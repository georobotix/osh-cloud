define(["exports","./GeometryOffsetAttribute-e8e698d7","./Transforms-62a339c3","./Matrix2-92b7fb9d","./ComponentDatatype-9ed50558","./CylinderGeometryLibrary-5924d4e5","./when-8166c7dd","./RuntimeError-4fdc4459","./GeometryAttribute-6f4c3b93","./GeometryAttributes-50becc99","./IndexDatatype-797210ca","./VertexFormat-c0801687"],(function(t,e,r,o,a,n,i,s,u,m,d,f){"use strict";var p=new o.Cartesian2,l=new o.Cartesian3,y=new o.Cartesian3,b=new o.Cartesian3,c=new o.Cartesian3;function v(t){t=i.defaultValue(t,i.defaultValue.EMPTY_OBJECT);var r=t.length,o=t.topRadius,a=t.bottomRadius,n=i.defaultValue(t.vertexFormat,f.VertexFormat.DEFAULT),u=i.defaultValue(t.slices,128);if(!i.defined(r))throw new s.DeveloperError("options.length must be defined.");if(!i.defined(o))throw new s.DeveloperError("options.topRadius must be defined.");if(!i.defined(a))throw new s.DeveloperError("options.bottomRadius must be defined.");if(u<3)throw new s.DeveloperError("options.slices must be greater than or equal to 3.");if(i.defined(t.offsetAttribute)&&t.offsetAttribute===e.GeometryOffsetAttribute.TOP)throw new s.DeveloperError("GeometryOffsetAttribute.TOP is not a supported options.offsetAttribute for this geometry.");this._length=r,this._topRadius=o,this._bottomRadius=a,this._vertexFormat=f.VertexFormat.clone(n),this._slices=u,this._offsetAttribute=t.offsetAttribute,this._workerName="createCylinderGeometry"}v.packedLength=f.VertexFormat.packedLength+5,v.pack=function(t,e,r){if(!i.defined(t))throw new s.DeveloperError("value is required");if(!i.defined(e))throw new s.DeveloperError("array is required");return r=i.defaultValue(r,0),f.VertexFormat.pack(t._vertexFormat,e,r),r+=f.VertexFormat.packedLength,e[r++]=t._length,e[r++]=t._topRadius,e[r++]=t._bottomRadius,e[r++]=t._slices,e[r]=i.defaultValue(t._offsetAttribute,-1),e};var A,h=new f.VertexFormat,w={vertexFormat:h,length:void 0,topRadius:void 0,bottomRadius:void 0,slices:void 0,offsetAttribute:void 0};v.unpack=function(t,e,r){if(!i.defined(t))throw new s.DeveloperError("array is required");e=i.defaultValue(e,0);var o=f.VertexFormat.unpack(t,e,h);e+=f.VertexFormat.packedLength;var a=t[e++],n=t[e++],u=t[e++],m=t[e++],d=t[e];return i.defined(r)?(r._vertexFormat=f.VertexFormat.clone(o,r._vertexFormat),r._length=a,r._topRadius=n,r._bottomRadius=u,r._slices=m,r._offsetAttribute=-1===d?void 0:d,r):(w.length=a,w.topRadius=n,w.bottomRadius=u,w.slices=m,w.offsetAttribute=-1===d?void 0:d,new v(w))},v.createGeometry=function(t){var s=t._length,f=t._topRadius,v=t._bottomRadius,A=t._vertexFormat,h=t._slices;if(!(s<=0||f<0||v<0||0===f&&0===v)){var w,g=h+h,x=h+g,_=g+g,F=n.CylinderGeometryLibrary.computePositions(s,f,v,h,!0),C=A.st?new Float32Array(2*_):void 0,D=A.normal?new Float32Array(3*_):void 0,G=A.tangent?new Float32Array(3*_):void 0,R=A.bitangent?new Float32Array(3*_):void 0,O=A.normal||A.tangent||A.bitangent;if(O){var E=A.tangent||A.bitangent,T=0,V=0,L=0,P=Math.atan2(v-f,s),M=l;M.z=Math.sin(P);var k=Math.cos(P),z=b,N=y;for(w=0;w<h;w++){var I=w/h*a.CesiumMath.TWO_PI,U=k*Math.cos(I),S=k*Math.sin(I);O&&(M.x=U,M.y=S,E&&(z=o.Cartesian3.normalize(o.Cartesian3.cross(o.Cartesian3.UNIT_Z,M,z),z)),A.normal&&(D[T++]=M.x,D[T++]=M.y,D[T++]=M.z,D[T++]=M.x,D[T++]=M.y,D[T++]=M.z),A.tangent&&(G[V++]=z.x,G[V++]=z.y,G[V++]=z.z,G[V++]=z.x,G[V++]=z.y,G[V++]=z.z),A.bitangent&&(N=o.Cartesian3.normalize(o.Cartesian3.cross(M,z,N),N),R[L++]=N.x,R[L++]=N.y,R[L++]=N.z,R[L++]=N.x,R[L++]=N.y,R[L++]=N.z))}for(w=0;w<h;w++)A.normal&&(D[T++]=0,D[T++]=0,D[T++]=-1),A.tangent&&(G[V++]=1,G[V++]=0,G[V++]=0),A.bitangent&&(R[L++]=0,R[L++]=-1,R[L++]=0);for(w=0;w<h;w++)A.normal&&(D[T++]=0,D[T++]=0,D[T++]=1),A.tangent&&(G[V++]=1,G[V++]=0,G[V++]=0),A.bitangent&&(R[L++]=0,R[L++]=1,R[L++]=0)}var q=12*h-12,B=d.IndexDatatype.createTypedArray(_,q),Y=0,Z=0;for(w=0;w<h-1;w++)B[Y++]=Z,B[Y++]=Z+2,B[Y++]=Z+3,B[Y++]=Z,B[Y++]=Z+3,B[Y++]=Z+1,Z+=2;for(B[Y++]=g-2,B[Y++]=0,B[Y++]=1,B[Y++]=g-2,B[Y++]=1,B[Y++]=g-1,w=1;w<h-1;w++)B[Y++]=g+w+1,B[Y++]=g+w,B[Y++]=g;for(w=1;w<h-1;w++)B[Y++]=x,B[Y++]=x+w,B[Y++]=x+w+1;var J=0;if(A.st){var W=Math.max(f,v);for(w=0;w<_;w++){var j=o.Cartesian3.fromArray(F,3*w,c);C[J++]=(j.x+W)/(2*W),C[J++]=(j.y+W)/(2*W)}}var H=new m.GeometryAttributes;A.position&&(H.position=new u.GeometryAttribute({componentDatatype:a.ComponentDatatype.DOUBLE,componentsPerAttribute:3,values:F})),A.normal&&(H.normal=new u.GeometryAttribute({componentDatatype:a.ComponentDatatype.FLOAT,componentsPerAttribute:3,values:D})),A.tangent&&(H.tangent=new u.GeometryAttribute({componentDatatype:a.ComponentDatatype.FLOAT,componentsPerAttribute:3,values:G})),A.bitangent&&(H.bitangent=new u.GeometryAttribute({componentDatatype:a.ComponentDatatype.FLOAT,componentsPerAttribute:3,values:R})),A.st&&(H.st=new u.GeometryAttribute({componentDatatype:a.ComponentDatatype.FLOAT,componentsPerAttribute:2,values:C})),p.x=.5*s,p.y=Math.max(v,f);var K=new r.BoundingSphere(o.Cartesian3.ZERO,o.Cartesian2.magnitude(p));if(i.defined(t._offsetAttribute)){s=F.length;var Q=new Uint8Array(s/3),X=t._offsetAttribute===e.GeometryOffsetAttribute.NONE?0:1;e.arrayFill(Q,X),H.applyOffset=new u.GeometryAttribute({componentDatatype:a.ComponentDatatype.UNSIGNED_BYTE,componentsPerAttribute:1,values:Q})}return new u.Geometry({attributes:H,indices:B,primitiveType:u.PrimitiveType.TRIANGLES,boundingSphere:K,offsetAttribute:t._offsetAttribute})}},v.getUnitCylinder=function(){return i.defined(A)||(A=v.createGeometry(new v({topRadius:1,bottomRadius:1,length:1,vertexFormat:f.VertexFormat.POSITION_ONLY}))),A},t.CylinderGeometry=v}));