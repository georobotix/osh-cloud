define(["./GeometryOffsetAttribute-e8e698d7","./arrayRemoveDuplicates-198208a4","./Transforms-62a339c3","./Matrix2-92b7fb9d","./RuntimeError-4fdc4459","./ComponentDatatype-9ed50558","./PolylineVolumeGeometryLibrary-b9fa2b05","./CorridorGeometryLibrary-143e6a2e","./when-8166c7dd","./GeometryAttribute-6f4c3b93","./GeometryAttributes-50becc99","./IndexDatatype-797210ca","./PolygonPipeline-7fb6627c","./VertexFormat-c0801687","./combine-a5c4cc47","./WebGLConstants-0664004c","./EllipsoidTangentPlane-5d8b4bd3","./AxisAlignedBoundingBox-b0cd1e39","./IntersectionTests-4f28a69c","./Plane-049255eb","./PolylinePipeline-fd9260c9","./EllipsoidGeodesic-133bd147","./EllipsoidRhumbLine-51654311"],(function(t,e,r,a,i,o,n,s,l,d,u,m,f,y,c,p,h,g,C,b,v,A,_){"use strict";var w=new a.Cartesian3,T=new a.Cartesian3,G=new a.Cartesian3,E=new a.Cartesian3,V=new a.Cartesian3,x=new a.Cartesian3,F=new a.Cartesian3,L=new a.Cartesian3;function P(t,e){for(var r=0;r<t.length;r++)t[r]=e.scaleToGeodeticSurface(t[r],t[r]);return t}function N(t,e,r,i,o,n){var l=t.normals,d=t.tangents,u=t.bitangents,m=a.Cartesian3.normalize(a.Cartesian3.cross(r,e,F),F);n.normal&&s.CorridorGeometryLibrary.addAttribute(l,e,i,o),n.tangent&&s.CorridorGeometryLibrary.addAttribute(d,m,i,o),n.bitangent&&s.CorridorGeometryLibrary.addAttribute(u,r,i,o)}function D(t,e,r){var i,n,f,y=t.positions,c=t.corners,p=t.endPositions,h=t.lefts,g=t.normals,C=new u.GeometryAttributes,b=0,v=0,A=0;for(n=0;n<y.length;n+=2)f=y[n].length-3,b+=f,A+=2*f,v+=y[n+1].length-3;for(b+=3,v+=3,n=0;n<c.length;n++){i=c[n];var _=c[n].leftPositions;l.defined(_)?(f=_.length,b+=f,A+=f):(f=c[n].rightPositions.length,v+=f,A+=f)}var V,P=l.defined(p);P&&(V=p[0].length-3,b+=V,v+=V,V/=3,A+=6*V);var D,M,O,I,k,S,R=b+v,H=new Float64Array(R),z=e.normal?new Float32Array(R):void 0,B=e.tangent?new Float32Array(R):void 0,U=e.bitangent?new Float32Array(R):void 0,Y={normals:z,tangents:B,bitangents:U},W=0,q=R-1,J=w,j=T,K=V/2,Q=m.IndexDatatype.createTypedArray(R/3,A),X=0;if(P){S=G,k=E;var Z=p[0];for(J=a.Cartesian3.fromArray(g,0,J),j=a.Cartesian3.fromArray(h,0,j),n=0;n<K;n++)S=a.Cartesian3.fromArray(Z,3*(K-1-n),S),k=a.Cartesian3.fromArray(Z,3*(K+n),k),s.CorridorGeometryLibrary.addAttribute(H,k,W),s.CorridorGeometryLibrary.addAttribute(H,S,void 0,q),N(Y,J,j,W,q,e),M=W/3,I=M+1,D=(q-2)/3,O=D-1,Q[X++]=D,Q[X++]=M,Q[X++]=O,Q[X++]=O,Q[X++]=M,Q[X++]=I,W+=3,q-=3}var $,tt,et=0,rt=0,at=y[et++],it=y[et++];for(H.set(at,W),H.set(it,q-it.length+1),j=a.Cartesian3.fromArray(h,rt,j),f=it.length-3,n=0;n<f;n+=3)$=r.geodeticSurfaceNormal(a.Cartesian3.fromArray(at,n,F),F),tt=r.geodeticSurfaceNormal(a.Cartesian3.fromArray(it,f-n,L),L),J=a.Cartesian3.normalize(a.Cartesian3.add($,tt,J),J),N(Y,J,j,W,q,e),M=W/3,I=M+1,D=(q-2)/3,O=D-1,Q[X++]=D,Q[X++]=M,Q[X++]=O,Q[X++]=O,Q[X++]=M,Q[X++]=I,W+=3,q-=3;for($=r.geodeticSurfaceNormal(a.Cartesian3.fromArray(at,f,F),F),tt=r.geodeticSurfaceNormal(a.Cartesian3.fromArray(it,f,L),L),J=a.Cartesian3.normalize(a.Cartesian3.add($,tt,J),J),rt+=3,n=0;n<c.length;n++){var ot;i=c[n];var nt,st,lt=i.leftPositions,dt=i.rightPositions,ut=x,mt=G,ft=E;if(J=a.Cartesian3.fromArray(g,rt,J),l.defined(lt)){for(N(Y,J,j,void 0,q,e),q-=3,nt=I,st=O,ot=0;ot<lt.length/3;ot++)ut=a.Cartesian3.fromArray(lt,3*ot,ut),Q[X++]=nt,Q[X++]=st-ot-1,Q[X++]=st-ot,s.CorridorGeometryLibrary.addAttribute(H,ut,void 0,q),mt=a.Cartesian3.fromArray(H,3*(st-ot-1),mt),ft=a.Cartesian3.fromArray(H,3*nt,ft),j=a.Cartesian3.normalize(a.Cartesian3.subtract(mt,ft,j),j),N(Y,J,j,void 0,q,e),q-=3;ut=a.Cartesian3.fromArray(H,3*nt,ut),mt=a.Cartesian3.subtract(a.Cartesian3.fromArray(H,3*st,mt),ut,mt),ft=a.Cartesian3.subtract(a.Cartesian3.fromArray(H,3*(st-ot),ft),ut,ft),j=a.Cartesian3.normalize(a.Cartesian3.add(mt,ft,j),j),N(Y,J,j,W,void 0,e),W+=3}else{for(N(Y,J,j,W,void 0,e),W+=3,nt=O,st=I,ot=0;ot<dt.length/3;ot++)ut=a.Cartesian3.fromArray(dt,3*ot,ut),Q[X++]=nt,Q[X++]=st+ot,Q[X++]=st+ot+1,s.CorridorGeometryLibrary.addAttribute(H,ut,W),mt=a.Cartesian3.fromArray(H,3*nt,mt),ft=a.Cartesian3.fromArray(H,3*(st+ot),ft),j=a.Cartesian3.normalize(a.Cartesian3.subtract(mt,ft,j),j),N(Y,J,j,W,void 0,e),W+=3;ut=a.Cartesian3.fromArray(H,3*nt,ut),mt=a.Cartesian3.subtract(a.Cartesian3.fromArray(H,3*(st+ot),mt),ut,mt),ft=a.Cartesian3.subtract(a.Cartesian3.fromArray(H,3*st,ft),ut,ft),j=a.Cartesian3.normalize(a.Cartesian3.negate(a.Cartesian3.add(ft,mt,j),j),j),N(Y,J,j,void 0,q,e),q-=3}for(at=y[et++],it=y[et++],at.splice(0,3),it.splice(it.length-3,3),H.set(at,W),H.set(it,q-it.length+1),f=it.length-3,rt+=3,j=a.Cartesian3.fromArray(h,rt,j),ot=0;ot<it.length;ot+=3)$=r.geodeticSurfaceNormal(a.Cartesian3.fromArray(at,ot,F),F),tt=r.geodeticSurfaceNormal(a.Cartesian3.fromArray(it,f-ot,L),L),J=a.Cartesian3.normalize(a.Cartesian3.add($,tt,J),J),N(Y,J,j,W,q,e),I=W/3,M=I-1,O=(q-2)/3,D=O+1,Q[X++]=D,Q[X++]=M,Q[X++]=O,Q[X++]=O,Q[X++]=M,Q[X++]=I,W+=3,q-=3;W-=3,q+=3}if(J=a.Cartesian3.fromArray(g,g.length-3,J),N(Y,J,j,W,q,e),P){W+=3,q-=3,S=G,k=E;var yt=p[1];for(n=0;n<K;n++)S=a.Cartesian3.fromArray(yt,3*(V-n-1),S),k=a.Cartesian3.fromArray(yt,3*n,k),s.CorridorGeometryLibrary.addAttribute(H,S,void 0,q),s.CorridorGeometryLibrary.addAttribute(H,k,W),N(Y,J,j,W,q,e),I=W/3,M=I-1,O=(q-2)/3,D=O+1,Q[X++]=D,Q[X++]=M,Q[X++]=O,Q[X++]=O,Q[X++]=M,Q[X++]=I,W+=3,q-=3}if(C.position=new d.GeometryAttribute({componentDatatype:o.ComponentDatatype.DOUBLE,componentsPerAttribute:3,values:H}),e.st){var ct,pt,ht=new Float32Array(R/3*2),gt=0;if(P){b/=3,v/=3;var Ct,bt=Math.PI/(V+1);pt=1/(b-V+1),ct=1/(v-V+1);var vt=V/2;for(n=vt+1;n<V+1;n++)Ct=o.CesiumMath.PI_OVER_TWO+bt*n,ht[gt++]=ct*(1+Math.cos(Ct)),ht[gt++]=.5*(1+Math.sin(Ct));for(n=1;n<v-V+1;n++)ht[gt++]=n*ct,ht[gt++]=0;for(n=V;n>vt;n--)Ct=o.CesiumMath.PI_OVER_TWO-n*bt,ht[gt++]=1-ct*(1+Math.cos(Ct)),ht[gt++]=.5*(1+Math.sin(Ct));for(n=vt;n>0;n--)Ct=o.CesiumMath.PI_OVER_TWO-bt*n,ht[gt++]=1-pt*(1+Math.cos(Ct)),ht[gt++]=.5*(1+Math.sin(Ct));for(n=b-V;n>0;n--)ht[gt++]=n*pt,ht[gt++]=1;for(n=1;n<vt+1;n++)Ct=o.CesiumMath.PI_OVER_TWO+bt*n,ht[gt++]=pt*(1+Math.cos(Ct)),ht[gt++]=.5*(1+Math.sin(Ct))}else{for(b/=3,v/=3,pt=1/(b-1),ct=1/(v-1),n=0;n<v;n++)ht[gt++]=n*ct,ht[gt++]=0;for(n=b;n>0;n--)ht[gt++]=(n-1)*pt,ht[gt++]=1}C.st=new d.GeometryAttribute({componentDatatype:o.ComponentDatatype.FLOAT,componentsPerAttribute:2,values:ht})}return e.normal&&(C.normal=new d.GeometryAttribute({componentDatatype:o.ComponentDatatype.FLOAT,componentsPerAttribute:3,values:Y.normals})),e.tangent&&(C.tangent=new d.GeometryAttribute({componentDatatype:o.ComponentDatatype.FLOAT,componentsPerAttribute:3,values:Y.tangents})),e.bitangent&&(C.bitangent=new d.GeometryAttribute({componentDatatype:o.ComponentDatatype.FLOAT,componentsPerAttribute:3,values:Y.bitangents})),{attributes:C,indices:Q}}function M(t,e){if(!e.normal&&!e.tangent&&!e.bitangent&&!e.st)return t;var r,i,o=t.position.values;(e.normal||e.bitangent)&&(r=t.normal.values,i=t.bitangent.values);var n,l=t.position.values.length/18,d=3*l,u=2*l,m=2*d;if(e.normal||e.bitangent||e.tangent){var f=e.normal?new Float32Array(6*d):void 0,y=e.tangent?new Float32Array(6*d):void 0,c=e.bitangent?new Float32Array(6*d):void 0,p=w,h=T,g=G,C=E,b=V,v=x,A=m;for(n=0;n<d;n+=3){var _=A+m;p=a.Cartesian3.fromArray(o,n,p),h=a.Cartesian3.fromArray(o,n+d,h),g=a.Cartesian3.fromArray(o,(n+3)%d,g),h=a.Cartesian3.subtract(h,p,h),g=a.Cartesian3.subtract(g,p,g),C=a.Cartesian3.normalize(a.Cartesian3.cross(h,g,C),C),e.normal&&(s.CorridorGeometryLibrary.addAttribute(f,C,_),s.CorridorGeometryLibrary.addAttribute(f,C,_+3),s.CorridorGeometryLibrary.addAttribute(f,C,A),s.CorridorGeometryLibrary.addAttribute(f,C,A+3)),(e.tangent||e.bitangent)&&(v=a.Cartesian3.fromArray(r,n,v),e.bitangent&&(s.CorridorGeometryLibrary.addAttribute(c,v,_),s.CorridorGeometryLibrary.addAttribute(c,v,_+3),s.CorridorGeometryLibrary.addAttribute(c,v,A),s.CorridorGeometryLibrary.addAttribute(c,v,A+3)),e.tangent&&(b=a.Cartesian3.normalize(a.Cartesian3.cross(v,C,b),b),s.CorridorGeometryLibrary.addAttribute(y,b,_),s.CorridorGeometryLibrary.addAttribute(y,b,_+3),s.CorridorGeometryLibrary.addAttribute(y,b,A),s.CorridorGeometryLibrary.addAttribute(y,b,A+3))),A+=6}if(e.normal){for(f.set(r),n=0;n<d;n+=3)f[n+d]=-r[n],f[n+d+1]=-r[n+1],f[n+d+2]=-r[n+2];t.normal.values=f}else t.normal=void 0;if(e.bitangent?(c.set(i),c.set(i,d),t.bitangent.values=c):t.bitangent=void 0,e.tangent){var F=t.tangent.values;y.set(F),y.set(F,d),t.tangent.values=y}}if(e.st){var L=t.st.values,P=new Float32Array(6*u);P.set(L),P.set(L,u);for(var N=2*u,D=0;D<2;D++){for(P[N++]=L[0],P[N++]=L[1],n=2;n<u;n+=2){var M=L[n],O=L[n+1];P[N++]=M,P[N++]=O,P[N++]=M,P[N++]=O}P[N++]=L[0],P[N++]=L[1]}t.st.values=P}return t}function O(t,e,r){r[e++]=t[0],r[e++]=t[1],r[e++]=t[2];for(var a=3;a<t.length;a+=3){var i=t[a],o=t[a+1],n=t[a+2];r[e++]=i,r[e++]=o,r[e++]=n,r[e++]=i,r[e++]=o,r[e++]=n}return r[e++]=t[0],r[e++]=t[1],r[e++]=t[2],r}function I(e,r){var a=new y.VertexFormat({position:r.position,normal:r.normal||r.bitangent||e.shadowVolume,tangent:r.tangent,bitangent:r.normal||r.bitangent,st:r.st}),i=e.ellipsoid,n=s.CorridorGeometryLibrary.computePositions(e),u=D(n,a,i),c=e.height,p=e.extrudedHeight,h=u.attributes,g=u.indices,C=h.position.values,b=C.length,v=new Float64Array(6*b),A=new Float64Array(b);A.set(C);var _,w=new Float64Array(4*b);C=f.PolygonPipeline.scaleToGeodeticHeight(C,c,i),w=O(C,0,w),A=f.PolygonPipeline.scaleToGeodeticHeight(A,p,i),w=O(A,2*b,w),v.set(C),v.set(A,b),v.set(w,2*b),h.position.values=v,h=M(h,r);var T=b/3;if(e.shadowVolume){var G=h.normal.values;b=G.length;var E=new Float32Array(6*b);for(_=0;_<b;_++)G[_]=-G[_];E.set(G,b),E=O(G,4*b,E),h.extrudeDirection=new d.GeometryAttribute({componentDatatype:o.ComponentDatatype.FLOAT,componentsPerAttribute:3,values:E}),r.normal||(h.normal=void 0)}if(l.defined(e.offsetAttribute)){var V=new Uint8Array(6*T);if(e.offsetAttribute===t.GeometryOffsetAttribute.TOP)V=t.arrayFill(V,1,0,T),V=t.arrayFill(V,1,2*T,4*T);else{var x=e.offsetAttribute===t.GeometryOffsetAttribute.NONE?0:1;V=t.arrayFill(V,x)}h.applyOffset=new d.GeometryAttribute({componentDatatype:o.ComponentDatatype.UNSIGNED_BYTE,componentsPerAttribute:1,values:V})}var F=g.length,L=T+T,P=m.IndexDatatype.createTypedArray(v.length/3,2*F+3*L);P.set(g);var N,I,k,S,R=F;for(_=0;_<F;_+=3){var H=g[_],z=g[_+1],B=g[_+2];P[R++]=B+T,P[R++]=z+T,P[R++]=H+T}for(_=0;_<L;_+=2)N=_+L,I=N+L,k=N+1,S=I+1,P[R++]=N,P[R++]=I,P[R++]=k,P[R++]=k,P[R++]=I,P[R++]=S;return{attributes:h,indices:P}}var k=new a.Cartesian3,S=new a.Cartesian3,R=new a.Cartographic;function H(t,e,r,i,o,n){var s=a.Cartesian3.subtract(e,t,k);a.Cartesian3.normalize(s,s);var l=r.geodeticSurfaceNormal(t,S),d=a.Cartesian3.cross(s,l,k);a.Cartesian3.multiplyByScalar(d,i,d);var u=o.latitude,m=o.longitude,f=n.latitude,y=n.longitude;a.Cartesian3.add(t,d,S),r.cartesianToCartographic(S,R);var c=R.latitude,p=R.longitude;u=Math.min(u,c),m=Math.min(m,p),f=Math.max(f,c),y=Math.max(y,p),a.Cartesian3.subtract(t,d,S),r.cartesianToCartographic(S,R),c=R.latitude,p=R.longitude,u=Math.min(u,c),m=Math.min(m,p),f=Math.max(f,c),y=Math.max(y,p),o.latitude=u,o.longitude=m,n.latitude=f,n.longitude=y}var z=new a.Cartesian3,B=new a.Cartesian3,U=new a.Cartographic,Y=new a.Cartographic;function W(t,r,i,o,s){t=P(t,r);var d=e.arrayRemoveDuplicates(t,a.Cartesian3.equalsEpsilon),u=d.length;if(u<2||i<=0)return new a.Rectangle;var m,f,y=.5*i;if(U.latitude=Number.POSITIVE_INFINITY,U.longitude=Number.POSITIVE_INFINITY,Y.latitude=Number.NEGATIVE_INFINITY,Y.longitude=Number.NEGATIVE_INFINITY,o===n.CornerType.ROUNDED){var c=d[0];a.Cartesian3.subtract(c,d[1],z),a.Cartesian3.normalize(z,z),a.Cartesian3.multiplyByScalar(z,y,z),a.Cartesian3.add(c,z,B),r.cartesianToCartographic(B,R),m=R.latitude,f=R.longitude,U.latitude=Math.min(U.latitude,m),U.longitude=Math.min(U.longitude,f),Y.latitude=Math.max(Y.latitude,m),Y.longitude=Math.max(Y.longitude,f)}for(var p=0;p<u-1;++p)H(d[p],d[p+1],r,y,U,Y);var h=d[u-1];a.Cartesian3.subtract(h,d[u-2],z),a.Cartesian3.normalize(z,z),a.Cartesian3.multiplyByScalar(z,y,z),a.Cartesian3.add(h,z,B),H(h,B,r,y,U,Y),o===n.CornerType.ROUNDED&&(r.cartesianToCartographic(B,R),m=R.latitude,f=R.longitude,U.latitude=Math.min(U.latitude,m),U.longitude=Math.min(U.longitude,f),Y.latitude=Math.max(Y.latitude,m),Y.longitude=Math.max(Y.longitude,f));var g=l.defined(s)?s:new a.Rectangle;return g.north=Y.latitude,g.south=U.latitude,g.east=Y.longitude,g.west=U.longitude,g}function q(t){t=l.defaultValue(t,l.defaultValue.EMPTY_OBJECT);var e=t.positions,r=t.width;i.Check.defined("options.positions",e),i.Check.defined("options.width",r);var s=l.defaultValue(t.height,0),d=l.defaultValue(t.extrudedHeight,s);this._positions=e,this._ellipsoid=a.Ellipsoid.clone(l.defaultValue(t.ellipsoid,a.Ellipsoid.WGS84)),this._vertexFormat=y.VertexFormat.clone(l.defaultValue(t.vertexFormat,y.VertexFormat.DEFAULT)),this._width=r,this._height=Math.max(s,d),this._extrudedHeight=Math.min(s,d),this._cornerType=l.defaultValue(t.cornerType,n.CornerType.ROUNDED),this._granularity=l.defaultValue(t.granularity,o.CesiumMath.RADIANS_PER_DEGREE),this._shadowVolume=l.defaultValue(t.shadowVolume,!1),this._workerName="createCorridorGeometry",this._offsetAttribute=t.offsetAttribute,this._rectangle=void 0,this.packedLength=1+e.length*a.Cartesian3.packedLength+a.Ellipsoid.packedLength+y.VertexFormat.packedLength+7}q.pack=function(t,e,r){i.Check.defined("value",t),i.Check.defined("array",e),r=l.defaultValue(r,0);var o=t._positions,n=o.length;e[r++]=n;for(var s=0;s<n;++s,r+=a.Cartesian3.packedLength)a.Cartesian3.pack(o[s],e,r);return a.Ellipsoid.pack(t._ellipsoid,e,r),r+=a.Ellipsoid.packedLength,y.VertexFormat.pack(t._vertexFormat,e,r),r+=y.VertexFormat.packedLength,e[r++]=t._width,e[r++]=t._height,e[r++]=t._extrudedHeight,e[r++]=t._cornerType,e[r++]=t._granularity,e[r++]=t._shadowVolume?1:0,e[r]=l.defaultValue(t._offsetAttribute,-1),e};var J=a.Ellipsoid.clone(a.Ellipsoid.UNIT_SPHERE),j=new y.VertexFormat,K={positions:void 0,ellipsoid:J,vertexFormat:j,width:void 0,height:void 0,extrudedHeight:void 0,cornerType:void 0,granularity:void 0,shadowVolume:void 0,offsetAttribute:void 0};function Q(t,e){return l.defined(e)&&(t=q.unpack(t,e)),t._ellipsoid=a.Ellipsoid.clone(t._ellipsoid),q.createGeometry(t)}return q.unpack=function(t,e,r){i.Check.defined("array",t),e=l.defaultValue(e,0);for(var o=t[e++],n=new Array(o),s=0;s<o;++s,e+=a.Cartesian3.packedLength)n[s]=a.Cartesian3.unpack(t,e);var d=a.Ellipsoid.unpack(t,e,J);e+=a.Ellipsoid.packedLength;var u=y.VertexFormat.unpack(t,e,j);e+=y.VertexFormat.packedLength;var m=t[e++],f=t[e++],c=t[e++],p=t[e++],h=t[e++],g=1===t[e++],C=t[e];return l.defined(r)?(r._positions=n,r._ellipsoid=a.Ellipsoid.clone(d,r._ellipsoid),r._vertexFormat=y.VertexFormat.clone(u,r._vertexFormat),r._width=m,r._height=f,r._extrudedHeight=c,r._cornerType=p,r._granularity=h,r._shadowVolume=g,r._offsetAttribute=-1===C?void 0:C,r):(K.positions=n,K.width=m,K.height=f,K.extrudedHeight=c,K.cornerType=p,K.granularity=h,K.shadowVolume=g,K.offsetAttribute=-1===C?void 0:C,new q(K))},q.computeRectangle=function(t,e){t=l.defaultValue(t,l.defaultValue.EMPTY_OBJECT);var r=t.positions,o=t.width;i.Check.defined("options.positions",r),i.Check.defined("options.width",o);var s=l.defaultValue(t.ellipsoid,a.Ellipsoid.WGS84),d=l.defaultValue(t.cornerType,n.CornerType.ROUNDED);return W(r,s,o,d,e)},q.createGeometry=function(i){var n=i._positions,u=i._width,m=i._ellipsoid;n=P(n,m);var y=e.arrayRemoveDuplicates(n,a.Cartesian3.equalsEpsilon);if(!(y.length<2||u<=0)){var c,p=i._height,h=i._extrudedHeight,g=!o.CesiumMath.equalsEpsilon(p,h,0,o.CesiumMath.EPSILON2),C=i._vertexFormat,b={ellipsoid:m,positions:y,width:u,cornerType:i._cornerType,granularity:i._granularity,saveAttributes:!0};if(g)b.height=p,b.extrudedHeight=h,b.shadowVolume=i._shadowVolume,b.offsetAttribute=i._offsetAttribute,c=I(b,C);else{var v=s.CorridorGeometryLibrary.computePositions(b);if(c=D(v,C,m),c.attributes.position.values=f.PolygonPipeline.scaleToGeodeticHeight(c.attributes.position.values,p,m),l.defined(i._offsetAttribute)){var A=i._offsetAttribute===t.GeometryOffsetAttribute.NONE?0:1,_=c.attributes.position.values.length,w=new Uint8Array(_/3);t.arrayFill(w,A),c.attributes.applyOffset=new d.GeometryAttribute({componentDatatype:o.ComponentDatatype.UNSIGNED_BYTE,componentsPerAttribute:1,values:w})}}var T=c.attributes,G=r.BoundingSphere.fromVertices(T.position.values,void 0,3);return C.position||(c.attributes.position.values=void 0),new d.Geometry({attributes:T,indices:c.indices,primitiveType:d.PrimitiveType.TRIANGLES,boundingSphere:G,offsetAttribute:i._offsetAttribute})}},q.createShadowVolume=function(t,e,r){var a=t._granularity,i=t._ellipsoid,o=e(a,i),n=r(a,i);return new q({positions:t._positions,width:t._width,cornerType:t._cornerType,ellipsoid:i,granularity:a,extrudedHeight:o,height:n,vertexFormat:y.VertexFormat.POSITION_ONLY,shadowVolume:!0})},Object.defineProperties(q.prototype,{rectangle:{get:function(){return l.defined(this._rectangle)||(this._rectangle=W(this._positions,this._ellipsoid,this._width,this._cornerType)),this._rectangle}},textureCoordinateRotationPoints:{get:function(){return[0,0,0,1,1,0]}}}),Q}));