"use strict";(self["webpackChunkvue3_webpack5"]=self["webpackChunkvue3_webpack5"]||[]).push([[9989],{81326:function(e,n,t){t.d(n,{Z:function(){return r}});var o=t(82982);function r(e,n){return(0,o.Z)(e)&&(0,o.Z)(e.extensions)&&(0,o.Z)(e.extensions[n])}},47548:function(e,n,t){var o=t(66553),r=t(82982),a=t(11954),i=t(9407),s=t(40384),l=t(50851),c=t(59875),u=t(17041),f=t(88893),_=t(40914),v=t(14358);function m(e){o.Z.typeOf.number("options.count",e.count),o.Z.typeOf.object("options.batchTable",e.batchTable);var n=e.count,t=e.batchTable,r=e.binaryBody,a=d(t),i=new f.Z({count:n,properties:a.jsonProperties}),s=x(a.hierarchy,r),u=p(n,a.binaryProperties,r),_=u.featureTableJson,m=new v.Z({count:_.count,properties:_.properties,class:u.transcodedClass,bufferViews:u.bufferViewsU8}),h={_batchTable:new c.Z({count:_.count,metadataTable:m,jsonMetadataTable:i,batchTableHierarchy:s})};return new l.Z({schema:u.transcodedSchema,featureTables:h,extensions:a.extensions,extras:a.extras})}function d(e){var n,t=e.HIERARCHY,o=e.extras,a=e.extensions;(0,r.Z)(t)?(m._deprecationWarning("batchTableHierarchyExtension","The batch table HIERARCHY property has been moved to an extension. Use extensions.3DTILES_batch_table_hierarchy instead."),n=t):(0,r.Z)(a)&&(n=a["3DTILES_batch_table_hierarchy"]);var i={},s={};for(var l in e)if(e.hasOwnProperty(l)&&"HIERARCHY"!==l&&"extensions"!==l&&"extras"!==l){var c=e[l];Array.isArray(c)?i[l]=c:s[l]=c}return{binaryProperties:s,jsonProperties:i,hierarchy:n,extras:o,extensions:a}}function p(e,n,t){var o={},a={},s={},l=0;for(var c in n)if(n.hasOwnProperty(c)){if(!(0,r.Z)(t))throw new i.Z("Property "+c+" requires a batch table binary.");var f=n[c],v=(0,u.Z)(f);a[c]={bufferView:l},o[c]=h(f),s[l]=v.createArrayBufferView(t.buffer,t.byteOffset+f.byteOffset,e),l++}var m={classes:{_batchTable:{properties:o}}},d=new _.Z(m),p={class:"_batchTable",count:e,properties:a};return{featureTableJson:p,bufferViewsU8:s,transcodedSchema:d,transcodedClass:d.classes._batchTable}}function h(e){var n=g(e.componentType),t=e.type;if("SCALAR"===t)return{type:n};var o=parseInt(t.charAt(3));return{type:"ARRAY",componentType:n,componentCount:o}}function g(e){switch(e){case"BYTE":return"INT8";case"UNSIGNED_BYTE":return"UINT8";case"SHORT":return"INT16";case"UNSIGNED_SHORT":return"UINT16";case"INT":return"INT32";case"UNSIGNED_INT":return"UINT32";case"FLOAT":return"FLOAT32";case"DOUBLE":return"FLOAT64"}}function x(e,n){if((0,r.Z)(e))return new s.Z({extension:e,binaryBody:n})}m._deprecationWarning=a.Z},19661:function(e,n,t){t.d(n,{Z:function(){return a}});var o=t(66553),r=t(82982);function a(e){return o.Z.typeOf.object("tileMetadata",e),{tile:{boundingVolume:i("TILE",e),minimumHeight:s("TILE",e),maximumHeight:l("TILE",e)},content:{boundingVolume:i("CONTENT",e),minimumHeight:s("CONTENT",e),maximumHeight:l("CONTENT",e)}}}function i(e,n){var t=e+"_BOUNDING_BOX",o=n.getPropertyBySemantic(t);if((0,r.Z)(o))return{box:o};var a=e+"_BOUNDING_REGION",i=n.getPropertyBySemantic(a);if((0,r.Z)(i))return{region:i};var s=e+"_BOUNDING_SPHERE",l=n.getPropertyBySemantic(s);return(0,r.Z)(l)?{sphere:[l.x,l.y,l.z,l.w]}:void 0}function s(e,n){var t=e+"_MINIMUM_HEIGHT";return n.getPropertyBySemantic(t)}function l(e,n){var t=e+"_MAXIMUM_HEIGHT";return n.getPropertyBySemantic(t)}},25821:function(e,n,t){t.d(n,{Z:function(){return u}});var o=t(66553),r=t(62200),a=t(82982),i=t(59875),s=t(67266),l=t(50851),c=t(14358);function u(e){e=(0,r.Z)(e,r.Z.EMPTY_OBJECT);var n=e.extension,t=e.schema;o.Z.typeOf.object("options.extension",n),o.Z.typeOf.object("options.schema",t);var u={};if((0,a.Z)(n.featureTables))for(var f in n.featureTables)if(n.featureTables.hasOwnProperty(f)){var _=n.featureTables[f],v=t.classes[_.class],m=new c.Z({count:_.count,properties:_.properties,class:v,bufferViews:e.bufferViews});u[f]=new i.Z({count:_.count,metadataTable:m,extras:_.extras,extensions:_.extensions})}var d={};if((0,a.Z)(n.featureTextures))for(var p in n.featureTextures)if(n.featureTextures.hasOwnProperty(p)){var h=n.featureTextures[p];d[p]=new s.Z({featureTexture:h,class:t.classes[h.class],textures:e.textures})}return new l.Z({schema:t,featureTables:u,featureTextures:d,statistics:n.statistics,extras:n.extras,extensions:n.extensions})}},16240:function(e,n,t){t.d(n,{Z:function(){return l}});var o=t(82982),r=t(12540),a=t(3020),i=t(9407),s=t(41059);function l(e){var n=new Uint8Array(e),t=(0,a.Z)(n);if("glTF"===t&&(t="glb"),s.Z.isBinaryFormat(t))return{contentType:t,binaryPayload:n};var r=c(n);if((0,o.Z)(r.root))return{contentType:s.Z.EXTERNAL_TILESET,jsonPayload:r};if((0,o.Z)(r.asset))return{contentType:s.Z.GLTF,jsonPayload:r};throw new i.Z("Invalid tile content.")}function c(e){var n;try{n=(0,r.Z)(e)}catch(t){throw new i.Z("Invalid tile content.")}return n}},51240:function(e,n,t){var o=t(62200),r=t(82982),a=t(52200),i=t(37231),s=t(9919),l=t(56629),c=t(29745),u=t(15322);function f(e,n){if(n=(0,o.Z)(n,o.Z.EMPTY_OBJECT),(0,r.Z)(e)&&(0,c.Z)(e,"KHR_materials_common")){(0,c.Z)(e,"KHR_techniques_webgl")||((0,r.Z)(e.extensions)||(e.extensions={}),e.extensions.KHR_techniques_webgl={programs:[],shaders:[],techniques:[]},e.extensionsUsed.push("KHR_techniques_webgl"),e.extensionsRequired.push("KHR_techniques_webgl"));var t=e.extensions.KHR_techniques_webgl;p(e);var a=_(e),i=u.Z.splitIncompatibleMaterials(e),s={},f=!1;return l.Z.material(e,(function(o,l){if((0,r.Z)(o.extensions)&&(0,r.Z)(o.extensions.KHR_materials_common)){var c=o.extensions.KHR_materials_common,u=i[l],_=d(c,u),m=s[_];(0,r.Z)(m)||(m=v(e,t,u,c,a,n.addBatchIdToGeneratedShaders),s[_]=m,f=!0);var p,h={},g=c.values;for(var x in g)g.hasOwnProperty(x)&&"transparent"!==x&&"doubleSided"!==x&&(p="u_"+x.toLowerCase(),h[p]=g[x]);o.extensions.KHR_techniques_webgl={technique:m,values:h},o.alphaMode="OPAQUE",c.transparent&&(o.alphaMode="BLEND"),c.doubleSided&&(o.doubleSided=!0)}})),f?(u.Z.ensureSemanticExistence(e),e):e}}function _(e){var n,t={};if((0,r.Z)(e.extensions)&&(0,r.Z)(e.extensions.KHR_materials_common)&&(n=e.extensions.KHR_materials_common.lights),(0,r.Z)(n)){var o=e.nodes;for(var i in o)if(o.hasOwnProperty(i)){var s=o[i];if((0,r.Z)(s.extensions)&&(0,r.Z)(s.extensions.KHR_materials_common)){var l=s.extensions.KHR_materials_common.light;(0,r.Z)(l)&&(0,r.Z)(n[l])&&(n[l].node=i),delete s.extensions.KHR_materials_common}}var c=0;for(var u in n)if(n.hasOwnProperty(u)){var f=n[u],_=f.type;if("ambient"!==_&&!(0,r.Z)(f.node)){delete n[u];continue}var v="light"+c.toString();switch(f.baseName=v,_){case"ambient":var m=f.ambient;t[v+"Color"]={type:a.Z.FLOAT_VEC3,value:m.color};break;case"directional":var d=f.directional;t[v+"Color"]={type:a.Z.FLOAT_VEC3,value:d.color},(0,r.Z)(f.node)&&(t[v+"Transform"]={node:f.node,semantic:"MODELVIEW",type:a.Z.FLOAT_MAT4});break;case"point":var p=f.point;t[v+"Color"]={type:a.Z.FLOAT_VEC3,value:p.color},(0,r.Z)(f.node)&&(t[v+"Transform"]={node:f.node,semantic:"MODELVIEW",type:a.Z.FLOAT_MAT4}),t[v+"Attenuation"]={type:a.Z.FLOAT_VEC3,value:[p.constantAttenuation,p.linearAttenuation,p.quadraticAttenuation]};break;case"spot":var h=f.spot;t[v+"Color"]={type:a.Z.FLOAT_VEC3,value:h.color},(0,r.Z)(f.node)&&(t[v+"Transform"]={node:f.node,semantic:"MODELVIEW",type:a.Z.FLOAT_MAT4},t[v+"InverseTransform"]={node:f.node,semantic:"MODELVIEWINVERSE",type:a.Z.FLOAT_MAT4,useInFragment:!0}),t[v+"Attenuation"]={type:a.Z.FLOAT_VEC3,value:[h.constantAttenuation,h.linearAttenuation,h.quadraticAttenuation]},t[v+"FallOff"]={type:a.Z.FLOAT_VEC2,value:[h.fallOffAngle,h.fallOffExponent]};break}++c}}return t}function v(e,n,t,l,u,f){(0,r.Z)(l)||(l={}),f=(0,o.Z)(f,!1);var _,v=n.techniques,d=n.shaders,p=n.programs,h=l.technique.toUpperCase();(0,r.Z)(e.extensions)&&(0,r.Z)(e.extensions.KHR_materials_common)&&(_=e.extensions.KHR_materials_common.lights);var g,x=l.values,b=(0,o.Z)(l.jointCount,0),Z=!1,T=!1;(0,r.Z)(t)&&(g=t.skinning,Z=g.skinned,T=t.hasVertexColors);var C,y="precision highp float;\n",O="precision highp float;\n",E="CONSTANT"!==h,L={u_modelViewMatrix:{semantic:(0,c.Z)(e,"CESIUM_RTC")?"CESIUM_RTC_MODELVIEW":"MODELVIEW",type:a.Z.FLOAT_MAT4},u_projectionMatrix:{semantic:"PROJECTION",type:a.Z.FLOAT_MAT4}};E&&(L.u_normalMatrix={semantic:"MODELVIEWINVERSETRANSPOSE",type:a.Z.FLOAT_MAT3}),Z&&(L.u_jointMatrix={count:b,semantic:"JOINTMATRIX",type:a.Z.FLOAT_MAT4});var I=!1;for(var A in x)if(x.hasOwnProperty(A)&&"transparent"!==A&&"doubleSided"!==A){var R=m(A,x[A]);C="u_"+A.toLowerCase(),I||R!==a.Z.SAMPLER_2D||(I=!0),L[C]={type:R}}if((0,r.Z)(L.u_diffuse)&&(L.u_diffuse.semantic="_3DTILESDIFFUSE"),(0,r.Z)(u))for(var S in u)u.hasOwnProperty(S)&&(C="u_"+S,L[C]=u[S]);for(C in L)if(L.hasOwnProperty(C)){var N=L[C],F=(0,r.Z)(N.count)?"["+N.count+"]":"";N.type!==a.Z.FLOAT_MAT3&&N.type!==a.Z.FLOAT_MAT4||N.useInFragment?(O+="uniform "+(0,i.Z)(N.type)+" "+C+F+";\n",delete N.useInFragment):y+="uniform "+(0,i.Z)(N.type)+" "+C+F+";\n"}var w="";Z&&(w+="    mat4 skinMatrix =\n        a_weight.x * u_jointMatrix[int(a_joint.x)] +\n        a_weight.y * u_jointMatrix[int(a_joint.y)] +\n        a_weight.z * u_jointMatrix[int(a_joint.z)] +\n        a_weight.w * u_jointMatrix[int(a_joint.w)];\n");var M,D={a_position:{semantic:"POSITION"}};y+="attribute vec3 a_position;\n",y+="varying vec3 v_positionEC;\n",w+=Z?"  vec4 pos = u_modelViewMatrix * skinMatrix * vec4(a_position,1.0);\n":"  vec4 pos = u_modelViewMatrix * vec4(a_position,1.0);\n",w+="  v_positionEC = pos.xyz;\n",w+="  gl_Position = u_projectionMatrix * pos;\n",O+="varying vec3 v_positionEC;\n",E&&(D.a_normal={semantic:"NORMAL"},y+="attribute vec3 a_normal;\n",y+="varying vec3 v_normal;\n",w+=Z?"  v_normal = u_normalMatrix * mat3(skinMatrix) * a_normal;\n":"  v_normal = u_normalMatrix * a_normal;\n",O+="varying vec3 v_normal;\n"),I&&(D.a_texcoord_0={semantic:"TEXCOORD_0"},M="v_texcoord_0",y+="attribute vec2 a_texcoord_0;\n",y+="varying vec2 "+M+";\n",w+="  "+M+" = a_texcoord_0;\n",O+="varying vec2 "+M+";\n"),Z&&(D.a_joint={semantic:"JOINTS_0"},D.a_weight={semantic:"WEIGHTS_0"},y+="attribute vec4 a_joint;\n",y+="attribute vec4 a_weight;\n"),T&&(D.a_vertexColor={semantic:"COLOR_0"},y+="attribute vec4 a_vertexColor;\n",y+="varying vec4 v_vertexColor;\n",w+="  v_vertexColor = a_vertexColor;\n",O+="varying vec4 v_vertexColor;\n"),f&&(D.a_batchId={semantic:"_BATCHID"},y+="attribute float a_batchId;\n");var H=E&&("BLINN"===h||"PHONG"===h)&&(0,r.Z)(L.u_specular)&&(0,r.Z)(L.u_shininess)&&L.u_shininess>0,z=!1,P=!1,V="";for(var B in _)if(_.hasOwnProperty(B)){var G=_[B],U=G.type.toLowerCase(),j=G.baseName;V+="  {\n";var k,q,W="u_"+j+"Color";"ambient"===U?(P=!0,V+="    ambientLight += "+W+";\n"):E&&(z=!0,k="v_"+j+"Direction",q="v_"+j+"Position","point"!==U&&(y+="varying vec3 "+k+";\n",O+="varying vec3 "+k+";\n",w+="  "+k+" = mat3(u_"+j+"Transform) * vec3(0.,0.,1.);\n","directional"===U&&(V+="    vec3 l = normalize("+k+");\n")),"directional"!==U?(y+="varying vec3 "+q+";\n",O+="varying vec3 "+q+";\n",w+="  "+q+" = u_"+j+"Transform[3].xyz;\n",V+="    vec3 VP = "+q+" - v_positionEC;\n",V+="    vec3 l = normalize(VP);\n",V+="    float range = length(VP);\n",V+="    float attenuation = 1.0 / (u_"+j+"Attenuation.x + ",V+="(u_"+j+"Attenuation.y * range) + ",V+="(u_"+j+"Attenuation.z * range * range));\n"):V+="    float attenuation = 1.0;\n","spot"===U&&(V+="    float spotDot = dot(l, normalize("+k+"));\n",V+="    if (spotDot < cos(u_"+j+"FallOff.x * 0.5))\n",V+="    {\n",V+="      attenuation = 0.0;\n",V+="    }\n",V+="    else\n",V+="    {\n",V+="        attenuation *= max(0.0, pow(spotDot, u_"+j+"FallOff.y));\n",V+="    }\n"),V+="    diffuseLight += "+W+"* max(dot(normal,l), 0.) * attenuation;\n",H&&("BLINN"===h?(V+="    vec3 h = normalize(l + viewDir);\n",V+="    float specularIntensity = max(0., pow(max(dot(normal, h), 0.), u_shininess)) * attenuation;\n"):(V+="    vec3 reflectDir = reflect(-l, normal);\n",V+="    float specularIntensity = max(0., pow(max(dot(reflectDir, viewDir), 0.), u_shininess)) * attenuation;\n"),V+="    specularLight += "+W+" * specularIntensity;\n")),V+="  }\n"}if(P||(V+="  ambientLight += vec3(0.2, 0.2, 0.2);\n"),!z&&"CONSTANT"!==h){O+="#ifdef USE_CUSTOM_LIGHT_COLOR \n",O+="uniform vec3 gltf_lightColor; \n",O+="#endif \n",V+="#ifndef USE_CUSTOM_LIGHT_COLOR \n",V+="    vec3 lightColor = czm_lightColor;\n",V+="#else \n",V+="    vec3 lightColor = gltf_lightColor;\n",V+="#endif \n",V+="  vec3 l = normalize(czm_lightDirectionEC);\n";var K="0.2";V+="  diffuseLight += lightColor * max(dot(normal,l), "+K+");\n",H&&("BLINN"===h?(V+="  vec3 h = normalize(l + viewDir);\n",V+="  float specularIntensity = max(0., pow(max(dot(normal, h), 0.), u_shininess));\n"):(V+="  vec3 reflectDir = reflect(-l, normal);\n",V+="  float specularIntensity = max(0., pow(max(dot(reflectDir, viewDir), 0.), u_shininess));\n"),V+="  specularLight += lightColor * specularIntensity;\n")}y+="void main(void) {\n",y+=w,y+="}\n",O+="void main(void) {\n";var X,J="  vec3 color = vec3(0.0, 0.0, 0.0);\n";E&&(O+="  vec3 normal = normalize(v_normal);\n",l.doubleSided&&(O+="  if (czm_backFacing())\n",O+="  {\n",O+="    normal = -normal;\n",O+="  }\n")),"CONSTANT"!==h?((0,r.Z)(L.u_diffuse)&&(L.u_diffuse.type===a.Z.SAMPLER_2D?O+="  vec4 diffuse = texture2D(u_diffuse, "+M+");\n":O+="  vec4 diffuse = u_diffuse;\n",O+="  vec3 diffuseLight = vec3(0.0, 0.0, 0.0);\n",J+="  color += diffuse.rgb * diffuseLight;\n"),H&&(L.u_specular.type===a.Z.SAMPLER_2D?O+="  vec3 specular = texture2D(u_specular, "+M+").rgb;\n":O+="  vec3 specular = u_specular.rgb;\n",O+="  vec3 specularLight = vec3(0.0, 0.0, 0.0);\n",J+="  color += specular * specularLight;\n"),X=(0,r.Z)(L.u_transparency)?"  gl_FragColor = vec4(color * diffuse.a * u_transparency, diffuse.a * u_transparency);\n":"  gl_FragColor = vec4(color * diffuse.a, diffuse.a);\n"):X=(0,r.Z)(L.u_transparency)?"  gl_FragColor = vec4(color * u_transparency, u_transparency);\n":"  gl_FragColor = vec4(color, 1.0);\n",T&&(J+="  color *= v_vertexColor.rgb;\n"),(0,r.Z)(L.u_emission)&&(L.u_emission.type===a.Z.SAMPLER_2D?O+="  vec3 emission = texture2D(u_emission, "+M+").rgb;\n":O+="  vec3 emission = u_emission.rgb;\n",J+="  color += emission;\n"),((0,r.Z)(L.u_ambient)||"CONSTANT"!==h)&&((0,r.Z)(L.u_ambient)?L.u_ambient.type===a.Z.SAMPLER_2D?O+="  vec3 ambient = texture2D(u_ambient, "+M+").rgb;\n":O+="  vec3 ambient = u_ambient.rgb;\n":O+="  vec3 ambient = diffuse.rgb;\n",J+="  color += ambient * ambientLight;\n"),O+="  vec3 viewDir = -normalize(v_positionEC);\n",O+="  vec3 ambientLight = vec3(0.0, 0.0, 0.0);\n",O+=V,O+=J,O+=X,O+="}\n";var Y=(0,s.Z)(d,{type:a.Z.VERTEX_SHADER,extras:{_pipeline:{source:y,extension:".glsl"}}}),Q=(0,s.Z)(d,{type:a.Z.FRAGMENT_SHADER,extras:{_pipeline:{source:O,extension:".glsl"}}}),$=(0,s.Z)(p,{fragmentShader:Q,vertexShader:Y}),ee=(0,s.Z)(v,{attributes:D,program:$,uniforms:L});return ee}function m(e,n){var t;switch(t=(0,r.Z)(n.value)?n.value:(0,r.Z)(n.index)?[n.index]:n,e){case"ambient":return 1===t.length?a.Z.SAMPLER_2D:a.Z.FLOAT_VEC4;case"diffuse":return 1===t.length?a.Z.SAMPLER_2D:a.Z.FLOAT_VEC4;case"emission":return 1===t.length?a.Z.SAMPLER_2D:a.Z.FLOAT_VEC4;case"specular":return 1===t.length?a.Z.SAMPLER_2D:a.Z.FLOAT_VEC4;case"shininess":return a.Z.FLOAT;case"transparency":return a.Z.FLOAT;case"transparent":return a.Z.BOOL;case"doubleSided":return a.Z.BOOL}}function d(e,n){var t="";t+="technique:"+e.technique+";";for(var a=e.values,i=Object.keys(a).sort(),s=i.length,l=0;l<s;++l){var c=i[l];a.hasOwnProperty(c)&&(t+=c+":"+m(c,a[c]),t+=";")}var u=(0,o.Z)(e.jointCount,0);if(t+=u.toString()+";",(0,r.Z)(n)){var f=n.skinning;u>0&&(t+=f.type+";"),t+=n.hasVertexColors}return t}function p(e){var n=e.extensions.KHR_materials_common;if((0,r.Z)(n)&&(0,r.Z)(n.lights))for(var t=n.lights,a=t.length,i=0;i<a;i++){var s=t[i];if("ambient"===s.type){(0,r.Z)(s.ambient)||(s.ambient={});var l=s.ambient;(0,r.Z)(l.color)||(l.color=[1,1,1])}else if("directional"===s.type){(0,r.Z)(s.directional)||(s.directional={});var c=s.directional;(0,r.Z)(c.color)||(c.color=[1,1,1])}else if("point"===s.type){(0,r.Z)(s.point)||(s.point={});var u=s.point;(0,r.Z)(u.color)||(u.color=[1,1,1]),u.constantAttenuation=(0,o.Z)(u.constantAttenuation,1),u.linearAttenuation=(0,o.Z)(u.linearAttenuation,0),u.quadraticAttenuation=(0,o.Z)(u.quadraticAttenuation,0)}else if("spot"===s.type){(0,r.Z)(s.spot)||(s.spot={});var f=s.spot;(0,r.Z)(f.color)||(f.color=[1,1,1]),f.constantAttenuation=(0,o.Z)(f.constantAttenuation,1),f.fallOffAngle=(0,o.Z)(f.fallOffAngle,3.14159265),f.fallOffExponent=(0,o.Z)(f.fallOffExponent,0),f.linearAttenuation=(0,o.Z)(f.linearAttenuation,0),f.quadraticAttenuation=(0,o.Z)(f.quadraticAttenuation,0)}}}n["Z"]=f},14503:function(e,n,t){var o=t(62200),r=t(82982),a=t(52200),i=t(37231),s=t(9919),l=t(56629),c=t(29745),u=t(15322);function f(e,n){if(n=(0,o.Z)(n,o.Z.EMPTY_OBJECT),(0,c.Z)(e,"KHR_techniques_webgl"))return e;if(!(0,r.Z)(e.materials)||0===e.materials.length)return e;(0,r.Z)(e.extensions)||(e.extensions={}),(0,r.Z)(e.extensionsUsed)||(e.extensionsUsed=[]),(0,r.Z)(e.extensionsRequired)||(e.extensionsRequired=[]),e.extensions.KHR_techniques_webgl={programs:[],shaders:[],techniques:[]},e.extensionsUsed.push("KHR_techniques_webgl"),e.extensionsRequired.push("KHR_techniques_webgl");var t=u.Z.splitIncompatibleMaterials(e);return l.Z.material(e,(function(o,a){var i={},s=g(e,o,a,i,t,n);(0,r.Z)(o.extensions)||(o.extensions={}),o.extensions.KHR_techniques_webgl={values:i,technique:s}})),u.Z.ensureSemanticExistence(e),e}function _(e){return(0,r.Z)(e.extensions)&&(0,r.Z)(e.extensions.KHR_materials_pbrSpecularGlossiness)}function v(e,n,t,o,a){var i,s=t[n];return(0,r.Z)(s)&&(0,r.Z)(s.texCoord)&&1===s.texCoord&&(o=o.replace("0","1")),(0,r.Z)(t[n+"Offset"])?(i=n+"Coord",a.fragmentShaderMain+="    vec2 "+i+" = computeTexCoord("+o+", "+n+"Offset, "+n+"Rotation, "+n+"Scale);\n"):i=o,i}var m=[0,0],d=[0],p=[1,1];function h(e,n,t){if(-1!==e.indexOf("Texture")&&(0,r.Z)(n.extensions)&&(0,r.Z)(n.extensions.KHR_texture_transform)){var a="u_"+e,i=n.extensions.KHR_texture_transform;t[a+"Offset"]=(0,o.Z)(i.offset,m),t[a+"Rotation"]=(0,o.Z)(i.rotation,d),t[a+"Scale"]=(0,o.Z)(i.scale,p),(0,r.Z)(n.texCoord)&&(0,r.Z)(i.texCoord)&&(t[a].texCoord=i.texCoord)}}function g(e,n,t,u,f,m){var d,p,g,b=(0,o.Z)(m.addBatchIdToGeneratedShaders,!1),Z=e.extensions.KHR_techniques_webgl,T=Z.techniques,C=Z.shaders,y=Z.programs,O=_(n),E=n.pbrMetallicRoughness;if((0,r.Z)(E)&&!O)for(p in E)E.hasOwnProperty(p)&&(g=E[p],d="u_"+p,u[d]=g,h(p,g,u));if(O){var L=n.extensions.KHR_materials_pbrSpecularGlossiness;for(p in L)L.hasOwnProperty(p)&&(g=L[p],d="u_"+p,u[d]=g,h(p,g,u))}for(var I in n)n.hasOwnProperty(I)&&(I.indexOf("Texture")>=0||I.indexOf("Factor")>=0)&&(g=n[I],d="u_"+I,u[d]=g,h(I,g,u));var A,R="precision highp float;\n",S="precision highp float;\n";(0,r.Z)(e.skins)&&(A=e.skins[0]);var N,F,w=(0,r.Z)(A)?A.joints:[],M=w.length,D=f[t],H=!1,z=!1,P=!1,V=!1,B=!1,G=!1,U=!1,j=!1,k=!1;(0,r.Z)(D)&&(N=D.skinning,H=N.skinned&&w.length>0,z=D.hasVertexColors,P=D.hasMorphTargets,V=D.hasNormals,B=D.hasTangents,G=D.hasTexCoords,U=D.hasTexCoord1,j=D.hasOutline),P&&l.Z.mesh(e,(function(e){l.Z.meshPrimitive(e,(function(e){if(e.material===t){var n=e.targets;(0,r.Z)(n)&&(F=n)}}))}));var q={u_modelViewMatrix:{semantic:(0,c.Z)(e,"CESIUM_RTC")?"CESIUM_RTC_MODELVIEW":"MODELVIEW",type:a.Z.FLOAT_MAT4},u_projectionMatrix:{semantic:"PROJECTION",type:a.Z.FLOAT_MAT4}};(0,r.Z)(n.extensions)&&(0,r.Z)(n.extensions.KHR_materials_unlit)&&(k=!0),V&&(q.u_normalMatrix={semantic:"MODELVIEWINVERSETRANSPOSE",type:a.Z.FLOAT_MAT3}),H&&(q.u_jointMatrix={count:M,semantic:"JOINTMATRIX",type:a.Z.FLOAT_MAT4}),P&&(q.u_morphWeights={count:F.length,semantic:"MORPHWEIGHTS",type:a.Z.FLOAT});var W=n.alphaMode;for(d in(0,r.Z)(W)&&"MASK"===W&&(q.u_alphaCutoff={semantic:"ALPHACUTOFF",type:a.Z.FLOAT}),u)u.hasOwnProperty(d)&&(q[d]={type:x(d)});var K=(0,o.Z)(q.u_baseColorTexture,q.u_baseColorFactor);for(d in(0,r.Z)(K)&&(K.semantic="_3DTILESDIFFUSE"),q)if(q.hasOwnProperty(d)){var X=q[d],J=(0,r.Z)(X.count)?"["+X.count+"]":"";X.type!==a.Z.FLOAT_MAT3&&X.type!==a.Z.FLOAT_MAT4&&"u_morphWeights"!==d||X.useInFragment?(S+="uniform "+(0,i.Z)(X.type)+" "+d+J+";\n",delete X.useInFragment):R+="uniform "+(0,i.Z)(X.type)+" "+d+J+";\n"}j&&(S+="uniform sampler2D u_outlineTexture;\n");var Y="";H&&(Y+="    mat4 skinMatrix =\n        a_weight.x * u_jointMatrix[int(a_joint.x)] +\n        a_weight.y * u_jointMatrix[int(a_joint.y)] +\n        a_weight.z * u_jointMatrix[int(a_joint.z)] +\n        a_weight.w * u_jointMatrix[int(a_joint.w)];\n");var Q={a_position:{semantic:"POSITION"}};if(j&&(Q.a_outlineCoordinates={semantic:"_OUTLINE_COORDINATES"}),R+="attribute vec3 a_position;\n",V&&(R+="varying vec3 v_positionEC;\n"),j&&(R+="attribute vec3 a_outlineCoordinates;\n",R+="varying vec3 v_outlineCoordinates;\n"),Y+="    vec3 weightedPosition = a_position;\n",V&&(Y+="    vec3 weightedNormal = a_normal;\n"),B&&(Y+="    vec4 weightedTangent = a_tangent;\n"),P)for(var $=0;$<F.length;$++){var ee=F[$];for(var ne in ee)if(ee.hasOwnProperty(ne)&&"extras"!==ne){var te="a_"+ne+"_"+$;Q[te]={semantic:ne+"_"+$},R+="attribute vec3 "+te+";\n","POSITION"===ne?Y+="    weightedPosition += u_morphWeights["+$+"] * "+te+";\n":"NORMAL"===ne?Y+="    weightedNormal += u_morphWeights["+$+"] * "+te+";\n":B&&"TANGENT"===ne&&(Y+="    weightedTangent.xyz += u_morphWeights["+$+"] * "+te+";\n")}}Y+=H?"    vec4 position = skinMatrix * vec4(weightedPosition, 1.0);\n":"    vec4 position = vec4(weightedPosition, 1.0);\n",Y+="    position = u_modelViewMatrix * position;\n",V&&(Y+="    v_positionEC = position.xyz;\n"),Y+="    gl_Position = u_projectionMatrix * position;\n",j&&(Y+="    v_outlineCoordinates = a_outlineCoordinates;\n"),V&&(Q.a_normal={semantic:"NORMAL"},R+="attribute vec3 a_normal;\n",k||(R+="varying vec3 v_normal;\n",Y+=H?"    v_normal = u_normalMatrix * mat3(skinMatrix) * weightedNormal;\n":"    v_normal = u_normalMatrix * weightedNormal;\n",S+="varying vec3 v_normal;\n"),S+="varying vec3 v_positionEC;\n"),B&&(Q.a_tangent={semantic:"TANGENT"},R+="attribute vec4 a_tangent;\n",R+="varying vec4 v_tangent;\n",Y+="    v_tangent.xyz = u_normalMatrix * weightedTangent.xyz;\n",Y+="    v_tangent.w = weightedTangent.w;\n",S+="varying vec4 v_tangent;\n"),j&&(S+="varying vec3 v_outlineCoordinates;\n");var oe,re,ae,ie,se,le,ce,ue,fe="";if(G){if(Q.a_texcoord_0={semantic:"TEXCOORD_0"},oe="v_texcoord_0",R+="attribute vec2 a_texcoord_0;\n",R+="varying vec2 "+oe+";\n",Y+="    "+oe+" = a_texcoord_0;\n",S+="varying vec2 "+oe+";\n",U){Q.a_texcoord_1={semantic:"TEXCOORD_1"};var _e=oe.replace("0","1");R+="attribute vec2 a_texcoord_1;\n",R+="varying vec2 "+_e+";\n",Y+="    "+_e+" = a_texcoord_1;\n",S+="varying vec2 "+_e+";\n"}var ve={fragmentShaderMain:fe};re=v(e,"u_normalTexture",u,oe,ve),ae=v(e,"u_baseColorTexture",u,oe,ve),ie=v(e,"u_specularGlossinessTexture",u,oe,ve),se=v(e,"u_diffuseTexture",u,oe,ve),le=v(e,"u_metallicRoughnessTexture",u,oe,ve),ce=v(e,"u_occlusionTexture",u,oe,ve),ue=v(e,"u_emissiveTexture",u,oe,ve),fe=ve.fragmentShaderMain}H&&(Q.a_joint={semantic:"JOINTS_0"},Q.a_weight={semantic:"WEIGHTS_0"},R+="attribute vec4 a_joint;\n",R+="attribute vec4 a_weight;\n"),z&&(Q.a_vertexColor={semantic:"COLOR_0"},R+="attribute vec4 a_vertexColor;\n",R+="varying vec4 v_vertexColor;\n",Y+="  v_vertexColor = a_vertexColor;\n",S+="varying vec4 v_vertexColor;\n"),b&&(Q.a_batchId={semantic:"_BATCHID"},R+="attribute float a_batchId;\n"),R+="void main(void) \n{\n",R+=Y,R+="}\n",V&&!k&&(S+="const float M_PI = 3.141592653589793;\n",S+="vec3 lambertianDiffuse(vec3 diffuseColor) \n{\n    return diffuseColor / M_PI;\n}\n\n",S+="vec3 fresnelSchlick2(vec3 f0, vec3 f90, float VdotH) \n{\n    return f0 + (f90 - f0) * pow(clamp(1.0 - VdotH, 0.0, 1.0), 5.0);\n}\n\n",S+="vec3 fresnelSchlick(float metalness, float VdotH) \n{\n    return metalness + (vec3(1.0) - metalness) * pow(1.0 - VdotH, 5.0);\n}\n\n",S+="float smithVisibilityG1(float NdotV, float roughness) \n{\n    float k = (roughness + 1.0) * (roughness + 1.0) / 8.0;\n    return NdotV / (NdotV * (1.0 - k) + k);\n}\n\n",S+="float smithVisibilityGGX(float roughness, float NdotL, float NdotV) \n{\n    return smithVisibilityG1(NdotL, roughness) * smithVisibilityG1(NdotV, roughness);\n}\n\n",S+="float GGX(float roughness, float NdotH) \n{\n    float roughnessSquared = roughness * roughness;\n    float f = (NdotH * roughnessSquared - NdotH) * NdotH + 1.0;\n    return roughnessSquared / (M_PI * f * f);\n}\n\n"),S+="vec3 SRGBtoLINEAR3(vec3 srgbIn) \n{\n    return pow(srgbIn, vec3(2.2));\n}\n\n",S+="vec4 SRGBtoLINEAR4(vec4 srgbIn) \n{\n    vec3 linearOut = pow(srgbIn.rgb, vec3(2.2));\n    return vec4(linearOut, srgbIn.a);\n}\n\n",S+="vec3 applyTonemapping(vec3 linearIn) \n{\n#ifndef HDR \n    return czm_acesTonemapping(linearIn);\n#else \n    return linearIn;\n#endif \n}\n\n",S+="vec3 LINEARtoSRGB(vec3 linearIn) \n{\n#ifndef HDR \n    return pow(linearIn, vec3(1.0/2.2));\n#else \n    return linearIn;\n#endif \n}\n\n",S+="vec2 computeTexCoord(vec2 texCoords, vec2 offset, float rotation, vec2 scale) \n{\n    rotation = -rotation; \n    mat3 transform = mat3(\n        cos(rotation) * scale.x, sin(rotation) * scale.x, 0.0, \n       -sin(rotation) * scale.y, cos(rotation) * scale.y, 0.0, \n        offset.x, offset.y, 1.0); \n    vec2 transformedTexCoords = (transform * vec3(fract(texCoords), 1.0)).xy; \n    return transformedTexCoords; \n}\n\n",S+="#ifdef USE_IBL_LIGHTING \n",S+="uniform vec2 gltf_iblFactor; \n",S+="#endif \n",S+="#ifdef USE_CUSTOM_LIGHT_COLOR \n",S+="uniform vec3 gltf_lightColor; \n",S+="#endif \n",S+="void main(void) \n{\n",S+=fe,V&&!k&&(S+="    vec3 ng = normalize(v_normal);\n",S+="    vec3 positionWC = vec3(czm_inverseView * vec4(v_positionEC, 1.0));\n",(0,r.Z)(u.u_normalTexture)?B?(S+="    vec3 t = normalize(v_tangent.xyz);\n",S+="    vec3 b = normalize(cross(ng, t) * v_tangent.w);\n",S+="    mat3 tbn = mat3(t, b, ng);\n",S+="    vec3 n = texture2D(u_normalTexture, "+re+").rgb;\n",S+="    n = normalize(tbn * (2.0 * n - 1.0));\n"):(S="#ifdef GL_OES_standard_derivatives\n#extension GL_OES_standard_derivatives : enable\n#endif\n"+S,S+="#ifdef GL_OES_standard_derivatives\n",S+="    vec3 pos_dx = dFdx(v_positionEC);\n",S+="    vec3 pos_dy = dFdy(v_positionEC);\n",S+="    vec3 tex_dx = dFdx(vec3("+re+",0.0));\n",S+="    vec3 tex_dy = dFdy(vec3("+re+",0.0));\n",S+="    vec3 t = (tex_dy.t * pos_dx - tex_dx.t * pos_dy) / (tex_dx.s * tex_dy.t - tex_dy.s * tex_dx.t);\n",S+="    t = normalize(t - ng * dot(ng, t));\n",S+="    vec3 b = normalize(cross(ng, t));\n",S+="    mat3 tbn = mat3(t, b, ng);\n",S+="    vec3 n = texture2D(u_normalTexture, "+re+").rgb;\n",S+="    n = normalize(tbn * (2.0 * n - 1.0));\n",S+="#else\n",S+="    vec3 n = ng;\n",S+="#endif\n"):S+="    vec3 n = ng;\n",n.doubleSided&&(S+="    if (czm_backFacing())\n",S+="    {\n",S+="        n = -n;\n",S+="    }\n")),(0,r.Z)(u.u_baseColorTexture)?(S+="    vec4 baseColorWithAlpha = SRGBtoLINEAR4(texture2D(u_baseColorTexture, "+ae+"));\n",(0,r.Z)(u.u_baseColorFactor)&&(S+="    baseColorWithAlpha *= u_baseColorFactor;\n")):(0,r.Z)(u.u_baseColorFactor)?S+="    vec4 baseColorWithAlpha = u_baseColorFactor;\n":S+="    vec4 baseColorWithAlpha = vec4(1.0);\n",z&&(S+="    baseColorWithAlpha *= v_vertexColor;\n"),S+="    vec3 baseColor = baseColorWithAlpha.rgb;\n",V&&!k?(O?((0,r.Z)(u.u_specularGlossinessTexture)?(S+="    vec4 specularGlossiness = SRGBtoLINEAR4(texture2D(u_specularGlossinessTexture, "+ie+"));\n",S+="    vec3 specular = specularGlossiness.rgb;\n",S+="    float glossiness = specularGlossiness.a;\n",(0,r.Z)(u.u_specularFactor)&&(S+="    specular *= u_specularFactor;\n"),(0,r.Z)(u.u_glossinessFactor)&&(S+="    glossiness *= u_glossinessFactor;\n")):((0,r.Z)(u.u_specularFactor)?S+="    vec3 specular = clamp(u_specularFactor, vec3(0.0), vec3(1.0));\n":S+="    vec3 specular = vec3(1.0);\n",(0,r.Z)(u.u_glossinessFactor)?S+="    float glossiness = clamp(u_glossinessFactor, 0.0, 1.0);\n":S+="    float glossiness = 1.0;\n"),(0,r.Z)(u.u_diffuseTexture)?(S+="    vec4 diffuse = SRGBtoLINEAR4(texture2D(u_diffuseTexture, "+se+"));\n",(0,r.Z)(u.u_diffuseFactor)&&(S+="    diffuse *= u_diffuseFactor;\n")):(0,r.Z)(u.u_diffuseFactor)?S+="    vec4 diffuse = clamp(u_diffuseFactor, vec4(0.0), vec4(1.0));\n":S+="    vec4 diffuse = vec4(1.0);\n"):(0,r.Z)(u.u_metallicRoughnessTexture)?(S+="    vec3 metallicRoughness = texture2D(u_metallicRoughnessTexture, "+le+").rgb;\n",S+="    float metalness = clamp(metallicRoughness.b, 0.0, 1.0);\n",S+="    float roughness = clamp(metallicRoughness.g, 0.04, 1.0);\n",(0,r.Z)(u.u_metallicFactor)&&(S+="    metalness *= u_metallicFactor;\n"),(0,r.Z)(u.u_roughnessFactor)&&(S+="    roughness *= u_roughnessFactor;\n")):((0,r.Z)(u.u_metallicFactor)?S+="    float metalness = clamp(u_metallicFactor, 0.0, 1.0);\n":S+="    float metalness = 1.0;\n",(0,r.Z)(u.u_roughnessFactor)?S+="    float roughness = clamp(u_roughnessFactor, 0.04, 1.0);\n":S+="    float roughness = 1.0;\n"),S+="    vec3 v = -normalize(v_positionEC);\n",S+="#ifndef USE_CUSTOM_LIGHT_COLOR \n",S+="    vec3 lightColorHdr = czm_lightColorHdr;\n",S+="#else \n",S+="    vec3 lightColorHdr = gltf_lightColor;\n",S+="#endif \n",S+="    vec3 l = normalize(czm_lightDirectionEC);\n",S+="    vec3 h = normalize(v + l);\n",S+="    float NdotL = clamp(dot(n, l), 0.001, 1.0);\n",S+="    float NdotV = abs(dot(n, v)) + 0.001;\n",S+="    float NdotH = clamp(dot(n, h), 0.0, 1.0);\n",S+="    float LdotH = clamp(dot(l, h), 0.0, 1.0);\n",S+="    float VdotH = clamp(dot(v, h), 0.0, 1.0);\n",S+="    vec3 f0 = vec3(0.04);\n",O?(S+="    float roughness = 1.0 - glossiness;\n",S+="    vec3 diffuseColor = diffuse.rgb * (1.0 - max(max(specular.r, specular.g), specular.b));\n",S+="    vec3 specularColor = specular;\n"):(S+="    vec3 diffuseColor = baseColor * (1.0 - metalness) * (1.0 - f0);\n",S+="    vec3 specularColor = mix(f0, baseColor, metalness);\n"),S+="    float alpha = roughness * roughness;\n",S+="    float reflectance = max(max(specularColor.r, specularColor.g), specularColor.b);\n",S+="    vec3 r90 = vec3(clamp(reflectance * 25.0, 0.0, 1.0));\n",S+="    vec3 r0 = specularColor.rgb;\n",S+="    vec3 F = fresnelSchlick2(r0, r90, VdotH);\n",S+="    float G = smithVisibilityGGX(alpha, NdotL, NdotV);\n",S+="    float D = GGX(alpha, NdotH);\n",S+="    vec3 diffuseContribution = (1.0 - F) * lambertianDiffuse(diffuseColor);\n",S+="    vec3 specularContribution = F * G * D / (4.0 * NdotL * NdotV);\n",S+="    vec3 color = NdotL * lightColorHdr * (diffuseContribution + specularContribution);\n",S+="#if defined(USE_IBL_LIGHTING) && !defined(DIFFUSE_IBL) && !defined(SPECULAR_IBL) \n",S+="    vec3 r = normalize(czm_inverseViewRotation * normalize(reflect(v, n)));\n",S+="    float vertexRadius = length(positionWC);\n",S+="    float horizonDotNadir = 1.0 - min(1.0, czm_ellipsoidRadii.x / vertexRadius);\n",S+="    float reflectionDotNadir = dot(r, normalize(positionWC));\n",S+="    r.x = -r.x;\n",S+="    r = -normalize(czm_temeToPseudoFixed * r);\n",S+="    r.x = -r.x;\n",S+="    float inverseRoughness = 1.04 - roughness;\n",S+="    inverseRoughness *= inverseRoughness;\n",S+="    vec3 sceneSkyBox = textureCube(czm_environmentMap, r).rgb * inverseRoughness;\n",S+="    float atmosphereHeight = 0.05;\n",S+="    float blendRegionSize = 0.1 * ((1.0 - inverseRoughness) * 8.0 + 1.1 - horizonDotNadir);\n",S+="    float blendRegionOffset = roughness * -1.0;\n",S+="    float farAboveHorizon = clamp(horizonDotNadir - blendRegionSize * 0.5 + blendRegionOffset, 1.0e-10 - blendRegionSize, 0.99999);\n",S+="    float aroundHorizon = clamp(horizonDotNadir + blendRegionSize * 0.5, 1.0e-10 - blendRegionSize, 0.99999);\n",S+="    float farBelowHorizon = clamp(horizonDotNadir + blendRegionSize * 1.5, 1.0e-10 - blendRegionSize, 0.99999);\n",S+="    float smoothstepHeight = smoothstep(0.0, atmosphereHeight, horizonDotNadir);\n",S+="    vec3 belowHorizonColor = mix(vec3(0.1, 0.15, 0.25), vec3(0.4, 0.7, 0.9), smoothstepHeight);\n",S+="    vec3 nadirColor = belowHorizonColor * 0.5;\n",S+="    vec3 aboveHorizonColor = mix(vec3(0.9, 1.0, 1.2), belowHorizonColor, roughness * 0.5);\n",S+="    vec3 blueSkyColor = mix(vec3(0.18, 0.26, 0.48), aboveHorizonColor, reflectionDotNadir * inverseRoughness * 0.5 + 0.75);\n",S+="    vec3 zenithColor = mix(blueSkyColor, sceneSkyBox, smoothstepHeight);\n",S+="    vec3 blueSkyDiffuseColor = vec3(0.7, 0.85, 0.9);\n",S+="    float diffuseIrradianceFromEarth = (1.0 - horizonDotNadir) * (reflectionDotNadir * 0.25 + 0.75) * smoothstepHeight;\n",S+="    float diffuseIrradianceFromSky = (1.0 - smoothstepHeight) * (1.0 - (reflectionDotNadir * 0.25 + 0.25));\n",S+="    vec3 diffuseIrradiance = blueSkyDiffuseColor * clamp(diffuseIrradianceFromEarth + diffuseIrradianceFromSky, 0.0, 1.0);\n",S+="    float notDistantRough = (1.0 - horizonDotNadir * roughness * 0.8);\n",S+="    vec3 specularIrradiance = mix(zenithColor, aboveHorizonColor, smoothstep(farAboveHorizon, aroundHorizon, reflectionDotNadir) * notDistantRough);\n",S+="    specularIrradiance = mix(specularIrradiance, belowHorizonColor, smoothstep(aroundHorizon, farBelowHorizon, reflectionDotNadir) * inverseRoughness);\n",S+="    specularIrradiance = mix(specularIrradiance, nadirColor, smoothstep(farBelowHorizon, 1.0, reflectionDotNadir) * inverseRoughness);\n",S+="#ifdef USE_SUN_LUMINANCE \n",S+="    float LdotZenith = clamp(dot(normalize(czm_inverseViewRotation * l), normalize(positionWC * -1.0)), 0.001, 1.0);\n",S+="    float S = acos(LdotZenith);\n",S+="    float NdotZenith = clamp(dot(normalize(czm_inverseViewRotation * n), normalize(positionWC * -1.0)), 0.001, 1.0);\n",S+="    float gamma = acos(NdotL);\n",S+="    float numerator = ((0.91 + 10.0 * exp(-3.0 * gamma) + 0.45 * pow(NdotL, 2.0)) * (1.0 - exp(-0.32 / NdotZenith)));\n",S+="    float denominator = (0.91 + 10.0 * exp(-3.0 * S) + 0.45 * pow(LdotZenith,2.0)) * (1.0 - exp(-0.32));\n",S+="    float luminance = gltf_luminanceAtZenith * (numerator / denominator);\n",S+="#endif \n",S+="    vec2 brdfLut = texture2D(czm_brdfLut, vec2(NdotV, roughness)).rg;\n",S+="    vec3 IBLColor = (diffuseIrradiance * diffuseColor * gltf_iblFactor.x) + (specularIrradiance * SRGBtoLINEAR3(specularColor * brdfLut.x + brdfLut.y) * gltf_iblFactor.y);\n",S+="    float maximumComponent = max(max(lightColorHdr.x, lightColorHdr.y), lightColorHdr.z);\n",S+="    vec3 lightColor = lightColorHdr / max(maximumComponent, 1.0);\n",S+="    IBLColor *= lightColor;\n",S+="#ifdef USE_SUN_LUMINANCE \n",S+="    color += IBLColor * luminance;\n",S+="#else \n",S+="    color += IBLColor; \n",S+="#endif \n",S+="#elif defined(DIFFUSE_IBL) || defined(SPECULAR_IBL) \n",S+="    const mat3 yUpToZUp = mat3(-1.0, 0.0, 0.0, 0.0, 0.0, -1.0, 0.0, 1.0, 0.0); \n",S+="    vec3 cubeDir = normalize(yUpToZUp * gltf_iblReferenceFrameMatrix * normalize(reflect(-v, n))); \n",S+="#ifdef DIFFUSE_IBL \n",S+="#ifdef CUSTOM_SPHERICAL_HARMONICS \n",S+="    vec3 diffuseIrradiance = czm_sphericalHarmonics(cubeDir, gltf_sphericalHarmonicCoefficients); \n",S+="#else \n",S+="    vec3 diffuseIrradiance = czm_sphericalHarmonics(cubeDir, czm_sphericalHarmonicCoefficients); \n",S+="#endif \n",S+="#else \n",S+="    vec3 diffuseIrradiance = vec3(0.0); \n",S+="#endif \n",S+="#ifdef SPECULAR_IBL \n",S+="    vec2 brdfLut = texture2D(czm_brdfLut, vec2(NdotV, roughness)).rg;\n",S+="#ifdef CUSTOM_SPECULAR_IBL \n",S+="    vec3 specularIBL = czm_sampleOctahedralProjection(gltf_specularMap, gltf_specularMapSize, cubeDir,  roughness * gltf_maxSpecularLOD, gltf_maxSpecularLOD);\n",S+="#else \n",S+="    vec3 specularIBL = czm_sampleOctahedralProjection(czm_specularEnvironmentMaps, czm_specularEnvironmentMapSize, cubeDir,  roughness * czm_specularEnvironmentMapsMaximumLOD, czm_specularEnvironmentMapsMaximumLOD);\n",S+="#endif \n",S+="    specularIBL *= F * brdfLut.x + brdfLut.y;\n",S+="#else \n",S+="    vec3 specularIBL = vec3(0.0); \n",S+="#endif \n",S+="    color += diffuseIrradiance * diffuseColor + specularColor * specularIBL;\n",S+="#endif \n"):S+="    vec3 color = baseColor;\n",k||((0,r.Z)(u.u_occlusionTexture)&&(S+="    color *= texture2D(u_occlusionTexture, "+ce+").r;\n"),(0,r.Z)(u.u_emissiveTexture)?(S+="    vec3 emissive = SRGBtoLINEAR3(texture2D(u_emissiveTexture, "+ue+").rgb);\n",(0,r.Z)(u.u_emissiveFactor)&&(S+="    emissive *= u_emissiveFactor;\n"),S+="    color += emissive;\n"):(0,r.Z)(u.u_emissiveFactor)&&(S+="    color += u_emissiveFactor;\n")),k||(S+="    color = applyTonemapping(color);\n"),S+="    color = LINEARtoSRGB(color);\n",j&&(S+="    float outlineness = max(\n",S+="        texture2D(u_outlineTexture, vec2(v_outlineCoordinates.x, 0.5)).r,\n",S+="        max(\n",S+="          texture2D(u_outlineTexture, vec2(v_outlineCoordinates.y, 0.5)).r,\n",S+="          texture2D(u_outlineTexture, vec2(v_outlineCoordinates.z, 0.5)).r));\n",S+="    color = mix(color, vec3(0.0, 0.0, 0.0), outlineness);\n"),(0,r.Z)(W)?"MASK"===W?(S+="    if (baseColorWithAlpha.a < u_alphaCutoff) {\n",S+="        discard;\n",S+="    }\n",S+="    gl_FragColor = vec4(color, 1.0);\n"):S+="BLEND"===W?"    gl_FragColor = vec4(color, baseColorWithAlpha.a);\n":"    gl_FragColor = vec4(color, 1.0);\n":S+="    gl_FragColor = vec4(color, 1.0);\n",S+="}\n";var me=(0,s.Z)(C,{type:a.Z.VERTEX_SHADER,extras:{_pipeline:{source:R,extension:".glsl"}}}),de=(0,s.Z)(C,{type:a.Z.FRAGMENT_SHADER,extras:{_pipeline:{source:S,extension:".glsl"}}}),pe=(0,s.Z)(y,{fragmentShader:de,vertexShader:me}),he=(0,s.Z)(T,{attributes:Q,program:pe,uniforms:q});return he}function x(e){if(-1!==e.indexOf("Offset"))return a.Z.FLOAT_VEC2;if(-1!==e.indexOf("Rotation"))return a.Z.FLOAT;if(-1!==e.indexOf("Scale"))return a.Z.FLOAT_VEC2;if(-1!==e.indexOf("Texture"))return a.Z.SAMPLER_2D;switch(e){case"u_baseColorFactor":return a.Z.FLOAT_VEC4;case"u_metallicFactor":return a.Z.FLOAT;case"u_roughnessFactor":return a.Z.FLOAT;case"u_emissiveFactor":return a.Z.FLOAT_VEC3;case"u_diffuseFactor":return a.Z.FLOAT_VEC4;case"u_specularFactor":return a.Z.FLOAT_VEC3;case"u_glossinessFactor":return a.Z.FLOAT}}n["Z"]=f},81154:function(e,n){n["Z"]="#ifdef MRT\n#extension GL_EXT_draw_buffers : enable\n#endif\n\nuniform vec4 u_bgColor;\nuniform sampler2D u_depthTexture;\n\nvarying vec2 v_textureCoordinates;\n\nvoid main()\n{\n    if (texture2D(u_depthTexture, v_textureCoordinates).r < 1.0)\n    {\n#ifdef MRT\n        gl_FragData[0] = u_bgColor;\n        gl_FragData[1] = vec4(u_bgColor.a);\n#else\n        gl_FragColor = u_bgColor;\n#endif\n        return;\n    }\n    \n    discard;\n}\n"}}]);
//# sourceMappingURL=chunk-vendors-6e78be6c-legacy.9f74805d.js.map