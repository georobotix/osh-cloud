"use strict";(self["webpackChunkvue3_webpack5"]=self["webpackChunkvue3_webpack5"]||[]).push([[2108],{48055:function(e,t,n){n.d(t,{T:function(){return s}});let i=1,r=1;class s{constructor(){this.time=0,this.channels=new Map,this.animations=new Map,this.playing=!1,this.lastEngineTime=-1}addChannel(e){const{delay:t=0,duration:n=Number.POSITIVE_INFINITY,rate:r=1,repeat:s=1}=e,o=i++,a={time:0,delay:t,duration:n,rate:r,repeat:s};return this._setChannelTime(a,this.time),this.channels.set(o,a),o}removeChannel(e){this.channels.delete(e);for(const[t,n]of this.animations)n.channel===e&&this.detachAnimation(t)}isFinished(e){const t=this.channels.get(e);return void 0!==t&&this.time>=t.delay+t.duration*t.repeat}getTime(e){if(void 0===e)return this.time;const t=this.channels.get(e);return void 0===t?-1:t.time}setTime(e){this.time=Math.max(0,e);const t=this.channels.values();for(const i of t)this._setChannelTime(i,this.time);const n=this.animations.values();for(const i of n){const{animation:e,channel:t}=i;e.setTime(this.getTime(t))}}play(){this.playing=!0}pause(){this.playing=!1,this.lastEngineTime=-1}reset(){this.setTime(0)}attachAnimation(e,t){const n=r++;return this.animations.set(n,{animation:e,channel:t}),e.setTime(this.getTime(t)),n}detachAnimation(e){this.animations.delete(e)}update(e){this.playing&&(-1===this.lastEngineTime&&(this.lastEngineTime=e),this.setTime(this.time+(e-this.lastEngineTime)),this.lastEngineTime=e)}_setChannelTime(e,t){const n=t-e.delay,i=e.duration*e.repeat;n>=i?e.time=e.duration*e.rate:(e.time=Math.max(0,n)%e.duration,e.time*=e.rate)}}},53982:function(e,t,n){n.d(t,{Z:function(){return o}});var i=n(74538),r=n(22525);const s={POINTS:0,LINES:1,LINE_LOOP:2,LINE_STRIP:3,TRIANGLES:4,TRIANGLE_STRIP:5,TRIANGLE_FAN:6};class o{static get DRAW_MODE(){return s}constructor(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};const{id:t=(0,i.hQ)("geometry"),drawMode:n=s.TRIANGLES,attributes:r={},indices:o=null,vertexCount:a=null}=e;this.id=t,this.drawMode=0|n,this.attributes={},this.userData={},this._setAttributes(r,o),this.vertexCount=a||this._calculateVertexCount(this.attributes,this.indices)}get mode(){return this.drawMode}getVertexCount(){return this.vertexCount}getAttributes(){return this.indices?{indices:this.indices,...this.attributes}:this.attributes}_print(e){return"Geometry ".concat(this.id," attribute ").concat(e)}_setAttributes(e,t){t&&(this.indices=ArrayBuffer.isView(t)?{value:t,size:1}:t);for(const n in e){let t=e[n];t=ArrayBuffer.isView(t)?{value:t}:t,(0,r.h)(ArrayBuffer.isView(t.value),"".concat(this._print(n),": must be typed array or object with value as typed array")),"POSITION"!==n&&"positions"!==n||t.size||(t.size=3),"indices"===n?((0,r.h)(!this.indices),this.indices=t):this.attributes[n]=t}return this.indices&&void 0!==this.indices.isIndexed&&(this.indices=Object.assign({},this.indices),delete this.indices.isIndexed),this}_calculateVertexCount(e,t){if(t)return t.value.length;let n=1/0;for(const i in e){const t=e[i],{value:r,size:s,constant:o}=t;!o&&r&&s>=1&&(n=Math.min(n,r.length/s))}return(0,r.h)(Number.isFinite(n)),n}}},16816:function(e,t,n){n.d(t,{Z:function(){return h}});var i=n(1418),r=n(49835),s=n(22525),o=n(14178),a=n(37178),c=n(53849),l=n(93370);const u=(0,l.Z)()&&"undefined"!==typeof document;let f=0;class h{constructor(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};const{onCreateContext:t=(e=>(0,i.s9)(e)),onAddHTML:n=null,onInitialize:s=(()=>{}),onRender:o=(()=>{}),onFinalize:a=(()=>{}),onError:c,gl:l=null,glOptions:u={},debug:h=!1,createFramebuffer:d=!1,autoResizeViewport:g=!0,autoResizeDrawingBuffer:p=!0,stats:m=r.lR.get("animation-loop-".concat(f++))}=e;let{useDevicePixels:_=!0}=e;"useDevicePixelRatio"in e&&(i.cM.deprecated("useDevicePixelRatio","useDevicePixels")(),_=e.useDevicePixelRatio),this.props={onCreateContext:t,onAddHTML:n,onInitialize:s,onRender:o,onFinalize:a,onError:c,gl:l,glOptions:u,debug:h,createFramebuffer:d},this.gl=l,this.needsRedraw=null,this.timeline=null,this.stats=m,this.cpuTime=this.stats.get("CPU Time"),this.gpuTime=this.stats.get("GPU Time"),this.frameRate=this.stats.get("Frame Rate"),this._initialized=!1,this._running=!1,this._animationFrameId=null,this._nextFramePromise=null,this._resolveNextFrame=null,this._cpuStartTime=0,this.setProps({autoResizeViewport:g,autoResizeDrawingBuffer:p,useDevicePixels:_}),this.start=this.start.bind(this),this.stop=this.stop.bind(this),this._pageLoadPromise=null,this._onMousemove=this._onMousemove.bind(this),this._onMouseleave=this._onMouseleave.bind(this)}delete(){this.stop(),this._setDisplay(null)}setNeedsRedraw(e){return(0,s.h)("string"===typeof e),this.needsRedraw=this.needsRedraw||e,this}setProps(e){return"autoResizeViewport"in e&&(this.autoResizeViewport=e.autoResizeViewport),"autoResizeDrawingBuffer"in e&&(this.autoResizeDrawingBuffer=e.autoResizeDrawingBuffer),"useDevicePixels"in e&&(this.useDevicePixels=e.useDevicePixels),this}start(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};if(this._running)return this;this._running=!0;const t=this._getPageLoadPromise().then((()=>!this._running||this._initialized?null:(this._createWebGLContext(e),this._createFramebuffer(),this._startEventHandling(),this._initializeCallbackData(),this._updateCallbackData(),this._resizeCanvasDrawingBuffer(),this._resizeViewport(),this._gpuTimeQuery=o.Z.isSupported(this.gl,["timers"])?new o.Z(this.gl):null,this._initialized=!0,this.onInitialize(this.animationProps)))).then((e=>{this._running&&(this._addCallbackData(e||{}),!1!==e&&this._startLoop())}));return this.props.onError&&t.catch(this.props.onError),this}redraw(){return this.isContextLost()||(this._beginTimers(),this._setupFrame(),this._updateCallbackData(),this._renderFrame(this.animationProps),this._clearNeedsRedraw(),this.offScreen&&this.gl.commit&&this.gl.commit(),this._resolveNextFrame&&(this._resolveNextFrame(this),this._nextFramePromise=null,this._resolveNextFrame=null),this._endTimers()),this}stop(){return this._running&&(this._finalizeCallbackData(),this._cancelAnimationFrame(this._animationFrameId),this._nextFramePromise=null,this._resolveNextFrame=null,this._animationFrameId=null,this._running=!1),this}attachTimeline(e){return this.timeline=e,this.timeline}detachTimeline(){this.timeline=null}waitForRender(){return this.setNeedsRedraw("waitForRender"),this._nextFramePromise||(this._nextFramePromise=new Promise((e=>{this._resolveNextFrame=e}))),this._nextFramePromise}async toDataURL(){return this.setNeedsRedraw("toDataURL"),await this.waitForRender(),this.gl.canvas.toDataURL()}isContextLost(){return this.gl.isContextLost()}onCreateContext(){return this.props.onCreateContext(...arguments)}onInitialize(){return this.props.onInitialize(...arguments)}onRender(){return this.props.onRender(...arguments)}onFinalize(){return this.props.onFinalize(...arguments)}getHTMLControlValue(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;const n=document.getElementById(e);return n?Number(n.value):t}setViewParameters(){return i.cM.removed("AnimationLoop.setViewParameters","AnimationLoop.setProps")(),this}_startLoop(){const e=()=>{this._running&&(this.redraw(),this._animationFrameId=this._requestAnimationFrame(e))};this._cancelAnimationFrame(this._animationFrameId),this._animationFrameId=this._requestAnimationFrame(e)}_getPageLoadPromise(){return this._pageLoadPromise||(this._pageLoadPromise=u?new Promise(((e,t)=>{u&&"complete"===document.readyState?e(document):window.addEventListener("load",(()=>{e(document)}))})):Promise.resolve({})),this._pageLoadPromise}_setDisplay(e){this.display&&(this.display.delete(),this.display.animationLoop=null),e&&(e.animationLoop=this),this.display=e}_cancelAnimationFrame(e){return this.display&&this.display.cancelAnimationFrame?this.display.cancelAnimationFrame(e):(0,a.W)(e)}_requestAnimationFrame(e){if(this._running)return this.display&&this.display.requestAnimationFrame?this.display.requestAnimationFrame(e):(0,a.U)(e)}_renderFrame(){this.display?this.display._renderFrame(...arguments):this.onRender(...arguments)}_clearNeedsRedraw(){this.needsRedraw=null}_setupFrame(){this._resizeCanvasDrawingBuffer(),this._resizeViewport(),this._resizeFramebuffer()}_initializeCallbackData(){this.animationProps={gl:this.gl,stop:this.stop,canvas:this.gl.canvas,framebuffer:this.framebuffer,useDevicePixels:this.useDevicePixels,needsRedraw:null,startTime:Date.now(),engineTime:0,tick:0,tock:0,time:0,_timeline:this.timeline,_loop:this,_animationLoop:this,_mousePosition:null}}_updateCallbackData(){const{width:e,height:t,aspect:n}=this._getSizeAndAspect();e===this.animationProps.width&&t===this.animationProps.height||this.setNeedsRedraw("drawing buffer resized"),n!==this.animationProps.aspect&&this.setNeedsRedraw("drawing buffer aspect changed"),this.animationProps.width=e,this.animationProps.height=t,this.animationProps.aspect=n,this.animationProps.needsRedraw=this.needsRedraw,this.animationProps.engineTime=Date.now()-this.animationProps.startTime,this.timeline&&this.timeline.update(this.animationProps.engineTime),this.animationProps.tick=Math.floor(this.animationProps.time/1e3*60),this.animationProps.tock++,this.animationProps.time=this.timeline?this.timeline.getTime():this.animationProps.engineTime,this.animationProps._offScreen=this.offScreen}_finalizeCallbackData(){this.onFinalize(this.animationProps)}_addCallbackData(e){"object"===typeof e&&null!==e&&(this.animationProps=Object.assign({},this.animationProps,e))}_createWebGLContext(e){if(this.offScreen=e.canvas&&"undefined"!==typeof OffscreenCanvas&&e.canvas instanceof OffscreenCanvas,e=Object.assign({},e,this.props.glOptions),this.gl=this.props.gl?(0,i.yW)(this.props.gl,e):this.onCreateContext(e),!(0,i.UF)(this.gl))throw new Error("AnimationLoop.onCreateContext - illegal context returned");(0,i.kL)(this.gl),this._createInfoDiv()}_createInfoDiv(){if(this.gl.canvas&&this.props.onAddHTML){const e=document.createElement("div");document.body.appendChild(e),e.style.position="relative";const t=document.createElement("div");t.style.position="absolute",t.style.left="10px",t.style.bottom="10px",t.style.width="300px",t.style.background="white",e.appendChild(this.gl.canvas),e.appendChild(t);const n=this.props.onAddHTML(t);n&&(t.innerHTML=n)}}_getSizeAndAspect(){const e=this.gl.drawingBufferWidth,t=this.gl.drawingBufferHeight;let n=1;const{canvas:i}=this.gl;return i&&i.clientHeight?n=i.clientWidth/i.clientHeight:e>0&&t>0&&(n=e/t),{width:e,height:t,aspect:n}}_resizeViewport(){this.autoResizeViewport&&this.gl.viewport(0,0,this.gl.drawingBufferWidth,this.gl.drawingBufferHeight)}_resizeCanvasDrawingBuffer(){this.autoResizeDrawingBuffer&&(0,i.aQ)(this.gl,{useDevicePixels:this.useDevicePixels})}_createFramebuffer(){this.props.createFramebuffer&&(this.framebuffer=new c.Z(this.gl))}_resizeFramebuffer(){this.framebuffer&&this.framebuffer.resize({width:this.gl.drawingBufferWidth,height:this.gl.drawingBufferHeight})}_beginTimers(){this.frameRate.timeEnd(),this.frameRate.timeStart(),this._gpuTimeQuery&&this._gpuTimeQuery.isResultAvailable()&&!this._gpuTimeQuery.isTimerDisjoint()&&this.stats.get("GPU Time").addTime(this._gpuTimeQuery.getTimerMilliseconds()),this._gpuTimeQuery&&this._gpuTimeQuery.beginTimeElapsedQuery(),this.cpuTime.timeStart()}_endTimers(){this.cpuTime.timeEnd(),this._gpuTimeQuery&&this._gpuTimeQuery.end()}_startEventHandling(){const{canvas:e}=this.gl;e&&(e.addEventListener("mousemove",this._onMousemove),e.addEventListener("mouseleave",this._onMouseleave))}_onMousemove(e){this.animationProps._mousePosition=[e.offsetX,e.offsetY]}_onMouseleave(e){this.animationProps._mousePosition=null}}},80210:function(e,t,n){n.d(t,{Z:function(){return y}});var i=n(1418),r=n(43426),s=n(74538),o=n(22525),a=n(26047),c=n(75433),l=n(55045),u=n(53478),f=n(51053),h=n(61713),d=n(49258),g=n(3124);const p={POSITION:"positions",NORMAL:"normals",COLOR_0:"colors",TEXCOORD_0:"texCoords",TEXCOORD_1:"texCoords1",TEXCOORD_2:"texCoords2"};function m(e,t,n){const i={};let r=t.indices;for(const s in t.attributes){const o=t.attributes[s],a=_(s,n);if("indices"===s)r=o;else if(o.constant)i[a]=o.value;else{const t=o.value,n={...o};delete n.value,i[a]=[new u.Z(e,t),n],b(s,n)}}if(r){const t=r.value||r;(0,o.h)(t instanceof Uint16Array||t instanceof Uint32Array,'attribute array for "indices" must be of integer type');const n={size:1,isIndexed:void 0===r.isIndexed||r.isIndexed};i.indices=[new u.Z(e,{data:t,target:34963}),n]}return i}function _(e,t){const{attributeMap:n=p}=t||{};return n&&n[e]||e}function b(e,t){let n;switch(e){case"texCoords":case"texCoord1":case"texCoord2":case"texCoord3":n="uvs";break;case"vertices":case"positions":case"normals":case"pickingColors":n="vectors";break;default:}switch(n){case"vectors":t.size=t.size||3;break;case"uvs":t.size=t.size||2;break;default:}(0,o.h)(Number.isFinite(t.size),"attribute ".concat(e," needs size"))}const v=2,x=1e4,A="Model needs drawMode and vertexCount",T=()=>{},E={};class y{constructor(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};const{id:n=(0,s.hQ)("model")}=t;(0,o.h)((0,i.UF)(e)),this.id=n,this.gl=e,this.id=t.id||(0,s.hQ)("Model"),this.lastLogTime=0,this.animated=!1,this.initialize(t)}initialize(e){this.props={},this.programManager=e.programManager||r.Z.getDefaultProgramManager(this.gl),this._programManagerState=-1,this._managedProgram=!1;const{program:t=null,vs:n,fs:i,modules:s,defines:a,inject:c,varyings:l,bufferMode:u,transpileToGLSL100:f}=e;this.programProps={program:t,vs:n,fs:i,modules:s,defines:a,inject:c,varyings:l,bufferMode:u,transpileToGLSL100:f},this.program=null,this.vertexArray=null,this._programDirty=!0,this.userData={},this.needsRedraw=!0,this._attributes={},this.attributes={},this.uniforms={},this.pickable=!0,this._checkProgram(),this.setUniforms(Object.assign({},this.getModuleUniforms(e.moduleSettings))),this.drawMode=void 0!==e.drawMode?e.drawMode:4,this.vertexCount=e.vertexCount||0,this.geometryBuffers={},this.isInstanced=e.isInstanced||e.instanced||e.instanceCount>0,this._setModelProps(e),this.geometry={},(0,o.h)(void 0!==this.drawMode&&Number.isFinite(this.vertexCount),A)}setProps(e){this._setModelProps(e)}delete(){for(const e in this._attributes)this._attributes[e]!==this.attributes[e]&&this._attributes[e].delete();this._managedProgram&&(this.programManager.release(this.program),this._managedProgram=!1),this.vertexArray.delete(),this._deleteGeometryBuffers()}getDrawMode(){return this.drawMode}getVertexCount(){return this.vertexCount}getInstanceCount(){return this.instanceCount}getAttributes(){return this.attributes}getProgram(){return this.program}setProgram(e){const{program:t,vs:n,fs:i,modules:r,defines:s,inject:o,varyings:a,bufferMode:c,transpileToGLSL100:l}=e;this.programProps={program:t,vs:n,fs:i,modules:r,defines:s,inject:o,varyings:a,bufferMode:c,transpileToGLSL100:l},this._programDirty=!0}getUniforms(){return this.uniforms}setDrawMode(e){return this.drawMode=e,this}setVertexCount(e){return(0,o.h)(Number.isFinite(e)),this.vertexCount=e,this}setInstanceCount(e){return(0,o.h)(Number.isFinite(e)),this.instanceCount=e,this}setGeometry(e){return this.drawMode=e.drawMode,this.vertexCount=e.getVertexCount(),this._deleteGeometryBuffers(),this.geometryBuffers=m(this.gl,e),this.vertexArray.setAttributes(this.geometryBuffers),this}setAttributes(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};if((0,s.nK)(e))return this;const t={};for(const n in e){const i=e[n];t[n]=i.getValue?i.getValue():i}return this.vertexArray.setAttributes(t),this}setUniforms(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};return Object.assign(this.uniforms,e),this}getModuleUniforms(e){this._checkProgram();const t=this.programManager.getUniforms(this.program);return t?t(e):{}}updateModuleSettings(e){const t=this.getModuleUniforms(e||{});return this.setUniforms(t)}clear(e){return(0,a.Z)(this.program.gl,e),this}draw(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};this._checkProgram();const{moduleSettings:t=null,framebuffer:n,uniforms:r={},attributes:s={},transformFeedback:o=this.transformFeedback,parameters:a={},vertexArray:c=this.vertexArray}=e;let l;this.setAttributes(s),this.updateModuleSettings(t),this.setUniforms(r),i.cM.priority>=v&&(l=this._logDrawCallStart(v));const u=this.vertexArray.getDrawParams(),{isIndexed:f=u.isIndexed,indexType:h=u.indexType,indexOffset:d=u.indexOffset,vertexArrayInstanced:g=u.isInstanced}=this.props;g&&!this.isInstanced&&i.cM.warn("Found instanced attributes on non-instanced model",this.id)();const{isInstanced:p,instanceCount:m}=this,{onBeforeRender:_=T,onAfterRender:b=T}=this.props;_(),this.program.setUniforms(this.uniforms);const x=this.program.draw(Object.assign(E,e,{logPriority:l,uniforms:null,framebuffer:n,parameters:a,drawMode:this.getDrawMode(),vertexCount:this.getVertexCount(),vertexArray:c,transformFeedback:o,isIndexed:f,indexType:h,isInstanced:p,instanceCount:m,offset:f?d:0}));return b(),i.cM.priority>=v&&this._logDrawCallEnd(l,c,n),x}transform(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};const{discard:t=!0,feedbackBuffers:n,unbindModels:i=[]}=e;let{parameters:r}=e;n&&this._setFeedbackBuffers(n),t&&(r=Object.assign({},r,{[35977]:t})),i.forEach((e=>e.vertexArray.unbindBuffers()));try{this.draw(Object.assign({},e,{parameters:r}))}finally{i.forEach((e=>e.vertexArray.bindBuffers()))}return this}render(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};return i.cM.warn("Model.render() is deprecated. Use Model.setUniforms() and Model.draw()")(),this.setUniforms(e).draw()}_setModelProps(e){Object.assign(this.props,e),"uniforms"in e&&this.setUniforms(e.uniforms),"pickable"in e&&(this.pickable=e.pickable),"instanceCount"in e&&(this.instanceCount=e.instanceCount),"geometry"in e&&this.setGeometry(e.geometry),"attributes"in e&&this.setAttributes(e.attributes),"_feedbackBuffers"in e&&this._setFeedbackBuffers(e._feedbackBuffers)}_checkProgram(){const e=this._programDirty||this.programManager.stateHash!==this._programManagerState;if(!e)return;let{program:t}=this.programProps;if(t)this._managedProgram=!1;else{const{vs:e,fs:n,modules:i,inject:r,defines:s,varyings:o,bufferMode:a,transpileToGLSL100:c}=this.programProps;t=this.programManager.get({vs:e,fs:n,modules:i,inject:r,defines:s,varyings:o,bufferMode:a,transpileToGLSL100:c}),this.program&&this._managedProgram&&this.programManager.release(this.program),this._programManagerState=this.programManager.stateHash,this._managedProgram=!0}(0,o.h)(t instanceof c.Z,"Model needs a program"),this._programDirty=!1,t!==this.program&&(this.program=t,this.vertexArray?this.vertexArray.setProps({program:this.program,attributes:this.vertexArray.attributes}):this.vertexArray=new l.Z(this.gl,{program:this.program}),this.setUniforms(Object.assign({},this.getModuleUniforms())))}_deleteGeometryBuffers(){for(const e in this.geometryBuffers){const t=this.geometryBuffers[e][0]||this.geometryBuffers[e];t instanceof u.Z&&t.delete()}}_setAnimationProps(e){this.animated&&(0,o.h)(e,"Model.draw(): animated uniforms but no animationProps")}_setFeedbackBuffers(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};if((0,s.nK)(e))return this;const{gl:t}=this.program;return this.transformFeedback=this.transformFeedback||new f.Z(t,{program:this.program}),this.transformFeedback.setBuffers(e),this}_logDrawCallStart(e){const t=e>3?0:x;if(!(Date.now()-this.lastLogTime<t))return this.lastLogTime=Date.now(),i.cM.group(v,">>> DRAWING MODEL ".concat(this.id),{collapsed:i.cM.level<=2})(),e}_logDrawCallEnd(e,t,n,r){if(void 0===e)return;const s=(0,h.L)({vertexArray:t,header:"".concat(this.id," attributes"),attributes:this._attributes}),{table:o,unusedTable:a,unusedCount:c}=(0,d.d)({header:"".concat(this.id," uniforms"),program:this.program,uniforms:Object.assign({},this.program.uniforms,n)}),{table:l,count:u}=(0,d.d)({header:"".concat(this.id," uniforms"),program:this.program,uniforms:Object.assign({},this.program.uniforms,n),undefinedOnly:!0});u>0&&i.cM.log("MISSING UNIFORMS",Object.keys(l))(),c>0&&i.cM.log("UNUSED UNIFORMS",Object.keys(a))();const f=(0,g.n)(this.vertexArray.configuration);i.cM.table(e,s)(),i.cM.table(e,o)(),i.cM.table(e+1,f)(),r&&r.log({logLevel:v,message:"Rendered to ".concat(r.id)}),i.cM.groupEnd(v)()}}},43426:function(e,t,n){n.d(t,{Z:function(){return oe}});var i=n(75682),r=n(29047);const s={number:{validate(e,t){return Number.isFinite(e)&&(!("max"in t)||e<=t.max)&&(!("min"in t)||e>=t.min)}},array:{validate(e,t){return Array.isArray(e)||ArrayBuffer.isView(e)}}};function o(e){const t={};for(const n in e){const i=e[n],r=a(i);t[n]=r}return t}function a(e){let t=c(e);return"object"===t?e?"type"in e?Object.assign({},e,s[e.type]):"value"in e?(t=c(e.value),Object.assign({type:t},e,s[t])):{type:"object",value:e}:{type:"object",value:null}:Object.assign({type:t,value:e},s[t])}function c(e){return Array.isArray(e)||ArrayBuffer.isView(e)?"array":typeof e}const l="vs",u="fs";class f{constructor(e){let{name:t,vs:n,fs:i,dependencies:s=[],uniforms:a,getUniforms:c,deprecations:l=[],defines:u={},inject:f={},vertexShader:d,fragmentShader:g}=e;(0,r.Z)("string"===typeof t),this.name=t,this.vs=n||d,this.fs=i||g,this.getModuleUniforms=c,this.dependencies=s,this.deprecations=this._parseDeprecationDefinitions(l),this.defines=u,this.injections=h(f),a&&(this.uniforms=o(a))}getModuleSource(e){let t;switch(e){case l:t=this.vs||"";break;case u:t=this.fs||"";break;default:(0,r.Z)(!1)}return"#define MODULE_".concat(this.name.toUpperCase().replace(/[^0-9a-z]/gi,"_"),"\n").concat(t,"// END MODULE_").concat(this.name,"\n\n")}getUniforms(e,t){return this.getModuleUniforms?this.getModuleUniforms(e,t):this.uniforms?this._defaultGetUniforms(e):{}}getDefines(){return this.defines}checkDeprecations(e,t){this.deprecations.forEach((n=>{n.regex.test(e)&&(n.deprecated?t.deprecated(n.old,n.new)():t.removed(n.old,n.new)())}))}_parseDeprecationDefinitions(e){return e.forEach((e=>{switch(e.type){case"function":e.regex=new RegExp("\\b".concat(e.old,"\\("));break;default:e.regex=new RegExp("".concat(e.type," ").concat(e.old,";"))}})),e}_defaultGetUniforms(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};const t={},n=this.uniforms;for(const i in n){const s=n[i];i in e&&!s.private?(s.validate&&(0,r.Z)(s.validate(e[i],s),"".concat(this.name,": invalid ").concat(i)),t[i]=e[i]):t[i]=s.value}return t}}function h(e){const t={vs:{},fs:{}};for(const n in e){let i=e[n];const r=n.slice(0,2);"string"===typeof i&&(i={order:0,injection:i}),t[r][n]=i}return t}function d(e){return g(m(e))}function g(e){const t={},n={};return p({modules:e,level:0,moduleMap:t,moduleDepth:n}),Object.keys(n).sort(((e,t)=>n[t]-n[e])).map((e=>t[e]))}function p(e){let{modules:t,level:n,moduleMap:i,moduleDepth:r}=e;if(n>=5)throw new Error("Possible loop in shader dependency graph");for(const s of t)i[s.name]=s,(void 0===r[s.name]||r[s.name]<n)&&(r[s.name]=n);for(const s of t)s.dependencies&&p({modules:s.dependencies,level:n+1,moduleMap:i,moduleDepth:r})}function m(e,t){return e.map((e=>(e instanceof f||((0,r.Z)("string"!==typeof e,"Shader module use by name is deprecated. Import shader module '".concat(e,"' and use it directly.")),(0,r.Z)(e.name,"shader module has no name"),e=new f(e),e.dependencies=m(e.dependencies)),e)))}function _(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};const t="undefined"!==typeof window&&window.navigator||{},n=e.userAgent||t.userAgent||"",i=-1!==n.indexOf("MSIE "),r=-1!==n.indexOf("Trident/");return i||r}const b=7936,v=7937,x=7938,A=35724,T={GLSL_FRAG_DATA:["WEBGL_draw_buffers",!0],GLSL_FRAG_DEPTH:["EXT_frag_depth",!0],GLSL_DERIVATIVES:["OES_standard_derivatives",!0],GLSL_TEXTURE_LOD:["EXT_shader_texture_lod",!0]},E={};function y(e){return"undefined"!==typeof WebGL2RenderingContext&&e instanceof WebGL2RenderingContext||Boolean(e&&2===e._version)}function L(e){const t=e.getExtension("WEBGL_debug_renderer_info"),n=e.getParameter(t&&t.UNMASKED_VENDOR_WEBGL||b),i=e.getParameter(t&&t.UNMASKED_RENDERER_WEBGL||v),r=S(n,i),s={gpuVendor:r,vendor:n,renderer:i,version:e.getParameter(x),shadingLanguageVersion:e.getParameter(A)};return s}function S(e,t){return e.match(/NVIDIA/i)||t.match(/NVIDIA/i)?"NVIDIA":e.match(/INTEL/i)||t.match(/INTEL/i)?"INTEL":e.match(/AMD/i)||t.match(/AMD/i)||e.match(/ATI/i)||t.match(/ATI/i)?"AMD":"UNKNOWN GPU"}Object.keys(T).forEach((e=>{E[e]=e}));const C={};function I(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};const i=T[t];if((0,r.Z)(i,t),!_(n))return!0;if(t in C)return C[t];const s=i[0],o=n.behavior||"enable",a="#extension GL_".concat(s," : ").concat(o,"\nvoid main(void) {}"),c=e.createShader(35633);e.shaderSource(c,a),e.compileShader(c);const l=e.getShaderParameter(c,35713);return e.deleteShader(c),C[t]=l,l}function R(e,t){const n=T[t];(0,r.Z)(n,t);const i=y(e)&&n[1]||n[0],s="string"===typeof i?Boolean(e.getExtension(i)):i;return(0,r.Z)(!1===s||!0===s),s}function w(e,t){return t=Array.isArray(t)?t:[t],t.every((t=>R(e,t)))}function O(e){const t=L(e);switch(t.gpuVendor.toLowerCase()){case"nvidia":return"#define NVIDIA_GPU\n// Nvidia optimizes away the calculation necessary for emulated fp64\n#define LUMA_FP64_CODE_ELIMINATION_WORKAROUND 1\n";case"intel":return"#define INTEL_GPU\n// Intel optimizes away the calculation necessary for emulated fp64\n#define LUMA_FP64_CODE_ELIMINATION_WORKAROUND 1\n// Intel's built-in 'tan' function doesn't have acceptable precision\n#define LUMA_FP32_TAN_PRECISION_WORKAROUND 1\n// Intel GPU doesn't have full 32 bits precision in same cases, causes overflow\n#define LUMA_FP64_HIGH_BITS_OVERFLOW_WORKAROUND 1\n";case"amd":return"#define AMD_GPU\n";default:return"#define DEFAULT_GPU\n// Prevent driver from optimizing away the calculation necessary for emulated fp64\n#define LUMA_FP64_CODE_ELIMINATION_WORKAROUND 1\n// Intel's built-in 'tan' function doesn't have acceptable precision\n#define LUMA_FP32_TAN_PRECISION_WORKAROUND 1\n// Intel GPU doesn't have full 32 bits precision in same cases, causes overflow\n#define LUMA_FP64_HIGH_BITS_OVERFLOW_WORKAROUND 1\n"}}function M(e,t,n){let i="#if (__VERSION__ > 120)\n\n# define FEATURE_GLSL_DERIVATIVES\n# define FEATURE_GLSL_DRAW_BUFFERS\n# define FEATURE_GLSL_FRAG_DEPTH\n# define FEATURE_GLSL_TEXTURE_LOD\n\n// DEPRECATED FLAGS, remove in v9\n# define FRAG_DEPTH\n# define DERIVATIVES\n# define DRAW_BUFFERS\n# define TEXTURE_LOD\n\n#endif // __VERSION\n";return w(e,E.GLSL_FRAG_DEPTH)&&(i+="\n// FRAG_DEPTH => gl_FragDepth is available\n#ifdef GL_EXT_frag_depth\n#extension GL_EXT_frag_depth : enable\n# define FEATURE_GLSL_FRAG_DEPTH\n# define FRAG_DEPTH\n# define gl_FragDepth gl_FragDepthEXT\n#endif\n"),w(e,E.GLSL_DERIVATIVES)&&I(e,E.GLSL_DERIVATIVES)&&(i+="\n// DERIVATIVES => dxdF, dxdY and fwidth are available\n#ifdef GL_OES_standard_derivatives\n#extension GL_OES_standard_derivatives : enable\n# define FEATURE_GLSL_DERIVATIVES\n# define DERIVATIVES\n#endif\n"),w(e,E.GLSL_FRAG_DATA)&&I(e,E.GLSL_FRAG_DATA,{behavior:"require"})&&(i+="\n// DRAW_BUFFERS => gl_FragData[] is available\n#ifdef GL_EXT_draw_buffers\n#extension GL_EXT_draw_buffers : require\n#define FEATURE_GLSL_DRAW_BUFFERS\n#define DRAW_BUFFERS\n#endif\n"),w(e,E.GLSL_TEXTURE_LOD)&&(i+="// TEXTURE_LOD => texture2DLod etc are available\n#ifdef GL_EXT_shader_texture_lod\n#extension GL_EXT_shader_texture_lod : enable\n\n# define FEATURE_GLSL_TEXTURE_LOD\n# define TEXTURE_LOD\n\n#endif\n"),i}var P=n(60827);function N(e){return new RegExp("\\b".concat(e,"[ \\t]+(\\w+[ \\t]+\\w+(\\[\\w+\\])?;)"),"g")}const B=[[/^(#version[ \t]+(100|300[ \t]+es))?[ \t]*\n/,"#version 300 es\n"],[/\btexture(2D|2DProj|Cube)Lod(EXT)?\(/g,"textureLod("],[/\btexture(2D|2DProj|Cube)(EXT)?\(/g,"texture("]],D=[...B,[N("attribute"),"in $1"],[N("varying"),"out $1"]],F=[...B,[N("varying"),"in $1"]],k=[[/^#version[ \t]+300[ \t]+es/,"#version 100"],[/\btexture(2D|2DProj|Cube)Lod\(/g,"texture$1LodEXT("],[/\btexture\(/g,"texture2D("],[/\btextureLod\(/g,"texture2DLodEXT("]],V=[...k,[N("in"),"attribute $1"],[N("out"),"varying $1"]],G=[...k,[N("in"),"varying $1"]],U="gl_FragColor",j=/\bout[ \t]+vec4[ \t]+(\w+)[ \t]*;\n?/,H=/void\s+main\s*\([^)]*\)\s*\{\n?/;function z(e,t,n){switch(t){case 300:return n?W(e,D):Z(e);case 100:return n?W(e,V):X(e);default:throw new Error("unknown GLSL version ".concat(t))}}function W(e,t){for(const[n,i]of t)e=e.replace(n,i);return e}function Z(e){e=W(e,F);const t=e.match(j);if(t){const n=t[1];e=e.replace(new RegExp("\\b".concat(U,"\\b"),"g"),n)}else{const t="fragmentColor";e=e.replace(H,(e=>"out vec4 ".concat(t,";\n").concat(e))).replace(new RegExp("\\b".concat(U,"\\b"),"g"),t)}return e}function X(e){e=W(e,G);const t=e.match(j);if(t){const n=t[1];e=e.replace(j,"").replace(new RegExp("\\b".concat(n,"\\b"),"g"),U)}return e}const q="\n\n".concat(P.O_,"\n\n"),Q={[i.H]:"vertex",[i.Y]:"fragment"},K="precision highp float;\n\n";function Y(e,t){const{vs:n,fs:r}=t,s=d(t.modules||[]);return{gl:e,vs:$(e,Object.assign({},t,{source:n,type:i.H,modules:s})),fs:$(e,Object.assign({},t,{source:r,type:i.Y,modules:s})),getUniforms:J(s)}}function $(e,t){let{id:n,source:s,type:o,modules:a,defines:c={},hookFunctions:l=[],inject:u={},transpileToGLSL100:f=!1,prologue:h=!0,log:d}=t;(0,r.Z)("string"===typeof s,"shader source must be a string");const g=o===i.H,p=s.split("\n");let m=100,_="",b=s;0===p[0].indexOf("#version ")?(m=300,_=p[0],b=p.slice(1).join("\n")):_="#version ".concat(m);const v={};a.forEach((e=>{Object.assign(v,e.getDefines())})),Object.assign(v,c);let x=h?"".concat(_,"\n").concat(te({id:n,source:s,type:o}),"\n").concat(ee({type:o}),"\n").concat(O(e),"\n").concat(M(e,m,!g),"\n").concat(ne(v),"\n").concat(g?"":K,"\n"):"".concat(_,"\n");const A=re(l),T={},E={},y={};for(const i in u){const e="string"===typeof u[i]?{injection:u[i],order:0}:u[i],t=i.match(/^(v|f)s:(#)?([\w-]+)$/);if(t){const n=t[2],r=t[3];n?"decl"===r?E[i]=[e]:y[i]=[e]:T[i]=[e]}else y[i]=[e]}for(const i of a){d&&i.checkDeprecations(b,d);const e=i.getModuleSource(o,m);x+=e;const t=i.injections[o];for(const n in t){const e=n.match(/^(v|f)s:#([\w-]+)$/);if(e){const i=e[2],r="decl"===i?E:y;r[n]=r[n]||[],r[n].push(t[n])}else T[n]=T[n]||[],T[n].push(t[n])}}return x+=q,x=(0,P.ZP)(x,o,E),x+=ie(A[o],T),x+=b,x=(0,P.ZP)(x,o,y),x=z(x,f?100:m,g),x}function J(e){return function(t){const n={};for(const i of e){const e=i.getUniforms(t,n);Object.assign(n,e)}return n}}function ee(e){let{type:t}=e;return"\n#define SHADER_TYPE_".concat(Q[t].toUpperCase(),"\n")}function te(e){let{id:t,source:n,type:i}=e;const r=t&&"string"===typeof t&&-1===n.indexOf("SHADER_NAME");return r?"\n#define SHADER_NAME ".concat(t,"_").concat(Q[i],"\n\n"):""}function ne(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},t=0,n="";for(const i in e){0===t&&(n+="\n// APPLICATION DEFINES\n"),t++;const r=e[i];(r||Number.isFinite(r))&&(n+="#define ".concat(i.toUpperCase()," ").concat(e[i],"\n"))}return 0===t&&(n+="\n"),n}function ie(e,t){let n="";for(const i in e){const r=e[i];if(n+="void ".concat(r.signature," {\n"),r.header&&(n+="  ".concat(r.header)),t[i]){const e=t[i];e.sort(((e,t)=>e.order-t.order));for(const t of e)n+="  ".concat(t.injection,"\n")}r.footer&&(n+="  ".concat(r.footer)),n+="}\n"}return n}function re(e){const t={vs:{},fs:{}};return e.forEach((e=>{let n;"string"!==typeof e?(n=e,e=n.hook):n={},e=e.trim();const[i,r]=e.split(":"),s=e.replace(/\(.+/,"");t[i][s]=Object.assign(n,{signature:r})})),t}var se=n(75433);class oe{static getDefaultProgramManager(e){return e.luma=e.luma||{},e.luma.defaultProgramManager=e.luma.defaultProgramManager||new oe(e),e.luma.defaultProgramManager}constructor(e){this.gl=e,this._programCache={},this._getUniforms={},this._registeredModules={},this._hookFunctions=[],this._defaultModules=[],this._hashes={},this._hashCounter=0,this.stateHash=0,this._useCounts={}}addDefaultModule(e){this._defaultModules.find((t=>t.name===e.name))||this._defaultModules.push(e),this.stateHash++}removeDefaultModule(e){const t="string"===typeof e?e:e.name;this._defaultModules=this._defaultModules.filter((e=>e.name!==t)),this.stateHash++}addShaderHook(e,t){t&&(e=Object.assign(t,{hook:e})),this._hookFunctions.push(e),this.stateHash++}get(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};const{vs:t="",fs:n="",defines:i={},inject:r={},varyings:s=[],bufferMode:o=35981,transpileToGLSL100:a=!1}=e,c=this._getModuleList(e.modules),l=this._getHash(t),u=this._getHash(n),f=c.map((e=>this._getHash(e.name))).sort(),h=s.map((e=>this._getHash(e))),d=Object.keys(i).sort(),g=Object.keys(r).sort(),p=[],m=[];for(const b of d)p.push(this._getHash(b)),p.push(this._getHash(i[b]));for(const b of g)m.push(this._getHash(b)),m.push(this._getHash(r[b]));const _="".concat(l,"/").concat(u,"D").concat(p.join("/"),"M").concat(f.join("/"),"I").concat(m.join("/"),"V").concat(h.join("/"),"H").concat(this.stateHash,"B").concat(o).concat(a?"T":"");if(!this._programCache[_]){const e=Y(this.gl,{vs:t,fs:n,modules:c,inject:r,defines:i,hookFunctions:this._hookFunctions,transpileToGLSL100:a});this._programCache[_]=new se.Z(this.gl,{hash:_,vs:e.vs,fs:e.fs,varyings:s,bufferMode:o}),this._getUniforms[_]=e.getUniforms||(e=>{}),this._useCounts[_]=0}return this._useCounts[_]++,this._programCache[_]}getUniforms(e){return this._getUniforms[e.hash]||null}release(e){const t=e.hash;this._useCounts[t]--,0===this._useCounts[t]&&(this._programCache[t].delete(),delete this._programCache[t],delete this._getUniforms[t],delete this._useCounts[t])}_getHash(e){return void 0===this._hashes[e]&&(this._hashes[e]=this._hashCounter++),this._hashes[e]}_getModuleList(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:[];const t=new Array(this._defaultModules.length+e.length),n={};let i=0;for(let r=0,s=this._defaultModules.length;r<s;++r){const e=this._defaultModules[r],s=e.name;t[i++]=e,n[s]=!0}for(let r=0,s=e.length;r<s;++r){const s=e[r],o=s.name;n[o]||(t[i++]=s,n[o]=!0)}return t.length=i,t}}},19718:function(e,t,n){n.d(t,{Z:function(){return V}});var i=n(29047);const r="void main() {gl_FragColor = vec4(0);}",s="out vec4 transform_output;\nvoid main() {\n  transform_output = vec4(0);\n}",o="#version 300 es\n".concat(s);function a(e,t){t=Array.isArray(t)?t:[t];const n=e.replace(/^\s+/,"").split(/\s+/),[i,r,s]=n;if(!t.includes(i)||!r||!s)return null;const o=s.split(";")[0];return{qualifier:i,type:r,name:o}}function c(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};const{version:t=100,input:n,inputType:i,output:a}=e;if(!n)return 300===t?o:t>300?"#version ".concat(t,"\n").concat(s):r;const c=f(n,i);return t>=300?"#version ".concat(t," ").concat(300===t?"es":"","\nin ").concat(i," ").concat(n,";\nout vec4 ").concat(a,";\nvoid main() {\n  ").concat(a," = ").concat(c,";\n}"):"varying ".concat(i," ").concat(n,";\nvoid main() {\n  gl_FragColor = ").concat(c,";\n}")}function l(e){switch(e){case"float":return"x";case"vec2":return"xy";case"vec3":return"xyz";case"vec4":return"xyzw";default:return(0,i.Z)(!1),null}}function u(e){switch(e){case"float":return 1;case"vec2":return 2;case"vec3":return 3;case"vec4":return 4;default:return(0,i.Z)(!1),null}}function f(e,t){switch(t){case"float":return"vec4(".concat(e,", 0.0, 0.0, 1.0)");case"vec2":return"vec4(".concat(e,", 0.0, 1.0)");case"vec3":return"vec4(".concat(e,", 1.0)");case"vec4":return e;default:return(0,i.Z)(!1),null}}var h=n(1418),d=n(53478),g=n(51053),p=n(22525);class m{constructor(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};this.gl=e,this.currentIndex=0,this.feedbackMap={},this.varyings=null,this.bindings=[],this.resources={},this._initialize(t),Object.seal(this)}setupResources(e){for(const t of this.bindings)this._setupTransformFeedback(t,e)}updateModelProps(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};const{varyings:t}=this;return t.length>0&&(e=Object.assign({},e,{varyings:t})),e}getDrawOptions(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};const t=this.bindings[this.currentIndex],{sourceBuffers:n,transformFeedback:i}=t,r=Object.assign({},n,e.attributes);return{attributes:r,transformFeedback:i}}swap(){return!!this.feedbackMap&&(this.currentIndex=this._getNextIndex(),!0)}update(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};this._setupBuffers(e)}getBuffer(e){const{feedbackBuffers:t}=this.bindings[this.currentIndex],n=e?t[e]:null;return n?n instanceof d.Z?n:n.buffer:null}getData(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};const{varyingName:t}=e,n=this.getBuffer(t);return n?n.getData():null}delete(){for(const e in this.resources)this.resources[e].delete()}_initialize(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};this._setupBuffers(e),this.varyings=e.varyings||Object.keys(this.bindings[this.currentIndex].feedbackBuffers),this.varyings.length>0&&(0,p.h)((0,h.D0)(this.gl))}_getFeedbackBuffers(e){const{sourceBuffers:t={}}=e,n={};if(this.bindings[this.currentIndex]&&Object.assign(n,this.bindings[this.currentIndex].feedbackBuffers),this.feedbackMap)for(const i in this.feedbackMap){const e=this.feedbackMap[i];i in t&&(n[e]=i)}Object.assign(n,e.feedbackBuffers);for(const i in n){const e=n[i];if("string"===typeof e){const r=t[e],{byteLength:s,usage:o,accessor:a}=r;n[i]=this._createNewBuffer(i,{byteLength:s,usage:o,accessor:a})}}return n}_setupBuffers(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};const{sourceBuffers:t=null}=e;Object.assign(this.feedbackMap,e.feedbackMap);const n=this._getFeedbackBuffers(e);this._updateBindings({sourceBuffers:t,feedbackBuffers:n})}_setupTransformFeedback(e,t){let{model:n}=t;const{program:i}=n;e.transformFeedback=new g.Z(this.gl,{program:i,buffers:e.feedbackBuffers})}_updateBindings(e){if(this.bindings[this.currentIndex]=this._updateBinding(this.bindings[this.currentIndex],e),this.feedbackMap){const{sourceBuffers:e,feedbackBuffers:t}=this._swapBuffers(this.bindings[this.currentIndex]),n=this._getNextIndex();this.bindings[n]=this._updateBinding(this.bindings[n],{sourceBuffers:e,feedbackBuffers:t})}}_updateBinding(e,t){return e?(Object.assign(e.sourceBuffers,t.sourceBuffers),Object.assign(e.feedbackBuffers,t.feedbackBuffers),e.transformFeedback&&e.transformFeedback.setBuffers(e.feedbackBuffers),e):{sourceBuffers:Object.assign({},t.sourceBuffers),feedbackBuffers:Object.assign({},t.feedbackBuffers)}}_swapBuffers(e){if(!this.feedbackMap)return null;const t=Object.assign({},e.sourceBuffers),n=Object.assign({},e.feedbackBuffers);for(const i in this.feedbackMap){const r=this.feedbackMap[i];t[i]=e.feedbackBuffers[r],n[r]=e.sourceBuffers[i],(0,p.h)(n[r]instanceof d.Z)}return{sourceBuffers:t,feedbackBuffers:n}}_createNewBuffer(e,t){const n=new d.Z(this.gl,t);return this.resources[e]&&this.resources[e].delete(),this.resources[e]=n,n}_getNextIndex(){return(this.currentIndex+1)%2}}var _=n(81913),b=n(51621),v=n(53849),x=n(73462),A=n(27588),T=n(60827);const E="attribute float transform_elementID;\nvec2 transform_getPixelSizeHalf(vec2 size) {\n  return vec2(1.) / (2. * size);\n}\n\nvec2 transform_getPixelIndices(vec2 texSize, vec2 pixelSizeHalf) {\n  float yIndex = floor((transform_elementID / texSize[0]) + pixelSizeHalf[1]);\n  float xIndex = transform_elementID - (yIndex * texSize[0]);\n  return vec2(xIndex, yIndex);\n}\nvec2 transform_getTexCoord(vec2 size) {\n  vec2 pixelSizeHalf = transform_getPixelSizeHalf(size);\n  vec2 indices = transform_getPixelIndices(size, pixelSizeHalf);\n  vec2 coord = indices / size + pixelSizeHalf;\n  return coord;\n}\nvec2 transform_getPos(vec2 size) {\n  vec2 texCoord = transform_getTexCoord(size);\n  vec2 pos = (texCoord * (2.0, 2.0)) - (1., 1.);\n  return pos;\n}\nvec4 transform_getInput(sampler2D texSampler, vec2 size) {\n  vec2 texCoord = transform_getTexCoord(size);\n  vec4 textureColor = texture2D(texSampler, texCoord);\n  return textureColor;\n}\n",y={name:"transform",vs:E,fs:null},L="transform_uSampler_",S="transform_uSize_",C="transform_position";function I(e){let{vs:t,sourceTextureMap:n,targetTextureVarying:i,targetTexture:r}=e;const s=Object.keys(n);let o=s.length,a=null;const c={};let l=t,u={};if(o>0||i){const e=l.split("\n"),t=e.slice();if(e.forEach(((e,r,s)=>{if(o>0){const i=P(e,n);if(i){const{updatedLine:e,inject:n}=i;t[r]=e,u=(0,T.Lm)([u,n]),Object.assign(c,i.samplerTextureMap),o--}}i&&!a&&(a=M(e,i))})),i){(0,p.h)(r);const e="".concat(S).concat(i),t="uniform vec2 ".concat(e,";\n"),n="     vec2 ".concat(C," = transform_getPos(").concat(e,");\n     gl_Position = vec4(").concat(C,", 0, 1.);\n"),s={"vs:#decl":t,"vs:#main-start":n};u=(0,T.Lm)([u,s])}l=t.join("\n")}return{vs:l,targetTextureType:a,inject:u,samplerTextureMap:c}}function R(e){let{sourceTextureMap:t,targetTextureVarying:n,targetTexture:i}=e;const r={};let s,o;n&&(({width:s,height:o}=i),r["".concat(S).concat(n)]=[s,o]);for(const a in t)({width:s,height:o}=t[a]),r["".concat(S).concat(a)]=[s,o];return r}function w(e){return a(e,["attribute","in"])}function O(e){const t="".concat(L).concat(e),n="".concat(S).concat(e),i="  uniform sampler2D ".concat(t,";\n  uniform vec2 ").concat(n,";");return{samplerName:t,sizeName:n,uniformDeclerations:i}}function M(e,t){const n=a(e,["varying","out"]);return n&&n.name===t?n.type:null}function P(e,t){const n={},i=w(e);if(!i)return null;const{type:r,name:s}=i;if(s&&t[s]){const t="// ".concat(e," => Replaced by Transform with a sampler"),{samplerName:i,sizeName:o,uniformDeclerations:a}=O(s),c=l(r),u="  ".concat(r," ").concat(s," = transform_getInput(").concat(i,", ").concat(o,").").concat(c,";\n");n[i]=s;const f={"vs:#decl":a,"vs:#main-start":u};return{updatedLine:t,inject:f,samplerTextureMap:n}}return null}const N={[10241]:9728,[10240]:9728,[10242]:33071,[10243]:33071},B="transform_output";class D{constructor(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};this.gl=e,this.id=this.currentIndex=0,this._swapTexture=null,this.targetTextureVarying=null,this.targetTextureType=null,this.samplerTextureMap=null,this.bindings=[],this.resources={},this._initialize(t),Object.seal(this)}updateModelProps(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};const t=this._processVertexShader(e);return Object.assign({},e,t)}getDrawOptions(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};const{sourceBuffers:t,sourceTextures:n,framebuffer:i,targetTexture:r}=this.bindings[this.currentIndex],s=Object.assign({},t,e.attributes),o=Object.assign({},e.uniforms),a=Object.assign({},e.parameters);let c=e.discard;if(this.hasSourceTextures||this.hasTargetTexture){s.transform_elementID=this.elementIDBuffer;for(const t in this.samplerTextureMap){const e=this.samplerTextureMap[t];o[t]=n[e]}this._setSourceTextureParameters();const e=R({sourceTextureMap:n,targetTextureVarying:this.targetTextureVarying,targetTexture:r});Object.assign(o,e)}return this.hasTargetTexture&&(c=!1,a.viewport=[0,0,i.width,i.height]),{attributes:s,framebuffer:i,uniforms:o,discard:c,parameters:a}}swap(){return!!this._swapTexture&&(this.currentIndex=this._getNextIndex(),!0)}update(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};this._setupTextures(e)}getTargetTexture(){const{targetTexture:e}=this.bindings[this.currentIndex];return e}getData(){let{packed:e=!1}=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};const{framebuffer:t}=this.bindings[this.currentIndex],n=(0,_.z6)(t);if(!e)return n;const i=n.constructor,r=u(this.targetTextureType),s=new i(n.length*r/4);let o=0;for(let a=0;a<n.length;a+=4)for(let e=0;e<r;e++)s[o++]=n[a+e];return s}getFramebuffer(){const e=this.bindings[this.currentIndex];return e.framebuffer}delete(){this.ownTexture&&this.ownTexture.delete(),this.elementIDBuffer&&this.elementIDBuffer.delete()}_initialize(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};const{_targetTextureVarying:t,_swapTexture:n}=e;this._swapTexture=n,this.targetTextureVarying=t,this.hasTargetTexture=t,this._setupTextures(e)}_createTargetTexture(e){const{sourceTextures:t,textureOrReference:n}=e;if(n instanceof b.Z)return n;const i=t[n];return i?(this._targetRefTexName=n,this._createNewTexture(i)):null}_setupTextures(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};const{sourceBuffers:t,_sourceTextures:n={},_targetTexture:i}=e,r=this._createTargetTexture({sourceTextures:n,textureOrReference:i});this.hasSourceTextures=this.hasSourceTextures||n&&Object.keys(n).length>0,this._updateBindings({sourceBuffers:t,sourceTextures:n,targetTexture:r}),"elementCount"in e&&this._updateElementIDBuffer(e.elementCount)}_updateElementIDBuffer(e){if("number"!==typeof e||this.elementCount>=e)return;const t=new Float32Array(e);t.forEach(((e,t,n)=>{n[t]=t})),this.elementIDBuffer?this.elementIDBuffer.setData({data:t}):this.elementIDBuffer=new d.Z(this.gl,{data:t,accessor:{size:1}}),this.elementCount=e}_updateBindings(e){if(this.bindings[this.currentIndex]=this._updateBinding(this.bindings[this.currentIndex],e),this._swapTexture){const{sourceTextures:e,targetTexture:t}=this._swapTextures(this.bindings[this.currentIndex]),n=this._getNextIndex();this.bindings[n]=this._updateBinding(this.bindings[n],{sourceTextures:e,targetTexture:t})}}_updateBinding(e,t){const{sourceBuffers:n,sourceTextures:i,targetTexture:r}=t;if(e||(e={sourceBuffers:{},sourceTextures:{},targetTexture:null}),Object.assign(e.sourceTextures,i),Object.assign(e.sourceBuffers,n),r){e.targetTexture=r;const{width:t,height:n}=r,{framebuffer:i}=e;i?(i.update({attachments:{[36064]:r},resizeAttachments:!1}),i.resize({width:t,height:n})):e.framebuffer=new v.Z(this.gl,{id:"transform-framebuffer",width:t,height:n,attachments:{[36064]:r}})}return e}_setSourceTextureParameters(){const e=this.currentIndex,{sourceTextures:t}=this.bindings[e];for(const n in t)t[n].setParameters(N)}_swapTextures(e){if(!this._swapTexture)return null;const t=Object.assign({},e.sourceTextures);t[this._swapTexture]=e.targetTexture;const n=e.sourceTextures[this._swapTexture];return{sourceTextures:t,targetTexture:n}}_createNewTexture(e){const t=(0,x.h)(e,{parameters:{[10241]:9728,[10240]:9728,[10242]:33071,[10243]:33071},pixelStore:{[37440]:!1}});return this.ownTexture&&this.ownTexture.delete(),this.ownTexture=t,t}_getNextIndex(){return(this.currentIndex+1)%2}_processVertexShader(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};const{sourceTextures:t,targetTexture:n}=this.bindings[this.currentIndex],{vs:i,uniforms:r,targetTextureType:s,inject:o,samplerTextureMap:a}=I({vs:e.vs,sourceTextureMap:t,targetTextureVarying:this.targetTextureVarying,targetTexture:n}),l=(0,T.Lm)([e.inject||{},o]);this.targetTextureType=s,this.samplerTextureMap=a;const u=e._fs||c({version:(0,A.Z)(i),input:this.targetTextureVarying,inputType:s,output:B}),f=this.hasSourceTextures||this.targetTextureVarying?[y].concat(e.modules||[]):e.modules;return{vs:i,fs:u,modules:f,uniforms:r,inject:l}}}var F=n(74538),k=n(80210);class V{static isSupported(e){return(0,h.D0)(e)}constructor(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};this.gl=e,this.model=null,this.elementCount=0,this.bufferTransform=null,this.textureTransform=null,this.elementIDBuffer=null,this._initialize(t),Object.seal(this)}delete(){const{model:e,bufferTransform:t,textureTransform:n}=this;e&&e.delete(),t&&t.delete(),n&&n.delete()}run(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};const{clearRenderTarget:t=!0}=e,n=this._updateDrawOptions(e);t&&n.framebuffer&&n.framebuffer.clear({color:!0}),this.model.transform(n)}swap(){let e=!1;const t=[this.bufferTransform,this.textureTransform].filter(Boolean);for(const n of t)e=e||n.swap();(0,p.h)(e,"Nothing to swap")}getBuffer(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:null;return this.bufferTransform&&this.bufferTransform.getBuffer(e)}getData(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};const t=[this.bufferTransform,this.textureTransform].filter(Boolean);for(const n of t){const t=n.getData(e);if(t)return t}return null}getFramebuffer(){return this.textureTransform&&this.textureTransform.getFramebuffer()}update(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};"elementCount"in e&&this.model.setVertexCount(e.elementCount);const t=[this.bufferTransform,this.textureTransform].filter(Boolean);for(const n of t)n.update(e)}_initialize(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};const{gl:t}=this;this._buildResourceTransforms(t,e),e=this._updateModelProps(e),this.model=new k.Z(t,Object.assign({},e,{fs:e.fs||c({version:(0,A.Z)(e.vs)}),id:e.id||"transform-model",drawMode:e.drawMode||0,vertexCount:e.elementCount})),this.bufferTransform&&this.bufferTransform.setupResources({model:this.model})}_updateModelProps(e){let t=Object.assign({},e);const n=[this.bufferTransform,this.textureTransform].filter(Boolean);for(const i of n)t=i.updateModelProps(t);return t}_buildResourceTransforms(e,t){G(t)&&(this.bufferTransform=new m(e,t)),U(t)&&(this.textureTransform=new D(e,t)),(0,p.h)(this.bufferTransform||this.textureTransform,"must provide source/feedback buffers or source/target textures")}_updateDrawOptions(e){let t=Object.assign({},e);const n=[this.bufferTransform,this.textureTransform].filter(Boolean);for(const i of n)t=Object.assign(t,i.getDrawOptions(t));return t}}function G(e){return!((0,F.nK)(e.feedbackBuffers)&&(0,F.nK)(e.feedbackMap)&&!(e.varyings&&e.varyings.length>0))}function U(e){return!((0,F.nK)(e._sourceTextures)&&!e._targetTexture&&!e._targetTextureVarying)}},77910:function(e,t,n){n.d(t,{Z:function(){return k}});var i=n(85451),r=n(1418),s=n(53478),o=n(14072),a=n(43855),c=n(44522);class l extends c.Z{constructor(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};e=Array.isArray(e)?{children:e}:e;const{children:t=[]}=e;r.cM.assert(t.every((e=>e instanceof c.Z)),"every child must an instance of ScenegraphNode"),super(e),this.children=t}add(){for(var e=arguments.length,t=new Array(e),n=0;n<e;n++)t[n]=arguments[n];for(const i of t)Array.isArray(i)?this.add(...i):this.children.push(i);return this}remove(e){const t=this.children,n=t.indexOf(e);return n>-1&&t.splice(n,1),this}removeAll(){return this.children=[],this}delete(){this.children.forEach((e=>e.delete())),this.removeAll(),super.delete()}getBounds(){const e=[[1/0,1/0,1/0],[-1/0,-1/0,-1/0]];return this.traverse(((t,n)=>{let{worldMatrix:i}=n;const r=t.getBounds();if(!r)return;const[s,o]=r,c=new a.Z(s).add(o).divide([2,2,2]);i.transformAsPoint(c,c);const l=new a.Z(o).subtract(s).divide([2,2,2]);i.transformAsVector(l,l);for(let u=0;u<8;u++){const t=new a.Z(1&u?-1:1,2&u?-1:1,4&u?-1:1).multiply(l).add(c);for(let n=0;n<3;n++)e[0][n]=Math.min(e[0][n],t[n]),e[1][n]=Math.max(e[1][n],t[n])}})),Number.isFinite(e[0][0])?e:null}traverse(e){let{worldMatrix:t=new i.Z}=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};const n=new i.Z(t).multiplyRight(this.matrix);for(const i of this.children)i instanceof l?i.traverse(e,{worldMatrix:n}):e(i,{worldMatrix:n})}}var u=n(22525),f=n(43897);const h={SCALAR:1,VEC2:2,VEC3:3,VEC4:4,MAT2:4,MAT3:9,MAT4:16},d={5120:Int8Array,5121:Uint8Array,5122:Int16Array,5123:Uint16Array,5125:Uint32Array,5126:Float32Array};function g(e){if(!e._animation){const t=d[e.componentType],n=h[e.type],i=n*e.count,{buffer:r,byteOffset:s}=e.bufferView.data,o=new t(r,s+(e.byteOffset||0),i);if(1===n)e._animation=Array.from(o);else{const t=[];for(let e=0;e<o.length;e+=n)t.push(Array.from(o.slice(e,e+n)));e._animation=t}}return e._animation}const p=new i.Z;function m(e,t){if(t.matrix.identity(),e.translation&&t.matrix.translate(e.translation),e.rotation){const n=p.fromQuaternion(e.rotation);t.matrix.multiplyRight(n)}e.scale&&t.matrix.scale(e.scale)}const _=new f.Z;function b(e,t,n,i,r){if("rotation"===t){_.slerp({start:n,target:i,ratio:r});for(let n=0;n<_.length;n++)e[t][n]=_[n]}else for(let s=0;s<n.length;s++)e[t][s]=r*i[s]+(1-r)*n[s]}function v(e,t,n){let{p0:i,outTangent0:r,inTangent1:s,p1:o,tDiff:a,ratio:c}=n;for(let l=0;l<e[t].length;l++){const n=r[l]*a,u=s[l]*a;e[t][l]=(2*Math.pow(c,3)-3*Math.pow(c,2)+1)*i[l]+(Math.pow(c,3)-2*Math.pow(c,2)+c)*n+(-2*Math.pow(c,3)+3*Math.pow(c,2))*o[l]+(Math.pow(c,3)-Math.pow(c,2))*u}}function x(e,t,n){for(let i=0;i<n.length;i++)e[t][i]=n[i]}function A(e,t,n,i){let{input:s,interpolation:o,output:a}=t;const c=s[s.length-1],l=e%c,f=s.findIndex((e=>e>=l)),h=Math.max(0,f-1);if(!Array.isArray(n[i]))switch(i){case"translation":n[i]=[0,0,0];break;case"rotation":n[i]=[0,0,0,1];break;case"scale":n[i]=[1,1,1];break;default:r.cM.warn("Bad animation path ".concat(i))()}(0,u.h)(n[i].length===a[h].length);const d=s[h],g=s[f];switch(o){case"STEP":x(n,i,a[h]);break;case"LINEAR":if(g>d){const e=(l-d)/(g-d);b(n,i,a[h],a[f],e)}break;case"CUBICSPLINE":if(g>d){const e=(l-d)/(g-d),t=g-d,r=a[3*h+1],s=a[3*h+2],o=a[3*f+0],c=a[3*f+1];v(n,i,{p0:r,outTangent0:s,inTangent1:o,p1:c,tDiff:t,ratio:e})}break;default:r.cM.warn("Interpolation ".concat(o," not supported"))();break}}class T{constructor(e){this.startTime=0,this.playing=!0,this.speed=1,this.channels=[],Object.assign(this,e)}animate(e){if(!this.playing)return;const t=e/1e3,n=(t-this.startTime)*this.speed;this.channels.forEach((e=>{let{sampler:t,target:i,path:r}=e;A(n,t,i,r),m(i,i._node)}))}}class E{constructor(e){this.animations=e.animations.map(((t,n)=>{const i=t.name||"Animation-".concat(n),r=t.samplers.map((t=>{let{input:n,interpolation:i="LINEAR",output:r}=t;return{input:g(e.accessors[n]),interpolation:i,output:g(e.accessors[r])}})),s=t.channels.map((t=>{let{sampler:n,target:i}=t;return{sampler:r[n],target:e.nodes[i.node],path:i.path}}));return new T({name:i,channels:s})}))}animate(e){this.setTime(e)}setTime(e){this.animations.forEach((t=>t.animate(e)))}getAnimations(){return this.animations}}var y=n(49764),L=n(80210);class S extends c.Z{constructor(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};super(t),this.onBeforeRender=null,this.AfterRender=null,e instanceof L.Z?(this.model=e,this._setModelNodeProps(t)):this.model=new L.Z(e,t),this.bounds=null,this.managedResources=t.managedResources||[]}setProps(e){return super.setProps(e),this._setModelNodeProps(e),this}getBounds(){return this.bounds}delete(){this.model&&(this.model.delete(),this.model=null),this.managedResources.forEach((e=>e.delete())),this.managedResources=[]}draw(){return this.model.draw(...arguments)}setUniforms(){return this.model.setUniforms(...arguments),this}setAttributes(){return this.model.setAttributes(...arguments),this}updateModuleSettings(){return this.model.updateModuleSettings(...arguments),this}_setModelNodeProps(e){this.model.setProps(e)}}var C=n(44211),I=n(6948),R=n(51621);class w{constructor(e,t){let{attributes:n,material:i,pbrDebug:r,imageBasedLightingEnvironment:s,lights:o,useTangents:a}=t;this.gl=e,this.defines={MANUAL_SRGB:1,SRGB_FAST_APPROXIMATION:1},(0,C.U6)(e,I.h.GLSL_TEXTURE_LOD)&&(this.defines.USE_TEX_LOD=1),this.uniforms={u_Camera:[0,0,0],u_MetallicRoughnessValues:[1,1]},this.parameters={},this.generatedTextures=[],s&&(this.uniforms.u_DiffuseEnvSampler=s.getDiffuseEnvSampler(),this.uniforms.u_SpecularEnvSampler=s.getSpecularEnvSampler(),this.uniforms.u_brdfLUT=s.getBrdfTexture(),this.uniforms.u_ScaleIBLAmbient=[1,1]),r&&(this.uniforms.u_ScaleDiffBaseMR=[0,0,0,0],this.uniforms.u_ScaleFGDSpec=[0,0,0,0]),this.defineIfPresent(n.NORMAL,"HAS_NORMALS"),this.defineIfPresent(n.TANGENT&&a,"HAS_TANGENTS"),this.defineIfPresent(n.TEXCOORD_0,"HAS_UV"),this.defineIfPresent(s,"USE_IBL"),this.defineIfPresent(o,"USE_LIGHTS"),this.defineIfPresent(r,"PBR_DEBUG"),i&&this.parseMaterial(i)}defineIfPresent(e,t){e&&(this.defines[t]=1)}parseTexture(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:null;const i=e.texture&&e.texture.sampler&&e.texture.sampler.parameters||{},r=e.texture.source.image;let s,o={};r.compressed?(s=r,o={[this.gl.TEXTURE_MIN_FILTER]:r.data.length>1?this.gl.LINEAR_MIPMAP_NEAREST:this.gl.LINEAR}):s={data:r};const a=new R.Z(this.gl,{id:e.name||e.id,parameters:{...i,...o},pixelStore:{[this.gl.UNPACK_FLIP_Y_WEBGL]:!1},...s});this.uniforms[t]=a,this.defineIfPresent(n,n),this.generatedTextures.push(a)}parsePbrMetallicRoughness(e){e.baseColorTexture&&this.parseTexture(e.baseColorTexture,"u_BaseColorSampler","HAS_BASECOLORMAP"),this.uniforms.u_BaseColorFactor=e.baseColorFactor||[1,1,1,1],e.metallicRoughnessTexture&&this.parseTexture(e.metallicRoughnessTexture,"u_MetallicRoughnessSampler","HAS_METALROUGHNESSMAP");const{metallicFactor:t=1,roughnessFactor:n=1}=e;this.uniforms.u_MetallicRoughnessValues=[t,n]}parseMaterial(e){if(this.uniforms.pbr_uUnlit=Boolean(e.unlit),e.pbrMetallicRoughness&&this.parsePbrMetallicRoughness(e.pbrMetallicRoughness),e.normalTexture){this.parseTexture(e.normalTexture,"u_NormalSampler","HAS_NORMALMAP");const{scale:t=1}=e.normalTexture;this.uniforms.u_NormalScale=t}if(e.occlusionTexture){this.parseTexture(e.occlusionTexture,"u_OcclusionSampler","HAS_OCCLUSIONMAP");const{strength:t=1}=e.occlusionTexture;this.uniforms.u_OcclusionStrength=t}if(e.emissiveTexture&&(this.parseTexture(e.emissiveTexture,"u_EmissiveSampler","HAS_EMISSIVEMAP"),this.uniforms.u_EmissiveFactor=e.emissiveFactor||[0,0,0]),"MASK"===e.alphaMode){const{alphaCutoff:t=.5}=e;this.defines.ALPHA_CUTOFF=1,this.uniforms.u_AlphaCutoff=t}else"BLEND"===e.alphaMode&&(r.cM.warn("BLEND alphaMode might not work well because it requires mesh sorting")(),Object.assign(this.parameters,{blend:!0,blendEquation:this.gl.FUNC_ADD,blendFunc:[this.gl.SRC_ALPHA,this.gl.ONE_MINUS_SRC_ALPHA,this.gl.ONE,this.gl.ONE_MINUS_SRC_ALPHA]}))}delete(){this.generatedTextures.forEach((e=>e.delete()))}}const O="\n#if (__VERSION__ < 300)\n  #define _attr attribute\n#else\n  #define _attr in\n#endif\n\n  _attr vec4 POSITION;\n\n  #ifdef HAS_NORMALS\n    _attr vec4 NORMAL;\n  #endif\n\n  #ifdef HAS_TANGENTS\n    _attr vec4 TANGENT;\n  #endif\n\n  #ifdef HAS_UV\n    _attr vec2 TEXCOORD_0;\n  #endif\n\n  void main(void) {\n    vec4 _NORMAL = vec4(0.);\n    vec4 _TANGENT = vec4(0.);\n    vec2 _TEXCOORD_0 = vec2(0.);\n\n    #ifdef HAS_NORMALS\n      _NORMAL = NORMAL;\n    #endif\n\n    #ifdef HAS_TANGENTS\n      _TANGENT = TANGENT;\n    #endif\n\n    #ifdef HAS_UV\n      _TEXCOORD_0 = TEXCOORD_0;\n    #endif\n\n    pbr_setPositionNormalTangentUV(POSITION, _NORMAL, _TANGENT, _TEXCOORD_0);\n    gl_Position = u_MVPMatrix * POSITION;\n  }\n",M="\n#if (__VERSION__ < 300)\n  #define fragmentColor gl_FragColor\n#else\n  out vec4 fragmentColor;\n#endif\n\n  void main(void) {\n    fragmentColor = pbr_filterColor(vec4(0));\n  }\n";function P(e,t){return(0,r.D0)(e)?"#version 300 es\n".concat(t):t}function N(e,t){const{id:n,drawMode:i,vertexCount:s,attributes:o,modelOptions:a}=t,c=new w(e,t);r.cM.info(4,"createGLTFModel defines: ",c.defines)();const l=[];l.push(...c.generatedTextures),l.push(...Object.values(o).map((e=>e.buffer)));const u=new S(e,Object.assign({id:n,drawMode:i,vertexCount:s,modules:[y.b],defines:c.defines,parameters:c.parameters,vs:P(e,O),fs:P(e,M),managedResources:l},a));return u.setProps({attributes:o}),u.setUniforms(c.uniforms),u}const B={SCALAR:1,VEC2:2,VEC3:3,VEC4:4,MAT2:4,MAT3:9,MAT4:16},D={modelOptions:{},pbrDebug:!1,imageBasedLightingEnvironment:null,lights:!0,useTangents:!1};class F{constructor(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};this.gl=e,this.options=Object.assign({},D,t)}instantiate(e){this.gltf=e;const t=(e.scenes||[]).map((e=>this.createScene(e)));return t}createAnimator(){return Array.isArray(this.gltf.animations)?new E(this.gltf):null}createScene(e){const t=e.nodes||[],n=t.map((e=>this.createNode(e))),i=new l({id:e.name||e.id,children:n});return i}createNode(e){if(!e._node){const t=e.children||[],n=t.map((e=>this.createNode(e)));e.mesh&&n.push(this.createMesh(e.mesh));const r=new l({id:e.name||e.id,children:n});if(e.matrix)r.setMatrix(e.matrix);else{if(r.matrix.identity(),e.translation&&r.matrix.translate(e.translation),e.rotation){const t=(new i.Z).fromQuaternion(e.rotation);r.matrix.multiplyRight(t)}e.scale&&r.matrix.scale(e.scale)}e._node=r}return e._node}createMesh(e){if(!e._mesh){const t=e.primitives||[],n=t.map(((t,n)=>this.createPrimitive(t,n,e))),i=new l({id:e.name||e.id,children:n});e._mesh=i}return e._mesh}getVertexCount(e){r.cM.warn("getVertexCount() not found")()}createPrimitive(e,t,n){const i=N(this.gl,Object.assign({id:e.name||"".concat(n.name||n.id,"-primitive-").concat(t),drawMode:e.mode||4,vertexCount:e.indices?e.indices.count:this.getVertexCount(e.attributes),attributes:this.createAttributes(e.attributes,e.indices),material:e.material},this.options));return i.bounds=[e.attributes.POSITION.min,e.attributes.POSITION.max],i}createAttributes(e,t){const n={};return Object.keys(e).forEach((t=>{n[t]=this.createAccessor(e[t],this.createBuffer(e[t],this.gl.ARRAY_BUFFER))})),t&&(n.indices=this.createAccessor(t,this.createBuffer(t,this.gl.ELEMENT_ARRAY_BUFFER))),r.cM.info(4,"glTF Attributes",{attributes:e,indices:t,generated:n})(),n}createBuffer(e,t){e.bufferView||(e.bufferView={});const{bufferView:n}=e;return n.lumaBuffers||(n.lumaBuffers={}),n.lumaBuffers[t]||(n.lumaBuffers[t]=new s.Z(this.gl,{id:"from-".concat(n.id),data:n.data||e.value,target:t})),n.lumaBuffers[t]}createAccessor(e,t){return new o.Z({buffer:t,offset:e.byteOffset||0,stride:e.bufferView.byteStride||0,type:e.componentType,size:B[e.type]})}createSampler(e){return e}needsPOT(){return!1}}function k(e,t,n){const i=new F(e,n),r=i.instantiate(t),s=i.createAnimator();return{scenes:r,animator:s}}},44522:function(e,t,n){n.d(t,{Z:function(){return a}});var i=n(43855),r=n(85451),s=n(74538),o=n(22525);class a{constructor(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};const{id:t}=e;this.id=t||(0,s.hQ)(this.constructor.name),this.display=!0,this.position=new i.Z,this.rotation=new i.Z,this.scale=new i.Z(1,1,1),this.matrix=new r.Z,this.userData={},this.props={},this._setScenegraphNodeProps(e)}delete(){}setProps(e){return this._setScenegraphNodeProps(e),this}toString(){return"{type: ScenegraphNode, id: ".concat(this.id,")}")}getBounds(){return null}setPosition(e){return(0,o.h)(3===e.length,"setPosition requires vector argument"),this.position=e,this}setRotation(e){return(0,o.h)(3===e.length,"setRotation requires vector argument"),this.rotation=e,this}setScale(e){return(0,o.h)(3===e.length,"setScale requires vector argument"),this.scale=e,this}setMatrix(e){let t=!(arguments.length>1&&void 0!==arguments[1])||arguments[1];t?this.matrix.copy(e):this.matrix=e}setMatrixComponents(e){let{position:t,rotation:n,scale:i,update:r=!0}=e;return t&&this.setPosition(t),n&&this.setRotation(n),i&&this.setScale(i),r&&this.updateMatrix(),this}updateMatrix(){const e=this.position,t=this.rotation,n=this.scale;return this.matrix.identity(),this.matrix.translate(e),this.matrix.rotateXYZ(t),this.matrix.scale(n),this}update(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};const{position:t,rotation:n,scale:i}=e;return t&&this.setPosition(t),n&&this.setRotation(n),i&&this.setScale(i),this.updateMatrix(),this}getCoordinateUniforms(e,t){(0,o.h)(e),t=t||this.matrix;const n=new r.Z(e).multiplyRight(t),i=n.invert(),s=i.transpose();return{viewMatrix:e,modelMatrix:t,objectMatrix:t,worldMatrix:n,worldInverseMatrix:i,worldInverseTransposeMatrix:s}}_setScenegraphNodeProps(e){"display"in e&&(this.display=e.display),"position"in e&&this.setPosition(e.position),"rotation"in e&&this.setRotation(e.rotation),"scale"in e&&this.setScale(e.scale),"matrix"in e&&this.setMatrix(e.matrix),Object.assign(this.props,e)}}},1418:function(e,t,n){n.d(t,{KQ:function(){return h},JD:function(){return f},s9:function(){return Me},JY:function(){return ye},w:function(){return Ee},vd:function(){return u},yW:function(){return Pe},UF:function(){return c},D0:function(){return l},cM:function(){return r},kL:function(){return xe},aQ:function(){return Be},dR:function(){return be},s8:function(){return Ae}});var i=n(56426);const r=new i.Z({id:"luma.gl"});function s(e,t){if(!e)throw new Error(t||"luma.gl: assertion failed.")}const o="Invalid WebGLRenderingContext",a="Requires WebGL2";function c(e){return"undefined"!==typeof WebGLRenderingContext&&e instanceof WebGLRenderingContext||("undefined"!==typeof WebGL2RenderingContext&&e instanceof WebGL2RenderingContext||Boolean(e&&Number.isFinite(e._version)))}function l(e){return"undefined"!==typeof WebGL2RenderingContext&&e instanceof WebGL2RenderingContext||Boolean(e&&2===e._version)}function u(e){return l(e)?e:null}function f(e){return s(c(e),o),e}function h(e){return s(l(e),a),e}const d={};function g(e){globalThis.console&&globalThis.console.error&&globalThis.console.error(e)}function p(e){globalThis.console&&globalThis.console.log&&globalThis.console.log(e)}function m(e,t){d[e]=!0,void 0!==t&&g(t)}function _(e){const t=e.getError;e.getError=function(){let n;do{n=t.apply(e),0!==n&&(d[n]=!0)}while(0!==n);for(n in d)if(d[n])return delete d[n],parseInt(n,10);return 0}}const b=function e(t){const n=t.gl;this.ext=t,this.isAlive=!0,this.hasBeenBound=!1,this.elementArrayBuffer=null,this.attribs=new Array(t.maxVertexAttribs);for(let i=0;i<this.attribs.length;i++){const t=new e.VertexAttrib(n);this.attribs[i]=t}this.maxAttrib=0};b.VertexAttrib=function(e){this.enabled=!1,this.buffer=null,this.size=4,this.type=5126,this.normalized=!1,this.stride=16,this.offset=0,this.cached="",this.recache()},b.VertexAttrib.prototype.recache=function(){this.cached=[this.size,this.type,this.normalized,this.stride,this.offset].join(":")};const v=function(e){const t=this;this.gl=e,_(e);const n=this.original={getParameter:e.getParameter,enableVertexAttribArray:e.enableVertexAttribArray,disableVertexAttribArray:e.disableVertexAttribArray,bindBuffer:e.bindBuffer,getVertexAttrib:e.getVertexAttrib,vertexAttribPointer:e.vertexAttribPointer};e.getParameter=function(e){return e===t.VERTEX_ARRAY_BINDING_OES?t.currentVertexArrayObject===t.defaultVertexArrayObject?null:t.currentVertexArrayObject:n.getParameter.apply(this,arguments)},e.enableVertexAttribArray=function(e){const i=t.currentVertexArrayObject;i.maxAttrib=Math.max(i.maxAttrib,e);const r=i.attribs[e];return r.enabled=!0,n.enableVertexAttribArray.apply(this,arguments)},e.disableVertexAttribArray=function(e){const i=t.currentVertexArrayObject;i.maxAttrib=Math.max(i.maxAttrib,e);const r=i.attribs[e];return r.enabled=!1,n.disableVertexAttribArray.apply(this,arguments)},e.bindBuffer=function(e,i){switch(e){case 34962:t.currentArrayBuffer=i;break;case 34963:t.currentVertexArrayObject.elementArrayBuffer=i;break;default:}return n.bindBuffer.apply(this,arguments)},e.getVertexAttrib=function(e,i){const r=t.currentVertexArrayObject,s=r.attribs[e];switch(i){case 34975:return s.buffer;case 34338:return s.enabled;case 34339:return s.size;case 34340:return s.stride;case 34341:return s.type;case 34922:return s.normalized;default:return n.getVertexAttrib.apply(this,arguments)}},e.vertexAttribPointer=function(e,i,r,s,o,a){const c=t.currentVertexArrayObject;c.maxAttrib=Math.max(c.maxAttrib,e);const l=c.attribs[e];return l.buffer=t.currentArrayBuffer,l.size=i,l.type=r,l.normalized=s,l.stride=o,l.offset=a,l.recache(),n.vertexAttribPointer.apply(this,arguments)},e.instrumentExtension&&e.instrumentExtension(this,"OES_vertex_array_object"),e.canvas&&e.canvas.addEventListener("webglcontextrestored",(()=>{p("OESVertexArrayObject emulation library context restored"),t.reset_()}),!0),this.reset_()};function x(e){if("function"===typeof e.createVertexArray)return;const t=e.getSupportedExtensions;e.getSupportedExtensions=function(){const e=t.call(this)||[];return e.indexOf("OES_vertex_array_object")<0&&e.push("OES_vertex_array_object"),e};const n=e.getExtension;e.getExtension=function(t){const i=n.call(this,t);return i||("OES_vertex_array_object"!==t?null:(e.__OESVertexArrayObject||(this.__OESVertexArrayObject=new v(this)),this.__OESVertexArrayObject))}}v.prototype.VERTEX_ARRAY_BINDING_OES=34229,v.prototype.reset_=function(){const e=void 0!==this.vertexArrayObjects;if(e)for(let n=0;n<this.vertexArrayObjects.length;++n)this.vertexArrayObjects.isAlive=!1;const t=this.gl;this.maxVertexAttribs=t.getParameter(34921),this.defaultVertexArrayObject=new b(this),this.currentVertexArrayObject=null,this.currentArrayBuffer=null,this.vertexArrayObjects=[this.defaultVertexArrayObject],this.bindVertexArrayOES(null)},v.prototype.createVertexArrayOES=function(){const e=new b(this);return this.vertexArrayObjects.push(e),e},v.prototype.deleteVertexArrayOES=function(e){e.isAlive=!1,this.vertexArrayObjects.splice(this.vertexArrayObjects.indexOf(e),1),this.currentVertexArrayObject===e&&this.bindVertexArrayOES(null)},v.prototype.isVertexArrayOES=function(e){return!!(e&&e instanceof b&&e.hasBeenBound&&e.ext===this)},v.prototype.bindVertexArrayOES=function(e){const t=this.gl;if(e&&!e.isAlive)return void m(1282,"bindVertexArrayOES: attempt to bind deleted arrayObject");const n=this.original,i=this.currentVertexArrayObject;this.currentVertexArrayObject=e||this.defaultVertexArrayObject,this.currentVertexArrayObject.hasBeenBound=!0;const r=this.currentVertexArrayObject;if(i===r)return;i&&r.elementArrayBuffer===i.elementArrayBuffer||n.bindBuffer.call(t,34963,r.elementArrayBuffer);let s=this.currentArrayBuffer;const o=Math.max(i?i.maxAttrib:0,r.maxAttrib);for(let a=0;a<=o;a++){const e=r.attribs[a],o=i?i.attribs[a]:null;if(i&&e.enabled===o.enabled||(e.enabled?n.enableVertexAttribArray.call(t,a):n.disableVertexAttribArray.call(t,a)),e.enabled){let r=!1;i&&e.buffer===o.buffer||(s!==e.buffer&&(n.bindBuffer.call(t,34962,e.buffer),s=e.buffer),r=!0),(r||e.cached!==o.cached)&&n.vertexAttribPointer.call(t,a,e.size,e.type,e.normalized,e.stride,e.offset)}}this.currentArrayBuffer!==s&&n.bindBuffer.call(t,34962,this.currentArrayBuffer)};const A="OES_element_index",T="WEBGL_draw_buffers",E="EXT_disjoint_timer_query",y="EXT_disjoint_timer_query_webgl2",L="EXT_texture_filter_anisotropic",S="WEBGL_debug_renderer_info",C=35723,I=4352,R=36795,w=34047,O=37445,M=37446,P=e=>l(e)?void 0:0,N={[3074]:e=>l(e)?void 0:36064,[C]:e=>l(e)?void 0:I,[35977]:P,[32937]:P,[R]:(e,t)=>{const n=l(e)?e.getExtension(y):e.getExtension(E);return n&&n.GPU_DISJOINT_EXT?t(n.GPU_DISJOINT_EXT):0},[O]:(e,t)=>{const n=e.getExtension(S);return t(n&&n.UNMASKED_VENDOR_WEBGL||7936)},[M]:(e,t)=>{const n=e.getExtension(S);return t(n&&n.UNMASKED_RENDERER_WEBGL||7937)},[w]:(e,t)=>{const n=e.luma.extensions[L];return n?t(n.MAX_TEXTURE_MAX_ANISOTROPY_EXT):1},[32883]:P,[35071]:P,[37447]:P,[36063]:(e,t)=>{if(!l(e)){const n=e.getExtension(T);return n?t(n.MAX_COLOR_ATTACHMENTS_WEBGL):0}},[35379]:P,[35374]:P,[35377]:P,[34852]:e=>{if(!l(e)){const t=e.getExtension(T);return t?t.MAX_DRAW_BUFFERS_WEBGL:0}},[36203]:e=>e.getExtension(A)?2147483647:65535,[33001]:e=>e.getExtension(A)?16777216:65535,[33e3]:e=>16777216,[37157]:P,[35373]:P,[35657]:P,[36183]:P,[37137]:P,[34045]:P,[35978]:P,[35979]:P,[35968]:P,[35376]:P,[35375]:P,[35659]:P,[37154]:P,[35371]:P,[35658]:P,[35076]:P,[35077]:P,[35380]:P};function B(e,t,n){const i=N[n],r="function"===typeof i?i(e,t,n):i,s=void 0!==r?r:t(n);return s}const D="OES_vertex_array_object",F="ANGLE_instanced_arrays",k="WEBGL_draw_buffers",V="EXT_disjoint_timer_query",G="EXT_texture_filter_anisotropic",U="VertexArray requires WebGL2 or OES_vertex_array_object extension";function j(e,t){return{webgl2:l(e),ext:e.getExtension(t)}}const H={[D]:{meta:{suffix:"OES"},createVertexArray:()=>{s(!1,U)},deleteVertexArray:()=>{},bindVertexArray:()=>{},isVertexArray:()=>!1},[F]:{meta:{suffix:"ANGLE"},vertexAttribDivisor(e,t){s(0===t,"WebGL instanced rendering not supported")},drawElementsInstanced:()=>{},drawArraysInstanced:()=>{}},[k]:{meta:{suffix:"WEBGL"},drawBuffers:()=>{s(!1)}},[V]:{meta:{suffix:"EXT"},createQuery:()=>{s(!1)},deleteQuery:()=>{s(!1)},beginQuery:()=>{s(!1)},endQuery:()=>{},getQuery(e,t){return this.getQueryObject(e,t)},getQueryParameter(e,t){return this.getQueryObject(e,t)},getQueryObject:()=>{}}},z={readBuffer:(e,t,n)=>{l(e)&&t(n)},getVertexAttrib:(e,t,n,i)=>{const{webgl2:r,ext:s}=j(e,F);let o;switch(i){case 35069:o=!!r&&void 0;break;case 35070:o=r||s?void 0:0;break;default:}return void 0!==o?o:t(n,i)},getProgramParameter:(e,t,n,i)=>{if(!l(e))switch(i){case 35967:return 35981;case 35971:return 0;case 35382:return 0;default:}return t(n,i)},getInternalformatParameter:(e,t,n,i,r)=>{if(!l(e))switch(r){case 32937:return new Int32Array([0]);default:}return e.getInternalformatParameter(n,i,r)},getTexParameter(e,t,n,i){switch(i){case 34046:const{extensions:t}=e.luma,n=t[G];i=n&&n.TEXTURE_MAX_ANISOTROPY_EXT||34046;break;default:}return t(n,i)},getParameter:B,hint(e,t,n,i){return t(n,i)}};function W(e){e.luma=e.luma||{};const{luma:t}=e;return t.polyfilled||(x(e),Z(e),q(e,H),X(e,{target:t,target2:e}),t.polyfilled=!0),e}function Z(e){e.luma.extensions={};const t=e.getSupportedExtensions()||[];for(const n of t)e.luma[n]=e.getExtension(n)}function X(e,t){let{target:n,target2:i}=t;Object.keys(z).forEach((t=>{if("function"===typeof z[t]){const r=e[t]?e[t].bind(e):()=>{},s=z[t].bind(null,e,r);n[t]=s,i[t]=s}}))}function q(e,t){for(const n of Object.getOwnPropertyNames(t))"overrides"!==n&&Q(e,{extension:n,target:e.luma,target2:e})}function Q(e,t){let{extension:n,target:i,target2:r}=t;const o=H[n];s(o);const{meta:a={}}=o,{suffix:c=""}=a,l=e.getExtension(n);for(const s of Object.keys(o)){const t="".concat(s).concat(c);let n=null;"meta"===s||"function"===typeof e[s]||(l&&"function"===typeof l[t]?n=function(){return l[t](...arguments)}:"function"===typeof o[s]&&(n=o[s].bind(i))),n&&(i[s]=n,r[s]=n)}}globalThis.polyfillContext=W;const K={[3042]:!1,[32773]:new Float32Array([0,0,0,0]),[32777]:32774,[34877]:32774,[32969]:1,[32968]:0,[32971]:1,[32970]:0,[3106]:new Float32Array([0,0,0,0]),[3107]:[!0,!0,!0,!0],[2884]:!1,[2885]:1029,[2929]:!1,[2931]:1,[2932]:513,[2928]:new Float32Array([0,1]),[2930]:!0,[3024]:!0,[36006]:null,[2886]:2305,[33170]:4352,[2849]:1,[32823]:!1,[32824]:0,[10752]:0,[32938]:1,[32939]:!1,[3089]:!1,[3088]:new Int32Array([0,0,1024,1024]),[2960]:!1,[2961]:0,[2968]:4294967295,[36005]:4294967295,[2962]:519,[2967]:0,[2963]:4294967295,[34816]:519,[36003]:0,[36004]:4294967295,[2964]:7680,[2965]:7680,[2966]:7680,[34817]:7680,[34818]:7680,[34819]:7680,[2978]:[0,0,1024,1024],[3333]:4,[3317]:4,[37440]:!1,[37441]:!1,[37443]:37444,[35723]:4352,[36010]:null,[35977]:!1,[3330]:0,[3332]:0,[3331]:0,[3314]:0,[32878]:0,[3316]:0,[3315]:0,[32877]:0},Y=(e,t,n)=>t?e.enable(n):e.disable(n),$=(e,t,n)=>e.hint(n,t),J=(e,t,n)=>e.pixelStorei(n,t),ee=(e,t)=>{const n=l(e)?36009:36160;return e.bindFramebuffer(n,t)},te=(e,t)=>e.bindFramebuffer(36008,t);function ne(e){return Array.isArray(e)||ArrayBuffer.isView(e)}const ie={[3042]:Y,[32773]:(e,t)=>e.blendColor(...t),[32777]:"blendEquation",[34877]:"blendEquation",[32969]:"blendFunc",[32968]:"blendFunc",[32971]:"blendFunc",[32970]:"blendFunc",[3106]:(e,t)=>e.clearColor(...t),[3107]:(e,t)=>e.colorMask(...t),[2884]:Y,[2885]:(e,t)=>e.cullFace(t),[2929]:Y,[2931]:(e,t)=>e.clearDepth(t),[2932]:(e,t)=>e.depthFunc(t),[2928]:(e,t)=>e.depthRange(...t),[2930]:(e,t)=>e.depthMask(t),[3024]:Y,[35723]:$,[36006]:ee,[2886]:(e,t)=>e.frontFace(t),[33170]:$,[2849]:(e,t)=>e.lineWidth(t),[32823]:Y,[32824]:"polygonOffset",[10752]:"polygonOffset",[35977]:Y,[32938]:"sampleCoverage",[32939]:"sampleCoverage",[3089]:Y,[3088]:(e,t)=>e.scissor(...t),[2960]:Y,[2961]:(e,t)=>e.clearStencil(t),[2968]:(e,t)=>e.stencilMaskSeparate(1028,t),[36005]:(e,t)=>e.stencilMaskSeparate(1029,t),[2962]:"stencilFuncFront",[2967]:"stencilFuncFront",[2963]:"stencilFuncFront",[34816]:"stencilFuncBack",[36003]:"stencilFuncBack",[36004]:"stencilFuncBack",[2964]:"stencilOpFront",[2965]:"stencilOpFront",[2966]:"stencilOpFront",[34817]:"stencilOpBack",[34818]:"stencilOpBack",[34819]:"stencilOpBack",[2978]:(e,t)=>e.viewport(...t),[3333]:J,[3317]:J,[37440]:J,[37441]:J,[37443]:J,[3330]:J,[3332]:J,[3331]:J,[36010]:te,[3314]:J,[32878]:J,[3316]:J,[3315]:J,[32877]:J,framebuffer:(e,t)=>{const n=t&&"handle"in t?t.handle:t;return e.bindFramebuffer(36160,n)},blend:(e,t)=>t?e.enable(3042):e.disable(3042),blendColor:(e,t)=>e.blendColor(...t),blendEquation:(e,t)=>{t=ne(t)?t:[t,t],e.blendEquationSeparate(...t)},blendFunc:(e,t)=>{t=ne(t)&&2===t.length?[...t,...t]:t,e.blendFuncSeparate(...t)},clearColor:(e,t)=>e.clearColor(...t),clearDepth:(e,t)=>e.clearDepth(t),clearStencil:(e,t)=>e.clearStencil(t),colorMask:(e,t)=>e.colorMask(...t),cull:(e,t)=>t?e.enable(2884):e.disable(2884),cullFace:(e,t)=>e.cullFace(t),depthTest:(e,t)=>t?e.enable(2929):e.disable(2929),depthFunc:(e,t)=>e.depthFunc(t),depthMask:(e,t)=>e.depthMask(t),depthRange:(e,t)=>e.depthRange(...t),dither:(e,t)=>t?e.enable(3024):e.disable(3024),derivativeHint:(e,t)=>{e.hint(35723,t)},frontFace:(e,t)=>e.frontFace(t),mipmapHint:(e,t)=>e.hint(33170,t),lineWidth:(e,t)=>e.lineWidth(t),polygonOffsetFill:(e,t)=>t?e.enable(32823):e.disable(32823),polygonOffset:(e,t)=>e.polygonOffset(...t),sampleCoverage:(e,t)=>e.sampleCoverage(...t),scissorTest:(e,t)=>t?e.enable(3089):e.disable(3089),scissor:(e,t)=>e.scissor(...t),stencilTest:(e,t)=>t?e.enable(2960):e.disable(2960),stencilMask:(e,t)=>{t=ne(t)?t:[t,t];const[n,i]=t;e.stencilMaskSeparate(1028,n),e.stencilMaskSeparate(1029,i)},stencilFunc:(e,t)=>{t=ne(t)&&3===t.length?[...t,...t]:t;const[n,i,r,s,o,a]=t;e.stencilFuncSeparate(1028,n,i,r),e.stencilFuncSeparate(1029,s,o,a)},stencilOp:(e,t)=>{t=ne(t)&&3===t.length?[...t,...t]:t;const[n,i,r,s,o,a]=t;e.stencilOpSeparate(1028,n,i,r),e.stencilOpSeparate(1029,s,o,a)},viewport:(e,t)=>e.viewport(...t)};function re(e,t,n){return void 0!==t[e]?t[e]:n[e]}const se={blendEquation:(e,t,n)=>e.blendEquationSeparate(re(32777,t,n),re(34877,t,n)),blendFunc:(e,t,n)=>e.blendFuncSeparate(re(32969,t,n),re(32968,t,n),re(32971,t,n),re(32970,t,n)),polygonOffset:(e,t,n)=>e.polygonOffset(re(32824,t,n),re(10752,t,n)),sampleCoverage:(e,t,n)=>e.sampleCoverage(re(32938,t,n),re(32939,t,n)),stencilFuncFront:(e,t,n)=>e.stencilFuncSeparate(1028,re(2962,t,n),re(2967,t,n),re(2963,t,n)),stencilFuncBack:(e,t,n)=>e.stencilFuncSeparate(1029,re(34816,t,n),re(36003,t,n),re(36004,t,n)),stencilOpFront:(e,t,n)=>e.stencilOpSeparate(1028,re(2964,t,n),re(2965,t,n),re(2966,t,n)),stencilOpBack:(e,t,n)=>e.stencilOpSeparate(1029,re(34817,t,n),re(34818,t,n),re(34819,t,n))},oe={enable:(e,t)=>e({[t]:!0}),disable:(e,t)=>e({[t]:!1}),pixelStorei:(e,t,n)=>e({[t]:n}),hint:(e,t,n)=>e({[t]:n}),bindFramebuffer:(e,t,n)=>{switch(t){case 36160:return e({[36006]:n,[36010]:n});case 36009:return e({[36006]:n});case 36008:return e({[36010]:n});default:return null}},blendColor:(e,t,n,i,r)=>e({[32773]:new Float32Array([t,n,i,r])}),blendEquation:(e,t)=>e({[32777]:t,[34877]:t}),blendEquationSeparate:(e,t,n)=>e({[32777]:t,[34877]:n}),blendFunc:(e,t,n)=>e({[32969]:t,[32968]:n,[32971]:t,[32970]:n}),blendFuncSeparate:(e,t,n,i,r)=>e({[32969]:t,[32968]:n,[32971]:i,[32970]:r}),clearColor:(e,t,n,i,r)=>e({[3106]:new Float32Array([t,n,i,r])}),clearDepth:(e,t)=>e({[2931]:t}),clearStencil:(e,t)=>e({[2961]:t}),colorMask:(e,t,n,i,r)=>e({[3107]:[t,n,i,r]}),cullFace:(e,t)=>e({[2885]:t}),depthFunc:(e,t)=>e({[2932]:t}),depthRange:(e,t,n)=>e({[2928]:new Float32Array([t,n])}),depthMask:(e,t)=>e({[2930]:t}),frontFace:(e,t)=>e({[2886]:t}),lineWidth:(e,t)=>e({[2849]:t}),polygonOffset:(e,t,n)=>e({[32824]:t,[10752]:n}),sampleCoverage:(e,t,n)=>e({[32938]:t,[32939]:n}),scissor:(e,t,n,i,r)=>e({[3088]:new Int32Array([t,n,i,r])}),stencilMask:(e,t)=>e({[2968]:t,[36005]:t}),stencilMaskSeparate:(e,t,n)=>e({[1028===t?2968:36005]:n}),stencilFunc:(e,t,n,i)=>e({[2962]:t,[2967]:n,[2963]:i,[34816]:t,[36003]:n,[36004]:i}),stencilFuncSeparate:(e,t,n,i,r)=>e({[1028===t?2962:34816]:n,[1028===t?2967:36003]:i,[1028===t?2963:36004]:r}),stencilOp:(e,t,n,i)=>e({[2964]:t,[2965]:n,[2966]:i,[34817]:t,[34818]:n,[34819]:i}),stencilOpSeparate:(e,t,n,i,r)=>e({[1028===t?2964:34817]:n,[1028===t?2965:34818]:i,[1028===t?2966:34819]:r}),viewport:(e,t,n,i,r)=>e({[2978]:[t,n,i,r]})},ae=(e,t)=>e.isEnabled(t),ce={[3042]:ae,[2884]:ae,[2929]:ae,[3024]:ae,[32823]:ae,[32926]:ae,[32928]:ae,[3089]:ae,[2960]:ae,[35977]:ae};function le(e){for(const t in e)return!1;return!0}function ue(e,t){if(e===t)return!0;const n=Array.isArray(e)||ArrayBuffer.isView(e),i=Array.isArray(t)||ArrayBuffer.isView(t);if(n&&i&&e.length===t.length){for(let n=0;n<e.length;++n)if(e[n]!==t[n])return!1;return!0}return!1}function fe(e,t){const n=e[t].bind(e);e[t]=function(){const t=arguments.length<=0?void 0:arguments[0];return t in e.state.cache&&e.state.enable?e.state.cache[t]:n(...arguments)},Object.defineProperty(e[t],"name",{value:"".concat(t,"-from-cache"),configurable:!1})}function he(e,t,n){const i=e[t].bind(e);e[t]=function(){for(var t=arguments.length,r=new Array(t),s=0;s<t;s++)r[s]=arguments[s];const{valueChanged:o,oldValue:a}=n(e.state._updateCache,...r);return o&&i(...r),a},Object.defineProperty(e[t],"name",{value:"".concat(t,"-to-cache"),configurable:!1})}function de(e){const t=e.useProgram.bind(e);e.useProgram=function(n){e.state.program!==n&&(t(n),e.state.program=n)}}class ge{constructor(e){let{copyState:t=!1,log:n=(()=>{})}=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};this.gl=e,this.program=null,this.stateStack=[],this.enable=!0,this.cache=t?ve(e):Object.assign({},K),this.log=n,this._updateCache=this._updateCache.bind(this),Object.seal(this)}push(){this.stateStack.push({})}pop(){s(this.stateStack.length>0);const e=this.stateStack[this.stateStack.length-1];be(this.gl,e),this.stateStack.pop()}_updateCache(e){let t,n=!1;const i=this.stateStack.length>0&&this.stateStack[this.stateStack.length-1];for(const r in e){s(void 0!==r);const o=e[r],a=this.cache[r];ue(o,a)||(n=!0,t=a,i&&!(r in i)&&(i[r]=a),this.cache[r]=o)}return{valueChanged:n,oldValue:t}}}function pe(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};const{enable:n=!0,copyState:i}=t;if(s(void 0!==i),!e.state){const{polyfillContext:t}=globalThis;t&&t(e),e.state=new ge(e,{copyState:i}),de(e);for(const n in oe){const t=oe[n];he(e,n,t)}fe(e,"getParameter"),fe(e,"isEnabled")}return e.state.enable=n,e}function me(e){e.state||pe(e,{copyState:!1}),e.state.push()}function _e(e){s(e.state),e.state.pop()}function be(e,t){if(s(c(e),"setParameters requires a WebGL context"),le(t))return;const n={};for(const r in t){const i=Number(r),s=ie[r];s&&("string"===typeof s?n[s]=!0:s(e,t[r],i))}const i=e.state&&e.state.cache;if(i)for(const r in n){const n=se[r];n(e,t,i)}}function ve(e,t){if(t=t||K,"number"===typeof t){const n=t,i=ce[n];return i?i(e,n):e.getParameter(n)}const n=Array.isArray(t)?t:Object.keys(t),i={};for(const r of n){const t=ce[r];i[r]=t?t(e,Number(r)):e.getParameter(Number(r))}return i}function xe(e){be(e,K)}function Ae(e,t,n){if(le(t))return n(e);const{nocatch:i=!0}=t;let r;if(me(e),be(e,t),i)r=n(e),_e(e);else try{r=n(e)}finally{_e(e)}return r}var Te=n(93370);function Ee(e){const{luma:t}=e;if(e.canvas&&t){const{clientWidth:n}=t.canvasSizeInfo;return n?e.drawingBufferWidth/n:1}return 1}function ye(e,t){let n=!(arguments.length>2&&void 0!==arguments[2])||arguments[2];const i=Ee(e),r=e.drawingBufferWidth,s=e.drawingBufferHeight;return Se(t,i,r,s,n)}function Le(e){const t="undefined"===typeof window?1:window.devicePixelRatio||1;return Number.isFinite(e)?e<=0?1:e:e?t:1}function Se(e,t,n,i,r){const s=Ce(e[0],t,n);let o=Ie(e[1],t,i,r),a=Ce(e[0]+1,t,n);const c=a===n-1?a:a-1;let l;return a=Ie(e[1]+1,t,i,r),r?(a=0===a?a:a+1,l=o,o=a):l=a===i-1?a:a-1,{x:s,y:o,width:Math.max(c-s+1,1),height:Math.max(l-o+1,1)}}function Ce(e,t,n){const i=Math.min(Math.round(e*t),n-1);return i}function Ie(e,t,n,i){return i?Math.max(0,n-1-Math.round(e*t)):Math.min(Math.round(e*t),n-1)}const Re=(0,Te.Z)(),we=Re&&"undefined"!==typeof document,Oe={webgl2:!0,webgl1:!0,throwOnError:!0,manageState:!0,canvas:null,debug:!1,width:800,height:600};function Me(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};s(Re,"createGLContext only available in the browser.\nCreate your own headless context or use 'createHeadlessContext' from @luma.gl/test-utils"),e=Object.assign({},Oe,e);const{width:t,height:n}=e;function i(t){if(e.throwOnError)throw new Error(t);return console.error(t),null}let r;e.onError=i;const{canvas:o}=e,a=Fe({canvas:o,width:t,height:n,onError:i});return r=De(a,e),r?(r=Pe(r,e),ke(r),r):null}function Pe(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};if(!e||e._instrumented)return e;e._version=e._version||Ve(e),e.luma=e.luma||{},e.luma.canvasSizeInfo=e.luma.canvasSizeInfo||{},t=Object.assign({},Oe,t);const{manageState:n,debug:i}=t;return n&&pe(e,{copyState:!1,log:function(){for(var e=arguments.length,t=new Array(e),n=0;n<e;n++)t[n]=arguments[n];return r.log(1,...t)()}}),Re&&i&&(globalThis.makeDebugContext?(e=globalThis.makeDebugContext(e,t),r.level=Math.max(r.level,1)):r.warn('WebGL debug mode not activated. import "@luma.gl/debug" to enable.')()),e._instrumented=!0,e}function Ne(e){const t=e.getParameter(7936),n=e.getParameter(7937),i=e.getExtension("WEBGL_debug_renderer_info"),r=i&&e.getParameter(i.UNMASKED_VENDOR_WEBGL||7936),s=i&&e.getParameter(i.UNMASKED_RENDERER_WEBGL||7937);return{vendor:r||t,renderer:s||n,vendorMasked:t,rendererMasked:n,version:e.getParameter(7938),shadingLanguageVersion:e.getParameter(35724)}}function Be(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};if(e.canvas){const n=Le(t.useDevicePixels);return void Ge(e,n,t)}const n=e.getExtension("STACKGL_resize_drawingbuffer");n&&"width"in t&&"height"in t&&n.resize(t.width,t.height)}function De(e,t){const{onError:n}=t;let i=null;const r=e=>i=e.statusMessage||i;e.addEventListener("webglcontextcreationerror",r,!1);const{webgl1:s=!0,webgl2:o=!0}=t;let a=null;return o&&(a=a||e.getContext("webgl2",t),a=a||e.getContext("experimental-webgl2",t)),s&&(a=a||e.getContext("webgl",t),a=a||e.getContext("experimental-webgl",t)),e.removeEventListener("webglcontextcreationerror",r,!1),a?(t.onContextLost&&e.addEventListener("webglcontextlost",t.onContextLost,!1),t.onContextRestored&&e.addEventListener("webglcontextrestored",t.onContextRestored,!1),a):n("Failed to create ".concat(o&&!s?"WebGL2":"WebGL"," context: ").concat(i||"Unknown error"))}function Fe(e){let t,{canvas:n,width:i=800,height:r=600,onError:s}=e;if("string"===typeof n){const e=we&&"complete"===document.readyState;e||s("createGLContext called on canvas '".concat(n,"' before page was loaded")),t=document.getElementById(n)}else n?t=n:(t=document.createElement("canvas"),t.id="lumagl-canvas",t.style.width=Number.isFinite(i)?"".concat(i,"px"):"100%",t.style.height=Number.isFinite(r)?"".concat(r,"px"):"100%",document.body.insertBefore(t,document.body.firstChild));return t}function ke(e){const t=l(e)?"WebGL2":"WebGL1",n=Ne(e),i=n?"(".concat(n.vendor,",").concat(n.renderer,")"):"",s=e.debug?" debug":"";r.info(1,"".concat(t).concat(s," context ").concat(i))()}function Ve(e){return"undefined"!==typeof WebGL2RenderingContext&&e instanceof WebGL2RenderingContext?2:1}function Ge(e,t,n){let i="width"in n?n.width:e.canvas.clientWidth,s="height"in n?n.height:e.canvas.clientHeight;i&&s||(r.log(1,"Canvas clientWidth/clientHeight is 0")(),t=1,i=e.canvas.width||1,s=e.canvas.height||1),e.luma=e.luma||{},e.luma.canvasSizeInfo=e.luma.canvasSizeInfo||{};const o=e.luma.canvasSizeInfo;if(o.clientWidth!==i||o.clientHeight!==s||o.devicePixelRatio!==t){let n=t;const o=Math.floor(i*n),a=Math.floor(s*n);e.canvas.width=o,e.canvas.height=a,e.drawingBufferWidth===o&&e.drawingBufferHeight===a||(r.warn("Device pixel ratio clamped")(),n=Math.min(e.drawingBufferWidth/i,e.drawingBufferHeight/s),e.canvas.width=Math.floor(i*n),e.canvas.height=Math.floor(s*n)),Object.assign(e.luma.canvasSizeInfo,{clientWidth:i,clientHeight:s,devicePixelRatio:t})}}},75682:function(e,t,n){n.d(t,{H:function(){return i},Y:function(){return r}});const i="vs",r="fs"},60827:function(e,t,n){n.d(t,{O_:function(){return c},Lm:function(){return d},ZP:function(){return h}});const i="#ifdef MODULE_LOGDEPTH\n  logdepth_adjustPosition(gl_Position);\n#endif\n",r="#ifdef MODULE_MATERIAL\n  gl_FragColor = material_filterColor(gl_FragColor);\n#endif\n\n#ifdef MODULE_LIGHTING\n  gl_FragColor = lighting_filterColor(gl_FragColor);\n#endif\n\n#ifdef MODULE_FOG\n  gl_FragColor = fog_filterColor(gl_FragColor);\n#endif\n\n#ifdef MODULE_PICKING\n  gl_FragColor = picking_filterHighlightColor(gl_FragColor);\n  gl_FragColor = picking_filterPickingColor(gl_FragColor);\n#endif\n\n#ifdef MODULE_LOGDEPTH\n  logdepth_setFragDepth();\n#endif\n";var s=n(75682),o=n(29047);const a={[s.H]:i,[s.Y]:r},c="__LUMA_INJECT_DECLARATIONS__",l=/void\s+main\s*\([^)]*\)\s*\{\n?/,u=/}\n?[^{}]*$/,f=[];function h(e,t,n){let i=arguments.length>3&&void 0!==arguments[3]&&arguments[3];const r=t===s.H;for(const s in n){const t=n[s];t.sort(((e,t)=>e.order-t.order)),f.length=t.length;for(let e=0,n=t.length;e<n;++e)f[e]=t[e].injection;const i="".concat(f.join("\n"),"\n");switch(s){case"vs:#decl":r&&(e=e.replace(c,i));break;case"vs:#main-start":r&&(e=e.replace(l,(e=>e+i)));break;case"vs:#main-end":r&&(e=e.replace(u,(e=>i+e)));break;case"fs:#decl":r||(e=e.replace(c,i));break;case"fs:#main-start":r||(e=e.replace(l,(e=>e+i)));break;case"fs:#main-end":r||(e=e.replace(u,(e=>i+e)));break;default:e=e.replace(s,(e=>e+i))}}return e=e.replace(c,""),i&&(e=e.replace(/\}\s*$/,(e=>e+a[t]))),e}function d(e){const t={};return(0,o.Z)(Array.isArray(e)&&e.length>1),e.forEach((e=>{for(const n in e)t[n]=t[n]?"".concat(t[n],"\n").concat(e[n]):e[n]})),t}},25502:function(e,t,n){n.d(t,{O:function(){return r}});const i="#ifdef LUMA_FP32_TAN_PRECISION_WORKAROUND\nconst float TWO_PI = 6.2831854820251465;\nconst float PI_2 = 1.5707963705062866;\nconst float PI_16 = 0.1963495463132858;\n\nconst float SIN_TABLE_0 = 0.19509032368659973;\nconst float SIN_TABLE_1 = 0.3826834261417389;\nconst float SIN_TABLE_2 = 0.5555702447891235;\nconst float SIN_TABLE_3 = 0.7071067690849304;\n\nconst float COS_TABLE_0 = 0.9807852506637573;\nconst float COS_TABLE_1 = 0.9238795042037964;\nconst float COS_TABLE_2 = 0.8314695954322815;\nconst float COS_TABLE_3 = 0.7071067690849304;\n\nconst float INVERSE_FACTORIAL_3 = 1.666666716337204e-01;\nconst float INVERSE_FACTORIAL_5 = 8.333333767950535e-03;\nconst float INVERSE_FACTORIAL_7 = 1.9841270113829523e-04;\nconst float INVERSE_FACTORIAL_9 = 2.75573188446287533e-06;\n\nfloat sin_taylor_fp32(float a) {\n  float r, s, t, x;\n\n  if (a == 0.0) {\n    return 0.0;\n  }\n\n  x = -a * a;\n  s = a;\n  r = a;\n\n  r = r * x;\n  t = r * INVERSE_FACTORIAL_3;\n  s = s + t;\n\n  r = r * x;\n  t = r * INVERSE_FACTORIAL_5;\n  s = s + t;\n\n  r = r * x;\n  t = r * INVERSE_FACTORIAL_7;\n  s = s + t;\n\n  r = r * x;\n  t = r * INVERSE_FACTORIAL_9;\n  s = s + t;\n\n  return s;\n}\n\nvoid sincos_taylor_fp32(float a, out float sin_t, out float cos_t) {\n  if (a == 0.0) {\n    sin_t = 0.0;\n    cos_t = 1.0;\n  }\n  sin_t = sin_taylor_fp32(a);\n  cos_t = sqrt(1.0 - sin_t * sin_t);\n}\n\nfloat tan_taylor_fp32(float a) {\n    float sin_a;\n    float cos_a;\n\n    if (a == 0.0) {\n        return 0.0;\n    }\n    float z = floor(a / TWO_PI);\n    float r = a - TWO_PI * z;\n\n    float t;\n    float q = floor(r / PI_2 + 0.5);\n    int j = int(q);\n\n    if (j < -2 || j > 2) {\n        return 1.0 / 0.0;\n    }\n\n    t = r - PI_2 * q;\n\n    q = floor(t / PI_16 + 0.5);\n    int k = int(q);\n    int abs_k = int(abs(float(k)));\n\n    if (abs_k > 4) {\n        return 1.0 / 0.0;\n    } else {\n        t = t - PI_16 * q;\n    }\n\n    float u = 0.0;\n    float v = 0.0;\n\n    float sin_t, cos_t;\n    float s, c;\n    sincos_taylor_fp32(t, sin_t, cos_t);\n\n    if (k == 0) {\n        s = sin_t;\n        c = cos_t;\n    } else {\n        if (abs(float(abs_k) - 1.0) < 0.5) {\n            u = COS_TABLE_0;\n            v = SIN_TABLE_0;\n        } else if (abs(float(abs_k) - 2.0) < 0.5) {\n            u = COS_TABLE_1;\n            v = SIN_TABLE_1;\n        } else if (abs(float(abs_k) - 3.0) < 0.5) {\n            u = COS_TABLE_2;\n            v = SIN_TABLE_2;\n        } else if (abs(float(abs_k) - 4.0) < 0.5) {\n            u = COS_TABLE_3;\n            v = SIN_TABLE_3;\n        }\n        if (k > 0) {\n            s = u * sin_t + v * cos_t;\n            c = u * cos_t - v * sin_t;\n        } else {\n            s = u * sin_t - v * cos_t;\n            c = u * cos_t + v * sin_t;\n        }\n    }\n\n    if (j == 0) {\n        sin_a = s;\n        cos_a = c;\n    } else if (j == 1) {\n        sin_a = c;\n        cos_a = -s;\n    } else if (j == -1) {\n        sin_a = -c;\n        cos_a = s;\n    } else {\n        sin_a = -s;\n        cos_a = -c;\n    }\n    return sin_a / cos_a;\n}\n#endif\n\nfloat tan_fp32(float a) {\n#ifdef LUMA_FP32_TAN_PRECISION_WORKAROUND\n  return tan_taylor_fp32(a);\n#else\n  return tan(a);\n#endif\n}\n",r={name:"fp32",vs:i,fs:null}},66931:function(e,t,n){n.d(t,{H:function(){return c}});var i="#if (defined(SHADER_TYPE_FRAGMENT) && defined(LIGHTING_FRAGMENT)) || (defined(SHADER_TYPE_VERTEX) && defined(LIGHTING_VERTEX))\n\nstruct AmbientLight {\n vec3 color;\n};\n\nstruct PointLight {\n vec3 color;\n vec3 position;\n vec3 attenuation;\n};\n\nstruct DirectionalLight {\n  vec3 color;\n  vec3 direction;\n};\n\nuniform AmbientLight lighting_uAmbientLight;\nuniform PointLight lighting_uPointLight[MAX_LIGHTS];\nuniform DirectionalLight lighting_uDirectionalLight[MAX_LIGHTS];\nuniform int lighting_uPointLightCount;\nuniform int lighting_uDirectionalLightCount;\n\nuniform bool lighting_uEnabled;\n\nfloat getPointLightAttenuation(PointLight pointLight, float distance) {\n  return pointLight.attenuation.x\n       + pointLight.attenuation.y * distance\n       + pointLight.attenuation.z * distance * distance;\n}\n\n#endif\n";const r={lightSources:{}};function s(){let{color:e=[0,0,0],intensity:t=1}=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};return e.map((e=>e*t/255))}function o(e){let{ambientLight:t,pointLights:n=[],directionalLights:i=[]}=e;const r={};return r["lighting_uAmbientLight.color"]=t?s(t):[0,0,0],n.forEach(((e,t)=>{r["lighting_uPointLight[".concat(t,"].color")]=s(e),r["lighting_uPointLight[".concat(t,"].position")]=e.position,r["lighting_uPointLight[".concat(t,"].attenuation")]=e.attenuation||[1,0,0]})),r.lighting_uPointLightCount=n.length,i.forEach(((e,t)=>{r["lighting_uDirectionalLight[".concat(t,"].color")]=s(e),r["lighting_uDirectionalLight[".concat(t,"].direction")]=e.direction})),r.lighting_uDirectionalLightCount=i.length,r}function a(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:r;if("lightSources"in e){const{ambientLight:t,pointLights:n,directionalLights:i}=e.lightSources||{},r=t||n&&n.length>0||i&&i.length>0;return r?Object.assign({},o({ambientLight:t,pointLights:n,directionalLights:i}),{lighting_uEnabled:!0}):{lighting_uEnabled:!1}}if("lights"in e){const t={pointLights:[],directionalLights:[]};for(const n of e.lights||[])switch(n.type){case"ambient":t.ambientLight=n;break;case"directional":t.directionalLights.push(n);break;case"point":t.pointLights.push(n);break;default:}return a({lightSources:t})}return{}}const c={name:"lights",vs:i,fs:i,getUniforms:a,defines:{MAX_LIGHTS:3}}},49764:function(e,t,n){n.d(t,{b:function(){return o}});var i=n(66931),r="uniform mat4 u_MVPMatrix;\nuniform mat4 u_ModelMatrix;\nuniform mat4 u_NormalMatrix;\n\nvarying vec3 pbr_vPosition;\nvarying vec2 pbr_vUV;\n\n#ifdef HAS_NORMALS\n# ifdef HAS_TANGENTS\nvarying mat3 pbr_vTBN;\n# else\nvarying vec3 pbr_vNormal;\n# endif\n#endif\n\nvoid pbr_setPositionNormalTangentUV(vec4 position, vec4 normal, vec4 tangent, vec2 uv)\n{\n  vec4 pos = u_ModelMatrix * position;\n  pbr_vPosition = vec3(pos.xyz) / pos.w;\n\n#ifdef HAS_NORMALS\n#ifdef HAS_TANGENTS\n  vec3 normalW = normalize(vec3(u_NormalMatrix * vec4(normal.xyz, 0.0)));\n  vec3 tangentW = normalize(vec3(u_ModelMatrix * vec4(tangent.xyz, 0.0)));\n  vec3 bitangentW = cross(normalW, tangentW) * tangent.w;\n  pbr_vTBN = mat3(tangentW, bitangentW, normalW);\n#else\n  pbr_vNormal = normalize(vec3(u_ModelMatrix * vec4(normal.xyz, 0.0)));\n#endif\n#endif\n\n#ifdef HAS_UV\n  pbr_vUV = uv;\n#else\n  pbr_vUV = vec2(0.,0.);\n#endif\n}\n",s="#if defined(USE_TEX_LOD) && !defined(FEATURE_GLSL_TEXTURE_LOD)\n# error PBR fragment shader: Texture LOD is not available\n#endif\n\n#if !defined(HAS_TANGENTS) && !defined(FEATURE_GLSL_DERIVATIVES)\n# error PBR fragment shader: Derivatives are not available\n#endif\n\n\n#if (__VERSION__ < 300)\n  #define SMART_FOR(INIT, WEBGL1COND, WEBGL2COND, INCR) for (INIT; WEBGL1COND; INCR)\n#else\n  #define SMART_FOR(INIT, WEBGL1COND, WEBGL2COND, INCR) for (INIT; WEBGL2COND; INCR)\n#endif\n\nprecision highp float;\n\nuniform bool pbr_uUnlit;\n\n#ifdef USE_IBL\nuniform samplerCube u_DiffuseEnvSampler;\nuniform samplerCube u_SpecularEnvSampler;\nuniform sampler2D u_brdfLUT;\nuniform vec2 u_ScaleIBLAmbient;\n#endif\n\n#ifdef HAS_BASECOLORMAP\nuniform sampler2D u_BaseColorSampler;\n#endif\n#ifdef HAS_NORMALMAP\nuniform sampler2D u_NormalSampler;\nuniform float u_NormalScale;\n#endif\n#ifdef HAS_EMISSIVEMAP\nuniform sampler2D u_EmissiveSampler;\nuniform vec3 u_EmissiveFactor;\n#endif\n#ifdef HAS_METALROUGHNESSMAP\nuniform sampler2D u_MetallicRoughnessSampler;\n#endif\n#ifdef HAS_OCCLUSIONMAP\nuniform sampler2D u_OcclusionSampler;\nuniform float u_OcclusionStrength;\n#endif\n\n#ifdef ALPHA_CUTOFF\nuniform float u_AlphaCutoff;\n#endif\n\nuniform vec2 u_MetallicRoughnessValues;\nuniform vec4 u_BaseColorFactor;\n\nuniform vec3 u_Camera;\n#ifdef PBR_DEBUG\nuniform vec4 u_ScaleDiffBaseMR;\nuniform vec4 u_ScaleFGDSpec;\n#endif\n\nvarying vec3 pbr_vPosition;\n\nvarying vec2 pbr_vUV;\n\n#ifdef HAS_NORMALS\n#ifdef HAS_TANGENTS\nvarying mat3 pbr_vTBN;\n#else\nvarying vec3 pbr_vNormal;\n#endif\n#endif\n\n\nstruct PBRInfo\n{\n  float NdotL;\n  float NdotV;\n  float NdotH;\n  float LdotH;\n  float VdotH;\n  float perceptualRoughness;\n  float metalness;\n  vec3 reflectance0;\n  vec3 reflectance90;\n  float alphaRoughness;\n  vec3 diffuseColor;\n  vec3 specularColor;\n  vec3 n;\n  vec3 v;\n};\n\nconst float M_PI = 3.141592653589793;\nconst float c_MinRoughness = 0.04;\n\nvec4 SRGBtoLINEAR(vec4 srgbIn)\n{\n#ifdef MANUAL_SRGB\n#ifdef SRGB_FAST_APPROXIMATION\n  vec3 linOut = pow(srgbIn.xyz,vec3(2.2));\n#else\n  vec3 bLess = step(vec3(0.04045),srgbIn.xyz);\n  vec3 linOut = mix( srgbIn.xyz/vec3(12.92), pow((srgbIn.xyz+vec3(0.055))/vec3(1.055),vec3(2.4)), bLess );\n#endif\n  return vec4(linOut,srgbIn.w);;\n#else\n  return srgbIn;\n#endif\n}\n\nvec3 getNormal()\n{\n#ifndef HAS_TANGENTS\n  vec3 pos_dx = dFdx(pbr_vPosition);\n  vec3 pos_dy = dFdy(pbr_vPosition);\n  vec3 tex_dx = dFdx(vec3(pbr_vUV, 0.0));\n  vec3 tex_dy = dFdy(vec3(pbr_vUV, 0.0));\n  vec3 t = (tex_dy.t * pos_dx - tex_dx.t * pos_dy) / (tex_dx.s * tex_dy.t - tex_dy.s * tex_dx.t);\n\n#ifdef HAS_NORMALS\n  vec3 ng = normalize(pbr_vNormal);\n#else\n  vec3 ng = cross(pos_dx, pos_dy);\n#endif\n\n  t = normalize(t - ng * dot(ng, t));\n  vec3 b = normalize(cross(ng, t));\n  mat3 tbn = mat3(t, b, ng);\n#else\n  mat3 tbn = pbr_vTBN;\n#endif\n\n#ifdef HAS_NORMALMAP\n  vec3 n = texture2D(u_NormalSampler, pbr_vUV).rgb;\n  n = normalize(tbn * ((2.0 * n - 1.0) * vec3(u_NormalScale, u_NormalScale, 1.0)));\n#else\n  vec3 n = normalize(tbn[2].xyz);\n#endif\n\n  return n;\n}\n\n\n#ifdef USE_IBL\nvec3 getIBLContribution(PBRInfo pbrInputs, vec3 n, vec3 reflection)\n{\n  float mipCount = 9.0;\n  float lod = (pbrInputs.perceptualRoughness * mipCount);\n  vec3 brdf = SRGBtoLINEAR(texture2D(u_brdfLUT,\n    vec2(pbrInputs.NdotV, 1.0 - pbrInputs.perceptualRoughness))).rgb;\n  vec3 diffuseLight = SRGBtoLINEAR(textureCube(u_DiffuseEnvSampler, n)).rgb;\n\n#ifdef USE_TEX_LOD\n  vec3 specularLight = SRGBtoLINEAR(textureCubeLod(u_SpecularEnvSampler, reflection, lod)).rgb;\n#else\n  vec3 specularLight = SRGBtoLINEAR(textureCube(u_SpecularEnvSampler, reflection)).rgb;\n#endif\n\n  vec3 diffuse = diffuseLight * pbrInputs.diffuseColor;\n  vec3 specular = specularLight * (pbrInputs.specularColor * brdf.x + brdf.y);\n  diffuse *= u_ScaleIBLAmbient.x;\n  specular *= u_ScaleIBLAmbient.y;\n\n  return diffuse + specular;\n}\n#endif\n\n\nvec3 diffuse(PBRInfo pbrInputs)\n{\n  return pbrInputs.diffuseColor / M_PI;\n}\n\nvec3 specularReflection(PBRInfo pbrInputs)\n{\n  return pbrInputs.reflectance0 +\n    (pbrInputs.reflectance90 - pbrInputs.reflectance0) *\n    pow(clamp(1.0 - pbrInputs.VdotH, 0.0, 1.0), 5.0);\n}\n\n\n\nfloat geometricOcclusion(PBRInfo pbrInputs)\n{\n  float NdotL = pbrInputs.NdotL;\n  float NdotV = pbrInputs.NdotV;\n  float r = pbrInputs.alphaRoughness;\n\n  float attenuationL = 2.0 * NdotL / (NdotL + sqrt(r * r + (1.0 - r * r) * (NdotL * NdotL)));\n  float attenuationV = 2.0 * NdotV / (NdotV + sqrt(r * r + (1.0 - r * r) * (NdotV * NdotV)));\n  return attenuationL * attenuationV;\n}\n\n\n\n\n\nfloat microfacetDistribution(PBRInfo pbrInputs)\n{\n  float roughnessSq = pbrInputs.alphaRoughness * pbrInputs.alphaRoughness;\n  float f = (pbrInputs.NdotH * roughnessSq - pbrInputs.NdotH) * pbrInputs.NdotH + 1.0;\n  return roughnessSq / (M_PI * f * f);\n}\n\nvoid PBRInfo_setAmbientLight(inout PBRInfo pbrInputs) {\n  pbrInputs.NdotL = 1.0;\n  pbrInputs.NdotH = 0.0;\n  pbrInputs.LdotH = 0.0;\n  pbrInputs.VdotH = 1.0;\n}\n\nvoid PBRInfo_setDirectionalLight(inout PBRInfo pbrInputs, vec3 lightDirection) {\n  vec3 n = pbrInputs.n;\n  vec3 v = pbrInputs.v;\n  vec3 l = normalize(lightDirection);\n  vec3 h = normalize(l+v);\n\n  pbrInputs.NdotL = clamp(dot(n, l), 0.001, 1.0);\n  pbrInputs.NdotH = clamp(dot(n, h), 0.0, 1.0);\n  pbrInputs.LdotH = clamp(dot(l, h), 0.0, 1.0);\n  pbrInputs.VdotH = clamp(dot(v, h), 0.0, 1.0);\n}\n\nvoid PBRInfo_setPointLight(inout PBRInfo pbrInputs, PointLight pointLight) {\n  vec3 light_direction = normalize(pointLight.position - pbr_vPosition);\n  PBRInfo_setDirectionalLight(pbrInputs, light_direction);\n}\n\nvec3 calculateFinalColor(PBRInfo pbrInputs, vec3 lightColor) {\n  vec3 F = specularReflection(pbrInputs);\n  float G = geometricOcclusion(pbrInputs);\n  float D = microfacetDistribution(pbrInputs);\n  vec3 diffuseContrib = (1.0 - F) * diffuse(pbrInputs);\n  vec3 specContrib = F * G * D / (4.0 * pbrInputs.NdotL * pbrInputs.NdotV);\n  return pbrInputs.NdotL * lightColor * (diffuseContrib + specContrib);\n}\n\nvec4 pbr_filterColor(vec4 colorUnused)\n{\n#ifdef HAS_BASECOLORMAP\n  vec4 baseColor = SRGBtoLINEAR(texture2D(u_BaseColorSampler, pbr_vUV)) * u_BaseColorFactor;\n#else\n  vec4 baseColor = u_BaseColorFactor;\n#endif\n\n#ifdef ALPHA_CUTOFF\n  if (baseColor.a < u_AlphaCutoff) {\n    discard;\n  }\n#endif\n\n  vec3 color = vec3(0, 0, 0);\n\n  if(pbr_uUnlit){\n    color.rgb = baseColor.rgb;\n  }\n  else{\n\n\n    float perceptualRoughness = u_MetallicRoughnessValues.y;\n    float metallic = u_MetallicRoughnessValues.x;\n#ifdef HAS_METALROUGHNESSMAP\n\n    vec4 mrSample = texture2D(u_MetallicRoughnessSampler, pbr_vUV);\n    perceptualRoughness = mrSample.g * perceptualRoughness;\n    metallic = mrSample.b * metallic;\n#endif\n    perceptualRoughness = clamp(perceptualRoughness, c_MinRoughness, 1.0);\n    metallic = clamp(metallic, 0.0, 1.0);\n\n    float alphaRoughness = perceptualRoughness * perceptualRoughness;\n\n    vec3 f0 = vec3(0.04);\n    vec3 diffuseColor = baseColor.rgb * (vec3(1.0) - f0);\n    diffuseColor *= 1.0 - metallic;\n    vec3 specularColor = mix(f0, baseColor.rgb, metallic);\n    float reflectance = max(max(specularColor.r, specularColor.g), specularColor.b);\n\n\n\n    float reflectance90 = clamp(reflectance * 25.0, 0.0, 1.0);\n    vec3 specularEnvironmentR0 = specularColor.rgb;\n    vec3 specularEnvironmentR90 = vec3(1.0, 1.0, 1.0) * reflectance90;\n\n    vec3 n = getNormal();\n    vec3 v = normalize(u_Camera - pbr_vPosition);\n\n    float NdotV = clamp(abs(dot(n, v)), 0.001, 1.0);\n    vec3 reflection = -normalize(reflect(v, n));\n\n    PBRInfo pbrInputs = PBRInfo(\n      0.0,\n      NdotV,\n      0.0,\n      0.0,\n      0.0,\n      perceptualRoughness,\n      metallic,\n      specularEnvironmentR0,\n      specularEnvironmentR90,\n      alphaRoughness,\n      diffuseColor,\n      specularColor,\n      n,\n      v\n    );\n\n#ifdef USE_LIGHTS\n    PBRInfo_setAmbientLight(pbrInputs);\n    color += calculateFinalColor(pbrInputs, lighting_uAmbientLight.color);\n    SMART_FOR(int i = 0, i < MAX_LIGHTS, i < lighting_uDirectionalLightCount, i++) {\n      if (i < lighting_uDirectionalLightCount) {\n        PBRInfo_setDirectionalLight(pbrInputs, lighting_uDirectionalLight[i].direction);\n        color += calculateFinalColor(pbrInputs, lighting_uDirectionalLight[i].color);\n      }\n    }\n    SMART_FOR(int i = 0, i < MAX_LIGHTS, i < lighting_uPointLightCount, i++) {\n      if (i < lighting_uPointLightCount) {\n        PBRInfo_setPointLight(pbrInputs, lighting_uPointLight[i]);\n        float attenuation = getPointLightAttenuation(lighting_uPointLight[i], distance(lighting_uPointLight[i].position, pbr_vPosition));\n        color += calculateFinalColor(pbrInputs, lighting_uPointLight[i].color / attenuation);\n      }\n    }\n#endif\n#ifdef USE_IBL\n    color += getIBLContribution(pbrInputs, n, reflection);\n#endif\n#ifdef HAS_OCCLUSIONMAP\n    float ao = texture2D(u_OcclusionSampler, pbr_vUV).r;\n    color = mix(color, color * ao, u_OcclusionStrength);\n#endif\n\n#ifdef HAS_EMISSIVEMAP\n    vec3 emissive = SRGBtoLINEAR(texture2D(u_EmissiveSampler, pbr_vUV)).rgb * u_EmissiveFactor;\n    color += emissive;\n#endif\n\n#ifdef PBR_DEBUG\n\n\n\n\n\n    color = mix(color, baseColor.rgb, u_ScaleDiffBaseMR.y);\n    color = mix(color, vec3(metallic), u_ScaleDiffBaseMR.z);\n    color = mix(color, vec3(perceptualRoughness), u_ScaleDiffBaseMR.w);\n#endif\n\n  }\n\n  return vec4(pow(color,vec3(1.0/2.2)), baseColor.a);\n}\n";const o={name:"pbr",vs:r,fs:s,defines:{LIGHTING_FRAGMENT:1},dependencies:[i.H]}},8674:function(e,t,n){n.d(t,{N:function(){return c}});var i=n(66931),r="\nuniform float lighting_uAmbient;\nuniform float lighting_uDiffuse;\nuniform float lighting_uShininess;\nuniform vec3  lighting_uSpecularColor;\n\nvec3 lighting_getLightColor(vec3 surfaceColor, vec3 light_direction, vec3 view_direction, vec3 normal_worldspace, vec3 color) {\n    vec3 halfway_direction = normalize(light_direction + view_direction);\n    float lambertian = dot(light_direction, normal_worldspace);\n    float specular = 0.0;\n    if (lambertian > 0.0) {\n      float specular_angle = max(dot(normal_worldspace, halfway_direction), 0.0);\n      specular = pow(specular_angle, lighting_uShininess);\n    }\n    lambertian = max(lambertian, 0.0);\n    return (lambertian * lighting_uDiffuse * surfaceColor + specular * lighting_uSpecularColor) * color;\n}\n\nvec3 lighting_getLightColor(vec3 surfaceColor, vec3 cameraPosition, vec3 position_worldspace, vec3 normal_worldspace) {\n  vec3 lightColor = surfaceColor;\n\n  if (lighting_uEnabled) {\n    vec3 view_direction = normalize(cameraPosition - position_worldspace);\n    lightColor = lighting_uAmbient * surfaceColor * lighting_uAmbientLight.color;\n\n    for (int i = 0; i < MAX_LIGHTS; i++) {\n      if (i >= lighting_uPointLightCount) {\n        break;\n      }\n      PointLight pointLight = lighting_uPointLight[i];\n      vec3 light_position_worldspace = pointLight.position;\n      vec3 light_direction = normalize(light_position_worldspace - position_worldspace);\n      lightColor += lighting_getLightColor(surfaceColor, light_direction, view_direction, normal_worldspace, pointLight.color);\n    }\n\n    for (int i = 0; i < MAX_LIGHTS; i++) {\n      if (i >= lighting_uDirectionalLightCount) {\n        break;\n      }\n      DirectionalLight directionalLight = lighting_uDirectionalLight[i];\n      lightColor += lighting_getLightColor(surfaceColor, -directionalLight.direction, view_direction, normal_worldspace, directionalLight.color);\n    }\n  }\n  return lightColor;\n}\n\nvec3 lighting_getSpecularLightColor(vec3 cameraPosition, vec3 position_worldspace, vec3 normal_worldspace) {\n  vec3 lightColor = vec3(0, 0, 0);\n  vec3 surfaceColor = vec3(0, 0, 0);\n\n  if (lighting_uEnabled) {\n    vec3 view_direction = normalize(cameraPosition - position_worldspace);\n\n    for (int i = 0; i < MAX_LIGHTS; i++) {\n      if (i >= lighting_uPointLightCount) {\n        break;\n      }\n      PointLight pointLight = lighting_uPointLight[i];\n      vec3 light_position_worldspace = pointLight.position;\n      vec3 light_direction = normalize(light_position_worldspace - position_worldspace);\n      lightColor += lighting_getLightColor(surfaceColor, light_direction, view_direction, normal_worldspace, pointLight.color);\n    }\n\n    for (int i = 0; i < MAX_LIGHTS; i++) {\n      if (i >= lighting_uDirectionalLightCount) {\n        break;\n      }\n      DirectionalLight directionalLight = lighting_uDirectionalLight[i];\n      lightColor += lighting_getLightColor(surfaceColor, -directionalLight.direction, view_direction, normal_worldspace, directionalLight.color);\n    }\n  }\n  return lightColor;\n}\n";const s={};function o(e){const{ambient:t=.35,diffuse:n=.6,shininess:i=32,specularColor:r=[30,30,30]}=e;return{lighting_uAmbient:t,lighting_uDiffuse:n,lighting_uShininess:i,lighting_uSpecularColor:r.map((e=>e/255))}}function a(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:s;if(!("material"in e))return{};const{material:t}=e;return t?o(t):{lighting_uEnabled:!1}}const c={name:"gouraud-lighting",dependencies:[i.H],vs:r,defines:{LIGHTING_VERTEX:1},getUniforms:a};i.H},83330:function(e,t,n){n.d(t,{q:function(){return c}});const i=new Uint8Array([0,255,255,255]),r={pickingSelectedColor:null,pickingHighlightColor:i,pickingActive:!1,pickingAttribute:!1};function s(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:r;const t={};if(void 0!==e.pickingSelectedColor)if(e.pickingSelectedColor){const n=e.pickingSelectedColor.slice(0,3);t.picking_uSelectedColorValid=1,t.picking_uSelectedColor=n}else t.picking_uSelectedColorValid=0;if(e.pickingHighlightColor){const n=Array.from(e.pickingHighlightColor,(e=>e/255));Number.isFinite(n[3])||(n[3]=1),t.picking_uHighlightColor=n}return void 0!==e.pickingActive&&(t.picking_uActive=Boolean(e.pickingActive),t.picking_uAttribute=Boolean(e.pickingAttribute)),t}const o="uniform bool picking_uActive;\nuniform bool picking_uAttribute;\nuniform vec3 picking_uSelectedColor;\nuniform bool picking_uSelectedColorValid;\n\nout vec4 picking_vRGBcolor_Avalid;\n\nconst float COLOR_SCALE = 1. / 255.;\n\nbool picking_isColorValid(vec3 color) {\n  return dot(color, vec3(1.0)) > 0.001;\n}\n\nbool isVertexPicked(vec3 vertexColor) {\n  return\n    picking_uSelectedColorValid &&\n    !picking_isColorValid(abs(vertexColor - picking_uSelectedColor));\n}\n\nvoid picking_setPickingColor(vec3 pickingColor) {\n  if (picking_uActive) {\n    picking_vRGBcolor_Avalid.a = float(picking_isColorValid(pickingColor));\n\n    if (!picking_uAttribute) {\n      picking_vRGBcolor_Avalid.rgb = pickingColor * COLOR_SCALE;\n    }\n  } else {\n    picking_vRGBcolor_Avalid.a = float(isVertexPicked(pickingColor));\n  }\n}\n\nvoid picking_setPickingAttribute(float value) {\n  if (picking_uAttribute) {\n    picking_vRGBcolor_Avalid.r = value;\n  }\n}\nvoid picking_setPickingAttribute(vec2 value) {\n  if (picking_uAttribute) {\n    picking_vRGBcolor_Avalid.rg = value;\n  }\n}\nvoid picking_setPickingAttribute(vec3 value) {\n  if (picking_uAttribute) {\n    picking_vRGBcolor_Avalid.rgb = value;\n  }\n}\n",a="uniform bool picking_uActive;\nuniform vec3 picking_uSelectedColor;\nuniform vec4 picking_uHighlightColor;\n\nin vec4 picking_vRGBcolor_Avalid;\nvec4 picking_filterHighlightColor(vec4 color) {\n  if (picking_uActive) {\n    return color;\n  }\n  bool selected = bool(picking_vRGBcolor_Avalid.a);\n\n  if (selected) {\n    float highLightAlpha = picking_uHighlightColor.a;\n    float blendedAlpha = highLightAlpha + color.a * (1.0 - highLightAlpha);\n    float highLightRatio = highLightAlpha / blendedAlpha;\n\n    vec3 blendedRGB = mix(color.rgb, picking_uHighlightColor.rgb, highLightRatio);\n    return vec4(blendedRGB, blendedAlpha);\n  } else {\n    return color;\n  }\n}\nvec4 picking_filterPickingColor(vec4 color) {\n  if (picking_uActive) {\n    if (picking_vRGBcolor_Avalid.a == 0.0) {\n      discard;\n    }\n    return picking_vRGBcolor_Avalid;\n  }\n  return color;\n}\nvec4 picking_filterColor(vec4 color) {\n  vec4 highightColor = picking_filterHighlightColor(color);\n  return picking_filterPickingColor(highightColor);\n}\n\n",c={name:"picking",vs:o,fs:a,getUniforms:s}},29047:function(e,t,n){function i(e,t){if(!e)throw new Error(t||"shadertools: assertion failed.")}n.d(t,{Z:function(){return i}})}}]);
//# sourceMappingURL=chunk-vendors-bc6c67ef-legacy.fdec1ea7.js.map