"use strict";(self["webpackChunkvue3_webpack5"]=self["webpackChunkvue3_webpack5"]||[]).push([[8689],{29826:function(e,t,i){i.d(t,{Z:function(){return Ct}});var n=i(82482),o=i(78918),s=i(61855),r=i(98452);function a(e,t){if(!e)return null;const i="startIndices"in e?e.startIndices[t]:t,n=e.featureIds.value[i];return-1!==i?l(e,n,i):null}function l(e,t,i){const n={properties:{...e.properties[t]}};for(const o in e.numericProps)n.properties[o]=e.numericProps[o].value[i];return n}function c(e,t){const i={points:null,lines:null,polygons:null};for(const n in i){const o=e[n].globalFeatureIds.value;i[n]=new Uint8ClampedArray(3*o.length);const s=[];for(let e=0;e<o.length;e++)t(o[e],s),i[n][3*e+0]=s[0],i[n][3*e+1]=s[1],i[n][3*e+2]=s[2]}return i}var d=i(13418),u=i(52447),h=i(93844),g=i(43844),p=i(24088),f=i(80210),m=i(53982),v="#define SHADER_NAME scatterplot-layer-vertex-shader\n\nattribute vec3 positions;\n\nattribute vec3 instancePositions;\nattribute vec3 instancePositions64Low;\nattribute float instanceRadius;\nattribute float instanceLineWidths;\nattribute vec4 instanceFillColors;\nattribute vec4 instanceLineColors;\nattribute vec3 instancePickingColors;\n\nuniform float opacity;\nuniform float radiusScale;\nuniform float radiusMinPixels;\nuniform float radiusMaxPixels;\nuniform float lineWidthScale;\nuniform float lineWidthMinPixels;\nuniform float lineWidthMaxPixels;\nuniform float stroked;\nuniform bool filled;\nuniform bool antialiasing;\nuniform bool billboard;\nuniform int radiusUnits;\nuniform int lineWidthUnits;\n\nvarying vec4 vFillColor;\nvarying vec4 vLineColor;\nvarying vec2 unitPosition;\nvarying float innerUnitRadius;\nvarying float outerRadiusPixels;\n\n\nvoid main(void) {\n  geometry.worldPosition = instancePositions;\n  outerRadiusPixels = clamp(\n    project_size_to_pixel(radiusScale * instanceRadius, radiusUnits),\n    radiusMinPixels, radiusMaxPixels\n  );\n  float lineWidthPixels = clamp(\n    project_size_to_pixel(lineWidthScale * instanceLineWidths, lineWidthUnits),\n    lineWidthMinPixels, lineWidthMaxPixels\n  );\n  outerRadiusPixels += stroked * lineWidthPixels / 2.0;\n  float edgePadding = antialiasing ? (outerRadiusPixels + SMOOTH_EDGE_RADIUS) / outerRadiusPixels : 1.0;\n  unitPosition = edgePadding * positions.xy;\n  geometry.uv = unitPosition;\n  geometry.pickingColor = instancePickingColors;\n\n  innerUnitRadius = 1.0 - stroked * lineWidthPixels / outerRadiusPixels;\n  \n  if (billboard) {\n    gl_Position = project_position_to_clipspace(instancePositions, instancePositions64Low, vec3(0.0), geometry.position);\n    DECKGL_FILTER_GL_POSITION(gl_Position, geometry);\n    vec3 offset = edgePadding * positions * outerRadiusPixels;\n    DECKGL_FILTER_SIZE(offset, geometry);\n    gl_Position.xy += project_pixel_size_to_clipspace(offset.xy);\n  } else {\n    vec3 offset = edgePadding * positions * project_pixel_size(outerRadiusPixels);\n    DECKGL_FILTER_SIZE(offset, geometry);\n    gl_Position = project_position_to_clipspace(instancePositions, instancePositions64Low, offset, geometry.position);\n    DECKGL_FILTER_GL_POSITION(gl_Position, geometry);\n  }\n  vFillColor = vec4(instanceFillColors.rgb, instanceFillColors.a * opacity);\n  DECKGL_FILTER_COLOR(vFillColor, geometry);\n  vLineColor = vec4(instanceLineColors.rgb, instanceLineColors.a * opacity);\n  DECKGL_FILTER_COLOR(vLineColor, geometry);\n}\n",y="#define SHADER_NAME scatterplot-layer-fragment-shader\n\nprecision highp float;\n\nuniform bool filled;\nuniform float stroked;\nuniform bool antialiasing;\n\nvarying vec4 vFillColor;\nvarying vec4 vLineColor;\nvarying vec2 unitPosition;\nvarying float innerUnitRadius;\nvarying float outerRadiusPixels;\n\nvoid main(void) {\n  geometry.uv = unitPosition;\n\n  float distToCenter = length(unitPosition) * outerRadiusPixels;\n  float inCircle = antialiasing ? \n    smoothedge(distToCenter, outerRadiusPixels) : \n    step(distToCenter, outerRadiusPixels);\n\n  if (inCircle == 0.0) {\n    discard;\n  }\n\n  if (stroked > 0.5) {\n    float isLine = antialiasing ? \n      smoothedge(innerUnitRadius * outerRadiusPixels, distToCenter) :\n      step(innerUnitRadius * outerRadiusPixels, distToCenter);\n\n    if (filled) {\n      gl_FragColor = mix(vFillColor, vLineColor, isLine);\n    } else {\n      if (isLine == 0.0) {\n        discard;\n      }\n      gl_FragColor = vec4(vLineColor.rgb, vLineColor.a * isLine);\n    }\n  } else if (filled) {\n    gl_FragColor = vFillColor;\n  } else {\n    discard;\n  }\n\n  gl_FragColor.a *= inCircle;\n  DECKGL_FILTER_COLOR(gl_FragColor, geometry);\n}\n";const x=[0,0,0,255],_={radiusUnits:"meters",radiusScale:{type:"number",min:0,value:1},radiusMinPixels:{type:"number",min:0,value:0},radiusMaxPixels:{type:"number",min:0,value:Number.MAX_SAFE_INTEGER},lineWidthUnits:"meters",lineWidthScale:{type:"number",min:0,value:1},lineWidthMinPixels:{type:"number",min:0,value:0},lineWidthMaxPixels:{type:"number",min:0,value:Number.MAX_SAFE_INTEGER},stroked:!1,filled:!0,billboard:!1,antialiasing:!0,getPosition:{type:"accessor",value:e=>e.position},getRadius:{type:"accessor",value:1},getFillColor:{type:"accessor",value:x},getLineColor:{type:"accessor",value:x},getLineWidth:{type:"accessor",value:1},strokeWidth:{deprecatedFor:"getLineWidth"},outline:{deprecatedFor:"stroked"},getColor:{deprecatedFor:["getFillColor","getLineColor"]}};class P extends u.Z{getShaders(){return super.getShaders({vs:v,fs:y,modules:[h.Z,g.Z]})}initializeState(){this.getAttributeManager().addInstanced({instancePositions:{size:3,type:5130,fp64:this.use64bitPositions(),transition:!0,accessor:"getPosition"},instanceRadius:{size:1,transition:!0,accessor:"getRadius",defaultValue:1},instanceFillColors:{size:this.props.colorFormat.length,transition:!0,normalized:!0,type:5121,accessor:"getFillColor",defaultValue:[0,0,0,255]},instanceLineColors:{size:this.props.colorFormat.length,transition:!0,normalized:!0,type:5121,accessor:"getLineColor",defaultValue:[0,0,0,255]},instanceLineWidths:{size:1,transition:!0,accessor:"getLineWidth",defaultValue:1}})}updateState(e){if(super.updateState(e),e.changeFlags.extensionsChanged){var t;const{gl:e}=this.context;null===(t=this.state.model)||void 0===t||t.delete(),this.state.model=this._getModel(e),this.getAttributeManager().invalidateAll()}}draw({uniforms:e}){const{radiusUnits:t,radiusScale:i,radiusMinPixels:n,radiusMaxPixels:o,stroked:s,filled:r,billboard:a,antialiasing:l,lineWidthUnits:c,lineWidthScale:d,lineWidthMinPixels:u,lineWidthMaxPixels:h}=this.props;this.state.model.setUniforms(e).setUniforms({stroked:s?1:0,filled:r,billboard:a,antialiasing:l,radiusUnits:p.iI[t],radiusScale:i,radiusMinPixels:n,radiusMaxPixels:o,lineWidthUnits:p.iI[c],lineWidthScale:d,lineWidthMinPixels:u,lineWidthMaxPixels:h}).draw()}_getModel(e){const t=[-1,-1,0,1,-1,0,1,1,0,-1,1,0];return new f.Z(e,{...this.getShaders(),id:this.props.id,geometry:new m.Z({drawMode:6,vertexCount:4,attributes:{positions:{size:3,value:new Float32Array(t)}}}),isInstanced:!0})}}(0,n.Z)(P,"defaultProps",_),(0,n.Z)(P,"layerName","ScatterplotLayer");var C=i(80744),b=i(38550),S="#define SHADER_NAME multi-icon-layer-fragment-shader\n\nprecision highp float;\n\nuniform float opacity;\nuniform sampler2D iconsTexture;\nuniform float gamma;\nuniform bool sdf;\nuniform float alphaCutoff;\nuniform float sdfBuffer;\nuniform float outlineBuffer;\nuniform vec4 outlineColor;\n\nvarying vec4 vColor;\nvarying vec2 vTextureCoords;\nvarying vec2 uv;\n\nvoid main(void) {\n  geometry.uv = uv;\n\n  if (!picking_uActive) {\n    float alpha = texture2D(iconsTexture, vTextureCoords).a;\n    vec4 color = vColor;\n    if (sdf) {\n      float distance = alpha;\n      alpha = smoothstep(sdfBuffer - gamma, sdfBuffer + gamma, distance);\n\n      if (outlineBuffer > 0.0) {\n        float inFill = alpha;\n        float inBorder = smoothstep(outlineBuffer - gamma, outlineBuffer + gamma, distance);\n        color = mix(outlineColor, vColor, inFill);\n        alpha = inBorder;\n      }\n    }\n    float a = alpha * color.a;\n    \n    if (a < alphaCutoff) {\n      discard;\n    }\n\n    gl_FragColor = vec4(color.rgb, a * opacity);\n  }\n\n  DECKGL_FILTER_COLOR(gl_FragColor, geometry);\n}\n";const L=.75,w=[],z={getIconOffsets:{type:"accessor",value:e=>e.offsets},alphaCutoff:.001,smoothing:.1,outlineWidth:0,outlineColor:{type:"color",value:[0,0,0,255]}};class T extends d.Z{constructor(...e){super(...e),(0,n.Z)(this,"state",void 0)}getShaders(){return{...super.getShaders(),fs:S}}initializeState(){super.initializeState();const e=this.getAttributeManager();e.addInstanced({instanceOffsets:{size:2,accessor:"getIconOffsets"},instancePickingColors:{type:5121,size:3,accessor:(e,{index:t,target:i})=>this.encodePickingColor(t,i)}})}updateState(e){super.updateState(e);const{props:t,oldProps:i}=e;let{outlineColor:n}=t;n!==i.outlineColor&&(n=n.map((e=>e/255)),n[3]=Number.isFinite(n[3])?n[3]:1,this.setState({outlineColor:n})),!t.sdf&&t.outlineWidth&&C.Z.warn("".concat(this.id,": fontSettings.sdf is required to render outline"))()}draw(e){const{sdf:t,smoothing:i,outlineWidth:n}=this.props,{outlineColor:o}=this.state,s=n?Math.max(i,L*(1-n)):-1;if(e.uniforms={...e.uniforms,sdfBuffer:L,outlineBuffer:s,gamma:i,sdf:Boolean(t),outlineColor:o},super.draw(e),t&&n){const{iconManager:e}=this.state,t=e.getTexture();t&&this.state.model.draw({uniforms:{outlineBuffer:L}})}}getInstanceOffset(e){return e?Array.from(e).flatMap((e=>super.getInstanceOffset(e))):w}getInstanceColorMode(e){return 1}getInstanceIconFrame(e){return e?Array.from(e).flatMap((e=>super.getInstanceIconFrame(e))):w}}(0,n.Z)(T,"defaultProps",z),(0,n.Z)(T,"layerName","MultiIconLayer");var M=i(39875);const A=32,I=[];function O(e){return Math.pow(2,Math.ceil(Math.log2(e)))}function E({characterSet:e,getFontWidth:t,fontHeight:i,buffer:n,maxCanvasWidth:o,mapping:s={},xOffset:r=0,yOffset:a=0}){let l=0,c=r;const d=i+2*n;for(const u of e)if(!s[u]){const e=t(u);c+e+2*n>o&&(c=0,l++),s[u]={x:c+n,y:a+l*d+n,width:e,height:d,layoutWidth:e,layoutHeight:i},c+=e+2*n}return{mapping:s,xOffset:c,yOffset:a+l*d,canvasHeight:O(a+(l+1)*d)}}function F(e,t,i,n){let o=0;for(let r=t;r<i;r++){var s;const t=e[r];o+=(null===(s=n[t])||void 0===s?void 0:s.layoutWidth)||0}return o}function R(e,t,i,n,o,s){let r=t,a=0;for(let l=t;l<i;l++){const t=F(e,l,l+1,o);a+t>n&&(r<l&&s.push(l),r=l,a=0),a+=t}return a}function Z(e,t,i,n,o,s){let r=t,a=t,l=t,c=0;for(let d=t;d<i;d++)if(" "===e[d]?l=d+1:" "!==e[d+1]&&d+1!==i||(l=d+1),l>a){let t=F(e,a,l,o);c+t>n&&(r<a&&(s.push(a),r=a,c=0),t>n&&(t=R(e,a,l,n,o,s),r=s[s.length-1])),a=l,c+=t}return c}function k(e,t,i,n,o=0,s){void 0===s&&(s=e.length);const r=[];return"break-all"===t?R(e,o,s,i,n,r):Z(e,o,s,i,n,r),r}function W(e,t,i,n,o,s){let r=0,a=0;for(let l=t;l<i;l++){const t=e[l],i=n[t];i?(a||(a=i.layoutHeight),o[l]=r+i.layoutWidth/2,r+=i.layoutWidth):(C.Z.warn("Missing character: ".concat(t," (").concat(t.codePointAt(0),")"))(),o[l]=r,r+=A)}s[0]=r,s[1]=a}function B(e,t,i,n,o){const s=Array.from(e),r=s.length,a=new Array(r),l=new Array(r),c=new Array(r),d=("break-word"===i||"break-all"===i)&&isFinite(n)&&n>0,u=[0,0],h=[0,0];let g=0,p=0,f=0;for(let v=0;v<=r;v++){const e=s[v];if("\n"!==e&&v!==r||(f=v),f>p){const e=d?k(s,i,n,o,p,f):I;for(let i=0;i<=e.length;i++){const n=0===i?p:e[i-1],r=i<e.length?e[i]:f;W(s,n,r,o,a,h);for(let e=n;e<r;e++){var m;const t=s[e],i=(null===(m=o[t])||void 0===m?void 0:m.layoutOffsetY)||0;l[e]=g+h[1]/2+i,c[e]=h[0]}g+=h[1]*t,u[0]=Math.max(u[0],h[0])}p=f}"\n"===e&&(a[p]=0,l[p]=0,c[p]=0,p++)}return u[1]=g,{x:a,y:l,rowWidth:c,size:u}}function D({value:e,length:t,stride:i,offset:n,startIndices:o,characterSet:s}){const r=e.BYTES_PER_ELEMENT,a=i?i/r:1,l=n?n/r:0,c=o[t]||Math.ceil((e.length-l)/a),d=s&&new Set,u=new Array(t);let h=e;if(a>1||l>0){const t=e.constructor;h=new t(c);for(let i=0;i<c;i++)h[i]=e[i*a+l]}for(let g=0;g<t;g++){const e=o[g],t=o[g+1]||c,i=h.subarray(e,t);u[g]=String.fromCodePoint.apply(null,i),d&&i.forEach(d.add,d)}if(d)for(const g of d)s.add(String.fromCodePoint(g));return{texts:u,characterCount:c}}class N{constructor(e=5){(0,n.Z)(this,"limit",void 0),(0,n.Z)(this,"_cache",{}),(0,n.Z)(this,"_order",[]),this.limit=e}get(e){const t=this._cache[e];return t&&(this._deleteOrder(e),this._appendOrder(e)),t}set(e,t){this._cache[e]?(this.delete(e),this._cache[e]=t,this._appendOrder(e)):(Object.keys(this._cache).length===this.limit&&this.delete(this._order[0]),this._cache[e]=t,this._appendOrder(e))}delete(e){const t=this._cache[e];t&&(delete this._cache[e],this._deleteOrder(e))}_deleteOrder(e){const t=this._order.indexOf(e);t>=0&&this._order.splice(t,1)}_appendOrder(e){this._order.push(e)}}function G(){const e=[];for(let t=32;t<128;t++)e.push(String.fromCharCode(t));return e}const U={fontFamily:"Monaco, monospace",fontWeight:"normal",characterSet:G(),fontSize:64,buffer:4,sdf:!1,cutoff:.25,radius:12,smoothing:.1},j=1024,V=.9,H=1.2,K=3;let J=new N(K);function q(e,t){let i;i="string"===typeof t?new Set(Array.from(t)):new Set(t);const n=J.get(e);if(!n)return i;for(const o in n.mapping)i.has(o)&&i.delete(o);return i}function X(e,t){for(let i=0;i<e.length;i++)t.data[4*i+3]=e[i]}function Y(e,t,i,n){e.font="".concat(n," ").concat(i,"px ").concat(t),e.fillStyle="#000",e.textBaseline="alphabetic",e.textAlign="left"}function Q(e){C.Z.assert(Number.isFinite(e)&&e>=K,"Invalid cache limit"),J=new N(e)}class ${constructor(){(0,n.Z)(this,"props",{...U}),(0,n.Z)(this,"_key",void 0),(0,n.Z)(this,"_atlas",void 0)}get texture(){return this._atlas}get mapping(){return this._atlas&&this._atlas.mapping}get scale(){const{fontSize:e,buffer:t}=this.props;return(e*H+2*t)/e}setProps(e={}){Object.assign(this.props,e),this._key=this._getKey();const t=q(this._key,this.props.characterSet),i=J.get(this._key);if(i&&0===t.size)return void(this._atlas!==i&&(this._atlas=i));const n=this._generateFontAtlas(t,i);this._atlas=n,J.set(this._key,n)}_generateFontAtlas(e,t){const{fontFamily:i,fontWeight:n,fontSize:o,buffer:s,sdf:r,radius:a,cutoff:l}=this.props;let c=t&&t.data;c||(c=document.createElement("canvas"),c.width=j);const d=c.getContext("2d",{willReadFrequently:!0});Y(d,i,o,n);const{mapping:u,canvasHeight:h,xOffset:g,yOffset:p}=E({getFontWidth:e=>d.measureText(e).width,fontHeight:o*H,buffer:s,characterSet:e,maxCanvasWidth:j,...t&&{mapping:t.mapping,xOffset:t.xOffset,yOffset:t.yOffset}});if(c.height!==h){const e=d.getImageData(0,0,c.width,c.height);c.height=h,d.putImageData(e,0,0)}if(Y(d,i,o,n),r){const t=new M.Z({fontSize:o,buffer:s,radius:a,cutoff:l,fontFamily:i,fontWeight:"".concat(n)});for(const i of e){const{data:e,width:n,height:s,glyphTop:r}=t.draw(i);u[i].width=n,u[i].layoutOffsetY=o*V-r;const a=d.createImageData(n,s);X(e,a),d.putImageData(a,u[i].x,u[i].y)}}else for(const f of e)d.fillText(f,u[f].x,u[f].y+s+o*V);return{xOffset:g,yOffset:p,mapping:u,data:c,width:c.width,height:c.height}}_getKey(){const{fontFamily:e,fontWeight:t,fontSize:i,buffer:n,sdf:o,radius:s,cutoff:r}=this.props;return o?"".concat(e," ").concat(t," ").concat(i," ").concat(n," ").concat(s," ").concat(r):"".concat(e," ").concat(t," ").concat(i," ").concat(n)}}var ee="#define SHADER_NAME text-background-layer-vertex-shader\n\nattribute vec2 positions;\n\nattribute vec3 instancePositions;\nattribute vec3 instancePositions64Low;\nattribute vec4 instanceRects;\nattribute float instanceSizes;\nattribute float instanceAngles;\nattribute vec2 instancePixelOffsets;\nattribute float instanceLineWidths;\nattribute vec4 instanceFillColors;\nattribute vec4 instanceLineColors;\nattribute vec3 instancePickingColors;\n\nuniform bool billboard;\nuniform float opacity;\nuniform float sizeScale;\nuniform float sizeMinPixels;\nuniform float sizeMaxPixels;\nuniform vec4 padding;\nuniform int sizeUnits;\n\nvarying vec4 vFillColor;\nvarying vec4 vLineColor;\nvarying float vLineWidth;\nvarying vec2 uv;\nvarying vec2 dimensions;\n\nvec2 rotate_by_angle(vec2 vertex, float angle) {\n  float angle_radian = radians(angle);\n  float cos_angle = cos(angle_radian);\n  float sin_angle = sin(angle_radian);\n  mat2 rotationMatrix = mat2(cos_angle, -sin_angle, sin_angle, cos_angle);\n  return rotationMatrix * vertex;\n}\n\nvoid main(void) {\n  geometry.worldPosition = instancePositions;\n  geometry.uv = positions;\n  geometry.pickingColor = instancePickingColors;\n  uv = positions;\n  vLineWidth = instanceLineWidths;\n  float sizePixels = clamp(\n    project_size_to_pixel(instanceSizes * sizeScale, sizeUnits),\n    sizeMinPixels, sizeMaxPixels\n  );\n\n  dimensions = instanceRects.zw * sizePixels + padding.xy + padding.zw;\n\n  vec2 pixelOffset = (positions * instanceRects.zw + instanceRects.xy) * sizePixels + mix(-padding.xy, padding.zw, positions);\n  pixelOffset = rotate_by_angle(pixelOffset, instanceAngles);\n  pixelOffset += instancePixelOffsets;\n  pixelOffset.y *= -1.0;\n\n  if (billboard)  {\n    gl_Position = project_position_to_clipspace(instancePositions, instancePositions64Low, vec3(0.0), geometry.position);\n    DECKGL_FILTER_GL_POSITION(gl_Position, geometry);\n    vec3 offset = vec3(pixelOffset, 0.0);\n    DECKGL_FILTER_SIZE(offset, geometry);\n    gl_Position.xy += project_pixel_size_to_clipspace(offset.xy);\n  } else {\n    vec3 offset_common = vec3(project_pixel_size(pixelOffset), 0.0);\n    DECKGL_FILTER_SIZE(offset_common, geometry);\n    gl_Position = project_position_to_clipspace(instancePositions, instancePositions64Low, offset_common, geometry.position);\n    DECKGL_FILTER_GL_POSITION(gl_Position, geometry);\n  }\n  vFillColor = vec4(instanceFillColors.rgb, instanceFillColors.a * opacity);\n  DECKGL_FILTER_COLOR(vFillColor, geometry);\n  vLineColor = vec4(instanceLineColors.rgb, instanceLineColors.a * opacity);\n  DECKGL_FILTER_COLOR(vLineColor, geometry);\n}\n",te="#define SHADER_NAME text-background-layer-fragment-shader\n\nprecision highp float;\n\nuniform bool stroked;\n\nvarying vec4 vFillColor;\nvarying vec4 vLineColor;\nvarying float vLineWidth;\nvarying vec2 uv;\nvarying vec2 dimensions;\n\nvoid main(void) {\n  geometry.uv = uv;\n\n  vec2 pixelPosition = uv * dimensions;\n  if (stroked) {\n    float distToEdge = min(\n      min(pixelPosition.x, dimensions.x - pixelPosition.x),\n      min(pixelPosition.y, dimensions.y - pixelPosition.y)\n    );\n    float isBorder = smoothedge(distToEdge, vLineWidth);\n    gl_FragColor = mix(vFillColor, vLineColor, isBorder);\n  } else {\n    gl_FragColor = vFillColor;\n  }\n\n  DECKGL_FILTER_COLOR(gl_FragColor, geometry);\n}\n";const ie={billboard:!0,sizeScale:1,sizeUnits:"pixels",sizeMinPixels:0,sizeMaxPixels:Number.MAX_SAFE_INTEGER,padding:{type:"array",value:[0,0,0,0]},getPosition:{type:"accessor",value:e=>e.position},getSize:{type:"accessor",value:1},getAngle:{type:"accessor",value:0},getPixelOffset:{type:"accessor",value:[0,0]},getBoundingRect:{type:"accessor",value:[0,0,0,0]},getFillColor:{type:"accessor",value:[0,0,0,255]},getLineColor:{type:"accessor",value:[0,0,0,255]},getLineWidth:{type:"accessor",value:1}};class ne extends u.Z{constructor(...e){super(...e),(0,n.Z)(this,"state",void 0)}getShaders(){return super.getShaders({vs:ee,fs:te,modules:[h.Z,g.Z]})}initializeState(){this.getAttributeManager().addInstanced({instancePositions:{size:3,type:5130,fp64:this.use64bitPositions(),transition:!0,accessor:"getPosition"},instanceSizes:{size:1,transition:!0,accessor:"getSize",defaultValue:1},instanceAngles:{size:1,transition:!0,accessor:"getAngle"},instanceRects:{size:4,accessor:"getBoundingRect"},instancePixelOffsets:{size:2,transition:!0,accessor:"getPixelOffset"},instanceFillColors:{size:4,transition:!0,normalized:!0,type:5121,accessor:"getFillColor",defaultValue:[0,0,0,255]},instanceLineColors:{size:4,transition:!0,normalized:!0,type:5121,accessor:"getLineColor",defaultValue:[0,0,0,255]},instanceLineWidths:{size:1,transition:!0,accessor:"getLineWidth",defaultValue:1}})}updateState(e){super.updateState(e);const{changeFlags:t}=e;if(t.extensionsChanged){var i;const{gl:e}=this.context;null===(i=this.state.model)||void 0===i||i.delete(),this.state.model=this._getModel(e),this.getAttributeManager().invalidateAll()}}draw({uniforms:e}){const{billboard:t,sizeScale:i,sizeUnits:n,sizeMinPixels:o,sizeMaxPixels:s,getLineWidth:r}=this.props;let{padding:a}=this.props;a.length<4&&(a=[a[0],a[1],a[0],a[1]]),this.state.model.setUniforms(e).setUniforms({billboard:t,stroked:Boolean(r),padding:a,sizeUnits:p.iI[n],sizeScale:i,sizeMinPixels:o,sizeMaxPixels:s}).draw()}_getModel(e){const t=[0,0,1,0,1,1,0,1];return new f.Z(e,{...this.getShaders(),id:this.props.id,geometry:new m.Z({drawMode:6,vertexCount:4,attributes:{positions:{size:2,value:new Float32Array(t)}}}),isInstanced:!0})}}(0,n.Z)(ne,"defaultProps",ie),(0,n.Z)(ne,"layerName","TextBackgroundLayer");const oe={start:1,middle:0,end:-1},se={top:1,center:0,bottom:-1},re=[0,0,0,255],ae=1,le={billboard:!0,sizeScale:1,sizeUnits:"pixels",sizeMinPixels:0,sizeMaxPixels:Number.MAX_SAFE_INTEGER,background:!1,getBackgroundColor:{type:"accessor",value:[255,255,255,255]},getBorderColor:{type:"accessor",value:re},getBorderWidth:{type:"accessor",value:0},backgroundPadding:{type:"array",value:[0,0,0,0]},characterSet:{type:"object",value:U.characterSet},fontFamily:U.fontFamily,fontWeight:U.fontWeight,lineHeight:ae,outlineWidth:{type:"number",value:0,min:0},outlineColor:{type:"color",value:re},fontSettings:{type:"object",value:{},compare:1},wordBreak:"break-word",maxWidth:{type:"number",value:-1},getText:{type:"accessor",value:e=>e.text},getPosition:{type:"accessor",value:e=>e.position},getColor:{type:"accessor",value:re},getSize:{type:"accessor",value:32},getAngle:{type:"accessor",value:0},getTextAnchor:{type:"accessor",value:"middle"},getAlignmentBaseline:{type:"accessor",value:"center"},getPixelOffset:{type:"accessor",value:[0,0]},backgroundColor:{deprecatedFor:["background","getBackgroundColor"]}};class ce extends o.Z{constructor(...e){super(...e),(0,n.Z)(this,"state",void 0),(0,n.Z)(this,"getBoundingRect",((e,t)=>{let{size:[i,n]}=this.transformParagraph(e,t);const{fontSize:o}=this.state.fontAtlasManager.props;i/=o,n/=o;const{getTextAnchor:s,getAlignmentBaseline:r}=this.props,a=oe["function"===typeof s?s(e,t):s],l=se["function"===typeof r?r(e,t):r];return[(a-1)*i/2,(l-1)*n/2,i,n]})),(0,n.Z)(this,"getIconOffsets",((e,t)=>{const{getTextAnchor:i,getAlignmentBaseline:n}=this.props,{x:o,y:s,rowWidth:r,size:[a,l]}=this.transformParagraph(e,t),c=oe["function"===typeof i?i(e,t):i],d=se["function"===typeof n?n(e,t):n],u=o.length,h=new Array(2*u);let g=0;for(let p=0;p<u;p++){const e=(1-c)*(a-r[p])/2;h[g++]=(c-1)*a/2+e+o[p],h[g++]=(d-1)*l/2+s[p]}return h}))}initializeState(){this.state={styleVersion:0,fontAtlasManager:new $},this.props.maxWidth>0&&C.Z.warn("v8.9 breaking change: TextLayer maxWidth is now relative to text size")()}updateState(e){const{props:t,oldProps:i,changeFlags:n}=e,o=n.dataChanged||n.updateTriggersChanged&&(n.updateTriggersChanged.all||n.updateTriggersChanged.getText);o&&this._updateText();const s=this._updateFontAtlas(),r=s||t.lineHeight!==i.lineHeight||t.wordBreak!==i.wordBreak||t.maxWidth!==i.maxWidth;r&&this.setState({styleVersion:this.state.styleVersion+1})}getPickingInfo({info:e}){return e.object=e.index>=0?this.props.data[e.index]:null,e}_updateFontAtlas(){const{fontSettings:e,fontFamily:t,fontWeight:i}=this.props,{fontAtlasManager:n,characterSet:o}=this.state,s={...e,characterSet:o,fontFamily:t,fontWeight:i};if(!n.mapping)return n.setProps(s),!0;for(const r in s)if(s[r]!==n.props[r])return n.setProps(s),!0;return!1}_updateText(){var e;const{data:t,characterSet:i}=this.props,n=null===(e=t.attributes)||void 0===e?void 0:e.getText;let o,{getText:s}=this.props,r=t.startIndices;const a="auto"===i&&new Set;if(n&&r){const{texts:e,characterCount:i}=D({...ArrayBuffer.isView(n)?{value:n}:n,length:t.length,startIndices:r,characterSet:a});o=i,s=(t,{index:i})=>e[i]}else{const{iterable:e,objectInfo:i}=(0,b.jB)(t);r=[0],o=0;for(const t of e){i.index++;const e=Array.from(s(t,i)||"");a&&e.forEach(a.add,a),o+=e.length,r.push(o)}}this.setState({getText:s,startIndices:r,numInstances:o,characterSet:a||i})}transformParagraph(e,t){const{fontAtlasManager:i}=this.state,n=i.mapping,o=this.state.getText,{wordBreak:s,lineHeight:r,maxWidth:a}=this.props,l=o(e,t)||"";return B(l,r,s,a*i.props.fontSize,n)}renderLayers(){const{startIndices:e,numInstances:t,getText:i,fontAtlasManager:{scale:n,texture:o,mapping:s},styleVersion:r}=this.state,{data:a,_dataDiff:l,getPosition:c,getColor:d,getSize:u,getAngle:h,getPixelOffset:g,getBackgroundColor:p,getBorderColor:f,getBorderWidth:m,backgroundPadding:v,background:y,billboard:x,fontSettings:_,outlineWidth:P,outlineColor:C,sizeScale:b,sizeUnits:S,sizeMinPixels:L,sizeMaxPixels:w,transitions:z,updateTriggers:M}=this.props,A=this.getSubLayerClass("characters",T),I=this.getSubLayerClass("background",ne);return[y&&new I({getFillColor:p,getLineColor:f,getLineWidth:m,padding:v,getPosition:c,getSize:u,getAngle:h,getPixelOffset:g,billboard:x,sizeScale:b,sizeUnits:S,sizeMinPixels:L,sizeMaxPixels:w,transitions:z&&{getPosition:z.getPosition,getAngle:z.getAngle,getSize:z.getSize,getFillColor:z.getBackgroundColor,getLineColor:z.getBorderColor,getLineWidth:z.getBorderWidth,getPixelOffset:z.getPixelOffset}},this.getSubLayerProps({id:"background",updateTriggers:{getPosition:M.getPosition,getAngle:M.getAngle,getSize:M.getSize,getFillColor:M.getBackgroundColor,getLineColor:M.getBorderColor,getLineWidth:M.getBorderWidth,getPixelOffset:M.getPixelOffset,getBoundingRect:{getText:M.getText,getTextAnchor:M.getTextAnchor,getAlignmentBaseline:M.getAlignmentBaseline,styleVersion:r}}}),{data:a.attributes&&a.attributes.background?{length:a.length,attributes:a.attributes.background}:a,_dataDiff:l,autoHighlight:!1,getBoundingRect:this.getBoundingRect}),new A({sdf:_.sdf,smoothing:Number.isFinite(_.smoothing)?_.smoothing:U.smoothing,outlineWidth:P/(_.radius||U.radius),outlineColor:C,iconAtlas:o,iconMapping:s,getPosition:c,getColor:d,getSize:u,getAngle:h,getPixelOffset:g,billboard:x,sizeScale:b*n,sizeUnits:S,sizeMinPixels:L*n,sizeMaxPixels:w*n,transitions:z&&{getPosition:z.getPosition,getAngle:z.getAngle,getColor:z.getColor,getSize:z.getSize,getPixelOffset:z.getPixelOffset}},this.getSubLayerProps({id:"characters",updateTriggers:{all:M.getText,getPosition:M.getPosition,getAngle:M.getAngle,getColor:M.getColor,getSize:M.getSize,getPixelOffset:M.getPixelOffset,getIconOffsets:{getTextAnchor:M.getTextAnchor,getAlignmentBaseline:M.getAlignmentBaseline,styleVersion:r}}}),{data:a,_dataDiff:l,startIndices:e,numInstances:t,getIconOffsets:this.getIconOffsets,getIcon:i})]}static set fontAtlasCacheLimit(e){Q(e)}}(0,n.Z)(ce,"defaultProps",le),(0,n.Z)(ce,"layerName","TextLayer");var de=i(41990),ue=i(56923);const he={circle:{type:P,props:{filled:"filled",stroked:"stroked",lineWidthMaxPixels:"lineWidthMaxPixels",lineWidthMinPixels:"lineWidthMinPixels",lineWidthScale:"lineWidthScale",lineWidthUnits:"lineWidthUnits",pointRadiusMaxPixels:"radiusMaxPixels",pointRadiusMinPixels:"radiusMinPixels",pointRadiusScale:"radiusScale",pointRadiusUnits:"radiusUnits",pointAntialiasing:"antialiasing",pointBillboard:"billboard",getFillColor:"getFillColor",getLineColor:"getLineColor",getLineWidth:"getLineWidth",getPointRadius:"getRadius"}},icon:{type:d.Z,props:{iconAtlas:"iconAtlas",iconMapping:"iconMapping",iconSizeMaxPixels:"sizeMaxPixels",iconSizeMinPixels:"sizeMinPixels",iconSizeScale:"sizeScale",iconSizeUnits:"sizeUnits",iconAlphaCutoff:"alphaCutoff",iconBillboard:"billboard",getIcon:"getIcon",getIconAngle:"getAngle",getIconColor:"getColor",getIconPixelOffset:"getPixelOffset",getIconSize:"getSize"}},text:{type:ce,props:{textSizeMaxPixels:"sizeMaxPixels",textSizeMinPixels:"sizeMinPixels",textSizeScale:"sizeScale",textSizeUnits:"sizeUnits",textBackground:"background",textBackgroundPadding:"backgroundPadding",textFontFamily:"fontFamily",textFontWeight:"fontWeight",textLineHeight:"lineHeight",textMaxWidth:"maxWidth",textOutlineColor:"outlineColor",textOutlineWidth:"outlineWidth",textWordBreak:"wordBreak",textCharacterSet:"characterSet",textBillboard:"billboard",textFontSettings:"fontSettings",getText:"getText",getTextAngle:"getAngle",getTextColor:"getColor",getTextPixelOffset:"getPixelOffset",getTextSize:"getSize",getTextAnchor:"getTextAnchor",getTextAlignmentBaseline:"getAlignmentBaseline",getTextBackgroundColor:"getBackgroundColor",getTextBorderColor:"getBorderColor",getTextBorderWidth:"getBorderWidth"}}},ge={type:de.Z,props:{lineWidthUnits:"widthUnits",lineWidthScale:"widthScale",lineWidthMinPixels:"widthMinPixels",lineWidthMaxPixels:"widthMaxPixels",lineJointRounded:"jointRounded",lineCapRounded:"capRounded",lineMiterLimit:"miterLimit",lineBillboard:"billboard",getLineColor:"getColor",getLineWidth:"getWidth"}},pe={type:ue.Z,props:{extruded:"extruded",filled:"filled",wireframe:"wireframe",elevationScale:"elevationScale",material:"material",_full3d:"_full3d",getElevation:"getElevation",getFillColor:"getFillColor",getLineColor:"getLineColor"}};function fe({type:e,props:t}){const i={};for(const n in t)i[n]=e.defaultProps[t[n]];return i}function me(e,t){const{transitions:i,updateTriggers:n}=e.props,o={updateTriggers:{},transitions:i&&{getPosition:i.geometry}};for(const s in t){const r=t[s];let a=e.props[s];s.startsWith("get")&&(a=e.getSubLayerAccessor(a),o.updateTriggers[r]=n[s],i&&(o.transitions[r]=i[s])),o[r]=a}return o}function ve(e){if(Array.isArray(e))return e;switch(C.Z.assert(e.type,"GeoJSON does not have type"),e.type){case"Feature":return[e];case"FeatureCollection":return C.Z.assert(Array.isArray(e.features),"GeoJSON does not have features array"),e.features;default:return[{geometry:e}]}}function ye(e,t,i={}){const n={pointFeatures:[],lineFeatures:[],polygonFeatures:[],polygonOutlineFeatures:[]},{startRow:o=0,endRow:s=e.length}=i;for(let r=o;r<s;r++){const i=e[r],{geometry:o}=i;if(o)if("GeometryCollection"===o.type){C.Z.assert(Array.isArray(o.geometries),"GeoJSON does not have geometries array");const{geometries:e}=o;for(let o=0;o<e.length;o++){const s=e[o];xe(s,n,t,i,r)}}else xe(o,n,t,i,r)}return n}function xe(e,t,i,n,o){const{type:s,coordinates:r}=e,{pointFeatures:a,lineFeatures:l,polygonFeatures:c,polygonOutlineFeatures:d}=t;if(Pe(s,r))switch(s){case"Point":a.push(i({geometry:e},n,o));break;case"MultiPoint":r.forEach((e=>{a.push(i({geometry:{type:"Point",coordinates:e}},n,o))}));break;case"LineString":l.push(i({geometry:e},n,o));break;case"MultiLineString":r.forEach((e=>{l.push(i({geometry:{type:"LineString",coordinates:e}},n,o))}));break;case"Polygon":c.push(i({geometry:e},n,o)),r.forEach((e=>{d.push(i({geometry:{type:"LineString",coordinates:e}},n,o))}));break;case"MultiPolygon":r.forEach((e=>{c.push(i({geometry:{type:"Polygon",coordinates:e}},n,o)),e.forEach((e=>{d.push(i({geometry:{type:"LineString",coordinates:e}},n,o))}))}));break;default:}else C.Z.warn("".concat(s," coordinates are malformed"))()}const _e={Point:1,MultiPoint:2,LineString:2,MultiLineString:3,Polygon:3,MultiPolygon:4};function Pe(e,t){let i=_e[e];C.Z.assert(i,"Unknown GeoJSON type ".concat(e));while(t&&--i>0)t=t[0];return t&&Number.isFinite(t[0])}function Ce(){return{points:{},lines:{},polygons:{},polygonsOutline:{}}}function be(e){return e.geometry.coordinates}function Se(e,t){const i=Ce(),{pointFeatures:n,lineFeatures:o,polygonFeatures:s,polygonOutlineFeatures:r}=e;return i.points.data=n,i.points._dataDiff=t.pointFeatures&&(()=>t.pointFeatures),i.points.getPosition=be,i.lines.data=o,i.lines._dataDiff=t.lineFeatures&&(()=>t.lineFeatures),i.lines.getPath=be,i.polygons.data=s,i.polygons._dataDiff=t.polygonFeatures&&(()=>t.polygonFeatures),i.polygons.getPolygon=be,i.polygonsOutline.data=r,i.polygonsOutline._dataDiff=t.polygonOutlineFeatures&&(()=>t.polygonOutlineFeatures),i.polygonsOutline.getPath=be,i}function Le(e,t){const i=Ce(),{points:n,lines:o,polygons:s}=e,r=c(e,t);return i.points.data={length:n.positions.value.length/n.positions.size,attributes:{...n.attributes,getPosition:n.positions,instancePickingColors:{size:3,value:r.points}},properties:n.properties,numericProps:n.numericProps,featureIds:n.featureIds},i.lines.data={length:o.pathIndices.value.length-1,startIndices:o.pathIndices.value,attributes:{...o.attributes,getPath:o.positions,instancePickingColors:{size:3,value:r.lines}},properties:o.properties,numericProps:o.numericProps,featureIds:o.featureIds},i.lines._pathType="open",i.polygons.data={length:s.polygonIndices.value.length-1,startIndices:s.polygonIndices.value,attributes:{...s.attributes,getPolygon:s.positions,pickingColors:{size:3,value:r.polygons}},properties:s.properties,numericProps:s.numericProps,featureIds:s.featureIds},i.polygons._normalize=!1,s.triangles&&(i.polygons.data.attributes.indices=s.triangles.value),i.polygonsOutline.data={length:s.primitivePolygonIndices.value.length-1,startIndices:s.primitivePolygonIndices.value,attributes:{...s.attributes,getPath:s.positions,instancePickingColors:{size:3,value:r.polygons}},properties:s.properties,numericProps:s.numericProps,featureIds:s.featureIds},i.polygonsOutline._pathType="open",i}const we=["points","linestrings","polygons"],ze={...fe(he.circle),...fe(he.icon),...fe(he.text),...fe(ge),...fe(pe),stroked:!0,filled:!0,extruded:!1,wireframe:!1,_full3d:!1,iconAtlas:{type:"object",value:null},iconMapping:{type:"object",value:{}},getIcon:{type:"accessor",value:e=>e.properties.icon},getText:{type:"accessor",value:e=>e.properties.text},pointType:"circle",getRadius:{deprecatedFor:"getPointRadius"}};class Te extends o.Z{initializeState(){this.state={layerProps:{},features:{}}}updateState({props:e,changeFlags:t}){if(!t.dataChanged)return;const{data:i}=this.props,n=i&&"points"in i&&"polygons"in i&&"lines"in i;this.setState({binary:n}),n?this._updateStateBinary({props:e,changeFlags:t}):this._updateStateJSON({props:e,changeFlags:t})}_updateStateBinary({props:e,changeFlags:t}){const i=Le(e.data,this.encodePickingColor);this.setState({layerProps:i})}_updateStateJSON({props:e,changeFlags:t}){const i=ve(e.data),n=this.getSubLayerRow.bind(this);let o={};const s={};if(Array.isArray(t.dataChanged)){const e=this.state.features;for(const t in e)o[t]=e[t].slice(),s[t]=[];for(const a of t.dataChanged){const t=ye(i,n,a);for(const i in e)s[i].push((0,r.b)({data:o[i],getIndex:e=>e.__source.index,dataRange:a,replace:t[i]}))}}else o=ye(i,n);const a=Se(o,s);this.setState({features:o,featuresDiff:s,layerProps:a})}getPickingInfo(e){const t=super.getPickingInfo(e),{index:i,sourceLayer:n}=t;return t.featureType=we.find((e=>n.id.startsWith("".concat(this.id,"-").concat(e,"-")))),i>=0&&n.id.startsWith("".concat(this.id,"-points-text"))&&this.state.binary&&(t.index=this.props.data.points.globalFeatureIds.value[i]),t}_updateAutoHighlight(e){const t="".concat(this.id,"-points-"),i="points"===e.featureType;for(const n of this.getSubLayers())n.id.startsWith(t)===i&&n.updateAutoHighlight(e)}_renderPolygonLayer(){const{extruded:e,wireframe:t}=this.props,{layerProps:i}=this.state,n="polygons-fill",o=this.shouldRenderSubLayer(n,i.polygons.data)&&this.getSubLayerClass(n,pe.type);if(o){const s=me(this,pe.props),r=e&&t;return r||delete s.getLineColor,s.updateTriggers.lineColors=r,new o(s,this.getSubLayerProps({id:n,updateTriggers:s.updateTriggers}),i.polygons)}return null}_renderLineLayers(){const{extruded:e,stroked:t}=this.props,{layerProps:i}=this.state,n="polygons-stroke",o="linestrings",s=!e&&t&&this.shouldRenderSubLayer(n,i.polygonsOutline.data)&&this.getSubLayerClass(n,ge.type),r=this.shouldRenderSubLayer(o,i.lines.data)&&this.getSubLayerClass(o,ge.type);if(s||r){const e=me(this,ge.props);return[s&&new s(e,this.getSubLayerProps({id:n,updateTriggers:e.updateTriggers}),i.polygonsOutline),r&&new r(e,this.getSubLayerProps({id:o,updateTriggers:e.updateTriggers}),i.lines)]}return null}_renderPointLayers(){const{pointType:e}=this.props,{layerProps:t,binary:i}=this.state;let{highlightedObjectIndex:n}=this.props;!i&&Number.isFinite(n)&&(n=t.points.data.findIndex((e=>e.__source.index===n)));const o=new Set(e.split("+")),s=[];for(const r of o){const e="points-".concat(r),o=he[r],a=o&&this.shouldRenderSubLayer(e,t.points.data)&&this.getSubLayerClass(e,o.type);if(a){const l=me(this,o.props);let c=t.points;if("text"===r&&i){const{instancePickingColors:e,...t}=c.data.attributes;c={...c,data:{...c.data,attributes:t}}}s.push(new a(l,this.getSubLayerProps({id:e,updateTriggers:l.updateTriggers,highlightedObjectIndex:n}),c))}}return s}renderLayers(){const{extruded:e}=this.props,t=this._renderPolygonLayer(),i=this._renderLineLayers(),n=this._renderPointLayers();return[!e&&t,i,n,e&&t]}getSubLayerAccessor(e){const{binary:t}=this.state;return t&&"function"===typeof e?(t,i)=>{const{data:n,index:o}=i,s=a(n,o);return e(s,i)}:super.getSubLayerAccessor(e)}}(0,n.Z)(Te,"layerName","GeoJsonLayer"),(0,n.Z)(Te,"defaultProps",ze);var Me=i(78634),Ae=i(85451),Ie=i(14034);class Oe{constructor(e){(0,n.Z)(this,"index",void 0),(0,n.Z)(this,"isVisible",void 0),(0,n.Z)(this,"isSelected",void 0),(0,n.Z)(this,"parent",void 0),(0,n.Z)(this,"children",void 0),(0,n.Z)(this,"content",void 0),(0,n.Z)(this,"state",void 0),(0,n.Z)(this,"layers",void 0),(0,n.Z)(this,"id",void 0),(0,n.Z)(this,"bbox",void 0),(0,n.Z)(this,"zoom",void 0),(0,n.Z)(this,"userData",void 0),(0,n.Z)(this,"_abortController",void 0),(0,n.Z)(this,"_loader",void 0),(0,n.Z)(this,"_loaderId",void 0),(0,n.Z)(this,"_isLoaded",void 0),(0,n.Z)(this,"_isCancelled",void 0),(0,n.Z)(this,"_needsReload",void 0),this.index=e,this.isVisible=!1,this.isSelected=!1,this.parent=null,this.children=[],this.content=null,this._loader=void 0,this._abortController=null,this._loaderId=0,this._isLoaded=!1,this._isCancelled=!1,this._needsReload=!1}get data(){return this.isLoading&&this._loader?this._loader.then((()=>this.data)):this.content}get isLoaded(){return this._isLoaded&&!this._needsReload}get isLoading(){return Boolean(this._loader)&&!this._isCancelled}get needsReload(){return this._needsReload||this._isCancelled}get byteLength(){const e=this.content?this.content.byteLength:0;return Number.isFinite(e)||console.error("byteLength not defined in tile data"),e}async _loadData({getData:e,requestScheduler:t,onLoad:i,onError:n}){const{index:o,id:s,bbox:r,userData:a,zoom:l}=this,c=this._loaderId;this._abortController=new AbortController;const{signal:d}=this._abortController,u=await t.scheduleRequest(this,(e=>e.isSelected?1:-1));if(!u)return void(this._isCancelled=!0);if(this._isCancelled)return void u.done();let h,g=null;try{g=await e({index:o,id:s,bbox:r,userData:a,zoom:l,signal:d})}catch(p){h=p||!0}finally{u.done()}c===this._loaderId&&(this._loader=void 0,this.content=g,!this._isCancelled||g?(this._isLoaded=!0,this._isCancelled=!1,h?n(h,this):i(this)):this._isLoaded=!1)}loadData(e){return this._isLoaded=!1,this._isCancelled=!1,this._needsReload=!1,this._loaderId++,this._loader=this._loadData(e),this._loader}setNeedsReload(){this.isLoading&&(this.abort(),this._loader=void 0),this._needsReload=!0}abort(){var e;this.isLoaded||(this._isCancelled=!0,null===(e=this._abortController)||void 0===e||e.abort())}}var Ee=i(73131),Fe=i(96935),Re=i(36772),Ze=i(78866);const ke=512,We=3,Be=[[.5,.5],[0,0],[0,1],[1,0],[1,1]],De=Be.concat([[0,.5],[.5,0],[1,.5],[.5,1]]),Ne=De.concat([[.25,.5],[.75,.5]]);class Ge{constructor(e,t,i){(0,n.Z)(this,"x",void 0),(0,n.Z)(this,"y",void 0),(0,n.Z)(this,"z",void 0),(0,n.Z)(this,"childVisible",void 0),(0,n.Z)(this,"selected",void 0),(0,n.Z)(this,"_children",void 0),this.x=e,this.y=t,this.z=i}get children(){if(!this._children){const e=2*this.x,t=2*this.y,i=this.z+1;this._children=[new Ge(e,t,i),new Ge(e,t+1,i),new Ge(e+1,t,i),new Ge(e+1,t+1,i)]}return this._children}update(e){const{viewport:t,cullingVolume:i,elevationBounds:n,minZ:o,maxZ:s,bounds:r,offset:a,project:l}=e,c=this.getBoundingVolume(n,a,l);if(r&&!this.insideBounds(r))return!1;const d=i.computeVisibility(c);if(d<0)return!1;if(!this.childVisible){let{z:e}=this;if(e<s&&e>=o){const i=c.distanceTo(t.cameraPosition)*t.scale/t.height;e+=Math.floor(Math.log2(i))}if(e>=s)return this.selected=!0,!0}this.selected=!1,this.childVisible=!0;for(const u of this.children)u.update(e);return!0}getSelected(e=[]){if(this.selected&&e.push(this),this._children)for(const t of this._children)t.getSelected(e);return e}insideBounds([e,t,i,n]){const o=Math.pow(2,this.z),s=ke/o;return this.x*s<i&&this.y*s<n&&(this.x+1)*s>e&&(this.y+1)*s>t}getBoundingVolume(e,t,i){if(i){const t=this.z<1?Ne:this.z<2?De:Be,n=[];for(const o of t){const t=tt(this.x+o[0],this.y+o[1],this.z);t[2]=e[0],n.push(i(t)),e[0]!==e[1]&&(t[2]=e[1],n.push(i(t)))}return(0,Re.du)(n)}const n=Math.pow(2,this.z),o=ke/n,s=this.x*o+t*ke,r=ke-(this.y+1)*o;return new Re.Xx([s,r,e[0]],[s+o,r+o,e[1]])}}function Ue(e,t,i,n){const o=e instanceof Ee.Z&&e.resolution?e.projectPosition:null,s=Object.values(e.getFrustumPlanes()).map((({normal:e,distance:t})=>new Re.JO(e.clone().negate(),t))),r=new Re.Mh(s),a=e.distanceScales.unitsPerMeter[2],l=i&&i[0]*a||0,c=i&&i[1]*a||0,d=e instanceof Fe.Z&&e.pitch<=60?t:0;if(n){const[e,t,i,o]=n,s=(0,Ze.w5)([e,o]),r=(0,Ze.w5)([i,t]);n=[s[0],ke-s[1],r[0],ke-r[1]]}const u=new Ge(0,0,0),h={viewport:e,project:o,cullingVolume:r,elevationBounds:[l,c],minZ:d,maxZ:t,bounds:n,offset:0};if(u.update(h),e instanceof Fe.Z&&e.subViewports&&e.subViewports.length>1){h.offset=-1;while(u.update(h))if(--h.offset<-We)break;h.offset=1;while(u.update(h))if(++h.offset>We)break}return u.getSelected()}const je=512,Ve=[-1/0,-1/0,1/0,1/0],He={type:"object",value:null,validate:(e,t)=>t.optional&&null===e||"string"===typeof e||Array.isArray(e)&&e.every((e=>"string"===typeof e)),equal:(e,t)=>{if(e===t)return!0;if(!Array.isArray(e)||!Array.isArray(t))return!1;const i=e.length;if(i!==t.length)return!1;for(let n=0;n<i;n++)if(e[n]!==t[n])return!1;return!0}};function Ke(e,t){const i=[t.transformAsPoint([e[0],e[1]]),t.transformAsPoint([e[2],e[1]]),t.transformAsPoint([e[0],e[3]]),t.transformAsPoint([e[2],e[3]])],n=[Math.min(...i.map((e=>e[0]))),Math.min(...i.map((e=>e[1]))),Math.max(...i.map((e=>e[0]))),Math.max(...i.map((e=>e[1])))];return n}function Je(e){return Math.abs(e.split("").reduce(((e,t)=>(e<<5)-e+t.charCodeAt(0)|0),0))}function qe(e,t){if(!e||!e.length)return null;const{index:i,id:n}=t;if(Array.isArray(e)){const t=Je(n)%e.length;e=e[t]}let o=e;for(const s of Object.keys(i)){const e=new RegExp("{".concat(s,"}"),"g");o=o.replace(e,String(i[s]))}return Number.isInteger(i.y)&&Number.isInteger(i.z)&&(o=o.replace(/\{-y\}/g,String(Math.pow(2,i.z)-i.y-1))),o}function Xe(e,t,i){let n;if(t&&2===t.length){const[i,o]=t,s=e.getBounds({z:i}),r=e.getBounds({z:o});n=[Math.min(s[0],r[0]),Math.min(s[1],r[1]),Math.max(s[2],r[2]),Math.max(s[3],r[3])]}else n=e.getBounds();return e.isGeospatial?[Math.max(n[0],i[0]),Math.max(n[1],i[1]),Math.min(n[2],i[2]),Math.min(n[3],i[3])]:[Math.max(Math.min(n[0],i[2]),i[0]),Math.max(Math.min(n[1],i[3]),i[1]),Math.min(Math.max(n[2],i[0]),i[2]),Math.min(Math.max(n[3],i[1]),i[3])]}function Ye({viewport:e,z:t=0,cullRect:i}){const n=e.subViewports||[e];return n.map((e=>Qe(e,t,i)))}function Qe(e,t,i){if(!Array.isArray(t)){const n=i.x-e.x,o=i.y-e.y,{width:s,height:r}=i,a={targetZ:t},l=e.unproject([n,o],a),c=e.unproject([n+s,o],a),d=e.unproject([n,o+r],a),u=e.unproject([n+s,o+r],a);return[Math.min(l[0],c[0],d[0],u[0]),Math.min(l[1],c[1],d[1],u[1]),Math.max(l[0],c[0],d[0],u[0]),Math.max(l[1],c[1],d[1],u[1])]}const n=Qe(e,t[0],i),o=Qe(e,t[1],i);return[Math.min(n[0],o[0]),Math.min(n[1],o[1]),Math.max(n[2],o[2]),Math.max(n[3],o[3])]}function $e(e,t,i){if(i){const n=Ke(e,i).map((e=>e*t/je));return n}return e.map((e=>e*t/je))}function et(e,t){return Math.pow(2,e)*je/t}function tt(e,t,i){const n=et(i,je),o=e/n*360-180,s=Math.PI-2*Math.PI*t/n,r=180/Math.PI*Math.atan(.5*(Math.exp(s)-Math.exp(-s)));return[o,r]}function it(e,t,i,n){const o=et(i,n);return[e/o*je,t/o*je]}function nt(e,t,i,n,o=je){if(e.isGeospatial){const[e,o]=tt(t,i,n),[s,r]=tt(t+1,i+1,n);return{west:e,north:o,east:s,south:r}}const[s,r]=it(t,i,n,o),[a,l]=it(t+1,i+1,n,o);return{left:s,top:r,right:a,bottom:l}}function ot(e,t,i,n,o){const s=Xe(e,null,n),r=et(t,i),[a,l,c,d]=$e(s,r,o),u=[];for(let h=Math.floor(a);h<c;h++)for(let e=Math.floor(l);e<d;e++)u.push({x:h,y:e,z:t});return u}function st({viewport:e,maxZoom:t,minZoom:i,zRange:n,extent:o,tileSize:s=je,modelMatrix:r,modelMatrixInverse:a,zoomOffset:l=0}){let c=e.isGeospatial?Math.round(e.zoom+Math.log2(je/s))+l:Math.ceil(e.zoom)+l;if("number"===typeof i&&Number.isFinite(i)&&c<i){if(!o)return[];c=i}"number"===typeof t&&Number.isFinite(t)&&c>t&&(c=t);let d=o;return r&&a&&o&&!e.isGeospatial&&(d=Ke(o,r)),e.isGeospatial?Ue(e,c,n,o):ot(e,c,s,d||Ve,a)}function rt(e){let t,i={};return n=>{for(const o in n)if(!at(n[o],i[o])){t=e(n),i=n;break}return t}}function at(e,t){if(e===t)return!0;if(Array.isArray(e)){const i=e.length;if(!t||t.length!==i)return!1;for(let n=0;n<i;n++)if(e[n]!==t[n])return!1;return!0}return!1}const lt=1,ct=2,dt="never",ut="no-overlap",ht="best-available",gt=5,pt={[ht]:vt,[ut]:yt,[dt]:()=>{}},ft={extent:null,tileSize:512,maxZoom:null,minZoom:null,maxCacheSize:null,maxCacheByteSize:null,refinementStrategy:"best-available",zRange:null,maxRequests:6,zoomOffset:0,onTileLoad:()=>{},onTileUnload:()=>{},onTileError:()=>{}};class mt{constructor(e){(0,n.Z)(this,"opts",void 0),(0,n.Z)(this,"_requestScheduler",void 0),(0,n.Z)(this,"_cache",void 0),(0,n.Z)(this,"_dirty",void 0),(0,n.Z)(this,"_tiles",void 0),(0,n.Z)(this,"_cacheByteSize",void 0),(0,n.Z)(this,"_viewport",void 0),(0,n.Z)(this,"_zRange",void 0),(0,n.Z)(this,"_selectedTiles",void 0),(0,n.Z)(this,"_frameNumber",void 0),(0,n.Z)(this,"_modelMatrix",void 0),(0,n.Z)(this,"_modelMatrixInverse",void 0),(0,n.Z)(this,"_maxZoom",void 0),(0,n.Z)(this,"_minZoom",void 0),(0,n.Z)(this,"onTileLoad",void 0),(0,n.Z)(this,"_getCullBounds",rt(Ye)),this.opts={...ft,...e},this.onTileLoad=e=>{var t,i;null===(t=(i=this.opts).onTileLoad)||void 0===t||t.call(i,e),this.opts.maxCacheByteSize&&(this._cacheByteSize+=e.byteLength,this._resizeCache())},this._requestScheduler=new Me.Z({maxRequests:e.maxRequests,throttleRequests:Boolean(e.maxRequests&&e.maxRequests>0)}),this._cache=new Map,this._tiles=[],this._dirty=!1,this._cacheByteSize=0,this._viewport=null,this._selectedTiles=null,this._frameNumber=0,this._modelMatrix=new Ae.Z,this._modelMatrixInverse=new Ae.Z,this.setOptions(e)}get tiles(){return this._tiles}get selectedTiles(){return this._selectedTiles}get isLoaded(){return null!==this._selectedTiles&&this._selectedTiles.every((e=>e.isLoaded))}get needsReload(){return null!==this._selectedTiles&&this._selectedTiles.some((e=>e.needsReload))}setOptions(e){Object.assign(this.opts,e),Number.isFinite(e.maxZoom)&&(this._maxZoom=Math.floor(e.maxZoom)),Number.isFinite(e.minZoom)&&(this._minZoom=Math.ceil(e.minZoom))}finalize(){for(const e of this._cache.values())e.isLoading&&e.abort();this._cache.clear(),this._tiles=[],this._selectedTiles=null}reloadAll(){for(const e of this._cache.keys()){const t=this._cache.get(e);this._selectedTiles&&this._selectedTiles.includes(t)?t.setNeedsReload():this._cache.delete(e)}}update(e,{zRange:t,modelMatrix:i}={}){const n=new Ae.Z(i),o=!n.equals(this._modelMatrix);if(this._viewport&&e.equals(this._viewport)&&(0,Ie.fS)(this._zRange,t)&&!o)this.needsReload&&(this._selectedTiles=this._selectedTiles.map((e=>this._getTile(e.index,!0))));else{o&&(this._modelMatrixInverse=n.clone().invert(),this._modelMatrix=n),this._viewport=e,this._zRange=t;const i=this.getTileIndices({viewport:e,maxZoom:this._maxZoom,minZoom:this._minZoom,zRange:t,modelMatrix:this._modelMatrix,modelMatrixInverse:this._modelMatrixInverse});this._selectedTiles=i.map((e=>this._getTile(e,!0))),this._dirty&&this._rebuildTree()}const s=this.updateTileStates();return this._pruneRequests(),this._dirty&&this._resizeCache(),s&&this._frameNumber++,this._frameNumber}isTileVisible(e,t){if(!e.isVisible)return!1;if(t&&this._viewport){const i=this._getCullBounds({viewport:this._viewport,z:this._zRange,cullRect:t}),{bbox:n}=e;for(const[e,t,o,s]of i){let i;if("west"in n)i=n.west<o&&n.east>e&&n.south<s&&n.north>t;else{const r=Math.min(n.top,n.bottom),a=Math.max(n.top,n.bottom);i=n.left<o&&n.right>e&&r<s&&a>t}if(i)return!0}return!1}return!0}getTileIndices({viewport:e,maxZoom:t,minZoom:i,zRange:n,modelMatrix:o,modelMatrixInverse:s}){const{tileSize:r,extent:a,zoomOffset:l}=this.opts;return st({viewport:e,maxZoom:t,minZoom:i,zRange:n,tileSize:r,extent:a,modelMatrix:o,modelMatrixInverse:s,zoomOffset:l})}getTileId(e){return"".concat(e.x,"-").concat(e.y,"-").concat(e.z)}getTileZoom(e){return e.z}getTileMetadata(e){const{tileSize:t}=this.opts;return{bbox:nt(this._viewport,e.x,e.y,e.z,t)}}getParentIndex(e){const t=Math.floor(e.x/2),i=Math.floor(e.y/2),n=e.z-1;return{x:t,y:i,z:n}}updateTileStates(){const e=this.opts.refinementStrategy||ht,t=new Array(this._cache.size);let i=0;for(const n of this._cache.values())t[i++]=n.isVisible,n.isSelected=!1,n.isVisible=!1;for(const n of this._selectedTiles)n.isSelected=!0,n.isVisible=!0;("function"===typeof e?e:pt[e])(Array.from(this._cache.values())),i=0;for(const n of this._cache.values())if(t[i++]!==n.isVisible)return!0;return!1}_pruneRequests(){const{maxRequests:e=0}=this.opts,t=[];let i=0;for(const n of this._cache.values())n.isLoading&&(i++,n.isSelected||n.isVisible||t.push(n));while(e>0&&i>e&&t.length>0){const e=t.shift();e.abort(),i--}}_rebuildTree(){const{_cache:e}=this;for(const t of e.values())t.parent=null,t.children&&(t.children.length=0);for(const t of e.values()){const e=this._getNearestAncestor(t);t.parent=e,null!==e&&void 0!==e&&e.children&&e.children.push(t)}}_resizeCache(){const{_cache:e,opts:t}=this,i=t.maxCacheSize||(t.maxCacheByteSize?1/0:gt*this.selectedTiles.length),n=t.maxCacheByteSize||1/0,o=e.size>i||this._cacheByteSize>n;if(o){for(const[o,a]of e){var s,r;if(!a.isVisible&&!a.isSelected)this._cacheByteSize-=t.maxCacheByteSize?a.byteLength:0,e.delete(o),null===(s=(r=this.opts).onTileUnload)||void 0===s||s.call(r,a);if(e.size<=i&&this._cacheByteSize<=n)break}this._rebuildTree(),this._dirty=!0}this._dirty&&(this._tiles=Array.from(this._cache.values()).sort(((e,t)=>e.zoom-t.zoom)),this._dirty=!1)}_getTile(e,t){const i=this.getTileId(e);let n=this._cache.get(i),o=!1;return!n&&t?(n=new Oe(e),Object.assign(n,this.getTileMetadata(n.index)),Object.assign(n,{id:i,zoom:this.getTileZoom(n.index)}),o=!0,this._cache.set(i,n),this._dirty=!0):n&&n.needsReload&&(o=!0),n&&o&&n.loadData({getData:this.opts.getTileData,requestScheduler:this._requestScheduler,onLoad:this.onTileLoad,onError:this.opts.onTileError}),n}_getNearestAncestor(e){const{_minZoom:t=0}=this;let i=e.index;while(this.getTileZoom(i)>t){i=this.getParentIndex(i);const e=this._getTile(i);if(e)return e}return null}}function vt(e){for(const t of e)t.state=0;for(const t of e)t.isSelected&&!xt(t)&&_t(t);for(const t of e)t.isVisible=Boolean(t.state&ct)}function yt(e){for(const i of e)i.state=0;for(const i of e)i.isSelected&&xt(i);const t=Array.from(e).sort(((e,t)=>e.zoom-t.zoom));for(const i of t)if(i.isVisible=Boolean(i.state&ct),i.children&&(i.isVisible||i.state&lt))for(const e of i.children)e.state=lt;else i.isSelected&&_t(i)}function xt(e){let t=e;while(t){if(t.isLoaded||t.content)return t.state|=ct,!0;t=t.parent}return!1}function _t(e){for(const t of e.children)t.isLoaded||t.content?t.state|=ct:_t(t)}const Pt={TilesetClass:mt,data:{type:"data",value:[]},dataComparator:He.equal,renderSubLayers:{type:"function",value:e=>new Te(e)},getTileData:{type:"function",optional:!0,value:null},onViewportLoad:{type:"function",optional:!0,value:null},onTileLoad:{type:"function",value:e=>{}},onTileUnload:{type:"function",value:e=>{}},onTileError:{type:"function",value:e=>console.error(e)},extent:{type:"array",optional:!0,value:null,compare:!0},tileSize:512,maxZoom:null,minZoom:0,maxCacheSize:null,maxCacheByteSize:null,refinementStrategy:ht,zRange:null,maxRequests:6,zoomOffset:0};class Ct extends o.Z{initializeState(){this.state={tileset:null,isLoaded:!1}}finalizeState(){var e,t;null===(e=this.state)||void 0===e||null===(t=e.tileset)||void 0===t||t.finalize()}get isLoaded(){var e,t;return null===(e=this.state)||void 0===e||null===(t=e.tileset)||void 0===t?void 0:t.selectedTiles.every((e=>e.isLoaded&&e.layers&&e.layers.every((e=>e.isLoaded))))}shouldUpdateState({changeFlags:e}){return e.somethingChanged}updateState({changeFlags:e}){let{tileset:t}=this.state;const i=e.propsOrDataChanged||e.updateTriggersChanged,n=e.dataChanged||e.updateTriggersChanged&&(e.updateTriggersChanged.all||e.updateTriggersChanged.getTileData);t?i&&(t.setOptions(this._getTilesetOptions()),n?t.reloadAll():this.state.tileset.tiles.forEach((e=>{e.layers=null}))):(t=new this.props.TilesetClass(this._getTilesetOptions()),this.setState({tileset:t})),this._updateTileset()}_getTilesetOptions(){const{tileSize:e,maxCacheSize:t,maxCacheByteSize:i,refinementStrategy:n,extent:o,maxZoom:s,minZoom:r,maxRequests:a,zoomOffset:l}=this.props;return{maxCacheSize:t,maxCacheByteSize:i,maxZoom:s,minZoom:r,tileSize:e,refinementStrategy:n,extent:o,maxRequests:a,zoomOffset:l,getTileData:this.getTileData.bind(this),onTileLoad:this._onTileLoad.bind(this),onTileError:this._onTileError.bind(this),onTileUnload:this._onTileUnload.bind(this)}}_updateTileset(){const{tileset:e}=this.state,{zRange:t,modelMatrix:i}=this.props,n=e.update(this.context.viewport,{zRange:t,modelMatrix:i}),{isLoaded:o}=e,s=this.state.isLoaded!==o,r=this.state.frameNumber!==n;o&&(s||r)&&this._onViewportLoad(),r&&this.setState({frameNumber:n}),this.state.isLoaded=o}_onViewportLoad(){const{tileset:e}=this.state,{onViewportLoad:t}=this.props;t&&t(e.selectedTiles)}_onTileLoad(e){this.props.onTileLoad(e),e.layers=null,this.setNeedsUpdate()}_onTileError(e,t){this.props.onTileError(e),t.layers=null,this.setNeedsUpdate()}_onTileUnload(e){this.props.onTileUnload(e)}getTileData(e){const{data:t,getTileData:i,fetch:n}=this.props,{signal:o}=e;return e.url="string"===typeof t||Array.isArray(t)?qe(t,e):null,i?i(e):n&&e.url?n(e.url,{propName:"data",layer:this,signal:o}):null}renderSubLayers(e){return this.props.renderSubLayers(e)}getSubLayerPropsByTile(e){return null}getPickingInfo({info:e,sourceLayer:t}){const i=t.props.tile;return e.picked&&(e.tile=i),e.sourceTile=i,e}_updateAutoHighlight(e){const t=e.sourceTile;if(t&&t.layers)for(const i of t.layers)i.updateAutoHighlight(e)}renderLayers(){return this.state.tileset.tiles.map((e=>{const t=this.getSubLayerPropsByTile(e);if(e.isLoaded||e.content)if(e.layers)t&&e.layers[0]&&Object.keys(t).some((i=>e.layers[0].props[i]!==t[i]))&&(e.layers=e.layers.map((e=>e.clone(t))));else{const i=this.renderSubLayers({...this.props,id:"".concat(this.id,"-").concat(e.id),data:e.content,_offset:0,tile:e});e.layers=(0,s.x)(i,Boolean).map((i=>i.clone({tile:e,...t})))}else;return e.layers}))}filterSubLayer({layer:e,cullRect:t}){const{tile:i}=e.props;return this.state.tileset.isTileVisible(i,t)}}(0,n.Z)(Ct,"defaultProps",Pt),(0,n.Z)(Ct,"layerName","TileLayer")},13863:function(e,t,i){i.d(t,{Z:function(){return P}});var n=i(82482),o=i(24088),s=i(52447),r=i(93844),a=i(43844),l=i(80210),c=i(53982),d=i(78866),u=i(14034);const h=new Uint16Array([0,2,1,0,3,2]),g=new Float32Array([0,1,0,0,1,0,1,1]);function p(e,t){if(!t)return f(e);const i=Math.max(Math.abs(e[0][0]-e[3][0]),Math.abs(e[1][0]-e[2][0])),n=Math.max(Math.abs(e[1][1]-e[0][1]),Math.abs(e[2][1]-e[3][1])),o=Math.ceil(i/t)+1,s=Math.ceil(n/t)+1,r=(o-1)*(s-1)*6,a=new Uint32Array(r),l=new Float32Array(o*s*2),c=new Float64Array(o*s*3);let d=0,u=0;for(let h=0;h<o;h++){const t=h/(o-1);for(let i=0;i<s;i++){const n=i/(s-1),o=m(e,t,n);c[3*d+0]=o[0],c[3*d+1]=o[1],c[3*d+2]=o[2]||0,l[2*d+0]=t,l[2*d+1]=1-n,h>0&&i>0&&(a[u++]=d-s,a[u++]=d-s-1,a[u++]=d-1,a[u++]=d-s,a[u++]=d-1,a[u++]=d),d++}}return{vertexCount:r,positions:c,indices:a,texCoords:l}}function f(e){const t=new Float64Array(12);for(let i=0;i<e.length;i++)t[3*i+0]=e[i][0],t[3*i+1]=e[i][1],t[3*i+2]=e[i][2]||0;return{vertexCount:6,positions:t,indices:h,texCoords:g}}function m(e,t,i){return(0,u.t7)((0,u.t7)(e[0],e[1],i),(0,u.t7)(e[3],e[2],i),t)}var v="\n#define SHADER_NAME bitmap-layer-vertex-shader\n\nattribute vec2 texCoords;\nattribute vec3 positions;\nattribute vec3 positions64Low;\n\nvarying vec2 vTexCoord;\nvarying vec2 vTexPos;\n\nuniform float coordinateConversion;\n\nconst vec3 pickingColor = vec3(1.0, 0.0, 0.0);\n\nvoid main(void) {\n  geometry.worldPosition = positions;\n  geometry.uv = texCoords;\n  geometry.pickingColor = pickingColor;\n\n  gl_Position = project_position_to_clipspace(positions, positions64Low, vec3(0.0), geometry.position);\n  DECKGL_FILTER_GL_POSITION(gl_Position, geometry);\n\n  vTexCoord = texCoords;\n\n  if (coordinateConversion < -0.5) {\n    vTexPos = geometry.position.xy + project_uCommonOrigin.xy;\n  } else if (coordinateConversion > 0.5) {\n    vTexPos = geometry.worldPosition.xy;\n  }\n\n  vec4 color = vec4(0.0);\n  DECKGL_FILTER_COLOR(color, geometry);\n}\n";const y="\nvec3 packUVsIntoRGB(vec2 uv) {\n  // Extract the top 8 bits. We want values to be truncated down so we can add a fraction\n  vec2 uv8bit = floor(uv * 256.);\n\n  // Calculate the normalized remainders of u and v parts that do not fit into 8 bits\n  // Scale and clamp to 0-1 range\n  vec2 uvFraction = fract(uv * 256.);\n  vec2 uvFraction4bit = floor(uvFraction * 16.);\n\n  // Remainder can be encoded in blue channel, encode as 4 bits for pixel coordinates\n  float fractions = uvFraction4bit.x + uvFraction4bit.y * 16.;\n\n  return vec3(uv8bit, fractions) / 255.;\n}\n";var x="\n#define SHADER_NAME bitmap-layer-fragment-shader\n\n#ifdef GL_ES\nprecision highp float;\n#endif\n\nuniform sampler2D bitmapTexture;\n\nvarying vec2 vTexCoord;\nvarying vec2 vTexPos;\n\nuniform float desaturate;\nuniform vec4 transparentColor;\nuniform vec3 tintColor;\nuniform float opacity;\n\nuniform float coordinateConversion;\nuniform vec4 bounds;\n\n/* projection utils */\nconst float TILE_SIZE = 512.0;\nconst float PI = 3.1415926536;\nconst float WORLD_SCALE = TILE_SIZE / PI / 2.0;\n\n// from degrees to Web Mercator\nvec2 lnglat_to_mercator(vec2 lnglat) {\n  float x = lnglat.x;\n  float y = clamp(lnglat.y, -89.9, 89.9);\n  return vec2(\n    radians(x) + PI,\n    PI + log(tan(PI * 0.25 + radians(y) * 0.5))\n  ) * WORLD_SCALE;\n}\n\n// from Web Mercator to degrees\nvec2 mercator_to_lnglat(vec2 xy) {\n  xy /= WORLD_SCALE;\n  return degrees(vec2(\n    xy.x - PI,\n    atan(exp(xy.y - PI)) * 2.0 - PI * 0.5\n  ));\n}\n/* End projection utils */\n\n// apply desaturation\nvec3 color_desaturate(vec3 color) {\n  float luminance = (color.r + color.g + color.b) * 0.333333333;\n  return mix(color, vec3(luminance), desaturate);\n}\n\n// apply tint\nvec3 color_tint(vec3 color) {\n  return color * tintColor;\n}\n\n// blend with background color\nvec4 apply_opacity(vec3 color, float alpha) {\n  if (transparentColor.a == 0.0) {\n    return vec4(color, alpha);\n  }\n  float blendedAlpha = alpha + transparentColor.a * (1.0 - alpha);\n  float highLightRatio = alpha / blendedAlpha;\n  vec3 blendedRGB = mix(transparentColor.rgb, color, highLightRatio);\n  return vec4(blendedRGB, blendedAlpha);\n}\n\nvec2 getUV(vec2 pos) {\n  return vec2(\n    (pos.x - bounds[0]) / (bounds[2] - bounds[0]),\n    (pos.y - bounds[3]) / (bounds[1] - bounds[3])\n  );\n}\n\n".concat(y,"\n\nvoid main(void) {\n  vec2 uv = vTexCoord;\n  if (coordinateConversion < -0.5) {\n    vec2 lnglat = mercator_to_lnglat(vTexPos);\n    uv = getUV(lnglat);\n  } else if (coordinateConversion > 0.5) {\n    vec2 commonPos = lnglat_to_mercator(vTexPos);\n    uv = getUV(commonPos);\n  }\n  vec4 bitmapColor = texture2D(bitmapTexture, uv);\n\n  gl_FragColor = apply_opacity(color_tint(color_desaturate(bitmapColor.rgb)), bitmapColor.a * opacity);\n\n  geometry.uv = uv;\n  DECKGL_FILTER_COLOR(gl_FragColor, geometry);\n\n  if (picking_uActive && !picking_uAttribute) {\n    // Since instance information is not used, we can use picking color for pixel index\n    gl_FragColor.rgb = packUVsIntoRGB(uv);\n  }\n}\n");const _={image:{type:"image",value:null,async:!0},bounds:{type:"array",value:[1,0,0,1],compare:!0},_imageCoordinateSystem:o.Df.DEFAULT,desaturate:{type:"number",min:0,max:1,value:0},transparentColor:{type:"color",value:[0,0,0,0]},tintColor:{type:"color",value:[255,255,255]},textureParameters:{type:"object",ignore:!0}};class P extends s.Z{constructor(...e){super(...e),(0,n.Z)(this,"state",void 0)}getShaders(){return super.getShaders({vs:v,fs:x,modules:[r.Z,a.Z]})}initializeState(){const e=this.getAttributeManager();e.remove(["instancePickingColors"]);const t=!0;e.add({indices:{size:1,isIndexed:!0,update:e=>e.value=this.state.mesh.indices,noAlloc:t},positions:{size:3,type:5130,fp64:this.use64bitPositions(),update:e=>e.value=this.state.mesh.positions,noAlloc:t},texCoords:{size:2,update:e=>e.value=this.state.mesh.texCoords,noAlloc:t}})}updateState({props:e,oldProps:t,changeFlags:i}){const n=this.getAttributeManager();if(i.extensionsChanged){var o;const{gl:e}=this.context;null===(o=this.state.model)||void 0===o||o.delete(),this.state.model=this._getModel(e),n.invalidateAll()}if(e.bounds!==t.bounds){const e=this.state.mesh,t=this._createMesh();this.state.model.setVertexCount(t.vertexCount);for(const i in t)e&&e[i]!==t[i]&&n.invalidate(i);this.setState({mesh:t,...this._getCoordinateUniforms()})}else e._imageCoordinateSystem!==t._imageCoordinateSystem&&this.setState(this._getCoordinateUniforms())}getPickingInfo(e){const{image:t}=this.props,i=e.info;if(!i.color||!t)return i.bitmap=null,i;const{width:n,height:o}=t;i.index=0;const s=C(i.color),r=[Math.floor(s[0]*n),Math.floor(s[1]*o)];return i.bitmap={size:{width:n,height:o},uv:s,pixel:r},i}disablePickingIndex(){this.setState({disablePicking:!0})}restorePickingColors(){this.setState({disablePicking:!1})}_updateAutoHighlight(e){super._updateAutoHighlight({...e,color:this.encodePickingColor(0)})}_createMesh(){const{bounds:e}=this.props;let t=e;return b(e)&&(t=[[e[0],e[1]],[e[0],e[3]],[e[2],e[3]],[e[2],e[1]]]),p(t,this.context.viewport.resolution)}_getModel(e){return e?new l.Z(e,{...this.getShaders(),id:this.props.id,geometry:new c.Z({drawMode:4,vertexCount:6}),isInstanced:!1}):null}draw(e){const{uniforms:t,moduleParameters:i}=e,{model:n,coordinateConversion:o,bounds:s,disablePicking:r}=this.state,{image:a,desaturate:l,transparentColor:c,tintColor:d}=this.props;i.pickingActive&&r||a&&n&&n.setUniforms(t).setUniforms({bitmapTexture:a,desaturate:l,transparentColor:c.map((e=>e/255)),tintColor:d.slice(0,3).map((e=>e/255)),coordinateConversion:o,bounds:s}).draw()}_getCoordinateUniforms(){const{LNGLAT:e,CARTESIAN:t,DEFAULT:i}=o.Df;let{_imageCoordinateSystem:n}=this.props;if(n!==i){const{bounds:i}=this.props;if(!b(i))throw new Error("_imageCoordinateSystem only supports rectangular bounds");const o=this.context.viewport.resolution?e:t;if(n=n===e?e:t,n===e&&o===t)return{coordinateConversion:-1,bounds:i};if(n===t&&o===e){const e=(0,d.w5)([i[0],i[1]]),t=(0,d.w5)([i[2],i[3]]);return{coordinateConversion:1,bounds:[e[0],e[1],t[0],t[1]]}}}return{coordinateConversion:0,bounds:[0,0,0,0]}}}function C(e){const[t,i,n]=e,o=(240&n)/256,s=(15&n)/16;return[(t+s)/256,(i+o)/256]}function b(e){return Number.isFinite(e[0])}(0,n.Z)(P,"layerName","BitmapLayer"),(0,n.Z)(P,"defaultProps",_)},13418:function(e,t,i){i.d(t,{Z:function(){return I}});var n=i(82482),o=i(52447),s=i(93844),r=i(43844),a=i(24088),l=i(80744),c=i(80210),d=i(53982),u="#define SHADER_NAME icon-layer-vertex-shader\n\nattribute vec2 positions;\n\nattribute vec3 instancePositions;\nattribute vec3 instancePositions64Low;\nattribute float instanceSizes;\nattribute float instanceAngles;\nattribute vec4 instanceColors;\nattribute vec3 instancePickingColors;\nattribute vec4 instanceIconFrames;\nattribute float instanceColorModes;\nattribute vec2 instanceOffsets;\nattribute vec2 instancePixelOffset;\n\nuniform float sizeScale;\nuniform vec2 iconsTextureDim;\nuniform float sizeMinPixels;\nuniform float sizeMaxPixels;\nuniform bool billboard;\nuniform int sizeUnits;\n\nvarying float vColorMode;\nvarying vec4 vColor;\nvarying vec2 vTextureCoords;\nvarying vec2 uv;\n\nvec2 rotate_by_angle(vec2 vertex, float angle) {\n  float angle_radian = angle * PI / 180.0;\n  float cos_angle = cos(angle_radian);\n  float sin_angle = sin(angle_radian);\n  mat2 rotationMatrix = mat2(cos_angle, -sin_angle, sin_angle, cos_angle);\n  return rotationMatrix * vertex;\n}\n\nvoid main(void) {\n  geometry.worldPosition = instancePositions;\n  geometry.uv = positions;\n  geometry.pickingColor = instancePickingColors;\n  uv = positions;\n\n  vec2 iconSize = instanceIconFrames.zw;\n  float sizePixels = clamp(\n    project_size_to_pixel(instanceSizes * sizeScale, sizeUnits), \n    sizeMinPixels, sizeMaxPixels\n  );\n  float instanceScale = iconSize.y == 0.0 ? 0.0 : sizePixels / iconSize.y;\n  vec2 pixelOffset = positions / 2.0 * iconSize + instanceOffsets;\n  pixelOffset = rotate_by_angle(pixelOffset, instanceAngles) * instanceScale;\n  pixelOffset += instancePixelOffset;\n  pixelOffset.y *= -1.0;\n\n  if (billboard)  {\n    gl_Position = project_position_to_clipspace(instancePositions, instancePositions64Low, vec3(0.0), geometry.position);\n    DECKGL_FILTER_GL_POSITION(gl_Position, geometry);\n    vec3 offset = vec3(pixelOffset, 0.0);\n    DECKGL_FILTER_SIZE(offset, geometry);\n    gl_Position.xy += project_pixel_size_to_clipspace(offset.xy);\n\n  } else {\n    vec3 offset_common = vec3(project_pixel_size(pixelOffset), 0.0);\n    DECKGL_FILTER_SIZE(offset_common, geometry);\n    gl_Position = project_position_to_clipspace(instancePositions, instancePositions64Low, offset_common, geometry.position); \n    DECKGL_FILTER_GL_POSITION(gl_Position, geometry);\n  }\n\n  vTextureCoords = mix(\n    instanceIconFrames.xy,\n    instanceIconFrames.xy + iconSize,\n    (positions.xy + 1.0) / 2.0\n  ) / iconsTextureDim;\n\n  vColor = instanceColors;\n  DECKGL_FILTER_COLOR(vColor, geometry);\n\n  vColorMode = instanceColorModes;\n}\n",h="#define SHADER_NAME icon-layer-fragment-shader\n\nprecision highp float;\n\nuniform float opacity;\nuniform sampler2D iconsTexture;\nuniform float alphaCutoff;\n\nvarying float vColorMode;\nvarying vec4 vColor;\nvarying vec2 vTextureCoords;\nvarying vec2 uv;\n\nvoid main(void) {\n  geometry.uv = uv;\n\n  vec4 texColor = texture2D(iconsTexture, vTextureCoords);\n  vec3 color = mix(texColor.rgb, vColor.rgb, vColorMode);\n  float a = texColor.a * opacity * vColor.a;\n\n  if (a < alphaCutoff) {\n    discard;\n  }\n\n  gl_FragColor = vec4(color, a);\n  DECKGL_FILTER_COLOR(gl_FragColor, geometry);\n}\n",g=i(51621),p=i(81913),f=i(44534),m=i(38550);const v=1024,y=4,x=()=>{},_={[10241]:9987,[10240]:9729,[10242]:33071,[10243]:33071};function P(e){return Math.pow(2,Math.ceil(Math.log2(e)))}function C(e,t,i,n){const o=Math.min(i/t.width,n/t.height),s=Math.floor(t.width*o),r=Math.floor(t.height*o);return 1===o?{data:t,width:s,height:r}:(e.canvas.height=r,e.canvas.width=s,e.clearRect(0,0,s,r),e.drawImage(t,0,0,t.width,t.height,0,0,s,r),{data:e.canvas,width:s,height:r})}function b(e){return e&&(e.id||e.url)}function S(e,t,i,n){const o=e.width,s=e.height,r=new g.Z(e.gl,{width:t,height:i,parameters:n});return(0,p.Lv)(e,r,{targetY:0,width:o,height:s}),e.delete(),r}function L(e,t,i){for(let n=0;n<t.length;n++){const{icon:o,xOffset:s}=t[n],r=b(o);e[r]={...o,x:s,y:i}}}function w({icons:e,buffer:t,mapping:i={},xOffset:n=0,yOffset:o=0,rowHeight:s=0,canvasWidth:r}){let a=[];for(let l=0;l<e.length;l++){const c=e[l],d=b(c);if(!i[d]){const{height:e,width:l}=c;n+l+t>r&&(L(i,a,o),n=0,o=s+o+t,s=0,a=[]),a.push({icon:c,xOffset:n}),n=n+l+t,s=Math.max(s,e)}}return a.length>0&&L(i,a,o),{mapping:i,rowHeight:s,xOffset:n,yOffset:o,canvasWidth:r,canvasHeight:P(s+o+t)}}function z(e,t,i){if(!e||!t)return null;i=i||{};const n={},{iterable:o,objectInfo:s}=(0,m.jB)(e);for(const r of o){s.index++;const e=t(r,s),o=b(e);if(!e)throw new Error("Icon is missing.");if(!e.url)throw new Error("Icon url is missing.");n[o]||i[o]&&e.url===i[o].url||(n[o]={...e,source:r,sourceIndex:s.index})}return n}class T{constructor(e,{onUpdate:t=x,onError:i=x}){(0,n.Z)(this,"gl",void 0),(0,n.Z)(this,"onUpdate",void 0),(0,n.Z)(this,"onError",void 0),(0,n.Z)(this,"_loadOptions",null),(0,n.Z)(this,"_texture",null),(0,n.Z)(this,"_externalTexture",null),(0,n.Z)(this,"_mapping",{}),(0,n.Z)(this,"_textureParameters",null),(0,n.Z)(this,"_pendingCount",0),(0,n.Z)(this,"_autoPacking",!1),(0,n.Z)(this,"_xOffset",0),(0,n.Z)(this,"_yOffset",0),(0,n.Z)(this,"_rowHeight",0),(0,n.Z)(this,"_buffer",y),(0,n.Z)(this,"_canvasWidth",v),(0,n.Z)(this,"_canvasHeight",0),(0,n.Z)(this,"_canvas",null),this.gl=e,this.onUpdate=t,this.onError=i}finalize(){var e;null===(e=this._texture)||void 0===e||e.delete()}getTexture(){return this._texture||this._externalTexture}getIconMapping(e){const t=this._autoPacking?b(e):e;return this._mapping[t]||{}}setProps({loadOptions:e,autoPacking:t,iconAtlas:i,iconMapping:n,textureParameters:o}){var s;(e&&(this._loadOptions=e),void 0!==t&&(this._autoPacking=t),n&&(this._mapping=n),i)&&(null===(s=this._texture)||void 0===s||s.delete(),this._texture=null,this._externalTexture=i);o&&(this._textureParameters=o)}get isLoaded(){return 0===this._pendingCount}packIcons(e,t){if(!this._autoPacking||"undefined"===typeof document)return;const i=Object.values(z(e,t,this._mapping)||{});if(i.length>0){const{mapping:e,xOffset:t,yOffset:n,rowHeight:o,canvasHeight:s}=w({icons:i,buffer:this._buffer,canvasWidth:this._canvasWidth,mapping:this._mapping,rowHeight:this._rowHeight,xOffset:this._xOffset,yOffset:this._yOffset});this._rowHeight=o,this._mapping=e,this._xOffset=t,this._yOffset=n,this._canvasHeight=s,this._texture||(this._texture=new g.Z(this.gl,{width:this._canvasWidth,height:this._canvasHeight,parameters:this._textureParameters||_})),this._texture.height!==this._canvasHeight&&(this._texture=S(this._texture,this._canvasWidth,this._canvasHeight,this._textureParameters||_)),this.onUpdate(),this._canvas=this._canvas||document.createElement("canvas"),this._loadIcons(i)}}_loadIcons(e){const t=this._canvas.getContext("2d",{willReadFrequently:!0});for(const i of e)this._pendingCount++,(0,f.z)(i.url,this._loadOptions).then((e=>{const n=b(i),o=this._mapping[n],{x:s,y:r,width:a,height:l}=o,{data:c,width:d,height:u}=C(t,e,a,l);this._texture.setSubImageData({data:c,x:s+(a-d)/2,y:r+(l-u)/2,width:d,height:u}),o.width=d,o.height=u,this._texture.generateMipmap(),this.onUpdate()})).catch((e=>{this.onError({url:i.url,source:i.source,sourceIndex:i.sourceIndex,loadOptions:this._loadOptions,error:e})})).finally((()=>{this._pendingCount--}))}}const M=[0,0,0,255],A={iconAtlas:{type:"image",value:null,async:!0},iconMapping:{type:"object",value:{},async:!0},sizeScale:{type:"number",value:1,min:0},billboard:!0,sizeUnits:"pixels",sizeMinPixels:{type:"number",min:0,value:0},sizeMaxPixels:{type:"number",min:0,value:Number.MAX_SAFE_INTEGER},alphaCutoff:{type:"number",value:.05,min:0,max:1},getPosition:{type:"accessor",value:e=>e.position},getIcon:{type:"accessor",value:e=>e.icon},getColor:{type:"accessor",value:M},getSize:{type:"accessor",value:1},getAngle:{type:"accessor",value:0},getPixelOffset:{type:"accessor",value:[0,0]},onIconError:{type:"function",value:null,optional:!0},textureParameters:{type:"object",ignore:!0}};class I extends o.Z{constructor(...e){super(...e),(0,n.Z)(this,"state",void 0)}getShaders(){return super.getShaders({vs:u,fs:h,modules:[s.Z,r.Z]})}initializeState(){this.state={iconManager:new T(this.context.gl,{onUpdate:this._onUpdate.bind(this),onError:this._onError.bind(this)})};const e=this.getAttributeManager();e.addInstanced({instancePositions:{size:3,type:5130,fp64:this.use64bitPositions(),transition:!0,accessor:"getPosition"},instanceSizes:{size:1,transition:!0,accessor:"getSize",defaultValue:1},instanceOffsets:{size:2,accessor:"getIcon",transform:this.getInstanceOffset},instanceIconFrames:{size:4,accessor:"getIcon",transform:this.getInstanceIconFrame},instanceColorModes:{size:1,type:5121,accessor:"getIcon",transform:this.getInstanceColorMode},instanceColors:{size:this.props.colorFormat.length,type:5121,normalized:!0,transition:!0,accessor:"getColor",defaultValue:M},instanceAngles:{size:1,transition:!0,accessor:"getAngle"},instancePixelOffset:{size:2,transition:!0,accessor:"getPixelOffset"}})}updateState(e){super.updateState(e);const{props:t,oldProps:i,changeFlags:n}=e,o=this.getAttributeManager(),{iconAtlas:s,iconMapping:r,data:a,getIcon:l,textureParameters:c}=t,{iconManager:d}=this.state,u=s||this.internalState.isAsyncPropLoading("iconAtlas");if(d.setProps({loadOptions:t.loadOptions,autoPacking:!u,iconAtlas:s,iconMapping:u?r:null,textureParameters:c}),u?i.iconMapping!==t.iconMapping&&o.invalidate("getIcon"):(n.dataChanged||n.updateTriggersChanged&&(n.updateTriggersChanged.all||n.updateTriggersChanged.getIcon))&&d.packIcons(a,l),n.extensionsChanged){var h;const{gl:e}=this.context;null===(h=this.state.model)||void 0===h||h.delete(),this.state.model=this._getModel(e),o.invalidateAll()}}get isLoaded(){return super.isLoaded&&this.state.iconManager.isLoaded}finalizeState(e){super.finalizeState(e),this.state.iconManager.finalize()}draw({uniforms:e}){const{sizeScale:t,sizeMinPixels:i,sizeMaxPixels:n,sizeUnits:o,billboard:s,alphaCutoff:r}=this.props,{iconManager:l}=this.state,c=l.getTexture();c&&this.state.model.setUniforms(e).setUniforms({iconsTexture:c,iconsTextureDim:[c.width,c.height],sizeUnits:a.iI[o],sizeScale:t,sizeMinPixels:i,sizeMaxPixels:n,billboard:s,alphaCutoff:r}).draw()}_getModel(e){const t=[-1,-1,-1,1,1,1,1,-1];return new c.Z(e,{...this.getShaders(),id:this.props.id,geometry:new d.Z({drawMode:6,attributes:{positions:{size:2,value:new Float32Array(t)}}}),isInstanced:!0})}_onUpdate(){this.setNeedsRedraw()}_onError(e){var t;const i=null===(t=this.getCurrentLayer())||void 0===t?void 0:t.props.onIconError;i?i(e):l.Z.error(e.error.message)()}getInstanceOffset(e){const{width:t,height:i,anchorX:n=t/2,anchorY:o=i/2}=this.state.iconManager.getIconMapping(e);return[t/2-n,i/2-o]}getInstanceColorMode(e){const t=this.state.iconManager.getIconMapping(e);return t.mask?1:0}getInstanceIconFrame(e){const{x:t,y:i,width:n,height:o}=this.state.iconManager.getIconMapping(e);return[t,i,n,o]}}(0,n.Z)(I,"defaultProps",A),(0,n.Z)(I,"layerName","IconLayer")},41990:function(e,t,i){i.d(t,{Z:function(){return b}});var n=i(82482),o=i(52447),s=i(93844),r=i(43844),a=i(24088),l=i(80210),c=i(53982),d=i(28005),u=i(89513);function h(e,t,i,n){let o;if(Array.isArray(e[0])){const i=e.length*t;o=new Array(i);for(let n=0;n<e.length;n++)for(let i=0;i<t;i++)o[n*t+i]=e[n][i]||0}else o=e;return i?(0,u.dj)(o,{size:t,gridResolution:i}):n?(0,u.ct)(o,{size:t}):o}const g=1,p=2,f=4;class m extends d.Z{constructor(e){super({...e,attributes:{positions:{size:3,padding:18,initialize:!0,type:e.fp64?Float64Array:Float32Array},segmentTypes:{size:1,type:Uint8ClampedArray}}})}get(e){return this.attributes[e]}getGeometryFromBuffer(e){return this.normalize?super.getGeometryFromBuffer(e):null}normalizeGeometry(e){return this.normalize?h(e,this.positionSize,this.opts.resolution,this.opts.wrapLongitude):e}getGeometrySize(e){if(v(e)){let t=0;for(const i of e)t+=this.getGeometrySize(i);return t}const t=this.getPathLength(e);return t<2?0:this.isClosed(e)?t<3?0:t+2:t}updateGeometryAttributes(e,t){if(0!==t.geometrySize)if(e&&v(e))for(const i of e){const e=this.getGeometrySize(i);t.geometrySize=e,this.updateGeometryAttributes(i,t),t.vertexStart+=e}else this._updateSegmentTypes(e,t),this._updatePositions(e,t)}_updateSegmentTypes(e,t){const i=this.attributes.segmentTypes,n=!!e&&this.isClosed(e),{vertexStart:o,geometrySize:s}=t;i.fill(0,o,o+s),n?(i[o]=f,i[o+s-2]=f):(i[o]+=g,i[o+s-2]+=p),i[o+s-1]=f}_updatePositions(e,t){const{positions:i}=this.attributes;if(!i||!e)return;const{vertexStart:n,geometrySize:o}=t,s=new Array(3);for(let r=n,a=0;a<o;r++,a++)this.getPointOnPath(e,a,s),i[3*r]=s[0],i[3*r+1]=s[1],i[3*r+2]=s[2]}getPathLength(e){return e.length/this.positionSize}getPointOnPath(e,t,i=[]){const{positionSize:n}=this;t*n>=e.length&&(t+=1-e.length/n);const o=t*n;return i[0]=e[o],i[1]=e[o+1],i[2]=3===n&&e[o+2]||0,i}isClosed(e){if(!this.normalize)return Boolean(this.opts.loop);const{positionSize:t}=this,i=e.length-t;return e[0]===e[i]&&e[1]===e[i+1]&&(2===t||e[2]===e[i+2])}}function v(e){return Array.isArray(e[0])}var y="#define SHADER_NAME path-layer-vertex-shader\n\nattribute vec2 positions;\n\nattribute float instanceTypes;\nattribute vec3 instanceStartPositions;\nattribute vec3 instanceEndPositions;\nattribute vec3 instanceLeftPositions;\nattribute vec3 instanceRightPositions;\nattribute vec3 instanceLeftPositions64Low;\nattribute vec3 instanceStartPositions64Low;\nattribute vec3 instanceEndPositions64Low;\nattribute vec3 instanceRightPositions64Low;\nattribute float instanceStrokeWidths;\nattribute vec4 instanceColors;\nattribute vec3 instancePickingColors;\n\nuniform float widthScale;\nuniform float widthMinPixels;\nuniform float widthMaxPixels;\nuniform float jointType;\nuniform float capType;\nuniform float miterLimit;\nuniform bool billboard;\nuniform int widthUnits;\n\nuniform float opacity;\n\nvarying vec4 vColor;\nvarying vec2 vCornerOffset;\nvarying float vMiterLength;\nvarying vec2 vPathPosition;\nvarying float vPathLength;\nvarying float vJointType;\n\nconst float EPSILON = 0.001;\nconst vec3 ZERO_OFFSET = vec3(0.0);\n\nfloat flipIfTrue(bool flag) {\n  return -(float(flag) * 2. - 1.);\n}\nvec3 getLineJoinOffset(\n  vec3 prevPoint, vec3 currPoint, vec3 nextPoint,\n  vec2 width\n) {\n  bool isEnd = positions.x > 0.0;\n  float sideOfPath = positions.y;\n  float isJoint = float(sideOfPath == 0.0);\n\n  vec3 deltaA3 = (currPoint - prevPoint);\n  vec3 deltaB3 = (nextPoint - currPoint);\n\n  mat3 rotationMatrix;\n  bool needsRotation = !billboard && project_needs_rotation(currPoint, rotationMatrix);\n  if (needsRotation) {\n    deltaA3 = deltaA3 * rotationMatrix;\n    deltaB3 = deltaB3 * rotationMatrix;\n  }\n  vec2 deltaA = deltaA3.xy / width;\n  vec2 deltaB = deltaB3.xy / width;\n\n  float lenA = length(deltaA);\n  float lenB = length(deltaB);\n\n  vec2 dirA = lenA > 0. ? normalize(deltaA) : vec2(0.0, 0.0);\n  vec2 dirB = lenB > 0. ? normalize(deltaB) : vec2(0.0, 0.0);\n\n  vec2 perpA = vec2(-dirA.y, dirA.x);\n  vec2 perpB = vec2(-dirB.y, dirB.x);\n  vec2 tangent = dirA + dirB;\n  tangent = length(tangent) > 0. ? normalize(tangent) : perpA;\n  vec2 miterVec = vec2(-tangent.y, tangent.x);\n  vec2 dir = isEnd ? dirA : dirB;\n  vec2 perp = isEnd ? perpA : perpB;\n  float L = isEnd ? lenA : lenB;\n  float sinHalfA = abs(dot(miterVec, perp));\n  float cosHalfA = abs(dot(dirA, miterVec));\n  float turnDirection = flipIfTrue(dirA.x * dirB.y >= dirA.y * dirB.x);\n  float cornerPosition = sideOfPath * turnDirection;\n\n  float miterSize = 1.0 / max(sinHalfA, EPSILON);\n  miterSize = mix(\n    min(miterSize, max(lenA, lenB) / max(cosHalfA, EPSILON)),\n    miterSize,\n    step(0.0, cornerPosition)\n  );\n\n  vec2 offsetVec = mix(miterVec * miterSize, perp, step(0.5, cornerPosition))\n    * (sideOfPath + isJoint * turnDirection);\n  bool isStartCap = lenA == 0.0 || (!isEnd && (instanceTypes == 1.0 || instanceTypes == 3.0));\n  bool isEndCap = lenB == 0.0 || (isEnd && (instanceTypes == 2.0 || instanceTypes == 3.0));\n  bool isCap = isStartCap || isEndCap;\n  if (isCap) {\n    offsetVec = mix(perp * sideOfPath, dir * capType * 4.0 * flipIfTrue(isStartCap), isJoint);\n    vJointType = capType;\n  } else {\n    vJointType = jointType;\n  }\n  vPathLength = L;\n  vCornerOffset = offsetVec;\n  vMiterLength = dot(vCornerOffset, miterVec * turnDirection);\n  vMiterLength = isCap ? isJoint : vMiterLength;\n\n  vec2 offsetFromStartOfPath = vCornerOffset + deltaA * float(isEnd);\n  vPathPosition = vec2(\n    dot(offsetFromStartOfPath, perp),\n    dot(offsetFromStartOfPath, dir)\n  );\n  geometry.uv = vPathPosition;\n\n  float isValid = step(instanceTypes, 3.5);\n  vec3 offset = vec3(offsetVec * width * isValid, 0.0);\n\n  if (needsRotation) {\n    offset = rotationMatrix * offset;\n  }\n  return offset;\n}\nvoid clipLine(inout vec4 position, vec4 refPosition) {\n  if (position.w < EPSILON) {\n    float r = (EPSILON - refPosition.w) / (position.w - refPosition.w);\n    position = refPosition + (position - refPosition) * r;\n  }\n}\n\nvoid main() {\n  geometry.pickingColor = instancePickingColors;\n\n  vColor = vec4(instanceColors.rgb, instanceColors.a * opacity);\n\n  float isEnd = positions.x;\n\n  vec3 prevPosition = mix(instanceLeftPositions, instanceStartPositions, isEnd);\n  vec3 prevPosition64Low = mix(instanceLeftPositions64Low, instanceStartPositions64Low, isEnd);\n\n  vec3 currPosition = mix(instanceStartPositions, instanceEndPositions, isEnd);\n  vec3 currPosition64Low = mix(instanceStartPositions64Low, instanceEndPositions64Low, isEnd);\n\n  vec3 nextPosition = mix(instanceEndPositions, instanceRightPositions, isEnd);\n  vec3 nextPosition64Low = mix(instanceEndPositions64Low, instanceRightPositions64Low, isEnd);\n\n  geometry.worldPosition = currPosition;\n  vec2 widthPixels = vec2(clamp(\n    project_size_to_pixel(instanceStrokeWidths * widthScale, widthUnits),\n    widthMinPixels, widthMaxPixels) / 2.0);\n  vec3 width;\n\n  if (billboard) {\n    vec4 prevPositionScreen = project_position_to_clipspace(prevPosition, prevPosition64Low, ZERO_OFFSET);\n    vec4 currPositionScreen = project_position_to_clipspace(currPosition, currPosition64Low, ZERO_OFFSET, geometry.position);\n    vec4 nextPositionScreen = project_position_to_clipspace(nextPosition, nextPosition64Low, ZERO_OFFSET);\n\n    clipLine(prevPositionScreen, currPositionScreen);\n    clipLine(nextPositionScreen, currPositionScreen);\n    clipLine(currPositionScreen, mix(nextPositionScreen, prevPositionScreen, isEnd));\n\n    width = vec3(widthPixels, 0.0);\n    DECKGL_FILTER_SIZE(width, geometry);\n\n    vec3 offset = getLineJoinOffset(\n      prevPositionScreen.xyz / prevPositionScreen.w,\n      currPositionScreen.xyz / currPositionScreen.w,\n      nextPositionScreen.xyz / nextPositionScreen.w,\n      project_pixel_size_to_clipspace(width.xy)\n    );\n\n    DECKGL_FILTER_GL_POSITION(currPositionScreen, geometry);\n    gl_Position = vec4(currPositionScreen.xyz + offset * currPositionScreen.w, currPositionScreen.w);\n  } else {\n    prevPosition = project_position(prevPosition, prevPosition64Low);\n    currPosition = project_position(currPosition, currPosition64Low);\n    nextPosition = project_position(nextPosition, nextPosition64Low);\n\n    width = vec3(project_pixel_size(widthPixels), 0.0);\n    DECKGL_FILTER_SIZE(width, geometry);\n\n    vec3 offset = getLineJoinOffset(prevPosition, currPosition, nextPosition, width.xy);\n    geometry.position = vec4(currPosition + offset, 1.0);\n    gl_Position = project_common_position_to_clipspace(geometry.position);\n    DECKGL_FILTER_GL_POSITION(gl_Position, geometry);\n  }\n  DECKGL_FILTER_COLOR(vColor, geometry);\n}\n",x="#define SHADER_NAME path-layer-fragment-shader\n\nprecision highp float;\n\nuniform float miterLimit;\n\nvarying vec4 vColor;\nvarying vec2 vCornerOffset;\nvarying float vMiterLength;\nvarying vec2 vPathPosition;\nvarying float vPathLength;\nvarying float vJointType;\n\nvoid main(void) {\n  geometry.uv = vPathPosition;\n\n  if (vPathPosition.y < 0.0 || vPathPosition.y > vPathLength) {\n    if (vJointType > 0.5 && length(vCornerOffset) > 1.0) {\n      discard;\n    }\n    if (vJointType < 0.5 && vMiterLength > miterLimit + 1.0) {\n      discard;\n    }\n  }\n  gl_FragColor = vColor;\n\n  DECKGL_FILTER_COLOR(gl_FragColor, geometry);\n}\n";const _=[0,0,0,255],P={widthUnits:"meters",widthScale:{type:"number",min:0,value:1},widthMinPixels:{type:"number",min:0,value:0},widthMaxPixels:{type:"number",min:0,value:Number.MAX_SAFE_INTEGER},jointRounded:!1,capRounded:!1,miterLimit:{type:"number",min:0,value:4},billboard:!1,_pathType:null,getPath:{type:"accessor",value:e=>e.path},getColor:{type:"accessor",value:_},getWidth:{type:"accessor",value:1},rounded:{deprecatedFor:["jointRounded","capRounded"]}},C={enter:(e,t)=>t.length?t.subarray(t.length-e.length):e};class b extends o.Z{constructor(...e){super(...e),(0,n.Z)(this,"state",void 0)}getShaders(){return super.getShaders({vs:y,fs:x,modules:[s.Z,r.Z]})}get wrapLongitude(){return!1}initializeState(){const e=!0,t=this.getAttributeManager();t.addInstanced({positions:{size:3,vertexOffset:1,type:5130,fp64:this.use64bitPositions(),transition:C,accessor:"getPath",update:this.calculatePositions,noAlloc:e,shaderAttributes:{instanceLeftPositions:{vertexOffset:0},instanceStartPositions:{vertexOffset:1},instanceEndPositions:{vertexOffset:2},instanceRightPositions:{vertexOffset:3}}},instanceTypes:{size:1,type:5121,update:this.calculateSegmentTypes,noAlloc:e},instanceStrokeWidths:{size:1,accessor:"getWidth",transition:C,defaultValue:1},instanceColors:{size:this.props.colorFormat.length,type:5121,normalized:!0,accessor:"getColor",transition:C,defaultValue:_},instancePickingColors:{size:3,type:5121,accessor:(e,{index:t,target:i})=>this.encodePickingColor(e&&e.__source?e.__source.index:t,i)}}),this.setState({pathTesselator:new m({fp64:this.use64bitPositions()})})}updateState(e){super.updateState(e);const{props:t,changeFlags:i}=e,n=this.getAttributeManager(),o=i.dataChanged||i.updateTriggersChanged&&(i.updateTriggersChanged.all||i.updateTriggersChanged.getPath);if(o){const{pathTesselator:e}=this.state,o=t.data.attributes||{};e.updateGeometry({data:t.data,geometryBuffer:o.getPath,buffers:o,normalize:!t._pathType,loop:"loop"===t._pathType,getGeometry:t.getPath,positionFormat:t.positionFormat,wrapLongitude:t.wrapLongitude,resolution:this.context.viewport.resolution,dataChanged:i.dataChanged}),this.setState({numInstances:e.instanceCount,startIndices:e.vertexStarts}),i.dataChanged||n.invalidateAll()}if(i.extensionsChanged){var s;const{gl:e}=this.context;null===(s=this.state.model)||void 0===s||s.delete(),this.state.model=this._getModel(e),n.invalidateAll()}}getPickingInfo(e){const t=super.getPickingInfo(e),{index:i}=t,{data:n}=this.props;return n[0]&&n[0].__source&&(t.object=n.find((e=>e.__source.index===i))),t}disablePickingIndex(e){const{data:t}=this.props;if(t[0]&&t[0].__source)for(let i=0;i<t.length;i++)t[i].__source.index===e&&this._disablePickingIndex(i);else this._disablePickingIndex(e)}draw({uniforms:e}){const{jointRounded:t,capRounded:i,billboard:n,miterLimit:o,widthUnits:s,widthScale:r,widthMinPixels:l,widthMaxPixels:c}=this.props;this.state.model.setUniforms(e).setUniforms({jointType:Number(t),capType:Number(i),billboard:n,widthUnits:a.iI[s],widthScale:r,miterLimit:o,widthMinPixels:l,widthMaxPixels:c}).draw()}_getModel(e){const t=[0,1,2,1,4,2,1,3,4,3,5,4],i=[0,0,0,-1,0,1,1,-1,1,1,1,0];return new l.Z(e,{...this.getShaders(),id:this.props.id,geometry:new c.Z({drawMode:4,attributes:{indices:new Uint16Array(t),positions:{value:new Float32Array(i),size:2}}}),isInstanced:!0})}calculatePositions(e){const{pathTesselator:t}=this.state;e.startIndices=t.vertexStarts,e.value=t.get("positions")}calculateSegmentTypes(e){const{pathTesselator:t}=this.state;e.startIndices=t.vertexStarts,e.value=t.get("segmentTypes")}}(0,n.Z)(b,"defaultProps",P),(0,n.Z)(b,"layerName","PathLayer")},33121:function(e,t,i){i.d(t,{Z:function(){return p}});var n=i(82482),o=i(78918),s=i(80744),r=i(38550),a=i(56923),l=i(41990),c=i(99890),d=i(98452);const u=[0,0,0,255],h=[0,0,0,255],g={stroked:!0,filled:!0,extruded:!1,elevationScale:1,wireframe:!1,_normalize:!0,_windingOrder:"CW",lineWidthUnits:"meters",lineWidthScale:1,lineWidthMinPixels:0,lineWidthMaxPixels:Number.MAX_SAFE_INTEGER,lineJointRounded:!1,lineMiterLimit:4,getPolygon:{type:"accessor",value:e=>e.polygon},getFillColor:{type:"accessor",value:h},getLineColor:{type:"accessor",value:u},getLineWidth:{type:"accessor",value:1},getElevation:{type:"accessor",value:1e3},material:!0};class p extends o.Z{initializeState(){this.state={paths:[]},this.props.getLineDashArray&&s.Z.removed("getLineDashArray","PathStyleExtension")()}updateState({changeFlags:e}){const t=e.dataChanged||e.updateTriggersChanged&&(e.updateTriggersChanged.all||e.updateTriggersChanged.getPolygon);if(t&&Array.isArray(e.dataChanged)){const t=this.state.paths.slice(),i=e.dataChanged.map((e=>(0,d.b)({data:t,getIndex:e=>e.__source.index,dataRange:e,replace:this._getPaths(e)})));this.setState({paths:t,pathsDiff:i})}else t&&this.setState({paths:this._getPaths(),pathsDiff:null})}_getPaths(e={}){const{data:t,getPolygon:i,positionFormat:n,_normalize:o}=this.props,s=[],a="XY"===n?2:3,{startRow:l,endRow:d}=e,{iterable:u,objectInfo:h}=(0,r.jB)(t,l,d);for(const r of u){h.index++;let e=i(r,h);o&&(e=c.Fv(e,a));const{holeIndices:t}=e,n=e.positions||e;if(t)for(let i=0;i<=t.length;i++){const e=n.slice(t[i-1]||0,t[i]||n.length);s.push(this.getSubLayerRow({path:e},r,h.index))}else s.push(this.getSubLayerRow({path:n},r,h.index))}return s}renderLayers(){const{data:e,_dataDiff:t,stroked:i,filled:n,extruded:o,wireframe:s,_normalize:r,_windingOrder:c,elevationScale:d,transitions:h,positionFormat:g}=this.props,{lineWidthUnits:p,lineWidthScale:f,lineWidthMinPixels:m,lineWidthMaxPixels:v,lineJointRounded:y,lineMiterLimit:x,lineDashJustified:_}=this.props,{getFillColor:P,getLineColor:C,getLineWidth:b,getLineDashArray:S,getElevation:L,getPolygon:w,updateTriggers:z,material:T}=this.props,{paths:M,pathsDiff:A}=this.state,I=this.getSubLayerClass("fill",a.Z),O=this.getSubLayerClass("stroke",l.Z),E=this.shouldRenderSubLayer("fill",M)&&new I({_dataDiff:t,extruded:o,elevationScale:d,filled:n,wireframe:s,_normalize:r,_windingOrder:c,getElevation:L,getFillColor:P,getLineColor:o&&s?C:u,material:T,transitions:h},this.getSubLayerProps({id:"fill",updateTriggers:z&&{getPolygon:z.getPolygon,getElevation:z.getElevation,getFillColor:z.getFillColor,lineColors:o&&s,getLineColor:z.getLineColor}}),{data:e,positionFormat:g,getPolygon:w}),F=!o&&i&&this.shouldRenderSubLayer("stroke",M)&&new O({_dataDiff:A&&(()=>A),widthUnits:p,widthScale:f,widthMinPixels:m,widthMaxPixels:v,jointRounded:y,miterLimit:x,dashJustified:_,_pathType:"loop",transitions:h&&{getWidth:h.getLineWidth,getColor:h.getLineColor,getPath:h.getPolygon},getColor:this.getSubLayerAccessor(C),getWidth:this.getSubLayerAccessor(b),getDashArray:this.getSubLayerAccessor(S)},this.getSubLayerProps({id:"stroke",updateTriggers:z&&{getWidth:z.getLineWidth,getColor:z.getLineColor,getDashArray:z.getLineDashArray}}),{data:M,positionFormat:g,getPath:e=>e.path});return[!o&&E,F,o&&E]}}(0,n.Z)(p,"layerName","PolygonLayer"),(0,n.Z)(p,"defaultProps",g)},99890:function(e,t,i){i.d(t,{Fv:function(){return y},Gd:function(){return u},k8:function(){return d},mD:function(){return P}});var n=i(9187),o=i.n(n),s=i(89513);const r=s.wG.CLOCKWISE,a=s.wG.COUNTER_CLOCKWISE,l={isClosed:!0};function c(e){if(e=e&&e.positions||e,!Array.isArray(e)&&!ArrayBuffer.isView(e))throw new Error("invalid polygon")}function d(e){return"positions"in e?e.positions:e}function u(e){return"holeIndices"in e?e.holeIndices:null}function h(e){return Array.isArray(e[0])}function g(e){return e.length>=1&&e[0].length>=2&&Number.isFinite(e[0][0])}function p(e){const t=e[0],i=e[e.length-1];return t[0]===i[0]&&t[1]===i[1]&&t[2]===i[2]}function f(e,t,i,n){for(let o=0;o<t;o++)if(e[i+o]!==e[n-t+o])return!1;return!0}function m(e,t,i,n,o){let r=t;const a=i.length;for(let s=0;s<a;s++)for(let t=0;t<n;t++)e[r++]=i[s][t]||0;if(!p(i))for(let s=0;s<n;s++)e[r++]=i[0][s]||0;return l.start=t,l.end=r,l.size=n,(0,s.Ny)(e,o,l),r}function v(e,t,i,n,o=0,r,a){r=r||i.length;const c=r-o;if(c<=0)return t;let d=t;for(let s=0;s<c;s++)e[d++]=i[o+s];if(!f(i,n,o,r))for(let s=0;s<n;s++)e[d++]=i[o+s];return l.start=t,l.end=d,l.size=n,(0,s.Ny)(e,a,l),d}function y(e,t){c(e);const i=[],n=[];if("positions"in e){const{positions:o,holeIndices:s}=e;if(s){let e=0;for(let l=0;l<=s.length;l++)e=v(i,e,o,t,s[l-1],s[l],0===l?r:a),n.push(e);return n.pop(),{positions:i,holeIndices:n}}e=o}if(!h(e))return v(i,0,e,t,0,i.length,r),i;if(!g(e)){let o=0;for(const[s,l]of e.entries())o=m(i,o,l,t,0===s?r:a),n.push(o);return n.pop(),{positions:i,holeIndices:n}}return m(i,0,e,t,r),i}function x(e,t,i){const n=e.length/3;let o=0;for(let s=0;s<n;s++){const r=(s+1)%n;o+=e[3*s+t]*e[3*r+i],o-=e[3*r+t]*e[3*s+i]}return Math.abs(o/2)}function _(e,t,i,n){const o=e.length/3;for(let s=0;s<o;s++){const o=3*s,r=e[o+0],a=e[o+1],l=e[o+2];e[o+t]=r,e[o+i]=a,e[o+n]=l}}function P(e,t,i,n){let s=u(e);s&&(s=s.map((e=>e/t)));let r=d(e);const a=n&&3===t;if(i){const e=r.length;r=r.slice();const n=[];for(let o=0;o<e;o+=t){n[0]=r[o],n[1]=r[o+1],a&&(n[2]=r[o+2]);const e=i(n);r[o]=e[0],r[o+1]=e[1],a&&(r[o+2]=e[2])}}if(a){const e=x(r,0,1),t=x(r,0,2),n=x(r,1,2);if(!e&&!t&&!n)return[];e>t&&e>n||(t>n?(i||(r=r.slice()),_(r,0,2,1)):(i||(r=r.slice()),_(r,1,2,0)))}return o()(r,s,t)}},56923:function(e,t,i){i.d(t,{Z:function(){return L}});var n=i(82482),o=i(52447),s=i(93844),r=i(8674),a=i(43844),l=i(24088),c=i(44211),d=i(6948),u=i(80210),h=i(53982),g=i(99890),p=i(28005),f=i(89513);class m extends p.Z{constructor(e){const{fp64:t,IndexType:i=Uint32Array}=e;super({...e,attributes:{positions:{size:3,type:t?Float64Array:Float32Array},vertexValid:{type:Uint8ClampedArray,size:1},indices:{type:i,size:1}}})}get(e){const{attributes:t}=this;return"indices"===e?t.indices&&t.indices.subarray(0,this.vertexCount):t[e]}updateGeometry(e){super.updateGeometry(e);const t=this.buffers.indices;if(t)this.vertexCount=(t.value||t).length;else if(this.data&&!this.getGeometry)throw new Error("missing indices buffer")}normalizeGeometry(e){if(this.normalize){const t=g.Fv(e,this.positionSize);return this.opts.resolution?(0,f.WZ)(g.k8(t),g.Gd(t),{size:this.positionSize,gridResolution:this.opts.resolution,edgeTypes:!0}):this.opts.wrapLongitude?(0,f.GU)(g.k8(t),g.Gd(t),{size:this.positionSize,maxLatitude:86,edgeTypes:!0}):t}return e}getGeometrySize(e){if(v(e)){let t=0;for(const i of e)t+=this.getGeometrySize(i);return t}return g.k8(e).length/this.positionSize}getGeometryFromBuffer(e){return this.normalize||!this.buffers.indices?super.getGeometryFromBuffer(e):null}updateGeometryAttributes(e,t){if(e&&v(e))for(const i of e){const e=this.getGeometrySize(i);t.geometrySize=e,this.updateGeometryAttributes(i,t),t.vertexStart+=e,t.indexStart=this.indexStarts[t.geometryIndex+1]}else this._updateIndices(e,t),this._updatePositions(e,t),this._updateVertexValid(e,t)}_updateIndices(e,{geometryIndex:t,vertexStart:i,indexStart:n}){const{attributes:o,indexStarts:s,typedArrayManager:r}=this;let a=o.indices;if(!a||!e)return;let l=n;const c=g.mD(e,this.positionSize,this.opts.preproject,this.opts.full3d);a=r.allocate(a,n+c.length,{copy:!0});for(let d=0;d<c.length;d++)a[l++]=c[d]+i;s[t+1]=n+c.length,o.indices=a}_updatePositions(e,{vertexStart:t,geometrySize:i}){const{attributes:{positions:n},positionSize:o}=this;if(!n||!e)return;const s=g.k8(e);for(let r=t,a=0;a<i;r++,a++){const e=s[a*o],t=s[a*o+1],i=o>2?s[a*o+2]:0;n[3*r]=e,n[3*r+1]=t,n[3*r+2]=i}}_updateVertexValid(e,{vertexStart:t,geometrySize:i}){const{positionSize:n}=this,o=this.attributes.vertexValid,s=e&&g.Gd(e);if(e&&e.edgeTypes?o.set(e.edgeTypes,t):o.fill(1,t,t+i),s)for(let r=0;r<s.length;r++)o[t+s[r]/n-1]=0;o[t+i-1]=0}}function v(e){return Array.isArray(e)&&e.length>0&&!Number.isFinite(e[0])}var y="\nattribute vec2 vertexPositions;\nattribute float vertexValid;\n\nuniform bool extruded;\nuniform bool isWireframe;\nuniform float elevationScale;\nuniform float opacity;\n\nvarying vec4 vColor;\n\nstruct PolygonProps {\n  vec4 fillColors;\n  vec4 lineColors;\n  vec3 positions;\n  vec3 nextPositions;\n  vec3 pickingColors;\n  vec3 positions64Low;\n  vec3 nextPositions64Low;\n  float elevations;\n};\n\nvec3 project_offset_normal(vec3 vector) {\n  if (project_uCoordinateSystem == COORDINATE_SYSTEM_LNGLAT ||\n    project_uCoordinateSystem == COORDINATE_SYSTEM_LNGLAT_OFFSETS) {\n    return normalize(vector * project_uCommonUnitsPerWorldUnit);\n  }\n  return project_normal(vector);\n}\n\nvoid calculatePosition(PolygonProps props) {\n#ifdef IS_SIDE_VERTEX\n  if(vertexValid < 0.5){\n    gl_Position = vec4(0.);\n    return;\n  }\n#endif\n\n  vec3 pos;\n  vec3 pos64Low;\n  vec3 normal;\n  vec4 colors = isWireframe ? props.lineColors : props.fillColors;\n\n  geometry.worldPosition = props.positions;\n  geometry.worldPositionAlt = props.nextPositions;\n  geometry.pickingColor = props.pickingColors;\n\n#ifdef IS_SIDE_VERTEX\n  pos = mix(props.positions, props.nextPositions, vertexPositions.x);\n  pos64Low = mix(props.positions64Low, props.nextPositions64Low, vertexPositions.x);\n#else\n  pos = props.positions;\n  pos64Low = props.positions64Low;\n#endif\n\n  if (extruded) {\n    pos.z += props.elevations * vertexPositions.y * elevationScale;\n  }\n  gl_Position = project_position_to_clipspace(pos, pos64Low, vec3(0.), geometry.position);\n\n  DECKGL_FILTER_GL_POSITION(gl_Position, geometry);\n\n  if (extruded) {\n  #ifdef IS_SIDE_VERTEX\n    normal = vec3(\n      props.positions.y - props.nextPositions.y + (props.positions64Low.y - props.nextPositions64Low.y),\n      props.nextPositions.x - props.positions.x + (props.nextPositions64Low.x - props.positions64Low.x),\n      0.0);\n    normal = project_offset_normal(normal);\n  #else\n    normal = project_normal(vec3(0.0, 0.0, 1.0));\n  #endif\n    geometry.normal = normal;\n    vec3 lightColor = lighting_getLightColor(colors.rgb, project_uCameraPosition, geometry.position.xyz, normal);\n    vColor = vec4(lightColor, colors.a * opacity);\n  } else {\n    vColor = vec4(colors.rgb, colors.a * opacity);\n  }\n  DECKGL_FILTER_COLOR(vColor, geometry);\n}\n",x="#define SHADER_NAME solid-polygon-layer-vertex-shader\n\nattribute vec3 positions;\nattribute vec3 positions64Low;\nattribute float elevations;\nattribute vec4 fillColors;\nattribute vec4 lineColors;\nattribute vec3 pickingColors;\n\n".concat(y,"\n\nvoid main(void) {\n  PolygonProps props;\n\n  props.positions = positions;\n  props.positions64Low = positions64Low;\n  props.elevations = elevations;\n  props.fillColors = fillColors;\n  props.lineColors = lineColors;\n  props.pickingColors = pickingColors;\n\n  calculatePosition(props);\n}\n"),_="#define SHADER_NAME solid-polygon-layer-vertex-shader-side\n#define IS_SIDE_VERTEX\n\n\nattribute vec3 instancePositions;\nattribute vec3 nextPositions;\nattribute vec3 instancePositions64Low;\nattribute vec3 nextPositions64Low;\nattribute float instanceElevations;\nattribute vec4 instanceFillColors;\nattribute vec4 instanceLineColors;\nattribute vec3 instancePickingColors;\n\n".concat(y,"\n\nvoid main(void) {\n  PolygonProps props;\n\n  #if RING_WINDING_ORDER_CW == 1\n    props.positions = instancePositions;\n    props.positions64Low = instancePositions64Low;\n    props.nextPositions = nextPositions;\n    props.nextPositions64Low = nextPositions64Low;\n  #else\n    props.positions = nextPositions;\n    props.positions64Low = nextPositions64Low;\n    props.nextPositions = instancePositions;\n    props.nextPositions64Low = instancePositions64Low;\n  #endif\n  props.elevations = instanceElevations;\n  props.fillColors = instanceFillColors;\n  props.lineColors = instanceLineColors;\n  props.pickingColors = instancePickingColors;\n\n  calculatePosition(props);\n}\n"),P="#define SHADER_NAME solid-polygon-layer-fragment-shader\n\nprecision highp float;\n\nvarying vec4 vColor;\n\nvoid main(void) {\n  gl_FragColor = vColor;\n\n  DECKGL_FILTER_COLOR(gl_FragColor, geometry);\n}\n";const C=[0,0,0,255],b={filled:!0,extruded:!1,wireframe:!1,_normalize:!0,_windingOrder:"CW",_full3d:!1,elevationScale:{type:"number",min:0,value:1},getPolygon:{type:"accessor",value:e=>e.polygon},getElevation:{type:"accessor",value:1e3},getFillColor:{type:"accessor",value:C},getLineColor:{type:"accessor",value:C},material:!0},S={enter:(e,t)=>t.length?t.subarray(t.length-e.length):e};class L extends o.Z{constructor(...e){super(...e),(0,n.Z)(this,"state",void 0)}getShaders(e){return super.getShaders({vs:"top"===e?x:_,fs:P,defines:{RING_WINDING_ORDER_CW:this.props._normalize||"CCW"!==this.props._windingOrder?1:0},modules:[s.Z,r.N,a.Z]})}get wrapLongitude(){return!1}initializeState(){const{gl:e,viewport:t}=this.context;let{coordinateSystem:i}=this.props;const{_full3d:n}=this.props;let o;t.isGeospatial&&i===l.Df.DEFAULT&&(i=l.Df.LNGLAT),i===l.Df.LNGLAT&&(o=n?t.projectPosition.bind(t):t.projectFlat.bind(t)),this.setState({numInstances:0,polygonTesselator:new m({preproject:o,fp64:this.use64bitPositions(),IndexType:!e||(0,c.ag)(e,d.h.ELEMENT_INDEX_UINT32)?Uint32Array:Uint16Array})});const s=this.getAttributeManager(),r=!0;s.remove(["instancePickingColors"]),s.add({indices:{size:1,isIndexed:!0,update:this.calculateIndices,noAlloc:r},positions:{size:3,type:5130,fp64:this.use64bitPositions(),transition:S,accessor:"getPolygon",update:this.calculatePositions,noAlloc:r,shaderAttributes:{positions:{vertexOffset:0,divisor:0},instancePositions:{vertexOffset:0,divisor:1},nextPositions:{vertexOffset:1,divisor:1}}},vertexValid:{size:1,divisor:1,type:5121,update:this.calculateVertexValid,noAlloc:r},elevations:{size:1,transition:S,accessor:"getElevation",shaderAttributes:{elevations:{divisor:0},instanceElevations:{divisor:1}}},fillColors:{size:this.props.colorFormat.length,type:5121,normalized:!0,transition:S,accessor:"getFillColor",defaultValue:C,shaderAttributes:{fillColors:{divisor:0},instanceFillColors:{divisor:1}}},lineColors:{size:this.props.colorFormat.length,type:5121,normalized:!0,transition:S,accessor:"getLineColor",defaultValue:C,shaderAttributes:{lineColors:{divisor:0},instanceLineColors:{divisor:1}}},pickingColors:{size:3,type:5121,accessor:(e,{index:t,target:i})=>this.encodePickingColor(e&&e.__source?e.__source.index:t,i),shaderAttributes:{pickingColors:{divisor:0},instancePickingColors:{divisor:1}}}})}getPickingInfo(e){const t=super.getPickingInfo(e),{index:i}=t,{data:n}=this.props;return n[0]&&n[0].__source&&(t.object=n.find((e=>e.__source.index===i))),t}disablePickingIndex(e){const{data:t}=this.props;if(t[0]&&t[0].__source)for(let i=0;i<t.length;i++)t[i].__source.index===e&&this._disablePickingIndex(i);else this._disablePickingIndex(e)}draw({uniforms:e}){const{extruded:t,filled:i,wireframe:n,elevationScale:o}=this.props,{topModel:s,sideModel:r,polygonTesselator:a}=this.state,l={...e,extruded:Boolean(t),elevationScale:o};r&&(r.setInstanceCount(a.instanceCount-1),r.setUniforms(l),n&&(r.setDrawMode(3),r.setUniforms({isWireframe:!0}).draw()),i&&(r.setDrawMode(6),r.setUniforms({isWireframe:!1}).draw())),s&&(s.setVertexCount(a.vertexCount),s.setUniforms(l).draw())}updateState(e){super.updateState(e),this.updateGeometry(e);const{props:t,oldProps:i,changeFlags:n}=e,o=this.getAttributeManager(),s=n.extensionsChanged||t.filled!==i.filled||t.extruded!==i.extruded;var r;s&&(null===(r=this.state.models)||void 0===r||r.forEach((e=>e.delete())),this.setState(this._getModels(this.context.gl)),o.invalidateAll())}updateGeometry({props:e,oldProps:t,changeFlags:i}){const n=i.dataChanged||i.updateTriggersChanged&&(i.updateTriggersChanged.all||i.updateTriggersChanged.getPolygon);if(n){const{polygonTesselator:t}=this.state,n=e.data.attributes||{};t.updateGeometry({data:e.data,normalize:e._normalize,geometryBuffer:n.getPolygon,buffers:n,getGeometry:e.getPolygon,positionFormat:e.positionFormat,wrapLongitude:e.wrapLongitude,resolution:this.context.viewport.resolution,fp64:this.use64bitPositions(),dataChanged:i.dataChanged,full3d:e._full3d}),this.setState({numInstances:t.instanceCount,startIndices:t.vertexStarts}),i.dataChanged||this.getAttributeManager().invalidateAll()}}_getModels(e){const{id:t,filled:i,extruded:n}=this.props;let o,s;if(i){const i=this.getShaders("top");i.defines.NON_INSTANCED_MODEL=1,o=new u.Z(e,{...i,id:"".concat(t,"-top"),drawMode:4,attributes:{vertexPositions:new Float32Array([0,1])},uniforms:{isWireframe:!1,isSideVertex:!1},vertexCount:0,isIndexed:!0})}return n&&(s=new u.Z(e,{...this.getShaders("side"),id:"".concat(t,"-side"),geometry:new h.Z({drawMode:1,vertexCount:4,attributes:{vertexPositions:{size:2,value:new Float32Array([1,0,0,0,0,1,1,1])}}}),instanceCount:0,isInstanced:1}),s.userData.excludeAttributes={indices:!0}),{models:[s,o].filter(Boolean),topModel:o,sideModel:s}}calculateIndices(e){const{polygonTesselator:t}=this.state;e.startIndices=t.indexStarts,e.value=t.get("indices")}calculatePositions(e){const{polygonTesselator:t}=this.state;e.startIndices=t.vertexStarts,e.value=t.get("positions")}calculateVertexValid(e){e.value=this.state.polygonTesselator.get("vertexValid")}}(0,n.Z)(L,"defaultProps",b),(0,n.Z)(L,"layerName","SolidPolygonLayer")},98452:function(e,t,i){function n({data:e,getIndex:t,dataRange:i,replace:n}){const{startRow:o=0,endRow:s=1/0}=i,r=e.length;let a=r,l=r;for(let h=0;h<r;h++){const i=t(e[h]);if(a>h&&i>=o&&(a=h),i>=s){l=h;break}}let c=a;const d=l-a!==n.length,u=d?e.slice(l):void 0;for(let h=0;h<n.length;h++)e[c++]=n[h];if(u){for(let t=0;t<u.length;t++)e[c++]=u[t];e.length=c}return{startRow:a,endRow:a+n.length}}i.d(t,{b:function(){return n}})}}]);
//# sourceMappingURL=chunk-vendors-21d0fda6.a6d802d3.js.map