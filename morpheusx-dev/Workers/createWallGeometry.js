define(["./when-8166c7dd","./Matrix2-92b7fb9d","./Transforms-62a339c3","./ComponentDatatype-9ed50558","./RuntimeError-4fdc4459","./GeometryAttribute-6f4c3b93","./GeometryAttributes-50becc99","./IndexDatatype-797210ca","./VertexFormat-c0801687","./WallGeometryLibrary-ace2cc0d","./combine-a5c4cc47","./WebGLConstants-0664004c","./arrayRemoveDuplicates-198208a4","./PolylinePipeline-fd9260c9","./EllipsoidGeodesic-133bd147","./EllipsoidRhumbLine-51654311","./IntersectionTests-4f28a69c","./Plane-049255eb"],(function(e,t,i,r,a,n,o,s,m,l,d,p,u,c,f,h,v,g){"use strict";var y=new t.Cartesian3,w=new t.Cartesian3,C=new t.Cartesian3,x=new t.Cartesian3,E=new t.Cartesian3,b=new t.Cartesian3,A=new t.Cartesian3;function _(i){i=e.defaultValue(i,e.defaultValue.EMPTY_OBJECT);var n=i.positions,o=i.maximumHeights,s=i.minimumHeights;if(!e.defined(n))throw new a.DeveloperError("options.positions is required.");if(e.defined(o)&&o.length!==n.length)throw new a.DeveloperError("options.positions and options.maximumHeights must have the same length.");if(e.defined(s)&&s.length!==n.length)throw new a.DeveloperError("options.positions and options.minimumHeights must have the same length.");var l=e.defaultValue(i.vertexFormat,m.VertexFormat.DEFAULT),d=e.defaultValue(i.granularity,r.CesiumMath.RADIANS_PER_DEGREE),p=e.defaultValue(i.ellipsoid,t.Ellipsoid.WGS84);this._positions=n,this._minimumHeights=s,this._maximumHeights=o,this._vertexFormat=m.VertexFormat.clone(l),this._granularity=d,this._ellipsoid=t.Ellipsoid.clone(p),this._workerName="createWallGeometry";var u=1+n.length*t.Cartesian3.packedLength+2;e.defined(s)&&(u+=s.length),e.defined(o)&&(u+=o.length),this.packedLength=u+t.Ellipsoid.packedLength+m.VertexFormat.packedLength+1}_.pack=function(i,r,n){if(!e.defined(i))throw new a.DeveloperError("value is required");if(!e.defined(r))throw new a.DeveloperError("array is required");var o;n=e.defaultValue(n,0);var s=i._positions,l=s.length;for(r[n++]=l,o=0;o<l;++o,n+=t.Cartesian3.packedLength)t.Cartesian3.pack(s[o],r,n);var d=i._minimumHeights;if(l=e.defined(d)?d.length:0,r[n++]=l,e.defined(d))for(o=0;o<l;++o)r[n++]=d[o];var p=i._maximumHeights;if(l=e.defined(p)?p.length:0,r[n++]=l,e.defined(p))for(o=0;o<l;++o)r[n++]=p[o];return t.Ellipsoid.pack(i._ellipsoid,r,n),n+=t.Ellipsoid.packedLength,m.VertexFormat.pack(i._vertexFormat,r,n),n+=m.VertexFormat.packedLength,r[n]=i._granularity,r};var F=t.Ellipsoid.clone(t.Ellipsoid.UNIT_SPHERE),D=new m.VertexFormat,L={positions:void 0,minimumHeights:void 0,maximumHeights:void 0,ellipsoid:F,vertexFormat:D,granularity:void 0};function H(i,r){return e.defined(r)&&(i=_.unpack(i,r)),i._ellipsoid=t.Ellipsoid.clone(i._ellipsoid),_.createGeometry(i)}return _.unpack=function(i,r,n){if(!e.defined(i))throw new a.DeveloperError("array is required");var o;r=e.defaultValue(r,0);var s,l,d=i[r++],p=new Array(d);for(o=0;o<d;++o,r+=t.Cartesian3.packedLength)p[o]=t.Cartesian3.unpack(i,r);if(d=i[r++],d>0)for(s=new Array(d),o=0;o<d;++o)s[o]=i[r++];if(d=i[r++],d>0)for(l=new Array(d),o=0;o<d;++o)l[o]=i[r++];var u=t.Ellipsoid.unpack(i,r,F);r+=t.Ellipsoid.packedLength;var c=m.VertexFormat.unpack(i,r,D);r+=m.VertexFormat.packedLength;var f=i[r];return e.defined(n)?(n._positions=p,n._minimumHeights=s,n._maximumHeights=l,n._ellipsoid=t.Ellipsoid.clone(u,n._ellipsoid),n._vertexFormat=m.VertexFormat.clone(c,n._vertexFormat),n._granularity=f,n):(L.positions=p,L.minimumHeights=s,L.maximumHeights=l,L.granularity=f,new _(L))},_.fromConstantHeights=function(t){t=e.defaultValue(t,e.defaultValue.EMPTY_OBJECT);var i,r,n=t.positions;if(!e.defined(n))throw new a.DeveloperError("options.positions is required.");var o=t.minimumHeight,s=t.maximumHeight,m=e.defined(o),l=e.defined(s);if(m||l){var d=n.length;i=m?new Array(d):void 0,r=l?new Array(d):void 0;for(var p=0;p<d;++p)m&&(i[p]=o),l&&(r[p]=s)}var u={positions:n,maximumHeights:r,minimumHeights:i,ellipsoid:t.ellipsoid,vertexFormat:t.vertexFormat};return new _(u)},_.createGeometry=function(a){var m=a._positions,d=a._minimumHeights,p=a._maximumHeights,u=a._vertexFormat,c=a._granularity,f=a._ellipsoid,h=l.WallGeometryLibrary.computePositions(f,m,p,d,c,!0);if(e.defined(h)){var v,g=h.bottomPositions,_=h.topPositions,F=h.numCorners,D=_.length,L=2*D,H=u.position?new Float64Array(L):void 0,k=u.normal?new Float32Array(L):void 0,V=u.tangent?new Float32Array(L):void 0,G=u.bitangent?new Float32Array(L):void 0,P=u.st?new Float32Array(L/3*2):void 0,T=0,z=0,O=0,R=0,S=0,I=A,q=b,N=E,M=!0;D/=3;var W=0,B=1/(D-F-1);for(v=0;v<D;++v){var U=3*v,J=t.Cartesian3.fromArray(_,U,y),Y=t.Cartesian3.fromArray(g,U,w);if(u.position&&(H[T++]=Y.x,H[T++]=Y.y,H[T++]=Y.z,H[T++]=J.x,H[T++]=J.y,H[T++]=J.z),u.st&&(P[S++]=W,P[S++]=0,P[S++]=W,P[S++]=1),u.normal||u.tangent||u.bitangent){var Z=t.Cartesian3.clone(t.Cartesian3.ZERO,x),j=t.Cartesian3.subtract(J,f.geodeticSurfaceNormal(J,w),w);if(v+1<D&&(Z=t.Cartesian3.fromArray(_,U+3,x)),M){var K=t.Cartesian3.subtract(Z,J,C),Q=t.Cartesian3.subtract(j,J,y);I=t.Cartesian3.normalize(t.Cartesian3.cross(Q,K,I),I),M=!1}t.Cartesian3.equalsEpsilon(J,Z,r.CesiumMath.EPSILON10)?M=!0:(W+=B,u.tangent&&(q=t.Cartesian3.normalize(t.Cartesian3.subtract(Z,J,q),q)),u.bitangent&&(N=t.Cartesian3.normalize(t.Cartesian3.cross(I,q,N),N))),u.normal&&(k[z++]=I.x,k[z++]=I.y,k[z++]=I.z,k[z++]=I.x,k[z++]=I.y,k[z++]=I.z),u.tangent&&(V[R++]=q.x,V[R++]=q.y,V[R++]=q.z,V[R++]=q.x,V[R++]=q.y,V[R++]=q.z),u.bitangent&&(G[O++]=N.x,G[O++]=N.y,G[O++]=N.z,G[O++]=N.x,G[O++]=N.y,G[O++]=N.z)}}var X=new o.GeometryAttributes;u.position&&(X.position=new n.GeometryAttribute({componentDatatype:r.ComponentDatatype.DOUBLE,componentsPerAttribute:3,values:H})),u.normal&&(X.normal=new n.GeometryAttribute({componentDatatype:r.ComponentDatatype.FLOAT,componentsPerAttribute:3,values:k})),u.tangent&&(X.tangent=new n.GeometryAttribute({componentDatatype:r.ComponentDatatype.FLOAT,componentsPerAttribute:3,values:V})),u.bitangent&&(X.bitangent=new n.GeometryAttribute({componentDatatype:r.ComponentDatatype.FLOAT,componentsPerAttribute:3,values:G})),u.st&&(X.st=new n.GeometryAttribute({componentDatatype:r.ComponentDatatype.FLOAT,componentsPerAttribute:2,values:P}));var $=L/3;L-=6*(F+1);var ee=s.IndexDatatype.createTypedArray($,L),te=0;for(v=0;v<$-2;v+=2){var ie=v,re=v+2,ae=t.Cartesian3.fromArray(H,3*ie,y),ne=t.Cartesian3.fromArray(H,3*re,w);if(!t.Cartesian3.equalsEpsilon(ae,ne,r.CesiumMath.EPSILON10)){var oe=v+1,se=v+3;ee[te++]=oe,ee[te++]=ie,ee[te++]=se,ee[te++]=se,ee[te++]=ie,ee[te++]=re}}return new n.Geometry({attributes:X,indices:ee,primitiveType:n.PrimitiveType.TRIANGLES,boundingSphere:new i.BoundingSphere.fromVertices(H)})}},H}));