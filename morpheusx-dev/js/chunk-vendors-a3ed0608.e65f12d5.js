"use strict";(self["webpackChunkvue3_webpack5"]=self["webpackChunkvue3_webpack5"]||[]).push([[2868],{67391:function(__unused_webpack___webpack_module__,__webpack_exports__){eval('var oldValue;\nif (typeof ko !== \'undefined\') {\n    oldValue = ko;\n}\n\n(function(){\n/*!\n * Knockout JavaScript library v3.5.1\n * (c) The Knockout.js team - http://knockoutjs.com/\n * License: MIT (http://www.opensource.org/licenses/mit-license.php)\n */\n\n(function() {(function(n){var A=this||(0,eval)("this"),w=A.document,R=A.navigator,v=A.jQuery,H=A.JSON;v||"undefined"===typeof jQuery||(v=jQuery);(function(n){n(A.ko={})})(function(S,T){function K(a,c){return null===a||typeof a in W?a===c:!1}function X(b,c){var d;return function(){d||(d=a.a.setTimeout(function(){d=n;b()},c))}}function Y(b,c){var d;return function(){clearTimeout(d);\nd=a.a.setTimeout(b,c)}}function Z(a,c){c&&"change"!==c?"beforeChange"===c?this.pc(a):this.gb(a,c):this.qc(a)}function aa(a,c){null!==c&&c.s&&c.s()}function ba(a,c){var d=this.qd,e=d[r];e.ra||(this.Qb&&this.mb[c]?(d.uc(c,a,this.mb[c]),this.mb[c]=null,--this.Qb):e.I[c]||d.uc(c,a,e.J?{da:a}:d.$c(a)),a.Ja&&a.gd())}var a="undefined"!==typeof S?S:{};a.b=function(b,c){for(var d=b.split("."),e=a,f=0;f<d.length-1;f++)e=e[d[f]];e[d[d.length-1]]=c};a.L=function(a,c,d){a[c]=d};a.version="3.5.1";a.b("version",\na.version);a.options={deferUpdates:!1,useOnlyNativeEvents:!1,foreachHidesDestroyed:!1};a.a=function(){function b(a,b){for(var c in a)f.call(a,c)&&b(c,a[c])}function c(a,b){if(b)for(var c in b)f.call(b,c)&&(a[c]=b[c]);return a}function d(a,b){a.__proto__=b;return a}function e(b,c,d,e){var l=b[c].match(q)||[];a.a.D(d.match(q),function(b){a.a.Na(l,b,e)});b[c]=l.join(" ")}var f=Object.prototype.hasOwnProperty,g={__proto__:[]}instanceof Array,h="function"===typeof Symbol,m={},k={};m[R&&/Firefox\\/2/i.test(R.userAgent)?\n"KeyboardEvent":"UIEvents"]=["keyup","keydown","keypress"];m.MouseEvents="click dblclick mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave".split(" ");b(m,function(a,b){if(b.length)for(var c=0,d=b.length;c<d;c++)k[b[c]]=a});var l={propertychange:!0},p=w&&function(){for(var a=3,b=w.createElement("div"),c=b.getElementsByTagName("i");b.innerHTML="\\x3c!--[if gt IE "+ ++a+"]><i></i><![endif]--\\x3e",c[0];);return 4<a?a:n}(),q=/\\S+/g,t;return{Jc:["authenticity_token",/^__RequestVerificationToken(_.*)?$/],\nD:function(a,b,c){for(var d=0,e=a.length;d<e;d++)b.call(c,a[d],d,a)},A:"function"==typeof Array.prototype.indexOf?function(a,b){return Array.prototype.indexOf.call(a,b)}:function(a,b){for(var c=0,d=a.length;c<d;c++)if(a[c]===b)return c;return-1},Lb:function(a,b,c){for(var d=0,e=a.length;d<e;d++)if(b.call(c,a[d],d,a))return a[d];return n},Pa:function(b,c){var d=a.a.A(b,c);0<d?b.splice(d,1):0===d&&b.shift()},wc:function(b){var c=[];b&&a.a.D(b,function(b){0>a.a.A(c,b)&&c.push(b)});return c},Mb:function(a,\nb,c){var d=[];if(a)for(var e=0,l=a.length;e<l;e++)d.push(b.call(c,a[e],e));return d},jb:function(a,b,c){var d=[];if(a)for(var e=0,l=a.length;e<l;e++)b.call(c,a[e],e)&&d.push(a[e]);return d},Nb:function(a,b){if(b instanceof Array)a.push.apply(a,b);else for(var c=0,d=b.length;c<d;c++)a.push(b[c]);return a},Na:function(b,c,d){var e=a.a.A(a.a.bc(b),c);0>e?d&&b.push(c):d||b.splice(e,1)},Ba:g,extend:c,setPrototypeOf:d,Ab:g?d:c,P:b,Ga:function(a,b,c){if(!a)return a;var d={},e;for(e in a)f.call(a,e)&&(d[e]=\nb.call(c,a[e],e,a));return d},Tb:function(b){for(;b.firstChild;)a.removeNode(b.firstChild)},Yb:function(b){b=a.a.la(b);for(var c=(b[0]&&b[0].ownerDocument||w).createElement("div"),d=0,e=b.length;d<e;d++)c.appendChild(a.oa(b[d]));return c},Ca:function(b,c){for(var d=0,e=b.length,l=[];d<e;d++){var k=b[d].cloneNode(!0);l.push(c?a.oa(k):k)}return l},va:function(b,c){a.a.Tb(b);if(c)for(var d=0,e=c.length;d<e;d++)b.appendChild(c[d])},Xc:function(b,c){var d=b.nodeType?[b]:b;if(0<d.length){for(var e=d[0],\nl=e.parentNode,k=0,f=c.length;k<f;k++)l.insertBefore(c[k],e);k=0;for(f=d.length;k<f;k++)a.removeNode(d[k])}},Ua:function(a,b){if(a.length){for(b=8===b.nodeType&&b.parentNode||b;a.length&&a[0].parentNode!==b;)a.splice(0,1);for(;1<a.length&&a[a.length-1].parentNode!==b;)a.length--;if(1<a.length){var c=a[0],d=a[a.length-1];for(a.length=0;c!==d;)a.push(c),c=c.nextSibling;a.push(d)}}return a},Zc:function(a,b){7>p?a.setAttribute("selected",b):a.selected=b},Db:function(a){return null===a||a===n?"":a.trim?\na.trim():a.toString().replace(/^[\\s\\xa0]+|[\\s\\xa0]+$/g,"")},Ud:function(a,b){a=a||"";return b.length>a.length?!1:a.substring(0,b.length)===b},vd:function(a,b){if(a===b)return!0;if(11===a.nodeType)return!1;if(b.contains)return b.contains(1!==a.nodeType?a.parentNode:a);if(b.compareDocumentPosition)return 16==(b.compareDocumentPosition(a)&16);for(;a&&a!=b;)a=a.parentNode;return!!a},Sb:function(b){return a.a.vd(b,b.ownerDocument.documentElement)},kd:function(b){return!!a.a.Lb(b,a.a.Sb)},R:function(a){return a&&\na.tagName&&a.tagName.toLowerCase()},Ac:function(b){return a.onError?function(){try{return b.apply(this,arguments)}catch(c){throw a.onError&&a.onError(c),c;}}:b},setTimeout:function(b,c){return setTimeout(a.a.Ac(b),c)},Gc:function(b){setTimeout(function(){a.onError&&a.onError(b);throw b;},0)},B:function(b,c,d){var e=a.a.Ac(d);d=l[c];if(a.options.useOnlyNativeEvents||d||!v)if(d||"function"!=typeof b.addEventListener)if("undefined"!=typeof b.attachEvent){var k=function(a){e.call(b,a)},f="on"+c;b.attachEvent(f,\nk);a.a.K.za(b,function(){b.detachEvent(f,k)})}else throw Error("Browser doesn\'t support addEventListener or attachEvent");else b.addEventListener(c,e,!1);else t||(t="function"==typeof v(b).on?"on":"bind"),v(b)[t](c,e)},Fb:function(b,c){if(!b||!b.nodeType)throw Error("element must be a DOM node when calling triggerEvent");var d;"input"===a.a.R(b)&&b.type&&"click"==c.toLowerCase()?(d=b.type,d="checkbox"==d||"radio"==d):d=!1;if(a.options.useOnlyNativeEvents||!v||d)if("function"==typeof w.createEvent)if("function"==\ntypeof b.dispatchEvent)d=w.createEvent(k[c]||"HTMLEvents"),d.initEvent(c,!0,!0,A,0,0,0,0,0,!1,!1,!1,!1,0,b),b.dispatchEvent(d);else throw Error("The supplied element doesn\'t support dispatchEvent");else if(d&&b.click)b.click();else if("undefined"!=typeof b.fireEvent)b.fireEvent("on"+c);else throw Error("Browser doesn\'t support triggering events");else v(b).trigger(c)},f:function(b){return a.O(b)?b():b},bc:function(b){return a.O(b)?b.v():b},Eb:function(b,c,d){var l;c&&("object"===typeof b.classList?\n(l=b.classList[d?"add":"remove"],a.a.D(c.match(q),function(a){l.call(b.classList,a)})):"string"===typeof b.className.baseVal?e(b.className,"baseVal",c,d):e(b,"className",c,d))},Bb:function(b,c){var d=a.a.f(c);if(null===d||d===n)d="";var e=a.h.firstChild(b);!e||3!=e.nodeType||a.h.nextSibling(e)?a.h.va(b,[b.ownerDocument.createTextNode(d)]):e.data=d;a.a.Ad(b)},Yc:function(a,b){a.name=b;if(7>=p)try{var c=a.name.replace(/[&<>\'"]/g,function(a){return"&#"+a.charCodeAt(0)+";"});a.mergeAttributes(w.createElement("<input name=\'"+\nc+"\'/>"),!1)}catch(d){}},Ad:function(a){9<=p&&(a=1==a.nodeType?a:a.parentNode,a.style&&(a.style.zoom=a.style.zoom))},wd:function(a){if(p){var b=a.style.width;a.style.width=0;a.style.width=b}},Pd:function(b,c){b=a.a.f(b);c=a.a.f(c);for(var d=[],e=b;e<=c;e++)d.push(e);return d},la:function(a){for(var b=[],c=0,d=a.length;c<d;c++)b.push(a[c]);return b},Da:function(a){return h?Symbol(a):a},Zd:6===p,$d:7===p,W:p,Lc:function(b,c){for(var d=a.a.la(b.getElementsByTagName("input")).concat(a.a.la(b.getElementsByTagName("textarea"))),\ne="string"==typeof c?function(a){return a.name===c}:function(a){return c.test(a.name)},l=[],k=d.length-1;0<=k;k--)e(d[k])&&l.push(d[k]);return l},Nd:function(b){return"string"==typeof b&&(b=a.a.Db(b))?H&&H.parse?H.parse(b):(new Function("return "+b))():null},hc:function(b,c,d){if(!H||!H.stringify)throw Error("Cannot find JSON.stringify(). Some browsers (e.g., IE < 8) don\'t support it natively, but you can overcome this by adding a script reference to json2.js, downloadable from http://www.json.org/json2.js");\nreturn H.stringify(a.a.f(b),c,d)},Od:function(c,d,e){e=e||{};var l=e.params||{},k=e.includeFields||this.Jc,f=c;if("object"==typeof c&&"form"===a.a.R(c))for(var f=c.action,h=k.length-1;0<=h;h--)for(var g=a.a.Lc(c,k[h]),m=g.length-1;0<=m;m--)l[g[m].name]=g[m].value;d=a.a.f(d);var p=w.createElement("form");p.style.display="none";p.action=f;p.method="post";for(var q in d)c=w.createElement("input"),c.type="hidden",c.name=q,c.value=a.a.hc(a.a.f(d[q])),p.appendChild(c);b(l,function(a,b){var c=w.createElement("input");\nc.type="hidden";c.name=a;c.value=b;p.appendChild(c)});w.body.appendChild(p);e.submitter?e.submitter(p):p.submit();setTimeout(function(){p.parentNode.removeChild(p)},0)}}}();a.b("utils",a.a);a.b("utils.arrayForEach",a.a.D);a.b("utils.arrayFirst",a.a.Lb);a.b("utils.arrayFilter",a.a.jb);a.b("utils.arrayGetDistinctValues",a.a.wc);a.b("utils.arrayIndexOf",a.a.A);a.b("utils.arrayMap",a.a.Mb);a.b("utils.arrayPushAll",a.a.Nb);a.b("utils.arrayRemoveItem",a.a.Pa);a.b("utils.cloneNodes",a.a.Ca);a.b("utils.createSymbolOrString",\na.a.Da);a.b("utils.extend",a.a.extend);a.b("utils.fieldsIncludedWithJsonPost",a.a.Jc);a.b("utils.getFormFields",a.a.Lc);a.b("utils.objectMap",a.a.Ga);a.b("utils.peekObservable",a.a.bc);a.b("utils.postJson",a.a.Od);a.b("utils.parseJson",a.a.Nd);a.b("utils.registerEventHandler",a.a.B);a.b("utils.stringifyJson",a.a.hc);a.b("utils.range",a.a.Pd);a.b("utils.toggleDomNodeCssClass",a.a.Eb);a.b("utils.triggerEvent",a.a.Fb);a.b("utils.unwrapObservable",a.a.f);a.b("utils.objectForEach",a.a.P);a.b("utils.addOrRemoveItem",\na.a.Na);a.b("utils.setTextContent",a.a.Bb);a.b("unwrap",a.a.f);Function.prototype.bind||(Function.prototype.bind=function(a){var c=this;if(1===arguments.length)return function(){return c.apply(a,arguments)};var d=Array.prototype.slice.call(arguments,1);return function(){var e=d.slice(0);e.push.apply(e,arguments);return c.apply(a,e)}});a.a.g=new function(){var b=0,c="__ko__"+(new Date).getTime(),d={},e,f;a.a.W?(e=function(a,e){var f=a[c];if(!f||"null"===f||!d[f]){if(!e)return n;f=a[c]="ko"+b++;d[f]=\n{}}return d[f]},f=function(a){var b=a[c];return b?(delete d[b],a[c]=null,!0):!1}):(e=function(a,b){var d=a[c];!d&&b&&(d=a[c]={});return d},f=function(a){return a[c]?(delete a[c],!0):!1});return{get:function(a,b){var c=e(a,!1);return c&&c[b]},set:function(a,b,c){(a=e(a,c!==n))&&(a[b]=c)},Ub:function(a,b,c){a=e(a,!0);return a[b]||(a[b]=c)},clear:f,Z:function(){return b++ +c}}};a.b("utils.domData",a.a.g);a.b("utils.domData.clear",a.a.g.clear);a.a.K=new function(){function b(b,c){var d=a.a.g.get(b,e);\nd===n&&c&&(d=[],a.a.g.set(b,e,d));return d}function c(c){var e=b(c,!1);if(e)for(var e=e.slice(0),k=0;k<e.length;k++)e[k](c);a.a.g.clear(c);a.a.K.cleanExternalData(c);g[c.nodeType]&&d(c.childNodes,!0)}function d(b,d){for(var e=[],l,f=0;f<b.length;f++)if(!d||8===b[f].nodeType)if(c(e[e.length]=l=b[f]),b[f]!==l)for(;f--&&-1==a.a.A(e,b[f]););}var e=a.a.g.Z(),f={1:!0,8:!0,9:!0},g={1:!0,9:!0};return{za:function(a,c){if("function"!=typeof c)throw Error("Callback must be a function");b(a,!0).push(c)},yb:function(c,\nd){var f=b(c,!1);f&&(a.a.Pa(f,d),0==f.length&&a.a.g.set(c,e,n))},oa:function(b){a.u.G(function(){f[b.nodeType]&&(c(b),g[b.nodeType]&&d(b.getElementsByTagName("*")))});return b},removeNode:function(b){a.oa(b);b.parentNode&&b.parentNode.removeChild(b)},cleanExternalData:function(a){v&&"function"==typeof v.cleanData&&v.cleanData([a])}}};a.oa=a.a.K.oa;a.removeNode=a.a.K.removeNode;a.b("cleanNode",a.oa);a.b("removeNode",a.removeNode);a.b("utils.domNodeDisposal",a.a.K);a.b("utils.domNodeDisposal.addDisposeCallback",\na.a.K.za);a.b("utils.domNodeDisposal.removeDisposeCallback",a.a.K.yb);(function(){var b=[0,"",""],c=[1,"<table>","</table>"],d=[3,"<table><tbody><tr>","</tr></tbody></table>"],e=[1,"<select multiple=\'multiple\'>","</select>"],f={thead:c,tbody:c,tfoot:c,tr:[2,"<table><tbody>","</tbody></table>"],td:d,th:d,option:e,optgroup:e},g=8>=a.a.W;a.a.ua=function(c,d){var e;if(v)if(v.parseHTML)e=v.parseHTML(c,d)||[];else{if((e=v.clean([c],d))&&e[0]){for(var l=e[0];l.parentNode&&11!==l.parentNode.nodeType;)l=l.parentNode;\nl.parentNode&&l.parentNode.removeChild(l)}}else{(e=d)||(e=w);var l=e.parentWindow||e.defaultView||A,p=a.a.Db(c).toLowerCase(),q=e.createElement("div"),t;t=(p=p.match(/^(?:\\x3c!--.*?--\\x3e\\s*?)*?<([a-z]+)[\\s>]/))&&f[p[1]]||b;p=t[0];t="ignored<div>"+t[1]+c+t[2]+"</div>";"function"==typeof l.innerShiv?q.appendChild(l.innerShiv(t)):(g&&e.body.appendChild(q),q.innerHTML=t,g&&q.parentNode.removeChild(q));for(;p--;)q=q.lastChild;e=a.a.la(q.lastChild.childNodes)}return e};a.a.Md=function(b,c){var d=a.a.ua(b,\nc);return d.length&&d[0].parentElement||a.a.Yb(d)};a.a.fc=function(b,c){a.a.Tb(b);c=a.a.f(c);if(null!==c&&c!==n)if("string"!=typeof c&&(c=c.toString()),v)v(b).html(c);else for(var d=a.a.ua(c,b.ownerDocument),e=0;e<d.length;e++)b.appendChild(d[e])}})();a.b("utils.parseHtmlFragment",a.a.ua);a.b("utils.setHtml",a.a.fc);a.aa=function(){function b(c,e){if(c)if(8==c.nodeType){var f=a.aa.Uc(c.nodeValue);null!=f&&e.push({ud:c,Kd:f})}else if(1==c.nodeType)for(var f=0,g=c.childNodes,h=g.length;f<h;f++)b(g[f],\ne)}var c={};return{Xb:function(a){if("function"!=typeof a)throw Error("You can only pass a function to ko.memoization.memoize()");var b=(4294967296*(1+Math.random())|0).toString(16).substring(1)+(4294967296*(1+Math.random())|0).toString(16).substring(1);c[b]=a;return"\\x3c!--[ko_memo:"+b+"]--\\x3e"},bd:function(a,b){var f=c[a];if(f===n)throw Error("Couldn\'t find any memo with ID "+a+". Perhaps it\'s already been unmemoized.");try{return f.apply(null,b||[]),!0}finally{delete c[a]}},cd:function(c,e){var f=\n[];b(c,f);for(var g=0,h=f.length;g<h;g++){var m=f[g].ud,k=[m];e&&a.a.Nb(k,e);a.aa.bd(f[g].Kd,k);m.nodeValue="";m.parentNode&&m.parentNode.removeChild(m)}},Uc:function(a){return(a=a.match(/^\\[ko_memo\\:(.*?)\\]$/))?a[1]:null}}}();a.b("memoization",a.aa);a.b("memoization.memoize",a.aa.Xb);a.b("memoization.unmemoize",a.aa.bd);a.b("memoization.parseMemoText",a.aa.Uc);a.b("memoization.unmemoizeDomNodeAndDescendants",a.aa.cd);a.na=function(){function b(){if(f)for(var b=f,c=0,d;h<f;)if(d=e[h++]){if(h>b){if(5E3<=\n++c){h=f;a.a.Gc(Error("\'Too much recursion\' after processing "+c+" task groups."));break}b=f}try{d()}catch(p){a.a.Gc(p)}}}function c(){b();h=f=e.length=0}var d,e=[],f=0,g=1,h=0;A.MutationObserver?d=function(a){var b=w.createElement("div");(new MutationObserver(a)).observe(b,{attributes:!0});return function(){b.classList.toggle("foo")}}(c):d=w&&"onreadystatechange"in w.createElement("script")?function(a){var b=w.createElement("script");b.onreadystatechange=function(){b.onreadystatechange=null;w.documentElement.removeChild(b);\nb=null;a()};w.documentElement.appendChild(b)}:function(a){setTimeout(a,0)};return{scheduler:d,zb:function(b){f||a.na.scheduler(c);e[f++]=b;return g++},cancel:function(a){a=a-(g-f);a>=h&&a<f&&(e[a]=null)},resetForTesting:function(){var a=f-h;h=f=e.length=0;return a},Sd:b}}();a.b("tasks",a.na);a.b("tasks.schedule",a.na.zb);a.b("tasks.runEarly",a.na.Sd);a.Ta={throttle:function(b,c){b.throttleEvaluation=c;var d=null;return a.$({read:b,write:function(e){clearTimeout(d);d=a.a.setTimeout(function(){b(e)},\nc)}})},rateLimit:function(a,c){var d,e,f;"number"==typeof c?d=c:(d=c.timeout,e=c.method);a.Hb=!1;f="function"==typeof e?e:"notifyWhenChangesStop"==e?Y:X;a.ub(function(a){return f(a,d,c)})},deferred:function(b,c){if(!0!==c)throw Error("The \'deferred\' extender only accepts the value \'true\', because it is not supported to turn deferral off once enabled.");b.Hb||(b.Hb=!0,b.ub(function(c){var e,f=!1;return function(){if(!f){a.na.cancel(e);e=a.na.zb(c);try{f=!0,b.notifySubscribers(n,"dirty")}finally{f=\n!1}}}}))},notify:function(a,c){a.equalityComparer="always"==c?null:K}};var W={undefined:1,"boolean":1,number:1,string:1};a.b("extenders",a.Ta);a.ic=function(b,c,d){this.da=b;this.lc=c;this.mc=d;this.Ib=!1;this.fb=this.Jb=null;a.L(this,"dispose",this.s);a.L(this,"disposeWhenNodeIsRemoved",this.l)};a.ic.prototype.s=function(){this.Ib||(this.fb&&a.a.K.yb(this.Jb,this.fb),this.Ib=!0,this.mc(),this.da=this.lc=this.mc=this.Jb=this.fb=null)};a.ic.prototype.l=function(b){this.Jb=b;a.a.K.za(b,this.fb=this.s.bind(this))};\na.T=function(){a.a.Ab(this,D);D.qb(this)};var D={qb:function(a){a.U={change:[]};a.sc=1},subscribe:function(b,c,d){var e=this;d=d||"change";var f=new a.ic(e,c?b.bind(c):b,function(){a.a.Pa(e.U[d],f);e.hb&&e.hb(d)});e.Qa&&e.Qa(d);e.U[d]||(e.U[d]=[]);e.U[d].push(f);return f},notifySubscribers:function(b,c){c=c||"change";"change"===c&&this.Gb();if(this.Wa(c)){var d="change"===c&&this.ed||this.U[c].slice(0);try{a.u.xc();for(var e=0,f;f=d[e];++e)f.Ib||f.lc(b)}finally{a.u.end()}}},ob:function(){return this.sc},\nDd:function(a){return this.ob()!==a},Gb:function(){++this.sc},ub:function(b){var c=this,d=a.O(c),e,f,g,h,m;c.gb||(c.gb=c.notifySubscribers,c.notifySubscribers=Z);var k=b(function(){c.Ja=!1;d&&h===c&&(h=c.nc?c.nc():c());var a=f||m&&c.sb(g,h);m=f=e=!1;a&&c.gb(g=h)});c.qc=function(a,b){b&&c.Ja||(m=!b);c.ed=c.U.change.slice(0);c.Ja=e=!0;h=a;k()};c.pc=function(a){e||(g=a,c.gb(a,"beforeChange"))};c.rc=function(){m=!0};c.gd=function(){c.sb(g,c.v(!0))&&(f=!0)}},Wa:function(a){return this.U[a]&&this.U[a].length},\nBd:function(b){if(b)return this.U[b]&&this.U[b].length||0;var c=0;a.a.P(this.U,function(a,b){"dirty"!==a&&(c+=b.length)});return c},sb:function(a,c){return!this.equalityComparer||!this.equalityComparer(a,c)},toString:function(){return"[object Object]"},extend:function(b){var c=this;b&&a.a.P(b,function(b,e){var f=a.Ta[b];"function"==typeof f&&(c=f(c,e)||c)});return c}};a.L(D,"init",D.qb);a.L(D,"subscribe",D.subscribe);a.L(D,"extend",D.extend);a.L(D,"getSubscriptionsCount",D.Bd);a.a.Ba&&a.a.setPrototypeOf(D,\nFunction.prototype);a.T.fn=D;a.Qc=function(a){return null!=a&&"function"==typeof a.subscribe&&"function"==typeof a.notifySubscribers};a.b("subscribable",a.T);a.b("isSubscribable",a.Qc);a.S=a.u=function(){function b(a){d.push(e);e=a}function c(){e=d.pop()}var d=[],e,f=0;return{xc:b,end:c,cc:function(b){if(e){if(!a.Qc(b))throw Error("Only subscribable things can act as dependencies");e.od.call(e.pd,b,b.fd||(b.fd=++f))}},G:function(a,d,e){try{return b(),a.apply(d,e||[])}finally{c()}},qa:function(){if(e)return e.o.qa()},\nVa:function(){if(e)return e.o.Va()},Ya:function(){if(e)return e.Ya},o:function(){if(e)return e.o}}}();a.b("computedContext",a.S);a.b("computedContext.getDependenciesCount",a.S.qa);a.b("computedContext.getDependencies",a.S.Va);a.b("computedContext.isInitial",a.S.Ya);a.b("computedContext.registerDependency",a.S.cc);a.b("ignoreDependencies",a.Yd=a.u.G);var I=a.a.Da("_latestValue");a.ta=function(b){function c(){if(0<arguments.length)return c.sb(c[I],arguments[0])&&(c.ya(),c[I]=arguments[0],c.xa()),this;\na.u.cc(c);return c[I]}c[I]=b;a.a.Ba||a.a.extend(c,a.T.fn);a.T.fn.qb(c);a.a.Ab(c,F);a.options.deferUpdates&&a.Ta.deferred(c,!0);return c};var F={equalityComparer:K,v:function(){return this[I]},xa:function(){this.notifySubscribers(this[I],"spectate");this.notifySubscribers(this[I])},ya:function(){this.notifySubscribers(this[I],"beforeChange")}};a.a.Ba&&a.a.setPrototypeOf(F,a.T.fn);var G=a.ta.Ma="__ko_proto__";F[G]=a.ta;a.O=function(b){if((b="function"==typeof b&&b[G])&&b!==F[G]&&b!==a.o.fn[G])throw Error("Invalid object that looks like an observable; possibly from another Knockout instance");\nreturn!!b};a.Za=function(b){return"function"==typeof b&&(b[G]===F[G]||b[G]===a.o.fn[G]&&b.Nc)};a.b("observable",a.ta);a.b("isObservable",a.O);a.b("isWriteableObservable",a.Za);a.b("isWritableObservable",a.Za);a.b("observable.fn",F);a.L(F,"peek",F.v);a.L(F,"valueHasMutated",F.xa);a.L(F,"valueWillMutate",F.ya);a.Ha=function(b){b=b||[];if("object"!=typeof b||!("length"in b))throw Error("The argument passed when initializing an observable array must be an array, or null, or undefined.");b=a.ta(b);a.a.Ab(b,\na.Ha.fn);return b.extend({trackArrayChanges:!0})};a.Ha.fn={remove:function(b){for(var c=this.v(),d=[],e="function"!=typeof b||a.O(b)?function(a){return a===b}:b,f=0;f<c.length;f++){var g=c[f];if(e(g)){0===d.length&&this.ya();if(c[f]!==g)throw Error("Array modified during remove; cannot remove item");d.push(g);c.splice(f,1);f--}}d.length&&this.xa();return d},removeAll:function(b){if(b===n){var c=this.v(),d=c.slice(0);this.ya();c.splice(0,c.length);this.xa();return d}return b?this.remove(function(c){return 0<=\na.a.A(b,c)}):[]},destroy:function(b){var c=this.v(),d="function"!=typeof b||a.O(b)?function(a){return a===b}:b;this.ya();for(var e=c.length-1;0<=e;e--){var f=c[e];d(f)&&(f._destroy=!0)}this.xa()},destroyAll:function(b){return b===n?this.destroy(function(){return!0}):b?this.destroy(function(c){return 0<=a.a.A(b,c)}):[]},indexOf:function(b){var c=this();return a.a.A(c,b)},replace:function(a,c){var d=this.indexOf(a);0<=d&&(this.ya(),this.v()[d]=c,this.xa())},sorted:function(a){var c=this().slice(0);\nreturn a?c.sort(a):c.sort()},reversed:function(){return this().slice(0).reverse()}};a.a.Ba&&a.a.setPrototypeOf(a.Ha.fn,a.ta.fn);a.a.D("pop push reverse shift sort splice unshift".split(" "),function(b){a.Ha.fn[b]=function(){var a=this.v();this.ya();this.zc(a,b,arguments);var d=a[b].apply(a,arguments);this.xa();return d===a?this:d}});a.a.D(["slice"],function(b){a.Ha.fn[b]=function(){var a=this();return a[b].apply(a,arguments)}});a.Pc=function(b){return a.O(b)&&"function"==typeof b.remove&&"function"==\ntypeof b.push};a.b("observableArray",a.Ha);a.b("isObservableArray",a.Pc);a.Ta.trackArrayChanges=function(b,c){function d(){function c(){if(m){var d=[].concat(b.v()||[]),e;if(b.Wa("arrayChange")){if(!f||1<m)f=a.a.Pb(k,d,b.Ob);e=f}k=d;f=null;m=0;e&&e.length&&b.notifySubscribers(e,"arrayChange")}}e?c():(e=!0,h=b.subscribe(function(){++m},null,"spectate"),k=[].concat(b.v()||[]),f=null,g=b.subscribe(c))}b.Ob={};c&&"object"==typeof c&&a.a.extend(b.Ob,c);b.Ob.sparse=!0;if(!b.zc){var e=!1,f=null,g,h,m=0,\nk,l=b.Qa,p=b.hb;b.Qa=function(a){l&&l.call(b,a);"arrayChange"===a&&d()};b.hb=function(a){p&&p.call(b,a);"arrayChange"!==a||b.Wa("arrayChange")||(g&&g.s(),h&&h.s(),h=g=null,e=!1,k=n)};b.zc=function(b,c,d){function l(a,b,c){return k[k.length]={status:a,value:b,index:c}}if(e&&!m){var k=[],p=b.length,g=d.length,h=0;switch(c){case "push":h=p;case "unshift":for(c=0;c<g;c++)l("added",d[c],h+c);break;case "pop":h=p-1;case "shift":p&&l("deleted",b[h],h);break;case "splice":c=Math.min(Math.max(0,0>d[0]?p+d[0]:\nd[0]),p);for(var p=1===g?p:Math.min(c+(d[1]||0),p),g=c+g-2,h=Math.max(p,g),U=[],L=[],n=2;c<h;++c,++n)c<p&&L.push(l("deleted",b[c],c)),c<g&&U.push(l("added",d[n],c));a.a.Kc(L,U);break;default:return}f=k}}}};var r=a.a.Da("_state");a.o=a.$=function(b,c,d){function e(){if(0<arguments.length){if("function"===typeof f)f.apply(g.nb,arguments);else throw Error("Cannot write a value to a ko.computed unless you specify a \'write\' option. If you wish to read the current value, don\'t pass any parameters.");return this}g.ra||\na.u.cc(e);(g.ka||g.J&&e.Xa())&&e.ha();return g.X}"object"===typeof b?d=b:(d=d||{},b&&(d.read=b));if("function"!=typeof d.read)throw Error("Pass a function that returns the value of the ko.computed");var f=d.write,g={X:n,sa:!0,ka:!0,rb:!1,jc:!1,ra:!1,wb:!1,J:!1,Wc:d.read,nb:c||d.owner,l:d.disposeWhenNodeIsRemoved||d.l||null,Sa:d.disposeWhen||d.Sa,Rb:null,I:{},V:0,Ic:null};e[r]=g;e.Nc="function"===typeof f;a.a.Ba||a.a.extend(e,a.T.fn);a.T.fn.qb(e);a.a.Ab(e,C);d.pure?(g.wb=!0,g.J=!0,a.a.extend(e,da)):\nd.deferEvaluation&&a.a.extend(e,ea);a.options.deferUpdates&&a.Ta.deferred(e,!0);g.l&&(g.jc=!0,g.l.nodeType||(g.l=null));g.J||d.deferEvaluation||e.ha();g.l&&e.ja()&&a.a.K.za(g.l,g.Rb=function(){e.s()});return e};var C={equalityComparer:K,qa:function(){return this[r].V},Va:function(){var b=[];a.a.P(this[r].I,function(a,d){b[d.Ka]=d.da});return b},Vb:function(b){if(!this[r].V)return!1;var c=this.Va();return-1!==a.a.A(c,b)?!0:!!a.a.Lb(c,function(a){return a.Vb&&a.Vb(b)})},uc:function(a,c,d){if(this[r].wb&&\nc===this)throw Error("A \'pure\' computed must not be called recursively");this[r].I[a]=d;d.Ka=this[r].V++;d.La=c.ob()},Xa:function(){var a,c,d=this[r].I;for(a in d)if(Object.prototype.hasOwnProperty.call(d,a)&&(c=d[a],this.Ia&&c.da.Ja||c.da.Dd(c.La)))return!0},Jd:function(){this.Ia&&!this[r].rb&&this.Ia(!1)},ja:function(){var a=this[r];return a.ka||0<a.V},Rd:function(){this.Ja?this[r].ka&&(this[r].sa=!0):this.Hc()},$c:function(a){if(a.Hb){var c=a.subscribe(this.Jd,this,"dirty"),d=a.subscribe(this.Rd,\nthis);return{da:a,s:function(){c.s();d.s()}}}return a.subscribe(this.Hc,this)},Hc:function(){var b=this,c=b.throttleEvaluation;c&&0<=c?(clearTimeout(this[r].Ic),this[r].Ic=a.a.setTimeout(function(){b.ha(!0)},c)):b.Ia?b.Ia(!0):b.ha(!0)},ha:function(b){var c=this[r],d=c.Sa,e=!1;if(!c.rb&&!c.ra){if(c.l&&!a.a.Sb(c.l)||d&&d()){if(!c.jc){this.s();return}}else c.jc=!1;c.rb=!0;try{e=this.zd(b)}finally{c.rb=!1}return e}},zd:function(b){var c=this[r],d=!1,e=c.wb?n:!c.V,d={qd:this,mb:c.I,Qb:c.V};a.u.xc({pd:d,\nod:ba,o:this,Ya:e});c.I={};c.V=0;var f=this.yd(c,d);c.V?d=this.sb(c.X,f):(this.s(),d=!0);d&&(c.J?this.Gb():this.notifySubscribers(c.X,"beforeChange"),c.X=f,this.notifySubscribers(c.X,"spectate"),!c.J&&b&&this.notifySubscribers(c.X),this.rc&&this.rc());e&&this.notifySubscribers(c.X,"awake");return d},yd:function(b,c){try{var d=b.Wc;return b.nb?d.call(b.nb):d()}finally{a.u.end(),c.Qb&&!b.J&&a.a.P(c.mb,aa),b.sa=b.ka=!1}},v:function(a){var c=this[r];(c.ka&&(a||!c.V)||c.J&&this.Xa())&&this.ha();return c.X},\nub:function(b){a.T.fn.ub.call(this,b);this.nc=function(){this[r].J||(this[r].sa?this.ha():this[r].ka=!1);return this[r].X};this.Ia=function(a){this.pc(this[r].X);this[r].ka=!0;a&&(this[r].sa=!0);this.qc(this,!a)}},s:function(){var b=this[r];!b.J&&b.I&&a.a.P(b.I,function(a,b){b.s&&b.s()});b.l&&b.Rb&&a.a.K.yb(b.l,b.Rb);b.I=n;b.V=0;b.ra=!0;b.sa=!1;b.ka=!1;b.J=!1;b.l=n;b.Sa=n;b.Wc=n;this.Nc||(b.nb=n)}},da={Qa:function(b){var c=this,d=c[r];if(!d.ra&&d.J&&"change"==b){d.J=!1;if(d.sa||c.Xa())d.I=null,d.V=\n0,c.ha()&&c.Gb();else{var e=[];a.a.P(d.I,function(a,b){e[b.Ka]=a});a.a.D(e,function(a,b){var e=d.I[a],m=c.$c(e.da);m.Ka=b;m.La=e.La;d.I[a]=m});c.Xa()&&c.ha()&&c.Gb()}d.ra||c.notifySubscribers(d.X,"awake")}},hb:function(b){var c=this[r];c.ra||"change"!=b||this.Wa("change")||(a.a.P(c.I,function(a,b){b.s&&(c.I[a]={da:b.da,Ka:b.Ka,La:b.La},b.s())}),c.J=!0,this.notifySubscribers(n,"asleep"))},ob:function(){var b=this[r];b.J&&(b.sa||this.Xa())&&this.ha();return a.T.fn.ob.call(this)}},ea={Qa:function(a){"change"!=\na&&"beforeChange"!=a||this.v()}};a.a.Ba&&a.a.setPrototypeOf(C,a.T.fn);var N=a.ta.Ma;C[N]=a.o;a.Oc=function(a){return"function"==typeof a&&a[N]===C[N]};a.Fd=function(b){return a.Oc(b)&&b[r]&&b[r].wb};a.b("computed",a.o);a.b("dependentObservable",a.o);a.b("isComputed",a.Oc);a.b("isPureComputed",a.Fd);a.b("computed.fn",C);a.L(C,"peek",C.v);a.L(C,"dispose",C.s);a.L(C,"isActive",C.ja);a.L(C,"getDependenciesCount",C.qa);a.L(C,"getDependencies",C.Va);a.xb=function(b,c){if("function"===typeof b)return a.o(b,\nc,{pure:!0});b=a.a.extend({},b);b.pure=!0;return a.o(b,c)};a.b("pureComputed",a.xb);(function(){function b(a,f,g){g=g||new d;a=f(a);if("object"!=typeof a||null===a||a===n||a instanceof RegExp||a instanceof Date||a instanceof String||a instanceof Number||a instanceof Boolean)return a;var h=a instanceof Array?[]:{};g.save(a,h);c(a,function(c){var d=f(a[c]);switch(typeof d){case "boolean":case "number":case "string":case "function":h[c]=d;break;case "object":case "undefined":var l=g.get(d);h[c]=l!==\nn?l:b(d,f,g)}});return h}function c(a,b){if(a instanceof Array){for(var c=0;c<a.length;c++)b(c);"function"==typeof a.toJSON&&b("toJSON")}else for(c in a)b(c)}function d(){this.keys=[];this.values=[]}a.ad=function(c){if(0==arguments.length)throw Error("When calling ko.toJS, pass the object you want to convert.");return b(c,function(b){for(var c=0;a.O(b)&&10>c;c++)b=b();return b})};a.toJSON=function(b,c,d){b=a.ad(b);return a.a.hc(b,c,d)};d.prototype={constructor:d,save:function(b,c){var d=a.a.A(this.keys,\nb);0<=d?this.values[d]=c:(this.keys.push(b),this.values.push(c))},get:function(b){b=a.a.A(this.keys,b);return 0<=b?this.values[b]:n}}})();a.b("toJS",a.ad);a.b("toJSON",a.toJSON);a.Wd=function(b,c,d){function e(c){var e=a.xb(b,d).extend({ma:"always"}),h=e.subscribe(function(a){a&&(h.s(),c(a))});e.notifySubscribers(e.v());return h}return"function"!==typeof Promise||c?e(c.bind(d)):new Promise(e)};a.b("when",a.Wd);(function(){a.w={M:function(b){switch(a.a.R(b)){case "option":return!0===b.__ko__hasDomDataOptionValue__?\na.a.g.get(b,a.c.options.$b):7>=a.a.W?b.getAttributeNode("value")&&b.getAttributeNode("value").specified?b.value:b.text:b.value;case "select":return 0<=b.selectedIndex?a.w.M(b.options[b.selectedIndex]):n;default:return b.value}},cb:function(b,c,d){switch(a.a.R(b)){case "option":"string"===typeof c?(a.a.g.set(b,a.c.options.$b,n),"__ko__hasDomDataOptionValue__"in b&&delete b.__ko__hasDomDataOptionValue__,b.value=c):(a.a.g.set(b,a.c.options.$b,c),b.__ko__hasDomDataOptionValue__=!0,b.value="number"===\ntypeof c?c:"");break;case "select":if(""===c||null===c)c=n;for(var e=-1,f=0,g=b.options.length,h;f<g;++f)if(h=a.w.M(b.options[f]),h==c||""===h&&c===n){e=f;break}if(d||0<=e||c===n&&1<b.size)b.selectedIndex=e,6===a.a.W&&a.a.setTimeout(function(){b.selectedIndex=e},0);break;default:if(null===c||c===n)c="";b.value=c}}}})();a.b("selectExtensions",a.w);a.b("selectExtensions.readValue",a.w.M);a.b("selectExtensions.writeValue",a.w.cb);a.m=function(){function b(b){b=a.a.Db(b);123===b.charCodeAt(0)&&(b=b.slice(1,\n-1));b+="\\n,";var c=[],d=b.match(e),p,q=[],h=0;if(1<d.length){for(var x=0,B;B=d[x];++x){var u=B.charCodeAt(0);if(44===u){if(0>=h){c.push(p&&q.length?{key:p,value:q.join("")}:{unknown:p||q.join("")});p=h=0;q=[];continue}}else if(58===u){if(!h&&!p&&1===q.length){p=q.pop();continue}}else if(47===u&&1<B.length&&(47===B.charCodeAt(1)||42===B.charCodeAt(1)))continue;else 47===u&&x&&1<B.length?(u=d[x-1].match(f))&&!g[u[0]]&&(b=b.substr(b.indexOf(B)+1),d=b.match(e),x=-1,B="/"):40===u||123===u||91===u?++h:\n41===u||125===u||93===u?--h:p||q.length||34!==u&&39!==u||(B=B.slice(1,-1));q.push(B)}if(0<h)throw Error("Unbalanced parentheses, braces, or brackets");}return c}var c=["true","false","null","undefined"],d=/^(?:[$_a-z][$\\w]*|(.+)(\\.\\s*[$_a-z][$\\w]*|\\[.+\\]))$/i,e=RegExp("\\"(?:\\\\\\\\.|[^\\"])*\\"|\'(?:\\\\\\\\.|[^\'])*\'|`(?:\\\\\\\\.|[^`])*`|/\\\\*(?:[^*]|\\\\*+[^*/])*\\\\*+/|//.*\\n|/(?:\\\\\\\\.|[^/])+/w*|[^\\\\s:,/][^,\\"\'`{}()/:[\\\\]]*[^\\\\s,\\"\'`{}()/:[\\\\]]|[^\\\\s]","g"),f=/[\\])"\'A-Za-z0-9_$]+$/,g={"in":1,"return":1,"typeof":1},\nh={};return{Ra:[],wa:h,ac:b,vb:function(e,f){function l(b,e){var f;if(!x){var k=a.getBindingHandler(b);if(k&&k.preprocess&&!(e=k.preprocess(e,b,l)))return;if(k=h[b])f=e,0<=a.a.A(c,f)?f=!1:(k=f.match(d),f=null===k?!1:k[1]?"Object("+k[1]+")"+k[2]:f),k=f;k&&q.push("\'"+("string"==typeof h[b]?h[b]:b)+"\':function(_z){"+f+"=_z}")}g&&(e="function(){return "+e+" }");p.push("\'"+b+"\':"+e)}f=f||{};var p=[],q=[],g=f.valueAccessors,x=f.bindingParams,B="string"===typeof e?b(e):e;a.a.D(B,function(a){l(a.key||a.unknown,\na.value)});q.length&&l("_ko_property_writers","{"+q.join(",")+" }");return p.join(",")},Id:function(a,b){for(var c=0;c<a.length;c++)if(a[c].key==b)return!0;return!1},eb:function(b,c,d,e,f){if(b&&a.O(b))!a.Za(b)||f&&b.v()===e||b(e);else if((b=c.get("_ko_property_writers"))&&b[d])b[d](e)}}}();a.b("expressionRewriting",a.m);a.b("expressionRewriting.bindingRewriteValidators",a.m.Ra);a.b("expressionRewriting.parseObjectLiteral",a.m.ac);a.b("expressionRewriting.preProcessBindings",a.m.vb);a.b("expressionRewriting._twoWayBindings",\na.m.wa);a.b("jsonExpressionRewriting",a.m);a.b("jsonExpressionRewriting.insertPropertyAccessorsIntoJson",a.m.vb);(function(){function b(a){return 8==a.nodeType&&g.test(f?a.text:a.nodeValue)}function c(a){return 8==a.nodeType&&h.test(f?a.text:a.nodeValue)}function d(d,e){for(var f=d,h=1,g=[];f=f.nextSibling;){if(c(f)&&(a.a.g.set(f,k,!0),h--,0===h))return g;g.push(f);b(f)&&h++}if(!e)throw Error("Cannot find closing comment tag to match: "+d.nodeValue);return null}function e(a,b){var c=d(a,b);return c?\n0<c.length?c[c.length-1].nextSibling:a.nextSibling:null}var f=w&&"\\x3c!--test--\\x3e"===w.createComment("test").text,g=f?/^\\x3c!--\\s*ko(?:\\s+([\\s\\S]+))?\\s*--\\x3e$/:/^\\s*ko(?:\\s+([\\s\\S]+))?\\s*$/,h=f?/^\\x3c!--\\s*\\/ko\\s*--\\x3e$/:/^\\s*\\/ko\\s*$/,m={ul:!0,ol:!0},k="__ko_matchedEndComment__";a.h={ea:{},childNodes:function(a){return b(a)?d(a):a.childNodes},Ea:function(c){if(b(c)){c=a.h.childNodes(c);for(var d=0,e=c.length;d<e;d++)a.removeNode(c[d])}else a.a.Tb(c)},va:function(c,d){if(b(c)){a.h.Ea(c);for(var e=\nc.nextSibling,f=0,k=d.length;f<k;f++)e.parentNode.insertBefore(d[f],e)}else a.a.va(c,d)},Vc:function(a,c){var d;b(a)?(d=a.nextSibling,a=a.parentNode):d=a.firstChild;d?c!==d&&a.insertBefore(c,d):a.appendChild(c)},Wb:function(c,d,e){e?(e=e.nextSibling,b(c)&&(c=c.parentNode),e?d!==e&&c.insertBefore(d,e):c.appendChild(d)):a.h.Vc(c,d)},firstChild:function(a){if(b(a))return!a.nextSibling||c(a.nextSibling)?null:a.nextSibling;if(a.firstChild&&c(a.firstChild))throw Error("Found invalid end comment, as the first child of "+\na);return a.firstChild},nextSibling:function(d){b(d)&&(d=e(d));if(d.nextSibling&&c(d.nextSibling)){var f=d.nextSibling;if(c(f)&&!a.a.g.get(f,k))throw Error("Found end comment without a matching opening comment, as child of "+d);return null}return d.nextSibling},Cd:b,Vd:function(a){return(a=(f?a.text:a.nodeValue).match(g))?a[1]:null},Sc:function(d){if(m[a.a.R(d)]){var f=d.firstChild;if(f){do if(1===f.nodeType){var k;k=f.firstChild;var h=null;if(k){do if(h)h.push(k);else if(b(k)){var g=e(k,!0);g?k=\ng:h=[k]}else c(k)&&(h=[k]);while(k=k.nextSibling)}if(k=h)for(h=f.nextSibling,g=0;g<k.length;g++)h?d.insertBefore(k[g],h):d.appendChild(k[g])}while(f=f.nextSibling)}}}}})();a.b("virtualElements",a.h);a.b("virtualElements.allowedBindings",a.h.ea);a.b("virtualElements.emptyNode",a.h.Ea);a.b("virtualElements.insertAfter",a.h.Wb);a.b("virtualElements.prepend",a.h.Vc);a.b("virtualElements.setDomNodeChildren",a.h.va);(function(){a.ga=function(){this.nd={}};a.a.extend(a.ga.prototype,{nodeHasBindings:function(b){switch(b.nodeType){case 1:return null!=\nb.getAttribute("data-bind")||a.j.getComponentNameForNode(b);case 8:return a.h.Cd(b);default:return!1}},getBindings:function(b,c){var d=this.getBindingsString(b,c),d=d?this.parseBindingsString(d,c,b):null;return a.j.tc(d,b,c,!1)},getBindingAccessors:function(b,c){var d=this.getBindingsString(b,c),d=d?this.parseBindingsString(d,c,b,{valueAccessors:!0}):null;return a.j.tc(d,b,c,!0)},getBindingsString:function(b){switch(b.nodeType){case 1:return b.getAttribute("data-bind");case 8:return a.h.Vd(b);default:return null}},\nparseBindingsString:function(b,c,d,e){try{var f=this.nd,g=b+(e&&e.valueAccessors||""),h;if(!(h=f[g])){var m,k="with($context){with($data||{}){return{"+a.m.vb(b,e)+"}}}";m=new Function("$context","$element",k);h=f[g]=m}return h(c,d)}catch(l){throw l.message="Unable to parse bindings.\\nBindings value: "+b+"\\nMessage: "+l.message,l;}}});a.ga.instance=new a.ga})();a.b("bindingProvider",a.ga);(function(){function b(b){var c=(b=a.a.g.get(b,z))&&b.N;c&&(b.N=null,c.Tc())}function c(c,d,e){this.node=c;this.yc=\nd;this.kb=[];this.H=!1;d.N||a.a.K.za(c,b);e&&e.N&&(e.N.kb.push(c),this.Kb=e)}function d(a){return function(){return a}}function e(a){return a()}function f(b){return a.a.Ga(a.u.G(b),function(a,c){return function(){return b()[c]}})}function g(b,c,e){return"function"===typeof b?f(b.bind(null,c,e)):a.a.Ga(b,d)}function h(a,b){return f(this.getBindings.bind(this,a,b))}function m(b,c){var d=a.h.firstChild(c);if(d){var e,f=a.ga.instance,l=f.preprocessNode;if(l){for(;e=d;)d=a.h.nextSibling(e),l.call(f,e);\nd=a.h.firstChild(c)}for(;e=d;)d=a.h.nextSibling(e),k(b,e)}a.i.ma(c,a.i.H)}function k(b,c){var d=b,e=1===c.nodeType;e&&a.h.Sc(c);if(e||a.ga.instance.nodeHasBindings(c))d=p(c,null,b).bindingContextForDescendants;d&&!u[a.a.R(c)]&&m(d,c)}function l(b){var c=[],d={},e=[];a.a.P(b,function ca(f){if(!d[f]){var k=a.getBindingHandler(f);k&&(k.after&&(e.push(f),a.a.D(k.after,function(c){if(b[c]){if(-1!==a.a.A(e,c))throw Error("Cannot combine the following bindings, because they have a cyclic dependency: "+e.join(", "));\nca(c)}}),e.length--),c.push({key:f,Mc:k}));d[f]=!0}});return c}function p(b,c,d){var f=a.a.g.Ub(b,z,{}),k=f.hd;if(!c){if(k)throw Error("You cannot apply bindings multiple times to the same element.");f.hd=!0}k||(f.context=d);f.Zb||(f.Zb={});var g;if(c&&"function"!==typeof c)g=c;else{var p=a.ga.instance,q=p.getBindingAccessors||h,m=a.$(function(){if(g=c?c(d,b):q.call(p,b,d)){if(d[t])d[t]();if(d[B])d[B]()}return g},null,{l:b});g&&m.ja()||(m=null)}var x=d,u;if(g){var J=function(){return a.a.Ga(m?m():\ng,e)},r=m?function(a){return function(){return e(m()[a])}}:function(a){return g[a]};J.get=function(a){return g[a]&&e(r(a))};J.has=function(a){return a in g};a.i.H in g&&a.i.subscribe(b,a.i.H,function(){var c=(0,g[a.i.H])();if(c){var d=a.h.childNodes(b);d.length&&c(d,a.Ec(d[0]))}});a.i.pa in g&&(x=a.i.Cb(b,d),a.i.subscribe(b,a.i.pa,function(){var c=(0,g[a.i.pa])();c&&a.h.firstChild(b)&&c(b)}));f=l(g);a.a.D(f,function(c){var d=c.Mc.init,e=c.Mc.update,f=c.key;if(8===b.nodeType&&!a.h.ea[f])throw Error("The binding \'"+\nf+"\' cannot be used with virtual elements");try{"function"==typeof d&&a.u.G(function(){var a=d(b,r(f),J,x.$data,x);if(a&&a.controlsDescendantBindings){if(u!==n)throw Error("Multiple bindings ("+u+" and "+f+") are trying to control descendant bindings of the same element. You cannot use these bindings together on the same element.");u=f}}),"function"==typeof e&&a.$(function(){e(b,r(f),J,x.$data,x)},null,{l:b})}catch(k){throw k.message=\'Unable to process binding "\'+f+": "+g[f]+\'"\\nMessage: \'+k.message,\nk;}})}f=u===n;return{shouldBindDescendants:f,bindingContextForDescendants:f&&x}}function q(b,c){return b&&b instanceof a.fa?b:new a.fa(b,n,n,c)}var t=a.a.Da("_subscribable"),x=a.a.Da("_ancestorBindingInfo"),B=a.a.Da("_dataDependency");a.c={};var u={script:!0,textarea:!0,template:!0};a.getBindingHandler=function(b){return a.c[b]};var J={};a.fa=function(b,c,d,e,f){function k(){var b=p?h():h,f=a.a.f(b);c?(a.a.extend(l,c),x in c&&(l[x]=c[x])):(l.$parents=[],l.$root=f,l.ko=a);l[t]=q;g?f=l.$data:(l.$rawData=\nb,l.$data=f);d&&(l[d]=f);e&&e(l,c,f);if(c&&c[t]&&!a.S.o().Vb(c[t]))c[t]();m&&(l[B]=m);return l.$data}var l=this,g=b===J,h=g?n:b,p="function"==typeof h&&!a.O(h),q,m=f&&f.dataDependency;f&&f.exportDependencies?k():(q=a.xb(k),q.v(),q.ja()?q.equalityComparer=null:l[t]=n)};a.fa.prototype.createChildContext=function(b,c,d,e){!e&&c&&"object"==typeof c&&(e=c,c=e.as,d=e.extend);if(c&&e&&e.noChildContext){var f="function"==typeof b&&!a.O(b);return new a.fa(J,this,null,function(a){d&&d(a);a[c]=f?b():b},e)}return new a.fa(b,\nthis,c,function(a,b){a.$parentContext=b;a.$parent=b.$data;a.$parents=(b.$parents||[]).slice(0);a.$parents.unshift(a.$parent);d&&d(a)},e)};a.fa.prototype.extend=function(b,c){return new a.fa(J,this,null,function(c){a.a.extend(c,"function"==typeof b?b(c):b)},c)};var z=a.a.g.Z();c.prototype.Tc=function(){this.Kb&&this.Kb.N&&this.Kb.N.sd(this.node)};c.prototype.sd=function(b){a.a.Pa(this.kb,b);!this.kb.length&&this.H&&this.Cc()};c.prototype.Cc=function(){this.H=!0;this.yc.N&&!this.kb.length&&(this.yc.N=\nnull,a.a.K.yb(this.node,b),a.i.ma(this.node,a.i.pa),this.Tc())};a.i={H:"childrenComplete",pa:"descendantsComplete",subscribe:function(b,c,d,e,f){var k=a.a.g.Ub(b,z,{});k.Fa||(k.Fa=new a.T);f&&f.notifyImmediately&&k.Zb[c]&&a.u.G(d,e,[b]);return k.Fa.subscribe(d,e,c)},ma:function(b,c){var d=a.a.g.get(b,z);if(d&&(d.Zb[c]=!0,d.Fa&&d.Fa.notifySubscribers(b,c),c==a.i.H))if(d.N)d.N.Cc();else if(d.N===n&&d.Fa&&d.Fa.Wa(a.i.pa))throw Error("descendantsComplete event not supported for bindings on this node");\n},Cb:function(b,d){var e=a.a.g.Ub(b,z,{});e.N||(e.N=new c(b,e,d[x]));return d[x]==e?d:d.extend(function(a){a[x]=e})}};a.Td=function(b){return(b=a.a.g.get(b,z))&&b.context};a.ib=function(b,c,d){1===b.nodeType&&a.h.Sc(b);return p(b,c,q(d))};a.ld=function(b,c,d){d=q(d);return a.ib(b,g(c,d,b),d)};a.Oa=function(a,b){1!==b.nodeType&&8!==b.nodeType||m(q(a),b)};a.vc=function(a,b,c){!v&&A.jQuery&&(v=A.jQuery);if(2>arguments.length){if(b=w.body,!b)throw Error("ko.applyBindings: could not find document.body; has the document been loaded?");\n}else if(!b||1!==b.nodeType&&8!==b.nodeType)throw Error("ko.applyBindings: first parameter should be your view model; second parameter should be a DOM node");k(q(a,c),b)};a.Dc=function(b){return!b||1!==b.nodeType&&8!==b.nodeType?n:a.Td(b)};a.Ec=function(b){return(b=a.Dc(b))?b.$data:n};a.b("bindingHandlers",a.c);a.b("bindingEvent",a.i);a.b("bindingEvent.subscribe",a.i.subscribe);a.b("bindingEvent.startPossiblyAsyncContentBinding",a.i.Cb);a.b("applyBindings",a.vc);a.b("applyBindingsToDescendants",a.Oa);\na.b("applyBindingAccessorsToNode",a.ib);a.b("applyBindingsToNode",a.ld);a.b("contextFor",a.Dc);a.b("dataFor",a.Ec)})();(function(b){function c(c,e){var k=Object.prototype.hasOwnProperty.call(f,c)?f[c]:b,l;k?k.subscribe(e):(k=f[c]=new a.T,k.subscribe(e),d(c,function(b,d){var e=!(!d||!d.synchronous);g[c]={definition:b,Gd:e};delete f[c];l||e?k.notifySubscribers(b):a.na.zb(function(){k.notifySubscribers(b)})}),l=!0)}function d(a,b){e("getConfig",[a],function(c){c?e("loadComponent",[a,c],function(a){b(a,\nc)}):b(null,null)})}function e(c,d,f,l){l||(l=a.j.loaders.slice(0));var g=l.shift();if(g){var q=g[c];if(q){var t=!1;if(q.apply(g,d.concat(function(a){t?f(null):null!==a?f(a):e(c,d,f,l)}))!==b&&(t=!0,!g.suppressLoaderExceptions))throw Error("Component loaders must supply values by invoking the callback, not by returning values synchronously.");}else e(c,d,f,l)}else f(null)}var f={},g={};a.j={get:function(d,e){var f=Object.prototype.hasOwnProperty.call(g,d)?g[d]:b;f?f.Gd?a.u.G(function(){e(f.definition)}):\na.na.zb(function(){e(f.definition)}):c(d,e)},Bc:function(a){delete g[a]},oc:e};a.j.loaders=[];a.b("components",a.j);a.b("components.get",a.j.get);a.b("components.clearCachedDefinition",a.j.Bc)})();(function(){function b(b,c,d,e){function g(){0===--B&&e(h)}var h={},B=2,u=d.template;d=d.viewModel;u?f(c,u,function(c){a.j.oc("loadTemplate",[b,c],function(a){h.template=a;g()})}):g();d?f(c,d,function(c){a.j.oc("loadViewModel",[b,c],function(a){h[m]=a;g()})}):g()}function c(a,b,d){if("function"===typeof b)d(function(a){return new b(a)});\nelse if("function"===typeof b[m])d(b[m]);else if("instance"in b){var e=b.instance;d(function(){return e})}else"viewModel"in b?c(a,b.viewModel,d):a("Unknown viewModel value: "+b)}function d(b){switch(a.a.R(b)){case "script":return a.a.ua(b.text);case "textarea":return a.a.ua(b.value);case "template":if(e(b.content))return a.a.Ca(b.content.childNodes)}return a.a.Ca(b.childNodes)}function e(a){return A.DocumentFragment?a instanceof DocumentFragment:a&&11===a.nodeType}function f(a,b,c){"string"===typeof b.require?\nT||A.require?(T||A.require)([b.require],function(a){a&&"object"===typeof a&&a.Xd&&a["default"]&&(a=a["default"]);c(a)}):a("Uses require, but no AMD loader is present"):c(b)}function g(a){return function(b){throw Error("Component \'"+a+"\': "+b);}}var h={};a.j.register=function(b,c){if(!c)throw Error("Invalid configuration for "+b);if(a.j.tb(b))throw Error("Component "+b+" is already registered");h[b]=c};a.j.tb=function(a){return Object.prototype.hasOwnProperty.call(h,a)};a.j.unregister=function(b){delete h[b];\na.j.Bc(b)};a.j.Fc={getConfig:function(b,c){c(a.j.tb(b)?h[b]:null)},loadComponent:function(a,c,d){var e=g(a);f(e,c,function(c){b(a,e,c,d)})},loadTemplate:function(b,c,f){b=g(b);if("string"===typeof c)f(a.a.ua(c));else if(c instanceof Array)f(c);else if(e(c))f(a.a.la(c.childNodes));else if(c.element)if(c=c.element,A.HTMLElement?c instanceof HTMLElement:c&&c.tagName&&1===c.nodeType)f(d(c));else if("string"===typeof c){var h=w.getElementById(c);h?f(d(h)):b("Cannot find element with ID "+c)}else b("Unknown element type: "+\nc);else b("Unknown template value: "+c)},loadViewModel:function(a,b,d){c(g(a),b,d)}};var m="createViewModel";a.b("components.register",a.j.register);a.b("components.isRegistered",a.j.tb);a.b("components.unregister",a.j.unregister);a.b("components.defaultLoader",a.j.Fc);a.j.loaders.push(a.j.Fc);a.j.dd=h})();(function(){function b(b,e){var f=b.getAttribute("params");if(f){var f=c.parseBindingsString(f,e,b,{valueAccessors:!0,bindingParams:!0}),f=a.a.Ga(f,function(c){return a.o(c,null,{l:b})}),g=a.a.Ga(f,\nfunction(c){var e=c.v();return c.ja()?a.o({read:function(){return a.a.f(c())},write:a.Za(e)&&function(a){c()(a)},l:b}):e});Object.prototype.hasOwnProperty.call(g,"$raw")||(g.$raw=f);return g}return{$raw:{}}}a.j.getComponentNameForNode=function(b){var c=a.a.R(b);if(a.j.tb(c)&&(-1!=c.indexOf("-")||"[object HTMLUnknownElement]"==""+b||8>=a.a.W&&b.tagName===c))return c};a.j.tc=function(c,e,f,g){if(1===e.nodeType){var h=a.j.getComponentNameForNode(e);if(h){c=c||{};if(c.component)throw Error(\'Cannot use the "component" binding on a custom element matching a component\');\nvar m={name:h,params:b(e,f)};c.component=g?function(){return m}:m}}return c};var c=new a.ga;9>a.a.W&&(a.j.register=function(a){return function(b){return a.apply(this,arguments)}}(a.j.register),w.createDocumentFragment=function(b){return function(){var c=b(),f=a.j.dd,g;for(g in f);return c}}(w.createDocumentFragment))})();(function(){function b(b,c,d){c=c.template;if(!c)throw Error("Component \'"+b+"\' has no template");b=a.a.Ca(c);a.h.va(d,b)}function c(a,b,c){var d=a.createViewModel;return d?d.call(a,\nb,c):b}var d=0;a.c.component={init:function(e,f,g,h,m){function k(){var a=l&&l.dispose;"function"===typeof a&&a.call(l);q&&q.s();p=l=q=null}var l,p,q,t=a.a.la(a.h.childNodes(e));a.h.Ea(e);a.a.K.za(e,k);a.o(function(){var g=a.a.f(f()),h,u;"string"===typeof g?h=g:(h=a.a.f(g.name),u=a.a.f(g.params));if(!h)throw Error("No component name specified");var n=a.i.Cb(e,m),z=p=++d;a.j.get(h,function(d){if(p===z){k();if(!d)throw Error("Unknown component \'"+h+"\'");b(h,d,e);var f=c(d,u,{element:e,templateNodes:t});\nd=n.createChildContext(f,{extend:function(a){a.$component=f;a.$componentTemplateNodes=t}});f&&f.koDescendantsComplete&&(q=a.i.subscribe(e,a.i.pa,f.koDescendantsComplete,f));l=f;a.Oa(d,e)}})},null,{l:e});return{controlsDescendantBindings:!0}}};a.h.ea.component=!0})();var V={"class":"className","for":"htmlFor"};a.c.attr={update:function(b,c){var d=a.a.f(c())||{};a.a.P(d,function(c,d){d=a.a.f(d);var g=c.indexOf(":"),g="lookupNamespaceURI"in b&&0<g&&b.lookupNamespaceURI(c.substr(0,g)),h=!1===d||null===\nd||d===n;h?g?b.removeAttributeNS(g,c):b.removeAttribute(c):d=d.toString();8>=a.a.W&&c in V?(c=V[c],h?b.removeAttribute(c):b[c]=d):h||(g?b.setAttributeNS(g,c,d):b.setAttribute(c,d));"name"===c&&a.a.Yc(b,h?"":d)})}};(function(){a.c.checked={after:["value","attr"],init:function(b,c,d){function e(){var e=b.checked,f=g();if(!a.S.Ya()&&(e||!m&&!a.S.qa())){var k=a.u.G(c);if(l){var q=p?k.v():k,z=t;t=f;z!==f?e&&(a.a.Na(q,f,!0),a.a.Na(q,z,!1)):a.a.Na(q,f,e);p&&a.Za(k)&&k(q)}else h&&(f===n?f=e:e||(f=n)),a.m.eb(k,\nd,"checked",f,!0)}}function f(){var d=a.a.f(c()),e=g();l?(b.checked=0<=a.a.A(d,e),t=e):b.checked=h&&e===n?!!d:g()===d}var g=a.xb(function(){if(d.has("checkedValue"))return a.a.f(d.get("checkedValue"));if(q)return d.has("value")?a.a.f(d.get("value")):b.value}),h="checkbox"==b.type,m="radio"==b.type;if(h||m){var k=c(),l=h&&a.a.f(k)instanceof Array,p=!(l&&k.push&&k.splice),q=m||l,t=l?g():n;m&&!b.name&&a.c.uniqueName.init(b,function(){return!0});a.o(e,null,{l:b});a.a.B(b,"click",e);a.o(f,null,{l:b});\nk=n}}};a.m.wa.checked=!0;a.c.checkedValue={update:function(b,c){b.value=a.a.f(c())}}})();a.c["class"]={update:function(b,c){var d=a.a.Db(a.a.f(c()));a.a.Eb(b,b.__ko__cssValue,!1);b.__ko__cssValue=d;a.a.Eb(b,d,!0)}};a.c.css={update:function(b,c){var d=a.a.f(c());null!==d&&"object"==typeof d?a.a.P(d,function(c,d){d=a.a.f(d);a.a.Eb(b,c,d)}):a.c["class"].update(b,c)}};a.c.enable={update:function(b,c){var d=a.a.f(c());d&&b.disabled?b.removeAttribute("disabled"):d||b.disabled||(b.disabled=!0)}};a.c.disable=\n{update:function(b,c){a.c.enable.update(b,function(){return!a.a.f(c())})}};a.c.event={init:function(b,c,d,e,f){var g=c()||{};a.a.P(g,function(g){"string"==typeof g&&a.a.B(b,g,function(b){var k,l=c()[g];if(l){try{var p=a.a.la(arguments);e=f.$data;p.unshift(e);k=l.apply(e,p)}finally{!0!==k&&(b.preventDefault?b.preventDefault():b.returnValue=!1)}!1===d.get(g+"Bubble")&&(b.cancelBubble=!0,b.stopPropagation&&b.stopPropagation())}})})}};a.c.foreach={Rc:function(b){return function(){var c=b(),d=a.a.bc(c);\nif(!d||"number"==typeof d.length)return{foreach:c,templateEngine:a.ba.Ma};a.a.f(c);return{foreach:d.data,as:d.as,noChildContext:d.noChildContext,includeDestroyed:d.includeDestroyed,afterAdd:d.afterAdd,beforeRemove:d.beforeRemove,afterRender:d.afterRender,beforeMove:d.beforeMove,afterMove:d.afterMove,templateEngine:a.ba.Ma}}},init:function(b,c){return a.c.template.init(b,a.c.foreach.Rc(c))},update:function(b,c,d,e,f){return a.c.template.update(b,a.c.foreach.Rc(c),d,e,f)}};a.m.Ra.foreach=!1;a.h.ea.foreach=\n!0;a.c.hasfocus={init:function(b,c,d){function e(e){b.__ko_hasfocusUpdating=!0;var f=b.ownerDocument;if("activeElement"in f){var g;try{g=f.activeElement}catch(l){g=f.body}e=g===b}f=c();a.m.eb(f,d,"hasfocus",e,!0);b.__ko_hasfocusLastValue=e;b.__ko_hasfocusUpdating=!1}var f=e.bind(null,!0),g=e.bind(null,!1);a.a.B(b,"focus",f);a.a.B(b,"focusin",f);a.a.B(b,"blur",g);a.a.B(b,"focusout",g);b.__ko_hasfocusLastValue=!1},update:function(b,c){var d=!!a.a.f(c());b.__ko_hasfocusUpdating||b.__ko_hasfocusLastValue===\nd||(d?b.focus():b.blur(),!d&&b.__ko_hasfocusLastValue&&b.ownerDocument.body.focus(),a.u.G(a.a.Fb,null,[b,d?"focusin":"focusout"]))}};a.m.wa.hasfocus=!0;a.c.hasFocus=a.c.hasfocus;a.m.wa.hasFocus="hasfocus";a.c.html={init:function(){return{controlsDescendantBindings:!0}},update:function(b,c){a.a.fc(b,c())}};(function(){function b(b,d,e){a.c[b]={init:function(b,c,h,m,k){var l,p,q={},t,x,n;if(d){m=h.get("as");var u=h.get("noChildContext");n=!(m&&u);q={as:m,noChildContext:u,exportDependencies:n}}x=(t=\n"render"==h.get("completeOn"))||h.has(a.i.pa);a.o(function(){var h=a.a.f(c()),m=!e!==!h,u=!p,r;if(n||m!==l){x&&(k=a.i.Cb(b,k));if(m){if(!d||n)q.dataDependency=a.S.o();r=d?k.createChildContext("function"==typeof h?h:c,q):a.S.qa()?k.extend(null,q):k}u&&a.S.qa()&&(p=a.a.Ca(a.h.childNodes(b),!0));m?(u||a.h.va(b,a.a.Ca(p)),a.Oa(r,b)):(a.h.Ea(b),t||a.i.ma(b,a.i.H));l=m}},null,{l:b});return{controlsDescendantBindings:!0}}};a.m.Ra[b]=!1;a.h.ea[b]=!0}b("if");b("ifnot",!1,!0);b("with",!0)})();a.c.let={init:function(b,\nc,d,e,f){c=f.extend(c);a.Oa(c,b);return{controlsDescendantBindings:!0}}};a.h.ea.let=!0;var Q={};a.c.options={init:function(b){if("select"!==a.a.R(b))throw Error("options binding applies only to SELECT elements");for(;0<b.length;)b.remove(0);return{controlsDescendantBindings:!0}},update:function(b,c,d){function e(){return a.a.jb(b.options,function(a){return a.selected})}function f(a,b,c){var d=typeof b;return"function"==d?b(a):"string"==d?a[b]:c}function g(c,d){if(x&&l)a.i.ma(b,a.i.H);else if(t.length){var e=\n0<=a.a.A(t,a.w.M(d[0]));a.a.Zc(d[0],e);x&&!e&&a.u.G(a.a.Fb,null,[b,"change"])}}var h=b.multiple,m=0!=b.length&&h?b.scrollTop:null,k=a.a.f(c()),l=d.get("valueAllowUnset")&&d.has("value"),p=d.get("optionsIncludeDestroyed");c={};var q,t=[];l||(h?t=a.a.Mb(e(),a.w.M):0<=b.selectedIndex&&t.push(a.w.M(b.options[b.selectedIndex])));k&&("undefined"==typeof k.length&&(k=[k]),q=a.a.jb(k,function(b){return p||b===n||null===b||!a.a.f(b._destroy)}),d.has("optionsCaption")&&(k=a.a.f(d.get("optionsCaption")),null!==\nk&&k!==n&&q.unshift(Q)));var x=!1;c.beforeRemove=function(a){b.removeChild(a)};k=g;d.has("optionsAfterRender")&&"function"==typeof d.get("optionsAfterRender")&&(k=function(b,c){g(0,c);a.u.G(d.get("optionsAfterRender"),null,[c[0],b!==Q?b:n])});a.a.ec(b,q,function(c,e,g){g.length&&(t=!l&&g[0].selected?[a.w.M(g[0])]:[],x=!0);e=b.ownerDocument.createElement("option");c===Q?(a.a.Bb(e,d.get("optionsCaption")),a.w.cb(e,n)):(g=f(c,d.get("optionsValue"),c),a.w.cb(e,a.a.f(g)),c=f(c,d.get("optionsText"),g),\na.a.Bb(e,c));return[e]},c,k);if(!l){var B;h?B=t.length&&e().length<t.length:B=t.length&&0<=b.selectedIndex?a.w.M(b.options[b.selectedIndex])!==t[0]:t.length||0<=b.selectedIndex;B&&a.u.G(a.a.Fb,null,[b,"change"])}(l||a.S.Ya())&&a.i.ma(b,a.i.H);a.a.wd(b);m&&20<Math.abs(m-b.scrollTop)&&(b.scrollTop=m)}};a.c.options.$b=a.a.g.Z();a.c.selectedOptions={init:function(b,c,d){function e(){var e=c(),f=[];a.a.D(b.getElementsByTagName("option"),function(b){b.selected&&f.push(a.w.M(b))});a.m.eb(e,d,"selectedOptions",\nf)}function f(){var d=a.a.f(c()),e=b.scrollTop;d&&"number"==typeof d.length&&a.a.D(b.getElementsByTagName("option"),function(b){var c=0<=a.a.A(d,a.w.M(b));b.selected!=c&&a.a.Zc(b,c)});b.scrollTop=e}if("select"!=a.a.R(b))throw Error("selectedOptions binding applies only to SELECT elements");var g;a.i.subscribe(b,a.i.H,function(){g?e():(a.a.B(b,"change",e),g=a.o(f,null,{l:b}))},null,{notifyImmediately:!0})},update:function(){}};a.m.wa.selectedOptions=!0;a.c.style={update:function(b,c){var d=a.a.f(c()||\n{});a.a.P(d,function(c,d){d=a.a.f(d);if(null===d||d===n||!1===d)d="";if(v)v(b).css(c,d);else if(/^--/.test(c))b.style.setProperty(c,d);else{c=c.replace(/-(\\w)/g,function(a,b){return b.toUpperCase()});var g=b.style[c];b.style[c]=d;d===g||b.style[c]!=g||isNaN(d)||(b.style[c]=d+"px")}})}};a.c.submit={init:function(b,c,d,e,f){if("function"!=typeof c())throw Error("The value for a submit binding must be a function");a.a.B(b,"submit",function(a){var d,e=c();try{d=e.call(f.$data,b)}finally{!0!==d&&(a.preventDefault?\na.preventDefault():a.returnValue=!1)}})}};a.c.text={init:function(){return{controlsDescendantBindings:!0}},update:function(b,c){a.a.Bb(b,c())}};a.h.ea.text=!0;(function(){if(A&&A.navigator){var b=function(a){if(a)return parseFloat(a[1])},c=A.navigator.userAgent,d,e,f,g,h;(d=A.opera&&A.opera.version&&parseInt(A.opera.version()))||(h=b(c.match(/Edge\\/([^ ]+)$/)))||b(c.match(/Chrome\\/([^ ]+)/))||(e=b(c.match(/Version\\/([^ ]+) Safari/)))||(f=b(c.match(/Firefox\\/([^ ]+)/)))||(g=a.a.W||b(c.match(/MSIE ([^ ]+)/)))||\n(g=b(c.match(/rv:([^ )]+)/)))}if(8<=g&&10>g)var m=a.a.g.Z(),k=a.a.g.Z(),l=function(b){var c=this.activeElement;(c=c&&a.a.g.get(c,k))&&c(b)},p=function(b,c){var d=b.ownerDocument;a.a.g.get(d,m)||(a.a.g.set(d,m,!0),a.a.B(d,"selectionchange",l));a.a.g.set(b,k,c)};a.c.textInput={init:function(b,c,k){function l(c,d){a.a.B(b,c,d)}function m(){var d=a.a.f(c());if(null===d||d===n)d="";L!==n&&d===L?a.a.setTimeout(m,4):b.value!==d&&(y=!0,b.value=d,y=!1,v=b.value)}function r(){w||(L=b.value,w=a.a.setTimeout(z,\n4))}function z(){clearTimeout(w);L=w=n;var d=b.value;v!==d&&(v=d,a.m.eb(c(),k,"textInput",d))}var v=b.value,w,L,A=9==a.a.W?r:z,y=!1;g&&l("keypress",z);11>g&&l("propertychange",function(a){y||"value"!==a.propertyName||A(a)});8==g&&(l("keyup",z),l("keydown",z));p&&(p(b,A),l("dragend",r));(!g||9<=g)&&l("input",A);5>e&&"textarea"===a.a.R(b)?(l("keydown",r),l("paste",r),l("cut",r)):11>d?l("keydown",r):4>f?(l("DOMAutoComplete",z),l("dragdrop",z),l("drop",z)):h&&"number"===b.type&&l("keydown",r);l("change",\nz);l("blur",z);a.o(m,null,{l:b})}};a.m.wa.textInput=!0;a.c.textinput={preprocess:function(a,b,c){c("textInput",a)}}})();a.c.uniqueName={init:function(b,c){if(c()){var d="ko_unique_"+ ++a.c.uniqueName.rd;a.a.Yc(b,d)}}};a.c.uniqueName.rd=0;a.c.using={init:function(b,c,d,e,f){var g;d.has("as")&&(g={as:d.get("as"),noChildContext:d.get("noChildContext")});c=f.createChildContext(c,g);a.Oa(c,b);return{controlsDescendantBindings:!0}}};a.h.ea.using=!0;a.c.value={init:function(b,c,d){var e=a.a.R(b),f="input"==\ne;if(!f||"checkbox"!=b.type&&"radio"!=b.type){var g=[],h=d.get("valueUpdate"),m=!1,k=null;h&&("string"==typeof h?g=[h]:g=a.a.wc(h),a.a.Pa(g,"change"));var l=function(){k=null;m=!1;var e=c(),f=a.w.M(b);a.m.eb(e,d,"value",f)};!a.a.W||!f||"text"!=b.type||"off"==b.autocomplete||b.form&&"off"==b.form.autocomplete||-1!=a.a.A(g,"propertychange")||(a.a.B(b,"propertychange",function(){m=!0}),a.a.B(b,"focus",function(){m=!1}),a.a.B(b,"blur",function(){m&&l()}));a.a.D(g,function(c){var d=l;a.a.Ud(c,"after")&&\n(d=function(){k=a.w.M(b);a.a.setTimeout(l,0)},c=c.substring(5));a.a.B(b,c,d)});var p;p=f&&"file"==b.type?function(){var d=a.a.f(c());null===d||d===n||""===d?b.value="":a.u.G(l)}:function(){var f=a.a.f(c()),g=a.w.M(b);if(null!==k&&f===k)a.a.setTimeout(p,0);else if(f!==g||g===n)"select"===e?(g=d.get("valueAllowUnset"),a.w.cb(b,f,g),g||f===a.w.M(b)||a.u.G(l)):a.w.cb(b,f)};if("select"===e){var q;a.i.subscribe(b,a.i.H,function(){q?d.get("valueAllowUnset")?p():l():(a.a.B(b,"change",l),q=a.o(p,null,{l:b}))},\nnull,{notifyImmediately:!0})}else a.a.B(b,"change",l),a.o(p,null,{l:b})}else a.ib(b,{checkedValue:c})},update:function(){}};a.m.wa.value=!0;a.c.visible={update:function(b,c){var d=a.a.f(c()),e="none"!=b.style.display;d&&!e?b.style.display="":!d&&e&&(b.style.display="none")}};a.c.hidden={update:function(b,c){a.c.visible.update(b,function(){return!a.a.f(c())})}};(function(b){a.c[b]={init:function(c,d,e,f,g){return a.c.event.init.call(this,c,function(){var a={};a[b]=d();return a},e,f,g)}}})("click");\na.ca=function(){};a.ca.prototype.renderTemplateSource=function(){throw Error("Override renderTemplateSource");};a.ca.prototype.createJavaScriptEvaluatorBlock=function(){throw Error("Override createJavaScriptEvaluatorBlock");};a.ca.prototype.makeTemplateSource=function(b,c){if("string"==typeof b){c=c||w;var d=c.getElementById(b);if(!d)throw Error("Cannot find template with ID "+b);return new a.C.F(d)}if(1==b.nodeType||8==b.nodeType)return new a.C.ia(b);throw Error("Unknown template type: "+b);};a.ca.prototype.renderTemplate=\nfunction(a,c,d,e){a=this.makeTemplateSource(a,e);return this.renderTemplateSource(a,c,d,e)};a.ca.prototype.isTemplateRewritten=function(a,c){return!1===this.allowTemplateRewriting?!0:this.makeTemplateSource(a,c).data("isRewritten")};a.ca.prototype.rewriteTemplate=function(a,c,d){a=this.makeTemplateSource(a,d);c=c(a.text());a.text(c);a.data("isRewritten",!0)};a.b("templateEngine",a.ca);a.kc=function(){function b(b,c,d,h){b=a.m.ac(b);for(var m=a.m.Ra,k=0;k<b.length;k++){var l=b[k].key;if(Object.prototype.hasOwnProperty.call(m,\nl)){var p=m[l];if("function"===typeof p){if(l=p(b[k].value))throw Error(l);}else if(!p)throw Error("This template engine does not support the \'"+l+"\' binding within its templates");}}d="ko.__tr_ambtns(function($context,$element){return(function(){return{ "+a.m.vb(b,{valueAccessors:!0})+" } })()},\'"+d.toLowerCase()+"\')";return h.createJavaScriptEvaluatorBlock(d)+c}var c=/(<([a-z]+\\d*)(?:\\s+(?!data-bind\\s*=\\s*)[a-z0-9\\-]+(?:=(?:\\"[^\\"]*\\"|\\\'[^\\\']*\\\'|[^>]*))?)*\\s+)data-bind\\s*=\\s*(["\'])([\\s\\S]*?)\\3/gi,\nd=/\\x3c!--\\s*ko\\b\\s*([\\s\\S]*?)\\s*--\\x3e/g;return{xd:function(b,c,d){c.isTemplateRewritten(b,d)||c.rewriteTemplate(b,function(b){return a.kc.Ld(b,c)},d)},Ld:function(a,f){return a.replace(c,function(a,c,d,e,l){return b(l,c,d,f)}).replace(d,function(a,c){return b(c,"\\x3c!-- ko --\\x3e","#comment",f)})},md:function(b,c){return a.aa.Xb(function(d,h){var m=d.nextSibling;m&&m.nodeName.toLowerCase()===c&&a.ib(m,b,h)})}}}();a.b("__tr_ambtns",a.kc.md);(function(){a.C={};a.C.F=function(b){if(this.F=b){var c=\na.a.R(b);this.ab="script"===c?1:"textarea"===c?2:"template"==c&&b.content&&11===b.content.nodeType?3:4}};a.C.F.prototype.text=function(){var b=1===this.ab?"text":2===this.ab?"value":"innerHTML";if(0==arguments.length)return this.F[b];var c=arguments[0];"innerHTML"===b?a.a.fc(this.F,c):this.F[b]=c};var b=a.a.g.Z()+"_";a.C.F.prototype.data=function(c){if(1===arguments.length)return a.a.g.get(this.F,b+c);a.a.g.set(this.F,b+c,arguments[1])};var c=a.a.g.Z();a.C.F.prototype.nodes=function(){var b=this.F;\nif(0==arguments.length){var e=a.a.g.get(b,c)||{},f=e.lb||(3===this.ab?b.content:4===this.ab?b:n);if(!f||e.jd){var g=this.text();g&&g!==e.bb&&(f=a.a.Md(g,b.ownerDocument),a.a.g.set(b,c,{lb:f,bb:g,jd:!0}))}return f}e=arguments[0];this.ab!==n&&this.text("");a.a.g.set(b,c,{lb:e})};a.C.ia=function(a){this.F=a};a.C.ia.prototype=new a.C.F;a.C.ia.prototype.constructor=a.C.ia;a.C.ia.prototype.text=function(){if(0==arguments.length){var b=a.a.g.get(this.F,c)||{};b.bb===n&&b.lb&&(b.bb=b.lb.innerHTML);return b.bb}a.a.g.set(this.F,\nc,{bb:arguments[0]})};a.b("templateSources",a.C);a.b("templateSources.domElement",a.C.F);a.b("templateSources.anonymousTemplate",a.C.ia)})();(function(){function b(b,c,d){var e;for(c=a.h.nextSibling(c);b&&(e=b)!==c;)b=a.h.nextSibling(e),d(e,b)}function c(c,d){if(c.length){var e=c[0],f=c[c.length-1],g=e.parentNode,h=a.ga.instance,m=h.preprocessNode;if(m){b(e,f,function(a,b){var c=a.previousSibling,d=m.call(h,a);d&&(a===e&&(e=d[0]||b),a===f&&(f=d[d.length-1]||c))});c.length=0;if(!e)return;e===f?c.push(e):\n(c.push(e,f),a.a.Ua(c,g))}b(e,f,function(b){1!==b.nodeType&&8!==b.nodeType||a.vc(d,b)});b(e,f,function(b){1!==b.nodeType&&8!==b.nodeType||a.aa.cd(b,[d])});a.a.Ua(c,g)}}function d(a){return a.nodeType?a:0<a.length?a[0]:null}function e(b,e,f,h,m){m=m||{};var n=(b&&d(b)||f||{}).ownerDocument,B=m.templateEngine||g;a.kc.xd(f,B,n);f=B.renderTemplate(f,h,m,n);if("number"!=typeof f.length||0<f.length&&"number"!=typeof f[0].nodeType)throw Error("Template engine must return an array of DOM nodes");n=!1;switch(e){case "replaceChildren":a.h.va(b,\nf);n=!0;break;case "replaceNode":a.a.Xc(b,f);n=!0;break;case "ignoreTargetNode":break;default:throw Error("Unknown renderMode: "+e);}n&&(c(f,h),m.afterRender&&a.u.G(m.afterRender,null,[f,h[m.as||"$data"]]),"replaceChildren"==e&&a.i.ma(b,a.i.H));return f}function f(b,c,d){return a.O(b)?b():"function"===typeof b?b(c,d):b}var g;a.gc=function(b){if(b!=n&&!(b instanceof a.ca))throw Error("templateEngine must inherit from ko.templateEngine");g=b};a.dc=function(b,c,h,m,t){h=h||{};if((h.templateEngine||g)==\nn)throw Error("Set a template engine before calling renderTemplate");t=t||"replaceChildren";if(m){var x=d(m);return a.$(function(){var g=c&&c instanceof a.fa?c:new a.fa(c,null,null,null,{exportDependencies:!0}),n=f(b,g.$data,g),g=e(m,t,n,g,h);"replaceNode"==t&&(m=g,x=d(m))},null,{Sa:function(){return!x||!a.a.Sb(x)},l:x&&"replaceNode"==t?x.parentNode:x})}return a.aa.Xb(function(d){a.dc(b,c,h,d,"replaceNode")})};a.Qd=function(b,d,g,h,m){function x(b,c){a.u.G(a.a.ec,null,[h,b,u,g,r,c]);a.i.ma(h,a.i.H)}\nfunction r(a,b){c(b,v);g.afterRender&&g.afterRender(b,a);v=null}function u(a,c){v=m.createChildContext(a,{as:z,noChildContext:g.noChildContext,extend:function(a){a.$index=c;z&&(a[z+"Index"]=c)}});var d=f(b,a,v);return e(h,"ignoreTargetNode",d,v,g)}var v,z=g.as,w=!1===g.includeDestroyed||a.options.foreachHidesDestroyed&&!g.includeDestroyed;if(w||g.beforeRemove||!a.Pc(d))return a.$(function(){var b=a.a.f(d)||[];"undefined"==typeof b.length&&(b=[b]);w&&(b=a.a.jb(b,function(b){return b===n||null===b||\n!a.a.f(b._destroy)}));x(b)},null,{l:h});x(d.v());var A=d.subscribe(function(a){x(d(),a)},null,"arrayChange");A.l(h);return A};var h=a.a.g.Z(),m=a.a.g.Z();a.c.template={init:function(b,c){var d=a.a.f(c());if("string"==typeof d||"name"in d)a.h.Ea(b);else if("nodes"in d){d=d.nodes||[];if(a.O(d))throw Error(\'The "nodes" option must be a plain, non-observable array.\');var e=d[0]&&d[0].parentNode;e&&a.a.g.get(e,m)||(e=a.a.Yb(d),a.a.g.set(e,m,!0));(new a.C.ia(b)).nodes(e)}else if(d=a.h.childNodes(b),0<d.length)e=\na.a.Yb(d),(new a.C.ia(b)).nodes(e);else throw Error("Anonymous template defined, but no template content was provided");return{controlsDescendantBindings:!0}},update:function(b,c,d,e,f){var g=c();c=a.a.f(g);d=!0;e=null;"string"==typeof c?c={}:(g="name"in c?c.name:b,"if"in c&&(d=a.a.f(c["if"])),d&&"ifnot"in c&&(d=!a.a.f(c.ifnot)),d&&!g&&(d=!1));"foreach"in c?e=a.Qd(g,d&&c.foreach||[],c,b,f):d?(d=f,"data"in c&&(d=f.createChildContext(c.data,{as:c.as,noChildContext:c.noChildContext,exportDependencies:!0})),\ne=a.dc(g,d,c,b)):a.h.Ea(b);f=e;(c=a.a.g.get(b,h))&&"function"==typeof c.s&&c.s();a.a.g.set(b,h,!f||f.ja&&!f.ja()?n:f)}};a.m.Ra.template=function(b){b=a.m.ac(b);return 1==b.length&&b[0].unknown||a.m.Id(b,"name")?null:"This template engine does not support anonymous templates nested within its templates"};a.h.ea.template=!0})();a.b("setTemplateEngine",a.gc);a.b("renderTemplate",a.dc);a.a.Kc=function(a,c,d){if(a.length&&c.length){var e,f,g,h,m;for(e=f=0;(!d||e<d)&&(h=a[f]);++f){for(g=0;m=c[g];++g)if(h.value===\nm.value){h.moved=m.index;m.moved=h.index;c.splice(g,1);e=g=0;break}e+=g}}};a.a.Pb=function(){function b(b,d,e,f,g){var h=Math.min,m=Math.max,k=[],l,p=b.length,q,n=d.length,r=n-p||1,v=p+n+1,u,w,z;for(l=0;l<=p;l++)for(w=u,k.push(u=[]),z=h(n,l+r),q=m(0,l-1);q<=z;q++)u[q]=q?l?b[l-1]===d[q-1]?w[q-1]:h(w[q]||v,u[q-1]||v)+1:q+1:l+1;h=[];m=[];r=[];l=p;for(q=n;l||q;)n=k[l][q]-1,q&&n===k[l][q-1]?m.push(h[h.length]={status:e,value:d[--q],index:q}):l&&n===k[l-1][q]?r.push(h[h.length]={status:f,value:b[--l],index:l}):\n(--q,--l,g.sparse||h.push({status:"retained",value:d[q]}));a.a.Kc(r,m,!g.dontLimitMoves&&10*p);return h.reverse()}return function(a,d,e){e="boolean"===typeof e?{dontLimitMoves:e}:e||{};a=a||[];d=d||[];return a.length<d.length?b(a,d,"added","deleted",e):b(d,a,"deleted","added",e)}}();a.b("utils.compareArrays",a.a.Pb);(function(){function b(b,c,d,h,m){var k=[],l=a.$(function(){var l=c(d,m,a.a.Ua(k,b))||[];0<k.length&&(a.a.Xc(k,l),h&&a.u.G(h,null,[d,l,m]));k.length=0;a.a.Nb(k,l)},null,{l:b,Sa:function(){return!a.a.kd(k)}});\nreturn{Y:k,$:l.ja()?l:n}}var c=a.a.g.Z(),d=a.a.g.Z();a.a.ec=function(e,f,g,h,m,k){function l(b){y={Aa:b,pb:a.ta(w++)};v.push(y);r||F.push(y)}function p(b){y=t[b];w!==y.pb.v()&&D.push(y);y.pb(w++);a.a.Ua(y.Y,e);v.push(y)}function q(b,c){if(b)for(var d=0,e=c.length;d<e;d++)a.a.D(c[d].Y,function(a){b(a,d,c[d].Aa)})}f=f||[];"undefined"==typeof f.length&&(f=[f]);h=h||{};var t=a.a.g.get(e,c),r=!t,v=[],u=0,w=0,z=[],A=[],C=[],D=[],F=[],y,I=0;if(r)a.a.D(f,l);else{if(!k||t&&t._countWaitingForRemove){var E=\na.a.Mb(t,function(a){return a.Aa});k=a.a.Pb(E,f,{dontLimitMoves:h.dontLimitMoves,sparse:!0})}for(var E=0,G,H,K;G=k[E];E++)switch(H=G.moved,K=G.index,G.status){case "deleted":for(;u<K;)p(u++);H===n&&(y=t[u],y.$&&(y.$.s(),y.$=n),a.a.Ua(y.Y,e).length&&(h.beforeRemove&&(v.push(y),I++,y.Aa===d?y=null:C.push(y)),y&&z.push.apply(z,y.Y)));u++;break;case "added":for(;w<K;)p(u++);H!==n?(A.push(v.length),p(H)):l(G.value)}for(;w<f.length;)p(u++);v._countWaitingForRemove=I}a.a.g.set(e,c,v);q(h.beforeMove,D);a.a.D(z,\nh.beforeRemove?a.oa:a.removeNode);var M,O,P;try{P=e.ownerDocument.activeElement}catch(N){}if(A.length)for(;(E=A.shift())!=n;){y=v[E];for(M=n;E;)if((O=v[--E].Y)&&O.length){M=O[O.length-1];break}for(f=0;u=y.Y[f];M=u,f++)a.h.Wb(e,u,M)}for(E=0;y=v[E];E++){y.Y||a.a.extend(y,b(e,g,y.Aa,m,y.pb));for(f=0;u=y.Y[f];M=u,f++)a.h.Wb(e,u,M);!y.Ed&&m&&(m(y.Aa,y.Y,y.pb),y.Ed=!0,M=y.Y[y.Y.length-1])}P&&e.ownerDocument.activeElement!=P&&P.focus();q(h.beforeRemove,C);for(E=0;E<C.length;++E)C[E].Aa=d;q(h.afterMove,D);\nq(h.afterAdd,F)}})();a.b("utils.setDomNodeChildrenFromArrayMapping",a.a.ec);a.ba=function(){this.allowTemplateRewriting=!1};a.ba.prototype=new a.ca;a.ba.prototype.constructor=a.ba;a.ba.prototype.renderTemplateSource=function(b,c,d,e){if(c=(9>a.a.W?0:b.nodes)?b.nodes():null)return a.a.la(c.cloneNode(!0).childNodes);b=b.text();return a.a.ua(b,e)};a.ba.Ma=new a.ba;a.gc(a.ba.Ma);a.b("nativeTemplateEngine",a.ba);(function(){a.$a=function(){var a=this.Hd=function(){if(!v||!v.tmpl)return 0;try{if(0<=v.tmpl.tag.tmpl.open.toString().indexOf("__"))return 2}catch(a){}return 1}();\nthis.renderTemplateSource=function(b,e,f,g){g=g||w;f=f||{};if(2>a)throw Error("Your version of jQuery.tmpl is too old. Please upgrade to jQuery.tmpl 1.0.0pre or later.");var h=b.data("precompiled");h||(h=b.text()||"",h=v.template(null,"{{ko_with $item.koBindingContext}}"+h+"{{/ko_with}}"),b.data("precompiled",h));b=[e.$data];e=v.extend({koBindingContext:e},f.templateOptions);e=v.tmpl(h,b,e);e.appendTo(g.createElement("div"));v.fragments={};return e};this.createJavaScriptEvaluatorBlock=function(a){return"{{ko_code ((function() { return "+\na+" })()) }}"};this.addTemplate=function(a,b){w.write("<script type=\'text/html\' id=\'"+a+"\'>"+b+"\\x3c/script>")};0<a&&(v.tmpl.tag.ko_code={open:"__.push($1 || \'\');"},v.tmpl.tag.ko_with={open:"with($1) {",close:"} "})};a.$a.prototype=new a.ca;a.$a.prototype.constructor=a.$a;var b=new a.$a;0<b.Hd&&a.gc(b);a.b("jqueryTmplTemplateEngine",a.$a)})()})})();})();\n\n})();\n\n// Avoid polluting the global scope.\nvar knockout = ko;\nif (typeof window !== \'undefined\') {\n    ko = window.ko;\n    if (typeof oldValue !== \'undefined\') {\n        window.ko = oldValue;\n    } else {\n        delete window.ko;\n    }\n} else {\n    ko = global.ko;\n    if (typeof oldValue !== \'undefined\') {\n        global.ko = oldValue;\n    } else {\n        delete global.ko;\n    }\n}\n\n/* harmony default export */ __webpack_exports__["Z"] = (knockout);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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Z0IsZ0NBQWdDLHdCQUF3QixnQ0FBZ0Msc0RBQXNELGtGQUFrRixXQUFXLG9CQUFvQixpQkFBaUIsY0FBYyxpQ0FBaUMsWUFBWSxnQkFBZ0IseUJBQXlCLHdCQUF3QixJQUFJLDZEQUE2RCxVQUFVLFNBQVM7QUFDNWpCLDRDQUE0QyxPQUFPLFFBQVEsK0dBQStHLDRCQUE0Qix3Q0FBd0MsZ0NBQWdDLE9BQU8sVUFBVSw0QkFBNEIsWUFBWSxZQUFZLG1CQUFtQixvQkFBb0IsZ0JBQWdCLG1DQUFtQyxlQUFlLFVBQVUsZ0RBQWdELFNBQVMsdUJBQXVCO0FBQ3RoQixLQUFLLE9BQU8sR0FBRywrQkFBK0Isa0VBQWtFLDBCQUEwQix3QkFBd0IsRUFBRSxxQkFBcUIsZ0JBQWdCLFdBQVcsRUFBRSxHQUFHLHdCQUF3QixnQ0FBZ0MsZUFBZSxnQkFBZ0IscUNBQXFDLElBQUksRUFBRSxLQUFLOztBQUVoVyxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUEseURBQWUsUUFBUSxFQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdnVlMy13ZWJwYWNrNS8uL25vZGVfbW9kdWxlcy9jZXNpdW0vU291cmNlL1RoaXJkUGFydHkva25vY2tvdXQtMy41LjEuanM/MmVjZSJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgb2xkVmFsdWU7XG5pZiAodHlwZW9mIGtvICE9PSAndW5kZWZpbmVkJykge1xuICAgIG9sZFZhbHVlID0ga287XG59XG5cbihmdW5jdGlvbigpe1xuLyohXG4gKiBLbm9ja291dCBKYXZhU2NyaXB0IGxpYnJhcnkgdjMuNS4xXG4gKiAoYykgVGhlIEtub2Nrb3V0LmpzIHRlYW0gLSBodHRwOi8va25vY2tvdXRqcy5jb20vXG4gKiBMaWNlbnNlOiBNSVQgKGh0dHA6Ly93d3cub3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvbWl0LWxpY2Vuc2UucGhwKVxuICovXG5cbihmdW5jdGlvbigpIHsoZnVuY3Rpb24obil7dmFyIEE9dGhpc3x8KDAsZXZhbCkoXCJ0aGlzXCIpLHc9QS5kb2N1bWVudCxSPUEubmF2aWdhdG9yLHY9QS5qUXVlcnksSD1BLkpTT047dnx8XCJ1bmRlZmluZWRcIj09PXR5cGVvZiBqUXVlcnl8fCh2PWpRdWVyeSk7KGZ1bmN0aW9uKG4pe24oQS5rbz17fSl9KShmdW5jdGlvbihTLFQpe2Z1bmN0aW9uIEsoYSxjKXtyZXR1cm4gbnVsbD09PWF8fHR5cGVvZiBhIGluIFc/YT09PWM6ITF9ZnVuY3Rpb24gWChiLGMpe3ZhciBkO3JldHVybiBmdW5jdGlvbigpe2R8fChkPWEuYS5zZXRUaW1lb3V0KGZ1bmN0aW9uKCl7ZD1uO2IoKX0sYykpfX1mdW5jdGlvbiBZKGIsYyl7dmFyIGQ7cmV0dXJuIGZ1bmN0aW9uKCl7Y2xlYXJUaW1lb3V0KGQpO1xuZD1hLmEuc2V0VGltZW91dChiLGMpfX1mdW5jdGlvbiBaKGEsYyl7YyYmXCJjaGFuZ2VcIiE9PWM/XCJiZWZvcmVDaGFuZ2VcIj09PWM/dGhpcy5wYyhhKTp0aGlzLmdiKGEsYyk6dGhpcy5xYyhhKX1mdW5jdGlvbiBhYShhLGMpe251bGwhPT1jJiZjLnMmJmMucygpfWZ1bmN0aW9uIGJhKGEsYyl7dmFyIGQ9dGhpcy5xZCxlPWRbcl07ZS5yYXx8KHRoaXMuUWImJnRoaXMubWJbY10/KGQudWMoYyxhLHRoaXMubWJbY10pLHRoaXMubWJbY109bnVsbCwtLXRoaXMuUWIpOmUuSVtjXXx8ZC51YyhjLGEsZS5KP3tkYTphfTpkLiRjKGEpKSxhLkphJiZhLmdkKCkpfXZhciBhPVwidW5kZWZpbmVkXCIhPT10eXBlb2YgUz9TOnt9O2EuYj1mdW5jdGlvbihiLGMpe2Zvcih2YXIgZD1iLnNwbGl0KFwiLlwiKSxlPWEsZj0wO2Y8ZC5sZW5ndGgtMTtmKyspZT1lW2RbZl1dO2VbZFtkLmxlbmd0aC0xXV09Y307YS5MPWZ1bmN0aW9uKGEsYyxkKXthW2NdPWR9O2EudmVyc2lvbj1cIjMuNS4xXCI7YS5iKFwidmVyc2lvblwiLFxuYS52ZXJzaW9uKTthLm9wdGlvbnM9e2RlZmVyVXBkYXRlczohMSx1c2VPbmx5TmF0aXZlRXZlbnRzOiExLGZvcmVhY2hIaWRlc0Rlc3Ryb3llZDohMX07YS5hPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gYihhLGIpe2Zvcih2YXIgYyBpbiBhKWYuY2FsbChhLGMpJiZiKGMsYVtjXSl9ZnVuY3Rpb24gYyhhLGIpe2lmKGIpZm9yKHZhciBjIGluIGIpZi5jYWxsKGIsYykmJihhW2NdPWJbY10pO3JldHVybiBhfWZ1bmN0aW9uIGQoYSxiKXthLl9fcHJvdG9fXz1iO3JldHVybiBhfWZ1bmN0aW9uIGUoYixjLGQsZSl7dmFyIGw9YltjXS5tYXRjaChxKXx8W107YS5hLkQoZC5tYXRjaChxKSxmdW5jdGlvbihiKXthLmEuTmEobCxiLGUpfSk7YltjXT1sLmpvaW4oXCIgXCIpfXZhciBmPU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHksZz17X19wcm90b19fOltdfWluc3RhbmNlb2YgQXJyYXksaD1cImZ1bmN0aW9uXCI9PT10eXBlb2YgU3ltYm9sLG09e30saz17fTttW1ImJi9GaXJlZm94XFwvMi9pLnRlc3QoUi51c2VyQWdlbnQpP1xuXCJLZXlib2FyZEV2ZW50XCI6XCJVSUV2ZW50c1wiXT1bXCJrZXl1cFwiLFwia2V5ZG93blwiLFwia2V5cHJlc3NcIl07bS5Nb3VzZUV2ZW50cz1cImNsaWNrIGRibGNsaWNrIG1vdXNlZG93biBtb3VzZXVwIG1vdXNlbW92ZSBtb3VzZW92ZXIgbW91c2VvdXQgbW91c2VlbnRlciBtb3VzZWxlYXZlXCIuc3BsaXQoXCIgXCIpO2IobSxmdW5jdGlvbihhLGIpe2lmKGIubGVuZ3RoKWZvcih2YXIgYz0wLGQ9Yi5sZW5ndGg7YzxkO2MrKylrW2JbY11dPWF9KTt2YXIgbD17cHJvcGVydHljaGFuZ2U6ITB9LHA9dyYmZnVuY3Rpb24oKXtmb3IodmFyIGE9MyxiPXcuY3JlYXRlRWxlbWVudChcImRpdlwiKSxjPWIuZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCJpXCIpO2IuaW5uZXJIVE1MPVwiXFx4M2MhLS1baWYgZ3QgSUUgXCIrICsrYStcIl0+PGk+PC9pPjwhW2VuZGlmXS0tXFx4M2VcIixjWzBdOyk7cmV0dXJuIDQ8YT9hOm59KCkscT0vXFxTKy9nLHQ7cmV0dXJue0pjOltcImF1dGhlbnRpY2l0eV90b2tlblwiLC9eX19SZXF1ZXN0VmVyaWZpY2F0aW9uVG9rZW4oXy4qKT8kL10sXG5EOmZ1bmN0aW9uKGEsYixjKXtmb3IodmFyIGQ9MCxlPWEubGVuZ3RoO2Q8ZTtkKyspYi5jYWxsKGMsYVtkXSxkLGEpfSxBOlwiZnVuY3Rpb25cIj09dHlwZW9mIEFycmF5LnByb3RvdHlwZS5pbmRleE9mP2Z1bmN0aW9uKGEsYil7cmV0dXJuIEFycmF5LnByb3RvdHlwZS5pbmRleE9mLmNhbGwoYSxiKX06ZnVuY3Rpb24oYSxiKXtmb3IodmFyIGM9MCxkPWEubGVuZ3RoO2M8ZDtjKyspaWYoYVtjXT09PWIpcmV0dXJuIGM7cmV0dXJuLTF9LExiOmZ1bmN0aW9uKGEsYixjKXtmb3IodmFyIGQ9MCxlPWEubGVuZ3RoO2Q8ZTtkKyspaWYoYi5jYWxsKGMsYVtkXSxkLGEpKXJldHVybiBhW2RdO3JldHVybiBufSxQYTpmdW5jdGlvbihiLGMpe3ZhciBkPWEuYS5BKGIsYyk7MDxkP2Iuc3BsaWNlKGQsMSk6MD09PWQmJmIuc2hpZnQoKX0sd2M6ZnVuY3Rpb24oYil7dmFyIGM9W107YiYmYS5hLkQoYixmdW5jdGlvbihiKXswPmEuYS5BKGMsYikmJmMucHVzaChiKX0pO3JldHVybiBjfSxNYjpmdW5jdGlvbihhLFxuYixjKXt2YXIgZD1bXTtpZihhKWZvcih2YXIgZT0wLGw9YS5sZW5ndGg7ZTxsO2UrKylkLnB1c2goYi5jYWxsKGMsYVtlXSxlKSk7cmV0dXJuIGR9LGpiOmZ1bmN0aW9uKGEsYixjKXt2YXIgZD1bXTtpZihhKWZvcih2YXIgZT0wLGw9YS5sZW5ndGg7ZTxsO2UrKyliLmNhbGwoYyxhW2VdLGUpJiZkLnB1c2goYVtlXSk7cmV0dXJuIGR9LE5iOmZ1bmN0aW9uKGEsYil7aWYoYiBpbnN0YW5jZW9mIEFycmF5KWEucHVzaC5hcHBseShhLGIpO2Vsc2UgZm9yKHZhciBjPTAsZD1iLmxlbmd0aDtjPGQ7YysrKWEucHVzaChiW2NdKTtyZXR1cm4gYX0sTmE6ZnVuY3Rpb24oYixjLGQpe3ZhciBlPWEuYS5BKGEuYS5iYyhiKSxjKTswPmU/ZCYmYi5wdXNoKGMpOmR8fGIuc3BsaWNlKGUsMSl9LEJhOmcsZXh0ZW5kOmMsc2V0UHJvdG90eXBlT2Y6ZCxBYjpnP2Q6YyxQOmIsR2E6ZnVuY3Rpb24oYSxiLGMpe2lmKCFhKXJldHVybiBhO3ZhciBkPXt9LGU7Zm9yKGUgaW4gYSlmLmNhbGwoYSxlKSYmKGRbZV09XG5iLmNhbGwoYyxhW2VdLGUsYSkpO3JldHVybiBkfSxUYjpmdW5jdGlvbihiKXtmb3IoO2IuZmlyc3RDaGlsZDspYS5yZW1vdmVOb2RlKGIuZmlyc3RDaGlsZCl9LFliOmZ1bmN0aW9uKGIpe2I9YS5hLmxhKGIpO2Zvcih2YXIgYz0oYlswXSYmYlswXS5vd25lckRvY3VtZW50fHx3KS5jcmVhdGVFbGVtZW50KFwiZGl2XCIpLGQ9MCxlPWIubGVuZ3RoO2Q8ZTtkKyspYy5hcHBlbmRDaGlsZChhLm9hKGJbZF0pKTtyZXR1cm4gY30sQ2E6ZnVuY3Rpb24oYixjKXtmb3IodmFyIGQ9MCxlPWIubGVuZ3RoLGw9W107ZDxlO2QrKyl7dmFyIGs9YltkXS5jbG9uZU5vZGUoITApO2wucHVzaChjP2Eub2Eoayk6ayl9cmV0dXJuIGx9LHZhOmZ1bmN0aW9uKGIsYyl7YS5hLlRiKGIpO2lmKGMpZm9yKHZhciBkPTAsZT1jLmxlbmd0aDtkPGU7ZCsrKWIuYXBwZW5kQ2hpbGQoY1tkXSl9LFhjOmZ1bmN0aW9uKGIsYyl7dmFyIGQ9Yi5ub2RlVHlwZT9bYl06YjtpZigwPGQubGVuZ3RoKXtmb3IodmFyIGU9ZFswXSxcbmw9ZS5wYXJlbnROb2RlLGs9MCxmPWMubGVuZ3RoO2s8ZjtrKyspbC5pbnNlcnRCZWZvcmUoY1trXSxlKTtrPTA7Zm9yKGY9ZC5sZW5ndGg7azxmO2srKylhLnJlbW92ZU5vZGUoZFtrXSl9fSxVYTpmdW5jdGlvbihhLGIpe2lmKGEubGVuZ3RoKXtmb3IoYj04PT09Yi5ub2RlVHlwZSYmYi5wYXJlbnROb2RlfHxiO2EubGVuZ3RoJiZhWzBdLnBhcmVudE5vZGUhPT1iOylhLnNwbGljZSgwLDEpO2Zvcig7MTxhLmxlbmd0aCYmYVthLmxlbmd0aC0xXS5wYXJlbnROb2RlIT09YjspYS5sZW5ndGgtLTtpZigxPGEubGVuZ3RoKXt2YXIgYz1hWzBdLGQ9YVthLmxlbmd0aC0xXTtmb3IoYS5sZW5ndGg9MDtjIT09ZDspYS5wdXNoKGMpLGM9Yy5uZXh0U2libGluZzthLnB1c2goZCl9fXJldHVybiBhfSxaYzpmdW5jdGlvbihhLGIpezc+cD9hLnNldEF0dHJpYnV0ZShcInNlbGVjdGVkXCIsYik6YS5zZWxlY3RlZD1ifSxEYjpmdW5jdGlvbihhKXtyZXR1cm4gbnVsbD09PWF8fGE9PT1uP1wiXCI6YS50cmltP1xuYS50cmltKCk6YS50b1N0cmluZygpLnJlcGxhY2UoL15bXFxzXFx4YTBdK3xbXFxzXFx4YTBdKyQvZyxcIlwiKX0sVWQ6ZnVuY3Rpb24oYSxiKXthPWF8fFwiXCI7cmV0dXJuIGIubGVuZ3RoPmEubGVuZ3RoPyExOmEuc3Vic3RyaW5nKDAsYi5sZW5ndGgpPT09Yn0sdmQ6ZnVuY3Rpb24oYSxiKXtpZihhPT09YilyZXR1cm4hMDtpZigxMT09PWEubm9kZVR5cGUpcmV0dXJuITE7aWYoYi5jb250YWlucylyZXR1cm4gYi5jb250YWlucygxIT09YS5ub2RlVHlwZT9hLnBhcmVudE5vZGU6YSk7aWYoYi5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbilyZXR1cm4gMTY9PShiLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uKGEpJjE2KTtmb3IoO2EmJmEhPWI7KWE9YS5wYXJlbnROb2RlO3JldHVybiEhYX0sU2I6ZnVuY3Rpb24oYil7cmV0dXJuIGEuYS52ZChiLGIub3duZXJEb2N1bWVudC5kb2N1bWVudEVsZW1lbnQpfSxrZDpmdW5jdGlvbihiKXtyZXR1cm4hIWEuYS5MYihiLGEuYS5TYil9LFI6ZnVuY3Rpb24oYSl7cmV0dXJuIGEmJlxuYS50YWdOYW1lJiZhLnRhZ05hbWUudG9Mb3dlckNhc2UoKX0sQWM6ZnVuY3Rpb24oYil7cmV0dXJuIGEub25FcnJvcj9mdW5jdGlvbigpe3RyeXtyZXR1cm4gYi5hcHBseSh0aGlzLGFyZ3VtZW50cyl9Y2F0Y2goYyl7dGhyb3cgYS5vbkVycm9yJiZhLm9uRXJyb3IoYyksYzt9fTpifSxzZXRUaW1lb3V0OmZ1bmN0aW9uKGIsYyl7cmV0dXJuIHNldFRpbWVvdXQoYS5hLkFjKGIpLGMpfSxHYzpmdW5jdGlvbihiKXtzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7YS5vbkVycm9yJiZhLm9uRXJyb3IoYik7dGhyb3cgYjt9LDApfSxCOmZ1bmN0aW9uKGIsYyxkKXt2YXIgZT1hLmEuQWMoZCk7ZD1sW2NdO2lmKGEub3B0aW9ucy51c2VPbmx5TmF0aXZlRXZlbnRzfHxkfHwhdilpZihkfHxcImZ1bmN0aW9uXCIhPXR5cGVvZiBiLmFkZEV2ZW50TGlzdGVuZXIpaWYoXCJ1bmRlZmluZWRcIiE9dHlwZW9mIGIuYXR0YWNoRXZlbnQpe3ZhciBrPWZ1bmN0aW9uKGEpe2UuY2FsbChiLGEpfSxmPVwib25cIitjO2IuYXR0YWNoRXZlbnQoZixcbmspO2EuYS5LLnphKGIsZnVuY3Rpb24oKXtiLmRldGFjaEV2ZW50KGYsayl9KX1lbHNlIHRocm93IEVycm9yKFwiQnJvd3NlciBkb2Vzbid0IHN1cHBvcnQgYWRkRXZlbnRMaXN0ZW5lciBvciBhdHRhY2hFdmVudFwiKTtlbHNlIGIuYWRkRXZlbnRMaXN0ZW5lcihjLGUsITEpO2Vsc2UgdHx8KHQ9XCJmdW5jdGlvblwiPT10eXBlb2YgdihiKS5vbj9cIm9uXCI6XCJiaW5kXCIpLHYoYilbdF0oYyxlKX0sRmI6ZnVuY3Rpb24oYixjKXtpZighYnx8IWIubm9kZVR5cGUpdGhyb3cgRXJyb3IoXCJlbGVtZW50IG11c3QgYmUgYSBET00gbm9kZSB3aGVuIGNhbGxpbmcgdHJpZ2dlckV2ZW50XCIpO3ZhciBkO1wiaW5wdXRcIj09PWEuYS5SKGIpJiZiLnR5cGUmJlwiY2xpY2tcIj09Yy50b0xvd2VyQ2FzZSgpPyhkPWIudHlwZSxkPVwiY2hlY2tib3hcIj09ZHx8XCJyYWRpb1wiPT1kKTpkPSExO2lmKGEub3B0aW9ucy51c2VPbmx5TmF0aXZlRXZlbnRzfHwhdnx8ZClpZihcImZ1bmN0aW9uXCI9PXR5cGVvZiB3LmNyZWF0ZUV2ZW50KWlmKFwiZnVuY3Rpb25cIj09XG50eXBlb2YgYi5kaXNwYXRjaEV2ZW50KWQ9dy5jcmVhdGVFdmVudChrW2NdfHxcIkhUTUxFdmVudHNcIiksZC5pbml0RXZlbnQoYywhMCwhMCxBLDAsMCwwLDAsMCwhMSwhMSwhMSwhMSwwLGIpLGIuZGlzcGF0Y2hFdmVudChkKTtlbHNlIHRocm93IEVycm9yKFwiVGhlIHN1cHBsaWVkIGVsZW1lbnQgZG9lc24ndCBzdXBwb3J0IGRpc3BhdGNoRXZlbnRcIik7ZWxzZSBpZihkJiZiLmNsaWNrKWIuY2xpY2soKTtlbHNlIGlmKFwidW5kZWZpbmVkXCIhPXR5cGVvZiBiLmZpcmVFdmVudCliLmZpcmVFdmVudChcIm9uXCIrYyk7ZWxzZSB0aHJvdyBFcnJvcihcIkJyb3dzZXIgZG9lc24ndCBzdXBwb3J0IHRyaWdnZXJpbmcgZXZlbnRzXCIpO2Vsc2UgdihiKS50cmlnZ2VyKGMpfSxmOmZ1bmN0aW9uKGIpe3JldHVybiBhLk8oYik/YigpOmJ9LGJjOmZ1bmN0aW9uKGIpe3JldHVybiBhLk8oYik/Yi52KCk6Yn0sRWI6ZnVuY3Rpb24oYixjLGQpe3ZhciBsO2MmJihcIm9iamVjdFwiPT09dHlwZW9mIGIuY2xhc3NMaXN0P1xuKGw9Yi5jbGFzc0xpc3RbZD9cImFkZFwiOlwicmVtb3ZlXCJdLGEuYS5EKGMubWF0Y2gocSksZnVuY3Rpb24oYSl7bC5jYWxsKGIuY2xhc3NMaXN0LGEpfSkpOlwic3RyaW5nXCI9PT10eXBlb2YgYi5jbGFzc05hbWUuYmFzZVZhbD9lKGIuY2xhc3NOYW1lLFwiYmFzZVZhbFwiLGMsZCk6ZShiLFwiY2xhc3NOYW1lXCIsYyxkKSl9LEJiOmZ1bmN0aW9uKGIsYyl7dmFyIGQ9YS5hLmYoYyk7aWYobnVsbD09PWR8fGQ9PT1uKWQ9XCJcIjt2YXIgZT1hLmguZmlyc3RDaGlsZChiKTshZXx8MyE9ZS5ub2RlVHlwZXx8YS5oLm5leHRTaWJsaW5nKGUpP2EuaC52YShiLFtiLm93bmVyRG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoZCldKTplLmRhdGE9ZDthLmEuQWQoYil9LFljOmZ1bmN0aW9uKGEsYil7YS5uYW1lPWI7aWYoNz49cCl0cnl7dmFyIGM9YS5uYW1lLnJlcGxhY2UoL1smPD4nXCJdL2csZnVuY3Rpb24oYSl7cmV0dXJuXCImI1wiK2EuY2hhckNvZGVBdCgwKStcIjtcIn0pO2EubWVyZ2VBdHRyaWJ1dGVzKHcuY3JlYXRlRWxlbWVudChcIjxpbnB1dCBuYW1lPSdcIitcbmMrXCInLz5cIiksITEpfWNhdGNoKGQpe319LEFkOmZ1bmN0aW9uKGEpezk8PXAmJihhPTE9PWEubm9kZVR5cGU/YTphLnBhcmVudE5vZGUsYS5zdHlsZSYmKGEuc3R5bGUuem9vbT1hLnN0eWxlLnpvb20pKX0sd2Q6ZnVuY3Rpb24oYSl7aWYocCl7dmFyIGI9YS5zdHlsZS53aWR0aDthLnN0eWxlLndpZHRoPTA7YS5zdHlsZS53aWR0aD1ifX0sUGQ6ZnVuY3Rpb24oYixjKXtiPWEuYS5mKGIpO2M9YS5hLmYoYyk7Zm9yKHZhciBkPVtdLGU9YjtlPD1jO2UrKylkLnB1c2goZSk7cmV0dXJuIGR9LGxhOmZ1bmN0aW9uKGEpe2Zvcih2YXIgYj1bXSxjPTAsZD1hLmxlbmd0aDtjPGQ7YysrKWIucHVzaChhW2NdKTtyZXR1cm4gYn0sRGE6ZnVuY3Rpb24oYSl7cmV0dXJuIGg/U3ltYm9sKGEpOmF9LFpkOjY9PT1wLCRkOjc9PT1wLFc6cCxMYzpmdW5jdGlvbihiLGMpe2Zvcih2YXIgZD1hLmEubGEoYi5nZXRFbGVtZW50c0J5VGFnTmFtZShcImlucHV0XCIpKS5jb25jYXQoYS5hLmxhKGIuZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCJ0ZXh0YXJlYVwiKSkpLFxuZT1cInN0cmluZ1wiPT10eXBlb2YgYz9mdW5jdGlvbihhKXtyZXR1cm4gYS5uYW1lPT09Y306ZnVuY3Rpb24oYSl7cmV0dXJuIGMudGVzdChhLm5hbWUpfSxsPVtdLGs9ZC5sZW5ndGgtMTswPD1rO2stLSllKGRba10pJiZsLnB1c2goZFtrXSk7cmV0dXJuIGx9LE5kOmZ1bmN0aW9uKGIpe3JldHVyblwic3RyaW5nXCI9PXR5cGVvZiBiJiYoYj1hLmEuRGIoYikpP0gmJkgucGFyc2U/SC5wYXJzZShiKToobmV3IEZ1bmN0aW9uKFwicmV0dXJuIFwiK2IpKSgpOm51bGx9LGhjOmZ1bmN0aW9uKGIsYyxkKXtpZighSHx8IUguc3RyaW5naWZ5KXRocm93IEVycm9yKFwiQ2Fubm90IGZpbmQgSlNPTi5zdHJpbmdpZnkoKS4gU29tZSBicm93c2VycyAoZS5nLiwgSUUgPCA4KSBkb24ndCBzdXBwb3J0IGl0IG5hdGl2ZWx5LCBidXQgeW91IGNhbiBvdmVyY29tZSB0aGlzIGJ5IGFkZGluZyBhIHNjcmlwdCByZWZlcmVuY2UgdG8ganNvbjIuanMsIGRvd25sb2FkYWJsZSBmcm9tIGh0dHA6Ly93d3cuanNvbi5vcmcvanNvbjIuanNcIik7XG5yZXR1cm4gSC5zdHJpbmdpZnkoYS5hLmYoYiksYyxkKX0sT2Q6ZnVuY3Rpb24oYyxkLGUpe2U9ZXx8e307dmFyIGw9ZS5wYXJhbXN8fHt9LGs9ZS5pbmNsdWRlRmllbGRzfHx0aGlzLkpjLGY9YztpZihcIm9iamVjdFwiPT10eXBlb2YgYyYmXCJmb3JtXCI9PT1hLmEuUihjKSlmb3IodmFyIGY9Yy5hY3Rpb24saD1rLmxlbmd0aC0xOzA8PWg7aC0tKWZvcih2YXIgZz1hLmEuTGMoYyxrW2hdKSxtPWcubGVuZ3RoLTE7MDw9bTttLS0pbFtnW21dLm5hbWVdPWdbbV0udmFsdWU7ZD1hLmEuZihkKTt2YXIgcD13LmNyZWF0ZUVsZW1lbnQoXCJmb3JtXCIpO3Auc3R5bGUuZGlzcGxheT1cIm5vbmVcIjtwLmFjdGlvbj1mO3AubWV0aG9kPVwicG9zdFwiO2Zvcih2YXIgcSBpbiBkKWM9dy5jcmVhdGVFbGVtZW50KFwiaW5wdXRcIiksYy50eXBlPVwiaGlkZGVuXCIsYy5uYW1lPXEsYy52YWx1ZT1hLmEuaGMoYS5hLmYoZFtxXSkpLHAuYXBwZW5kQ2hpbGQoYyk7YihsLGZ1bmN0aW9uKGEsYil7dmFyIGM9dy5jcmVhdGVFbGVtZW50KFwiaW5wdXRcIik7XG5jLnR5cGU9XCJoaWRkZW5cIjtjLm5hbWU9YTtjLnZhbHVlPWI7cC5hcHBlbmRDaGlsZChjKX0pO3cuYm9keS5hcHBlbmRDaGlsZChwKTtlLnN1Ym1pdHRlcj9lLnN1Ym1pdHRlcihwKTpwLnN1Ym1pdCgpO3NldFRpbWVvdXQoZnVuY3Rpb24oKXtwLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQocCl9LDApfX19KCk7YS5iKFwidXRpbHNcIixhLmEpO2EuYihcInV0aWxzLmFycmF5Rm9yRWFjaFwiLGEuYS5EKTthLmIoXCJ1dGlscy5hcnJheUZpcnN0XCIsYS5hLkxiKTthLmIoXCJ1dGlscy5hcnJheUZpbHRlclwiLGEuYS5qYik7YS5iKFwidXRpbHMuYXJyYXlHZXREaXN0aW5jdFZhbHVlc1wiLGEuYS53Yyk7YS5iKFwidXRpbHMuYXJyYXlJbmRleE9mXCIsYS5hLkEpO2EuYihcInV0aWxzLmFycmF5TWFwXCIsYS5hLk1iKTthLmIoXCJ1dGlscy5hcnJheVB1c2hBbGxcIixhLmEuTmIpO2EuYihcInV0aWxzLmFycmF5UmVtb3ZlSXRlbVwiLGEuYS5QYSk7YS5iKFwidXRpbHMuY2xvbmVOb2Rlc1wiLGEuYS5DYSk7YS5iKFwidXRpbHMuY3JlYXRlU3ltYm9sT3JTdHJpbmdcIixcbmEuYS5EYSk7YS5iKFwidXRpbHMuZXh0ZW5kXCIsYS5hLmV4dGVuZCk7YS5iKFwidXRpbHMuZmllbGRzSW5jbHVkZWRXaXRoSnNvblBvc3RcIixhLmEuSmMpO2EuYihcInV0aWxzLmdldEZvcm1GaWVsZHNcIixhLmEuTGMpO2EuYihcInV0aWxzLm9iamVjdE1hcFwiLGEuYS5HYSk7YS5iKFwidXRpbHMucGVla09ic2VydmFibGVcIixhLmEuYmMpO2EuYihcInV0aWxzLnBvc3RKc29uXCIsYS5hLk9kKTthLmIoXCJ1dGlscy5wYXJzZUpzb25cIixhLmEuTmQpO2EuYihcInV0aWxzLnJlZ2lzdGVyRXZlbnRIYW5kbGVyXCIsYS5hLkIpO2EuYihcInV0aWxzLnN0cmluZ2lmeUpzb25cIixhLmEuaGMpO2EuYihcInV0aWxzLnJhbmdlXCIsYS5hLlBkKTthLmIoXCJ1dGlscy50b2dnbGVEb21Ob2RlQ3NzQ2xhc3NcIixhLmEuRWIpO2EuYihcInV0aWxzLnRyaWdnZXJFdmVudFwiLGEuYS5GYik7YS5iKFwidXRpbHMudW53cmFwT2JzZXJ2YWJsZVwiLGEuYS5mKTthLmIoXCJ1dGlscy5vYmplY3RGb3JFYWNoXCIsYS5hLlApO2EuYihcInV0aWxzLmFkZE9yUmVtb3ZlSXRlbVwiLFxuYS5hLk5hKTthLmIoXCJ1dGlscy5zZXRUZXh0Q29udGVudFwiLGEuYS5CYik7YS5iKFwidW53cmFwXCIsYS5hLmYpO0Z1bmN0aW9uLnByb3RvdHlwZS5iaW5kfHwoRnVuY3Rpb24ucHJvdG90eXBlLmJpbmQ9ZnVuY3Rpb24oYSl7dmFyIGM9dGhpcztpZigxPT09YXJndW1lbnRzLmxlbmd0aClyZXR1cm4gZnVuY3Rpb24oKXtyZXR1cm4gYy5hcHBseShhLGFyZ3VtZW50cyl9O3ZhciBkPUFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywxKTtyZXR1cm4gZnVuY3Rpb24oKXt2YXIgZT1kLnNsaWNlKDApO2UucHVzaC5hcHBseShlLGFyZ3VtZW50cyk7cmV0dXJuIGMuYXBwbHkoYSxlKX19KTthLmEuZz1uZXcgZnVuY3Rpb24oKXt2YXIgYj0wLGM9XCJfX2tvX19cIisobmV3IERhdGUpLmdldFRpbWUoKSxkPXt9LGUsZjthLmEuVz8oZT1mdW5jdGlvbihhLGUpe3ZhciBmPWFbY107aWYoIWZ8fFwibnVsbFwiPT09Znx8IWRbZl0pe2lmKCFlKXJldHVybiBuO2Y9YVtjXT1cImtvXCIrYisrO2RbZl09XG57fX1yZXR1cm4gZFtmXX0sZj1mdW5jdGlvbihhKXt2YXIgYj1hW2NdO3JldHVybiBiPyhkZWxldGUgZFtiXSxhW2NdPW51bGwsITApOiExfSk6KGU9ZnVuY3Rpb24oYSxiKXt2YXIgZD1hW2NdOyFkJiZiJiYoZD1hW2NdPXt9KTtyZXR1cm4gZH0sZj1mdW5jdGlvbihhKXtyZXR1cm4gYVtjXT8oZGVsZXRlIGFbY10sITApOiExfSk7cmV0dXJue2dldDpmdW5jdGlvbihhLGIpe3ZhciBjPWUoYSwhMSk7cmV0dXJuIGMmJmNbYl19LHNldDpmdW5jdGlvbihhLGIsYyl7KGE9ZShhLGMhPT1uKSkmJihhW2JdPWMpfSxVYjpmdW5jdGlvbihhLGIsYyl7YT1lKGEsITApO3JldHVybiBhW2JdfHwoYVtiXT1jKX0sY2xlYXI6ZixaOmZ1bmN0aW9uKCl7cmV0dXJuIGIrKyArY319fTthLmIoXCJ1dGlscy5kb21EYXRhXCIsYS5hLmcpO2EuYihcInV0aWxzLmRvbURhdGEuY2xlYXJcIixhLmEuZy5jbGVhcik7YS5hLks9bmV3IGZ1bmN0aW9uKCl7ZnVuY3Rpb24gYihiLGMpe3ZhciBkPWEuYS5nLmdldChiLGUpO1xuZD09PW4mJmMmJihkPVtdLGEuYS5nLnNldChiLGUsZCkpO3JldHVybiBkfWZ1bmN0aW9uIGMoYyl7dmFyIGU9YihjLCExKTtpZihlKWZvcih2YXIgZT1lLnNsaWNlKDApLGs9MDtrPGUubGVuZ3RoO2srKyllW2tdKGMpO2EuYS5nLmNsZWFyKGMpO2EuYS5LLmNsZWFuRXh0ZXJuYWxEYXRhKGMpO2dbYy5ub2RlVHlwZV0mJmQoYy5jaGlsZE5vZGVzLCEwKX1mdW5jdGlvbiBkKGIsZCl7Zm9yKHZhciBlPVtdLGwsZj0wO2Y8Yi5sZW5ndGg7ZisrKWlmKCFkfHw4PT09YltmXS5ub2RlVHlwZSlpZihjKGVbZS5sZW5ndGhdPWw9YltmXSksYltmXSE9PWwpZm9yKDtmLS0mJi0xPT1hLmEuQShlLGJbZl0pOyk7fXZhciBlPWEuYS5nLlooKSxmPXsxOiEwLDg6ITAsOTohMH0sZz17MTohMCw5OiEwfTtyZXR1cm57emE6ZnVuY3Rpb24oYSxjKXtpZihcImZ1bmN0aW9uXCIhPXR5cGVvZiBjKXRocm93IEVycm9yKFwiQ2FsbGJhY2sgbXVzdCBiZSBhIGZ1bmN0aW9uXCIpO2IoYSwhMCkucHVzaChjKX0seWI6ZnVuY3Rpb24oYyxcbmQpe3ZhciBmPWIoYywhMSk7ZiYmKGEuYS5QYShmLGQpLDA9PWYubGVuZ3RoJiZhLmEuZy5zZXQoYyxlLG4pKX0sb2E6ZnVuY3Rpb24oYil7YS51LkcoZnVuY3Rpb24oKXtmW2Iubm9kZVR5cGVdJiYoYyhiKSxnW2Iubm9kZVR5cGVdJiZkKGIuZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCIqXCIpKSl9KTtyZXR1cm4gYn0scmVtb3ZlTm9kZTpmdW5jdGlvbihiKXthLm9hKGIpO2IucGFyZW50Tm9kZSYmYi5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGIpfSxjbGVhbkV4dGVybmFsRGF0YTpmdW5jdGlvbihhKXt2JiZcImZ1bmN0aW9uXCI9PXR5cGVvZiB2LmNsZWFuRGF0YSYmdi5jbGVhbkRhdGEoW2FdKX19fTthLm9hPWEuYS5LLm9hO2EucmVtb3ZlTm9kZT1hLmEuSy5yZW1vdmVOb2RlO2EuYihcImNsZWFuTm9kZVwiLGEub2EpO2EuYihcInJlbW92ZU5vZGVcIixhLnJlbW92ZU5vZGUpO2EuYihcInV0aWxzLmRvbU5vZGVEaXNwb3NhbFwiLGEuYS5LKTthLmIoXCJ1dGlscy5kb21Ob2RlRGlzcG9zYWwuYWRkRGlzcG9zZUNhbGxiYWNrXCIsXG5hLmEuSy56YSk7YS5iKFwidXRpbHMuZG9tTm9kZURpc3Bvc2FsLnJlbW92ZURpc3Bvc2VDYWxsYmFja1wiLGEuYS5LLnliKTsoZnVuY3Rpb24oKXt2YXIgYj1bMCxcIlwiLFwiXCJdLGM9WzEsXCI8dGFibGU+XCIsXCI8L3RhYmxlPlwiXSxkPVszLFwiPHRhYmxlPjx0Ym9keT48dHI+XCIsXCI8L3RyPjwvdGJvZHk+PC90YWJsZT5cIl0sZT1bMSxcIjxzZWxlY3QgbXVsdGlwbGU9J211bHRpcGxlJz5cIixcIjwvc2VsZWN0PlwiXSxmPXt0aGVhZDpjLHRib2R5OmMsdGZvb3Q6Yyx0cjpbMixcIjx0YWJsZT48dGJvZHk+XCIsXCI8L3Rib2R5PjwvdGFibGU+XCJdLHRkOmQsdGg6ZCxvcHRpb246ZSxvcHRncm91cDplfSxnPTg+PWEuYS5XO2EuYS51YT1mdW5jdGlvbihjLGQpe3ZhciBlO2lmKHYpaWYodi5wYXJzZUhUTUwpZT12LnBhcnNlSFRNTChjLGQpfHxbXTtlbHNle2lmKChlPXYuY2xlYW4oW2NdLGQpKSYmZVswXSl7Zm9yKHZhciBsPWVbMF07bC5wYXJlbnROb2RlJiYxMSE9PWwucGFyZW50Tm9kZS5ub2RlVHlwZTspbD1sLnBhcmVudE5vZGU7XG5sLnBhcmVudE5vZGUmJmwucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChsKX19ZWxzZXsoZT1kKXx8KGU9dyk7dmFyIGw9ZS5wYXJlbnRXaW5kb3d8fGUuZGVmYXVsdFZpZXd8fEEscD1hLmEuRGIoYykudG9Mb3dlckNhc2UoKSxxPWUuY3JlYXRlRWxlbWVudChcImRpdlwiKSx0O3Q9KHA9cC5tYXRjaCgvXig/OlxceDNjIS0tLio/LS1cXHgzZVxccyo/KSo/PChbYS16XSspW1xccz5dLykpJiZmW3BbMV1dfHxiO3A9dFswXTt0PVwiaWdub3JlZDxkaXY+XCIrdFsxXStjK3RbMl0rXCI8L2Rpdj5cIjtcImZ1bmN0aW9uXCI9PXR5cGVvZiBsLmlubmVyU2hpdj9xLmFwcGVuZENoaWxkKGwuaW5uZXJTaGl2KHQpKTooZyYmZS5ib2R5LmFwcGVuZENoaWxkKHEpLHEuaW5uZXJIVE1MPXQsZyYmcS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHEpKTtmb3IoO3AtLTspcT1xLmxhc3RDaGlsZDtlPWEuYS5sYShxLmxhc3RDaGlsZC5jaGlsZE5vZGVzKX1yZXR1cm4gZX07YS5hLk1kPWZ1bmN0aW9uKGIsYyl7dmFyIGQ9YS5hLnVhKGIsXG5jKTtyZXR1cm4gZC5sZW5ndGgmJmRbMF0ucGFyZW50RWxlbWVudHx8YS5hLlliKGQpfTthLmEuZmM9ZnVuY3Rpb24oYixjKXthLmEuVGIoYik7Yz1hLmEuZihjKTtpZihudWxsIT09YyYmYyE9PW4paWYoXCJzdHJpbmdcIiE9dHlwZW9mIGMmJihjPWMudG9TdHJpbmcoKSksdil2KGIpLmh0bWwoYyk7ZWxzZSBmb3IodmFyIGQ9YS5hLnVhKGMsYi5vd25lckRvY3VtZW50KSxlPTA7ZTxkLmxlbmd0aDtlKyspYi5hcHBlbmRDaGlsZChkW2VdKX19KSgpO2EuYihcInV0aWxzLnBhcnNlSHRtbEZyYWdtZW50XCIsYS5hLnVhKTthLmIoXCJ1dGlscy5zZXRIdG1sXCIsYS5hLmZjKTthLmFhPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gYihjLGUpe2lmKGMpaWYoOD09Yy5ub2RlVHlwZSl7dmFyIGY9YS5hYS5VYyhjLm5vZGVWYWx1ZSk7bnVsbCE9ZiYmZS5wdXNoKHt1ZDpjLEtkOmZ9KX1lbHNlIGlmKDE9PWMubm9kZVR5cGUpZm9yKHZhciBmPTAsZz1jLmNoaWxkTm9kZXMsaD1nLmxlbmd0aDtmPGg7ZisrKWIoZ1tmXSxcbmUpfXZhciBjPXt9O3JldHVybntYYjpmdW5jdGlvbihhKXtpZihcImZ1bmN0aW9uXCIhPXR5cGVvZiBhKXRocm93IEVycm9yKFwiWW91IGNhbiBvbmx5IHBhc3MgYSBmdW5jdGlvbiB0byBrby5tZW1vaXphdGlvbi5tZW1vaXplKClcIik7dmFyIGI9KDQyOTQ5NjcyOTYqKDErTWF0aC5yYW5kb20oKSl8MCkudG9TdHJpbmcoMTYpLnN1YnN0cmluZygxKSsoNDI5NDk2NzI5NiooMStNYXRoLnJhbmRvbSgpKXwwKS50b1N0cmluZygxNikuc3Vic3RyaW5nKDEpO2NbYl09YTtyZXR1cm5cIlxceDNjIS0tW2tvX21lbW86XCIrYitcIl0tLVxceDNlXCJ9LGJkOmZ1bmN0aW9uKGEsYil7dmFyIGY9Y1thXTtpZihmPT09bil0aHJvdyBFcnJvcihcIkNvdWxkbid0IGZpbmQgYW55IG1lbW8gd2l0aCBJRCBcIithK1wiLiBQZXJoYXBzIGl0J3MgYWxyZWFkeSBiZWVuIHVubWVtb2l6ZWQuXCIpO3RyeXtyZXR1cm4gZi5hcHBseShudWxsLGJ8fFtdKSwhMH1maW5hbGx5e2RlbGV0ZSBjW2FdfX0sY2Q6ZnVuY3Rpb24oYyxlKXt2YXIgZj1cbltdO2IoYyxmKTtmb3IodmFyIGc9MCxoPWYubGVuZ3RoO2c8aDtnKyspe3ZhciBtPWZbZ10udWQsaz1bbV07ZSYmYS5hLk5iKGssZSk7YS5hYS5iZChmW2ddLktkLGspO20ubm9kZVZhbHVlPVwiXCI7bS5wYXJlbnROb2RlJiZtLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQobSl9fSxVYzpmdW5jdGlvbihhKXtyZXR1cm4oYT1hLm1hdGNoKC9eXFxba29fbWVtb1xcOiguKj8pXFxdJC8pKT9hWzFdOm51bGx9fX0oKTthLmIoXCJtZW1vaXphdGlvblwiLGEuYWEpO2EuYihcIm1lbW9pemF0aW9uLm1lbW9pemVcIixhLmFhLlhiKTthLmIoXCJtZW1vaXphdGlvbi51bm1lbW9pemVcIixhLmFhLmJkKTthLmIoXCJtZW1vaXphdGlvbi5wYXJzZU1lbW9UZXh0XCIsYS5hYS5VYyk7YS5iKFwibWVtb2l6YXRpb24udW5tZW1vaXplRG9tTm9kZUFuZERlc2NlbmRhbnRzXCIsYS5hYS5jZCk7YS5uYT1mdW5jdGlvbigpe2Z1bmN0aW9uIGIoKXtpZihmKWZvcih2YXIgYj1mLGM9MCxkO2g8ZjspaWYoZD1lW2grK10pe2lmKGg+Yil7aWYoNUUzPD1cbisrYyl7aD1mO2EuYS5HYyhFcnJvcihcIidUb28gbXVjaCByZWN1cnNpb24nIGFmdGVyIHByb2Nlc3NpbmcgXCIrYytcIiB0YXNrIGdyb3Vwcy5cIikpO2JyZWFrfWI9Zn10cnl7ZCgpfWNhdGNoKHApe2EuYS5HYyhwKX19fWZ1bmN0aW9uIGMoKXtiKCk7aD1mPWUubGVuZ3RoPTB9dmFyIGQsZT1bXSxmPTAsZz0xLGg9MDtBLk11dGF0aW9uT2JzZXJ2ZXI/ZD1mdW5jdGlvbihhKXt2YXIgYj13LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7KG5ldyBNdXRhdGlvbk9ic2VydmVyKGEpKS5vYnNlcnZlKGIse2F0dHJpYnV0ZXM6ITB9KTtyZXR1cm4gZnVuY3Rpb24oKXtiLmNsYXNzTGlzdC50b2dnbGUoXCJmb29cIil9fShjKTpkPXcmJlwib25yZWFkeXN0YXRlY2hhbmdlXCJpbiB3LmNyZWF0ZUVsZW1lbnQoXCJzY3JpcHRcIik/ZnVuY3Rpb24oYSl7dmFyIGI9dy5jcmVhdGVFbGVtZW50KFwic2NyaXB0XCIpO2Iub25yZWFkeXN0YXRlY2hhbmdlPWZ1bmN0aW9uKCl7Yi5vbnJlYWR5c3RhdGVjaGFuZ2U9bnVsbDt3LmRvY3VtZW50RWxlbWVudC5yZW1vdmVDaGlsZChiKTtcbmI9bnVsbDthKCl9O3cuZG9jdW1lbnRFbGVtZW50LmFwcGVuZENoaWxkKGIpfTpmdW5jdGlvbihhKXtzZXRUaW1lb3V0KGEsMCl9O3JldHVybntzY2hlZHVsZXI6ZCx6YjpmdW5jdGlvbihiKXtmfHxhLm5hLnNjaGVkdWxlcihjKTtlW2YrK109YjtyZXR1cm4gZysrfSxjYW5jZWw6ZnVuY3Rpb24oYSl7YT1hLShnLWYpO2E+PWgmJmE8ZiYmKGVbYV09bnVsbCl9LHJlc2V0Rm9yVGVzdGluZzpmdW5jdGlvbigpe3ZhciBhPWYtaDtoPWY9ZS5sZW5ndGg9MDtyZXR1cm4gYX0sU2Q6Yn19KCk7YS5iKFwidGFza3NcIixhLm5hKTthLmIoXCJ0YXNrcy5zY2hlZHVsZVwiLGEubmEuemIpO2EuYihcInRhc2tzLnJ1bkVhcmx5XCIsYS5uYS5TZCk7YS5UYT17dGhyb3R0bGU6ZnVuY3Rpb24oYixjKXtiLnRocm90dGxlRXZhbHVhdGlvbj1jO3ZhciBkPW51bGw7cmV0dXJuIGEuJCh7cmVhZDpiLHdyaXRlOmZ1bmN0aW9uKGUpe2NsZWFyVGltZW91dChkKTtkPWEuYS5zZXRUaW1lb3V0KGZ1bmN0aW9uKCl7YihlKX0sXG5jKX19KX0scmF0ZUxpbWl0OmZ1bmN0aW9uKGEsYyl7dmFyIGQsZSxmO1wibnVtYmVyXCI9PXR5cGVvZiBjP2Q9YzooZD1jLnRpbWVvdXQsZT1jLm1ldGhvZCk7YS5IYj0hMTtmPVwiZnVuY3Rpb25cIj09dHlwZW9mIGU/ZTpcIm5vdGlmeVdoZW5DaGFuZ2VzU3RvcFwiPT1lP1k6WDthLnViKGZ1bmN0aW9uKGEpe3JldHVybiBmKGEsZCxjKX0pfSxkZWZlcnJlZDpmdW5jdGlvbihiLGMpe2lmKCEwIT09Yyl0aHJvdyBFcnJvcihcIlRoZSAnZGVmZXJyZWQnIGV4dGVuZGVyIG9ubHkgYWNjZXB0cyB0aGUgdmFsdWUgJ3RydWUnLCBiZWNhdXNlIGl0IGlzIG5vdCBzdXBwb3J0ZWQgdG8gdHVybiBkZWZlcnJhbCBvZmYgb25jZSBlbmFibGVkLlwiKTtiLkhifHwoYi5IYj0hMCxiLnViKGZ1bmN0aW9uKGMpe3ZhciBlLGY9ITE7cmV0dXJuIGZ1bmN0aW9uKCl7aWYoIWYpe2EubmEuY2FuY2VsKGUpO2U9YS5uYS56YihjKTt0cnl7Zj0hMCxiLm5vdGlmeVN1YnNjcmliZXJzKG4sXCJkaXJ0eVwiKX1maW5hbGx5e2Y9XG4hMX19fX0pKX0sbm90aWZ5OmZ1bmN0aW9uKGEsYyl7YS5lcXVhbGl0eUNvbXBhcmVyPVwiYWx3YXlzXCI9PWM/bnVsbDpLfX07dmFyIFc9e3VuZGVmaW5lZDoxLFwiYm9vbGVhblwiOjEsbnVtYmVyOjEsc3RyaW5nOjF9O2EuYihcImV4dGVuZGVyc1wiLGEuVGEpO2EuaWM9ZnVuY3Rpb24oYixjLGQpe3RoaXMuZGE9Yjt0aGlzLmxjPWM7dGhpcy5tYz1kO3RoaXMuSWI9ITE7dGhpcy5mYj10aGlzLkpiPW51bGw7YS5MKHRoaXMsXCJkaXNwb3NlXCIsdGhpcy5zKTthLkwodGhpcyxcImRpc3Bvc2VXaGVuTm9kZUlzUmVtb3ZlZFwiLHRoaXMubCl9O2EuaWMucHJvdG90eXBlLnM9ZnVuY3Rpb24oKXt0aGlzLklifHwodGhpcy5mYiYmYS5hLksueWIodGhpcy5KYix0aGlzLmZiKSx0aGlzLkliPSEwLHRoaXMubWMoKSx0aGlzLmRhPXRoaXMubGM9dGhpcy5tYz10aGlzLkpiPXRoaXMuZmI9bnVsbCl9O2EuaWMucHJvdG90eXBlLmw9ZnVuY3Rpb24oYil7dGhpcy5KYj1iO2EuYS5LLnphKGIsdGhpcy5mYj10aGlzLnMuYmluZCh0aGlzKSl9O1xuYS5UPWZ1bmN0aW9uKCl7YS5hLkFiKHRoaXMsRCk7RC5xYih0aGlzKX07dmFyIEQ9e3FiOmZ1bmN0aW9uKGEpe2EuVT17Y2hhbmdlOltdfTthLnNjPTF9LHN1YnNjcmliZTpmdW5jdGlvbihiLGMsZCl7dmFyIGU9dGhpcztkPWR8fFwiY2hhbmdlXCI7dmFyIGY9bmV3IGEuaWMoZSxjP2IuYmluZChjKTpiLGZ1bmN0aW9uKCl7YS5hLlBhKGUuVVtkXSxmKTtlLmhiJiZlLmhiKGQpfSk7ZS5RYSYmZS5RYShkKTtlLlVbZF18fChlLlVbZF09W10pO2UuVVtkXS5wdXNoKGYpO3JldHVybiBmfSxub3RpZnlTdWJzY3JpYmVyczpmdW5jdGlvbihiLGMpe2M9Y3x8XCJjaGFuZ2VcIjtcImNoYW5nZVwiPT09YyYmdGhpcy5HYigpO2lmKHRoaXMuV2EoYykpe3ZhciBkPVwiY2hhbmdlXCI9PT1jJiZ0aGlzLmVkfHx0aGlzLlVbY10uc2xpY2UoMCk7dHJ5e2EudS54YygpO2Zvcih2YXIgZT0wLGY7Zj1kW2VdOysrZSlmLklifHxmLmxjKGIpfWZpbmFsbHl7YS51LmVuZCgpfX19LG9iOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuc2N9LFxuRGQ6ZnVuY3Rpb24oYSl7cmV0dXJuIHRoaXMub2IoKSE9PWF9LEdiOmZ1bmN0aW9uKCl7Kyt0aGlzLnNjfSx1YjpmdW5jdGlvbihiKXt2YXIgYz10aGlzLGQ9YS5PKGMpLGUsZixnLGgsbTtjLmdifHwoYy5nYj1jLm5vdGlmeVN1YnNjcmliZXJzLGMubm90aWZ5U3Vic2NyaWJlcnM9Wik7dmFyIGs9YihmdW5jdGlvbigpe2MuSmE9ITE7ZCYmaD09PWMmJihoPWMubmM/Yy5uYygpOmMoKSk7dmFyIGE9Znx8bSYmYy5zYihnLGgpO209Zj1lPSExO2EmJmMuZ2IoZz1oKX0pO2MucWM9ZnVuY3Rpb24oYSxiKXtiJiZjLkphfHwobT0hYik7Yy5lZD1jLlUuY2hhbmdlLnNsaWNlKDApO2MuSmE9ZT0hMDtoPWE7aygpfTtjLnBjPWZ1bmN0aW9uKGEpe2V8fChnPWEsYy5nYihhLFwiYmVmb3JlQ2hhbmdlXCIpKX07Yy5yYz1mdW5jdGlvbigpe209ITB9O2MuZ2Q9ZnVuY3Rpb24oKXtjLnNiKGcsYy52KCEwKSkmJihmPSEwKX19LFdhOmZ1bmN0aW9uKGEpe3JldHVybiB0aGlzLlVbYV0mJnRoaXMuVVthXS5sZW5ndGh9LFxuQmQ6ZnVuY3Rpb24oYil7aWYoYilyZXR1cm4gdGhpcy5VW2JdJiZ0aGlzLlVbYl0ubGVuZ3RofHwwO3ZhciBjPTA7YS5hLlAodGhpcy5VLGZ1bmN0aW9uKGEsYil7XCJkaXJ0eVwiIT09YSYmKGMrPWIubGVuZ3RoKX0pO3JldHVybiBjfSxzYjpmdW5jdGlvbihhLGMpe3JldHVybiF0aGlzLmVxdWFsaXR5Q29tcGFyZXJ8fCF0aGlzLmVxdWFsaXR5Q29tcGFyZXIoYSxjKX0sdG9TdHJpbmc6ZnVuY3Rpb24oKXtyZXR1cm5cIltvYmplY3QgT2JqZWN0XVwifSxleHRlbmQ6ZnVuY3Rpb24oYil7dmFyIGM9dGhpcztiJiZhLmEuUChiLGZ1bmN0aW9uKGIsZSl7dmFyIGY9YS5UYVtiXTtcImZ1bmN0aW9uXCI9PXR5cGVvZiBmJiYoYz1mKGMsZSl8fGMpfSk7cmV0dXJuIGN9fTthLkwoRCxcImluaXRcIixELnFiKTthLkwoRCxcInN1YnNjcmliZVwiLEQuc3Vic2NyaWJlKTthLkwoRCxcImV4dGVuZFwiLEQuZXh0ZW5kKTthLkwoRCxcImdldFN1YnNjcmlwdGlvbnNDb3VudFwiLEQuQmQpO2EuYS5CYSYmYS5hLnNldFByb3RvdHlwZU9mKEQsXG5GdW5jdGlvbi5wcm90b3R5cGUpO2EuVC5mbj1EO2EuUWM9ZnVuY3Rpb24oYSl7cmV0dXJuIG51bGwhPWEmJlwiZnVuY3Rpb25cIj09dHlwZW9mIGEuc3Vic2NyaWJlJiZcImZ1bmN0aW9uXCI9PXR5cGVvZiBhLm5vdGlmeVN1YnNjcmliZXJzfTthLmIoXCJzdWJzY3JpYmFibGVcIixhLlQpO2EuYihcImlzU3Vic2NyaWJhYmxlXCIsYS5RYyk7YS5TPWEudT1mdW5jdGlvbigpe2Z1bmN0aW9uIGIoYSl7ZC5wdXNoKGUpO2U9YX1mdW5jdGlvbiBjKCl7ZT1kLnBvcCgpfXZhciBkPVtdLGUsZj0wO3JldHVybnt4YzpiLGVuZDpjLGNjOmZ1bmN0aW9uKGIpe2lmKGUpe2lmKCFhLlFjKGIpKXRocm93IEVycm9yKFwiT25seSBzdWJzY3JpYmFibGUgdGhpbmdzIGNhbiBhY3QgYXMgZGVwZW5kZW5jaWVzXCIpO2Uub2QuY2FsbChlLnBkLGIsYi5mZHx8KGIuZmQ9KytmKSl9fSxHOmZ1bmN0aW9uKGEsZCxlKXt0cnl7cmV0dXJuIGIoKSxhLmFwcGx5KGQsZXx8W10pfWZpbmFsbHl7YygpfX0scWE6ZnVuY3Rpb24oKXtpZihlKXJldHVybiBlLm8ucWEoKX0sXG5WYTpmdW5jdGlvbigpe2lmKGUpcmV0dXJuIGUuby5WYSgpfSxZYTpmdW5jdGlvbigpe2lmKGUpcmV0dXJuIGUuWWF9LG86ZnVuY3Rpb24oKXtpZihlKXJldHVybiBlLm99fX0oKTthLmIoXCJjb21wdXRlZENvbnRleHRcIixhLlMpO2EuYihcImNvbXB1dGVkQ29udGV4dC5nZXREZXBlbmRlbmNpZXNDb3VudFwiLGEuUy5xYSk7YS5iKFwiY29tcHV0ZWRDb250ZXh0LmdldERlcGVuZGVuY2llc1wiLGEuUy5WYSk7YS5iKFwiY29tcHV0ZWRDb250ZXh0LmlzSW5pdGlhbFwiLGEuUy5ZYSk7YS5iKFwiY29tcHV0ZWRDb250ZXh0LnJlZ2lzdGVyRGVwZW5kZW5jeVwiLGEuUy5jYyk7YS5iKFwiaWdub3JlRGVwZW5kZW5jaWVzXCIsYS5ZZD1hLnUuRyk7dmFyIEk9YS5hLkRhKFwiX2xhdGVzdFZhbHVlXCIpO2EudGE9ZnVuY3Rpb24oYil7ZnVuY3Rpb24gYygpe2lmKDA8YXJndW1lbnRzLmxlbmd0aClyZXR1cm4gYy5zYihjW0ldLGFyZ3VtZW50c1swXSkmJihjLnlhKCksY1tJXT1hcmd1bWVudHNbMF0sYy54YSgpKSx0aGlzO1xuYS51LmNjKGMpO3JldHVybiBjW0ldfWNbSV09YjthLmEuQmF8fGEuYS5leHRlbmQoYyxhLlQuZm4pO2EuVC5mbi5xYihjKTthLmEuQWIoYyxGKTthLm9wdGlvbnMuZGVmZXJVcGRhdGVzJiZhLlRhLmRlZmVycmVkKGMsITApO3JldHVybiBjfTt2YXIgRj17ZXF1YWxpdHlDb21wYXJlcjpLLHY6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpc1tJXX0seGE6ZnVuY3Rpb24oKXt0aGlzLm5vdGlmeVN1YnNjcmliZXJzKHRoaXNbSV0sXCJzcGVjdGF0ZVwiKTt0aGlzLm5vdGlmeVN1YnNjcmliZXJzKHRoaXNbSV0pfSx5YTpmdW5jdGlvbigpe3RoaXMubm90aWZ5U3Vic2NyaWJlcnModGhpc1tJXSxcImJlZm9yZUNoYW5nZVwiKX19O2EuYS5CYSYmYS5hLnNldFByb3RvdHlwZU9mKEYsYS5ULmZuKTt2YXIgRz1hLnRhLk1hPVwiX19rb19wcm90b19fXCI7RltHXT1hLnRhO2EuTz1mdW5jdGlvbihiKXtpZigoYj1cImZ1bmN0aW9uXCI9PXR5cGVvZiBiJiZiW0ddKSYmYiE9PUZbR10mJmIhPT1hLm8uZm5bR10pdGhyb3cgRXJyb3IoXCJJbnZhbGlkIG9iamVjdCB0aGF0IGxvb2tzIGxpa2UgYW4gb2JzZXJ2YWJsZTsgcG9zc2libHkgZnJvbSBhbm90aGVyIEtub2Nrb3V0IGluc3RhbmNlXCIpO1xucmV0dXJuISFifTthLlphPWZ1bmN0aW9uKGIpe3JldHVyblwiZnVuY3Rpb25cIj09dHlwZW9mIGImJihiW0ddPT09RltHXXx8YltHXT09PWEuby5mbltHXSYmYi5OYyl9O2EuYihcIm9ic2VydmFibGVcIixhLnRhKTthLmIoXCJpc09ic2VydmFibGVcIixhLk8pO2EuYihcImlzV3JpdGVhYmxlT2JzZXJ2YWJsZVwiLGEuWmEpO2EuYihcImlzV3JpdGFibGVPYnNlcnZhYmxlXCIsYS5aYSk7YS5iKFwib2JzZXJ2YWJsZS5mblwiLEYpO2EuTChGLFwicGVla1wiLEYudik7YS5MKEYsXCJ2YWx1ZUhhc011dGF0ZWRcIixGLnhhKTthLkwoRixcInZhbHVlV2lsbE11dGF0ZVwiLEYueWEpO2EuSGE9ZnVuY3Rpb24oYil7Yj1ifHxbXTtpZihcIm9iamVjdFwiIT10eXBlb2YgYnx8IShcImxlbmd0aFwiaW4gYikpdGhyb3cgRXJyb3IoXCJUaGUgYXJndW1lbnQgcGFzc2VkIHdoZW4gaW5pdGlhbGl6aW5nIGFuIG9ic2VydmFibGUgYXJyYXkgbXVzdCBiZSBhbiBhcnJheSwgb3IgbnVsbCwgb3IgdW5kZWZpbmVkLlwiKTtiPWEudGEoYik7YS5hLkFiKGIsXG5hLkhhLmZuKTtyZXR1cm4gYi5leHRlbmQoe3RyYWNrQXJyYXlDaGFuZ2VzOiEwfSl9O2EuSGEuZm49e3JlbW92ZTpmdW5jdGlvbihiKXtmb3IodmFyIGM9dGhpcy52KCksZD1bXSxlPVwiZnVuY3Rpb25cIiE9dHlwZW9mIGJ8fGEuTyhiKT9mdW5jdGlvbihhKXtyZXR1cm4gYT09PWJ9OmIsZj0wO2Y8Yy5sZW5ndGg7ZisrKXt2YXIgZz1jW2ZdO2lmKGUoZykpezA9PT1kLmxlbmd0aCYmdGhpcy55YSgpO2lmKGNbZl0hPT1nKXRocm93IEVycm9yKFwiQXJyYXkgbW9kaWZpZWQgZHVyaW5nIHJlbW92ZTsgY2Fubm90IHJlbW92ZSBpdGVtXCIpO2QucHVzaChnKTtjLnNwbGljZShmLDEpO2YtLX19ZC5sZW5ndGgmJnRoaXMueGEoKTtyZXR1cm4gZH0scmVtb3ZlQWxsOmZ1bmN0aW9uKGIpe2lmKGI9PT1uKXt2YXIgYz10aGlzLnYoKSxkPWMuc2xpY2UoMCk7dGhpcy55YSgpO2Muc3BsaWNlKDAsYy5sZW5ndGgpO3RoaXMueGEoKTtyZXR1cm4gZH1yZXR1cm4gYj90aGlzLnJlbW92ZShmdW5jdGlvbihjKXtyZXR1cm4gMDw9XG5hLmEuQShiLGMpfSk6W119LGRlc3Ryb3k6ZnVuY3Rpb24oYil7dmFyIGM9dGhpcy52KCksZD1cImZ1bmN0aW9uXCIhPXR5cGVvZiBifHxhLk8oYik/ZnVuY3Rpb24oYSl7cmV0dXJuIGE9PT1ifTpiO3RoaXMueWEoKTtmb3IodmFyIGU9Yy5sZW5ndGgtMTswPD1lO2UtLSl7dmFyIGY9Y1tlXTtkKGYpJiYoZi5fZGVzdHJveT0hMCl9dGhpcy54YSgpfSxkZXN0cm95QWxsOmZ1bmN0aW9uKGIpe3JldHVybiBiPT09bj90aGlzLmRlc3Ryb3koZnVuY3Rpb24oKXtyZXR1cm4hMH0pOmI/dGhpcy5kZXN0cm95KGZ1bmN0aW9uKGMpe3JldHVybiAwPD1hLmEuQShiLGMpfSk6W119LGluZGV4T2Y6ZnVuY3Rpb24oYil7dmFyIGM9dGhpcygpO3JldHVybiBhLmEuQShjLGIpfSxyZXBsYWNlOmZ1bmN0aW9uKGEsYyl7dmFyIGQ9dGhpcy5pbmRleE9mKGEpOzA8PWQmJih0aGlzLnlhKCksdGhpcy52KClbZF09Yyx0aGlzLnhhKCkpfSxzb3J0ZWQ6ZnVuY3Rpb24oYSl7dmFyIGM9dGhpcygpLnNsaWNlKDApO1xucmV0dXJuIGE/Yy5zb3J0KGEpOmMuc29ydCgpfSxyZXZlcnNlZDpmdW5jdGlvbigpe3JldHVybiB0aGlzKCkuc2xpY2UoMCkucmV2ZXJzZSgpfX07YS5hLkJhJiZhLmEuc2V0UHJvdG90eXBlT2YoYS5IYS5mbixhLnRhLmZuKTthLmEuRChcInBvcCBwdXNoIHJldmVyc2Ugc2hpZnQgc29ydCBzcGxpY2UgdW5zaGlmdFwiLnNwbGl0KFwiIFwiKSxmdW5jdGlvbihiKXthLkhhLmZuW2JdPWZ1bmN0aW9uKCl7dmFyIGE9dGhpcy52KCk7dGhpcy55YSgpO3RoaXMuemMoYSxiLGFyZ3VtZW50cyk7dmFyIGQ9YVtiXS5hcHBseShhLGFyZ3VtZW50cyk7dGhpcy54YSgpO3JldHVybiBkPT09YT90aGlzOmR9fSk7YS5hLkQoW1wic2xpY2VcIl0sZnVuY3Rpb24oYil7YS5IYS5mbltiXT1mdW5jdGlvbigpe3ZhciBhPXRoaXMoKTtyZXR1cm4gYVtiXS5hcHBseShhLGFyZ3VtZW50cyl9fSk7YS5QYz1mdW5jdGlvbihiKXtyZXR1cm4gYS5PKGIpJiZcImZ1bmN0aW9uXCI9PXR5cGVvZiBiLnJlbW92ZSYmXCJmdW5jdGlvblwiPT1cbnR5cGVvZiBiLnB1c2h9O2EuYihcIm9ic2VydmFibGVBcnJheVwiLGEuSGEpO2EuYihcImlzT2JzZXJ2YWJsZUFycmF5XCIsYS5QYyk7YS5UYS50cmFja0FycmF5Q2hhbmdlcz1mdW5jdGlvbihiLGMpe2Z1bmN0aW9uIGQoKXtmdW5jdGlvbiBjKCl7aWYobSl7dmFyIGQ9W10uY29uY2F0KGIudigpfHxbXSksZTtpZihiLldhKFwiYXJyYXlDaGFuZ2VcIikpe2lmKCFmfHwxPG0pZj1hLmEuUGIoayxkLGIuT2IpO2U9Zn1rPWQ7Zj1udWxsO209MDtlJiZlLmxlbmd0aCYmYi5ub3RpZnlTdWJzY3JpYmVycyhlLFwiYXJyYXlDaGFuZ2VcIil9fWU/YygpOihlPSEwLGg9Yi5zdWJzY3JpYmUoZnVuY3Rpb24oKXsrK219LG51bGwsXCJzcGVjdGF0ZVwiKSxrPVtdLmNvbmNhdChiLnYoKXx8W10pLGY9bnVsbCxnPWIuc3Vic2NyaWJlKGMpKX1iLk9iPXt9O2MmJlwib2JqZWN0XCI9PXR5cGVvZiBjJiZhLmEuZXh0ZW5kKGIuT2IsYyk7Yi5PYi5zcGFyc2U9ITA7aWYoIWIuemMpe3ZhciBlPSExLGY9bnVsbCxnLGgsbT0wLFxuayxsPWIuUWEscD1iLmhiO2IuUWE9ZnVuY3Rpb24oYSl7bCYmbC5jYWxsKGIsYSk7XCJhcnJheUNoYW5nZVwiPT09YSYmZCgpfTtiLmhiPWZ1bmN0aW9uKGEpe3AmJnAuY2FsbChiLGEpO1wiYXJyYXlDaGFuZ2VcIiE9PWF8fGIuV2EoXCJhcnJheUNoYW5nZVwiKXx8KGcmJmcucygpLGgmJmgucygpLGg9Zz1udWxsLGU9ITEsaz1uKX07Yi56Yz1mdW5jdGlvbihiLGMsZCl7ZnVuY3Rpb24gbChhLGIsYyl7cmV0dXJuIGtbay5sZW5ndGhdPXtzdGF0dXM6YSx2YWx1ZTpiLGluZGV4OmN9fWlmKGUmJiFtKXt2YXIgaz1bXSxwPWIubGVuZ3RoLGc9ZC5sZW5ndGgsaD0wO3N3aXRjaChjKXtjYXNlIFwicHVzaFwiOmg9cDtjYXNlIFwidW5zaGlmdFwiOmZvcihjPTA7YzxnO2MrKylsKFwiYWRkZWRcIixkW2NdLGgrYyk7YnJlYWs7Y2FzZSBcInBvcFwiOmg9cC0xO2Nhc2UgXCJzaGlmdFwiOnAmJmwoXCJkZWxldGVkXCIsYltoXSxoKTticmVhaztjYXNlIFwic3BsaWNlXCI6Yz1NYXRoLm1pbihNYXRoLm1heCgwLDA+ZFswXT9wK2RbMF06XG5kWzBdKSxwKTtmb3IodmFyIHA9MT09PWc/cDpNYXRoLm1pbihjKyhkWzFdfHwwKSxwKSxnPWMrZy0yLGg9TWF0aC5tYXgocCxnKSxVPVtdLEw9W10sbj0yO2M8aDsrK2MsKytuKWM8cCYmTC5wdXNoKGwoXCJkZWxldGVkXCIsYltjXSxjKSksYzxnJiZVLnB1c2gobChcImFkZGVkXCIsZFtuXSxjKSk7YS5hLktjKEwsVSk7YnJlYWs7ZGVmYXVsdDpyZXR1cm59Zj1rfX19fTt2YXIgcj1hLmEuRGEoXCJfc3RhdGVcIik7YS5vPWEuJD1mdW5jdGlvbihiLGMsZCl7ZnVuY3Rpb24gZSgpe2lmKDA8YXJndW1lbnRzLmxlbmd0aCl7aWYoXCJmdW5jdGlvblwiPT09dHlwZW9mIGYpZi5hcHBseShnLm5iLGFyZ3VtZW50cyk7ZWxzZSB0aHJvdyBFcnJvcihcIkNhbm5vdCB3cml0ZSBhIHZhbHVlIHRvIGEga28uY29tcHV0ZWQgdW5sZXNzIHlvdSBzcGVjaWZ5IGEgJ3dyaXRlJyBvcHRpb24uIElmIHlvdSB3aXNoIHRvIHJlYWQgdGhlIGN1cnJlbnQgdmFsdWUsIGRvbid0IHBhc3MgYW55IHBhcmFtZXRlcnMuXCIpO3JldHVybiB0aGlzfWcucmF8fFxuYS51LmNjKGUpOyhnLmthfHxnLkomJmUuWGEoKSkmJmUuaGEoKTtyZXR1cm4gZy5YfVwib2JqZWN0XCI9PT10eXBlb2YgYj9kPWI6KGQ9ZHx8e30sYiYmKGQucmVhZD1iKSk7aWYoXCJmdW5jdGlvblwiIT10eXBlb2YgZC5yZWFkKXRocm93IEVycm9yKFwiUGFzcyBhIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyB0aGUgdmFsdWUgb2YgdGhlIGtvLmNvbXB1dGVkXCIpO3ZhciBmPWQud3JpdGUsZz17WDpuLHNhOiEwLGthOiEwLHJiOiExLGpjOiExLHJhOiExLHdiOiExLEo6ITEsV2M6ZC5yZWFkLG5iOmN8fGQub3duZXIsbDpkLmRpc3Bvc2VXaGVuTm9kZUlzUmVtb3ZlZHx8ZC5sfHxudWxsLFNhOmQuZGlzcG9zZVdoZW58fGQuU2EsUmI6bnVsbCxJOnt9LFY6MCxJYzpudWxsfTtlW3JdPWc7ZS5OYz1cImZ1bmN0aW9uXCI9PT10eXBlb2YgZjthLmEuQmF8fGEuYS5leHRlbmQoZSxhLlQuZm4pO2EuVC5mbi5xYihlKTthLmEuQWIoZSxDKTtkLnB1cmU/KGcud2I9ITAsZy5KPSEwLGEuYS5leHRlbmQoZSxkYSkpOlxuZC5kZWZlckV2YWx1YXRpb24mJmEuYS5leHRlbmQoZSxlYSk7YS5vcHRpb25zLmRlZmVyVXBkYXRlcyYmYS5UYS5kZWZlcnJlZChlLCEwKTtnLmwmJihnLmpjPSEwLGcubC5ub2RlVHlwZXx8KGcubD1udWxsKSk7Zy5KfHxkLmRlZmVyRXZhbHVhdGlvbnx8ZS5oYSgpO2cubCYmZS5qYSgpJiZhLmEuSy56YShnLmwsZy5SYj1mdW5jdGlvbigpe2UucygpfSk7cmV0dXJuIGV9O3ZhciBDPXtlcXVhbGl0eUNvbXBhcmVyOksscWE6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpc1tyXS5WfSxWYTpmdW5jdGlvbigpe3ZhciBiPVtdO2EuYS5QKHRoaXNbcl0uSSxmdW5jdGlvbihhLGQpe2JbZC5LYV09ZC5kYX0pO3JldHVybiBifSxWYjpmdW5jdGlvbihiKXtpZighdGhpc1tyXS5WKXJldHVybiExO3ZhciBjPXRoaXMuVmEoKTtyZXR1cm4tMSE9PWEuYS5BKGMsYik/ITA6ISFhLmEuTGIoYyxmdW5jdGlvbihhKXtyZXR1cm4gYS5WYiYmYS5WYihiKX0pfSx1YzpmdW5jdGlvbihhLGMsZCl7aWYodGhpc1tyXS53YiYmXG5jPT09dGhpcyl0aHJvdyBFcnJvcihcIkEgJ3B1cmUnIGNvbXB1dGVkIG11c3Qgbm90IGJlIGNhbGxlZCByZWN1cnNpdmVseVwiKTt0aGlzW3JdLklbYV09ZDtkLkthPXRoaXNbcl0uVisrO2QuTGE9Yy5vYigpfSxYYTpmdW5jdGlvbigpe3ZhciBhLGMsZD10aGlzW3JdLkk7Zm9yKGEgaW4gZClpZihPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoZCxhKSYmKGM9ZFthXSx0aGlzLklhJiZjLmRhLkphfHxjLmRhLkRkKGMuTGEpKSlyZXR1cm4hMH0sSmQ6ZnVuY3Rpb24oKXt0aGlzLklhJiYhdGhpc1tyXS5yYiYmdGhpcy5JYSghMSl9LGphOmZ1bmN0aW9uKCl7dmFyIGE9dGhpc1tyXTtyZXR1cm4gYS5rYXx8MDxhLlZ9LFJkOmZ1bmN0aW9uKCl7dGhpcy5KYT90aGlzW3JdLmthJiYodGhpc1tyXS5zYT0hMCk6dGhpcy5IYygpfSwkYzpmdW5jdGlvbihhKXtpZihhLkhiKXt2YXIgYz1hLnN1YnNjcmliZSh0aGlzLkpkLHRoaXMsXCJkaXJ0eVwiKSxkPWEuc3Vic2NyaWJlKHRoaXMuUmQsXG50aGlzKTtyZXR1cm57ZGE6YSxzOmZ1bmN0aW9uKCl7Yy5zKCk7ZC5zKCl9fX1yZXR1cm4gYS5zdWJzY3JpYmUodGhpcy5IYyx0aGlzKX0sSGM6ZnVuY3Rpb24oKXt2YXIgYj10aGlzLGM9Yi50aHJvdHRsZUV2YWx1YXRpb247YyYmMDw9Yz8oY2xlYXJUaW1lb3V0KHRoaXNbcl0uSWMpLHRoaXNbcl0uSWM9YS5hLnNldFRpbWVvdXQoZnVuY3Rpb24oKXtiLmhhKCEwKX0sYykpOmIuSWE/Yi5JYSghMCk6Yi5oYSghMCl9LGhhOmZ1bmN0aW9uKGIpe3ZhciBjPXRoaXNbcl0sZD1jLlNhLGU9ITE7aWYoIWMucmImJiFjLnJhKXtpZihjLmwmJiFhLmEuU2IoYy5sKXx8ZCYmZCgpKXtpZighYy5qYyl7dGhpcy5zKCk7cmV0dXJufX1lbHNlIGMuamM9ITE7Yy5yYj0hMDt0cnl7ZT10aGlzLnpkKGIpfWZpbmFsbHl7Yy5yYj0hMX1yZXR1cm4gZX19LHpkOmZ1bmN0aW9uKGIpe3ZhciBjPXRoaXNbcl0sZD0hMSxlPWMud2I/bjohYy5WLGQ9e3FkOnRoaXMsbWI6Yy5JLFFiOmMuVn07YS51LnhjKHtwZDpkLFxub2Q6YmEsbzp0aGlzLFlhOmV9KTtjLkk9e307Yy5WPTA7dmFyIGY9dGhpcy55ZChjLGQpO2MuVj9kPXRoaXMuc2IoYy5YLGYpOih0aGlzLnMoKSxkPSEwKTtkJiYoYy5KP3RoaXMuR2IoKTp0aGlzLm5vdGlmeVN1YnNjcmliZXJzKGMuWCxcImJlZm9yZUNoYW5nZVwiKSxjLlg9Zix0aGlzLm5vdGlmeVN1YnNjcmliZXJzKGMuWCxcInNwZWN0YXRlXCIpLCFjLkomJmImJnRoaXMubm90aWZ5U3Vic2NyaWJlcnMoYy5YKSx0aGlzLnJjJiZ0aGlzLnJjKCkpO2UmJnRoaXMubm90aWZ5U3Vic2NyaWJlcnMoYy5YLFwiYXdha2VcIik7cmV0dXJuIGR9LHlkOmZ1bmN0aW9uKGIsYyl7dHJ5e3ZhciBkPWIuV2M7cmV0dXJuIGIubmI/ZC5jYWxsKGIubmIpOmQoKX1maW5hbGx5e2EudS5lbmQoKSxjLlFiJiYhYi5KJiZhLmEuUChjLm1iLGFhKSxiLnNhPWIua2E9ITF9fSx2OmZ1bmN0aW9uKGEpe3ZhciBjPXRoaXNbcl07KGMua2EmJihhfHwhYy5WKXx8Yy5KJiZ0aGlzLlhhKCkpJiZ0aGlzLmhhKCk7cmV0dXJuIGMuWH0sXG51YjpmdW5jdGlvbihiKXthLlQuZm4udWIuY2FsbCh0aGlzLGIpO3RoaXMubmM9ZnVuY3Rpb24oKXt0aGlzW3JdLkp8fCh0aGlzW3JdLnNhP3RoaXMuaGEoKTp0aGlzW3JdLmthPSExKTtyZXR1cm4gdGhpc1tyXS5YfTt0aGlzLklhPWZ1bmN0aW9uKGEpe3RoaXMucGModGhpc1tyXS5YKTt0aGlzW3JdLmthPSEwO2EmJih0aGlzW3JdLnNhPSEwKTt0aGlzLnFjKHRoaXMsIWEpfX0sczpmdW5jdGlvbigpe3ZhciBiPXRoaXNbcl07IWIuSiYmYi5JJiZhLmEuUChiLkksZnVuY3Rpb24oYSxiKXtiLnMmJmIucygpfSk7Yi5sJiZiLlJiJiZhLmEuSy55YihiLmwsYi5SYik7Yi5JPW47Yi5WPTA7Yi5yYT0hMDtiLnNhPSExO2Iua2E9ITE7Yi5KPSExO2IubD1uO2IuU2E9bjtiLldjPW47dGhpcy5OY3x8KGIubmI9bil9fSxkYT17UWE6ZnVuY3Rpb24oYil7dmFyIGM9dGhpcyxkPWNbcl07aWYoIWQucmEmJmQuSiYmXCJjaGFuZ2VcIj09Yil7ZC5KPSExO2lmKGQuc2F8fGMuWGEoKSlkLkk9bnVsbCxkLlY9XG4wLGMuaGEoKSYmYy5HYigpO2Vsc2V7dmFyIGU9W107YS5hLlAoZC5JLGZ1bmN0aW9uKGEsYil7ZVtiLkthXT1hfSk7YS5hLkQoZSxmdW5jdGlvbihhLGIpe3ZhciBlPWQuSVthXSxtPWMuJGMoZS5kYSk7bS5LYT1iO20uTGE9ZS5MYTtkLklbYV09bX0pO2MuWGEoKSYmYy5oYSgpJiZjLkdiKCl9ZC5yYXx8Yy5ub3RpZnlTdWJzY3JpYmVycyhkLlgsXCJhd2FrZVwiKX19LGhiOmZ1bmN0aW9uKGIpe3ZhciBjPXRoaXNbcl07Yy5yYXx8XCJjaGFuZ2VcIiE9Ynx8dGhpcy5XYShcImNoYW5nZVwiKXx8KGEuYS5QKGMuSSxmdW5jdGlvbihhLGIpe2IucyYmKGMuSVthXT17ZGE6Yi5kYSxLYTpiLkthLExhOmIuTGF9LGIucygpKX0pLGMuSj0hMCx0aGlzLm5vdGlmeVN1YnNjcmliZXJzKG4sXCJhc2xlZXBcIikpfSxvYjpmdW5jdGlvbigpe3ZhciBiPXRoaXNbcl07Yi5KJiYoYi5zYXx8dGhpcy5YYSgpKSYmdGhpcy5oYSgpO3JldHVybiBhLlQuZm4ub2IuY2FsbCh0aGlzKX19LGVhPXtRYTpmdW5jdGlvbihhKXtcImNoYW5nZVwiIT1cbmEmJlwiYmVmb3JlQ2hhbmdlXCIhPWF8fHRoaXMudigpfX07YS5hLkJhJiZhLmEuc2V0UHJvdG90eXBlT2YoQyxhLlQuZm4pO3ZhciBOPWEudGEuTWE7Q1tOXT1hLm87YS5PYz1mdW5jdGlvbihhKXtyZXR1cm5cImZ1bmN0aW9uXCI9PXR5cGVvZiBhJiZhW05dPT09Q1tOXX07YS5GZD1mdW5jdGlvbihiKXtyZXR1cm4gYS5PYyhiKSYmYltyXSYmYltyXS53Yn07YS5iKFwiY29tcHV0ZWRcIixhLm8pO2EuYihcImRlcGVuZGVudE9ic2VydmFibGVcIixhLm8pO2EuYihcImlzQ29tcHV0ZWRcIixhLk9jKTthLmIoXCJpc1B1cmVDb21wdXRlZFwiLGEuRmQpO2EuYihcImNvbXB1dGVkLmZuXCIsQyk7YS5MKEMsXCJwZWVrXCIsQy52KTthLkwoQyxcImRpc3Bvc2VcIixDLnMpO2EuTChDLFwiaXNBY3RpdmVcIixDLmphKTthLkwoQyxcImdldERlcGVuZGVuY2llc0NvdW50XCIsQy5xYSk7YS5MKEMsXCJnZXREZXBlbmRlbmNpZXNcIixDLlZhKTthLnhiPWZ1bmN0aW9uKGIsYyl7aWYoXCJmdW5jdGlvblwiPT09dHlwZW9mIGIpcmV0dXJuIGEubyhiLFxuYyx7cHVyZTohMH0pO2I9YS5hLmV4dGVuZCh7fSxiKTtiLnB1cmU9ITA7cmV0dXJuIGEubyhiLGMpfTthLmIoXCJwdXJlQ29tcHV0ZWRcIixhLnhiKTsoZnVuY3Rpb24oKXtmdW5jdGlvbiBiKGEsZixnKXtnPWd8fG5ldyBkO2E9ZihhKTtpZihcIm9iamVjdFwiIT10eXBlb2YgYXx8bnVsbD09PWF8fGE9PT1ufHxhIGluc3RhbmNlb2YgUmVnRXhwfHxhIGluc3RhbmNlb2YgRGF0ZXx8YSBpbnN0YW5jZW9mIFN0cmluZ3x8YSBpbnN0YW5jZW9mIE51bWJlcnx8YSBpbnN0YW5jZW9mIEJvb2xlYW4pcmV0dXJuIGE7dmFyIGg9YSBpbnN0YW5jZW9mIEFycmF5P1tdOnt9O2cuc2F2ZShhLGgpO2MoYSxmdW5jdGlvbihjKXt2YXIgZD1mKGFbY10pO3N3aXRjaCh0eXBlb2YgZCl7Y2FzZSBcImJvb2xlYW5cIjpjYXNlIFwibnVtYmVyXCI6Y2FzZSBcInN0cmluZ1wiOmNhc2UgXCJmdW5jdGlvblwiOmhbY109ZDticmVhaztjYXNlIFwib2JqZWN0XCI6Y2FzZSBcInVuZGVmaW5lZFwiOnZhciBsPWcuZ2V0KGQpO2hbY109bCE9PVxubj9sOmIoZCxmLGcpfX0pO3JldHVybiBofWZ1bmN0aW9uIGMoYSxiKXtpZihhIGluc3RhbmNlb2YgQXJyYXkpe2Zvcih2YXIgYz0wO2M8YS5sZW5ndGg7YysrKWIoYyk7XCJmdW5jdGlvblwiPT10eXBlb2YgYS50b0pTT04mJmIoXCJ0b0pTT05cIil9ZWxzZSBmb3IoYyBpbiBhKWIoYyl9ZnVuY3Rpb24gZCgpe3RoaXMua2V5cz1bXTt0aGlzLnZhbHVlcz1bXX1hLmFkPWZ1bmN0aW9uKGMpe2lmKDA9PWFyZ3VtZW50cy5sZW5ndGgpdGhyb3cgRXJyb3IoXCJXaGVuIGNhbGxpbmcga28udG9KUywgcGFzcyB0aGUgb2JqZWN0IHlvdSB3YW50IHRvIGNvbnZlcnQuXCIpO3JldHVybiBiKGMsZnVuY3Rpb24oYil7Zm9yKHZhciBjPTA7YS5PKGIpJiYxMD5jO2MrKyliPWIoKTtyZXR1cm4gYn0pfTthLnRvSlNPTj1mdW5jdGlvbihiLGMsZCl7Yj1hLmFkKGIpO3JldHVybiBhLmEuaGMoYixjLGQpfTtkLnByb3RvdHlwZT17Y29uc3RydWN0b3I6ZCxzYXZlOmZ1bmN0aW9uKGIsYyl7dmFyIGQ9YS5hLkEodGhpcy5rZXlzLFxuYik7MDw9ZD90aGlzLnZhbHVlc1tkXT1jOih0aGlzLmtleXMucHVzaChiKSx0aGlzLnZhbHVlcy5wdXNoKGMpKX0sZ2V0OmZ1bmN0aW9uKGIpe2I9YS5hLkEodGhpcy5rZXlzLGIpO3JldHVybiAwPD1iP3RoaXMudmFsdWVzW2JdOm59fX0pKCk7YS5iKFwidG9KU1wiLGEuYWQpO2EuYihcInRvSlNPTlwiLGEudG9KU09OKTthLldkPWZ1bmN0aW9uKGIsYyxkKXtmdW5jdGlvbiBlKGMpe3ZhciBlPWEueGIoYixkKS5leHRlbmQoe21hOlwiYWx3YXlzXCJ9KSxoPWUuc3Vic2NyaWJlKGZ1bmN0aW9uKGEpe2EmJihoLnMoKSxjKGEpKX0pO2Uubm90aWZ5U3Vic2NyaWJlcnMoZS52KCkpO3JldHVybiBofXJldHVyblwiZnVuY3Rpb25cIiE9PXR5cGVvZiBQcm9taXNlfHxjP2UoYy5iaW5kKGQpKTpuZXcgUHJvbWlzZShlKX07YS5iKFwid2hlblwiLGEuV2QpOyhmdW5jdGlvbigpe2Eudz17TTpmdW5jdGlvbihiKXtzd2l0Y2goYS5hLlIoYikpe2Nhc2UgXCJvcHRpb25cIjpyZXR1cm4hMD09PWIuX19rb19faGFzRG9tRGF0YU9wdGlvblZhbHVlX18/XG5hLmEuZy5nZXQoYixhLmMub3B0aW9ucy4kYik6Nz49YS5hLlc/Yi5nZXRBdHRyaWJ1dGVOb2RlKFwidmFsdWVcIikmJmIuZ2V0QXR0cmlidXRlTm9kZShcInZhbHVlXCIpLnNwZWNpZmllZD9iLnZhbHVlOmIudGV4dDpiLnZhbHVlO2Nhc2UgXCJzZWxlY3RcIjpyZXR1cm4gMDw9Yi5zZWxlY3RlZEluZGV4P2Eudy5NKGIub3B0aW9uc1tiLnNlbGVjdGVkSW5kZXhdKTpuO2RlZmF1bHQ6cmV0dXJuIGIudmFsdWV9fSxjYjpmdW5jdGlvbihiLGMsZCl7c3dpdGNoKGEuYS5SKGIpKXtjYXNlIFwib3B0aW9uXCI6XCJzdHJpbmdcIj09PXR5cGVvZiBjPyhhLmEuZy5zZXQoYixhLmMub3B0aW9ucy4kYixuKSxcIl9fa29fX2hhc0RvbURhdGFPcHRpb25WYWx1ZV9fXCJpbiBiJiZkZWxldGUgYi5fX2tvX19oYXNEb21EYXRhT3B0aW9uVmFsdWVfXyxiLnZhbHVlPWMpOihhLmEuZy5zZXQoYixhLmMub3B0aW9ucy4kYixjKSxiLl9fa29fX2hhc0RvbURhdGFPcHRpb25WYWx1ZV9fPSEwLGIudmFsdWU9XCJudW1iZXJcIj09PVxudHlwZW9mIGM/YzpcIlwiKTticmVhaztjYXNlIFwic2VsZWN0XCI6aWYoXCJcIj09PWN8fG51bGw9PT1jKWM9bjtmb3IodmFyIGU9LTEsZj0wLGc9Yi5vcHRpb25zLmxlbmd0aCxoO2Y8ZzsrK2YpaWYoaD1hLncuTShiLm9wdGlvbnNbZl0pLGg9PWN8fFwiXCI9PT1oJiZjPT09bil7ZT1mO2JyZWFrfWlmKGR8fDA8PWV8fGM9PT1uJiYxPGIuc2l6ZSliLnNlbGVjdGVkSW5kZXg9ZSw2PT09YS5hLlcmJmEuYS5zZXRUaW1lb3V0KGZ1bmN0aW9uKCl7Yi5zZWxlY3RlZEluZGV4PWV9LDApO2JyZWFrO2RlZmF1bHQ6aWYobnVsbD09PWN8fGM9PT1uKWM9XCJcIjtiLnZhbHVlPWN9fX19KSgpO2EuYihcInNlbGVjdEV4dGVuc2lvbnNcIixhLncpO2EuYihcInNlbGVjdEV4dGVuc2lvbnMucmVhZFZhbHVlXCIsYS53Lk0pO2EuYihcInNlbGVjdEV4dGVuc2lvbnMud3JpdGVWYWx1ZVwiLGEudy5jYik7YS5tPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gYihiKXtiPWEuYS5EYihiKTsxMjM9PT1iLmNoYXJDb2RlQXQoMCkmJihiPWIuc2xpY2UoMSxcbi0xKSk7Yis9XCJcXG4sXCI7dmFyIGM9W10sZD1iLm1hdGNoKGUpLHAscT1bXSxoPTA7aWYoMTxkLmxlbmd0aCl7Zm9yKHZhciB4PTAsQjtCPWRbeF07Kyt4KXt2YXIgdT1CLmNoYXJDb2RlQXQoMCk7aWYoNDQ9PT11KXtpZigwPj1oKXtjLnB1c2gocCYmcS5sZW5ndGg/e2tleTpwLHZhbHVlOnEuam9pbihcIlwiKX06e3Vua25vd246cHx8cS5qb2luKFwiXCIpfSk7cD1oPTA7cT1bXTtjb250aW51ZX19ZWxzZSBpZig1OD09PXUpe2lmKCFoJiYhcCYmMT09PXEubGVuZ3RoKXtwPXEucG9wKCk7Y29udGludWV9fWVsc2UgaWYoNDc9PT11JiYxPEIubGVuZ3RoJiYoNDc9PT1CLmNoYXJDb2RlQXQoMSl8fDQyPT09Qi5jaGFyQ29kZUF0KDEpKSljb250aW51ZTtlbHNlIDQ3PT09dSYmeCYmMTxCLmxlbmd0aD8odT1kW3gtMV0ubWF0Y2goZikpJiYhZ1t1WzBdXSYmKGI9Yi5zdWJzdHIoYi5pbmRleE9mKEIpKzEpLGQ9Yi5tYXRjaChlKSx4PS0xLEI9XCIvXCIpOjQwPT09dXx8MTIzPT09dXx8OTE9PT11PysraDpcbjQxPT09dXx8MTI1PT09dXx8OTM9PT11Py0taDpwfHxxLmxlbmd0aHx8MzQhPT11JiYzOSE9PXV8fChCPUIuc2xpY2UoMSwtMSkpO3EucHVzaChCKX1pZigwPGgpdGhyb3cgRXJyb3IoXCJVbmJhbGFuY2VkIHBhcmVudGhlc2VzLCBicmFjZXMsIG9yIGJyYWNrZXRzXCIpO31yZXR1cm4gY312YXIgYz1bXCJ0cnVlXCIsXCJmYWxzZVwiLFwibnVsbFwiLFwidW5kZWZpbmVkXCJdLGQ9L14oPzpbJF9hLXpdWyRcXHddKnwoLispKFxcLlxccypbJF9hLXpdWyRcXHddKnxcXFsuK1xcXSkpJC9pLGU9UmVnRXhwKFwiXFxcIig/OlxcXFxcXFxcLnxbXlxcXCJdKSpcXFwifCcoPzpcXFxcXFxcXC58W14nXSkqJ3xgKD86XFxcXFxcXFwufFteYF0pKmB8L1xcXFwqKD86W14qXXxcXFxcKitbXiovXSkqXFxcXCorL3wvLy4qXFxufC8oPzpcXFxcXFxcXC58W14vXSkrL3cqfFteXFxcXHM6LC9dW14sXFxcIidge30oKS86W1xcXFxdXSpbXlxcXFxzLFxcXCInYHt9KCkvOltcXFxcXV18W15cXFxcc11cIixcImdcIiksZj0vW1xcXSlcIidBLVphLXowLTlfJF0rJC8sZz17XCJpblwiOjEsXCJyZXR1cm5cIjoxLFwidHlwZW9mXCI6MX0sXG5oPXt9O3JldHVybntSYTpbXSx3YTpoLGFjOmIsdmI6ZnVuY3Rpb24oZSxmKXtmdW5jdGlvbiBsKGIsZSl7dmFyIGY7aWYoIXgpe3ZhciBrPWEuZ2V0QmluZGluZ0hhbmRsZXIoYik7aWYoayYmay5wcmVwcm9jZXNzJiYhKGU9ay5wcmVwcm9jZXNzKGUsYixsKSkpcmV0dXJuO2lmKGs9aFtiXSlmPWUsMDw9YS5hLkEoYyxmKT9mPSExOihrPWYubWF0Y2goZCksZj1udWxsPT09az8hMTprWzFdP1wiT2JqZWN0KFwiK2tbMV0rXCIpXCIra1syXTpmKSxrPWY7ayYmcS5wdXNoKFwiJ1wiKyhcInN0cmluZ1wiPT10eXBlb2YgaFtiXT9oW2JdOmIpK1wiJzpmdW5jdGlvbihfeil7XCIrZitcIj1fen1cIil9ZyYmKGU9XCJmdW5jdGlvbigpe3JldHVybiBcIitlK1wiIH1cIik7cC5wdXNoKFwiJ1wiK2IrXCInOlwiK2UpfWY9Znx8e307dmFyIHA9W10scT1bXSxnPWYudmFsdWVBY2Nlc3NvcnMseD1mLmJpbmRpbmdQYXJhbXMsQj1cInN0cmluZ1wiPT09dHlwZW9mIGU/YihlKTplO2EuYS5EKEIsZnVuY3Rpb24oYSl7bChhLmtleXx8YS51bmtub3duLFxuYS52YWx1ZSl9KTtxLmxlbmd0aCYmbChcIl9rb19wcm9wZXJ0eV93cml0ZXJzXCIsXCJ7XCIrcS5qb2luKFwiLFwiKStcIiB9XCIpO3JldHVybiBwLmpvaW4oXCIsXCIpfSxJZDpmdW5jdGlvbihhLGIpe2Zvcih2YXIgYz0wO2M8YS5sZW5ndGg7YysrKWlmKGFbY10ua2V5PT1iKXJldHVybiEwO3JldHVybiExfSxlYjpmdW5jdGlvbihiLGMsZCxlLGYpe2lmKGImJmEuTyhiKSkhYS5aYShiKXx8ZiYmYi52KCk9PT1lfHxiKGUpO2Vsc2UgaWYoKGI9Yy5nZXQoXCJfa29fcHJvcGVydHlfd3JpdGVyc1wiKSkmJmJbZF0pYltkXShlKX19fSgpO2EuYihcImV4cHJlc3Npb25SZXdyaXRpbmdcIixhLm0pO2EuYihcImV4cHJlc3Npb25SZXdyaXRpbmcuYmluZGluZ1Jld3JpdGVWYWxpZGF0b3JzXCIsYS5tLlJhKTthLmIoXCJleHByZXNzaW9uUmV3cml0aW5nLnBhcnNlT2JqZWN0TGl0ZXJhbFwiLGEubS5hYyk7YS5iKFwiZXhwcmVzc2lvblJld3JpdGluZy5wcmVQcm9jZXNzQmluZGluZ3NcIixhLm0udmIpO2EuYihcImV4cHJlc3Npb25SZXdyaXRpbmcuX3R3b1dheUJpbmRpbmdzXCIsXG5hLm0ud2EpO2EuYihcImpzb25FeHByZXNzaW9uUmV3cml0aW5nXCIsYS5tKTthLmIoXCJqc29uRXhwcmVzc2lvblJld3JpdGluZy5pbnNlcnRQcm9wZXJ0eUFjY2Vzc29yc0ludG9Kc29uXCIsYS5tLnZiKTsoZnVuY3Rpb24oKXtmdW5jdGlvbiBiKGEpe3JldHVybiA4PT1hLm5vZGVUeXBlJiZnLnRlc3QoZj9hLnRleHQ6YS5ub2RlVmFsdWUpfWZ1bmN0aW9uIGMoYSl7cmV0dXJuIDg9PWEubm9kZVR5cGUmJmgudGVzdChmP2EudGV4dDphLm5vZGVWYWx1ZSl9ZnVuY3Rpb24gZChkLGUpe2Zvcih2YXIgZj1kLGg9MSxnPVtdO2Y9Zi5uZXh0U2libGluZzspe2lmKGMoZikmJihhLmEuZy5zZXQoZixrLCEwKSxoLS0sMD09PWgpKXJldHVybiBnO2cucHVzaChmKTtiKGYpJiZoKyt9aWYoIWUpdGhyb3cgRXJyb3IoXCJDYW5ub3QgZmluZCBjbG9zaW5nIGNvbW1lbnQgdGFnIHRvIG1hdGNoOiBcIitkLm5vZGVWYWx1ZSk7cmV0dXJuIG51bGx9ZnVuY3Rpb24gZShhLGIpe3ZhciBjPWQoYSxiKTtyZXR1cm4gYz9cbjA8Yy5sZW5ndGg/Y1tjLmxlbmd0aC0xXS5uZXh0U2libGluZzphLm5leHRTaWJsaW5nOm51bGx9dmFyIGY9dyYmXCJcXHgzYyEtLXRlc3QtLVxceDNlXCI9PT13LmNyZWF0ZUNvbW1lbnQoXCJ0ZXN0XCIpLnRleHQsZz1mPy9eXFx4M2MhLS1cXHMqa28oPzpcXHMrKFtcXHNcXFNdKykpP1xccyotLVxceDNlJC86L15cXHMqa28oPzpcXHMrKFtcXHNcXFNdKykpP1xccyokLyxoPWY/L15cXHgzYyEtLVxccypcXC9rb1xccyotLVxceDNlJC86L15cXHMqXFwva29cXHMqJC8sbT17dWw6ITAsb2w6ITB9LGs9XCJfX2tvX21hdGNoZWRFbmRDb21tZW50X19cIjthLmg9e2VhOnt9LGNoaWxkTm9kZXM6ZnVuY3Rpb24oYSl7cmV0dXJuIGIoYSk/ZChhKTphLmNoaWxkTm9kZXN9LEVhOmZ1bmN0aW9uKGMpe2lmKGIoYykpe2M9YS5oLmNoaWxkTm9kZXMoYyk7Zm9yKHZhciBkPTAsZT1jLmxlbmd0aDtkPGU7ZCsrKWEucmVtb3ZlTm9kZShjW2RdKX1lbHNlIGEuYS5UYihjKX0sdmE6ZnVuY3Rpb24oYyxkKXtpZihiKGMpKXthLmguRWEoYyk7Zm9yKHZhciBlPVxuYy5uZXh0U2libGluZyxmPTAsaz1kLmxlbmd0aDtmPGs7ZisrKWUucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUoZFtmXSxlKX1lbHNlIGEuYS52YShjLGQpfSxWYzpmdW5jdGlvbihhLGMpe3ZhciBkO2IoYSk/KGQ9YS5uZXh0U2libGluZyxhPWEucGFyZW50Tm9kZSk6ZD1hLmZpcnN0Q2hpbGQ7ZD9jIT09ZCYmYS5pbnNlcnRCZWZvcmUoYyxkKTphLmFwcGVuZENoaWxkKGMpfSxXYjpmdW5jdGlvbihjLGQsZSl7ZT8oZT1lLm5leHRTaWJsaW5nLGIoYykmJihjPWMucGFyZW50Tm9kZSksZT9kIT09ZSYmYy5pbnNlcnRCZWZvcmUoZCxlKTpjLmFwcGVuZENoaWxkKGQpKTphLmguVmMoYyxkKX0sZmlyc3RDaGlsZDpmdW5jdGlvbihhKXtpZihiKGEpKXJldHVybiFhLm5leHRTaWJsaW5nfHxjKGEubmV4dFNpYmxpbmcpP251bGw6YS5uZXh0U2libGluZztpZihhLmZpcnN0Q2hpbGQmJmMoYS5maXJzdENoaWxkKSl0aHJvdyBFcnJvcihcIkZvdW5kIGludmFsaWQgZW5kIGNvbW1lbnQsIGFzIHRoZSBmaXJzdCBjaGlsZCBvZiBcIitcbmEpO3JldHVybiBhLmZpcnN0Q2hpbGR9LG5leHRTaWJsaW5nOmZ1bmN0aW9uKGQpe2IoZCkmJihkPWUoZCkpO2lmKGQubmV4dFNpYmxpbmcmJmMoZC5uZXh0U2libGluZykpe3ZhciBmPWQubmV4dFNpYmxpbmc7aWYoYyhmKSYmIWEuYS5nLmdldChmLGspKXRocm93IEVycm9yKFwiRm91bmQgZW5kIGNvbW1lbnQgd2l0aG91dCBhIG1hdGNoaW5nIG9wZW5pbmcgY29tbWVudCwgYXMgY2hpbGQgb2YgXCIrZCk7cmV0dXJuIG51bGx9cmV0dXJuIGQubmV4dFNpYmxpbmd9LENkOmIsVmQ6ZnVuY3Rpb24oYSl7cmV0dXJuKGE9KGY/YS50ZXh0OmEubm9kZVZhbHVlKS5tYXRjaChnKSk/YVsxXTpudWxsfSxTYzpmdW5jdGlvbihkKXtpZihtW2EuYS5SKGQpXSl7dmFyIGY9ZC5maXJzdENoaWxkO2lmKGYpe2RvIGlmKDE9PT1mLm5vZGVUeXBlKXt2YXIgaztrPWYuZmlyc3RDaGlsZDt2YXIgaD1udWxsO2lmKGspe2RvIGlmKGgpaC5wdXNoKGspO2Vsc2UgaWYoYihrKSl7dmFyIGc9ZShrLCEwKTtnP2s9XG5nOmg9W2tdfWVsc2UgYyhrKSYmKGg9W2tdKTt3aGlsZShrPWsubmV4dFNpYmxpbmcpfWlmKGs9aClmb3IoaD1mLm5leHRTaWJsaW5nLGc9MDtnPGsubGVuZ3RoO2crKyloP2QuaW5zZXJ0QmVmb3JlKGtbZ10saCk6ZC5hcHBlbmRDaGlsZChrW2ddKX13aGlsZShmPWYubmV4dFNpYmxpbmcpfX19fX0pKCk7YS5iKFwidmlydHVhbEVsZW1lbnRzXCIsYS5oKTthLmIoXCJ2aXJ0dWFsRWxlbWVudHMuYWxsb3dlZEJpbmRpbmdzXCIsYS5oLmVhKTthLmIoXCJ2aXJ0dWFsRWxlbWVudHMuZW1wdHlOb2RlXCIsYS5oLkVhKTthLmIoXCJ2aXJ0dWFsRWxlbWVudHMuaW5zZXJ0QWZ0ZXJcIixhLmguV2IpO2EuYihcInZpcnR1YWxFbGVtZW50cy5wcmVwZW5kXCIsYS5oLlZjKTthLmIoXCJ2aXJ0dWFsRWxlbWVudHMuc2V0RG9tTm9kZUNoaWxkcmVuXCIsYS5oLnZhKTsoZnVuY3Rpb24oKXthLmdhPWZ1bmN0aW9uKCl7dGhpcy5uZD17fX07YS5hLmV4dGVuZChhLmdhLnByb3RvdHlwZSx7bm9kZUhhc0JpbmRpbmdzOmZ1bmN0aW9uKGIpe3N3aXRjaChiLm5vZGVUeXBlKXtjYXNlIDE6cmV0dXJuIG51bGwhPVxuYi5nZXRBdHRyaWJ1dGUoXCJkYXRhLWJpbmRcIil8fGEuai5nZXRDb21wb25lbnROYW1lRm9yTm9kZShiKTtjYXNlIDg6cmV0dXJuIGEuaC5DZChiKTtkZWZhdWx0OnJldHVybiExfX0sZ2V0QmluZGluZ3M6ZnVuY3Rpb24oYixjKXt2YXIgZD10aGlzLmdldEJpbmRpbmdzU3RyaW5nKGIsYyksZD1kP3RoaXMucGFyc2VCaW5kaW5nc1N0cmluZyhkLGMsYik6bnVsbDtyZXR1cm4gYS5qLnRjKGQsYixjLCExKX0sZ2V0QmluZGluZ0FjY2Vzc29yczpmdW5jdGlvbihiLGMpe3ZhciBkPXRoaXMuZ2V0QmluZGluZ3NTdHJpbmcoYixjKSxkPWQ/dGhpcy5wYXJzZUJpbmRpbmdzU3RyaW5nKGQsYyxiLHt2YWx1ZUFjY2Vzc29yczohMH0pOm51bGw7cmV0dXJuIGEuai50YyhkLGIsYywhMCl9LGdldEJpbmRpbmdzU3RyaW5nOmZ1bmN0aW9uKGIpe3N3aXRjaChiLm5vZGVUeXBlKXtjYXNlIDE6cmV0dXJuIGIuZ2V0QXR0cmlidXRlKFwiZGF0YS1iaW5kXCIpO2Nhc2UgODpyZXR1cm4gYS5oLlZkKGIpO2RlZmF1bHQ6cmV0dXJuIG51bGx9fSxcbnBhcnNlQmluZGluZ3NTdHJpbmc6ZnVuY3Rpb24oYixjLGQsZSl7dHJ5e3ZhciBmPXRoaXMubmQsZz1iKyhlJiZlLnZhbHVlQWNjZXNzb3JzfHxcIlwiKSxoO2lmKCEoaD1mW2ddKSl7dmFyIG0saz1cIndpdGgoJGNvbnRleHQpe3dpdGgoJGRhdGF8fHt9KXtyZXR1cm57XCIrYS5tLnZiKGIsZSkrXCJ9fX1cIjttPW5ldyBGdW5jdGlvbihcIiRjb250ZXh0XCIsXCIkZWxlbWVudFwiLGspO2g9ZltnXT1tfXJldHVybiBoKGMsZCl9Y2F0Y2gobCl7dGhyb3cgbC5tZXNzYWdlPVwiVW5hYmxlIHRvIHBhcnNlIGJpbmRpbmdzLlxcbkJpbmRpbmdzIHZhbHVlOiBcIitiK1wiXFxuTWVzc2FnZTogXCIrbC5tZXNzYWdlLGw7fX19KTthLmdhLmluc3RhbmNlPW5ldyBhLmdhfSkoKTthLmIoXCJiaW5kaW5nUHJvdmlkZXJcIixhLmdhKTsoZnVuY3Rpb24oKXtmdW5jdGlvbiBiKGIpe3ZhciBjPShiPWEuYS5nLmdldChiLHopKSYmYi5OO2MmJihiLk49bnVsbCxjLlRjKCkpfWZ1bmN0aW9uIGMoYyxkLGUpe3RoaXMubm9kZT1jO3RoaXMueWM9XG5kO3RoaXMua2I9W107dGhpcy5IPSExO2QuTnx8YS5hLksuemEoYyxiKTtlJiZlLk4mJihlLk4ua2IucHVzaChjKSx0aGlzLktiPWUpfWZ1bmN0aW9uIGQoYSl7cmV0dXJuIGZ1bmN0aW9uKCl7cmV0dXJuIGF9fWZ1bmN0aW9uIGUoYSl7cmV0dXJuIGEoKX1mdW5jdGlvbiBmKGIpe3JldHVybiBhLmEuR2EoYS51LkcoYiksZnVuY3Rpb24oYSxjKXtyZXR1cm4gZnVuY3Rpb24oKXtyZXR1cm4gYigpW2NdfX0pfWZ1bmN0aW9uIGcoYixjLGUpe3JldHVyblwiZnVuY3Rpb25cIj09PXR5cGVvZiBiP2YoYi5iaW5kKG51bGwsYyxlKSk6YS5hLkdhKGIsZCl9ZnVuY3Rpb24gaChhLGIpe3JldHVybiBmKHRoaXMuZ2V0QmluZGluZ3MuYmluZCh0aGlzLGEsYikpfWZ1bmN0aW9uIG0oYixjKXt2YXIgZD1hLmguZmlyc3RDaGlsZChjKTtpZihkKXt2YXIgZSxmPWEuZ2EuaW5zdGFuY2UsbD1mLnByZXByb2Nlc3NOb2RlO2lmKGwpe2Zvcig7ZT1kOylkPWEuaC5uZXh0U2libGluZyhlKSxsLmNhbGwoZixlKTtcbmQ9YS5oLmZpcnN0Q2hpbGQoYyl9Zm9yKDtlPWQ7KWQ9YS5oLm5leHRTaWJsaW5nKGUpLGsoYixlKX1hLmkubWEoYyxhLmkuSCl9ZnVuY3Rpb24gayhiLGMpe3ZhciBkPWIsZT0xPT09Yy5ub2RlVHlwZTtlJiZhLmguU2MoYyk7aWYoZXx8YS5nYS5pbnN0YW5jZS5ub2RlSGFzQmluZGluZ3MoYykpZD1wKGMsbnVsbCxiKS5iaW5kaW5nQ29udGV4dEZvckRlc2NlbmRhbnRzO2QmJiF1W2EuYS5SKGMpXSYmbShkLGMpfWZ1bmN0aW9uIGwoYil7dmFyIGM9W10sZD17fSxlPVtdO2EuYS5QKGIsZnVuY3Rpb24gY2EoZil7aWYoIWRbZl0pe3ZhciBrPWEuZ2V0QmluZGluZ0hhbmRsZXIoZik7ayYmKGsuYWZ0ZXImJihlLnB1c2goZiksYS5hLkQoay5hZnRlcixmdW5jdGlvbihjKXtpZihiW2NdKXtpZigtMSE9PWEuYS5BKGUsYykpdGhyb3cgRXJyb3IoXCJDYW5ub3QgY29tYmluZSB0aGUgZm9sbG93aW5nIGJpbmRpbmdzLCBiZWNhdXNlIHRoZXkgaGF2ZSBhIGN5Y2xpYyBkZXBlbmRlbmN5OiBcIitlLmpvaW4oXCIsIFwiKSk7XG5jYShjKX19KSxlLmxlbmd0aC0tKSxjLnB1c2goe2tleTpmLE1jOmt9KSk7ZFtmXT0hMH19KTtyZXR1cm4gY31mdW5jdGlvbiBwKGIsYyxkKXt2YXIgZj1hLmEuZy5VYihiLHose30pLGs9Zi5oZDtpZighYyl7aWYoayl0aHJvdyBFcnJvcihcIllvdSBjYW5ub3QgYXBwbHkgYmluZGluZ3MgbXVsdGlwbGUgdGltZXMgdG8gdGhlIHNhbWUgZWxlbWVudC5cIik7Zi5oZD0hMH1rfHwoZi5jb250ZXh0PWQpO2YuWmJ8fChmLlpiPXt9KTt2YXIgZztpZihjJiZcImZ1bmN0aW9uXCIhPT10eXBlb2YgYylnPWM7ZWxzZXt2YXIgcD1hLmdhLmluc3RhbmNlLHE9cC5nZXRCaW5kaW5nQWNjZXNzb3JzfHxoLG09YS4kKGZ1bmN0aW9uKCl7aWYoZz1jP2MoZCxiKTpxLmNhbGwocCxiLGQpKXtpZihkW3RdKWRbdF0oKTtpZihkW0JdKWRbQl0oKX1yZXR1cm4gZ30sbnVsbCx7bDpifSk7ZyYmbS5qYSgpfHwobT1udWxsKX12YXIgeD1kLHU7aWYoZyl7dmFyIEo9ZnVuY3Rpb24oKXtyZXR1cm4gYS5hLkdhKG0/bSgpOlxuZyxlKX0scj1tP2Z1bmN0aW9uKGEpe3JldHVybiBmdW5jdGlvbigpe3JldHVybiBlKG0oKVthXSl9fTpmdW5jdGlvbihhKXtyZXR1cm4gZ1thXX07Si5nZXQ9ZnVuY3Rpb24oYSl7cmV0dXJuIGdbYV0mJmUocihhKSl9O0ouaGFzPWZ1bmN0aW9uKGEpe3JldHVybiBhIGluIGd9O2EuaS5IIGluIGcmJmEuaS5zdWJzY3JpYmUoYixhLmkuSCxmdW5jdGlvbigpe3ZhciBjPSgwLGdbYS5pLkhdKSgpO2lmKGMpe3ZhciBkPWEuaC5jaGlsZE5vZGVzKGIpO2QubGVuZ3RoJiZjKGQsYS5FYyhkWzBdKSl9fSk7YS5pLnBhIGluIGcmJih4PWEuaS5DYihiLGQpLGEuaS5zdWJzY3JpYmUoYixhLmkucGEsZnVuY3Rpb24oKXt2YXIgYz0oMCxnW2EuaS5wYV0pKCk7YyYmYS5oLmZpcnN0Q2hpbGQoYikmJmMoYil9KSk7Zj1sKGcpO2EuYS5EKGYsZnVuY3Rpb24oYyl7dmFyIGQ9Yy5NYy5pbml0LGU9Yy5NYy51cGRhdGUsZj1jLmtleTtpZig4PT09Yi5ub2RlVHlwZSYmIWEuaC5lYVtmXSl0aHJvdyBFcnJvcihcIlRoZSBiaW5kaW5nICdcIitcbmYrXCInIGNhbm5vdCBiZSB1c2VkIHdpdGggdmlydHVhbCBlbGVtZW50c1wiKTt0cnl7XCJmdW5jdGlvblwiPT10eXBlb2YgZCYmYS51LkcoZnVuY3Rpb24oKXt2YXIgYT1kKGIscihmKSxKLHguJGRhdGEseCk7aWYoYSYmYS5jb250cm9sc0Rlc2NlbmRhbnRCaW5kaW5ncyl7aWYodSE9PW4pdGhyb3cgRXJyb3IoXCJNdWx0aXBsZSBiaW5kaW5ncyAoXCIrdStcIiBhbmQgXCIrZitcIikgYXJlIHRyeWluZyB0byBjb250cm9sIGRlc2NlbmRhbnQgYmluZGluZ3Mgb2YgdGhlIHNhbWUgZWxlbWVudC4gWW91IGNhbm5vdCB1c2UgdGhlc2UgYmluZGluZ3MgdG9nZXRoZXIgb24gdGhlIHNhbWUgZWxlbWVudC5cIik7dT1mfX0pLFwiZnVuY3Rpb25cIj09dHlwZW9mIGUmJmEuJChmdW5jdGlvbigpe2UoYixyKGYpLEoseC4kZGF0YSx4KX0sbnVsbCx7bDpifSl9Y2F0Y2goayl7dGhyb3cgay5tZXNzYWdlPSdVbmFibGUgdG8gcHJvY2VzcyBiaW5kaW5nIFwiJytmK1wiOiBcIitnW2ZdKydcIlxcbk1lc3NhZ2U6ICcray5tZXNzYWdlLFxuazt9fSl9Zj11PT09bjtyZXR1cm57c2hvdWxkQmluZERlc2NlbmRhbnRzOmYsYmluZGluZ0NvbnRleHRGb3JEZXNjZW5kYW50czpmJiZ4fX1mdW5jdGlvbiBxKGIsYyl7cmV0dXJuIGImJmIgaW5zdGFuY2VvZiBhLmZhP2I6bmV3IGEuZmEoYixuLG4sYyl9dmFyIHQ9YS5hLkRhKFwiX3N1YnNjcmliYWJsZVwiKSx4PWEuYS5EYShcIl9hbmNlc3RvckJpbmRpbmdJbmZvXCIpLEI9YS5hLkRhKFwiX2RhdGFEZXBlbmRlbmN5XCIpO2EuYz17fTt2YXIgdT17c2NyaXB0OiEwLHRleHRhcmVhOiEwLHRlbXBsYXRlOiEwfTthLmdldEJpbmRpbmdIYW5kbGVyPWZ1bmN0aW9uKGIpe3JldHVybiBhLmNbYl19O3ZhciBKPXt9O2EuZmE9ZnVuY3Rpb24oYixjLGQsZSxmKXtmdW5jdGlvbiBrKCl7dmFyIGI9cD9oKCk6aCxmPWEuYS5mKGIpO2M/KGEuYS5leHRlbmQobCxjKSx4IGluIGMmJihsW3hdPWNbeF0pKToobC4kcGFyZW50cz1bXSxsLiRyb290PWYsbC5rbz1hKTtsW3RdPXE7Zz9mPWwuJGRhdGE6KGwuJHJhd0RhdGE9XG5iLGwuJGRhdGE9Zik7ZCYmKGxbZF09Zik7ZSYmZShsLGMsZik7aWYoYyYmY1t0XSYmIWEuUy5vKCkuVmIoY1t0XSkpY1t0XSgpO20mJihsW0JdPW0pO3JldHVybiBsLiRkYXRhfXZhciBsPXRoaXMsZz1iPT09SixoPWc/bjpiLHA9XCJmdW5jdGlvblwiPT10eXBlb2YgaCYmIWEuTyhoKSxxLG09ZiYmZi5kYXRhRGVwZW5kZW5jeTtmJiZmLmV4cG9ydERlcGVuZGVuY2llcz9rKCk6KHE9YS54YihrKSxxLnYoKSxxLmphKCk/cS5lcXVhbGl0eUNvbXBhcmVyPW51bGw6bFt0XT1uKX07YS5mYS5wcm90b3R5cGUuY3JlYXRlQ2hpbGRDb250ZXh0PWZ1bmN0aW9uKGIsYyxkLGUpeyFlJiZjJiZcIm9iamVjdFwiPT10eXBlb2YgYyYmKGU9YyxjPWUuYXMsZD1lLmV4dGVuZCk7aWYoYyYmZSYmZS5ub0NoaWxkQ29udGV4dCl7dmFyIGY9XCJmdW5jdGlvblwiPT10eXBlb2YgYiYmIWEuTyhiKTtyZXR1cm4gbmV3IGEuZmEoSix0aGlzLG51bGwsZnVuY3Rpb24oYSl7ZCYmZChhKTthW2NdPWY/YigpOmJ9LGUpfXJldHVybiBuZXcgYS5mYShiLFxudGhpcyxjLGZ1bmN0aW9uKGEsYil7YS4kcGFyZW50Q29udGV4dD1iO2EuJHBhcmVudD1iLiRkYXRhO2EuJHBhcmVudHM9KGIuJHBhcmVudHN8fFtdKS5zbGljZSgwKTthLiRwYXJlbnRzLnVuc2hpZnQoYS4kcGFyZW50KTtkJiZkKGEpfSxlKX07YS5mYS5wcm90b3R5cGUuZXh0ZW5kPWZ1bmN0aW9uKGIsYyl7cmV0dXJuIG5ldyBhLmZhKEosdGhpcyxudWxsLGZ1bmN0aW9uKGMpe2EuYS5leHRlbmQoYyxcImZ1bmN0aW9uXCI9PXR5cGVvZiBiP2IoYyk6Yil9LGMpfTt2YXIgej1hLmEuZy5aKCk7Yy5wcm90b3R5cGUuVGM9ZnVuY3Rpb24oKXt0aGlzLktiJiZ0aGlzLktiLk4mJnRoaXMuS2IuTi5zZCh0aGlzLm5vZGUpfTtjLnByb3RvdHlwZS5zZD1mdW5jdGlvbihiKXthLmEuUGEodGhpcy5rYixiKTshdGhpcy5rYi5sZW5ndGgmJnRoaXMuSCYmdGhpcy5DYygpfTtjLnByb3RvdHlwZS5DYz1mdW5jdGlvbigpe3RoaXMuSD0hMDt0aGlzLnljLk4mJiF0aGlzLmtiLmxlbmd0aCYmKHRoaXMueWMuTj1cbm51bGwsYS5hLksueWIodGhpcy5ub2RlLGIpLGEuaS5tYSh0aGlzLm5vZGUsYS5pLnBhKSx0aGlzLlRjKCkpfTthLmk9e0g6XCJjaGlsZHJlbkNvbXBsZXRlXCIscGE6XCJkZXNjZW5kYW50c0NvbXBsZXRlXCIsc3Vic2NyaWJlOmZ1bmN0aW9uKGIsYyxkLGUsZil7dmFyIGs9YS5hLmcuVWIoYix6LHt9KTtrLkZhfHwoay5GYT1uZXcgYS5UKTtmJiZmLm5vdGlmeUltbWVkaWF0ZWx5JiZrLlpiW2NdJiZhLnUuRyhkLGUsW2JdKTtyZXR1cm4gay5GYS5zdWJzY3JpYmUoZCxlLGMpfSxtYTpmdW5jdGlvbihiLGMpe3ZhciBkPWEuYS5nLmdldChiLHopO2lmKGQmJihkLlpiW2NdPSEwLGQuRmEmJmQuRmEubm90aWZ5U3Vic2NyaWJlcnMoYixjKSxjPT1hLmkuSCkpaWYoZC5OKWQuTi5DYygpO2Vsc2UgaWYoZC5OPT09biYmZC5GYSYmZC5GYS5XYShhLmkucGEpKXRocm93IEVycm9yKFwiZGVzY2VuZGFudHNDb21wbGV0ZSBldmVudCBub3Qgc3VwcG9ydGVkIGZvciBiaW5kaW5ncyBvbiB0aGlzIG5vZGVcIik7XG59LENiOmZ1bmN0aW9uKGIsZCl7dmFyIGU9YS5hLmcuVWIoYix6LHt9KTtlLk58fChlLk49bmV3IGMoYixlLGRbeF0pKTtyZXR1cm4gZFt4XT09ZT9kOmQuZXh0ZW5kKGZ1bmN0aW9uKGEpe2FbeF09ZX0pfX07YS5UZD1mdW5jdGlvbihiKXtyZXR1cm4oYj1hLmEuZy5nZXQoYix6KSkmJmIuY29udGV4dH07YS5pYj1mdW5jdGlvbihiLGMsZCl7MT09PWIubm9kZVR5cGUmJmEuaC5TYyhiKTtyZXR1cm4gcChiLGMscShkKSl9O2EubGQ9ZnVuY3Rpb24oYixjLGQpe2Q9cShkKTtyZXR1cm4gYS5pYihiLGcoYyxkLGIpLGQpfTthLk9hPWZ1bmN0aW9uKGEsYil7MSE9PWIubm9kZVR5cGUmJjghPT1iLm5vZGVUeXBlfHxtKHEoYSksYil9O2EudmM9ZnVuY3Rpb24oYSxiLGMpeyF2JiZBLmpRdWVyeSYmKHY9QS5qUXVlcnkpO2lmKDI+YXJndW1lbnRzLmxlbmd0aCl7aWYoYj13LmJvZHksIWIpdGhyb3cgRXJyb3IoXCJrby5hcHBseUJpbmRpbmdzOiBjb3VsZCBub3QgZmluZCBkb2N1bWVudC5ib2R5OyBoYXMgdGhlIGRvY3VtZW50IGJlZW4gbG9hZGVkP1wiKTtcbn1lbHNlIGlmKCFifHwxIT09Yi5ub2RlVHlwZSYmOCE9PWIubm9kZVR5cGUpdGhyb3cgRXJyb3IoXCJrby5hcHBseUJpbmRpbmdzOiBmaXJzdCBwYXJhbWV0ZXIgc2hvdWxkIGJlIHlvdXIgdmlldyBtb2RlbDsgc2Vjb25kIHBhcmFtZXRlciBzaG91bGQgYmUgYSBET00gbm9kZVwiKTtrKHEoYSxjKSxiKX07YS5EYz1mdW5jdGlvbihiKXtyZXR1cm4hYnx8MSE9PWIubm9kZVR5cGUmJjghPT1iLm5vZGVUeXBlP246YS5UZChiKX07YS5FYz1mdW5jdGlvbihiKXtyZXR1cm4oYj1hLkRjKGIpKT9iLiRkYXRhOm59O2EuYihcImJpbmRpbmdIYW5kbGVyc1wiLGEuYyk7YS5iKFwiYmluZGluZ0V2ZW50XCIsYS5pKTthLmIoXCJiaW5kaW5nRXZlbnQuc3Vic2NyaWJlXCIsYS5pLnN1YnNjcmliZSk7YS5iKFwiYmluZGluZ0V2ZW50LnN0YXJ0UG9zc2libHlBc3luY0NvbnRlbnRCaW5kaW5nXCIsYS5pLkNiKTthLmIoXCJhcHBseUJpbmRpbmdzXCIsYS52Yyk7YS5iKFwiYXBwbHlCaW5kaW5nc1RvRGVzY2VuZGFudHNcIixhLk9hKTtcbmEuYihcImFwcGx5QmluZGluZ0FjY2Vzc29yc1RvTm9kZVwiLGEuaWIpO2EuYihcImFwcGx5QmluZGluZ3NUb05vZGVcIixhLmxkKTthLmIoXCJjb250ZXh0Rm9yXCIsYS5EYyk7YS5iKFwiZGF0YUZvclwiLGEuRWMpfSkoKTsoZnVuY3Rpb24oYil7ZnVuY3Rpb24gYyhjLGUpe3ZhciBrPU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChmLGMpP2ZbY106YixsO2s/ay5zdWJzY3JpYmUoZSk6KGs9ZltjXT1uZXcgYS5ULGsuc3Vic2NyaWJlKGUpLGQoYyxmdW5jdGlvbihiLGQpe3ZhciBlPSEoIWR8fCFkLnN5bmNocm9ub3VzKTtnW2NdPXtkZWZpbml0aW9uOmIsR2Q6ZX07ZGVsZXRlIGZbY107bHx8ZT9rLm5vdGlmeVN1YnNjcmliZXJzKGIpOmEubmEuemIoZnVuY3Rpb24oKXtrLm5vdGlmeVN1YnNjcmliZXJzKGIpfSl9KSxsPSEwKX1mdW5jdGlvbiBkKGEsYil7ZShcImdldENvbmZpZ1wiLFthXSxmdW5jdGlvbihjKXtjP2UoXCJsb2FkQ29tcG9uZW50XCIsW2EsY10sZnVuY3Rpb24oYSl7YihhLFxuYyl9KTpiKG51bGwsbnVsbCl9KX1mdW5jdGlvbiBlKGMsZCxmLGwpe2x8fChsPWEuai5sb2FkZXJzLnNsaWNlKDApKTt2YXIgZz1sLnNoaWZ0KCk7aWYoZyl7dmFyIHE9Z1tjXTtpZihxKXt2YXIgdD0hMTtpZihxLmFwcGx5KGcsZC5jb25jYXQoZnVuY3Rpb24oYSl7dD9mKG51bGwpOm51bGwhPT1hP2YoYSk6ZShjLGQsZixsKX0pKSE9PWImJih0PSEwLCFnLnN1cHByZXNzTG9hZGVyRXhjZXB0aW9ucykpdGhyb3cgRXJyb3IoXCJDb21wb25lbnQgbG9hZGVycyBtdXN0IHN1cHBseSB2YWx1ZXMgYnkgaW52b2tpbmcgdGhlIGNhbGxiYWNrLCBub3QgYnkgcmV0dXJuaW5nIHZhbHVlcyBzeW5jaHJvbm91c2x5LlwiKTt9ZWxzZSBlKGMsZCxmLGwpfWVsc2UgZihudWxsKX12YXIgZj17fSxnPXt9O2Euaj17Z2V0OmZ1bmN0aW9uKGQsZSl7dmFyIGY9T2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGcsZCk/Z1tkXTpiO2Y/Zi5HZD9hLnUuRyhmdW5jdGlvbigpe2UoZi5kZWZpbml0aW9uKX0pOlxuYS5uYS56YihmdW5jdGlvbigpe2UoZi5kZWZpbml0aW9uKX0pOmMoZCxlKX0sQmM6ZnVuY3Rpb24oYSl7ZGVsZXRlIGdbYV19LG9jOmV9O2Euai5sb2FkZXJzPVtdO2EuYihcImNvbXBvbmVudHNcIixhLmopO2EuYihcImNvbXBvbmVudHMuZ2V0XCIsYS5qLmdldCk7YS5iKFwiY29tcG9uZW50cy5jbGVhckNhY2hlZERlZmluaXRpb25cIixhLmouQmMpfSkoKTsoZnVuY3Rpb24oKXtmdW5jdGlvbiBiKGIsYyxkLGUpe2Z1bmN0aW9uIGcoKXswPT09LS1CJiZlKGgpfXZhciBoPXt9LEI9Mix1PWQudGVtcGxhdGU7ZD1kLnZpZXdNb2RlbDt1P2YoYyx1LGZ1bmN0aW9uKGMpe2Euai5vYyhcImxvYWRUZW1wbGF0ZVwiLFtiLGNdLGZ1bmN0aW9uKGEpe2gudGVtcGxhdGU9YTtnKCl9KX0pOmcoKTtkP2YoYyxkLGZ1bmN0aW9uKGMpe2Euai5vYyhcImxvYWRWaWV3TW9kZWxcIixbYixjXSxmdW5jdGlvbihhKXtoW21dPWE7ZygpfSl9KTpnKCl9ZnVuY3Rpb24gYyhhLGIsZCl7aWYoXCJmdW5jdGlvblwiPT09dHlwZW9mIGIpZChmdW5jdGlvbihhKXtyZXR1cm4gbmV3IGIoYSl9KTtcbmVsc2UgaWYoXCJmdW5jdGlvblwiPT09dHlwZW9mIGJbbV0pZChiW21dKTtlbHNlIGlmKFwiaW5zdGFuY2VcImluIGIpe3ZhciBlPWIuaW5zdGFuY2U7ZChmdW5jdGlvbigpe3JldHVybiBlfSl9ZWxzZVwidmlld01vZGVsXCJpbiBiP2MoYSxiLnZpZXdNb2RlbCxkKTphKFwiVW5rbm93biB2aWV3TW9kZWwgdmFsdWU6IFwiK2IpfWZ1bmN0aW9uIGQoYil7c3dpdGNoKGEuYS5SKGIpKXtjYXNlIFwic2NyaXB0XCI6cmV0dXJuIGEuYS51YShiLnRleHQpO2Nhc2UgXCJ0ZXh0YXJlYVwiOnJldHVybiBhLmEudWEoYi52YWx1ZSk7Y2FzZSBcInRlbXBsYXRlXCI6aWYoZShiLmNvbnRlbnQpKXJldHVybiBhLmEuQ2EoYi5jb250ZW50LmNoaWxkTm9kZXMpfXJldHVybiBhLmEuQ2EoYi5jaGlsZE5vZGVzKX1mdW5jdGlvbiBlKGEpe3JldHVybiBBLkRvY3VtZW50RnJhZ21lbnQ/YSBpbnN0YW5jZW9mIERvY3VtZW50RnJhZ21lbnQ6YSYmMTE9PT1hLm5vZGVUeXBlfWZ1bmN0aW9uIGYoYSxiLGMpe1wic3RyaW5nXCI9PT10eXBlb2YgYi5yZXF1aXJlP1xuVHx8QS5yZXF1aXJlPyhUfHxBLnJlcXVpcmUpKFtiLnJlcXVpcmVdLGZ1bmN0aW9uKGEpe2EmJlwib2JqZWN0XCI9PT10eXBlb2YgYSYmYS5YZCYmYVtcImRlZmF1bHRcIl0mJihhPWFbXCJkZWZhdWx0XCJdKTtjKGEpfSk6YShcIlVzZXMgcmVxdWlyZSwgYnV0IG5vIEFNRCBsb2FkZXIgaXMgcHJlc2VudFwiKTpjKGIpfWZ1bmN0aW9uIGcoYSl7cmV0dXJuIGZ1bmN0aW9uKGIpe3Rocm93IEVycm9yKFwiQ29tcG9uZW50ICdcIithK1wiJzogXCIrYik7fX12YXIgaD17fTthLmoucmVnaXN0ZXI9ZnVuY3Rpb24oYixjKXtpZighYyl0aHJvdyBFcnJvcihcIkludmFsaWQgY29uZmlndXJhdGlvbiBmb3IgXCIrYik7aWYoYS5qLnRiKGIpKXRocm93IEVycm9yKFwiQ29tcG9uZW50IFwiK2IrXCIgaXMgYWxyZWFkeSByZWdpc3RlcmVkXCIpO2hbYl09Y307YS5qLnRiPWZ1bmN0aW9uKGEpe3JldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoaCxhKX07YS5qLnVucmVnaXN0ZXI9ZnVuY3Rpb24oYil7ZGVsZXRlIGhbYl07XG5hLmouQmMoYil9O2Euai5GYz17Z2V0Q29uZmlnOmZ1bmN0aW9uKGIsYyl7YyhhLmoudGIoYik/aFtiXTpudWxsKX0sbG9hZENvbXBvbmVudDpmdW5jdGlvbihhLGMsZCl7dmFyIGU9ZyhhKTtmKGUsYyxmdW5jdGlvbihjKXtiKGEsZSxjLGQpfSl9LGxvYWRUZW1wbGF0ZTpmdW5jdGlvbihiLGMsZil7Yj1nKGIpO2lmKFwic3RyaW5nXCI9PT10eXBlb2YgYylmKGEuYS51YShjKSk7ZWxzZSBpZihjIGluc3RhbmNlb2YgQXJyYXkpZihjKTtlbHNlIGlmKGUoYykpZihhLmEubGEoYy5jaGlsZE5vZGVzKSk7ZWxzZSBpZihjLmVsZW1lbnQpaWYoYz1jLmVsZW1lbnQsQS5IVE1MRWxlbWVudD9jIGluc3RhbmNlb2YgSFRNTEVsZW1lbnQ6YyYmYy50YWdOYW1lJiYxPT09Yy5ub2RlVHlwZSlmKGQoYykpO2Vsc2UgaWYoXCJzdHJpbmdcIj09PXR5cGVvZiBjKXt2YXIgaD13LmdldEVsZW1lbnRCeUlkKGMpO2g/ZihkKGgpKTpiKFwiQ2Fubm90IGZpbmQgZWxlbWVudCB3aXRoIElEIFwiK2MpfWVsc2UgYihcIlVua25vd24gZWxlbWVudCB0eXBlOiBcIitcbmMpO2Vsc2UgYihcIlVua25vd24gdGVtcGxhdGUgdmFsdWU6IFwiK2MpfSxsb2FkVmlld01vZGVsOmZ1bmN0aW9uKGEsYixkKXtjKGcoYSksYixkKX19O3ZhciBtPVwiY3JlYXRlVmlld01vZGVsXCI7YS5iKFwiY29tcG9uZW50cy5yZWdpc3RlclwiLGEuai5yZWdpc3Rlcik7YS5iKFwiY29tcG9uZW50cy5pc1JlZ2lzdGVyZWRcIixhLmoudGIpO2EuYihcImNvbXBvbmVudHMudW5yZWdpc3RlclwiLGEuai51bnJlZ2lzdGVyKTthLmIoXCJjb21wb25lbnRzLmRlZmF1bHRMb2FkZXJcIixhLmouRmMpO2Euai5sb2FkZXJzLnB1c2goYS5qLkZjKTthLmouZGQ9aH0pKCk7KGZ1bmN0aW9uKCl7ZnVuY3Rpb24gYihiLGUpe3ZhciBmPWIuZ2V0QXR0cmlidXRlKFwicGFyYW1zXCIpO2lmKGYpe3ZhciBmPWMucGFyc2VCaW5kaW5nc1N0cmluZyhmLGUsYix7dmFsdWVBY2Nlc3NvcnM6ITAsYmluZGluZ1BhcmFtczohMH0pLGY9YS5hLkdhKGYsZnVuY3Rpb24oYyl7cmV0dXJuIGEubyhjLG51bGwse2w6Yn0pfSksZz1hLmEuR2EoZixcbmZ1bmN0aW9uKGMpe3ZhciBlPWMudigpO3JldHVybiBjLmphKCk/YS5vKHtyZWFkOmZ1bmN0aW9uKCl7cmV0dXJuIGEuYS5mKGMoKSl9LHdyaXRlOmEuWmEoZSkmJmZ1bmN0aW9uKGEpe2MoKShhKX0sbDpifSk6ZX0pO09iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChnLFwiJHJhd1wiKXx8KGcuJHJhdz1mKTtyZXR1cm4gZ31yZXR1cm57JHJhdzp7fX19YS5qLmdldENvbXBvbmVudE5hbWVGb3JOb2RlPWZ1bmN0aW9uKGIpe3ZhciBjPWEuYS5SKGIpO2lmKGEuai50YihjKSYmKC0xIT1jLmluZGV4T2YoXCItXCIpfHxcIltvYmplY3QgSFRNTFVua25vd25FbGVtZW50XVwiPT1cIlwiK2J8fDg+PWEuYS5XJiZiLnRhZ05hbWU9PT1jKSlyZXR1cm4gY307YS5qLnRjPWZ1bmN0aW9uKGMsZSxmLGcpe2lmKDE9PT1lLm5vZGVUeXBlKXt2YXIgaD1hLmouZ2V0Q29tcG9uZW50TmFtZUZvck5vZGUoZSk7aWYoaCl7Yz1jfHx7fTtpZihjLmNvbXBvbmVudCl0aHJvdyBFcnJvcignQ2Fubm90IHVzZSB0aGUgXCJjb21wb25lbnRcIiBiaW5kaW5nIG9uIGEgY3VzdG9tIGVsZW1lbnQgbWF0Y2hpbmcgYSBjb21wb25lbnQnKTtcbnZhciBtPXtuYW1lOmgscGFyYW1zOmIoZSxmKX07Yy5jb21wb25lbnQ9Zz9mdW5jdGlvbigpe3JldHVybiBtfTptfX1yZXR1cm4gY307dmFyIGM9bmV3IGEuZ2E7OT5hLmEuVyYmKGEuai5yZWdpc3Rlcj1mdW5jdGlvbihhKXtyZXR1cm4gZnVuY3Rpb24oYil7cmV0dXJuIGEuYXBwbHkodGhpcyxhcmd1bWVudHMpfX0oYS5qLnJlZ2lzdGVyKSx3LmNyZWF0ZURvY3VtZW50RnJhZ21lbnQ9ZnVuY3Rpb24oYil7cmV0dXJuIGZ1bmN0aW9uKCl7dmFyIGM9YigpLGY9YS5qLmRkLGc7Zm9yKGcgaW4gZik7cmV0dXJuIGN9fSh3LmNyZWF0ZURvY3VtZW50RnJhZ21lbnQpKX0pKCk7KGZ1bmN0aW9uKCl7ZnVuY3Rpb24gYihiLGMsZCl7Yz1jLnRlbXBsYXRlO2lmKCFjKXRocm93IEVycm9yKFwiQ29tcG9uZW50ICdcIitiK1wiJyBoYXMgbm8gdGVtcGxhdGVcIik7Yj1hLmEuQ2EoYyk7YS5oLnZhKGQsYil9ZnVuY3Rpb24gYyhhLGIsYyl7dmFyIGQ9YS5jcmVhdGVWaWV3TW9kZWw7cmV0dXJuIGQ/ZC5jYWxsKGEsXG5iLGMpOmJ9dmFyIGQ9MDthLmMuY29tcG9uZW50PXtpbml0OmZ1bmN0aW9uKGUsZixnLGgsbSl7ZnVuY3Rpb24gaygpe3ZhciBhPWwmJmwuZGlzcG9zZTtcImZ1bmN0aW9uXCI9PT10eXBlb2YgYSYmYS5jYWxsKGwpO3EmJnEucygpO3A9bD1xPW51bGx9dmFyIGwscCxxLHQ9YS5hLmxhKGEuaC5jaGlsZE5vZGVzKGUpKTthLmguRWEoZSk7YS5hLksuemEoZSxrKTthLm8oZnVuY3Rpb24oKXt2YXIgZz1hLmEuZihmKCkpLGgsdTtcInN0cmluZ1wiPT09dHlwZW9mIGc/aD1nOihoPWEuYS5mKGcubmFtZSksdT1hLmEuZihnLnBhcmFtcykpO2lmKCFoKXRocm93IEVycm9yKFwiTm8gY29tcG9uZW50IG5hbWUgc3BlY2lmaWVkXCIpO3ZhciBuPWEuaS5DYihlLG0pLHo9cD0rK2Q7YS5qLmdldChoLGZ1bmN0aW9uKGQpe2lmKHA9PT16KXtrKCk7aWYoIWQpdGhyb3cgRXJyb3IoXCJVbmtub3duIGNvbXBvbmVudCAnXCIraCtcIidcIik7YihoLGQsZSk7dmFyIGY9YyhkLHUse2VsZW1lbnQ6ZSx0ZW1wbGF0ZU5vZGVzOnR9KTtcbmQ9bi5jcmVhdGVDaGlsZENvbnRleHQoZix7ZXh0ZW5kOmZ1bmN0aW9uKGEpe2EuJGNvbXBvbmVudD1mO2EuJGNvbXBvbmVudFRlbXBsYXRlTm9kZXM9dH19KTtmJiZmLmtvRGVzY2VuZGFudHNDb21wbGV0ZSYmKHE9YS5pLnN1YnNjcmliZShlLGEuaS5wYSxmLmtvRGVzY2VuZGFudHNDb21wbGV0ZSxmKSk7bD1mO2EuT2EoZCxlKX19KX0sbnVsbCx7bDplfSk7cmV0dXJue2NvbnRyb2xzRGVzY2VuZGFudEJpbmRpbmdzOiEwfX19O2EuaC5lYS5jb21wb25lbnQ9ITB9KSgpO3ZhciBWPXtcImNsYXNzXCI6XCJjbGFzc05hbWVcIixcImZvclwiOlwiaHRtbEZvclwifTthLmMuYXR0cj17dXBkYXRlOmZ1bmN0aW9uKGIsYyl7dmFyIGQ9YS5hLmYoYygpKXx8e307YS5hLlAoZCxmdW5jdGlvbihjLGQpe2Q9YS5hLmYoZCk7dmFyIGc9Yy5pbmRleE9mKFwiOlwiKSxnPVwibG9va3VwTmFtZXNwYWNlVVJJXCJpbiBiJiYwPGcmJmIubG9va3VwTmFtZXNwYWNlVVJJKGMuc3Vic3RyKDAsZykpLGg9ITE9PT1kfHxudWxsPT09XG5kfHxkPT09bjtoP2c/Yi5yZW1vdmVBdHRyaWJ1dGVOUyhnLGMpOmIucmVtb3ZlQXR0cmlidXRlKGMpOmQ9ZC50b1N0cmluZygpOzg+PWEuYS5XJiZjIGluIFY/KGM9VltjXSxoP2IucmVtb3ZlQXR0cmlidXRlKGMpOmJbY109ZCk6aHx8KGc/Yi5zZXRBdHRyaWJ1dGVOUyhnLGMsZCk6Yi5zZXRBdHRyaWJ1dGUoYyxkKSk7XCJuYW1lXCI9PT1jJiZhLmEuWWMoYixoP1wiXCI6ZCl9KX19OyhmdW5jdGlvbigpe2EuYy5jaGVja2VkPXthZnRlcjpbXCJ2YWx1ZVwiLFwiYXR0clwiXSxpbml0OmZ1bmN0aW9uKGIsYyxkKXtmdW5jdGlvbiBlKCl7dmFyIGU9Yi5jaGVja2VkLGY9ZygpO2lmKCFhLlMuWWEoKSYmKGV8fCFtJiYhYS5TLnFhKCkpKXt2YXIgaz1hLnUuRyhjKTtpZihsKXt2YXIgcT1wP2sudigpOmssej10O3Q9Zjt6IT09Zj9lJiYoYS5hLk5hKHEsZiwhMCksYS5hLk5hKHEseiwhMSkpOmEuYS5OYShxLGYsZSk7cCYmYS5aYShrKSYmayhxKX1lbHNlIGgmJihmPT09bj9mPWU6ZXx8KGY9bikpLGEubS5lYihrLFxuZCxcImNoZWNrZWRcIixmLCEwKX19ZnVuY3Rpb24gZigpe3ZhciBkPWEuYS5mKGMoKSksZT1nKCk7bD8oYi5jaGVja2VkPTA8PWEuYS5BKGQsZSksdD1lKTpiLmNoZWNrZWQ9aCYmZT09PW4/ISFkOmcoKT09PWR9dmFyIGc9YS54YihmdW5jdGlvbigpe2lmKGQuaGFzKFwiY2hlY2tlZFZhbHVlXCIpKXJldHVybiBhLmEuZihkLmdldChcImNoZWNrZWRWYWx1ZVwiKSk7aWYocSlyZXR1cm4gZC5oYXMoXCJ2YWx1ZVwiKT9hLmEuZihkLmdldChcInZhbHVlXCIpKTpiLnZhbHVlfSksaD1cImNoZWNrYm94XCI9PWIudHlwZSxtPVwicmFkaW9cIj09Yi50eXBlO2lmKGh8fG0pe3ZhciBrPWMoKSxsPWgmJmEuYS5mKGspaW5zdGFuY2VvZiBBcnJheSxwPSEobCYmay5wdXNoJiZrLnNwbGljZSkscT1tfHxsLHQ9bD9nKCk6bjttJiYhYi5uYW1lJiZhLmMudW5pcXVlTmFtZS5pbml0KGIsZnVuY3Rpb24oKXtyZXR1cm4hMH0pO2EubyhlLG51bGwse2w6Yn0pO2EuYS5CKGIsXCJjbGlja1wiLGUpO2EubyhmLG51bGwse2w6Yn0pO1xuaz1ufX19O2EubS53YS5jaGVja2VkPSEwO2EuYy5jaGVja2VkVmFsdWU9e3VwZGF0ZTpmdW5jdGlvbihiLGMpe2IudmFsdWU9YS5hLmYoYygpKX19fSkoKTthLmNbXCJjbGFzc1wiXT17dXBkYXRlOmZ1bmN0aW9uKGIsYyl7dmFyIGQ9YS5hLkRiKGEuYS5mKGMoKSkpO2EuYS5FYihiLGIuX19rb19fY3NzVmFsdWUsITEpO2IuX19rb19fY3NzVmFsdWU9ZDthLmEuRWIoYixkLCEwKX19O2EuYy5jc3M9e3VwZGF0ZTpmdW5jdGlvbihiLGMpe3ZhciBkPWEuYS5mKGMoKSk7bnVsbCE9PWQmJlwib2JqZWN0XCI9PXR5cGVvZiBkP2EuYS5QKGQsZnVuY3Rpb24oYyxkKXtkPWEuYS5mKGQpO2EuYS5FYihiLGMsZCl9KTphLmNbXCJjbGFzc1wiXS51cGRhdGUoYixjKX19O2EuYy5lbmFibGU9e3VwZGF0ZTpmdW5jdGlvbihiLGMpe3ZhciBkPWEuYS5mKGMoKSk7ZCYmYi5kaXNhYmxlZD9iLnJlbW92ZUF0dHJpYnV0ZShcImRpc2FibGVkXCIpOmR8fGIuZGlzYWJsZWR8fChiLmRpc2FibGVkPSEwKX19O2EuYy5kaXNhYmxlPVxue3VwZGF0ZTpmdW5jdGlvbihiLGMpe2EuYy5lbmFibGUudXBkYXRlKGIsZnVuY3Rpb24oKXtyZXR1cm4hYS5hLmYoYygpKX0pfX07YS5jLmV2ZW50PXtpbml0OmZ1bmN0aW9uKGIsYyxkLGUsZil7dmFyIGc9YygpfHx7fTthLmEuUChnLGZ1bmN0aW9uKGcpe1wic3RyaW5nXCI9PXR5cGVvZiBnJiZhLmEuQihiLGcsZnVuY3Rpb24oYil7dmFyIGssbD1jKClbZ107aWYobCl7dHJ5e3ZhciBwPWEuYS5sYShhcmd1bWVudHMpO2U9Zi4kZGF0YTtwLnVuc2hpZnQoZSk7az1sLmFwcGx5KGUscCl9ZmluYWxseXshMCE9PWsmJihiLnByZXZlbnREZWZhdWx0P2IucHJldmVudERlZmF1bHQoKTpiLnJldHVyblZhbHVlPSExKX0hMT09PWQuZ2V0KGcrXCJCdWJibGVcIikmJihiLmNhbmNlbEJ1YmJsZT0hMCxiLnN0b3BQcm9wYWdhdGlvbiYmYi5zdG9wUHJvcGFnYXRpb24oKSl9fSl9KX19O2EuYy5mb3JlYWNoPXtSYzpmdW5jdGlvbihiKXtyZXR1cm4gZnVuY3Rpb24oKXt2YXIgYz1iKCksZD1hLmEuYmMoYyk7XG5pZighZHx8XCJudW1iZXJcIj09dHlwZW9mIGQubGVuZ3RoKXJldHVybntmb3JlYWNoOmMsdGVtcGxhdGVFbmdpbmU6YS5iYS5NYX07YS5hLmYoYyk7cmV0dXJue2ZvcmVhY2g6ZC5kYXRhLGFzOmQuYXMsbm9DaGlsZENvbnRleHQ6ZC5ub0NoaWxkQ29udGV4dCxpbmNsdWRlRGVzdHJveWVkOmQuaW5jbHVkZURlc3Ryb3llZCxhZnRlckFkZDpkLmFmdGVyQWRkLGJlZm9yZVJlbW92ZTpkLmJlZm9yZVJlbW92ZSxhZnRlclJlbmRlcjpkLmFmdGVyUmVuZGVyLGJlZm9yZU1vdmU6ZC5iZWZvcmVNb3ZlLGFmdGVyTW92ZTpkLmFmdGVyTW92ZSx0ZW1wbGF0ZUVuZ2luZTphLmJhLk1hfX19LGluaXQ6ZnVuY3Rpb24oYixjKXtyZXR1cm4gYS5jLnRlbXBsYXRlLmluaXQoYixhLmMuZm9yZWFjaC5SYyhjKSl9LHVwZGF0ZTpmdW5jdGlvbihiLGMsZCxlLGYpe3JldHVybiBhLmMudGVtcGxhdGUudXBkYXRlKGIsYS5jLmZvcmVhY2guUmMoYyksZCxlLGYpfX07YS5tLlJhLmZvcmVhY2g9ITE7YS5oLmVhLmZvcmVhY2g9XG4hMDthLmMuaGFzZm9jdXM9e2luaXQ6ZnVuY3Rpb24oYixjLGQpe2Z1bmN0aW9uIGUoZSl7Yi5fX2tvX2hhc2ZvY3VzVXBkYXRpbmc9ITA7dmFyIGY9Yi5vd25lckRvY3VtZW50O2lmKFwiYWN0aXZlRWxlbWVudFwiaW4gZil7dmFyIGc7dHJ5e2c9Zi5hY3RpdmVFbGVtZW50fWNhdGNoKGwpe2c9Zi5ib2R5fWU9Zz09PWJ9Zj1jKCk7YS5tLmViKGYsZCxcImhhc2ZvY3VzXCIsZSwhMCk7Yi5fX2tvX2hhc2ZvY3VzTGFzdFZhbHVlPWU7Yi5fX2tvX2hhc2ZvY3VzVXBkYXRpbmc9ITF9dmFyIGY9ZS5iaW5kKG51bGwsITApLGc9ZS5iaW5kKG51bGwsITEpO2EuYS5CKGIsXCJmb2N1c1wiLGYpO2EuYS5CKGIsXCJmb2N1c2luXCIsZik7YS5hLkIoYixcImJsdXJcIixnKTthLmEuQihiLFwiZm9jdXNvdXRcIixnKTtiLl9fa29faGFzZm9jdXNMYXN0VmFsdWU9ITF9LHVwZGF0ZTpmdW5jdGlvbihiLGMpe3ZhciBkPSEhYS5hLmYoYygpKTtiLl9fa29faGFzZm9jdXNVcGRhdGluZ3x8Yi5fX2tvX2hhc2ZvY3VzTGFzdFZhbHVlPT09XG5kfHwoZD9iLmZvY3VzKCk6Yi5ibHVyKCksIWQmJmIuX19rb19oYXNmb2N1c0xhc3RWYWx1ZSYmYi5vd25lckRvY3VtZW50LmJvZHkuZm9jdXMoKSxhLnUuRyhhLmEuRmIsbnVsbCxbYixkP1wiZm9jdXNpblwiOlwiZm9jdXNvdXRcIl0pKX19O2EubS53YS5oYXNmb2N1cz0hMDthLmMuaGFzRm9jdXM9YS5jLmhhc2ZvY3VzO2EubS53YS5oYXNGb2N1cz1cImhhc2ZvY3VzXCI7YS5jLmh0bWw9e2luaXQ6ZnVuY3Rpb24oKXtyZXR1cm57Y29udHJvbHNEZXNjZW5kYW50QmluZGluZ3M6ITB9fSx1cGRhdGU6ZnVuY3Rpb24oYixjKXthLmEuZmMoYixjKCkpfX07KGZ1bmN0aW9uKCl7ZnVuY3Rpb24gYihiLGQsZSl7YS5jW2JdPXtpbml0OmZ1bmN0aW9uKGIsYyxoLG0sayl7dmFyIGwscCxxPXt9LHQseCxuO2lmKGQpe209aC5nZXQoXCJhc1wiKTt2YXIgdT1oLmdldChcIm5vQ2hpbGRDb250ZXh0XCIpO249IShtJiZ1KTtxPXthczptLG5vQ2hpbGRDb250ZXh0OnUsZXhwb3J0RGVwZW5kZW5jaWVzOm59fXg9KHQ9XG5cInJlbmRlclwiPT1oLmdldChcImNvbXBsZXRlT25cIikpfHxoLmhhcyhhLmkucGEpO2EubyhmdW5jdGlvbigpe3ZhciBoPWEuYS5mKGMoKSksbT0hZSE9PSFoLHU9IXAscjtpZihufHxtIT09bCl7eCYmKGs9YS5pLkNiKGIsaykpO2lmKG0pe2lmKCFkfHxuKXEuZGF0YURlcGVuZGVuY3k9YS5TLm8oKTtyPWQ/ay5jcmVhdGVDaGlsZENvbnRleHQoXCJmdW5jdGlvblwiPT10eXBlb2YgaD9oOmMscSk6YS5TLnFhKCk/ay5leHRlbmQobnVsbCxxKTprfXUmJmEuUy5xYSgpJiYocD1hLmEuQ2EoYS5oLmNoaWxkTm9kZXMoYiksITApKTttPyh1fHxhLmgudmEoYixhLmEuQ2EocCkpLGEuT2EocixiKSk6KGEuaC5FYShiKSx0fHxhLmkubWEoYixhLmkuSCkpO2w9bX19LG51bGwse2w6Yn0pO3JldHVybntjb250cm9sc0Rlc2NlbmRhbnRCaW5kaW5nczohMH19fTthLm0uUmFbYl09ITE7YS5oLmVhW2JdPSEwfWIoXCJpZlwiKTtiKFwiaWZub3RcIiwhMSwhMCk7YihcIndpdGhcIiwhMCl9KSgpO2EuYy5sZXQ9e2luaXQ6ZnVuY3Rpb24oYixcbmMsZCxlLGYpe2M9Zi5leHRlbmQoYyk7YS5PYShjLGIpO3JldHVybntjb250cm9sc0Rlc2NlbmRhbnRCaW5kaW5nczohMH19fTthLmguZWEubGV0PSEwO3ZhciBRPXt9O2EuYy5vcHRpb25zPXtpbml0OmZ1bmN0aW9uKGIpe2lmKFwic2VsZWN0XCIhPT1hLmEuUihiKSl0aHJvdyBFcnJvcihcIm9wdGlvbnMgYmluZGluZyBhcHBsaWVzIG9ubHkgdG8gU0VMRUNUIGVsZW1lbnRzXCIpO2Zvcig7MDxiLmxlbmd0aDspYi5yZW1vdmUoMCk7cmV0dXJue2NvbnRyb2xzRGVzY2VuZGFudEJpbmRpbmdzOiEwfX0sdXBkYXRlOmZ1bmN0aW9uKGIsYyxkKXtmdW5jdGlvbiBlKCl7cmV0dXJuIGEuYS5qYihiLm9wdGlvbnMsZnVuY3Rpb24oYSl7cmV0dXJuIGEuc2VsZWN0ZWR9KX1mdW5jdGlvbiBmKGEsYixjKXt2YXIgZD10eXBlb2YgYjtyZXR1cm5cImZ1bmN0aW9uXCI9PWQ/YihhKTpcInN0cmluZ1wiPT1kP2FbYl06Y31mdW5jdGlvbiBnKGMsZCl7aWYoeCYmbClhLmkubWEoYixhLmkuSCk7ZWxzZSBpZih0Lmxlbmd0aCl7dmFyIGU9XG4wPD1hLmEuQSh0LGEudy5NKGRbMF0pKTthLmEuWmMoZFswXSxlKTt4JiYhZSYmYS51LkcoYS5hLkZiLG51bGwsW2IsXCJjaGFuZ2VcIl0pfX12YXIgaD1iLm11bHRpcGxlLG09MCE9Yi5sZW5ndGgmJmg/Yi5zY3JvbGxUb3A6bnVsbCxrPWEuYS5mKGMoKSksbD1kLmdldChcInZhbHVlQWxsb3dVbnNldFwiKSYmZC5oYXMoXCJ2YWx1ZVwiKSxwPWQuZ2V0KFwib3B0aW9uc0luY2x1ZGVEZXN0cm95ZWRcIik7Yz17fTt2YXIgcSx0PVtdO2x8fChoP3Q9YS5hLk1iKGUoKSxhLncuTSk6MDw9Yi5zZWxlY3RlZEluZGV4JiZ0LnB1c2goYS53Lk0oYi5vcHRpb25zW2Iuc2VsZWN0ZWRJbmRleF0pKSk7ayYmKFwidW5kZWZpbmVkXCI9PXR5cGVvZiBrLmxlbmd0aCYmKGs9W2tdKSxxPWEuYS5qYihrLGZ1bmN0aW9uKGIpe3JldHVybiBwfHxiPT09bnx8bnVsbD09PWJ8fCFhLmEuZihiLl9kZXN0cm95KX0pLGQuaGFzKFwib3B0aW9uc0NhcHRpb25cIikmJihrPWEuYS5mKGQuZ2V0KFwib3B0aW9uc0NhcHRpb25cIikpLG51bGwhPT1cbmsmJmshPT1uJiZxLnVuc2hpZnQoUSkpKTt2YXIgeD0hMTtjLmJlZm9yZVJlbW92ZT1mdW5jdGlvbihhKXtiLnJlbW92ZUNoaWxkKGEpfTtrPWc7ZC5oYXMoXCJvcHRpb25zQWZ0ZXJSZW5kZXJcIikmJlwiZnVuY3Rpb25cIj09dHlwZW9mIGQuZ2V0KFwib3B0aW9uc0FmdGVyUmVuZGVyXCIpJiYoaz1mdW5jdGlvbihiLGMpe2coMCxjKTthLnUuRyhkLmdldChcIm9wdGlvbnNBZnRlclJlbmRlclwiKSxudWxsLFtjWzBdLGIhPT1RP2I6bl0pfSk7YS5hLmVjKGIscSxmdW5jdGlvbihjLGUsZyl7Zy5sZW5ndGgmJih0PSFsJiZnWzBdLnNlbGVjdGVkP1thLncuTShnWzBdKV06W10seD0hMCk7ZT1iLm93bmVyRG9jdW1lbnQuY3JlYXRlRWxlbWVudChcIm9wdGlvblwiKTtjPT09UT8oYS5hLkJiKGUsZC5nZXQoXCJvcHRpb25zQ2FwdGlvblwiKSksYS53LmNiKGUsbikpOihnPWYoYyxkLmdldChcIm9wdGlvbnNWYWx1ZVwiKSxjKSxhLncuY2IoZSxhLmEuZihnKSksYz1mKGMsZC5nZXQoXCJvcHRpb25zVGV4dFwiKSxnKSxcbmEuYS5CYihlLGMpKTtyZXR1cm5bZV19LGMsayk7aWYoIWwpe3ZhciBCO2g/Qj10Lmxlbmd0aCYmZSgpLmxlbmd0aDx0Lmxlbmd0aDpCPXQubGVuZ3RoJiYwPD1iLnNlbGVjdGVkSW5kZXg/YS53Lk0oYi5vcHRpb25zW2Iuc2VsZWN0ZWRJbmRleF0pIT09dFswXTp0Lmxlbmd0aHx8MDw9Yi5zZWxlY3RlZEluZGV4O0ImJmEudS5HKGEuYS5GYixudWxsLFtiLFwiY2hhbmdlXCJdKX0obHx8YS5TLllhKCkpJiZhLmkubWEoYixhLmkuSCk7YS5hLndkKGIpO20mJjIwPE1hdGguYWJzKG0tYi5zY3JvbGxUb3ApJiYoYi5zY3JvbGxUb3A9bSl9fTthLmMub3B0aW9ucy4kYj1hLmEuZy5aKCk7YS5jLnNlbGVjdGVkT3B0aW9ucz17aW5pdDpmdW5jdGlvbihiLGMsZCl7ZnVuY3Rpb24gZSgpe3ZhciBlPWMoKSxmPVtdO2EuYS5EKGIuZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCJvcHRpb25cIiksZnVuY3Rpb24oYil7Yi5zZWxlY3RlZCYmZi5wdXNoKGEudy5NKGIpKX0pO2EubS5lYihlLGQsXCJzZWxlY3RlZE9wdGlvbnNcIixcbmYpfWZ1bmN0aW9uIGYoKXt2YXIgZD1hLmEuZihjKCkpLGU9Yi5zY3JvbGxUb3A7ZCYmXCJudW1iZXJcIj09dHlwZW9mIGQubGVuZ3RoJiZhLmEuRChiLmdldEVsZW1lbnRzQnlUYWdOYW1lKFwib3B0aW9uXCIpLGZ1bmN0aW9uKGIpe3ZhciBjPTA8PWEuYS5BKGQsYS53Lk0oYikpO2Iuc2VsZWN0ZWQhPWMmJmEuYS5aYyhiLGMpfSk7Yi5zY3JvbGxUb3A9ZX1pZihcInNlbGVjdFwiIT1hLmEuUihiKSl0aHJvdyBFcnJvcihcInNlbGVjdGVkT3B0aW9ucyBiaW5kaW5nIGFwcGxpZXMgb25seSB0byBTRUxFQ1QgZWxlbWVudHNcIik7dmFyIGc7YS5pLnN1YnNjcmliZShiLGEuaS5ILGZ1bmN0aW9uKCl7Zz9lKCk6KGEuYS5CKGIsXCJjaGFuZ2VcIixlKSxnPWEubyhmLG51bGwse2w6Yn0pKX0sbnVsbCx7bm90aWZ5SW1tZWRpYXRlbHk6ITB9KX0sdXBkYXRlOmZ1bmN0aW9uKCl7fX07YS5tLndhLnNlbGVjdGVkT3B0aW9ucz0hMDthLmMuc3R5bGU9e3VwZGF0ZTpmdW5jdGlvbihiLGMpe3ZhciBkPWEuYS5mKGMoKXx8XG57fSk7YS5hLlAoZCxmdW5jdGlvbihjLGQpe2Q9YS5hLmYoZCk7aWYobnVsbD09PWR8fGQ9PT1ufHwhMT09PWQpZD1cIlwiO2lmKHYpdihiKS5jc3MoYyxkKTtlbHNlIGlmKC9eLS0vLnRlc3QoYykpYi5zdHlsZS5zZXRQcm9wZXJ0eShjLGQpO2Vsc2V7Yz1jLnJlcGxhY2UoLy0oXFx3KS9nLGZ1bmN0aW9uKGEsYil7cmV0dXJuIGIudG9VcHBlckNhc2UoKX0pO3ZhciBnPWIuc3R5bGVbY107Yi5zdHlsZVtjXT1kO2Q9PT1nfHxiLnN0eWxlW2NdIT1nfHxpc05hTihkKXx8KGIuc3R5bGVbY109ZCtcInB4XCIpfX0pfX07YS5jLnN1Ym1pdD17aW5pdDpmdW5jdGlvbihiLGMsZCxlLGYpe2lmKFwiZnVuY3Rpb25cIiE9dHlwZW9mIGMoKSl0aHJvdyBFcnJvcihcIlRoZSB2YWx1ZSBmb3IgYSBzdWJtaXQgYmluZGluZyBtdXN0IGJlIGEgZnVuY3Rpb25cIik7YS5hLkIoYixcInN1Ym1pdFwiLGZ1bmN0aW9uKGEpe3ZhciBkLGU9YygpO3RyeXtkPWUuY2FsbChmLiRkYXRhLGIpfWZpbmFsbHl7ITAhPT1kJiYoYS5wcmV2ZW50RGVmYXVsdD9cbmEucHJldmVudERlZmF1bHQoKTphLnJldHVyblZhbHVlPSExKX19KX19O2EuYy50ZXh0PXtpbml0OmZ1bmN0aW9uKCl7cmV0dXJue2NvbnRyb2xzRGVzY2VuZGFudEJpbmRpbmdzOiEwfX0sdXBkYXRlOmZ1bmN0aW9uKGIsYyl7YS5hLkJiKGIsYygpKX19O2EuaC5lYS50ZXh0PSEwOyhmdW5jdGlvbigpe2lmKEEmJkEubmF2aWdhdG9yKXt2YXIgYj1mdW5jdGlvbihhKXtpZihhKXJldHVybiBwYXJzZUZsb2F0KGFbMV0pfSxjPUEubmF2aWdhdG9yLnVzZXJBZ2VudCxkLGUsZixnLGg7KGQ9QS5vcGVyYSYmQS5vcGVyYS52ZXJzaW9uJiZwYXJzZUludChBLm9wZXJhLnZlcnNpb24oKSkpfHwoaD1iKGMubWF0Y2goL0VkZ2VcXC8oW14gXSspJC8pKSl8fGIoYy5tYXRjaCgvQ2hyb21lXFwvKFteIF0rKS8pKXx8KGU9YihjLm1hdGNoKC9WZXJzaW9uXFwvKFteIF0rKSBTYWZhcmkvKSkpfHwoZj1iKGMubWF0Y2goL0ZpcmVmb3hcXC8oW14gXSspLykpKXx8KGc9YS5hLld8fGIoYy5tYXRjaCgvTVNJRSAoW14gXSspLykpKXx8XG4oZz1iKGMubWF0Y2goL3J2OihbXiApXSspLykpKX1pZig4PD1nJiYxMD5nKXZhciBtPWEuYS5nLlooKSxrPWEuYS5nLlooKSxsPWZ1bmN0aW9uKGIpe3ZhciBjPXRoaXMuYWN0aXZlRWxlbWVudDsoYz1jJiZhLmEuZy5nZXQoYyxrKSkmJmMoYil9LHA9ZnVuY3Rpb24oYixjKXt2YXIgZD1iLm93bmVyRG9jdW1lbnQ7YS5hLmcuZ2V0KGQsbSl8fChhLmEuZy5zZXQoZCxtLCEwKSxhLmEuQihkLFwic2VsZWN0aW9uY2hhbmdlXCIsbCkpO2EuYS5nLnNldChiLGssYyl9O2EuYy50ZXh0SW5wdXQ9e2luaXQ6ZnVuY3Rpb24oYixjLGspe2Z1bmN0aW9uIGwoYyxkKXthLmEuQihiLGMsZCl9ZnVuY3Rpb24gbSgpe3ZhciBkPWEuYS5mKGMoKSk7aWYobnVsbD09PWR8fGQ9PT1uKWQ9XCJcIjtMIT09biYmZD09PUw/YS5hLnNldFRpbWVvdXQobSw0KTpiLnZhbHVlIT09ZCYmKHk9ITAsYi52YWx1ZT1kLHk9ITEsdj1iLnZhbHVlKX1mdW5jdGlvbiByKCl7d3x8KEw9Yi52YWx1ZSx3PWEuYS5zZXRUaW1lb3V0KHosXG40KSl9ZnVuY3Rpb24geigpe2NsZWFyVGltZW91dCh3KTtMPXc9bjt2YXIgZD1iLnZhbHVlO3YhPT1kJiYodj1kLGEubS5lYihjKCksayxcInRleHRJbnB1dFwiLGQpKX12YXIgdj1iLnZhbHVlLHcsTCxBPTk9PWEuYS5XP3I6eix5PSExO2cmJmwoXCJrZXlwcmVzc1wiLHopOzExPmcmJmwoXCJwcm9wZXJ0eWNoYW5nZVwiLGZ1bmN0aW9uKGEpe3l8fFwidmFsdWVcIiE9PWEucHJvcGVydHlOYW1lfHxBKGEpfSk7OD09ZyYmKGwoXCJrZXl1cFwiLHopLGwoXCJrZXlkb3duXCIseikpO3AmJihwKGIsQSksbChcImRyYWdlbmRcIixyKSk7KCFnfHw5PD1nKSYmbChcImlucHV0XCIsQSk7NT5lJiZcInRleHRhcmVhXCI9PT1hLmEuUihiKT8obChcImtleWRvd25cIixyKSxsKFwicGFzdGVcIixyKSxsKFwiY3V0XCIscikpOjExPmQ/bChcImtleWRvd25cIixyKTo0PmY/KGwoXCJET01BdXRvQ29tcGxldGVcIix6KSxsKFwiZHJhZ2Ryb3BcIix6KSxsKFwiZHJvcFwiLHopKTpoJiZcIm51bWJlclwiPT09Yi50eXBlJiZsKFwia2V5ZG93blwiLHIpO2woXCJjaGFuZ2VcIixcbnopO2woXCJibHVyXCIseik7YS5vKG0sbnVsbCx7bDpifSl9fTthLm0ud2EudGV4dElucHV0PSEwO2EuYy50ZXh0aW5wdXQ9e3ByZXByb2Nlc3M6ZnVuY3Rpb24oYSxiLGMpe2MoXCJ0ZXh0SW5wdXRcIixhKX19fSkoKTthLmMudW5pcXVlTmFtZT17aW5pdDpmdW5jdGlvbihiLGMpe2lmKGMoKSl7dmFyIGQ9XCJrb191bmlxdWVfXCIrICsrYS5jLnVuaXF1ZU5hbWUucmQ7YS5hLlljKGIsZCl9fX07YS5jLnVuaXF1ZU5hbWUucmQ9MDthLmMudXNpbmc9e2luaXQ6ZnVuY3Rpb24oYixjLGQsZSxmKXt2YXIgZztkLmhhcyhcImFzXCIpJiYoZz17YXM6ZC5nZXQoXCJhc1wiKSxub0NoaWxkQ29udGV4dDpkLmdldChcIm5vQ2hpbGRDb250ZXh0XCIpfSk7Yz1mLmNyZWF0ZUNoaWxkQ29udGV4dChjLGcpO2EuT2EoYyxiKTtyZXR1cm57Y29udHJvbHNEZXNjZW5kYW50QmluZGluZ3M6ITB9fX07YS5oLmVhLnVzaW5nPSEwO2EuYy52YWx1ZT17aW5pdDpmdW5jdGlvbihiLGMsZCl7dmFyIGU9YS5hLlIoYiksZj1cImlucHV0XCI9PVxuZTtpZighZnx8XCJjaGVja2JveFwiIT1iLnR5cGUmJlwicmFkaW9cIiE9Yi50eXBlKXt2YXIgZz1bXSxoPWQuZ2V0KFwidmFsdWVVcGRhdGVcIiksbT0hMSxrPW51bGw7aCYmKFwic3RyaW5nXCI9PXR5cGVvZiBoP2c9W2hdOmc9YS5hLndjKGgpLGEuYS5QYShnLFwiY2hhbmdlXCIpKTt2YXIgbD1mdW5jdGlvbigpe2s9bnVsbDttPSExO3ZhciBlPWMoKSxmPWEudy5NKGIpO2EubS5lYihlLGQsXCJ2YWx1ZVwiLGYpfTshYS5hLld8fCFmfHxcInRleHRcIiE9Yi50eXBlfHxcIm9mZlwiPT1iLmF1dG9jb21wbGV0ZXx8Yi5mb3JtJiZcIm9mZlwiPT1iLmZvcm0uYXV0b2NvbXBsZXRlfHwtMSE9YS5hLkEoZyxcInByb3BlcnR5Y2hhbmdlXCIpfHwoYS5hLkIoYixcInByb3BlcnR5Y2hhbmdlXCIsZnVuY3Rpb24oKXttPSEwfSksYS5hLkIoYixcImZvY3VzXCIsZnVuY3Rpb24oKXttPSExfSksYS5hLkIoYixcImJsdXJcIixmdW5jdGlvbigpe20mJmwoKX0pKTthLmEuRChnLGZ1bmN0aW9uKGMpe3ZhciBkPWw7YS5hLlVkKGMsXCJhZnRlclwiKSYmXG4oZD1mdW5jdGlvbigpe2s9YS53Lk0oYik7YS5hLnNldFRpbWVvdXQobCwwKX0sYz1jLnN1YnN0cmluZyg1KSk7YS5hLkIoYixjLGQpfSk7dmFyIHA7cD1mJiZcImZpbGVcIj09Yi50eXBlP2Z1bmN0aW9uKCl7dmFyIGQ9YS5hLmYoYygpKTtudWxsPT09ZHx8ZD09PW58fFwiXCI9PT1kP2IudmFsdWU9XCJcIjphLnUuRyhsKX06ZnVuY3Rpb24oKXt2YXIgZj1hLmEuZihjKCkpLGc9YS53Lk0oYik7aWYobnVsbCE9PWsmJmY9PT1rKWEuYS5zZXRUaW1lb3V0KHAsMCk7ZWxzZSBpZihmIT09Z3x8Zz09PW4pXCJzZWxlY3RcIj09PWU/KGc9ZC5nZXQoXCJ2YWx1ZUFsbG93VW5zZXRcIiksYS53LmNiKGIsZixnKSxnfHxmPT09YS53Lk0oYil8fGEudS5HKGwpKTphLncuY2IoYixmKX07aWYoXCJzZWxlY3RcIj09PWUpe3ZhciBxO2EuaS5zdWJzY3JpYmUoYixhLmkuSCxmdW5jdGlvbigpe3E/ZC5nZXQoXCJ2YWx1ZUFsbG93VW5zZXRcIik/cCgpOmwoKTooYS5hLkIoYixcImNoYW5nZVwiLGwpLHE9YS5vKHAsbnVsbCx7bDpifSkpfSxcbm51bGwse25vdGlmeUltbWVkaWF0ZWx5OiEwfSl9ZWxzZSBhLmEuQihiLFwiY2hhbmdlXCIsbCksYS5vKHAsbnVsbCx7bDpifSl9ZWxzZSBhLmliKGIse2NoZWNrZWRWYWx1ZTpjfSl9LHVwZGF0ZTpmdW5jdGlvbigpe319O2EubS53YS52YWx1ZT0hMDthLmMudmlzaWJsZT17dXBkYXRlOmZ1bmN0aW9uKGIsYyl7dmFyIGQ9YS5hLmYoYygpKSxlPVwibm9uZVwiIT1iLnN0eWxlLmRpc3BsYXk7ZCYmIWU/Yi5zdHlsZS5kaXNwbGF5PVwiXCI6IWQmJmUmJihiLnN0eWxlLmRpc3BsYXk9XCJub25lXCIpfX07YS5jLmhpZGRlbj17dXBkYXRlOmZ1bmN0aW9uKGIsYyl7YS5jLnZpc2libGUudXBkYXRlKGIsZnVuY3Rpb24oKXtyZXR1cm4hYS5hLmYoYygpKX0pfX07KGZ1bmN0aW9uKGIpe2EuY1tiXT17aW5pdDpmdW5jdGlvbihjLGQsZSxmLGcpe3JldHVybiBhLmMuZXZlbnQuaW5pdC5jYWxsKHRoaXMsYyxmdW5jdGlvbigpe3ZhciBhPXt9O2FbYl09ZCgpO3JldHVybiBhfSxlLGYsZyl9fX0pKFwiY2xpY2tcIik7XG5hLmNhPWZ1bmN0aW9uKCl7fTthLmNhLnByb3RvdHlwZS5yZW5kZXJUZW1wbGF0ZVNvdXJjZT1mdW5jdGlvbigpe3Rocm93IEVycm9yKFwiT3ZlcnJpZGUgcmVuZGVyVGVtcGxhdGVTb3VyY2VcIik7fTthLmNhLnByb3RvdHlwZS5jcmVhdGVKYXZhU2NyaXB0RXZhbHVhdG9yQmxvY2s9ZnVuY3Rpb24oKXt0aHJvdyBFcnJvcihcIk92ZXJyaWRlIGNyZWF0ZUphdmFTY3JpcHRFdmFsdWF0b3JCbG9ja1wiKTt9O2EuY2EucHJvdG90eXBlLm1ha2VUZW1wbGF0ZVNvdXJjZT1mdW5jdGlvbihiLGMpe2lmKFwic3RyaW5nXCI9PXR5cGVvZiBiKXtjPWN8fHc7dmFyIGQ9Yy5nZXRFbGVtZW50QnlJZChiKTtpZighZCl0aHJvdyBFcnJvcihcIkNhbm5vdCBmaW5kIHRlbXBsYXRlIHdpdGggSUQgXCIrYik7cmV0dXJuIG5ldyBhLkMuRihkKX1pZigxPT1iLm5vZGVUeXBlfHw4PT1iLm5vZGVUeXBlKXJldHVybiBuZXcgYS5DLmlhKGIpO3Rocm93IEVycm9yKFwiVW5rbm93biB0ZW1wbGF0ZSB0eXBlOiBcIitiKTt9O2EuY2EucHJvdG90eXBlLnJlbmRlclRlbXBsYXRlPVxuZnVuY3Rpb24oYSxjLGQsZSl7YT10aGlzLm1ha2VUZW1wbGF0ZVNvdXJjZShhLGUpO3JldHVybiB0aGlzLnJlbmRlclRlbXBsYXRlU291cmNlKGEsYyxkLGUpfTthLmNhLnByb3RvdHlwZS5pc1RlbXBsYXRlUmV3cml0dGVuPWZ1bmN0aW9uKGEsYyl7cmV0dXJuITE9PT10aGlzLmFsbG93VGVtcGxhdGVSZXdyaXRpbmc/ITA6dGhpcy5tYWtlVGVtcGxhdGVTb3VyY2UoYSxjKS5kYXRhKFwiaXNSZXdyaXR0ZW5cIil9O2EuY2EucHJvdG90eXBlLnJld3JpdGVUZW1wbGF0ZT1mdW5jdGlvbihhLGMsZCl7YT10aGlzLm1ha2VUZW1wbGF0ZVNvdXJjZShhLGQpO2M9YyhhLnRleHQoKSk7YS50ZXh0KGMpO2EuZGF0YShcImlzUmV3cml0dGVuXCIsITApfTthLmIoXCJ0ZW1wbGF0ZUVuZ2luZVwiLGEuY2EpO2Eua2M9ZnVuY3Rpb24oKXtmdW5jdGlvbiBiKGIsYyxkLGgpe2I9YS5tLmFjKGIpO2Zvcih2YXIgbT1hLm0uUmEsaz0wO2s8Yi5sZW5ndGg7aysrKXt2YXIgbD1iW2tdLmtleTtpZihPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwobSxcbmwpKXt2YXIgcD1tW2xdO2lmKFwiZnVuY3Rpb25cIj09PXR5cGVvZiBwKXtpZihsPXAoYltrXS52YWx1ZSkpdGhyb3cgRXJyb3IobCk7fWVsc2UgaWYoIXApdGhyb3cgRXJyb3IoXCJUaGlzIHRlbXBsYXRlIGVuZ2luZSBkb2VzIG5vdCBzdXBwb3J0IHRoZSAnXCIrbCtcIicgYmluZGluZyB3aXRoaW4gaXRzIHRlbXBsYXRlc1wiKTt9fWQ9XCJrby5fX3RyX2FtYnRucyhmdW5jdGlvbigkY29udGV4dCwkZWxlbWVudCl7cmV0dXJuKGZ1bmN0aW9uKCl7cmV0dXJueyBcIithLm0udmIoYix7dmFsdWVBY2Nlc3NvcnM6ITB9KStcIiB9IH0pKCl9LCdcIitkLnRvTG93ZXJDYXNlKCkrXCInKVwiO3JldHVybiBoLmNyZWF0ZUphdmFTY3JpcHRFdmFsdWF0b3JCbG9jayhkKStjfXZhciBjPS8oPChbYS16XStcXGQqKSg/OlxccysoPyFkYXRhLWJpbmRcXHMqPVxccyopW2EtejAtOVxcLV0rKD86PSg/OlxcXCJbXlxcXCJdKlxcXCJ8XFwnW15cXCddKlxcJ3xbXj5dKikpPykqXFxzKylkYXRhLWJpbmRcXHMqPVxccyooW1wiJ10pKFtcXHNcXFNdKj8pXFwzL2dpLFxuZD0vXFx4M2MhLS1cXHMqa29cXGJcXHMqKFtcXHNcXFNdKj8pXFxzKi0tXFx4M2UvZztyZXR1cm57eGQ6ZnVuY3Rpb24oYixjLGQpe2MuaXNUZW1wbGF0ZVJld3JpdHRlbihiLGQpfHxjLnJld3JpdGVUZW1wbGF0ZShiLGZ1bmN0aW9uKGIpe3JldHVybiBhLmtjLkxkKGIsYyl9LGQpfSxMZDpmdW5jdGlvbihhLGYpe3JldHVybiBhLnJlcGxhY2UoYyxmdW5jdGlvbihhLGMsZCxlLGwpe3JldHVybiBiKGwsYyxkLGYpfSkucmVwbGFjZShkLGZ1bmN0aW9uKGEsYyl7cmV0dXJuIGIoYyxcIlxceDNjIS0tIGtvIC0tXFx4M2VcIixcIiNjb21tZW50XCIsZil9KX0sbWQ6ZnVuY3Rpb24oYixjKXtyZXR1cm4gYS5hYS5YYihmdW5jdGlvbihkLGgpe3ZhciBtPWQubmV4dFNpYmxpbmc7bSYmbS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpPT09YyYmYS5pYihtLGIsaCl9KX19fSgpO2EuYihcIl9fdHJfYW1idG5zXCIsYS5rYy5tZCk7KGZ1bmN0aW9uKCl7YS5DPXt9O2EuQy5GPWZ1bmN0aW9uKGIpe2lmKHRoaXMuRj1iKXt2YXIgYz1cbmEuYS5SKGIpO3RoaXMuYWI9XCJzY3JpcHRcIj09PWM/MTpcInRleHRhcmVhXCI9PT1jPzI6XCJ0ZW1wbGF0ZVwiPT1jJiZiLmNvbnRlbnQmJjExPT09Yi5jb250ZW50Lm5vZGVUeXBlPzM6NH19O2EuQy5GLnByb3RvdHlwZS50ZXh0PWZ1bmN0aW9uKCl7dmFyIGI9MT09PXRoaXMuYWI/XCJ0ZXh0XCI6Mj09PXRoaXMuYWI/XCJ2YWx1ZVwiOlwiaW5uZXJIVE1MXCI7aWYoMD09YXJndW1lbnRzLmxlbmd0aClyZXR1cm4gdGhpcy5GW2JdO3ZhciBjPWFyZ3VtZW50c1swXTtcImlubmVySFRNTFwiPT09Yj9hLmEuZmModGhpcy5GLGMpOnRoaXMuRltiXT1jfTt2YXIgYj1hLmEuZy5aKCkrXCJfXCI7YS5DLkYucHJvdG90eXBlLmRhdGE9ZnVuY3Rpb24oYyl7aWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpcmV0dXJuIGEuYS5nLmdldCh0aGlzLkYsYitjKTthLmEuZy5zZXQodGhpcy5GLGIrYyxhcmd1bWVudHNbMV0pfTt2YXIgYz1hLmEuZy5aKCk7YS5DLkYucHJvdG90eXBlLm5vZGVzPWZ1bmN0aW9uKCl7dmFyIGI9dGhpcy5GO1xuaWYoMD09YXJndW1lbnRzLmxlbmd0aCl7dmFyIGU9YS5hLmcuZ2V0KGIsYyl8fHt9LGY9ZS5sYnx8KDM9PT10aGlzLmFiP2IuY29udGVudDo0PT09dGhpcy5hYj9iOm4pO2lmKCFmfHxlLmpkKXt2YXIgZz10aGlzLnRleHQoKTtnJiZnIT09ZS5iYiYmKGY9YS5hLk1kKGcsYi5vd25lckRvY3VtZW50KSxhLmEuZy5zZXQoYixjLHtsYjpmLGJiOmcsamQ6ITB9KSl9cmV0dXJuIGZ9ZT1hcmd1bWVudHNbMF07dGhpcy5hYiE9PW4mJnRoaXMudGV4dChcIlwiKTthLmEuZy5zZXQoYixjLHtsYjplfSl9O2EuQy5pYT1mdW5jdGlvbihhKXt0aGlzLkY9YX07YS5DLmlhLnByb3RvdHlwZT1uZXcgYS5DLkY7YS5DLmlhLnByb3RvdHlwZS5jb25zdHJ1Y3Rvcj1hLkMuaWE7YS5DLmlhLnByb3RvdHlwZS50ZXh0PWZ1bmN0aW9uKCl7aWYoMD09YXJndW1lbnRzLmxlbmd0aCl7dmFyIGI9YS5hLmcuZ2V0KHRoaXMuRixjKXx8e307Yi5iYj09PW4mJmIubGImJihiLmJiPWIubGIuaW5uZXJIVE1MKTtyZXR1cm4gYi5iYn1hLmEuZy5zZXQodGhpcy5GLFxuYyx7YmI6YXJndW1lbnRzWzBdfSl9O2EuYihcInRlbXBsYXRlU291cmNlc1wiLGEuQyk7YS5iKFwidGVtcGxhdGVTb3VyY2VzLmRvbUVsZW1lbnRcIixhLkMuRik7YS5iKFwidGVtcGxhdGVTb3VyY2VzLmFub255bW91c1RlbXBsYXRlXCIsYS5DLmlhKX0pKCk7KGZ1bmN0aW9uKCl7ZnVuY3Rpb24gYihiLGMsZCl7dmFyIGU7Zm9yKGM9YS5oLm5leHRTaWJsaW5nKGMpO2ImJihlPWIpIT09YzspYj1hLmgubmV4dFNpYmxpbmcoZSksZChlLGIpfWZ1bmN0aW9uIGMoYyxkKXtpZihjLmxlbmd0aCl7dmFyIGU9Y1swXSxmPWNbYy5sZW5ndGgtMV0sZz1lLnBhcmVudE5vZGUsaD1hLmdhLmluc3RhbmNlLG09aC5wcmVwcm9jZXNzTm9kZTtpZihtKXtiKGUsZixmdW5jdGlvbihhLGIpe3ZhciBjPWEucHJldmlvdXNTaWJsaW5nLGQ9bS5jYWxsKGgsYSk7ZCYmKGE9PT1lJiYoZT1kWzBdfHxiKSxhPT09ZiYmKGY9ZFtkLmxlbmd0aC0xXXx8YykpfSk7Yy5sZW5ndGg9MDtpZighZSlyZXR1cm47ZT09PWY/Yy5wdXNoKGUpOlxuKGMucHVzaChlLGYpLGEuYS5VYShjLGcpKX1iKGUsZixmdW5jdGlvbihiKXsxIT09Yi5ub2RlVHlwZSYmOCE9PWIubm9kZVR5cGV8fGEudmMoZCxiKX0pO2IoZSxmLGZ1bmN0aW9uKGIpezEhPT1iLm5vZGVUeXBlJiY4IT09Yi5ub2RlVHlwZXx8YS5hYS5jZChiLFtkXSl9KTthLmEuVWEoYyxnKX19ZnVuY3Rpb24gZChhKXtyZXR1cm4gYS5ub2RlVHlwZT9hOjA8YS5sZW5ndGg/YVswXTpudWxsfWZ1bmN0aW9uIGUoYixlLGYsaCxtKXttPW18fHt9O3ZhciBuPShiJiZkKGIpfHxmfHx7fSkub3duZXJEb2N1bWVudCxCPW0udGVtcGxhdGVFbmdpbmV8fGc7YS5rYy54ZChmLEIsbik7Zj1CLnJlbmRlclRlbXBsYXRlKGYsaCxtLG4pO2lmKFwibnVtYmVyXCIhPXR5cGVvZiBmLmxlbmd0aHx8MDxmLmxlbmd0aCYmXCJudW1iZXJcIiE9dHlwZW9mIGZbMF0ubm9kZVR5cGUpdGhyb3cgRXJyb3IoXCJUZW1wbGF0ZSBlbmdpbmUgbXVzdCByZXR1cm4gYW4gYXJyYXkgb2YgRE9NIG5vZGVzXCIpO249ITE7c3dpdGNoKGUpe2Nhc2UgXCJyZXBsYWNlQ2hpbGRyZW5cIjphLmgudmEoYixcbmYpO249ITA7YnJlYWs7Y2FzZSBcInJlcGxhY2VOb2RlXCI6YS5hLlhjKGIsZik7bj0hMDticmVhaztjYXNlIFwiaWdub3JlVGFyZ2V0Tm9kZVwiOmJyZWFrO2RlZmF1bHQ6dGhyb3cgRXJyb3IoXCJVbmtub3duIHJlbmRlck1vZGU6IFwiK2UpO31uJiYoYyhmLGgpLG0uYWZ0ZXJSZW5kZXImJmEudS5HKG0uYWZ0ZXJSZW5kZXIsbnVsbCxbZixoW20uYXN8fFwiJGRhdGFcIl1dKSxcInJlcGxhY2VDaGlsZHJlblwiPT1lJiZhLmkubWEoYixhLmkuSCkpO3JldHVybiBmfWZ1bmN0aW9uIGYoYixjLGQpe3JldHVybiBhLk8oYik/YigpOlwiZnVuY3Rpb25cIj09PXR5cGVvZiBiP2IoYyxkKTpifXZhciBnO2EuZ2M9ZnVuY3Rpb24oYil7aWYoYiE9biYmIShiIGluc3RhbmNlb2YgYS5jYSkpdGhyb3cgRXJyb3IoXCJ0ZW1wbGF0ZUVuZ2luZSBtdXN0IGluaGVyaXQgZnJvbSBrby50ZW1wbGF0ZUVuZ2luZVwiKTtnPWJ9O2EuZGM9ZnVuY3Rpb24oYixjLGgsbSx0KXtoPWh8fHt9O2lmKChoLnRlbXBsYXRlRW5naW5lfHxnKT09XG5uKXRocm93IEVycm9yKFwiU2V0IGEgdGVtcGxhdGUgZW5naW5lIGJlZm9yZSBjYWxsaW5nIHJlbmRlclRlbXBsYXRlXCIpO3Q9dHx8XCJyZXBsYWNlQ2hpbGRyZW5cIjtpZihtKXt2YXIgeD1kKG0pO3JldHVybiBhLiQoZnVuY3Rpb24oKXt2YXIgZz1jJiZjIGluc3RhbmNlb2YgYS5mYT9jOm5ldyBhLmZhKGMsbnVsbCxudWxsLG51bGwse2V4cG9ydERlcGVuZGVuY2llczohMH0pLG49ZihiLGcuJGRhdGEsZyksZz1lKG0sdCxuLGcsaCk7XCJyZXBsYWNlTm9kZVwiPT10JiYobT1nLHg9ZChtKSl9LG51bGwse1NhOmZ1bmN0aW9uKCl7cmV0dXJuIXh8fCFhLmEuU2IoeCl9LGw6eCYmXCJyZXBsYWNlTm9kZVwiPT10P3gucGFyZW50Tm9kZTp4fSl9cmV0dXJuIGEuYWEuWGIoZnVuY3Rpb24oZCl7YS5kYyhiLGMsaCxkLFwicmVwbGFjZU5vZGVcIil9KX07YS5RZD1mdW5jdGlvbihiLGQsZyxoLG0pe2Z1bmN0aW9uIHgoYixjKXthLnUuRyhhLmEuZWMsbnVsbCxbaCxiLHUsZyxyLGNdKTthLmkubWEoaCxhLmkuSCl9XG5mdW5jdGlvbiByKGEsYil7YyhiLHYpO2cuYWZ0ZXJSZW5kZXImJmcuYWZ0ZXJSZW5kZXIoYixhKTt2PW51bGx9ZnVuY3Rpb24gdShhLGMpe3Y9bS5jcmVhdGVDaGlsZENvbnRleHQoYSx7YXM6eixub0NoaWxkQ29udGV4dDpnLm5vQ2hpbGRDb250ZXh0LGV4dGVuZDpmdW5jdGlvbihhKXthLiRpbmRleD1jO3omJihhW3orXCJJbmRleFwiXT1jKX19KTt2YXIgZD1mKGIsYSx2KTtyZXR1cm4gZShoLFwiaWdub3JlVGFyZ2V0Tm9kZVwiLGQsdixnKX12YXIgdix6PWcuYXMsdz0hMT09PWcuaW5jbHVkZURlc3Ryb3llZHx8YS5vcHRpb25zLmZvcmVhY2hIaWRlc0Rlc3Ryb3llZCYmIWcuaW5jbHVkZURlc3Ryb3llZDtpZih3fHxnLmJlZm9yZVJlbW92ZXx8IWEuUGMoZCkpcmV0dXJuIGEuJChmdW5jdGlvbigpe3ZhciBiPWEuYS5mKGQpfHxbXTtcInVuZGVmaW5lZFwiPT10eXBlb2YgYi5sZW5ndGgmJihiPVtiXSk7dyYmKGI9YS5hLmpiKGIsZnVuY3Rpb24oYil7cmV0dXJuIGI9PT1ufHxudWxsPT09Ynx8XG4hYS5hLmYoYi5fZGVzdHJveSl9KSk7eChiKX0sbnVsbCx7bDpofSk7eChkLnYoKSk7dmFyIEE9ZC5zdWJzY3JpYmUoZnVuY3Rpb24oYSl7eChkKCksYSl9LG51bGwsXCJhcnJheUNoYW5nZVwiKTtBLmwoaCk7cmV0dXJuIEF9O3ZhciBoPWEuYS5nLlooKSxtPWEuYS5nLlooKTthLmMudGVtcGxhdGU9e2luaXQ6ZnVuY3Rpb24oYixjKXt2YXIgZD1hLmEuZihjKCkpO2lmKFwic3RyaW5nXCI9PXR5cGVvZiBkfHxcIm5hbWVcImluIGQpYS5oLkVhKGIpO2Vsc2UgaWYoXCJub2Rlc1wiaW4gZCl7ZD1kLm5vZGVzfHxbXTtpZihhLk8oZCkpdGhyb3cgRXJyb3IoJ1RoZSBcIm5vZGVzXCIgb3B0aW9uIG11c3QgYmUgYSBwbGFpbiwgbm9uLW9ic2VydmFibGUgYXJyYXkuJyk7dmFyIGU9ZFswXSYmZFswXS5wYXJlbnROb2RlO2UmJmEuYS5nLmdldChlLG0pfHwoZT1hLmEuWWIoZCksYS5hLmcuc2V0KGUsbSwhMCkpOyhuZXcgYS5DLmlhKGIpKS5ub2RlcyhlKX1lbHNlIGlmKGQ9YS5oLmNoaWxkTm9kZXMoYiksMDxkLmxlbmd0aCllPVxuYS5hLlliKGQpLChuZXcgYS5DLmlhKGIpKS5ub2RlcyhlKTtlbHNlIHRocm93IEVycm9yKFwiQW5vbnltb3VzIHRlbXBsYXRlIGRlZmluZWQsIGJ1dCBubyB0ZW1wbGF0ZSBjb250ZW50IHdhcyBwcm92aWRlZFwiKTtyZXR1cm57Y29udHJvbHNEZXNjZW5kYW50QmluZGluZ3M6ITB9fSx1cGRhdGU6ZnVuY3Rpb24oYixjLGQsZSxmKXt2YXIgZz1jKCk7Yz1hLmEuZihnKTtkPSEwO2U9bnVsbDtcInN0cmluZ1wiPT10eXBlb2YgYz9jPXt9OihnPVwibmFtZVwiaW4gYz9jLm5hbWU6YixcImlmXCJpbiBjJiYoZD1hLmEuZihjW1wiaWZcIl0pKSxkJiZcImlmbm90XCJpbiBjJiYoZD0hYS5hLmYoYy5pZm5vdCkpLGQmJiFnJiYoZD0hMSkpO1wiZm9yZWFjaFwiaW4gYz9lPWEuUWQoZyxkJiZjLmZvcmVhY2h8fFtdLGMsYixmKTpkPyhkPWYsXCJkYXRhXCJpbiBjJiYoZD1mLmNyZWF0ZUNoaWxkQ29udGV4dChjLmRhdGEse2FzOmMuYXMsbm9DaGlsZENvbnRleHQ6Yy5ub0NoaWxkQ29udGV4dCxleHBvcnREZXBlbmRlbmNpZXM6ITB9KSksXG5lPWEuZGMoZyxkLGMsYikpOmEuaC5FYShiKTtmPWU7KGM9YS5hLmcuZ2V0KGIsaCkpJiZcImZ1bmN0aW9uXCI9PXR5cGVvZiBjLnMmJmMucygpO2EuYS5nLnNldChiLGgsIWZ8fGYuamEmJiFmLmphKCk/bjpmKX19O2EubS5SYS50ZW1wbGF0ZT1mdW5jdGlvbihiKXtiPWEubS5hYyhiKTtyZXR1cm4gMT09Yi5sZW5ndGgmJmJbMF0udW5rbm93bnx8YS5tLklkKGIsXCJuYW1lXCIpP251bGw6XCJUaGlzIHRlbXBsYXRlIGVuZ2luZSBkb2VzIG5vdCBzdXBwb3J0IGFub255bW91cyB0ZW1wbGF0ZXMgbmVzdGVkIHdpdGhpbiBpdHMgdGVtcGxhdGVzXCJ9O2EuaC5lYS50ZW1wbGF0ZT0hMH0pKCk7YS5iKFwic2V0VGVtcGxhdGVFbmdpbmVcIixhLmdjKTthLmIoXCJyZW5kZXJUZW1wbGF0ZVwiLGEuZGMpO2EuYS5LYz1mdW5jdGlvbihhLGMsZCl7aWYoYS5sZW5ndGgmJmMubGVuZ3RoKXt2YXIgZSxmLGcsaCxtO2ZvcihlPWY9MDsoIWR8fGU8ZCkmJihoPWFbZl0pOysrZil7Zm9yKGc9MDttPWNbZ107KytnKWlmKGgudmFsdWU9PT1cbm0udmFsdWUpe2gubW92ZWQ9bS5pbmRleDttLm1vdmVkPWguaW5kZXg7Yy5zcGxpY2UoZywxKTtlPWc9MDticmVha31lKz1nfX19O2EuYS5QYj1mdW5jdGlvbigpe2Z1bmN0aW9uIGIoYixkLGUsZixnKXt2YXIgaD1NYXRoLm1pbixtPU1hdGgubWF4LGs9W10sbCxwPWIubGVuZ3RoLHEsbj1kLmxlbmd0aCxyPW4tcHx8MSx2PXArbisxLHUsdyx6O2ZvcihsPTA7bDw9cDtsKyspZm9yKHc9dSxrLnB1c2godT1bXSksej1oKG4sbCtyKSxxPW0oMCxsLTEpO3E8PXo7cSsrKXVbcV09cT9sP2JbbC0xXT09PWRbcS0xXT93W3EtMV06aCh3W3FdfHx2LHVbcS0xXXx8dikrMTpxKzE6bCsxO2g9W107bT1bXTtyPVtdO2w9cDtmb3IocT1uO2x8fHE7KW49a1tsXVtxXS0xLHEmJm49PT1rW2xdW3EtMV0/bS5wdXNoKGhbaC5sZW5ndGhdPXtzdGF0dXM6ZSx2YWx1ZTpkWy0tcV0saW5kZXg6cX0pOmwmJm49PT1rW2wtMV1bcV0/ci5wdXNoKGhbaC5sZW5ndGhdPXtzdGF0dXM6Zix2YWx1ZTpiWy0tbF0saW5kZXg6bH0pOlxuKC0tcSwtLWwsZy5zcGFyc2V8fGgucHVzaCh7c3RhdHVzOlwicmV0YWluZWRcIix2YWx1ZTpkW3FdfSkpO2EuYS5LYyhyLG0sIWcuZG9udExpbWl0TW92ZXMmJjEwKnApO3JldHVybiBoLnJldmVyc2UoKX1yZXR1cm4gZnVuY3Rpb24oYSxkLGUpe2U9XCJib29sZWFuXCI9PT10eXBlb2YgZT97ZG9udExpbWl0TW92ZXM6ZX06ZXx8e307YT1hfHxbXTtkPWR8fFtdO3JldHVybiBhLmxlbmd0aDxkLmxlbmd0aD9iKGEsZCxcImFkZGVkXCIsXCJkZWxldGVkXCIsZSk6YihkLGEsXCJkZWxldGVkXCIsXCJhZGRlZFwiLGUpfX0oKTthLmIoXCJ1dGlscy5jb21wYXJlQXJyYXlzXCIsYS5hLlBiKTsoZnVuY3Rpb24oKXtmdW5jdGlvbiBiKGIsYyxkLGgsbSl7dmFyIGs9W10sbD1hLiQoZnVuY3Rpb24oKXt2YXIgbD1jKGQsbSxhLmEuVWEoayxiKSl8fFtdOzA8ay5sZW5ndGgmJihhLmEuWGMoayxsKSxoJiZhLnUuRyhoLG51bGwsW2QsbCxtXSkpO2subGVuZ3RoPTA7YS5hLk5iKGssbCl9LG51bGwse2w6YixTYTpmdW5jdGlvbigpe3JldHVybiFhLmEua2Qoayl9fSk7XG5yZXR1cm57WTprLCQ6bC5qYSgpP2w6bn19dmFyIGM9YS5hLmcuWigpLGQ9YS5hLmcuWigpO2EuYS5lYz1mdW5jdGlvbihlLGYsZyxoLG0sayl7ZnVuY3Rpb24gbChiKXt5PXtBYTpiLHBiOmEudGEodysrKX07di5wdXNoKHkpO3J8fEYucHVzaCh5KX1mdW5jdGlvbiBwKGIpe3k9dFtiXTt3IT09eS5wYi52KCkmJkQucHVzaCh5KTt5LnBiKHcrKyk7YS5hLlVhKHkuWSxlKTt2LnB1c2goeSl9ZnVuY3Rpb24gcShiLGMpe2lmKGIpZm9yKHZhciBkPTAsZT1jLmxlbmd0aDtkPGU7ZCsrKWEuYS5EKGNbZF0uWSxmdW5jdGlvbihhKXtiKGEsZCxjW2RdLkFhKX0pfWY9Znx8W107XCJ1bmRlZmluZWRcIj09dHlwZW9mIGYubGVuZ3RoJiYoZj1bZl0pO2g9aHx8e307dmFyIHQ9YS5hLmcuZ2V0KGUsYykscj0hdCx2PVtdLHU9MCx3PTAsej1bXSxBPVtdLEM9W10sRD1bXSxGPVtdLHksST0wO2lmKHIpYS5hLkQoZixsKTtlbHNle2lmKCFrfHx0JiZ0Ll9jb3VudFdhaXRpbmdGb3JSZW1vdmUpe3ZhciBFPVxuYS5hLk1iKHQsZnVuY3Rpb24oYSl7cmV0dXJuIGEuQWF9KTtrPWEuYS5QYihFLGYse2RvbnRMaW1pdE1vdmVzOmguZG9udExpbWl0TW92ZXMsc3BhcnNlOiEwfSl9Zm9yKHZhciBFPTAsRyxILEs7Rz1rW0VdO0UrKylzd2l0Y2goSD1HLm1vdmVkLEs9Ry5pbmRleCxHLnN0YXR1cyl7Y2FzZSBcImRlbGV0ZWRcIjpmb3IoO3U8SzspcCh1KyspO0g9PT1uJiYoeT10W3VdLHkuJCYmKHkuJC5zKCkseS4kPW4pLGEuYS5VYSh5LlksZSkubGVuZ3RoJiYoaC5iZWZvcmVSZW1vdmUmJih2LnB1c2goeSksSSsrLHkuQWE9PT1kP3k9bnVsbDpDLnB1c2goeSkpLHkmJnoucHVzaC5hcHBseSh6LHkuWSkpKTt1Kys7YnJlYWs7Y2FzZSBcImFkZGVkXCI6Zm9yKDt3PEs7KXAodSsrKTtIIT09bj8oQS5wdXNoKHYubGVuZ3RoKSxwKEgpKTpsKEcudmFsdWUpfWZvcig7dzxmLmxlbmd0aDspcCh1KyspO3YuX2NvdW50V2FpdGluZ0ZvclJlbW92ZT1JfWEuYS5nLnNldChlLGMsdik7cShoLmJlZm9yZU1vdmUsRCk7YS5hLkQoeixcbmguYmVmb3JlUmVtb3ZlP2Eub2E6YS5yZW1vdmVOb2RlKTt2YXIgTSxPLFA7dHJ5e1A9ZS5vd25lckRvY3VtZW50LmFjdGl2ZUVsZW1lbnR9Y2F0Y2goTil7fWlmKEEubGVuZ3RoKWZvcig7KEU9QS5zaGlmdCgpKSE9bjspe3k9dltFXTtmb3IoTT1uO0U7KWlmKChPPXZbLS1FXS5ZKSYmTy5sZW5ndGgpe009T1tPLmxlbmd0aC0xXTticmVha31mb3IoZj0wO3U9eS5ZW2ZdO009dSxmKyspYS5oLldiKGUsdSxNKX1mb3IoRT0wO3k9dltFXTtFKyspe3kuWXx8YS5hLmV4dGVuZCh5LGIoZSxnLHkuQWEsbSx5LnBiKSk7Zm9yKGY9MDt1PXkuWVtmXTtNPXUsZisrKWEuaC5XYihlLHUsTSk7IXkuRWQmJm0mJihtKHkuQWEseS5ZLHkucGIpLHkuRWQ9ITAsTT15LllbeS5ZLmxlbmd0aC0xXSl9UCYmZS5vd25lckRvY3VtZW50LmFjdGl2ZUVsZW1lbnQhPVAmJlAuZm9jdXMoKTtxKGguYmVmb3JlUmVtb3ZlLEMpO2ZvcihFPTA7RTxDLmxlbmd0aDsrK0UpQ1tFXS5BYT1kO3EoaC5hZnRlck1vdmUsRCk7XG5xKGguYWZ0ZXJBZGQsRil9fSkoKTthLmIoXCJ1dGlscy5zZXREb21Ob2RlQ2hpbGRyZW5Gcm9tQXJyYXlNYXBwaW5nXCIsYS5hLmVjKTthLmJhPWZ1bmN0aW9uKCl7dGhpcy5hbGxvd1RlbXBsYXRlUmV3cml0aW5nPSExfTthLmJhLnByb3RvdHlwZT1uZXcgYS5jYTthLmJhLnByb3RvdHlwZS5jb25zdHJ1Y3Rvcj1hLmJhO2EuYmEucHJvdG90eXBlLnJlbmRlclRlbXBsYXRlU291cmNlPWZ1bmN0aW9uKGIsYyxkLGUpe2lmKGM9KDk+YS5hLlc/MDpiLm5vZGVzKT9iLm5vZGVzKCk6bnVsbClyZXR1cm4gYS5hLmxhKGMuY2xvbmVOb2RlKCEwKS5jaGlsZE5vZGVzKTtiPWIudGV4dCgpO3JldHVybiBhLmEudWEoYixlKX07YS5iYS5NYT1uZXcgYS5iYTthLmdjKGEuYmEuTWEpO2EuYihcIm5hdGl2ZVRlbXBsYXRlRW5naW5lXCIsYS5iYSk7KGZ1bmN0aW9uKCl7YS4kYT1mdW5jdGlvbigpe3ZhciBhPXRoaXMuSGQ9ZnVuY3Rpb24oKXtpZighdnx8IXYudG1wbClyZXR1cm4gMDt0cnl7aWYoMDw9di50bXBsLnRhZy50bXBsLm9wZW4udG9TdHJpbmcoKS5pbmRleE9mKFwiX19cIikpcmV0dXJuIDJ9Y2F0Y2goYSl7fXJldHVybiAxfSgpO1xudGhpcy5yZW5kZXJUZW1wbGF0ZVNvdXJjZT1mdW5jdGlvbihiLGUsZixnKXtnPWd8fHc7Zj1mfHx7fTtpZigyPmEpdGhyb3cgRXJyb3IoXCJZb3VyIHZlcnNpb24gb2YgalF1ZXJ5LnRtcGwgaXMgdG9vIG9sZC4gUGxlYXNlIHVwZ3JhZGUgdG8galF1ZXJ5LnRtcGwgMS4wLjBwcmUgb3IgbGF0ZXIuXCIpO3ZhciBoPWIuZGF0YShcInByZWNvbXBpbGVkXCIpO2h8fChoPWIudGV4dCgpfHxcIlwiLGg9di50ZW1wbGF0ZShudWxsLFwie3trb193aXRoICRpdGVtLmtvQmluZGluZ0NvbnRleHR9fVwiK2grXCJ7ey9rb193aXRofX1cIiksYi5kYXRhKFwicHJlY29tcGlsZWRcIixoKSk7Yj1bZS4kZGF0YV07ZT12LmV4dGVuZCh7a29CaW5kaW5nQ29udGV4dDplfSxmLnRlbXBsYXRlT3B0aW9ucyk7ZT12LnRtcGwoaCxiLGUpO2UuYXBwZW5kVG8oZy5jcmVhdGVFbGVtZW50KFwiZGl2XCIpKTt2LmZyYWdtZW50cz17fTtyZXR1cm4gZX07dGhpcy5jcmVhdGVKYXZhU2NyaXB0RXZhbHVhdG9yQmxvY2s9ZnVuY3Rpb24oYSl7cmV0dXJuXCJ7e2tvX2NvZGUgKChmdW5jdGlvbigpIHsgcmV0dXJuIFwiK1xuYStcIiB9KSgpKSB9fVwifTt0aGlzLmFkZFRlbXBsYXRlPWZ1bmN0aW9uKGEsYil7dy53cml0ZShcIjxzY3JpcHQgdHlwZT0ndGV4dC9odG1sJyBpZD0nXCIrYStcIic+XCIrYitcIlxceDNjL3NjcmlwdD5cIil9OzA8YSYmKHYudG1wbC50YWcua29fY29kZT17b3BlbjpcIl9fLnB1c2goJDEgfHwgJycpO1wifSx2LnRtcGwudGFnLmtvX3dpdGg9e29wZW46XCJ3aXRoKCQxKSB7XCIsY2xvc2U6XCJ9IFwifSl9O2EuJGEucHJvdG90eXBlPW5ldyBhLmNhO2EuJGEucHJvdG90eXBlLmNvbnN0cnVjdG9yPWEuJGE7dmFyIGI9bmV3IGEuJGE7MDxiLkhkJiZhLmdjKGIpO2EuYihcImpxdWVyeVRtcGxUZW1wbGF0ZUVuZ2luZVwiLGEuJGEpfSkoKX0pfSkoKTt9KSgpO1xuXG59KSgpO1xuXG4vLyBBdm9pZCBwb2xsdXRpbmcgdGhlIGdsb2JhbCBzY29wZS5cbnZhciBrbm9ja291dCA9IGtvO1xuaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKSB7XG4gICAga28gPSB3aW5kb3cua287XG4gICAgaWYgKHR5cGVvZiBvbGRWYWx1ZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgd2luZG93LmtvID0gb2xkVmFsdWU7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgZGVsZXRlIHdpbmRvdy5rbztcbiAgICB9XG59IGVsc2Uge1xuICAgIGtvID0gZ2xvYmFsLmtvO1xuICAgIGlmICh0eXBlb2Ygb2xkVmFsdWUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIGdsb2JhbC5rbyA9IG9sZFZhbHVlO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGRlbGV0ZSBnbG9iYWwua287XG4gICAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBrbm9ja291dDtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///67391\n')},11397:function(__unused_webpack___webpack_module__,__webpack_exports__){eval("/**\n * @license\n * Knockout ES5 plugin - https://github.com/SteveSanderson/knockout-es5\n * Copyright (c) Steve Sanderson\n * MIT license\n */\n\n    var OBSERVABLES_PROPERTY = '__knockoutObservables';\n    var SUBSCRIBABLE_PROPERTY = '__knockoutSubscribable';\n\n    // Model tracking\n    // --------------\n    //\n    // This is the central feature of Knockout-ES5. We augment model objects by converting properties\n    // into ES5 getter/setter pairs that read/write an underlying Knockout observable. This means you can\n    // use plain JavaScript syntax to read/write the property while still getting the full benefits of\n    // Knockout's automatic dependency detection and notification triggering.\n    //\n    // For comparison, here's Knockout ES3-compatible syntax:\n    //\n    //     var firstNameLength = myModel.user().firstName().length; // Read\n    //     myModel.user().firstName('Bert'); // Write\n    //\n    // ... versus Knockout-ES5 syntax:\n    //\n    //     var firstNameLength = myModel.user.firstName.length; // Read\n    //     myModel.user.firstName = 'Bert'; // Write\n\n    // `ko.track(model)` converts each property on the given model object into a getter/setter pair that\n    // wraps a Knockout observable. Optionally specify an array of property names to wrap; otherwise we\n    // wrap all properties. If any of the properties are already observables, we replace them with\n    // ES5 getter/setter pairs that wrap your original observable instances. In the case of readonly\n    // ko.computed properties, we simply do not define a setter (so attempted writes will be ignored,\n    // which is how ES5 readonly properties normally behave).\n    //\n    // By design, this does *not* recursively walk child object properties, because making literally\n    // everything everywhere independently observable is usually unhelpful. When you do want to track\n    // child object properties independently, define your own class for those child objects and put\n    // a separate ko.track call into its constructor --- this gives you far more control.\n    function track(obj, propertyNames) {\n        if (!obj /*|| typeof obj !== 'object'*/) {\n            throw new Error('When calling ko.track, you must pass an object as the first parameter.');\n        }\n\n        var ko = this,\n            allObservablesForObject = getAllObservablesForObject(obj, true);\n        propertyNames = propertyNames || Object.getOwnPropertyNames(obj);\n\n        propertyNames.forEach(function(propertyName) {\n            // Skip storage properties\n            if (propertyName === OBSERVABLES_PROPERTY || propertyName === SUBSCRIBABLE_PROPERTY) {\n                return;\n            }\n            // Skip properties that are already tracked\n            if (propertyName in allObservablesForObject) {\n                return;\n            }\n\n            var origValue = obj[propertyName],\n                isArray = origValue instanceof Array,\n                observable = ko.isObservable(origValue) ? origValue\n                                              : isArray ? ko.observableArray(origValue)\n                                                        : ko.observable(origValue);\n\n            Object.defineProperty(obj, propertyName, {\n                configurable: true,\n                enumerable: true,\n                get: observable,\n                set: ko.isWriteableObservable(observable) ? observable : undefined\n            });\n\n            allObservablesForObject[propertyName] = observable;\n\n            if (isArray) {\n                notifyWhenPresentOrFutureArrayValuesMutate(ko, observable);\n            }\n        });\n\n        return obj;\n    }\n\n    // Gets or creates the hidden internal key-value collection of observables corresponding to\n    // properties on the model object.\n    function getAllObservablesForObject(obj, createIfNotDefined) {\n        var result = obj[OBSERVABLES_PROPERTY];\n        if (!result && createIfNotDefined) {\n            result = {};\n            Object.defineProperty(obj, OBSERVABLES_PROPERTY, {\n                value : result\n            });\n        }\n        return result;\n    }\n\n    // Computed properties\n    // -------------------\n    //\n    // The preceding code is already sufficient to upgrade ko.computed model properties to ES5\n    // getter/setter pairs (or in the case of readonly ko.computed properties, just a getter).\n    // These then behave like a regular property with a getter function, except they are smarter:\n    // your evaluator is only invoked when one of its dependencies changes. The result is cached\n    // and used for all evaluations until the next time a dependency changes).\n    //\n    // However, instead of forcing developers to declare a ko.computed property explicitly, it's\n    // nice to offer a utility function that declares a computed getter directly.\n\n    // Implements `ko.defineProperty`\n    function defineComputedProperty(obj, propertyName, evaluatorOrOptions) {\n        var ko = this,\n            computedOptions = { owner: obj, deferEvaluation: true };\n\n        if (typeof evaluatorOrOptions === 'function') {\n            computedOptions.read = evaluatorOrOptions;\n        } else {\n            if ('value' in evaluatorOrOptions) {\n                throw new Error('For ko.defineProperty, you must not specify a \"value\" for the property. You must provide a \"get\" function.');\n            }\n\n            if (typeof evaluatorOrOptions.get !== 'function') {\n                throw new Error('For ko.defineProperty, the third parameter must be either an evaluator function, or an options object containing a function called \"get\".');\n            }\n\n            computedOptions.read = evaluatorOrOptions.get;\n            computedOptions.write = evaluatorOrOptions.set;\n        }\n\n        obj[propertyName] = ko.computed(computedOptions);\n        track.call(ko, obj, [propertyName]);\n        return obj;\n    }\n\n    // Array handling\n    // --------------\n    //\n    // Arrays are special, because unlike other property types, they have standard mutator functions\n    // (`push`/`pop`/`splice`/etc.) and it's desirable to trigger a change notification whenever one of\n    // those mutator functions is invoked.\n    //\n    // Traditionally, Knockout handles this by putting special versions of `push`/`pop`/etc. on observable\n    // arrays that mutate the underlying array and then trigger a notification. That approach doesn't\n    // work for Knockout-ES5 because properties now return the underlying arrays, so the mutator runs\n    // in the context of the underlying array, not any particular observable:\n    //\n    //     // Operates on the underlying array value\n    //     myModel.someCollection.push('New value');\n    //\n    // To solve this, Knockout-ES5 detects array values, and modifies them as follows:\n    //  1. Associates a hidden subscribable with each array instance that it encounters\n    //  2. Intercepts standard mutators (`push`/`pop`/etc.) and makes them trigger the subscribable\n    // Then, for model properties whose values are arrays, the property's underlying observable\n    // subscribes to the array subscribable, so it can trigger a change notification after mutation.\n\n    // Given an observable that underlies a model property, watch for any array value that might\n    // be assigned as the property value, and hook into its change events\n    function notifyWhenPresentOrFutureArrayValuesMutate(ko, observable) {\n        var watchingArraySubscription = null;\n        ko.computed(function () {\n            // Unsubscribe to any earlier array instance\n            if (watchingArraySubscription) {\n                watchingArraySubscription.dispose();\n                watchingArraySubscription = null;\n            }\n\n            // Subscribe to the new array instance\n            var newArrayInstance = observable();\n            if (newArrayInstance instanceof Array) {\n                watchingArraySubscription = startWatchingArrayInstance(ko, observable, newArrayInstance);\n            }\n        });\n    }\n\n    // Listens for array mutations, and when they happen, cause the observable to fire notifications.\n    // This is used to make model properties of type array fire notifications when the array changes.\n    // Returns a subscribable that can later be disposed.\n    function startWatchingArrayInstance(ko, observable, arrayInstance) {\n        var subscribable = getSubscribableForArray(ko, arrayInstance);\n        return subscribable.subscribe(observable);\n    }\n\n    // Gets or creates a subscribable that fires after each array mutation\n    function getSubscribableForArray(ko, arrayInstance) {\n        var subscribable = arrayInstance[SUBSCRIBABLE_PROPERTY];\n        if (!subscribable) {\n            subscribable = new ko.subscribable();\n            Object.defineProperty(arrayInstance, SUBSCRIBABLE_PROPERTY, {\n                value : subscribable\n            });\n\n            var notificationPauseSignal = {};\n            wrapStandardArrayMutators(arrayInstance, subscribable, notificationPauseSignal);\n            addKnockoutArrayMutators(ko, arrayInstance, subscribable, notificationPauseSignal);\n        }\n\n        return subscribable;\n    }\n\n    // After each array mutation, fires a notification on the given subscribable\n    function wrapStandardArrayMutators(arrayInstance, subscribable, notificationPauseSignal) {\n        ['pop', 'push', 'reverse', 'shift', 'sort', 'splice', 'unshift'].forEach(function(fnName) {\n            var origMutator = arrayInstance[fnName];\n            arrayInstance[fnName] = function() {\n                var result = origMutator.apply(this, arguments);\n                if (notificationPauseSignal.pause !== true) {\n                    subscribable.notifySubscribers(this);\n                }\n                return result;\n            };\n        });\n    }\n\n    // Adds Knockout's additional array mutation functions to the array\n    function addKnockoutArrayMutators(ko, arrayInstance, subscribable, notificationPauseSignal) {\n        ['remove', 'removeAll', 'destroy', 'destroyAll', 'replace'].forEach(function(fnName) {\n            // Make it a non-enumerable property for consistency with standard Array functions\n            Object.defineProperty(arrayInstance, fnName, {\n                enumerable: false,\n                value: function() {\n                    var result;\n\n                    // These additional array mutators are built using the underlying push/pop/etc.\n                    // mutators, which are wrapped to trigger notifications. But we don't want to\n                    // trigger multiple notifications, so pause the push/pop/etc. wrappers and\n                    // delivery only one notification at the end of the process.\n                    notificationPauseSignal.pause = true;\n                    try {\n                        // Creates a temporary observableArray that can perform the operation.\n                        result = ko.observableArray.fn[fnName].apply(ko.observableArray(arrayInstance), arguments);\n                    }\n                    finally {\n                        notificationPauseSignal.pause = false;\n                    }\n                    subscribable.notifySubscribers(arrayInstance);\n                    return result;\n                }\n            });\n        });\n    }\n\n    // Static utility functions\n    // ------------------------\n    //\n    // Since Knockout-ES5 sets up properties that return values, not observables, you can't\n    // trivially subscribe to the underlying observables (e.g., `someProperty.subscribe(...)`),\n    // or tell them that object values have mutated, etc. To handle this, we set up some\n    // extra utility functions that can return or work with the underlying observables.\n\n    // Returns the underlying observable associated with a model property (or `null` if the\n    // model or property doesn't exist, or isn't associated with an observable). This means\n    // you can subscribe to the property, e.g.:\n    //\n    //     ko.getObservable(model, 'propertyName')\n    //       .subscribe(function(newValue) { ... });\n    function getObservable(obj, propertyName) {\n        if (!obj /*|| typeof obj !== 'object'*/) {\n            return null;\n        }\n\n        var allObservablesForObject = getAllObservablesForObject(obj, false);\n        return (allObservablesForObject && allObservablesForObject[propertyName]) || null;\n    }\n\n    // Causes a property's associated observable to fire a change notification. Useful when\n    // the property value is a complex object and you've modified a child property.\n    function valueHasMutated(obj, propertyName) {\n        var observable = getObservable(obj, propertyName);\n\n        if (observable) {\n            observable.valueHasMutated();\n        }\n    }\n\n    // Extends a Knockout instance with Knockout-ES5 functionality\n    function attachToKo(ko) {\n        ko.track = track;\n        ko.getObservable = getObservable;\n        ko.valueHasMutated = valueHasMutated;\n        ko.defineProperty = defineComputedProperty;\n    }\n\n    /* harmony default export */ __webpack_exports__[\"Z\"] = ({\n        attachToKo : attachToKo\n    });\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTEzOTcuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvRUFBb0U7QUFDcEUsNkNBQTZDO0FBQzdDO0FBQ0E7QUFDQTtBQUNBLGdFQUFnRTtBQUNoRSw0Q0FBNEM7O0FBRTVDO0FBQ0EsMkZBQTJGO0FBQzNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTs7QUFFYjs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0M7O0FBRWhDO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTs7QUFFYjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMsS0FBSztBQUNsRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsSUFBSSx5REFBZTtBQUNuQjtBQUNBLEtBQUssRUFBQyIsInNvdXJjZXMiOlsid2VicGFjazovL3Z1ZTMtd2VicGFjazUvLi9ub2RlX21vZHVsZXMvY2VzaXVtL1NvdXJjZS9UaGlyZFBhcnR5L2tub2Nrb3V0LWVzNS5qcz8zZGNlIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQGxpY2Vuc2VcbiAqIEtub2Nrb3V0IEVTNSBwbHVnaW4gLSBodHRwczovL2dpdGh1Yi5jb20vU3RldmVTYW5kZXJzb24va25vY2tvdXQtZXM1XG4gKiBDb3B5cmlnaHQgKGMpIFN0ZXZlIFNhbmRlcnNvblxuICogTUlUIGxpY2Vuc2VcbiAqL1xuXG4gICAgdmFyIE9CU0VSVkFCTEVTX1BST1BFUlRZID0gJ19fa25vY2tvdXRPYnNlcnZhYmxlcyc7XG4gICAgdmFyIFNVQlNDUklCQUJMRV9QUk9QRVJUWSA9ICdfX2tub2Nrb3V0U3Vic2NyaWJhYmxlJztcblxuICAgIC8vIE1vZGVsIHRyYWNraW5nXG4gICAgLy8gLS0tLS0tLS0tLS0tLS1cbiAgICAvL1xuICAgIC8vIFRoaXMgaXMgdGhlIGNlbnRyYWwgZmVhdHVyZSBvZiBLbm9ja291dC1FUzUuIFdlIGF1Z21lbnQgbW9kZWwgb2JqZWN0cyBieSBjb252ZXJ0aW5nIHByb3BlcnRpZXNcbiAgICAvLyBpbnRvIEVTNSBnZXR0ZXIvc2V0dGVyIHBhaXJzIHRoYXQgcmVhZC93cml0ZSBhbiB1bmRlcmx5aW5nIEtub2Nrb3V0IG9ic2VydmFibGUuIFRoaXMgbWVhbnMgeW91IGNhblxuICAgIC8vIHVzZSBwbGFpbiBKYXZhU2NyaXB0IHN5bnRheCB0byByZWFkL3dyaXRlIHRoZSBwcm9wZXJ0eSB3aGlsZSBzdGlsbCBnZXR0aW5nIHRoZSBmdWxsIGJlbmVmaXRzIG9mXG4gICAgLy8gS25vY2tvdXQncyBhdXRvbWF0aWMgZGVwZW5kZW5jeSBkZXRlY3Rpb24gYW5kIG5vdGlmaWNhdGlvbiB0cmlnZ2VyaW5nLlxuICAgIC8vXG4gICAgLy8gRm9yIGNvbXBhcmlzb24sIGhlcmUncyBLbm9ja291dCBFUzMtY29tcGF0aWJsZSBzeW50YXg6XG4gICAgLy9cbiAgICAvLyAgICAgdmFyIGZpcnN0TmFtZUxlbmd0aCA9IG15TW9kZWwudXNlcigpLmZpcnN0TmFtZSgpLmxlbmd0aDsgLy8gUmVhZFxuICAgIC8vICAgICBteU1vZGVsLnVzZXIoKS5maXJzdE5hbWUoJ0JlcnQnKTsgLy8gV3JpdGVcbiAgICAvL1xuICAgIC8vIC4uLiB2ZXJzdXMgS25vY2tvdXQtRVM1IHN5bnRheDpcbiAgICAvL1xuICAgIC8vICAgICB2YXIgZmlyc3ROYW1lTGVuZ3RoID0gbXlNb2RlbC51c2VyLmZpcnN0TmFtZS5sZW5ndGg7IC8vIFJlYWRcbiAgICAvLyAgICAgbXlNb2RlbC51c2VyLmZpcnN0TmFtZSA9ICdCZXJ0JzsgLy8gV3JpdGVcblxuICAgIC8vIGBrby50cmFjayhtb2RlbClgIGNvbnZlcnRzIGVhY2ggcHJvcGVydHkgb24gdGhlIGdpdmVuIG1vZGVsIG9iamVjdCBpbnRvIGEgZ2V0dGVyL3NldHRlciBwYWlyIHRoYXRcbiAgICAvLyB3cmFwcyBhIEtub2Nrb3V0IG9ic2VydmFibGUuIE9wdGlvbmFsbHkgc3BlY2lmeSBhbiBhcnJheSBvZiBwcm9wZXJ0eSBuYW1lcyB0byB3cmFwOyBvdGhlcndpc2Ugd2VcbiAgICAvLyB3cmFwIGFsbCBwcm9wZXJ0aWVzLiBJZiBhbnkgb2YgdGhlIHByb3BlcnRpZXMgYXJlIGFscmVhZHkgb2JzZXJ2YWJsZXMsIHdlIHJlcGxhY2UgdGhlbSB3aXRoXG4gICAgLy8gRVM1IGdldHRlci9zZXR0ZXIgcGFpcnMgdGhhdCB3cmFwIHlvdXIgb3JpZ2luYWwgb2JzZXJ2YWJsZSBpbnN0YW5jZXMuIEluIHRoZSBjYXNlIG9mIHJlYWRvbmx5XG4gICAgLy8ga28uY29tcHV0ZWQgcHJvcGVydGllcywgd2Ugc2ltcGx5IGRvIG5vdCBkZWZpbmUgYSBzZXR0ZXIgKHNvIGF0dGVtcHRlZCB3cml0ZXMgd2lsbCBiZSBpZ25vcmVkLFxuICAgIC8vIHdoaWNoIGlzIGhvdyBFUzUgcmVhZG9ubHkgcHJvcGVydGllcyBub3JtYWxseSBiZWhhdmUpLlxuICAgIC8vXG4gICAgLy8gQnkgZGVzaWduLCB0aGlzIGRvZXMgKm5vdCogcmVjdXJzaXZlbHkgd2FsayBjaGlsZCBvYmplY3QgcHJvcGVydGllcywgYmVjYXVzZSBtYWtpbmcgbGl0ZXJhbGx5XG4gICAgLy8gZXZlcnl0aGluZyBldmVyeXdoZXJlIGluZGVwZW5kZW50bHkgb2JzZXJ2YWJsZSBpcyB1c3VhbGx5IHVuaGVscGZ1bC4gV2hlbiB5b3UgZG8gd2FudCB0byB0cmFja1xuICAgIC8vIGNoaWxkIG9iamVjdCBwcm9wZXJ0aWVzIGluZGVwZW5kZW50bHksIGRlZmluZSB5b3VyIG93biBjbGFzcyBmb3IgdGhvc2UgY2hpbGQgb2JqZWN0cyBhbmQgcHV0XG4gICAgLy8gYSBzZXBhcmF0ZSBrby50cmFjayBjYWxsIGludG8gaXRzIGNvbnN0cnVjdG9yIC0tLSB0aGlzIGdpdmVzIHlvdSBmYXIgbW9yZSBjb250cm9sLlxuICAgIGZ1bmN0aW9uIHRyYWNrKG9iaiwgcHJvcGVydHlOYW1lcykge1xuICAgICAgICBpZiAoIW9iaiAvKnx8IHR5cGVvZiBvYmogIT09ICdvYmplY3QnKi8pIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignV2hlbiBjYWxsaW5nIGtvLnRyYWNrLCB5b3UgbXVzdCBwYXNzIGFuIG9iamVjdCBhcyB0aGUgZmlyc3QgcGFyYW1ldGVyLicpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGtvID0gdGhpcyxcbiAgICAgICAgICAgIGFsbE9ic2VydmFibGVzRm9yT2JqZWN0ID0gZ2V0QWxsT2JzZXJ2YWJsZXNGb3JPYmplY3Qob2JqLCB0cnVlKTtcbiAgICAgICAgcHJvcGVydHlOYW1lcyA9IHByb3BlcnR5TmFtZXMgfHwgT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMob2JqKTtcblxuICAgICAgICBwcm9wZXJ0eU5hbWVzLmZvckVhY2goZnVuY3Rpb24ocHJvcGVydHlOYW1lKSB7XG4gICAgICAgICAgICAvLyBTa2lwIHN0b3JhZ2UgcHJvcGVydGllc1xuICAgICAgICAgICAgaWYgKHByb3BlcnR5TmFtZSA9PT0gT0JTRVJWQUJMRVNfUFJPUEVSVFkgfHwgcHJvcGVydHlOYW1lID09PSBTVUJTQ1JJQkFCTEVfUFJPUEVSVFkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBTa2lwIHByb3BlcnRpZXMgdGhhdCBhcmUgYWxyZWFkeSB0cmFja2VkXG4gICAgICAgICAgICBpZiAocHJvcGVydHlOYW1lIGluIGFsbE9ic2VydmFibGVzRm9yT2JqZWN0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgb3JpZ1ZhbHVlID0gb2JqW3Byb3BlcnR5TmFtZV0sXG4gICAgICAgICAgICAgICAgaXNBcnJheSA9IG9yaWdWYWx1ZSBpbnN0YW5jZW9mIEFycmF5LFxuICAgICAgICAgICAgICAgIG9ic2VydmFibGUgPSBrby5pc09ic2VydmFibGUob3JpZ1ZhbHVlKSA/IG9yaWdWYWx1ZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogaXNBcnJheSA/IGtvLm9ic2VydmFibGVBcnJheShvcmlnVmFsdWUpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDoga28ub2JzZXJ2YWJsZShvcmlnVmFsdWUpO1xuXG4gICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBwcm9wZXJ0eU5hbWUsIHtcbiAgICAgICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICBnZXQ6IG9ic2VydmFibGUsXG4gICAgICAgICAgICAgICAgc2V0OiBrby5pc1dyaXRlYWJsZU9ic2VydmFibGUob2JzZXJ2YWJsZSkgPyBvYnNlcnZhYmxlIDogdW5kZWZpbmVkXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgYWxsT2JzZXJ2YWJsZXNGb3JPYmplY3RbcHJvcGVydHlOYW1lXSA9IG9ic2VydmFibGU7XG5cbiAgICAgICAgICAgIGlmIChpc0FycmF5KSB7XG4gICAgICAgICAgICAgICAgbm90aWZ5V2hlblByZXNlbnRPckZ1dHVyZUFycmF5VmFsdWVzTXV0YXRlKGtvLCBvYnNlcnZhYmxlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9XG5cbiAgICAvLyBHZXRzIG9yIGNyZWF0ZXMgdGhlIGhpZGRlbiBpbnRlcm5hbCBrZXktdmFsdWUgY29sbGVjdGlvbiBvZiBvYnNlcnZhYmxlcyBjb3JyZXNwb25kaW5nIHRvXG4gICAgLy8gcHJvcGVydGllcyBvbiB0aGUgbW9kZWwgb2JqZWN0LlxuICAgIGZ1bmN0aW9uIGdldEFsbE9ic2VydmFibGVzRm9yT2JqZWN0KG9iaiwgY3JlYXRlSWZOb3REZWZpbmVkKSB7XG4gICAgICAgIHZhciByZXN1bHQgPSBvYmpbT0JTRVJWQUJMRVNfUFJPUEVSVFldO1xuICAgICAgICBpZiAoIXJlc3VsdCAmJiBjcmVhdGVJZk5vdERlZmluZWQpIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IHt9O1xuICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwgT0JTRVJWQUJMRVNfUFJPUEVSVFksIHtcbiAgICAgICAgICAgICAgICB2YWx1ZSA6IHJlc3VsdFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvLyBDb21wdXRlZCBwcm9wZXJ0aWVzXG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIC8vXG4gICAgLy8gVGhlIHByZWNlZGluZyBjb2RlIGlzIGFscmVhZHkgc3VmZmljaWVudCB0byB1cGdyYWRlIGtvLmNvbXB1dGVkIG1vZGVsIHByb3BlcnRpZXMgdG8gRVM1XG4gICAgLy8gZ2V0dGVyL3NldHRlciBwYWlycyAob3IgaW4gdGhlIGNhc2Ugb2YgcmVhZG9ubHkga28uY29tcHV0ZWQgcHJvcGVydGllcywganVzdCBhIGdldHRlcikuXG4gICAgLy8gVGhlc2UgdGhlbiBiZWhhdmUgbGlrZSBhIHJlZ3VsYXIgcHJvcGVydHkgd2l0aCBhIGdldHRlciBmdW5jdGlvbiwgZXhjZXB0IHRoZXkgYXJlIHNtYXJ0ZXI6XG4gICAgLy8geW91ciBldmFsdWF0b3IgaXMgb25seSBpbnZva2VkIHdoZW4gb25lIG9mIGl0cyBkZXBlbmRlbmNpZXMgY2hhbmdlcy4gVGhlIHJlc3VsdCBpcyBjYWNoZWRcbiAgICAvLyBhbmQgdXNlZCBmb3IgYWxsIGV2YWx1YXRpb25zIHVudGlsIHRoZSBuZXh0IHRpbWUgYSBkZXBlbmRlbmN5IGNoYW5nZXMpLlxuICAgIC8vXG4gICAgLy8gSG93ZXZlciwgaW5zdGVhZCBvZiBmb3JjaW5nIGRldmVsb3BlcnMgdG8gZGVjbGFyZSBhIGtvLmNvbXB1dGVkIHByb3BlcnR5IGV4cGxpY2l0bHksIGl0J3NcbiAgICAvLyBuaWNlIHRvIG9mZmVyIGEgdXRpbGl0eSBmdW5jdGlvbiB0aGF0IGRlY2xhcmVzIGEgY29tcHV0ZWQgZ2V0dGVyIGRpcmVjdGx5LlxuXG4gICAgLy8gSW1wbGVtZW50cyBga28uZGVmaW5lUHJvcGVydHlgXG4gICAgZnVuY3Rpb24gZGVmaW5lQ29tcHV0ZWRQcm9wZXJ0eShvYmosIHByb3BlcnR5TmFtZSwgZXZhbHVhdG9yT3JPcHRpb25zKSB7XG4gICAgICAgIHZhciBrbyA9IHRoaXMsXG4gICAgICAgICAgICBjb21wdXRlZE9wdGlvbnMgPSB7IG93bmVyOiBvYmosIGRlZmVyRXZhbHVhdGlvbjogdHJ1ZSB9O1xuXG4gICAgICAgIGlmICh0eXBlb2YgZXZhbHVhdG9yT3JPcHRpb25zID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBjb21wdXRlZE9wdGlvbnMucmVhZCA9IGV2YWx1YXRvck9yT3B0aW9ucztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmICgndmFsdWUnIGluIGV2YWx1YXRvck9yT3B0aW9ucykge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRm9yIGtvLmRlZmluZVByb3BlcnR5LCB5b3UgbXVzdCBub3Qgc3BlY2lmeSBhIFwidmFsdWVcIiBmb3IgdGhlIHByb3BlcnR5LiBZb3UgbXVzdCBwcm92aWRlIGEgXCJnZXRcIiBmdW5jdGlvbi4nKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHR5cGVvZiBldmFsdWF0b3JPck9wdGlvbnMuZ2V0ICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdGb3Iga28uZGVmaW5lUHJvcGVydHksIHRoZSB0aGlyZCBwYXJhbWV0ZXIgbXVzdCBiZSBlaXRoZXIgYW4gZXZhbHVhdG9yIGZ1bmN0aW9uLCBvciBhbiBvcHRpb25zIG9iamVjdCBjb250YWluaW5nIGEgZnVuY3Rpb24gY2FsbGVkIFwiZ2V0XCIuJyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNvbXB1dGVkT3B0aW9ucy5yZWFkID0gZXZhbHVhdG9yT3JPcHRpb25zLmdldDtcbiAgICAgICAgICAgIGNvbXB1dGVkT3B0aW9ucy53cml0ZSA9IGV2YWx1YXRvck9yT3B0aW9ucy5zZXQ7XG4gICAgICAgIH1cblxuICAgICAgICBvYmpbcHJvcGVydHlOYW1lXSA9IGtvLmNvbXB1dGVkKGNvbXB1dGVkT3B0aW9ucyk7XG4gICAgICAgIHRyYWNrLmNhbGwoa28sIG9iaiwgW3Byb3BlcnR5TmFtZV0pO1xuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH1cblxuICAgIC8vIEFycmF5IGhhbmRsaW5nXG4gICAgLy8gLS0tLS0tLS0tLS0tLS1cbiAgICAvL1xuICAgIC8vIEFycmF5cyBhcmUgc3BlY2lhbCwgYmVjYXVzZSB1bmxpa2Ugb3RoZXIgcHJvcGVydHkgdHlwZXMsIHRoZXkgaGF2ZSBzdGFuZGFyZCBtdXRhdG9yIGZ1bmN0aW9uc1xuICAgIC8vIChgcHVzaGAvYHBvcGAvYHNwbGljZWAvZXRjLikgYW5kIGl0J3MgZGVzaXJhYmxlIHRvIHRyaWdnZXIgYSBjaGFuZ2Ugbm90aWZpY2F0aW9uIHdoZW5ldmVyIG9uZSBvZlxuICAgIC8vIHRob3NlIG11dGF0b3IgZnVuY3Rpb25zIGlzIGludm9rZWQuXG4gICAgLy9cbiAgICAvLyBUcmFkaXRpb25hbGx5LCBLbm9ja291dCBoYW5kbGVzIHRoaXMgYnkgcHV0dGluZyBzcGVjaWFsIHZlcnNpb25zIG9mIGBwdXNoYC9gcG9wYC9ldGMuIG9uIG9ic2VydmFibGVcbiAgICAvLyBhcnJheXMgdGhhdCBtdXRhdGUgdGhlIHVuZGVybHlpbmcgYXJyYXkgYW5kIHRoZW4gdHJpZ2dlciBhIG5vdGlmaWNhdGlvbi4gVGhhdCBhcHByb2FjaCBkb2Vzbid0XG4gICAgLy8gd29yayBmb3IgS25vY2tvdXQtRVM1IGJlY2F1c2UgcHJvcGVydGllcyBub3cgcmV0dXJuIHRoZSB1bmRlcmx5aW5nIGFycmF5cywgc28gdGhlIG11dGF0b3IgcnVuc1xuICAgIC8vIGluIHRoZSBjb250ZXh0IG9mIHRoZSB1bmRlcmx5aW5nIGFycmF5LCBub3QgYW55IHBhcnRpY3VsYXIgb2JzZXJ2YWJsZTpcbiAgICAvL1xuICAgIC8vICAgICAvLyBPcGVyYXRlcyBvbiB0aGUgdW5kZXJseWluZyBhcnJheSB2YWx1ZVxuICAgIC8vICAgICBteU1vZGVsLnNvbWVDb2xsZWN0aW9uLnB1c2goJ05ldyB2YWx1ZScpO1xuICAgIC8vXG4gICAgLy8gVG8gc29sdmUgdGhpcywgS25vY2tvdXQtRVM1IGRldGVjdHMgYXJyYXkgdmFsdWVzLCBhbmQgbW9kaWZpZXMgdGhlbSBhcyBmb2xsb3dzOlxuICAgIC8vICAxLiBBc3NvY2lhdGVzIGEgaGlkZGVuIHN1YnNjcmliYWJsZSB3aXRoIGVhY2ggYXJyYXkgaW5zdGFuY2UgdGhhdCBpdCBlbmNvdW50ZXJzXG4gICAgLy8gIDIuIEludGVyY2VwdHMgc3RhbmRhcmQgbXV0YXRvcnMgKGBwdXNoYC9gcG9wYC9ldGMuKSBhbmQgbWFrZXMgdGhlbSB0cmlnZ2VyIHRoZSBzdWJzY3JpYmFibGVcbiAgICAvLyBUaGVuLCBmb3IgbW9kZWwgcHJvcGVydGllcyB3aG9zZSB2YWx1ZXMgYXJlIGFycmF5cywgdGhlIHByb3BlcnR5J3MgdW5kZXJseWluZyBvYnNlcnZhYmxlXG4gICAgLy8gc3Vic2NyaWJlcyB0byB0aGUgYXJyYXkgc3Vic2NyaWJhYmxlLCBzbyBpdCBjYW4gdHJpZ2dlciBhIGNoYW5nZSBub3RpZmljYXRpb24gYWZ0ZXIgbXV0YXRpb24uXG5cbiAgICAvLyBHaXZlbiBhbiBvYnNlcnZhYmxlIHRoYXQgdW5kZXJsaWVzIGEgbW9kZWwgcHJvcGVydHksIHdhdGNoIGZvciBhbnkgYXJyYXkgdmFsdWUgdGhhdCBtaWdodFxuICAgIC8vIGJlIGFzc2lnbmVkIGFzIHRoZSBwcm9wZXJ0eSB2YWx1ZSwgYW5kIGhvb2sgaW50byBpdHMgY2hhbmdlIGV2ZW50c1xuICAgIGZ1bmN0aW9uIG5vdGlmeVdoZW5QcmVzZW50T3JGdXR1cmVBcnJheVZhbHVlc011dGF0ZShrbywgb2JzZXJ2YWJsZSkge1xuICAgICAgICB2YXIgd2F0Y2hpbmdBcnJheVN1YnNjcmlwdGlvbiA9IG51bGw7XG4gICAgICAgIGtvLmNvbXB1dGVkKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIC8vIFVuc3Vic2NyaWJlIHRvIGFueSBlYXJsaWVyIGFycmF5IGluc3RhbmNlXG4gICAgICAgICAgICBpZiAod2F0Y2hpbmdBcnJheVN1YnNjcmlwdGlvbikge1xuICAgICAgICAgICAgICAgIHdhdGNoaW5nQXJyYXlTdWJzY3JpcHRpb24uZGlzcG9zZSgpO1xuICAgICAgICAgICAgICAgIHdhdGNoaW5nQXJyYXlTdWJzY3JpcHRpb24gPSBudWxsO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBTdWJzY3JpYmUgdG8gdGhlIG5ldyBhcnJheSBpbnN0YW5jZVxuICAgICAgICAgICAgdmFyIG5ld0FycmF5SW5zdGFuY2UgPSBvYnNlcnZhYmxlKCk7XG4gICAgICAgICAgICBpZiAobmV3QXJyYXlJbnN0YW5jZSBpbnN0YW5jZW9mIEFycmF5KSB7XG4gICAgICAgICAgICAgICAgd2F0Y2hpbmdBcnJheVN1YnNjcmlwdGlvbiA9IHN0YXJ0V2F0Y2hpbmdBcnJheUluc3RhbmNlKGtvLCBvYnNlcnZhYmxlLCBuZXdBcnJheUluc3RhbmNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgLy8gTGlzdGVucyBmb3IgYXJyYXkgbXV0YXRpb25zLCBhbmQgd2hlbiB0aGV5IGhhcHBlbiwgY2F1c2UgdGhlIG9ic2VydmFibGUgdG8gZmlyZSBub3RpZmljYXRpb25zLlxuICAgIC8vIFRoaXMgaXMgdXNlZCB0byBtYWtlIG1vZGVsIHByb3BlcnRpZXMgb2YgdHlwZSBhcnJheSBmaXJlIG5vdGlmaWNhdGlvbnMgd2hlbiB0aGUgYXJyYXkgY2hhbmdlcy5cbiAgICAvLyBSZXR1cm5zIGEgc3Vic2NyaWJhYmxlIHRoYXQgY2FuIGxhdGVyIGJlIGRpc3Bvc2VkLlxuICAgIGZ1bmN0aW9uIHN0YXJ0V2F0Y2hpbmdBcnJheUluc3RhbmNlKGtvLCBvYnNlcnZhYmxlLCBhcnJheUluc3RhbmNlKSB7XG4gICAgICAgIHZhciBzdWJzY3JpYmFibGUgPSBnZXRTdWJzY3JpYmFibGVGb3JBcnJheShrbywgYXJyYXlJbnN0YW5jZSk7XG4gICAgICAgIHJldHVybiBzdWJzY3JpYmFibGUuc3Vic2NyaWJlKG9ic2VydmFibGUpO1xuICAgIH1cblxuICAgIC8vIEdldHMgb3IgY3JlYXRlcyBhIHN1YnNjcmliYWJsZSB0aGF0IGZpcmVzIGFmdGVyIGVhY2ggYXJyYXkgbXV0YXRpb25cbiAgICBmdW5jdGlvbiBnZXRTdWJzY3JpYmFibGVGb3JBcnJheShrbywgYXJyYXlJbnN0YW5jZSkge1xuICAgICAgICB2YXIgc3Vic2NyaWJhYmxlID0gYXJyYXlJbnN0YW5jZVtTVUJTQ1JJQkFCTEVfUFJPUEVSVFldO1xuICAgICAgICBpZiAoIXN1YnNjcmliYWJsZSkge1xuICAgICAgICAgICAgc3Vic2NyaWJhYmxlID0gbmV3IGtvLnN1YnNjcmliYWJsZSgpO1xuICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGFycmF5SW5zdGFuY2UsIFNVQlNDUklCQUJMRV9QUk9QRVJUWSwge1xuICAgICAgICAgICAgICAgIHZhbHVlIDogc3Vic2NyaWJhYmxlXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgdmFyIG5vdGlmaWNhdGlvblBhdXNlU2lnbmFsID0ge307XG4gICAgICAgICAgICB3cmFwU3RhbmRhcmRBcnJheU11dGF0b3JzKGFycmF5SW5zdGFuY2UsIHN1YnNjcmliYWJsZSwgbm90aWZpY2F0aW9uUGF1c2VTaWduYWwpO1xuICAgICAgICAgICAgYWRkS25vY2tvdXRBcnJheU11dGF0b3JzKGtvLCBhcnJheUluc3RhbmNlLCBzdWJzY3JpYmFibGUsIG5vdGlmaWNhdGlvblBhdXNlU2lnbmFsKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBzdWJzY3JpYmFibGU7XG4gICAgfVxuXG4gICAgLy8gQWZ0ZXIgZWFjaCBhcnJheSBtdXRhdGlvbiwgZmlyZXMgYSBub3RpZmljYXRpb24gb24gdGhlIGdpdmVuIHN1YnNjcmliYWJsZVxuICAgIGZ1bmN0aW9uIHdyYXBTdGFuZGFyZEFycmF5TXV0YXRvcnMoYXJyYXlJbnN0YW5jZSwgc3Vic2NyaWJhYmxlLCBub3RpZmljYXRpb25QYXVzZVNpZ25hbCkge1xuICAgICAgICBbJ3BvcCcsICdwdXNoJywgJ3JldmVyc2UnLCAnc2hpZnQnLCAnc29ydCcsICdzcGxpY2UnLCAndW5zaGlmdCddLmZvckVhY2goZnVuY3Rpb24oZm5OYW1lKSB7XG4gICAgICAgICAgICB2YXIgb3JpZ011dGF0b3IgPSBhcnJheUluc3RhbmNlW2ZuTmFtZV07XG4gICAgICAgICAgICBhcnJheUluc3RhbmNlW2ZuTmFtZV0gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICB2YXIgcmVzdWx0ID0gb3JpZ011dGF0b3IuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgICAgICAgICBpZiAobm90aWZpY2F0aW9uUGF1c2VTaWduYWwucGF1c2UgIT09IHRydWUpIHtcbiAgICAgICAgICAgICAgICAgICAgc3Vic2NyaWJhYmxlLm5vdGlmeVN1YnNjcmliZXJzKHRoaXMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgLy8gQWRkcyBLbm9ja291dCdzIGFkZGl0aW9uYWwgYXJyYXkgbXV0YXRpb24gZnVuY3Rpb25zIHRvIHRoZSBhcnJheVxuICAgIGZ1bmN0aW9uIGFkZEtub2Nrb3V0QXJyYXlNdXRhdG9ycyhrbywgYXJyYXlJbnN0YW5jZSwgc3Vic2NyaWJhYmxlLCBub3RpZmljYXRpb25QYXVzZVNpZ25hbCkge1xuICAgICAgICBbJ3JlbW92ZScsICdyZW1vdmVBbGwnLCAnZGVzdHJveScsICdkZXN0cm95QWxsJywgJ3JlcGxhY2UnXS5mb3JFYWNoKGZ1bmN0aW9uKGZuTmFtZSkge1xuICAgICAgICAgICAgLy8gTWFrZSBpdCBhIG5vbi1lbnVtZXJhYmxlIHByb3BlcnR5IGZvciBjb25zaXN0ZW5jeSB3aXRoIHN0YW5kYXJkIEFycmF5IGZ1bmN0aW9uc1xuICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGFycmF5SW5zdGFuY2UsIGZuTmFtZSwge1xuICAgICAgICAgICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHJlc3VsdDtcblxuICAgICAgICAgICAgICAgICAgICAvLyBUaGVzZSBhZGRpdGlvbmFsIGFycmF5IG11dGF0b3JzIGFyZSBidWlsdCB1c2luZyB0aGUgdW5kZXJseWluZyBwdXNoL3BvcC9ldGMuXG4gICAgICAgICAgICAgICAgICAgIC8vIG11dGF0b3JzLCB3aGljaCBhcmUgd3JhcHBlZCB0byB0cmlnZ2VyIG5vdGlmaWNhdGlvbnMuIEJ1dCB3ZSBkb24ndCB3YW50IHRvXG4gICAgICAgICAgICAgICAgICAgIC8vIHRyaWdnZXIgbXVsdGlwbGUgbm90aWZpY2F0aW9ucywgc28gcGF1c2UgdGhlIHB1c2gvcG9wL2V0Yy4gd3JhcHBlcnMgYW5kXG4gICAgICAgICAgICAgICAgICAgIC8vIGRlbGl2ZXJ5IG9ubHkgb25lIG5vdGlmaWNhdGlvbiBhdCB0aGUgZW5kIG9mIHRoZSBwcm9jZXNzLlxuICAgICAgICAgICAgICAgICAgICBub3RpZmljYXRpb25QYXVzZVNpZ25hbC5wYXVzZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBDcmVhdGVzIGEgdGVtcG9yYXJ5IG9ic2VydmFibGVBcnJheSB0aGF0IGNhbiBwZXJmb3JtIHRoZSBvcGVyYXRpb24uXG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSBrby5vYnNlcnZhYmxlQXJyYXkuZm5bZm5OYW1lXS5hcHBseShrby5vYnNlcnZhYmxlQXJyYXkoYXJyYXlJbnN0YW5jZSksIGFyZ3VtZW50cyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBub3RpZmljYXRpb25QYXVzZVNpZ25hbC5wYXVzZSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHN1YnNjcmliYWJsZS5ub3RpZnlTdWJzY3JpYmVycyhhcnJheUluc3RhbmNlKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgLy8gU3RhdGljIHV0aWxpdHkgZnVuY3Rpb25zXG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgLy9cbiAgICAvLyBTaW5jZSBLbm9ja291dC1FUzUgc2V0cyB1cCBwcm9wZXJ0aWVzIHRoYXQgcmV0dXJuIHZhbHVlcywgbm90IG9ic2VydmFibGVzLCB5b3UgY2FuJ3RcbiAgICAvLyB0cml2aWFsbHkgc3Vic2NyaWJlIHRvIHRoZSB1bmRlcmx5aW5nIG9ic2VydmFibGVzIChlLmcuLCBgc29tZVByb3BlcnR5LnN1YnNjcmliZSguLi4pYCksXG4gICAgLy8gb3IgdGVsbCB0aGVtIHRoYXQgb2JqZWN0IHZhbHVlcyBoYXZlIG11dGF0ZWQsIGV0Yy4gVG8gaGFuZGxlIHRoaXMsIHdlIHNldCB1cCBzb21lXG4gICAgLy8gZXh0cmEgdXRpbGl0eSBmdW5jdGlvbnMgdGhhdCBjYW4gcmV0dXJuIG9yIHdvcmsgd2l0aCB0aGUgdW5kZXJseWluZyBvYnNlcnZhYmxlcy5cblxuICAgIC8vIFJldHVybnMgdGhlIHVuZGVybHlpbmcgb2JzZXJ2YWJsZSBhc3NvY2lhdGVkIHdpdGggYSBtb2RlbCBwcm9wZXJ0eSAob3IgYG51bGxgIGlmIHRoZVxuICAgIC8vIG1vZGVsIG9yIHByb3BlcnR5IGRvZXNuJ3QgZXhpc3QsIG9yIGlzbid0IGFzc29jaWF0ZWQgd2l0aCBhbiBvYnNlcnZhYmxlKS4gVGhpcyBtZWFuc1xuICAgIC8vIHlvdSBjYW4gc3Vic2NyaWJlIHRvIHRoZSBwcm9wZXJ0eSwgZS5nLjpcbiAgICAvL1xuICAgIC8vICAgICBrby5nZXRPYnNlcnZhYmxlKG1vZGVsLCAncHJvcGVydHlOYW1lJylcbiAgICAvLyAgICAgICAuc3Vic2NyaWJlKGZ1bmN0aW9uKG5ld1ZhbHVlKSB7IC4uLiB9KTtcbiAgICBmdW5jdGlvbiBnZXRPYnNlcnZhYmxlKG9iaiwgcHJvcGVydHlOYW1lKSB7XG4gICAgICAgIGlmICghb2JqIC8qfHwgdHlwZW9mIG9iaiAhPT0gJ29iamVjdCcqLykge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgYWxsT2JzZXJ2YWJsZXNGb3JPYmplY3QgPSBnZXRBbGxPYnNlcnZhYmxlc0Zvck9iamVjdChvYmosIGZhbHNlKTtcbiAgICAgICAgcmV0dXJuIChhbGxPYnNlcnZhYmxlc0Zvck9iamVjdCAmJiBhbGxPYnNlcnZhYmxlc0Zvck9iamVjdFtwcm9wZXJ0eU5hbWVdKSB8fCBudWxsO1xuICAgIH1cblxuICAgIC8vIENhdXNlcyBhIHByb3BlcnR5J3MgYXNzb2NpYXRlZCBvYnNlcnZhYmxlIHRvIGZpcmUgYSBjaGFuZ2Ugbm90aWZpY2F0aW9uLiBVc2VmdWwgd2hlblxuICAgIC8vIHRoZSBwcm9wZXJ0eSB2YWx1ZSBpcyBhIGNvbXBsZXggb2JqZWN0IGFuZCB5b3UndmUgbW9kaWZpZWQgYSBjaGlsZCBwcm9wZXJ0eS5cbiAgICBmdW5jdGlvbiB2YWx1ZUhhc011dGF0ZWQob2JqLCBwcm9wZXJ0eU5hbWUpIHtcbiAgICAgICAgdmFyIG9ic2VydmFibGUgPSBnZXRPYnNlcnZhYmxlKG9iaiwgcHJvcGVydHlOYW1lKTtcblxuICAgICAgICBpZiAob2JzZXJ2YWJsZSkge1xuICAgICAgICAgICAgb2JzZXJ2YWJsZS52YWx1ZUhhc011dGF0ZWQoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIEV4dGVuZHMgYSBLbm9ja291dCBpbnN0YW5jZSB3aXRoIEtub2Nrb3V0LUVTNSBmdW5jdGlvbmFsaXR5XG4gICAgZnVuY3Rpb24gYXR0YWNoVG9Lbyhrbykge1xuICAgICAgICBrby50cmFjayA9IHRyYWNrO1xuICAgICAgICBrby5nZXRPYnNlcnZhYmxlID0gZ2V0T2JzZXJ2YWJsZTtcbiAgICAgICAga28udmFsdWVIYXNNdXRhdGVkID0gdmFsdWVIYXNNdXRhdGVkO1xuICAgICAgICBrby5kZWZpbmVQcm9wZXJ0eSA9IGRlZmluZUNvbXB1dGVkUHJvcGVydHk7XG4gICAgfVxuXG4gICAgZXhwb3J0IGRlZmF1bHQge1xuICAgICAgICBhdHRhY2hUb0tvIDogYXR0YWNoVG9Lb1xuICAgIH07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///11397\n")},53454:function(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__){eval('/* harmony import */ var _knockout_3_5_1_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(67391);\n/* harmony import */ var _knockout_es5_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(11397);\n/* harmony import */ var _Widgets_SvgPathBindingHandler_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(32082);\n\n\n\n\n// install the Knockout-ES5 plugin\n_knockout_es5_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"].attachToKo */ .Z.attachToKo(_knockout_3_5_1_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .Z);\n\n// Register all Cesium binding handlers\n_Widgets_SvgPathBindingHandler_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"].register */ .Z.register(_knockout_3_5_1_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .Z);\n\n/* harmony default export */ __webpack_exports__["Z"] = (_knockout_3_5_1_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .Z);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNTM0NTQuanMiLCJtYXBwaW5ncyI6Ijs7O0FBQTJDO0FBQ0U7QUFDMkI7O0FBRXhFO0FBQ0EsdUZBQXVCLENBQUMsbUVBQVE7O0FBRWhDO0FBQ0Esb0dBQThCLENBQUMsbUVBQVE7O0FBRXZDLHlEQUFlLG1FQUFRLEVBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly92dWUzLXdlYnBhY2s1Ly4vbm9kZV9tb2R1bGVzL2Nlc2l1bS9Tb3VyY2UvVGhpcmRQYXJ0eS9rbm9ja291dC5qcz9hNzU1Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBrbm9ja291dCBmcm9tICcuL2tub2Nrb3V0LTMuNS4xLmpzJztcbmltcG9ydCBrbm9ja291dF9lczUgZnJvbSAnLi9rbm9ja291dC1lczUuanMnO1xuaW1wb3J0IFN2Z1BhdGhCaW5kaW5nSGFuZGxlciBmcm9tICcuLi9XaWRnZXRzL1N2Z1BhdGhCaW5kaW5nSGFuZGxlci5qcyc7XG5cbi8vIGluc3RhbGwgdGhlIEtub2Nrb3V0LUVTNSBwbHVnaW5cbmtub2Nrb3V0X2VzNS5hdHRhY2hUb0tvKGtub2Nrb3V0KTtcblxuLy8gUmVnaXN0ZXIgYWxsIENlc2l1bSBiaW5kaW5nIGhhbmRsZXJzXG5TdmdQYXRoQmluZGluZ0hhbmRsZXIucmVnaXN0ZXIoa25vY2tvdXQpO1xuXG5leHBvcnQgZGVmYXVsdCBrbm9ja291dDtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///53454\n')},13332:function(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__){eval('/* unused harmony export default */\n/* This file is automatically rebuilt by the Cesium build process. */\nconst e=(/* unused pure expression or super */ null && ([171,75,84,88,32,50,48,187,13,10,26,10]));var n,i,s,a,r,o,l,f;!function(t){t[t.NONE=0]="NONE",t[t.BASISLZ=1]="BASISLZ",t[t.ZSTD=2]="ZSTD",t[t.ZLIB=3]="ZLIB";}(n||(n={})),function(t){t[t.BASICFORMAT=0]="BASICFORMAT";}(i||(i={})),function(t){t[t.UNSPECIFIED=0]="UNSPECIFIED",t[t.ETC1S=163]="ETC1S",t[t.UASTC=166]="UASTC";}(s||(s={})),function(t){t[t.UNSPECIFIED=0]="UNSPECIFIED",t[t.SRGB=1]="SRGB";}(a||(a={})),function(t){t[t.UNSPECIFIED=0]="UNSPECIFIED",t[t.LINEAR=1]="LINEAR",t[t.SRGB=2]="SRGB",t[t.ITU=3]="ITU",t[t.NTSC=4]="NTSC",t[t.SLOG=5]="SLOG",t[t.SLOG2=6]="SLOG2";}(r||(r={})),function(t){t[t.ALPHA_STRAIGHT=0]="ALPHA_STRAIGHT",t[t.ALPHA_PREMULTIPLIED=1]="ALPHA_PREMULTIPLIED";}(o||(o={})),function(t){t[t.RGB=0]="RGB",t[t.RRR=3]="RRR",t[t.GGG=4]="GGG",t[t.AAA=15]="AAA";}(l||(l={})),function(t){t[t.RGB=0]="RGB",t[t.RGBA=3]="RGBA",t[t.RRR=4]="RRR",t[t.RRRG=5]="RRRG";}(f||(f={}));class U{constructor(){this.vkFormat=0,this.typeSize=1,this.pixelWidth=0,this.pixelHeight=0,this.pixelDepth=0,this.layerCount=0,this.faceCount=1,this.supercompressionScheme=n.NONE,this.levels=[],this.dataFormatDescriptor=[{vendorId:0,descriptorType:i.BASICFORMAT,versionNumber:2,descriptorBlockSize:40,colorModel:s.UNSPECIFIED,colorPrimaries:a.SRGB,transferFunction:a.SRGB,flags:o.ALPHA_STRAIGHT,texelBlockDimension:{x:4,y:4,z:1,w:1},bytesPlane:[],samples:[]}],this.keyValue={},this.globalData=null;}}class c{constructor(t,e,n,i){this._dataView=new DataView(t.buffer,t.byteOffset+e,n),this._littleEndian=i,this._offset=0;}_nextUint8(){const t=this._dataView.getUint8(this._offset);return this._offset+=1,t}_nextUint16(){const t=this._dataView.getUint16(this._offset,this._littleEndian);return this._offset+=2,t}_nextUint32(){const t=this._dataView.getUint32(this._offset,this._littleEndian);return this._offset+=4,t}_nextUint64(){const t=this._dataView.getUint32(this._offset,this._littleEndian)+2**32*this._dataView.getUint32(this._offset+4,this._littleEndian);return this._offset+=8,t}_skip(t){return this._offset+=t,this}_scan(t,e=0){const n=this._offset;let i=0;for(;this._dataView.getUint8(this._offset)!==e&&i<t;)i++,this._offset++;return i<t&&this._offset++,new Uint8Array(this._dataView.buffer,this._dataView.byteOffset+n,i)}}function _(t){return "undefined"!=typeof TextDecoder?(new TextDecoder).decode(t):Buffer.from(t).toString("utf8")}function p(t){const n=new Uint8Array(t.buffer,t.byteOffset,e.length);if(n[0]!==e[0]||n[1]!==e[1]||n[2]!==e[2]||n[3]!==e[3]||n[4]!==e[4]||n[5]!==e[5]||n[6]!==e[6]||n[7]!==e[7]||n[8]!==e[8]||n[9]!==e[9]||n[10]!==e[10]||n[11]!==e[11])throw new Error("Missing KTX 2.0 identifier.");const i=new U,s=17*Uint32Array.BYTES_PER_ELEMENT,a=new c(t,e.length,s,!0);i.vkFormat=a._nextUint32(),i.typeSize=a._nextUint32(),i.pixelWidth=a._nextUint32(),i.pixelHeight=a._nextUint32(),i.pixelDepth=a._nextUint32(),i.layerCount=a._nextUint32(),i.faceCount=a._nextUint32();const r=a._nextUint32();i.supercompressionScheme=a._nextUint32();const o=a._nextUint32(),l=a._nextUint32(),f=a._nextUint32(),h=a._nextUint32(),g=a._nextUint64(),p=a._nextUint64(),x=new c(t,e.length+s,3*r*8,!0);for(let e=0;e<r;e++)i.levels.push({levelData:new Uint8Array(t.buffer,t.byteOffset+x._nextUint64(),x._nextUint64()),uncompressedByteLength:x._nextUint64()});const u=new c(t,o,l,!0),y={vendorId:u._skip(4)._nextUint16(),descriptorType:u._nextUint16(),versionNumber:u._nextUint16(),descriptorBlockSize:u._nextUint16(),colorModel:u._nextUint8(),colorPrimaries:u._nextUint8(),transferFunction:u._nextUint8(),flags:u._nextUint8(),texelBlockDimension:{x:u._nextUint8()+1,y:u._nextUint8()+1,z:u._nextUint8()+1,w:u._nextUint8()+1},bytesPlane:[u._nextUint8(),u._nextUint8(),u._nextUint8(),u._nextUint8(),u._nextUint8(),u._nextUint8(),u._nextUint8(),u._nextUint8()],samples:[]},D=(y.descriptorBlockSize/4-6)/4;for(let t=0;t<D;t++)y.samples[t]={bitOffset:u._nextUint16(),bitLength:u._nextUint8(),channelID:u._nextUint8(),samplePosition:[u._nextUint8(),u._nextUint8(),u._nextUint8(),u._nextUint8()],sampleLower:u._nextUint32(),sampleUpper:u._nextUint32()};i.dataFormatDescriptor.length=0,i.dataFormatDescriptor.push(y);const b=new c(t,f,h,!0);for(;b._offset<h;){const t=b._nextUint32(),e=b._scan(t),n=_(e),s=b._scan(t-e.byteLength);i.keyValue[n]=n.match(/^ktx/i)?_(s):s,b._offset%4&&b._skip(4-b._offset%4);}if(p<=0)return i;const d=new c(t,g,p,!0),B=d._nextUint16(),w=d._nextUint16(),A=d._nextUint32(),S=d._nextUint32(),m=d._nextUint32(),L=d._nextUint32(),I=[];for(let t=0;t<r;t++)I.push({imageFlags:d._nextUint32(),rgbSliceByteOffset:d._nextUint32(),rgbSliceByteLength:d._nextUint32(),alphaSliceByteOffset:d._nextUint32(),alphaSliceByteLength:d._nextUint32()});const R=g+d._offset,E=R+A,T=E+S,O=T+m,P=new Uint8Array(t.buffer,t.byteOffset+R,A),C=new Uint8Array(t.buffer,t.byteOffset+E,S),F=new Uint8Array(t.buffer,t.byteOffset+T,m),G=new Uint8Array(t.buffer,t.byteOffset+O,L);return i.globalData={endpointCount:B,selectorCount:w,imageDescs:I,endpointsData:P,selectorsData:C,tablesData:F,extendedData:G},i}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTMzMzIuanMiLCJtYXBwaW5ncyI6IjtBQUFBO0FBQ0EsUUFBUSx1RkFBdUMsR0FBQyxvQkFBb0IsYUFBYSxtRkFBbUYsU0FBUyxlQUFlLGtDQUFrQyxTQUFTLGVBQWUsZ0ZBQWdGLFNBQVMsZUFBZSxxREFBcUQsU0FBUyxlQUFlLHdKQUF3SixTQUFTLGVBQWUseUZBQXlGLFNBQVMsZUFBZSxzRUFBc0UsU0FBUyxlQUFlLHlFQUF5RSxTQUFTLEdBQUcsUUFBUSxjQUFjLHdNQUF3TSxrTUFBa00sZ0JBQWdCLDBCQUEwQixrQkFBa0Isd0JBQXdCLFFBQVEscUJBQXFCLDRGQUE0RixhQUFhLDhDQUE4Qyx5QkFBeUIsY0FBYyxrRUFBa0UseUJBQXlCLGNBQWMsa0VBQWtFLHlCQUF5QixjQUFjLG9JQUFvSSx5QkFBeUIsU0FBUyw0QkFBNEIsYUFBYSxxQkFBcUIsUUFBUSxLQUFLLCtDQUErQyxvQkFBb0IsZ0dBQWdHLGNBQWMsbUdBQW1HLGNBQWMsdURBQXVELGlOQUFpTiwwRUFBMEUsdU1BQXVNLHdCQUF3Qix5Q0FBeUMsaUpBQWlKLFlBQVksSUFBSSxtQkFBbUIsdUhBQXVILEVBQUUsMkJBQTJCLHFRQUFxUSw0RUFBNEUsaUpBQWlKLGlDQUFpQyxZQUFZLElBQUksa0JBQWtCLGtOQUFrTiwrREFBK0Qsd0JBQXdCLEtBQUssWUFBWSxFQUFFLHNFQUFzRSwyRUFBMkUsaUJBQWlCLHlJQUF5SSxZQUFZLElBQUksWUFBWSwyS0FBMkssRUFBRSxzTkFBc04scUJBQXFCLHlHQUF5Rzs7QUFFdDJKIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdnVlMy13ZWJwYWNrNS8uL25vZGVfbW9kdWxlcy9jZXNpdW0vU291cmNlL1RoaXJkUGFydHkva3R4LXBhcnNlLmpzPzIxZDQiXSwic291cmNlc0NvbnRlbnQiOlsiLyogVGhpcyBmaWxlIGlzIGF1dG9tYXRpY2FsbHkgcmVidWlsdCBieSB0aGUgQ2VzaXVtIGJ1aWxkIHByb2Nlc3MuICovXG5jb25zdCBlPVsxNzEsNzUsODQsODgsMzIsNTAsNDgsMTg3LDEzLDEwLDI2LDEwXTt2YXIgbixpLHMsYSxyLG8sbCxmOyFmdW5jdGlvbih0KXt0W3QuTk9ORT0wXT1cIk5PTkVcIix0W3QuQkFTSVNMWj0xXT1cIkJBU0lTTFpcIix0W3QuWlNURD0yXT1cIlpTVERcIix0W3QuWkxJQj0zXT1cIlpMSUJcIjt9KG58fChuPXt9KSksZnVuY3Rpb24odCl7dFt0LkJBU0lDRk9STUFUPTBdPVwiQkFTSUNGT1JNQVRcIjt9KGl8fChpPXt9KSksZnVuY3Rpb24odCl7dFt0LlVOU1BFQ0lGSUVEPTBdPVwiVU5TUEVDSUZJRURcIix0W3QuRVRDMVM9MTYzXT1cIkVUQzFTXCIsdFt0LlVBU1RDPTE2Nl09XCJVQVNUQ1wiO30oc3x8KHM9e30pKSxmdW5jdGlvbih0KXt0W3QuVU5TUEVDSUZJRUQ9MF09XCJVTlNQRUNJRklFRFwiLHRbdC5TUkdCPTFdPVwiU1JHQlwiO30oYXx8KGE9e30pKSxmdW5jdGlvbih0KXt0W3QuVU5TUEVDSUZJRUQ9MF09XCJVTlNQRUNJRklFRFwiLHRbdC5MSU5FQVI9MV09XCJMSU5FQVJcIix0W3QuU1JHQj0yXT1cIlNSR0JcIix0W3QuSVRVPTNdPVwiSVRVXCIsdFt0Lk5UU0M9NF09XCJOVFNDXCIsdFt0LlNMT0c9NV09XCJTTE9HXCIsdFt0LlNMT0cyPTZdPVwiU0xPRzJcIjt9KHJ8fChyPXt9KSksZnVuY3Rpb24odCl7dFt0LkFMUEhBX1NUUkFJR0hUPTBdPVwiQUxQSEFfU1RSQUlHSFRcIix0W3QuQUxQSEFfUFJFTVVMVElQTElFRD0xXT1cIkFMUEhBX1BSRU1VTFRJUExJRURcIjt9KG98fChvPXt9KSksZnVuY3Rpb24odCl7dFt0LlJHQj0wXT1cIlJHQlwiLHRbdC5SUlI9M109XCJSUlJcIix0W3QuR0dHPTRdPVwiR0dHXCIsdFt0LkFBQT0xNV09XCJBQUFcIjt9KGx8fChsPXt9KSksZnVuY3Rpb24odCl7dFt0LlJHQj0wXT1cIlJHQlwiLHRbdC5SR0JBPTNdPVwiUkdCQVwiLHRbdC5SUlI9NF09XCJSUlJcIix0W3QuUlJSRz01XT1cIlJSUkdcIjt9KGZ8fChmPXt9KSk7Y2xhc3MgVXtjb25zdHJ1Y3Rvcigpe3RoaXMudmtGb3JtYXQ9MCx0aGlzLnR5cGVTaXplPTEsdGhpcy5waXhlbFdpZHRoPTAsdGhpcy5waXhlbEhlaWdodD0wLHRoaXMucGl4ZWxEZXB0aD0wLHRoaXMubGF5ZXJDb3VudD0wLHRoaXMuZmFjZUNvdW50PTEsdGhpcy5zdXBlcmNvbXByZXNzaW9uU2NoZW1lPW4uTk9ORSx0aGlzLmxldmVscz1bXSx0aGlzLmRhdGFGb3JtYXREZXNjcmlwdG9yPVt7dmVuZG9ySWQ6MCxkZXNjcmlwdG9yVHlwZTppLkJBU0lDRk9STUFULHZlcnNpb25OdW1iZXI6MixkZXNjcmlwdG9yQmxvY2tTaXplOjQwLGNvbG9yTW9kZWw6cy5VTlNQRUNJRklFRCxjb2xvclByaW1hcmllczphLlNSR0IsdHJhbnNmZXJGdW5jdGlvbjphLlNSR0IsZmxhZ3M6by5BTFBIQV9TVFJBSUdIVCx0ZXhlbEJsb2NrRGltZW5zaW9uOnt4OjQseTo0LHo6MSx3OjF9LGJ5dGVzUGxhbmU6W10sc2FtcGxlczpbXX1dLHRoaXMua2V5VmFsdWU9e30sdGhpcy5nbG9iYWxEYXRhPW51bGw7fX1jbGFzcyBje2NvbnN0cnVjdG9yKHQsZSxuLGkpe3RoaXMuX2RhdGFWaWV3PW5ldyBEYXRhVmlldyh0LmJ1ZmZlcix0LmJ5dGVPZmZzZXQrZSxuKSx0aGlzLl9saXR0bGVFbmRpYW49aSx0aGlzLl9vZmZzZXQ9MDt9X25leHRVaW50OCgpe2NvbnN0IHQ9dGhpcy5fZGF0YVZpZXcuZ2V0VWludDgodGhpcy5fb2Zmc2V0KTtyZXR1cm4gdGhpcy5fb2Zmc2V0Kz0xLHR9X25leHRVaW50MTYoKXtjb25zdCB0PXRoaXMuX2RhdGFWaWV3LmdldFVpbnQxNih0aGlzLl9vZmZzZXQsdGhpcy5fbGl0dGxlRW5kaWFuKTtyZXR1cm4gdGhpcy5fb2Zmc2V0Kz0yLHR9X25leHRVaW50MzIoKXtjb25zdCB0PXRoaXMuX2RhdGFWaWV3LmdldFVpbnQzMih0aGlzLl9vZmZzZXQsdGhpcy5fbGl0dGxlRW5kaWFuKTtyZXR1cm4gdGhpcy5fb2Zmc2V0Kz00LHR9X25leHRVaW50NjQoKXtjb25zdCB0PXRoaXMuX2RhdGFWaWV3LmdldFVpbnQzMih0aGlzLl9vZmZzZXQsdGhpcy5fbGl0dGxlRW5kaWFuKSsyKiozMip0aGlzLl9kYXRhVmlldy5nZXRVaW50MzIodGhpcy5fb2Zmc2V0KzQsdGhpcy5fbGl0dGxlRW5kaWFuKTtyZXR1cm4gdGhpcy5fb2Zmc2V0Kz04LHR9X3NraXAodCl7cmV0dXJuIHRoaXMuX29mZnNldCs9dCx0aGlzfV9zY2FuKHQsZT0wKXtjb25zdCBuPXRoaXMuX29mZnNldDtsZXQgaT0wO2Zvcig7dGhpcy5fZGF0YVZpZXcuZ2V0VWludDgodGhpcy5fb2Zmc2V0KSE9PWUmJmk8dDspaSsrLHRoaXMuX29mZnNldCsrO3JldHVybiBpPHQmJnRoaXMuX29mZnNldCsrLG5ldyBVaW50OEFycmF5KHRoaXMuX2RhdGFWaWV3LmJ1ZmZlcix0aGlzLl9kYXRhVmlldy5ieXRlT2Zmc2V0K24saSl9fWZ1bmN0aW9uIF8odCl7cmV0dXJuIFwidW5kZWZpbmVkXCIhPXR5cGVvZiBUZXh0RGVjb2Rlcj8obmV3IFRleHREZWNvZGVyKS5kZWNvZGUodCk6QnVmZmVyLmZyb20odCkudG9TdHJpbmcoXCJ1dGY4XCIpfWZ1bmN0aW9uIHAodCl7Y29uc3Qgbj1uZXcgVWludDhBcnJheSh0LmJ1ZmZlcix0LmJ5dGVPZmZzZXQsZS5sZW5ndGgpO2lmKG5bMF0hPT1lWzBdfHxuWzFdIT09ZVsxXXx8blsyXSE9PWVbMl18fG5bM10hPT1lWzNdfHxuWzRdIT09ZVs0XXx8bls1XSE9PWVbNV18fG5bNl0hPT1lWzZdfHxuWzddIT09ZVs3XXx8bls4XSE9PWVbOF18fG5bOV0hPT1lWzldfHxuWzEwXSE9PWVbMTBdfHxuWzExXSE9PWVbMTFdKXRocm93IG5ldyBFcnJvcihcIk1pc3NpbmcgS1RYIDIuMCBpZGVudGlmaWVyLlwiKTtjb25zdCBpPW5ldyBVLHM9MTcqVWludDMyQXJyYXkuQllURVNfUEVSX0VMRU1FTlQsYT1uZXcgYyh0LGUubGVuZ3RoLHMsITApO2kudmtGb3JtYXQ9YS5fbmV4dFVpbnQzMigpLGkudHlwZVNpemU9YS5fbmV4dFVpbnQzMigpLGkucGl4ZWxXaWR0aD1hLl9uZXh0VWludDMyKCksaS5waXhlbEhlaWdodD1hLl9uZXh0VWludDMyKCksaS5waXhlbERlcHRoPWEuX25leHRVaW50MzIoKSxpLmxheWVyQ291bnQ9YS5fbmV4dFVpbnQzMigpLGkuZmFjZUNvdW50PWEuX25leHRVaW50MzIoKTtjb25zdCByPWEuX25leHRVaW50MzIoKTtpLnN1cGVyY29tcHJlc3Npb25TY2hlbWU9YS5fbmV4dFVpbnQzMigpO2NvbnN0IG89YS5fbmV4dFVpbnQzMigpLGw9YS5fbmV4dFVpbnQzMigpLGY9YS5fbmV4dFVpbnQzMigpLGg9YS5fbmV4dFVpbnQzMigpLGc9YS5fbmV4dFVpbnQ2NCgpLHA9YS5fbmV4dFVpbnQ2NCgpLHg9bmV3IGModCxlLmxlbmd0aCtzLDMqcio4LCEwKTtmb3IobGV0IGU9MDtlPHI7ZSsrKWkubGV2ZWxzLnB1c2goe2xldmVsRGF0YTpuZXcgVWludDhBcnJheSh0LmJ1ZmZlcix0LmJ5dGVPZmZzZXQreC5fbmV4dFVpbnQ2NCgpLHguX25leHRVaW50NjQoKSksdW5jb21wcmVzc2VkQnl0ZUxlbmd0aDp4Ll9uZXh0VWludDY0KCl9KTtjb25zdCB1PW5ldyBjKHQsbyxsLCEwKSx5PXt2ZW5kb3JJZDp1Ll9za2lwKDQpLl9uZXh0VWludDE2KCksZGVzY3JpcHRvclR5cGU6dS5fbmV4dFVpbnQxNigpLHZlcnNpb25OdW1iZXI6dS5fbmV4dFVpbnQxNigpLGRlc2NyaXB0b3JCbG9ja1NpemU6dS5fbmV4dFVpbnQxNigpLGNvbG9yTW9kZWw6dS5fbmV4dFVpbnQ4KCksY29sb3JQcmltYXJpZXM6dS5fbmV4dFVpbnQ4KCksdHJhbnNmZXJGdW5jdGlvbjp1Ll9uZXh0VWludDgoKSxmbGFnczp1Ll9uZXh0VWludDgoKSx0ZXhlbEJsb2NrRGltZW5zaW9uOnt4OnUuX25leHRVaW50OCgpKzEseTp1Ll9uZXh0VWludDgoKSsxLHo6dS5fbmV4dFVpbnQ4KCkrMSx3OnUuX25leHRVaW50OCgpKzF9LGJ5dGVzUGxhbmU6W3UuX25leHRVaW50OCgpLHUuX25leHRVaW50OCgpLHUuX25leHRVaW50OCgpLHUuX25leHRVaW50OCgpLHUuX25leHRVaW50OCgpLHUuX25leHRVaW50OCgpLHUuX25leHRVaW50OCgpLHUuX25leHRVaW50OCgpXSxzYW1wbGVzOltdfSxEPSh5LmRlc2NyaXB0b3JCbG9ja1NpemUvNC02KS80O2ZvcihsZXQgdD0wO3Q8RDt0KyspeS5zYW1wbGVzW3RdPXtiaXRPZmZzZXQ6dS5fbmV4dFVpbnQxNigpLGJpdExlbmd0aDp1Ll9uZXh0VWludDgoKSxjaGFubmVsSUQ6dS5fbmV4dFVpbnQ4KCksc2FtcGxlUG9zaXRpb246W3UuX25leHRVaW50OCgpLHUuX25leHRVaW50OCgpLHUuX25leHRVaW50OCgpLHUuX25leHRVaW50OCgpXSxzYW1wbGVMb3dlcjp1Ll9uZXh0VWludDMyKCksc2FtcGxlVXBwZXI6dS5fbmV4dFVpbnQzMigpfTtpLmRhdGFGb3JtYXREZXNjcmlwdG9yLmxlbmd0aD0wLGkuZGF0YUZvcm1hdERlc2NyaXB0b3IucHVzaCh5KTtjb25zdCBiPW5ldyBjKHQsZixoLCEwKTtmb3IoO2IuX29mZnNldDxoOyl7Y29uc3QgdD1iLl9uZXh0VWludDMyKCksZT1iLl9zY2FuKHQpLG49XyhlKSxzPWIuX3NjYW4odC1lLmJ5dGVMZW5ndGgpO2kua2V5VmFsdWVbbl09bi5tYXRjaCgvXmt0eC9pKT9fKHMpOnMsYi5fb2Zmc2V0JTQmJmIuX3NraXAoNC1iLl9vZmZzZXQlNCk7fWlmKHA8PTApcmV0dXJuIGk7Y29uc3QgZD1uZXcgYyh0LGcscCwhMCksQj1kLl9uZXh0VWludDE2KCksdz1kLl9uZXh0VWludDE2KCksQT1kLl9uZXh0VWludDMyKCksUz1kLl9uZXh0VWludDMyKCksbT1kLl9uZXh0VWludDMyKCksTD1kLl9uZXh0VWludDMyKCksST1bXTtmb3IobGV0IHQ9MDt0PHI7dCsrKUkucHVzaCh7aW1hZ2VGbGFnczpkLl9uZXh0VWludDMyKCkscmdiU2xpY2VCeXRlT2Zmc2V0OmQuX25leHRVaW50MzIoKSxyZ2JTbGljZUJ5dGVMZW5ndGg6ZC5fbmV4dFVpbnQzMigpLGFscGhhU2xpY2VCeXRlT2Zmc2V0OmQuX25leHRVaW50MzIoKSxhbHBoYVNsaWNlQnl0ZUxlbmd0aDpkLl9uZXh0VWludDMyKCl9KTtjb25zdCBSPWcrZC5fb2Zmc2V0LEU9UitBLFQ9RStTLE89VCttLFA9bmV3IFVpbnQ4QXJyYXkodC5idWZmZXIsdC5ieXRlT2Zmc2V0K1IsQSksQz1uZXcgVWludDhBcnJheSh0LmJ1ZmZlcix0LmJ5dGVPZmZzZXQrRSxTKSxGPW5ldyBVaW50OEFycmF5KHQuYnVmZmVyLHQuYnl0ZU9mZnNldCtULG0pLEc9bmV3IFVpbnQ4QXJyYXkodC5idWZmZXIsdC5ieXRlT2Zmc2V0K08sTCk7cmV0dXJuIGkuZ2xvYmFsRGF0YT17ZW5kcG9pbnRDb3VudDpCLHNlbGVjdG9yQ291bnQ6dyxpbWFnZURlc2NzOkksZW5kcG9pbnRzRGF0YTpQLHNlbGVjdG9yc0RhdGE6Qyx0YWJsZXNEYXRhOkYsZXh0ZW5kZWREYXRhOkd9LGl9XG5cbmV4cG9ydCB7IHAgYXMgZGVmYXVsdCB9O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///13332\n')},40212:function(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__){eval('/* unused harmony export default */\n/* harmony import */ var _commonjsHelpers_3aae1032_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(22549);\n/* This file is automatically rebuilt by the Cesium build process. */\n\n\nvar LercDecode = (0,_commonjsHelpers_3aae1032_js__WEBPACK_IMPORTED_MODULE_0__.c)(function (module) {\n/* jshint forin: false, bitwise: false */\n/*\nCopyright 2015-2018 Esri\n\nLicensed under the Apache License, Version 2.0 (the "License");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\nhttp://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an "AS IS" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n\nA copy of the license and additional notices are located with the\nsource distribution at:\n\nhttp://github.com/Esri/lerc/\n\nContributors:  Johannes Schmid, (LERC v1)\n               Chayanika Khatua, (LERC v1)\n               Wenxue Ju (LERC v1, v2.x)\n*/\n\n/* Copyright 2015-2018 Esri. Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0 @preserve */\n\n/**\n * a module for decoding LERC blobs\n * @module Lerc\n */\n(function() {\n  //the original LercDecode for Version 1\n  var LercDecode = (function() {\n\n    // WARNING: This decoder version can only read old version 1 Lerc blobs. Use with caution.\n\n    // Note: currently, this module only has an implementation for decoding LERC data, not encoding. The name of\n    // the class was chosen to be future proof.\n\n    var CntZImage = {};\n\n    CntZImage.defaultNoDataValue = -3.4027999387901484e+38; // smallest Float32 value\n\n    /**\n     * Decode a LERC byte stream and return an object containing the pixel data and some required and optional\n     * information about it, such as the image\'s width and height.\n     *\n     * @param {ArrayBuffer} input The LERC input byte stream\n     * @param {object} [options] Decoding options, containing any of the following properties:\n     * @config {number} [inputOffset = 0]\n     *        Skip the first inputOffset bytes of the input byte stream. A valid LERC file is expected at that position.\n     * @config {Uint8Array} [encodedMask = null]\n     *        If specified, the decoder will not read mask information from the input and use the specified encoded\n     *        mask data instead. Mask header/data must not be present in the LERC byte stream in this case.\n     * @config {number} [noDataValue = LercCode.defaultNoDataValue]\n     *        Pixel value to use for masked pixels.\n     * @config {ArrayBufferView|Array} [pixelType = Float32Array]\n     *        The desired type of the pixelData array in the return value. Note that it is the caller\'s responsibility to\n     *        provide an appropriate noDataValue if the default pixelType is overridden.\n     * @config {boolean} [returnMask = false]\n     *        If true, the return value will contain a maskData property of type Uint8Array which has one element per\n     *        pixel, the value of which is 1 or 0 depending on whether that pixel\'s data is present or masked. If the\n     *        input LERC data does not contain a mask, maskData will not be returned.\n     * @config {boolean} [returnEncodedMask = false]\n     *        If true, the return value will contain a encodedMaskData property, which can be passed into encode() as\n     *        encodedMask.\n     * @config {boolean} [returnFileInfo = false]\n     *        If true, the return value will have a fileInfo property that contains metadata obtained from the\n     *        LERC headers and the decoding process.\n     * @config {boolean} [computeUsedBitDepths = false]\n     *        If true, the fileInfo property in the return value will contain the set of all block bit depths\n     *        encountered during decoding. Will only have an effect if returnFileInfo option is true.\n     * @returns {{width, height, pixelData, minValue, maxValue, noDataValue, maskData, encodedMaskData, fileInfo}}\n     */\n    CntZImage.decode = function(input, options) {\n      options = options || {};\n\n      var skipMask = options.encodedMaskData || (options.encodedMaskData === null);\n      var parsedData = parse(input, options.inputOffset || 0, skipMask);\n\n      var noDataValue = (options.noDataValue !== null) ? options.noDataValue : CntZImage.defaultNoDataValue;\n\n      var uncompressedData = uncompressPixelValues(parsedData, options.pixelType || Float32Array,\n        options.encodedMaskData, noDataValue, options.returnMask);\n\n      var result = {\n        width: parsedData.width,\n        height: parsedData.height,\n        pixelData: uncompressedData.resultPixels,\n        minValue: uncompressedData.minValue,\n        maxValue: parsedData.pixels.maxValue,\n        noDataValue: noDataValue\n      };\n\n      if (uncompressedData.resultMask) {\n        result.maskData = uncompressedData.resultMask;\n      }\n\n      if (options.returnEncodedMask && parsedData.mask) {\n        result.encodedMaskData = parsedData.mask.bitset ? parsedData.mask.bitset : null;\n      }\n\n      if (options.returnFileInfo) {\n        result.fileInfo = formatFileInfo(parsedData);\n        if (options.computeUsedBitDepths) {\n          result.fileInfo.bitDepths = computeUsedBitDepths(parsedData);\n        }\n      }\n\n      return result;\n    };\n\n    var uncompressPixelValues = function(data, TypedArrayClass, maskBitset, noDataValue, storeDecodedMask) {\n      var blockIdx = 0;\n      var numX = data.pixels.numBlocksX;\n      var numY = data.pixels.numBlocksY;\n      var blockWidth = Math.floor(data.width / numX);\n      var blockHeight = Math.floor(data.height / numY);\n      var scale = 2 * data.maxZError;\n      var minValue = Number.MAX_VALUE, currentValue;\n      maskBitset = maskBitset || ((data.mask) ? data.mask.bitset : null);\n\n      var resultPixels, resultMask;\n      resultPixels = new TypedArrayClass(data.width * data.height);\n      if (storeDecodedMask && maskBitset) {\n        resultMask = new Uint8Array(data.width * data.height);\n      }\n      var blockDataBuffer = new Float32Array(blockWidth * blockHeight);\n\n      var xx, yy;\n      for (var y = 0; y <= numY; y++) {\n        var thisBlockHeight = (y !== numY) ? blockHeight : (data.height % numY);\n        if (thisBlockHeight === 0) {\n          continue;\n        }\n        for (var x = 0; x <= numX; x++) {\n          var thisBlockWidth = (x !== numX) ? blockWidth : (data.width % numX);\n          if (thisBlockWidth === 0) {\n            continue;\n          }\n\n          var outPtr = y * data.width * blockHeight + x * blockWidth;\n          var outStride = data.width - thisBlockWidth;\n\n          var block = data.pixels.blocks[blockIdx];\n\n          var blockData, blockPtr, constValue;\n          if (block.encoding < 2) {\n            // block is either uncompressed or bit-stuffed (encodings 0 and 1)\n            if (block.encoding === 0) {\n              // block is uncompressed\n              blockData = block.rawData;\n            } else {\n              // block is bit-stuffed\n              unstuff(block.stuffedData, block.bitsPerPixel, block.numValidPixels, block.offset, scale, blockDataBuffer, data.pixels.maxValue);\n              blockData = blockDataBuffer;\n            }\n            blockPtr = 0;\n          }\n          else if (block.encoding === 2) {\n            // block is all 0\n            constValue = 0;\n          }\n          else {\n            // block has constant value (encoding === 3)\n            constValue = block.offset;\n          }\n\n          var maskByte;\n          if (maskBitset) {\n            for (yy = 0; yy < thisBlockHeight; yy++) {\n              if (outPtr & 7) {\n                //\n                maskByte = maskBitset[outPtr >> 3];\n                maskByte <<= outPtr & 7;\n              }\n              for (xx = 0; xx < thisBlockWidth; xx++) {\n                if (!(outPtr & 7)) {\n                  // read next byte from mask\n                  maskByte = maskBitset[outPtr >> 3];\n                }\n                if (maskByte & 128) {\n                  // pixel data present\n                  if (resultMask) {\n                    resultMask[outPtr] = 1;\n                  }\n                  currentValue = (block.encoding < 2) ? blockData[blockPtr++] : constValue;\n                  minValue = minValue > currentValue ? currentValue : minValue;\n                  resultPixels[outPtr++] = currentValue;\n                } else {\n                  // pixel data not present\n                  if (resultMask) {\n                    resultMask[outPtr] = 0;\n                  }\n                  resultPixels[outPtr++] = noDataValue;\n                }\n                maskByte <<= 1;\n              }\n              outPtr += outStride;\n            }\n          } else {\n            // mask not present, simply copy block over\n            if (block.encoding < 2) {\n              // duplicating this code block for performance reasons\n              // blockData case:\n              for (yy = 0; yy < thisBlockHeight; yy++) {\n                for (xx = 0; xx < thisBlockWidth; xx++) {\n                  currentValue = blockData[blockPtr++];\n                  minValue = minValue > currentValue ? currentValue : minValue;\n                  resultPixels[outPtr++] = currentValue;\n                }\n                outPtr += outStride;\n              }\n            }\n            else {\n              // constValue case:\n              minValue = minValue > constValue ? constValue : minValue;\n              for (yy = 0; yy < thisBlockHeight; yy++) {\n                for (xx = 0; xx < thisBlockWidth; xx++) {\n                  resultPixels[outPtr++] = constValue;\n                }\n                outPtr += outStride;\n              }\n            }\n          }\n          if ((block.encoding === 1) && (blockPtr !== block.numValidPixels)) {\n            throw "Block and Mask do not match";\n          }\n          blockIdx++;\n        }\n      }\n\n      return {\n        resultPixels: resultPixels,\n        resultMask: resultMask,\n        minValue: minValue\n      };\n    };\n\n    var formatFileInfo = function(data) {\n      return {\n        "fileIdentifierString": data.fileIdentifierString,\n        "fileVersion": data.fileVersion,\n        "imageType": data.imageType,\n        "height": data.height,\n        "width": data.width,\n        "maxZError": data.maxZError,\n        "eofOffset": data.eofOffset,\n        "mask": data.mask ? {\n          "numBlocksX": data.mask.numBlocksX,\n          "numBlocksY": data.mask.numBlocksY,\n          "numBytes": data.mask.numBytes,\n          "maxValue": data.mask.maxValue\n        } : null,\n        "pixels": {\n          "numBlocksX": data.pixels.numBlocksX,\n          "numBlocksY": data.pixels.numBlocksY,\n          "numBytes": data.pixels.numBytes,\n          "maxValue": data.pixels.maxValue,\n          "noDataValue": data.noDataValue\n        }\n      };\n    };\n\n    var computeUsedBitDepths = function(data) {\n      var numBlocks = data.pixels.numBlocksX * data.pixels.numBlocksY;\n      var bitDepths = {};\n      for (var i = 0; i < numBlocks; i++) {\n        var block = data.pixels.blocks[i];\n        if (block.encoding === 0) {\n          bitDepths.float32 = true;\n        } else if (block.encoding === 1) {\n          bitDepths[block.bitsPerPixel] = true;\n        } else {\n          bitDepths[0] = true;\n        }\n      }\n\n      return Object.keys(bitDepths);\n    };\n\n    var parse = function(input, fp, skipMask) {\n      var data = {};\n\n      // File header\n      var fileIdView = new Uint8Array(input, fp, 10);\n      data.fileIdentifierString = String.fromCharCode.apply(null, fileIdView);\n      if (data.fileIdentifierString.trim() !== "CntZImage") {\n        throw "Unexpected file identifier string: " + data.fileIdentifierString;\n      }\n      fp += 10;\n      var view = new DataView(input, fp, 24);\n      data.fileVersion = view.getInt32(0, true);\n      data.imageType = view.getInt32(4, true);\n      data.height = view.getUint32(8, true);\n      data.width = view.getUint32(12, true);\n      data.maxZError = view.getFloat64(16, true);\n      fp += 24;\n\n      // Mask Header\n      if (!skipMask) {\n        view = new DataView(input, fp, 16);\n        data.mask = {};\n        data.mask.numBlocksY = view.getUint32(0, true);\n        data.mask.numBlocksX = view.getUint32(4, true);\n        data.mask.numBytes = view.getUint32(8, true);\n        data.mask.maxValue = view.getFloat32(12, true);\n        fp += 16;\n\n        // Mask Data\n        if (data.mask.numBytes > 0) {\n          var bitset = new Uint8Array(Math.ceil(data.width * data.height / 8));\n          view = new DataView(input, fp, data.mask.numBytes);\n          var cnt = view.getInt16(0, true);\n          var ip = 2, op = 0;\n          do {\n            if (cnt > 0) {\n              while (cnt--) { bitset[op++] = view.getUint8(ip++); }\n            } else {\n              var val = view.getUint8(ip++);\n              cnt = -cnt;\n              while (cnt--) { bitset[op++] = val; }\n            }\n            cnt = view.getInt16(ip, true);\n            ip += 2;\n          } while (ip < data.mask.numBytes);\n          if ((cnt !== -32768) || (op < bitset.length)) {\n            throw "Unexpected end of mask RLE encoding";\n          }\n          data.mask.bitset = bitset;\n          fp += data.mask.numBytes;\n        }\n        else if ((data.mask.numBytes | data.mask.numBlocksY | data.mask.maxValue) === 0) {  // Special case, all nodata\n          data.mask.bitset = new Uint8Array(Math.ceil(data.width * data.height / 8));\n        }\n      }\n\n      // Pixel Header\n      view = new DataView(input, fp, 16);\n      data.pixels = {};\n      data.pixels.numBlocksY = view.getUint32(0, true);\n      data.pixels.numBlocksX = view.getUint32(4, true);\n      data.pixels.numBytes = view.getUint32(8, true);\n      data.pixels.maxValue = view.getFloat32(12, true);\n      fp += 16;\n\n      var numBlocksX = data.pixels.numBlocksX;\n      var numBlocksY = data.pixels.numBlocksY;\n      // the number of blocks specified in the header does not take into account the blocks at the end of\n      // each row/column with a special width/height that make the image complete in case the width is not\n      // evenly divisible by the number of blocks.\n      var actualNumBlocksX = numBlocksX + ((data.width % numBlocksX) > 0 ? 1 : 0);\n      var actualNumBlocksY = numBlocksY + ((data.height % numBlocksY) > 0 ? 1 : 0);\n      data.pixels.blocks = new Array(actualNumBlocksX * actualNumBlocksY);\n      var blockI = 0;\n      for (var blockY = 0; blockY < actualNumBlocksY; blockY++) {\n        for (var blockX = 0; blockX < actualNumBlocksX; blockX++) {\n\n          // Block\n          var size = 0;\n          var bytesLeft = input.byteLength - fp;\n          view = new DataView(input, fp, Math.min(10, bytesLeft));\n          var block = {};\n          data.pixels.blocks[blockI++] = block;\n          var headerByte = view.getUint8(0); size++;\n          block.encoding = headerByte & 63;\n          if (block.encoding > 3) {\n            throw "Invalid block encoding (" + block.encoding + ")";\n          }\n          if (block.encoding === 2) {\n            fp++;\n            continue;\n          }\n          if ((headerByte !== 0) && (headerByte !== 2)) {\n            headerByte >>= 6;\n            block.offsetType = headerByte;\n            if (headerByte === 2) {\n              block.offset = view.getInt8(1); size++;\n            } else if (headerByte === 1) {\n              block.offset = view.getInt16(1, true); size += 2;\n            } else if (headerByte === 0) {\n              block.offset = view.getFloat32(1, true); size += 4;\n            } else {\n              throw "Invalid block offset type";\n            }\n\n            if (block.encoding === 1) {\n              headerByte = view.getUint8(size); size++;\n              block.bitsPerPixel = headerByte & 63;\n              headerByte >>= 6;\n              block.numValidPixelsType = headerByte;\n              if (headerByte === 2) {\n                block.numValidPixels = view.getUint8(size); size++;\n              } else if (headerByte === 1) {\n                block.numValidPixels = view.getUint16(size, true); size += 2;\n              } else if (headerByte === 0) {\n                block.numValidPixels = view.getUint32(size, true); size += 4;\n              } else {\n                throw "Invalid valid pixel count type";\n              }\n            }\n          }\n          fp += size;\n\n          if (block.encoding === 3) {\n            continue;\n          }\n\n          var arrayBuf, store8;\n          if (block.encoding === 0) {\n            var numPixels = (data.pixels.numBytes - 1) / 4;\n            if (numPixels !== Math.floor(numPixels)) {\n              throw "uncompressed block has invalid length";\n            }\n            arrayBuf = new ArrayBuffer(numPixels * 4);\n            store8 = new Uint8Array(arrayBuf);\n            store8.set(new Uint8Array(input, fp, numPixels * 4));\n            var rawData = new Float32Array(arrayBuf);\n            block.rawData = rawData;\n            fp += numPixels * 4;\n          } else if (block.encoding === 1) {\n            var dataBytes = Math.ceil(block.numValidPixels * block.bitsPerPixel / 8);\n            var dataWords = Math.ceil(dataBytes / 4);\n            arrayBuf = new ArrayBuffer(dataWords * 4);\n            store8 = new Uint8Array(arrayBuf);\n            store8.set(new Uint8Array(input, fp, dataBytes));\n            block.stuffedData = new Uint32Array(arrayBuf);\n            fp += dataBytes;\n          }\n        }\n      }\n      data.eofOffset = fp;\n      return data;\n    };\n\n    var unstuff = function(src, bitsPerPixel, numPixels, offset, scale, dest, maxValue) {\n      var bitMask = (1 << bitsPerPixel) - 1;\n      var i = 0, o;\n      var bitsLeft = 0;\n      var n, buffer;\n      var nmax = Math.ceil((maxValue - offset) / scale);\n      // get rid of trailing bytes that are already part of next block\n      var numInvalidTailBytes = src.length * 4 - Math.ceil(bitsPerPixel * numPixels / 8);\n      src[src.length - 1] <<= 8 * numInvalidTailBytes;\n\n      for (o = 0; o < numPixels; o++) {\n        if (bitsLeft === 0) {\n          buffer = src[i++];\n          bitsLeft = 32;\n        }\n        if (bitsLeft >= bitsPerPixel) {\n          n = (buffer >>> (bitsLeft - bitsPerPixel)) & bitMask;\n          bitsLeft -= bitsPerPixel;\n        } else {\n          var missingBits = (bitsPerPixel - bitsLeft);\n          n = ((buffer & bitMask) << missingBits) & bitMask;\n          buffer = src[i++];\n          bitsLeft = 32 - missingBits;\n          n += (buffer >>> bitsLeft);\n        }\n        //pixel values may exceed max due to quantization\n        dest[o] = n < nmax ? offset + n * scale : maxValue;\n      }\n      return dest;\n    };\n\n    return CntZImage;\n  })();\n\n  //version 2. Supports 2.1, 2.2, 2.3\n  var Lerc2Decode = (function() {\n    // Note: currently, this module only has an implementation for decoding LERC data, not encoding. The name of\n    // the class was chosen to be future proof, following LercDecode.\n\n    /*****************************************\n    * private static class bitsutffer used by Lerc2Decode\n    *******************************************/\n    var BitStuffer = {\n      //methods ending with 2 are for the new byte order used by Lerc2.3 and above.\n      //originalUnstuff is used to unpack Huffman code table. code is duplicated to unstuffx for performance reasons.\n      unstuff: function(src, dest, bitsPerPixel, numPixels, lutArr, offset, scale, maxValue) {\n        var bitMask = (1 << bitsPerPixel) - 1;\n        var i = 0, o;\n        var bitsLeft = 0;\n        var n, buffer, missingBits, nmax;\n\n        // get rid of trailing bytes that are already part of next block\n        var numInvalidTailBytes = src.length * 4 - Math.ceil(bitsPerPixel * numPixels / 8);\n        src[src.length - 1] <<= 8 * numInvalidTailBytes;\n        if (lutArr) {\n          for (o = 0; o < numPixels; o++) {\n            if (bitsLeft === 0) {\n              buffer = src[i++];\n              bitsLeft = 32;\n            }\n            if (bitsLeft >= bitsPerPixel) {\n              n = (buffer >>> (bitsLeft - bitsPerPixel)) & bitMask;\n              bitsLeft -= bitsPerPixel;\n            }\n            else {\n              missingBits = (bitsPerPixel - bitsLeft);\n              n = ((buffer & bitMask) << missingBits) & bitMask;\n              buffer = src[i++];\n              bitsLeft = 32 - missingBits;\n              n += (buffer >>> bitsLeft);\n            }\n            dest[o] = lutArr[n];//offset + lutArr[n] * scale;\n          }\n        }\n        else {\n          nmax = Math.ceil((maxValue - offset) / scale);\n          for (o = 0; o < numPixels; o++) {\n            if (bitsLeft === 0) {\n              buffer = src[i++];\n              bitsLeft = 32;\n            }\n            if (bitsLeft >= bitsPerPixel) {\n              n = (buffer >>> (bitsLeft - bitsPerPixel)) & bitMask;\n              bitsLeft -= bitsPerPixel;\n            }\n            else {\n              missingBits = (bitsPerPixel - bitsLeft);\n              n = ((buffer & bitMask) << missingBits) & bitMask;\n              buffer = src[i++];\n              bitsLeft = 32 - missingBits;\n              n += (buffer >>> bitsLeft);\n            }\n            //pixel values may exceed max due to quantization\n            dest[o] = n < nmax ? offset + n * scale : maxValue;\n          }\n        }\n      },\n\n      unstuffLUT: function(src, bitsPerPixel, numPixels, offset, scale, maxValue) {\n        var bitMask = (1 << bitsPerPixel) - 1;\n        var i = 0, o = 0, missingBits = 0, bitsLeft = 0, n = 0;\n        var buffer;\n        var dest = [];\n\n        // get rid of trailing bytes that are already part of next block\n        var numInvalidTailBytes = src.length * 4 - Math.ceil(bitsPerPixel * numPixels / 8);\n        src[src.length - 1] <<= 8 * numInvalidTailBytes;\n\n        var nmax = Math.ceil((maxValue - offset) / scale);\n        for (o = 0; o < numPixels; o++) {\n          if (bitsLeft === 0) {\n            buffer = src[i++];\n            bitsLeft = 32;\n          }\n          if (bitsLeft >= bitsPerPixel) {\n            n = (buffer >>> (bitsLeft - bitsPerPixel)) & bitMask;\n            bitsLeft -= bitsPerPixel;\n          } else {\n            missingBits = (bitsPerPixel - bitsLeft);\n            n = ((buffer & bitMask) << missingBits) & bitMask;\n            buffer = src[i++];\n            bitsLeft = 32 - missingBits;\n            n += (buffer >>> bitsLeft);\n          }\n          //dest.push(n);\n          dest[o] = n < nmax ? offset + n * scale : maxValue;\n        }\n        dest.unshift(offset);//1st one\n        return dest;\n      },\n\n      unstuff2: function(src, dest, bitsPerPixel, numPixels, lutArr, offset, scale, maxValue) {\n        var bitMask = (1 << bitsPerPixel) - 1;\n        var i = 0, o;\n        var bitsLeft = 0, bitPos = 0;\n        var n, buffer, missingBits;\n        if (lutArr) {\n          for (o = 0; o < numPixels; o++) {\n            if (bitsLeft === 0) {\n              buffer = src[i++];\n              bitsLeft = 32;\n              bitPos = 0;\n            }\n            if (bitsLeft >= bitsPerPixel) {\n              n = ((buffer >>> bitPos) & bitMask);\n              bitsLeft -= bitsPerPixel;\n              bitPos += bitsPerPixel;\n            } else {\n              missingBits = (bitsPerPixel - bitsLeft);\n              n = (buffer >>> bitPos) & bitMask;\n              buffer = src[i++];\n              bitsLeft = 32 - missingBits;\n              n |= (buffer & ((1 << missingBits) - 1)) << (bitsPerPixel - missingBits);\n              bitPos = missingBits;\n            }\n            dest[o] = lutArr[n];\n          }\n        }\n        else {\n          var nmax = Math.ceil((maxValue - offset) / scale);\n          for (o = 0; o < numPixels; o++) {\n            if (bitsLeft === 0) {\n              buffer = src[i++];\n              bitsLeft = 32;\n              bitPos = 0;\n            }\n            if (bitsLeft >= bitsPerPixel) {\n              //no unsigned left shift\n              n = ((buffer >>> bitPos) & bitMask);\n              bitsLeft -= bitsPerPixel;\n              bitPos += bitsPerPixel;\n            } else {\n              missingBits = (bitsPerPixel - bitsLeft);\n              n = (buffer >>> bitPos) & bitMask;//((buffer & bitMask) << missingBits) & bitMask;\n              buffer = src[i++];\n              bitsLeft = 32 - missingBits;\n              n |= (buffer & ((1 << missingBits) - 1)) << (bitsPerPixel - missingBits);\n              bitPos = missingBits;\n            }\n            //pixel values may exceed max due to quantization\n            dest[o] = n < nmax ? offset + n * scale : maxValue;\n          }\n        }\n        return dest;\n      },\n\n      unstuffLUT2: function(src, bitsPerPixel, numPixels, offset, scale, maxValue) {\n        var bitMask = (1 << bitsPerPixel) - 1;\n        var i = 0, o = 0, missingBits = 0, bitsLeft = 0, n = 0, bitPos = 0;\n        var buffer;\n        var dest = [];\n        var nmax = Math.ceil((maxValue - offset) / scale);\n        for (o = 0; o < numPixels; o++) {\n          if (bitsLeft === 0) {\n            buffer = src[i++];\n            bitsLeft = 32;\n            bitPos = 0;\n          }\n          if (bitsLeft >= bitsPerPixel) {\n            //no unsigned left shift\n            n = ((buffer >>> bitPos) & bitMask);\n            bitsLeft -= bitsPerPixel;\n            bitPos += bitsPerPixel;\n          } else {\n            missingBits = (bitsPerPixel - bitsLeft);\n            n = (buffer >>> bitPos) & bitMask;//((buffer & bitMask) << missingBits) & bitMask;\n            buffer = src[i++];\n            bitsLeft = 32 - missingBits;\n            n |= (buffer & ((1 << missingBits) - 1)) << (bitsPerPixel - missingBits);\n            bitPos = missingBits;\n          }\n          //dest.push(n);\n          dest[o] = n < nmax ? offset + n * scale : maxValue;\n        }\n        dest.unshift(offset);\n        return dest;\n      },\n\n      originalUnstuff: function(src, dest, bitsPerPixel, numPixels) {\n        var bitMask = (1 << bitsPerPixel) - 1;\n        var i = 0, o;\n        var bitsLeft = 0;\n        var n, buffer, missingBits;\n\n        // get rid of trailing bytes that are already part of next block\n        var numInvalidTailBytes = src.length * 4 - Math.ceil(bitsPerPixel * numPixels / 8);\n        src[src.length - 1] <<= 8 * numInvalidTailBytes;\n\n        for (o = 0; o < numPixels; o++) {\n          if (bitsLeft === 0) {\n            buffer = src[i++];\n            bitsLeft = 32;\n          }\n          if (bitsLeft >= bitsPerPixel) {\n            n = (buffer >>> (bitsLeft - bitsPerPixel)) & bitMask;\n            bitsLeft -= bitsPerPixel;\n          }\n          else {\n            missingBits = (bitsPerPixel - bitsLeft);\n            n = ((buffer & bitMask) << missingBits) & bitMask;\n            buffer = src[i++];\n            bitsLeft = 32 - missingBits;\n            n += (buffer >>> bitsLeft);\n          }\n          dest[o] = n;\n        }\n        return dest;\n      },\n\n      originalUnstuff2: function(src, dest, bitsPerPixel, numPixels) {\n        var bitMask = (1 << bitsPerPixel) - 1;\n        var i = 0, o;\n        var bitsLeft = 0, bitPos = 0;\n        var n, buffer, missingBits;\n        //micro-optimizations\n        for (o = 0; o < numPixels; o++) {\n          if (bitsLeft === 0) {\n            buffer = src[i++];\n            bitsLeft = 32;\n            bitPos = 0;\n          }\n          if (bitsLeft >= bitsPerPixel) {\n            //no unsigned left shift\n            n = ((buffer >>> bitPos) & bitMask);\n            bitsLeft -= bitsPerPixel;\n            bitPos += bitsPerPixel;\n          } else {\n            missingBits = (bitsPerPixel - bitsLeft);\n            n = (buffer >>> bitPos) & bitMask;//((buffer & bitMask) << missingBits) & bitMask;\n            buffer = src[i++];\n            bitsLeft = 32 - missingBits;\n            n |= (buffer & ((1 << missingBits) - 1)) << (bitsPerPixel - missingBits);\n            bitPos = missingBits;\n          }\n          dest[o] = n;\n        }\n        return dest;\n      }\n    };\n\n    /*****************************************\n    *private static class used by Lerc2Decode\n    ******************************************/\n    var Lerc2Helpers = {\n      HUFFMAN_LUT_BITS_MAX: 12, //use 2^12 lut, treat it like constant\n      computeChecksumFletcher32: function(input) {\n\n        var sum1 = 0xffff, sum2 = 0xffff;\n        var len = input.length;\n        var words = Math.floor(len / 2);\n        var i = 0;\n        while (words) {\n          var tlen = (words >= 359) ? 359 : words;\n          words -= tlen;\n          do {\n            sum1 += (input[i++] << 8);\n            sum2 += sum1 += input[i++];\n          } while (--tlen);\n\n          sum1 = (sum1 & 0xffff) + (sum1 >>> 16);\n          sum2 = (sum2 & 0xffff) + (sum2 >>> 16);\n        }\n\n        // add the straggler byte if it exists\n        if (len & 1) {\n          sum2 += sum1 += (input[i] << 8);\n        }\n        // second reduction step to reduce sums to 16 bits\n        sum1 = (sum1 & 0xffff) + (sum1 >>> 16);\n        sum2 = (sum2 & 0xffff) + (sum2 >>> 16);\n\n        return (sum2 << 16 | sum1) >>> 0;\n      },\n\n      readHeaderInfo: function(input, data) {\n        var ptr = data.ptr;\n        var fileIdView = new Uint8Array(input, ptr, 6);\n        var headerInfo = {};\n        headerInfo.fileIdentifierString = String.fromCharCode.apply(null, fileIdView);\n        if (headerInfo.fileIdentifierString.lastIndexOf("Lerc2", 0) !== 0) {\n          throw "Unexpected file identifier string (expect Lerc2 ): " + headerInfo.fileIdentifierString;\n        }\n        ptr += 6;\n        var view = new DataView(input, ptr, 8);\n        var fileVersion = view.getInt32(0, true);\n        headerInfo.fileVersion = fileVersion;\n        ptr += 4;\n        if (fileVersion >= 3) {\n          headerInfo.checksum = view.getUint32(4, true); //nrows\n          ptr += 4;\n        }\n\n        //keys start from here\n        view = new DataView(input, ptr, 12);\n        headerInfo.height = view.getUint32(0, true); //nrows\n        headerInfo.width = view.getUint32(4, true); //ncols\n        ptr += 8;\n        if (fileVersion >= 4) {\n          headerInfo.numDims = view.getUint32(8, true);\n          ptr += 4;\n        }\n        else {\n          headerInfo.numDims = 1;\n        }\n\n        view = new DataView(input, ptr, 40);\n        headerInfo.numValidPixel = view.getUint32(0, true);\n        headerInfo.microBlockSize = view.getInt32(4, true);\n        headerInfo.blobSize = view.getInt32(8, true);\n        headerInfo.imageType = view.getInt32(12, true);\n\n        headerInfo.maxZError = view.getFloat64(16, true);\n        headerInfo.zMin = view.getFloat64(24, true);\n        headerInfo.zMax = view.getFloat64(32, true);\n        ptr += 40;\n        data.headerInfo = headerInfo;\n        data.ptr = ptr;\n\n        var checksum, keyLength;\n        if (fileVersion >= 3) {\n          keyLength = fileVersion >= 4 ? 52 : 48;\n          checksum = this.computeChecksumFletcher32(new Uint8Array(input, ptr - keyLength, headerInfo.blobSize - 14));\n          if (checksum !== headerInfo.checksum) {\n            throw "Checksum failed.";\n          }\n        }\n        return true;\n      },\n\n      checkMinMaxRanges: function(input, data) {\n        var headerInfo = data.headerInfo;\n        var OutPixelTypeArray = this.getDataTypeArray(headerInfo.imageType);\n        var rangeBytes = headerInfo.numDims * this.getDataTypeSize(headerInfo.imageType);\n        var minValues = this.readSubArray(input, data.ptr, OutPixelTypeArray, rangeBytes);\n        var maxValues = this.readSubArray(input, data.ptr + rangeBytes, OutPixelTypeArray, rangeBytes);\n        data.ptr += (2 * rangeBytes);\n        var i, equal = true;\n        for (i = 0; i < headerInfo.numDims; i++) {\n          if (minValues[i] !== maxValues[i]) {\n            equal = false;\n            break;\n          }\n        }\n        headerInfo.minValues = minValues;\n        headerInfo.maxValues = maxValues;\n        return equal;\n      },\n\n      readSubArray: function(input, ptr, OutPixelTypeArray, numBytes) {\n        var rawData;\n        if (OutPixelTypeArray === Uint8Array) {\n          rawData = new Uint8Array(input, ptr, numBytes);\n        }\n        else {\n          var arrayBuf = new ArrayBuffer(numBytes);\n          var store8 = new Uint8Array(arrayBuf);\n          store8.set(new Uint8Array(input, ptr, numBytes));\n          rawData = new OutPixelTypeArray(arrayBuf);\n        }\n        return rawData;\n      },\n\n      readMask: function(input, data) {\n        var ptr = data.ptr;\n        var headerInfo = data.headerInfo;\n        var numPixels = headerInfo.width * headerInfo.height;\n        var numValidPixel = headerInfo.numValidPixel;\n\n        var view = new DataView(input, ptr, 4);\n        var mask = {};\n        mask.numBytes = view.getUint32(0, true);\n        ptr += 4;\n\n        // Mask Data\n        if ((0 === numValidPixel || numPixels === numValidPixel) && 0 !== mask.numBytes) {\n          throw ("invalid mask");\n        }\n        var bitset, resultMask;\n        if (numValidPixel === 0) {\n          bitset = new Uint8Array(Math.ceil(numPixels / 8));\n          mask.bitset = bitset;\n          resultMask = new Uint8Array(numPixels);\n          data.pixels.resultMask = resultMask;\n          ptr += mask.numBytes;\n        }// ????? else if (data.mask.numBytes > 0 && data.mask.numBytes< data.numValidPixel) {\n        else if (mask.numBytes > 0) {\n          bitset = new Uint8Array(Math.ceil(numPixels / 8));\n          view = new DataView(input, ptr, mask.numBytes);\n          var cnt = view.getInt16(0, true);\n          var ip = 2, op = 0, val = 0;\n          do {\n            if (cnt > 0) {\n              while (cnt--) { bitset[op++] = view.getUint8(ip++); }\n            } else {\n              val = view.getUint8(ip++);\n              cnt = -cnt;\n              while (cnt--) { bitset[op++] = val; }\n            }\n            cnt = view.getInt16(ip, true);\n            ip += 2;\n          } while (ip < mask.numBytes);\n          if ((cnt !== -32768) || (op < bitset.length)) {\n            throw "Unexpected end of mask RLE encoding";\n          }\n\n          resultMask = new Uint8Array(numPixels);\n          var mb = 0, k = 0;\n\n          for (k = 0; k < numPixels; k++) {\n            if (k & 7) {\n              mb = bitset[k >> 3];\n              mb <<= k & 7;\n            }\n            else {\n              mb = bitset[k >> 3];\n            }\n            if (mb & 128) {\n              resultMask[k] = 1;\n            }\n          }\n          data.pixels.resultMask = resultMask;\n\n          mask.bitset = bitset;\n          ptr += mask.numBytes;\n        }\n        data.ptr = ptr;\n        data.mask = mask;\n        return true;\n      },\n\n      readDataOneSweep: function(input, data, OutPixelTypeArray) {\n        var ptr = data.ptr;\n        var headerInfo = data.headerInfo;\n        var numDims = headerInfo.numDims;\n        var numPixels = headerInfo.width * headerInfo.height;\n        var imageType = headerInfo.imageType;\n        var numBytes = headerInfo.numValidPixel * Lerc2Helpers.getDataTypeSize(imageType) * numDims;\n        //data.pixels.numBytes = numBytes;\n        var rawData;\n        var mask = data.pixels.resultMask;\n        if (OutPixelTypeArray === Uint8Array) {\n          rawData = new Uint8Array(input, ptr, numBytes);\n        }\n        else {\n          var arrayBuf = new ArrayBuffer(numBytes);\n          var store8 = new Uint8Array(arrayBuf);\n          store8.set(new Uint8Array(input, ptr, numBytes));\n          rawData = new OutPixelTypeArray(arrayBuf);\n        }\n        if (rawData.length === numPixels * numDims) {\n          data.pixels.resultPixels = rawData;\n        }\n        else  //mask\n        {\n          data.pixels.resultPixels = new OutPixelTypeArray(numPixels * numDims);\n          var z = 0, k = 0, i = 0, nStart = 0;\n          if (numDims > 1) {\n            for (i=0; i < numDims; i++) {\n              nStart = i * numPixels;\n              for (k = 0; k < numPixels; k++) {\n                if (mask[k]) {\n                  data.pixels.resultPixels[nStart + k] = rawData[z++];\n                }\n              }\n            }\n          }\n          else {\n            for (k = 0; k < numPixels; k++) {\n              if (mask[k]) {\n                data.pixels.resultPixels[k] = rawData[z++];\n              }\n            }\n          }\n        }\n        ptr += numBytes;\n        data.ptr = ptr;       //return data;\n        return true;\n      },\n\n      readHuffmanTree: function(input, data) {\n        var BITS_MAX = this.HUFFMAN_LUT_BITS_MAX; //8 is slow for the large test image\n        //var size_max = 1 << BITS_MAX;\n        /* ************************\n         * reading code table\n         *************************/\n        var view = new DataView(input, data.ptr, 16);\n        data.ptr += 16;\n        var version = view.getInt32(0, true);\n        if (version < 2) {\n          throw "unsupported Huffman version";\n        }\n        var size = view.getInt32(4, true);\n        var i0 = view.getInt32(8, true);\n        var i1 = view.getInt32(12, true);\n        if (i0 >= i1) {\n          return false;\n        }\n        var blockDataBuffer = new Uint32Array(i1 - i0);\n        Lerc2Helpers.decodeBits(input, data, blockDataBuffer);\n        var codeTable = []; //size\n        var i, j, k, len;\n\n        for (i = i0; i < i1; i++) {\n          j = i - (i < size ? 0 : size);//wrap around\n          codeTable[j] = { first: blockDataBuffer[i - i0], second: null };\n        }\n\n        var dataBytes = input.byteLength - data.ptr;\n        var dataWords = Math.ceil(dataBytes / 4);\n        var arrayBuf = new ArrayBuffer(dataWords * 4);\n        var store8 = new Uint8Array(arrayBuf);\n        store8.set(new Uint8Array(input, data.ptr, dataBytes));\n        var stuffedData = new Uint32Array(arrayBuf); //must start from x*4\n        var bitPos = 0, word, srcPtr = 0;\n        word = stuffedData[0];\n        for (i = i0; i < i1; i++) {\n          j = i - (i < size ? 0 : size);//wrap around\n          len = codeTable[j].first;\n          if (len > 0) {\n            codeTable[j].second = (word << bitPos) >>> (32 - len);\n\n            if (32 - bitPos >= len) {\n              bitPos += len;\n              if (bitPos === 32) {\n                bitPos = 0;\n                srcPtr++;\n                word = stuffedData[srcPtr];\n              }\n            }\n            else {\n              bitPos += len - 32;\n              srcPtr++;\n              word = stuffedData[srcPtr];\n              codeTable[j].second |= word >>> (32 - bitPos);\n            }\n          }\n        }\n\n        //finished reading code table\n\n        /* ************************\n         * building lut\n         *************************/\n        var numBitsLUT = 0, numBitsLUTQick = 0;\n        var tree = new TreeNode();\n        for (i = 0; i < codeTable.length; i++) {\n          if (codeTable[i] !== undefined) {\n            numBitsLUT = Math.max(numBitsLUT, codeTable[i].first);\n          }\n        }\n        if (numBitsLUT >= BITS_MAX) {\n          numBitsLUTQick = BITS_MAX;\n        }\n        else {\n          numBitsLUTQick = numBitsLUT;\n        }\n        if (numBitsLUT >= 30) {\n          console.log("WARning, large NUM LUT BITS IS " + numBitsLUT);\n        }\n        var decodeLut = [], entry, code, numEntries, jj, currentBit, node;\n        for (i = i0; i < i1; i++) {\n          j = i - (i < size ? 0 : size);//wrap around\n          len = codeTable[j].first;\n          if (len > 0) {\n            entry = [len, j];\n            if (len <= numBitsLUTQick) {\n              code = codeTable[j].second << (numBitsLUTQick - len);\n              numEntries = 1 << (numBitsLUTQick - len);\n              for (k = 0; k < numEntries; k++) {\n                decodeLut[code | k] = entry;\n              }\n            }\n            else {\n              //build tree\n              code = codeTable[j].second;\n              node = tree;\n              for (jj = len - 1; jj >= 0; jj--) {\n                currentBit = code >>> jj & 1; //no left shift as length could be 30,31\n                if (currentBit) {\n                  if (!node.right) {\n                    node.right = new TreeNode();\n                  }\n                  node = node.right;\n                }\n                else {\n                  if (!node.left) {\n                    node.left = new TreeNode();\n                  }\n                  node = node.left;\n                }\n                if (jj === 0 && !node.val) {\n                  node.val = entry[1];\n                }\n              }\n            }\n          }\n        }\n        return {\n          decodeLut: decodeLut,\n          numBitsLUTQick: numBitsLUTQick,\n          numBitsLUT: numBitsLUT,\n          tree: tree,\n          stuffedData: stuffedData,\n          srcPtr: srcPtr,\n          bitPos: bitPos\n        };\n      },\n\n      readHuffman: function(input, data, OutPixelTypeArray) {\n        var headerInfo = data.headerInfo;\n        var numDims = headerInfo.numDims;\n        var height = data.headerInfo.height;\n        var width = data.headerInfo.width;\n        var numPixels = width * height;\n        //var size_max = 1 << BITS_MAX;\n        /* ************************\n         * reading huffman structure info\n         *************************/\n        var huffmanInfo = this.readHuffmanTree(input, data);\n        var decodeLut = huffmanInfo.decodeLut;\n        var tree = huffmanInfo.tree;\n        //stuffedData includes huffman headers\n        var stuffedData = huffmanInfo.stuffedData;\n        var srcPtr = huffmanInfo.srcPtr;\n        var bitPos = huffmanInfo.bitPos;\n        var numBitsLUTQick = huffmanInfo.numBitsLUTQick;\n        var numBitsLUT = huffmanInfo.numBitsLUT;\n        var offset = data.headerInfo.imageType === 0 ? 128 : 0;\n        /*************************\n        *  decode\n        ***************************/\n        var node, val, delta, mask = data.pixels.resultMask, valTmp, valTmpQuick, currentBit;\n        var i, j, k, ii;\n        var prevVal = 0;\n        if (bitPos > 0) {\n          srcPtr++;\n          bitPos = 0;\n        }\n        var word = stuffedData[srcPtr];\n        var deltaEncode = data.encodeMode === 1;\n        var resultPixelsAllDim = new OutPixelTypeArray(numPixels * numDims);\n        var resultPixels = resultPixelsAllDim;\n        var iDim;\n        for (iDim = 0; iDim < headerInfo.numDims; iDim++) {\n          if (numDims > 1) {\n            //get the mem block of current dimension\n            resultPixels = new OutPixelTypeArray(resultPixelsAllDim.buffer, numPixels * iDim, numPixels);\n            prevVal = 0;\n          }\n          if (data.headerInfo.numValidPixel === width * height) { //all valid\n            for (k = 0, i = 0; i < height; i++) {\n              for (j = 0; j < width; j++, k++) {\n                val = 0;\n                valTmp = (word << bitPos) >>> (32 - numBitsLUTQick);\n                valTmpQuick = valTmp;// >>> deltaBits;\n                if (32 - bitPos < numBitsLUTQick) {\n                  valTmp |= ((stuffedData[srcPtr + 1]) >>> (64 - bitPos - numBitsLUTQick));\n                  valTmpQuick = valTmp;// >>> deltaBits;\n                }\n                if (decodeLut[valTmpQuick])    // if there, move the correct number of bits and done\n                {\n                  val = decodeLut[valTmpQuick][1];\n                  bitPos += decodeLut[valTmpQuick][0];\n                }\n                else {\n                  valTmp = (word << bitPos) >>> (32 - numBitsLUT);\n                  valTmpQuick = valTmp;// >>> deltaBits;\n                  if (32 - bitPos < numBitsLUT) {\n                    valTmp |= ((stuffedData[srcPtr + 1]) >>> (64 - bitPos - numBitsLUT));\n                    valTmpQuick = valTmp;// >>> deltaBits;\n                  }\n                  node = tree;\n                  for (ii = 0; ii < numBitsLUT; ii++) {\n                    currentBit = valTmp >>> (numBitsLUT - ii - 1) & 1;\n                    node = currentBit ? node.right : node.left;\n                    if (!(node.left || node.right)) {\n                      val = node.val;\n                      bitPos = bitPos + ii + 1;\n                      break;\n                    }\n                  }\n                }\n\n                if (bitPos >= 32) {\n                  bitPos -= 32;\n                  srcPtr++;\n                  word = stuffedData[srcPtr];\n                }\n\n                delta = val - offset;\n                if (deltaEncode) {\n                  if (j > 0) {\n                    delta += prevVal;    // use overflow\n                  }\n                  else if (i > 0) {\n                    delta += resultPixels[k - width];\n                  }\n                  else {\n                    delta += prevVal;\n                  }\n                  delta &= 0xFF; //overflow\n                  resultPixels[k] = delta;//overflow\n                  prevVal = delta;\n                }\n                else {\n                  resultPixels[k] = delta;\n                }\n              }\n            }\n          }\n          else { //not all valid, use mask\n            for (k = 0, i = 0; i < height; i++) {\n              for (j = 0; j < width; j++, k++) {\n                if (mask[k]) {\n                  val = 0;\n                  valTmp = (word << bitPos) >>> (32 - numBitsLUTQick);\n                  valTmpQuick = valTmp;// >>> deltaBits;\n                  if (32 - bitPos < numBitsLUTQick) {\n                    valTmp |= ((stuffedData[srcPtr + 1]) >>> (64 - bitPos - numBitsLUTQick));\n                    valTmpQuick = valTmp;// >>> deltaBits;\n                  }\n                  if (decodeLut[valTmpQuick])    // if there, move the correct number of bits and done\n                  {\n                    val = decodeLut[valTmpQuick][1];\n                    bitPos += decodeLut[valTmpQuick][0];\n                  }\n                  else {\n                    valTmp = (word << bitPos) >>> (32 - numBitsLUT);\n                    valTmpQuick = valTmp;// >>> deltaBits;\n                    if (32 - bitPos < numBitsLUT) {\n                      valTmp |= ((stuffedData[srcPtr + 1]) >>> (64 - bitPos - numBitsLUT));\n                      valTmpQuick = valTmp;// >>> deltaBits;\n                    }\n                    node = tree;\n                    for (ii = 0; ii < numBitsLUT; ii++) {\n                      currentBit = valTmp >>> (numBitsLUT - ii - 1) & 1;\n                      node = currentBit ? node.right : node.left;\n                      if (!(node.left || node.right)) {\n                        val = node.val;\n                        bitPos = bitPos + ii + 1;\n                        break;\n                      }\n                    }\n                  }\n\n                  if (bitPos >= 32) {\n                    bitPos -= 32;\n                    srcPtr++;\n                    word = stuffedData[srcPtr];\n                  }\n\n                  delta = val - offset;\n                  if (deltaEncode) {\n                    if (j > 0 && mask[k - 1]) {\n                      delta += prevVal;    // use overflow\n                    }\n                    else if (i > 0 && mask[k - width]) {\n                      delta += resultPixels[k - width];\n                    }\n                    else {\n                      delta += prevVal;\n                    }\n\n                    delta &= 0xFF; //overflow\n                    resultPixels[k] = delta;//overflow\n                    prevVal = delta;\n                  }\n                  else {\n                    resultPixels[k] = delta;\n                  }\n                }\n              }\n            }\n          }\n          data.ptr = data.ptr + (srcPtr + 1) * 4 + (bitPos > 0 ? 4 : 0);\n        }\n        data.pixels.resultPixels = resultPixelsAllDim;\n      },\n\n      decodeBits: function(input, data, blockDataBuffer, offset, iDim) {\n        {\n          //bitstuff encoding is 3\n          var headerInfo = data.headerInfo;\n          var fileVersion = headerInfo.fileVersion;\n          //var block = {};\n          var blockPtr = 0;\n          var view = new DataView(input, data.ptr, 5);//to do\n          var headerByte = view.getUint8(0);\n          blockPtr++;\n          var bits67 = headerByte >> 6;\n          var n = (bits67 === 0) ? 4 : 3 - bits67;\n          var doLut = (headerByte & 32) > 0 ? true : false;//5th bit\n          var numBits = headerByte & 31;\n          var numElements = 0;\n          if (n === 1) {\n            numElements = view.getUint8(blockPtr); blockPtr++;\n          } else if (n === 2) {\n            numElements = view.getUint16(blockPtr, true); blockPtr += 2;\n          } else if (n === 4) {\n            numElements = view.getUint32(blockPtr, true); blockPtr += 4;\n          } else {\n            throw "Invalid valid pixel count type";\n          }\n          //fix: huffman codes are bit stuffed, but not bound by data\'s max value, so need to use originalUnstuff\n          //offset = offset || 0;\n          var scale = 2 * headerInfo.maxZError;\n          var stuffedData, arrayBuf, store8, dataBytes, dataWords;\n          var lutArr, lutData, lutBytes, bitsPerPixel;\n          var zMax = headerInfo.numDims > 1 ? headerInfo.maxValues[iDim] : headerInfo.zMax;\n          if (doLut) {\n            data.counter.lut++;\n            lutBytes = view.getUint8(blockPtr);\n            blockPtr++;\n            dataBytes = Math.ceil((lutBytes - 1) * numBits / 8);\n            dataWords = Math.ceil(dataBytes / 4);\n            arrayBuf = new ArrayBuffer(dataWords * 4);\n            store8 = new Uint8Array(arrayBuf);\n\n            data.ptr += blockPtr;\n            store8.set(new Uint8Array(input, data.ptr, dataBytes));\n\n            lutData = new Uint32Array(arrayBuf);\n            data.ptr += dataBytes;\n\n            bitsPerPixel = 0;\n            while ((lutBytes - 1) >>> bitsPerPixel) {\n              bitsPerPixel++;\n            }\n            dataBytes = Math.ceil(numElements * bitsPerPixel / 8);\n            dataWords = Math.ceil(dataBytes / 4);\n            arrayBuf = new ArrayBuffer(dataWords * 4);\n            store8 = new Uint8Array(arrayBuf);\n            store8.set(new Uint8Array(input, data.ptr, dataBytes));\n            stuffedData = new Uint32Array(arrayBuf);\n            data.ptr += dataBytes;\n            if (fileVersion >= 3) {\n              lutArr = BitStuffer.unstuffLUT2(lutData, numBits, lutBytes - 1, offset, scale, zMax);\n            }\n            else {\n              lutArr = BitStuffer.unstuffLUT(lutData, numBits, lutBytes - 1, offset, scale, zMax);\n            }\n            //lutArr.unshift(0);\n            if (fileVersion >= 3) {\n              //BitStuffer.unstuff2(block, blockDataBuffer, headerInfo.zMax);\n              BitStuffer.unstuff2(stuffedData, blockDataBuffer, bitsPerPixel, numElements, lutArr);\n            }\n            else {\n              BitStuffer.unstuff(stuffedData, blockDataBuffer, bitsPerPixel, numElements, lutArr);\n            }\n          }\n          else {\n            //console.debug("bitstuffer");\n            data.counter.bitstuffer++;\n            bitsPerPixel = numBits;\n            data.ptr += blockPtr;\n            if (bitsPerPixel > 0) {\n              dataBytes = Math.ceil(numElements * bitsPerPixel / 8);\n              dataWords = Math.ceil(dataBytes / 4);\n              arrayBuf = new ArrayBuffer(dataWords * 4);\n              store8 = new Uint8Array(arrayBuf);\n              store8.set(new Uint8Array(input, data.ptr, dataBytes));\n              stuffedData = new Uint32Array(arrayBuf);\n              data.ptr += dataBytes;\n              if (fileVersion >= 3) {\n                if (offset == null) {\n                  BitStuffer.originalUnstuff2(stuffedData, blockDataBuffer, bitsPerPixel, numElements);\n                }\n                else {\n                  BitStuffer.unstuff2(stuffedData, blockDataBuffer, bitsPerPixel, numElements, false, offset, scale, zMax);\n                }\n              }\n              else {\n                if (offset == null) {\n                  BitStuffer.originalUnstuff(stuffedData, blockDataBuffer, bitsPerPixel, numElements);\n                }\n                else {\n                  BitStuffer.unstuff(stuffedData, blockDataBuffer, bitsPerPixel, numElements, false, offset, scale, zMax);\n                }\n              }\n            }\n          }\n        }\n\n      },\n\n      readTiles: function(input, data, OutPixelTypeArray) {\n        var headerInfo = data.headerInfo;\n        var width = headerInfo.width;\n        var height = headerInfo.height;\n        var microBlockSize = headerInfo.microBlockSize;\n        var imageType = headerInfo.imageType;\n        var dataTypeSize = Lerc2Helpers.getDataTypeSize(imageType);\n        var numBlocksX = Math.ceil(width / microBlockSize);\n        var numBlocksY = Math.ceil(height / microBlockSize);\n        data.pixels.numBlocksY = numBlocksY;\n        data.pixels.numBlocksX = numBlocksX;\n        data.pixels.ptr = 0;\n        var row = 0, col = 0, blockY = 0, blockX = 0, thisBlockHeight = 0, thisBlockWidth = 0, bytesLeft = 0, headerByte = 0, bits67 = 0, testCode = 0, outPtr = 0, outStride = 0, numBytes = 0, bytesleft = 0, z = 0, blockPtr = 0;\n        var view, block, arrayBuf, store8, rawData;\n        var blockEncoding;\n        var blockDataBuffer = new OutPixelTypeArray(microBlockSize * microBlockSize);\n        var lastBlockHeight = (height % microBlockSize) || microBlockSize;\n        var lastBlockWidth = (width % microBlockSize) || microBlockSize;\n        var offsetType, offset;\n        var numDims = headerInfo.numDims, iDim;\n        var mask = data.pixels.resultMask;\n        var resultPixels = data.pixels.resultPixels;\n        for (blockY = 0; blockY < numBlocksY; blockY++) {\n          thisBlockHeight = (blockY !== numBlocksY - 1) ? microBlockSize : lastBlockHeight;\n          for (blockX = 0; blockX < numBlocksX; blockX++) {\n            //console.debug("y" + blockY + " x" + blockX);\n            thisBlockWidth = (blockX !== numBlocksX - 1) ? microBlockSize : lastBlockWidth;\n\n            outPtr = blockY * width * microBlockSize + blockX * microBlockSize;\n            outStride = width - thisBlockWidth;\n\n\n            for (iDim = 0; iDim < numDims; iDim++) {\n              if (numDims > 1) {\n                resultPixels = new OutPixelTypeArray(data.pixels.resultPixels.buffer, width * height * iDim * dataTypeSize, width * height);\n              }\n              bytesLeft = input.byteLength - data.ptr;\n              view = new DataView(input, data.ptr, Math.min(10, bytesLeft));\n              block = {};\n              blockPtr = 0;\n              headerByte = view.getUint8(0);\n              blockPtr++;\n              bits67 = (headerByte >> 6) & 0xFF;\n              testCode = (headerByte >> 2) & 15;    // use bits 2345 for integrity check\n              if (testCode !== (((blockX * microBlockSize) >> 3) & 15)) {\n                throw "integrity issue";\n                //return false;\n              }\n\n              blockEncoding = headerByte & 3;\n              if (blockEncoding > 3) {\n                data.ptr += blockPtr;\n                throw "Invalid block encoding (" + blockEncoding + ")";\n              }\n              else if (blockEncoding === 2) { //constant 0\n                data.counter.constant++;\n                data.ptr += blockPtr;\n                continue;\n              }\n              else if (blockEncoding === 0) {  //uncompressed\n                data.counter.uncompressed++;\n                data.ptr += blockPtr;\n                numBytes = thisBlockHeight * thisBlockWidth * dataTypeSize;\n                bytesleft = input.byteLength - data.ptr;\n                numBytes = numBytes < bytesleft ? numBytes : bytesleft;\n                //bit alignment\n                arrayBuf = new ArrayBuffer((numBytes % dataTypeSize) === 0 ? numBytes : (numBytes + dataTypeSize - numBytes % dataTypeSize));\n                store8 = new Uint8Array(arrayBuf);\n                store8.set(new Uint8Array(input, data.ptr, numBytes));\n                rawData = new OutPixelTypeArray(arrayBuf);\n                z = 0;\n                if (mask) {\n                  for (row = 0; row < thisBlockHeight; row++) {\n                    for (col = 0; col < thisBlockWidth; col++) {\n                      if (mask[outPtr]) {\n                        resultPixels[outPtr] = rawData[z++];\n                      }\n                      outPtr++;\n                    }\n                    outPtr += outStride;\n                  }\n                }\n                else {//all valid\n                  for (row = 0; row < thisBlockHeight; row++) {\n                    for (col = 0; col < thisBlockWidth; col++) {\n                      resultPixels[outPtr++] = rawData[z++];\n                    }\n                    outPtr += outStride;\n                  }\n                }\n                data.ptr += z * dataTypeSize;\n              }\n              else { //1 or 3\n                offsetType = Lerc2Helpers.getDataTypeUsed(imageType, bits67);\n                offset = Lerc2Helpers.getOnePixel(block, blockPtr, offsetType, view);\n                blockPtr += Lerc2Helpers.getDataTypeSize(offsetType);\n                if (blockEncoding === 3) //constant offset value\n                {\n                  data.ptr += blockPtr;\n                  data.counter.constantoffset++;\n                  //you can delete the following resultMask case in favor of performance because val is constant and users use nodata mask, otherwise nodatavalue post processing handles it too.\n                  //while the above statement is true, we\'re not doing it as we want to keep invalid pixel value at 0 rather than arbitrary values\n                  if (mask) {\n                    for (row = 0; row < thisBlockHeight; row++) {\n                      for (col = 0; col < thisBlockWidth; col++) {\n                        if (mask[outPtr]) {\n                          resultPixels[outPtr] = offset;\n                        }\n                        outPtr++;\n                      }\n                      outPtr += outStride;\n                    }\n                  }\n                  else {\n                    for (row = 0; row < thisBlockHeight; row++) {\n                      for (col = 0; col < thisBlockWidth; col++) {\n                        resultPixels[outPtr++] = offset;\n                      }\n                      outPtr += outStride;\n                    }\n                  }\n                }\n                else { //bitstuff encoding is 3\n                  data.ptr += blockPtr;\n                  //heavy lifting\n                  Lerc2Helpers.decodeBits(input, data, blockDataBuffer, offset, iDim);\n                  blockPtr = 0;\n                  if (mask) {\n                    for (row = 0; row < thisBlockHeight; row++) {\n                      for (col = 0; col < thisBlockWidth; col++) {\n                        if (mask[outPtr]) {\n                          resultPixels[outPtr] = blockDataBuffer[blockPtr++];\n                        }\n                        outPtr++;\n                      }\n                      outPtr += outStride;\n                    }\n                  }\n                  else {\n                    for (row = 0; row < thisBlockHeight; row++) {\n                      for (col = 0; col < thisBlockWidth; col++) {\n                        resultPixels[outPtr++] = blockDataBuffer[blockPtr++];\n                      }\n                      outPtr += outStride;\n                    }\n                  }\n                }\n              }\n            }\n          }\n        }\n      },\n\n      /*****************\n      *  private methods (helper methods)\n      *****************/\n\n      formatFileInfo: function(data) {\n        return {\n          "fileIdentifierString": data.headerInfo.fileIdentifierString,\n          "fileVersion": data.headerInfo.fileVersion,\n          "imageType": data.headerInfo.imageType,\n          "height": data.headerInfo.height,\n          "width": data.headerInfo.width,\n          "numValidPixel": data.headerInfo.numValidPixel,\n          "microBlockSize": data.headerInfo.microBlockSize,\n          "blobSize": data.headerInfo.blobSize,\n          "maxZError": data.headerInfo.maxZError,\n          "pixelType": Lerc2Helpers.getPixelType(data.headerInfo.imageType),\n          "eofOffset": data.eofOffset,\n          "mask": data.mask ? {\n            "numBytes": data.mask.numBytes\n          } : null,\n          "pixels": {\n            "numBlocksX": data.pixels.numBlocksX,\n            "numBlocksY": data.pixels.numBlocksY,\n            //"numBytes": data.pixels.numBytes,\n            "maxValue": data.headerInfo.zMax,\n            "minValue": data.headerInfo.zMin,\n            "noDataValue": data.noDataValue\n          }\n        };\n      },\n\n      constructConstantSurface: function(data) {\n        var val = data.headerInfo.zMax;\n        var numDims =  data.headerInfo.numDims;\n        var numPixels = data.headerInfo.height * data.headerInfo.width;\n        var numPixelAllDims = numPixels * numDims;\n        var i=0, k = 0, nStart=0;\n        var mask = data.pixels.resultMask;\n        if (mask) {\n          if (numDims > 1) {\n            for (i=0; i < numDims; i++) {\n              nStart = i * numPixels;\n              for (k = 0; k < numPixels; k++) {\n                if (mask[k]) {\n                  data.pixels.resultPixels[nStart + k] = val;\n                }\n              }\n            }\n          }\n          else {\n            for (k = 0; k < numPixels; k++) {\n              if (mask[k]) {\n                data.pixels.resultPixels[k] = val;\n              }\n            }\n          }\n        }\n        else {\n          if (data.pixels.resultPixels.fill) {\n            data.pixels.resultPixels.fill(val);\n          }\n          else {\n            for (k = 0; k < numPixelAllDims; k++) {\n              data.pixels.resultPixels[k] = val;\n            }\n          }\n        }\n        return;\n      },\n\n      getDataTypeArray: function(t) {\n        var tp;\n        switch (t) {\n          case 0: //char\n            tp = Int8Array;\n            break;\n          case 1: //byte\n            tp = Uint8Array;\n            break;\n          case 2: //short\n            tp = Int16Array;\n            break;\n          case 3: //ushort\n            tp = Uint16Array;\n            break;\n          case 4:\n            tp = Int32Array;\n            break;\n          case 5:\n            tp = Uint32Array;\n            break;\n          case 6:\n            tp = Float32Array;\n            break;\n          case 7:\n            tp = Float64Array;\n            break;\n          default:\n            tp = Float32Array;\n        }\n        return tp;\n      },\n\n      getPixelType: function(t) {\n        var tp;\n        switch (t) {\n          case 0: //char\n            tp = "S8";\n            break;\n          case 1: //byte\n            tp = "U8";\n            break;\n          case 2: //short\n            tp = "S16";\n            break;\n          case 3: //ushort\n            tp = "U16";\n            break;\n          case 4:\n            tp = "S32";\n            break;\n          case 5:\n            tp = "U32";\n            break;\n          case 6:\n            tp = "F32";\n            break;\n          case 7:\n            tp = "F64"; //not supported\n            break;\n          default:\n            tp = "F32";\n        }\n        return tp;\n      },\n\n      isValidPixelValue: function(t, val) {\n        if (val == null) {\n          return false;\n        }\n        var isValid;\n        switch (t) {\n          case 0: //char\n            isValid = val >= -128 && val <= 127;\n            break;\n          case 1: //byte  (unsigned char)\n            isValid = val >= 0 && val <= 255;\n            break;\n          case 2: //short\n            isValid = val >= -32768 && val <= 32767;\n            break;\n          case 3: //ushort\n            isValid = val >= 0 && val <= 65536;\n            break;\n          case 4: //int 32\n            isValid = val >= -2147483648 && val <= 2147483647;\n            break;\n          case 5: //uinit 32\n            isValid = val >= 0 && val <= 4294967296;\n            break;\n          case 6:\n            isValid = val >= -3.4027999387901484e+38 && val <= 3.4027999387901484e+38;\n            break;\n          case 7:\n            isValid = val >= 5e-324 && val <= 1.7976931348623157e+308;\n            break;\n          default:\n            isValid = false;\n        }\n        return isValid;\n      },\n\n      getDataTypeSize: function(t) {\n        var s = 0;\n        switch (t) {\n          case 0: //ubyte\n          case 1: //byte\n            s = 1;\n            break;\n          case 2: //short\n          case 3: //ushort\n            s = 2;\n            break;\n          case 4:\n          case 5:\n          case 6:\n            s = 4;\n            break;\n          case 7:\n            s = 8;\n            break;\n          default:\n            s = t;\n        }\n        return s;\n      },\n\n      getDataTypeUsed: function(dt, tc) {\n        var t = dt;\n        switch (dt) {\n          case 2: //short\n          case 4: //long\n            t = dt - tc;\n            break;\n          case 3: //ushort\n          case 5: //ulong\n            t = dt - 2 * tc;\n            break;\n          case 6: //float\n            if (0 === tc) {\n              t = dt;\n            }\n            else if (1 === tc) {\n              t = 2;\n            }\n            else {\n              t = 1;//byte\n            }\n            break;\n          case 7: //double\n            if (0 === tc) {\n              t = dt;\n            }\n            else {\n              t = dt - 2 * tc + 1;\n            }\n            break;\n          default:\n            t = dt;\n            break;\n        }\n        return t;\n      },\n\n      getOnePixel: function(block, blockPtr, offsetType, view) {\n        var temp = 0;\n        switch (offsetType) {\n          case 0: //char\n            temp = view.getInt8(blockPtr);\n            break;\n          case 1: //byte\n            temp = view.getUint8(blockPtr);\n            break;\n          case 2:\n            temp = view.getInt16(blockPtr, true);\n            break;\n          case 3:\n            temp = view.getUint16(blockPtr, true);\n            break;\n          case 4:\n            temp = view.getInt32(blockPtr, true);\n            break;\n          case 5:\n            temp = view.getUInt32(blockPtr, true);\n            break;\n          case 6:\n            temp = view.getFloat32(blockPtr, true);\n            break;\n          case 7:\n            //temp = view.getFloat64(blockPtr, true);\n            //blockPtr += 8;\n            //lerc2 encoding doesnt handle float 64, force to float32???\n            temp = view.getFloat64(blockPtr, true);\n            break;\n          default:\n            throw ("the decoder does not understand this pixel type");\n        }\n        return temp;\n      }\n    };\n\n    /***************************************************\n    *private class for a tree node. Huffman code is in Lerc2Helpers\n    ****************************************************/\n    var TreeNode = function(val, left, right) {\n      this.val = val;\n      this.left = left;\n      this.right = right;\n    };\n\n    var Lerc2Decode = {\n      /*\n      * ********removed options compared to LERC1. We can bring some of them back if needed.\n       * removed pixel type. LERC2 is typed and doesn\'t require user to give pixel type\n       * changed encodedMaskData to maskData. LERC2 \'s js version make it faster to use maskData directly.\n       * removed returnMask. mask is used by LERC2 internally and is cost free. In case of user input mask, it\'s returned as well and has neglible cost.\n       * removed nodatavalue. Because LERC2 pixels are typed, nodatavalue will sacrify a useful value for many types (8bit, 16bit) etc,\n       *       user has to be knowledgable enough about raster and their data to avoid usability issues. so nodata value is simply removed now.\n       *       We can add it back later if their\'s a clear requirement.\n       * removed encodedMask. This option was not implemented in LercDecode. It can be done after decoding (less efficient)\n       * removed computeUsedBitDepths.\n       *\n       *\n       * response changes compared to LERC1\n       * 1. encodedMaskData is not available\n       * 2. noDataValue is optional (returns only if user\'s noDataValue is with in the valid data type range)\n       * 3. maskData is always available\n      */\n      /*****************\n      *  public properties\n      ******************/\n      //HUFFMAN_LUT_BITS_MAX: 12, //use 2^12 lut, not configurable\n\n      /*****************\n      *  public methods\n      *****************/\n\n      /**\n       * Decode a LERC2 byte stream and return an object containing the pixel data and optional metadata.\n       *\n       * @param {ArrayBuffer} input The LERC input byte stream\n       * @param {object} [options] options Decoding options\n       * @param {number} [options.inputOffset] The number of bytes to skip in the input byte stream. A valid LERC file is expected at that position\n       * @param {boolean} [options.returnFileInfo] If true, the return value will have a fileInfo property that contains metadata obtained from the LERC headers and the decoding process\n       */\n      decode: function(/*byte array*/ input, /*object*/ options) {\n        //currently there\'s a bug in the sparse array, so please do not set to false\n        options = options || {};\n        var noDataValue = options.noDataValue;\n\n        //initialize\n        var i = 0, data = {};\n        data.ptr = options.inputOffset || 0;\n        data.pixels = {};\n\n        // File header\n        if (!Lerc2Helpers.readHeaderInfo(input, data)) ;\n        var headerInfo = data.headerInfo;\n        var fileVersion = headerInfo.fileVersion;\n        var OutPixelTypeArray = Lerc2Helpers.getDataTypeArray(headerInfo.imageType);\n\n        // Mask Header\n        Lerc2Helpers.readMask(input, data);\n        if (headerInfo.numValidPixel !== headerInfo.width * headerInfo.height && !data.pixels.resultMask) {\n          data.pixels.resultMask = options.maskData;\n        }\n\n        var numPixels = headerInfo.width * headerInfo.height;\n        data.pixels.resultPixels = new OutPixelTypeArray(numPixels * headerInfo.numDims);\n\n        data.counter = {\n          onesweep: 0,\n          uncompressed: 0,\n          lut: 0,\n          bitstuffer: 0,\n          constant: 0,\n          constantoffset: 0\n        };\n        if (headerInfo.numValidPixel !== 0) {\n          //not tested\n          if (headerInfo.zMax === headerInfo.zMin) //constant surface\n          {\n            Lerc2Helpers.constructConstantSurface(data);\n          }\n          else if (fileVersion >= 4 && Lerc2Helpers.checkMinMaxRanges(input, data)) {\n            Lerc2Helpers.constructConstantSurface(data);\n          }\n          else {\n            var view = new DataView(input, data.ptr, 2);\n            var bReadDataOneSweep = view.getUint8(0);\n            data.ptr++;\n            if (bReadDataOneSweep) {\n              //console.debug("OneSweep");\n              Lerc2Helpers.readDataOneSweep(input, data, OutPixelTypeArray);\n            }\n            else {\n              //lerc2.1: //bitstuffing + lut\n              //lerc2.2: //bitstuffing + lut + huffman\n              //lerc2.3: new bitstuffer\n              if (fileVersion > 1 && headerInfo.imageType <= 1 && Math.abs(headerInfo.maxZError - 0.5) < 0.00001) {\n                //this is 2.x plus 8 bit (unsigned and signed) data, possiblity of Huffman\n                var flagHuffman = view.getUint8(1);\n                data.ptr++;\n                data.encodeMode = flagHuffman;\n                if (flagHuffman > 2 || (fileVersion < 4 && flagHuffman > 1)) {\n                  throw "Invalid Huffman flag " + flagHuffman;\n                }\n                if (flagHuffman) {//1 - delta Huffman, 2 - Huffman\n                  //console.log("Huffman");\n                  Lerc2Helpers.readHuffman(input, data, OutPixelTypeArray);\n                }\n                else {\n                  //console.log("Tiles");\n                  Lerc2Helpers.readTiles(input, data, OutPixelTypeArray);\n                }\n              }\n              else { //lerc2.x non-8 bit data\n                //console.log("Tiles");\n                Lerc2Helpers.readTiles(input, data, OutPixelTypeArray);\n              }\n            }\n          }\n        }\n\n        data.eofOffset = data.ptr;\n        var diff;\n        if (options.inputOffset) {\n          diff = data.headerInfo.blobSize + options.inputOffset - data.ptr;\n          if (Math.abs(diff) >= 1) {\n            //console.debug("incorrect eof: dataptr " + data.ptr + " offset " + options.inputOffset + " blobsize " + data.headerInfo.blobSize + " diff: " + diff);\n            data.eofOffset = options.inputOffset + data.headerInfo.blobSize;\n          }\n        }\n        else {\n          diff = data.headerInfo.blobSize - data.ptr;\n          if (Math.abs(diff) >= 1) {\n            //console.debug("incorrect first band eof: dataptr " + data.ptr + " blobsize " + data.headerInfo.blobSize + " diff: " + diff);\n            data.eofOffset = data.headerInfo.blobSize;\n          }\n        }\n\n        var result = {\n          width: headerInfo.width,\n          height: headerInfo.height,\n          pixelData: data.pixels.resultPixels,\n          minValue: headerInfo.zMin,\n          maxValue: headerInfo.zMax,\n          validPixelCount: headerInfo.numValidPixel,\n          dimCount: headerInfo.numDims,\n          dimStats: {\n            minValues: headerInfo.minValues,\n            maxValues: headerInfo.maxValues\n          },\n          maskData: data.pixels.resultMask\n          //noDataValue: noDataValue\n        };\n\n        //we should remove this if there\'s no existing client\n        //optional noDataValue processing, it\'s user\'s responsiblity\n        if (data.pixels.resultMask && Lerc2Helpers.isValidPixelValue(headerInfo.imageType, noDataValue)) {\n          var mask = data.pixels.resultMask;\n          for (i = 0; i < numPixels; i++) {\n            if (!mask[i]) {\n              result.pixelData[i] = noDataValue;\n            }\n          }\n          result.noDataValue = noDataValue;\n        }\n        data.noDataValue = noDataValue;\n        if (options.returnFileInfo) {\n          result.fileInfo = Lerc2Helpers.formatFileInfo(data);\n        }\n        return result;\n      },\n\n      getBandCount: function(/*byte array*/ input) {\n        var count = 0;\n        var i = 0;\n        var temp = {};\n        temp.ptr = 0;\n        temp.pixels = {};\n        while (i < input.byteLength - 58) {\n          Lerc2Helpers.readHeaderInfo(input, temp);\n          i += temp.headerInfo.blobSize;\n          count++;\n          temp.ptr = i;\n        }\n        return count;\n      }\n    };\n\n    return Lerc2Decode;\n  })();\n\n  var isPlatformLittleEndian = (function() {\n    var a = new ArrayBuffer(4);\n    var b = new Uint8Array(a);\n    var c = new Uint32Array(a);\n    c[0] = 1;\n    return b[0] === 1;\n  })();\n\n  var Lerc = {\n    /************wrapper**********************************************/\n    /**\n     * A wrapper for decoding both LERC1 and LERC2 byte streams capable of handling multiband pixel blocks for various pixel types.\n     *\n     * @alias module:Lerc\n     * @param {ArrayBuffer} input The LERC input byte stream\n     * @param {object} [options] The decoding options below are optional.\n     * @param {number} [options.inputOffset] The number of bytes to skip in the input byte stream. A valid Lerc file is expected at that position.\n     * @param {string} [options.pixelType] (LERC1 only) Default value is F32. Valid pixel types for input are U8/S8/S16/U16/S32/U32/F32.\n     * @param {number} [options.noDataValue] (LERC1 only). It is recommended to use the returned mask instead of setting this value.\n     * @returns {{width, height, pixels, pixelType, mask, statistics}}\n       * @property {number} width Width of decoded image.\n       * @property {number} height Height of decoded image.\n       * @property {array} pixels [band1, band2, ] Each band is a typed array of width*height.\n       * @property {string} pixelType The type of pixels represented in the output.\n       * @property {mask} mask Typed array with a size of width*height, or null if all pixels are valid.\n       * @property {array} statistics [statistics_band1, statistics_band2, ] Each element is a statistics object representing min and max values\n    **/\n    decode: function(encodedData, options) {\n      if (!isPlatformLittleEndian) {\n        throw "Big endian system is not supported.";\n      }\n      options = options || {};\n      var inputOffset = options.inputOffset || 0;\n      var fileIdView = new Uint8Array(encodedData, inputOffset, 10);\n      var fileIdentifierString = String.fromCharCode.apply(null, fileIdView);\n      var lerc, majorVersion;\n      if (fileIdentifierString.trim() === "CntZImage") {\n        lerc = LercDecode;\n        majorVersion = 1;\n      }\n      else if (fileIdentifierString.substring(0, 5) === "Lerc2") {\n        lerc = Lerc2Decode;\n        majorVersion = 2;\n      }\n      else {\n        throw "Unexpected file identifier string: " + fileIdentifierString;\n      }\n\n      var iPlane = 0, eof = encodedData.byteLength - 10, encodedMaskData, bandMasks = [], bandMask, maskData;\n      var decodedPixelBlock = {\n        width: 0,\n        height: 0,\n        pixels: [],\n        pixelType: options.pixelType,\n        mask: null,\n        statistics: []\n      };\n\n      while (inputOffset < eof) {\n        var result = lerc.decode(encodedData, {\n          inputOffset: inputOffset,//for both lerc1 and lerc2\n          encodedMaskData: encodedMaskData,//lerc1 only\n          maskData: maskData,//lerc2 only\n          returnMask: iPlane === 0 ? true : false,//lerc1 only\n          returnEncodedMask: iPlane === 0 ? true : false,//lerc1 only\n          returnFileInfo: true,//for both lerc1 and lerc2\n          pixelType: options.pixelType || null,//lerc1 only\n          noDataValue: options.noDataValue || null//lerc1 only\n        });\n\n        inputOffset = result.fileInfo.eofOffset;\n        if (iPlane === 0) {\n          encodedMaskData = result.encodedMaskData;//lerc1\n          maskData = result.maskData;//lerc2\n          decodedPixelBlock.width = result.width;\n          decodedPixelBlock.height = result.height;\n          decodedPixelBlock.dimCount = result.dimCount || 1;\n          //decodedPixelBlock.dimStats = decodedPixelBlock.dimStats;\n          decodedPixelBlock.pixelType = result.pixelType || result.fileInfo.pixelType;\n          decodedPixelBlock.mask = result.maskData;\n        }\n        if (majorVersion >1 && result.fileInfo.mask && result.fileInfo.mask.numBytes > 0) {\n          bandMasks.push(result.maskData);\n        }\n\n        iPlane++;\n        decodedPixelBlock.pixels.push(result.pixelData);\n        decodedPixelBlock.statistics.push({\n          minValue: result.minValue,\n          maxValue: result.maxValue,\n          noDataValue: result.noDataValue,\n          dimStats: result.dimStats\n        });\n      }\n      var i, j, numPixels;\n      if (majorVersion > 1 && bandMasks.length > 1) {\n        numPixels = decodedPixelBlock.width * decodedPixelBlock.height;\n        decodedPixelBlock.bandMasks = bandMasks;\n        maskData = new Uint8Array(numPixels);\n        maskData.set(bandMasks[0]);\n        for (i = 1; i < bandMasks.length; i++) {\n          bandMask = bandMasks[i];\n          for (j = 0; j < numPixels; j++) {\n            maskData[j] = maskData[j] & bandMask[j];\n          }\n        }\n        decodedPixelBlock.maskData = maskData;\n      }\n\n      return decodedPixelBlock;\n    }\n  };\n\n  if (module.exports) {/* jshint ignore:line */\n    //commonJS module 1.0/1.1/1.1.1 systems, such as nodeJS\n    //http://wiki.commonjs.org/wiki/Modules\n    module.exports = Lerc;/* jshint ignore:line */\n  }\n  else {\n    //assign to this, most likely window\n    this.Lerc = Lerc;\n  }\n\n})();\n});\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNDAyMTIuanMiLCJtYXBwaW5ncyI6Ijs7QUFBQTtBQUMyRTs7QUFFM0UsaUJBQWlCLCtEQUFvQjtBQUNyQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSw2RkFBNkY7O0FBRTdGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUEsNERBQTREOztBQUU1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsYUFBYTtBQUM1QixlQUFlLFFBQVE7QUFDdkIsZ0JBQWdCLFFBQVE7QUFDeEI7QUFDQSxnQkFBZ0IsWUFBWTtBQUM1QjtBQUNBO0FBQ0EsZ0JBQWdCLFFBQVE7QUFDeEI7QUFDQSxnQkFBZ0IsdUJBQXVCO0FBQ3ZDO0FBQ0E7QUFDQSxnQkFBZ0IsU0FBUztBQUN6QjtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsU0FBUztBQUN6QjtBQUNBO0FBQ0EsZ0JBQWdCLFNBQVM7QUFDekI7QUFDQTtBQUNBLGdCQUFnQixTQUFTO0FBQ3pCO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHNCQUFzQixXQUFXO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLFdBQVc7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EseUJBQXlCLHNCQUFzQjtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLHFCQUFxQjtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsc0JBQXNCO0FBQ2pELDZCQUE2QixxQkFBcUI7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsc0JBQXNCO0FBQ2pELDZCQUE2QixxQkFBcUI7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsZUFBZTtBQUNyQztBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCLGNBQWM7QUFDZDtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0RkFBNEY7QUFDNUY7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLDJCQUEyQjtBQUN0RCw2QkFBNkIsMkJBQTJCOztBQUV4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkM7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDO0FBQzlDLGNBQWM7QUFDZCxxREFBcUQ7QUFDckQsY0FBYztBQUNkLHVEQUF1RDtBQUN2RCxjQUFjO0FBQ2Q7QUFDQTs7QUFFQTtBQUNBLGdEQUFnRDtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLDREQUE0RDtBQUM1RCxnQkFBZ0I7QUFDaEIsbUVBQW1FO0FBQ25FLGdCQUFnQjtBQUNoQixtRUFBbUU7QUFDbkUsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsa0JBQWtCLGVBQWU7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixlQUFlO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixlQUFlO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG9CQUFvQixlQUFlO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLGVBQWU7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixlQUFlO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0EsZ0RBQWdEO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsZUFBZTtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBLDhDQUE4QztBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsb0JBQW9CLGVBQWU7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsZUFBZTtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBLDhDQUE4QztBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZOztBQUVaO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlEQUF5RDtBQUN6RDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxxREFBcUQ7QUFDckQsb0RBQW9EO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLHdCQUF3QjtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QjtBQUM5QixjQUFjO0FBQ2Q7QUFDQTtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsc0JBQXNCLGVBQWU7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLGFBQWE7QUFDbkM7QUFDQSwwQkFBMEIsZUFBZTtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixlQUFlO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0EsT0FBTzs7QUFFUDtBQUNBLGtEQUFrRDtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEI7QUFDNUI7O0FBRUEscUJBQXFCLFFBQVE7QUFDN0Isd0NBQXdDO0FBQ3hDLDJCQUEyQjtBQUMzQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscURBQXFEO0FBQ3JEO0FBQ0E7QUFDQSxxQkFBcUIsUUFBUTtBQUM3Qix3Q0FBd0M7QUFDeEM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isc0JBQXNCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsUUFBUTtBQUM3Qix3Q0FBd0M7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLGdCQUFnQjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxTQUFTO0FBQzFDLDhDQUE4QztBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QiwyQkFBMkI7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtFQUFrRTtBQUNsRSwrQkFBK0IsWUFBWTtBQUMzQywwQkFBMEIsV0FBVztBQUNyQztBQUNBO0FBQ0EscUNBQXFDO0FBQ3JDO0FBQ0E7QUFDQSx1Q0FBdUM7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QztBQUN2QztBQUNBO0FBQ0EseUNBQXlDO0FBQ3pDO0FBQ0E7QUFDQSwrQkFBK0IsaUJBQWlCO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQztBQUNqQywwQ0FBMEM7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQiwrQkFBK0IsWUFBWTtBQUMzQywwQkFBMEIsV0FBVztBQUNyQztBQUNBO0FBQ0E7QUFDQSx1Q0FBdUM7QUFDdkM7QUFDQTtBQUNBLHlDQUF5QztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDO0FBQ3pDO0FBQ0E7QUFDQSwyQ0FBMkM7QUFDM0M7QUFDQTtBQUNBLGlDQUFpQyxpQkFBaUI7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG1DQUFtQztBQUNuQyw0Q0FBNEM7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNEQUFzRDtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJEQUEyRDtBQUMzRDtBQUNBO0FBQ0E7QUFDQSxtREFBbUQ7QUFDbkQsWUFBWTtBQUNaLDBEQUEwRDtBQUMxRCxZQUFZO0FBQ1osMERBQTBEO0FBQzFELFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixxQkFBcUI7QUFDOUM7QUFDQSwyQkFBMkIscUJBQXFCO0FBQ2hEO0FBQ0E7O0FBRUE7QUFDQTs7O0FBR0EsMkJBQTJCLGdCQUFnQjtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRDtBQUNwRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyx1QkFBdUI7QUFDdkQsa0NBQWtDLHNCQUFzQjtBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCLGdDQUFnQyx1QkFBdUI7QUFDdkQsa0NBQWtDLHNCQUFzQjtBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyx1QkFBdUI7QUFDekQsb0NBQW9DLHNCQUFzQjtBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0MsdUJBQXVCO0FBQ3pELG9DQUFvQyxzQkFBc0I7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0MsdUJBQXVCO0FBQ3pELG9DQUFvQyxzQkFBc0I7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLHVCQUF1QjtBQUN6RCxvQ0FBb0Msc0JBQXNCO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLGFBQWE7QUFDbkM7QUFDQSwwQkFBMEIsZUFBZTtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixlQUFlO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IscUJBQXFCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLGFBQWE7QUFDOUIsaUJBQWlCLFFBQVE7QUFDekIsaUJBQWlCLFFBQVE7QUFDekIsaUJBQWlCLFNBQVM7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixlQUFlO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLGFBQWE7QUFDNUIsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCLGtCQUFrQjtBQUNsQixvQkFBb0IsUUFBUTtBQUM1QixvQkFBb0IsUUFBUTtBQUM1QixvQkFBb0IsT0FBTztBQUMzQixvQkFBb0IsUUFBUTtBQUM1QixvQkFBb0IsTUFBTTtBQUMxQixvQkFBb0IsT0FBTztBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0EsbURBQW1EO0FBQ25ELHFDQUFxQztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixzQkFBc0I7QUFDMUM7QUFDQSxzQkFBc0IsZUFBZTtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLENBQUM7QUFDRCxDQUFDOztBQUVnQyIsInNvdXJjZXMiOlsid2VicGFjazovL3Z1ZTMtd2VicGFjazUvLi9ub2RlX21vZHVsZXMvY2VzaXVtL1NvdXJjZS9UaGlyZFBhcnR5L2xlcmMuanM/ZmQ5YyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiBUaGlzIGZpbGUgaXMgYXV0b21hdGljYWxseSByZWJ1aWx0IGJ5IHRoZSBDZXNpdW0gYnVpbGQgcHJvY2Vzcy4gKi9cbmltcG9ydCB7IGMgYXMgY3JlYXRlQ29tbW9uanNNb2R1bGUgfSBmcm9tICcuL19jb21tb25qc0hlbHBlcnMtM2FhZTEwMzIuanMnO1xuXG52YXIgTGVyY0RlY29kZSA9IGNyZWF0ZUNvbW1vbmpzTW9kdWxlKGZ1bmN0aW9uIChtb2R1bGUpIHtcbi8qIGpzaGludCBmb3JpbjogZmFsc2UsIGJpdHdpc2U6IGZhbHNlICovXG4vKlxuQ29weXJpZ2h0IDIwMTUtMjAxOCBFc3JpXG5cbkxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG55b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG5Zb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcblxuaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG5cblVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbmRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbldJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxubGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5cbkEgY29weSBvZiB0aGUgbGljZW5zZSBhbmQgYWRkaXRpb25hbCBub3RpY2VzIGFyZSBsb2NhdGVkIHdpdGggdGhlXG5zb3VyY2UgZGlzdHJpYnV0aW9uIGF0OlxuXG5odHRwOi8vZ2l0aHViLmNvbS9Fc3JpL2xlcmMvXG5cbkNvbnRyaWJ1dG9yczogIEpvaGFubmVzIFNjaG1pZCwgKExFUkMgdjEpXG4gICAgICAgICAgICAgICBDaGF5YW5pa2EgS2hhdHVhLCAoTEVSQyB2MSlcbiAgICAgICAgICAgICAgIFdlbnh1ZSBKdSAoTEVSQyB2MSwgdjIueClcbiovXG5cbi8qIENvcHlyaWdodCAyMDE1LTIwMTggRXNyaS4gTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXQgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wIEBwcmVzZXJ2ZSAqL1xuXG4vKipcbiAqIGEgbW9kdWxlIGZvciBkZWNvZGluZyBMRVJDIGJsb2JzXG4gKiBAbW9kdWxlIExlcmNcbiAqL1xuKGZ1bmN0aW9uKCkge1xuICAvL3RoZSBvcmlnaW5hbCBMZXJjRGVjb2RlIGZvciBWZXJzaW9uIDFcbiAgdmFyIExlcmNEZWNvZGUgPSAoZnVuY3Rpb24oKSB7XG5cbiAgICAvLyBXQVJOSU5HOiBUaGlzIGRlY29kZXIgdmVyc2lvbiBjYW4gb25seSByZWFkIG9sZCB2ZXJzaW9uIDEgTGVyYyBibG9icy4gVXNlIHdpdGggY2F1dGlvbi5cblxuICAgIC8vIE5vdGU6IGN1cnJlbnRseSwgdGhpcyBtb2R1bGUgb25seSBoYXMgYW4gaW1wbGVtZW50YXRpb24gZm9yIGRlY29kaW5nIExFUkMgZGF0YSwgbm90IGVuY29kaW5nLiBUaGUgbmFtZSBvZlxuICAgIC8vIHRoZSBjbGFzcyB3YXMgY2hvc2VuIHRvIGJlIGZ1dHVyZSBwcm9vZi5cblxuICAgIHZhciBDbnRaSW1hZ2UgPSB7fTtcblxuICAgIENudFpJbWFnZS5kZWZhdWx0Tm9EYXRhVmFsdWUgPSAtMy40MDI3OTk5Mzg3OTAxNDg0ZSszODsgLy8gc21hbGxlc3QgRmxvYXQzMiB2YWx1ZVxuXG4gICAgLyoqXG4gICAgICogRGVjb2RlIGEgTEVSQyBieXRlIHN0cmVhbSBhbmQgcmV0dXJuIGFuIG9iamVjdCBjb250YWluaW5nIHRoZSBwaXhlbCBkYXRhIGFuZCBzb21lIHJlcXVpcmVkIGFuZCBvcHRpb25hbFxuICAgICAqIGluZm9ybWF0aW9uIGFib3V0IGl0LCBzdWNoIGFzIHRoZSBpbWFnZSdzIHdpZHRoIGFuZCBoZWlnaHQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0FycmF5QnVmZmVyfSBpbnB1dCBUaGUgTEVSQyBpbnB1dCBieXRlIHN0cmVhbVxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBbb3B0aW9uc10gRGVjb2Rpbmcgb3B0aW9ucywgY29udGFpbmluZyBhbnkgb2YgdGhlIGZvbGxvd2luZyBwcm9wZXJ0aWVzOlxuICAgICAqIEBjb25maWcge251bWJlcn0gW2lucHV0T2Zmc2V0ID0gMF1cbiAgICAgKiAgICAgICAgU2tpcCB0aGUgZmlyc3QgaW5wdXRPZmZzZXQgYnl0ZXMgb2YgdGhlIGlucHV0IGJ5dGUgc3RyZWFtLiBBIHZhbGlkIExFUkMgZmlsZSBpcyBleHBlY3RlZCBhdCB0aGF0IHBvc2l0aW9uLlxuICAgICAqIEBjb25maWcge1VpbnQ4QXJyYXl9IFtlbmNvZGVkTWFzayA9IG51bGxdXG4gICAgICogICAgICAgIElmIHNwZWNpZmllZCwgdGhlIGRlY29kZXIgd2lsbCBub3QgcmVhZCBtYXNrIGluZm9ybWF0aW9uIGZyb20gdGhlIGlucHV0IGFuZCB1c2UgdGhlIHNwZWNpZmllZCBlbmNvZGVkXG4gICAgICogICAgICAgIG1hc2sgZGF0YSBpbnN0ZWFkLiBNYXNrIGhlYWRlci9kYXRhIG11c3Qgbm90IGJlIHByZXNlbnQgaW4gdGhlIExFUkMgYnl0ZSBzdHJlYW0gaW4gdGhpcyBjYXNlLlxuICAgICAqIEBjb25maWcge251bWJlcn0gW25vRGF0YVZhbHVlID0gTGVyY0NvZGUuZGVmYXVsdE5vRGF0YVZhbHVlXVxuICAgICAqICAgICAgICBQaXhlbCB2YWx1ZSB0byB1c2UgZm9yIG1hc2tlZCBwaXhlbHMuXG4gICAgICogQGNvbmZpZyB7QXJyYXlCdWZmZXJWaWV3fEFycmF5fSBbcGl4ZWxUeXBlID0gRmxvYXQzMkFycmF5XVxuICAgICAqICAgICAgICBUaGUgZGVzaXJlZCB0eXBlIG9mIHRoZSBwaXhlbERhdGEgYXJyYXkgaW4gdGhlIHJldHVybiB2YWx1ZS4gTm90ZSB0aGF0IGl0IGlzIHRoZSBjYWxsZXIncyByZXNwb25zaWJpbGl0eSB0b1xuICAgICAqICAgICAgICBwcm92aWRlIGFuIGFwcHJvcHJpYXRlIG5vRGF0YVZhbHVlIGlmIHRoZSBkZWZhdWx0IHBpeGVsVHlwZSBpcyBvdmVycmlkZGVuLlxuICAgICAqIEBjb25maWcge2Jvb2xlYW59IFtyZXR1cm5NYXNrID0gZmFsc2VdXG4gICAgICogICAgICAgIElmIHRydWUsIHRoZSByZXR1cm4gdmFsdWUgd2lsbCBjb250YWluIGEgbWFza0RhdGEgcHJvcGVydHkgb2YgdHlwZSBVaW50OEFycmF5IHdoaWNoIGhhcyBvbmUgZWxlbWVudCBwZXJcbiAgICAgKiAgICAgICAgcGl4ZWwsIHRoZSB2YWx1ZSBvZiB3aGljaCBpcyAxIG9yIDAgZGVwZW5kaW5nIG9uIHdoZXRoZXIgdGhhdCBwaXhlbCdzIGRhdGEgaXMgcHJlc2VudCBvciBtYXNrZWQuIElmIHRoZVxuICAgICAqICAgICAgICBpbnB1dCBMRVJDIGRhdGEgZG9lcyBub3QgY29udGFpbiBhIG1hc2ssIG1hc2tEYXRhIHdpbGwgbm90IGJlIHJldHVybmVkLlxuICAgICAqIEBjb25maWcge2Jvb2xlYW59IFtyZXR1cm5FbmNvZGVkTWFzayA9IGZhbHNlXVxuICAgICAqICAgICAgICBJZiB0cnVlLCB0aGUgcmV0dXJuIHZhbHVlIHdpbGwgY29udGFpbiBhIGVuY29kZWRNYXNrRGF0YSBwcm9wZXJ0eSwgd2hpY2ggY2FuIGJlIHBhc3NlZCBpbnRvIGVuY29kZSgpIGFzXG4gICAgICogICAgICAgIGVuY29kZWRNYXNrLlxuICAgICAqIEBjb25maWcge2Jvb2xlYW59IFtyZXR1cm5GaWxlSW5mbyA9IGZhbHNlXVxuICAgICAqICAgICAgICBJZiB0cnVlLCB0aGUgcmV0dXJuIHZhbHVlIHdpbGwgaGF2ZSBhIGZpbGVJbmZvIHByb3BlcnR5IHRoYXQgY29udGFpbnMgbWV0YWRhdGEgb2J0YWluZWQgZnJvbSB0aGVcbiAgICAgKiAgICAgICAgTEVSQyBoZWFkZXJzIGFuZCB0aGUgZGVjb2RpbmcgcHJvY2Vzcy5cbiAgICAgKiBAY29uZmlnIHtib29sZWFufSBbY29tcHV0ZVVzZWRCaXREZXB0aHMgPSBmYWxzZV1cbiAgICAgKiAgICAgICAgSWYgdHJ1ZSwgdGhlIGZpbGVJbmZvIHByb3BlcnR5IGluIHRoZSByZXR1cm4gdmFsdWUgd2lsbCBjb250YWluIHRoZSBzZXQgb2YgYWxsIGJsb2NrIGJpdCBkZXB0aHNcbiAgICAgKiAgICAgICAgZW5jb3VudGVyZWQgZHVyaW5nIGRlY29kaW5nLiBXaWxsIG9ubHkgaGF2ZSBhbiBlZmZlY3QgaWYgcmV0dXJuRmlsZUluZm8gb3B0aW9uIGlzIHRydWUuXG4gICAgICogQHJldHVybnMge3t3aWR0aCwgaGVpZ2h0LCBwaXhlbERhdGEsIG1pblZhbHVlLCBtYXhWYWx1ZSwgbm9EYXRhVmFsdWUsIG1hc2tEYXRhLCBlbmNvZGVkTWFza0RhdGEsIGZpbGVJbmZvfX1cbiAgICAgKi9cbiAgICBDbnRaSW1hZ2UuZGVjb2RlID0gZnVuY3Rpb24oaW5wdXQsIG9wdGlvbnMpIHtcbiAgICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gICAgICB2YXIgc2tpcE1hc2sgPSBvcHRpb25zLmVuY29kZWRNYXNrRGF0YSB8fCAob3B0aW9ucy5lbmNvZGVkTWFza0RhdGEgPT09IG51bGwpO1xuICAgICAgdmFyIHBhcnNlZERhdGEgPSBwYXJzZShpbnB1dCwgb3B0aW9ucy5pbnB1dE9mZnNldCB8fCAwLCBza2lwTWFzayk7XG5cbiAgICAgIHZhciBub0RhdGFWYWx1ZSA9IChvcHRpb25zLm5vRGF0YVZhbHVlICE9PSBudWxsKSA/IG9wdGlvbnMubm9EYXRhVmFsdWUgOiBDbnRaSW1hZ2UuZGVmYXVsdE5vRGF0YVZhbHVlO1xuXG4gICAgICB2YXIgdW5jb21wcmVzc2VkRGF0YSA9IHVuY29tcHJlc3NQaXhlbFZhbHVlcyhwYXJzZWREYXRhLCBvcHRpb25zLnBpeGVsVHlwZSB8fCBGbG9hdDMyQXJyYXksXG4gICAgICAgIG9wdGlvbnMuZW5jb2RlZE1hc2tEYXRhLCBub0RhdGFWYWx1ZSwgb3B0aW9ucy5yZXR1cm5NYXNrKTtcblxuICAgICAgdmFyIHJlc3VsdCA9IHtcbiAgICAgICAgd2lkdGg6IHBhcnNlZERhdGEud2lkdGgsXG4gICAgICAgIGhlaWdodDogcGFyc2VkRGF0YS5oZWlnaHQsXG4gICAgICAgIHBpeGVsRGF0YTogdW5jb21wcmVzc2VkRGF0YS5yZXN1bHRQaXhlbHMsXG4gICAgICAgIG1pblZhbHVlOiB1bmNvbXByZXNzZWREYXRhLm1pblZhbHVlLFxuICAgICAgICBtYXhWYWx1ZTogcGFyc2VkRGF0YS5waXhlbHMubWF4VmFsdWUsXG4gICAgICAgIG5vRGF0YVZhbHVlOiBub0RhdGFWYWx1ZVxuICAgICAgfTtcblxuICAgICAgaWYgKHVuY29tcHJlc3NlZERhdGEucmVzdWx0TWFzaykge1xuICAgICAgICByZXN1bHQubWFza0RhdGEgPSB1bmNvbXByZXNzZWREYXRhLnJlc3VsdE1hc2s7XG4gICAgICB9XG5cbiAgICAgIGlmIChvcHRpb25zLnJldHVybkVuY29kZWRNYXNrICYmIHBhcnNlZERhdGEubWFzaykge1xuICAgICAgICByZXN1bHQuZW5jb2RlZE1hc2tEYXRhID0gcGFyc2VkRGF0YS5tYXNrLmJpdHNldCA/IHBhcnNlZERhdGEubWFzay5iaXRzZXQgOiBudWxsO1xuICAgICAgfVxuXG4gICAgICBpZiAob3B0aW9ucy5yZXR1cm5GaWxlSW5mbykge1xuICAgICAgICByZXN1bHQuZmlsZUluZm8gPSBmb3JtYXRGaWxlSW5mbyhwYXJzZWREYXRhKTtcbiAgICAgICAgaWYgKG9wdGlvbnMuY29tcHV0ZVVzZWRCaXREZXB0aHMpIHtcbiAgICAgICAgICByZXN1bHQuZmlsZUluZm8uYml0RGVwdGhzID0gY29tcHV0ZVVzZWRCaXREZXB0aHMocGFyc2VkRGF0YSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuXG4gICAgdmFyIHVuY29tcHJlc3NQaXhlbFZhbHVlcyA9IGZ1bmN0aW9uKGRhdGEsIFR5cGVkQXJyYXlDbGFzcywgbWFza0JpdHNldCwgbm9EYXRhVmFsdWUsIHN0b3JlRGVjb2RlZE1hc2spIHtcbiAgICAgIHZhciBibG9ja0lkeCA9IDA7XG4gICAgICB2YXIgbnVtWCA9IGRhdGEucGl4ZWxzLm51bUJsb2Nrc1g7XG4gICAgICB2YXIgbnVtWSA9IGRhdGEucGl4ZWxzLm51bUJsb2Nrc1k7XG4gICAgICB2YXIgYmxvY2tXaWR0aCA9IE1hdGguZmxvb3IoZGF0YS53aWR0aCAvIG51bVgpO1xuICAgICAgdmFyIGJsb2NrSGVpZ2h0ID0gTWF0aC5mbG9vcihkYXRhLmhlaWdodCAvIG51bVkpO1xuICAgICAgdmFyIHNjYWxlID0gMiAqIGRhdGEubWF4WkVycm9yO1xuICAgICAgdmFyIG1pblZhbHVlID0gTnVtYmVyLk1BWF9WQUxVRSwgY3VycmVudFZhbHVlO1xuICAgICAgbWFza0JpdHNldCA9IG1hc2tCaXRzZXQgfHwgKChkYXRhLm1hc2spID8gZGF0YS5tYXNrLmJpdHNldCA6IG51bGwpO1xuXG4gICAgICB2YXIgcmVzdWx0UGl4ZWxzLCByZXN1bHRNYXNrO1xuICAgICAgcmVzdWx0UGl4ZWxzID0gbmV3IFR5cGVkQXJyYXlDbGFzcyhkYXRhLndpZHRoICogZGF0YS5oZWlnaHQpO1xuICAgICAgaWYgKHN0b3JlRGVjb2RlZE1hc2sgJiYgbWFza0JpdHNldCkge1xuICAgICAgICByZXN1bHRNYXNrID0gbmV3IFVpbnQ4QXJyYXkoZGF0YS53aWR0aCAqIGRhdGEuaGVpZ2h0KTtcbiAgICAgIH1cbiAgICAgIHZhciBibG9ja0RhdGFCdWZmZXIgPSBuZXcgRmxvYXQzMkFycmF5KGJsb2NrV2lkdGggKiBibG9ja0hlaWdodCk7XG5cbiAgICAgIHZhciB4eCwgeXk7XG4gICAgICBmb3IgKHZhciB5ID0gMDsgeSA8PSBudW1ZOyB5KyspIHtcbiAgICAgICAgdmFyIHRoaXNCbG9ja0hlaWdodCA9ICh5ICE9PSBudW1ZKSA/IGJsb2NrSGVpZ2h0IDogKGRhdGEuaGVpZ2h0ICUgbnVtWSk7XG4gICAgICAgIGlmICh0aGlzQmxvY2tIZWlnaHQgPT09IDApIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKHZhciB4ID0gMDsgeCA8PSBudW1YOyB4KyspIHtcbiAgICAgICAgICB2YXIgdGhpc0Jsb2NrV2lkdGggPSAoeCAhPT0gbnVtWCkgPyBibG9ja1dpZHRoIDogKGRhdGEud2lkdGggJSBudW1YKTtcbiAgICAgICAgICBpZiAodGhpc0Jsb2NrV2lkdGggPT09IDApIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciBvdXRQdHIgPSB5ICogZGF0YS53aWR0aCAqIGJsb2NrSGVpZ2h0ICsgeCAqIGJsb2NrV2lkdGg7XG4gICAgICAgICAgdmFyIG91dFN0cmlkZSA9IGRhdGEud2lkdGggLSB0aGlzQmxvY2tXaWR0aDtcblxuICAgICAgICAgIHZhciBibG9jayA9IGRhdGEucGl4ZWxzLmJsb2Nrc1tibG9ja0lkeF07XG5cbiAgICAgICAgICB2YXIgYmxvY2tEYXRhLCBibG9ja1B0ciwgY29uc3RWYWx1ZTtcbiAgICAgICAgICBpZiAoYmxvY2suZW5jb2RpbmcgPCAyKSB7XG4gICAgICAgICAgICAvLyBibG9jayBpcyBlaXRoZXIgdW5jb21wcmVzc2VkIG9yIGJpdC1zdHVmZmVkIChlbmNvZGluZ3MgMCBhbmQgMSlcbiAgICAgICAgICAgIGlmIChibG9jay5lbmNvZGluZyA9PT0gMCkge1xuICAgICAgICAgICAgICAvLyBibG9jayBpcyB1bmNvbXByZXNzZWRcbiAgICAgICAgICAgICAgYmxvY2tEYXRhID0gYmxvY2sucmF3RGF0YTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIC8vIGJsb2NrIGlzIGJpdC1zdHVmZmVkXG4gICAgICAgICAgICAgIHVuc3R1ZmYoYmxvY2suc3R1ZmZlZERhdGEsIGJsb2NrLmJpdHNQZXJQaXhlbCwgYmxvY2subnVtVmFsaWRQaXhlbHMsIGJsb2NrLm9mZnNldCwgc2NhbGUsIGJsb2NrRGF0YUJ1ZmZlciwgZGF0YS5waXhlbHMubWF4VmFsdWUpO1xuICAgICAgICAgICAgICBibG9ja0RhdGEgPSBibG9ja0RhdGFCdWZmZXI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBibG9ja1B0ciA9IDA7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2UgaWYgKGJsb2NrLmVuY29kaW5nID09PSAyKSB7XG4gICAgICAgICAgICAvLyBibG9jayBpcyBhbGwgMFxuICAgICAgICAgICAgY29uc3RWYWx1ZSA9IDA7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gYmxvY2sgaGFzIGNvbnN0YW50IHZhbHVlIChlbmNvZGluZyA9PT0gMylcbiAgICAgICAgICAgIGNvbnN0VmFsdWUgPSBibG9jay5vZmZzZXQ7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIG1hc2tCeXRlO1xuICAgICAgICAgIGlmIChtYXNrQml0c2V0KSB7XG4gICAgICAgICAgICBmb3IgKHl5ID0gMDsgeXkgPCB0aGlzQmxvY2tIZWlnaHQ7IHl5KyspIHtcbiAgICAgICAgICAgICAgaWYgKG91dFB0ciAmIDcpIHtcbiAgICAgICAgICAgICAgICAvL1xuICAgICAgICAgICAgICAgIG1hc2tCeXRlID0gbWFza0JpdHNldFtvdXRQdHIgPj4gM107XG4gICAgICAgICAgICAgICAgbWFza0J5dGUgPDw9IG91dFB0ciAmIDc7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgZm9yICh4eCA9IDA7IHh4IDwgdGhpc0Jsb2NrV2lkdGg7IHh4KyspIHtcbiAgICAgICAgICAgICAgICBpZiAoIShvdXRQdHIgJiA3KSkge1xuICAgICAgICAgICAgICAgICAgLy8gcmVhZCBuZXh0IGJ5dGUgZnJvbSBtYXNrXG4gICAgICAgICAgICAgICAgICBtYXNrQnl0ZSA9IG1hc2tCaXRzZXRbb3V0UHRyID4+IDNdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAobWFza0J5dGUgJiAxMjgpIHtcbiAgICAgICAgICAgICAgICAgIC8vIHBpeGVsIGRhdGEgcHJlc2VudFxuICAgICAgICAgICAgICAgICAgaWYgKHJlc3VsdE1hc2spIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0TWFza1tvdXRQdHJdID0gMTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIGN1cnJlbnRWYWx1ZSA9IChibG9jay5lbmNvZGluZyA8IDIpID8gYmxvY2tEYXRhW2Jsb2NrUHRyKytdIDogY29uc3RWYWx1ZTtcbiAgICAgICAgICAgICAgICAgIG1pblZhbHVlID0gbWluVmFsdWUgPiBjdXJyZW50VmFsdWUgPyBjdXJyZW50VmFsdWUgOiBtaW5WYWx1ZTtcbiAgICAgICAgICAgICAgICAgIHJlc3VsdFBpeGVsc1tvdXRQdHIrK10gPSBjdXJyZW50VmFsdWU7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIC8vIHBpeGVsIGRhdGEgbm90IHByZXNlbnRcbiAgICAgICAgICAgICAgICAgIGlmIChyZXN1bHRNYXNrKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdE1hc2tbb3V0UHRyXSA9IDA7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICByZXN1bHRQaXhlbHNbb3V0UHRyKytdID0gbm9EYXRhVmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG1hc2tCeXRlIDw8PSAxO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIG91dFB0ciArPSBvdXRTdHJpZGU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIG1hc2sgbm90IHByZXNlbnQsIHNpbXBseSBjb3B5IGJsb2NrIG92ZXJcbiAgICAgICAgICAgIGlmIChibG9jay5lbmNvZGluZyA8IDIpIHtcbiAgICAgICAgICAgICAgLy8gZHVwbGljYXRpbmcgdGhpcyBjb2RlIGJsb2NrIGZvciBwZXJmb3JtYW5jZSByZWFzb25zXG4gICAgICAgICAgICAgIC8vIGJsb2NrRGF0YSBjYXNlOlxuICAgICAgICAgICAgICBmb3IgKHl5ID0gMDsgeXkgPCB0aGlzQmxvY2tIZWlnaHQ7IHl5KyspIHtcbiAgICAgICAgICAgICAgICBmb3IgKHh4ID0gMDsgeHggPCB0aGlzQmxvY2tXaWR0aDsgeHgrKykge1xuICAgICAgICAgICAgICAgICAgY3VycmVudFZhbHVlID0gYmxvY2tEYXRhW2Jsb2NrUHRyKytdO1xuICAgICAgICAgICAgICAgICAgbWluVmFsdWUgPSBtaW5WYWx1ZSA+IGN1cnJlbnRWYWx1ZSA/IGN1cnJlbnRWYWx1ZSA6IG1pblZhbHVlO1xuICAgICAgICAgICAgICAgICAgcmVzdWx0UGl4ZWxzW291dFB0cisrXSA9IGN1cnJlbnRWYWx1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgb3V0UHRyICs9IG91dFN0cmlkZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgIC8vIGNvbnN0VmFsdWUgY2FzZTpcbiAgICAgICAgICAgICAgbWluVmFsdWUgPSBtaW5WYWx1ZSA+IGNvbnN0VmFsdWUgPyBjb25zdFZhbHVlIDogbWluVmFsdWU7XG4gICAgICAgICAgICAgIGZvciAoeXkgPSAwOyB5eSA8IHRoaXNCbG9ja0hlaWdodDsgeXkrKykge1xuICAgICAgICAgICAgICAgIGZvciAoeHggPSAwOyB4eCA8IHRoaXNCbG9ja1dpZHRoOyB4eCsrKSB7XG4gICAgICAgICAgICAgICAgICByZXN1bHRQaXhlbHNbb3V0UHRyKytdID0gY29uc3RWYWx1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgb3V0UHRyICs9IG91dFN0cmlkZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoKGJsb2NrLmVuY29kaW5nID09PSAxKSAmJiAoYmxvY2tQdHIgIT09IGJsb2NrLm51bVZhbGlkUGl4ZWxzKSkge1xuICAgICAgICAgICAgdGhyb3cgXCJCbG9jayBhbmQgTWFzayBkbyBub3QgbWF0Y2hcIjtcbiAgICAgICAgICB9XG4gICAgICAgICAgYmxvY2tJZHgrKztcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4ge1xuICAgICAgICByZXN1bHRQaXhlbHM6IHJlc3VsdFBpeGVscyxcbiAgICAgICAgcmVzdWx0TWFzazogcmVzdWx0TWFzayxcbiAgICAgICAgbWluVmFsdWU6IG1pblZhbHVlXG4gICAgICB9O1xuICAgIH07XG5cbiAgICB2YXIgZm9ybWF0RmlsZUluZm8gPSBmdW5jdGlvbihkYXRhKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBcImZpbGVJZGVudGlmaWVyU3RyaW5nXCI6IGRhdGEuZmlsZUlkZW50aWZpZXJTdHJpbmcsXG4gICAgICAgIFwiZmlsZVZlcnNpb25cIjogZGF0YS5maWxlVmVyc2lvbixcbiAgICAgICAgXCJpbWFnZVR5cGVcIjogZGF0YS5pbWFnZVR5cGUsXG4gICAgICAgIFwiaGVpZ2h0XCI6IGRhdGEuaGVpZ2h0LFxuICAgICAgICBcIndpZHRoXCI6IGRhdGEud2lkdGgsXG4gICAgICAgIFwibWF4WkVycm9yXCI6IGRhdGEubWF4WkVycm9yLFxuICAgICAgICBcImVvZk9mZnNldFwiOiBkYXRhLmVvZk9mZnNldCxcbiAgICAgICAgXCJtYXNrXCI6IGRhdGEubWFzayA/IHtcbiAgICAgICAgICBcIm51bUJsb2Nrc1hcIjogZGF0YS5tYXNrLm51bUJsb2Nrc1gsXG4gICAgICAgICAgXCJudW1CbG9ja3NZXCI6IGRhdGEubWFzay5udW1CbG9ja3NZLFxuICAgICAgICAgIFwibnVtQnl0ZXNcIjogZGF0YS5tYXNrLm51bUJ5dGVzLFxuICAgICAgICAgIFwibWF4VmFsdWVcIjogZGF0YS5tYXNrLm1heFZhbHVlXG4gICAgICAgIH0gOiBudWxsLFxuICAgICAgICBcInBpeGVsc1wiOiB7XG4gICAgICAgICAgXCJudW1CbG9ja3NYXCI6IGRhdGEucGl4ZWxzLm51bUJsb2Nrc1gsXG4gICAgICAgICAgXCJudW1CbG9ja3NZXCI6IGRhdGEucGl4ZWxzLm51bUJsb2Nrc1ksXG4gICAgICAgICAgXCJudW1CeXRlc1wiOiBkYXRhLnBpeGVscy5udW1CeXRlcyxcbiAgICAgICAgICBcIm1heFZhbHVlXCI6IGRhdGEucGl4ZWxzLm1heFZhbHVlLFxuICAgICAgICAgIFwibm9EYXRhVmFsdWVcIjogZGF0YS5ub0RhdGFWYWx1ZVxuICAgICAgICB9XG4gICAgICB9O1xuICAgIH07XG5cbiAgICB2YXIgY29tcHV0ZVVzZWRCaXREZXB0aHMgPSBmdW5jdGlvbihkYXRhKSB7XG4gICAgICB2YXIgbnVtQmxvY2tzID0gZGF0YS5waXhlbHMubnVtQmxvY2tzWCAqIGRhdGEucGl4ZWxzLm51bUJsb2Nrc1k7XG4gICAgICB2YXIgYml0RGVwdGhzID0ge307XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG51bUJsb2NrczsgaSsrKSB7XG4gICAgICAgIHZhciBibG9jayA9IGRhdGEucGl4ZWxzLmJsb2Nrc1tpXTtcbiAgICAgICAgaWYgKGJsb2NrLmVuY29kaW5nID09PSAwKSB7XG4gICAgICAgICAgYml0RGVwdGhzLmZsb2F0MzIgPSB0cnVlO1xuICAgICAgICB9IGVsc2UgaWYgKGJsb2NrLmVuY29kaW5nID09PSAxKSB7XG4gICAgICAgICAgYml0RGVwdGhzW2Jsb2NrLmJpdHNQZXJQaXhlbF0gPSB0cnVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGJpdERlcHRoc1swXSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIE9iamVjdC5rZXlzKGJpdERlcHRocyk7XG4gICAgfTtcblxuICAgIHZhciBwYXJzZSA9IGZ1bmN0aW9uKGlucHV0LCBmcCwgc2tpcE1hc2spIHtcbiAgICAgIHZhciBkYXRhID0ge307XG5cbiAgICAgIC8vIEZpbGUgaGVhZGVyXG4gICAgICB2YXIgZmlsZUlkVmlldyA9IG5ldyBVaW50OEFycmF5KGlucHV0LCBmcCwgMTApO1xuICAgICAgZGF0YS5maWxlSWRlbnRpZmllclN0cmluZyA9IFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkobnVsbCwgZmlsZUlkVmlldyk7XG4gICAgICBpZiAoZGF0YS5maWxlSWRlbnRpZmllclN0cmluZy50cmltKCkgIT09IFwiQ250WkltYWdlXCIpIHtcbiAgICAgICAgdGhyb3cgXCJVbmV4cGVjdGVkIGZpbGUgaWRlbnRpZmllciBzdHJpbmc6IFwiICsgZGF0YS5maWxlSWRlbnRpZmllclN0cmluZztcbiAgICAgIH1cbiAgICAgIGZwICs9IDEwO1xuICAgICAgdmFyIHZpZXcgPSBuZXcgRGF0YVZpZXcoaW5wdXQsIGZwLCAyNCk7XG4gICAgICBkYXRhLmZpbGVWZXJzaW9uID0gdmlldy5nZXRJbnQzMigwLCB0cnVlKTtcbiAgICAgIGRhdGEuaW1hZ2VUeXBlID0gdmlldy5nZXRJbnQzMig0LCB0cnVlKTtcbiAgICAgIGRhdGEuaGVpZ2h0ID0gdmlldy5nZXRVaW50MzIoOCwgdHJ1ZSk7XG4gICAgICBkYXRhLndpZHRoID0gdmlldy5nZXRVaW50MzIoMTIsIHRydWUpO1xuICAgICAgZGF0YS5tYXhaRXJyb3IgPSB2aWV3LmdldEZsb2F0NjQoMTYsIHRydWUpO1xuICAgICAgZnAgKz0gMjQ7XG5cbiAgICAgIC8vIE1hc2sgSGVhZGVyXG4gICAgICBpZiAoIXNraXBNYXNrKSB7XG4gICAgICAgIHZpZXcgPSBuZXcgRGF0YVZpZXcoaW5wdXQsIGZwLCAxNik7XG4gICAgICAgIGRhdGEubWFzayA9IHt9O1xuICAgICAgICBkYXRhLm1hc2subnVtQmxvY2tzWSA9IHZpZXcuZ2V0VWludDMyKDAsIHRydWUpO1xuICAgICAgICBkYXRhLm1hc2subnVtQmxvY2tzWCA9IHZpZXcuZ2V0VWludDMyKDQsIHRydWUpO1xuICAgICAgICBkYXRhLm1hc2subnVtQnl0ZXMgPSB2aWV3LmdldFVpbnQzMig4LCB0cnVlKTtcbiAgICAgICAgZGF0YS5tYXNrLm1heFZhbHVlID0gdmlldy5nZXRGbG9hdDMyKDEyLCB0cnVlKTtcbiAgICAgICAgZnAgKz0gMTY7XG5cbiAgICAgICAgLy8gTWFzayBEYXRhXG4gICAgICAgIGlmIChkYXRhLm1hc2subnVtQnl0ZXMgPiAwKSB7XG4gICAgICAgICAgdmFyIGJpdHNldCA9IG5ldyBVaW50OEFycmF5KE1hdGguY2VpbChkYXRhLndpZHRoICogZGF0YS5oZWlnaHQgLyA4KSk7XG4gICAgICAgICAgdmlldyA9IG5ldyBEYXRhVmlldyhpbnB1dCwgZnAsIGRhdGEubWFzay5udW1CeXRlcyk7XG4gICAgICAgICAgdmFyIGNudCA9IHZpZXcuZ2V0SW50MTYoMCwgdHJ1ZSk7XG4gICAgICAgICAgdmFyIGlwID0gMiwgb3AgPSAwO1xuICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgIGlmIChjbnQgPiAwKSB7XG4gICAgICAgICAgICAgIHdoaWxlIChjbnQtLSkgeyBiaXRzZXRbb3ArK10gPSB2aWV3LmdldFVpbnQ4KGlwKyspOyB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB2YXIgdmFsID0gdmlldy5nZXRVaW50OChpcCsrKTtcbiAgICAgICAgICAgICAgY250ID0gLWNudDtcbiAgICAgICAgICAgICAgd2hpbGUgKGNudC0tKSB7IGJpdHNldFtvcCsrXSA9IHZhbDsgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY250ID0gdmlldy5nZXRJbnQxNihpcCwgdHJ1ZSk7XG4gICAgICAgICAgICBpcCArPSAyO1xuICAgICAgICAgIH0gd2hpbGUgKGlwIDwgZGF0YS5tYXNrLm51bUJ5dGVzKTtcbiAgICAgICAgICBpZiAoKGNudCAhPT0gLTMyNzY4KSB8fCAob3AgPCBiaXRzZXQubGVuZ3RoKSkge1xuICAgICAgICAgICAgdGhyb3cgXCJVbmV4cGVjdGVkIGVuZCBvZiBtYXNrIFJMRSBlbmNvZGluZ1wiO1xuICAgICAgICAgIH1cbiAgICAgICAgICBkYXRhLm1hc2suYml0c2V0ID0gYml0c2V0O1xuICAgICAgICAgIGZwICs9IGRhdGEubWFzay5udW1CeXRlcztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICgoZGF0YS5tYXNrLm51bUJ5dGVzIHwgZGF0YS5tYXNrLm51bUJsb2Nrc1kgfCBkYXRhLm1hc2subWF4VmFsdWUpID09PSAwKSB7ICAvLyBTcGVjaWFsIGNhc2UsIGFsbCBub2RhdGFcbiAgICAgICAgICBkYXRhLm1hc2suYml0c2V0ID0gbmV3IFVpbnQ4QXJyYXkoTWF0aC5jZWlsKGRhdGEud2lkdGggKiBkYXRhLmhlaWdodCAvIDgpKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBQaXhlbCBIZWFkZXJcbiAgICAgIHZpZXcgPSBuZXcgRGF0YVZpZXcoaW5wdXQsIGZwLCAxNik7XG4gICAgICBkYXRhLnBpeGVscyA9IHt9O1xuICAgICAgZGF0YS5waXhlbHMubnVtQmxvY2tzWSA9IHZpZXcuZ2V0VWludDMyKDAsIHRydWUpO1xuICAgICAgZGF0YS5waXhlbHMubnVtQmxvY2tzWCA9IHZpZXcuZ2V0VWludDMyKDQsIHRydWUpO1xuICAgICAgZGF0YS5waXhlbHMubnVtQnl0ZXMgPSB2aWV3LmdldFVpbnQzMig4LCB0cnVlKTtcbiAgICAgIGRhdGEucGl4ZWxzLm1heFZhbHVlID0gdmlldy5nZXRGbG9hdDMyKDEyLCB0cnVlKTtcbiAgICAgIGZwICs9IDE2O1xuXG4gICAgICB2YXIgbnVtQmxvY2tzWCA9IGRhdGEucGl4ZWxzLm51bUJsb2Nrc1g7XG4gICAgICB2YXIgbnVtQmxvY2tzWSA9IGRhdGEucGl4ZWxzLm51bUJsb2Nrc1k7XG4gICAgICAvLyB0aGUgbnVtYmVyIG9mIGJsb2NrcyBzcGVjaWZpZWQgaW4gdGhlIGhlYWRlciBkb2VzIG5vdCB0YWtlIGludG8gYWNjb3VudCB0aGUgYmxvY2tzIGF0IHRoZSBlbmQgb2ZcbiAgICAgIC8vIGVhY2ggcm93L2NvbHVtbiB3aXRoIGEgc3BlY2lhbCB3aWR0aC9oZWlnaHQgdGhhdCBtYWtlIHRoZSBpbWFnZSBjb21wbGV0ZSBpbiBjYXNlIHRoZSB3aWR0aCBpcyBub3RcbiAgICAgIC8vIGV2ZW5seSBkaXZpc2libGUgYnkgdGhlIG51bWJlciBvZiBibG9ja3MuXG4gICAgICB2YXIgYWN0dWFsTnVtQmxvY2tzWCA9IG51bUJsb2Nrc1ggKyAoKGRhdGEud2lkdGggJSBudW1CbG9ja3NYKSA+IDAgPyAxIDogMCk7XG4gICAgICB2YXIgYWN0dWFsTnVtQmxvY2tzWSA9IG51bUJsb2Nrc1kgKyAoKGRhdGEuaGVpZ2h0ICUgbnVtQmxvY2tzWSkgPiAwID8gMSA6IDApO1xuICAgICAgZGF0YS5waXhlbHMuYmxvY2tzID0gbmV3IEFycmF5KGFjdHVhbE51bUJsb2Nrc1ggKiBhY3R1YWxOdW1CbG9ja3NZKTtcbiAgICAgIHZhciBibG9ja0kgPSAwO1xuICAgICAgZm9yICh2YXIgYmxvY2tZID0gMDsgYmxvY2tZIDwgYWN0dWFsTnVtQmxvY2tzWTsgYmxvY2tZKyspIHtcbiAgICAgICAgZm9yICh2YXIgYmxvY2tYID0gMDsgYmxvY2tYIDwgYWN0dWFsTnVtQmxvY2tzWDsgYmxvY2tYKyspIHtcblxuICAgICAgICAgIC8vIEJsb2NrXG4gICAgICAgICAgdmFyIHNpemUgPSAwO1xuICAgICAgICAgIHZhciBieXRlc0xlZnQgPSBpbnB1dC5ieXRlTGVuZ3RoIC0gZnA7XG4gICAgICAgICAgdmlldyA9IG5ldyBEYXRhVmlldyhpbnB1dCwgZnAsIE1hdGgubWluKDEwLCBieXRlc0xlZnQpKTtcbiAgICAgICAgICB2YXIgYmxvY2sgPSB7fTtcbiAgICAgICAgICBkYXRhLnBpeGVscy5ibG9ja3NbYmxvY2tJKytdID0gYmxvY2s7XG4gICAgICAgICAgdmFyIGhlYWRlckJ5dGUgPSB2aWV3LmdldFVpbnQ4KDApOyBzaXplKys7XG4gICAgICAgICAgYmxvY2suZW5jb2RpbmcgPSBoZWFkZXJCeXRlICYgNjM7XG4gICAgICAgICAgaWYgKGJsb2NrLmVuY29kaW5nID4gMykge1xuICAgICAgICAgICAgdGhyb3cgXCJJbnZhbGlkIGJsb2NrIGVuY29kaW5nIChcIiArIGJsb2NrLmVuY29kaW5nICsgXCIpXCI7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChibG9jay5lbmNvZGluZyA9PT0gMikge1xuICAgICAgICAgICAgZnArKztcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoKGhlYWRlckJ5dGUgIT09IDApICYmIChoZWFkZXJCeXRlICE9PSAyKSkge1xuICAgICAgICAgICAgaGVhZGVyQnl0ZSA+Pj0gNjtcbiAgICAgICAgICAgIGJsb2NrLm9mZnNldFR5cGUgPSBoZWFkZXJCeXRlO1xuICAgICAgICAgICAgaWYgKGhlYWRlckJ5dGUgPT09IDIpIHtcbiAgICAgICAgICAgICAgYmxvY2sub2Zmc2V0ID0gdmlldy5nZXRJbnQ4KDEpOyBzaXplKys7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGhlYWRlckJ5dGUgPT09IDEpIHtcbiAgICAgICAgICAgICAgYmxvY2sub2Zmc2V0ID0gdmlldy5nZXRJbnQxNigxLCB0cnVlKTsgc2l6ZSArPSAyO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChoZWFkZXJCeXRlID09PSAwKSB7XG4gICAgICAgICAgICAgIGJsb2NrLm9mZnNldCA9IHZpZXcuZ2V0RmxvYXQzMigxLCB0cnVlKTsgc2l6ZSArPSA0O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgdGhyb3cgXCJJbnZhbGlkIGJsb2NrIG9mZnNldCB0eXBlXCI7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChibG9jay5lbmNvZGluZyA9PT0gMSkge1xuICAgICAgICAgICAgICBoZWFkZXJCeXRlID0gdmlldy5nZXRVaW50OChzaXplKTsgc2l6ZSsrO1xuICAgICAgICAgICAgICBibG9jay5iaXRzUGVyUGl4ZWwgPSBoZWFkZXJCeXRlICYgNjM7XG4gICAgICAgICAgICAgIGhlYWRlckJ5dGUgPj49IDY7XG4gICAgICAgICAgICAgIGJsb2NrLm51bVZhbGlkUGl4ZWxzVHlwZSA9IGhlYWRlckJ5dGU7XG4gICAgICAgICAgICAgIGlmIChoZWFkZXJCeXRlID09PSAyKSB7XG4gICAgICAgICAgICAgICAgYmxvY2subnVtVmFsaWRQaXhlbHMgPSB2aWV3LmdldFVpbnQ4KHNpemUpOyBzaXplKys7XG4gICAgICAgICAgICAgIH0gZWxzZSBpZiAoaGVhZGVyQnl0ZSA9PT0gMSkge1xuICAgICAgICAgICAgICAgIGJsb2NrLm51bVZhbGlkUGl4ZWxzID0gdmlldy5nZXRVaW50MTYoc2l6ZSwgdHJ1ZSk7IHNpemUgKz0gMjtcbiAgICAgICAgICAgICAgfSBlbHNlIGlmIChoZWFkZXJCeXRlID09PSAwKSB7XG4gICAgICAgICAgICAgICAgYmxvY2subnVtVmFsaWRQaXhlbHMgPSB2aWV3LmdldFVpbnQzMihzaXplLCB0cnVlKTsgc2l6ZSArPSA0O1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRocm93IFwiSW52YWxpZCB2YWxpZCBwaXhlbCBjb3VudCB0eXBlXCI7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgZnAgKz0gc2l6ZTtcblxuICAgICAgICAgIGlmIChibG9jay5lbmNvZGluZyA9PT0gMykge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIGFycmF5QnVmLCBzdG9yZTg7XG4gICAgICAgICAgaWYgKGJsb2NrLmVuY29kaW5nID09PSAwKSB7XG4gICAgICAgICAgICB2YXIgbnVtUGl4ZWxzID0gKGRhdGEucGl4ZWxzLm51bUJ5dGVzIC0gMSkgLyA0O1xuICAgICAgICAgICAgaWYgKG51bVBpeGVscyAhPT0gTWF0aC5mbG9vcihudW1QaXhlbHMpKSB7XG4gICAgICAgICAgICAgIHRocm93IFwidW5jb21wcmVzc2VkIGJsb2NrIGhhcyBpbnZhbGlkIGxlbmd0aFwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYXJyYXlCdWYgPSBuZXcgQXJyYXlCdWZmZXIobnVtUGl4ZWxzICogNCk7XG4gICAgICAgICAgICBzdG9yZTggPSBuZXcgVWludDhBcnJheShhcnJheUJ1Zik7XG4gICAgICAgICAgICBzdG9yZTguc2V0KG5ldyBVaW50OEFycmF5KGlucHV0LCBmcCwgbnVtUGl4ZWxzICogNCkpO1xuICAgICAgICAgICAgdmFyIHJhd0RhdGEgPSBuZXcgRmxvYXQzMkFycmF5KGFycmF5QnVmKTtcbiAgICAgICAgICAgIGJsb2NrLnJhd0RhdGEgPSByYXdEYXRhO1xuICAgICAgICAgICAgZnAgKz0gbnVtUGl4ZWxzICogNDtcbiAgICAgICAgICB9IGVsc2UgaWYgKGJsb2NrLmVuY29kaW5nID09PSAxKSB7XG4gICAgICAgICAgICB2YXIgZGF0YUJ5dGVzID0gTWF0aC5jZWlsKGJsb2NrLm51bVZhbGlkUGl4ZWxzICogYmxvY2suYml0c1BlclBpeGVsIC8gOCk7XG4gICAgICAgICAgICB2YXIgZGF0YVdvcmRzID0gTWF0aC5jZWlsKGRhdGFCeXRlcyAvIDQpO1xuICAgICAgICAgICAgYXJyYXlCdWYgPSBuZXcgQXJyYXlCdWZmZXIoZGF0YVdvcmRzICogNCk7XG4gICAgICAgICAgICBzdG9yZTggPSBuZXcgVWludDhBcnJheShhcnJheUJ1Zik7XG4gICAgICAgICAgICBzdG9yZTguc2V0KG5ldyBVaW50OEFycmF5KGlucHV0LCBmcCwgZGF0YUJ5dGVzKSk7XG4gICAgICAgICAgICBibG9jay5zdHVmZmVkRGF0YSA9IG5ldyBVaW50MzJBcnJheShhcnJheUJ1Zik7XG4gICAgICAgICAgICBmcCArPSBkYXRhQnl0ZXM7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBkYXRhLmVvZk9mZnNldCA9IGZwO1xuICAgICAgcmV0dXJuIGRhdGE7XG4gICAgfTtcblxuICAgIHZhciB1bnN0dWZmID0gZnVuY3Rpb24oc3JjLCBiaXRzUGVyUGl4ZWwsIG51bVBpeGVscywgb2Zmc2V0LCBzY2FsZSwgZGVzdCwgbWF4VmFsdWUpIHtcbiAgICAgIHZhciBiaXRNYXNrID0gKDEgPDwgYml0c1BlclBpeGVsKSAtIDE7XG4gICAgICB2YXIgaSA9IDAsIG87XG4gICAgICB2YXIgYml0c0xlZnQgPSAwO1xuICAgICAgdmFyIG4sIGJ1ZmZlcjtcbiAgICAgIHZhciBubWF4ID0gTWF0aC5jZWlsKChtYXhWYWx1ZSAtIG9mZnNldCkgLyBzY2FsZSk7XG4gICAgICAvLyBnZXQgcmlkIG9mIHRyYWlsaW5nIGJ5dGVzIHRoYXQgYXJlIGFscmVhZHkgcGFydCBvZiBuZXh0IGJsb2NrXG4gICAgICB2YXIgbnVtSW52YWxpZFRhaWxCeXRlcyA9IHNyYy5sZW5ndGggKiA0IC0gTWF0aC5jZWlsKGJpdHNQZXJQaXhlbCAqIG51bVBpeGVscyAvIDgpO1xuICAgICAgc3JjW3NyYy5sZW5ndGggLSAxXSA8PD0gOCAqIG51bUludmFsaWRUYWlsQnl0ZXM7XG5cbiAgICAgIGZvciAobyA9IDA7IG8gPCBudW1QaXhlbHM7IG8rKykge1xuICAgICAgICBpZiAoYml0c0xlZnQgPT09IDApIHtcbiAgICAgICAgICBidWZmZXIgPSBzcmNbaSsrXTtcbiAgICAgICAgICBiaXRzTGVmdCA9IDMyO1xuICAgICAgICB9XG4gICAgICAgIGlmIChiaXRzTGVmdCA+PSBiaXRzUGVyUGl4ZWwpIHtcbiAgICAgICAgICBuID0gKGJ1ZmZlciA+Pj4gKGJpdHNMZWZ0IC0gYml0c1BlclBpeGVsKSkgJiBiaXRNYXNrO1xuICAgICAgICAgIGJpdHNMZWZ0IC09IGJpdHNQZXJQaXhlbDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YXIgbWlzc2luZ0JpdHMgPSAoYml0c1BlclBpeGVsIC0gYml0c0xlZnQpO1xuICAgICAgICAgIG4gPSAoKGJ1ZmZlciAmIGJpdE1hc2spIDw8IG1pc3NpbmdCaXRzKSAmIGJpdE1hc2s7XG4gICAgICAgICAgYnVmZmVyID0gc3JjW2krK107XG4gICAgICAgICAgYml0c0xlZnQgPSAzMiAtIG1pc3NpbmdCaXRzO1xuICAgICAgICAgIG4gKz0gKGJ1ZmZlciA+Pj4gYml0c0xlZnQpO1xuICAgICAgICB9XG4gICAgICAgIC8vcGl4ZWwgdmFsdWVzIG1heSBleGNlZWQgbWF4IGR1ZSB0byBxdWFudGl6YXRpb25cbiAgICAgICAgZGVzdFtvXSA9IG4gPCBubWF4ID8gb2Zmc2V0ICsgbiAqIHNjYWxlIDogbWF4VmFsdWU7XG4gICAgICB9XG4gICAgICByZXR1cm4gZGVzdDtcbiAgICB9O1xuXG4gICAgcmV0dXJuIENudFpJbWFnZTtcbiAgfSkoKTtcblxuICAvL3ZlcnNpb24gMi4gU3VwcG9ydHMgMi4xLCAyLjIsIDIuM1xuICB2YXIgTGVyYzJEZWNvZGUgPSAoZnVuY3Rpb24oKSB7XG4gICAgLy8gTm90ZTogY3VycmVudGx5LCB0aGlzIG1vZHVsZSBvbmx5IGhhcyBhbiBpbXBsZW1lbnRhdGlvbiBmb3IgZGVjb2RpbmcgTEVSQyBkYXRhLCBub3QgZW5jb2RpbmcuIFRoZSBuYW1lIG9mXG4gICAgLy8gdGhlIGNsYXNzIHdhcyBjaG9zZW4gdG8gYmUgZnV0dXJlIHByb29mLCBmb2xsb3dpbmcgTGVyY0RlY29kZS5cblxuICAgIC8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuICAgICogcHJpdmF0ZSBzdGF0aWMgY2xhc3MgYml0c3V0ZmZlciB1c2VkIGJ5IExlcmMyRGVjb2RlXG4gICAgKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbiAgICB2YXIgQml0U3R1ZmZlciA9IHtcbiAgICAgIC8vbWV0aG9kcyBlbmRpbmcgd2l0aCAyIGFyZSBmb3IgdGhlIG5ldyBieXRlIG9yZGVyIHVzZWQgYnkgTGVyYzIuMyBhbmQgYWJvdmUuXG4gICAgICAvL29yaWdpbmFsVW5zdHVmZiBpcyB1c2VkIHRvIHVucGFjayBIdWZmbWFuIGNvZGUgdGFibGUuIGNvZGUgaXMgZHVwbGljYXRlZCB0byB1bnN0dWZmeCBmb3IgcGVyZm9ybWFuY2UgcmVhc29ucy5cbiAgICAgIHVuc3R1ZmY6IGZ1bmN0aW9uKHNyYywgZGVzdCwgYml0c1BlclBpeGVsLCBudW1QaXhlbHMsIGx1dEFyciwgb2Zmc2V0LCBzY2FsZSwgbWF4VmFsdWUpIHtcbiAgICAgICAgdmFyIGJpdE1hc2sgPSAoMSA8PCBiaXRzUGVyUGl4ZWwpIC0gMTtcbiAgICAgICAgdmFyIGkgPSAwLCBvO1xuICAgICAgICB2YXIgYml0c0xlZnQgPSAwO1xuICAgICAgICB2YXIgbiwgYnVmZmVyLCBtaXNzaW5nQml0cywgbm1heDtcblxuICAgICAgICAvLyBnZXQgcmlkIG9mIHRyYWlsaW5nIGJ5dGVzIHRoYXQgYXJlIGFscmVhZHkgcGFydCBvZiBuZXh0IGJsb2NrXG4gICAgICAgIHZhciBudW1JbnZhbGlkVGFpbEJ5dGVzID0gc3JjLmxlbmd0aCAqIDQgLSBNYXRoLmNlaWwoYml0c1BlclBpeGVsICogbnVtUGl4ZWxzIC8gOCk7XG4gICAgICAgIHNyY1tzcmMubGVuZ3RoIC0gMV0gPDw9IDggKiBudW1JbnZhbGlkVGFpbEJ5dGVzO1xuICAgICAgICBpZiAobHV0QXJyKSB7XG4gICAgICAgICAgZm9yIChvID0gMDsgbyA8IG51bVBpeGVsczsgbysrKSB7XG4gICAgICAgICAgICBpZiAoYml0c0xlZnQgPT09IDApIHtcbiAgICAgICAgICAgICAgYnVmZmVyID0gc3JjW2krK107XG4gICAgICAgICAgICAgIGJpdHNMZWZ0ID0gMzI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoYml0c0xlZnQgPj0gYml0c1BlclBpeGVsKSB7XG4gICAgICAgICAgICAgIG4gPSAoYnVmZmVyID4+PiAoYml0c0xlZnQgLSBiaXRzUGVyUGl4ZWwpKSAmIGJpdE1hc2s7XG4gICAgICAgICAgICAgIGJpdHNMZWZ0IC09IGJpdHNQZXJQaXhlbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICBtaXNzaW5nQml0cyA9IChiaXRzUGVyUGl4ZWwgLSBiaXRzTGVmdCk7XG4gICAgICAgICAgICAgIG4gPSAoKGJ1ZmZlciAmIGJpdE1hc2spIDw8IG1pc3NpbmdCaXRzKSAmIGJpdE1hc2s7XG4gICAgICAgICAgICAgIGJ1ZmZlciA9IHNyY1tpKytdO1xuICAgICAgICAgICAgICBiaXRzTGVmdCA9IDMyIC0gbWlzc2luZ0JpdHM7XG4gICAgICAgICAgICAgIG4gKz0gKGJ1ZmZlciA+Pj4gYml0c0xlZnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZGVzdFtvXSA9IGx1dEFycltuXTsvL29mZnNldCArIGx1dEFycltuXSAqIHNjYWxlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICBubWF4ID0gTWF0aC5jZWlsKChtYXhWYWx1ZSAtIG9mZnNldCkgLyBzY2FsZSk7XG4gICAgICAgICAgZm9yIChvID0gMDsgbyA8IG51bVBpeGVsczsgbysrKSB7XG4gICAgICAgICAgICBpZiAoYml0c0xlZnQgPT09IDApIHtcbiAgICAgICAgICAgICAgYnVmZmVyID0gc3JjW2krK107XG4gICAgICAgICAgICAgIGJpdHNMZWZ0ID0gMzI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoYml0c0xlZnQgPj0gYml0c1BlclBpeGVsKSB7XG4gICAgICAgICAgICAgIG4gPSAoYnVmZmVyID4+PiAoYml0c0xlZnQgLSBiaXRzUGVyUGl4ZWwpKSAmIGJpdE1hc2s7XG4gICAgICAgICAgICAgIGJpdHNMZWZ0IC09IGJpdHNQZXJQaXhlbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICBtaXNzaW5nQml0cyA9IChiaXRzUGVyUGl4ZWwgLSBiaXRzTGVmdCk7XG4gICAgICAgICAgICAgIG4gPSAoKGJ1ZmZlciAmIGJpdE1hc2spIDw8IG1pc3NpbmdCaXRzKSAmIGJpdE1hc2s7XG4gICAgICAgICAgICAgIGJ1ZmZlciA9IHNyY1tpKytdO1xuICAgICAgICAgICAgICBiaXRzTGVmdCA9IDMyIC0gbWlzc2luZ0JpdHM7XG4gICAgICAgICAgICAgIG4gKz0gKGJ1ZmZlciA+Pj4gYml0c0xlZnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy9waXhlbCB2YWx1ZXMgbWF5IGV4Y2VlZCBtYXggZHVlIHRvIHF1YW50aXphdGlvblxuICAgICAgICAgICAgZGVzdFtvXSA9IG4gPCBubWF4ID8gb2Zmc2V0ICsgbiAqIHNjYWxlIDogbWF4VmFsdWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9LFxuXG4gICAgICB1bnN0dWZmTFVUOiBmdW5jdGlvbihzcmMsIGJpdHNQZXJQaXhlbCwgbnVtUGl4ZWxzLCBvZmZzZXQsIHNjYWxlLCBtYXhWYWx1ZSkge1xuICAgICAgICB2YXIgYml0TWFzayA9ICgxIDw8IGJpdHNQZXJQaXhlbCkgLSAxO1xuICAgICAgICB2YXIgaSA9IDAsIG8gPSAwLCBtaXNzaW5nQml0cyA9IDAsIGJpdHNMZWZ0ID0gMCwgbiA9IDA7XG4gICAgICAgIHZhciBidWZmZXI7XG4gICAgICAgIHZhciBkZXN0ID0gW107XG5cbiAgICAgICAgLy8gZ2V0IHJpZCBvZiB0cmFpbGluZyBieXRlcyB0aGF0IGFyZSBhbHJlYWR5IHBhcnQgb2YgbmV4dCBibG9ja1xuICAgICAgICB2YXIgbnVtSW52YWxpZFRhaWxCeXRlcyA9IHNyYy5sZW5ndGggKiA0IC0gTWF0aC5jZWlsKGJpdHNQZXJQaXhlbCAqIG51bVBpeGVscyAvIDgpO1xuICAgICAgICBzcmNbc3JjLmxlbmd0aCAtIDFdIDw8PSA4ICogbnVtSW52YWxpZFRhaWxCeXRlcztcblxuICAgICAgICB2YXIgbm1heCA9IE1hdGguY2VpbCgobWF4VmFsdWUgLSBvZmZzZXQpIC8gc2NhbGUpO1xuICAgICAgICBmb3IgKG8gPSAwOyBvIDwgbnVtUGl4ZWxzOyBvKyspIHtcbiAgICAgICAgICBpZiAoYml0c0xlZnQgPT09IDApIHtcbiAgICAgICAgICAgIGJ1ZmZlciA9IHNyY1tpKytdO1xuICAgICAgICAgICAgYml0c0xlZnQgPSAzMjtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGJpdHNMZWZ0ID49IGJpdHNQZXJQaXhlbCkge1xuICAgICAgICAgICAgbiA9IChidWZmZXIgPj4+IChiaXRzTGVmdCAtIGJpdHNQZXJQaXhlbCkpICYgYml0TWFzaztcbiAgICAgICAgICAgIGJpdHNMZWZ0IC09IGJpdHNQZXJQaXhlbDtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbWlzc2luZ0JpdHMgPSAoYml0c1BlclBpeGVsIC0gYml0c0xlZnQpO1xuICAgICAgICAgICAgbiA9ICgoYnVmZmVyICYgYml0TWFzaykgPDwgbWlzc2luZ0JpdHMpICYgYml0TWFzaztcbiAgICAgICAgICAgIGJ1ZmZlciA9IHNyY1tpKytdO1xuICAgICAgICAgICAgYml0c0xlZnQgPSAzMiAtIG1pc3NpbmdCaXRzO1xuICAgICAgICAgICAgbiArPSAoYnVmZmVyID4+PiBiaXRzTGVmdCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vZGVzdC5wdXNoKG4pO1xuICAgICAgICAgIGRlc3Rbb10gPSBuIDwgbm1heCA/IG9mZnNldCArIG4gKiBzY2FsZSA6IG1heFZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIGRlc3QudW5zaGlmdChvZmZzZXQpOy8vMXN0IG9uZVxuICAgICAgICByZXR1cm4gZGVzdDtcbiAgICAgIH0sXG5cbiAgICAgIHVuc3R1ZmYyOiBmdW5jdGlvbihzcmMsIGRlc3QsIGJpdHNQZXJQaXhlbCwgbnVtUGl4ZWxzLCBsdXRBcnIsIG9mZnNldCwgc2NhbGUsIG1heFZhbHVlKSB7XG4gICAgICAgIHZhciBiaXRNYXNrID0gKDEgPDwgYml0c1BlclBpeGVsKSAtIDE7XG4gICAgICAgIHZhciBpID0gMCwgbztcbiAgICAgICAgdmFyIGJpdHNMZWZ0ID0gMCwgYml0UG9zID0gMDtcbiAgICAgICAgdmFyIG4sIGJ1ZmZlciwgbWlzc2luZ0JpdHM7XG4gICAgICAgIGlmIChsdXRBcnIpIHtcbiAgICAgICAgICBmb3IgKG8gPSAwOyBvIDwgbnVtUGl4ZWxzOyBvKyspIHtcbiAgICAgICAgICAgIGlmIChiaXRzTGVmdCA9PT0gMCkge1xuICAgICAgICAgICAgICBidWZmZXIgPSBzcmNbaSsrXTtcbiAgICAgICAgICAgICAgYml0c0xlZnQgPSAzMjtcbiAgICAgICAgICAgICAgYml0UG9zID0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChiaXRzTGVmdCA+PSBiaXRzUGVyUGl4ZWwpIHtcbiAgICAgICAgICAgICAgbiA9ICgoYnVmZmVyID4+PiBiaXRQb3MpICYgYml0TWFzayk7XG4gICAgICAgICAgICAgIGJpdHNMZWZ0IC09IGJpdHNQZXJQaXhlbDtcbiAgICAgICAgICAgICAgYml0UG9zICs9IGJpdHNQZXJQaXhlbDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIG1pc3NpbmdCaXRzID0gKGJpdHNQZXJQaXhlbCAtIGJpdHNMZWZ0KTtcbiAgICAgICAgICAgICAgbiA9IChidWZmZXIgPj4+IGJpdFBvcykgJiBiaXRNYXNrO1xuICAgICAgICAgICAgICBidWZmZXIgPSBzcmNbaSsrXTtcbiAgICAgICAgICAgICAgYml0c0xlZnQgPSAzMiAtIG1pc3NpbmdCaXRzO1xuICAgICAgICAgICAgICBuIHw9IChidWZmZXIgJiAoKDEgPDwgbWlzc2luZ0JpdHMpIC0gMSkpIDw8IChiaXRzUGVyUGl4ZWwgLSBtaXNzaW5nQml0cyk7XG4gICAgICAgICAgICAgIGJpdFBvcyA9IG1pc3NpbmdCaXRzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZGVzdFtvXSA9IGx1dEFycltuXTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgdmFyIG5tYXggPSBNYXRoLmNlaWwoKG1heFZhbHVlIC0gb2Zmc2V0KSAvIHNjYWxlKTtcbiAgICAgICAgICBmb3IgKG8gPSAwOyBvIDwgbnVtUGl4ZWxzOyBvKyspIHtcbiAgICAgICAgICAgIGlmIChiaXRzTGVmdCA9PT0gMCkge1xuICAgICAgICAgICAgICBidWZmZXIgPSBzcmNbaSsrXTtcbiAgICAgICAgICAgICAgYml0c0xlZnQgPSAzMjtcbiAgICAgICAgICAgICAgYml0UG9zID0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChiaXRzTGVmdCA+PSBiaXRzUGVyUGl4ZWwpIHtcbiAgICAgICAgICAgICAgLy9ubyB1bnNpZ25lZCBsZWZ0IHNoaWZ0XG4gICAgICAgICAgICAgIG4gPSAoKGJ1ZmZlciA+Pj4gYml0UG9zKSAmIGJpdE1hc2spO1xuICAgICAgICAgICAgICBiaXRzTGVmdCAtPSBiaXRzUGVyUGl4ZWw7XG4gICAgICAgICAgICAgIGJpdFBvcyArPSBiaXRzUGVyUGl4ZWw7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBtaXNzaW5nQml0cyA9IChiaXRzUGVyUGl4ZWwgLSBiaXRzTGVmdCk7XG4gICAgICAgICAgICAgIG4gPSAoYnVmZmVyID4+PiBiaXRQb3MpICYgYml0TWFzazsvLygoYnVmZmVyICYgYml0TWFzaykgPDwgbWlzc2luZ0JpdHMpICYgYml0TWFzaztcbiAgICAgICAgICAgICAgYnVmZmVyID0gc3JjW2krK107XG4gICAgICAgICAgICAgIGJpdHNMZWZ0ID0gMzIgLSBtaXNzaW5nQml0cztcbiAgICAgICAgICAgICAgbiB8PSAoYnVmZmVyICYgKCgxIDw8IG1pc3NpbmdCaXRzKSAtIDEpKSA8PCAoYml0c1BlclBpeGVsIC0gbWlzc2luZ0JpdHMpO1xuICAgICAgICAgICAgICBiaXRQb3MgPSBtaXNzaW5nQml0cztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vcGl4ZWwgdmFsdWVzIG1heSBleGNlZWQgbWF4IGR1ZSB0byBxdWFudGl6YXRpb25cbiAgICAgICAgICAgIGRlc3Rbb10gPSBuIDwgbm1heCA/IG9mZnNldCArIG4gKiBzY2FsZSA6IG1heFZhbHVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZGVzdDtcbiAgICAgIH0sXG5cbiAgICAgIHVuc3R1ZmZMVVQyOiBmdW5jdGlvbihzcmMsIGJpdHNQZXJQaXhlbCwgbnVtUGl4ZWxzLCBvZmZzZXQsIHNjYWxlLCBtYXhWYWx1ZSkge1xuICAgICAgICB2YXIgYml0TWFzayA9ICgxIDw8IGJpdHNQZXJQaXhlbCkgLSAxO1xuICAgICAgICB2YXIgaSA9IDAsIG8gPSAwLCBtaXNzaW5nQml0cyA9IDAsIGJpdHNMZWZ0ID0gMCwgbiA9IDAsIGJpdFBvcyA9IDA7XG4gICAgICAgIHZhciBidWZmZXI7XG4gICAgICAgIHZhciBkZXN0ID0gW107XG4gICAgICAgIHZhciBubWF4ID0gTWF0aC5jZWlsKChtYXhWYWx1ZSAtIG9mZnNldCkgLyBzY2FsZSk7XG4gICAgICAgIGZvciAobyA9IDA7IG8gPCBudW1QaXhlbHM7IG8rKykge1xuICAgICAgICAgIGlmIChiaXRzTGVmdCA9PT0gMCkge1xuICAgICAgICAgICAgYnVmZmVyID0gc3JjW2krK107XG4gICAgICAgICAgICBiaXRzTGVmdCA9IDMyO1xuICAgICAgICAgICAgYml0UG9zID0gMDtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGJpdHNMZWZ0ID49IGJpdHNQZXJQaXhlbCkge1xuICAgICAgICAgICAgLy9ubyB1bnNpZ25lZCBsZWZ0IHNoaWZ0XG4gICAgICAgICAgICBuID0gKChidWZmZXIgPj4+IGJpdFBvcykgJiBiaXRNYXNrKTtcbiAgICAgICAgICAgIGJpdHNMZWZ0IC09IGJpdHNQZXJQaXhlbDtcbiAgICAgICAgICAgIGJpdFBvcyArPSBiaXRzUGVyUGl4ZWw7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG1pc3NpbmdCaXRzID0gKGJpdHNQZXJQaXhlbCAtIGJpdHNMZWZ0KTtcbiAgICAgICAgICAgIG4gPSAoYnVmZmVyID4+PiBiaXRQb3MpICYgYml0TWFzazsvLygoYnVmZmVyICYgYml0TWFzaykgPDwgbWlzc2luZ0JpdHMpICYgYml0TWFzaztcbiAgICAgICAgICAgIGJ1ZmZlciA9IHNyY1tpKytdO1xuICAgICAgICAgICAgYml0c0xlZnQgPSAzMiAtIG1pc3NpbmdCaXRzO1xuICAgICAgICAgICAgbiB8PSAoYnVmZmVyICYgKCgxIDw8IG1pc3NpbmdCaXRzKSAtIDEpKSA8PCAoYml0c1BlclBpeGVsIC0gbWlzc2luZ0JpdHMpO1xuICAgICAgICAgICAgYml0UG9zID0gbWlzc2luZ0JpdHM7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vZGVzdC5wdXNoKG4pO1xuICAgICAgICAgIGRlc3Rbb10gPSBuIDwgbm1heCA/IG9mZnNldCArIG4gKiBzY2FsZSA6IG1heFZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIGRlc3QudW5zaGlmdChvZmZzZXQpO1xuICAgICAgICByZXR1cm4gZGVzdDtcbiAgICAgIH0sXG5cbiAgICAgIG9yaWdpbmFsVW5zdHVmZjogZnVuY3Rpb24oc3JjLCBkZXN0LCBiaXRzUGVyUGl4ZWwsIG51bVBpeGVscykge1xuICAgICAgICB2YXIgYml0TWFzayA9ICgxIDw8IGJpdHNQZXJQaXhlbCkgLSAxO1xuICAgICAgICB2YXIgaSA9IDAsIG87XG4gICAgICAgIHZhciBiaXRzTGVmdCA9IDA7XG4gICAgICAgIHZhciBuLCBidWZmZXIsIG1pc3NpbmdCaXRzO1xuXG4gICAgICAgIC8vIGdldCByaWQgb2YgdHJhaWxpbmcgYnl0ZXMgdGhhdCBhcmUgYWxyZWFkeSBwYXJ0IG9mIG5leHQgYmxvY2tcbiAgICAgICAgdmFyIG51bUludmFsaWRUYWlsQnl0ZXMgPSBzcmMubGVuZ3RoICogNCAtIE1hdGguY2VpbChiaXRzUGVyUGl4ZWwgKiBudW1QaXhlbHMgLyA4KTtcbiAgICAgICAgc3JjW3NyYy5sZW5ndGggLSAxXSA8PD0gOCAqIG51bUludmFsaWRUYWlsQnl0ZXM7XG5cbiAgICAgICAgZm9yIChvID0gMDsgbyA8IG51bVBpeGVsczsgbysrKSB7XG4gICAgICAgICAgaWYgKGJpdHNMZWZ0ID09PSAwKSB7XG4gICAgICAgICAgICBidWZmZXIgPSBzcmNbaSsrXTtcbiAgICAgICAgICAgIGJpdHNMZWZ0ID0gMzI7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChiaXRzTGVmdCA+PSBiaXRzUGVyUGl4ZWwpIHtcbiAgICAgICAgICAgIG4gPSAoYnVmZmVyID4+PiAoYml0c0xlZnQgLSBiaXRzUGVyUGl4ZWwpKSAmIGJpdE1hc2s7XG4gICAgICAgICAgICBiaXRzTGVmdCAtPSBiaXRzUGVyUGl4ZWw7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbWlzc2luZ0JpdHMgPSAoYml0c1BlclBpeGVsIC0gYml0c0xlZnQpO1xuICAgICAgICAgICAgbiA9ICgoYnVmZmVyICYgYml0TWFzaykgPDwgbWlzc2luZ0JpdHMpICYgYml0TWFzaztcbiAgICAgICAgICAgIGJ1ZmZlciA9IHNyY1tpKytdO1xuICAgICAgICAgICAgYml0c0xlZnQgPSAzMiAtIG1pc3NpbmdCaXRzO1xuICAgICAgICAgICAgbiArPSAoYnVmZmVyID4+PiBiaXRzTGVmdCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGRlc3Rbb10gPSBuO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkZXN0O1xuICAgICAgfSxcblxuICAgICAgb3JpZ2luYWxVbnN0dWZmMjogZnVuY3Rpb24oc3JjLCBkZXN0LCBiaXRzUGVyUGl4ZWwsIG51bVBpeGVscykge1xuICAgICAgICB2YXIgYml0TWFzayA9ICgxIDw8IGJpdHNQZXJQaXhlbCkgLSAxO1xuICAgICAgICB2YXIgaSA9IDAsIG87XG4gICAgICAgIHZhciBiaXRzTGVmdCA9IDAsIGJpdFBvcyA9IDA7XG4gICAgICAgIHZhciBuLCBidWZmZXIsIG1pc3NpbmdCaXRzO1xuICAgICAgICAvL21pY3JvLW9wdGltaXphdGlvbnNcbiAgICAgICAgZm9yIChvID0gMDsgbyA8IG51bVBpeGVsczsgbysrKSB7XG4gICAgICAgICAgaWYgKGJpdHNMZWZ0ID09PSAwKSB7XG4gICAgICAgICAgICBidWZmZXIgPSBzcmNbaSsrXTtcbiAgICAgICAgICAgIGJpdHNMZWZ0ID0gMzI7XG4gICAgICAgICAgICBiaXRQb3MgPSAwO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoYml0c0xlZnQgPj0gYml0c1BlclBpeGVsKSB7XG4gICAgICAgICAgICAvL25vIHVuc2lnbmVkIGxlZnQgc2hpZnRcbiAgICAgICAgICAgIG4gPSAoKGJ1ZmZlciA+Pj4gYml0UG9zKSAmIGJpdE1hc2spO1xuICAgICAgICAgICAgYml0c0xlZnQgLT0gYml0c1BlclBpeGVsO1xuICAgICAgICAgICAgYml0UG9zICs9IGJpdHNQZXJQaXhlbDtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbWlzc2luZ0JpdHMgPSAoYml0c1BlclBpeGVsIC0gYml0c0xlZnQpO1xuICAgICAgICAgICAgbiA9IChidWZmZXIgPj4+IGJpdFBvcykgJiBiaXRNYXNrOy8vKChidWZmZXIgJiBiaXRNYXNrKSA8PCBtaXNzaW5nQml0cykgJiBiaXRNYXNrO1xuICAgICAgICAgICAgYnVmZmVyID0gc3JjW2krK107XG4gICAgICAgICAgICBiaXRzTGVmdCA9IDMyIC0gbWlzc2luZ0JpdHM7XG4gICAgICAgICAgICBuIHw9IChidWZmZXIgJiAoKDEgPDwgbWlzc2luZ0JpdHMpIC0gMSkpIDw8IChiaXRzUGVyUGl4ZWwgLSBtaXNzaW5nQml0cyk7XG4gICAgICAgICAgICBiaXRQb3MgPSBtaXNzaW5nQml0cztcbiAgICAgICAgICB9XG4gICAgICAgICAgZGVzdFtvXSA9IG47XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGRlc3Q7XG4gICAgICB9XG4gICAgfTtcblxuICAgIC8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuICAgICpwcml2YXRlIHN0YXRpYyBjbGFzcyB1c2VkIGJ5IExlcmMyRGVjb2RlXG4gICAgKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuICAgIHZhciBMZXJjMkhlbHBlcnMgPSB7XG4gICAgICBIVUZGTUFOX0xVVF9CSVRTX01BWDogMTIsIC8vdXNlIDJeMTIgbHV0LCB0cmVhdCBpdCBsaWtlIGNvbnN0YW50XG4gICAgICBjb21wdXRlQ2hlY2tzdW1GbGV0Y2hlcjMyOiBmdW5jdGlvbihpbnB1dCkge1xuXG4gICAgICAgIHZhciBzdW0xID0gMHhmZmZmLCBzdW0yID0gMHhmZmZmO1xuICAgICAgICB2YXIgbGVuID0gaW5wdXQubGVuZ3RoO1xuICAgICAgICB2YXIgd29yZHMgPSBNYXRoLmZsb29yKGxlbiAvIDIpO1xuICAgICAgICB2YXIgaSA9IDA7XG4gICAgICAgIHdoaWxlICh3b3Jkcykge1xuICAgICAgICAgIHZhciB0bGVuID0gKHdvcmRzID49IDM1OSkgPyAzNTkgOiB3b3JkcztcbiAgICAgICAgICB3b3JkcyAtPSB0bGVuO1xuICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgIHN1bTEgKz0gKGlucHV0W2krK10gPDwgOCk7XG4gICAgICAgICAgICBzdW0yICs9IHN1bTEgKz0gaW5wdXRbaSsrXTtcbiAgICAgICAgICB9IHdoaWxlICgtLXRsZW4pO1xuXG4gICAgICAgICAgc3VtMSA9IChzdW0xICYgMHhmZmZmKSArIChzdW0xID4+PiAxNik7XG4gICAgICAgICAgc3VtMiA9IChzdW0yICYgMHhmZmZmKSArIChzdW0yID4+PiAxNik7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBhZGQgdGhlIHN0cmFnZ2xlciBieXRlIGlmIGl0IGV4aXN0c1xuICAgICAgICBpZiAobGVuICYgMSkge1xuICAgICAgICAgIHN1bTIgKz0gc3VtMSArPSAoaW5wdXRbaV0gPDwgOCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gc2Vjb25kIHJlZHVjdGlvbiBzdGVwIHRvIHJlZHVjZSBzdW1zIHRvIDE2IGJpdHNcbiAgICAgICAgc3VtMSA9IChzdW0xICYgMHhmZmZmKSArIChzdW0xID4+PiAxNik7XG4gICAgICAgIHN1bTIgPSAoc3VtMiAmIDB4ZmZmZikgKyAoc3VtMiA+Pj4gMTYpO1xuXG4gICAgICAgIHJldHVybiAoc3VtMiA8PCAxNiB8IHN1bTEpID4+PiAwO1xuICAgICAgfSxcblxuICAgICAgcmVhZEhlYWRlckluZm86IGZ1bmN0aW9uKGlucHV0LCBkYXRhKSB7XG4gICAgICAgIHZhciBwdHIgPSBkYXRhLnB0cjtcbiAgICAgICAgdmFyIGZpbGVJZFZpZXcgPSBuZXcgVWludDhBcnJheShpbnB1dCwgcHRyLCA2KTtcbiAgICAgICAgdmFyIGhlYWRlckluZm8gPSB7fTtcbiAgICAgICAgaGVhZGVySW5mby5maWxlSWRlbnRpZmllclN0cmluZyA9IFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkobnVsbCwgZmlsZUlkVmlldyk7XG4gICAgICAgIGlmIChoZWFkZXJJbmZvLmZpbGVJZGVudGlmaWVyU3RyaW5nLmxhc3RJbmRleE9mKFwiTGVyYzJcIiwgMCkgIT09IDApIHtcbiAgICAgICAgICB0aHJvdyBcIlVuZXhwZWN0ZWQgZmlsZSBpZGVudGlmaWVyIHN0cmluZyAoZXhwZWN0IExlcmMyICk6IFwiICsgaGVhZGVySW5mby5maWxlSWRlbnRpZmllclN0cmluZztcbiAgICAgICAgfVxuICAgICAgICBwdHIgKz0gNjtcbiAgICAgICAgdmFyIHZpZXcgPSBuZXcgRGF0YVZpZXcoaW5wdXQsIHB0ciwgOCk7XG4gICAgICAgIHZhciBmaWxlVmVyc2lvbiA9IHZpZXcuZ2V0SW50MzIoMCwgdHJ1ZSk7XG4gICAgICAgIGhlYWRlckluZm8uZmlsZVZlcnNpb24gPSBmaWxlVmVyc2lvbjtcbiAgICAgICAgcHRyICs9IDQ7XG4gICAgICAgIGlmIChmaWxlVmVyc2lvbiA+PSAzKSB7XG4gICAgICAgICAgaGVhZGVySW5mby5jaGVja3N1bSA9IHZpZXcuZ2V0VWludDMyKDQsIHRydWUpOyAvL25yb3dzXG4gICAgICAgICAgcHRyICs9IDQ7XG4gICAgICAgIH1cblxuICAgICAgICAvL2tleXMgc3RhcnQgZnJvbSBoZXJlXG4gICAgICAgIHZpZXcgPSBuZXcgRGF0YVZpZXcoaW5wdXQsIHB0ciwgMTIpO1xuICAgICAgICBoZWFkZXJJbmZvLmhlaWdodCA9IHZpZXcuZ2V0VWludDMyKDAsIHRydWUpOyAvL25yb3dzXG4gICAgICAgIGhlYWRlckluZm8ud2lkdGggPSB2aWV3LmdldFVpbnQzMig0LCB0cnVlKTsgLy9uY29sc1xuICAgICAgICBwdHIgKz0gODtcbiAgICAgICAgaWYgKGZpbGVWZXJzaW9uID49IDQpIHtcbiAgICAgICAgICBoZWFkZXJJbmZvLm51bURpbXMgPSB2aWV3LmdldFVpbnQzMig4LCB0cnVlKTtcbiAgICAgICAgICBwdHIgKz0gNDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICBoZWFkZXJJbmZvLm51bURpbXMgPSAxO1xuICAgICAgICB9XG5cbiAgICAgICAgdmlldyA9IG5ldyBEYXRhVmlldyhpbnB1dCwgcHRyLCA0MCk7XG4gICAgICAgIGhlYWRlckluZm8ubnVtVmFsaWRQaXhlbCA9IHZpZXcuZ2V0VWludDMyKDAsIHRydWUpO1xuICAgICAgICBoZWFkZXJJbmZvLm1pY3JvQmxvY2tTaXplID0gdmlldy5nZXRJbnQzMig0LCB0cnVlKTtcbiAgICAgICAgaGVhZGVySW5mby5ibG9iU2l6ZSA9IHZpZXcuZ2V0SW50MzIoOCwgdHJ1ZSk7XG4gICAgICAgIGhlYWRlckluZm8uaW1hZ2VUeXBlID0gdmlldy5nZXRJbnQzMigxMiwgdHJ1ZSk7XG5cbiAgICAgICAgaGVhZGVySW5mby5tYXhaRXJyb3IgPSB2aWV3LmdldEZsb2F0NjQoMTYsIHRydWUpO1xuICAgICAgICBoZWFkZXJJbmZvLnpNaW4gPSB2aWV3LmdldEZsb2F0NjQoMjQsIHRydWUpO1xuICAgICAgICBoZWFkZXJJbmZvLnpNYXggPSB2aWV3LmdldEZsb2F0NjQoMzIsIHRydWUpO1xuICAgICAgICBwdHIgKz0gNDA7XG4gICAgICAgIGRhdGEuaGVhZGVySW5mbyA9IGhlYWRlckluZm87XG4gICAgICAgIGRhdGEucHRyID0gcHRyO1xuXG4gICAgICAgIHZhciBjaGVja3N1bSwga2V5TGVuZ3RoO1xuICAgICAgICBpZiAoZmlsZVZlcnNpb24gPj0gMykge1xuICAgICAgICAgIGtleUxlbmd0aCA9IGZpbGVWZXJzaW9uID49IDQgPyA1MiA6IDQ4O1xuICAgICAgICAgIGNoZWNrc3VtID0gdGhpcy5jb21wdXRlQ2hlY2tzdW1GbGV0Y2hlcjMyKG5ldyBVaW50OEFycmF5KGlucHV0LCBwdHIgLSBrZXlMZW5ndGgsIGhlYWRlckluZm8uYmxvYlNpemUgLSAxNCkpO1xuICAgICAgICAgIGlmIChjaGVja3N1bSAhPT0gaGVhZGVySW5mby5jaGVja3N1bSkge1xuICAgICAgICAgICAgdGhyb3cgXCJDaGVja3N1bSBmYWlsZWQuXCI7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfSxcblxuICAgICAgY2hlY2tNaW5NYXhSYW5nZXM6IGZ1bmN0aW9uKGlucHV0LCBkYXRhKSB7XG4gICAgICAgIHZhciBoZWFkZXJJbmZvID0gZGF0YS5oZWFkZXJJbmZvO1xuICAgICAgICB2YXIgT3V0UGl4ZWxUeXBlQXJyYXkgPSB0aGlzLmdldERhdGFUeXBlQXJyYXkoaGVhZGVySW5mby5pbWFnZVR5cGUpO1xuICAgICAgICB2YXIgcmFuZ2VCeXRlcyA9IGhlYWRlckluZm8ubnVtRGltcyAqIHRoaXMuZ2V0RGF0YVR5cGVTaXplKGhlYWRlckluZm8uaW1hZ2VUeXBlKTtcbiAgICAgICAgdmFyIG1pblZhbHVlcyA9IHRoaXMucmVhZFN1YkFycmF5KGlucHV0LCBkYXRhLnB0ciwgT3V0UGl4ZWxUeXBlQXJyYXksIHJhbmdlQnl0ZXMpO1xuICAgICAgICB2YXIgbWF4VmFsdWVzID0gdGhpcy5yZWFkU3ViQXJyYXkoaW5wdXQsIGRhdGEucHRyICsgcmFuZ2VCeXRlcywgT3V0UGl4ZWxUeXBlQXJyYXksIHJhbmdlQnl0ZXMpO1xuICAgICAgICBkYXRhLnB0ciArPSAoMiAqIHJhbmdlQnl0ZXMpO1xuICAgICAgICB2YXIgaSwgZXF1YWwgPSB0cnVlO1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgaGVhZGVySW5mby5udW1EaW1zOyBpKyspIHtcbiAgICAgICAgICBpZiAobWluVmFsdWVzW2ldICE9PSBtYXhWYWx1ZXNbaV0pIHtcbiAgICAgICAgICAgIGVxdWFsID0gZmFsc2U7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaGVhZGVySW5mby5taW5WYWx1ZXMgPSBtaW5WYWx1ZXM7XG4gICAgICAgIGhlYWRlckluZm8ubWF4VmFsdWVzID0gbWF4VmFsdWVzO1xuICAgICAgICByZXR1cm4gZXF1YWw7XG4gICAgICB9LFxuXG4gICAgICByZWFkU3ViQXJyYXk6IGZ1bmN0aW9uKGlucHV0LCBwdHIsIE91dFBpeGVsVHlwZUFycmF5LCBudW1CeXRlcykge1xuICAgICAgICB2YXIgcmF3RGF0YTtcbiAgICAgICAgaWYgKE91dFBpeGVsVHlwZUFycmF5ID09PSBVaW50OEFycmF5KSB7XG4gICAgICAgICAgcmF3RGF0YSA9IG5ldyBVaW50OEFycmF5KGlucHV0LCBwdHIsIG51bUJ5dGVzKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICB2YXIgYXJyYXlCdWYgPSBuZXcgQXJyYXlCdWZmZXIobnVtQnl0ZXMpO1xuICAgICAgICAgIHZhciBzdG9yZTggPSBuZXcgVWludDhBcnJheShhcnJheUJ1Zik7XG4gICAgICAgICAgc3RvcmU4LnNldChuZXcgVWludDhBcnJheShpbnB1dCwgcHRyLCBudW1CeXRlcykpO1xuICAgICAgICAgIHJhd0RhdGEgPSBuZXcgT3V0UGl4ZWxUeXBlQXJyYXkoYXJyYXlCdWYpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByYXdEYXRhO1xuICAgICAgfSxcblxuICAgICAgcmVhZE1hc2s6IGZ1bmN0aW9uKGlucHV0LCBkYXRhKSB7XG4gICAgICAgIHZhciBwdHIgPSBkYXRhLnB0cjtcbiAgICAgICAgdmFyIGhlYWRlckluZm8gPSBkYXRhLmhlYWRlckluZm87XG4gICAgICAgIHZhciBudW1QaXhlbHMgPSBoZWFkZXJJbmZvLndpZHRoICogaGVhZGVySW5mby5oZWlnaHQ7XG4gICAgICAgIHZhciBudW1WYWxpZFBpeGVsID0gaGVhZGVySW5mby5udW1WYWxpZFBpeGVsO1xuXG4gICAgICAgIHZhciB2aWV3ID0gbmV3IERhdGFWaWV3KGlucHV0LCBwdHIsIDQpO1xuICAgICAgICB2YXIgbWFzayA9IHt9O1xuICAgICAgICBtYXNrLm51bUJ5dGVzID0gdmlldy5nZXRVaW50MzIoMCwgdHJ1ZSk7XG4gICAgICAgIHB0ciArPSA0O1xuXG4gICAgICAgIC8vIE1hc2sgRGF0YVxuICAgICAgICBpZiAoKDAgPT09IG51bVZhbGlkUGl4ZWwgfHwgbnVtUGl4ZWxzID09PSBudW1WYWxpZFBpeGVsKSAmJiAwICE9PSBtYXNrLm51bUJ5dGVzKSB7XG4gICAgICAgICAgdGhyb3cgKFwiaW52YWxpZCBtYXNrXCIpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBiaXRzZXQsIHJlc3VsdE1hc2s7XG4gICAgICAgIGlmIChudW1WYWxpZFBpeGVsID09PSAwKSB7XG4gICAgICAgICAgYml0c2V0ID0gbmV3IFVpbnQ4QXJyYXkoTWF0aC5jZWlsKG51bVBpeGVscyAvIDgpKTtcbiAgICAgICAgICBtYXNrLmJpdHNldCA9IGJpdHNldDtcbiAgICAgICAgICByZXN1bHRNYXNrID0gbmV3IFVpbnQ4QXJyYXkobnVtUGl4ZWxzKTtcbiAgICAgICAgICBkYXRhLnBpeGVscy5yZXN1bHRNYXNrID0gcmVzdWx0TWFzaztcbiAgICAgICAgICBwdHIgKz0gbWFzay5udW1CeXRlcztcbiAgICAgICAgfS8vID8/Pz8/IGVsc2UgaWYgKGRhdGEubWFzay5udW1CeXRlcyA+IDAgJiYgZGF0YS5tYXNrLm51bUJ5dGVzPCBkYXRhLm51bVZhbGlkUGl4ZWwpIHtcbiAgICAgICAgZWxzZSBpZiAobWFzay5udW1CeXRlcyA+IDApIHtcbiAgICAgICAgICBiaXRzZXQgPSBuZXcgVWludDhBcnJheShNYXRoLmNlaWwobnVtUGl4ZWxzIC8gOCkpO1xuICAgICAgICAgIHZpZXcgPSBuZXcgRGF0YVZpZXcoaW5wdXQsIHB0ciwgbWFzay5udW1CeXRlcyk7XG4gICAgICAgICAgdmFyIGNudCA9IHZpZXcuZ2V0SW50MTYoMCwgdHJ1ZSk7XG4gICAgICAgICAgdmFyIGlwID0gMiwgb3AgPSAwLCB2YWwgPSAwO1xuICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgIGlmIChjbnQgPiAwKSB7XG4gICAgICAgICAgICAgIHdoaWxlIChjbnQtLSkgeyBiaXRzZXRbb3ArK10gPSB2aWV3LmdldFVpbnQ4KGlwKyspOyB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB2YWwgPSB2aWV3LmdldFVpbnQ4KGlwKyspO1xuICAgICAgICAgICAgICBjbnQgPSAtY250O1xuICAgICAgICAgICAgICB3aGlsZSAoY250LS0pIHsgYml0c2V0W29wKytdID0gdmFsOyB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjbnQgPSB2aWV3LmdldEludDE2KGlwLCB0cnVlKTtcbiAgICAgICAgICAgIGlwICs9IDI7XG4gICAgICAgICAgfSB3aGlsZSAoaXAgPCBtYXNrLm51bUJ5dGVzKTtcbiAgICAgICAgICBpZiAoKGNudCAhPT0gLTMyNzY4KSB8fCAob3AgPCBiaXRzZXQubGVuZ3RoKSkge1xuICAgICAgICAgICAgdGhyb3cgXCJVbmV4cGVjdGVkIGVuZCBvZiBtYXNrIFJMRSBlbmNvZGluZ1wiO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJlc3VsdE1hc2sgPSBuZXcgVWludDhBcnJheShudW1QaXhlbHMpO1xuICAgICAgICAgIHZhciBtYiA9IDAsIGsgPSAwO1xuXG4gICAgICAgICAgZm9yIChrID0gMDsgayA8IG51bVBpeGVsczsgaysrKSB7XG4gICAgICAgICAgICBpZiAoayAmIDcpIHtcbiAgICAgICAgICAgICAgbWIgPSBiaXRzZXRbayA+PiAzXTtcbiAgICAgICAgICAgICAgbWIgPDw9IGsgJiA3O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgIG1iID0gYml0c2V0W2sgPj4gM107XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobWIgJiAxMjgpIHtcbiAgICAgICAgICAgICAgcmVzdWx0TWFza1trXSA9IDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGRhdGEucGl4ZWxzLnJlc3VsdE1hc2sgPSByZXN1bHRNYXNrO1xuXG4gICAgICAgICAgbWFzay5iaXRzZXQgPSBiaXRzZXQ7XG4gICAgICAgICAgcHRyICs9IG1hc2subnVtQnl0ZXM7XG4gICAgICAgIH1cbiAgICAgICAgZGF0YS5wdHIgPSBwdHI7XG4gICAgICAgIGRhdGEubWFzayA9IG1hc2s7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfSxcblxuICAgICAgcmVhZERhdGFPbmVTd2VlcDogZnVuY3Rpb24oaW5wdXQsIGRhdGEsIE91dFBpeGVsVHlwZUFycmF5KSB7XG4gICAgICAgIHZhciBwdHIgPSBkYXRhLnB0cjtcbiAgICAgICAgdmFyIGhlYWRlckluZm8gPSBkYXRhLmhlYWRlckluZm87XG4gICAgICAgIHZhciBudW1EaW1zID0gaGVhZGVySW5mby5udW1EaW1zO1xuICAgICAgICB2YXIgbnVtUGl4ZWxzID0gaGVhZGVySW5mby53aWR0aCAqIGhlYWRlckluZm8uaGVpZ2h0O1xuICAgICAgICB2YXIgaW1hZ2VUeXBlID0gaGVhZGVySW5mby5pbWFnZVR5cGU7XG4gICAgICAgIHZhciBudW1CeXRlcyA9IGhlYWRlckluZm8ubnVtVmFsaWRQaXhlbCAqIExlcmMySGVscGVycy5nZXREYXRhVHlwZVNpemUoaW1hZ2VUeXBlKSAqIG51bURpbXM7XG4gICAgICAgIC8vZGF0YS5waXhlbHMubnVtQnl0ZXMgPSBudW1CeXRlcztcbiAgICAgICAgdmFyIHJhd0RhdGE7XG4gICAgICAgIHZhciBtYXNrID0gZGF0YS5waXhlbHMucmVzdWx0TWFzaztcbiAgICAgICAgaWYgKE91dFBpeGVsVHlwZUFycmF5ID09PSBVaW50OEFycmF5KSB7XG4gICAgICAgICAgcmF3RGF0YSA9IG5ldyBVaW50OEFycmF5KGlucHV0LCBwdHIsIG51bUJ5dGVzKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICB2YXIgYXJyYXlCdWYgPSBuZXcgQXJyYXlCdWZmZXIobnVtQnl0ZXMpO1xuICAgICAgICAgIHZhciBzdG9yZTggPSBuZXcgVWludDhBcnJheShhcnJheUJ1Zik7XG4gICAgICAgICAgc3RvcmU4LnNldChuZXcgVWludDhBcnJheShpbnB1dCwgcHRyLCBudW1CeXRlcykpO1xuICAgICAgICAgIHJhd0RhdGEgPSBuZXcgT3V0UGl4ZWxUeXBlQXJyYXkoYXJyYXlCdWYpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyYXdEYXRhLmxlbmd0aCA9PT0gbnVtUGl4ZWxzICogbnVtRGltcykge1xuICAgICAgICAgIGRhdGEucGl4ZWxzLnJlc3VsdFBpeGVscyA9IHJhd0RhdGE7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSAgLy9tYXNrXG4gICAgICAgIHtcbiAgICAgICAgICBkYXRhLnBpeGVscy5yZXN1bHRQaXhlbHMgPSBuZXcgT3V0UGl4ZWxUeXBlQXJyYXkobnVtUGl4ZWxzICogbnVtRGltcyk7XG4gICAgICAgICAgdmFyIHogPSAwLCBrID0gMCwgaSA9IDAsIG5TdGFydCA9IDA7XG4gICAgICAgICAgaWYgKG51bURpbXMgPiAxKSB7XG4gICAgICAgICAgICBmb3IgKGk9MDsgaSA8IG51bURpbXM7IGkrKykge1xuICAgICAgICAgICAgICBuU3RhcnQgPSBpICogbnVtUGl4ZWxzO1xuICAgICAgICAgICAgICBmb3IgKGsgPSAwOyBrIDwgbnVtUGl4ZWxzOyBrKyspIHtcbiAgICAgICAgICAgICAgICBpZiAobWFza1trXSkge1xuICAgICAgICAgICAgICAgICAgZGF0YS5waXhlbHMucmVzdWx0UGl4ZWxzW25TdGFydCArIGtdID0gcmF3RGF0YVt6KytdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGZvciAoayA9IDA7IGsgPCBudW1QaXhlbHM7IGsrKykge1xuICAgICAgICAgICAgICBpZiAobWFza1trXSkge1xuICAgICAgICAgICAgICAgIGRhdGEucGl4ZWxzLnJlc3VsdFBpeGVsc1trXSA9IHJhd0RhdGFbeisrXTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBwdHIgKz0gbnVtQnl0ZXM7XG4gICAgICAgIGRhdGEucHRyID0gcHRyOyAgICAgICAvL3JldHVybiBkYXRhO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH0sXG5cbiAgICAgIHJlYWRIdWZmbWFuVHJlZTogZnVuY3Rpb24oaW5wdXQsIGRhdGEpIHtcbiAgICAgICAgdmFyIEJJVFNfTUFYID0gdGhpcy5IVUZGTUFOX0xVVF9CSVRTX01BWDsgLy84IGlzIHNsb3cgZm9yIHRoZSBsYXJnZSB0ZXN0IGltYWdlXG4gICAgICAgIC8vdmFyIHNpemVfbWF4ID0gMSA8PCBCSVRTX01BWDtcbiAgICAgICAgLyogKioqKioqKioqKioqKioqKioqKioqKioqXG4gICAgICAgICAqIHJlYWRpbmcgY29kZSB0YWJsZVxuICAgICAgICAgKioqKioqKioqKioqKioqKioqKioqKioqKi9cbiAgICAgICAgdmFyIHZpZXcgPSBuZXcgRGF0YVZpZXcoaW5wdXQsIGRhdGEucHRyLCAxNik7XG4gICAgICAgIGRhdGEucHRyICs9IDE2O1xuICAgICAgICB2YXIgdmVyc2lvbiA9IHZpZXcuZ2V0SW50MzIoMCwgdHJ1ZSk7XG4gICAgICAgIGlmICh2ZXJzaW9uIDwgMikge1xuICAgICAgICAgIHRocm93IFwidW5zdXBwb3J0ZWQgSHVmZm1hbiB2ZXJzaW9uXCI7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHNpemUgPSB2aWV3LmdldEludDMyKDQsIHRydWUpO1xuICAgICAgICB2YXIgaTAgPSB2aWV3LmdldEludDMyKDgsIHRydWUpO1xuICAgICAgICB2YXIgaTEgPSB2aWV3LmdldEludDMyKDEyLCB0cnVlKTtcbiAgICAgICAgaWYgKGkwID49IGkxKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHZhciBibG9ja0RhdGFCdWZmZXIgPSBuZXcgVWludDMyQXJyYXkoaTEgLSBpMCk7XG4gICAgICAgIExlcmMySGVscGVycy5kZWNvZGVCaXRzKGlucHV0LCBkYXRhLCBibG9ja0RhdGFCdWZmZXIpO1xuICAgICAgICB2YXIgY29kZVRhYmxlID0gW107IC8vc2l6ZVxuICAgICAgICB2YXIgaSwgaiwgaywgbGVuO1xuXG4gICAgICAgIGZvciAoaSA9IGkwOyBpIDwgaTE7IGkrKykge1xuICAgICAgICAgIGogPSBpIC0gKGkgPCBzaXplID8gMCA6IHNpemUpOy8vd3JhcCBhcm91bmRcbiAgICAgICAgICBjb2RlVGFibGVbal0gPSB7IGZpcnN0OiBibG9ja0RhdGFCdWZmZXJbaSAtIGkwXSwgc2Vjb25kOiBudWxsIH07XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgZGF0YUJ5dGVzID0gaW5wdXQuYnl0ZUxlbmd0aCAtIGRhdGEucHRyO1xuICAgICAgICB2YXIgZGF0YVdvcmRzID0gTWF0aC5jZWlsKGRhdGFCeXRlcyAvIDQpO1xuICAgICAgICB2YXIgYXJyYXlCdWYgPSBuZXcgQXJyYXlCdWZmZXIoZGF0YVdvcmRzICogNCk7XG4gICAgICAgIHZhciBzdG9yZTggPSBuZXcgVWludDhBcnJheShhcnJheUJ1Zik7XG4gICAgICAgIHN0b3JlOC5zZXQobmV3IFVpbnQ4QXJyYXkoaW5wdXQsIGRhdGEucHRyLCBkYXRhQnl0ZXMpKTtcbiAgICAgICAgdmFyIHN0dWZmZWREYXRhID0gbmV3IFVpbnQzMkFycmF5KGFycmF5QnVmKTsgLy9tdXN0IHN0YXJ0IGZyb20geCo0XG4gICAgICAgIHZhciBiaXRQb3MgPSAwLCB3b3JkLCBzcmNQdHIgPSAwO1xuICAgICAgICB3b3JkID0gc3R1ZmZlZERhdGFbMF07XG4gICAgICAgIGZvciAoaSA9IGkwOyBpIDwgaTE7IGkrKykge1xuICAgICAgICAgIGogPSBpIC0gKGkgPCBzaXplID8gMCA6IHNpemUpOy8vd3JhcCBhcm91bmRcbiAgICAgICAgICBsZW4gPSBjb2RlVGFibGVbal0uZmlyc3Q7XG4gICAgICAgICAgaWYgKGxlbiA+IDApIHtcbiAgICAgICAgICAgIGNvZGVUYWJsZVtqXS5zZWNvbmQgPSAod29yZCA8PCBiaXRQb3MpID4+PiAoMzIgLSBsZW4pO1xuXG4gICAgICAgICAgICBpZiAoMzIgLSBiaXRQb3MgPj0gbGVuKSB7XG4gICAgICAgICAgICAgIGJpdFBvcyArPSBsZW47XG4gICAgICAgICAgICAgIGlmIChiaXRQb3MgPT09IDMyKSB7XG4gICAgICAgICAgICAgICAgYml0UG9zID0gMDtcbiAgICAgICAgICAgICAgICBzcmNQdHIrKztcbiAgICAgICAgICAgICAgICB3b3JkID0gc3R1ZmZlZERhdGFbc3JjUHRyXTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgIGJpdFBvcyArPSBsZW4gLSAzMjtcbiAgICAgICAgICAgICAgc3JjUHRyKys7XG4gICAgICAgICAgICAgIHdvcmQgPSBzdHVmZmVkRGF0YVtzcmNQdHJdO1xuICAgICAgICAgICAgICBjb2RlVGFibGVbal0uc2Vjb25kIHw9IHdvcmQgPj4+ICgzMiAtIGJpdFBvcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy9maW5pc2hlZCByZWFkaW5nIGNvZGUgdGFibGVcblxuICAgICAgICAvKiAqKioqKioqKioqKioqKioqKioqKioqKipcbiAgICAgICAgICogYnVpbGRpbmcgbHV0XG4gICAgICAgICAqKioqKioqKioqKioqKioqKioqKioqKioqL1xuICAgICAgICB2YXIgbnVtQml0c0xVVCA9IDAsIG51bUJpdHNMVVRRaWNrID0gMDtcbiAgICAgICAgdmFyIHRyZWUgPSBuZXcgVHJlZU5vZGUoKTtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGNvZGVUYWJsZS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGlmIChjb2RlVGFibGVbaV0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgbnVtQml0c0xVVCA9IE1hdGgubWF4KG51bUJpdHNMVVQsIGNvZGVUYWJsZVtpXS5maXJzdCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChudW1CaXRzTFVUID49IEJJVFNfTUFYKSB7XG4gICAgICAgICAgbnVtQml0c0xVVFFpY2sgPSBCSVRTX01BWDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICBudW1CaXRzTFVUUWljayA9IG51bUJpdHNMVVQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG51bUJpdHNMVVQgPj0gMzApIHtcbiAgICAgICAgICBjb25zb2xlLmxvZyhcIldBUm5pbmcsIGxhcmdlIE5VTSBMVVQgQklUUyBJUyBcIiArIG51bUJpdHNMVVQpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBkZWNvZGVMdXQgPSBbXSwgZW50cnksIGNvZGUsIG51bUVudHJpZXMsIGpqLCBjdXJyZW50Qml0LCBub2RlO1xuICAgICAgICBmb3IgKGkgPSBpMDsgaSA8IGkxOyBpKyspIHtcbiAgICAgICAgICBqID0gaSAtIChpIDwgc2l6ZSA/IDAgOiBzaXplKTsvL3dyYXAgYXJvdW5kXG4gICAgICAgICAgbGVuID0gY29kZVRhYmxlW2pdLmZpcnN0O1xuICAgICAgICAgIGlmIChsZW4gPiAwKSB7XG4gICAgICAgICAgICBlbnRyeSA9IFtsZW4sIGpdO1xuICAgICAgICAgICAgaWYgKGxlbiA8PSBudW1CaXRzTFVUUWljaykge1xuICAgICAgICAgICAgICBjb2RlID0gY29kZVRhYmxlW2pdLnNlY29uZCA8PCAobnVtQml0c0xVVFFpY2sgLSBsZW4pO1xuICAgICAgICAgICAgICBudW1FbnRyaWVzID0gMSA8PCAobnVtQml0c0xVVFFpY2sgLSBsZW4pO1xuICAgICAgICAgICAgICBmb3IgKGsgPSAwOyBrIDwgbnVtRW50cmllczsgaysrKSB7XG4gICAgICAgICAgICAgICAgZGVjb2RlTHV0W2NvZGUgfCBrXSA9IGVudHJ5O1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgLy9idWlsZCB0cmVlXG4gICAgICAgICAgICAgIGNvZGUgPSBjb2RlVGFibGVbal0uc2Vjb25kO1xuICAgICAgICAgICAgICBub2RlID0gdHJlZTtcbiAgICAgICAgICAgICAgZm9yIChqaiA9IGxlbiAtIDE7IGpqID49IDA7IGpqLS0pIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50Qml0ID0gY29kZSA+Pj4gamogJiAxOyAvL25vIGxlZnQgc2hpZnQgYXMgbGVuZ3RoIGNvdWxkIGJlIDMwLDMxXG4gICAgICAgICAgICAgICAgaWYgKGN1cnJlbnRCaXQpIHtcbiAgICAgICAgICAgICAgICAgIGlmICghbm9kZS5yaWdodCkge1xuICAgICAgICAgICAgICAgICAgICBub2RlLnJpZ2h0ID0gbmV3IFRyZWVOb2RlKCk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBub2RlID0gbm9kZS5yaWdodDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICBpZiAoIW5vZGUubGVmdCkge1xuICAgICAgICAgICAgICAgICAgICBub2RlLmxlZnQgPSBuZXcgVHJlZU5vZGUoKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIG5vZGUgPSBub2RlLmxlZnQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChqaiA9PT0gMCAmJiAhbm9kZS52YWwpIHtcbiAgICAgICAgICAgICAgICAgIG5vZGUudmFsID0gZW50cnlbMV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgZGVjb2RlTHV0OiBkZWNvZGVMdXQsXG4gICAgICAgICAgbnVtQml0c0xVVFFpY2s6IG51bUJpdHNMVVRRaWNrLFxuICAgICAgICAgIG51bUJpdHNMVVQ6IG51bUJpdHNMVVQsXG4gICAgICAgICAgdHJlZTogdHJlZSxcbiAgICAgICAgICBzdHVmZmVkRGF0YTogc3R1ZmZlZERhdGEsXG4gICAgICAgICAgc3JjUHRyOiBzcmNQdHIsXG4gICAgICAgICAgYml0UG9zOiBiaXRQb3NcbiAgICAgICAgfTtcbiAgICAgIH0sXG5cbiAgICAgIHJlYWRIdWZmbWFuOiBmdW5jdGlvbihpbnB1dCwgZGF0YSwgT3V0UGl4ZWxUeXBlQXJyYXkpIHtcbiAgICAgICAgdmFyIGhlYWRlckluZm8gPSBkYXRhLmhlYWRlckluZm87XG4gICAgICAgIHZhciBudW1EaW1zID0gaGVhZGVySW5mby5udW1EaW1zO1xuICAgICAgICB2YXIgaGVpZ2h0ID0gZGF0YS5oZWFkZXJJbmZvLmhlaWdodDtcbiAgICAgICAgdmFyIHdpZHRoID0gZGF0YS5oZWFkZXJJbmZvLndpZHRoO1xuICAgICAgICB2YXIgbnVtUGl4ZWxzID0gd2lkdGggKiBoZWlnaHQ7XG4gICAgICAgIC8vdmFyIHNpemVfbWF4ID0gMSA8PCBCSVRTX01BWDtcbiAgICAgICAgLyogKioqKioqKioqKioqKioqKioqKioqKioqXG4gICAgICAgICAqIHJlYWRpbmcgaHVmZm1hbiBzdHJ1Y3R1cmUgaW5mb1xuICAgICAgICAgKioqKioqKioqKioqKioqKioqKioqKioqKi9cbiAgICAgICAgdmFyIGh1ZmZtYW5JbmZvID0gdGhpcy5yZWFkSHVmZm1hblRyZWUoaW5wdXQsIGRhdGEpO1xuICAgICAgICB2YXIgZGVjb2RlTHV0ID0gaHVmZm1hbkluZm8uZGVjb2RlTHV0O1xuICAgICAgICB2YXIgdHJlZSA9IGh1ZmZtYW5JbmZvLnRyZWU7XG4gICAgICAgIC8vc3R1ZmZlZERhdGEgaW5jbHVkZXMgaHVmZm1hbiBoZWFkZXJzXG4gICAgICAgIHZhciBzdHVmZmVkRGF0YSA9IGh1ZmZtYW5JbmZvLnN0dWZmZWREYXRhO1xuICAgICAgICB2YXIgc3JjUHRyID0gaHVmZm1hbkluZm8uc3JjUHRyO1xuICAgICAgICB2YXIgYml0UG9zID0gaHVmZm1hbkluZm8uYml0UG9zO1xuICAgICAgICB2YXIgbnVtQml0c0xVVFFpY2sgPSBodWZmbWFuSW5mby5udW1CaXRzTFVUUWljaztcbiAgICAgICAgdmFyIG51bUJpdHNMVVQgPSBodWZmbWFuSW5mby5udW1CaXRzTFVUO1xuICAgICAgICB2YXIgb2Zmc2V0ID0gZGF0YS5oZWFkZXJJbmZvLmltYWdlVHlwZSA9PT0gMCA/IDEyOCA6IDA7XG4gICAgICAgIC8qKioqKioqKioqKioqKioqKioqKioqKioqXG4gICAgICAgICogIGRlY29kZVxuICAgICAgICAqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4gICAgICAgIHZhciBub2RlLCB2YWwsIGRlbHRhLCBtYXNrID0gZGF0YS5waXhlbHMucmVzdWx0TWFzaywgdmFsVG1wLCB2YWxUbXBRdWljaywgY3VycmVudEJpdDtcbiAgICAgICAgdmFyIGksIGosIGssIGlpO1xuICAgICAgICB2YXIgcHJldlZhbCA9IDA7XG4gICAgICAgIGlmIChiaXRQb3MgPiAwKSB7XG4gICAgICAgICAgc3JjUHRyKys7XG4gICAgICAgICAgYml0UG9zID0gMDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgd29yZCA9IHN0dWZmZWREYXRhW3NyY1B0cl07XG4gICAgICAgIHZhciBkZWx0YUVuY29kZSA9IGRhdGEuZW5jb2RlTW9kZSA9PT0gMTtcbiAgICAgICAgdmFyIHJlc3VsdFBpeGVsc0FsbERpbSA9IG5ldyBPdXRQaXhlbFR5cGVBcnJheShudW1QaXhlbHMgKiBudW1EaW1zKTtcbiAgICAgICAgdmFyIHJlc3VsdFBpeGVscyA9IHJlc3VsdFBpeGVsc0FsbERpbTtcbiAgICAgICAgdmFyIGlEaW07XG4gICAgICAgIGZvciAoaURpbSA9IDA7IGlEaW0gPCBoZWFkZXJJbmZvLm51bURpbXM7IGlEaW0rKykge1xuICAgICAgICAgIGlmIChudW1EaW1zID4gMSkge1xuICAgICAgICAgICAgLy9nZXQgdGhlIG1lbSBibG9jayBvZiBjdXJyZW50IGRpbWVuc2lvblxuICAgICAgICAgICAgcmVzdWx0UGl4ZWxzID0gbmV3IE91dFBpeGVsVHlwZUFycmF5KHJlc3VsdFBpeGVsc0FsbERpbS5idWZmZXIsIG51bVBpeGVscyAqIGlEaW0sIG51bVBpeGVscyk7XG4gICAgICAgICAgICBwcmV2VmFsID0gMDtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGRhdGEuaGVhZGVySW5mby5udW1WYWxpZFBpeGVsID09PSB3aWR0aCAqIGhlaWdodCkgeyAvL2FsbCB2YWxpZFxuICAgICAgICAgICAgZm9yIChrID0gMCwgaSA9IDA7IGkgPCBoZWlnaHQ7IGkrKykge1xuICAgICAgICAgICAgICBmb3IgKGogPSAwOyBqIDwgd2lkdGg7IGorKywgaysrKSB7XG4gICAgICAgICAgICAgICAgdmFsID0gMDtcbiAgICAgICAgICAgICAgICB2YWxUbXAgPSAod29yZCA8PCBiaXRQb3MpID4+PiAoMzIgLSBudW1CaXRzTFVUUWljayk7XG4gICAgICAgICAgICAgICAgdmFsVG1wUXVpY2sgPSB2YWxUbXA7Ly8gPj4+IGRlbHRhQml0cztcbiAgICAgICAgICAgICAgICBpZiAoMzIgLSBiaXRQb3MgPCBudW1CaXRzTFVUUWljaykge1xuICAgICAgICAgICAgICAgICAgdmFsVG1wIHw9ICgoc3R1ZmZlZERhdGFbc3JjUHRyICsgMV0pID4+PiAoNjQgLSBiaXRQb3MgLSBudW1CaXRzTFVUUWljaykpO1xuICAgICAgICAgICAgICAgICAgdmFsVG1wUXVpY2sgPSB2YWxUbXA7Ly8gPj4+IGRlbHRhQml0cztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGRlY29kZUx1dFt2YWxUbXBRdWlja10pICAgIC8vIGlmIHRoZXJlLCBtb3ZlIHRoZSBjb3JyZWN0IG51bWJlciBvZiBiaXRzIGFuZCBkb25lXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgdmFsID0gZGVjb2RlTHV0W3ZhbFRtcFF1aWNrXVsxXTtcbiAgICAgICAgICAgICAgICAgIGJpdFBvcyArPSBkZWNvZGVMdXRbdmFsVG1wUXVpY2tdWzBdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIHZhbFRtcCA9ICh3b3JkIDw8IGJpdFBvcykgPj4+ICgzMiAtIG51bUJpdHNMVVQpO1xuICAgICAgICAgICAgICAgICAgdmFsVG1wUXVpY2sgPSB2YWxUbXA7Ly8gPj4+IGRlbHRhQml0cztcbiAgICAgICAgICAgICAgICAgIGlmICgzMiAtIGJpdFBvcyA8IG51bUJpdHNMVVQpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsVG1wIHw9ICgoc3R1ZmZlZERhdGFbc3JjUHRyICsgMV0pID4+PiAoNjQgLSBiaXRQb3MgLSBudW1CaXRzTFVUKSk7XG4gICAgICAgICAgICAgICAgICAgIHZhbFRtcFF1aWNrID0gdmFsVG1wOy8vID4+PiBkZWx0YUJpdHM7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBub2RlID0gdHJlZTtcbiAgICAgICAgICAgICAgICAgIGZvciAoaWkgPSAwOyBpaSA8IG51bUJpdHNMVVQ7IGlpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudEJpdCA9IHZhbFRtcCA+Pj4gKG51bUJpdHNMVVQgLSBpaSAtIDEpICYgMTtcbiAgICAgICAgICAgICAgICAgICAgbm9kZSA9IGN1cnJlbnRCaXQgPyBub2RlLnJpZ2h0IDogbm9kZS5sZWZ0O1xuICAgICAgICAgICAgICAgICAgICBpZiAoIShub2RlLmxlZnQgfHwgbm9kZS5yaWdodCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICB2YWwgPSBub2RlLnZhbDtcbiAgICAgICAgICAgICAgICAgICAgICBiaXRQb3MgPSBiaXRQb3MgKyBpaSArIDE7XG4gICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoYml0UG9zID49IDMyKSB7XG4gICAgICAgICAgICAgICAgICBiaXRQb3MgLT0gMzI7XG4gICAgICAgICAgICAgICAgICBzcmNQdHIrKztcbiAgICAgICAgICAgICAgICAgIHdvcmQgPSBzdHVmZmVkRGF0YVtzcmNQdHJdO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGRlbHRhID0gdmFsIC0gb2Zmc2V0O1xuICAgICAgICAgICAgICAgIGlmIChkZWx0YUVuY29kZSkge1xuICAgICAgICAgICAgICAgICAgaWYgKGogPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGRlbHRhICs9IHByZXZWYWw7ICAgIC8vIHVzZSBvdmVyZmxvd1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoaSA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgZGVsdGEgKz0gcmVzdWx0UGl4ZWxzW2sgLSB3aWR0aF07XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZGVsdGEgKz0gcHJldlZhbDtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIGRlbHRhICY9IDB4RkY7IC8vb3ZlcmZsb3dcbiAgICAgICAgICAgICAgICAgIHJlc3VsdFBpeGVsc1trXSA9IGRlbHRhOy8vb3ZlcmZsb3dcbiAgICAgICAgICAgICAgICAgIHByZXZWYWwgPSBkZWx0YTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICByZXN1bHRQaXhlbHNba10gPSBkZWx0YTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSB7IC8vbm90IGFsbCB2YWxpZCwgdXNlIG1hc2tcbiAgICAgICAgICAgIGZvciAoayA9IDAsIGkgPSAwOyBpIDwgaGVpZ2h0OyBpKyspIHtcbiAgICAgICAgICAgICAgZm9yIChqID0gMDsgaiA8IHdpZHRoOyBqKyssIGsrKykge1xuICAgICAgICAgICAgICAgIGlmIChtYXNrW2tdKSB7XG4gICAgICAgICAgICAgICAgICB2YWwgPSAwO1xuICAgICAgICAgICAgICAgICAgdmFsVG1wID0gKHdvcmQgPDwgYml0UG9zKSA+Pj4gKDMyIC0gbnVtQml0c0xVVFFpY2spO1xuICAgICAgICAgICAgICAgICAgdmFsVG1wUXVpY2sgPSB2YWxUbXA7Ly8gPj4+IGRlbHRhQml0cztcbiAgICAgICAgICAgICAgICAgIGlmICgzMiAtIGJpdFBvcyA8IG51bUJpdHNMVVRRaWNrKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhbFRtcCB8PSAoKHN0dWZmZWREYXRhW3NyY1B0ciArIDFdKSA+Pj4gKDY0IC0gYml0UG9zIC0gbnVtQml0c0xVVFFpY2spKTtcbiAgICAgICAgICAgICAgICAgICAgdmFsVG1wUXVpY2sgPSB2YWxUbXA7Ly8gPj4+IGRlbHRhQml0cztcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIGlmIChkZWNvZGVMdXRbdmFsVG1wUXVpY2tdKSAgICAvLyBpZiB0aGVyZSwgbW92ZSB0aGUgY29ycmVjdCBudW1iZXIgb2YgYml0cyBhbmQgZG9uZVxuICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICB2YWwgPSBkZWNvZGVMdXRbdmFsVG1wUXVpY2tdWzFdO1xuICAgICAgICAgICAgICAgICAgICBiaXRQb3MgKz0gZGVjb2RlTHV0W3ZhbFRtcFF1aWNrXVswXTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB2YWxUbXAgPSAod29yZCA8PCBiaXRQb3MpID4+PiAoMzIgLSBudW1CaXRzTFVUKTtcbiAgICAgICAgICAgICAgICAgICAgdmFsVG1wUXVpY2sgPSB2YWxUbXA7Ly8gPj4+IGRlbHRhQml0cztcbiAgICAgICAgICAgICAgICAgICAgaWYgKDMyIC0gYml0UG9zIDwgbnVtQml0c0xVVCkge1xuICAgICAgICAgICAgICAgICAgICAgIHZhbFRtcCB8PSAoKHN0dWZmZWREYXRhW3NyY1B0ciArIDFdKSA+Pj4gKDY0IC0gYml0UG9zIC0gbnVtQml0c0xVVCkpO1xuICAgICAgICAgICAgICAgICAgICAgIHZhbFRtcFF1aWNrID0gdmFsVG1wOy8vID4+PiBkZWx0YUJpdHM7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgbm9kZSA9IHRyZWU7XG4gICAgICAgICAgICAgICAgICAgIGZvciAoaWkgPSAwOyBpaSA8IG51bUJpdHNMVVQ7IGlpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50Qml0ID0gdmFsVG1wID4+PiAobnVtQml0c0xVVCAtIGlpIC0gMSkgJiAxO1xuICAgICAgICAgICAgICAgICAgICAgIG5vZGUgPSBjdXJyZW50Qml0ID8gbm9kZS5yaWdodCA6IG5vZGUubGVmdDtcbiAgICAgICAgICAgICAgICAgICAgICBpZiAoIShub2RlLmxlZnQgfHwgbm9kZS5yaWdodCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbCA9IG5vZGUudmFsO1xuICAgICAgICAgICAgICAgICAgICAgICAgYml0UG9zID0gYml0UG9zICsgaWkgKyAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgIGlmIChiaXRQb3MgPj0gMzIpIHtcbiAgICAgICAgICAgICAgICAgICAgYml0UG9zIC09IDMyO1xuICAgICAgICAgICAgICAgICAgICBzcmNQdHIrKztcbiAgICAgICAgICAgICAgICAgICAgd29yZCA9IHN0dWZmZWREYXRhW3NyY1B0cl07XG4gICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgIGRlbHRhID0gdmFsIC0gb2Zmc2V0O1xuICAgICAgICAgICAgICAgICAgaWYgKGRlbHRhRW5jb2RlKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChqID4gMCAmJiBtYXNrW2sgLSAxXSkge1xuICAgICAgICAgICAgICAgICAgICAgIGRlbHRhICs9IHByZXZWYWw7ICAgIC8vIHVzZSBvdmVyZmxvd1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGkgPiAwICYmIG1hc2tbayAtIHdpZHRoXSkge1xuICAgICAgICAgICAgICAgICAgICAgIGRlbHRhICs9IHJlc3VsdFBpeGVsc1trIC0gd2lkdGhdO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgIGRlbHRhICs9IHByZXZWYWw7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBkZWx0YSAmPSAweEZGOyAvL292ZXJmbG93XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdFBpeGVsc1trXSA9IGRlbHRhOy8vb3ZlcmZsb3dcbiAgICAgICAgICAgICAgICAgICAgcHJldlZhbCA9IGRlbHRhO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdFBpeGVsc1trXSA9IGRlbHRhO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBkYXRhLnB0ciA9IGRhdGEucHRyICsgKHNyY1B0ciArIDEpICogNCArIChiaXRQb3MgPiAwID8gNCA6IDApO1xuICAgICAgICB9XG4gICAgICAgIGRhdGEucGl4ZWxzLnJlc3VsdFBpeGVscyA9IHJlc3VsdFBpeGVsc0FsbERpbTtcbiAgICAgIH0sXG5cbiAgICAgIGRlY29kZUJpdHM6IGZ1bmN0aW9uKGlucHV0LCBkYXRhLCBibG9ja0RhdGFCdWZmZXIsIG9mZnNldCwgaURpbSkge1xuICAgICAgICB7XG4gICAgICAgICAgLy9iaXRzdHVmZiBlbmNvZGluZyBpcyAzXG4gICAgICAgICAgdmFyIGhlYWRlckluZm8gPSBkYXRhLmhlYWRlckluZm87XG4gICAgICAgICAgdmFyIGZpbGVWZXJzaW9uID0gaGVhZGVySW5mby5maWxlVmVyc2lvbjtcbiAgICAgICAgICAvL3ZhciBibG9jayA9IHt9O1xuICAgICAgICAgIHZhciBibG9ja1B0ciA9IDA7XG4gICAgICAgICAgdmFyIHZpZXcgPSBuZXcgRGF0YVZpZXcoaW5wdXQsIGRhdGEucHRyLCA1KTsvL3RvIGRvXG4gICAgICAgICAgdmFyIGhlYWRlckJ5dGUgPSB2aWV3LmdldFVpbnQ4KDApO1xuICAgICAgICAgIGJsb2NrUHRyKys7XG4gICAgICAgICAgdmFyIGJpdHM2NyA9IGhlYWRlckJ5dGUgPj4gNjtcbiAgICAgICAgICB2YXIgbiA9IChiaXRzNjcgPT09IDApID8gNCA6IDMgLSBiaXRzNjc7XG4gICAgICAgICAgdmFyIGRvTHV0ID0gKGhlYWRlckJ5dGUgJiAzMikgPiAwID8gdHJ1ZSA6IGZhbHNlOy8vNXRoIGJpdFxuICAgICAgICAgIHZhciBudW1CaXRzID0gaGVhZGVyQnl0ZSAmIDMxO1xuICAgICAgICAgIHZhciBudW1FbGVtZW50cyA9IDA7XG4gICAgICAgICAgaWYgKG4gPT09IDEpIHtcbiAgICAgICAgICAgIG51bUVsZW1lbnRzID0gdmlldy5nZXRVaW50OChibG9ja1B0cik7IGJsb2NrUHRyKys7XG4gICAgICAgICAgfSBlbHNlIGlmIChuID09PSAyKSB7XG4gICAgICAgICAgICBudW1FbGVtZW50cyA9IHZpZXcuZ2V0VWludDE2KGJsb2NrUHRyLCB0cnVlKTsgYmxvY2tQdHIgKz0gMjtcbiAgICAgICAgICB9IGVsc2UgaWYgKG4gPT09IDQpIHtcbiAgICAgICAgICAgIG51bUVsZW1lbnRzID0gdmlldy5nZXRVaW50MzIoYmxvY2tQdHIsIHRydWUpOyBibG9ja1B0ciArPSA0O1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBcIkludmFsaWQgdmFsaWQgcGl4ZWwgY291bnQgdHlwZVwiO1xuICAgICAgICAgIH1cbiAgICAgICAgICAvL2ZpeDogaHVmZm1hbiBjb2RlcyBhcmUgYml0IHN0dWZmZWQsIGJ1dCBub3QgYm91bmQgYnkgZGF0YSdzIG1heCB2YWx1ZSwgc28gbmVlZCB0byB1c2Ugb3JpZ2luYWxVbnN0dWZmXG4gICAgICAgICAgLy9vZmZzZXQgPSBvZmZzZXQgfHwgMDtcbiAgICAgICAgICB2YXIgc2NhbGUgPSAyICogaGVhZGVySW5mby5tYXhaRXJyb3I7XG4gICAgICAgICAgdmFyIHN0dWZmZWREYXRhLCBhcnJheUJ1Ziwgc3RvcmU4LCBkYXRhQnl0ZXMsIGRhdGFXb3JkcztcbiAgICAgICAgICB2YXIgbHV0QXJyLCBsdXREYXRhLCBsdXRCeXRlcywgYml0c1BlclBpeGVsO1xuICAgICAgICAgIHZhciB6TWF4ID0gaGVhZGVySW5mby5udW1EaW1zID4gMSA/IGhlYWRlckluZm8ubWF4VmFsdWVzW2lEaW1dIDogaGVhZGVySW5mby56TWF4O1xuICAgICAgICAgIGlmIChkb0x1dCkge1xuICAgICAgICAgICAgZGF0YS5jb3VudGVyLmx1dCsrO1xuICAgICAgICAgICAgbHV0Qnl0ZXMgPSB2aWV3LmdldFVpbnQ4KGJsb2NrUHRyKTtcbiAgICAgICAgICAgIGJsb2NrUHRyKys7XG4gICAgICAgICAgICBkYXRhQnl0ZXMgPSBNYXRoLmNlaWwoKGx1dEJ5dGVzIC0gMSkgKiBudW1CaXRzIC8gOCk7XG4gICAgICAgICAgICBkYXRhV29yZHMgPSBNYXRoLmNlaWwoZGF0YUJ5dGVzIC8gNCk7XG4gICAgICAgICAgICBhcnJheUJ1ZiA9IG5ldyBBcnJheUJ1ZmZlcihkYXRhV29yZHMgKiA0KTtcbiAgICAgICAgICAgIHN0b3JlOCA9IG5ldyBVaW50OEFycmF5KGFycmF5QnVmKTtcblxuICAgICAgICAgICAgZGF0YS5wdHIgKz0gYmxvY2tQdHI7XG4gICAgICAgICAgICBzdG9yZTguc2V0KG5ldyBVaW50OEFycmF5KGlucHV0LCBkYXRhLnB0ciwgZGF0YUJ5dGVzKSk7XG5cbiAgICAgICAgICAgIGx1dERhdGEgPSBuZXcgVWludDMyQXJyYXkoYXJyYXlCdWYpO1xuICAgICAgICAgICAgZGF0YS5wdHIgKz0gZGF0YUJ5dGVzO1xuXG4gICAgICAgICAgICBiaXRzUGVyUGl4ZWwgPSAwO1xuICAgICAgICAgICAgd2hpbGUgKChsdXRCeXRlcyAtIDEpID4+PiBiaXRzUGVyUGl4ZWwpIHtcbiAgICAgICAgICAgICAgYml0c1BlclBpeGVsKys7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkYXRhQnl0ZXMgPSBNYXRoLmNlaWwobnVtRWxlbWVudHMgKiBiaXRzUGVyUGl4ZWwgLyA4KTtcbiAgICAgICAgICAgIGRhdGFXb3JkcyA9IE1hdGguY2VpbChkYXRhQnl0ZXMgLyA0KTtcbiAgICAgICAgICAgIGFycmF5QnVmID0gbmV3IEFycmF5QnVmZmVyKGRhdGFXb3JkcyAqIDQpO1xuICAgICAgICAgICAgc3RvcmU4ID0gbmV3IFVpbnQ4QXJyYXkoYXJyYXlCdWYpO1xuICAgICAgICAgICAgc3RvcmU4LnNldChuZXcgVWludDhBcnJheShpbnB1dCwgZGF0YS5wdHIsIGRhdGFCeXRlcykpO1xuICAgICAgICAgICAgc3R1ZmZlZERhdGEgPSBuZXcgVWludDMyQXJyYXkoYXJyYXlCdWYpO1xuICAgICAgICAgICAgZGF0YS5wdHIgKz0gZGF0YUJ5dGVzO1xuICAgICAgICAgICAgaWYgKGZpbGVWZXJzaW9uID49IDMpIHtcbiAgICAgICAgICAgICAgbHV0QXJyID0gQml0U3R1ZmZlci51bnN0dWZmTFVUMihsdXREYXRhLCBudW1CaXRzLCBsdXRCeXRlcyAtIDEsIG9mZnNldCwgc2NhbGUsIHpNYXgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgIGx1dEFyciA9IEJpdFN0dWZmZXIudW5zdHVmZkxVVChsdXREYXRhLCBudW1CaXRzLCBsdXRCeXRlcyAtIDEsIG9mZnNldCwgc2NhbGUsIHpNYXgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy9sdXRBcnIudW5zaGlmdCgwKTtcbiAgICAgICAgICAgIGlmIChmaWxlVmVyc2lvbiA+PSAzKSB7XG4gICAgICAgICAgICAgIC8vQml0U3R1ZmZlci51bnN0dWZmMihibG9jaywgYmxvY2tEYXRhQnVmZmVyLCBoZWFkZXJJbmZvLnpNYXgpO1xuICAgICAgICAgICAgICBCaXRTdHVmZmVyLnVuc3R1ZmYyKHN0dWZmZWREYXRhLCBibG9ja0RhdGFCdWZmZXIsIGJpdHNQZXJQaXhlbCwgbnVtRWxlbWVudHMsIGx1dEFycik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgQml0U3R1ZmZlci51bnN0dWZmKHN0dWZmZWREYXRhLCBibG9ja0RhdGFCdWZmZXIsIGJpdHNQZXJQaXhlbCwgbnVtRWxlbWVudHMsIGx1dEFycik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy9jb25zb2xlLmRlYnVnKFwiYml0c3R1ZmZlclwiKTtcbiAgICAgICAgICAgIGRhdGEuY291bnRlci5iaXRzdHVmZmVyKys7XG4gICAgICAgICAgICBiaXRzUGVyUGl4ZWwgPSBudW1CaXRzO1xuICAgICAgICAgICAgZGF0YS5wdHIgKz0gYmxvY2tQdHI7XG4gICAgICAgICAgICBpZiAoYml0c1BlclBpeGVsID4gMCkge1xuICAgICAgICAgICAgICBkYXRhQnl0ZXMgPSBNYXRoLmNlaWwobnVtRWxlbWVudHMgKiBiaXRzUGVyUGl4ZWwgLyA4KTtcbiAgICAgICAgICAgICAgZGF0YVdvcmRzID0gTWF0aC5jZWlsKGRhdGFCeXRlcyAvIDQpO1xuICAgICAgICAgICAgICBhcnJheUJ1ZiA9IG5ldyBBcnJheUJ1ZmZlcihkYXRhV29yZHMgKiA0KTtcbiAgICAgICAgICAgICAgc3RvcmU4ID0gbmV3IFVpbnQ4QXJyYXkoYXJyYXlCdWYpO1xuICAgICAgICAgICAgICBzdG9yZTguc2V0KG5ldyBVaW50OEFycmF5KGlucHV0LCBkYXRhLnB0ciwgZGF0YUJ5dGVzKSk7XG4gICAgICAgICAgICAgIHN0dWZmZWREYXRhID0gbmV3IFVpbnQzMkFycmF5KGFycmF5QnVmKTtcbiAgICAgICAgICAgICAgZGF0YS5wdHIgKz0gZGF0YUJ5dGVzO1xuICAgICAgICAgICAgICBpZiAoZmlsZVZlcnNpb24gPj0gMykge1xuICAgICAgICAgICAgICAgIGlmIChvZmZzZXQgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgQml0U3R1ZmZlci5vcmlnaW5hbFVuc3R1ZmYyKHN0dWZmZWREYXRhLCBibG9ja0RhdGFCdWZmZXIsIGJpdHNQZXJQaXhlbCwgbnVtRWxlbWVudHMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIEJpdFN0dWZmZXIudW5zdHVmZjIoc3R1ZmZlZERhdGEsIGJsb2NrRGF0YUJ1ZmZlciwgYml0c1BlclBpeGVsLCBudW1FbGVtZW50cywgZmFsc2UsIG9mZnNldCwgc2NhbGUsIHpNYXgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAob2Zmc2V0ID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgIEJpdFN0dWZmZXIub3JpZ2luYWxVbnN0dWZmKHN0dWZmZWREYXRhLCBibG9ja0RhdGFCdWZmZXIsIGJpdHNQZXJQaXhlbCwgbnVtRWxlbWVudHMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIEJpdFN0dWZmZXIudW5zdHVmZihzdHVmZmVkRGF0YSwgYmxvY2tEYXRhQnVmZmVyLCBiaXRzUGVyUGl4ZWwsIG51bUVsZW1lbnRzLCBmYWxzZSwgb2Zmc2V0LCBzY2FsZSwgek1heCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgIH0sXG5cbiAgICAgIHJlYWRUaWxlczogZnVuY3Rpb24oaW5wdXQsIGRhdGEsIE91dFBpeGVsVHlwZUFycmF5KSB7XG4gICAgICAgIHZhciBoZWFkZXJJbmZvID0gZGF0YS5oZWFkZXJJbmZvO1xuICAgICAgICB2YXIgd2lkdGggPSBoZWFkZXJJbmZvLndpZHRoO1xuICAgICAgICB2YXIgaGVpZ2h0ID0gaGVhZGVySW5mby5oZWlnaHQ7XG4gICAgICAgIHZhciBtaWNyb0Jsb2NrU2l6ZSA9IGhlYWRlckluZm8ubWljcm9CbG9ja1NpemU7XG4gICAgICAgIHZhciBpbWFnZVR5cGUgPSBoZWFkZXJJbmZvLmltYWdlVHlwZTtcbiAgICAgICAgdmFyIGRhdGFUeXBlU2l6ZSA9IExlcmMySGVscGVycy5nZXREYXRhVHlwZVNpemUoaW1hZ2VUeXBlKTtcbiAgICAgICAgdmFyIG51bUJsb2Nrc1ggPSBNYXRoLmNlaWwod2lkdGggLyBtaWNyb0Jsb2NrU2l6ZSk7XG4gICAgICAgIHZhciBudW1CbG9ja3NZID0gTWF0aC5jZWlsKGhlaWdodCAvIG1pY3JvQmxvY2tTaXplKTtcbiAgICAgICAgZGF0YS5waXhlbHMubnVtQmxvY2tzWSA9IG51bUJsb2Nrc1k7XG4gICAgICAgIGRhdGEucGl4ZWxzLm51bUJsb2Nrc1ggPSBudW1CbG9ja3NYO1xuICAgICAgICBkYXRhLnBpeGVscy5wdHIgPSAwO1xuICAgICAgICB2YXIgcm93ID0gMCwgY29sID0gMCwgYmxvY2tZID0gMCwgYmxvY2tYID0gMCwgdGhpc0Jsb2NrSGVpZ2h0ID0gMCwgdGhpc0Jsb2NrV2lkdGggPSAwLCBieXRlc0xlZnQgPSAwLCBoZWFkZXJCeXRlID0gMCwgYml0czY3ID0gMCwgdGVzdENvZGUgPSAwLCBvdXRQdHIgPSAwLCBvdXRTdHJpZGUgPSAwLCBudW1CeXRlcyA9IDAsIGJ5dGVzbGVmdCA9IDAsIHogPSAwLCBibG9ja1B0ciA9IDA7XG4gICAgICAgIHZhciB2aWV3LCBibG9jaywgYXJyYXlCdWYsIHN0b3JlOCwgcmF3RGF0YTtcbiAgICAgICAgdmFyIGJsb2NrRW5jb2Rpbmc7XG4gICAgICAgIHZhciBibG9ja0RhdGFCdWZmZXIgPSBuZXcgT3V0UGl4ZWxUeXBlQXJyYXkobWljcm9CbG9ja1NpemUgKiBtaWNyb0Jsb2NrU2l6ZSk7XG4gICAgICAgIHZhciBsYXN0QmxvY2tIZWlnaHQgPSAoaGVpZ2h0ICUgbWljcm9CbG9ja1NpemUpIHx8IG1pY3JvQmxvY2tTaXplO1xuICAgICAgICB2YXIgbGFzdEJsb2NrV2lkdGggPSAod2lkdGggJSBtaWNyb0Jsb2NrU2l6ZSkgfHwgbWljcm9CbG9ja1NpemU7XG4gICAgICAgIHZhciBvZmZzZXRUeXBlLCBvZmZzZXQ7XG4gICAgICAgIHZhciBudW1EaW1zID0gaGVhZGVySW5mby5udW1EaW1zLCBpRGltO1xuICAgICAgICB2YXIgbWFzayA9IGRhdGEucGl4ZWxzLnJlc3VsdE1hc2s7XG4gICAgICAgIHZhciByZXN1bHRQaXhlbHMgPSBkYXRhLnBpeGVscy5yZXN1bHRQaXhlbHM7XG4gICAgICAgIGZvciAoYmxvY2tZID0gMDsgYmxvY2tZIDwgbnVtQmxvY2tzWTsgYmxvY2tZKyspIHtcbiAgICAgICAgICB0aGlzQmxvY2tIZWlnaHQgPSAoYmxvY2tZICE9PSBudW1CbG9ja3NZIC0gMSkgPyBtaWNyb0Jsb2NrU2l6ZSA6IGxhc3RCbG9ja0hlaWdodDtcbiAgICAgICAgICBmb3IgKGJsb2NrWCA9IDA7IGJsb2NrWCA8IG51bUJsb2Nrc1g7IGJsb2NrWCsrKSB7XG4gICAgICAgICAgICAvL2NvbnNvbGUuZGVidWcoXCJ5XCIgKyBibG9ja1kgKyBcIiB4XCIgKyBibG9ja1gpO1xuICAgICAgICAgICAgdGhpc0Jsb2NrV2lkdGggPSAoYmxvY2tYICE9PSBudW1CbG9ja3NYIC0gMSkgPyBtaWNyb0Jsb2NrU2l6ZSA6IGxhc3RCbG9ja1dpZHRoO1xuXG4gICAgICAgICAgICBvdXRQdHIgPSBibG9ja1kgKiB3aWR0aCAqIG1pY3JvQmxvY2tTaXplICsgYmxvY2tYICogbWljcm9CbG9ja1NpemU7XG4gICAgICAgICAgICBvdXRTdHJpZGUgPSB3aWR0aCAtIHRoaXNCbG9ja1dpZHRoO1xuXG5cbiAgICAgICAgICAgIGZvciAoaURpbSA9IDA7IGlEaW0gPCBudW1EaW1zOyBpRGltKyspIHtcbiAgICAgICAgICAgICAgaWYgKG51bURpbXMgPiAxKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0UGl4ZWxzID0gbmV3IE91dFBpeGVsVHlwZUFycmF5KGRhdGEucGl4ZWxzLnJlc3VsdFBpeGVscy5idWZmZXIsIHdpZHRoICogaGVpZ2h0ICogaURpbSAqIGRhdGFUeXBlU2l6ZSwgd2lkdGggKiBoZWlnaHQpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGJ5dGVzTGVmdCA9IGlucHV0LmJ5dGVMZW5ndGggLSBkYXRhLnB0cjtcbiAgICAgICAgICAgICAgdmlldyA9IG5ldyBEYXRhVmlldyhpbnB1dCwgZGF0YS5wdHIsIE1hdGgubWluKDEwLCBieXRlc0xlZnQpKTtcbiAgICAgICAgICAgICAgYmxvY2sgPSB7fTtcbiAgICAgICAgICAgICAgYmxvY2tQdHIgPSAwO1xuICAgICAgICAgICAgICBoZWFkZXJCeXRlID0gdmlldy5nZXRVaW50OCgwKTtcbiAgICAgICAgICAgICAgYmxvY2tQdHIrKztcbiAgICAgICAgICAgICAgYml0czY3ID0gKGhlYWRlckJ5dGUgPj4gNikgJiAweEZGO1xuICAgICAgICAgICAgICB0ZXN0Q29kZSA9IChoZWFkZXJCeXRlID4+IDIpICYgMTU7ICAgIC8vIHVzZSBiaXRzIDIzNDUgZm9yIGludGVncml0eSBjaGVja1xuICAgICAgICAgICAgICBpZiAodGVzdENvZGUgIT09ICgoKGJsb2NrWCAqIG1pY3JvQmxvY2tTaXplKSA+PiAzKSAmIDE1KSkge1xuICAgICAgICAgICAgICAgIHRocm93IFwiaW50ZWdyaXR5IGlzc3VlXCI7XG4gICAgICAgICAgICAgICAgLy9yZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBibG9ja0VuY29kaW5nID0gaGVhZGVyQnl0ZSAmIDM7XG4gICAgICAgICAgICAgIGlmIChibG9ja0VuY29kaW5nID4gMykge1xuICAgICAgICAgICAgICAgIGRhdGEucHRyICs9IGJsb2NrUHRyO1xuICAgICAgICAgICAgICAgIHRocm93IFwiSW52YWxpZCBibG9jayBlbmNvZGluZyAoXCIgKyBibG9ja0VuY29kaW5nICsgXCIpXCI7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgZWxzZSBpZiAoYmxvY2tFbmNvZGluZyA9PT0gMikgeyAvL2NvbnN0YW50IDBcbiAgICAgICAgICAgICAgICBkYXRhLmNvdW50ZXIuY29uc3RhbnQrKztcbiAgICAgICAgICAgICAgICBkYXRhLnB0ciArPSBibG9ja1B0cjtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBlbHNlIGlmIChibG9ja0VuY29kaW5nID09PSAwKSB7ICAvL3VuY29tcHJlc3NlZFxuICAgICAgICAgICAgICAgIGRhdGEuY291bnRlci51bmNvbXByZXNzZWQrKztcbiAgICAgICAgICAgICAgICBkYXRhLnB0ciArPSBibG9ja1B0cjtcbiAgICAgICAgICAgICAgICBudW1CeXRlcyA9IHRoaXNCbG9ja0hlaWdodCAqIHRoaXNCbG9ja1dpZHRoICogZGF0YVR5cGVTaXplO1xuICAgICAgICAgICAgICAgIGJ5dGVzbGVmdCA9IGlucHV0LmJ5dGVMZW5ndGggLSBkYXRhLnB0cjtcbiAgICAgICAgICAgICAgICBudW1CeXRlcyA9IG51bUJ5dGVzIDwgYnl0ZXNsZWZ0ID8gbnVtQnl0ZXMgOiBieXRlc2xlZnQ7XG4gICAgICAgICAgICAgICAgLy9iaXQgYWxpZ25tZW50XG4gICAgICAgICAgICAgICAgYXJyYXlCdWYgPSBuZXcgQXJyYXlCdWZmZXIoKG51bUJ5dGVzICUgZGF0YVR5cGVTaXplKSA9PT0gMCA/IG51bUJ5dGVzIDogKG51bUJ5dGVzICsgZGF0YVR5cGVTaXplIC0gbnVtQnl0ZXMgJSBkYXRhVHlwZVNpemUpKTtcbiAgICAgICAgICAgICAgICBzdG9yZTggPSBuZXcgVWludDhBcnJheShhcnJheUJ1Zik7XG4gICAgICAgICAgICAgICAgc3RvcmU4LnNldChuZXcgVWludDhBcnJheShpbnB1dCwgZGF0YS5wdHIsIG51bUJ5dGVzKSk7XG4gICAgICAgICAgICAgICAgcmF3RGF0YSA9IG5ldyBPdXRQaXhlbFR5cGVBcnJheShhcnJheUJ1Zik7XG4gICAgICAgICAgICAgICAgeiA9IDA7XG4gICAgICAgICAgICAgICAgaWYgKG1hc2spIHtcbiAgICAgICAgICAgICAgICAgIGZvciAocm93ID0gMDsgcm93IDwgdGhpc0Jsb2NrSGVpZ2h0OyByb3crKykge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGNvbCA9IDA7IGNvbCA8IHRoaXNCbG9ja1dpZHRoOyBjb2wrKykge1xuICAgICAgICAgICAgICAgICAgICAgIGlmIChtYXNrW291dFB0cl0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdFBpeGVsc1tvdXRQdHJdID0gcmF3RGF0YVt6KytdO1xuICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICBvdXRQdHIrKztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBvdXRQdHIgKz0gb3V0U3RyaWRlO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHsvL2FsbCB2YWxpZFxuICAgICAgICAgICAgICAgICAgZm9yIChyb3cgPSAwOyByb3cgPCB0aGlzQmxvY2tIZWlnaHQ7IHJvdysrKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAoY29sID0gMDsgY29sIDwgdGhpc0Jsb2NrV2lkdGg7IGNvbCsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgcmVzdWx0UGl4ZWxzW291dFB0cisrXSA9IHJhd0RhdGFbeisrXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBvdXRQdHIgKz0gb3V0U3RyaWRlO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBkYXRhLnB0ciArPSB6ICogZGF0YVR5cGVTaXplO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGVsc2UgeyAvLzEgb3IgM1xuICAgICAgICAgICAgICAgIG9mZnNldFR5cGUgPSBMZXJjMkhlbHBlcnMuZ2V0RGF0YVR5cGVVc2VkKGltYWdlVHlwZSwgYml0czY3KTtcbiAgICAgICAgICAgICAgICBvZmZzZXQgPSBMZXJjMkhlbHBlcnMuZ2V0T25lUGl4ZWwoYmxvY2ssIGJsb2NrUHRyLCBvZmZzZXRUeXBlLCB2aWV3KTtcbiAgICAgICAgICAgICAgICBibG9ja1B0ciArPSBMZXJjMkhlbHBlcnMuZ2V0RGF0YVR5cGVTaXplKG9mZnNldFR5cGUpO1xuICAgICAgICAgICAgICAgIGlmIChibG9ja0VuY29kaW5nID09PSAzKSAvL2NvbnN0YW50IG9mZnNldCB2YWx1ZVxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgIGRhdGEucHRyICs9IGJsb2NrUHRyO1xuICAgICAgICAgICAgICAgICAgZGF0YS5jb3VudGVyLmNvbnN0YW50b2Zmc2V0Kys7XG4gICAgICAgICAgICAgICAgICAvL3lvdSBjYW4gZGVsZXRlIHRoZSBmb2xsb3dpbmcgcmVzdWx0TWFzayBjYXNlIGluIGZhdm9yIG9mIHBlcmZvcm1hbmNlIGJlY2F1c2UgdmFsIGlzIGNvbnN0YW50IGFuZCB1c2VycyB1c2Ugbm9kYXRhIG1hc2ssIG90aGVyd2lzZSBub2RhdGF2YWx1ZSBwb3N0IHByb2Nlc3NpbmcgaGFuZGxlcyBpdCB0b28uXG4gICAgICAgICAgICAgICAgICAvL3doaWxlIHRoZSBhYm92ZSBzdGF0ZW1lbnQgaXMgdHJ1ZSwgd2UncmUgbm90IGRvaW5nIGl0IGFzIHdlIHdhbnQgdG8ga2VlcCBpbnZhbGlkIHBpeGVsIHZhbHVlIGF0IDAgcmF0aGVyIHRoYW4gYXJiaXRyYXJ5IHZhbHVlc1xuICAgICAgICAgICAgICAgICAgaWYgKG1hc2spIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChyb3cgPSAwOyByb3cgPCB0aGlzQmxvY2tIZWlnaHQ7IHJvdysrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgZm9yIChjb2wgPSAwOyBjb2wgPCB0aGlzQmxvY2tXaWR0aDsgY29sKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChtYXNrW291dFB0cl0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0UGl4ZWxzW291dFB0cl0gPSBvZmZzZXQ7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBvdXRQdHIrKztcbiAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgb3V0UHRyICs9IG91dFN0cmlkZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAocm93ID0gMDsgcm93IDwgdGhpc0Jsb2NrSGVpZ2h0OyByb3crKykge1xuICAgICAgICAgICAgICAgICAgICAgIGZvciAoY29sID0gMDsgY29sIDwgdGhpc0Jsb2NrV2lkdGg7IGNvbCsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHRQaXhlbHNbb3V0UHRyKytdID0gb2Zmc2V0O1xuICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICBvdXRQdHIgKz0gb3V0U3RyaWRlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgeyAvL2JpdHN0dWZmIGVuY29kaW5nIGlzIDNcbiAgICAgICAgICAgICAgICAgIGRhdGEucHRyICs9IGJsb2NrUHRyO1xuICAgICAgICAgICAgICAgICAgLy9oZWF2eSBsaWZ0aW5nXG4gICAgICAgICAgICAgICAgICBMZXJjMkhlbHBlcnMuZGVjb2RlQml0cyhpbnB1dCwgZGF0YSwgYmxvY2tEYXRhQnVmZmVyLCBvZmZzZXQsIGlEaW0pO1xuICAgICAgICAgICAgICAgICAgYmxvY2tQdHIgPSAwO1xuICAgICAgICAgICAgICAgICAgaWYgKG1hc2spIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChyb3cgPSAwOyByb3cgPCB0aGlzQmxvY2tIZWlnaHQ7IHJvdysrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgZm9yIChjb2wgPSAwOyBjb2wgPCB0aGlzQmxvY2tXaWR0aDsgY29sKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChtYXNrW291dFB0cl0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0UGl4ZWxzW291dFB0cl0gPSBibG9ja0RhdGFCdWZmZXJbYmxvY2tQdHIrK107XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBvdXRQdHIrKztcbiAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgb3V0UHRyICs9IG91dFN0cmlkZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAocm93ID0gMDsgcm93IDwgdGhpc0Jsb2NrSGVpZ2h0OyByb3crKykge1xuICAgICAgICAgICAgICAgICAgICAgIGZvciAoY29sID0gMDsgY29sIDwgdGhpc0Jsb2NrV2lkdGg7IGNvbCsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHRQaXhlbHNbb3V0UHRyKytdID0gYmxvY2tEYXRhQnVmZmVyW2Jsb2NrUHRyKytdO1xuICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICBvdXRQdHIgKz0gb3V0U3RyaWRlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9LFxuXG4gICAgICAvKioqKioqKioqKioqKioqKipcbiAgICAgICogIHByaXZhdGUgbWV0aG9kcyAoaGVscGVyIG1ldGhvZHMpXG4gICAgICAqKioqKioqKioqKioqKioqKi9cblxuICAgICAgZm9ybWF0RmlsZUluZm86IGZ1bmN0aW9uKGRhdGEpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBcImZpbGVJZGVudGlmaWVyU3RyaW5nXCI6IGRhdGEuaGVhZGVySW5mby5maWxlSWRlbnRpZmllclN0cmluZyxcbiAgICAgICAgICBcImZpbGVWZXJzaW9uXCI6IGRhdGEuaGVhZGVySW5mby5maWxlVmVyc2lvbixcbiAgICAgICAgICBcImltYWdlVHlwZVwiOiBkYXRhLmhlYWRlckluZm8uaW1hZ2VUeXBlLFxuICAgICAgICAgIFwiaGVpZ2h0XCI6IGRhdGEuaGVhZGVySW5mby5oZWlnaHQsXG4gICAgICAgICAgXCJ3aWR0aFwiOiBkYXRhLmhlYWRlckluZm8ud2lkdGgsXG4gICAgICAgICAgXCJudW1WYWxpZFBpeGVsXCI6IGRhdGEuaGVhZGVySW5mby5udW1WYWxpZFBpeGVsLFxuICAgICAgICAgIFwibWljcm9CbG9ja1NpemVcIjogZGF0YS5oZWFkZXJJbmZvLm1pY3JvQmxvY2tTaXplLFxuICAgICAgICAgIFwiYmxvYlNpemVcIjogZGF0YS5oZWFkZXJJbmZvLmJsb2JTaXplLFxuICAgICAgICAgIFwibWF4WkVycm9yXCI6IGRhdGEuaGVhZGVySW5mby5tYXhaRXJyb3IsXG4gICAgICAgICAgXCJwaXhlbFR5cGVcIjogTGVyYzJIZWxwZXJzLmdldFBpeGVsVHlwZShkYXRhLmhlYWRlckluZm8uaW1hZ2VUeXBlKSxcbiAgICAgICAgICBcImVvZk9mZnNldFwiOiBkYXRhLmVvZk9mZnNldCxcbiAgICAgICAgICBcIm1hc2tcIjogZGF0YS5tYXNrID8ge1xuICAgICAgICAgICAgXCJudW1CeXRlc1wiOiBkYXRhLm1hc2subnVtQnl0ZXNcbiAgICAgICAgICB9IDogbnVsbCxcbiAgICAgICAgICBcInBpeGVsc1wiOiB7XG4gICAgICAgICAgICBcIm51bUJsb2Nrc1hcIjogZGF0YS5waXhlbHMubnVtQmxvY2tzWCxcbiAgICAgICAgICAgIFwibnVtQmxvY2tzWVwiOiBkYXRhLnBpeGVscy5udW1CbG9ja3NZLFxuICAgICAgICAgICAgLy9cIm51bUJ5dGVzXCI6IGRhdGEucGl4ZWxzLm51bUJ5dGVzLFxuICAgICAgICAgICAgXCJtYXhWYWx1ZVwiOiBkYXRhLmhlYWRlckluZm8uek1heCxcbiAgICAgICAgICAgIFwibWluVmFsdWVcIjogZGF0YS5oZWFkZXJJbmZvLnpNaW4sXG4gICAgICAgICAgICBcIm5vRGF0YVZhbHVlXCI6IGRhdGEubm9EYXRhVmFsdWVcbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICB9LFxuXG4gICAgICBjb25zdHJ1Y3RDb25zdGFudFN1cmZhY2U6IGZ1bmN0aW9uKGRhdGEpIHtcbiAgICAgICAgdmFyIHZhbCA9IGRhdGEuaGVhZGVySW5mby56TWF4O1xuICAgICAgICB2YXIgbnVtRGltcyA9ICBkYXRhLmhlYWRlckluZm8ubnVtRGltcztcbiAgICAgICAgdmFyIG51bVBpeGVscyA9IGRhdGEuaGVhZGVySW5mby5oZWlnaHQgKiBkYXRhLmhlYWRlckluZm8ud2lkdGg7XG4gICAgICAgIHZhciBudW1QaXhlbEFsbERpbXMgPSBudW1QaXhlbHMgKiBudW1EaW1zO1xuICAgICAgICB2YXIgaT0wLCBrID0gMCwgblN0YXJ0PTA7XG4gICAgICAgIHZhciBtYXNrID0gZGF0YS5waXhlbHMucmVzdWx0TWFzaztcbiAgICAgICAgaWYgKG1hc2spIHtcbiAgICAgICAgICBpZiAobnVtRGltcyA+IDEpIHtcbiAgICAgICAgICAgIGZvciAoaT0wOyBpIDwgbnVtRGltczsgaSsrKSB7XG4gICAgICAgICAgICAgIG5TdGFydCA9IGkgKiBudW1QaXhlbHM7XG4gICAgICAgICAgICAgIGZvciAoayA9IDA7IGsgPCBudW1QaXhlbHM7IGsrKykge1xuICAgICAgICAgICAgICAgIGlmIChtYXNrW2tdKSB7XG4gICAgICAgICAgICAgICAgICBkYXRhLnBpeGVscy5yZXN1bHRQaXhlbHNbblN0YXJ0ICsga10gPSB2YWw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZm9yIChrID0gMDsgayA8IG51bVBpeGVsczsgaysrKSB7XG4gICAgICAgICAgICAgIGlmIChtYXNrW2tdKSB7XG4gICAgICAgICAgICAgICAgZGF0YS5waXhlbHMucmVzdWx0UGl4ZWxzW2tdID0gdmFsO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIGlmIChkYXRhLnBpeGVscy5yZXN1bHRQaXhlbHMuZmlsbCkge1xuICAgICAgICAgICAgZGF0YS5waXhlbHMucmVzdWx0UGl4ZWxzLmZpbGwodmFsKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBmb3IgKGsgPSAwOyBrIDwgbnVtUGl4ZWxBbGxEaW1zOyBrKyspIHtcbiAgICAgICAgICAgICAgZGF0YS5waXhlbHMucmVzdWx0UGl4ZWxzW2tdID0gdmFsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm47XG4gICAgICB9LFxuXG4gICAgICBnZXREYXRhVHlwZUFycmF5OiBmdW5jdGlvbih0KSB7XG4gICAgICAgIHZhciB0cDtcbiAgICAgICAgc3dpdGNoICh0KSB7XG4gICAgICAgICAgY2FzZSAwOiAvL2NoYXJcbiAgICAgICAgICAgIHRwID0gSW50OEFycmF5O1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAxOiAvL2J5dGVcbiAgICAgICAgICAgIHRwID0gVWludDhBcnJheTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgMjogLy9zaG9ydFxuICAgICAgICAgICAgdHAgPSBJbnQxNkFycmF5O1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAzOiAvL3VzaG9ydFxuICAgICAgICAgICAgdHAgPSBVaW50MTZBcnJheTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgIHRwID0gSW50MzJBcnJheTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgNTpcbiAgICAgICAgICAgIHRwID0gVWludDMyQXJyYXk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIDY6XG4gICAgICAgICAgICB0cCA9IEZsb2F0MzJBcnJheTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgNzpcbiAgICAgICAgICAgIHRwID0gRmxvYXQ2NEFycmF5O1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHRwID0gRmxvYXQzMkFycmF5O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cDtcbiAgICAgIH0sXG5cbiAgICAgIGdldFBpeGVsVHlwZTogZnVuY3Rpb24odCkge1xuICAgICAgICB2YXIgdHA7XG4gICAgICAgIHN3aXRjaCAodCkge1xuICAgICAgICAgIGNhc2UgMDogLy9jaGFyXG4gICAgICAgICAgICB0cCA9IFwiUzhcIjtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgMTogLy9ieXRlXG4gICAgICAgICAgICB0cCA9IFwiVThcIjtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgMjogLy9zaG9ydFxuICAgICAgICAgICAgdHAgPSBcIlMxNlwiO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAzOiAvL3VzaG9ydFxuICAgICAgICAgICAgdHAgPSBcIlUxNlwiO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgdHAgPSBcIlMzMlwiO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSA1OlxuICAgICAgICAgICAgdHAgPSBcIlUzMlwiO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSA2OlxuICAgICAgICAgICAgdHAgPSBcIkYzMlwiO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSA3OlxuICAgICAgICAgICAgdHAgPSBcIkY2NFwiOyAvL25vdCBzdXBwb3J0ZWRcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICB0cCA9IFwiRjMyXCI7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRwO1xuICAgICAgfSxcblxuICAgICAgaXNWYWxpZFBpeGVsVmFsdWU6IGZ1bmN0aW9uKHQsIHZhbCkge1xuICAgICAgICBpZiAodmFsID09IG51bGwpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGlzVmFsaWQ7XG4gICAgICAgIHN3aXRjaCAodCkge1xuICAgICAgICAgIGNhc2UgMDogLy9jaGFyXG4gICAgICAgICAgICBpc1ZhbGlkID0gdmFsID49IC0xMjggJiYgdmFsIDw9IDEyNztcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgMTogLy9ieXRlICAodW5zaWduZWQgY2hhcilcbiAgICAgICAgICAgIGlzVmFsaWQgPSB2YWwgPj0gMCAmJiB2YWwgPD0gMjU1O1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAyOiAvL3Nob3J0XG4gICAgICAgICAgICBpc1ZhbGlkID0gdmFsID49IC0zMjc2OCAmJiB2YWwgPD0gMzI3Njc7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIDM6IC8vdXNob3J0XG4gICAgICAgICAgICBpc1ZhbGlkID0gdmFsID49IDAgJiYgdmFsIDw9IDY1NTM2O1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSA0OiAvL2ludCAzMlxuICAgICAgICAgICAgaXNWYWxpZCA9IHZhbCA+PSAtMjE0NzQ4MzY0OCAmJiB2YWwgPD0gMjE0NzQ4MzY0NztcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgNTogLy91aW5pdCAzMlxuICAgICAgICAgICAgaXNWYWxpZCA9IHZhbCA+PSAwICYmIHZhbCA8PSA0Mjk0OTY3Mjk2O1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSA2OlxuICAgICAgICAgICAgaXNWYWxpZCA9IHZhbCA+PSAtMy40MDI3OTk5Mzg3OTAxNDg0ZSszOCAmJiB2YWwgPD0gMy40MDI3OTk5Mzg3OTAxNDg0ZSszODtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgNzpcbiAgICAgICAgICAgIGlzVmFsaWQgPSB2YWwgPj0gNWUtMzI0ICYmIHZhbCA8PSAxLjc5NzY5MzEzNDg2MjMxNTdlKzMwODtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICBpc1ZhbGlkID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGlzVmFsaWQ7XG4gICAgICB9LFxuXG4gICAgICBnZXREYXRhVHlwZVNpemU6IGZ1bmN0aW9uKHQpIHtcbiAgICAgICAgdmFyIHMgPSAwO1xuICAgICAgICBzd2l0Y2ggKHQpIHtcbiAgICAgICAgICBjYXNlIDA6IC8vdWJ5dGVcbiAgICAgICAgICBjYXNlIDE6IC8vYnl0ZVxuICAgICAgICAgICAgcyA9IDE7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIDI6IC8vc2hvcnRcbiAgICAgICAgICBjYXNlIDM6IC8vdXNob3J0XG4gICAgICAgICAgICBzID0gMjtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICBjYXNlIDU6XG4gICAgICAgICAgY2FzZSA2OlxuICAgICAgICAgICAgcyA9IDQ7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIDc6XG4gICAgICAgICAgICBzID0gODtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICBzID0gdDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcztcbiAgICAgIH0sXG5cbiAgICAgIGdldERhdGFUeXBlVXNlZDogZnVuY3Rpb24oZHQsIHRjKSB7XG4gICAgICAgIHZhciB0ID0gZHQ7XG4gICAgICAgIHN3aXRjaCAoZHQpIHtcbiAgICAgICAgICBjYXNlIDI6IC8vc2hvcnRcbiAgICAgICAgICBjYXNlIDQ6IC8vbG9uZ1xuICAgICAgICAgICAgdCA9IGR0IC0gdGM7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIDM6IC8vdXNob3J0XG4gICAgICAgICAgY2FzZSA1OiAvL3Vsb25nXG4gICAgICAgICAgICB0ID0gZHQgLSAyICogdGM7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIDY6IC8vZmxvYXRcbiAgICAgICAgICAgIGlmICgwID09PSB0Yykge1xuICAgICAgICAgICAgICB0ID0gZHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICgxID09PSB0Yykge1xuICAgICAgICAgICAgICB0ID0gMjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICB0ID0gMTsvL2J5dGVcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgNzogLy9kb3VibGVcbiAgICAgICAgICAgIGlmICgwID09PSB0Yykge1xuICAgICAgICAgICAgICB0ID0gZHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgdCA9IGR0IC0gMiAqIHRjICsgMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICB0ID0gZHQ7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdDtcbiAgICAgIH0sXG5cbiAgICAgIGdldE9uZVBpeGVsOiBmdW5jdGlvbihibG9jaywgYmxvY2tQdHIsIG9mZnNldFR5cGUsIHZpZXcpIHtcbiAgICAgICAgdmFyIHRlbXAgPSAwO1xuICAgICAgICBzd2l0Y2ggKG9mZnNldFR5cGUpIHtcbiAgICAgICAgICBjYXNlIDA6IC8vY2hhclxuICAgICAgICAgICAgdGVtcCA9IHZpZXcuZ2V0SW50OChibG9ja1B0cik7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIDE6IC8vYnl0ZVxuICAgICAgICAgICAgdGVtcCA9IHZpZXcuZ2V0VWludDgoYmxvY2tQdHIpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgdGVtcCA9IHZpZXcuZ2V0SW50MTYoYmxvY2tQdHIsIHRydWUpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgdGVtcCA9IHZpZXcuZ2V0VWludDE2KGJsb2NrUHRyLCB0cnVlKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgIHRlbXAgPSB2aWV3LmdldEludDMyKGJsb2NrUHRyLCB0cnVlKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgNTpcbiAgICAgICAgICAgIHRlbXAgPSB2aWV3LmdldFVJbnQzMihibG9ja1B0ciwgdHJ1ZSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIDY6XG4gICAgICAgICAgICB0ZW1wID0gdmlldy5nZXRGbG9hdDMyKGJsb2NrUHRyLCB0cnVlKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgNzpcbiAgICAgICAgICAgIC8vdGVtcCA9IHZpZXcuZ2V0RmxvYXQ2NChibG9ja1B0ciwgdHJ1ZSk7XG4gICAgICAgICAgICAvL2Jsb2NrUHRyICs9IDg7XG4gICAgICAgICAgICAvL2xlcmMyIGVuY29kaW5nIGRvZXNudCBoYW5kbGUgZmxvYXQgNjQsIGZvcmNlIHRvIGZsb2F0MzI/Pz9cbiAgICAgICAgICAgIHRlbXAgPSB2aWV3LmdldEZsb2F0NjQoYmxvY2tQdHIsIHRydWUpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHRocm93IChcInRoZSBkZWNvZGVyIGRvZXMgbm90IHVuZGVyc3RhbmQgdGhpcyBwaXhlbCB0eXBlXCIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0ZW1wO1xuICAgICAgfVxuICAgIH07XG5cbiAgICAvKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gICAgKnByaXZhdGUgY2xhc3MgZm9yIGEgdHJlZSBub2RlLiBIdWZmbWFuIGNvZGUgaXMgaW4gTGVyYzJIZWxwZXJzXG4gICAgKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbiAgICB2YXIgVHJlZU5vZGUgPSBmdW5jdGlvbih2YWwsIGxlZnQsIHJpZ2h0KSB7XG4gICAgICB0aGlzLnZhbCA9IHZhbDtcbiAgICAgIHRoaXMubGVmdCA9IGxlZnQ7XG4gICAgICB0aGlzLnJpZ2h0ID0gcmlnaHQ7XG4gICAgfTtcblxuICAgIHZhciBMZXJjMkRlY29kZSA9IHtcbiAgICAgIC8qXG4gICAgICAqICoqKioqKioqcmVtb3ZlZCBvcHRpb25zIGNvbXBhcmVkIHRvIExFUkMxLiBXZSBjYW4gYnJpbmcgc29tZSBvZiB0aGVtIGJhY2sgaWYgbmVlZGVkLlxuICAgICAgICogcmVtb3ZlZCBwaXhlbCB0eXBlLiBMRVJDMiBpcyB0eXBlZCBhbmQgZG9lc24ndCByZXF1aXJlIHVzZXIgdG8gZ2l2ZSBwaXhlbCB0eXBlXG4gICAgICAgKiBjaGFuZ2VkIGVuY29kZWRNYXNrRGF0YSB0byBtYXNrRGF0YS4gTEVSQzIgJ3MganMgdmVyc2lvbiBtYWtlIGl0IGZhc3RlciB0byB1c2UgbWFza0RhdGEgZGlyZWN0bHkuXG4gICAgICAgKiByZW1vdmVkIHJldHVybk1hc2suIG1hc2sgaXMgdXNlZCBieSBMRVJDMiBpbnRlcm5hbGx5IGFuZCBpcyBjb3N0IGZyZWUuIEluIGNhc2Ugb2YgdXNlciBpbnB1dCBtYXNrLCBpdCdzIHJldHVybmVkIGFzIHdlbGwgYW5kIGhhcyBuZWdsaWJsZSBjb3N0LlxuICAgICAgICogcmVtb3ZlZCBub2RhdGF2YWx1ZS4gQmVjYXVzZSBMRVJDMiBwaXhlbHMgYXJlIHR5cGVkLCBub2RhdGF2YWx1ZSB3aWxsIHNhY3JpZnkgYSB1c2VmdWwgdmFsdWUgZm9yIG1hbnkgdHlwZXMgKDhiaXQsIDE2Yml0KSBldGMsXG4gICAgICAgKiAgICAgICB1c2VyIGhhcyB0byBiZSBrbm93bGVkZ2FibGUgZW5vdWdoIGFib3V0IHJhc3RlciBhbmQgdGhlaXIgZGF0YSB0byBhdm9pZCB1c2FiaWxpdHkgaXNzdWVzLiBzbyBub2RhdGEgdmFsdWUgaXMgc2ltcGx5IHJlbW92ZWQgbm93LlxuICAgICAgICogICAgICAgV2UgY2FuIGFkZCBpdCBiYWNrIGxhdGVyIGlmIHRoZWlyJ3MgYSBjbGVhciByZXF1aXJlbWVudC5cbiAgICAgICAqIHJlbW92ZWQgZW5jb2RlZE1hc2suIFRoaXMgb3B0aW9uIHdhcyBub3QgaW1wbGVtZW50ZWQgaW4gTGVyY0RlY29kZS4gSXQgY2FuIGJlIGRvbmUgYWZ0ZXIgZGVjb2RpbmcgKGxlc3MgZWZmaWNpZW50KVxuICAgICAgICogcmVtb3ZlZCBjb21wdXRlVXNlZEJpdERlcHRocy5cbiAgICAgICAqXG4gICAgICAgKlxuICAgICAgICogcmVzcG9uc2UgY2hhbmdlcyBjb21wYXJlZCB0byBMRVJDMVxuICAgICAgICogMS4gZW5jb2RlZE1hc2tEYXRhIGlzIG5vdCBhdmFpbGFibGVcbiAgICAgICAqIDIuIG5vRGF0YVZhbHVlIGlzIG9wdGlvbmFsIChyZXR1cm5zIG9ubHkgaWYgdXNlcidzIG5vRGF0YVZhbHVlIGlzIHdpdGggaW4gdGhlIHZhbGlkIGRhdGEgdHlwZSByYW5nZSlcbiAgICAgICAqIDMuIG1hc2tEYXRhIGlzIGFsd2F5cyBhdmFpbGFibGVcbiAgICAgICovXG4gICAgICAvKioqKioqKioqKioqKioqKipcbiAgICAgICogIHB1YmxpYyBwcm9wZXJ0aWVzXG4gICAgICAqKioqKioqKioqKioqKioqKiovXG4gICAgICAvL0hVRkZNQU5fTFVUX0JJVFNfTUFYOiAxMiwgLy91c2UgMl4xMiBsdXQsIG5vdCBjb25maWd1cmFibGVcblxuICAgICAgLyoqKioqKioqKioqKioqKioqXG4gICAgICAqICBwdWJsaWMgbWV0aG9kc1xuICAgICAgKioqKioqKioqKioqKioqKiovXG5cbiAgICAgIC8qKlxuICAgICAgICogRGVjb2RlIGEgTEVSQzIgYnl0ZSBzdHJlYW0gYW5kIHJldHVybiBhbiBvYmplY3QgY29udGFpbmluZyB0aGUgcGl4ZWwgZGF0YSBhbmQgb3B0aW9uYWwgbWV0YWRhdGEuXG4gICAgICAgKlxuICAgICAgICogQHBhcmFtIHtBcnJheUJ1ZmZlcn0gaW5wdXQgVGhlIExFUkMgaW5wdXQgYnl0ZSBzdHJlYW1cbiAgICAgICAqIEBwYXJhbSB7b2JqZWN0fSBbb3B0aW9uc10gb3B0aW9ucyBEZWNvZGluZyBvcHRpb25zXG4gICAgICAgKiBAcGFyYW0ge251bWJlcn0gW29wdGlvbnMuaW5wdXRPZmZzZXRdIFRoZSBudW1iZXIgb2YgYnl0ZXMgdG8gc2tpcCBpbiB0aGUgaW5wdXQgYnl0ZSBzdHJlYW0uIEEgdmFsaWQgTEVSQyBmaWxlIGlzIGV4cGVjdGVkIGF0IHRoYXQgcG9zaXRpb25cbiAgICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMucmV0dXJuRmlsZUluZm9dIElmIHRydWUsIHRoZSByZXR1cm4gdmFsdWUgd2lsbCBoYXZlIGEgZmlsZUluZm8gcHJvcGVydHkgdGhhdCBjb250YWlucyBtZXRhZGF0YSBvYnRhaW5lZCBmcm9tIHRoZSBMRVJDIGhlYWRlcnMgYW5kIHRoZSBkZWNvZGluZyBwcm9jZXNzXG4gICAgICAgKi9cbiAgICAgIGRlY29kZTogZnVuY3Rpb24oLypieXRlIGFycmF5Ki8gaW5wdXQsIC8qb2JqZWN0Ki8gb3B0aW9ucykge1xuICAgICAgICAvL2N1cnJlbnRseSB0aGVyZSdzIGEgYnVnIGluIHRoZSBzcGFyc2UgYXJyYXksIHNvIHBsZWFzZSBkbyBub3Qgc2V0IHRvIGZhbHNlXG4gICAgICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgICAgICB2YXIgbm9EYXRhVmFsdWUgPSBvcHRpb25zLm5vRGF0YVZhbHVlO1xuXG4gICAgICAgIC8vaW5pdGlhbGl6ZVxuICAgICAgICB2YXIgaSA9IDAsIGRhdGEgPSB7fTtcbiAgICAgICAgZGF0YS5wdHIgPSBvcHRpb25zLmlucHV0T2Zmc2V0IHx8IDA7XG4gICAgICAgIGRhdGEucGl4ZWxzID0ge307XG5cbiAgICAgICAgLy8gRmlsZSBoZWFkZXJcbiAgICAgICAgaWYgKCFMZXJjMkhlbHBlcnMucmVhZEhlYWRlckluZm8oaW5wdXQsIGRhdGEpKSA7XG4gICAgICAgIHZhciBoZWFkZXJJbmZvID0gZGF0YS5oZWFkZXJJbmZvO1xuICAgICAgICB2YXIgZmlsZVZlcnNpb24gPSBoZWFkZXJJbmZvLmZpbGVWZXJzaW9uO1xuICAgICAgICB2YXIgT3V0UGl4ZWxUeXBlQXJyYXkgPSBMZXJjMkhlbHBlcnMuZ2V0RGF0YVR5cGVBcnJheShoZWFkZXJJbmZvLmltYWdlVHlwZSk7XG5cbiAgICAgICAgLy8gTWFzayBIZWFkZXJcbiAgICAgICAgTGVyYzJIZWxwZXJzLnJlYWRNYXNrKGlucHV0LCBkYXRhKTtcbiAgICAgICAgaWYgKGhlYWRlckluZm8ubnVtVmFsaWRQaXhlbCAhPT0gaGVhZGVySW5mby53aWR0aCAqIGhlYWRlckluZm8uaGVpZ2h0ICYmICFkYXRhLnBpeGVscy5yZXN1bHRNYXNrKSB7XG4gICAgICAgICAgZGF0YS5waXhlbHMucmVzdWx0TWFzayA9IG9wdGlvbnMubWFza0RhdGE7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgbnVtUGl4ZWxzID0gaGVhZGVySW5mby53aWR0aCAqIGhlYWRlckluZm8uaGVpZ2h0O1xuICAgICAgICBkYXRhLnBpeGVscy5yZXN1bHRQaXhlbHMgPSBuZXcgT3V0UGl4ZWxUeXBlQXJyYXkobnVtUGl4ZWxzICogaGVhZGVySW5mby5udW1EaW1zKTtcblxuICAgICAgICBkYXRhLmNvdW50ZXIgPSB7XG4gICAgICAgICAgb25lc3dlZXA6IDAsXG4gICAgICAgICAgdW5jb21wcmVzc2VkOiAwLFxuICAgICAgICAgIGx1dDogMCxcbiAgICAgICAgICBiaXRzdHVmZmVyOiAwLFxuICAgICAgICAgIGNvbnN0YW50OiAwLFxuICAgICAgICAgIGNvbnN0YW50b2Zmc2V0OiAwXG4gICAgICAgIH07XG4gICAgICAgIGlmIChoZWFkZXJJbmZvLm51bVZhbGlkUGl4ZWwgIT09IDApIHtcbiAgICAgICAgICAvL25vdCB0ZXN0ZWRcbiAgICAgICAgICBpZiAoaGVhZGVySW5mby56TWF4ID09PSBoZWFkZXJJbmZvLnpNaW4pIC8vY29uc3RhbnQgc3VyZmFjZVxuICAgICAgICAgIHtcbiAgICAgICAgICAgIExlcmMySGVscGVycy5jb25zdHJ1Y3RDb25zdGFudFN1cmZhY2UoZGF0YSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2UgaWYgKGZpbGVWZXJzaW9uID49IDQgJiYgTGVyYzJIZWxwZXJzLmNoZWNrTWluTWF4UmFuZ2VzKGlucHV0LCBkYXRhKSkge1xuICAgICAgICAgICAgTGVyYzJIZWxwZXJzLmNvbnN0cnVjdENvbnN0YW50U3VyZmFjZShkYXRhKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB2YXIgdmlldyA9IG5ldyBEYXRhVmlldyhpbnB1dCwgZGF0YS5wdHIsIDIpO1xuICAgICAgICAgICAgdmFyIGJSZWFkRGF0YU9uZVN3ZWVwID0gdmlldy5nZXRVaW50OCgwKTtcbiAgICAgICAgICAgIGRhdGEucHRyKys7XG4gICAgICAgICAgICBpZiAoYlJlYWREYXRhT25lU3dlZXApIHtcbiAgICAgICAgICAgICAgLy9jb25zb2xlLmRlYnVnKFwiT25lU3dlZXBcIik7XG4gICAgICAgICAgICAgIExlcmMySGVscGVycy5yZWFkRGF0YU9uZVN3ZWVwKGlucHV0LCBkYXRhLCBPdXRQaXhlbFR5cGVBcnJheSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgLy9sZXJjMi4xOiAvL2JpdHN0dWZmaW5nICsgbHV0XG4gICAgICAgICAgICAgIC8vbGVyYzIuMjogLy9iaXRzdHVmZmluZyArIGx1dCArIGh1ZmZtYW5cbiAgICAgICAgICAgICAgLy9sZXJjMi4zOiBuZXcgYml0c3R1ZmZlclxuICAgICAgICAgICAgICBpZiAoZmlsZVZlcnNpb24gPiAxICYmIGhlYWRlckluZm8uaW1hZ2VUeXBlIDw9IDEgJiYgTWF0aC5hYnMoaGVhZGVySW5mby5tYXhaRXJyb3IgLSAwLjUpIDwgMC4wMDAwMSkge1xuICAgICAgICAgICAgICAgIC8vdGhpcyBpcyAyLnggcGx1cyA4IGJpdCAodW5zaWduZWQgYW5kIHNpZ25lZCkgZGF0YSwgcG9zc2libGl0eSBvZiBIdWZmbWFuXG4gICAgICAgICAgICAgICAgdmFyIGZsYWdIdWZmbWFuID0gdmlldy5nZXRVaW50OCgxKTtcbiAgICAgICAgICAgICAgICBkYXRhLnB0cisrO1xuICAgICAgICAgICAgICAgIGRhdGEuZW5jb2RlTW9kZSA9IGZsYWdIdWZmbWFuO1xuICAgICAgICAgICAgICAgIGlmIChmbGFnSHVmZm1hbiA+IDIgfHwgKGZpbGVWZXJzaW9uIDwgNCAmJiBmbGFnSHVmZm1hbiA+IDEpKSB7XG4gICAgICAgICAgICAgICAgICB0aHJvdyBcIkludmFsaWQgSHVmZm1hbiBmbGFnIFwiICsgZmxhZ0h1ZmZtYW47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChmbGFnSHVmZm1hbikgey8vMSAtIGRlbHRhIEh1ZmZtYW4sIDIgLSBIdWZmbWFuXG4gICAgICAgICAgICAgICAgICAvL2NvbnNvbGUubG9nKFwiSHVmZm1hblwiKTtcbiAgICAgICAgICAgICAgICAgIExlcmMySGVscGVycy5yZWFkSHVmZm1hbihpbnB1dCwgZGF0YSwgT3V0UGl4ZWxUeXBlQXJyYXkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIC8vY29uc29sZS5sb2coXCJUaWxlc1wiKTtcbiAgICAgICAgICAgICAgICAgIExlcmMySGVscGVycy5yZWFkVGlsZXMoaW5wdXQsIGRhdGEsIE91dFBpeGVsVHlwZUFycmF5KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgZWxzZSB7IC8vbGVyYzIueCBub24tOCBiaXQgZGF0YVxuICAgICAgICAgICAgICAgIC8vY29uc29sZS5sb2coXCJUaWxlc1wiKTtcbiAgICAgICAgICAgICAgICBMZXJjMkhlbHBlcnMucmVhZFRpbGVzKGlucHV0LCBkYXRhLCBPdXRQaXhlbFR5cGVBcnJheSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBkYXRhLmVvZk9mZnNldCA9IGRhdGEucHRyO1xuICAgICAgICB2YXIgZGlmZjtcbiAgICAgICAgaWYgKG9wdGlvbnMuaW5wdXRPZmZzZXQpIHtcbiAgICAgICAgICBkaWZmID0gZGF0YS5oZWFkZXJJbmZvLmJsb2JTaXplICsgb3B0aW9ucy5pbnB1dE9mZnNldCAtIGRhdGEucHRyO1xuICAgICAgICAgIGlmIChNYXRoLmFicyhkaWZmKSA+PSAxKSB7XG4gICAgICAgICAgICAvL2NvbnNvbGUuZGVidWcoXCJpbmNvcnJlY3QgZW9mOiBkYXRhcHRyIFwiICsgZGF0YS5wdHIgKyBcIiBvZmZzZXQgXCIgKyBvcHRpb25zLmlucHV0T2Zmc2V0ICsgXCIgYmxvYnNpemUgXCIgKyBkYXRhLmhlYWRlckluZm8uYmxvYlNpemUgKyBcIiBkaWZmOiBcIiArIGRpZmYpO1xuICAgICAgICAgICAgZGF0YS5lb2ZPZmZzZXQgPSBvcHRpb25zLmlucHV0T2Zmc2V0ICsgZGF0YS5oZWFkZXJJbmZvLmJsb2JTaXplO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICBkaWZmID0gZGF0YS5oZWFkZXJJbmZvLmJsb2JTaXplIC0gZGF0YS5wdHI7XG4gICAgICAgICAgaWYgKE1hdGguYWJzKGRpZmYpID49IDEpIHtcbiAgICAgICAgICAgIC8vY29uc29sZS5kZWJ1ZyhcImluY29ycmVjdCBmaXJzdCBiYW5kIGVvZjogZGF0YXB0ciBcIiArIGRhdGEucHRyICsgXCIgYmxvYnNpemUgXCIgKyBkYXRhLmhlYWRlckluZm8uYmxvYlNpemUgKyBcIiBkaWZmOiBcIiArIGRpZmYpO1xuICAgICAgICAgICAgZGF0YS5lb2ZPZmZzZXQgPSBkYXRhLmhlYWRlckluZm8uYmxvYlNpemU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHJlc3VsdCA9IHtcbiAgICAgICAgICB3aWR0aDogaGVhZGVySW5mby53aWR0aCxcbiAgICAgICAgICBoZWlnaHQ6IGhlYWRlckluZm8uaGVpZ2h0LFxuICAgICAgICAgIHBpeGVsRGF0YTogZGF0YS5waXhlbHMucmVzdWx0UGl4ZWxzLFxuICAgICAgICAgIG1pblZhbHVlOiBoZWFkZXJJbmZvLnpNaW4sXG4gICAgICAgICAgbWF4VmFsdWU6IGhlYWRlckluZm8uek1heCxcbiAgICAgICAgICB2YWxpZFBpeGVsQ291bnQ6IGhlYWRlckluZm8ubnVtVmFsaWRQaXhlbCxcbiAgICAgICAgICBkaW1Db3VudDogaGVhZGVySW5mby5udW1EaW1zLFxuICAgICAgICAgIGRpbVN0YXRzOiB7XG4gICAgICAgICAgICBtaW5WYWx1ZXM6IGhlYWRlckluZm8ubWluVmFsdWVzLFxuICAgICAgICAgICAgbWF4VmFsdWVzOiBoZWFkZXJJbmZvLm1heFZhbHVlc1xuICAgICAgICAgIH0sXG4gICAgICAgICAgbWFza0RhdGE6IGRhdGEucGl4ZWxzLnJlc3VsdE1hc2tcbiAgICAgICAgICAvL25vRGF0YVZhbHVlOiBub0RhdGFWYWx1ZVxuICAgICAgICB9O1xuXG4gICAgICAgIC8vd2Ugc2hvdWxkIHJlbW92ZSB0aGlzIGlmIHRoZXJlJ3Mgbm8gZXhpc3RpbmcgY2xpZW50XG4gICAgICAgIC8vb3B0aW9uYWwgbm9EYXRhVmFsdWUgcHJvY2Vzc2luZywgaXQncyB1c2VyJ3MgcmVzcG9uc2libGl0eVxuICAgICAgICBpZiAoZGF0YS5waXhlbHMucmVzdWx0TWFzayAmJiBMZXJjMkhlbHBlcnMuaXNWYWxpZFBpeGVsVmFsdWUoaGVhZGVySW5mby5pbWFnZVR5cGUsIG5vRGF0YVZhbHVlKSkge1xuICAgICAgICAgIHZhciBtYXNrID0gZGF0YS5waXhlbHMucmVzdWx0TWFzaztcbiAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbnVtUGl4ZWxzOyBpKyspIHtcbiAgICAgICAgICAgIGlmICghbWFza1tpXSkge1xuICAgICAgICAgICAgICByZXN1bHQucGl4ZWxEYXRhW2ldID0gbm9EYXRhVmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHJlc3VsdC5ub0RhdGFWYWx1ZSA9IG5vRGF0YVZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIGRhdGEubm9EYXRhVmFsdWUgPSBub0RhdGFWYWx1ZTtcbiAgICAgICAgaWYgKG9wdGlvbnMucmV0dXJuRmlsZUluZm8pIHtcbiAgICAgICAgICByZXN1bHQuZmlsZUluZm8gPSBMZXJjMkhlbHBlcnMuZm9ybWF0RmlsZUluZm8oZGF0YSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH0sXG5cbiAgICAgIGdldEJhbmRDb3VudDogZnVuY3Rpb24oLypieXRlIGFycmF5Ki8gaW5wdXQpIHtcbiAgICAgICAgdmFyIGNvdW50ID0gMDtcbiAgICAgICAgdmFyIGkgPSAwO1xuICAgICAgICB2YXIgdGVtcCA9IHt9O1xuICAgICAgICB0ZW1wLnB0ciA9IDA7XG4gICAgICAgIHRlbXAucGl4ZWxzID0ge307XG4gICAgICAgIHdoaWxlIChpIDwgaW5wdXQuYnl0ZUxlbmd0aCAtIDU4KSB7XG4gICAgICAgICAgTGVyYzJIZWxwZXJzLnJlYWRIZWFkZXJJbmZvKGlucHV0LCB0ZW1wKTtcbiAgICAgICAgICBpICs9IHRlbXAuaGVhZGVySW5mby5ibG9iU2l6ZTtcbiAgICAgICAgICBjb3VudCsrO1xuICAgICAgICAgIHRlbXAucHRyID0gaTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY291bnQ7XG4gICAgICB9XG4gICAgfTtcblxuICAgIHJldHVybiBMZXJjMkRlY29kZTtcbiAgfSkoKTtcblxuICB2YXIgaXNQbGF0Zm9ybUxpdHRsZUVuZGlhbiA9IChmdW5jdGlvbigpIHtcbiAgICB2YXIgYSA9IG5ldyBBcnJheUJ1ZmZlcig0KTtcbiAgICB2YXIgYiA9IG5ldyBVaW50OEFycmF5KGEpO1xuICAgIHZhciBjID0gbmV3IFVpbnQzMkFycmF5KGEpO1xuICAgIGNbMF0gPSAxO1xuICAgIHJldHVybiBiWzBdID09PSAxO1xuICB9KSgpO1xuXG4gIHZhciBMZXJjID0ge1xuICAgIC8qKioqKioqKioqKip3cmFwcGVyKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbiAgICAvKipcbiAgICAgKiBBIHdyYXBwZXIgZm9yIGRlY29kaW5nIGJvdGggTEVSQzEgYW5kIExFUkMyIGJ5dGUgc3RyZWFtcyBjYXBhYmxlIG9mIGhhbmRsaW5nIG11bHRpYmFuZCBwaXhlbCBibG9ja3MgZm9yIHZhcmlvdXMgcGl4ZWwgdHlwZXMuXG4gICAgICpcbiAgICAgKiBAYWxpYXMgbW9kdWxlOkxlcmNcbiAgICAgKiBAcGFyYW0ge0FycmF5QnVmZmVyfSBpbnB1dCBUaGUgTEVSQyBpbnB1dCBieXRlIHN0cmVhbVxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBbb3B0aW9uc10gVGhlIGRlY29kaW5nIG9wdGlvbnMgYmVsb3cgYXJlIG9wdGlvbmFsLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0aW9ucy5pbnB1dE9mZnNldF0gVGhlIG51bWJlciBvZiBieXRlcyB0byBza2lwIGluIHRoZSBpbnB1dCBieXRlIHN0cmVhbS4gQSB2YWxpZCBMZXJjIGZpbGUgaXMgZXhwZWN0ZWQgYXQgdGhhdCBwb3NpdGlvbi5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMucGl4ZWxUeXBlXSAoTEVSQzEgb25seSkgRGVmYXVsdCB2YWx1ZSBpcyBGMzIuIFZhbGlkIHBpeGVsIHR5cGVzIGZvciBpbnB1dCBhcmUgVTgvUzgvUzE2L1UxNi9TMzIvVTMyL0YzMi5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW29wdGlvbnMubm9EYXRhVmFsdWVdIChMRVJDMSBvbmx5KS4gSXQgaXMgcmVjb21tZW5kZWQgdG8gdXNlIHRoZSByZXR1cm5lZCBtYXNrIGluc3RlYWQgb2Ygc2V0dGluZyB0aGlzIHZhbHVlLlxuICAgICAqIEByZXR1cm5zIHt7d2lkdGgsIGhlaWdodCwgcGl4ZWxzLCBwaXhlbFR5cGUsIG1hc2ssIHN0YXRpc3RpY3N9fVxuICAgICAgICogQHByb3BlcnR5IHtudW1iZXJ9IHdpZHRoIFdpZHRoIG9mIGRlY29kZWQgaW1hZ2UuXG4gICAgICAgKiBAcHJvcGVydHkge251bWJlcn0gaGVpZ2h0IEhlaWdodCBvZiBkZWNvZGVkIGltYWdlLlxuICAgICAgICogQHByb3BlcnR5IHthcnJheX0gcGl4ZWxzIFtiYW5kMSwgYmFuZDIsIOKApl0gRWFjaCBiYW5kIGlzIGEgdHlwZWQgYXJyYXkgb2Ygd2lkdGgqaGVpZ2h0LlxuICAgICAgICogQHByb3BlcnR5IHtzdHJpbmd9IHBpeGVsVHlwZSBUaGUgdHlwZSBvZiBwaXhlbHMgcmVwcmVzZW50ZWQgaW4gdGhlIG91dHB1dC5cbiAgICAgICAqIEBwcm9wZXJ0eSB7bWFza30gbWFzayBUeXBlZCBhcnJheSB3aXRoIGEgc2l6ZSBvZiB3aWR0aCpoZWlnaHQsIG9yIG51bGwgaWYgYWxsIHBpeGVscyBhcmUgdmFsaWQuXG4gICAgICAgKiBAcHJvcGVydHkge2FycmF5fSBzdGF0aXN0aWNzIFtzdGF0aXN0aWNzX2JhbmQxLCBzdGF0aXN0aWNzX2JhbmQyLCDigKZdIEVhY2ggZWxlbWVudCBpcyBhIHN0YXRpc3RpY3Mgb2JqZWN0IHJlcHJlc2VudGluZyBtaW4gYW5kIG1heCB2YWx1ZXNcbiAgICAqKi9cbiAgICBkZWNvZGU6IGZ1bmN0aW9uKGVuY29kZWREYXRhLCBvcHRpb25zKSB7XG4gICAgICBpZiAoIWlzUGxhdGZvcm1MaXR0bGVFbmRpYW4pIHtcbiAgICAgICAgdGhyb3cgXCJCaWcgZW5kaWFuIHN5c3RlbSBpcyBub3Qgc3VwcG9ydGVkLlwiO1xuICAgICAgfVxuICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgICB2YXIgaW5wdXRPZmZzZXQgPSBvcHRpb25zLmlucHV0T2Zmc2V0IHx8IDA7XG4gICAgICB2YXIgZmlsZUlkVmlldyA9IG5ldyBVaW50OEFycmF5KGVuY29kZWREYXRhLCBpbnB1dE9mZnNldCwgMTApO1xuICAgICAgdmFyIGZpbGVJZGVudGlmaWVyU3RyaW5nID0gU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShudWxsLCBmaWxlSWRWaWV3KTtcbiAgICAgIHZhciBsZXJjLCBtYWpvclZlcnNpb247XG4gICAgICBpZiAoZmlsZUlkZW50aWZpZXJTdHJpbmcudHJpbSgpID09PSBcIkNudFpJbWFnZVwiKSB7XG4gICAgICAgIGxlcmMgPSBMZXJjRGVjb2RlO1xuICAgICAgICBtYWpvclZlcnNpb24gPSAxO1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAoZmlsZUlkZW50aWZpZXJTdHJpbmcuc3Vic3RyaW5nKDAsIDUpID09PSBcIkxlcmMyXCIpIHtcbiAgICAgICAgbGVyYyA9IExlcmMyRGVjb2RlO1xuICAgICAgICBtYWpvclZlcnNpb24gPSAyO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIHRocm93IFwiVW5leHBlY3RlZCBmaWxlIGlkZW50aWZpZXIgc3RyaW5nOiBcIiArIGZpbGVJZGVudGlmaWVyU3RyaW5nO1xuICAgICAgfVxuXG4gICAgICB2YXIgaVBsYW5lID0gMCwgZW9mID0gZW5jb2RlZERhdGEuYnl0ZUxlbmd0aCAtIDEwLCBlbmNvZGVkTWFza0RhdGEsIGJhbmRNYXNrcyA9IFtdLCBiYW5kTWFzaywgbWFza0RhdGE7XG4gICAgICB2YXIgZGVjb2RlZFBpeGVsQmxvY2sgPSB7XG4gICAgICAgIHdpZHRoOiAwLFxuICAgICAgICBoZWlnaHQ6IDAsXG4gICAgICAgIHBpeGVsczogW10sXG4gICAgICAgIHBpeGVsVHlwZTogb3B0aW9ucy5waXhlbFR5cGUsXG4gICAgICAgIG1hc2s6IG51bGwsXG4gICAgICAgIHN0YXRpc3RpY3M6IFtdXG4gICAgICB9O1xuXG4gICAgICB3aGlsZSAoaW5wdXRPZmZzZXQgPCBlb2YpIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IGxlcmMuZGVjb2RlKGVuY29kZWREYXRhLCB7XG4gICAgICAgICAgaW5wdXRPZmZzZXQ6IGlucHV0T2Zmc2V0LC8vZm9yIGJvdGggbGVyYzEgYW5kIGxlcmMyXG4gICAgICAgICAgZW5jb2RlZE1hc2tEYXRhOiBlbmNvZGVkTWFza0RhdGEsLy9sZXJjMSBvbmx5XG4gICAgICAgICAgbWFza0RhdGE6IG1hc2tEYXRhLC8vbGVyYzIgb25seVxuICAgICAgICAgIHJldHVybk1hc2s6IGlQbGFuZSA9PT0gMCA/IHRydWUgOiBmYWxzZSwvL2xlcmMxIG9ubHlcbiAgICAgICAgICByZXR1cm5FbmNvZGVkTWFzazogaVBsYW5lID09PSAwID8gdHJ1ZSA6IGZhbHNlLC8vbGVyYzEgb25seVxuICAgICAgICAgIHJldHVybkZpbGVJbmZvOiB0cnVlLC8vZm9yIGJvdGggbGVyYzEgYW5kIGxlcmMyXG4gICAgICAgICAgcGl4ZWxUeXBlOiBvcHRpb25zLnBpeGVsVHlwZSB8fCBudWxsLC8vbGVyYzEgb25seVxuICAgICAgICAgIG5vRGF0YVZhbHVlOiBvcHRpb25zLm5vRGF0YVZhbHVlIHx8IG51bGwvL2xlcmMxIG9ubHlcbiAgICAgICAgfSk7XG5cbiAgICAgICAgaW5wdXRPZmZzZXQgPSByZXN1bHQuZmlsZUluZm8uZW9mT2Zmc2V0O1xuICAgICAgICBpZiAoaVBsYW5lID09PSAwKSB7XG4gICAgICAgICAgZW5jb2RlZE1hc2tEYXRhID0gcmVzdWx0LmVuY29kZWRNYXNrRGF0YTsvL2xlcmMxXG4gICAgICAgICAgbWFza0RhdGEgPSByZXN1bHQubWFza0RhdGE7Ly9sZXJjMlxuICAgICAgICAgIGRlY29kZWRQaXhlbEJsb2NrLndpZHRoID0gcmVzdWx0LndpZHRoO1xuICAgICAgICAgIGRlY29kZWRQaXhlbEJsb2NrLmhlaWdodCA9IHJlc3VsdC5oZWlnaHQ7XG4gICAgICAgICAgZGVjb2RlZFBpeGVsQmxvY2suZGltQ291bnQgPSByZXN1bHQuZGltQ291bnQgfHwgMTtcbiAgICAgICAgICAvL2RlY29kZWRQaXhlbEJsb2NrLmRpbVN0YXRzID0gZGVjb2RlZFBpeGVsQmxvY2suZGltU3RhdHM7XG4gICAgICAgICAgZGVjb2RlZFBpeGVsQmxvY2sucGl4ZWxUeXBlID0gcmVzdWx0LnBpeGVsVHlwZSB8fCByZXN1bHQuZmlsZUluZm8ucGl4ZWxUeXBlO1xuICAgICAgICAgIGRlY29kZWRQaXhlbEJsb2NrLm1hc2sgPSByZXN1bHQubWFza0RhdGE7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1ham9yVmVyc2lvbiA+MSAmJiByZXN1bHQuZmlsZUluZm8ubWFzayAmJiByZXN1bHQuZmlsZUluZm8ubWFzay5udW1CeXRlcyA+IDApIHtcbiAgICAgICAgICBiYW5kTWFza3MucHVzaChyZXN1bHQubWFza0RhdGEpO1xuICAgICAgICB9XG5cbiAgICAgICAgaVBsYW5lKys7XG4gICAgICAgIGRlY29kZWRQaXhlbEJsb2NrLnBpeGVscy5wdXNoKHJlc3VsdC5waXhlbERhdGEpO1xuICAgICAgICBkZWNvZGVkUGl4ZWxCbG9jay5zdGF0aXN0aWNzLnB1c2goe1xuICAgICAgICAgIG1pblZhbHVlOiByZXN1bHQubWluVmFsdWUsXG4gICAgICAgICAgbWF4VmFsdWU6IHJlc3VsdC5tYXhWYWx1ZSxcbiAgICAgICAgICBub0RhdGFWYWx1ZTogcmVzdWx0Lm5vRGF0YVZhbHVlLFxuICAgICAgICAgIGRpbVN0YXRzOiByZXN1bHQuZGltU3RhdHNcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICB2YXIgaSwgaiwgbnVtUGl4ZWxzO1xuICAgICAgaWYgKG1ham9yVmVyc2lvbiA+IDEgJiYgYmFuZE1hc2tzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgbnVtUGl4ZWxzID0gZGVjb2RlZFBpeGVsQmxvY2sud2lkdGggKiBkZWNvZGVkUGl4ZWxCbG9jay5oZWlnaHQ7XG4gICAgICAgIGRlY29kZWRQaXhlbEJsb2NrLmJhbmRNYXNrcyA9IGJhbmRNYXNrcztcbiAgICAgICAgbWFza0RhdGEgPSBuZXcgVWludDhBcnJheShudW1QaXhlbHMpO1xuICAgICAgICBtYXNrRGF0YS5zZXQoYmFuZE1hc2tzWzBdKTtcbiAgICAgICAgZm9yIChpID0gMTsgaSA8IGJhbmRNYXNrcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGJhbmRNYXNrID0gYmFuZE1hc2tzW2ldO1xuICAgICAgICAgIGZvciAoaiA9IDA7IGogPCBudW1QaXhlbHM7IGorKykge1xuICAgICAgICAgICAgbWFza0RhdGFbal0gPSBtYXNrRGF0YVtqXSAmIGJhbmRNYXNrW2pdO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBkZWNvZGVkUGl4ZWxCbG9jay5tYXNrRGF0YSA9IG1hc2tEYXRhO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gZGVjb2RlZFBpeGVsQmxvY2s7XG4gICAgfVxuICB9O1xuXG4gIGlmIChtb2R1bGUuZXhwb3J0cykgey8qIGpzaGludCBpZ25vcmU6bGluZSAqL1xuICAgIC8vY29tbW9uSlMgbW9kdWxlIDEuMC8xLjEvMS4xLjEgc3lzdGVtcywgc3VjaCBhcyBub2RlSlNcbiAgICAvL2h0dHA6Ly93aWtpLmNvbW1vbmpzLm9yZy93aWtpL01vZHVsZXNcbiAgICBtb2R1bGUuZXhwb3J0cyA9IExlcmM7LyoganNoaW50IGlnbm9yZTpsaW5lICovXG4gIH1cbiAgZWxzZSB7XG4gICAgLy9hc3NpZ24gdG8gdGhpcywgbW9zdCBsaWtlbHkgd2luZG93XG4gICAgdGhpcy5MZXJjID0gTGVyYztcbiAgfVxuXG59KSgpO1xufSk7XG5cbmV4cG9ydCB7IExlcmNEZWNvZGUgYXMgZGVmYXVsdCB9O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///40212\n')}}]);