"use strict";(self["webpackChunkvue3_webpack5"]=self["webpackChunkvue3_webpack5"]||[]).push([[3105],{11491:function(__unused_webpack___webpack_module__,__webpack_exports__){eval('/**\n * ArcType defines the path that should be taken connecting vertices.\n *\n * @enum {Number}\n */\nvar ArcType = {\n  /**\n   * Straight line that does not conform to the surface of the ellipsoid.\n   *\n   * @type {Number}\n   * @constant\n   */\n  NONE: 0,\n\n  /**\n   * Follow geodesic path.\n   *\n   * @type {Number}\n   * @constant\n   */\n  GEODESIC: 1,\n\n  /**\n   * Follow rhumb or loxodrome path.\n   *\n   * @type {Number}\n   * @constant\n   */\n  RHUMB: 2,\n};\n/* harmony default export */ __webpack_exports__["Z"] = (Object.freeze(ArcType));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTE0OTEuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseURBQWUsc0JBQXNCLEVBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly92dWUzLXdlYnBhY2s1Ly4vbm9kZV9tb2R1bGVzL2Nlc2l1bS9Tb3VyY2UvQ29yZS9BcmNUeXBlLmpzPzdhYTciXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBBcmNUeXBlIGRlZmluZXMgdGhlIHBhdGggdGhhdCBzaG91bGQgYmUgdGFrZW4gY29ubmVjdGluZyB2ZXJ0aWNlcy5cbiAqXG4gKiBAZW51bSB7TnVtYmVyfVxuICovXG52YXIgQXJjVHlwZSA9IHtcbiAgLyoqXG4gICAqIFN0cmFpZ2h0IGxpbmUgdGhhdCBkb2VzIG5vdCBjb25mb3JtIHRvIHRoZSBzdXJmYWNlIG9mIHRoZSBlbGxpcHNvaWQuXG4gICAqXG4gICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAqIEBjb25zdGFudFxuICAgKi9cbiAgTk9ORTogMCxcblxuICAvKipcbiAgICogRm9sbG93IGdlb2Rlc2ljIHBhdGguXG4gICAqXG4gICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAqIEBjb25zdGFudFxuICAgKi9cbiAgR0VPREVTSUM6IDEsXG5cbiAgLyoqXG4gICAqIEZvbGxvdyByaHVtYiBvciBsb3hvZHJvbWUgcGF0aC5cbiAgICpcbiAgICogQHR5cGUge051bWJlcn1cbiAgICogQGNvbnN0YW50XG4gICAqL1xuICBSSFVNQjogMixcbn07XG5leHBvcnQgZGVmYXVsdCBPYmplY3QuZnJlZXplKEFyY1R5cGUpO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///11491\n')},8629:function(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__){eval('/* harmony import */ var _defined_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(82982);\n/* harmony import */ var _DeveloperError_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(12572);\n\n\n\n/**\n * A collection of key-value pairs that is stored as a hash for easy\n * lookup but also provides an array for fast iteration.\n * @alias AssociativeArray\n * @constructor\n */\nfunction AssociativeArray() {\n  this._array = [];\n  this._hash = {};\n}\n\nObject.defineProperties(AssociativeArray.prototype, {\n  /**\n   * Gets the number of items in the collection.\n   * @memberof AssociativeArray.prototype\n   *\n   * @type {Number}\n   */\n  length: {\n    get: function () {\n      return this._array.length;\n    },\n  },\n  /**\n   * Gets an unordered array of all values in the collection.\n   * This is a live array that will automatically reflect the values in the collection,\n   * it should not be modified directly.\n   * @memberof AssociativeArray.prototype\n   *\n   * @type {Array}\n   */\n  values: {\n    get: function () {\n      return this._array;\n    },\n  },\n});\n\n/**\n * Determines if the provided key is in the array.\n *\n * @param {String|Number} key The key to check.\n * @returns {Boolean} <code>true</code> if the key is in the array, <code>false</code> otherwise.\n */\nAssociativeArray.prototype.contains = function (key) {\n  //>>includeStart(\'debug\', pragmas.debug);\n  if (typeof key !== "string" && typeof key !== "number") {\n    throw new _DeveloperError_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .Z("key is required to be a string or number.");\n  }\n  //>>includeEnd(\'debug\');\n  return (0,_defined_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .Z)(this._hash[key]);\n};\n\n/**\n * Associates the provided key with the provided value.  If the key already\n * exists, it is overwritten with the new value.\n *\n * @param {String|Number} key A unique identifier.\n * @param {*} value The value to associate with the provided key.\n */\nAssociativeArray.prototype.set = function (key, value) {\n  //>>includeStart(\'debug\', pragmas.debug);\n  if (typeof key !== "string" && typeof key !== "number") {\n    throw new _DeveloperError_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .Z("key is required to be a string or number.");\n  }\n  //>>includeEnd(\'debug\');\n\n  var oldValue = this._hash[key];\n  if (value !== oldValue) {\n    this.remove(key);\n    this._hash[key] = value;\n    this._array.push(value);\n  }\n};\n\n/**\n * Retrieves the value associated with the provided key.\n *\n * @param {String|Number} key The key whose value is to be retrieved.\n * @returns {*} The associated value, or undefined if the key does not exist in the collection.\n */\nAssociativeArray.prototype.get = function (key) {\n  //>>includeStart(\'debug\', pragmas.debug);\n  if (typeof key !== "string" && typeof key !== "number") {\n    throw new _DeveloperError_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .Z("key is required to be a string or number.");\n  }\n  //>>includeEnd(\'debug\');\n  return this._hash[key];\n};\n\n/**\n * Removes a key-value pair from the collection.\n *\n * @param {String|Number} key The key to be removed.\n * @returns {Boolean} True if it was removed, false if the key was not in the collection.\n */\nAssociativeArray.prototype.remove = function (key) {\n  //>>includeStart(\'debug\', pragmas.debug);\n  if ((0,_defined_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .Z)(key) && typeof key !== "string" && typeof key !== "number") {\n    throw new _DeveloperError_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .Z("key is required to be a string or number.");\n  }\n  //>>includeEnd(\'debug\');\n\n  var value = this._hash[key];\n  var hasValue = (0,_defined_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .Z)(value);\n  if (hasValue) {\n    var array = this._array;\n    array.splice(array.indexOf(value), 1);\n    delete this._hash[key];\n  }\n  return hasValue;\n};\n\n/**\n * Clears the collection.\n */\nAssociativeArray.prototype.removeAll = function () {\n  var array = this._array;\n  if (array.length > 0) {\n    this._hash = {};\n    array.length = 0;\n  }\n};\n/* harmony default export */ __webpack_exports__["Z"] = (AssociativeArray);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiODYyOS5qcyIsIm1hcHBpbmdzIjoiOztBQUFtQztBQUNjOztBQUVqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNILENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0EsV0FBVyxlQUFlO0FBQzFCLGFBQWEsU0FBUztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsbUVBQWM7QUFDNUI7QUFDQTtBQUNBLFNBQVMsZ0VBQU87QUFDaEI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGVBQWU7QUFDMUIsV0FBVyxHQUFHO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLG1FQUFjO0FBQzVCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxlQUFlO0FBQzFCLGFBQWEsR0FBRztBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsbUVBQWM7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxlQUFlO0FBQzFCLGFBQWEsU0FBUztBQUN0QjtBQUNBO0FBQ0E7QUFDQSxNQUFNLGdFQUFPO0FBQ2IsY0FBYyxtRUFBYztBQUM1QjtBQUNBOztBQUVBO0FBQ0EsaUJBQWlCLGdFQUFPO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseURBQWUsZ0JBQWdCLEVBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly92dWUzLXdlYnBhY2s1Ly4vbm9kZV9tb2R1bGVzL2Nlc2l1bS9Tb3VyY2UvQ29yZS9Bc3NvY2lhdGl2ZUFycmF5LmpzPzA1OWQiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IGRlZmluZWQgZnJvbSBcIi4vZGVmaW5lZC5qc1wiO1xuaW1wb3J0IERldmVsb3BlckVycm9yIGZyb20gXCIuL0RldmVsb3BlckVycm9yLmpzXCI7XG5cbi8qKlxuICogQSBjb2xsZWN0aW9uIG9mIGtleS12YWx1ZSBwYWlycyB0aGF0IGlzIHN0b3JlZCBhcyBhIGhhc2ggZm9yIGVhc3lcbiAqIGxvb2t1cCBidXQgYWxzbyBwcm92aWRlcyBhbiBhcnJheSBmb3IgZmFzdCBpdGVyYXRpb24uXG4gKiBAYWxpYXMgQXNzb2NpYXRpdmVBcnJheVxuICogQGNvbnN0cnVjdG9yXG4gKi9cbmZ1bmN0aW9uIEFzc29jaWF0aXZlQXJyYXkoKSB7XG4gIHRoaXMuX2FycmF5ID0gW107XG4gIHRoaXMuX2hhc2ggPSB7fTtcbn1cblxuT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoQXNzb2NpYXRpdmVBcnJheS5wcm90b3R5cGUsIHtcbiAgLyoqXG4gICAqIEdldHMgdGhlIG51bWJlciBvZiBpdGVtcyBpbiB0aGUgY29sbGVjdGlvbi5cbiAgICogQG1lbWJlcm9mIEFzc29jaWF0aXZlQXJyYXkucHJvdG90eXBlXG4gICAqXG4gICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAqL1xuICBsZW5ndGg6IHtcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9hcnJheS5sZW5ndGg7XG4gICAgfSxcbiAgfSxcbiAgLyoqXG4gICAqIEdldHMgYW4gdW5vcmRlcmVkIGFycmF5IG9mIGFsbCB2YWx1ZXMgaW4gdGhlIGNvbGxlY3Rpb24uXG4gICAqIFRoaXMgaXMgYSBsaXZlIGFycmF5IHRoYXQgd2lsbCBhdXRvbWF0aWNhbGx5IHJlZmxlY3QgdGhlIHZhbHVlcyBpbiB0aGUgY29sbGVjdGlvbixcbiAgICogaXQgc2hvdWxkIG5vdCBiZSBtb2RpZmllZCBkaXJlY3RseS5cbiAgICogQG1lbWJlcm9mIEFzc29jaWF0aXZlQXJyYXkucHJvdG90eXBlXG4gICAqXG4gICAqIEB0eXBlIHtBcnJheX1cbiAgICovXG4gIHZhbHVlczoge1xuICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX2FycmF5O1xuICAgIH0sXG4gIH0sXG59KTtcblxuLyoqXG4gKiBEZXRlcm1pbmVzIGlmIHRoZSBwcm92aWRlZCBrZXkgaXMgaW4gdGhlIGFycmF5LlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfE51bWJlcn0ga2V5IFRoZSBrZXkgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Qm9vbGVhbn0gPGNvZGU+dHJ1ZTwvY29kZT4gaWYgdGhlIGtleSBpcyBpbiB0aGUgYXJyYXksIDxjb2RlPmZhbHNlPC9jb2RlPiBvdGhlcndpc2UuXG4gKi9cbkFzc29jaWF0aXZlQXJyYXkucHJvdG90eXBlLmNvbnRhaW5zID0gZnVuY3Rpb24gKGtleSkge1xuICAvLz4+aW5jbHVkZVN0YXJ0KCdkZWJ1ZycsIHByYWdtYXMuZGVidWcpO1xuICBpZiAodHlwZW9mIGtleSAhPT0gXCJzdHJpbmdcIiAmJiB0eXBlb2Yga2V5ICE9PSBcIm51bWJlclwiKSB7XG4gICAgdGhyb3cgbmV3IERldmVsb3BlckVycm9yKFwia2V5IGlzIHJlcXVpcmVkIHRvIGJlIGEgc3RyaW5nIG9yIG51bWJlci5cIik7XG4gIH1cbiAgLy8+PmluY2x1ZGVFbmQoJ2RlYnVnJyk7XG4gIHJldHVybiBkZWZpbmVkKHRoaXMuX2hhc2hba2V5XSk7XG59O1xuXG4vKipcbiAqIEFzc29jaWF0ZXMgdGhlIHByb3ZpZGVkIGtleSB3aXRoIHRoZSBwcm92aWRlZCB2YWx1ZS4gIElmIHRoZSBrZXkgYWxyZWFkeVxuICogZXhpc3RzLCBpdCBpcyBvdmVyd3JpdHRlbiB3aXRoIHRoZSBuZXcgdmFsdWUuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd8TnVtYmVyfSBrZXkgQSB1bmlxdWUgaWRlbnRpZmllci5cbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGFzc29jaWF0ZSB3aXRoIHRoZSBwcm92aWRlZCBrZXkuXG4gKi9cbkFzc29jaWF0aXZlQXJyYXkucHJvdG90eXBlLnNldCA9IGZ1bmN0aW9uIChrZXksIHZhbHVlKSB7XG4gIC8vPj5pbmNsdWRlU3RhcnQoJ2RlYnVnJywgcHJhZ21hcy5kZWJ1Zyk7XG4gIGlmICh0eXBlb2Yga2V5ICE9PSBcInN0cmluZ1wiICYmIHR5cGVvZiBrZXkgIT09IFwibnVtYmVyXCIpIHtcbiAgICB0aHJvdyBuZXcgRGV2ZWxvcGVyRXJyb3IoXCJrZXkgaXMgcmVxdWlyZWQgdG8gYmUgYSBzdHJpbmcgb3IgbnVtYmVyLlwiKTtcbiAgfVxuICAvLz4+aW5jbHVkZUVuZCgnZGVidWcnKTtcblxuICB2YXIgb2xkVmFsdWUgPSB0aGlzLl9oYXNoW2tleV07XG4gIGlmICh2YWx1ZSAhPT0gb2xkVmFsdWUpIHtcbiAgICB0aGlzLnJlbW92ZShrZXkpO1xuICAgIHRoaXMuX2hhc2hba2V5XSA9IHZhbHVlO1xuICAgIHRoaXMuX2FycmF5LnB1c2godmFsdWUpO1xuICB9XG59O1xuXG4vKipcbiAqIFJldHJpZXZlcyB0aGUgdmFsdWUgYXNzb2NpYXRlZCB3aXRoIHRoZSBwcm92aWRlZCBrZXkuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd8TnVtYmVyfSBrZXkgVGhlIGtleSB3aG9zZSB2YWx1ZSBpcyB0byBiZSByZXRyaWV2ZWQuXG4gKiBAcmV0dXJucyB7Kn0gVGhlIGFzc29jaWF0ZWQgdmFsdWUsIG9yIHVuZGVmaW5lZCBpZiB0aGUga2V5IGRvZXMgbm90IGV4aXN0IGluIHRoZSBjb2xsZWN0aW9uLlxuICovXG5Bc3NvY2lhdGl2ZUFycmF5LnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiAoa2V5KSB7XG4gIC8vPj5pbmNsdWRlU3RhcnQoJ2RlYnVnJywgcHJhZ21hcy5kZWJ1Zyk7XG4gIGlmICh0eXBlb2Yga2V5ICE9PSBcInN0cmluZ1wiICYmIHR5cGVvZiBrZXkgIT09IFwibnVtYmVyXCIpIHtcbiAgICB0aHJvdyBuZXcgRGV2ZWxvcGVyRXJyb3IoXCJrZXkgaXMgcmVxdWlyZWQgdG8gYmUgYSBzdHJpbmcgb3IgbnVtYmVyLlwiKTtcbiAgfVxuICAvLz4+aW5jbHVkZUVuZCgnZGVidWcnKTtcbiAgcmV0dXJuIHRoaXMuX2hhc2hba2V5XTtcbn07XG5cbi8qKlxuICogUmVtb3ZlcyBhIGtleS12YWx1ZSBwYWlyIGZyb20gdGhlIGNvbGxlY3Rpb24uXG4gKlxuICogQHBhcmFtIHtTdHJpbmd8TnVtYmVyfSBrZXkgVGhlIGtleSB0byBiZSByZW1vdmVkLlxuICogQHJldHVybnMge0Jvb2xlYW59IFRydWUgaWYgaXQgd2FzIHJlbW92ZWQsIGZhbHNlIGlmIHRoZSBrZXkgd2FzIG5vdCBpbiB0aGUgY29sbGVjdGlvbi5cbiAqL1xuQXNzb2NpYXRpdmVBcnJheS5wcm90b3R5cGUucmVtb3ZlID0gZnVuY3Rpb24gKGtleSkge1xuICAvLz4+aW5jbHVkZVN0YXJ0KCdkZWJ1ZycsIHByYWdtYXMuZGVidWcpO1xuICBpZiAoZGVmaW5lZChrZXkpICYmIHR5cGVvZiBrZXkgIT09IFwic3RyaW5nXCIgJiYgdHlwZW9mIGtleSAhPT0gXCJudW1iZXJcIikge1xuICAgIHRocm93IG5ldyBEZXZlbG9wZXJFcnJvcihcImtleSBpcyByZXF1aXJlZCB0byBiZSBhIHN0cmluZyBvciBudW1iZXIuXCIpO1xuICB9XG4gIC8vPj5pbmNsdWRlRW5kKCdkZWJ1ZycpO1xuXG4gIHZhciB2YWx1ZSA9IHRoaXMuX2hhc2hba2V5XTtcbiAgdmFyIGhhc1ZhbHVlID0gZGVmaW5lZCh2YWx1ZSk7XG4gIGlmIChoYXNWYWx1ZSkge1xuICAgIHZhciBhcnJheSA9IHRoaXMuX2FycmF5O1xuICAgIGFycmF5LnNwbGljZShhcnJheS5pbmRleE9mKHZhbHVlKSwgMSk7XG4gICAgZGVsZXRlIHRoaXMuX2hhc2hba2V5XTtcbiAgfVxuICByZXR1cm4gaGFzVmFsdWU7XG59O1xuXG4vKipcbiAqIENsZWFycyB0aGUgY29sbGVjdGlvbi5cbiAqL1xuQXNzb2NpYXRpdmVBcnJheS5wcm90b3R5cGUucmVtb3ZlQWxsID0gZnVuY3Rpb24gKCkge1xuICB2YXIgYXJyYXkgPSB0aGlzLl9hcnJheTtcbiAgaWYgKGFycmF5Lmxlbmd0aCA+IDApIHtcbiAgICB0aGlzLl9oYXNoID0ge307XG4gICAgYXJyYXkubGVuZ3RoID0gMDtcbiAgfVxufTtcbmV4cG9ydCBkZWZhdWx0IEFzc29jaWF0aXZlQXJyYXk7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///8629\n')},52323:function(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__){eval('/* harmony import */ var _Cartesian2_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(60838);\n/* harmony import */ var _Cartesian3_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(60216);\n/* harmony import */ var _ComponentDatatype_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(84828);\n/* harmony import */ var _Check_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(66553);\n/* harmony import */ var _defined_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(82982);\n/* harmony import */ var _DeveloperError_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(12572);\n/* harmony import */ var _Math_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(99417);\n/* harmony import */ var _Scene_AttributeType_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(77072);\n\n\n\n\n\n\n\n\n\nvar RIGHT_SHIFT = 1.0 / 256.0;\nvar LEFT_SHIFT = 256.0;\n\n/**\n * Attribute compression and decompression functions.\n *\n * @namespace AttributeCompression\n *\n * @private\n */\nvar AttributeCompression = {};\n\n/**\n * Encodes a normalized vector into 2 SNORM values in the range of [0-rangeMax] following the \'oct\' encoding.\n *\n * Oct encoding is a compact representation of unit length vectors.\n * The \'oct\' encoding is described in "A Survey of Efficient Representations of Independent Unit Vectors",\n * Cigolle et al 2014: {@link http://jcgt.org/published/0003/02/01/}\n *\n * @param {Cartesian3} vector The normalized vector to be compressed into 2 component \'oct\' encoding.\n * @param {Cartesian2} result The 2 component oct-encoded unit length vector.\n * @param {Number} rangeMax The maximum value of the SNORM range. The encoded vector is stored in log2(rangeMax+1) bits.\n * @returns {Cartesian2} The 2 component oct-encoded unit length vector.\n *\n * @exception {DeveloperError} vector must be normalized.\n *\n * @see AttributeCompression.octDecodeInRange\n */\nAttributeCompression.octEncodeInRange = function (vector, rangeMax, result) {\n  //>>includeStart(\'debug\', pragmas.debug);\n  _Check_js__WEBPACK_IMPORTED_MODULE_3__/* ["default"].defined */ .Z.defined("vector", vector);\n  _Check_js__WEBPACK_IMPORTED_MODULE_3__/* ["default"].defined */ .Z.defined("result", result);\n  var magSquared = _Cartesian3_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"].magnitudeSquared */ .Z.magnitudeSquared(vector);\n  if (Math.abs(magSquared - 1.0) > _Math_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"].EPSILON6 */ .Z.EPSILON6) {\n    throw new _DeveloperError_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .Z("vector must be normalized.");\n  }\n  //>>includeEnd(\'debug\');\n\n  result.x =\n    vector.x / (Math.abs(vector.x) + Math.abs(vector.y) + Math.abs(vector.z));\n  result.y =\n    vector.y / (Math.abs(vector.x) + Math.abs(vector.y) + Math.abs(vector.z));\n  if (vector.z < 0) {\n    var x = result.x;\n    var y = result.y;\n    result.x = (1.0 - Math.abs(y)) * _Math_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"].signNotZero */ .Z.signNotZero(x);\n    result.y = (1.0 - Math.abs(x)) * _Math_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"].signNotZero */ .Z.signNotZero(y);\n  }\n\n  result.x = _Math_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"].toSNorm */ .Z.toSNorm(result.x, rangeMax);\n  result.y = _Math_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"].toSNorm */ .Z.toSNorm(result.y, rangeMax);\n\n  return result;\n};\n\n/**\n * Encodes a normalized vector into 2 SNORM values in the range of [0-255] following the \'oct\' encoding.\n *\n * @param {Cartesian3} vector The normalized vector to be compressed into 2 byte \'oct\' encoding.\n * @param {Cartesian2} result The 2 byte oct-encoded unit length vector.\n * @returns {Cartesian2} The 2 byte oct-encoded unit length vector.\n *\n * @exception {DeveloperError} vector must be normalized.\n *\n * @see AttributeCompression.octEncodeInRange\n * @see AttributeCompression.octDecode\n */\nAttributeCompression.octEncode = function (vector, result) {\n  return AttributeCompression.octEncodeInRange(vector, 255, result);\n};\n\nvar octEncodeScratch = new _Cartesian2_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .Z();\nvar uint8ForceArray = new Uint8Array(1);\nfunction forceUint8(value) {\n  uint8ForceArray[0] = value;\n  return uint8ForceArray[0];\n}\n/**\n * @param {Cartesian3} vector The normalized vector to be compressed into 4 byte \'oct\' encoding.\n * @param {Cartesian4} result The 4 byte oct-encoded unit length vector.\n * @returns {Cartesian4} The 4 byte oct-encoded unit length vector.\n *\n * @exception {DeveloperError} vector must be normalized.\n *\n * @see AttributeCompression.octEncodeInRange\n * @see AttributeCompression.octDecodeFromCartesian4\n */\nAttributeCompression.octEncodeToCartesian4 = function (vector, result) {\n  AttributeCompression.octEncodeInRange(vector, 65535, octEncodeScratch);\n  result.x = forceUint8(octEncodeScratch.x * RIGHT_SHIFT);\n  result.y = forceUint8(octEncodeScratch.x);\n  result.z = forceUint8(octEncodeScratch.y * RIGHT_SHIFT);\n  result.w = forceUint8(octEncodeScratch.y);\n  return result;\n};\n\n/**\n * Decodes a unit-length vector in \'oct\' encoding to a normalized 3-component vector.\n *\n * @param {Number} x The x component of the oct-encoded unit length vector.\n * @param {Number} y The y component of the oct-encoded unit length vector.\n * @param {Number} rangeMax The maximum value of the SNORM range. The encoded vector is stored in log2(rangeMax+1) bits.\n * @param {Cartesian3} result The decoded and normalized vector\n * @returns {Cartesian3} The decoded and normalized vector.\n *\n * @exception {DeveloperError} x and y must be unsigned normalized integers between 0 and rangeMax.\n *\n * @see AttributeCompression.octEncodeInRange\n */\nAttributeCompression.octDecodeInRange = function (x, y, rangeMax, result) {\n  //>>includeStart(\'debug\', pragmas.debug);\n  _Check_js__WEBPACK_IMPORTED_MODULE_3__/* ["default"].defined */ .Z.defined("result", result);\n  if (x < 0 || x > rangeMax || y < 0 || y > rangeMax) {\n    throw new _DeveloperError_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .Z(\n      "x and y must be unsigned normalized integers between 0 and " + rangeMax\n    );\n  }\n  //>>includeEnd(\'debug\');\n\n  result.x = _Math_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"].fromSNorm */ .Z.fromSNorm(x, rangeMax);\n  result.y = _Math_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"].fromSNorm */ .Z.fromSNorm(y, rangeMax);\n  result.z = 1.0 - (Math.abs(result.x) + Math.abs(result.y));\n\n  if (result.z < 0.0) {\n    var oldVX = result.x;\n    result.x = (1.0 - Math.abs(result.y)) * _Math_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"].signNotZero */ .Z.signNotZero(oldVX);\n    result.y = (1.0 - Math.abs(oldVX)) * _Math_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"].signNotZero */ .Z.signNotZero(result.y);\n  }\n\n  return _Cartesian3_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"].normalize */ .Z.normalize(result, result);\n};\n\n/**\n * Decodes a unit-length vector in 2 byte \'oct\' encoding to a normalized 3-component vector.\n *\n * @param {Number} x The x component of the oct-encoded unit length vector.\n * @param {Number} y The y component of the oct-encoded unit length vector.\n * @param {Cartesian3} result The decoded and normalized vector.\n * @returns {Cartesian3} The decoded and normalized vector.\n *\n * @exception {DeveloperError} x and y must be an unsigned normalized integer between 0 and 255.\n *\n * @see AttributeCompression.octDecodeInRange\n */\nAttributeCompression.octDecode = function (x, y, result) {\n  return AttributeCompression.octDecodeInRange(x, y, 255, result);\n};\n\n/**\n * Decodes a unit-length vector in 4 byte \'oct\' encoding to a normalized 3-component vector.\n *\n * @param {Cartesian4} encoded The oct-encoded unit length vector.\n * @param {Cartesian3} result The decoded and normalized vector.\n * @returns {Cartesian3} The decoded and normalized vector.\n *\n * @exception {DeveloperError} x, y, z, and w must be unsigned normalized integers between 0 and 255.\n *\n * @see AttributeCompression.octDecodeInRange\n * @see AttributeCompression.octEncodeToCartesian4\n */\nAttributeCompression.octDecodeFromCartesian4 = function (encoded, result) {\n  //>>includeStart(\'debug\', pragmas.debug);\n  _Check_js__WEBPACK_IMPORTED_MODULE_3__/* ["default"].typeOf.object */ .Z.typeOf.object("encoded", encoded);\n  _Check_js__WEBPACK_IMPORTED_MODULE_3__/* ["default"].typeOf.object */ .Z.typeOf.object("result", result);\n  //>>includeEnd(\'debug\');\n  var x = encoded.x;\n  var y = encoded.y;\n  var z = encoded.z;\n  var w = encoded.w;\n  //>>includeStart(\'debug\', pragmas.debug);\n  if (\n    x < 0 ||\n    x > 255 ||\n    y < 0 ||\n    y > 255 ||\n    z < 0 ||\n    z > 255 ||\n    w < 0 ||\n    w > 255\n  ) {\n    throw new _DeveloperError_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .Z(\n      "x, y, z, and w must be unsigned normalized integers between 0 and 255"\n    );\n  }\n  //>>includeEnd(\'debug\');\n\n  var xOct16 = x * LEFT_SHIFT + y;\n  var yOct16 = z * LEFT_SHIFT + w;\n  return AttributeCompression.octDecodeInRange(xOct16, yOct16, 65535, result);\n};\n\n/**\n * Packs an oct encoded vector into a single floating-point number.\n *\n * @param {Cartesian2} encoded The oct encoded vector.\n * @returns {Number} The oct encoded vector packed into a single float.\n *\n */\nAttributeCompression.octPackFloat = function (encoded) {\n  //>>includeStart(\'debug\', pragmas.debug);\n  _Check_js__WEBPACK_IMPORTED_MODULE_3__/* ["default"].defined */ .Z.defined("encoded", encoded);\n  //>>includeEnd(\'debug\');\n  return 256.0 * encoded.x + encoded.y;\n};\n\nvar scratchEncodeCart2 = new _Cartesian2_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .Z();\n\n/**\n * Encodes a normalized vector into 2 SNORM values in the range of [0-255] following the \'oct\' encoding and\n * stores those values in a single float-point number.\n *\n * @param {Cartesian3} vector The normalized vector to be compressed into 2 byte \'oct\' encoding.\n * @returns {Number} The 2 byte oct-encoded unit length vector.\n *\n * @exception {DeveloperError} vector must be normalized.\n */\nAttributeCompression.octEncodeFloat = function (vector) {\n  AttributeCompression.octEncode(vector, scratchEncodeCart2);\n  return AttributeCompression.octPackFloat(scratchEncodeCart2);\n};\n\n/**\n * Decodes a unit-length vector in \'oct\' encoding packed in a floating-point number to a normalized 3-component vector.\n *\n * @param {Number} value The oct-encoded unit length vector stored as a single floating-point number.\n * @param {Cartesian3} result The decoded and normalized vector\n * @returns {Cartesian3} The decoded and normalized vector.\n *\n */\nAttributeCompression.octDecodeFloat = function (value, result) {\n  //>>includeStart(\'debug\', pragmas.debug);\n  _Check_js__WEBPACK_IMPORTED_MODULE_3__/* ["default"].defined */ .Z.defined("value", value);\n  //>>includeEnd(\'debug\');\n\n  var temp = value / 256.0;\n  var x = Math.floor(temp);\n  var y = (temp - x) * 256.0;\n\n  return AttributeCompression.octDecode(x, y, result);\n};\n\n/**\n * Encodes three normalized vectors into 6 SNORM values in the range of [0-255] following the \'oct\' encoding and\n * packs those into two floating-point numbers.\n *\n * @param {Cartesian3} v1 A normalized vector to be compressed.\n * @param {Cartesian3} v2 A normalized vector to be compressed.\n * @param {Cartesian3} v3 A normalized vector to be compressed.\n * @param {Cartesian2} result The \'oct\' encoded vectors packed into two floating-point numbers.\n * @returns {Cartesian2} The \'oct\' encoded vectors packed into two floating-point numbers.\n *\n */\nAttributeCompression.octPack = function (v1, v2, v3, result) {\n  //>>includeStart(\'debug\', pragmas.debug);\n  _Check_js__WEBPACK_IMPORTED_MODULE_3__/* ["default"].defined */ .Z.defined("v1", v1);\n  _Check_js__WEBPACK_IMPORTED_MODULE_3__/* ["default"].defined */ .Z.defined("v2", v2);\n  _Check_js__WEBPACK_IMPORTED_MODULE_3__/* ["default"].defined */ .Z.defined("v3", v3);\n  _Check_js__WEBPACK_IMPORTED_MODULE_3__/* ["default"].defined */ .Z.defined("result", result);\n  //>>includeEnd(\'debug\');\n\n  var encoded1 = AttributeCompression.octEncodeFloat(v1);\n  var encoded2 = AttributeCompression.octEncodeFloat(v2);\n\n  var encoded3 = AttributeCompression.octEncode(v3, scratchEncodeCart2);\n  result.x = 65536.0 * encoded3.x + encoded1;\n  result.y = 65536.0 * encoded3.y + encoded2;\n  return result;\n};\n\n/**\n * Decodes three unit-length vectors in \'oct\' encoding packed into a floating-point number to a normalized 3-component vector.\n *\n * @param {Cartesian2} packed The three oct-encoded unit length vectors stored as two floating-point number.\n * @param {Cartesian3} v1 One decoded and normalized vector.\n * @param {Cartesian3} v2 One decoded and normalized vector.\n * @param {Cartesian3} v3 One decoded and normalized vector.\n */\nAttributeCompression.octUnpack = function (packed, v1, v2, v3) {\n  //>>includeStart(\'debug\', pragmas.debug);\n  _Check_js__WEBPACK_IMPORTED_MODULE_3__/* ["default"].defined */ .Z.defined("packed", packed);\n  _Check_js__WEBPACK_IMPORTED_MODULE_3__/* ["default"].defined */ .Z.defined("v1", v1);\n  _Check_js__WEBPACK_IMPORTED_MODULE_3__/* ["default"].defined */ .Z.defined("v2", v2);\n  _Check_js__WEBPACK_IMPORTED_MODULE_3__/* ["default"].defined */ .Z.defined("v3", v3);\n  //>>includeEnd(\'debug\');\n\n  var temp = packed.x / 65536.0;\n  var x = Math.floor(temp);\n  var encodedFloat1 = (temp - x) * 65536.0;\n\n  temp = packed.y / 65536.0;\n  var y = Math.floor(temp);\n  var encodedFloat2 = (temp - y) * 65536.0;\n\n  AttributeCompression.octDecodeFloat(encodedFloat1, v1);\n  AttributeCompression.octDecodeFloat(encodedFloat2, v2);\n  AttributeCompression.octDecode(x, y, v3);\n};\n\n/**\n * Pack texture coordinates into a single float. The texture coordinates will only preserve 12 bits of precision.\n *\n * @param {Cartesian2} textureCoordinates The texture coordinates to compress.  Both coordinates must be in the range 0.0-1.0.\n * @returns {Number} The packed texture coordinates.\n *\n */\nAttributeCompression.compressTextureCoordinates = function (\n  textureCoordinates\n) {\n  //>>includeStart(\'debug\', pragmas.debug);\n  _Check_js__WEBPACK_IMPORTED_MODULE_3__/* ["default"].defined */ .Z.defined("textureCoordinates", textureCoordinates);\n  //>>includeEnd(\'debug\');\n\n  // Move x and y to the range 0-4095;\n  var x = (textureCoordinates.x * 4095.0) | 0;\n  var y = (textureCoordinates.y * 4095.0) | 0;\n  return 4096.0 * x + y;\n};\n\n/**\n * Decompresses texture coordinates that were packed into a single float.\n *\n * @param {Number} compressed The compressed texture coordinates.\n * @param {Cartesian2} result The decompressed texture coordinates.\n * @returns {Cartesian2} The modified result parameter.\n *\n */\nAttributeCompression.decompressTextureCoordinates = function (\n  compressed,\n  result\n) {\n  //>>includeStart(\'debug\', pragmas.debug);\n  _Check_js__WEBPACK_IMPORTED_MODULE_3__/* ["default"].defined */ .Z.defined("compressed", compressed);\n  _Check_js__WEBPACK_IMPORTED_MODULE_3__/* ["default"].defined */ .Z.defined("result", result);\n  //>>includeEnd(\'debug\');\n\n  var temp = compressed / 4096.0;\n  var xZeroTo4095 = Math.floor(temp);\n  result.x = xZeroTo4095 / 4095.0;\n  result.y = (compressed - xZeroTo4095 * 4096) / 4095;\n  return result;\n};\n\nfunction zigZagDecode(value) {\n  return (value >> 1) ^ -(value & 1);\n}\n\n/**\n * Decodes delta and ZigZag encoded vertices. This modifies the buffers in place.\n *\n * @param {Uint16Array} uBuffer The buffer view of u values.\n * @param {Uint16Array} vBuffer The buffer view of v values.\n * @param {Uint16Array} [heightBuffer] The buffer view of height values.\n *\n * @see {@link https://github.com/CesiumGS/quantized-mesh|quantized-mesh-1.0 terrain format}\n */\nAttributeCompression.zigZagDeltaDecode = function (\n  uBuffer,\n  vBuffer,\n  heightBuffer\n) {\n  //>>includeStart(\'debug\', pragmas.debug);\n  _Check_js__WEBPACK_IMPORTED_MODULE_3__/* ["default"].defined */ .Z.defined("uBuffer", uBuffer);\n  _Check_js__WEBPACK_IMPORTED_MODULE_3__/* ["default"].defined */ .Z.defined("vBuffer", vBuffer);\n  _Check_js__WEBPACK_IMPORTED_MODULE_3__/* ["default"].typeOf.number.equals */ .Z.typeOf.number.equals(\n    "uBuffer.length",\n    "vBuffer.length",\n    uBuffer.length,\n    vBuffer.length\n  );\n  if ((0,_defined_js__WEBPACK_IMPORTED_MODULE_7__/* ["default"] */ .Z)(heightBuffer)) {\n    _Check_js__WEBPACK_IMPORTED_MODULE_3__/* ["default"].typeOf.number.equals */ .Z.typeOf.number.equals(\n      "uBuffer.length",\n      "heightBuffer.length",\n      uBuffer.length,\n      heightBuffer.length\n    );\n  }\n  //>>includeEnd(\'debug\');\n\n  var count = uBuffer.length;\n\n  var u = 0;\n  var v = 0;\n  var height = 0;\n\n  for (var i = 0; i < count; ++i) {\n    u += zigZagDecode(uBuffer[i]);\n    v += zigZagDecode(vBuffer[i]);\n\n    uBuffer[i] = u;\n    vBuffer[i] = v;\n\n    if ((0,_defined_js__WEBPACK_IMPORTED_MODULE_7__/* ["default"] */ .Z)(heightBuffer)) {\n      height += zigZagDecode(heightBuffer[i]);\n      heightBuffer[i] = height;\n    }\n  }\n};\n\n/**\n * Dequantizes a quantized typed array into a floating point typed array.\n *\n * @see {@link https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_mesh_quantization#encoding-quantized-data}\n *\n * @param {Int8Array|Uint8Array|Int16Array|Uint16Array|Int32Array|Uint32Array} typedArray The typed array for the quantized data.\n * @param {ComponentDatatype} componentDatatype The component datatype of the quantized data.\n * @param {AttributeType} type The attribute type of the quantized data.\n * @param {Number} count The number of attributes referenced in the dequantized array.\n *\n * @returns {Float32Array} The dequantized array.\n */\nAttributeCompression.dequantize = function (\n  typedArray,\n  componentDatatype,\n  type,\n  count\n) {\n  //>>includeStart(\'debug\', pragmas.debug);\n  _Check_js__WEBPACK_IMPORTED_MODULE_3__/* ["default"].defined */ .Z.defined("typedArray", typedArray);\n  _Check_js__WEBPACK_IMPORTED_MODULE_3__/* ["default"].defined */ .Z.defined("componentDatatype", componentDatatype);\n  _Check_js__WEBPACK_IMPORTED_MODULE_3__/* ["default"].defined */ .Z.defined("type", type);\n  _Check_js__WEBPACK_IMPORTED_MODULE_3__/* ["default"].defined */ .Z.defined("count", count);\n  //>>includeEnd(\'debug\');\n\n  var componentsPerAttribute = _Scene_AttributeType_js__WEBPACK_IMPORTED_MODULE_6__/* ["default"].getNumberOfComponents */ .Z.getNumberOfComponents(type);\n\n  var divisor;\n  switch (componentDatatype) {\n    case _ComponentDatatype_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"].BYTE */ .Z.BYTE:\n      divisor = 127.0;\n      break;\n    case _ComponentDatatype_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"].UNSIGNED_BYTE */ .Z.UNSIGNED_BYTE:\n      divisor = 255.0;\n      break;\n    case _ComponentDatatype_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"].SHORT */ .Z.SHORT:\n      divisor = 32767.0;\n      break;\n    case _ComponentDatatype_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"].UNSIGNED_SHORT */ .Z.UNSIGNED_SHORT:\n      divisor = 65535.0;\n      break;\n    case _ComponentDatatype_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"].INT */ .Z.INT:\n      divisor = 2147483647.0;\n      break;\n    case _ComponentDatatype_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"].UNSIGNED_INT */ .Z.UNSIGNED_INT:\n      divisor = 4294967295.0;\n      break;\n    //>>includeStart(\'debug\', pragmas.debug);\n    default:\n      throw new _DeveloperError_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .Z(\n        "Cannot dequantize component datatype: " + componentDatatype\n      );\n    //>>includeEnd(\'debug\');\n  }\n\n  var dequantizedTypedArray = new Float32Array(count * componentsPerAttribute);\n\n  for (var i = 0; i < count; i++) {\n    for (var j = 0; j < componentsPerAttribute; j++) {\n      var index = i * componentsPerAttribute + j;\n      dequantizedTypedArray[index] = Math.max(\n        typedArray[index] / divisor,\n        -1.0\n      );\n    }\n  }\n\n  return dequantizedTypedArray;\n};\n\n/* harmony default export */ __webpack_exports__["Z"] = (AttributeCompression);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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O0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSx5REFBZSxvQkFBb0IsRUFBQyIsInNvdXJjZXMiOlsid2VicGFjazovL3Z1ZTMtd2VicGFjazUvLi9ub2RlX21vZHVsZXMvY2VzaXVtL1NvdXJjZS9Db3JlL0F0dHJpYnV0ZUNvbXByZXNzaW9uLmpzP2UzZTciXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IENhcnRlc2lhbjIgZnJvbSBcIi4vQ2FydGVzaWFuMi5qc1wiO1xuaW1wb3J0IENhcnRlc2lhbjMgZnJvbSBcIi4vQ2FydGVzaWFuMy5qc1wiO1xuaW1wb3J0IENvbXBvbmVudERhdGF0eXBlIGZyb20gXCIuL0NvbXBvbmVudERhdGF0eXBlLmpzXCI7XG5pbXBvcnQgQ2hlY2sgZnJvbSBcIi4vQ2hlY2suanNcIjtcbmltcG9ydCBkZWZpbmVkIGZyb20gXCIuL2RlZmluZWQuanNcIjtcbmltcG9ydCBEZXZlbG9wZXJFcnJvciBmcm9tIFwiLi9EZXZlbG9wZXJFcnJvci5qc1wiO1xuaW1wb3J0IENlc2l1bU1hdGggZnJvbSBcIi4vTWF0aC5qc1wiO1xuaW1wb3J0IEF0dHJpYnV0ZVR5cGUgZnJvbSBcIi4uL1NjZW5lL0F0dHJpYnV0ZVR5cGUuanNcIjtcblxudmFyIFJJR0hUX1NISUZUID0gMS4wIC8gMjU2LjA7XG52YXIgTEVGVF9TSElGVCA9IDI1Ni4wO1xuXG4vKipcbiAqIEF0dHJpYnV0ZSBjb21wcmVzc2lvbiBhbmQgZGVjb21wcmVzc2lvbiBmdW5jdGlvbnMuXG4gKlxuICogQG5hbWVzcGFjZSBBdHRyaWJ1dGVDb21wcmVzc2lvblxuICpcbiAqIEBwcml2YXRlXG4gKi9cbnZhciBBdHRyaWJ1dGVDb21wcmVzc2lvbiA9IHt9O1xuXG4vKipcbiAqIEVuY29kZXMgYSBub3JtYWxpemVkIHZlY3RvciBpbnRvIDIgU05PUk0gdmFsdWVzIGluIHRoZSByYW5nZSBvZiBbMC1yYW5nZU1heF0gZm9sbG93aW5nIHRoZSAnb2N0JyBlbmNvZGluZy5cbiAqXG4gKiBPY3QgZW5jb2RpbmcgaXMgYSBjb21wYWN0IHJlcHJlc2VudGF0aW9uIG9mIHVuaXQgbGVuZ3RoIHZlY3RvcnMuXG4gKiBUaGUgJ29jdCcgZW5jb2RpbmcgaXMgZGVzY3JpYmVkIGluIFwiQSBTdXJ2ZXkgb2YgRWZmaWNpZW50IFJlcHJlc2VudGF0aW9ucyBvZiBJbmRlcGVuZGVudCBVbml0IFZlY3RvcnNcIixcbiAqIENpZ29sbGUgZXQgYWwgMjAxNDoge0BsaW5rIGh0dHA6Ly9qY2d0Lm9yZy9wdWJsaXNoZWQvMDAwMy8wMi8wMS99XG4gKlxuICogQHBhcmFtIHtDYXJ0ZXNpYW4zfSB2ZWN0b3IgVGhlIG5vcm1hbGl6ZWQgdmVjdG9yIHRvIGJlIGNvbXByZXNzZWQgaW50byAyIGNvbXBvbmVudCAnb2N0JyBlbmNvZGluZy5cbiAqIEBwYXJhbSB7Q2FydGVzaWFuMn0gcmVzdWx0IFRoZSAyIGNvbXBvbmVudCBvY3QtZW5jb2RlZCB1bml0IGxlbmd0aCB2ZWN0b3IuXG4gKiBAcGFyYW0ge051bWJlcn0gcmFuZ2VNYXggVGhlIG1heGltdW0gdmFsdWUgb2YgdGhlIFNOT1JNIHJhbmdlLiBUaGUgZW5jb2RlZCB2ZWN0b3IgaXMgc3RvcmVkIGluIGxvZzIocmFuZ2VNYXgrMSkgYml0cy5cbiAqIEByZXR1cm5zIHtDYXJ0ZXNpYW4yfSBUaGUgMiBjb21wb25lbnQgb2N0LWVuY29kZWQgdW5pdCBsZW5ndGggdmVjdG9yLlxuICpcbiAqIEBleGNlcHRpb24ge0RldmVsb3BlckVycm9yfSB2ZWN0b3IgbXVzdCBiZSBub3JtYWxpemVkLlxuICpcbiAqIEBzZWUgQXR0cmlidXRlQ29tcHJlc3Npb24ub2N0RGVjb2RlSW5SYW5nZVxuICovXG5BdHRyaWJ1dGVDb21wcmVzc2lvbi5vY3RFbmNvZGVJblJhbmdlID0gZnVuY3Rpb24gKHZlY3RvciwgcmFuZ2VNYXgsIHJlc3VsdCkge1xuICAvLz4+aW5jbHVkZVN0YXJ0KCdkZWJ1ZycsIHByYWdtYXMuZGVidWcpO1xuICBDaGVjay5kZWZpbmVkKFwidmVjdG9yXCIsIHZlY3Rvcik7XG4gIENoZWNrLmRlZmluZWQoXCJyZXN1bHRcIiwgcmVzdWx0KTtcbiAgdmFyIG1hZ1NxdWFyZWQgPSBDYXJ0ZXNpYW4zLm1hZ25pdHVkZVNxdWFyZWQodmVjdG9yKTtcbiAgaWYgKE1hdGguYWJzKG1hZ1NxdWFyZWQgLSAxLjApID4gQ2VzaXVtTWF0aC5FUFNJTE9ONikge1xuICAgIHRocm93IG5ldyBEZXZlbG9wZXJFcnJvcihcInZlY3RvciBtdXN0IGJlIG5vcm1hbGl6ZWQuXCIpO1xuICB9XG4gIC8vPj5pbmNsdWRlRW5kKCdkZWJ1ZycpO1xuXG4gIHJlc3VsdC54ID1cbiAgICB2ZWN0b3IueCAvIChNYXRoLmFicyh2ZWN0b3IueCkgKyBNYXRoLmFicyh2ZWN0b3IueSkgKyBNYXRoLmFicyh2ZWN0b3IueikpO1xuICByZXN1bHQueSA9XG4gICAgdmVjdG9yLnkgLyAoTWF0aC5hYnModmVjdG9yLngpICsgTWF0aC5hYnModmVjdG9yLnkpICsgTWF0aC5hYnModmVjdG9yLnopKTtcbiAgaWYgKHZlY3Rvci56IDwgMCkge1xuICAgIHZhciB4ID0gcmVzdWx0Lng7XG4gICAgdmFyIHkgPSByZXN1bHQueTtcbiAgICByZXN1bHQueCA9ICgxLjAgLSBNYXRoLmFicyh5KSkgKiBDZXNpdW1NYXRoLnNpZ25Ob3RaZXJvKHgpO1xuICAgIHJlc3VsdC55ID0gKDEuMCAtIE1hdGguYWJzKHgpKSAqIENlc2l1bU1hdGguc2lnbk5vdFplcm8oeSk7XG4gIH1cblxuICByZXN1bHQueCA9IENlc2l1bU1hdGgudG9TTm9ybShyZXN1bHQueCwgcmFuZ2VNYXgpO1xuICByZXN1bHQueSA9IENlc2l1bU1hdGgudG9TTm9ybShyZXN1bHQueSwgcmFuZ2VNYXgpO1xuXG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG4vKipcbiAqIEVuY29kZXMgYSBub3JtYWxpemVkIHZlY3RvciBpbnRvIDIgU05PUk0gdmFsdWVzIGluIHRoZSByYW5nZSBvZiBbMC0yNTVdIGZvbGxvd2luZyB0aGUgJ29jdCcgZW5jb2RpbmcuXG4gKlxuICogQHBhcmFtIHtDYXJ0ZXNpYW4zfSB2ZWN0b3IgVGhlIG5vcm1hbGl6ZWQgdmVjdG9yIHRvIGJlIGNvbXByZXNzZWQgaW50byAyIGJ5dGUgJ29jdCcgZW5jb2RpbmcuXG4gKiBAcGFyYW0ge0NhcnRlc2lhbjJ9IHJlc3VsdCBUaGUgMiBieXRlIG9jdC1lbmNvZGVkIHVuaXQgbGVuZ3RoIHZlY3Rvci5cbiAqIEByZXR1cm5zIHtDYXJ0ZXNpYW4yfSBUaGUgMiBieXRlIG9jdC1lbmNvZGVkIHVuaXQgbGVuZ3RoIHZlY3Rvci5cbiAqXG4gKiBAZXhjZXB0aW9uIHtEZXZlbG9wZXJFcnJvcn0gdmVjdG9yIG11c3QgYmUgbm9ybWFsaXplZC5cbiAqXG4gKiBAc2VlIEF0dHJpYnV0ZUNvbXByZXNzaW9uLm9jdEVuY29kZUluUmFuZ2VcbiAqIEBzZWUgQXR0cmlidXRlQ29tcHJlc3Npb24ub2N0RGVjb2RlXG4gKi9cbkF0dHJpYnV0ZUNvbXByZXNzaW9uLm9jdEVuY29kZSA9IGZ1bmN0aW9uICh2ZWN0b3IsIHJlc3VsdCkge1xuICByZXR1cm4gQXR0cmlidXRlQ29tcHJlc3Npb24ub2N0RW5jb2RlSW5SYW5nZSh2ZWN0b3IsIDI1NSwgcmVzdWx0KTtcbn07XG5cbnZhciBvY3RFbmNvZGVTY3JhdGNoID0gbmV3IENhcnRlc2lhbjIoKTtcbnZhciB1aW50OEZvcmNlQXJyYXkgPSBuZXcgVWludDhBcnJheSgxKTtcbmZ1bmN0aW9uIGZvcmNlVWludDgodmFsdWUpIHtcbiAgdWludDhGb3JjZUFycmF5WzBdID0gdmFsdWU7XG4gIHJldHVybiB1aW50OEZvcmNlQXJyYXlbMF07XG59XG4vKipcbiAqIEBwYXJhbSB7Q2FydGVzaWFuM30gdmVjdG9yIFRoZSBub3JtYWxpemVkIHZlY3RvciB0byBiZSBjb21wcmVzc2VkIGludG8gNCBieXRlICdvY3QnIGVuY29kaW5nLlxuICogQHBhcmFtIHtDYXJ0ZXNpYW40fSByZXN1bHQgVGhlIDQgYnl0ZSBvY3QtZW5jb2RlZCB1bml0IGxlbmd0aCB2ZWN0b3IuXG4gKiBAcmV0dXJucyB7Q2FydGVzaWFuNH0gVGhlIDQgYnl0ZSBvY3QtZW5jb2RlZCB1bml0IGxlbmd0aCB2ZWN0b3IuXG4gKlxuICogQGV4Y2VwdGlvbiB7RGV2ZWxvcGVyRXJyb3J9IHZlY3RvciBtdXN0IGJlIG5vcm1hbGl6ZWQuXG4gKlxuICogQHNlZSBBdHRyaWJ1dGVDb21wcmVzc2lvbi5vY3RFbmNvZGVJblJhbmdlXG4gKiBAc2VlIEF0dHJpYnV0ZUNvbXByZXNzaW9uLm9jdERlY29kZUZyb21DYXJ0ZXNpYW40XG4gKi9cbkF0dHJpYnV0ZUNvbXByZXNzaW9uLm9jdEVuY29kZVRvQ2FydGVzaWFuNCA9IGZ1bmN0aW9uICh2ZWN0b3IsIHJlc3VsdCkge1xuICBBdHRyaWJ1dGVDb21wcmVzc2lvbi5vY3RFbmNvZGVJblJhbmdlKHZlY3RvciwgNjU1MzUsIG9jdEVuY29kZVNjcmF0Y2gpO1xuICByZXN1bHQueCA9IGZvcmNlVWludDgob2N0RW5jb2RlU2NyYXRjaC54ICogUklHSFRfU0hJRlQpO1xuICByZXN1bHQueSA9IGZvcmNlVWludDgob2N0RW5jb2RlU2NyYXRjaC54KTtcbiAgcmVzdWx0LnogPSBmb3JjZVVpbnQ4KG9jdEVuY29kZVNjcmF0Y2gueSAqIFJJR0hUX1NISUZUKTtcbiAgcmVzdWx0LncgPSBmb3JjZVVpbnQ4KG9jdEVuY29kZVNjcmF0Y2gueSk7XG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG4vKipcbiAqIERlY29kZXMgYSB1bml0LWxlbmd0aCB2ZWN0b3IgaW4gJ29jdCcgZW5jb2RpbmcgdG8gYSBub3JtYWxpemVkIDMtY29tcG9uZW50IHZlY3Rvci5cbiAqXG4gKiBAcGFyYW0ge051bWJlcn0geCBUaGUgeCBjb21wb25lbnQgb2YgdGhlIG9jdC1lbmNvZGVkIHVuaXQgbGVuZ3RoIHZlY3Rvci5cbiAqIEBwYXJhbSB7TnVtYmVyfSB5IFRoZSB5IGNvbXBvbmVudCBvZiB0aGUgb2N0LWVuY29kZWQgdW5pdCBsZW5ndGggdmVjdG9yLlxuICogQHBhcmFtIHtOdW1iZXJ9IHJhbmdlTWF4IFRoZSBtYXhpbXVtIHZhbHVlIG9mIHRoZSBTTk9STSByYW5nZS4gVGhlIGVuY29kZWQgdmVjdG9yIGlzIHN0b3JlZCBpbiBsb2cyKHJhbmdlTWF4KzEpIGJpdHMuXG4gKiBAcGFyYW0ge0NhcnRlc2lhbjN9IHJlc3VsdCBUaGUgZGVjb2RlZCBhbmQgbm9ybWFsaXplZCB2ZWN0b3JcbiAqIEByZXR1cm5zIHtDYXJ0ZXNpYW4zfSBUaGUgZGVjb2RlZCBhbmQgbm9ybWFsaXplZCB2ZWN0b3IuXG4gKlxuICogQGV4Y2VwdGlvbiB7RGV2ZWxvcGVyRXJyb3J9IHggYW5kIHkgbXVzdCBiZSB1bnNpZ25lZCBub3JtYWxpemVkIGludGVnZXJzIGJldHdlZW4gMCBhbmQgcmFuZ2VNYXguXG4gKlxuICogQHNlZSBBdHRyaWJ1dGVDb21wcmVzc2lvbi5vY3RFbmNvZGVJblJhbmdlXG4gKi9cbkF0dHJpYnV0ZUNvbXByZXNzaW9uLm9jdERlY29kZUluUmFuZ2UgPSBmdW5jdGlvbiAoeCwgeSwgcmFuZ2VNYXgsIHJlc3VsdCkge1xuICAvLz4+aW5jbHVkZVN0YXJ0KCdkZWJ1ZycsIHByYWdtYXMuZGVidWcpO1xuICBDaGVjay5kZWZpbmVkKFwicmVzdWx0XCIsIHJlc3VsdCk7XG4gIGlmICh4IDwgMCB8fCB4ID4gcmFuZ2VNYXggfHwgeSA8IDAgfHwgeSA+IHJhbmdlTWF4KSB7XG4gICAgdGhyb3cgbmV3IERldmVsb3BlckVycm9yKFxuICAgICAgXCJ4IGFuZCB5IG11c3QgYmUgdW5zaWduZWQgbm9ybWFsaXplZCBpbnRlZ2VycyBiZXR3ZWVuIDAgYW5kIFwiICsgcmFuZ2VNYXhcbiAgICApO1xuICB9XG4gIC8vPj5pbmNsdWRlRW5kKCdkZWJ1ZycpO1xuXG4gIHJlc3VsdC54ID0gQ2VzaXVtTWF0aC5mcm9tU05vcm0oeCwgcmFuZ2VNYXgpO1xuICByZXN1bHQueSA9IENlc2l1bU1hdGguZnJvbVNOb3JtKHksIHJhbmdlTWF4KTtcbiAgcmVzdWx0LnogPSAxLjAgLSAoTWF0aC5hYnMocmVzdWx0LngpICsgTWF0aC5hYnMocmVzdWx0LnkpKTtcblxuICBpZiAocmVzdWx0LnogPCAwLjApIHtcbiAgICB2YXIgb2xkVlggPSByZXN1bHQueDtcbiAgICByZXN1bHQueCA9ICgxLjAgLSBNYXRoLmFicyhyZXN1bHQueSkpICogQ2VzaXVtTWF0aC5zaWduTm90WmVybyhvbGRWWCk7XG4gICAgcmVzdWx0LnkgPSAoMS4wIC0gTWF0aC5hYnMob2xkVlgpKSAqIENlc2l1bU1hdGguc2lnbk5vdFplcm8ocmVzdWx0LnkpO1xuICB9XG5cbiAgcmV0dXJuIENhcnRlc2lhbjMubm9ybWFsaXplKHJlc3VsdCwgcmVzdWx0KTtcbn07XG5cbi8qKlxuICogRGVjb2RlcyBhIHVuaXQtbGVuZ3RoIHZlY3RvciBpbiAyIGJ5dGUgJ29jdCcgZW5jb2RpbmcgdG8gYSBub3JtYWxpemVkIDMtY29tcG9uZW50IHZlY3Rvci5cbiAqXG4gKiBAcGFyYW0ge051bWJlcn0geCBUaGUgeCBjb21wb25lbnQgb2YgdGhlIG9jdC1lbmNvZGVkIHVuaXQgbGVuZ3RoIHZlY3Rvci5cbiAqIEBwYXJhbSB7TnVtYmVyfSB5IFRoZSB5IGNvbXBvbmVudCBvZiB0aGUgb2N0LWVuY29kZWQgdW5pdCBsZW5ndGggdmVjdG9yLlxuICogQHBhcmFtIHtDYXJ0ZXNpYW4zfSByZXN1bHQgVGhlIGRlY29kZWQgYW5kIG5vcm1hbGl6ZWQgdmVjdG9yLlxuICogQHJldHVybnMge0NhcnRlc2lhbjN9IFRoZSBkZWNvZGVkIGFuZCBub3JtYWxpemVkIHZlY3Rvci5cbiAqXG4gKiBAZXhjZXB0aW9uIHtEZXZlbG9wZXJFcnJvcn0geCBhbmQgeSBtdXN0IGJlIGFuIHVuc2lnbmVkIG5vcm1hbGl6ZWQgaW50ZWdlciBiZXR3ZWVuIDAgYW5kIDI1NS5cbiAqXG4gKiBAc2VlIEF0dHJpYnV0ZUNvbXByZXNzaW9uLm9jdERlY29kZUluUmFuZ2VcbiAqL1xuQXR0cmlidXRlQ29tcHJlc3Npb24ub2N0RGVjb2RlID0gZnVuY3Rpb24gKHgsIHksIHJlc3VsdCkge1xuICByZXR1cm4gQXR0cmlidXRlQ29tcHJlc3Npb24ub2N0RGVjb2RlSW5SYW5nZSh4LCB5LCAyNTUsIHJlc3VsdCk7XG59O1xuXG4vKipcbiAqIERlY29kZXMgYSB1bml0LWxlbmd0aCB2ZWN0b3IgaW4gNCBieXRlICdvY3QnIGVuY29kaW5nIHRvIGEgbm9ybWFsaXplZCAzLWNvbXBvbmVudCB2ZWN0b3IuXG4gKlxuICogQHBhcmFtIHtDYXJ0ZXNpYW40fSBlbmNvZGVkIFRoZSBvY3QtZW5jb2RlZCB1bml0IGxlbmd0aCB2ZWN0b3IuXG4gKiBAcGFyYW0ge0NhcnRlc2lhbjN9IHJlc3VsdCBUaGUgZGVjb2RlZCBhbmQgbm9ybWFsaXplZCB2ZWN0b3IuXG4gKiBAcmV0dXJucyB7Q2FydGVzaWFuM30gVGhlIGRlY29kZWQgYW5kIG5vcm1hbGl6ZWQgdmVjdG9yLlxuICpcbiAqIEBleGNlcHRpb24ge0RldmVsb3BlckVycm9yfSB4LCB5LCB6LCBhbmQgdyBtdXN0IGJlIHVuc2lnbmVkIG5vcm1hbGl6ZWQgaW50ZWdlcnMgYmV0d2VlbiAwIGFuZCAyNTUuXG4gKlxuICogQHNlZSBBdHRyaWJ1dGVDb21wcmVzc2lvbi5vY3REZWNvZGVJblJhbmdlXG4gKiBAc2VlIEF0dHJpYnV0ZUNvbXByZXNzaW9uLm9jdEVuY29kZVRvQ2FydGVzaWFuNFxuICovXG5BdHRyaWJ1dGVDb21wcmVzc2lvbi5vY3REZWNvZGVGcm9tQ2FydGVzaWFuNCA9IGZ1bmN0aW9uIChlbmNvZGVkLCByZXN1bHQpIHtcbiAgLy8+PmluY2x1ZGVTdGFydCgnZGVidWcnLCBwcmFnbWFzLmRlYnVnKTtcbiAgQ2hlY2sudHlwZU9mLm9iamVjdChcImVuY29kZWRcIiwgZW5jb2RlZCk7XG4gIENoZWNrLnR5cGVPZi5vYmplY3QoXCJyZXN1bHRcIiwgcmVzdWx0KTtcbiAgLy8+PmluY2x1ZGVFbmQoJ2RlYnVnJyk7XG4gIHZhciB4ID0gZW5jb2RlZC54O1xuICB2YXIgeSA9IGVuY29kZWQueTtcbiAgdmFyIHogPSBlbmNvZGVkLno7XG4gIHZhciB3ID0gZW5jb2RlZC53O1xuICAvLz4+aW5jbHVkZVN0YXJ0KCdkZWJ1ZycsIHByYWdtYXMuZGVidWcpO1xuICBpZiAoXG4gICAgeCA8IDAgfHxcbiAgICB4ID4gMjU1IHx8XG4gICAgeSA8IDAgfHxcbiAgICB5ID4gMjU1IHx8XG4gICAgeiA8IDAgfHxcbiAgICB6ID4gMjU1IHx8XG4gICAgdyA8IDAgfHxcbiAgICB3ID4gMjU1XG4gICkge1xuICAgIHRocm93IG5ldyBEZXZlbG9wZXJFcnJvcihcbiAgICAgIFwieCwgeSwgeiwgYW5kIHcgbXVzdCBiZSB1bnNpZ25lZCBub3JtYWxpemVkIGludGVnZXJzIGJldHdlZW4gMCBhbmQgMjU1XCJcbiAgICApO1xuICB9XG4gIC8vPj5pbmNsdWRlRW5kKCdkZWJ1ZycpO1xuXG4gIHZhciB4T2N0MTYgPSB4ICogTEVGVF9TSElGVCArIHk7XG4gIHZhciB5T2N0MTYgPSB6ICogTEVGVF9TSElGVCArIHc7XG4gIHJldHVybiBBdHRyaWJ1dGVDb21wcmVzc2lvbi5vY3REZWNvZGVJblJhbmdlKHhPY3QxNiwgeU9jdDE2LCA2NTUzNSwgcmVzdWx0KTtcbn07XG5cbi8qKlxuICogUGFja3MgYW4gb2N0IGVuY29kZWQgdmVjdG9yIGludG8gYSBzaW5nbGUgZmxvYXRpbmctcG9pbnQgbnVtYmVyLlxuICpcbiAqIEBwYXJhbSB7Q2FydGVzaWFuMn0gZW5jb2RlZCBUaGUgb2N0IGVuY29kZWQgdmVjdG9yLlxuICogQHJldHVybnMge051bWJlcn0gVGhlIG9jdCBlbmNvZGVkIHZlY3RvciBwYWNrZWQgaW50byBhIHNpbmdsZSBmbG9hdC5cbiAqXG4gKi9cbkF0dHJpYnV0ZUNvbXByZXNzaW9uLm9jdFBhY2tGbG9hdCA9IGZ1bmN0aW9uIChlbmNvZGVkKSB7XG4gIC8vPj5pbmNsdWRlU3RhcnQoJ2RlYnVnJywgcHJhZ21hcy5kZWJ1Zyk7XG4gIENoZWNrLmRlZmluZWQoXCJlbmNvZGVkXCIsIGVuY29kZWQpO1xuICAvLz4+aW5jbHVkZUVuZCgnZGVidWcnKTtcbiAgcmV0dXJuIDI1Ni4wICogZW5jb2RlZC54ICsgZW5jb2RlZC55O1xufTtcblxudmFyIHNjcmF0Y2hFbmNvZGVDYXJ0MiA9IG5ldyBDYXJ0ZXNpYW4yKCk7XG5cbi8qKlxuICogRW5jb2RlcyBhIG5vcm1hbGl6ZWQgdmVjdG9yIGludG8gMiBTTk9STSB2YWx1ZXMgaW4gdGhlIHJhbmdlIG9mIFswLTI1NV0gZm9sbG93aW5nIHRoZSAnb2N0JyBlbmNvZGluZyBhbmRcbiAqIHN0b3JlcyB0aG9zZSB2YWx1ZXMgaW4gYSBzaW5nbGUgZmxvYXQtcG9pbnQgbnVtYmVyLlxuICpcbiAqIEBwYXJhbSB7Q2FydGVzaWFuM30gdmVjdG9yIFRoZSBub3JtYWxpemVkIHZlY3RvciB0byBiZSBjb21wcmVzc2VkIGludG8gMiBieXRlICdvY3QnIGVuY29kaW5nLlxuICogQHJldHVybnMge051bWJlcn0gVGhlIDIgYnl0ZSBvY3QtZW5jb2RlZCB1bml0IGxlbmd0aCB2ZWN0b3IuXG4gKlxuICogQGV4Y2VwdGlvbiB7RGV2ZWxvcGVyRXJyb3J9IHZlY3RvciBtdXN0IGJlIG5vcm1hbGl6ZWQuXG4gKi9cbkF0dHJpYnV0ZUNvbXByZXNzaW9uLm9jdEVuY29kZUZsb2F0ID0gZnVuY3Rpb24gKHZlY3Rvcikge1xuICBBdHRyaWJ1dGVDb21wcmVzc2lvbi5vY3RFbmNvZGUodmVjdG9yLCBzY3JhdGNoRW5jb2RlQ2FydDIpO1xuICByZXR1cm4gQXR0cmlidXRlQ29tcHJlc3Npb24ub2N0UGFja0Zsb2F0KHNjcmF0Y2hFbmNvZGVDYXJ0Mik7XG59O1xuXG4vKipcbiAqIERlY29kZXMgYSB1bml0LWxlbmd0aCB2ZWN0b3IgaW4gJ29jdCcgZW5jb2RpbmcgcGFja2VkIGluIGEgZmxvYXRpbmctcG9pbnQgbnVtYmVyIHRvIGEgbm9ybWFsaXplZCAzLWNvbXBvbmVudCB2ZWN0b3IuXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IHZhbHVlIFRoZSBvY3QtZW5jb2RlZCB1bml0IGxlbmd0aCB2ZWN0b3Igc3RvcmVkIGFzIGEgc2luZ2xlIGZsb2F0aW5nLXBvaW50IG51bWJlci5cbiAqIEBwYXJhbSB7Q2FydGVzaWFuM30gcmVzdWx0IFRoZSBkZWNvZGVkIGFuZCBub3JtYWxpemVkIHZlY3RvclxuICogQHJldHVybnMge0NhcnRlc2lhbjN9IFRoZSBkZWNvZGVkIGFuZCBub3JtYWxpemVkIHZlY3Rvci5cbiAqXG4gKi9cbkF0dHJpYnV0ZUNvbXByZXNzaW9uLm9jdERlY29kZUZsb2F0ID0gZnVuY3Rpb24gKHZhbHVlLCByZXN1bHQpIHtcbiAgLy8+PmluY2x1ZGVTdGFydCgnZGVidWcnLCBwcmFnbWFzLmRlYnVnKTtcbiAgQ2hlY2suZGVmaW5lZChcInZhbHVlXCIsIHZhbHVlKTtcbiAgLy8+PmluY2x1ZGVFbmQoJ2RlYnVnJyk7XG5cbiAgdmFyIHRlbXAgPSB2YWx1ZSAvIDI1Ni4wO1xuICB2YXIgeCA9IE1hdGguZmxvb3IodGVtcCk7XG4gIHZhciB5ID0gKHRlbXAgLSB4KSAqIDI1Ni4wO1xuXG4gIHJldHVybiBBdHRyaWJ1dGVDb21wcmVzc2lvbi5vY3REZWNvZGUoeCwgeSwgcmVzdWx0KTtcbn07XG5cbi8qKlxuICogRW5jb2RlcyB0aHJlZSBub3JtYWxpemVkIHZlY3RvcnMgaW50byA2IFNOT1JNIHZhbHVlcyBpbiB0aGUgcmFuZ2Ugb2YgWzAtMjU1XSBmb2xsb3dpbmcgdGhlICdvY3QnIGVuY29kaW5nIGFuZFxuICogcGFja3MgdGhvc2UgaW50byB0d28gZmxvYXRpbmctcG9pbnQgbnVtYmVycy5cbiAqXG4gKiBAcGFyYW0ge0NhcnRlc2lhbjN9IHYxIEEgbm9ybWFsaXplZCB2ZWN0b3IgdG8gYmUgY29tcHJlc3NlZC5cbiAqIEBwYXJhbSB7Q2FydGVzaWFuM30gdjIgQSBub3JtYWxpemVkIHZlY3RvciB0byBiZSBjb21wcmVzc2VkLlxuICogQHBhcmFtIHtDYXJ0ZXNpYW4zfSB2MyBBIG5vcm1hbGl6ZWQgdmVjdG9yIHRvIGJlIGNvbXByZXNzZWQuXG4gKiBAcGFyYW0ge0NhcnRlc2lhbjJ9IHJlc3VsdCBUaGUgJ29jdCcgZW5jb2RlZCB2ZWN0b3JzIHBhY2tlZCBpbnRvIHR3byBmbG9hdGluZy1wb2ludCBudW1iZXJzLlxuICogQHJldHVybnMge0NhcnRlc2lhbjJ9IFRoZSAnb2N0JyBlbmNvZGVkIHZlY3RvcnMgcGFja2VkIGludG8gdHdvIGZsb2F0aW5nLXBvaW50IG51bWJlcnMuXG4gKlxuICovXG5BdHRyaWJ1dGVDb21wcmVzc2lvbi5vY3RQYWNrID0gZnVuY3Rpb24gKHYxLCB2MiwgdjMsIHJlc3VsdCkge1xuICAvLz4+aW5jbHVkZVN0YXJ0KCdkZWJ1ZycsIHByYWdtYXMuZGVidWcpO1xuICBDaGVjay5kZWZpbmVkKFwidjFcIiwgdjEpO1xuICBDaGVjay5kZWZpbmVkKFwidjJcIiwgdjIpO1xuICBDaGVjay5kZWZpbmVkKFwidjNcIiwgdjMpO1xuICBDaGVjay5kZWZpbmVkKFwicmVzdWx0XCIsIHJlc3VsdCk7XG4gIC8vPj5pbmNsdWRlRW5kKCdkZWJ1ZycpO1xuXG4gIHZhciBlbmNvZGVkMSA9IEF0dHJpYnV0ZUNvbXByZXNzaW9uLm9jdEVuY29kZUZsb2F0KHYxKTtcbiAgdmFyIGVuY29kZWQyID0gQXR0cmlidXRlQ29tcHJlc3Npb24ub2N0RW5jb2RlRmxvYXQodjIpO1xuXG4gIHZhciBlbmNvZGVkMyA9IEF0dHJpYnV0ZUNvbXByZXNzaW9uLm9jdEVuY29kZSh2Mywgc2NyYXRjaEVuY29kZUNhcnQyKTtcbiAgcmVzdWx0LnggPSA2NTUzNi4wICogZW5jb2RlZDMueCArIGVuY29kZWQxO1xuICByZXN1bHQueSA9IDY1NTM2LjAgKiBlbmNvZGVkMy55ICsgZW5jb2RlZDI7XG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG4vKipcbiAqIERlY29kZXMgdGhyZWUgdW5pdC1sZW5ndGggdmVjdG9ycyBpbiAnb2N0JyBlbmNvZGluZyBwYWNrZWQgaW50byBhIGZsb2F0aW5nLXBvaW50IG51bWJlciB0byBhIG5vcm1hbGl6ZWQgMy1jb21wb25lbnQgdmVjdG9yLlxuICpcbiAqIEBwYXJhbSB7Q2FydGVzaWFuMn0gcGFja2VkIFRoZSB0aHJlZSBvY3QtZW5jb2RlZCB1bml0IGxlbmd0aCB2ZWN0b3JzIHN0b3JlZCBhcyB0d28gZmxvYXRpbmctcG9pbnQgbnVtYmVyLlxuICogQHBhcmFtIHtDYXJ0ZXNpYW4zfSB2MSBPbmUgZGVjb2RlZCBhbmQgbm9ybWFsaXplZCB2ZWN0b3IuXG4gKiBAcGFyYW0ge0NhcnRlc2lhbjN9IHYyIE9uZSBkZWNvZGVkIGFuZCBub3JtYWxpemVkIHZlY3Rvci5cbiAqIEBwYXJhbSB7Q2FydGVzaWFuM30gdjMgT25lIGRlY29kZWQgYW5kIG5vcm1hbGl6ZWQgdmVjdG9yLlxuICovXG5BdHRyaWJ1dGVDb21wcmVzc2lvbi5vY3RVbnBhY2sgPSBmdW5jdGlvbiAocGFja2VkLCB2MSwgdjIsIHYzKSB7XG4gIC8vPj5pbmNsdWRlU3RhcnQoJ2RlYnVnJywgcHJhZ21hcy5kZWJ1Zyk7XG4gIENoZWNrLmRlZmluZWQoXCJwYWNrZWRcIiwgcGFja2VkKTtcbiAgQ2hlY2suZGVmaW5lZChcInYxXCIsIHYxKTtcbiAgQ2hlY2suZGVmaW5lZChcInYyXCIsIHYyKTtcbiAgQ2hlY2suZGVmaW5lZChcInYzXCIsIHYzKTtcbiAgLy8+PmluY2x1ZGVFbmQoJ2RlYnVnJyk7XG5cbiAgdmFyIHRlbXAgPSBwYWNrZWQueCAvIDY1NTM2LjA7XG4gIHZhciB4ID0gTWF0aC5mbG9vcih0ZW1wKTtcbiAgdmFyIGVuY29kZWRGbG9hdDEgPSAodGVtcCAtIHgpICogNjU1MzYuMDtcblxuICB0ZW1wID0gcGFja2VkLnkgLyA2NTUzNi4wO1xuICB2YXIgeSA9IE1hdGguZmxvb3IodGVtcCk7XG4gIHZhciBlbmNvZGVkRmxvYXQyID0gKHRlbXAgLSB5KSAqIDY1NTM2LjA7XG5cbiAgQXR0cmlidXRlQ29tcHJlc3Npb24ub2N0RGVjb2RlRmxvYXQoZW5jb2RlZEZsb2F0MSwgdjEpO1xuICBBdHRyaWJ1dGVDb21wcmVzc2lvbi5vY3REZWNvZGVGbG9hdChlbmNvZGVkRmxvYXQyLCB2Mik7XG4gIEF0dHJpYnV0ZUNvbXByZXNzaW9uLm9jdERlY29kZSh4LCB5LCB2Myk7XG59O1xuXG4vKipcbiAqIFBhY2sgdGV4dHVyZSBjb29yZGluYXRlcyBpbnRvIGEgc2luZ2xlIGZsb2F0LiBUaGUgdGV4dHVyZSBjb29yZGluYXRlcyB3aWxsIG9ubHkgcHJlc2VydmUgMTIgYml0cyBvZiBwcmVjaXNpb24uXG4gKlxuICogQHBhcmFtIHtDYXJ0ZXNpYW4yfSB0ZXh0dXJlQ29vcmRpbmF0ZXMgVGhlIHRleHR1cmUgY29vcmRpbmF0ZXMgdG8gY29tcHJlc3MuICBCb3RoIGNvb3JkaW5hdGVzIG11c3QgYmUgaW4gdGhlIHJhbmdlIDAuMC0xLjAuXG4gKiBAcmV0dXJucyB7TnVtYmVyfSBUaGUgcGFja2VkIHRleHR1cmUgY29vcmRpbmF0ZXMuXG4gKlxuICovXG5BdHRyaWJ1dGVDb21wcmVzc2lvbi5jb21wcmVzc1RleHR1cmVDb29yZGluYXRlcyA9IGZ1bmN0aW9uIChcbiAgdGV4dHVyZUNvb3JkaW5hdGVzXG4pIHtcbiAgLy8+PmluY2x1ZGVTdGFydCgnZGVidWcnLCBwcmFnbWFzLmRlYnVnKTtcbiAgQ2hlY2suZGVmaW5lZChcInRleHR1cmVDb29yZGluYXRlc1wiLCB0ZXh0dXJlQ29vcmRpbmF0ZXMpO1xuICAvLz4+aW5jbHVkZUVuZCgnZGVidWcnKTtcblxuICAvLyBNb3ZlIHggYW5kIHkgdG8gdGhlIHJhbmdlIDAtNDA5NTtcbiAgdmFyIHggPSAodGV4dHVyZUNvb3JkaW5hdGVzLnggKiA0MDk1LjApIHwgMDtcbiAgdmFyIHkgPSAodGV4dHVyZUNvb3JkaW5hdGVzLnkgKiA0MDk1LjApIHwgMDtcbiAgcmV0dXJuIDQwOTYuMCAqIHggKyB5O1xufTtcblxuLyoqXG4gKiBEZWNvbXByZXNzZXMgdGV4dHVyZSBjb29yZGluYXRlcyB0aGF0IHdlcmUgcGFja2VkIGludG8gYSBzaW5nbGUgZmxvYXQuXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IGNvbXByZXNzZWQgVGhlIGNvbXByZXNzZWQgdGV4dHVyZSBjb29yZGluYXRlcy5cbiAqIEBwYXJhbSB7Q2FydGVzaWFuMn0gcmVzdWx0IFRoZSBkZWNvbXByZXNzZWQgdGV4dHVyZSBjb29yZGluYXRlcy5cbiAqIEByZXR1cm5zIHtDYXJ0ZXNpYW4yfSBUaGUgbW9kaWZpZWQgcmVzdWx0IHBhcmFtZXRlci5cbiAqXG4gKi9cbkF0dHJpYnV0ZUNvbXByZXNzaW9uLmRlY29tcHJlc3NUZXh0dXJlQ29vcmRpbmF0ZXMgPSBmdW5jdGlvbiAoXG4gIGNvbXByZXNzZWQsXG4gIHJlc3VsdFxuKSB7XG4gIC8vPj5pbmNsdWRlU3RhcnQoJ2RlYnVnJywgcHJhZ21hcy5kZWJ1Zyk7XG4gIENoZWNrLmRlZmluZWQoXCJjb21wcmVzc2VkXCIsIGNvbXByZXNzZWQpO1xuICBDaGVjay5kZWZpbmVkKFwicmVzdWx0XCIsIHJlc3VsdCk7XG4gIC8vPj5pbmNsdWRlRW5kKCdkZWJ1ZycpO1xuXG4gIHZhciB0ZW1wID0gY29tcHJlc3NlZCAvIDQwOTYuMDtcbiAgdmFyIHhaZXJvVG80MDk1ID0gTWF0aC5mbG9vcih0ZW1wKTtcbiAgcmVzdWx0LnggPSB4WmVyb1RvNDA5NSAvIDQwOTUuMDtcbiAgcmVzdWx0LnkgPSAoY29tcHJlc3NlZCAtIHhaZXJvVG80MDk1ICogNDA5NikgLyA0MDk1O1xuICByZXR1cm4gcmVzdWx0O1xufTtcblxuZnVuY3Rpb24gemlnWmFnRGVjb2RlKHZhbHVlKSB7XG4gIHJldHVybiAodmFsdWUgPj4gMSkgXiAtKHZhbHVlICYgMSk7XG59XG5cbi8qKlxuICogRGVjb2RlcyBkZWx0YSBhbmQgWmlnWmFnIGVuY29kZWQgdmVydGljZXMuIFRoaXMgbW9kaWZpZXMgdGhlIGJ1ZmZlcnMgaW4gcGxhY2UuXG4gKlxuICogQHBhcmFtIHtVaW50MTZBcnJheX0gdUJ1ZmZlciBUaGUgYnVmZmVyIHZpZXcgb2YgdSB2YWx1ZXMuXG4gKiBAcGFyYW0ge1VpbnQxNkFycmF5fSB2QnVmZmVyIFRoZSBidWZmZXIgdmlldyBvZiB2IHZhbHVlcy5cbiAqIEBwYXJhbSB7VWludDE2QXJyYXl9IFtoZWlnaHRCdWZmZXJdIFRoZSBidWZmZXIgdmlldyBvZiBoZWlnaHQgdmFsdWVzLlxuICpcbiAqIEBzZWUge0BsaW5rIGh0dHBzOi8vZ2l0aHViLmNvbS9DZXNpdW1HUy9xdWFudGl6ZWQtbWVzaHxxdWFudGl6ZWQtbWVzaC0xLjAgdGVycmFpbiBmb3JtYXR9XG4gKi9cbkF0dHJpYnV0ZUNvbXByZXNzaW9uLnppZ1phZ0RlbHRhRGVjb2RlID0gZnVuY3Rpb24gKFxuICB1QnVmZmVyLFxuICB2QnVmZmVyLFxuICBoZWlnaHRCdWZmZXJcbikge1xuICAvLz4+aW5jbHVkZVN0YXJ0KCdkZWJ1ZycsIHByYWdtYXMuZGVidWcpO1xuICBDaGVjay5kZWZpbmVkKFwidUJ1ZmZlclwiLCB1QnVmZmVyKTtcbiAgQ2hlY2suZGVmaW5lZChcInZCdWZmZXJcIiwgdkJ1ZmZlcik7XG4gIENoZWNrLnR5cGVPZi5udW1iZXIuZXF1YWxzKFxuICAgIFwidUJ1ZmZlci5sZW5ndGhcIixcbiAgICBcInZCdWZmZXIubGVuZ3RoXCIsXG4gICAgdUJ1ZmZlci5sZW5ndGgsXG4gICAgdkJ1ZmZlci5sZW5ndGhcbiAgKTtcbiAgaWYgKGRlZmluZWQoaGVpZ2h0QnVmZmVyKSkge1xuICAgIENoZWNrLnR5cGVPZi5udW1iZXIuZXF1YWxzKFxuICAgICAgXCJ1QnVmZmVyLmxlbmd0aFwiLFxuICAgICAgXCJoZWlnaHRCdWZmZXIubGVuZ3RoXCIsXG4gICAgICB1QnVmZmVyLmxlbmd0aCxcbiAgICAgIGhlaWdodEJ1ZmZlci5sZW5ndGhcbiAgICApO1xuICB9XG4gIC8vPj5pbmNsdWRlRW5kKCdkZWJ1ZycpO1xuXG4gIHZhciBjb3VudCA9IHVCdWZmZXIubGVuZ3RoO1xuXG4gIHZhciB1ID0gMDtcbiAgdmFyIHYgPSAwO1xuICB2YXIgaGVpZ2h0ID0gMDtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGNvdW50OyArK2kpIHtcbiAgICB1ICs9IHppZ1phZ0RlY29kZSh1QnVmZmVyW2ldKTtcbiAgICB2ICs9IHppZ1phZ0RlY29kZSh2QnVmZmVyW2ldKTtcblxuICAgIHVCdWZmZXJbaV0gPSB1O1xuICAgIHZCdWZmZXJbaV0gPSB2O1xuXG4gICAgaWYgKGRlZmluZWQoaGVpZ2h0QnVmZmVyKSkge1xuICAgICAgaGVpZ2h0ICs9IHppZ1phZ0RlY29kZShoZWlnaHRCdWZmZXJbaV0pO1xuICAgICAgaGVpZ2h0QnVmZmVyW2ldID0gaGVpZ2h0O1xuICAgIH1cbiAgfVxufTtcblxuLyoqXG4gKiBEZXF1YW50aXplcyBhIHF1YW50aXplZCB0eXBlZCBhcnJheSBpbnRvIGEgZmxvYXRpbmcgcG9pbnQgdHlwZWQgYXJyYXkuXG4gKlxuICogQHNlZSB7QGxpbmsgaHR0cHM6Ly9naXRodWIuY29tL0tocm9ub3NHcm91cC9nbFRGL3RyZWUvbWFzdGVyL2V4dGVuc2lvbnMvMi4wL0tocm9ub3MvS0hSX21lc2hfcXVhbnRpemF0aW9uI2VuY29kaW5nLXF1YW50aXplZC1kYXRhfVxuICpcbiAqIEBwYXJhbSB7SW50OEFycmF5fFVpbnQ4QXJyYXl8SW50MTZBcnJheXxVaW50MTZBcnJheXxJbnQzMkFycmF5fFVpbnQzMkFycmF5fSB0eXBlZEFycmF5IFRoZSB0eXBlZCBhcnJheSBmb3IgdGhlIHF1YW50aXplZCBkYXRhLlxuICogQHBhcmFtIHtDb21wb25lbnREYXRhdHlwZX0gY29tcG9uZW50RGF0YXR5cGUgVGhlIGNvbXBvbmVudCBkYXRhdHlwZSBvZiB0aGUgcXVhbnRpemVkIGRhdGEuXG4gKiBAcGFyYW0ge0F0dHJpYnV0ZVR5cGV9IHR5cGUgVGhlIGF0dHJpYnV0ZSB0eXBlIG9mIHRoZSBxdWFudGl6ZWQgZGF0YS5cbiAqIEBwYXJhbSB7TnVtYmVyfSBjb3VudCBUaGUgbnVtYmVyIG9mIGF0dHJpYnV0ZXMgcmVmZXJlbmNlZCBpbiB0aGUgZGVxdWFudGl6ZWQgYXJyYXkuXG4gKlxuICogQHJldHVybnMge0Zsb2F0MzJBcnJheX0gVGhlIGRlcXVhbnRpemVkIGFycmF5LlxuICovXG5BdHRyaWJ1dGVDb21wcmVzc2lvbi5kZXF1YW50aXplID0gZnVuY3Rpb24gKFxuICB0eXBlZEFycmF5LFxuICBjb21wb25lbnREYXRhdHlwZSxcbiAgdHlwZSxcbiAgY291bnRcbikge1xuICAvLz4+aW5jbHVkZVN0YXJ0KCdkZWJ1ZycsIHByYWdtYXMuZGVidWcpO1xuICBDaGVjay5kZWZpbmVkKFwidHlwZWRBcnJheVwiLCB0eXBlZEFycmF5KTtcbiAgQ2hlY2suZGVmaW5lZChcImNvbXBvbmVudERhdGF0eXBlXCIsIGNvbXBvbmVudERhdGF0eXBlKTtcbiAgQ2hlY2suZGVmaW5lZChcInR5cGVcIiwgdHlwZSk7XG4gIENoZWNrLmRlZmluZWQoXCJjb3VudFwiLCBjb3VudCk7XG4gIC8vPj5pbmNsdWRlRW5kKCdkZWJ1ZycpO1xuXG4gIHZhciBjb21wb25lbnRzUGVyQXR0cmlidXRlID0gQXR0cmlidXRlVHlwZS5nZXROdW1iZXJPZkNvbXBvbmVudHModHlwZSk7XG5cbiAgdmFyIGRpdmlzb3I7XG4gIHN3aXRjaCAoY29tcG9uZW50RGF0YXR5cGUpIHtcbiAgICBjYXNlIENvbXBvbmVudERhdGF0eXBlLkJZVEU6XG4gICAgICBkaXZpc29yID0gMTI3LjA7XG4gICAgICBicmVhaztcbiAgICBjYXNlIENvbXBvbmVudERhdGF0eXBlLlVOU0lHTkVEX0JZVEU6XG4gICAgICBkaXZpc29yID0gMjU1LjA7XG4gICAgICBicmVhaztcbiAgICBjYXNlIENvbXBvbmVudERhdGF0eXBlLlNIT1JUOlxuICAgICAgZGl2aXNvciA9IDMyNzY3LjA7XG4gICAgICBicmVhaztcbiAgICBjYXNlIENvbXBvbmVudERhdGF0eXBlLlVOU0lHTkVEX1NIT1JUOlxuICAgICAgZGl2aXNvciA9IDY1NTM1LjA7XG4gICAgICBicmVhaztcbiAgICBjYXNlIENvbXBvbmVudERhdGF0eXBlLklOVDpcbiAgICAgIGRpdmlzb3IgPSAyMTQ3NDgzNjQ3LjA7XG4gICAgICBicmVhaztcbiAgICBjYXNlIENvbXBvbmVudERhdGF0eXBlLlVOU0lHTkVEX0lOVDpcbiAgICAgIGRpdmlzb3IgPSA0Mjk0OTY3Mjk1LjA7XG4gICAgICBicmVhaztcbiAgICAvLz4+aW5jbHVkZVN0YXJ0KCdkZWJ1ZycsIHByYWdtYXMuZGVidWcpO1xuICAgIGRlZmF1bHQ6XG4gICAgICB0aHJvdyBuZXcgRGV2ZWxvcGVyRXJyb3IoXG4gICAgICAgIFwiQ2Fubm90IGRlcXVhbnRpemUgY29tcG9uZW50IGRhdGF0eXBlOiBcIiArIGNvbXBvbmVudERhdGF0eXBlXG4gICAgICApO1xuICAgIC8vPj5pbmNsdWRlRW5kKCdkZWJ1ZycpO1xuICB9XG5cbiAgdmFyIGRlcXVhbnRpemVkVHlwZWRBcnJheSA9IG5ldyBGbG9hdDMyQXJyYXkoY291bnQgKiBjb21wb25lbnRzUGVyQXR0cmlidXRlKTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGNvdW50OyBpKyspIHtcbiAgICBmb3IgKHZhciBqID0gMDsgaiA8IGNvbXBvbmVudHNQZXJBdHRyaWJ1dGU7IGorKykge1xuICAgICAgdmFyIGluZGV4ID0gaSAqIGNvbXBvbmVudHNQZXJBdHRyaWJ1dGUgKyBqO1xuICAgICAgZGVxdWFudGl6ZWRUeXBlZEFycmF5W2luZGV4XSA9IE1hdGgubWF4KFxuICAgICAgICB0eXBlZEFycmF5W2luZGV4XSAvIGRpdmlzb3IsXG4gICAgICAgIC0xLjBcbiAgICAgICk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGRlcXVhbnRpemVkVHlwZWRBcnJheTtcbn07XG5cbmV4cG9ydCBkZWZhdWx0IEF0dHJpYnV0ZUNvbXByZXNzaW9uO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///52323\n')},55829:function(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__){eval('/* harmony import */ var _Cartesian3_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(60216);\n/* harmony import */ var _Check_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(66553);\n/* harmony import */ var _defaultValue_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(62200);\n/* harmony import */ var _defined_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(82982);\n/* harmony import */ var _Intersect_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(84935);\n\n\n\n\n\n\n/**\n * Creates an instance of an AxisAlignedBoundingBox from the minimum and maximum points along the x, y, and z axes.\n * @alias AxisAlignedBoundingBox\n * @constructor\n *\n * @param {Cartesian3} [minimum=Cartesian3.ZERO] The minimum point along the x, y, and z axes.\n * @param {Cartesian3} [maximum=Cartesian3.ZERO] The maximum point along the x, y, and z axes.\n * @param {Cartesian3} [center] The center of the box; automatically computed if not supplied.\n *\n * @see BoundingSphere\n * @see BoundingRectangle\n */\nfunction AxisAlignedBoundingBox(minimum, maximum, center) {\n  /**\n   * The minimum point defining the bounding box.\n   * @type {Cartesian3}\n   * @default {@link Cartesian3.ZERO}\n   */\n  this.minimum = _Cartesian3_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].clone */ .Z.clone((0,_defaultValue_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"] */ .Z)(minimum, _Cartesian3_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].ZERO */ .Z.ZERO));\n\n  /**\n   * The maximum point defining the bounding box.\n   * @type {Cartesian3}\n   * @default {@link Cartesian3.ZERO}\n   */\n  this.maximum = _Cartesian3_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].clone */ .Z.clone((0,_defaultValue_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"] */ .Z)(maximum, _Cartesian3_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].ZERO */ .Z.ZERO));\n\n  //If center was not defined, compute it.\n  if (!(0,_defined_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .Z)(center)) {\n    center = _Cartesian3_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].midpoint */ .Z.midpoint(this.minimum, this.maximum, new _Cartesian3_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .Z());\n  } else {\n    center = _Cartesian3_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].clone */ .Z.clone(center);\n  }\n\n  /**\n   * The center point of the bounding box.\n   * @type {Cartesian3}\n   */\n  this.center = center;\n}\n\n/**\n * Computes an instance of an AxisAlignedBoundingBox. The box is determined by\n * finding the points spaced the farthest apart on the x, y, and z axes.\n *\n * @param {Cartesian3[]} positions List of points that the bounding box will enclose.  Each point must have a <code>x</code>, <code>y</code>, and <code>z</code> properties.\n * @param {AxisAlignedBoundingBox} [result] The object onto which to store the result.\n * @returns {AxisAlignedBoundingBox} The modified result parameter or a new AxisAlignedBoundingBox instance if one was not provided.\n *\n * @example\n * // Compute an axis aligned bounding box enclosing two points.\n * var box = Cesium.AxisAlignedBoundingBox.fromPoints([new Cesium.Cartesian3(2, 0, 0), new Cesium.Cartesian3(-2, 0, 0)]);\n */\nAxisAlignedBoundingBox.fromPoints = function (positions, result) {\n  if (!(0,_defined_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .Z)(result)) {\n    result = new AxisAlignedBoundingBox();\n  }\n\n  if (!(0,_defined_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .Z)(positions) || positions.length === 0) {\n    result.minimum = _Cartesian3_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].clone */ .Z.clone(_Cartesian3_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].ZERO */ .Z.ZERO, result.minimum);\n    result.maximum = _Cartesian3_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].clone */ .Z.clone(_Cartesian3_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].ZERO */ .Z.ZERO, result.maximum);\n    result.center = _Cartesian3_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].clone */ .Z.clone(_Cartesian3_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].ZERO */ .Z.ZERO, result.center);\n    return result;\n  }\n\n  var minimumX = positions[0].x;\n  var minimumY = positions[0].y;\n  var minimumZ = positions[0].z;\n\n  var maximumX = positions[0].x;\n  var maximumY = positions[0].y;\n  var maximumZ = positions[0].z;\n\n  var length = positions.length;\n  for (var i = 1; i < length; i++) {\n    var p = positions[i];\n    var x = p.x;\n    var y = p.y;\n    var z = p.z;\n\n    minimumX = Math.min(x, minimumX);\n    maximumX = Math.max(x, maximumX);\n    minimumY = Math.min(y, minimumY);\n    maximumY = Math.max(y, maximumY);\n    minimumZ = Math.min(z, minimumZ);\n    maximumZ = Math.max(z, maximumZ);\n  }\n\n  var minimum = result.minimum;\n  minimum.x = minimumX;\n  minimum.y = minimumY;\n  minimum.z = minimumZ;\n\n  var maximum = result.maximum;\n  maximum.x = maximumX;\n  maximum.y = maximumY;\n  maximum.z = maximumZ;\n\n  result.center = _Cartesian3_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].midpoint */ .Z.midpoint(minimum, maximum, result.center);\n\n  return result;\n};\n\n/**\n * Duplicates a AxisAlignedBoundingBox instance.\n *\n * @param {AxisAlignedBoundingBox} box The bounding box to duplicate.\n * @param {AxisAlignedBoundingBox} [result] The object onto which to store the result.\n * @returns {AxisAlignedBoundingBox} The modified result parameter or a new AxisAlignedBoundingBox instance if none was provided. (Returns undefined if box is undefined)\n */\nAxisAlignedBoundingBox.clone = function (box, result) {\n  if (!(0,_defined_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .Z)(box)) {\n    return undefined;\n  }\n\n  if (!(0,_defined_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .Z)(result)) {\n    return new AxisAlignedBoundingBox(box.minimum, box.maximum, box.center);\n  }\n\n  result.minimum = _Cartesian3_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].clone */ .Z.clone(box.minimum, result.minimum);\n  result.maximum = _Cartesian3_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].clone */ .Z.clone(box.maximum, result.maximum);\n  result.center = _Cartesian3_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].clone */ .Z.clone(box.center, result.center);\n  return result;\n};\n\n/**\n * Compares the provided AxisAlignedBoundingBox componentwise and returns\n * <code>true</code> if they are equal, <code>false</code> otherwise.\n *\n * @param {AxisAlignedBoundingBox} [left] The first AxisAlignedBoundingBox.\n * @param {AxisAlignedBoundingBox} [right] The second AxisAlignedBoundingBox.\n * @returns {Boolean} <code>true</code> if left and right are equal, <code>false</code> otherwise.\n */\nAxisAlignedBoundingBox.equals = function (left, right) {\n  return (\n    left === right ||\n    ((0,_defined_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .Z)(left) &&\n      (0,_defined_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .Z)(right) &&\n      _Cartesian3_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].equals */ .Z.equals(left.center, right.center) &&\n      _Cartesian3_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].equals */ .Z.equals(left.minimum, right.minimum) &&\n      _Cartesian3_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].equals */ .Z.equals(left.maximum, right.maximum))\n  );\n};\n\nvar intersectScratch = new _Cartesian3_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .Z();\n/**\n * Determines which side of a plane a box is located.\n *\n * @param {AxisAlignedBoundingBox} box The bounding box to test.\n * @param {Plane} plane The plane to test against.\n * @returns {Intersect} {@link Intersect.INSIDE} if the entire box is on the side of the plane\n *                      the normal is pointing, {@link Intersect.OUTSIDE} if the entire box is\n *                      on the opposite side, and {@link Intersect.INTERSECTING} if the box\n *                      intersects the plane.\n */\nAxisAlignedBoundingBox.intersectPlane = function (box, plane) {\n  //>>includeStart(\'debug\', pragmas.debug);\n  _Check_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"].defined */ .Z.defined("box", box);\n  _Check_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"].defined */ .Z.defined("plane", plane);\n  //>>includeEnd(\'debug\');\n\n  intersectScratch = _Cartesian3_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].subtract */ .Z.subtract(\n    box.maximum,\n    box.minimum,\n    intersectScratch\n  );\n  var h = _Cartesian3_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].multiplyByScalar */ .Z.multiplyByScalar(intersectScratch, 0.5, intersectScratch); //The positive half diagonal\n  var normal = plane.normal;\n  var e =\n    h.x * Math.abs(normal.x) +\n    h.y * Math.abs(normal.y) +\n    h.z * Math.abs(normal.z);\n  var s = _Cartesian3_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].dot */ .Z.dot(box.center, normal) + plane.distance; //signed distance from center\n\n  if (s - e > 0) {\n    return _Intersect_js__WEBPACK_IMPORTED_MODULE_3__/* ["default"].INSIDE */ .Z.INSIDE;\n  }\n\n  if (s + e < 0) {\n    //Not in front because normals point inward\n    return _Intersect_js__WEBPACK_IMPORTED_MODULE_3__/* ["default"].OUTSIDE */ .Z.OUTSIDE;\n  }\n\n  return _Intersect_js__WEBPACK_IMPORTED_MODULE_3__/* ["default"].INTERSECTING */ .Z.INTERSECTING;\n};\n\n/**\n * Duplicates this AxisAlignedBoundingBox instance.\n *\n * @param {AxisAlignedBoundingBox} [result] The object onto which to store the result.\n * @returns {AxisAlignedBoundingBox} The modified result parameter or a new AxisAlignedBoundingBox instance if one was not provided.\n */\nAxisAlignedBoundingBox.prototype.clone = function (result) {\n  return AxisAlignedBoundingBox.clone(this, result);\n};\n\n/**\n * Determines which side of a plane this box is located.\n *\n * @param {Plane} plane The plane to test against.\n * @returns {Intersect} {@link Intersect.INSIDE} if the entire box is on the side of the plane\n *                      the normal is pointing, {@link Intersect.OUTSIDE} if the entire box is\n *                      on the opposite side, and {@link Intersect.INTERSECTING} if the box\n *                      intersects the plane.\n */\nAxisAlignedBoundingBox.prototype.intersectPlane = function (plane) {\n  return AxisAlignedBoundingBox.intersectPlane(this, plane);\n};\n\n/**\n * Compares this AxisAlignedBoundingBox against the provided AxisAlignedBoundingBox componentwise and returns\n * <code>true</code> if they are equal, <code>false</code> otherwise.\n *\n * @param {AxisAlignedBoundingBox} [right] The right hand side AxisAlignedBoundingBox.\n * @returns {Boolean} <code>true</code> if they are equal, <code>false</code> otherwise.\n */\nAxisAlignedBoundingBox.prototype.equals = function (right) {\n  return AxisAlignedBoundingBox.equals(this, right);\n};\n/* harmony default export */ __webpack_exports__["Z"] = (AxisAlignedBoundingBox);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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d0I7QUFDakQsaURBQWlELHlCQUF5QjtBQUMxRSxtREFBbUQsOEJBQThCO0FBQ2pGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLHdCQUF3QjtBQUNuQyxhQUFhLFNBQVM7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5REFBZSxzQkFBc0IsRUFBQyIsInNvdXJjZXMiOlsid2VicGFjazovL3Z1ZTMtd2VicGFjazUvLi9ub2RlX21vZHVsZXMvY2VzaXVtL1NvdXJjZS9Db3JlL0F4aXNBbGlnbmVkQm91bmRpbmdCb3guanM/MTJiZCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgQ2FydGVzaWFuMyBmcm9tIFwiLi9DYXJ0ZXNpYW4zLmpzXCI7XG5pbXBvcnQgQ2hlY2sgZnJvbSBcIi4vQ2hlY2suanNcIjtcbmltcG9ydCBkZWZhdWx0VmFsdWUgZnJvbSBcIi4vZGVmYXVsdFZhbHVlLmpzXCI7XG5pbXBvcnQgZGVmaW5lZCBmcm9tIFwiLi9kZWZpbmVkLmpzXCI7XG5pbXBvcnQgSW50ZXJzZWN0IGZyb20gXCIuL0ludGVyc2VjdC5qc1wiO1xuXG4vKipcbiAqIENyZWF0ZXMgYW4gaW5zdGFuY2Ugb2YgYW4gQXhpc0FsaWduZWRCb3VuZGluZ0JveCBmcm9tIHRoZSBtaW5pbXVtIGFuZCBtYXhpbXVtIHBvaW50cyBhbG9uZyB0aGUgeCwgeSwgYW5kIHogYXhlcy5cbiAqIEBhbGlhcyBBeGlzQWxpZ25lZEJvdW5kaW5nQm94XG4gKiBAY29uc3RydWN0b3JcbiAqXG4gKiBAcGFyYW0ge0NhcnRlc2lhbjN9IFttaW5pbXVtPUNhcnRlc2lhbjMuWkVST10gVGhlIG1pbmltdW0gcG9pbnQgYWxvbmcgdGhlIHgsIHksIGFuZCB6IGF4ZXMuXG4gKiBAcGFyYW0ge0NhcnRlc2lhbjN9IFttYXhpbXVtPUNhcnRlc2lhbjMuWkVST10gVGhlIG1heGltdW0gcG9pbnQgYWxvbmcgdGhlIHgsIHksIGFuZCB6IGF4ZXMuXG4gKiBAcGFyYW0ge0NhcnRlc2lhbjN9IFtjZW50ZXJdIFRoZSBjZW50ZXIgb2YgdGhlIGJveDsgYXV0b21hdGljYWxseSBjb21wdXRlZCBpZiBub3Qgc3VwcGxpZWQuXG4gKlxuICogQHNlZSBCb3VuZGluZ1NwaGVyZVxuICogQHNlZSBCb3VuZGluZ1JlY3RhbmdsZVxuICovXG5mdW5jdGlvbiBBeGlzQWxpZ25lZEJvdW5kaW5nQm94KG1pbmltdW0sIG1heGltdW0sIGNlbnRlcikge1xuICAvKipcbiAgICogVGhlIG1pbmltdW0gcG9pbnQgZGVmaW5pbmcgdGhlIGJvdW5kaW5nIGJveC5cbiAgICogQHR5cGUge0NhcnRlc2lhbjN9XG4gICAqIEBkZWZhdWx0IHtAbGluayBDYXJ0ZXNpYW4zLlpFUk99XG4gICAqL1xuICB0aGlzLm1pbmltdW0gPSBDYXJ0ZXNpYW4zLmNsb25lKGRlZmF1bHRWYWx1ZShtaW5pbXVtLCBDYXJ0ZXNpYW4zLlpFUk8pKTtcblxuICAvKipcbiAgICogVGhlIG1heGltdW0gcG9pbnQgZGVmaW5pbmcgdGhlIGJvdW5kaW5nIGJveC5cbiAgICogQHR5cGUge0NhcnRlc2lhbjN9XG4gICAqIEBkZWZhdWx0IHtAbGluayBDYXJ0ZXNpYW4zLlpFUk99XG4gICAqL1xuICB0aGlzLm1heGltdW0gPSBDYXJ0ZXNpYW4zLmNsb25lKGRlZmF1bHRWYWx1ZShtYXhpbXVtLCBDYXJ0ZXNpYW4zLlpFUk8pKTtcblxuICAvL0lmIGNlbnRlciB3YXMgbm90IGRlZmluZWQsIGNvbXB1dGUgaXQuXG4gIGlmICghZGVmaW5lZChjZW50ZXIpKSB7XG4gICAgY2VudGVyID0gQ2FydGVzaWFuMy5taWRwb2ludCh0aGlzLm1pbmltdW0sIHRoaXMubWF4aW11bSwgbmV3IENhcnRlc2lhbjMoKSk7XG4gIH0gZWxzZSB7XG4gICAgY2VudGVyID0gQ2FydGVzaWFuMy5jbG9uZShjZW50ZXIpO1xuICB9XG5cbiAgLyoqXG4gICAqIFRoZSBjZW50ZXIgcG9pbnQgb2YgdGhlIGJvdW5kaW5nIGJveC5cbiAgICogQHR5cGUge0NhcnRlc2lhbjN9XG4gICAqL1xuICB0aGlzLmNlbnRlciA9IGNlbnRlcjtcbn1cblxuLyoqXG4gKiBDb21wdXRlcyBhbiBpbnN0YW5jZSBvZiBhbiBBeGlzQWxpZ25lZEJvdW5kaW5nQm94LiBUaGUgYm94IGlzIGRldGVybWluZWQgYnlcbiAqIGZpbmRpbmcgdGhlIHBvaW50cyBzcGFjZWQgdGhlIGZhcnRoZXN0IGFwYXJ0IG9uIHRoZSB4LCB5LCBhbmQgeiBheGVzLlxuICpcbiAqIEBwYXJhbSB7Q2FydGVzaWFuM1tdfSBwb3NpdGlvbnMgTGlzdCBvZiBwb2ludHMgdGhhdCB0aGUgYm91bmRpbmcgYm94IHdpbGwgZW5jbG9zZS4gIEVhY2ggcG9pbnQgbXVzdCBoYXZlIGEgPGNvZGU+eDwvY29kZT4sIDxjb2RlPnk8L2NvZGU+LCBhbmQgPGNvZGU+ejwvY29kZT4gcHJvcGVydGllcy5cbiAqIEBwYXJhbSB7QXhpc0FsaWduZWRCb3VuZGluZ0JveH0gW3Jlc3VsdF0gVGhlIG9iamVjdCBvbnRvIHdoaWNoIHRvIHN0b3JlIHRoZSByZXN1bHQuXG4gKiBAcmV0dXJucyB7QXhpc0FsaWduZWRCb3VuZGluZ0JveH0gVGhlIG1vZGlmaWVkIHJlc3VsdCBwYXJhbWV0ZXIgb3IgYSBuZXcgQXhpc0FsaWduZWRCb3VuZGluZ0JveCBpbnN0YW5jZSBpZiBvbmUgd2FzIG5vdCBwcm92aWRlZC5cbiAqXG4gKiBAZXhhbXBsZVxuICogLy8gQ29tcHV0ZSBhbiBheGlzIGFsaWduZWQgYm91bmRpbmcgYm94IGVuY2xvc2luZyB0d28gcG9pbnRzLlxuICogdmFyIGJveCA9IENlc2l1bS5BeGlzQWxpZ25lZEJvdW5kaW5nQm94LmZyb21Qb2ludHMoW25ldyBDZXNpdW0uQ2FydGVzaWFuMygyLCAwLCAwKSwgbmV3IENlc2l1bS5DYXJ0ZXNpYW4zKC0yLCAwLCAwKV0pO1xuICovXG5BeGlzQWxpZ25lZEJvdW5kaW5nQm94LmZyb21Qb2ludHMgPSBmdW5jdGlvbiAocG9zaXRpb25zLCByZXN1bHQpIHtcbiAgaWYgKCFkZWZpbmVkKHJlc3VsdCkpIHtcbiAgICByZXN1bHQgPSBuZXcgQXhpc0FsaWduZWRCb3VuZGluZ0JveCgpO1xuICB9XG5cbiAgaWYgKCFkZWZpbmVkKHBvc2l0aW9ucykgfHwgcG9zaXRpb25zLmxlbmd0aCA9PT0gMCkge1xuICAgIHJlc3VsdC5taW5pbXVtID0gQ2FydGVzaWFuMy5jbG9uZShDYXJ0ZXNpYW4zLlpFUk8sIHJlc3VsdC5taW5pbXVtKTtcbiAgICByZXN1bHQubWF4aW11bSA9IENhcnRlc2lhbjMuY2xvbmUoQ2FydGVzaWFuMy5aRVJPLCByZXN1bHQubWF4aW11bSk7XG4gICAgcmVzdWx0LmNlbnRlciA9IENhcnRlc2lhbjMuY2xvbmUoQ2FydGVzaWFuMy5aRVJPLCByZXN1bHQuY2VudGVyKTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgdmFyIG1pbmltdW1YID0gcG9zaXRpb25zWzBdLng7XG4gIHZhciBtaW5pbXVtWSA9IHBvc2l0aW9uc1swXS55O1xuICB2YXIgbWluaW11bVogPSBwb3NpdGlvbnNbMF0uejtcblxuICB2YXIgbWF4aW11bVggPSBwb3NpdGlvbnNbMF0ueDtcbiAgdmFyIG1heGltdW1ZID0gcG9zaXRpb25zWzBdLnk7XG4gIHZhciBtYXhpbXVtWiA9IHBvc2l0aW9uc1swXS56O1xuXG4gIHZhciBsZW5ndGggPSBwb3NpdGlvbnMubGVuZ3RoO1xuICBmb3IgKHZhciBpID0gMTsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHAgPSBwb3NpdGlvbnNbaV07XG4gICAgdmFyIHggPSBwLng7XG4gICAgdmFyIHkgPSBwLnk7XG4gICAgdmFyIHogPSBwLno7XG5cbiAgICBtaW5pbXVtWCA9IE1hdGgubWluKHgsIG1pbmltdW1YKTtcbiAgICBtYXhpbXVtWCA9IE1hdGgubWF4KHgsIG1heGltdW1YKTtcbiAgICBtaW5pbXVtWSA9IE1hdGgubWluKHksIG1pbmltdW1ZKTtcbiAgICBtYXhpbXVtWSA9IE1hdGgubWF4KHksIG1heGltdW1ZKTtcbiAgICBtaW5pbXVtWiA9IE1hdGgubWluKHosIG1pbmltdW1aKTtcbiAgICBtYXhpbXVtWiA9IE1hdGgubWF4KHosIG1heGltdW1aKTtcbiAgfVxuXG4gIHZhciBtaW5pbXVtID0gcmVzdWx0Lm1pbmltdW07XG4gIG1pbmltdW0ueCA9IG1pbmltdW1YO1xuICBtaW5pbXVtLnkgPSBtaW5pbXVtWTtcbiAgbWluaW11bS56ID0gbWluaW11bVo7XG5cbiAgdmFyIG1heGltdW0gPSByZXN1bHQubWF4aW11bTtcbiAgbWF4aW11bS54ID0gbWF4aW11bVg7XG4gIG1heGltdW0ueSA9IG1heGltdW1ZO1xuICBtYXhpbXVtLnogPSBtYXhpbXVtWjtcblxuICByZXN1bHQuY2VudGVyID0gQ2FydGVzaWFuMy5taWRwb2ludChtaW5pbXVtLCBtYXhpbXVtLCByZXN1bHQuY2VudGVyKTtcblxuICByZXR1cm4gcmVzdWx0O1xufTtcblxuLyoqXG4gKiBEdXBsaWNhdGVzIGEgQXhpc0FsaWduZWRCb3VuZGluZ0JveCBpbnN0YW5jZS5cbiAqXG4gKiBAcGFyYW0ge0F4aXNBbGlnbmVkQm91bmRpbmdCb3h9IGJveCBUaGUgYm91bmRpbmcgYm94IHRvIGR1cGxpY2F0ZS5cbiAqIEBwYXJhbSB7QXhpc0FsaWduZWRCb3VuZGluZ0JveH0gW3Jlc3VsdF0gVGhlIG9iamVjdCBvbnRvIHdoaWNoIHRvIHN0b3JlIHRoZSByZXN1bHQuXG4gKiBAcmV0dXJucyB7QXhpc0FsaWduZWRCb3VuZGluZ0JveH0gVGhlIG1vZGlmaWVkIHJlc3VsdCBwYXJhbWV0ZXIgb3IgYSBuZXcgQXhpc0FsaWduZWRCb3VuZGluZ0JveCBpbnN0YW5jZSBpZiBub25lIHdhcyBwcm92aWRlZC4gKFJldHVybnMgdW5kZWZpbmVkIGlmIGJveCBpcyB1bmRlZmluZWQpXG4gKi9cbkF4aXNBbGlnbmVkQm91bmRpbmdCb3guY2xvbmUgPSBmdW5jdGlvbiAoYm94LCByZXN1bHQpIHtcbiAgaWYgKCFkZWZpbmVkKGJveCkpIHtcbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG5cbiAgaWYgKCFkZWZpbmVkKHJlc3VsdCkpIHtcbiAgICByZXR1cm4gbmV3IEF4aXNBbGlnbmVkQm91bmRpbmdCb3goYm94Lm1pbmltdW0sIGJveC5tYXhpbXVtLCBib3guY2VudGVyKTtcbiAgfVxuXG4gIHJlc3VsdC5taW5pbXVtID0gQ2FydGVzaWFuMy5jbG9uZShib3gubWluaW11bSwgcmVzdWx0Lm1pbmltdW0pO1xuICByZXN1bHQubWF4aW11bSA9IENhcnRlc2lhbjMuY2xvbmUoYm94Lm1heGltdW0sIHJlc3VsdC5tYXhpbXVtKTtcbiAgcmVzdWx0LmNlbnRlciA9IENhcnRlc2lhbjMuY2xvbmUoYm94LmNlbnRlciwgcmVzdWx0LmNlbnRlcik7XG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG4vKipcbiAqIENvbXBhcmVzIHRoZSBwcm92aWRlZCBBeGlzQWxpZ25lZEJvdW5kaW5nQm94IGNvbXBvbmVudHdpc2UgYW5kIHJldHVybnNcbiAqIDxjb2RlPnRydWU8L2NvZGU+IGlmIHRoZXkgYXJlIGVxdWFsLCA8Y29kZT5mYWxzZTwvY29kZT4gb3RoZXJ3aXNlLlxuICpcbiAqIEBwYXJhbSB7QXhpc0FsaWduZWRCb3VuZGluZ0JveH0gW2xlZnRdIFRoZSBmaXJzdCBBeGlzQWxpZ25lZEJvdW5kaW5nQm94LlxuICogQHBhcmFtIHtBeGlzQWxpZ25lZEJvdW5kaW5nQm94fSBbcmlnaHRdIFRoZSBzZWNvbmQgQXhpc0FsaWduZWRCb3VuZGluZ0JveC5cbiAqIEByZXR1cm5zIHtCb29sZWFufSA8Y29kZT50cnVlPC9jb2RlPiBpZiBsZWZ0IGFuZCByaWdodCBhcmUgZXF1YWwsIDxjb2RlPmZhbHNlPC9jb2RlPiBvdGhlcndpc2UuXG4gKi9cbkF4aXNBbGlnbmVkQm91bmRpbmdCb3guZXF1YWxzID0gZnVuY3Rpb24gKGxlZnQsIHJpZ2h0KSB7XG4gIHJldHVybiAoXG4gICAgbGVmdCA9PT0gcmlnaHQgfHxcbiAgICAoZGVmaW5lZChsZWZ0KSAmJlxuICAgICAgZGVmaW5lZChyaWdodCkgJiZcbiAgICAgIENhcnRlc2lhbjMuZXF1YWxzKGxlZnQuY2VudGVyLCByaWdodC5jZW50ZXIpICYmXG4gICAgICBDYXJ0ZXNpYW4zLmVxdWFscyhsZWZ0Lm1pbmltdW0sIHJpZ2h0Lm1pbmltdW0pICYmXG4gICAgICBDYXJ0ZXNpYW4zLmVxdWFscyhsZWZ0Lm1heGltdW0sIHJpZ2h0Lm1heGltdW0pKVxuICApO1xufTtcblxudmFyIGludGVyc2VjdFNjcmF0Y2ggPSBuZXcgQ2FydGVzaWFuMygpO1xuLyoqXG4gKiBEZXRlcm1pbmVzIHdoaWNoIHNpZGUgb2YgYSBwbGFuZSBhIGJveCBpcyBsb2NhdGVkLlxuICpcbiAqIEBwYXJhbSB7QXhpc0FsaWduZWRCb3VuZGluZ0JveH0gYm94IFRoZSBib3VuZGluZyBib3ggdG8gdGVzdC5cbiAqIEBwYXJhbSB7UGxhbmV9IHBsYW5lIFRoZSBwbGFuZSB0byB0ZXN0IGFnYWluc3QuXG4gKiBAcmV0dXJucyB7SW50ZXJzZWN0fSB7QGxpbmsgSW50ZXJzZWN0LklOU0lERX0gaWYgdGhlIGVudGlyZSBib3ggaXMgb24gdGhlIHNpZGUgb2YgdGhlIHBsYW5lXG4gKiAgICAgICAgICAgICAgICAgICAgICB0aGUgbm9ybWFsIGlzIHBvaW50aW5nLCB7QGxpbmsgSW50ZXJzZWN0Lk9VVFNJREV9IGlmIHRoZSBlbnRpcmUgYm94IGlzXG4gKiAgICAgICAgICAgICAgICAgICAgICBvbiB0aGUgb3Bwb3NpdGUgc2lkZSwgYW5kIHtAbGluayBJbnRlcnNlY3QuSU5URVJTRUNUSU5HfSBpZiB0aGUgYm94XG4gKiAgICAgICAgICAgICAgICAgICAgICBpbnRlcnNlY3RzIHRoZSBwbGFuZS5cbiAqL1xuQXhpc0FsaWduZWRCb3VuZGluZ0JveC5pbnRlcnNlY3RQbGFuZSA9IGZ1bmN0aW9uIChib3gsIHBsYW5lKSB7XG4gIC8vPj5pbmNsdWRlU3RhcnQoJ2RlYnVnJywgcHJhZ21hcy5kZWJ1Zyk7XG4gIENoZWNrLmRlZmluZWQoXCJib3hcIiwgYm94KTtcbiAgQ2hlY2suZGVmaW5lZChcInBsYW5lXCIsIHBsYW5lKTtcbiAgLy8+PmluY2x1ZGVFbmQoJ2RlYnVnJyk7XG5cbiAgaW50ZXJzZWN0U2NyYXRjaCA9IENhcnRlc2lhbjMuc3VidHJhY3QoXG4gICAgYm94Lm1heGltdW0sXG4gICAgYm94Lm1pbmltdW0sXG4gICAgaW50ZXJzZWN0U2NyYXRjaFxuICApO1xuICB2YXIgaCA9IENhcnRlc2lhbjMubXVsdGlwbHlCeVNjYWxhcihpbnRlcnNlY3RTY3JhdGNoLCAwLjUsIGludGVyc2VjdFNjcmF0Y2gpOyAvL1RoZSBwb3NpdGl2ZSBoYWxmIGRpYWdvbmFsXG4gIHZhciBub3JtYWwgPSBwbGFuZS5ub3JtYWw7XG4gIHZhciBlID1cbiAgICBoLnggKiBNYXRoLmFicyhub3JtYWwueCkgK1xuICAgIGgueSAqIE1hdGguYWJzKG5vcm1hbC55KSArXG4gICAgaC56ICogTWF0aC5hYnMobm9ybWFsLnopO1xuICB2YXIgcyA9IENhcnRlc2lhbjMuZG90KGJveC5jZW50ZXIsIG5vcm1hbCkgKyBwbGFuZS5kaXN0YW5jZTsgLy9zaWduZWQgZGlzdGFuY2UgZnJvbSBjZW50ZXJcblxuICBpZiAocyAtIGUgPiAwKSB7XG4gICAgcmV0dXJuIEludGVyc2VjdC5JTlNJREU7XG4gIH1cblxuICBpZiAocyArIGUgPCAwKSB7XG4gICAgLy9Ob3QgaW4gZnJvbnQgYmVjYXVzZSBub3JtYWxzIHBvaW50IGlud2FyZFxuICAgIHJldHVybiBJbnRlcnNlY3QuT1VUU0lERTtcbiAgfVxuXG4gIHJldHVybiBJbnRlcnNlY3QuSU5URVJTRUNUSU5HO1xufTtcblxuLyoqXG4gKiBEdXBsaWNhdGVzIHRoaXMgQXhpc0FsaWduZWRCb3VuZGluZ0JveCBpbnN0YW5jZS5cbiAqXG4gKiBAcGFyYW0ge0F4aXNBbGlnbmVkQm91bmRpbmdCb3h9IFtyZXN1bHRdIFRoZSBvYmplY3Qgb250byB3aGljaCB0byBzdG9yZSB0aGUgcmVzdWx0LlxuICogQHJldHVybnMge0F4aXNBbGlnbmVkQm91bmRpbmdCb3h9IFRoZSBtb2RpZmllZCByZXN1bHQgcGFyYW1ldGVyIG9yIGEgbmV3IEF4aXNBbGlnbmVkQm91bmRpbmdCb3ggaW5zdGFuY2UgaWYgb25lIHdhcyBub3QgcHJvdmlkZWQuXG4gKi9cbkF4aXNBbGlnbmVkQm91bmRpbmdCb3gucHJvdG90eXBlLmNsb25lID0gZnVuY3Rpb24gKHJlc3VsdCkge1xuICByZXR1cm4gQXhpc0FsaWduZWRCb3VuZGluZ0JveC5jbG9uZSh0aGlzLCByZXN1bHQpO1xufTtcblxuLyoqXG4gKiBEZXRlcm1pbmVzIHdoaWNoIHNpZGUgb2YgYSBwbGFuZSB0aGlzIGJveCBpcyBsb2NhdGVkLlxuICpcbiAqIEBwYXJhbSB7UGxhbmV9IHBsYW5lIFRoZSBwbGFuZSB0byB0ZXN0IGFnYWluc3QuXG4gKiBAcmV0dXJucyB7SW50ZXJzZWN0fSB7QGxpbmsgSW50ZXJzZWN0LklOU0lERX0gaWYgdGhlIGVudGlyZSBib3ggaXMgb24gdGhlIHNpZGUgb2YgdGhlIHBsYW5lXG4gKiAgICAgICAgICAgICAgICAgICAgICB0aGUgbm9ybWFsIGlzIHBvaW50aW5nLCB7QGxpbmsgSW50ZXJzZWN0Lk9VVFNJREV9IGlmIHRoZSBlbnRpcmUgYm94IGlzXG4gKiAgICAgICAgICAgICAgICAgICAgICBvbiB0aGUgb3Bwb3NpdGUgc2lkZSwgYW5kIHtAbGluayBJbnRlcnNlY3QuSU5URVJTRUNUSU5HfSBpZiB0aGUgYm94XG4gKiAgICAgICAgICAgICAgICAgICAgICBpbnRlcnNlY3RzIHRoZSBwbGFuZS5cbiAqL1xuQXhpc0FsaWduZWRCb3VuZGluZ0JveC5wcm90b3R5cGUuaW50ZXJzZWN0UGxhbmUgPSBmdW5jdGlvbiAocGxhbmUpIHtcbiAgcmV0dXJuIEF4aXNBbGlnbmVkQm91bmRpbmdCb3guaW50ZXJzZWN0UGxhbmUodGhpcywgcGxhbmUpO1xufTtcblxuLyoqXG4gKiBDb21wYXJlcyB0aGlzIEF4aXNBbGlnbmVkQm91bmRpbmdCb3ggYWdhaW5zdCB0aGUgcHJvdmlkZWQgQXhpc0FsaWduZWRCb3VuZGluZ0JveCBjb21wb25lbnR3aXNlIGFuZCByZXR1cm5zXG4gKiA8Y29kZT50cnVlPC9jb2RlPiBpZiB0aGV5IGFyZSBlcXVhbCwgPGNvZGU+ZmFsc2U8L2NvZGU+IG90aGVyd2lzZS5cbiAqXG4gKiBAcGFyYW0ge0F4aXNBbGlnbmVkQm91bmRpbmdCb3h9IFtyaWdodF0gVGhlIHJpZ2h0IGhhbmQgc2lkZSBBeGlzQWxpZ25lZEJvdW5kaW5nQm94LlxuICogQHJldHVybnMge0Jvb2xlYW59IDxjb2RlPnRydWU8L2NvZGU+IGlmIHRoZXkgYXJlIGVxdWFsLCA8Y29kZT5mYWxzZTwvY29kZT4gb3RoZXJ3aXNlLlxuICovXG5BeGlzQWxpZ25lZEJvdW5kaW5nQm94LnByb3RvdHlwZS5lcXVhbHMgPSBmdW5jdGlvbiAocmlnaHQpIHtcbiAgcmV0dXJuIEF4aXNBbGlnbmVkQm91bmRpbmdCb3guZXF1YWxzKHRoaXMsIHJpZ2h0KTtcbn07XG5leHBvcnQgZGVmYXVsdCBBeGlzQWxpZ25lZEJvdW5kaW5nQm94O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///55829\n')}}]);