"use strict";(self["webpackChunkvue3_webpack5"]=self["webpackChunkvue3_webpack5"]||[]).push([[4004],{25489:function(__unused_webpack___webpack_module__,__webpack_exports__){eval('/**\n * The encoding that is used for a heightmap\n *\n * @enum {Number}\n */\nvar HeightmapEncoding = {\n  /**\n   * No encoding\n   *\n   * @type {Number}\n   * @constant\n   */\n  NONE: 0,\n\n  /**\n   * LERC encoding\n   *\n   * @type {Number}\n   * @constant\n   *\n   * @see {@link https://github.com/Esri/lerc|The LERC specification}\n   */\n  LERC: 1,\n};\n/* harmony default export */ __webpack_exports__["Z"] = (Object.freeze(HeightmapEncoding));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjU0ODkuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBLHlEQUFlLGdDQUFnQyxFQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdnVlMy13ZWJwYWNrNS8uL25vZGVfbW9kdWxlcy9jZXNpdW0vU291cmNlL0NvcmUvSGVpZ2h0bWFwRW5jb2RpbmcuanM/Nzc4MCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIFRoZSBlbmNvZGluZyB0aGF0IGlzIHVzZWQgZm9yIGEgaGVpZ2h0bWFwXG4gKlxuICogQGVudW0ge051bWJlcn1cbiAqL1xudmFyIEhlaWdodG1hcEVuY29kaW5nID0ge1xuICAvKipcbiAgICogTm8gZW5jb2RpbmdcbiAgICpcbiAgICogQHR5cGUge051bWJlcn1cbiAgICogQGNvbnN0YW50XG4gICAqL1xuICBOT05FOiAwLFxuXG4gIC8qKlxuICAgKiBMRVJDIGVuY29kaW5nXG4gICAqXG4gICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAqIEBjb25zdGFudFxuICAgKlxuICAgKiBAc2VlIHtAbGluayBodHRwczovL2dpdGh1Yi5jb20vRXNyaS9sZXJjfFRoZSBMRVJDIHNwZWNpZmljYXRpb259XG4gICAqL1xuICBMRVJDOiAxLFxufTtcbmV4cG9ydCBkZWZhdWx0IE9iamVjdC5mcmVlemUoSGVpZ2h0bWFwRW5jb2RpbmcpO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///25489\n')},57134:function(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__){eval('/* harmony import */ var _ThirdParty_when_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(13222);\n/* harmony import */ var _BoundingSphere_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(48243);\n/* harmony import */ var _Cartesian3_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(60216);\n/* harmony import */ var _Check_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(66553);\n/* harmony import */ var _defaultValue_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(62200);\n/* harmony import */ var _defined_js__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(82982);\n/* harmony import */ var _DeveloperError_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(12572);\n/* harmony import */ var _GeographicProjection_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(39756);\n/* harmony import */ var _HeightmapEncoding_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(25489);\n/* harmony import */ var _HeightmapTessellator_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(25260);\n/* harmony import */ var _Math_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(99417);\n/* harmony import */ var _OrientedBoundingBox_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(25405);\n/* harmony import */ var _Rectangle_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(96190);\n/* harmony import */ var _TaskProcessor_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(2819);\n/* harmony import */ var _TerrainData_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(99978);\n/* harmony import */ var _TerrainEncoding_js__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(41782);\n/* harmony import */ var _TerrainMesh_js__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(13758);\n/* harmony import */ var _TerrainProvider_js__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(1497);\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n/**\n * Terrain data for a single tile where the terrain data is represented as a heightmap.  A heightmap\n * is a rectangular array of heights in row-major order from north to south and west to east.\n *\n * @alias HeightmapTerrainData\n * @constructor\n *\n * @param {Object} options Object with the following properties:\n * @param {Int8Array|Uint8Array|Int16Array|Uint16Array|Int32Array|Uint32Array|Float32Array|Float64Array} options.buffer The buffer containing height data.\n * @param {Number} options.width The width (longitude direction) of the heightmap, in samples.\n * @param {Number} options.height The height (latitude direction) of the heightmap, in samples.\n * @param {Number} [options.childTileMask=15] A bit mask indicating which of this tile\'s four children exist.\n *                 If a child\'s bit is set, geometry will be requested for that tile as well when it\n *                 is needed.  If the bit is cleared, the child tile is not requested and geometry is\n *                 instead upsampled from the parent.  The bit values are as follows:\n *                 <table>\n *                  <tr><th>Bit Position</th><th>Bit Value</th><th>Child Tile</th></tr>\n *                  <tr><td>0</td><td>1</td><td>Southwest</td></tr>\n *                  <tr><td>1</td><td>2</td><td>Southeast</td></tr>\n *                  <tr><td>2</td><td>4</td><td>Northwest</td></tr>\n *                  <tr><td>3</td><td>8</td><td>Northeast</td></tr>\n *                 </table>\n * @param {Uint8Array} [options.waterMask] The water mask included in this terrain data, if any.  A water mask is a square\n *                     Uint8Array or image where a value of 255 indicates water and a value of 0 indicates land.\n *                     Values in between 0 and 255 are allowed as well to smoothly blend between land and water.\n * @param {Object} [options.structure] An object describing the structure of the height data.\n * @param {Number} [options.structure.heightScale=1.0] The factor by which to multiply height samples in order to obtain\n *                 the height above the heightOffset, in meters.  The heightOffset is added to the resulting\n *                 height after multiplying by the scale.\n * @param {Number} [options.structure.heightOffset=0.0] The offset to add to the scaled height to obtain the final\n *                 height in meters.  The offset is added after the height sample is multiplied by the\n *                 heightScale.\n * @param {Number} [options.structure.elementsPerHeight=1] The number of elements in the buffer that make up a single height\n *                 sample.  This is usually 1, indicating that each element is a separate height sample.  If\n *                 it is greater than 1, that number of elements together form the height sample, which is\n *                 computed according to the structure.elementMultiplier and structure.isBigEndian properties.\n * @param {Number} [options.structure.stride=1] The number of elements to skip to get from the first element of\n *                 one height to the first element of the next height.\n * @param {Number} [options.structure.elementMultiplier=256.0] The multiplier used to compute the height value when the\n *                 stride property is greater than 1.  For example, if the stride is 4 and the strideMultiplier\n *                 is 256, the height is computed as follows:\n *                 `height = buffer[index] + buffer[index + 1] * 256 + buffer[index + 2] * 256 * 256 + buffer[index + 3] * 256 * 256 * 256`\n *                 This is assuming that the isBigEndian property is false.  If it is true, the order of the\n *                 elements is reversed.\n * @param {Boolean} [options.structure.isBigEndian=false] Indicates endianness of the elements in the buffer when the\n *                  stride property is greater than 1.  If this property is false, the first element is the\n *                  low-order element.  If it is true, the first element is the high-order element.\n * @param {Number} [options.structure.lowestEncodedHeight] The lowest value that can be stored in the height buffer.  Any heights that are lower\n *                 than this value after encoding with the `heightScale` and `heightOffset` are clamped to this value.  For example, if the height\n *                 buffer is a `Uint16Array`, this value should be 0 because a `Uint16Array` cannot store negative numbers.  If this parameter is\n *                 not specified, no minimum value is enforced.\n * @param {Number} [options.structure.highestEncodedHeight] The highest value that can be stored in the height buffer.  Any heights that are higher\n *                 than this value after encoding with the `heightScale` and `heightOffset` are clamped to this value.  For example, if the height\n *                 buffer is a `Uint16Array`, this value should be `256 * 256 - 1` or 65535 because a `Uint16Array` cannot store numbers larger\n *                 than 65535.  If this parameter is not specified, no maximum value is enforced.\n * @param {HeightmapEncoding} [options.encoding=HeightmapEncoding.NONE] The encoding that is used on the buffer.\n * @param {Boolean} [options.createdByUpsampling=false] True if this instance was created by upsampling another instance;\n *                  otherwise, false.\n *\n *\n * @example\n * var buffer = ...\n * var heightBuffer = new Uint16Array(buffer, 0, that._heightmapWidth * that._heightmapWidth);\n * var childTileMask = new Uint8Array(buffer, heightBuffer.byteLength, 1)[0];\n * var waterMask = new Uint8Array(buffer, heightBuffer.byteLength + 1, buffer.byteLength - heightBuffer.byteLength - 1);\n * var terrainData = new Cesium.HeightmapTerrainData({\n *   buffer : heightBuffer,\n *   width : 65,\n *   height : 65,\n *   childTileMask : childTileMask,\n *   waterMask : waterMask\n * });\n *\n * @see TerrainData\n * @see QuantizedMeshTerrainData\n * @see GoogleEarthEnterpriseTerrainData\n */\nfunction HeightmapTerrainData(options) {\n  //>>includeStart(\'debug\', pragmas.debug);\n  if (!(0,_defined_js__WEBPACK_IMPORTED_MODULE_17__/* ["default"] */ .Z)(options) || !(0,_defined_js__WEBPACK_IMPORTED_MODULE_17__/* ["default"] */ .Z)(options.buffer)) {\n    throw new _DeveloperError_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"] */ .Z("options.buffer is required.");\n  }\n  if (!(0,_defined_js__WEBPACK_IMPORTED_MODULE_17__/* ["default"] */ .Z)(options.width)) {\n    throw new _DeveloperError_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"] */ .Z("options.width is required.");\n  }\n  if (!(0,_defined_js__WEBPACK_IMPORTED_MODULE_17__/* ["default"] */ .Z)(options.height)) {\n    throw new _DeveloperError_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"] */ .Z("options.height is required.");\n  }\n  //>>includeEnd(\'debug\');\n\n  this._buffer = options.buffer;\n  this._width = options.width;\n  this._height = options.height;\n  this._childTileMask = (0,_defaultValue_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .Z)(options.childTileMask, 15);\n  this._encoding = (0,_defaultValue_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .Z)(options.encoding, _HeightmapEncoding_js__WEBPACK_IMPORTED_MODULE_7__/* ["default"].NONE */ .Z.NONE);\n\n  var defaultStructure = _HeightmapTessellator_js__WEBPACK_IMPORTED_MODULE_8__/* ["default"].DEFAULT_STRUCTURE */ .Z.DEFAULT_STRUCTURE;\n  var structure = options.structure;\n  if (!(0,_defined_js__WEBPACK_IMPORTED_MODULE_17__/* ["default"] */ .Z)(structure)) {\n    structure = defaultStructure;\n  } else if (structure !== defaultStructure) {\n    structure.heightScale = (0,_defaultValue_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .Z)(\n      structure.heightScale,\n      defaultStructure.heightScale\n    );\n    structure.heightOffset = (0,_defaultValue_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .Z)(\n      structure.heightOffset,\n      defaultStructure.heightOffset\n    );\n    structure.elementsPerHeight = (0,_defaultValue_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .Z)(\n      structure.elementsPerHeight,\n      defaultStructure.elementsPerHeight\n    );\n    structure.stride = (0,_defaultValue_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .Z)(structure.stride, defaultStructure.stride);\n    structure.elementMultiplier = (0,_defaultValue_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .Z)(\n      structure.elementMultiplier,\n      defaultStructure.elementMultiplier\n    );\n    structure.isBigEndian = (0,_defaultValue_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .Z)(\n      structure.isBigEndian,\n      defaultStructure.isBigEndian\n    );\n  }\n\n  this._structure = structure;\n  this._createdByUpsampling = (0,_defaultValue_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .Z)(options.createdByUpsampling, false);\n  this._waterMask = options.waterMask;\n\n  this._skirtHeight = undefined;\n  this._bufferType =\n    this._encoding === _HeightmapEncoding_js__WEBPACK_IMPORTED_MODULE_7__/* ["default"].LERC */ .Z.LERC\n      ? Float32Array\n      : this._buffer.constructor;\n  this._mesh = undefined;\n}\n\nObject.defineProperties(HeightmapTerrainData.prototype, {\n  /**\n   * An array of credits for this tile.\n   * @memberof HeightmapTerrainData.prototype\n   * @type {Credit[]}\n   */\n  credits: {\n    get: function () {\n      return undefined;\n    },\n  },\n  /**\n   * The water mask included in this terrain data, if any.  A water mask is a square\n   * Uint8Array or image where a value of 255 indicates water and a value of 0 indicates land.\n   * Values in between 0 and 255 are allowed as well to smoothly blend between land and water.\n   * @memberof HeightmapTerrainData.prototype\n   * @type {Uint8Array|HTMLImageElement|HTMLCanvasElement}\n   */\n  waterMask: {\n    get: function () {\n      return this._waterMask;\n    },\n  },\n\n  childTileMask: {\n    get: function () {\n      return this._childTileMask;\n    },\n  },\n});\n\nvar createMeshTaskName = "createVerticesFromHeightmap";\nvar createMeshTaskProcessorNoThrottle = new _TaskProcessor_js__WEBPACK_IMPORTED_MODULE_12__/* ["default"] */ .Z(createMeshTaskName);\nvar createMeshTaskProcessorThrottle = new _TaskProcessor_js__WEBPACK_IMPORTED_MODULE_12__/* ["default"] */ .Z(\n  createMeshTaskName,\n  _TerrainData_js__WEBPACK_IMPORTED_MODULE_13__/* ["default"].maximumAsynchronousTasks */ .Z.maximumAsynchronousTasks\n);\n\n/**\n * Creates a {@link TerrainMesh} from this terrain data.\n *\n * @private\n *\n * @param {Object} options Object with the following properties:\n * @param {TilingScheme} options.tilingScheme The tiling scheme to which this tile belongs.\n * @param {Number} options.x The X coordinate of the tile for which to create the terrain data.\n * @param {Number} options.y The Y coordinate of the tile for which to create the terrain data.\n * @param {Number} options.level The level of the tile for which to create the terrain data.\n * @param {Number} [options.exaggeration=1.0] The scale used to exaggerate the terrain.\n * @param {Number} [options.exaggerationRelativeHeight=0.0] The height relative to which terrain is exaggerated.\n * @param {Boolean} [options.throttle=true] If true, indicates that this operation will need to be retried if too many asynchronous mesh creations are already in progress.\n * @returns {Promise.<TerrainMesh>|undefined} A promise for the terrain mesh, or undefined if too many\n *          asynchronous mesh creations are already in progress and the operation should\n *          be retried later.\n */\nHeightmapTerrainData.prototype.createMesh = function (options) {\n  options = (0,_defaultValue_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .Z)(options, _defaultValue_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"].EMPTY_OBJECT */ .Z.EMPTY_OBJECT);\n\n  //>>includeStart(\'debug\', pragmas.debug);\n  _Check_js__WEBPACK_IMPORTED_MODULE_3__/* ["default"].typeOf.object */ .Z.typeOf.object("options.tilingScheme", options.tilingScheme);\n  _Check_js__WEBPACK_IMPORTED_MODULE_3__/* ["default"].typeOf.number */ .Z.typeOf.number("options.x", options.x);\n  _Check_js__WEBPACK_IMPORTED_MODULE_3__/* ["default"].typeOf.number */ .Z.typeOf.number("options.y", options.y);\n  _Check_js__WEBPACK_IMPORTED_MODULE_3__/* ["default"].typeOf.number */ .Z.typeOf.number("options.level", options.level);\n  //>>includeEnd(\'debug\');\n\n  var tilingScheme = options.tilingScheme;\n  var x = options.x;\n  var y = options.y;\n  var level = options.level;\n  var exaggeration = (0,_defaultValue_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .Z)(options.exaggeration, 1.0);\n  var exaggerationRelativeHeight = (0,_defaultValue_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .Z)(\n    options.exaggerationRelativeHeight,\n    0.0\n  );\n  var throttle = (0,_defaultValue_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .Z)(options.throttle, true);\n\n  var ellipsoid = tilingScheme.ellipsoid;\n  var nativeRectangle = tilingScheme.tileXYToNativeRectangle(x, y, level);\n  var rectangle = tilingScheme.tileXYToRectangle(x, y, level);\n\n  // Compute the center of the tile for RTC rendering.\n  var center = ellipsoid.cartographicToCartesian(_Rectangle_js__WEBPACK_IMPORTED_MODULE_11__/* ["default"].center */ .Z.center(rectangle));\n\n  var structure = this._structure;\n\n  var levelZeroMaxError = _TerrainProvider_js__WEBPACK_IMPORTED_MODULE_16__/* ["default"].getEstimatedLevelZeroGeometricErrorForAHeightmap */ .Z.getEstimatedLevelZeroGeometricErrorForAHeightmap(\n    ellipsoid,\n    this._width,\n    tilingScheme.getNumberOfXTilesAtLevel(0)\n  );\n  var thisLevelMaxError = levelZeroMaxError / (1 << level);\n  this._skirtHeight = Math.min(thisLevelMaxError * 4.0, 1000.0);\n\n  var createMeshTaskProcessor = throttle\n    ? createMeshTaskProcessorThrottle\n    : createMeshTaskProcessorNoThrottle;\n\n  var verticesPromise = createMeshTaskProcessor.scheduleTask({\n    heightmap: this._buffer,\n    structure: structure,\n    includeWebMercatorT: true,\n    width: this._width,\n    height: this._height,\n    nativeRectangle: nativeRectangle,\n    rectangle: rectangle,\n    relativeToCenter: center,\n    ellipsoid: ellipsoid,\n    skirtHeight: this._skirtHeight,\n    isGeographic: tilingScheme.projection instanceof _GeographicProjection_js__WEBPACK_IMPORTED_MODULE_6__/* ["default"] */ .Z,\n    exaggeration: exaggeration,\n    exaggerationRelativeHeight: exaggerationRelativeHeight,\n    encoding: this._encoding,\n  });\n\n  if (!(0,_defined_js__WEBPACK_IMPORTED_MODULE_17__/* ["default"] */ .Z)(verticesPromise)) {\n    // Postponed\n    return undefined;\n  }\n\n  var that = this;\n  return (0,_ThirdParty_when_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .Z)(verticesPromise, function (result) {\n    var indicesAndEdges;\n    if (that._skirtHeight > 0.0) {\n      indicesAndEdges = _TerrainProvider_js__WEBPACK_IMPORTED_MODULE_16__/* ["default"].getRegularGridAndSkirtIndicesAndEdgeIndices */ .Z.getRegularGridAndSkirtIndicesAndEdgeIndices(\n        result.gridWidth,\n        result.gridHeight\n      );\n    } else {\n      indicesAndEdges = _TerrainProvider_js__WEBPACK_IMPORTED_MODULE_16__/* ["default"].getRegularGridIndicesAndEdgeIndices */ .Z.getRegularGridIndicesAndEdgeIndices(\n        result.gridWidth,\n        result.gridHeight\n      );\n    }\n\n    var vertexCountWithoutSkirts = result.gridWidth * result.gridHeight;\n\n    // Clone complex result objects because the transfer from the web worker\n    // has stripped them down to JSON-style objects.\n    that._mesh = new _TerrainMesh_js__WEBPACK_IMPORTED_MODULE_15__/* ["default"] */ .Z(\n      center,\n      new Float32Array(result.vertices),\n      indicesAndEdges.indices,\n      indicesAndEdges.indexCountWithoutSkirts,\n      vertexCountWithoutSkirts,\n      result.minimumHeight,\n      result.maximumHeight,\n      _BoundingSphere_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"].clone */ .Z.clone(result.boundingSphere3D),\n      _Cartesian3_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"].clone */ .Z.clone(result.occludeePointInScaledSpace),\n      result.numberOfAttributes,\n      _OrientedBoundingBox_js__WEBPACK_IMPORTED_MODULE_10__/* ["default"].clone */ .Z.clone(result.orientedBoundingBox),\n      _TerrainEncoding_js__WEBPACK_IMPORTED_MODULE_14__/* ["default"].clone */ .Z.clone(result.encoding),\n      indicesAndEdges.westIndicesSouthToNorth,\n      indicesAndEdges.southIndicesEastToWest,\n      indicesAndEdges.eastIndicesNorthToSouth,\n      indicesAndEdges.northIndicesWestToEast\n    );\n\n    // Free memory received from server after mesh is created.\n    that._buffer = undefined;\n    return that._mesh;\n  });\n};\n\n/**\n * @param {Object} options Object with the following properties:\n * @param {TilingScheme} options.tilingScheme The tiling scheme to which this tile belongs.\n * @param {Number} options.x The X coordinate of the tile for which to create the terrain data.\n * @param {Number} options.y The Y coordinate of the tile for which to create the terrain data.\n * @param {Number} options.level The level of the tile for which to create the terrain data.\n * @param {Number} [options.exaggeration=1.0] The scale used to exaggerate the terrain.\n * @param {Number} [options.exaggerationRelativeHeight=0.0] The height relative to which terrain is exaggerated.\n *\n * @private\n */\nHeightmapTerrainData.prototype._createMeshSync = function (options) {\n  //>>includeStart(\'debug\', pragmas.debug);\n  _Check_js__WEBPACK_IMPORTED_MODULE_3__/* ["default"].typeOf.object */ .Z.typeOf.object("options.tilingScheme", options.tilingScheme);\n  _Check_js__WEBPACK_IMPORTED_MODULE_3__/* ["default"].typeOf.number */ .Z.typeOf.number("options.x", options.x);\n  _Check_js__WEBPACK_IMPORTED_MODULE_3__/* ["default"].typeOf.number */ .Z.typeOf.number("options.y", options.y);\n  _Check_js__WEBPACK_IMPORTED_MODULE_3__/* ["default"].typeOf.number */ .Z.typeOf.number("options.level", options.level);\n  //>>includeEnd(\'debug\');\n\n  var tilingScheme = options.tilingScheme;\n  var x = options.x;\n  var y = options.y;\n  var level = options.level;\n  var exaggeration = (0,_defaultValue_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .Z)(options.exaggeration, 1.0);\n  var exaggerationRelativeHeight = (0,_defaultValue_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .Z)(\n    options.exaggerationRelativeHeight,\n    0.0\n  );\n\n  var ellipsoid = tilingScheme.ellipsoid;\n  var nativeRectangle = tilingScheme.tileXYToNativeRectangle(x, y, level);\n  var rectangle = tilingScheme.tileXYToRectangle(x, y, level);\n\n  // Compute the center of the tile for RTC rendering.\n  var center = ellipsoid.cartographicToCartesian(_Rectangle_js__WEBPACK_IMPORTED_MODULE_11__/* ["default"].center */ .Z.center(rectangle));\n\n  var structure = this._structure;\n\n  var levelZeroMaxError = _TerrainProvider_js__WEBPACK_IMPORTED_MODULE_16__/* ["default"].getEstimatedLevelZeroGeometricErrorForAHeightmap */ .Z.getEstimatedLevelZeroGeometricErrorForAHeightmap(\n    ellipsoid,\n    this._width,\n    tilingScheme.getNumberOfXTilesAtLevel(0)\n  );\n  var thisLevelMaxError = levelZeroMaxError / (1 << level);\n  this._skirtHeight = Math.min(thisLevelMaxError * 4.0, 1000.0);\n\n  var result = _HeightmapTessellator_js__WEBPACK_IMPORTED_MODULE_8__/* ["default"].computeVertices */ .Z.computeVertices({\n    heightmap: this._buffer,\n    structure: structure,\n    includeWebMercatorT: true,\n    width: this._width,\n    height: this._height,\n    nativeRectangle: nativeRectangle,\n    rectangle: rectangle,\n    relativeToCenter: center,\n    ellipsoid: ellipsoid,\n    skirtHeight: this._skirtHeight,\n    isGeographic: tilingScheme.projection instanceof _GeographicProjection_js__WEBPACK_IMPORTED_MODULE_6__/* ["default"] */ .Z,\n    exaggeration: exaggeration,\n    exaggerationRelativeHeight: exaggerationRelativeHeight,\n  });\n\n  // Free memory received from server after mesh is created.\n  this._buffer = undefined;\n\n  var indicesAndEdges;\n  if (this._skirtHeight > 0.0) {\n    indicesAndEdges = _TerrainProvider_js__WEBPACK_IMPORTED_MODULE_16__/* ["default"].getRegularGridAndSkirtIndicesAndEdgeIndices */ .Z.getRegularGridAndSkirtIndicesAndEdgeIndices(\n      this._width,\n      this._height\n    );\n  } else {\n    indicesAndEdges = _TerrainProvider_js__WEBPACK_IMPORTED_MODULE_16__/* ["default"].getRegularGridIndicesAndEdgeIndices */ .Z.getRegularGridIndicesAndEdgeIndices(\n      this._width,\n      this._height\n    );\n  }\n\n  var vertexCountWithoutSkirts = result.gridWidth * result.gridHeight;\n\n  // No need to clone here (as we do in the async version) because the result\n  // is not coming from a web worker.\n  this._mesh = new _TerrainMesh_js__WEBPACK_IMPORTED_MODULE_15__/* ["default"] */ .Z(\n    center,\n    result.vertices,\n    indicesAndEdges.indices,\n    indicesAndEdges.indexCountWithoutSkirts,\n    vertexCountWithoutSkirts,\n    result.minimumHeight,\n    result.maximumHeight,\n    result.boundingSphere3D,\n    result.occludeePointInScaledSpace,\n    result.encoding.stride,\n    result.orientedBoundingBox,\n    result.encoding,\n    indicesAndEdges.westIndicesSouthToNorth,\n    indicesAndEdges.southIndicesEastToWest,\n    indicesAndEdges.eastIndicesNorthToSouth,\n    indicesAndEdges.northIndicesWestToEast\n  );\n\n  return this._mesh;\n};\n\n/**\n * Computes the terrain height at a specified longitude and latitude.\n *\n * @param {Rectangle} rectangle The rectangle covered by this terrain data.\n * @param {Number} longitude The longitude in radians.\n * @param {Number} latitude The latitude in radians.\n * @returns {Number} The terrain height at the specified position.  If the position\n *          is outside the rectangle, this method will extrapolate the height, which is likely to be wildly\n *          incorrect for positions far outside the rectangle.\n */\nHeightmapTerrainData.prototype.interpolateHeight = function (\n  rectangle,\n  longitude,\n  latitude\n) {\n  var width = this._width;\n  var height = this._height;\n\n  var structure = this._structure;\n  var stride = structure.stride;\n  var elementsPerHeight = structure.elementsPerHeight;\n  var elementMultiplier = structure.elementMultiplier;\n  var isBigEndian = structure.isBigEndian;\n  var heightOffset = structure.heightOffset;\n  var heightScale = structure.heightScale;\n\n  var isMeshCreated = (0,_defined_js__WEBPACK_IMPORTED_MODULE_17__/* ["default"] */ .Z)(this._mesh);\n  var isLERCEncoding = this._encoding === _HeightmapEncoding_js__WEBPACK_IMPORTED_MODULE_7__/* ["default"].LERC */ .Z.LERC;\n  var isInterpolationImpossible = !isMeshCreated && isLERCEncoding;\n  if (isInterpolationImpossible) {\n    // We can\'t interpolate using the buffer because it\'s LERC encoded\n    //  so please call createMesh() first and interpolate using the mesh;\n    //  as mesh creation will decode the LERC buffer\n    return undefined;\n  }\n\n  var heightSample;\n  if (isMeshCreated) {\n    var buffer = this._mesh.vertices;\n    var encoding = this._mesh.encoding;\n    heightSample = interpolateMeshHeight(\n      buffer,\n      encoding,\n      heightOffset,\n      heightScale,\n      rectangle,\n      width,\n      height,\n      longitude,\n      latitude\n    );\n  } else {\n    heightSample = interpolateHeight(\n      this._buffer,\n      elementsPerHeight,\n      elementMultiplier,\n      stride,\n      isBigEndian,\n      rectangle,\n      width,\n      height,\n      longitude,\n      latitude\n    );\n    heightSample = heightSample * heightScale + heightOffset;\n  }\n\n  return heightSample;\n};\n\n/**\n * Upsamples this terrain data for use by a descendant tile.  The resulting instance will contain a subset of the\n * height samples in this instance, interpolated if necessary.\n *\n * @param {TilingScheme} tilingScheme The tiling scheme of this terrain data.\n * @param {Number} thisX The X coordinate of this tile in the tiling scheme.\n * @param {Number} thisY The Y coordinate of this tile in the tiling scheme.\n * @param {Number} thisLevel The level of this tile in the tiling scheme.\n * @param {Number} descendantX The X coordinate within the tiling scheme of the descendant tile for which we are upsampling.\n * @param {Number} descendantY The Y coordinate within the tiling scheme of the descendant tile for which we are upsampling.\n * @param {Number} descendantLevel The level within the tiling scheme of the descendant tile for which we are upsampling.\n * @returns {Promise.<HeightmapTerrainData>|undefined} A promise for upsampled heightmap terrain data for the descendant tile,\n *          or undefined if too many asynchronous upsample operations are in progress and the request has been\n *          deferred.\n */\nHeightmapTerrainData.prototype.upsample = function (\n  tilingScheme,\n  thisX,\n  thisY,\n  thisLevel,\n  descendantX,\n  descendantY,\n  descendantLevel\n) {\n  //>>includeStart(\'debug\', pragmas.debug);\n  if (!(0,_defined_js__WEBPACK_IMPORTED_MODULE_17__/* ["default"] */ .Z)(tilingScheme)) {\n    throw new _DeveloperError_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"] */ .Z("tilingScheme is required.");\n  }\n  if (!(0,_defined_js__WEBPACK_IMPORTED_MODULE_17__/* ["default"] */ .Z)(thisX)) {\n    throw new _DeveloperError_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"] */ .Z("thisX is required.");\n  }\n  if (!(0,_defined_js__WEBPACK_IMPORTED_MODULE_17__/* ["default"] */ .Z)(thisY)) {\n    throw new _DeveloperError_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"] */ .Z("thisY is required.");\n  }\n  if (!(0,_defined_js__WEBPACK_IMPORTED_MODULE_17__/* ["default"] */ .Z)(thisLevel)) {\n    throw new _DeveloperError_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"] */ .Z("thisLevel is required.");\n  }\n  if (!(0,_defined_js__WEBPACK_IMPORTED_MODULE_17__/* ["default"] */ .Z)(descendantX)) {\n    throw new _DeveloperError_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"] */ .Z("descendantX is required.");\n  }\n  if (!(0,_defined_js__WEBPACK_IMPORTED_MODULE_17__/* ["default"] */ .Z)(descendantY)) {\n    throw new _DeveloperError_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"] */ .Z("descendantY is required.");\n  }\n  if (!(0,_defined_js__WEBPACK_IMPORTED_MODULE_17__/* ["default"] */ .Z)(descendantLevel)) {\n    throw new _DeveloperError_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"] */ .Z("descendantLevel is required.");\n  }\n  var levelDifference = descendantLevel - thisLevel;\n  if (levelDifference > 1) {\n    throw new _DeveloperError_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"] */ .Z(\n      "Upsampling through more than one level at a time is not currently supported."\n    );\n  }\n  //>>includeEnd(\'debug\');\n\n  var meshData = this._mesh;\n  if (!(0,_defined_js__WEBPACK_IMPORTED_MODULE_17__/* ["default"] */ .Z)(meshData)) {\n    return undefined;\n  }\n\n  var width = this._width;\n  var height = this._height;\n  var structure = this._structure;\n  var stride = structure.stride;\n\n  var heights = new this._bufferType(width * height * stride);\n\n  var buffer = meshData.vertices;\n  var encoding = meshData.encoding;\n\n  // PERFORMANCE_IDEA: don\'t recompute these rectangles - the caller already knows them.\n  var sourceRectangle = tilingScheme.tileXYToRectangle(thisX, thisY, thisLevel);\n  var destinationRectangle = tilingScheme.tileXYToRectangle(\n    descendantX,\n    descendantY,\n    descendantLevel\n  );\n\n  var heightOffset = structure.heightOffset;\n  var heightScale = structure.heightScale;\n\n  var elementsPerHeight = structure.elementsPerHeight;\n  var elementMultiplier = structure.elementMultiplier;\n  var isBigEndian = structure.isBigEndian;\n\n  var divisor = Math.pow(elementMultiplier, elementsPerHeight - 1);\n\n  for (var j = 0; j < height; ++j) {\n    var latitude = _Math_js__WEBPACK_IMPORTED_MODULE_9__/* ["default"].lerp */ .Z.lerp(\n      destinationRectangle.north,\n      destinationRectangle.south,\n      j / (height - 1)\n    );\n    for (var i = 0; i < width; ++i) {\n      var longitude = _Math_js__WEBPACK_IMPORTED_MODULE_9__/* ["default"].lerp */ .Z.lerp(\n        destinationRectangle.west,\n        destinationRectangle.east,\n        i / (width - 1)\n      );\n      var heightSample = interpolateMeshHeight(\n        buffer,\n        encoding,\n        heightOffset,\n        heightScale,\n        sourceRectangle,\n        width,\n        height,\n        longitude,\n        latitude\n      );\n\n      // Use conditionals here instead of Math.min and Math.max so that an undefined\n      // lowestEncodedHeight or highestEncodedHeight has no effect.\n      heightSample =\n        heightSample < structure.lowestEncodedHeight\n          ? structure.lowestEncodedHeight\n          : heightSample;\n      heightSample =\n        heightSample > structure.highestEncodedHeight\n          ? structure.highestEncodedHeight\n          : heightSample;\n\n      setHeight(\n        heights,\n        elementsPerHeight,\n        elementMultiplier,\n        divisor,\n        stride,\n        isBigEndian,\n        j * width + i,\n        heightSample\n      );\n    }\n  }\n\n  return new HeightmapTerrainData({\n    buffer: heights,\n    width: width,\n    height: height,\n    childTileMask: 0,\n    structure: this._structure,\n    createdByUpsampling: true,\n  });\n};\n\n/**\n * Determines if a given child tile is available, based on the\n * {@link HeightmapTerrainData.childTileMask}.  The given child tile coordinates are assumed\n * to be one of the four children of this tile.  If non-child tile coordinates are\n * given, the availability of the southeast child tile is returned.\n *\n * @param {Number} thisX The tile X coordinate of this (the parent) tile.\n * @param {Number} thisY The tile Y coordinate of this (the parent) tile.\n * @param {Number} childX The tile X coordinate of the child tile to check for availability.\n * @param {Number} childY The tile Y coordinate of the child tile to check for availability.\n * @returns {Boolean} True if the child tile is available; otherwise, false.\n */\nHeightmapTerrainData.prototype.isChildAvailable = function (\n  thisX,\n  thisY,\n  childX,\n  childY\n) {\n  //>>includeStart(\'debug\', pragmas.debug);\n  if (!(0,_defined_js__WEBPACK_IMPORTED_MODULE_17__/* ["default"] */ .Z)(thisX)) {\n    throw new _DeveloperError_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"] */ .Z("thisX is required.");\n  }\n  if (!(0,_defined_js__WEBPACK_IMPORTED_MODULE_17__/* ["default"] */ .Z)(thisY)) {\n    throw new _DeveloperError_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"] */ .Z("thisY is required.");\n  }\n  if (!(0,_defined_js__WEBPACK_IMPORTED_MODULE_17__/* ["default"] */ .Z)(childX)) {\n    throw new _DeveloperError_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"] */ .Z("childX is required.");\n  }\n  if (!(0,_defined_js__WEBPACK_IMPORTED_MODULE_17__/* ["default"] */ .Z)(childY)) {\n    throw new _DeveloperError_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"] */ .Z("childY is required.");\n  }\n  //>>includeEnd(\'debug\');\n\n  var bitNumber = 2; // northwest child\n  if (childX !== thisX * 2) {\n    ++bitNumber; // east child\n  }\n  if (childY !== thisY * 2) {\n    bitNumber -= 2; // south child\n  }\n\n  return (this._childTileMask & (1 << bitNumber)) !== 0;\n};\n\n/**\n * Gets a value indicating whether or not this terrain data was created by upsampling lower resolution\n * terrain data.  If this value is false, the data was obtained from some other source, such\n * as by downloading it from a remote server.  This method should return true for instances\n * returned from a call to {@link HeightmapTerrainData#upsample}.\n *\n * @returns {Boolean} True if this instance was created by upsampling; otherwise, false.\n */\nHeightmapTerrainData.prototype.wasCreatedByUpsampling = function () {\n  return this._createdByUpsampling;\n};\n\nfunction interpolateHeight(\n  sourceHeights,\n  elementsPerHeight,\n  elementMultiplier,\n  stride,\n  isBigEndian,\n  sourceRectangle,\n  width,\n  height,\n  longitude,\n  latitude\n) {\n  var fromWest =\n    ((longitude - sourceRectangle.west) * (width - 1)) /\n    (sourceRectangle.east - sourceRectangle.west);\n  var fromSouth =\n    ((latitude - sourceRectangle.south) * (height - 1)) /\n    (sourceRectangle.north - sourceRectangle.south);\n\n  var westInteger = fromWest | 0;\n  var eastInteger = westInteger + 1;\n  if (eastInteger >= width) {\n    eastInteger = width - 1;\n    westInteger = width - 2;\n  }\n\n  var southInteger = fromSouth | 0;\n  var northInteger = southInteger + 1;\n  if (northInteger >= height) {\n    northInteger = height - 1;\n    southInteger = height - 2;\n  }\n\n  var dx = fromWest - westInteger;\n  var dy = fromSouth - southInteger;\n\n  southInteger = height - 1 - southInteger;\n  northInteger = height - 1 - northInteger;\n\n  var southwestHeight = getHeight(\n    sourceHeights,\n    elementsPerHeight,\n    elementMultiplier,\n    stride,\n    isBigEndian,\n    southInteger * width + westInteger\n  );\n  var southeastHeight = getHeight(\n    sourceHeights,\n    elementsPerHeight,\n    elementMultiplier,\n    stride,\n    isBigEndian,\n    southInteger * width + eastInteger\n  );\n  var northwestHeight = getHeight(\n    sourceHeights,\n    elementsPerHeight,\n    elementMultiplier,\n    stride,\n    isBigEndian,\n    northInteger * width + westInteger\n  );\n  var northeastHeight = getHeight(\n    sourceHeights,\n    elementsPerHeight,\n    elementMultiplier,\n    stride,\n    isBigEndian,\n    northInteger * width + eastInteger\n  );\n\n  return triangleInterpolateHeight(\n    dx,\n    dy,\n    southwestHeight,\n    southeastHeight,\n    northwestHeight,\n    northeastHeight\n  );\n}\n\nfunction interpolateMeshHeight(\n  buffer,\n  encoding,\n  heightOffset,\n  heightScale,\n  sourceRectangle,\n  width,\n  height,\n  longitude,\n  latitude\n) {\n  // returns a height encoded according to the structure\'s heightScale and heightOffset.\n  var fromWest =\n    ((longitude - sourceRectangle.west) * (width - 1)) /\n    (sourceRectangle.east - sourceRectangle.west);\n  var fromSouth =\n    ((latitude - sourceRectangle.south) * (height - 1)) /\n    (sourceRectangle.north - sourceRectangle.south);\n\n  var westInteger = fromWest | 0;\n  var eastInteger = westInteger + 1;\n  if (eastInteger >= width) {\n    eastInteger = width - 1;\n    westInteger = width - 2;\n  }\n\n  var southInteger = fromSouth | 0;\n  var northInteger = southInteger + 1;\n  if (northInteger >= height) {\n    northInteger = height - 1;\n    southInteger = height - 2;\n  }\n\n  var dx = fromWest - westInteger;\n  var dy = fromSouth - southInteger;\n\n  southInteger = height - 1 - southInteger;\n  northInteger = height - 1 - northInteger;\n\n  var southwestHeight =\n    (encoding.decodeHeight(buffer, southInteger * width + westInteger) -\n      heightOffset) /\n    heightScale;\n  var southeastHeight =\n    (encoding.decodeHeight(buffer, southInteger * width + eastInteger) -\n      heightOffset) /\n    heightScale;\n  var northwestHeight =\n    (encoding.decodeHeight(buffer, northInteger * width + westInteger) -\n      heightOffset) /\n    heightScale;\n  var northeastHeight =\n    (encoding.decodeHeight(buffer, northInteger * width + eastInteger) -\n      heightOffset) /\n    heightScale;\n\n  return triangleInterpolateHeight(\n    dx,\n    dy,\n    southwestHeight,\n    southeastHeight,\n    northwestHeight,\n    northeastHeight\n  );\n}\n\nfunction triangleInterpolateHeight(\n  dX,\n  dY,\n  southwestHeight,\n  southeastHeight,\n  northwestHeight,\n  northeastHeight\n) {\n  // The HeightmapTessellator bisects the quad from southwest to northeast.\n  if (dY < dX) {\n    // Lower right triangle\n    return (\n      southwestHeight +\n      dX * (southeastHeight - southwestHeight) +\n      dY * (northeastHeight - southeastHeight)\n    );\n  }\n\n  // Upper left triangle\n  return (\n    southwestHeight +\n    dX * (northeastHeight - northwestHeight) +\n    dY * (northwestHeight - southwestHeight)\n  );\n}\n\nfunction getHeight(\n  heights,\n  elementsPerHeight,\n  elementMultiplier,\n  stride,\n  isBigEndian,\n  index\n) {\n  index *= stride;\n\n  var height = 0;\n  var i;\n\n  if (isBigEndian) {\n    for (i = 0; i < elementsPerHeight; ++i) {\n      height = height * elementMultiplier + heights[index + i];\n    }\n  } else {\n    for (i = elementsPerHeight - 1; i >= 0; --i) {\n      height = height * elementMultiplier + heights[index + i];\n    }\n  }\n\n  return height;\n}\n\nfunction setHeight(\n  heights,\n  elementsPerHeight,\n  elementMultiplier,\n  divisor,\n  stride,\n  isBigEndian,\n  index,\n  height\n) {\n  index *= stride;\n\n  var i;\n  if (isBigEndian) {\n    for (i = 0; i < elementsPerHeight - 1; ++i) {\n      heights[index + i] = (height / divisor) | 0;\n      height -= heights[index + i] * divisor;\n      divisor /= elementMultiplier;\n    }\n  } else {\n    for (i = elementsPerHeight - 1; i > 0; --i) {\n      heights[index + i] = (height / divisor) | 0;\n      height -= heights[index + i] * divisor;\n      divisor /= elementMultiplier;\n    }\n  }\n  heights[index + i] = height;\n}\n/* harmony default export */ __webpack_exports__["Z"] = (HeightmapTerrainData);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLGdCQUFnQix1QkFBdUI7QUFDdkM7QUFDQTtBQUNBLElBQUk7QUFDSixvQ0FBb0MsUUFBUTtBQUM1QztBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxnQkFBZ0IsMkJBQTJCO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKLG9DQUFvQyxPQUFPO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseURBQWUsb0JBQW9CLEVBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly92dWUzLXdlYnBhY2s1Ly4vbm9kZV9tb2R1bGVzL2Nlc2l1bS9Tb3VyY2UvQ29yZS9IZWlnaHRtYXBUZXJyYWluRGF0YS5qcz8xNWQyIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB3aGVuIGZyb20gXCIuLi9UaGlyZFBhcnR5L3doZW4uanNcIjtcbmltcG9ydCBCb3VuZGluZ1NwaGVyZSBmcm9tIFwiLi9Cb3VuZGluZ1NwaGVyZS5qc1wiO1xuaW1wb3J0IENhcnRlc2lhbjMgZnJvbSBcIi4vQ2FydGVzaWFuMy5qc1wiO1xuaW1wb3J0IENoZWNrIGZyb20gXCIuL0NoZWNrLmpzXCI7XG5pbXBvcnQgZGVmYXVsdFZhbHVlIGZyb20gXCIuL2RlZmF1bHRWYWx1ZS5qc1wiO1xuaW1wb3J0IGRlZmluZWQgZnJvbSBcIi4vZGVmaW5lZC5qc1wiO1xuaW1wb3J0IERldmVsb3BlckVycm9yIGZyb20gXCIuL0RldmVsb3BlckVycm9yLmpzXCI7XG5pbXBvcnQgR2VvZ3JhcGhpY1Byb2plY3Rpb24gZnJvbSBcIi4vR2VvZ3JhcGhpY1Byb2plY3Rpb24uanNcIjtcbmltcG9ydCBIZWlnaHRtYXBFbmNvZGluZyBmcm9tIFwiLi9IZWlnaHRtYXBFbmNvZGluZy5qc1wiO1xuaW1wb3J0IEhlaWdodG1hcFRlc3NlbGxhdG9yIGZyb20gXCIuL0hlaWdodG1hcFRlc3NlbGxhdG9yLmpzXCI7XG5pbXBvcnQgQ2VzaXVtTWF0aCBmcm9tIFwiLi9NYXRoLmpzXCI7XG5pbXBvcnQgT3JpZW50ZWRCb3VuZGluZ0JveCBmcm9tIFwiLi9PcmllbnRlZEJvdW5kaW5nQm94LmpzXCI7XG5pbXBvcnQgUmVjdGFuZ2xlIGZyb20gXCIuL1JlY3RhbmdsZS5qc1wiO1xuaW1wb3J0IFRhc2tQcm9jZXNzb3IgZnJvbSBcIi4vVGFza1Byb2Nlc3Nvci5qc1wiO1xuaW1wb3J0IFRlcnJhaW5EYXRhIGZyb20gXCIuL1RlcnJhaW5EYXRhLmpzXCI7XG5pbXBvcnQgVGVycmFpbkVuY29kaW5nIGZyb20gXCIuL1RlcnJhaW5FbmNvZGluZy5qc1wiO1xuaW1wb3J0IFRlcnJhaW5NZXNoIGZyb20gXCIuL1RlcnJhaW5NZXNoLmpzXCI7XG5pbXBvcnQgVGVycmFpblByb3ZpZGVyIGZyb20gXCIuL1RlcnJhaW5Qcm92aWRlci5qc1wiO1xuXG4vKipcbiAqIFRlcnJhaW4gZGF0YSBmb3IgYSBzaW5nbGUgdGlsZSB3aGVyZSB0aGUgdGVycmFpbiBkYXRhIGlzIHJlcHJlc2VudGVkIGFzIGEgaGVpZ2h0bWFwLiAgQSBoZWlnaHRtYXBcbiAqIGlzIGEgcmVjdGFuZ3VsYXIgYXJyYXkgb2YgaGVpZ2h0cyBpbiByb3ctbWFqb3Igb3JkZXIgZnJvbSBub3J0aCB0byBzb3V0aCBhbmQgd2VzdCB0byBlYXN0LlxuICpcbiAqIEBhbGlhcyBIZWlnaHRtYXBUZXJyYWluRGF0YVxuICogQGNvbnN0cnVjdG9yXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgT2JqZWN0IHdpdGggdGhlIGZvbGxvd2luZyBwcm9wZXJ0aWVzOlxuICogQHBhcmFtIHtJbnQ4QXJyYXl8VWludDhBcnJheXxJbnQxNkFycmF5fFVpbnQxNkFycmF5fEludDMyQXJyYXl8VWludDMyQXJyYXl8RmxvYXQzMkFycmF5fEZsb2F0NjRBcnJheX0gb3B0aW9ucy5idWZmZXIgVGhlIGJ1ZmZlciBjb250YWluaW5nIGhlaWdodCBkYXRhLlxuICogQHBhcmFtIHtOdW1iZXJ9IG9wdGlvbnMud2lkdGggVGhlIHdpZHRoIChsb25naXR1ZGUgZGlyZWN0aW9uKSBvZiB0aGUgaGVpZ2h0bWFwLCBpbiBzYW1wbGVzLlxuICogQHBhcmFtIHtOdW1iZXJ9IG9wdGlvbnMuaGVpZ2h0IFRoZSBoZWlnaHQgKGxhdGl0dWRlIGRpcmVjdGlvbikgb2YgdGhlIGhlaWdodG1hcCwgaW4gc2FtcGxlcy5cbiAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5jaGlsZFRpbGVNYXNrPTE1XSBBIGJpdCBtYXNrIGluZGljYXRpbmcgd2hpY2ggb2YgdGhpcyB0aWxlJ3MgZm91ciBjaGlsZHJlbiBleGlzdC5cbiAqICAgICAgICAgICAgICAgICBJZiBhIGNoaWxkJ3MgYml0IGlzIHNldCwgZ2VvbWV0cnkgd2lsbCBiZSByZXF1ZXN0ZWQgZm9yIHRoYXQgdGlsZSBhcyB3ZWxsIHdoZW4gaXRcbiAqICAgICAgICAgICAgICAgICBpcyBuZWVkZWQuICBJZiB0aGUgYml0IGlzIGNsZWFyZWQsIHRoZSBjaGlsZCB0aWxlIGlzIG5vdCByZXF1ZXN0ZWQgYW5kIGdlb21ldHJ5IGlzXG4gKiAgICAgICAgICAgICAgICAgaW5zdGVhZCB1cHNhbXBsZWQgZnJvbSB0aGUgcGFyZW50LiAgVGhlIGJpdCB2YWx1ZXMgYXJlIGFzIGZvbGxvd3M6XG4gKiAgICAgICAgICAgICAgICAgPHRhYmxlPlxuICogICAgICAgICAgICAgICAgICA8dHI+PHRoPkJpdCBQb3NpdGlvbjwvdGg+PHRoPkJpdCBWYWx1ZTwvdGg+PHRoPkNoaWxkIFRpbGU8L3RoPjwvdHI+XG4gKiAgICAgICAgICAgICAgICAgIDx0cj48dGQ+MDwvdGQ+PHRkPjE8L3RkPjx0ZD5Tb3V0aHdlc3Q8L3RkPjwvdHI+XG4gKiAgICAgICAgICAgICAgICAgIDx0cj48dGQ+MTwvdGQ+PHRkPjI8L3RkPjx0ZD5Tb3V0aGVhc3Q8L3RkPjwvdHI+XG4gKiAgICAgICAgICAgICAgICAgIDx0cj48dGQ+MjwvdGQ+PHRkPjQ8L3RkPjx0ZD5Ob3J0aHdlc3Q8L3RkPjwvdHI+XG4gKiAgICAgICAgICAgICAgICAgIDx0cj48dGQ+MzwvdGQ+PHRkPjg8L3RkPjx0ZD5Ob3J0aGVhc3Q8L3RkPjwvdHI+XG4gKiAgICAgICAgICAgICAgICAgPC90YWJsZT5cbiAqIEBwYXJhbSB7VWludDhBcnJheX0gW29wdGlvbnMud2F0ZXJNYXNrXSBUaGUgd2F0ZXIgbWFzayBpbmNsdWRlZCBpbiB0aGlzIHRlcnJhaW4gZGF0YSwgaWYgYW55LiAgQSB3YXRlciBtYXNrIGlzIGEgc3F1YXJlXG4gKiAgICAgICAgICAgICAgICAgICAgIFVpbnQ4QXJyYXkgb3IgaW1hZ2Ugd2hlcmUgYSB2YWx1ZSBvZiAyNTUgaW5kaWNhdGVzIHdhdGVyIGFuZCBhIHZhbHVlIG9mIDAgaW5kaWNhdGVzIGxhbmQuXG4gKiAgICAgICAgICAgICAgICAgICAgIFZhbHVlcyBpbiBiZXR3ZWVuIDAgYW5kIDI1NSBhcmUgYWxsb3dlZCBhcyB3ZWxsIHRvIHNtb290aGx5IGJsZW5kIGJldHdlZW4gbGFuZCBhbmQgd2F0ZXIuXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnMuc3RydWN0dXJlXSBBbiBvYmplY3QgZGVzY3JpYmluZyB0aGUgc3RydWN0dXJlIG9mIHRoZSBoZWlnaHQgZGF0YS5cbiAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5zdHJ1Y3R1cmUuaGVpZ2h0U2NhbGU9MS4wXSBUaGUgZmFjdG9yIGJ5IHdoaWNoIHRvIG11bHRpcGx5IGhlaWdodCBzYW1wbGVzIGluIG9yZGVyIHRvIG9idGFpblxuICogICAgICAgICAgICAgICAgIHRoZSBoZWlnaHQgYWJvdmUgdGhlIGhlaWdodE9mZnNldCwgaW4gbWV0ZXJzLiAgVGhlIGhlaWdodE9mZnNldCBpcyBhZGRlZCB0byB0aGUgcmVzdWx0aW5nXG4gKiAgICAgICAgICAgICAgICAgaGVpZ2h0IGFmdGVyIG11bHRpcGx5aW5nIGJ5IHRoZSBzY2FsZS5cbiAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5zdHJ1Y3R1cmUuaGVpZ2h0T2Zmc2V0PTAuMF0gVGhlIG9mZnNldCB0byBhZGQgdG8gdGhlIHNjYWxlZCBoZWlnaHQgdG8gb2J0YWluIHRoZSBmaW5hbFxuICogICAgICAgICAgICAgICAgIGhlaWdodCBpbiBtZXRlcnMuICBUaGUgb2Zmc2V0IGlzIGFkZGVkIGFmdGVyIHRoZSBoZWlnaHQgc2FtcGxlIGlzIG11bHRpcGxpZWQgYnkgdGhlXG4gKiAgICAgICAgICAgICAgICAgaGVpZ2h0U2NhbGUuXG4gKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMuc3RydWN0dXJlLmVsZW1lbnRzUGVySGVpZ2h0PTFdIFRoZSBudW1iZXIgb2YgZWxlbWVudHMgaW4gdGhlIGJ1ZmZlciB0aGF0IG1ha2UgdXAgYSBzaW5nbGUgaGVpZ2h0XG4gKiAgICAgICAgICAgICAgICAgc2FtcGxlLiAgVGhpcyBpcyB1c3VhbGx5IDEsIGluZGljYXRpbmcgdGhhdCBlYWNoIGVsZW1lbnQgaXMgYSBzZXBhcmF0ZSBoZWlnaHQgc2FtcGxlLiAgSWZcbiAqICAgICAgICAgICAgICAgICBpdCBpcyBncmVhdGVyIHRoYW4gMSwgdGhhdCBudW1iZXIgb2YgZWxlbWVudHMgdG9nZXRoZXIgZm9ybSB0aGUgaGVpZ2h0IHNhbXBsZSwgd2hpY2ggaXNcbiAqICAgICAgICAgICAgICAgICBjb21wdXRlZCBhY2NvcmRpbmcgdG8gdGhlIHN0cnVjdHVyZS5lbGVtZW50TXVsdGlwbGllciBhbmQgc3RydWN0dXJlLmlzQmlnRW5kaWFuIHByb3BlcnRpZXMuXG4gKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMuc3RydWN0dXJlLnN0cmlkZT0xXSBUaGUgbnVtYmVyIG9mIGVsZW1lbnRzIHRvIHNraXAgdG8gZ2V0IGZyb20gdGhlIGZpcnN0IGVsZW1lbnQgb2ZcbiAqICAgICAgICAgICAgICAgICBvbmUgaGVpZ2h0IHRvIHRoZSBmaXJzdCBlbGVtZW50IG9mIHRoZSBuZXh0IGhlaWdodC5cbiAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5zdHJ1Y3R1cmUuZWxlbWVudE11bHRpcGxpZXI9MjU2LjBdIFRoZSBtdWx0aXBsaWVyIHVzZWQgdG8gY29tcHV0ZSB0aGUgaGVpZ2h0IHZhbHVlIHdoZW4gdGhlXG4gKiAgICAgICAgICAgICAgICAgc3RyaWRlIHByb3BlcnR5IGlzIGdyZWF0ZXIgdGhhbiAxLiAgRm9yIGV4YW1wbGUsIGlmIHRoZSBzdHJpZGUgaXMgNCBhbmQgdGhlIHN0cmlkZU11bHRpcGxpZXJcbiAqICAgICAgICAgICAgICAgICBpcyAyNTYsIHRoZSBoZWlnaHQgaXMgY29tcHV0ZWQgYXMgZm9sbG93czpcbiAqICAgICAgICAgICAgICAgICBgaGVpZ2h0ID0gYnVmZmVyW2luZGV4XSArIGJ1ZmZlcltpbmRleCArIDFdICogMjU2ICsgYnVmZmVyW2luZGV4ICsgMl0gKiAyNTYgKiAyNTYgKyBidWZmZXJbaW5kZXggKyAzXSAqIDI1NiAqIDI1NiAqIDI1NmBcbiAqICAgICAgICAgICAgICAgICBUaGlzIGlzIGFzc3VtaW5nIHRoYXQgdGhlIGlzQmlnRW5kaWFuIHByb3BlcnR5IGlzIGZhbHNlLiAgSWYgaXQgaXMgdHJ1ZSwgdGhlIG9yZGVyIG9mIHRoZVxuICogICAgICAgICAgICAgICAgIGVsZW1lbnRzIGlzIHJldmVyc2VkLlxuICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5zdHJ1Y3R1cmUuaXNCaWdFbmRpYW49ZmFsc2VdIEluZGljYXRlcyBlbmRpYW5uZXNzIG9mIHRoZSBlbGVtZW50cyBpbiB0aGUgYnVmZmVyIHdoZW4gdGhlXG4gKiAgICAgICAgICAgICAgICAgIHN0cmlkZSBwcm9wZXJ0eSBpcyBncmVhdGVyIHRoYW4gMS4gIElmIHRoaXMgcHJvcGVydHkgaXMgZmFsc2UsIHRoZSBmaXJzdCBlbGVtZW50IGlzIHRoZVxuICogICAgICAgICAgICAgICAgICBsb3ctb3JkZXIgZWxlbWVudC4gIElmIGl0IGlzIHRydWUsIHRoZSBmaXJzdCBlbGVtZW50IGlzIHRoZSBoaWdoLW9yZGVyIGVsZW1lbnQuXG4gKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMuc3RydWN0dXJlLmxvd2VzdEVuY29kZWRIZWlnaHRdIFRoZSBsb3dlc3QgdmFsdWUgdGhhdCBjYW4gYmUgc3RvcmVkIGluIHRoZSBoZWlnaHQgYnVmZmVyLiAgQW55IGhlaWdodHMgdGhhdCBhcmUgbG93ZXJcbiAqICAgICAgICAgICAgICAgICB0aGFuIHRoaXMgdmFsdWUgYWZ0ZXIgZW5jb2Rpbmcgd2l0aCB0aGUgYGhlaWdodFNjYWxlYCBhbmQgYGhlaWdodE9mZnNldGAgYXJlIGNsYW1wZWQgdG8gdGhpcyB2YWx1ZS4gIEZvciBleGFtcGxlLCBpZiB0aGUgaGVpZ2h0XG4gKiAgICAgICAgICAgICAgICAgYnVmZmVyIGlzIGEgYFVpbnQxNkFycmF5YCwgdGhpcyB2YWx1ZSBzaG91bGQgYmUgMCBiZWNhdXNlIGEgYFVpbnQxNkFycmF5YCBjYW5ub3Qgc3RvcmUgbmVnYXRpdmUgbnVtYmVycy4gIElmIHRoaXMgcGFyYW1ldGVyIGlzXG4gKiAgICAgICAgICAgICAgICAgbm90IHNwZWNpZmllZCwgbm8gbWluaW11bSB2YWx1ZSBpcyBlbmZvcmNlZC5cbiAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5zdHJ1Y3R1cmUuaGlnaGVzdEVuY29kZWRIZWlnaHRdIFRoZSBoaWdoZXN0IHZhbHVlIHRoYXQgY2FuIGJlIHN0b3JlZCBpbiB0aGUgaGVpZ2h0IGJ1ZmZlci4gIEFueSBoZWlnaHRzIHRoYXQgYXJlIGhpZ2hlclxuICogICAgICAgICAgICAgICAgIHRoYW4gdGhpcyB2YWx1ZSBhZnRlciBlbmNvZGluZyB3aXRoIHRoZSBgaGVpZ2h0U2NhbGVgIGFuZCBgaGVpZ2h0T2Zmc2V0YCBhcmUgY2xhbXBlZCB0byB0aGlzIHZhbHVlLiAgRm9yIGV4YW1wbGUsIGlmIHRoZSBoZWlnaHRcbiAqICAgICAgICAgICAgICAgICBidWZmZXIgaXMgYSBgVWludDE2QXJyYXlgLCB0aGlzIHZhbHVlIHNob3VsZCBiZSBgMjU2ICogMjU2IC0gMWAgb3IgNjU1MzUgYmVjYXVzZSBhIGBVaW50MTZBcnJheWAgY2Fubm90IHN0b3JlIG51bWJlcnMgbGFyZ2VyXG4gKiAgICAgICAgICAgICAgICAgdGhhbiA2NTUzNS4gIElmIHRoaXMgcGFyYW1ldGVyIGlzIG5vdCBzcGVjaWZpZWQsIG5vIG1heGltdW0gdmFsdWUgaXMgZW5mb3JjZWQuXG4gKiBAcGFyYW0ge0hlaWdodG1hcEVuY29kaW5nfSBbb3B0aW9ucy5lbmNvZGluZz1IZWlnaHRtYXBFbmNvZGluZy5OT05FXSBUaGUgZW5jb2RpbmcgdGhhdCBpcyB1c2VkIG9uIHRoZSBidWZmZXIuXG4gKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLmNyZWF0ZWRCeVVwc2FtcGxpbmc9ZmFsc2VdIFRydWUgaWYgdGhpcyBpbnN0YW5jZSB3YXMgY3JlYXRlZCBieSB1cHNhbXBsaW5nIGFub3RoZXIgaW5zdGFuY2U7XG4gKiAgICAgICAgICAgICAgICAgIG90aGVyd2lzZSwgZmFsc2UuXG4gKlxuICpcbiAqIEBleGFtcGxlXG4gKiB2YXIgYnVmZmVyID0gLi4uXG4gKiB2YXIgaGVpZ2h0QnVmZmVyID0gbmV3IFVpbnQxNkFycmF5KGJ1ZmZlciwgMCwgdGhhdC5faGVpZ2h0bWFwV2lkdGggKiB0aGF0Ll9oZWlnaHRtYXBXaWR0aCk7XG4gKiB2YXIgY2hpbGRUaWxlTWFzayA9IG5ldyBVaW50OEFycmF5KGJ1ZmZlciwgaGVpZ2h0QnVmZmVyLmJ5dGVMZW5ndGgsIDEpWzBdO1xuICogdmFyIHdhdGVyTWFzayA9IG5ldyBVaW50OEFycmF5KGJ1ZmZlciwgaGVpZ2h0QnVmZmVyLmJ5dGVMZW5ndGggKyAxLCBidWZmZXIuYnl0ZUxlbmd0aCAtIGhlaWdodEJ1ZmZlci5ieXRlTGVuZ3RoIC0gMSk7XG4gKiB2YXIgdGVycmFpbkRhdGEgPSBuZXcgQ2VzaXVtLkhlaWdodG1hcFRlcnJhaW5EYXRhKHtcbiAqICAgYnVmZmVyIDogaGVpZ2h0QnVmZmVyLFxuICogICB3aWR0aCA6IDY1LFxuICogICBoZWlnaHQgOiA2NSxcbiAqICAgY2hpbGRUaWxlTWFzayA6IGNoaWxkVGlsZU1hc2ssXG4gKiAgIHdhdGVyTWFzayA6IHdhdGVyTWFza1xuICogfSk7XG4gKlxuICogQHNlZSBUZXJyYWluRGF0YVxuICogQHNlZSBRdWFudGl6ZWRNZXNoVGVycmFpbkRhdGFcbiAqIEBzZWUgR29vZ2xlRWFydGhFbnRlcnByaXNlVGVycmFpbkRhdGFcbiAqL1xuZnVuY3Rpb24gSGVpZ2h0bWFwVGVycmFpbkRhdGEob3B0aW9ucykge1xuICAvLz4+aW5jbHVkZVN0YXJ0KCdkZWJ1ZycsIHByYWdtYXMuZGVidWcpO1xuICBpZiAoIWRlZmluZWQob3B0aW9ucykgfHwgIWRlZmluZWQob3B0aW9ucy5idWZmZXIpKSB7XG4gICAgdGhyb3cgbmV3IERldmVsb3BlckVycm9yKFwib3B0aW9ucy5idWZmZXIgaXMgcmVxdWlyZWQuXCIpO1xuICB9XG4gIGlmICghZGVmaW5lZChvcHRpb25zLndpZHRoKSkge1xuICAgIHRocm93IG5ldyBEZXZlbG9wZXJFcnJvcihcIm9wdGlvbnMud2lkdGggaXMgcmVxdWlyZWQuXCIpO1xuICB9XG4gIGlmICghZGVmaW5lZChvcHRpb25zLmhlaWdodCkpIHtcbiAgICB0aHJvdyBuZXcgRGV2ZWxvcGVyRXJyb3IoXCJvcHRpb25zLmhlaWdodCBpcyByZXF1aXJlZC5cIik7XG4gIH1cbiAgLy8+PmluY2x1ZGVFbmQoJ2RlYnVnJyk7XG5cbiAgdGhpcy5fYnVmZmVyID0gb3B0aW9ucy5idWZmZXI7XG4gIHRoaXMuX3dpZHRoID0gb3B0aW9ucy53aWR0aDtcbiAgdGhpcy5faGVpZ2h0ID0gb3B0aW9ucy5oZWlnaHQ7XG4gIHRoaXMuX2NoaWxkVGlsZU1hc2sgPSBkZWZhdWx0VmFsdWUob3B0aW9ucy5jaGlsZFRpbGVNYXNrLCAxNSk7XG4gIHRoaXMuX2VuY29kaW5nID0gZGVmYXVsdFZhbHVlKG9wdGlvbnMuZW5jb2RpbmcsIEhlaWdodG1hcEVuY29kaW5nLk5PTkUpO1xuXG4gIHZhciBkZWZhdWx0U3RydWN0dXJlID0gSGVpZ2h0bWFwVGVzc2VsbGF0b3IuREVGQVVMVF9TVFJVQ1RVUkU7XG4gIHZhciBzdHJ1Y3R1cmUgPSBvcHRpb25zLnN0cnVjdHVyZTtcbiAgaWYgKCFkZWZpbmVkKHN0cnVjdHVyZSkpIHtcbiAgICBzdHJ1Y3R1cmUgPSBkZWZhdWx0U3RydWN0dXJlO1xuICB9IGVsc2UgaWYgKHN0cnVjdHVyZSAhPT0gZGVmYXVsdFN0cnVjdHVyZSkge1xuICAgIHN0cnVjdHVyZS5oZWlnaHRTY2FsZSA9IGRlZmF1bHRWYWx1ZShcbiAgICAgIHN0cnVjdHVyZS5oZWlnaHRTY2FsZSxcbiAgICAgIGRlZmF1bHRTdHJ1Y3R1cmUuaGVpZ2h0U2NhbGVcbiAgICApO1xuICAgIHN0cnVjdHVyZS5oZWlnaHRPZmZzZXQgPSBkZWZhdWx0VmFsdWUoXG4gICAgICBzdHJ1Y3R1cmUuaGVpZ2h0T2Zmc2V0LFxuICAgICAgZGVmYXVsdFN0cnVjdHVyZS5oZWlnaHRPZmZzZXRcbiAgICApO1xuICAgIHN0cnVjdHVyZS5lbGVtZW50c1BlckhlaWdodCA9IGRlZmF1bHRWYWx1ZShcbiAgICAgIHN0cnVjdHVyZS5lbGVtZW50c1BlckhlaWdodCxcbiAgICAgIGRlZmF1bHRTdHJ1Y3R1cmUuZWxlbWVudHNQZXJIZWlnaHRcbiAgICApO1xuICAgIHN0cnVjdHVyZS5zdHJpZGUgPSBkZWZhdWx0VmFsdWUoc3RydWN0dXJlLnN0cmlkZSwgZGVmYXVsdFN0cnVjdHVyZS5zdHJpZGUpO1xuICAgIHN0cnVjdHVyZS5lbGVtZW50TXVsdGlwbGllciA9IGRlZmF1bHRWYWx1ZShcbiAgICAgIHN0cnVjdHVyZS5lbGVtZW50TXVsdGlwbGllcixcbiAgICAgIGRlZmF1bHRTdHJ1Y3R1cmUuZWxlbWVudE11bHRpcGxpZXJcbiAgICApO1xuICAgIHN0cnVjdHVyZS5pc0JpZ0VuZGlhbiA9IGRlZmF1bHRWYWx1ZShcbiAgICAgIHN0cnVjdHVyZS5pc0JpZ0VuZGlhbixcbiAgICAgIGRlZmF1bHRTdHJ1Y3R1cmUuaXNCaWdFbmRpYW5cbiAgICApO1xuICB9XG5cbiAgdGhpcy5fc3RydWN0dXJlID0gc3RydWN0dXJlO1xuICB0aGlzLl9jcmVhdGVkQnlVcHNhbXBsaW5nID0gZGVmYXVsdFZhbHVlKG9wdGlvbnMuY3JlYXRlZEJ5VXBzYW1wbGluZywgZmFsc2UpO1xuICB0aGlzLl93YXRlck1hc2sgPSBvcHRpb25zLndhdGVyTWFzaztcblxuICB0aGlzLl9za2lydEhlaWdodCA9IHVuZGVmaW5lZDtcbiAgdGhpcy5fYnVmZmVyVHlwZSA9XG4gICAgdGhpcy5fZW5jb2RpbmcgPT09IEhlaWdodG1hcEVuY29kaW5nLkxFUkNcbiAgICAgID8gRmxvYXQzMkFycmF5XG4gICAgICA6IHRoaXMuX2J1ZmZlci5jb25zdHJ1Y3RvcjtcbiAgdGhpcy5fbWVzaCA9IHVuZGVmaW5lZDtcbn1cblxuT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoSGVpZ2h0bWFwVGVycmFpbkRhdGEucHJvdG90eXBlLCB7XG4gIC8qKlxuICAgKiBBbiBhcnJheSBvZiBjcmVkaXRzIGZvciB0aGlzIHRpbGUuXG4gICAqIEBtZW1iZXJvZiBIZWlnaHRtYXBUZXJyYWluRGF0YS5wcm90b3R5cGVcbiAgICogQHR5cGUge0NyZWRpdFtdfVxuICAgKi9cbiAgY3JlZGl0czoge1xuICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9LFxuICB9LFxuICAvKipcbiAgICogVGhlIHdhdGVyIG1hc2sgaW5jbHVkZWQgaW4gdGhpcyB0ZXJyYWluIGRhdGEsIGlmIGFueS4gIEEgd2F0ZXIgbWFzayBpcyBhIHNxdWFyZVxuICAgKiBVaW50OEFycmF5IG9yIGltYWdlIHdoZXJlIGEgdmFsdWUgb2YgMjU1IGluZGljYXRlcyB3YXRlciBhbmQgYSB2YWx1ZSBvZiAwIGluZGljYXRlcyBsYW5kLlxuICAgKiBWYWx1ZXMgaW4gYmV0d2VlbiAwIGFuZCAyNTUgYXJlIGFsbG93ZWQgYXMgd2VsbCB0byBzbW9vdGhseSBibGVuZCBiZXR3ZWVuIGxhbmQgYW5kIHdhdGVyLlxuICAgKiBAbWVtYmVyb2YgSGVpZ2h0bWFwVGVycmFpbkRhdGEucHJvdG90eXBlXG4gICAqIEB0eXBlIHtVaW50OEFycmF5fEhUTUxJbWFnZUVsZW1lbnR8SFRNTENhbnZhc0VsZW1lbnR9XG4gICAqL1xuICB3YXRlck1hc2s6IHtcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLl93YXRlck1hc2s7XG4gICAgfSxcbiAgfSxcblxuICBjaGlsZFRpbGVNYXNrOiB7XG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fY2hpbGRUaWxlTWFzaztcbiAgICB9LFxuICB9LFxufSk7XG5cbnZhciBjcmVhdGVNZXNoVGFza05hbWUgPSBcImNyZWF0ZVZlcnRpY2VzRnJvbUhlaWdodG1hcFwiO1xudmFyIGNyZWF0ZU1lc2hUYXNrUHJvY2Vzc29yTm9UaHJvdHRsZSA9IG5ldyBUYXNrUHJvY2Vzc29yKGNyZWF0ZU1lc2hUYXNrTmFtZSk7XG52YXIgY3JlYXRlTWVzaFRhc2tQcm9jZXNzb3JUaHJvdHRsZSA9IG5ldyBUYXNrUHJvY2Vzc29yKFxuICBjcmVhdGVNZXNoVGFza05hbWUsXG4gIFRlcnJhaW5EYXRhLm1heGltdW1Bc3luY2hyb25vdXNUYXNrc1xuKTtcblxuLyoqXG4gKiBDcmVhdGVzIGEge0BsaW5rIFRlcnJhaW5NZXNofSBmcm9tIHRoaXMgdGVycmFpbiBkYXRhLlxuICpcbiAqIEBwcml2YXRlXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgT2JqZWN0IHdpdGggdGhlIGZvbGxvd2luZyBwcm9wZXJ0aWVzOlxuICogQHBhcmFtIHtUaWxpbmdTY2hlbWV9IG9wdGlvbnMudGlsaW5nU2NoZW1lIFRoZSB0aWxpbmcgc2NoZW1lIHRvIHdoaWNoIHRoaXMgdGlsZSBiZWxvbmdzLlxuICogQHBhcmFtIHtOdW1iZXJ9IG9wdGlvbnMueCBUaGUgWCBjb29yZGluYXRlIG9mIHRoZSB0aWxlIGZvciB3aGljaCB0byBjcmVhdGUgdGhlIHRlcnJhaW4gZGF0YS5cbiAqIEBwYXJhbSB7TnVtYmVyfSBvcHRpb25zLnkgVGhlIFkgY29vcmRpbmF0ZSBvZiB0aGUgdGlsZSBmb3Igd2hpY2ggdG8gY3JlYXRlIHRoZSB0ZXJyYWluIGRhdGEuXG4gKiBAcGFyYW0ge051bWJlcn0gb3B0aW9ucy5sZXZlbCBUaGUgbGV2ZWwgb2YgdGhlIHRpbGUgZm9yIHdoaWNoIHRvIGNyZWF0ZSB0aGUgdGVycmFpbiBkYXRhLlxuICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLmV4YWdnZXJhdGlvbj0xLjBdIFRoZSBzY2FsZSB1c2VkIHRvIGV4YWdnZXJhdGUgdGhlIHRlcnJhaW4uXG4gKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMuZXhhZ2dlcmF0aW9uUmVsYXRpdmVIZWlnaHQ9MC4wXSBUaGUgaGVpZ2h0IHJlbGF0aXZlIHRvIHdoaWNoIHRlcnJhaW4gaXMgZXhhZ2dlcmF0ZWQuXG4gKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLnRocm90dGxlPXRydWVdIElmIHRydWUsIGluZGljYXRlcyB0aGF0IHRoaXMgb3BlcmF0aW9uIHdpbGwgbmVlZCB0byBiZSByZXRyaWVkIGlmIHRvbyBtYW55IGFzeW5jaHJvbm91cyBtZXNoIGNyZWF0aW9ucyBhcmUgYWxyZWFkeSBpbiBwcm9ncmVzcy5cbiAqIEByZXR1cm5zIHtQcm9taXNlLjxUZXJyYWluTWVzaD58dW5kZWZpbmVkfSBBIHByb21pc2UgZm9yIHRoZSB0ZXJyYWluIG1lc2gsIG9yIHVuZGVmaW5lZCBpZiB0b28gbWFueVxuICogICAgICAgICAgYXN5bmNocm9ub3VzIG1lc2ggY3JlYXRpb25zIGFyZSBhbHJlYWR5IGluIHByb2dyZXNzIGFuZCB0aGUgb3BlcmF0aW9uIHNob3VsZFxuICogICAgICAgICAgYmUgcmV0cmllZCBsYXRlci5cbiAqL1xuSGVpZ2h0bWFwVGVycmFpbkRhdGEucHJvdG90eXBlLmNyZWF0ZU1lc2ggPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICBvcHRpb25zID0gZGVmYXVsdFZhbHVlKG9wdGlvbnMsIGRlZmF1bHRWYWx1ZS5FTVBUWV9PQkpFQ1QpO1xuXG4gIC8vPj5pbmNsdWRlU3RhcnQoJ2RlYnVnJywgcHJhZ21hcy5kZWJ1Zyk7XG4gIENoZWNrLnR5cGVPZi5vYmplY3QoXCJvcHRpb25zLnRpbGluZ1NjaGVtZVwiLCBvcHRpb25zLnRpbGluZ1NjaGVtZSk7XG4gIENoZWNrLnR5cGVPZi5udW1iZXIoXCJvcHRpb25zLnhcIiwgb3B0aW9ucy54KTtcbiAgQ2hlY2sudHlwZU9mLm51bWJlcihcIm9wdGlvbnMueVwiLCBvcHRpb25zLnkpO1xuICBDaGVjay50eXBlT2YubnVtYmVyKFwib3B0aW9ucy5sZXZlbFwiLCBvcHRpb25zLmxldmVsKTtcbiAgLy8+PmluY2x1ZGVFbmQoJ2RlYnVnJyk7XG5cbiAgdmFyIHRpbGluZ1NjaGVtZSA9IG9wdGlvbnMudGlsaW5nU2NoZW1lO1xuICB2YXIgeCA9IG9wdGlvbnMueDtcbiAgdmFyIHkgPSBvcHRpb25zLnk7XG4gIHZhciBsZXZlbCA9IG9wdGlvbnMubGV2ZWw7XG4gIHZhciBleGFnZ2VyYXRpb24gPSBkZWZhdWx0VmFsdWUob3B0aW9ucy5leGFnZ2VyYXRpb24sIDEuMCk7XG4gIHZhciBleGFnZ2VyYXRpb25SZWxhdGl2ZUhlaWdodCA9IGRlZmF1bHRWYWx1ZShcbiAgICBvcHRpb25zLmV4YWdnZXJhdGlvblJlbGF0aXZlSGVpZ2h0LFxuICAgIDAuMFxuICApO1xuICB2YXIgdGhyb3R0bGUgPSBkZWZhdWx0VmFsdWUob3B0aW9ucy50aHJvdHRsZSwgdHJ1ZSk7XG5cbiAgdmFyIGVsbGlwc29pZCA9IHRpbGluZ1NjaGVtZS5lbGxpcHNvaWQ7XG4gIHZhciBuYXRpdmVSZWN0YW5nbGUgPSB0aWxpbmdTY2hlbWUudGlsZVhZVG9OYXRpdmVSZWN0YW5nbGUoeCwgeSwgbGV2ZWwpO1xuICB2YXIgcmVjdGFuZ2xlID0gdGlsaW5nU2NoZW1lLnRpbGVYWVRvUmVjdGFuZ2xlKHgsIHksIGxldmVsKTtcblxuICAvLyBDb21wdXRlIHRoZSBjZW50ZXIgb2YgdGhlIHRpbGUgZm9yIFJUQyByZW5kZXJpbmcuXG4gIHZhciBjZW50ZXIgPSBlbGxpcHNvaWQuY2FydG9ncmFwaGljVG9DYXJ0ZXNpYW4oUmVjdGFuZ2xlLmNlbnRlcihyZWN0YW5nbGUpKTtcblxuICB2YXIgc3RydWN0dXJlID0gdGhpcy5fc3RydWN0dXJlO1xuXG4gIHZhciBsZXZlbFplcm9NYXhFcnJvciA9IFRlcnJhaW5Qcm92aWRlci5nZXRFc3RpbWF0ZWRMZXZlbFplcm9HZW9tZXRyaWNFcnJvckZvckFIZWlnaHRtYXAoXG4gICAgZWxsaXBzb2lkLFxuICAgIHRoaXMuX3dpZHRoLFxuICAgIHRpbGluZ1NjaGVtZS5nZXROdW1iZXJPZlhUaWxlc0F0TGV2ZWwoMClcbiAgKTtcbiAgdmFyIHRoaXNMZXZlbE1heEVycm9yID0gbGV2ZWxaZXJvTWF4RXJyb3IgLyAoMSA8PCBsZXZlbCk7XG4gIHRoaXMuX3NraXJ0SGVpZ2h0ID0gTWF0aC5taW4odGhpc0xldmVsTWF4RXJyb3IgKiA0LjAsIDEwMDAuMCk7XG5cbiAgdmFyIGNyZWF0ZU1lc2hUYXNrUHJvY2Vzc29yID0gdGhyb3R0bGVcbiAgICA/IGNyZWF0ZU1lc2hUYXNrUHJvY2Vzc29yVGhyb3R0bGVcbiAgICA6IGNyZWF0ZU1lc2hUYXNrUHJvY2Vzc29yTm9UaHJvdHRsZTtcblxuICB2YXIgdmVydGljZXNQcm9taXNlID0gY3JlYXRlTWVzaFRhc2tQcm9jZXNzb3Iuc2NoZWR1bGVUYXNrKHtcbiAgICBoZWlnaHRtYXA6IHRoaXMuX2J1ZmZlcixcbiAgICBzdHJ1Y3R1cmU6IHN0cnVjdHVyZSxcbiAgICBpbmNsdWRlV2ViTWVyY2F0b3JUOiB0cnVlLFxuICAgIHdpZHRoOiB0aGlzLl93aWR0aCxcbiAgICBoZWlnaHQ6IHRoaXMuX2hlaWdodCxcbiAgICBuYXRpdmVSZWN0YW5nbGU6IG5hdGl2ZVJlY3RhbmdsZSxcbiAgICByZWN0YW5nbGU6IHJlY3RhbmdsZSxcbiAgICByZWxhdGl2ZVRvQ2VudGVyOiBjZW50ZXIsXG4gICAgZWxsaXBzb2lkOiBlbGxpcHNvaWQsXG4gICAgc2tpcnRIZWlnaHQ6IHRoaXMuX3NraXJ0SGVpZ2h0LFxuICAgIGlzR2VvZ3JhcGhpYzogdGlsaW5nU2NoZW1lLnByb2plY3Rpb24gaW5zdGFuY2VvZiBHZW9ncmFwaGljUHJvamVjdGlvbixcbiAgICBleGFnZ2VyYXRpb246IGV4YWdnZXJhdGlvbixcbiAgICBleGFnZ2VyYXRpb25SZWxhdGl2ZUhlaWdodDogZXhhZ2dlcmF0aW9uUmVsYXRpdmVIZWlnaHQsXG4gICAgZW5jb2Rpbmc6IHRoaXMuX2VuY29kaW5nLFxuICB9KTtcblxuICBpZiAoIWRlZmluZWQodmVydGljZXNQcm9taXNlKSkge1xuICAgIC8vIFBvc3Rwb25lZFxuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cblxuICB2YXIgdGhhdCA9IHRoaXM7XG4gIHJldHVybiB3aGVuKHZlcnRpY2VzUHJvbWlzZSwgZnVuY3Rpb24gKHJlc3VsdCkge1xuICAgIHZhciBpbmRpY2VzQW5kRWRnZXM7XG4gICAgaWYgKHRoYXQuX3NraXJ0SGVpZ2h0ID4gMC4wKSB7XG4gICAgICBpbmRpY2VzQW5kRWRnZXMgPSBUZXJyYWluUHJvdmlkZXIuZ2V0UmVndWxhckdyaWRBbmRTa2lydEluZGljZXNBbmRFZGdlSW5kaWNlcyhcbiAgICAgICAgcmVzdWx0LmdyaWRXaWR0aCxcbiAgICAgICAgcmVzdWx0LmdyaWRIZWlnaHRcbiAgICAgICk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGluZGljZXNBbmRFZGdlcyA9IFRlcnJhaW5Qcm92aWRlci5nZXRSZWd1bGFyR3JpZEluZGljZXNBbmRFZGdlSW5kaWNlcyhcbiAgICAgICAgcmVzdWx0LmdyaWRXaWR0aCxcbiAgICAgICAgcmVzdWx0LmdyaWRIZWlnaHRcbiAgICAgICk7XG4gICAgfVxuXG4gICAgdmFyIHZlcnRleENvdW50V2l0aG91dFNraXJ0cyA9IHJlc3VsdC5ncmlkV2lkdGggKiByZXN1bHQuZ3JpZEhlaWdodDtcblxuICAgIC8vIENsb25lIGNvbXBsZXggcmVzdWx0IG9iamVjdHMgYmVjYXVzZSB0aGUgdHJhbnNmZXIgZnJvbSB0aGUgd2ViIHdvcmtlclxuICAgIC8vIGhhcyBzdHJpcHBlZCB0aGVtIGRvd24gdG8gSlNPTi1zdHlsZSBvYmplY3RzLlxuICAgIHRoYXQuX21lc2ggPSBuZXcgVGVycmFpbk1lc2goXG4gICAgICBjZW50ZXIsXG4gICAgICBuZXcgRmxvYXQzMkFycmF5KHJlc3VsdC52ZXJ0aWNlcyksXG4gICAgICBpbmRpY2VzQW5kRWRnZXMuaW5kaWNlcyxcbiAgICAgIGluZGljZXNBbmRFZGdlcy5pbmRleENvdW50V2l0aG91dFNraXJ0cyxcbiAgICAgIHZlcnRleENvdW50V2l0aG91dFNraXJ0cyxcbiAgICAgIHJlc3VsdC5taW5pbXVtSGVpZ2h0LFxuICAgICAgcmVzdWx0Lm1heGltdW1IZWlnaHQsXG4gICAgICBCb3VuZGluZ1NwaGVyZS5jbG9uZShyZXN1bHQuYm91bmRpbmdTcGhlcmUzRCksXG4gICAgICBDYXJ0ZXNpYW4zLmNsb25lKHJlc3VsdC5vY2NsdWRlZVBvaW50SW5TY2FsZWRTcGFjZSksXG4gICAgICByZXN1bHQubnVtYmVyT2ZBdHRyaWJ1dGVzLFxuICAgICAgT3JpZW50ZWRCb3VuZGluZ0JveC5jbG9uZShyZXN1bHQub3JpZW50ZWRCb3VuZGluZ0JveCksXG4gICAgICBUZXJyYWluRW5jb2RpbmcuY2xvbmUocmVzdWx0LmVuY29kaW5nKSxcbiAgICAgIGluZGljZXNBbmRFZGdlcy53ZXN0SW5kaWNlc1NvdXRoVG9Ob3J0aCxcbiAgICAgIGluZGljZXNBbmRFZGdlcy5zb3V0aEluZGljZXNFYXN0VG9XZXN0LFxuICAgICAgaW5kaWNlc0FuZEVkZ2VzLmVhc3RJbmRpY2VzTm9ydGhUb1NvdXRoLFxuICAgICAgaW5kaWNlc0FuZEVkZ2VzLm5vcnRoSW5kaWNlc1dlc3RUb0Vhc3RcbiAgICApO1xuXG4gICAgLy8gRnJlZSBtZW1vcnkgcmVjZWl2ZWQgZnJvbSBzZXJ2ZXIgYWZ0ZXIgbWVzaCBpcyBjcmVhdGVkLlxuICAgIHRoYXQuX2J1ZmZlciA9IHVuZGVmaW5lZDtcbiAgICByZXR1cm4gdGhhdC5fbWVzaDtcbiAgfSk7XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIE9iamVjdCB3aXRoIHRoZSBmb2xsb3dpbmcgcHJvcGVydGllczpcbiAqIEBwYXJhbSB7VGlsaW5nU2NoZW1lfSBvcHRpb25zLnRpbGluZ1NjaGVtZSBUaGUgdGlsaW5nIHNjaGVtZSB0byB3aGljaCB0aGlzIHRpbGUgYmVsb25ncy5cbiAqIEBwYXJhbSB7TnVtYmVyfSBvcHRpb25zLnggVGhlIFggY29vcmRpbmF0ZSBvZiB0aGUgdGlsZSBmb3Igd2hpY2ggdG8gY3JlYXRlIHRoZSB0ZXJyYWluIGRhdGEuXG4gKiBAcGFyYW0ge051bWJlcn0gb3B0aW9ucy55IFRoZSBZIGNvb3JkaW5hdGUgb2YgdGhlIHRpbGUgZm9yIHdoaWNoIHRvIGNyZWF0ZSB0aGUgdGVycmFpbiBkYXRhLlxuICogQHBhcmFtIHtOdW1iZXJ9IG9wdGlvbnMubGV2ZWwgVGhlIGxldmVsIG9mIHRoZSB0aWxlIGZvciB3aGljaCB0byBjcmVhdGUgdGhlIHRlcnJhaW4gZGF0YS5cbiAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5leGFnZ2VyYXRpb249MS4wXSBUaGUgc2NhbGUgdXNlZCB0byBleGFnZ2VyYXRlIHRoZSB0ZXJyYWluLlxuICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLmV4YWdnZXJhdGlvblJlbGF0aXZlSGVpZ2h0PTAuMF0gVGhlIGhlaWdodCByZWxhdGl2ZSB0byB3aGljaCB0ZXJyYWluIGlzIGV4YWdnZXJhdGVkLlxuICpcbiAqIEBwcml2YXRlXG4gKi9cbkhlaWdodG1hcFRlcnJhaW5EYXRhLnByb3RvdHlwZS5fY3JlYXRlTWVzaFN5bmMgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAvLz4+aW5jbHVkZVN0YXJ0KCdkZWJ1ZycsIHByYWdtYXMuZGVidWcpO1xuICBDaGVjay50eXBlT2Yub2JqZWN0KFwib3B0aW9ucy50aWxpbmdTY2hlbWVcIiwgb3B0aW9ucy50aWxpbmdTY2hlbWUpO1xuICBDaGVjay50eXBlT2YubnVtYmVyKFwib3B0aW9ucy54XCIsIG9wdGlvbnMueCk7XG4gIENoZWNrLnR5cGVPZi5udW1iZXIoXCJvcHRpb25zLnlcIiwgb3B0aW9ucy55KTtcbiAgQ2hlY2sudHlwZU9mLm51bWJlcihcIm9wdGlvbnMubGV2ZWxcIiwgb3B0aW9ucy5sZXZlbCk7XG4gIC8vPj5pbmNsdWRlRW5kKCdkZWJ1ZycpO1xuXG4gIHZhciB0aWxpbmdTY2hlbWUgPSBvcHRpb25zLnRpbGluZ1NjaGVtZTtcbiAgdmFyIHggPSBvcHRpb25zLng7XG4gIHZhciB5ID0gb3B0aW9ucy55O1xuICB2YXIgbGV2ZWwgPSBvcHRpb25zLmxldmVsO1xuICB2YXIgZXhhZ2dlcmF0aW9uID0gZGVmYXVsdFZhbHVlKG9wdGlvbnMuZXhhZ2dlcmF0aW9uLCAxLjApO1xuICB2YXIgZXhhZ2dlcmF0aW9uUmVsYXRpdmVIZWlnaHQgPSBkZWZhdWx0VmFsdWUoXG4gICAgb3B0aW9ucy5leGFnZ2VyYXRpb25SZWxhdGl2ZUhlaWdodCxcbiAgICAwLjBcbiAgKTtcblxuICB2YXIgZWxsaXBzb2lkID0gdGlsaW5nU2NoZW1lLmVsbGlwc29pZDtcbiAgdmFyIG5hdGl2ZVJlY3RhbmdsZSA9IHRpbGluZ1NjaGVtZS50aWxlWFlUb05hdGl2ZVJlY3RhbmdsZSh4LCB5LCBsZXZlbCk7XG4gIHZhciByZWN0YW5nbGUgPSB0aWxpbmdTY2hlbWUudGlsZVhZVG9SZWN0YW5nbGUoeCwgeSwgbGV2ZWwpO1xuXG4gIC8vIENvbXB1dGUgdGhlIGNlbnRlciBvZiB0aGUgdGlsZSBmb3IgUlRDIHJlbmRlcmluZy5cbiAgdmFyIGNlbnRlciA9IGVsbGlwc29pZC5jYXJ0b2dyYXBoaWNUb0NhcnRlc2lhbihSZWN0YW5nbGUuY2VudGVyKHJlY3RhbmdsZSkpO1xuXG4gIHZhciBzdHJ1Y3R1cmUgPSB0aGlzLl9zdHJ1Y3R1cmU7XG5cbiAgdmFyIGxldmVsWmVyb01heEVycm9yID0gVGVycmFpblByb3ZpZGVyLmdldEVzdGltYXRlZExldmVsWmVyb0dlb21ldHJpY0Vycm9yRm9yQUhlaWdodG1hcChcbiAgICBlbGxpcHNvaWQsXG4gICAgdGhpcy5fd2lkdGgsXG4gICAgdGlsaW5nU2NoZW1lLmdldE51bWJlck9mWFRpbGVzQXRMZXZlbCgwKVxuICApO1xuICB2YXIgdGhpc0xldmVsTWF4RXJyb3IgPSBsZXZlbFplcm9NYXhFcnJvciAvICgxIDw8IGxldmVsKTtcbiAgdGhpcy5fc2tpcnRIZWlnaHQgPSBNYXRoLm1pbih0aGlzTGV2ZWxNYXhFcnJvciAqIDQuMCwgMTAwMC4wKTtcblxuICB2YXIgcmVzdWx0ID0gSGVpZ2h0bWFwVGVzc2VsbGF0b3IuY29tcHV0ZVZlcnRpY2VzKHtcbiAgICBoZWlnaHRtYXA6IHRoaXMuX2J1ZmZlcixcbiAgICBzdHJ1Y3R1cmU6IHN0cnVjdHVyZSxcbiAgICBpbmNsdWRlV2ViTWVyY2F0b3JUOiB0cnVlLFxuICAgIHdpZHRoOiB0aGlzLl93aWR0aCxcbiAgICBoZWlnaHQ6IHRoaXMuX2hlaWdodCxcbiAgICBuYXRpdmVSZWN0YW5nbGU6IG5hdGl2ZVJlY3RhbmdsZSxcbiAgICByZWN0YW5nbGU6IHJlY3RhbmdsZSxcbiAgICByZWxhdGl2ZVRvQ2VudGVyOiBjZW50ZXIsXG4gICAgZWxsaXBzb2lkOiBlbGxpcHNvaWQsXG4gICAgc2tpcnRIZWlnaHQ6IHRoaXMuX3NraXJ0SGVpZ2h0LFxuICAgIGlzR2VvZ3JhcGhpYzogdGlsaW5nU2NoZW1lLnByb2plY3Rpb24gaW5zdGFuY2VvZiBHZW9ncmFwaGljUHJvamVjdGlvbixcbiAgICBleGFnZ2VyYXRpb246IGV4YWdnZXJhdGlvbixcbiAgICBleGFnZ2VyYXRpb25SZWxhdGl2ZUhlaWdodDogZXhhZ2dlcmF0aW9uUmVsYXRpdmVIZWlnaHQsXG4gIH0pO1xuXG4gIC8vIEZyZWUgbWVtb3J5IHJlY2VpdmVkIGZyb20gc2VydmVyIGFmdGVyIG1lc2ggaXMgY3JlYXRlZC5cbiAgdGhpcy5fYnVmZmVyID0gdW5kZWZpbmVkO1xuXG4gIHZhciBpbmRpY2VzQW5kRWRnZXM7XG4gIGlmICh0aGlzLl9za2lydEhlaWdodCA+IDAuMCkge1xuICAgIGluZGljZXNBbmRFZGdlcyA9IFRlcnJhaW5Qcm92aWRlci5nZXRSZWd1bGFyR3JpZEFuZFNraXJ0SW5kaWNlc0FuZEVkZ2VJbmRpY2VzKFxuICAgICAgdGhpcy5fd2lkdGgsXG4gICAgICB0aGlzLl9oZWlnaHRcbiAgICApO1xuICB9IGVsc2Uge1xuICAgIGluZGljZXNBbmRFZGdlcyA9IFRlcnJhaW5Qcm92aWRlci5nZXRSZWd1bGFyR3JpZEluZGljZXNBbmRFZGdlSW5kaWNlcyhcbiAgICAgIHRoaXMuX3dpZHRoLFxuICAgICAgdGhpcy5faGVpZ2h0XG4gICAgKTtcbiAgfVxuXG4gIHZhciB2ZXJ0ZXhDb3VudFdpdGhvdXRTa2lydHMgPSByZXN1bHQuZ3JpZFdpZHRoICogcmVzdWx0LmdyaWRIZWlnaHQ7XG5cbiAgLy8gTm8gbmVlZCB0byBjbG9uZSBoZXJlIChhcyB3ZSBkbyBpbiB0aGUgYXN5bmMgdmVyc2lvbikgYmVjYXVzZSB0aGUgcmVzdWx0XG4gIC8vIGlzIG5vdCBjb21pbmcgZnJvbSBhIHdlYiB3b3JrZXIuXG4gIHRoaXMuX21lc2ggPSBuZXcgVGVycmFpbk1lc2goXG4gICAgY2VudGVyLFxuICAgIHJlc3VsdC52ZXJ0aWNlcyxcbiAgICBpbmRpY2VzQW5kRWRnZXMuaW5kaWNlcyxcbiAgICBpbmRpY2VzQW5kRWRnZXMuaW5kZXhDb3VudFdpdGhvdXRTa2lydHMsXG4gICAgdmVydGV4Q291bnRXaXRob3V0U2tpcnRzLFxuICAgIHJlc3VsdC5taW5pbXVtSGVpZ2h0LFxuICAgIHJlc3VsdC5tYXhpbXVtSGVpZ2h0LFxuICAgIHJlc3VsdC5ib3VuZGluZ1NwaGVyZTNELFxuICAgIHJlc3VsdC5vY2NsdWRlZVBvaW50SW5TY2FsZWRTcGFjZSxcbiAgICByZXN1bHQuZW5jb2Rpbmcuc3RyaWRlLFxuICAgIHJlc3VsdC5vcmllbnRlZEJvdW5kaW5nQm94LFxuICAgIHJlc3VsdC5lbmNvZGluZyxcbiAgICBpbmRpY2VzQW5kRWRnZXMud2VzdEluZGljZXNTb3V0aFRvTm9ydGgsXG4gICAgaW5kaWNlc0FuZEVkZ2VzLnNvdXRoSW5kaWNlc0Vhc3RUb1dlc3QsXG4gICAgaW5kaWNlc0FuZEVkZ2VzLmVhc3RJbmRpY2VzTm9ydGhUb1NvdXRoLFxuICAgIGluZGljZXNBbmRFZGdlcy5ub3J0aEluZGljZXNXZXN0VG9FYXN0XG4gICk7XG5cbiAgcmV0dXJuIHRoaXMuX21lc2g7XG59O1xuXG4vKipcbiAqIENvbXB1dGVzIHRoZSB0ZXJyYWluIGhlaWdodCBhdCBhIHNwZWNpZmllZCBsb25naXR1ZGUgYW5kIGxhdGl0dWRlLlxuICpcbiAqIEBwYXJhbSB7UmVjdGFuZ2xlfSByZWN0YW5nbGUgVGhlIHJlY3RhbmdsZSBjb3ZlcmVkIGJ5IHRoaXMgdGVycmFpbiBkYXRhLlxuICogQHBhcmFtIHtOdW1iZXJ9IGxvbmdpdHVkZSBUaGUgbG9uZ2l0dWRlIGluIHJhZGlhbnMuXG4gKiBAcGFyYW0ge051bWJlcn0gbGF0aXR1ZGUgVGhlIGxhdGl0dWRlIGluIHJhZGlhbnMuXG4gKiBAcmV0dXJucyB7TnVtYmVyfSBUaGUgdGVycmFpbiBoZWlnaHQgYXQgdGhlIHNwZWNpZmllZCBwb3NpdGlvbi4gIElmIHRoZSBwb3NpdGlvblxuICogICAgICAgICAgaXMgb3V0c2lkZSB0aGUgcmVjdGFuZ2xlLCB0aGlzIG1ldGhvZCB3aWxsIGV4dHJhcG9sYXRlIHRoZSBoZWlnaHQsIHdoaWNoIGlzIGxpa2VseSB0byBiZSB3aWxkbHlcbiAqICAgICAgICAgIGluY29ycmVjdCBmb3IgcG9zaXRpb25zIGZhciBvdXRzaWRlIHRoZSByZWN0YW5nbGUuXG4gKi9cbkhlaWdodG1hcFRlcnJhaW5EYXRhLnByb3RvdHlwZS5pbnRlcnBvbGF0ZUhlaWdodCA9IGZ1bmN0aW9uIChcbiAgcmVjdGFuZ2xlLFxuICBsb25naXR1ZGUsXG4gIGxhdGl0dWRlXG4pIHtcbiAgdmFyIHdpZHRoID0gdGhpcy5fd2lkdGg7XG4gIHZhciBoZWlnaHQgPSB0aGlzLl9oZWlnaHQ7XG5cbiAgdmFyIHN0cnVjdHVyZSA9IHRoaXMuX3N0cnVjdHVyZTtcbiAgdmFyIHN0cmlkZSA9IHN0cnVjdHVyZS5zdHJpZGU7XG4gIHZhciBlbGVtZW50c1BlckhlaWdodCA9IHN0cnVjdHVyZS5lbGVtZW50c1BlckhlaWdodDtcbiAgdmFyIGVsZW1lbnRNdWx0aXBsaWVyID0gc3RydWN0dXJlLmVsZW1lbnRNdWx0aXBsaWVyO1xuICB2YXIgaXNCaWdFbmRpYW4gPSBzdHJ1Y3R1cmUuaXNCaWdFbmRpYW47XG4gIHZhciBoZWlnaHRPZmZzZXQgPSBzdHJ1Y3R1cmUuaGVpZ2h0T2Zmc2V0O1xuICB2YXIgaGVpZ2h0U2NhbGUgPSBzdHJ1Y3R1cmUuaGVpZ2h0U2NhbGU7XG5cbiAgdmFyIGlzTWVzaENyZWF0ZWQgPSBkZWZpbmVkKHRoaXMuX21lc2gpO1xuICB2YXIgaXNMRVJDRW5jb2RpbmcgPSB0aGlzLl9lbmNvZGluZyA9PT0gSGVpZ2h0bWFwRW5jb2RpbmcuTEVSQztcbiAgdmFyIGlzSW50ZXJwb2xhdGlvbkltcG9zc2libGUgPSAhaXNNZXNoQ3JlYXRlZCAmJiBpc0xFUkNFbmNvZGluZztcbiAgaWYgKGlzSW50ZXJwb2xhdGlvbkltcG9zc2libGUpIHtcbiAgICAvLyBXZSBjYW4ndCBpbnRlcnBvbGF0ZSB1c2luZyB0aGUgYnVmZmVyIGJlY2F1c2UgaXQncyBMRVJDIGVuY29kZWRcbiAgICAvLyAgc28gcGxlYXNlIGNhbGwgY3JlYXRlTWVzaCgpIGZpcnN0IGFuZCBpbnRlcnBvbGF0ZSB1c2luZyB0aGUgbWVzaDtcbiAgICAvLyAgYXMgbWVzaCBjcmVhdGlvbiB3aWxsIGRlY29kZSB0aGUgTEVSQyBidWZmZXJcbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG5cbiAgdmFyIGhlaWdodFNhbXBsZTtcbiAgaWYgKGlzTWVzaENyZWF0ZWQpIHtcbiAgICB2YXIgYnVmZmVyID0gdGhpcy5fbWVzaC52ZXJ0aWNlcztcbiAgICB2YXIgZW5jb2RpbmcgPSB0aGlzLl9tZXNoLmVuY29kaW5nO1xuICAgIGhlaWdodFNhbXBsZSA9IGludGVycG9sYXRlTWVzaEhlaWdodChcbiAgICAgIGJ1ZmZlcixcbiAgICAgIGVuY29kaW5nLFxuICAgICAgaGVpZ2h0T2Zmc2V0LFxuICAgICAgaGVpZ2h0U2NhbGUsXG4gICAgICByZWN0YW5nbGUsXG4gICAgICB3aWR0aCxcbiAgICAgIGhlaWdodCxcbiAgICAgIGxvbmdpdHVkZSxcbiAgICAgIGxhdGl0dWRlXG4gICAgKTtcbiAgfSBlbHNlIHtcbiAgICBoZWlnaHRTYW1wbGUgPSBpbnRlcnBvbGF0ZUhlaWdodChcbiAgICAgIHRoaXMuX2J1ZmZlcixcbiAgICAgIGVsZW1lbnRzUGVySGVpZ2h0LFxuICAgICAgZWxlbWVudE11bHRpcGxpZXIsXG4gICAgICBzdHJpZGUsXG4gICAgICBpc0JpZ0VuZGlhbixcbiAgICAgIHJlY3RhbmdsZSxcbiAgICAgIHdpZHRoLFxuICAgICAgaGVpZ2h0LFxuICAgICAgbG9uZ2l0dWRlLFxuICAgICAgbGF0aXR1ZGVcbiAgICApO1xuICAgIGhlaWdodFNhbXBsZSA9IGhlaWdodFNhbXBsZSAqIGhlaWdodFNjYWxlICsgaGVpZ2h0T2Zmc2V0O1xuICB9XG5cbiAgcmV0dXJuIGhlaWdodFNhbXBsZTtcbn07XG5cbi8qKlxuICogVXBzYW1wbGVzIHRoaXMgdGVycmFpbiBkYXRhIGZvciB1c2UgYnkgYSBkZXNjZW5kYW50IHRpbGUuICBUaGUgcmVzdWx0aW5nIGluc3RhbmNlIHdpbGwgY29udGFpbiBhIHN1YnNldCBvZiB0aGVcbiAqIGhlaWdodCBzYW1wbGVzIGluIHRoaXMgaW5zdGFuY2UsIGludGVycG9sYXRlZCBpZiBuZWNlc3NhcnkuXG4gKlxuICogQHBhcmFtIHtUaWxpbmdTY2hlbWV9IHRpbGluZ1NjaGVtZSBUaGUgdGlsaW5nIHNjaGVtZSBvZiB0aGlzIHRlcnJhaW4gZGF0YS5cbiAqIEBwYXJhbSB7TnVtYmVyfSB0aGlzWCBUaGUgWCBjb29yZGluYXRlIG9mIHRoaXMgdGlsZSBpbiB0aGUgdGlsaW5nIHNjaGVtZS5cbiAqIEBwYXJhbSB7TnVtYmVyfSB0aGlzWSBUaGUgWSBjb29yZGluYXRlIG9mIHRoaXMgdGlsZSBpbiB0aGUgdGlsaW5nIHNjaGVtZS5cbiAqIEBwYXJhbSB7TnVtYmVyfSB0aGlzTGV2ZWwgVGhlIGxldmVsIG9mIHRoaXMgdGlsZSBpbiB0aGUgdGlsaW5nIHNjaGVtZS5cbiAqIEBwYXJhbSB7TnVtYmVyfSBkZXNjZW5kYW50WCBUaGUgWCBjb29yZGluYXRlIHdpdGhpbiB0aGUgdGlsaW5nIHNjaGVtZSBvZiB0aGUgZGVzY2VuZGFudCB0aWxlIGZvciB3aGljaCB3ZSBhcmUgdXBzYW1wbGluZy5cbiAqIEBwYXJhbSB7TnVtYmVyfSBkZXNjZW5kYW50WSBUaGUgWSBjb29yZGluYXRlIHdpdGhpbiB0aGUgdGlsaW5nIHNjaGVtZSBvZiB0aGUgZGVzY2VuZGFudCB0aWxlIGZvciB3aGljaCB3ZSBhcmUgdXBzYW1wbGluZy5cbiAqIEBwYXJhbSB7TnVtYmVyfSBkZXNjZW5kYW50TGV2ZWwgVGhlIGxldmVsIHdpdGhpbiB0aGUgdGlsaW5nIHNjaGVtZSBvZiB0aGUgZGVzY2VuZGFudCB0aWxlIGZvciB3aGljaCB3ZSBhcmUgdXBzYW1wbGluZy5cbiAqIEByZXR1cm5zIHtQcm9taXNlLjxIZWlnaHRtYXBUZXJyYWluRGF0YT58dW5kZWZpbmVkfSBBIHByb21pc2UgZm9yIHVwc2FtcGxlZCBoZWlnaHRtYXAgdGVycmFpbiBkYXRhIGZvciB0aGUgZGVzY2VuZGFudCB0aWxlLFxuICogICAgICAgICAgb3IgdW5kZWZpbmVkIGlmIHRvbyBtYW55IGFzeW5jaHJvbm91cyB1cHNhbXBsZSBvcGVyYXRpb25zIGFyZSBpbiBwcm9ncmVzcyBhbmQgdGhlIHJlcXVlc3QgaGFzIGJlZW5cbiAqICAgICAgICAgIGRlZmVycmVkLlxuICovXG5IZWlnaHRtYXBUZXJyYWluRGF0YS5wcm90b3R5cGUudXBzYW1wbGUgPSBmdW5jdGlvbiAoXG4gIHRpbGluZ1NjaGVtZSxcbiAgdGhpc1gsXG4gIHRoaXNZLFxuICB0aGlzTGV2ZWwsXG4gIGRlc2NlbmRhbnRYLFxuICBkZXNjZW5kYW50WSxcbiAgZGVzY2VuZGFudExldmVsXG4pIHtcbiAgLy8+PmluY2x1ZGVTdGFydCgnZGVidWcnLCBwcmFnbWFzLmRlYnVnKTtcbiAgaWYgKCFkZWZpbmVkKHRpbGluZ1NjaGVtZSkpIHtcbiAgICB0aHJvdyBuZXcgRGV2ZWxvcGVyRXJyb3IoXCJ0aWxpbmdTY2hlbWUgaXMgcmVxdWlyZWQuXCIpO1xuICB9XG4gIGlmICghZGVmaW5lZCh0aGlzWCkpIHtcbiAgICB0aHJvdyBuZXcgRGV2ZWxvcGVyRXJyb3IoXCJ0aGlzWCBpcyByZXF1aXJlZC5cIik7XG4gIH1cbiAgaWYgKCFkZWZpbmVkKHRoaXNZKSkge1xuICAgIHRocm93IG5ldyBEZXZlbG9wZXJFcnJvcihcInRoaXNZIGlzIHJlcXVpcmVkLlwiKTtcbiAgfVxuICBpZiAoIWRlZmluZWQodGhpc0xldmVsKSkge1xuICAgIHRocm93IG5ldyBEZXZlbG9wZXJFcnJvcihcInRoaXNMZXZlbCBpcyByZXF1aXJlZC5cIik7XG4gIH1cbiAgaWYgKCFkZWZpbmVkKGRlc2NlbmRhbnRYKSkge1xuICAgIHRocm93IG5ldyBEZXZlbG9wZXJFcnJvcihcImRlc2NlbmRhbnRYIGlzIHJlcXVpcmVkLlwiKTtcbiAgfVxuICBpZiAoIWRlZmluZWQoZGVzY2VuZGFudFkpKSB7XG4gICAgdGhyb3cgbmV3IERldmVsb3BlckVycm9yKFwiZGVzY2VuZGFudFkgaXMgcmVxdWlyZWQuXCIpO1xuICB9XG4gIGlmICghZGVmaW5lZChkZXNjZW5kYW50TGV2ZWwpKSB7XG4gICAgdGhyb3cgbmV3IERldmVsb3BlckVycm9yKFwiZGVzY2VuZGFudExldmVsIGlzIHJlcXVpcmVkLlwiKTtcbiAgfVxuICB2YXIgbGV2ZWxEaWZmZXJlbmNlID0gZGVzY2VuZGFudExldmVsIC0gdGhpc0xldmVsO1xuICBpZiAobGV2ZWxEaWZmZXJlbmNlID4gMSkge1xuICAgIHRocm93IG5ldyBEZXZlbG9wZXJFcnJvcihcbiAgICAgIFwiVXBzYW1wbGluZyB0aHJvdWdoIG1vcmUgdGhhbiBvbmUgbGV2ZWwgYXQgYSB0aW1lIGlzIG5vdCBjdXJyZW50bHkgc3VwcG9ydGVkLlwiXG4gICAgKTtcbiAgfVxuICAvLz4+aW5jbHVkZUVuZCgnZGVidWcnKTtcblxuICB2YXIgbWVzaERhdGEgPSB0aGlzLl9tZXNoO1xuICBpZiAoIWRlZmluZWQobWVzaERhdGEpKSB7XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxuXG4gIHZhciB3aWR0aCA9IHRoaXMuX3dpZHRoO1xuICB2YXIgaGVpZ2h0ID0gdGhpcy5faGVpZ2h0O1xuICB2YXIgc3RydWN0dXJlID0gdGhpcy5fc3RydWN0dXJlO1xuICB2YXIgc3RyaWRlID0gc3RydWN0dXJlLnN0cmlkZTtcblxuICB2YXIgaGVpZ2h0cyA9IG5ldyB0aGlzLl9idWZmZXJUeXBlKHdpZHRoICogaGVpZ2h0ICogc3RyaWRlKTtcblxuICB2YXIgYnVmZmVyID0gbWVzaERhdGEudmVydGljZXM7XG4gIHZhciBlbmNvZGluZyA9IG1lc2hEYXRhLmVuY29kaW5nO1xuXG4gIC8vIFBFUkZPUk1BTkNFX0lERUE6IGRvbid0IHJlY29tcHV0ZSB0aGVzZSByZWN0YW5nbGVzIC0gdGhlIGNhbGxlciBhbHJlYWR5IGtub3dzIHRoZW0uXG4gIHZhciBzb3VyY2VSZWN0YW5nbGUgPSB0aWxpbmdTY2hlbWUudGlsZVhZVG9SZWN0YW5nbGUodGhpc1gsIHRoaXNZLCB0aGlzTGV2ZWwpO1xuICB2YXIgZGVzdGluYXRpb25SZWN0YW5nbGUgPSB0aWxpbmdTY2hlbWUudGlsZVhZVG9SZWN0YW5nbGUoXG4gICAgZGVzY2VuZGFudFgsXG4gICAgZGVzY2VuZGFudFksXG4gICAgZGVzY2VuZGFudExldmVsXG4gICk7XG5cbiAgdmFyIGhlaWdodE9mZnNldCA9IHN0cnVjdHVyZS5oZWlnaHRPZmZzZXQ7XG4gIHZhciBoZWlnaHRTY2FsZSA9IHN0cnVjdHVyZS5oZWlnaHRTY2FsZTtcblxuICB2YXIgZWxlbWVudHNQZXJIZWlnaHQgPSBzdHJ1Y3R1cmUuZWxlbWVudHNQZXJIZWlnaHQ7XG4gIHZhciBlbGVtZW50TXVsdGlwbGllciA9IHN0cnVjdHVyZS5lbGVtZW50TXVsdGlwbGllcjtcbiAgdmFyIGlzQmlnRW5kaWFuID0gc3RydWN0dXJlLmlzQmlnRW5kaWFuO1xuXG4gIHZhciBkaXZpc29yID0gTWF0aC5wb3coZWxlbWVudE11bHRpcGxpZXIsIGVsZW1lbnRzUGVySGVpZ2h0IC0gMSk7XG5cbiAgZm9yICh2YXIgaiA9IDA7IGogPCBoZWlnaHQ7ICsraikge1xuICAgIHZhciBsYXRpdHVkZSA9IENlc2l1bU1hdGgubGVycChcbiAgICAgIGRlc3RpbmF0aW9uUmVjdGFuZ2xlLm5vcnRoLFxuICAgICAgZGVzdGluYXRpb25SZWN0YW5nbGUuc291dGgsXG4gICAgICBqIC8gKGhlaWdodCAtIDEpXG4gICAgKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHdpZHRoOyArK2kpIHtcbiAgICAgIHZhciBsb25naXR1ZGUgPSBDZXNpdW1NYXRoLmxlcnAoXG4gICAgICAgIGRlc3RpbmF0aW9uUmVjdGFuZ2xlLndlc3QsXG4gICAgICAgIGRlc3RpbmF0aW9uUmVjdGFuZ2xlLmVhc3QsXG4gICAgICAgIGkgLyAod2lkdGggLSAxKVxuICAgICAgKTtcbiAgICAgIHZhciBoZWlnaHRTYW1wbGUgPSBpbnRlcnBvbGF0ZU1lc2hIZWlnaHQoXG4gICAgICAgIGJ1ZmZlcixcbiAgICAgICAgZW5jb2RpbmcsXG4gICAgICAgIGhlaWdodE9mZnNldCxcbiAgICAgICAgaGVpZ2h0U2NhbGUsXG4gICAgICAgIHNvdXJjZVJlY3RhbmdsZSxcbiAgICAgICAgd2lkdGgsXG4gICAgICAgIGhlaWdodCxcbiAgICAgICAgbG9uZ2l0dWRlLFxuICAgICAgICBsYXRpdHVkZVxuICAgICAgKTtcblxuICAgICAgLy8gVXNlIGNvbmRpdGlvbmFscyBoZXJlIGluc3RlYWQgb2YgTWF0aC5taW4gYW5kIE1hdGgubWF4IHNvIHRoYXQgYW4gdW5kZWZpbmVkXG4gICAgICAvLyBsb3dlc3RFbmNvZGVkSGVpZ2h0IG9yIGhpZ2hlc3RFbmNvZGVkSGVpZ2h0IGhhcyBubyBlZmZlY3QuXG4gICAgICBoZWlnaHRTYW1wbGUgPVxuICAgICAgICBoZWlnaHRTYW1wbGUgPCBzdHJ1Y3R1cmUubG93ZXN0RW5jb2RlZEhlaWdodFxuICAgICAgICAgID8gc3RydWN0dXJlLmxvd2VzdEVuY29kZWRIZWlnaHRcbiAgICAgICAgICA6IGhlaWdodFNhbXBsZTtcbiAgICAgIGhlaWdodFNhbXBsZSA9XG4gICAgICAgIGhlaWdodFNhbXBsZSA+IHN0cnVjdHVyZS5oaWdoZXN0RW5jb2RlZEhlaWdodFxuICAgICAgICAgID8gc3RydWN0dXJlLmhpZ2hlc3RFbmNvZGVkSGVpZ2h0XG4gICAgICAgICAgOiBoZWlnaHRTYW1wbGU7XG5cbiAgICAgIHNldEhlaWdodChcbiAgICAgICAgaGVpZ2h0cyxcbiAgICAgICAgZWxlbWVudHNQZXJIZWlnaHQsXG4gICAgICAgIGVsZW1lbnRNdWx0aXBsaWVyLFxuICAgICAgICBkaXZpc29yLFxuICAgICAgICBzdHJpZGUsXG4gICAgICAgIGlzQmlnRW5kaWFuLFxuICAgICAgICBqICogd2lkdGggKyBpLFxuICAgICAgICBoZWlnaHRTYW1wbGVcbiAgICAgICk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG5ldyBIZWlnaHRtYXBUZXJyYWluRGF0YSh7XG4gICAgYnVmZmVyOiBoZWlnaHRzLFxuICAgIHdpZHRoOiB3aWR0aCxcbiAgICBoZWlnaHQ6IGhlaWdodCxcbiAgICBjaGlsZFRpbGVNYXNrOiAwLFxuICAgIHN0cnVjdHVyZTogdGhpcy5fc3RydWN0dXJlLFxuICAgIGNyZWF0ZWRCeVVwc2FtcGxpbmc6IHRydWUsXG4gIH0pO1xufTtcblxuLyoqXG4gKiBEZXRlcm1pbmVzIGlmIGEgZ2l2ZW4gY2hpbGQgdGlsZSBpcyBhdmFpbGFibGUsIGJhc2VkIG9uIHRoZVxuICoge0BsaW5rIEhlaWdodG1hcFRlcnJhaW5EYXRhLmNoaWxkVGlsZU1hc2t9LiAgVGhlIGdpdmVuIGNoaWxkIHRpbGUgY29vcmRpbmF0ZXMgYXJlIGFzc3VtZWRcbiAqIHRvIGJlIG9uZSBvZiB0aGUgZm91ciBjaGlsZHJlbiBvZiB0aGlzIHRpbGUuICBJZiBub24tY2hpbGQgdGlsZSBjb29yZGluYXRlcyBhcmVcbiAqIGdpdmVuLCB0aGUgYXZhaWxhYmlsaXR5IG9mIHRoZSBzb3V0aGVhc3QgY2hpbGQgdGlsZSBpcyByZXR1cm5lZC5cbiAqXG4gKiBAcGFyYW0ge051bWJlcn0gdGhpc1ggVGhlIHRpbGUgWCBjb29yZGluYXRlIG9mIHRoaXMgKHRoZSBwYXJlbnQpIHRpbGUuXG4gKiBAcGFyYW0ge051bWJlcn0gdGhpc1kgVGhlIHRpbGUgWSBjb29yZGluYXRlIG9mIHRoaXMgKHRoZSBwYXJlbnQpIHRpbGUuXG4gKiBAcGFyYW0ge051bWJlcn0gY2hpbGRYIFRoZSB0aWxlIFggY29vcmRpbmF0ZSBvZiB0aGUgY2hpbGQgdGlsZSB0byBjaGVjayBmb3IgYXZhaWxhYmlsaXR5LlxuICogQHBhcmFtIHtOdW1iZXJ9IGNoaWxkWSBUaGUgdGlsZSBZIGNvb3JkaW5hdGUgb2YgdGhlIGNoaWxkIHRpbGUgdG8gY2hlY2sgZm9yIGF2YWlsYWJpbGl0eS5cbiAqIEByZXR1cm5zIHtCb29sZWFufSBUcnVlIGlmIHRoZSBjaGlsZCB0aWxlIGlzIGF2YWlsYWJsZTsgb3RoZXJ3aXNlLCBmYWxzZS5cbiAqL1xuSGVpZ2h0bWFwVGVycmFpbkRhdGEucHJvdG90eXBlLmlzQ2hpbGRBdmFpbGFibGUgPSBmdW5jdGlvbiAoXG4gIHRoaXNYLFxuICB0aGlzWSxcbiAgY2hpbGRYLFxuICBjaGlsZFlcbikge1xuICAvLz4+aW5jbHVkZVN0YXJ0KCdkZWJ1ZycsIHByYWdtYXMuZGVidWcpO1xuICBpZiAoIWRlZmluZWQodGhpc1gpKSB7XG4gICAgdGhyb3cgbmV3IERldmVsb3BlckVycm9yKFwidGhpc1ggaXMgcmVxdWlyZWQuXCIpO1xuICB9XG4gIGlmICghZGVmaW5lZCh0aGlzWSkpIHtcbiAgICB0aHJvdyBuZXcgRGV2ZWxvcGVyRXJyb3IoXCJ0aGlzWSBpcyByZXF1aXJlZC5cIik7XG4gIH1cbiAgaWYgKCFkZWZpbmVkKGNoaWxkWCkpIHtcbiAgICB0aHJvdyBuZXcgRGV2ZWxvcGVyRXJyb3IoXCJjaGlsZFggaXMgcmVxdWlyZWQuXCIpO1xuICB9XG4gIGlmICghZGVmaW5lZChjaGlsZFkpKSB7XG4gICAgdGhyb3cgbmV3IERldmVsb3BlckVycm9yKFwiY2hpbGRZIGlzIHJlcXVpcmVkLlwiKTtcbiAgfVxuICAvLz4+aW5jbHVkZUVuZCgnZGVidWcnKTtcblxuICB2YXIgYml0TnVtYmVyID0gMjsgLy8gbm9ydGh3ZXN0IGNoaWxkXG4gIGlmIChjaGlsZFggIT09IHRoaXNYICogMikge1xuICAgICsrYml0TnVtYmVyOyAvLyBlYXN0IGNoaWxkXG4gIH1cbiAgaWYgKGNoaWxkWSAhPT0gdGhpc1kgKiAyKSB7XG4gICAgYml0TnVtYmVyIC09IDI7IC8vIHNvdXRoIGNoaWxkXG4gIH1cblxuICByZXR1cm4gKHRoaXMuX2NoaWxkVGlsZU1hc2sgJiAoMSA8PCBiaXROdW1iZXIpKSAhPT0gMDtcbn07XG5cbi8qKlxuICogR2V0cyBhIHZhbHVlIGluZGljYXRpbmcgd2hldGhlciBvciBub3QgdGhpcyB0ZXJyYWluIGRhdGEgd2FzIGNyZWF0ZWQgYnkgdXBzYW1wbGluZyBsb3dlciByZXNvbHV0aW9uXG4gKiB0ZXJyYWluIGRhdGEuICBJZiB0aGlzIHZhbHVlIGlzIGZhbHNlLCB0aGUgZGF0YSB3YXMgb2J0YWluZWQgZnJvbSBzb21lIG90aGVyIHNvdXJjZSwgc3VjaFxuICogYXMgYnkgZG93bmxvYWRpbmcgaXQgZnJvbSBhIHJlbW90ZSBzZXJ2ZXIuICBUaGlzIG1ldGhvZCBzaG91bGQgcmV0dXJuIHRydWUgZm9yIGluc3RhbmNlc1xuICogcmV0dXJuZWQgZnJvbSBhIGNhbGwgdG8ge0BsaW5rIEhlaWdodG1hcFRlcnJhaW5EYXRhI3Vwc2FtcGxlfS5cbiAqXG4gKiBAcmV0dXJucyB7Qm9vbGVhbn0gVHJ1ZSBpZiB0aGlzIGluc3RhbmNlIHdhcyBjcmVhdGVkIGJ5IHVwc2FtcGxpbmc7IG90aGVyd2lzZSwgZmFsc2UuXG4gKi9cbkhlaWdodG1hcFRlcnJhaW5EYXRhLnByb3RvdHlwZS53YXNDcmVhdGVkQnlVcHNhbXBsaW5nID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy5fY3JlYXRlZEJ5VXBzYW1wbGluZztcbn07XG5cbmZ1bmN0aW9uIGludGVycG9sYXRlSGVpZ2h0KFxuICBzb3VyY2VIZWlnaHRzLFxuICBlbGVtZW50c1BlckhlaWdodCxcbiAgZWxlbWVudE11bHRpcGxpZXIsXG4gIHN0cmlkZSxcbiAgaXNCaWdFbmRpYW4sXG4gIHNvdXJjZVJlY3RhbmdsZSxcbiAgd2lkdGgsXG4gIGhlaWdodCxcbiAgbG9uZ2l0dWRlLFxuICBsYXRpdHVkZVxuKSB7XG4gIHZhciBmcm9tV2VzdCA9XG4gICAgKChsb25naXR1ZGUgLSBzb3VyY2VSZWN0YW5nbGUud2VzdCkgKiAod2lkdGggLSAxKSkgL1xuICAgIChzb3VyY2VSZWN0YW5nbGUuZWFzdCAtIHNvdXJjZVJlY3RhbmdsZS53ZXN0KTtcbiAgdmFyIGZyb21Tb3V0aCA9XG4gICAgKChsYXRpdHVkZSAtIHNvdXJjZVJlY3RhbmdsZS5zb3V0aCkgKiAoaGVpZ2h0IC0gMSkpIC9cbiAgICAoc291cmNlUmVjdGFuZ2xlLm5vcnRoIC0gc291cmNlUmVjdGFuZ2xlLnNvdXRoKTtcblxuICB2YXIgd2VzdEludGVnZXIgPSBmcm9tV2VzdCB8IDA7XG4gIHZhciBlYXN0SW50ZWdlciA9IHdlc3RJbnRlZ2VyICsgMTtcbiAgaWYgKGVhc3RJbnRlZ2VyID49IHdpZHRoKSB7XG4gICAgZWFzdEludGVnZXIgPSB3aWR0aCAtIDE7XG4gICAgd2VzdEludGVnZXIgPSB3aWR0aCAtIDI7XG4gIH1cblxuICB2YXIgc291dGhJbnRlZ2VyID0gZnJvbVNvdXRoIHwgMDtcbiAgdmFyIG5vcnRoSW50ZWdlciA9IHNvdXRoSW50ZWdlciArIDE7XG4gIGlmIChub3J0aEludGVnZXIgPj0gaGVpZ2h0KSB7XG4gICAgbm9ydGhJbnRlZ2VyID0gaGVpZ2h0IC0gMTtcbiAgICBzb3V0aEludGVnZXIgPSBoZWlnaHQgLSAyO1xuICB9XG5cbiAgdmFyIGR4ID0gZnJvbVdlc3QgLSB3ZXN0SW50ZWdlcjtcbiAgdmFyIGR5ID0gZnJvbVNvdXRoIC0gc291dGhJbnRlZ2VyO1xuXG4gIHNvdXRoSW50ZWdlciA9IGhlaWdodCAtIDEgLSBzb3V0aEludGVnZXI7XG4gIG5vcnRoSW50ZWdlciA9IGhlaWdodCAtIDEgLSBub3J0aEludGVnZXI7XG5cbiAgdmFyIHNvdXRod2VzdEhlaWdodCA9IGdldEhlaWdodChcbiAgICBzb3VyY2VIZWlnaHRzLFxuICAgIGVsZW1lbnRzUGVySGVpZ2h0LFxuICAgIGVsZW1lbnRNdWx0aXBsaWVyLFxuICAgIHN0cmlkZSxcbiAgICBpc0JpZ0VuZGlhbixcbiAgICBzb3V0aEludGVnZXIgKiB3aWR0aCArIHdlc3RJbnRlZ2VyXG4gICk7XG4gIHZhciBzb3V0aGVhc3RIZWlnaHQgPSBnZXRIZWlnaHQoXG4gICAgc291cmNlSGVpZ2h0cyxcbiAgICBlbGVtZW50c1BlckhlaWdodCxcbiAgICBlbGVtZW50TXVsdGlwbGllcixcbiAgICBzdHJpZGUsXG4gICAgaXNCaWdFbmRpYW4sXG4gICAgc291dGhJbnRlZ2VyICogd2lkdGggKyBlYXN0SW50ZWdlclxuICApO1xuICB2YXIgbm9ydGh3ZXN0SGVpZ2h0ID0gZ2V0SGVpZ2h0KFxuICAgIHNvdXJjZUhlaWdodHMsXG4gICAgZWxlbWVudHNQZXJIZWlnaHQsXG4gICAgZWxlbWVudE11bHRpcGxpZXIsXG4gICAgc3RyaWRlLFxuICAgIGlzQmlnRW5kaWFuLFxuICAgIG5vcnRoSW50ZWdlciAqIHdpZHRoICsgd2VzdEludGVnZXJcbiAgKTtcbiAgdmFyIG5vcnRoZWFzdEhlaWdodCA9IGdldEhlaWdodChcbiAgICBzb3VyY2VIZWlnaHRzLFxuICAgIGVsZW1lbnRzUGVySGVpZ2h0LFxuICAgIGVsZW1lbnRNdWx0aXBsaWVyLFxuICAgIHN0cmlkZSxcbiAgICBpc0JpZ0VuZGlhbixcbiAgICBub3J0aEludGVnZXIgKiB3aWR0aCArIGVhc3RJbnRlZ2VyXG4gICk7XG5cbiAgcmV0dXJuIHRyaWFuZ2xlSW50ZXJwb2xhdGVIZWlnaHQoXG4gICAgZHgsXG4gICAgZHksXG4gICAgc291dGh3ZXN0SGVpZ2h0LFxuICAgIHNvdXRoZWFzdEhlaWdodCxcbiAgICBub3J0aHdlc3RIZWlnaHQsXG4gICAgbm9ydGhlYXN0SGVpZ2h0XG4gICk7XG59XG5cbmZ1bmN0aW9uIGludGVycG9sYXRlTWVzaEhlaWdodChcbiAgYnVmZmVyLFxuICBlbmNvZGluZyxcbiAgaGVpZ2h0T2Zmc2V0LFxuICBoZWlnaHRTY2FsZSxcbiAgc291cmNlUmVjdGFuZ2xlLFxuICB3aWR0aCxcbiAgaGVpZ2h0LFxuICBsb25naXR1ZGUsXG4gIGxhdGl0dWRlXG4pIHtcbiAgLy8gcmV0dXJucyBhIGhlaWdodCBlbmNvZGVkIGFjY29yZGluZyB0byB0aGUgc3RydWN0dXJlJ3MgaGVpZ2h0U2NhbGUgYW5kIGhlaWdodE9mZnNldC5cbiAgdmFyIGZyb21XZXN0ID1cbiAgICAoKGxvbmdpdHVkZSAtIHNvdXJjZVJlY3RhbmdsZS53ZXN0KSAqICh3aWR0aCAtIDEpKSAvXG4gICAgKHNvdXJjZVJlY3RhbmdsZS5lYXN0IC0gc291cmNlUmVjdGFuZ2xlLndlc3QpO1xuICB2YXIgZnJvbVNvdXRoID1cbiAgICAoKGxhdGl0dWRlIC0gc291cmNlUmVjdGFuZ2xlLnNvdXRoKSAqIChoZWlnaHQgLSAxKSkgL1xuICAgIChzb3VyY2VSZWN0YW5nbGUubm9ydGggLSBzb3VyY2VSZWN0YW5nbGUuc291dGgpO1xuXG4gIHZhciB3ZXN0SW50ZWdlciA9IGZyb21XZXN0IHwgMDtcbiAgdmFyIGVhc3RJbnRlZ2VyID0gd2VzdEludGVnZXIgKyAxO1xuICBpZiAoZWFzdEludGVnZXIgPj0gd2lkdGgpIHtcbiAgICBlYXN0SW50ZWdlciA9IHdpZHRoIC0gMTtcbiAgICB3ZXN0SW50ZWdlciA9IHdpZHRoIC0gMjtcbiAgfVxuXG4gIHZhciBzb3V0aEludGVnZXIgPSBmcm9tU291dGggfCAwO1xuICB2YXIgbm9ydGhJbnRlZ2VyID0gc291dGhJbnRlZ2VyICsgMTtcbiAgaWYgKG5vcnRoSW50ZWdlciA+PSBoZWlnaHQpIHtcbiAgICBub3J0aEludGVnZXIgPSBoZWlnaHQgLSAxO1xuICAgIHNvdXRoSW50ZWdlciA9IGhlaWdodCAtIDI7XG4gIH1cblxuICB2YXIgZHggPSBmcm9tV2VzdCAtIHdlc3RJbnRlZ2VyO1xuICB2YXIgZHkgPSBmcm9tU291dGggLSBzb3V0aEludGVnZXI7XG5cbiAgc291dGhJbnRlZ2VyID0gaGVpZ2h0IC0gMSAtIHNvdXRoSW50ZWdlcjtcbiAgbm9ydGhJbnRlZ2VyID0gaGVpZ2h0IC0gMSAtIG5vcnRoSW50ZWdlcjtcblxuICB2YXIgc291dGh3ZXN0SGVpZ2h0ID1cbiAgICAoZW5jb2RpbmcuZGVjb2RlSGVpZ2h0KGJ1ZmZlciwgc291dGhJbnRlZ2VyICogd2lkdGggKyB3ZXN0SW50ZWdlcikgLVxuICAgICAgaGVpZ2h0T2Zmc2V0KSAvXG4gICAgaGVpZ2h0U2NhbGU7XG4gIHZhciBzb3V0aGVhc3RIZWlnaHQgPVxuICAgIChlbmNvZGluZy5kZWNvZGVIZWlnaHQoYnVmZmVyLCBzb3V0aEludGVnZXIgKiB3aWR0aCArIGVhc3RJbnRlZ2VyKSAtXG4gICAgICBoZWlnaHRPZmZzZXQpIC9cbiAgICBoZWlnaHRTY2FsZTtcbiAgdmFyIG5vcnRod2VzdEhlaWdodCA9XG4gICAgKGVuY29kaW5nLmRlY29kZUhlaWdodChidWZmZXIsIG5vcnRoSW50ZWdlciAqIHdpZHRoICsgd2VzdEludGVnZXIpIC1cbiAgICAgIGhlaWdodE9mZnNldCkgL1xuICAgIGhlaWdodFNjYWxlO1xuICB2YXIgbm9ydGhlYXN0SGVpZ2h0ID1cbiAgICAoZW5jb2RpbmcuZGVjb2RlSGVpZ2h0KGJ1ZmZlciwgbm9ydGhJbnRlZ2VyICogd2lkdGggKyBlYXN0SW50ZWdlcikgLVxuICAgICAgaGVpZ2h0T2Zmc2V0KSAvXG4gICAgaGVpZ2h0U2NhbGU7XG5cbiAgcmV0dXJuIHRyaWFuZ2xlSW50ZXJwb2xhdGVIZWlnaHQoXG4gICAgZHgsXG4gICAgZHksXG4gICAgc291dGh3ZXN0SGVpZ2h0LFxuICAgIHNvdXRoZWFzdEhlaWdodCxcbiAgICBub3J0aHdlc3RIZWlnaHQsXG4gICAgbm9ydGhlYXN0SGVpZ2h0XG4gICk7XG59XG5cbmZ1bmN0aW9uIHRyaWFuZ2xlSW50ZXJwb2xhdGVIZWlnaHQoXG4gIGRYLFxuICBkWSxcbiAgc291dGh3ZXN0SGVpZ2h0LFxuICBzb3V0aGVhc3RIZWlnaHQsXG4gIG5vcnRod2VzdEhlaWdodCxcbiAgbm9ydGhlYXN0SGVpZ2h0XG4pIHtcbiAgLy8gVGhlIEhlaWdodG1hcFRlc3NlbGxhdG9yIGJpc2VjdHMgdGhlIHF1YWQgZnJvbSBzb3V0aHdlc3QgdG8gbm9ydGhlYXN0LlxuICBpZiAoZFkgPCBkWCkge1xuICAgIC8vIExvd2VyIHJpZ2h0IHRyaWFuZ2xlXG4gICAgcmV0dXJuIChcbiAgICAgIHNvdXRod2VzdEhlaWdodCArXG4gICAgICBkWCAqIChzb3V0aGVhc3RIZWlnaHQgLSBzb3V0aHdlc3RIZWlnaHQpICtcbiAgICAgIGRZICogKG5vcnRoZWFzdEhlaWdodCAtIHNvdXRoZWFzdEhlaWdodClcbiAgICApO1xuICB9XG5cbiAgLy8gVXBwZXIgbGVmdCB0cmlhbmdsZVxuICByZXR1cm4gKFxuICAgIHNvdXRod2VzdEhlaWdodCArXG4gICAgZFggKiAobm9ydGhlYXN0SGVpZ2h0IC0gbm9ydGh3ZXN0SGVpZ2h0KSArXG4gICAgZFkgKiAobm9ydGh3ZXN0SGVpZ2h0IC0gc291dGh3ZXN0SGVpZ2h0KVxuICApO1xufVxuXG5mdW5jdGlvbiBnZXRIZWlnaHQoXG4gIGhlaWdodHMsXG4gIGVsZW1lbnRzUGVySGVpZ2h0LFxuICBlbGVtZW50TXVsdGlwbGllcixcbiAgc3RyaWRlLFxuICBpc0JpZ0VuZGlhbixcbiAgaW5kZXhcbikge1xuICBpbmRleCAqPSBzdHJpZGU7XG5cbiAgdmFyIGhlaWdodCA9IDA7XG4gIHZhciBpO1xuXG4gIGlmIChpc0JpZ0VuZGlhbikge1xuICAgIGZvciAoaSA9IDA7IGkgPCBlbGVtZW50c1BlckhlaWdodDsgKytpKSB7XG4gICAgICBoZWlnaHQgPSBoZWlnaHQgKiBlbGVtZW50TXVsdGlwbGllciArIGhlaWdodHNbaW5kZXggKyBpXTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgZm9yIChpID0gZWxlbWVudHNQZXJIZWlnaHQgLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgaGVpZ2h0ID0gaGVpZ2h0ICogZWxlbWVudE11bHRpcGxpZXIgKyBoZWlnaHRzW2luZGV4ICsgaV07XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGhlaWdodDtcbn1cblxuZnVuY3Rpb24gc2V0SGVpZ2h0KFxuICBoZWlnaHRzLFxuICBlbGVtZW50c1BlckhlaWdodCxcbiAgZWxlbWVudE11bHRpcGxpZXIsXG4gIGRpdmlzb3IsXG4gIHN0cmlkZSxcbiAgaXNCaWdFbmRpYW4sXG4gIGluZGV4LFxuICBoZWlnaHRcbikge1xuICBpbmRleCAqPSBzdHJpZGU7XG5cbiAgdmFyIGk7XG4gIGlmIChpc0JpZ0VuZGlhbikge1xuICAgIGZvciAoaSA9IDA7IGkgPCBlbGVtZW50c1BlckhlaWdodCAtIDE7ICsraSkge1xuICAgICAgaGVpZ2h0c1tpbmRleCArIGldID0gKGhlaWdodCAvIGRpdmlzb3IpIHwgMDtcbiAgICAgIGhlaWdodCAtPSBoZWlnaHRzW2luZGV4ICsgaV0gKiBkaXZpc29yO1xuICAgICAgZGl2aXNvciAvPSBlbGVtZW50TXVsdGlwbGllcjtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgZm9yIChpID0gZWxlbWVudHNQZXJIZWlnaHQgLSAxOyBpID4gMDsgLS1pKSB7XG4gICAgICBoZWlnaHRzW2luZGV4ICsgaV0gPSAoaGVpZ2h0IC8gZGl2aXNvcikgfCAwO1xuICAgICAgaGVpZ2h0IC09IGhlaWdodHNbaW5kZXggKyBpXSAqIGRpdmlzb3I7XG4gICAgICBkaXZpc29yIC89IGVsZW1lbnRNdWx0aXBsaWVyO1xuICAgIH1cbiAgfVxuICBoZWlnaHRzW2luZGV4ICsgaV0gPSBoZWlnaHQ7XG59XG5leHBvcnQgZGVmYXVsdCBIZWlnaHRtYXBUZXJyYWluRGF0YTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///57134\n')},25260:function(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__){eval('/* harmony import */ var _AxisAlignedBoundingBox_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(55829);\n/* harmony import */ var _BoundingSphere_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(48243);\n/* harmony import */ var _Cartesian2_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(60838);\n/* harmony import */ var _Cartesian3_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(60216);\n/* harmony import */ var _defaultValue_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(62200);\n/* harmony import */ var _defined_js__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(82982);\n/* harmony import */ var _DeveloperError_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(12572);\n/* harmony import */ var _Ellipsoid_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(50491);\n/* harmony import */ var _EllipsoidalOccluder_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(61252);\n/* harmony import */ var _Math_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(99417);\n/* harmony import */ var _Matrix4_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(72248);\n/* harmony import */ var _OrientedBoundingBox_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(25405);\n/* harmony import */ var _Rectangle_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(96190);\n/* harmony import */ var _TerrainEncoding_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(41782);\n/* harmony import */ var _Transforms_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(95555);\n/* harmony import */ var _WebMercatorProjection_js__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(79962);\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n/**\n * Contains functions to create a mesh from a heightmap image.\n *\n * @namespace HeightmapTessellator\n *\n * @private\n */\nvar HeightmapTessellator = {};\n\n/**\n * The default structure of a heightmap, as given to {@link HeightmapTessellator.computeVertices}.\n *\n * @constant\n */\nHeightmapTessellator.DEFAULT_STRUCTURE = Object.freeze({\n  heightScale: 1.0,\n  heightOffset: 0.0,\n  elementsPerHeight: 1,\n  stride: 1,\n  elementMultiplier: 256.0,\n  isBigEndian: false,\n});\n\nvar cartesian3Scratch = new _Cartesian3_js__WEBPACK_IMPORTED_MODULE_3__/* ["default"] */ .Z();\nvar matrix4Scratch = new _Matrix4_js__WEBPACK_IMPORTED_MODULE_9__/* ["default"] */ .Z();\nvar minimumScratch = new _Cartesian3_js__WEBPACK_IMPORTED_MODULE_3__/* ["default"] */ .Z();\nvar maximumScratch = new _Cartesian3_js__WEBPACK_IMPORTED_MODULE_3__/* ["default"] */ .Z();\n\n/**\n * Fills an array of vertices from a heightmap image.\n *\n * @param {Object} options Object with the following properties:\n * @param {Int8Array|Uint8Array|Int16Array|Uint16Array|Int32Array|Uint32Array|Float32Array|Float64Array} options.heightmap The heightmap to tessellate.\n * @param {Number} options.width The width of the heightmap, in height samples.\n * @param {Number} options.height The height of the heightmap, in height samples.\n * @param {Number} options.skirtHeight The height of skirts to drape at the edges of the heightmap.\n * @param {Rectangle} options.nativeRectangle A rectangle in the native coordinates of the heightmap\'s projection.  For\n *                 a heightmap with a geographic projection, this is degrees.  For the web mercator\n *                 projection, this is meters.\n * @param {Number} [options.exaggeration=1.0] The scale used to exaggerate the terrain.\n * @param {Number} [options.exaggerationRelativeHeight=0.0] The height from which terrain is exaggerated.\n * @param {Rectangle} [options.rectangle] The rectangle covered by the heightmap, in geodetic coordinates with north, south, east and\n *                 west properties in radians.  Either rectangle or nativeRectangle must be provided.  If both\n *                 are provided, they\'re assumed to be consistent.\n * @param {Boolean} [options.isGeographic=true] True if the heightmap uses a {@link GeographicProjection}, or false if it uses\n *                  a {@link WebMercatorProjection}.\n * @param {Cartesian3} [options.relativeToCenter=Cartesian3.ZERO] The positions will be computed as <code>Cartesian3.subtract(worldPosition, relativeToCenter)</code>.\n * @param {Ellipsoid} [options.ellipsoid=Ellipsoid.WGS84] The ellipsoid to which the heightmap applies.\n * @param {Object} [options.structure] An object describing the structure of the height data.\n * @param {Number} [options.structure.heightScale=1.0] The factor by which to multiply height samples in order to obtain\n *                 the height above the heightOffset, in meters.  The heightOffset is added to the resulting\n *                 height after multiplying by the scale.\n * @param {Number} [options.structure.heightOffset=0.0] The offset to add to the scaled height to obtain the final\n *                 height in meters.  The offset is added after the height sample is multiplied by the\n *                 heightScale.\n * @param {Number} [options.structure.elementsPerHeight=1] The number of elements in the buffer that make up a single height\n *                 sample.  This is usually 1, indicating that each element is a separate height sample.  If\n *                 it is greater than 1, that number of elements together form the height sample, which is\n *                 computed according to the structure.elementMultiplier and structure.isBigEndian properties.\n * @param {Number} [options.structure.stride=1] The number of elements to skip to get from the first element of\n *                 one height to the first element of the next height.\n * @param {Number} [options.structure.elementMultiplier=256.0] The multiplier used to compute the height value when the\n *                 stride property is greater than 1.  For example, if the stride is 4 and the strideMultiplier\n *                 is 256, the height is computed as follows:\n *                 `height = buffer[index] + buffer[index + 1] * 256 + buffer[index + 2] * 256 * 256 + buffer[index + 3] * 256 * 256 * 256`\n *                 This is assuming that the isBigEndian property is false.  If it is true, the order of the\n *                 elements is reversed.\n * @param {Number} [options.structure.lowestEncodedHeight] The lowest value that can be stored in the height buffer.  Any heights that are lower\n *                 than this value after encoding with the `heightScale` and `heightOffset` are clamped to this value.  For example, if the height\n *                 buffer is a `Uint16Array`, this value should be 0 because a `Uint16Array` cannot store negative numbers.  If this parameter is\n *                 not specified, no minimum value is enforced.\n * @param {Number} [options.structure.highestEncodedHeight] The highest value that can be stored in the height buffer.  Any heights that are higher\n *                 than this value after encoding with the `heightScale` and `heightOffset` are clamped to this value.  For example, if the height\n *                 buffer is a `Uint16Array`, this value should be `256 * 256 - 1` or 65535 because a `Uint16Array` cannot store numbers larger\n *                 than 65535.  If this parameter is not specified, no maximum value is enforced.\n * @param {Boolean} [options.structure.isBigEndian=false] Indicates endianness of the elements in the buffer when the\n *                  stride property is greater than 1.  If this property is false, the first element is the\n *                  low-order element.  If it is true, the first element is the high-order element.\n *\n * @example\n * var width = 5;\n * var height = 5;\n * var statistics = Cesium.HeightmapTessellator.computeVertices({\n *     heightmap : [1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0],\n *     width : width,\n *     height : height,\n *     skirtHeight : 0.0,\n *     nativeRectangle : {\n *         west : 10.0,\n *         east : 20.0,\n *         south : 30.0,\n *         north : 40.0\n *     }\n * });\n *\n * var encoding = statistics.encoding;\n * var position = encoding.decodePosition(statistics.vertices, index);\n */\nHeightmapTessellator.computeVertices = function (options) {\n  //>>includeStart(\'debug\', pragmas.debug);\n  if (!(0,_defined_js__WEBPACK_IMPORTED_MODULE_15__/* ["default"] */ .Z)(options) || !(0,_defined_js__WEBPACK_IMPORTED_MODULE_15__/* ["default"] */ .Z)(options.heightmap)) {\n    throw new _DeveloperError_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"] */ .Z("options.heightmap is required.");\n  }\n  if (!(0,_defined_js__WEBPACK_IMPORTED_MODULE_15__/* ["default"] */ .Z)(options.width) || !(0,_defined_js__WEBPACK_IMPORTED_MODULE_15__/* ["default"] */ .Z)(options.height)) {\n    throw new _DeveloperError_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"] */ .Z("options.width and options.height are required.");\n  }\n  if (!(0,_defined_js__WEBPACK_IMPORTED_MODULE_15__/* ["default"] */ .Z)(options.nativeRectangle)) {\n    throw new _DeveloperError_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"] */ .Z("options.nativeRectangle is required.");\n  }\n  if (!(0,_defined_js__WEBPACK_IMPORTED_MODULE_15__/* ["default"] */ .Z)(options.skirtHeight)) {\n    throw new _DeveloperError_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"] */ .Z("options.skirtHeight is required.");\n  }\n  //>>includeEnd(\'debug\');\n\n  // This function tends to be a performance hotspot for terrain rendering,\n  // so it employs a lot of inlining and unrolling as an optimization.\n  // In particular, the functionality of Ellipsoid.cartographicToCartesian\n  // is inlined.\n\n  var cos = Math.cos;\n  var sin = Math.sin;\n  var sqrt = Math.sqrt;\n  var atan = Math.atan;\n  var exp = Math.exp;\n  var piOverTwo = _Math_js__WEBPACK_IMPORTED_MODULE_8__/* ["default"].PI_OVER_TWO */ .Z.PI_OVER_TWO;\n  var toRadians = _Math_js__WEBPACK_IMPORTED_MODULE_8__/* ["default"].toRadians */ .Z.toRadians;\n\n  var heightmap = options.heightmap;\n  var width = options.width;\n  var height = options.height;\n  var skirtHeight = options.skirtHeight;\n  var hasSkirts = skirtHeight > 0.0;\n\n  var isGeographic = (0,_defaultValue_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .Z)(options.isGeographic, true);\n  var ellipsoid = (0,_defaultValue_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .Z)(options.ellipsoid, _Ellipsoid_js__WEBPACK_IMPORTED_MODULE_6__/* ["default"].WGS84 */ .Z.WGS84);\n\n  var oneOverGlobeSemimajorAxis = 1.0 / ellipsoid.maximumRadius;\n\n  var nativeRectangle = _Rectangle_js__WEBPACK_IMPORTED_MODULE_11__/* ["default"].clone */ .Z.clone(options.nativeRectangle);\n  var rectangle = _Rectangle_js__WEBPACK_IMPORTED_MODULE_11__/* ["default"].clone */ .Z.clone(options.rectangle);\n\n  var geographicWest;\n  var geographicSouth;\n  var geographicEast;\n  var geographicNorth;\n\n  if (!(0,_defined_js__WEBPACK_IMPORTED_MODULE_15__/* ["default"] */ .Z)(rectangle)) {\n    if (isGeographic) {\n      geographicWest = toRadians(nativeRectangle.west);\n      geographicSouth = toRadians(nativeRectangle.south);\n      geographicEast = toRadians(nativeRectangle.east);\n      geographicNorth = toRadians(nativeRectangle.north);\n    } else {\n      geographicWest = nativeRectangle.west * oneOverGlobeSemimajorAxis;\n      geographicSouth =\n        piOverTwo -\n        2.0 * atan(exp(-nativeRectangle.south * oneOverGlobeSemimajorAxis));\n      geographicEast = nativeRectangle.east * oneOverGlobeSemimajorAxis;\n      geographicNorth =\n        piOverTwo -\n        2.0 * atan(exp(-nativeRectangle.north * oneOverGlobeSemimajorAxis));\n    }\n  } else {\n    geographicWest = rectangle.west;\n    geographicSouth = rectangle.south;\n    geographicEast = rectangle.east;\n    geographicNorth = rectangle.north;\n  }\n\n  var relativeToCenter = options.relativeToCenter;\n  var hasRelativeToCenter = (0,_defined_js__WEBPACK_IMPORTED_MODULE_15__/* ["default"] */ .Z)(relativeToCenter);\n  relativeToCenter = hasRelativeToCenter ? relativeToCenter : _Cartesian3_js__WEBPACK_IMPORTED_MODULE_3__/* ["default"].ZERO */ .Z.ZERO;\n  var includeWebMercatorT = (0,_defaultValue_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .Z)(options.includeWebMercatorT, false);\n\n  var exaggeration = (0,_defaultValue_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .Z)(options.exaggeration, 1.0);\n  var exaggerationRelativeHeight = (0,_defaultValue_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .Z)(\n    options.exaggerationRelativeHeight,\n    0.0\n  );\n  var hasExaggeration = exaggeration !== 1.0;\n  var includeGeodeticSurfaceNormals = hasExaggeration;\n\n  var structure = (0,_defaultValue_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .Z)(\n    options.structure,\n    HeightmapTessellator.DEFAULT_STRUCTURE\n  );\n  var heightScale = (0,_defaultValue_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .Z)(\n    structure.heightScale,\n    HeightmapTessellator.DEFAULT_STRUCTURE.heightScale\n  );\n  var heightOffset = (0,_defaultValue_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .Z)(\n    structure.heightOffset,\n    HeightmapTessellator.DEFAULT_STRUCTURE.heightOffset\n  );\n  var elementsPerHeight = (0,_defaultValue_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .Z)(\n    structure.elementsPerHeight,\n    HeightmapTessellator.DEFAULT_STRUCTURE.elementsPerHeight\n  );\n  var stride = (0,_defaultValue_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .Z)(\n    structure.stride,\n    HeightmapTessellator.DEFAULT_STRUCTURE.stride\n  );\n  var elementMultiplier = (0,_defaultValue_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .Z)(\n    structure.elementMultiplier,\n    HeightmapTessellator.DEFAULT_STRUCTURE.elementMultiplier\n  );\n  var isBigEndian = (0,_defaultValue_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .Z)(\n    structure.isBigEndian,\n    HeightmapTessellator.DEFAULT_STRUCTURE.isBigEndian\n  );\n\n  var rectangleWidth = _Rectangle_js__WEBPACK_IMPORTED_MODULE_11__/* ["default"].computeWidth */ .Z.computeWidth(nativeRectangle);\n  var rectangleHeight = _Rectangle_js__WEBPACK_IMPORTED_MODULE_11__/* ["default"].computeHeight */ .Z.computeHeight(nativeRectangle);\n\n  var granularityX = rectangleWidth / (width - 1);\n  var granularityY = rectangleHeight / (height - 1);\n\n  if (!isGeographic) {\n    rectangleWidth *= oneOverGlobeSemimajorAxis;\n    rectangleHeight *= oneOverGlobeSemimajorAxis;\n  }\n\n  var radiiSquared = ellipsoid.radiiSquared;\n  var radiiSquaredX = radiiSquared.x;\n  var radiiSquaredY = radiiSquared.y;\n  var radiiSquaredZ = radiiSquared.z;\n\n  var minimumHeight = 65536.0;\n  var maximumHeight = -65536.0;\n\n  var fromENU = _Transforms_js__WEBPACK_IMPORTED_MODULE_13__/* ["default"].eastNorthUpToFixedFrame */ .Z.eastNorthUpToFixedFrame(relativeToCenter, ellipsoid);\n  var toENU = _Matrix4_js__WEBPACK_IMPORTED_MODULE_9__/* ["default"].inverseTransformation */ .Z.inverseTransformation(fromENU, matrix4Scratch);\n\n  var southMercatorY;\n  var oneOverMercatorHeight;\n  if (includeWebMercatorT) {\n    southMercatorY = _WebMercatorProjection_js__WEBPACK_IMPORTED_MODULE_14__/* ["default"].geodeticLatitudeToMercatorAngle */ .Z.geodeticLatitudeToMercatorAngle(\n      geographicSouth\n    );\n    oneOverMercatorHeight =\n      1.0 /\n      (_WebMercatorProjection_js__WEBPACK_IMPORTED_MODULE_14__/* ["default"].geodeticLatitudeToMercatorAngle */ .Z.geodeticLatitudeToMercatorAngle(geographicNorth) -\n        southMercatorY);\n  }\n\n  var minimum = minimumScratch;\n  minimum.x = Number.POSITIVE_INFINITY;\n  minimum.y = Number.POSITIVE_INFINITY;\n  minimum.z = Number.POSITIVE_INFINITY;\n\n  var maximum = maximumScratch;\n  maximum.x = Number.NEGATIVE_INFINITY;\n  maximum.y = Number.NEGATIVE_INFINITY;\n  maximum.z = Number.NEGATIVE_INFINITY;\n\n  var hMin = Number.POSITIVE_INFINITY;\n\n  var gridVertexCount = width * height;\n  var edgeVertexCount = skirtHeight > 0.0 ? width * 2 + height * 2 : 0;\n  var vertexCount = gridVertexCount + edgeVertexCount;\n\n  var positions = new Array(vertexCount);\n  var heights = new Array(vertexCount);\n  var uvs = new Array(vertexCount);\n  var webMercatorTs = includeWebMercatorT ? new Array(vertexCount) : [];\n  var geodeticSurfaceNormals = includeGeodeticSurfaceNormals\n    ? new Array(vertexCount)\n    : [];\n\n  var startRow = 0;\n  var endRow = height;\n  var startCol = 0;\n  var endCol = width;\n\n  if (hasSkirts) {\n    --startRow;\n    ++endRow;\n    --startCol;\n    ++endCol;\n  }\n\n  var skirtOffsetPercentage = 0.00001;\n\n  for (var rowIndex = startRow; rowIndex < endRow; ++rowIndex) {\n    var row = rowIndex;\n    if (row < 0) {\n      row = 0;\n    }\n    if (row >= height) {\n      row = height - 1;\n    }\n\n    var latitude = nativeRectangle.north - granularityY * row;\n\n    if (!isGeographic) {\n      latitude =\n        piOverTwo - 2.0 * atan(exp(-latitude * oneOverGlobeSemimajorAxis));\n    } else {\n      latitude = toRadians(latitude);\n    }\n\n    var v = (latitude - geographicSouth) / (geographicNorth - geographicSouth);\n    v = _Math_js__WEBPACK_IMPORTED_MODULE_8__/* ["default"].clamp */ .Z.clamp(v, 0.0, 1.0);\n\n    var isNorthEdge = rowIndex === startRow;\n    var isSouthEdge = rowIndex === endRow - 1;\n    if (skirtHeight > 0.0) {\n      if (isNorthEdge) {\n        latitude += skirtOffsetPercentage * rectangleHeight;\n      } else if (isSouthEdge) {\n        latitude -= skirtOffsetPercentage * rectangleHeight;\n      }\n    }\n\n    var cosLatitude = cos(latitude);\n    var nZ = sin(latitude);\n    var kZ = radiiSquaredZ * nZ;\n\n    var webMercatorT;\n    if (includeWebMercatorT) {\n      webMercatorT =\n        (_WebMercatorProjection_js__WEBPACK_IMPORTED_MODULE_14__/* ["default"].geodeticLatitudeToMercatorAngle */ .Z.geodeticLatitudeToMercatorAngle(latitude) -\n          southMercatorY) *\n        oneOverMercatorHeight;\n    }\n\n    for (var colIndex = startCol; colIndex < endCol; ++colIndex) {\n      var col = colIndex;\n      if (col < 0) {\n        col = 0;\n      }\n      if (col >= width) {\n        col = width - 1;\n      }\n\n      var terrainOffset = row * (width * stride) + col * stride;\n\n      var heightSample;\n      if (elementsPerHeight === 1) {\n        heightSample = heightmap[terrainOffset];\n      } else {\n        heightSample = 0;\n\n        var elementOffset;\n        if (isBigEndian) {\n          for (\n            elementOffset = 0;\n            elementOffset < elementsPerHeight;\n            ++elementOffset\n          ) {\n            heightSample =\n              heightSample * elementMultiplier +\n              heightmap[terrainOffset + elementOffset];\n          }\n        } else {\n          for (\n            elementOffset = elementsPerHeight - 1;\n            elementOffset >= 0;\n            --elementOffset\n          ) {\n            heightSample =\n              heightSample * elementMultiplier +\n              heightmap[terrainOffset + elementOffset];\n          }\n        }\n      }\n\n      heightSample = heightSample * heightScale + heightOffset;\n\n      maximumHeight = Math.max(maximumHeight, heightSample);\n      minimumHeight = Math.min(minimumHeight, heightSample);\n\n      var longitude = nativeRectangle.west + granularityX * col;\n\n      if (!isGeographic) {\n        longitude = longitude * oneOverGlobeSemimajorAxis;\n      } else {\n        longitude = toRadians(longitude);\n      }\n\n      var u = (longitude - geographicWest) / (geographicEast - geographicWest);\n      u = _Math_js__WEBPACK_IMPORTED_MODULE_8__/* ["default"].clamp */ .Z.clamp(u, 0.0, 1.0);\n\n      var index = row * width + col;\n\n      if (skirtHeight > 0.0) {\n        var isWestEdge = colIndex === startCol;\n        var isEastEdge = colIndex === endCol - 1;\n        var isEdge = isNorthEdge || isSouthEdge || isWestEdge || isEastEdge;\n        var isCorner =\n          (isNorthEdge || isSouthEdge) && (isWestEdge || isEastEdge);\n        if (isCorner) {\n          // Don\'t generate skirts on the corners.\n          continue;\n        } else if (isEdge) {\n          heightSample -= skirtHeight;\n\n          if (isWestEdge) {\n            // The outer loop iterates north to south but the indices are ordered south to north, hence the index flip below\n            index = gridVertexCount + (height - row - 1);\n            longitude -= skirtOffsetPercentage * rectangleWidth;\n          } else if (isSouthEdge) {\n            // Add after west indices. South indices are ordered east to west.\n            index = gridVertexCount + height + (width - col - 1);\n          } else if (isEastEdge) {\n            // Add after west and south indices. East indices are ordered north to south. The index is flipped like above.\n            index = gridVertexCount + height + width + row;\n            longitude += skirtOffsetPercentage * rectangleWidth;\n          } else if (isNorthEdge) {\n            // Add after west, south, and east indices. North indices are ordered west to east.\n            index = gridVertexCount + height + width + height + col;\n          }\n        }\n      }\n\n      var nX = cosLatitude * cos(longitude);\n      var nY = cosLatitude * sin(longitude);\n\n      var kX = radiiSquaredX * nX;\n      var kY = radiiSquaredY * nY;\n\n      var gamma = sqrt(kX * nX + kY * nY + kZ * nZ);\n      var oneOverGamma = 1.0 / gamma;\n\n      var rSurfaceX = kX * oneOverGamma;\n      var rSurfaceY = kY * oneOverGamma;\n      var rSurfaceZ = kZ * oneOverGamma;\n\n      var position = new _Cartesian3_js__WEBPACK_IMPORTED_MODULE_3__/* ["default"] */ .Z();\n      position.x = rSurfaceX + nX * heightSample;\n      position.y = rSurfaceY + nY * heightSample;\n      position.z = rSurfaceZ + nZ * heightSample;\n\n      _Matrix4_js__WEBPACK_IMPORTED_MODULE_9__/* ["default"].multiplyByPoint */ .Z.multiplyByPoint(toENU, position, cartesian3Scratch);\n      _Cartesian3_js__WEBPACK_IMPORTED_MODULE_3__/* ["default"].minimumByComponent */ .Z.minimumByComponent(cartesian3Scratch, minimum, minimum);\n      _Cartesian3_js__WEBPACK_IMPORTED_MODULE_3__/* ["default"].maximumByComponent */ .Z.maximumByComponent(cartesian3Scratch, maximum, maximum);\n      hMin = Math.min(hMin, heightSample);\n\n      positions[index] = position;\n      uvs[index] = new _Cartesian2_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"] */ .Z(u, v);\n      heights[index] = heightSample;\n\n      if (includeWebMercatorT) {\n        webMercatorTs[index] = webMercatorT;\n      }\n\n      if (includeGeodeticSurfaceNormals) {\n        geodeticSurfaceNormals[index] = ellipsoid.geodeticSurfaceNormal(\n          position\n        );\n      }\n    }\n  }\n\n  var boundingSphere3D = _BoundingSphere_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"].fromPoints */ .Z.fromPoints(positions);\n  var orientedBoundingBox;\n  if ((0,_defined_js__WEBPACK_IMPORTED_MODULE_15__/* ["default"] */ .Z)(rectangle)) {\n    orientedBoundingBox = _OrientedBoundingBox_js__WEBPACK_IMPORTED_MODULE_10__/* ["default"].fromRectangle */ .Z.fromRectangle(\n      rectangle,\n      minimumHeight,\n      maximumHeight,\n      ellipsoid\n    );\n  }\n\n  var occludeePointInScaledSpace;\n  if (hasRelativeToCenter) {\n    var occluder = new _EllipsoidalOccluder_js__WEBPACK_IMPORTED_MODULE_7__/* ["default"] */ .Z(ellipsoid);\n    occludeePointInScaledSpace = occluder.computeHorizonCullingPointPossiblyUnderEllipsoid(\n      relativeToCenter,\n      positions,\n      minimumHeight\n    );\n  }\n\n  var aaBox = new _AxisAlignedBoundingBox_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .Z(minimum, maximum, relativeToCenter);\n  var encoding = new _TerrainEncoding_js__WEBPACK_IMPORTED_MODULE_12__/* ["default"] */ .Z(\n    relativeToCenter,\n    aaBox,\n    hMin,\n    maximumHeight,\n    fromENU,\n    false,\n    includeWebMercatorT,\n    includeGeodeticSurfaceNormals,\n    exaggeration,\n    exaggerationRelativeHeight\n  );\n  var vertices = new Float32Array(vertexCount * encoding.stride);\n\n  var bufferIndex = 0;\n  for (var j = 0; j < vertexCount; ++j) {\n    bufferIndex = encoding.encode(\n      vertices,\n      bufferIndex,\n      positions[j],\n      uvs[j],\n      heights[j],\n      undefined,\n      webMercatorTs[j],\n      geodeticSurfaceNormals[j]\n    );\n  }\n\n  return {\n    vertices: vertices,\n    maximumHeight: maximumHeight,\n    minimumHeight: minimumHeight,\n    encoding: encoding,\n    boundingSphere3D: boundingSphere3D,\n    orientedBoundingBox: orientedBoundingBox,\n    occludeePointInScaledSpace: occludeePointInScaledSpace,\n  };\n};\n/* harmony default export */ __webpack_exports__["Z"] = (HeightmapTessellator);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QixFQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdnVlMy13ZWJwYWNrNS8uL25vZGVfbW9kdWxlcy9jZXNpdW0vU291cmNlL0NvcmUvSGVpZ2h0bWFwVGVzc2VsbGF0b3IuanM/ODVkNSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgQXhpc0FsaWduZWRCb3VuZGluZ0JveCBmcm9tIFwiLi9BeGlzQWxpZ25lZEJvdW5kaW5nQm94LmpzXCI7XG5pbXBvcnQgQm91bmRpbmdTcGhlcmUgZnJvbSBcIi4vQm91bmRpbmdTcGhlcmUuanNcIjtcbmltcG9ydCBDYXJ0ZXNpYW4yIGZyb20gXCIuL0NhcnRlc2lhbjIuanNcIjtcbmltcG9ydCBDYXJ0ZXNpYW4zIGZyb20gXCIuL0NhcnRlc2lhbjMuanNcIjtcbmltcG9ydCBkZWZhdWx0VmFsdWUgZnJvbSBcIi4vZGVmYXVsdFZhbHVlLmpzXCI7XG5pbXBvcnQgZGVmaW5lZCBmcm9tIFwiLi9kZWZpbmVkLmpzXCI7XG5pbXBvcnQgRGV2ZWxvcGVyRXJyb3IgZnJvbSBcIi4vRGV2ZWxvcGVyRXJyb3IuanNcIjtcbmltcG9ydCBFbGxpcHNvaWQgZnJvbSBcIi4vRWxsaXBzb2lkLmpzXCI7XG5pbXBvcnQgRWxsaXBzb2lkYWxPY2NsdWRlciBmcm9tIFwiLi9FbGxpcHNvaWRhbE9jY2x1ZGVyLmpzXCI7XG5pbXBvcnQgQ2VzaXVtTWF0aCBmcm9tIFwiLi9NYXRoLmpzXCI7XG5pbXBvcnQgTWF0cml4NCBmcm9tIFwiLi9NYXRyaXg0LmpzXCI7XG5pbXBvcnQgT3JpZW50ZWRCb3VuZGluZ0JveCBmcm9tIFwiLi9PcmllbnRlZEJvdW5kaW5nQm94LmpzXCI7XG5pbXBvcnQgUmVjdGFuZ2xlIGZyb20gXCIuL1JlY3RhbmdsZS5qc1wiO1xuaW1wb3J0IFRlcnJhaW5FbmNvZGluZyBmcm9tIFwiLi9UZXJyYWluRW5jb2RpbmcuanNcIjtcbmltcG9ydCBUcmFuc2Zvcm1zIGZyb20gXCIuL1RyYW5zZm9ybXMuanNcIjtcbmltcG9ydCBXZWJNZXJjYXRvclByb2plY3Rpb24gZnJvbSBcIi4vV2ViTWVyY2F0b3JQcm9qZWN0aW9uLmpzXCI7XG5cbi8qKlxuICogQ29udGFpbnMgZnVuY3Rpb25zIHRvIGNyZWF0ZSBhIG1lc2ggZnJvbSBhIGhlaWdodG1hcCBpbWFnZS5cbiAqXG4gKiBAbmFtZXNwYWNlIEhlaWdodG1hcFRlc3NlbGxhdG9yXG4gKlxuICogQHByaXZhdGVcbiAqL1xudmFyIEhlaWdodG1hcFRlc3NlbGxhdG9yID0ge307XG5cbi8qKlxuICogVGhlIGRlZmF1bHQgc3RydWN0dXJlIG9mIGEgaGVpZ2h0bWFwLCBhcyBnaXZlbiB0byB7QGxpbmsgSGVpZ2h0bWFwVGVzc2VsbGF0b3IuY29tcHV0ZVZlcnRpY2VzfS5cbiAqXG4gKiBAY29uc3RhbnRcbiAqL1xuSGVpZ2h0bWFwVGVzc2VsbGF0b3IuREVGQVVMVF9TVFJVQ1RVUkUgPSBPYmplY3QuZnJlZXplKHtcbiAgaGVpZ2h0U2NhbGU6IDEuMCxcbiAgaGVpZ2h0T2Zmc2V0OiAwLjAsXG4gIGVsZW1lbnRzUGVySGVpZ2h0OiAxLFxuICBzdHJpZGU6IDEsXG4gIGVsZW1lbnRNdWx0aXBsaWVyOiAyNTYuMCxcbiAgaXNCaWdFbmRpYW46IGZhbHNlLFxufSk7XG5cbnZhciBjYXJ0ZXNpYW4zU2NyYXRjaCA9IG5ldyBDYXJ0ZXNpYW4zKCk7XG52YXIgbWF0cml4NFNjcmF0Y2ggPSBuZXcgTWF0cml4NCgpO1xudmFyIG1pbmltdW1TY3JhdGNoID0gbmV3IENhcnRlc2lhbjMoKTtcbnZhciBtYXhpbXVtU2NyYXRjaCA9IG5ldyBDYXJ0ZXNpYW4zKCk7XG5cbi8qKlxuICogRmlsbHMgYW4gYXJyYXkgb2YgdmVydGljZXMgZnJvbSBhIGhlaWdodG1hcCBpbWFnZS5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyBPYmplY3Qgd2l0aCB0aGUgZm9sbG93aW5nIHByb3BlcnRpZXM6XG4gKiBAcGFyYW0ge0ludDhBcnJheXxVaW50OEFycmF5fEludDE2QXJyYXl8VWludDE2QXJyYXl8SW50MzJBcnJheXxVaW50MzJBcnJheXxGbG9hdDMyQXJyYXl8RmxvYXQ2NEFycmF5fSBvcHRpb25zLmhlaWdodG1hcCBUaGUgaGVpZ2h0bWFwIHRvIHRlc3NlbGxhdGUuXG4gKiBAcGFyYW0ge051bWJlcn0gb3B0aW9ucy53aWR0aCBUaGUgd2lkdGggb2YgdGhlIGhlaWdodG1hcCwgaW4gaGVpZ2h0IHNhbXBsZXMuXG4gKiBAcGFyYW0ge051bWJlcn0gb3B0aW9ucy5oZWlnaHQgVGhlIGhlaWdodCBvZiB0aGUgaGVpZ2h0bWFwLCBpbiBoZWlnaHQgc2FtcGxlcy5cbiAqIEBwYXJhbSB7TnVtYmVyfSBvcHRpb25zLnNraXJ0SGVpZ2h0IFRoZSBoZWlnaHQgb2Ygc2tpcnRzIHRvIGRyYXBlIGF0IHRoZSBlZGdlcyBvZiB0aGUgaGVpZ2h0bWFwLlxuICogQHBhcmFtIHtSZWN0YW5nbGV9IG9wdGlvbnMubmF0aXZlUmVjdGFuZ2xlIEEgcmVjdGFuZ2xlIGluIHRoZSBuYXRpdmUgY29vcmRpbmF0ZXMgb2YgdGhlIGhlaWdodG1hcCdzIHByb2plY3Rpb24uICBGb3JcbiAqICAgICAgICAgICAgICAgICBhIGhlaWdodG1hcCB3aXRoIGEgZ2VvZ3JhcGhpYyBwcm9qZWN0aW9uLCB0aGlzIGlzIGRlZ3JlZXMuICBGb3IgdGhlIHdlYiBtZXJjYXRvclxuICogICAgICAgICAgICAgICAgIHByb2plY3Rpb24sIHRoaXMgaXMgbWV0ZXJzLlxuICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLmV4YWdnZXJhdGlvbj0xLjBdIFRoZSBzY2FsZSB1c2VkIHRvIGV4YWdnZXJhdGUgdGhlIHRlcnJhaW4uXG4gKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMuZXhhZ2dlcmF0aW9uUmVsYXRpdmVIZWlnaHQ9MC4wXSBUaGUgaGVpZ2h0IGZyb20gd2hpY2ggdGVycmFpbiBpcyBleGFnZ2VyYXRlZC5cbiAqIEBwYXJhbSB7UmVjdGFuZ2xlfSBbb3B0aW9ucy5yZWN0YW5nbGVdIFRoZSByZWN0YW5nbGUgY292ZXJlZCBieSB0aGUgaGVpZ2h0bWFwLCBpbiBnZW9kZXRpYyBjb29yZGluYXRlcyB3aXRoIG5vcnRoLCBzb3V0aCwgZWFzdCBhbmRcbiAqICAgICAgICAgICAgICAgICB3ZXN0IHByb3BlcnRpZXMgaW4gcmFkaWFucy4gIEVpdGhlciByZWN0YW5nbGUgb3IgbmF0aXZlUmVjdGFuZ2xlIG11c3QgYmUgcHJvdmlkZWQuICBJZiBib3RoXG4gKiAgICAgICAgICAgICAgICAgYXJlIHByb3ZpZGVkLCB0aGV5J3JlIGFzc3VtZWQgdG8gYmUgY29uc2lzdGVudC5cbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMuaXNHZW9ncmFwaGljPXRydWVdIFRydWUgaWYgdGhlIGhlaWdodG1hcCB1c2VzIGEge0BsaW5rIEdlb2dyYXBoaWNQcm9qZWN0aW9ufSwgb3IgZmFsc2UgaWYgaXQgdXNlc1xuICogICAgICAgICAgICAgICAgICBhIHtAbGluayBXZWJNZXJjYXRvclByb2plY3Rpb259LlxuICogQHBhcmFtIHtDYXJ0ZXNpYW4zfSBbb3B0aW9ucy5yZWxhdGl2ZVRvQ2VudGVyPUNhcnRlc2lhbjMuWkVST10gVGhlIHBvc2l0aW9ucyB3aWxsIGJlIGNvbXB1dGVkIGFzIDxjb2RlPkNhcnRlc2lhbjMuc3VidHJhY3Qod29ybGRQb3NpdGlvbiwgcmVsYXRpdmVUb0NlbnRlcik8L2NvZGU+LlxuICogQHBhcmFtIHtFbGxpcHNvaWR9IFtvcHRpb25zLmVsbGlwc29pZD1FbGxpcHNvaWQuV0dTODRdIFRoZSBlbGxpcHNvaWQgdG8gd2hpY2ggdGhlIGhlaWdodG1hcCBhcHBsaWVzLlxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zLnN0cnVjdHVyZV0gQW4gb2JqZWN0IGRlc2NyaWJpbmcgdGhlIHN0cnVjdHVyZSBvZiB0aGUgaGVpZ2h0IGRhdGEuXG4gKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMuc3RydWN0dXJlLmhlaWdodFNjYWxlPTEuMF0gVGhlIGZhY3RvciBieSB3aGljaCB0byBtdWx0aXBseSBoZWlnaHQgc2FtcGxlcyBpbiBvcmRlciB0byBvYnRhaW5cbiAqICAgICAgICAgICAgICAgICB0aGUgaGVpZ2h0IGFib3ZlIHRoZSBoZWlnaHRPZmZzZXQsIGluIG1ldGVycy4gIFRoZSBoZWlnaHRPZmZzZXQgaXMgYWRkZWQgdG8gdGhlIHJlc3VsdGluZ1xuICogICAgICAgICAgICAgICAgIGhlaWdodCBhZnRlciBtdWx0aXBseWluZyBieSB0aGUgc2NhbGUuXG4gKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMuc3RydWN0dXJlLmhlaWdodE9mZnNldD0wLjBdIFRoZSBvZmZzZXQgdG8gYWRkIHRvIHRoZSBzY2FsZWQgaGVpZ2h0IHRvIG9idGFpbiB0aGUgZmluYWxcbiAqICAgICAgICAgICAgICAgICBoZWlnaHQgaW4gbWV0ZXJzLiAgVGhlIG9mZnNldCBpcyBhZGRlZCBhZnRlciB0aGUgaGVpZ2h0IHNhbXBsZSBpcyBtdWx0aXBsaWVkIGJ5IHRoZVxuICogICAgICAgICAgICAgICAgIGhlaWdodFNjYWxlLlxuICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLnN0cnVjdHVyZS5lbGVtZW50c1BlckhlaWdodD0xXSBUaGUgbnVtYmVyIG9mIGVsZW1lbnRzIGluIHRoZSBidWZmZXIgdGhhdCBtYWtlIHVwIGEgc2luZ2xlIGhlaWdodFxuICogICAgICAgICAgICAgICAgIHNhbXBsZS4gIFRoaXMgaXMgdXN1YWxseSAxLCBpbmRpY2F0aW5nIHRoYXQgZWFjaCBlbGVtZW50IGlzIGEgc2VwYXJhdGUgaGVpZ2h0IHNhbXBsZS4gIElmXG4gKiAgICAgICAgICAgICAgICAgaXQgaXMgZ3JlYXRlciB0aGFuIDEsIHRoYXQgbnVtYmVyIG9mIGVsZW1lbnRzIHRvZ2V0aGVyIGZvcm0gdGhlIGhlaWdodCBzYW1wbGUsIHdoaWNoIGlzXG4gKiAgICAgICAgICAgICAgICAgY29tcHV0ZWQgYWNjb3JkaW5nIHRvIHRoZSBzdHJ1Y3R1cmUuZWxlbWVudE11bHRpcGxpZXIgYW5kIHN0cnVjdHVyZS5pc0JpZ0VuZGlhbiBwcm9wZXJ0aWVzLlxuICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLnN0cnVjdHVyZS5zdHJpZGU9MV0gVGhlIG51bWJlciBvZiBlbGVtZW50cyB0byBza2lwIHRvIGdldCBmcm9tIHRoZSBmaXJzdCBlbGVtZW50IG9mXG4gKiAgICAgICAgICAgICAgICAgb25lIGhlaWdodCB0byB0aGUgZmlyc3QgZWxlbWVudCBvZiB0aGUgbmV4dCBoZWlnaHQuXG4gKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMuc3RydWN0dXJlLmVsZW1lbnRNdWx0aXBsaWVyPTI1Ni4wXSBUaGUgbXVsdGlwbGllciB1c2VkIHRvIGNvbXB1dGUgdGhlIGhlaWdodCB2YWx1ZSB3aGVuIHRoZVxuICogICAgICAgICAgICAgICAgIHN0cmlkZSBwcm9wZXJ0eSBpcyBncmVhdGVyIHRoYW4gMS4gIEZvciBleGFtcGxlLCBpZiB0aGUgc3RyaWRlIGlzIDQgYW5kIHRoZSBzdHJpZGVNdWx0aXBsaWVyXG4gKiAgICAgICAgICAgICAgICAgaXMgMjU2LCB0aGUgaGVpZ2h0IGlzIGNvbXB1dGVkIGFzIGZvbGxvd3M6XG4gKiAgICAgICAgICAgICAgICAgYGhlaWdodCA9IGJ1ZmZlcltpbmRleF0gKyBidWZmZXJbaW5kZXggKyAxXSAqIDI1NiArIGJ1ZmZlcltpbmRleCArIDJdICogMjU2ICogMjU2ICsgYnVmZmVyW2luZGV4ICsgM10gKiAyNTYgKiAyNTYgKiAyNTZgXG4gKiAgICAgICAgICAgICAgICAgVGhpcyBpcyBhc3N1bWluZyB0aGF0IHRoZSBpc0JpZ0VuZGlhbiBwcm9wZXJ0eSBpcyBmYWxzZS4gIElmIGl0IGlzIHRydWUsIHRoZSBvcmRlciBvZiB0aGVcbiAqICAgICAgICAgICAgICAgICBlbGVtZW50cyBpcyByZXZlcnNlZC5cbiAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5zdHJ1Y3R1cmUubG93ZXN0RW5jb2RlZEhlaWdodF0gVGhlIGxvd2VzdCB2YWx1ZSB0aGF0IGNhbiBiZSBzdG9yZWQgaW4gdGhlIGhlaWdodCBidWZmZXIuICBBbnkgaGVpZ2h0cyB0aGF0IGFyZSBsb3dlclxuICogICAgICAgICAgICAgICAgIHRoYW4gdGhpcyB2YWx1ZSBhZnRlciBlbmNvZGluZyB3aXRoIHRoZSBgaGVpZ2h0U2NhbGVgIGFuZCBgaGVpZ2h0T2Zmc2V0YCBhcmUgY2xhbXBlZCB0byB0aGlzIHZhbHVlLiAgRm9yIGV4YW1wbGUsIGlmIHRoZSBoZWlnaHRcbiAqICAgICAgICAgICAgICAgICBidWZmZXIgaXMgYSBgVWludDE2QXJyYXlgLCB0aGlzIHZhbHVlIHNob3VsZCBiZSAwIGJlY2F1c2UgYSBgVWludDE2QXJyYXlgIGNhbm5vdCBzdG9yZSBuZWdhdGl2ZSBudW1iZXJzLiAgSWYgdGhpcyBwYXJhbWV0ZXIgaXNcbiAqICAgICAgICAgICAgICAgICBub3Qgc3BlY2lmaWVkLCBubyBtaW5pbXVtIHZhbHVlIGlzIGVuZm9yY2VkLlxuICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLnN0cnVjdHVyZS5oaWdoZXN0RW5jb2RlZEhlaWdodF0gVGhlIGhpZ2hlc3QgdmFsdWUgdGhhdCBjYW4gYmUgc3RvcmVkIGluIHRoZSBoZWlnaHQgYnVmZmVyLiAgQW55IGhlaWdodHMgdGhhdCBhcmUgaGlnaGVyXG4gKiAgICAgICAgICAgICAgICAgdGhhbiB0aGlzIHZhbHVlIGFmdGVyIGVuY29kaW5nIHdpdGggdGhlIGBoZWlnaHRTY2FsZWAgYW5kIGBoZWlnaHRPZmZzZXRgIGFyZSBjbGFtcGVkIHRvIHRoaXMgdmFsdWUuICBGb3IgZXhhbXBsZSwgaWYgdGhlIGhlaWdodFxuICogICAgICAgICAgICAgICAgIGJ1ZmZlciBpcyBhIGBVaW50MTZBcnJheWAsIHRoaXMgdmFsdWUgc2hvdWxkIGJlIGAyNTYgKiAyNTYgLSAxYCBvciA2NTUzNSBiZWNhdXNlIGEgYFVpbnQxNkFycmF5YCBjYW5ub3Qgc3RvcmUgbnVtYmVycyBsYXJnZXJcbiAqICAgICAgICAgICAgICAgICB0aGFuIDY1NTM1LiAgSWYgdGhpcyBwYXJhbWV0ZXIgaXMgbm90IHNwZWNpZmllZCwgbm8gbWF4aW11bSB2YWx1ZSBpcyBlbmZvcmNlZC5cbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMuc3RydWN0dXJlLmlzQmlnRW5kaWFuPWZhbHNlXSBJbmRpY2F0ZXMgZW5kaWFubmVzcyBvZiB0aGUgZWxlbWVudHMgaW4gdGhlIGJ1ZmZlciB3aGVuIHRoZVxuICogICAgICAgICAgICAgICAgICBzdHJpZGUgcHJvcGVydHkgaXMgZ3JlYXRlciB0aGFuIDEuICBJZiB0aGlzIHByb3BlcnR5IGlzIGZhbHNlLCB0aGUgZmlyc3QgZWxlbWVudCBpcyB0aGVcbiAqICAgICAgICAgICAgICAgICAgbG93LW9yZGVyIGVsZW1lbnQuICBJZiBpdCBpcyB0cnVlLCB0aGUgZmlyc3QgZWxlbWVudCBpcyB0aGUgaGlnaC1vcmRlciBlbGVtZW50LlxuICpcbiAqIEBleGFtcGxlXG4gKiB2YXIgd2lkdGggPSA1O1xuICogdmFyIGhlaWdodCA9IDU7XG4gKiB2YXIgc3RhdGlzdGljcyA9IENlc2l1bS5IZWlnaHRtYXBUZXNzZWxsYXRvci5jb21wdXRlVmVydGljZXMoe1xuICogICAgIGhlaWdodG1hcCA6IFsxLjAsIDIuMCwgMy4wLCA0LjAsIDUuMCwgNi4wLCA3LjAsIDguMCwgOS4wXSxcbiAqICAgICB3aWR0aCA6IHdpZHRoLFxuICogICAgIGhlaWdodCA6IGhlaWdodCxcbiAqICAgICBza2lydEhlaWdodCA6IDAuMCxcbiAqICAgICBuYXRpdmVSZWN0YW5nbGUgOiB7XG4gKiAgICAgICAgIHdlc3QgOiAxMC4wLFxuICogICAgICAgICBlYXN0IDogMjAuMCxcbiAqICAgICAgICAgc291dGggOiAzMC4wLFxuICogICAgICAgICBub3J0aCA6IDQwLjBcbiAqICAgICB9XG4gKiB9KTtcbiAqXG4gKiB2YXIgZW5jb2RpbmcgPSBzdGF0aXN0aWNzLmVuY29kaW5nO1xuICogdmFyIHBvc2l0aW9uID0gZW5jb2RpbmcuZGVjb2RlUG9zaXRpb24oc3RhdGlzdGljcy52ZXJ0aWNlcywgaW5kZXgpO1xuICovXG5IZWlnaHRtYXBUZXNzZWxsYXRvci5jb21wdXRlVmVydGljZXMgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAvLz4+aW5jbHVkZVN0YXJ0KCdkZWJ1ZycsIHByYWdtYXMuZGVidWcpO1xuICBpZiAoIWRlZmluZWQob3B0aW9ucykgfHwgIWRlZmluZWQob3B0aW9ucy5oZWlnaHRtYXApKSB7XG4gICAgdGhyb3cgbmV3IERldmVsb3BlckVycm9yKFwib3B0aW9ucy5oZWlnaHRtYXAgaXMgcmVxdWlyZWQuXCIpO1xuICB9XG4gIGlmICghZGVmaW5lZChvcHRpb25zLndpZHRoKSB8fCAhZGVmaW5lZChvcHRpb25zLmhlaWdodCkpIHtcbiAgICB0aHJvdyBuZXcgRGV2ZWxvcGVyRXJyb3IoXCJvcHRpb25zLndpZHRoIGFuZCBvcHRpb25zLmhlaWdodCBhcmUgcmVxdWlyZWQuXCIpO1xuICB9XG4gIGlmICghZGVmaW5lZChvcHRpb25zLm5hdGl2ZVJlY3RhbmdsZSkpIHtcbiAgICB0aHJvdyBuZXcgRGV2ZWxvcGVyRXJyb3IoXCJvcHRpb25zLm5hdGl2ZVJlY3RhbmdsZSBpcyByZXF1aXJlZC5cIik7XG4gIH1cbiAgaWYgKCFkZWZpbmVkKG9wdGlvbnMuc2tpcnRIZWlnaHQpKSB7XG4gICAgdGhyb3cgbmV3IERldmVsb3BlckVycm9yKFwib3B0aW9ucy5za2lydEhlaWdodCBpcyByZXF1aXJlZC5cIik7XG4gIH1cbiAgLy8+PmluY2x1ZGVFbmQoJ2RlYnVnJyk7XG5cbiAgLy8gVGhpcyBmdW5jdGlvbiB0ZW5kcyB0byBiZSBhIHBlcmZvcm1hbmNlIGhvdHNwb3QgZm9yIHRlcnJhaW4gcmVuZGVyaW5nLFxuICAvLyBzbyBpdCBlbXBsb3lzIGEgbG90IG9mIGlubGluaW5nIGFuZCB1bnJvbGxpbmcgYXMgYW4gb3B0aW1pemF0aW9uLlxuICAvLyBJbiBwYXJ0aWN1bGFyLCB0aGUgZnVuY3Rpb25hbGl0eSBvZiBFbGxpcHNvaWQuY2FydG9ncmFwaGljVG9DYXJ0ZXNpYW5cbiAgLy8gaXMgaW5saW5lZC5cblxuICB2YXIgY29zID0gTWF0aC5jb3M7XG4gIHZhciBzaW4gPSBNYXRoLnNpbjtcbiAgdmFyIHNxcnQgPSBNYXRoLnNxcnQ7XG4gIHZhciBhdGFuID0gTWF0aC5hdGFuO1xuICB2YXIgZXhwID0gTWF0aC5leHA7XG4gIHZhciBwaU92ZXJUd28gPSBDZXNpdW1NYXRoLlBJX09WRVJfVFdPO1xuICB2YXIgdG9SYWRpYW5zID0gQ2VzaXVtTWF0aC50b1JhZGlhbnM7XG5cbiAgdmFyIGhlaWdodG1hcCA9IG9wdGlvbnMuaGVpZ2h0bWFwO1xuICB2YXIgd2lkdGggPSBvcHRpb25zLndpZHRoO1xuICB2YXIgaGVpZ2h0ID0gb3B0aW9ucy5oZWlnaHQ7XG4gIHZhciBza2lydEhlaWdodCA9IG9wdGlvbnMuc2tpcnRIZWlnaHQ7XG4gIHZhciBoYXNTa2lydHMgPSBza2lydEhlaWdodCA+IDAuMDtcblxuICB2YXIgaXNHZW9ncmFwaGljID0gZGVmYXVsdFZhbHVlKG9wdGlvbnMuaXNHZW9ncmFwaGljLCB0cnVlKTtcbiAgdmFyIGVsbGlwc29pZCA9IGRlZmF1bHRWYWx1ZShvcHRpb25zLmVsbGlwc29pZCwgRWxsaXBzb2lkLldHUzg0KTtcblxuICB2YXIgb25lT3Zlckdsb2JlU2VtaW1ham9yQXhpcyA9IDEuMCAvIGVsbGlwc29pZC5tYXhpbXVtUmFkaXVzO1xuXG4gIHZhciBuYXRpdmVSZWN0YW5nbGUgPSBSZWN0YW5nbGUuY2xvbmUob3B0aW9ucy5uYXRpdmVSZWN0YW5nbGUpO1xuICB2YXIgcmVjdGFuZ2xlID0gUmVjdGFuZ2xlLmNsb25lKG9wdGlvbnMucmVjdGFuZ2xlKTtcblxuICB2YXIgZ2VvZ3JhcGhpY1dlc3Q7XG4gIHZhciBnZW9ncmFwaGljU291dGg7XG4gIHZhciBnZW9ncmFwaGljRWFzdDtcbiAgdmFyIGdlb2dyYXBoaWNOb3J0aDtcblxuICBpZiAoIWRlZmluZWQocmVjdGFuZ2xlKSkge1xuICAgIGlmIChpc0dlb2dyYXBoaWMpIHtcbiAgICAgIGdlb2dyYXBoaWNXZXN0ID0gdG9SYWRpYW5zKG5hdGl2ZVJlY3RhbmdsZS53ZXN0KTtcbiAgICAgIGdlb2dyYXBoaWNTb3V0aCA9IHRvUmFkaWFucyhuYXRpdmVSZWN0YW5nbGUuc291dGgpO1xuICAgICAgZ2VvZ3JhcGhpY0Vhc3QgPSB0b1JhZGlhbnMobmF0aXZlUmVjdGFuZ2xlLmVhc3QpO1xuICAgICAgZ2VvZ3JhcGhpY05vcnRoID0gdG9SYWRpYW5zKG5hdGl2ZVJlY3RhbmdsZS5ub3J0aCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGdlb2dyYXBoaWNXZXN0ID0gbmF0aXZlUmVjdGFuZ2xlLndlc3QgKiBvbmVPdmVyR2xvYmVTZW1pbWFqb3JBeGlzO1xuICAgICAgZ2VvZ3JhcGhpY1NvdXRoID1cbiAgICAgICAgcGlPdmVyVHdvIC1cbiAgICAgICAgMi4wICogYXRhbihleHAoLW5hdGl2ZVJlY3RhbmdsZS5zb3V0aCAqIG9uZU92ZXJHbG9iZVNlbWltYWpvckF4aXMpKTtcbiAgICAgIGdlb2dyYXBoaWNFYXN0ID0gbmF0aXZlUmVjdGFuZ2xlLmVhc3QgKiBvbmVPdmVyR2xvYmVTZW1pbWFqb3JBeGlzO1xuICAgICAgZ2VvZ3JhcGhpY05vcnRoID1cbiAgICAgICAgcGlPdmVyVHdvIC1cbiAgICAgICAgMi4wICogYXRhbihleHAoLW5hdGl2ZVJlY3RhbmdsZS5ub3J0aCAqIG9uZU92ZXJHbG9iZVNlbWltYWpvckF4aXMpKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgZ2VvZ3JhcGhpY1dlc3QgPSByZWN0YW5nbGUud2VzdDtcbiAgICBnZW9ncmFwaGljU291dGggPSByZWN0YW5nbGUuc291dGg7XG4gICAgZ2VvZ3JhcGhpY0Vhc3QgPSByZWN0YW5nbGUuZWFzdDtcbiAgICBnZW9ncmFwaGljTm9ydGggPSByZWN0YW5nbGUubm9ydGg7XG4gIH1cblxuICB2YXIgcmVsYXRpdmVUb0NlbnRlciA9IG9wdGlvbnMucmVsYXRpdmVUb0NlbnRlcjtcbiAgdmFyIGhhc1JlbGF0aXZlVG9DZW50ZXIgPSBkZWZpbmVkKHJlbGF0aXZlVG9DZW50ZXIpO1xuICByZWxhdGl2ZVRvQ2VudGVyID0gaGFzUmVsYXRpdmVUb0NlbnRlciA/IHJlbGF0aXZlVG9DZW50ZXIgOiBDYXJ0ZXNpYW4zLlpFUk87XG4gIHZhciBpbmNsdWRlV2ViTWVyY2F0b3JUID0gZGVmYXVsdFZhbHVlKG9wdGlvbnMuaW5jbHVkZVdlYk1lcmNhdG9yVCwgZmFsc2UpO1xuXG4gIHZhciBleGFnZ2VyYXRpb24gPSBkZWZhdWx0VmFsdWUob3B0aW9ucy5leGFnZ2VyYXRpb24sIDEuMCk7XG4gIHZhciBleGFnZ2VyYXRpb25SZWxhdGl2ZUhlaWdodCA9IGRlZmF1bHRWYWx1ZShcbiAgICBvcHRpb25zLmV4YWdnZXJhdGlvblJlbGF0aXZlSGVpZ2h0LFxuICAgIDAuMFxuICApO1xuICB2YXIgaGFzRXhhZ2dlcmF0aW9uID0gZXhhZ2dlcmF0aW9uICE9PSAxLjA7XG4gIHZhciBpbmNsdWRlR2VvZGV0aWNTdXJmYWNlTm9ybWFscyA9IGhhc0V4YWdnZXJhdGlvbjtcblxuICB2YXIgc3RydWN0dXJlID0gZGVmYXVsdFZhbHVlKFxuICAgIG9wdGlvbnMuc3RydWN0dXJlLFxuICAgIEhlaWdodG1hcFRlc3NlbGxhdG9yLkRFRkFVTFRfU1RSVUNUVVJFXG4gICk7XG4gIHZhciBoZWlnaHRTY2FsZSA9IGRlZmF1bHRWYWx1ZShcbiAgICBzdHJ1Y3R1cmUuaGVpZ2h0U2NhbGUsXG4gICAgSGVpZ2h0bWFwVGVzc2VsbGF0b3IuREVGQVVMVF9TVFJVQ1RVUkUuaGVpZ2h0U2NhbGVcbiAgKTtcbiAgdmFyIGhlaWdodE9mZnNldCA9IGRlZmF1bHRWYWx1ZShcbiAgICBzdHJ1Y3R1cmUuaGVpZ2h0T2Zmc2V0LFxuICAgIEhlaWdodG1hcFRlc3NlbGxhdG9yLkRFRkFVTFRfU1RSVUNUVVJFLmhlaWdodE9mZnNldFxuICApO1xuICB2YXIgZWxlbWVudHNQZXJIZWlnaHQgPSBkZWZhdWx0VmFsdWUoXG4gICAgc3RydWN0dXJlLmVsZW1lbnRzUGVySGVpZ2h0LFxuICAgIEhlaWdodG1hcFRlc3NlbGxhdG9yLkRFRkFVTFRfU1RSVUNUVVJFLmVsZW1lbnRzUGVySGVpZ2h0XG4gICk7XG4gIHZhciBzdHJpZGUgPSBkZWZhdWx0VmFsdWUoXG4gICAgc3RydWN0dXJlLnN0cmlkZSxcbiAgICBIZWlnaHRtYXBUZXNzZWxsYXRvci5ERUZBVUxUX1NUUlVDVFVSRS5zdHJpZGVcbiAgKTtcbiAgdmFyIGVsZW1lbnRNdWx0aXBsaWVyID0gZGVmYXVsdFZhbHVlKFxuICAgIHN0cnVjdHVyZS5lbGVtZW50TXVsdGlwbGllcixcbiAgICBIZWlnaHRtYXBUZXNzZWxsYXRvci5ERUZBVUxUX1NUUlVDVFVSRS5lbGVtZW50TXVsdGlwbGllclxuICApO1xuICB2YXIgaXNCaWdFbmRpYW4gPSBkZWZhdWx0VmFsdWUoXG4gICAgc3RydWN0dXJlLmlzQmlnRW5kaWFuLFxuICAgIEhlaWdodG1hcFRlc3NlbGxhdG9yLkRFRkFVTFRfU1RSVUNUVVJFLmlzQmlnRW5kaWFuXG4gICk7XG5cbiAgdmFyIHJlY3RhbmdsZVdpZHRoID0gUmVjdGFuZ2xlLmNvbXB1dGVXaWR0aChuYXRpdmVSZWN0YW5nbGUpO1xuICB2YXIgcmVjdGFuZ2xlSGVpZ2h0ID0gUmVjdGFuZ2xlLmNvbXB1dGVIZWlnaHQobmF0aXZlUmVjdGFuZ2xlKTtcblxuICB2YXIgZ3JhbnVsYXJpdHlYID0gcmVjdGFuZ2xlV2lkdGggLyAod2lkdGggLSAxKTtcbiAgdmFyIGdyYW51bGFyaXR5WSA9IHJlY3RhbmdsZUhlaWdodCAvIChoZWlnaHQgLSAxKTtcblxuICBpZiAoIWlzR2VvZ3JhcGhpYykge1xuICAgIHJlY3RhbmdsZVdpZHRoICo9IG9uZU92ZXJHbG9iZVNlbWltYWpvckF4aXM7XG4gICAgcmVjdGFuZ2xlSGVpZ2h0ICo9IG9uZU92ZXJHbG9iZVNlbWltYWpvckF4aXM7XG4gIH1cblxuICB2YXIgcmFkaWlTcXVhcmVkID0gZWxsaXBzb2lkLnJhZGlpU3F1YXJlZDtcbiAgdmFyIHJhZGlpU3F1YXJlZFggPSByYWRpaVNxdWFyZWQueDtcbiAgdmFyIHJhZGlpU3F1YXJlZFkgPSByYWRpaVNxdWFyZWQueTtcbiAgdmFyIHJhZGlpU3F1YXJlZFogPSByYWRpaVNxdWFyZWQuejtcblxuICB2YXIgbWluaW11bUhlaWdodCA9IDY1NTM2LjA7XG4gIHZhciBtYXhpbXVtSGVpZ2h0ID0gLTY1NTM2LjA7XG5cbiAgdmFyIGZyb21FTlUgPSBUcmFuc2Zvcm1zLmVhc3ROb3J0aFVwVG9GaXhlZEZyYW1lKHJlbGF0aXZlVG9DZW50ZXIsIGVsbGlwc29pZCk7XG4gIHZhciB0b0VOVSA9IE1hdHJpeDQuaW52ZXJzZVRyYW5zZm9ybWF0aW9uKGZyb21FTlUsIG1hdHJpeDRTY3JhdGNoKTtcblxuICB2YXIgc291dGhNZXJjYXRvclk7XG4gIHZhciBvbmVPdmVyTWVyY2F0b3JIZWlnaHQ7XG4gIGlmIChpbmNsdWRlV2ViTWVyY2F0b3JUKSB7XG4gICAgc291dGhNZXJjYXRvclkgPSBXZWJNZXJjYXRvclByb2plY3Rpb24uZ2VvZGV0aWNMYXRpdHVkZVRvTWVyY2F0b3JBbmdsZShcbiAgICAgIGdlb2dyYXBoaWNTb3V0aFxuICAgICk7XG4gICAgb25lT3Zlck1lcmNhdG9ySGVpZ2h0ID1cbiAgICAgIDEuMCAvXG4gICAgICAoV2ViTWVyY2F0b3JQcm9qZWN0aW9uLmdlb2RldGljTGF0aXR1ZGVUb01lcmNhdG9yQW5nbGUoZ2VvZ3JhcGhpY05vcnRoKSAtXG4gICAgICAgIHNvdXRoTWVyY2F0b3JZKTtcbiAgfVxuXG4gIHZhciBtaW5pbXVtID0gbWluaW11bVNjcmF0Y2g7XG4gIG1pbmltdW0ueCA9IE51bWJlci5QT1NJVElWRV9JTkZJTklUWTtcbiAgbWluaW11bS55ID0gTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZO1xuICBtaW5pbXVtLnogPSBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFk7XG5cbiAgdmFyIG1heGltdW0gPSBtYXhpbXVtU2NyYXRjaDtcbiAgbWF4aW11bS54ID0gTnVtYmVyLk5FR0FUSVZFX0lORklOSVRZO1xuICBtYXhpbXVtLnkgPSBOdW1iZXIuTkVHQVRJVkVfSU5GSU5JVFk7XG4gIG1heGltdW0ueiA9IE51bWJlci5ORUdBVElWRV9JTkZJTklUWTtcblxuICB2YXIgaE1pbiA9IE51bWJlci5QT1NJVElWRV9JTkZJTklUWTtcblxuICB2YXIgZ3JpZFZlcnRleENvdW50ID0gd2lkdGggKiBoZWlnaHQ7XG4gIHZhciBlZGdlVmVydGV4Q291bnQgPSBza2lydEhlaWdodCA+IDAuMCA/IHdpZHRoICogMiArIGhlaWdodCAqIDIgOiAwO1xuICB2YXIgdmVydGV4Q291bnQgPSBncmlkVmVydGV4Q291bnQgKyBlZGdlVmVydGV4Q291bnQ7XG5cbiAgdmFyIHBvc2l0aW9ucyA9IG5ldyBBcnJheSh2ZXJ0ZXhDb3VudCk7XG4gIHZhciBoZWlnaHRzID0gbmV3IEFycmF5KHZlcnRleENvdW50KTtcbiAgdmFyIHV2cyA9IG5ldyBBcnJheSh2ZXJ0ZXhDb3VudCk7XG4gIHZhciB3ZWJNZXJjYXRvclRzID0gaW5jbHVkZVdlYk1lcmNhdG9yVCA/IG5ldyBBcnJheSh2ZXJ0ZXhDb3VudCkgOiBbXTtcbiAgdmFyIGdlb2RldGljU3VyZmFjZU5vcm1hbHMgPSBpbmNsdWRlR2VvZGV0aWNTdXJmYWNlTm9ybWFsc1xuICAgID8gbmV3IEFycmF5KHZlcnRleENvdW50KVxuICAgIDogW107XG5cbiAgdmFyIHN0YXJ0Um93ID0gMDtcbiAgdmFyIGVuZFJvdyA9IGhlaWdodDtcbiAgdmFyIHN0YXJ0Q29sID0gMDtcbiAgdmFyIGVuZENvbCA9IHdpZHRoO1xuXG4gIGlmIChoYXNTa2lydHMpIHtcbiAgICAtLXN0YXJ0Um93O1xuICAgICsrZW5kUm93O1xuICAgIC0tc3RhcnRDb2w7XG4gICAgKytlbmRDb2w7XG4gIH1cblxuICB2YXIgc2tpcnRPZmZzZXRQZXJjZW50YWdlID0gMC4wMDAwMTtcblxuICBmb3IgKHZhciByb3dJbmRleCA9IHN0YXJ0Um93OyByb3dJbmRleCA8IGVuZFJvdzsgKytyb3dJbmRleCkge1xuICAgIHZhciByb3cgPSByb3dJbmRleDtcbiAgICBpZiAocm93IDwgMCkge1xuICAgICAgcm93ID0gMDtcbiAgICB9XG4gICAgaWYgKHJvdyA+PSBoZWlnaHQpIHtcbiAgICAgIHJvdyA9IGhlaWdodCAtIDE7XG4gICAgfVxuXG4gICAgdmFyIGxhdGl0dWRlID0gbmF0aXZlUmVjdGFuZ2xlLm5vcnRoIC0gZ3JhbnVsYXJpdHlZICogcm93O1xuXG4gICAgaWYgKCFpc0dlb2dyYXBoaWMpIHtcbiAgICAgIGxhdGl0dWRlID1cbiAgICAgICAgcGlPdmVyVHdvIC0gMi4wICogYXRhbihleHAoLWxhdGl0dWRlICogb25lT3Zlckdsb2JlU2VtaW1ham9yQXhpcykpO1xuICAgIH0gZWxzZSB7XG4gICAgICBsYXRpdHVkZSA9IHRvUmFkaWFucyhsYXRpdHVkZSk7XG4gICAgfVxuXG4gICAgdmFyIHYgPSAobGF0aXR1ZGUgLSBnZW9ncmFwaGljU291dGgpIC8gKGdlb2dyYXBoaWNOb3J0aCAtIGdlb2dyYXBoaWNTb3V0aCk7XG4gICAgdiA9IENlc2l1bU1hdGguY2xhbXAodiwgMC4wLCAxLjApO1xuXG4gICAgdmFyIGlzTm9ydGhFZGdlID0gcm93SW5kZXggPT09IHN0YXJ0Um93O1xuICAgIHZhciBpc1NvdXRoRWRnZSA9IHJvd0luZGV4ID09PSBlbmRSb3cgLSAxO1xuICAgIGlmIChza2lydEhlaWdodCA+IDAuMCkge1xuICAgICAgaWYgKGlzTm9ydGhFZGdlKSB7XG4gICAgICAgIGxhdGl0dWRlICs9IHNraXJ0T2Zmc2V0UGVyY2VudGFnZSAqIHJlY3RhbmdsZUhlaWdodDtcbiAgICAgIH0gZWxzZSBpZiAoaXNTb3V0aEVkZ2UpIHtcbiAgICAgICAgbGF0aXR1ZGUgLT0gc2tpcnRPZmZzZXRQZXJjZW50YWdlICogcmVjdGFuZ2xlSGVpZ2h0O1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBjb3NMYXRpdHVkZSA9IGNvcyhsYXRpdHVkZSk7XG4gICAgdmFyIG5aID0gc2luKGxhdGl0dWRlKTtcbiAgICB2YXIga1ogPSByYWRpaVNxdWFyZWRaICogblo7XG5cbiAgICB2YXIgd2ViTWVyY2F0b3JUO1xuICAgIGlmIChpbmNsdWRlV2ViTWVyY2F0b3JUKSB7XG4gICAgICB3ZWJNZXJjYXRvclQgPVxuICAgICAgICAoV2ViTWVyY2F0b3JQcm9qZWN0aW9uLmdlb2RldGljTGF0aXR1ZGVUb01lcmNhdG9yQW5nbGUobGF0aXR1ZGUpIC1cbiAgICAgICAgICBzb3V0aE1lcmNhdG9yWSkgKlxuICAgICAgICBvbmVPdmVyTWVyY2F0b3JIZWlnaHQ7XG4gICAgfVxuXG4gICAgZm9yICh2YXIgY29sSW5kZXggPSBzdGFydENvbDsgY29sSW5kZXggPCBlbmRDb2w7ICsrY29sSW5kZXgpIHtcbiAgICAgIHZhciBjb2wgPSBjb2xJbmRleDtcbiAgICAgIGlmIChjb2wgPCAwKSB7XG4gICAgICAgIGNvbCA9IDA7XG4gICAgICB9XG4gICAgICBpZiAoY29sID49IHdpZHRoKSB7XG4gICAgICAgIGNvbCA9IHdpZHRoIC0gMTtcbiAgICAgIH1cblxuICAgICAgdmFyIHRlcnJhaW5PZmZzZXQgPSByb3cgKiAod2lkdGggKiBzdHJpZGUpICsgY29sICogc3RyaWRlO1xuXG4gICAgICB2YXIgaGVpZ2h0U2FtcGxlO1xuICAgICAgaWYgKGVsZW1lbnRzUGVySGVpZ2h0ID09PSAxKSB7XG4gICAgICAgIGhlaWdodFNhbXBsZSA9IGhlaWdodG1hcFt0ZXJyYWluT2Zmc2V0XTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGhlaWdodFNhbXBsZSA9IDA7XG5cbiAgICAgICAgdmFyIGVsZW1lbnRPZmZzZXQ7XG4gICAgICAgIGlmIChpc0JpZ0VuZGlhbikge1xuICAgICAgICAgIGZvciAoXG4gICAgICAgICAgICBlbGVtZW50T2Zmc2V0ID0gMDtcbiAgICAgICAgICAgIGVsZW1lbnRPZmZzZXQgPCBlbGVtZW50c1BlckhlaWdodDtcbiAgICAgICAgICAgICsrZWxlbWVudE9mZnNldFxuICAgICAgICAgICkge1xuICAgICAgICAgICAgaGVpZ2h0U2FtcGxlID1cbiAgICAgICAgICAgICAgaGVpZ2h0U2FtcGxlICogZWxlbWVudE11bHRpcGxpZXIgK1xuICAgICAgICAgICAgICBoZWlnaHRtYXBbdGVycmFpbk9mZnNldCArIGVsZW1lbnRPZmZzZXRdO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBmb3IgKFxuICAgICAgICAgICAgZWxlbWVudE9mZnNldCA9IGVsZW1lbnRzUGVySGVpZ2h0IC0gMTtcbiAgICAgICAgICAgIGVsZW1lbnRPZmZzZXQgPj0gMDtcbiAgICAgICAgICAgIC0tZWxlbWVudE9mZnNldFxuICAgICAgICAgICkge1xuICAgICAgICAgICAgaGVpZ2h0U2FtcGxlID1cbiAgICAgICAgICAgICAgaGVpZ2h0U2FtcGxlICogZWxlbWVudE11bHRpcGxpZXIgK1xuICAgICAgICAgICAgICBoZWlnaHRtYXBbdGVycmFpbk9mZnNldCArIGVsZW1lbnRPZmZzZXRdO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBoZWlnaHRTYW1wbGUgPSBoZWlnaHRTYW1wbGUgKiBoZWlnaHRTY2FsZSArIGhlaWdodE9mZnNldDtcblxuICAgICAgbWF4aW11bUhlaWdodCA9IE1hdGgubWF4KG1heGltdW1IZWlnaHQsIGhlaWdodFNhbXBsZSk7XG4gICAgICBtaW5pbXVtSGVpZ2h0ID0gTWF0aC5taW4obWluaW11bUhlaWdodCwgaGVpZ2h0U2FtcGxlKTtcblxuICAgICAgdmFyIGxvbmdpdHVkZSA9IG5hdGl2ZVJlY3RhbmdsZS53ZXN0ICsgZ3JhbnVsYXJpdHlYICogY29sO1xuXG4gICAgICBpZiAoIWlzR2VvZ3JhcGhpYykge1xuICAgICAgICBsb25naXR1ZGUgPSBsb25naXR1ZGUgKiBvbmVPdmVyR2xvYmVTZW1pbWFqb3JBeGlzO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbG9uZ2l0dWRlID0gdG9SYWRpYW5zKGxvbmdpdHVkZSk7XG4gICAgICB9XG5cbiAgICAgIHZhciB1ID0gKGxvbmdpdHVkZSAtIGdlb2dyYXBoaWNXZXN0KSAvIChnZW9ncmFwaGljRWFzdCAtIGdlb2dyYXBoaWNXZXN0KTtcbiAgICAgIHUgPSBDZXNpdW1NYXRoLmNsYW1wKHUsIDAuMCwgMS4wKTtcblxuICAgICAgdmFyIGluZGV4ID0gcm93ICogd2lkdGggKyBjb2w7XG5cbiAgICAgIGlmIChza2lydEhlaWdodCA+IDAuMCkge1xuICAgICAgICB2YXIgaXNXZXN0RWRnZSA9IGNvbEluZGV4ID09PSBzdGFydENvbDtcbiAgICAgICAgdmFyIGlzRWFzdEVkZ2UgPSBjb2xJbmRleCA9PT0gZW5kQ29sIC0gMTtcbiAgICAgICAgdmFyIGlzRWRnZSA9IGlzTm9ydGhFZGdlIHx8IGlzU291dGhFZGdlIHx8IGlzV2VzdEVkZ2UgfHwgaXNFYXN0RWRnZTtcbiAgICAgICAgdmFyIGlzQ29ybmVyID1cbiAgICAgICAgICAoaXNOb3J0aEVkZ2UgfHwgaXNTb3V0aEVkZ2UpICYmIChpc1dlc3RFZGdlIHx8IGlzRWFzdEVkZ2UpO1xuICAgICAgICBpZiAoaXNDb3JuZXIpIHtcbiAgICAgICAgICAvLyBEb24ndCBnZW5lcmF0ZSBza2lydHMgb24gdGhlIGNvcm5lcnMuXG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH0gZWxzZSBpZiAoaXNFZGdlKSB7XG4gICAgICAgICAgaGVpZ2h0U2FtcGxlIC09IHNraXJ0SGVpZ2h0O1xuXG4gICAgICAgICAgaWYgKGlzV2VzdEVkZ2UpIHtcbiAgICAgICAgICAgIC8vIFRoZSBvdXRlciBsb29wIGl0ZXJhdGVzIG5vcnRoIHRvIHNvdXRoIGJ1dCB0aGUgaW5kaWNlcyBhcmUgb3JkZXJlZCBzb3V0aCB0byBub3J0aCwgaGVuY2UgdGhlIGluZGV4IGZsaXAgYmVsb3dcbiAgICAgICAgICAgIGluZGV4ID0gZ3JpZFZlcnRleENvdW50ICsgKGhlaWdodCAtIHJvdyAtIDEpO1xuICAgICAgICAgICAgbG9uZ2l0dWRlIC09IHNraXJ0T2Zmc2V0UGVyY2VudGFnZSAqIHJlY3RhbmdsZVdpZHRoO1xuICAgICAgICAgIH0gZWxzZSBpZiAoaXNTb3V0aEVkZ2UpIHtcbiAgICAgICAgICAgIC8vIEFkZCBhZnRlciB3ZXN0IGluZGljZXMuIFNvdXRoIGluZGljZXMgYXJlIG9yZGVyZWQgZWFzdCB0byB3ZXN0LlxuICAgICAgICAgICAgaW5kZXggPSBncmlkVmVydGV4Q291bnQgKyBoZWlnaHQgKyAod2lkdGggLSBjb2wgLSAxKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKGlzRWFzdEVkZ2UpIHtcbiAgICAgICAgICAgIC8vIEFkZCBhZnRlciB3ZXN0IGFuZCBzb3V0aCBpbmRpY2VzLiBFYXN0IGluZGljZXMgYXJlIG9yZGVyZWQgbm9ydGggdG8gc291dGguIFRoZSBpbmRleCBpcyBmbGlwcGVkIGxpa2UgYWJvdmUuXG4gICAgICAgICAgICBpbmRleCA9IGdyaWRWZXJ0ZXhDb3VudCArIGhlaWdodCArIHdpZHRoICsgcm93O1xuICAgICAgICAgICAgbG9uZ2l0dWRlICs9IHNraXJ0T2Zmc2V0UGVyY2VudGFnZSAqIHJlY3RhbmdsZVdpZHRoO1xuICAgICAgICAgIH0gZWxzZSBpZiAoaXNOb3J0aEVkZ2UpIHtcbiAgICAgICAgICAgIC8vIEFkZCBhZnRlciB3ZXN0LCBzb3V0aCwgYW5kIGVhc3QgaW5kaWNlcy4gTm9ydGggaW5kaWNlcyBhcmUgb3JkZXJlZCB3ZXN0IHRvIGVhc3QuXG4gICAgICAgICAgICBpbmRleCA9IGdyaWRWZXJ0ZXhDb3VudCArIGhlaWdodCArIHdpZHRoICsgaGVpZ2h0ICsgY29sO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB2YXIgblggPSBjb3NMYXRpdHVkZSAqIGNvcyhsb25naXR1ZGUpO1xuICAgICAgdmFyIG5ZID0gY29zTGF0aXR1ZGUgKiBzaW4obG9uZ2l0dWRlKTtcblxuICAgICAgdmFyIGtYID0gcmFkaWlTcXVhcmVkWCAqIG5YO1xuICAgICAgdmFyIGtZID0gcmFkaWlTcXVhcmVkWSAqIG5ZO1xuXG4gICAgICB2YXIgZ2FtbWEgPSBzcXJ0KGtYICogblggKyBrWSAqIG5ZICsga1ogKiBuWik7XG4gICAgICB2YXIgb25lT3ZlckdhbW1hID0gMS4wIC8gZ2FtbWE7XG5cbiAgICAgIHZhciByU3VyZmFjZVggPSBrWCAqIG9uZU92ZXJHYW1tYTtcbiAgICAgIHZhciByU3VyZmFjZVkgPSBrWSAqIG9uZU92ZXJHYW1tYTtcbiAgICAgIHZhciByU3VyZmFjZVogPSBrWiAqIG9uZU92ZXJHYW1tYTtcblxuICAgICAgdmFyIHBvc2l0aW9uID0gbmV3IENhcnRlc2lhbjMoKTtcbiAgICAgIHBvc2l0aW9uLnggPSByU3VyZmFjZVggKyBuWCAqIGhlaWdodFNhbXBsZTtcbiAgICAgIHBvc2l0aW9uLnkgPSByU3VyZmFjZVkgKyBuWSAqIGhlaWdodFNhbXBsZTtcbiAgICAgIHBvc2l0aW9uLnogPSByU3VyZmFjZVogKyBuWiAqIGhlaWdodFNhbXBsZTtcblxuICAgICAgTWF0cml4NC5tdWx0aXBseUJ5UG9pbnQodG9FTlUsIHBvc2l0aW9uLCBjYXJ0ZXNpYW4zU2NyYXRjaCk7XG4gICAgICBDYXJ0ZXNpYW4zLm1pbmltdW1CeUNvbXBvbmVudChjYXJ0ZXNpYW4zU2NyYXRjaCwgbWluaW11bSwgbWluaW11bSk7XG4gICAgICBDYXJ0ZXNpYW4zLm1heGltdW1CeUNvbXBvbmVudChjYXJ0ZXNpYW4zU2NyYXRjaCwgbWF4aW11bSwgbWF4aW11bSk7XG4gICAgICBoTWluID0gTWF0aC5taW4oaE1pbiwgaGVpZ2h0U2FtcGxlKTtcblxuICAgICAgcG9zaXRpb25zW2luZGV4XSA9IHBvc2l0aW9uO1xuICAgICAgdXZzW2luZGV4XSA9IG5ldyBDYXJ0ZXNpYW4yKHUsIHYpO1xuICAgICAgaGVpZ2h0c1tpbmRleF0gPSBoZWlnaHRTYW1wbGU7XG5cbiAgICAgIGlmIChpbmNsdWRlV2ViTWVyY2F0b3JUKSB7XG4gICAgICAgIHdlYk1lcmNhdG9yVHNbaW5kZXhdID0gd2ViTWVyY2F0b3JUO1xuICAgICAgfVxuXG4gICAgICBpZiAoaW5jbHVkZUdlb2RldGljU3VyZmFjZU5vcm1hbHMpIHtcbiAgICAgICAgZ2VvZGV0aWNTdXJmYWNlTm9ybWFsc1tpbmRleF0gPSBlbGxpcHNvaWQuZ2VvZGV0aWNTdXJmYWNlTm9ybWFsKFxuICAgICAgICAgIHBvc2l0aW9uXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgdmFyIGJvdW5kaW5nU3BoZXJlM0QgPSBCb3VuZGluZ1NwaGVyZS5mcm9tUG9pbnRzKHBvc2l0aW9ucyk7XG4gIHZhciBvcmllbnRlZEJvdW5kaW5nQm94O1xuICBpZiAoZGVmaW5lZChyZWN0YW5nbGUpKSB7XG4gICAgb3JpZW50ZWRCb3VuZGluZ0JveCA9IE9yaWVudGVkQm91bmRpbmdCb3guZnJvbVJlY3RhbmdsZShcbiAgICAgIHJlY3RhbmdsZSxcbiAgICAgIG1pbmltdW1IZWlnaHQsXG4gICAgICBtYXhpbXVtSGVpZ2h0LFxuICAgICAgZWxsaXBzb2lkXG4gICAgKTtcbiAgfVxuXG4gIHZhciBvY2NsdWRlZVBvaW50SW5TY2FsZWRTcGFjZTtcbiAgaWYgKGhhc1JlbGF0aXZlVG9DZW50ZXIpIHtcbiAgICB2YXIgb2NjbHVkZXIgPSBuZXcgRWxsaXBzb2lkYWxPY2NsdWRlcihlbGxpcHNvaWQpO1xuICAgIG9jY2x1ZGVlUG9pbnRJblNjYWxlZFNwYWNlID0gb2NjbHVkZXIuY29tcHV0ZUhvcml6b25DdWxsaW5nUG9pbnRQb3NzaWJseVVuZGVyRWxsaXBzb2lkKFxuICAgICAgcmVsYXRpdmVUb0NlbnRlcixcbiAgICAgIHBvc2l0aW9ucyxcbiAgICAgIG1pbmltdW1IZWlnaHRcbiAgICApO1xuICB9XG5cbiAgdmFyIGFhQm94ID0gbmV3IEF4aXNBbGlnbmVkQm91bmRpbmdCb3gobWluaW11bSwgbWF4aW11bSwgcmVsYXRpdmVUb0NlbnRlcik7XG4gIHZhciBlbmNvZGluZyA9IG5ldyBUZXJyYWluRW5jb2RpbmcoXG4gICAgcmVsYXRpdmVUb0NlbnRlcixcbiAgICBhYUJveCxcbiAgICBoTWluLFxuICAgIG1heGltdW1IZWlnaHQsXG4gICAgZnJvbUVOVSxcbiAgICBmYWxzZSxcbiAgICBpbmNsdWRlV2ViTWVyY2F0b3JULFxuICAgIGluY2x1ZGVHZW9kZXRpY1N1cmZhY2VOb3JtYWxzLFxuICAgIGV4YWdnZXJhdGlvbixcbiAgICBleGFnZ2VyYXRpb25SZWxhdGl2ZUhlaWdodFxuICApO1xuICB2YXIgdmVydGljZXMgPSBuZXcgRmxvYXQzMkFycmF5KHZlcnRleENvdW50ICogZW5jb2Rpbmcuc3RyaWRlKTtcblxuICB2YXIgYnVmZmVySW5kZXggPSAwO1xuICBmb3IgKHZhciBqID0gMDsgaiA8IHZlcnRleENvdW50OyArK2opIHtcbiAgICBidWZmZXJJbmRleCA9IGVuY29kaW5nLmVuY29kZShcbiAgICAgIHZlcnRpY2VzLFxuICAgICAgYnVmZmVySW5kZXgsXG4gICAgICBwb3NpdGlvbnNbal0sXG4gICAgICB1dnNbal0sXG4gICAgICBoZWlnaHRzW2pdLFxuICAgICAgdW5kZWZpbmVkLFxuICAgICAgd2ViTWVyY2F0b3JUc1tqXSxcbiAgICAgIGdlb2RldGljU3VyZmFjZU5vcm1hbHNbal1cbiAgICApO1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICB2ZXJ0aWNlczogdmVydGljZXMsXG4gICAgbWF4aW11bUhlaWdodDogbWF4aW11bUhlaWdodCxcbiAgICBtaW5pbXVtSGVpZ2h0OiBtaW5pbXVtSGVpZ2h0LFxuICAgIGVuY29kaW5nOiBlbmNvZGluZyxcbiAgICBib3VuZGluZ1NwaGVyZTNEOiBib3VuZGluZ1NwaGVyZTNELFxuICAgIG9yaWVudGVkQm91bmRpbmdCb3g6IG9yaWVudGVkQm91bmRpbmdCb3gsXG4gICAgb2NjbHVkZWVQb2ludEluU2NhbGVkU3BhY2U6IG9jY2x1ZGVlUG9pbnRJblNjYWxlZFNwYWNlLFxuICB9O1xufTtcbmV4cG9ydCBkZWZhdWx0IEhlaWdodG1hcFRlc3NlbGxhdG9yO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///25260\n')},72241:function(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__){eval('/* harmony import */ var _defaultValue_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(62200);\n/* harmony import */ var _defined_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(82982);\n/* harmony import */ var _DeveloperError_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(12572);\n/* harmony import */ var _Math_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(99417);\n\n\n\n\n\nvar factorial = _Math_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"].factorial */ .Z.factorial;\n\nfunction calculateCoefficientTerm(\n  x,\n  zIndices,\n  xTable,\n  derivOrder,\n  termOrder,\n  reservedIndices\n) {\n  var result = 0;\n  var reserved;\n  var i;\n  var j;\n\n  if (derivOrder > 0) {\n    for (i = 0; i < termOrder; i++) {\n      reserved = false;\n      for (j = 0; j < reservedIndices.length && !reserved; j++) {\n        if (i === reservedIndices[j]) {\n          reserved = true;\n        }\n      }\n\n      if (!reserved) {\n        reservedIndices.push(i);\n        result += calculateCoefficientTerm(\n          x,\n          zIndices,\n          xTable,\n          derivOrder - 1,\n          termOrder,\n          reservedIndices\n        );\n        reservedIndices.splice(reservedIndices.length - 1, 1);\n      }\n    }\n\n    return result;\n  }\n\n  result = 1;\n  for (i = 0; i < termOrder; i++) {\n    reserved = false;\n    for (j = 0; j < reservedIndices.length && !reserved; j++) {\n      if (i === reservedIndices[j]) {\n        reserved = true;\n      }\n    }\n\n    if (!reserved) {\n      result *= x - xTable[zIndices[i]];\n    }\n  }\n\n  return result;\n}\n\n/**\n * An {@link InterpolationAlgorithm} for performing Hermite interpolation.\n *\n * @namespace HermitePolynomialApproximation\n */\nvar HermitePolynomialApproximation = {\n  type: "Hermite",\n};\n\n/**\n * Given the desired degree, returns the number of data points required for interpolation.\n *\n * @param {Number} degree The desired degree of interpolation.\n * @param {Number} [inputOrder=0]  The order of the inputs (0 means just the data, 1 means the data and its derivative, etc).\n * @returns {Number} The number of required data points needed for the desired degree of interpolation.\n * @exception {DeveloperError} degree must be 0 or greater.\n * @exception {DeveloperError} inputOrder must be 0 or greater.\n */\nHermitePolynomialApproximation.getRequiredDataPoints = function (\n  degree,\n  inputOrder\n) {\n  inputOrder = (0,_defaultValue_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .Z)(inputOrder, 0);\n\n  //>>includeStart(\'debug\', pragmas.debug);\n  if (!(0,_defined_js__WEBPACK_IMPORTED_MODULE_3__/* ["default"] */ .Z)(degree)) {\n    throw new _DeveloperError_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .Z("degree is required.");\n  }\n  if (degree < 0) {\n    throw new _DeveloperError_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .Z("degree must be 0 or greater.");\n  }\n  if (inputOrder < 0) {\n    throw new _DeveloperError_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .Z("inputOrder must be 0 or greater.");\n  }\n  //>>includeEnd(\'debug\');\n\n  return Math.max(Math.floor((degree + 1) / (inputOrder + 1)), 2);\n};\n\n/**\n * Interpolates values using Hermite Polynomial Approximation.\n *\n * @param {Number} x The independent variable for which the dependent variables will be interpolated.\n * @param {Number[]} xTable The array of independent variables to use to interpolate.  The values\n * in this array must be in increasing order and the same value must not occur twice in the array.\n * @param {Number[]} yTable The array of dependent variables to use to interpolate.  For a set of three\n * dependent values (p,q,w) at time 1 and time 2 this should be as follows: {p1, q1, w1, p2, q2, w2}.\n * @param {Number} yStride The number of dependent variable values in yTable corresponding to\n * each independent variable value in xTable.\n * @param {Number[]} [result] An existing array into which to store the result.\n * @returns {Number[]} The array of interpolated values, or the result parameter if one was provided.\n */\nHermitePolynomialApproximation.interpolateOrderZero = function (\n  x,\n  xTable,\n  yTable,\n  yStride,\n  result\n) {\n  if (!(0,_defined_js__WEBPACK_IMPORTED_MODULE_3__/* ["default"] */ .Z)(result)) {\n    result = new Array(yStride);\n  }\n\n  var i;\n  var j;\n  var d;\n  var s;\n  var len;\n  var index;\n  var length = xTable.length;\n  var coefficients = new Array(yStride);\n\n  for (i = 0; i < yStride; i++) {\n    result[i] = 0;\n\n    var l = new Array(length);\n    coefficients[i] = l;\n    for (j = 0; j < length; j++) {\n      l[j] = [];\n    }\n  }\n\n  var zIndicesLength = length,\n    zIndices = new Array(zIndicesLength);\n\n  for (i = 0; i < zIndicesLength; i++) {\n    zIndices[i] = i;\n  }\n\n  var highestNonZeroCoef = length - 1;\n  for (s = 0; s < yStride; s++) {\n    for (j = 0; j < zIndicesLength; j++) {\n      index = zIndices[j] * yStride + s;\n      coefficients[s][0].push(yTable[index]);\n    }\n\n    for (i = 1; i < zIndicesLength; i++) {\n      var nonZeroCoefficients = false;\n      for (j = 0; j < zIndicesLength - i; j++) {\n        var zj = xTable[zIndices[j]];\n        var zn = xTable[zIndices[j + i]];\n\n        var numerator;\n        if (zn - zj <= 0) {\n          index = zIndices[j] * yStride + yStride * i + s;\n          numerator = yTable[index];\n          coefficients[s][i].push(numerator / factorial(i));\n        } else {\n          numerator = coefficients[s][i - 1][j + 1] - coefficients[s][i - 1][j];\n          coefficients[s][i].push(numerator / (zn - zj));\n        }\n        nonZeroCoefficients = nonZeroCoefficients || numerator !== 0;\n      }\n\n      if (!nonZeroCoefficients) {\n        highestNonZeroCoef = i - 1;\n      }\n    }\n  }\n\n  for (d = 0, len = 0; d <= len; d++) {\n    for (i = d; i <= highestNonZeroCoef; i++) {\n      var tempTerm = calculateCoefficientTerm(x, zIndices, xTable, d, i, []);\n      for (s = 0; s < yStride; s++) {\n        var coeff = coefficients[s][i][0];\n        result[s + d * yStride] += coeff * tempTerm;\n      }\n    }\n  }\n\n  return result;\n};\n\nvar arrayScratch = [];\n\n/**\n * Interpolates values using Hermite Polynomial Approximation.\n *\n * @param {Number} x The independent variable for which the dependent variables will be interpolated.\n * @param {Number[]} xTable The array of independent variables to use to interpolate.  The values\n * in this array must be in increasing order and the same value must not occur twice in the array.\n * @param {Number[]} yTable The array of dependent variables to use to interpolate.  For a set of three\n * dependent values (p,q,w) at time 1 and time 2 this should be as follows: {p1, q1, w1, p2, q2, w2}.\n * @param {Number} yStride The number of dependent variable values in yTable corresponding to\n * each independent variable value in xTable.\n * @param {Number} inputOrder The number of derivatives supplied for input.\n * @param {Number} outputOrder The number of derivatives desired for output.\n * @param {Number[]} [result] An existing array into which to store the result.\n *\n * @returns {Number[]} The array of interpolated values, or the result parameter if one was provided.\n */\nHermitePolynomialApproximation.interpolate = function (\n  x,\n  xTable,\n  yTable,\n  yStride,\n  inputOrder,\n  outputOrder,\n  result\n) {\n  var resultLength = yStride * (outputOrder + 1);\n  if (!(0,_defined_js__WEBPACK_IMPORTED_MODULE_3__/* ["default"] */ .Z)(result)) {\n    result = new Array(resultLength);\n  }\n  for (var r = 0; r < resultLength; r++) {\n    result[r] = 0;\n  }\n\n  var length = xTable.length;\n  // The zIndices array holds copies of the addresses of the xTable values\n  // in the range we\'re looking at. Even though this just holds information already\n  // available in xTable this is a much more convenient format.\n  var zIndices = new Array(length * (inputOrder + 1));\n  var i;\n  for (i = 0; i < length; i++) {\n    for (var j = 0; j < inputOrder + 1; j++) {\n      zIndices[i * (inputOrder + 1) + j] = i;\n    }\n  }\n\n  var zIndiceslength = zIndices.length;\n  var coefficients = arrayScratch;\n  var highestNonZeroCoef = fillCoefficientList(\n    coefficients,\n    zIndices,\n    xTable,\n    yTable,\n    yStride,\n    inputOrder\n  );\n  var reservedIndices = [];\n\n  var tmp = (zIndiceslength * (zIndiceslength + 1)) / 2;\n  var loopStop = Math.min(highestNonZeroCoef, outputOrder);\n  for (var d = 0; d <= loopStop; d++) {\n    for (i = d; i <= highestNonZeroCoef; i++) {\n      reservedIndices.length = 0;\n      var tempTerm = calculateCoefficientTerm(\n        x,\n        zIndices,\n        xTable,\n        d,\n        i,\n        reservedIndices\n      );\n      var dimTwo = Math.floor((i * (1 - i)) / 2) + zIndiceslength * i;\n\n      for (var s = 0; s < yStride; s++) {\n        var dimOne = Math.floor(s * tmp);\n        var coef = coefficients[dimOne + dimTwo];\n        result[s + d * yStride] += coef * tempTerm;\n      }\n    }\n  }\n\n  return result;\n};\n\nfunction fillCoefficientList(\n  coefficients,\n  zIndices,\n  xTable,\n  yTable,\n  yStride,\n  inputOrder\n) {\n  var j;\n  var index;\n  var highestNonZero = -1;\n  var zIndiceslength = zIndices.length;\n  var tmp = (zIndiceslength * (zIndiceslength + 1)) / 2;\n\n  for (var s = 0; s < yStride; s++) {\n    var dimOne = Math.floor(s * tmp);\n\n    for (j = 0; j < zIndiceslength; j++) {\n      index = zIndices[j] * yStride * (inputOrder + 1) + s;\n      coefficients[dimOne + j] = yTable[index];\n    }\n\n    for (var i = 1; i < zIndiceslength; i++) {\n      var coefIndex = 0;\n      var dimTwo = Math.floor((i * (1 - i)) / 2) + zIndiceslength * i;\n      var nonZeroCoefficients = false;\n\n      for (j = 0; j < zIndiceslength - i; j++) {\n        var zj = xTable[zIndices[j]];\n        var zn = xTable[zIndices[j + i]];\n\n        var numerator;\n        var coefficient;\n        if (zn - zj <= 0) {\n          index = zIndices[j] * yStride * (inputOrder + 1) + yStride * i + s;\n          numerator = yTable[index];\n          coefficient = numerator / _Math_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"].factorial */ .Z.factorial(i);\n          coefficients[dimOne + dimTwo + coefIndex] = coefficient;\n          coefIndex++;\n        } else {\n          var dimTwoMinusOne =\n            Math.floor(((i - 1) * (2 - i)) / 2) + zIndiceslength * (i - 1);\n          numerator =\n            coefficients[dimOne + dimTwoMinusOne + j + 1] -\n            coefficients[dimOne + dimTwoMinusOne + j];\n          coefficient = numerator / (zn - zj);\n          coefficients[dimOne + dimTwo + coefIndex] = coefficient;\n          coefIndex++;\n        }\n        nonZeroCoefficients = nonZeroCoefficients || numerator !== 0.0;\n      }\n\n      if (nonZeroCoefficients) {\n        highestNonZero = Math.max(highestNonZero, i);\n      }\n    }\n  }\n\n  return highestNonZero;\n}\n/* harmony default export */ __webpack_exports__["Z"] = (HermitePolynomialApproximation);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNzIyNDEuanMiLCJtYXBwaW5ncyI6Ijs7OztBQUE2QztBQUNWO0FBQ2M7QUFDZDs7QUFFbkMsZ0JBQWdCLDZFQUFvQjs7QUFFcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZ0JBQWdCLGVBQWU7QUFDL0I7QUFDQSxrQkFBa0IseUNBQXlDO0FBQzNEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxjQUFjLGVBQWU7QUFDN0I7QUFDQSxnQkFBZ0IseUNBQXlDO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxPQUFPLDhCQUE4QjtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixhQUFhLFFBQVE7QUFDckIsZUFBZSxnQkFBZ0I7QUFDL0IsZUFBZSxnQkFBZ0I7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUscUVBQVk7O0FBRTNCO0FBQ0EsT0FBTyxnRUFBTztBQUNkLGNBQWMsbUVBQWM7QUFDNUI7QUFDQTtBQUNBLGNBQWMsbUVBQWM7QUFDNUI7QUFDQTtBQUNBLGNBQWMsbUVBQWM7QUFDNUI7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFVBQVU7QUFDckI7QUFDQSxXQUFXLFVBQVU7QUFDckIsNkVBQTZFLHVCQUF1QjtBQUNwRyxXQUFXLFFBQVE7QUFDbkI7QUFDQSxXQUFXLFVBQVU7QUFDckIsYUFBYSxVQUFVO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPLGdFQUFPO0FBQ2Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGNBQWMsYUFBYTtBQUMzQjs7QUFFQTtBQUNBO0FBQ0EsZ0JBQWdCLFlBQVk7QUFDNUI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsY0FBYyxvQkFBb0I7QUFDbEM7QUFDQTs7QUFFQTtBQUNBLGNBQWMsYUFBYTtBQUMzQixnQkFBZ0Isb0JBQW9CO0FBQ3BDO0FBQ0E7QUFDQTs7QUFFQSxnQkFBZ0Isb0JBQW9CO0FBQ3BDO0FBQ0Esa0JBQWtCLHdCQUF3QjtBQUMxQztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHVCQUF1QixVQUFVO0FBQ2pDLGdCQUFnQix5QkFBeUI7QUFDekM7QUFDQSxrQkFBa0IsYUFBYTtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsVUFBVTtBQUNyQjtBQUNBLFdBQVcsVUFBVTtBQUNyQiw2RUFBNkUsdUJBQXVCO0FBQ3BHLFdBQVcsUUFBUTtBQUNuQjtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxVQUFVO0FBQ3JCO0FBQ0EsYUFBYSxVQUFVO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPLGdFQUFPO0FBQ2Q7QUFDQTtBQUNBLGtCQUFrQixrQkFBa0I7QUFDcEM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLFlBQVk7QUFDMUIsb0JBQW9CLG9CQUFvQjtBQUN4QztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esa0JBQWtCLGVBQWU7QUFDakMsZ0JBQWdCLHlCQUF5QjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxzQkFBc0IsYUFBYTtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxrQkFBa0IsYUFBYTtBQUMvQjs7QUFFQSxnQkFBZ0Isb0JBQW9CO0FBQ3BDO0FBQ0E7QUFDQTs7QUFFQSxvQkFBb0Isb0JBQW9CO0FBQ3hDO0FBQ0E7QUFDQTs7QUFFQSxrQkFBa0Isd0JBQXdCO0FBQzFDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyw2RUFBb0I7QUFDeEQ7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHlEQUFlLDhCQUE4QixFQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdnVlMy13ZWJwYWNrNS8uL25vZGVfbW9kdWxlcy9jZXNpdW0vU291cmNlL0NvcmUvSGVybWl0ZVBvbHlub21pYWxBcHByb3hpbWF0aW9uLmpzPzY2NDIiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IGRlZmF1bHRWYWx1ZSBmcm9tIFwiLi9kZWZhdWx0VmFsdWUuanNcIjtcbmltcG9ydCBkZWZpbmVkIGZyb20gXCIuL2RlZmluZWQuanNcIjtcbmltcG9ydCBEZXZlbG9wZXJFcnJvciBmcm9tIFwiLi9EZXZlbG9wZXJFcnJvci5qc1wiO1xuaW1wb3J0IENlc2l1bU1hdGggZnJvbSBcIi4vTWF0aC5qc1wiO1xuXG52YXIgZmFjdG9yaWFsID0gQ2VzaXVtTWF0aC5mYWN0b3JpYWw7XG5cbmZ1bmN0aW9uIGNhbGN1bGF0ZUNvZWZmaWNpZW50VGVybShcbiAgeCxcbiAgekluZGljZXMsXG4gIHhUYWJsZSxcbiAgZGVyaXZPcmRlcixcbiAgdGVybU9yZGVyLFxuICByZXNlcnZlZEluZGljZXNcbikge1xuICB2YXIgcmVzdWx0ID0gMDtcbiAgdmFyIHJlc2VydmVkO1xuICB2YXIgaTtcbiAgdmFyIGo7XG5cbiAgaWYgKGRlcml2T3JkZXIgPiAwKSB7XG4gICAgZm9yIChpID0gMDsgaSA8IHRlcm1PcmRlcjsgaSsrKSB7XG4gICAgICByZXNlcnZlZCA9IGZhbHNlO1xuICAgICAgZm9yIChqID0gMDsgaiA8IHJlc2VydmVkSW5kaWNlcy5sZW5ndGggJiYgIXJlc2VydmVkOyBqKyspIHtcbiAgICAgICAgaWYgKGkgPT09IHJlc2VydmVkSW5kaWNlc1tqXSkge1xuICAgICAgICAgIHJlc2VydmVkID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoIXJlc2VydmVkKSB7XG4gICAgICAgIHJlc2VydmVkSW5kaWNlcy5wdXNoKGkpO1xuICAgICAgICByZXN1bHQgKz0gY2FsY3VsYXRlQ29lZmZpY2llbnRUZXJtKFxuICAgICAgICAgIHgsXG4gICAgICAgICAgekluZGljZXMsXG4gICAgICAgICAgeFRhYmxlLFxuICAgICAgICAgIGRlcml2T3JkZXIgLSAxLFxuICAgICAgICAgIHRlcm1PcmRlcixcbiAgICAgICAgICByZXNlcnZlZEluZGljZXNcbiAgICAgICAgKTtcbiAgICAgICAgcmVzZXJ2ZWRJbmRpY2VzLnNwbGljZShyZXNlcnZlZEluZGljZXMubGVuZ3RoIC0gMSwgMSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIHJlc3VsdCA9IDE7XG4gIGZvciAoaSA9IDA7IGkgPCB0ZXJtT3JkZXI7IGkrKykge1xuICAgIHJlc2VydmVkID0gZmFsc2U7XG4gICAgZm9yIChqID0gMDsgaiA8IHJlc2VydmVkSW5kaWNlcy5sZW5ndGggJiYgIXJlc2VydmVkOyBqKyspIHtcbiAgICAgIGlmIChpID09PSByZXNlcnZlZEluZGljZXNbal0pIHtcbiAgICAgICAgcmVzZXJ2ZWQgPSB0cnVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICghcmVzZXJ2ZWQpIHtcbiAgICAgIHJlc3VsdCAqPSB4IC0geFRhYmxlW3pJbmRpY2VzW2ldXTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vKipcbiAqIEFuIHtAbGluayBJbnRlcnBvbGF0aW9uQWxnb3JpdGhtfSBmb3IgcGVyZm9ybWluZyBIZXJtaXRlIGludGVycG9sYXRpb24uXG4gKlxuICogQG5hbWVzcGFjZSBIZXJtaXRlUG9seW5vbWlhbEFwcHJveGltYXRpb25cbiAqL1xudmFyIEhlcm1pdGVQb2x5bm9taWFsQXBwcm94aW1hdGlvbiA9IHtcbiAgdHlwZTogXCJIZXJtaXRlXCIsXG59O1xuXG4vKipcbiAqIEdpdmVuIHRoZSBkZXNpcmVkIGRlZ3JlZSwgcmV0dXJucyB0aGUgbnVtYmVyIG9mIGRhdGEgcG9pbnRzIHJlcXVpcmVkIGZvciBpbnRlcnBvbGF0aW9uLlxuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSBkZWdyZWUgVGhlIGRlc2lyZWQgZGVncmVlIG9mIGludGVycG9sYXRpb24uXG4gKiBAcGFyYW0ge051bWJlcn0gW2lucHV0T3JkZXI9MF0gIFRoZSBvcmRlciBvZiB0aGUgaW5wdXRzICgwIG1lYW5zIGp1c3QgdGhlIGRhdGEsIDEgbWVhbnMgdGhlIGRhdGEgYW5kIGl0cyBkZXJpdmF0aXZlLCBldGMpLlxuICogQHJldHVybnMge051bWJlcn0gVGhlIG51bWJlciBvZiByZXF1aXJlZCBkYXRhIHBvaW50cyBuZWVkZWQgZm9yIHRoZSBkZXNpcmVkIGRlZ3JlZSBvZiBpbnRlcnBvbGF0aW9uLlxuICogQGV4Y2VwdGlvbiB7RGV2ZWxvcGVyRXJyb3J9IGRlZ3JlZSBtdXN0IGJlIDAgb3IgZ3JlYXRlci5cbiAqIEBleGNlcHRpb24ge0RldmVsb3BlckVycm9yfSBpbnB1dE9yZGVyIG11c3QgYmUgMCBvciBncmVhdGVyLlxuICovXG5IZXJtaXRlUG9seW5vbWlhbEFwcHJveGltYXRpb24uZ2V0UmVxdWlyZWREYXRhUG9pbnRzID0gZnVuY3Rpb24gKFxuICBkZWdyZWUsXG4gIGlucHV0T3JkZXJcbikge1xuICBpbnB1dE9yZGVyID0gZGVmYXVsdFZhbHVlKGlucHV0T3JkZXIsIDApO1xuXG4gIC8vPj5pbmNsdWRlU3RhcnQoJ2RlYnVnJywgcHJhZ21hcy5kZWJ1Zyk7XG4gIGlmICghZGVmaW5lZChkZWdyZWUpKSB7XG4gICAgdGhyb3cgbmV3IERldmVsb3BlckVycm9yKFwiZGVncmVlIGlzIHJlcXVpcmVkLlwiKTtcbiAgfVxuICBpZiAoZGVncmVlIDwgMCkge1xuICAgIHRocm93IG5ldyBEZXZlbG9wZXJFcnJvcihcImRlZ3JlZSBtdXN0IGJlIDAgb3IgZ3JlYXRlci5cIik7XG4gIH1cbiAgaWYgKGlucHV0T3JkZXIgPCAwKSB7XG4gICAgdGhyb3cgbmV3IERldmVsb3BlckVycm9yKFwiaW5wdXRPcmRlciBtdXN0IGJlIDAgb3IgZ3JlYXRlci5cIik7XG4gIH1cbiAgLy8+PmluY2x1ZGVFbmQoJ2RlYnVnJyk7XG5cbiAgcmV0dXJuIE1hdGgubWF4KE1hdGguZmxvb3IoKGRlZ3JlZSArIDEpIC8gKGlucHV0T3JkZXIgKyAxKSksIDIpO1xufTtcblxuLyoqXG4gKiBJbnRlcnBvbGF0ZXMgdmFsdWVzIHVzaW5nIEhlcm1pdGUgUG9seW5vbWlhbCBBcHByb3hpbWF0aW9uLlxuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSB4IFRoZSBpbmRlcGVuZGVudCB2YXJpYWJsZSBmb3Igd2hpY2ggdGhlIGRlcGVuZGVudCB2YXJpYWJsZXMgd2lsbCBiZSBpbnRlcnBvbGF0ZWQuXG4gKiBAcGFyYW0ge051bWJlcltdfSB4VGFibGUgVGhlIGFycmF5IG9mIGluZGVwZW5kZW50IHZhcmlhYmxlcyB0byB1c2UgdG8gaW50ZXJwb2xhdGUuICBUaGUgdmFsdWVzXG4gKiBpbiB0aGlzIGFycmF5IG11c3QgYmUgaW4gaW5jcmVhc2luZyBvcmRlciBhbmQgdGhlIHNhbWUgdmFsdWUgbXVzdCBub3Qgb2NjdXIgdHdpY2UgaW4gdGhlIGFycmF5LlxuICogQHBhcmFtIHtOdW1iZXJbXX0geVRhYmxlIFRoZSBhcnJheSBvZiBkZXBlbmRlbnQgdmFyaWFibGVzIHRvIHVzZSB0byBpbnRlcnBvbGF0ZS4gIEZvciBhIHNldCBvZiB0aHJlZVxuICogZGVwZW5kZW50IHZhbHVlcyAocCxxLHcpIGF0IHRpbWUgMSBhbmQgdGltZSAyIHRoaXMgc2hvdWxkIGJlIGFzIGZvbGxvd3M6IHtwMSwgcTEsIHcxLCBwMiwgcTIsIHcyfS5cbiAqIEBwYXJhbSB7TnVtYmVyfSB5U3RyaWRlIFRoZSBudW1iZXIgb2YgZGVwZW5kZW50IHZhcmlhYmxlIHZhbHVlcyBpbiB5VGFibGUgY29ycmVzcG9uZGluZyB0b1xuICogZWFjaCBpbmRlcGVuZGVudCB2YXJpYWJsZSB2YWx1ZSBpbiB4VGFibGUuXG4gKiBAcGFyYW0ge051bWJlcltdfSBbcmVzdWx0XSBBbiBleGlzdGluZyBhcnJheSBpbnRvIHdoaWNoIHRvIHN0b3JlIHRoZSByZXN1bHQuXG4gKiBAcmV0dXJucyB7TnVtYmVyW119IFRoZSBhcnJheSBvZiBpbnRlcnBvbGF0ZWQgdmFsdWVzLCBvciB0aGUgcmVzdWx0IHBhcmFtZXRlciBpZiBvbmUgd2FzIHByb3ZpZGVkLlxuICovXG5IZXJtaXRlUG9seW5vbWlhbEFwcHJveGltYXRpb24uaW50ZXJwb2xhdGVPcmRlclplcm8gPSBmdW5jdGlvbiAoXG4gIHgsXG4gIHhUYWJsZSxcbiAgeVRhYmxlLFxuICB5U3RyaWRlLFxuICByZXN1bHRcbikge1xuICBpZiAoIWRlZmluZWQocmVzdWx0KSkge1xuICAgIHJlc3VsdCA9IG5ldyBBcnJheSh5U3RyaWRlKTtcbiAgfVxuXG4gIHZhciBpO1xuICB2YXIgajtcbiAgdmFyIGQ7XG4gIHZhciBzO1xuICB2YXIgbGVuO1xuICB2YXIgaW5kZXg7XG4gIHZhciBsZW5ndGggPSB4VGFibGUubGVuZ3RoO1xuICB2YXIgY29lZmZpY2llbnRzID0gbmV3IEFycmF5KHlTdHJpZGUpO1xuXG4gIGZvciAoaSA9IDA7IGkgPCB5U3RyaWRlOyBpKyspIHtcbiAgICByZXN1bHRbaV0gPSAwO1xuXG4gICAgdmFyIGwgPSBuZXcgQXJyYXkobGVuZ3RoKTtcbiAgICBjb2VmZmljaWVudHNbaV0gPSBsO1xuICAgIGZvciAoaiA9IDA7IGogPCBsZW5ndGg7IGorKykge1xuICAgICAgbFtqXSA9IFtdO1xuICAgIH1cbiAgfVxuXG4gIHZhciB6SW5kaWNlc0xlbmd0aCA9IGxlbmd0aCxcbiAgICB6SW5kaWNlcyA9IG5ldyBBcnJheSh6SW5kaWNlc0xlbmd0aCk7XG5cbiAgZm9yIChpID0gMDsgaSA8IHpJbmRpY2VzTGVuZ3RoOyBpKyspIHtcbiAgICB6SW5kaWNlc1tpXSA9IGk7XG4gIH1cblxuICB2YXIgaGlnaGVzdE5vblplcm9Db2VmID0gbGVuZ3RoIC0gMTtcbiAgZm9yIChzID0gMDsgcyA8IHlTdHJpZGU7IHMrKykge1xuICAgIGZvciAoaiA9IDA7IGogPCB6SW5kaWNlc0xlbmd0aDsgaisrKSB7XG4gICAgICBpbmRleCA9IHpJbmRpY2VzW2pdICogeVN0cmlkZSArIHM7XG4gICAgICBjb2VmZmljaWVudHNbc11bMF0ucHVzaCh5VGFibGVbaW5kZXhdKTtcbiAgICB9XG5cbiAgICBmb3IgKGkgPSAxOyBpIDwgekluZGljZXNMZW5ndGg7IGkrKykge1xuICAgICAgdmFyIG5vblplcm9Db2VmZmljaWVudHMgPSBmYWxzZTtcbiAgICAgIGZvciAoaiA9IDA7IGogPCB6SW5kaWNlc0xlbmd0aCAtIGk7IGorKykge1xuICAgICAgICB2YXIgemogPSB4VGFibGVbekluZGljZXNbal1dO1xuICAgICAgICB2YXIgem4gPSB4VGFibGVbekluZGljZXNbaiArIGldXTtcblxuICAgICAgICB2YXIgbnVtZXJhdG9yO1xuICAgICAgICBpZiAoem4gLSB6aiA8PSAwKSB7XG4gICAgICAgICAgaW5kZXggPSB6SW5kaWNlc1tqXSAqIHlTdHJpZGUgKyB5U3RyaWRlICogaSArIHM7XG4gICAgICAgICAgbnVtZXJhdG9yID0geVRhYmxlW2luZGV4XTtcbiAgICAgICAgICBjb2VmZmljaWVudHNbc11baV0ucHVzaChudW1lcmF0b3IgLyBmYWN0b3JpYWwoaSkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG51bWVyYXRvciA9IGNvZWZmaWNpZW50c1tzXVtpIC0gMV1baiArIDFdIC0gY29lZmZpY2llbnRzW3NdW2kgLSAxXVtqXTtcbiAgICAgICAgICBjb2VmZmljaWVudHNbc11baV0ucHVzaChudW1lcmF0b3IgLyAoem4gLSB6aikpO1xuICAgICAgICB9XG4gICAgICAgIG5vblplcm9Db2VmZmljaWVudHMgPSBub25aZXJvQ29lZmZpY2llbnRzIHx8IG51bWVyYXRvciAhPT0gMDtcbiAgICAgIH1cblxuICAgICAgaWYgKCFub25aZXJvQ29lZmZpY2llbnRzKSB7XG4gICAgICAgIGhpZ2hlc3ROb25aZXJvQ29lZiA9IGkgLSAxO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZvciAoZCA9IDAsIGxlbiA9IDA7IGQgPD0gbGVuOyBkKyspIHtcbiAgICBmb3IgKGkgPSBkOyBpIDw9IGhpZ2hlc3ROb25aZXJvQ29lZjsgaSsrKSB7XG4gICAgICB2YXIgdGVtcFRlcm0gPSBjYWxjdWxhdGVDb2VmZmljaWVudFRlcm0oeCwgekluZGljZXMsIHhUYWJsZSwgZCwgaSwgW10pO1xuICAgICAgZm9yIChzID0gMDsgcyA8IHlTdHJpZGU7IHMrKykge1xuICAgICAgICB2YXIgY29lZmYgPSBjb2VmZmljaWVudHNbc11baV1bMF07XG4gICAgICAgIHJlc3VsdFtzICsgZCAqIHlTdHJpZGVdICs9IGNvZWZmICogdGVtcFRlcm07XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbnZhciBhcnJheVNjcmF0Y2ggPSBbXTtcblxuLyoqXG4gKiBJbnRlcnBvbGF0ZXMgdmFsdWVzIHVzaW5nIEhlcm1pdGUgUG9seW5vbWlhbCBBcHByb3hpbWF0aW9uLlxuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSB4IFRoZSBpbmRlcGVuZGVudCB2YXJpYWJsZSBmb3Igd2hpY2ggdGhlIGRlcGVuZGVudCB2YXJpYWJsZXMgd2lsbCBiZSBpbnRlcnBvbGF0ZWQuXG4gKiBAcGFyYW0ge051bWJlcltdfSB4VGFibGUgVGhlIGFycmF5IG9mIGluZGVwZW5kZW50IHZhcmlhYmxlcyB0byB1c2UgdG8gaW50ZXJwb2xhdGUuICBUaGUgdmFsdWVzXG4gKiBpbiB0aGlzIGFycmF5IG11c3QgYmUgaW4gaW5jcmVhc2luZyBvcmRlciBhbmQgdGhlIHNhbWUgdmFsdWUgbXVzdCBub3Qgb2NjdXIgdHdpY2UgaW4gdGhlIGFycmF5LlxuICogQHBhcmFtIHtOdW1iZXJbXX0geVRhYmxlIFRoZSBhcnJheSBvZiBkZXBlbmRlbnQgdmFyaWFibGVzIHRvIHVzZSB0byBpbnRlcnBvbGF0ZS4gIEZvciBhIHNldCBvZiB0aHJlZVxuICogZGVwZW5kZW50IHZhbHVlcyAocCxxLHcpIGF0IHRpbWUgMSBhbmQgdGltZSAyIHRoaXMgc2hvdWxkIGJlIGFzIGZvbGxvd3M6IHtwMSwgcTEsIHcxLCBwMiwgcTIsIHcyfS5cbiAqIEBwYXJhbSB7TnVtYmVyfSB5U3RyaWRlIFRoZSBudW1iZXIgb2YgZGVwZW5kZW50IHZhcmlhYmxlIHZhbHVlcyBpbiB5VGFibGUgY29ycmVzcG9uZGluZyB0b1xuICogZWFjaCBpbmRlcGVuZGVudCB2YXJpYWJsZSB2YWx1ZSBpbiB4VGFibGUuXG4gKiBAcGFyYW0ge051bWJlcn0gaW5wdXRPcmRlciBUaGUgbnVtYmVyIG9mIGRlcml2YXRpdmVzIHN1cHBsaWVkIGZvciBpbnB1dC5cbiAqIEBwYXJhbSB7TnVtYmVyfSBvdXRwdXRPcmRlciBUaGUgbnVtYmVyIG9mIGRlcml2YXRpdmVzIGRlc2lyZWQgZm9yIG91dHB1dC5cbiAqIEBwYXJhbSB7TnVtYmVyW119IFtyZXN1bHRdIEFuIGV4aXN0aW5nIGFycmF5IGludG8gd2hpY2ggdG8gc3RvcmUgdGhlIHJlc3VsdC5cbiAqXG4gKiBAcmV0dXJucyB7TnVtYmVyW119IFRoZSBhcnJheSBvZiBpbnRlcnBvbGF0ZWQgdmFsdWVzLCBvciB0aGUgcmVzdWx0IHBhcmFtZXRlciBpZiBvbmUgd2FzIHByb3ZpZGVkLlxuICovXG5IZXJtaXRlUG9seW5vbWlhbEFwcHJveGltYXRpb24uaW50ZXJwb2xhdGUgPSBmdW5jdGlvbiAoXG4gIHgsXG4gIHhUYWJsZSxcbiAgeVRhYmxlLFxuICB5U3RyaWRlLFxuICBpbnB1dE9yZGVyLFxuICBvdXRwdXRPcmRlcixcbiAgcmVzdWx0XG4pIHtcbiAgdmFyIHJlc3VsdExlbmd0aCA9IHlTdHJpZGUgKiAob3V0cHV0T3JkZXIgKyAxKTtcbiAgaWYgKCFkZWZpbmVkKHJlc3VsdCkpIHtcbiAgICByZXN1bHQgPSBuZXcgQXJyYXkocmVzdWx0TGVuZ3RoKTtcbiAgfVxuICBmb3IgKHZhciByID0gMDsgciA8IHJlc3VsdExlbmd0aDsgcisrKSB7XG4gICAgcmVzdWx0W3JdID0gMDtcbiAgfVxuXG4gIHZhciBsZW5ndGggPSB4VGFibGUubGVuZ3RoO1xuICAvLyBUaGUgekluZGljZXMgYXJyYXkgaG9sZHMgY29waWVzIG9mIHRoZSBhZGRyZXNzZXMgb2YgdGhlIHhUYWJsZSB2YWx1ZXNcbiAgLy8gaW4gdGhlIHJhbmdlIHdlJ3JlIGxvb2tpbmcgYXQuIEV2ZW4gdGhvdWdoIHRoaXMganVzdCBob2xkcyBpbmZvcm1hdGlvbiBhbHJlYWR5XG4gIC8vIGF2YWlsYWJsZSBpbiB4VGFibGUgdGhpcyBpcyBhIG11Y2ggbW9yZSBjb252ZW5pZW50IGZvcm1hdC5cbiAgdmFyIHpJbmRpY2VzID0gbmV3IEFycmF5KGxlbmd0aCAqIChpbnB1dE9yZGVyICsgMSkpO1xuICB2YXIgaTtcbiAgZm9yIChpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgZm9yICh2YXIgaiA9IDA7IGogPCBpbnB1dE9yZGVyICsgMTsgaisrKSB7XG4gICAgICB6SW5kaWNlc1tpICogKGlucHV0T3JkZXIgKyAxKSArIGpdID0gaTtcbiAgICB9XG4gIH1cblxuICB2YXIgekluZGljZXNsZW5ndGggPSB6SW5kaWNlcy5sZW5ndGg7XG4gIHZhciBjb2VmZmljaWVudHMgPSBhcnJheVNjcmF0Y2g7XG4gIHZhciBoaWdoZXN0Tm9uWmVyb0NvZWYgPSBmaWxsQ29lZmZpY2llbnRMaXN0KFxuICAgIGNvZWZmaWNpZW50cyxcbiAgICB6SW5kaWNlcyxcbiAgICB4VGFibGUsXG4gICAgeVRhYmxlLFxuICAgIHlTdHJpZGUsXG4gICAgaW5wdXRPcmRlclxuICApO1xuICB2YXIgcmVzZXJ2ZWRJbmRpY2VzID0gW107XG5cbiAgdmFyIHRtcCA9ICh6SW5kaWNlc2xlbmd0aCAqICh6SW5kaWNlc2xlbmd0aCArIDEpKSAvIDI7XG4gIHZhciBsb29wU3RvcCA9IE1hdGgubWluKGhpZ2hlc3ROb25aZXJvQ29lZiwgb3V0cHV0T3JkZXIpO1xuICBmb3IgKHZhciBkID0gMDsgZCA8PSBsb29wU3RvcDsgZCsrKSB7XG4gICAgZm9yIChpID0gZDsgaSA8PSBoaWdoZXN0Tm9uWmVyb0NvZWY7IGkrKykge1xuICAgICAgcmVzZXJ2ZWRJbmRpY2VzLmxlbmd0aCA9IDA7XG4gICAgICB2YXIgdGVtcFRlcm0gPSBjYWxjdWxhdGVDb2VmZmljaWVudFRlcm0oXG4gICAgICAgIHgsXG4gICAgICAgIHpJbmRpY2VzLFxuICAgICAgICB4VGFibGUsXG4gICAgICAgIGQsXG4gICAgICAgIGksXG4gICAgICAgIHJlc2VydmVkSW5kaWNlc1xuICAgICAgKTtcbiAgICAgIHZhciBkaW1Ud28gPSBNYXRoLmZsb29yKChpICogKDEgLSBpKSkgLyAyKSArIHpJbmRpY2VzbGVuZ3RoICogaTtcblxuICAgICAgZm9yICh2YXIgcyA9IDA7IHMgPCB5U3RyaWRlOyBzKyspIHtcbiAgICAgICAgdmFyIGRpbU9uZSA9IE1hdGguZmxvb3IocyAqIHRtcCk7XG4gICAgICAgIHZhciBjb2VmID0gY29lZmZpY2llbnRzW2RpbU9uZSArIGRpbVR3b107XG4gICAgICAgIHJlc3VsdFtzICsgZCAqIHlTdHJpZGVdICs9IGNvZWYgKiB0ZW1wVGVybTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gcmVzdWx0O1xufTtcblxuZnVuY3Rpb24gZmlsbENvZWZmaWNpZW50TGlzdChcbiAgY29lZmZpY2llbnRzLFxuICB6SW5kaWNlcyxcbiAgeFRhYmxlLFxuICB5VGFibGUsXG4gIHlTdHJpZGUsXG4gIGlucHV0T3JkZXJcbikge1xuICB2YXIgajtcbiAgdmFyIGluZGV4O1xuICB2YXIgaGlnaGVzdE5vblplcm8gPSAtMTtcbiAgdmFyIHpJbmRpY2VzbGVuZ3RoID0gekluZGljZXMubGVuZ3RoO1xuICB2YXIgdG1wID0gKHpJbmRpY2VzbGVuZ3RoICogKHpJbmRpY2VzbGVuZ3RoICsgMSkpIC8gMjtcblxuICBmb3IgKHZhciBzID0gMDsgcyA8IHlTdHJpZGU7IHMrKykge1xuICAgIHZhciBkaW1PbmUgPSBNYXRoLmZsb29yKHMgKiB0bXApO1xuXG4gICAgZm9yIChqID0gMDsgaiA8IHpJbmRpY2VzbGVuZ3RoOyBqKyspIHtcbiAgICAgIGluZGV4ID0gekluZGljZXNbal0gKiB5U3RyaWRlICogKGlucHV0T3JkZXIgKyAxKSArIHM7XG4gICAgICBjb2VmZmljaWVudHNbZGltT25lICsgal0gPSB5VGFibGVbaW5kZXhdO1xuICAgIH1cblxuICAgIGZvciAodmFyIGkgPSAxOyBpIDwgekluZGljZXNsZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGNvZWZJbmRleCA9IDA7XG4gICAgICB2YXIgZGltVHdvID0gTWF0aC5mbG9vcigoaSAqICgxIC0gaSkpIC8gMikgKyB6SW5kaWNlc2xlbmd0aCAqIGk7XG4gICAgICB2YXIgbm9uWmVyb0NvZWZmaWNpZW50cyA9IGZhbHNlO1xuXG4gICAgICBmb3IgKGogPSAwOyBqIDwgekluZGljZXNsZW5ndGggLSBpOyBqKyspIHtcbiAgICAgICAgdmFyIHpqID0geFRhYmxlW3pJbmRpY2VzW2pdXTtcbiAgICAgICAgdmFyIHpuID0geFRhYmxlW3pJbmRpY2VzW2ogKyBpXV07XG5cbiAgICAgICAgdmFyIG51bWVyYXRvcjtcbiAgICAgICAgdmFyIGNvZWZmaWNpZW50O1xuICAgICAgICBpZiAoem4gLSB6aiA8PSAwKSB7XG4gICAgICAgICAgaW5kZXggPSB6SW5kaWNlc1tqXSAqIHlTdHJpZGUgKiAoaW5wdXRPcmRlciArIDEpICsgeVN0cmlkZSAqIGkgKyBzO1xuICAgICAgICAgIG51bWVyYXRvciA9IHlUYWJsZVtpbmRleF07XG4gICAgICAgICAgY29lZmZpY2llbnQgPSBudW1lcmF0b3IgLyBDZXNpdW1NYXRoLmZhY3RvcmlhbChpKTtcbiAgICAgICAgICBjb2VmZmljaWVudHNbZGltT25lICsgZGltVHdvICsgY29lZkluZGV4XSA9IGNvZWZmaWNpZW50O1xuICAgICAgICAgIGNvZWZJbmRleCsrO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciBkaW1Ud29NaW51c09uZSA9XG4gICAgICAgICAgICBNYXRoLmZsb29yKCgoaSAtIDEpICogKDIgLSBpKSkgLyAyKSArIHpJbmRpY2VzbGVuZ3RoICogKGkgLSAxKTtcbiAgICAgICAgICBudW1lcmF0b3IgPVxuICAgICAgICAgICAgY29lZmZpY2llbnRzW2RpbU9uZSArIGRpbVR3b01pbnVzT25lICsgaiArIDFdIC1cbiAgICAgICAgICAgIGNvZWZmaWNpZW50c1tkaW1PbmUgKyBkaW1Ud29NaW51c09uZSArIGpdO1xuICAgICAgICAgIGNvZWZmaWNpZW50ID0gbnVtZXJhdG9yIC8gKHpuIC0gemopO1xuICAgICAgICAgIGNvZWZmaWNpZW50c1tkaW1PbmUgKyBkaW1Ud28gKyBjb2VmSW5kZXhdID0gY29lZmZpY2llbnQ7XG4gICAgICAgICAgY29lZkluZGV4Kys7XG4gICAgICAgIH1cbiAgICAgICAgbm9uWmVyb0NvZWZmaWNpZW50cyA9IG5vblplcm9Db2VmZmljaWVudHMgfHwgbnVtZXJhdG9yICE9PSAwLjA7XG4gICAgICB9XG5cbiAgICAgIGlmIChub25aZXJvQ29lZmZpY2llbnRzKSB7XG4gICAgICAgIGhpZ2hlc3ROb25aZXJvID0gTWF0aC5tYXgoaGlnaGVzdE5vblplcm8sIGkpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBoaWdoZXN0Tm9uWmVybztcbn1cbmV4cG9ydCBkZWZhdWx0IEhlcm1pdGVQb2x5bm9taWFsQXBwcm94aW1hdGlvbjtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///72241\n')},41399:function(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__){eval('/* harmony import */ var _Cartesian3_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(60216);\n/* harmony import */ var _Cartesian4_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(63367);\n/* harmony import */ var _defaultValue_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(62200);\n/* harmony import */ var _defined_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(82982);\n/* harmony import */ var _DeveloperError_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(12572);\n/* harmony import */ var _LinearSpline_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(96304);\n/* harmony import */ var _Matrix4_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(72248);\n/* harmony import */ var _Spline_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(84543);\n/* harmony import */ var _TridiagonalSystemSolver_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(72579);\n\n\n\n\n\n\n\n\n\n\nvar scratchLower = [];\nvar scratchDiagonal = [];\nvar scratchUpper = [];\nvar scratchRight = [];\n\nfunction generateClamped(points, firstTangent, lastTangent) {\n  var l = scratchLower;\n  var u = scratchUpper;\n  var d = scratchDiagonal;\n  var r = scratchRight;\n\n  l.length = u.length = points.length - 1;\n  d.length = r.length = points.length;\n\n  var i;\n  l[0] = d[0] = 1.0;\n  u[0] = 0.0;\n\n  var right = r[0];\n  if (!(0,_defined_js__WEBPACK_IMPORTED_MODULE_8__/* ["default"] */ .Z)(right)) {\n    right = r[0] = new _Cartesian3_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .Z();\n  }\n  _Cartesian3_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].clone */ .Z.clone(firstTangent, right);\n\n  for (i = 1; i < l.length - 1; ++i) {\n    l[i] = u[i] = 1.0;\n    d[i] = 4.0;\n\n    right = r[i];\n    if (!(0,_defined_js__WEBPACK_IMPORTED_MODULE_8__/* ["default"] */ .Z)(right)) {\n      right = r[i] = new _Cartesian3_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .Z();\n    }\n    _Cartesian3_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].subtract */ .Z.subtract(points[i + 1], points[i - 1], right);\n    _Cartesian3_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].multiplyByScalar */ .Z.multiplyByScalar(right, 3.0, right);\n  }\n\n  l[i] = 0.0;\n  u[i] = 1.0;\n  d[i] = 4.0;\n\n  right = r[i];\n  if (!(0,_defined_js__WEBPACK_IMPORTED_MODULE_8__/* ["default"] */ .Z)(right)) {\n    right = r[i] = new _Cartesian3_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .Z();\n  }\n  _Cartesian3_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].subtract */ .Z.subtract(points[i + 1], points[i - 1], right);\n  _Cartesian3_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].multiplyByScalar */ .Z.multiplyByScalar(right, 3.0, right);\n\n  d[i + 1] = 1.0;\n  right = r[i + 1];\n  if (!(0,_defined_js__WEBPACK_IMPORTED_MODULE_8__/* ["default"] */ .Z)(right)) {\n    right = r[i + 1] = new _Cartesian3_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .Z();\n  }\n  _Cartesian3_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].clone */ .Z.clone(lastTangent, right);\n\n  return _TridiagonalSystemSolver_js__WEBPACK_IMPORTED_MODULE_7__/* ["default"].solve */ .Z.solve(l, d, u, r);\n}\n\nfunction generateNatural(points) {\n  var l = scratchLower;\n  var u = scratchUpper;\n  var d = scratchDiagonal;\n  var r = scratchRight;\n\n  l.length = u.length = points.length - 1;\n  d.length = r.length = points.length;\n\n  var i;\n  l[0] = u[0] = 1.0;\n  d[0] = 2.0;\n\n  var right = r[0];\n  if (!(0,_defined_js__WEBPACK_IMPORTED_MODULE_8__/* ["default"] */ .Z)(right)) {\n    right = r[0] = new _Cartesian3_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .Z();\n  }\n  _Cartesian3_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].subtract */ .Z.subtract(points[1], points[0], right);\n  _Cartesian3_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].multiplyByScalar */ .Z.multiplyByScalar(right, 3.0, right);\n\n  for (i = 1; i < l.length; ++i) {\n    l[i] = u[i] = 1.0;\n    d[i] = 4.0;\n\n    right = r[i];\n    if (!(0,_defined_js__WEBPACK_IMPORTED_MODULE_8__/* ["default"] */ .Z)(right)) {\n      right = r[i] = new _Cartesian3_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .Z();\n    }\n    _Cartesian3_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].subtract */ .Z.subtract(points[i + 1], points[i - 1], right);\n    _Cartesian3_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].multiplyByScalar */ .Z.multiplyByScalar(right, 3.0, right);\n  }\n\n  d[i] = 2.0;\n\n  right = r[i];\n  if (!(0,_defined_js__WEBPACK_IMPORTED_MODULE_8__/* ["default"] */ .Z)(right)) {\n    right = r[i] = new _Cartesian3_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .Z();\n  }\n  _Cartesian3_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].subtract */ .Z.subtract(points[i], points[i - 1], right);\n  _Cartesian3_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].multiplyByScalar */ .Z.multiplyByScalar(right, 3.0, right);\n\n  return _TridiagonalSystemSolver_js__WEBPACK_IMPORTED_MODULE_7__/* ["default"].solve */ .Z.solve(l, d, u, r);\n}\n\n/**\n * A Hermite spline is a cubic interpolating spline. Points, incoming tangents, outgoing tangents, and times\n * must be defined for each control point. The outgoing tangents are defined for points [0, n - 2] and the incoming\n * tangents are defined for points [1, n - 1]. For example, when interpolating a segment of the curve between <code>points[i]</code> and\n * <code>points[i + 1]</code>, the tangents at the points will be <code>outTangents[i]</code> and <code>inTangents[i]</code>,\n * respectively.\n *\n * @alias HermiteSpline\n * @constructor\n *\n * @param {Object} options Object with the following properties:\n * @param {Number[]} options.times An array of strictly increasing, unit-less, floating-point times at each point.\n *                The values are in no way connected to the clock time. They are the parameterization for the curve.\n * @param {Cartesian3[]} options.points The array of {@link Cartesian3} control points.\n * @param {Cartesian3[]} options.inTangents The array of {@link Cartesian3} incoming tangents at each control point.\n * @param {Cartesian3[]} options.outTangents The array of {@link Cartesian3} outgoing tangents at each control point.\n *\n * @exception {DeveloperError} points.length must be greater than or equal to 2.\n * @exception {DeveloperError} times.length must be equal to points.length.\n * @exception {DeveloperError} inTangents and outTangents must have a length equal to points.length - 1.\n *\n *\n * @example\n * // Create a G<sup>1</sup> continuous Hermite spline\n * var times = [ 0.0, 1.5, 3.0, 4.5, 6.0 ];\n * var spline = new Cesium.HermiteSpline({\n *     times : times,\n *     points : [\n *         new Cesium.Cartesian3(1235398.0, -4810983.0, 4146266.0),\n *         new Cesium.Cartesian3(1372574.0, -5345182.0, 4606657.0),\n *         new Cesium.Cartesian3(-757983.0, -5542796.0, 4514323.0),\n *         new Cesium.Cartesian3(-2821260.0, -5248423.0, 4021290.0),\n *         new Cesium.Cartesian3(-2539788.0, -4724797.0, 3620093.0)\n *     ],\n *     outTangents : [\n *         new Cesium.Cartesian3(1125196, -161816, 270551),\n *         new Cesium.Cartesian3(-996690.5, -365906.5, 184028.5),\n *         new Cesium.Cartesian3(-2096917, 48379.5, -292683.5),\n *         new Cesium.Cartesian3(-890902.5, 408999.5, -447115)\n *     ],\n *     inTangents : [\n *         new Cesium.Cartesian3(-1993381, -731813, 368057),\n *         new Cesium.Cartesian3(-4193834, 96759, -585367),\n *         new Cesium.Cartesian3(-1781805, 817999, -894230),\n *         new Cesium.Cartesian3(1165345, 112641, 47281)\n *     ]\n * });\n *\n * var p0 = spline.evaluate(times[0]);\n *\n * @see CatmullRomSpline\n * @see LinearSpline\n * @see QuaternionSpline\n * @see WeightSpline\n */\nfunction HermiteSpline(options) {\n  options = (0,_defaultValue_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"] */ .Z)(options, _defaultValue_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"].EMPTY_OBJECT */ .Z.EMPTY_OBJECT);\n\n  var points = options.points;\n  var times = options.times;\n  var inTangents = options.inTangents;\n  var outTangents = options.outTangents;\n\n  //>>includeStart(\'debug\', pragmas.debug);\n  if (\n    !(0,_defined_js__WEBPACK_IMPORTED_MODULE_8__/* ["default"] */ .Z)(points) ||\n    !(0,_defined_js__WEBPACK_IMPORTED_MODULE_8__/* ["default"] */ .Z)(times) ||\n    !(0,_defined_js__WEBPACK_IMPORTED_MODULE_8__/* ["default"] */ .Z)(inTangents) ||\n    !(0,_defined_js__WEBPACK_IMPORTED_MODULE_8__/* ["default"] */ .Z)(outTangents)\n  ) {\n    throw new _DeveloperError_js__WEBPACK_IMPORTED_MODULE_3__/* ["default"] */ .Z(\n      "times, points, inTangents, and outTangents are required."\n    );\n  }\n  if (points.length < 2) {\n    throw new _DeveloperError_js__WEBPACK_IMPORTED_MODULE_3__/* ["default"] */ .Z(\n      "points.length must be greater than or equal to 2."\n    );\n  }\n  if (times.length !== points.length) {\n    throw new _DeveloperError_js__WEBPACK_IMPORTED_MODULE_3__/* ["default"] */ .Z("times.length must be equal to points.length.");\n  }\n  if (\n    inTangents.length !== outTangents.length ||\n    inTangents.length !== points.length - 1\n  ) {\n    throw new _DeveloperError_js__WEBPACK_IMPORTED_MODULE_3__/* ["default"] */ .Z(\n      "inTangents and outTangents must have a length equal to points.length - 1."\n    );\n  }\n  //>>includeEnd(\'debug\');\n\n  this._times = times;\n  this._points = points;\n  this._inTangents = inTangents;\n  this._outTangents = outTangents;\n\n  this._lastTimeIndex = 0;\n}\n\nObject.defineProperties(HermiteSpline.prototype, {\n  /**\n   * An array of times for the control points.\n   *\n   * @memberof HermiteSpline.prototype\n   *\n   * @type {Number[]}\n   * @readonly\n   */\n  times: {\n    get: function () {\n      return this._times;\n    },\n  },\n\n  /**\n   * An array of {@link Cartesian3} control points.\n   *\n   * @memberof HermiteSpline.prototype\n   *\n   * @type {Cartesian3[]}\n   * @readonly\n   */\n  points: {\n    get: function () {\n      return this._points;\n    },\n  },\n\n  /**\n   * An array of {@link Cartesian3} incoming tangents at each control point.\n   *\n   * @memberof HermiteSpline.prototype\n   *\n   * @type {Cartesian3[]}\n   * @readonly\n   */\n  inTangents: {\n    get: function () {\n      return this._inTangents;\n    },\n  },\n\n  /**\n   * An array of {@link Cartesian3} outgoing tangents at each control point.\n   *\n   * @memberof HermiteSpline.prototype\n   *\n   * @type {Cartesian3[]}\n   * @readonly\n   */\n  outTangents: {\n    get: function () {\n      return this._outTangents;\n    },\n  },\n});\n\n/**\n * Creates a spline where the tangents at each control point are the same.\n * The curves are guaranteed to be at least in the class C<sup>1</sup>.\n *\n * @param {Object} options Object with the following properties:\n * @param {Number[]} options.times The array of control point times.\n * @param {Cartesian3[]} options.points The array of control points.\n * @param {Cartesian3[]} options.tangents The array of tangents at the control points.\n * @returns {HermiteSpline} A hermite spline.\n *\n * @exception {DeveloperError} points, times and tangents are required.\n * @exception {DeveloperError} points.length must be greater than or equal to 2.\n * @exception {DeveloperError} times, points and tangents must have the same length.\n *\n * @example\n * var points = [\n *     new Cesium.Cartesian3(1235398.0, -4810983.0, 4146266.0),\n *     new Cesium.Cartesian3(1372574.0, -5345182.0, 4606657.0),\n *     new Cesium.Cartesian3(-757983.0, -5542796.0, 4514323.0),\n *     new Cesium.Cartesian3(-2821260.0, -5248423.0, 4021290.0),\n *     new Cesium.Cartesian3(-2539788.0, -4724797.0, 3620093.0)\n * ];\n *\n * // Add tangents\n * var tangents = new Array(points.length);\n * tangents[0] = new Cesium.Cartesian3(1125196, -161816, 270551);\n * var temp = new Cesium.Cartesian3();\n * for (var i = 1; i < tangents.length - 1; ++i) {\n *     tangents[i] = Cesium.Cartesian3.multiplyByScalar(Cesium.Cartesian3.subtract(points[i + 1], points[i - 1], temp), 0.5, new Cesium.Cartesian3());\n * }\n * tangents[tangents.length - 1] = new Cesium.Cartesian3(1165345, 112641, 47281);\n *\n * var spline = Cesium.HermiteSpline.createC1({\n *     times : times,\n *     points : points,\n *     tangents : tangents\n * });\n */\nHermiteSpline.createC1 = function (options) {\n  options = (0,_defaultValue_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"] */ .Z)(options, _defaultValue_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"].EMPTY_OBJECT */ .Z.EMPTY_OBJECT);\n\n  var times = options.times;\n  var points = options.points;\n  var tangents = options.tangents;\n\n  //>>includeStart(\'debug\', pragmas.debug);\n  if (!(0,_defined_js__WEBPACK_IMPORTED_MODULE_8__/* ["default"] */ .Z)(points) || !(0,_defined_js__WEBPACK_IMPORTED_MODULE_8__/* ["default"] */ .Z)(times) || !(0,_defined_js__WEBPACK_IMPORTED_MODULE_8__/* ["default"] */ .Z)(tangents)) {\n    throw new _DeveloperError_js__WEBPACK_IMPORTED_MODULE_3__/* ["default"] */ .Z("points, times and tangents are required.");\n  }\n  if (points.length < 2) {\n    throw new _DeveloperError_js__WEBPACK_IMPORTED_MODULE_3__/* ["default"] */ .Z(\n      "points.length must be greater than or equal to 2."\n    );\n  }\n  if (times.length !== points.length || times.length !== tangents.length) {\n    throw new _DeveloperError_js__WEBPACK_IMPORTED_MODULE_3__/* ["default"] */ .Z(\n      "times, points and tangents must have the same length."\n    );\n  }\n  //>>includeEnd(\'debug\');\n\n  var outTangents = tangents.slice(0, tangents.length - 1);\n  var inTangents = tangents.slice(1, tangents.length);\n\n  return new HermiteSpline({\n    times: times,\n    points: points,\n    inTangents: inTangents,\n    outTangents: outTangents,\n  });\n};\n\n/**\n * Creates a natural cubic spline. The tangents at the control points are generated\n * to create a curve in the class C<sup>2</sup>.\n *\n * @param {Object} options Object with the following properties:\n * @param {Number[]} options.times The array of control point times.\n * @param {Cartesian3[]} options.points The array of control points.\n * @returns {HermiteSpline|LinearSpline} A hermite spline or a linear spline if less than 3 control points were given.\n *\n * @exception {DeveloperError} points and times are required.\n * @exception {DeveloperError} points.length must be greater than or equal to 2.\n * @exception {DeveloperError} times.length must be equal to points.length.\n *\n * @example\n * // Create a natural cubic spline above the earth from Philadelphia to Los Angeles.\n * var spline = Cesium.HermiteSpline.createNaturalCubic({\n *     times : [ 0.0, 1.5, 3.0, 4.5, 6.0 ],\n *     points : [\n *         new Cesium.Cartesian3(1235398.0, -4810983.0, 4146266.0),\n *         new Cesium.Cartesian3(1372574.0, -5345182.0, 4606657.0),\n *         new Cesium.Cartesian3(-757983.0, -5542796.0, 4514323.0),\n *         new Cesium.Cartesian3(-2821260.0, -5248423.0, 4021290.0),\n *         new Cesium.Cartesian3(-2539788.0, -4724797.0, 3620093.0)\n *     ]\n * });\n */\nHermiteSpline.createNaturalCubic = function (options) {\n  options = (0,_defaultValue_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"] */ .Z)(options, _defaultValue_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"].EMPTY_OBJECT */ .Z.EMPTY_OBJECT);\n\n  var times = options.times;\n  var points = options.points;\n\n  //>>includeStart(\'debug\', pragmas.debug);\n  if (!(0,_defined_js__WEBPACK_IMPORTED_MODULE_8__/* ["default"] */ .Z)(points) || !(0,_defined_js__WEBPACK_IMPORTED_MODULE_8__/* ["default"] */ .Z)(times)) {\n    throw new _DeveloperError_js__WEBPACK_IMPORTED_MODULE_3__/* ["default"] */ .Z("points and times are required.");\n  }\n  if (points.length < 2) {\n    throw new _DeveloperError_js__WEBPACK_IMPORTED_MODULE_3__/* ["default"] */ .Z(\n      "points.length must be greater than or equal to 2."\n    );\n  }\n  if (times.length !== points.length) {\n    throw new _DeveloperError_js__WEBPACK_IMPORTED_MODULE_3__/* ["default"] */ .Z("times.length must be equal to points.length.");\n  }\n  //>>includeEnd(\'debug\');\n\n  if (points.length < 3) {\n    return new _LinearSpline_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .Z({\n      points: points,\n      times: times,\n    });\n  }\n\n  var tangents = generateNatural(points);\n  var outTangents = tangents.slice(0, tangents.length - 1);\n  var inTangents = tangents.slice(1, tangents.length);\n\n  return new HermiteSpline({\n    times: times,\n    points: points,\n    inTangents: inTangents,\n    outTangents: outTangents,\n  });\n};\n\n/**\n * Creates a clamped cubic spline. The tangents at the interior control points are generated\n * to create a curve in the class C<sup>2</sup>.\n *\n * @param {Object} options Object with the following properties:\n * @param {Number[]} options.times The array of control point times.\n * @param {Cartesian3[]} options.points The array of control points.\n * @param {Cartesian3} options.firstTangent The outgoing tangent of the first control point.\n * @param {Cartesian3} options.lastTangent The incoming tangent of the last control point.\n * @returns {HermiteSpline|LinearSpline} A hermite spline or a linear spline if less than 3 control points were given.\n *\n * @exception {DeveloperError} points, times, firstTangent and lastTangent are required.\n * @exception {DeveloperError} points.length must be greater than or equal to 2.\n * @exception {DeveloperError} times.length must be equal to points.length.\n *\n * @example\n * // Create a clamped cubic spline above the earth from Philadelphia to Los Angeles.\n * var spline = Cesium.HermiteSpline.createClampedCubic({\n *     times : [ 0.0, 1.5, 3.0, 4.5, 6.0 ],\n *     points : [\n *         new Cesium.Cartesian3(1235398.0, -4810983.0, 4146266.0),\n *         new Cesium.Cartesian3(1372574.0, -5345182.0, 4606657.0),\n *         new Cesium.Cartesian3(-757983.0, -5542796.0, 4514323.0),\n *         new Cesium.Cartesian3(-2821260.0, -5248423.0, 4021290.0),\n *         new Cesium.Cartesian3(-2539788.0, -4724797.0, 3620093.0)\n *     ],\n *     firstTangent : new Cesium.Cartesian3(1125196, -161816, 270551),\n *     lastTangent : new Cesium.Cartesian3(1165345, 112641, 47281)\n * });\n */\nHermiteSpline.createClampedCubic = function (options) {\n  options = (0,_defaultValue_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"] */ .Z)(options, _defaultValue_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"].EMPTY_OBJECT */ .Z.EMPTY_OBJECT);\n\n  var times = options.times;\n  var points = options.points;\n  var firstTangent = options.firstTangent;\n  var lastTangent = options.lastTangent;\n\n  //>>includeStart(\'debug\', pragmas.debug);\n  if (\n    !(0,_defined_js__WEBPACK_IMPORTED_MODULE_8__/* ["default"] */ .Z)(points) ||\n    !(0,_defined_js__WEBPACK_IMPORTED_MODULE_8__/* ["default"] */ .Z)(times) ||\n    !(0,_defined_js__WEBPACK_IMPORTED_MODULE_8__/* ["default"] */ .Z)(firstTangent) ||\n    !(0,_defined_js__WEBPACK_IMPORTED_MODULE_8__/* ["default"] */ .Z)(lastTangent)\n  ) {\n    throw new _DeveloperError_js__WEBPACK_IMPORTED_MODULE_3__/* ["default"] */ .Z(\n      "points, times, firstTangent and lastTangent are required."\n    );\n  }\n  if (points.length < 2) {\n    throw new _DeveloperError_js__WEBPACK_IMPORTED_MODULE_3__/* ["default"] */ .Z(\n      "points.length must be greater than or equal to 2."\n    );\n  }\n  if (times.length !== points.length) {\n    throw new _DeveloperError_js__WEBPACK_IMPORTED_MODULE_3__/* ["default"] */ .Z("times.length must be equal to points.length.");\n  }\n  //>>includeEnd(\'debug\');\n\n  if (points.length < 3) {\n    return new _LinearSpline_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .Z({\n      points: points,\n      times: times,\n    });\n  }\n\n  var tangents = generateClamped(points, firstTangent, lastTangent);\n  var outTangents = tangents.slice(0, tangents.length - 1);\n  var inTangents = tangents.slice(1, tangents.length);\n\n  return new HermiteSpline({\n    times: times,\n    points: points,\n    inTangents: inTangents,\n    outTangents: outTangents,\n  });\n};\n\nHermiteSpline.hermiteCoefficientMatrix = new _Matrix4_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"] */ .Z(\n  2.0,\n  -3.0,\n  0.0,\n  1.0,\n  -2.0,\n  3.0,\n  0.0,\n  0.0,\n  1.0,\n  -2.0,\n  1.0,\n  0.0,\n  1.0,\n  -1.0,\n  0.0,\n  0.0\n);\n\n/**\n * Finds an index <code>i</code> in <code>times</code> such that the parameter\n * <code>time</code> is in the interval <code>[times[i], times[i + 1]]</code>.\n * @function\n *\n * @param {Number} time The time.\n * @returns {Number} The index for the element at the start of the interval.\n *\n * @exception {DeveloperError} time must be in the range <code>[t<sub>0</sub>, t<sub>n</sub>]</code>, where <code>t<sub>0</sub></code>\n *                             is the first element in the array <code>times</code> and <code>t<sub>n</sub></code> is the last element\n *                             in the array <code>times</code>.\n */\nHermiteSpline.prototype.findTimeInterval = _Spline_js__WEBPACK_IMPORTED_MODULE_6__/* ["default"].prototype.findTimeInterval */ .Z.prototype.findTimeInterval;\n\nvar scratchTimeVec = new _Cartesian4_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .Z();\nvar scratchTemp = new _Cartesian3_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .Z();\n\n/**\n * Wraps the given time to the period covered by the spline.\n * @function\n *\n * @param {Number} time The time.\n * @return {Number} The time, wrapped around to the updated animation.\n */\nHermiteSpline.prototype.wrapTime = _Spline_js__WEBPACK_IMPORTED_MODULE_6__/* ["default"].prototype.wrapTime */ .Z.prototype.wrapTime;\n\n/**\n * Clamps the given time to the period covered by the spline.\n * @function\n *\n * @param {Number} time The time.\n * @return {Number} The time, clamped to the animation period.\n */\nHermiteSpline.prototype.clampTime = _Spline_js__WEBPACK_IMPORTED_MODULE_6__/* ["default"].prototype.clampTime */ .Z.prototype.clampTime;\n\n/**\n * Evaluates the curve at a given time.\n *\n * @param {Number} time The time at which to evaluate the curve.\n * @param {Cartesian3} [result] The object onto which to store the result.\n * @returns {Cartesian3} The modified result parameter or a new instance of the point on the curve at the given time.\n *\n * @exception {DeveloperError} time must be in the range <code>[t<sub>0</sub>, t<sub>n</sub>]</code>, where <code>t<sub>0</sub></code>\n *                             is the first element in the array <code>times</code> and <code>t<sub>n</sub></code> is the last element\n *                             in the array <code>times</code>.\n */\nHermiteSpline.prototype.evaluate = function (time, result) {\n  if (!(0,_defined_js__WEBPACK_IMPORTED_MODULE_8__/* ["default"] */ .Z)(result)) {\n    result = new _Cartesian3_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .Z();\n  }\n  var points = this.points;\n  var times = this.times;\n  var inTangents = this.inTangents;\n  var outTangents = this.outTangents;\n\n  var i = (this._lastTimeIndex = this.findTimeInterval(\n    time,\n    this._lastTimeIndex\n  ));\n  var u = (time - times[i]) / (times[i + 1] - times[i]);\n\n  var timeVec = scratchTimeVec;\n  timeVec.z = u;\n  timeVec.y = u * u;\n  timeVec.x = timeVec.y * u;\n  timeVec.w = 1.0;\n\n  var coefs = _Matrix4_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"].multiplyByVector */ .Z.multiplyByVector(\n    HermiteSpline.hermiteCoefficientMatrix,\n    timeVec,\n    timeVec\n  );\n\n  result = _Cartesian3_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].multiplyByScalar */ .Z.multiplyByScalar(points[i], coefs.x, result);\n  _Cartesian3_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].multiplyByScalar */ .Z.multiplyByScalar(points[i + 1], coefs.y, scratchTemp);\n  _Cartesian3_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].add */ .Z.add(result, scratchTemp, result);\n  _Cartesian3_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].multiplyByScalar */ .Z.multiplyByScalar(outTangents[i], coefs.z, scratchTemp);\n  _Cartesian3_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].add */ .Z.add(result, scratchTemp, result);\n  _Cartesian3_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].multiplyByScalar */ .Z.multiplyByScalar(inTangents[i], coefs.w, scratchTemp);\n  return _Cartesian3_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].add */ .Z.add(result, scratchTemp, result);\n};\n/* harmony default export */ __webpack_exports__["Z"] = (HermiteSpline);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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LEVBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly92dWUzLXdlYnBhY2s1Ly4vbm9kZV9tb2R1bGVzL2Nlc2l1bS9Tb3VyY2UvQ29yZS9IZXJtaXRlU3BsaW5lLmpzP2UwMmIiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IENhcnRlc2lhbjMgZnJvbSBcIi4vQ2FydGVzaWFuMy5qc1wiO1xuaW1wb3J0IENhcnRlc2lhbjQgZnJvbSBcIi4vQ2FydGVzaWFuNC5qc1wiO1xuaW1wb3J0IGRlZmF1bHRWYWx1ZSBmcm9tIFwiLi9kZWZhdWx0VmFsdWUuanNcIjtcbmltcG9ydCBkZWZpbmVkIGZyb20gXCIuL2RlZmluZWQuanNcIjtcbmltcG9ydCBEZXZlbG9wZXJFcnJvciBmcm9tIFwiLi9EZXZlbG9wZXJFcnJvci5qc1wiO1xuaW1wb3J0IExpbmVhclNwbGluZSBmcm9tIFwiLi9MaW5lYXJTcGxpbmUuanNcIjtcbmltcG9ydCBNYXRyaXg0IGZyb20gXCIuL01hdHJpeDQuanNcIjtcbmltcG9ydCBTcGxpbmUgZnJvbSBcIi4vU3BsaW5lLmpzXCI7XG5pbXBvcnQgVHJpZGlhZ29uYWxTeXN0ZW1Tb2x2ZXIgZnJvbSBcIi4vVHJpZGlhZ29uYWxTeXN0ZW1Tb2x2ZXIuanNcIjtcblxudmFyIHNjcmF0Y2hMb3dlciA9IFtdO1xudmFyIHNjcmF0Y2hEaWFnb25hbCA9IFtdO1xudmFyIHNjcmF0Y2hVcHBlciA9IFtdO1xudmFyIHNjcmF0Y2hSaWdodCA9IFtdO1xuXG5mdW5jdGlvbiBnZW5lcmF0ZUNsYW1wZWQocG9pbnRzLCBmaXJzdFRhbmdlbnQsIGxhc3RUYW5nZW50KSB7XG4gIHZhciBsID0gc2NyYXRjaExvd2VyO1xuICB2YXIgdSA9IHNjcmF0Y2hVcHBlcjtcbiAgdmFyIGQgPSBzY3JhdGNoRGlhZ29uYWw7XG4gIHZhciByID0gc2NyYXRjaFJpZ2h0O1xuXG4gIGwubGVuZ3RoID0gdS5sZW5ndGggPSBwb2ludHMubGVuZ3RoIC0gMTtcbiAgZC5sZW5ndGggPSByLmxlbmd0aCA9IHBvaW50cy5sZW5ndGg7XG5cbiAgdmFyIGk7XG4gIGxbMF0gPSBkWzBdID0gMS4wO1xuICB1WzBdID0gMC4wO1xuXG4gIHZhciByaWdodCA9IHJbMF07XG4gIGlmICghZGVmaW5lZChyaWdodCkpIHtcbiAgICByaWdodCA9IHJbMF0gPSBuZXcgQ2FydGVzaWFuMygpO1xuICB9XG4gIENhcnRlc2lhbjMuY2xvbmUoZmlyc3RUYW5nZW50LCByaWdodCk7XG5cbiAgZm9yIChpID0gMTsgaSA8IGwubGVuZ3RoIC0gMTsgKytpKSB7XG4gICAgbFtpXSA9IHVbaV0gPSAxLjA7XG4gICAgZFtpXSA9IDQuMDtcblxuICAgIHJpZ2h0ID0gcltpXTtcbiAgICBpZiAoIWRlZmluZWQocmlnaHQpKSB7XG4gICAgICByaWdodCA9IHJbaV0gPSBuZXcgQ2FydGVzaWFuMygpO1xuICAgIH1cbiAgICBDYXJ0ZXNpYW4zLnN1YnRyYWN0KHBvaW50c1tpICsgMV0sIHBvaW50c1tpIC0gMV0sIHJpZ2h0KTtcbiAgICBDYXJ0ZXNpYW4zLm11bHRpcGx5QnlTY2FsYXIocmlnaHQsIDMuMCwgcmlnaHQpO1xuICB9XG5cbiAgbFtpXSA9IDAuMDtcbiAgdVtpXSA9IDEuMDtcbiAgZFtpXSA9IDQuMDtcblxuICByaWdodCA9IHJbaV07XG4gIGlmICghZGVmaW5lZChyaWdodCkpIHtcbiAgICByaWdodCA9IHJbaV0gPSBuZXcgQ2FydGVzaWFuMygpO1xuICB9XG4gIENhcnRlc2lhbjMuc3VidHJhY3QocG9pbnRzW2kgKyAxXSwgcG9pbnRzW2kgLSAxXSwgcmlnaHQpO1xuICBDYXJ0ZXNpYW4zLm11bHRpcGx5QnlTY2FsYXIocmlnaHQsIDMuMCwgcmlnaHQpO1xuXG4gIGRbaSArIDFdID0gMS4wO1xuICByaWdodCA9IHJbaSArIDFdO1xuICBpZiAoIWRlZmluZWQocmlnaHQpKSB7XG4gICAgcmlnaHQgPSByW2kgKyAxXSA9IG5ldyBDYXJ0ZXNpYW4zKCk7XG4gIH1cbiAgQ2FydGVzaWFuMy5jbG9uZShsYXN0VGFuZ2VudCwgcmlnaHQpO1xuXG4gIHJldHVybiBUcmlkaWFnb25hbFN5c3RlbVNvbHZlci5zb2x2ZShsLCBkLCB1LCByKTtcbn1cblxuZnVuY3Rpb24gZ2VuZXJhdGVOYXR1cmFsKHBvaW50cykge1xuICB2YXIgbCA9IHNjcmF0Y2hMb3dlcjtcbiAgdmFyIHUgPSBzY3JhdGNoVXBwZXI7XG4gIHZhciBkID0gc2NyYXRjaERpYWdvbmFsO1xuICB2YXIgciA9IHNjcmF0Y2hSaWdodDtcblxuICBsLmxlbmd0aCA9IHUubGVuZ3RoID0gcG9pbnRzLmxlbmd0aCAtIDE7XG4gIGQubGVuZ3RoID0gci5sZW5ndGggPSBwb2ludHMubGVuZ3RoO1xuXG4gIHZhciBpO1xuICBsWzBdID0gdVswXSA9IDEuMDtcbiAgZFswXSA9IDIuMDtcblxuICB2YXIgcmlnaHQgPSByWzBdO1xuICBpZiAoIWRlZmluZWQocmlnaHQpKSB7XG4gICAgcmlnaHQgPSByWzBdID0gbmV3IENhcnRlc2lhbjMoKTtcbiAgfVxuICBDYXJ0ZXNpYW4zLnN1YnRyYWN0KHBvaW50c1sxXSwgcG9pbnRzWzBdLCByaWdodCk7XG4gIENhcnRlc2lhbjMubXVsdGlwbHlCeVNjYWxhcihyaWdodCwgMy4wLCByaWdodCk7XG5cbiAgZm9yIChpID0gMTsgaSA8IGwubGVuZ3RoOyArK2kpIHtcbiAgICBsW2ldID0gdVtpXSA9IDEuMDtcbiAgICBkW2ldID0gNC4wO1xuXG4gICAgcmlnaHQgPSByW2ldO1xuICAgIGlmICghZGVmaW5lZChyaWdodCkpIHtcbiAgICAgIHJpZ2h0ID0gcltpXSA9IG5ldyBDYXJ0ZXNpYW4zKCk7XG4gICAgfVxuICAgIENhcnRlc2lhbjMuc3VidHJhY3QocG9pbnRzW2kgKyAxXSwgcG9pbnRzW2kgLSAxXSwgcmlnaHQpO1xuICAgIENhcnRlc2lhbjMubXVsdGlwbHlCeVNjYWxhcihyaWdodCwgMy4wLCByaWdodCk7XG4gIH1cblxuICBkW2ldID0gMi4wO1xuXG4gIHJpZ2h0ID0gcltpXTtcbiAgaWYgKCFkZWZpbmVkKHJpZ2h0KSkge1xuICAgIHJpZ2h0ID0gcltpXSA9IG5ldyBDYXJ0ZXNpYW4zKCk7XG4gIH1cbiAgQ2FydGVzaWFuMy5zdWJ0cmFjdChwb2ludHNbaV0sIHBvaW50c1tpIC0gMV0sIHJpZ2h0KTtcbiAgQ2FydGVzaWFuMy5tdWx0aXBseUJ5U2NhbGFyKHJpZ2h0LCAzLjAsIHJpZ2h0KTtcblxuICByZXR1cm4gVHJpZGlhZ29uYWxTeXN0ZW1Tb2x2ZXIuc29sdmUobCwgZCwgdSwgcik7XG59XG5cbi8qKlxuICogQSBIZXJtaXRlIHNwbGluZSBpcyBhIGN1YmljIGludGVycG9sYXRpbmcgc3BsaW5lLiBQb2ludHMsIGluY29taW5nIHRhbmdlbnRzLCBvdXRnb2luZyB0YW5nZW50cywgYW5kIHRpbWVzXG4gKiBtdXN0IGJlIGRlZmluZWQgZm9yIGVhY2ggY29udHJvbCBwb2ludC4gVGhlIG91dGdvaW5nIHRhbmdlbnRzIGFyZSBkZWZpbmVkIGZvciBwb2ludHMgWzAsIG4gLSAyXSBhbmQgdGhlIGluY29taW5nXG4gKiB0YW5nZW50cyBhcmUgZGVmaW5lZCBmb3IgcG9pbnRzIFsxLCBuIC0gMV0uIEZvciBleGFtcGxlLCB3aGVuIGludGVycG9sYXRpbmcgYSBzZWdtZW50IG9mIHRoZSBjdXJ2ZSBiZXR3ZWVuIDxjb2RlPnBvaW50c1tpXTwvY29kZT4gYW5kXG4gKiA8Y29kZT5wb2ludHNbaSArIDFdPC9jb2RlPiwgdGhlIHRhbmdlbnRzIGF0IHRoZSBwb2ludHMgd2lsbCBiZSA8Y29kZT5vdXRUYW5nZW50c1tpXTwvY29kZT4gYW5kIDxjb2RlPmluVGFuZ2VudHNbaV08L2NvZGU+LFxuICogcmVzcGVjdGl2ZWx5LlxuICpcbiAqIEBhbGlhcyBIZXJtaXRlU3BsaW5lXG4gKiBAY29uc3RydWN0b3JcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyBPYmplY3Qgd2l0aCB0aGUgZm9sbG93aW5nIHByb3BlcnRpZXM6XG4gKiBAcGFyYW0ge051bWJlcltdfSBvcHRpb25zLnRpbWVzIEFuIGFycmF5IG9mIHN0cmljdGx5IGluY3JlYXNpbmcsIHVuaXQtbGVzcywgZmxvYXRpbmctcG9pbnQgdGltZXMgYXQgZWFjaCBwb2ludC5cbiAqICAgICAgICAgICAgICAgIFRoZSB2YWx1ZXMgYXJlIGluIG5vIHdheSBjb25uZWN0ZWQgdG8gdGhlIGNsb2NrIHRpbWUuIFRoZXkgYXJlIHRoZSBwYXJhbWV0ZXJpemF0aW9uIGZvciB0aGUgY3VydmUuXG4gKiBAcGFyYW0ge0NhcnRlc2lhbjNbXX0gb3B0aW9ucy5wb2ludHMgVGhlIGFycmF5IG9mIHtAbGluayBDYXJ0ZXNpYW4zfSBjb250cm9sIHBvaW50cy5cbiAqIEBwYXJhbSB7Q2FydGVzaWFuM1tdfSBvcHRpb25zLmluVGFuZ2VudHMgVGhlIGFycmF5IG9mIHtAbGluayBDYXJ0ZXNpYW4zfSBpbmNvbWluZyB0YW5nZW50cyBhdCBlYWNoIGNvbnRyb2wgcG9pbnQuXG4gKiBAcGFyYW0ge0NhcnRlc2lhbjNbXX0gb3B0aW9ucy5vdXRUYW5nZW50cyBUaGUgYXJyYXkgb2Yge0BsaW5rIENhcnRlc2lhbjN9IG91dGdvaW5nIHRhbmdlbnRzIGF0IGVhY2ggY29udHJvbCBwb2ludC5cbiAqXG4gKiBAZXhjZXB0aW9uIHtEZXZlbG9wZXJFcnJvcn0gcG9pbnRzLmxlbmd0aCBtdXN0IGJlIGdyZWF0ZXIgdGhhbiBvciBlcXVhbCB0byAyLlxuICogQGV4Y2VwdGlvbiB7RGV2ZWxvcGVyRXJyb3J9IHRpbWVzLmxlbmd0aCBtdXN0IGJlIGVxdWFsIHRvIHBvaW50cy5sZW5ndGguXG4gKiBAZXhjZXB0aW9uIHtEZXZlbG9wZXJFcnJvcn0gaW5UYW5nZW50cyBhbmQgb3V0VGFuZ2VudHMgbXVzdCBoYXZlIGEgbGVuZ3RoIGVxdWFsIHRvIHBvaW50cy5sZW5ndGggLSAxLlxuICpcbiAqXG4gKiBAZXhhbXBsZVxuICogLy8gQ3JlYXRlIGEgRzxzdXA+MTwvc3VwPiBjb250aW51b3VzIEhlcm1pdGUgc3BsaW5lXG4gKiB2YXIgdGltZXMgPSBbIDAuMCwgMS41LCAzLjAsIDQuNSwgNi4wIF07XG4gKiB2YXIgc3BsaW5lID0gbmV3IENlc2l1bS5IZXJtaXRlU3BsaW5lKHtcbiAqICAgICB0aW1lcyA6IHRpbWVzLFxuICogICAgIHBvaW50cyA6IFtcbiAqICAgICAgICAgbmV3IENlc2l1bS5DYXJ0ZXNpYW4zKDEyMzUzOTguMCwgLTQ4MTA5ODMuMCwgNDE0NjI2Ni4wKSxcbiAqICAgICAgICAgbmV3IENlc2l1bS5DYXJ0ZXNpYW4zKDEzNzI1NzQuMCwgLTUzNDUxODIuMCwgNDYwNjY1Ny4wKSxcbiAqICAgICAgICAgbmV3IENlc2l1bS5DYXJ0ZXNpYW4zKC03NTc5ODMuMCwgLTU1NDI3OTYuMCwgNDUxNDMyMy4wKSxcbiAqICAgICAgICAgbmV3IENlc2l1bS5DYXJ0ZXNpYW4zKC0yODIxMjYwLjAsIC01MjQ4NDIzLjAsIDQwMjEyOTAuMCksXG4gKiAgICAgICAgIG5ldyBDZXNpdW0uQ2FydGVzaWFuMygtMjUzOTc4OC4wLCAtNDcyNDc5Ny4wLCAzNjIwMDkzLjApXG4gKiAgICAgXSxcbiAqICAgICBvdXRUYW5nZW50cyA6IFtcbiAqICAgICAgICAgbmV3IENlc2l1bS5DYXJ0ZXNpYW4zKDExMjUxOTYsIC0xNjE4MTYsIDI3MDU1MSksXG4gKiAgICAgICAgIG5ldyBDZXNpdW0uQ2FydGVzaWFuMygtOTk2NjkwLjUsIC0zNjU5MDYuNSwgMTg0MDI4LjUpLFxuICogICAgICAgICBuZXcgQ2VzaXVtLkNhcnRlc2lhbjMoLTIwOTY5MTcsIDQ4Mzc5LjUsIC0yOTI2ODMuNSksXG4gKiAgICAgICAgIG5ldyBDZXNpdW0uQ2FydGVzaWFuMygtODkwOTAyLjUsIDQwODk5OS41LCAtNDQ3MTE1KVxuICogICAgIF0sXG4gKiAgICAgaW5UYW5nZW50cyA6IFtcbiAqICAgICAgICAgbmV3IENlc2l1bS5DYXJ0ZXNpYW4zKC0xOTkzMzgxLCAtNzMxODEzLCAzNjgwNTcpLFxuICogICAgICAgICBuZXcgQ2VzaXVtLkNhcnRlc2lhbjMoLTQxOTM4MzQsIDk2NzU5LCAtNTg1MzY3KSxcbiAqICAgICAgICAgbmV3IENlc2l1bS5DYXJ0ZXNpYW4zKC0xNzgxODA1LCA4MTc5OTksIC04OTQyMzApLFxuICogICAgICAgICBuZXcgQ2VzaXVtLkNhcnRlc2lhbjMoMTE2NTM0NSwgMTEyNjQxLCA0NzI4MSlcbiAqICAgICBdXG4gKiB9KTtcbiAqXG4gKiB2YXIgcDAgPSBzcGxpbmUuZXZhbHVhdGUodGltZXNbMF0pO1xuICpcbiAqIEBzZWUgQ2F0bXVsbFJvbVNwbGluZVxuICogQHNlZSBMaW5lYXJTcGxpbmVcbiAqIEBzZWUgUXVhdGVybmlvblNwbGluZVxuICogQHNlZSBXZWlnaHRTcGxpbmVcbiAqL1xuZnVuY3Rpb24gSGVybWl0ZVNwbGluZShvcHRpb25zKSB7XG4gIG9wdGlvbnMgPSBkZWZhdWx0VmFsdWUob3B0aW9ucywgZGVmYXVsdFZhbHVlLkVNUFRZX09CSkVDVCk7XG5cbiAgdmFyIHBvaW50cyA9IG9wdGlvbnMucG9pbnRzO1xuICB2YXIgdGltZXMgPSBvcHRpb25zLnRpbWVzO1xuICB2YXIgaW5UYW5nZW50cyA9IG9wdGlvbnMuaW5UYW5nZW50cztcbiAgdmFyIG91dFRhbmdlbnRzID0gb3B0aW9ucy5vdXRUYW5nZW50cztcblxuICAvLz4+aW5jbHVkZVN0YXJ0KCdkZWJ1ZycsIHByYWdtYXMuZGVidWcpO1xuICBpZiAoXG4gICAgIWRlZmluZWQocG9pbnRzKSB8fFxuICAgICFkZWZpbmVkKHRpbWVzKSB8fFxuICAgICFkZWZpbmVkKGluVGFuZ2VudHMpIHx8XG4gICAgIWRlZmluZWQob3V0VGFuZ2VudHMpXG4gICkge1xuICAgIHRocm93IG5ldyBEZXZlbG9wZXJFcnJvcihcbiAgICAgIFwidGltZXMsIHBvaW50cywgaW5UYW5nZW50cywgYW5kIG91dFRhbmdlbnRzIGFyZSByZXF1aXJlZC5cIlxuICAgICk7XG4gIH1cbiAgaWYgKHBvaW50cy5sZW5ndGggPCAyKSB7XG4gICAgdGhyb3cgbmV3IERldmVsb3BlckVycm9yKFxuICAgICAgXCJwb2ludHMubGVuZ3RoIG11c3QgYmUgZ3JlYXRlciB0aGFuIG9yIGVxdWFsIHRvIDIuXCJcbiAgICApO1xuICB9XG4gIGlmICh0aW1lcy5sZW5ndGggIT09IHBvaW50cy5sZW5ndGgpIHtcbiAgICB0aHJvdyBuZXcgRGV2ZWxvcGVyRXJyb3IoXCJ0aW1lcy5sZW5ndGggbXVzdCBiZSBlcXVhbCB0byBwb2ludHMubGVuZ3RoLlwiKTtcbiAgfVxuICBpZiAoXG4gICAgaW5UYW5nZW50cy5sZW5ndGggIT09IG91dFRhbmdlbnRzLmxlbmd0aCB8fFxuICAgIGluVGFuZ2VudHMubGVuZ3RoICE9PSBwb2ludHMubGVuZ3RoIC0gMVxuICApIHtcbiAgICB0aHJvdyBuZXcgRGV2ZWxvcGVyRXJyb3IoXG4gICAgICBcImluVGFuZ2VudHMgYW5kIG91dFRhbmdlbnRzIG11c3QgaGF2ZSBhIGxlbmd0aCBlcXVhbCB0byBwb2ludHMubGVuZ3RoIC0gMS5cIlxuICAgICk7XG4gIH1cbiAgLy8+PmluY2x1ZGVFbmQoJ2RlYnVnJyk7XG5cbiAgdGhpcy5fdGltZXMgPSB0aW1lcztcbiAgdGhpcy5fcG9pbnRzID0gcG9pbnRzO1xuICB0aGlzLl9pblRhbmdlbnRzID0gaW5UYW5nZW50cztcbiAgdGhpcy5fb3V0VGFuZ2VudHMgPSBvdXRUYW5nZW50cztcblxuICB0aGlzLl9sYXN0VGltZUluZGV4ID0gMDtcbn1cblxuT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoSGVybWl0ZVNwbGluZS5wcm90b3R5cGUsIHtcbiAgLyoqXG4gICAqIEFuIGFycmF5IG9mIHRpbWVzIGZvciB0aGUgY29udHJvbCBwb2ludHMuXG4gICAqXG4gICAqIEBtZW1iZXJvZiBIZXJtaXRlU3BsaW5lLnByb3RvdHlwZVxuICAgKlxuICAgKiBAdHlwZSB7TnVtYmVyW119XG4gICAqIEByZWFkb25seVxuICAgKi9cbiAgdGltZXM6IHtcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLl90aW1lcztcbiAgICB9LFxuICB9LFxuXG4gIC8qKlxuICAgKiBBbiBhcnJheSBvZiB7QGxpbmsgQ2FydGVzaWFuM30gY29udHJvbCBwb2ludHMuXG4gICAqXG4gICAqIEBtZW1iZXJvZiBIZXJtaXRlU3BsaW5lLnByb3RvdHlwZVxuICAgKlxuICAgKiBAdHlwZSB7Q2FydGVzaWFuM1tdfVxuICAgKiBAcmVhZG9ubHlcbiAgICovXG4gIHBvaW50czoge1xuICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX3BvaW50cztcbiAgICB9LFxuICB9LFxuXG4gIC8qKlxuICAgKiBBbiBhcnJheSBvZiB7QGxpbmsgQ2FydGVzaWFuM30gaW5jb21pbmcgdGFuZ2VudHMgYXQgZWFjaCBjb250cm9sIHBvaW50LlxuICAgKlxuICAgKiBAbWVtYmVyb2YgSGVybWl0ZVNwbGluZS5wcm90b3R5cGVcbiAgICpcbiAgICogQHR5cGUge0NhcnRlc2lhbjNbXX1cbiAgICogQHJlYWRvbmx5XG4gICAqL1xuICBpblRhbmdlbnRzOiB7XG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5faW5UYW5nZW50cztcbiAgICB9LFxuICB9LFxuXG4gIC8qKlxuICAgKiBBbiBhcnJheSBvZiB7QGxpbmsgQ2FydGVzaWFuM30gb3V0Z29pbmcgdGFuZ2VudHMgYXQgZWFjaCBjb250cm9sIHBvaW50LlxuICAgKlxuICAgKiBAbWVtYmVyb2YgSGVybWl0ZVNwbGluZS5wcm90b3R5cGVcbiAgICpcbiAgICogQHR5cGUge0NhcnRlc2lhbjNbXX1cbiAgICogQHJlYWRvbmx5XG4gICAqL1xuICBvdXRUYW5nZW50czoge1xuICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX291dFRhbmdlbnRzO1xuICAgIH0sXG4gIH0sXG59KTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgc3BsaW5lIHdoZXJlIHRoZSB0YW5nZW50cyBhdCBlYWNoIGNvbnRyb2wgcG9pbnQgYXJlIHRoZSBzYW1lLlxuICogVGhlIGN1cnZlcyBhcmUgZ3VhcmFudGVlZCB0byBiZSBhdCBsZWFzdCBpbiB0aGUgY2xhc3MgQzxzdXA+MTwvc3VwPi5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyBPYmplY3Qgd2l0aCB0aGUgZm9sbG93aW5nIHByb3BlcnRpZXM6XG4gKiBAcGFyYW0ge051bWJlcltdfSBvcHRpb25zLnRpbWVzIFRoZSBhcnJheSBvZiBjb250cm9sIHBvaW50IHRpbWVzLlxuICogQHBhcmFtIHtDYXJ0ZXNpYW4zW119IG9wdGlvbnMucG9pbnRzIFRoZSBhcnJheSBvZiBjb250cm9sIHBvaW50cy5cbiAqIEBwYXJhbSB7Q2FydGVzaWFuM1tdfSBvcHRpb25zLnRhbmdlbnRzIFRoZSBhcnJheSBvZiB0YW5nZW50cyBhdCB0aGUgY29udHJvbCBwb2ludHMuXG4gKiBAcmV0dXJucyB7SGVybWl0ZVNwbGluZX0gQSBoZXJtaXRlIHNwbGluZS5cbiAqXG4gKiBAZXhjZXB0aW9uIHtEZXZlbG9wZXJFcnJvcn0gcG9pbnRzLCB0aW1lcyBhbmQgdGFuZ2VudHMgYXJlIHJlcXVpcmVkLlxuICogQGV4Y2VwdGlvbiB7RGV2ZWxvcGVyRXJyb3J9IHBvaW50cy5sZW5ndGggbXVzdCBiZSBncmVhdGVyIHRoYW4gb3IgZXF1YWwgdG8gMi5cbiAqIEBleGNlcHRpb24ge0RldmVsb3BlckVycm9yfSB0aW1lcywgcG9pbnRzIGFuZCB0YW5nZW50cyBtdXN0IGhhdmUgdGhlIHNhbWUgbGVuZ3RoLlxuICpcbiAqIEBleGFtcGxlXG4gKiB2YXIgcG9pbnRzID0gW1xuICogICAgIG5ldyBDZXNpdW0uQ2FydGVzaWFuMygxMjM1Mzk4LjAsIC00ODEwOTgzLjAsIDQxNDYyNjYuMCksXG4gKiAgICAgbmV3IENlc2l1bS5DYXJ0ZXNpYW4zKDEzNzI1NzQuMCwgLTUzNDUxODIuMCwgNDYwNjY1Ny4wKSxcbiAqICAgICBuZXcgQ2VzaXVtLkNhcnRlc2lhbjMoLTc1Nzk4My4wLCAtNTU0Mjc5Ni4wLCA0NTE0MzIzLjApLFxuICogICAgIG5ldyBDZXNpdW0uQ2FydGVzaWFuMygtMjgyMTI2MC4wLCAtNTI0ODQyMy4wLCA0MDIxMjkwLjApLFxuICogICAgIG5ldyBDZXNpdW0uQ2FydGVzaWFuMygtMjUzOTc4OC4wLCAtNDcyNDc5Ny4wLCAzNjIwMDkzLjApXG4gKiBdO1xuICpcbiAqIC8vIEFkZCB0YW5nZW50c1xuICogdmFyIHRhbmdlbnRzID0gbmV3IEFycmF5KHBvaW50cy5sZW5ndGgpO1xuICogdGFuZ2VudHNbMF0gPSBuZXcgQ2VzaXVtLkNhcnRlc2lhbjMoMTEyNTE5NiwgLTE2MTgxNiwgMjcwNTUxKTtcbiAqIHZhciB0ZW1wID0gbmV3IENlc2l1bS5DYXJ0ZXNpYW4zKCk7XG4gKiBmb3IgKHZhciBpID0gMTsgaSA8IHRhbmdlbnRzLmxlbmd0aCAtIDE7ICsraSkge1xuICogICAgIHRhbmdlbnRzW2ldID0gQ2VzaXVtLkNhcnRlc2lhbjMubXVsdGlwbHlCeVNjYWxhcihDZXNpdW0uQ2FydGVzaWFuMy5zdWJ0cmFjdChwb2ludHNbaSArIDFdLCBwb2ludHNbaSAtIDFdLCB0ZW1wKSwgMC41LCBuZXcgQ2VzaXVtLkNhcnRlc2lhbjMoKSk7XG4gKiB9XG4gKiB0YW5nZW50c1t0YW5nZW50cy5sZW5ndGggLSAxXSA9IG5ldyBDZXNpdW0uQ2FydGVzaWFuMygxMTY1MzQ1LCAxMTI2NDEsIDQ3MjgxKTtcbiAqXG4gKiB2YXIgc3BsaW5lID0gQ2VzaXVtLkhlcm1pdGVTcGxpbmUuY3JlYXRlQzEoe1xuICogICAgIHRpbWVzIDogdGltZXMsXG4gKiAgICAgcG9pbnRzIDogcG9pbnRzLFxuICogICAgIHRhbmdlbnRzIDogdGFuZ2VudHNcbiAqIH0pO1xuICovXG5IZXJtaXRlU3BsaW5lLmNyZWF0ZUMxID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgb3B0aW9ucyA9IGRlZmF1bHRWYWx1ZShvcHRpb25zLCBkZWZhdWx0VmFsdWUuRU1QVFlfT0JKRUNUKTtcblxuICB2YXIgdGltZXMgPSBvcHRpb25zLnRpbWVzO1xuICB2YXIgcG9pbnRzID0gb3B0aW9ucy5wb2ludHM7XG4gIHZhciB0YW5nZW50cyA9IG9wdGlvbnMudGFuZ2VudHM7XG5cbiAgLy8+PmluY2x1ZGVTdGFydCgnZGVidWcnLCBwcmFnbWFzLmRlYnVnKTtcbiAgaWYgKCFkZWZpbmVkKHBvaW50cykgfHwgIWRlZmluZWQodGltZXMpIHx8ICFkZWZpbmVkKHRhbmdlbnRzKSkge1xuICAgIHRocm93IG5ldyBEZXZlbG9wZXJFcnJvcihcInBvaW50cywgdGltZXMgYW5kIHRhbmdlbnRzIGFyZSByZXF1aXJlZC5cIik7XG4gIH1cbiAgaWYgKHBvaW50cy5sZW5ndGggPCAyKSB7XG4gICAgdGhyb3cgbmV3IERldmVsb3BlckVycm9yKFxuICAgICAgXCJwb2ludHMubGVuZ3RoIG11c3QgYmUgZ3JlYXRlciB0aGFuIG9yIGVxdWFsIHRvIDIuXCJcbiAgICApO1xuICB9XG4gIGlmICh0aW1lcy5sZW5ndGggIT09IHBvaW50cy5sZW5ndGggfHwgdGltZXMubGVuZ3RoICE9PSB0YW5nZW50cy5sZW5ndGgpIHtcbiAgICB0aHJvdyBuZXcgRGV2ZWxvcGVyRXJyb3IoXG4gICAgICBcInRpbWVzLCBwb2ludHMgYW5kIHRhbmdlbnRzIG11c3QgaGF2ZSB0aGUgc2FtZSBsZW5ndGguXCJcbiAgICApO1xuICB9XG4gIC8vPj5pbmNsdWRlRW5kKCdkZWJ1ZycpO1xuXG4gIHZhciBvdXRUYW5nZW50cyA9IHRhbmdlbnRzLnNsaWNlKDAsIHRhbmdlbnRzLmxlbmd0aCAtIDEpO1xuICB2YXIgaW5UYW5nZW50cyA9IHRhbmdlbnRzLnNsaWNlKDEsIHRhbmdlbnRzLmxlbmd0aCk7XG5cbiAgcmV0dXJuIG5ldyBIZXJtaXRlU3BsaW5lKHtcbiAgICB0aW1lczogdGltZXMsXG4gICAgcG9pbnRzOiBwb2ludHMsXG4gICAgaW5UYW5nZW50czogaW5UYW5nZW50cyxcbiAgICBvdXRUYW5nZW50czogb3V0VGFuZ2VudHMsXG4gIH0pO1xufTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgbmF0dXJhbCBjdWJpYyBzcGxpbmUuIFRoZSB0YW5nZW50cyBhdCB0aGUgY29udHJvbCBwb2ludHMgYXJlIGdlbmVyYXRlZFxuICogdG8gY3JlYXRlIGEgY3VydmUgaW4gdGhlIGNsYXNzIEM8c3VwPjI8L3N1cD4uXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgT2JqZWN0IHdpdGggdGhlIGZvbGxvd2luZyBwcm9wZXJ0aWVzOlxuICogQHBhcmFtIHtOdW1iZXJbXX0gb3B0aW9ucy50aW1lcyBUaGUgYXJyYXkgb2YgY29udHJvbCBwb2ludCB0aW1lcy5cbiAqIEBwYXJhbSB7Q2FydGVzaWFuM1tdfSBvcHRpb25zLnBvaW50cyBUaGUgYXJyYXkgb2YgY29udHJvbCBwb2ludHMuXG4gKiBAcmV0dXJucyB7SGVybWl0ZVNwbGluZXxMaW5lYXJTcGxpbmV9IEEgaGVybWl0ZSBzcGxpbmUgb3IgYSBsaW5lYXIgc3BsaW5lIGlmIGxlc3MgdGhhbiAzIGNvbnRyb2wgcG9pbnRzIHdlcmUgZ2l2ZW4uXG4gKlxuICogQGV4Y2VwdGlvbiB7RGV2ZWxvcGVyRXJyb3J9IHBvaW50cyBhbmQgdGltZXMgYXJlIHJlcXVpcmVkLlxuICogQGV4Y2VwdGlvbiB7RGV2ZWxvcGVyRXJyb3J9IHBvaW50cy5sZW5ndGggbXVzdCBiZSBncmVhdGVyIHRoYW4gb3IgZXF1YWwgdG8gMi5cbiAqIEBleGNlcHRpb24ge0RldmVsb3BlckVycm9yfSB0aW1lcy5sZW5ndGggbXVzdCBiZSBlcXVhbCB0byBwb2ludHMubGVuZ3RoLlxuICpcbiAqIEBleGFtcGxlXG4gKiAvLyBDcmVhdGUgYSBuYXR1cmFsIGN1YmljIHNwbGluZSBhYm92ZSB0aGUgZWFydGggZnJvbSBQaGlsYWRlbHBoaWEgdG8gTG9zIEFuZ2VsZXMuXG4gKiB2YXIgc3BsaW5lID0gQ2VzaXVtLkhlcm1pdGVTcGxpbmUuY3JlYXRlTmF0dXJhbEN1YmljKHtcbiAqICAgICB0aW1lcyA6IFsgMC4wLCAxLjUsIDMuMCwgNC41LCA2LjAgXSxcbiAqICAgICBwb2ludHMgOiBbXG4gKiAgICAgICAgIG5ldyBDZXNpdW0uQ2FydGVzaWFuMygxMjM1Mzk4LjAsIC00ODEwOTgzLjAsIDQxNDYyNjYuMCksXG4gKiAgICAgICAgIG5ldyBDZXNpdW0uQ2FydGVzaWFuMygxMzcyNTc0LjAsIC01MzQ1MTgyLjAsIDQ2MDY2NTcuMCksXG4gKiAgICAgICAgIG5ldyBDZXNpdW0uQ2FydGVzaWFuMygtNzU3OTgzLjAsIC01NTQyNzk2LjAsIDQ1MTQzMjMuMCksXG4gKiAgICAgICAgIG5ldyBDZXNpdW0uQ2FydGVzaWFuMygtMjgyMTI2MC4wLCAtNTI0ODQyMy4wLCA0MDIxMjkwLjApLFxuICogICAgICAgICBuZXcgQ2VzaXVtLkNhcnRlc2lhbjMoLTI1Mzk3ODguMCwgLTQ3MjQ3OTcuMCwgMzYyMDA5My4wKVxuICogICAgIF1cbiAqIH0pO1xuICovXG5IZXJtaXRlU3BsaW5lLmNyZWF0ZU5hdHVyYWxDdWJpYyA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gIG9wdGlvbnMgPSBkZWZhdWx0VmFsdWUob3B0aW9ucywgZGVmYXVsdFZhbHVlLkVNUFRZX09CSkVDVCk7XG5cbiAgdmFyIHRpbWVzID0gb3B0aW9ucy50aW1lcztcbiAgdmFyIHBvaW50cyA9IG9wdGlvbnMucG9pbnRzO1xuXG4gIC8vPj5pbmNsdWRlU3RhcnQoJ2RlYnVnJywgcHJhZ21hcy5kZWJ1Zyk7XG4gIGlmICghZGVmaW5lZChwb2ludHMpIHx8ICFkZWZpbmVkKHRpbWVzKSkge1xuICAgIHRocm93IG5ldyBEZXZlbG9wZXJFcnJvcihcInBvaW50cyBhbmQgdGltZXMgYXJlIHJlcXVpcmVkLlwiKTtcbiAgfVxuICBpZiAocG9pbnRzLmxlbmd0aCA8IDIpIHtcbiAgICB0aHJvdyBuZXcgRGV2ZWxvcGVyRXJyb3IoXG4gICAgICBcInBvaW50cy5sZW5ndGggbXVzdCBiZSBncmVhdGVyIHRoYW4gb3IgZXF1YWwgdG8gMi5cIlxuICAgICk7XG4gIH1cbiAgaWYgKHRpbWVzLmxlbmd0aCAhPT0gcG9pbnRzLmxlbmd0aCkge1xuICAgIHRocm93IG5ldyBEZXZlbG9wZXJFcnJvcihcInRpbWVzLmxlbmd0aCBtdXN0IGJlIGVxdWFsIHRvIHBvaW50cy5sZW5ndGguXCIpO1xuICB9XG4gIC8vPj5pbmNsdWRlRW5kKCdkZWJ1ZycpO1xuXG4gIGlmIChwb2ludHMubGVuZ3RoIDwgMykge1xuICAgIHJldHVybiBuZXcgTGluZWFyU3BsaW5lKHtcbiAgICAgIHBvaW50czogcG9pbnRzLFxuICAgICAgdGltZXM6IHRpbWVzLFxuICAgIH0pO1xuICB9XG5cbiAgdmFyIHRhbmdlbnRzID0gZ2VuZXJhdGVOYXR1cmFsKHBvaW50cyk7XG4gIHZhciBvdXRUYW5nZW50cyA9IHRhbmdlbnRzLnNsaWNlKDAsIHRhbmdlbnRzLmxlbmd0aCAtIDEpO1xuICB2YXIgaW5UYW5nZW50cyA9IHRhbmdlbnRzLnNsaWNlKDEsIHRhbmdlbnRzLmxlbmd0aCk7XG5cbiAgcmV0dXJuIG5ldyBIZXJtaXRlU3BsaW5lKHtcbiAgICB0aW1lczogdGltZXMsXG4gICAgcG9pbnRzOiBwb2ludHMsXG4gICAgaW5UYW5nZW50czogaW5UYW5nZW50cyxcbiAgICBvdXRUYW5nZW50czogb3V0VGFuZ2VudHMsXG4gIH0pO1xufTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgY2xhbXBlZCBjdWJpYyBzcGxpbmUuIFRoZSB0YW5nZW50cyBhdCB0aGUgaW50ZXJpb3IgY29udHJvbCBwb2ludHMgYXJlIGdlbmVyYXRlZFxuICogdG8gY3JlYXRlIGEgY3VydmUgaW4gdGhlIGNsYXNzIEM8c3VwPjI8L3N1cD4uXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgT2JqZWN0IHdpdGggdGhlIGZvbGxvd2luZyBwcm9wZXJ0aWVzOlxuICogQHBhcmFtIHtOdW1iZXJbXX0gb3B0aW9ucy50aW1lcyBUaGUgYXJyYXkgb2YgY29udHJvbCBwb2ludCB0aW1lcy5cbiAqIEBwYXJhbSB7Q2FydGVzaWFuM1tdfSBvcHRpb25zLnBvaW50cyBUaGUgYXJyYXkgb2YgY29udHJvbCBwb2ludHMuXG4gKiBAcGFyYW0ge0NhcnRlc2lhbjN9IG9wdGlvbnMuZmlyc3RUYW5nZW50IFRoZSBvdXRnb2luZyB0YW5nZW50IG9mIHRoZSBmaXJzdCBjb250cm9sIHBvaW50LlxuICogQHBhcmFtIHtDYXJ0ZXNpYW4zfSBvcHRpb25zLmxhc3RUYW5nZW50IFRoZSBpbmNvbWluZyB0YW5nZW50IG9mIHRoZSBsYXN0IGNvbnRyb2wgcG9pbnQuXG4gKiBAcmV0dXJucyB7SGVybWl0ZVNwbGluZXxMaW5lYXJTcGxpbmV9IEEgaGVybWl0ZSBzcGxpbmUgb3IgYSBsaW5lYXIgc3BsaW5lIGlmIGxlc3MgdGhhbiAzIGNvbnRyb2wgcG9pbnRzIHdlcmUgZ2l2ZW4uXG4gKlxuICogQGV4Y2VwdGlvbiB7RGV2ZWxvcGVyRXJyb3J9IHBvaW50cywgdGltZXMsIGZpcnN0VGFuZ2VudCBhbmQgbGFzdFRhbmdlbnQgYXJlIHJlcXVpcmVkLlxuICogQGV4Y2VwdGlvbiB7RGV2ZWxvcGVyRXJyb3J9IHBvaW50cy5sZW5ndGggbXVzdCBiZSBncmVhdGVyIHRoYW4gb3IgZXF1YWwgdG8gMi5cbiAqIEBleGNlcHRpb24ge0RldmVsb3BlckVycm9yfSB0aW1lcy5sZW5ndGggbXVzdCBiZSBlcXVhbCB0byBwb2ludHMubGVuZ3RoLlxuICpcbiAqIEBleGFtcGxlXG4gKiAvLyBDcmVhdGUgYSBjbGFtcGVkIGN1YmljIHNwbGluZSBhYm92ZSB0aGUgZWFydGggZnJvbSBQaGlsYWRlbHBoaWEgdG8gTG9zIEFuZ2VsZXMuXG4gKiB2YXIgc3BsaW5lID0gQ2VzaXVtLkhlcm1pdGVTcGxpbmUuY3JlYXRlQ2xhbXBlZEN1YmljKHtcbiAqICAgICB0aW1lcyA6IFsgMC4wLCAxLjUsIDMuMCwgNC41LCA2LjAgXSxcbiAqICAgICBwb2ludHMgOiBbXG4gKiAgICAgICAgIG5ldyBDZXNpdW0uQ2FydGVzaWFuMygxMjM1Mzk4LjAsIC00ODEwOTgzLjAsIDQxNDYyNjYuMCksXG4gKiAgICAgICAgIG5ldyBDZXNpdW0uQ2FydGVzaWFuMygxMzcyNTc0LjAsIC01MzQ1MTgyLjAsIDQ2MDY2NTcuMCksXG4gKiAgICAgICAgIG5ldyBDZXNpdW0uQ2FydGVzaWFuMygtNzU3OTgzLjAsIC01NTQyNzk2LjAsIDQ1MTQzMjMuMCksXG4gKiAgICAgICAgIG5ldyBDZXNpdW0uQ2FydGVzaWFuMygtMjgyMTI2MC4wLCAtNTI0ODQyMy4wLCA0MDIxMjkwLjApLFxuICogICAgICAgICBuZXcgQ2VzaXVtLkNhcnRlc2lhbjMoLTI1Mzk3ODguMCwgLTQ3MjQ3OTcuMCwgMzYyMDA5My4wKVxuICogICAgIF0sXG4gKiAgICAgZmlyc3RUYW5nZW50IDogbmV3IENlc2l1bS5DYXJ0ZXNpYW4zKDExMjUxOTYsIC0xNjE4MTYsIDI3MDU1MSksXG4gKiAgICAgbGFzdFRhbmdlbnQgOiBuZXcgQ2VzaXVtLkNhcnRlc2lhbjMoMTE2NTM0NSwgMTEyNjQxLCA0NzI4MSlcbiAqIH0pO1xuICovXG5IZXJtaXRlU3BsaW5lLmNyZWF0ZUNsYW1wZWRDdWJpYyA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gIG9wdGlvbnMgPSBkZWZhdWx0VmFsdWUob3B0aW9ucywgZGVmYXVsdFZhbHVlLkVNUFRZX09CSkVDVCk7XG5cbiAgdmFyIHRpbWVzID0gb3B0aW9ucy50aW1lcztcbiAgdmFyIHBvaW50cyA9IG9wdGlvbnMucG9pbnRzO1xuICB2YXIgZmlyc3RUYW5nZW50ID0gb3B0aW9ucy5maXJzdFRhbmdlbnQ7XG4gIHZhciBsYXN0VGFuZ2VudCA9IG9wdGlvbnMubGFzdFRhbmdlbnQ7XG5cbiAgLy8+PmluY2x1ZGVTdGFydCgnZGVidWcnLCBwcmFnbWFzLmRlYnVnKTtcbiAgaWYgKFxuICAgICFkZWZpbmVkKHBvaW50cykgfHxcbiAgICAhZGVmaW5lZCh0aW1lcykgfHxcbiAgICAhZGVmaW5lZChmaXJzdFRhbmdlbnQpIHx8XG4gICAgIWRlZmluZWQobGFzdFRhbmdlbnQpXG4gICkge1xuICAgIHRocm93IG5ldyBEZXZlbG9wZXJFcnJvcihcbiAgICAgIFwicG9pbnRzLCB0aW1lcywgZmlyc3RUYW5nZW50IGFuZCBsYXN0VGFuZ2VudCBhcmUgcmVxdWlyZWQuXCJcbiAgICApO1xuICB9XG4gIGlmIChwb2ludHMubGVuZ3RoIDwgMikge1xuICAgIHRocm93IG5ldyBEZXZlbG9wZXJFcnJvcihcbiAgICAgIFwicG9pbnRzLmxlbmd0aCBtdXN0IGJlIGdyZWF0ZXIgdGhhbiBvciBlcXVhbCB0byAyLlwiXG4gICAgKTtcbiAgfVxuICBpZiAodGltZXMubGVuZ3RoICE9PSBwb2ludHMubGVuZ3RoKSB7XG4gICAgdGhyb3cgbmV3IERldmVsb3BlckVycm9yKFwidGltZXMubGVuZ3RoIG11c3QgYmUgZXF1YWwgdG8gcG9pbnRzLmxlbmd0aC5cIik7XG4gIH1cbiAgLy8+PmluY2x1ZGVFbmQoJ2RlYnVnJyk7XG5cbiAgaWYgKHBvaW50cy5sZW5ndGggPCAzKSB7XG4gICAgcmV0dXJuIG5ldyBMaW5lYXJTcGxpbmUoe1xuICAgICAgcG9pbnRzOiBwb2ludHMsXG4gICAgICB0aW1lczogdGltZXMsXG4gICAgfSk7XG4gIH1cblxuICB2YXIgdGFuZ2VudHMgPSBnZW5lcmF0ZUNsYW1wZWQocG9pbnRzLCBmaXJzdFRhbmdlbnQsIGxhc3RUYW5nZW50KTtcbiAgdmFyIG91dFRhbmdlbnRzID0gdGFuZ2VudHMuc2xpY2UoMCwgdGFuZ2VudHMubGVuZ3RoIC0gMSk7XG4gIHZhciBpblRhbmdlbnRzID0gdGFuZ2VudHMuc2xpY2UoMSwgdGFuZ2VudHMubGVuZ3RoKTtcblxuICByZXR1cm4gbmV3IEhlcm1pdGVTcGxpbmUoe1xuICAgIHRpbWVzOiB0aW1lcyxcbiAgICBwb2ludHM6IHBvaW50cyxcbiAgICBpblRhbmdlbnRzOiBpblRhbmdlbnRzLFxuICAgIG91dFRhbmdlbnRzOiBvdXRUYW5nZW50cyxcbiAgfSk7XG59O1xuXG5IZXJtaXRlU3BsaW5lLmhlcm1pdGVDb2VmZmljaWVudE1hdHJpeCA9IG5ldyBNYXRyaXg0KFxuICAyLjAsXG4gIC0zLjAsXG4gIDAuMCxcbiAgMS4wLFxuICAtMi4wLFxuICAzLjAsXG4gIDAuMCxcbiAgMC4wLFxuICAxLjAsXG4gIC0yLjAsXG4gIDEuMCxcbiAgMC4wLFxuICAxLjAsXG4gIC0xLjAsXG4gIDAuMCxcbiAgMC4wXG4pO1xuXG4vKipcbiAqIEZpbmRzIGFuIGluZGV4IDxjb2RlPmk8L2NvZGU+IGluIDxjb2RlPnRpbWVzPC9jb2RlPiBzdWNoIHRoYXQgdGhlIHBhcmFtZXRlclxuICogPGNvZGU+dGltZTwvY29kZT4gaXMgaW4gdGhlIGludGVydmFsIDxjb2RlPlt0aW1lc1tpXSwgdGltZXNbaSArIDFdXTwvY29kZT4uXG4gKiBAZnVuY3Rpb25cbiAqXG4gKiBAcGFyYW0ge051bWJlcn0gdGltZSBUaGUgdGltZS5cbiAqIEByZXR1cm5zIHtOdW1iZXJ9IFRoZSBpbmRleCBmb3IgdGhlIGVsZW1lbnQgYXQgdGhlIHN0YXJ0IG9mIHRoZSBpbnRlcnZhbC5cbiAqXG4gKiBAZXhjZXB0aW9uIHtEZXZlbG9wZXJFcnJvcn0gdGltZSBtdXN0IGJlIGluIHRoZSByYW5nZSA8Y29kZT5bdDxzdWI+MDwvc3ViPiwgdDxzdWI+bjwvc3ViPl08L2NvZGU+LCB3aGVyZSA8Y29kZT50PHN1Yj4wPC9zdWI+PC9jb2RlPlxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlzIHRoZSBmaXJzdCBlbGVtZW50IGluIHRoZSBhcnJheSA8Y29kZT50aW1lczwvY29kZT4gYW5kIDxjb2RlPnQ8c3ViPm48L3N1Yj48L2NvZGU+IGlzIHRoZSBsYXN0IGVsZW1lbnRcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbiB0aGUgYXJyYXkgPGNvZGU+dGltZXM8L2NvZGU+LlxuICovXG5IZXJtaXRlU3BsaW5lLnByb3RvdHlwZS5maW5kVGltZUludGVydmFsID0gU3BsaW5lLnByb3RvdHlwZS5maW5kVGltZUludGVydmFsO1xuXG52YXIgc2NyYXRjaFRpbWVWZWMgPSBuZXcgQ2FydGVzaWFuNCgpO1xudmFyIHNjcmF0Y2hUZW1wID0gbmV3IENhcnRlc2lhbjMoKTtcblxuLyoqXG4gKiBXcmFwcyB0aGUgZ2l2ZW4gdGltZSB0byB0aGUgcGVyaW9kIGNvdmVyZWQgYnkgdGhlIHNwbGluZS5cbiAqIEBmdW5jdGlvblxuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSB0aW1lIFRoZSB0aW1lLlxuICogQHJldHVybiB7TnVtYmVyfSBUaGUgdGltZSwgd3JhcHBlZCBhcm91bmQgdG8gdGhlIHVwZGF0ZWQgYW5pbWF0aW9uLlxuICovXG5IZXJtaXRlU3BsaW5lLnByb3RvdHlwZS53cmFwVGltZSA9IFNwbGluZS5wcm90b3R5cGUud3JhcFRpbWU7XG5cbi8qKlxuICogQ2xhbXBzIHRoZSBnaXZlbiB0aW1lIHRvIHRoZSBwZXJpb2QgY292ZXJlZCBieSB0aGUgc3BsaW5lLlxuICogQGZ1bmN0aW9uXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IHRpbWUgVGhlIHRpbWUuXG4gKiBAcmV0dXJuIHtOdW1iZXJ9IFRoZSB0aW1lLCBjbGFtcGVkIHRvIHRoZSBhbmltYXRpb24gcGVyaW9kLlxuICovXG5IZXJtaXRlU3BsaW5lLnByb3RvdHlwZS5jbGFtcFRpbWUgPSBTcGxpbmUucHJvdG90eXBlLmNsYW1wVGltZTtcblxuLyoqXG4gKiBFdmFsdWF0ZXMgdGhlIGN1cnZlIGF0IGEgZ2l2ZW4gdGltZS5cbiAqXG4gKiBAcGFyYW0ge051bWJlcn0gdGltZSBUaGUgdGltZSBhdCB3aGljaCB0byBldmFsdWF0ZSB0aGUgY3VydmUuXG4gKiBAcGFyYW0ge0NhcnRlc2lhbjN9IFtyZXN1bHRdIFRoZSBvYmplY3Qgb250byB3aGljaCB0byBzdG9yZSB0aGUgcmVzdWx0LlxuICogQHJldHVybnMge0NhcnRlc2lhbjN9IFRoZSBtb2RpZmllZCByZXN1bHQgcGFyYW1ldGVyIG9yIGEgbmV3IGluc3RhbmNlIG9mIHRoZSBwb2ludCBvbiB0aGUgY3VydmUgYXQgdGhlIGdpdmVuIHRpbWUuXG4gKlxuICogQGV4Y2VwdGlvbiB7RGV2ZWxvcGVyRXJyb3J9IHRpbWUgbXVzdCBiZSBpbiB0aGUgcmFuZ2UgPGNvZGU+W3Q8c3ViPjA8L3N1Yj4sIHQ8c3ViPm48L3N1Yj5dPC9jb2RlPiwgd2hlcmUgPGNvZGU+dDxzdWI+MDwvc3ViPjwvY29kZT5cbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpcyB0aGUgZmlyc3QgZWxlbWVudCBpbiB0aGUgYXJyYXkgPGNvZGU+dGltZXM8L2NvZGU+IGFuZCA8Y29kZT50PHN1Yj5uPC9zdWI+PC9jb2RlPiBpcyB0aGUgbGFzdCBlbGVtZW50XG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW4gdGhlIGFycmF5IDxjb2RlPnRpbWVzPC9jb2RlPi5cbiAqL1xuSGVybWl0ZVNwbGluZS5wcm90b3R5cGUuZXZhbHVhdGUgPSBmdW5jdGlvbiAodGltZSwgcmVzdWx0KSB7XG4gIGlmICghZGVmaW5lZChyZXN1bHQpKSB7XG4gICAgcmVzdWx0ID0gbmV3IENhcnRlc2lhbjMoKTtcbiAgfVxuICB2YXIgcG9pbnRzID0gdGhpcy5wb2ludHM7XG4gIHZhciB0aW1lcyA9IHRoaXMudGltZXM7XG4gIHZhciBpblRhbmdlbnRzID0gdGhpcy5pblRhbmdlbnRzO1xuICB2YXIgb3V0VGFuZ2VudHMgPSB0aGlzLm91dFRhbmdlbnRzO1xuXG4gIHZhciBpID0gKHRoaXMuX2xhc3RUaW1lSW5kZXggPSB0aGlzLmZpbmRUaW1lSW50ZXJ2YWwoXG4gICAgdGltZSxcbiAgICB0aGlzLl9sYXN0VGltZUluZGV4XG4gICkpO1xuICB2YXIgdSA9ICh0aW1lIC0gdGltZXNbaV0pIC8gKHRpbWVzW2kgKyAxXSAtIHRpbWVzW2ldKTtcblxuICB2YXIgdGltZVZlYyA9IHNjcmF0Y2hUaW1lVmVjO1xuICB0aW1lVmVjLnogPSB1O1xuICB0aW1lVmVjLnkgPSB1ICogdTtcbiAgdGltZVZlYy54ID0gdGltZVZlYy55ICogdTtcbiAgdGltZVZlYy53ID0gMS4wO1xuXG4gIHZhciBjb2VmcyA9IE1hdHJpeDQubXVsdGlwbHlCeVZlY3RvcihcbiAgICBIZXJtaXRlU3BsaW5lLmhlcm1pdGVDb2VmZmljaWVudE1hdHJpeCxcbiAgICB0aW1lVmVjLFxuICAgIHRpbWVWZWNcbiAgKTtcblxuICByZXN1bHQgPSBDYXJ0ZXNpYW4zLm11bHRpcGx5QnlTY2FsYXIocG9pbnRzW2ldLCBjb2Vmcy54LCByZXN1bHQpO1xuICBDYXJ0ZXNpYW4zLm11bHRpcGx5QnlTY2FsYXIocG9pbnRzW2kgKyAxXSwgY29lZnMueSwgc2NyYXRjaFRlbXApO1xuICBDYXJ0ZXNpYW4zLmFkZChyZXN1bHQsIHNjcmF0Y2hUZW1wLCByZXN1bHQpO1xuICBDYXJ0ZXNpYW4zLm11bHRpcGx5QnlTY2FsYXIob3V0VGFuZ2VudHNbaV0sIGNvZWZzLnosIHNjcmF0Y2hUZW1wKTtcbiAgQ2FydGVzaWFuMy5hZGQocmVzdWx0LCBzY3JhdGNoVGVtcCwgcmVzdWx0KTtcbiAgQ2FydGVzaWFuMy5tdWx0aXBseUJ5U2NhbGFyKGluVGFuZ2VudHNbaV0sIGNvZWZzLncsIHNjcmF0Y2hUZW1wKTtcbiAgcmV0dXJuIENhcnRlc2lhbjMuYWRkKHJlc3VsdCwgc2NyYXRjaFRlbXAsIHJlc3VsdCk7XG59O1xuZXhwb3J0IGRlZmF1bHQgSGVybWl0ZVNwbGluZTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///41399\n')},67662:function(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__){eval('/* harmony import */ var _Check_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(66553);\n/* harmony import */ var _DeveloperError_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(12572);\n\n\n\n/**\n * Hilbert Order helper functions.\n *\n * @namespace HilbertOrder\n */\nvar HilbertOrder = {};\n\n/**\n * Computes the Hilbert index at the given level from 2D coordinates.\n *\n * @param {Number} level The level of the curve\n * @param {Number} x The X coordinate\n * @param {Number} y The Y coordinate\n * @returns {Number} The Hilbert index.\n * @private\n */\nHilbertOrder.encode2D = function (level, x, y) {\n  var n = Math.pow(2, level);\n  //>>includeStart(\'debug\', pragmas.debug);\n  _Check_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].typeOf.number */ .Z.typeOf.number("level", level);\n  _Check_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].typeOf.number */ .Z.typeOf.number("x", x);\n  _Check_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].typeOf.number */ .Z.typeOf.number("y", y);\n  if (level < 1) {\n    throw new _DeveloperError_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .Z("Hilbert level cannot be less than 1.");\n  }\n  if (x < 0 || x >= n || y < 0 || y >= n) {\n    throw new _DeveloperError_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .Z("Invalid coordinates for given level.");\n  }\n  //>>includeEnd(\'debug\');\n\n  var p = {\n    x: x,\n    y: y,\n  };\n  var rx,\n    ry,\n    s,\n    // eslint-disable-next-line no-undef\n    index = BigInt(0);\n\n  for (s = n / 2; s > 0; s /= 2) {\n    rx = (p.x & s) > 0 ? 1 : 0;\n    ry = (p.y & s) > 0 ? 1 : 0;\n    // eslint-disable-next-line no-undef\n    index += BigInt(((3 * rx) ^ ry) * s * s);\n    rotate(n, p, rx, ry);\n  }\n\n  return index;\n};\n\n/**\n * Computes the 2D coordinates from the Hilbert index at the given level.\n *\n * @param {Number} level The level of the curve\n * @param {BigInt} index The Hilbert index\n * @returns {Number[]} An array containing the 2D coordinates ([x, y]) corresponding to the Morton index.\n * @private\n */\nHilbertOrder.decode2D = function (level, index) {\n  //>>includeStart(\'debug\', pragmas.debug);\n  _Check_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].typeOf.number */ .Z.typeOf.number("level", level);\n  _Check_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].typeOf.bigint */ .Z.typeOf.bigint("index", index);\n  if (level < 1) {\n    throw new _DeveloperError_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .Z("Hilbert level cannot be less than 1.");\n  }\n  // eslint-disable-next-line no-undef\n  if (index < BigInt(0) || index >= BigInt(Math.pow(4, level))) {\n    throw new _DeveloperError_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .Z(\n      "Hilbert index exceeds valid maximum for given level."\n    );\n  }\n  //>>includeEnd(\'debug\');\n\n  var n = Math.pow(2, level);\n  var p = {\n    x: 0,\n    y: 0,\n  };\n  var rx, ry, s, t;\n\n  for (s = 1, t = index; s < n; s *= 2) {\n    // eslint-disable-next-line no-undef\n    rx = 1 & Number(t / BigInt(2));\n    // eslint-disable-next-line no-undef\n    ry = 1 & Number(t ^ BigInt(rx));\n    rotate(s, p, rx, ry);\n    p.x += s * rx;\n    p.y += s * ry;\n    // eslint-disable-next-line no-undef\n    t /= BigInt(4);\n  }\n\n  return [p.x, p.y];\n};\n\n/**\n * @private\n */\nfunction rotate(n, p, rx, ry) {\n  if (ry !== 0) {\n    return;\n  }\n\n  if (rx === 1) {\n    p.x = n - 1 - p.x;\n    p.y = n - 1 - p.y;\n  }\n\n  var t = p.x;\n  p.x = p.y;\n  p.y = t;\n}\n\n/* harmony default export */ __webpack_exports__["Z"] = (HilbertOrder);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNjc2NjIuanMiLCJtYXBwaW5ncyI6Ijs7QUFBK0I7QUFDa0I7O0FBRWpEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUUsc0ZBQW1CO0FBQ3JCLEVBQUUsc0ZBQW1CO0FBQ3JCLEVBQUUsc0ZBQW1CO0FBQ3JCO0FBQ0EsY0FBYyxtRUFBYztBQUM1QjtBQUNBO0FBQ0EsY0FBYyxtRUFBYztBQUM1QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxrQkFBa0IsT0FBTztBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLGFBQWEsVUFBVTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUUsc0ZBQW1CO0FBQ3JCLEVBQUUsc0ZBQW1CO0FBQ3JCO0FBQ0EsY0FBYyxtRUFBYztBQUM1QjtBQUNBO0FBQ0E7QUFDQSxjQUFjLG1FQUFjO0FBQzVCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx5QkFBeUIsT0FBTztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHlEQUFlLFlBQVksRUFBQyIsInNvdXJjZXMiOlsid2VicGFjazovL3Z1ZTMtd2VicGFjazUvLi9ub2RlX21vZHVsZXMvY2VzaXVtL1NvdXJjZS9Db3JlL0hpbGJlcnRPcmRlci5qcz85YzU4Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBDaGVjayBmcm9tIFwiLi9DaGVjay5qc1wiO1xuaW1wb3J0IERldmVsb3BlckVycm9yIGZyb20gXCIuL0RldmVsb3BlckVycm9yLmpzXCI7XG5cbi8qKlxuICogSGlsYmVydCBPcmRlciBoZWxwZXIgZnVuY3Rpb25zLlxuICpcbiAqIEBuYW1lc3BhY2UgSGlsYmVydE9yZGVyXG4gKi9cbnZhciBIaWxiZXJ0T3JkZXIgPSB7fTtcblxuLyoqXG4gKiBDb21wdXRlcyB0aGUgSGlsYmVydCBpbmRleCBhdCB0aGUgZ2l2ZW4gbGV2ZWwgZnJvbSAyRCBjb29yZGluYXRlcy5cbiAqXG4gKiBAcGFyYW0ge051bWJlcn0gbGV2ZWwgVGhlIGxldmVsIG9mIHRoZSBjdXJ2ZVxuICogQHBhcmFtIHtOdW1iZXJ9IHggVGhlIFggY29vcmRpbmF0ZVxuICogQHBhcmFtIHtOdW1iZXJ9IHkgVGhlIFkgY29vcmRpbmF0ZVxuICogQHJldHVybnMge051bWJlcn0gVGhlIEhpbGJlcnQgaW5kZXguXG4gKiBAcHJpdmF0ZVxuICovXG5IaWxiZXJ0T3JkZXIuZW5jb2RlMkQgPSBmdW5jdGlvbiAobGV2ZWwsIHgsIHkpIHtcbiAgdmFyIG4gPSBNYXRoLnBvdygyLCBsZXZlbCk7XG4gIC8vPj5pbmNsdWRlU3RhcnQoJ2RlYnVnJywgcHJhZ21hcy5kZWJ1Zyk7XG4gIENoZWNrLnR5cGVPZi5udW1iZXIoXCJsZXZlbFwiLCBsZXZlbCk7XG4gIENoZWNrLnR5cGVPZi5udW1iZXIoXCJ4XCIsIHgpO1xuICBDaGVjay50eXBlT2YubnVtYmVyKFwieVwiLCB5KTtcbiAgaWYgKGxldmVsIDwgMSkge1xuICAgIHRocm93IG5ldyBEZXZlbG9wZXJFcnJvcihcIkhpbGJlcnQgbGV2ZWwgY2Fubm90IGJlIGxlc3MgdGhhbiAxLlwiKTtcbiAgfVxuICBpZiAoeCA8IDAgfHwgeCA+PSBuIHx8IHkgPCAwIHx8IHkgPj0gbikge1xuICAgIHRocm93IG5ldyBEZXZlbG9wZXJFcnJvcihcIkludmFsaWQgY29vcmRpbmF0ZXMgZm9yIGdpdmVuIGxldmVsLlwiKTtcbiAgfVxuICAvLz4+aW5jbHVkZUVuZCgnZGVidWcnKTtcblxuICB2YXIgcCA9IHtcbiAgICB4OiB4LFxuICAgIHk6IHksXG4gIH07XG4gIHZhciByeCxcbiAgICByeSxcbiAgICBzLFxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bmRlZlxuICAgIGluZGV4ID0gQmlnSW50KDApO1xuXG4gIGZvciAocyA9IG4gLyAyOyBzID4gMDsgcyAvPSAyKSB7XG4gICAgcnggPSAocC54ICYgcykgPiAwID8gMSA6IDA7XG4gICAgcnkgPSAocC55ICYgcykgPiAwID8gMSA6IDA7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVuZGVmXG4gICAgaW5kZXggKz0gQmlnSW50KCgoMyAqIHJ4KSBeIHJ5KSAqIHMgKiBzKTtcbiAgICByb3RhdGUobiwgcCwgcngsIHJ5KTtcbiAgfVxuXG4gIHJldHVybiBpbmRleDtcbn07XG5cbi8qKlxuICogQ29tcHV0ZXMgdGhlIDJEIGNvb3JkaW5hdGVzIGZyb20gdGhlIEhpbGJlcnQgaW5kZXggYXQgdGhlIGdpdmVuIGxldmVsLlxuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSBsZXZlbCBUaGUgbGV2ZWwgb2YgdGhlIGN1cnZlXG4gKiBAcGFyYW0ge0JpZ0ludH0gaW5kZXggVGhlIEhpbGJlcnQgaW5kZXhcbiAqIEByZXR1cm5zIHtOdW1iZXJbXX0gQW4gYXJyYXkgY29udGFpbmluZyB0aGUgMkQgY29vcmRpbmF0ZXMgKFt4LCB5XSkgY29ycmVzcG9uZGluZyB0byB0aGUgTW9ydG9uIGluZGV4LlxuICogQHByaXZhdGVcbiAqL1xuSGlsYmVydE9yZGVyLmRlY29kZTJEID0gZnVuY3Rpb24gKGxldmVsLCBpbmRleCkge1xuICAvLz4+aW5jbHVkZVN0YXJ0KCdkZWJ1ZycsIHByYWdtYXMuZGVidWcpO1xuICBDaGVjay50eXBlT2YubnVtYmVyKFwibGV2ZWxcIiwgbGV2ZWwpO1xuICBDaGVjay50eXBlT2YuYmlnaW50KFwiaW5kZXhcIiwgaW5kZXgpO1xuICBpZiAobGV2ZWwgPCAxKSB7XG4gICAgdGhyb3cgbmV3IERldmVsb3BlckVycm9yKFwiSGlsYmVydCBsZXZlbCBjYW5ub3QgYmUgbGVzcyB0aGFuIDEuXCIpO1xuICB9XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bmRlZlxuICBpZiAoaW5kZXggPCBCaWdJbnQoMCkgfHwgaW5kZXggPj0gQmlnSW50KE1hdGgucG93KDQsIGxldmVsKSkpIHtcbiAgICB0aHJvdyBuZXcgRGV2ZWxvcGVyRXJyb3IoXG4gICAgICBcIkhpbGJlcnQgaW5kZXggZXhjZWVkcyB2YWxpZCBtYXhpbXVtIGZvciBnaXZlbiBsZXZlbC5cIlxuICAgICk7XG4gIH1cbiAgLy8+PmluY2x1ZGVFbmQoJ2RlYnVnJyk7XG5cbiAgdmFyIG4gPSBNYXRoLnBvdygyLCBsZXZlbCk7XG4gIHZhciBwID0ge1xuICAgIHg6IDAsXG4gICAgeTogMCxcbiAgfTtcbiAgdmFyIHJ4LCByeSwgcywgdDtcblxuICBmb3IgKHMgPSAxLCB0ID0gaW5kZXg7IHMgPCBuOyBzICo9IDIpIHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW5kZWZcbiAgICByeCA9IDEgJiBOdW1iZXIodCAvIEJpZ0ludCgyKSk7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVuZGVmXG4gICAgcnkgPSAxICYgTnVtYmVyKHQgXiBCaWdJbnQocngpKTtcbiAgICByb3RhdGUocywgcCwgcngsIHJ5KTtcbiAgICBwLnggKz0gcyAqIHJ4O1xuICAgIHAueSArPSBzICogcnk7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVuZGVmXG4gICAgdCAvPSBCaWdJbnQoNCk7XG4gIH1cblxuICByZXR1cm4gW3AueCwgcC55XTtcbn07XG5cbi8qKlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gcm90YXRlKG4sIHAsIHJ4LCByeSkge1xuICBpZiAocnkgIT09IDApIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBpZiAocnggPT09IDEpIHtcbiAgICBwLnggPSBuIC0gMSAtIHAueDtcbiAgICBwLnkgPSBuIC0gMSAtIHAueTtcbiAgfVxuXG4gIHZhciB0ID0gcC54O1xuICBwLnggPSBwLnk7XG4gIHAueSA9IHQ7XG59XG5cbmV4cG9ydCBkZWZhdWx0IEhpbGJlcnRPcmRlcjtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///67662\n')},41999:function(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__){eval('\n// EXPORTS\n__webpack_require__.d(__webpack_exports__, {\n  "Z": function() { return /* binding */ Core_Iau2000Orientation; }\n});\n\n// EXTERNAL MODULE: ./node_modules/cesium/Source/Core/defined.js\nvar defined = __webpack_require__(82982);\n;// CONCATENATED MODULE: ./node_modules/cesium/Source/Core/IauOrientationParameters.js\n/**\n * A structure containing the orientation data computed at a particular time. The data\n * represents the direction of the pole of rotation and the rotation about that pole.\n * <p>\n * These parameters correspond to the parameters in the Report from the IAU/IAG Working Group\n * except that they are expressed in radians.\n * </p>\n *\n * @namespace IauOrientationParameters\n *\n * @private\n */\nfunction IauOrientationParameters(\n  rightAscension,\n  declination,\n  rotation,\n  rotationRate\n) {\n  /**\n   * The right ascension of the north pole of the body with respect to\n   * the International Celestial Reference Frame, in radians.\n   * @type {Number}\n   *\n   * @private\n   */\n  this.rightAscension = rightAscension;\n\n  /**\n   * The declination of the north pole of the body with respect to\n   * the International Celestial Reference Frame, in radians.\n   * @type {Number}\n   *\n   * @private\n   */\n  this.declination = declination;\n\n  /**\n   * The rotation about the north pole used to align a set of axes with\n   * the meridian defined by the IAU report, in radians.\n   * @type {Number}\n   *\n   * @private\n   */\n  this.rotation = rotation;\n\n  /**\n   * The instantaneous rotation rate about the north pole, in radians per second.\n   * @type {Number}\n   *\n   * @private\n   */\n  this.rotationRate = rotationRate;\n}\n/* harmony default export */ var Core_IauOrientationParameters = (IauOrientationParameters);\n\n// EXTERNAL MODULE: ./node_modules/cesium/Source/Core/JulianDate.js\nvar JulianDate = __webpack_require__(55293);\n// EXTERNAL MODULE: ./node_modules/cesium/Source/Core/Math.js\nvar Core_Math = __webpack_require__(99417);\n// EXTERNAL MODULE: ./node_modules/cesium/Source/Core/TimeConstants.js\nvar TimeConstants = __webpack_require__(4877);\n;// CONCATENATED MODULE: ./node_modules/cesium/Source/Core/Iau2000Orientation.js\n\n\n\n\n\n\n/**\n * This is a collection of the orientation information available for central bodies.\n * The data comes from the Report of the IAU/IAG Working Group on Cartographic\n * Coordinates and Rotational Elements: 2000.\n *\n * @namespace Iau2000Orientation\n *\n * @private\n */\nvar Iau2000Orientation = {};\n\nvar TdtMinusTai = 32.184;\nvar J2000d = 2451545.0;\n\nvar c1 = -0.0529921;\nvar c2 = -0.1059842;\nvar c3 = 13.0120009;\nvar c4 = 13.3407154;\nvar c5 = 0.9856003;\nvar c6 = 26.4057084;\nvar c7 = 13.064993;\nvar c8 = 0.3287146;\nvar c9 = 1.7484877;\nvar c10 = -0.1589763;\nvar c11 = 0.0036096;\nvar c12 = 0.1643573;\nvar c13 = 12.9590088;\nvar dateTT = new JulianDate/* default */.Z();\n\n/**\n * Compute the orientation parameters for the Moon.\n *\n * @param {JulianDate} [date=JulianDate.now()] The date to evaluate the parameters.\n * @param {IauOrientationParameters} [result] The object onto which to store the result.\n * @returns {IauOrientationParameters} The modified result parameter or a new instance representing the orientation of the Earth\'s Moon.\n * @private\n */\nIau2000Orientation.ComputeMoon = function (date, result) {\n  if (!(0,defined/* default */.Z)(date)) {\n    date = JulianDate/* default.now */.Z.now();\n  }\n\n  dateTT = JulianDate/* default.addSeconds */.Z.addSeconds(date, TdtMinusTai, dateTT);\n  var d = JulianDate/* default.totalDays */.Z.totalDays(dateTT) - J2000d;\n  var T = d / TimeConstants/* default.DAYS_PER_JULIAN_CENTURY */.Z.DAYS_PER_JULIAN_CENTURY;\n\n  var E1 = (125.045 + c1 * d) * Core_Math/* default.RADIANS_PER_DEGREE */.Z.RADIANS_PER_DEGREE;\n  var E2 = (250.089 + c2 * d) * Core_Math/* default.RADIANS_PER_DEGREE */.Z.RADIANS_PER_DEGREE;\n  var E3 = (260.008 + c3 * d) * Core_Math/* default.RADIANS_PER_DEGREE */.Z.RADIANS_PER_DEGREE;\n  var E4 = (176.625 + c4 * d) * Core_Math/* default.RADIANS_PER_DEGREE */.Z.RADIANS_PER_DEGREE;\n  var E5 = (357.529 + c5 * d) * Core_Math/* default.RADIANS_PER_DEGREE */.Z.RADIANS_PER_DEGREE;\n  var E6 = (311.589 + c6 * d) * Core_Math/* default.RADIANS_PER_DEGREE */.Z.RADIANS_PER_DEGREE;\n  var E7 = (134.963 + c7 * d) * Core_Math/* default.RADIANS_PER_DEGREE */.Z.RADIANS_PER_DEGREE;\n  var E8 = (276.617 + c8 * d) * Core_Math/* default.RADIANS_PER_DEGREE */.Z.RADIANS_PER_DEGREE;\n  var E9 = (34.226 + c9 * d) * Core_Math/* default.RADIANS_PER_DEGREE */.Z.RADIANS_PER_DEGREE;\n  var E10 = (15.134 + c10 * d) * Core_Math/* default.RADIANS_PER_DEGREE */.Z.RADIANS_PER_DEGREE;\n  var E11 = (119.743 + c11 * d) * Core_Math/* default.RADIANS_PER_DEGREE */.Z.RADIANS_PER_DEGREE;\n  var E12 = (239.961 + c12 * d) * Core_Math/* default.RADIANS_PER_DEGREE */.Z.RADIANS_PER_DEGREE;\n  var E13 = (25.053 + c13 * d) * Core_Math/* default.RADIANS_PER_DEGREE */.Z.RADIANS_PER_DEGREE;\n\n  var sinE1 = Math.sin(E1);\n  var sinE2 = Math.sin(E2);\n  var sinE3 = Math.sin(E3);\n  var sinE4 = Math.sin(E4);\n  var sinE5 = Math.sin(E5);\n  var sinE6 = Math.sin(E6);\n  var sinE7 = Math.sin(E7);\n  var sinE8 = Math.sin(E8);\n  var sinE9 = Math.sin(E9);\n  var sinE10 = Math.sin(E10);\n  var sinE11 = Math.sin(E11);\n  var sinE12 = Math.sin(E12);\n  var sinE13 = Math.sin(E13);\n\n  var cosE1 = Math.cos(E1);\n  var cosE2 = Math.cos(E2);\n  var cosE3 = Math.cos(E3);\n  var cosE4 = Math.cos(E4);\n  var cosE5 = Math.cos(E5);\n  var cosE6 = Math.cos(E6);\n  var cosE7 = Math.cos(E7);\n  var cosE8 = Math.cos(E8);\n  var cosE9 = Math.cos(E9);\n  var cosE10 = Math.cos(E10);\n  var cosE11 = Math.cos(E11);\n  var cosE12 = Math.cos(E12);\n  var cosE13 = Math.cos(E13);\n\n  var rightAscension =\n    (269.9949 +\n      0.0031 * T -\n      3.8787 * sinE1 -\n      0.1204 * sinE2 +\n      0.07 * sinE3 -\n      0.0172 * sinE4 +\n      0.0072 * sinE6 -\n      0.0052 * sinE10 +\n      0.0043 * sinE13) *\n    Core_Math/* default.RADIANS_PER_DEGREE */.Z.RADIANS_PER_DEGREE;\n  var declination =\n    (66.5392 +\n      0.013 * T +\n      1.5419 * cosE1 +\n      0.0239 * cosE2 -\n      0.0278 * cosE3 +\n      0.0068 * cosE4 -\n      0.0029 * cosE6 +\n      0.0009 * cosE7 +\n      0.0008 * cosE10 -\n      0.0009 * cosE13) *\n    Core_Math/* default.RADIANS_PER_DEGREE */.Z.RADIANS_PER_DEGREE;\n  var rotation =\n    (38.3213 +\n      13.17635815 * d -\n      1.4e-12 * d * d +\n      3.561 * sinE1 +\n      0.1208 * sinE2 -\n      0.0642 * sinE3 +\n      0.0158 * sinE4 +\n      0.0252 * sinE5 -\n      0.0066 * sinE6 -\n      0.0047 * sinE7 -\n      0.0046 * sinE8 +\n      0.0028 * sinE9 +\n      0.0052 * sinE10 +\n      0.004 * sinE11 +\n      0.0019 * sinE12 -\n      0.0044 * sinE13) *\n    Core_Math/* default.RADIANS_PER_DEGREE */.Z.RADIANS_PER_DEGREE;\n\n  var rotationRate =\n    ((13.17635815 -\n      1.4e-12 * (2.0 * d) +\n      3.561 * cosE1 * c1 +\n      0.1208 * cosE2 * c2 -\n      0.0642 * cosE3 * c3 +\n      0.0158 * cosE4 * c4 +\n      0.0252 * cosE5 * c5 -\n      0.0066 * cosE6 * c6 -\n      0.0047 * cosE7 * c7 -\n      0.0046 * cosE8 * c8 +\n      0.0028 * cosE9 * c9 +\n      0.0052 * cosE10 * c10 +\n      0.004 * cosE11 * c11 +\n      0.0019 * cosE12 * c12 -\n      0.0044 * cosE13 * c13) /\n      86400.0) *\n    Core_Math/* default.RADIANS_PER_DEGREE */.Z.RADIANS_PER_DEGREE;\n\n  if (!(0,defined/* default */.Z)(result)) {\n    result = new Core_IauOrientationParameters();\n  }\n\n  result.rightAscension = rightAscension;\n  result.declination = declination;\n  result.rotation = rotation;\n  result.rotationRate = rotationRate;\n\n  return result;\n};\n/* harmony default export */ var Core_Iau2000Orientation = (Iau2000Orientation);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNDE5OTkuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0VBQWUsd0JBQXdCLEVBQUM7Ozs7Ozs7OztBQ3JETDtBQUNrQztBQUM1QjtBQUNOO0FBQ1k7O0FBRS9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIseUJBQVU7O0FBRTNCO0FBQ0E7QUFDQTtBQUNBLFdBQVcsWUFBWTtBQUN2QixXQUFXLDBCQUEwQjtBQUNyQyxhQUFhLDBCQUEwQjtBQUN2QztBQUNBO0FBQ0E7QUFDQSxPQUFPLDBCQUFPO0FBQ2QsV0FBVyxpQ0FBYztBQUN6Qjs7QUFFQSxXQUFXLCtDQUFxQjtBQUNoQyxVQUFVLDZDQUFvQjtBQUM5QixjQUFjLDRFQUFxQzs7QUFFbkQsZ0NBQWdDLDhEQUE2QjtBQUM3RCxnQ0FBZ0MsOERBQTZCO0FBQzdELGdDQUFnQyw4REFBNkI7QUFDN0QsZ0NBQWdDLDhEQUE2QjtBQUM3RCxnQ0FBZ0MsOERBQTZCO0FBQzdELGdDQUFnQyw4REFBNkI7QUFDN0QsZ0NBQWdDLDhEQUE2QjtBQUM3RCxnQ0FBZ0MsOERBQTZCO0FBQzdELCtCQUErQiw4REFBNkI7QUFDNUQsaUNBQWlDLDhEQUE2QjtBQUM5RCxrQ0FBa0MsOERBQTZCO0FBQy9ELGtDQUFrQyw4REFBNkI7QUFDL0QsaUNBQWlDLDhEQUE2Qjs7QUFFOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLDhEQUE2QjtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSw4REFBNkI7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUksOERBQTZCOztBQUVqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSw4REFBNkI7O0FBRWpDLE9BQU8sMEJBQU87QUFDZCxpQkFBaUIsNkJBQXdCO0FBQ3pDOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSw0REFBZSxrQkFBa0IsRUFBQyIsInNvdXJjZXMiOlsid2VicGFjazovL3Z1ZTMtd2VicGFjazUvLi9ub2RlX21vZHVsZXMvY2VzaXVtL1NvdXJjZS9Db3JlL0lhdU9yaWVudGF0aW9uUGFyYW1ldGVycy5qcz9kMTljIiwid2VicGFjazovL3Z1ZTMtd2VicGFjazUvLi9ub2RlX21vZHVsZXMvY2VzaXVtL1NvdXJjZS9Db3JlL0lhdTIwMDBPcmllbnRhdGlvbi5qcz9iMGNkIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQSBzdHJ1Y3R1cmUgY29udGFpbmluZyB0aGUgb3JpZW50YXRpb24gZGF0YSBjb21wdXRlZCBhdCBhIHBhcnRpY3VsYXIgdGltZS4gVGhlIGRhdGFcbiAqIHJlcHJlc2VudHMgdGhlIGRpcmVjdGlvbiBvZiB0aGUgcG9sZSBvZiByb3RhdGlvbiBhbmQgdGhlIHJvdGF0aW9uIGFib3V0IHRoYXQgcG9sZS5cbiAqIDxwPlxuICogVGhlc2UgcGFyYW1ldGVycyBjb3JyZXNwb25kIHRvIHRoZSBwYXJhbWV0ZXJzIGluIHRoZSBSZXBvcnQgZnJvbSB0aGUgSUFVL0lBRyBXb3JraW5nIEdyb3VwXG4gKiBleGNlcHQgdGhhdCB0aGV5IGFyZSBleHByZXNzZWQgaW4gcmFkaWFucy5cbiAqIDwvcD5cbiAqXG4gKiBAbmFtZXNwYWNlIElhdU9yaWVudGF0aW9uUGFyYW1ldGVyc1xuICpcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIElhdU9yaWVudGF0aW9uUGFyYW1ldGVycyhcbiAgcmlnaHRBc2NlbnNpb24sXG4gIGRlY2xpbmF0aW9uLFxuICByb3RhdGlvbixcbiAgcm90YXRpb25SYXRlXG4pIHtcbiAgLyoqXG4gICAqIFRoZSByaWdodCBhc2NlbnNpb24gb2YgdGhlIG5vcnRoIHBvbGUgb2YgdGhlIGJvZHkgd2l0aCByZXNwZWN0IHRvXG4gICAqIHRoZSBJbnRlcm5hdGlvbmFsIENlbGVzdGlhbCBSZWZlcmVuY2UgRnJhbWUsIGluIHJhZGlhbnMuXG4gICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICB0aGlzLnJpZ2h0QXNjZW5zaW9uID0gcmlnaHRBc2NlbnNpb247XG5cbiAgLyoqXG4gICAqIFRoZSBkZWNsaW5hdGlvbiBvZiB0aGUgbm9ydGggcG9sZSBvZiB0aGUgYm9keSB3aXRoIHJlc3BlY3QgdG9cbiAgICogdGhlIEludGVybmF0aW9uYWwgQ2VsZXN0aWFsIFJlZmVyZW5jZSBGcmFtZSwgaW4gcmFkaWFucy5cbiAgICogQHR5cGUge051bWJlcn1cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICovXG4gIHRoaXMuZGVjbGluYXRpb24gPSBkZWNsaW5hdGlvbjtcblxuICAvKipcbiAgICogVGhlIHJvdGF0aW9uIGFib3V0IHRoZSBub3J0aCBwb2xlIHVzZWQgdG8gYWxpZ24gYSBzZXQgb2YgYXhlcyB3aXRoXG4gICAqIHRoZSBtZXJpZGlhbiBkZWZpbmVkIGJ5IHRoZSBJQVUgcmVwb3J0LCBpbiByYWRpYW5zLlxuICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgdGhpcy5yb3RhdGlvbiA9IHJvdGF0aW9uO1xuXG4gIC8qKlxuICAgKiBUaGUgaW5zdGFudGFuZW91cyByb3RhdGlvbiByYXRlIGFib3V0IHRoZSBub3J0aCBwb2xlLCBpbiByYWRpYW5zIHBlciBzZWNvbmQuXG4gICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICB0aGlzLnJvdGF0aW9uUmF0ZSA9IHJvdGF0aW9uUmF0ZTtcbn1cbmV4cG9ydCBkZWZhdWx0IElhdU9yaWVudGF0aW9uUGFyYW1ldGVycztcbiIsImltcG9ydCBkZWZpbmVkIGZyb20gXCIuL2RlZmluZWQuanNcIjtcbmltcG9ydCBJYXVPcmllbnRhdGlvblBhcmFtZXRlcnMgZnJvbSBcIi4vSWF1T3JpZW50YXRpb25QYXJhbWV0ZXJzLmpzXCI7XG5pbXBvcnQgSnVsaWFuRGF0ZSBmcm9tIFwiLi9KdWxpYW5EYXRlLmpzXCI7XG5pbXBvcnQgQ2VzaXVtTWF0aCBmcm9tIFwiLi9NYXRoLmpzXCI7XG5pbXBvcnQgVGltZUNvbnN0YW50cyBmcm9tIFwiLi9UaW1lQ29uc3RhbnRzLmpzXCI7XG5cbi8qKlxuICogVGhpcyBpcyBhIGNvbGxlY3Rpb24gb2YgdGhlIG9yaWVudGF0aW9uIGluZm9ybWF0aW9uIGF2YWlsYWJsZSBmb3IgY2VudHJhbCBib2RpZXMuXG4gKiBUaGUgZGF0YSBjb21lcyBmcm9tIHRoZSBSZXBvcnQgb2YgdGhlIElBVS9JQUcgV29ya2luZyBHcm91cCBvbiBDYXJ0b2dyYXBoaWNcbiAqIENvb3JkaW5hdGVzIGFuZCBSb3RhdGlvbmFsIEVsZW1lbnRzOiAyMDAwLlxuICpcbiAqIEBuYW1lc3BhY2UgSWF1MjAwME9yaWVudGF0aW9uXG4gKlxuICogQHByaXZhdGVcbiAqL1xudmFyIElhdTIwMDBPcmllbnRhdGlvbiA9IHt9O1xuXG52YXIgVGR0TWludXNUYWkgPSAzMi4xODQ7XG52YXIgSjIwMDBkID0gMjQ1MTU0NS4wO1xuXG52YXIgYzEgPSAtMC4wNTI5OTIxO1xudmFyIGMyID0gLTAuMTA1OTg0MjtcbnZhciBjMyA9IDEzLjAxMjAwMDk7XG52YXIgYzQgPSAxMy4zNDA3MTU0O1xudmFyIGM1ID0gMC45ODU2MDAzO1xudmFyIGM2ID0gMjYuNDA1NzA4NDtcbnZhciBjNyA9IDEzLjA2NDk5MztcbnZhciBjOCA9IDAuMzI4NzE0NjtcbnZhciBjOSA9IDEuNzQ4NDg3NztcbnZhciBjMTAgPSAtMC4xNTg5NzYzO1xudmFyIGMxMSA9IDAuMDAzNjA5NjtcbnZhciBjMTIgPSAwLjE2NDM1NzM7XG52YXIgYzEzID0gMTIuOTU5MDA4ODtcbnZhciBkYXRlVFQgPSBuZXcgSnVsaWFuRGF0ZSgpO1xuXG4vKipcbiAqIENvbXB1dGUgdGhlIG9yaWVudGF0aW9uIHBhcmFtZXRlcnMgZm9yIHRoZSBNb29uLlxuICpcbiAqIEBwYXJhbSB7SnVsaWFuRGF0ZX0gW2RhdGU9SnVsaWFuRGF0ZS5ub3coKV0gVGhlIGRhdGUgdG8gZXZhbHVhdGUgdGhlIHBhcmFtZXRlcnMuXG4gKiBAcGFyYW0ge0lhdU9yaWVudGF0aW9uUGFyYW1ldGVyc30gW3Jlc3VsdF0gVGhlIG9iamVjdCBvbnRvIHdoaWNoIHRvIHN0b3JlIHRoZSByZXN1bHQuXG4gKiBAcmV0dXJucyB7SWF1T3JpZW50YXRpb25QYXJhbWV0ZXJzfSBUaGUgbW9kaWZpZWQgcmVzdWx0IHBhcmFtZXRlciBvciBhIG5ldyBpbnN0YW5jZSByZXByZXNlbnRpbmcgdGhlIG9yaWVudGF0aW9uIG9mIHRoZSBFYXJ0aCdzIE1vb24uXG4gKiBAcHJpdmF0ZVxuICovXG5JYXUyMDAwT3JpZW50YXRpb24uQ29tcHV0ZU1vb24gPSBmdW5jdGlvbiAoZGF0ZSwgcmVzdWx0KSB7XG4gIGlmICghZGVmaW5lZChkYXRlKSkge1xuICAgIGRhdGUgPSBKdWxpYW5EYXRlLm5vdygpO1xuICB9XG5cbiAgZGF0ZVRUID0gSnVsaWFuRGF0ZS5hZGRTZWNvbmRzKGRhdGUsIFRkdE1pbnVzVGFpLCBkYXRlVFQpO1xuICB2YXIgZCA9IEp1bGlhbkRhdGUudG90YWxEYXlzKGRhdGVUVCkgLSBKMjAwMGQ7XG4gIHZhciBUID0gZCAvIFRpbWVDb25zdGFudHMuREFZU19QRVJfSlVMSUFOX0NFTlRVUlk7XG5cbiAgdmFyIEUxID0gKDEyNS4wNDUgKyBjMSAqIGQpICogQ2VzaXVtTWF0aC5SQURJQU5TX1BFUl9ERUdSRUU7XG4gIHZhciBFMiA9ICgyNTAuMDg5ICsgYzIgKiBkKSAqIENlc2l1bU1hdGguUkFESUFOU19QRVJfREVHUkVFO1xuICB2YXIgRTMgPSAoMjYwLjAwOCArIGMzICogZCkgKiBDZXNpdW1NYXRoLlJBRElBTlNfUEVSX0RFR1JFRTtcbiAgdmFyIEU0ID0gKDE3Ni42MjUgKyBjNCAqIGQpICogQ2VzaXVtTWF0aC5SQURJQU5TX1BFUl9ERUdSRUU7XG4gIHZhciBFNSA9ICgzNTcuNTI5ICsgYzUgKiBkKSAqIENlc2l1bU1hdGguUkFESUFOU19QRVJfREVHUkVFO1xuICB2YXIgRTYgPSAoMzExLjU4OSArIGM2ICogZCkgKiBDZXNpdW1NYXRoLlJBRElBTlNfUEVSX0RFR1JFRTtcbiAgdmFyIEU3ID0gKDEzNC45NjMgKyBjNyAqIGQpICogQ2VzaXVtTWF0aC5SQURJQU5TX1BFUl9ERUdSRUU7XG4gIHZhciBFOCA9ICgyNzYuNjE3ICsgYzggKiBkKSAqIENlc2l1bU1hdGguUkFESUFOU19QRVJfREVHUkVFO1xuICB2YXIgRTkgPSAoMzQuMjI2ICsgYzkgKiBkKSAqIENlc2l1bU1hdGguUkFESUFOU19QRVJfREVHUkVFO1xuICB2YXIgRTEwID0gKDE1LjEzNCArIGMxMCAqIGQpICogQ2VzaXVtTWF0aC5SQURJQU5TX1BFUl9ERUdSRUU7XG4gIHZhciBFMTEgPSAoMTE5Ljc0MyArIGMxMSAqIGQpICogQ2VzaXVtTWF0aC5SQURJQU5TX1BFUl9ERUdSRUU7XG4gIHZhciBFMTIgPSAoMjM5Ljk2MSArIGMxMiAqIGQpICogQ2VzaXVtTWF0aC5SQURJQU5TX1BFUl9ERUdSRUU7XG4gIHZhciBFMTMgPSAoMjUuMDUzICsgYzEzICogZCkgKiBDZXNpdW1NYXRoLlJBRElBTlNfUEVSX0RFR1JFRTtcblxuICB2YXIgc2luRTEgPSBNYXRoLnNpbihFMSk7XG4gIHZhciBzaW5FMiA9IE1hdGguc2luKEUyKTtcbiAgdmFyIHNpbkUzID0gTWF0aC5zaW4oRTMpO1xuICB2YXIgc2luRTQgPSBNYXRoLnNpbihFNCk7XG4gIHZhciBzaW5FNSA9IE1hdGguc2luKEU1KTtcbiAgdmFyIHNpbkU2ID0gTWF0aC5zaW4oRTYpO1xuICB2YXIgc2luRTcgPSBNYXRoLnNpbihFNyk7XG4gIHZhciBzaW5FOCA9IE1hdGguc2luKEU4KTtcbiAgdmFyIHNpbkU5ID0gTWF0aC5zaW4oRTkpO1xuICB2YXIgc2luRTEwID0gTWF0aC5zaW4oRTEwKTtcbiAgdmFyIHNpbkUxMSA9IE1hdGguc2luKEUxMSk7XG4gIHZhciBzaW5FMTIgPSBNYXRoLnNpbihFMTIpO1xuICB2YXIgc2luRTEzID0gTWF0aC5zaW4oRTEzKTtcblxuICB2YXIgY29zRTEgPSBNYXRoLmNvcyhFMSk7XG4gIHZhciBjb3NFMiA9IE1hdGguY29zKEUyKTtcbiAgdmFyIGNvc0UzID0gTWF0aC5jb3MoRTMpO1xuICB2YXIgY29zRTQgPSBNYXRoLmNvcyhFNCk7XG4gIHZhciBjb3NFNSA9IE1hdGguY29zKEU1KTtcbiAgdmFyIGNvc0U2ID0gTWF0aC5jb3MoRTYpO1xuICB2YXIgY29zRTcgPSBNYXRoLmNvcyhFNyk7XG4gIHZhciBjb3NFOCA9IE1hdGguY29zKEU4KTtcbiAgdmFyIGNvc0U5ID0gTWF0aC5jb3MoRTkpO1xuICB2YXIgY29zRTEwID0gTWF0aC5jb3MoRTEwKTtcbiAgdmFyIGNvc0UxMSA9IE1hdGguY29zKEUxMSk7XG4gIHZhciBjb3NFMTIgPSBNYXRoLmNvcyhFMTIpO1xuICB2YXIgY29zRTEzID0gTWF0aC5jb3MoRTEzKTtcblxuICB2YXIgcmlnaHRBc2NlbnNpb24gPVxuICAgICgyNjkuOTk0OSArXG4gICAgICAwLjAwMzEgKiBUIC1cbiAgICAgIDMuODc4NyAqIHNpbkUxIC1cbiAgICAgIDAuMTIwNCAqIHNpbkUyICtcbiAgICAgIDAuMDcgKiBzaW5FMyAtXG4gICAgICAwLjAxNzIgKiBzaW5FNCArXG4gICAgICAwLjAwNzIgKiBzaW5FNiAtXG4gICAgICAwLjAwNTIgKiBzaW5FMTAgK1xuICAgICAgMC4wMDQzICogc2luRTEzKSAqXG4gICAgQ2VzaXVtTWF0aC5SQURJQU5TX1BFUl9ERUdSRUU7XG4gIHZhciBkZWNsaW5hdGlvbiA9XG4gICAgKDY2LjUzOTIgK1xuICAgICAgMC4wMTMgKiBUICtcbiAgICAgIDEuNTQxOSAqIGNvc0UxICtcbiAgICAgIDAuMDIzOSAqIGNvc0UyIC1cbiAgICAgIDAuMDI3OCAqIGNvc0UzICtcbiAgICAgIDAuMDA2OCAqIGNvc0U0IC1cbiAgICAgIDAuMDAyOSAqIGNvc0U2ICtcbiAgICAgIDAuMDAwOSAqIGNvc0U3ICtcbiAgICAgIDAuMDAwOCAqIGNvc0UxMCAtXG4gICAgICAwLjAwMDkgKiBjb3NFMTMpICpcbiAgICBDZXNpdW1NYXRoLlJBRElBTlNfUEVSX0RFR1JFRTtcbiAgdmFyIHJvdGF0aW9uID1cbiAgICAoMzguMzIxMyArXG4gICAgICAxMy4xNzYzNTgxNSAqIGQgLVxuICAgICAgMS40ZS0xMiAqIGQgKiBkICtcbiAgICAgIDMuNTYxICogc2luRTEgK1xuICAgICAgMC4xMjA4ICogc2luRTIgLVxuICAgICAgMC4wNjQyICogc2luRTMgK1xuICAgICAgMC4wMTU4ICogc2luRTQgK1xuICAgICAgMC4wMjUyICogc2luRTUgLVxuICAgICAgMC4wMDY2ICogc2luRTYgLVxuICAgICAgMC4wMDQ3ICogc2luRTcgLVxuICAgICAgMC4wMDQ2ICogc2luRTggK1xuICAgICAgMC4wMDI4ICogc2luRTkgK1xuICAgICAgMC4wMDUyICogc2luRTEwICtcbiAgICAgIDAuMDA0ICogc2luRTExICtcbiAgICAgIDAuMDAxOSAqIHNpbkUxMiAtXG4gICAgICAwLjAwNDQgKiBzaW5FMTMpICpcbiAgICBDZXNpdW1NYXRoLlJBRElBTlNfUEVSX0RFR1JFRTtcblxuICB2YXIgcm90YXRpb25SYXRlID1cbiAgICAoKDEzLjE3NjM1ODE1IC1cbiAgICAgIDEuNGUtMTIgKiAoMi4wICogZCkgK1xuICAgICAgMy41NjEgKiBjb3NFMSAqIGMxICtcbiAgICAgIDAuMTIwOCAqIGNvc0UyICogYzIgLVxuICAgICAgMC4wNjQyICogY29zRTMgKiBjMyArXG4gICAgICAwLjAxNTggKiBjb3NFNCAqIGM0ICtcbiAgICAgIDAuMDI1MiAqIGNvc0U1ICogYzUgLVxuICAgICAgMC4wMDY2ICogY29zRTYgKiBjNiAtXG4gICAgICAwLjAwNDcgKiBjb3NFNyAqIGM3IC1cbiAgICAgIDAuMDA0NiAqIGNvc0U4ICogYzggK1xuICAgICAgMC4wMDI4ICogY29zRTkgKiBjOSArXG4gICAgICAwLjAwNTIgKiBjb3NFMTAgKiBjMTAgK1xuICAgICAgMC4wMDQgKiBjb3NFMTEgKiBjMTEgK1xuICAgICAgMC4wMDE5ICogY29zRTEyICogYzEyIC1cbiAgICAgIDAuMDA0NCAqIGNvc0UxMyAqIGMxMykgL1xuICAgICAgODY0MDAuMCkgKlxuICAgIENlc2l1bU1hdGguUkFESUFOU19QRVJfREVHUkVFO1xuXG4gIGlmICghZGVmaW5lZChyZXN1bHQpKSB7XG4gICAgcmVzdWx0ID0gbmV3IElhdU9yaWVudGF0aW9uUGFyYW1ldGVycygpO1xuICB9XG5cbiAgcmVzdWx0LnJpZ2h0QXNjZW5zaW9uID0gcmlnaHRBc2NlbnNpb247XG4gIHJlc3VsdC5kZWNsaW5hdGlvbiA9IGRlY2xpbmF0aW9uO1xuICByZXN1bHQucm90YXRpb24gPSByb3RhdGlvbjtcbiAgcmVzdWx0LnJvdGF0aW9uUmF0ZSA9IHJvdGF0aW9uUmF0ZTtcblxuICByZXR1cm4gcmVzdWx0O1xufTtcbmV4cG9ydCBkZWZhdWx0IElhdTIwMDBPcmllbnRhdGlvbjtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///41999\n')},27846:function(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__){eval('/* harmony import */ var _ThirdParty_when_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(13222);\n/* harmony import */ var _buildModuleUrl_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(72000);\n/* harmony import */ var _defaultValue_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(62200);\n/* harmony import */ var _defined_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(82982);\n/* harmony import */ var _Iau2006XysSample_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(50048);\n/* harmony import */ var _JulianDate_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(55293);\n/* harmony import */ var _Resource_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(68985);\n/* harmony import */ var _TimeStandard_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(13098);\n\n\n\n\n\n\n\n\n\n/**\n * A set of IAU2006 XYS data that is used to evaluate the transformation between the International\n * Celestial Reference Frame (ICRF) and the International Terrestrial Reference Frame (ITRF).\n *\n * @alias Iau2006XysData\n * @constructor\n *\n * @param {Object} [options] Object with the following properties:\n * @param {Resource|String} [options.xysFileUrlTemplate=\'Assets/IAU2006_XYS/IAU2006_XYS_{0}.json\'] A template URL for obtaining the XYS data.  In the template,\n *                 `{0}` will be replaced with the file index.\n * @param {Number} [options.interpolationOrder=9] The order of interpolation to perform on the XYS data.\n * @param {Number} [options.sampleZeroJulianEphemerisDate=2442396.5] The Julian ephemeris date (JED) of the\n *                 first XYS sample.\n * @param {Number} [options.stepSizeDays=1.0] The step size, in days, between successive XYS samples.\n * @param {Number} [options.samplesPerXysFile=1000] The number of samples in each XYS file.\n * @param {Number} [options.totalSamples=27426] The total number of samples in all XYS files.\n *\n * @private\n */\nfunction Iau2006XysData(options) {\n  options = (0,_defaultValue_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"] */ .Z)(options, _defaultValue_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"].EMPTY_OBJECT */ .Z.EMPTY_OBJECT);\n\n  this._xysFileUrlTemplate = _Resource_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"].createIfNeeded */ .Z.createIfNeeded(\n    options.xysFileUrlTemplate\n  );\n  this._interpolationOrder = (0,_defaultValue_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"] */ .Z)(options.interpolationOrder, 9);\n  this._sampleZeroJulianEphemerisDate = (0,_defaultValue_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"] */ .Z)(\n    options.sampleZeroJulianEphemerisDate,\n    2442396.5\n  );\n  this._sampleZeroDateTT = new _JulianDate_js__WEBPACK_IMPORTED_MODULE_3__/* ["default"] */ .Z(\n    this._sampleZeroJulianEphemerisDate,\n    0.0,\n    _TimeStandard_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"].TAI */ .Z.TAI\n  );\n  this._stepSizeDays = (0,_defaultValue_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"] */ .Z)(options.stepSizeDays, 1.0);\n  this._samplesPerXysFile = (0,_defaultValue_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"] */ .Z)(options.samplesPerXysFile, 1000);\n  this._totalSamples = (0,_defaultValue_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"] */ .Z)(options.totalSamples, 27426);\n  this._samples = new Array(this._totalSamples * 3);\n  this._chunkDownloadsInProgress = [];\n\n  var order = this._interpolationOrder;\n\n  // Compute denominators and X values for interpolation.\n  var denom = (this._denominators = new Array(order + 1));\n  var xTable = (this._xTable = new Array(order + 1));\n\n  var stepN = Math.pow(this._stepSizeDays, order);\n\n  for (var i = 0; i <= order; ++i) {\n    denom[i] = stepN;\n    xTable[i] = i * this._stepSizeDays;\n\n    for (var j = 0; j <= order; ++j) {\n      if (j !== i) {\n        denom[i] *= i - j;\n      }\n    }\n\n    denom[i] = 1.0 / denom[i];\n  }\n\n  // Allocate scratch arrays for interpolation.\n  this._work = new Array(order + 1);\n  this._coef = new Array(order + 1);\n}\n\nvar julianDateScratch = new _JulianDate_js__WEBPACK_IMPORTED_MODULE_3__/* ["default"] */ .Z(0, 0.0, _TimeStandard_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"].TAI */ .Z.TAI);\n\nfunction getDaysSinceEpoch(xys, dayTT, secondTT) {\n  var dateTT = julianDateScratch;\n  dateTT.dayNumber = dayTT;\n  dateTT.secondsOfDay = secondTT;\n  return _JulianDate_js__WEBPACK_IMPORTED_MODULE_3__/* ["default"].daysDifference */ .Z.daysDifference(dateTT, xys._sampleZeroDateTT);\n}\n\n/**\n * Preloads XYS data for a specified date range.\n *\n * @param {Number} startDayTT The Julian day number of the beginning of the interval to preload, expressed in\n *                 the Terrestrial Time (TT) time standard.\n * @param {Number} startSecondTT The seconds past noon of the beginning of the interval to preload, expressed in\n *                 the Terrestrial Time (TT) time standard.\n * @param {Number} stopDayTT The Julian day number of the end of the interval to preload, expressed in\n *                 the Terrestrial Time (TT) time standard.\n * @param {Number} stopSecondTT The seconds past noon of the end of the interval to preload, expressed in\n *                 the Terrestrial Time (TT) time standard.\n * @returns {Promise<void>} A promise that, when resolved, indicates that the requested interval has been\n *                    preloaded.\n */\nIau2006XysData.prototype.preload = function (\n  startDayTT,\n  startSecondTT,\n  stopDayTT,\n  stopSecondTT\n) {\n  var startDaysSinceEpoch = getDaysSinceEpoch(this, startDayTT, startSecondTT);\n  var stopDaysSinceEpoch = getDaysSinceEpoch(this, stopDayTT, stopSecondTT);\n\n  var startIndex =\n    (startDaysSinceEpoch / this._stepSizeDays - this._interpolationOrder / 2) |\n    0;\n  if (startIndex < 0) {\n    startIndex = 0;\n  }\n\n  var stopIndex =\n    (stopDaysSinceEpoch / this._stepSizeDays - this._interpolationOrder / 2) |\n    (0 + this._interpolationOrder);\n  if (stopIndex >= this._totalSamples) {\n    stopIndex = this._totalSamples - 1;\n  }\n\n  var startChunk = (startIndex / this._samplesPerXysFile) | 0;\n  var stopChunk = (stopIndex / this._samplesPerXysFile) | 0;\n\n  var promises = [];\n  for (var i = startChunk; i <= stopChunk; ++i) {\n    promises.push(requestXysChunk(this, i));\n  }\n\n  return _ThirdParty_when_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].all */ .Z.all(promises);\n};\n\n/**\n * Computes the XYS values for a given date by interpolating.  If the required data is not yet downloaded,\n * this method will return undefined.\n *\n * @param {Number} dayTT The Julian day number for which to compute the XYS value, expressed in\n *                 the Terrestrial Time (TT) time standard.\n * @param {Number} secondTT The seconds past noon of the date for which to compute the XYS value, expressed in\n *                 the Terrestrial Time (TT) time standard.\n * @param {Iau2006XysSample} [result] The instance to which to copy the interpolated result.  If this parameter\n *                           is undefined, a new instance is allocated and returned.\n * @returns {Iau2006XysSample} The interpolated XYS values, or undefined if the required data for this\n *                             computation has not yet been downloaded.\n *\n * @see Iau2006XysData#preload\n */\nIau2006XysData.prototype.computeXysRadians = function (\n  dayTT,\n  secondTT,\n  result\n) {\n  var daysSinceEpoch = getDaysSinceEpoch(this, dayTT, secondTT);\n  if (daysSinceEpoch < 0.0) {\n    // Can\'t evaluate prior to the epoch of the data.\n    return undefined;\n  }\n\n  var centerIndex = (daysSinceEpoch / this._stepSizeDays) | 0;\n  if (centerIndex >= this._totalSamples) {\n    // Can\'t evaluate after the last sample in the data.\n    return undefined;\n  }\n\n  var degree = this._interpolationOrder;\n\n  var firstIndex = centerIndex - ((degree / 2) | 0);\n  if (firstIndex < 0) {\n    firstIndex = 0;\n  }\n  var lastIndex = firstIndex + degree;\n  if (lastIndex >= this._totalSamples) {\n    lastIndex = this._totalSamples - 1;\n    firstIndex = lastIndex - degree;\n    if (firstIndex < 0) {\n      firstIndex = 0;\n    }\n  }\n\n  // Are all the samples we need present?\n  // We can assume so if the first and last are present\n  var isDataMissing = false;\n  var samples = this._samples;\n  if (!(0,_defined_js__WEBPACK_IMPORTED_MODULE_6__/* ["default"] */ .Z)(samples[firstIndex * 3])) {\n    requestXysChunk(this, (firstIndex / this._samplesPerXysFile) | 0);\n    isDataMissing = true;\n  }\n\n  if (!(0,_defined_js__WEBPACK_IMPORTED_MODULE_6__/* ["default"] */ .Z)(samples[lastIndex * 3])) {\n    requestXysChunk(this, (lastIndex / this._samplesPerXysFile) | 0);\n    isDataMissing = true;\n  }\n\n  if (isDataMissing) {\n    return undefined;\n  }\n\n  if (!(0,_defined_js__WEBPACK_IMPORTED_MODULE_6__/* ["default"] */ .Z)(result)) {\n    result = new _Iau2006XysSample_js__WEBPACK_IMPORTED_MODULE_7__/* ["default"] */ .Z(0.0, 0.0, 0.0);\n  } else {\n    result.x = 0.0;\n    result.y = 0.0;\n    result.s = 0.0;\n  }\n\n  var x = daysSinceEpoch - firstIndex * this._stepSizeDays;\n\n  var work = this._work;\n  var denom = this._denominators;\n  var coef = this._coef;\n  var xTable = this._xTable;\n\n  var i, j;\n  for (i = 0; i <= degree; ++i) {\n    work[i] = x - xTable[i];\n  }\n\n  for (i = 0; i <= degree; ++i) {\n    coef[i] = 1.0;\n\n    for (j = 0; j <= degree; ++j) {\n      if (j !== i) {\n        coef[i] *= work[j];\n      }\n    }\n\n    coef[i] *= denom[i];\n\n    var sampleIndex = (firstIndex + i) * 3;\n    result.x += coef[i] * samples[sampleIndex++];\n    result.y += coef[i] * samples[sampleIndex++];\n    result.s += coef[i] * samples[sampleIndex];\n  }\n\n  return result;\n};\n\nfunction requestXysChunk(xysData, chunkIndex) {\n  if (xysData._chunkDownloadsInProgress[chunkIndex]) {\n    // Chunk has already been requested.\n    return xysData._chunkDownloadsInProgress[chunkIndex];\n  }\n\n  var deferred = _ThirdParty_when_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].defer */ .Z.defer();\n\n  xysData._chunkDownloadsInProgress[chunkIndex] = deferred;\n\n  var chunkUrl;\n  var xysFileUrlTemplate = xysData._xysFileUrlTemplate;\n  if ((0,_defined_js__WEBPACK_IMPORTED_MODULE_6__/* ["default"] */ .Z)(xysFileUrlTemplate)) {\n    chunkUrl = xysFileUrlTemplate.getDerivedResource({\n      templateValues: {\n        0: chunkIndex,\n      },\n    });\n  } else {\n    chunkUrl = new _Resource_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .Z({\n      url: (0,_buildModuleUrl_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .Z)(\n        "Assets/IAU2006_XYS/IAU2006_XYS_" + chunkIndex + ".json"\n      ),\n    });\n  }\n\n  (0,_ThirdParty_when_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .Z)(chunkUrl.fetchJson(), function (chunk) {\n    xysData._chunkDownloadsInProgress[chunkIndex] = false;\n\n    var samples = xysData._samples;\n    var newSamples = chunk.samples;\n    var startIndex = chunkIndex * xysData._samplesPerXysFile * 3;\n\n    for (var i = 0, len = newSamples.length; i < len; ++i) {\n      samples[startIndex + i] = newSamples[i];\n    }\n\n    deferred.resolve();\n  });\n\n  return deferred.promise;\n}\n/* harmony default export */ __webpack_exports__["Z"] = (Iau2006XysData);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QUFDQSxLQUFLO0FBQ0w7O0FBRUEsRUFBRSx3RUFBSTtBQUNOOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSw2Q0FBNkMsU0FBUztBQUN0RDtBQUNBOztBQUVBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0EseURBQWUsY0FBYyxFQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdnVlMy13ZWJwYWNrNS8uL25vZGVfbW9kdWxlcy9jZXNpdW0vU291cmNlL0NvcmUvSWF1MjAwNlh5c0RhdGEuanM/MThlYSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgd2hlbiBmcm9tIFwiLi4vVGhpcmRQYXJ0eS93aGVuLmpzXCI7XG5pbXBvcnQgYnVpbGRNb2R1bGVVcmwgZnJvbSBcIi4vYnVpbGRNb2R1bGVVcmwuanNcIjtcbmltcG9ydCBkZWZhdWx0VmFsdWUgZnJvbSBcIi4vZGVmYXVsdFZhbHVlLmpzXCI7XG5pbXBvcnQgZGVmaW5lZCBmcm9tIFwiLi9kZWZpbmVkLmpzXCI7XG5pbXBvcnQgSWF1MjAwNlh5c1NhbXBsZSBmcm9tIFwiLi9JYXUyMDA2WHlzU2FtcGxlLmpzXCI7XG5pbXBvcnQgSnVsaWFuRGF0ZSBmcm9tIFwiLi9KdWxpYW5EYXRlLmpzXCI7XG5pbXBvcnQgUmVzb3VyY2UgZnJvbSBcIi4vUmVzb3VyY2UuanNcIjtcbmltcG9ydCBUaW1lU3RhbmRhcmQgZnJvbSBcIi4vVGltZVN0YW5kYXJkLmpzXCI7XG5cbi8qKlxuICogQSBzZXQgb2YgSUFVMjAwNiBYWVMgZGF0YSB0aGF0IGlzIHVzZWQgdG8gZXZhbHVhdGUgdGhlIHRyYW5zZm9ybWF0aW9uIGJldHdlZW4gdGhlIEludGVybmF0aW9uYWxcbiAqIENlbGVzdGlhbCBSZWZlcmVuY2UgRnJhbWUgKElDUkYpIGFuZCB0aGUgSW50ZXJuYXRpb25hbCBUZXJyZXN0cmlhbCBSZWZlcmVuY2UgRnJhbWUgKElUUkYpLlxuICpcbiAqIEBhbGlhcyBJYXUyMDA2WHlzRGF0YVxuICogQGNvbnN0cnVjdG9yXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSBPYmplY3Qgd2l0aCB0aGUgZm9sbG93aW5nIHByb3BlcnRpZXM6XG4gKiBAcGFyYW0ge1Jlc291cmNlfFN0cmluZ30gW29wdGlvbnMueHlzRmlsZVVybFRlbXBsYXRlPSdBc3NldHMvSUFVMjAwNl9YWVMvSUFVMjAwNl9YWVNfezB9Lmpzb24nXSBBIHRlbXBsYXRlIFVSTCBmb3Igb2J0YWluaW5nIHRoZSBYWVMgZGF0YS4gIEluIHRoZSB0ZW1wbGF0ZSxcbiAqICAgICAgICAgICAgICAgICBgezB9YCB3aWxsIGJlIHJlcGxhY2VkIHdpdGggdGhlIGZpbGUgaW5kZXguXG4gKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMuaW50ZXJwb2xhdGlvbk9yZGVyPTldIFRoZSBvcmRlciBvZiBpbnRlcnBvbGF0aW9uIHRvIHBlcmZvcm0gb24gdGhlIFhZUyBkYXRhLlxuICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLnNhbXBsZVplcm9KdWxpYW5FcGhlbWVyaXNEYXRlPTI0NDIzOTYuNV0gVGhlIEp1bGlhbiBlcGhlbWVyaXMgZGF0ZSAoSkVEKSBvZiB0aGVcbiAqICAgICAgICAgICAgICAgICBmaXJzdCBYWVMgc2FtcGxlLlxuICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLnN0ZXBTaXplRGF5cz0xLjBdIFRoZSBzdGVwIHNpemUsIGluIGRheXMsIGJldHdlZW4gc3VjY2Vzc2l2ZSBYWVMgc2FtcGxlcy5cbiAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5zYW1wbGVzUGVyWHlzRmlsZT0xMDAwXSBUaGUgbnVtYmVyIG9mIHNhbXBsZXMgaW4gZWFjaCBYWVMgZmlsZS5cbiAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy50b3RhbFNhbXBsZXM9Mjc0MjZdIFRoZSB0b3RhbCBudW1iZXIgb2Ygc2FtcGxlcyBpbiBhbGwgWFlTIGZpbGVzLlxuICpcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIElhdTIwMDZYeXNEYXRhKG9wdGlvbnMpIHtcbiAgb3B0aW9ucyA9IGRlZmF1bHRWYWx1ZShvcHRpb25zLCBkZWZhdWx0VmFsdWUuRU1QVFlfT0JKRUNUKTtcblxuICB0aGlzLl94eXNGaWxlVXJsVGVtcGxhdGUgPSBSZXNvdXJjZS5jcmVhdGVJZk5lZWRlZChcbiAgICBvcHRpb25zLnh5c0ZpbGVVcmxUZW1wbGF0ZVxuICApO1xuICB0aGlzLl9pbnRlcnBvbGF0aW9uT3JkZXIgPSBkZWZhdWx0VmFsdWUob3B0aW9ucy5pbnRlcnBvbGF0aW9uT3JkZXIsIDkpO1xuICB0aGlzLl9zYW1wbGVaZXJvSnVsaWFuRXBoZW1lcmlzRGF0ZSA9IGRlZmF1bHRWYWx1ZShcbiAgICBvcHRpb25zLnNhbXBsZVplcm9KdWxpYW5FcGhlbWVyaXNEYXRlLFxuICAgIDI0NDIzOTYuNVxuICApO1xuICB0aGlzLl9zYW1wbGVaZXJvRGF0ZVRUID0gbmV3IEp1bGlhbkRhdGUoXG4gICAgdGhpcy5fc2FtcGxlWmVyb0p1bGlhbkVwaGVtZXJpc0RhdGUsXG4gICAgMC4wLFxuICAgIFRpbWVTdGFuZGFyZC5UQUlcbiAgKTtcbiAgdGhpcy5fc3RlcFNpemVEYXlzID0gZGVmYXVsdFZhbHVlKG9wdGlvbnMuc3RlcFNpemVEYXlzLCAxLjApO1xuICB0aGlzLl9zYW1wbGVzUGVyWHlzRmlsZSA9IGRlZmF1bHRWYWx1ZShvcHRpb25zLnNhbXBsZXNQZXJYeXNGaWxlLCAxMDAwKTtcbiAgdGhpcy5fdG90YWxTYW1wbGVzID0gZGVmYXVsdFZhbHVlKG9wdGlvbnMudG90YWxTYW1wbGVzLCAyNzQyNik7XG4gIHRoaXMuX3NhbXBsZXMgPSBuZXcgQXJyYXkodGhpcy5fdG90YWxTYW1wbGVzICogMyk7XG4gIHRoaXMuX2NodW5rRG93bmxvYWRzSW5Qcm9ncmVzcyA9IFtdO1xuXG4gIHZhciBvcmRlciA9IHRoaXMuX2ludGVycG9sYXRpb25PcmRlcjtcblxuICAvLyBDb21wdXRlIGRlbm9taW5hdG9ycyBhbmQgWCB2YWx1ZXMgZm9yIGludGVycG9sYXRpb24uXG4gIHZhciBkZW5vbSA9ICh0aGlzLl9kZW5vbWluYXRvcnMgPSBuZXcgQXJyYXkob3JkZXIgKyAxKSk7XG4gIHZhciB4VGFibGUgPSAodGhpcy5feFRhYmxlID0gbmV3IEFycmF5KG9yZGVyICsgMSkpO1xuXG4gIHZhciBzdGVwTiA9IE1hdGgucG93KHRoaXMuX3N0ZXBTaXplRGF5cywgb3JkZXIpO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDw9IG9yZGVyOyArK2kpIHtcbiAgICBkZW5vbVtpXSA9IHN0ZXBOO1xuICAgIHhUYWJsZVtpXSA9IGkgKiB0aGlzLl9zdGVwU2l6ZURheXM7XG5cbiAgICBmb3IgKHZhciBqID0gMDsgaiA8PSBvcmRlcjsgKytqKSB7XG4gICAgICBpZiAoaiAhPT0gaSkge1xuICAgICAgICBkZW5vbVtpXSAqPSBpIC0gajtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBkZW5vbVtpXSA9IDEuMCAvIGRlbm9tW2ldO1xuICB9XG5cbiAgLy8gQWxsb2NhdGUgc2NyYXRjaCBhcnJheXMgZm9yIGludGVycG9sYXRpb24uXG4gIHRoaXMuX3dvcmsgPSBuZXcgQXJyYXkob3JkZXIgKyAxKTtcbiAgdGhpcy5fY29lZiA9IG5ldyBBcnJheShvcmRlciArIDEpO1xufVxuXG52YXIganVsaWFuRGF0ZVNjcmF0Y2ggPSBuZXcgSnVsaWFuRGF0ZSgwLCAwLjAsIFRpbWVTdGFuZGFyZC5UQUkpO1xuXG5mdW5jdGlvbiBnZXREYXlzU2luY2VFcG9jaCh4eXMsIGRheVRULCBzZWNvbmRUVCkge1xuICB2YXIgZGF0ZVRUID0ganVsaWFuRGF0ZVNjcmF0Y2g7XG4gIGRhdGVUVC5kYXlOdW1iZXIgPSBkYXlUVDtcbiAgZGF0ZVRULnNlY29uZHNPZkRheSA9IHNlY29uZFRUO1xuICByZXR1cm4gSnVsaWFuRGF0ZS5kYXlzRGlmZmVyZW5jZShkYXRlVFQsIHh5cy5fc2FtcGxlWmVyb0RhdGVUVCk7XG59XG5cbi8qKlxuICogUHJlbG9hZHMgWFlTIGRhdGEgZm9yIGEgc3BlY2lmaWVkIGRhdGUgcmFuZ2UuXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IHN0YXJ0RGF5VFQgVGhlIEp1bGlhbiBkYXkgbnVtYmVyIG9mIHRoZSBiZWdpbm5pbmcgb2YgdGhlIGludGVydmFsIHRvIHByZWxvYWQsIGV4cHJlc3NlZCBpblxuICogICAgICAgICAgICAgICAgIHRoZSBUZXJyZXN0cmlhbCBUaW1lIChUVCkgdGltZSBzdGFuZGFyZC5cbiAqIEBwYXJhbSB7TnVtYmVyfSBzdGFydFNlY29uZFRUIFRoZSBzZWNvbmRzIHBhc3Qgbm9vbiBvZiB0aGUgYmVnaW5uaW5nIG9mIHRoZSBpbnRlcnZhbCB0byBwcmVsb2FkLCBleHByZXNzZWQgaW5cbiAqICAgICAgICAgICAgICAgICB0aGUgVGVycmVzdHJpYWwgVGltZSAoVFQpIHRpbWUgc3RhbmRhcmQuXG4gKiBAcGFyYW0ge051bWJlcn0gc3RvcERheVRUIFRoZSBKdWxpYW4gZGF5IG51bWJlciBvZiB0aGUgZW5kIG9mIHRoZSBpbnRlcnZhbCB0byBwcmVsb2FkLCBleHByZXNzZWQgaW5cbiAqICAgICAgICAgICAgICAgICB0aGUgVGVycmVzdHJpYWwgVGltZSAoVFQpIHRpbWUgc3RhbmRhcmQuXG4gKiBAcGFyYW0ge051bWJlcn0gc3RvcFNlY29uZFRUIFRoZSBzZWNvbmRzIHBhc3Qgbm9vbiBvZiB0aGUgZW5kIG9mIHRoZSBpbnRlcnZhbCB0byBwcmVsb2FkLCBleHByZXNzZWQgaW5cbiAqICAgICAgICAgICAgICAgICB0aGUgVGVycmVzdHJpYWwgVGltZSAoVFQpIHRpbWUgc3RhbmRhcmQuXG4gKiBAcmV0dXJucyB7UHJvbWlzZTx2b2lkPn0gQSBwcm9taXNlIHRoYXQsIHdoZW4gcmVzb2x2ZWQsIGluZGljYXRlcyB0aGF0IHRoZSByZXF1ZXN0ZWQgaW50ZXJ2YWwgaGFzIGJlZW5cbiAqICAgICAgICAgICAgICAgICAgICBwcmVsb2FkZWQuXG4gKi9cbklhdTIwMDZYeXNEYXRhLnByb3RvdHlwZS5wcmVsb2FkID0gZnVuY3Rpb24gKFxuICBzdGFydERheVRULFxuICBzdGFydFNlY29uZFRULFxuICBzdG9wRGF5VFQsXG4gIHN0b3BTZWNvbmRUVFxuKSB7XG4gIHZhciBzdGFydERheXNTaW5jZUVwb2NoID0gZ2V0RGF5c1NpbmNlRXBvY2godGhpcywgc3RhcnREYXlUVCwgc3RhcnRTZWNvbmRUVCk7XG4gIHZhciBzdG9wRGF5c1NpbmNlRXBvY2ggPSBnZXREYXlzU2luY2VFcG9jaCh0aGlzLCBzdG9wRGF5VFQsIHN0b3BTZWNvbmRUVCk7XG5cbiAgdmFyIHN0YXJ0SW5kZXggPVxuICAgIChzdGFydERheXNTaW5jZUVwb2NoIC8gdGhpcy5fc3RlcFNpemVEYXlzIC0gdGhpcy5faW50ZXJwb2xhdGlvbk9yZGVyIC8gMikgfFxuICAgIDA7XG4gIGlmIChzdGFydEluZGV4IDwgMCkge1xuICAgIHN0YXJ0SW5kZXggPSAwO1xuICB9XG5cbiAgdmFyIHN0b3BJbmRleCA9XG4gICAgKHN0b3BEYXlzU2luY2VFcG9jaCAvIHRoaXMuX3N0ZXBTaXplRGF5cyAtIHRoaXMuX2ludGVycG9sYXRpb25PcmRlciAvIDIpIHxcbiAgICAoMCArIHRoaXMuX2ludGVycG9sYXRpb25PcmRlcik7XG4gIGlmIChzdG9wSW5kZXggPj0gdGhpcy5fdG90YWxTYW1wbGVzKSB7XG4gICAgc3RvcEluZGV4ID0gdGhpcy5fdG90YWxTYW1wbGVzIC0gMTtcbiAgfVxuXG4gIHZhciBzdGFydENodW5rID0gKHN0YXJ0SW5kZXggLyB0aGlzLl9zYW1wbGVzUGVyWHlzRmlsZSkgfCAwO1xuICB2YXIgc3RvcENodW5rID0gKHN0b3BJbmRleCAvIHRoaXMuX3NhbXBsZXNQZXJYeXNGaWxlKSB8IDA7XG5cbiAgdmFyIHByb21pc2VzID0gW107XG4gIGZvciAodmFyIGkgPSBzdGFydENodW5rOyBpIDw9IHN0b3BDaHVuazsgKytpKSB7XG4gICAgcHJvbWlzZXMucHVzaChyZXF1ZXN0WHlzQ2h1bmsodGhpcywgaSkpO1xuICB9XG5cbiAgcmV0dXJuIHdoZW4uYWxsKHByb21pc2VzKTtcbn07XG5cbi8qKlxuICogQ29tcHV0ZXMgdGhlIFhZUyB2YWx1ZXMgZm9yIGEgZ2l2ZW4gZGF0ZSBieSBpbnRlcnBvbGF0aW5nLiAgSWYgdGhlIHJlcXVpcmVkIGRhdGEgaXMgbm90IHlldCBkb3dubG9hZGVkLFxuICogdGhpcyBtZXRob2Qgd2lsbCByZXR1cm4gdW5kZWZpbmVkLlxuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSBkYXlUVCBUaGUgSnVsaWFuIGRheSBudW1iZXIgZm9yIHdoaWNoIHRvIGNvbXB1dGUgdGhlIFhZUyB2YWx1ZSwgZXhwcmVzc2VkIGluXG4gKiAgICAgICAgICAgICAgICAgdGhlIFRlcnJlc3RyaWFsIFRpbWUgKFRUKSB0aW1lIHN0YW5kYXJkLlxuICogQHBhcmFtIHtOdW1iZXJ9IHNlY29uZFRUIFRoZSBzZWNvbmRzIHBhc3Qgbm9vbiBvZiB0aGUgZGF0ZSBmb3Igd2hpY2ggdG8gY29tcHV0ZSB0aGUgWFlTIHZhbHVlLCBleHByZXNzZWQgaW5cbiAqICAgICAgICAgICAgICAgICB0aGUgVGVycmVzdHJpYWwgVGltZSAoVFQpIHRpbWUgc3RhbmRhcmQuXG4gKiBAcGFyYW0ge0lhdTIwMDZYeXNTYW1wbGV9IFtyZXN1bHRdIFRoZSBpbnN0YW5jZSB0byB3aGljaCB0byBjb3B5IHRoZSBpbnRlcnBvbGF0ZWQgcmVzdWx0LiAgSWYgdGhpcyBwYXJhbWV0ZXJcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgaXMgdW5kZWZpbmVkLCBhIG5ldyBpbnN0YW5jZSBpcyBhbGxvY2F0ZWQgYW5kIHJldHVybmVkLlxuICogQHJldHVybnMge0lhdTIwMDZYeXNTYW1wbGV9IFRoZSBpbnRlcnBvbGF0ZWQgWFlTIHZhbHVlcywgb3IgdW5kZWZpbmVkIGlmIHRoZSByZXF1aXJlZCBkYXRhIGZvciB0aGlzXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29tcHV0YXRpb24gaGFzIG5vdCB5ZXQgYmVlbiBkb3dubG9hZGVkLlxuICpcbiAqIEBzZWUgSWF1MjAwNlh5c0RhdGEjcHJlbG9hZFxuICovXG5JYXUyMDA2WHlzRGF0YS5wcm90b3R5cGUuY29tcHV0ZVh5c1JhZGlhbnMgPSBmdW5jdGlvbiAoXG4gIGRheVRULFxuICBzZWNvbmRUVCxcbiAgcmVzdWx0XG4pIHtcbiAgdmFyIGRheXNTaW5jZUVwb2NoID0gZ2V0RGF5c1NpbmNlRXBvY2godGhpcywgZGF5VFQsIHNlY29uZFRUKTtcbiAgaWYgKGRheXNTaW5jZUVwb2NoIDwgMC4wKSB7XG4gICAgLy8gQ2FuJ3QgZXZhbHVhdGUgcHJpb3IgdG8gdGhlIGVwb2NoIG9mIHRoZSBkYXRhLlxuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cblxuICB2YXIgY2VudGVySW5kZXggPSAoZGF5c1NpbmNlRXBvY2ggLyB0aGlzLl9zdGVwU2l6ZURheXMpIHwgMDtcbiAgaWYgKGNlbnRlckluZGV4ID49IHRoaXMuX3RvdGFsU2FtcGxlcykge1xuICAgIC8vIENhbid0IGV2YWx1YXRlIGFmdGVyIHRoZSBsYXN0IHNhbXBsZSBpbiB0aGUgZGF0YS5cbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG5cbiAgdmFyIGRlZ3JlZSA9IHRoaXMuX2ludGVycG9sYXRpb25PcmRlcjtcblxuICB2YXIgZmlyc3RJbmRleCA9IGNlbnRlckluZGV4IC0gKChkZWdyZWUgLyAyKSB8IDApO1xuICBpZiAoZmlyc3RJbmRleCA8IDApIHtcbiAgICBmaXJzdEluZGV4ID0gMDtcbiAgfVxuICB2YXIgbGFzdEluZGV4ID0gZmlyc3RJbmRleCArIGRlZ3JlZTtcbiAgaWYgKGxhc3RJbmRleCA+PSB0aGlzLl90b3RhbFNhbXBsZXMpIHtcbiAgICBsYXN0SW5kZXggPSB0aGlzLl90b3RhbFNhbXBsZXMgLSAxO1xuICAgIGZpcnN0SW5kZXggPSBsYXN0SW5kZXggLSBkZWdyZWU7XG4gICAgaWYgKGZpcnN0SW5kZXggPCAwKSB7XG4gICAgICBmaXJzdEluZGV4ID0gMDtcbiAgICB9XG4gIH1cblxuICAvLyBBcmUgYWxsIHRoZSBzYW1wbGVzIHdlIG5lZWQgcHJlc2VudD9cbiAgLy8gV2UgY2FuIGFzc3VtZSBzbyBpZiB0aGUgZmlyc3QgYW5kIGxhc3QgYXJlIHByZXNlbnRcbiAgdmFyIGlzRGF0YU1pc3NpbmcgPSBmYWxzZTtcbiAgdmFyIHNhbXBsZXMgPSB0aGlzLl9zYW1wbGVzO1xuICBpZiAoIWRlZmluZWQoc2FtcGxlc1tmaXJzdEluZGV4ICogM10pKSB7XG4gICAgcmVxdWVzdFh5c0NodW5rKHRoaXMsIChmaXJzdEluZGV4IC8gdGhpcy5fc2FtcGxlc1Blclh5c0ZpbGUpIHwgMCk7XG4gICAgaXNEYXRhTWlzc2luZyA9IHRydWU7XG4gIH1cblxuICBpZiAoIWRlZmluZWQoc2FtcGxlc1tsYXN0SW5kZXggKiAzXSkpIHtcbiAgICByZXF1ZXN0WHlzQ2h1bmsodGhpcywgKGxhc3RJbmRleCAvIHRoaXMuX3NhbXBsZXNQZXJYeXNGaWxlKSB8IDApO1xuICAgIGlzRGF0YU1pc3NpbmcgPSB0cnVlO1xuICB9XG5cbiAgaWYgKGlzRGF0YU1pc3NpbmcpIHtcbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG5cbiAgaWYgKCFkZWZpbmVkKHJlc3VsdCkpIHtcbiAgICByZXN1bHQgPSBuZXcgSWF1MjAwNlh5c1NhbXBsZSgwLjAsIDAuMCwgMC4wKTtcbiAgfSBlbHNlIHtcbiAgICByZXN1bHQueCA9IDAuMDtcbiAgICByZXN1bHQueSA9IDAuMDtcbiAgICByZXN1bHQucyA9IDAuMDtcbiAgfVxuXG4gIHZhciB4ID0gZGF5c1NpbmNlRXBvY2ggLSBmaXJzdEluZGV4ICogdGhpcy5fc3RlcFNpemVEYXlzO1xuXG4gIHZhciB3b3JrID0gdGhpcy5fd29yaztcbiAgdmFyIGRlbm9tID0gdGhpcy5fZGVub21pbmF0b3JzO1xuICB2YXIgY29lZiA9IHRoaXMuX2NvZWY7XG4gIHZhciB4VGFibGUgPSB0aGlzLl94VGFibGU7XG5cbiAgdmFyIGksIGo7XG4gIGZvciAoaSA9IDA7IGkgPD0gZGVncmVlOyArK2kpIHtcbiAgICB3b3JrW2ldID0geCAtIHhUYWJsZVtpXTtcbiAgfVxuXG4gIGZvciAoaSA9IDA7IGkgPD0gZGVncmVlOyArK2kpIHtcbiAgICBjb2VmW2ldID0gMS4wO1xuXG4gICAgZm9yIChqID0gMDsgaiA8PSBkZWdyZWU7ICsraikge1xuICAgICAgaWYgKGogIT09IGkpIHtcbiAgICAgICAgY29lZltpXSAqPSB3b3JrW2pdO1xuICAgICAgfVxuICAgIH1cblxuICAgIGNvZWZbaV0gKj0gZGVub21baV07XG5cbiAgICB2YXIgc2FtcGxlSW5kZXggPSAoZmlyc3RJbmRleCArIGkpICogMztcbiAgICByZXN1bHQueCArPSBjb2VmW2ldICogc2FtcGxlc1tzYW1wbGVJbmRleCsrXTtcbiAgICByZXN1bHQueSArPSBjb2VmW2ldICogc2FtcGxlc1tzYW1wbGVJbmRleCsrXTtcbiAgICByZXN1bHQucyArPSBjb2VmW2ldICogc2FtcGxlc1tzYW1wbGVJbmRleF07XG4gIH1cblxuICByZXR1cm4gcmVzdWx0O1xufTtcblxuZnVuY3Rpb24gcmVxdWVzdFh5c0NodW5rKHh5c0RhdGEsIGNodW5rSW5kZXgpIHtcbiAgaWYgKHh5c0RhdGEuX2NodW5rRG93bmxvYWRzSW5Qcm9ncmVzc1tjaHVua0luZGV4XSkge1xuICAgIC8vIENodW5rIGhhcyBhbHJlYWR5IGJlZW4gcmVxdWVzdGVkLlxuICAgIHJldHVybiB4eXNEYXRhLl9jaHVua0Rvd25sb2Fkc0luUHJvZ3Jlc3NbY2h1bmtJbmRleF07XG4gIH1cblxuICB2YXIgZGVmZXJyZWQgPSB3aGVuLmRlZmVyKCk7XG5cbiAgeHlzRGF0YS5fY2h1bmtEb3dubG9hZHNJblByb2dyZXNzW2NodW5rSW5kZXhdID0gZGVmZXJyZWQ7XG5cbiAgdmFyIGNodW5rVXJsO1xuICB2YXIgeHlzRmlsZVVybFRlbXBsYXRlID0geHlzRGF0YS5feHlzRmlsZVVybFRlbXBsYXRlO1xuICBpZiAoZGVmaW5lZCh4eXNGaWxlVXJsVGVtcGxhdGUpKSB7XG4gICAgY2h1bmtVcmwgPSB4eXNGaWxlVXJsVGVtcGxhdGUuZ2V0RGVyaXZlZFJlc291cmNlKHtcbiAgICAgIHRlbXBsYXRlVmFsdWVzOiB7XG4gICAgICAgIDA6IGNodW5rSW5kZXgsXG4gICAgICB9LFxuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIGNodW5rVXJsID0gbmV3IFJlc291cmNlKHtcbiAgICAgIHVybDogYnVpbGRNb2R1bGVVcmwoXG4gICAgICAgIFwiQXNzZXRzL0lBVTIwMDZfWFlTL0lBVTIwMDZfWFlTX1wiICsgY2h1bmtJbmRleCArIFwiLmpzb25cIlxuICAgICAgKSxcbiAgICB9KTtcbiAgfVxuXG4gIHdoZW4oY2h1bmtVcmwuZmV0Y2hKc29uKCksIGZ1bmN0aW9uIChjaHVuaykge1xuICAgIHh5c0RhdGEuX2NodW5rRG93bmxvYWRzSW5Qcm9ncmVzc1tjaHVua0luZGV4XSA9IGZhbHNlO1xuXG4gICAgdmFyIHNhbXBsZXMgPSB4eXNEYXRhLl9zYW1wbGVzO1xuICAgIHZhciBuZXdTYW1wbGVzID0gY2h1bmsuc2FtcGxlcztcbiAgICB2YXIgc3RhcnRJbmRleCA9IGNodW5rSW5kZXggKiB4eXNEYXRhLl9zYW1wbGVzUGVyWHlzRmlsZSAqIDM7XG5cbiAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gbmV3U2FtcGxlcy5sZW5ndGg7IGkgPCBsZW47ICsraSkge1xuICAgICAgc2FtcGxlc1tzdGFydEluZGV4ICsgaV0gPSBuZXdTYW1wbGVzW2ldO1xuICAgIH1cblxuICAgIGRlZmVycmVkLnJlc29sdmUoKTtcbiAgfSk7XG5cbiAgcmV0dXJuIGRlZmVycmVkLnByb21pc2U7XG59XG5leHBvcnQgZGVmYXVsdCBJYXUyMDA2WHlzRGF0YTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///27846\n')},50048:function(__unused_webpack___webpack_module__,__webpack_exports__){eval('/**\n * An IAU 2006 XYS value sampled at a particular time.\n *\n * @alias Iau2006XysSample\n * @constructor\n *\n * @param {Number} x The X value.\n * @param {Number} y The Y value.\n * @param {Number} s The S value.\n *\n * @private\n */\nfunction Iau2006XysSample(x, y, s) {\n  /**\n   * The X value.\n   * @type {Number}\n   */\n  this.x = x;\n\n  /**\n   * The Y value.\n   * @type {Number}\n   */\n  this.y = y;\n\n  /**\n   * The S value.\n   * @type {Number}\n   */\n  this.s = s;\n}\n/* harmony default export */ __webpack_exports__["Z"] = (Iau2006XysSample);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNTAwNDguanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0EseURBQWUsZ0JBQWdCLEVBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly92dWUzLXdlYnBhY2s1Ly4vbm9kZV9tb2R1bGVzL2Nlc2l1bS9Tb3VyY2UvQ29yZS9JYXUyMDA2WHlzU2FtcGxlLmpzPzU1NGMiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBBbiBJQVUgMjAwNiBYWVMgdmFsdWUgc2FtcGxlZCBhdCBhIHBhcnRpY3VsYXIgdGltZS5cbiAqXG4gKiBAYWxpYXMgSWF1MjAwNlh5c1NhbXBsZVxuICogQGNvbnN0cnVjdG9yXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IHggVGhlIFggdmFsdWUuXG4gKiBAcGFyYW0ge051bWJlcn0geSBUaGUgWSB2YWx1ZS5cbiAqIEBwYXJhbSB7TnVtYmVyfSBzIFRoZSBTIHZhbHVlLlxuICpcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIElhdTIwMDZYeXNTYW1wbGUoeCwgeSwgcykge1xuICAvKipcbiAgICogVGhlIFggdmFsdWUuXG4gICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAqL1xuICB0aGlzLnggPSB4O1xuXG4gIC8qKlxuICAgKiBUaGUgWSB2YWx1ZS5cbiAgICogQHR5cGUge051bWJlcn1cbiAgICovXG4gIHRoaXMueSA9IHk7XG5cbiAgLyoqXG4gICAqIFRoZSBTIHZhbHVlLlxuICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgKi9cbiAgdGhpcy5zID0gcztcbn1cbmV4cG9ydCBkZWZhdWx0IElhdTIwMDZYeXNTYW1wbGU7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///50048\n')},23628:function(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__){eval('/* harmony import */ var _Cartesian3_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(60216);\n/* harmony import */ var _defined_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(82982);\n/* harmony import */ var _Iau2000Orientation_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(41999);\n/* harmony import */ var _JulianDate_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(55293);\n/* harmony import */ var _Math_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(99417);\n/* harmony import */ var _Matrix3_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(68201);\n/* harmony import */ var _Quaternion_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(87811);\n\n\n\n\n\n\n\n\n/**\n * The Axes representing the orientation of a Globe as represented by the data\n * from the IAU/IAG Working Group reports on rotational elements.\n * @alias IauOrientationAxes\n * @constructor\n *\n * @param {IauOrientationAxes.ComputeFunction} [computeFunction] The function that computes the {@link IauOrientationParameters} given a {@link JulianDate}.\n *\n * @see Iau2000Orientation\n *\n * @private\n */\nfunction IauOrientationAxes(computeFunction) {\n  if (!(0,_defined_js__WEBPACK_IMPORTED_MODULE_6__/* ["default"] */ .Z)(computeFunction) || typeof computeFunction !== "function") {\n    computeFunction = _Iau2000Orientation_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"].ComputeMoon */ .Z.ComputeMoon;\n  }\n\n  this._computeFunction = computeFunction;\n}\n\nvar xAxisScratch = new _Cartesian3_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .Z();\nvar yAxisScratch = new _Cartesian3_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .Z();\nvar zAxisScratch = new _Cartesian3_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .Z();\n\nfunction computeRotationMatrix(alpha, delta, result) {\n  var xAxis = xAxisScratch;\n  xAxis.x = Math.cos(alpha + _Math_js__WEBPACK_IMPORTED_MODULE_3__/* ["default"].PI_OVER_TWO */ .Z.PI_OVER_TWO);\n  xAxis.y = Math.sin(alpha + _Math_js__WEBPACK_IMPORTED_MODULE_3__/* ["default"].PI_OVER_TWO */ .Z.PI_OVER_TWO);\n  xAxis.z = 0.0;\n\n  var cosDec = Math.cos(delta);\n\n  var zAxis = zAxisScratch;\n  zAxis.x = cosDec * Math.cos(alpha);\n  zAxis.y = cosDec * Math.sin(alpha);\n  zAxis.z = Math.sin(delta);\n\n  var yAxis = _Cartesian3_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].cross */ .Z.cross(zAxis, xAxis, yAxisScratch);\n\n  if (!(0,_defined_js__WEBPACK_IMPORTED_MODULE_6__/* ["default"] */ .Z)(result)) {\n    result = new _Matrix3_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .Z();\n  }\n\n  result[0] = xAxis.x;\n  result[1] = yAxis.x;\n  result[2] = zAxis.x;\n  result[3] = xAxis.y;\n  result[4] = yAxis.y;\n  result[5] = zAxis.y;\n  result[6] = xAxis.z;\n  result[7] = yAxis.z;\n  result[8] = zAxis.z;\n\n  return result;\n}\n\nvar rotMtxScratch = new _Matrix3_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .Z();\nvar quatScratch = new _Quaternion_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"] */ .Z();\n\n/**\n * Computes a rotation from ICRF to a Globe\'s Fixed axes.\n *\n * @param {JulianDate} date The date to evaluate the matrix.\n * @param {Matrix3} result The object onto which to store the result.\n * @returns {Matrix3} The modified result parameter or a new instance of the rotation from ICRF to Fixed.\n */\nIauOrientationAxes.prototype.evaluate = function (date, result) {\n  if (!(0,_defined_js__WEBPACK_IMPORTED_MODULE_6__/* ["default"] */ .Z)(date)) {\n    date = _JulianDate_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"].now */ .Z.now();\n  }\n\n  var alphaDeltaW = this._computeFunction(date);\n  var precMtx = computeRotationMatrix(\n    alphaDeltaW.rightAscension,\n    alphaDeltaW.declination,\n    result\n  );\n\n  var rot = _Math_js__WEBPACK_IMPORTED_MODULE_3__/* ["default"].zeroToTwoPi */ .Z.zeroToTwoPi(alphaDeltaW.rotation);\n  var quat = _Quaternion_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"].fromAxisAngle */ .Z.fromAxisAngle(_Cartesian3_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].UNIT_Z */ .Z.UNIT_Z, rot, quatScratch);\n  var rotMtx = _Matrix3_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"].fromQuaternion */ .Z.fromQuaternion(\n    _Quaternion_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"].conjugate */ .Z.conjugate(quat, quat),\n    rotMtxScratch\n  );\n\n  var cbi2cbf = _Matrix3_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"].multiply */ .Z.multiply(rotMtx, precMtx, precMtx);\n  return cbi2cbf;\n};\n\n/**\n * A function that computes the {@link IauOrientationParameters} for a {@link JulianDate}.\n * @callback IauOrientationAxes.ComputeFunction\n * @param {JulianDate} date The date to evaluate the parameters.\n * @returns {IauOrientationParameters} The orientation parameters.\n * @private\n */\n/* harmony default export */ __webpack_exports__["Z"] = (IauOrientationAxes);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjM2MjguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUF5QztBQUNOO0FBQ3NCO0FBQ2hCO0FBQ047QUFDQTtBQUNNOztBQUV6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLG9DQUFvQyxrREFBa0QsZ0NBQWdDLFNBQVMsaUJBQWlCO0FBQzNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU8sZ0VBQU87QUFDZCxzQkFBc0IsK0ZBQThCO0FBQ3BEOztBQUVBO0FBQ0E7O0FBRUEsdUJBQXVCLCtEQUFVO0FBQ2pDLHVCQUF1QiwrREFBVTtBQUNqQyx1QkFBdUIsK0RBQVU7O0FBRWpDO0FBQ0E7QUFDQSw2QkFBNkIsaUZBQXNCO0FBQ25ELDZCQUE2QixpRkFBc0I7QUFDbkQ7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsY0FBYywyRUFBZ0I7O0FBRTlCLE9BQU8sZ0VBQU87QUFDZCxpQkFBaUIsNERBQU87QUFDeEI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsd0JBQXdCLDREQUFPO0FBQy9CLHNCQUFzQiwrREFBVTs7QUFFaEM7QUFDQTtBQUNBO0FBQ0EsV0FBVyxZQUFZO0FBQ3ZCLFdBQVcsU0FBUztBQUNwQixhQUFhLFNBQVM7QUFDdEI7QUFDQTtBQUNBLE9BQU8sZ0VBQU87QUFDZCxXQUFXLHVFQUFjO0FBQ3pCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxZQUFZLGlGQUFzQjtBQUNsQyxhQUFhLDJGQUF3QixDQUFDLDZFQUFpQjtBQUN2RCxlQUFlLDBGQUFzQjtBQUNyQyxJQUFJLG1GQUFvQjtBQUN4QjtBQUNBOztBQUVBLGdCQUFnQiw4RUFBZ0I7QUFDaEM7QUFDQTs7QUFFQTtBQUNBLGlDQUFpQyxnQ0FBZ0MsT0FBTyxpQkFBaUI7QUFDekY7QUFDQSxXQUFXLFlBQVk7QUFDdkIsYUFBYSwwQkFBMEI7QUFDdkM7QUFDQTtBQUNBLHlEQUFlLGtCQUFrQixFQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdnVlMy13ZWJwYWNrNS8uL25vZGVfbW9kdWxlcy9jZXNpdW0vU291cmNlL0NvcmUvSWF1T3JpZW50YXRpb25BeGVzLmpzPzRjY2EiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IENhcnRlc2lhbjMgZnJvbSBcIi4vQ2FydGVzaWFuMy5qc1wiO1xuaW1wb3J0IGRlZmluZWQgZnJvbSBcIi4vZGVmaW5lZC5qc1wiO1xuaW1wb3J0IElhdTIwMDBPcmllbnRhdGlvbiBmcm9tIFwiLi9JYXUyMDAwT3JpZW50YXRpb24uanNcIjtcbmltcG9ydCBKdWxpYW5EYXRlIGZyb20gXCIuL0p1bGlhbkRhdGUuanNcIjtcbmltcG9ydCBDZXNpdW1NYXRoIGZyb20gXCIuL01hdGguanNcIjtcbmltcG9ydCBNYXRyaXgzIGZyb20gXCIuL01hdHJpeDMuanNcIjtcbmltcG9ydCBRdWF0ZXJuaW9uIGZyb20gXCIuL1F1YXRlcm5pb24uanNcIjtcblxuLyoqXG4gKiBUaGUgQXhlcyByZXByZXNlbnRpbmcgdGhlIG9yaWVudGF0aW9uIG9mIGEgR2xvYmUgYXMgcmVwcmVzZW50ZWQgYnkgdGhlIGRhdGFcbiAqIGZyb20gdGhlIElBVS9JQUcgV29ya2luZyBHcm91cCByZXBvcnRzIG9uIHJvdGF0aW9uYWwgZWxlbWVudHMuXG4gKiBAYWxpYXMgSWF1T3JpZW50YXRpb25BeGVzXG4gKiBAY29uc3RydWN0b3JcbiAqXG4gKiBAcGFyYW0ge0lhdU9yaWVudGF0aW9uQXhlcy5Db21wdXRlRnVuY3Rpb259IFtjb21wdXRlRnVuY3Rpb25dIFRoZSBmdW5jdGlvbiB0aGF0IGNvbXB1dGVzIHRoZSB7QGxpbmsgSWF1T3JpZW50YXRpb25QYXJhbWV0ZXJzfSBnaXZlbiBhIHtAbGluayBKdWxpYW5EYXRlfS5cbiAqXG4gKiBAc2VlIElhdTIwMDBPcmllbnRhdGlvblxuICpcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIElhdU9yaWVudGF0aW9uQXhlcyhjb21wdXRlRnVuY3Rpb24pIHtcbiAgaWYgKCFkZWZpbmVkKGNvbXB1dGVGdW5jdGlvbikgfHwgdHlwZW9mIGNvbXB1dGVGdW5jdGlvbiAhPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgY29tcHV0ZUZ1bmN0aW9uID0gSWF1MjAwME9yaWVudGF0aW9uLkNvbXB1dGVNb29uO1xuICB9XG5cbiAgdGhpcy5fY29tcHV0ZUZ1bmN0aW9uID0gY29tcHV0ZUZ1bmN0aW9uO1xufVxuXG52YXIgeEF4aXNTY3JhdGNoID0gbmV3IENhcnRlc2lhbjMoKTtcbnZhciB5QXhpc1NjcmF0Y2ggPSBuZXcgQ2FydGVzaWFuMygpO1xudmFyIHpBeGlzU2NyYXRjaCA9IG5ldyBDYXJ0ZXNpYW4zKCk7XG5cbmZ1bmN0aW9uIGNvbXB1dGVSb3RhdGlvbk1hdHJpeChhbHBoYSwgZGVsdGEsIHJlc3VsdCkge1xuICB2YXIgeEF4aXMgPSB4QXhpc1NjcmF0Y2g7XG4gIHhBeGlzLnggPSBNYXRoLmNvcyhhbHBoYSArIENlc2l1bU1hdGguUElfT1ZFUl9UV08pO1xuICB4QXhpcy55ID0gTWF0aC5zaW4oYWxwaGEgKyBDZXNpdW1NYXRoLlBJX09WRVJfVFdPKTtcbiAgeEF4aXMueiA9IDAuMDtcblxuICB2YXIgY29zRGVjID0gTWF0aC5jb3MoZGVsdGEpO1xuXG4gIHZhciB6QXhpcyA9IHpBeGlzU2NyYXRjaDtcbiAgekF4aXMueCA9IGNvc0RlYyAqIE1hdGguY29zKGFscGhhKTtcbiAgekF4aXMueSA9IGNvc0RlYyAqIE1hdGguc2luKGFscGhhKTtcbiAgekF4aXMueiA9IE1hdGguc2luKGRlbHRhKTtcblxuICB2YXIgeUF4aXMgPSBDYXJ0ZXNpYW4zLmNyb3NzKHpBeGlzLCB4QXhpcywgeUF4aXNTY3JhdGNoKTtcblxuICBpZiAoIWRlZmluZWQocmVzdWx0KSkge1xuICAgIHJlc3VsdCA9IG5ldyBNYXRyaXgzKCk7XG4gIH1cblxuICByZXN1bHRbMF0gPSB4QXhpcy54O1xuICByZXN1bHRbMV0gPSB5QXhpcy54O1xuICByZXN1bHRbMl0gPSB6QXhpcy54O1xuICByZXN1bHRbM10gPSB4QXhpcy55O1xuICByZXN1bHRbNF0gPSB5QXhpcy55O1xuICByZXN1bHRbNV0gPSB6QXhpcy55O1xuICByZXN1bHRbNl0gPSB4QXhpcy56O1xuICByZXN1bHRbN10gPSB5QXhpcy56O1xuICByZXN1bHRbOF0gPSB6QXhpcy56O1xuXG4gIHJldHVybiByZXN1bHQ7XG59XG5cbnZhciByb3RNdHhTY3JhdGNoID0gbmV3IE1hdHJpeDMoKTtcbnZhciBxdWF0U2NyYXRjaCA9IG5ldyBRdWF0ZXJuaW9uKCk7XG5cbi8qKlxuICogQ29tcHV0ZXMgYSByb3RhdGlvbiBmcm9tIElDUkYgdG8gYSBHbG9iZSdzIEZpeGVkIGF4ZXMuXG4gKlxuICogQHBhcmFtIHtKdWxpYW5EYXRlfSBkYXRlIFRoZSBkYXRlIHRvIGV2YWx1YXRlIHRoZSBtYXRyaXguXG4gKiBAcGFyYW0ge01hdHJpeDN9IHJlc3VsdCBUaGUgb2JqZWN0IG9udG8gd2hpY2ggdG8gc3RvcmUgdGhlIHJlc3VsdC5cbiAqIEByZXR1cm5zIHtNYXRyaXgzfSBUaGUgbW9kaWZpZWQgcmVzdWx0IHBhcmFtZXRlciBvciBhIG5ldyBpbnN0YW5jZSBvZiB0aGUgcm90YXRpb24gZnJvbSBJQ1JGIHRvIEZpeGVkLlxuICovXG5JYXVPcmllbnRhdGlvbkF4ZXMucHJvdG90eXBlLmV2YWx1YXRlID0gZnVuY3Rpb24gKGRhdGUsIHJlc3VsdCkge1xuICBpZiAoIWRlZmluZWQoZGF0ZSkpIHtcbiAgICBkYXRlID0gSnVsaWFuRGF0ZS5ub3coKTtcbiAgfVxuXG4gIHZhciBhbHBoYURlbHRhVyA9IHRoaXMuX2NvbXB1dGVGdW5jdGlvbihkYXRlKTtcbiAgdmFyIHByZWNNdHggPSBjb21wdXRlUm90YXRpb25NYXRyaXgoXG4gICAgYWxwaGFEZWx0YVcucmlnaHRBc2NlbnNpb24sXG4gICAgYWxwaGFEZWx0YVcuZGVjbGluYXRpb24sXG4gICAgcmVzdWx0XG4gICk7XG5cbiAgdmFyIHJvdCA9IENlc2l1bU1hdGguemVyb1RvVHdvUGkoYWxwaGFEZWx0YVcucm90YXRpb24pO1xuICB2YXIgcXVhdCA9IFF1YXRlcm5pb24uZnJvbUF4aXNBbmdsZShDYXJ0ZXNpYW4zLlVOSVRfWiwgcm90LCBxdWF0U2NyYXRjaCk7XG4gIHZhciByb3RNdHggPSBNYXRyaXgzLmZyb21RdWF0ZXJuaW9uKFxuICAgIFF1YXRlcm5pb24uY29uanVnYXRlKHF1YXQsIHF1YXQpLFxuICAgIHJvdE10eFNjcmF0Y2hcbiAgKTtcblxuICB2YXIgY2JpMmNiZiA9IE1hdHJpeDMubXVsdGlwbHkocm90TXR4LCBwcmVjTXR4LCBwcmVjTXR4KTtcbiAgcmV0dXJuIGNiaTJjYmY7XG59O1xuXG4vKipcbiAqIEEgZnVuY3Rpb24gdGhhdCBjb21wdXRlcyB0aGUge0BsaW5rIElhdU9yaWVudGF0aW9uUGFyYW1ldGVyc30gZm9yIGEge0BsaW5rIEp1bGlhbkRhdGV9LlxuICogQGNhbGxiYWNrIElhdU9yaWVudGF0aW9uQXhlcy5Db21wdXRlRnVuY3Rpb25cbiAqIEBwYXJhbSB7SnVsaWFuRGF0ZX0gZGF0ZSBUaGUgZGF0ZSB0byBldmFsdWF0ZSB0aGUgcGFyYW1ldGVycy5cbiAqIEByZXR1cm5zIHtJYXVPcmllbnRhdGlvblBhcmFtZXRlcnN9IFRoZSBvcmllbnRhdGlvbiBwYXJhbWV0ZXJzLlxuICogQHByaXZhdGVcbiAqL1xuZXhwb3J0IGRlZmF1bHQgSWF1T3JpZW50YXRpb25BeGVzO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///23628\n')},22832:function(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__){eval('/* harmony import */ var _defined_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(82982);\n/* harmony import */ var _DeveloperError_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(12572);\n/* harmony import */ var _Math_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(99417);\n/* harmony import */ var _WebGLConstants_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(52200);\n\n\n\n\n\n/**\n * Constants for WebGL index datatypes.  These corresponds to the\n * <code>type</code> parameter of {@link http://www.khronos.org/opengles/sdk/docs/man/xhtml/glDrawElements.xml|drawElements}.\n *\n * @enum {Number}\n */\nvar IndexDatatype = {\n  /**\n   * 8-bit unsigned byte corresponding to <code>UNSIGNED_BYTE</code> and the type\n   * of an element in <code>Uint8Array</code>.\n   *\n   * @type {Number}\n   * @constant\n   */\n  UNSIGNED_BYTE: _WebGLConstants_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"].UNSIGNED_BYTE */ .Z.UNSIGNED_BYTE,\n\n  /**\n   * 16-bit unsigned short corresponding to <code>UNSIGNED_SHORT</code> and the type\n   * of an element in <code>Uint16Array</code>.\n   *\n   * @type {Number}\n   * @constant\n   */\n  UNSIGNED_SHORT: _WebGLConstants_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"].UNSIGNED_SHORT */ .Z.UNSIGNED_SHORT,\n\n  /**\n   * 32-bit unsigned int corresponding to <code>UNSIGNED_INT</code> and the type\n   * of an element in <code>Uint32Array</code>.\n   *\n   * @type {Number}\n   * @constant\n   */\n  UNSIGNED_INT: _WebGLConstants_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"].UNSIGNED_INT */ .Z.UNSIGNED_INT,\n};\n\n/**\n * Returns the size, in bytes, of the corresponding datatype.\n *\n * @param {IndexDatatype} indexDatatype The index datatype to get the size of.\n * @returns {Number} The size in bytes.\n *\n * @example\n * // Returns 2\n * var size = Cesium.IndexDatatype.getSizeInBytes(Cesium.IndexDatatype.UNSIGNED_SHORT);\n */\nIndexDatatype.getSizeInBytes = function (indexDatatype) {\n  switch (indexDatatype) {\n    case IndexDatatype.UNSIGNED_BYTE:\n      return Uint8Array.BYTES_PER_ELEMENT;\n    case IndexDatatype.UNSIGNED_SHORT:\n      return Uint16Array.BYTES_PER_ELEMENT;\n    case IndexDatatype.UNSIGNED_INT:\n      return Uint32Array.BYTES_PER_ELEMENT;\n  }\n\n  //>>includeStart(\'debug\', pragmas.debug);\n  throw new _DeveloperError_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .Z(\n    "indexDatatype is required and must be a valid IndexDatatype constant."\n  );\n  //>>includeEnd(\'debug\');\n};\n\n/**\n * Gets the datatype with a given size in bytes.\n *\n * @param {Number} sizeInBytes The size of a single index in bytes.\n * @returns {IndexDatatype} The index datatype with the given size.\n */\nIndexDatatype.fromSizeInBytes = function (sizeInBytes) {\n  switch (sizeInBytes) {\n    case 2:\n      return IndexDatatype.UNSIGNED_SHORT;\n    case 4:\n      return IndexDatatype.UNSIGNED_INT;\n    case 1:\n      return IndexDatatype.UNSIGNED_BYTE;\n    //>>includeStart(\'debug\', pragmas.debug);\n    default:\n      throw new _DeveloperError_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .Z(\n        "Size in bytes cannot be mapped to an IndexDatatype"\n      );\n    //>>includeEnd(\'debug\');\n  }\n};\n\n/**\n * Validates that the provided index datatype is a valid {@link IndexDatatype}.\n *\n * @param {IndexDatatype} indexDatatype The index datatype to validate.\n * @returns {Boolean} <code>true</code> if the provided index datatype is a valid value; otherwise, <code>false</code>.\n *\n * @example\n * if (!Cesium.IndexDatatype.validate(indexDatatype)) {\n *   throw new Cesium.DeveloperError(\'indexDatatype must be a valid value.\');\n * }\n */\nIndexDatatype.validate = function (indexDatatype) {\n  return (\n    (0,_defined_js__WEBPACK_IMPORTED_MODULE_3__/* ["default"] */ .Z)(indexDatatype) &&\n    (indexDatatype === IndexDatatype.UNSIGNED_BYTE ||\n      indexDatatype === IndexDatatype.UNSIGNED_SHORT ||\n      indexDatatype === IndexDatatype.UNSIGNED_INT)\n  );\n};\n\n/**\n * Creates a typed array that will store indices, using either <code><Uint16Array</code>\n * or <code>Uint32Array</code> depending on the number of vertices.\n *\n * @param {Number} numberOfVertices Number of vertices that the indices will reference.\n * @param {Number|Array} indicesLengthOrArray Passed through to the typed array constructor.\n * @returns {Uint16Array|Uint32Array} A <code>Uint16Array</code> or <code>Uint32Array</code> constructed with <code>indicesLengthOrArray</code>.\n *\n * @example\n * this.indices = Cesium.IndexDatatype.createTypedArray(positions.length / 3, numberOfIndices);\n */\nIndexDatatype.createTypedArray = function (\n  numberOfVertices,\n  indicesLengthOrArray\n) {\n  //>>includeStart(\'debug\', pragmas.debug);\n  if (!(0,_defined_js__WEBPACK_IMPORTED_MODULE_3__/* ["default"] */ .Z)(numberOfVertices)) {\n    throw new _DeveloperError_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .Z("numberOfVertices is required.");\n  }\n  //>>includeEnd(\'debug\');\n\n  if (numberOfVertices >= _Math_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"].SIXTY_FOUR_KILOBYTES */ .Z.SIXTY_FOUR_KILOBYTES) {\n    return new Uint32Array(indicesLengthOrArray);\n  }\n\n  return new Uint16Array(indicesLengthOrArray);\n};\n\n/**\n * Creates a typed array from a source array buffer.  The resulting typed array will store indices, using either <code><Uint16Array</code>\n * or <code>Uint32Array</code> depending on the number of vertices.\n *\n * @param {Number} numberOfVertices Number of vertices that the indices will reference.\n * @param {ArrayBuffer} sourceArray Passed through to the typed array constructor.\n * @param {Number} byteOffset Passed through to the typed array constructor.\n * @param {Number} length Passed through to the typed array constructor.\n * @returns {Uint16Array|Uint32Array} A <code>Uint16Array</code> or <code>Uint32Array</code> constructed with <code>sourceArray</code>, <code>byteOffset</code>, and <code>length</code>.\n *\n */\nIndexDatatype.createTypedArrayFromArrayBuffer = function (\n  numberOfVertices,\n  sourceArray,\n  byteOffset,\n  length\n) {\n  //>>includeStart(\'debug\', pragmas.debug);\n  if (!(0,_defined_js__WEBPACK_IMPORTED_MODULE_3__/* ["default"] */ .Z)(numberOfVertices)) {\n    throw new _DeveloperError_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .Z("numberOfVertices is required.");\n  }\n  if (!(0,_defined_js__WEBPACK_IMPORTED_MODULE_3__/* ["default"] */ .Z)(sourceArray)) {\n    throw new _DeveloperError_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .Z("sourceArray is required.");\n  }\n  if (!(0,_defined_js__WEBPACK_IMPORTED_MODULE_3__/* ["default"] */ .Z)(byteOffset)) {\n    throw new _DeveloperError_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .Z("byteOffset is required.");\n  }\n  //>>includeEnd(\'debug\');\n\n  if (numberOfVertices >= _Math_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"].SIXTY_FOUR_KILOBYTES */ .Z.SIXTY_FOUR_KILOBYTES) {\n    return new Uint32Array(sourceArray, byteOffset, length);\n  }\n\n  return new Uint16Array(sourceArray, byteOffset, length);\n};\n/* harmony default export */ __webpack_exports__["Z"] = (Object.freeze(IndexDatatype));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjI4MzIuanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFtQztBQUNjO0FBQ2Q7QUFDYzs7QUFFakQ7QUFDQTtBQUNBLG1DQUFtQyx5RkFBeUY7QUFDNUg7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQSxpQkFBaUIsK0ZBQTRCOztBQUU3QztBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0Esa0JBQWtCLGlHQUE2Qjs7QUFFL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBLGdCQUFnQiw2RkFBMkI7QUFDM0M7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxlQUFlO0FBQzFCLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsWUFBWSxtRUFBYztBQUMxQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsYUFBYSxlQUFlO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsbUVBQWM7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDBEQUEwRCxvQkFBb0I7QUFDOUU7QUFDQSxXQUFXLGVBQWU7QUFDMUIsYUFBYSxTQUFTLG1FQUFtRTtBQUN6RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSxnRUFBTztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxjQUFjO0FBQ3pCLGFBQWEseUJBQXlCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU8sZ0VBQU87QUFDZCxjQUFjLG1FQUFjO0FBQzVCO0FBQ0E7O0FBRUEsMEJBQTBCLG1HQUErQjtBQUN6RDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxhQUFhO0FBQ3hCLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsYUFBYSx5QkFBeUI7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTyxnRUFBTztBQUNkLGNBQWMsbUVBQWM7QUFDNUI7QUFDQSxPQUFPLGdFQUFPO0FBQ2QsY0FBYyxtRUFBYztBQUM1QjtBQUNBLE9BQU8sZ0VBQU87QUFDZCxjQUFjLG1FQUFjO0FBQzVCO0FBQ0E7O0FBRUEsMEJBQTBCLG1HQUErQjtBQUN6RDtBQUNBOztBQUVBO0FBQ0E7QUFDQSx5REFBZSw0QkFBNEIsRUFBQyIsInNvdXJjZXMiOlsid2VicGFjazovL3Z1ZTMtd2VicGFjazUvLi9ub2RlX21vZHVsZXMvY2VzaXVtL1NvdXJjZS9Db3JlL0luZGV4RGF0YXR5cGUuanM/N2U1NCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgZGVmaW5lZCBmcm9tIFwiLi9kZWZpbmVkLmpzXCI7XG5pbXBvcnQgRGV2ZWxvcGVyRXJyb3IgZnJvbSBcIi4vRGV2ZWxvcGVyRXJyb3IuanNcIjtcbmltcG9ydCBDZXNpdW1NYXRoIGZyb20gXCIuL01hdGguanNcIjtcbmltcG9ydCBXZWJHTENvbnN0YW50cyBmcm9tIFwiLi9XZWJHTENvbnN0YW50cy5qc1wiO1xuXG4vKipcbiAqIENvbnN0YW50cyBmb3IgV2ViR0wgaW5kZXggZGF0YXR5cGVzLiAgVGhlc2UgY29ycmVzcG9uZHMgdG8gdGhlXG4gKiA8Y29kZT50eXBlPC9jb2RlPiBwYXJhbWV0ZXIgb2Yge0BsaW5rIGh0dHA6Ly93d3cua2hyb25vcy5vcmcvb3BlbmdsZXMvc2RrL2RvY3MvbWFuL3hodG1sL2dsRHJhd0VsZW1lbnRzLnhtbHxkcmF3RWxlbWVudHN9LlxuICpcbiAqIEBlbnVtIHtOdW1iZXJ9XG4gKi9cbnZhciBJbmRleERhdGF0eXBlID0ge1xuICAvKipcbiAgICogOC1iaXQgdW5zaWduZWQgYnl0ZSBjb3JyZXNwb25kaW5nIHRvIDxjb2RlPlVOU0lHTkVEX0JZVEU8L2NvZGU+IGFuZCB0aGUgdHlwZVxuICAgKiBvZiBhbiBlbGVtZW50IGluIDxjb2RlPlVpbnQ4QXJyYXk8L2NvZGU+LlxuICAgKlxuICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgKiBAY29uc3RhbnRcbiAgICovXG4gIFVOU0lHTkVEX0JZVEU6IFdlYkdMQ29uc3RhbnRzLlVOU0lHTkVEX0JZVEUsXG5cbiAgLyoqXG4gICAqIDE2LWJpdCB1bnNpZ25lZCBzaG9ydCBjb3JyZXNwb25kaW5nIHRvIDxjb2RlPlVOU0lHTkVEX1NIT1JUPC9jb2RlPiBhbmQgdGhlIHR5cGVcbiAgICogb2YgYW4gZWxlbWVudCBpbiA8Y29kZT5VaW50MTZBcnJheTwvY29kZT4uXG4gICAqXG4gICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAqIEBjb25zdGFudFxuICAgKi9cbiAgVU5TSUdORURfU0hPUlQ6IFdlYkdMQ29uc3RhbnRzLlVOU0lHTkVEX1NIT1JULFxuXG4gIC8qKlxuICAgKiAzMi1iaXQgdW5zaWduZWQgaW50IGNvcnJlc3BvbmRpbmcgdG8gPGNvZGU+VU5TSUdORURfSU5UPC9jb2RlPiBhbmQgdGhlIHR5cGVcbiAgICogb2YgYW4gZWxlbWVudCBpbiA8Y29kZT5VaW50MzJBcnJheTwvY29kZT4uXG4gICAqXG4gICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAqIEBjb25zdGFudFxuICAgKi9cbiAgVU5TSUdORURfSU5UOiBXZWJHTENvbnN0YW50cy5VTlNJR05FRF9JTlQsXG59O1xuXG4vKipcbiAqIFJldHVybnMgdGhlIHNpemUsIGluIGJ5dGVzLCBvZiB0aGUgY29ycmVzcG9uZGluZyBkYXRhdHlwZS5cbiAqXG4gKiBAcGFyYW0ge0luZGV4RGF0YXR5cGV9IGluZGV4RGF0YXR5cGUgVGhlIGluZGV4IGRhdGF0eXBlIHRvIGdldCB0aGUgc2l6ZSBvZi5cbiAqIEByZXR1cm5zIHtOdW1iZXJ9IFRoZSBzaXplIGluIGJ5dGVzLlxuICpcbiAqIEBleGFtcGxlXG4gKiAvLyBSZXR1cm5zIDJcbiAqIHZhciBzaXplID0gQ2VzaXVtLkluZGV4RGF0YXR5cGUuZ2V0U2l6ZUluQnl0ZXMoQ2VzaXVtLkluZGV4RGF0YXR5cGUuVU5TSUdORURfU0hPUlQpO1xuICovXG5JbmRleERhdGF0eXBlLmdldFNpemVJbkJ5dGVzID0gZnVuY3Rpb24gKGluZGV4RGF0YXR5cGUpIHtcbiAgc3dpdGNoIChpbmRleERhdGF0eXBlKSB7XG4gICAgY2FzZSBJbmRleERhdGF0eXBlLlVOU0lHTkVEX0JZVEU6XG4gICAgICByZXR1cm4gVWludDhBcnJheS5CWVRFU19QRVJfRUxFTUVOVDtcbiAgICBjYXNlIEluZGV4RGF0YXR5cGUuVU5TSUdORURfU0hPUlQ6XG4gICAgICByZXR1cm4gVWludDE2QXJyYXkuQllURVNfUEVSX0VMRU1FTlQ7XG4gICAgY2FzZSBJbmRleERhdGF0eXBlLlVOU0lHTkVEX0lOVDpcbiAgICAgIHJldHVybiBVaW50MzJBcnJheS5CWVRFU19QRVJfRUxFTUVOVDtcbiAgfVxuXG4gIC8vPj5pbmNsdWRlU3RhcnQoJ2RlYnVnJywgcHJhZ21hcy5kZWJ1Zyk7XG4gIHRocm93IG5ldyBEZXZlbG9wZXJFcnJvcihcbiAgICBcImluZGV4RGF0YXR5cGUgaXMgcmVxdWlyZWQgYW5kIG11c3QgYmUgYSB2YWxpZCBJbmRleERhdGF0eXBlIGNvbnN0YW50LlwiXG4gICk7XG4gIC8vPj5pbmNsdWRlRW5kKCdkZWJ1ZycpO1xufTtcblxuLyoqXG4gKiBHZXRzIHRoZSBkYXRhdHlwZSB3aXRoIGEgZ2l2ZW4gc2l6ZSBpbiBieXRlcy5cbiAqXG4gKiBAcGFyYW0ge051bWJlcn0gc2l6ZUluQnl0ZXMgVGhlIHNpemUgb2YgYSBzaW5nbGUgaW5kZXggaW4gYnl0ZXMuXG4gKiBAcmV0dXJucyB7SW5kZXhEYXRhdHlwZX0gVGhlIGluZGV4IGRhdGF0eXBlIHdpdGggdGhlIGdpdmVuIHNpemUuXG4gKi9cbkluZGV4RGF0YXR5cGUuZnJvbVNpemVJbkJ5dGVzID0gZnVuY3Rpb24gKHNpemVJbkJ5dGVzKSB7XG4gIHN3aXRjaCAoc2l6ZUluQnl0ZXMpIHtcbiAgICBjYXNlIDI6XG4gICAgICByZXR1cm4gSW5kZXhEYXRhdHlwZS5VTlNJR05FRF9TSE9SVDtcbiAgICBjYXNlIDQ6XG4gICAgICByZXR1cm4gSW5kZXhEYXRhdHlwZS5VTlNJR05FRF9JTlQ7XG4gICAgY2FzZSAxOlxuICAgICAgcmV0dXJuIEluZGV4RGF0YXR5cGUuVU5TSUdORURfQllURTtcbiAgICAvLz4+aW5jbHVkZVN0YXJ0KCdkZWJ1ZycsIHByYWdtYXMuZGVidWcpO1xuICAgIGRlZmF1bHQ6XG4gICAgICB0aHJvdyBuZXcgRGV2ZWxvcGVyRXJyb3IoXG4gICAgICAgIFwiU2l6ZSBpbiBieXRlcyBjYW5ub3QgYmUgbWFwcGVkIHRvIGFuIEluZGV4RGF0YXR5cGVcIlxuICAgICAgKTtcbiAgICAvLz4+aW5jbHVkZUVuZCgnZGVidWcnKTtcbiAgfVxufTtcblxuLyoqXG4gKiBWYWxpZGF0ZXMgdGhhdCB0aGUgcHJvdmlkZWQgaW5kZXggZGF0YXR5cGUgaXMgYSB2YWxpZCB7QGxpbmsgSW5kZXhEYXRhdHlwZX0uXG4gKlxuICogQHBhcmFtIHtJbmRleERhdGF0eXBlfSBpbmRleERhdGF0eXBlIFRoZSBpbmRleCBkYXRhdHlwZSB0byB2YWxpZGF0ZS5cbiAqIEByZXR1cm5zIHtCb29sZWFufSA8Y29kZT50cnVlPC9jb2RlPiBpZiB0aGUgcHJvdmlkZWQgaW5kZXggZGF0YXR5cGUgaXMgYSB2YWxpZCB2YWx1ZTsgb3RoZXJ3aXNlLCA8Y29kZT5mYWxzZTwvY29kZT4uXG4gKlxuICogQGV4YW1wbGVcbiAqIGlmICghQ2VzaXVtLkluZGV4RGF0YXR5cGUudmFsaWRhdGUoaW5kZXhEYXRhdHlwZSkpIHtcbiAqICAgdGhyb3cgbmV3IENlc2l1bS5EZXZlbG9wZXJFcnJvcignaW5kZXhEYXRhdHlwZSBtdXN0IGJlIGEgdmFsaWQgdmFsdWUuJyk7XG4gKiB9XG4gKi9cbkluZGV4RGF0YXR5cGUudmFsaWRhdGUgPSBmdW5jdGlvbiAoaW5kZXhEYXRhdHlwZSkge1xuICByZXR1cm4gKFxuICAgIGRlZmluZWQoaW5kZXhEYXRhdHlwZSkgJiZcbiAgICAoaW5kZXhEYXRhdHlwZSA9PT0gSW5kZXhEYXRhdHlwZS5VTlNJR05FRF9CWVRFIHx8XG4gICAgICBpbmRleERhdGF0eXBlID09PSBJbmRleERhdGF0eXBlLlVOU0lHTkVEX1NIT1JUIHx8XG4gICAgICBpbmRleERhdGF0eXBlID09PSBJbmRleERhdGF0eXBlLlVOU0lHTkVEX0lOVClcbiAgKTtcbn07XG5cbi8qKlxuICogQ3JlYXRlcyBhIHR5cGVkIGFycmF5IHRoYXQgd2lsbCBzdG9yZSBpbmRpY2VzLCB1c2luZyBlaXRoZXIgPGNvZGU+PFVpbnQxNkFycmF5PC9jb2RlPlxuICogb3IgPGNvZGU+VWludDMyQXJyYXk8L2NvZGU+IGRlcGVuZGluZyBvbiB0aGUgbnVtYmVyIG9mIHZlcnRpY2VzLlxuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSBudW1iZXJPZlZlcnRpY2VzIE51bWJlciBvZiB2ZXJ0aWNlcyB0aGF0IHRoZSBpbmRpY2VzIHdpbGwgcmVmZXJlbmNlLlxuICogQHBhcmFtIHtOdW1iZXJ8QXJyYXl9IGluZGljZXNMZW5ndGhPckFycmF5IFBhc3NlZCB0aHJvdWdoIHRvIHRoZSB0eXBlZCBhcnJheSBjb25zdHJ1Y3Rvci5cbiAqIEByZXR1cm5zIHtVaW50MTZBcnJheXxVaW50MzJBcnJheX0gQSA8Y29kZT5VaW50MTZBcnJheTwvY29kZT4gb3IgPGNvZGU+VWludDMyQXJyYXk8L2NvZGU+IGNvbnN0cnVjdGVkIHdpdGggPGNvZGU+aW5kaWNlc0xlbmd0aE9yQXJyYXk8L2NvZGU+LlxuICpcbiAqIEBleGFtcGxlXG4gKiB0aGlzLmluZGljZXMgPSBDZXNpdW0uSW5kZXhEYXRhdHlwZS5jcmVhdGVUeXBlZEFycmF5KHBvc2l0aW9ucy5sZW5ndGggLyAzLCBudW1iZXJPZkluZGljZXMpO1xuICovXG5JbmRleERhdGF0eXBlLmNyZWF0ZVR5cGVkQXJyYXkgPSBmdW5jdGlvbiAoXG4gIG51bWJlck9mVmVydGljZXMsXG4gIGluZGljZXNMZW5ndGhPckFycmF5XG4pIHtcbiAgLy8+PmluY2x1ZGVTdGFydCgnZGVidWcnLCBwcmFnbWFzLmRlYnVnKTtcbiAgaWYgKCFkZWZpbmVkKG51bWJlck9mVmVydGljZXMpKSB7XG4gICAgdGhyb3cgbmV3IERldmVsb3BlckVycm9yKFwibnVtYmVyT2ZWZXJ0aWNlcyBpcyByZXF1aXJlZC5cIik7XG4gIH1cbiAgLy8+PmluY2x1ZGVFbmQoJ2RlYnVnJyk7XG5cbiAgaWYgKG51bWJlck9mVmVydGljZXMgPj0gQ2VzaXVtTWF0aC5TSVhUWV9GT1VSX0tJTE9CWVRFUykge1xuICAgIHJldHVybiBuZXcgVWludDMyQXJyYXkoaW5kaWNlc0xlbmd0aE9yQXJyYXkpO1xuICB9XG5cbiAgcmV0dXJuIG5ldyBVaW50MTZBcnJheShpbmRpY2VzTGVuZ3RoT3JBcnJheSk7XG59O1xuXG4vKipcbiAqIENyZWF0ZXMgYSB0eXBlZCBhcnJheSBmcm9tIGEgc291cmNlIGFycmF5IGJ1ZmZlci4gIFRoZSByZXN1bHRpbmcgdHlwZWQgYXJyYXkgd2lsbCBzdG9yZSBpbmRpY2VzLCB1c2luZyBlaXRoZXIgPGNvZGU+PFVpbnQxNkFycmF5PC9jb2RlPlxuICogb3IgPGNvZGU+VWludDMyQXJyYXk8L2NvZGU+IGRlcGVuZGluZyBvbiB0aGUgbnVtYmVyIG9mIHZlcnRpY2VzLlxuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSBudW1iZXJPZlZlcnRpY2VzIE51bWJlciBvZiB2ZXJ0aWNlcyB0aGF0IHRoZSBpbmRpY2VzIHdpbGwgcmVmZXJlbmNlLlxuICogQHBhcmFtIHtBcnJheUJ1ZmZlcn0gc291cmNlQXJyYXkgUGFzc2VkIHRocm91Z2ggdG8gdGhlIHR5cGVkIGFycmF5IGNvbnN0cnVjdG9yLlxuICogQHBhcmFtIHtOdW1iZXJ9IGJ5dGVPZmZzZXQgUGFzc2VkIHRocm91Z2ggdG8gdGhlIHR5cGVkIGFycmF5IGNvbnN0cnVjdG9yLlxuICogQHBhcmFtIHtOdW1iZXJ9IGxlbmd0aCBQYXNzZWQgdGhyb3VnaCB0byB0aGUgdHlwZWQgYXJyYXkgY29uc3RydWN0b3IuXG4gKiBAcmV0dXJucyB7VWludDE2QXJyYXl8VWludDMyQXJyYXl9IEEgPGNvZGU+VWludDE2QXJyYXk8L2NvZGU+IG9yIDxjb2RlPlVpbnQzMkFycmF5PC9jb2RlPiBjb25zdHJ1Y3RlZCB3aXRoIDxjb2RlPnNvdXJjZUFycmF5PC9jb2RlPiwgPGNvZGU+Ynl0ZU9mZnNldDwvY29kZT4sIGFuZCA8Y29kZT5sZW5ndGg8L2NvZGU+LlxuICpcbiAqL1xuSW5kZXhEYXRhdHlwZS5jcmVhdGVUeXBlZEFycmF5RnJvbUFycmF5QnVmZmVyID0gZnVuY3Rpb24gKFxuICBudW1iZXJPZlZlcnRpY2VzLFxuICBzb3VyY2VBcnJheSxcbiAgYnl0ZU9mZnNldCxcbiAgbGVuZ3RoXG4pIHtcbiAgLy8+PmluY2x1ZGVTdGFydCgnZGVidWcnLCBwcmFnbWFzLmRlYnVnKTtcbiAgaWYgKCFkZWZpbmVkKG51bWJlck9mVmVydGljZXMpKSB7XG4gICAgdGhyb3cgbmV3IERldmVsb3BlckVycm9yKFwibnVtYmVyT2ZWZXJ0aWNlcyBpcyByZXF1aXJlZC5cIik7XG4gIH1cbiAgaWYgKCFkZWZpbmVkKHNvdXJjZUFycmF5KSkge1xuICAgIHRocm93IG5ldyBEZXZlbG9wZXJFcnJvcihcInNvdXJjZUFycmF5IGlzIHJlcXVpcmVkLlwiKTtcbiAgfVxuICBpZiAoIWRlZmluZWQoYnl0ZU9mZnNldCkpIHtcbiAgICB0aHJvdyBuZXcgRGV2ZWxvcGVyRXJyb3IoXCJieXRlT2Zmc2V0IGlzIHJlcXVpcmVkLlwiKTtcbiAgfVxuICAvLz4+aW5jbHVkZUVuZCgnZGVidWcnKTtcblxuICBpZiAobnVtYmVyT2ZWZXJ0aWNlcyA+PSBDZXNpdW1NYXRoLlNJWFRZX0ZPVVJfS0lMT0JZVEVTKSB7XG4gICAgcmV0dXJuIG5ldyBVaW50MzJBcnJheShzb3VyY2VBcnJheSwgYnl0ZU9mZnNldCwgbGVuZ3RoKTtcbiAgfVxuXG4gIHJldHVybiBuZXcgVWludDE2QXJyYXkoc291cmNlQXJyYXksIGJ5dGVPZmZzZXQsIGxlbmd0aCk7XG59O1xuZXhwb3J0IGRlZmF1bHQgT2JqZWN0LmZyZWV6ZShJbmRleERhdGF0eXBlKTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///22832\n')},35739:function(__unused_webpack___webpack_module__,__unused_webpack___webpack_exports__,__webpack_require__){eval('/* harmony import */ var _DeveloperError_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(12572);\n\n\n/**\n * The interface for interpolation algorithms.\n *\n * @interface InterpolationAlgorithm\n *\n * @see LagrangePolynomialApproximation\n * @see LinearApproximation\n * @see HermitePolynomialApproximation\n */\nvar InterpolationAlgorithm = {};\n\n/**\n * Gets the name of this interpolation algorithm.\n * @type {String}\n */\nInterpolationAlgorithm.type = undefined;\n\n/**\n * Given the desired degree, returns the number of data points required for interpolation.\n * @function\n *\n * @param {Number} degree The desired degree of interpolation.\n * @returns {Number} The number of required data points needed for the desired degree of interpolation.\n */\nInterpolationAlgorithm.getRequiredDataPoints =\n  _DeveloperError_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].throwInstantiationError */ .Z.throwInstantiationError;\n\n/**\n * Performs zero order interpolation.\n * @function\n *\n * @param {Number} x The independent variable for which the dependent variables will be interpolated.\n * @param {Number[]} xTable The array of independent variables to use to interpolate.  The values\n * in this array must be in increasing order and the same value must not occur twice in the array.\n * @param {Number[]} yTable The array of dependent variables to use to interpolate.  For a set of three\n * dependent values (p,q,w) at time 1 and time 2 this should be as follows: {p1, q1, w1, p2, q2, w2}.\n * @param {Number} yStride The number of dependent variable values in yTable corresponding to\n * each independent variable value in xTable.\n * @param {Number[]} [result] An existing array into which to store the result.\n *\n * @returns {Number[]} The array of interpolated values, or the result parameter if one was provided.\n */\nInterpolationAlgorithm.interpolateOrderZero =\n  _DeveloperError_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].throwInstantiationError */ .Z.throwInstantiationError;\n\n/**\n * Performs higher order interpolation.  Not all interpolators need to support high-order interpolation,\n * if this function remains undefined on implementing objects, interpolateOrderZero will be used instead.\n * @function\n * @param {Number} x The independent variable for which the dependent variables will be interpolated.\n * @param {Number[]} xTable The array of independent variables to use to interpolate.  The values\n * in this array must be in increasing order and the same value must not occur twice in the array.\n * @param {Number[]} yTable The array of dependent variables to use to interpolate.  For a set of three\n * dependent values (p,q,w) at time 1 and time 2 this should be as follows: {p1, q1, w1, p2, q2, w2}.\n * @param {Number} yStride The number of dependent variable values in yTable corresponding to\n * each independent variable value in xTable.\n * @param {Number} inputOrder The number of derivatives supplied for input.\n * @param {Number} outputOrder The number of derivatives desired for output.\n * @param {Number[]} [result] An existing array into which to store the result.\n * @returns {Number[]} The array of interpolated values, or the result parameter if one was provided.\n */\nInterpolationAlgorithm.interpolate = _DeveloperError_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].throwInstantiationError */ .Z.throwInstantiationError;\n/* unused harmony default export */ var __WEBPACK_DEFAULT_EXPORT__ = ((/* unused pure expression or super */ null && (InterpolationAlgorithm)));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMzU3MzkuanMiLCJtYXBwaW5ncyI6IjtBQUFpRDs7QUFFakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0EsRUFBRSxtSEFBc0M7O0FBRXhDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsVUFBVTtBQUNyQjtBQUNBLFdBQVcsVUFBVTtBQUNyQiw2RUFBNkUsdUJBQXVCO0FBQ3BHLFdBQVcsUUFBUTtBQUNuQjtBQUNBLFdBQVcsVUFBVTtBQUNyQjtBQUNBLGFBQWEsVUFBVTtBQUN2QjtBQUNBO0FBQ0EsRUFBRSxtSEFBc0M7O0FBRXhDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsVUFBVTtBQUNyQjtBQUNBLFdBQVcsVUFBVTtBQUNyQiw2RUFBNkUsdUJBQXVCO0FBQ3BHLFdBQVcsUUFBUTtBQUNuQjtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxVQUFVO0FBQ3JCLGFBQWEsVUFBVTtBQUN2QjtBQUNBLHFDQUFxQyxtSEFBc0M7QUFDM0Usc0VBQWUsc0VBQXNCLElBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly92dWUzLXdlYnBhY2s1Ly4vbm9kZV9tb2R1bGVzL2Nlc2l1bS9Tb3VyY2UvQ29yZS9JbnRlcnBvbGF0aW9uQWxnb3JpdGhtLmpzPzczYjUiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IERldmVsb3BlckVycm9yIGZyb20gXCIuL0RldmVsb3BlckVycm9yLmpzXCI7XG5cbi8qKlxuICogVGhlIGludGVyZmFjZSBmb3IgaW50ZXJwb2xhdGlvbiBhbGdvcml0aG1zLlxuICpcbiAqIEBpbnRlcmZhY2UgSW50ZXJwb2xhdGlvbkFsZ29yaXRobVxuICpcbiAqIEBzZWUgTGFncmFuZ2VQb2x5bm9taWFsQXBwcm94aW1hdGlvblxuICogQHNlZSBMaW5lYXJBcHByb3hpbWF0aW9uXG4gKiBAc2VlIEhlcm1pdGVQb2x5bm9taWFsQXBwcm94aW1hdGlvblxuICovXG52YXIgSW50ZXJwb2xhdGlvbkFsZ29yaXRobSA9IHt9O1xuXG4vKipcbiAqIEdldHMgdGhlIG5hbWUgb2YgdGhpcyBpbnRlcnBvbGF0aW9uIGFsZ29yaXRobS5cbiAqIEB0eXBlIHtTdHJpbmd9XG4gKi9cbkludGVycG9sYXRpb25BbGdvcml0aG0udHlwZSA9IHVuZGVmaW5lZDtcblxuLyoqXG4gKiBHaXZlbiB0aGUgZGVzaXJlZCBkZWdyZWUsIHJldHVybnMgdGhlIG51bWJlciBvZiBkYXRhIHBvaW50cyByZXF1aXJlZCBmb3IgaW50ZXJwb2xhdGlvbi5cbiAqIEBmdW5jdGlvblxuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSBkZWdyZWUgVGhlIGRlc2lyZWQgZGVncmVlIG9mIGludGVycG9sYXRpb24uXG4gKiBAcmV0dXJucyB7TnVtYmVyfSBUaGUgbnVtYmVyIG9mIHJlcXVpcmVkIGRhdGEgcG9pbnRzIG5lZWRlZCBmb3IgdGhlIGRlc2lyZWQgZGVncmVlIG9mIGludGVycG9sYXRpb24uXG4gKi9cbkludGVycG9sYXRpb25BbGdvcml0aG0uZ2V0UmVxdWlyZWREYXRhUG9pbnRzID1cbiAgRGV2ZWxvcGVyRXJyb3IudGhyb3dJbnN0YW50aWF0aW9uRXJyb3I7XG5cbi8qKlxuICogUGVyZm9ybXMgemVybyBvcmRlciBpbnRlcnBvbGF0aW9uLlxuICogQGZ1bmN0aW9uXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IHggVGhlIGluZGVwZW5kZW50IHZhcmlhYmxlIGZvciB3aGljaCB0aGUgZGVwZW5kZW50IHZhcmlhYmxlcyB3aWxsIGJlIGludGVycG9sYXRlZC5cbiAqIEBwYXJhbSB7TnVtYmVyW119IHhUYWJsZSBUaGUgYXJyYXkgb2YgaW5kZXBlbmRlbnQgdmFyaWFibGVzIHRvIHVzZSB0byBpbnRlcnBvbGF0ZS4gIFRoZSB2YWx1ZXNcbiAqIGluIHRoaXMgYXJyYXkgbXVzdCBiZSBpbiBpbmNyZWFzaW5nIG9yZGVyIGFuZCB0aGUgc2FtZSB2YWx1ZSBtdXN0IG5vdCBvY2N1ciB0d2ljZSBpbiB0aGUgYXJyYXkuXG4gKiBAcGFyYW0ge051bWJlcltdfSB5VGFibGUgVGhlIGFycmF5IG9mIGRlcGVuZGVudCB2YXJpYWJsZXMgdG8gdXNlIHRvIGludGVycG9sYXRlLiAgRm9yIGEgc2V0IG9mIHRocmVlXG4gKiBkZXBlbmRlbnQgdmFsdWVzIChwLHEsdykgYXQgdGltZSAxIGFuZCB0aW1lIDIgdGhpcyBzaG91bGQgYmUgYXMgZm9sbG93czoge3AxLCBxMSwgdzEsIHAyLCBxMiwgdzJ9LlxuICogQHBhcmFtIHtOdW1iZXJ9IHlTdHJpZGUgVGhlIG51bWJlciBvZiBkZXBlbmRlbnQgdmFyaWFibGUgdmFsdWVzIGluIHlUYWJsZSBjb3JyZXNwb25kaW5nIHRvXG4gKiBlYWNoIGluZGVwZW5kZW50IHZhcmlhYmxlIHZhbHVlIGluIHhUYWJsZS5cbiAqIEBwYXJhbSB7TnVtYmVyW119IFtyZXN1bHRdIEFuIGV4aXN0aW5nIGFycmF5IGludG8gd2hpY2ggdG8gc3RvcmUgdGhlIHJlc3VsdC5cbiAqXG4gKiBAcmV0dXJucyB7TnVtYmVyW119IFRoZSBhcnJheSBvZiBpbnRlcnBvbGF0ZWQgdmFsdWVzLCBvciB0aGUgcmVzdWx0IHBhcmFtZXRlciBpZiBvbmUgd2FzIHByb3ZpZGVkLlxuICovXG5JbnRlcnBvbGF0aW9uQWxnb3JpdGhtLmludGVycG9sYXRlT3JkZXJaZXJvID1cbiAgRGV2ZWxvcGVyRXJyb3IudGhyb3dJbnN0YW50aWF0aW9uRXJyb3I7XG5cbi8qKlxuICogUGVyZm9ybXMgaGlnaGVyIG9yZGVyIGludGVycG9sYXRpb24uICBOb3QgYWxsIGludGVycG9sYXRvcnMgbmVlZCB0byBzdXBwb3J0IGhpZ2gtb3JkZXIgaW50ZXJwb2xhdGlvbixcbiAqIGlmIHRoaXMgZnVuY3Rpb24gcmVtYWlucyB1bmRlZmluZWQgb24gaW1wbGVtZW50aW5nIG9iamVjdHMsIGludGVycG9sYXRlT3JkZXJaZXJvIHdpbGwgYmUgdXNlZCBpbnN0ZWFkLlxuICogQGZ1bmN0aW9uXG4gKiBAcGFyYW0ge051bWJlcn0geCBUaGUgaW5kZXBlbmRlbnQgdmFyaWFibGUgZm9yIHdoaWNoIHRoZSBkZXBlbmRlbnQgdmFyaWFibGVzIHdpbGwgYmUgaW50ZXJwb2xhdGVkLlxuICogQHBhcmFtIHtOdW1iZXJbXX0geFRhYmxlIFRoZSBhcnJheSBvZiBpbmRlcGVuZGVudCB2YXJpYWJsZXMgdG8gdXNlIHRvIGludGVycG9sYXRlLiAgVGhlIHZhbHVlc1xuICogaW4gdGhpcyBhcnJheSBtdXN0IGJlIGluIGluY3JlYXNpbmcgb3JkZXIgYW5kIHRoZSBzYW1lIHZhbHVlIG11c3Qgbm90IG9jY3VyIHR3aWNlIGluIHRoZSBhcnJheS5cbiAqIEBwYXJhbSB7TnVtYmVyW119IHlUYWJsZSBUaGUgYXJyYXkgb2YgZGVwZW5kZW50IHZhcmlhYmxlcyB0byB1c2UgdG8gaW50ZXJwb2xhdGUuICBGb3IgYSBzZXQgb2YgdGhyZWVcbiAqIGRlcGVuZGVudCB2YWx1ZXMgKHAscSx3KSBhdCB0aW1lIDEgYW5kIHRpbWUgMiB0aGlzIHNob3VsZCBiZSBhcyBmb2xsb3dzOiB7cDEsIHExLCB3MSwgcDIsIHEyLCB3Mn0uXG4gKiBAcGFyYW0ge051bWJlcn0geVN0cmlkZSBUaGUgbnVtYmVyIG9mIGRlcGVuZGVudCB2YXJpYWJsZSB2YWx1ZXMgaW4geVRhYmxlIGNvcnJlc3BvbmRpbmcgdG9cbiAqIGVhY2ggaW5kZXBlbmRlbnQgdmFyaWFibGUgdmFsdWUgaW4geFRhYmxlLlxuICogQHBhcmFtIHtOdW1iZXJ9IGlucHV0T3JkZXIgVGhlIG51bWJlciBvZiBkZXJpdmF0aXZlcyBzdXBwbGllZCBmb3IgaW5wdXQuXG4gKiBAcGFyYW0ge051bWJlcn0gb3V0cHV0T3JkZXIgVGhlIG51bWJlciBvZiBkZXJpdmF0aXZlcyBkZXNpcmVkIGZvciBvdXRwdXQuXG4gKiBAcGFyYW0ge051bWJlcltdfSBbcmVzdWx0XSBBbiBleGlzdGluZyBhcnJheSBpbnRvIHdoaWNoIHRvIHN0b3JlIHRoZSByZXN1bHQuXG4gKiBAcmV0dXJucyB7TnVtYmVyW119IFRoZSBhcnJheSBvZiBpbnRlcnBvbGF0ZWQgdmFsdWVzLCBvciB0aGUgcmVzdWx0IHBhcmFtZXRlciBpZiBvbmUgd2FzIHByb3ZpZGVkLlxuICovXG5JbnRlcnBvbGF0aW9uQWxnb3JpdGhtLmludGVycG9sYXRlID0gRGV2ZWxvcGVyRXJyb3IudGhyb3dJbnN0YW50aWF0aW9uRXJyb3I7XG5leHBvcnQgZGVmYXVsdCBJbnRlcnBvbGF0aW9uQWxnb3JpdGhtO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///35739\n')},84935:function(__unused_webpack___webpack_module__,__webpack_exports__){eval("/**\n * This enumerated type is used in determining where, relative to the frustum, an\n * object is located. The object can either be fully contained within the frustum (INSIDE),\n * partially inside the frustum and partially outside (INTERSECTING), or somewhere entirely\n * outside of the frustum's 6 planes (OUTSIDE).\n *\n * @enum {Number}\n */\nvar Intersect = {\n  /**\n   * Represents that an object is not contained within the frustum.\n   *\n   * @type {Number}\n   * @constant\n   */\n  OUTSIDE: -1,\n\n  /**\n   * Represents that an object intersects one of the frustum's planes.\n   *\n   * @type {Number}\n   * @constant\n   */\n  INTERSECTING: 0,\n\n  /**\n   * Represents that an object is fully within the frustum.\n   *\n   * @type {Number}\n   * @constant\n   */\n  INSIDE: 1,\n};\n/* harmony default export */ __webpack_exports__[\"Z\"] = (Object.freeze(Intersect));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiODQ5MzUuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseURBQWUsd0JBQXdCLEVBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly92dWUzLXdlYnBhY2s1Ly4vbm9kZV9tb2R1bGVzL2Nlc2l1bS9Tb3VyY2UvQ29yZS9JbnRlcnNlY3QuanM/ODA1OSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIFRoaXMgZW51bWVyYXRlZCB0eXBlIGlzIHVzZWQgaW4gZGV0ZXJtaW5pbmcgd2hlcmUsIHJlbGF0aXZlIHRvIHRoZSBmcnVzdHVtLCBhblxuICogb2JqZWN0IGlzIGxvY2F0ZWQuIFRoZSBvYmplY3QgY2FuIGVpdGhlciBiZSBmdWxseSBjb250YWluZWQgd2l0aGluIHRoZSBmcnVzdHVtIChJTlNJREUpLFxuICogcGFydGlhbGx5IGluc2lkZSB0aGUgZnJ1c3R1bSBhbmQgcGFydGlhbGx5IG91dHNpZGUgKElOVEVSU0VDVElORyksIG9yIHNvbWV3aGVyZSBlbnRpcmVseVxuICogb3V0c2lkZSBvZiB0aGUgZnJ1c3R1bSdzIDYgcGxhbmVzIChPVVRTSURFKS5cbiAqXG4gKiBAZW51bSB7TnVtYmVyfVxuICovXG52YXIgSW50ZXJzZWN0ID0ge1xuICAvKipcbiAgICogUmVwcmVzZW50cyB0aGF0IGFuIG9iamVjdCBpcyBub3QgY29udGFpbmVkIHdpdGhpbiB0aGUgZnJ1c3R1bS5cbiAgICpcbiAgICogQHR5cGUge051bWJlcn1cbiAgICogQGNvbnN0YW50XG4gICAqL1xuICBPVVRTSURFOiAtMSxcblxuICAvKipcbiAgICogUmVwcmVzZW50cyB0aGF0IGFuIG9iamVjdCBpbnRlcnNlY3RzIG9uZSBvZiB0aGUgZnJ1c3R1bSdzIHBsYW5lcy5cbiAgICpcbiAgICogQHR5cGUge051bWJlcn1cbiAgICogQGNvbnN0YW50XG4gICAqL1xuICBJTlRFUlNFQ1RJTkc6IDAsXG5cbiAgLyoqXG4gICAqIFJlcHJlc2VudHMgdGhhdCBhbiBvYmplY3QgaXMgZnVsbHkgd2l0aGluIHRoZSBmcnVzdHVtLlxuICAgKlxuICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgKiBAY29uc3RhbnRcbiAgICovXG4gIElOU0lERTogMSxcbn07XG5leHBvcnQgZGVmYXVsdCBPYmplY3QuZnJlZXplKEludGVyc2VjdCk7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///84935\n")},67627:function(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__){eval('/* harmony import */ var _Cartesian3_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(60216);\n/* harmony import */ var _Cartographic_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(51688);\n/* harmony import */ var _defaultValue_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(62200);\n/* harmony import */ var _defined_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(82982);\n/* harmony import */ var _DeveloperError_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(12572);\n/* harmony import */ var _Interval_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(9058);\n/* harmony import */ var _Math_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(99417);\n/* harmony import */ var _Matrix3_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(68201);\n/* harmony import */ var _QuadraticRealPolynomial_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(46003);\n/* harmony import */ var _QuarticRealPolynomial_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(1479);\n/* harmony import */ var _Ray_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(68457);\n\n\n\n\n\n\n\n\n\n\n\n\n/**\n * Functions for computing the intersection between geometries such as rays, planes, triangles, and ellipsoids.\n *\n * @namespace IntersectionTests\n */\nvar IntersectionTests = {};\n\n/**\n * Computes the intersection of a ray and a plane.\n *\n * @param {Ray} ray The ray.\n * @param {Plane} plane The plane.\n * @param {Cartesian3} [result] The object onto which to store the result.\n * @returns {Cartesian3} The intersection point or undefined if there is no intersections.\n */\nIntersectionTests.rayPlane = function (ray, plane, result) {\n  //>>includeStart(\'debug\', pragmas.debug);\n  if (!(0,_defined_js__WEBPACK_IMPORTED_MODULE_10__/* ["default"] */ .Z)(ray)) {\n    throw new _DeveloperError_js__WEBPACK_IMPORTED_MODULE_3__/* ["default"] */ .Z("ray is required.");\n  }\n  if (!(0,_defined_js__WEBPACK_IMPORTED_MODULE_10__/* ["default"] */ .Z)(plane)) {\n    throw new _DeveloperError_js__WEBPACK_IMPORTED_MODULE_3__/* ["default"] */ .Z("plane is required.");\n  }\n  //>>includeEnd(\'debug\');\n\n  if (!(0,_defined_js__WEBPACK_IMPORTED_MODULE_10__/* ["default"] */ .Z)(result)) {\n    result = new _Cartesian3_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .Z();\n  }\n\n  var origin = ray.origin;\n  var direction = ray.direction;\n  var normal = plane.normal;\n  var denominator = _Cartesian3_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].dot */ .Z.dot(normal, direction);\n\n  if (Math.abs(denominator) < _Math_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"].EPSILON15 */ .Z.EPSILON15) {\n    // Ray is parallel to plane.  The ray may be in the polygon\'s plane.\n    return undefined;\n  }\n\n  var t = (-plane.distance - _Cartesian3_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].dot */ .Z.dot(normal, origin)) / denominator;\n\n  if (t < 0) {\n    return undefined;\n  }\n\n  result = _Cartesian3_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].multiplyByScalar */ .Z.multiplyByScalar(direction, t, result);\n  return _Cartesian3_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].add */ .Z.add(origin, result, result);\n};\n\nvar scratchEdge0 = new _Cartesian3_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .Z();\nvar scratchEdge1 = new _Cartesian3_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .Z();\nvar scratchPVec = new _Cartesian3_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .Z();\nvar scratchTVec = new _Cartesian3_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .Z();\nvar scratchQVec = new _Cartesian3_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .Z();\n\n/**\n * Computes the intersection of a ray and a triangle as a parametric distance along the input ray. The result is negative when the triangle is behind the ray.\n *\n * Implements {@link https://cadxfem.org/inf/Fast%20MinimumStorage%20RayTriangle%20Intersection.pdf|\n * Fast Minimum Storage Ray/Triangle Intersection} by Tomas Moller and Ben Trumbore.\n *\n * @memberof IntersectionTests\n *\n * @param {Ray} ray The ray.\n * @param {Cartesian3} p0 The first vertex of the triangle.\n * @param {Cartesian3} p1 The second vertex of the triangle.\n * @param {Cartesian3} p2 The third vertex of the triangle.\n * @param {Boolean} [cullBackFaces=false] If <code>true</code>, will only compute an intersection with the front face of the triangle\n *                  and return undefined for intersections with the back face.\n * @returns {Number} The intersection as a parametric distance along the ray, or undefined if there is no intersection.\n */\nIntersectionTests.rayTriangleParametric = function (\n  ray,\n  p0,\n  p1,\n  p2,\n  cullBackFaces\n) {\n  //>>includeStart(\'debug\', pragmas.debug);\n  if (!(0,_defined_js__WEBPACK_IMPORTED_MODULE_10__/* ["default"] */ .Z)(ray)) {\n    throw new _DeveloperError_js__WEBPACK_IMPORTED_MODULE_3__/* ["default"] */ .Z("ray is required.");\n  }\n  if (!(0,_defined_js__WEBPACK_IMPORTED_MODULE_10__/* ["default"] */ .Z)(p0)) {\n    throw new _DeveloperError_js__WEBPACK_IMPORTED_MODULE_3__/* ["default"] */ .Z("p0 is required.");\n  }\n  if (!(0,_defined_js__WEBPACK_IMPORTED_MODULE_10__/* ["default"] */ .Z)(p1)) {\n    throw new _DeveloperError_js__WEBPACK_IMPORTED_MODULE_3__/* ["default"] */ .Z("p1 is required.");\n  }\n  if (!(0,_defined_js__WEBPACK_IMPORTED_MODULE_10__/* ["default"] */ .Z)(p2)) {\n    throw new _DeveloperError_js__WEBPACK_IMPORTED_MODULE_3__/* ["default"] */ .Z("p2 is required.");\n  }\n  //>>includeEnd(\'debug\');\n\n  cullBackFaces = (0,_defaultValue_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"] */ .Z)(cullBackFaces, false);\n\n  var origin = ray.origin;\n  var direction = ray.direction;\n\n  var edge0 = _Cartesian3_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].subtract */ .Z.subtract(p1, p0, scratchEdge0);\n  var edge1 = _Cartesian3_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].subtract */ .Z.subtract(p2, p0, scratchEdge1);\n\n  var p = _Cartesian3_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].cross */ .Z.cross(direction, edge1, scratchPVec);\n  var det = _Cartesian3_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].dot */ .Z.dot(edge0, p);\n\n  var tvec;\n  var q;\n\n  var u;\n  var v;\n  var t;\n\n  if (cullBackFaces) {\n    if (det < _Math_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"].EPSILON6 */ .Z.EPSILON6) {\n      return undefined;\n    }\n\n    tvec = _Cartesian3_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].subtract */ .Z.subtract(origin, p0, scratchTVec);\n    u = _Cartesian3_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].dot */ .Z.dot(tvec, p);\n    if (u < 0.0 || u > det) {\n      return undefined;\n    }\n\n    q = _Cartesian3_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].cross */ .Z.cross(tvec, edge0, scratchQVec);\n\n    v = _Cartesian3_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].dot */ .Z.dot(direction, q);\n    if (v < 0.0 || u + v > det) {\n      return undefined;\n    }\n\n    t = _Cartesian3_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].dot */ .Z.dot(edge1, q) / det;\n  } else {\n    if (Math.abs(det) < _Math_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"].EPSILON6 */ .Z.EPSILON6) {\n      return undefined;\n    }\n    var invDet = 1.0 / det;\n\n    tvec = _Cartesian3_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].subtract */ .Z.subtract(origin, p0, scratchTVec);\n    u = _Cartesian3_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].dot */ .Z.dot(tvec, p) * invDet;\n    if (u < 0.0 || u > 1.0) {\n      return undefined;\n    }\n\n    q = _Cartesian3_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].cross */ .Z.cross(tvec, edge0, scratchQVec);\n\n    v = _Cartesian3_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].dot */ .Z.dot(direction, q) * invDet;\n    if (v < 0.0 || u + v > 1.0) {\n      return undefined;\n    }\n\n    t = _Cartesian3_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].dot */ .Z.dot(edge1, q) * invDet;\n  }\n\n  return t;\n};\n\n/**\n * Computes the intersection of a ray and a triangle as a Cartesian3 coordinate.\n *\n * Implements {@link https://cadxfem.org/inf/Fast%20MinimumStorage%20RayTriangle%20Intersection.pdf|\n * Fast Minimum Storage Ray/Triangle Intersection} by Tomas Moller and Ben Trumbore.\n *\n * @memberof IntersectionTests\n *\n * @param {Ray} ray The ray.\n * @param {Cartesian3} p0 The first vertex of the triangle.\n * @param {Cartesian3} p1 The second vertex of the triangle.\n * @param {Cartesian3} p2 The third vertex of the triangle.\n * @param {Boolean} [cullBackFaces=false] If <code>true</code>, will only compute an intersection with the front face of the triangle\n *                  and return undefined for intersections with the back face.\n * @param {Cartesian3} [result] The <code>Cartesian3</code> onto which to store the result.\n * @returns {Cartesian3} The intersection point or undefined if there is no intersections.\n */\nIntersectionTests.rayTriangle = function (\n  ray,\n  p0,\n  p1,\n  p2,\n  cullBackFaces,\n  result\n) {\n  var t = IntersectionTests.rayTriangleParametric(\n    ray,\n    p0,\n    p1,\n    p2,\n    cullBackFaces\n  );\n  if (!(0,_defined_js__WEBPACK_IMPORTED_MODULE_10__/* ["default"] */ .Z)(t) || t < 0.0) {\n    return undefined;\n  }\n\n  if (!(0,_defined_js__WEBPACK_IMPORTED_MODULE_10__/* ["default"] */ .Z)(result)) {\n    result = new _Cartesian3_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .Z();\n  }\n\n  _Cartesian3_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].multiplyByScalar */ .Z.multiplyByScalar(ray.direction, t, result);\n  return _Cartesian3_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].add */ .Z.add(ray.origin, result, result);\n};\n\nvar scratchLineSegmentTriangleRay = new _Ray_js__WEBPACK_IMPORTED_MODULE_9__/* ["default"] */ .Z();\n\n/**\n * Computes the intersection of a line segment and a triangle.\n * @memberof IntersectionTests\n *\n * @param {Cartesian3} v0 The an end point of the line segment.\n * @param {Cartesian3} v1 The other end point of the line segment.\n * @param {Cartesian3} p0 The first vertex of the triangle.\n * @param {Cartesian3} p1 The second vertex of the triangle.\n * @param {Cartesian3} p2 The third vertex of the triangle.\n * @param {Boolean} [cullBackFaces=false] If <code>true</code>, will only compute an intersection with the front face of the triangle\n *                  and return undefined for intersections with the back face.\n * @param {Cartesian3} [result] The <code>Cartesian3</code> onto which to store the result.\n * @returns {Cartesian3} The intersection point or undefined if there is no intersections.\n */\nIntersectionTests.lineSegmentTriangle = function (\n  v0,\n  v1,\n  p0,\n  p1,\n  p2,\n  cullBackFaces,\n  result\n) {\n  //>>includeStart(\'debug\', pragmas.debug);\n  if (!(0,_defined_js__WEBPACK_IMPORTED_MODULE_10__/* ["default"] */ .Z)(v0)) {\n    throw new _DeveloperError_js__WEBPACK_IMPORTED_MODULE_3__/* ["default"] */ .Z("v0 is required.");\n  }\n  if (!(0,_defined_js__WEBPACK_IMPORTED_MODULE_10__/* ["default"] */ .Z)(v1)) {\n    throw new _DeveloperError_js__WEBPACK_IMPORTED_MODULE_3__/* ["default"] */ .Z("v1 is required.");\n  }\n  if (!(0,_defined_js__WEBPACK_IMPORTED_MODULE_10__/* ["default"] */ .Z)(p0)) {\n    throw new _DeveloperError_js__WEBPACK_IMPORTED_MODULE_3__/* ["default"] */ .Z("p0 is required.");\n  }\n  if (!(0,_defined_js__WEBPACK_IMPORTED_MODULE_10__/* ["default"] */ .Z)(p1)) {\n    throw new _DeveloperError_js__WEBPACK_IMPORTED_MODULE_3__/* ["default"] */ .Z("p1 is required.");\n  }\n  if (!(0,_defined_js__WEBPACK_IMPORTED_MODULE_10__/* ["default"] */ .Z)(p2)) {\n    throw new _DeveloperError_js__WEBPACK_IMPORTED_MODULE_3__/* ["default"] */ .Z("p2 is required.");\n  }\n  //>>includeEnd(\'debug\');\n\n  var ray = scratchLineSegmentTriangleRay;\n  _Cartesian3_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].clone */ .Z.clone(v0, ray.origin);\n  _Cartesian3_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].subtract */ .Z.subtract(v1, v0, ray.direction);\n  _Cartesian3_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].normalize */ .Z.normalize(ray.direction, ray.direction);\n\n  var t = IntersectionTests.rayTriangleParametric(\n    ray,\n    p0,\n    p1,\n    p2,\n    cullBackFaces\n  );\n  if (!(0,_defined_js__WEBPACK_IMPORTED_MODULE_10__/* ["default"] */ .Z)(t) || t < 0.0 || t > _Cartesian3_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].distance */ .Z.distance(v0, v1)) {\n    return undefined;\n  }\n\n  if (!(0,_defined_js__WEBPACK_IMPORTED_MODULE_10__/* ["default"] */ .Z)(result)) {\n    result = new _Cartesian3_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .Z();\n  }\n\n  _Cartesian3_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].multiplyByScalar */ .Z.multiplyByScalar(ray.direction, t, result);\n  return _Cartesian3_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].add */ .Z.add(ray.origin, result, result);\n};\n\nfunction solveQuadratic(a, b, c, result) {\n  var det = b * b - 4.0 * a * c;\n  if (det < 0.0) {\n    return undefined;\n  } else if (det > 0.0) {\n    var denom = 1.0 / (2.0 * a);\n    var disc = Math.sqrt(det);\n    var root0 = (-b + disc) * denom;\n    var root1 = (-b - disc) * denom;\n\n    if (root0 < root1) {\n      result.root0 = root0;\n      result.root1 = root1;\n    } else {\n      result.root0 = root1;\n      result.root1 = root0;\n    }\n\n    return result;\n  }\n\n  var root = -b / (2.0 * a);\n  if (root === 0.0) {\n    return undefined;\n  }\n\n  result.root0 = result.root1 = root;\n  return result;\n}\n\nvar raySphereRoots = {\n  root0: 0.0,\n  root1: 0.0,\n};\n\nfunction raySphere(ray, sphere, result) {\n  if (!(0,_defined_js__WEBPACK_IMPORTED_MODULE_10__/* ["default"] */ .Z)(result)) {\n    result = new _Interval_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .Z();\n  }\n\n  var origin = ray.origin;\n  var direction = ray.direction;\n\n  var center = sphere.center;\n  var radiusSquared = sphere.radius * sphere.radius;\n\n  var diff = _Cartesian3_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].subtract */ .Z.subtract(origin, center, scratchPVec);\n\n  var a = _Cartesian3_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].dot */ .Z.dot(direction, direction);\n  var b = 2.0 * _Cartesian3_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].dot */ .Z.dot(direction, diff);\n  var c = _Cartesian3_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].magnitudeSquared */ .Z.magnitudeSquared(diff) - radiusSquared;\n\n  var roots = solveQuadratic(a, b, c, raySphereRoots);\n  if (!(0,_defined_js__WEBPACK_IMPORTED_MODULE_10__/* ["default"] */ .Z)(roots)) {\n    return undefined;\n  }\n\n  result.start = roots.root0;\n  result.stop = roots.root1;\n  return result;\n}\n\n/**\n * Computes the intersection points of a ray with a sphere.\n * @memberof IntersectionTests\n *\n * @param {Ray} ray The ray.\n * @param {BoundingSphere} sphere The sphere.\n * @param {Interval} [result] The result onto which to store the result.\n * @returns {Interval} The interval containing scalar points along the ray or undefined if there are no intersections.\n */\nIntersectionTests.raySphere = function (ray, sphere, result) {\n  //>>includeStart(\'debug\', pragmas.debug);\n  if (!(0,_defined_js__WEBPACK_IMPORTED_MODULE_10__/* ["default"] */ .Z)(ray)) {\n    throw new _DeveloperError_js__WEBPACK_IMPORTED_MODULE_3__/* ["default"] */ .Z("ray is required.");\n  }\n  if (!(0,_defined_js__WEBPACK_IMPORTED_MODULE_10__/* ["default"] */ .Z)(sphere)) {\n    throw new _DeveloperError_js__WEBPACK_IMPORTED_MODULE_3__/* ["default"] */ .Z("sphere is required.");\n  }\n  //>>includeEnd(\'debug\');\n\n  result = raySphere(ray, sphere, result);\n  if (!(0,_defined_js__WEBPACK_IMPORTED_MODULE_10__/* ["default"] */ .Z)(result) || result.stop < 0.0) {\n    return undefined;\n  }\n\n  result.start = Math.max(result.start, 0.0);\n  return result;\n};\n\nvar scratchLineSegmentRay = new _Ray_js__WEBPACK_IMPORTED_MODULE_9__/* ["default"] */ .Z();\n\n/**\n * Computes the intersection points of a line segment with a sphere.\n * @memberof IntersectionTests\n *\n * @param {Cartesian3} p0 An end point of the line segment.\n * @param {Cartesian3} p1 The other end point of the line segment.\n * @param {BoundingSphere} sphere The sphere.\n * @param {Interval} [result] The result onto which to store the result.\n * @returns {Interval} The interval containing scalar points along the ray or undefined if there are no intersections.\n */\nIntersectionTests.lineSegmentSphere = function (p0, p1, sphere, result) {\n  //>>includeStart(\'debug\', pragmas.debug);\n  if (!(0,_defined_js__WEBPACK_IMPORTED_MODULE_10__/* ["default"] */ .Z)(p0)) {\n    throw new _DeveloperError_js__WEBPACK_IMPORTED_MODULE_3__/* ["default"] */ .Z("p0 is required.");\n  }\n  if (!(0,_defined_js__WEBPACK_IMPORTED_MODULE_10__/* ["default"] */ .Z)(p1)) {\n    throw new _DeveloperError_js__WEBPACK_IMPORTED_MODULE_3__/* ["default"] */ .Z("p1 is required.");\n  }\n  if (!(0,_defined_js__WEBPACK_IMPORTED_MODULE_10__/* ["default"] */ .Z)(sphere)) {\n    throw new _DeveloperError_js__WEBPACK_IMPORTED_MODULE_3__/* ["default"] */ .Z("sphere is required.");\n  }\n  //>>includeEnd(\'debug\');\n\n  var ray = scratchLineSegmentRay;\n  _Cartesian3_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].clone */ .Z.clone(p0, ray.origin);\n  var direction = _Cartesian3_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].subtract */ .Z.subtract(p1, p0, ray.direction);\n\n  var maxT = _Cartesian3_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].magnitude */ .Z.magnitude(direction);\n  _Cartesian3_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].normalize */ .Z.normalize(direction, direction);\n\n  result = raySphere(ray, sphere, result);\n  if (!(0,_defined_js__WEBPACK_IMPORTED_MODULE_10__/* ["default"] */ .Z)(result) || result.stop < 0.0 || result.start > maxT) {\n    return undefined;\n  }\n\n  result.start = Math.max(result.start, 0.0);\n  result.stop = Math.min(result.stop, maxT);\n  return result;\n};\n\nvar scratchQ = new _Cartesian3_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .Z();\nvar scratchW = new _Cartesian3_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .Z();\n\n/**\n * Computes the intersection points of a ray with an ellipsoid.\n *\n * @param {Ray} ray The ray.\n * @param {Ellipsoid} ellipsoid The ellipsoid.\n * @returns {Interval} The interval containing scalar points along the ray or undefined if there are no intersections.\n */\nIntersectionTests.rayEllipsoid = function (ray, ellipsoid) {\n  //>>includeStart(\'debug\', pragmas.debug);\n  if (!(0,_defined_js__WEBPACK_IMPORTED_MODULE_10__/* ["default"] */ .Z)(ray)) {\n    throw new _DeveloperError_js__WEBPACK_IMPORTED_MODULE_3__/* ["default"] */ .Z("ray is required.");\n  }\n  if (!(0,_defined_js__WEBPACK_IMPORTED_MODULE_10__/* ["default"] */ .Z)(ellipsoid)) {\n    throw new _DeveloperError_js__WEBPACK_IMPORTED_MODULE_3__/* ["default"] */ .Z("ellipsoid is required.");\n  }\n  //>>includeEnd(\'debug\');\n\n  var inverseRadii = ellipsoid.oneOverRadii;\n  var q = _Cartesian3_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].multiplyComponents */ .Z.multiplyComponents(inverseRadii, ray.origin, scratchQ);\n  var w = _Cartesian3_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].multiplyComponents */ .Z.multiplyComponents(inverseRadii, ray.direction, scratchW);\n\n  var q2 = _Cartesian3_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].magnitudeSquared */ .Z.magnitudeSquared(q);\n  var qw = _Cartesian3_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].dot */ .Z.dot(q, w);\n\n  var difference, w2, product, discriminant, temp;\n\n  if (q2 > 1.0) {\n    // Outside ellipsoid.\n    if (qw >= 0.0) {\n      // Looking outward or tangent (0 intersections).\n      return undefined;\n    }\n\n    // qw < 0.0.\n    var qw2 = qw * qw;\n    difference = q2 - 1.0; // Positively valued.\n    w2 = _Cartesian3_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].magnitudeSquared */ .Z.magnitudeSquared(w);\n    product = w2 * difference;\n\n    if (qw2 < product) {\n      // Imaginary roots (0 intersections).\n      return undefined;\n    } else if (qw2 > product) {\n      // Distinct roots (2 intersections).\n      discriminant = qw * qw - product;\n      temp = -qw + Math.sqrt(discriminant); // Avoid cancellation.\n      var root0 = temp / w2;\n      var root1 = difference / temp;\n      if (root0 < root1) {\n        return new _Interval_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .Z(root0, root1);\n      }\n\n      return {\n        start: root1,\n        stop: root0,\n      };\n    }\n    // qw2 == product.  Repeated roots (2 intersections).\n    var root = Math.sqrt(difference / w2);\n    return new _Interval_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .Z(root, root);\n  } else if (q2 < 1.0) {\n    // Inside ellipsoid (2 intersections).\n    difference = q2 - 1.0; // Negatively valued.\n    w2 = _Cartesian3_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].magnitudeSquared */ .Z.magnitudeSquared(w);\n    product = w2 * difference; // Negatively valued.\n\n    discriminant = qw * qw - product;\n    temp = -qw + Math.sqrt(discriminant); // Positively valued.\n    return new _Interval_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .Z(0.0, temp / w2);\n  }\n  // q2 == 1.0. On ellipsoid.\n  if (qw < 0.0) {\n    // Looking inward.\n    w2 = _Cartesian3_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].magnitudeSquared */ .Z.magnitudeSquared(w);\n    return new _Interval_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .Z(0.0, -qw / w2);\n  }\n\n  // qw >= 0.0.  Looking outward or tangent.\n  return undefined;\n};\n\nfunction addWithCancellationCheck(left, right, tolerance) {\n  var difference = left + right;\n  if (\n    _Math_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"].sign */ .Z.sign(left) !== _Math_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"].sign */ .Z.sign(right) &&\n    Math.abs(difference / Math.max(Math.abs(left), Math.abs(right))) < tolerance\n  ) {\n    return 0.0;\n  }\n\n  return difference;\n}\n\nfunction quadraticVectorExpression(A, b, c, x, w) {\n  var xSquared = x * x;\n  var wSquared = w * w;\n\n  var l2 = (A[_Matrix3_js__WEBPACK_IMPORTED_MODULE_6__/* ["default"].COLUMN1ROW1 */ .Z.COLUMN1ROW1] - A[_Matrix3_js__WEBPACK_IMPORTED_MODULE_6__/* ["default"].COLUMN2ROW2 */ .Z.COLUMN2ROW2]) * wSquared;\n  var l1 =\n    w *\n    (x *\n      addWithCancellationCheck(\n        A[_Matrix3_js__WEBPACK_IMPORTED_MODULE_6__/* ["default"].COLUMN1ROW0 */ .Z.COLUMN1ROW0],\n        A[_Matrix3_js__WEBPACK_IMPORTED_MODULE_6__/* ["default"].COLUMN0ROW1 */ .Z.COLUMN0ROW1],\n        _Math_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"].EPSILON15 */ .Z.EPSILON15\n      ) +\n      b.y);\n  var l0 =\n    A[_Matrix3_js__WEBPACK_IMPORTED_MODULE_6__/* ["default"].COLUMN0ROW0 */ .Z.COLUMN0ROW0] * xSquared +\n    A[_Matrix3_js__WEBPACK_IMPORTED_MODULE_6__/* ["default"].COLUMN2ROW2 */ .Z.COLUMN2ROW2] * wSquared +\n    x * b.x +\n    c;\n\n  var r1 =\n    wSquared *\n    addWithCancellationCheck(\n      A[_Matrix3_js__WEBPACK_IMPORTED_MODULE_6__/* ["default"].COLUMN2ROW1 */ .Z.COLUMN2ROW1],\n      A[_Matrix3_js__WEBPACK_IMPORTED_MODULE_6__/* ["default"].COLUMN1ROW2 */ .Z.COLUMN1ROW2],\n      _Math_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"].EPSILON15 */ .Z.EPSILON15\n    );\n  var r0 =\n    w *\n    (x *\n      addWithCancellationCheck(A[_Matrix3_js__WEBPACK_IMPORTED_MODULE_6__/* ["default"].COLUMN2ROW0 */ .Z.COLUMN2ROW0], A[_Matrix3_js__WEBPACK_IMPORTED_MODULE_6__/* ["default"].COLUMN0ROW2 */ .Z.COLUMN0ROW2]) +\n      b.z);\n\n  var cosines;\n  var solutions = [];\n  if (r0 === 0.0 && r1 === 0.0) {\n    cosines = _QuadraticRealPolynomial_js__WEBPACK_IMPORTED_MODULE_7__/* ["default"].computeRealRoots */ .Z.computeRealRoots(l2, l1, l0);\n    if (cosines.length === 0) {\n      return solutions;\n    }\n\n    var cosine0 = cosines[0];\n    var sine0 = Math.sqrt(Math.max(1.0 - cosine0 * cosine0, 0.0));\n    solutions.push(new _Cartesian3_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .Z(x, w * cosine0, w * -sine0));\n    solutions.push(new _Cartesian3_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .Z(x, w * cosine0, w * sine0));\n\n    if (cosines.length === 2) {\n      var cosine1 = cosines[1];\n      var sine1 = Math.sqrt(Math.max(1.0 - cosine1 * cosine1, 0.0));\n      solutions.push(new _Cartesian3_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .Z(x, w * cosine1, w * -sine1));\n      solutions.push(new _Cartesian3_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .Z(x, w * cosine1, w * sine1));\n    }\n\n    return solutions;\n  }\n\n  var r0Squared = r0 * r0;\n  var r1Squared = r1 * r1;\n  var l2Squared = l2 * l2;\n  var r0r1 = r0 * r1;\n\n  var c4 = l2Squared + r1Squared;\n  var c3 = 2.0 * (l1 * l2 + r0r1);\n  var c2 = 2.0 * l0 * l2 + l1 * l1 - r1Squared + r0Squared;\n  var c1 = 2.0 * (l0 * l1 - r0r1);\n  var c0 = l0 * l0 - r0Squared;\n\n  if (c4 === 0.0 && c3 === 0.0 && c2 === 0.0 && c1 === 0.0) {\n    return solutions;\n  }\n\n  cosines = _QuarticRealPolynomial_js__WEBPACK_IMPORTED_MODULE_8__/* ["default"].computeRealRoots */ .Z.computeRealRoots(c4, c3, c2, c1, c0);\n  var length = cosines.length;\n  if (length === 0) {\n    return solutions;\n  }\n\n  for (var i = 0; i < length; ++i) {\n    var cosine = cosines[i];\n    var cosineSquared = cosine * cosine;\n    var sineSquared = Math.max(1.0 - cosineSquared, 0.0);\n    var sine = Math.sqrt(sineSquared);\n\n    //var left = l2 * cosineSquared + l1 * cosine + l0;\n    var left;\n    if (_Math_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"].sign */ .Z.sign(l2) === _Math_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"].sign */ .Z.sign(l0)) {\n      left = addWithCancellationCheck(\n        l2 * cosineSquared + l0,\n        l1 * cosine,\n        _Math_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"].EPSILON12 */ .Z.EPSILON12\n      );\n    } else if (_Math_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"].sign */ .Z.sign(l0) === _Math_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"].sign */ .Z.sign(l1 * cosine)) {\n      left = addWithCancellationCheck(\n        l2 * cosineSquared,\n        l1 * cosine + l0,\n        _Math_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"].EPSILON12 */ .Z.EPSILON12\n      );\n    } else {\n      left = addWithCancellationCheck(\n        l2 * cosineSquared + l1 * cosine,\n        l0,\n        _Math_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"].EPSILON12 */ .Z.EPSILON12\n      );\n    }\n\n    var right = addWithCancellationCheck(r1 * cosine, r0, _Math_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"].EPSILON15 */ .Z.EPSILON15);\n    var product = left * right;\n\n    if (product < 0.0) {\n      solutions.push(new _Cartesian3_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .Z(x, w * cosine, w * sine));\n    } else if (product > 0.0) {\n      solutions.push(new _Cartesian3_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .Z(x, w * cosine, w * -sine));\n    } else if (sine !== 0.0) {\n      solutions.push(new _Cartesian3_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .Z(x, w * cosine, w * -sine));\n      solutions.push(new _Cartesian3_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .Z(x, w * cosine, w * sine));\n      ++i;\n    } else {\n      solutions.push(new _Cartesian3_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .Z(x, w * cosine, w * sine));\n    }\n  }\n\n  return solutions;\n}\n\nvar firstAxisScratch = new _Cartesian3_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .Z();\nvar secondAxisScratch = new _Cartesian3_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .Z();\nvar thirdAxisScratch = new _Cartesian3_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .Z();\nvar referenceScratch = new _Cartesian3_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .Z();\nvar bCart = new _Cartesian3_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .Z();\nvar bScratch = new _Matrix3_js__WEBPACK_IMPORTED_MODULE_6__/* ["default"] */ .Z();\nvar btScratch = new _Matrix3_js__WEBPACK_IMPORTED_MODULE_6__/* ["default"] */ .Z();\nvar diScratch = new _Matrix3_js__WEBPACK_IMPORTED_MODULE_6__/* ["default"] */ .Z();\nvar dScratch = new _Matrix3_js__WEBPACK_IMPORTED_MODULE_6__/* ["default"] */ .Z();\nvar cScratch = new _Matrix3_js__WEBPACK_IMPORTED_MODULE_6__/* ["default"] */ .Z();\nvar tempMatrix = new _Matrix3_js__WEBPACK_IMPORTED_MODULE_6__/* ["default"] */ .Z();\nvar aScratch = new _Matrix3_js__WEBPACK_IMPORTED_MODULE_6__/* ["default"] */ .Z();\nvar sScratch = new _Cartesian3_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .Z();\nvar closestScratch = new _Cartesian3_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .Z();\nvar surfPointScratch = new _Cartographic_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .Z();\n\n/**\n * Provides the point along the ray which is nearest to the ellipsoid.\n *\n * @param {Ray} ray The ray.\n * @param {Ellipsoid} ellipsoid The ellipsoid.\n * @returns {Cartesian3} The nearest planetodetic point on the ray.\n */\nIntersectionTests.grazingAltitudeLocation = function (ray, ellipsoid) {\n  //>>includeStart(\'debug\', pragmas.debug);\n  if (!(0,_defined_js__WEBPACK_IMPORTED_MODULE_10__/* ["default"] */ .Z)(ray)) {\n    throw new _DeveloperError_js__WEBPACK_IMPORTED_MODULE_3__/* ["default"] */ .Z("ray is required.");\n  }\n  if (!(0,_defined_js__WEBPACK_IMPORTED_MODULE_10__/* ["default"] */ .Z)(ellipsoid)) {\n    throw new _DeveloperError_js__WEBPACK_IMPORTED_MODULE_3__/* ["default"] */ .Z("ellipsoid is required.");\n  }\n  //>>includeEnd(\'debug\');\n\n  var position = ray.origin;\n  var direction = ray.direction;\n\n  if (!_Cartesian3_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].equals */ .Z.equals(position, _Cartesian3_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].ZERO */ .Z.ZERO)) {\n    var normal = ellipsoid.geodeticSurfaceNormal(position, firstAxisScratch);\n    if (_Cartesian3_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].dot */ .Z.dot(direction, normal) >= 0.0) {\n      // The location provided is the closest point in altitude\n      return position;\n    }\n  }\n\n  var intersects = (0,_defined_js__WEBPACK_IMPORTED_MODULE_10__/* ["default"] */ .Z)(this.rayEllipsoid(ray, ellipsoid));\n\n  // Compute the scaled direction vector.\n  var f = ellipsoid.transformPositionToScaledSpace(direction, firstAxisScratch);\n\n  // Constructs a basis from the unit scaled direction vector. Construct its rotation and transpose.\n  var firstAxis = _Cartesian3_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].normalize */ .Z.normalize(f, f);\n  var reference = _Cartesian3_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].mostOrthogonalAxis */ .Z.mostOrthogonalAxis(f, referenceScratch);\n  var secondAxis = _Cartesian3_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].normalize */ .Z.normalize(\n    _Cartesian3_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].cross */ .Z.cross(reference, firstAxis, secondAxisScratch),\n    secondAxisScratch\n  );\n  var thirdAxis = _Cartesian3_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].normalize */ .Z.normalize(\n    _Cartesian3_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].cross */ .Z.cross(firstAxis, secondAxis, thirdAxisScratch),\n    thirdAxisScratch\n  );\n  var B = bScratch;\n  B[0] = firstAxis.x;\n  B[1] = firstAxis.y;\n  B[2] = firstAxis.z;\n  B[3] = secondAxis.x;\n  B[4] = secondAxis.y;\n  B[5] = secondAxis.z;\n  B[6] = thirdAxis.x;\n  B[7] = thirdAxis.y;\n  B[8] = thirdAxis.z;\n\n  var B_T = _Matrix3_js__WEBPACK_IMPORTED_MODULE_6__/* ["default"].transpose */ .Z.transpose(B, btScratch);\n\n  // Get the scaling matrix and its inverse.\n  var D_I = _Matrix3_js__WEBPACK_IMPORTED_MODULE_6__/* ["default"].fromScale */ .Z.fromScale(ellipsoid.radii, diScratch);\n  var D = _Matrix3_js__WEBPACK_IMPORTED_MODULE_6__/* ["default"].fromScale */ .Z.fromScale(ellipsoid.oneOverRadii, dScratch);\n\n  var C = cScratch;\n  C[0] = 0.0;\n  C[1] = -direction.z;\n  C[2] = direction.y;\n  C[3] = direction.z;\n  C[4] = 0.0;\n  C[5] = -direction.x;\n  C[6] = -direction.y;\n  C[7] = direction.x;\n  C[8] = 0.0;\n\n  var temp = _Matrix3_js__WEBPACK_IMPORTED_MODULE_6__/* ["default"].multiply */ .Z.multiply(\n    _Matrix3_js__WEBPACK_IMPORTED_MODULE_6__/* ["default"].multiply */ .Z.multiply(B_T, D, tempMatrix),\n    C,\n    tempMatrix\n  );\n  var A = _Matrix3_js__WEBPACK_IMPORTED_MODULE_6__/* ["default"].multiply */ .Z.multiply(_Matrix3_js__WEBPACK_IMPORTED_MODULE_6__/* ["default"].multiply */ .Z.multiply(temp, D_I, aScratch), B, aScratch);\n  var b = _Matrix3_js__WEBPACK_IMPORTED_MODULE_6__/* ["default"].multiplyByVector */ .Z.multiplyByVector(temp, position, bCart);\n\n  // Solve for the solutions to the expression in standard form:\n  var solutions = quadraticVectorExpression(\n    A,\n    _Cartesian3_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].negate */ .Z.negate(b, firstAxisScratch),\n    0.0,\n    0.0,\n    1.0\n  );\n\n  var s;\n  var altitude;\n  var length = solutions.length;\n  if (length > 0) {\n    var closest = _Cartesian3_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].clone */ .Z.clone(_Cartesian3_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].ZERO */ .Z.ZERO, closestScratch);\n    var maximumValue = Number.NEGATIVE_INFINITY;\n\n    for (var i = 0; i < length; ++i) {\n      s = _Matrix3_js__WEBPACK_IMPORTED_MODULE_6__/* ["default"].multiplyByVector */ .Z.multiplyByVector(\n        D_I,\n        _Matrix3_js__WEBPACK_IMPORTED_MODULE_6__/* ["default"].multiplyByVector */ .Z.multiplyByVector(B, solutions[i], sScratch),\n        sScratch\n      );\n      var v = _Cartesian3_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].normalize */ .Z.normalize(\n        _Cartesian3_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].subtract */ .Z.subtract(s, position, referenceScratch),\n        referenceScratch\n      );\n      var dotProduct = _Cartesian3_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].dot */ .Z.dot(v, direction);\n\n      if (dotProduct > maximumValue) {\n        maximumValue = dotProduct;\n        closest = _Cartesian3_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].clone */ .Z.clone(s, closest);\n      }\n    }\n\n    var surfacePoint = ellipsoid.cartesianToCartographic(\n      closest,\n      surfPointScratch\n    );\n    maximumValue = _Math_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"].clamp */ .Z.clamp(maximumValue, 0.0, 1.0);\n    altitude =\n      _Cartesian3_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].magnitude */ .Z.magnitude(\n        _Cartesian3_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].subtract */ .Z.subtract(closest, position, referenceScratch)\n      ) * Math.sqrt(1.0 - maximumValue * maximumValue);\n    altitude = intersects ? -altitude : altitude;\n    surfacePoint.height = altitude;\n    return ellipsoid.cartographicToCartesian(surfacePoint, new _Cartesian3_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .Z());\n  }\n\n  return undefined;\n};\n\nvar lineSegmentPlaneDifference = new _Cartesian3_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .Z();\n\n/**\n * Computes the intersection of a line segment and a plane.\n *\n * @param {Cartesian3} endPoint0 An end point of the line segment.\n * @param {Cartesian3} endPoint1 The other end point of the line segment.\n * @param {Plane} plane The plane.\n * @param {Cartesian3} [result] The object onto which to store the result.\n * @returns {Cartesian3} The intersection point or undefined if there is no intersection.\n *\n * @example\n * var origin = Cesium.Cartesian3.fromDegrees(-75.59777, 40.03883);\n * var normal = ellipsoid.geodeticSurfaceNormal(origin);\n * var plane = Cesium.Plane.fromPointNormal(origin, normal);\n *\n * var p0 = new Cesium.Cartesian3(...);\n * var p1 = new Cesium.Cartesian3(...);\n *\n * // find the intersection of the line segment from p0 to p1 and the tangent plane at origin.\n * var intersection = Cesium.IntersectionTests.lineSegmentPlane(p0, p1, plane);\n */\nIntersectionTests.lineSegmentPlane = function (\n  endPoint0,\n  endPoint1,\n  plane,\n  result\n) {\n  //>>includeStart(\'debug\', pragmas.debug);\n  if (!(0,_defined_js__WEBPACK_IMPORTED_MODULE_10__/* ["default"] */ .Z)(endPoint0)) {\n    throw new _DeveloperError_js__WEBPACK_IMPORTED_MODULE_3__/* ["default"] */ .Z("endPoint0 is required.");\n  }\n  if (!(0,_defined_js__WEBPACK_IMPORTED_MODULE_10__/* ["default"] */ .Z)(endPoint1)) {\n    throw new _DeveloperError_js__WEBPACK_IMPORTED_MODULE_3__/* ["default"] */ .Z("endPoint1 is required.");\n  }\n  if (!(0,_defined_js__WEBPACK_IMPORTED_MODULE_10__/* ["default"] */ .Z)(plane)) {\n    throw new _DeveloperError_js__WEBPACK_IMPORTED_MODULE_3__/* ["default"] */ .Z("plane is required.");\n  }\n  //>>includeEnd(\'debug\');\n\n  if (!(0,_defined_js__WEBPACK_IMPORTED_MODULE_10__/* ["default"] */ .Z)(result)) {\n    result = new _Cartesian3_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .Z();\n  }\n\n  var difference = _Cartesian3_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].subtract */ .Z.subtract(\n    endPoint1,\n    endPoint0,\n    lineSegmentPlaneDifference\n  );\n  var normal = plane.normal;\n  var nDotDiff = _Cartesian3_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].dot */ .Z.dot(normal, difference);\n\n  // check if the segment and plane are parallel\n  if (Math.abs(nDotDiff) < _Math_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"].EPSILON6 */ .Z.EPSILON6) {\n    return undefined;\n  }\n\n  var nDotP0 = _Cartesian3_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].dot */ .Z.dot(normal, endPoint0);\n  var t = -(plane.distance + nDotP0) / nDotDiff;\n\n  // intersection only if t is in [0, 1]\n  if (t < 0.0 || t > 1.0) {\n    return undefined;\n  }\n\n  // intersection is endPoint0 + t * (endPoint1 - endPoint0)\n  _Cartesian3_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].multiplyByScalar */ .Z.multiplyByScalar(difference, t, result);\n  _Cartesian3_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].add */ .Z.add(endPoint0, result, result);\n  return result;\n};\n\n/**\n * Computes the intersection of a triangle and a plane\n *\n * @param {Cartesian3} p0 First point of the triangle\n * @param {Cartesian3} p1 Second point of the triangle\n * @param {Cartesian3} p2 Third point of the triangle\n * @param {Plane} plane Intersection plane\n * @returns {Object} An object with properties <code>positions</code> and <code>indices</code>, which are arrays that represent three triangles that do not cross the plane. (Undefined if no intersection exists)\n *\n * @example\n * var origin = Cesium.Cartesian3.fromDegrees(-75.59777, 40.03883);\n * var normal = ellipsoid.geodeticSurfaceNormal(origin);\n * var plane = Cesium.Plane.fromPointNormal(origin, normal);\n *\n * var p0 = new Cesium.Cartesian3(...);\n * var p1 = new Cesium.Cartesian3(...);\n * var p2 = new Cesium.Cartesian3(...);\n *\n * // convert the triangle composed of points (p0, p1, p2) to three triangles that don\'t cross the plane\n * var triangles = Cesium.IntersectionTests.trianglePlaneIntersection(p0, p1, p2, plane);\n */\nIntersectionTests.trianglePlaneIntersection = function (p0, p1, p2, plane) {\n  //>>includeStart(\'debug\', pragmas.debug);\n  if (!(0,_defined_js__WEBPACK_IMPORTED_MODULE_10__/* ["default"] */ .Z)(p0) || !(0,_defined_js__WEBPACK_IMPORTED_MODULE_10__/* ["default"] */ .Z)(p1) || !(0,_defined_js__WEBPACK_IMPORTED_MODULE_10__/* ["default"] */ .Z)(p2) || !(0,_defined_js__WEBPACK_IMPORTED_MODULE_10__/* ["default"] */ .Z)(plane)) {\n    throw new _DeveloperError_js__WEBPACK_IMPORTED_MODULE_3__/* ["default"] */ .Z("p0, p1, p2, and plane are required.");\n  }\n  //>>includeEnd(\'debug\');\n\n  var planeNormal = plane.normal;\n  var planeD = plane.distance;\n  var p0Behind = _Cartesian3_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].dot */ .Z.dot(planeNormal, p0) + planeD < 0.0;\n  var p1Behind = _Cartesian3_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].dot */ .Z.dot(planeNormal, p1) + planeD < 0.0;\n  var p2Behind = _Cartesian3_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].dot */ .Z.dot(planeNormal, p2) + planeD < 0.0;\n  // Given these dots products, the calls to lineSegmentPlaneIntersection\n  // always have defined results.\n\n  var numBehind = 0;\n  numBehind += p0Behind ? 1 : 0;\n  numBehind += p1Behind ? 1 : 0;\n  numBehind += p2Behind ? 1 : 0;\n\n  var u1, u2;\n  if (numBehind === 1 || numBehind === 2) {\n    u1 = new _Cartesian3_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .Z();\n    u2 = new _Cartesian3_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .Z();\n  }\n\n  if (numBehind === 1) {\n    if (p0Behind) {\n      IntersectionTests.lineSegmentPlane(p0, p1, plane, u1);\n      IntersectionTests.lineSegmentPlane(p0, p2, plane, u2);\n\n      return {\n        positions: [p0, p1, p2, u1, u2],\n        indices: [\n          // Behind\n          0,\n          3,\n          4,\n\n          // In front\n          1,\n          2,\n          4,\n          1,\n          4,\n          3,\n        ],\n      };\n    } else if (p1Behind) {\n      IntersectionTests.lineSegmentPlane(p1, p2, plane, u1);\n      IntersectionTests.lineSegmentPlane(p1, p0, plane, u2);\n\n      return {\n        positions: [p0, p1, p2, u1, u2],\n        indices: [\n          // Behind\n          1,\n          3,\n          4,\n\n          // In front\n          2,\n          0,\n          4,\n          2,\n          4,\n          3,\n        ],\n      };\n    } else if (p2Behind) {\n      IntersectionTests.lineSegmentPlane(p2, p0, plane, u1);\n      IntersectionTests.lineSegmentPlane(p2, p1, plane, u2);\n\n      return {\n        positions: [p0, p1, p2, u1, u2],\n        indices: [\n          // Behind\n          2,\n          3,\n          4,\n\n          // In front\n          0,\n          1,\n          4,\n          0,\n          4,\n          3,\n        ],\n      };\n    }\n  } else if (numBehind === 2) {\n    if (!p0Behind) {\n      IntersectionTests.lineSegmentPlane(p1, p0, plane, u1);\n      IntersectionTests.lineSegmentPlane(p2, p0, plane, u2);\n\n      return {\n        positions: [p0, p1, p2, u1, u2],\n        indices: [\n          // Behind\n          1,\n          2,\n          4,\n          1,\n          4,\n          3,\n\n          // In front\n          0,\n          3,\n          4,\n        ],\n      };\n    } else if (!p1Behind) {\n      IntersectionTests.lineSegmentPlane(p2, p1, plane, u1);\n      IntersectionTests.lineSegmentPlane(p0, p1, plane, u2);\n\n      return {\n        positions: [p0, p1, p2, u1, u2],\n        indices: [\n          // Behind\n          2,\n          0,\n          4,\n          2,\n          4,\n          3,\n\n          // In front\n          1,\n          3,\n          4,\n        ],\n      };\n    } else if (!p2Behind) {\n      IntersectionTests.lineSegmentPlane(p0, p2, plane, u1);\n      IntersectionTests.lineSegmentPlane(p1, p2, plane, u2);\n\n      return {\n        positions: [p0, p1, p2, u1, u2],\n        indices: [\n          // Behind\n          0,\n          1,\n          4,\n          0,\n          4,\n          3,\n\n          // In front\n          2,\n          3,\n          4,\n        ],\n      };\n    }\n  }\n\n  // if numBehind is 3, the triangle is completely behind the plane;\n  // otherwise, it is completely in front (numBehind is 0).\n  return undefined;\n};\n/* harmony default export */ __webpack_exports__["Z"] = (IntersectionTests);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseURBQWUsaUJBQWlCLEVBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly92dWUzLXdlYnBhY2s1Ly4vbm9kZV9tb2R1bGVzL2Nlc2l1bS9Tb3VyY2UvQ29yZS9JbnRlcnNlY3Rpb25UZXN0cy5qcz82NDUyIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBDYXJ0ZXNpYW4zIGZyb20gXCIuL0NhcnRlc2lhbjMuanNcIjtcbmltcG9ydCBDYXJ0b2dyYXBoaWMgZnJvbSBcIi4vQ2FydG9ncmFwaGljLmpzXCI7XG5pbXBvcnQgZGVmYXVsdFZhbHVlIGZyb20gXCIuL2RlZmF1bHRWYWx1ZS5qc1wiO1xuaW1wb3J0IGRlZmluZWQgZnJvbSBcIi4vZGVmaW5lZC5qc1wiO1xuaW1wb3J0IERldmVsb3BlckVycm9yIGZyb20gXCIuL0RldmVsb3BlckVycm9yLmpzXCI7XG5pbXBvcnQgSW50ZXJ2YWwgZnJvbSBcIi4vSW50ZXJ2YWwuanNcIjtcbmltcG9ydCBDZXNpdW1NYXRoIGZyb20gXCIuL01hdGguanNcIjtcbmltcG9ydCBNYXRyaXgzIGZyb20gXCIuL01hdHJpeDMuanNcIjtcbmltcG9ydCBRdWFkcmF0aWNSZWFsUG9seW5vbWlhbCBmcm9tIFwiLi9RdWFkcmF0aWNSZWFsUG9seW5vbWlhbC5qc1wiO1xuaW1wb3J0IFF1YXJ0aWNSZWFsUG9seW5vbWlhbCBmcm9tIFwiLi9RdWFydGljUmVhbFBvbHlub21pYWwuanNcIjtcbmltcG9ydCBSYXkgZnJvbSBcIi4vUmF5LmpzXCI7XG5cbi8qKlxuICogRnVuY3Rpb25zIGZvciBjb21wdXRpbmcgdGhlIGludGVyc2VjdGlvbiBiZXR3ZWVuIGdlb21ldHJpZXMgc3VjaCBhcyByYXlzLCBwbGFuZXMsIHRyaWFuZ2xlcywgYW5kIGVsbGlwc29pZHMuXG4gKlxuICogQG5hbWVzcGFjZSBJbnRlcnNlY3Rpb25UZXN0c1xuICovXG52YXIgSW50ZXJzZWN0aW9uVGVzdHMgPSB7fTtcblxuLyoqXG4gKiBDb21wdXRlcyB0aGUgaW50ZXJzZWN0aW9uIG9mIGEgcmF5IGFuZCBhIHBsYW5lLlxuICpcbiAqIEBwYXJhbSB7UmF5fSByYXkgVGhlIHJheS5cbiAqIEBwYXJhbSB7UGxhbmV9IHBsYW5lIFRoZSBwbGFuZS5cbiAqIEBwYXJhbSB7Q2FydGVzaWFuM30gW3Jlc3VsdF0gVGhlIG9iamVjdCBvbnRvIHdoaWNoIHRvIHN0b3JlIHRoZSByZXN1bHQuXG4gKiBAcmV0dXJucyB7Q2FydGVzaWFuM30gVGhlIGludGVyc2VjdGlvbiBwb2ludCBvciB1bmRlZmluZWQgaWYgdGhlcmUgaXMgbm8gaW50ZXJzZWN0aW9ucy5cbiAqL1xuSW50ZXJzZWN0aW9uVGVzdHMucmF5UGxhbmUgPSBmdW5jdGlvbiAocmF5LCBwbGFuZSwgcmVzdWx0KSB7XG4gIC8vPj5pbmNsdWRlU3RhcnQoJ2RlYnVnJywgcHJhZ21hcy5kZWJ1Zyk7XG4gIGlmICghZGVmaW5lZChyYXkpKSB7XG4gICAgdGhyb3cgbmV3IERldmVsb3BlckVycm9yKFwicmF5IGlzIHJlcXVpcmVkLlwiKTtcbiAgfVxuICBpZiAoIWRlZmluZWQocGxhbmUpKSB7XG4gICAgdGhyb3cgbmV3IERldmVsb3BlckVycm9yKFwicGxhbmUgaXMgcmVxdWlyZWQuXCIpO1xuICB9XG4gIC8vPj5pbmNsdWRlRW5kKCdkZWJ1ZycpO1xuXG4gIGlmICghZGVmaW5lZChyZXN1bHQpKSB7XG4gICAgcmVzdWx0ID0gbmV3IENhcnRlc2lhbjMoKTtcbiAgfVxuXG4gIHZhciBvcmlnaW4gPSByYXkub3JpZ2luO1xuICB2YXIgZGlyZWN0aW9uID0gcmF5LmRpcmVjdGlvbjtcbiAgdmFyIG5vcm1hbCA9IHBsYW5lLm5vcm1hbDtcbiAgdmFyIGRlbm9taW5hdG9yID0gQ2FydGVzaWFuMy5kb3Qobm9ybWFsLCBkaXJlY3Rpb24pO1xuXG4gIGlmIChNYXRoLmFicyhkZW5vbWluYXRvcikgPCBDZXNpdW1NYXRoLkVQU0lMT04xNSkge1xuICAgIC8vIFJheSBpcyBwYXJhbGxlbCB0byBwbGFuZS4gIFRoZSByYXkgbWF5IGJlIGluIHRoZSBwb2x5Z29uJ3MgcGxhbmUuXG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxuXG4gIHZhciB0ID0gKC1wbGFuZS5kaXN0YW5jZSAtIENhcnRlc2lhbjMuZG90KG5vcm1hbCwgb3JpZ2luKSkgLyBkZW5vbWluYXRvcjtcblxuICBpZiAodCA8IDApIHtcbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG5cbiAgcmVzdWx0ID0gQ2FydGVzaWFuMy5tdWx0aXBseUJ5U2NhbGFyKGRpcmVjdGlvbiwgdCwgcmVzdWx0KTtcbiAgcmV0dXJuIENhcnRlc2lhbjMuYWRkKG9yaWdpbiwgcmVzdWx0LCByZXN1bHQpO1xufTtcblxudmFyIHNjcmF0Y2hFZGdlMCA9IG5ldyBDYXJ0ZXNpYW4zKCk7XG52YXIgc2NyYXRjaEVkZ2UxID0gbmV3IENhcnRlc2lhbjMoKTtcbnZhciBzY3JhdGNoUFZlYyA9IG5ldyBDYXJ0ZXNpYW4zKCk7XG52YXIgc2NyYXRjaFRWZWMgPSBuZXcgQ2FydGVzaWFuMygpO1xudmFyIHNjcmF0Y2hRVmVjID0gbmV3IENhcnRlc2lhbjMoKTtcblxuLyoqXG4gKiBDb21wdXRlcyB0aGUgaW50ZXJzZWN0aW9uIG9mIGEgcmF5IGFuZCBhIHRyaWFuZ2xlIGFzIGEgcGFyYW1ldHJpYyBkaXN0YW5jZSBhbG9uZyB0aGUgaW5wdXQgcmF5LiBUaGUgcmVzdWx0IGlzIG5lZ2F0aXZlIHdoZW4gdGhlIHRyaWFuZ2xlIGlzIGJlaGluZCB0aGUgcmF5LlxuICpcbiAqIEltcGxlbWVudHMge0BsaW5rIGh0dHBzOi8vY2FkeGZlbS5vcmcvaW5mL0Zhc3QlMjBNaW5pbXVtU3RvcmFnZSUyMFJheVRyaWFuZ2xlJTIwSW50ZXJzZWN0aW9uLnBkZnxcbiAqIEZhc3QgTWluaW11bSBTdG9yYWdlIFJheS9UcmlhbmdsZSBJbnRlcnNlY3Rpb259IGJ5IFRvbWFzIE1vbGxlciBhbmQgQmVuIFRydW1ib3JlLlxuICpcbiAqIEBtZW1iZXJvZiBJbnRlcnNlY3Rpb25UZXN0c1xuICpcbiAqIEBwYXJhbSB7UmF5fSByYXkgVGhlIHJheS5cbiAqIEBwYXJhbSB7Q2FydGVzaWFuM30gcDAgVGhlIGZpcnN0IHZlcnRleCBvZiB0aGUgdHJpYW5nbGUuXG4gKiBAcGFyYW0ge0NhcnRlc2lhbjN9IHAxIFRoZSBzZWNvbmQgdmVydGV4IG9mIHRoZSB0cmlhbmdsZS5cbiAqIEBwYXJhbSB7Q2FydGVzaWFuM30gcDIgVGhlIHRoaXJkIHZlcnRleCBvZiB0aGUgdHJpYW5nbGUuXG4gKiBAcGFyYW0ge0Jvb2xlYW59IFtjdWxsQmFja0ZhY2VzPWZhbHNlXSBJZiA8Y29kZT50cnVlPC9jb2RlPiwgd2lsbCBvbmx5IGNvbXB1dGUgYW4gaW50ZXJzZWN0aW9uIHdpdGggdGhlIGZyb250IGZhY2Ugb2YgdGhlIHRyaWFuZ2xlXG4gKiAgICAgICAgICAgICAgICAgIGFuZCByZXR1cm4gdW5kZWZpbmVkIGZvciBpbnRlcnNlY3Rpb25zIHdpdGggdGhlIGJhY2sgZmFjZS5cbiAqIEByZXR1cm5zIHtOdW1iZXJ9IFRoZSBpbnRlcnNlY3Rpb24gYXMgYSBwYXJhbWV0cmljIGRpc3RhbmNlIGFsb25nIHRoZSByYXksIG9yIHVuZGVmaW5lZCBpZiB0aGVyZSBpcyBubyBpbnRlcnNlY3Rpb24uXG4gKi9cbkludGVyc2VjdGlvblRlc3RzLnJheVRyaWFuZ2xlUGFyYW1ldHJpYyA9IGZ1bmN0aW9uIChcbiAgcmF5LFxuICBwMCxcbiAgcDEsXG4gIHAyLFxuICBjdWxsQmFja0ZhY2VzXG4pIHtcbiAgLy8+PmluY2x1ZGVTdGFydCgnZGVidWcnLCBwcmFnbWFzLmRlYnVnKTtcbiAgaWYgKCFkZWZpbmVkKHJheSkpIHtcbiAgICB0aHJvdyBuZXcgRGV2ZWxvcGVyRXJyb3IoXCJyYXkgaXMgcmVxdWlyZWQuXCIpO1xuICB9XG4gIGlmICghZGVmaW5lZChwMCkpIHtcbiAgICB0aHJvdyBuZXcgRGV2ZWxvcGVyRXJyb3IoXCJwMCBpcyByZXF1aXJlZC5cIik7XG4gIH1cbiAgaWYgKCFkZWZpbmVkKHAxKSkge1xuICAgIHRocm93IG5ldyBEZXZlbG9wZXJFcnJvcihcInAxIGlzIHJlcXVpcmVkLlwiKTtcbiAgfVxuICBpZiAoIWRlZmluZWQocDIpKSB7XG4gICAgdGhyb3cgbmV3IERldmVsb3BlckVycm9yKFwicDIgaXMgcmVxdWlyZWQuXCIpO1xuICB9XG4gIC8vPj5pbmNsdWRlRW5kKCdkZWJ1ZycpO1xuXG4gIGN1bGxCYWNrRmFjZXMgPSBkZWZhdWx0VmFsdWUoY3VsbEJhY2tGYWNlcywgZmFsc2UpO1xuXG4gIHZhciBvcmlnaW4gPSByYXkub3JpZ2luO1xuICB2YXIgZGlyZWN0aW9uID0gcmF5LmRpcmVjdGlvbjtcblxuICB2YXIgZWRnZTAgPSBDYXJ0ZXNpYW4zLnN1YnRyYWN0KHAxLCBwMCwgc2NyYXRjaEVkZ2UwKTtcbiAgdmFyIGVkZ2UxID0gQ2FydGVzaWFuMy5zdWJ0cmFjdChwMiwgcDAsIHNjcmF0Y2hFZGdlMSk7XG5cbiAgdmFyIHAgPSBDYXJ0ZXNpYW4zLmNyb3NzKGRpcmVjdGlvbiwgZWRnZTEsIHNjcmF0Y2hQVmVjKTtcbiAgdmFyIGRldCA9IENhcnRlc2lhbjMuZG90KGVkZ2UwLCBwKTtcblxuICB2YXIgdHZlYztcbiAgdmFyIHE7XG5cbiAgdmFyIHU7XG4gIHZhciB2O1xuICB2YXIgdDtcblxuICBpZiAoY3VsbEJhY2tGYWNlcykge1xuICAgIGlmIChkZXQgPCBDZXNpdW1NYXRoLkVQU0lMT042KSB7XG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIHR2ZWMgPSBDYXJ0ZXNpYW4zLnN1YnRyYWN0KG9yaWdpbiwgcDAsIHNjcmF0Y2hUVmVjKTtcbiAgICB1ID0gQ2FydGVzaWFuMy5kb3QodHZlYywgcCk7XG4gICAgaWYgKHUgPCAwLjAgfHwgdSA+IGRldCkge1xuICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICBxID0gQ2FydGVzaWFuMy5jcm9zcyh0dmVjLCBlZGdlMCwgc2NyYXRjaFFWZWMpO1xuXG4gICAgdiA9IENhcnRlc2lhbjMuZG90KGRpcmVjdGlvbiwgcSk7XG4gICAgaWYgKHYgPCAwLjAgfHwgdSArIHYgPiBkZXQpIHtcbiAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgdCA9IENhcnRlc2lhbjMuZG90KGVkZ2UxLCBxKSAvIGRldDtcbiAgfSBlbHNlIHtcbiAgICBpZiAoTWF0aC5hYnMoZGV0KSA8IENlc2l1bU1hdGguRVBTSUxPTjYpIHtcbiAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIHZhciBpbnZEZXQgPSAxLjAgLyBkZXQ7XG5cbiAgICB0dmVjID0gQ2FydGVzaWFuMy5zdWJ0cmFjdChvcmlnaW4sIHAwLCBzY3JhdGNoVFZlYyk7XG4gICAgdSA9IENhcnRlc2lhbjMuZG90KHR2ZWMsIHApICogaW52RGV0O1xuICAgIGlmICh1IDwgMC4wIHx8IHUgPiAxLjApIHtcbiAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgcSA9IENhcnRlc2lhbjMuY3Jvc3ModHZlYywgZWRnZTAsIHNjcmF0Y2hRVmVjKTtcblxuICAgIHYgPSBDYXJ0ZXNpYW4zLmRvdChkaXJlY3Rpb24sIHEpICogaW52RGV0O1xuICAgIGlmICh2IDwgMC4wIHx8IHUgKyB2ID4gMS4wKSB7XG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIHQgPSBDYXJ0ZXNpYW4zLmRvdChlZGdlMSwgcSkgKiBpbnZEZXQ7XG4gIH1cblxuICByZXR1cm4gdDtcbn07XG5cbi8qKlxuICogQ29tcHV0ZXMgdGhlIGludGVyc2VjdGlvbiBvZiBhIHJheSBhbmQgYSB0cmlhbmdsZSBhcyBhIENhcnRlc2lhbjMgY29vcmRpbmF0ZS5cbiAqXG4gKiBJbXBsZW1lbnRzIHtAbGluayBodHRwczovL2NhZHhmZW0ub3JnL2luZi9GYXN0JTIwTWluaW11bVN0b3JhZ2UlMjBSYXlUcmlhbmdsZSUyMEludGVyc2VjdGlvbi5wZGZ8XG4gKiBGYXN0IE1pbmltdW0gU3RvcmFnZSBSYXkvVHJpYW5nbGUgSW50ZXJzZWN0aW9ufSBieSBUb21hcyBNb2xsZXIgYW5kIEJlbiBUcnVtYm9yZS5cbiAqXG4gKiBAbWVtYmVyb2YgSW50ZXJzZWN0aW9uVGVzdHNcbiAqXG4gKiBAcGFyYW0ge1JheX0gcmF5IFRoZSByYXkuXG4gKiBAcGFyYW0ge0NhcnRlc2lhbjN9IHAwIFRoZSBmaXJzdCB2ZXJ0ZXggb2YgdGhlIHRyaWFuZ2xlLlxuICogQHBhcmFtIHtDYXJ0ZXNpYW4zfSBwMSBUaGUgc2Vjb25kIHZlcnRleCBvZiB0aGUgdHJpYW5nbGUuXG4gKiBAcGFyYW0ge0NhcnRlc2lhbjN9IHAyIFRoZSB0aGlyZCB2ZXJ0ZXggb2YgdGhlIHRyaWFuZ2xlLlxuICogQHBhcmFtIHtCb29sZWFufSBbY3VsbEJhY2tGYWNlcz1mYWxzZV0gSWYgPGNvZGU+dHJ1ZTwvY29kZT4sIHdpbGwgb25seSBjb21wdXRlIGFuIGludGVyc2VjdGlvbiB3aXRoIHRoZSBmcm9udCBmYWNlIG9mIHRoZSB0cmlhbmdsZVxuICogICAgICAgICAgICAgICAgICBhbmQgcmV0dXJuIHVuZGVmaW5lZCBmb3IgaW50ZXJzZWN0aW9ucyB3aXRoIHRoZSBiYWNrIGZhY2UuXG4gKiBAcGFyYW0ge0NhcnRlc2lhbjN9IFtyZXN1bHRdIFRoZSA8Y29kZT5DYXJ0ZXNpYW4zPC9jb2RlPiBvbnRvIHdoaWNoIHRvIHN0b3JlIHRoZSByZXN1bHQuXG4gKiBAcmV0dXJucyB7Q2FydGVzaWFuM30gVGhlIGludGVyc2VjdGlvbiBwb2ludCBvciB1bmRlZmluZWQgaWYgdGhlcmUgaXMgbm8gaW50ZXJzZWN0aW9ucy5cbiAqL1xuSW50ZXJzZWN0aW9uVGVzdHMucmF5VHJpYW5nbGUgPSBmdW5jdGlvbiAoXG4gIHJheSxcbiAgcDAsXG4gIHAxLFxuICBwMixcbiAgY3VsbEJhY2tGYWNlcyxcbiAgcmVzdWx0XG4pIHtcbiAgdmFyIHQgPSBJbnRlcnNlY3Rpb25UZXN0cy5yYXlUcmlhbmdsZVBhcmFtZXRyaWMoXG4gICAgcmF5LFxuICAgIHAwLFxuICAgIHAxLFxuICAgIHAyLFxuICAgIGN1bGxCYWNrRmFjZXNcbiAgKTtcbiAgaWYgKCFkZWZpbmVkKHQpIHx8IHQgPCAwLjApIHtcbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG5cbiAgaWYgKCFkZWZpbmVkKHJlc3VsdCkpIHtcbiAgICByZXN1bHQgPSBuZXcgQ2FydGVzaWFuMygpO1xuICB9XG5cbiAgQ2FydGVzaWFuMy5tdWx0aXBseUJ5U2NhbGFyKHJheS5kaXJlY3Rpb24sIHQsIHJlc3VsdCk7XG4gIHJldHVybiBDYXJ0ZXNpYW4zLmFkZChyYXkub3JpZ2luLCByZXN1bHQsIHJlc3VsdCk7XG59O1xuXG52YXIgc2NyYXRjaExpbmVTZWdtZW50VHJpYW5nbGVSYXkgPSBuZXcgUmF5KCk7XG5cbi8qKlxuICogQ29tcHV0ZXMgdGhlIGludGVyc2VjdGlvbiBvZiBhIGxpbmUgc2VnbWVudCBhbmQgYSB0cmlhbmdsZS5cbiAqIEBtZW1iZXJvZiBJbnRlcnNlY3Rpb25UZXN0c1xuICpcbiAqIEBwYXJhbSB7Q2FydGVzaWFuM30gdjAgVGhlIGFuIGVuZCBwb2ludCBvZiB0aGUgbGluZSBzZWdtZW50LlxuICogQHBhcmFtIHtDYXJ0ZXNpYW4zfSB2MSBUaGUgb3RoZXIgZW5kIHBvaW50IG9mIHRoZSBsaW5lIHNlZ21lbnQuXG4gKiBAcGFyYW0ge0NhcnRlc2lhbjN9IHAwIFRoZSBmaXJzdCB2ZXJ0ZXggb2YgdGhlIHRyaWFuZ2xlLlxuICogQHBhcmFtIHtDYXJ0ZXNpYW4zfSBwMSBUaGUgc2Vjb25kIHZlcnRleCBvZiB0aGUgdHJpYW5nbGUuXG4gKiBAcGFyYW0ge0NhcnRlc2lhbjN9IHAyIFRoZSB0aGlyZCB2ZXJ0ZXggb2YgdGhlIHRyaWFuZ2xlLlxuICogQHBhcmFtIHtCb29sZWFufSBbY3VsbEJhY2tGYWNlcz1mYWxzZV0gSWYgPGNvZGU+dHJ1ZTwvY29kZT4sIHdpbGwgb25seSBjb21wdXRlIGFuIGludGVyc2VjdGlvbiB3aXRoIHRoZSBmcm9udCBmYWNlIG9mIHRoZSB0cmlhbmdsZVxuICogICAgICAgICAgICAgICAgICBhbmQgcmV0dXJuIHVuZGVmaW5lZCBmb3IgaW50ZXJzZWN0aW9ucyB3aXRoIHRoZSBiYWNrIGZhY2UuXG4gKiBAcGFyYW0ge0NhcnRlc2lhbjN9IFtyZXN1bHRdIFRoZSA8Y29kZT5DYXJ0ZXNpYW4zPC9jb2RlPiBvbnRvIHdoaWNoIHRvIHN0b3JlIHRoZSByZXN1bHQuXG4gKiBAcmV0dXJucyB7Q2FydGVzaWFuM30gVGhlIGludGVyc2VjdGlvbiBwb2ludCBvciB1bmRlZmluZWQgaWYgdGhlcmUgaXMgbm8gaW50ZXJzZWN0aW9ucy5cbiAqL1xuSW50ZXJzZWN0aW9uVGVzdHMubGluZVNlZ21lbnRUcmlhbmdsZSA9IGZ1bmN0aW9uIChcbiAgdjAsXG4gIHYxLFxuICBwMCxcbiAgcDEsXG4gIHAyLFxuICBjdWxsQmFja0ZhY2VzLFxuICByZXN1bHRcbikge1xuICAvLz4+aW5jbHVkZVN0YXJ0KCdkZWJ1ZycsIHByYWdtYXMuZGVidWcpO1xuICBpZiAoIWRlZmluZWQodjApKSB7XG4gICAgdGhyb3cgbmV3IERldmVsb3BlckVycm9yKFwidjAgaXMgcmVxdWlyZWQuXCIpO1xuICB9XG4gIGlmICghZGVmaW5lZCh2MSkpIHtcbiAgICB0aHJvdyBuZXcgRGV2ZWxvcGVyRXJyb3IoXCJ2MSBpcyByZXF1aXJlZC5cIik7XG4gIH1cbiAgaWYgKCFkZWZpbmVkKHAwKSkge1xuICAgIHRocm93IG5ldyBEZXZlbG9wZXJFcnJvcihcInAwIGlzIHJlcXVpcmVkLlwiKTtcbiAgfVxuICBpZiAoIWRlZmluZWQocDEpKSB7XG4gICAgdGhyb3cgbmV3IERldmVsb3BlckVycm9yKFwicDEgaXMgcmVxdWlyZWQuXCIpO1xuICB9XG4gIGlmICghZGVmaW5lZChwMikpIHtcbiAgICB0aHJvdyBuZXcgRGV2ZWxvcGVyRXJyb3IoXCJwMiBpcyByZXF1aXJlZC5cIik7XG4gIH1cbiAgLy8+PmluY2x1ZGVFbmQoJ2RlYnVnJyk7XG5cbiAgdmFyIHJheSA9IHNjcmF0Y2hMaW5lU2VnbWVudFRyaWFuZ2xlUmF5O1xuICBDYXJ0ZXNpYW4zLmNsb25lKHYwLCByYXkub3JpZ2luKTtcbiAgQ2FydGVzaWFuMy5zdWJ0cmFjdCh2MSwgdjAsIHJheS5kaXJlY3Rpb24pO1xuICBDYXJ0ZXNpYW4zLm5vcm1hbGl6ZShyYXkuZGlyZWN0aW9uLCByYXkuZGlyZWN0aW9uKTtcblxuICB2YXIgdCA9IEludGVyc2VjdGlvblRlc3RzLnJheVRyaWFuZ2xlUGFyYW1ldHJpYyhcbiAgICByYXksXG4gICAgcDAsXG4gICAgcDEsXG4gICAgcDIsXG4gICAgY3VsbEJhY2tGYWNlc1xuICApO1xuICBpZiAoIWRlZmluZWQodCkgfHwgdCA8IDAuMCB8fCB0ID4gQ2FydGVzaWFuMy5kaXN0YW5jZSh2MCwgdjEpKSB7XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxuXG4gIGlmICghZGVmaW5lZChyZXN1bHQpKSB7XG4gICAgcmVzdWx0ID0gbmV3IENhcnRlc2lhbjMoKTtcbiAgfVxuXG4gIENhcnRlc2lhbjMubXVsdGlwbHlCeVNjYWxhcihyYXkuZGlyZWN0aW9uLCB0LCByZXN1bHQpO1xuICByZXR1cm4gQ2FydGVzaWFuMy5hZGQocmF5Lm9yaWdpbiwgcmVzdWx0LCByZXN1bHQpO1xufTtcblxuZnVuY3Rpb24gc29sdmVRdWFkcmF0aWMoYSwgYiwgYywgcmVzdWx0KSB7XG4gIHZhciBkZXQgPSBiICogYiAtIDQuMCAqIGEgKiBjO1xuICBpZiAoZGV0IDwgMC4wKSB7XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfSBlbHNlIGlmIChkZXQgPiAwLjApIHtcbiAgICB2YXIgZGVub20gPSAxLjAgLyAoMi4wICogYSk7XG4gICAgdmFyIGRpc2MgPSBNYXRoLnNxcnQoZGV0KTtcbiAgICB2YXIgcm9vdDAgPSAoLWIgKyBkaXNjKSAqIGRlbm9tO1xuICAgIHZhciByb290MSA9ICgtYiAtIGRpc2MpICogZGVub207XG5cbiAgICBpZiAocm9vdDAgPCByb290MSkge1xuICAgICAgcmVzdWx0LnJvb3QwID0gcm9vdDA7XG4gICAgICByZXN1bHQucm9vdDEgPSByb290MTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVzdWx0LnJvb3QwID0gcm9vdDE7XG4gICAgICByZXN1bHQucm9vdDEgPSByb290MDtcbiAgICB9XG5cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgdmFyIHJvb3QgPSAtYiAvICgyLjAgKiBhKTtcbiAgaWYgKHJvb3QgPT09IDAuMCkge1xuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cblxuICByZXN1bHQucm9vdDAgPSByZXN1bHQucm9vdDEgPSByb290O1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG52YXIgcmF5U3BoZXJlUm9vdHMgPSB7XG4gIHJvb3QwOiAwLjAsXG4gIHJvb3QxOiAwLjAsXG59O1xuXG5mdW5jdGlvbiByYXlTcGhlcmUocmF5LCBzcGhlcmUsIHJlc3VsdCkge1xuICBpZiAoIWRlZmluZWQocmVzdWx0KSkge1xuICAgIHJlc3VsdCA9IG5ldyBJbnRlcnZhbCgpO1xuICB9XG5cbiAgdmFyIG9yaWdpbiA9IHJheS5vcmlnaW47XG4gIHZhciBkaXJlY3Rpb24gPSByYXkuZGlyZWN0aW9uO1xuXG4gIHZhciBjZW50ZXIgPSBzcGhlcmUuY2VudGVyO1xuICB2YXIgcmFkaXVzU3F1YXJlZCA9IHNwaGVyZS5yYWRpdXMgKiBzcGhlcmUucmFkaXVzO1xuXG4gIHZhciBkaWZmID0gQ2FydGVzaWFuMy5zdWJ0cmFjdChvcmlnaW4sIGNlbnRlciwgc2NyYXRjaFBWZWMpO1xuXG4gIHZhciBhID0gQ2FydGVzaWFuMy5kb3QoZGlyZWN0aW9uLCBkaXJlY3Rpb24pO1xuICB2YXIgYiA9IDIuMCAqIENhcnRlc2lhbjMuZG90KGRpcmVjdGlvbiwgZGlmZik7XG4gIHZhciBjID0gQ2FydGVzaWFuMy5tYWduaXR1ZGVTcXVhcmVkKGRpZmYpIC0gcmFkaXVzU3F1YXJlZDtcblxuICB2YXIgcm9vdHMgPSBzb2x2ZVF1YWRyYXRpYyhhLCBiLCBjLCByYXlTcGhlcmVSb290cyk7XG4gIGlmICghZGVmaW5lZChyb290cykpIHtcbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG5cbiAgcmVzdWx0LnN0YXJ0ID0gcm9vdHMucm9vdDA7XG4gIHJlc3VsdC5zdG9wID0gcm9vdHMucm9vdDE7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbi8qKlxuICogQ29tcHV0ZXMgdGhlIGludGVyc2VjdGlvbiBwb2ludHMgb2YgYSByYXkgd2l0aCBhIHNwaGVyZS5cbiAqIEBtZW1iZXJvZiBJbnRlcnNlY3Rpb25UZXN0c1xuICpcbiAqIEBwYXJhbSB7UmF5fSByYXkgVGhlIHJheS5cbiAqIEBwYXJhbSB7Qm91bmRpbmdTcGhlcmV9IHNwaGVyZSBUaGUgc3BoZXJlLlxuICogQHBhcmFtIHtJbnRlcnZhbH0gW3Jlc3VsdF0gVGhlIHJlc3VsdCBvbnRvIHdoaWNoIHRvIHN0b3JlIHRoZSByZXN1bHQuXG4gKiBAcmV0dXJucyB7SW50ZXJ2YWx9IFRoZSBpbnRlcnZhbCBjb250YWluaW5nIHNjYWxhciBwb2ludHMgYWxvbmcgdGhlIHJheSBvciB1bmRlZmluZWQgaWYgdGhlcmUgYXJlIG5vIGludGVyc2VjdGlvbnMuXG4gKi9cbkludGVyc2VjdGlvblRlc3RzLnJheVNwaGVyZSA9IGZ1bmN0aW9uIChyYXksIHNwaGVyZSwgcmVzdWx0KSB7XG4gIC8vPj5pbmNsdWRlU3RhcnQoJ2RlYnVnJywgcHJhZ21hcy5kZWJ1Zyk7XG4gIGlmICghZGVmaW5lZChyYXkpKSB7XG4gICAgdGhyb3cgbmV3IERldmVsb3BlckVycm9yKFwicmF5IGlzIHJlcXVpcmVkLlwiKTtcbiAgfVxuICBpZiAoIWRlZmluZWQoc3BoZXJlKSkge1xuICAgIHRocm93IG5ldyBEZXZlbG9wZXJFcnJvcihcInNwaGVyZSBpcyByZXF1aXJlZC5cIik7XG4gIH1cbiAgLy8+PmluY2x1ZGVFbmQoJ2RlYnVnJyk7XG5cbiAgcmVzdWx0ID0gcmF5U3BoZXJlKHJheSwgc3BoZXJlLCByZXN1bHQpO1xuICBpZiAoIWRlZmluZWQocmVzdWx0KSB8fCByZXN1bHQuc3RvcCA8IDAuMCkge1xuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cblxuICByZXN1bHQuc3RhcnQgPSBNYXRoLm1heChyZXN1bHQuc3RhcnQsIDAuMCk7XG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG52YXIgc2NyYXRjaExpbmVTZWdtZW50UmF5ID0gbmV3IFJheSgpO1xuXG4vKipcbiAqIENvbXB1dGVzIHRoZSBpbnRlcnNlY3Rpb24gcG9pbnRzIG9mIGEgbGluZSBzZWdtZW50IHdpdGggYSBzcGhlcmUuXG4gKiBAbWVtYmVyb2YgSW50ZXJzZWN0aW9uVGVzdHNcbiAqXG4gKiBAcGFyYW0ge0NhcnRlc2lhbjN9IHAwIEFuIGVuZCBwb2ludCBvZiB0aGUgbGluZSBzZWdtZW50LlxuICogQHBhcmFtIHtDYXJ0ZXNpYW4zfSBwMSBUaGUgb3RoZXIgZW5kIHBvaW50IG9mIHRoZSBsaW5lIHNlZ21lbnQuXG4gKiBAcGFyYW0ge0JvdW5kaW5nU3BoZXJlfSBzcGhlcmUgVGhlIHNwaGVyZS5cbiAqIEBwYXJhbSB7SW50ZXJ2YWx9IFtyZXN1bHRdIFRoZSByZXN1bHQgb250byB3aGljaCB0byBzdG9yZSB0aGUgcmVzdWx0LlxuICogQHJldHVybnMge0ludGVydmFsfSBUaGUgaW50ZXJ2YWwgY29udGFpbmluZyBzY2FsYXIgcG9pbnRzIGFsb25nIHRoZSByYXkgb3IgdW5kZWZpbmVkIGlmIHRoZXJlIGFyZSBubyBpbnRlcnNlY3Rpb25zLlxuICovXG5JbnRlcnNlY3Rpb25UZXN0cy5saW5lU2VnbWVudFNwaGVyZSA9IGZ1bmN0aW9uIChwMCwgcDEsIHNwaGVyZSwgcmVzdWx0KSB7XG4gIC8vPj5pbmNsdWRlU3RhcnQoJ2RlYnVnJywgcHJhZ21hcy5kZWJ1Zyk7XG4gIGlmICghZGVmaW5lZChwMCkpIHtcbiAgICB0aHJvdyBuZXcgRGV2ZWxvcGVyRXJyb3IoXCJwMCBpcyByZXF1aXJlZC5cIik7XG4gIH1cbiAgaWYgKCFkZWZpbmVkKHAxKSkge1xuICAgIHRocm93IG5ldyBEZXZlbG9wZXJFcnJvcihcInAxIGlzIHJlcXVpcmVkLlwiKTtcbiAgfVxuICBpZiAoIWRlZmluZWQoc3BoZXJlKSkge1xuICAgIHRocm93IG5ldyBEZXZlbG9wZXJFcnJvcihcInNwaGVyZSBpcyByZXF1aXJlZC5cIik7XG4gIH1cbiAgLy8+PmluY2x1ZGVFbmQoJ2RlYnVnJyk7XG5cbiAgdmFyIHJheSA9IHNjcmF0Y2hMaW5lU2VnbWVudFJheTtcbiAgQ2FydGVzaWFuMy5jbG9uZShwMCwgcmF5Lm9yaWdpbik7XG4gIHZhciBkaXJlY3Rpb24gPSBDYXJ0ZXNpYW4zLnN1YnRyYWN0KHAxLCBwMCwgcmF5LmRpcmVjdGlvbik7XG5cbiAgdmFyIG1heFQgPSBDYXJ0ZXNpYW4zLm1hZ25pdHVkZShkaXJlY3Rpb24pO1xuICBDYXJ0ZXNpYW4zLm5vcm1hbGl6ZShkaXJlY3Rpb24sIGRpcmVjdGlvbik7XG5cbiAgcmVzdWx0ID0gcmF5U3BoZXJlKHJheSwgc3BoZXJlLCByZXN1bHQpO1xuICBpZiAoIWRlZmluZWQocmVzdWx0KSB8fCByZXN1bHQuc3RvcCA8IDAuMCB8fCByZXN1bHQuc3RhcnQgPiBtYXhUKSB7XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxuXG4gIHJlc3VsdC5zdGFydCA9IE1hdGgubWF4KHJlc3VsdC5zdGFydCwgMC4wKTtcbiAgcmVzdWx0LnN0b3AgPSBNYXRoLm1pbihyZXN1bHQuc3RvcCwgbWF4VCk7XG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG52YXIgc2NyYXRjaFEgPSBuZXcgQ2FydGVzaWFuMygpO1xudmFyIHNjcmF0Y2hXID0gbmV3IENhcnRlc2lhbjMoKTtcblxuLyoqXG4gKiBDb21wdXRlcyB0aGUgaW50ZXJzZWN0aW9uIHBvaW50cyBvZiBhIHJheSB3aXRoIGFuIGVsbGlwc29pZC5cbiAqXG4gKiBAcGFyYW0ge1JheX0gcmF5IFRoZSByYXkuXG4gKiBAcGFyYW0ge0VsbGlwc29pZH0gZWxsaXBzb2lkIFRoZSBlbGxpcHNvaWQuXG4gKiBAcmV0dXJucyB7SW50ZXJ2YWx9IFRoZSBpbnRlcnZhbCBjb250YWluaW5nIHNjYWxhciBwb2ludHMgYWxvbmcgdGhlIHJheSBvciB1bmRlZmluZWQgaWYgdGhlcmUgYXJlIG5vIGludGVyc2VjdGlvbnMuXG4gKi9cbkludGVyc2VjdGlvblRlc3RzLnJheUVsbGlwc29pZCA9IGZ1bmN0aW9uIChyYXksIGVsbGlwc29pZCkge1xuICAvLz4+aW5jbHVkZVN0YXJ0KCdkZWJ1ZycsIHByYWdtYXMuZGVidWcpO1xuICBpZiAoIWRlZmluZWQocmF5KSkge1xuICAgIHRocm93IG5ldyBEZXZlbG9wZXJFcnJvcihcInJheSBpcyByZXF1aXJlZC5cIik7XG4gIH1cbiAgaWYgKCFkZWZpbmVkKGVsbGlwc29pZCkpIHtcbiAgICB0aHJvdyBuZXcgRGV2ZWxvcGVyRXJyb3IoXCJlbGxpcHNvaWQgaXMgcmVxdWlyZWQuXCIpO1xuICB9XG4gIC8vPj5pbmNsdWRlRW5kKCdkZWJ1ZycpO1xuXG4gIHZhciBpbnZlcnNlUmFkaWkgPSBlbGxpcHNvaWQub25lT3ZlclJhZGlpO1xuICB2YXIgcSA9IENhcnRlc2lhbjMubXVsdGlwbHlDb21wb25lbnRzKGludmVyc2VSYWRpaSwgcmF5Lm9yaWdpbiwgc2NyYXRjaFEpO1xuICB2YXIgdyA9IENhcnRlc2lhbjMubXVsdGlwbHlDb21wb25lbnRzKGludmVyc2VSYWRpaSwgcmF5LmRpcmVjdGlvbiwgc2NyYXRjaFcpO1xuXG4gIHZhciBxMiA9IENhcnRlc2lhbjMubWFnbml0dWRlU3F1YXJlZChxKTtcbiAgdmFyIHF3ID0gQ2FydGVzaWFuMy5kb3QocSwgdyk7XG5cbiAgdmFyIGRpZmZlcmVuY2UsIHcyLCBwcm9kdWN0LCBkaXNjcmltaW5hbnQsIHRlbXA7XG5cbiAgaWYgKHEyID4gMS4wKSB7XG4gICAgLy8gT3V0c2lkZSBlbGxpcHNvaWQuXG4gICAgaWYgKHF3ID49IDAuMCkge1xuICAgICAgLy8gTG9va2luZyBvdXR3YXJkIG9yIHRhbmdlbnQgKDAgaW50ZXJzZWN0aW9ucykuXG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIC8vIHF3IDwgMC4wLlxuICAgIHZhciBxdzIgPSBxdyAqIHF3O1xuICAgIGRpZmZlcmVuY2UgPSBxMiAtIDEuMDsgLy8gUG9zaXRpdmVseSB2YWx1ZWQuXG4gICAgdzIgPSBDYXJ0ZXNpYW4zLm1hZ25pdHVkZVNxdWFyZWQodyk7XG4gICAgcHJvZHVjdCA9IHcyICogZGlmZmVyZW5jZTtcblxuICAgIGlmIChxdzIgPCBwcm9kdWN0KSB7XG4gICAgICAvLyBJbWFnaW5hcnkgcm9vdHMgKDAgaW50ZXJzZWN0aW9ucykuXG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH0gZWxzZSBpZiAocXcyID4gcHJvZHVjdCkge1xuICAgICAgLy8gRGlzdGluY3Qgcm9vdHMgKDIgaW50ZXJzZWN0aW9ucykuXG4gICAgICBkaXNjcmltaW5hbnQgPSBxdyAqIHF3IC0gcHJvZHVjdDtcbiAgICAgIHRlbXAgPSAtcXcgKyBNYXRoLnNxcnQoZGlzY3JpbWluYW50KTsgLy8gQXZvaWQgY2FuY2VsbGF0aW9uLlxuICAgICAgdmFyIHJvb3QwID0gdGVtcCAvIHcyO1xuICAgICAgdmFyIHJvb3QxID0gZGlmZmVyZW5jZSAvIHRlbXA7XG4gICAgICBpZiAocm9vdDAgPCByb290MSkge1xuICAgICAgICByZXR1cm4gbmV3IEludGVydmFsKHJvb3QwLCByb290MSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIHN0YXJ0OiByb290MSxcbiAgICAgICAgc3RvcDogcm9vdDAsXG4gICAgICB9O1xuICAgIH1cbiAgICAvLyBxdzIgPT0gcHJvZHVjdC4gIFJlcGVhdGVkIHJvb3RzICgyIGludGVyc2VjdGlvbnMpLlxuICAgIHZhciByb290ID0gTWF0aC5zcXJ0KGRpZmZlcmVuY2UgLyB3Mik7XG4gICAgcmV0dXJuIG5ldyBJbnRlcnZhbChyb290LCByb290KTtcbiAgfSBlbHNlIGlmIChxMiA8IDEuMCkge1xuICAgIC8vIEluc2lkZSBlbGxpcHNvaWQgKDIgaW50ZXJzZWN0aW9ucykuXG4gICAgZGlmZmVyZW5jZSA9IHEyIC0gMS4wOyAvLyBOZWdhdGl2ZWx5IHZhbHVlZC5cbiAgICB3MiA9IENhcnRlc2lhbjMubWFnbml0dWRlU3F1YXJlZCh3KTtcbiAgICBwcm9kdWN0ID0gdzIgKiBkaWZmZXJlbmNlOyAvLyBOZWdhdGl2ZWx5IHZhbHVlZC5cblxuICAgIGRpc2NyaW1pbmFudCA9IHF3ICogcXcgLSBwcm9kdWN0O1xuICAgIHRlbXAgPSAtcXcgKyBNYXRoLnNxcnQoZGlzY3JpbWluYW50KTsgLy8gUG9zaXRpdmVseSB2YWx1ZWQuXG4gICAgcmV0dXJuIG5ldyBJbnRlcnZhbCgwLjAsIHRlbXAgLyB3Mik7XG4gIH1cbiAgLy8gcTIgPT0gMS4wLiBPbiBlbGxpcHNvaWQuXG4gIGlmIChxdyA8IDAuMCkge1xuICAgIC8vIExvb2tpbmcgaW53YXJkLlxuICAgIHcyID0gQ2FydGVzaWFuMy5tYWduaXR1ZGVTcXVhcmVkKHcpO1xuICAgIHJldHVybiBuZXcgSW50ZXJ2YWwoMC4wLCAtcXcgLyB3Mik7XG4gIH1cblxuICAvLyBxdyA+PSAwLjAuICBMb29raW5nIG91dHdhcmQgb3IgdGFuZ2VudC5cbiAgcmV0dXJuIHVuZGVmaW5lZDtcbn07XG5cbmZ1bmN0aW9uIGFkZFdpdGhDYW5jZWxsYXRpb25DaGVjayhsZWZ0LCByaWdodCwgdG9sZXJhbmNlKSB7XG4gIHZhciBkaWZmZXJlbmNlID0gbGVmdCArIHJpZ2h0O1xuICBpZiAoXG4gICAgQ2VzaXVtTWF0aC5zaWduKGxlZnQpICE9PSBDZXNpdW1NYXRoLnNpZ24ocmlnaHQpICYmXG4gICAgTWF0aC5hYnMoZGlmZmVyZW5jZSAvIE1hdGgubWF4KE1hdGguYWJzKGxlZnQpLCBNYXRoLmFicyhyaWdodCkpKSA8IHRvbGVyYW5jZVxuICApIHtcbiAgICByZXR1cm4gMC4wO1xuICB9XG5cbiAgcmV0dXJuIGRpZmZlcmVuY2U7XG59XG5cbmZ1bmN0aW9uIHF1YWRyYXRpY1ZlY3RvckV4cHJlc3Npb24oQSwgYiwgYywgeCwgdykge1xuICB2YXIgeFNxdWFyZWQgPSB4ICogeDtcbiAgdmFyIHdTcXVhcmVkID0gdyAqIHc7XG5cbiAgdmFyIGwyID0gKEFbTWF0cml4My5DT0xVTU4xUk9XMV0gLSBBW01hdHJpeDMuQ09MVU1OMlJPVzJdKSAqIHdTcXVhcmVkO1xuICB2YXIgbDEgPVxuICAgIHcgKlxuICAgICh4ICpcbiAgICAgIGFkZFdpdGhDYW5jZWxsYXRpb25DaGVjayhcbiAgICAgICAgQVtNYXRyaXgzLkNPTFVNTjFST1cwXSxcbiAgICAgICAgQVtNYXRyaXgzLkNPTFVNTjBST1cxXSxcbiAgICAgICAgQ2VzaXVtTWF0aC5FUFNJTE9OMTVcbiAgICAgICkgK1xuICAgICAgYi55KTtcbiAgdmFyIGwwID1cbiAgICBBW01hdHJpeDMuQ09MVU1OMFJPVzBdICogeFNxdWFyZWQgK1xuICAgIEFbTWF0cml4My5DT0xVTU4yUk9XMl0gKiB3U3F1YXJlZCArXG4gICAgeCAqIGIueCArXG4gICAgYztcblxuICB2YXIgcjEgPVxuICAgIHdTcXVhcmVkICpcbiAgICBhZGRXaXRoQ2FuY2VsbGF0aW9uQ2hlY2soXG4gICAgICBBW01hdHJpeDMuQ09MVU1OMlJPVzFdLFxuICAgICAgQVtNYXRyaXgzLkNPTFVNTjFST1cyXSxcbiAgICAgIENlc2l1bU1hdGguRVBTSUxPTjE1XG4gICAgKTtcbiAgdmFyIHIwID1cbiAgICB3ICpcbiAgICAoeCAqXG4gICAgICBhZGRXaXRoQ2FuY2VsbGF0aW9uQ2hlY2soQVtNYXRyaXgzLkNPTFVNTjJST1cwXSwgQVtNYXRyaXgzLkNPTFVNTjBST1cyXSkgK1xuICAgICAgYi56KTtcblxuICB2YXIgY29zaW5lcztcbiAgdmFyIHNvbHV0aW9ucyA9IFtdO1xuICBpZiAocjAgPT09IDAuMCAmJiByMSA9PT0gMC4wKSB7XG4gICAgY29zaW5lcyA9IFF1YWRyYXRpY1JlYWxQb2x5bm9taWFsLmNvbXB1dGVSZWFsUm9vdHMobDIsIGwxLCBsMCk7XG4gICAgaWYgKGNvc2luZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm4gc29sdXRpb25zO1xuICAgIH1cblxuICAgIHZhciBjb3NpbmUwID0gY29zaW5lc1swXTtcbiAgICB2YXIgc2luZTAgPSBNYXRoLnNxcnQoTWF0aC5tYXgoMS4wIC0gY29zaW5lMCAqIGNvc2luZTAsIDAuMCkpO1xuICAgIHNvbHV0aW9ucy5wdXNoKG5ldyBDYXJ0ZXNpYW4zKHgsIHcgKiBjb3NpbmUwLCB3ICogLXNpbmUwKSk7XG4gICAgc29sdXRpb25zLnB1c2gobmV3IENhcnRlc2lhbjMoeCwgdyAqIGNvc2luZTAsIHcgKiBzaW5lMCkpO1xuXG4gICAgaWYgKGNvc2luZXMubGVuZ3RoID09PSAyKSB7XG4gICAgICB2YXIgY29zaW5lMSA9IGNvc2luZXNbMV07XG4gICAgICB2YXIgc2luZTEgPSBNYXRoLnNxcnQoTWF0aC5tYXgoMS4wIC0gY29zaW5lMSAqIGNvc2luZTEsIDAuMCkpO1xuICAgICAgc29sdXRpb25zLnB1c2gobmV3IENhcnRlc2lhbjMoeCwgdyAqIGNvc2luZTEsIHcgKiAtc2luZTEpKTtcbiAgICAgIHNvbHV0aW9ucy5wdXNoKG5ldyBDYXJ0ZXNpYW4zKHgsIHcgKiBjb3NpbmUxLCB3ICogc2luZTEpKTtcbiAgICB9XG5cbiAgICByZXR1cm4gc29sdXRpb25zO1xuICB9XG5cbiAgdmFyIHIwU3F1YXJlZCA9IHIwICogcjA7XG4gIHZhciByMVNxdWFyZWQgPSByMSAqIHIxO1xuICB2YXIgbDJTcXVhcmVkID0gbDIgKiBsMjtcbiAgdmFyIHIwcjEgPSByMCAqIHIxO1xuXG4gIHZhciBjNCA9IGwyU3F1YXJlZCArIHIxU3F1YXJlZDtcbiAgdmFyIGMzID0gMi4wICogKGwxICogbDIgKyByMHIxKTtcbiAgdmFyIGMyID0gMi4wICogbDAgKiBsMiArIGwxICogbDEgLSByMVNxdWFyZWQgKyByMFNxdWFyZWQ7XG4gIHZhciBjMSA9IDIuMCAqIChsMCAqIGwxIC0gcjByMSk7XG4gIHZhciBjMCA9IGwwICogbDAgLSByMFNxdWFyZWQ7XG5cbiAgaWYgKGM0ID09PSAwLjAgJiYgYzMgPT09IDAuMCAmJiBjMiA9PT0gMC4wICYmIGMxID09PSAwLjApIHtcbiAgICByZXR1cm4gc29sdXRpb25zO1xuICB9XG5cbiAgY29zaW5lcyA9IFF1YXJ0aWNSZWFsUG9seW5vbWlhbC5jb21wdXRlUmVhbFJvb3RzKGM0LCBjMywgYzIsIGMxLCBjMCk7XG4gIHZhciBsZW5ndGggPSBjb3NpbmVzLmxlbmd0aDtcbiAgaWYgKGxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiBzb2x1dGlvbnM7XG4gIH1cblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgKytpKSB7XG4gICAgdmFyIGNvc2luZSA9IGNvc2luZXNbaV07XG4gICAgdmFyIGNvc2luZVNxdWFyZWQgPSBjb3NpbmUgKiBjb3NpbmU7XG4gICAgdmFyIHNpbmVTcXVhcmVkID0gTWF0aC5tYXgoMS4wIC0gY29zaW5lU3F1YXJlZCwgMC4wKTtcbiAgICB2YXIgc2luZSA9IE1hdGguc3FydChzaW5lU3F1YXJlZCk7XG5cbiAgICAvL3ZhciBsZWZ0ID0gbDIgKiBjb3NpbmVTcXVhcmVkICsgbDEgKiBjb3NpbmUgKyBsMDtcbiAgICB2YXIgbGVmdDtcbiAgICBpZiAoQ2VzaXVtTWF0aC5zaWduKGwyKSA9PT0gQ2VzaXVtTWF0aC5zaWduKGwwKSkge1xuICAgICAgbGVmdCA9IGFkZFdpdGhDYW5jZWxsYXRpb25DaGVjayhcbiAgICAgICAgbDIgKiBjb3NpbmVTcXVhcmVkICsgbDAsXG4gICAgICAgIGwxICogY29zaW5lLFxuICAgICAgICBDZXNpdW1NYXRoLkVQU0lMT04xMlxuICAgICAgKTtcbiAgICB9IGVsc2UgaWYgKENlc2l1bU1hdGguc2lnbihsMCkgPT09IENlc2l1bU1hdGguc2lnbihsMSAqIGNvc2luZSkpIHtcbiAgICAgIGxlZnQgPSBhZGRXaXRoQ2FuY2VsbGF0aW9uQ2hlY2soXG4gICAgICAgIGwyICogY29zaW5lU3F1YXJlZCxcbiAgICAgICAgbDEgKiBjb3NpbmUgKyBsMCxcbiAgICAgICAgQ2VzaXVtTWF0aC5FUFNJTE9OMTJcbiAgICAgICk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGxlZnQgPSBhZGRXaXRoQ2FuY2VsbGF0aW9uQ2hlY2soXG4gICAgICAgIGwyICogY29zaW5lU3F1YXJlZCArIGwxICogY29zaW5lLFxuICAgICAgICBsMCxcbiAgICAgICAgQ2VzaXVtTWF0aC5FUFNJTE9OMTJcbiAgICAgICk7XG4gICAgfVxuXG4gICAgdmFyIHJpZ2h0ID0gYWRkV2l0aENhbmNlbGxhdGlvbkNoZWNrKHIxICogY29zaW5lLCByMCwgQ2VzaXVtTWF0aC5FUFNJTE9OMTUpO1xuICAgIHZhciBwcm9kdWN0ID0gbGVmdCAqIHJpZ2h0O1xuXG4gICAgaWYgKHByb2R1Y3QgPCAwLjApIHtcbiAgICAgIHNvbHV0aW9ucy5wdXNoKG5ldyBDYXJ0ZXNpYW4zKHgsIHcgKiBjb3NpbmUsIHcgKiBzaW5lKSk7XG4gICAgfSBlbHNlIGlmIChwcm9kdWN0ID4gMC4wKSB7XG4gICAgICBzb2x1dGlvbnMucHVzaChuZXcgQ2FydGVzaWFuMyh4LCB3ICogY29zaW5lLCB3ICogLXNpbmUpKTtcbiAgICB9IGVsc2UgaWYgKHNpbmUgIT09IDAuMCkge1xuICAgICAgc29sdXRpb25zLnB1c2gobmV3IENhcnRlc2lhbjMoeCwgdyAqIGNvc2luZSwgdyAqIC1zaW5lKSk7XG4gICAgICBzb2x1dGlvbnMucHVzaChuZXcgQ2FydGVzaWFuMyh4LCB3ICogY29zaW5lLCB3ICogc2luZSkpO1xuICAgICAgKytpO1xuICAgIH0gZWxzZSB7XG4gICAgICBzb2x1dGlvbnMucHVzaChuZXcgQ2FydGVzaWFuMyh4LCB3ICogY29zaW5lLCB3ICogc2luZSkpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBzb2x1dGlvbnM7XG59XG5cbnZhciBmaXJzdEF4aXNTY3JhdGNoID0gbmV3IENhcnRlc2lhbjMoKTtcbnZhciBzZWNvbmRBeGlzU2NyYXRjaCA9IG5ldyBDYXJ0ZXNpYW4zKCk7XG52YXIgdGhpcmRBeGlzU2NyYXRjaCA9IG5ldyBDYXJ0ZXNpYW4zKCk7XG52YXIgcmVmZXJlbmNlU2NyYXRjaCA9IG5ldyBDYXJ0ZXNpYW4zKCk7XG52YXIgYkNhcnQgPSBuZXcgQ2FydGVzaWFuMygpO1xudmFyIGJTY3JhdGNoID0gbmV3IE1hdHJpeDMoKTtcbnZhciBidFNjcmF0Y2ggPSBuZXcgTWF0cml4MygpO1xudmFyIGRpU2NyYXRjaCA9IG5ldyBNYXRyaXgzKCk7XG52YXIgZFNjcmF0Y2ggPSBuZXcgTWF0cml4MygpO1xudmFyIGNTY3JhdGNoID0gbmV3IE1hdHJpeDMoKTtcbnZhciB0ZW1wTWF0cml4ID0gbmV3IE1hdHJpeDMoKTtcbnZhciBhU2NyYXRjaCA9IG5ldyBNYXRyaXgzKCk7XG52YXIgc1NjcmF0Y2ggPSBuZXcgQ2FydGVzaWFuMygpO1xudmFyIGNsb3Nlc3RTY3JhdGNoID0gbmV3IENhcnRlc2lhbjMoKTtcbnZhciBzdXJmUG9pbnRTY3JhdGNoID0gbmV3IENhcnRvZ3JhcGhpYygpO1xuXG4vKipcbiAqIFByb3ZpZGVzIHRoZSBwb2ludCBhbG9uZyB0aGUgcmF5IHdoaWNoIGlzIG5lYXJlc3QgdG8gdGhlIGVsbGlwc29pZC5cbiAqXG4gKiBAcGFyYW0ge1JheX0gcmF5IFRoZSByYXkuXG4gKiBAcGFyYW0ge0VsbGlwc29pZH0gZWxsaXBzb2lkIFRoZSBlbGxpcHNvaWQuXG4gKiBAcmV0dXJucyB7Q2FydGVzaWFuM30gVGhlIG5lYXJlc3QgcGxhbmV0b2RldGljIHBvaW50IG9uIHRoZSByYXkuXG4gKi9cbkludGVyc2VjdGlvblRlc3RzLmdyYXppbmdBbHRpdHVkZUxvY2F0aW9uID0gZnVuY3Rpb24gKHJheSwgZWxsaXBzb2lkKSB7XG4gIC8vPj5pbmNsdWRlU3RhcnQoJ2RlYnVnJywgcHJhZ21hcy5kZWJ1Zyk7XG4gIGlmICghZGVmaW5lZChyYXkpKSB7XG4gICAgdGhyb3cgbmV3IERldmVsb3BlckVycm9yKFwicmF5IGlzIHJlcXVpcmVkLlwiKTtcbiAgfVxuICBpZiAoIWRlZmluZWQoZWxsaXBzb2lkKSkge1xuICAgIHRocm93IG5ldyBEZXZlbG9wZXJFcnJvcihcImVsbGlwc29pZCBpcyByZXF1aXJlZC5cIik7XG4gIH1cbiAgLy8+PmluY2x1ZGVFbmQoJ2RlYnVnJyk7XG5cbiAgdmFyIHBvc2l0aW9uID0gcmF5Lm9yaWdpbjtcbiAgdmFyIGRpcmVjdGlvbiA9IHJheS5kaXJlY3Rpb247XG5cbiAgaWYgKCFDYXJ0ZXNpYW4zLmVxdWFscyhwb3NpdGlvbiwgQ2FydGVzaWFuMy5aRVJPKSkge1xuICAgIHZhciBub3JtYWwgPSBlbGxpcHNvaWQuZ2VvZGV0aWNTdXJmYWNlTm9ybWFsKHBvc2l0aW9uLCBmaXJzdEF4aXNTY3JhdGNoKTtcbiAgICBpZiAoQ2FydGVzaWFuMy5kb3QoZGlyZWN0aW9uLCBub3JtYWwpID49IDAuMCkge1xuICAgICAgLy8gVGhlIGxvY2F0aW9uIHByb3ZpZGVkIGlzIHRoZSBjbG9zZXN0IHBvaW50IGluIGFsdGl0dWRlXG4gICAgICByZXR1cm4gcG9zaXRpb247XG4gICAgfVxuICB9XG5cbiAgdmFyIGludGVyc2VjdHMgPSBkZWZpbmVkKHRoaXMucmF5RWxsaXBzb2lkKHJheSwgZWxsaXBzb2lkKSk7XG5cbiAgLy8gQ29tcHV0ZSB0aGUgc2NhbGVkIGRpcmVjdGlvbiB2ZWN0b3IuXG4gIHZhciBmID0gZWxsaXBzb2lkLnRyYW5zZm9ybVBvc2l0aW9uVG9TY2FsZWRTcGFjZShkaXJlY3Rpb24sIGZpcnN0QXhpc1NjcmF0Y2gpO1xuXG4gIC8vIENvbnN0cnVjdHMgYSBiYXNpcyBmcm9tIHRoZSB1bml0IHNjYWxlZCBkaXJlY3Rpb24gdmVjdG9yLiBDb25zdHJ1Y3QgaXRzIHJvdGF0aW9uIGFuZCB0cmFuc3Bvc2UuXG4gIHZhciBmaXJzdEF4aXMgPSBDYXJ0ZXNpYW4zLm5vcm1hbGl6ZShmLCBmKTtcbiAgdmFyIHJlZmVyZW5jZSA9IENhcnRlc2lhbjMubW9zdE9ydGhvZ29uYWxBeGlzKGYsIHJlZmVyZW5jZVNjcmF0Y2gpO1xuICB2YXIgc2Vjb25kQXhpcyA9IENhcnRlc2lhbjMubm9ybWFsaXplKFxuICAgIENhcnRlc2lhbjMuY3Jvc3MocmVmZXJlbmNlLCBmaXJzdEF4aXMsIHNlY29uZEF4aXNTY3JhdGNoKSxcbiAgICBzZWNvbmRBeGlzU2NyYXRjaFxuICApO1xuICB2YXIgdGhpcmRBeGlzID0gQ2FydGVzaWFuMy5ub3JtYWxpemUoXG4gICAgQ2FydGVzaWFuMy5jcm9zcyhmaXJzdEF4aXMsIHNlY29uZEF4aXMsIHRoaXJkQXhpc1NjcmF0Y2gpLFxuICAgIHRoaXJkQXhpc1NjcmF0Y2hcbiAgKTtcbiAgdmFyIEIgPSBiU2NyYXRjaDtcbiAgQlswXSA9IGZpcnN0QXhpcy54O1xuICBCWzFdID0gZmlyc3RBeGlzLnk7XG4gIEJbMl0gPSBmaXJzdEF4aXMuejtcbiAgQlszXSA9IHNlY29uZEF4aXMueDtcbiAgQls0XSA9IHNlY29uZEF4aXMueTtcbiAgQls1XSA9IHNlY29uZEF4aXMuejtcbiAgQls2XSA9IHRoaXJkQXhpcy54O1xuICBCWzddID0gdGhpcmRBeGlzLnk7XG4gIEJbOF0gPSB0aGlyZEF4aXMuejtcblxuICB2YXIgQl9UID0gTWF0cml4My50cmFuc3Bvc2UoQiwgYnRTY3JhdGNoKTtcblxuICAvLyBHZXQgdGhlIHNjYWxpbmcgbWF0cml4IGFuZCBpdHMgaW52ZXJzZS5cbiAgdmFyIERfSSA9IE1hdHJpeDMuZnJvbVNjYWxlKGVsbGlwc29pZC5yYWRpaSwgZGlTY3JhdGNoKTtcbiAgdmFyIEQgPSBNYXRyaXgzLmZyb21TY2FsZShlbGxpcHNvaWQub25lT3ZlclJhZGlpLCBkU2NyYXRjaCk7XG5cbiAgdmFyIEMgPSBjU2NyYXRjaDtcbiAgQ1swXSA9IDAuMDtcbiAgQ1sxXSA9IC1kaXJlY3Rpb24uejtcbiAgQ1syXSA9IGRpcmVjdGlvbi55O1xuICBDWzNdID0gZGlyZWN0aW9uLno7XG4gIENbNF0gPSAwLjA7XG4gIENbNV0gPSAtZGlyZWN0aW9uLng7XG4gIENbNl0gPSAtZGlyZWN0aW9uLnk7XG4gIENbN10gPSBkaXJlY3Rpb24ueDtcbiAgQ1s4XSA9IDAuMDtcblxuICB2YXIgdGVtcCA9IE1hdHJpeDMubXVsdGlwbHkoXG4gICAgTWF0cml4My5tdWx0aXBseShCX1QsIEQsIHRlbXBNYXRyaXgpLFxuICAgIEMsXG4gICAgdGVtcE1hdHJpeFxuICApO1xuICB2YXIgQSA9IE1hdHJpeDMubXVsdGlwbHkoTWF0cml4My5tdWx0aXBseSh0ZW1wLCBEX0ksIGFTY3JhdGNoKSwgQiwgYVNjcmF0Y2gpO1xuICB2YXIgYiA9IE1hdHJpeDMubXVsdGlwbHlCeVZlY3Rvcih0ZW1wLCBwb3NpdGlvbiwgYkNhcnQpO1xuXG4gIC8vIFNvbHZlIGZvciB0aGUgc29sdXRpb25zIHRvIHRoZSBleHByZXNzaW9uIGluIHN0YW5kYXJkIGZvcm06XG4gIHZhciBzb2x1dGlvbnMgPSBxdWFkcmF0aWNWZWN0b3JFeHByZXNzaW9uKFxuICAgIEEsXG4gICAgQ2FydGVzaWFuMy5uZWdhdGUoYiwgZmlyc3RBeGlzU2NyYXRjaCksXG4gICAgMC4wLFxuICAgIDAuMCxcbiAgICAxLjBcbiAgKTtcblxuICB2YXIgcztcbiAgdmFyIGFsdGl0dWRlO1xuICB2YXIgbGVuZ3RoID0gc29sdXRpb25zLmxlbmd0aDtcbiAgaWYgKGxlbmd0aCA+IDApIHtcbiAgICB2YXIgY2xvc2VzdCA9IENhcnRlc2lhbjMuY2xvbmUoQ2FydGVzaWFuMy5aRVJPLCBjbG9zZXN0U2NyYXRjaCk7XG4gICAgdmFyIG1heGltdW1WYWx1ZSA9IE51bWJlci5ORUdBVElWRV9JTkZJTklUWTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kpIHtcbiAgICAgIHMgPSBNYXRyaXgzLm11bHRpcGx5QnlWZWN0b3IoXG4gICAgICAgIERfSSxcbiAgICAgICAgTWF0cml4My5tdWx0aXBseUJ5VmVjdG9yKEIsIHNvbHV0aW9uc1tpXSwgc1NjcmF0Y2gpLFxuICAgICAgICBzU2NyYXRjaFxuICAgICAgKTtcbiAgICAgIHZhciB2ID0gQ2FydGVzaWFuMy5ub3JtYWxpemUoXG4gICAgICAgIENhcnRlc2lhbjMuc3VidHJhY3QocywgcG9zaXRpb24sIHJlZmVyZW5jZVNjcmF0Y2gpLFxuICAgICAgICByZWZlcmVuY2VTY3JhdGNoXG4gICAgICApO1xuICAgICAgdmFyIGRvdFByb2R1Y3QgPSBDYXJ0ZXNpYW4zLmRvdCh2LCBkaXJlY3Rpb24pO1xuXG4gICAgICBpZiAoZG90UHJvZHVjdCA+IG1heGltdW1WYWx1ZSkge1xuICAgICAgICBtYXhpbXVtVmFsdWUgPSBkb3RQcm9kdWN0O1xuICAgICAgICBjbG9zZXN0ID0gQ2FydGVzaWFuMy5jbG9uZShzLCBjbG9zZXN0KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgc3VyZmFjZVBvaW50ID0gZWxsaXBzb2lkLmNhcnRlc2lhblRvQ2FydG9ncmFwaGljKFxuICAgICAgY2xvc2VzdCxcbiAgICAgIHN1cmZQb2ludFNjcmF0Y2hcbiAgICApO1xuICAgIG1heGltdW1WYWx1ZSA9IENlc2l1bU1hdGguY2xhbXAobWF4aW11bVZhbHVlLCAwLjAsIDEuMCk7XG4gICAgYWx0aXR1ZGUgPVxuICAgICAgQ2FydGVzaWFuMy5tYWduaXR1ZGUoXG4gICAgICAgIENhcnRlc2lhbjMuc3VidHJhY3QoY2xvc2VzdCwgcG9zaXRpb24sIHJlZmVyZW5jZVNjcmF0Y2gpXG4gICAgICApICogTWF0aC5zcXJ0KDEuMCAtIG1heGltdW1WYWx1ZSAqIG1heGltdW1WYWx1ZSk7XG4gICAgYWx0aXR1ZGUgPSBpbnRlcnNlY3RzID8gLWFsdGl0dWRlIDogYWx0aXR1ZGU7XG4gICAgc3VyZmFjZVBvaW50LmhlaWdodCA9IGFsdGl0dWRlO1xuICAgIHJldHVybiBlbGxpcHNvaWQuY2FydG9ncmFwaGljVG9DYXJ0ZXNpYW4oc3VyZmFjZVBvaW50LCBuZXcgQ2FydGVzaWFuMygpKTtcbiAgfVxuXG4gIHJldHVybiB1bmRlZmluZWQ7XG59O1xuXG52YXIgbGluZVNlZ21lbnRQbGFuZURpZmZlcmVuY2UgPSBuZXcgQ2FydGVzaWFuMygpO1xuXG4vKipcbiAqIENvbXB1dGVzIHRoZSBpbnRlcnNlY3Rpb24gb2YgYSBsaW5lIHNlZ21lbnQgYW5kIGEgcGxhbmUuXG4gKlxuICogQHBhcmFtIHtDYXJ0ZXNpYW4zfSBlbmRQb2ludDAgQW4gZW5kIHBvaW50IG9mIHRoZSBsaW5lIHNlZ21lbnQuXG4gKiBAcGFyYW0ge0NhcnRlc2lhbjN9IGVuZFBvaW50MSBUaGUgb3RoZXIgZW5kIHBvaW50IG9mIHRoZSBsaW5lIHNlZ21lbnQuXG4gKiBAcGFyYW0ge1BsYW5lfSBwbGFuZSBUaGUgcGxhbmUuXG4gKiBAcGFyYW0ge0NhcnRlc2lhbjN9IFtyZXN1bHRdIFRoZSBvYmplY3Qgb250byB3aGljaCB0byBzdG9yZSB0aGUgcmVzdWx0LlxuICogQHJldHVybnMge0NhcnRlc2lhbjN9IFRoZSBpbnRlcnNlY3Rpb24gcG9pbnQgb3IgdW5kZWZpbmVkIGlmIHRoZXJlIGlzIG5vIGludGVyc2VjdGlvbi5cbiAqXG4gKiBAZXhhbXBsZVxuICogdmFyIG9yaWdpbiA9IENlc2l1bS5DYXJ0ZXNpYW4zLmZyb21EZWdyZWVzKC03NS41OTc3NywgNDAuMDM4ODMpO1xuICogdmFyIG5vcm1hbCA9IGVsbGlwc29pZC5nZW9kZXRpY1N1cmZhY2VOb3JtYWwob3JpZ2luKTtcbiAqIHZhciBwbGFuZSA9IENlc2l1bS5QbGFuZS5mcm9tUG9pbnROb3JtYWwob3JpZ2luLCBub3JtYWwpO1xuICpcbiAqIHZhciBwMCA9IG5ldyBDZXNpdW0uQ2FydGVzaWFuMyguLi4pO1xuICogdmFyIHAxID0gbmV3IENlc2l1bS5DYXJ0ZXNpYW4zKC4uLik7XG4gKlxuICogLy8gZmluZCB0aGUgaW50ZXJzZWN0aW9uIG9mIHRoZSBsaW5lIHNlZ21lbnQgZnJvbSBwMCB0byBwMSBhbmQgdGhlIHRhbmdlbnQgcGxhbmUgYXQgb3JpZ2luLlxuICogdmFyIGludGVyc2VjdGlvbiA9IENlc2l1bS5JbnRlcnNlY3Rpb25UZXN0cy5saW5lU2VnbWVudFBsYW5lKHAwLCBwMSwgcGxhbmUpO1xuICovXG5JbnRlcnNlY3Rpb25UZXN0cy5saW5lU2VnbWVudFBsYW5lID0gZnVuY3Rpb24gKFxuICBlbmRQb2ludDAsXG4gIGVuZFBvaW50MSxcbiAgcGxhbmUsXG4gIHJlc3VsdFxuKSB7XG4gIC8vPj5pbmNsdWRlU3RhcnQoJ2RlYnVnJywgcHJhZ21hcy5kZWJ1Zyk7XG4gIGlmICghZGVmaW5lZChlbmRQb2ludDApKSB7XG4gICAgdGhyb3cgbmV3IERldmVsb3BlckVycm9yKFwiZW5kUG9pbnQwIGlzIHJlcXVpcmVkLlwiKTtcbiAgfVxuICBpZiAoIWRlZmluZWQoZW5kUG9pbnQxKSkge1xuICAgIHRocm93IG5ldyBEZXZlbG9wZXJFcnJvcihcImVuZFBvaW50MSBpcyByZXF1aXJlZC5cIik7XG4gIH1cbiAgaWYgKCFkZWZpbmVkKHBsYW5lKSkge1xuICAgIHRocm93IG5ldyBEZXZlbG9wZXJFcnJvcihcInBsYW5lIGlzIHJlcXVpcmVkLlwiKTtcbiAgfVxuICAvLz4+aW5jbHVkZUVuZCgnZGVidWcnKTtcblxuICBpZiAoIWRlZmluZWQocmVzdWx0KSkge1xuICAgIHJlc3VsdCA9IG5ldyBDYXJ0ZXNpYW4zKCk7XG4gIH1cblxuICB2YXIgZGlmZmVyZW5jZSA9IENhcnRlc2lhbjMuc3VidHJhY3QoXG4gICAgZW5kUG9pbnQxLFxuICAgIGVuZFBvaW50MCxcbiAgICBsaW5lU2VnbWVudFBsYW5lRGlmZmVyZW5jZVxuICApO1xuICB2YXIgbm9ybWFsID0gcGxhbmUubm9ybWFsO1xuICB2YXIgbkRvdERpZmYgPSBDYXJ0ZXNpYW4zLmRvdChub3JtYWwsIGRpZmZlcmVuY2UpO1xuXG4gIC8vIGNoZWNrIGlmIHRoZSBzZWdtZW50IGFuZCBwbGFuZSBhcmUgcGFyYWxsZWxcbiAgaWYgKE1hdGguYWJzKG5Eb3REaWZmKSA8IENlc2l1bU1hdGguRVBTSUxPTjYpIHtcbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG5cbiAgdmFyIG5Eb3RQMCA9IENhcnRlc2lhbjMuZG90KG5vcm1hbCwgZW5kUG9pbnQwKTtcbiAgdmFyIHQgPSAtKHBsYW5lLmRpc3RhbmNlICsgbkRvdFAwKSAvIG5Eb3REaWZmO1xuXG4gIC8vIGludGVyc2VjdGlvbiBvbmx5IGlmIHQgaXMgaW4gWzAsIDFdXG4gIGlmICh0IDwgMC4wIHx8IHQgPiAxLjApIHtcbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG5cbiAgLy8gaW50ZXJzZWN0aW9uIGlzIGVuZFBvaW50MCArIHQgKiAoZW5kUG9pbnQxIC0gZW5kUG9pbnQwKVxuICBDYXJ0ZXNpYW4zLm11bHRpcGx5QnlTY2FsYXIoZGlmZmVyZW5jZSwgdCwgcmVzdWx0KTtcbiAgQ2FydGVzaWFuMy5hZGQoZW5kUG9pbnQwLCByZXN1bHQsIHJlc3VsdCk7XG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG4vKipcbiAqIENvbXB1dGVzIHRoZSBpbnRlcnNlY3Rpb24gb2YgYSB0cmlhbmdsZSBhbmQgYSBwbGFuZVxuICpcbiAqIEBwYXJhbSB7Q2FydGVzaWFuM30gcDAgRmlyc3QgcG9pbnQgb2YgdGhlIHRyaWFuZ2xlXG4gKiBAcGFyYW0ge0NhcnRlc2lhbjN9IHAxIFNlY29uZCBwb2ludCBvZiB0aGUgdHJpYW5nbGVcbiAqIEBwYXJhbSB7Q2FydGVzaWFuM30gcDIgVGhpcmQgcG9pbnQgb2YgdGhlIHRyaWFuZ2xlXG4gKiBAcGFyYW0ge1BsYW5lfSBwbGFuZSBJbnRlcnNlY3Rpb24gcGxhbmVcbiAqIEByZXR1cm5zIHtPYmplY3R9IEFuIG9iamVjdCB3aXRoIHByb3BlcnRpZXMgPGNvZGU+cG9zaXRpb25zPC9jb2RlPiBhbmQgPGNvZGU+aW5kaWNlczwvY29kZT4sIHdoaWNoIGFyZSBhcnJheXMgdGhhdCByZXByZXNlbnQgdGhyZWUgdHJpYW5nbGVzIHRoYXQgZG8gbm90IGNyb3NzIHRoZSBwbGFuZS4gKFVuZGVmaW5lZCBpZiBubyBpbnRlcnNlY3Rpb24gZXhpc3RzKVxuICpcbiAqIEBleGFtcGxlXG4gKiB2YXIgb3JpZ2luID0gQ2VzaXVtLkNhcnRlc2lhbjMuZnJvbURlZ3JlZXMoLTc1LjU5Nzc3LCA0MC4wMzg4Myk7XG4gKiB2YXIgbm9ybWFsID0gZWxsaXBzb2lkLmdlb2RldGljU3VyZmFjZU5vcm1hbChvcmlnaW4pO1xuICogdmFyIHBsYW5lID0gQ2VzaXVtLlBsYW5lLmZyb21Qb2ludE5vcm1hbChvcmlnaW4sIG5vcm1hbCk7XG4gKlxuICogdmFyIHAwID0gbmV3IENlc2l1bS5DYXJ0ZXNpYW4zKC4uLik7XG4gKiB2YXIgcDEgPSBuZXcgQ2VzaXVtLkNhcnRlc2lhbjMoLi4uKTtcbiAqIHZhciBwMiA9IG5ldyBDZXNpdW0uQ2FydGVzaWFuMyguLi4pO1xuICpcbiAqIC8vIGNvbnZlcnQgdGhlIHRyaWFuZ2xlIGNvbXBvc2VkIG9mIHBvaW50cyAocDAsIHAxLCBwMikgdG8gdGhyZWUgdHJpYW5nbGVzIHRoYXQgZG9uJ3QgY3Jvc3MgdGhlIHBsYW5lXG4gKiB2YXIgdHJpYW5nbGVzID0gQ2VzaXVtLkludGVyc2VjdGlvblRlc3RzLnRyaWFuZ2xlUGxhbmVJbnRlcnNlY3Rpb24ocDAsIHAxLCBwMiwgcGxhbmUpO1xuICovXG5JbnRlcnNlY3Rpb25UZXN0cy50cmlhbmdsZVBsYW5lSW50ZXJzZWN0aW9uID0gZnVuY3Rpb24gKHAwLCBwMSwgcDIsIHBsYW5lKSB7XG4gIC8vPj5pbmNsdWRlU3RhcnQoJ2RlYnVnJywgcHJhZ21hcy5kZWJ1Zyk7XG4gIGlmICghZGVmaW5lZChwMCkgfHwgIWRlZmluZWQocDEpIHx8ICFkZWZpbmVkKHAyKSB8fCAhZGVmaW5lZChwbGFuZSkpIHtcbiAgICB0aHJvdyBuZXcgRGV2ZWxvcGVyRXJyb3IoXCJwMCwgcDEsIHAyLCBhbmQgcGxhbmUgYXJlIHJlcXVpcmVkLlwiKTtcbiAgfVxuICAvLz4+aW5jbHVkZUVuZCgnZGVidWcnKTtcblxuICB2YXIgcGxhbmVOb3JtYWwgPSBwbGFuZS5ub3JtYWw7XG4gIHZhciBwbGFuZUQgPSBwbGFuZS5kaXN0YW5jZTtcbiAgdmFyIHAwQmVoaW5kID0gQ2FydGVzaWFuMy5kb3QocGxhbmVOb3JtYWwsIHAwKSArIHBsYW5lRCA8IDAuMDtcbiAgdmFyIHAxQmVoaW5kID0gQ2FydGVzaWFuMy5kb3QocGxhbmVOb3JtYWwsIHAxKSArIHBsYW5lRCA8IDAuMDtcbiAgdmFyIHAyQmVoaW5kID0gQ2FydGVzaWFuMy5kb3QocGxhbmVOb3JtYWwsIHAyKSArIHBsYW5lRCA8IDAuMDtcbiAgLy8gR2l2ZW4gdGhlc2UgZG90cyBwcm9kdWN0cywgdGhlIGNhbGxzIHRvIGxpbmVTZWdtZW50UGxhbmVJbnRlcnNlY3Rpb25cbiAgLy8gYWx3YXlzIGhhdmUgZGVmaW5lZCByZXN1bHRzLlxuXG4gIHZhciBudW1CZWhpbmQgPSAwO1xuICBudW1CZWhpbmQgKz0gcDBCZWhpbmQgPyAxIDogMDtcbiAgbnVtQmVoaW5kICs9IHAxQmVoaW5kID8gMSA6IDA7XG4gIG51bUJlaGluZCArPSBwMkJlaGluZCA/IDEgOiAwO1xuXG4gIHZhciB1MSwgdTI7XG4gIGlmIChudW1CZWhpbmQgPT09IDEgfHwgbnVtQmVoaW5kID09PSAyKSB7XG4gICAgdTEgPSBuZXcgQ2FydGVzaWFuMygpO1xuICAgIHUyID0gbmV3IENhcnRlc2lhbjMoKTtcbiAgfVxuXG4gIGlmIChudW1CZWhpbmQgPT09IDEpIHtcbiAgICBpZiAocDBCZWhpbmQpIHtcbiAgICAgIEludGVyc2VjdGlvblRlc3RzLmxpbmVTZWdtZW50UGxhbmUocDAsIHAxLCBwbGFuZSwgdTEpO1xuICAgICAgSW50ZXJzZWN0aW9uVGVzdHMubGluZVNlZ21lbnRQbGFuZShwMCwgcDIsIHBsYW5lLCB1Mik7XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIHBvc2l0aW9uczogW3AwLCBwMSwgcDIsIHUxLCB1Ml0sXG4gICAgICAgIGluZGljZXM6IFtcbiAgICAgICAgICAvLyBCZWhpbmRcbiAgICAgICAgICAwLFxuICAgICAgICAgIDMsXG4gICAgICAgICAgNCxcblxuICAgICAgICAgIC8vIEluIGZyb250XG4gICAgICAgICAgMSxcbiAgICAgICAgICAyLFxuICAgICAgICAgIDQsXG4gICAgICAgICAgMSxcbiAgICAgICAgICA0LFxuICAgICAgICAgIDMsXG4gICAgICAgIF0sXG4gICAgICB9O1xuICAgIH0gZWxzZSBpZiAocDFCZWhpbmQpIHtcbiAgICAgIEludGVyc2VjdGlvblRlc3RzLmxpbmVTZWdtZW50UGxhbmUocDEsIHAyLCBwbGFuZSwgdTEpO1xuICAgICAgSW50ZXJzZWN0aW9uVGVzdHMubGluZVNlZ21lbnRQbGFuZShwMSwgcDAsIHBsYW5lLCB1Mik7XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIHBvc2l0aW9uczogW3AwLCBwMSwgcDIsIHUxLCB1Ml0sXG4gICAgICAgIGluZGljZXM6IFtcbiAgICAgICAgICAvLyBCZWhpbmRcbiAgICAgICAgICAxLFxuICAgICAgICAgIDMsXG4gICAgICAgICAgNCxcblxuICAgICAgICAgIC8vIEluIGZyb250XG4gICAgICAgICAgMixcbiAgICAgICAgICAwLFxuICAgICAgICAgIDQsXG4gICAgICAgICAgMixcbiAgICAgICAgICA0LFxuICAgICAgICAgIDMsXG4gICAgICAgIF0sXG4gICAgICB9O1xuICAgIH0gZWxzZSBpZiAocDJCZWhpbmQpIHtcbiAgICAgIEludGVyc2VjdGlvblRlc3RzLmxpbmVTZWdtZW50UGxhbmUocDIsIHAwLCBwbGFuZSwgdTEpO1xuICAgICAgSW50ZXJzZWN0aW9uVGVzdHMubGluZVNlZ21lbnRQbGFuZShwMiwgcDEsIHBsYW5lLCB1Mik7XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIHBvc2l0aW9uczogW3AwLCBwMSwgcDIsIHUxLCB1Ml0sXG4gICAgICAgIGluZGljZXM6IFtcbiAgICAgICAgICAvLyBCZWhpbmRcbiAgICAgICAgICAyLFxuICAgICAgICAgIDMsXG4gICAgICAgICAgNCxcblxuICAgICAgICAgIC8vIEluIGZyb250XG4gICAgICAgICAgMCxcbiAgICAgICAgICAxLFxuICAgICAgICAgIDQsXG4gICAgICAgICAgMCxcbiAgICAgICAgICA0LFxuICAgICAgICAgIDMsXG4gICAgICAgIF0sXG4gICAgICB9O1xuICAgIH1cbiAgfSBlbHNlIGlmIChudW1CZWhpbmQgPT09IDIpIHtcbiAgICBpZiAoIXAwQmVoaW5kKSB7XG4gICAgICBJbnRlcnNlY3Rpb25UZXN0cy5saW5lU2VnbWVudFBsYW5lKHAxLCBwMCwgcGxhbmUsIHUxKTtcbiAgICAgIEludGVyc2VjdGlvblRlc3RzLmxpbmVTZWdtZW50UGxhbmUocDIsIHAwLCBwbGFuZSwgdTIpO1xuXG4gICAgICByZXR1cm4ge1xuICAgICAgICBwb3NpdGlvbnM6IFtwMCwgcDEsIHAyLCB1MSwgdTJdLFxuICAgICAgICBpbmRpY2VzOiBbXG4gICAgICAgICAgLy8gQmVoaW5kXG4gICAgICAgICAgMSxcbiAgICAgICAgICAyLFxuICAgICAgICAgIDQsXG4gICAgICAgICAgMSxcbiAgICAgICAgICA0LFxuICAgICAgICAgIDMsXG5cbiAgICAgICAgICAvLyBJbiBmcm9udFxuICAgICAgICAgIDAsXG4gICAgICAgICAgMyxcbiAgICAgICAgICA0LFxuICAgICAgICBdLFxuICAgICAgfTtcbiAgICB9IGVsc2UgaWYgKCFwMUJlaGluZCkge1xuICAgICAgSW50ZXJzZWN0aW9uVGVzdHMubGluZVNlZ21lbnRQbGFuZShwMiwgcDEsIHBsYW5lLCB1MSk7XG4gICAgICBJbnRlcnNlY3Rpb25UZXN0cy5saW5lU2VnbWVudFBsYW5lKHAwLCBwMSwgcGxhbmUsIHUyKTtcblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgcG9zaXRpb25zOiBbcDAsIHAxLCBwMiwgdTEsIHUyXSxcbiAgICAgICAgaW5kaWNlczogW1xuICAgICAgICAgIC8vIEJlaGluZFxuICAgICAgICAgIDIsXG4gICAgICAgICAgMCxcbiAgICAgICAgICA0LFxuICAgICAgICAgIDIsXG4gICAgICAgICAgNCxcbiAgICAgICAgICAzLFxuXG4gICAgICAgICAgLy8gSW4gZnJvbnRcbiAgICAgICAgICAxLFxuICAgICAgICAgIDMsXG4gICAgICAgICAgNCxcbiAgICAgICAgXSxcbiAgICAgIH07XG4gICAgfSBlbHNlIGlmICghcDJCZWhpbmQpIHtcbiAgICAgIEludGVyc2VjdGlvblRlc3RzLmxpbmVTZWdtZW50UGxhbmUocDAsIHAyLCBwbGFuZSwgdTEpO1xuICAgICAgSW50ZXJzZWN0aW9uVGVzdHMubGluZVNlZ21lbnRQbGFuZShwMSwgcDIsIHBsYW5lLCB1Mik7XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIHBvc2l0aW9uczogW3AwLCBwMSwgcDIsIHUxLCB1Ml0sXG4gICAgICAgIGluZGljZXM6IFtcbiAgICAgICAgICAvLyBCZWhpbmRcbiAgICAgICAgICAwLFxuICAgICAgICAgIDEsXG4gICAgICAgICAgNCxcbiAgICAgICAgICAwLFxuICAgICAgICAgIDQsXG4gICAgICAgICAgMyxcblxuICAgICAgICAgIC8vIEluIGZyb250XG4gICAgICAgICAgMixcbiAgICAgICAgICAzLFxuICAgICAgICAgIDQsXG4gICAgICAgIF0sXG4gICAgICB9O1xuICAgIH1cbiAgfVxuXG4gIC8vIGlmIG51bUJlaGluZCBpcyAzLCB0aGUgdHJpYW5nbGUgaXMgY29tcGxldGVseSBiZWhpbmQgdGhlIHBsYW5lO1xuICAvLyBvdGhlcndpc2UsIGl0IGlzIGNvbXBsZXRlbHkgaW4gZnJvbnQgKG51bUJlaGluZCBpcyAwKS5cbiAgcmV0dXJuIHVuZGVmaW5lZDtcbn07XG5leHBvcnQgZGVmYXVsdCBJbnRlcnNlY3Rpb25UZXN0cztcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///67627\n')},17980:function(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__){eval('/* harmony import */ var _Cartesian2_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(60838);\n/* harmony import */ var _Cartesian3_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(60216);\n/* harmony import */ var _Check_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(66553);\n/* harmony import */ var _defined_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(82982);\n/* harmony import */ var _DeveloperError_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(12572);\n\n\n\n\n\n\n/**\n * Contains functions for operating on 2D triangles.\n *\n * @namespace Intersections2D\n */\nvar Intersections2D = {};\n\n/**\n * Splits a 2D triangle at given axis-aligned threshold value and returns the resulting\n * polygon on a given side of the threshold.  The resulting polygon may have 0, 1, 2,\n * 3, or 4 vertices.\n *\n * @param {Number} threshold The threshold coordinate value at which to clip the triangle.\n * @param {Boolean} keepAbove true to keep the portion of the triangle above the threshold, or false\n *                            to keep the portion below.\n * @param {Number} u0 The coordinate of the first vertex in the triangle, in counter-clockwise order.\n * @param {Number} u1 The coordinate of the second vertex in the triangle, in counter-clockwise order.\n * @param {Number} u2 The coordinate of the third vertex in the triangle, in counter-clockwise order.\n * @param {Number[]} [result] The array into which to copy the result.  If this parameter is not supplied,\n *                            a new array is constructed and returned.\n * @returns {Number[]} The polygon that results after the clip, specified as a list of\n *                     vertices.  The vertices are specified in counter-clockwise order.\n *                     Each vertex is either an index from the existing list (identified as\n *                     a 0, 1, or 2) or -1 indicating a new vertex not in the original triangle.\n *                     For new vertices, the -1 is followed by three additional numbers: the\n *                     index of each of the two original vertices forming the line segment that\n *                     the new vertex lies on, and the fraction of the distance from the first\n *                     vertex to the second one.\n *\n * @example\n * var result = Cesium.Intersections2D.clipTriangleAtAxisAlignedThreshold(0.5, false, 0.2, 0.6, 0.4);\n * // result === [2, 0, -1, 1, 0, 0.25, -1, 1, 2, 0.5]\n */\nIntersections2D.clipTriangleAtAxisAlignedThreshold = function (\n  threshold,\n  keepAbove,\n  u0,\n  u1,\n  u2,\n  result\n) {\n  //>>includeStart(\'debug\', pragmas.debug);\n  if (!(0,_defined_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .Z)(threshold)) {\n    throw new _DeveloperError_js__WEBPACK_IMPORTED_MODULE_3__/* ["default"] */ .Z("threshold is required.");\n  }\n  if (!(0,_defined_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .Z)(keepAbove)) {\n    throw new _DeveloperError_js__WEBPACK_IMPORTED_MODULE_3__/* ["default"] */ .Z("keepAbove is required.");\n  }\n  if (!(0,_defined_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .Z)(u0)) {\n    throw new _DeveloperError_js__WEBPACK_IMPORTED_MODULE_3__/* ["default"] */ .Z("u0 is required.");\n  }\n  if (!(0,_defined_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .Z)(u1)) {\n    throw new _DeveloperError_js__WEBPACK_IMPORTED_MODULE_3__/* ["default"] */ .Z("u1 is required.");\n  }\n  if (!(0,_defined_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .Z)(u2)) {\n    throw new _DeveloperError_js__WEBPACK_IMPORTED_MODULE_3__/* ["default"] */ .Z("u2 is required.");\n  }\n  //>>includeEnd(\'debug\');\n\n  if (!(0,_defined_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .Z)(result)) {\n    result = [];\n  } else {\n    result.length = 0;\n  }\n\n  var u0Behind;\n  var u1Behind;\n  var u2Behind;\n  if (keepAbove) {\n    u0Behind = u0 < threshold;\n    u1Behind = u1 < threshold;\n    u2Behind = u2 < threshold;\n  } else {\n    u0Behind = u0 > threshold;\n    u1Behind = u1 > threshold;\n    u2Behind = u2 > threshold;\n  }\n\n  var numBehind = u0Behind + u1Behind + u2Behind;\n\n  var u01Ratio;\n  var u02Ratio;\n  var u12Ratio;\n  var u10Ratio;\n  var u20Ratio;\n  var u21Ratio;\n\n  if (numBehind === 1) {\n    if (u0Behind) {\n      u01Ratio = (threshold - u0) / (u1 - u0);\n      u02Ratio = (threshold - u0) / (u2 - u0);\n\n      result.push(1);\n\n      result.push(2);\n\n      if (u02Ratio !== 1.0) {\n        result.push(-1);\n        result.push(0);\n        result.push(2);\n        result.push(u02Ratio);\n      }\n\n      if (u01Ratio !== 1.0) {\n        result.push(-1);\n        result.push(0);\n        result.push(1);\n        result.push(u01Ratio);\n      }\n    } else if (u1Behind) {\n      u12Ratio = (threshold - u1) / (u2 - u1);\n      u10Ratio = (threshold - u1) / (u0 - u1);\n\n      result.push(2);\n\n      result.push(0);\n\n      if (u10Ratio !== 1.0) {\n        result.push(-1);\n        result.push(1);\n        result.push(0);\n        result.push(u10Ratio);\n      }\n\n      if (u12Ratio !== 1.0) {\n        result.push(-1);\n        result.push(1);\n        result.push(2);\n        result.push(u12Ratio);\n      }\n    } else if (u2Behind) {\n      u20Ratio = (threshold - u2) / (u0 - u2);\n      u21Ratio = (threshold - u2) / (u1 - u2);\n\n      result.push(0);\n\n      result.push(1);\n\n      if (u21Ratio !== 1.0) {\n        result.push(-1);\n        result.push(2);\n        result.push(1);\n        result.push(u21Ratio);\n      }\n\n      if (u20Ratio !== 1.0) {\n        result.push(-1);\n        result.push(2);\n        result.push(0);\n        result.push(u20Ratio);\n      }\n    }\n  } else if (numBehind === 2) {\n    if (!u0Behind && u0 !== threshold) {\n      u10Ratio = (threshold - u1) / (u0 - u1);\n      u20Ratio = (threshold - u2) / (u0 - u2);\n\n      result.push(0);\n\n      result.push(-1);\n      result.push(1);\n      result.push(0);\n      result.push(u10Ratio);\n\n      result.push(-1);\n      result.push(2);\n      result.push(0);\n      result.push(u20Ratio);\n    } else if (!u1Behind && u1 !== threshold) {\n      u21Ratio = (threshold - u2) / (u1 - u2);\n      u01Ratio = (threshold - u0) / (u1 - u0);\n\n      result.push(1);\n\n      result.push(-1);\n      result.push(2);\n      result.push(1);\n      result.push(u21Ratio);\n\n      result.push(-1);\n      result.push(0);\n      result.push(1);\n      result.push(u01Ratio);\n    } else if (!u2Behind && u2 !== threshold) {\n      u02Ratio = (threshold - u0) / (u2 - u0);\n      u12Ratio = (threshold - u1) / (u2 - u1);\n\n      result.push(2);\n\n      result.push(-1);\n      result.push(0);\n      result.push(2);\n      result.push(u02Ratio);\n\n      result.push(-1);\n      result.push(1);\n      result.push(2);\n      result.push(u12Ratio);\n    }\n  } else if (numBehind !== 3) {\n    // Completely in front of threshold\n    result.push(0);\n    result.push(1);\n    result.push(2);\n  }\n  // else Completely behind threshold\n\n  return result;\n};\n\n/**\n * Compute the barycentric coordinates of a 2D position within a 2D triangle.\n *\n * @param {Number} x The x coordinate of the position for which to find the barycentric coordinates.\n * @param {Number} y The y coordinate of the position for which to find the barycentric coordinates.\n * @param {Number} x1 The x coordinate of the triangle\'s first vertex.\n * @param {Number} y1 The y coordinate of the triangle\'s first vertex.\n * @param {Number} x2 The x coordinate of the triangle\'s second vertex.\n * @param {Number} y2 The y coordinate of the triangle\'s second vertex.\n * @param {Number} x3 The x coordinate of the triangle\'s third vertex.\n * @param {Number} y3 The y coordinate of the triangle\'s third vertex.\n * @param {Cartesian3} [result] The instance into to which to copy the result.  If this parameter\n *                     is undefined, a new instance is created and returned.\n * @returns {Cartesian3} The barycentric coordinates of the position within the triangle.\n *\n * @example\n * var result = Cesium.Intersections2D.computeBarycentricCoordinates(0.0, 0.0, 0.0, 1.0, -1, -0.5, 1, -0.5);\n * // result === new Cesium.Cartesian3(1.0 / 3.0, 1.0 / 3.0, 1.0 / 3.0);\n */\nIntersections2D.computeBarycentricCoordinates = function (\n  x,\n  y,\n  x1,\n  y1,\n  x2,\n  y2,\n  x3,\n  y3,\n  result\n) {\n  //>>includeStart(\'debug\', pragmas.debug);\n  if (!(0,_defined_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .Z)(x)) {\n    throw new _DeveloperError_js__WEBPACK_IMPORTED_MODULE_3__/* ["default"] */ .Z("x is required.");\n  }\n  if (!(0,_defined_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .Z)(y)) {\n    throw new _DeveloperError_js__WEBPACK_IMPORTED_MODULE_3__/* ["default"] */ .Z("y is required.");\n  }\n  if (!(0,_defined_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .Z)(x1)) {\n    throw new _DeveloperError_js__WEBPACK_IMPORTED_MODULE_3__/* ["default"] */ .Z("x1 is required.");\n  }\n  if (!(0,_defined_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .Z)(y1)) {\n    throw new _DeveloperError_js__WEBPACK_IMPORTED_MODULE_3__/* ["default"] */ .Z("y1 is required.");\n  }\n  if (!(0,_defined_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .Z)(x2)) {\n    throw new _DeveloperError_js__WEBPACK_IMPORTED_MODULE_3__/* ["default"] */ .Z("x2 is required.");\n  }\n  if (!(0,_defined_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .Z)(y2)) {\n    throw new _DeveloperError_js__WEBPACK_IMPORTED_MODULE_3__/* ["default"] */ .Z("y2 is required.");\n  }\n  if (!(0,_defined_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .Z)(x3)) {\n    throw new _DeveloperError_js__WEBPACK_IMPORTED_MODULE_3__/* ["default"] */ .Z("x3 is required.");\n  }\n  if (!(0,_defined_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .Z)(y3)) {\n    throw new _DeveloperError_js__WEBPACK_IMPORTED_MODULE_3__/* ["default"] */ .Z("y3 is required.");\n  }\n  //>>includeEnd(\'debug\');\n\n  var x1mx3 = x1 - x3;\n  var x3mx2 = x3 - x2;\n  var y2my3 = y2 - y3;\n  var y1my3 = y1 - y3;\n  var inverseDeterminant = 1.0 / (y2my3 * x1mx3 + x3mx2 * y1my3);\n  var ymy3 = y - y3;\n  var xmx3 = x - x3;\n  var l1 = (y2my3 * xmx3 + x3mx2 * ymy3) * inverseDeterminant;\n  var l2 = (-y1my3 * xmx3 + x1mx3 * ymy3) * inverseDeterminant;\n  var l3 = 1.0 - l1 - l2;\n\n  if ((0,_defined_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .Z)(result)) {\n    result.x = l1;\n    result.y = l2;\n    result.z = l3;\n    return result;\n  }\n  return new _Cartesian3_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .Z(l1, l2, l3);\n};\n\n/**\n * Compute the intersection between 2 line segments\n *\n * @param {Number} x00 The x coordinate of the first line\'s first vertex.\n * @param {Number} y00 The y coordinate of the first line\'s first vertex.\n * @param {Number} x01 The x coordinate of the first line\'s second vertex.\n * @param {Number} y01 The y coordinate of the first line\'s second vertex.\n * @param {Number} x10 The x coordinate of the second line\'s first vertex.\n * @param {Number} y10 The y coordinate of the second line\'s first vertex.\n * @param {Number} x11 The x coordinate of the second line\'s second vertex.\n * @param {Number} y11 The y coordinate of the second line\'s second vertex.\n * @param {Cartesian2} [result] The instance into to which to copy the result. If this parameter\n *                     is undefined, a new instance is created and returned.\n * @returns {Cartesian2} The intersection point, undefined if there is no intersection point or lines are coincident.\n *\n * @example\n * var result = Cesium.Intersections2D.computeLineSegmentLineSegmentIntersection(0.0, 0.0, 0.0, 2.0, -1, 1, 1, 1);\n * // result === new Cesium.Cartesian2(0.0, 1.0);\n */\nIntersections2D.computeLineSegmentLineSegmentIntersection = function (\n  x00,\n  y00,\n  x01,\n  y01,\n  x10,\n  y10,\n  x11,\n  y11,\n  result\n) {\n  //>>includeStart(\'debug\', pragmas.debug);\n  _Check_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"].typeOf.number */ .Z.typeOf.number("x00", x00);\n  _Check_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"].typeOf.number */ .Z.typeOf.number("y00", y00);\n  _Check_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"].typeOf.number */ .Z.typeOf.number("x01", x01);\n  _Check_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"].typeOf.number */ .Z.typeOf.number("y01", y01);\n  _Check_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"].typeOf.number */ .Z.typeOf.number("x10", x10);\n  _Check_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"].typeOf.number */ .Z.typeOf.number("y10", y10);\n  _Check_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"].typeOf.number */ .Z.typeOf.number("x11", x11);\n  _Check_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"].typeOf.number */ .Z.typeOf.number("y11", y11);\n  //>>includeEnd(\'debug\');\n\n  var numerator1A = (x11 - x10) * (y00 - y10) - (y11 - y10) * (x00 - x10);\n  var numerator1B = (x01 - x00) * (y00 - y10) - (y01 - y00) * (x00 - x10);\n  var denominator1 = (y11 - y10) * (x01 - x00) - (x11 - x10) * (y01 - y00);\n\n  // If denominator = 0, then lines are parallel. If denominator = 0 and both numerators are 0, then coincident\n  if (denominator1 === 0) {\n    return;\n  }\n\n  var ua1 = numerator1A / denominator1;\n  var ub1 = numerator1B / denominator1;\n\n  if (ua1 >= 0 && ua1 <= 1 && ub1 >= 0 && ub1 <= 1) {\n    if (!(0,_defined_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .Z)(result)) {\n      result = new _Cartesian2_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .Z();\n    }\n\n    result.x = x00 + ua1 * (x01 - x00);\n    result.y = y00 + ua1 * (y01 - y00);\n\n    return result;\n  }\n};\n/* harmony default export */ __webpack_exports__["Z"] = (Intersections2D);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QUFDZCxjQUFjLG1FQUFjO0FBQzVCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsTUFBTSxnRUFBTztBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLCtEQUFVO0FBQ3ZCOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxZQUFZO0FBQ3ZCO0FBQ0EsYUFBYSxZQUFZO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFLHNGQUFtQjtBQUNyQixFQUFFLHNGQUFtQjtBQUNyQixFQUFFLHNGQUFtQjtBQUNyQixFQUFFLHNGQUFtQjtBQUNyQixFQUFFLHNGQUFtQjtBQUNyQixFQUFFLHNGQUFtQjtBQUNyQixFQUFFLHNGQUFtQjtBQUNyQixFQUFFLHNGQUFtQjtBQUNyQjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLFNBQVMsZ0VBQU87QUFDaEIsbUJBQW1CLCtEQUFVO0FBQzdCOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EseURBQWUsZUFBZSxFQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdnVlMy13ZWJwYWNrNS8uL25vZGVfbW9kdWxlcy9jZXNpdW0vU291cmNlL0NvcmUvSW50ZXJzZWN0aW9uczJELmpzPzYzMzYiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IENhcnRlc2lhbjIgZnJvbSBcIi4vQ2FydGVzaWFuMi5qc1wiO1xuaW1wb3J0IENhcnRlc2lhbjMgZnJvbSBcIi4vQ2FydGVzaWFuMy5qc1wiO1xuaW1wb3J0IENoZWNrIGZyb20gXCIuL0NoZWNrLmpzXCI7XG5pbXBvcnQgZGVmaW5lZCBmcm9tIFwiLi9kZWZpbmVkLmpzXCI7XG5pbXBvcnQgRGV2ZWxvcGVyRXJyb3IgZnJvbSBcIi4vRGV2ZWxvcGVyRXJyb3IuanNcIjtcblxuLyoqXG4gKiBDb250YWlucyBmdW5jdGlvbnMgZm9yIG9wZXJhdGluZyBvbiAyRCB0cmlhbmdsZXMuXG4gKlxuICogQG5hbWVzcGFjZSBJbnRlcnNlY3Rpb25zMkRcbiAqL1xudmFyIEludGVyc2VjdGlvbnMyRCA9IHt9O1xuXG4vKipcbiAqIFNwbGl0cyBhIDJEIHRyaWFuZ2xlIGF0IGdpdmVuIGF4aXMtYWxpZ25lZCB0aHJlc2hvbGQgdmFsdWUgYW5kIHJldHVybnMgdGhlIHJlc3VsdGluZ1xuICogcG9seWdvbiBvbiBhIGdpdmVuIHNpZGUgb2YgdGhlIHRocmVzaG9sZC4gIFRoZSByZXN1bHRpbmcgcG9seWdvbiBtYXkgaGF2ZSAwLCAxLCAyLFxuICogMywgb3IgNCB2ZXJ0aWNlcy5cbiAqXG4gKiBAcGFyYW0ge051bWJlcn0gdGhyZXNob2xkIFRoZSB0aHJlc2hvbGQgY29vcmRpbmF0ZSB2YWx1ZSBhdCB3aGljaCB0byBjbGlwIHRoZSB0cmlhbmdsZS5cbiAqIEBwYXJhbSB7Qm9vbGVhbn0ga2VlcEFib3ZlIHRydWUgdG8ga2VlcCB0aGUgcG9ydGlvbiBvZiB0aGUgdHJpYW5nbGUgYWJvdmUgdGhlIHRocmVzaG9sZCwgb3IgZmFsc2VcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRvIGtlZXAgdGhlIHBvcnRpb24gYmVsb3cuXG4gKiBAcGFyYW0ge051bWJlcn0gdTAgVGhlIGNvb3JkaW5hdGUgb2YgdGhlIGZpcnN0IHZlcnRleCBpbiB0aGUgdHJpYW5nbGUsIGluIGNvdW50ZXItY2xvY2t3aXNlIG9yZGVyLlxuICogQHBhcmFtIHtOdW1iZXJ9IHUxIFRoZSBjb29yZGluYXRlIG9mIHRoZSBzZWNvbmQgdmVydGV4IGluIHRoZSB0cmlhbmdsZSwgaW4gY291bnRlci1jbG9ja3dpc2Ugb3JkZXIuXG4gKiBAcGFyYW0ge051bWJlcn0gdTIgVGhlIGNvb3JkaW5hdGUgb2YgdGhlIHRoaXJkIHZlcnRleCBpbiB0aGUgdHJpYW5nbGUsIGluIGNvdW50ZXItY2xvY2t3aXNlIG9yZGVyLlxuICogQHBhcmFtIHtOdW1iZXJbXX0gW3Jlc3VsdF0gVGhlIGFycmF5IGludG8gd2hpY2ggdG8gY29weSB0aGUgcmVzdWx0LiAgSWYgdGhpcyBwYXJhbWV0ZXIgaXMgbm90IHN1cHBsaWVkLFxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgYSBuZXcgYXJyYXkgaXMgY29uc3RydWN0ZWQgYW5kIHJldHVybmVkLlxuICogQHJldHVybnMge051bWJlcltdfSBUaGUgcG9seWdvbiB0aGF0IHJlc3VsdHMgYWZ0ZXIgdGhlIGNsaXAsIHNwZWNpZmllZCBhcyBhIGxpc3Qgb2ZcbiAqICAgICAgICAgICAgICAgICAgICAgdmVydGljZXMuICBUaGUgdmVydGljZXMgYXJlIHNwZWNpZmllZCBpbiBjb3VudGVyLWNsb2Nrd2lzZSBvcmRlci5cbiAqICAgICAgICAgICAgICAgICAgICAgRWFjaCB2ZXJ0ZXggaXMgZWl0aGVyIGFuIGluZGV4IGZyb20gdGhlIGV4aXN0aW5nIGxpc3QgKGlkZW50aWZpZWQgYXNcbiAqICAgICAgICAgICAgICAgICAgICAgYSAwLCAxLCBvciAyKSBvciAtMSBpbmRpY2F0aW5nIGEgbmV3IHZlcnRleCBub3QgaW4gdGhlIG9yaWdpbmFsIHRyaWFuZ2xlLlxuICogICAgICAgICAgICAgICAgICAgICBGb3IgbmV3IHZlcnRpY2VzLCB0aGUgLTEgaXMgZm9sbG93ZWQgYnkgdGhyZWUgYWRkaXRpb25hbCBudW1iZXJzOiB0aGVcbiAqICAgICAgICAgICAgICAgICAgICAgaW5kZXggb2YgZWFjaCBvZiB0aGUgdHdvIG9yaWdpbmFsIHZlcnRpY2VzIGZvcm1pbmcgdGhlIGxpbmUgc2VnbWVudCB0aGF0XG4gKiAgICAgICAgICAgICAgICAgICAgIHRoZSBuZXcgdmVydGV4IGxpZXMgb24sIGFuZCB0aGUgZnJhY3Rpb24gb2YgdGhlIGRpc3RhbmNlIGZyb20gdGhlIGZpcnN0XG4gKiAgICAgICAgICAgICAgICAgICAgIHZlcnRleCB0byB0aGUgc2Vjb25kIG9uZS5cbiAqXG4gKiBAZXhhbXBsZVxuICogdmFyIHJlc3VsdCA9IENlc2l1bS5JbnRlcnNlY3Rpb25zMkQuY2xpcFRyaWFuZ2xlQXRBeGlzQWxpZ25lZFRocmVzaG9sZCgwLjUsIGZhbHNlLCAwLjIsIDAuNiwgMC40KTtcbiAqIC8vIHJlc3VsdCA9PT0gWzIsIDAsIC0xLCAxLCAwLCAwLjI1LCAtMSwgMSwgMiwgMC41XVxuICovXG5JbnRlcnNlY3Rpb25zMkQuY2xpcFRyaWFuZ2xlQXRBeGlzQWxpZ25lZFRocmVzaG9sZCA9IGZ1bmN0aW9uIChcbiAgdGhyZXNob2xkLFxuICBrZWVwQWJvdmUsXG4gIHUwLFxuICB1MSxcbiAgdTIsXG4gIHJlc3VsdFxuKSB7XG4gIC8vPj5pbmNsdWRlU3RhcnQoJ2RlYnVnJywgcHJhZ21hcy5kZWJ1Zyk7XG4gIGlmICghZGVmaW5lZCh0aHJlc2hvbGQpKSB7XG4gICAgdGhyb3cgbmV3IERldmVsb3BlckVycm9yKFwidGhyZXNob2xkIGlzIHJlcXVpcmVkLlwiKTtcbiAgfVxuICBpZiAoIWRlZmluZWQoa2VlcEFib3ZlKSkge1xuICAgIHRocm93IG5ldyBEZXZlbG9wZXJFcnJvcihcImtlZXBBYm92ZSBpcyByZXF1aXJlZC5cIik7XG4gIH1cbiAgaWYgKCFkZWZpbmVkKHUwKSkge1xuICAgIHRocm93IG5ldyBEZXZlbG9wZXJFcnJvcihcInUwIGlzIHJlcXVpcmVkLlwiKTtcbiAgfVxuICBpZiAoIWRlZmluZWQodTEpKSB7XG4gICAgdGhyb3cgbmV3IERldmVsb3BlckVycm9yKFwidTEgaXMgcmVxdWlyZWQuXCIpO1xuICB9XG4gIGlmICghZGVmaW5lZCh1MikpIHtcbiAgICB0aHJvdyBuZXcgRGV2ZWxvcGVyRXJyb3IoXCJ1MiBpcyByZXF1aXJlZC5cIik7XG4gIH1cbiAgLy8+PmluY2x1ZGVFbmQoJ2RlYnVnJyk7XG5cbiAgaWYgKCFkZWZpbmVkKHJlc3VsdCkpIHtcbiAgICByZXN1bHQgPSBbXTtcbiAgfSBlbHNlIHtcbiAgICByZXN1bHQubGVuZ3RoID0gMDtcbiAgfVxuXG4gIHZhciB1MEJlaGluZDtcbiAgdmFyIHUxQmVoaW5kO1xuICB2YXIgdTJCZWhpbmQ7XG4gIGlmIChrZWVwQWJvdmUpIHtcbiAgICB1MEJlaGluZCA9IHUwIDwgdGhyZXNob2xkO1xuICAgIHUxQmVoaW5kID0gdTEgPCB0aHJlc2hvbGQ7XG4gICAgdTJCZWhpbmQgPSB1MiA8IHRocmVzaG9sZDtcbiAgfSBlbHNlIHtcbiAgICB1MEJlaGluZCA9IHUwID4gdGhyZXNob2xkO1xuICAgIHUxQmVoaW5kID0gdTEgPiB0aHJlc2hvbGQ7XG4gICAgdTJCZWhpbmQgPSB1MiA+IHRocmVzaG9sZDtcbiAgfVxuXG4gIHZhciBudW1CZWhpbmQgPSB1MEJlaGluZCArIHUxQmVoaW5kICsgdTJCZWhpbmQ7XG5cbiAgdmFyIHUwMVJhdGlvO1xuICB2YXIgdTAyUmF0aW87XG4gIHZhciB1MTJSYXRpbztcbiAgdmFyIHUxMFJhdGlvO1xuICB2YXIgdTIwUmF0aW87XG4gIHZhciB1MjFSYXRpbztcblxuICBpZiAobnVtQmVoaW5kID09PSAxKSB7XG4gICAgaWYgKHUwQmVoaW5kKSB7XG4gICAgICB1MDFSYXRpbyA9ICh0aHJlc2hvbGQgLSB1MCkgLyAodTEgLSB1MCk7XG4gICAgICB1MDJSYXRpbyA9ICh0aHJlc2hvbGQgLSB1MCkgLyAodTIgLSB1MCk7XG5cbiAgICAgIHJlc3VsdC5wdXNoKDEpO1xuXG4gICAgICByZXN1bHQucHVzaCgyKTtcblxuICAgICAgaWYgKHUwMlJhdGlvICE9PSAxLjApIHtcbiAgICAgICAgcmVzdWx0LnB1c2goLTEpO1xuICAgICAgICByZXN1bHQucHVzaCgwKTtcbiAgICAgICAgcmVzdWx0LnB1c2goMik7XG4gICAgICAgIHJlc3VsdC5wdXNoKHUwMlJhdGlvKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHUwMVJhdGlvICE9PSAxLjApIHtcbiAgICAgICAgcmVzdWx0LnB1c2goLTEpO1xuICAgICAgICByZXN1bHQucHVzaCgwKTtcbiAgICAgICAgcmVzdWx0LnB1c2goMSk7XG4gICAgICAgIHJlc3VsdC5wdXNoKHUwMVJhdGlvKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHUxQmVoaW5kKSB7XG4gICAgICB1MTJSYXRpbyA9ICh0aHJlc2hvbGQgLSB1MSkgLyAodTIgLSB1MSk7XG4gICAgICB1MTBSYXRpbyA9ICh0aHJlc2hvbGQgLSB1MSkgLyAodTAgLSB1MSk7XG5cbiAgICAgIHJlc3VsdC5wdXNoKDIpO1xuXG4gICAgICByZXN1bHQucHVzaCgwKTtcblxuICAgICAgaWYgKHUxMFJhdGlvICE9PSAxLjApIHtcbiAgICAgICAgcmVzdWx0LnB1c2goLTEpO1xuICAgICAgICByZXN1bHQucHVzaCgxKTtcbiAgICAgICAgcmVzdWx0LnB1c2goMCk7XG4gICAgICAgIHJlc3VsdC5wdXNoKHUxMFJhdGlvKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHUxMlJhdGlvICE9PSAxLjApIHtcbiAgICAgICAgcmVzdWx0LnB1c2goLTEpO1xuICAgICAgICByZXN1bHQucHVzaCgxKTtcbiAgICAgICAgcmVzdWx0LnB1c2goMik7XG4gICAgICAgIHJlc3VsdC5wdXNoKHUxMlJhdGlvKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHUyQmVoaW5kKSB7XG4gICAgICB1MjBSYXRpbyA9ICh0aHJlc2hvbGQgLSB1MikgLyAodTAgLSB1Mik7XG4gICAgICB1MjFSYXRpbyA9ICh0aHJlc2hvbGQgLSB1MikgLyAodTEgLSB1Mik7XG5cbiAgICAgIHJlc3VsdC5wdXNoKDApO1xuXG4gICAgICByZXN1bHQucHVzaCgxKTtcblxuICAgICAgaWYgKHUyMVJhdGlvICE9PSAxLjApIHtcbiAgICAgICAgcmVzdWx0LnB1c2goLTEpO1xuICAgICAgICByZXN1bHQucHVzaCgyKTtcbiAgICAgICAgcmVzdWx0LnB1c2goMSk7XG4gICAgICAgIHJlc3VsdC5wdXNoKHUyMVJhdGlvKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHUyMFJhdGlvICE9PSAxLjApIHtcbiAgICAgICAgcmVzdWx0LnB1c2goLTEpO1xuICAgICAgICByZXN1bHQucHVzaCgyKTtcbiAgICAgICAgcmVzdWx0LnB1c2goMCk7XG4gICAgICAgIHJlc3VsdC5wdXNoKHUyMFJhdGlvKTtcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSBpZiAobnVtQmVoaW5kID09PSAyKSB7XG4gICAgaWYgKCF1MEJlaGluZCAmJiB1MCAhPT0gdGhyZXNob2xkKSB7XG4gICAgICB1MTBSYXRpbyA9ICh0aHJlc2hvbGQgLSB1MSkgLyAodTAgLSB1MSk7XG4gICAgICB1MjBSYXRpbyA9ICh0aHJlc2hvbGQgLSB1MikgLyAodTAgLSB1Mik7XG5cbiAgICAgIHJlc3VsdC5wdXNoKDApO1xuXG4gICAgICByZXN1bHQucHVzaCgtMSk7XG4gICAgICByZXN1bHQucHVzaCgxKTtcbiAgICAgIHJlc3VsdC5wdXNoKDApO1xuICAgICAgcmVzdWx0LnB1c2godTEwUmF0aW8pO1xuXG4gICAgICByZXN1bHQucHVzaCgtMSk7XG4gICAgICByZXN1bHQucHVzaCgyKTtcbiAgICAgIHJlc3VsdC5wdXNoKDApO1xuICAgICAgcmVzdWx0LnB1c2godTIwUmF0aW8pO1xuICAgIH0gZWxzZSBpZiAoIXUxQmVoaW5kICYmIHUxICE9PSB0aHJlc2hvbGQpIHtcbiAgICAgIHUyMVJhdGlvID0gKHRocmVzaG9sZCAtIHUyKSAvICh1MSAtIHUyKTtcbiAgICAgIHUwMVJhdGlvID0gKHRocmVzaG9sZCAtIHUwKSAvICh1MSAtIHUwKTtcblxuICAgICAgcmVzdWx0LnB1c2goMSk7XG5cbiAgICAgIHJlc3VsdC5wdXNoKC0xKTtcbiAgICAgIHJlc3VsdC5wdXNoKDIpO1xuICAgICAgcmVzdWx0LnB1c2goMSk7XG4gICAgICByZXN1bHQucHVzaCh1MjFSYXRpbyk7XG5cbiAgICAgIHJlc3VsdC5wdXNoKC0xKTtcbiAgICAgIHJlc3VsdC5wdXNoKDApO1xuICAgICAgcmVzdWx0LnB1c2goMSk7XG4gICAgICByZXN1bHQucHVzaCh1MDFSYXRpbyk7XG4gICAgfSBlbHNlIGlmICghdTJCZWhpbmQgJiYgdTIgIT09IHRocmVzaG9sZCkge1xuICAgICAgdTAyUmF0aW8gPSAodGhyZXNob2xkIC0gdTApIC8gKHUyIC0gdTApO1xuICAgICAgdTEyUmF0aW8gPSAodGhyZXNob2xkIC0gdTEpIC8gKHUyIC0gdTEpO1xuXG4gICAgICByZXN1bHQucHVzaCgyKTtcblxuICAgICAgcmVzdWx0LnB1c2goLTEpO1xuICAgICAgcmVzdWx0LnB1c2goMCk7XG4gICAgICByZXN1bHQucHVzaCgyKTtcbiAgICAgIHJlc3VsdC5wdXNoKHUwMlJhdGlvKTtcblxuICAgICAgcmVzdWx0LnB1c2goLTEpO1xuICAgICAgcmVzdWx0LnB1c2goMSk7XG4gICAgICByZXN1bHQucHVzaCgyKTtcbiAgICAgIHJlc3VsdC5wdXNoKHUxMlJhdGlvKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAobnVtQmVoaW5kICE9PSAzKSB7XG4gICAgLy8gQ29tcGxldGVseSBpbiBmcm9udCBvZiB0aHJlc2hvbGRcbiAgICByZXN1bHQucHVzaCgwKTtcbiAgICByZXN1bHQucHVzaCgxKTtcbiAgICByZXN1bHQucHVzaCgyKTtcbiAgfVxuICAvLyBlbHNlIENvbXBsZXRlbHkgYmVoaW5kIHRocmVzaG9sZFxuXG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG4vKipcbiAqIENvbXB1dGUgdGhlIGJhcnljZW50cmljIGNvb3JkaW5hdGVzIG9mIGEgMkQgcG9zaXRpb24gd2l0aGluIGEgMkQgdHJpYW5nbGUuXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IHggVGhlIHggY29vcmRpbmF0ZSBvZiB0aGUgcG9zaXRpb24gZm9yIHdoaWNoIHRvIGZpbmQgdGhlIGJhcnljZW50cmljIGNvb3JkaW5hdGVzLlxuICogQHBhcmFtIHtOdW1iZXJ9IHkgVGhlIHkgY29vcmRpbmF0ZSBvZiB0aGUgcG9zaXRpb24gZm9yIHdoaWNoIHRvIGZpbmQgdGhlIGJhcnljZW50cmljIGNvb3JkaW5hdGVzLlxuICogQHBhcmFtIHtOdW1iZXJ9IHgxIFRoZSB4IGNvb3JkaW5hdGUgb2YgdGhlIHRyaWFuZ2xlJ3MgZmlyc3QgdmVydGV4LlxuICogQHBhcmFtIHtOdW1iZXJ9IHkxIFRoZSB5IGNvb3JkaW5hdGUgb2YgdGhlIHRyaWFuZ2xlJ3MgZmlyc3QgdmVydGV4LlxuICogQHBhcmFtIHtOdW1iZXJ9IHgyIFRoZSB4IGNvb3JkaW5hdGUgb2YgdGhlIHRyaWFuZ2xlJ3Mgc2Vjb25kIHZlcnRleC5cbiAqIEBwYXJhbSB7TnVtYmVyfSB5MiBUaGUgeSBjb29yZGluYXRlIG9mIHRoZSB0cmlhbmdsZSdzIHNlY29uZCB2ZXJ0ZXguXG4gKiBAcGFyYW0ge051bWJlcn0geDMgVGhlIHggY29vcmRpbmF0ZSBvZiB0aGUgdHJpYW5nbGUncyB0aGlyZCB2ZXJ0ZXguXG4gKiBAcGFyYW0ge051bWJlcn0geTMgVGhlIHkgY29vcmRpbmF0ZSBvZiB0aGUgdHJpYW5nbGUncyB0aGlyZCB2ZXJ0ZXguXG4gKiBAcGFyYW0ge0NhcnRlc2lhbjN9IFtyZXN1bHRdIFRoZSBpbnN0YW5jZSBpbnRvIHRvIHdoaWNoIHRvIGNvcHkgdGhlIHJlc3VsdC4gIElmIHRoaXMgcGFyYW1ldGVyXG4gKiAgICAgICAgICAgICAgICAgICAgIGlzIHVuZGVmaW5lZCwgYSBuZXcgaW5zdGFuY2UgaXMgY3JlYXRlZCBhbmQgcmV0dXJuZWQuXG4gKiBAcmV0dXJucyB7Q2FydGVzaWFuM30gVGhlIGJhcnljZW50cmljIGNvb3JkaW5hdGVzIG9mIHRoZSBwb3NpdGlvbiB3aXRoaW4gdGhlIHRyaWFuZ2xlLlxuICpcbiAqIEBleGFtcGxlXG4gKiB2YXIgcmVzdWx0ID0gQ2VzaXVtLkludGVyc2VjdGlvbnMyRC5jb21wdXRlQmFyeWNlbnRyaWNDb29yZGluYXRlcygwLjAsIDAuMCwgMC4wLCAxLjAsIC0xLCAtMC41LCAxLCAtMC41KTtcbiAqIC8vIHJlc3VsdCA9PT0gbmV3IENlc2l1bS5DYXJ0ZXNpYW4zKDEuMCAvIDMuMCwgMS4wIC8gMy4wLCAxLjAgLyAzLjApO1xuICovXG5JbnRlcnNlY3Rpb25zMkQuY29tcHV0ZUJhcnljZW50cmljQ29vcmRpbmF0ZXMgPSBmdW5jdGlvbiAoXG4gIHgsXG4gIHksXG4gIHgxLFxuICB5MSxcbiAgeDIsXG4gIHkyLFxuICB4MyxcbiAgeTMsXG4gIHJlc3VsdFxuKSB7XG4gIC8vPj5pbmNsdWRlU3RhcnQoJ2RlYnVnJywgcHJhZ21hcy5kZWJ1Zyk7XG4gIGlmICghZGVmaW5lZCh4KSkge1xuICAgIHRocm93IG5ldyBEZXZlbG9wZXJFcnJvcihcInggaXMgcmVxdWlyZWQuXCIpO1xuICB9XG4gIGlmICghZGVmaW5lZCh5KSkge1xuICAgIHRocm93IG5ldyBEZXZlbG9wZXJFcnJvcihcInkgaXMgcmVxdWlyZWQuXCIpO1xuICB9XG4gIGlmICghZGVmaW5lZCh4MSkpIHtcbiAgICB0aHJvdyBuZXcgRGV2ZWxvcGVyRXJyb3IoXCJ4MSBpcyByZXF1aXJlZC5cIik7XG4gIH1cbiAgaWYgKCFkZWZpbmVkKHkxKSkge1xuICAgIHRocm93IG5ldyBEZXZlbG9wZXJFcnJvcihcInkxIGlzIHJlcXVpcmVkLlwiKTtcbiAgfVxuICBpZiAoIWRlZmluZWQoeDIpKSB7XG4gICAgdGhyb3cgbmV3IERldmVsb3BlckVycm9yKFwieDIgaXMgcmVxdWlyZWQuXCIpO1xuICB9XG4gIGlmICghZGVmaW5lZCh5MikpIHtcbiAgICB0aHJvdyBuZXcgRGV2ZWxvcGVyRXJyb3IoXCJ5MiBpcyByZXF1aXJlZC5cIik7XG4gIH1cbiAgaWYgKCFkZWZpbmVkKHgzKSkge1xuICAgIHRocm93IG5ldyBEZXZlbG9wZXJFcnJvcihcIngzIGlzIHJlcXVpcmVkLlwiKTtcbiAgfVxuICBpZiAoIWRlZmluZWQoeTMpKSB7XG4gICAgdGhyb3cgbmV3IERldmVsb3BlckVycm9yKFwieTMgaXMgcmVxdWlyZWQuXCIpO1xuICB9XG4gIC8vPj5pbmNsdWRlRW5kKCdkZWJ1ZycpO1xuXG4gIHZhciB4MW14MyA9IHgxIC0geDM7XG4gIHZhciB4M214MiA9IHgzIC0geDI7XG4gIHZhciB5Mm15MyA9IHkyIC0geTM7XG4gIHZhciB5MW15MyA9IHkxIC0geTM7XG4gIHZhciBpbnZlcnNlRGV0ZXJtaW5hbnQgPSAxLjAgLyAoeTJteTMgKiB4MW14MyArIHgzbXgyICogeTFteTMpO1xuICB2YXIgeW15MyA9IHkgLSB5MztcbiAgdmFyIHhteDMgPSB4IC0geDM7XG4gIHZhciBsMSA9ICh5Mm15MyAqIHhteDMgKyB4M214MiAqIHlteTMpICogaW52ZXJzZURldGVybWluYW50O1xuICB2YXIgbDIgPSAoLXkxbXkzICogeG14MyArIHgxbXgzICogeW15MykgKiBpbnZlcnNlRGV0ZXJtaW5hbnQ7XG4gIHZhciBsMyA9IDEuMCAtIGwxIC0gbDI7XG5cbiAgaWYgKGRlZmluZWQocmVzdWx0KSkge1xuICAgIHJlc3VsdC54ID0gbDE7XG4gICAgcmVzdWx0LnkgPSBsMjtcbiAgICByZXN1bHQueiA9IGwzO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbiAgcmV0dXJuIG5ldyBDYXJ0ZXNpYW4zKGwxLCBsMiwgbDMpO1xufTtcblxuLyoqXG4gKiBDb21wdXRlIHRoZSBpbnRlcnNlY3Rpb24gYmV0d2VlbiAyIGxpbmUgc2VnbWVudHNcbiAqXG4gKiBAcGFyYW0ge051bWJlcn0geDAwIFRoZSB4IGNvb3JkaW5hdGUgb2YgdGhlIGZpcnN0IGxpbmUncyBmaXJzdCB2ZXJ0ZXguXG4gKiBAcGFyYW0ge051bWJlcn0geTAwIFRoZSB5IGNvb3JkaW5hdGUgb2YgdGhlIGZpcnN0IGxpbmUncyBmaXJzdCB2ZXJ0ZXguXG4gKiBAcGFyYW0ge051bWJlcn0geDAxIFRoZSB4IGNvb3JkaW5hdGUgb2YgdGhlIGZpcnN0IGxpbmUncyBzZWNvbmQgdmVydGV4LlxuICogQHBhcmFtIHtOdW1iZXJ9IHkwMSBUaGUgeSBjb29yZGluYXRlIG9mIHRoZSBmaXJzdCBsaW5lJ3Mgc2Vjb25kIHZlcnRleC5cbiAqIEBwYXJhbSB7TnVtYmVyfSB4MTAgVGhlIHggY29vcmRpbmF0ZSBvZiB0aGUgc2Vjb25kIGxpbmUncyBmaXJzdCB2ZXJ0ZXguXG4gKiBAcGFyYW0ge051bWJlcn0geTEwIFRoZSB5IGNvb3JkaW5hdGUgb2YgdGhlIHNlY29uZCBsaW5lJ3MgZmlyc3QgdmVydGV4LlxuICogQHBhcmFtIHtOdW1iZXJ9IHgxMSBUaGUgeCBjb29yZGluYXRlIG9mIHRoZSBzZWNvbmQgbGluZSdzIHNlY29uZCB2ZXJ0ZXguXG4gKiBAcGFyYW0ge051bWJlcn0geTExIFRoZSB5IGNvb3JkaW5hdGUgb2YgdGhlIHNlY29uZCBsaW5lJ3Mgc2Vjb25kIHZlcnRleC5cbiAqIEBwYXJhbSB7Q2FydGVzaWFuMn0gW3Jlc3VsdF0gVGhlIGluc3RhbmNlIGludG8gdG8gd2hpY2ggdG8gY29weSB0aGUgcmVzdWx0LiBJZiB0aGlzIHBhcmFtZXRlclxuICogICAgICAgICAgICAgICAgICAgICBpcyB1bmRlZmluZWQsIGEgbmV3IGluc3RhbmNlIGlzIGNyZWF0ZWQgYW5kIHJldHVybmVkLlxuICogQHJldHVybnMge0NhcnRlc2lhbjJ9IFRoZSBpbnRlcnNlY3Rpb24gcG9pbnQsIHVuZGVmaW5lZCBpZiB0aGVyZSBpcyBubyBpbnRlcnNlY3Rpb24gcG9pbnQgb3IgbGluZXMgYXJlIGNvaW5jaWRlbnQuXG4gKlxuICogQGV4YW1wbGVcbiAqIHZhciByZXN1bHQgPSBDZXNpdW0uSW50ZXJzZWN0aW9uczJELmNvbXB1dGVMaW5lU2VnbWVudExpbmVTZWdtZW50SW50ZXJzZWN0aW9uKDAuMCwgMC4wLCAwLjAsIDIuMCwgLTEsIDEsIDEsIDEpO1xuICogLy8gcmVzdWx0ID09PSBuZXcgQ2VzaXVtLkNhcnRlc2lhbjIoMC4wLCAxLjApO1xuICovXG5JbnRlcnNlY3Rpb25zMkQuY29tcHV0ZUxpbmVTZWdtZW50TGluZVNlZ21lbnRJbnRlcnNlY3Rpb24gPSBmdW5jdGlvbiAoXG4gIHgwMCxcbiAgeTAwLFxuICB4MDEsXG4gIHkwMSxcbiAgeDEwLFxuICB5MTAsXG4gIHgxMSxcbiAgeTExLFxuICByZXN1bHRcbikge1xuICAvLz4+aW5jbHVkZVN0YXJ0KCdkZWJ1ZycsIHByYWdtYXMuZGVidWcpO1xuICBDaGVjay50eXBlT2YubnVtYmVyKFwieDAwXCIsIHgwMCk7XG4gIENoZWNrLnR5cGVPZi5udW1iZXIoXCJ5MDBcIiwgeTAwKTtcbiAgQ2hlY2sudHlwZU9mLm51bWJlcihcIngwMVwiLCB4MDEpO1xuICBDaGVjay50eXBlT2YubnVtYmVyKFwieTAxXCIsIHkwMSk7XG4gIENoZWNrLnR5cGVPZi5udW1iZXIoXCJ4MTBcIiwgeDEwKTtcbiAgQ2hlY2sudHlwZU9mLm51bWJlcihcInkxMFwiLCB5MTApO1xuICBDaGVjay50eXBlT2YubnVtYmVyKFwieDExXCIsIHgxMSk7XG4gIENoZWNrLnR5cGVPZi5udW1iZXIoXCJ5MTFcIiwgeTExKTtcbiAgLy8+PmluY2x1ZGVFbmQoJ2RlYnVnJyk7XG5cbiAgdmFyIG51bWVyYXRvcjFBID0gKHgxMSAtIHgxMCkgKiAoeTAwIC0geTEwKSAtICh5MTEgLSB5MTApICogKHgwMCAtIHgxMCk7XG4gIHZhciBudW1lcmF0b3IxQiA9ICh4MDEgLSB4MDApICogKHkwMCAtIHkxMCkgLSAoeTAxIC0geTAwKSAqICh4MDAgLSB4MTApO1xuICB2YXIgZGVub21pbmF0b3IxID0gKHkxMSAtIHkxMCkgKiAoeDAxIC0geDAwKSAtICh4MTEgLSB4MTApICogKHkwMSAtIHkwMCk7XG5cbiAgLy8gSWYgZGVub21pbmF0b3IgPSAwLCB0aGVuIGxpbmVzIGFyZSBwYXJhbGxlbC4gSWYgZGVub21pbmF0b3IgPSAwIGFuZCBib3RoIG51bWVyYXRvcnMgYXJlIDAsIHRoZW4gY29pbmNpZGVudFxuICBpZiAoZGVub21pbmF0b3IxID09PSAwKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIHVhMSA9IG51bWVyYXRvcjFBIC8gZGVub21pbmF0b3IxO1xuICB2YXIgdWIxID0gbnVtZXJhdG9yMUIgLyBkZW5vbWluYXRvcjE7XG5cbiAgaWYgKHVhMSA+PSAwICYmIHVhMSA8PSAxICYmIHViMSA+PSAwICYmIHViMSA8PSAxKSB7XG4gICAgaWYgKCFkZWZpbmVkKHJlc3VsdCkpIHtcbiAgICAgIHJlc3VsdCA9IG5ldyBDYXJ0ZXNpYW4yKCk7XG4gICAgfVxuXG4gICAgcmVzdWx0LnggPSB4MDAgKyB1YTEgKiAoeDAxIC0geDAwKTtcbiAgICByZXN1bHQueSA9IHkwMCArIHVhMSAqICh5MDEgLSB5MDApO1xuXG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxufTtcbmV4cG9ydCBkZWZhdWx0IEludGVyc2VjdGlvbnMyRDtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///17980\n')},9058:function(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__){eval('/* harmony import */ var _defaultValue_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(62200);\n\n\n/**\n * Represents the closed interval [start, stop].\n * @alias Interval\n * @constructor\n *\n * @param {Number} [start=0.0] The beginning of the interval.\n * @param {Number} [stop=0.0] The end of the interval.\n */\nfunction Interval(start, stop) {\n  /**\n   * The beginning of the interval.\n   * @type {Number}\n   * @default 0.0\n   */\n  this.start = (0,_defaultValue_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .Z)(start, 0.0);\n  /**\n   * The end of the interval.\n   * @type {Number}\n   * @default 0.0\n   */\n  this.stop = (0,_defaultValue_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .Z)(stop, 0.0);\n}\n/* harmony default export */ __webpack_exports__["Z"] = (Interval);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiOTA1OC5qcyIsIm1hcHBpbmdzIjoiO0FBQTZDOztBQUU3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0EsZUFBZSxxRUFBWTtBQUMzQjtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQSxjQUFjLHFFQUFZO0FBQzFCO0FBQ0EseURBQWUsUUFBUSxFQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdnVlMy13ZWJwYWNrNS8uL25vZGVfbW9kdWxlcy9jZXNpdW0vU291cmNlL0NvcmUvSW50ZXJ2YWwuanM/YzNmMCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgZGVmYXVsdFZhbHVlIGZyb20gXCIuL2RlZmF1bHRWYWx1ZS5qc1wiO1xuXG4vKipcbiAqIFJlcHJlc2VudHMgdGhlIGNsb3NlZCBpbnRlcnZhbCBbc3RhcnQsIHN0b3BdLlxuICogQGFsaWFzIEludGVydmFsXG4gKiBAY29uc3RydWN0b3JcbiAqXG4gKiBAcGFyYW0ge051bWJlcn0gW3N0YXJ0PTAuMF0gVGhlIGJlZ2lubmluZyBvZiB0aGUgaW50ZXJ2YWwuXG4gKiBAcGFyYW0ge051bWJlcn0gW3N0b3A9MC4wXSBUaGUgZW5kIG9mIHRoZSBpbnRlcnZhbC5cbiAqL1xuZnVuY3Rpb24gSW50ZXJ2YWwoc3RhcnQsIHN0b3ApIHtcbiAgLyoqXG4gICAqIFRoZSBiZWdpbm5pbmcgb2YgdGhlIGludGVydmFsLlxuICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgKiBAZGVmYXVsdCAwLjBcbiAgICovXG4gIHRoaXMuc3RhcnQgPSBkZWZhdWx0VmFsdWUoc3RhcnQsIDAuMCk7XG4gIC8qKlxuICAgKiBUaGUgZW5kIG9mIHRoZSBpbnRlcnZhbC5cbiAgICogQHR5cGUge051bWJlcn1cbiAgICogQGRlZmF1bHQgMC4wXG4gICAqL1xuICB0aGlzLnN0b3AgPSBkZWZhdWx0VmFsdWUoc3RvcCwgMC4wKTtcbn1cbmV4cG9ydCBkZWZhdWx0IEludGVydmFsO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///9058\n')},10221:function(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__){eval('/* harmony import */ var _Credit_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(52975);\n/* harmony import */ var _defined_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(82982);\n/* harmony import */ var _Resource_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(68985);\n\n\n\n\nvar defaultTokenCredit;\nvar defaultAccessToken =\n  "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJqdGkiOiI2NjU0MGI3NC1iZjM2LTQzNzctYjM3Yy0zMmU2NGQyNTBiM2MiLCJpZCI6MjU5LCJpYXQiOjE2MzA0OTk1NzV9.xNFmNo8X26_nTRRouMiQSbmrOYel9uLf-eXp_q6htb4";\n/**\n * Default settings for accessing the Cesium ion API.\n *\n * An ion access token is only required if you are using any ion related APIs.\n * A default access token is provided for evaluation purposes only.\n * Sign up for a free ion account and get your own access token at {@link https://cesium.com}\n *\n * @see IonResource\n * @see IonImageryProvider\n * @see IonGeocoderService\n * @see createWorldImagery\n * @see createWorldTerrain\n * @namespace Ion\n */\nvar Ion = {};\n\n/**\n * Gets or sets the default Cesium ion access token.\n *\n * @type {String}\n */\nIon.defaultAccessToken = defaultAccessToken;\n\n/**\n * Gets or sets the default Cesium ion server.\n *\n * @type {String|Resource}\n * @default https://api.cesium.com\n */\nIon.defaultServer = new _Resource_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .Z({ url: "https://api.cesium.com/" });\n\nIon.getDefaultTokenCredit = function (providedKey) {\n  if (providedKey !== defaultAccessToken) {\n    return undefined;\n  }\n\n  if (!(0,_defined_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"] */ .Z)(defaultTokenCredit)) {\n    var defaultTokenMessage =\n      \'<b> \\\n            This application is using Cesium\\\'s default ion access token. Please assign <i>Cesium.Ion.defaultAccessToken</i> \\\n            with an access token from your ion account before making any Cesium API calls. \\\n            You can sign up for a free ion account at <a href="https://cesium.com">https://cesium.com</a>.</b>\';\n\n    defaultTokenCredit = new _Credit_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .Z(defaultTokenMessage, true);\n  }\n\n  return defaultTokenCredit;\n};\n/* harmony default export */ __webpack_exports__["Z"] = (Ion);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTAyMjEuanMiLCJtYXBwaW5ncyI6Ijs7O0FBQWlDO0FBQ0U7QUFDRTs7QUFFckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9FQUFvRTtBQUNwRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSx3QkFBd0IsNkRBQVEsR0FBRyxnQ0FBZ0M7O0FBRW5FO0FBQ0E7QUFDQTtBQUNBOztBQUVBLE9BQU8sZ0VBQU87QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDZCQUE2QiwyREFBTTtBQUNuQzs7QUFFQTtBQUNBO0FBQ0EseURBQWUsR0FBRyxFQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdnVlMy13ZWJwYWNrNS8uL25vZGVfbW9kdWxlcy9jZXNpdW0vU291cmNlL0NvcmUvSW9uLmpzP2FmMzQiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IENyZWRpdCBmcm9tIFwiLi9DcmVkaXQuanNcIjtcbmltcG9ydCBkZWZpbmVkIGZyb20gXCIuL2RlZmluZWQuanNcIjtcbmltcG9ydCBSZXNvdXJjZSBmcm9tIFwiLi9SZXNvdXJjZS5qc1wiO1xuXG52YXIgZGVmYXVsdFRva2VuQ3JlZGl0O1xudmFyIGRlZmF1bHRBY2Nlc3NUb2tlbiA9XG4gIFwiZXlKaGJHY2lPaUpJVXpJMU5pSXNJblI1Y0NJNklrcFhWQ0o5LmV5SnFkR2tpT2lJMk5qVTBNR0kzTkMxaVpqTTJMVFF6TnpjdFlqTTNZeTB6TW1VMk5HUXlOVEJpTTJNaUxDSnBaQ0k2TWpVNUxDSnBZWFFpT2pFMk16QTBPVGsxTnpWOS54TkZtTm84WDI2X25UUlJvdU1pUVNibXJPWWVsOXVMZi1lWHBfcTZodGI0XCI7XG4vKipcbiAqIERlZmF1bHQgc2V0dGluZ3MgZm9yIGFjY2Vzc2luZyB0aGUgQ2VzaXVtIGlvbiBBUEkuXG4gKlxuICogQW4gaW9uIGFjY2VzcyB0b2tlbiBpcyBvbmx5IHJlcXVpcmVkIGlmIHlvdSBhcmUgdXNpbmcgYW55IGlvbiByZWxhdGVkIEFQSXMuXG4gKiBBIGRlZmF1bHQgYWNjZXNzIHRva2VuIGlzIHByb3ZpZGVkIGZvciBldmFsdWF0aW9uIHB1cnBvc2VzIG9ubHkuXG4gKiBTaWduIHVwIGZvciBhIGZyZWUgaW9uIGFjY291bnQgYW5kIGdldCB5b3VyIG93biBhY2Nlc3MgdG9rZW4gYXQge0BsaW5rIGh0dHBzOi8vY2VzaXVtLmNvbX1cbiAqXG4gKiBAc2VlIElvblJlc291cmNlXG4gKiBAc2VlIElvbkltYWdlcnlQcm92aWRlclxuICogQHNlZSBJb25HZW9jb2RlclNlcnZpY2VcbiAqIEBzZWUgY3JlYXRlV29ybGRJbWFnZXJ5XG4gKiBAc2VlIGNyZWF0ZVdvcmxkVGVycmFpblxuICogQG5hbWVzcGFjZSBJb25cbiAqL1xudmFyIElvbiA9IHt9O1xuXG4vKipcbiAqIEdldHMgb3Igc2V0cyB0aGUgZGVmYXVsdCBDZXNpdW0gaW9uIGFjY2VzcyB0b2tlbi5cbiAqXG4gKiBAdHlwZSB7U3RyaW5nfVxuICovXG5Jb24uZGVmYXVsdEFjY2Vzc1Rva2VuID0gZGVmYXVsdEFjY2Vzc1Rva2VuO1xuXG4vKipcbiAqIEdldHMgb3Igc2V0cyB0aGUgZGVmYXVsdCBDZXNpdW0gaW9uIHNlcnZlci5cbiAqXG4gKiBAdHlwZSB7U3RyaW5nfFJlc291cmNlfVxuICogQGRlZmF1bHQgaHR0cHM6Ly9hcGkuY2VzaXVtLmNvbVxuICovXG5Jb24uZGVmYXVsdFNlcnZlciA9IG5ldyBSZXNvdXJjZSh7IHVybDogXCJodHRwczovL2FwaS5jZXNpdW0uY29tL1wiIH0pO1xuXG5Jb24uZ2V0RGVmYXVsdFRva2VuQ3JlZGl0ID0gZnVuY3Rpb24gKHByb3ZpZGVkS2V5KSB7XG4gIGlmIChwcm92aWRlZEtleSAhPT0gZGVmYXVsdEFjY2Vzc1Rva2VuKSB7XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxuXG4gIGlmICghZGVmaW5lZChkZWZhdWx0VG9rZW5DcmVkaXQpKSB7XG4gICAgdmFyIGRlZmF1bHRUb2tlbk1lc3NhZ2UgPVxuICAgICAgJzxiPiBcXFxuICAgICAgICAgICAgVGhpcyBhcHBsaWNhdGlvbiBpcyB1c2luZyBDZXNpdW1cXCdzIGRlZmF1bHQgaW9uIGFjY2VzcyB0b2tlbi4gUGxlYXNlIGFzc2lnbiA8aT5DZXNpdW0uSW9uLmRlZmF1bHRBY2Nlc3NUb2tlbjwvaT4gXFxcbiAgICAgICAgICAgIHdpdGggYW4gYWNjZXNzIHRva2VuIGZyb20geW91ciBpb24gYWNjb3VudCBiZWZvcmUgbWFraW5nIGFueSBDZXNpdW0gQVBJIGNhbGxzLiBcXFxuICAgICAgICAgICAgWW91IGNhbiBzaWduIHVwIGZvciBhIGZyZWUgaW9uIGFjY291bnQgYXQgPGEgaHJlZj1cImh0dHBzOi8vY2VzaXVtLmNvbVwiPmh0dHBzOi8vY2VzaXVtLmNvbTwvYT4uPC9iPic7XG5cbiAgICBkZWZhdWx0VG9rZW5DcmVkaXQgPSBuZXcgQ3JlZGl0KGRlZmF1bHRUb2tlbk1lc3NhZ2UsIHRydWUpO1xuICB9XG5cbiAgcmV0dXJuIGRlZmF1bHRUb2tlbkNyZWRpdDtcbn07XG5leHBvcnQgZGVmYXVsdCBJb247XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///10221\n')},98338:function(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__){eval('/* harmony import */ var _Check_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(66553);\n/* harmony import */ var _Credit_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(52975);\n/* harmony import */ var _defaultValue_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(62200);\n/* harmony import */ var _defined_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(82982);\n/* harmony import */ var _Ion_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(10221);\n/* harmony import */ var _PeliasGeocoderService_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(42978);\n/* harmony import */ var _Resource_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(68985);\n\n\n\n\n\n\n\n\n/**\n * Provides geocoding through Cesium ion.\n * @alias IonGeocoderService\n * @constructor\n *\n * @param {Object} options Object with the following properties:\n * @param {Scene} options.scene The scene\n * @param {String} [options.accessToken=Ion.defaultAccessToken] The access token to use.\n * @param {String|Resource} [options.server=Ion.defaultServer] The resource to the Cesium ion API server.\n *\n * @see Ion\n */\nfunction IonGeocoderService(options) {\n  options = (0,_defaultValue_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"] */ .Z)(options, _defaultValue_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"].EMPTY_OBJECT */ .Z.EMPTY_OBJECT);\n\n  //>>includeStart(\'debug\', pragmas.debug);\n  _Check_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].typeOf.object */ .Z.typeOf.object("options.scene", options.scene);\n  //>>includeEnd(\'debug\');\n\n  var accessToken = (0,_defaultValue_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"] */ .Z)(options.accessToken, _Ion_js__WEBPACK_IMPORTED_MODULE_3__/* ["default"].defaultAccessToken */ .Z.defaultAccessToken);\n  var server = _Resource_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"].createIfNeeded */ .Z.createIfNeeded(\n    (0,_defaultValue_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"] */ .Z)(options.server, _Ion_js__WEBPACK_IMPORTED_MODULE_3__/* ["default"].defaultServer */ .Z.defaultServer)\n  );\n  server.appendForwardSlash();\n\n  var defaultTokenCredit = _Ion_js__WEBPACK_IMPORTED_MODULE_3__/* ["default"].getDefaultTokenCredit */ .Z.getDefaultTokenCredit(accessToken);\n  if ((0,_defined_js__WEBPACK_IMPORTED_MODULE_6__/* ["default"] */ .Z)(defaultTokenCredit)) {\n    options.scene.frameState.creditDisplay.addDefaultCredit(\n      _Credit_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"].clone */ .Z.clone(defaultTokenCredit)\n    );\n  }\n\n  var searchEndpoint = server.getDerivedResource({\n    url: "v1/geocode",\n  });\n\n  if ((0,_defined_js__WEBPACK_IMPORTED_MODULE_6__/* ["default"] */ .Z)(accessToken)) {\n    searchEndpoint.appendQueryParameters({ access_token: accessToken });\n  }\n\n  this._accessToken = accessToken;\n  this._server = server;\n  this._pelias = new _PeliasGeocoderService_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .Z(searchEndpoint);\n}\n\n/**\n * @function\n *\n * @param {String} query The query to be sent to the geocoder service\n * @param {GeocodeType} [type=GeocodeType.SEARCH] The type of geocode to perform.\n * @returns {Promise<GeocoderService.Result[]>}\n */\nIonGeocoderService.prototype.geocode = function (query, geocodeType) {\n  return this._pelias.geocode(query, geocodeType);\n};\n/* harmony default export */ __webpack_exports__["Z"] = (IonGeocoderService);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiOTgzMzguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUErQjtBQUNFO0FBQ1k7QUFDVjtBQUNSO0FBQ29DO0FBQzFCOztBQUVyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsT0FBTztBQUNsQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxpQkFBaUI7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLHFFQUFZLFVBQVUsMkZBQXlCOztBQUUzRDtBQUNBLEVBQUUsc0ZBQW1CO0FBQ3JCOztBQUVBLG9CQUFvQixxRUFBWSxzQkFBc0IsOEZBQXNCO0FBQzVFLGVBQWUsMkZBQXVCO0FBQ3RDLElBQUkscUVBQVksaUJBQWlCLG9GQUFpQjtBQUNsRDtBQUNBOztBQUVBLDJCQUEyQixvR0FBeUI7QUFDcEQsTUFBTSxnRUFBTztBQUNiO0FBQ0EsTUFBTSx1RUFBWTtBQUNsQjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHOztBQUVILE1BQU0sZ0VBQU87QUFDYiwyQ0FBMkMsMkJBQTJCO0FBQ3RFOztBQUVBO0FBQ0E7QUFDQSxxQkFBcUIsMEVBQXFCO0FBQzFDOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLGFBQWE7QUFDeEIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseURBQWUsa0JBQWtCLEVBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly92dWUzLXdlYnBhY2s1Ly4vbm9kZV9tb2R1bGVzL2Nlc2l1bS9Tb3VyY2UvQ29yZS9Jb25HZW9jb2RlclNlcnZpY2UuanM/OGIxYiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgQ2hlY2sgZnJvbSBcIi4vQ2hlY2suanNcIjtcbmltcG9ydCBDcmVkaXQgZnJvbSBcIi4vQ3JlZGl0LmpzXCI7XG5pbXBvcnQgZGVmYXVsdFZhbHVlIGZyb20gXCIuL2RlZmF1bHRWYWx1ZS5qc1wiO1xuaW1wb3J0IGRlZmluZWQgZnJvbSBcIi4vZGVmaW5lZC5qc1wiO1xuaW1wb3J0IElvbiBmcm9tIFwiLi9Jb24uanNcIjtcbmltcG9ydCBQZWxpYXNHZW9jb2RlclNlcnZpY2UgZnJvbSBcIi4vUGVsaWFzR2VvY29kZXJTZXJ2aWNlLmpzXCI7XG5pbXBvcnQgUmVzb3VyY2UgZnJvbSBcIi4vUmVzb3VyY2UuanNcIjtcblxuLyoqXG4gKiBQcm92aWRlcyBnZW9jb2RpbmcgdGhyb3VnaCBDZXNpdW0gaW9uLlxuICogQGFsaWFzIElvbkdlb2NvZGVyU2VydmljZVxuICogQGNvbnN0cnVjdG9yXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgT2JqZWN0IHdpdGggdGhlIGZvbGxvd2luZyBwcm9wZXJ0aWVzOlxuICogQHBhcmFtIHtTY2VuZX0gb3B0aW9ucy5zY2VuZSBUaGUgc2NlbmVcbiAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5hY2Nlc3NUb2tlbj1Jb24uZGVmYXVsdEFjY2Vzc1Rva2VuXSBUaGUgYWNjZXNzIHRva2VuIHRvIHVzZS5cbiAqIEBwYXJhbSB7U3RyaW5nfFJlc291cmNlfSBbb3B0aW9ucy5zZXJ2ZXI9SW9uLmRlZmF1bHRTZXJ2ZXJdIFRoZSByZXNvdXJjZSB0byB0aGUgQ2VzaXVtIGlvbiBBUEkgc2VydmVyLlxuICpcbiAqIEBzZWUgSW9uXG4gKi9cbmZ1bmN0aW9uIElvbkdlb2NvZGVyU2VydmljZShvcHRpb25zKSB7XG4gIG9wdGlvbnMgPSBkZWZhdWx0VmFsdWUob3B0aW9ucywgZGVmYXVsdFZhbHVlLkVNUFRZX09CSkVDVCk7XG5cbiAgLy8+PmluY2x1ZGVTdGFydCgnZGVidWcnLCBwcmFnbWFzLmRlYnVnKTtcbiAgQ2hlY2sudHlwZU9mLm9iamVjdChcIm9wdGlvbnMuc2NlbmVcIiwgb3B0aW9ucy5zY2VuZSk7XG4gIC8vPj5pbmNsdWRlRW5kKCdkZWJ1ZycpO1xuXG4gIHZhciBhY2Nlc3NUb2tlbiA9IGRlZmF1bHRWYWx1ZShvcHRpb25zLmFjY2Vzc1Rva2VuLCBJb24uZGVmYXVsdEFjY2Vzc1Rva2VuKTtcbiAgdmFyIHNlcnZlciA9IFJlc291cmNlLmNyZWF0ZUlmTmVlZGVkKFxuICAgIGRlZmF1bHRWYWx1ZShvcHRpb25zLnNlcnZlciwgSW9uLmRlZmF1bHRTZXJ2ZXIpXG4gICk7XG4gIHNlcnZlci5hcHBlbmRGb3J3YXJkU2xhc2goKTtcblxuICB2YXIgZGVmYXVsdFRva2VuQ3JlZGl0ID0gSW9uLmdldERlZmF1bHRUb2tlbkNyZWRpdChhY2Nlc3NUb2tlbik7XG4gIGlmIChkZWZpbmVkKGRlZmF1bHRUb2tlbkNyZWRpdCkpIHtcbiAgICBvcHRpb25zLnNjZW5lLmZyYW1lU3RhdGUuY3JlZGl0RGlzcGxheS5hZGREZWZhdWx0Q3JlZGl0KFxuICAgICAgQ3JlZGl0LmNsb25lKGRlZmF1bHRUb2tlbkNyZWRpdClcbiAgICApO1xuICB9XG5cbiAgdmFyIHNlYXJjaEVuZHBvaW50ID0gc2VydmVyLmdldERlcml2ZWRSZXNvdXJjZSh7XG4gICAgdXJsOiBcInYxL2dlb2NvZGVcIixcbiAgfSk7XG5cbiAgaWYgKGRlZmluZWQoYWNjZXNzVG9rZW4pKSB7XG4gICAgc2VhcmNoRW5kcG9pbnQuYXBwZW5kUXVlcnlQYXJhbWV0ZXJzKHsgYWNjZXNzX3Rva2VuOiBhY2Nlc3NUb2tlbiB9KTtcbiAgfVxuXG4gIHRoaXMuX2FjY2Vzc1Rva2VuID0gYWNjZXNzVG9rZW47XG4gIHRoaXMuX3NlcnZlciA9IHNlcnZlcjtcbiAgdGhpcy5fcGVsaWFzID0gbmV3IFBlbGlhc0dlb2NvZGVyU2VydmljZShzZWFyY2hFbmRwb2ludCk7XG59XG5cbi8qKlxuICogQGZ1bmN0aW9uXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHF1ZXJ5IFRoZSBxdWVyeSB0byBiZSBzZW50IHRvIHRoZSBnZW9jb2RlciBzZXJ2aWNlXG4gKiBAcGFyYW0ge0dlb2NvZGVUeXBlfSBbdHlwZT1HZW9jb2RlVHlwZS5TRUFSQ0hdIFRoZSB0eXBlIG9mIGdlb2NvZGUgdG8gcGVyZm9ybS5cbiAqIEByZXR1cm5zIHtQcm9taXNlPEdlb2NvZGVyU2VydmljZS5SZXN1bHRbXT59XG4gKi9cbklvbkdlb2NvZGVyU2VydmljZS5wcm90b3R5cGUuZ2VvY29kZSA9IGZ1bmN0aW9uIChxdWVyeSwgZ2VvY29kZVR5cGUpIHtcbiAgcmV0dXJuIHRoaXMuX3BlbGlhcy5nZW9jb2RlKHF1ZXJ5LCBnZW9jb2RlVHlwZSk7XG59O1xuZXhwb3J0IGRlZmF1bHQgSW9uR2VvY29kZXJTZXJ2aWNlO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///98338\n')},48604:function(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__){eval('/* harmony import */ var _ThirdParty_Uri_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(93922);\n/* harmony import */ var _ThirdParty_when_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(13222);\n/* harmony import */ var _Check_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(66553);\n/* harmony import */ var _Credit_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(52975);\n/* harmony import */ var _defaultValue_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(62200);\n/* harmony import */ var _defined_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(82982);\n/* harmony import */ var _Ion_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(10221);\n/* harmony import */ var _Resource_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(68985);\n/* harmony import */ var _RuntimeError_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(9407);\n\n\n\n\n\n\n\n\n\n\n/**\n * A {@link Resource} instance that encapsulates Cesium ion asset access.\n * This object is normally not instantiated directly, use {@link IonResource.fromAssetId}.\n *\n * @alias IonResource\n * @constructor\n * @augments Resource\n *\n * @param {Object} endpoint The result of the Cesium ion asset endpoint service.\n * @param {Resource} endpointResource The resource used to retreive the endpoint.\n *\n * @see Ion\n * @see IonImageryProvider\n * @see createWorldTerrain\n * @see https://cesium.com\n */\nfunction IonResource(endpoint, endpointResource) {\n  //>>includeStart(\'debug\', pragmas.debug);\n  _Check_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"].defined */ .Z.defined("endpoint", endpoint);\n  _Check_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"].defined */ .Z.defined("endpointResource", endpointResource);\n  //>>includeEnd(\'debug\');\n\n  var options;\n  var externalType = endpoint.externalType;\n  var isExternal = (0,_defined_js__WEBPACK_IMPORTED_MODULE_8__/* ["default"] */ .Z)(externalType);\n\n  if (!isExternal) {\n    options = {\n      url: endpoint.url,\n      retryAttempts: 1,\n      retryCallback: retryCallback,\n    };\n  } else if (\n    externalType === "3DTILES" ||\n    externalType === "STK_TERRAIN_SERVER"\n  ) {\n    // 3D Tiles and STK Terrain Server external assets can still be represented as an IonResource\n    options = { url: endpoint.options.url };\n  } else {\n    //External imagery assets have additional configuration that can\'t be represented as a Resource\n    throw new _RuntimeError_js__WEBPACK_IMPORTED_MODULE_7__/* ["default"] */ .Z(\n      "Ion.createResource does not support external imagery assets; use IonImageryProvider instead."\n    );\n  }\n\n  _Resource_js__WEBPACK_IMPORTED_MODULE_6__/* ["default"].call */ .Z.call(this, options);\n\n  // The asset endpoint data returned from ion.\n  this._ionEndpoint = endpoint;\n  this._ionEndpointDomain = isExternal\n    ? undefined\n    : new _ThirdParty_Uri_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .Z(endpoint.url).authority();\n\n  // The endpoint resource to fetch when a new token is needed\n  this._ionEndpointResource = endpointResource;\n\n  // The primary IonResource from which an instance is derived\n  this._ionRoot = undefined;\n\n  // Shared promise for endpooint requests amd credits (only ever set on the root request)\n  this._pendingPromise = undefined;\n  this._credits = undefined;\n  this._isExternal = isExternal;\n}\n\nif ((0,_defined_js__WEBPACK_IMPORTED_MODULE_8__/* ["default"] */ .Z)(Object.create)) {\n  IonResource.prototype = Object.create(_Resource_js__WEBPACK_IMPORTED_MODULE_6__/* ["default"].prototype */ .Z.prototype);\n  IonResource.prototype.constructor = IonResource;\n}\n\n/**\n * Asynchronously creates an instance.\n *\n * @param {Number} assetId The Cesium ion asset id.\n * @param {Object} [options] An object with the following properties:\n * @param {String} [options.accessToken=Ion.defaultAccessToken] The access token to use.\n * @param {String|Resource} [options.server=Ion.defaultServer] The resource to the Cesium ion API server.\n * @returns {Promise.<IonResource>} A Promise to am instance representing the Cesium ion Asset.\n *\n * @example\n * //Load a Cesium3DTileset with asset ID of 124624234\n * viewer.scene.primitives.add(new Cesium.Cesium3DTileset({ url: Cesium.IonResource.fromAssetId(124624234) }));\n *\n * @example\n * //Load a CZML file with asset ID of 10890\n * Cesium.IonResource.fromAssetId(10890)\n *   .then(function (resource) {\n *     viewer.dataSources.add(Cesium.CzmlDataSource.load(resource));\n *   });\n */\nIonResource.fromAssetId = function (assetId, options) {\n  var endpointResource = IonResource._createEndpointResource(assetId, options);\n\n  return endpointResource.fetchJson().then(function (endpoint) {\n    return new IonResource(endpoint, endpointResource);\n  });\n};\n\nObject.defineProperties(IonResource.prototype, {\n  /**\n   * Gets the credits required for attribution of the asset.\n   *\n   * @memberof IonResource.prototype\n   * @type {Credit[]}\n   * @readonly\n   */\n  credits: {\n    get: function () {\n      // Only we\'re not the root, return its credits;\n      if ((0,_defined_js__WEBPACK_IMPORTED_MODULE_8__/* ["default"] */ .Z)(this._ionRoot)) {\n        return this._ionRoot.credits;\n      }\n\n      // We are the root\n      if ((0,_defined_js__WEBPACK_IMPORTED_MODULE_8__/* ["default"] */ .Z)(this._credits)) {\n        return this._credits;\n      }\n\n      this._credits = IonResource.getCreditsFromEndpoint(\n        this._ionEndpoint,\n        this._ionEndpointResource\n      );\n\n      return this._credits;\n    },\n  },\n});\n\n/** @private */\nIonResource.getCreditsFromEndpoint = function (endpoint, endpointResource) {\n  var credits = endpoint.attributions.map(_Credit_js__WEBPACK_IMPORTED_MODULE_3__/* ["default"].getIonCredit */ .Z.getIonCredit);\n  var defaultTokenCredit = _Ion_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"].getDefaultTokenCredit */ .Z.getDefaultTokenCredit(\n    endpointResource.queryParameters.access_token\n  );\n  if ((0,_defined_js__WEBPACK_IMPORTED_MODULE_8__/* ["default"] */ .Z)(defaultTokenCredit)) {\n    credits.push(_Credit_js__WEBPACK_IMPORTED_MODULE_3__/* ["default"].clone */ .Z.clone(defaultTokenCredit));\n  }\n  return credits;\n};\n\n/** @inheritdoc */\nIonResource.prototype.clone = function (result) {\n  // We always want to use the root\'s information because it\'s the most up-to-date\n  var ionRoot = (0,_defaultValue_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .Z)(this._ionRoot, this);\n\n  if (!(0,_defined_js__WEBPACK_IMPORTED_MODULE_8__/* ["default"] */ .Z)(result)) {\n    result = new IonResource(\n      ionRoot._ionEndpoint,\n      ionRoot._ionEndpointResource\n    );\n  }\n\n  result = _Resource_js__WEBPACK_IMPORTED_MODULE_6__/* ["default"].prototype.clone.call */ .Z.prototype.clone.call(this, result);\n  result._ionRoot = ionRoot;\n  result._isExternal = this._isExternal;\n\n  return result;\n};\n\nIonResource.prototype.fetchImage = function (options) {\n  if (!this._isExternal) {\n    var userOptions = options;\n    options = {\n      preferBlob: true,\n    };\n    if ((0,_defined_js__WEBPACK_IMPORTED_MODULE_8__/* ["default"] */ .Z)(userOptions)) {\n      options.flipY = userOptions.flipY;\n      options.preferImageBitmap = userOptions.preferImageBitmap;\n    }\n  }\n\n  return _Resource_js__WEBPACK_IMPORTED_MODULE_6__/* ["default"].prototype.fetchImage.call */ .Z.prototype.fetchImage.call(this, options);\n};\n\nIonResource.prototype._makeRequest = function (options) {\n  // Don\'t send ion access token to non-ion servers.\n  if (\n    this._isExternal ||\n    new _ThirdParty_Uri_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .Z(this.url).authority() !== this._ionEndpointDomain\n  ) {\n    return _Resource_js__WEBPACK_IMPORTED_MODULE_6__/* ["default"].prototype._makeRequest.call */ .Z.prototype._makeRequest.call(this, options);\n  }\n\n  if (!(0,_defined_js__WEBPACK_IMPORTED_MODULE_8__/* ["default"] */ .Z)(options.headers)) {\n    options.headers = {};\n  }\n  options.headers.Authorization = "Bearer " + this._ionEndpoint.accessToken;\n\n  return _Resource_js__WEBPACK_IMPORTED_MODULE_6__/* ["default"].prototype._makeRequest.call */ .Z.prototype._makeRequest.call(this, options);\n};\n\n/**\n * @private\n */\nIonResource._createEndpointResource = function (assetId, options) {\n  //>>includeStart(\'debug\', pragmas.debug);\n  _Check_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"].defined */ .Z.defined("assetId", assetId);\n  //>>includeEnd(\'debug\');\n\n  options = (0,_defaultValue_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .Z)(options, _defaultValue_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"].EMPTY_OBJECT */ .Z.EMPTY_OBJECT);\n  var server = (0,_defaultValue_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .Z)(options.server, _Ion_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"].defaultServer */ .Z.defaultServer);\n  var accessToken = (0,_defaultValue_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .Z)(options.accessToken, _Ion_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"].defaultAccessToken */ .Z.defaultAccessToken);\n  server = _Resource_js__WEBPACK_IMPORTED_MODULE_6__/* ["default"].createIfNeeded */ .Z.createIfNeeded(server);\n\n  var resourceOptions = {\n    url: "v1/assets/" + assetId + "/endpoint",\n  };\n\n  if ((0,_defined_js__WEBPACK_IMPORTED_MODULE_8__/* ["default"] */ .Z)(accessToken)) {\n    resourceOptions.queryParameters = { access_token: accessToken };\n  }\n\n  return server.getDerivedResource(resourceOptions);\n};\n\nfunction retryCallback(that, error) {\n  var ionRoot = (0,_defaultValue_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .Z)(that._ionRoot, that);\n  var endpointResource = ionRoot._ionEndpointResource;\n\n  // Image is not available in worker threads, so this avoids\n  // a ReferenceError\n  var imageDefined = typeof Image !== "undefined";\n\n  // We only want to retry in the case of invalid credentials (401) or image\n  // requests(since Image failures can not provide a status code)\n  if (\n    !(0,_defined_js__WEBPACK_IMPORTED_MODULE_8__/* ["default"] */ .Z)(error) ||\n    (error.statusCode !== 401 &&\n      !(imageDefined && error.target instanceof Image))\n  ) {\n    return _ThirdParty_when_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"].resolve */ .Z.resolve(false);\n  }\n\n  // We use a shared pending promise for all derived assets, since they share\n  // a common access_token.  If we\'re already requesting a new token for this\n  // asset, we wait on the same promise.\n  if (!(0,_defined_js__WEBPACK_IMPORTED_MODULE_8__/* ["default"] */ .Z)(ionRoot._pendingPromise)) {\n    ionRoot._pendingPromise = endpointResource\n      .fetchJson()\n      .then(function (newEndpoint) {\n        //Set the token for root resource so new derived resources automatically pick it up\n        ionRoot._ionEndpoint = newEndpoint;\n        return newEndpoint;\n      })\n      .always(function (newEndpoint) {\n        // Pass or fail, we\'re done with this promise, the next failure should use a new one.\n        ionRoot._pendingPromise = undefined;\n        return newEndpoint;\n      });\n  }\n\n  return ionRoot._pendingPromise.then(function (newEndpoint) {\n    // Set the new token and endpoint for this resource\n    that._ionEndpoint = newEndpoint;\n    return true;\n  });\n}\n/* harmony default export */ __webpack_exports__["Z"] = (IonResource);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLHlEQUFlLFdBQVcsRUFBQyIsInNvdXJjZXMiOlsid2VicGFjazovL3Z1ZTMtd2VicGFjazUvLi9ub2RlX21vZHVsZXMvY2VzaXVtL1NvdXJjZS9Db3JlL0lvblJlc291cmNlLmpzP2Q1NWUiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IFVyaSBmcm9tIFwiLi4vVGhpcmRQYXJ0eS9VcmkuanNcIjtcbmltcG9ydCB3aGVuIGZyb20gXCIuLi9UaGlyZFBhcnR5L3doZW4uanNcIjtcbmltcG9ydCBDaGVjayBmcm9tIFwiLi9DaGVjay5qc1wiO1xuaW1wb3J0IENyZWRpdCBmcm9tIFwiLi9DcmVkaXQuanNcIjtcbmltcG9ydCBkZWZhdWx0VmFsdWUgZnJvbSBcIi4vZGVmYXVsdFZhbHVlLmpzXCI7XG5pbXBvcnQgZGVmaW5lZCBmcm9tIFwiLi9kZWZpbmVkLmpzXCI7XG5pbXBvcnQgSW9uIGZyb20gXCIuL0lvbi5qc1wiO1xuaW1wb3J0IFJlc291cmNlIGZyb20gXCIuL1Jlc291cmNlLmpzXCI7XG5pbXBvcnQgUnVudGltZUVycm9yIGZyb20gXCIuL1J1bnRpbWVFcnJvci5qc1wiO1xuXG4vKipcbiAqIEEge0BsaW5rIFJlc291cmNlfSBpbnN0YW5jZSB0aGF0IGVuY2Fwc3VsYXRlcyBDZXNpdW0gaW9uIGFzc2V0IGFjY2Vzcy5cbiAqIFRoaXMgb2JqZWN0IGlzIG5vcm1hbGx5IG5vdCBpbnN0YW50aWF0ZWQgZGlyZWN0bHksIHVzZSB7QGxpbmsgSW9uUmVzb3VyY2UuZnJvbUFzc2V0SWR9LlxuICpcbiAqIEBhbGlhcyBJb25SZXNvdXJjZVxuICogQGNvbnN0cnVjdG9yXG4gKiBAYXVnbWVudHMgUmVzb3VyY2VcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gZW5kcG9pbnQgVGhlIHJlc3VsdCBvZiB0aGUgQ2VzaXVtIGlvbiBhc3NldCBlbmRwb2ludCBzZXJ2aWNlLlxuICogQHBhcmFtIHtSZXNvdXJjZX0gZW5kcG9pbnRSZXNvdXJjZSBUaGUgcmVzb3VyY2UgdXNlZCB0byByZXRyZWl2ZSB0aGUgZW5kcG9pbnQuXG4gKlxuICogQHNlZSBJb25cbiAqIEBzZWUgSW9uSW1hZ2VyeVByb3ZpZGVyXG4gKiBAc2VlIGNyZWF0ZVdvcmxkVGVycmFpblxuICogQHNlZSBodHRwczovL2Nlc2l1bS5jb21cbiAqL1xuZnVuY3Rpb24gSW9uUmVzb3VyY2UoZW5kcG9pbnQsIGVuZHBvaW50UmVzb3VyY2UpIHtcbiAgLy8+PmluY2x1ZGVTdGFydCgnZGVidWcnLCBwcmFnbWFzLmRlYnVnKTtcbiAgQ2hlY2suZGVmaW5lZChcImVuZHBvaW50XCIsIGVuZHBvaW50KTtcbiAgQ2hlY2suZGVmaW5lZChcImVuZHBvaW50UmVzb3VyY2VcIiwgZW5kcG9pbnRSZXNvdXJjZSk7XG4gIC8vPj5pbmNsdWRlRW5kKCdkZWJ1ZycpO1xuXG4gIHZhciBvcHRpb25zO1xuICB2YXIgZXh0ZXJuYWxUeXBlID0gZW5kcG9pbnQuZXh0ZXJuYWxUeXBlO1xuICB2YXIgaXNFeHRlcm5hbCA9IGRlZmluZWQoZXh0ZXJuYWxUeXBlKTtcblxuICBpZiAoIWlzRXh0ZXJuYWwpIHtcbiAgICBvcHRpb25zID0ge1xuICAgICAgdXJsOiBlbmRwb2ludC51cmwsXG4gICAgICByZXRyeUF0dGVtcHRzOiAxLFxuICAgICAgcmV0cnlDYWxsYmFjazogcmV0cnlDYWxsYmFjayxcbiAgICB9O1xuICB9IGVsc2UgaWYgKFxuICAgIGV4dGVybmFsVHlwZSA9PT0gXCIzRFRJTEVTXCIgfHxcbiAgICBleHRlcm5hbFR5cGUgPT09IFwiU1RLX1RFUlJBSU5fU0VSVkVSXCJcbiAgKSB7XG4gICAgLy8gM0QgVGlsZXMgYW5kIFNUSyBUZXJyYWluIFNlcnZlciBleHRlcm5hbCBhc3NldHMgY2FuIHN0aWxsIGJlIHJlcHJlc2VudGVkIGFzIGFuIElvblJlc291cmNlXG4gICAgb3B0aW9ucyA9IHsgdXJsOiBlbmRwb2ludC5vcHRpb25zLnVybCB9O1xuICB9IGVsc2Uge1xuICAgIC8vRXh0ZXJuYWwgaW1hZ2VyeSBhc3NldHMgaGF2ZSBhZGRpdGlvbmFsIGNvbmZpZ3VyYXRpb24gdGhhdCBjYW4ndCBiZSByZXByZXNlbnRlZCBhcyBhIFJlc291cmNlXG4gICAgdGhyb3cgbmV3IFJ1bnRpbWVFcnJvcihcbiAgICAgIFwiSW9uLmNyZWF0ZVJlc291cmNlIGRvZXMgbm90IHN1cHBvcnQgZXh0ZXJuYWwgaW1hZ2VyeSBhc3NldHM7IHVzZSBJb25JbWFnZXJ5UHJvdmlkZXIgaW5zdGVhZC5cIlxuICAgICk7XG4gIH1cblxuICBSZXNvdXJjZS5jYWxsKHRoaXMsIG9wdGlvbnMpO1xuXG4gIC8vIFRoZSBhc3NldCBlbmRwb2ludCBkYXRhIHJldHVybmVkIGZyb20gaW9uLlxuICB0aGlzLl9pb25FbmRwb2ludCA9IGVuZHBvaW50O1xuICB0aGlzLl9pb25FbmRwb2ludERvbWFpbiA9IGlzRXh0ZXJuYWxcbiAgICA/IHVuZGVmaW5lZFxuICAgIDogbmV3IFVyaShlbmRwb2ludC51cmwpLmF1dGhvcml0eSgpO1xuXG4gIC8vIFRoZSBlbmRwb2ludCByZXNvdXJjZSB0byBmZXRjaCB3aGVuIGEgbmV3IHRva2VuIGlzIG5lZWRlZFxuICB0aGlzLl9pb25FbmRwb2ludFJlc291cmNlID0gZW5kcG9pbnRSZXNvdXJjZTtcblxuICAvLyBUaGUgcHJpbWFyeSBJb25SZXNvdXJjZSBmcm9tIHdoaWNoIGFuIGluc3RhbmNlIGlzIGRlcml2ZWRcbiAgdGhpcy5faW9uUm9vdCA9IHVuZGVmaW5lZDtcblxuICAvLyBTaGFyZWQgcHJvbWlzZSBmb3IgZW5kcG9vaW50IHJlcXVlc3RzIGFtZCBjcmVkaXRzIChvbmx5IGV2ZXIgc2V0IG9uIHRoZSByb290IHJlcXVlc3QpXG4gIHRoaXMuX3BlbmRpbmdQcm9taXNlID0gdW5kZWZpbmVkO1xuICB0aGlzLl9jcmVkaXRzID0gdW5kZWZpbmVkO1xuICB0aGlzLl9pc0V4dGVybmFsID0gaXNFeHRlcm5hbDtcbn1cblxuaWYgKGRlZmluZWQoT2JqZWN0LmNyZWF0ZSkpIHtcbiAgSW9uUmVzb3VyY2UucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShSZXNvdXJjZS5wcm90b3R5cGUpO1xuICBJb25SZXNvdXJjZS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBJb25SZXNvdXJjZTtcbn1cblxuLyoqXG4gKiBBc3luY2hyb25vdXNseSBjcmVhdGVzIGFuIGluc3RhbmNlLlxuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSBhc3NldElkIFRoZSBDZXNpdW0gaW9uIGFzc2V0IGlkLlxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSBBbiBvYmplY3Qgd2l0aCB0aGUgZm9sbG93aW5nIHByb3BlcnRpZXM6XG4gKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMuYWNjZXNzVG9rZW49SW9uLmRlZmF1bHRBY2Nlc3NUb2tlbl0gVGhlIGFjY2VzcyB0b2tlbiB0byB1c2UuXG4gKiBAcGFyYW0ge1N0cmluZ3xSZXNvdXJjZX0gW29wdGlvbnMuc2VydmVyPUlvbi5kZWZhdWx0U2VydmVyXSBUaGUgcmVzb3VyY2UgdG8gdGhlIENlc2l1bSBpb24gQVBJIHNlcnZlci5cbiAqIEByZXR1cm5zIHtQcm9taXNlLjxJb25SZXNvdXJjZT59IEEgUHJvbWlzZSB0byBhbSBpbnN0YW5jZSByZXByZXNlbnRpbmcgdGhlIENlc2l1bSBpb24gQXNzZXQuXG4gKlxuICogQGV4YW1wbGVcbiAqIC8vTG9hZCBhIENlc2l1bTNEVGlsZXNldCB3aXRoIGFzc2V0IElEIG9mIDEyNDYyNDIzNFxuICogdmlld2VyLnNjZW5lLnByaW1pdGl2ZXMuYWRkKG5ldyBDZXNpdW0uQ2VzaXVtM0RUaWxlc2V0KHsgdXJsOiBDZXNpdW0uSW9uUmVzb3VyY2UuZnJvbUFzc2V0SWQoMTI0NjI0MjM0KSB9KSk7XG4gKlxuICogQGV4YW1wbGVcbiAqIC8vTG9hZCBhIENaTUwgZmlsZSB3aXRoIGFzc2V0IElEIG9mIDEwODkwXG4gKiBDZXNpdW0uSW9uUmVzb3VyY2UuZnJvbUFzc2V0SWQoMTA4OTApXG4gKiAgIC50aGVuKGZ1bmN0aW9uIChyZXNvdXJjZSkge1xuICogICAgIHZpZXdlci5kYXRhU291cmNlcy5hZGQoQ2VzaXVtLkN6bWxEYXRhU291cmNlLmxvYWQocmVzb3VyY2UpKTtcbiAqICAgfSk7XG4gKi9cbklvblJlc291cmNlLmZyb21Bc3NldElkID0gZnVuY3Rpb24gKGFzc2V0SWQsIG9wdGlvbnMpIHtcbiAgdmFyIGVuZHBvaW50UmVzb3VyY2UgPSBJb25SZXNvdXJjZS5fY3JlYXRlRW5kcG9pbnRSZXNvdXJjZShhc3NldElkLCBvcHRpb25zKTtcblxuICByZXR1cm4gZW5kcG9pbnRSZXNvdXJjZS5mZXRjaEpzb24oKS50aGVuKGZ1bmN0aW9uIChlbmRwb2ludCkge1xuICAgIHJldHVybiBuZXcgSW9uUmVzb3VyY2UoZW5kcG9pbnQsIGVuZHBvaW50UmVzb3VyY2UpO1xuICB9KTtcbn07XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKElvblJlc291cmNlLnByb3RvdHlwZSwge1xuICAvKipcbiAgICogR2V0cyB0aGUgY3JlZGl0cyByZXF1aXJlZCBmb3IgYXR0cmlidXRpb24gb2YgdGhlIGFzc2V0LlxuICAgKlxuICAgKiBAbWVtYmVyb2YgSW9uUmVzb3VyY2UucHJvdG90eXBlXG4gICAqIEB0eXBlIHtDcmVkaXRbXX1cbiAgICogQHJlYWRvbmx5XG4gICAqL1xuICBjcmVkaXRzOiB7XG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAvLyBPbmx5IHdlJ3JlIG5vdCB0aGUgcm9vdCwgcmV0dXJuIGl0cyBjcmVkaXRzO1xuICAgICAgaWYgKGRlZmluZWQodGhpcy5faW9uUm9vdCkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2lvblJvb3QuY3JlZGl0cztcbiAgICAgIH1cblxuICAgICAgLy8gV2UgYXJlIHRoZSByb290XG4gICAgICBpZiAoZGVmaW5lZCh0aGlzLl9jcmVkaXRzKSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fY3JlZGl0cztcbiAgICAgIH1cblxuICAgICAgdGhpcy5fY3JlZGl0cyA9IElvblJlc291cmNlLmdldENyZWRpdHNGcm9tRW5kcG9pbnQoXG4gICAgICAgIHRoaXMuX2lvbkVuZHBvaW50LFxuICAgICAgICB0aGlzLl9pb25FbmRwb2ludFJlc291cmNlXG4gICAgICApO1xuXG4gICAgICByZXR1cm4gdGhpcy5fY3JlZGl0cztcbiAgICB9LFxuICB9LFxufSk7XG5cbi8qKiBAcHJpdmF0ZSAqL1xuSW9uUmVzb3VyY2UuZ2V0Q3JlZGl0c0Zyb21FbmRwb2ludCA9IGZ1bmN0aW9uIChlbmRwb2ludCwgZW5kcG9pbnRSZXNvdXJjZSkge1xuICB2YXIgY3JlZGl0cyA9IGVuZHBvaW50LmF0dHJpYnV0aW9ucy5tYXAoQ3JlZGl0LmdldElvbkNyZWRpdCk7XG4gIHZhciBkZWZhdWx0VG9rZW5DcmVkaXQgPSBJb24uZ2V0RGVmYXVsdFRva2VuQ3JlZGl0KFxuICAgIGVuZHBvaW50UmVzb3VyY2UucXVlcnlQYXJhbWV0ZXJzLmFjY2Vzc190b2tlblxuICApO1xuICBpZiAoZGVmaW5lZChkZWZhdWx0VG9rZW5DcmVkaXQpKSB7XG4gICAgY3JlZGl0cy5wdXNoKENyZWRpdC5jbG9uZShkZWZhdWx0VG9rZW5DcmVkaXQpKTtcbiAgfVxuICByZXR1cm4gY3JlZGl0cztcbn07XG5cbi8qKiBAaW5oZXJpdGRvYyAqL1xuSW9uUmVzb3VyY2UucHJvdG90eXBlLmNsb25lID0gZnVuY3Rpb24gKHJlc3VsdCkge1xuICAvLyBXZSBhbHdheXMgd2FudCB0byB1c2UgdGhlIHJvb3QncyBpbmZvcm1hdGlvbiBiZWNhdXNlIGl0J3MgdGhlIG1vc3QgdXAtdG8tZGF0ZVxuICB2YXIgaW9uUm9vdCA9IGRlZmF1bHRWYWx1ZSh0aGlzLl9pb25Sb290LCB0aGlzKTtcblxuICBpZiAoIWRlZmluZWQocmVzdWx0KSkge1xuICAgIHJlc3VsdCA9IG5ldyBJb25SZXNvdXJjZShcbiAgICAgIGlvblJvb3QuX2lvbkVuZHBvaW50LFxuICAgICAgaW9uUm9vdC5faW9uRW5kcG9pbnRSZXNvdXJjZVxuICAgICk7XG4gIH1cblxuICByZXN1bHQgPSBSZXNvdXJjZS5wcm90b3R5cGUuY2xvbmUuY2FsbCh0aGlzLCByZXN1bHQpO1xuICByZXN1bHQuX2lvblJvb3QgPSBpb25Sb290O1xuICByZXN1bHQuX2lzRXh0ZXJuYWwgPSB0aGlzLl9pc0V4dGVybmFsO1xuXG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG5Jb25SZXNvdXJjZS5wcm90b3R5cGUuZmV0Y2hJbWFnZSA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gIGlmICghdGhpcy5faXNFeHRlcm5hbCkge1xuICAgIHZhciB1c2VyT3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgb3B0aW9ucyA9IHtcbiAgICAgIHByZWZlckJsb2I6IHRydWUsXG4gICAgfTtcbiAgICBpZiAoZGVmaW5lZCh1c2VyT3B0aW9ucykpIHtcbiAgICAgIG9wdGlvbnMuZmxpcFkgPSB1c2VyT3B0aW9ucy5mbGlwWTtcbiAgICAgIG9wdGlvbnMucHJlZmVySW1hZ2VCaXRtYXAgPSB1c2VyT3B0aW9ucy5wcmVmZXJJbWFnZUJpdG1hcDtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gUmVzb3VyY2UucHJvdG90eXBlLmZldGNoSW1hZ2UuY2FsbCh0aGlzLCBvcHRpb25zKTtcbn07XG5cbklvblJlc291cmNlLnByb3RvdHlwZS5fbWFrZVJlcXVlc3QgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAvLyBEb24ndCBzZW5kIGlvbiBhY2Nlc3MgdG9rZW4gdG8gbm9uLWlvbiBzZXJ2ZXJzLlxuICBpZiAoXG4gICAgdGhpcy5faXNFeHRlcm5hbCB8fFxuICAgIG5ldyBVcmkodGhpcy51cmwpLmF1dGhvcml0eSgpICE9PSB0aGlzLl9pb25FbmRwb2ludERvbWFpblxuICApIHtcbiAgICByZXR1cm4gUmVzb3VyY2UucHJvdG90eXBlLl9tYWtlUmVxdWVzdC5jYWxsKHRoaXMsIG9wdGlvbnMpO1xuICB9XG5cbiAgaWYgKCFkZWZpbmVkKG9wdGlvbnMuaGVhZGVycykpIHtcbiAgICBvcHRpb25zLmhlYWRlcnMgPSB7fTtcbiAgfVxuICBvcHRpb25zLmhlYWRlcnMuQXV0aG9yaXphdGlvbiA9IFwiQmVhcmVyIFwiICsgdGhpcy5faW9uRW5kcG9pbnQuYWNjZXNzVG9rZW47XG5cbiAgcmV0dXJuIFJlc291cmNlLnByb3RvdHlwZS5fbWFrZVJlcXVlc3QuY2FsbCh0aGlzLCBvcHRpb25zKTtcbn07XG5cbi8qKlxuICogQHByaXZhdGVcbiAqL1xuSW9uUmVzb3VyY2UuX2NyZWF0ZUVuZHBvaW50UmVzb3VyY2UgPSBmdW5jdGlvbiAoYXNzZXRJZCwgb3B0aW9ucykge1xuICAvLz4+aW5jbHVkZVN0YXJ0KCdkZWJ1ZycsIHByYWdtYXMuZGVidWcpO1xuICBDaGVjay5kZWZpbmVkKFwiYXNzZXRJZFwiLCBhc3NldElkKTtcbiAgLy8+PmluY2x1ZGVFbmQoJ2RlYnVnJyk7XG5cbiAgb3B0aW9ucyA9IGRlZmF1bHRWYWx1ZShvcHRpb25zLCBkZWZhdWx0VmFsdWUuRU1QVFlfT0JKRUNUKTtcbiAgdmFyIHNlcnZlciA9IGRlZmF1bHRWYWx1ZShvcHRpb25zLnNlcnZlciwgSW9uLmRlZmF1bHRTZXJ2ZXIpO1xuICB2YXIgYWNjZXNzVG9rZW4gPSBkZWZhdWx0VmFsdWUob3B0aW9ucy5hY2Nlc3NUb2tlbiwgSW9uLmRlZmF1bHRBY2Nlc3NUb2tlbik7XG4gIHNlcnZlciA9IFJlc291cmNlLmNyZWF0ZUlmTmVlZGVkKHNlcnZlcik7XG5cbiAgdmFyIHJlc291cmNlT3B0aW9ucyA9IHtcbiAgICB1cmw6IFwidjEvYXNzZXRzL1wiICsgYXNzZXRJZCArIFwiL2VuZHBvaW50XCIsXG4gIH07XG5cbiAgaWYgKGRlZmluZWQoYWNjZXNzVG9rZW4pKSB7XG4gICAgcmVzb3VyY2VPcHRpb25zLnF1ZXJ5UGFyYW1ldGVycyA9IHsgYWNjZXNzX3Rva2VuOiBhY2Nlc3NUb2tlbiB9O1xuICB9XG5cbiAgcmV0dXJuIHNlcnZlci5nZXREZXJpdmVkUmVzb3VyY2UocmVzb3VyY2VPcHRpb25zKTtcbn07XG5cbmZ1bmN0aW9uIHJldHJ5Q2FsbGJhY2sodGhhdCwgZXJyb3IpIHtcbiAgdmFyIGlvblJvb3QgPSBkZWZhdWx0VmFsdWUodGhhdC5faW9uUm9vdCwgdGhhdCk7XG4gIHZhciBlbmRwb2ludFJlc291cmNlID0gaW9uUm9vdC5faW9uRW5kcG9pbnRSZXNvdXJjZTtcblxuICAvLyBJbWFnZSBpcyBub3QgYXZhaWxhYmxlIGluIHdvcmtlciB0aHJlYWRzLCBzbyB0aGlzIGF2b2lkc1xuICAvLyBhIFJlZmVyZW5jZUVycm9yXG4gIHZhciBpbWFnZURlZmluZWQgPSB0eXBlb2YgSW1hZ2UgIT09IFwidW5kZWZpbmVkXCI7XG5cbiAgLy8gV2Ugb25seSB3YW50IHRvIHJldHJ5IGluIHRoZSBjYXNlIG9mIGludmFsaWQgY3JlZGVudGlhbHMgKDQwMSkgb3IgaW1hZ2VcbiAgLy8gcmVxdWVzdHMoc2luY2UgSW1hZ2UgZmFpbHVyZXMgY2FuIG5vdCBwcm92aWRlIGEgc3RhdHVzIGNvZGUpXG4gIGlmIChcbiAgICAhZGVmaW5lZChlcnJvcikgfHxcbiAgICAoZXJyb3Iuc3RhdHVzQ29kZSAhPT0gNDAxICYmXG4gICAgICAhKGltYWdlRGVmaW5lZCAmJiBlcnJvci50YXJnZXQgaW5zdGFuY2VvZiBJbWFnZSkpXG4gICkge1xuICAgIHJldHVybiB3aGVuLnJlc29sdmUoZmFsc2UpO1xuICB9XG5cbiAgLy8gV2UgdXNlIGEgc2hhcmVkIHBlbmRpbmcgcHJvbWlzZSBmb3IgYWxsIGRlcml2ZWQgYXNzZXRzLCBzaW5jZSB0aGV5IHNoYXJlXG4gIC8vIGEgY29tbW9uIGFjY2Vzc190b2tlbi4gIElmIHdlJ3JlIGFscmVhZHkgcmVxdWVzdGluZyBhIG5ldyB0b2tlbiBmb3IgdGhpc1xuICAvLyBhc3NldCwgd2Ugd2FpdCBvbiB0aGUgc2FtZSBwcm9taXNlLlxuICBpZiAoIWRlZmluZWQoaW9uUm9vdC5fcGVuZGluZ1Byb21pc2UpKSB7XG4gICAgaW9uUm9vdC5fcGVuZGluZ1Byb21pc2UgPSBlbmRwb2ludFJlc291cmNlXG4gICAgICAuZmV0Y2hKc29uKClcbiAgICAgIC50aGVuKGZ1bmN0aW9uIChuZXdFbmRwb2ludCkge1xuICAgICAgICAvL1NldCB0aGUgdG9rZW4gZm9yIHJvb3QgcmVzb3VyY2Ugc28gbmV3IGRlcml2ZWQgcmVzb3VyY2VzIGF1dG9tYXRpY2FsbHkgcGljayBpdCB1cFxuICAgICAgICBpb25Sb290Ll9pb25FbmRwb2ludCA9IG5ld0VuZHBvaW50O1xuICAgICAgICByZXR1cm4gbmV3RW5kcG9pbnQ7XG4gICAgICB9KVxuICAgICAgLmFsd2F5cyhmdW5jdGlvbiAobmV3RW5kcG9pbnQpIHtcbiAgICAgICAgLy8gUGFzcyBvciBmYWlsLCB3ZSdyZSBkb25lIHdpdGggdGhpcyBwcm9taXNlLCB0aGUgbmV4dCBmYWlsdXJlIHNob3VsZCB1c2UgYSBuZXcgb25lLlxuICAgICAgICBpb25Sb290Ll9wZW5kaW5nUHJvbWlzZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgcmV0dXJuIG5ld0VuZHBvaW50O1xuICAgICAgfSk7XG4gIH1cblxuICByZXR1cm4gaW9uUm9vdC5fcGVuZGluZ1Byb21pc2UudGhlbihmdW5jdGlvbiAobmV3RW5kcG9pbnQpIHtcbiAgICAvLyBTZXQgdGhlIG5ldyB0b2tlbiBhbmQgZW5kcG9pbnQgZm9yIHRoaXMgcmVzb3VyY2VcbiAgICB0aGF0Ll9pb25FbmRwb2ludCA9IG5ld0VuZHBvaW50O1xuICAgIHJldHVybiB0cnVlO1xuICB9KTtcbn1cbmV4cG9ydCBkZWZhdWx0IElvblJlc291cmNlO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///48604\n')},22841:function(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__){eval('/* harmony import */ var _JulianDate_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(55293);\n/* harmony import */ var _TimeInterval_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(77808);\n\n\n\nvar MINIMUM_VALUE = Object.freeze(\n  _JulianDate_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].fromIso8601 */ .Z.fromIso8601("0000-01-01T00:00:00Z")\n);\nvar MAXIMUM_VALUE = Object.freeze(\n  _JulianDate_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].fromIso8601 */ .Z.fromIso8601("9999-12-31T24:00:00Z")\n);\nvar MAXIMUM_INTERVAL = Object.freeze(\n  new _TimeInterval_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .Z({\n    start: MINIMUM_VALUE,\n    stop: MAXIMUM_VALUE,\n  })\n);\n\n/**\n * Constants related to ISO8601 support.\n *\n * @namespace\n *\n * @see {@link http://en.wikipedia.org/wiki/ISO_8601|ISO 8601 on Wikipedia}\n * @see JulianDate\n * @see TimeInterval\n */\nvar Iso8601 = {\n  /**\n   * A {@link JulianDate} representing the earliest time representable by an ISO8601 date.\n   * This is equivalent to the date string \'0000-01-01T00:00:00Z\'\n   *\n   * @type {JulianDate}\n   * @constant\n   */\n  MINIMUM_VALUE: MINIMUM_VALUE,\n\n  /**\n   * A {@link JulianDate} representing the latest time representable by an ISO8601 date.\n   * This is equivalent to the date string \'9999-12-31T24:00:00Z\'\n   *\n   * @type {JulianDate}\n   * @constant\n   */\n  MAXIMUM_VALUE: MAXIMUM_VALUE,\n\n  /**\n   * A {@link TimeInterval} representing the largest interval representable by an ISO8601 interval.\n   * This is equivalent to the interval string \'0000-01-01T00:00:00Z/9999-12-31T24:00:00Z\'\n   *\n   * @type {JulianDate}\n   * @constant\n   */\n  MAXIMUM_INTERVAL: MAXIMUM_INTERVAL,\n};\n/* harmony default export */ __webpack_exports__["Z"] = (Iso8601);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjI4NDEuanMiLCJtYXBwaW5ncyI6Ijs7QUFBeUM7QUFDSTs7QUFFN0M7QUFDQSxFQUFFLHVGQUFzQjtBQUN4QjtBQUNBO0FBQ0EsRUFBRSx1RkFBc0I7QUFDeEI7QUFDQTtBQUNBLE1BQU0saUVBQVk7QUFDbEI7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLGtCQUFrQjtBQUMxQjtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFFBQVEsa0JBQWtCO0FBQzFCO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBOztBQUVBO0FBQ0EsUUFBUSxvQkFBb0I7QUFDNUI7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlEQUFlLE9BQU8sRUFBQyIsInNvdXJjZXMiOlsid2VicGFjazovL3Z1ZTMtd2VicGFjazUvLi9ub2RlX21vZHVsZXMvY2VzaXVtL1NvdXJjZS9Db3JlL0lzbzg2MDEuanM/MDRhOCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgSnVsaWFuRGF0ZSBmcm9tIFwiLi9KdWxpYW5EYXRlLmpzXCI7XG5pbXBvcnQgVGltZUludGVydmFsIGZyb20gXCIuL1RpbWVJbnRlcnZhbC5qc1wiO1xuXG52YXIgTUlOSU1VTV9WQUxVRSA9IE9iamVjdC5mcmVlemUoXG4gIEp1bGlhbkRhdGUuZnJvbUlzbzg2MDEoXCIwMDAwLTAxLTAxVDAwOjAwOjAwWlwiKVxuKTtcbnZhciBNQVhJTVVNX1ZBTFVFID0gT2JqZWN0LmZyZWV6ZShcbiAgSnVsaWFuRGF0ZS5mcm9tSXNvODYwMShcIjk5OTktMTItMzFUMjQ6MDA6MDBaXCIpXG4pO1xudmFyIE1BWElNVU1fSU5URVJWQUwgPSBPYmplY3QuZnJlZXplKFxuICBuZXcgVGltZUludGVydmFsKHtcbiAgICBzdGFydDogTUlOSU1VTV9WQUxVRSxcbiAgICBzdG9wOiBNQVhJTVVNX1ZBTFVFLFxuICB9KVxuKTtcblxuLyoqXG4gKiBDb25zdGFudHMgcmVsYXRlZCB0byBJU084NjAxIHN1cHBvcnQuXG4gKlxuICogQG5hbWVzcGFjZVxuICpcbiAqIEBzZWUge0BsaW5rIGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvSVNPXzg2MDF8SVNPIDg2MDEgb24gV2lraXBlZGlhfVxuICogQHNlZSBKdWxpYW5EYXRlXG4gKiBAc2VlIFRpbWVJbnRlcnZhbFxuICovXG52YXIgSXNvODYwMSA9IHtcbiAgLyoqXG4gICAqIEEge0BsaW5rIEp1bGlhbkRhdGV9IHJlcHJlc2VudGluZyB0aGUgZWFybGllc3QgdGltZSByZXByZXNlbnRhYmxlIGJ5IGFuIElTTzg2MDEgZGF0ZS5cbiAgICogVGhpcyBpcyBlcXVpdmFsZW50IHRvIHRoZSBkYXRlIHN0cmluZyAnMDAwMC0wMS0wMVQwMDowMDowMFonXG4gICAqXG4gICAqIEB0eXBlIHtKdWxpYW5EYXRlfVxuICAgKiBAY29uc3RhbnRcbiAgICovXG4gIE1JTklNVU1fVkFMVUU6IE1JTklNVU1fVkFMVUUsXG5cbiAgLyoqXG4gICAqIEEge0BsaW5rIEp1bGlhbkRhdGV9IHJlcHJlc2VudGluZyB0aGUgbGF0ZXN0IHRpbWUgcmVwcmVzZW50YWJsZSBieSBhbiBJU084NjAxIGRhdGUuXG4gICAqIFRoaXMgaXMgZXF1aXZhbGVudCB0byB0aGUgZGF0ZSBzdHJpbmcgJzk5OTktMTItMzFUMjQ6MDA6MDBaJ1xuICAgKlxuICAgKiBAdHlwZSB7SnVsaWFuRGF0ZX1cbiAgICogQGNvbnN0YW50XG4gICAqL1xuICBNQVhJTVVNX1ZBTFVFOiBNQVhJTVVNX1ZBTFVFLFxuXG4gIC8qKlxuICAgKiBBIHtAbGluayBUaW1lSW50ZXJ2YWx9IHJlcHJlc2VudGluZyB0aGUgbGFyZ2VzdCBpbnRlcnZhbCByZXByZXNlbnRhYmxlIGJ5IGFuIElTTzg2MDEgaW50ZXJ2YWwuXG4gICAqIFRoaXMgaXMgZXF1aXZhbGVudCB0byB0aGUgaW50ZXJ2YWwgc3RyaW5nICcwMDAwLTAxLTAxVDAwOjAwOjAwWi85OTk5LTEyLTMxVDI0OjAwOjAwWidcbiAgICpcbiAgICogQHR5cGUge0p1bGlhbkRhdGV9XG4gICAqIEBjb25zdGFudFxuICAgKi9cbiAgTUFYSU1VTV9JTlRFUlZBTDogTUFYSU1VTV9JTlRFUlZBTCxcbn07XG5leHBvcnQgZGVmYXVsdCBJc284NjAxO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///22841\n')},55293:function(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__){eval('/* harmony import */ var _binarySearch_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(377);\n/* harmony import */ var _defaultValue_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(62200);\n/* harmony import */ var _defined_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(82982);\n/* harmony import */ var _DeveloperError_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(12572);\n/* harmony import */ var _GregorianDate_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(98648);\n/* harmony import */ var _isLeapYear_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(55706);\n/* harmony import */ var _LeapSecond_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(52409);\n/* harmony import */ var _TimeConstants_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(4877);\n/* harmony import */ var _TimeStandard_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(13098);\n\n\n\n\n\n\n\n\n\n\nvar gregorianDateScratch = new _GregorianDate_js__WEBPACK_IMPORTED_MODULE_6__/* ["default"] */ .Z();\nvar daysInMonth = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];\nvar daysInLeapFeburary = 29;\n\nfunction compareLeapSecondDates(leapSecond, dateToFind) {\n  return JulianDate.compare(leapSecond.julianDate, dateToFind.julianDate);\n}\n\n// we don\'t really need a leap second instance, anything with a julianDate property will do\nvar binarySearchScratchLeapSecond = new _LeapSecond_js__WEBPACK_IMPORTED_MODULE_7__/* ["default"] */ .Z();\n\nfunction convertUtcToTai(julianDate) {\n  //Even though julianDate is in UTC, we\'ll treat it as TAI and\n  //search the leap second table for it.\n  binarySearchScratchLeapSecond.julianDate = julianDate;\n  var leapSeconds = JulianDate.leapSeconds;\n  var index = (0,_binarySearch_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .Z)(\n    leapSeconds,\n    binarySearchScratchLeapSecond,\n    compareLeapSecondDates\n  );\n\n  if (index < 0) {\n    index = ~index;\n  }\n\n  if (index >= leapSeconds.length) {\n    index = leapSeconds.length - 1;\n  }\n\n  var offset = leapSeconds[index].offset;\n  if (index > 0) {\n    //Now we have the index of the closest leap second that comes on or after our UTC time.\n    //However, if the difference between the UTC date being converted and the TAI\n    //defined leap second is greater than the offset, we are off by one and need to use\n    //the previous leap second.\n    var difference = JulianDate.secondsDifference(\n      leapSeconds[index].julianDate,\n      julianDate\n    );\n    if (difference > offset) {\n      index--;\n      offset = leapSeconds[index].offset;\n    }\n  }\n\n  JulianDate.addSeconds(julianDate, offset, julianDate);\n}\n\nfunction convertTaiToUtc(julianDate, result) {\n  binarySearchScratchLeapSecond.julianDate = julianDate;\n  var leapSeconds = JulianDate.leapSeconds;\n  var index = (0,_binarySearch_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .Z)(\n    leapSeconds,\n    binarySearchScratchLeapSecond,\n    compareLeapSecondDates\n  );\n  if (index < 0) {\n    index = ~index;\n  }\n\n  //All times before our first leap second get the first offset.\n  if (index === 0) {\n    return JulianDate.addSeconds(julianDate, -leapSeconds[0].offset, result);\n  }\n\n  //All times after our leap second get the last offset.\n  if (index >= leapSeconds.length) {\n    return JulianDate.addSeconds(\n      julianDate,\n      -leapSeconds[index - 1].offset,\n      result\n    );\n  }\n\n  //Compute the difference between the found leap second and the time we are converting.\n  var difference = JulianDate.secondsDifference(\n    leapSeconds[index].julianDate,\n    julianDate\n  );\n\n  if (difference === 0) {\n    //The date is in our leap second table.\n    return JulianDate.addSeconds(\n      julianDate,\n      -leapSeconds[index].offset,\n      result\n    );\n  }\n\n  if (difference <= 1.0) {\n    //The requested date is during the moment of a leap second, then we cannot convert to UTC\n    return undefined;\n  }\n\n  //The time is in between two leap seconds, index is the leap second after the date\n  //we\'re converting, so we subtract one to get the correct LeapSecond instance.\n  return JulianDate.addSeconds(\n    julianDate,\n    -leapSeconds[--index].offset,\n    result\n  );\n}\n\nfunction setComponents(wholeDays, secondsOfDay, julianDate) {\n  var extraDays = (secondsOfDay / _TimeConstants_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"].SECONDS_PER_DAY */ .Z.SECONDS_PER_DAY) | 0;\n  wholeDays += extraDays;\n  secondsOfDay -= _TimeConstants_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"].SECONDS_PER_DAY */ .Z.SECONDS_PER_DAY * extraDays;\n\n  if (secondsOfDay < 0) {\n    wholeDays--;\n    secondsOfDay += _TimeConstants_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"].SECONDS_PER_DAY */ .Z.SECONDS_PER_DAY;\n  }\n\n  julianDate.dayNumber = wholeDays;\n  julianDate.secondsOfDay = secondsOfDay;\n  return julianDate;\n}\n\nfunction computeJulianDateComponents(\n  year,\n  month,\n  day,\n  hour,\n  minute,\n  second,\n  millisecond\n) {\n  // Algorithm from page 604 of the Explanatory Supplement to the\n  // Astronomical Almanac (Seidelmann 1992).\n\n  var a = ((month - 14) / 12) | 0;\n  var b = year + 4800 + a;\n  var dayNumber =\n    (((1461 * b) / 4) | 0) +\n    (((367 * (month - 2 - 12 * a)) / 12) | 0) -\n    (((3 * (((b + 100) / 100) | 0)) / 4) | 0) +\n    day -\n    32075;\n\n  // JulianDates are noon-based\n  hour = hour - 12;\n  if (hour < 0) {\n    hour += 24;\n  }\n\n  var secondsOfDay =\n    second +\n    (hour * _TimeConstants_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"].SECONDS_PER_HOUR */ .Z.SECONDS_PER_HOUR +\n      minute * _TimeConstants_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"].SECONDS_PER_MINUTE */ .Z.SECONDS_PER_MINUTE +\n      millisecond * _TimeConstants_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"].SECONDS_PER_MILLISECOND */ .Z.SECONDS_PER_MILLISECOND);\n\n  if (secondsOfDay >= 43200.0) {\n    dayNumber -= 1;\n  }\n\n  return [dayNumber, secondsOfDay];\n}\n\n//Regular expressions used for ISO8601 date parsing.\n//YYYY\nvar matchCalendarYear = /^(\\d{4})$/;\n//YYYY-MM (YYYYMM is invalid)\nvar matchCalendarMonth = /^(\\d{4})-(\\d{2})$/;\n//YYYY-DDD or YYYYDDD\nvar matchOrdinalDate = /^(\\d{4})-?(\\d{3})$/;\n//YYYY-Www or YYYYWww or YYYY-Www-D or YYYYWwwD\nvar matchWeekDate = /^(\\d{4})-?W(\\d{2})-?(\\d{1})?$/;\n//YYYY-MM-DD or YYYYMMDD\nvar matchCalendarDate = /^(\\d{4})-?(\\d{2})-?(\\d{2})$/;\n// Match utc offset\nvar utcOffset = /([Z+\\-])?(\\d{2})?:?(\\d{2})?$/;\n// Match hours HH or HH.xxxxx\nvar matchHours = /^(\\d{2})(\\.\\d+)?/.source + utcOffset.source;\n// Match hours/minutes HH:MM HHMM.xxxxx\nvar matchHoursMinutes = /^(\\d{2}):?(\\d{2})(\\.\\d+)?/.source + utcOffset.source;\n// Match hours/minutes HH:MM:SS HHMMSS.xxxxx\nvar matchHoursMinutesSeconds =\n  /^(\\d{2}):?(\\d{2}):?(\\d{2})(\\.\\d+)?/.source + utcOffset.source;\n\nvar iso8601ErrorMessage = "Invalid ISO 8601 date.";\n\n/**\n * Represents an astronomical Julian date, which is the number of days since noon on January 1, -4712 (4713 BC).\n * For increased precision, this class stores the whole number part of the date and the seconds\n * part of the date in separate components.  In order to be safe for arithmetic and represent\n * leap seconds, the date is always stored in the International Atomic Time standard\n * {@link TimeStandard.TAI}.\n * @alias JulianDate\n * @constructor\n *\n * @param {Number} [julianDayNumber=0.0] The Julian Day Number representing the number of whole days.  Fractional days will also be handled correctly.\n * @param {Number} [secondsOfDay=0.0] The number of seconds into the current Julian Day Number.  Fractional seconds, negative seconds and seconds greater than a day will be handled correctly.\n * @param {TimeStandard} [timeStandard=TimeStandard.UTC] The time standard in which the first two parameters are defined.\n */\nfunction JulianDate(julianDayNumber, secondsOfDay, timeStandard) {\n  /**\n   * Gets or sets the number of whole days.\n   * @type {Number}\n   */\n  this.dayNumber = undefined;\n\n  /**\n   * Gets or sets the number of seconds into the current day.\n   * @type {Number}\n   */\n  this.secondsOfDay = undefined;\n\n  julianDayNumber = (0,_defaultValue_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .Z)(julianDayNumber, 0.0);\n  secondsOfDay = (0,_defaultValue_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .Z)(secondsOfDay, 0.0);\n  timeStandard = (0,_defaultValue_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .Z)(timeStandard, _TimeStandard_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"].UTC */ .Z.UTC);\n\n  //If julianDayNumber is fractional, make it an integer and add the number of seconds the fraction represented.\n  var wholeDays = julianDayNumber | 0;\n  secondsOfDay =\n    secondsOfDay +\n    (julianDayNumber - wholeDays) * _TimeConstants_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"].SECONDS_PER_DAY */ .Z.SECONDS_PER_DAY;\n\n  setComponents(wholeDays, secondsOfDay, this);\n\n  if (timeStandard === _TimeStandard_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"].UTC */ .Z.UTC) {\n    convertUtcToTai(this);\n  }\n}\n\n/**\n * Creates a new instance from a GregorianDate.\n *\n * @param {GregorianDate} date A GregorianDate.\n * @param {JulianDate} [result] An existing instance to use for the result.\n * @returns {JulianDate} The modified result parameter or a new instance if none was provided.\n *\n * @exception {DeveloperError} date must be a valid GregorianDate.\n */\nJulianDate.fromGregorianDate = function (date, result) {\n  //>>includeStart(\'debug\', pragmas.debug);\n  if (!(date instanceof _GregorianDate_js__WEBPACK_IMPORTED_MODULE_6__/* ["default"] */ .Z)) {\n    throw new _DeveloperError_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"] */ .Z("date must be a valid GregorianDate.");\n  }\n  //>>includeEnd(\'debug\');\n\n  var components = computeJulianDateComponents(\n    date.year,\n    date.month,\n    date.day,\n    date.hour,\n    date.minute,\n    date.second,\n    date.millisecond\n  );\n  if (!(0,_defined_js__WEBPACK_IMPORTED_MODULE_8__/* ["default"] */ .Z)(result)) {\n    return new JulianDate(components[0], components[1], _TimeStandard_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"].UTC */ .Z.UTC);\n  }\n  setComponents(components[0], components[1], result);\n  convertUtcToTai(result);\n  return result;\n};\n\n/**\n * Creates a new instance from a JavaScript Date.\n *\n * @param {Date} date A JavaScript Date.\n * @param {JulianDate} [result] An existing instance to use for the result.\n * @returns {JulianDate} The modified result parameter or a new instance if none was provided.\n *\n * @exception {DeveloperError} date must be a valid JavaScript Date.\n */\nJulianDate.fromDate = function (date, result) {\n  //>>includeStart(\'debug\', pragmas.debug);\n  if (!(date instanceof Date) || isNaN(date.getTime())) {\n    throw new _DeveloperError_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"] */ .Z("date must be a valid JavaScript Date.");\n  }\n  //>>includeEnd(\'debug\');\n\n  var components = computeJulianDateComponents(\n    date.getUTCFullYear(),\n    date.getUTCMonth() + 1,\n    date.getUTCDate(),\n    date.getUTCHours(),\n    date.getUTCMinutes(),\n    date.getUTCSeconds(),\n    date.getUTCMilliseconds()\n  );\n  if (!(0,_defined_js__WEBPACK_IMPORTED_MODULE_8__/* ["default"] */ .Z)(result)) {\n    return new JulianDate(components[0], components[1], _TimeStandard_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"].UTC */ .Z.UTC);\n  }\n  setComponents(components[0], components[1], result);\n  convertUtcToTai(result);\n  return result;\n};\n\n/**\n * Creates a new instance from a from an {@link http://en.wikipedia.org/wiki/ISO_8601|ISO 8601} date.\n * This method is superior to <code>Date.parse</code> because it will handle all valid formats defined by the ISO 8601\n * specification, including leap seconds and sub-millisecond times, which discarded by most JavaScript implementations.\n *\n * @param {String} iso8601String An ISO 8601 date.\n * @param {JulianDate} [result] An existing instance to use for the result.\n * @returns {JulianDate} The modified result parameter or a new instance if none was provided.\n *\n * @exception {DeveloperError} Invalid ISO 8601 date.\n */\nJulianDate.fromIso8601 = function (iso8601String, result) {\n  //>>includeStart(\'debug\', pragmas.debug);\n  if (typeof iso8601String !== "string") {\n    throw new _DeveloperError_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"] */ .Z(iso8601ErrorMessage);\n  }\n  //>>includeEnd(\'debug\');\n\n  //Comma and decimal point both indicate a fractional number according to ISO 8601,\n  //start out by blanket replacing , with . which is the only valid such symbol in JS.\n  iso8601String = iso8601String.replace(",", ".");\n\n  //Split the string into its date and time components, denoted by a mandatory T\n  var tokens = iso8601String.split("T");\n  var year;\n  var month = 1;\n  var day = 1;\n  var hour = 0;\n  var minute = 0;\n  var second = 0;\n  var millisecond = 0;\n\n  //Lacking a time is okay, but a missing date is illegal.\n  var date = tokens[0];\n  var time = tokens[1];\n  var tmp;\n  var inLeapYear;\n  //>>includeStart(\'debug\', pragmas.debug);\n  if (!(0,_defined_js__WEBPACK_IMPORTED_MODULE_8__/* ["default"] */ .Z)(date)) {\n    throw new _DeveloperError_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"] */ .Z(iso8601ErrorMessage);\n  }\n\n  var dashCount;\n  //>>includeEnd(\'debug\');\n\n  //First match the date against possible regular expressions.\n  tokens = date.match(matchCalendarDate);\n  if (tokens !== null) {\n    //>>includeStart(\'debug\', pragmas.debug);\n    dashCount = date.split("-").length - 1;\n    if (dashCount > 0 && dashCount !== 2) {\n      throw new _DeveloperError_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"] */ .Z(iso8601ErrorMessage);\n    }\n    //>>includeEnd(\'debug\');\n    year = +tokens[1];\n    month = +tokens[2];\n    day = +tokens[3];\n  } else {\n    tokens = date.match(matchCalendarMonth);\n    if (tokens !== null) {\n      year = +tokens[1];\n      month = +tokens[2];\n    } else {\n      tokens = date.match(matchCalendarYear);\n      if (tokens !== null) {\n        year = +tokens[1];\n      } else {\n        //Not a year/month/day so it must be an ordinal date.\n        var dayOfYear;\n        tokens = date.match(matchOrdinalDate);\n        if (tokens !== null) {\n          year = +tokens[1];\n          dayOfYear = +tokens[2];\n          inLeapYear = (0,_isLeapYear_js__WEBPACK_IMPORTED_MODULE_3__/* ["default"] */ .Z)(year);\n\n          //This validation is only applicable for this format.\n          //>>includeStart(\'debug\', pragmas.debug);\n          if (\n            dayOfYear < 1 ||\n            (inLeapYear && dayOfYear > 366) ||\n            (!inLeapYear && dayOfYear > 365)\n          ) {\n            throw new _DeveloperError_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"] */ .Z(iso8601ErrorMessage);\n          }\n          //>>includeEnd(\'debug\')\n        } else {\n          tokens = date.match(matchWeekDate);\n          if (tokens !== null) {\n            //ISO week date to ordinal date from\n            //http://en.wikipedia.org/w/index.php?title=ISO_week_date&oldid=474176775\n            year = +tokens[1];\n            var weekNumber = +tokens[2];\n            var dayOfWeek = +tokens[3] || 0;\n\n            //>>includeStart(\'debug\', pragmas.debug);\n            dashCount = date.split("-").length - 1;\n            if (\n              dashCount > 0 &&\n              ((!(0,_defined_js__WEBPACK_IMPORTED_MODULE_8__/* ["default"] */ .Z)(tokens[3]) && dashCount !== 1) ||\n                ((0,_defined_js__WEBPACK_IMPORTED_MODULE_8__/* ["default"] */ .Z)(tokens[3]) && dashCount !== 2))\n            ) {\n              throw new _DeveloperError_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"] */ .Z(iso8601ErrorMessage);\n            }\n            //>>includeEnd(\'debug\')\n\n            var january4 = new Date(Date.UTC(year, 0, 4));\n            dayOfYear = weekNumber * 7 + dayOfWeek - january4.getUTCDay() - 3;\n          } else {\n            //None of our regular expressions succeeded in parsing the date properly.\n            //>>includeStart(\'debug\', pragmas.debug);\n            throw new _DeveloperError_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"] */ .Z(iso8601ErrorMessage);\n            //>>includeEnd(\'debug\')\n          }\n        }\n        //Split an ordinal date into month/day.\n        tmp = new Date(Date.UTC(year, 0, 1));\n        tmp.setUTCDate(dayOfYear);\n        month = tmp.getUTCMonth() + 1;\n        day = tmp.getUTCDate();\n      }\n    }\n  }\n\n  //Now that we have all of the date components, validate them to make sure nothing is out of range.\n  inLeapYear = (0,_isLeapYear_js__WEBPACK_IMPORTED_MODULE_3__/* ["default"] */ .Z)(year);\n  //>>includeStart(\'debug\', pragmas.debug);\n  if (\n    month < 1 ||\n    month > 12 ||\n    day < 1 ||\n    ((month !== 2 || !inLeapYear) && day > daysInMonth[month - 1]) ||\n    (inLeapYear && month === 2 && day > daysInLeapFeburary)\n  ) {\n    throw new _DeveloperError_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"] */ .Z(iso8601ErrorMessage);\n  }\n  //>>includeEnd(\'debug\')\n\n  //Now move onto the time string, which is much simpler.\n  //If no time is specified, it is considered the beginning of the day, UTC to match Javascript\'s implementation.\n  var offsetIndex;\n  if ((0,_defined_js__WEBPACK_IMPORTED_MODULE_8__/* ["default"] */ .Z)(time)) {\n    tokens = time.match(matchHoursMinutesSeconds);\n    if (tokens !== null) {\n      //>>includeStart(\'debug\', pragmas.debug);\n      dashCount = time.split(":").length - 1;\n      if (dashCount > 0 && dashCount !== 2 && dashCount !== 3) {\n        throw new _DeveloperError_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"] */ .Z(iso8601ErrorMessage);\n      }\n      //>>includeEnd(\'debug\')\n\n      hour = +tokens[1];\n      minute = +tokens[2];\n      second = +tokens[3];\n      millisecond = +(tokens[4] || 0) * 1000.0;\n      offsetIndex = 5;\n    } else {\n      tokens = time.match(matchHoursMinutes);\n      if (tokens !== null) {\n        //>>includeStart(\'debug\', pragmas.debug);\n        dashCount = time.split(":").length - 1;\n        if (dashCount > 2) {\n          throw new _DeveloperError_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"] */ .Z(iso8601ErrorMessage);\n        }\n        //>>includeEnd(\'debug\')\n\n        hour = +tokens[1];\n        minute = +tokens[2];\n        second = +(tokens[3] || 0) * 60.0;\n        offsetIndex = 4;\n      } else {\n        tokens = time.match(matchHours);\n        if (tokens !== null) {\n          hour = +tokens[1];\n          minute = +(tokens[2] || 0) * 60.0;\n          offsetIndex = 3;\n        } else {\n          //>>includeStart(\'debug\', pragmas.debug);\n          throw new _DeveloperError_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"] */ .Z(iso8601ErrorMessage);\n          //>>includeEnd(\'debug\')\n        }\n      }\n    }\n\n    //Validate that all values are in proper range.  Minutes and hours have special cases at 60 and 24.\n    //>>includeStart(\'debug\', pragmas.debug);\n    if (\n      minute >= 60 ||\n      second >= 61 ||\n      hour > 24 ||\n      (hour === 24 && (minute > 0 || second > 0 || millisecond > 0))\n    ) {\n      throw new _DeveloperError_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"] */ .Z(iso8601ErrorMessage);\n    }\n    //>>includeEnd(\'debug\');\n\n    //Check the UTC offset value, if no value exists, use local time\n    //a Z indicates UTC, + or - are offsets.\n    var offset = tokens[offsetIndex];\n    var offsetHours = +tokens[offsetIndex + 1];\n    var offsetMinutes = +(tokens[offsetIndex + 2] || 0);\n    switch (offset) {\n      case "+":\n        hour = hour - offsetHours;\n        minute = minute - offsetMinutes;\n        break;\n      case "-":\n        hour = hour + offsetHours;\n        minute = minute + offsetMinutes;\n        break;\n      case "Z":\n        break;\n      default:\n        minute =\n          minute +\n          new Date(\n            Date.UTC(year, month - 1, day, hour, minute)\n          ).getTimezoneOffset();\n        break;\n    }\n  }\n\n  //ISO8601 denotes a leap second by any time having a seconds component of 60 seconds.\n  //If that\'s the case, we need to temporarily subtract a second in order to build a UTC date.\n  //Then we add it back in after converting to TAI.\n  var isLeapSecond = second === 60;\n  if (isLeapSecond) {\n    second--;\n  }\n\n  //Even if we successfully parsed the string into its components, after applying UTC offset or\n  //special cases like 24:00:00 denoting midnight, we need to normalize the data appropriately.\n\n  //milliseconds can never be greater than 1000, and seconds can\'t be above 60, so we start with minutes\n  while (minute >= 60) {\n    minute -= 60;\n    hour++;\n  }\n\n  while (hour >= 24) {\n    hour -= 24;\n    day++;\n  }\n\n  tmp = inLeapYear && month === 2 ? daysInLeapFeburary : daysInMonth[month - 1];\n  while (day > tmp) {\n    day -= tmp;\n    month++;\n\n    if (month > 12) {\n      month -= 12;\n      year++;\n    }\n\n    tmp =\n      inLeapYear && month === 2 ? daysInLeapFeburary : daysInMonth[month - 1];\n  }\n\n  //If UTC offset is at the beginning/end of the day, minutes can be negative.\n  while (minute < 0) {\n    minute += 60;\n    hour--;\n  }\n\n  while (hour < 0) {\n    hour += 24;\n    day--;\n  }\n\n  while (day < 1) {\n    month--;\n    if (month < 1) {\n      month += 12;\n      year--;\n    }\n\n    tmp =\n      inLeapYear && month === 2 ? daysInLeapFeburary : daysInMonth[month - 1];\n    day += tmp;\n  }\n\n  //Now create the JulianDate components from the Gregorian date and actually create our instance.\n  var components = computeJulianDateComponents(\n    year,\n    month,\n    day,\n    hour,\n    minute,\n    second,\n    millisecond\n  );\n\n  if (!(0,_defined_js__WEBPACK_IMPORTED_MODULE_8__/* ["default"] */ .Z)(result)) {\n    result = new JulianDate(components[0], components[1], _TimeStandard_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"].UTC */ .Z.UTC);\n  } else {\n    setComponents(components[0], components[1], result);\n    convertUtcToTai(result);\n  }\n\n  //If we were on a leap second, add it back.\n  if (isLeapSecond) {\n    JulianDate.addSeconds(result, 1, result);\n  }\n\n  return result;\n};\n\n/**\n * Creates a new instance that represents the current system time.\n * This is equivalent to calling <code>JulianDate.fromDate(new Date());</code>.\n *\n * @param {JulianDate} [result] An existing instance to use for the result.\n * @returns {JulianDate} The modified result parameter or a new instance if none was provided.\n */\nJulianDate.now = function (result) {\n  return JulianDate.fromDate(new Date(), result);\n};\n\nvar toGregorianDateScratch = new JulianDate(0, 0, _TimeStandard_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"].TAI */ .Z.TAI);\n\n/**\n * Creates a {@link GregorianDate} from the provided instance.\n *\n * @param {JulianDate} julianDate The date to be converted.\n * @param {GregorianDate} [result] An existing instance to use for the result.\n * @returns {GregorianDate} The modified result parameter or a new instance if none was provided.\n */\nJulianDate.toGregorianDate = function (julianDate, result) {\n  //>>includeStart(\'debug\', pragmas.debug);\n  if (!(0,_defined_js__WEBPACK_IMPORTED_MODULE_8__/* ["default"] */ .Z)(julianDate)) {\n    throw new _DeveloperError_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"] */ .Z("julianDate is required.");\n  }\n  //>>includeEnd(\'debug\');\n\n  var isLeapSecond = false;\n  var thisUtc = convertTaiToUtc(julianDate, toGregorianDateScratch);\n  if (!(0,_defined_js__WEBPACK_IMPORTED_MODULE_8__/* ["default"] */ .Z)(thisUtc)) {\n    //Conversion to UTC will fail if we are during a leap second.\n    //If that\'s the case, subtract a second and convert again.\n    //JavaScript doesn\'t support leap seconds, so this results in second 59 being repeated twice.\n    JulianDate.addSeconds(julianDate, -1, toGregorianDateScratch);\n    thisUtc = convertTaiToUtc(toGregorianDateScratch, toGregorianDateScratch);\n    isLeapSecond = true;\n  }\n\n  var julianDayNumber = thisUtc.dayNumber;\n  var secondsOfDay = thisUtc.secondsOfDay;\n\n  if (secondsOfDay >= 43200.0) {\n    julianDayNumber += 1;\n  }\n\n  // Algorithm from page 604 of the Explanatory Supplement to the\n  // Astronomical Almanac (Seidelmann 1992).\n  var L = (julianDayNumber + 68569) | 0;\n  var N = ((4 * L) / 146097) | 0;\n  L = (L - (((146097 * N + 3) / 4) | 0)) | 0;\n  var I = ((4000 * (L + 1)) / 1461001) | 0;\n  L = (L - (((1461 * I) / 4) | 0) + 31) | 0;\n  var J = ((80 * L) / 2447) | 0;\n  var day = (L - (((2447 * J) / 80) | 0)) | 0;\n  L = (J / 11) | 0;\n  var month = (J + 2 - 12 * L) | 0;\n  var year = (100 * (N - 49) + I + L) | 0;\n\n  var hour = (secondsOfDay / _TimeConstants_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"].SECONDS_PER_HOUR */ .Z.SECONDS_PER_HOUR) | 0;\n  var remainingSeconds = secondsOfDay - hour * _TimeConstants_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"].SECONDS_PER_HOUR */ .Z.SECONDS_PER_HOUR;\n  var minute = (remainingSeconds / _TimeConstants_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"].SECONDS_PER_MINUTE */ .Z.SECONDS_PER_MINUTE) | 0;\n  remainingSeconds =\n    remainingSeconds - minute * _TimeConstants_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"].SECONDS_PER_MINUTE */ .Z.SECONDS_PER_MINUTE;\n  var second = remainingSeconds | 0;\n  var millisecond =\n    (remainingSeconds - second) / _TimeConstants_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"].SECONDS_PER_MILLISECOND */ .Z.SECONDS_PER_MILLISECOND;\n\n  // JulianDates are noon-based\n  hour += 12;\n  if (hour > 23) {\n    hour -= 24;\n  }\n\n  //If we were on a leap second, add it back.\n  if (isLeapSecond) {\n    second += 1;\n  }\n\n  if (!(0,_defined_js__WEBPACK_IMPORTED_MODULE_8__/* ["default"] */ .Z)(result)) {\n    return new _GregorianDate_js__WEBPACK_IMPORTED_MODULE_6__/* ["default"] */ .Z(\n      year,\n      month,\n      day,\n      hour,\n      minute,\n      second,\n      millisecond,\n      isLeapSecond\n    );\n  }\n\n  result.year = year;\n  result.month = month;\n  result.day = day;\n  result.hour = hour;\n  result.minute = minute;\n  result.second = second;\n  result.millisecond = millisecond;\n  result.isLeapSecond = isLeapSecond;\n  return result;\n};\n\n/**\n * Creates a JavaScript Date from the provided instance.\n * Since JavaScript dates are only accurate to the nearest millisecond and\n * cannot represent a leap second, consider using {@link JulianDate.toGregorianDate} instead.\n * If the provided JulianDate is during a leap second, the previous second is used.\n *\n * @param {JulianDate} julianDate The date to be converted.\n * @returns {Date} A new instance representing the provided date.\n */\nJulianDate.toDate = function (julianDate) {\n  //>>includeStart(\'debug\', pragmas.debug);\n  if (!(0,_defined_js__WEBPACK_IMPORTED_MODULE_8__/* ["default"] */ .Z)(julianDate)) {\n    throw new _DeveloperError_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"] */ .Z("julianDate is required.");\n  }\n  //>>includeEnd(\'debug\');\n\n  var gDate = JulianDate.toGregorianDate(julianDate, gregorianDateScratch);\n  var second = gDate.second;\n  if (gDate.isLeapSecond) {\n    second -= 1;\n  }\n  return new Date(\n    Date.UTC(\n      gDate.year,\n      gDate.month - 1,\n      gDate.day,\n      gDate.hour,\n      gDate.minute,\n      second,\n      gDate.millisecond\n    )\n  );\n};\n\n/**\n * Creates an ISO8601 representation of the provided date.\n *\n * @param {JulianDate} julianDate The date to be converted.\n * @param {Number} [precision] The number of fractional digits used to represent the seconds component.  By default, the most precise representation is used.\n * @returns {String} The ISO8601 representation of the provided date.\n */\nJulianDate.toIso8601 = function (julianDate, precision) {\n  //>>includeStart(\'debug\', pragmas.debug);\n  if (!(0,_defined_js__WEBPACK_IMPORTED_MODULE_8__/* ["default"] */ .Z)(julianDate)) {\n    throw new _DeveloperError_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"] */ .Z("julianDate is required.");\n  }\n  //>>includeEnd(\'debug\');\n\n  var gDate = JulianDate.toGregorianDate(julianDate, gregorianDateScratch);\n  var year = gDate.year;\n  var month = gDate.month;\n  var day = gDate.day;\n  var hour = gDate.hour;\n  var minute = gDate.minute;\n  var second = gDate.second;\n  var millisecond = gDate.millisecond;\n\n  // special case - Iso8601.MAXIMUM_VALUE produces a string which we can\'t parse unless we adjust.\n  // 10000-01-01T00:00:00 is the same instant as 9999-12-31T24:00:00\n  if (\n    year === 10000 &&\n    month === 1 &&\n    day === 1 &&\n    hour === 0 &&\n    minute === 0 &&\n    second === 0 &&\n    millisecond === 0\n  ) {\n    year = 9999;\n    month = 12;\n    day = 31;\n    hour = 24;\n  }\n\n  var millisecondStr;\n\n  if (!(0,_defined_js__WEBPACK_IMPORTED_MODULE_8__/* ["default"] */ .Z)(precision) && millisecond !== 0) {\n    //Forces milliseconds into a number with at least 3 digits to whatever the default toString() precision is.\n    millisecondStr = (millisecond * 0.01).toString().replace(".", "");\n    return (\n      year.toString().padStart(4, "0") +\n      "-" +\n      month.toString().padStart(2, "0") +\n      "-" +\n      day.toString().padStart(2, "0") +\n      "T" +\n      hour.toString().padStart(2, "0") +\n      ":" +\n      minute.toString().padStart(2, "0") +\n      ":" +\n      second.toString().padStart(2, "0") +\n      "." +\n      millisecondStr +\n      "Z"\n    );\n  }\n\n  //Precision is either 0 or milliseconds is 0 with undefined precision, in either case, leave off milliseconds entirely\n  if (!(0,_defined_js__WEBPACK_IMPORTED_MODULE_8__/* ["default"] */ .Z)(precision) || precision === 0) {\n    return (\n      year.toString().padStart(4, "0") +\n      "-" +\n      month.toString().padStart(2, "0") +\n      "-" +\n      day.toString().padStart(2, "0") +\n      "T" +\n      hour.toString().padStart(2, "0") +\n      ":" +\n      minute.toString().padStart(2, "0") +\n      ":" +\n      second.toString().padStart(2, "0") +\n      "Z"\n    );\n  }\n\n  //Forces milliseconds into a number with at least 3 digits to whatever the specified precision is.\n  millisecondStr = (millisecond * 0.01)\n    .toFixed(precision)\n    .replace(".", "")\n    .slice(0, precision);\n  return (\n    year.toString().padStart(4, "0") +\n    "-" +\n    month.toString().padStart(2, "0") +\n    "-" +\n    day.toString().padStart(2, "0") +\n    "T" +\n    hour.toString().padStart(2, "0") +\n    ":" +\n    minute.toString().padStart(2, "0") +\n    ":" +\n    second.toString().padStart(2, "0") +\n    "." +\n    millisecondStr +\n    "Z"\n  );\n};\n\n/**\n * Duplicates a JulianDate instance.\n *\n * @param {JulianDate} julianDate The date to duplicate.\n * @param {JulianDate} [result] An existing instance to use for the result.\n * @returns {JulianDate} The modified result parameter or a new instance if none was provided. Returns undefined if julianDate is undefined.\n */\nJulianDate.clone = function (julianDate, result) {\n  if (!(0,_defined_js__WEBPACK_IMPORTED_MODULE_8__/* ["default"] */ .Z)(julianDate)) {\n    return undefined;\n  }\n  if (!(0,_defined_js__WEBPACK_IMPORTED_MODULE_8__/* ["default"] */ .Z)(result)) {\n    return new JulianDate(\n      julianDate.dayNumber,\n      julianDate.secondsOfDay,\n      _TimeStandard_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"].TAI */ .Z.TAI\n    );\n  }\n  result.dayNumber = julianDate.dayNumber;\n  result.secondsOfDay = julianDate.secondsOfDay;\n  return result;\n};\n\n/**\n * Compares two instances.\n *\n * @param {JulianDate} left The first instance.\n * @param {JulianDate} right The second instance.\n * @returns {Number} A negative value if left is less than right, a positive value if left is greater than right, or zero if left and right are equal.\n */\nJulianDate.compare = function (left, right) {\n  //>>includeStart(\'debug\', pragmas.debug);\n  if (!(0,_defined_js__WEBPACK_IMPORTED_MODULE_8__/* ["default"] */ .Z)(left)) {\n    throw new _DeveloperError_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"] */ .Z("left is required.");\n  }\n  if (!(0,_defined_js__WEBPACK_IMPORTED_MODULE_8__/* ["default"] */ .Z)(right)) {\n    throw new _DeveloperError_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"] */ .Z("right is required.");\n  }\n  //>>includeEnd(\'debug\');\n\n  var julianDayNumberDifference = left.dayNumber - right.dayNumber;\n  if (julianDayNumberDifference !== 0) {\n    return julianDayNumberDifference;\n  }\n  return left.secondsOfDay - right.secondsOfDay;\n};\n\n/**\n * Compares two instances and returns <code>true</code> if they are equal, <code>false</code> otherwise.\n *\n * @param {JulianDate} [left] The first instance.\n * @param {JulianDate} [right] The second instance.\n * @returns {Boolean} <code>true</code> if the dates are equal; otherwise, <code>false</code>.\n */\nJulianDate.equals = function (left, right) {\n  return (\n    left === right ||\n    ((0,_defined_js__WEBPACK_IMPORTED_MODULE_8__/* ["default"] */ .Z)(left) &&\n      (0,_defined_js__WEBPACK_IMPORTED_MODULE_8__/* ["default"] */ .Z)(right) &&\n      left.dayNumber === right.dayNumber &&\n      left.secondsOfDay === right.secondsOfDay)\n  );\n};\n\n/**\n * Compares two instances and returns <code>true</code> if they are within <code>epsilon</code> seconds of\n * each other.  That is, in order for the dates to be considered equal (and for\n * this function to return <code>true</code>), the absolute value of the difference between them, in\n * seconds, must be less than <code>epsilon</code>.\n *\n * @param {JulianDate} [left] The first instance.\n * @param {JulianDate} [right] The second instance.\n * @param {Number} [epsilon=0] The maximum number of seconds that should separate the two instances.\n * @returns {Boolean} <code>true</code> if the two dates are within <code>epsilon</code> seconds of each other; otherwise <code>false</code>.\n */\nJulianDate.equalsEpsilon = function (left, right, epsilon) {\n  epsilon = (0,_defaultValue_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .Z)(epsilon, 0);\n\n  return (\n    left === right ||\n    ((0,_defined_js__WEBPACK_IMPORTED_MODULE_8__/* ["default"] */ .Z)(left) &&\n      (0,_defined_js__WEBPACK_IMPORTED_MODULE_8__/* ["default"] */ .Z)(right) &&\n      Math.abs(JulianDate.secondsDifference(left, right)) <= epsilon)\n  );\n};\n\n/**\n * Computes the total number of whole and fractional days represented by the provided instance.\n *\n * @param {JulianDate} julianDate The date.\n * @returns {Number} The Julian date as single floating point number.\n */\nJulianDate.totalDays = function (julianDate) {\n  //>>includeStart(\'debug\', pragmas.debug);\n  if (!(0,_defined_js__WEBPACK_IMPORTED_MODULE_8__/* ["default"] */ .Z)(julianDate)) {\n    throw new _DeveloperError_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"] */ .Z("julianDate is required.");\n  }\n  //>>includeEnd(\'debug\');\n  return (\n    julianDate.dayNumber +\n    julianDate.secondsOfDay / _TimeConstants_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"].SECONDS_PER_DAY */ .Z.SECONDS_PER_DAY\n  );\n};\n\n/**\n * Computes the difference in seconds between the provided instance.\n *\n * @param {JulianDate} left The first instance.\n * @param {JulianDate} right The second instance.\n * @returns {Number} The difference, in seconds, when subtracting <code>right</code> from <code>left</code>.\n */\nJulianDate.secondsDifference = function (left, right) {\n  //>>includeStart(\'debug\', pragmas.debug);\n  if (!(0,_defined_js__WEBPACK_IMPORTED_MODULE_8__/* ["default"] */ .Z)(left)) {\n    throw new _DeveloperError_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"] */ .Z("left is required.");\n  }\n  if (!(0,_defined_js__WEBPACK_IMPORTED_MODULE_8__/* ["default"] */ .Z)(right)) {\n    throw new _DeveloperError_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"] */ .Z("right is required.");\n  }\n  //>>includeEnd(\'debug\');\n\n  var dayDifference =\n    (left.dayNumber - right.dayNumber) * _TimeConstants_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"].SECONDS_PER_DAY */ .Z.SECONDS_PER_DAY;\n  return dayDifference + (left.secondsOfDay - right.secondsOfDay);\n};\n\n/**\n * Computes the difference in days between the provided instance.\n *\n * @param {JulianDate} left The first instance.\n * @param {JulianDate} right The second instance.\n * @returns {Number} The difference, in days, when subtracting <code>right</code> from <code>left</code>.\n */\nJulianDate.daysDifference = function (left, right) {\n  //>>includeStart(\'debug\', pragmas.debug);\n  if (!(0,_defined_js__WEBPACK_IMPORTED_MODULE_8__/* ["default"] */ .Z)(left)) {\n    throw new _DeveloperError_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"] */ .Z("left is required.");\n  }\n  if (!(0,_defined_js__WEBPACK_IMPORTED_MODULE_8__/* ["default"] */ .Z)(right)) {\n    throw new _DeveloperError_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"] */ .Z("right is required.");\n  }\n  //>>includeEnd(\'debug\');\n\n  var dayDifference = left.dayNumber - right.dayNumber;\n  var secondDifference =\n    (left.secondsOfDay - right.secondsOfDay) / _TimeConstants_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"].SECONDS_PER_DAY */ .Z.SECONDS_PER_DAY;\n  return dayDifference + secondDifference;\n};\n\n/**\n * Computes the number of seconds the provided instance is ahead of UTC.\n *\n * @param {JulianDate} julianDate The date.\n * @returns {Number} The number of seconds the provided instance is ahead of UTC\n */\nJulianDate.computeTaiMinusUtc = function (julianDate) {\n  binarySearchScratchLeapSecond.julianDate = julianDate;\n  var leapSeconds = JulianDate.leapSeconds;\n  var index = (0,_binarySearch_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .Z)(\n    leapSeconds,\n    binarySearchScratchLeapSecond,\n    compareLeapSecondDates\n  );\n  if (index < 0) {\n    index = ~index;\n    --index;\n    if (index < 0) {\n      index = 0;\n    }\n  }\n  return leapSeconds[index].offset;\n};\n\n/**\n * Adds the provided number of seconds to the provided date instance.\n *\n * @param {JulianDate} julianDate The date.\n * @param {Number} seconds The number of seconds to add or subtract.\n * @param {JulianDate} result An existing instance to use for the result.\n * @returns {JulianDate} The modified result parameter.\n */\nJulianDate.addSeconds = function (julianDate, seconds, result) {\n  //>>includeStart(\'debug\', pragmas.debug);\n  if (!(0,_defined_js__WEBPACK_IMPORTED_MODULE_8__/* ["default"] */ .Z)(julianDate)) {\n    throw new _DeveloperError_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"] */ .Z("julianDate is required.");\n  }\n  if (!(0,_defined_js__WEBPACK_IMPORTED_MODULE_8__/* ["default"] */ .Z)(seconds)) {\n    throw new _DeveloperError_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"] */ .Z("seconds is required.");\n  }\n  if (!(0,_defined_js__WEBPACK_IMPORTED_MODULE_8__/* ["default"] */ .Z)(result)) {\n    throw new _DeveloperError_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"] */ .Z("result is required.");\n  }\n  //>>includeEnd(\'debug\');\n\n  return setComponents(\n    julianDate.dayNumber,\n    julianDate.secondsOfDay + seconds,\n    result\n  );\n};\n\n/**\n * Adds the provided number of minutes to the provided date instance.\n *\n * @param {JulianDate} julianDate The date.\n * @param {Number} minutes The number of minutes to add or subtract.\n * @param {JulianDate} result An existing instance to use for the result.\n * @returns {JulianDate} The modified result parameter.\n */\nJulianDate.addMinutes = function (julianDate, minutes, result) {\n  //>>includeStart(\'debug\', pragmas.debug);\n  if (!(0,_defined_js__WEBPACK_IMPORTED_MODULE_8__/* ["default"] */ .Z)(julianDate)) {\n    throw new _DeveloperError_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"] */ .Z("julianDate is required.");\n  }\n  if (!(0,_defined_js__WEBPACK_IMPORTED_MODULE_8__/* ["default"] */ .Z)(minutes)) {\n    throw new _DeveloperError_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"] */ .Z("minutes is required.");\n  }\n  if (!(0,_defined_js__WEBPACK_IMPORTED_MODULE_8__/* ["default"] */ .Z)(result)) {\n    throw new _DeveloperError_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"] */ .Z("result is required.");\n  }\n  //>>includeEnd(\'debug\');\n\n  var newSecondsOfDay =\n    julianDate.secondsOfDay + minutes * _TimeConstants_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"].SECONDS_PER_MINUTE */ .Z.SECONDS_PER_MINUTE;\n  return setComponents(julianDate.dayNumber, newSecondsOfDay, result);\n};\n\n/**\n * Adds the provided number of hours to the provided date instance.\n *\n * @param {JulianDate} julianDate The date.\n * @param {Number} hours The number of hours to add or subtract.\n * @param {JulianDate} result An existing instance to use for the result.\n * @returns {JulianDate} The modified result parameter.\n */\nJulianDate.addHours = function (julianDate, hours, result) {\n  //>>includeStart(\'debug\', pragmas.debug);\n  if (!(0,_defined_js__WEBPACK_IMPORTED_MODULE_8__/* ["default"] */ .Z)(julianDate)) {\n    throw new _DeveloperError_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"] */ .Z("julianDate is required.");\n  }\n  if (!(0,_defined_js__WEBPACK_IMPORTED_MODULE_8__/* ["default"] */ .Z)(hours)) {\n    throw new _DeveloperError_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"] */ .Z("hours is required.");\n  }\n  if (!(0,_defined_js__WEBPACK_IMPORTED_MODULE_8__/* ["default"] */ .Z)(result)) {\n    throw new _DeveloperError_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"] */ .Z("result is required.");\n  }\n  //>>includeEnd(\'debug\');\n\n  var newSecondsOfDay =\n    julianDate.secondsOfDay + hours * _TimeConstants_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"].SECONDS_PER_HOUR */ .Z.SECONDS_PER_HOUR;\n  return setComponents(julianDate.dayNumber, newSecondsOfDay, result);\n};\n\n/**\n * Adds the provided number of days to the provided date instance.\n *\n * @param {JulianDate} julianDate The date.\n * @param {Number} days The number of days to add or subtract.\n * @param {JulianDate} result An existing instance to use for the result.\n * @returns {JulianDate} The modified result parameter.\n */\nJulianDate.addDays = function (julianDate, days, result) {\n  //>>includeStart(\'debug\', pragmas.debug);\n  if (!(0,_defined_js__WEBPACK_IMPORTED_MODULE_8__/* ["default"] */ .Z)(julianDate)) {\n    throw new _DeveloperError_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"] */ .Z("julianDate is required.");\n  }\n  if (!(0,_defined_js__WEBPACK_IMPORTED_MODULE_8__/* ["default"] */ .Z)(days)) {\n    throw new _DeveloperError_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"] */ .Z("days is required.");\n  }\n  if (!(0,_defined_js__WEBPACK_IMPORTED_MODULE_8__/* ["default"] */ .Z)(result)) {\n    throw new _DeveloperError_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"] */ .Z("result is required.");\n  }\n  //>>includeEnd(\'debug\');\n\n  var newJulianDayNumber = julianDate.dayNumber + days;\n  return setComponents(newJulianDayNumber, julianDate.secondsOfDay, result);\n};\n\n/**\n * Compares the provided instances and returns <code>true</code> if <code>left</code> is earlier than <code>right</code>, <code>false</code> otherwise.\n *\n * @param {JulianDate} left The first instance.\n * @param {JulianDate} right The second instance.\n * @returns {Boolean} <code>true</code> if <code>left</code> is earlier than <code>right</code>, <code>false</code> otherwise.\n */\nJulianDate.lessThan = function (left, right) {\n  return JulianDate.compare(left, right) < 0;\n};\n\n/**\n * Compares the provided instances and returns <code>true</code> if <code>left</code> is earlier than or equal to <code>right</code>, <code>false</code> otherwise.\n *\n * @param {JulianDate} left The first instance.\n * @param {JulianDate} right The second instance.\n * @returns {Boolean} <code>true</code> if <code>left</code> is earlier than or equal to <code>right</code>, <code>false</code> otherwise.\n */\nJulianDate.lessThanOrEquals = function (left, right) {\n  return JulianDate.compare(left, right) <= 0;\n};\n\n/**\n * Compares the provided instances and returns <code>true</code> if <code>left</code> is later than <code>right</code>, <code>false</code> otherwise.\n *\n * @param {JulianDate} left The first instance.\n * @param {JulianDate} right The second instance.\n * @returns {Boolean} <code>true</code> if <code>left</code> is later than <code>right</code>, <code>false</code> otherwise.\n */\nJulianDate.greaterThan = function (left, right) {\n  return JulianDate.compare(left, right) > 0;\n};\n\n/**\n * Compares the provided instances and returns <code>true</code> if <code>left</code> is later than or equal to <code>right</code>, <code>false</code> otherwise.\n *\n * @param {JulianDate} left The first instance.\n * @param {JulianDate} right The second instance.\n * @returns {Boolean} <code>true</code> if <code>left</code> is later than or equal to <code>right</code>, <code>false</code> otherwise.\n */\nJulianDate.greaterThanOrEquals = function (left, right) {\n  return JulianDate.compare(left, right) >= 0;\n};\n\n/**\n * Duplicates this instance.\n *\n * @param {JulianDate} [result] An existing instance to use for the result.\n * @returns {JulianDate} The modified result parameter or a new instance if none was provided.\n */\nJulianDate.prototype.clone = function (result) {\n  return JulianDate.clone(this, result);\n};\n\n/**\n * Compares this and the provided instance and returns <code>true</code> if they are equal, <code>false</code> otherwise.\n *\n * @param {JulianDate} [right] The second instance.\n * @returns {Boolean} <code>true</code> if the dates are equal; otherwise, <code>false</code>.\n */\nJulianDate.prototype.equals = function (right) {\n  return JulianDate.equals(this, right);\n};\n\n/**\n * Compares this and the provided instance and returns <code>true</code> if they are within <code>epsilon</code> seconds of\n * each other.  That is, in order for the dates to be considered equal (and for\n * this function to return <code>true</code>), the absolute value of the difference between them, in\n * seconds, must be less than <code>epsilon</code>.\n *\n * @param {JulianDate} [right] The second instance.\n * @param {Number} [epsilon=0] The maximum number of seconds that should separate the two instances.\n * @returns {Boolean} <code>true</code> if the two dates are within <code>epsilon</code> seconds of each other; otherwise <code>false</code>.\n */\nJulianDate.prototype.equalsEpsilon = function (right, epsilon) {\n  return JulianDate.equalsEpsilon(this, right, epsilon);\n};\n\n/**\n * Creates a string representing this date in ISO8601 format.\n *\n * @returns {String} A string representing this date in ISO8601 format.\n */\nJulianDate.prototype.toString = function () {\n  return JulianDate.toIso8601(this);\n};\n\n/**\n * Gets or sets the list of leap seconds used throughout Cesium.\n * @memberof JulianDate\n * @type {LeapSecond[]}\n */\nJulianDate.leapSeconds = [\n  new _LeapSecond_js__WEBPACK_IMPORTED_MODULE_7__/* ["default"] */ .Z(new JulianDate(2441317, 43210.0, _TimeStandard_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"].TAI */ .Z.TAI), 10), // January 1, 1972 00:00:00 UTC\n  new _LeapSecond_js__WEBPACK_IMPORTED_MODULE_7__/* ["default"] */ .Z(new JulianDate(2441499, 43211.0, _TimeStandard_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"].TAI */ .Z.TAI), 11), // July 1, 1972 00:00:00 UTC\n  new _LeapSecond_js__WEBPACK_IMPORTED_MODULE_7__/* ["default"] */ .Z(new JulianDate(2441683, 43212.0, _TimeStandard_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"].TAI */ .Z.TAI), 12), // January 1, 1973 00:00:00 UTC\n  new _LeapSecond_js__WEBPACK_IMPORTED_MODULE_7__/* ["default"] */ .Z(new JulianDate(2442048, 43213.0, _TimeStandard_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"].TAI */ .Z.TAI), 13), // January 1, 1974 00:00:00 UTC\n  new _LeapSecond_js__WEBPACK_IMPORTED_MODULE_7__/* ["default"] */ .Z(new JulianDate(2442413, 43214.0, _TimeStandard_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"].TAI */ .Z.TAI), 14), // January 1, 1975 00:00:00 UTC\n  new _LeapSecond_js__WEBPACK_IMPORTED_MODULE_7__/* ["default"] */ .Z(new JulianDate(2442778, 43215.0, _TimeStandard_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"].TAI */ .Z.TAI), 15), // January 1, 1976 00:00:00 UTC\n  new _LeapSecond_js__WEBPACK_IMPORTED_MODULE_7__/* ["default"] */ .Z(new JulianDate(2443144, 43216.0, _TimeStandard_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"].TAI */ .Z.TAI), 16), // January 1, 1977 00:00:00 UTC\n  new _LeapSecond_js__WEBPACK_IMPORTED_MODULE_7__/* ["default"] */ .Z(new JulianDate(2443509, 43217.0, _TimeStandard_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"].TAI */ .Z.TAI), 17), // January 1, 1978 00:00:00 UTC\n  new _LeapSecond_js__WEBPACK_IMPORTED_MODULE_7__/* ["default"] */ .Z(new JulianDate(2443874, 43218.0, _TimeStandard_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"].TAI */ .Z.TAI), 18), // January 1, 1979 00:00:00 UTC\n  new _LeapSecond_js__WEBPACK_IMPORTED_MODULE_7__/* ["default"] */ .Z(new JulianDate(2444239, 43219.0, _TimeStandard_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"].TAI */ .Z.TAI), 19), // January 1, 1980 00:00:00 UTC\n  new _LeapSecond_js__WEBPACK_IMPORTED_MODULE_7__/* ["default"] */ .Z(new JulianDate(2444786, 43220.0, _TimeStandard_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"].TAI */ .Z.TAI), 20), // July 1, 1981 00:00:00 UTC\n  new _LeapSecond_js__WEBPACK_IMPORTED_MODULE_7__/* ["default"] */ .Z(new JulianDate(2445151, 43221.0, _TimeStandard_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"].TAI */ .Z.TAI), 21), // July 1, 1982 00:00:00 UTC\n  new _LeapSecond_js__WEBPACK_IMPORTED_MODULE_7__/* ["default"] */ .Z(new JulianDate(2445516, 43222.0, _TimeStandard_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"].TAI */ .Z.TAI), 22), // July 1, 1983 00:00:00 UTC\n  new _LeapSecond_js__WEBPACK_IMPORTED_MODULE_7__/* ["default"] */ .Z(new JulianDate(2446247, 43223.0, _TimeStandard_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"].TAI */ .Z.TAI), 23), // July 1, 1985 00:00:00 UTC\n  new _LeapSecond_js__WEBPACK_IMPORTED_MODULE_7__/* ["default"] */ .Z(new JulianDate(2447161, 43224.0, _TimeStandard_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"].TAI */ .Z.TAI), 24), // January 1, 1988 00:00:00 UTC\n  new _LeapSecond_js__WEBPACK_IMPORTED_MODULE_7__/* ["default"] */ .Z(new JulianDate(2447892, 43225.0, _TimeStandard_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"].TAI */ .Z.TAI), 25), // January 1, 1990 00:00:00 UTC\n  new _LeapSecond_js__WEBPACK_IMPORTED_MODULE_7__/* ["default"] */ .Z(new JulianDate(2448257, 43226.0, _TimeStandard_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"].TAI */ .Z.TAI), 26), // January 1, 1991 00:00:00 UTC\n  new _LeapSecond_js__WEBPACK_IMPORTED_MODULE_7__/* ["default"] */ .Z(new JulianDate(2448804, 43227.0, _TimeStandard_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"].TAI */ .Z.TAI), 27), // July 1, 1992 00:00:00 UTC\n  new _LeapSecond_js__WEBPACK_IMPORTED_MODULE_7__/* ["default"] */ .Z(new JulianDate(2449169, 43228.0, _TimeStandard_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"].TAI */ .Z.TAI), 28), // July 1, 1993 00:00:00 UTC\n  new _LeapSecond_js__WEBPACK_IMPORTED_MODULE_7__/* ["default"] */ .Z(new JulianDate(2449534, 43229.0, _TimeStandard_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"].TAI */ .Z.TAI), 29), // July 1, 1994 00:00:00 UTC\n  new _LeapSecond_js__WEBPACK_IMPORTED_MODULE_7__/* ["default"] */ .Z(new JulianDate(2450083, 43230.0, _TimeStandard_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"].TAI */ .Z.TAI), 30), // January 1, 1996 00:00:00 UTC\n  new _LeapSecond_js__WEBPACK_IMPORTED_MODULE_7__/* ["default"] */ .Z(new JulianDate(2450630, 43231.0, _TimeStandard_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"].TAI */ .Z.TAI), 31), // July 1, 1997 00:00:00 UTC\n  new _LeapSecond_js__WEBPACK_IMPORTED_MODULE_7__/* ["default"] */ .Z(new JulianDate(2451179, 43232.0, _TimeStandard_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"].TAI */ .Z.TAI), 32), // January 1, 1999 00:00:00 UTC\n  new _LeapSecond_js__WEBPACK_IMPORTED_MODULE_7__/* ["default"] */ .Z(new JulianDate(2453736, 43233.0, _TimeStandard_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"].TAI */ .Z.TAI), 33), // January 1, 2006 00:00:00 UTC\n  new _LeapSecond_js__WEBPACK_IMPORTED_MODULE_7__/* ["default"] */ .Z(new JulianDate(2454832, 43234.0, _TimeStandard_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"].TAI */ .Z.TAI), 34), // January 1, 2009 00:00:00 UTC\n  new _LeapSecond_js__WEBPACK_IMPORTED_MODULE_7__/* ["default"] */ .Z(new JulianDate(2456109, 43235.0, _TimeStandard_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"].TAI */ .Z.TAI), 35), // July 1, 2012 00:00:00 UTC\n  new _LeapSecond_js__WEBPACK_IMPORTED_MODULE_7__/* ["default"] */ .Z(new JulianDate(2457204, 43236.0, _TimeStandard_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"].TAI */ .Z.TAI), 36), // July 1, 2015 00:00:00 UTC\n  new _LeapSecond_js__WEBPACK_IMPORTED_MODULE_7__/* ["default"] */ .Z(new JulianDate(2457754, 43237.0, _TimeStandard_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"].TAI */ .Z.TAI), 37), // January 1, 2017 00:00:00 UTC\n];\n/* harmony default export */ __webpack_exports__["Z"] = (JulianDate);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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REFBVSxrQ0FBa0MseUVBQWdCO0FBQ2xFLE1BQU0sK0RBQVUsa0NBQWtDLHlFQUFnQjtBQUNsRSxNQUFNLCtEQUFVLGtDQUFrQyx5RUFBZ0I7QUFDbEUsTUFBTSwrREFBVSxrQ0FBa0MseUVBQWdCO0FBQ2xFLE1BQU0sK0RBQVUsa0NBQWtDLHlFQUFnQjtBQUNsRSxNQUFNLCtEQUFVLGtDQUFrQyx5RUFBZ0I7QUFDbEUsTUFBTSwrREFBVSxrQ0FBa0MseUVBQWdCO0FBQ2xFLE1BQU0sK0RBQVUsa0NBQWtDLHlFQUFnQjtBQUNsRTtBQUNBLHlEQUFlLFVBQVUsRUFBQyIsInNvdXJjZXMiOlsid2VicGFjazovL3Z1ZTMtd2VicGFjazUvLi9ub2RlX21vZHVsZXMvY2VzaXVtL1NvdXJjZS9Db3JlL0p1bGlhbkRhdGUuanM/NDViYSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgYmluYXJ5U2VhcmNoIGZyb20gXCIuL2JpbmFyeVNlYXJjaC5qc1wiO1xuaW1wb3J0IGRlZmF1bHRWYWx1ZSBmcm9tIFwiLi9kZWZhdWx0VmFsdWUuanNcIjtcbmltcG9ydCBkZWZpbmVkIGZyb20gXCIuL2RlZmluZWQuanNcIjtcbmltcG9ydCBEZXZlbG9wZXJFcnJvciBmcm9tIFwiLi9EZXZlbG9wZXJFcnJvci5qc1wiO1xuaW1wb3J0IEdyZWdvcmlhbkRhdGUgZnJvbSBcIi4vR3JlZ29yaWFuRGF0ZS5qc1wiO1xuaW1wb3J0IGlzTGVhcFllYXIgZnJvbSBcIi4vaXNMZWFwWWVhci5qc1wiO1xuaW1wb3J0IExlYXBTZWNvbmQgZnJvbSBcIi4vTGVhcFNlY29uZC5qc1wiO1xuaW1wb3J0IFRpbWVDb25zdGFudHMgZnJvbSBcIi4vVGltZUNvbnN0YW50cy5qc1wiO1xuaW1wb3J0IFRpbWVTdGFuZGFyZCBmcm9tIFwiLi9UaW1lU3RhbmRhcmQuanNcIjtcblxudmFyIGdyZWdvcmlhbkRhdGVTY3JhdGNoID0gbmV3IEdyZWdvcmlhbkRhdGUoKTtcbnZhciBkYXlzSW5Nb250aCA9IFszMSwgMjgsIDMxLCAzMCwgMzEsIDMwLCAzMSwgMzEsIDMwLCAzMSwgMzAsIDMxXTtcbnZhciBkYXlzSW5MZWFwRmVidXJhcnkgPSAyOTtcblxuZnVuY3Rpb24gY29tcGFyZUxlYXBTZWNvbmREYXRlcyhsZWFwU2Vjb25kLCBkYXRlVG9GaW5kKSB7XG4gIHJldHVybiBKdWxpYW5EYXRlLmNvbXBhcmUobGVhcFNlY29uZC5qdWxpYW5EYXRlLCBkYXRlVG9GaW5kLmp1bGlhbkRhdGUpO1xufVxuXG4vLyB3ZSBkb24ndCByZWFsbHkgbmVlZCBhIGxlYXAgc2Vjb25kIGluc3RhbmNlLCBhbnl0aGluZyB3aXRoIGEganVsaWFuRGF0ZSBwcm9wZXJ0eSB3aWxsIGRvXG52YXIgYmluYXJ5U2VhcmNoU2NyYXRjaExlYXBTZWNvbmQgPSBuZXcgTGVhcFNlY29uZCgpO1xuXG5mdW5jdGlvbiBjb252ZXJ0VXRjVG9UYWkoanVsaWFuRGF0ZSkge1xuICAvL0V2ZW4gdGhvdWdoIGp1bGlhbkRhdGUgaXMgaW4gVVRDLCB3ZSdsbCB0cmVhdCBpdCBhcyBUQUkgYW5kXG4gIC8vc2VhcmNoIHRoZSBsZWFwIHNlY29uZCB0YWJsZSBmb3IgaXQuXG4gIGJpbmFyeVNlYXJjaFNjcmF0Y2hMZWFwU2Vjb25kLmp1bGlhbkRhdGUgPSBqdWxpYW5EYXRlO1xuICB2YXIgbGVhcFNlY29uZHMgPSBKdWxpYW5EYXRlLmxlYXBTZWNvbmRzO1xuICB2YXIgaW5kZXggPSBiaW5hcnlTZWFyY2goXG4gICAgbGVhcFNlY29uZHMsXG4gICAgYmluYXJ5U2VhcmNoU2NyYXRjaExlYXBTZWNvbmQsXG4gICAgY29tcGFyZUxlYXBTZWNvbmREYXRlc1xuICApO1xuXG4gIGlmIChpbmRleCA8IDApIHtcbiAgICBpbmRleCA9IH5pbmRleDtcbiAgfVxuXG4gIGlmIChpbmRleCA+PSBsZWFwU2Vjb25kcy5sZW5ndGgpIHtcbiAgICBpbmRleCA9IGxlYXBTZWNvbmRzLmxlbmd0aCAtIDE7XG4gIH1cblxuICB2YXIgb2Zmc2V0ID0gbGVhcFNlY29uZHNbaW5kZXhdLm9mZnNldDtcbiAgaWYgKGluZGV4ID4gMCkge1xuICAgIC8vTm93IHdlIGhhdmUgdGhlIGluZGV4IG9mIHRoZSBjbG9zZXN0IGxlYXAgc2Vjb25kIHRoYXQgY29tZXMgb24gb3IgYWZ0ZXIgb3VyIFVUQyB0aW1lLlxuICAgIC8vSG93ZXZlciwgaWYgdGhlIGRpZmZlcmVuY2UgYmV0d2VlbiB0aGUgVVRDIGRhdGUgYmVpbmcgY29udmVydGVkIGFuZCB0aGUgVEFJXG4gICAgLy9kZWZpbmVkIGxlYXAgc2Vjb25kIGlzIGdyZWF0ZXIgdGhhbiB0aGUgb2Zmc2V0LCB3ZSBhcmUgb2ZmIGJ5IG9uZSBhbmQgbmVlZCB0byB1c2VcbiAgICAvL3RoZSBwcmV2aW91cyBsZWFwIHNlY29uZC5cbiAgICB2YXIgZGlmZmVyZW5jZSA9IEp1bGlhbkRhdGUuc2Vjb25kc0RpZmZlcmVuY2UoXG4gICAgICBsZWFwU2Vjb25kc1tpbmRleF0uanVsaWFuRGF0ZSxcbiAgICAgIGp1bGlhbkRhdGVcbiAgICApO1xuICAgIGlmIChkaWZmZXJlbmNlID4gb2Zmc2V0KSB7XG4gICAgICBpbmRleC0tO1xuICAgICAgb2Zmc2V0ID0gbGVhcFNlY29uZHNbaW5kZXhdLm9mZnNldDtcbiAgICB9XG4gIH1cblxuICBKdWxpYW5EYXRlLmFkZFNlY29uZHMoanVsaWFuRGF0ZSwgb2Zmc2V0LCBqdWxpYW5EYXRlKTtcbn1cblxuZnVuY3Rpb24gY29udmVydFRhaVRvVXRjKGp1bGlhbkRhdGUsIHJlc3VsdCkge1xuICBiaW5hcnlTZWFyY2hTY3JhdGNoTGVhcFNlY29uZC5qdWxpYW5EYXRlID0ganVsaWFuRGF0ZTtcbiAgdmFyIGxlYXBTZWNvbmRzID0gSnVsaWFuRGF0ZS5sZWFwU2Vjb25kcztcbiAgdmFyIGluZGV4ID0gYmluYXJ5U2VhcmNoKFxuICAgIGxlYXBTZWNvbmRzLFxuICAgIGJpbmFyeVNlYXJjaFNjcmF0Y2hMZWFwU2Vjb25kLFxuICAgIGNvbXBhcmVMZWFwU2Vjb25kRGF0ZXNcbiAgKTtcbiAgaWYgKGluZGV4IDwgMCkge1xuICAgIGluZGV4ID0gfmluZGV4O1xuICB9XG5cbiAgLy9BbGwgdGltZXMgYmVmb3JlIG91ciBmaXJzdCBsZWFwIHNlY29uZCBnZXQgdGhlIGZpcnN0IG9mZnNldC5cbiAgaWYgKGluZGV4ID09PSAwKSB7XG4gICAgcmV0dXJuIEp1bGlhbkRhdGUuYWRkU2Vjb25kcyhqdWxpYW5EYXRlLCAtbGVhcFNlY29uZHNbMF0ub2Zmc2V0LCByZXN1bHQpO1xuICB9XG5cbiAgLy9BbGwgdGltZXMgYWZ0ZXIgb3VyIGxlYXAgc2Vjb25kIGdldCB0aGUgbGFzdCBvZmZzZXQuXG4gIGlmIChpbmRleCA+PSBsZWFwU2Vjb25kcy5sZW5ndGgpIHtcbiAgICByZXR1cm4gSnVsaWFuRGF0ZS5hZGRTZWNvbmRzKFxuICAgICAganVsaWFuRGF0ZSxcbiAgICAgIC1sZWFwU2Vjb25kc1tpbmRleCAtIDFdLm9mZnNldCxcbiAgICAgIHJlc3VsdFxuICAgICk7XG4gIH1cblxuICAvL0NvbXB1dGUgdGhlIGRpZmZlcmVuY2UgYmV0d2VlbiB0aGUgZm91bmQgbGVhcCBzZWNvbmQgYW5kIHRoZSB0aW1lIHdlIGFyZSBjb252ZXJ0aW5nLlxuICB2YXIgZGlmZmVyZW5jZSA9IEp1bGlhbkRhdGUuc2Vjb25kc0RpZmZlcmVuY2UoXG4gICAgbGVhcFNlY29uZHNbaW5kZXhdLmp1bGlhbkRhdGUsXG4gICAganVsaWFuRGF0ZVxuICApO1xuXG4gIGlmIChkaWZmZXJlbmNlID09PSAwKSB7XG4gICAgLy9UaGUgZGF0ZSBpcyBpbiBvdXIgbGVhcCBzZWNvbmQgdGFibGUuXG4gICAgcmV0dXJuIEp1bGlhbkRhdGUuYWRkU2Vjb25kcyhcbiAgICAgIGp1bGlhbkRhdGUsXG4gICAgICAtbGVhcFNlY29uZHNbaW5kZXhdLm9mZnNldCxcbiAgICAgIHJlc3VsdFxuICAgICk7XG4gIH1cblxuICBpZiAoZGlmZmVyZW5jZSA8PSAxLjApIHtcbiAgICAvL1RoZSByZXF1ZXN0ZWQgZGF0ZSBpcyBkdXJpbmcgdGhlIG1vbWVudCBvZiBhIGxlYXAgc2Vjb25kLCB0aGVuIHdlIGNhbm5vdCBjb252ZXJ0IHRvIFVUQ1xuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cblxuICAvL1RoZSB0aW1lIGlzIGluIGJldHdlZW4gdHdvIGxlYXAgc2Vjb25kcywgaW5kZXggaXMgdGhlIGxlYXAgc2Vjb25kIGFmdGVyIHRoZSBkYXRlXG4gIC8vd2UncmUgY29udmVydGluZywgc28gd2Ugc3VidHJhY3Qgb25lIHRvIGdldCB0aGUgY29ycmVjdCBMZWFwU2Vjb25kIGluc3RhbmNlLlxuICByZXR1cm4gSnVsaWFuRGF0ZS5hZGRTZWNvbmRzKFxuICAgIGp1bGlhbkRhdGUsXG4gICAgLWxlYXBTZWNvbmRzWy0taW5kZXhdLm9mZnNldCxcbiAgICByZXN1bHRcbiAgKTtcbn1cblxuZnVuY3Rpb24gc2V0Q29tcG9uZW50cyh3aG9sZURheXMsIHNlY29uZHNPZkRheSwganVsaWFuRGF0ZSkge1xuICB2YXIgZXh0cmFEYXlzID0gKHNlY29uZHNPZkRheSAvIFRpbWVDb25zdGFudHMuU0VDT05EU19QRVJfREFZKSB8IDA7XG4gIHdob2xlRGF5cyArPSBleHRyYURheXM7XG4gIHNlY29uZHNPZkRheSAtPSBUaW1lQ29uc3RhbnRzLlNFQ09ORFNfUEVSX0RBWSAqIGV4dHJhRGF5cztcblxuICBpZiAoc2Vjb25kc09mRGF5IDwgMCkge1xuICAgIHdob2xlRGF5cy0tO1xuICAgIHNlY29uZHNPZkRheSArPSBUaW1lQ29uc3RhbnRzLlNFQ09ORFNfUEVSX0RBWTtcbiAgfVxuXG4gIGp1bGlhbkRhdGUuZGF5TnVtYmVyID0gd2hvbGVEYXlzO1xuICBqdWxpYW5EYXRlLnNlY29uZHNPZkRheSA9IHNlY29uZHNPZkRheTtcbiAgcmV0dXJuIGp1bGlhbkRhdGU7XG59XG5cbmZ1bmN0aW9uIGNvbXB1dGVKdWxpYW5EYXRlQ29tcG9uZW50cyhcbiAgeWVhcixcbiAgbW9udGgsXG4gIGRheSxcbiAgaG91cixcbiAgbWludXRlLFxuICBzZWNvbmQsXG4gIG1pbGxpc2Vjb25kXG4pIHtcbiAgLy8gQWxnb3JpdGhtIGZyb20gcGFnZSA2MDQgb2YgdGhlIEV4cGxhbmF0b3J5IFN1cHBsZW1lbnQgdG8gdGhlXG4gIC8vIEFzdHJvbm9taWNhbCBBbG1hbmFjIChTZWlkZWxtYW5uIDE5OTIpLlxuXG4gIHZhciBhID0gKChtb250aCAtIDE0KSAvIDEyKSB8IDA7XG4gIHZhciBiID0geWVhciArIDQ4MDAgKyBhO1xuICB2YXIgZGF5TnVtYmVyID1cbiAgICAoKCgxNDYxICogYikgLyA0KSB8IDApICtcbiAgICAoKCgzNjcgKiAobW9udGggLSAyIC0gMTIgKiBhKSkgLyAxMikgfCAwKSAtXG4gICAgKCgoMyAqICgoKGIgKyAxMDApIC8gMTAwKSB8IDApKSAvIDQpIHwgMCkgK1xuICAgIGRheSAtXG4gICAgMzIwNzU7XG5cbiAgLy8gSnVsaWFuRGF0ZXMgYXJlIG5vb24tYmFzZWRcbiAgaG91ciA9IGhvdXIgLSAxMjtcbiAgaWYgKGhvdXIgPCAwKSB7XG4gICAgaG91ciArPSAyNDtcbiAgfVxuXG4gIHZhciBzZWNvbmRzT2ZEYXkgPVxuICAgIHNlY29uZCArXG4gICAgKGhvdXIgKiBUaW1lQ29uc3RhbnRzLlNFQ09ORFNfUEVSX0hPVVIgK1xuICAgICAgbWludXRlICogVGltZUNvbnN0YW50cy5TRUNPTkRTX1BFUl9NSU5VVEUgK1xuICAgICAgbWlsbGlzZWNvbmQgKiBUaW1lQ29uc3RhbnRzLlNFQ09ORFNfUEVSX01JTExJU0VDT05EKTtcblxuICBpZiAoc2Vjb25kc09mRGF5ID49IDQzMjAwLjApIHtcbiAgICBkYXlOdW1iZXIgLT0gMTtcbiAgfVxuXG4gIHJldHVybiBbZGF5TnVtYmVyLCBzZWNvbmRzT2ZEYXldO1xufVxuXG4vL1JlZ3VsYXIgZXhwcmVzc2lvbnMgdXNlZCBmb3IgSVNPODYwMSBkYXRlIHBhcnNpbmcuXG4vL1lZWVlcbnZhciBtYXRjaENhbGVuZGFyWWVhciA9IC9eKFxcZHs0fSkkLztcbi8vWVlZWS1NTSAoWVlZWU1NIGlzIGludmFsaWQpXG52YXIgbWF0Y2hDYWxlbmRhck1vbnRoID0gL14oXFxkezR9KS0oXFxkezJ9KSQvO1xuLy9ZWVlZLURERCBvciBZWVlZREREXG52YXIgbWF0Y2hPcmRpbmFsRGF0ZSA9IC9eKFxcZHs0fSktPyhcXGR7M30pJC87XG4vL1lZWVktV3d3IG9yIFlZWVlXd3cgb3IgWVlZWS1Xd3ctRCBvciBZWVlZV3d3RFxudmFyIG1hdGNoV2Vla0RhdGUgPSAvXihcXGR7NH0pLT9XKFxcZHsyfSktPyhcXGR7MX0pPyQvO1xuLy9ZWVlZLU1NLUREIG9yIFlZWVlNTUREXG52YXIgbWF0Y2hDYWxlbmRhckRhdGUgPSAvXihcXGR7NH0pLT8oXFxkezJ9KS0/KFxcZHsyfSkkLztcbi8vIE1hdGNoIHV0YyBvZmZzZXRcbnZhciB1dGNPZmZzZXQgPSAvKFtaK1xcLV0pPyhcXGR7Mn0pPzo/KFxcZHsyfSk/JC87XG4vLyBNYXRjaCBob3VycyBISCBvciBISC54eHh4eFxudmFyIG1hdGNoSG91cnMgPSAvXihcXGR7Mn0pKFxcLlxcZCspPy8uc291cmNlICsgdXRjT2Zmc2V0LnNvdXJjZTtcbi8vIE1hdGNoIGhvdXJzL21pbnV0ZXMgSEg6TU0gSEhNTS54eHh4eFxudmFyIG1hdGNoSG91cnNNaW51dGVzID0gL14oXFxkezJ9KTo/KFxcZHsyfSkoXFwuXFxkKyk/Ly5zb3VyY2UgKyB1dGNPZmZzZXQuc291cmNlO1xuLy8gTWF0Y2ggaG91cnMvbWludXRlcyBISDpNTTpTUyBISE1NU1MueHh4eHhcbnZhciBtYXRjaEhvdXJzTWludXRlc1NlY29uZHMgPVxuICAvXihcXGR7Mn0pOj8oXFxkezJ9KTo/KFxcZHsyfSkoXFwuXFxkKyk/Ly5zb3VyY2UgKyB1dGNPZmZzZXQuc291cmNlO1xuXG52YXIgaXNvODYwMUVycm9yTWVzc2FnZSA9IFwiSW52YWxpZCBJU08gODYwMSBkYXRlLlwiO1xuXG4vKipcbiAqIFJlcHJlc2VudHMgYW4gYXN0cm9ub21pY2FsIEp1bGlhbiBkYXRlLCB3aGljaCBpcyB0aGUgbnVtYmVyIG9mIGRheXMgc2luY2Ugbm9vbiBvbiBKYW51YXJ5IDEsIC00NzEyICg0NzEzIEJDKS5cbiAqIEZvciBpbmNyZWFzZWQgcHJlY2lzaW9uLCB0aGlzIGNsYXNzIHN0b3JlcyB0aGUgd2hvbGUgbnVtYmVyIHBhcnQgb2YgdGhlIGRhdGUgYW5kIHRoZSBzZWNvbmRzXG4gKiBwYXJ0IG9mIHRoZSBkYXRlIGluIHNlcGFyYXRlIGNvbXBvbmVudHMuICBJbiBvcmRlciB0byBiZSBzYWZlIGZvciBhcml0aG1ldGljIGFuZCByZXByZXNlbnRcbiAqIGxlYXAgc2Vjb25kcywgdGhlIGRhdGUgaXMgYWx3YXlzIHN0b3JlZCBpbiB0aGUgSW50ZXJuYXRpb25hbCBBdG9taWMgVGltZSBzdGFuZGFyZFxuICoge0BsaW5rIFRpbWVTdGFuZGFyZC5UQUl9LlxuICogQGFsaWFzIEp1bGlhbkRhdGVcbiAqIEBjb25zdHJ1Y3RvclxuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSBbanVsaWFuRGF5TnVtYmVyPTAuMF0gVGhlIEp1bGlhbiBEYXkgTnVtYmVyIHJlcHJlc2VudGluZyB0aGUgbnVtYmVyIG9mIHdob2xlIGRheXMuICBGcmFjdGlvbmFsIGRheXMgd2lsbCBhbHNvIGJlIGhhbmRsZWQgY29ycmVjdGx5LlxuICogQHBhcmFtIHtOdW1iZXJ9IFtzZWNvbmRzT2ZEYXk9MC4wXSBUaGUgbnVtYmVyIG9mIHNlY29uZHMgaW50byB0aGUgY3VycmVudCBKdWxpYW4gRGF5IE51bWJlci4gIEZyYWN0aW9uYWwgc2Vjb25kcywgbmVnYXRpdmUgc2Vjb25kcyBhbmQgc2Vjb25kcyBncmVhdGVyIHRoYW4gYSBkYXkgd2lsbCBiZSBoYW5kbGVkIGNvcnJlY3RseS5cbiAqIEBwYXJhbSB7VGltZVN0YW5kYXJkfSBbdGltZVN0YW5kYXJkPVRpbWVTdGFuZGFyZC5VVENdIFRoZSB0aW1lIHN0YW5kYXJkIGluIHdoaWNoIHRoZSBmaXJzdCB0d28gcGFyYW1ldGVycyBhcmUgZGVmaW5lZC5cbiAqL1xuZnVuY3Rpb24gSnVsaWFuRGF0ZShqdWxpYW5EYXlOdW1iZXIsIHNlY29uZHNPZkRheSwgdGltZVN0YW5kYXJkKSB7XG4gIC8qKlxuICAgKiBHZXRzIG9yIHNldHMgdGhlIG51bWJlciBvZiB3aG9sZSBkYXlzLlxuICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgKi9cbiAgdGhpcy5kYXlOdW1iZXIgPSB1bmRlZmluZWQ7XG5cbiAgLyoqXG4gICAqIEdldHMgb3Igc2V0cyB0aGUgbnVtYmVyIG9mIHNlY29uZHMgaW50byB0aGUgY3VycmVudCBkYXkuXG4gICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAqL1xuICB0aGlzLnNlY29uZHNPZkRheSA9IHVuZGVmaW5lZDtcblxuICBqdWxpYW5EYXlOdW1iZXIgPSBkZWZhdWx0VmFsdWUoanVsaWFuRGF5TnVtYmVyLCAwLjApO1xuICBzZWNvbmRzT2ZEYXkgPSBkZWZhdWx0VmFsdWUoc2Vjb25kc09mRGF5LCAwLjApO1xuICB0aW1lU3RhbmRhcmQgPSBkZWZhdWx0VmFsdWUodGltZVN0YW5kYXJkLCBUaW1lU3RhbmRhcmQuVVRDKTtcblxuICAvL0lmIGp1bGlhbkRheU51bWJlciBpcyBmcmFjdGlvbmFsLCBtYWtlIGl0IGFuIGludGVnZXIgYW5kIGFkZCB0aGUgbnVtYmVyIG9mIHNlY29uZHMgdGhlIGZyYWN0aW9uIHJlcHJlc2VudGVkLlxuICB2YXIgd2hvbGVEYXlzID0ganVsaWFuRGF5TnVtYmVyIHwgMDtcbiAgc2Vjb25kc09mRGF5ID1cbiAgICBzZWNvbmRzT2ZEYXkgK1xuICAgIChqdWxpYW5EYXlOdW1iZXIgLSB3aG9sZURheXMpICogVGltZUNvbnN0YW50cy5TRUNPTkRTX1BFUl9EQVk7XG5cbiAgc2V0Q29tcG9uZW50cyh3aG9sZURheXMsIHNlY29uZHNPZkRheSwgdGhpcyk7XG5cbiAgaWYgKHRpbWVTdGFuZGFyZCA9PT0gVGltZVN0YW5kYXJkLlVUQykge1xuICAgIGNvbnZlcnRVdGNUb1RhaSh0aGlzKTtcbiAgfVxufVxuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgaW5zdGFuY2UgZnJvbSBhIEdyZWdvcmlhbkRhdGUuXG4gKlxuICogQHBhcmFtIHtHcmVnb3JpYW5EYXRlfSBkYXRlIEEgR3JlZ29yaWFuRGF0ZS5cbiAqIEBwYXJhbSB7SnVsaWFuRGF0ZX0gW3Jlc3VsdF0gQW4gZXhpc3RpbmcgaW5zdGFuY2UgdG8gdXNlIGZvciB0aGUgcmVzdWx0LlxuICogQHJldHVybnMge0p1bGlhbkRhdGV9IFRoZSBtb2RpZmllZCByZXN1bHQgcGFyYW1ldGVyIG9yIGEgbmV3IGluc3RhbmNlIGlmIG5vbmUgd2FzIHByb3ZpZGVkLlxuICpcbiAqIEBleGNlcHRpb24ge0RldmVsb3BlckVycm9yfSBkYXRlIG11c3QgYmUgYSB2YWxpZCBHcmVnb3JpYW5EYXRlLlxuICovXG5KdWxpYW5EYXRlLmZyb21HcmVnb3JpYW5EYXRlID0gZnVuY3Rpb24gKGRhdGUsIHJlc3VsdCkge1xuICAvLz4+aW5jbHVkZVN0YXJ0KCdkZWJ1ZycsIHByYWdtYXMuZGVidWcpO1xuICBpZiAoIShkYXRlIGluc3RhbmNlb2YgR3JlZ29yaWFuRGF0ZSkpIHtcbiAgICB0aHJvdyBuZXcgRGV2ZWxvcGVyRXJyb3IoXCJkYXRlIG11c3QgYmUgYSB2YWxpZCBHcmVnb3JpYW5EYXRlLlwiKTtcbiAgfVxuICAvLz4+aW5jbHVkZUVuZCgnZGVidWcnKTtcblxuICB2YXIgY29tcG9uZW50cyA9IGNvbXB1dGVKdWxpYW5EYXRlQ29tcG9uZW50cyhcbiAgICBkYXRlLnllYXIsXG4gICAgZGF0ZS5tb250aCxcbiAgICBkYXRlLmRheSxcbiAgICBkYXRlLmhvdXIsXG4gICAgZGF0ZS5taW51dGUsXG4gICAgZGF0ZS5zZWNvbmQsXG4gICAgZGF0ZS5taWxsaXNlY29uZFxuICApO1xuICBpZiAoIWRlZmluZWQocmVzdWx0KSkge1xuICAgIHJldHVybiBuZXcgSnVsaWFuRGF0ZShjb21wb25lbnRzWzBdLCBjb21wb25lbnRzWzFdLCBUaW1lU3RhbmRhcmQuVVRDKTtcbiAgfVxuICBzZXRDb21wb25lbnRzKGNvbXBvbmVudHNbMF0sIGNvbXBvbmVudHNbMV0sIHJlc3VsdCk7XG4gIGNvbnZlcnRVdGNUb1RhaShyZXN1bHQpO1xuICByZXR1cm4gcmVzdWx0O1xufTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IGluc3RhbmNlIGZyb20gYSBKYXZhU2NyaXB0IERhdGUuXG4gKlxuICogQHBhcmFtIHtEYXRlfSBkYXRlIEEgSmF2YVNjcmlwdCBEYXRlLlxuICogQHBhcmFtIHtKdWxpYW5EYXRlfSBbcmVzdWx0XSBBbiBleGlzdGluZyBpbnN0YW5jZSB0byB1c2UgZm9yIHRoZSByZXN1bHQuXG4gKiBAcmV0dXJucyB7SnVsaWFuRGF0ZX0gVGhlIG1vZGlmaWVkIHJlc3VsdCBwYXJhbWV0ZXIgb3IgYSBuZXcgaW5zdGFuY2UgaWYgbm9uZSB3YXMgcHJvdmlkZWQuXG4gKlxuICogQGV4Y2VwdGlvbiB7RGV2ZWxvcGVyRXJyb3J9IGRhdGUgbXVzdCBiZSBhIHZhbGlkIEphdmFTY3JpcHQgRGF0ZS5cbiAqL1xuSnVsaWFuRGF0ZS5mcm9tRGF0ZSA9IGZ1bmN0aW9uIChkYXRlLCByZXN1bHQpIHtcbiAgLy8+PmluY2x1ZGVTdGFydCgnZGVidWcnLCBwcmFnbWFzLmRlYnVnKTtcbiAgaWYgKCEoZGF0ZSBpbnN0YW5jZW9mIERhdGUpIHx8IGlzTmFOKGRhdGUuZ2V0VGltZSgpKSkge1xuICAgIHRocm93IG5ldyBEZXZlbG9wZXJFcnJvcihcImRhdGUgbXVzdCBiZSBhIHZhbGlkIEphdmFTY3JpcHQgRGF0ZS5cIik7XG4gIH1cbiAgLy8+PmluY2x1ZGVFbmQoJ2RlYnVnJyk7XG5cbiAgdmFyIGNvbXBvbmVudHMgPSBjb21wdXRlSnVsaWFuRGF0ZUNvbXBvbmVudHMoXG4gICAgZGF0ZS5nZXRVVENGdWxsWWVhcigpLFxuICAgIGRhdGUuZ2V0VVRDTW9udGgoKSArIDEsXG4gICAgZGF0ZS5nZXRVVENEYXRlKCksXG4gICAgZGF0ZS5nZXRVVENIb3VycygpLFxuICAgIGRhdGUuZ2V0VVRDTWludXRlcygpLFxuICAgIGRhdGUuZ2V0VVRDU2Vjb25kcygpLFxuICAgIGRhdGUuZ2V0VVRDTWlsbGlzZWNvbmRzKClcbiAgKTtcbiAgaWYgKCFkZWZpbmVkKHJlc3VsdCkpIHtcbiAgICByZXR1cm4gbmV3IEp1bGlhbkRhdGUoY29tcG9uZW50c1swXSwgY29tcG9uZW50c1sxXSwgVGltZVN0YW5kYXJkLlVUQyk7XG4gIH1cbiAgc2V0Q29tcG9uZW50cyhjb21wb25lbnRzWzBdLCBjb21wb25lbnRzWzFdLCByZXN1bHQpO1xuICBjb252ZXJ0VXRjVG9UYWkocmVzdWx0KTtcbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyBpbnN0YW5jZSBmcm9tIGEgZnJvbSBhbiB7QGxpbmsgaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9JU09fODYwMXxJU08gODYwMX0gZGF0ZS5cbiAqIFRoaXMgbWV0aG9kIGlzIHN1cGVyaW9yIHRvIDxjb2RlPkRhdGUucGFyc2U8L2NvZGU+IGJlY2F1c2UgaXQgd2lsbCBoYW5kbGUgYWxsIHZhbGlkIGZvcm1hdHMgZGVmaW5lZCBieSB0aGUgSVNPIDg2MDFcbiAqIHNwZWNpZmljYXRpb24sIGluY2x1ZGluZyBsZWFwIHNlY29uZHMgYW5kIHN1Yi1taWxsaXNlY29uZCB0aW1lcywgd2hpY2ggZGlzY2FyZGVkIGJ5IG1vc3QgSmF2YVNjcmlwdCBpbXBsZW1lbnRhdGlvbnMuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGlzbzg2MDFTdHJpbmcgQW4gSVNPIDg2MDEgZGF0ZS5cbiAqIEBwYXJhbSB7SnVsaWFuRGF0ZX0gW3Jlc3VsdF0gQW4gZXhpc3RpbmcgaW5zdGFuY2UgdG8gdXNlIGZvciB0aGUgcmVzdWx0LlxuICogQHJldHVybnMge0p1bGlhbkRhdGV9IFRoZSBtb2RpZmllZCByZXN1bHQgcGFyYW1ldGVyIG9yIGEgbmV3IGluc3RhbmNlIGlmIG5vbmUgd2FzIHByb3ZpZGVkLlxuICpcbiAqIEBleGNlcHRpb24ge0RldmVsb3BlckVycm9yfSBJbnZhbGlkIElTTyA4NjAxIGRhdGUuXG4gKi9cbkp1bGlhbkRhdGUuZnJvbUlzbzg2MDEgPSBmdW5jdGlvbiAoaXNvODYwMVN0cmluZywgcmVzdWx0KSB7XG4gIC8vPj5pbmNsdWRlU3RhcnQoJ2RlYnVnJywgcHJhZ21hcy5kZWJ1Zyk7XG4gIGlmICh0eXBlb2YgaXNvODYwMVN0cmluZyAhPT0gXCJzdHJpbmdcIikge1xuICAgIHRocm93IG5ldyBEZXZlbG9wZXJFcnJvcihpc284NjAxRXJyb3JNZXNzYWdlKTtcbiAgfVxuICAvLz4+aW5jbHVkZUVuZCgnZGVidWcnKTtcblxuICAvL0NvbW1hIGFuZCBkZWNpbWFsIHBvaW50IGJvdGggaW5kaWNhdGUgYSBmcmFjdGlvbmFsIG51bWJlciBhY2NvcmRpbmcgdG8gSVNPIDg2MDEsXG4gIC8vc3RhcnQgb3V0IGJ5IGJsYW5rZXQgcmVwbGFjaW5nICwgd2l0aCAuIHdoaWNoIGlzIHRoZSBvbmx5IHZhbGlkIHN1Y2ggc3ltYm9sIGluIEpTLlxuICBpc284NjAxU3RyaW5nID0gaXNvODYwMVN0cmluZy5yZXBsYWNlKFwiLFwiLCBcIi5cIik7XG5cbiAgLy9TcGxpdCB0aGUgc3RyaW5nIGludG8gaXRzIGRhdGUgYW5kIHRpbWUgY29tcG9uZW50cywgZGVub3RlZCBieSBhIG1hbmRhdG9yeSBUXG4gIHZhciB0b2tlbnMgPSBpc284NjAxU3RyaW5nLnNwbGl0KFwiVFwiKTtcbiAgdmFyIHllYXI7XG4gIHZhciBtb250aCA9IDE7XG4gIHZhciBkYXkgPSAxO1xuICB2YXIgaG91ciA9IDA7XG4gIHZhciBtaW51dGUgPSAwO1xuICB2YXIgc2Vjb25kID0gMDtcbiAgdmFyIG1pbGxpc2Vjb25kID0gMDtcblxuICAvL0xhY2tpbmcgYSB0aW1lIGlzIG9rYXksIGJ1dCBhIG1pc3NpbmcgZGF0ZSBpcyBpbGxlZ2FsLlxuICB2YXIgZGF0ZSA9IHRva2Vuc1swXTtcbiAgdmFyIHRpbWUgPSB0b2tlbnNbMV07XG4gIHZhciB0bXA7XG4gIHZhciBpbkxlYXBZZWFyO1xuICAvLz4+aW5jbHVkZVN0YXJ0KCdkZWJ1ZycsIHByYWdtYXMuZGVidWcpO1xuICBpZiAoIWRlZmluZWQoZGF0ZSkpIHtcbiAgICB0aHJvdyBuZXcgRGV2ZWxvcGVyRXJyb3IoaXNvODYwMUVycm9yTWVzc2FnZSk7XG4gIH1cblxuICB2YXIgZGFzaENvdW50O1xuICAvLz4+aW5jbHVkZUVuZCgnZGVidWcnKTtcblxuICAvL0ZpcnN0IG1hdGNoIHRoZSBkYXRlIGFnYWluc3QgcG9zc2libGUgcmVndWxhciBleHByZXNzaW9ucy5cbiAgdG9rZW5zID0gZGF0ZS5tYXRjaChtYXRjaENhbGVuZGFyRGF0ZSk7XG4gIGlmICh0b2tlbnMgIT09IG51bGwpIHtcbiAgICAvLz4+aW5jbHVkZVN0YXJ0KCdkZWJ1ZycsIHByYWdtYXMuZGVidWcpO1xuICAgIGRhc2hDb3VudCA9IGRhdGUuc3BsaXQoXCItXCIpLmxlbmd0aCAtIDE7XG4gICAgaWYgKGRhc2hDb3VudCA+IDAgJiYgZGFzaENvdW50ICE9PSAyKSB7XG4gICAgICB0aHJvdyBuZXcgRGV2ZWxvcGVyRXJyb3IoaXNvODYwMUVycm9yTWVzc2FnZSk7XG4gICAgfVxuICAgIC8vPj5pbmNsdWRlRW5kKCdkZWJ1ZycpO1xuICAgIHllYXIgPSArdG9rZW5zWzFdO1xuICAgIG1vbnRoID0gK3Rva2Vuc1syXTtcbiAgICBkYXkgPSArdG9rZW5zWzNdO1xuICB9IGVsc2Uge1xuICAgIHRva2VucyA9IGRhdGUubWF0Y2gobWF0Y2hDYWxlbmRhck1vbnRoKTtcbiAgICBpZiAodG9rZW5zICE9PSBudWxsKSB7XG4gICAgICB5ZWFyID0gK3Rva2Vuc1sxXTtcbiAgICAgIG1vbnRoID0gK3Rva2Vuc1syXTtcbiAgICB9IGVsc2Uge1xuICAgICAgdG9rZW5zID0gZGF0ZS5tYXRjaChtYXRjaENhbGVuZGFyWWVhcik7XG4gICAgICBpZiAodG9rZW5zICE9PSBudWxsKSB7XG4gICAgICAgIHllYXIgPSArdG9rZW5zWzFdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy9Ob3QgYSB5ZWFyL21vbnRoL2RheSBzbyBpdCBtdXN0IGJlIGFuIG9yZGluYWwgZGF0ZS5cbiAgICAgICAgdmFyIGRheU9mWWVhcjtcbiAgICAgICAgdG9rZW5zID0gZGF0ZS5tYXRjaChtYXRjaE9yZGluYWxEYXRlKTtcbiAgICAgICAgaWYgKHRva2VucyAhPT0gbnVsbCkge1xuICAgICAgICAgIHllYXIgPSArdG9rZW5zWzFdO1xuICAgICAgICAgIGRheU9mWWVhciA9ICt0b2tlbnNbMl07XG4gICAgICAgICAgaW5MZWFwWWVhciA9IGlzTGVhcFllYXIoeWVhcik7XG5cbiAgICAgICAgICAvL1RoaXMgdmFsaWRhdGlvbiBpcyBvbmx5IGFwcGxpY2FibGUgZm9yIHRoaXMgZm9ybWF0LlxuICAgICAgICAgIC8vPj5pbmNsdWRlU3RhcnQoJ2RlYnVnJywgcHJhZ21hcy5kZWJ1Zyk7XG4gICAgICAgICAgaWYgKFxuICAgICAgICAgICAgZGF5T2ZZZWFyIDwgMSB8fFxuICAgICAgICAgICAgKGluTGVhcFllYXIgJiYgZGF5T2ZZZWFyID4gMzY2KSB8fFxuICAgICAgICAgICAgKCFpbkxlYXBZZWFyICYmIGRheU9mWWVhciA+IDM2NSlcbiAgICAgICAgICApIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBEZXZlbG9wZXJFcnJvcihpc284NjAxRXJyb3JNZXNzYWdlKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgLy8+PmluY2x1ZGVFbmQoJ2RlYnVnJylcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0b2tlbnMgPSBkYXRlLm1hdGNoKG1hdGNoV2Vla0RhdGUpO1xuICAgICAgICAgIGlmICh0b2tlbnMgIT09IG51bGwpIHtcbiAgICAgICAgICAgIC8vSVNPIHdlZWsgZGF0ZSB0byBvcmRpbmFsIGRhdGUgZnJvbVxuICAgICAgICAgICAgLy9odHRwOi8vZW4ud2lraXBlZGlhLm9yZy93L2luZGV4LnBocD90aXRsZT1JU09fd2Vla19kYXRlJm9sZGlkPTQ3NDE3Njc3NVxuICAgICAgICAgICAgeWVhciA9ICt0b2tlbnNbMV07XG4gICAgICAgICAgICB2YXIgd2Vla051bWJlciA9ICt0b2tlbnNbMl07XG4gICAgICAgICAgICB2YXIgZGF5T2ZXZWVrID0gK3Rva2Vuc1szXSB8fCAwO1xuXG4gICAgICAgICAgICAvLz4+aW5jbHVkZVN0YXJ0KCdkZWJ1ZycsIHByYWdtYXMuZGVidWcpO1xuICAgICAgICAgICAgZGFzaENvdW50ID0gZGF0ZS5zcGxpdChcIi1cIikubGVuZ3RoIC0gMTtcbiAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgZGFzaENvdW50ID4gMCAmJlxuICAgICAgICAgICAgICAoKCFkZWZpbmVkKHRva2Vuc1szXSkgJiYgZGFzaENvdW50ICE9PSAxKSB8fFxuICAgICAgICAgICAgICAgIChkZWZpbmVkKHRva2Vuc1szXSkgJiYgZGFzaENvdW50ICE9PSAyKSlcbiAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICB0aHJvdyBuZXcgRGV2ZWxvcGVyRXJyb3IoaXNvODYwMUVycm9yTWVzc2FnZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLz4+aW5jbHVkZUVuZCgnZGVidWcnKVxuXG4gICAgICAgICAgICB2YXIgamFudWFyeTQgPSBuZXcgRGF0ZShEYXRlLlVUQyh5ZWFyLCAwLCA0KSk7XG4gICAgICAgICAgICBkYXlPZlllYXIgPSB3ZWVrTnVtYmVyICogNyArIGRheU9mV2VlayAtIGphbnVhcnk0LmdldFVUQ0RheSgpIC0gMztcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy9Ob25lIG9mIG91ciByZWd1bGFyIGV4cHJlc3Npb25zIHN1Y2NlZWRlZCBpbiBwYXJzaW5nIHRoZSBkYXRlIHByb3Blcmx5LlxuICAgICAgICAgICAgLy8+PmluY2x1ZGVTdGFydCgnZGVidWcnLCBwcmFnbWFzLmRlYnVnKTtcbiAgICAgICAgICAgIHRocm93IG5ldyBEZXZlbG9wZXJFcnJvcihpc284NjAxRXJyb3JNZXNzYWdlKTtcbiAgICAgICAgICAgIC8vPj5pbmNsdWRlRW5kKCdkZWJ1ZycpXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vU3BsaXQgYW4gb3JkaW5hbCBkYXRlIGludG8gbW9udGgvZGF5LlxuICAgICAgICB0bXAgPSBuZXcgRGF0ZShEYXRlLlVUQyh5ZWFyLCAwLCAxKSk7XG4gICAgICAgIHRtcC5zZXRVVENEYXRlKGRheU9mWWVhcik7XG4gICAgICAgIG1vbnRoID0gdG1wLmdldFVUQ01vbnRoKCkgKyAxO1xuICAgICAgICBkYXkgPSB0bXAuZ2V0VVRDRGF0ZSgpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8vTm93IHRoYXQgd2UgaGF2ZSBhbGwgb2YgdGhlIGRhdGUgY29tcG9uZW50cywgdmFsaWRhdGUgdGhlbSB0byBtYWtlIHN1cmUgbm90aGluZyBpcyBvdXQgb2YgcmFuZ2UuXG4gIGluTGVhcFllYXIgPSBpc0xlYXBZZWFyKHllYXIpO1xuICAvLz4+aW5jbHVkZVN0YXJ0KCdkZWJ1ZycsIHByYWdtYXMuZGVidWcpO1xuICBpZiAoXG4gICAgbW9udGggPCAxIHx8XG4gICAgbW9udGggPiAxMiB8fFxuICAgIGRheSA8IDEgfHxcbiAgICAoKG1vbnRoICE9PSAyIHx8ICFpbkxlYXBZZWFyKSAmJiBkYXkgPiBkYXlzSW5Nb250aFttb250aCAtIDFdKSB8fFxuICAgIChpbkxlYXBZZWFyICYmIG1vbnRoID09PSAyICYmIGRheSA+IGRheXNJbkxlYXBGZWJ1cmFyeSlcbiAgKSB7XG4gICAgdGhyb3cgbmV3IERldmVsb3BlckVycm9yKGlzbzg2MDFFcnJvck1lc3NhZ2UpO1xuICB9XG4gIC8vPj5pbmNsdWRlRW5kKCdkZWJ1ZycpXG5cbiAgLy9Ob3cgbW92ZSBvbnRvIHRoZSB0aW1lIHN0cmluZywgd2hpY2ggaXMgbXVjaCBzaW1wbGVyLlxuICAvL0lmIG5vIHRpbWUgaXMgc3BlY2lmaWVkLCBpdCBpcyBjb25zaWRlcmVkIHRoZSBiZWdpbm5pbmcgb2YgdGhlIGRheSwgVVRDIHRvIG1hdGNoIEphdmFzY3JpcHQncyBpbXBsZW1lbnRhdGlvbi5cbiAgdmFyIG9mZnNldEluZGV4O1xuICBpZiAoZGVmaW5lZCh0aW1lKSkge1xuICAgIHRva2VucyA9IHRpbWUubWF0Y2gobWF0Y2hIb3Vyc01pbnV0ZXNTZWNvbmRzKTtcbiAgICBpZiAodG9rZW5zICE9PSBudWxsKSB7XG4gICAgICAvLz4+aW5jbHVkZVN0YXJ0KCdkZWJ1ZycsIHByYWdtYXMuZGVidWcpO1xuICAgICAgZGFzaENvdW50ID0gdGltZS5zcGxpdChcIjpcIikubGVuZ3RoIC0gMTtcbiAgICAgIGlmIChkYXNoQ291bnQgPiAwICYmIGRhc2hDb3VudCAhPT0gMiAmJiBkYXNoQ291bnQgIT09IDMpIHtcbiAgICAgICAgdGhyb3cgbmV3IERldmVsb3BlckVycm9yKGlzbzg2MDFFcnJvck1lc3NhZ2UpO1xuICAgICAgfVxuICAgICAgLy8+PmluY2x1ZGVFbmQoJ2RlYnVnJylcblxuICAgICAgaG91ciA9ICt0b2tlbnNbMV07XG4gICAgICBtaW51dGUgPSArdG9rZW5zWzJdO1xuICAgICAgc2Vjb25kID0gK3Rva2Vuc1szXTtcbiAgICAgIG1pbGxpc2Vjb25kID0gKyh0b2tlbnNbNF0gfHwgMCkgKiAxMDAwLjA7XG4gICAgICBvZmZzZXRJbmRleCA9IDU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRva2VucyA9IHRpbWUubWF0Y2gobWF0Y2hIb3Vyc01pbnV0ZXMpO1xuICAgICAgaWYgKHRva2VucyAhPT0gbnVsbCkge1xuICAgICAgICAvLz4+aW5jbHVkZVN0YXJ0KCdkZWJ1ZycsIHByYWdtYXMuZGVidWcpO1xuICAgICAgICBkYXNoQ291bnQgPSB0aW1lLnNwbGl0KFwiOlwiKS5sZW5ndGggLSAxO1xuICAgICAgICBpZiAoZGFzaENvdW50ID4gMikge1xuICAgICAgICAgIHRocm93IG5ldyBEZXZlbG9wZXJFcnJvcihpc284NjAxRXJyb3JNZXNzYWdlKTtcbiAgICAgICAgfVxuICAgICAgICAvLz4+aW5jbHVkZUVuZCgnZGVidWcnKVxuXG4gICAgICAgIGhvdXIgPSArdG9rZW5zWzFdO1xuICAgICAgICBtaW51dGUgPSArdG9rZW5zWzJdO1xuICAgICAgICBzZWNvbmQgPSArKHRva2Vuc1szXSB8fCAwKSAqIDYwLjA7XG4gICAgICAgIG9mZnNldEluZGV4ID0gNDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRva2VucyA9IHRpbWUubWF0Y2gobWF0Y2hIb3Vycyk7XG4gICAgICAgIGlmICh0b2tlbnMgIT09IG51bGwpIHtcbiAgICAgICAgICBob3VyID0gK3Rva2Vuc1sxXTtcbiAgICAgICAgICBtaW51dGUgPSArKHRva2Vuc1syXSB8fCAwKSAqIDYwLjA7XG4gICAgICAgICAgb2Zmc2V0SW5kZXggPSAzO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vPj5pbmNsdWRlU3RhcnQoJ2RlYnVnJywgcHJhZ21hcy5kZWJ1Zyk7XG4gICAgICAgICAgdGhyb3cgbmV3IERldmVsb3BlckVycm9yKGlzbzg2MDFFcnJvck1lc3NhZ2UpO1xuICAgICAgICAgIC8vPj5pbmNsdWRlRW5kKCdkZWJ1ZycpXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvL1ZhbGlkYXRlIHRoYXQgYWxsIHZhbHVlcyBhcmUgaW4gcHJvcGVyIHJhbmdlLiAgTWludXRlcyBhbmQgaG91cnMgaGF2ZSBzcGVjaWFsIGNhc2VzIGF0IDYwIGFuZCAyNC5cbiAgICAvLz4+aW5jbHVkZVN0YXJ0KCdkZWJ1ZycsIHByYWdtYXMuZGVidWcpO1xuICAgIGlmIChcbiAgICAgIG1pbnV0ZSA+PSA2MCB8fFxuICAgICAgc2Vjb25kID49IDYxIHx8XG4gICAgICBob3VyID4gMjQgfHxcbiAgICAgIChob3VyID09PSAyNCAmJiAobWludXRlID4gMCB8fCBzZWNvbmQgPiAwIHx8IG1pbGxpc2Vjb25kID4gMCkpXG4gICAgKSB7XG4gICAgICB0aHJvdyBuZXcgRGV2ZWxvcGVyRXJyb3IoaXNvODYwMUVycm9yTWVzc2FnZSk7XG4gICAgfVxuICAgIC8vPj5pbmNsdWRlRW5kKCdkZWJ1ZycpO1xuXG4gICAgLy9DaGVjayB0aGUgVVRDIG9mZnNldCB2YWx1ZSwgaWYgbm8gdmFsdWUgZXhpc3RzLCB1c2UgbG9jYWwgdGltZVxuICAgIC8vYSBaIGluZGljYXRlcyBVVEMsICsgb3IgLSBhcmUgb2Zmc2V0cy5cbiAgICB2YXIgb2Zmc2V0ID0gdG9rZW5zW29mZnNldEluZGV4XTtcbiAgICB2YXIgb2Zmc2V0SG91cnMgPSArdG9rZW5zW29mZnNldEluZGV4ICsgMV07XG4gICAgdmFyIG9mZnNldE1pbnV0ZXMgPSArKHRva2Vuc1tvZmZzZXRJbmRleCArIDJdIHx8IDApO1xuICAgIHN3aXRjaCAob2Zmc2V0KSB7XG4gICAgICBjYXNlIFwiK1wiOlxuICAgICAgICBob3VyID0gaG91ciAtIG9mZnNldEhvdXJzO1xuICAgICAgICBtaW51dGUgPSBtaW51dGUgLSBvZmZzZXRNaW51dGVzO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCItXCI6XG4gICAgICAgIGhvdXIgPSBob3VyICsgb2Zmc2V0SG91cnM7XG4gICAgICAgIG1pbnV0ZSA9IG1pbnV0ZSArIG9mZnNldE1pbnV0ZXM7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcIlpcIjpcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICBtaW51dGUgPVxuICAgICAgICAgIG1pbnV0ZSArXG4gICAgICAgICAgbmV3IERhdGUoXG4gICAgICAgICAgICBEYXRlLlVUQyh5ZWFyLCBtb250aCAtIDEsIGRheSwgaG91ciwgbWludXRlKVxuICAgICAgICAgICkuZ2V0VGltZXpvbmVPZmZzZXQoKTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG5cbiAgLy9JU084NjAxIGRlbm90ZXMgYSBsZWFwIHNlY29uZCBieSBhbnkgdGltZSBoYXZpbmcgYSBzZWNvbmRzIGNvbXBvbmVudCBvZiA2MCBzZWNvbmRzLlxuICAvL0lmIHRoYXQncyB0aGUgY2FzZSwgd2UgbmVlZCB0byB0ZW1wb3JhcmlseSBzdWJ0cmFjdCBhIHNlY29uZCBpbiBvcmRlciB0byBidWlsZCBhIFVUQyBkYXRlLlxuICAvL1RoZW4gd2UgYWRkIGl0IGJhY2sgaW4gYWZ0ZXIgY29udmVydGluZyB0byBUQUkuXG4gIHZhciBpc0xlYXBTZWNvbmQgPSBzZWNvbmQgPT09IDYwO1xuICBpZiAoaXNMZWFwU2Vjb25kKSB7XG4gICAgc2Vjb25kLS07XG4gIH1cblxuICAvL0V2ZW4gaWYgd2Ugc3VjY2Vzc2Z1bGx5IHBhcnNlZCB0aGUgc3RyaW5nIGludG8gaXRzIGNvbXBvbmVudHMsIGFmdGVyIGFwcGx5aW5nIFVUQyBvZmZzZXQgb3JcbiAgLy9zcGVjaWFsIGNhc2VzIGxpa2UgMjQ6MDA6MDAgZGVub3RpbmcgbWlkbmlnaHQsIHdlIG5lZWQgdG8gbm9ybWFsaXplIHRoZSBkYXRhIGFwcHJvcHJpYXRlbHkuXG5cbiAgLy9taWxsaXNlY29uZHMgY2FuIG5ldmVyIGJlIGdyZWF0ZXIgdGhhbiAxMDAwLCBhbmQgc2Vjb25kcyBjYW4ndCBiZSBhYm92ZSA2MCwgc28gd2Ugc3RhcnQgd2l0aCBtaW51dGVzXG4gIHdoaWxlIChtaW51dGUgPj0gNjApIHtcbiAgICBtaW51dGUgLT0gNjA7XG4gICAgaG91cisrO1xuICB9XG5cbiAgd2hpbGUgKGhvdXIgPj0gMjQpIHtcbiAgICBob3VyIC09IDI0O1xuICAgIGRheSsrO1xuICB9XG5cbiAgdG1wID0gaW5MZWFwWWVhciAmJiBtb250aCA9PT0gMiA/IGRheXNJbkxlYXBGZWJ1cmFyeSA6IGRheXNJbk1vbnRoW21vbnRoIC0gMV07XG4gIHdoaWxlIChkYXkgPiB0bXApIHtcbiAgICBkYXkgLT0gdG1wO1xuICAgIG1vbnRoKys7XG5cbiAgICBpZiAobW9udGggPiAxMikge1xuICAgICAgbW9udGggLT0gMTI7XG4gICAgICB5ZWFyKys7XG4gICAgfVxuXG4gICAgdG1wID1cbiAgICAgIGluTGVhcFllYXIgJiYgbW9udGggPT09IDIgPyBkYXlzSW5MZWFwRmVidXJhcnkgOiBkYXlzSW5Nb250aFttb250aCAtIDFdO1xuICB9XG5cbiAgLy9JZiBVVEMgb2Zmc2V0IGlzIGF0IHRoZSBiZWdpbm5pbmcvZW5kIG9mIHRoZSBkYXksIG1pbnV0ZXMgY2FuIGJlIG5lZ2F0aXZlLlxuICB3aGlsZSAobWludXRlIDwgMCkge1xuICAgIG1pbnV0ZSArPSA2MDtcbiAgICBob3VyLS07XG4gIH1cblxuICB3aGlsZSAoaG91ciA8IDApIHtcbiAgICBob3VyICs9IDI0O1xuICAgIGRheS0tO1xuICB9XG5cbiAgd2hpbGUgKGRheSA8IDEpIHtcbiAgICBtb250aC0tO1xuICAgIGlmIChtb250aCA8IDEpIHtcbiAgICAgIG1vbnRoICs9IDEyO1xuICAgICAgeWVhci0tO1xuICAgIH1cblxuICAgIHRtcCA9XG4gICAgICBpbkxlYXBZZWFyICYmIG1vbnRoID09PSAyID8gZGF5c0luTGVhcEZlYnVyYXJ5IDogZGF5c0luTW9udGhbbW9udGggLSAxXTtcbiAgICBkYXkgKz0gdG1wO1xuICB9XG5cbiAgLy9Ob3cgY3JlYXRlIHRoZSBKdWxpYW5EYXRlIGNvbXBvbmVudHMgZnJvbSB0aGUgR3JlZ29yaWFuIGRhdGUgYW5kIGFjdHVhbGx5IGNyZWF0ZSBvdXIgaW5zdGFuY2UuXG4gIHZhciBjb21wb25lbnRzID0gY29tcHV0ZUp1bGlhbkRhdGVDb21wb25lbnRzKFxuICAgIHllYXIsXG4gICAgbW9udGgsXG4gICAgZGF5LFxuICAgIGhvdXIsXG4gICAgbWludXRlLFxuICAgIHNlY29uZCxcbiAgICBtaWxsaXNlY29uZFxuICApO1xuXG4gIGlmICghZGVmaW5lZChyZXN1bHQpKSB7XG4gICAgcmVzdWx0ID0gbmV3IEp1bGlhbkRhdGUoY29tcG9uZW50c1swXSwgY29tcG9uZW50c1sxXSwgVGltZVN0YW5kYXJkLlVUQyk7XG4gIH0gZWxzZSB7XG4gICAgc2V0Q29tcG9uZW50cyhjb21wb25lbnRzWzBdLCBjb21wb25lbnRzWzFdLCByZXN1bHQpO1xuICAgIGNvbnZlcnRVdGNUb1RhaShyZXN1bHQpO1xuICB9XG5cbiAgLy9JZiB3ZSB3ZXJlIG9uIGEgbGVhcCBzZWNvbmQsIGFkZCBpdCBiYWNrLlxuICBpZiAoaXNMZWFwU2Vjb25kKSB7XG4gICAgSnVsaWFuRGF0ZS5hZGRTZWNvbmRzKHJlc3VsdCwgMSwgcmVzdWx0KTtcbiAgfVxuXG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgaW5zdGFuY2UgdGhhdCByZXByZXNlbnRzIHRoZSBjdXJyZW50IHN5c3RlbSB0aW1lLlxuICogVGhpcyBpcyBlcXVpdmFsZW50IHRvIGNhbGxpbmcgPGNvZGU+SnVsaWFuRGF0ZS5mcm9tRGF0ZShuZXcgRGF0ZSgpKTs8L2NvZGU+LlxuICpcbiAqIEBwYXJhbSB7SnVsaWFuRGF0ZX0gW3Jlc3VsdF0gQW4gZXhpc3RpbmcgaW5zdGFuY2UgdG8gdXNlIGZvciB0aGUgcmVzdWx0LlxuICogQHJldHVybnMge0p1bGlhbkRhdGV9IFRoZSBtb2RpZmllZCByZXN1bHQgcGFyYW1ldGVyIG9yIGEgbmV3IGluc3RhbmNlIGlmIG5vbmUgd2FzIHByb3ZpZGVkLlxuICovXG5KdWxpYW5EYXRlLm5vdyA9IGZ1bmN0aW9uIChyZXN1bHQpIHtcbiAgcmV0dXJuIEp1bGlhbkRhdGUuZnJvbURhdGUobmV3IERhdGUoKSwgcmVzdWx0KTtcbn07XG5cbnZhciB0b0dyZWdvcmlhbkRhdGVTY3JhdGNoID0gbmV3IEp1bGlhbkRhdGUoMCwgMCwgVGltZVN0YW5kYXJkLlRBSSk7XG5cbi8qKlxuICogQ3JlYXRlcyBhIHtAbGluayBHcmVnb3JpYW5EYXRlfSBmcm9tIHRoZSBwcm92aWRlZCBpbnN0YW5jZS5cbiAqXG4gKiBAcGFyYW0ge0p1bGlhbkRhdGV9IGp1bGlhbkRhdGUgVGhlIGRhdGUgdG8gYmUgY29udmVydGVkLlxuICogQHBhcmFtIHtHcmVnb3JpYW5EYXRlfSBbcmVzdWx0XSBBbiBleGlzdGluZyBpbnN0YW5jZSB0byB1c2UgZm9yIHRoZSByZXN1bHQuXG4gKiBAcmV0dXJucyB7R3JlZ29yaWFuRGF0ZX0gVGhlIG1vZGlmaWVkIHJlc3VsdCBwYXJhbWV0ZXIgb3IgYSBuZXcgaW5zdGFuY2UgaWYgbm9uZSB3YXMgcHJvdmlkZWQuXG4gKi9cbkp1bGlhbkRhdGUudG9HcmVnb3JpYW5EYXRlID0gZnVuY3Rpb24gKGp1bGlhbkRhdGUsIHJlc3VsdCkge1xuICAvLz4+aW5jbHVkZVN0YXJ0KCdkZWJ1ZycsIHByYWdtYXMuZGVidWcpO1xuICBpZiAoIWRlZmluZWQoanVsaWFuRGF0ZSkpIHtcbiAgICB0aHJvdyBuZXcgRGV2ZWxvcGVyRXJyb3IoXCJqdWxpYW5EYXRlIGlzIHJlcXVpcmVkLlwiKTtcbiAgfVxuICAvLz4+aW5jbHVkZUVuZCgnZGVidWcnKTtcblxuICB2YXIgaXNMZWFwU2Vjb25kID0gZmFsc2U7XG4gIHZhciB0aGlzVXRjID0gY29udmVydFRhaVRvVXRjKGp1bGlhbkRhdGUsIHRvR3JlZ29yaWFuRGF0ZVNjcmF0Y2gpO1xuICBpZiAoIWRlZmluZWQodGhpc1V0YykpIHtcbiAgICAvL0NvbnZlcnNpb24gdG8gVVRDIHdpbGwgZmFpbCBpZiB3ZSBhcmUgZHVyaW5nIGEgbGVhcCBzZWNvbmQuXG4gICAgLy9JZiB0aGF0J3MgdGhlIGNhc2UsIHN1YnRyYWN0IGEgc2Vjb25kIGFuZCBjb252ZXJ0IGFnYWluLlxuICAgIC8vSmF2YVNjcmlwdCBkb2Vzbid0IHN1cHBvcnQgbGVhcCBzZWNvbmRzLCBzbyB0aGlzIHJlc3VsdHMgaW4gc2Vjb25kIDU5IGJlaW5nIHJlcGVhdGVkIHR3aWNlLlxuICAgIEp1bGlhbkRhdGUuYWRkU2Vjb25kcyhqdWxpYW5EYXRlLCAtMSwgdG9HcmVnb3JpYW5EYXRlU2NyYXRjaCk7XG4gICAgdGhpc1V0YyA9IGNvbnZlcnRUYWlUb1V0Yyh0b0dyZWdvcmlhbkRhdGVTY3JhdGNoLCB0b0dyZWdvcmlhbkRhdGVTY3JhdGNoKTtcbiAgICBpc0xlYXBTZWNvbmQgPSB0cnVlO1xuICB9XG5cbiAgdmFyIGp1bGlhbkRheU51bWJlciA9IHRoaXNVdGMuZGF5TnVtYmVyO1xuICB2YXIgc2Vjb25kc09mRGF5ID0gdGhpc1V0Yy5zZWNvbmRzT2ZEYXk7XG5cbiAgaWYgKHNlY29uZHNPZkRheSA+PSA0MzIwMC4wKSB7XG4gICAganVsaWFuRGF5TnVtYmVyICs9IDE7XG4gIH1cblxuICAvLyBBbGdvcml0aG0gZnJvbSBwYWdlIDYwNCBvZiB0aGUgRXhwbGFuYXRvcnkgU3VwcGxlbWVudCB0byB0aGVcbiAgLy8gQXN0cm9ub21pY2FsIEFsbWFuYWMgKFNlaWRlbG1hbm4gMTk5MikuXG4gIHZhciBMID0gKGp1bGlhbkRheU51bWJlciArIDY4NTY5KSB8IDA7XG4gIHZhciBOID0gKCg0ICogTCkgLyAxNDYwOTcpIHwgMDtcbiAgTCA9IChMIC0gKCgoMTQ2MDk3ICogTiArIDMpIC8gNCkgfCAwKSkgfCAwO1xuICB2YXIgSSA9ICgoNDAwMCAqIChMICsgMSkpIC8gMTQ2MTAwMSkgfCAwO1xuICBMID0gKEwgLSAoKCgxNDYxICogSSkgLyA0KSB8IDApICsgMzEpIHwgMDtcbiAgdmFyIEogPSAoKDgwICogTCkgLyAyNDQ3KSB8IDA7XG4gIHZhciBkYXkgPSAoTCAtICgoKDI0NDcgKiBKKSAvIDgwKSB8IDApKSB8IDA7XG4gIEwgPSAoSiAvIDExKSB8IDA7XG4gIHZhciBtb250aCA9IChKICsgMiAtIDEyICogTCkgfCAwO1xuICB2YXIgeWVhciA9ICgxMDAgKiAoTiAtIDQ5KSArIEkgKyBMKSB8IDA7XG5cbiAgdmFyIGhvdXIgPSAoc2Vjb25kc09mRGF5IC8gVGltZUNvbnN0YW50cy5TRUNPTkRTX1BFUl9IT1VSKSB8IDA7XG4gIHZhciByZW1haW5pbmdTZWNvbmRzID0gc2Vjb25kc09mRGF5IC0gaG91ciAqIFRpbWVDb25zdGFudHMuU0VDT05EU19QRVJfSE9VUjtcbiAgdmFyIG1pbnV0ZSA9IChyZW1haW5pbmdTZWNvbmRzIC8gVGltZUNvbnN0YW50cy5TRUNPTkRTX1BFUl9NSU5VVEUpIHwgMDtcbiAgcmVtYWluaW5nU2Vjb25kcyA9XG4gICAgcmVtYWluaW5nU2Vjb25kcyAtIG1pbnV0ZSAqIFRpbWVDb25zdGFudHMuU0VDT05EU19QRVJfTUlOVVRFO1xuICB2YXIgc2Vjb25kID0gcmVtYWluaW5nU2Vjb25kcyB8IDA7XG4gIHZhciBtaWxsaXNlY29uZCA9XG4gICAgKHJlbWFpbmluZ1NlY29uZHMgLSBzZWNvbmQpIC8gVGltZUNvbnN0YW50cy5TRUNPTkRTX1BFUl9NSUxMSVNFQ09ORDtcblxuICAvLyBKdWxpYW5EYXRlcyBhcmUgbm9vbi1iYXNlZFxuICBob3VyICs9IDEyO1xuICBpZiAoaG91ciA+IDIzKSB7XG4gICAgaG91ciAtPSAyNDtcbiAgfVxuXG4gIC8vSWYgd2Ugd2VyZSBvbiBhIGxlYXAgc2Vjb25kLCBhZGQgaXQgYmFjay5cbiAgaWYgKGlzTGVhcFNlY29uZCkge1xuICAgIHNlY29uZCArPSAxO1xuICB9XG5cbiAgaWYgKCFkZWZpbmVkKHJlc3VsdCkpIHtcbiAgICByZXR1cm4gbmV3IEdyZWdvcmlhbkRhdGUoXG4gICAgICB5ZWFyLFxuICAgICAgbW9udGgsXG4gICAgICBkYXksXG4gICAgICBob3VyLFxuICAgICAgbWludXRlLFxuICAgICAgc2Vjb25kLFxuICAgICAgbWlsbGlzZWNvbmQsXG4gICAgICBpc0xlYXBTZWNvbmRcbiAgICApO1xuICB9XG5cbiAgcmVzdWx0LnllYXIgPSB5ZWFyO1xuICByZXN1bHQubW9udGggPSBtb250aDtcbiAgcmVzdWx0LmRheSA9IGRheTtcbiAgcmVzdWx0LmhvdXIgPSBob3VyO1xuICByZXN1bHQubWludXRlID0gbWludXRlO1xuICByZXN1bHQuc2Vjb25kID0gc2Vjb25kO1xuICByZXN1bHQubWlsbGlzZWNvbmQgPSBtaWxsaXNlY29uZDtcbiAgcmVzdWx0LmlzTGVhcFNlY29uZCA9IGlzTGVhcFNlY29uZDtcbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbi8qKlxuICogQ3JlYXRlcyBhIEphdmFTY3JpcHQgRGF0ZSBmcm9tIHRoZSBwcm92aWRlZCBpbnN0YW5jZS5cbiAqIFNpbmNlIEphdmFTY3JpcHQgZGF0ZXMgYXJlIG9ubHkgYWNjdXJhdGUgdG8gdGhlIG5lYXJlc3QgbWlsbGlzZWNvbmQgYW5kXG4gKiBjYW5ub3QgcmVwcmVzZW50IGEgbGVhcCBzZWNvbmQsIGNvbnNpZGVyIHVzaW5nIHtAbGluayBKdWxpYW5EYXRlLnRvR3JlZ29yaWFuRGF0ZX0gaW5zdGVhZC5cbiAqIElmIHRoZSBwcm92aWRlZCBKdWxpYW5EYXRlIGlzIGR1cmluZyBhIGxlYXAgc2Vjb25kLCB0aGUgcHJldmlvdXMgc2Vjb25kIGlzIHVzZWQuXG4gKlxuICogQHBhcmFtIHtKdWxpYW5EYXRlfSBqdWxpYW5EYXRlIFRoZSBkYXRlIHRvIGJlIGNvbnZlcnRlZC5cbiAqIEByZXR1cm5zIHtEYXRlfSBBIG5ldyBpbnN0YW5jZSByZXByZXNlbnRpbmcgdGhlIHByb3ZpZGVkIGRhdGUuXG4gKi9cbkp1bGlhbkRhdGUudG9EYXRlID0gZnVuY3Rpb24gKGp1bGlhbkRhdGUpIHtcbiAgLy8+PmluY2x1ZGVTdGFydCgnZGVidWcnLCBwcmFnbWFzLmRlYnVnKTtcbiAgaWYgKCFkZWZpbmVkKGp1bGlhbkRhdGUpKSB7XG4gICAgdGhyb3cgbmV3IERldmVsb3BlckVycm9yKFwianVsaWFuRGF0ZSBpcyByZXF1aXJlZC5cIik7XG4gIH1cbiAgLy8+PmluY2x1ZGVFbmQoJ2RlYnVnJyk7XG5cbiAgdmFyIGdEYXRlID0gSnVsaWFuRGF0ZS50b0dyZWdvcmlhbkRhdGUoanVsaWFuRGF0ZSwgZ3JlZ29yaWFuRGF0ZVNjcmF0Y2gpO1xuICB2YXIgc2Vjb25kID0gZ0RhdGUuc2Vjb25kO1xuICBpZiAoZ0RhdGUuaXNMZWFwU2Vjb25kKSB7XG4gICAgc2Vjb25kIC09IDE7XG4gIH1cbiAgcmV0dXJuIG5ldyBEYXRlKFxuICAgIERhdGUuVVRDKFxuICAgICAgZ0RhdGUueWVhcixcbiAgICAgIGdEYXRlLm1vbnRoIC0gMSxcbiAgICAgIGdEYXRlLmRheSxcbiAgICAgIGdEYXRlLmhvdXIsXG4gICAgICBnRGF0ZS5taW51dGUsXG4gICAgICBzZWNvbmQsXG4gICAgICBnRGF0ZS5taWxsaXNlY29uZFxuICAgIClcbiAgKTtcbn07XG5cbi8qKlxuICogQ3JlYXRlcyBhbiBJU084NjAxIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBwcm92aWRlZCBkYXRlLlxuICpcbiAqIEBwYXJhbSB7SnVsaWFuRGF0ZX0ganVsaWFuRGF0ZSBUaGUgZGF0ZSB0byBiZSBjb252ZXJ0ZWQuXG4gKiBAcGFyYW0ge051bWJlcn0gW3ByZWNpc2lvbl0gVGhlIG51bWJlciBvZiBmcmFjdGlvbmFsIGRpZ2l0cyB1c2VkIHRvIHJlcHJlc2VudCB0aGUgc2Vjb25kcyBjb21wb25lbnQuICBCeSBkZWZhdWx0LCB0aGUgbW9zdCBwcmVjaXNlIHJlcHJlc2VudGF0aW9uIGlzIHVzZWQuXG4gKiBAcmV0dXJucyB7U3RyaW5nfSBUaGUgSVNPODYwMSByZXByZXNlbnRhdGlvbiBvZiB0aGUgcHJvdmlkZWQgZGF0ZS5cbiAqL1xuSnVsaWFuRGF0ZS50b0lzbzg2MDEgPSBmdW5jdGlvbiAoanVsaWFuRGF0ZSwgcHJlY2lzaW9uKSB7XG4gIC8vPj5pbmNsdWRlU3RhcnQoJ2RlYnVnJywgcHJhZ21hcy5kZWJ1Zyk7XG4gIGlmICghZGVmaW5lZChqdWxpYW5EYXRlKSkge1xuICAgIHRocm93IG5ldyBEZXZlbG9wZXJFcnJvcihcImp1bGlhbkRhdGUgaXMgcmVxdWlyZWQuXCIpO1xuICB9XG4gIC8vPj5pbmNsdWRlRW5kKCdkZWJ1ZycpO1xuXG4gIHZhciBnRGF0ZSA9IEp1bGlhbkRhdGUudG9HcmVnb3JpYW5EYXRlKGp1bGlhbkRhdGUsIGdyZWdvcmlhbkRhdGVTY3JhdGNoKTtcbiAgdmFyIHllYXIgPSBnRGF0ZS55ZWFyO1xuICB2YXIgbW9udGggPSBnRGF0ZS5tb250aDtcbiAgdmFyIGRheSA9IGdEYXRlLmRheTtcbiAgdmFyIGhvdXIgPSBnRGF0ZS5ob3VyO1xuICB2YXIgbWludXRlID0gZ0RhdGUubWludXRlO1xuICB2YXIgc2Vjb25kID0gZ0RhdGUuc2Vjb25kO1xuICB2YXIgbWlsbGlzZWNvbmQgPSBnRGF0ZS5taWxsaXNlY29uZDtcblxuICAvLyBzcGVjaWFsIGNhc2UgLSBJc284NjAxLk1BWElNVU1fVkFMVUUgcHJvZHVjZXMgYSBzdHJpbmcgd2hpY2ggd2UgY2FuJ3QgcGFyc2UgdW5sZXNzIHdlIGFkanVzdC5cbiAgLy8gMTAwMDAtMDEtMDFUMDA6MDA6MDAgaXMgdGhlIHNhbWUgaW5zdGFudCBhcyA5OTk5LTEyLTMxVDI0OjAwOjAwXG4gIGlmIChcbiAgICB5ZWFyID09PSAxMDAwMCAmJlxuICAgIG1vbnRoID09PSAxICYmXG4gICAgZGF5ID09PSAxICYmXG4gICAgaG91ciA9PT0gMCAmJlxuICAgIG1pbnV0ZSA9PT0gMCAmJlxuICAgIHNlY29uZCA9PT0gMCAmJlxuICAgIG1pbGxpc2Vjb25kID09PSAwXG4gICkge1xuICAgIHllYXIgPSA5OTk5O1xuICAgIG1vbnRoID0gMTI7XG4gICAgZGF5ID0gMzE7XG4gICAgaG91ciA9IDI0O1xuICB9XG5cbiAgdmFyIG1pbGxpc2Vjb25kU3RyO1xuXG4gIGlmICghZGVmaW5lZChwcmVjaXNpb24pICYmIG1pbGxpc2Vjb25kICE9PSAwKSB7XG4gICAgLy9Gb3JjZXMgbWlsbGlzZWNvbmRzIGludG8gYSBudW1iZXIgd2l0aCBhdCBsZWFzdCAzIGRpZ2l0cyB0byB3aGF0ZXZlciB0aGUgZGVmYXVsdCB0b1N0cmluZygpIHByZWNpc2lvbiBpcy5cbiAgICBtaWxsaXNlY29uZFN0ciA9IChtaWxsaXNlY29uZCAqIDAuMDEpLnRvU3RyaW5nKCkucmVwbGFjZShcIi5cIiwgXCJcIik7XG4gICAgcmV0dXJuIChcbiAgICAgIHllYXIudG9TdHJpbmcoKS5wYWRTdGFydCg0LCBcIjBcIikgK1xuICAgICAgXCItXCIgK1xuICAgICAgbW9udGgudG9TdHJpbmcoKS5wYWRTdGFydCgyLCBcIjBcIikgK1xuICAgICAgXCItXCIgK1xuICAgICAgZGF5LnRvU3RyaW5nKCkucGFkU3RhcnQoMiwgXCIwXCIpICtcbiAgICAgIFwiVFwiICtcbiAgICAgIGhvdXIudG9TdHJpbmcoKS5wYWRTdGFydCgyLCBcIjBcIikgK1xuICAgICAgXCI6XCIgK1xuICAgICAgbWludXRlLnRvU3RyaW5nKCkucGFkU3RhcnQoMiwgXCIwXCIpICtcbiAgICAgIFwiOlwiICtcbiAgICAgIHNlY29uZC50b1N0cmluZygpLnBhZFN0YXJ0KDIsIFwiMFwiKSArXG4gICAgICBcIi5cIiArXG4gICAgICBtaWxsaXNlY29uZFN0ciArXG4gICAgICBcIlpcIlxuICAgICk7XG4gIH1cblxuICAvL1ByZWNpc2lvbiBpcyBlaXRoZXIgMCBvciBtaWxsaXNlY29uZHMgaXMgMCB3aXRoIHVuZGVmaW5lZCBwcmVjaXNpb24sIGluIGVpdGhlciBjYXNlLCBsZWF2ZSBvZmYgbWlsbGlzZWNvbmRzIGVudGlyZWx5XG4gIGlmICghZGVmaW5lZChwcmVjaXNpb24pIHx8IHByZWNpc2lvbiA9PT0gMCkge1xuICAgIHJldHVybiAoXG4gICAgICB5ZWFyLnRvU3RyaW5nKCkucGFkU3RhcnQoNCwgXCIwXCIpICtcbiAgICAgIFwiLVwiICtcbiAgICAgIG1vbnRoLnRvU3RyaW5nKCkucGFkU3RhcnQoMiwgXCIwXCIpICtcbiAgICAgIFwiLVwiICtcbiAgICAgIGRheS50b1N0cmluZygpLnBhZFN0YXJ0KDIsIFwiMFwiKSArXG4gICAgICBcIlRcIiArXG4gICAgICBob3VyLnRvU3RyaW5nKCkucGFkU3RhcnQoMiwgXCIwXCIpICtcbiAgICAgIFwiOlwiICtcbiAgICAgIG1pbnV0ZS50b1N0cmluZygpLnBhZFN0YXJ0KDIsIFwiMFwiKSArXG4gICAgICBcIjpcIiArXG4gICAgICBzZWNvbmQudG9TdHJpbmcoKS5wYWRTdGFydCgyLCBcIjBcIikgK1xuICAgICAgXCJaXCJcbiAgICApO1xuICB9XG5cbiAgLy9Gb3JjZXMgbWlsbGlzZWNvbmRzIGludG8gYSBudW1iZXIgd2l0aCBhdCBsZWFzdCAzIGRpZ2l0cyB0byB3aGF0ZXZlciB0aGUgc3BlY2lmaWVkIHByZWNpc2lvbiBpcy5cbiAgbWlsbGlzZWNvbmRTdHIgPSAobWlsbGlzZWNvbmQgKiAwLjAxKVxuICAgIC50b0ZpeGVkKHByZWNpc2lvbilcbiAgICAucmVwbGFjZShcIi5cIiwgXCJcIilcbiAgICAuc2xpY2UoMCwgcHJlY2lzaW9uKTtcbiAgcmV0dXJuIChcbiAgICB5ZWFyLnRvU3RyaW5nKCkucGFkU3RhcnQoNCwgXCIwXCIpICtcbiAgICBcIi1cIiArXG4gICAgbW9udGgudG9TdHJpbmcoKS5wYWRTdGFydCgyLCBcIjBcIikgK1xuICAgIFwiLVwiICtcbiAgICBkYXkudG9TdHJpbmcoKS5wYWRTdGFydCgyLCBcIjBcIikgK1xuICAgIFwiVFwiICtcbiAgICBob3VyLnRvU3RyaW5nKCkucGFkU3RhcnQoMiwgXCIwXCIpICtcbiAgICBcIjpcIiArXG4gICAgbWludXRlLnRvU3RyaW5nKCkucGFkU3RhcnQoMiwgXCIwXCIpICtcbiAgICBcIjpcIiArXG4gICAgc2Vjb25kLnRvU3RyaW5nKCkucGFkU3RhcnQoMiwgXCIwXCIpICtcbiAgICBcIi5cIiArXG4gICAgbWlsbGlzZWNvbmRTdHIgK1xuICAgIFwiWlwiXG4gICk7XG59O1xuXG4vKipcbiAqIER1cGxpY2F0ZXMgYSBKdWxpYW5EYXRlIGluc3RhbmNlLlxuICpcbiAqIEBwYXJhbSB7SnVsaWFuRGF0ZX0ganVsaWFuRGF0ZSBUaGUgZGF0ZSB0byBkdXBsaWNhdGUuXG4gKiBAcGFyYW0ge0p1bGlhbkRhdGV9IFtyZXN1bHRdIEFuIGV4aXN0aW5nIGluc3RhbmNlIHRvIHVzZSBmb3IgdGhlIHJlc3VsdC5cbiAqIEByZXR1cm5zIHtKdWxpYW5EYXRlfSBUaGUgbW9kaWZpZWQgcmVzdWx0IHBhcmFtZXRlciBvciBhIG5ldyBpbnN0YW5jZSBpZiBub25lIHdhcyBwcm92aWRlZC4gUmV0dXJucyB1bmRlZmluZWQgaWYganVsaWFuRGF0ZSBpcyB1bmRlZmluZWQuXG4gKi9cbkp1bGlhbkRhdGUuY2xvbmUgPSBmdW5jdGlvbiAoanVsaWFuRGF0ZSwgcmVzdWx0KSB7XG4gIGlmICghZGVmaW5lZChqdWxpYW5EYXRlKSkge1xuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cbiAgaWYgKCFkZWZpbmVkKHJlc3VsdCkpIHtcbiAgICByZXR1cm4gbmV3IEp1bGlhbkRhdGUoXG4gICAgICBqdWxpYW5EYXRlLmRheU51bWJlcixcbiAgICAgIGp1bGlhbkRhdGUuc2Vjb25kc09mRGF5LFxuICAgICAgVGltZVN0YW5kYXJkLlRBSVxuICAgICk7XG4gIH1cbiAgcmVzdWx0LmRheU51bWJlciA9IGp1bGlhbkRhdGUuZGF5TnVtYmVyO1xuICByZXN1bHQuc2Vjb25kc09mRGF5ID0ganVsaWFuRGF0ZS5zZWNvbmRzT2ZEYXk7XG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG4vKipcbiAqIENvbXBhcmVzIHR3byBpbnN0YW5jZXMuXG4gKlxuICogQHBhcmFtIHtKdWxpYW5EYXRlfSBsZWZ0IFRoZSBmaXJzdCBpbnN0YW5jZS5cbiAqIEBwYXJhbSB7SnVsaWFuRGF0ZX0gcmlnaHQgVGhlIHNlY29uZCBpbnN0YW5jZS5cbiAqIEByZXR1cm5zIHtOdW1iZXJ9IEEgbmVnYXRpdmUgdmFsdWUgaWYgbGVmdCBpcyBsZXNzIHRoYW4gcmlnaHQsIGEgcG9zaXRpdmUgdmFsdWUgaWYgbGVmdCBpcyBncmVhdGVyIHRoYW4gcmlnaHQsIG9yIHplcm8gaWYgbGVmdCBhbmQgcmlnaHQgYXJlIGVxdWFsLlxuICovXG5KdWxpYW5EYXRlLmNvbXBhcmUgPSBmdW5jdGlvbiAobGVmdCwgcmlnaHQpIHtcbiAgLy8+PmluY2x1ZGVTdGFydCgnZGVidWcnLCBwcmFnbWFzLmRlYnVnKTtcbiAgaWYgKCFkZWZpbmVkKGxlZnQpKSB7XG4gICAgdGhyb3cgbmV3IERldmVsb3BlckVycm9yKFwibGVmdCBpcyByZXF1aXJlZC5cIik7XG4gIH1cbiAgaWYgKCFkZWZpbmVkKHJpZ2h0KSkge1xuICAgIHRocm93IG5ldyBEZXZlbG9wZXJFcnJvcihcInJpZ2h0IGlzIHJlcXVpcmVkLlwiKTtcbiAgfVxuICAvLz4+aW5jbHVkZUVuZCgnZGVidWcnKTtcblxuICB2YXIganVsaWFuRGF5TnVtYmVyRGlmZmVyZW5jZSA9IGxlZnQuZGF5TnVtYmVyIC0gcmlnaHQuZGF5TnVtYmVyO1xuICBpZiAoanVsaWFuRGF5TnVtYmVyRGlmZmVyZW5jZSAhPT0gMCkge1xuICAgIHJldHVybiBqdWxpYW5EYXlOdW1iZXJEaWZmZXJlbmNlO1xuICB9XG4gIHJldHVybiBsZWZ0LnNlY29uZHNPZkRheSAtIHJpZ2h0LnNlY29uZHNPZkRheTtcbn07XG5cbi8qKlxuICogQ29tcGFyZXMgdHdvIGluc3RhbmNlcyBhbmQgcmV0dXJucyA8Y29kZT50cnVlPC9jb2RlPiBpZiB0aGV5IGFyZSBlcXVhbCwgPGNvZGU+ZmFsc2U8L2NvZGU+IG90aGVyd2lzZS5cbiAqXG4gKiBAcGFyYW0ge0p1bGlhbkRhdGV9IFtsZWZ0XSBUaGUgZmlyc3QgaW5zdGFuY2UuXG4gKiBAcGFyYW0ge0p1bGlhbkRhdGV9IFtyaWdodF0gVGhlIHNlY29uZCBpbnN0YW5jZS5cbiAqIEByZXR1cm5zIHtCb29sZWFufSA8Y29kZT50cnVlPC9jb2RlPiBpZiB0aGUgZGF0ZXMgYXJlIGVxdWFsOyBvdGhlcndpc2UsIDxjb2RlPmZhbHNlPC9jb2RlPi5cbiAqL1xuSnVsaWFuRGF0ZS5lcXVhbHMgPSBmdW5jdGlvbiAobGVmdCwgcmlnaHQpIHtcbiAgcmV0dXJuIChcbiAgICBsZWZ0ID09PSByaWdodCB8fFxuICAgIChkZWZpbmVkKGxlZnQpICYmXG4gICAgICBkZWZpbmVkKHJpZ2h0KSAmJlxuICAgICAgbGVmdC5kYXlOdW1iZXIgPT09IHJpZ2h0LmRheU51bWJlciAmJlxuICAgICAgbGVmdC5zZWNvbmRzT2ZEYXkgPT09IHJpZ2h0LnNlY29uZHNPZkRheSlcbiAgKTtcbn07XG5cbi8qKlxuICogQ29tcGFyZXMgdHdvIGluc3RhbmNlcyBhbmQgcmV0dXJucyA8Y29kZT50cnVlPC9jb2RlPiBpZiB0aGV5IGFyZSB3aXRoaW4gPGNvZGU+ZXBzaWxvbjwvY29kZT4gc2Vjb25kcyBvZlxuICogZWFjaCBvdGhlci4gIFRoYXQgaXMsIGluIG9yZGVyIGZvciB0aGUgZGF0ZXMgdG8gYmUgY29uc2lkZXJlZCBlcXVhbCAoYW5kIGZvclxuICogdGhpcyBmdW5jdGlvbiB0byByZXR1cm4gPGNvZGU+dHJ1ZTwvY29kZT4pLCB0aGUgYWJzb2x1dGUgdmFsdWUgb2YgdGhlIGRpZmZlcmVuY2UgYmV0d2VlbiB0aGVtLCBpblxuICogc2Vjb25kcywgbXVzdCBiZSBsZXNzIHRoYW4gPGNvZGU+ZXBzaWxvbjwvY29kZT4uXG4gKlxuICogQHBhcmFtIHtKdWxpYW5EYXRlfSBbbGVmdF0gVGhlIGZpcnN0IGluc3RhbmNlLlxuICogQHBhcmFtIHtKdWxpYW5EYXRlfSBbcmlnaHRdIFRoZSBzZWNvbmQgaW5zdGFuY2UuXG4gKiBAcGFyYW0ge051bWJlcn0gW2Vwc2lsb249MF0gVGhlIG1heGltdW0gbnVtYmVyIG9mIHNlY29uZHMgdGhhdCBzaG91bGQgc2VwYXJhdGUgdGhlIHR3byBpbnN0YW5jZXMuXG4gKiBAcmV0dXJucyB7Qm9vbGVhbn0gPGNvZGU+dHJ1ZTwvY29kZT4gaWYgdGhlIHR3byBkYXRlcyBhcmUgd2l0aGluIDxjb2RlPmVwc2lsb248L2NvZGU+IHNlY29uZHMgb2YgZWFjaCBvdGhlcjsgb3RoZXJ3aXNlIDxjb2RlPmZhbHNlPC9jb2RlPi5cbiAqL1xuSnVsaWFuRGF0ZS5lcXVhbHNFcHNpbG9uID0gZnVuY3Rpb24gKGxlZnQsIHJpZ2h0LCBlcHNpbG9uKSB7XG4gIGVwc2lsb24gPSBkZWZhdWx0VmFsdWUoZXBzaWxvbiwgMCk7XG5cbiAgcmV0dXJuIChcbiAgICBsZWZ0ID09PSByaWdodCB8fFxuICAgIChkZWZpbmVkKGxlZnQpICYmXG4gICAgICBkZWZpbmVkKHJpZ2h0KSAmJlxuICAgICAgTWF0aC5hYnMoSnVsaWFuRGF0ZS5zZWNvbmRzRGlmZmVyZW5jZShsZWZ0LCByaWdodCkpIDw9IGVwc2lsb24pXG4gICk7XG59O1xuXG4vKipcbiAqIENvbXB1dGVzIHRoZSB0b3RhbCBudW1iZXIgb2Ygd2hvbGUgYW5kIGZyYWN0aW9uYWwgZGF5cyByZXByZXNlbnRlZCBieSB0aGUgcHJvdmlkZWQgaW5zdGFuY2UuXG4gKlxuICogQHBhcmFtIHtKdWxpYW5EYXRlfSBqdWxpYW5EYXRlIFRoZSBkYXRlLlxuICogQHJldHVybnMge051bWJlcn0gVGhlIEp1bGlhbiBkYXRlIGFzIHNpbmdsZSBmbG9hdGluZyBwb2ludCBudW1iZXIuXG4gKi9cbkp1bGlhbkRhdGUudG90YWxEYXlzID0gZnVuY3Rpb24gKGp1bGlhbkRhdGUpIHtcbiAgLy8+PmluY2x1ZGVTdGFydCgnZGVidWcnLCBwcmFnbWFzLmRlYnVnKTtcbiAgaWYgKCFkZWZpbmVkKGp1bGlhbkRhdGUpKSB7XG4gICAgdGhyb3cgbmV3IERldmVsb3BlckVycm9yKFwianVsaWFuRGF0ZSBpcyByZXF1aXJlZC5cIik7XG4gIH1cbiAgLy8+PmluY2x1ZGVFbmQoJ2RlYnVnJyk7XG4gIHJldHVybiAoXG4gICAganVsaWFuRGF0ZS5kYXlOdW1iZXIgK1xuICAgIGp1bGlhbkRhdGUuc2Vjb25kc09mRGF5IC8gVGltZUNvbnN0YW50cy5TRUNPTkRTX1BFUl9EQVlcbiAgKTtcbn07XG5cbi8qKlxuICogQ29tcHV0ZXMgdGhlIGRpZmZlcmVuY2UgaW4gc2Vjb25kcyBiZXR3ZWVuIHRoZSBwcm92aWRlZCBpbnN0YW5jZS5cbiAqXG4gKiBAcGFyYW0ge0p1bGlhbkRhdGV9IGxlZnQgVGhlIGZpcnN0IGluc3RhbmNlLlxuICogQHBhcmFtIHtKdWxpYW5EYXRlfSByaWdodCBUaGUgc2Vjb25kIGluc3RhbmNlLlxuICogQHJldHVybnMge051bWJlcn0gVGhlIGRpZmZlcmVuY2UsIGluIHNlY29uZHMsIHdoZW4gc3VidHJhY3RpbmcgPGNvZGU+cmlnaHQ8L2NvZGU+IGZyb20gPGNvZGU+bGVmdDwvY29kZT4uXG4gKi9cbkp1bGlhbkRhdGUuc2Vjb25kc0RpZmZlcmVuY2UgPSBmdW5jdGlvbiAobGVmdCwgcmlnaHQpIHtcbiAgLy8+PmluY2x1ZGVTdGFydCgnZGVidWcnLCBwcmFnbWFzLmRlYnVnKTtcbiAgaWYgKCFkZWZpbmVkKGxlZnQpKSB7XG4gICAgdGhyb3cgbmV3IERldmVsb3BlckVycm9yKFwibGVmdCBpcyByZXF1aXJlZC5cIik7XG4gIH1cbiAgaWYgKCFkZWZpbmVkKHJpZ2h0KSkge1xuICAgIHRocm93IG5ldyBEZXZlbG9wZXJFcnJvcihcInJpZ2h0IGlzIHJlcXVpcmVkLlwiKTtcbiAgfVxuICAvLz4+aW5jbHVkZUVuZCgnZGVidWcnKTtcblxuICB2YXIgZGF5RGlmZmVyZW5jZSA9XG4gICAgKGxlZnQuZGF5TnVtYmVyIC0gcmlnaHQuZGF5TnVtYmVyKSAqIFRpbWVDb25zdGFudHMuU0VDT05EU19QRVJfREFZO1xuICByZXR1cm4gZGF5RGlmZmVyZW5jZSArIChsZWZ0LnNlY29uZHNPZkRheSAtIHJpZ2h0LnNlY29uZHNPZkRheSk7XG59O1xuXG4vKipcbiAqIENvbXB1dGVzIHRoZSBkaWZmZXJlbmNlIGluIGRheXMgYmV0d2VlbiB0aGUgcHJvdmlkZWQgaW5zdGFuY2UuXG4gKlxuICogQHBhcmFtIHtKdWxpYW5EYXRlfSBsZWZ0IFRoZSBmaXJzdCBpbnN0YW5jZS5cbiAqIEBwYXJhbSB7SnVsaWFuRGF0ZX0gcmlnaHQgVGhlIHNlY29uZCBpbnN0YW5jZS5cbiAqIEByZXR1cm5zIHtOdW1iZXJ9IFRoZSBkaWZmZXJlbmNlLCBpbiBkYXlzLCB3aGVuIHN1YnRyYWN0aW5nIDxjb2RlPnJpZ2h0PC9jb2RlPiBmcm9tIDxjb2RlPmxlZnQ8L2NvZGU+LlxuICovXG5KdWxpYW5EYXRlLmRheXNEaWZmZXJlbmNlID0gZnVuY3Rpb24gKGxlZnQsIHJpZ2h0KSB7XG4gIC8vPj5pbmNsdWRlU3RhcnQoJ2RlYnVnJywgcHJhZ21hcy5kZWJ1Zyk7XG4gIGlmICghZGVmaW5lZChsZWZ0KSkge1xuICAgIHRocm93IG5ldyBEZXZlbG9wZXJFcnJvcihcImxlZnQgaXMgcmVxdWlyZWQuXCIpO1xuICB9XG4gIGlmICghZGVmaW5lZChyaWdodCkpIHtcbiAgICB0aHJvdyBuZXcgRGV2ZWxvcGVyRXJyb3IoXCJyaWdodCBpcyByZXF1aXJlZC5cIik7XG4gIH1cbiAgLy8+PmluY2x1ZGVFbmQoJ2RlYnVnJyk7XG5cbiAgdmFyIGRheURpZmZlcmVuY2UgPSBsZWZ0LmRheU51bWJlciAtIHJpZ2h0LmRheU51bWJlcjtcbiAgdmFyIHNlY29uZERpZmZlcmVuY2UgPVxuICAgIChsZWZ0LnNlY29uZHNPZkRheSAtIHJpZ2h0LnNlY29uZHNPZkRheSkgLyBUaW1lQ29uc3RhbnRzLlNFQ09ORFNfUEVSX0RBWTtcbiAgcmV0dXJuIGRheURpZmZlcmVuY2UgKyBzZWNvbmREaWZmZXJlbmNlO1xufTtcblxuLyoqXG4gKiBDb21wdXRlcyB0aGUgbnVtYmVyIG9mIHNlY29uZHMgdGhlIHByb3ZpZGVkIGluc3RhbmNlIGlzIGFoZWFkIG9mIFVUQy5cbiAqXG4gKiBAcGFyYW0ge0p1bGlhbkRhdGV9IGp1bGlhbkRhdGUgVGhlIGRhdGUuXG4gKiBAcmV0dXJucyB7TnVtYmVyfSBUaGUgbnVtYmVyIG9mIHNlY29uZHMgdGhlIHByb3ZpZGVkIGluc3RhbmNlIGlzIGFoZWFkIG9mIFVUQ1xuICovXG5KdWxpYW5EYXRlLmNvbXB1dGVUYWlNaW51c1V0YyA9IGZ1bmN0aW9uIChqdWxpYW5EYXRlKSB7XG4gIGJpbmFyeVNlYXJjaFNjcmF0Y2hMZWFwU2Vjb25kLmp1bGlhbkRhdGUgPSBqdWxpYW5EYXRlO1xuICB2YXIgbGVhcFNlY29uZHMgPSBKdWxpYW5EYXRlLmxlYXBTZWNvbmRzO1xuICB2YXIgaW5kZXggPSBiaW5hcnlTZWFyY2goXG4gICAgbGVhcFNlY29uZHMsXG4gICAgYmluYXJ5U2VhcmNoU2NyYXRjaExlYXBTZWNvbmQsXG4gICAgY29tcGFyZUxlYXBTZWNvbmREYXRlc1xuICApO1xuICBpZiAoaW5kZXggPCAwKSB7XG4gICAgaW5kZXggPSB+aW5kZXg7XG4gICAgLS1pbmRleDtcbiAgICBpZiAoaW5kZXggPCAwKSB7XG4gICAgICBpbmRleCA9IDA7XG4gICAgfVxuICB9XG4gIHJldHVybiBsZWFwU2Vjb25kc1tpbmRleF0ub2Zmc2V0O1xufTtcblxuLyoqXG4gKiBBZGRzIHRoZSBwcm92aWRlZCBudW1iZXIgb2Ygc2Vjb25kcyB0byB0aGUgcHJvdmlkZWQgZGF0ZSBpbnN0YW5jZS5cbiAqXG4gKiBAcGFyYW0ge0p1bGlhbkRhdGV9IGp1bGlhbkRhdGUgVGhlIGRhdGUuXG4gKiBAcGFyYW0ge051bWJlcn0gc2Vjb25kcyBUaGUgbnVtYmVyIG9mIHNlY29uZHMgdG8gYWRkIG9yIHN1YnRyYWN0LlxuICogQHBhcmFtIHtKdWxpYW5EYXRlfSByZXN1bHQgQW4gZXhpc3RpbmcgaW5zdGFuY2UgdG8gdXNlIGZvciB0aGUgcmVzdWx0LlxuICogQHJldHVybnMge0p1bGlhbkRhdGV9IFRoZSBtb2RpZmllZCByZXN1bHQgcGFyYW1ldGVyLlxuICovXG5KdWxpYW5EYXRlLmFkZFNlY29uZHMgPSBmdW5jdGlvbiAoanVsaWFuRGF0ZSwgc2Vjb25kcywgcmVzdWx0KSB7XG4gIC8vPj5pbmNsdWRlU3RhcnQoJ2RlYnVnJywgcHJhZ21hcy5kZWJ1Zyk7XG4gIGlmICghZGVmaW5lZChqdWxpYW5EYXRlKSkge1xuICAgIHRocm93IG5ldyBEZXZlbG9wZXJFcnJvcihcImp1bGlhbkRhdGUgaXMgcmVxdWlyZWQuXCIpO1xuICB9XG4gIGlmICghZGVmaW5lZChzZWNvbmRzKSkge1xuICAgIHRocm93IG5ldyBEZXZlbG9wZXJFcnJvcihcInNlY29uZHMgaXMgcmVxdWlyZWQuXCIpO1xuICB9XG4gIGlmICghZGVmaW5lZChyZXN1bHQpKSB7XG4gICAgdGhyb3cgbmV3IERldmVsb3BlckVycm9yKFwicmVzdWx0IGlzIHJlcXVpcmVkLlwiKTtcbiAgfVxuICAvLz4+aW5jbHVkZUVuZCgnZGVidWcnKTtcblxuICByZXR1cm4gc2V0Q29tcG9uZW50cyhcbiAgICBqdWxpYW5EYXRlLmRheU51bWJlcixcbiAgICBqdWxpYW5EYXRlLnNlY29uZHNPZkRheSArIHNlY29uZHMsXG4gICAgcmVzdWx0XG4gICk7XG59O1xuXG4vKipcbiAqIEFkZHMgdGhlIHByb3ZpZGVkIG51bWJlciBvZiBtaW51dGVzIHRvIHRoZSBwcm92aWRlZCBkYXRlIGluc3RhbmNlLlxuICpcbiAqIEBwYXJhbSB7SnVsaWFuRGF0ZX0ganVsaWFuRGF0ZSBUaGUgZGF0ZS5cbiAqIEBwYXJhbSB7TnVtYmVyfSBtaW51dGVzIFRoZSBudW1iZXIgb2YgbWludXRlcyB0byBhZGQgb3Igc3VidHJhY3QuXG4gKiBAcGFyYW0ge0p1bGlhbkRhdGV9IHJlc3VsdCBBbiBleGlzdGluZyBpbnN0YW5jZSB0byB1c2UgZm9yIHRoZSByZXN1bHQuXG4gKiBAcmV0dXJucyB7SnVsaWFuRGF0ZX0gVGhlIG1vZGlmaWVkIHJlc3VsdCBwYXJhbWV0ZXIuXG4gKi9cbkp1bGlhbkRhdGUuYWRkTWludXRlcyA9IGZ1bmN0aW9uIChqdWxpYW5EYXRlLCBtaW51dGVzLCByZXN1bHQpIHtcbiAgLy8+PmluY2x1ZGVTdGFydCgnZGVidWcnLCBwcmFnbWFzLmRlYnVnKTtcbiAgaWYgKCFkZWZpbmVkKGp1bGlhbkRhdGUpKSB7XG4gICAgdGhyb3cgbmV3IERldmVsb3BlckVycm9yKFwianVsaWFuRGF0ZSBpcyByZXF1aXJlZC5cIik7XG4gIH1cbiAgaWYgKCFkZWZpbmVkKG1pbnV0ZXMpKSB7XG4gICAgdGhyb3cgbmV3IERldmVsb3BlckVycm9yKFwibWludXRlcyBpcyByZXF1aXJlZC5cIik7XG4gIH1cbiAgaWYgKCFkZWZpbmVkKHJlc3VsdCkpIHtcbiAgICB0aHJvdyBuZXcgRGV2ZWxvcGVyRXJyb3IoXCJyZXN1bHQgaXMgcmVxdWlyZWQuXCIpO1xuICB9XG4gIC8vPj5pbmNsdWRlRW5kKCdkZWJ1ZycpO1xuXG4gIHZhciBuZXdTZWNvbmRzT2ZEYXkgPVxuICAgIGp1bGlhbkRhdGUuc2Vjb25kc09mRGF5ICsgbWludXRlcyAqIFRpbWVDb25zdGFudHMuU0VDT05EU19QRVJfTUlOVVRFO1xuICByZXR1cm4gc2V0Q29tcG9uZW50cyhqdWxpYW5EYXRlLmRheU51bWJlciwgbmV3U2Vjb25kc09mRGF5LCByZXN1bHQpO1xufTtcblxuLyoqXG4gKiBBZGRzIHRoZSBwcm92aWRlZCBudW1iZXIgb2YgaG91cnMgdG8gdGhlIHByb3ZpZGVkIGRhdGUgaW5zdGFuY2UuXG4gKlxuICogQHBhcmFtIHtKdWxpYW5EYXRlfSBqdWxpYW5EYXRlIFRoZSBkYXRlLlxuICogQHBhcmFtIHtOdW1iZXJ9IGhvdXJzIFRoZSBudW1iZXIgb2YgaG91cnMgdG8gYWRkIG9yIHN1YnRyYWN0LlxuICogQHBhcmFtIHtKdWxpYW5EYXRlfSByZXN1bHQgQW4gZXhpc3RpbmcgaW5zdGFuY2UgdG8gdXNlIGZvciB0aGUgcmVzdWx0LlxuICogQHJldHVybnMge0p1bGlhbkRhdGV9IFRoZSBtb2RpZmllZCByZXN1bHQgcGFyYW1ldGVyLlxuICovXG5KdWxpYW5EYXRlLmFkZEhvdXJzID0gZnVuY3Rpb24gKGp1bGlhbkRhdGUsIGhvdXJzLCByZXN1bHQpIHtcbiAgLy8+PmluY2x1ZGVTdGFydCgnZGVidWcnLCBwcmFnbWFzLmRlYnVnKTtcbiAgaWYgKCFkZWZpbmVkKGp1bGlhbkRhdGUpKSB7XG4gICAgdGhyb3cgbmV3IERldmVsb3BlckVycm9yKFwianVsaWFuRGF0ZSBpcyByZXF1aXJlZC5cIik7XG4gIH1cbiAgaWYgKCFkZWZpbmVkKGhvdXJzKSkge1xuICAgIHRocm93IG5ldyBEZXZlbG9wZXJFcnJvcihcImhvdXJzIGlzIHJlcXVpcmVkLlwiKTtcbiAgfVxuICBpZiAoIWRlZmluZWQocmVzdWx0KSkge1xuICAgIHRocm93IG5ldyBEZXZlbG9wZXJFcnJvcihcInJlc3VsdCBpcyByZXF1aXJlZC5cIik7XG4gIH1cbiAgLy8+PmluY2x1ZGVFbmQoJ2RlYnVnJyk7XG5cbiAgdmFyIG5ld1NlY29uZHNPZkRheSA9XG4gICAganVsaWFuRGF0ZS5zZWNvbmRzT2ZEYXkgKyBob3VycyAqIFRpbWVDb25zdGFudHMuU0VDT05EU19QRVJfSE9VUjtcbiAgcmV0dXJuIHNldENvbXBvbmVudHMoanVsaWFuRGF0ZS5kYXlOdW1iZXIsIG5ld1NlY29uZHNPZkRheSwgcmVzdWx0KTtcbn07XG5cbi8qKlxuICogQWRkcyB0aGUgcHJvdmlkZWQgbnVtYmVyIG9mIGRheXMgdG8gdGhlIHByb3ZpZGVkIGRhdGUgaW5zdGFuY2UuXG4gKlxuICogQHBhcmFtIHtKdWxpYW5EYXRlfSBqdWxpYW5EYXRlIFRoZSBkYXRlLlxuICogQHBhcmFtIHtOdW1iZXJ9IGRheXMgVGhlIG51bWJlciBvZiBkYXlzIHRvIGFkZCBvciBzdWJ0cmFjdC5cbiAqIEBwYXJhbSB7SnVsaWFuRGF0ZX0gcmVzdWx0IEFuIGV4aXN0aW5nIGluc3RhbmNlIHRvIHVzZSBmb3IgdGhlIHJlc3VsdC5cbiAqIEByZXR1cm5zIHtKdWxpYW5EYXRlfSBUaGUgbW9kaWZpZWQgcmVzdWx0IHBhcmFtZXRlci5cbiAqL1xuSnVsaWFuRGF0ZS5hZGREYXlzID0gZnVuY3Rpb24gKGp1bGlhbkRhdGUsIGRheXMsIHJlc3VsdCkge1xuICAvLz4+aW5jbHVkZVN0YXJ0KCdkZWJ1ZycsIHByYWdtYXMuZGVidWcpO1xuICBpZiAoIWRlZmluZWQoanVsaWFuRGF0ZSkpIHtcbiAgICB0aHJvdyBuZXcgRGV2ZWxvcGVyRXJyb3IoXCJqdWxpYW5EYXRlIGlzIHJlcXVpcmVkLlwiKTtcbiAgfVxuICBpZiAoIWRlZmluZWQoZGF5cykpIHtcbiAgICB0aHJvdyBuZXcgRGV2ZWxvcGVyRXJyb3IoXCJkYXlzIGlzIHJlcXVpcmVkLlwiKTtcbiAgfVxuICBpZiAoIWRlZmluZWQocmVzdWx0KSkge1xuICAgIHRocm93IG5ldyBEZXZlbG9wZXJFcnJvcihcInJlc3VsdCBpcyByZXF1aXJlZC5cIik7XG4gIH1cbiAgLy8+PmluY2x1ZGVFbmQoJ2RlYnVnJyk7XG5cbiAgdmFyIG5ld0p1bGlhbkRheU51bWJlciA9IGp1bGlhbkRhdGUuZGF5TnVtYmVyICsgZGF5cztcbiAgcmV0dXJuIHNldENvbXBvbmVudHMobmV3SnVsaWFuRGF5TnVtYmVyLCBqdWxpYW5EYXRlLnNlY29uZHNPZkRheSwgcmVzdWx0KTtcbn07XG5cbi8qKlxuICogQ29tcGFyZXMgdGhlIHByb3ZpZGVkIGluc3RhbmNlcyBhbmQgcmV0dXJucyA8Y29kZT50cnVlPC9jb2RlPiBpZiA8Y29kZT5sZWZ0PC9jb2RlPiBpcyBlYXJsaWVyIHRoYW4gPGNvZGU+cmlnaHQ8L2NvZGU+LCA8Y29kZT5mYWxzZTwvY29kZT4gb3RoZXJ3aXNlLlxuICpcbiAqIEBwYXJhbSB7SnVsaWFuRGF0ZX0gbGVmdCBUaGUgZmlyc3QgaW5zdGFuY2UuXG4gKiBAcGFyYW0ge0p1bGlhbkRhdGV9IHJpZ2h0IFRoZSBzZWNvbmQgaW5zdGFuY2UuXG4gKiBAcmV0dXJucyB7Qm9vbGVhbn0gPGNvZGU+dHJ1ZTwvY29kZT4gaWYgPGNvZGU+bGVmdDwvY29kZT4gaXMgZWFybGllciB0aGFuIDxjb2RlPnJpZ2h0PC9jb2RlPiwgPGNvZGU+ZmFsc2U8L2NvZGU+IG90aGVyd2lzZS5cbiAqL1xuSnVsaWFuRGF0ZS5sZXNzVGhhbiA9IGZ1bmN0aW9uIChsZWZ0LCByaWdodCkge1xuICByZXR1cm4gSnVsaWFuRGF0ZS5jb21wYXJlKGxlZnQsIHJpZ2h0KSA8IDA7XG59O1xuXG4vKipcbiAqIENvbXBhcmVzIHRoZSBwcm92aWRlZCBpbnN0YW5jZXMgYW5kIHJldHVybnMgPGNvZGU+dHJ1ZTwvY29kZT4gaWYgPGNvZGU+bGVmdDwvY29kZT4gaXMgZWFybGllciB0aGFuIG9yIGVxdWFsIHRvIDxjb2RlPnJpZ2h0PC9jb2RlPiwgPGNvZGU+ZmFsc2U8L2NvZGU+IG90aGVyd2lzZS5cbiAqXG4gKiBAcGFyYW0ge0p1bGlhbkRhdGV9IGxlZnQgVGhlIGZpcnN0IGluc3RhbmNlLlxuICogQHBhcmFtIHtKdWxpYW5EYXRlfSByaWdodCBUaGUgc2Vjb25kIGluc3RhbmNlLlxuICogQHJldHVybnMge0Jvb2xlYW59IDxjb2RlPnRydWU8L2NvZGU+IGlmIDxjb2RlPmxlZnQ8L2NvZGU+IGlzIGVhcmxpZXIgdGhhbiBvciBlcXVhbCB0byA8Y29kZT5yaWdodDwvY29kZT4sIDxjb2RlPmZhbHNlPC9jb2RlPiBvdGhlcndpc2UuXG4gKi9cbkp1bGlhbkRhdGUubGVzc1RoYW5PckVxdWFscyA9IGZ1bmN0aW9uIChsZWZ0LCByaWdodCkge1xuICByZXR1cm4gSnVsaWFuRGF0ZS5jb21wYXJlKGxlZnQsIHJpZ2h0KSA8PSAwO1xufTtcblxuLyoqXG4gKiBDb21wYXJlcyB0aGUgcHJvdmlkZWQgaW5zdGFuY2VzIGFuZCByZXR1cm5zIDxjb2RlPnRydWU8L2NvZGU+IGlmIDxjb2RlPmxlZnQ8L2NvZGU+IGlzIGxhdGVyIHRoYW4gPGNvZGU+cmlnaHQ8L2NvZGU+LCA8Y29kZT5mYWxzZTwvY29kZT4gb3RoZXJ3aXNlLlxuICpcbiAqIEBwYXJhbSB7SnVsaWFuRGF0ZX0gbGVmdCBUaGUgZmlyc3QgaW5zdGFuY2UuXG4gKiBAcGFyYW0ge0p1bGlhbkRhdGV9IHJpZ2h0IFRoZSBzZWNvbmQgaW5zdGFuY2UuXG4gKiBAcmV0dXJucyB7Qm9vbGVhbn0gPGNvZGU+dHJ1ZTwvY29kZT4gaWYgPGNvZGU+bGVmdDwvY29kZT4gaXMgbGF0ZXIgdGhhbiA8Y29kZT5yaWdodDwvY29kZT4sIDxjb2RlPmZhbHNlPC9jb2RlPiBvdGhlcndpc2UuXG4gKi9cbkp1bGlhbkRhdGUuZ3JlYXRlclRoYW4gPSBmdW5jdGlvbiAobGVmdCwgcmlnaHQpIHtcbiAgcmV0dXJuIEp1bGlhbkRhdGUuY29tcGFyZShsZWZ0LCByaWdodCkgPiAwO1xufTtcblxuLyoqXG4gKiBDb21wYXJlcyB0aGUgcHJvdmlkZWQgaW5zdGFuY2VzIGFuZCByZXR1cm5zIDxjb2RlPnRydWU8L2NvZGU+IGlmIDxjb2RlPmxlZnQ8L2NvZGU+IGlzIGxhdGVyIHRoYW4gb3IgZXF1YWwgdG8gPGNvZGU+cmlnaHQ8L2NvZGU+LCA8Y29kZT5mYWxzZTwvY29kZT4gb3RoZXJ3aXNlLlxuICpcbiAqIEBwYXJhbSB7SnVsaWFuRGF0ZX0gbGVmdCBUaGUgZmlyc3QgaW5zdGFuY2UuXG4gKiBAcGFyYW0ge0p1bGlhbkRhdGV9IHJpZ2h0IFRoZSBzZWNvbmQgaW5zdGFuY2UuXG4gKiBAcmV0dXJucyB7Qm9vbGVhbn0gPGNvZGU+dHJ1ZTwvY29kZT4gaWYgPGNvZGU+bGVmdDwvY29kZT4gaXMgbGF0ZXIgdGhhbiBvciBlcXVhbCB0byA8Y29kZT5yaWdodDwvY29kZT4sIDxjb2RlPmZhbHNlPC9jb2RlPiBvdGhlcndpc2UuXG4gKi9cbkp1bGlhbkRhdGUuZ3JlYXRlclRoYW5PckVxdWFscyA9IGZ1bmN0aW9uIChsZWZ0LCByaWdodCkge1xuICByZXR1cm4gSnVsaWFuRGF0ZS5jb21wYXJlKGxlZnQsIHJpZ2h0KSA+PSAwO1xufTtcblxuLyoqXG4gKiBEdXBsaWNhdGVzIHRoaXMgaW5zdGFuY2UuXG4gKlxuICogQHBhcmFtIHtKdWxpYW5EYXRlfSBbcmVzdWx0XSBBbiBleGlzdGluZyBpbnN0YW5jZSB0byB1c2UgZm9yIHRoZSByZXN1bHQuXG4gKiBAcmV0dXJucyB7SnVsaWFuRGF0ZX0gVGhlIG1vZGlmaWVkIHJlc3VsdCBwYXJhbWV0ZXIgb3IgYSBuZXcgaW5zdGFuY2UgaWYgbm9uZSB3YXMgcHJvdmlkZWQuXG4gKi9cbkp1bGlhbkRhdGUucHJvdG90eXBlLmNsb25lID0gZnVuY3Rpb24gKHJlc3VsdCkge1xuICByZXR1cm4gSnVsaWFuRGF0ZS5jbG9uZSh0aGlzLCByZXN1bHQpO1xufTtcblxuLyoqXG4gKiBDb21wYXJlcyB0aGlzIGFuZCB0aGUgcHJvdmlkZWQgaW5zdGFuY2UgYW5kIHJldHVybnMgPGNvZGU+dHJ1ZTwvY29kZT4gaWYgdGhleSBhcmUgZXF1YWwsIDxjb2RlPmZhbHNlPC9jb2RlPiBvdGhlcndpc2UuXG4gKlxuICogQHBhcmFtIHtKdWxpYW5EYXRlfSBbcmlnaHRdIFRoZSBzZWNvbmQgaW5zdGFuY2UuXG4gKiBAcmV0dXJucyB7Qm9vbGVhbn0gPGNvZGU+dHJ1ZTwvY29kZT4gaWYgdGhlIGRhdGVzIGFyZSBlcXVhbDsgb3RoZXJ3aXNlLCA8Y29kZT5mYWxzZTwvY29kZT4uXG4gKi9cbkp1bGlhbkRhdGUucHJvdG90eXBlLmVxdWFscyA9IGZ1bmN0aW9uIChyaWdodCkge1xuICByZXR1cm4gSnVsaWFuRGF0ZS5lcXVhbHModGhpcywgcmlnaHQpO1xufTtcblxuLyoqXG4gKiBDb21wYXJlcyB0aGlzIGFuZCB0aGUgcHJvdmlkZWQgaW5zdGFuY2UgYW5kIHJldHVybnMgPGNvZGU+dHJ1ZTwvY29kZT4gaWYgdGhleSBhcmUgd2l0aGluIDxjb2RlPmVwc2lsb248L2NvZGU+IHNlY29uZHMgb2ZcbiAqIGVhY2ggb3RoZXIuICBUaGF0IGlzLCBpbiBvcmRlciBmb3IgdGhlIGRhdGVzIHRvIGJlIGNvbnNpZGVyZWQgZXF1YWwgKGFuZCBmb3JcbiAqIHRoaXMgZnVuY3Rpb24gdG8gcmV0dXJuIDxjb2RlPnRydWU8L2NvZGU+KSwgdGhlIGFic29sdXRlIHZhbHVlIG9mIHRoZSBkaWZmZXJlbmNlIGJldHdlZW4gdGhlbSwgaW5cbiAqIHNlY29uZHMsIG11c3QgYmUgbGVzcyB0aGFuIDxjb2RlPmVwc2lsb248L2NvZGU+LlxuICpcbiAqIEBwYXJhbSB7SnVsaWFuRGF0ZX0gW3JpZ2h0XSBUaGUgc2Vjb25kIGluc3RhbmNlLlxuICogQHBhcmFtIHtOdW1iZXJ9IFtlcHNpbG9uPTBdIFRoZSBtYXhpbXVtIG51bWJlciBvZiBzZWNvbmRzIHRoYXQgc2hvdWxkIHNlcGFyYXRlIHRoZSB0d28gaW5zdGFuY2VzLlxuICogQHJldHVybnMge0Jvb2xlYW59IDxjb2RlPnRydWU8L2NvZGU+IGlmIHRoZSB0d28gZGF0ZXMgYXJlIHdpdGhpbiA8Y29kZT5lcHNpbG9uPC9jb2RlPiBzZWNvbmRzIG9mIGVhY2ggb3RoZXI7IG90aGVyd2lzZSA8Y29kZT5mYWxzZTwvY29kZT4uXG4gKi9cbkp1bGlhbkRhdGUucHJvdG90eXBlLmVxdWFsc0Vwc2lsb24gPSBmdW5jdGlvbiAocmlnaHQsIGVwc2lsb24pIHtcbiAgcmV0dXJuIEp1bGlhbkRhdGUuZXF1YWxzRXBzaWxvbih0aGlzLCByaWdodCwgZXBzaWxvbik7XG59O1xuXG4vKipcbiAqIENyZWF0ZXMgYSBzdHJpbmcgcmVwcmVzZW50aW5nIHRoaXMgZGF0ZSBpbiBJU084NjAxIGZvcm1hdC5cbiAqXG4gKiBAcmV0dXJucyB7U3RyaW5nfSBBIHN0cmluZyByZXByZXNlbnRpbmcgdGhpcyBkYXRlIGluIElTTzg2MDEgZm9ybWF0LlxuICovXG5KdWxpYW5EYXRlLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIEp1bGlhbkRhdGUudG9Jc284NjAxKHRoaXMpO1xufTtcblxuLyoqXG4gKiBHZXRzIG9yIHNldHMgdGhlIGxpc3Qgb2YgbGVhcCBzZWNvbmRzIHVzZWQgdGhyb3VnaG91dCBDZXNpdW0uXG4gKiBAbWVtYmVyb2YgSnVsaWFuRGF0ZVxuICogQHR5cGUge0xlYXBTZWNvbmRbXX1cbiAqL1xuSnVsaWFuRGF0ZS5sZWFwU2Vjb25kcyA9IFtcbiAgbmV3IExlYXBTZWNvbmQobmV3IEp1bGlhbkRhdGUoMjQ0MTMxNywgNDMyMTAuMCwgVGltZVN0YW5kYXJkLlRBSSksIDEwKSwgLy8gSmFudWFyeSAxLCAxOTcyIDAwOjAwOjAwIFVUQ1xuICBuZXcgTGVhcFNlY29uZChuZXcgSnVsaWFuRGF0ZSgyNDQxNDk5LCA0MzIxMS4wLCBUaW1lU3RhbmRhcmQuVEFJKSwgMTEpLCAvLyBKdWx5IDEsIDE5NzIgMDA6MDA6MDAgVVRDXG4gIG5ldyBMZWFwU2Vjb25kKG5ldyBKdWxpYW5EYXRlKDI0NDE2ODMsIDQzMjEyLjAsIFRpbWVTdGFuZGFyZC5UQUkpLCAxMiksIC8vIEphbnVhcnkgMSwgMTk3MyAwMDowMDowMCBVVENcbiAgbmV3IExlYXBTZWNvbmQobmV3IEp1bGlhbkRhdGUoMjQ0MjA0OCwgNDMyMTMuMCwgVGltZVN0YW5kYXJkLlRBSSksIDEzKSwgLy8gSmFudWFyeSAxLCAxOTc0IDAwOjAwOjAwIFVUQ1xuICBuZXcgTGVhcFNlY29uZChuZXcgSnVsaWFuRGF0ZSgyNDQyNDEzLCA0MzIxNC4wLCBUaW1lU3RhbmRhcmQuVEFJKSwgMTQpLCAvLyBKYW51YXJ5IDEsIDE5NzUgMDA6MDA6MDAgVVRDXG4gIG5ldyBMZWFwU2Vjb25kKG5ldyBKdWxpYW5EYXRlKDI0NDI3NzgsIDQzMjE1LjAsIFRpbWVTdGFuZGFyZC5UQUkpLCAxNSksIC8vIEphbnVhcnkgMSwgMTk3NiAwMDowMDowMCBVVENcbiAgbmV3IExlYXBTZWNvbmQobmV3IEp1bGlhbkRhdGUoMjQ0MzE0NCwgNDMyMTYuMCwgVGltZVN0YW5kYXJkLlRBSSksIDE2KSwgLy8gSmFudWFyeSAxLCAxOTc3IDAwOjAwOjAwIFVUQ1xuICBuZXcgTGVhcFNlY29uZChuZXcgSnVsaWFuRGF0ZSgyNDQzNTA5LCA0MzIxNy4wLCBUaW1lU3RhbmRhcmQuVEFJKSwgMTcpLCAvLyBKYW51YXJ5IDEsIDE5NzggMDA6MDA6MDAgVVRDXG4gIG5ldyBMZWFwU2Vjb25kKG5ldyBKdWxpYW5EYXRlKDI0NDM4NzQsIDQzMjE4LjAsIFRpbWVTdGFuZGFyZC5UQUkpLCAxOCksIC8vIEphbnVhcnkgMSwgMTk3OSAwMDowMDowMCBVVENcbiAgbmV3IExlYXBTZWNvbmQobmV3IEp1bGlhbkRhdGUoMjQ0NDIzOSwgNDMyMTkuMCwgVGltZVN0YW5kYXJkLlRBSSksIDE5KSwgLy8gSmFudWFyeSAxLCAxOTgwIDAwOjAwOjAwIFVUQ1xuICBuZXcgTGVhcFNlY29uZChuZXcgSnVsaWFuRGF0ZSgyNDQ0Nzg2LCA0MzIyMC4wLCBUaW1lU3RhbmRhcmQuVEFJKSwgMjApLCAvLyBKdWx5IDEsIDE5ODEgMDA6MDA6MDAgVVRDXG4gIG5ldyBMZWFwU2Vjb25kKG5ldyBKdWxpYW5EYXRlKDI0NDUxNTEsIDQzMjIxLjAsIFRpbWVTdGFuZGFyZC5UQUkpLCAyMSksIC8vIEp1bHkgMSwgMTk4MiAwMDowMDowMCBVVENcbiAgbmV3IExlYXBTZWNvbmQobmV3IEp1bGlhbkRhdGUoMjQ0NTUxNiwgNDMyMjIuMCwgVGltZVN0YW5kYXJkLlRBSSksIDIyKSwgLy8gSnVseSAxLCAxOTgzIDAwOjAwOjAwIFVUQ1xuICBuZXcgTGVhcFNlY29uZChuZXcgSnVsaWFuRGF0ZSgyNDQ2MjQ3LCA0MzIyMy4wLCBUaW1lU3RhbmRhcmQuVEFJKSwgMjMpLCAvLyBKdWx5IDEsIDE5ODUgMDA6MDA6MDAgVVRDXG4gIG5ldyBMZWFwU2Vjb25kKG5ldyBKdWxpYW5EYXRlKDI0NDcxNjEsIDQzMjI0LjAsIFRpbWVTdGFuZGFyZC5UQUkpLCAyNCksIC8vIEphbnVhcnkgMSwgMTk4OCAwMDowMDowMCBVVENcbiAgbmV3IExlYXBTZWNvbmQobmV3IEp1bGlhbkRhdGUoMjQ0Nzg5MiwgNDMyMjUuMCwgVGltZVN0YW5kYXJkLlRBSSksIDI1KSwgLy8gSmFudWFyeSAxLCAxOTkwIDAwOjAwOjAwIFVUQ1xuICBuZXcgTGVhcFNlY29uZChuZXcgSnVsaWFuRGF0ZSgyNDQ4MjU3LCA0MzIyNi4wLCBUaW1lU3RhbmRhcmQuVEFJKSwgMjYpLCAvLyBKYW51YXJ5IDEsIDE5OTEgMDA6MDA6MDAgVVRDXG4gIG5ldyBMZWFwU2Vjb25kKG5ldyBKdWxpYW5EYXRlKDI0NDg4MDQsIDQzMjI3LjAsIFRpbWVTdGFuZGFyZC5UQUkpLCAyNyksIC8vIEp1bHkgMSwgMTk5MiAwMDowMDowMCBVVENcbiAgbmV3IExlYXBTZWNvbmQobmV3IEp1bGlhbkRhdGUoMjQ0OTE2OSwgNDMyMjguMCwgVGltZVN0YW5kYXJkLlRBSSksIDI4KSwgLy8gSnVseSAxLCAxOTkzIDAwOjAwOjAwIFVUQ1xuICBuZXcgTGVhcFNlY29uZChuZXcgSnVsaWFuRGF0ZSgyNDQ5NTM0LCA0MzIyOS4wLCBUaW1lU3RhbmRhcmQuVEFJKSwgMjkpLCAvLyBKdWx5IDEsIDE5OTQgMDA6MDA6MDAgVVRDXG4gIG5ldyBMZWFwU2Vjb25kKG5ldyBKdWxpYW5EYXRlKDI0NTAwODMsIDQzMjMwLjAsIFRpbWVTdGFuZGFyZC5UQUkpLCAzMCksIC8vIEphbnVhcnkgMSwgMTk5NiAwMDowMDowMCBVVENcbiAgbmV3IExlYXBTZWNvbmQobmV3IEp1bGlhbkRhdGUoMjQ1MDYzMCwgNDMyMzEuMCwgVGltZVN0YW5kYXJkLlRBSSksIDMxKSwgLy8gSnVseSAxLCAxOTk3IDAwOjAwOjAwIFVUQ1xuICBuZXcgTGVhcFNlY29uZChuZXcgSnVsaWFuRGF0ZSgyNDUxMTc5LCA0MzIzMi4wLCBUaW1lU3RhbmRhcmQuVEFJKSwgMzIpLCAvLyBKYW51YXJ5IDEsIDE5OTkgMDA6MDA6MDAgVVRDXG4gIG5ldyBMZWFwU2Vjb25kKG5ldyBKdWxpYW5EYXRlKDI0NTM3MzYsIDQzMjMzLjAsIFRpbWVTdGFuZGFyZC5UQUkpLCAzMyksIC8vIEphbnVhcnkgMSwgMjAwNiAwMDowMDowMCBVVENcbiAgbmV3IExlYXBTZWNvbmQobmV3IEp1bGlhbkRhdGUoMjQ1NDgzMiwgNDMyMzQuMCwgVGltZVN0YW5kYXJkLlRBSSksIDM0KSwgLy8gSmFudWFyeSAxLCAyMDA5IDAwOjAwOjAwIFVUQ1xuICBuZXcgTGVhcFNlY29uZChuZXcgSnVsaWFuRGF0ZSgyNDU2MTA5LCA0MzIzNS4wLCBUaW1lU3RhbmRhcmQuVEFJKSwgMzUpLCAvLyBKdWx5IDEsIDIwMTIgMDA6MDA6MDAgVVRDXG4gIG5ldyBMZWFwU2Vjb25kKG5ldyBKdWxpYW5EYXRlKDI0NTcyMDQsIDQzMjM2LjAsIFRpbWVTdGFuZGFyZC5UQUkpLCAzNiksIC8vIEp1bHkgMSwgMjAxNSAwMDowMDowMCBVVENcbiAgbmV3IExlYXBTZWNvbmQobmV3IEp1bGlhbkRhdGUoMjQ1Nzc1NCwgNDMyMzcuMCwgVGltZVN0YW5kYXJkLlRBSSksIDM3KSwgLy8gSmFudWFyeSAxLCAyMDE3IDAwOjAwOjAwIFVUQ1xuXTtcbmV4cG9ydCBkZWZhdWx0IEp1bGlhbkRhdGU7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///55293\n')},29690:function(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__){eval('/* harmony import */ var _Check_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(66553);\n/* harmony import */ var _CompressedTextureBuffer_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(67167);\n/* harmony import */ var _defined_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(82982);\n/* harmony import */ var _TaskProcessor_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(2819);\n\n\n\n\n\n/**\n * Transcodes KTX2 textures using web workers.\n *\n * @private\n */\nfunction KTX2Transcoder() {}\n\nKTX2Transcoder._transcodeTaskProcessor = new _TaskProcessor_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"] */ .Z(\n  "transcodeKTX2",\n  Number.POSITIVE_INFINITY // KTX2 transcoding is used in place of Resource.fetchImage, so it can\'t reject as "just soooo busy right now"\n);\n\nKTX2Transcoder._readyPromise = undefined;\n\nfunction makeReadyPromise() {\n  var readyPromise = KTX2Transcoder._transcodeTaskProcessor\n    .initWebAssemblyModule({\n      modulePath: "ThirdParty/Workers/basis_transcoder.js",\n      wasmBinaryFile: "ThirdParty/basis_transcoder.wasm",\n    })\n    .then(function () {\n      return KTX2Transcoder._transcodeTaskProcessor;\n    });\n  KTX2Transcoder._readyPromise = readyPromise;\n}\n\nKTX2Transcoder.transcode = function (ktx2Buffer, supportedTargetFormats) {\n  //>>includeStart(\'debug\', pragmas.debug);\n  _Check_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].defined */ .Z.defined("supportedTargetFormats", supportedTargetFormats);\n  //>>includeEnd(\'debug\');\n\n  if (!(0,_defined_js__WEBPACK_IMPORTED_MODULE_3__/* ["default"] */ .Z)(KTX2Transcoder._readyPromise)) {\n    makeReadyPromise();\n  }\n\n  return KTX2Transcoder._readyPromise\n    .then(function (taskProcessor) {\n      var parameters;\n      if (ktx2Buffer instanceof ArrayBuffer) {\n        var view = new Uint8Array(ktx2Buffer);\n        parameters = {\n          supportedTargetFormats: supportedTargetFormats,\n          ktx2Buffer: view,\n        };\n        return taskProcessor.scheduleTask(parameters, [ktx2Buffer]);\n      }\n      parameters = {\n        supportedTargetFormats: supportedTargetFormats,\n        ktx2Buffer: ktx2Buffer,\n      };\n      return taskProcessor.scheduleTask(parameters, [ktx2Buffer.buffer]);\n    })\n    .then(function (result) {\n      var levelsLength = result.length;\n      var faceKeys = Object.keys(result[0]);\n      var faceKeysLength = faceKeys.length;\n\n      var i;\n      for (i = 0; i < levelsLength; i++) {\n        var faces = result[i];\n        for (var j = 0; j < faceKeysLength; j++) {\n          var face = faces[faceKeys[j]];\n          faces[faceKeys[j]] = new _CompressedTextureBuffer_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .Z(\n            face.internalFormat,\n            face.datatype,\n            face.width,\n            face.height,\n            face.levelBuffer\n          );\n        }\n      }\n\n      // Cleaning up parsed result if it\'s a single image\n      if (faceKeysLength === 1) {\n        for (i = 0; i < levelsLength; ++i) {\n          result[i] = result[i][faceKeys[0]];\n        }\n\n        if (levelsLength === 1) {\n          result = result[0];\n        }\n      }\n      return result;\n    })\n    .otherwise(function (error) {\n      throw error;\n    });\n};\n\n/* harmony default export */ __webpack_exports__["Z"] = (KTX2Transcoder);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjk2OTAuanMiLCJtYXBwaW5ncyI6Ijs7OztBQUErQjtBQUNvQztBQUNoQztBQUNZOztBQUUvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsNkNBQTZDLGtFQUFhO0FBQzFEO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsRUFBRSwwRUFBYTtBQUNmOztBQUVBLE9BQU8sZ0VBQU87QUFDZDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esa0JBQWtCLGtCQUFrQjtBQUNwQztBQUNBLHdCQUF3QixvQkFBb0I7QUFDNUM7QUFDQSxtQ0FBbUMsNEVBQXVCO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG9CQUFvQixrQkFBa0I7QUFDdEM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUEseURBQWUsY0FBYyxFQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdnVlMy13ZWJwYWNrNS8uL25vZGVfbW9kdWxlcy9jZXNpdW0vU291cmNlL0NvcmUvS1RYMlRyYW5zY29kZXIuanM/ODVjOCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgQ2hlY2sgZnJvbSBcIi4vQ2hlY2suanNcIjtcbmltcG9ydCBDb21wcmVzc2VkVGV4dHVyZUJ1ZmZlciBmcm9tIFwiLi9Db21wcmVzc2VkVGV4dHVyZUJ1ZmZlci5qc1wiO1xuaW1wb3J0IGRlZmluZWQgZnJvbSBcIi4vZGVmaW5lZC5qc1wiO1xuaW1wb3J0IFRhc2tQcm9jZXNzb3IgZnJvbSBcIi4vVGFza1Byb2Nlc3Nvci5qc1wiO1xuXG4vKipcbiAqIFRyYW5zY29kZXMgS1RYMiB0ZXh0dXJlcyB1c2luZyB3ZWIgd29ya2Vycy5cbiAqXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBLVFgyVHJhbnNjb2RlcigpIHt9XG5cbktUWDJUcmFuc2NvZGVyLl90cmFuc2NvZGVUYXNrUHJvY2Vzc29yID0gbmV3IFRhc2tQcm9jZXNzb3IoXG4gIFwidHJhbnNjb2RlS1RYMlwiLFxuICBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFkgLy8gS1RYMiB0cmFuc2NvZGluZyBpcyB1c2VkIGluIHBsYWNlIG9mIFJlc291cmNlLmZldGNoSW1hZ2UsIHNvIGl0IGNhbid0IHJlamVjdCBhcyBcImp1c3Qgc29vb28gYnVzeSByaWdodCBub3dcIlxuKTtcblxuS1RYMlRyYW5zY29kZXIuX3JlYWR5UHJvbWlzZSA9IHVuZGVmaW5lZDtcblxuZnVuY3Rpb24gbWFrZVJlYWR5UHJvbWlzZSgpIHtcbiAgdmFyIHJlYWR5UHJvbWlzZSA9IEtUWDJUcmFuc2NvZGVyLl90cmFuc2NvZGVUYXNrUHJvY2Vzc29yXG4gICAgLmluaXRXZWJBc3NlbWJseU1vZHVsZSh7XG4gICAgICBtb2R1bGVQYXRoOiBcIlRoaXJkUGFydHkvV29ya2Vycy9iYXNpc190cmFuc2NvZGVyLmpzXCIsXG4gICAgICB3YXNtQmluYXJ5RmlsZTogXCJUaGlyZFBhcnR5L2Jhc2lzX3RyYW5zY29kZXIud2FzbVwiLFxuICAgIH0pXG4gICAgLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIEtUWDJUcmFuc2NvZGVyLl90cmFuc2NvZGVUYXNrUHJvY2Vzc29yO1xuICAgIH0pO1xuICBLVFgyVHJhbnNjb2Rlci5fcmVhZHlQcm9taXNlID0gcmVhZHlQcm9taXNlO1xufVxuXG5LVFgyVHJhbnNjb2Rlci50cmFuc2NvZGUgPSBmdW5jdGlvbiAoa3R4MkJ1ZmZlciwgc3VwcG9ydGVkVGFyZ2V0Rm9ybWF0cykge1xuICAvLz4+aW5jbHVkZVN0YXJ0KCdkZWJ1ZycsIHByYWdtYXMuZGVidWcpO1xuICBDaGVjay5kZWZpbmVkKFwic3VwcG9ydGVkVGFyZ2V0Rm9ybWF0c1wiLCBzdXBwb3J0ZWRUYXJnZXRGb3JtYXRzKTtcbiAgLy8+PmluY2x1ZGVFbmQoJ2RlYnVnJyk7XG5cbiAgaWYgKCFkZWZpbmVkKEtUWDJUcmFuc2NvZGVyLl9yZWFkeVByb21pc2UpKSB7XG4gICAgbWFrZVJlYWR5UHJvbWlzZSgpO1xuICB9XG5cbiAgcmV0dXJuIEtUWDJUcmFuc2NvZGVyLl9yZWFkeVByb21pc2VcbiAgICAudGhlbihmdW5jdGlvbiAodGFza1Byb2Nlc3Nvcikge1xuICAgICAgdmFyIHBhcmFtZXRlcnM7XG4gICAgICBpZiAoa3R4MkJ1ZmZlciBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSB7XG4gICAgICAgIHZhciB2aWV3ID0gbmV3IFVpbnQ4QXJyYXkoa3R4MkJ1ZmZlcik7XG4gICAgICAgIHBhcmFtZXRlcnMgPSB7XG4gICAgICAgICAgc3VwcG9ydGVkVGFyZ2V0Rm9ybWF0czogc3VwcG9ydGVkVGFyZ2V0Rm9ybWF0cyxcbiAgICAgICAgICBrdHgyQnVmZmVyOiB2aWV3LFxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gdGFza1Byb2Nlc3Nvci5zY2hlZHVsZVRhc2socGFyYW1ldGVycywgW2t0eDJCdWZmZXJdKTtcbiAgICAgIH1cbiAgICAgIHBhcmFtZXRlcnMgPSB7XG4gICAgICAgIHN1cHBvcnRlZFRhcmdldEZvcm1hdHM6IHN1cHBvcnRlZFRhcmdldEZvcm1hdHMsXG4gICAgICAgIGt0eDJCdWZmZXI6IGt0eDJCdWZmZXIsXG4gICAgICB9O1xuICAgICAgcmV0dXJuIHRhc2tQcm9jZXNzb3Iuc2NoZWR1bGVUYXNrKHBhcmFtZXRlcnMsIFtrdHgyQnVmZmVyLmJ1ZmZlcl0pO1xuICAgIH0pXG4gICAgLnRoZW4oZnVuY3Rpb24gKHJlc3VsdCkge1xuICAgICAgdmFyIGxldmVsc0xlbmd0aCA9IHJlc3VsdC5sZW5ndGg7XG4gICAgICB2YXIgZmFjZUtleXMgPSBPYmplY3Qua2V5cyhyZXN1bHRbMF0pO1xuICAgICAgdmFyIGZhY2VLZXlzTGVuZ3RoID0gZmFjZUtleXMubGVuZ3RoO1xuXG4gICAgICB2YXIgaTtcbiAgICAgIGZvciAoaSA9IDA7IGkgPCBsZXZlbHNMZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgZmFjZXMgPSByZXN1bHRbaV07XG4gICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgZmFjZUtleXNMZW5ndGg7IGorKykge1xuICAgICAgICAgIHZhciBmYWNlID0gZmFjZXNbZmFjZUtleXNbal1dO1xuICAgICAgICAgIGZhY2VzW2ZhY2VLZXlzW2pdXSA9IG5ldyBDb21wcmVzc2VkVGV4dHVyZUJ1ZmZlcihcbiAgICAgICAgICAgIGZhY2UuaW50ZXJuYWxGb3JtYXQsXG4gICAgICAgICAgICBmYWNlLmRhdGF0eXBlLFxuICAgICAgICAgICAgZmFjZS53aWR0aCxcbiAgICAgICAgICAgIGZhY2UuaGVpZ2h0LFxuICAgICAgICAgICAgZmFjZS5sZXZlbEJ1ZmZlclxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gQ2xlYW5pbmcgdXAgcGFyc2VkIHJlc3VsdCBpZiBpdCdzIGEgc2luZ2xlIGltYWdlXG4gICAgICBpZiAoZmFjZUtleXNMZW5ndGggPT09IDEpIHtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGxldmVsc0xlbmd0aDsgKytpKSB7XG4gICAgICAgICAgcmVzdWx0W2ldID0gcmVzdWx0W2ldW2ZhY2VLZXlzWzBdXTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChsZXZlbHNMZW5ndGggPT09IDEpIHtcbiAgICAgICAgICByZXN1bHQgPSByZXN1bHRbMF07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSlcbiAgICAub3RoZXJ3aXNlKGZ1bmN0aW9uIChlcnJvcikge1xuICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfSk7XG59O1xuXG5leHBvcnQgZGVmYXVsdCBLVFgyVHJhbnNjb2RlcjtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///29690\n')}}]);