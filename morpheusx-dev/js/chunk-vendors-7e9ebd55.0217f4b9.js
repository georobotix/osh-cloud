"use strict";(self["webpackChunkvue3_webpack5"]=self["webpackChunkvue3_webpack5"]||[]).push([[5898],{59359:function(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__){eval('/* harmony import */ var _arrayFill_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(23401);\n/* harmony import */ var _BoundingSphere_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(48243);\n/* harmony import */ var _Cartesian2_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(60838);\n/* harmony import */ var _Cartesian3_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(60216);\n/* harmony import */ var _Cartographic_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(51688);\n/* harmony import */ var _Check_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(66553);\n/* harmony import */ var _ComponentDatatype_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(84828);\n/* harmony import */ var _defaultValue_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(62200);\n/* harmony import */ var _defined_js__WEBPACK_IMPORTED_MODULE_25__ = __webpack_require__(82982);\n/* harmony import */ var _DeveloperError_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(12572);\n/* harmony import */ var _EllipseGeometryLibrary_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(47302);\n/* harmony import */ var _Ellipsoid_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(50491);\n/* harmony import */ var _GeographicProjection_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(39756);\n/* harmony import */ var _Geometry_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(82408);\n/* harmony import */ var _GeometryAttribute_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(13616);\n/* harmony import */ var _GeometryAttributes_js__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(56652);\n/* harmony import */ var _GeometryInstance_js__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(26865);\n/* harmony import */ var _GeometryOffsetAttribute_js__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(87379);\n/* harmony import */ var _GeometryPipeline_js__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(57552);\n/* harmony import */ var _IndexDatatype_js__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(22832);\n/* harmony import */ var _Math_js__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(99417);\n/* harmony import */ var _Matrix3_js__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(68201);\n/* harmony import */ var _PrimitiveType_js__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(97264);\n/* harmony import */ var _Quaternion_js__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(87811);\n/* harmony import */ var _Rectangle_js__WEBPACK_IMPORTED_MODULE_23__ = __webpack_require__(96190);\n/* harmony import */ var _VertexFormat_js__WEBPACK_IMPORTED_MODULE_24__ = __webpack_require__(67252);\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nvar scratchCartesian1 = new _Cartesian3_js__WEBPACK_IMPORTED_MODULE_3__/* ["default"] */ .Z();\nvar scratchCartesian2 = new _Cartesian3_js__WEBPACK_IMPORTED_MODULE_3__/* ["default"] */ .Z();\nvar scratchCartesian3 = new _Cartesian3_js__WEBPACK_IMPORTED_MODULE_3__/* ["default"] */ .Z();\nvar scratchCartesian4 = new _Cartesian3_js__WEBPACK_IMPORTED_MODULE_3__/* ["default"] */ .Z();\nvar texCoordScratch = new _Cartesian2_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"] */ .Z();\nvar textureMatrixScratch = new _Matrix3_js__WEBPACK_IMPORTED_MODULE_20__/* ["default"] */ .Z();\nvar tangentMatrixScratch = new _Matrix3_js__WEBPACK_IMPORTED_MODULE_20__/* ["default"] */ .Z();\nvar quaternionScratch = new _Quaternion_js__WEBPACK_IMPORTED_MODULE_22__/* ["default"] */ .Z();\n\nvar scratchNormal = new _Cartesian3_js__WEBPACK_IMPORTED_MODULE_3__/* ["default"] */ .Z();\nvar scratchTangent = new _Cartesian3_js__WEBPACK_IMPORTED_MODULE_3__/* ["default"] */ .Z();\nvar scratchBitangent = new _Cartesian3_js__WEBPACK_IMPORTED_MODULE_3__/* ["default"] */ .Z();\n\nvar scratchCartographic = new _Cartographic_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .Z();\nvar projectedCenterScratch = new _Cartesian3_js__WEBPACK_IMPORTED_MODULE_3__/* ["default"] */ .Z();\n\nvar scratchMinTexCoord = new _Cartesian2_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"] */ .Z();\nvar scratchMaxTexCoord = new _Cartesian2_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"] */ .Z();\n\nfunction computeTopBottomAttributes(positions, options, extrude) {\n  var vertexFormat = options.vertexFormat;\n  var center = options.center;\n  var semiMajorAxis = options.semiMajorAxis;\n  var semiMinorAxis = options.semiMinorAxis;\n  var ellipsoid = options.ellipsoid;\n  var stRotation = options.stRotation;\n  var size = extrude ? (positions.length / 3) * 2 : positions.length / 3;\n  var shadowVolume = options.shadowVolume;\n\n  var textureCoordinates = vertexFormat.st\n    ? new Float32Array(size * 2)\n    : undefined;\n  var normals = vertexFormat.normal ? new Float32Array(size * 3) : undefined;\n  var tangents = vertexFormat.tangent ? new Float32Array(size * 3) : undefined;\n  var bitangents = vertexFormat.bitangent\n    ? new Float32Array(size * 3)\n    : undefined;\n\n  var extrudeNormals = shadowVolume ? new Float32Array(size * 3) : undefined;\n\n  var textureCoordIndex = 0;\n\n  // Raise positions to a height above the ellipsoid and compute the\n  // texture coordinates, normals, tangents, and bitangents.\n  var normal = scratchNormal;\n  var tangent = scratchTangent;\n  var bitangent = scratchBitangent;\n\n  var projection = new _GeographicProjection_js__WEBPACK_IMPORTED_MODULE_11__/* ["default"] */ .Z(ellipsoid);\n  var projectedCenter = projection.project(\n    ellipsoid.cartesianToCartographic(center, scratchCartographic),\n    projectedCenterScratch\n  );\n\n  var geodeticNormal = ellipsoid.scaleToGeodeticSurface(\n    center,\n    scratchCartesian1\n  );\n  ellipsoid.geodeticSurfaceNormal(geodeticNormal, geodeticNormal);\n\n  var textureMatrix = textureMatrixScratch;\n  var tangentMatrix = tangentMatrixScratch;\n  if (stRotation !== 0) {\n    var rotation = _Quaternion_js__WEBPACK_IMPORTED_MODULE_22__/* ["default"].fromAxisAngle */ .Z.fromAxisAngle(\n      geodeticNormal,\n      stRotation,\n      quaternionScratch\n    );\n    textureMatrix = _Matrix3_js__WEBPACK_IMPORTED_MODULE_20__/* ["default"].fromQuaternion */ .Z.fromQuaternion(rotation, textureMatrix);\n\n    rotation = _Quaternion_js__WEBPACK_IMPORTED_MODULE_22__/* ["default"].fromAxisAngle */ .Z.fromAxisAngle(\n      geodeticNormal,\n      -stRotation,\n      quaternionScratch\n    );\n    tangentMatrix = _Matrix3_js__WEBPACK_IMPORTED_MODULE_20__/* ["default"].fromQuaternion */ .Z.fromQuaternion(rotation, tangentMatrix);\n  } else {\n    textureMatrix = _Matrix3_js__WEBPACK_IMPORTED_MODULE_20__/* ["default"].clone */ .Z.clone(_Matrix3_js__WEBPACK_IMPORTED_MODULE_20__/* ["default"].IDENTITY */ .Z.IDENTITY, textureMatrix);\n    tangentMatrix = _Matrix3_js__WEBPACK_IMPORTED_MODULE_20__/* ["default"].clone */ .Z.clone(_Matrix3_js__WEBPACK_IMPORTED_MODULE_20__/* ["default"].IDENTITY */ .Z.IDENTITY, tangentMatrix);\n  }\n\n  var minTexCoord = _Cartesian2_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"].fromElements */ .Z.fromElements(\n    Number.POSITIVE_INFINITY,\n    Number.POSITIVE_INFINITY,\n    scratchMinTexCoord\n  );\n  var maxTexCoord = _Cartesian2_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"].fromElements */ .Z.fromElements(\n    Number.NEGATIVE_INFINITY,\n    Number.NEGATIVE_INFINITY,\n    scratchMaxTexCoord\n  );\n\n  var length = positions.length;\n  var bottomOffset = extrude ? length : 0;\n  var stOffset = (bottomOffset / 3) * 2;\n  for (var i = 0; i < length; i += 3) {\n    var i1 = i + 1;\n    var i2 = i + 2;\n    var position = _Cartesian3_js__WEBPACK_IMPORTED_MODULE_3__/* ["default"].fromArray */ .Z.fromArray(positions, i, scratchCartesian1);\n\n    if (vertexFormat.st) {\n      var rotatedPoint = _Matrix3_js__WEBPACK_IMPORTED_MODULE_20__/* ["default"].multiplyByVector */ .Z.multiplyByVector(\n        textureMatrix,\n        position,\n        scratchCartesian2\n      );\n      var projectedPoint = projection.project(\n        ellipsoid.cartesianToCartographic(rotatedPoint, scratchCartographic),\n        scratchCartesian3\n      );\n      _Cartesian3_js__WEBPACK_IMPORTED_MODULE_3__/* ["default"].subtract */ .Z.subtract(projectedPoint, projectedCenter, projectedPoint);\n\n      texCoordScratch.x =\n        (projectedPoint.x + semiMajorAxis) / (2.0 * semiMajorAxis);\n      texCoordScratch.y =\n        (projectedPoint.y + semiMinorAxis) / (2.0 * semiMinorAxis);\n\n      minTexCoord.x = Math.min(texCoordScratch.x, minTexCoord.x);\n      minTexCoord.y = Math.min(texCoordScratch.y, minTexCoord.y);\n      maxTexCoord.x = Math.max(texCoordScratch.x, maxTexCoord.x);\n      maxTexCoord.y = Math.max(texCoordScratch.y, maxTexCoord.y);\n\n      if (extrude) {\n        textureCoordinates[textureCoordIndex + stOffset] = texCoordScratch.x;\n        textureCoordinates[textureCoordIndex + 1 + stOffset] =\n          texCoordScratch.y;\n      }\n\n      textureCoordinates[textureCoordIndex++] = texCoordScratch.x;\n      textureCoordinates[textureCoordIndex++] = texCoordScratch.y;\n    }\n\n    if (\n      vertexFormat.normal ||\n      vertexFormat.tangent ||\n      vertexFormat.bitangent ||\n      shadowVolume\n    ) {\n      normal = ellipsoid.geodeticSurfaceNormal(position, normal);\n\n      if (shadowVolume) {\n        extrudeNormals[i + bottomOffset] = -normal.x;\n        extrudeNormals[i1 + bottomOffset] = -normal.y;\n        extrudeNormals[i2 + bottomOffset] = -normal.z;\n      }\n\n      if (\n        vertexFormat.normal ||\n        vertexFormat.tangent ||\n        vertexFormat.bitangent\n      ) {\n        if (vertexFormat.tangent || vertexFormat.bitangent) {\n          tangent = _Cartesian3_js__WEBPACK_IMPORTED_MODULE_3__/* ["default"].normalize */ .Z.normalize(\n            _Cartesian3_js__WEBPACK_IMPORTED_MODULE_3__/* ["default"].cross */ .Z.cross(_Cartesian3_js__WEBPACK_IMPORTED_MODULE_3__/* ["default"].UNIT_Z */ .Z.UNIT_Z, normal, tangent),\n            tangent\n          );\n          _Matrix3_js__WEBPACK_IMPORTED_MODULE_20__/* ["default"].multiplyByVector */ .Z.multiplyByVector(tangentMatrix, tangent, tangent);\n        }\n        if (vertexFormat.normal) {\n          normals[i] = normal.x;\n          normals[i1] = normal.y;\n          normals[i2] = normal.z;\n          if (extrude) {\n            normals[i + bottomOffset] = -normal.x;\n            normals[i1 + bottomOffset] = -normal.y;\n            normals[i2 + bottomOffset] = -normal.z;\n          }\n        }\n\n        if (vertexFormat.tangent) {\n          tangents[i] = tangent.x;\n          tangents[i1] = tangent.y;\n          tangents[i2] = tangent.z;\n          if (extrude) {\n            tangents[i + bottomOffset] = -tangent.x;\n            tangents[i1 + bottomOffset] = -tangent.y;\n            tangents[i2 + bottomOffset] = -tangent.z;\n          }\n        }\n\n        if (vertexFormat.bitangent) {\n          bitangent = _Cartesian3_js__WEBPACK_IMPORTED_MODULE_3__/* ["default"].normalize */ .Z.normalize(\n            _Cartesian3_js__WEBPACK_IMPORTED_MODULE_3__/* ["default"].cross */ .Z.cross(normal, tangent, bitangent),\n            bitangent\n          );\n          bitangents[i] = bitangent.x;\n          bitangents[i1] = bitangent.y;\n          bitangents[i2] = bitangent.z;\n          if (extrude) {\n            bitangents[i + bottomOffset] = bitangent.x;\n            bitangents[i1 + bottomOffset] = bitangent.y;\n            bitangents[i2 + bottomOffset] = bitangent.z;\n          }\n        }\n      }\n    }\n  }\n\n  if (vertexFormat.st) {\n    length = textureCoordinates.length;\n    for (var k = 0; k < length; k += 2) {\n      textureCoordinates[k] =\n        (textureCoordinates[k] - minTexCoord.x) /\n        (maxTexCoord.x - minTexCoord.x);\n      textureCoordinates[k + 1] =\n        (textureCoordinates[k + 1] - minTexCoord.y) /\n        (maxTexCoord.y - minTexCoord.y);\n    }\n  }\n\n  var attributes = new _GeometryAttributes_js__WEBPACK_IMPORTED_MODULE_14__/* ["default"] */ .Z();\n\n  if (vertexFormat.position) {\n    var finalPositions = _EllipseGeometryLibrary_js__WEBPACK_IMPORTED_MODULE_9__/* ["default"].raisePositionsToHeight */ .Z.raisePositionsToHeight(\n      positions,\n      options,\n      extrude\n    );\n    attributes.position = new _GeometryAttribute_js__WEBPACK_IMPORTED_MODULE_13__/* ["default"] */ .Z({\n      componentDatatype: _ComponentDatatype_js__WEBPACK_IMPORTED_MODULE_6__/* ["default"].DOUBLE */ .Z.DOUBLE,\n      componentsPerAttribute: 3,\n      values: finalPositions,\n    });\n  }\n\n  if (vertexFormat.st) {\n    attributes.st = new _GeometryAttribute_js__WEBPACK_IMPORTED_MODULE_13__/* ["default"] */ .Z({\n      componentDatatype: _ComponentDatatype_js__WEBPACK_IMPORTED_MODULE_6__/* ["default"].FLOAT */ .Z.FLOAT,\n      componentsPerAttribute: 2,\n      values: textureCoordinates,\n    });\n  }\n\n  if (vertexFormat.normal) {\n    attributes.normal = new _GeometryAttribute_js__WEBPACK_IMPORTED_MODULE_13__/* ["default"] */ .Z({\n      componentDatatype: _ComponentDatatype_js__WEBPACK_IMPORTED_MODULE_6__/* ["default"].FLOAT */ .Z.FLOAT,\n      componentsPerAttribute: 3,\n      values: normals,\n    });\n  }\n\n  if (vertexFormat.tangent) {\n    attributes.tangent = new _GeometryAttribute_js__WEBPACK_IMPORTED_MODULE_13__/* ["default"] */ .Z({\n      componentDatatype: _ComponentDatatype_js__WEBPACK_IMPORTED_MODULE_6__/* ["default"].FLOAT */ .Z.FLOAT,\n      componentsPerAttribute: 3,\n      values: tangents,\n    });\n  }\n\n  if (vertexFormat.bitangent) {\n    attributes.bitangent = new _GeometryAttribute_js__WEBPACK_IMPORTED_MODULE_13__/* ["default"] */ .Z({\n      componentDatatype: _ComponentDatatype_js__WEBPACK_IMPORTED_MODULE_6__/* ["default"].FLOAT */ .Z.FLOAT,\n      componentsPerAttribute: 3,\n      values: bitangents,\n    });\n  }\n\n  if (shadowVolume) {\n    attributes.extrudeDirection = new _GeometryAttribute_js__WEBPACK_IMPORTED_MODULE_13__/* ["default"] */ .Z({\n      componentDatatype: _ComponentDatatype_js__WEBPACK_IMPORTED_MODULE_6__/* ["default"].FLOAT */ .Z.FLOAT,\n      componentsPerAttribute: 3,\n      values: extrudeNormals,\n    });\n  }\n\n  if (extrude && (0,_defined_js__WEBPACK_IMPORTED_MODULE_25__/* ["default"] */ .Z)(options.offsetAttribute)) {\n    var offsetAttribute = new Uint8Array(size);\n    if (options.offsetAttribute === _GeometryOffsetAttribute_js__WEBPACK_IMPORTED_MODULE_16__/* ["default"].TOP */ .Z.TOP) {\n      offsetAttribute = (0,_arrayFill_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .Z)(offsetAttribute, 1, 0, size / 2);\n    } else {\n      var offsetValue =\n        options.offsetAttribute === _GeometryOffsetAttribute_js__WEBPACK_IMPORTED_MODULE_16__/* ["default"].NONE */ .Z.NONE ? 0 : 1;\n      offsetAttribute = (0,_arrayFill_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .Z)(offsetAttribute, offsetValue);\n    }\n\n    attributes.applyOffset = new _GeometryAttribute_js__WEBPACK_IMPORTED_MODULE_13__/* ["default"] */ .Z({\n      componentDatatype: _ComponentDatatype_js__WEBPACK_IMPORTED_MODULE_6__/* ["default"].UNSIGNED_BYTE */ .Z.UNSIGNED_BYTE,\n      componentsPerAttribute: 1,\n      values: offsetAttribute,\n    });\n  }\n\n  return attributes;\n}\n\nfunction topIndices(numPts) {\n  // numTriangles in half = 3 + 8 + 12 + ... = -1 + 4 + (4 + 4) + (4 + 4 + 4) + ... = -1 + 4 * (1 + 2 + 3 + ...)\n  //              = -1 + 4 * ((n * ( n + 1)) / 2)\n  // total triangles = 2 * numTrangles in half\n  // indices = total triangles * 3;\n  // Substitute numPts for n above\n\n  var indices = new Array(12 * (numPts * (numPts + 1)) - 6);\n  var indicesIndex = 0;\n  var prevIndex;\n  var numInterior;\n  var positionIndex;\n  var i;\n  var j;\n  // Indices triangles to the \'right\' of the north vector\n\n  prevIndex = 0;\n  positionIndex = 1;\n  for (i = 0; i < 3; i++) {\n    indices[indicesIndex++] = positionIndex++;\n    indices[indicesIndex++] = prevIndex;\n    indices[indicesIndex++] = positionIndex;\n  }\n\n  for (i = 2; i < numPts + 1; ++i) {\n    positionIndex = i * (i + 1) - 1;\n    prevIndex = (i - 1) * i - 1;\n\n    indices[indicesIndex++] = positionIndex++;\n    indices[indicesIndex++] = prevIndex;\n    indices[indicesIndex++] = positionIndex;\n\n    numInterior = 2 * i;\n    for (j = 0; j < numInterior - 1; ++j) {\n      indices[indicesIndex++] = positionIndex;\n      indices[indicesIndex++] = prevIndex++;\n      indices[indicesIndex++] = prevIndex;\n\n      indices[indicesIndex++] = positionIndex++;\n      indices[indicesIndex++] = prevIndex;\n      indices[indicesIndex++] = positionIndex;\n    }\n\n    indices[indicesIndex++] = positionIndex++;\n    indices[indicesIndex++] = prevIndex;\n    indices[indicesIndex++] = positionIndex;\n  }\n\n  // Indices for center column of triangles\n  numInterior = numPts * 2;\n  ++positionIndex;\n  ++prevIndex;\n  for (i = 0; i < numInterior - 1; ++i) {\n    indices[indicesIndex++] = positionIndex;\n    indices[indicesIndex++] = prevIndex++;\n    indices[indicesIndex++] = prevIndex;\n\n    indices[indicesIndex++] = positionIndex++;\n    indices[indicesIndex++] = prevIndex;\n    indices[indicesIndex++] = positionIndex;\n  }\n\n  indices[indicesIndex++] = positionIndex;\n  indices[indicesIndex++] = prevIndex++;\n  indices[indicesIndex++] = prevIndex;\n\n  indices[indicesIndex++] = positionIndex++;\n  indices[indicesIndex++] = prevIndex++;\n  indices[indicesIndex++] = prevIndex;\n\n  // Reverse the process creating indices to the \'left\' of the north vector\n  ++prevIndex;\n  for (i = numPts - 1; i > 1; --i) {\n    indices[indicesIndex++] = prevIndex++;\n    indices[indicesIndex++] = prevIndex;\n    indices[indicesIndex++] = positionIndex;\n\n    numInterior = 2 * i;\n    for (j = 0; j < numInterior - 1; ++j) {\n      indices[indicesIndex++] = positionIndex;\n      indices[indicesIndex++] = prevIndex++;\n      indices[indicesIndex++] = prevIndex;\n\n      indices[indicesIndex++] = positionIndex++;\n      indices[indicesIndex++] = prevIndex;\n      indices[indicesIndex++] = positionIndex;\n    }\n\n    indices[indicesIndex++] = prevIndex++;\n    indices[indicesIndex++] = prevIndex++;\n    indices[indicesIndex++] = positionIndex++;\n  }\n\n  for (i = 0; i < 3; i++) {\n    indices[indicesIndex++] = prevIndex++;\n    indices[indicesIndex++] = prevIndex;\n    indices[indicesIndex++] = positionIndex;\n  }\n  return indices;\n}\n\nvar boundingSphereCenter = new _Cartesian3_js__WEBPACK_IMPORTED_MODULE_3__/* ["default"] */ .Z();\n\nfunction computeEllipse(options) {\n  var center = options.center;\n  boundingSphereCenter = _Cartesian3_js__WEBPACK_IMPORTED_MODULE_3__/* ["default"].multiplyByScalar */ .Z.multiplyByScalar(\n    options.ellipsoid.geodeticSurfaceNormal(center, boundingSphereCenter),\n    options.height,\n    boundingSphereCenter\n  );\n  boundingSphereCenter = _Cartesian3_js__WEBPACK_IMPORTED_MODULE_3__/* ["default"].add */ .Z.add(\n    center,\n    boundingSphereCenter,\n    boundingSphereCenter\n  );\n  var boundingSphere = new _BoundingSphere_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .Z(\n    boundingSphereCenter,\n    options.semiMajorAxis\n  );\n  var cep = _EllipseGeometryLibrary_js__WEBPACK_IMPORTED_MODULE_9__/* ["default"].computeEllipsePositions */ .Z.computeEllipsePositions(\n    options,\n    true,\n    false\n  );\n  var positions = cep.positions;\n  var numPts = cep.numPts;\n  var attributes = computeTopBottomAttributes(positions, options, false);\n  var indices = topIndices(numPts);\n  indices = _IndexDatatype_js__WEBPACK_IMPORTED_MODULE_18__/* ["default"].createTypedArray */ .Z.createTypedArray(positions.length / 3, indices);\n  return {\n    boundingSphere: boundingSphere,\n    attributes: attributes,\n    indices: indices,\n  };\n}\n\nfunction computeWallAttributes(positions, options) {\n  var vertexFormat = options.vertexFormat;\n  var center = options.center;\n  var semiMajorAxis = options.semiMajorAxis;\n  var semiMinorAxis = options.semiMinorAxis;\n  var ellipsoid = options.ellipsoid;\n  var height = options.height;\n  var extrudedHeight = options.extrudedHeight;\n  var stRotation = options.stRotation;\n  var size = (positions.length / 3) * 2;\n\n  var finalPositions = new Float64Array(size * 3);\n  var textureCoordinates = vertexFormat.st\n    ? new Float32Array(size * 2)\n    : undefined;\n  var normals = vertexFormat.normal ? new Float32Array(size * 3) : undefined;\n  var tangents = vertexFormat.tangent ? new Float32Array(size * 3) : undefined;\n  var bitangents = vertexFormat.bitangent\n    ? new Float32Array(size * 3)\n    : undefined;\n\n  var shadowVolume = options.shadowVolume;\n  var extrudeNormals = shadowVolume ? new Float32Array(size * 3) : undefined;\n\n  var textureCoordIndex = 0;\n\n  // Raise positions to a height above the ellipsoid and compute the\n  // texture coordinates, normals, tangents, and bitangents.\n  var normal = scratchNormal;\n  var tangent = scratchTangent;\n  var bitangent = scratchBitangent;\n\n  var projection = new _GeographicProjection_js__WEBPACK_IMPORTED_MODULE_11__/* ["default"] */ .Z(ellipsoid);\n  var projectedCenter = projection.project(\n    ellipsoid.cartesianToCartographic(center, scratchCartographic),\n    projectedCenterScratch\n  );\n\n  var geodeticNormal = ellipsoid.scaleToGeodeticSurface(\n    center,\n    scratchCartesian1\n  );\n  ellipsoid.geodeticSurfaceNormal(geodeticNormal, geodeticNormal);\n  var rotation = _Quaternion_js__WEBPACK_IMPORTED_MODULE_22__/* ["default"].fromAxisAngle */ .Z.fromAxisAngle(\n    geodeticNormal,\n    stRotation,\n    quaternionScratch\n  );\n  var textureMatrix = _Matrix3_js__WEBPACK_IMPORTED_MODULE_20__/* ["default"].fromQuaternion */ .Z.fromQuaternion(rotation, textureMatrixScratch);\n\n  var minTexCoord = _Cartesian2_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"].fromElements */ .Z.fromElements(\n    Number.POSITIVE_INFINITY,\n    Number.POSITIVE_INFINITY,\n    scratchMinTexCoord\n  );\n  var maxTexCoord = _Cartesian2_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"].fromElements */ .Z.fromElements(\n    Number.NEGATIVE_INFINITY,\n    Number.NEGATIVE_INFINITY,\n    scratchMaxTexCoord\n  );\n\n  var length = positions.length;\n  var stOffset = (length / 3) * 2;\n  for (var i = 0; i < length; i += 3) {\n    var i1 = i + 1;\n    var i2 = i + 2;\n    var position = _Cartesian3_js__WEBPACK_IMPORTED_MODULE_3__/* ["default"].fromArray */ .Z.fromArray(positions, i, scratchCartesian1);\n    var extrudedPosition;\n\n    if (vertexFormat.st) {\n      var rotatedPoint = _Matrix3_js__WEBPACK_IMPORTED_MODULE_20__/* ["default"].multiplyByVector */ .Z.multiplyByVector(\n        textureMatrix,\n        position,\n        scratchCartesian2\n      );\n      var projectedPoint = projection.project(\n        ellipsoid.cartesianToCartographic(rotatedPoint, scratchCartographic),\n        scratchCartesian3\n      );\n      _Cartesian3_js__WEBPACK_IMPORTED_MODULE_3__/* ["default"].subtract */ .Z.subtract(projectedPoint, projectedCenter, projectedPoint);\n\n      texCoordScratch.x =\n        (projectedPoint.x + semiMajorAxis) / (2.0 * semiMajorAxis);\n      texCoordScratch.y =\n        (projectedPoint.y + semiMinorAxis) / (2.0 * semiMinorAxis);\n\n      minTexCoord.x = Math.min(texCoordScratch.x, minTexCoord.x);\n      minTexCoord.y = Math.min(texCoordScratch.y, minTexCoord.y);\n      maxTexCoord.x = Math.max(texCoordScratch.x, maxTexCoord.x);\n      maxTexCoord.y = Math.max(texCoordScratch.y, maxTexCoord.y);\n\n      textureCoordinates[textureCoordIndex + stOffset] = texCoordScratch.x;\n      textureCoordinates[textureCoordIndex + 1 + stOffset] = texCoordScratch.y;\n\n      textureCoordinates[textureCoordIndex++] = texCoordScratch.x;\n      textureCoordinates[textureCoordIndex++] = texCoordScratch.y;\n    }\n\n    position = ellipsoid.scaleToGeodeticSurface(position, position);\n    extrudedPosition = _Cartesian3_js__WEBPACK_IMPORTED_MODULE_3__/* ["default"].clone */ .Z.clone(position, scratchCartesian2);\n    normal = ellipsoid.geodeticSurfaceNormal(position, normal);\n\n    if (shadowVolume) {\n      extrudeNormals[i + length] = -normal.x;\n      extrudeNormals[i1 + length] = -normal.y;\n      extrudeNormals[i2 + length] = -normal.z;\n    }\n\n    var scaledNormal = _Cartesian3_js__WEBPACK_IMPORTED_MODULE_3__/* ["default"].multiplyByScalar */ .Z.multiplyByScalar(\n      normal,\n      height,\n      scratchCartesian4\n    );\n    position = _Cartesian3_js__WEBPACK_IMPORTED_MODULE_3__/* ["default"].add */ .Z.add(position, scaledNormal, position);\n    scaledNormal = _Cartesian3_js__WEBPACK_IMPORTED_MODULE_3__/* ["default"].multiplyByScalar */ .Z.multiplyByScalar(\n      normal,\n      extrudedHeight,\n      scaledNormal\n    );\n    extrudedPosition = _Cartesian3_js__WEBPACK_IMPORTED_MODULE_3__/* ["default"].add */ .Z.add(\n      extrudedPosition,\n      scaledNormal,\n      extrudedPosition\n    );\n\n    if (vertexFormat.position) {\n      finalPositions[i + length] = extrudedPosition.x;\n      finalPositions[i1 + length] = extrudedPosition.y;\n      finalPositions[i2 + length] = extrudedPosition.z;\n\n      finalPositions[i] = position.x;\n      finalPositions[i1] = position.y;\n      finalPositions[i2] = position.z;\n    }\n\n    if (vertexFormat.normal || vertexFormat.tangent || vertexFormat.bitangent) {\n      bitangent = _Cartesian3_js__WEBPACK_IMPORTED_MODULE_3__/* ["default"].clone */ .Z.clone(normal, bitangent);\n      var next = _Cartesian3_js__WEBPACK_IMPORTED_MODULE_3__/* ["default"].fromArray */ .Z.fromArray(\n        positions,\n        (i + 3) % length,\n        scratchCartesian4\n      );\n      _Cartesian3_js__WEBPACK_IMPORTED_MODULE_3__/* ["default"].subtract */ .Z.subtract(next, position, next);\n      var bottom = _Cartesian3_js__WEBPACK_IMPORTED_MODULE_3__/* ["default"].subtract */ .Z.subtract(\n        extrudedPosition,\n        position,\n        scratchCartesian3\n      );\n\n      normal = _Cartesian3_js__WEBPACK_IMPORTED_MODULE_3__/* ["default"].normalize */ .Z.normalize(\n        _Cartesian3_js__WEBPACK_IMPORTED_MODULE_3__/* ["default"].cross */ .Z.cross(bottom, next, normal),\n        normal\n      );\n\n      if (vertexFormat.normal) {\n        normals[i] = normal.x;\n        normals[i1] = normal.y;\n        normals[i2] = normal.z;\n\n        normals[i + length] = normal.x;\n        normals[i1 + length] = normal.y;\n        normals[i2 + length] = normal.z;\n      }\n\n      if (vertexFormat.tangent) {\n        tangent = _Cartesian3_js__WEBPACK_IMPORTED_MODULE_3__/* ["default"].normalize */ .Z.normalize(\n          _Cartesian3_js__WEBPACK_IMPORTED_MODULE_3__/* ["default"].cross */ .Z.cross(bitangent, normal, tangent),\n          tangent\n        );\n        tangents[i] = tangent.x;\n        tangents[i1] = tangent.y;\n        tangents[i2] = tangent.z;\n\n        tangents[i + length] = tangent.x;\n        tangents[i + 1 + length] = tangent.y;\n        tangents[i + 2 + length] = tangent.z;\n      }\n\n      if (vertexFormat.bitangent) {\n        bitangents[i] = bitangent.x;\n        bitangents[i1] = bitangent.y;\n        bitangents[i2] = bitangent.z;\n\n        bitangents[i + length] = bitangent.x;\n        bitangents[i1 + length] = bitangent.y;\n        bitangents[i2 + length] = bitangent.z;\n      }\n    }\n  }\n\n  if (vertexFormat.st) {\n    length = textureCoordinates.length;\n    for (var k = 0; k < length; k += 2) {\n      textureCoordinates[k] =\n        (textureCoordinates[k] - minTexCoord.x) /\n        (maxTexCoord.x - minTexCoord.x);\n      textureCoordinates[k + 1] =\n        (textureCoordinates[k + 1] - minTexCoord.y) /\n        (maxTexCoord.y - minTexCoord.y);\n    }\n  }\n\n  var attributes = new _GeometryAttributes_js__WEBPACK_IMPORTED_MODULE_14__/* ["default"] */ .Z();\n\n  if (vertexFormat.position) {\n    attributes.position = new _GeometryAttribute_js__WEBPACK_IMPORTED_MODULE_13__/* ["default"] */ .Z({\n      componentDatatype: _ComponentDatatype_js__WEBPACK_IMPORTED_MODULE_6__/* ["default"].DOUBLE */ .Z.DOUBLE,\n      componentsPerAttribute: 3,\n      values: finalPositions,\n    });\n  }\n\n  if (vertexFormat.st) {\n    attributes.st = new _GeometryAttribute_js__WEBPACK_IMPORTED_MODULE_13__/* ["default"] */ .Z({\n      componentDatatype: _ComponentDatatype_js__WEBPACK_IMPORTED_MODULE_6__/* ["default"].FLOAT */ .Z.FLOAT,\n      componentsPerAttribute: 2,\n      values: textureCoordinates,\n    });\n  }\n\n  if (vertexFormat.normal) {\n    attributes.normal = new _GeometryAttribute_js__WEBPACK_IMPORTED_MODULE_13__/* ["default"] */ .Z({\n      componentDatatype: _ComponentDatatype_js__WEBPACK_IMPORTED_MODULE_6__/* ["default"].FLOAT */ .Z.FLOAT,\n      componentsPerAttribute: 3,\n      values: normals,\n    });\n  }\n\n  if (vertexFormat.tangent) {\n    attributes.tangent = new _GeometryAttribute_js__WEBPACK_IMPORTED_MODULE_13__/* ["default"] */ .Z({\n      componentDatatype: _ComponentDatatype_js__WEBPACK_IMPORTED_MODULE_6__/* ["default"].FLOAT */ .Z.FLOAT,\n      componentsPerAttribute: 3,\n      values: tangents,\n    });\n  }\n\n  if (vertexFormat.bitangent) {\n    attributes.bitangent = new _GeometryAttribute_js__WEBPACK_IMPORTED_MODULE_13__/* ["default"] */ .Z({\n      componentDatatype: _ComponentDatatype_js__WEBPACK_IMPORTED_MODULE_6__/* ["default"].FLOAT */ .Z.FLOAT,\n      componentsPerAttribute: 3,\n      values: bitangents,\n    });\n  }\n\n  if (shadowVolume) {\n    attributes.extrudeDirection = new _GeometryAttribute_js__WEBPACK_IMPORTED_MODULE_13__/* ["default"] */ .Z({\n      componentDatatype: _ComponentDatatype_js__WEBPACK_IMPORTED_MODULE_6__/* ["default"].FLOAT */ .Z.FLOAT,\n      componentsPerAttribute: 3,\n      values: extrudeNormals,\n    });\n  }\n\n  if ((0,_defined_js__WEBPACK_IMPORTED_MODULE_25__/* ["default"] */ .Z)(options.offsetAttribute)) {\n    var offsetAttribute = new Uint8Array(size);\n    if (options.offsetAttribute === _GeometryOffsetAttribute_js__WEBPACK_IMPORTED_MODULE_16__/* ["default"].TOP */ .Z.TOP) {\n      offsetAttribute = (0,_arrayFill_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .Z)(offsetAttribute, 1, 0, size / 2);\n    } else {\n      var offsetValue =\n        options.offsetAttribute === _GeometryOffsetAttribute_js__WEBPACK_IMPORTED_MODULE_16__/* ["default"].NONE */ .Z.NONE ? 0 : 1;\n      offsetAttribute = (0,_arrayFill_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .Z)(offsetAttribute, offsetValue);\n    }\n    attributes.applyOffset = new _GeometryAttribute_js__WEBPACK_IMPORTED_MODULE_13__/* ["default"] */ .Z({\n      componentDatatype: _ComponentDatatype_js__WEBPACK_IMPORTED_MODULE_6__/* ["default"].UNSIGNED_BYTE */ .Z.UNSIGNED_BYTE,\n      componentsPerAttribute: 1,\n      values: offsetAttribute,\n    });\n  }\n\n  return attributes;\n}\n\nfunction computeWallIndices(positions) {\n  var length = positions.length / 3;\n  var indices = _IndexDatatype_js__WEBPACK_IMPORTED_MODULE_18__/* ["default"].createTypedArray */ .Z.createTypedArray(length, length * 6);\n  var index = 0;\n  for (var i = 0; i < length; i++) {\n    var UL = i;\n    var LL = i + length;\n    var UR = (UL + 1) % length;\n    var LR = UR + length;\n    indices[index++] = UL;\n    indices[index++] = LL;\n    indices[index++] = UR;\n    indices[index++] = UR;\n    indices[index++] = LL;\n    indices[index++] = LR;\n  }\n\n  return indices;\n}\n\nvar topBoundingSphere = new _BoundingSphere_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .Z();\nvar bottomBoundingSphere = new _BoundingSphere_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .Z();\n\nfunction computeExtrudedEllipse(options) {\n  var center = options.center;\n  var ellipsoid = options.ellipsoid;\n  var semiMajorAxis = options.semiMajorAxis;\n  var scaledNormal = _Cartesian3_js__WEBPACK_IMPORTED_MODULE_3__/* ["default"].multiplyByScalar */ .Z.multiplyByScalar(\n    ellipsoid.geodeticSurfaceNormal(center, scratchCartesian1),\n    options.height,\n    scratchCartesian1\n  );\n  topBoundingSphere.center = _Cartesian3_js__WEBPACK_IMPORTED_MODULE_3__/* ["default"].add */ .Z.add(\n    center,\n    scaledNormal,\n    topBoundingSphere.center\n  );\n  topBoundingSphere.radius = semiMajorAxis;\n\n  scaledNormal = _Cartesian3_js__WEBPACK_IMPORTED_MODULE_3__/* ["default"].multiplyByScalar */ .Z.multiplyByScalar(\n    ellipsoid.geodeticSurfaceNormal(center, scaledNormal),\n    options.extrudedHeight,\n    scaledNormal\n  );\n  bottomBoundingSphere.center = _Cartesian3_js__WEBPACK_IMPORTED_MODULE_3__/* ["default"].add */ .Z.add(\n    center,\n    scaledNormal,\n    bottomBoundingSphere.center\n  );\n  bottomBoundingSphere.radius = semiMajorAxis;\n\n  var cep = _EllipseGeometryLibrary_js__WEBPACK_IMPORTED_MODULE_9__/* ["default"].computeEllipsePositions */ .Z.computeEllipsePositions(options, true, true);\n  var positions = cep.positions;\n  var numPts = cep.numPts;\n  var outerPositions = cep.outerPositions;\n  var boundingSphere = _BoundingSphere_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"].union */ .Z.union(\n    topBoundingSphere,\n    bottomBoundingSphere\n  );\n  var topBottomAttributes = computeTopBottomAttributes(\n    positions,\n    options,\n    true\n  );\n  var indices = topIndices(numPts);\n  var length = indices.length;\n  indices.length = length * 2;\n  var posLength = positions.length / 3;\n  for (var i = 0; i < length; i += 3) {\n    indices[i + length] = indices[i + 2] + posLength;\n    indices[i + 1 + length] = indices[i + 1] + posLength;\n    indices[i + 2 + length] = indices[i] + posLength;\n  }\n\n  var topBottomIndices = _IndexDatatype_js__WEBPACK_IMPORTED_MODULE_18__/* ["default"].createTypedArray */ .Z.createTypedArray(\n    (posLength * 2) / 3,\n    indices\n  );\n\n  var topBottomGeo = new _Geometry_js__WEBPACK_IMPORTED_MODULE_12__/* ["default"] */ .Z({\n    attributes: topBottomAttributes,\n    indices: topBottomIndices,\n    primitiveType: _PrimitiveType_js__WEBPACK_IMPORTED_MODULE_21__/* ["default"].TRIANGLES */ .Z.TRIANGLES,\n  });\n\n  var wallAttributes = computeWallAttributes(outerPositions, options);\n  indices = computeWallIndices(outerPositions);\n  var wallIndices = _IndexDatatype_js__WEBPACK_IMPORTED_MODULE_18__/* ["default"].createTypedArray */ .Z.createTypedArray(\n    (outerPositions.length * 2) / 3,\n    indices\n  );\n\n  var wallGeo = new _Geometry_js__WEBPACK_IMPORTED_MODULE_12__/* ["default"] */ .Z({\n    attributes: wallAttributes,\n    indices: wallIndices,\n    primitiveType: _PrimitiveType_js__WEBPACK_IMPORTED_MODULE_21__/* ["default"].TRIANGLES */ .Z.TRIANGLES,\n  });\n\n  var geo = _GeometryPipeline_js__WEBPACK_IMPORTED_MODULE_17__/* ["default"].combineInstances */ .Z.combineInstances([\n    new _GeometryInstance_js__WEBPACK_IMPORTED_MODULE_15__/* ["default"] */ .Z({\n      geometry: topBottomGeo,\n    }),\n    new _GeometryInstance_js__WEBPACK_IMPORTED_MODULE_15__/* ["default"] */ .Z({\n      geometry: wallGeo,\n    }),\n  ]);\n\n  return {\n    boundingSphere: boundingSphere,\n    attributes: geo[0].attributes,\n    indices: geo[0].indices,\n  };\n}\n\nfunction computeRectangle(\n  center,\n  semiMajorAxis,\n  semiMinorAxis,\n  rotation,\n  granularity,\n  ellipsoid,\n  result\n) {\n  var cep = _EllipseGeometryLibrary_js__WEBPACK_IMPORTED_MODULE_9__/* ["default"].computeEllipsePositions */ .Z.computeEllipsePositions(\n    {\n      center: center,\n      semiMajorAxis: semiMajorAxis,\n      semiMinorAxis: semiMinorAxis,\n      rotation: rotation,\n      granularity: granularity,\n    },\n    false,\n    true\n  );\n  var positionsFlat = cep.outerPositions;\n  var positionsCount = positionsFlat.length / 3;\n  var positions = new Array(positionsCount);\n  for (var i = 0; i < positionsCount; ++i) {\n    positions[i] = _Cartesian3_js__WEBPACK_IMPORTED_MODULE_3__/* ["default"].fromArray */ .Z.fromArray(positionsFlat, i * 3);\n  }\n  var rectangle = _Rectangle_js__WEBPACK_IMPORTED_MODULE_23__/* ["default"].fromCartesianArray */ .Z.fromCartesianArray(positions, ellipsoid, result);\n  // Rectangle width goes beyond 180 degrees when the ellipse crosses a pole.\n  // When this happens, make the rectangle into a "circle" around the pole\n  if (rectangle.width > _Math_js__WEBPACK_IMPORTED_MODULE_19__/* ["default"].PI */ .Z.PI) {\n    rectangle.north =\n      rectangle.north > 0.0\n        ? _Math_js__WEBPACK_IMPORTED_MODULE_19__/* ["default"].PI_OVER_TWO */ .Z.PI_OVER_TWO - _Math_js__WEBPACK_IMPORTED_MODULE_19__/* ["default"].EPSILON7 */ .Z.EPSILON7\n        : rectangle.north;\n    rectangle.south =\n      rectangle.south < 0.0\n        ? _Math_js__WEBPACK_IMPORTED_MODULE_19__/* ["default"].EPSILON7 */ .Z.EPSILON7 - _Math_js__WEBPACK_IMPORTED_MODULE_19__/* ["default"].PI_OVER_TWO */ .Z.PI_OVER_TWO\n        : rectangle.south;\n    rectangle.east = _Math_js__WEBPACK_IMPORTED_MODULE_19__/* ["default"].PI */ .Z.PI;\n    rectangle.west = -_Math_js__WEBPACK_IMPORTED_MODULE_19__/* ["default"].PI */ .Z.PI;\n  }\n  return rectangle;\n}\n\n/**\n * A description of an ellipse on an ellipsoid. Ellipse geometry can be rendered with both {@link Primitive} and {@link GroundPrimitive}.\n *\n * @alias EllipseGeometry\n * @constructor\n *\n * @param {Object} options Object with the following properties:\n * @param {Cartesian3} options.center The ellipse\'s center point in the fixed frame.\n * @param {Number} options.semiMajorAxis The length of the ellipse\'s semi-major axis in meters.\n * @param {Number} options.semiMinorAxis The length of the ellipse\'s semi-minor axis in meters.\n * @param {Ellipsoid} [options.ellipsoid=Ellipsoid.WGS84] The ellipsoid the ellipse will be on.\n * @param {Number} [options.height=0.0] The distance in meters between the ellipse and the ellipsoid surface.\n * @param {Number} [options.extrudedHeight] The distance in meters between the ellipse\'s extruded face and the ellipsoid surface.\n * @param {Number} [options.rotation=0.0] The angle of rotation counter-clockwise from north.\n * @param {Number} [options.stRotation=0.0] The rotation of the texture coordinates counter-clockwise from north.\n * @param {Number} [options.granularity=CesiumMath.RADIANS_PER_DEGREE] The angular distance between points on the ellipse in radians.\n * @param {VertexFormat} [options.vertexFormat=VertexFormat.DEFAULT] The vertex attributes to be computed.\n *\n * @exception {DeveloperError} semiMajorAxis and semiMinorAxis must be greater than zero.\n * @exception {DeveloperError} semiMajorAxis must be greater than or equal to the semiMinorAxis.\n * @exception {DeveloperError} granularity must be greater than zero.\n *\n *\n * @example\n * // Create an ellipse.\n * var ellipse = new Cesium.EllipseGeometry({\n *   center : Cesium.Cartesian3.fromDegrees(-75.59777, 40.03883),\n *   semiMajorAxis : 500000.0,\n *   semiMinorAxis : 300000.0,\n *   rotation : Cesium.Math.toRadians(60.0)\n * });\n * var geometry = Cesium.EllipseGeometry.createGeometry(ellipse);\n *\n * @see EllipseGeometry.createGeometry\n */\nfunction EllipseGeometry(options) {\n  options = (0,_defaultValue_js__WEBPACK_IMPORTED_MODULE_7__/* ["default"] */ .Z)(options, _defaultValue_js__WEBPACK_IMPORTED_MODULE_7__/* ["default"].EMPTY_OBJECT */ .Z.EMPTY_OBJECT);\n\n  var center = options.center;\n  var ellipsoid = (0,_defaultValue_js__WEBPACK_IMPORTED_MODULE_7__/* ["default"] */ .Z)(options.ellipsoid, _Ellipsoid_js__WEBPACK_IMPORTED_MODULE_10__/* ["default"].WGS84 */ .Z.WGS84);\n  var semiMajorAxis = options.semiMajorAxis;\n  var semiMinorAxis = options.semiMinorAxis;\n  var granularity = (0,_defaultValue_js__WEBPACK_IMPORTED_MODULE_7__/* ["default"] */ .Z)(\n    options.granularity,\n    _Math_js__WEBPACK_IMPORTED_MODULE_19__/* ["default"].RADIANS_PER_DEGREE */ .Z.RADIANS_PER_DEGREE\n  );\n  var vertexFormat = (0,_defaultValue_js__WEBPACK_IMPORTED_MODULE_7__/* ["default"] */ .Z)(options.vertexFormat, _VertexFormat_js__WEBPACK_IMPORTED_MODULE_24__/* ["default"].DEFAULT */ .Z.DEFAULT);\n\n  //>>includeStart(\'debug\', pragmas.debug);\n  _Check_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"].defined */ .Z.defined("options.center", center);\n  _Check_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"].typeOf.number */ .Z.typeOf.number("options.semiMajorAxis", semiMajorAxis);\n  _Check_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"].typeOf.number */ .Z.typeOf.number("options.semiMinorAxis", semiMinorAxis);\n  if (semiMajorAxis < semiMinorAxis) {\n    throw new _DeveloperError_js__WEBPACK_IMPORTED_MODULE_8__/* ["default"] */ .Z(\n      "semiMajorAxis must be greater than or equal to the semiMinorAxis."\n    );\n  }\n  if (granularity <= 0.0) {\n    throw new _DeveloperError_js__WEBPACK_IMPORTED_MODULE_8__/* ["default"] */ .Z("granularity must be greater than zero.");\n  }\n  //>>includeEnd(\'debug\');\n\n  var height = (0,_defaultValue_js__WEBPACK_IMPORTED_MODULE_7__/* ["default"] */ .Z)(options.height, 0.0);\n  var extrudedHeight = (0,_defaultValue_js__WEBPACK_IMPORTED_MODULE_7__/* ["default"] */ .Z)(options.extrudedHeight, height);\n\n  this._center = _Cartesian3_js__WEBPACK_IMPORTED_MODULE_3__/* ["default"].clone */ .Z.clone(center);\n  this._semiMajorAxis = semiMajorAxis;\n  this._semiMinorAxis = semiMinorAxis;\n  this._ellipsoid = _Ellipsoid_js__WEBPACK_IMPORTED_MODULE_10__/* ["default"].clone */ .Z.clone(ellipsoid);\n  this._rotation = (0,_defaultValue_js__WEBPACK_IMPORTED_MODULE_7__/* ["default"] */ .Z)(options.rotation, 0.0);\n  this._stRotation = (0,_defaultValue_js__WEBPACK_IMPORTED_MODULE_7__/* ["default"] */ .Z)(options.stRotation, 0.0);\n  this._height = Math.max(extrudedHeight, height);\n  this._granularity = granularity;\n  this._vertexFormat = _VertexFormat_js__WEBPACK_IMPORTED_MODULE_24__/* ["default"].clone */ .Z.clone(vertexFormat);\n  this._extrudedHeight = Math.min(extrudedHeight, height);\n  this._shadowVolume = (0,_defaultValue_js__WEBPACK_IMPORTED_MODULE_7__/* ["default"] */ .Z)(options.shadowVolume, false);\n  this._workerName = "createEllipseGeometry";\n  this._offsetAttribute = options.offsetAttribute;\n\n  this._rectangle = undefined;\n  this._textureCoordinateRotationPoints = undefined;\n}\n\n/**\n * The number of elements used to pack the object into an array.\n * @type {Number}\n */\nEllipseGeometry.packedLength =\n  _Cartesian3_js__WEBPACK_IMPORTED_MODULE_3__/* ["default"].packedLength */ .Z.packedLength +\n  _Ellipsoid_js__WEBPACK_IMPORTED_MODULE_10__/* ["default"].packedLength */ .Z.packedLength +\n  _VertexFormat_js__WEBPACK_IMPORTED_MODULE_24__/* ["default"].packedLength */ .Z.packedLength +\n  9;\n\n/**\n * Stores the provided instance into the provided array.\n *\n * @param {EllipseGeometry} value The value to pack.\n * @param {Number[]} array The array to pack into.\n * @param {Number} [startingIndex=0] The index into the array at which to start packing the elements.\n *\n * @returns {Number[]} The array that was packed into\n */\nEllipseGeometry.pack = function (value, array, startingIndex) {\n  //>>includeStart(\'debug\', pragmas.debug);\n  _Check_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"].defined */ .Z.defined("value", value);\n  _Check_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"].defined */ .Z.defined("array", array);\n  //>>includeEnd(\'debug\');\n\n  startingIndex = (0,_defaultValue_js__WEBPACK_IMPORTED_MODULE_7__/* ["default"] */ .Z)(startingIndex, 0);\n\n  _Cartesian3_js__WEBPACK_IMPORTED_MODULE_3__/* ["default"].pack */ .Z.pack(value._center, array, startingIndex);\n  startingIndex += _Cartesian3_js__WEBPACK_IMPORTED_MODULE_3__/* ["default"].packedLength */ .Z.packedLength;\n\n  _Ellipsoid_js__WEBPACK_IMPORTED_MODULE_10__/* ["default"].pack */ .Z.pack(value._ellipsoid, array, startingIndex);\n  startingIndex += _Ellipsoid_js__WEBPACK_IMPORTED_MODULE_10__/* ["default"].packedLength */ .Z.packedLength;\n\n  _VertexFormat_js__WEBPACK_IMPORTED_MODULE_24__/* ["default"].pack */ .Z.pack(value._vertexFormat, array, startingIndex);\n  startingIndex += _VertexFormat_js__WEBPACK_IMPORTED_MODULE_24__/* ["default"].packedLength */ .Z.packedLength;\n\n  array[startingIndex++] = value._semiMajorAxis;\n  array[startingIndex++] = value._semiMinorAxis;\n  array[startingIndex++] = value._rotation;\n  array[startingIndex++] = value._stRotation;\n  array[startingIndex++] = value._height;\n  array[startingIndex++] = value._granularity;\n  array[startingIndex++] = value._extrudedHeight;\n  array[startingIndex++] = value._shadowVolume ? 1.0 : 0.0;\n  array[startingIndex] = (0,_defaultValue_js__WEBPACK_IMPORTED_MODULE_7__/* ["default"] */ .Z)(value._offsetAttribute, -1);\n\n  return array;\n};\n\nvar scratchCenter = new _Cartesian3_js__WEBPACK_IMPORTED_MODULE_3__/* ["default"] */ .Z();\nvar scratchEllipsoid = new _Ellipsoid_js__WEBPACK_IMPORTED_MODULE_10__/* ["default"] */ .Z();\nvar scratchVertexFormat = new _VertexFormat_js__WEBPACK_IMPORTED_MODULE_24__/* ["default"] */ .Z();\nvar scratchOptions = {\n  center: scratchCenter,\n  ellipsoid: scratchEllipsoid,\n  vertexFormat: scratchVertexFormat,\n  semiMajorAxis: undefined,\n  semiMinorAxis: undefined,\n  rotation: undefined,\n  stRotation: undefined,\n  height: undefined,\n  granularity: undefined,\n  extrudedHeight: undefined,\n  shadowVolume: undefined,\n  offsetAttribute: undefined,\n};\n\n/**\n * Retrieves an instance from a packed array.\n *\n * @param {Number[]} array The packed array.\n * @param {Number} [startingIndex=0] The starting index of the element to be unpacked.\n * @param {EllipseGeometry} [result] The object into which to store the result.\n * @returns {EllipseGeometry} The modified result parameter or a new EllipseGeometry instance if one was not provided.\n */\nEllipseGeometry.unpack = function (array, startingIndex, result) {\n  //>>includeStart(\'debug\', pragmas.debug);\n  _Check_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"].defined */ .Z.defined("array", array);\n  //>>includeEnd(\'debug\');\n\n  startingIndex = (0,_defaultValue_js__WEBPACK_IMPORTED_MODULE_7__/* ["default"] */ .Z)(startingIndex, 0);\n\n  var center = _Cartesian3_js__WEBPACK_IMPORTED_MODULE_3__/* ["default"].unpack */ .Z.unpack(array, startingIndex, scratchCenter);\n  startingIndex += _Cartesian3_js__WEBPACK_IMPORTED_MODULE_3__/* ["default"].packedLength */ .Z.packedLength;\n\n  var ellipsoid = _Ellipsoid_js__WEBPACK_IMPORTED_MODULE_10__/* ["default"].unpack */ .Z.unpack(array, startingIndex, scratchEllipsoid);\n  startingIndex += _Ellipsoid_js__WEBPACK_IMPORTED_MODULE_10__/* ["default"].packedLength */ .Z.packedLength;\n\n  var vertexFormat = _VertexFormat_js__WEBPACK_IMPORTED_MODULE_24__/* ["default"].unpack */ .Z.unpack(\n    array,\n    startingIndex,\n    scratchVertexFormat\n  );\n  startingIndex += _VertexFormat_js__WEBPACK_IMPORTED_MODULE_24__/* ["default"].packedLength */ .Z.packedLength;\n\n  var semiMajorAxis = array[startingIndex++];\n  var semiMinorAxis = array[startingIndex++];\n  var rotation = array[startingIndex++];\n  var stRotation = array[startingIndex++];\n  var height = array[startingIndex++];\n  var granularity = array[startingIndex++];\n  var extrudedHeight = array[startingIndex++];\n  var shadowVolume = array[startingIndex++] === 1.0;\n  var offsetAttribute = array[startingIndex];\n\n  if (!(0,_defined_js__WEBPACK_IMPORTED_MODULE_25__/* ["default"] */ .Z)(result)) {\n    scratchOptions.height = height;\n    scratchOptions.extrudedHeight = extrudedHeight;\n    scratchOptions.granularity = granularity;\n    scratchOptions.stRotation = stRotation;\n    scratchOptions.rotation = rotation;\n    scratchOptions.semiMajorAxis = semiMajorAxis;\n    scratchOptions.semiMinorAxis = semiMinorAxis;\n    scratchOptions.shadowVolume = shadowVolume;\n    scratchOptions.offsetAttribute =\n      offsetAttribute === -1 ? undefined : offsetAttribute;\n\n    return new EllipseGeometry(scratchOptions);\n  }\n\n  result._center = _Cartesian3_js__WEBPACK_IMPORTED_MODULE_3__/* ["default"].clone */ .Z.clone(center, result._center);\n  result._ellipsoid = _Ellipsoid_js__WEBPACK_IMPORTED_MODULE_10__/* ["default"].clone */ .Z.clone(ellipsoid, result._ellipsoid);\n  result._vertexFormat = _VertexFormat_js__WEBPACK_IMPORTED_MODULE_24__/* ["default"].clone */ .Z.clone(vertexFormat, result._vertexFormat);\n  result._semiMajorAxis = semiMajorAxis;\n  result._semiMinorAxis = semiMinorAxis;\n  result._rotation = rotation;\n  result._stRotation = stRotation;\n  result._height = height;\n  result._granularity = granularity;\n  result._extrudedHeight = extrudedHeight;\n  result._shadowVolume = shadowVolume;\n  result._offsetAttribute =\n    offsetAttribute === -1 ? undefined : offsetAttribute;\n\n  return result;\n};\n\n/**\n * Computes the bounding rectangle based on the provided options\n *\n * @param {Object} options Object with the following properties:\n * @param {Cartesian3} options.center The ellipse\'s center point in the fixed frame.\n * @param {Number} options.semiMajorAxis The length of the ellipse\'s semi-major axis in meters.\n * @param {Number} options.semiMinorAxis The length of the ellipse\'s semi-minor axis in meters.\n * @param {Ellipsoid} [options.ellipsoid=Ellipsoid.WGS84] The ellipsoid the ellipse will be on.\n * @param {Number} [options.rotation=0.0] The angle of rotation counter-clockwise from north.\n * @param {Number} [options.granularity=CesiumMath.RADIANS_PER_DEGREE] The angular distance between points on the ellipse in radians.\n * @param {Rectangle} [result] An object in which to store the result\n *\n * @returns {Rectangle} The result rectangle\n */\nEllipseGeometry.computeRectangle = function (options, result) {\n  options = (0,_defaultValue_js__WEBPACK_IMPORTED_MODULE_7__/* ["default"] */ .Z)(options, _defaultValue_js__WEBPACK_IMPORTED_MODULE_7__/* ["default"].EMPTY_OBJECT */ .Z.EMPTY_OBJECT);\n\n  var center = options.center;\n  var ellipsoid = (0,_defaultValue_js__WEBPACK_IMPORTED_MODULE_7__/* ["default"] */ .Z)(options.ellipsoid, _Ellipsoid_js__WEBPACK_IMPORTED_MODULE_10__/* ["default"].WGS84 */ .Z.WGS84);\n  var semiMajorAxis = options.semiMajorAxis;\n  var semiMinorAxis = options.semiMinorAxis;\n  var granularity = (0,_defaultValue_js__WEBPACK_IMPORTED_MODULE_7__/* ["default"] */ .Z)(\n    options.granularity,\n    _Math_js__WEBPACK_IMPORTED_MODULE_19__/* ["default"].RADIANS_PER_DEGREE */ .Z.RADIANS_PER_DEGREE\n  );\n  var rotation = (0,_defaultValue_js__WEBPACK_IMPORTED_MODULE_7__/* ["default"] */ .Z)(options.rotation, 0.0);\n\n  //>>includeStart(\'debug\', pragmas.debug);\n  _Check_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"].defined */ .Z.defined("options.center", center);\n  _Check_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"].typeOf.number */ .Z.typeOf.number("options.semiMajorAxis", semiMajorAxis);\n  _Check_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"].typeOf.number */ .Z.typeOf.number("options.semiMinorAxis", semiMinorAxis);\n  if (semiMajorAxis < semiMinorAxis) {\n    throw new _DeveloperError_js__WEBPACK_IMPORTED_MODULE_8__/* ["default"] */ .Z(\n      "semiMajorAxis must be greater than or equal to the semiMinorAxis."\n    );\n  }\n  if (granularity <= 0.0) {\n    throw new _DeveloperError_js__WEBPACK_IMPORTED_MODULE_8__/* ["default"] */ .Z("granularity must be greater than zero.");\n  }\n  //>>includeEnd(\'debug\');\n\n  return computeRectangle(\n    center,\n    semiMajorAxis,\n    semiMinorAxis,\n    rotation,\n    granularity,\n    ellipsoid,\n    result\n  );\n};\n\n/**\n * Computes the geometric representation of a ellipse on an ellipsoid, including its vertices, indices, and a bounding sphere.\n *\n * @param {EllipseGeometry} ellipseGeometry A description of the ellipse.\n * @returns {Geometry|undefined} The computed vertices and indices.\n */\nEllipseGeometry.createGeometry = function (ellipseGeometry) {\n  if (\n    ellipseGeometry._semiMajorAxis <= 0.0 ||\n    ellipseGeometry._semiMinorAxis <= 0.0\n  ) {\n    return;\n  }\n\n  var height = ellipseGeometry._height;\n  var extrudedHeight = ellipseGeometry._extrudedHeight;\n  var extrude = !_Math_js__WEBPACK_IMPORTED_MODULE_19__/* ["default"].equalsEpsilon */ .Z.equalsEpsilon(\n    height,\n    extrudedHeight,\n    0,\n    _Math_js__WEBPACK_IMPORTED_MODULE_19__/* ["default"].EPSILON2 */ .Z.EPSILON2\n  );\n\n  ellipseGeometry._center = ellipseGeometry._ellipsoid.scaleToGeodeticSurface(\n    ellipseGeometry._center,\n    ellipseGeometry._center\n  );\n  var options = {\n    center: ellipseGeometry._center,\n    semiMajorAxis: ellipseGeometry._semiMajorAxis,\n    semiMinorAxis: ellipseGeometry._semiMinorAxis,\n    ellipsoid: ellipseGeometry._ellipsoid,\n    rotation: ellipseGeometry._rotation,\n    height: height,\n    granularity: ellipseGeometry._granularity,\n    vertexFormat: ellipseGeometry._vertexFormat,\n    stRotation: ellipseGeometry._stRotation,\n  };\n  var geometry;\n  if (extrude) {\n    options.extrudedHeight = extrudedHeight;\n    options.shadowVolume = ellipseGeometry._shadowVolume;\n    options.offsetAttribute = ellipseGeometry._offsetAttribute;\n    geometry = computeExtrudedEllipse(options);\n  } else {\n    geometry = computeEllipse(options);\n\n    if ((0,_defined_js__WEBPACK_IMPORTED_MODULE_25__/* ["default"] */ .Z)(ellipseGeometry._offsetAttribute)) {\n      var length = geometry.attributes.position.values.length;\n      var applyOffset = new Uint8Array(length / 3);\n      var offsetValue =\n        ellipseGeometry._offsetAttribute === _GeometryOffsetAttribute_js__WEBPACK_IMPORTED_MODULE_16__/* ["default"].NONE */ .Z.NONE\n          ? 0\n          : 1;\n      (0,_arrayFill_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .Z)(applyOffset, offsetValue);\n      geometry.attributes.applyOffset = new _GeometryAttribute_js__WEBPACK_IMPORTED_MODULE_13__/* ["default"] */ .Z({\n        componentDatatype: _ComponentDatatype_js__WEBPACK_IMPORTED_MODULE_6__/* ["default"].UNSIGNED_BYTE */ .Z.UNSIGNED_BYTE,\n        componentsPerAttribute: 1,\n        values: applyOffset,\n      });\n    }\n  }\n\n  return new _Geometry_js__WEBPACK_IMPORTED_MODULE_12__/* ["default"] */ .Z({\n    attributes: geometry.attributes,\n    indices: geometry.indices,\n    primitiveType: _PrimitiveType_js__WEBPACK_IMPORTED_MODULE_21__/* ["default"].TRIANGLES */ .Z.TRIANGLES,\n    boundingSphere: geometry.boundingSphere,\n    offsetAttribute: ellipseGeometry._offsetAttribute,\n  });\n};\n\n/**\n * @private\n */\nEllipseGeometry.createShadowVolume = function (\n  ellipseGeometry,\n  minHeightFunc,\n  maxHeightFunc\n) {\n  var granularity = ellipseGeometry._granularity;\n  var ellipsoid = ellipseGeometry._ellipsoid;\n\n  var minHeight = minHeightFunc(granularity, ellipsoid);\n  var maxHeight = maxHeightFunc(granularity, ellipsoid);\n\n  return new EllipseGeometry({\n    center: ellipseGeometry._center,\n    semiMajorAxis: ellipseGeometry._semiMajorAxis,\n    semiMinorAxis: ellipseGeometry._semiMinorAxis,\n    ellipsoid: ellipsoid,\n    rotation: ellipseGeometry._rotation,\n    stRotation: ellipseGeometry._stRotation,\n    granularity: granularity,\n    extrudedHeight: minHeight,\n    height: maxHeight,\n    vertexFormat: _VertexFormat_js__WEBPACK_IMPORTED_MODULE_24__/* ["default"].POSITION_ONLY */ .Z.POSITION_ONLY,\n    shadowVolume: true,\n  });\n};\n\nfunction textureCoordinateRotationPoints(ellipseGeometry) {\n  var stRotation = -ellipseGeometry._stRotation;\n  if (stRotation === 0.0) {\n    return [0, 0, 0, 1, 1, 0];\n  }\n\n  var cep = _EllipseGeometryLibrary_js__WEBPACK_IMPORTED_MODULE_9__/* ["default"].computeEllipsePositions */ .Z.computeEllipsePositions(\n    {\n      center: ellipseGeometry._center,\n      semiMajorAxis: ellipseGeometry._semiMajorAxis,\n      semiMinorAxis: ellipseGeometry._semiMinorAxis,\n      rotation: ellipseGeometry._rotation,\n      granularity: ellipseGeometry._granularity,\n    },\n    false,\n    true\n  );\n  var positionsFlat = cep.outerPositions;\n  var positionsCount = positionsFlat.length / 3;\n  var positions = new Array(positionsCount);\n  for (var i = 0; i < positionsCount; ++i) {\n    positions[i] = _Cartesian3_js__WEBPACK_IMPORTED_MODULE_3__/* ["default"].fromArray */ .Z.fromArray(positionsFlat, i * 3);\n  }\n\n  var ellipsoid = ellipseGeometry._ellipsoid;\n  var boundingRectangle = ellipseGeometry.rectangle;\n  return _Geometry_js__WEBPACK_IMPORTED_MODULE_12__/* ["default"]._textureCoordinateRotationPoints */ .Z._textureCoordinateRotationPoints(\n    positions,\n    stRotation,\n    ellipsoid,\n    boundingRectangle\n  );\n}\n\nObject.defineProperties(EllipseGeometry.prototype, {\n  /**\n   * @private\n   */\n  rectangle: {\n    get: function () {\n      if (!(0,_defined_js__WEBPACK_IMPORTED_MODULE_25__/* ["default"] */ .Z)(this._rectangle)) {\n        this._rectangle = computeRectangle(\n          this._center,\n          this._semiMajorAxis,\n          this._semiMinorAxis,\n          this._rotation,\n          this._granularity,\n          this._ellipsoid\n        );\n      }\n      return this._rectangle;\n    },\n  },\n  /**\n   * For remapping texture coordinates when rendering EllipseGeometries as GroundPrimitives.\n   * @private\n   */\n  textureCoordinateRotationPoints: {\n    get: function () {\n      if (!(0,_defined_js__WEBPACK_IMPORTED_MODULE_25__/* ["default"] */ .Z)(this._textureCoordinateRotationPoints)) {\n        this._textureCoordinateRotationPoints = textureCoordinateRotationPoints(\n          this\n        );\n      }\n      return this._textureCoordinateRotationPoints;\n    },\n  },\n});\n/* harmony default export */ __webpack_exports__["Z"] = (EllipseGeometry);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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TSxrRUFBUztBQUNmLDRDQUE0Qyx1RUFBaUI7QUFDN0QsMkJBQTJCLGtHQUErQjtBQUMxRDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUEsYUFBYSw4REFBUTtBQUNyQjtBQUNBO0FBQ0EsbUJBQW1CLHVGQUF1QjtBQUMxQztBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsOEZBQTBCO0FBQzVDO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsWUFBWSwySEFBOEM7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixvQkFBb0I7QUFDdEMsbUJBQW1CLG1GQUFvQjtBQUN2Qzs7QUFFQTtBQUNBO0FBQ0EsU0FBUyxnSUFBeUM7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsaUVBQU87QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsaUVBQU87QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0gsQ0FBQztBQUNELHlEQUFlLGVBQWUsRUFBQyIsInNvdXJjZXMiOlsid2VicGFjazovL3Z1ZTMtd2VicGFjazUvLi9ub2RlX21vZHVsZXMvY2VzaXVtL1NvdXJjZS9Db3JlL0VsbGlwc2VHZW9tZXRyeS5qcz9mODRjIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBhcnJheUZpbGwgZnJvbSBcIi4vYXJyYXlGaWxsLmpzXCI7XG5pbXBvcnQgQm91bmRpbmdTcGhlcmUgZnJvbSBcIi4vQm91bmRpbmdTcGhlcmUuanNcIjtcbmltcG9ydCBDYXJ0ZXNpYW4yIGZyb20gXCIuL0NhcnRlc2lhbjIuanNcIjtcbmltcG9ydCBDYXJ0ZXNpYW4zIGZyb20gXCIuL0NhcnRlc2lhbjMuanNcIjtcbmltcG9ydCBDYXJ0b2dyYXBoaWMgZnJvbSBcIi4vQ2FydG9ncmFwaGljLmpzXCI7XG5pbXBvcnQgQ2hlY2sgZnJvbSBcIi4vQ2hlY2suanNcIjtcbmltcG9ydCBDb21wb25lbnREYXRhdHlwZSBmcm9tIFwiLi9Db21wb25lbnREYXRhdHlwZS5qc1wiO1xuaW1wb3J0IGRlZmF1bHRWYWx1ZSBmcm9tIFwiLi9kZWZhdWx0VmFsdWUuanNcIjtcbmltcG9ydCBkZWZpbmVkIGZyb20gXCIuL2RlZmluZWQuanNcIjtcbmltcG9ydCBEZXZlbG9wZXJFcnJvciBmcm9tIFwiLi9EZXZlbG9wZXJFcnJvci5qc1wiO1xuaW1wb3J0IEVsbGlwc2VHZW9tZXRyeUxpYnJhcnkgZnJvbSBcIi4vRWxsaXBzZUdlb21ldHJ5TGlicmFyeS5qc1wiO1xuaW1wb3J0IEVsbGlwc29pZCBmcm9tIFwiLi9FbGxpcHNvaWQuanNcIjtcbmltcG9ydCBHZW9ncmFwaGljUHJvamVjdGlvbiBmcm9tIFwiLi9HZW9ncmFwaGljUHJvamVjdGlvbi5qc1wiO1xuaW1wb3J0IEdlb21ldHJ5IGZyb20gXCIuL0dlb21ldHJ5LmpzXCI7XG5pbXBvcnQgR2VvbWV0cnlBdHRyaWJ1dGUgZnJvbSBcIi4vR2VvbWV0cnlBdHRyaWJ1dGUuanNcIjtcbmltcG9ydCBHZW9tZXRyeUF0dHJpYnV0ZXMgZnJvbSBcIi4vR2VvbWV0cnlBdHRyaWJ1dGVzLmpzXCI7XG5pbXBvcnQgR2VvbWV0cnlJbnN0YW5jZSBmcm9tIFwiLi9HZW9tZXRyeUluc3RhbmNlLmpzXCI7XG5pbXBvcnQgR2VvbWV0cnlPZmZzZXRBdHRyaWJ1dGUgZnJvbSBcIi4vR2VvbWV0cnlPZmZzZXRBdHRyaWJ1dGUuanNcIjtcbmltcG9ydCBHZW9tZXRyeVBpcGVsaW5lIGZyb20gXCIuL0dlb21ldHJ5UGlwZWxpbmUuanNcIjtcbmltcG9ydCBJbmRleERhdGF0eXBlIGZyb20gXCIuL0luZGV4RGF0YXR5cGUuanNcIjtcbmltcG9ydCBDZXNpdW1NYXRoIGZyb20gXCIuL01hdGguanNcIjtcbmltcG9ydCBNYXRyaXgzIGZyb20gXCIuL01hdHJpeDMuanNcIjtcbmltcG9ydCBQcmltaXRpdmVUeXBlIGZyb20gXCIuL1ByaW1pdGl2ZVR5cGUuanNcIjtcbmltcG9ydCBRdWF0ZXJuaW9uIGZyb20gXCIuL1F1YXRlcm5pb24uanNcIjtcbmltcG9ydCBSZWN0YW5nbGUgZnJvbSBcIi4vUmVjdGFuZ2xlLmpzXCI7XG5pbXBvcnQgVmVydGV4Rm9ybWF0IGZyb20gXCIuL1ZlcnRleEZvcm1hdC5qc1wiO1xuXG52YXIgc2NyYXRjaENhcnRlc2lhbjEgPSBuZXcgQ2FydGVzaWFuMygpO1xudmFyIHNjcmF0Y2hDYXJ0ZXNpYW4yID0gbmV3IENhcnRlc2lhbjMoKTtcbnZhciBzY3JhdGNoQ2FydGVzaWFuMyA9IG5ldyBDYXJ0ZXNpYW4zKCk7XG52YXIgc2NyYXRjaENhcnRlc2lhbjQgPSBuZXcgQ2FydGVzaWFuMygpO1xudmFyIHRleENvb3JkU2NyYXRjaCA9IG5ldyBDYXJ0ZXNpYW4yKCk7XG52YXIgdGV4dHVyZU1hdHJpeFNjcmF0Y2ggPSBuZXcgTWF0cml4MygpO1xudmFyIHRhbmdlbnRNYXRyaXhTY3JhdGNoID0gbmV3IE1hdHJpeDMoKTtcbnZhciBxdWF0ZXJuaW9uU2NyYXRjaCA9IG5ldyBRdWF0ZXJuaW9uKCk7XG5cbnZhciBzY3JhdGNoTm9ybWFsID0gbmV3IENhcnRlc2lhbjMoKTtcbnZhciBzY3JhdGNoVGFuZ2VudCA9IG5ldyBDYXJ0ZXNpYW4zKCk7XG52YXIgc2NyYXRjaEJpdGFuZ2VudCA9IG5ldyBDYXJ0ZXNpYW4zKCk7XG5cbnZhciBzY3JhdGNoQ2FydG9ncmFwaGljID0gbmV3IENhcnRvZ3JhcGhpYygpO1xudmFyIHByb2plY3RlZENlbnRlclNjcmF0Y2ggPSBuZXcgQ2FydGVzaWFuMygpO1xuXG52YXIgc2NyYXRjaE1pblRleENvb3JkID0gbmV3IENhcnRlc2lhbjIoKTtcbnZhciBzY3JhdGNoTWF4VGV4Q29vcmQgPSBuZXcgQ2FydGVzaWFuMigpO1xuXG5mdW5jdGlvbiBjb21wdXRlVG9wQm90dG9tQXR0cmlidXRlcyhwb3NpdGlvbnMsIG9wdGlvbnMsIGV4dHJ1ZGUpIHtcbiAgdmFyIHZlcnRleEZvcm1hdCA9IG9wdGlvbnMudmVydGV4Rm9ybWF0O1xuICB2YXIgY2VudGVyID0gb3B0aW9ucy5jZW50ZXI7XG4gIHZhciBzZW1pTWFqb3JBeGlzID0gb3B0aW9ucy5zZW1pTWFqb3JBeGlzO1xuICB2YXIgc2VtaU1pbm9yQXhpcyA9IG9wdGlvbnMuc2VtaU1pbm9yQXhpcztcbiAgdmFyIGVsbGlwc29pZCA9IG9wdGlvbnMuZWxsaXBzb2lkO1xuICB2YXIgc3RSb3RhdGlvbiA9IG9wdGlvbnMuc3RSb3RhdGlvbjtcbiAgdmFyIHNpemUgPSBleHRydWRlID8gKHBvc2l0aW9ucy5sZW5ndGggLyAzKSAqIDIgOiBwb3NpdGlvbnMubGVuZ3RoIC8gMztcbiAgdmFyIHNoYWRvd1ZvbHVtZSA9IG9wdGlvbnMuc2hhZG93Vm9sdW1lO1xuXG4gIHZhciB0ZXh0dXJlQ29vcmRpbmF0ZXMgPSB2ZXJ0ZXhGb3JtYXQuc3RcbiAgICA/IG5ldyBGbG9hdDMyQXJyYXkoc2l6ZSAqIDIpXG4gICAgOiB1bmRlZmluZWQ7XG4gIHZhciBub3JtYWxzID0gdmVydGV4Rm9ybWF0Lm5vcm1hbCA/IG5ldyBGbG9hdDMyQXJyYXkoc2l6ZSAqIDMpIDogdW5kZWZpbmVkO1xuICB2YXIgdGFuZ2VudHMgPSB2ZXJ0ZXhGb3JtYXQudGFuZ2VudCA/IG5ldyBGbG9hdDMyQXJyYXkoc2l6ZSAqIDMpIDogdW5kZWZpbmVkO1xuICB2YXIgYml0YW5nZW50cyA9IHZlcnRleEZvcm1hdC5iaXRhbmdlbnRcbiAgICA/IG5ldyBGbG9hdDMyQXJyYXkoc2l6ZSAqIDMpXG4gICAgOiB1bmRlZmluZWQ7XG5cbiAgdmFyIGV4dHJ1ZGVOb3JtYWxzID0gc2hhZG93Vm9sdW1lID8gbmV3IEZsb2F0MzJBcnJheShzaXplICogMykgOiB1bmRlZmluZWQ7XG5cbiAgdmFyIHRleHR1cmVDb29yZEluZGV4ID0gMDtcblxuICAvLyBSYWlzZSBwb3NpdGlvbnMgdG8gYSBoZWlnaHQgYWJvdmUgdGhlIGVsbGlwc29pZCBhbmQgY29tcHV0ZSB0aGVcbiAgLy8gdGV4dHVyZSBjb29yZGluYXRlcywgbm9ybWFscywgdGFuZ2VudHMsIGFuZCBiaXRhbmdlbnRzLlxuICB2YXIgbm9ybWFsID0gc2NyYXRjaE5vcm1hbDtcbiAgdmFyIHRhbmdlbnQgPSBzY3JhdGNoVGFuZ2VudDtcbiAgdmFyIGJpdGFuZ2VudCA9IHNjcmF0Y2hCaXRhbmdlbnQ7XG5cbiAgdmFyIHByb2plY3Rpb24gPSBuZXcgR2VvZ3JhcGhpY1Byb2plY3Rpb24oZWxsaXBzb2lkKTtcbiAgdmFyIHByb2plY3RlZENlbnRlciA9IHByb2plY3Rpb24ucHJvamVjdChcbiAgICBlbGxpcHNvaWQuY2FydGVzaWFuVG9DYXJ0b2dyYXBoaWMoY2VudGVyLCBzY3JhdGNoQ2FydG9ncmFwaGljKSxcbiAgICBwcm9qZWN0ZWRDZW50ZXJTY3JhdGNoXG4gICk7XG5cbiAgdmFyIGdlb2RldGljTm9ybWFsID0gZWxsaXBzb2lkLnNjYWxlVG9HZW9kZXRpY1N1cmZhY2UoXG4gICAgY2VudGVyLFxuICAgIHNjcmF0Y2hDYXJ0ZXNpYW4xXG4gICk7XG4gIGVsbGlwc29pZC5nZW9kZXRpY1N1cmZhY2VOb3JtYWwoZ2VvZGV0aWNOb3JtYWwsIGdlb2RldGljTm9ybWFsKTtcblxuICB2YXIgdGV4dHVyZU1hdHJpeCA9IHRleHR1cmVNYXRyaXhTY3JhdGNoO1xuICB2YXIgdGFuZ2VudE1hdHJpeCA9IHRhbmdlbnRNYXRyaXhTY3JhdGNoO1xuICBpZiAoc3RSb3RhdGlvbiAhPT0gMCkge1xuICAgIHZhciByb3RhdGlvbiA9IFF1YXRlcm5pb24uZnJvbUF4aXNBbmdsZShcbiAgICAgIGdlb2RldGljTm9ybWFsLFxuICAgICAgc3RSb3RhdGlvbixcbiAgICAgIHF1YXRlcm5pb25TY3JhdGNoXG4gICAgKTtcbiAgICB0ZXh0dXJlTWF0cml4ID0gTWF0cml4My5mcm9tUXVhdGVybmlvbihyb3RhdGlvbiwgdGV4dHVyZU1hdHJpeCk7XG5cbiAgICByb3RhdGlvbiA9IFF1YXRlcm5pb24uZnJvbUF4aXNBbmdsZShcbiAgICAgIGdlb2RldGljTm9ybWFsLFxuICAgICAgLXN0Um90YXRpb24sXG4gICAgICBxdWF0ZXJuaW9uU2NyYXRjaFxuICAgICk7XG4gICAgdGFuZ2VudE1hdHJpeCA9IE1hdHJpeDMuZnJvbVF1YXRlcm5pb24ocm90YXRpb24sIHRhbmdlbnRNYXRyaXgpO1xuICB9IGVsc2Uge1xuICAgIHRleHR1cmVNYXRyaXggPSBNYXRyaXgzLmNsb25lKE1hdHJpeDMuSURFTlRJVFksIHRleHR1cmVNYXRyaXgpO1xuICAgIHRhbmdlbnRNYXRyaXggPSBNYXRyaXgzLmNsb25lKE1hdHJpeDMuSURFTlRJVFksIHRhbmdlbnRNYXRyaXgpO1xuICB9XG5cbiAgdmFyIG1pblRleENvb3JkID0gQ2FydGVzaWFuMi5mcm9tRWxlbWVudHMoXG4gICAgTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZLFxuICAgIE51bWJlci5QT1NJVElWRV9JTkZJTklUWSxcbiAgICBzY3JhdGNoTWluVGV4Q29vcmRcbiAgKTtcbiAgdmFyIG1heFRleENvb3JkID0gQ2FydGVzaWFuMi5mcm9tRWxlbWVudHMoXG4gICAgTnVtYmVyLk5FR0FUSVZFX0lORklOSVRZLFxuICAgIE51bWJlci5ORUdBVElWRV9JTkZJTklUWSxcbiAgICBzY3JhdGNoTWF4VGV4Q29vcmRcbiAgKTtcblxuICB2YXIgbGVuZ3RoID0gcG9zaXRpb25zLmxlbmd0aDtcbiAgdmFyIGJvdHRvbU9mZnNldCA9IGV4dHJ1ZGUgPyBsZW5ndGggOiAwO1xuICB2YXIgc3RPZmZzZXQgPSAoYm90dG9tT2Zmc2V0IC8gMykgKiAyO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSArPSAzKSB7XG4gICAgdmFyIGkxID0gaSArIDE7XG4gICAgdmFyIGkyID0gaSArIDI7XG4gICAgdmFyIHBvc2l0aW9uID0gQ2FydGVzaWFuMy5mcm9tQXJyYXkocG9zaXRpb25zLCBpLCBzY3JhdGNoQ2FydGVzaWFuMSk7XG5cbiAgICBpZiAodmVydGV4Rm9ybWF0LnN0KSB7XG4gICAgICB2YXIgcm90YXRlZFBvaW50ID0gTWF0cml4My5tdWx0aXBseUJ5VmVjdG9yKFxuICAgICAgICB0ZXh0dXJlTWF0cml4LFxuICAgICAgICBwb3NpdGlvbixcbiAgICAgICAgc2NyYXRjaENhcnRlc2lhbjJcbiAgICAgICk7XG4gICAgICB2YXIgcHJvamVjdGVkUG9pbnQgPSBwcm9qZWN0aW9uLnByb2plY3QoXG4gICAgICAgIGVsbGlwc29pZC5jYXJ0ZXNpYW5Ub0NhcnRvZ3JhcGhpYyhyb3RhdGVkUG9pbnQsIHNjcmF0Y2hDYXJ0b2dyYXBoaWMpLFxuICAgICAgICBzY3JhdGNoQ2FydGVzaWFuM1xuICAgICAgKTtcbiAgICAgIENhcnRlc2lhbjMuc3VidHJhY3QocHJvamVjdGVkUG9pbnQsIHByb2plY3RlZENlbnRlciwgcHJvamVjdGVkUG9pbnQpO1xuXG4gICAgICB0ZXhDb29yZFNjcmF0Y2gueCA9XG4gICAgICAgIChwcm9qZWN0ZWRQb2ludC54ICsgc2VtaU1ham9yQXhpcykgLyAoMi4wICogc2VtaU1ham9yQXhpcyk7XG4gICAgICB0ZXhDb29yZFNjcmF0Y2gueSA9XG4gICAgICAgIChwcm9qZWN0ZWRQb2ludC55ICsgc2VtaU1pbm9yQXhpcykgLyAoMi4wICogc2VtaU1pbm9yQXhpcyk7XG5cbiAgICAgIG1pblRleENvb3JkLnggPSBNYXRoLm1pbih0ZXhDb29yZFNjcmF0Y2gueCwgbWluVGV4Q29vcmQueCk7XG4gICAgICBtaW5UZXhDb29yZC55ID0gTWF0aC5taW4odGV4Q29vcmRTY3JhdGNoLnksIG1pblRleENvb3JkLnkpO1xuICAgICAgbWF4VGV4Q29vcmQueCA9IE1hdGgubWF4KHRleENvb3JkU2NyYXRjaC54LCBtYXhUZXhDb29yZC54KTtcbiAgICAgIG1heFRleENvb3JkLnkgPSBNYXRoLm1heCh0ZXhDb29yZFNjcmF0Y2gueSwgbWF4VGV4Q29vcmQueSk7XG5cbiAgICAgIGlmIChleHRydWRlKSB7XG4gICAgICAgIHRleHR1cmVDb29yZGluYXRlc1t0ZXh0dXJlQ29vcmRJbmRleCArIHN0T2Zmc2V0XSA9IHRleENvb3JkU2NyYXRjaC54O1xuICAgICAgICB0ZXh0dXJlQ29vcmRpbmF0ZXNbdGV4dHVyZUNvb3JkSW5kZXggKyAxICsgc3RPZmZzZXRdID1cbiAgICAgICAgICB0ZXhDb29yZFNjcmF0Y2gueTtcbiAgICAgIH1cblxuICAgICAgdGV4dHVyZUNvb3JkaW5hdGVzW3RleHR1cmVDb29yZEluZGV4KytdID0gdGV4Q29vcmRTY3JhdGNoLng7XG4gICAgICB0ZXh0dXJlQ29vcmRpbmF0ZXNbdGV4dHVyZUNvb3JkSW5kZXgrK10gPSB0ZXhDb29yZFNjcmF0Y2gueTtcbiAgICB9XG5cbiAgICBpZiAoXG4gICAgICB2ZXJ0ZXhGb3JtYXQubm9ybWFsIHx8XG4gICAgICB2ZXJ0ZXhGb3JtYXQudGFuZ2VudCB8fFxuICAgICAgdmVydGV4Rm9ybWF0LmJpdGFuZ2VudCB8fFxuICAgICAgc2hhZG93Vm9sdW1lXG4gICAgKSB7XG4gICAgICBub3JtYWwgPSBlbGxpcHNvaWQuZ2VvZGV0aWNTdXJmYWNlTm9ybWFsKHBvc2l0aW9uLCBub3JtYWwpO1xuXG4gICAgICBpZiAoc2hhZG93Vm9sdW1lKSB7XG4gICAgICAgIGV4dHJ1ZGVOb3JtYWxzW2kgKyBib3R0b21PZmZzZXRdID0gLW5vcm1hbC54O1xuICAgICAgICBleHRydWRlTm9ybWFsc1tpMSArIGJvdHRvbU9mZnNldF0gPSAtbm9ybWFsLnk7XG4gICAgICAgIGV4dHJ1ZGVOb3JtYWxzW2kyICsgYm90dG9tT2Zmc2V0XSA9IC1ub3JtYWwuejtcbiAgICAgIH1cblxuICAgICAgaWYgKFxuICAgICAgICB2ZXJ0ZXhGb3JtYXQubm9ybWFsIHx8XG4gICAgICAgIHZlcnRleEZvcm1hdC50YW5nZW50IHx8XG4gICAgICAgIHZlcnRleEZvcm1hdC5iaXRhbmdlbnRcbiAgICAgICkge1xuICAgICAgICBpZiAodmVydGV4Rm9ybWF0LnRhbmdlbnQgfHwgdmVydGV4Rm9ybWF0LmJpdGFuZ2VudCkge1xuICAgICAgICAgIHRhbmdlbnQgPSBDYXJ0ZXNpYW4zLm5vcm1hbGl6ZShcbiAgICAgICAgICAgIENhcnRlc2lhbjMuY3Jvc3MoQ2FydGVzaWFuMy5VTklUX1osIG5vcm1hbCwgdGFuZ2VudCksXG4gICAgICAgICAgICB0YW5nZW50XG4gICAgICAgICAgKTtcbiAgICAgICAgICBNYXRyaXgzLm11bHRpcGx5QnlWZWN0b3IodGFuZ2VudE1hdHJpeCwgdGFuZ2VudCwgdGFuZ2VudCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHZlcnRleEZvcm1hdC5ub3JtYWwpIHtcbiAgICAgICAgICBub3JtYWxzW2ldID0gbm9ybWFsLng7XG4gICAgICAgICAgbm9ybWFsc1tpMV0gPSBub3JtYWwueTtcbiAgICAgICAgICBub3JtYWxzW2kyXSA9IG5vcm1hbC56O1xuICAgICAgICAgIGlmIChleHRydWRlKSB7XG4gICAgICAgICAgICBub3JtYWxzW2kgKyBib3R0b21PZmZzZXRdID0gLW5vcm1hbC54O1xuICAgICAgICAgICAgbm9ybWFsc1tpMSArIGJvdHRvbU9mZnNldF0gPSAtbm9ybWFsLnk7XG4gICAgICAgICAgICBub3JtYWxzW2kyICsgYm90dG9tT2Zmc2V0XSA9IC1ub3JtYWwuejtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodmVydGV4Rm9ybWF0LnRhbmdlbnQpIHtcbiAgICAgICAgICB0YW5nZW50c1tpXSA9IHRhbmdlbnQueDtcbiAgICAgICAgICB0YW5nZW50c1tpMV0gPSB0YW5nZW50Lnk7XG4gICAgICAgICAgdGFuZ2VudHNbaTJdID0gdGFuZ2VudC56O1xuICAgICAgICAgIGlmIChleHRydWRlKSB7XG4gICAgICAgICAgICB0YW5nZW50c1tpICsgYm90dG9tT2Zmc2V0XSA9IC10YW5nZW50Lng7XG4gICAgICAgICAgICB0YW5nZW50c1tpMSArIGJvdHRvbU9mZnNldF0gPSAtdGFuZ2VudC55O1xuICAgICAgICAgICAgdGFuZ2VudHNbaTIgKyBib3R0b21PZmZzZXRdID0gLXRhbmdlbnQuejtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodmVydGV4Rm9ybWF0LmJpdGFuZ2VudCkge1xuICAgICAgICAgIGJpdGFuZ2VudCA9IENhcnRlc2lhbjMubm9ybWFsaXplKFxuICAgICAgICAgICAgQ2FydGVzaWFuMy5jcm9zcyhub3JtYWwsIHRhbmdlbnQsIGJpdGFuZ2VudCksXG4gICAgICAgICAgICBiaXRhbmdlbnRcbiAgICAgICAgICApO1xuICAgICAgICAgIGJpdGFuZ2VudHNbaV0gPSBiaXRhbmdlbnQueDtcbiAgICAgICAgICBiaXRhbmdlbnRzW2kxXSA9IGJpdGFuZ2VudC55O1xuICAgICAgICAgIGJpdGFuZ2VudHNbaTJdID0gYml0YW5nZW50Lno7XG4gICAgICAgICAgaWYgKGV4dHJ1ZGUpIHtcbiAgICAgICAgICAgIGJpdGFuZ2VudHNbaSArIGJvdHRvbU9mZnNldF0gPSBiaXRhbmdlbnQueDtcbiAgICAgICAgICAgIGJpdGFuZ2VudHNbaTEgKyBib3R0b21PZmZzZXRdID0gYml0YW5nZW50Lnk7XG4gICAgICAgICAgICBiaXRhbmdlbnRzW2kyICsgYm90dG9tT2Zmc2V0XSA9IGJpdGFuZ2VudC56O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGlmICh2ZXJ0ZXhGb3JtYXQuc3QpIHtcbiAgICBsZW5ndGggPSB0ZXh0dXJlQ29vcmRpbmF0ZXMubGVuZ3RoO1xuICAgIGZvciAodmFyIGsgPSAwOyBrIDwgbGVuZ3RoOyBrICs9IDIpIHtcbiAgICAgIHRleHR1cmVDb29yZGluYXRlc1trXSA9XG4gICAgICAgICh0ZXh0dXJlQ29vcmRpbmF0ZXNba10gLSBtaW5UZXhDb29yZC54KSAvXG4gICAgICAgIChtYXhUZXhDb29yZC54IC0gbWluVGV4Q29vcmQueCk7XG4gICAgICB0ZXh0dXJlQ29vcmRpbmF0ZXNbayArIDFdID1cbiAgICAgICAgKHRleHR1cmVDb29yZGluYXRlc1trICsgMV0gLSBtaW5UZXhDb29yZC55KSAvXG4gICAgICAgIChtYXhUZXhDb29yZC55IC0gbWluVGV4Q29vcmQueSk7XG4gICAgfVxuICB9XG5cbiAgdmFyIGF0dHJpYnV0ZXMgPSBuZXcgR2VvbWV0cnlBdHRyaWJ1dGVzKCk7XG5cbiAgaWYgKHZlcnRleEZvcm1hdC5wb3NpdGlvbikge1xuICAgIHZhciBmaW5hbFBvc2l0aW9ucyA9IEVsbGlwc2VHZW9tZXRyeUxpYnJhcnkucmFpc2VQb3NpdGlvbnNUb0hlaWdodChcbiAgICAgIHBvc2l0aW9ucyxcbiAgICAgIG9wdGlvbnMsXG4gICAgICBleHRydWRlXG4gICAgKTtcbiAgICBhdHRyaWJ1dGVzLnBvc2l0aW9uID0gbmV3IEdlb21ldHJ5QXR0cmlidXRlKHtcbiAgICAgIGNvbXBvbmVudERhdGF0eXBlOiBDb21wb25lbnREYXRhdHlwZS5ET1VCTEUsXG4gICAgICBjb21wb25lbnRzUGVyQXR0cmlidXRlOiAzLFxuICAgICAgdmFsdWVzOiBmaW5hbFBvc2l0aW9ucyxcbiAgICB9KTtcbiAgfVxuXG4gIGlmICh2ZXJ0ZXhGb3JtYXQuc3QpIHtcbiAgICBhdHRyaWJ1dGVzLnN0ID0gbmV3IEdlb21ldHJ5QXR0cmlidXRlKHtcbiAgICAgIGNvbXBvbmVudERhdGF0eXBlOiBDb21wb25lbnREYXRhdHlwZS5GTE9BVCxcbiAgICAgIGNvbXBvbmVudHNQZXJBdHRyaWJ1dGU6IDIsXG4gICAgICB2YWx1ZXM6IHRleHR1cmVDb29yZGluYXRlcyxcbiAgICB9KTtcbiAgfVxuXG4gIGlmICh2ZXJ0ZXhGb3JtYXQubm9ybWFsKSB7XG4gICAgYXR0cmlidXRlcy5ub3JtYWwgPSBuZXcgR2VvbWV0cnlBdHRyaWJ1dGUoe1xuICAgICAgY29tcG9uZW50RGF0YXR5cGU6IENvbXBvbmVudERhdGF0eXBlLkZMT0FULFxuICAgICAgY29tcG9uZW50c1BlckF0dHJpYnV0ZTogMyxcbiAgICAgIHZhbHVlczogbm9ybWFscyxcbiAgICB9KTtcbiAgfVxuXG4gIGlmICh2ZXJ0ZXhGb3JtYXQudGFuZ2VudCkge1xuICAgIGF0dHJpYnV0ZXMudGFuZ2VudCA9IG5ldyBHZW9tZXRyeUF0dHJpYnV0ZSh7XG4gICAgICBjb21wb25lbnREYXRhdHlwZTogQ29tcG9uZW50RGF0YXR5cGUuRkxPQVQsXG4gICAgICBjb21wb25lbnRzUGVyQXR0cmlidXRlOiAzLFxuICAgICAgdmFsdWVzOiB0YW5nZW50cyxcbiAgICB9KTtcbiAgfVxuXG4gIGlmICh2ZXJ0ZXhGb3JtYXQuYml0YW5nZW50KSB7XG4gICAgYXR0cmlidXRlcy5iaXRhbmdlbnQgPSBuZXcgR2VvbWV0cnlBdHRyaWJ1dGUoe1xuICAgICAgY29tcG9uZW50RGF0YXR5cGU6IENvbXBvbmVudERhdGF0eXBlLkZMT0FULFxuICAgICAgY29tcG9uZW50c1BlckF0dHJpYnV0ZTogMyxcbiAgICAgIHZhbHVlczogYml0YW5nZW50cyxcbiAgICB9KTtcbiAgfVxuXG4gIGlmIChzaGFkb3dWb2x1bWUpIHtcbiAgICBhdHRyaWJ1dGVzLmV4dHJ1ZGVEaXJlY3Rpb24gPSBuZXcgR2VvbWV0cnlBdHRyaWJ1dGUoe1xuICAgICAgY29tcG9uZW50RGF0YXR5cGU6IENvbXBvbmVudERhdGF0eXBlLkZMT0FULFxuICAgICAgY29tcG9uZW50c1BlckF0dHJpYnV0ZTogMyxcbiAgICAgIHZhbHVlczogZXh0cnVkZU5vcm1hbHMsXG4gICAgfSk7XG4gIH1cblxuICBpZiAoZXh0cnVkZSAmJiBkZWZpbmVkKG9wdGlvbnMub2Zmc2V0QXR0cmlidXRlKSkge1xuICAgIHZhciBvZmZzZXRBdHRyaWJ1dGUgPSBuZXcgVWludDhBcnJheShzaXplKTtcbiAgICBpZiAob3B0aW9ucy5vZmZzZXRBdHRyaWJ1dGUgPT09IEdlb21ldHJ5T2Zmc2V0QXR0cmlidXRlLlRPUCkge1xuICAgICAgb2Zmc2V0QXR0cmlidXRlID0gYXJyYXlGaWxsKG9mZnNldEF0dHJpYnV0ZSwgMSwgMCwgc2l6ZSAvIDIpO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgb2Zmc2V0VmFsdWUgPVxuICAgICAgICBvcHRpb25zLm9mZnNldEF0dHJpYnV0ZSA9PT0gR2VvbWV0cnlPZmZzZXRBdHRyaWJ1dGUuTk9ORSA/IDAgOiAxO1xuICAgICAgb2Zmc2V0QXR0cmlidXRlID0gYXJyYXlGaWxsKG9mZnNldEF0dHJpYnV0ZSwgb2Zmc2V0VmFsdWUpO1xuICAgIH1cblxuICAgIGF0dHJpYnV0ZXMuYXBwbHlPZmZzZXQgPSBuZXcgR2VvbWV0cnlBdHRyaWJ1dGUoe1xuICAgICAgY29tcG9uZW50RGF0YXR5cGU6IENvbXBvbmVudERhdGF0eXBlLlVOU0lHTkVEX0JZVEUsXG4gICAgICBjb21wb25lbnRzUGVyQXR0cmlidXRlOiAxLFxuICAgICAgdmFsdWVzOiBvZmZzZXRBdHRyaWJ1dGUsXG4gICAgfSk7XG4gIH1cblxuICByZXR1cm4gYXR0cmlidXRlcztcbn1cblxuZnVuY3Rpb24gdG9wSW5kaWNlcyhudW1QdHMpIHtcbiAgLy8gbnVtVHJpYW5nbGVzIGluIGhhbGYgPSAzICsgOCArIDEyICsgLi4uID0gLTEgKyA0ICsgKDQgKyA0KSArICg0ICsgNCArIDQpICsgLi4uID0gLTEgKyA0ICogKDEgKyAyICsgMyArIC4uLilcbiAgLy8gICAgICAgICAgICAgID0gLTEgKyA0ICogKChuICogKCBuICsgMSkpIC8gMilcbiAgLy8gdG90YWwgdHJpYW5nbGVzID0gMiAqIG51bVRyYW5nbGVzIGluIGhhbGZcbiAgLy8gaW5kaWNlcyA9IHRvdGFsIHRyaWFuZ2xlcyAqIDM7XG4gIC8vIFN1YnN0aXR1dGUgbnVtUHRzIGZvciBuIGFib3ZlXG5cbiAgdmFyIGluZGljZXMgPSBuZXcgQXJyYXkoMTIgKiAobnVtUHRzICogKG51bVB0cyArIDEpKSAtIDYpO1xuICB2YXIgaW5kaWNlc0luZGV4ID0gMDtcbiAgdmFyIHByZXZJbmRleDtcbiAgdmFyIG51bUludGVyaW9yO1xuICB2YXIgcG9zaXRpb25JbmRleDtcbiAgdmFyIGk7XG4gIHZhciBqO1xuICAvLyBJbmRpY2VzIHRyaWFuZ2xlcyB0byB0aGUgJ3JpZ2h0JyBvZiB0aGUgbm9ydGggdmVjdG9yXG5cbiAgcHJldkluZGV4ID0gMDtcbiAgcG9zaXRpb25JbmRleCA9IDE7XG4gIGZvciAoaSA9IDA7IGkgPCAzOyBpKyspIHtcbiAgICBpbmRpY2VzW2luZGljZXNJbmRleCsrXSA9IHBvc2l0aW9uSW5kZXgrKztcbiAgICBpbmRpY2VzW2luZGljZXNJbmRleCsrXSA9IHByZXZJbmRleDtcbiAgICBpbmRpY2VzW2luZGljZXNJbmRleCsrXSA9IHBvc2l0aW9uSW5kZXg7XG4gIH1cblxuICBmb3IgKGkgPSAyOyBpIDwgbnVtUHRzICsgMTsgKytpKSB7XG4gICAgcG9zaXRpb25JbmRleCA9IGkgKiAoaSArIDEpIC0gMTtcbiAgICBwcmV2SW5kZXggPSAoaSAtIDEpICogaSAtIDE7XG5cbiAgICBpbmRpY2VzW2luZGljZXNJbmRleCsrXSA9IHBvc2l0aW9uSW5kZXgrKztcbiAgICBpbmRpY2VzW2luZGljZXNJbmRleCsrXSA9IHByZXZJbmRleDtcbiAgICBpbmRpY2VzW2luZGljZXNJbmRleCsrXSA9IHBvc2l0aW9uSW5kZXg7XG5cbiAgICBudW1JbnRlcmlvciA9IDIgKiBpO1xuICAgIGZvciAoaiA9IDA7IGogPCBudW1JbnRlcmlvciAtIDE7ICsraikge1xuICAgICAgaW5kaWNlc1tpbmRpY2VzSW5kZXgrK10gPSBwb3NpdGlvbkluZGV4O1xuICAgICAgaW5kaWNlc1tpbmRpY2VzSW5kZXgrK10gPSBwcmV2SW5kZXgrKztcbiAgICAgIGluZGljZXNbaW5kaWNlc0luZGV4KytdID0gcHJldkluZGV4O1xuXG4gICAgICBpbmRpY2VzW2luZGljZXNJbmRleCsrXSA9IHBvc2l0aW9uSW5kZXgrKztcbiAgICAgIGluZGljZXNbaW5kaWNlc0luZGV4KytdID0gcHJldkluZGV4O1xuICAgICAgaW5kaWNlc1tpbmRpY2VzSW5kZXgrK10gPSBwb3NpdGlvbkluZGV4O1xuICAgIH1cblxuICAgIGluZGljZXNbaW5kaWNlc0luZGV4KytdID0gcG9zaXRpb25JbmRleCsrO1xuICAgIGluZGljZXNbaW5kaWNlc0luZGV4KytdID0gcHJldkluZGV4O1xuICAgIGluZGljZXNbaW5kaWNlc0luZGV4KytdID0gcG9zaXRpb25JbmRleDtcbiAgfVxuXG4gIC8vIEluZGljZXMgZm9yIGNlbnRlciBjb2x1bW4gb2YgdHJpYW5nbGVzXG4gIG51bUludGVyaW9yID0gbnVtUHRzICogMjtcbiAgKytwb3NpdGlvbkluZGV4O1xuICArK3ByZXZJbmRleDtcbiAgZm9yIChpID0gMDsgaSA8IG51bUludGVyaW9yIC0gMTsgKytpKSB7XG4gICAgaW5kaWNlc1tpbmRpY2VzSW5kZXgrK10gPSBwb3NpdGlvbkluZGV4O1xuICAgIGluZGljZXNbaW5kaWNlc0luZGV4KytdID0gcHJldkluZGV4Kys7XG4gICAgaW5kaWNlc1tpbmRpY2VzSW5kZXgrK10gPSBwcmV2SW5kZXg7XG5cbiAgICBpbmRpY2VzW2luZGljZXNJbmRleCsrXSA9IHBvc2l0aW9uSW5kZXgrKztcbiAgICBpbmRpY2VzW2luZGljZXNJbmRleCsrXSA9IHByZXZJbmRleDtcbiAgICBpbmRpY2VzW2luZGljZXNJbmRleCsrXSA9IHBvc2l0aW9uSW5kZXg7XG4gIH1cblxuICBpbmRpY2VzW2luZGljZXNJbmRleCsrXSA9IHBvc2l0aW9uSW5kZXg7XG4gIGluZGljZXNbaW5kaWNlc0luZGV4KytdID0gcHJldkluZGV4Kys7XG4gIGluZGljZXNbaW5kaWNlc0luZGV4KytdID0gcHJldkluZGV4O1xuXG4gIGluZGljZXNbaW5kaWNlc0luZGV4KytdID0gcG9zaXRpb25JbmRleCsrO1xuICBpbmRpY2VzW2luZGljZXNJbmRleCsrXSA9IHByZXZJbmRleCsrO1xuICBpbmRpY2VzW2luZGljZXNJbmRleCsrXSA9IHByZXZJbmRleDtcblxuICAvLyBSZXZlcnNlIHRoZSBwcm9jZXNzIGNyZWF0aW5nIGluZGljZXMgdG8gdGhlICdsZWZ0JyBvZiB0aGUgbm9ydGggdmVjdG9yXG4gICsrcHJldkluZGV4O1xuICBmb3IgKGkgPSBudW1QdHMgLSAxOyBpID4gMTsgLS1pKSB7XG4gICAgaW5kaWNlc1tpbmRpY2VzSW5kZXgrK10gPSBwcmV2SW5kZXgrKztcbiAgICBpbmRpY2VzW2luZGljZXNJbmRleCsrXSA9IHByZXZJbmRleDtcbiAgICBpbmRpY2VzW2luZGljZXNJbmRleCsrXSA9IHBvc2l0aW9uSW5kZXg7XG5cbiAgICBudW1JbnRlcmlvciA9IDIgKiBpO1xuICAgIGZvciAoaiA9IDA7IGogPCBudW1JbnRlcmlvciAtIDE7ICsraikge1xuICAgICAgaW5kaWNlc1tpbmRpY2VzSW5kZXgrK10gPSBwb3NpdGlvbkluZGV4O1xuICAgICAgaW5kaWNlc1tpbmRpY2VzSW5kZXgrK10gPSBwcmV2SW5kZXgrKztcbiAgICAgIGluZGljZXNbaW5kaWNlc0luZGV4KytdID0gcHJldkluZGV4O1xuXG4gICAgICBpbmRpY2VzW2luZGljZXNJbmRleCsrXSA9IHBvc2l0aW9uSW5kZXgrKztcbiAgICAgIGluZGljZXNbaW5kaWNlc0luZGV4KytdID0gcHJldkluZGV4O1xuICAgICAgaW5kaWNlc1tpbmRpY2VzSW5kZXgrK10gPSBwb3NpdGlvbkluZGV4O1xuICAgIH1cblxuICAgIGluZGljZXNbaW5kaWNlc0luZGV4KytdID0gcHJldkluZGV4Kys7XG4gICAgaW5kaWNlc1tpbmRpY2VzSW5kZXgrK10gPSBwcmV2SW5kZXgrKztcbiAgICBpbmRpY2VzW2luZGljZXNJbmRleCsrXSA9IHBvc2l0aW9uSW5kZXgrKztcbiAgfVxuXG4gIGZvciAoaSA9IDA7IGkgPCAzOyBpKyspIHtcbiAgICBpbmRpY2VzW2luZGljZXNJbmRleCsrXSA9IHByZXZJbmRleCsrO1xuICAgIGluZGljZXNbaW5kaWNlc0luZGV4KytdID0gcHJldkluZGV4O1xuICAgIGluZGljZXNbaW5kaWNlc0luZGV4KytdID0gcG9zaXRpb25JbmRleDtcbiAgfVxuICByZXR1cm4gaW5kaWNlcztcbn1cblxudmFyIGJvdW5kaW5nU3BoZXJlQ2VudGVyID0gbmV3IENhcnRlc2lhbjMoKTtcblxuZnVuY3Rpb24gY29tcHV0ZUVsbGlwc2Uob3B0aW9ucykge1xuICB2YXIgY2VudGVyID0gb3B0aW9ucy5jZW50ZXI7XG4gIGJvdW5kaW5nU3BoZXJlQ2VudGVyID0gQ2FydGVzaWFuMy5tdWx0aXBseUJ5U2NhbGFyKFxuICAgIG9wdGlvbnMuZWxsaXBzb2lkLmdlb2RldGljU3VyZmFjZU5vcm1hbChjZW50ZXIsIGJvdW5kaW5nU3BoZXJlQ2VudGVyKSxcbiAgICBvcHRpb25zLmhlaWdodCxcbiAgICBib3VuZGluZ1NwaGVyZUNlbnRlclxuICApO1xuICBib3VuZGluZ1NwaGVyZUNlbnRlciA9IENhcnRlc2lhbjMuYWRkKFxuICAgIGNlbnRlcixcbiAgICBib3VuZGluZ1NwaGVyZUNlbnRlcixcbiAgICBib3VuZGluZ1NwaGVyZUNlbnRlclxuICApO1xuICB2YXIgYm91bmRpbmdTcGhlcmUgPSBuZXcgQm91bmRpbmdTcGhlcmUoXG4gICAgYm91bmRpbmdTcGhlcmVDZW50ZXIsXG4gICAgb3B0aW9ucy5zZW1pTWFqb3JBeGlzXG4gICk7XG4gIHZhciBjZXAgPSBFbGxpcHNlR2VvbWV0cnlMaWJyYXJ5LmNvbXB1dGVFbGxpcHNlUG9zaXRpb25zKFxuICAgIG9wdGlvbnMsXG4gICAgdHJ1ZSxcbiAgICBmYWxzZVxuICApO1xuICB2YXIgcG9zaXRpb25zID0gY2VwLnBvc2l0aW9ucztcbiAgdmFyIG51bVB0cyA9IGNlcC5udW1QdHM7XG4gIHZhciBhdHRyaWJ1dGVzID0gY29tcHV0ZVRvcEJvdHRvbUF0dHJpYnV0ZXMocG9zaXRpb25zLCBvcHRpb25zLCBmYWxzZSk7XG4gIHZhciBpbmRpY2VzID0gdG9wSW5kaWNlcyhudW1QdHMpO1xuICBpbmRpY2VzID0gSW5kZXhEYXRhdHlwZS5jcmVhdGVUeXBlZEFycmF5KHBvc2l0aW9ucy5sZW5ndGggLyAzLCBpbmRpY2VzKTtcbiAgcmV0dXJuIHtcbiAgICBib3VuZGluZ1NwaGVyZTogYm91bmRpbmdTcGhlcmUsXG4gICAgYXR0cmlidXRlczogYXR0cmlidXRlcyxcbiAgICBpbmRpY2VzOiBpbmRpY2VzLFxuICB9O1xufVxuXG5mdW5jdGlvbiBjb21wdXRlV2FsbEF0dHJpYnV0ZXMocG9zaXRpb25zLCBvcHRpb25zKSB7XG4gIHZhciB2ZXJ0ZXhGb3JtYXQgPSBvcHRpb25zLnZlcnRleEZvcm1hdDtcbiAgdmFyIGNlbnRlciA9IG9wdGlvbnMuY2VudGVyO1xuICB2YXIgc2VtaU1ham9yQXhpcyA9IG9wdGlvbnMuc2VtaU1ham9yQXhpcztcbiAgdmFyIHNlbWlNaW5vckF4aXMgPSBvcHRpb25zLnNlbWlNaW5vckF4aXM7XG4gIHZhciBlbGxpcHNvaWQgPSBvcHRpb25zLmVsbGlwc29pZDtcbiAgdmFyIGhlaWdodCA9IG9wdGlvbnMuaGVpZ2h0O1xuICB2YXIgZXh0cnVkZWRIZWlnaHQgPSBvcHRpb25zLmV4dHJ1ZGVkSGVpZ2h0O1xuICB2YXIgc3RSb3RhdGlvbiA9IG9wdGlvbnMuc3RSb3RhdGlvbjtcbiAgdmFyIHNpemUgPSAocG9zaXRpb25zLmxlbmd0aCAvIDMpICogMjtcblxuICB2YXIgZmluYWxQb3NpdGlvbnMgPSBuZXcgRmxvYXQ2NEFycmF5KHNpemUgKiAzKTtcbiAgdmFyIHRleHR1cmVDb29yZGluYXRlcyA9IHZlcnRleEZvcm1hdC5zdFxuICAgID8gbmV3IEZsb2F0MzJBcnJheShzaXplICogMilcbiAgICA6IHVuZGVmaW5lZDtcbiAgdmFyIG5vcm1hbHMgPSB2ZXJ0ZXhGb3JtYXQubm9ybWFsID8gbmV3IEZsb2F0MzJBcnJheShzaXplICogMykgOiB1bmRlZmluZWQ7XG4gIHZhciB0YW5nZW50cyA9IHZlcnRleEZvcm1hdC50YW5nZW50ID8gbmV3IEZsb2F0MzJBcnJheShzaXplICogMykgOiB1bmRlZmluZWQ7XG4gIHZhciBiaXRhbmdlbnRzID0gdmVydGV4Rm9ybWF0LmJpdGFuZ2VudFxuICAgID8gbmV3IEZsb2F0MzJBcnJheShzaXplICogMylcbiAgICA6IHVuZGVmaW5lZDtcblxuICB2YXIgc2hhZG93Vm9sdW1lID0gb3B0aW9ucy5zaGFkb3dWb2x1bWU7XG4gIHZhciBleHRydWRlTm9ybWFscyA9IHNoYWRvd1ZvbHVtZSA/IG5ldyBGbG9hdDMyQXJyYXkoc2l6ZSAqIDMpIDogdW5kZWZpbmVkO1xuXG4gIHZhciB0ZXh0dXJlQ29vcmRJbmRleCA9IDA7XG5cbiAgLy8gUmFpc2UgcG9zaXRpb25zIHRvIGEgaGVpZ2h0IGFib3ZlIHRoZSBlbGxpcHNvaWQgYW5kIGNvbXB1dGUgdGhlXG4gIC8vIHRleHR1cmUgY29vcmRpbmF0ZXMsIG5vcm1hbHMsIHRhbmdlbnRzLCBhbmQgYml0YW5nZW50cy5cbiAgdmFyIG5vcm1hbCA9IHNjcmF0Y2hOb3JtYWw7XG4gIHZhciB0YW5nZW50ID0gc2NyYXRjaFRhbmdlbnQ7XG4gIHZhciBiaXRhbmdlbnQgPSBzY3JhdGNoQml0YW5nZW50O1xuXG4gIHZhciBwcm9qZWN0aW9uID0gbmV3IEdlb2dyYXBoaWNQcm9qZWN0aW9uKGVsbGlwc29pZCk7XG4gIHZhciBwcm9qZWN0ZWRDZW50ZXIgPSBwcm9qZWN0aW9uLnByb2plY3QoXG4gICAgZWxsaXBzb2lkLmNhcnRlc2lhblRvQ2FydG9ncmFwaGljKGNlbnRlciwgc2NyYXRjaENhcnRvZ3JhcGhpYyksXG4gICAgcHJvamVjdGVkQ2VudGVyU2NyYXRjaFxuICApO1xuXG4gIHZhciBnZW9kZXRpY05vcm1hbCA9IGVsbGlwc29pZC5zY2FsZVRvR2VvZGV0aWNTdXJmYWNlKFxuICAgIGNlbnRlcixcbiAgICBzY3JhdGNoQ2FydGVzaWFuMVxuICApO1xuICBlbGxpcHNvaWQuZ2VvZGV0aWNTdXJmYWNlTm9ybWFsKGdlb2RldGljTm9ybWFsLCBnZW9kZXRpY05vcm1hbCk7XG4gIHZhciByb3RhdGlvbiA9IFF1YXRlcm5pb24uZnJvbUF4aXNBbmdsZShcbiAgICBnZW9kZXRpY05vcm1hbCxcbiAgICBzdFJvdGF0aW9uLFxuICAgIHF1YXRlcm5pb25TY3JhdGNoXG4gICk7XG4gIHZhciB0ZXh0dXJlTWF0cml4ID0gTWF0cml4My5mcm9tUXVhdGVybmlvbihyb3RhdGlvbiwgdGV4dHVyZU1hdHJpeFNjcmF0Y2gpO1xuXG4gIHZhciBtaW5UZXhDb29yZCA9IENhcnRlc2lhbjIuZnJvbUVsZW1lbnRzKFxuICAgIE51bWJlci5QT1NJVElWRV9JTkZJTklUWSxcbiAgICBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFksXG4gICAgc2NyYXRjaE1pblRleENvb3JkXG4gICk7XG4gIHZhciBtYXhUZXhDb29yZCA9IENhcnRlc2lhbjIuZnJvbUVsZW1lbnRzKFxuICAgIE51bWJlci5ORUdBVElWRV9JTkZJTklUWSxcbiAgICBOdW1iZXIuTkVHQVRJVkVfSU5GSU5JVFksXG4gICAgc2NyYXRjaE1heFRleENvb3JkXG4gICk7XG5cbiAgdmFyIGxlbmd0aCA9IHBvc2l0aW9ucy5sZW5ndGg7XG4gIHZhciBzdE9mZnNldCA9IChsZW5ndGggLyAzKSAqIDI7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpICs9IDMpIHtcbiAgICB2YXIgaTEgPSBpICsgMTtcbiAgICB2YXIgaTIgPSBpICsgMjtcbiAgICB2YXIgcG9zaXRpb24gPSBDYXJ0ZXNpYW4zLmZyb21BcnJheShwb3NpdGlvbnMsIGksIHNjcmF0Y2hDYXJ0ZXNpYW4xKTtcbiAgICB2YXIgZXh0cnVkZWRQb3NpdGlvbjtcblxuICAgIGlmICh2ZXJ0ZXhGb3JtYXQuc3QpIHtcbiAgICAgIHZhciByb3RhdGVkUG9pbnQgPSBNYXRyaXgzLm11bHRpcGx5QnlWZWN0b3IoXG4gICAgICAgIHRleHR1cmVNYXRyaXgsXG4gICAgICAgIHBvc2l0aW9uLFxuICAgICAgICBzY3JhdGNoQ2FydGVzaWFuMlxuICAgICAgKTtcbiAgICAgIHZhciBwcm9qZWN0ZWRQb2ludCA9IHByb2plY3Rpb24ucHJvamVjdChcbiAgICAgICAgZWxsaXBzb2lkLmNhcnRlc2lhblRvQ2FydG9ncmFwaGljKHJvdGF0ZWRQb2ludCwgc2NyYXRjaENhcnRvZ3JhcGhpYyksXG4gICAgICAgIHNjcmF0Y2hDYXJ0ZXNpYW4zXG4gICAgICApO1xuICAgICAgQ2FydGVzaWFuMy5zdWJ0cmFjdChwcm9qZWN0ZWRQb2ludCwgcHJvamVjdGVkQ2VudGVyLCBwcm9qZWN0ZWRQb2ludCk7XG5cbiAgICAgIHRleENvb3JkU2NyYXRjaC54ID1cbiAgICAgICAgKHByb2plY3RlZFBvaW50LnggKyBzZW1pTWFqb3JBeGlzKSAvICgyLjAgKiBzZW1pTWFqb3JBeGlzKTtcbiAgICAgIHRleENvb3JkU2NyYXRjaC55ID1cbiAgICAgICAgKHByb2plY3RlZFBvaW50LnkgKyBzZW1pTWlub3JBeGlzKSAvICgyLjAgKiBzZW1pTWlub3JBeGlzKTtcblxuICAgICAgbWluVGV4Q29vcmQueCA9IE1hdGgubWluKHRleENvb3JkU2NyYXRjaC54LCBtaW5UZXhDb29yZC54KTtcbiAgICAgIG1pblRleENvb3JkLnkgPSBNYXRoLm1pbih0ZXhDb29yZFNjcmF0Y2gueSwgbWluVGV4Q29vcmQueSk7XG4gICAgICBtYXhUZXhDb29yZC54ID0gTWF0aC5tYXgodGV4Q29vcmRTY3JhdGNoLngsIG1heFRleENvb3JkLngpO1xuICAgICAgbWF4VGV4Q29vcmQueSA9IE1hdGgubWF4KHRleENvb3JkU2NyYXRjaC55LCBtYXhUZXhDb29yZC55KTtcblxuICAgICAgdGV4dHVyZUNvb3JkaW5hdGVzW3RleHR1cmVDb29yZEluZGV4ICsgc3RPZmZzZXRdID0gdGV4Q29vcmRTY3JhdGNoLng7XG4gICAgICB0ZXh0dXJlQ29vcmRpbmF0ZXNbdGV4dHVyZUNvb3JkSW5kZXggKyAxICsgc3RPZmZzZXRdID0gdGV4Q29vcmRTY3JhdGNoLnk7XG5cbiAgICAgIHRleHR1cmVDb29yZGluYXRlc1t0ZXh0dXJlQ29vcmRJbmRleCsrXSA9IHRleENvb3JkU2NyYXRjaC54O1xuICAgICAgdGV4dHVyZUNvb3JkaW5hdGVzW3RleHR1cmVDb29yZEluZGV4KytdID0gdGV4Q29vcmRTY3JhdGNoLnk7XG4gICAgfVxuXG4gICAgcG9zaXRpb24gPSBlbGxpcHNvaWQuc2NhbGVUb0dlb2RldGljU3VyZmFjZShwb3NpdGlvbiwgcG9zaXRpb24pO1xuICAgIGV4dHJ1ZGVkUG9zaXRpb24gPSBDYXJ0ZXNpYW4zLmNsb25lKHBvc2l0aW9uLCBzY3JhdGNoQ2FydGVzaWFuMik7XG4gICAgbm9ybWFsID0gZWxsaXBzb2lkLmdlb2RldGljU3VyZmFjZU5vcm1hbChwb3NpdGlvbiwgbm9ybWFsKTtcblxuICAgIGlmIChzaGFkb3dWb2x1bWUpIHtcbiAgICAgIGV4dHJ1ZGVOb3JtYWxzW2kgKyBsZW5ndGhdID0gLW5vcm1hbC54O1xuICAgICAgZXh0cnVkZU5vcm1hbHNbaTEgKyBsZW5ndGhdID0gLW5vcm1hbC55O1xuICAgICAgZXh0cnVkZU5vcm1hbHNbaTIgKyBsZW5ndGhdID0gLW5vcm1hbC56O1xuICAgIH1cblxuICAgIHZhciBzY2FsZWROb3JtYWwgPSBDYXJ0ZXNpYW4zLm11bHRpcGx5QnlTY2FsYXIoXG4gICAgICBub3JtYWwsXG4gICAgICBoZWlnaHQsXG4gICAgICBzY3JhdGNoQ2FydGVzaWFuNFxuICAgICk7XG4gICAgcG9zaXRpb24gPSBDYXJ0ZXNpYW4zLmFkZChwb3NpdGlvbiwgc2NhbGVkTm9ybWFsLCBwb3NpdGlvbik7XG4gICAgc2NhbGVkTm9ybWFsID0gQ2FydGVzaWFuMy5tdWx0aXBseUJ5U2NhbGFyKFxuICAgICAgbm9ybWFsLFxuICAgICAgZXh0cnVkZWRIZWlnaHQsXG4gICAgICBzY2FsZWROb3JtYWxcbiAgICApO1xuICAgIGV4dHJ1ZGVkUG9zaXRpb24gPSBDYXJ0ZXNpYW4zLmFkZChcbiAgICAgIGV4dHJ1ZGVkUG9zaXRpb24sXG4gICAgICBzY2FsZWROb3JtYWwsXG4gICAgICBleHRydWRlZFBvc2l0aW9uXG4gICAgKTtcblxuICAgIGlmICh2ZXJ0ZXhGb3JtYXQucG9zaXRpb24pIHtcbiAgICAgIGZpbmFsUG9zaXRpb25zW2kgKyBsZW5ndGhdID0gZXh0cnVkZWRQb3NpdGlvbi54O1xuICAgICAgZmluYWxQb3NpdGlvbnNbaTEgKyBsZW5ndGhdID0gZXh0cnVkZWRQb3NpdGlvbi55O1xuICAgICAgZmluYWxQb3NpdGlvbnNbaTIgKyBsZW5ndGhdID0gZXh0cnVkZWRQb3NpdGlvbi56O1xuXG4gICAgICBmaW5hbFBvc2l0aW9uc1tpXSA9IHBvc2l0aW9uLng7XG4gICAgICBmaW5hbFBvc2l0aW9uc1tpMV0gPSBwb3NpdGlvbi55O1xuICAgICAgZmluYWxQb3NpdGlvbnNbaTJdID0gcG9zaXRpb24uejtcbiAgICB9XG5cbiAgICBpZiAodmVydGV4Rm9ybWF0Lm5vcm1hbCB8fCB2ZXJ0ZXhGb3JtYXQudGFuZ2VudCB8fCB2ZXJ0ZXhGb3JtYXQuYml0YW5nZW50KSB7XG4gICAgICBiaXRhbmdlbnQgPSBDYXJ0ZXNpYW4zLmNsb25lKG5vcm1hbCwgYml0YW5nZW50KTtcbiAgICAgIHZhciBuZXh0ID0gQ2FydGVzaWFuMy5mcm9tQXJyYXkoXG4gICAgICAgIHBvc2l0aW9ucyxcbiAgICAgICAgKGkgKyAzKSAlIGxlbmd0aCxcbiAgICAgICAgc2NyYXRjaENhcnRlc2lhbjRcbiAgICAgICk7XG4gICAgICBDYXJ0ZXNpYW4zLnN1YnRyYWN0KG5leHQsIHBvc2l0aW9uLCBuZXh0KTtcbiAgICAgIHZhciBib3R0b20gPSBDYXJ0ZXNpYW4zLnN1YnRyYWN0KFxuICAgICAgICBleHRydWRlZFBvc2l0aW9uLFxuICAgICAgICBwb3NpdGlvbixcbiAgICAgICAgc2NyYXRjaENhcnRlc2lhbjNcbiAgICAgICk7XG5cbiAgICAgIG5vcm1hbCA9IENhcnRlc2lhbjMubm9ybWFsaXplKFxuICAgICAgICBDYXJ0ZXNpYW4zLmNyb3NzKGJvdHRvbSwgbmV4dCwgbm9ybWFsKSxcbiAgICAgICAgbm9ybWFsXG4gICAgICApO1xuXG4gICAgICBpZiAodmVydGV4Rm9ybWF0Lm5vcm1hbCkge1xuICAgICAgICBub3JtYWxzW2ldID0gbm9ybWFsLng7XG4gICAgICAgIG5vcm1hbHNbaTFdID0gbm9ybWFsLnk7XG4gICAgICAgIG5vcm1hbHNbaTJdID0gbm9ybWFsLno7XG5cbiAgICAgICAgbm9ybWFsc1tpICsgbGVuZ3RoXSA9IG5vcm1hbC54O1xuICAgICAgICBub3JtYWxzW2kxICsgbGVuZ3RoXSA9IG5vcm1hbC55O1xuICAgICAgICBub3JtYWxzW2kyICsgbGVuZ3RoXSA9IG5vcm1hbC56O1xuICAgICAgfVxuXG4gICAgICBpZiAodmVydGV4Rm9ybWF0LnRhbmdlbnQpIHtcbiAgICAgICAgdGFuZ2VudCA9IENhcnRlc2lhbjMubm9ybWFsaXplKFxuICAgICAgICAgIENhcnRlc2lhbjMuY3Jvc3MoYml0YW5nZW50LCBub3JtYWwsIHRhbmdlbnQpLFxuICAgICAgICAgIHRhbmdlbnRcbiAgICAgICAgKTtcbiAgICAgICAgdGFuZ2VudHNbaV0gPSB0YW5nZW50Lng7XG4gICAgICAgIHRhbmdlbnRzW2kxXSA9IHRhbmdlbnQueTtcbiAgICAgICAgdGFuZ2VudHNbaTJdID0gdGFuZ2VudC56O1xuXG4gICAgICAgIHRhbmdlbnRzW2kgKyBsZW5ndGhdID0gdGFuZ2VudC54O1xuICAgICAgICB0YW5nZW50c1tpICsgMSArIGxlbmd0aF0gPSB0YW5nZW50Lnk7XG4gICAgICAgIHRhbmdlbnRzW2kgKyAyICsgbGVuZ3RoXSA9IHRhbmdlbnQuejtcbiAgICAgIH1cblxuICAgICAgaWYgKHZlcnRleEZvcm1hdC5iaXRhbmdlbnQpIHtcbiAgICAgICAgYml0YW5nZW50c1tpXSA9IGJpdGFuZ2VudC54O1xuICAgICAgICBiaXRhbmdlbnRzW2kxXSA9IGJpdGFuZ2VudC55O1xuICAgICAgICBiaXRhbmdlbnRzW2kyXSA9IGJpdGFuZ2VudC56O1xuXG4gICAgICAgIGJpdGFuZ2VudHNbaSArIGxlbmd0aF0gPSBiaXRhbmdlbnQueDtcbiAgICAgICAgYml0YW5nZW50c1tpMSArIGxlbmd0aF0gPSBiaXRhbmdlbnQueTtcbiAgICAgICAgYml0YW5nZW50c1tpMiArIGxlbmd0aF0gPSBiaXRhbmdlbnQuejtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBpZiAodmVydGV4Rm9ybWF0LnN0KSB7XG4gICAgbGVuZ3RoID0gdGV4dHVyZUNvb3JkaW5hdGVzLmxlbmd0aDtcbiAgICBmb3IgKHZhciBrID0gMDsgayA8IGxlbmd0aDsgayArPSAyKSB7XG4gICAgICB0ZXh0dXJlQ29vcmRpbmF0ZXNba10gPVxuICAgICAgICAodGV4dHVyZUNvb3JkaW5hdGVzW2tdIC0gbWluVGV4Q29vcmQueCkgL1xuICAgICAgICAobWF4VGV4Q29vcmQueCAtIG1pblRleENvb3JkLngpO1xuICAgICAgdGV4dHVyZUNvb3JkaW5hdGVzW2sgKyAxXSA9XG4gICAgICAgICh0ZXh0dXJlQ29vcmRpbmF0ZXNbayArIDFdIC0gbWluVGV4Q29vcmQueSkgL1xuICAgICAgICAobWF4VGV4Q29vcmQueSAtIG1pblRleENvb3JkLnkpO1xuICAgIH1cbiAgfVxuXG4gIHZhciBhdHRyaWJ1dGVzID0gbmV3IEdlb21ldHJ5QXR0cmlidXRlcygpO1xuXG4gIGlmICh2ZXJ0ZXhGb3JtYXQucG9zaXRpb24pIHtcbiAgICBhdHRyaWJ1dGVzLnBvc2l0aW9uID0gbmV3IEdlb21ldHJ5QXR0cmlidXRlKHtcbiAgICAgIGNvbXBvbmVudERhdGF0eXBlOiBDb21wb25lbnREYXRhdHlwZS5ET1VCTEUsXG4gICAgICBjb21wb25lbnRzUGVyQXR0cmlidXRlOiAzLFxuICAgICAgdmFsdWVzOiBmaW5hbFBvc2l0aW9ucyxcbiAgICB9KTtcbiAgfVxuXG4gIGlmICh2ZXJ0ZXhGb3JtYXQuc3QpIHtcbiAgICBhdHRyaWJ1dGVzLnN0ID0gbmV3IEdlb21ldHJ5QXR0cmlidXRlKHtcbiAgICAgIGNvbXBvbmVudERhdGF0eXBlOiBDb21wb25lbnREYXRhdHlwZS5GTE9BVCxcbiAgICAgIGNvbXBvbmVudHNQZXJBdHRyaWJ1dGU6IDIsXG4gICAgICB2YWx1ZXM6IHRleHR1cmVDb29yZGluYXRlcyxcbiAgICB9KTtcbiAgfVxuXG4gIGlmICh2ZXJ0ZXhGb3JtYXQubm9ybWFsKSB7XG4gICAgYXR0cmlidXRlcy5ub3JtYWwgPSBuZXcgR2VvbWV0cnlBdHRyaWJ1dGUoe1xuICAgICAgY29tcG9uZW50RGF0YXR5cGU6IENvbXBvbmVudERhdGF0eXBlLkZMT0FULFxuICAgICAgY29tcG9uZW50c1BlckF0dHJpYnV0ZTogMyxcbiAgICAgIHZhbHVlczogbm9ybWFscyxcbiAgICB9KTtcbiAgfVxuXG4gIGlmICh2ZXJ0ZXhGb3JtYXQudGFuZ2VudCkge1xuICAgIGF0dHJpYnV0ZXMudGFuZ2VudCA9IG5ldyBHZW9tZXRyeUF0dHJpYnV0ZSh7XG4gICAgICBjb21wb25lbnREYXRhdHlwZTogQ29tcG9uZW50RGF0YXR5cGUuRkxPQVQsXG4gICAgICBjb21wb25lbnRzUGVyQXR0cmlidXRlOiAzLFxuICAgICAgdmFsdWVzOiB0YW5nZW50cyxcbiAgICB9KTtcbiAgfVxuXG4gIGlmICh2ZXJ0ZXhGb3JtYXQuYml0YW5nZW50KSB7XG4gICAgYXR0cmlidXRlcy5iaXRhbmdlbnQgPSBuZXcgR2VvbWV0cnlBdHRyaWJ1dGUoe1xuICAgICAgY29tcG9uZW50RGF0YXR5cGU6IENvbXBvbmVudERhdGF0eXBlLkZMT0FULFxuICAgICAgY29tcG9uZW50c1BlckF0dHJpYnV0ZTogMyxcbiAgICAgIHZhbHVlczogYml0YW5nZW50cyxcbiAgICB9KTtcbiAgfVxuXG4gIGlmIChzaGFkb3dWb2x1bWUpIHtcbiAgICBhdHRyaWJ1dGVzLmV4dHJ1ZGVEaXJlY3Rpb24gPSBuZXcgR2VvbWV0cnlBdHRyaWJ1dGUoe1xuICAgICAgY29tcG9uZW50RGF0YXR5cGU6IENvbXBvbmVudERhdGF0eXBlLkZMT0FULFxuICAgICAgY29tcG9uZW50c1BlckF0dHJpYnV0ZTogMyxcbiAgICAgIHZhbHVlczogZXh0cnVkZU5vcm1hbHMsXG4gICAgfSk7XG4gIH1cblxuICBpZiAoZGVmaW5lZChvcHRpb25zLm9mZnNldEF0dHJpYnV0ZSkpIHtcbiAgICB2YXIgb2Zmc2V0QXR0cmlidXRlID0gbmV3IFVpbnQ4QXJyYXkoc2l6ZSk7XG4gICAgaWYgKG9wdGlvbnMub2Zmc2V0QXR0cmlidXRlID09PSBHZW9tZXRyeU9mZnNldEF0dHJpYnV0ZS5UT1ApIHtcbiAgICAgIG9mZnNldEF0dHJpYnV0ZSA9IGFycmF5RmlsbChvZmZzZXRBdHRyaWJ1dGUsIDEsIDAsIHNpemUgLyAyKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIG9mZnNldFZhbHVlID1cbiAgICAgICAgb3B0aW9ucy5vZmZzZXRBdHRyaWJ1dGUgPT09IEdlb21ldHJ5T2Zmc2V0QXR0cmlidXRlLk5PTkUgPyAwIDogMTtcbiAgICAgIG9mZnNldEF0dHJpYnV0ZSA9IGFycmF5RmlsbChvZmZzZXRBdHRyaWJ1dGUsIG9mZnNldFZhbHVlKTtcbiAgICB9XG4gICAgYXR0cmlidXRlcy5hcHBseU9mZnNldCA9IG5ldyBHZW9tZXRyeUF0dHJpYnV0ZSh7XG4gICAgICBjb21wb25lbnREYXRhdHlwZTogQ29tcG9uZW50RGF0YXR5cGUuVU5TSUdORURfQllURSxcbiAgICAgIGNvbXBvbmVudHNQZXJBdHRyaWJ1dGU6IDEsXG4gICAgICB2YWx1ZXM6IG9mZnNldEF0dHJpYnV0ZSxcbiAgICB9KTtcbiAgfVxuXG4gIHJldHVybiBhdHRyaWJ1dGVzO1xufVxuXG5mdW5jdGlvbiBjb21wdXRlV2FsbEluZGljZXMocG9zaXRpb25zKSB7XG4gIHZhciBsZW5ndGggPSBwb3NpdGlvbnMubGVuZ3RoIC8gMztcbiAgdmFyIGluZGljZXMgPSBJbmRleERhdGF0eXBlLmNyZWF0ZVR5cGVkQXJyYXkobGVuZ3RoLCBsZW5ndGggKiA2KTtcbiAgdmFyIGluZGV4ID0gMDtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgIHZhciBVTCA9IGk7XG4gICAgdmFyIExMID0gaSArIGxlbmd0aDtcbiAgICB2YXIgVVIgPSAoVUwgKyAxKSAlIGxlbmd0aDtcbiAgICB2YXIgTFIgPSBVUiArIGxlbmd0aDtcbiAgICBpbmRpY2VzW2luZGV4KytdID0gVUw7XG4gICAgaW5kaWNlc1tpbmRleCsrXSA9IExMO1xuICAgIGluZGljZXNbaW5kZXgrK10gPSBVUjtcbiAgICBpbmRpY2VzW2luZGV4KytdID0gVVI7XG4gICAgaW5kaWNlc1tpbmRleCsrXSA9IExMO1xuICAgIGluZGljZXNbaW5kZXgrK10gPSBMUjtcbiAgfVxuXG4gIHJldHVybiBpbmRpY2VzO1xufVxuXG52YXIgdG9wQm91bmRpbmdTcGhlcmUgPSBuZXcgQm91bmRpbmdTcGhlcmUoKTtcbnZhciBib3R0b21Cb3VuZGluZ1NwaGVyZSA9IG5ldyBCb3VuZGluZ1NwaGVyZSgpO1xuXG5mdW5jdGlvbiBjb21wdXRlRXh0cnVkZWRFbGxpcHNlKG9wdGlvbnMpIHtcbiAgdmFyIGNlbnRlciA9IG9wdGlvbnMuY2VudGVyO1xuICB2YXIgZWxsaXBzb2lkID0gb3B0aW9ucy5lbGxpcHNvaWQ7XG4gIHZhciBzZW1pTWFqb3JBeGlzID0gb3B0aW9ucy5zZW1pTWFqb3JBeGlzO1xuICB2YXIgc2NhbGVkTm9ybWFsID0gQ2FydGVzaWFuMy5tdWx0aXBseUJ5U2NhbGFyKFxuICAgIGVsbGlwc29pZC5nZW9kZXRpY1N1cmZhY2VOb3JtYWwoY2VudGVyLCBzY3JhdGNoQ2FydGVzaWFuMSksXG4gICAgb3B0aW9ucy5oZWlnaHQsXG4gICAgc2NyYXRjaENhcnRlc2lhbjFcbiAgKTtcbiAgdG9wQm91bmRpbmdTcGhlcmUuY2VudGVyID0gQ2FydGVzaWFuMy5hZGQoXG4gICAgY2VudGVyLFxuICAgIHNjYWxlZE5vcm1hbCxcbiAgICB0b3BCb3VuZGluZ1NwaGVyZS5jZW50ZXJcbiAgKTtcbiAgdG9wQm91bmRpbmdTcGhlcmUucmFkaXVzID0gc2VtaU1ham9yQXhpcztcblxuICBzY2FsZWROb3JtYWwgPSBDYXJ0ZXNpYW4zLm11bHRpcGx5QnlTY2FsYXIoXG4gICAgZWxsaXBzb2lkLmdlb2RldGljU3VyZmFjZU5vcm1hbChjZW50ZXIsIHNjYWxlZE5vcm1hbCksXG4gICAgb3B0aW9ucy5leHRydWRlZEhlaWdodCxcbiAgICBzY2FsZWROb3JtYWxcbiAgKTtcbiAgYm90dG9tQm91bmRpbmdTcGhlcmUuY2VudGVyID0gQ2FydGVzaWFuMy5hZGQoXG4gICAgY2VudGVyLFxuICAgIHNjYWxlZE5vcm1hbCxcbiAgICBib3R0b21Cb3VuZGluZ1NwaGVyZS5jZW50ZXJcbiAgKTtcbiAgYm90dG9tQm91bmRpbmdTcGhlcmUucmFkaXVzID0gc2VtaU1ham9yQXhpcztcblxuICB2YXIgY2VwID0gRWxsaXBzZUdlb21ldHJ5TGlicmFyeS5jb21wdXRlRWxsaXBzZVBvc2l0aW9ucyhvcHRpb25zLCB0cnVlLCB0cnVlKTtcbiAgdmFyIHBvc2l0aW9ucyA9IGNlcC5wb3NpdGlvbnM7XG4gIHZhciBudW1QdHMgPSBjZXAubnVtUHRzO1xuICB2YXIgb3V0ZXJQb3NpdGlvbnMgPSBjZXAub3V0ZXJQb3NpdGlvbnM7XG4gIHZhciBib3VuZGluZ1NwaGVyZSA9IEJvdW5kaW5nU3BoZXJlLnVuaW9uKFxuICAgIHRvcEJvdW5kaW5nU3BoZXJlLFxuICAgIGJvdHRvbUJvdW5kaW5nU3BoZXJlXG4gICk7XG4gIHZhciB0b3BCb3R0b21BdHRyaWJ1dGVzID0gY29tcHV0ZVRvcEJvdHRvbUF0dHJpYnV0ZXMoXG4gICAgcG9zaXRpb25zLFxuICAgIG9wdGlvbnMsXG4gICAgdHJ1ZVxuICApO1xuICB2YXIgaW5kaWNlcyA9IHRvcEluZGljZXMobnVtUHRzKTtcbiAgdmFyIGxlbmd0aCA9IGluZGljZXMubGVuZ3RoO1xuICBpbmRpY2VzLmxlbmd0aCA9IGxlbmd0aCAqIDI7XG4gIHZhciBwb3NMZW5ndGggPSBwb3NpdGlvbnMubGVuZ3RoIC8gMztcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkgKz0gMykge1xuICAgIGluZGljZXNbaSArIGxlbmd0aF0gPSBpbmRpY2VzW2kgKyAyXSArIHBvc0xlbmd0aDtcbiAgICBpbmRpY2VzW2kgKyAxICsgbGVuZ3RoXSA9IGluZGljZXNbaSArIDFdICsgcG9zTGVuZ3RoO1xuICAgIGluZGljZXNbaSArIDIgKyBsZW5ndGhdID0gaW5kaWNlc1tpXSArIHBvc0xlbmd0aDtcbiAgfVxuXG4gIHZhciB0b3BCb3R0b21JbmRpY2VzID0gSW5kZXhEYXRhdHlwZS5jcmVhdGVUeXBlZEFycmF5KFxuICAgIChwb3NMZW5ndGggKiAyKSAvIDMsXG4gICAgaW5kaWNlc1xuICApO1xuXG4gIHZhciB0b3BCb3R0b21HZW8gPSBuZXcgR2VvbWV0cnkoe1xuICAgIGF0dHJpYnV0ZXM6IHRvcEJvdHRvbUF0dHJpYnV0ZXMsXG4gICAgaW5kaWNlczogdG9wQm90dG9tSW5kaWNlcyxcbiAgICBwcmltaXRpdmVUeXBlOiBQcmltaXRpdmVUeXBlLlRSSUFOR0xFUyxcbiAgfSk7XG5cbiAgdmFyIHdhbGxBdHRyaWJ1dGVzID0gY29tcHV0ZVdhbGxBdHRyaWJ1dGVzKG91dGVyUG9zaXRpb25zLCBvcHRpb25zKTtcbiAgaW5kaWNlcyA9IGNvbXB1dGVXYWxsSW5kaWNlcyhvdXRlclBvc2l0aW9ucyk7XG4gIHZhciB3YWxsSW5kaWNlcyA9IEluZGV4RGF0YXR5cGUuY3JlYXRlVHlwZWRBcnJheShcbiAgICAob3V0ZXJQb3NpdGlvbnMubGVuZ3RoICogMikgLyAzLFxuICAgIGluZGljZXNcbiAgKTtcblxuICB2YXIgd2FsbEdlbyA9IG5ldyBHZW9tZXRyeSh7XG4gICAgYXR0cmlidXRlczogd2FsbEF0dHJpYnV0ZXMsXG4gICAgaW5kaWNlczogd2FsbEluZGljZXMsXG4gICAgcHJpbWl0aXZlVHlwZTogUHJpbWl0aXZlVHlwZS5UUklBTkdMRVMsXG4gIH0pO1xuXG4gIHZhciBnZW8gPSBHZW9tZXRyeVBpcGVsaW5lLmNvbWJpbmVJbnN0YW5jZXMoW1xuICAgIG5ldyBHZW9tZXRyeUluc3RhbmNlKHtcbiAgICAgIGdlb21ldHJ5OiB0b3BCb3R0b21HZW8sXG4gICAgfSksXG4gICAgbmV3IEdlb21ldHJ5SW5zdGFuY2Uoe1xuICAgICAgZ2VvbWV0cnk6IHdhbGxHZW8sXG4gICAgfSksXG4gIF0pO1xuXG4gIHJldHVybiB7XG4gICAgYm91bmRpbmdTcGhlcmU6IGJvdW5kaW5nU3BoZXJlLFxuICAgIGF0dHJpYnV0ZXM6IGdlb1swXS5hdHRyaWJ1dGVzLFxuICAgIGluZGljZXM6IGdlb1swXS5pbmRpY2VzLFxuICB9O1xufVxuXG5mdW5jdGlvbiBjb21wdXRlUmVjdGFuZ2xlKFxuICBjZW50ZXIsXG4gIHNlbWlNYWpvckF4aXMsXG4gIHNlbWlNaW5vckF4aXMsXG4gIHJvdGF0aW9uLFxuICBncmFudWxhcml0eSxcbiAgZWxsaXBzb2lkLFxuICByZXN1bHRcbikge1xuICB2YXIgY2VwID0gRWxsaXBzZUdlb21ldHJ5TGlicmFyeS5jb21wdXRlRWxsaXBzZVBvc2l0aW9ucyhcbiAgICB7XG4gICAgICBjZW50ZXI6IGNlbnRlcixcbiAgICAgIHNlbWlNYWpvckF4aXM6IHNlbWlNYWpvckF4aXMsXG4gICAgICBzZW1pTWlub3JBeGlzOiBzZW1pTWlub3JBeGlzLFxuICAgICAgcm90YXRpb246IHJvdGF0aW9uLFxuICAgICAgZ3JhbnVsYXJpdHk6IGdyYW51bGFyaXR5LFxuICAgIH0sXG4gICAgZmFsc2UsXG4gICAgdHJ1ZVxuICApO1xuICB2YXIgcG9zaXRpb25zRmxhdCA9IGNlcC5vdXRlclBvc2l0aW9ucztcbiAgdmFyIHBvc2l0aW9uc0NvdW50ID0gcG9zaXRpb25zRmxhdC5sZW5ndGggLyAzO1xuICB2YXIgcG9zaXRpb25zID0gbmV3IEFycmF5KHBvc2l0aW9uc0NvdW50KTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBwb3NpdGlvbnNDb3VudDsgKytpKSB7XG4gICAgcG9zaXRpb25zW2ldID0gQ2FydGVzaWFuMy5mcm9tQXJyYXkocG9zaXRpb25zRmxhdCwgaSAqIDMpO1xuICB9XG4gIHZhciByZWN0YW5nbGUgPSBSZWN0YW5nbGUuZnJvbUNhcnRlc2lhbkFycmF5KHBvc2l0aW9ucywgZWxsaXBzb2lkLCByZXN1bHQpO1xuICAvLyBSZWN0YW5nbGUgd2lkdGggZ29lcyBiZXlvbmQgMTgwIGRlZ3JlZXMgd2hlbiB0aGUgZWxsaXBzZSBjcm9zc2VzIGEgcG9sZS5cbiAgLy8gV2hlbiB0aGlzIGhhcHBlbnMsIG1ha2UgdGhlIHJlY3RhbmdsZSBpbnRvIGEgXCJjaXJjbGVcIiBhcm91bmQgdGhlIHBvbGVcbiAgaWYgKHJlY3RhbmdsZS53aWR0aCA+IENlc2l1bU1hdGguUEkpIHtcbiAgICByZWN0YW5nbGUubm9ydGggPVxuICAgICAgcmVjdGFuZ2xlLm5vcnRoID4gMC4wXG4gICAgICAgID8gQ2VzaXVtTWF0aC5QSV9PVkVSX1RXTyAtIENlc2l1bU1hdGguRVBTSUxPTjdcbiAgICAgICAgOiByZWN0YW5nbGUubm9ydGg7XG4gICAgcmVjdGFuZ2xlLnNvdXRoID1cbiAgICAgIHJlY3RhbmdsZS5zb3V0aCA8IDAuMFxuICAgICAgICA/IENlc2l1bU1hdGguRVBTSUxPTjcgLSBDZXNpdW1NYXRoLlBJX09WRVJfVFdPXG4gICAgICAgIDogcmVjdGFuZ2xlLnNvdXRoO1xuICAgIHJlY3RhbmdsZS5lYXN0ID0gQ2VzaXVtTWF0aC5QSTtcbiAgICByZWN0YW5nbGUud2VzdCA9IC1DZXNpdW1NYXRoLlBJO1xuICB9XG4gIHJldHVybiByZWN0YW5nbGU7XG59XG5cbi8qKlxuICogQSBkZXNjcmlwdGlvbiBvZiBhbiBlbGxpcHNlIG9uIGFuIGVsbGlwc29pZC4gRWxsaXBzZSBnZW9tZXRyeSBjYW4gYmUgcmVuZGVyZWQgd2l0aCBib3RoIHtAbGluayBQcmltaXRpdmV9IGFuZCB7QGxpbmsgR3JvdW5kUHJpbWl0aXZlfS5cbiAqXG4gKiBAYWxpYXMgRWxsaXBzZUdlb21ldHJ5XG4gKiBAY29uc3RydWN0b3JcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyBPYmplY3Qgd2l0aCB0aGUgZm9sbG93aW5nIHByb3BlcnRpZXM6XG4gKiBAcGFyYW0ge0NhcnRlc2lhbjN9IG9wdGlvbnMuY2VudGVyIFRoZSBlbGxpcHNlJ3MgY2VudGVyIHBvaW50IGluIHRoZSBmaXhlZCBmcmFtZS5cbiAqIEBwYXJhbSB7TnVtYmVyfSBvcHRpb25zLnNlbWlNYWpvckF4aXMgVGhlIGxlbmd0aCBvZiB0aGUgZWxsaXBzZSdzIHNlbWktbWFqb3IgYXhpcyBpbiBtZXRlcnMuXG4gKiBAcGFyYW0ge051bWJlcn0gb3B0aW9ucy5zZW1pTWlub3JBeGlzIFRoZSBsZW5ndGggb2YgdGhlIGVsbGlwc2UncyBzZW1pLW1pbm9yIGF4aXMgaW4gbWV0ZXJzLlxuICogQHBhcmFtIHtFbGxpcHNvaWR9IFtvcHRpb25zLmVsbGlwc29pZD1FbGxpcHNvaWQuV0dTODRdIFRoZSBlbGxpcHNvaWQgdGhlIGVsbGlwc2Ugd2lsbCBiZSBvbi5cbiAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5oZWlnaHQ9MC4wXSBUaGUgZGlzdGFuY2UgaW4gbWV0ZXJzIGJldHdlZW4gdGhlIGVsbGlwc2UgYW5kIHRoZSBlbGxpcHNvaWQgc3VyZmFjZS5cbiAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5leHRydWRlZEhlaWdodF0gVGhlIGRpc3RhbmNlIGluIG1ldGVycyBiZXR3ZWVuIHRoZSBlbGxpcHNlJ3MgZXh0cnVkZWQgZmFjZSBhbmQgdGhlIGVsbGlwc29pZCBzdXJmYWNlLlxuICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLnJvdGF0aW9uPTAuMF0gVGhlIGFuZ2xlIG9mIHJvdGF0aW9uIGNvdW50ZXItY2xvY2t3aXNlIGZyb20gbm9ydGguXG4gKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMuc3RSb3RhdGlvbj0wLjBdIFRoZSByb3RhdGlvbiBvZiB0aGUgdGV4dHVyZSBjb29yZGluYXRlcyBjb3VudGVyLWNsb2Nrd2lzZSBmcm9tIG5vcnRoLlxuICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLmdyYW51bGFyaXR5PUNlc2l1bU1hdGguUkFESUFOU19QRVJfREVHUkVFXSBUaGUgYW5ndWxhciBkaXN0YW5jZSBiZXR3ZWVuIHBvaW50cyBvbiB0aGUgZWxsaXBzZSBpbiByYWRpYW5zLlxuICogQHBhcmFtIHtWZXJ0ZXhGb3JtYXR9IFtvcHRpb25zLnZlcnRleEZvcm1hdD1WZXJ0ZXhGb3JtYXQuREVGQVVMVF0gVGhlIHZlcnRleCBhdHRyaWJ1dGVzIHRvIGJlIGNvbXB1dGVkLlxuICpcbiAqIEBleGNlcHRpb24ge0RldmVsb3BlckVycm9yfSBzZW1pTWFqb3JBeGlzIGFuZCBzZW1pTWlub3JBeGlzIG11c3QgYmUgZ3JlYXRlciB0aGFuIHplcm8uXG4gKiBAZXhjZXB0aW9uIHtEZXZlbG9wZXJFcnJvcn0gc2VtaU1ham9yQXhpcyBtdXN0IGJlIGdyZWF0ZXIgdGhhbiBvciBlcXVhbCB0byB0aGUgc2VtaU1pbm9yQXhpcy5cbiAqIEBleGNlcHRpb24ge0RldmVsb3BlckVycm9yfSBncmFudWxhcml0eSBtdXN0IGJlIGdyZWF0ZXIgdGhhbiB6ZXJvLlxuICpcbiAqXG4gKiBAZXhhbXBsZVxuICogLy8gQ3JlYXRlIGFuIGVsbGlwc2UuXG4gKiB2YXIgZWxsaXBzZSA9IG5ldyBDZXNpdW0uRWxsaXBzZUdlb21ldHJ5KHtcbiAqICAgY2VudGVyIDogQ2VzaXVtLkNhcnRlc2lhbjMuZnJvbURlZ3JlZXMoLTc1LjU5Nzc3LCA0MC4wMzg4MyksXG4gKiAgIHNlbWlNYWpvckF4aXMgOiA1MDAwMDAuMCxcbiAqICAgc2VtaU1pbm9yQXhpcyA6IDMwMDAwMC4wLFxuICogICByb3RhdGlvbiA6IENlc2l1bS5NYXRoLnRvUmFkaWFucyg2MC4wKVxuICogfSk7XG4gKiB2YXIgZ2VvbWV0cnkgPSBDZXNpdW0uRWxsaXBzZUdlb21ldHJ5LmNyZWF0ZUdlb21ldHJ5KGVsbGlwc2UpO1xuICpcbiAqIEBzZWUgRWxsaXBzZUdlb21ldHJ5LmNyZWF0ZUdlb21ldHJ5XG4gKi9cbmZ1bmN0aW9uIEVsbGlwc2VHZW9tZXRyeShvcHRpb25zKSB7XG4gIG9wdGlvbnMgPSBkZWZhdWx0VmFsdWUob3B0aW9ucywgZGVmYXVsdFZhbHVlLkVNUFRZX09CSkVDVCk7XG5cbiAgdmFyIGNlbnRlciA9IG9wdGlvbnMuY2VudGVyO1xuICB2YXIgZWxsaXBzb2lkID0gZGVmYXVsdFZhbHVlKG9wdGlvbnMuZWxsaXBzb2lkLCBFbGxpcHNvaWQuV0dTODQpO1xuICB2YXIgc2VtaU1ham9yQXhpcyA9IG9wdGlvbnMuc2VtaU1ham9yQXhpcztcbiAgdmFyIHNlbWlNaW5vckF4aXMgPSBvcHRpb25zLnNlbWlNaW5vckF4aXM7XG4gIHZhciBncmFudWxhcml0eSA9IGRlZmF1bHRWYWx1ZShcbiAgICBvcHRpb25zLmdyYW51bGFyaXR5LFxuICAgIENlc2l1bU1hdGguUkFESUFOU19QRVJfREVHUkVFXG4gICk7XG4gIHZhciB2ZXJ0ZXhGb3JtYXQgPSBkZWZhdWx0VmFsdWUob3B0aW9ucy52ZXJ0ZXhGb3JtYXQsIFZlcnRleEZvcm1hdC5ERUZBVUxUKTtcblxuICAvLz4+aW5jbHVkZVN0YXJ0KCdkZWJ1ZycsIHByYWdtYXMuZGVidWcpO1xuICBDaGVjay5kZWZpbmVkKFwib3B0aW9ucy5jZW50ZXJcIiwgY2VudGVyKTtcbiAgQ2hlY2sudHlwZU9mLm51bWJlcihcIm9wdGlvbnMuc2VtaU1ham9yQXhpc1wiLCBzZW1pTWFqb3JBeGlzKTtcbiAgQ2hlY2sudHlwZU9mLm51bWJlcihcIm9wdGlvbnMuc2VtaU1pbm9yQXhpc1wiLCBzZW1pTWlub3JBeGlzKTtcbiAgaWYgKHNlbWlNYWpvckF4aXMgPCBzZW1pTWlub3JBeGlzKSB7XG4gICAgdGhyb3cgbmV3IERldmVsb3BlckVycm9yKFxuICAgICAgXCJzZW1pTWFqb3JBeGlzIG11c3QgYmUgZ3JlYXRlciB0aGFuIG9yIGVxdWFsIHRvIHRoZSBzZW1pTWlub3JBeGlzLlwiXG4gICAgKTtcbiAgfVxuICBpZiAoZ3JhbnVsYXJpdHkgPD0gMC4wKSB7XG4gICAgdGhyb3cgbmV3IERldmVsb3BlckVycm9yKFwiZ3JhbnVsYXJpdHkgbXVzdCBiZSBncmVhdGVyIHRoYW4gemVyby5cIik7XG4gIH1cbiAgLy8+PmluY2x1ZGVFbmQoJ2RlYnVnJyk7XG5cbiAgdmFyIGhlaWdodCA9IGRlZmF1bHRWYWx1ZShvcHRpb25zLmhlaWdodCwgMC4wKTtcbiAgdmFyIGV4dHJ1ZGVkSGVpZ2h0ID0gZGVmYXVsdFZhbHVlKG9wdGlvbnMuZXh0cnVkZWRIZWlnaHQsIGhlaWdodCk7XG5cbiAgdGhpcy5fY2VudGVyID0gQ2FydGVzaWFuMy5jbG9uZShjZW50ZXIpO1xuICB0aGlzLl9zZW1pTWFqb3JBeGlzID0gc2VtaU1ham9yQXhpcztcbiAgdGhpcy5fc2VtaU1pbm9yQXhpcyA9IHNlbWlNaW5vckF4aXM7XG4gIHRoaXMuX2VsbGlwc29pZCA9IEVsbGlwc29pZC5jbG9uZShlbGxpcHNvaWQpO1xuICB0aGlzLl9yb3RhdGlvbiA9IGRlZmF1bHRWYWx1ZShvcHRpb25zLnJvdGF0aW9uLCAwLjApO1xuICB0aGlzLl9zdFJvdGF0aW9uID0gZGVmYXVsdFZhbHVlKG9wdGlvbnMuc3RSb3RhdGlvbiwgMC4wKTtcbiAgdGhpcy5faGVpZ2h0ID0gTWF0aC5tYXgoZXh0cnVkZWRIZWlnaHQsIGhlaWdodCk7XG4gIHRoaXMuX2dyYW51bGFyaXR5ID0gZ3JhbnVsYXJpdHk7XG4gIHRoaXMuX3ZlcnRleEZvcm1hdCA9IFZlcnRleEZvcm1hdC5jbG9uZSh2ZXJ0ZXhGb3JtYXQpO1xuICB0aGlzLl9leHRydWRlZEhlaWdodCA9IE1hdGgubWluKGV4dHJ1ZGVkSGVpZ2h0LCBoZWlnaHQpO1xuICB0aGlzLl9zaGFkb3dWb2x1bWUgPSBkZWZhdWx0VmFsdWUob3B0aW9ucy5zaGFkb3dWb2x1bWUsIGZhbHNlKTtcbiAgdGhpcy5fd29ya2VyTmFtZSA9IFwiY3JlYXRlRWxsaXBzZUdlb21ldHJ5XCI7XG4gIHRoaXMuX29mZnNldEF0dHJpYnV0ZSA9IG9wdGlvbnMub2Zmc2V0QXR0cmlidXRlO1xuXG4gIHRoaXMuX3JlY3RhbmdsZSA9IHVuZGVmaW5lZDtcbiAgdGhpcy5fdGV4dHVyZUNvb3JkaW5hdGVSb3RhdGlvblBvaW50cyA9IHVuZGVmaW5lZDtcbn1cblxuLyoqXG4gKiBUaGUgbnVtYmVyIG9mIGVsZW1lbnRzIHVzZWQgdG8gcGFjayB0aGUgb2JqZWN0IGludG8gYW4gYXJyYXkuXG4gKiBAdHlwZSB7TnVtYmVyfVxuICovXG5FbGxpcHNlR2VvbWV0cnkucGFja2VkTGVuZ3RoID1cbiAgQ2FydGVzaWFuMy5wYWNrZWRMZW5ndGggK1xuICBFbGxpcHNvaWQucGFja2VkTGVuZ3RoICtcbiAgVmVydGV4Rm9ybWF0LnBhY2tlZExlbmd0aCArXG4gIDk7XG5cbi8qKlxuICogU3RvcmVzIHRoZSBwcm92aWRlZCBpbnN0YW5jZSBpbnRvIHRoZSBwcm92aWRlZCBhcnJheS5cbiAqXG4gKiBAcGFyYW0ge0VsbGlwc2VHZW9tZXRyeX0gdmFsdWUgVGhlIHZhbHVlIHRvIHBhY2suXG4gKiBAcGFyYW0ge051bWJlcltdfSBhcnJheSBUaGUgYXJyYXkgdG8gcGFjayBpbnRvLlxuICogQHBhcmFtIHtOdW1iZXJ9IFtzdGFydGluZ0luZGV4PTBdIFRoZSBpbmRleCBpbnRvIHRoZSBhcnJheSBhdCB3aGljaCB0byBzdGFydCBwYWNraW5nIHRoZSBlbGVtZW50cy5cbiAqXG4gKiBAcmV0dXJucyB7TnVtYmVyW119IFRoZSBhcnJheSB0aGF0IHdhcyBwYWNrZWQgaW50b1xuICovXG5FbGxpcHNlR2VvbWV0cnkucGFjayA9IGZ1bmN0aW9uICh2YWx1ZSwgYXJyYXksIHN0YXJ0aW5nSW5kZXgpIHtcbiAgLy8+PmluY2x1ZGVTdGFydCgnZGVidWcnLCBwcmFnbWFzLmRlYnVnKTtcbiAgQ2hlY2suZGVmaW5lZChcInZhbHVlXCIsIHZhbHVlKTtcbiAgQ2hlY2suZGVmaW5lZChcImFycmF5XCIsIGFycmF5KTtcbiAgLy8+PmluY2x1ZGVFbmQoJ2RlYnVnJyk7XG5cbiAgc3RhcnRpbmdJbmRleCA9IGRlZmF1bHRWYWx1ZShzdGFydGluZ0luZGV4LCAwKTtcblxuICBDYXJ0ZXNpYW4zLnBhY2sodmFsdWUuX2NlbnRlciwgYXJyYXksIHN0YXJ0aW5nSW5kZXgpO1xuICBzdGFydGluZ0luZGV4ICs9IENhcnRlc2lhbjMucGFja2VkTGVuZ3RoO1xuXG4gIEVsbGlwc29pZC5wYWNrKHZhbHVlLl9lbGxpcHNvaWQsIGFycmF5LCBzdGFydGluZ0luZGV4KTtcbiAgc3RhcnRpbmdJbmRleCArPSBFbGxpcHNvaWQucGFja2VkTGVuZ3RoO1xuXG4gIFZlcnRleEZvcm1hdC5wYWNrKHZhbHVlLl92ZXJ0ZXhGb3JtYXQsIGFycmF5LCBzdGFydGluZ0luZGV4KTtcbiAgc3RhcnRpbmdJbmRleCArPSBWZXJ0ZXhGb3JtYXQucGFja2VkTGVuZ3RoO1xuXG4gIGFycmF5W3N0YXJ0aW5nSW5kZXgrK10gPSB2YWx1ZS5fc2VtaU1ham9yQXhpcztcbiAgYXJyYXlbc3RhcnRpbmdJbmRleCsrXSA9IHZhbHVlLl9zZW1pTWlub3JBeGlzO1xuICBhcnJheVtzdGFydGluZ0luZGV4KytdID0gdmFsdWUuX3JvdGF0aW9uO1xuICBhcnJheVtzdGFydGluZ0luZGV4KytdID0gdmFsdWUuX3N0Um90YXRpb247XG4gIGFycmF5W3N0YXJ0aW5nSW5kZXgrK10gPSB2YWx1ZS5faGVpZ2h0O1xuICBhcnJheVtzdGFydGluZ0luZGV4KytdID0gdmFsdWUuX2dyYW51bGFyaXR5O1xuICBhcnJheVtzdGFydGluZ0luZGV4KytdID0gdmFsdWUuX2V4dHJ1ZGVkSGVpZ2h0O1xuICBhcnJheVtzdGFydGluZ0luZGV4KytdID0gdmFsdWUuX3NoYWRvd1ZvbHVtZSA/IDEuMCA6IDAuMDtcbiAgYXJyYXlbc3RhcnRpbmdJbmRleF0gPSBkZWZhdWx0VmFsdWUodmFsdWUuX29mZnNldEF0dHJpYnV0ZSwgLTEpO1xuXG4gIHJldHVybiBhcnJheTtcbn07XG5cbnZhciBzY3JhdGNoQ2VudGVyID0gbmV3IENhcnRlc2lhbjMoKTtcbnZhciBzY3JhdGNoRWxsaXBzb2lkID0gbmV3IEVsbGlwc29pZCgpO1xudmFyIHNjcmF0Y2hWZXJ0ZXhGb3JtYXQgPSBuZXcgVmVydGV4Rm9ybWF0KCk7XG52YXIgc2NyYXRjaE9wdGlvbnMgPSB7XG4gIGNlbnRlcjogc2NyYXRjaENlbnRlcixcbiAgZWxsaXBzb2lkOiBzY3JhdGNoRWxsaXBzb2lkLFxuICB2ZXJ0ZXhGb3JtYXQ6IHNjcmF0Y2hWZXJ0ZXhGb3JtYXQsXG4gIHNlbWlNYWpvckF4aXM6IHVuZGVmaW5lZCxcbiAgc2VtaU1pbm9yQXhpczogdW5kZWZpbmVkLFxuICByb3RhdGlvbjogdW5kZWZpbmVkLFxuICBzdFJvdGF0aW9uOiB1bmRlZmluZWQsXG4gIGhlaWdodDogdW5kZWZpbmVkLFxuICBncmFudWxhcml0eTogdW5kZWZpbmVkLFxuICBleHRydWRlZEhlaWdodDogdW5kZWZpbmVkLFxuICBzaGFkb3dWb2x1bWU6IHVuZGVmaW5lZCxcbiAgb2Zmc2V0QXR0cmlidXRlOiB1bmRlZmluZWQsXG59O1xuXG4vKipcbiAqIFJldHJpZXZlcyBhbiBpbnN0YW5jZSBmcm9tIGEgcGFja2VkIGFycmF5LlxuICpcbiAqIEBwYXJhbSB7TnVtYmVyW119IGFycmF5IFRoZSBwYWNrZWQgYXJyYXkuXG4gKiBAcGFyYW0ge051bWJlcn0gW3N0YXJ0aW5nSW5kZXg9MF0gVGhlIHN0YXJ0aW5nIGluZGV4IG9mIHRoZSBlbGVtZW50IHRvIGJlIHVucGFja2VkLlxuICogQHBhcmFtIHtFbGxpcHNlR2VvbWV0cnl9IFtyZXN1bHRdIFRoZSBvYmplY3QgaW50byB3aGljaCB0byBzdG9yZSB0aGUgcmVzdWx0LlxuICogQHJldHVybnMge0VsbGlwc2VHZW9tZXRyeX0gVGhlIG1vZGlmaWVkIHJlc3VsdCBwYXJhbWV0ZXIgb3IgYSBuZXcgRWxsaXBzZUdlb21ldHJ5IGluc3RhbmNlIGlmIG9uZSB3YXMgbm90IHByb3ZpZGVkLlxuICovXG5FbGxpcHNlR2VvbWV0cnkudW5wYWNrID0gZnVuY3Rpb24gKGFycmF5LCBzdGFydGluZ0luZGV4LCByZXN1bHQpIHtcbiAgLy8+PmluY2x1ZGVTdGFydCgnZGVidWcnLCBwcmFnbWFzLmRlYnVnKTtcbiAgQ2hlY2suZGVmaW5lZChcImFycmF5XCIsIGFycmF5KTtcbiAgLy8+PmluY2x1ZGVFbmQoJ2RlYnVnJyk7XG5cbiAgc3RhcnRpbmdJbmRleCA9IGRlZmF1bHRWYWx1ZShzdGFydGluZ0luZGV4LCAwKTtcblxuICB2YXIgY2VudGVyID0gQ2FydGVzaWFuMy51bnBhY2soYXJyYXksIHN0YXJ0aW5nSW5kZXgsIHNjcmF0Y2hDZW50ZXIpO1xuICBzdGFydGluZ0luZGV4ICs9IENhcnRlc2lhbjMucGFja2VkTGVuZ3RoO1xuXG4gIHZhciBlbGxpcHNvaWQgPSBFbGxpcHNvaWQudW5wYWNrKGFycmF5LCBzdGFydGluZ0luZGV4LCBzY3JhdGNoRWxsaXBzb2lkKTtcbiAgc3RhcnRpbmdJbmRleCArPSBFbGxpcHNvaWQucGFja2VkTGVuZ3RoO1xuXG4gIHZhciB2ZXJ0ZXhGb3JtYXQgPSBWZXJ0ZXhGb3JtYXQudW5wYWNrKFxuICAgIGFycmF5LFxuICAgIHN0YXJ0aW5nSW5kZXgsXG4gICAgc2NyYXRjaFZlcnRleEZvcm1hdFxuICApO1xuICBzdGFydGluZ0luZGV4ICs9IFZlcnRleEZvcm1hdC5wYWNrZWRMZW5ndGg7XG5cbiAgdmFyIHNlbWlNYWpvckF4aXMgPSBhcnJheVtzdGFydGluZ0luZGV4KytdO1xuICB2YXIgc2VtaU1pbm9yQXhpcyA9IGFycmF5W3N0YXJ0aW5nSW5kZXgrK107XG4gIHZhciByb3RhdGlvbiA9IGFycmF5W3N0YXJ0aW5nSW5kZXgrK107XG4gIHZhciBzdFJvdGF0aW9uID0gYXJyYXlbc3RhcnRpbmdJbmRleCsrXTtcbiAgdmFyIGhlaWdodCA9IGFycmF5W3N0YXJ0aW5nSW5kZXgrK107XG4gIHZhciBncmFudWxhcml0eSA9IGFycmF5W3N0YXJ0aW5nSW5kZXgrK107XG4gIHZhciBleHRydWRlZEhlaWdodCA9IGFycmF5W3N0YXJ0aW5nSW5kZXgrK107XG4gIHZhciBzaGFkb3dWb2x1bWUgPSBhcnJheVtzdGFydGluZ0luZGV4KytdID09PSAxLjA7XG4gIHZhciBvZmZzZXRBdHRyaWJ1dGUgPSBhcnJheVtzdGFydGluZ0luZGV4XTtcblxuICBpZiAoIWRlZmluZWQocmVzdWx0KSkge1xuICAgIHNjcmF0Y2hPcHRpb25zLmhlaWdodCA9IGhlaWdodDtcbiAgICBzY3JhdGNoT3B0aW9ucy5leHRydWRlZEhlaWdodCA9IGV4dHJ1ZGVkSGVpZ2h0O1xuICAgIHNjcmF0Y2hPcHRpb25zLmdyYW51bGFyaXR5ID0gZ3JhbnVsYXJpdHk7XG4gICAgc2NyYXRjaE9wdGlvbnMuc3RSb3RhdGlvbiA9IHN0Um90YXRpb247XG4gICAgc2NyYXRjaE9wdGlvbnMucm90YXRpb24gPSByb3RhdGlvbjtcbiAgICBzY3JhdGNoT3B0aW9ucy5zZW1pTWFqb3JBeGlzID0gc2VtaU1ham9yQXhpcztcbiAgICBzY3JhdGNoT3B0aW9ucy5zZW1pTWlub3JBeGlzID0gc2VtaU1pbm9yQXhpcztcbiAgICBzY3JhdGNoT3B0aW9ucy5zaGFkb3dWb2x1bWUgPSBzaGFkb3dWb2x1bWU7XG4gICAgc2NyYXRjaE9wdGlvbnMub2Zmc2V0QXR0cmlidXRlID1cbiAgICAgIG9mZnNldEF0dHJpYnV0ZSA9PT0gLTEgPyB1bmRlZmluZWQgOiBvZmZzZXRBdHRyaWJ1dGU7XG5cbiAgICByZXR1cm4gbmV3IEVsbGlwc2VHZW9tZXRyeShzY3JhdGNoT3B0aW9ucyk7XG4gIH1cblxuICByZXN1bHQuX2NlbnRlciA9IENhcnRlc2lhbjMuY2xvbmUoY2VudGVyLCByZXN1bHQuX2NlbnRlcik7XG4gIHJlc3VsdC5fZWxsaXBzb2lkID0gRWxsaXBzb2lkLmNsb25lKGVsbGlwc29pZCwgcmVzdWx0Ll9lbGxpcHNvaWQpO1xuICByZXN1bHQuX3ZlcnRleEZvcm1hdCA9IFZlcnRleEZvcm1hdC5jbG9uZSh2ZXJ0ZXhGb3JtYXQsIHJlc3VsdC5fdmVydGV4Rm9ybWF0KTtcbiAgcmVzdWx0Ll9zZW1pTWFqb3JBeGlzID0gc2VtaU1ham9yQXhpcztcbiAgcmVzdWx0Ll9zZW1pTWlub3JBeGlzID0gc2VtaU1pbm9yQXhpcztcbiAgcmVzdWx0Ll9yb3RhdGlvbiA9IHJvdGF0aW9uO1xuICByZXN1bHQuX3N0Um90YXRpb24gPSBzdFJvdGF0aW9uO1xuICByZXN1bHQuX2hlaWdodCA9IGhlaWdodDtcbiAgcmVzdWx0Ll9ncmFudWxhcml0eSA9IGdyYW51bGFyaXR5O1xuICByZXN1bHQuX2V4dHJ1ZGVkSGVpZ2h0ID0gZXh0cnVkZWRIZWlnaHQ7XG4gIHJlc3VsdC5fc2hhZG93Vm9sdW1lID0gc2hhZG93Vm9sdW1lO1xuICByZXN1bHQuX29mZnNldEF0dHJpYnV0ZSA9XG4gICAgb2Zmc2V0QXR0cmlidXRlID09PSAtMSA/IHVuZGVmaW5lZCA6IG9mZnNldEF0dHJpYnV0ZTtcblxuICByZXR1cm4gcmVzdWx0O1xufTtcblxuLyoqXG4gKiBDb21wdXRlcyB0aGUgYm91bmRpbmcgcmVjdGFuZ2xlIGJhc2VkIG9uIHRoZSBwcm92aWRlZCBvcHRpb25zXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgT2JqZWN0IHdpdGggdGhlIGZvbGxvd2luZyBwcm9wZXJ0aWVzOlxuICogQHBhcmFtIHtDYXJ0ZXNpYW4zfSBvcHRpb25zLmNlbnRlciBUaGUgZWxsaXBzZSdzIGNlbnRlciBwb2ludCBpbiB0aGUgZml4ZWQgZnJhbWUuXG4gKiBAcGFyYW0ge051bWJlcn0gb3B0aW9ucy5zZW1pTWFqb3JBeGlzIFRoZSBsZW5ndGggb2YgdGhlIGVsbGlwc2UncyBzZW1pLW1ham9yIGF4aXMgaW4gbWV0ZXJzLlxuICogQHBhcmFtIHtOdW1iZXJ9IG9wdGlvbnMuc2VtaU1pbm9yQXhpcyBUaGUgbGVuZ3RoIG9mIHRoZSBlbGxpcHNlJ3Mgc2VtaS1taW5vciBheGlzIGluIG1ldGVycy5cbiAqIEBwYXJhbSB7RWxsaXBzb2lkfSBbb3B0aW9ucy5lbGxpcHNvaWQ9RWxsaXBzb2lkLldHUzg0XSBUaGUgZWxsaXBzb2lkIHRoZSBlbGxpcHNlIHdpbGwgYmUgb24uXG4gKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMucm90YXRpb249MC4wXSBUaGUgYW5nbGUgb2Ygcm90YXRpb24gY291bnRlci1jbG9ja3dpc2UgZnJvbSBub3J0aC5cbiAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5ncmFudWxhcml0eT1DZXNpdW1NYXRoLlJBRElBTlNfUEVSX0RFR1JFRV0gVGhlIGFuZ3VsYXIgZGlzdGFuY2UgYmV0d2VlbiBwb2ludHMgb24gdGhlIGVsbGlwc2UgaW4gcmFkaWFucy5cbiAqIEBwYXJhbSB7UmVjdGFuZ2xlfSBbcmVzdWx0XSBBbiBvYmplY3QgaW4gd2hpY2ggdG8gc3RvcmUgdGhlIHJlc3VsdFxuICpcbiAqIEByZXR1cm5zIHtSZWN0YW5nbGV9IFRoZSByZXN1bHQgcmVjdGFuZ2xlXG4gKi9cbkVsbGlwc2VHZW9tZXRyeS5jb21wdXRlUmVjdGFuZ2xlID0gZnVuY3Rpb24gKG9wdGlvbnMsIHJlc3VsdCkge1xuICBvcHRpb25zID0gZGVmYXVsdFZhbHVlKG9wdGlvbnMsIGRlZmF1bHRWYWx1ZS5FTVBUWV9PQkpFQ1QpO1xuXG4gIHZhciBjZW50ZXIgPSBvcHRpb25zLmNlbnRlcjtcbiAgdmFyIGVsbGlwc29pZCA9IGRlZmF1bHRWYWx1ZShvcHRpb25zLmVsbGlwc29pZCwgRWxsaXBzb2lkLldHUzg0KTtcbiAgdmFyIHNlbWlNYWpvckF4aXMgPSBvcHRpb25zLnNlbWlNYWpvckF4aXM7XG4gIHZhciBzZW1pTWlub3JBeGlzID0gb3B0aW9ucy5zZW1pTWlub3JBeGlzO1xuICB2YXIgZ3JhbnVsYXJpdHkgPSBkZWZhdWx0VmFsdWUoXG4gICAgb3B0aW9ucy5ncmFudWxhcml0eSxcbiAgICBDZXNpdW1NYXRoLlJBRElBTlNfUEVSX0RFR1JFRVxuICApO1xuICB2YXIgcm90YXRpb24gPSBkZWZhdWx0VmFsdWUob3B0aW9ucy5yb3RhdGlvbiwgMC4wKTtcblxuICAvLz4+aW5jbHVkZVN0YXJ0KCdkZWJ1ZycsIHByYWdtYXMuZGVidWcpO1xuICBDaGVjay5kZWZpbmVkKFwib3B0aW9ucy5jZW50ZXJcIiwgY2VudGVyKTtcbiAgQ2hlY2sudHlwZU9mLm51bWJlcihcIm9wdGlvbnMuc2VtaU1ham9yQXhpc1wiLCBzZW1pTWFqb3JBeGlzKTtcbiAgQ2hlY2sudHlwZU9mLm51bWJlcihcIm9wdGlvbnMuc2VtaU1pbm9yQXhpc1wiLCBzZW1pTWlub3JBeGlzKTtcbiAgaWYgKHNlbWlNYWpvckF4aXMgPCBzZW1pTWlub3JBeGlzKSB7XG4gICAgdGhyb3cgbmV3IERldmVsb3BlckVycm9yKFxuICAgICAgXCJzZW1pTWFqb3JBeGlzIG11c3QgYmUgZ3JlYXRlciB0aGFuIG9yIGVxdWFsIHRvIHRoZSBzZW1pTWlub3JBeGlzLlwiXG4gICAgKTtcbiAgfVxuICBpZiAoZ3JhbnVsYXJpdHkgPD0gMC4wKSB7XG4gICAgdGhyb3cgbmV3IERldmVsb3BlckVycm9yKFwiZ3JhbnVsYXJpdHkgbXVzdCBiZSBncmVhdGVyIHRoYW4gemVyby5cIik7XG4gIH1cbiAgLy8+PmluY2x1ZGVFbmQoJ2RlYnVnJyk7XG5cbiAgcmV0dXJuIGNvbXB1dGVSZWN0YW5nbGUoXG4gICAgY2VudGVyLFxuICAgIHNlbWlNYWpvckF4aXMsXG4gICAgc2VtaU1pbm9yQXhpcyxcbiAgICByb3RhdGlvbixcbiAgICBncmFudWxhcml0eSxcbiAgICBlbGxpcHNvaWQsXG4gICAgcmVzdWx0XG4gICk7XG59O1xuXG4vKipcbiAqIENvbXB1dGVzIHRoZSBnZW9tZXRyaWMgcmVwcmVzZW50YXRpb24gb2YgYSBlbGxpcHNlIG9uIGFuIGVsbGlwc29pZCwgaW5jbHVkaW5nIGl0cyB2ZXJ0aWNlcywgaW5kaWNlcywgYW5kIGEgYm91bmRpbmcgc3BoZXJlLlxuICpcbiAqIEBwYXJhbSB7RWxsaXBzZUdlb21ldHJ5fSBlbGxpcHNlR2VvbWV0cnkgQSBkZXNjcmlwdGlvbiBvZiB0aGUgZWxsaXBzZS5cbiAqIEByZXR1cm5zIHtHZW9tZXRyeXx1bmRlZmluZWR9IFRoZSBjb21wdXRlZCB2ZXJ0aWNlcyBhbmQgaW5kaWNlcy5cbiAqL1xuRWxsaXBzZUdlb21ldHJ5LmNyZWF0ZUdlb21ldHJ5ID0gZnVuY3Rpb24gKGVsbGlwc2VHZW9tZXRyeSkge1xuICBpZiAoXG4gICAgZWxsaXBzZUdlb21ldHJ5Ll9zZW1pTWFqb3JBeGlzIDw9IDAuMCB8fFxuICAgIGVsbGlwc2VHZW9tZXRyeS5fc2VtaU1pbm9yQXhpcyA8PSAwLjBcbiAgKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIGhlaWdodCA9IGVsbGlwc2VHZW9tZXRyeS5faGVpZ2h0O1xuICB2YXIgZXh0cnVkZWRIZWlnaHQgPSBlbGxpcHNlR2VvbWV0cnkuX2V4dHJ1ZGVkSGVpZ2h0O1xuICB2YXIgZXh0cnVkZSA9ICFDZXNpdW1NYXRoLmVxdWFsc0Vwc2lsb24oXG4gICAgaGVpZ2h0LFxuICAgIGV4dHJ1ZGVkSGVpZ2h0LFxuICAgIDAsXG4gICAgQ2VzaXVtTWF0aC5FUFNJTE9OMlxuICApO1xuXG4gIGVsbGlwc2VHZW9tZXRyeS5fY2VudGVyID0gZWxsaXBzZUdlb21ldHJ5Ll9lbGxpcHNvaWQuc2NhbGVUb0dlb2RldGljU3VyZmFjZShcbiAgICBlbGxpcHNlR2VvbWV0cnkuX2NlbnRlcixcbiAgICBlbGxpcHNlR2VvbWV0cnkuX2NlbnRlclxuICApO1xuICB2YXIgb3B0aW9ucyA9IHtcbiAgICBjZW50ZXI6IGVsbGlwc2VHZW9tZXRyeS5fY2VudGVyLFxuICAgIHNlbWlNYWpvckF4aXM6IGVsbGlwc2VHZW9tZXRyeS5fc2VtaU1ham9yQXhpcyxcbiAgICBzZW1pTWlub3JBeGlzOiBlbGxpcHNlR2VvbWV0cnkuX3NlbWlNaW5vckF4aXMsXG4gICAgZWxsaXBzb2lkOiBlbGxpcHNlR2VvbWV0cnkuX2VsbGlwc29pZCxcbiAgICByb3RhdGlvbjogZWxsaXBzZUdlb21ldHJ5Ll9yb3RhdGlvbixcbiAgICBoZWlnaHQ6IGhlaWdodCxcbiAgICBncmFudWxhcml0eTogZWxsaXBzZUdlb21ldHJ5Ll9ncmFudWxhcml0eSxcbiAgICB2ZXJ0ZXhGb3JtYXQ6IGVsbGlwc2VHZW9tZXRyeS5fdmVydGV4Rm9ybWF0LFxuICAgIHN0Um90YXRpb246IGVsbGlwc2VHZW9tZXRyeS5fc3RSb3RhdGlvbixcbiAgfTtcbiAgdmFyIGdlb21ldHJ5O1xuICBpZiAoZXh0cnVkZSkge1xuICAgIG9wdGlvbnMuZXh0cnVkZWRIZWlnaHQgPSBleHRydWRlZEhlaWdodDtcbiAgICBvcHRpb25zLnNoYWRvd1ZvbHVtZSA9IGVsbGlwc2VHZW9tZXRyeS5fc2hhZG93Vm9sdW1lO1xuICAgIG9wdGlvbnMub2Zmc2V0QXR0cmlidXRlID0gZWxsaXBzZUdlb21ldHJ5Ll9vZmZzZXRBdHRyaWJ1dGU7XG4gICAgZ2VvbWV0cnkgPSBjb21wdXRlRXh0cnVkZWRFbGxpcHNlKG9wdGlvbnMpO1xuICB9IGVsc2Uge1xuICAgIGdlb21ldHJ5ID0gY29tcHV0ZUVsbGlwc2Uob3B0aW9ucyk7XG5cbiAgICBpZiAoZGVmaW5lZChlbGxpcHNlR2VvbWV0cnkuX29mZnNldEF0dHJpYnV0ZSkpIHtcbiAgICAgIHZhciBsZW5ndGggPSBnZW9tZXRyeS5hdHRyaWJ1dGVzLnBvc2l0aW9uLnZhbHVlcy5sZW5ndGg7XG4gICAgICB2YXIgYXBwbHlPZmZzZXQgPSBuZXcgVWludDhBcnJheShsZW5ndGggLyAzKTtcbiAgICAgIHZhciBvZmZzZXRWYWx1ZSA9XG4gICAgICAgIGVsbGlwc2VHZW9tZXRyeS5fb2Zmc2V0QXR0cmlidXRlID09PSBHZW9tZXRyeU9mZnNldEF0dHJpYnV0ZS5OT05FXG4gICAgICAgICAgPyAwXG4gICAgICAgICAgOiAxO1xuICAgICAgYXJyYXlGaWxsKGFwcGx5T2Zmc2V0LCBvZmZzZXRWYWx1ZSk7XG4gICAgICBnZW9tZXRyeS5hdHRyaWJ1dGVzLmFwcGx5T2Zmc2V0ID0gbmV3IEdlb21ldHJ5QXR0cmlidXRlKHtcbiAgICAgICAgY29tcG9uZW50RGF0YXR5cGU6IENvbXBvbmVudERhdGF0eXBlLlVOU0lHTkVEX0JZVEUsXG4gICAgICAgIGNvbXBvbmVudHNQZXJBdHRyaWJ1dGU6IDEsXG4gICAgICAgIHZhbHVlczogYXBwbHlPZmZzZXQsXG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gbmV3IEdlb21ldHJ5KHtcbiAgICBhdHRyaWJ1dGVzOiBnZW9tZXRyeS5hdHRyaWJ1dGVzLFxuICAgIGluZGljZXM6IGdlb21ldHJ5LmluZGljZXMsXG4gICAgcHJpbWl0aXZlVHlwZTogUHJpbWl0aXZlVHlwZS5UUklBTkdMRVMsXG4gICAgYm91bmRpbmdTcGhlcmU6IGdlb21ldHJ5LmJvdW5kaW5nU3BoZXJlLFxuICAgIG9mZnNldEF0dHJpYnV0ZTogZWxsaXBzZUdlb21ldHJ5Ll9vZmZzZXRBdHRyaWJ1dGUsXG4gIH0pO1xufTtcblxuLyoqXG4gKiBAcHJpdmF0ZVxuICovXG5FbGxpcHNlR2VvbWV0cnkuY3JlYXRlU2hhZG93Vm9sdW1lID0gZnVuY3Rpb24gKFxuICBlbGxpcHNlR2VvbWV0cnksXG4gIG1pbkhlaWdodEZ1bmMsXG4gIG1heEhlaWdodEZ1bmNcbikge1xuICB2YXIgZ3JhbnVsYXJpdHkgPSBlbGxpcHNlR2VvbWV0cnkuX2dyYW51bGFyaXR5O1xuICB2YXIgZWxsaXBzb2lkID0gZWxsaXBzZUdlb21ldHJ5Ll9lbGxpcHNvaWQ7XG5cbiAgdmFyIG1pbkhlaWdodCA9IG1pbkhlaWdodEZ1bmMoZ3JhbnVsYXJpdHksIGVsbGlwc29pZCk7XG4gIHZhciBtYXhIZWlnaHQgPSBtYXhIZWlnaHRGdW5jKGdyYW51bGFyaXR5LCBlbGxpcHNvaWQpO1xuXG4gIHJldHVybiBuZXcgRWxsaXBzZUdlb21ldHJ5KHtcbiAgICBjZW50ZXI6IGVsbGlwc2VHZW9tZXRyeS5fY2VudGVyLFxuICAgIHNlbWlNYWpvckF4aXM6IGVsbGlwc2VHZW9tZXRyeS5fc2VtaU1ham9yQXhpcyxcbiAgICBzZW1pTWlub3JBeGlzOiBlbGxpcHNlR2VvbWV0cnkuX3NlbWlNaW5vckF4aXMsXG4gICAgZWxsaXBzb2lkOiBlbGxpcHNvaWQsXG4gICAgcm90YXRpb246IGVsbGlwc2VHZW9tZXRyeS5fcm90YXRpb24sXG4gICAgc3RSb3RhdGlvbjogZWxsaXBzZUdlb21ldHJ5Ll9zdFJvdGF0aW9uLFxuICAgIGdyYW51bGFyaXR5OiBncmFudWxhcml0eSxcbiAgICBleHRydWRlZEhlaWdodDogbWluSGVpZ2h0LFxuICAgIGhlaWdodDogbWF4SGVpZ2h0LFxuICAgIHZlcnRleEZvcm1hdDogVmVydGV4Rm9ybWF0LlBPU0lUSU9OX09OTFksXG4gICAgc2hhZG93Vm9sdW1lOiB0cnVlLFxuICB9KTtcbn07XG5cbmZ1bmN0aW9uIHRleHR1cmVDb29yZGluYXRlUm90YXRpb25Qb2ludHMoZWxsaXBzZUdlb21ldHJ5KSB7XG4gIHZhciBzdFJvdGF0aW9uID0gLWVsbGlwc2VHZW9tZXRyeS5fc3RSb3RhdGlvbjtcbiAgaWYgKHN0Um90YXRpb24gPT09IDAuMCkge1xuICAgIHJldHVybiBbMCwgMCwgMCwgMSwgMSwgMF07XG4gIH1cblxuICB2YXIgY2VwID0gRWxsaXBzZUdlb21ldHJ5TGlicmFyeS5jb21wdXRlRWxsaXBzZVBvc2l0aW9ucyhcbiAgICB7XG4gICAgICBjZW50ZXI6IGVsbGlwc2VHZW9tZXRyeS5fY2VudGVyLFxuICAgICAgc2VtaU1ham9yQXhpczogZWxsaXBzZUdlb21ldHJ5Ll9zZW1pTWFqb3JBeGlzLFxuICAgICAgc2VtaU1pbm9yQXhpczogZWxsaXBzZUdlb21ldHJ5Ll9zZW1pTWlub3JBeGlzLFxuICAgICAgcm90YXRpb246IGVsbGlwc2VHZW9tZXRyeS5fcm90YXRpb24sXG4gICAgICBncmFudWxhcml0eTogZWxsaXBzZUdlb21ldHJ5Ll9ncmFudWxhcml0eSxcbiAgICB9LFxuICAgIGZhbHNlLFxuICAgIHRydWVcbiAgKTtcbiAgdmFyIHBvc2l0aW9uc0ZsYXQgPSBjZXAub3V0ZXJQb3NpdGlvbnM7XG4gIHZhciBwb3NpdGlvbnNDb3VudCA9IHBvc2l0aW9uc0ZsYXQubGVuZ3RoIC8gMztcbiAgdmFyIHBvc2l0aW9ucyA9IG5ldyBBcnJheShwb3NpdGlvbnNDb3VudCk7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcG9zaXRpb25zQ291bnQ7ICsraSkge1xuICAgIHBvc2l0aW9uc1tpXSA9IENhcnRlc2lhbjMuZnJvbUFycmF5KHBvc2l0aW9uc0ZsYXQsIGkgKiAzKTtcbiAgfVxuXG4gIHZhciBlbGxpcHNvaWQgPSBlbGxpcHNlR2VvbWV0cnkuX2VsbGlwc29pZDtcbiAgdmFyIGJvdW5kaW5nUmVjdGFuZ2xlID0gZWxsaXBzZUdlb21ldHJ5LnJlY3RhbmdsZTtcbiAgcmV0dXJuIEdlb21ldHJ5Ll90ZXh0dXJlQ29vcmRpbmF0ZVJvdGF0aW9uUG9pbnRzKFxuICAgIHBvc2l0aW9ucyxcbiAgICBzdFJvdGF0aW9uLFxuICAgIGVsbGlwc29pZCxcbiAgICBib3VuZGluZ1JlY3RhbmdsZVxuICApO1xufVxuXG5PYmplY3QuZGVmaW5lUHJvcGVydGllcyhFbGxpcHNlR2VvbWV0cnkucHJvdG90eXBlLCB7XG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgcmVjdGFuZ2xlOiB7XG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAoIWRlZmluZWQodGhpcy5fcmVjdGFuZ2xlKSkge1xuICAgICAgICB0aGlzLl9yZWN0YW5nbGUgPSBjb21wdXRlUmVjdGFuZ2xlKFxuICAgICAgICAgIHRoaXMuX2NlbnRlcixcbiAgICAgICAgICB0aGlzLl9zZW1pTWFqb3JBeGlzLFxuICAgICAgICAgIHRoaXMuX3NlbWlNaW5vckF4aXMsXG4gICAgICAgICAgdGhpcy5fcm90YXRpb24sXG4gICAgICAgICAgdGhpcy5fZ3JhbnVsYXJpdHksXG4gICAgICAgICAgdGhpcy5fZWxsaXBzb2lkXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy5fcmVjdGFuZ2xlO1xuICAgIH0sXG4gIH0sXG4gIC8qKlxuICAgKiBGb3IgcmVtYXBwaW5nIHRleHR1cmUgY29vcmRpbmF0ZXMgd2hlbiByZW5kZXJpbmcgRWxsaXBzZUdlb21ldHJpZXMgYXMgR3JvdW5kUHJpbWl0aXZlcy5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIHRleHR1cmVDb29yZGluYXRlUm90YXRpb25Qb2ludHM6IHtcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmICghZGVmaW5lZCh0aGlzLl90ZXh0dXJlQ29vcmRpbmF0ZVJvdGF0aW9uUG9pbnRzKSkge1xuICAgICAgICB0aGlzLl90ZXh0dXJlQ29vcmRpbmF0ZVJvdGF0aW9uUG9pbnRzID0gdGV4dHVyZUNvb3JkaW5hdGVSb3RhdGlvblBvaW50cyhcbiAgICAgICAgICB0aGlzXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy5fdGV4dHVyZUNvb3JkaW5hdGVSb3RhdGlvblBvaW50cztcbiAgICB9LFxuICB9LFxufSk7XG5leHBvcnQgZGVmYXVsdCBFbGxpcHNlR2VvbWV0cnk7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///59359\n')},47302:function(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__){eval('/* harmony import */ var _Cartesian3_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(60216);\n/* harmony import */ var _Math_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(99417);\n/* harmony import */ var _Matrix3_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(68201);\n/* harmony import */ var _Quaternion_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(87811);\n\n\n\n\n\nvar EllipseGeometryLibrary = {};\n\nvar rotAxis = new _Cartesian3_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .Z();\nvar tempVec = new _Cartesian3_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .Z();\nvar unitQuat = new _Quaternion_js__WEBPACK_IMPORTED_MODULE_3__/* ["default"] */ .Z();\nvar rotMtx = new _Matrix3_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"] */ .Z();\n\nfunction pointOnEllipsoid(\n  theta,\n  rotation,\n  northVec,\n  eastVec,\n  aSqr,\n  ab,\n  bSqr,\n  mag,\n  unitPos,\n  result\n) {\n  var azimuth = theta + rotation;\n\n  _Cartesian3_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].multiplyByScalar */ .Z.multiplyByScalar(eastVec, Math.cos(azimuth), rotAxis);\n  _Cartesian3_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].multiplyByScalar */ .Z.multiplyByScalar(northVec, Math.sin(azimuth), tempVec);\n  _Cartesian3_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].add */ .Z.add(rotAxis, tempVec, rotAxis);\n\n  var cosThetaSquared = Math.cos(theta);\n  cosThetaSquared = cosThetaSquared * cosThetaSquared;\n\n  var sinThetaSquared = Math.sin(theta);\n  sinThetaSquared = sinThetaSquared * sinThetaSquared;\n\n  var radius = ab / Math.sqrt(bSqr * cosThetaSquared + aSqr * sinThetaSquared);\n  var angle = radius / mag;\n\n  // Create the quaternion to rotate the position vector to the boundary of the ellipse.\n  _Quaternion_js__WEBPACK_IMPORTED_MODULE_3__/* ["default"].fromAxisAngle */ .Z.fromAxisAngle(rotAxis, angle, unitQuat);\n  _Matrix3_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"].fromQuaternion */ .Z.fromQuaternion(unitQuat, rotMtx);\n\n  _Matrix3_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"].multiplyByVector */ .Z.multiplyByVector(rotMtx, unitPos, result);\n  _Cartesian3_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].normalize */ .Z.normalize(result, result);\n  _Cartesian3_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].multiplyByScalar */ .Z.multiplyByScalar(result, mag, result);\n  return result;\n}\n\nvar scratchCartesian1 = new _Cartesian3_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .Z();\nvar scratchCartesian2 = new _Cartesian3_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .Z();\nvar scratchCartesian3 = new _Cartesian3_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .Z();\nvar scratchNormal = new _Cartesian3_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .Z();\n/**\n * Returns the positions raised to the given heights\n * @private\n */\nEllipseGeometryLibrary.raisePositionsToHeight = function (\n  positions,\n  options,\n  extrude\n) {\n  var ellipsoid = options.ellipsoid;\n  var height = options.height;\n  var extrudedHeight = options.extrudedHeight;\n  var size = extrude ? (positions.length / 3) * 2 : positions.length / 3;\n\n  var finalPositions = new Float64Array(size * 3);\n\n  var length = positions.length;\n  var bottomOffset = extrude ? length : 0;\n  for (var i = 0; i < length; i += 3) {\n    var i1 = i + 1;\n    var i2 = i + 2;\n\n    var position = _Cartesian3_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].fromArray */ .Z.fromArray(positions, i, scratchCartesian1);\n    ellipsoid.scaleToGeodeticSurface(position, position);\n\n    var extrudedPosition = _Cartesian3_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].clone */ .Z.clone(position, scratchCartesian2);\n    var normal = ellipsoid.geodeticSurfaceNormal(position, scratchNormal);\n    var scaledNormal = _Cartesian3_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].multiplyByScalar */ .Z.multiplyByScalar(\n      normal,\n      height,\n      scratchCartesian3\n    );\n    _Cartesian3_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].add */ .Z.add(position, scaledNormal, position);\n\n    if (extrude) {\n      _Cartesian3_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].multiplyByScalar */ .Z.multiplyByScalar(normal, extrudedHeight, scaledNormal);\n      _Cartesian3_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].add */ .Z.add(extrudedPosition, scaledNormal, extrudedPosition);\n\n      finalPositions[i + bottomOffset] = extrudedPosition.x;\n      finalPositions[i1 + bottomOffset] = extrudedPosition.y;\n      finalPositions[i2 + bottomOffset] = extrudedPosition.z;\n    }\n\n    finalPositions[i] = position.x;\n    finalPositions[i1] = position.y;\n    finalPositions[i2] = position.z;\n  }\n\n  return finalPositions;\n};\n\nvar unitPosScratch = new _Cartesian3_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .Z();\nvar eastVecScratch = new _Cartesian3_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .Z();\nvar northVecScratch = new _Cartesian3_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .Z();\n/**\n * Returns an array of positions that make up the ellipse.\n * @private\n */\nEllipseGeometryLibrary.computeEllipsePositions = function (\n  options,\n  addFillPositions,\n  addEdgePositions\n) {\n  var semiMinorAxis = options.semiMinorAxis;\n  var semiMajorAxis = options.semiMajorAxis;\n  var rotation = options.rotation;\n  var center = options.center;\n\n  // Computing the arc-length of the ellipse is too expensive to be practical. Estimating it using the\n  // arc length of the sphere is too inaccurate and creates sharp edges when either the semi-major or\n  // semi-minor axis is much bigger than the other. Instead, scale the angle delta to make\n  // the distance along the ellipse boundary more closely match the granularity.\n  var granularity = options.granularity * 8.0;\n\n  var aSqr = semiMinorAxis * semiMinorAxis;\n  var bSqr = semiMajorAxis * semiMajorAxis;\n  var ab = semiMajorAxis * semiMinorAxis;\n\n  var mag = _Cartesian3_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].magnitude */ .Z.magnitude(center);\n\n  var unitPos = _Cartesian3_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].normalize */ .Z.normalize(center, unitPosScratch);\n  var eastVec = _Cartesian3_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].cross */ .Z.cross(_Cartesian3_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].UNIT_Z */ .Z.UNIT_Z, center, eastVecScratch);\n  eastVec = _Cartesian3_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].normalize */ .Z.normalize(eastVec, eastVec);\n  var northVec = _Cartesian3_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].cross */ .Z.cross(unitPos, eastVec, northVecScratch);\n\n  // The number of points in the first quadrant\n  var numPts = 1 + Math.ceil(_Math_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"].PI_OVER_TWO */ .Z.PI_OVER_TWO / granularity);\n\n  var deltaTheta = _Math_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"].PI_OVER_TWO */ .Z.PI_OVER_TWO / (numPts - 1);\n  var theta = _Math_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"].PI_OVER_TWO */ .Z.PI_OVER_TWO - numPts * deltaTheta;\n  if (theta < 0.0) {\n    numPts -= Math.ceil(Math.abs(theta) / deltaTheta);\n  }\n\n  // If the number of points were three, the ellipse\n  // would be tessellated like below:\n  //\n  //         *---*\n  //       / | \\ | \\\n  //     *---*---*---*\n  //   / | \\ | \\ | \\ | \\\n  //  / .*---*---*---*. \\\n  // * ` | \\ | \\ | \\ | `*\n  //  \\`.*---*---*---*.`/\n  //   \\ | \\ | \\ | \\ | /\n  //     *---*---*---*\n  //       \\ | \\ | /\n  //         *---*\n  // The first and last column have one position and fan to connect to the adjacent column.\n  // Each other vertical column contains an even number of positions.\n  var size = 2 * (numPts * (numPts + 2));\n  var positions = addFillPositions ? new Array(size * 3) : undefined;\n  var positionIndex = 0;\n  var position = scratchCartesian1;\n  var reflectedPosition = scratchCartesian2;\n\n  var outerPositionsLength = numPts * 4 * 3;\n  var outerRightIndex = outerPositionsLength - 1;\n  var outerLeftIndex = 0;\n  var outerPositions = addEdgePositions\n    ? new Array(outerPositionsLength)\n    : undefined;\n\n  var i;\n  var j;\n  var numInterior;\n  var t;\n  var interiorPosition;\n\n  // Compute points in the \'eastern\' half of the ellipse\n  theta = _Math_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"].PI_OVER_TWO */ .Z.PI_OVER_TWO;\n  position = pointOnEllipsoid(\n    theta,\n    rotation,\n    northVec,\n    eastVec,\n    aSqr,\n    ab,\n    bSqr,\n    mag,\n    unitPos,\n    position\n  );\n  if (addFillPositions) {\n    positions[positionIndex++] = position.x;\n    positions[positionIndex++] = position.y;\n    positions[positionIndex++] = position.z;\n  }\n  if (addEdgePositions) {\n    outerPositions[outerRightIndex--] = position.z;\n    outerPositions[outerRightIndex--] = position.y;\n    outerPositions[outerRightIndex--] = position.x;\n  }\n  theta = _Math_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"].PI_OVER_TWO */ .Z.PI_OVER_TWO - deltaTheta;\n  for (i = 1; i < numPts + 1; ++i) {\n    position = pointOnEllipsoid(\n      theta,\n      rotation,\n      northVec,\n      eastVec,\n      aSqr,\n      ab,\n      bSqr,\n      mag,\n      unitPos,\n      position\n    );\n    reflectedPosition = pointOnEllipsoid(\n      Math.PI - theta,\n      rotation,\n      northVec,\n      eastVec,\n      aSqr,\n      ab,\n      bSqr,\n      mag,\n      unitPos,\n      reflectedPosition\n    );\n\n    if (addFillPositions) {\n      positions[positionIndex++] = position.x;\n      positions[positionIndex++] = position.y;\n      positions[positionIndex++] = position.z;\n\n      numInterior = 2 * i + 2;\n      for (j = 1; j < numInterior - 1; ++j) {\n        t = j / (numInterior - 1);\n        interiorPosition = _Cartesian3_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].lerp */ .Z.lerp(\n          position,\n          reflectedPosition,\n          t,\n          scratchCartesian3\n        );\n        positions[positionIndex++] = interiorPosition.x;\n        positions[positionIndex++] = interiorPosition.y;\n        positions[positionIndex++] = interiorPosition.z;\n      }\n\n      positions[positionIndex++] = reflectedPosition.x;\n      positions[positionIndex++] = reflectedPosition.y;\n      positions[positionIndex++] = reflectedPosition.z;\n    }\n\n    if (addEdgePositions) {\n      outerPositions[outerRightIndex--] = position.z;\n      outerPositions[outerRightIndex--] = position.y;\n      outerPositions[outerRightIndex--] = position.x;\n      outerPositions[outerLeftIndex++] = reflectedPosition.x;\n      outerPositions[outerLeftIndex++] = reflectedPosition.y;\n      outerPositions[outerLeftIndex++] = reflectedPosition.z;\n    }\n\n    theta = _Math_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"].PI_OVER_TWO */ .Z.PI_OVER_TWO - (i + 1) * deltaTheta;\n  }\n\n  // Compute points in the \'western\' half of the ellipse\n  for (i = numPts; i > 1; --i) {\n    theta = _Math_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"].PI_OVER_TWO */ .Z.PI_OVER_TWO - (i - 1) * deltaTheta;\n\n    position = pointOnEllipsoid(\n      -theta,\n      rotation,\n      northVec,\n      eastVec,\n      aSqr,\n      ab,\n      bSqr,\n      mag,\n      unitPos,\n      position\n    );\n    reflectedPosition = pointOnEllipsoid(\n      theta + Math.PI,\n      rotation,\n      northVec,\n      eastVec,\n      aSqr,\n      ab,\n      bSqr,\n      mag,\n      unitPos,\n      reflectedPosition\n    );\n\n    if (addFillPositions) {\n      positions[positionIndex++] = position.x;\n      positions[positionIndex++] = position.y;\n      positions[positionIndex++] = position.z;\n\n      numInterior = 2 * (i - 1) + 2;\n      for (j = 1; j < numInterior - 1; ++j) {\n        t = j / (numInterior - 1);\n        interiorPosition = _Cartesian3_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].lerp */ .Z.lerp(\n          position,\n          reflectedPosition,\n          t,\n          scratchCartesian3\n        );\n        positions[positionIndex++] = interiorPosition.x;\n        positions[positionIndex++] = interiorPosition.y;\n        positions[positionIndex++] = interiorPosition.z;\n      }\n\n      positions[positionIndex++] = reflectedPosition.x;\n      positions[positionIndex++] = reflectedPosition.y;\n      positions[positionIndex++] = reflectedPosition.z;\n    }\n\n    if (addEdgePositions) {\n      outerPositions[outerRightIndex--] = position.z;\n      outerPositions[outerRightIndex--] = position.y;\n      outerPositions[outerRightIndex--] = position.x;\n      outerPositions[outerLeftIndex++] = reflectedPosition.x;\n      outerPositions[outerLeftIndex++] = reflectedPosition.y;\n      outerPositions[outerLeftIndex++] = reflectedPosition.z;\n    }\n  }\n\n  theta = _Math_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"].PI_OVER_TWO */ .Z.PI_OVER_TWO;\n  position = pointOnEllipsoid(\n    -theta,\n    rotation,\n    northVec,\n    eastVec,\n    aSqr,\n    ab,\n    bSqr,\n    mag,\n    unitPos,\n    position\n  );\n\n  var r = {};\n  if (addFillPositions) {\n    positions[positionIndex++] = position.x;\n    positions[positionIndex++] = position.y;\n    positions[positionIndex++] = position.z;\n    r.positions = positions;\n    r.numPts = numPts;\n  }\n  if (addEdgePositions) {\n    outerPositions[outerRightIndex--] = position.z;\n    outerPositions[outerRightIndex--] = position.y;\n    outerPositions[outerRightIndex--] = position.x;\n    r.outerPositions = outerPositions;\n  }\n\n  return r;\n};\n/* harmony default export */ __webpack_exports__["Z"] = (EllipseGeometryLibrary);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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RkFBc0I7QUFDbEM7O0FBRUE7QUFDQSxtQkFBbUIsT0FBTztBQUMxQixZQUFZLGlGQUFzQjs7QUFFbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esa0JBQWtCLHFCQUFxQjtBQUN2QztBQUNBLDJCQUEyQix5RUFBZTtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFVBQVUsaUZBQXNCO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx5REFBZSxzQkFBc0IsRUFBQyIsInNvdXJjZXMiOlsid2VicGFjazovL3Z1ZTMtd2VicGFjazUvLi9ub2RlX21vZHVsZXMvY2VzaXVtL1NvdXJjZS9Db3JlL0VsbGlwc2VHZW9tZXRyeUxpYnJhcnkuanM/Yzc5ZSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgQ2FydGVzaWFuMyBmcm9tIFwiLi9DYXJ0ZXNpYW4zLmpzXCI7XG5pbXBvcnQgQ2VzaXVtTWF0aCBmcm9tIFwiLi9NYXRoLmpzXCI7XG5pbXBvcnQgTWF0cml4MyBmcm9tIFwiLi9NYXRyaXgzLmpzXCI7XG5pbXBvcnQgUXVhdGVybmlvbiBmcm9tIFwiLi9RdWF0ZXJuaW9uLmpzXCI7XG5cbnZhciBFbGxpcHNlR2VvbWV0cnlMaWJyYXJ5ID0ge307XG5cbnZhciByb3RBeGlzID0gbmV3IENhcnRlc2lhbjMoKTtcbnZhciB0ZW1wVmVjID0gbmV3IENhcnRlc2lhbjMoKTtcbnZhciB1bml0UXVhdCA9IG5ldyBRdWF0ZXJuaW9uKCk7XG52YXIgcm90TXR4ID0gbmV3IE1hdHJpeDMoKTtcblxuZnVuY3Rpb24gcG9pbnRPbkVsbGlwc29pZChcbiAgdGhldGEsXG4gIHJvdGF0aW9uLFxuICBub3J0aFZlYyxcbiAgZWFzdFZlYyxcbiAgYVNxcixcbiAgYWIsXG4gIGJTcXIsXG4gIG1hZyxcbiAgdW5pdFBvcyxcbiAgcmVzdWx0XG4pIHtcbiAgdmFyIGF6aW11dGggPSB0aGV0YSArIHJvdGF0aW9uO1xuXG4gIENhcnRlc2lhbjMubXVsdGlwbHlCeVNjYWxhcihlYXN0VmVjLCBNYXRoLmNvcyhhemltdXRoKSwgcm90QXhpcyk7XG4gIENhcnRlc2lhbjMubXVsdGlwbHlCeVNjYWxhcihub3J0aFZlYywgTWF0aC5zaW4oYXppbXV0aCksIHRlbXBWZWMpO1xuICBDYXJ0ZXNpYW4zLmFkZChyb3RBeGlzLCB0ZW1wVmVjLCByb3RBeGlzKTtcblxuICB2YXIgY29zVGhldGFTcXVhcmVkID0gTWF0aC5jb3ModGhldGEpO1xuICBjb3NUaGV0YVNxdWFyZWQgPSBjb3NUaGV0YVNxdWFyZWQgKiBjb3NUaGV0YVNxdWFyZWQ7XG5cbiAgdmFyIHNpblRoZXRhU3F1YXJlZCA9IE1hdGguc2luKHRoZXRhKTtcbiAgc2luVGhldGFTcXVhcmVkID0gc2luVGhldGFTcXVhcmVkICogc2luVGhldGFTcXVhcmVkO1xuXG4gIHZhciByYWRpdXMgPSBhYiAvIE1hdGguc3FydChiU3FyICogY29zVGhldGFTcXVhcmVkICsgYVNxciAqIHNpblRoZXRhU3F1YXJlZCk7XG4gIHZhciBhbmdsZSA9IHJhZGl1cyAvIG1hZztcblxuICAvLyBDcmVhdGUgdGhlIHF1YXRlcm5pb24gdG8gcm90YXRlIHRoZSBwb3NpdGlvbiB2ZWN0b3IgdG8gdGhlIGJvdW5kYXJ5IG9mIHRoZSBlbGxpcHNlLlxuICBRdWF0ZXJuaW9uLmZyb21BeGlzQW5nbGUocm90QXhpcywgYW5nbGUsIHVuaXRRdWF0KTtcbiAgTWF0cml4My5mcm9tUXVhdGVybmlvbih1bml0UXVhdCwgcm90TXR4KTtcblxuICBNYXRyaXgzLm11bHRpcGx5QnlWZWN0b3Iocm90TXR4LCB1bml0UG9zLCByZXN1bHQpO1xuICBDYXJ0ZXNpYW4zLm5vcm1hbGl6ZShyZXN1bHQsIHJlc3VsdCk7XG4gIENhcnRlc2lhbjMubXVsdGlwbHlCeVNjYWxhcihyZXN1bHQsIG1hZywgcmVzdWx0KTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxudmFyIHNjcmF0Y2hDYXJ0ZXNpYW4xID0gbmV3IENhcnRlc2lhbjMoKTtcbnZhciBzY3JhdGNoQ2FydGVzaWFuMiA9IG5ldyBDYXJ0ZXNpYW4zKCk7XG52YXIgc2NyYXRjaENhcnRlc2lhbjMgPSBuZXcgQ2FydGVzaWFuMygpO1xudmFyIHNjcmF0Y2hOb3JtYWwgPSBuZXcgQ2FydGVzaWFuMygpO1xuLyoqXG4gKiBSZXR1cm5zIHRoZSBwb3NpdGlvbnMgcmFpc2VkIHRvIHRoZSBnaXZlbiBoZWlnaHRzXG4gKiBAcHJpdmF0ZVxuICovXG5FbGxpcHNlR2VvbWV0cnlMaWJyYXJ5LnJhaXNlUG9zaXRpb25zVG9IZWlnaHQgPSBmdW5jdGlvbiAoXG4gIHBvc2l0aW9ucyxcbiAgb3B0aW9ucyxcbiAgZXh0cnVkZVxuKSB7XG4gIHZhciBlbGxpcHNvaWQgPSBvcHRpb25zLmVsbGlwc29pZDtcbiAgdmFyIGhlaWdodCA9IG9wdGlvbnMuaGVpZ2h0O1xuICB2YXIgZXh0cnVkZWRIZWlnaHQgPSBvcHRpb25zLmV4dHJ1ZGVkSGVpZ2h0O1xuICB2YXIgc2l6ZSA9IGV4dHJ1ZGUgPyAocG9zaXRpb25zLmxlbmd0aCAvIDMpICogMiA6IHBvc2l0aW9ucy5sZW5ndGggLyAzO1xuXG4gIHZhciBmaW5hbFBvc2l0aW9ucyA9IG5ldyBGbG9hdDY0QXJyYXkoc2l6ZSAqIDMpO1xuXG4gIHZhciBsZW5ndGggPSBwb3NpdGlvbnMubGVuZ3RoO1xuICB2YXIgYm90dG9tT2Zmc2V0ID0gZXh0cnVkZSA/IGxlbmd0aCA6IDA7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpICs9IDMpIHtcbiAgICB2YXIgaTEgPSBpICsgMTtcbiAgICB2YXIgaTIgPSBpICsgMjtcblxuICAgIHZhciBwb3NpdGlvbiA9IENhcnRlc2lhbjMuZnJvbUFycmF5KHBvc2l0aW9ucywgaSwgc2NyYXRjaENhcnRlc2lhbjEpO1xuICAgIGVsbGlwc29pZC5zY2FsZVRvR2VvZGV0aWNTdXJmYWNlKHBvc2l0aW9uLCBwb3NpdGlvbik7XG5cbiAgICB2YXIgZXh0cnVkZWRQb3NpdGlvbiA9IENhcnRlc2lhbjMuY2xvbmUocG9zaXRpb24sIHNjcmF0Y2hDYXJ0ZXNpYW4yKTtcbiAgICB2YXIgbm9ybWFsID0gZWxsaXBzb2lkLmdlb2RldGljU3VyZmFjZU5vcm1hbChwb3NpdGlvbiwgc2NyYXRjaE5vcm1hbCk7XG4gICAgdmFyIHNjYWxlZE5vcm1hbCA9IENhcnRlc2lhbjMubXVsdGlwbHlCeVNjYWxhcihcbiAgICAgIG5vcm1hbCxcbiAgICAgIGhlaWdodCxcbiAgICAgIHNjcmF0Y2hDYXJ0ZXNpYW4zXG4gICAgKTtcbiAgICBDYXJ0ZXNpYW4zLmFkZChwb3NpdGlvbiwgc2NhbGVkTm9ybWFsLCBwb3NpdGlvbik7XG5cbiAgICBpZiAoZXh0cnVkZSkge1xuICAgICAgQ2FydGVzaWFuMy5tdWx0aXBseUJ5U2NhbGFyKG5vcm1hbCwgZXh0cnVkZWRIZWlnaHQsIHNjYWxlZE5vcm1hbCk7XG4gICAgICBDYXJ0ZXNpYW4zLmFkZChleHRydWRlZFBvc2l0aW9uLCBzY2FsZWROb3JtYWwsIGV4dHJ1ZGVkUG9zaXRpb24pO1xuXG4gICAgICBmaW5hbFBvc2l0aW9uc1tpICsgYm90dG9tT2Zmc2V0XSA9IGV4dHJ1ZGVkUG9zaXRpb24ueDtcbiAgICAgIGZpbmFsUG9zaXRpb25zW2kxICsgYm90dG9tT2Zmc2V0XSA9IGV4dHJ1ZGVkUG9zaXRpb24ueTtcbiAgICAgIGZpbmFsUG9zaXRpb25zW2kyICsgYm90dG9tT2Zmc2V0XSA9IGV4dHJ1ZGVkUG9zaXRpb24uejtcbiAgICB9XG5cbiAgICBmaW5hbFBvc2l0aW9uc1tpXSA9IHBvc2l0aW9uLng7XG4gICAgZmluYWxQb3NpdGlvbnNbaTFdID0gcG9zaXRpb24ueTtcbiAgICBmaW5hbFBvc2l0aW9uc1tpMl0gPSBwb3NpdGlvbi56O1xuICB9XG5cbiAgcmV0dXJuIGZpbmFsUG9zaXRpb25zO1xufTtcblxudmFyIHVuaXRQb3NTY3JhdGNoID0gbmV3IENhcnRlc2lhbjMoKTtcbnZhciBlYXN0VmVjU2NyYXRjaCA9IG5ldyBDYXJ0ZXNpYW4zKCk7XG52YXIgbm9ydGhWZWNTY3JhdGNoID0gbmV3IENhcnRlc2lhbjMoKTtcbi8qKlxuICogUmV0dXJucyBhbiBhcnJheSBvZiBwb3NpdGlvbnMgdGhhdCBtYWtlIHVwIHRoZSBlbGxpcHNlLlxuICogQHByaXZhdGVcbiAqL1xuRWxsaXBzZUdlb21ldHJ5TGlicmFyeS5jb21wdXRlRWxsaXBzZVBvc2l0aW9ucyA9IGZ1bmN0aW9uIChcbiAgb3B0aW9ucyxcbiAgYWRkRmlsbFBvc2l0aW9ucyxcbiAgYWRkRWRnZVBvc2l0aW9uc1xuKSB7XG4gIHZhciBzZW1pTWlub3JBeGlzID0gb3B0aW9ucy5zZW1pTWlub3JBeGlzO1xuICB2YXIgc2VtaU1ham9yQXhpcyA9IG9wdGlvbnMuc2VtaU1ham9yQXhpcztcbiAgdmFyIHJvdGF0aW9uID0gb3B0aW9ucy5yb3RhdGlvbjtcbiAgdmFyIGNlbnRlciA9IG9wdGlvbnMuY2VudGVyO1xuXG4gIC8vIENvbXB1dGluZyB0aGUgYXJjLWxlbmd0aCBvZiB0aGUgZWxsaXBzZSBpcyB0b28gZXhwZW5zaXZlIHRvIGJlIHByYWN0aWNhbC4gRXN0aW1hdGluZyBpdCB1c2luZyB0aGVcbiAgLy8gYXJjIGxlbmd0aCBvZiB0aGUgc3BoZXJlIGlzIHRvbyBpbmFjY3VyYXRlIGFuZCBjcmVhdGVzIHNoYXJwIGVkZ2VzIHdoZW4gZWl0aGVyIHRoZSBzZW1pLW1ham9yIG9yXG4gIC8vIHNlbWktbWlub3IgYXhpcyBpcyBtdWNoIGJpZ2dlciB0aGFuIHRoZSBvdGhlci4gSW5zdGVhZCwgc2NhbGUgdGhlIGFuZ2xlIGRlbHRhIHRvIG1ha2VcbiAgLy8gdGhlIGRpc3RhbmNlIGFsb25nIHRoZSBlbGxpcHNlIGJvdW5kYXJ5IG1vcmUgY2xvc2VseSBtYXRjaCB0aGUgZ3JhbnVsYXJpdHkuXG4gIHZhciBncmFudWxhcml0eSA9IG9wdGlvbnMuZ3JhbnVsYXJpdHkgKiA4LjA7XG5cbiAgdmFyIGFTcXIgPSBzZW1pTWlub3JBeGlzICogc2VtaU1pbm9yQXhpcztcbiAgdmFyIGJTcXIgPSBzZW1pTWFqb3JBeGlzICogc2VtaU1ham9yQXhpcztcbiAgdmFyIGFiID0gc2VtaU1ham9yQXhpcyAqIHNlbWlNaW5vckF4aXM7XG5cbiAgdmFyIG1hZyA9IENhcnRlc2lhbjMubWFnbml0dWRlKGNlbnRlcik7XG5cbiAgdmFyIHVuaXRQb3MgPSBDYXJ0ZXNpYW4zLm5vcm1hbGl6ZShjZW50ZXIsIHVuaXRQb3NTY3JhdGNoKTtcbiAgdmFyIGVhc3RWZWMgPSBDYXJ0ZXNpYW4zLmNyb3NzKENhcnRlc2lhbjMuVU5JVF9aLCBjZW50ZXIsIGVhc3RWZWNTY3JhdGNoKTtcbiAgZWFzdFZlYyA9IENhcnRlc2lhbjMubm9ybWFsaXplKGVhc3RWZWMsIGVhc3RWZWMpO1xuICB2YXIgbm9ydGhWZWMgPSBDYXJ0ZXNpYW4zLmNyb3NzKHVuaXRQb3MsIGVhc3RWZWMsIG5vcnRoVmVjU2NyYXRjaCk7XG5cbiAgLy8gVGhlIG51bWJlciBvZiBwb2ludHMgaW4gdGhlIGZpcnN0IHF1YWRyYW50XG4gIHZhciBudW1QdHMgPSAxICsgTWF0aC5jZWlsKENlc2l1bU1hdGguUElfT1ZFUl9UV08gLyBncmFudWxhcml0eSk7XG5cbiAgdmFyIGRlbHRhVGhldGEgPSBDZXNpdW1NYXRoLlBJX09WRVJfVFdPIC8gKG51bVB0cyAtIDEpO1xuICB2YXIgdGhldGEgPSBDZXNpdW1NYXRoLlBJX09WRVJfVFdPIC0gbnVtUHRzICogZGVsdGFUaGV0YTtcbiAgaWYgKHRoZXRhIDwgMC4wKSB7XG4gICAgbnVtUHRzIC09IE1hdGguY2VpbChNYXRoLmFicyh0aGV0YSkgLyBkZWx0YVRoZXRhKTtcbiAgfVxuXG4gIC8vIElmIHRoZSBudW1iZXIgb2YgcG9pbnRzIHdlcmUgdGhyZWUsIHRoZSBlbGxpcHNlXG4gIC8vIHdvdWxkIGJlIHRlc3NlbGxhdGVkIGxpa2UgYmVsb3c6XG4gIC8vXG4gIC8vICAgICAgICAgKi0tLSpcbiAgLy8gICAgICAgLyB8IFxcIHwgXFxcbiAgLy8gICAgICotLS0qLS0tKi0tLSpcbiAgLy8gICAvIHwgXFwgfCBcXCB8IFxcIHwgXFxcbiAgLy8gIC8gLiotLS0qLS0tKi0tLSouIFxcXG4gIC8vICogYCB8IFxcIHwgXFwgfCBcXCB8IGAqXG4gIC8vICBcXGAuKi0tLSotLS0qLS0tKi5gL1xuICAvLyAgIFxcIHwgXFwgfCBcXCB8IFxcIHwgL1xuICAvLyAgICAgKi0tLSotLS0qLS0tKlxuICAvLyAgICAgICBcXCB8IFxcIHwgL1xuICAvLyAgICAgICAgICotLS0qXG4gIC8vIFRoZSBmaXJzdCBhbmQgbGFzdCBjb2x1bW4gaGF2ZSBvbmUgcG9zaXRpb24gYW5kIGZhbiB0byBjb25uZWN0IHRvIHRoZSBhZGphY2VudCBjb2x1bW4uXG4gIC8vIEVhY2ggb3RoZXIgdmVydGljYWwgY29sdW1uIGNvbnRhaW5zIGFuIGV2ZW4gbnVtYmVyIG9mIHBvc2l0aW9ucy5cbiAgdmFyIHNpemUgPSAyICogKG51bVB0cyAqIChudW1QdHMgKyAyKSk7XG4gIHZhciBwb3NpdGlvbnMgPSBhZGRGaWxsUG9zaXRpb25zID8gbmV3IEFycmF5KHNpemUgKiAzKSA6IHVuZGVmaW5lZDtcbiAgdmFyIHBvc2l0aW9uSW5kZXggPSAwO1xuICB2YXIgcG9zaXRpb24gPSBzY3JhdGNoQ2FydGVzaWFuMTtcbiAgdmFyIHJlZmxlY3RlZFBvc2l0aW9uID0gc2NyYXRjaENhcnRlc2lhbjI7XG5cbiAgdmFyIG91dGVyUG9zaXRpb25zTGVuZ3RoID0gbnVtUHRzICogNCAqIDM7XG4gIHZhciBvdXRlclJpZ2h0SW5kZXggPSBvdXRlclBvc2l0aW9uc0xlbmd0aCAtIDE7XG4gIHZhciBvdXRlckxlZnRJbmRleCA9IDA7XG4gIHZhciBvdXRlclBvc2l0aW9ucyA9IGFkZEVkZ2VQb3NpdGlvbnNcbiAgICA/IG5ldyBBcnJheShvdXRlclBvc2l0aW9uc0xlbmd0aClcbiAgICA6IHVuZGVmaW5lZDtcblxuICB2YXIgaTtcbiAgdmFyIGo7XG4gIHZhciBudW1JbnRlcmlvcjtcbiAgdmFyIHQ7XG4gIHZhciBpbnRlcmlvclBvc2l0aW9uO1xuXG4gIC8vIENvbXB1dGUgcG9pbnRzIGluIHRoZSAnZWFzdGVybicgaGFsZiBvZiB0aGUgZWxsaXBzZVxuICB0aGV0YSA9IENlc2l1bU1hdGguUElfT1ZFUl9UV087XG4gIHBvc2l0aW9uID0gcG9pbnRPbkVsbGlwc29pZChcbiAgICB0aGV0YSxcbiAgICByb3RhdGlvbixcbiAgICBub3J0aFZlYyxcbiAgICBlYXN0VmVjLFxuICAgIGFTcXIsXG4gICAgYWIsXG4gICAgYlNxcixcbiAgICBtYWcsXG4gICAgdW5pdFBvcyxcbiAgICBwb3NpdGlvblxuICApO1xuICBpZiAoYWRkRmlsbFBvc2l0aW9ucykge1xuICAgIHBvc2l0aW9uc1twb3NpdGlvbkluZGV4KytdID0gcG9zaXRpb24ueDtcbiAgICBwb3NpdGlvbnNbcG9zaXRpb25JbmRleCsrXSA9IHBvc2l0aW9uLnk7XG4gICAgcG9zaXRpb25zW3Bvc2l0aW9uSW5kZXgrK10gPSBwb3NpdGlvbi56O1xuICB9XG4gIGlmIChhZGRFZGdlUG9zaXRpb25zKSB7XG4gICAgb3V0ZXJQb3NpdGlvbnNbb3V0ZXJSaWdodEluZGV4LS1dID0gcG9zaXRpb24uejtcbiAgICBvdXRlclBvc2l0aW9uc1tvdXRlclJpZ2h0SW5kZXgtLV0gPSBwb3NpdGlvbi55O1xuICAgIG91dGVyUG9zaXRpb25zW291dGVyUmlnaHRJbmRleC0tXSA9IHBvc2l0aW9uLng7XG4gIH1cbiAgdGhldGEgPSBDZXNpdW1NYXRoLlBJX09WRVJfVFdPIC0gZGVsdGFUaGV0YTtcbiAgZm9yIChpID0gMTsgaSA8IG51bVB0cyArIDE7ICsraSkge1xuICAgIHBvc2l0aW9uID0gcG9pbnRPbkVsbGlwc29pZChcbiAgICAgIHRoZXRhLFxuICAgICAgcm90YXRpb24sXG4gICAgICBub3J0aFZlYyxcbiAgICAgIGVhc3RWZWMsXG4gICAgICBhU3FyLFxuICAgICAgYWIsXG4gICAgICBiU3FyLFxuICAgICAgbWFnLFxuICAgICAgdW5pdFBvcyxcbiAgICAgIHBvc2l0aW9uXG4gICAgKTtcbiAgICByZWZsZWN0ZWRQb3NpdGlvbiA9IHBvaW50T25FbGxpcHNvaWQoXG4gICAgICBNYXRoLlBJIC0gdGhldGEsXG4gICAgICByb3RhdGlvbixcbiAgICAgIG5vcnRoVmVjLFxuICAgICAgZWFzdFZlYyxcbiAgICAgIGFTcXIsXG4gICAgICBhYixcbiAgICAgIGJTcXIsXG4gICAgICBtYWcsXG4gICAgICB1bml0UG9zLFxuICAgICAgcmVmbGVjdGVkUG9zaXRpb25cbiAgICApO1xuXG4gICAgaWYgKGFkZEZpbGxQb3NpdGlvbnMpIHtcbiAgICAgIHBvc2l0aW9uc1twb3NpdGlvbkluZGV4KytdID0gcG9zaXRpb24ueDtcbiAgICAgIHBvc2l0aW9uc1twb3NpdGlvbkluZGV4KytdID0gcG9zaXRpb24ueTtcbiAgICAgIHBvc2l0aW9uc1twb3NpdGlvbkluZGV4KytdID0gcG9zaXRpb24uejtcblxuICAgICAgbnVtSW50ZXJpb3IgPSAyICogaSArIDI7XG4gICAgICBmb3IgKGogPSAxOyBqIDwgbnVtSW50ZXJpb3IgLSAxOyArK2opIHtcbiAgICAgICAgdCA9IGogLyAobnVtSW50ZXJpb3IgLSAxKTtcbiAgICAgICAgaW50ZXJpb3JQb3NpdGlvbiA9IENhcnRlc2lhbjMubGVycChcbiAgICAgICAgICBwb3NpdGlvbixcbiAgICAgICAgICByZWZsZWN0ZWRQb3NpdGlvbixcbiAgICAgICAgICB0LFxuICAgICAgICAgIHNjcmF0Y2hDYXJ0ZXNpYW4zXG4gICAgICAgICk7XG4gICAgICAgIHBvc2l0aW9uc1twb3NpdGlvbkluZGV4KytdID0gaW50ZXJpb3JQb3NpdGlvbi54O1xuICAgICAgICBwb3NpdGlvbnNbcG9zaXRpb25JbmRleCsrXSA9IGludGVyaW9yUG9zaXRpb24ueTtcbiAgICAgICAgcG9zaXRpb25zW3Bvc2l0aW9uSW5kZXgrK10gPSBpbnRlcmlvclBvc2l0aW9uLno7XG4gICAgICB9XG5cbiAgICAgIHBvc2l0aW9uc1twb3NpdGlvbkluZGV4KytdID0gcmVmbGVjdGVkUG9zaXRpb24ueDtcbiAgICAgIHBvc2l0aW9uc1twb3NpdGlvbkluZGV4KytdID0gcmVmbGVjdGVkUG9zaXRpb24ueTtcbiAgICAgIHBvc2l0aW9uc1twb3NpdGlvbkluZGV4KytdID0gcmVmbGVjdGVkUG9zaXRpb24uejtcbiAgICB9XG5cbiAgICBpZiAoYWRkRWRnZVBvc2l0aW9ucykge1xuICAgICAgb3V0ZXJQb3NpdGlvbnNbb3V0ZXJSaWdodEluZGV4LS1dID0gcG9zaXRpb24uejtcbiAgICAgIG91dGVyUG9zaXRpb25zW291dGVyUmlnaHRJbmRleC0tXSA9IHBvc2l0aW9uLnk7XG4gICAgICBvdXRlclBvc2l0aW9uc1tvdXRlclJpZ2h0SW5kZXgtLV0gPSBwb3NpdGlvbi54O1xuICAgICAgb3V0ZXJQb3NpdGlvbnNbb3V0ZXJMZWZ0SW5kZXgrK10gPSByZWZsZWN0ZWRQb3NpdGlvbi54O1xuICAgICAgb3V0ZXJQb3NpdGlvbnNbb3V0ZXJMZWZ0SW5kZXgrK10gPSByZWZsZWN0ZWRQb3NpdGlvbi55O1xuICAgICAgb3V0ZXJQb3NpdGlvbnNbb3V0ZXJMZWZ0SW5kZXgrK10gPSByZWZsZWN0ZWRQb3NpdGlvbi56O1xuICAgIH1cblxuICAgIHRoZXRhID0gQ2VzaXVtTWF0aC5QSV9PVkVSX1RXTyAtIChpICsgMSkgKiBkZWx0YVRoZXRhO1xuICB9XG5cbiAgLy8gQ29tcHV0ZSBwb2ludHMgaW4gdGhlICd3ZXN0ZXJuJyBoYWxmIG9mIHRoZSBlbGxpcHNlXG4gIGZvciAoaSA9IG51bVB0czsgaSA+IDE7IC0taSkge1xuICAgIHRoZXRhID0gQ2VzaXVtTWF0aC5QSV9PVkVSX1RXTyAtIChpIC0gMSkgKiBkZWx0YVRoZXRhO1xuXG4gICAgcG9zaXRpb24gPSBwb2ludE9uRWxsaXBzb2lkKFxuICAgICAgLXRoZXRhLFxuICAgICAgcm90YXRpb24sXG4gICAgICBub3J0aFZlYyxcbiAgICAgIGVhc3RWZWMsXG4gICAgICBhU3FyLFxuICAgICAgYWIsXG4gICAgICBiU3FyLFxuICAgICAgbWFnLFxuICAgICAgdW5pdFBvcyxcbiAgICAgIHBvc2l0aW9uXG4gICAgKTtcbiAgICByZWZsZWN0ZWRQb3NpdGlvbiA9IHBvaW50T25FbGxpcHNvaWQoXG4gICAgICB0aGV0YSArIE1hdGguUEksXG4gICAgICByb3RhdGlvbixcbiAgICAgIG5vcnRoVmVjLFxuICAgICAgZWFzdFZlYyxcbiAgICAgIGFTcXIsXG4gICAgICBhYixcbiAgICAgIGJTcXIsXG4gICAgICBtYWcsXG4gICAgICB1bml0UG9zLFxuICAgICAgcmVmbGVjdGVkUG9zaXRpb25cbiAgICApO1xuXG4gICAgaWYgKGFkZEZpbGxQb3NpdGlvbnMpIHtcbiAgICAgIHBvc2l0aW9uc1twb3NpdGlvbkluZGV4KytdID0gcG9zaXRpb24ueDtcbiAgICAgIHBvc2l0aW9uc1twb3NpdGlvbkluZGV4KytdID0gcG9zaXRpb24ueTtcbiAgICAgIHBvc2l0aW9uc1twb3NpdGlvbkluZGV4KytdID0gcG9zaXRpb24uejtcblxuICAgICAgbnVtSW50ZXJpb3IgPSAyICogKGkgLSAxKSArIDI7XG4gICAgICBmb3IgKGogPSAxOyBqIDwgbnVtSW50ZXJpb3IgLSAxOyArK2opIHtcbiAgICAgICAgdCA9IGogLyAobnVtSW50ZXJpb3IgLSAxKTtcbiAgICAgICAgaW50ZXJpb3JQb3NpdGlvbiA9IENhcnRlc2lhbjMubGVycChcbiAgICAgICAgICBwb3NpdGlvbixcbiAgICAgICAgICByZWZsZWN0ZWRQb3NpdGlvbixcbiAgICAgICAgICB0LFxuICAgICAgICAgIHNjcmF0Y2hDYXJ0ZXNpYW4zXG4gICAgICAgICk7XG4gICAgICAgIHBvc2l0aW9uc1twb3NpdGlvbkluZGV4KytdID0gaW50ZXJpb3JQb3NpdGlvbi54O1xuICAgICAgICBwb3NpdGlvbnNbcG9zaXRpb25JbmRleCsrXSA9IGludGVyaW9yUG9zaXRpb24ueTtcbiAgICAgICAgcG9zaXRpb25zW3Bvc2l0aW9uSW5kZXgrK10gPSBpbnRlcmlvclBvc2l0aW9uLno7XG4gICAgICB9XG5cbiAgICAgIHBvc2l0aW9uc1twb3NpdGlvbkluZGV4KytdID0gcmVmbGVjdGVkUG9zaXRpb24ueDtcbiAgICAgIHBvc2l0aW9uc1twb3NpdGlvbkluZGV4KytdID0gcmVmbGVjdGVkUG9zaXRpb24ueTtcbiAgICAgIHBvc2l0aW9uc1twb3NpdGlvbkluZGV4KytdID0gcmVmbGVjdGVkUG9zaXRpb24uejtcbiAgICB9XG5cbiAgICBpZiAoYWRkRWRnZVBvc2l0aW9ucykge1xuICAgICAgb3V0ZXJQb3NpdGlvbnNbb3V0ZXJSaWdodEluZGV4LS1dID0gcG9zaXRpb24uejtcbiAgICAgIG91dGVyUG9zaXRpb25zW291dGVyUmlnaHRJbmRleC0tXSA9IHBvc2l0aW9uLnk7XG4gICAgICBvdXRlclBvc2l0aW9uc1tvdXRlclJpZ2h0SW5kZXgtLV0gPSBwb3NpdGlvbi54O1xuICAgICAgb3V0ZXJQb3NpdGlvbnNbb3V0ZXJMZWZ0SW5kZXgrK10gPSByZWZsZWN0ZWRQb3NpdGlvbi54O1xuICAgICAgb3V0ZXJQb3NpdGlvbnNbb3V0ZXJMZWZ0SW5kZXgrK10gPSByZWZsZWN0ZWRQb3NpdGlvbi55O1xuICAgICAgb3V0ZXJQb3NpdGlvbnNbb3V0ZXJMZWZ0SW5kZXgrK10gPSByZWZsZWN0ZWRQb3NpdGlvbi56O1xuICAgIH1cbiAgfVxuXG4gIHRoZXRhID0gQ2VzaXVtTWF0aC5QSV9PVkVSX1RXTztcbiAgcG9zaXRpb24gPSBwb2ludE9uRWxsaXBzb2lkKFxuICAgIC10aGV0YSxcbiAgICByb3RhdGlvbixcbiAgICBub3J0aFZlYyxcbiAgICBlYXN0VmVjLFxuICAgIGFTcXIsXG4gICAgYWIsXG4gICAgYlNxcixcbiAgICBtYWcsXG4gICAgdW5pdFBvcyxcbiAgICBwb3NpdGlvblxuICApO1xuXG4gIHZhciByID0ge307XG4gIGlmIChhZGRGaWxsUG9zaXRpb25zKSB7XG4gICAgcG9zaXRpb25zW3Bvc2l0aW9uSW5kZXgrK10gPSBwb3NpdGlvbi54O1xuICAgIHBvc2l0aW9uc1twb3NpdGlvbkluZGV4KytdID0gcG9zaXRpb24ueTtcbiAgICBwb3NpdGlvbnNbcG9zaXRpb25JbmRleCsrXSA9IHBvc2l0aW9uLno7XG4gICAgci5wb3NpdGlvbnMgPSBwb3NpdGlvbnM7XG4gICAgci5udW1QdHMgPSBudW1QdHM7XG4gIH1cbiAgaWYgKGFkZEVkZ2VQb3NpdGlvbnMpIHtcbiAgICBvdXRlclBvc2l0aW9uc1tvdXRlclJpZ2h0SW5kZXgtLV0gPSBwb3NpdGlvbi56O1xuICAgIG91dGVyUG9zaXRpb25zW291dGVyUmlnaHRJbmRleC0tXSA9IHBvc2l0aW9uLnk7XG4gICAgb3V0ZXJQb3NpdGlvbnNbb3V0ZXJSaWdodEluZGV4LS1dID0gcG9zaXRpb24ueDtcbiAgICByLm91dGVyUG9zaXRpb25zID0gb3V0ZXJQb3NpdGlvbnM7XG4gIH1cblxuICByZXR1cm4gcjtcbn07XG5leHBvcnQgZGVmYXVsdCBFbGxpcHNlR2VvbWV0cnlMaWJyYXJ5O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///47302\n')},27337:function(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__){eval('/* harmony import */ var _arrayFill_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(23401);\n/* harmony import */ var _BoundingSphere_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(48243);\n/* harmony import */ var _Cartesian3_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(60216);\n/* harmony import */ var _ComponentDatatype_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(84828);\n/* harmony import */ var _defaultValue_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(62200);\n/* harmony import */ var _defined_js__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(82982);\n/* harmony import */ var _DeveloperError_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(12572);\n/* harmony import */ var _EllipseGeometryLibrary_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(47302);\n/* harmony import */ var _Ellipsoid_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(50491);\n/* harmony import */ var _Geometry_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(82408);\n/* harmony import */ var _GeometryAttribute_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(13616);\n/* harmony import */ var _GeometryAttributes_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(56652);\n/* harmony import */ var _GeometryOffsetAttribute_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(87379);\n/* harmony import */ var _IndexDatatype_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(22832);\n/* harmony import */ var _Math_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(99417);\n/* harmony import */ var _PrimitiveType_js__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(97264);\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nvar scratchCartesian1 = new _Cartesian3_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"] */ .Z();\nvar boundingSphereCenter = new _Cartesian3_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"] */ .Z();\n\nfunction computeEllipse(options) {\n  var center = options.center;\n  boundingSphereCenter = _Cartesian3_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"].multiplyByScalar */ .Z.multiplyByScalar(\n    options.ellipsoid.geodeticSurfaceNormal(center, boundingSphereCenter),\n    options.height,\n    boundingSphereCenter\n  );\n  boundingSphereCenter = _Cartesian3_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"].add */ .Z.add(\n    center,\n    boundingSphereCenter,\n    boundingSphereCenter\n  );\n  var boundingSphere = new _BoundingSphere_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .Z(\n    boundingSphereCenter,\n    options.semiMajorAxis\n  );\n  var positions = _EllipseGeometryLibrary_js__WEBPACK_IMPORTED_MODULE_6__/* ["default"].computeEllipsePositions */ .Z.computeEllipsePositions(\n    options,\n    false,\n    true\n  ).outerPositions;\n\n  var attributes = new _GeometryAttributes_js__WEBPACK_IMPORTED_MODULE_10__/* ["default"] */ .Z({\n    position: new _GeometryAttribute_js__WEBPACK_IMPORTED_MODULE_9__/* ["default"] */ .Z({\n      componentDatatype: _ComponentDatatype_js__WEBPACK_IMPORTED_MODULE_3__/* ["default"].DOUBLE */ .Z.DOUBLE,\n      componentsPerAttribute: 3,\n      values: _EllipseGeometryLibrary_js__WEBPACK_IMPORTED_MODULE_6__/* ["default"].raisePositionsToHeight */ .Z.raisePositionsToHeight(\n        positions,\n        options,\n        false\n      ),\n    }),\n  });\n\n  var length = positions.length / 3;\n  var indices = _IndexDatatype_js__WEBPACK_IMPORTED_MODULE_12__/* ["default"].createTypedArray */ .Z.createTypedArray(length, length * 2);\n  var index = 0;\n  for (var i = 0; i < length; ++i) {\n    indices[index++] = i;\n    indices[index++] = (i + 1) % length;\n  }\n\n  return {\n    boundingSphere: boundingSphere,\n    attributes: attributes,\n    indices: indices,\n  };\n}\n\nvar topBoundingSphere = new _BoundingSphere_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .Z();\nvar bottomBoundingSphere = new _BoundingSphere_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .Z();\nfunction computeExtrudedEllipse(options) {\n  var center = options.center;\n  var ellipsoid = options.ellipsoid;\n  var semiMajorAxis = options.semiMajorAxis;\n  var scaledNormal = _Cartesian3_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"].multiplyByScalar */ .Z.multiplyByScalar(\n    ellipsoid.geodeticSurfaceNormal(center, scratchCartesian1),\n    options.height,\n    scratchCartesian1\n  );\n  topBoundingSphere.center = _Cartesian3_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"].add */ .Z.add(\n    center,\n    scaledNormal,\n    topBoundingSphere.center\n  );\n  topBoundingSphere.radius = semiMajorAxis;\n\n  scaledNormal = _Cartesian3_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"].multiplyByScalar */ .Z.multiplyByScalar(\n    ellipsoid.geodeticSurfaceNormal(center, scaledNormal),\n    options.extrudedHeight,\n    scaledNormal\n  );\n  bottomBoundingSphere.center = _Cartesian3_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"].add */ .Z.add(\n    center,\n    scaledNormal,\n    bottomBoundingSphere.center\n  );\n  bottomBoundingSphere.radius = semiMajorAxis;\n\n  var positions = _EllipseGeometryLibrary_js__WEBPACK_IMPORTED_MODULE_6__/* ["default"].computeEllipsePositions */ .Z.computeEllipsePositions(\n    options,\n    false,\n    true\n  ).outerPositions;\n  var attributes = new _GeometryAttributes_js__WEBPACK_IMPORTED_MODULE_10__/* ["default"] */ .Z({\n    position: new _GeometryAttribute_js__WEBPACK_IMPORTED_MODULE_9__/* ["default"] */ .Z({\n      componentDatatype: _ComponentDatatype_js__WEBPACK_IMPORTED_MODULE_3__/* ["default"].DOUBLE */ .Z.DOUBLE,\n      componentsPerAttribute: 3,\n      values: _EllipseGeometryLibrary_js__WEBPACK_IMPORTED_MODULE_6__/* ["default"].raisePositionsToHeight */ .Z.raisePositionsToHeight(\n        positions,\n        options,\n        true\n      ),\n    }),\n  });\n\n  positions = attributes.position.values;\n  var boundingSphere = _BoundingSphere_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"].union */ .Z.union(\n    topBoundingSphere,\n    bottomBoundingSphere\n  );\n  var length = positions.length / 3;\n\n  if ((0,_defined_js__WEBPACK_IMPORTED_MODULE_15__/* ["default"] */ .Z)(options.offsetAttribute)) {\n    var applyOffset = new Uint8Array(length);\n    if (options.offsetAttribute === _GeometryOffsetAttribute_js__WEBPACK_IMPORTED_MODULE_11__/* ["default"].TOP */ .Z.TOP) {\n      applyOffset = (0,_arrayFill_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .Z)(applyOffset, 1, 0, length / 2);\n    } else {\n      var offsetValue =\n        options.offsetAttribute === _GeometryOffsetAttribute_js__WEBPACK_IMPORTED_MODULE_11__/* ["default"].NONE */ .Z.NONE ? 0 : 1;\n      applyOffset = (0,_arrayFill_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .Z)(applyOffset, offsetValue);\n    }\n\n    attributes.applyOffset = new _GeometryAttribute_js__WEBPACK_IMPORTED_MODULE_9__/* ["default"] */ .Z({\n      componentDatatype: _ComponentDatatype_js__WEBPACK_IMPORTED_MODULE_3__/* ["default"].UNSIGNED_BYTE */ .Z.UNSIGNED_BYTE,\n      componentsPerAttribute: 1,\n      values: applyOffset,\n    });\n  }\n\n  var numberOfVerticalLines = (0,_defaultValue_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .Z)(options.numberOfVerticalLines, 16);\n  numberOfVerticalLines = _Math_js__WEBPACK_IMPORTED_MODULE_13__/* ["default"].clamp */ .Z.clamp(\n    numberOfVerticalLines,\n    0,\n    length / 2\n  );\n\n  var indices = _IndexDatatype_js__WEBPACK_IMPORTED_MODULE_12__/* ["default"].createTypedArray */ .Z.createTypedArray(\n    length,\n    length * 2 + numberOfVerticalLines * 2\n  );\n\n  length /= 2;\n  var index = 0;\n  var i;\n  for (i = 0; i < length; ++i) {\n    indices[index++] = i;\n    indices[index++] = (i + 1) % length;\n    indices[index++] = i + length;\n    indices[index++] = ((i + 1) % length) + length;\n  }\n\n  var numSide;\n  if (numberOfVerticalLines > 0) {\n    var numSideLines = Math.min(numberOfVerticalLines, length);\n    numSide = Math.round(length / numSideLines);\n\n    var maxI = Math.min(numSide * numberOfVerticalLines, length);\n    for (i = 0; i < maxI; i += numSide) {\n      indices[index++] = i;\n      indices[index++] = i + length;\n    }\n  }\n\n  return {\n    boundingSphere: boundingSphere,\n    attributes: attributes,\n    indices: indices,\n  };\n}\n\n/**\n * A description of the outline of an ellipse on an ellipsoid.\n *\n * @alias EllipseOutlineGeometry\n * @constructor\n *\n * @param {Object} options Object with the following properties:\n * @param {Cartesian3} options.center The ellipse\'s center point in the fixed frame.\n * @param {Number} options.semiMajorAxis The length of the ellipse\'s semi-major axis in meters.\n * @param {Number} options.semiMinorAxis The length of the ellipse\'s semi-minor axis in meters.\n * @param {Ellipsoid} [options.ellipsoid=Ellipsoid.WGS84] The ellipsoid the ellipse will be on.\n * @param {Number} [options.height=0.0] The distance in meters between the ellipse and the ellipsoid surface.\n * @param {Number} [options.extrudedHeight] The distance in meters between the ellipse\'s extruded face and the ellipsoid surface.\n * @param {Number} [options.rotation=0.0] The angle from north (counter-clockwise) in radians.\n * @param {Number} [options.granularity=0.02] The angular distance between points on the ellipse in radians.\n * @param {Number} [options.numberOfVerticalLines=16] Number of lines to draw between the top and bottom surface of an extruded ellipse.\n *\n * @exception {DeveloperError} semiMajorAxis and semiMinorAxis must be greater than zero.\n * @exception {DeveloperError} semiMajorAxis must be greater than or equal to the semiMinorAxis.\n * @exception {DeveloperError} granularity must be greater than zero.\n *\n * @see EllipseOutlineGeometry.createGeometry\n *\n * @example\n * var ellipse = new Cesium.EllipseOutlineGeometry({\n *   center : Cesium.Cartesian3.fromDegrees(-75.59777, 40.03883),\n *   semiMajorAxis : 500000.0,\n *   semiMinorAxis : 300000.0,\n *   rotation : Cesium.Math.toRadians(60.0)\n * });\n * var geometry = Cesium.EllipseOutlineGeometry.createGeometry(ellipse);\n */\nfunction EllipseOutlineGeometry(options) {\n  options = (0,_defaultValue_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .Z)(options, _defaultValue_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"].EMPTY_OBJECT */ .Z.EMPTY_OBJECT);\n\n  var center = options.center;\n  var ellipsoid = (0,_defaultValue_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .Z)(options.ellipsoid, _Ellipsoid_js__WEBPACK_IMPORTED_MODULE_7__/* ["default"].WGS84 */ .Z.WGS84);\n  var semiMajorAxis = options.semiMajorAxis;\n  var semiMinorAxis = options.semiMinorAxis;\n  var granularity = (0,_defaultValue_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .Z)(\n    options.granularity,\n    _Math_js__WEBPACK_IMPORTED_MODULE_13__/* ["default"].RADIANS_PER_DEGREE */ .Z.RADIANS_PER_DEGREE\n  );\n\n  //>>includeStart(\'debug\', pragmas.debug);\n  if (!(0,_defined_js__WEBPACK_IMPORTED_MODULE_15__/* ["default"] */ .Z)(center)) {\n    throw new _DeveloperError_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"] */ .Z("center is required.");\n  }\n  if (!(0,_defined_js__WEBPACK_IMPORTED_MODULE_15__/* ["default"] */ .Z)(semiMajorAxis)) {\n    throw new _DeveloperError_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"] */ .Z("semiMajorAxis is required.");\n  }\n  if (!(0,_defined_js__WEBPACK_IMPORTED_MODULE_15__/* ["default"] */ .Z)(semiMinorAxis)) {\n    throw new _DeveloperError_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"] */ .Z("semiMinorAxis is required.");\n  }\n  if (semiMajorAxis < semiMinorAxis) {\n    throw new _DeveloperError_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"] */ .Z(\n      "semiMajorAxis must be greater than or equal to the semiMinorAxis."\n    );\n  }\n  if (granularity <= 0.0) {\n    throw new _DeveloperError_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"] */ .Z("granularity must be greater than zero.");\n  }\n  //>>includeEnd(\'debug\');\n\n  var height = (0,_defaultValue_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .Z)(options.height, 0.0);\n  var extrudedHeight = (0,_defaultValue_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .Z)(options.extrudedHeight, height);\n\n  this._center = _Cartesian3_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"].clone */ .Z.clone(center);\n  this._semiMajorAxis = semiMajorAxis;\n  this._semiMinorAxis = semiMinorAxis;\n  this._ellipsoid = _Ellipsoid_js__WEBPACK_IMPORTED_MODULE_7__/* ["default"].clone */ .Z.clone(ellipsoid);\n  this._rotation = (0,_defaultValue_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .Z)(options.rotation, 0.0);\n  this._height = Math.max(extrudedHeight, height);\n  this._granularity = granularity;\n  this._extrudedHeight = Math.min(extrudedHeight, height);\n  this._numberOfVerticalLines = Math.max(\n    (0,_defaultValue_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .Z)(options.numberOfVerticalLines, 16),\n    0\n  );\n  this._offsetAttribute = options.offsetAttribute;\n  this._workerName = "createEllipseOutlineGeometry";\n}\n\n/**\n * The number of elements used to pack the object into an array.\n * @type {Number}\n */\nEllipseOutlineGeometry.packedLength =\n  _Cartesian3_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"].packedLength */ .Z.packedLength + _Ellipsoid_js__WEBPACK_IMPORTED_MODULE_7__/* ["default"].packedLength */ .Z.packedLength + 8;\n\n/**\n * Stores the provided instance into the provided array.\n *\n * @param {EllipseOutlineGeometry} value The value to pack.\n * @param {Number[]} array The array to pack into.\n * @param {Number} [startingIndex=0] The index into the array at which to start packing the elements.\n *\n * @returns {Number[]} The array that was packed into\n */\nEllipseOutlineGeometry.pack = function (value, array, startingIndex) {\n  //>>includeStart(\'debug\', pragmas.debug);\n  if (!(0,_defined_js__WEBPACK_IMPORTED_MODULE_15__/* ["default"] */ .Z)(value)) {\n    throw new _DeveloperError_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"] */ .Z("value is required");\n  }\n  if (!(0,_defined_js__WEBPACK_IMPORTED_MODULE_15__/* ["default"] */ .Z)(array)) {\n    throw new _DeveloperError_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"] */ .Z("array is required");\n  }\n  //>>includeEnd(\'debug\');\n\n  startingIndex = (0,_defaultValue_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .Z)(startingIndex, 0);\n\n  _Cartesian3_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"].pack */ .Z.pack(value._center, array, startingIndex);\n  startingIndex += _Cartesian3_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"].packedLength */ .Z.packedLength;\n\n  _Ellipsoid_js__WEBPACK_IMPORTED_MODULE_7__/* ["default"].pack */ .Z.pack(value._ellipsoid, array, startingIndex);\n  startingIndex += _Ellipsoid_js__WEBPACK_IMPORTED_MODULE_7__/* ["default"].packedLength */ .Z.packedLength;\n\n  array[startingIndex++] = value._semiMajorAxis;\n  array[startingIndex++] = value._semiMinorAxis;\n  array[startingIndex++] = value._rotation;\n  array[startingIndex++] = value._height;\n  array[startingIndex++] = value._granularity;\n  array[startingIndex++] = value._extrudedHeight;\n  array[startingIndex++] = value._numberOfVerticalLines;\n  array[startingIndex] = (0,_defaultValue_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .Z)(value._offsetAttribute, -1);\n\n  return array;\n};\n\nvar scratchCenter = new _Cartesian3_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"] */ .Z();\nvar scratchEllipsoid = new _Ellipsoid_js__WEBPACK_IMPORTED_MODULE_7__/* ["default"] */ .Z();\nvar scratchOptions = {\n  center: scratchCenter,\n  ellipsoid: scratchEllipsoid,\n  semiMajorAxis: undefined,\n  semiMinorAxis: undefined,\n  rotation: undefined,\n  height: undefined,\n  granularity: undefined,\n  extrudedHeight: undefined,\n  numberOfVerticalLines: undefined,\n  offsetAttribute: undefined,\n};\n\n/**\n * Retrieves an instance from a packed array.\n *\n * @param {Number[]} array The packed array.\n * @param {Number} [startingIndex=0] The starting index of the element to be unpacked.\n * @param {EllipseOutlineGeometry} [result] The object into which to store the result.\n * @returns {EllipseOutlineGeometry} The modified result parameter or a new EllipseOutlineGeometry instance if one was not provided.\n */\nEllipseOutlineGeometry.unpack = function (array, startingIndex, result) {\n  //>>includeStart(\'debug\', pragmas.debug);\n  if (!(0,_defined_js__WEBPACK_IMPORTED_MODULE_15__/* ["default"] */ .Z)(array)) {\n    throw new _DeveloperError_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"] */ .Z("array is required");\n  }\n  //>>includeEnd(\'debug\');\n\n  startingIndex = (0,_defaultValue_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .Z)(startingIndex, 0);\n\n  var center = _Cartesian3_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"].unpack */ .Z.unpack(array, startingIndex, scratchCenter);\n  startingIndex += _Cartesian3_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"].packedLength */ .Z.packedLength;\n\n  var ellipsoid = _Ellipsoid_js__WEBPACK_IMPORTED_MODULE_7__/* ["default"].unpack */ .Z.unpack(array, startingIndex, scratchEllipsoid);\n  startingIndex += _Ellipsoid_js__WEBPACK_IMPORTED_MODULE_7__/* ["default"].packedLength */ .Z.packedLength;\n\n  var semiMajorAxis = array[startingIndex++];\n  var semiMinorAxis = array[startingIndex++];\n  var rotation = array[startingIndex++];\n  var height = array[startingIndex++];\n  var granularity = array[startingIndex++];\n  var extrudedHeight = array[startingIndex++];\n  var numberOfVerticalLines = array[startingIndex++];\n  var offsetAttribute = array[startingIndex];\n\n  if (!(0,_defined_js__WEBPACK_IMPORTED_MODULE_15__/* ["default"] */ .Z)(result)) {\n    scratchOptions.height = height;\n    scratchOptions.extrudedHeight = extrudedHeight;\n    scratchOptions.granularity = granularity;\n    scratchOptions.rotation = rotation;\n    scratchOptions.semiMajorAxis = semiMajorAxis;\n    scratchOptions.semiMinorAxis = semiMinorAxis;\n    scratchOptions.numberOfVerticalLines = numberOfVerticalLines;\n    scratchOptions.offsetAttribute =\n      offsetAttribute === -1 ? undefined : offsetAttribute;\n\n    return new EllipseOutlineGeometry(scratchOptions);\n  }\n\n  result._center = _Cartesian3_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"].clone */ .Z.clone(center, result._center);\n  result._ellipsoid = _Ellipsoid_js__WEBPACK_IMPORTED_MODULE_7__/* ["default"].clone */ .Z.clone(ellipsoid, result._ellipsoid);\n  result._semiMajorAxis = semiMajorAxis;\n  result._semiMinorAxis = semiMinorAxis;\n  result._rotation = rotation;\n  result._height = height;\n  result._granularity = granularity;\n  result._extrudedHeight = extrudedHeight;\n  result._numberOfVerticalLines = numberOfVerticalLines;\n  result._offsetAttribute =\n    offsetAttribute === -1 ? undefined : offsetAttribute;\n\n  return result;\n};\n\n/**\n * Computes the geometric representation of an outline of an ellipse on an ellipsoid, including its vertices, indices, and a bounding sphere.\n *\n * @param {EllipseOutlineGeometry} ellipseGeometry A description of the ellipse.\n * @returns {Geometry|undefined} The computed vertices and indices.\n */\nEllipseOutlineGeometry.createGeometry = function (ellipseGeometry) {\n  if (\n    ellipseGeometry._semiMajorAxis <= 0.0 ||\n    ellipseGeometry._semiMinorAxis <= 0.0\n  ) {\n    return;\n  }\n\n  var height = ellipseGeometry._height;\n  var extrudedHeight = ellipseGeometry._extrudedHeight;\n  var extrude = !_Math_js__WEBPACK_IMPORTED_MODULE_13__/* ["default"].equalsEpsilon */ .Z.equalsEpsilon(\n    height,\n    extrudedHeight,\n    0,\n    _Math_js__WEBPACK_IMPORTED_MODULE_13__/* ["default"].EPSILON2 */ .Z.EPSILON2\n  );\n\n  ellipseGeometry._center = ellipseGeometry._ellipsoid.scaleToGeodeticSurface(\n    ellipseGeometry._center,\n    ellipseGeometry._center\n  );\n  var options = {\n    center: ellipseGeometry._center,\n    semiMajorAxis: ellipseGeometry._semiMajorAxis,\n    semiMinorAxis: ellipseGeometry._semiMinorAxis,\n    ellipsoid: ellipseGeometry._ellipsoid,\n    rotation: ellipseGeometry._rotation,\n    height: height,\n    granularity: ellipseGeometry._granularity,\n    numberOfVerticalLines: ellipseGeometry._numberOfVerticalLines,\n  };\n  var geometry;\n  if (extrude) {\n    options.extrudedHeight = extrudedHeight;\n    options.offsetAttribute = ellipseGeometry._offsetAttribute;\n    geometry = computeExtrudedEllipse(options);\n  } else {\n    geometry = computeEllipse(options);\n\n    if ((0,_defined_js__WEBPACK_IMPORTED_MODULE_15__/* ["default"] */ .Z)(ellipseGeometry._offsetAttribute)) {\n      var length = geometry.attributes.position.values.length;\n      var applyOffset = new Uint8Array(length / 3);\n      var offsetValue =\n        ellipseGeometry._offsetAttribute === _GeometryOffsetAttribute_js__WEBPACK_IMPORTED_MODULE_11__/* ["default"].NONE */ .Z.NONE\n          ? 0\n          : 1;\n      (0,_arrayFill_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .Z)(applyOffset, offsetValue);\n      geometry.attributes.applyOffset = new _GeometryAttribute_js__WEBPACK_IMPORTED_MODULE_9__/* ["default"] */ .Z({\n        componentDatatype: _ComponentDatatype_js__WEBPACK_IMPORTED_MODULE_3__/* ["default"].UNSIGNED_BYTE */ .Z.UNSIGNED_BYTE,\n        componentsPerAttribute: 1,\n        values: applyOffset,\n      });\n    }\n  }\n\n  return new _Geometry_js__WEBPACK_IMPORTED_MODULE_8__/* ["default"] */ .Z({\n    attributes: geometry.attributes,\n    indices: geometry.indices,\n    primitiveType: _PrimitiveType_js__WEBPACK_IMPORTED_MODULE_14__/* ["default"].LINES */ .Z.LINES,\n    boundingSphere: geometry.boundingSphere,\n    offsetAttribute: ellipseGeometry._offsetAttribute,\n  });\n};\n/* harmony default export */ __webpack_exports__["Z"] = (EllipseOutlineGeometry);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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Q0EsT0FBTztBQUNQO0FBQ0E7O0FBRUEsYUFBYSw2REFBUTtBQUNyQjtBQUNBO0FBQ0EsbUJBQW1CLCtFQUFtQjtBQUN0QztBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EseURBQWUsc0JBQXNCLEVBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly92dWUzLXdlYnBhY2s1Ly4vbm9kZV9tb2R1bGVzL2Nlc2l1bS9Tb3VyY2UvQ29yZS9FbGxpcHNlT3V0bGluZUdlb21ldHJ5LmpzPzA1ZTIiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IGFycmF5RmlsbCBmcm9tIFwiLi9hcnJheUZpbGwuanNcIjtcbmltcG9ydCBCb3VuZGluZ1NwaGVyZSBmcm9tIFwiLi9Cb3VuZGluZ1NwaGVyZS5qc1wiO1xuaW1wb3J0IENhcnRlc2lhbjMgZnJvbSBcIi4vQ2FydGVzaWFuMy5qc1wiO1xuaW1wb3J0IENvbXBvbmVudERhdGF0eXBlIGZyb20gXCIuL0NvbXBvbmVudERhdGF0eXBlLmpzXCI7XG5pbXBvcnQgZGVmYXVsdFZhbHVlIGZyb20gXCIuL2RlZmF1bHRWYWx1ZS5qc1wiO1xuaW1wb3J0IGRlZmluZWQgZnJvbSBcIi4vZGVmaW5lZC5qc1wiO1xuaW1wb3J0IERldmVsb3BlckVycm9yIGZyb20gXCIuL0RldmVsb3BlckVycm9yLmpzXCI7XG5pbXBvcnQgRWxsaXBzZUdlb21ldHJ5TGlicmFyeSBmcm9tIFwiLi9FbGxpcHNlR2VvbWV0cnlMaWJyYXJ5LmpzXCI7XG5pbXBvcnQgRWxsaXBzb2lkIGZyb20gXCIuL0VsbGlwc29pZC5qc1wiO1xuaW1wb3J0IEdlb21ldHJ5IGZyb20gXCIuL0dlb21ldHJ5LmpzXCI7XG5pbXBvcnQgR2VvbWV0cnlBdHRyaWJ1dGUgZnJvbSBcIi4vR2VvbWV0cnlBdHRyaWJ1dGUuanNcIjtcbmltcG9ydCBHZW9tZXRyeUF0dHJpYnV0ZXMgZnJvbSBcIi4vR2VvbWV0cnlBdHRyaWJ1dGVzLmpzXCI7XG5pbXBvcnQgR2VvbWV0cnlPZmZzZXRBdHRyaWJ1dGUgZnJvbSBcIi4vR2VvbWV0cnlPZmZzZXRBdHRyaWJ1dGUuanNcIjtcbmltcG9ydCBJbmRleERhdGF0eXBlIGZyb20gXCIuL0luZGV4RGF0YXR5cGUuanNcIjtcbmltcG9ydCBDZXNpdW1NYXRoIGZyb20gXCIuL01hdGguanNcIjtcbmltcG9ydCBQcmltaXRpdmVUeXBlIGZyb20gXCIuL1ByaW1pdGl2ZVR5cGUuanNcIjtcblxudmFyIHNjcmF0Y2hDYXJ0ZXNpYW4xID0gbmV3IENhcnRlc2lhbjMoKTtcbnZhciBib3VuZGluZ1NwaGVyZUNlbnRlciA9IG5ldyBDYXJ0ZXNpYW4zKCk7XG5cbmZ1bmN0aW9uIGNvbXB1dGVFbGxpcHNlKG9wdGlvbnMpIHtcbiAgdmFyIGNlbnRlciA9IG9wdGlvbnMuY2VudGVyO1xuICBib3VuZGluZ1NwaGVyZUNlbnRlciA9IENhcnRlc2lhbjMubXVsdGlwbHlCeVNjYWxhcihcbiAgICBvcHRpb25zLmVsbGlwc29pZC5nZW9kZXRpY1N1cmZhY2VOb3JtYWwoY2VudGVyLCBib3VuZGluZ1NwaGVyZUNlbnRlciksXG4gICAgb3B0aW9ucy5oZWlnaHQsXG4gICAgYm91bmRpbmdTcGhlcmVDZW50ZXJcbiAgKTtcbiAgYm91bmRpbmdTcGhlcmVDZW50ZXIgPSBDYXJ0ZXNpYW4zLmFkZChcbiAgICBjZW50ZXIsXG4gICAgYm91bmRpbmdTcGhlcmVDZW50ZXIsXG4gICAgYm91bmRpbmdTcGhlcmVDZW50ZXJcbiAgKTtcbiAgdmFyIGJvdW5kaW5nU3BoZXJlID0gbmV3IEJvdW5kaW5nU3BoZXJlKFxuICAgIGJvdW5kaW5nU3BoZXJlQ2VudGVyLFxuICAgIG9wdGlvbnMuc2VtaU1ham9yQXhpc1xuICApO1xuICB2YXIgcG9zaXRpb25zID0gRWxsaXBzZUdlb21ldHJ5TGlicmFyeS5jb21wdXRlRWxsaXBzZVBvc2l0aW9ucyhcbiAgICBvcHRpb25zLFxuICAgIGZhbHNlLFxuICAgIHRydWVcbiAgKS5vdXRlclBvc2l0aW9ucztcblxuICB2YXIgYXR0cmlidXRlcyA9IG5ldyBHZW9tZXRyeUF0dHJpYnV0ZXMoe1xuICAgIHBvc2l0aW9uOiBuZXcgR2VvbWV0cnlBdHRyaWJ1dGUoe1xuICAgICAgY29tcG9uZW50RGF0YXR5cGU6IENvbXBvbmVudERhdGF0eXBlLkRPVUJMRSxcbiAgICAgIGNvbXBvbmVudHNQZXJBdHRyaWJ1dGU6IDMsXG4gICAgICB2YWx1ZXM6IEVsbGlwc2VHZW9tZXRyeUxpYnJhcnkucmFpc2VQb3NpdGlvbnNUb0hlaWdodChcbiAgICAgICAgcG9zaXRpb25zLFxuICAgICAgICBvcHRpb25zLFxuICAgICAgICBmYWxzZVxuICAgICAgKSxcbiAgICB9KSxcbiAgfSk7XG5cbiAgdmFyIGxlbmd0aCA9IHBvc2l0aW9ucy5sZW5ndGggLyAzO1xuICB2YXIgaW5kaWNlcyA9IEluZGV4RGF0YXR5cGUuY3JlYXRlVHlwZWRBcnJheShsZW5ndGgsIGxlbmd0aCAqIDIpO1xuICB2YXIgaW5kZXggPSAwO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgKytpKSB7XG4gICAgaW5kaWNlc1tpbmRleCsrXSA9IGk7XG4gICAgaW5kaWNlc1tpbmRleCsrXSA9IChpICsgMSkgJSBsZW5ndGg7XG4gIH1cblxuICByZXR1cm4ge1xuICAgIGJvdW5kaW5nU3BoZXJlOiBib3VuZGluZ1NwaGVyZSxcbiAgICBhdHRyaWJ1dGVzOiBhdHRyaWJ1dGVzLFxuICAgIGluZGljZXM6IGluZGljZXMsXG4gIH07XG59XG5cbnZhciB0b3BCb3VuZGluZ1NwaGVyZSA9IG5ldyBCb3VuZGluZ1NwaGVyZSgpO1xudmFyIGJvdHRvbUJvdW5kaW5nU3BoZXJlID0gbmV3IEJvdW5kaW5nU3BoZXJlKCk7XG5mdW5jdGlvbiBjb21wdXRlRXh0cnVkZWRFbGxpcHNlKG9wdGlvbnMpIHtcbiAgdmFyIGNlbnRlciA9IG9wdGlvbnMuY2VudGVyO1xuICB2YXIgZWxsaXBzb2lkID0gb3B0aW9ucy5lbGxpcHNvaWQ7XG4gIHZhciBzZW1pTWFqb3JBeGlzID0gb3B0aW9ucy5zZW1pTWFqb3JBeGlzO1xuICB2YXIgc2NhbGVkTm9ybWFsID0gQ2FydGVzaWFuMy5tdWx0aXBseUJ5U2NhbGFyKFxuICAgIGVsbGlwc29pZC5nZW9kZXRpY1N1cmZhY2VOb3JtYWwoY2VudGVyLCBzY3JhdGNoQ2FydGVzaWFuMSksXG4gICAgb3B0aW9ucy5oZWlnaHQsXG4gICAgc2NyYXRjaENhcnRlc2lhbjFcbiAgKTtcbiAgdG9wQm91bmRpbmdTcGhlcmUuY2VudGVyID0gQ2FydGVzaWFuMy5hZGQoXG4gICAgY2VudGVyLFxuICAgIHNjYWxlZE5vcm1hbCxcbiAgICB0b3BCb3VuZGluZ1NwaGVyZS5jZW50ZXJcbiAgKTtcbiAgdG9wQm91bmRpbmdTcGhlcmUucmFkaXVzID0gc2VtaU1ham9yQXhpcztcblxuICBzY2FsZWROb3JtYWwgPSBDYXJ0ZXNpYW4zLm11bHRpcGx5QnlTY2FsYXIoXG4gICAgZWxsaXBzb2lkLmdlb2RldGljU3VyZmFjZU5vcm1hbChjZW50ZXIsIHNjYWxlZE5vcm1hbCksXG4gICAgb3B0aW9ucy5leHRydWRlZEhlaWdodCxcbiAgICBzY2FsZWROb3JtYWxcbiAgKTtcbiAgYm90dG9tQm91bmRpbmdTcGhlcmUuY2VudGVyID0gQ2FydGVzaWFuMy5hZGQoXG4gICAgY2VudGVyLFxuICAgIHNjYWxlZE5vcm1hbCxcbiAgICBib3R0b21Cb3VuZGluZ1NwaGVyZS5jZW50ZXJcbiAgKTtcbiAgYm90dG9tQm91bmRpbmdTcGhlcmUucmFkaXVzID0gc2VtaU1ham9yQXhpcztcblxuICB2YXIgcG9zaXRpb25zID0gRWxsaXBzZUdlb21ldHJ5TGlicmFyeS5jb21wdXRlRWxsaXBzZVBvc2l0aW9ucyhcbiAgICBvcHRpb25zLFxuICAgIGZhbHNlLFxuICAgIHRydWVcbiAgKS5vdXRlclBvc2l0aW9ucztcbiAgdmFyIGF0dHJpYnV0ZXMgPSBuZXcgR2VvbWV0cnlBdHRyaWJ1dGVzKHtcbiAgICBwb3NpdGlvbjogbmV3IEdlb21ldHJ5QXR0cmlidXRlKHtcbiAgICAgIGNvbXBvbmVudERhdGF0eXBlOiBDb21wb25lbnREYXRhdHlwZS5ET1VCTEUsXG4gICAgICBjb21wb25lbnRzUGVyQXR0cmlidXRlOiAzLFxuICAgICAgdmFsdWVzOiBFbGxpcHNlR2VvbWV0cnlMaWJyYXJ5LnJhaXNlUG9zaXRpb25zVG9IZWlnaHQoXG4gICAgICAgIHBvc2l0aW9ucyxcbiAgICAgICAgb3B0aW9ucyxcbiAgICAgICAgdHJ1ZVxuICAgICAgKSxcbiAgICB9KSxcbiAgfSk7XG5cbiAgcG9zaXRpb25zID0gYXR0cmlidXRlcy5wb3NpdGlvbi52YWx1ZXM7XG4gIHZhciBib3VuZGluZ1NwaGVyZSA9IEJvdW5kaW5nU3BoZXJlLnVuaW9uKFxuICAgIHRvcEJvdW5kaW5nU3BoZXJlLFxuICAgIGJvdHRvbUJvdW5kaW5nU3BoZXJlXG4gICk7XG4gIHZhciBsZW5ndGggPSBwb3NpdGlvbnMubGVuZ3RoIC8gMztcblxuICBpZiAoZGVmaW5lZChvcHRpb25zLm9mZnNldEF0dHJpYnV0ZSkpIHtcbiAgICB2YXIgYXBwbHlPZmZzZXQgPSBuZXcgVWludDhBcnJheShsZW5ndGgpO1xuICAgIGlmIChvcHRpb25zLm9mZnNldEF0dHJpYnV0ZSA9PT0gR2VvbWV0cnlPZmZzZXRBdHRyaWJ1dGUuVE9QKSB7XG4gICAgICBhcHBseU9mZnNldCA9IGFycmF5RmlsbChhcHBseU9mZnNldCwgMSwgMCwgbGVuZ3RoIC8gMik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBvZmZzZXRWYWx1ZSA9XG4gICAgICAgIG9wdGlvbnMub2Zmc2V0QXR0cmlidXRlID09PSBHZW9tZXRyeU9mZnNldEF0dHJpYnV0ZS5OT05FID8gMCA6IDE7XG4gICAgICBhcHBseU9mZnNldCA9IGFycmF5RmlsbChhcHBseU9mZnNldCwgb2Zmc2V0VmFsdWUpO1xuICAgIH1cblxuICAgIGF0dHJpYnV0ZXMuYXBwbHlPZmZzZXQgPSBuZXcgR2VvbWV0cnlBdHRyaWJ1dGUoe1xuICAgICAgY29tcG9uZW50RGF0YXR5cGU6IENvbXBvbmVudERhdGF0eXBlLlVOU0lHTkVEX0JZVEUsXG4gICAgICBjb21wb25lbnRzUGVyQXR0cmlidXRlOiAxLFxuICAgICAgdmFsdWVzOiBhcHBseU9mZnNldCxcbiAgICB9KTtcbiAgfVxuXG4gIHZhciBudW1iZXJPZlZlcnRpY2FsTGluZXMgPSBkZWZhdWx0VmFsdWUob3B0aW9ucy5udW1iZXJPZlZlcnRpY2FsTGluZXMsIDE2KTtcbiAgbnVtYmVyT2ZWZXJ0aWNhbExpbmVzID0gQ2VzaXVtTWF0aC5jbGFtcChcbiAgICBudW1iZXJPZlZlcnRpY2FsTGluZXMsXG4gICAgMCxcbiAgICBsZW5ndGggLyAyXG4gICk7XG5cbiAgdmFyIGluZGljZXMgPSBJbmRleERhdGF0eXBlLmNyZWF0ZVR5cGVkQXJyYXkoXG4gICAgbGVuZ3RoLFxuICAgIGxlbmd0aCAqIDIgKyBudW1iZXJPZlZlcnRpY2FsTGluZXMgKiAyXG4gICk7XG5cbiAgbGVuZ3RoIC89IDI7XG4gIHZhciBpbmRleCA9IDA7XG4gIHZhciBpO1xuICBmb3IgKGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kpIHtcbiAgICBpbmRpY2VzW2luZGV4KytdID0gaTtcbiAgICBpbmRpY2VzW2luZGV4KytdID0gKGkgKyAxKSAlIGxlbmd0aDtcbiAgICBpbmRpY2VzW2luZGV4KytdID0gaSArIGxlbmd0aDtcbiAgICBpbmRpY2VzW2luZGV4KytdID0gKChpICsgMSkgJSBsZW5ndGgpICsgbGVuZ3RoO1xuICB9XG5cbiAgdmFyIG51bVNpZGU7XG4gIGlmIChudW1iZXJPZlZlcnRpY2FsTGluZXMgPiAwKSB7XG4gICAgdmFyIG51bVNpZGVMaW5lcyA9IE1hdGgubWluKG51bWJlck9mVmVydGljYWxMaW5lcywgbGVuZ3RoKTtcbiAgICBudW1TaWRlID0gTWF0aC5yb3VuZChsZW5ndGggLyBudW1TaWRlTGluZXMpO1xuXG4gICAgdmFyIG1heEkgPSBNYXRoLm1pbihudW1TaWRlICogbnVtYmVyT2ZWZXJ0aWNhbExpbmVzLCBsZW5ndGgpO1xuICAgIGZvciAoaSA9IDA7IGkgPCBtYXhJOyBpICs9IG51bVNpZGUpIHtcbiAgICAgIGluZGljZXNbaW5kZXgrK10gPSBpO1xuICAgICAgaW5kaWNlc1tpbmRleCsrXSA9IGkgKyBsZW5ndGg7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBib3VuZGluZ1NwaGVyZTogYm91bmRpbmdTcGhlcmUsXG4gICAgYXR0cmlidXRlczogYXR0cmlidXRlcyxcbiAgICBpbmRpY2VzOiBpbmRpY2VzLFxuICB9O1xufVxuXG4vKipcbiAqIEEgZGVzY3JpcHRpb24gb2YgdGhlIG91dGxpbmUgb2YgYW4gZWxsaXBzZSBvbiBhbiBlbGxpcHNvaWQuXG4gKlxuICogQGFsaWFzIEVsbGlwc2VPdXRsaW5lR2VvbWV0cnlcbiAqIEBjb25zdHJ1Y3RvclxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIE9iamVjdCB3aXRoIHRoZSBmb2xsb3dpbmcgcHJvcGVydGllczpcbiAqIEBwYXJhbSB7Q2FydGVzaWFuM30gb3B0aW9ucy5jZW50ZXIgVGhlIGVsbGlwc2UncyBjZW50ZXIgcG9pbnQgaW4gdGhlIGZpeGVkIGZyYW1lLlxuICogQHBhcmFtIHtOdW1iZXJ9IG9wdGlvbnMuc2VtaU1ham9yQXhpcyBUaGUgbGVuZ3RoIG9mIHRoZSBlbGxpcHNlJ3Mgc2VtaS1tYWpvciBheGlzIGluIG1ldGVycy5cbiAqIEBwYXJhbSB7TnVtYmVyfSBvcHRpb25zLnNlbWlNaW5vckF4aXMgVGhlIGxlbmd0aCBvZiB0aGUgZWxsaXBzZSdzIHNlbWktbWlub3IgYXhpcyBpbiBtZXRlcnMuXG4gKiBAcGFyYW0ge0VsbGlwc29pZH0gW29wdGlvbnMuZWxsaXBzb2lkPUVsbGlwc29pZC5XR1M4NF0gVGhlIGVsbGlwc29pZCB0aGUgZWxsaXBzZSB3aWxsIGJlIG9uLlxuICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLmhlaWdodD0wLjBdIFRoZSBkaXN0YW5jZSBpbiBtZXRlcnMgYmV0d2VlbiB0aGUgZWxsaXBzZSBhbmQgdGhlIGVsbGlwc29pZCBzdXJmYWNlLlxuICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLmV4dHJ1ZGVkSGVpZ2h0XSBUaGUgZGlzdGFuY2UgaW4gbWV0ZXJzIGJldHdlZW4gdGhlIGVsbGlwc2UncyBleHRydWRlZCBmYWNlIGFuZCB0aGUgZWxsaXBzb2lkIHN1cmZhY2UuXG4gKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMucm90YXRpb249MC4wXSBUaGUgYW5nbGUgZnJvbSBub3J0aCAoY291bnRlci1jbG9ja3dpc2UpIGluIHJhZGlhbnMuXG4gKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMuZ3JhbnVsYXJpdHk9MC4wMl0gVGhlIGFuZ3VsYXIgZGlzdGFuY2UgYmV0d2VlbiBwb2ludHMgb24gdGhlIGVsbGlwc2UgaW4gcmFkaWFucy5cbiAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5udW1iZXJPZlZlcnRpY2FsTGluZXM9MTZdIE51bWJlciBvZiBsaW5lcyB0byBkcmF3IGJldHdlZW4gdGhlIHRvcCBhbmQgYm90dG9tIHN1cmZhY2Ugb2YgYW4gZXh0cnVkZWQgZWxsaXBzZS5cbiAqXG4gKiBAZXhjZXB0aW9uIHtEZXZlbG9wZXJFcnJvcn0gc2VtaU1ham9yQXhpcyBhbmQgc2VtaU1pbm9yQXhpcyBtdXN0IGJlIGdyZWF0ZXIgdGhhbiB6ZXJvLlxuICogQGV4Y2VwdGlvbiB7RGV2ZWxvcGVyRXJyb3J9IHNlbWlNYWpvckF4aXMgbXVzdCBiZSBncmVhdGVyIHRoYW4gb3IgZXF1YWwgdG8gdGhlIHNlbWlNaW5vckF4aXMuXG4gKiBAZXhjZXB0aW9uIHtEZXZlbG9wZXJFcnJvcn0gZ3JhbnVsYXJpdHkgbXVzdCBiZSBncmVhdGVyIHRoYW4gemVyby5cbiAqXG4gKiBAc2VlIEVsbGlwc2VPdXRsaW5lR2VvbWV0cnkuY3JlYXRlR2VvbWV0cnlcbiAqXG4gKiBAZXhhbXBsZVxuICogdmFyIGVsbGlwc2UgPSBuZXcgQ2VzaXVtLkVsbGlwc2VPdXRsaW5lR2VvbWV0cnkoe1xuICogICBjZW50ZXIgOiBDZXNpdW0uQ2FydGVzaWFuMy5mcm9tRGVncmVlcygtNzUuNTk3NzcsIDQwLjAzODgzKSxcbiAqICAgc2VtaU1ham9yQXhpcyA6IDUwMDAwMC4wLFxuICogICBzZW1pTWlub3JBeGlzIDogMzAwMDAwLjAsXG4gKiAgIHJvdGF0aW9uIDogQ2VzaXVtLk1hdGgudG9SYWRpYW5zKDYwLjApXG4gKiB9KTtcbiAqIHZhciBnZW9tZXRyeSA9IENlc2l1bS5FbGxpcHNlT3V0bGluZUdlb21ldHJ5LmNyZWF0ZUdlb21ldHJ5KGVsbGlwc2UpO1xuICovXG5mdW5jdGlvbiBFbGxpcHNlT3V0bGluZUdlb21ldHJ5KG9wdGlvbnMpIHtcbiAgb3B0aW9ucyA9IGRlZmF1bHRWYWx1ZShvcHRpb25zLCBkZWZhdWx0VmFsdWUuRU1QVFlfT0JKRUNUKTtcblxuICB2YXIgY2VudGVyID0gb3B0aW9ucy5jZW50ZXI7XG4gIHZhciBlbGxpcHNvaWQgPSBkZWZhdWx0VmFsdWUob3B0aW9ucy5lbGxpcHNvaWQsIEVsbGlwc29pZC5XR1M4NCk7XG4gIHZhciBzZW1pTWFqb3JBeGlzID0gb3B0aW9ucy5zZW1pTWFqb3JBeGlzO1xuICB2YXIgc2VtaU1pbm9yQXhpcyA9IG9wdGlvbnMuc2VtaU1pbm9yQXhpcztcbiAgdmFyIGdyYW51bGFyaXR5ID0gZGVmYXVsdFZhbHVlKFxuICAgIG9wdGlvbnMuZ3JhbnVsYXJpdHksXG4gICAgQ2VzaXVtTWF0aC5SQURJQU5TX1BFUl9ERUdSRUVcbiAgKTtcblxuICAvLz4+aW5jbHVkZVN0YXJ0KCdkZWJ1ZycsIHByYWdtYXMuZGVidWcpO1xuICBpZiAoIWRlZmluZWQoY2VudGVyKSkge1xuICAgIHRocm93IG5ldyBEZXZlbG9wZXJFcnJvcihcImNlbnRlciBpcyByZXF1aXJlZC5cIik7XG4gIH1cbiAgaWYgKCFkZWZpbmVkKHNlbWlNYWpvckF4aXMpKSB7XG4gICAgdGhyb3cgbmV3IERldmVsb3BlckVycm9yKFwic2VtaU1ham9yQXhpcyBpcyByZXF1aXJlZC5cIik7XG4gIH1cbiAgaWYgKCFkZWZpbmVkKHNlbWlNaW5vckF4aXMpKSB7XG4gICAgdGhyb3cgbmV3IERldmVsb3BlckVycm9yKFwic2VtaU1pbm9yQXhpcyBpcyByZXF1aXJlZC5cIik7XG4gIH1cbiAgaWYgKHNlbWlNYWpvckF4aXMgPCBzZW1pTWlub3JBeGlzKSB7XG4gICAgdGhyb3cgbmV3IERldmVsb3BlckVycm9yKFxuICAgICAgXCJzZW1pTWFqb3JBeGlzIG11c3QgYmUgZ3JlYXRlciB0aGFuIG9yIGVxdWFsIHRvIHRoZSBzZW1pTWlub3JBeGlzLlwiXG4gICAgKTtcbiAgfVxuICBpZiAoZ3JhbnVsYXJpdHkgPD0gMC4wKSB7XG4gICAgdGhyb3cgbmV3IERldmVsb3BlckVycm9yKFwiZ3JhbnVsYXJpdHkgbXVzdCBiZSBncmVhdGVyIHRoYW4gemVyby5cIik7XG4gIH1cbiAgLy8+PmluY2x1ZGVFbmQoJ2RlYnVnJyk7XG5cbiAgdmFyIGhlaWdodCA9IGRlZmF1bHRWYWx1ZShvcHRpb25zLmhlaWdodCwgMC4wKTtcbiAgdmFyIGV4dHJ1ZGVkSGVpZ2h0ID0gZGVmYXVsdFZhbHVlKG9wdGlvbnMuZXh0cnVkZWRIZWlnaHQsIGhlaWdodCk7XG5cbiAgdGhpcy5fY2VudGVyID0gQ2FydGVzaWFuMy5jbG9uZShjZW50ZXIpO1xuICB0aGlzLl9zZW1pTWFqb3JBeGlzID0gc2VtaU1ham9yQXhpcztcbiAgdGhpcy5fc2VtaU1pbm9yQXhpcyA9IHNlbWlNaW5vckF4aXM7XG4gIHRoaXMuX2VsbGlwc29pZCA9IEVsbGlwc29pZC5jbG9uZShlbGxpcHNvaWQpO1xuICB0aGlzLl9yb3RhdGlvbiA9IGRlZmF1bHRWYWx1ZShvcHRpb25zLnJvdGF0aW9uLCAwLjApO1xuICB0aGlzLl9oZWlnaHQgPSBNYXRoLm1heChleHRydWRlZEhlaWdodCwgaGVpZ2h0KTtcbiAgdGhpcy5fZ3JhbnVsYXJpdHkgPSBncmFudWxhcml0eTtcbiAgdGhpcy5fZXh0cnVkZWRIZWlnaHQgPSBNYXRoLm1pbihleHRydWRlZEhlaWdodCwgaGVpZ2h0KTtcbiAgdGhpcy5fbnVtYmVyT2ZWZXJ0aWNhbExpbmVzID0gTWF0aC5tYXgoXG4gICAgZGVmYXVsdFZhbHVlKG9wdGlvbnMubnVtYmVyT2ZWZXJ0aWNhbExpbmVzLCAxNiksXG4gICAgMFxuICApO1xuICB0aGlzLl9vZmZzZXRBdHRyaWJ1dGUgPSBvcHRpb25zLm9mZnNldEF0dHJpYnV0ZTtcbiAgdGhpcy5fd29ya2VyTmFtZSA9IFwiY3JlYXRlRWxsaXBzZU91dGxpbmVHZW9tZXRyeVwiO1xufVxuXG4vKipcbiAqIFRoZSBudW1iZXIgb2YgZWxlbWVudHMgdXNlZCB0byBwYWNrIHRoZSBvYmplY3QgaW50byBhbiBhcnJheS5cbiAqIEB0eXBlIHtOdW1iZXJ9XG4gKi9cbkVsbGlwc2VPdXRsaW5lR2VvbWV0cnkucGFja2VkTGVuZ3RoID1cbiAgQ2FydGVzaWFuMy5wYWNrZWRMZW5ndGggKyBFbGxpcHNvaWQucGFja2VkTGVuZ3RoICsgODtcblxuLyoqXG4gKiBTdG9yZXMgdGhlIHByb3ZpZGVkIGluc3RhbmNlIGludG8gdGhlIHByb3ZpZGVkIGFycmF5LlxuICpcbiAqIEBwYXJhbSB7RWxsaXBzZU91dGxpbmVHZW9tZXRyeX0gdmFsdWUgVGhlIHZhbHVlIHRvIHBhY2suXG4gKiBAcGFyYW0ge051bWJlcltdfSBhcnJheSBUaGUgYXJyYXkgdG8gcGFjayBpbnRvLlxuICogQHBhcmFtIHtOdW1iZXJ9IFtzdGFydGluZ0luZGV4PTBdIFRoZSBpbmRleCBpbnRvIHRoZSBhcnJheSBhdCB3aGljaCB0byBzdGFydCBwYWNraW5nIHRoZSBlbGVtZW50cy5cbiAqXG4gKiBAcmV0dXJucyB7TnVtYmVyW119IFRoZSBhcnJheSB0aGF0IHdhcyBwYWNrZWQgaW50b1xuICovXG5FbGxpcHNlT3V0bGluZUdlb21ldHJ5LnBhY2sgPSBmdW5jdGlvbiAodmFsdWUsIGFycmF5LCBzdGFydGluZ0luZGV4KSB7XG4gIC8vPj5pbmNsdWRlU3RhcnQoJ2RlYnVnJywgcHJhZ21hcy5kZWJ1Zyk7XG4gIGlmICghZGVmaW5lZCh2YWx1ZSkpIHtcbiAgICB0aHJvdyBuZXcgRGV2ZWxvcGVyRXJyb3IoXCJ2YWx1ZSBpcyByZXF1aXJlZFwiKTtcbiAgfVxuICBpZiAoIWRlZmluZWQoYXJyYXkpKSB7XG4gICAgdGhyb3cgbmV3IERldmVsb3BlckVycm9yKFwiYXJyYXkgaXMgcmVxdWlyZWRcIik7XG4gIH1cbiAgLy8+PmluY2x1ZGVFbmQoJ2RlYnVnJyk7XG5cbiAgc3RhcnRpbmdJbmRleCA9IGRlZmF1bHRWYWx1ZShzdGFydGluZ0luZGV4LCAwKTtcblxuICBDYXJ0ZXNpYW4zLnBhY2sodmFsdWUuX2NlbnRlciwgYXJyYXksIHN0YXJ0aW5nSW5kZXgpO1xuICBzdGFydGluZ0luZGV4ICs9IENhcnRlc2lhbjMucGFja2VkTGVuZ3RoO1xuXG4gIEVsbGlwc29pZC5wYWNrKHZhbHVlLl9lbGxpcHNvaWQsIGFycmF5LCBzdGFydGluZ0luZGV4KTtcbiAgc3RhcnRpbmdJbmRleCArPSBFbGxpcHNvaWQucGFja2VkTGVuZ3RoO1xuXG4gIGFycmF5W3N0YXJ0aW5nSW5kZXgrK10gPSB2YWx1ZS5fc2VtaU1ham9yQXhpcztcbiAgYXJyYXlbc3RhcnRpbmdJbmRleCsrXSA9IHZhbHVlLl9zZW1pTWlub3JBeGlzO1xuICBhcnJheVtzdGFydGluZ0luZGV4KytdID0gdmFsdWUuX3JvdGF0aW9uO1xuICBhcnJheVtzdGFydGluZ0luZGV4KytdID0gdmFsdWUuX2hlaWdodDtcbiAgYXJyYXlbc3RhcnRpbmdJbmRleCsrXSA9IHZhbHVlLl9ncmFudWxhcml0eTtcbiAgYXJyYXlbc3RhcnRpbmdJbmRleCsrXSA9IHZhbHVlLl9leHRydWRlZEhlaWdodDtcbiAgYXJyYXlbc3RhcnRpbmdJbmRleCsrXSA9IHZhbHVlLl9udW1iZXJPZlZlcnRpY2FsTGluZXM7XG4gIGFycmF5W3N0YXJ0aW5nSW5kZXhdID0gZGVmYXVsdFZhbHVlKHZhbHVlLl9vZmZzZXRBdHRyaWJ1dGUsIC0xKTtcblxuICByZXR1cm4gYXJyYXk7XG59O1xuXG52YXIgc2NyYXRjaENlbnRlciA9IG5ldyBDYXJ0ZXNpYW4zKCk7XG52YXIgc2NyYXRjaEVsbGlwc29pZCA9IG5ldyBFbGxpcHNvaWQoKTtcbnZhciBzY3JhdGNoT3B0aW9ucyA9IHtcbiAgY2VudGVyOiBzY3JhdGNoQ2VudGVyLFxuICBlbGxpcHNvaWQ6IHNjcmF0Y2hFbGxpcHNvaWQsXG4gIHNlbWlNYWpvckF4aXM6IHVuZGVmaW5lZCxcbiAgc2VtaU1pbm9yQXhpczogdW5kZWZpbmVkLFxuICByb3RhdGlvbjogdW5kZWZpbmVkLFxuICBoZWlnaHQ6IHVuZGVmaW5lZCxcbiAgZ3JhbnVsYXJpdHk6IHVuZGVmaW5lZCxcbiAgZXh0cnVkZWRIZWlnaHQ6IHVuZGVmaW5lZCxcbiAgbnVtYmVyT2ZWZXJ0aWNhbExpbmVzOiB1bmRlZmluZWQsXG4gIG9mZnNldEF0dHJpYnV0ZTogdW5kZWZpbmVkLFxufTtcblxuLyoqXG4gKiBSZXRyaWV2ZXMgYW4gaW5zdGFuY2UgZnJvbSBhIHBhY2tlZCBhcnJheS5cbiAqXG4gKiBAcGFyYW0ge051bWJlcltdfSBhcnJheSBUaGUgcGFja2VkIGFycmF5LlxuICogQHBhcmFtIHtOdW1iZXJ9IFtzdGFydGluZ0luZGV4PTBdIFRoZSBzdGFydGluZyBpbmRleCBvZiB0aGUgZWxlbWVudCB0byBiZSB1bnBhY2tlZC5cbiAqIEBwYXJhbSB7RWxsaXBzZU91dGxpbmVHZW9tZXRyeX0gW3Jlc3VsdF0gVGhlIG9iamVjdCBpbnRvIHdoaWNoIHRvIHN0b3JlIHRoZSByZXN1bHQuXG4gKiBAcmV0dXJucyB7RWxsaXBzZU91dGxpbmVHZW9tZXRyeX0gVGhlIG1vZGlmaWVkIHJlc3VsdCBwYXJhbWV0ZXIgb3IgYSBuZXcgRWxsaXBzZU91dGxpbmVHZW9tZXRyeSBpbnN0YW5jZSBpZiBvbmUgd2FzIG5vdCBwcm92aWRlZC5cbiAqL1xuRWxsaXBzZU91dGxpbmVHZW9tZXRyeS51bnBhY2sgPSBmdW5jdGlvbiAoYXJyYXksIHN0YXJ0aW5nSW5kZXgsIHJlc3VsdCkge1xuICAvLz4+aW5jbHVkZVN0YXJ0KCdkZWJ1ZycsIHByYWdtYXMuZGVidWcpO1xuICBpZiAoIWRlZmluZWQoYXJyYXkpKSB7XG4gICAgdGhyb3cgbmV3IERldmVsb3BlckVycm9yKFwiYXJyYXkgaXMgcmVxdWlyZWRcIik7XG4gIH1cbiAgLy8+PmluY2x1ZGVFbmQoJ2RlYnVnJyk7XG5cbiAgc3RhcnRpbmdJbmRleCA9IGRlZmF1bHRWYWx1ZShzdGFydGluZ0luZGV4LCAwKTtcblxuICB2YXIgY2VudGVyID0gQ2FydGVzaWFuMy51bnBhY2soYXJyYXksIHN0YXJ0aW5nSW5kZXgsIHNjcmF0Y2hDZW50ZXIpO1xuICBzdGFydGluZ0luZGV4ICs9IENhcnRlc2lhbjMucGFja2VkTGVuZ3RoO1xuXG4gIHZhciBlbGxpcHNvaWQgPSBFbGxpcHNvaWQudW5wYWNrKGFycmF5LCBzdGFydGluZ0luZGV4LCBzY3JhdGNoRWxsaXBzb2lkKTtcbiAgc3RhcnRpbmdJbmRleCArPSBFbGxpcHNvaWQucGFja2VkTGVuZ3RoO1xuXG4gIHZhciBzZW1pTWFqb3JBeGlzID0gYXJyYXlbc3RhcnRpbmdJbmRleCsrXTtcbiAgdmFyIHNlbWlNaW5vckF4aXMgPSBhcnJheVtzdGFydGluZ0luZGV4KytdO1xuICB2YXIgcm90YXRpb24gPSBhcnJheVtzdGFydGluZ0luZGV4KytdO1xuICB2YXIgaGVpZ2h0ID0gYXJyYXlbc3RhcnRpbmdJbmRleCsrXTtcbiAgdmFyIGdyYW51bGFyaXR5ID0gYXJyYXlbc3RhcnRpbmdJbmRleCsrXTtcbiAgdmFyIGV4dHJ1ZGVkSGVpZ2h0ID0gYXJyYXlbc3RhcnRpbmdJbmRleCsrXTtcbiAgdmFyIG51bWJlck9mVmVydGljYWxMaW5lcyA9IGFycmF5W3N0YXJ0aW5nSW5kZXgrK107XG4gIHZhciBvZmZzZXRBdHRyaWJ1dGUgPSBhcnJheVtzdGFydGluZ0luZGV4XTtcblxuICBpZiAoIWRlZmluZWQocmVzdWx0KSkge1xuICAgIHNjcmF0Y2hPcHRpb25zLmhlaWdodCA9IGhlaWdodDtcbiAgICBzY3JhdGNoT3B0aW9ucy5leHRydWRlZEhlaWdodCA9IGV4dHJ1ZGVkSGVpZ2h0O1xuICAgIHNjcmF0Y2hPcHRpb25zLmdyYW51bGFyaXR5ID0gZ3JhbnVsYXJpdHk7XG4gICAgc2NyYXRjaE9wdGlvbnMucm90YXRpb24gPSByb3RhdGlvbjtcbiAgICBzY3JhdGNoT3B0aW9ucy5zZW1pTWFqb3JBeGlzID0gc2VtaU1ham9yQXhpcztcbiAgICBzY3JhdGNoT3B0aW9ucy5zZW1pTWlub3JBeGlzID0gc2VtaU1pbm9yQXhpcztcbiAgICBzY3JhdGNoT3B0aW9ucy5udW1iZXJPZlZlcnRpY2FsTGluZXMgPSBudW1iZXJPZlZlcnRpY2FsTGluZXM7XG4gICAgc2NyYXRjaE9wdGlvbnMub2Zmc2V0QXR0cmlidXRlID1cbiAgICAgIG9mZnNldEF0dHJpYnV0ZSA9PT0gLTEgPyB1bmRlZmluZWQgOiBvZmZzZXRBdHRyaWJ1dGU7XG5cbiAgICByZXR1cm4gbmV3IEVsbGlwc2VPdXRsaW5lR2VvbWV0cnkoc2NyYXRjaE9wdGlvbnMpO1xuICB9XG5cbiAgcmVzdWx0Ll9jZW50ZXIgPSBDYXJ0ZXNpYW4zLmNsb25lKGNlbnRlciwgcmVzdWx0Ll9jZW50ZXIpO1xuICByZXN1bHQuX2VsbGlwc29pZCA9IEVsbGlwc29pZC5jbG9uZShlbGxpcHNvaWQsIHJlc3VsdC5fZWxsaXBzb2lkKTtcbiAgcmVzdWx0Ll9zZW1pTWFqb3JBeGlzID0gc2VtaU1ham9yQXhpcztcbiAgcmVzdWx0Ll9zZW1pTWlub3JBeGlzID0gc2VtaU1pbm9yQXhpcztcbiAgcmVzdWx0Ll9yb3RhdGlvbiA9IHJvdGF0aW9uO1xuICByZXN1bHQuX2hlaWdodCA9IGhlaWdodDtcbiAgcmVzdWx0Ll9ncmFudWxhcml0eSA9IGdyYW51bGFyaXR5O1xuICByZXN1bHQuX2V4dHJ1ZGVkSGVpZ2h0ID0gZXh0cnVkZWRIZWlnaHQ7XG4gIHJlc3VsdC5fbnVtYmVyT2ZWZXJ0aWNhbExpbmVzID0gbnVtYmVyT2ZWZXJ0aWNhbExpbmVzO1xuICByZXN1bHQuX29mZnNldEF0dHJpYnV0ZSA9XG4gICAgb2Zmc2V0QXR0cmlidXRlID09PSAtMSA/IHVuZGVmaW5lZCA6IG9mZnNldEF0dHJpYnV0ZTtcblxuICByZXR1cm4gcmVzdWx0O1xufTtcblxuLyoqXG4gKiBDb21wdXRlcyB0aGUgZ2VvbWV0cmljIHJlcHJlc2VudGF0aW9uIG9mIGFuIG91dGxpbmUgb2YgYW4gZWxsaXBzZSBvbiBhbiBlbGxpcHNvaWQsIGluY2x1ZGluZyBpdHMgdmVydGljZXMsIGluZGljZXMsIGFuZCBhIGJvdW5kaW5nIHNwaGVyZS5cbiAqXG4gKiBAcGFyYW0ge0VsbGlwc2VPdXRsaW5lR2VvbWV0cnl9IGVsbGlwc2VHZW9tZXRyeSBBIGRlc2NyaXB0aW9uIG9mIHRoZSBlbGxpcHNlLlxuICogQHJldHVybnMge0dlb21ldHJ5fHVuZGVmaW5lZH0gVGhlIGNvbXB1dGVkIHZlcnRpY2VzIGFuZCBpbmRpY2VzLlxuICovXG5FbGxpcHNlT3V0bGluZUdlb21ldHJ5LmNyZWF0ZUdlb21ldHJ5ID0gZnVuY3Rpb24gKGVsbGlwc2VHZW9tZXRyeSkge1xuICBpZiAoXG4gICAgZWxsaXBzZUdlb21ldHJ5Ll9zZW1pTWFqb3JBeGlzIDw9IDAuMCB8fFxuICAgIGVsbGlwc2VHZW9tZXRyeS5fc2VtaU1pbm9yQXhpcyA8PSAwLjBcbiAgKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIGhlaWdodCA9IGVsbGlwc2VHZW9tZXRyeS5faGVpZ2h0O1xuICB2YXIgZXh0cnVkZWRIZWlnaHQgPSBlbGxpcHNlR2VvbWV0cnkuX2V4dHJ1ZGVkSGVpZ2h0O1xuICB2YXIgZXh0cnVkZSA9ICFDZXNpdW1NYXRoLmVxdWFsc0Vwc2lsb24oXG4gICAgaGVpZ2h0LFxuICAgIGV4dHJ1ZGVkSGVpZ2h0LFxuICAgIDAsXG4gICAgQ2VzaXVtTWF0aC5FUFNJTE9OMlxuICApO1xuXG4gIGVsbGlwc2VHZW9tZXRyeS5fY2VudGVyID0gZWxsaXBzZUdlb21ldHJ5Ll9lbGxpcHNvaWQuc2NhbGVUb0dlb2RldGljU3VyZmFjZShcbiAgICBlbGxpcHNlR2VvbWV0cnkuX2NlbnRlcixcbiAgICBlbGxpcHNlR2VvbWV0cnkuX2NlbnRlclxuICApO1xuICB2YXIgb3B0aW9ucyA9IHtcbiAgICBjZW50ZXI6IGVsbGlwc2VHZW9tZXRyeS5fY2VudGVyLFxuICAgIHNlbWlNYWpvckF4aXM6IGVsbGlwc2VHZW9tZXRyeS5fc2VtaU1ham9yQXhpcyxcbiAgICBzZW1pTWlub3JBeGlzOiBlbGxpcHNlR2VvbWV0cnkuX3NlbWlNaW5vckF4aXMsXG4gICAgZWxsaXBzb2lkOiBlbGxpcHNlR2VvbWV0cnkuX2VsbGlwc29pZCxcbiAgICByb3RhdGlvbjogZWxsaXBzZUdlb21ldHJ5Ll9yb3RhdGlvbixcbiAgICBoZWlnaHQ6IGhlaWdodCxcbiAgICBncmFudWxhcml0eTogZWxsaXBzZUdlb21ldHJ5Ll9ncmFudWxhcml0eSxcbiAgICBudW1iZXJPZlZlcnRpY2FsTGluZXM6IGVsbGlwc2VHZW9tZXRyeS5fbnVtYmVyT2ZWZXJ0aWNhbExpbmVzLFxuICB9O1xuICB2YXIgZ2VvbWV0cnk7XG4gIGlmIChleHRydWRlKSB7XG4gICAgb3B0aW9ucy5leHRydWRlZEhlaWdodCA9IGV4dHJ1ZGVkSGVpZ2h0O1xuICAgIG9wdGlvbnMub2Zmc2V0QXR0cmlidXRlID0gZWxsaXBzZUdlb21ldHJ5Ll9vZmZzZXRBdHRyaWJ1dGU7XG4gICAgZ2VvbWV0cnkgPSBjb21wdXRlRXh0cnVkZWRFbGxpcHNlKG9wdGlvbnMpO1xuICB9IGVsc2Uge1xuICAgIGdlb21ldHJ5ID0gY29tcHV0ZUVsbGlwc2Uob3B0aW9ucyk7XG5cbiAgICBpZiAoZGVmaW5lZChlbGxpcHNlR2VvbWV0cnkuX29mZnNldEF0dHJpYnV0ZSkpIHtcbiAgICAgIHZhciBsZW5ndGggPSBnZW9tZXRyeS5hdHRyaWJ1dGVzLnBvc2l0aW9uLnZhbHVlcy5sZW5ndGg7XG4gICAgICB2YXIgYXBwbHlPZmZzZXQgPSBuZXcgVWludDhBcnJheShsZW5ndGggLyAzKTtcbiAgICAgIHZhciBvZmZzZXRWYWx1ZSA9XG4gICAgICAgIGVsbGlwc2VHZW9tZXRyeS5fb2Zmc2V0QXR0cmlidXRlID09PSBHZW9tZXRyeU9mZnNldEF0dHJpYnV0ZS5OT05FXG4gICAgICAgICAgPyAwXG4gICAgICAgICAgOiAxO1xuICAgICAgYXJyYXlGaWxsKGFwcGx5T2Zmc2V0LCBvZmZzZXRWYWx1ZSk7XG4gICAgICBnZW9tZXRyeS5hdHRyaWJ1dGVzLmFwcGx5T2Zmc2V0ID0gbmV3IEdlb21ldHJ5QXR0cmlidXRlKHtcbiAgICAgICAgY29tcG9uZW50RGF0YXR5cGU6IENvbXBvbmVudERhdGF0eXBlLlVOU0lHTkVEX0JZVEUsXG4gICAgICAgIGNvbXBvbmVudHNQZXJBdHRyaWJ1dGU6IDEsXG4gICAgICAgIHZhbHVlczogYXBwbHlPZmZzZXQsXG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gbmV3IEdlb21ldHJ5KHtcbiAgICBhdHRyaWJ1dGVzOiBnZW9tZXRyeS5hdHRyaWJ1dGVzLFxuICAgIGluZGljZXM6IGdlb21ldHJ5LmluZGljZXMsXG4gICAgcHJpbWl0aXZlVHlwZTogUHJpbWl0aXZlVHlwZS5MSU5FUyxcbiAgICBib3VuZGluZ1NwaGVyZTogZ2VvbWV0cnkuYm91bmRpbmdTcGhlcmUsXG4gICAgb2Zmc2V0QXR0cmlidXRlOiBlbGxpcHNlR2VvbWV0cnkuX29mZnNldEF0dHJpYnV0ZSxcbiAgfSk7XG59O1xuZXhwb3J0IGRlZmF1bHQgRWxsaXBzZU91dGxpbmVHZW9tZXRyeTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///27337\n')},50491:function(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__){eval('/* harmony import */ var _Cartesian3_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(60216);\n/* harmony import */ var _Cartographic_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(51688);\n/* harmony import */ var _Check_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(66553);\n/* harmony import */ var _defaultValue_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(62200);\n/* harmony import */ var _defined_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(82982);\n/* harmony import */ var _DeveloperError_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(12572);\n/* harmony import */ var _Math_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(99417);\n/* harmony import */ var _scaleToGeodeticSurface_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(97);\n\n\n\n\n\n\n\n\n\nfunction initialize(ellipsoid, x, y, z) {\n  x = (0,_defaultValue_js__WEBPACK_IMPORTED_MODULE_3__/* ["default"] */ .Z)(x, 0.0);\n  y = (0,_defaultValue_js__WEBPACK_IMPORTED_MODULE_3__/* ["default"] */ .Z)(y, 0.0);\n  z = (0,_defaultValue_js__WEBPACK_IMPORTED_MODULE_3__/* ["default"] */ .Z)(z, 0.0);\n\n  //>>includeStart(\'debug\', pragmas.debug);\n  _Check_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"].typeOf.number.greaterThanOrEquals */ .Z.typeOf.number.greaterThanOrEquals("x", x, 0.0);\n  _Check_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"].typeOf.number.greaterThanOrEquals */ .Z.typeOf.number.greaterThanOrEquals("y", y, 0.0);\n  _Check_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"].typeOf.number.greaterThanOrEquals */ .Z.typeOf.number.greaterThanOrEquals("z", z, 0.0);\n  //>>includeEnd(\'debug\');\n\n  ellipsoid._radii = new _Cartesian3_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .Z(x, y, z);\n\n  ellipsoid._radiiSquared = new _Cartesian3_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .Z(x * x, y * y, z * z);\n\n  ellipsoid._radiiToTheFourth = new _Cartesian3_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .Z(\n    x * x * x * x,\n    y * y * y * y,\n    z * z * z * z\n  );\n\n  ellipsoid._oneOverRadii = new _Cartesian3_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .Z(\n    x === 0.0 ? 0.0 : 1.0 / x,\n    y === 0.0 ? 0.0 : 1.0 / y,\n    z === 0.0 ? 0.0 : 1.0 / z\n  );\n\n  ellipsoid._oneOverRadiiSquared = new _Cartesian3_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .Z(\n    x === 0.0 ? 0.0 : 1.0 / (x * x),\n    y === 0.0 ? 0.0 : 1.0 / (y * y),\n    z === 0.0 ? 0.0 : 1.0 / (z * z)\n  );\n\n  ellipsoid._minimumRadius = Math.min(x, y, z);\n\n  ellipsoid._maximumRadius = Math.max(x, y, z);\n\n  ellipsoid._centerToleranceSquared = _Math_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"].EPSILON1 */ .Z.EPSILON1;\n\n  if (ellipsoid._radiiSquared.z !== 0) {\n    ellipsoid._squaredXOverSquaredZ =\n      ellipsoid._radiiSquared.x / ellipsoid._radiiSquared.z;\n  }\n}\n\n/**\n * A quadratic surface defined in Cartesian coordinates by the equation\n * <code>(x / a)^2 + (y / b)^2 + (z / c)^2 = 1</code>.  Primarily used\n * by Cesium to represent the shape of planetary bodies.\n *\n * Rather than constructing this object directly, one of the provided\n * constants is normally used.\n * @alias Ellipsoid\n * @constructor\n *\n * @param {Number} [x=0] The radius in the x direction.\n * @param {Number} [y=0] The radius in the y direction.\n * @param {Number} [z=0] The radius in the z direction.\n *\n * @exception {DeveloperError} All radii components must be greater than or equal to zero.\n *\n * @see Ellipsoid.fromCartesian3\n * @see Ellipsoid.WGS84\n * @see Ellipsoid.UNIT_SPHERE\n */\nfunction Ellipsoid(x, y, z) {\n  this._radii = undefined;\n  this._radiiSquared = undefined;\n  this._radiiToTheFourth = undefined;\n  this._oneOverRadii = undefined;\n  this._oneOverRadiiSquared = undefined;\n  this._minimumRadius = undefined;\n  this._maximumRadius = undefined;\n  this._centerToleranceSquared = undefined;\n  this._squaredXOverSquaredZ = undefined;\n\n  initialize(this, x, y, z);\n}\n\nObject.defineProperties(Ellipsoid.prototype, {\n  /**\n   * Gets the radii of the ellipsoid.\n   * @memberof Ellipsoid.prototype\n   * @type {Cartesian3}\n   * @readonly\n   */\n  radii: {\n    get: function () {\n      return this._radii;\n    },\n  },\n  /**\n   * Gets the squared radii of the ellipsoid.\n   * @memberof Ellipsoid.prototype\n   * @type {Cartesian3}\n   * @readonly\n   */\n  radiiSquared: {\n    get: function () {\n      return this._radiiSquared;\n    },\n  },\n  /**\n   * Gets the radii of the ellipsoid raise to the fourth power.\n   * @memberof Ellipsoid.prototype\n   * @type {Cartesian3}\n   * @readonly\n   */\n  radiiToTheFourth: {\n    get: function () {\n      return this._radiiToTheFourth;\n    },\n  },\n  /**\n   * Gets one over the radii of the ellipsoid.\n   * @memberof Ellipsoid.prototype\n   * @type {Cartesian3}\n   * @readonly\n   */\n  oneOverRadii: {\n    get: function () {\n      return this._oneOverRadii;\n    },\n  },\n  /**\n   * Gets one over the squared radii of the ellipsoid.\n   * @memberof Ellipsoid.prototype\n   * @type {Cartesian3}\n   * @readonly\n   */\n  oneOverRadiiSquared: {\n    get: function () {\n      return this._oneOverRadiiSquared;\n    },\n  },\n  /**\n   * Gets the minimum radius of the ellipsoid.\n   * @memberof Ellipsoid.prototype\n   * @type {Number}\n   * @readonly\n   */\n  minimumRadius: {\n    get: function () {\n      return this._minimumRadius;\n    },\n  },\n  /**\n   * Gets the maximum radius of the ellipsoid.\n   * @memberof Ellipsoid.prototype\n   * @type {Number}\n   * @readonly\n   */\n  maximumRadius: {\n    get: function () {\n      return this._maximumRadius;\n    },\n  },\n});\n\n/**\n * Duplicates an Ellipsoid instance.\n *\n * @param {Ellipsoid} ellipsoid The ellipsoid to duplicate.\n * @param {Ellipsoid} [result] The object onto which to store the result, or undefined if a new\n *                    instance should be created.\n * @returns {Ellipsoid} The cloned Ellipsoid. (Returns undefined if ellipsoid is undefined)\n */\nEllipsoid.clone = function (ellipsoid, result) {\n  if (!(0,_defined_js__WEBPACK_IMPORTED_MODULE_7__/* ["default"] */ .Z)(ellipsoid)) {\n    return undefined;\n  }\n  var radii = ellipsoid._radii;\n\n  if (!(0,_defined_js__WEBPACK_IMPORTED_MODULE_7__/* ["default"] */ .Z)(result)) {\n    return new Ellipsoid(radii.x, radii.y, radii.z);\n  }\n\n  _Cartesian3_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].clone */ .Z.clone(radii, result._radii);\n  _Cartesian3_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].clone */ .Z.clone(ellipsoid._radiiSquared, result._radiiSquared);\n  _Cartesian3_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].clone */ .Z.clone(ellipsoid._radiiToTheFourth, result._radiiToTheFourth);\n  _Cartesian3_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].clone */ .Z.clone(ellipsoid._oneOverRadii, result._oneOverRadii);\n  _Cartesian3_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].clone */ .Z.clone(ellipsoid._oneOverRadiiSquared, result._oneOverRadiiSquared);\n  result._minimumRadius = ellipsoid._minimumRadius;\n  result._maximumRadius = ellipsoid._maximumRadius;\n  result._centerToleranceSquared = ellipsoid._centerToleranceSquared;\n\n  return result;\n};\n\n/**\n * Computes an Ellipsoid from a Cartesian specifying the radii in x, y, and z directions.\n *\n * @param {Cartesian3} [cartesian=Cartesian3.ZERO] The ellipsoid\'s radius in the x, y, and z directions.\n * @param {Ellipsoid} [result] The object onto which to store the result, or undefined if a new\n *                    instance should be created.\n * @returns {Ellipsoid} A new Ellipsoid instance.\n *\n * @exception {DeveloperError} All radii components must be greater than or equal to zero.\n *\n * @see Ellipsoid.WGS84\n * @see Ellipsoid.UNIT_SPHERE\n */\nEllipsoid.fromCartesian3 = function (cartesian, result) {\n  if (!(0,_defined_js__WEBPACK_IMPORTED_MODULE_7__/* ["default"] */ .Z)(result)) {\n    result = new Ellipsoid();\n  }\n\n  if (!(0,_defined_js__WEBPACK_IMPORTED_MODULE_7__/* ["default"] */ .Z)(cartesian)) {\n    return result;\n  }\n\n  initialize(result, cartesian.x, cartesian.y, cartesian.z);\n  return result;\n};\n\n/**\n * An Ellipsoid instance initialized to the WGS84 standard.\n *\n * @type {Ellipsoid}\n * @constant\n */\nEllipsoid.WGS84 = Object.freeze(\n  new Ellipsoid(6378137.0, 6378137.0, 6356752.3142451793)\n);\n\n/**\n * An Ellipsoid instance initialized to radii of (1.0, 1.0, 1.0).\n *\n * @type {Ellipsoid}\n * @constant\n */\nEllipsoid.UNIT_SPHERE = Object.freeze(new Ellipsoid(1.0, 1.0, 1.0));\n\n/**\n * An Ellipsoid instance initialized to a sphere with the lunar radius.\n *\n * @type {Ellipsoid}\n * @constant\n */\nEllipsoid.MOON = Object.freeze(\n  new Ellipsoid(\n    _Math_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"].LUNAR_RADIUS */ .Z.LUNAR_RADIUS,\n    _Math_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"].LUNAR_RADIUS */ .Z.LUNAR_RADIUS,\n    _Math_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"].LUNAR_RADIUS */ .Z.LUNAR_RADIUS\n  )\n);\n\n/**\n * Duplicates an Ellipsoid instance.\n *\n * @param {Ellipsoid} [result] The object onto which to store the result, or undefined if a new\n *                    instance should be created.\n * @returns {Ellipsoid} The cloned Ellipsoid.\n */\nEllipsoid.prototype.clone = function (result) {\n  return Ellipsoid.clone(this, result);\n};\n\n/**\n * The number of elements used to pack the object into an array.\n * @type {Number}\n */\nEllipsoid.packedLength = _Cartesian3_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].packedLength */ .Z.packedLength;\n\n/**\n * Stores the provided instance into the provided array.\n *\n * @param {Ellipsoid} value The value to pack.\n * @param {Number[]} array The array to pack into.\n * @param {Number} [startingIndex=0] The index into the array at which to start packing the elements.\n *\n * @returns {Number[]} The array that was packed into\n */\nEllipsoid.pack = function (value, array, startingIndex) {\n  //>>includeStart(\'debug\', pragmas.debug);\n  _Check_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"].typeOf.object */ .Z.typeOf.object("value", value);\n  _Check_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"].defined */ .Z.defined("array", array);\n  //>>includeEnd(\'debug\');\n\n  startingIndex = (0,_defaultValue_js__WEBPACK_IMPORTED_MODULE_3__/* ["default"] */ .Z)(startingIndex, 0);\n\n  _Cartesian3_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].pack */ .Z.pack(value._radii, array, startingIndex);\n\n  return array;\n};\n\n/**\n * Retrieves an instance from a packed array.\n *\n * @param {Number[]} array The packed array.\n * @param {Number} [startingIndex=0] The starting index of the element to be unpacked.\n * @param {Ellipsoid} [result] The object into which to store the result.\n * @returns {Ellipsoid} The modified result parameter or a new Ellipsoid instance if one was not provided.\n */\nEllipsoid.unpack = function (array, startingIndex, result) {\n  //>>includeStart(\'debug\', pragmas.debug);\n  _Check_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"].defined */ .Z.defined("array", array);\n  //>>includeEnd(\'debug\');\n\n  startingIndex = (0,_defaultValue_js__WEBPACK_IMPORTED_MODULE_3__/* ["default"] */ .Z)(startingIndex, 0);\n\n  var radii = _Cartesian3_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].unpack */ .Z.unpack(array, startingIndex);\n  return Ellipsoid.fromCartesian3(radii, result);\n};\n\n/**\n * Computes the unit vector directed from the center of this ellipsoid toward the provided Cartesian position.\n * @function\n *\n * @param {Cartesian3} cartesian The Cartesian for which to to determine the geocentric normal.\n * @param {Cartesian3} [result] The object onto which to store the result.\n * @returns {Cartesian3} The modified result parameter or a new Cartesian3 instance if none was provided.\n */\nEllipsoid.prototype.geocentricSurfaceNormal = _Cartesian3_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].normalize */ .Z.normalize;\n\n/**\n * Computes the normal of the plane tangent to the surface of the ellipsoid at the provided position.\n *\n * @param {Cartographic} cartographic The cartographic position for which to to determine the geodetic normal.\n * @param {Cartesian3} [result] The object onto which to store the result.\n * @returns {Cartesian3} The modified result parameter or a new Cartesian3 instance if none was provided.\n */\nEllipsoid.prototype.geodeticSurfaceNormalCartographic = function (\n  cartographic,\n  result\n) {\n  //>>includeStart(\'debug\', pragmas.debug);\n  _Check_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"].typeOf.object */ .Z.typeOf.object("cartographic", cartographic);\n  //>>includeEnd(\'debug\');\n\n  var longitude = cartographic.longitude;\n  var latitude = cartographic.latitude;\n  var cosLatitude = Math.cos(latitude);\n\n  var x = cosLatitude * Math.cos(longitude);\n  var y = cosLatitude * Math.sin(longitude);\n  var z = Math.sin(latitude);\n\n  if (!(0,_defined_js__WEBPACK_IMPORTED_MODULE_7__/* ["default"] */ .Z)(result)) {\n    result = new _Cartesian3_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .Z();\n  }\n  result.x = x;\n  result.y = y;\n  result.z = z;\n  return _Cartesian3_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].normalize */ .Z.normalize(result, result);\n};\n\n/**\n * Computes the normal of the plane tangent to the surface of the ellipsoid at the provided position.\n *\n * @param {Cartesian3} cartesian The Cartesian position for which to to determine the surface normal.\n * @param {Cartesian3} [result] The object onto which to store the result.\n * @returns {Cartesian3} The modified result parameter or a new Cartesian3 instance if none was provided, or undefined if a normal cannot be found.\n */\nEllipsoid.prototype.geodeticSurfaceNormal = function (cartesian, result) {\n  if (\n    _Cartesian3_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].equalsEpsilon */ .Z.equalsEpsilon(cartesian, _Cartesian3_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].ZERO */ .Z.ZERO, _Math_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"].EPSILON14 */ .Z.EPSILON14)\n  ) {\n    return undefined;\n  }\n  if (!(0,_defined_js__WEBPACK_IMPORTED_MODULE_7__/* ["default"] */ .Z)(result)) {\n    result = new _Cartesian3_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .Z();\n  }\n  result = _Cartesian3_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].multiplyComponents */ .Z.multiplyComponents(\n    cartesian,\n    this._oneOverRadiiSquared,\n    result\n  );\n  return _Cartesian3_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].normalize */ .Z.normalize(result, result);\n};\n\nvar cartographicToCartesianNormal = new _Cartesian3_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .Z();\nvar cartographicToCartesianK = new _Cartesian3_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .Z();\n\n/**\n * Converts the provided cartographic to Cartesian representation.\n *\n * @param {Cartographic} cartographic The cartographic position.\n * @param {Cartesian3} [result] The object onto which to store the result.\n * @returns {Cartesian3} The modified result parameter or a new Cartesian3 instance if none was provided.\n *\n * @example\n * //Create a Cartographic and determine it\'s Cartesian representation on a WGS84 ellipsoid.\n * var position = new Cesium.Cartographic(Cesium.Math.toRadians(21), Cesium.Math.toRadians(78), 5000);\n * var cartesianPosition = Cesium.Ellipsoid.WGS84.cartographicToCartesian(position);\n */\nEllipsoid.prototype.cartographicToCartesian = function (cartographic, result) {\n  //`cartographic is required` is thrown from geodeticSurfaceNormalCartographic.\n  var n = cartographicToCartesianNormal;\n  var k = cartographicToCartesianK;\n  this.geodeticSurfaceNormalCartographic(cartographic, n);\n  _Cartesian3_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].multiplyComponents */ .Z.multiplyComponents(this._radiiSquared, n, k);\n  var gamma = Math.sqrt(_Cartesian3_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].dot */ .Z.dot(n, k));\n  _Cartesian3_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].divideByScalar */ .Z.divideByScalar(k, gamma, k);\n  _Cartesian3_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].multiplyByScalar */ .Z.multiplyByScalar(n, cartographic.height, n);\n\n  if (!(0,_defined_js__WEBPACK_IMPORTED_MODULE_7__/* ["default"] */ .Z)(result)) {\n    result = new _Cartesian3_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .Z();\n  }\n  return _Cartesian3_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].add */ .Z.add(k, n, result);\n};\n\n/**\n * Converts the provided array of cartographics to an array of Cartesians.\n *\n * @param {Cartographic[]} cartographics An array of cartographic positions.\n * @param {Cartesian3[]} [result] The object onto which to store the result.\n * @returns {Cartesian3[]} The modified result parameter or a new Array instance if none was provided.\n *\n * @example\n * //Convert an array of Cartographics and determine their Cartesian representation on a WGS84 ellipsoid.\n * var positions = [new Cesium.Cartographic(Cesium.Math.toRadians(21), Cesium.Math.toRadians(78), 0),\n *                  new Cesium.Cartographic(Cesium.Math.toRadians(21.321), Cesium.Math.toRadians(78.123), 100),\n *                  new Cesium.Cartographic(Cesium.Math.toRadians(21.645), Cesium.Math.toRadians(78.456), 250)];\n * var cartesianPositions = Cesium.Ellipsoid.WGS84.cartographicArrayToCartesianArray(positions);\n */\nEllipsoid.prototype.cartographicArrayToCartesianArray = function (\n  cartographics,\n  result\n) {\n  //>>includeStart(\'debug\', pragmas.debug);\n  _Check_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"].defined */ .Z.defined("cartographics", cartographics);\n  //>>includeEnd(\'debug\')\n\n  var length = cartographics.length;\n  if (!(0,_defined_js__WEBPACK_IMPORTED_MODULE_7__/* ["default"] */ .Z)(result)) {\n    result = new Array(length);\n  } else {\n    result.length = length;\n  }\n  for (var i = 0; i < length; i++) {\n    result[i] = this.cartographicToCartesian(cartographics[i], result[i]);\n  }\n  return result;\n};\n\nvar cartesianToCartographicN = new _Cartesian3_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .Z();\nvar cartesianToCartographicP = new _Cartesian3_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .Z();\nvar cartesianToCartographicH = new _Cartesian3_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .Z();\n\n/**\n * Converts the provided cartesian to cartographic representation.\n * The cartesian is undefined at the center of the ellipsoid.\n *\n * @param {Cartesian3} cartesian The Cartesian position to convert to cartographic representation.\n * @param {Cartographic} [result] The object onto which to store the result.\n * @returns {Cartographic} The modified result parameter, new Cartographic instance if none was provided, or undefined if the cartesian is at the center of the ellipsoid.\n *\n * @example\n * //Create a Cartesian and determine it\'s Cartographic representation on a WGS84 ellipsoid.\n * var position = new Cesium.Cartesian3(17832.12, 83234.52, 952313.73);\n * var cartographicPosition = Cesium.Ellipsoid.WGS84.cartesianToCartographic(position);\n */\nEllipsoid.prototype.cartesianToCartographic = function (cartesian, result) {\n  //`cartesian is required.` is thrown from scaleToGeodeticSurface\n  var p = this.scaleToGeodeticSurface(cartesian, cartesianToCartographicP);\n\n  if (!(0,_defined_js__WEBPACK_IMPORTED_MODULE_7__/* ["default"] */ .Z)(p)) {\n    return undefined;\n  }\n\n  var n = this.geodeticSurfaceNormal(p, cartesianToCartographicN);\n  var h = _Cartesian3_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].subtract */ .Z.subtract(cartesian, p, cartesianToCartographicH);\n\n  var longitude = Math.atan2(n.y, n.x);\n  var latitude = Math.asin(n.z);\n  var height =\n    _Math_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"].sign */ .Z.sign(_Cartesian3_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].dot */ .Z.dot(h, cartesian)) * _Cartesian3_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].magnitude */ .Z.magnitude(h);\n\n  if (!(0,_defined_js__WEBPACK_IMPORTED_MODULE_7__/* ["default"] */ .Z)(result)) {\n    return new _Cartographic_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .Z(longitude, latitude, height);\n  }\n  result.longitude = longitude;\n  result.latitude = latitude;\n  result.height = height;\n  return result;\n};\n\n/**\n * Converts the provided array of cartesians to an array of cartographics.\n *\n * @param {Cartesian3[]} cartesians An array of Cartesian positions.\n * @param {Cartographic[]} [result] The object onto which to store the result.\n * @returns {Cartographic[]} The modified result parameter or a new Array instance if none was provided.\n *\n * @example\n * //Create an array of Cartesians and determine their Cartographic representation on a WGS84 ellipsoid.\n * var positions = [new Cesium.Cartesian3(17832.12, 83234.52, 952313.73),\n *                  new Cesium.Cartesian3(17832.13, 83234.53, 952313.73),\n *                  new Cesium.Cartesian3(17832.14, 83234.54, 952313.73)]\n * var cartographicPositions = Cesium.Ellipsoid.WGS84.cartesianArrayToCartographicArray(positions);\n */\nEllipsoid.prototype.cartesianArrayToCartographicArray = function (\n  cartesians,\n  result\n) {\n  //>>includeStart(\'debug\', pragmas.debug);\n  _Check_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"].defined */ .Z.defined("cartesians", cartesians);\n  //>>includeEnd(\'debug\');\n\n  var length = cartesians.length;\n  if (!(0,_defined_js__WEBPACK_IMPORTED_MODULE_7__/* ["default"] */ .Z)(result)) {\n    result = new Array(length);\n  } else {\n    result.length = length;\n  }\n  for (var i = 0; i < length; ++i) {\n    result[i] = this.cartesianToCartographic(cartesians[i], result[i]);\n  }\n  return result;\n};\n\n/**\n * Scales the provided Cartesian position along the geodetic surface normal\n * so that it is on the surface of this ellipsoid.  If the position is\n * at the center of the ellipsoid, this function returns undefined.\n *\n * @param {Cartesian3} cartesian The Cartesian position to scale.\n * @param {Cartesian3} [result] The object onto which to store the result.\n * @returns {Cartesian3} The modified result parameter, a new Cartesian3 instance if none was provided, or undefined if the position is at the center.\n */\nEllipsoid.prototype.scaleToGeodeticSurface = function (cartesian, result) {\n  return (0,_scaleToGeodeticSurface_js__WEBPACK_IMPORTED_MODULE_6__/* ["default"] */ .Z)(\n    cartesian,\n    this._oneOverRadii,\n    this._oneOverRadiiSquared,\n    this._centerToleranceSquared,\n    result\n  );\n};\n\n/**\n * Scales the provided Cartesian position along the geocentric surface normal\n * so that it is on the surface of this ellipsoid.\n *\n * @param {Cartesian3} cartesian The Cartesian position to scale.\n * @param {Cartesian3} [result] The object onto which to store the result.\n * @returns {Cartesian3} The modified result parameter or a new Cartesian3 instance if none was provided.\n */\nEllipsoid.prototype.scaleToGeocentricSurface = function (cartesian, result) {\n  //>>includeStart(\'debug\', pragmas.debug);\n  _Check_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"].typeOf.object */ .Z.typeOf.object("cartesian", cartesian);\n  //>>includeEnd(\'debug\');\n\n  if (!(0,_defined_js__WEBPACK_IMPORTED_MODULE_7__/* ["default"] */ .Z)(result)) {\n    result = new _Cartesian3_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .Z();\n  }\n\n  var positionX = cartesian.x;\n  var positionY = cartesian.y;\n  var positionZ = cartesian.z;\n  var oneOverRadiiSquared = this._oneOverRadiiSquared;\n\n  var beta =\n    1.0 /\n    Math.sqrt(\n      positionX * positionX * oneOverRadiiSquared.x +\n        positionY * positionY * oneOverRadiiSquared.y +\n        positionZ * positionZ * oneOverRadiiSquared.z\n    );\n\n  return _Cartesian3_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].multiplyByScalar */ .Z.multiplyByScalar(cartesian, beta, result);\n};\n\n/**\n * Transforms a Cartesian X, Y, Z position to the ellipsoid-scaled space by multiplying\n * its components by the result of {@link Ellipsoid#oneOverRadii}.\n *\n * @param {Cartesian3} position The position to transform.\n * @param {Cartesian3} [result] The position to which to copy the result, or undefined to create and\n *        return a new instance.\n * @returns {Cartesian3} The position expressed in the scaled space.  The returned instance is the\n *          one passed as the result parameter if it is not undefined, or a new instance of it is.\n */\nEllipsoid.prototype.transformPositionToScaledSpace = function (\n  position,\n  result\n) {\n  if (!(0,_defined_js__WEBPACK_IMPORTED_MODULE_7__/* ["default"] */ .Z)(result)) {\n    result = new _Cartesian3_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .Z();\n  }\n\n  return _Cartesian3_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].multiplyComponents */ .Z.multiplyComponents(position, this._oneOverRadii, result);\n};\n\n/**\n * Transforms a Cartesian X, Y, Z position from the ellipsoid-scaled space by multiplying\n * its components by the result of {@link Ellipsoid#radii}.\n *\n * @param {Cartesian3} position The position to transform.\n * @param {Cartesian3} [result] The position to which to copy the result, or undefined to create and\n *        return a new instance.\n * @returns {Cartesian3} The position expressed in the unscaled space.  The returned instance is the\n *          one passed as the result parameter if it is not undefined, or a new instance of it is.\n */\nEllipsoid.prototype.transformPositionFromScaledSpace = function (\n  position,\n  result\n) {\n  if (!(0,_defined_js__WEBPACK_IMPORTED_MODULE_7__/* ["default"] */ .Z)(result)) {\n    result = new _Cartesian3_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .Z();\n  }\n\n  return _Cartesian3_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].multiplyComponents */ .Z.multiplyComponents(position, this._radii, result);\n};\n\n/**\n * Compares this Ellipsoid against the provided Ellipsoid componentwise and returns\n * <code>true</code> if they are equal, <code>false</code> otherwise.\n *\n * @param {Ellipsoid} [right] The other Ellipsoid.\n * @returns {Boolean} <code>true</code> if they are equal, <code>false</code> otherwise.\n */\nEllipsoid.prototype.equals = function (right) {\n  return (\n    this === right ||\n    ((0,_defined_js__WEBPACK_IMPORTED_MODULE_7__/* ["default"] */ .Z)(right) && _Cartesian3_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].equals */ .Z.equals(this._radii, right._radii))\n  );\n};\n\n/**\n * Creates a string representing this Ellipsoid in the format \'(radii.x, radii.y, radii.z)\'.\n *\n * @returns {String} A string representing this ellipsoid in the format \'(radii.x, radii.y, radii.z)\'.\n */\nEllipsoid.prototype.toString = function () {\n  return this._radii.toString();\n};\n\n/**\n * Computes a point which is the intersection of the surface normal with the z-axis.\n *\n * @param {Cartesian3} position the position. must be on the surface of the ellipsoid.\n * @param {Number} [buffer = 0.0] A buffer to subtract from the ellipsoid size when checking if the point is inside the ellipsoid.\n *                                In earth case, with common earth datums, there is no need for this buffer since the intersection point is always (relatively) very close to the center.\n *                                In WGS84 datum, intersection point is at max z = +-42841.31151331382 (0.673% of z-axis).\n *                                Intersection point could be outside the ellipsoid if the ratio of MajorAxis / AxisOfRotation is bigger than the square root of 2\n * @param {Cartesian3} [result] The cartesian to which to copy the result, or undefined to create and\n *        return a new instance.\n * @returns {Cartesian3 | undefined} the intersection point if it\'s inside the ellipsoid, undefined otherwise\n *\n * @exception {DeveloperError} position is required.\n * @exception {DeveloperError} Ellipsoid must be an ellipsoid of revolution (radii.x == radii.y).\n * @exception {DeveloperError} Ellipsoid.radii.z must be greater than 0.\n */\nEllipsoid.prototype.getSurfaceNormalIntersectionWithZAxis = function (\n  position,\n  buffer,\n  result\n) {\n  //>>includeStart(\'debug\', pragmas.debug);\n  _Check_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"].typeOf.object */ .Z.typeOf.object("position", position);\n\n  if (\n    !_Math_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"].equalsEpsilon */ .Z.equalsEpsilon(\n      this._radii.x,\n      this._radii.y,\n      _Math_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"].EPSILON15 */ .Z.EPSILON15\n    )\n  ) {\n    throw new _DeveloperError_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .Z(\n      "Ellipsoid must be an ellipsoid of revolution (radii.x == radii.y)"\n    );\n  }\n\n  _Check_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"].typeOf.number.greaterThan */ .Z.typeOf.number.greaterThan("Ellipsoid.radii.z", this._radii.z, 0);\n  //>>includeEnd(\'debug\');\n\n  buffer = (0,_defaultValue_js__WEBPACK_IMPORTED_MODULE_3__/* ["default"] */ .Z)(buffer, 0.0);\n\n  var squaredXOverSquaredZ = this._squaredXOverSquaredZ;\n\n  if (!(0,_defined_js__WEBPACK_IMPORTED_MODULE_7__/* ["default"] */ .Z)(result)) {\n    result = new _Cartesian3_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .Z();\n  }\n\n  result.x = 0.0;\n  result.y = 0.0;\n  result.z = position.z * (1 - squaredXOverSquaredZ);\n\n  if (Math.abs(result.z) >= this._radii.z - buffer) {\n    return undefined;\n  }\n\n  return result;\n};\n\nvar abscissas = [\n  0.14887433898163,\n  0.43339539412925,\n  0.67940956829902,\n  0.86506336668898,\n  0.97390652851717,\n  0.0,\n];\nvar weights = [\n  0.29552422471475,\n  0.26926671930999,\n  0.21908636251598,\n  0.14945134915058,\n  0.066671344308684,\n  0.0,\n];\n\n/**\n * Compute the 10th order Gauss-Legendre Quadrature of the given definite integral.\n *\n * @param {Number} a The lower bound for the integration.\n * @param {Number} b The upper bound for the integration.\n * @param {Ellipsoid~RealValuedScalarFunction} func The function to integrate.\n * @returns {Number} The value of the integral of the given function over the given domain.\n *\n * @private\n */\nfunction gaussLegendreQuadrature(a, b, func) {\n  //>>includeStart(\'debug\', pragmas.debug);\n  _Check_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"].typeOf.number */ .Z.typeOf.number("a", a);\n  _Check_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"].typeOf.number */ .Z.typeOf.number("b", b);\n  _Check_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"].typeOf.func */ .Z.typeOf.func("func", func);\n  //>>includeEnd(\'debug\');\n\n  // The range is half of the normal range since the five weights add to one (ten weights add to two).\n  // The values of the abscissas are multiplied by two to account for this.\n  var xMean = 0.5 * (b + a);\n  var xRange = 0.5 * (b - a);\n\n  var sum = 0.0;\n  for (var i = 0; i < 5; i++) {\n    var dx = xRange * abscissas[i];\n    sum += weights[i] * (func(xMean + dx) + func(xMean - dx));\n  }\n\n  // Scale the sum to the range of x.\n  sum *= xRange;\n  return sum;\n}\n\n/**\n * A real valued scalar function.\n * @callback Ellipsoid~RealValuedScalarFunction\n *\n * @param {Number} x The value used to evaluate the function.\n * @returns {Number} The value of the function at x.\n *\n * @private\n */\n\n/**\n * Computes an approximation of the surface area of a rectangle on the surface of an ellipsoid using\n * Gauss-Legendre 10th order quadrature.\n *\n * @param {Rectangle} rectangle The rectangle used for computing the surface area.\n * @returns {Number} The approximate area of the rectangle on the surface of this ellipsoid.\n */\nEllipsoid.prototype.surfaceArea = function (rectangle) {\n  //>>includeStart(\'debug\', pragmas.debug);\n  _Check_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"].typeOf.object */ .Z.typeOf.object("rectangle", rectangle);\n  //>>includeEnd(\'debug\');\n  var minLongitude = rectangle.west;\n  var maxLongitude = rectangle.east;\n  var minLatitude = rectangle.south;\n  var maxLatitude = rectangle.north;\n\n  while (maxLongitude < minLongitude) {\n    maxLongitude += _Math_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"].TWO_PI */ .Z.TWO_PI;\n  }\n\n  var radiiSquared = this._radiiSquared;\n  var a2 = radiiSquared.x;\n  var b2 = radiiSquared.y;\n  var c2 = radiiSquared.z;\n  var a2b2 = a2 * b2;\n  return gaussLegendreQuadrature(minLatitude, maxLatitude, function (lat) {\n    // phi represents the angle measured from the north pole\n    // sin(phi) = sin(pi / 2 - lat) = cos(lat), cos(phi) is similar\n    var sinPhi = Math.cos(lat);\n    var cosPhi = Math.sin(lat);\n    return (\n      Math.cos(lat) *\n      gaussLegendreQuadrature(minLongitude, maxLongitude, function (lon) {\n        var cosTheta = Math.cos(lon);\n        var sinTheta = Math.sin(lon);\n        return Math.sqrt(\n          a2b2 * cosPhi * cosPhi +\n            c2 *\n              (b2 * cosTheta * cosTheta + a2 * sinTheta * sinTheta) *\n              sinPhi *\n              sinPhi\n        );\n      })\n    );\n  });\n};\n\n/* harmony default export */ __webpack_exports__["Z"] = (Ellipsoid);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QUFDbkIsV0FBVyxvQ0FBb0M7QUFDL0MsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFLHNGQUFtQjtBQUNyQixFQUFFLHNGQUFtQjtBQUNyQixFQUFFLGtGQUFpQjtBQUNuQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGtCQUFrQixPQUFPO0FBQ3pCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxXQUFXO0FBQ3RCLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQSxFQUFFLHNGQUFtQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esb0JBQW9CLHVFQUFpQjtBQUNyQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLEdBQUc7QUFDSDs7QUFFQSx5REFBZSxTQUFTLEVBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly92dWUzLXdlYnBhY2s1Ly4vbm9kZV9tb2R1bGVzL2Nlc2l1bS9Tb3VyY2UvQ29yZS9FbGxpcHNvaWQuanM/YzI3MiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgQ2FydGVzaWFuMyBmcm9tIFwiLi9DYXJ0ZXNpYW4zLmpzXCI7XG5pbXBvcnQgQ2FydG9ncmFwaGljIGZyb20gXCIuL0NhcnRvZ3JhcGhpYy5qc1wiO1xuaW1wb3J0IENoZWNrIGZyb20gXCIuL0NoZWNrLmpzXCI7XG5pbXBvcnQgZGVmYXVsdFZhbHVlIGZyb20gXCIuL2RlZmF1bHRWYWx1ZS5qc1wiO1xuaW1wb3J0IGRlZmluZWQgZnJvbSBcIi4vZGVmaW5lZC5qc1wiO1xuaW1wb3J0IERldmVsb3BlckVycm9yIGZyb20gXCIuL0RldmVsb3BlckVycm9yLmpzXCI7XG5pbXBvcnQgQ2VzaXVtTWF0aCBmcm9tIFwiLi9NYXRoLmpzXCI7XG5pbXBvcnQgc2NhbGVUb0dlb2RldGljU3VyZmFjZSBmcm9tIFwiLi9zY2FsZVRvR2VvZGV0aWNTdXJmYWNlLmpzXCI7XG5cbmZ1bmN0aW9uIGluaXRpYWxpemUoZWxsaXBzb2lkLCB4LCB5LCB6KSB7XG4gIHggPSBkZWZhdWx0VmFsdWUoeCwgMC4wKTtcbiAgeSA9IGRlZmF1bHRWYWx1ZSh5LCAwLjApO1xuICB6ID0gZGVmYXVsdFZhbHVlKHosIDAuMCk7XG5cbiAgLy8+PmluY2x1ZGVTdGFydCgnZGVidWcnLCBwcmFnbWFzLmRlYnVnKTtcbiAgQ2hlY2sudHlwZU9mLm51bWJlci5ncmVhdGVyVGhhbk9yRXF1YWxzKFwieFwiLCB4LCAwLjApO1xuICBDaGVjay50eXBlT2YubnVtYmVyLmdyZWF0ZXJUaGFuT3JFcXVhbHMoXCJ5XCIsIHksIDAuMCk7XG4gIENoZWNrLnR5cGVPZi5udW1iZXIuZ3JlYXRlclRoYW5PckVxdWFscyhcInpcIiwgeiwgMC4wKTtcbiAgLy8+PmluY2x1ZGVFbmQoJ2RlYnVnJyk7XG5cbiAgZWxsaXBzb2lkLl9yYWRpaSA9IG5ldyBDYXJ0ZXNpYW4zKHgsIHksIHopO1xuXG4gIGVsbGlwc29pZC5fcmFkaWlTcXVhcmVkID0gbmV3IENhcnRlc2lhbjMoeCAqIHgsIHkgKiB5LCB6ICogeik7XG5cbiAgZWxsaXBzb2lkLl9yYWRpaVRvVGhlRm91cnRoID0gbmV3IENhcnRlc2lhbjMoXG4gICAgeCAqIHggKiB4ICogeCxcbiAgICB5ICogeSAqIHkgKiB5LFxuICAgIHogKiB6ICogeiAqIHpcbiAgKTtcblxuICBlbGxpcHNvaWQuX29uZU92ZXJSYWRpaSA9IG5ldyBDYXJ0ZXNpYW4zKFxuICAgIHggPT09IDAuMCA/IDAuMCA6IDEuMCAvIHgsXG4gICAgeSA9PT0gMC4wID8gMC4wIDogMS4wIC8geSxcbiAgICB6ID09PSAwLjAgPyAwLjAgOiAxLjAgLyB6XG4gICk7XG5cbiAgZWxsaXBzb2lkLl9vbmVPdmVyUmFkaWlTcXVhcmVkID0gbmV3IENhcnRlc2lhbjMoXG4gICAgeCA9PT0gMC4wID8gMC4wIDogMS4wIC8gKHggKiB4KSxcbiAgICB5ID09PSAwLjAgPyAwLjAgOiAxLjAgLyAoeSAqIHkpLFxuICAgIHogPT09IDAuMCA/IDAuMCA6IDEuMCAvICh6ICogeilcbiAgKTtcblxuICBlbGxpcHNvaWQuX21pbmltdW1SYWRpdXMgPSBNYXRoLm1pbih4LCB5LCB6KTtcblxuICBlbGxpcHNvaWQuX21heGltdW1SYWRpdXMgPSBNYXRoLm1heCh4LCB5LCB6KTtcblxuICBlbGxpcHNvaWQuX2NlbnRlclRvbGVyYW5jZVNxdWFyZWQgPSBDZXNpdW1NYXRoLkVQU0lMT04xO1xuXG4gIGlmIChlbGxpcHNvaWQuX3JhZGlpU3F1YXJlZC56ICE9PSAwKSB7XG4gICAgZWxsaXBzb2lkLl9zcXVhcmVkWE92ZXJTcXVhcmVkWiA9XG4gICAgICBlbGxpcHNvaWQuX3JhZGlpU3F1YXJlZC54IC8gZWxsaXBzb2lkLl9yYWRpaVNxdWFyZWQuejtcbiAgfVxufVxuXG4vKipcbiAqIEEgcXVhZHJhdGljIHN1cmZhY2UgZGVmaW5lZCBpbiBDYXJ0ZXNpYW4gY29vcmRpbmF0ZXMgYnkgdGhlIGVxdWF0aW9uXG4gKiA8Y29kZT4oeCAvIGEpXjIgKyAoeSAvIGIpXjIgKyAoeiAvIGMpXjIgPSAxPC9jb2RlPi4gIFByaW1hcmlseSB1c2VkXG4gKiBieSBDZXNpdW0gdG8gcmVwcmVzZW50IHRoZSBzaGFwZSBvZiBwbGFuZXRhcnkgYm9kaWVzLlxuICpcbiAqIFJhdGhlciB0aGFuIGNvbnN0cnVjdGluZyB0aGlzIG9iamVjdCBkaXJlY3RseSwgb25lIG9mIHRoZSBwcm92aWRlZFxuICogY29uc3RhbnRzIGlzIG5vcm1hbGx5IHVzZWQuXG4gKiBAYWxpYXMgRWxsaXBzb2lkXG4gKiBAY29uc3RydWN0b3JcbiAqXG4gKiBAcGFyYW0ge051bWJlcn0gW3g9MF0gVGhlIHJhZGl1cyBpbiB0aGUgeCBkaXJlY3Rpb24uXG4gKiBAcGFyYW0ge051bWJlcn0gW3k9MF0gVGhlIHJhZGl1cyBpbiB0aGUgeSBkaXJlY3Rpb24uXG4gKiBAcGFyYW0ge051bWJlcn0gW3o9MF0gVGhlIHJhZGl1cyBpbiB0aGUgeiBkaXJlY3Rpb24uXG4gKlxuICogQGV4Y2VwdGlvbiB7RGV2ZWxvcGVyRXJyb3J9IEFsbCByYWRpaSBjb21wb25lbnRzIG11c3QgYmUgZ3JlYXRlciB0aGFuIG9yIGVxdWFsIHRvIHplcm8uXG4gKlxuICogQHNlZSBFbGxpcHNvaWQuZnJvbUNhcnRlc2lhbjNcbiAqIEBzZWUgRWxsaXBzb2lkLldHUzg0XG4gKiBAc2VlIEVsbGlwc29pZC5VTklUX1NQSEVSRVxuICovXG5mdW5jdGlvbiBFbGxpcHNvaWQoeCwgeSwgeikge1xuICB0aGlzLl9yYWRpaSA9IHVuZGVmaW5lZDtcbiAgdGhpcy5fcmFkaWlTcXVhcmVkID0gdW5kZWZpbmVkO1xuICB0aGlzLl9yYWRpaVRvVGhlRm91cnRoID0gdW5kZWZpbmVkO1xuICB0aGlzLl9vbmVPdmVyUmFkaWkgPSB1bmRlZmluZWQ7XG4gIHRoaXMuX29uZU92ZXJSYWRpaVNxdWFyZWQgPSB1bmRlZmluZWQ7XG4gIHRoaXMuX21pbmltdW1SYWRpdXMgPSB1bmRlZmluZWQ7XG4gIHRoaXMuX21heGltdW1SYWRpdXMgPSB1bmRlZmluZWQ7XG4gIHRoaXMuX2NlbnRlclRvbGVyYW5jZVNxdWFyZWQgPSB1bmRlZmluZWQ7XG4gIHRoaXMuX3NxdWFyZWRYT3ZlclNxdWFyZWRaID0gdW5kZWZpbmVkO1xuXG4gIGluaXRpYWxpemUodGhpcywgeCwgeSwgeik7XG59XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKEVsbGlwc29pZC5wcm90b3R5cGUsIHtcbiAgLyoqXG4gICAqIEdldHMgdGhlIHJhZGlpIG9mIHRoZSBlbGxpcHNvaWQuXG4gICAqIEBtZW1iZXJvZiBFbGxpcHNvaWQucHJvdG90eXBlXG4gICAqIEB0eXBlIHtDYXJ0ZXNpYW4zfVxuICAgKiBAcmVhZG9ubHlcbiAgICovXG4gIHJhZGlpOiB7XG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fcmFkaWk7XG4gICAgfSxcbiAgfSxcbiAgLyoqXG4gICAqIEdldHMgdGhlIHNxdWFyZWQgcmFkaWkgb2YgdGhlIGVsbGlwc29pZC5cbiAgICogQG1lbWJlcm9mIEVsbGlwc29pZC5wcm90b3R5cGVcbiAgICogQHR5cGUge0NhcnRlc2lhbjN9XG4gICAqIEByZWFkb25seVxuICAgKi9cbiAgcmFkaWlTcXVhcmVkOiB7XG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fcmFkaWlTcXVhcmVkO1xuICAgIH0sXG4gIH0sXG4gIC8qKlxuICAgKiBHZXRzIHRoZSByYWRpaSBvZiB0aGUgZWxsaXBzb2lkIHJhaXNlIHRvIHRoZSBmb3VydGggcG93ZXIuXG4gICAqIEBtZW1iZXJvZiBFbGxpcHNvaWQucHJvdG90eXBlXG4gICAqIEB0eXBlIHtDYXJ0ZXNpYW4zfVxuICAgKiBAcmVhZG9ubHlcbiAgICovXG4gIHJhZGlpVG9UaGVGb3VydGg6IHtcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9yYWRpaVRvVGhlRm91cnRoO1xuICAgIH0sXG4gIH0sXG4gIC8qKlxuICAgKiBHZXRzIG9uZSBvdmVyIHRoZSByYWRpaSBvZiB0aGUgZWxsaXBzb2lkLlxuICAgKiBAbWVtYmVyb2YgRWxsaXBzb2lkLnByb3RvdHlwZVxuICAgKiBAdHlwZSB7Q2FydGVzaWFuM31cbiAgICogQHJlYWRvbmx5XG4gICAqL1xuICBvbmVPdmVyUmFkaWk6IHtcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9vbmVPdmVyUmFkaWk7XG4gICAgfSxcbiAgfSxcbiAgLyoqXG4gICAqIEdldHMgb25lIG92ZXIgdGhlIHNxdWFyZWQgcmFkaWkgb2YgdGhlIGVsbGlwc29pZC5cbiAgICogQG1lbWJlcm9mIEVsbGlwc29pZC5wcm90b3R5cGVcbiAgICogQHR5cGUge0NhcnRlc2lhbjN9XG4gICAqIEByZWFkb25seVxuICAgKi9cbiAgb25lT3ZlclJhZGlpU3F1YXJlZDoge1xuICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX29uZU92ZXJSYWRpaVNxdWFyZWQ7XG4gICAgfSxcbiAgfSxcbiAgLyoqXG4gICAqIEdldHMgdGhlIG1pbmltdW0gcmFkaXVzIG9mIHRoZSBlbGxpcHNvaWQuXG4gICAqIEBtZW1iZXJvZiBFbGxpcHNvaWQucHJvdG90eXBlXG4gICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAqIEByZWFkb25seVxuICAgKi9cbiAgbWluaW11bVJhZGl1czoge1xuICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX21pbmltdW1SYWRpdXM7XG4gICAgfSxcbiAgfSxcbiAgLyoqXG4gICAqIEdldHMgdGhlIG1heGltdW0gcmFkaXVzIG9mIHRoZSBlbGxpcHNvaWQuXG4gICAqIEBtZW1iZXJvZiBFbGxpcHNvaWQucHJvdG90eXBlXG4gICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAqIEByZWFkb25seVxuICAgKi9cbiAgbWF4aW11bVJhZGl1czoge1xuICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX21heGltdW1SYWRpdXM7XG4gICAgfSxcbiAgfSxcbn0pO1xuXG4vKipcbiAqIER1cGxpY2F0ZXMgYW4gRWxsaXBzb2lkIGluc3RhbmNlLlxuICpcbiAqIEBwYXJhbSB7RWxsaXBzb2lkfSBlbGxpcHNvaWQgVGhlIGVsbGlwc29pZCB0byBkdXBsaWNhdGUuXG4gKiBAcGFyYW0ge0VsbGlwc29pZH0gW3Jlc3VsdF0gVGhlIG9iamVjdCBvbnRvIHdoaWNoIHRvIHN0b3JlIHRoZSByZXN1bHQsIG9yIHVuZGVmaW5lZCBpZiBhIG5ld1xuICogICAgICAgICAgICAgICAgICAgIGluc3RhbmNlIHNob3VsZCBiZSBjcmVhdGVkLlxuICogQHJldHVybnMge0VsbGlwc29pZH0gVGhlIGNsb25lZCBFbGxpcHNvaWQuIChSZXR1cm5zIHVuZGVmaW5lZCBpZiBlbGxpcHNvaWQgaXMgdW5kZWZpbmVkKVxuICovXG5FbGxpcHNvaWQuY2xvbmUgPSBmdW5jdGlvbiAoZWxsaXBzb2lkLCByZXN1bHQpIHtcbiAgaWYgKCFkZWZpbmVkKGVsbGlwc29pZCkpIHtcbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG4gIHZhciByYWRpaSA9IGVsbGlwc29pZC5fcmFkaWk7XG5cbiAgaWYgKCFkZWZpbmVkKHJlc3VsdCkpIHtcbiAgICByZXR1cm4gbmV3IEVsbGlwc29pZChyYWRpaS54LCByYWRpaS55LCByYWRpaS56KTtcbiAgfVxuXG4gIENhcnRlc2lhbjMuY2xvbmUocmFkaWksIHJlc3VsdC5fcmFkaWkpO1xuICBDYXJ0ZXNpYW4zLmNsb25lKGVsbGlwc29pZC5fcmFkaWlTcXVhcmVkLCByZXN1bHQuX3JhZGlpU3F1YXJlZCk7XG4gIENhcnRlc2lhbjMuY2xvbmUoZWxsaXBzb2lkLl9yYWRpaVRvVGhlRm91cnRoLCByZXN1bHQuX3JhZGlpVG9UaGVGb3VydGgpO1xuICBDYXJ0ZXNpYW4zLmNsb25lKGVsbGlwc29pZC5fb25lT3ZlclJhZGlpLCByZXN1bHQuX29uZU92ZXJSYWRpaSk7XG4gIENhcnRlc2lhbjMuY2xvbmUoZWxsaXBzb2lkLl9vbmVPdmVyUmFkaWlTcXVhcmVkLCByZXN1bHQuX29uZU92ZXJSYWRpaVNxdWFyZWQpO1xuICByZXN1bHQuX21pbmltdW1SYWRpdXMgPSBlbGxpcHNvaWQuX21pbmltdW1SYWRpdXM7XG4gIHJlc3VsdC5fbWF4aW11bVJhZGl1cyA9IGVsbGlwc29pZC5fbWF4aW11bVJhZGl1cztcbiAgcmVzdWx0Ll9jZW50ZXJUb2xlcmFuY2VTcXVhcmVkID0gZWxsaXBzb2lkLl9jZW50ZXJUb2xlcmFuY2VTcXVhcmVkO1xuXG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG4vKipcbiAqIENvbXB1dGVzIGFuIEVsbGlwc29pZCBmcm9tIGEgQ2FydGVzaWFuIHNwZWNpZnlpbmcgdGhlIHJhZGlpIGluIHgsIHksIGFuZCB6IGRpcmVjdGlvbnMuXG4gKlxuICogQHBhcmFtIHtDYXJ0ZXNpYW4zfSBbY2FydGVzaWFuPUNhcnRlc2lhbjMuWkVST10gVGhlIGVsbGlwc29pZCdzIHJhZGl1cyBpbiB0aGUgeCwgeSwgYW5kIHogZGlyZWN0aW9ucy5cbiAqIEBwYXJhbSB7RWxsaXBzb2lkfSBbcmVzdWx0XSBUaGUgb2JqZWN0IG9udG8gd2hpY2ggdG8gc3RvcmUgdGhlIHJlc3VsdCwgb3IgdW5kZWZpbmVkIGlmIGEgbmV3XG4gKiAgICAgICAgICAgICAgICAgICAgaW5zdGFuY2Ugc2hvdWxkIGJlIGNyZWF0ZWQuXG4gKiBAcmV0dXJucyB7RWxsaXBzb2lkfSBBIG5ldyBFbGxpcHNvaWQgaW5zdGFuY2UuXG4gKlxuICogQGV4Y2VwdGlvbiB7RGV2ZWxvcGVyRXJyb3J9IEFsbCByYWRpaSBjb21wb25lbnRzIG11c3QgYmUgZ3JlYXRlciB0aGFuIG9yIGVxdWFsIHRvIHplcm8uXG4gKlxuICogQHNlZSBFbGxpcHNvaWQuV0dTODRcbiAqIEBzZWUgRWxsaXBzb2lkLlVOSVRfU1BIRVJFXG4gKi9cbkVsbGlwc29pZC5mcm9tQ2FydGVzaWFuMyA9IGZ1bmN0aW9uIChjYXJ0ZXNpYW4sIHJlc3VsdCkge1xuICBpZiAoIWRlZmluZWQocmVzdWx0KSkge1xuICAgIHJlc3VsdCA9IG5ldyBFbGxpcHNvaWQoKTtcbiAgfVxuXG4gIGlmICghZGVmaW5lZChjYXJ0ZXNpYW4pKSB7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIGluaXRpYWxpemUocmVzdWx0LCBjYXJ0ZXNpYW4ueCwgY2FydGVzaWFuLnksIGNhcnRlc2lhbi56KTtcbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbi8qKlxuICogQW4gRWxsaXBzb2lkIGluc3RhbmNlIGluaXRpYWxpemVkIHRvIHRoZSBXR1M4NCBzdGFuZGFyZC5cbiAqXG4gKiBAdHlwZSB7RWxsaXBzb2lkfVxuICogQGNvbnN0YW50XG4gKi9cbkVsbGlwc29pZC5XR1M4NCA9IE9iamVjdC5mcmVlemUoXG4gIG5ldyBFbGxpcHNvaWQoNjM3ODEzNy4wLCA2Mzc4MTM3LjAsIDYzNTY3NTIuMzE0MjQ1MTc5Mylcbik7XG5cbi8qKlxuICogQW4gRWxsaXBzb2lkIGluc3RhbmNlIGluaXRpYWxpemVkIHRvIHJhZGlpIG9mICgxLjAsIDEuMCwgMS4wKS5cbiAqXG4gKiBAdHlwZSB7RWxsaXBzb2lkfVxuICogQGNvbnN0YW50XG4gKi9cbkVsbGlwc29pZC5VTklUX1NQSEVSRSA9IE9iamVjdC5mcmVlemUobmV3IEVsbGlwc29pZCgxLjAsIDEuMCwgMS4wKSk7XG5cbi8qKlxuICogQW4gRWxsaXBzb2lkIGluc3RhbmNlIGluaXRpYWxpemVkIHRvIGEgc3BoZXJlIHdpdGggdGhlIGx1bmFyIHJhZGl1cy5cbiAqXG4gKiBAdHlwZSB7RWxsaXBzb2lkfVxuICogQGNvbnN0YW50XG4gKi9cbkVsbGlwc29pZC5NT09OID0gT2JqZWN0LmZyZWV6ZShcbiAgbmV3IEVsbGlwc29pZChcbiAgICBDZXNpdW1NYXRoLkxVTkFSX1JBRElVUyxcbiAgICBDZXNpdW1NYXRoLkxVTkFSX1JBRElVUyxcbiAgICBDZXNpdW1NYXRoLkxVTkFSX1JBRElVU1xuICApXG4pO1xuXG4vKipcbiAqIER1cGxpY2F0ZXMgYW4gRWxsaXBzb2lkIGluc3RhbmNlLlxuICpcbiAqIEBwYXJhbSB7RWxsaXBzb2lkfSBbcmVzdWx0XSBUaGUgb2JqZWN0IG9udG8gd2hpY2ggdG8gc3RvcmUgdGhlIHJlc3VsdCwgb3IgdW5kZWZpbmVkIGlmIGEgbmV3XG4gKiAgICAgICAgICAgICAgICAgICAgaW5zdGFuY2Ugc2hvdWxkIGJlIGNyZWF0ZWQuXG4gKiBAcmV0dXJucyB7RWxsaXBzb2lkfSBUaGUgY2xvbmVkIEVsbGlwc29pZC5cbiAqL1xuRWxsaXBzb2lkLnByb3RvdHlwZS5jbG9uZSA9IGZ1bmN0aW9uIChyZXN1bHQpIHtcbiAgcmV0dXJuIEVsbGlwc29pZC5jbG9uZSh0aGlzLCByZXN1bHQpO1xufTtcblxuLyoqXG4gKiBUaGUgbnVtYmVyIG9mIGVsZW1lbnRzIHVzZWQgdG8gcGFjayB0aGUgb2JqZWN0IGludG8gYW4gYXJyYXkuXG4gKiBAdHlwZSB7TnVtYmVyfVxuICovXG5FbGxpcHNvaWQucGFja2VkTGVuZ3RoID0gQ2FydGVzaWFuMy5wYWNrZWRMZW5ndGg7XG5cbi8qKlxuICogU3RvcmVzIHRoZSBwcm92aWRlZCBpbnN0YW5jZSBpbnRvIHRoZSBwcm92aWRlZCBhcnJheS5cbiAqXG4gKiBAcGFyYW0ge0VsbGlwc29pZH0gdmFsdWUgVGhlIHZhbHVlIHRvIHBhY2suXG4gKiBAcGFyYW0ge051bWJlcltdfSBhcnJheSBUaGUgYXJyYXkgdG8gcGFjayBpbnRvLlxuICogQHBhcmFtIHtOdW1iZXJ9IFtzdGFydGluZ0luZGV4PTBdIFRoZSBpbmRleCBpbnRvIHRoZSBhcnJheSBhdCB3aGljaCB0byBzdGFydCBwYWNraW5nIHRoZSBlbGVtZW50cy5cbiAqXG4gKiBAcmV0dXJucyB7TnVtYmVyW119IFRoZSBhcnJheSB0aGF0IHdhcyBwYWNrZWQgaW50b1xuICovXG5FbGxpcHNvaWQucGFjayA9IGZ1bmN0aW9uICh2YWx1ZSwgYXJyYXksIHN0YXJ0aW5nSW5kZXgpIHtcbiAgLy8+PmluY2x1ZGVTdGFydCgnZGVidWcnLCBwcmFnbWFzLmRlYnVnKTtcbiAgQ2hlY2sudHlwZU9mLm9iamVjdChcInZhbHVlXCIsIHZhbHVlKTtcbiAgQ2hlY2suZGVmaW5lZChcImFycmF5XCIsIGFycmF5KTtcbiAgLy8+PmluY2x1ZGVFbmQoJ2RlYnVnJyk7XG5cbiAgc3RhcnRpbmdJbmRleCA9IGRlZmF1bHRWYWx1ZShzdGFydGluZ0luZGV4LCAwKTtcblxuICBDYXJ0ZXNpYW4zLnBhY2sodmFsdWUuX3JhZGlpLCBhcnJheSwgc3RhcnRpbmdJbmRleCk7XG5cbiAgcmV0dXJuIGFycmF5O1xufTtcblxuLyoqXG4gKiBSZXRyaWV2ZXMgYW4gaW5zdGFuY2UgZnJvbSBhIHBhY2tlZCBhcnJheS5cbiAqXG4gKiBAcGFyYW0ge051bWJlcltdfSBhcnJheSBUaGUgcGFja2VkIGFycmF5LlxuICogQHBhcmFtIHtOdW1iZXJ9IFtzdGFydGluZ0luZGV4PTBdIFRoZSBzdGFydGluZyBpbmRleCBvZiB0aGUgZWxlbWVudCB0byBiZSB1bnBhY2tlZC5cbiAqIEBwYXJhbSB7RWxsaXBzb2lkfSBbcmVzdWx0XSBUaGUgb2JqZWN0IGludG8gd2hpY2ggdG8gc3RvcmUgdGhlIHJlc3VsdC5cbiAqIEByZXR1cm5zIHtFbGxpcHNvaWR9IFRoZSBtb2RpZmllZCByZXN1bHQgcGFyYW1ldGVyIG9yIGEgbmV3IEVsbGlwc29pZCBpbnN0YW5jZSBpZiBvbmUgd2FzIG5vdCBwcm92aWRlZC5cbiAqL1xuRWxsaXBzb2lkLnVucGFjayA9IGZ1bmN0aW9uIChhcnJheSwgc3RhcnRpbmdJbmRleCwgcmVzdWx0KSB7XG4gIC8vPj5pbmNsdWRlU3RhcnQoJ2RlYnVnJywgcHJhZ21hcy5kZWJ1Zyk7XG4gIENoZWNrLmRlZmluZWQoXCJhcnJheVwiLCBhcnJheSk7XG4gIC8vPj5pbmNsdWRlRW5kKCdkZWJ1ZycpO1xuXG4gIHN0YXJ0aW5nSW5kZXggPSBkZWZhdWx0VmFsdWUoc3RhcnRpbmdJbmRleCwgMCk7XG5cbiAgdmFyIHJhZGlpID0gQ2FydGVzaWFuMy51bnBhY2soYXJyYXksIHN0YXJ0aW5nSW5kZXgpO1xuICByZXR1cm4gRWxsaXBzb2lkLmZyb21DYXJ0ZXNpYW4zKHJhZGlpLCByZXN1bHQpO1xufTtcblxuLyoqXG4gKiBDb21wdXRlcyB0aGUgdW5pdCB2ZWN0b3IgZGlyZWN0ZWQgZnJvbSB0aGUgY2VudGVyIG9mIHRoaXMgZWxsaXBzb2lkIHRvd2FyZCB0aGUgcHJvdmlkZWQgQ2FydGVzaWFuIHBvc2l0aW9uLlxuICogQGZ1bmN0aW9uXG4gKlxuICogQHBhcmFtIHtDYXJ0ZXNpYW4zfSBjYXJ0ZXNpYW4gVGhlIENhcnRlc2lhbiBmb3Igd2hpY2ggdG8gdG8gZGV0ZXJtaW5lIHRoZSBnZW9jZW50cmljIG5vcm1hbC5cbiAqIEBwYXJhbSB7Q2FydGVzaWFuM30gW3Jlc3VsdF0gVGhlIG9iamVjdCBvbnRvIHdoaWNoIHRvIHN0b3JlIHRoZSByZXN1bHQuXG4gKiBAcmV0dXJucyB7Q2FydGVzaWFuM30gVGhlIG1vZGlmaWVkIHJlc3VsdCBwYXJhbWV0ZXIgb3IgYSBuZXcgQ2FydGVzaWFuMyBpbnN0YW5jZSBpZiBub25lIHdhcyBwcm92aWRlZC5cbiAqL1xuRWxsaXBzb2lkLnByb3RvdHlwZS5nZW9jZW50cmljU3VyZmFjZU5vcm1hbCA9IENhcnRlc2lhbjMubm9ybWFsaXplO1xuXG4vKipcbiAqIENvbXB1dGVzIHRoZSBub3JtYWwgb2YgdGhlIHBsYW5lIHRhbmdlbnQgdG8gdGhlIHN1cmZhY2Ugb2YgdGhlIGVsbGlwc29pZCBhdCB0aGUgcHJvdmlkZWQgcG9zaXRpb24uXG4gKlxuICogQHBhcmFtIHtDYXJ0b2dyYXBoaWN9IGNhcnRvZ3JhcGhpYyBUaGUgY2FydG9ncmFwaGljIHBvc2l0aW9uIGZvciB3aGljaCB0byB0byBkZXRlcm1pbmUgdGhlIGdlb2RldGljIG5vcm1hbC5cbiAqIEBwYXJhbSB7Q2FydGVzaWFuM30gW3Jlc3VsdF0gVGhlIG9iamVjdCBvbnRvIHdoaWNoIHRvIHN0b3JlIHRoZSByZXN1bHQuXG4gKiBAcmV0dXJucyB7Q2FydGVzaWFuM30gVGhlIG1vZGlmaWVkIHJlc3VsdCBwYXJhbWV0ZXIgb3IgYSBuZXcgQ2FydGVzaWFuMyBpbnN0YW5jZSBpZiBub25lIHdhcyBwcm92aWRlZC5cbiAqL1xuRWxsaXBzb2lkLnByb3RvdHlwZS5nZW9kZXRpY1N1cmZhY2VOb3JtYWxDYXJ0b2dyYXBoaWMgPSBmdW5jdGlvbiAoXG4gIGNhcnRvZ3JhcGhpYyxcbiAgcmVzdWx0XG4pIHtcbiAgLy8+PmluY2x1ZGVTdGFydCgnZGVidWcnLCBwcmFnbWFzLmRlYnVnKTtcbiAgQ2hlY2sudHlwZU9mLm9iamVjdChcImNhcnRvZ3JhcGhpY1wiLCBjYXJ0b2dyYXBoaWMpO1xuICAvLz4+aW5jbHVkZUVuZCgnZGVidWcnKTtcblxuICB2YXIgbG9uZ2l0dWRlID0gY2FydG9ncmFwaGljLmxvbmdpdHVkZTtcbiAgdmFyIGxhdGl0dWRlID0gY2FydG9ncmFwaGljLmxhdGl0dWRlO1xuICB2YXIgY29zTGF0aXR1ZGUgPSBNYXRoLmNvcyhsYXRpdHVkZSk7XG5cbiAgdmFyIHggPSBjb3NMYXRpdHVkZSAqIE1hdGguY29zKGxvbmdpdHVkZSk7XG4gIHZhciB5ID0gY29zTGF0aXR1ZGUgKiBNYXRoLnNpbihsb25naXR1ZGUpO1xuICB2YXIgeiA9IE1hdGguc2luKGxhdGl0dWRlKTtcblxuICBpZiAoIWRlZmluZWQocmVzdWx0KSkge1xuICAgIHJlc3VsdCA9IG5ldyBDYXJ0ZXNpYW4zKCk7XG4gIH1cbiAgcmVzdWx0LnggPSB4O1xuICByZXN1bHQueSA9IHk7XG4gIHJlc3VsdC56ID0gejtcbiAgcmV0dXJuIENhcnRlc2lhbjMubm9ybWFsaXplKHJlc3VsdCwgcmVzdWx0KTtcbn07XG5cbi8qKlxuICogQ29tcHV0ZXMgdGhlIG5vcm1hbCBvZiB0aGUgcGxhbmUgdGFuZ2VudCB0byB0aGUgc3VyZmFjZSBvZiB0aGUgZWxsaXBzb2lkIGF0IHRoZSBwcm92aWRlZCBwb3NpdGlvbi5cbiAqXG4gKiBAcGFyYW0ge0NhcnRlc2lhbjN9IGNhcnRlc2lhbiBUaGUgQ2FydGVzaWFuIHBvc2l0aW9uIGZvciB3aGljaCB0byB0byBkZXRlcm1pbmUgdGhlIHN1cmZhY2Ugbm9ybWFsLlxuICogQHBhcmFtIHtDYXJ0ZXNpYW4zfSBbcmVzdWx0XSBUaGUgb2JqZWN0IG9udG8gd2hpY2ggdG8gc3RvcmUgdGhlIHJlc3VsdC5cbiAqIEByZXR1cm5zIHtDYXJ0ZXNpYW4zfSBUaGUgbW9kaWZpZWQgcmVzdWx0IHBhcmFtZXRlciBvciBhIG5ldyBDYXJ0ZXNpYW4zIGluc3RhbmNlIGlmIG5vbmUgd2FzIHByb3ZpZGVkLCBvciB1bmRlZmluZWQgaWYgYSBub3JtYWwgY2Fubm90IGJlIGZvdW5kLlxuICovXG5FbGxpcHNvaWQucHJvdG90eXBlLmdlb2RldGljU3VyZmFjZU5vcm1hbCA9IGZ1bmN0aW9uIChjYXJ0ZXNpYW4sIHJlc3VsdCkge1xuICBpZiAoXG4gICAgQ2FydGVzaWFuMy5lcXVhbHNFcHNpbG9uKGNhcnRlc2lhbiwgQ2FydGVzaWFuMy5aRVJPLCBDZXNpdW1NYXRoLkVQU0lMT04xNClcbiAgKSB7XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxuICBpZiAoIWRlZmluZWQocmVzdWx0KSkge1xuICAgIHJlc3VsdCA9IG5ldyBDYXJ0ZXNpYW4zKCk7XG4gIH1cbiAgcmVzdWx0ID0gQ2FydGVzaWFuMy5tdWx0aXBseUNvbXBvbmVudHMoXG4gICAgY2FydGVzaWFuLFxuICAgIHRoaXMuX29uZU92ZXJSYWRpaVNxdWFyZWQsXG4gICAgcmVzdWx0XG4gICk7XG4gIHJldHVybiBDYXJ0ZXNpYW4zLm5vcm1hbGl6ZShyZXN1bHQsIHJlc3VsdCk7XG59O1xuXG52YXIgY2FydG9ncmFwaGljVG9DYXJ0ZXNpYW5Ob3JtYWwgPSBuZXcgQ2FydGVzaWFuMygpO1xudmFyIGNhcnRvZ3JhcGhpY1RvQ2FydGVzaWFuSyA9IG5ldyBDYXJ0ZXNpYW4zKCk7XG5cbi8qKlxuICogQ29udmVydHMgdGhlIHByb3ZpZGVkIGNhcnRvZ3JhcGhpYyB0byBDYXJ0ZXNpYW4gcmVwcmVzZW50YXRpb24uXG4gKlxuICogQHBhcmFtIHtDYXJ0b2dyYXBoaWN9IGNhcnRvZ3JhcGhpYyBUaGUgY2FydG9ncmFwaGljIHBvc2l0aW9uLlxuICogQHBhcmFtIHtDYXJ0ZXNpYW4zfSBbcmVzdWx0XSBUaGUgb2JqZWN0IG9udG8gd2hpY2ggdG8gc3RvcmUgdGhlIHJlc3VsdC5cbiAqIEByZXR1cm5zIHtDYXJ0ZXNpYW4zfSBUaGUgbW9kaWZpZWQgcmVzdWx0IHBhcmFtZXRlciBvciBhIG5ldyBDYXJ0ZXNpYW4zIGluc3RhbmNlIGlmIG5vbmUgd2FzIHByb3ZpZGVkLlxuICpcbiAqIEBleGFtcGxlXG4gKiAvL0NyZWF0ZSBhIENhcnRvZ3JhcGhpYyBhbmQgZGV0ZXJtaW5lIGl0J3MgQ2FydGVzaWFuIHJlcHJlc2VudGF0aW9uIG9uIGEgV0dTODQgZWxsaXBzb2lkLlxuICogdmFyIHBvc2l0aW9uID0gbmV3IENlc2l1bS5DYXJ0b2dyYXBoaWMoQ2VzaXVtLk1hdGgudG9SYWRpYW5zKDIxKSwgQ2VzaXVtLk1hdGgudG9SYWRpYW5zKDc4KSwgNTAwMCk7XG4gKiB2YXIgY2FydGVzaWFuUG9zaXRpb24gPSBDZXNpdW0uRWxsaXBzb2lkLldHUzg0LmNhcnRvZ3JhcGhpY1RvQ2FydGVzaWFuKHBvc2l0aW9uKTtcbiAqL1xuRWxsaXBzb2lkLnByb3RvdHlwZS5jYXJ0b2dyYXBoaWNUb0NhcnRlc2lhbiA9IGZ1bmN0aW9uIChjYXJ0b2dyYXBoaWMsIHJlc3VsdCkge1xuICAvL2BjYXJ0b2dyYXBoaWMgaXMgcmVxdWlyZWRgIGlzIHRocm93biBmcm9tIGdlb2RldGljU3VyZmFjZU5vcm1hbENhcnRvZ3JhcGhpYy5cbiAgdmFyIG4gPSBjYXJ0b2dyYXBoaWNUb0NhcnRlc2lhbk5vcm1hbDtcbiAgdmFyIGsgPSBjYXJ0b2dyYXBoaWNUb0NhcnRlc2lhbks7XG4gIHRoaXMuZ2VvZGV0aWNTdXJmYWNlTm9ybWFsQ2FydG9ncmFwaGljKGNhcnRvZ3JhcGhpYywgbik7XG4gIENhcnRlc2lhbjMubXVsdGlwbHlDb21wb25lbnRzKHRoaXMuX3JhZGlpU3F1YXJlZCwgbiwgayk7XG4gIHZhciBnYW1tYSA9IE1hdGguc3FydChDYXJ0ZXNpYW4zLmRvdChuLCBrKSk7XG4gIENhcnRlc2lhbjMuZGl2aWRlQnlTY2FsYXIoaywgZ2FtbWEsIGspO1xuICBDYXJ0ZXNpYW4zLm11bHRpcGx5QnlTY2FsYXIobiwgY2FydG9ncmFwaGljLmhlaWdodCwgbik7XG5cbiAgaWYgKCFkZWZpbmVkKHJlc3VsdCkpIHtcbiAgICByZXN1bHQgPSBuZXcgQ2FydGVzaWFuMygpO1xuICB9XG4gIHJldHVybiBDYXJ0ZXNpYW4zLmFkZChrLCBuLCByZXN1bHQpO1xufTtcblxuLyoqXG4gKiBDb252ZXJ0cyB0aGUgcHJvdmlkZWQgYXJyYXkgb2YgY2FydG9ncmFwaGljcyB0byBhbiBhcnJheSBvZiBDYXJ0ZXNpYW5zLlxuICpcbiAqIEBwYXJhbSB7Q2FydG9ncmFwaGljW119IGNhcnRvZ3JhcGhpY3MgQW4gYXJyYXkgb2YgY2FydG9ncmFwaGljIHBvc2l0aW9ucy5cbiAqIEBwYXJhbSB7Q2FydGVzaWFuM1tdfSBbcmVzdWx0XSBUaGUgb2JqZWN0IG9udG8gd2hpY2ggdG8gc3RvcmUgdGhlIHJlc3VsdC5cbiAqIEByZXR1cm5zIHtDYXJ0ZXNpYW4zW119IFRoZSBtb2RpZmllZCByZXN1bHQgcGFyYW1ldGVyIG9yIGEgbmV3IEFycmF5IGluc3RhbmNlIGlmIG5vbmUgd2FzIHByb3ZpZGVkLlxuICpcbiAqIEBleGFtcGxlXG4gKiAvL0NvbnZlcnQgYW4gYXJyYXkgb2YgQ2FydG9ncmFwaGljcyBhbmQgZGV0ZXJtaW5lIHRoZWlyIENhcnRlc2lhbiByZXByZXNlbnRhdGlvbiBvbiBhIFdHUzg0IGVsbGlwc29pZC5cbiAqIHZhciBwb3NpdGlvbnMgPSBbbmV3IENlc2l1bS5DYXJ0b2dyYXBoaWMoQ2VzaXVtLk1hdGgudG9SYWRpYW5zKDIxKSwgQ2VzaXVtLk1hdGgudG9SYWRpYW5zKDc4KSwgMCksXG4gKiAgICAgICAgICAgICAgICAgIG5ldyBDZXNpdW0uQ2FydG9ncmFwaGljKENlc2l1bS5NYXRoLnRvUmFkaWFucygyMS4zMjEpLCBDZXNpdW0uTWF0aC50b1JhZGlhbnMoNzguMTIzKSwgMTAwKSxcbiAqICAgICAgICAgICAgICAgICAgbmV3IENlc2l1bS5DYXJ0b2dyYXBoaWMoQ2VzaXVtLk1hdGgudG9SYWRpYW5zKDIxLjY0NSksIENlc2l1bS5NYXRoLnRvUmFkaWFucyg3OC40NTYpLCAyNTApXTtcbiAqIHZhciBjYXJ0ZXNpYW5Qb3NpdGlvbnMgPSBDZXNpdW0uRWxsaXBzb2lkLldHUzg0LmNhcnRvZ3JhcGhpY0FycmF5VG9DYXJ0ZXNpYW5BcnJheShwb3NpdGlvbnMpO1xuICovXG5FbGxpcHNvaWQucHJvdG90eXBlLmNhcnRvZ3JhcGhpY0FycmF5VG9DYXJ0ZXNpYW5BcnJheSA9IGZ1bmN0aW9uIChcbiAgY2FydG9ncmFwaGljcyxcbiAgcmVzdWx0XG4pIHtcbiAgLy8+PmluY2x1ZGVTdGFydCgnZGVidWcnLCBwcmFnbWFzLmRlYnVnKTtcbiAgQ2hlY2suZGVmaW5lZChcImNhcnRvZ3JhcGhpY3NcIiwgY2FydG9ncmFwaGljcyk7XG4gIC8vPj5pbmNsdWRlRW5kKCdkZWJ1ZycpXG5cbiAgdmFyIGxlbmd0aCA9IGNhcnRvZ3JhcGhpY3MubGVuZ3RoO1xuICBpZiAoIWRlZmluZWQocmVzdWx0KSkge1xuICAgIHJlc3VsdCA9IG5ldyBBcnJheShsZW5ndGgpO1xuICB9IGVsc2Uge1xuICAgIHJlc3VsdC5sZW5ndGggPSBsZW5ndGg7XG4gIH1cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgIHJlc3VsdFtpXSA9IHRoaXMuY2FydG9ncmFwaGljVG9DYXJ0ZXNpYW4oY2FydG9ncmFwaGljc1tpXSwgcmVzdWx0W2ldKTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufTtcblxudmFyIGNhcnRlc2lhblRvQ2FydG9ncmFwaGljTiA9IG5ldyBDYXJ0ZXNpYW4zKCk7XG52YXIgY2FydGVzaWFuVG9DYXJ0b2dyYXBoaWNQID0gbmV3IENhcnRlc2lhbjMoKTtcbnZhciBjYXJ0ZXNpYW5Ub0NhcnRvZ3JhcGhpY0ggPSBuZXcgQ2FydGVzaWFuMygpO1xuXG4vKipcbiAqIENvbnZlcnRzIHRoZSBwcm92aWRlZCBjYXJ0ZXNpYW4gdG8gY2FydG9ncmFwaGljIHJlcHJlc2VudGF0aW9uLlxuICogVGhlIGNhcnRlc2lhbiBpcyB1bmRlZmluZWQgYXQgdGhlIGNlbnRlciBvZiB0aGUgZWxsaXBzb2lkLlxuICpcbiAqIEBwYXJhbSB7Q2FydGVzaWFuM30gY2FydGVzaWFuIFRoZSBDYXJ0ZXNpYW4gcG9zaXRpb24gdG8gY29udmVydCB0byBjYXJ0b2dyYXBoaWMgcmVwcmVzZW50YXRpb24uXG4gKiBAcGFyYW0ge0NhcnRvZ3JhcGhpY30gW3Jlc3VsdF0gVGhlIG9iamVjdCBvbnRvIHdoaWNoIHRvIHN0b3JlIHRoZSByZXN1bHQuXG4gKiBAcmV0dXJucyB7Q2FydG9ncmFwaGljfSBUaGUgbW9kaWZpZWQgcmVzdWx0IHBhcmFtZXRlciwgbmV3IENhcnRvZ3JhcGhpYyBpbnN0YW5jZSBpZiBub25lIHdhcyBwcm92aWRlZCwgb3IgdW5kZWZpbmVkIGlmIHRoZSBjYXJ0ZXNpYW4gaXMgYXQgdGhlIGNlbnRlciBvZiB0aGUgZWxsaXBzb2lkLlxuICpcbiAqIEBleGFtcGxlXG4gKiAvL0NyZWF0ZSBhIENhcnRlc2lhbiBhbmQgZGV0ZXJtaW5lIGl0J3MgQ2FydG9ncmFwaGljIHJlcHJlc2VudGF0aW9uIG9uIGEgV0dTODQgZWxsaXBzb2lkLlxuICogdmFyIHBvc2l0aW9uID0gbmV3IENlc2l1bS5DYXJ0ZXNpYW4zKDE3ODMyLjEyLCA4MzIzNC41MiwgOTUyMzEzLjczKTtcbiAqIHZhciBjYXJ0b2dyYXBoaWNQb3NpdGlvbiA9IENlc2l1bS5FbGxpcHNvaWQuV0dTODQuY2FydGVzaWFuVG9DYXJ0b2dyYXBoaWMocG9zaXRpb24pO1xuICovXG5FbGxpcHNvaWQucHJvdG90eXBlLmNhcnRlc2lhblRvQ2FydG9ncmFwaGljID0gZnVuY3Rpb24gKGNhcnRlc2lhbiwgcmVzdWx0KSB7XG4gIC8vYGNhcnRlc2lhbiBpcyByZXF1aXJlZC5gIGlzIHRocm93biBmcm9tIHNjYWxlVG9HZW9kZXRpY1N1cmZhY2VcbiAgdmFyIHAgPSB0aGlzLnNjYWxlVG9HZW9kZXRpY1N1cmZhY2UoY2FydGVzaWFuLCBjYXJ0ZXNpYW5Ub0NhcnRvZ3JhcGhpY1ApO1xuXG4gIGlmICghZGVmaW5lZChwKSkge1xuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cblxuICB2YXIgbiA9IHRoaXMuZ2VvZGV0aWNTdXJmYWNlTm9ybWFsKHAsIGNhcnRlc2lhblRvQ2FydG9ncmFwaGljTik7XG4gIHZhciBoID0gQ2FydGVzaWFuMy5zdWJ0cmFjdChjYXJ0ZXNpYW4sIHAsIGNhcnRlc2lhblRvQ2FydG9ncmFwaGljSCk7XG5cbiAgdmFyIGxvbmdpdHVkZSA9IE1hdGguYXRhbjIobi55LCBuLngpO1xuICB2YXIgbGF0aXR1ZGUgPSBNYXRoLmFzaW4obi56KTtcbiAgdmFyIGhlaWdodCA9XG4gICAgQ2VzaXVtTWF0aC5zaWduKENhcnRlc2lhbjMuZG90KGgsIGNhcnRlc2lhbikpICogQ2FydGVzaWFuMy5tYWduaXR1ZGUoaCk7XG5cbiAgaWYgKCFkZWZpbmVkKHJlc3VsdCkpIHtcbiAgICByZXR1cm4gbmV3IENhcnRvZ3JhcGhpYyhsb25naXR1ZGUsIGxhdGl0dWRlLCBoZWlnaHQpO1xuICB9XG4gIHJlc3VsdC5sb25naXR1ZGUgPSBsb25naXR1ZGU7XG4gIHJlc3VsdC5sYXRpdHVkZSA9IGxhdGl0dWRlO1xuICByZXN1bHQuaGVpZ2h0ID0gaGVpZ2h0O1xuICByZXR1cm4gcmVzdWx0O1xufTtcblxuLyoqXG4gKiBDb252ZXJ0cyB0aGUgcHJvdmlkZWQgYXJyYXkgb2YgY2FydGVzaWFucyB0byBhbiBhcnJheSBvZiBjYXJ0b2dyYXBoaWNzLlxuICpcbiAqIEBwYXJhbSB7Q2FydGVzaWFuM1tdfSBjYXJ0ZXNpYW5zIEFuIGFycmF5IG9mIENhcnRlc2lhbiBwb3NpdGlvbnMuXG4gKiBAcGFyYW0ge0NhcnRvZ3JhcGhpY1tdfSBbcmVzdWx0XSBUaGUgb2JqZWN0IG9udG8gd2hpY2ggdG8gc3RvcmUgdGhlIHJlc3VsdC5cbiAqIEByZXR1cm5zIHtDYXJ0b2dyYXBoaWNbXX0gVGhlIG1vZGlmaWVkIHJlc3VsdCBwYXJhbWV0ZXIgb3IgYSBuZXcgQXJyYXkgaW5zdGFuY2UgaWYgbm9uZSB3YXMgcHJvdmlkZWQuXG4gKlxuICogQGV4YW1wbGVcbiAqIC8vQ3JlYXRlIGFuIGFycmF5IG9mIENhcnRlc2lhbnMgYW5kIGRldGVybWluZSB0aGVpciBDYXJ0b2dyYXBoaWMgcmVwcmVzZW50YXRpb24gb24gYSBXR1M4NCBlbGxpcHNvaWQuXG4gKiB2YXIgcG9zaXRpb25zID0gW25ldyBDZXNpdW0uQ2FydGVzaWFuMygxNzgzMi4xMiwgODMyMzQuNTIsIDk1MjMxMy43MyksXG4gKiAgICAgICAgICAgICAgICAgIG5ldyBDZXNpdW0uQ2FydGVzaWFuMygxNzgzMi4xMywgODMyMzQuNTMsIDk1MjMxMy43MyksXG4gKiAgICAgICAgICAgICAgICAgIG5ldyBDZXNpdW0uQ2FydGVzaWFuMygxNzgzMi4xNCwgODMyMzQuNTQsIDk1MjMxMy43MyldXG4gKiB2YXIgY2FydG9ncmFwaGljUG9zaXRpb25zID0gQ2VzaXVtLkVsbGlwc29pZC5XR1M4NC5jYXJ0ZXNpYW5BcnJheVRvQ2FydG9ncmFwaGljQXJyYXkocG9zaXRpb25zKTtcbiAqL1xuRWxsaXBzb2lkLnByb3RvdHlwZS5jYXJ0ZXNpYW5BcnJheVRvQ2FydG9ncmFwaGljQXJyYXkgPSBmdW5jdGlvbiAoXG4gIGNhcnRlc2lhbnMsXG4gIHJlc3VsdFxuKSB7XG4gIC8vPj5pbmNsdWRlU3RhcnQoJ2RlYnVnJywgcHJhZ21hcy5kZWJ1Zyk7XG4gIENoZWNrLmRlZmluZWQoXCJjYXJ0ZXNpYW5zXCIsIGNhcnRlc2lhbnMpO1xuICAvLz4+aW5jbHVkZUVuZCgnZGVidWcnKTtcblxuICB2YXIgbGVuZ3RoID0gY2FydGVzaWFucy5sZW5ndGg7XG4gIGlmICghZGVmaW5lZChyZXN1bHQpKSB7XG4gICAgcmVzdWx0ID0gbmV3IEFycmF5KGxlbmd0aCk7XG4gIH0gZWxzZSB7XG4gICAgcmVzdWx0Lmxlbmd0aCA9IGxlbmd0aDtcbiAgfVxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgKytpKSB7XG4gICAgcmVzdWx0W2ldID0gdGhpcy5jYXJ0ZXNpYW5Ub0NhcnRvZ3JhcGhpYyhjYXJ0ZXNpYW5zW2ldLCByZXN1bHRbaV0pO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG4vKipcbiAqIFNjYWxlcyB0aGUgcHJvdmlkZWQgQ2FydGVzaWFuIHBvc2l0aW9uIGFsb25nIHRoZSBnZW9kZXRpYyBzdXJmYWNlIG5vcm1hbFxuICogc28gdGhhdCBpdCBpcyBvbiB0aGUgc3VyZmFjZSBvZiB0aGlzIGVsbGlwc29pZC4gIElmIHRoZSBwb3NpdGlvbiBpc1xuICogYXQgdGhlIGNlbnRlciBvZiB0aGUgZWxsaXBzb2lkLCB0aGlzIGZ1bmN0aW9uIHJldHVybnMgdW5kZWZpbmVkLlxuICpcbiAqIEBwYXJhbSB7Q2FydGVzaWFuM30gY2FydGVzaWFuIFRoZSBDYXJ0ZXNpYW4gcG9zaXRpb24gdG8gc2NhbGUuXG4gKiBAcGFyYW0ge0NhcnRlc2lhbjN9IFtyZXN1bHRdIFRoZSBvYmplY3Qgb250byB3aGljaCB0byBzdG9yZSB0aGUgcmVzdWx0LlxuICogQHJldHVybnMge0NhcnRlc2lhbjN9IFRoZSBtb2RpZmllZCByZXN1bHQgcGFyYW1ldGVyLCBhIG5ldyBDYXJ0ZXNpYW4zIGluc3RhbmNlIGlmIG5vbmUgd2FzIHByb3ZpZGVkLCBvciB1bmRlZmluZWQgaWYgdGhlIHBvc2l0aW9uIGlzIGF0IHRoZSBjZW50ZXIuXG4gKi9cbkVsbGlwc29pZC5wcm90b3R5cGUuc2NhbGVUb0dlb2RldGljU3VyZmFjZSA9IGZ1bmN0aW9uIChjYXJ0ZXNpYW4sIHJlc3VsdCkge1xuICByZXR1cm4gc2NhbGVUb0dlb2RldGljU3VyZmFjZShcbiAgICBjYXJ0ZXNpYW4sXG4gICAgdGhpcy5fb25lT3ZlclJhZGlpLFxuICAgIHRoaXMuX29uZU92ZXJSYWRpaVNxdWFyZWQsXG4gICAgdGhpcy5fY2VudGVyVG9sZXJhbmNlU3F1YXJlZCxcbiAgICByZXN1bHRcbiAgKTtcbn07XG5cbi8qKlxuICogU2NhbGVzIHRoZSBwcm92aWRlZCBDYXJ0ZXNpYW4gcG9zaXRpb24gYWxvbmcgdGhlIGdlb2NlbnRyaWMgc3VyZmFjZSBub3JtYWxcbiAqIHNvIHRoYXQgaXQgaXMgb24gdGhlIHN1cmZhY2Ugb2YgdGhpcyBlbGxpcHNvaWQuXG4gKlxuICogQHBhcmFtIHtDYXJ0ZXNpYW4zfSBjYXJ0ZXNpYW4gVGhlIENhcnRlc2lhbiBwb3NpdGlvbiB0byBzY2FsZS5cbiAqIEBwYXJhbSB7Q2FydGVzaWFuM30gW3Jlc3VsdF0gVGhlIG9iamVjdCBvbnRvIHdoaWNoIHRvIHN0b3JlIHRoZSByZXN1bHQuXG4gKiBAcmV0dXJucyB7Q2FydGVzaWFuM30gVGhlIG1vZGlmaWVkIHJlc3VsdCBwYXJhbWV0ZXIgb3IgYSBuZXcgQ2FydGVzaWFuMyBpbnN0YW5jZSBpZiBub25lIHdhcyBwcm92aWRlZC5cbiAqL1xuRWxsaXBzb2lkLnByb3RvdHlwZS5zY2FsZVRvR2VvY2VudHJpY1N1cmZhY2UgPSBmdW5jdGlvbiAoY2FydGVzaWFuLCByZXN1bHQpIHtcbiAgLy8+PmluY2x1ZGVTdGFydCgnZGVidWcnLCBwcmFnbWFzLmRlYnVnKTtcbiAgQ2hlY2sudHlwZU9mLm9iamVjdChcImNhcnRlc2lhblwiLCBjYXJ0ZXNpYW4pO1xuICAvLz4+aW5jbHVkZUVuZCgnZGVidWcnKTtcblxuICBpZiAoIWRlZmluZWQocmVzdWx0KSkge1xuICAgIHJlc3VsdCA9IG5ldyBDYXJ0ZXNpYW4zKCk7XG4gIH1cblxuICB2YXIgcG9zaXRpb25YID0gY2FydGVzaWFuLng7XG4gIHZhciBwb3NpdGlvblkgPSBjYXJ0ZXNpYW4ueTtcbiAgdmFyIHBvc2l0aW9uWiA9IGNhcnRlc2lhbi56O1xuICB2YXIgb25lT3ZlclJhZGlpU3F1YXJlZCA9IHRoaXMuX29uZU92ZXJSYWRpaVNxdWFyZWQ7XG5cbiAgdmFyIGJldGEgPVxuICAgIDEuMCAvXG4gICAgTWF0aC5zcXJ0KFxuICAgICAgcG9zaXRpb25YICogcG9zaXRpb25YICogb25lT3ZlclJhZGlpU3F1YXJlZC54ICtcbiAgICAgICAgcG9zaXRpb25ZICogcG9zaXRpb25ZICogb25lT3ZlclJhZGlpU3F1YXJlZC55ICtcbiAgICAgICAgcG9zaXRpb25aICogcG9zaXRpb25aICogb25lT3ZlclJhZGlpU3F1YXJlZC56XG4gICAgKTtcblxuICByZXR1cm4gQ2FydGVzaWFuMy5tdWx0aXBseUJ5U2NhbGFyKGNhcnRlc2lhbiwgYmV0YSwgcmVzdWx0KTtcbn07XG5cbi8qKlxuICogVHJhbnNmb3JtcyBhIENhcnRlc2lhbiBYLCBZLCBaIHBvc2l0aW9uIHRvIHRoZSBlbGxpcHNvaWQtc2NhbGVkIHNwYWNlIGJ5IG11bHRpcGx5aW5nXG4gKiBpdHMgY29tcG9uZW50cyBieSB0aGUgcmVzdWx0IG9mIHtAbGluayBFbGxpcHNvaWQjb25lT3ZlclJhZGlpfS5cbiAqXG4gKiBAcGFyYW0ge0NhcnRlc2lhbjN9IHBvc2l0aW9uIFRoZSBwb3NpdGlvbiB0byB0cmFuc2Zvcm0uXG4gKiBAcGFyYW0ge0NhcnRlc2lhbjN9IFtyZXN1bHRdIFRoZSBwb3NpdGlvbiB0byB3aGljaCB0byBjb3B5IHRoZSByZXN1bHQsIG9yIHVuZGVmaW5lZCB0byBjcmVhdGUgYW5kXG4gKiAgICAgICAgcmV0dXJuIGEgbmV3IGluc3RhbmNlLlxuICogQHJldHVybnMge0NhcnRlc2lhbjN9IFRoZSBwb3NpdGlvbiBleHByZXNzZWQgaW4gdGhlIHNjYWxlZCBzcGFjZS4gIFRoZSByZXR1cm5lZCBpbnN0YW5jZSBpcyB0aGVcbiAqICAgICAgICAgIG9uZSBwYXNzZWQgYXMgdGhlIHJlc3VsdCBwYXJhbWV0ZXIgaWYgaXQgaXMgbm90IHVuZGVmaW5lZCwgb3IgYSBuZXcgaW5zdGFuY2Ugb2YgaXQgaXMuXG4gKi9cbkVsbGlwc29pZC5wcm90b3R5cGUudHJhbnNmb3JtUG9zaXRpb25Ub1NjYWxlZFNwYWNlID0gZnVuY3Rpb24gKFxuICBwb3NpdGlvbixcbiAgcmVzdWx0XG4pIHtcbiAgaWYgKCFkZWZpbmVkKHJlc3VsdCkpIHtcbiAgICByZXN1bHQgPSBuZXcgQ2FydGVzaWFuMygpO1xuICB9XG5cbiAgcmV0dXJuIENhcnRlc2lhbjMubXVsdGlwbHlDb21wb25lbnRzKHBvc2l0aW9uLCB0aGlzLl9vbmVPdmVyUmFkaWksIHJlc3VsdCk7XG59O1xuXG4vKipcbiAqIFRyYW5zZm9ybXMgYSBDYXJ0ZXNpYW4gWCwgWSwgWiBwb3NpdGlvbiBmcm9tIHRoZSBlbGxpcHNvaWQtc2NhbGVkIHNwYWNlIGJ5IG11bHRpcGx5aW5nXG4gKiBpdHMgY29tcG9uZW50cyBieSB0aGUgcmVzdWx0IG9mIHtAbGluayBFbGxpcHNvaWQjcmFkaWl9LlxuICpcbiAqIEBwYXJhbSB7Q2FydGVzaWFuM30gcG9zaXRpb24gVGhlIHBvc2l0aW9uIHRvIHRyYW5zZm9ybS5cbiAqIEBwYXJhbSB7Q2FydGVzaWFuM30gW3Jlc3VsdF0gVGhlIHBvc2l0aW9uIHRvIHdoaWNoIHRvIGNvcHkgdGhlIHJlc3VsdCwgb3IgdW5kZWZpbmVkIHRvIGNyZWF0ZSBhbmRcbiAqICAgICAgICByZXR1cm4gYSBuZXcgaW5zdGFuY2UuXG4gKiBAcmV0dXJucyB7Q2FydGVzaWFuM30gVGhlIHBvc2l0aW9uIGV4cHJlc3NlZCBpbiB0aGUgdW5zY2FsZWQgc3BhY2UuICBUaGUgcmV0dXJuZWQgaW5zdGFuY2UgaXMgdGhlXG4gKiAgICAgICAgICBvbmUgcGFzc2VkIGFzIHRoZSByZXN1bHQgcGFyYW1ldGVyIGlmIGl0IGlzIG5vdCB1bmRlZmluZWQsIG9yIGEgbmV3IGluc3RhbmNlIG9mIGl0IGlzLlxuICovXG5FbGxpcHNvaWQucHJvdG90eXBlLnRyYW5zZm9ybVBvc2l0aW9uRnJvbVNjYWxlZFNwYWNlID0gZnVuY3Rpb24gKFxuICBwb3NpdGlvbixcbiAgcmVzdWx0XG4pIHtcbiAgaWYgKCFkZWZpbmVkKHJlc3VsdCkpIHtcbiAgICByZXN1bHQgPSBuZXcgQ2FydGVzaWFuMygpO1xuICB9XG5cbiAgcmV0dXJuIENhcnRlc2lhbjMubXVsdGlwbHlDb21wb25lbnRzKHBvc2l0aW9uLCB0aGlzLl9yYWRpaSwgcmVzdWx0KTtcbn07XG5cbi8qKlxuICogQ29tcGFyZXMgdGhpcyBFbGxpcHNvaWQgYWdhaW5zdCB0aGUgcHJvdmlkZWQgRWxsaXBzb2lkIGNvbXBvbmVudHdpc2UgYW5kIHJldHVybnNcbiAqIDxjb2RlPnRydWU8L2NvZGU+IGlmIHRoZXkgYXJlIGVxdWFsLCA8Y29kZT5mYWxzZTwvY29kZT4gb3RoZXJ3aXNlLlxuICpcbiAqIEBwYXJhbSB7RWxsaXBzb2lkfSBbcmlnaHRdIFRoZSBvdGhlciBFbGxpcHNvaWQuXG4gKiBAcmV0dXJucyB7Qm9vbGVhbn0gPGNvZGU+dHJ1ZTwvY29kZT4gaWYgdGhleSBhcmUgZXF1YWwsIDxjb2RlPmZhbHNlPC9jb2RlPiBvdGhlcndpc2UuXG4gKi9cbkVsbGlwc29pZC5wcm90b3R5cGUuZXF1YWxzID0gZnVuY3Rpb24gKHJpZ2h0KSB7XG4gIHJldHVybiAoXG4gICAgdGhpcyA9PT0gcmlnaHQgfHxcbiAgICAoZGVmaW5lZChyaWdodCkgJiYgQ2FydGVzaWFuMy5lcXVhbHModGhpcy5fcmFkaWksIHJpZ2h0Ll9yYWRpaSkpXG4gICk7XG59O1xuXG4vKipcbiAqIENyZWF0ZXMgYSBzdHJpbmcgcmVwcmVzZW50aW5nIHRoaXMgRWxsaXBzb2lkIGluIHRoZSBmb3JtYXQgJyhyYWRpaS54LCByYWRpaS55LCByYWRpaS56KScuXG4gKlxuICogQHJldHVybnMge1N0cmluZ30gQSBzdHJpbmcgcmVwcmVzZW50aW5nIHRoaXMgZWxsaXBzb2lkIGluIHRoZSBmb3JtYXQgJyhyYWRpaS54LCByYWRpaS55LCByYWRpaS56KScuXG4gKi9cbkVsbGlwc29pZC5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLl9yYWRpaS50b1N0cmluZygpO1xufTtcblxuLyoqXG4gKiBDb21wdXRlcyBhIHBvaW50IHdoaWNoIGlzIHRoZSBpbnRlcnNlY3Rpb24gb2YgdGhlIHN1cmZhY2Ugbm9ybWFsIHdpdGggdGhlIHotYXhpcy5cbiAqXG4gKiBAcGFyYW0ge0NhcnRlc2lhbjN9IHBvc2l0aW9uIHRoZSBwb3NpdGlvbi4gbXVzdCBiZSBvbiB0aGUgc3VyZmFjZSBvZiB0aGUgZWxsaXBzb2lkLlxuICogQHBhcmFtIHtOdW1iZXJ9IFtidWZmZXIgPSAwLjBdIEEgYnVmZmVyIHRvIHN1YnRyYWN0IGZyb20gdGhlIGVsbGlwc29pZCBzaXplIHdoZW4gY2hlY2tpbmcgaWYgdGhlIHBvaW50IGlzIGluc2lkZSB0aGUgZWxsaXBzb2lkLlxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIEluIGVhcnRoIGNhc2UsIHdpdGggY29tbW9uIGVhcnRoIGRhdHVtcywgdGhlcmUgaXMgbm8gbmVlZCBmb3IgdGhpcyBidWZmZXIgc2luY2UgdGhlIGludGVyc2VjdGlvbiBwb2ludCBpcyBhbHdheXMgKHJlbGF0aXZlbHkpIHZlcnkgY2xvc2UgdG8gdGhlIGNlbnRlci5cbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBJbiBXR1M4NCBkYXR1bSwgaW50ZXJzZWN0aW9uIHBvaW50IGlzIGF0IG1heCB6ID0gKy00Mjg0MS4zMTE1MTMzMTM4MiAoMC42NzMlIG9mIHotYXhpcykuXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgSW50ZXJzZWN0aW9uIHBvaW50IGNvdWxkIGJlIG91dHNpZGUgdGhlIGVsbGlwc29pZCBpZiB0aGUgcmF0aW8gb2YgTWFqb3JBeGlzIC8gQXhpc09mUm90YXRpb24gaXMgYmlnZ2VyIHRoYW4gdGhlIHNxdWFyZSByb290IG9mIDJcbiAqIEBwYXJhbSB7Q2FydGVzaWFuM30gW3Jlc3VsdF0gVGhlIGNhcnRlc2lhbiB0byB3aGljaCB0byBjb3B5IHRoZSByZXN1bHQsIG9yIHVuZGVmaW5lZCB0byBjcmVhdGUgYW5kXG4gKiAgICAgICAgcmV0dXJuIGEgbmV3IGluc3RhbmNlLlxuICogQHJldHVybnMge0NhcnRlc2lhbjMgfCB1bmRlZmluZWR9IHRoZSBpbnRlcnNlY3Rpb24gcG9pbnQgaWYgaXQncyBpbnNpZGUgdGhlIGVsbGlwc29pZCwgdW5kZWZpbmVkIG90aGVyd2lzZVxuICpcbiAqIEBleGNlcHRpb24ge0RldmVsb3BlckVycm9yfSBwb3NpdGlvbiBpcyByZXF1aXJlZC5cbiAqIEBleGNlcHRpb24ge0RldmVsb3BlckVycm9yfSBFbGxpcHNvaWQgbXVzdCBiZSBhbiBlbGxpcHNvaWQgb2YgcmV2b2x1dGlvbiAocmFkaWkueCA9PSByYWRpaS55KS5cbiAqIEBleGNlcHRpb24ge0RldmVsb3BlckVycm9yfSBFbGxpcHNvaWQucmFkaWkueiBtdXN0IGJlIGdyZWF0ZXIgdGhhbiAwLlxuICovXG5FbGxpcHNvaWQucHJvdG90eXBlLmdldFN1cmZhY2VOb3JtYWxJbnRlcnNlY3Rpb25XaXRoWkF4aXMgPSBmdW5jdGlvbiAoXG4gIHBvc2l0aW9uLFxuICBidWZmZXIsXG4gIHJlc3VsdFxuKSB7XG4gIC8vPj5pbmNsdWRlU3RhcnQoJ2RlYnVnJywgcHJhZ21hcy5kZWJ1Zyk7XG4gIENoZWNrLnR5cGVPZi5vYmplY3QoXCJwb3NpdGlvblwiLCBwb3NpdGlvbik7XG5cbiAgaWYgKFxuICAgICFDZXNpdW1NYXRoLmVxdWFsc0Vwc2lsb24oXG4gICAgICB0aGlzLl9yYWRpaS54LFxuICAgICAgdGhpcy5fcmFkaWkueSxcbiAgICAgIENlc2l1bU1hdGguRVBTSUxPTjE1XG4gICAgKVxuICApIHtcbiAgICB0aHJvdyBuZXcgRGV2ZWxvcGVyRXJyb3IoXG4gICAgICBcIkVsbGlwc29pZCBtdXN0IGJlIGFuIGVsbGlwc29pZCBvZiByZXZvbHV0aW9uIChyYWRpaS54ID09IHJhZGlpLnkpXCJcbiAgICApO1xuICB9XG5cbiAgQ2hlY2sudHlwZU9mLm51bWJlci5ncmVhdGVyVGhhbihcIkVsbGlwc29pZC5yYWRpaS56XCIsIHRoaXMuX3JhZGlpLnosIDApO1xuICAvLz4+aW5jbHVkZUVuZCgnZGVidWcnKTtcblxuICBidWZmZXIgPSBkZWZhdWx0VmFsdWUoYnVmZmVyLCAwLjApO1xuXG4gIHZhciBzcXVhcmVkWE92ZXJTcXVhcmVkWiA9IHRoaXMuX3NxdWFyZWRYT3ZlclNxdWFyZWRaO1xuXG4gIGlmICghZGVmaW5lZChyZXN1bHQpKSB7XG4gICAgcmVzdWx0ID0gbmV3IENhcnRlc2lhbjMoKTtcbiAgfVxuXG4gIHJlc3VsdC54ID0gMC4wO1xuICByZXN1bHQueSA9IDAuMDtcbiAgcmVzdWx0LnogPSBwb3NpdGlvbi56ICogKDEgLSBzcXVhcmVkWE92ZXJTcXVhcmVkWik7XG5cbiAgaWYgKE1hdGguYWJzKHJlc3VsdC56KSA+PSB0aGlzLl9yYWRpaS56IC0gYnVmZmVyKSB7XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxuXG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG52YXIgYWJzY2lzc2FzID0gW1xuICAwLjE0ODg3NDMzODk4MTYzLFxuICAwLjQzMzM5NTM5NDEyOTI1LFxuICAwLjY3OTQwOTU2ODI5OTAyLFxuICAwLjg2NTA2MzM2NjY4ODk4LFxuICAwLjk3MzkwNjUyODUxNzE3LFxuICAwLjAsXG5dO1xudmFyIHdlaWdodHMgPSBbXG4gIDAuMjk1NTI0MjI0NzE0NzUsXG4gIDAuMjY5MjY2NzE5MzA5OTksXG4gIDAuMjE5MDg2MzYyNTE1OTgsXG4gIDAuMTQ5NDUxMzQ5MTUwNTgsXG4gIDAuMDY2NjcxMzQ0MzA4Njg0LFxuICAwLjAsXG5dO1xuXG4vKipcbiAqIENvbXB1dGUgdGhlIDEwdGggb3JkZXIgR2F1c3MtTGVnZW5kcmUgUXVhZHJhdHVyZSBvZiB0aGUgZ2l2ZW4gZGVmaW5pdGUgaW50ZWdyYWwuXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IGEgVGhlIGxvd2VyIGJvdW5kIGZvciB0aGUgaW50ZWdyYXRpb24uXG4gKiBAcGFyYW0ge051bWJlcn0gYiBUaGUgdXBwZXIgYm91bmQgZm9yIHRoZSBpbnRlZ3JhdGlvbi5cbiAqIEBwYXJhbSB7RWxsaXBzb2lkflJlYWxWYWx1ZWRTY2FsYXJGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gaW50ZWdyYXRlLlxuICogQHJldHVybnMge051bWJlcn0gVGhlIHZhbHVlIG9mIHRoZSBpbnRlZ3JhbCBvZiB0aGUgZ2l2ZW4gZnVuY3Rpb24gb3ZlciB0aGUgZ2l2ZW4gZG9tYWluLlxuICpcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGdhdXNzTGVnZW5kcmVRdWFkcmF0dXJlKGEsIGIsIGZ1bmMpIHtcbiAgLy8+PmluY2x1ZGVTdGFydCgnZGVidWcnLCBwcmFnbWFzLmRlYnVnKTtcbiAgQ2hlY2sudHlwZU9mLm51bWJlcihcImFcIiwgYSk7XG4gIENoZWNrLnR5cGVPZi5udW1iZXIoXCJiXCIsIGIpO1xuICBDaGVjay50eXBlT2YuZnVuYyhcImZ1bmNcIiwgZnVuYyk7XG4gIC8vPj5pbmNsdWRlRW5kKCdkZWJ1ZycpO1xuXG4gIC8vIFRoZSByYW5nZSBpcyBoYWxmIG9mIHRoZSBub3JtYWwgcmFuZ2Ugc2luY2UgdGhlIGZpdmUgd2VpZ2h0cyBhZGQgdG8gb25lICh0ZW4gd2VpZ2h0cyBhZGQgdG8gdHdvKS5cbiAgLy8gVGhlIHZhbHVlcyBvZiB0aGUgYWJzY2lzc2FzIGFyZSBtdWx0aXBsaWVkIGJ5IHR3byB0byBhY2NvdW50IGZvciB0aGlzLlxuICB2YXIgeE1lYW4gPSAwLjUgKiAoYiArIGEpO1xuICB2YXIgeFJhbmdlID0gMC41ICogKGIgLSBhKTtcblxuICB2YXIgc3VtID0gMC4wO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IDU7IGkrKykge1xuICAgIHZhciBkeCA9IHhSYW5nZSAqIGFic2Npc3Nhc1tpXTtcbiAgICBzdW0gKz0gd2VpZ2h0c1tpXSAqIChmdW5jKHhNZWFuICsgZHgpICsgZnVuYyh4TWVhbiAtIGR4KSk7XG4gIH1cblxuICAvLyBTY2FsZSB0aGUgc3VtIHRvIHRoZSByYW5nZSBvZiB4LlxuICBzdW0gKj0geFJhbmdlO1xuICByZXR1cm4gc3VtO1xufVxuXG4vKipcbiAqIEEgcmVhbCB2YWx1ZWQgc2NhbGFyIGZ1bmN0aW9uLlxuICogQGNhbGxiYWNrIEVsbGlwc29pZH5SZWFsVmFsdWVkU2NhbGFyRnVuY3Rpb25cbiAqXG4gKiBAcGFyYW0ge051bWJlcn0geCBUaGUgdmFsdWUgdXNlZCB0byBldmFsdWF0ZSB0aGUgZnVuY3Rpb24uXG4gKiBAcmV0dXJucyB7TnVtYmVyfSBUaGUgdmFsdWUgb2YgdGhlIGZ1bmN0aW9uIGF0IHguXG4gKlxuICogQHByaXZhdGVcbiAqL1xuXG4vKipcbiAqIENvbXB1dGVzIGFuIGFwcHJveGltYXRpb24gb2YgdGhlIHN1cmZhY2UgYXJlYSBvZiBhIHJlY3RhbmdsZSBvbiB0aGUgc3VyZmFjZSBvZiBhbiBlbGxpcHNvaWQgdXNpbmdcbiAqIEdhdXNzLUxlZ2VuZHJlIDEwdGggb3JkZXIgcXVhZHJhdHVyZS5cbiAqXG4gKiBAcGFyYW0ge1JlY3RhbmdsZX0gcmVjdGFuZ2xlIFRoZSByZWN0YW5nbGUgdXNlZCBmb3IgY29tcHV0aW5nIHRoZSBzdXJmYWNlIGFyZWEuXG4gKiBAcmV0dXJucyB7TnVtYmVyfSBUaGUgYXBwcm94aW1hdGUgYXJlYSBvZiB0aGUgcmVjdGFuZ2xlIG9uIHRoZSBzdXJmYWNlIG9mIHRoaXMgZWxsaXBzb2lkLlxuICovXG5FbGxpcHNvaWQucHJvdG90eXBlLnN1cmZhY2VBcmVhID0gZnVuY3Rpb24gKHJlY3RhbmdsZSkge1xuICAvLz4+aW5jbHVkZVN0YXJ0KCdkZWJ1ZycsIHByYWdtYXMuZGVidWcpO1xuICBDaGVjay50eXBlT2Yub2JqZWN0KFwicmVjdGFuZ2xlXCIsIHJlY3RhbmdsZSk7XG4gIC8vPj5pbmNsdWRlRW5kKCdkZWJ1ZycpO1xuICB2YXIgbWluTG9uZ2l0dWRlID0gcmVjdGFuZ2xlLndlc3Q7XG4gIHZhciBtYXhMb25naXR1ZGUgPSByZWN0YW5nbGUuZWFzdDtcbiAgdmFyIG1pbkxhdGl0dWRlID0gcmVjdGFuZ2xlLnNvdXRoO1xuICB2YXIgbWF4TGF0aXR1ZGUgPSByZWN0YW5nbGUubm9ydGg7XG5cbiAgd2hpbGUgKG1heExvbmdpdHVkZSA8IG1pbkxvbmdpdHVkZSkge1xuICAgIG1heExvbmdpdHVkZSArPSBDZXNpdW1NYXRoLlRXT19QSTtcbiAgfVxuXG4gIHZhciByYWRpaVNxdWFyZWQgPSB0aGlzLl9yYWRpaVNxdWFyZWQ7XG4gIHZhciBhMiA9IHJhZGlpU3F1YXJlZC54O1xuICB2YXIgYjIgPSByYWRpaVNxdWFyZWQueTtcbiAgdmFyIGMyID0gcmFkaWlTcXVhcmVkLno7XG4gIHZhciBhMmIyID0gYTIgKiBiMjtcbiAgcmV0dXJuIGdhdXNzTGVnZW5kcmVRdWFkcmF0dXJlKG1pbkxhdGl0dWRlLCBtYXhMYXRpdHVkZSwgZnVuY3Rpb24gKGxhdCkge1xuICAgIC8vIHBoaSByZXByZXNlbnRzIHRoZSBhbmdsZSBtZWFzdXJlZCBmcm9tIHRoZSBub3J0aCBwb2xlXG4gICAgLy8gc2luKHBoaSkgPSBzaW4ocGkgLyAyIC0gbGF0KSA9IGNvcyhsYXQpLCBjb3MocGhpKSBpcyBzaW1pbGFyXG4gICAgdmFyIHNpblBoaSA9IE1hdGguY29zKGxhdCk7XG4gICAgdmFyIGNvc1BoaSA9IE1hdGguc2luKGxhdCk7XG4gICAgcmV0dXJuIChcbiAgICAgIE1hdGguY29zKGxhdCkgKlxuICAgICAgZ2F1c3NMZWdlbmRyZVF1YWRyYXR1cmUobWluTG9uZ2l0dWRlLCBtYXhMb25naXR1ZGUsIGZ1bmN0aW9uIChsb24pIHtcbiAgICAgICAgdmFyIGNvc1RoZXRhID0gTWF0aC5jb3MobG9uKTtcbiAgICAgICAgdmFyIHNpblRoZXRhID0gTWF0aC5zaW4obG9uKTtcbiAgICAgICAgcmV0dXJuIE1hdGguc3FydChcbiAgICAgICAgICBhMmIyICogY29zUGhpICogY29zUGhpICtcbiAgICAgICAgICAgIGMyICpcbiAgICAgICAgICAgICAgKGIyICogY29zVGhldGEgKiBjb3NUaGV0YSArIGEyICogc2luVGhldGEgKiBzaW5UaGV0YSkgKlxuICAgICAgICAgICAgICBzaW5QaGkgKlxuICAgICAgICAgICAgICBzaW5QaGlcbiAgICAgICAgKTtcbiAgICAgIH0pXG4gICAgKTtcbiAgfSk7XG59O1xuXG5leHBvcnQgZGVmYXVsdCBFbGxpcHNvaWQ7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///50491\n')},39043:function(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__){eval('/* harmony import */ var _Cartesian3_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(60216);\n/* harmony import */ var _Cartographic_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(51688);\n/* harmony import */ var _Check_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(66553);\n/* harmony import */ var _defaultValue_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(62200);\n/* harmony import */ var _defined_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(82982);\n/* harmony import */ var _Ellipsoid_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(50491);\n/* harmony import */ var _Math_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(99417);\n\n\n\n\n\n\n\n\nfunction setConstants(ellipsoidGeodesic) {\n  var uSquared = ellipsoidGeodesic._uSquared;\n  var a = ellipsoidGeodesic._ellipsoid.maximumRadius;\n  var b = ellipsoidGeodesic._ellipsoid.minimumRadius;\n  var f = (a - b) / a;\n\n  var cosineHeading = Math.cos(ellipsoidGeodesic._startHeading);\n  var sineHeading = Math.sin(ellipsoidGeodesic._startHeading);\n\n  var tanU = (1 - f) * Math.tan(ellipsoidGeodesic._start.latitude);\n\n  var cosineU = 1.0 / Math.sqrt(1.0 + tanU * tanU);\n  var sineU = cosineU * tanU;\n\n  var sigma = Math.atan2(tanU, cosineHeading);\n\n  var sineAlpha = cosineU * sineHeading;\n  var sineSquaredAlpha = sineAlpha * sineAlpha;\n\n  var cosineSquaredAlpha = 1.0 - sineSquaredAlpha;\n  var cosineAlpha = Math.sqrt(cosineSquaredAlpha);\n\n  var u2Over4 = uSquared / 4.0;\n  var u4Over16 = u2Over4 * u2Over4;\n  var u6Over64 = u4Over16 * u2Over4;\n  var u8Over256 = u4Over16 * u4Over16;\n\n  var a0 =\n    1.0 +\n    u2Over4 -\n    (3.0 * u4Over16) / 4.0 +\n    (5.0 * u6Over64) / 4.0 -\n    (175.0 * u8Over256) / 64.0;\n  var a1 = 1.0 - u2Over4 + (15.0 * u4Over16) / 8.0 - (35.0 * u6Over64) / 8.0;\n  var a2 = 1.0 - 3.0 * u2Over4 + (35.0 * u4Over16) / 4.0;\n  var a3 = 1.0 - 5.0 * u2Over4;\n\n  var distanceRatio =\n    a0 * sigma -\n    (a1 * Math.sin(2.0 * sigma) * u2Over4) / 2.0 -\n    (a2 * Math.sin(4.0 * sigma) * u4Over16) / 16.0 -\n    (a3 * Math.sin(6.0 * sigma) * u6Over64) / 48.0 -\n    (Math.sin(8.0 * sigma) * 5.0 * u8Over256) / 512;\n\n  var constants = ellipsoidGeodesic._constants;\n\n  constants.a = a;\n  constants.b = b;\n  constants.f = f;\n  constants.cosineHeading = cosineHeading;\n  constants.sineHeading = sineHeading;\n  constants.tanU = tanU;\n  constants.cosineU = cosineU;\n  constants.sineU = sineU;\n  constants.sigma = sigma;\n  constants.sineAlpha = sineAlpha;\n  constants.sineSquaredAlpha = sineSquaredAlpha;\n  constants.cosineSquaredAlpha = cosineSquaredAlpha;\n  constants.cosineAlpha = cosineAlpha;\n  constants.u2Over4 = u2Over4;\n  constants.u4Over16 = u4Over16;\n  constants.u6Over64 = u6Over64;\n  constants.u8Over256 = u8Over256;\n  constants.a0 = a0;\n  constants.a1 = a1;\n  constants.a2 = a2;\n  constants.a3 = a3;\n  constants.distanceRatio = distanceRatio;\n}\n\nfunction computeC(f, cosineSquaredAlpha) {\n  return (\n    (f * cosineSquaredAlpha * (4.0 + f * (4.0 - 3.0 * cosineSquaredAlpha))) /\n    16.0\n  );\n}\n\nfunction computeDeltaLambda(\n  f,\n  sineAlpha,\n  cosineSquaredAlpha,\n  sigma,\n  sineSigma,\n  cosineSigma,\n  cosineTwiceSigmaMidpoint\n) {\n  var C = computeC(f, cosineSquaredAlpha);\n\n  return (\n    (1.0 - C) *\n    f *\n    sineAlpha *\n    (sigma +\n      C *\n        sineSigma *\n        (cosineTwiceSigmaMidpoint +\n          C *\n            cosineSigma *\n            (2.0 * cosineTwiceSigmaMidpoint * cosineTwiceSigmaMidpoint - 1.0)))\n  );\n}\n\nfunction vincentyInverseFormula(\n  ellipsoidGeodesic,\n  major,\n  minor,\n  firstLongitude,\n  firstLatitude,\n  secondLongitude,\n  secondLatitude\n) {\n  var eff = (major - minor) / major;\n  var l = secondLongitude - firstLongitude;\n\n  var u1 = Math.atan((1 - eff) * Math.tan(firstLatitude));\n  var u2 = Math.atan((1 - eff) * Math.tan(secondLatitude));\n\n  var cosineU1 = Math.cos(u1);\n  var sineU1 = Math.sin(u1);\n  var cosineU2 = Math.cos(u2);\n  var sineU2 = Math.sin(u2);\n\n  var cc = cosineU1 * cosineU2;\n  var cs = cosineU1 * sineU2;\n  var ss = sineU1 * sineU2;\n  var sc = sineU1 * cosineU2;\n\n  var lambda = l;\n  var lambdaDot = _Math_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"].TWO_PI */ .Z.TWO_PI;\n\n  var cosineLambda = Math.cos(lambda);\n  var sineLambda = Math.sin(lambda);\n\n  var sigma;\n  var cosineSigma;\n  var sineSigma;\n  var cosineSquaredAlpha;\n  var cosineTwiceSigmaMidpoint;\n\n  do {\n    cosineLambda = Math.cos(lambda);\n    sineLambda = Math.sin(lambda);\n\n    var temp = cs - sc * cosineLambda;\n    sineSigma = Math.sqrt(\n      cosineU2 * cosineU2 * sineLambda * sineLambda + temp * temp\n    );\n    cosineSigma = ss + cc * cosineLambda;\n\n    sigma = Math.atan2(sineSigma, cosineSigma);\n\n    var sineAlpha;\n\n    if (sineSigma === 0.0) {\n      sineAlpha = 0.0;\n      cosineSquaredAlpha = 1.0;\n    } else {\n      sineAlpha = (cc * sineLambda) / sineSigma;\n      cosineSquaredAlpha = 1.0 - sineAlpha * sineAlpha;\n    }\n\n    lambdaDot = lambda;\n\n    cosineTwiceSigmaMidpoint = cosineSigma - (2.0 * ss) / cosineSquaredAlpha;\n\n    if (!isFinite(cosineTwiceSigmaMidpoint)) {\n      cosineTwiceSigmaMidpoint = 0.0;\n    }\n\n    lambda =\n      l +\n      computeDeltaLambda(\n        eff,\n        sineAlpha,\n        cosineSquaredAlpha,\n        sigma,\n        sineSigma,\n        cosineSigma,\n        cosineTwiceSigmaMidpoint\n      );\n  } while (Math.abs(lambda - lambdaDot) > _Math_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"].EPSILON12 */ .Z.EPSILON12);\n\n  var uSquared =\n    (cosineSquaredAlpha * (major * major - minor * minor)) / (minor * minor);\n  var A =\n    1.0 +\n    (uSquared *\n      (4096.0 + uSquared * (uSquared * (320.0 - 175.0 * uSquared) - 768.0))) /\n      16384.0;\n  var B =\n    (uSquared *\n      (256.0 + uSquared * (uSquared * (74.0 - 47.0 * uSquared) - 128.0))) /\n    1024.0;\n\n  var cosineSquaredTwiceSigmaMidpoint =\n    cosineTwiceSigmaMidpoint * cosineTwiceSigmaMidpoint;\n  var deltaSigma =\n    B *\n    sineSigma *\n    (cosineTwiceSigmaMidpoint +\n      (B *\n        (cosineSigma * (2.0 * cosineSquaredTwiceSigmaMidpoint - 1.0) -\n          (B *\n            cosineTwiceSigmaMidpoint *\n            (4.0 * sineSigma * sineSigma - 3.0) *\n            (4.0 * cosineSquaredTwiceSigmaMidpoint - 3.0)) /\n            6.0)) /\n        4.0);\n\n  var distance = minor * A * (sigma - deltaSigma);\n\n  var startHeading = Math.atan2(cosineU2 * sineLambda, cs - sc * cosineLambda);\n  var endHeading = Math.atan2(cosineU1 * sineLambda, cs * cosineLambda - sc);\n\n  ellipsoidGeodesic._distance = distance;\n  ellipsoidGeodesic._startHeading = startHeading;\n  ellipsoidGeodesic._endHeading = endHeading;\n  ellipsoidGeodesic._uSquared = uSquared;\n}\n\nvar scratchCart1 = new _Cartesian3_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .Z();\nvar scratchCart2 = new _Cartesian3_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .Z();\nfunction computeProperties(ellipsoidGeodesic, start, end, ellipsoid) {\n  var firstCartesian = _Cartesian3_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].normalize */ .Z.normalize(\n    ellipsoid.cartographicToCartesian(start, scratchCart2),\n    scratchCart1\n  );\n  var lastCartesian = _Cartesian3_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].normalize */ .Z.normalize(\n    ellipsoid.cartographicToCartesian(end, scratchCart2),\n    scratchCart2\n  );\n\n  //>>includeStart(\'debug\', pragmas.debug);\n  _Check_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"].typeOf.number.greaterThanOrEquals */ .Z.typeOf.number.greaterThanOrEquals(\n    "value",\n    Math.abs(\n      Math.abs(_Cartesian3_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].angleBetween */ .Z.angleBetween(firstCartesian, lastCartesian)) - Math.PI\n    ),\n    0.0125\n  );\n  //>>includeEnd(\'debug\');\n\n  vincentyInverseFormula(\n    ellipsoidGeodesic,\n    ellipsoid.maximumRadius,\n    ellipsoid.minimumRadius,\n    start.longitude,\n    start.latitude,\n    end.longitude,\n    end.latitude\n  );\n\n  ellipsoidGeodesic._start = _Cartographic_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"].clone */ .Z.clone(\n    start,\n    ellipsoidGeodesic._start\n  );\n  ellipsoidGeodesic._end = _Cartographic_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"].clone */ .Z.clone(end, ellipsoidGeodesic._end);\n  ellipsoidGeodesic._start.height = 0;\n  ellipsoidGeodesic._end.height = 0;\n\n  setConstants(ellipsoidGeodesic);\n}\n\n/**\n * Initializes a geodesic on the ellipsoid connecting the two provided planetodetic points.\n *\n * @alias EllipsoidGeodesic\n * @constructor\n *\n * @param {Cartographic} [start] The initial planetodetic point on the path.\n * @param {Cartographic} [end] The final planetodetic point on the path.\n * @param {Ellipsoid} [ellipsoid=Ellipsoid.WGS84] The ellipsoid on which the geodesic lies.\n */\nfunction EllipsoidGeodesic(start, end, ellipsoid) {\n  var e = (0,_defaultValue_js__WEBPACK_IMPORTED_MODULE_3__/* ["default"] */ .Z)(ellipsoid, _Ellipsoid_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"].WGS84 */ .Z.WGS84);\n  this._ellipsoid = e;\n  this._start = new _Cartographic_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .Z();\n  this._end = new _Cartographic_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .Z();\n\n  this._constants = {};\n  this._startHeading = undefined;\n  this._endHeading = undefined;\n  this._distance = undefined;\n  this._uSquared = undefined;\n\n  if ((0,_defined_js__WEBPACK_IMPORTED_MODULE_6__/* ["default"] */ .Z)(start) && (0,_defined_js__WEBPACK_IMPORTED_MODULE_6__/* ["default"] */ .Z)(end)) {\n    computeProperties(this, start, end, e);\n  }\n}\n\nObject.defineProperties(EllipsoidGeodesic.prototype, {\n  /**\n   * Gets the ellipsoid.\n   * @memberof EllipsoidGeodesic.prototype\n   * @type {Ellipsoid}\n   * @readonly\n   */\n  ellipsoid: {\n    get: function () {\n      return this._ellipsoid;\n    },\n  },\n\n  /**\n   * Gets the surface distance between the start and end point\n   * @memberof EllipsoidGeodesic.prototype\n   * @type {Number}\n   * @readonly\n   */\n  surfaceDistance: {\n    get: function () {\n      //>>includeStart(\'debug\', pragmas.debug);\n      _Check_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"].defined */ .Z.defined("distance", this._distance);\n      //>>includeEnd(\'debug\');\n\n      return this._distance;\n    },\n  },\n\n  /**\n   * Gets the initial planetodetic point on the path.\n   * @memberof EllipsoidGeodesic.prototype\n   * @type {Cartographic}\n   * @readonly\n   */\n  start: {\n    get: function () {\n      return this._start;\n    },\n  },\n\n  /**\n   * Gets the final planetodetic point on the path.\n   * @memberof EllipsoidGeodesic.prototype\n   * @type {Cartographic}\n   * @readonly\n   */\n  end: {\n    get: function () {\n      return this._end;\n    },\n  },\n\n  /**\n   * Gets the heading at the initial point.\n   * @memberof EllipsoidGeodesic.prototype\n   * @type {Number}\n   * @readonly\n   */\n  startHeading: {\n    get: function () {\n      //>>includeStart(\'debug\', pragmas.debug);\n      _Check_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"].defined */ .Z.defined("distance", this._distance);\n      //>>includeEnd(\'debug\');\n\n      return this._startHeading;\n    },\n  },\n\n  /**\n   * Gets the heading at the final point.\n   * @memberof EllipsoidGeodesic.prototype\n   * @type {Number}\n   * @readonly\n   */\n  endHeading: {\n    get: function () {\n      //>>includeStart(\'debug\', pragmas.debug);\n      _Check_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"].defined */ .Z.defined("distance", this._distance);\n      //>>includeEnd(\'debug\');\n\n      return this._endHeading;\n    },\n  },\n});\n\n/**\n * Sets the start and end points of the geodesic\n *\n * @param {Cartographic} start The initial planetodetic point on the path.\n * @param {Cartographic} end The final planetodetic point on the path.\n */\nEllipsoidGeodesic.prototype.setEndPoints = function (start, end) {\n  //>>includeStart(\'debug\', pragmas.debug);\n  _Check_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"].defined */ .Z.defined("start", start);\n  _Check_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"].defined */ .Z.defined("end", end);\n  //>>includeEnd(\'debug\');\n\n  computeProperties(this, start, end, this._ellipsoid);\n};\n\n/**\n * Provides the location of a point at the indicated portion along the geodesic.\n *\n * @param {Number} fraction The portion of the distance between the initial and final points.\n * @param {Cartographic} [result] The object in which to store the result.\n * @returns {Cartographic} The location of the point along the geodesic.\n */\nEllipsoidGeodesic.prototype.interpolateUsingFraction = function (\n  fraction,\n  result\n) {\n  return this.interpolateUsingSurfaceDistance(\n    this._distance * fraction,\n    result\n  );\n};\n\n/**\n * Provides the location of a point at the indicated distance along the geodesic.\n *\n * @param {Number} distance The distance from the inital point to the point of interest along the geodesic\n * @param {Cartographic} [result] The object in which to store the result.\n * @returns {Cartographic} The location of the point along the geodesic.\n *\n * @exception {DeveloperError} start and end must be set before calling function interpolateUsingSurfaceDistance\n */\nEllipsoidGeodesic.prototype.interpolateUsingSurfaceDistance = function (\n  distance,\n  result\n) {\n  //>>includeStart(\'debug\', pragmas.debug);\n  _Check_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"].defined */ .Z.defined("distance", this._distance);\n  //>>includeEnd(\'debug\');\n\n  var constants = this._constants;\n\n  var s = constants.distanceRatio + distance / constants.b;\n\n  var cosine2S = Math.cos(2.0 * s);\n  var cosine4S = Math.cos(4.0 * s);\n  var cosine6S = Math.cos(6.0 * s);\n  var sine2S = Math.sin(2.0 * s);\n  var sine4S = Math.sin(4.0 * s);\n  var sine6S = Math.sin(6.0 * s);\n  var sine8S = Math.sin(8.0 * s);\n\n  var s2 = s * s;\n  var s3 = s * s2;\n\n  var u8Over256 = constants.u8Over256;\n  var u2Over4 = constants.u2Over4;\n  var u6Over64 = constants.u6Over64;\n  var u4Over16 = constants.u4Over16;\n  var sigma =\n    (2.0 * s3 * u8Over256 * cosine2S) / 3.0 +\n    s *\n      (1.0 -\n        u2Over4 +\n        (7.0 * u4Over16) / 4.0 -\n        (15.0 * u6Over64) / 4.0 +\n        (579.0 * u8Over256) / 64.0 -\n        (u4Over16 - (15.0 * u6Over64) / 4.0 + (187.0 * u8Over256) / 16.0) *\n          cosine2S -\n        ((5.0 * u6Over64) / 4.0 - (115.0 * u8Over256) / 16.0) * cosine4S -\n        (29.0 * u8Over256 * cosine6S) / 16.0) +\n    (u2Over4 / 2.0 -\n      u4Over16 +\n      (71.0 * u6Over64) / 32.0 -\n      (85.0 * u8Over256) / 16.0) *\n      sine2S +\n    ((5.0 * u4Over16) / 16.0 -\n      (5.0 * u6Over64) / 4.0 +\n      (383.0 * u8Over256) / 96.0) *\n      sine4S -\n    s2 *\n      ((u6Over64 - (11.0 * u8Over256) / 2.0) * sine2S +\n        (5.0 * u8Over256 * sine4S) / 2.0) +\n    ((29.0 * u6Over64) / 96.0 - (29.0 * u8Over256) / 16.0) * sine6S +\n    (539.0 * u8Over256 * sine8S) / 1536.0;\n\n  var theta = Math.asin(Math.sin(sigma) * constants.cosineAlpha);\n  var latitude = Math.atan((constants.a / constants.b) * Math.tan(theta));\n\n  // Redefine in terms of relative argument of latitude.\n  sigma = sigma - constants.sigma;\n\n  var cosineTwiceSigmaMidpoint = Math.cos(2.0 * constants.sigma + sigma);\n\n  var sineSigma = Math.sin(sigma);\n  var cosineSigma = Math.cos(sigma);\n\n  var cc = constants.cosineU * cosineSigma;\n  var ss = constants.sineU * sineSigma;\n\n  var lambda = Math.atan2(\n    sineSigma * constants.sineHeading,\n    cc - ss * constants.cosineHeading\n  );\n\n  var l =\n    lambda -\n    computeDeltaLambda(\n      constants.f,\n      constants.sineAlpha,\n      constants.cosineSquaredAlpha,\n      sigma,\n      sineSigma,\n      cosineSigma,\n      cosineTwiceSigmaMidpoint\n    );\n\n  if ((0,_defined_js__WEBPACK_IMPORTED_MODULE_6__/* ["default"] */ .Z)(result)) {\n    result.longitude = this._start.longitude + l;\n    result.latitude = latitude;\n    result.height = 0.0;\n    return result;\n  }\n\n  return new _Cartographic_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .Z(this._start.longitude + l, latitude, 0.0);\n};\n/* harmony default export */ __webpack_exports__["Z"] = (EllipsoidGeodesic);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsTUFBTSxnRUFBTztBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsYUFBYSxpRUFBWTtBQUN6QjtBQUNBLHlEQUFlLGlCQUFpQixFQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdnVlMy13ZWJwYWNrNS8uL25vZGVfbW9kdWxlcy9jZXNpdW0vU291cmNlL0NvcmUvRWxsaXBzb2lkR2VvZGVzaWMuanM/OWUwOCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgQ2FydGVzaWFuMyBmcm9tIFwiLi9DYXJ0ZXNpYW4zLmpzXCI7XG5pbXBvcnQgQ2FydG9ncmFwaGljIGZyb20gXCIuL0NhcnRvZ3JhcGhpYy5qc1wiO1xuaW1wb3J0IENoZWNrIGZyb20gXCIuL0NoZWNrLmpzXCI7XG5pbXBvcnQgZGVmYXVsdFZhbHVlIGZyb20gXCIuL2RlZmF1bHRWYWx1ZS5qc1wiO1xuaW1wb3J0IGRlZmluZWQgZnJvbSBcIi4vZGVmaW5lZC5qc1wiO1xuaW1wb3J0IEVsbGlwc29pZCBmcm9tIFwiLi9FbGxpcHNvaWQuanNcIjtcbmltcG9ydCBDZXNpdW1NYXRoIGZyb20gXCIuL01hdGguanNcIjtcblxuZnVuY3Rpb24gc2V0Q29uc3RhbnRzKGVsbGlwc29pZEdlb2Rlc2ljKSB7XG4gIHZhciB1U3F1YXJlZCA9IGVsbGlwc29pZEdlb2Rlc2ljLl91U3F1YXJlZDtcbiAgdmFyIGEgPSBlbGxpcHNvaWRHZW9kZXNpYy5fZWxsaXBzb2lkLm1heGltdW1SYWRpdXM7XG4gIHZhciBiID0gZWxsaXBzb2lkR2VvZGVzaWMuX2VsbGlwc29pZC5taW5pbXVtUmFkaXVzO1xuICB2YXIgZiA9IChhIC0gYikgLyBhO1xuXG4gIHZhciBjb3NpbmVIZWFkaW5nID0gTWF0aC5jb3MoZWxsaXBzb2lkR2VvZGVzaWMuX3N0YXJ0SGVhZGluZyk7XG4gIHZhciBzaW5lSGVhZGluZyA9IE1hdGguc2luKGVsbGlwc29pZEdlb2Rlc2ljLl9zdGFydEhlYWRpbmcpO1xuXG4gIHZhciB0YW5VID0gKDEgLSBmKSAqIE1hdGgudGFuKGVsbGlwc29pZEdlb2Rlc2ljLl9zdGFydC5sYXRpdHVkZSk7XG5cbiAgdmFyIGNvc2luZVUgPSAxLjAgLyBNYXRoLnNxcnQoMS4wICsgdGFuVSAqIHRhblUpO1xuICB2YXIgc2luZVUgPSBjb3NpbmVVICogdGFuVTtcblxuICB2YXIgc2lnbWEgPSBNYXRoLmF0YW4yKHRhblUsIGNvc2luZUhlYWRpbmcpO1xuXG4gIHZhciBzaW5lQWxwaGEgPSBjb3NpbmVVICogc2luZUhlYWRpbmc7XG4gIHZhciBzaW5lU3F1YXJlZEFscGhhID0gc2luZUFscGhhICogc2luZUFscGhhO1xuXG4gIHZhciBjb3NpbmVTcXVhcmVkQWxwaGEgPSAxLjAgLSBzaW5lU3F1YXJlZEFscGhhO1xuICB2YXIgY29zaW5lQWxwaGEgPSBNYXRoLnNxcnQoY29zaW5lU3F1YXJlZEFscGhhKTtcblxuICB2YXIgdTJPdmVyNCA9IHVTcXVhcmVkIC8gNC4wO1xuICB2YXIgdTRPdmVyMTYgPSB1Mk92ZXI0ICogdTJPdmVyNDtcbiAgdmFyIHU2T3ZlcjY0ID0gdTRPdmVyMTYgKiB1Mk92ZXI0O1xuICB2YXIgdThPdmVyMjU2ID0gdTRPdmVyMTYgKiB1NE92ZXIxNjtcblxuICB2YXIgYTAgPVxuICAgIDEuMCArXG4gICAgdTJPdmVyNCAtXG4gICAgKDMuMCAqIHU0T3ZlcjE2KSAvIDQuMCArXG4gICAgKDUuMCAqIHU2T3ZlcjY0KSAvIDQuMCAtXG4gICAgKDE3NS4wICogdThPdmVyMjU2KSAvIDY0LjA7XG4gIHZhciBhMSA9IDEuMCAtIHUyT3ZlcjQgKyAoMTUuMCAqIHU0T3ZlcjE2KSAvIDguMCAtICgzNS4wICogdTZPdmVyNjQpIC8gOC4wO1xuICB2YXIgYTIgPSAxLjAgLSAzLjAgKiB1Mk92ZXI0ICsgKDM1LjAgKiB1NE92ZXIxNikgLyA0LjA7XG4gIHZhciBhMyA9IDEuMCAtIDUuMCAqIHUyT3ZlcjQ7XG5cbiAgdmFyIGRpc3RhbmNlUmF0aW8gPVxuICAgIGEwICogc2lnbWEgLVxuICAgIChhMSAqIE1hdGguc2luKDIuMCAqIHNpZ21hKSAqIHUyT3ZlcjQpIC8gMi4wIC1cbiAgICAoYTIgKiBNYXRoLnNpbig0LjAgKiBzaWdtYSkgKiB1NE92ZXIxNikgLyAxNi4wIC1cbiAgICAoYTMgKiBNYXRoLnNpbig2LjAgKiBzaWdtYSkgKiB1Nk92ZXI2NCkgLyA0OC4wIC1cbiAgICAoTWF0aC5zaW4oOC4wICogc2lnbWEpICogNS4wICogdThPdmVyMjU2KSAvIDUxMjtcblxuICB2YXIgY29uc3RhbnRzID0gZWxsaXBzb2lkR2VvZGVzaWMuX2NvbnN0YW50cztcblxuICBjb25zdGFudHMuYSA9IGE7XG4gIGNvbnN0YW50cy5iID0gYjtcbiAgY29uc3RhbnRzLmYgPSBmO1xuICBjb25zdGFudHMuY29zaW5lSGVhZGluZyA9IGNvc2luZUhlYWRpbmc7XG4gIGNvbnN0YW50cy5zaW5lSGVhZGluZyA9IHNpbmVIZWFkaW5nO1xuICBjb25zdGFudHMudGFuVSA9IHRhblU7XG4gIGNvbnN0YW50cy5jb3NpbmVVID0gY29zaW5lVTtcbiAgY29uc3RhbnRzLnNpbmVVID0gc2luZVU7XG4gIGNvbnN0YW50cy5zaWdtYSA9IHNpZ21hO1xuICBjb25zdGFudHMuc2luZUFscGhhID0gc2luZUFscGhhO1xuICBjb25zdGFudHMuc2luZVNxdWFyZWRBbHBoYSA9IHNpbmVTcXVhcmVkQWxwaGE7XG4gIGNvbnN0YW50cy5jb3NpbmVTcXVhcmVkQWxwaGEgPSBjb3NpbmVTcXVhcmVkQWxwaGE7XG4gIGNvbnN0YW50cy5jb3NpbmVBbHBoYSA9IGNvc2luZUFscGhhO1xuICBjb25zdGFudHMudTJPdmVyNCA9IHUyT3ZlcjQ7XG4gIGNvbnN0YW50cy51NE92ZXIxNiA9IHU0T3ZlcjE2O1xuICBjb25zdGFudHMudTZPdmVyNjQgPSB1Nk92ZXI2NDtcbiAgY29uc3RhbnRzLnU4T3ZlcjI1NiA9IHU4T3ZlcjI1NjtcbiAgY29uc3RhbnRzLmEwID0gYTA7XG4gIGNvbnN0YW50cy5hMSA9IGExO1xuICBjb25zdGFudHMuYTIgPSBhMjtcbiAgY29uc3RhbnRzLmEzID0gYTM7XG4gIGNvbnN0YW50cy5kaXN0YW5jZVJhdGlvID0gZGlzdGFuY2VSYXRpbztcbn1cblxuZnVuY3Rpb24gY29tcHV0ZUMoZiwgY29zaW5lU3F1YXJlZEFscGhhKSB7XG4gIHJldHVybiAoXG4gICAgKGYgKiBjb3NpbmVTcXVhcmVkQWxwaGEgKiAoNC4wICsgZiAqICg0LjAgLSAzLjAgKiBjb3NpbmVTcXVhcmVkQWxwaGEpKSkgL1xuICAgIDE2LjBcbiAgKTtcbn1cblxuZnVuY3Rpb24gY29tcHV0ZURlbHRhTGFtYmRhKFxuICBmLFxuICBzaW5lQWxwaGEsXG4gIGNvc2luZVNxdWFyZWRBbHBoYSxcbiAgc2lnbWEsXG4gIHNpbmVTaWdtYSxcbiAgY29zaW5lU2lnbWEsXG4gIGNvc2luZVR3aWNlU2lnbWFNaWRwb2ludFxuKSB7XG4gIHZhciBDID0gY29tcHV0ZUMoZiwgY29zaW5lU3F1YXJlZEFscGhhKTtcblxuICByZXR1cm4gKFxuICAgICgxLjAgLSBDKSAqXG4gICAgZiAqXG4gICAgc2luZUFscGhhICpcbiAgICAoc2lnbWEgK1xuICAgICAgQyAqXG4gICAgICAgIHNpbmVTaWdtYSAqXG4gICAgICAgIChjb3NpbmVUd2ljZVNpZ21hTWlkcG9pbnQgK1xuICAgICAgICAgIEMgKlxuICAgICAgICAgICAgY29zaW5lU2lnbWEgKlxuICAgICAgICAgICAgKDIuMCAqIGNvc2luZVR3aWNlU2lnbWFNaWRwb2ludCAqIGNvc2luZVR3aWNlU2lnbWFNaWRwb2ludCAtIDEuMCkpKVxuICApO1xufVxuXG5mdW5jdGlvbiB2aW5jZW50eUludmVyc2VGb3JtdWxhKFxuICBlbGxpcHNvaWRHZW9kZXNpYyxcbiAgbWFqb3IsXG4gIG1pbm9yLFxuICBmaXJzdExvbmdpdHVkZSxcbiAgZmlyc3RMYXRpdHVkZSxcbiAgc2Vjb25kTG9uZ2l0dWRlLFxuICBzZWNvbmRMYXRpdHVkZVxuKSB7XG4gIHZhciBlZmYgPSAobWFqb3IgLSBtaW5vcikgLyBtYWpvcjtcbiAgdmFyIGwgPSBzZWNvbmRMb25naXR1ZGUgLSBmaXJzdExvbmdpdHVkZTtcblxuICB2YXIgdTEgPSBNYXRoLmF0YW4oKDEgLSBlZmYpICogTWF0aC50YW4oZmlyc3RMYXRpdHVkZSkpO1xuICB2YXIgdTIgPSBNYXRoLmF0YW4oKDEgLSBlZmYpICogTWF0aC50YW4oc2Vjb25kTGF0aXR1ZGUpKTtcblxuICB2YXIgY29zaW5lVTEgPSBNYXRoLmNvcyh1MSk7XG4gIHZhciBzaW5lVTEgPSBNYXRoLnNpbih1MSk7XG4gIHZhciBjb3NpbmVVMiA9IE1hdGguY29zKHUyKTtcbiAgdmFyIHNpbmVVMiA9IE1hdGguc2luKHUyKTtcblxuICB2YXIgY2MgPSBjb3NpbmVVMSAqIGNvc2luZVUyO1xuICB2YXIgY3MgPSBjb3NpbmVVMSAqIHNpbmVVMjtcbiAgdmFyIHNzID0gc2luZVUxICogc2luZVUyO1xuICB2YXIgc2MgPSBzaW5lVTEgKiBjb3NpbmVVMjtcblxuICB2YXIgbGFtYmRhID0gbDtcbiAgdmFyIGxhbWJkYURvdCA9IENlc2l1bU1hdGguVFdPX1BJO1xuXG4gIHZhciBjb3NpbmVMYW1iZGEgPSBNYXRoLmNvcyhsYW1iZGEpO1xuICB2YXIgc2luZUxhbWJkYSA9IE1hdGguc2luKGxhbWJkYSk7XG5cbiAgdmFyIHNpZ21hO1xuICB2YXIgY29zaW5lU2lnbWE7XG4gIHZhciBzaW5lU2lnbWE7XG4gIHZhciBjb3NpbmVTcXVhcmVkQWxwaGE7XG4gIHZhciBjb3NpbmVUd2ljZVNpZ21hTWlkcG9pbnQ7XG5cbiAgZG8ge1xuICAgIGNvc2luZUxhbWJkYSA9IE1hdGguY29zKGxhbWJkYSk7XG4gICAgc2luZUxhbWJkYSA9IE1hdGguc2luKGxhbWJkYSk7XG5cbiAgICB2YXIgdGVtcCA9IGNzIC0gc2MgKiBjb3NpbmVMYW1iZGE7XG4gICAgc2luZVNpZ21hID0gTWF0aC5zcXJ0KFxuICAgICAgY29zaW5lVTIgKiBjb3NpbmVVMiAqIHNpbmVMYW1iZGEgKiBzaW5lTGFtYmRhICsgdGVtcCAqIHRlbXBcbiAgICApO1xuICAgIGNvc2luZVNpZ21hID0gc3MgKyBjYyAqIGNvc2luZUxhbWJkYTtcblxuICAgIHNpZ21hID0gTWF0aC5hdGFuMihzaW5lU2lnbWEsIGNvc2luZVNpZ21hKTtcblxuICAgIHZhciBzaW5lQWxwaGE7XG5cbiAgICBpZiAoc2luZVNpZ21hID09PSAwLjApIHtcbiAgICAgIHNpbmVBbHBoYSA9IDAuMDtcbiAgICAgIGNvc2luZVNxdWFyZWRBbHBoYSA9IDEuMDtcbiAgICB9IGVsc2Uge1xuICAgICAgc2luZUFscGhhID0gKGNjICogc2luZUxhbWJkYSkgLyBzaW5lU2lnbWE7XG4gICAgICBjb3NpbmVTcXVhcmVkQWxwaGEgPSAxLjAgLSBzaW5lQWxwaGEgKiBzaW5lQWxwaGE7XG4gICAgfVxuXG4gICAgbGFtYmRhRG90ID0gbGFtYmRhO1xuXG4gICAgY29zaW5lVHdpY2VTaWdtYU1pZHBvaW50ID0gY29zaW5lU2lnbWEgLSAoMi4wICogc3MpIC8gY29zaW5lU3F1YXJlZEFscGhhO1xuXG4gICAgaWYgKCFpc0Zpbml0ZShjb3NpbmVUd2ljZVNpZ21hTWlkcG9pbnQpKSB7XG4gICAgICBjb3NpbmVUd2ljZVNpZ21hTWlkcG9pbnQgPSAwLjA7XG4gICAgfVxuXG4gICAgbGFtYmRhID1cbiAgICAgIGwgK1xuICAgICAgY29tcHV0ZURlbHRhTGFtYmRhKFxuICAgICAgICBlZmYsXG4gICAgICAgIHNpbmVBbHBoYSxcbiAgICAgICAgY29zaW5lU3F1YXJlZEFscGhhLFxuICAgICAgICBzaWdtYSxcbiAgICAgICAgc2luZVNpZ21hLFxuICAgICAgICBjb3NpbmVTaWdtYSxcbiAgICAgICAgY29zaW5lVHdpY2VTaWdtYU1pZHBvaW50XG4gICAgICApO1xuICB9IHdoaWxlIChNYXRoLmFicyhsYW1iZGEgLSBsYW1iZGFEb3QpID4gQ2VzaXVtTWF0aC5FUFNJTE9OMTIpO1xuXG4gIHZhciB1U3F1YXJlZCA9XG4gICAgKGNvc2luZVNxdWFyZWRBbHBoYSAqIChtYWpvciAqIG1ham9yIC0gbWlub3IgKiBtaW5vcikpIC8gKG1pbm9yICogbWlub3IpO1xuICB2YXIgQSA9XG4gICAgMS4wICtcbiAgICAodVNxdWFyZWQgKlxuICAgICAgKDQwOTYuMCArIHVTcXVhcmVkICogKHVTcXVhcmVkICogKDMyMC4wIC0gMTc1LjAgKiB1U3F1YXJlZCkgLSA3NjguMCkpKSAvXG4gICAgICAxNjM4NC4wO1xuICB2YXIgQiA9XG4gICAgKHVTcXVhcmVkICpcbiAgICAgICgyNTYuMCArIHVTcXVhcmVkICogKHVTcXVhcmVkICogKDc0LjAgLSA0Ny4wICogdVNxdWFyZWQpIC0gMTI4LjApKSkgL1xuICAgIDEwMjQuMDtcblxuICB2YXIgY29zaW5lU3F1YXJlZFR3aWNlU2lnbWFNaWRwb2ludCA9XG4gICAgY29zaW5lVHdpY2VTaWdtYU1pZHBvaW50ICogY29zaW5lVHdpY2VTaWdtYU1pZHBvaW50O1xuICB2YXIgZGVsdGFTaWdtYSA9XG4gICAgQiAqXG4gICAgc2luZVNpZ21hICpcbiAgICAoY29zaW5lVHdpY2VTaWdtYU1pZHBvaW50ICtcbiAgICAgIChCICpcbiAgICAgICAgKGNvc2luZVNpZ21hICogKDIuMCAqIGNvc2luZVNxdWFyZWRUd2ljZVNpZ21hTWlkcG9pbnQgLSAxLjApIC1cbiAgICAgICAgICAoQiAqXG4gICAgICAgICAgICBjb3NpbmVUd2ljZVNpZ21hTWlkcG9pbnQgKlxuICAgICAgICAgICAgKDQuMCAqIHNpbmVTaWdtYSAqIHNpbmVTaWdtYSAtIDMuMCkgKlxuICAgICAgICAgICAgKDQuMCAqIGNvc2luZVNxdWFyZWRUd2ljZVNpZ21hTWlkcG9pbnQgLSAzLjApKSAvXG4gICAgICAgICAgICA2LjApKSAvXG4gICAgICAgIDQuMCk7XG5cbiAgdmFyIGRpc3RhbmNlID0gbWlub3IgKiBBICogKHNpZ21hIC0gZGVsdGFTaWdtYSk7XG5cbiAgdmFyIHN0YXJ0SGVhZGluZyA9IE1hdGguYXRhbjIoY29zaW5lVTIgKiBzaW5lTGFtYmRhLCBjcyAtIHNjICogY29zaW5lTGFtYmRhKTtcbiAgdmFyIGVuZEhlYWRpbmcgPSBNYXRoLmF0YW4yKGNvc2luZVUxICogc2luZUxhbWJkYSwgY3MgKiBjb3NpbmVMYW1iZGEgLSBzYyk7XG5cbiAgZWxsaXBzb2lkR2VvZGVzaWMuX2Rpc3RhbmNlID0gZGlzdGFuY2U7XG4gIGVsbGlwc29pZEdlb2Rlc2ljLl9zdGFydEhlYWRpbmcgPSBzdGFydEhlYWRpbmc7XG4gIGVsbGlwc29pZEdlb2Rlc2ljLl9lbmRIZWFkaW5nID0gZW5kSGVhZGluZztcbiAgZWxsaXBzb2lkR2VvZGVzaWMuX3VTcXVhcmVkID0gdVNxdWFyZWQ7XG59XG5cbnZhciBzY3JhdGNoQ2FydDEgPSBuZXcgQ2FydGVzaWFuMygpO1xudmFyIHNjcmF0Y2hDYXJ0MiA9IG5ldyBDYXJ0ZXNpYW4zKCk7XG5mdW5jdGlvbiBjb21wdXRlUHJvcGVydGllcyhlbGxpcHNvaWRHZW9kZXNpYywgc3RhcnQsIGVuZCwgZWxsaXBzb2lkKSB7XG4gIHZhciBmaXJzdENhcnRlc2lhbiA9IENhcnRlc2lhbjMubm9ybWFsaXplKFxuICAgIGVsbGlwc29pZC5jYXJ0b2dyYXBoaWNUb0NhcnRlc2lhbihzdGFydCwgc2NyYXRjaENhcnQyKSxcbiAgICBzY3JhdGNoQ2FydDFcbiAgKTtcbiAgdmFyIGxhc3RDYXJ0ZXNpYW4gPSBDYXJ0ZXNpYW4zLm5vcm1hbGl6ZShcbiAgICBlbGxpcHNvaWQuY2FydG9ncmFwaGljVG9DYXJ0ZXNpYW4oZW5kLCBzY3JhdGNoQ2FydDIpLFxuICAgIHNjcmF0Y2hDYXJ0MlxuICApO1xuXG4gIC8vPj5pbmNsdWRlU3RhcnQoJ2RlYnVnJywgcHJhZ21hcy5kZWJ1Zyk7XG4gIENoZWNrLnR5cGVPZi5udW1iZXIuZ3JlYXRlclRoYW5PckVxdWFscyhcbiAgICBcInZhbHVlXCIsXG4gICAgTWF0aC5hYnMoXG4gICAgICBNYXRoLmFicyhDYXJ0ZXNpYW4zLmFuZ2xlQmV0d2VlbihmaXJzdENhcnRlc2lhbiwgbGFzdENhcnRlc2lhbikpIC0gTWF0aC5QSVxuICAgICksXG4gICAgMC4wMTI1XG4gICk7XG4gIC8vPj5pbmNsdWRlRW5kKCdkZWJ1ZycpO1xuXG4gIHZpbmNlbnR5SW52ZXJzZUZvcm11bGEoXG4gICAgZWxsaXBzb2lkR2VvZGVzaWMsXG4gICAgZWxsaXBzb2lkLm1heGltdW1SYWRpdXMsXG4gICAgZWxsaXBzb2lkLm1pbmltdW1SYWRpdXMsXG4gICAgc3RhcnQubG9uZ2l0dWRlLFxuICAgIHN0YXJ0LmxhdGl0dWRlLFxuICAgIGVuZC5sb25naXR1ZGUsXG4gICAgZW5kLmxhdGl0dWRlXG4gICk7XG5cbiAgZWxsaXBzb2lkR2VvZGVzaWMuX3N0YXJ0ID0gQ2FydG9ncmFwaGljLmNsb25lKFxuICAgIHN0YXJ0LFxuICAgIGVsbGlwc29pZEdlb2Rlc2ljLl9zdGFydFxuICApO1xuICBlbGxpcHNvaWRHZW9kZXNpYy5fZW5kID0gQ2FydG9ncmFwaGljLmNsb25lKGVuZCwgZWxsaXBzb2lkR2VvZGVzaWMuX2VuZCk7XG4gIGVsbGlwc29pZEdlb2Rlc2ljLl9zdGFydC5oZWlnaHQgPSAwO1xuICBlbGxpcHNvaWRHZW9kZXNpYy5fZW5kLmhlaWdodCA9IDA7XG5cbiAgc2V0Q29uc3RhbnRzKGVsbGlwc29pZEdlb2Rlc2ljKTtcbn1cblxuLyoqXG4gKiBJbml0aWFsaXplcyBhIGdlb2Rlc2ljIG9uIHRoZSBlbGxpcHNvaWQgY29ubmVjdGluZyB0aGUgdHdvIHByb3ZpZGVkIHBsYW5ldG9kZXRpYyBwb2ludHMuXG4gKlxuICogQGFsaWFzIEVsbGlwc29pZEdlb2Rlc2ljXG4gKiBAY29uc3RydWN0b3JcbiAqXG4gKiBAcGFyYW0ge0NhcnRvZ3JhcGhpY30gW3N0YXJ0XSBUaGUgaW5pdGlhbCBwbGFuZXRvZGV0aWMgcG9pbnQgb24gdGhlIHBhdGguXG4gKiBAcGFyYW0ge0NhcnRvZ3JhcGhpY30gW2VuZF0gVGhlIGZpbmFsIHBsYW5ldG9kZXRpYyBwb2ludCBvbiB0aGUgcGF0aC5cbiAqIEBwYXJhbSB7RWxsaXBzb2lkfSBbZWxsaXBzb2lkPUVsbGlwc29pZC5XR1M4NF0gVGhlIGVsbGlwc29pZCBvbiB3aGljaCB0aGUgZ2VvZGVzaWMgbGllcy5cbiAqL1xuZnVuY3Rpb24gRWxsaXBzb2lkR2VvZGVzaWMoc3RhcnQsIGVuZCwgZWxsaXBzb2lkKSB7XG4gIHZhciBlID0gZGVmYXVsdFZhbHVlKGVsbGlwc29pZCwgRWxsaXBzb2lkLldHUzg0KTtcbiAgdGhpcy5fZWxsaXBzb2lkID0gZTtcbiAgdGhpcy5fc3RhcnQgPSBuZXcgQ2FydG9ncmFwaGljKCk7XG4gIHRoaXMuX2VuZCA9IG5ldyBDYXJ0b2dyYXBoaWMoKTtcblxuICB0aGlzLl9jb25zdGFudHMgPSB7fTtcbiAgdGhpcy5fc3RhcnRIZWFkaW5nID0gdW5kZWZpbmVkO1xuICB0aGlzLl9lbmRIZWFkaW5nID0gdW5kZWZpbmVkO1xuICB0aGlzLl9kaXN0YW5jZSA9IHVuZGVmaW5lZDtcbiAgdGhpcy5fdVNxdWFyZWQgPSB1bmRlZmluZWQ7XG5cbiAgaWYgKGRlZmluZWQoc3RhcnQpICYmIGRlZmluZWQoZW5kKSkge1xuICAgIGNvbXB1dGVQcm9wZXJ0aWVzKHRoaXMsIHN0YXJ0LCBlbmQsIGUpO1xuICB9XG59XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKEVsbGlwc29pZEdlb2Rlc2ljLnByb3RvdHlwZSwge1xuICAvKipcbiAgICogR2V0cyB0aGUgZWxsaXBzb2lkLlxuICAgKiBAbWVtYmVyb2YgRWxsaXBzb2lkR2VvZGVzaWMucHJvdG90eXBlXG4gICAqIEB0eXBlIHtFbGxpcHNvaWR9XG4gICAqIEByZWFkb25seVxuICAgKi9cbiAgZWxsaXBzb2lkOiB7XG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fZWxsaXBzb2lkO1xuICAgIH0sXG4gIH0sXG5cbiAgLyoqXG4gICAqIEdldHMgdGhlIHN1cmZhY2UgZGlzdGFuY2UgYmV0d2VlbiB0aGUgc3RhcnQgYW5kIGVuZCBwb2ludFxuICAgKiBAbWVtYmVyb2YgRWxsaXBzb2lkR2VvZGVzaWMucHJvdG90eXBlXG4gICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAqIEByZWFkb25seVxuICAgKi9cbiAgc3VyZmFjZURpc3RhbmNlOiB7XG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAvLz4+aW5jbHVkZVN0YXJ0KCdkZWJ1ZycsIHByYWdtYXMuZGVidWcpO1xuICAgICAgQ2hlY2suZGVmaW5lZChcImRpc3RhbmNlXCIsIHRoaXMuX2Rpc3RhbmNlKTtcbiAgICAgIC8vPj5pbmNsdWRlRW5kKCdkZWJ1ZycpO1xuXG4gICAgICByZXR1cm4gdGhpcy5fZGlzdGFuY2U7XG4gICAgfSxcbiAgfSxcblxuICAvKipcbiAgICogR2V0cyB0aGUgaW5pdGlhbCBwbGFuZXRvZGV0aWMgcG9pbnQgb24gdGhlIHBhdGguXG4gICAqIEBtZW1iZXJvZiBFbGxpcHNvaWRHZW9kZXNpYy5wcm90b3R5cGVcbiAgICogQHR5cGUge0NhcnRvZ3JhcGhpY31cbiAgICogQHJlYWRvbmx5XG4gICAqL1xuICBzdGFydDoge1xuICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX3N0YXJ0O1xuICAgIH0sXG4gIH0sXG5cbiAgLyoqXG4gICAqIEdldHMgdGhlIGZpbmFsIHBsYW5ldG9kZXRpYyBwb2ludCBvbiB0aGUgcGF0aC5cbiAgICogQG1lbWJlcm9mIEVsbGlwc29pZEdlb2Rlc2ljLnByb3RvdHlwZVxuICAgKiBAdHlwZSB7Q2FydG9ncmFwaGljfVxuICAgKiBAcmVhZG9ubHlcbiAgICovXG4gIGVuZDoge1xuICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX2VuZDtcbiAgICB9LFxuICB9LFxuXG4gIC8qKlxuICAgKiBHZXRzIHRoZSBoZWFkaW5nIGF0IHRoZSBpbml0aWFsIHBvaW50LlxuICAgKiBAbWVtYmVyb2YgRWxsaXBzb2lkR2VvZGVzaWMucHJvdG90eXBlXG4gICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAqIEByZWFkb25seVxuICAgKi9cbiAgc3RhcnRIZWFkaW5nOiB7XG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAvLz4+aW5jbHVkZVN0YXJ0KCdkZWJ1ZycsIHByYWdtYXMuZGVidWcpO1xuICAgICAgQ2hlY2suZGVmaW5lZChcImRpc3RhbmNlXCIsIHRoaXMuX2Rpc3RhbmNlKTtcbiAgICAgIC8vPj5pbmNsdWRlRW5kKCdkZWJ1ZycpO1xuXG4gICAgICByZXR1cm4gdGhpcy5fc3RhcnRIZWFkaW5nO1xuICAgIH0sXG4gIH0sXG5cbiAgLyoqXG4gICAqIEdldHMgdGhlIGhlYWRpbmcgYXQgdGhlIGZpbmFsIHBvaW50LlxuICAgKiBAbWVtYmVyb2YgRWxsaXBzb2lkR2VvZGVzaWMucHJvdG90eXBlXG4gICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAqIEByZWFkb25seVxuICAgKi9cbiAgZW5kSGVhZGluZzoge1xuICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgLy8+PmluY2x1ZGVTdGFydCgnZGVidWcnLCBwcmFnbWFzLmRlYnVnKTtcbiAgICAgIENoZWNrLmRlZmluZWQoXCJkaXN0YW5jZVwiLCB0aGlzLl9kaXN0YW5jZSk7XG4gICAgICAvLz4+aW5jbHVkZUVuZCgnZGVidWcnKTtcblxuICAgICAgcmV0dXJuIHRoaXMuX2VuZEhlYWRpbmc7XG4gICAgfSxcbiAgfSxcbn0pO1xuXG4vKipcbiAqIFNldHMgdGhlIHN0YXJ0IGFuZCBlbmQgcG9pbnRzIG9mIHRoZSBnZW9kZXNpY1xuICpcbiAqIEBwYXJhbSB7Q2FydG9ncmFwaGljfSBzdGFydCBUaGUgaW5pdGlhbCBwbGFuZXRvZGV0aWMgcG9pbnQgb24gdGhlIHBhdGguXG4gKiBAcGFyYW0ge0NhcnRvZ3JhcGhpY30gZW5kIFRoZSBmaW5hbCBwbGFuZXRvZGV0aWMgcG9pbnQgb24gdGhlIHBhdGguXG4gKi9cbkVsbGlwc29pZEdlb2Rlc2ljLnByb3RvdHlwZS5zZXRFbmRQb2ludHMgPSBmdW5jdGlvbiAoc3RhcnQsIGVuZCkge1xuICAvLz4+aW5jbHVkZVN0YXJ0KCdkZWJ1ZycsIHByYWdtYXMuZGVidWcpO1xuICBDaGVjay5kZWZpbmVkKFwic3RhcnRcIiwgc3RhcnQpO1xuICBDaGVjay5kZWZpbmVkKFwiZW5kXCIsIGVuZCk7XG4gIC8vPj5pbmNsdWRlRW5kKCdkZWJ1ZycpO1xuXG4gIGNvbXB1dGVQcm9wZXJ0aWVzKHRoaXMsIHN0YXJ0LCBlbmQsIHRoaXMuX2VsbGlwc29pZCk7XG59O1xuXG4vKipcbiAqIFByb3ZpZGVzIHRoZSBsb2NhdGlvbiBvZiBhIHBvaW50IGF0IHRoZSBpbmRpY2F0ZWQgcG9ydGlvbiBhbG9uZyB0aGUgZ2VvZGVzaWMuXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IGZyYWN0aW9uIFRoZSBwb3J0aW9uIG9mIHRoZSBkaXN0YW5jZSBiZXR3ZWVuIHRoZSBpbml0aWFsIGFuZCBmaW5hbCBwb2ludHMuXG4gKiBAcGFyYW0ge0NhcnRvZ3JhcGhpY30gW3Jlc3VsdF0gVGhlIG9iamVjdCBpbiB3aGljaCB0byBzdG9yZSB0aGUgcmVzdWx0LlxuICogQHJldHVybnMge0NhcnRvZ3JhcGhpY30gVGhlIGxvY2F0aW9uIG9mIHRoZSBwb2ludCBhbG9uZyB0aGUgZ2VvZGVzaWMuXG4gKi9cbkVsbGlwc29pZEdlb2Rlc2ljLnByb3RvdHlwZS5pbnRlcnBvbGF0ZVVzaW5nRnJhY3Rpb24gPSBmdW5jdGlvbiAoXG4gIGZyYWN0aW9uLFxuICByZXN1bHRcbikge1xuICByZXR1cm4gdGhpcy5pbnRlcnBvbGF0ZVVzaW5nU3VyZmFjZURpc3RhbmNlKFxuICAgIHRoaXMuX2Rpc3RhbmNlICogZnJhY3Rpb24sXG4gICAgcmVzdWx0XG4gICk7XG59O1xuXG4vKipcbiAqIFByb3ZpZGVzIHRoZSBsb2NhdGlvbiBvZiBhIHBvaW50IGF0IHRoZSBpbmRpY2F0ZWQgZGlzdGFuY2UgYWxvbmcgdGhlIGdlb2Rlc2ljLlxuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSBkaXN0YW5jZSBUaGUgZGlzdGFuY2UgZnJvbSB0aGUgaW5pdGFsIHBvaW50IHRvIHRoZSBwb2ludCBvZiBpbnRlcmVzdCBhbG9uZyB0aGUgZ2VvZGVzaWNcbiAqIEBwYXJhbSB7Q2FydG9ncmFwaGljfSBbcmVzdWx0XSBUaGUgb2JqZWN0IGluIHdoaWNoIHRvIHN0b3JlIHRoZSByZXN1bHQuXG4gKiBAcmV0dXJucyB7Q2FydG9ncmFwaGljfSBUaGUgbG9jYXRpb24gb2YgdGhlIHBvaW50IGFsb25nIHRoZSBnZW9kZXNpYy5cbiAqXG4gKiBAZXhjZXB0aW9uIHtEZXZlbG9wZXJFcnJvcn0gc3RhcnQgYW5kIGVuZCBtdXN0IGJlIHNldCBiZWZvcmUgY2FsbGluZyBmdW5jdGlvbiBpbnRlcnBvbGF0ZVVzaW5nU3VyZmFjZURpc3RhbmNlXG4gKi9cbkVsbGlwc29pZEdlb2Rlc2ljLnByb3RvdHlwZS5pbnRlcnBvbGF0ZVVzaW5nU3VyZmFjZURpc3RhbmNlID0gZnVuY3Rpb24gKFxuICBkaXN0YW5jZSxcbiAgcmVzdWx0XG4pIHtcbiAgLy8+PmluY2x1ZGVTdGFydCgnZGVidWcnLCBwcmFnbWFzLmRlYnVnKTtcbiAgQ2hlY2suZGVmaW5lZChcImRpc3RhbmNlXCIsIHRoaXMuX2Rpc3RhbmNlKTtcbiAgLy8+PmluY2x1ZGVFbmQoJ2RlYnVnJyk7XG5cbiAgdmFyIGNvbnN0YW50cyA9IHRoaXMuX2NvbnN0YW50cztcblxuICB2YXIgcyA9IGNvbnN0YW50cy5kaXN0YW5jZVJhdGlvICsgZGlzdGFuY2UgLyBjb25zdGFudHMuYjtcblxuICB2YXIgY29zaW5lMlMgPSBNYXRoLmNvcygyLjAgKiBzKTtcbiAgdmFyIGNvc2luZTRTID0gTWF0aC5jb3MoNC4wICogcyk7XG4gIHZhciBjb3NpbmU2UyA9IE1hdGguY29zKDYuMCAqIHMpO1xuICB2YXIgc2luZTJTID0gTWF0aC5zaW4oMi4wICogcyk7XG4gIHZhciBzaW5lNFMgPSBNYXRoLnNpbig0LjAgKiBzKTtcbiAgdmFyIHNpbmU2UyA9IE1hdGguc2luKDYuMCAqIHMpO1xuICB2YXIgc2luZThTID0gTWF0aC5zaW4oOC4wICogcyk7XG5cbiAgdmFyIHMyID0gcyAqIHM7XG4gIHZhciBzMyA9IHMgKiBzMjtcblxuICB2YXIgdThPdmVyMjU2ID0gY29uc3RhbnRzLnU4T3ZlcjI1NjtcbiAgdmFyIHUyT3ZlcjQgPSBjb25zdGFudHMudTJPdmVyNDtcbiAgdmFyIHU2T3ZlcjY0ID0gY29uc3RhbnRzLnU2T3ZlcjY0O1xuICB2YXIgdTRPdmVyMTYgPSBjb25zdGFudHMudTRPdmVyMTY7XG4gIHZhciBzaWdtYSA9XG4gICAgKDIuMCAqIHMzICogdThPdmVyMjU2ICogY29zaW5lMlMpIC8gMy4wICtcbiAgICBzICpcbiAgICAgICgxLjAgLVxuICAgICAgICB1Mk92ZXI0ICtcbiAgICAgICAgKDcuMCAqIHU0T3ZlcjE2KSAvIDQuMCAtXG4gICAgICAgICgxNS4wICogdTZPdmVyNjQpIC8gNC4wICtcbiAgICAgICAgKDU3OS4wICogdThPdmVyMjU2KSAvIDY0LjAgLVxuICAgICAgICAodTRPdmVyMTYgLSAoMTUuMCAqIHU2T3ZlcjY0KSAvIDQuMCArICgxODcuMCAqIHU4T3ZlcjI1NikgLyAxNi4wKSAqXG4gICAgICAgICAgY29zaW5lMlMgLVxuICAgICAgICAoKDUuMCAqIHU2T3ZlcjY0KSAvIDQuMCAtICgxMTUuMCAqIHU4T3ZlcjI1NikgLyAxNi4wKSAqIGNvc2luZTRTIC1cbiAgICAgICAgKDI5LjAgKiB1OE92ZXIyNTYgKiBjb3NpbmU2UykgLyAxNi4wKSArXG4gICAgKHUyT3ZlcjQgLyAyLjAgLVxuICAgICAgdTRPdmVyMTYgK1xuICAgICAgKDcxLjAgKiB1Nk92ZXI2NCkgLyAzMi4wIC1cbiAgICAgICg4NS4wICogdThPdmVyMjU2KSAvIDE2LjApICpcbiAgICAgIHNpbmUyUyArXG4gICAgKCg1LjAgKiB1NE92ZXIxNikgLyAxNi4wIC1cbiAgICAgICg1LjAgKiB1Nk92ZXI2NCkgLyA0LjAgK1xuICAgICAgKDM4My4wICogdThPdmVyMjU2KSAvIDk2LjApICpcbiAgICAgIHNpbmU0UyAtXG4gICAgczIgKlxuICAgICAgKCh1Nk92ZXI2NCAtICgxMS4wICogdThPdmVyMjU2KSAvIDIuMCkgKiBzaW5lMlMgK1xuICAgICAgICAoNS4wICogdThPdmVyMjU2ICogc2luZTRTKSAvIDIuMCkgK1xuICAgICgoMjkuMCAqIHU2T3ZlcjY0KSAvIDk2LjAgLSAoMjkuMCAqIHU4T3ZlcjI1NikgLyAxNi4wKSAqIHNpbmU2UyArXG4gICAgKDUzOS4wICogdThPdmVyMjU2ICogc2luZThTKSAvIDE1MzYuMDtcblxuICB2YXIgdGhldGEgPSBNYXRoLmFzaW4oTWF0aC5zaW4oc2lnbWEpICogY29uc3RhbnRzLmNvc2luZUFscGhhKTtcbiAgdmFyIGxhdGl0dWRlID0gTWF0aC5hdGFuKChjb25zdGFudHMuYSAvIGNvbnN0YW50cy5iKSAqIE1hdGgudGFuKHRoZXRhKSk7XG5cbiAgLy8gUmVkZWZpbmUgaW4gdGVybXMgb2YgcmVsYXRpdmUgYXJndW1lbnQgb2YgbGF0aXR1ZGUuXG4gIHNpZ21hID0gc2lnbWEgLSBjb25zdGFudHMuc2lnbWE7XG5cbiAgdmFyIGNvc2luZVR3aWNlU2lnbWFNaWRwb2ludCA9IE1hdGguY29zKDIuMCAqIGNvbnN0YW50cy5zaWdtYSArIHNpZ21hKTtcblxuICB2YXIgc2luZVNpZ21hID0gTWF0aC5zaW4oc2lnbWEpO1xuICB2YXIgY29zaW5lU2lnbWEgPSBNYXRoLmNvcyhzaWdtYSk7XG5cbiAgdmFyIGNjID0gY29uc3RhbnRzLmNvc2luZVUgKiBjb3NpbmVTaWdtYTtcbiAgdmFyIHNzID0gY29uc3RhbnRzLnNpbmVVICogc2luZVNpZ21hO1xuXG4gIHZhciBsYW1iZGEgPSBNYXRoLmF0YW4yKFxuICAgIHNpbmVTaWdtYSAqIGNvbnN0YW50cy5zaW5lSGVhZGluZyxcbiAgICBjYyAtIHNzICogY29uc3RhbnRzLmNvc2luZUhlYWRpbmdcbiAgKTtcblxuICB2YXIgbCA9XG4gICAgbGFtYmRhIC1cbiAgICBjb21wdXRlRGVsdGFMYW1iZGEoXG4gICAgICBjb25zdGFudHMuZixcbiAgICAgIGNvbnN0YW50cy5zaW5lQWxwaGEsXG4gICAgICBjb25zdGFudHMuY29zaW5lU3F1YXJlZEFscGhhLFxuICAgICAgc2lnbWEsXG4gICAgICBzaW5lU2lnbWEsXG4gICAgICBjb3NpbmVTaWdtYSxcbiAgICAgIGNvc2luZVR3aWNlU2lnbWFNaWRwb2ludFxuICAgICk7XG5cbiAgaWYgKGRlZmluZWQocmVzdWx0KSkge1xuICAgIHJlc3VsdC5sb25naXR1ZGUgPSB0aGlzLl9zdGFydC5sb25naXR1ZGUgKyBsO1xuICAgIHJlc3VsdC5sYXRpdHVkZSA9IGxhdGl0dWRlO1xuICAgIHJlc3VsdC5oZWlnaHQgPSAwLjA7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIHJldHVybiBuZXcgQ2FydG9ncmFwaGljKHRoaXMuX3N0YXJ0LmxvbmdpdHVkZSArIGwsIGxhdGl0dWRlLCAwLjApO1xufTtcbmV4cG9ydCBkZWZhdWx0IEVsbGlwc29pZEdlb2Rlc2ljO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///39043\n')},64727:function(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__){eval('/* harmony import */ var _arrayFill_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(23401);\n/* harmony import */ var _BoundingSphere_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(48243);\n/* harmony import */ var _Cartesian2_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(60838);\n/* harmony import */ var _Cartesian3_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(60216);\n/* harmony import */ var _ComponentDatatype_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(84828);\n/* harmony import */ var _defaultValue_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(62200);\n/* harmony import */ var _defined_js__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(82982);\n/* harmony import */ var _DeveloperError_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(12572);\n/* harmony import */ var _Ellipsoid_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(50491);\n/* harmony import */ var _Geometry_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(82408);\n/* harmony import */ var _GeometryAttribute_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(13616);\n/* harmony import */ var _GeometryAttributes_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(56652);\n/* harmony import */ var _GeometryOffsetAttribute_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(87379);\n/* harmony import */ var _IndexDatatype_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(22832);\n/* harmony import */ var _Math_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(99417);\n/* harmony import */ var _PrimitiveType_js__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(97264);\n/* harmony import */ var _VertexFormat_js__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(67252);\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nvar scratchPosition = new _Cartesian3_js__WEBPACK_IMPORTED_MODULE_3__/* ["default"] */ .Z();\nvar scratchNormal = new _Cartesian3_js__WEBPACK_IMPORTED_MODULE_3__/* ["default"] */ .Z();\nvar scratchTangent = new _Cartesian3_js__WEBPACK_IMPORTED_MODULE_3__/* ["default"] */ .Z();\nvar scratchBitangent = new _Cartesian3_js__WEBPACK_IMPORTED_MODULE_3__/* ["default"] */ .Z();\nvar scratchNormalST = new _Cartesian3_js__WEBPACK_IMPORTED_MODULE_3__/* ["default"] */ .Z();\nvar defaultRadii = new _Cartesian3_js__WEBPACK_IMPORTED_MODULE_3__/* ["default"] */ .Z(1.0, 1.0, 1.0);\n\nvar cos = Math.cos;\nvar sin = Math.sin;\n\n/**\n * A description of an ellipsoid centered at the origin.\n *\n * @alias EllipsoidGeometry\n * @constructor\n *\n * @param {Object} [options] Object with the following properties:\n * @param {Cartesian3} [options.radii=Cartesian3(1.0, 1.0, 1.0)] The radii of the ellipsoid in the x, y, and z directions.\n * @param {Cartesian3} [options.innerRadii=options.radii] The inner radii of the ellipsoid in the x, y, and z directions.\n * @param {Number} [options.minimumClock=0.0] The minimum angle lying in the xy-plane measured from the positive x-axis and toward the positive y-axis.\n * @param {Number} [options.maximumClock=2*PI] The maximum angle lying in the xy-plane measured from the positive x-axis and toward the positive y-axis.\n * @param {Number} [options.minimumCone=0.0] The minimum angle measured from the positive z-axis and toward the negative z-axis.\n * @param {Number} [options.maximumCone=PI] The maximum angle measured from the positive z-axis and toward the negative z-axis.\n * @param {Number} [options.stackPartitions=64] The number of times to partition the ellipsoid into stacks.\n * @param {Number} [options.slicePartitions=64] The number of times to partition the ellipsoid into radial slices.\n * @param {VertexFormat} [options.vertexFormat=VertexFormat.DEFAULT] The vertex attributes to be computed.\n *\n * @exception {DeveloperError} options.slicePartitions cannot be less than three.\n * @exception {DeveloperError} options.stackPartitions cannot be less than three.\n *\n * @see EllipsoidGeometry#createGeometry\n *\n * @example\n * var ellipsoid = new Cesium.EllipsoidGeometry({\n *   vertexFormat : Cesium.VertexFormat.POSITION_ONLY,\n *   radii : new Cesium.Cartesian3(1000000.0, 500000.0, 500000.0)\n * });\n * var geometry = Cesium.EllipsoidGeometry.createGeometry(ellipsoid);\n */\nfunction EllipsoidGeometry(options) {\n  options = (0,_defaultValue_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"] */ .Z)(options, _defaultValue_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"].EMPTY_OBJECT */ .Z.EMPTY_OBJECT);\n\n  var radii = (0,_defaultValue_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"] */ .Z)(options.radii, defaultRadii);\n  var innerRadii = (0,_defaultValue_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"] */ .Z)(options.innerRadii, radii);\n  var minimumClock = (0,_defaultValue_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"] */ .Z)(options.minimumClock, 0.0);\n  var maximumClock = (0,_defaultValue_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"] */ .Z)(options.maximumClock, _Math_js__WEBPACK_IMPORTED_MODULE_13__/* ["default"].TWO_PI */ .Z.TWO_PI);\n  var minimumCone = (0,_defaultValue_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"] */ .Z)(options.minimumCone, 0.0);\n  var maximumCone = (0,_defaultValue_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"] */ .Z)(options.maximumCone, _Math_js__WEBPACK_IMPORTED_MODULE_13__/* ["default"].PI */ .Z.PI);\n  var stackPartitions = Math.round((0,_defaultValue_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"] */ .Z)(options.stackPartitions, 64));\n  var slicePartitions = Math.round((0,_defaultValue_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"] */ .Z)(options.slicePartitions, 64));\n  var vertexFormat = (0,_defaultValue_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"] */ .Z)(options.vertexFormat, _VertexFormat_js__WEBPACK_IMPORTED_MODULE_15__/* ["default"].DEFAULT */ .Z.DEFAULT);\n\n  //>>includeStart(\'debug\', pragmas.debug);\n  if (slicePartitions < 3) {\n    throw new _DeveloperError_js__WEBPACK_IMPORTED_MODULE_6__/* ["default"] */ .Z(\n      "options.slicePartitions cannot be less than three."\n    );\n  }\n  if (stackPartitions < 3) {\n    throw new _DeveloperError_js__WEBPACK_IMPORTED_MODULE_6__/* ["default"] */ .Z(\n      "options.stackPartitions cannot be less than three."\n    );\n  }\n  //>>includeEnd(\'debug\');\n\n  this._radii = _Cartesian3_js__WEBPACK_IMPORTED_MODULE_3__/* ["default"].clone */ .Z.clone(radii);\n  this._innerRadii = _Cartesian3_js__WEBPACK_IMPORTED_MODULE_3__/* ["default"].clone */ .Z.clone(innerRadii);\n  this._minimumClock = minimumClock;\n  this._maximumClock = maximumClock;\n  this._minimumCone = minimumCone;\n  this._maximumCone = maximumCone;\n  this._stackPartitions = stackPartitions;\n  this._slicePartitions = slicePartitions;\n  this._vertexFormat = _VertexFormat_js__WEBPACK_IMPORTED_MODULE_15__/* ["default"].clone */ .Z.clone(vertexFormat);\n  this._offsetAttribute = options.offsetAttribute;\n  this._workerName = "createEllipsoidGeometry";\n}\n\n/**\n * The number of elements used to pack the object into an array.\n * @type {Number}\n */\nEllipsoidGeometry.packedLength =\n  2 * _Cartesian3_js__WEBPACK_IMPORTED_MODULE_3__/* ["default"].packedLength */ .Z.packedLength + _VertexFormat_js__WEBPACK_IMPORTED_MODULE_15__/* ["default"].packedLength */ .Z.packedLength + 7;\n\n/**\n * Stores the provided instance into the provided array.\n *\n * @param {EllipsoidGeometry} value The value to pack.\n * @param {Number[]} array The array to pack into.\n * @param {Number} [startingIndex=0] The index into the array at which to start packing the elements.\n *\n * @returns {Number[]} The array that was packed into\n */\nEllipsoidGeometry.pack = function (value, array, startingIndex) {\n  //>>includeStart(\'debug\', pragmas.debug);\n  if (!(0,_defined_js__WEBPACK_IMPORTED_MODULE_16__/* ["default"] */ .Z)(value)) {\n    throw new _DeveloperError_js__WEBPACK_IMPORTED_MODULE_6__/* ["default"] */ .Z("value is required");\n  }\n  if (!(0,_defined_js__WEBPACK_IMPORTED_MODULE_16__/* ["default"] */ .Z)(array)) {\n    throw new _DeveloperError_js__WEBPACK_IMPORTED_MODULE_6__/* ["default"] */ .Z("array is required");\n  }\n  //>>includeEnd(\'debug\');\n\n  startingIndex = (0,_defaultValue_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"] */ .Z)(startingIndex, 0);\n\n  _Cartesian3_js__WEBPACK_IMPORTED_MODULE_3__/* ["default"].pack */ .Z.pack(value._radii, array, startingIndex);\n  startingIndex += _Cartesian3_js__WEBPACK_IMPORTED_MODULE_3__/* ["default"].packedLength */ .Z.packedLength;\n\n  _Cartesian3_js__WEBPACK_IMPORTED_MODULE_3__/* ["default"].pack */ .Z.pack(value._innerRadii, array, startingIndex);\n  startingIndex += _Cartesian3_js__WEBPACK_IMPORTED_MODULE_3__/* ["default"].packedLength */ .Z.packedLength;\n\n  _VertexFormat_js__WEBPACK_IMPORTED_MODULE_15__/* ["default"].pack */ .Z.pack(value._vertexFormat, array, startingIndex);\n  startingIndex += _VertexFormat_js__WEBPACK_IMPORTED_MODULE_15__/* ["default"].packedLength */ .Z.packedLength;\n\n  array[startingIndex++] = value._minimumClock;\n  array[startingIndex++] = value._maximumClock;\n  array[startingIndex++] = value._minimumCone;\n  array[startingIndex++] = value._maximumCone;\n  array[startingIndex++] = value._stackPartitions;\n  array[startingIndex++] = value._slicePartitions;\n  array[startingIndex] = (0,_defaultValue_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"] */ .Z)(value._offsetAttribute, -1);\n\n  return array;\n};\n\nvar scratchRadii = new _Cartesian3_js__WEBPACK_IMPORTED_MODULE_3__/* ["default"] */ .Z();\nvar scratchInnerRadii = new _Cartesian3_js__WEBPACK_IMPORTED_MODULE_3__/* ["default"] */ .Z();\nvar scratchVertexFormat = new _VertexFormat_js__WEBPACK_IMPORTED_MODULE_15__/* ["default"] */ .Z();\nvar scratchOptions = {\n  radii: scratchRadii,\n  innerRadii: scratchInnerRadii,\n  vertexFormat: scratchVertexFormat,\n  minimumClock: undefined,\n  maximumClock: undefined,\n  minimumCone: undefined,\n  maximumCone: undefined,\n  stackPartitions: undefined,\n  slicePartitions: undefined,\n  offsetAttribute: undefined,\n};\n\n/**\n * Retrieves an instance from a packed array.\n *\n * @param {Number[]} array The packed array.\n * @param {Number} [startingIndex=0] The starting index of the element to be unpacked.\n * @param {EllipsoidGeometry} [result] The object into which to store the result.\n * @returns {EllipsoidGeometry} The modified result parameter or a new EllipsoidGeometry instance if one was not provided.\n */\nEllipsoidGeometry.unpack = function (array, startingIndex, result) {\n  //>>includeStart(\'debug\', pragmas.debug);\n  if (!(0,_defined_js__WEBPACK_IMPORTED_MODULE_16__/* ["default"] */ .Z)(array)) {\n    throw new _DeveloperError_js__WEBPACK_IMPORTED_MODULE_6__/* ["default"] */ .Z("array is required");\n  }\n  //>>includeEnd(\'debug\');\n\n  startingIndex = (0,_defaultValue_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"] */ .Z)(startingIndex, 0);\n\n  var radii = _Cartesian3_js__WEBPACK_IMPORTED_MODULE_3__/* ["default"].unpack */ .Z.unpack(array, startingIndex, scratchRadii);\n  startingIndex += _Cartesian3_js__WEBPACK_IMPORTED_MODULE_3__/* ["default"].packedLength */ .Z.packedLength;\n\n  var innerRadii = _Cartesian3_js__WEBPACK_IMPORTED_MODULE_3__/* ["default"].unpack */ .Z.unpack(array, startingIndex, scratchInnerRadii);\n  startingIndex += _Cartesian3_js__WEBPACK_IMPORTED_MODULE_3__/* ["default"].packedLength */ .Z.packedLength;\n\n  var vertexFormat = _VertexFormat_js__WEBPACK_IMPORTED_MODULE_15__/* ["default"].unpack */ .Z.unpack(\n    array,\n    startingIndex,\n    scratchVertexFormat\n  );\n  startingIndex += _VertexFormat_js__WEBPACK_IMPORTED_MODULE_15__/* ["default"].packedLength */ .Z.packedLength;\n\n  var minimumClock = array[startingIndex++];\n  var maximumClock = array[startingIndex++];\n  var minimumCone = array[startingIndex++];\n  var maximumCone = array[startingIndex++];\n  var stackPartitions = array[startingIndex++];\n  var slicePartitions = array[startingIndex++];\n  var offsetAttribute = array[startingIndex];\n\n  if (!(0,_defined_js__WEBPACK_IMPORTED_MODULE_16__/* ["default"] */ .Z)(result)) {\n    scratchOptions.minimumClock = minimumClock;\n    scratchOptions.maximumClock = maximumClock;\n    scratchOptions.minimumCone = minimumCone;\n    scratchOptions.maximumCone = maximumCone;\n    scratchOptions.stackPartitions = stackPartitions;\n    scratchOptions.slicePartitions = slicePartitions;\n    scratchOptions.offsetAttribute =\n      offsetAttribute === -1 ? undefined : offsetAttribute;\n    return new EllipsoidGeometry(scratchOptions);\n  }\n\n  result._radii = _Cartesian3_js__WEBPACK_IMPORTED_MODULE_3__/* ["default"].clone */ .Z.clone(radii, result._radii);\n  result._innerRadii = _Cartesian3_js__WEBPACK_IMPORTED_MODULE_3__/* ["default"].clone */ .Z.clone(innerRadii, result._innerRadii);\n  result._vertexFormat = _VertexFormat_js__WEBPACK_IMPORTED_MODULE_15__/* ["default"].clone */ .Z.clone(vertexFormat, result._vertexFormat);\n  result._minimumClock = minimumClock;\n  result._maximumClock = maximumClock;\n  result._minimumCone = minimumCone;\n  result._maximumCone = maximumCone;\n  result._stackPartitions = stackPartitions;\n  result._slicePartitions = slicePartitions;\n  result._offsetAttribute =\n    offsetAttribute === -1 ? undefined : offsetAttribute;\n\n  return result;\n};\n\n/**\n * Computes the geometric representation of an ellipsoid, including its vertices, indices, and a bounding sphere.\n *\n * @param {EllipsoidGeometry} ellipsoidGeometry A description of the ellipsoid.\n * @returns {Geometry|undefined} The computed vertices and indices.\n */\nEllipsoidGeometry.createGeometry = function (ellipsoidGeometry) {\n  var radii = ellipsoidGeometry._radii;\n  if (radii.x <= 0 || radii.y <= 0 || radii.z <= 0) {\n    return;\n  }\n\n  var innerRadii = ellipsoidGeometry._innerRadii;\n  if (innerRadii.x <= 0 || innerRadii.y <= 0 || innerRadii.z <= 0) {\n    return;\n  }\n\n  var minimumClock = ellipsoidGeometry._minimumClock;\n  var maximumClock = ellipsoidGeometry._maximumClock;\n  var minimumCone = ellipsoidGeometry._minimumCone;\n  var maximumCone = ellipsoidGeometry._maximumCone;\n  var vertexFormat = ellipsoidGeometry._vertexFormat;\n\n  // Add an extra slice and stack so that the number of partitions is the\n  // number of surfaces rather than the number of joints\n  var slicePartitions = ellipsoidGeometry._slicePartitions + 1;\n  var stackPartitions = ellipsoidGeometry._stackPartitions + 1;\n\n  slicePartitions = Math.round(\n    (slicePartitions * Math.abs(maximumClock - minimumClock)) /\n      _Math_js__WEBPACK_IMPORTED_MODULE_13__/* ["default"].TWO_PI */ .Z.TWO_PI\n  );\n  stackPartitions = Math.round(\n    (stackPartitions * Math.abs(maximumCone - minimumCone)) / _Math_js__WEBPACK_IMPORTED_MODULE_13__/* ["default"].PI */ .Z.PI\n  );\n\n  if (slicePartitions < 2) {\n    slicePartitions = 2;\n  }\n  if (stackPartitions < 2) {\n    stackPartitions = 2;\n  }\n\n  var i;\n  var j;\n  var index = 0;\n\n  // Create arrays for theta and phi. Duplicate first and last angle to\n  // allow different normals at the intersections.\n  var phis = [minimumCone];\n  var thetas = [minimumClock];\n  for (i = 0; i < stackPartitions; i++) {\n    phis.push(\n      minimumCone + (i * (maximumCone - minimumCone)) / (stackPartitions - 1)\n    );\n  }\n  phis.push(maximumCone);\n  for (j = 0; j < slicePartitions; j++) {\n    thetas.push(\n      minimumClock + (j * (maximumClock - minimumClock)) / (slicePartitions - 1)\n    );\n  }\n  thetas.push(maximumClock);\n  var numPhis = phis.length;\n  var numThetas = thetas.length;\n\n  // Allow for extra indices if there is an inner surface and if we need\n  // to close the sides if the clock range is not a full circle\n  var extraIndices = 0;\n  var vertexMultiplier = 1.0;\n  var hasInnerSurface =\n    innerRadii.x !== radii.x ||\n    innerRadii.y !== radii.y ||\n    innerRadii.z !== radii.z;\n  var isTopOpen = false;\n  var isBotOpen = false;\n  var isClockOpen = false;\n  if (hasInnerSurface) {\n    vertexMultiplier = 2.0;\n    if (minimumCone > 0.0) {\n      isTopOpen = true;\n      extraIndices += slicePartitions - 1;\n    }\n    if (maximumCone < Math.PI) {\n      isBotOpen = true;\n      extraIndices += slicePartitions - 1;\n    }\n    if ((maximumClock - minimumClock) % _Math_js__WEBPACK_IMPORTED_MODULE_13__/* ["default"].TWO_PI */ .Z.TWO_PI) {\n      isClockOpen = true;\n      extraIndices += (stackPartitions - 1) * 2 + 1;\n    } else {\n      extraIndices += 1;\n    }\n  }\n\n  var vertexCount = numThetas * numPhis * vertexMultiplier;\n  var positions = new Float64Array(vertexCount * 3);\n  var isInner = (0,_arrayFill_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .Z)(new Array(vertexCount), false);\n  var negateNormal = (0,_arrayFill_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .Z)(new Array(vertexCount), false);\n\n  // Multiply by 6 because there are two triangles per sector\n  var indexCount = slicePartitions * stackPartitions * vertexMultiplier;\n  var numIndices =\n    6 *\n    (indexCount +\n      extraIndices +\n      1 -\n      (slicePartitions + stackPartitions) * vertexMultiplier);\n  var indices = _IndexDatatype_js__WEBPACK_IMPORTED_MODULE_12__/* ["default"].createTypedArray */ .Z.createTypedArray(indexCount, numIndices);\n\n  var normals = vertexFormat.normal\n    ? new Float32Array(vertexCount * 3)\n    : undefined;\n  var tangents = vertexFormat.tangent\n    ? new Float32Array(vertexCount * 3)\n    : undefined;\n  var bitangents = vertexFormat.bitangent\n    ? new Float32Array(vertexCount * 3)\n    : undefined;\n  var st = vertexFormat.st ? new Float32Array(vertexCount * 2) : undefined;\n\n  // Calculate sin/cos phi\n  var sinPhi = new Array(numPhis);\n  var cosPhi = new Array(numPhis);\n  for (i = 0; i < numPhis; i++) {\n    sinPhi[i] = sin(phis[i]);\n    cosPhi[i] = cos(phis[i]);\n  }\n\n  // Calculate sin/cos theta\n  var sinTheta = new Array(numThetas);\n  var cosTheta = new Array(numThetas);\n  for (j = 0; j < numThetas; j++) {\n    cosTheta[j] = cos(thetas[j]);\n    sinTheta[j] = sin(thetas[j]);\n  }\n\n  // Create outer surface\n  for (i = 0; i < numPhis; i++) {\n    for (j = 0; j < numThetas; j++) {\n      positions[index++] = radii.x * sinPhi[i] * cosTheta[j];\n      positions[index++] = radii.y * sinPhi[i] * sinTheta[j];\n      positions[index++] = radii.z * cosPhi[i];\n    }\n  }\n\n  // Create inner surface\n  var vertexIndex = vertexCount / 2.0;\n  if (hasInnerSurface) {\n    for (i = 0; i < numPhis; i++) {\n      for (j = 0; j < numThetas; j++) {\n        positions[index++] = innerRadii.x * sinPhi[i] * cosTheta[j];\n        positions[index++] = innerRadii.y * sinPhi[i] * sinTheta[j];\n        positions[index++] = innerRadii.z * cosPhi[i];\n\n        // Keep track of which vertices are the inner and which ones\n        // need the normal to be negated\n        isInner[vertexIndex] = true;\n        if (i > 0 && i !== numPhis - 1 && j !== 0 && j !== numThetas - 1) {\n          negateNormal[vertexIndex] = true;\n        }\n        vertexIndex++;\n      }\n    }\n  }\n\n  // Create indices for outer surface\n  index = 0;\n  var topOffset;\n  var bottomOffset;\n  for (i = 1; i < numPhis - 2; i++) {\n    topOffset = i * numThetas;\n    bottomOffset = (i + 1) * numThetas;\n\n    for (j = 1; j < numThetas - 2; j++) {\n      indices[index++] = bottomOffset + j;\n      indices[index++] = bottomOffset + j + 1;\n      indices[index++] = topOffset + j + 1;\n\n      indices[index++] = bottomOffset + j;\n      indices[index++] = topOffset + j + 1;\n      indices[index++] = topOffset + j;\n    }\n  }\n\n  // Create indices for inner surface\n  if (hasInnerSurface) {\n    var offset = numPhis * numThetas;\n    for (i = 1; i < numPhis - 2; i++) {\n      topOffset = offset + i * numThetas;\n      bottomOffset = offset + (i + 1) * numThetas;\n\n      for (j = 1; j < numThetas - 2; j++) {\n        indices[index++] = bottomOffset + j;\n        indices[index++] = topOffset + j;\n        indices[index++] = topOffset + j + 1;\n\n        indices[index++] = bottomOffset + j;\n        indices[index++] = topOffset + j + 1;\n        indices[index++] = bottomOffset + j + 1;\n      }\n    }\n  }\n\n  var outerOffset;\n  var innerOffset;\n  if (hasInnerSurface) {\n    if (isTopOpen) {\n      // Connect the top of the inner surface to the top of the outer surface\n      innerOffset = numPhis * numThetas;\n      for (i = 1; i < numThetas - 2; i++) {\n        indices[index++] = i;\n        indices[index++] = i + 1;\n        indices[index++] = innerOffset + i + 1;\n\n        indices[index++] = i;\n        indices[index++] = innerOffset + i + 1;\n        indices[index++] = innerOffset + i;\n      }\n    }\n\n    if (isBotOpen) {\n      // Connect the bottom of the inner surface to the bottom of the outer surface\n      outerOffset = numPhis * numThetas - numThetas;\n      innerOffset = numPhis * numThetas * vertexMultiplier - numThetas;\n      for (i = 1; i < numThetas - 2; i++) {\n        indices[index++] = outerOffset + i + 1;\n        indices[index++] = outerOffset + i;\n        indices[index++] = innerOffset + i;\n\n        indices[index++] = outerOffset + i + 1;\n        indices[index++] = innerOffset + i;\n        indices[index++] = innerOffset + i + 1;\n      }\n    }\n  }\n\n  // Connect the edges if clock is not closed\n  if (isClockOpen) {\n    for (i = 1; i < numPhis - 2; i++) {\n      innerOffset = numThetas * numPhis + numThetas * i;\n      outerOffset = numThetas * i;\n      indices[index++] = innerOffset;\n      indices[index++] = outerOffset + numThetas;\n      indices[index++] = outerOffset;\n\n      indices[index++] = innerOffset;\n      indices[index++] = innerOffset + numThetas;\n      indices[index++] = outerOffset + numThetas;\n    }\n\n    for (i = 1; i < numPhis - 2; i++) {\n      innerOffset = numThetas * numPhis + numThetas * (i + 1) - 1;\n      outerOffset = numThetas * (i + 1) - 1;\n      indices[index++] = outerOffset + numThetas;\n      indices[index++] = innerOffset;\n      indices[index++] = outerOffset;\n\n      indices[index++] = outerOffset + numThetas;\n      indices[index++] = innerOffset + numThetas;\n      indices[index++] = innerOffset;\n    }\n  }\n\n  var attributes = new _GeometryAttributes_js__WEBPACK_IMPORTED_MODULE_10__/* ["default"] */ .Z();\n\n  if (vertexFormat.position) {\n    attributes.position = new _GeometryAttribute_js__WEBPACK_IMPORTED_MODULE_9__/* ["default"] */ .Z({\n      componentDatatype: _ComponentDatatype_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"].DOUBLE */ .Z.DOUBLE,\n      componentsPerAttribute: 3,\n      values: positions,\n    });\n  }\n\n  var stIndex = 0;\n  var normalIndex = 0;\n  var tangentIndex = 0;\n  var bitangentIndex = 0;\n  var vertexCountHalf = vertexCount / 2.0;\n\n  var ellipsoid;\n  var ellipsoidOuter = _Ellipsoid_js__WEBPACK_IMPORTED_MODULE_7__/* ["default"].fromCartesian3 */ .Z.fromCartesian3(radii);\n  var ellipsoidInner = _Ellipsoid_js__WEBPACK_IMPORTED_MODULE_7__/* ["default"].fromCartesian3 */ .Z.fromCartesian3(innerRadii);\n\n  if (\n    vertexFormat.st ||\n    vertexFormat.normal ||\n    vertexFormat.tangent ||\n    vertexFormat.bitangent\n  ) {\n    for (i = 0; i < vertexCount; i++) {\n      ellipsoid = isInner[i] ? ellipsoidInner : ellipsoidOuter;\n      var position = _Cartesian3_js__WEBPACK_IMPORTED_MODULE_3__/* ["default"].fromArray */ .Z.fromArray(positions, i * 3, scratchPosition);\n      var normal = ellipsoid.geodeticSurfaceNormal(position, scratchNormal);\n      if (negateNormal[i]) {\n        _Cartesian3_js__WEBPACK_IMPORTED_MODULE_3__/* ["default"].negate */ .Z.negate(normal, normal);\n      }\n\n      if (vertexFormat.st) {\n        var normalST = _Cartesian2_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"].negate */ .Z.negate(normal, scratchNormalST);\n        st[stIndex++] =\n          Math.atan2(normalST.y, normalST.x) / _Math_js__WEBPACK_IMPORTED_MODULE_13__/* ["default"].TWO_PI */ .Z.TWO_PI + 0.5;\n        st[stIndex++] = Math.asin(normal.z) / Math.PI + 0.5;\n      }\n\n      if (vertexFormat.normal) {\n        normals[normalIndex++] = normal.x;\n        normals[normalIndex++] = normal.y;\n        normals[normalIndex++] = normal.z;\n      }\n\n      if (vertexFormat.tangent || vertexFormat.bitangent) {\n        var tangent = scratchTangent;\n\n        // Use UNIT_X for the poles\n        var tangetOffset = 0;\n        var unit;\n        if (isInner[i]) {\n          tangetOffset = vertexCountHalf;\n        }\n        if (\n          !isTopOpen &&\n          i >= tangetOffset &&\n          i < tangetOffset + numThetas * 2\n        ) {\n          unit = _Cartesian3_js__WEBPACK_IMPORTED_MODULE_3__/* ["default"].UNIT_X */ .Z.UNIT_X;\n        } else {\n          unit = _Cartesian3_js__WEBPACK_IMPORTED_MODULE_3__/* ["default"].UNIT_Z */ .Z.UNIT_Z;\n        }\n        _Cartesian3_js__WEBPACK_IMPORTED_MODULE_3__/* ["default"].cross */ .Z.cross(unit, normal, tangent);\n        _Cartesian3_js__WEBPACK_IMPORTED_MODULE_3__/* ["default"].normalize */ .Z.normalize(tangent, tangent);\n\n        if (vertexFormat.tangent) {\n          tangents[tangentIndex++] = tangent.x;\n          tangents[tangentIndex++] = tangent.y;\n          tangents[tangentIndex++] = tangent.z;\n        }\n\n        if (vertexFormat.bitangent) {\n          var bitangent = _Cartesian3_js__WEBPACK_IMPORTED_MODULE_3__/* ["default"].cross */ .Z.cross(normal, tangent, scratchBitangent);\n          _Cartesian3_js__WEBPACK_IMPORTED_MODULE_3__/* ["default"].normalize */ .Z.normalize(bitangent, bitangent);\n\n          bitangents[bitangentIndex++] = bitangent.x;\n          bitangents[bitangentIndex++] = bitangent.y;\n          bitangents[bitangentIndex++] = bitangent.z;\n        }\n      }\n    }\n\n    if (vertexFormat.st) {\n      attributes.st = new _GeometryAttribute_js__WEBPACK_IMPORTED_MODULE_9__/* ["default"] */ .Z({\n        componentDatatype: _ComponentDatatype_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"].FLOAT */ .Z.FLOAT,\n        componentsPerAttribute: 2,\n        values: st,\n      });\n    }\n\n    if (vertexFormat.normal) {\n      attributes.normal = new _GeometryAttribute_js__WEBPACK_IMPORTED_MODULE_9__/* ["default"] */ .Z({\n        componentDatatype: _ComponentDatatype_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"].FLOAT */ .Z.FLOAT,\n        componentsPerAttribute: 3,\n        values: normals,\n      });\n    }\n\n    if (vertexFormat.tangent) {\n      attributes.tangent = new _GeometryAttribute_js__WEBPACK_IMPORTED_MODULE_9__/* ["default"] */ .Z({\n        componentDatatype: _ComponentDatatype_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"].FLOAT */ .Z.FLOAT,\n        componentsPerAttribute: 3,\n        values: tangents,\n      });\n    }\n\n    if (vertexFormat.bitangent) {\n      attributes.bitangent = new _GeometryAttribute_js__WEBPACK_IMPORTED_MODULE_9__/* ["default"] */ .Z({\n        componentDatatype: _ComponentDatatype_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"].FLOAT */ .Z.FLOAT,\n        componentsPerAttribute: 3,\n        values: bitangents,\n      });\n    }\n  }\n\n  if ((0,_defined_js__WEBPACK_IMPORTED_MODULE_16__/* ["default"] */ .Z)(ellipsoidGeometry._offsetAttribute)) {\n    var length = positions.length;\n    var applyOffset = new Uint8Array(length / 3);\n    var offsetValue =\n      ellipsoidGeometry._offsetAttribute === _GeometryOffsetAttribute_js__WEBPACK_IMPORTED_MODULE_11__/* ["default"].NONE */ .Z.NONE\n        ? 0\n        : 1;\n    (0,_arrayFill_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .Z)(applyOffset, offsetValue);\n    attributes.applyOffset = new _GeometryAttribute_js__WEBPACK_IMPORTED_MODULE_9__/* ["default"] */ .Z({\n      componentDatatype: _ComponentDatatype_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"].UNSIGNED_BYTE */ .Z.UNSIGNED_BYTE,\n      componentsPerAttribute: 1,\n      values: applyOffset,\n    });\n  }\n\n  return new _Geometry_js__WEBPACK_IMPORTED_MODULE_8__/* ["default"] */ .Z({\n    attributes: attributes,\n    indices: indices,\n    primitiveType: _PrimitiveType_js__WEBPACK_IMPORTED_MODULE_14__/* ["default"].TRIANGLES */ .Z.TRIANGLES,\n    boundingSphere: _BoundingSphere_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"].fromEllipsoid */ .Z.fromEllipsoid(ellipsoidOuter),\n    offsetAttribute: ellipsoidGeometry._offsetAttribute,\n  });\n};\n\nvar unitEllipsoidGeometry;\n\n/**\n * Returns the geometric representation of a unit ellipsoid, including its vertices, indices, and a bounding sphere.\n * @returns {Geometry} The computed vertices and indices.\n *\n * @private\n */\nEllipsoidGeometry.getUnitEllipsoid = function () {\n  if (!(0,_defined_js__WEBPACK_IMPORTED_MODULE_16__/* ["default"] */ .Z)(unitEllipsoidGeometry)) {\n    unitEllipsoidGeometry = EllipsoidGeometry.createGeometry(\n      new EllipsoidGeometry({\n        radii: new _Cartesian3_js__WEBPACK_IMPORTED_MODULE_3__/* ["default"] */ .Z(1.0, 1.0, 1.0),\n        vertexFormat: _VertexFormat_js__WEBPACK_IMPORTED_MODULE_15__/* ["default"].POSITION_ONLY */ .Z.POSITION_ONLY,\n      })\n    );\n  }\n  return unitEllipsoidGeometry;\n};\n/* harmony default export */ __webpack_exports__["Z"] = (EllipsoidGeometry);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QUFDUDtBQUNBOztBQUVBLE1BQU0saUVBQU87QUFDYjtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMsdUZBQTRCO0FBQ3pFO0FBQ0E7QUFDQSxJQUFJLGtFQUFTO0FBQ2IsaUNBQWlDLHNFQUFpQjtBQUNsRCx5QkFBeUIsa0dBQStCO0FBQ3hEO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUEsYUFBYSw2REFBUTtBQUNyQjtBQUNBO0FBQ0EsbUJBQW1CLHVGQUF1QjtBQUMxQyxvQkFBb0IsK0ZBQTRCO0FBQ2hEO0FBQ0EsR0FBRztBQUNIOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxhQUFhLFVBQVU7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPLGlFQUFPO0FBQ2Q7QUFDQTtBQUNBLG1CQUFtQiwrREFBVTtBQUM3QixzQkFBc0IsOEZBQTBCO0FBQ2hELE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlEQUFlLGlCQUFpQixFQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdnVlMy13ZWJwYWNrNS8uL25vZGVfbW9kdWxlcy9jZXNpdW0vU291cmNlL0NvcmUvRWxsaXBzb2lkR2VvbWV0cnkuanM/NzJkNCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgYXJyYXlGaWxsIGZyb20gXCIuL2FycmF5RmlsbC5qc1wiO1xuaW1wb3J0IEJvdW5kaW5nU3BoZXJlIGZyb20gXCIuL0JvdW5kaW5nU3BoZXJlLmpzXCI7XG5pbXBvcnQgQ2FydGVzaWFuMiBmcm9tIFwiLi9DYXJ0ZXNpYW4yLmpzXCI7XG5pbXBvcnQgQ2FydGVzaWFuMyBmcm9tIFwiLi9DYXJ0ZXNpYW4zLmpzXCI7XG5pbXBvcnQgQ29tcG9uZW50RGF0YXR5cGUgZnJvbSBcIi4vQ29tcG9uZW50RGF0YXR5cGUuanNcIjtcbmltcG9ydCBkZWZhdWx0VmFsdWUgZnJvbSBcIi4vZGVmYXVsdFZhbHVlLmpzXCI7XG5pbXBvcnQgZGVmaW5lZCBmcm9tIFwiLi9kZWZpbmVkLmpzXCI7XG5pbXBvcnQgRGV2ZWxvcGVyRXJyb3IgZnJvbSBcIi4vRGV2ZWxvcGVyRXJyb3IuanNcIjtcbmltcG9ydCBFbGxpcHNvaWQgZnJvbSBcIi4vRWxsaXBzb2lkLmpzXCI7XG5pbXBvcnQgR2VvbWV0cnkgZnJvbSBcIi4vR2VvbWV0cnkuanNcIjtcbmltcG9ydCBHZW9tZXRyeUF0dHJpYnV0ZSBmcm9tIFwiLi9HZW9tZXRyeUF0dHJpYnV0ZS5qc1wiO1xuaW1wb3J0IEdlb21ldHJ5QXR0cmlidXRlcyBmcm9tIFwiLi9HZW9tZXRyeUF0dHJpYnV0ZXMuanNcIjtcbmltcG9ydCBHZW9tZXRyeU9mZnNldEF0dHJpYnV0ZSBmcm9tIFwiLi9HZW9tZXRyeU9mZnNldEF0dHJpYnV0ZS5qc1wiO1xuaW1wb3J0IEluZGV4RGF0YXR5cGUgZnJvbSBcIi4vSW5kZXhEYXRhdHlwZS5qc1wiO1xuaW1wb3J0IENlc2l1bU1hdGggZnJvbSBcIi4vTWF0aC5qc1wiO1xuaW1wb3J0IFByaW1pdGl2ZVR5cGUgZnJvbSBcIi4vUHJpbWl0aXZlVHlwZS5qc1wiO1xuaW1wb3J0IFZlcnRleEZvcm1hdCBmcm9tIFwiLi9WZXJ0ZXhGb3JtYXQuanNcIjtcblxudmFyIHNjcmF0Y2hQb3NpdGlvbiA9IG5ldyBDYXJ0ZXNpYW4zKCk7XG52YXIgc2NyYXRjaE5vcm1hbCA9IG5ldyBDYXJ0ZXNpYW4zKCk7XG52YXIgc2NyYXRjaFRhbmdlbnQgPSBuZXcgQ2FydGVzaWFuMygpO1xudmFyIHNjcmF0Y2hCaXRhbmdlbnQgPSBuZXcgQ2FydGVzaWFuMygpO1xudmFyIHNjcmF0Y2hOb3JtYWxTVCA9IG5ldyBDYXJ0ZXNpYW4zKCk7XG52YXIgZGVmYXVsdFJhZGlpID0gbmV3IENhcnRlc2lhbjMoMS4wLCAxLjAsIDEuMCk7XG5cbnZhciBjb3MgPSBNYXRoLmNvcztcbnZhciBzaW4gPSBNYXRoLnNpbjtcblxuLyoqXG4gKiBBIGRlc2NyaXB0aW9uIG9mIGFuIGVsbGlwc29pZCBjZW50ZXJlZCBhdCB0aGUgb3JpZ2luLlxuICpcbiAqIEBhbGlhcyBFbGxpcHNvaWRHZW9tZXRyeVxuICogQGNvbnN0cnVjdG9yXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSBPYmplY3Qgd2l0aCB0aGUgZm9sbG93aW5nIHByb3BlcnRpZXM6XG4gKiBAcGFyYW0ge0NhcnRlc2lhbjN9IFtvcHRpb25zLnJhZGlpPUNhcnRlc2lhbjMoMS4wLCAxLjAsIDEuMCldIFRoZSByYWRpaSBvZiB0aGUgZWxsaXBzb2lkIGluIHRoZSB4LCB5LCBhbmQgeiBkaXJlY3Rpb25zLlxuICogQHBhcmFtIHtDYXJ0ZXNpYW4zfSBbb3B0aW9ucy5pbm5lclJhZGlpPW9wdGlvbnMucmFkaWldIFRoZSBpbm5lciByYWRpaSBvZiB0aGUgZWxsaXBzb2lkIGluIHRoZSB4LCB5LCBhbmQgeiBkaXJlY3Rpb25zLlxuICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLm1pbmltdW1DbG9jaz0wLjBdIFRoZSBtaW5pbXVtIGFuZ2xlIGx5aW5nIGluIHRoZSB4eS1wbGFuZSBtZWFzdXJlZCBmcm9tIHRoZSBwb3NpdGl2ZSB4LWF4aXMgYW5kIHRvd2FyZCB0aGUgcG9zaXRpdmUgeS1heGlzLlxuICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLm1heGltdW1DbG9jaz0yKlBJXSBUaGUgbWF4aW11bSBhbmdsZSBseWluZyBpbiB0aGUgeHktcGxhbmUgbWVhc3VyZWQgZnJvbSB0aGUgcG9zaXRpdmUgeC1heGlzIGFuZCB0b3dhcmQgdGhlIHBvc2l0aXZlIHktYXhpcy5cbiAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5taW5pbXVtQ29uZT0wLjBdIFRoZSBtaW5pbXVtIGFuZ2xlIG1lYXN1cmVkIGZyb20gdGhlIHBvc2l0aXZlIHotYXhpcyBhbmQgdG93YXJkIHRoZSBuZWdhdGl2ZSB6LWF4aXMuXG4gKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMubWF4aW11bUNvbmU9UEldIFRoZSBtYXhpbXVtIGFuZ2xlIG1lYXN1cmVkIGZyb20gdGhlIHBvc2l0aXZlIHotYXhpcyBhbmQgdG93YXJkIHRoZSBuZWdhdGl2ZSB6LWF4aXMuXG4gKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMuc3RhY2tQYXJ0aXRpb25zPTY0XSBUaGUgbnVtYmVyIG9mIHRpbWVzIHRvIHBhcnRpdGlvbiB0aGUgZWxsaXBzb2lkIGludG8gc3RhY2tzLlxuICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLnNsaWNlUGFydGl0aW9ucz02NF0gVGhlIG51bWJlciBvZiB0aW1lcyB0byBwYXJ0aXRpb24gdGhlIGVsbGlwc29pZCBpbnRvIHJhZGlhbCBzbGljZXMuXG4gKiBAcGFyYW0ge1ZlcnRleEZvcm1hdH0gW29wdGlvbnMudmVydGV4Rm9ybWF0PVZlcnRleEZvcm1hdC5ERUZBVUxUXSBUaGUgdmVydGV4IGF0dHJpYnV0ZXMgdG8gYmUgY29tcHV0ZWQuXG4gKlxuICogQGV4Y2VwdGlvbiB7RGV2ZWxvcGVyRXJyb3J9IG9wdGlvbnMuc2xpY2VQYXJ0aXRpb25zIGNhbm5vdCBiZSBsZXNzIHRoYW4gdGhyZWUuXG4gKiBAZXhjZXB0aW9uIHtEZXZlbG9wZXJFcnJvcn0gb3B0aW9ucy5zdGFja1BhcnRpdGlvbnMgY2Fubm90IGJlIGxlc3MgdGhhbiB0aHJlZS5cbiAqXG4gKiBAc2VlIEVsbGlwc29pZEdlb21ldHJ5I2NyZWF0ZUdlb21ldHJ5XG4gKlxuICogQGV4YW1wbGVcbiAqIHZhciBlbGxpcHNvaWQgPSBuZXcgQ2VzaXVtLkVsbGlwc29pZEdlb21ldHJ5KHtcbiAqICAgdmVydGV4Rm9ybWF0IDogQ2VzaXVtLlZlcnRleEZvcm1hdC5QT1NJVElPTl9PTkxZLFxuICogICByYWRpaSA6IG5ldyBDZXNpdW0uQ2FydGVzaWFuMygxMDAwMDAwLjAsIDUwMDAwMC4wLCA1MDAwMDAuMClcbiAqIH0pO1xuICogdmFyIGdlb21ldHJ5ID0gQ2VzaXVtLkVsbGlwc29pZEdlb21ldHJ5LmNyZWF0ZUdlb21ldHJ5KGVsbGlwc29pZCk7XG4gKi9cbmZ1bmN0aW9uIEVsbGlwc29pZEdlb21ldHJ5KG9wdGlvbnMpIHtcbiAgb3B0aW9ucyA9IGRlZmF1bHRWYWx1ZShvcHRpb25zLCBkZWZhdWx0VmFsdWUuRU1QVFlfT0JKRUNUKTtcblxuICB2YXIgcmFkaWkgPSBkZWZhdWx0VmFsdWUob3B0aW9ucy5yYWRpaSwgZGVmYXVsdFJhZGlpKTtcbiAgdmFyIGlubmVyUmFkaWkgPSBkZWZhdWx0VmFsdWUob3B0aW9ucy5pbm5lclJhZGlpLCByYWRpaSk7XG4gIHZhciBtaW5pbXVtQ2xvY2sgPSBkZWZhdWx0VmFsdWUob3B0aW9ucy5taW5pbXVtQ2xvY2ssIDAuMCk7XG4gIHZhciBtYXhpbXVtQ2xvY2sgPSBkZWZhdWx0VmFsdWUob3B0aW9ucy5tYXhpbXVtQ2xvY2ssIENlc2l1bU1hdGguVFdPX1BJKTtcbiAgdmFyIG1pbmltdW1Db25lID0gZGVmYXVsdFZhbHVlKG9wdGlvbnMubWluaW11bUNvbmUsIDAuMCk7XG4gIHZhciBtYXhpbXVtQ29uZSA9IGRlZmF1bHRWYWx1ZShvcHRpb25zLm1heGltdW1Db25lLCBDZXNpdW1NYXRoLlBJKTtcbiAgdmFyIHN0YWNrUGFydGl0aW9ucyA9IE1hdGgucm91bmQoZGVmYXVsdFZhbHVlKG9wdGlvbnMuc3RhY2tQYXJ0aXRpb25zLCA2NCkpO1xuICB2YXIgc2xpY2VQYXJ0aXRpb25zID0gTWF0aC5yb3VuZChkZWZhdWx0VmFsdWUob3B0aW9ucy5zbGljZVBhcnRpdGlvbnMsIDY0KSk7XG4gIHZhciB2ZXJ0ZXhGb3JtYXQgPSBkZWZhdWx0VmFsdWUob3B0aW9ucy52ZXJ0ZXhGb3JtYXQsIFZlcnRleEZvcm1hdC5ERUZBVUxUKTtcblxuICAvLz4+aW5jbHVkZVN0YXJ0KCdkZWJ1ZycsIHByYWdtYXMuZGVidWcpO1xuICBpZiAoc2xpY2VQYXJ0aXRpb25zIDwgMykge1xuICAgIHRocm93IG5ldyBEZXZlbG9wZXJFcnJvcihcbiAgICAgIFwib3B0aW9ucy5zbGljZVBhcnRpdGlvbnMgY2Fubm90IGJlIGxlc3MgdGhhbiB0aHJlZS5cIlxuICAgICk7XG4gIH1cbiAgaWYgKHN0YWNrUGFydGl0aW9ucyA8IDMpIHtcbiAgICB0aHJvdyBuZXcgRGV2ZWxvcGVyRXJyb3IoXG4gICAgICBcIm9wdGlvbnMuc3RhY2tQYXJ0aXRpb25zIGNhbm5vdCBiZSBsZXNzIHRoYW4gdGhyZWUuXCJcbiAgICApO1xuICB9XG4gIC8vPj5pbmNsdWRlRW5kKCdkZWJ1ZycpO1xuXG4gIHRoaXMuX3JhZGlpID0gQ2FydGVzaWFuMy5jbG9uZShyYWRpaSk7XG4gIHRoaXMuX2lubmVyUmFkaWkgPSBDYXJ0ZXNpYW4zLmNsb25lKGlubmVyUmFkaWkpO1xuICB0aGlzLl9taW5pbXVtQ2xvY2sgPSBtaW5pbXVtQ2xvY2s7XG4gIHRoaXMuX21heGltdW1DbG9jayA9IG1heGltdW1DbG9jaztcbiAgdGhpcy5fbWluaW11bUNvbmUgPSBtaW5pbXVtQ29uZTtcbiAgdGhpcy5fbWF4aW11bUNvbmUgPSBtYXhpbXVtQ29uZTtcbiAgdGhpcy5fc3RhY2tQYXJ0aXRpb25zID0gc3RhY2tQYXJ0aXRpb25zO1xuICB0aGlzLl9zbGljZVBhcnRpdGlvbnMgPSBzbGljZVBhcnRpdGlvbnM7XG4gIHRoaXMuX3ZlcnRleEZvcm1hdCA9IFZlcnRleEZvcm1hdC5jbG9uZSh2ZXJ0ZXhGb3JtYXQpO1xuICB0aGlzLl9vZmZzZXRBdHRyaWJ1dGUgPSBvcHRpb25zLm9mZnNldEF0dHJpYnV0ZTtcbiAgdGhpcy5fd29ya2VyTmFtZSA9IFwiY3JlYXRlRWxsaXBzb2lkR2VvbWV0cnlcIjtcbn1cblxuLyoqXG4gKiBUaGUgbnVtYmVyIG9mIGVsZW1lbnRzIHVzZWQgdG8gcGFjayB0aGUgb2JqZWN0IGludG8gYW4gYXJyYXkuXG4gKiBAdHlwZSB7TnVtYmVyfVxuICovXG5FbGxpcHNvaWRHZW9tZXRyeS5wYWNrZWRMZW5ndGggPVxuICAyICogQ2FydGVzaWFuMy5wYWNrZWRMZW5ndGggKyBWZXJ0ZXhGb3JtYXQucGFja2VkTGVuZ3RoICsgNztcblxuLyoqXG4gKiBTdG9yZXMgdGhlIHByb3ZpZGVkIGluc3RhbmNlIGludG8gdGhlIHByb3ZpZGVkIGFycmF5LlxuICpcbiAqIEBwYXJhbSB7RWxsaXBzb2lkR2VvbWV0cnl9IHZhbHVlIFRoZSB2YWx1ZSB0byBwYWNrLlxuICogQHBhcmFtIHtOdW1iZXJbXX0gYXJyYXkgVGhlIGFycmF5IHRvIHBhY2sgaW50by5cbiAqIEBwYXJhbSB7TnVtYmVyfSBbc3RhcnRpbmdJbmRleD0wXSBUaGUgaW5kZXggaW50byB0aGUgYXJyYXkgYXQgd2hpY2ggdG8gc3RhcnQgcGFja2luZyB0aGUgZWxlbWVudHMuXG4gKlxuICogQHJldHVybnMge051bWJlcltdfSBUaGUgYXJyYXkgdGhhdCB3YXMgcGFja2VkIGludG9cbiAqL1xuRWxsaXBzb2lkR2VvbWV0cnkucGFjayA9IGZ1bmN0aW9uICh2YWx1ZSwgYXJyYXksIHN0YXJ0aW5nSW5kZXgpIHtcbiAgLy8+PmluY2x1ZGVTdGFydCgnZGVidWcnLCBwcmFnbWFzLmRlYnVnKTtcbiAgaWYgKCFkZWZpbmVkKHZhbHVlKSkge1xuICAgIHRocm93IG5ldyBEZXZlbG9wZXJFcnJvcihcInZhbHVlIGlzIHJlcXVpcmVkXCIpO1xuICB9XG4gIGlmICghZGVmaW5lZChhcnJheSkpIHtcbiAgICB0aHJvdyBuZXcgRGV2ZWxvcGVyRXJyb3IoXCJhcnJheSBpcyByZXF1aXJlZFwiKTtcbiAgfVxuICAvLz4+aW5jbHVkZUVuZCgnZGVidWcnKTtcblxuICBzdGFydGluZ0luZGV4ID0gZGVmYXVsdFZhbHVlKHN0YXJ0aW5nSW5kZXgsIDApO1xuXG4gIENhcnRlc2lhbjMucGFjayh2YWx1ZS5fcmFkaWksIGFycmF5LCBzdGFydGluZ0luZGV4KTtcbiAgc3RhcnRpbmdJbmRleCArPSBDYXJ0ZXNpYW4zLnBhY2tlZExlbmd0aDtcblxuICBDYXJ0ZXNpYW4zLnBhY2sodmFsdWUuX2lubmVyUmFkaWksIGFycmF5LCBzdGFydGluZ0luZGV4KTtcbiAgc3RhcnRpbmdJbmRleCArPSBDYXJ0ZXNpYW4zLnBhY2tlZExlbmd0aDtcblxuICBWZXJ0ZXhGb3JtYXQucGFjayh2YWx1ZS5fdmVydGV4Rm9ybWF0LCBhcnJheSwgc3RhcnRpbmdJbmRleCk7XG4gIHN0YXJ0aW5nSW5kZXggKz0gVmVydGV4Rm9ybWF0LnBhY2tlZExlbmd0aDtcblxuICBhcnJheVtzdGFydGluZ0luZGV4KytdID0gdmFsdWUuX21pbmltdW1DbG9jaztcbiAgYXJyYXlbc3RhcnRpbmdJbmRleCsrXSA9IHZhbHVlLl9tYXhpbXVtQ2xvY2s7XG4gIGFycmF5W3N0YXJ0aW5nSW5kZXgrK10gPSB2YWx1ZS5fbWluaW11bUNvbmU7XG4gIGFycmF5W3N0YXJ0aW5nSW5kZXgrK10gPSB2YWx1ZS5fbWF4aW11bUNvbmU7XG4gIGFycmF5W3N0YXJ0aW5nSW5kZXgrK10gPSB2YWx1ZS5fc3RhY2tQYXJ0aXRpb25zO1xuICBhcnJheVtzdGFydGluZ0luZGV4KytdID0gdmFsdWUuX3NsaWNlUGFydGl0aW9ucztcbiAgYXJyYXlbc3RhcnRpbmdJbmRleF0gPSBkZWZhdWx0VmFsdWUodmFsdWUuX29mZnNldEF0dHJpYnV0ZSwgLTEpO1xuXG4gIHJldHVybiBhcnJheTtcbn07XG5cbnZhciBzY3JhdGNoUmFkaWkgPSBuZXcgQ2FydGVzaWFuMygpO1xudmFyIHNjcmF0Y2hJbm5lclJhZGlpID0gbmV3IENhcnRlc2lhbjMoKTtcbnZhciBzY3JhdGNoVmVydGV4Rm9ybWF0ID0gbmV3IFZlcnRleEZvcm1hdCgpO1xudmFyIHNjcmF0Y2hPcHRpb25zID0ge1xuICByYWRpaTogc2NyYXRjaFJhZGlpLFxuICBpbm5lclJhZGlpOiBzY3JhdGNoSW5uZXJSYWRpaSxcbiAgdmVydGV4Rm9ybWF0OiBzY3JhdGNoVmVydGV4Rm9ybWF0LFxuICBtaW5pbXVtQ2xvY2s6IHVuZGVmaW5lZCxcbiAgbWF4aW11bUNsb2NrOiB1bmRlZmluZWQsXG4gIG1pbmltdW1Db25lOiB1bmRlZmluZWQsXG4gIG1heGltdW1Db25lOiB1bmRlZmluZWQsXG4gIHN0YWNrUGFydGl0aW9uczogdW5kZWZpbmVkLFxuICBzbGljZVBhcnRpdGlvbnM6IHVuZGVmaW5lZCxcbiAgb2Zmc2V0QXR0cmlidXRlOiB1bmRlZmluZWQsXG59O1xuXG4vKipcbiAqIFJldHJpZXZlcyBhbiBpbnN0YW5jZSBmcm9tIGEgcGFja2VkIGFycmF5LlxuICpcbiAqIEBwYXJhbSB7TnVtYmVyW119IGFycmF5IFRoZSBwYWNrZWQgYXJyYXkuXG4gKiBAcGFyYW0ge051bWJlcn0gW3N0YXJ0aW5nSW5kZXg9MF0gVGhlIHN0YXJ0aW5nIGluZGV4IG9mIHRoZSBlbGVtZW50IHRvIGJlIHVucGFja2VkLlxuICogQHBhcmFtIHtFbGxpcHNvaWRHZW9tZXRyeX0gW3Jlc3VsdF0gVGhlIG9iamVjdCBpbnRvIHdoaWNoIHRvIHN0b3JlIHRoZSByZXN1bHQuXG4gKiBAcmV0dXJucyB7RWxsaXBzb2lkR2VvbWV0cnl9IFRoZSBtb2RpZmllZCByZXN1bHQgcGFyYW1ldGVyIG9yIGEgbmV3IEVsbGlwc29pZEdlb21ldHJ5IGluc3RhbmNlIGlmIG9uZSB3YXMgbm90IHByb3ZpZGVkLlxuICovXG5FbGxpcHNvaWRHZW9tZXRyeS51bnBhY2sgPSBmdW5jdGlvbiAoYXJyYXksIHN0YXJ0aW5nSW5kZXgsIHJlc3VsdCkge1xuICAvLz4+aW5jbHVkZVN0YXJ0KCdkZWJ1ZycsIHByYWdtYXMuZGVidWcpO1xuICBpZiAoIWRlZmluZWQoYXJyYXkpKSB7XG4gICAgdGhyb3cgbmV3IERldmVsb3BlckVycm9yKFwiYXJyYXkgaXMgcmVxdWlyZWRcIik7XG4gIH1cbiAgLy8+PmluY2x1ZGVFbmQoJ2RlYnVnJyk7XG5cbiAgc3RhcnRpbmdJbmRleCA9IGRlZmF1bHRWYWx1ZShzdGFydGluZ0luZGV4LCAwKTtcblxuICB2YXIgcmFkaWkgPSBDYXJ0ZXNpYW4zLnVucGFjayhhcnJheSwgc3RhcnRpbmdJbmRleCwgc2NyYXRjaFJhZGlpKTtcbiAgc3RhcnRpbmdJbmRleCArPSBDYXJ0ZXNpYW4zLnBhY2tlZExlbmd0aDtcblxuICB2YXIgaW5uZXJSYWRpaSA9IENhcnRlc2lhbjMudW5wYWNrKGFycmF5LCBzdGFydGluZ0luZGV4LCBzY3JhdGNoSW5uZXJSYWRpaSk7XG4gIHN0YXJ0aW5nSW5kZXggKz0gQ2FydGVzaWFuMy5wYWNrZWRMZW5ndGg7XG5cbiAgdmFyIHZlcnRleEZvcm1hdCA9IFZlcnRleEZvcm1hdC51bnBhY2soXG4gICAgYXJyYXksXG4gICAgc3RhcnRpbmdJbmRleCxcbiAgICBzY3JhdGNoVmVydGV4Rm9ybWF0XG4gICk7XG4gIHN0YXJ0aW5nSW5kZXggKz0gVmVydGV4Rm9ybWF0LnBhY2tlZExlbmd0aDtcblxuICB2YXIgbWluaW11bUNsb2NrID0gYXJyYXlbc3RhcnRpbmdJbmRleCsrXTtcbiAgdmFyIG1heGltdW1DbG9jayA9IGFycmF5W3N0YXJ0aW5nSW5kZXgrK107XG4gIHZhciBtaW5pbXVtQ29uZSA9IGFycmF5W3N0YXJ0aW5nSW5kZXgrK107XG4gIHZhciBtYXhpbXVtQ29uZSA9IGFycmF5W3N0YXJ0aW5nSW5kZXgrK107XG4gIHZhciBzdGFja1BhcnRpdGlvbnMgPSBhcnJheVtzdGFydGluZ0luZGV4KytdO1xuICB2YXIgc2xpY2VQYXJ0aXRpb25zID0gYXJyYXlbc3RhcnRpbmdJbmRleCsrXTtcbiAgdmFyIG9mZnNldEF0dHJpYnV0ZSA9IGFycmF5W3N0YXJ0aW5nSW5kZXhdO1xuXG4gIGlmICghZGVmaW5lZChyZXN1bHQpKSB7XG4gICAgc2NyYXRjaE9wdGlvbnMubWluaW11bUNsb2NrID0gbWluaW11bUNsb2NrO1xuICAgIHNjcmF0Y2hPcHRpb25zLm1heGltdW1DbG9jayA9IG1heGltdW1DbG9jaztcbiAgICBzY3JhdGNoT3B0aW9ucy5taW5pbXVtQ29uZSA9IG1pbmltdW1Db25lO1xuICAgIHNjcmF0Y2hPcHRpb25zLm1heGltdW1Db25lID0gbWF4aW11bUNvbmU7XG4gICAgc2NyYXRjaE9wdGlvbnMuc3RhY2tQYXJ0aXRpb25zID0gc3RhY2tQYXJ0aXRpb25zO1xuICAgIHNjcmF0Y2hPcHRpb25zLnNsaWNlUGFydGl0aW9ucyA9IHNsaWNlUGFydGl0aW9ucztcbiAgICBzY3JhdGNoT3B0aW9ucy5vZmZzZXRBdHRyaWJ1dGUgPVxuICAgICAgb2Zmc2V0QXR0cmlidXRlID09PSAtMSA/IHVuZGVmaW5lZCA6IG9mZnNldEF0dHJpYnV0ZTtcbiAgICByZXR1cm4gbmV3IEVsbGlwc29pZEdlb21ldHJ5KHNjcmF0Y2hPcHRpb25zKTtcbiAgfVxuXG4gIHJlc3VsdC5fcmFkaWkgPSBDYXJ0ZXNpYW4zLmNsb25lKHJhZGlpLCByZXN1bHQuX3JhZGlpKTtcbiAgcmVzdWx0Ll9pbm5lclJhZGlpID0gQ2FydGVzaWFuMy5jbG9uZShpbm5lclJhZGlpLCByZXN1bHQuX2lubmVyUmFkaWkpO1xuICByZXN1bHQuX3ZlcnRleEZvcm1hdCA9IFZlcnRleEZvcm1hdC5jbG9uZSh2ZXJ0ZXhGb3JtYXQsIHJlc3VsdC5fdmVydGV4Rm9ybWF0KTtcbiAgcmVzdWx0Ll9taW5pbXVtQ2xvY2sgPSBtaW5pbXVtQ2xvY2s7XG4gIHJlc3VsdC5fbWF4aW11bUNsb2NrID0gbWF4aW11bUNsb2NrO1xuICByZXN1bHQuX21pbmltdW1Db25lID0gbWluaW11bUNvbmU7XG4gIHJlc3VsdC5fbWF4aW11bUNvbmUgPSBtYXhpbXVtQ29uZTtcbiAgcmVzdWx0Ll9zdGFja1BhcnRpdGlvbnMgPSBzdGFja1BhcnRpdGlvbnM7XG4gIHJlc3VsdC5fc2xpY2VQYXJ0aXRpb25zID0gc2xpY2VQYXJ0aXRpb25zO1xuICByZXN1bHQuX29mZnNldEF0dHJpYnV0ZSA9XG4gICAgb2Zmc2V0QXR0cmlidXRlID09PSAtMSA/IHVuZGVmaW5lZCA6IG9mZnNldEF0dHJpYnV0ZTtcblxuICByZXR1cm4gcmVzdWx0O1xufTtcblxuLyoqXG4gKiBDb21wdXRlcyB0aGUgZ2VvbWV0cmljIHJlcHJlc2VudGF0aW9uIG9mIGFuIGVsbGlwc29pZCwgaW5jbHVkaW5nIGl0cyB2ZXJ0aWNlcywgaW5kaWNlcywgYW5kIGEgYm91bmRpbmcgc3BoZXJlLlxuICpcbiAqIEBwYXJhbSB7RWxsaXBzb2lkR2VvbWV0cnl9IGVsbGlwc29pZEdlb21ldHJ5IEEgZGVzY3JpcHRpb24gb2YgdGhlIGVsbGlwc29pZC5cbiAqIEByZXR1cm5zIHtHZW9tZXRyeXx1bmRlZmluZWR9IFRoZSBjb21wdXRlZCB2ZXJ0aWNlcyBhbmQgaW5kaWNlcy5cbiAqL1xuRWxsaXBzb2lkR2VvbWV0cnkuY3JlYXRlR2VvbWV0cnkgPSBmdW5jdGlvbiAoZWxsaXBzb2lkR2VvbWV0cnkpIHtcbiAgdmFyIHJhZGlpID0gZWxsaXBzb2lkR2VvbWV0cnkuX3JhZGlpO1xuICBpZiAocmFkaWkueCA8PSAwIHx8IHJhZGlpLnkgPD0gMCB8fCByYWRpaS56IDw9IDApIHtcbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgaW5uZXJSYWRpaSA9IGVsbGlwc29pZEdlb21ldHJ5Ll9pbm5lclJhZGlpO1xuICBpZiAoaW5uZXJSYWRpaS54IDw9IDAgfHwgaW5uZXJSYWRpaS55IDw9IDAgfHwgaW5uZXJSYWRpaS56IDw9IDApIHtcbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgbWluaW11bUNsb2NrID0gZWxsaXBzb2lkR2VvbWV0cnkuX21pbmltdW1DbG9jaztcbiAgdmFyIG1heGltdW1DbG9jayA9IGVsbGlwc29pZEdlb21ldHJ5Ll9tYXhpbXVtQ2xvY2s7XG4gIHZhciBtaW5pbXVtQ29uZSA9IGVsbGlwc29pZEdlb21ldHJ5Ll9taW5pbXVtQ29uZTtcbiAgdmFyIG1heGltdW1Db25lID0gZWxsaXBzb2lkR2VvbWV0cnkuX21heGltdW1Db25lO1xuICB2YXIgdmVydGV4Rm9ybWF0ID0gZWxsaXBzb2lkR2VvbWV0cnkuX3ZlcnRleEZvcm1hdDtcblxuICAvLyBBZGQgYW4gZXh0cmEgc2xpY2UgYW5kIHN0YWNrIHNvIHRoYXQgdGhlIG51bWJlciBvZiBwYXJ0aXRpb25zIGlzIHRoZVxuICAvLyBudW1iZXIgb2Ygc3VyZmFjZXMgcmF0aGVyIHRoYW4gdGhlIG51bWJlciBvZiBqb2ludHNcbiAgdmFyIHNsaWNlUGFydGl0aW9ucyA9IGVsbGlwc29pZEdlb21ldHJ5Ll9zbGljZVBhcnRpdGlvbnMgKyAxO1xuICB2YXIgc3RhY2tQYXJ0aXRpb25zID0gZWxsaXBzb2lkR2VvbWV0cnkuX3N0YWNrUGFydGl0aW9ucyArIDE7XG5cbiAgc2xpY2VQYXJ0aXRpb25zID0gTWF0aC5yb3VuZChcbiAgICAoc2xpY2VQYXJ0aXRpb25zICogTWF0aC5hYnMobWF4aW11bUNsb2NrIC0gbWluaW11bUNsb2NrKSkgL1xuICAgICAgQ2VzaXVtTWF0aC5UV09fUElcbiAgKTtcbiAgc3RhY2tQYXJ0aXRpb25zID0gTWF0aC5yb3VuZChcbiAgICAoc3RhY2tQYXJ0aXRpb25zICogTWF0aC5hYnMobWF4aW11bUNvbmUgLSBtaW5pbXVtQ29uZSkpIC8gQ2VzaXVtTWF0aC5QSVxuICApO1xuXG4gIGlmIChzbGljZVBhcnRpdGlvbnMgPCAyKSB7XG4gICAgc2xpY2VQYXJ0aXRpb25zID0gMjtcbiAgfVxuICBpZiAoc3RhY2tQYXJ0aXRpb25zIDwgMikge1xuICAgIHN0YWNrUGFydGl0aW9ucyA9IDI7XG4gIH1cblxuICB2YXIgaTtcbiAgdmFyIGo7XG4gIHZhciBpbmRleCA9IDA7XG5cbiAgLy8gQ3JlYXRlIGFycmF5cyBmb3IgdGhldGEgYW5kIHBoaS4gRHVwbGljYXRlIGZpcnN0IGFuZCBsYXN0IGFuZ2xlIHRvXG4gIC8vIGFsbG93IGRpZmZlcmVudCBub3JtYWxzIGF0IHRoZSBpbnRlcnNlY3Rpb25zLlxuICB2YXIgcGhpcyA9IFttaW5pbXVtQ29uZV07XG4gIHZhciB0aGV0YXMgPSBbbWluaW11bUNsb2NrXTtcbiAgZm9yIChpID0gMDsgaSA8IHN0YWNrUGFydGl0aW9uczsgaSsrKSB7XG4gICAgcGhpcy5wdXNoKFxuICAgICAgbWluaW11bUNvbmUgKyAoaSAqIChtYXhpbXVtQ29uZSAtIG1pbmltdW1Db25lKSkgLyAoc3RhY2tQYXJ0aXRpb25zIC0gMSlcbiAgICApO1xuICB9XG4gIHBoaXMucHVzaChtYXhpbXVtQ29uZSk7XG4gIGZvciAoaiA9IDA7IGogPCBzbGljZVBhcnRpdGlvbnM7IGorKykge1xuICAgIHRoZXRhcy5wdXNoKFxuICAgICAgbWluaW11bUNsb2NrICsgKGogKiAobWF4aW11bUNsb2NrIC0gbWluaW11bUNsb2NrKSkgLyAoc2xpY2VQYXJ0aXRpb25zIC0gMSlcbiAgICApO1xuICB9XG4gIHRoZXRhcy5wdXNoKG1heGltdW1DbG9jayk7XG4gIHZhciBudW1QaGlzID0gcGhpcy5sZW5ndGg7XG4gIHZhciBudW1UaGV0YXMgPSB0aGV0YXMubGVuZ3RoO1xuXG4gIC8vIEFsbG93IGZvciBleHRyYSBpbmRpY2VzIGlmIHRoZXJlIGlzIGFuIGlubmVyIHN1cmZhY2UgYW5kIGlmIHdlIG5lZWRcbiAgLy8gdG8gY2xvc2UgdGhlIHNpZGVzIGlmIHRoZSBjbG9jayByYW5nZSBpcyBub3QgYSBmdWxsIGNpcmNsZVxuICB2YXIgZXh0cmFJbmRpY2VzID0gMDtcbiAgdmFyIHZlcnRleE11bHRpcGxpZXIgPSAxLjA7XG4gIHZhciBoYXNJbm5lclN1cmZhY2UgPVxuICAgIGlubmVyUmFkaWkueCAhPT0gcmFkaWkueCB8fFxuICAgIGlubmVyUmFkaWkueSAhPT0gcmFkaWkueSB8fFxuICAgIGlubmVyUmFkaWkueiAhPT0gcmFkaWkuejtcbiAgdmFyIGlzVG9wT3BlbiA9IGZhbHNlO1xuICB2YXIgaXNCb3RPcGVuID0gZmFsc2U7XG4gIHZhciBpc0Nsb2NrT3BlbiA9IGZhbHNlO1xuICBpZiAoaGFzSW5uZXJTdXJmYWNlKSB7XG4gICAgdmVydGV4TXVsdGlwbGllciA9IDIuMDtcbiAgICBpZiAobWluaW11bUNvbmUgPiAwLjApIHtcbiAgICAgIGlzVG9wT3BlbiA9IHRydWU7XG4gICAgICBleHRyYUluZGljZXMgKz0gc2xpY2VQYXJ0aXRpb25zIC0gMTtcbiAgICB9XG4gICAgaWYgKG1heGltdW1Db25lIDwgTWF0aC5QSSkge1xuICAgICAgaXNCb3RPcGVuID0gdHJ1ZTtcbiAgICAgIGV4dHJhSW5kaWNlcyArPSBzbGljZVBhcnRpdGlvbnMgLSAxO1xuICAgIH1cbiAgICBpZiAoKG1heGltdW1DbG9jayAtIG1pbmltdW1DbG9jaykgJSBDZXNpdW1NYXRoLlRXT19QSSkge1xuICAgICAgaXNDbG9ja09wZW4gPSB0cnVlO1xuICAgICAgZXh0cmFJbmRpY2VzICs9IChzdGFja1BhcnRpdGlvbnMgLSAxKSAqIDIgKyAxO1xuICAgIH0gZWxzZSB7XG4gICAgICBleHRyYUluZGljZXMgKz0gMTtcbiAgICB9XG4gIH1cblxuICB2YXIgdmVydGV4Q291bnQgPSBudW1UaGV0YXMgKiBudW1QaGlzICogdmVydGV4TXVsdGlwbGllcjtcbiAgdmFyIHBvc2l0aW9ucyA9IG5ldyBGbG9hdDY0QXJyYXkodmVydGV4Q291bnQgKiAzKTtcbiAgdmFyIGlzSW5uZXIgPSBhcnJheUZpbGwobmV3IEFycmF5KHZlcnRleENvdW50KSwgZmFsc2UpO1xuICB2YXIgbmVnYXRlTm9ybWFsID0gYXJyYXlGaWxsKG5ldyBBcnJheSh2ZXJ0ZXhDb3VudCksIGZhbHNlKTtcblxuICAvLyBNdWx0aXBseSBieSA2IGJlY2F1c2UgdGhlcmUgYXJlIHR3byB0cmlhbmdsZXMgcGVyIHNlY3RvclxuICB2YXIgaW5kZXhDb3VudCA9IHNsaWNlUGFydGl0aW9ucyAqIHN0YWNrUGFydGl0aW9ucyAqIHZlcnRleE11bHRpcGxpZXI7XG4gIHZhciBudW1JbmRpY2VzID1cbiAgICA2ICpcbiAgICAoaW5kZXhDb3VudCArXG4gICAgICBleHRyYUluZGljZXMgK1xuICAgICAgMSAtXG4gICAgICAoc2xpY2VQYXJ0aXRpb25zICsgc3RhY2tQYXJ0aXRpb25zKSAqIHZlcnRleE11bHRpcGxpZXIpO1xuICB2YXIgaW5kaWNlcyA9IEluZGV4RGF0YXR5cGUuY3JlYXRlVHlwZWRBcnJheShpbmRleENvdW50LCBudW1JbmRpY2VzKTtcblxuICB2YXIgbm9ybWFscyA9IHZlcnRleEZvcm1hdC5ub3JtYWxcbiAgICA/IG5ldyBGbG9hdDMyQXJyYXkodmVydGV4Q291bnQgKiAzKVxuICAgIDogdW5kZWZpbmVkO1xuICB2YXIgdGFuZ2VudHMgPSB2ZXJ0ZXhGb3JtYXQudGFuZ2VudFxuICAgID8gbmV3IEZsb2F0MzJBcnJheSh2ZXJ0ZXhDb3VudCAqIDMpXG4gICAgOiB1bmRlZmluZWQ7XG4gIHZhciBiaXRhbmdlbnRzID0gdmVydGV4Rm9ybWF0LmJpdGFuZ2VudFxuICAgID8gbmV3IEZsb2F0MzJBcnJheSh2ZXJ0ZXhDb3VudCAqIDMpXG4gICAgOiB1bmRlZmluZWQ7XG4gIHZhciBzdCA9IHZlcnRleEZvcm1hdC5zdCA/IG5ldyBGbG9hdDMyQXJyYXkodmVydGV4Q291bnQgKiAyKSA6IHVuZGVmaW5lZDtcblxuICAvLyBDYWxjdWxhdGUgc2luL2NvcyBwaGlcbiAgdmFyIHNpblBoaSA9IG5ldyBBcnJheShudW1QaGlzKTtcbiAgdmFyIGNvc1BoaSA9IG5ldyBBcnJheShudW1QaGlzKTtcbiAgZm9yIChpID0gMDsgaSA8IG51bVBoaXM7IGkrKykge1xuICAgIHNpblBoaVtpXSA9IHNpbihwaGlzW2ldKTtcbiAgICBjb3NQaGlbaV0gPSBjb3MocGhpc1tpXSk7XG4gIH1cblxuICAvLyBDYWxjdWxhdGUgc2luL2NvcyB0aGV0YVxuICB2YXIgc2luVGhldGEgPSBuZXcgQXJyYXkobnVtVGhldGFzKTtcbiAgdmFyIGNvc1RoZXRhID0gbmV3IEFycmF5KG51bVRoZXRhcyk7XG4gIGZvciAoaiA9IDA7IGogPCBudW1UaGV0YXM7IGorKykge1xuICAgIGNvc1RoZXRhW2pdID0gY29zKHRoZXRhc1tqXSk7XG4gICAgc2luVGhldGFbal0gPSBzaW4odGhldGFzW2pdKTtcbiAgfVxuXG4gIC8vIENyZWF0ZSBvdXRlciBzdXJmYWNlXG4gIGZvciAoaSA9IDA7IGkgPCBudW1QaGlzOyBpKyspIHtcbiAgICBmb3IgKGogPSAwOyBqIDwgbnVtVGhldGFzOyBqKyspIHtcbiAgICAgIHBvc2l0aW9uc1tpbmRleCsrXSA9IHJhZGlpLnggKiBzaW5QaGlbaV0gKiBjb3NUaGV0YVtqXTtcbiAgICAgIHBvc2l0aW9uc1tpbmRleCsrXSA9IHJhZGlpLnkgKiBzaW5QaGlbaV0gKiBzaW5UaGV0YVtqXTtcbiAgICAgIHBvc2l0aW9uc1tpbmRleCsrXSA9IHJhZGlpLnogKiBjb3NQaGlbaV07XG4gICAgfVxuICB9XG5cbiAgLy8gQ3JlYXRlIGlubmVyIHN1cmZhY2VcbiAgdmFyIHZlcnRleEluZGV4ID0gdmVydGV4Q291bnQgLyAyLjA7XG4gIGlmIChoYXNJbm5lclN1cmZhY2UpIHtcbiAgICBmb3IgKGkgPSAwOyBpIDwgbnVtUGhpczsgaSsrKSB7XG4gICAgICBmb3IgKGogPSAwOyBqIDwgbnVtVGhldGFzOyBqKyspIHtcbiAgICAgICAgcG9zaXRpb25zW2luZGV4KytdID0gaW5uZXJSYWRpaS54ICogc2luUGhpW2ldICogY29zVGhldGFbal07XG4gICAgICAgIHBvc2l0aW9uc1tpbmRleCsrXSA9IGlubmVyUmFkaWkueSAqIHNpblBoaVtpXSAqIHNpblRoZXRhW2pdO1xuICAgICAgICBwb3NpdGlvbnNbaW5kZXgrK10gPSBpbm5lclJhZGlpLnogKiBjb3NQaGlbaV07XG5cbiAgICAgICAgLy8gS2VlcCB0cmFjayBvZiB3aGljaCB2ZXJ0aWNlcyBhcmUgdGhlIGlubmVyIGFuZCB3aGljaCBvbmVzXG4gICAgICAgIC8vIG5lZWQgdGhlIG5vcm1hbCB0byBiZSBuZWdhdGVkXG4gICAgICAgIGlzSW5uZXJbdmVydGV4SW5kZXhdID0gdHJ1ZTtcbiAgICAgICAgaWYgKGkgPiAwICYmIGkgIT09IG51bVBoaXMgLSAxICYmIGogIT09IDAgJiYgaiAhPT0gbnVtVGhldGFzIC0gMSkge1xuICAgICAgICAgIG5lZ2F0ZU5vcm1hbFt2ZXJ0ZXhJbmRleF0gPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHZlcnRleEluZGV4Kys7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLy8gQ3JlYXRlIGluZGljZXMgZm9yIG91dGVyIHN1cmZhY2VcbiAgaW5kZXggPSAwO1xuICB2YXIgdG9wT2Zmc2V0O1xuICB2YXIgYm90dG9tT2Zmc2V0O1xuICBmb3IgKGkgPSAxOyBpIDwgbnVtUGhpcyAtIDI7IGkrKykge1xuICAgIHRvcE9mZnNldCA9IGkgKiBudW1UaGV0YXM7XG4gICAgYm90dG9tT2Zmc2V0ID0gKGkgKyAxKSAqIG51bVRoZXRhcztcblxuICAgIGZvciAoaiA9IDE7IGogPCBudW1UaGV0YXMgLSAyOyBqKyspIHtcbiAgICAgIGluZGljZXNbaW5kZXgrK10gPSBib3R0b21PZmZzZXQgKyBqO1xuICAgICAgaW5kaWNlc1tpbmRleCsrXSA9IGJvdHRvbU9mZnNldCArIGogKyAxO1xuICAgICAgaW5kaWNlc1tpbmRleCsrXSA9IHRvcE9mZnNldCArIGogKyAxO1xuXG4gICAgICBpbmRpY2VzW2luZGV4KytdID0gYm90dG9tT2Zmc2V0ICsgajtcbiAgICAgIGluZGljZXNbaW5kZXgrK10gPSB0b3BPZmZzZXQgKyBqICsgMTtcbiAgICAgIGluZGljZXNbaW5kZXgrK10gPSB0b3BPZmZzZXQgKyBqO1xuICAgIH1cbiAgfVxuXG4gIC8vIENyZWF0ZSBpbmRpY2VzIGZvciBpbm5lciBzdXJmYWNlXG4gIGlmIChoYXNJbm5lclN1cmZhY2UpIHtcbiAgICB2YXIgb2Zmc2V0ID0gbnVtUGhpcyAqIG51bVRoZXRhcztcbiAgICBmb3IgKGkgPSAxOyBpIDwgbnVtUGhpcyAtIDI7IGkrKykge1xuICAgICAgdG9wT2Zmc2V0ID0gb2Zmc2V0ICsgaSAqIG51bVRoZXRhcztcbiAgICAgIGJvdHRvbU9mZnNldCA9IG9mZnNldCArIChpICsgMSkgKiBudW1UaGV0YXM7XG5cbiAgICAgIGZvciAoaiA9IDE7IGogPCBudW1UaGV0YXMgLSAyOyBqKyspIHtcbiAgICAgICAgaW5kaWNlc1tpbmRleCsrXSA9IGJvdHRvbU9mZnNldCArIGo7XG4gICAgICAgIGluZGljZXNbaW5kZXgrK10gPSB0b3BPZmZzZXQgKyBqO1xuICAgICAgICBpbmRpY2VzW2luZGV4KytdID0gdG9wT2Zmc2V0ICsgaiArIDE7XG5cbiAgICAgICAgaW5kaWNlc1tpbmRleCsrXSA9IGJvdHRvbU9mZnNldCArIGo7XG4gICAgICAgIGluZGljZXNbaW5kZXgrK10gPSB0b3BPZmZzZXQgKyBqICsgMTtcbiAgICAgICAgaW5kaWNlc1tpbmRleCsrXSA9IGJvdHRvbU9mZnNldCArIGogKyAxO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHZhciBvdXRlck9mZnNldDtcbiAgdmFyIGlubmVyT2Zmc2V0O1xuICBpZiAoaGFzSW5uZXJTdXJmYWNlKSB7XG4gICAgaWYgKGlzVG9wT3Blbikge1xuICAgICAgLy8gQ29ubmVjdCB0aGUgdG9wIG9mIHRoZSBpbm5lciBzdXJmYWNlIHRvIHRoZSB0b3Agb2YgdGhlIG91dGVyIHN1cmZhY2VcbiAgICAgIGlubmVyT2Zmc2V0ID0gbnVtUGhpcyAqIG51bVRoZXRhcztcbiAgICAgIGZvciAoaSA9IDE7IGkgPCBudW1UaGV0YXMgLSAyOyBpKyspIHtcbiAgICAgICAgaW5kaWNlc1tpbmRleCsrXSA9IGk7XG4gICAgICAgIGluZGljZXNbaW5kZXgrK10gPSBpICsgMTtcbiAgICAgICAgaW5kaWNlc1tpbmRleCsrXSA9IGlubmVyT2Zmc2V0ICsgaSArIDE7XG5cbiAgICAgICAgaW5kaWNlc1tpbmRleCsrXSA9IGk7XG4gICAgICAgIGluZGljZXNbaW5kZXgrK10gPSBpbm5lck9mZnNldCArIGkgKyAxO1xuICAgICAgICBpbmRpY2VzW2luZGV4KytdID0gaW5uZXJPZmZzZXQgKyBpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChpc0JvdE9wZW4pIHtcbiAgICAgIC8vIENvbm5lY3QgdGhlIGJvdHRvbSBvZiB0aGUgaW5uZXIgc3VyZmFjZSB0byB0aGUgYm90dG9tIG9mIHRoZSBvdXRlciBzdXJmYWNlXG4gICAgICBvdXRlck9mZnNldCA9IG51bVBoaXMgKiBudW1UaGV0YXMgLSBudW1UaGV0YXM7XG4gICAgICBpbm5lck9mZnNldCA9IG51bVBoaXMgKiBudW1UaGV0YXMgKiB2ZXJ0ZXhNdWx0aXBsaWVyIC0gbnVtVGhldGFzO1xuICAgICAgZm9yIChpID0gMTsgaSA8IG51bVRoZXRhcyAtIDI7IGkrKykge1xuICAgICAgICBpbmRpY2VzW2luZGV4KytdID0gb3V0ZXJPZmZzZXQgKyBpICsgMTtcbiAgICAgICAgaW5kaWNlc1tpbmRleCsrXSA9IG91dGVyT2Zmc2V0ICsgaTtcbiAgICAgICAgaW5kaWNlc1tpbmRleCsrXSA9IGlubmVyT2Zmc2V0ICsgaTtcblxuICAgICAgICBpbmRpY2VzW2luZGV4KytdID0gb3V0ZXJPZmZzZXQgKyBpICsgMTtcbiAgICAgICAgaW5kaWNlc1tpbmRleCsrXSA9IGlubmVyT2Zmc2V0ICsgaTtcbiAgICAgICAgaW5kaWNlc1tpbmRleCsrXSA9IGlubmVyT2Zmc2V0ICsgaSArIDE7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLy8gQ29ubmVjdCB0aGUgZWRnZXMgaWYgY2xvY2sgaXMgbm90IGNsb3NlZFxuICBpZiAoaXNDbG9ja09wZW4pIHtcbiAgICBmb3IgKGkgPSAxOyBpIDwgbnVtUGhpcyAtIDI7IGkrKykge1xuICAgICAgaW5uZXJPZmZzZXQgPSBudW1UaGV0YXMgKiBudW1QaGlzICsgbnVtVGhldGFzICogaTtcbiAgICAgIG91dGVyT2Zmc2V0ID0gbnVtVGhldGFzICogaTtcbiAgICAgIGluZGljZXNbaW5kZXgrK10gPSBpbm5lck9mZnNldDtcbiAgICAgIGluZGljZXNbaW5kZXgrK10gPSBvdXRlck9mZnNldCArIG51bVRoZXRhcztcbiAgICAgIGluZGljZXNbaW5kZXgrK10gPSBvdXRlck9mZnNldDtcblxuICAgICAgaW5kaWNlc1tpbmRleCsrXSA9IGlubmVyT2Zmc2V0O1xuICAgICAgaW5kaWNlc1tpbmRleCsrXSA9IGlubmVyT2Zmc2V0ICsgbnVtVGhldGFzO1xuICAgICAgaW5kaWNlc1tpbmRleCsrXSA9IG91dGVyT2Zmc2V0ICsgbnVtVGhldGFzO1xuICAgIH1cblxuICAgIGZvciAoaSA9IDE7IGkgPCBudW1QaGlzIC0gMjsgaSsrKSB7XG4gICAgICBpbm5lck9mZnNldCA9IG51bVRoZXRhcyAqIG51bVBoaXMgKyBudW1UaGV0YXMgKiAoaSArIDEpIC0gMTtcbiAgICAgIG91dGVyT2Zmc2V0ID0gbnVtVGhldGFzICogKGkgKyAxKSAtIDE7XG4gICAgICBpbmRpY2VzW2luZGV4KytdID0gb3V0ZXJPZmZzZXQgKyBudW1UaGV0YXM7XG4gICAgICBpbmRpY2VzW2luZGV4KytdID0gaW5uZXJPZmZzZXQ7XG4gICAgICBpbmRpY2VzW2luZGV4KytdID0gb3V0ZXJPZmZzZXQ7XG5cbiAgICAgIGluZGljZXNbaW5kZXgrK10gPSBvdXRlck9mZnNldCArIG51bVRoZXRhcztcbiAgICAgIGluZGljZXNbaW5kZXgrK10gPSBpbm5lck9mZnNldCArIG51bVRoZXRhcztcbiAgICAgIGluZGljZXNbaW5kZXgrK10gPSBpbm5lck9mZnNldDtcbiAgICB9XG4gIH1cblxuICB2YXIgYXR0cmlidXRlcyA9IG5ldyBHZW9tZXRyeUF0dHJpYnV0ZXMoKTtcblxuICBpZiAodmVydGV4Rm9ybWF0LnBvc2l0aW9uKSB7XG4gICAgYXR0cmlidXRlcy5wb3NpdGlvbiA9IG5ldyBHZW9tZXRyeUF0dHJpYnV0ZSh7XG4gICAgICBjb21wb25lbnREYXRhdHlwZTogQ29tcG9uZW50RGF0YXR5cGUuRE9VQkxFLFxuICAgICAgY29tcG9uZW50c1BlckF0dHJpYnV0ZTogMyxcbiAgICAgIHZhbHVlczogcG9zaXRpb25zLFxuICAgIH0pO1xuICB9XG5cbiAgdmFyIHN0SW5kZXggPSAwO1xuICB2YXIgbm9ybWFsSW5kZXggPSAwO1xuICB2YXIgdGFuZ2VudEluZGV4ID0gMDtcbiAgdmFyIGJpdGFuZ2VudEluZGV4ID0gMDtcbiAgdmFyIHZlcnRleENvdW50SGFsZiA9IHZlcnRleENvdW50IC8gMi4wO1xuXG4gIHZhciBlbGxpcHNvaWQ7XG4gIHZhciBlbGxpcHNvaWRPdXRlciA9IEVsbGlwc29pZC5mcm9tQ2FydGVzaWFuMyhyYWRpaSk7XG4gIHZhciBlbGxpcHNvaWRJbm5lciA9IEVsbGlwc29pZC5mcm9tQ2FydGVzaWFuMyhpbm5lclJhZGlpKTtcblxuICBpZiAoXG4gICAgdmVydGV4Rm9ybWF0LnN0IHx8XG4gICAgdmVydGV4Rm9ybWF0Lm5vcm1hbCB8fFxuICAgIHZlcnRleEZvcm1hdC50YW5nZW50IHx8XG4gICAgdmVydGV4Rm9ybWF0LmJpdGFuZ2VudFxuICApIHtcbiAgICBmb3IgKGkgPSAwOyBpIDwgdmVydGV4Q291bnQ7IGkrKykge1xuICAgICAgZWxsaXBzb2lkID0gaXNJbm5lcltpXSA/IGVsbGlwc29pZElubmVyIDogZWxsaXBzb2lkT3V0ZXI7XG4gICAgICB2YXIgcG9zaXRpb24gPSBDYXJ0ZXNpYW4zLmZyb21BcnJheShwb3NpdGlvbnMsIGkgKiAzLCBzY3JhdGNoUG9zaXRpb24pO1xuICAgICAgdmFyIG5vcm1hbCA9IGVsbGlwc29pZC5nZW9kZXRpY1N1cmZhY2VOb3JtYWwocG9zaXRpb24sIHNjcmF0Y2hOb3JtYWwpO1xuICAgICAgaWYgKG5lZ2F0ZU5vcm1hbFtpXSkge1xuICAgICAgICBDYXJ0ZXNpYW4zLm5lZ2F0ZShub3JtYWwsIG5vcm1hbCk7XG4gICAgICB9XG5cbiAgICAgIGlmICh2ZXJ0ZXhGb3JtYXQuc3QpIHtcbiAgICAgICAgdmFyIG5vcm1hbFNUID0gQ2FydGVzaWFuMi5uZWdhdGUobm9ybWFsLCBzY3JhdGNoTm9ybWFsU1QpO1xuICAgICAgICBzdFtzdEluZGV4KytdID1cbiAgICAgICAgICBNYXRoLmF0YW4yKG5vcm1hbFNULnksIG5vcm1hbFNULngpIC8gQ2VzaXVtTWF0aC5UV09fUEkgKyAwLjU7XG4gICAgICAgIHN0W3N0SW5kZXgrK10gPSBNYXRoLmFzaW4obm9ybWFsLnopIC8gTWF0aC5QSSArIDAuNTtcbiAgICAgIH1cblxuICAgICAgaWYgKHZlcnRleEZvcm1hdC5ub3JtYWwpIHtcbiAgICAgICAgbm9ybWFsc1tub3JtYWxJbmRleCsrXSA9IG5vcm1hbC54O1xuICAgICAgICBub3JtYWxzW25vcm1hbEluZGV4KytdID0gbm9ybWFsLnk7XG4gICAgICAgIG5vcm1hbHNbbm9ybWFsSW5kZXgrK10gPSBub3JtYWwuejtcbiAgICAgIH1cblxuICAgICAgaWYgKHZlcnRleEZvcm1hdC50YW5nZW50IHx8IHZlcnRleEZvcm1hdC5iaXRhbmdlbnQpIHtcbiAgICAgICAgdmFyIHRhbmdlbnQgPSBzY3JhdGNoVGFuZ2VudDtcblxuICAgICAgICAvLyBVc2UgVU5JVF9YIGZvciB0aGUgcG9sZXNcbiAgICAgICAgdmFyIHRhbmdldE9mZnNldCA9IDA7XG4gICAgICAgIHZhciB1bml0O1xuICAgICAgICBpZiAoaXNJbm5lcltpXSkge1xuICAgICAgICAgIHRhbmdldE9mZnNldCA9IHZlcnRleENvdW50SGFsZjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoXG4gICAgICAgICAgIWlzVG9wT3BlbiAmJlxuICAgICAgICAgIGkgPj0gdGFuZ2V0T2Zmc2V0ICYmXG4gICAgICAgICAgaSA8IHRhbmdldE9mZnNldCArIG51bVRoZXRhcyAqIDJcbiAgICAgICAgKSB7XG4gICAgICAgICAgdW5pdCA9IENhcnRlc2lhbjMuVU5JVF9YO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHVuaXQgPSBDYXJ0ZXNpYW4zLlVOSVRfWjtcbiAgICAgICAgfVxuICAgICAgICBDYXJ0ZXNpYW4zLmNyb3NzKHVuaXQsIG5vcm1hbCwgdGFuZ2VudCk7XG4gICAgICAgIENhcnRlc2lhbjMubm9ybWFsaXplKHRhbmdlbnQsIHRhbmdlbnQpO1xuXG4gICAgICAgIGlmICh2ZXJ0ZXhGb3JtYXQudGFuZ2VudCkge1xuICAgICAgICAgIHRhbmdlbnRzW3RhbmdlbnRJbmRleCsrXSA9IHRhbmdlbnQueDtcbiAgICAgICAgICB0YW5nZW50c1t0YW5nZW50SW5kZXgrK10gPSB0YW5nZW50Lnk7XG4gICAgICAgICAgdGFuZ2VudHNbdGFuZ2VudEluZGV4KytdID0gdGFuZ2VudC56O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHZlcnRleEZvcm1hdC5iaXRhbmdlbnQpIHtcbiAgICAgICAgICB2YXIgYml0YW5nZW50ID0gQ2FydGVzaWFuMy5jcm9zcyhub3JtYWwsIHRhbmdlbnQsIHNjcmF0Y2hCaXRhbmdlbnQpO1xuICAgICAgICAgIENhcnRlc2lhbjMubm9ybWFsaXplKGJpdGFuZ2VudCwgYml0YW5nZW50KTtcblxuICAgICAgICAgIGJpdGFuZ2VudHNbYml0YW5nZW50SW5kZXgrK10gPSBiaXRhbmdlbnQueDtcbiAgICAgICAgICBiaXRhbmdlbnRzW2JpdGFuZ2VudEluZGV4KytdID0gYml0YW5nZW50Lnk7XG4gICAgICAgICAgYml0YW5nZW50c1tiaXRhbmdlbnRJbmRleCsrXSA9IGJpdGFuZ2VudC56O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHZlcnRleEZvcm1hdC5zdCkge1xuICAgICAgYXR0cmlidXRlcy5zdCA9IG5ldyBHZW9tZXRyeUF0dHJpYnV0ZSh7XG4gICAgICAgIGNvbXBvbmVudERhdGF0eXBlOiBDb21wb25lbnREYXRhdHlwZS5GTE9BVCxcbiAgICAgICAgY29tcG9uZW50c1BlckF0dHJpYnV0ZTogMixcbiAgICAgICAgdmFsdWVzOiBzdCxcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGlmICh2ZXJ0ZXhGb3JtYXQubm9ybWFsKSB7XG4gICAgICBhdHRyaWJ1dGVzLm5vcm1hbCA9IG5ldyBHZW9tZXRyeUF0dHJpYnV0ZSh7XG4gICAgICAgIGNvbXBvbmVudERhdGF0eXBlOiBDb21wb25lbnREYXRhdHlwZS5GTE9BVCxcbiAgICAgICAgY29tcG9uZW50c1BlckF0dHJpYnV0ZTogMyxcbiAgICAgICAgdmFsdWVzOiBub3JtYWxzLFxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgaWYgKHZlcnRleEZvcm1hdC50YW5nZW50KSB7XG4gICAgICBhdHRyaWJ1dGVzLnRhbmdlbnQgPSBuZXcgR2VvbWV0cnlBdHRyaWJ1dGUoe1xuICAgICAgICBjb21wb25lbnREYXRhdHlwZTogQ29tcG9uZW50RGF0YXR5cGUuRkxPQVQsXG4gICAgICAgIGNvbXBvbmVudHNQZXJBdHRyaWJ1dGU6IDMsXG4gICAgICAgIHZhbHVlczogdGFuZ2VudHMsXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBpZiAodmVydGV4Rm9ybWF0LmJpdGFuZ2VudCkge1xuICAgICAgYXR0cmlidXRlcy5iaXRhbmdlbnQgPSBuZXcgR2VvbWV0cnlBdHRyaWJ1dGUoe1xuICAgICAgICBjb21wb25lbnREYXRhdHlwZTogQ29tcG9uZW50RGF0YXR5cGUuRkxPQVQsXG4gICAgICAgIGNvbXBvbmVudHNQZXJBdHRyaWJ1dGU6IDMsXG4gICAgICAgIHZhbHVlczogYml0YW5nZW50cyxcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIGlmIChkZWZpbmVkKGVsbGlwc29pZEdlb21ldHJ5Ll9vZmZzZXRBdHRyaWJ1dGUpKSB7XG4gICAgdmFyIGxlbmd0aCA9IHBvc2l0aW9ucy5sZW5ndGg7XG4gICAgdmFyIGFwcGx5T2Zmc2V0ID0gbmV3IFVpbnQ4QXJyYXkobGVuZ3RoIC8gMyk7XG4gICAgdmFyIG9mZnNldFZhbHVlID1cbiAgICAgIGVsbGlwc29pZEdlb21ldHJ5Ll9vZmZzZXRBdHRyaWJ1dGUgPT09IEdlb21ldHJ5T2Zmc2V0QXR0cmlidXRlLk5PTkVcbiAgICAgICAgPyAwXG4gICAgICAgIDogMTtcbiAgICBhcnJheUZpbGwoYXBwbHlPZmZzZXQsIG9mZnNldFZhbHVlKTtcbiAgICBhdHRyaWJ1dGVzLmFwcGx5T2Zmc2V0ID0gbmV3IEdlb21ldHJ5QXR0cmlidXRlKHtcbiAgICAgIGNvbXBvbmVudERhdGF0eXBlOiBDb21wb25lbnREYXRhdHlwZS5VTlNJR05FRF9CWVRFLFxuICAgICAgY29tcG9uZW50c1BlckF0dHJpYnV0ZTogMSxcbiAgICAgIHZhbHVlczogYXBwbHlPZmZzZXQsXG4gICAgfSk7XG4gIH1cblxuICByZXR1cm4gbmV3IEdlb21ldHJ5KHtcbiAgICBhdHRyaWJ1dGVzOiBhdHRyaWJ1dGVzLFxuICAgIGluZGljZXM6IGluZGljZXMsXG4gICAgcHJpbWl0aXZlVHlwZTogUHJpbWl0aXZlVHlwZS5UUklBTkdMRVMsXG4gICAgYm91bmRpbmdTcGhlcmU6IEJvdW5kaW5nU3BoZXJlLmZyb21FbGxpcHNvaWQoZWxsaXBzb2lkT3V0ZXIpLFxuICAgIG9mZnNldEF0dHJpYnV0ZTogZWxsaXBzb2lkR2VvbWV0cnkuX29mZnNldEF0dHJpYnV0ZSxcbiAgfSk7XG59O1xuXG52YXIgdW5pdEVsbGlwc29pZEdlb21ldHJ5O1xuXG4vKipcbiAqIFJldHVybnMgdGhlIGdlb21ldHJpYyByZXByZXNlbnRhdGlvbiBvZiBhIHVuaXQgZWxsaXBzb2lkLCBpbmNsdWRpbmcgaXRzIHZlcnRpY2VzLCBpbmRpY2VzLCBhbmQgYSBib3VuZGluZyBzcGhlcmUuXG4gKiBAcmV0dXJucyB7R2VvbWV0cnl9IFRoZSBjb21wdXRlZCB2ZXJ0aWNlcyBhbmQgaW5kaWNlcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICovXG5FbGxpcHNvaWRHZW9tZXRyeS5nZXRVbml0RWxsaXBzb2lkID0gZnVuY3Rpb24gKCkge1xuICBpZiAoIWRlZmluZWQodW5pdEVsbGlwc29pZEdlb21ldHJ5KSkge1xuICAgIHVuaXRFbGxpcHNvaWRHZW9tZXRyeSA9IEVsbGlwc29pZEdlb21ldHJ5LmNyZWF0ZUdlb21ldHJ5KFxuICAgICAgbmV3IEVsbGlwc29pZEdlb21ldHJ5KHtcbiAgICAgICAgcmFkaWk6IG5ldyBDYXJ0ZXNpYW4zKDEuMCwgMS4wLCAxLjApLFxuICAgICAgICB2ZXJ0ZXhGb3JtYXQ6IFZlcnRleEZvcm1hdC5QT1NJVElPTl9PTkxZLFxuICAgICAgfSlcbiAgICApO1xuICB9XG4gIHJldHVybiB1bml0RWxsaXBzb2lkR2VvbWV0cnk7XG59O1xuZXhwb3J0IGRlZmF1bHQgRWxsaXBzb2lkR2VvbWV0cnk7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///64727\n')},75619:function(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__){eval('/* harmony import */ var _arrayFill_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(23401);\n/* harmony import */ var _BoundingSphere_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(48243);\n/* harmony import */ var _Cartesian3_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(60216);\n/* harmony import */ var _ComponentDatatype_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(84828);\n/* harmony import */ var _defaultValue_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(62200);\n/* harmony import */ var _defined_js__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(82982);\n/* harmony import */ var _DeveloperError_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(12572);\n/* harmony import */ var _Ellipsoid_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(50491);\n/* harmony import */ var _Geometry_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(82408);\n/* harmony import */ var _GeometryAttribute_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(13616);\n/* harmony import */ var _GeometryAttributes_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(56652);\n/* harmony import */ var _GeometryOffsetAttribute_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(87379);\n/* harmony import */ var _IndexDatatype_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(22832);\n/* harmony import */ var _Math_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(99417);\n/* harmony import */ var _PrimitiveType_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(97264);\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nvar defaultRadii = new _Cartesian3_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"] */ .Z(1.0, 1.0, 1.0);\nvar cos = Math.cos;\nvar sin = Math.sin;\n\n/**\n * A description of the outline of an ellipsoid centered at the origin.\n *\n * @alias EllipsoidOutlineGeometry\n * @constructor\n *\n * @param {Object} [options] Object with the following properties:\n * @param {Cartesian3} [options.radii=Cartesian3(1.0, 1.0, 1.0)] The radii of the ellipsoid in the x, y, and z directions.\n * @param {Cartesian3} [options.innerRadii=options.radii] The inner radii of the ellipsoid in the x, y, and z directions.\n * @param {Number} [options.minimumClock=0.0] The minimum angle lying in the xy-plane measured from the positive x-axis and toward the positive y-axis.\n * @param {Number} [options.maximumClock=2*PI] The maximum angle lying in the xy-plane measured from the positive x-axis and toward the positive y-axis.\n * @param {Number} [options.minimumCone=0.0] The minimum angle measured from the positive z-axis and toward the negative z-axis.\n * @param {Number} [options.maximumCone=PI] The maximum angle measured from the positive z-axis and toward the negative z-axis.\n * @param {Number} [options.stackPartitions=10] The count of stacks for the ellipsoid (1 greater than the number of parallel lines).\n * @param {Number} [options.slicePartitions=8] The count of slices for the ellipsoid (Equal to the number of radial lines).\n * @param {Number} [options.subdivisions=128] The number of points per line, determining the granularity of the curvature.\n *\n * @exception {DeveloperError} options.stackPartitions must be greater than or equal to one.\n * @exception {DeveloperError} options.slicePartitions must be greater than or equal to zero.\n * @exception {DeveloperError} options.subdivisions must be greater than or equal to zero.\n *\n * @example\n * var ellipsoid = new Cesium.EllipsoidOutlineGeometry({\n *   radii : new Cesium.Cartesian3(1000000.0, 500000.0, 500000.0),\n *   stackPartitions: 6,\n *   slicePartitions: 5\n * });\n * var geometry = Cesium.EllipsoidOutlineGeometry.createGeometry(ellipsoid);\n */\nfunction EllipsoidOutlineGeometry(options) {\n  options = (0,_defaultValue_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .Z)(options, _defaultValue_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"].EMPTY_OBJECT */ .Z.EMPTY_OBJECT);\n\n  var radii = (0,_defaultValue_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .Z)(options.radii, defaultRadii);\n  var innerRadii = (0,_defaultValue_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .Z)(options.innerRadii, radii);\n  var minimumClock = (0,_defaultValue_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .Z)(options.minimumClock, 0.0);\n  var maximumClock = (0,_defaultValue_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .Z)(options.maximumClock, _Math_js__WEBPACK_IMPORTED_MODULE_12__/* ["default"].TWO_PI */ .Z.TWO_PI);\n  var minimumCone = (0,_defaultValue_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .Z)(options.minimumCone, 0.0);\n  var maximumCone = (0,_defaultValue_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .Z)(options.maximumCone, _Math_js__WEBPACK_IMPORTED_MODULE_12__/* ["default"].PI */ .Z.PI);\n  var stackPartitions = Math.round((0,_defaultValue_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .Z)(options.stackPartitions, 10));\n  var slicePartitions = Math.round((0,_defaultValue_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .Z)(options.slicePartitions, 8));\n  var subdivisions = Math.round((0,_defaultValue_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .Z)(options.subdivisions, 128));\n\n  //>>includeStart(\'debug\', pragmas.debug);\n  if (stackPartitions < 1) {\n    throw new _DeveloperError_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"] */ .Z("options.stackPartitions cannot be less than 1");\n  }\n  if (slicePartitions < 0) {\n    throw new _DeveloperError_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"] */ .Z("options.slicePartitions cannot be less than 0");\n  }\n  if (subdivisions < 0) {\n    throw new _DeveloperError_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"] */ .Z(\n      "options.subdivisions must be greater than or equal to zero."\n    );\n  }\n  if (\n    (0,_defined_js__WEBPACK_IMPORTED_MODULE_14__/* ["default"] */ .Z)(options.offsetAttribute) &&\n    options.offsetAttribute === _GeometryOffsetAttribute_js__WEBPACK_IMPORTED_MODULE_10__/* ["default"].TOP */ .Z.TOP\n  ) {\n    throw new _DeveloperError_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"] */ .Z(\n      "GeometryOffsetAttribute.TOP is not a supported options.offsetAttribute for this geometry."\n    );\n  }\n  //>>includeEnd(\'debug\');\n\n  this._radii = _Cartesian3_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"].clone */ .Z.clone(radii);\n  this._innerRadii = _Cartesian3_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"].clone */ .Z.clone(innerRadii);\n  this._minimumClock = minimumClock;\n  this._maximumClock = maximumClock;\n  this._minimumCone = minimumCone;\n  this._maximumCone = maximumCone;\n  this._stackPartitions = stackPartitions;\n  this._slicePartitions = slicePartitions;\n  this._subdivisions = subdivisions;\n  this._offsetAttribute = options.offsetAttribute;\n  this._workerName = "createEllipsoidOutlineGeometry";\n}\n\n/**\n * The number of elements used to pack the object into an array.\n * @type {Number}\n */\nEllipsoidOutlineGeometry.packedLength = 2 * _Cartesian3_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"].packedLength */ .Z.packedLength + 8;\n\n/**\n * Stores the provided instance into the provided array.\n *\n * @param {EllipsoidOutlineGeometry} value The value to pack.\n * @param {Number[]} array The array to pack into.\n * @param {Number} [startingIndex=0] The index into the array at which to start packing the elements.\n *\n * @returns {Number[]} The array that was packed into\n */\nEllipsoidOutlineGeometry.pack = function (value, array, startingIndex) {\n  //>>includeStart(\'debug\', pragmas.debug);\n  if (!(0,_defined_js__WEBPACK_IMPORTED_MODULE_14__/* ["default"] */ .Z)(value)) {\n    throw new _DeveloperError_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"] */ .Z("value is required");\n  }\n  if (!(0,_defined_js__WEBPACK_IMPORTED_MODULE_14__/* ["default"] */ .Z)(array)) {\n    throw new _DeveloperError_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"] */ .Z("array is required");\n  }\n  //>>includeEnd(\'debug\');\n\n  startingIndex = (0,_defaultValue_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .Z)(startingIndex, 0);\n\n  _Cartesian3_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"].pack */ .Z.pack(value._radii, array, startingIndex);\n  startingIndex += _Cartesian3_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"].packedLength */ .Z.packedLength;\n\n  _Cartesian3_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"].pack */ .Z.pack(value._innerRadii, array, startingIndex);\n  startingIndex += _Cartesian3_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"].packedLength */ .Z.packedLength;\n\n  array[startingIndex++] = value._minimumClock;\n  array[startingIndex++] = value._maximumClock;\n  array[startingIndex++] = value._minimumCone;\n  array[startingIndex++] = value._maximumCone;\n  array[startingIndex++] = value._stackPartitions;\n  array[startingIndex++] = value._slicePartitions;\n  array[startingIndex++] = value._subdivisions;\n  array[startingIndex] = (0,_defaultValue_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .Z)(value._offsetAttribute, -1);\n\n  return array;\n};\n\nvar scratchRadii = new _Cartesian3_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"] */ .Z();\nvar scratchInnerRadii = new _Cartesian3_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"] */ .Z();\nvar scratchOptions = {\n  radii: scratchRadii,\n  innerRadii: scratchInnerRadii,\n  minimumClock: undefined,\n  maximumClock: undefined,\n  minimumCone: undefined,\n  maximumCone: undefined,\n  stackPartitions: undefined,\n  slicePartitions: undefined,\n  subdivisions: undefined,\n  offsetAttribute: undefined,\n};\n\n/**\n * Retrieves an instance from a packed array.\n *\n * @param {Number[]} array The packed array.\n * @param {Number} [startingIndex=0] The starting index of the element to be unpacked.\n * @param {EllipsoidOutlineGeometry} [result] The object into which to store the result.\n * @returns {EllipsoidOutlineGeometry} The modified result parameter or a new EllipsoidOutlineGeometry instance if one was not provided.\n */\nEllipsoidOutlineGeometry.unpack = function (array, startingIndex, result) {\n  //>>includeStart(\'debug\', pragmas.debug);\n  if (!(0,_defined_js__WEBPACK_IMPORTED_MODULE_14__/* ["default"] */ .Z)(array)) {\n    throw new _DeveloperError_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"] */ .Z("array is required");\n  }\n  //>>includeEnd(\'debug\');\n\n  startingIndex = (0,_defaultValue_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .Z)(startingIndex, 0);\n\n  var radii = _Cartesian3_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"].unpack */ .Z.unpack(array, startingIndex, scratchRadii);\n  startingIndex += _Cartesian3_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"].packedLength */ .Z.packedLength;\n\n  var innerRadii = _Cartesian3_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"].unpack */ .Z.unpack(array, startingIndex, scratchInnerRadii);\n  startingIndex += _Cartesian3_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"].packedLength */ .Z.packedLength;\n\n  var minimumClock = array[startingIndex++];\n  var maximumClock = array[startingIndex++];\n  var minimumCone = array[startingIndex++];\n  var maximumCone = array[startingIndex++];\n  var stackPartitions = array[startingIndex++];\n  var slicePartitions = array[startingIndex++];\n  var subdivisions = array[startingIndex++];\n  var offsetAttribute = array[startingIndex];\n\n  if (!(0,_defined_js__WEBPACK_IMPORTED_MODULE_14__/* ["default"] */ .Z)(result)) {\n    scratchOptions.minimumClock = minimumClock;\n    scratchOptions.maximumClock = maximumClock;\n    scratchOptions.minimumCone = minimumCone;\n    scratchOptions.maximumCone = maximumCone;\n    scratchOptions.stackPartitions = stackPartitions;\n    scratchOptions.slicePartitions = slicePartitions;\n    scratchOptions.subdivisions = subdivisions;\n    scratchOptions.offsetAttribute =\n      offsetAttribute === -1 ? undefined : offsetAttribute;\n    return new EllipsoidOutlineGeometry(scratchOptions);\n  }\n\n  result._radii = _Cartesian3_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"].clone */ .Z.clone(radii, result._radii);\n  result._innerRadii = _Cartesian3_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"].clone */ .Z.clone(innerRadii, result._innerRadii);\n  result._minimumClock = minimumClock;\n  result._maximumClock = maximumClock;\n  result._minimumCone = minimumCone;\n  result._maximumCone = maximumCone;\n  result._stackPartitions = stackPartitions;\n  result._slicePartitions = slicePartitions;\n  result._subdivisions = subdivisions;\n  result._offsetAttribute =\n    offsetAttribute === -1 ? undefined : offsetAttribute;\n\n  return result;\n};\n\n/**\n * Computes the geometric representation of an outline of an ellipsoid, including its vertices, indices, and a bounding sphere.\n *\n * @param {EllipsoidOutlineGeometry} ellipsoidGeometry A description of the ellipsoid outline.\n * @returns {Geometry|undefined} The computed vertices and indices.\n */\nEllipsoidOutlineGeometry.createGeometry = function (ellipsoidGeometry) {\n  var radii = ellipsoidGeometry._radii;\n  if (radii.x <= 0 || radii.y <= 0 || radii.z <= 0) {\n    return;\n  }\n\n  var innerRadii = ellipsoidGeometry._innerRadii;\n  if (innerRadii.x <= 0 || innerRadii.y <= 0 || innerRadii.z <= 0) {\n    return;\n  }\n\n  var minimumClock = ellipsoidGeometry._minimumClock;\n  var maximumClock = ellipsoidGeometry._maximumClock;\n  var minimumCone = ellipsoidGeometry._minimumCone;\n  var maximumCone = ellipsoidGeometry._maximumCone;\n  var subdivisions = ellipsoidGeometry._subdivisions;\n  var ellipsoid = _Ellipsoid_js__WEBPACK_IMPORTED_MODULE_6__/* ["default"].fromCartesian3 */ .Z.fromCartesian3(radii);\n\n  // Add an extra slice and stack to remain consistent with EllipsoidGeometry\n  var slicePartitions = ellipsoidGeometry._slicePartitions + 1;\n  var stackPartitions = ellipsoidGeometry._stackPartitions + 1;\n\n  slicePartitions = Math.round(\n    (slicePartitions * Math.abs(maximumClock - minimumClock)) /\n      _Math_js__WEBPACK_IMPORTED_MODULE_12__/* ["default"].TWO_PI */ .Z.TWO_PI\n  );\n  stackPartitions = Math.round(\n    (stackPartitions * Math.abs(maximumCone - minimumCone)) / _Math_js__WEBPACK_IMPORTED_MODULE_12__/* ["default"].PI */ .Z.PI\n  );\n\n  if (slicePartitions < 2) {\n    slicePartitions = 2;\n  }\n  if (stackPartitions < 2) {\n    stackPartitions = 2;\n  }\n\n  var extraIndices = 0;\n  var vertexMultiplier = 1.0;\n  var hasInnerSurface =\n    innerRadii.x !== radii.x ||\n    innerRadii.y !== radii.y ||\n    innerRadii.z !== radii.z;\n  var isTopOpen = false;\n  var isBotOpen = false;\n  if (hasInnerSurface) {\n    vertexMultiplier = 2.0;\n    // Add 2x slicePartitions to connect the top/bottom of the outer to\n    // the top/bottom of the inner\n    if (minimumCone > 0.0) {\n      isTopOpen = true;\n      extraIndices += slicePartitions;\n    }\n    if (maximumCone < Math.PI) {\n      isBotOpen = true;\n      extraIndices += slicePartitions;\n    }\n  }\n\n  var vertexCount =\n    subdivisions * vertexMultiplier * (stackPartitions + slicePartitions);\n  var positions = new Float64Array(vertexCount * 3);\n\n  // Multiply by two because two points define each line segment\n  var numIndices =\n    2 *\n    (vertexCount +\n      extraIndices -\n      (slicePartitions + stackPartitions) * vertexMultiplier);\n  var indices = _IndexDatatype_js__WEBPACK_IMPORTED_MODULE_11__/* ["default"].createTypedArray */ .Z.createTypedArray(vertexCount, numIndices);\n\n  var i;\n  var j;\n  var theta;\n  var phi;\n  var index = 0;\n\n  // Calculate sin/cos phi\n  var sinPhi = new Array(stackPartitions);\n  var cosPhi = new Array(stackPartitions);\n  for (i = 0; i < stackPartitions; i++) {\n    phi =\n      minimumCone + (i * (maximumCone - minimumCone)) / (stackPartitions - 1);\n    sinPhi[i] = sin(phi);\n    cosPhi[i] = cos(phi);\n  }\n\n  // Calculate sin/cos theta\n  var sinTheta = new Array(subdivisions);\n  var cosTheta = new Array(subdivisions);\n  for (i = 0; i < subdivisions; i++) {\n    theta =\n      minimumClock + (i * (maximumClock - minimumClock)) / (subdivisions - 1);\n    sinTheta[i] = sin(theta);\n    cosTheta[i] = cos(theta);\n  }\n\n  // Calculate the latitude lines on the outer surface\n  for (i = 0; i < stackPartitions; i++) {\n    for (j = 0; j < subdivisions; j++) {\n      positions[index++] = radii.x * sinPhi[i] * cosTheta[j];\n      positions[index++] = radii.y * sinPhi[i] * sinTheta[j];\n      positions[index++] = radii.z * cosPhi[i];\n    }\n  }\n\n  // Calculate the latitude lines on the inner surface\n  if (hasInnerSurface) {\n    for (i = 0; i < stackPartitions; i++) {\n      for (j = 0; j < subdivisions; j++) {\n        positions[index++] = innerRadii.x * sinPhi[i] * cosTheta[j];\n        positions[index++] = innerRadii.y * sinPhi[i] * sinTheta[j];\n        positions[index++] = innerRadii.z * cosPhi[i];\n      }\n    }\n  }\n\n  // Calculate sin/cos phi\n  sinPhi.length = subdivisions;\n  cosPhi.length = subdivisions;\n  for (i = 0; i < subdivisions; i++) {\n    phi = minimumCone + (i * (maximumCone - minimumCone)) / (subdivisions - 1);\n    sinPhi[i] = sin(phi);\n    cosPhi[i] = cos(phi);\n  }\n\n  // Calculate sin/cos theta for each slice partition\n  sinTheta.length = slicePartitions;\n  cosTheta.length = slicePartitions;\n  for (i = 0; i < slicePartitions; i++) {\n    theta =\n      minimumClock +\n      (i * (maximumClock - minimumClock)) / (slicePartitions - 1);\n    sinTheta[i] = sin(theta);\n    cosTheta[i] = cos(theta);\n  }\n\n  // Calculate the longitude lines on the outer surface\n  for (i = 0; i < subdivisions; i++) {\n    for (j = 0; j < slicePartitions; j++) {\n      positions[index++] = radii.x * sinPhi[i] * cosTheta[j];\n      positions[index++] = radii.y * sinPhi[i] * sinTheta[j];\n      positions[index++] = radii.z * cosPhi[i];\n    }\n  }\n\n  // Calculate the longitude lines on the inner surface\n  if (hasInnerSurface) {\n    for (i = 0; i < subdivisions; i++) {\n      for (j = 0; j < slicePartitions; j++) {\n        positions[index++] = innerRadii.x * sinPhi[i] * cosTheta[j];\n        positions[index++] = innerRadii.y * sinPhi[i] * sinTheta[j];\n        positions[index++] = innerRadii.z * cosPhi[i];\n      }\n    }\n  }\n\n  // Create indices for the latitude lines\n  index = 0;\n  for (i = 0; i < stackPartitions * vertexMultiplier; i++) {\n    var topOffset = i * subdivisions;\n    for (j = 0; j < subdivisions - 1; j++) {\n      indices[index++] = topOffset + j;\n      indices[index++] = topOffset + j + 1;\n    }\n  }\n\n  // Create indices for the outer longitude lines\n  var offset = stackPartitions * subdivisions * vertexMultiplier;\n  for (i = 0; i < slicePartitions; i++) {\n    for (j = 0; j < subdivisions - 1; j++) {\n      indices[index++] = offset + i + j * slicePartitions;\n      indices[index++] = offset + i + (j + 1) * slicePartitions;\n    }\n  }\n\n  // Create indices for the inner longitude lines\n  if (hasInnerSurface) {\n    offset =\n      stackPartitions * subdivisions * vertexMultiplier +\n      slicePartitions * subdivisions;\n    for (i = 0; i < slicePartitions; i++) {\n      for (j = 0; j < subdivisions - 1; j++) {\n        indices[index++] = offset + i + j * slicePartitions;\n        indices[index++] = offset + i + (j + 1) * slicePartitions;\n      }\n    }\n  }\n\n  if (hasInnerSurface) {\n    var outerOffset = stackPartitions * subdivisions * vertexMultiplier;\n    var innerOffset = outerOffset + subdivisions * slicePartitions;\n    if (isTopOpen) {\n      // Draw lines from the top of the inner surface to the top of the outer surface\n      for (i = 0; i < slicePartitions; i++) {\n        indices[index++] = outerOffset + i;\n        indices[index++] = innerOffset + i;\n      }\n    }\n\n    if (isBotOpen) {\n      // Draw lines from the top of the inner surface to the top of the outer surface\n      outerOffset += subdivisions * slicePartitions - slicePartitions;\n      innerOffset += subdivisions * slicePartitions - slicePartitions;\n      for (i = 0; i < slicePartitions; i++) {\n        indices[index++] = outerOffset + i;\n        indices[index++] = innerOffset + i;\n      }\n    }\n  }\n\n  var attributes = new _GeometryAttributes_js__WEBPACK_IMPORTED_MODULE_9__/* ["default"] */ .Z({\n    position: new _GeometryAttribute_js__WEBPACK_IMPORTED_MODULE_8__/* ["default"] */ .Z({\n      componentDatatype: _ComponentDatatype_js__WEBPACK_IMPORTED_MODULE_3__/* ["default"].DOUBLE */ .Z.DOUBLE,\n      componentsPerAttribute: 3,\n      values: positions,\n    }),\n  });\n\n  if ((0,_defined_js__WEBPACK_IMPORTED_MODULE_14__/* ["default"] */ .Z)(ellipsoidGeometry._offsetAttribute)) {\n    var length = positions.length;\n    var applyOffset = new Uint8Array(length / 3);\n    var offsetValue =\n      ellipsoidGeometry._offsetAttribute === _GeometryOffsetAttribute_js__WEBPACK_IMPORTED_MODULE_10__/* ["default"].NONE */ .Z.NONE\n        ? 0\n        : 1;\n    (0,_arrayFill_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .Z)(applyOffset, offsetValue);\n    attributes.applyOffset = new _GeometryAttribute_js__WEBPACK_IMPORTED_MODULE_8__/* ["default"] */ .Z({\n      componentDatatype: _ComponentDatatype_js__WEBPACK_IMPORTED_MODULE_3__/* ["default"].UNSIGNED_BYTE */ .Z.UNSIGNED_BYTE,\n      componentsPerAttribute: 1,\n      values: applyOffset,\n    });\n  }\n\n  return new _Geometry_js__WEBPACK_IMPORTED_MODULE_7__/* ["default"] */ .Z({\n    attributes: attributes,\n    indices: indices,\n    primitiveType: _PrimitiveType_js__WEBPACK_IMPORTED_MODULE_13__/* ["default"].LINES */ .Z.LINES,\n    boundingSphere: _BoundingSphere_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"].fromEllipsoid */ .Z.fromEllipsoid(ellipsoid),\n    offsetAttribute: ellipsoidGeometry._offsetAttribute,\n  });\n};\n/* harmony default export */ __webpack_exports__["Z"] = (EllipsoidOutlineGeometry);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QUFlLHdCQUF3QixFQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdnVlMy13ZWJwYWNrNS8uL25vZGVfbW9kdWxlcy9jZXNpdW0vU291cmNlL0NvcmUvRWxsaXBzb2lkT3V0bGluZUdlb21ldHJ5LmpzP2JkZTEiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IGFycmF5RmlsbCBmcm9tIFwiLi9hcnJheUZpbGwuanNcIjtcbmltcG9ydCBCb3VuZGluZ1NwaGVyZSBmcm9tIFwiLi9Cb3VuZGluZ1NwaGVyZS5qc1wiO1xuaW1wb3J0IENhcnRlc2lhbjMgZnJvbSBcIi4vQ2FydGVzaWFuMy5qc1wiO1xuaW1wb3J0IENvbXBvbmVudERhdGF0eXBlIGZyb20gXCIuL0NvbXBvbmVudERhdGF0eXBlLmpzXCI7XG5pbXBvcnQgZGVmYXVsdFZhbHVlIGZyb20gXCIuL2RlZmF1bHRWYWx1ZS5qc1wiO1xuaW1wb3J0IGRlZmluZWQgZnJvbSBcIi4vZGVmaW5lZC5qc1wiO1xuaW1wb3J0IERldmVsb3BlckVycm9yIGZyb20gXCIuL0RldmVsb3BlckVycm9yLmpzXCI7XG5pbXBvcnQgRWxsaXBzb2lkIGZyb20gXCIuL0VsbGlwc29pZC5qc1wiO1xuaW1wb3J0IEdlb21ldHJ5IGZyb20gXCIuL0dlb21ldHJ5LmpzXCI7XG5pbXBvcnQgR2VvbWV0cnlBdHRyaWJ1dGUgZnJvbSBcIi4vR2VvbWV0cnlBdHRyaWJ1dGUuanNcIjtcbmltcG9ydCBHZW9tZXRyeUF0dHJpYnV0ZXMgZnJvbSBcIi4vR2VvbWV0cnlBdHRyaWJ1dGVzLmpzXCI7XG5pbXBvcnQgR2VvbWV0cnlPZmZzZXRBdHRyaWJ1dGUgZnJvbSBcIi4vR2VvbWV0cnlPZmZzZXRBdHRyaWJ1dGUuanNcIjtcbmltcG9ydCBJbmRleERhdGF0eXBlIGZyb20gXCIuL0luZGV4RGF0YXR5cGUuanNcIjtcbmltcG9ydCBDZXNpdW1NYXRoIGZyb20gXCIuL01hdGguanNcIjtcbmltcG9ydCBQcmltaXRpdmVUeXBlIGZyb20gXCIuL1ByaW1pdGl2ZVR5cGUuanNcIjtcblxudmFyIGRlZmF1bHRSYWRpaSA9IG5ldyBDYXJ0ZXNpYW4zKDEuMCwgMS4wLCAxLjApO1xudmFyIGNvcyA9IE1hdGguY29zO1xudmFyIHNpbiA9IE1hdGguc2luO1xuXG4vKipcbiAqIEEgZGVzY3JpcHRpb24gb2YgdGhlIG91dGxpbmUgb2YgYW4gZWxsaXBzb2lkIGNlbnRlcmVkIGF0IHRoZSBvcmlnaW4uXG4gKlxuICogQGFsaWFzIEVsbGlwc29pZE91dGxpbmVHZW9tZXRyeVxuICogQGNvbnN0cnVjdG9yXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSBPYmplY3Qgd2l0aCB0aGUgZm9sbG93aW5nIHByb3BlcnRpZXM6XG4gKiBAcGFyYW0ge0NhcnRlc2lhbjN9IFtvcHRpb25zLnJhZGlpPUNhcnRlc2lhbjMoMS4wLCAxLjAsIDEuMCldIFRoZSByYWRpaSBvZiB0aGUgZWxsaXBzb2lkIGluIHRoZSB4LCB5LCBhbmQgeiBkaXJlY3Rpb25zLlxuICogQHBhcmFtIHtDYXJ0ZXNpYW4zfSBbb3B0aW9ucy5pbm5lclJhZGlpPW9wdGlvbnMucmFkaWldIFRoZSBpbm5lciByYWRpaSBvZiB0aGUgZWxsaXBzb2lkIGluIHRoZSB4LCB5LCBhbmQgeiBkaXJlY3Rpb25zLlxuICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLm1pbmltdW1DbG9jaz0wLjBdIFRoZSBtaW5pbXVtIGFuZ2xlIGx5aW5nIGluIHRoZSB4eS1wbGFuZSBtZWFzdXJlZCBmcm9tIHRoZSBwb3NpdGl2ZSB4LWF4aXMgYW5kIHRvd2FyZCB0aGUgcG9zaXRpdmUgeS1heGlzLlxuICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLm1heGltdW1DbG9jaz0yKlBJXSBUaGUgbWF4aW11bSBhbmdsZSBseWluZyBpbiB0aGUgeHktcGxhbmUgbWVhc3VyZWQgZnJvbSB0aGUgcG9zaXRpdmUgeC1heGlzIGFuZCB0b3dhcmQgdGhlIHBvc2l0aXZlIHktYXhpcy5cbiAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5taW5pbXVtQ29uZT0wLjBdIFRoZSBtaW5pbXVtIGFuZ2xlIG1lYXN1cmVkIGZyb20gdGhlIHBvc2l0aXZlIHotYXhpcyBhbmQgdG93YXJkIHRoZSBuZWdhdGl2ZSB6LWF4aXMuXG4gKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMubWF4aW11bUNvbmU9UEldIFRoZSBtYXhpbXVtIGFuZ2xlIG1lYXN1cmVkIGZyb20gdGhlIHBvc2l0aXZlIHotYXhpcyBhbmQgdG93YXJkIHRoZSBuZWdhdGl2ZSB6LWF4aXMuXG4gKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMuc3RhY2tQYXJ0aXRpb25zPTEwXSBUaGUgY291bnQgb2Ygc3RhY2tzIGZvciB0aGUgZWxsaXBzb2lkICgxIGdyZWF0ZXIgdGhhbiB0aGUgbnVtYmVyIG9mIHBhcmFsbGVsIGxpbmVzKS5cbiAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5zbGljZVBhcnRpdGlvbnM9OF0gVGhlIGNvdW50IG9mIHNsaWNlcyBmb3IgdGhlIGVsbGlwc29pZCAoRXF1YWwgdG8gdGhlIG51bWJlciBvZiByYWRpYWwgbGluZXMpLlxuICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLnN1YmRpdmlzaW9ucz0xMjhdIFRoZSBudW1iZXIgb2YgcG9pbnRzIHBlciBsaW5lLCBkZXRlcm1pbmluZyB0aGUgZ3JhbnVsYXJpdHkgb2YgdGhlIGN1cnZhdHVyZS5cbiAqXG4gKiBAZXhjZXB0aW9uIHtEZXZlbG9wZXJFcnJvcn0gb3B0aW9ucy5zdGFja1BhcnRpdGlvbnMgbXVzdCBiZSBncmVhdGVyIHRoYW4gb3IgZXF1YWwgdG8gb25lLlxuICogQGV4Y2VwdGlvbiB7RGV2ZWxvcGVyRXJyb3J9IG9wdGlvbnMuc2xpY2VQYXJ0aXRpb25zIG11c3QgYmUgZ3JlYXRlciB0aGFuIG9yIGVxdWFsIHRvIHplcm8uXG4gKiBAZXhjZXB0aW9uIHtEZXZlbG9wZXJFcnJvcn0gb3B0aW9ucy5zdWJkaXZpc2lvbnMgbXVzdCBiZSBncmVhdGVyIHRoYW4gb3IgZXF1YWwgdG8gemVyby5cbiAqXG4gKiBAZXhhbXBsZVxuICogdmFyIGVsbGlwc29pZCA9IG5ldyBDZXNpdW0uRWxsaXBzb2lkT3V0bGluZUdlb21ldHJ5KHtcbiAqICAgcmFkaWkgOiBuZXcgQ2VzaXVtLkNhcnRlc2lhbjMoMTAwMDAwMC4wLCA1MDAwMDAuMCwgNTAwMDAwLjApLFxuICogICBzdGFja1BhcnRpdGlvbnM6IDYsXG4gKiAgIHNsaWNlUGFydGl0aW9uczogNVxuICogfSk7XG4gKiB2YXIgZ2VvbWV0cnkgPSBDZXNpdW0uRWxsaXBzb2lkT3V0bGluZUdlb21ldHJ5LmNyZWF0ZUdlb21ldHJ5KGVsbGlwc29pZCk7XG4gKi9cbmZ1bmN0aW9uIEVsbGlwc29pZE91dGxpbmVHZW9tZXRyeShvcHRpb25zKSB7XG4gIG9wdGlvbnMgPSBkZWZhdWx0VmFsdWUob3B0aW9ucywgZGVmYXVsdFZhbHVlLkVNUFRZX09CSkVDVCk7XG5cbiAgdmFyIHJhZGlpID0gZGVmYXVsdFZhbHVlKG9wdGlvbnMucmFkaWksIGRlZmF1bHRSYWRpaSk7XG4gIHZhciBpbm5lclJhZGlpID0gZGVmYXVsdFZhbHVlKG9wdGlvbnMuaW5uZXJSYWRpaSwgcmFkaWkpO1xuICB2YXIgbWluaW11bUNsb2NrID0gZGVmYXVsdFZhbHVlKG9wdGlvbnMubWluaW11bUNsb2NrLCAwLjApO1xuICB2YXIgbWF4aW11bUNsb2NrID0gZGVmYXVsdFZhbHVlKG9wdGlvbnMubWF4aW11bUNsb2NrLCBDZXNpdW1NYXRoLlRXT19QSSk7XG4gIHZhciBtaW5pbXVtQ29uZSA9IGRlZmF1bHRWYWx1ZShvcHRpb25zLm1pbmltdW1Db25lLCAwLjApO1xuICB2YXIgbWF4aW11bUNvbmUgPSBkZWZhdWx0VmFsdWUob3B0aW9ucy5tYXhpbXVtQ29uZSwgQ2VzaXVtTWF0aC5QSSk7XG4gIHZhciBzdGFja1BhcnRpdGlvbnMgPSBNYXRoLnJvdW5kKGRlZmF1bHRWYWx1ZShvcHRpb25zLnN0YWNrUGFydGl0aW9ucywgMTApKTtcbiAgdmFyIHNsaWNlUGFydGl0aW9ucyA9IE1hdGgucm91bmQoZGVmYXVsdFZhbHVlKG9wdGlvbnMuc2xpY2VQYXJ0aXRpb25zLCA4KSk7XG4gIHZhciBzdWJkaXZpc2lvbnMgPSBNYXRoLnJvdW5kKGRlZmF1bHRWYWx1ZShvcHRpb25zLnN1YmRpdmlzaW9ucywgMTI4KSk7XG5cbiAgLy8+PmluY2x1ZGVTdGFydCgnZGVidWcnLCBwcmFnbWFzLmRlYnVnKTtcbiAgaWYgKHN0YWNrUGFydGl0aW9ucyA8IDEpIHtcbiAgICB0aHJvdyBuZXcgRGV2ZWxvcGVyRXJyb3IoXCJvcHRpb25zLnN0YWNrUGFydGl0aW9ucyBjYW5ub3QgYmUgbGVzcyB0aGFuIDFcIik7XG4gIH1cbiAgaWYgKHNsaWNlUGFydGl0aW9ucyA8IDApIHtcbiAgICB0aHJvdyBuZXcgRGV2ZWxvcGVyRXJyb3IoXCJvcHRpb25zLnNsaWNlUGFydGl0aW9ucyBjYW5ub3QgYmUgbGVzcyB0aGFuIDBcIik7XG4gIH1cbiAgaWYgKHN1YmRpdmlzaW9ucyA8IDApIHtcbiAgICB0aHJvdyBuZXcgRGV2ZWxvcGVyRXJyb3IoXG4gICAgICBcIm9wdGlvbnMuc3ViZGl2aXNpb25zIG11c3QgYmUgZ3JlYXRlciB0aGFuIG9yIGVxdWFsIHRvIHplcm8uXCJcbiAgICApO1xuICB9XG4gIGlmIChcbiAgICBkZWZpbmVkKG9wdGlvbnMub2Zmc2V0QXR0cmlidXRlKSAmJlxuICAgIG9wdGlvbnMub2Zmc2V0QXR0cmlidXRlID09PSBHZW9tZXRyeU9mZnNldEF0dHJpYnV0ZS5UT1BcbiAgKSB7XG4gICAgdGhyb3cgbmV3IERldmVsb3BlckVycm9yKFxuICAgICAgXCJHZW9tZXRyeU9mZnNldEF0dHJpYnV0ZS5UT1AgaXMgbm90IGEgc3VwcG9ydGVkIG9wdGlvbnMub2Zmc2V0QXR0cmlidXRlIGZvciB0aGlzIGdlb21ldHJ5LlwiXG4gICAgKTtcbiAgfVxuICAvLz4+aW5jbHVkZUVuZCgnZGVidWcnKTtcblxuICB0aGlzLl9yYWRpaSA9IENhcnRlc2lhbjMuY2xvbmUocmFkaWkpO1xuICB0aGlzLl9pbm5lclJhZGlpID0gQ2FydGVzaWFuMy5jbG9uZShpbm5lclJhZGlpKTtcbiAgdGhpcy5fbWluaW11bUNsb2NrID0gbWluaW11bUNsb2NrO1xuICB0aGlzLl9tYXhpbXVtQ2xvY2sgPSBtYXhpbXVtQ2xvY2s7XG4gIHRoaXMuX21pbmltdW1Db25lID0gbWluaW11bUNvbmU7XG4gIHRoaXMuX21heGltdW1Db25lID0gbWF4aW11bUNvbmU7XG4gIHRoaXMuX3N0YWNrUGFydGl0aW9ucyA9IHN0YWNrUGFydGl0aW9ucztcbiAgdGhpcy5fc2xpY2VQYXJ0aXRpb25zID0gc2xpY2VQYXJ0aXRpb25zO1xuICB0aGlzLl9zdWJkaXZpc2lvbnMgPSBzdWJkaXZpc2lvbnM7XG4gIHRoaXMuX29mZnNldEF0dHJpYnV0ZSA9IG9wdGlvbnMub2Zmc2V0QXR0cmlidXRlO1xuICB0aGlzLl93b3JrZXJOYW1lID0gXCJjcmVhdGVFbGxpcHNvaWRPdXRsaW5lR2VvbWV0cnlcIjtcbn1cblxuLyoqXG4gKiBUaGUgbnVtYmVyIG9mIGVsZW1lbnRzIHVzZWQgdG8gcGFjayB0aGUgb2JqZWN0IGludG8gYW4gYXJyYXkuXG4gKiBAdHlwZSB7TnVtYmVyfVxuICovXG5FbGxpcHNvaWRPdXRsaW5lR2VvbWV0cnkucGFja2VkTGVuZ3RoID0gMiAqIENhcnRlc2lhbjMucGFja2VkTGVuZ3RoICsgODtcblxuLyoqXG4gKiBTdG9yZXMgdGhlIHByb3ZpZGVkIGluc3RhbmNlIGludG8gdGhlIHByb3ZpZGVkIGFycmF5LlxuICpcbiAqIEBwYXJhbSB7RWxsaXBzb2lkT3V0bGluZUdlb21ldHJ5fSB2YWx1ZSBUaGUgdmFsdWUgdG8gcGFjay5cbiAqIEBwYXJhbSB7TnVtYmVyW119IGFycmF5IFRoZSBhcnJheSB0byBwYWNrIGludG8uXG4gKiBAcGFyYW0ge051bWJlcn0gW3N0YXJ0aW5nSW5kZXg9MF0gVGhlIGluZGV4IGludG8gdGhlIGFycmF5IGF0IHdoaWNoIHRvIHN0YXJ0IHBhY2tpbmcgdGhlIGVsZW1lbnRzLlxuICpcbiAqIEByZXR1cm5zIHtOdW1iZXJbXX0gVGhlIGFycmF5IHRoYXQgd2FzIHBhY2tlZCBpbnRvXG4gKi9cbkVsbGlwc29pZE91dGxpbmVHZW9tZXRyeS5wYWNrID0gZnVuY3Rpb24gKHZhbHVlLCBhcnJheSwgc3RhcnRpbmdJbmRleCkge1xuICAvLz4+aW5jbHVkZVN0YXJ0KCdkZWJ1ZycsIHByYWdtYXMuZGVidWcpO1xuICBpZiAoIWRlZmluZWQodmFsdWUpKSB7XG4gICAgdGhyb3cgbmV3IERldmVsb3BlckVycm9yKFwidmFsdWUgaXMgcmVxdWlyZWRcIik7XG4gIH1cbiAgaWYgKCFkZWZpbmVkKGFycmF5KSkge1xuICAgIHRocm93IG5ldyBEZXZlbG9wZXJFcnJvcihcImFycmF5IGlzIHJlcXVpcmVkXCIpO1xuICB9XG4gIC8vPj5pbmNsdWRlRW5kKCdkZWJ1ZycpO1xuXG4gIHN0YXJ0aW5nSW5kZXggPSBkZWZhdWx0VmFsdWUoc3RhcnRpbmdJbmRleCwgMCk7XG5cbiAgQ2FydGVzaWFuMy5wYWNrKHZhbHVlLl9yYWRpaSwgYXJyYXksIHN0YXJ0aW5nSW5kZXgpO1xuICBzdGFydGluZ0luZGV4ICs9IENhcnRlc2lhbjMucGFja2VkTGVuZ3RoO1xuXG4gIENhcnRlc2lhbjMucGFjayh2YWx1ZS5faW5uZXJSYWRpaSwgYXJyYXksIHN0YXJ0aW5nSW5kZXgpO1xuICBzdGFydGluZ0luZGV4ICs9IENhcnRlc2lhbjMucGFja2VkTGVuZ3RoO1xuXG4gIGFycmF5W3N0YXJ0aW5nSW5kZXgrK10gPSB2YWx1ZS5fbWluaW11bUNsb2NrO1xuICBhcnJheVtzdGFydGluZ0luZGV4KytdID0gdmFsdWUuX21heGltdW1DbG9jaztcbiAgYXJyYXlbc3RhcnRpbmdJbmRleCsrXSA9IHZhbHVlLl9taW5pbXVtQ29uZTtcbiAgYXJyYXlbc3RhcnRpbmdJbmRleCsrXSA9IHZhbHVlLl9tYXhpbXVtQ29uZTtcbiAgYXJyYXlbc3RhcnRpbmdJbmRleCsrXSA9IHZhbHVlLl9zdGFja1BhcnRpdGlvbnM7XG4gIGFycmF5W3N0YXJ0aW5nSW5kZXgrK10gPSB2YWx1ZS5fc2xpY2VQYXJ0aXRpb25zO1xuICBhcnJheVtzdGFydGluZ0luZGV4KytdID0gdmFsdWUuX3N1YmRpdmlzaW9ucztcbiAgYXJyYXlbc3RhcnRpbmdJbmRleF0gPSBkZWZhdWx0VmFsdWUodmFsdWUuX29mZnNldEF0dHJpYnV0ZSwgLTEpO1xuXG4gIHJldHVybiBhcnJheTtcbn07XG5cbnZhciBzY3JhdGNoUmFkaWkgPSBuZXcgQ2FydGVzaWFuMygpO1xudmFyIHNjcmF0Y2hJbm5lclJhZGlpID0gbmV3IENhcnRlc2lhbjMoKTtcbnZhciBzY3JhdGNoT3B0aW9ucyA9IHtcbiAgcmFkaWk6IHNjcmF0Y2hSYWRpaSxcbiAgaW5uZXJSYWRpaTogc2NyYXRjaElubmVyUmFkaWksXG4gIG1pbmltdW1DbG9jazogdW5kZWZpbmVkLFxuICBtYXhpbXVtQ2xvY2s6IHVuZGVmaW5lZCxcbiAgbWluaW11bUNvbmU6IHVuZGVmaW5lZCxcbiAgbWF4aW11bUNvbmU6IHVuZGVmaW5lZCxcbiAgc3RhY2tQYXJ0aXRpb25zOiB1bmRlZmluZWQsXG4gIHNsaWNlUGFydGl0aW9uczogdW5kZWZpbmVkLFxuICBzdWJkaXZpc2lvbnM6IHVuZGVmaW5lZCxcbiAgb2Zmc2V0QXR0cmlidXRlOiB1bmRlZmluZWQsXG59O1xuXG4vKipcbiAqIFJldHJpZXZlcyBhbiBpbnN0YW5jZSBmcm9tIGEgcGFja2VkIGFycmF5LlxuICpcbiAqIEBwYXJhbSB7TnVtYmVyW119IGFycmF5IFRoZSBwYWNrZWQgYXJyYXkuXG4gKiBAcGFyYW0ge051bWJlcn0gW3N0YXJ0aW5nSW5kZXg9MF0gVGhlIHN0YXJ0aW5nIGluZGV4IG9mIHRoZSBlbGVtZW50IHRvIGJlIHVucGFja2VkLlxuICogQHBhcmFtIHtFbGxpcHNvaWRPdXRsaW5lR2VvbWV0cnl9IFtyZXN1bHRdIFRoZSBvYmplY3QgaW50byB3aGljaCB0byBzdG9yZSB0aGUgcmVzdWx0LlxuICogQHJldHVybnMge0VsbGlwc29pZE91dGxpbmVHZW9tZXRyeX0gVGhlIG1vZGlmaWVkIHJlc3VsdCBwYXJhbWV0ZXIgb3IgYSBuZXcgRWxsaXBzb2lkT3V0bGluZUdlb21ldHJ5IGluc3RhbmNlIGlmIG9uZSB3YXMgbm90IHByb3ZpZGVkLlxuICovXG5FbGxpcHNvaWRPdXRsaW5lR2VvbWV0cnkudW5wYWNrID0gZnVuY3Rpb24gKGFycmF5LCBzdGFydGluZ0luZGV4LCByZXN1bHQpIHtcbiAgLy8+PmluY2x1ZGVTdGFydCgnZGVidWcnLCBwcmFnbWFzLmRlYnVnKTtcbiAgaWYgKCFkZWZpbmVkKGFycmF5KSkge1xuICAgIHRocm93IG5ldyBEZXZlbG9wZXJFcnJvcihcImFycmF5IGlzIHJlcXVpcmVkXCIpO1xuICB9XG4gIC8vPj5pbmNsdWRlRW5kKCdkZWJ1ZycpO1xuXG4gIHN0YXJ0aW5nSW5kZXggPSBkZWZhdWx0VmFsdWUoc3RhcnRpbmdJbmRleCwgMCk7XG5cbiAgdmFyIHJhZGlpID0gQ2FydGVzaWFuMy51bnBhY2soYXJyYXksIHN0YXJ0aW5nSW5kZXgsIHNjcmF0Y2hSYWRpaSk7XG4gIHN0YXJ0aW5nSW5kZXggKz0gQ2FydGVzaWFuMy5wYWNrZWRMZW5ndGg7XG5cbiAgdmFyIGlubmVyUmFkaWkgPSBDYXJ0ZXNpYW4zLnVucGFjayhhcnJheSwgc3RhcnRpbmdJbmRleCwgc2NyYXRjaElubmVyUmFkaWkpO1xuICBzdGFydGluZ0luZGV4ICs9IENhcnRlc2lhbjMucGFja2VkTGVuZ3RoO1xuXG4gIHZhciBtaW5pbXVtQ2xvY2sgPSBhcnJheVtzdGFydGluZ0luZGV4KytdO1xuICB2YXIgbWF4aW11bUNsb2NrID0gYXJyYXlbc3RhcnRpbmdJbmRleCsrXTtcbiAgdmFyIG1pbmltdW1Db25lID0gYXJyYXlbc3RhcnRpbmdJbmRleCsrXTtcbiAgdmFyIG1heGltdW1Db25lID0gYXJyYXlbc3RhcnRpbmdJbmRleCsrXTtcbiAgdmFyIHN0YWNrUGFydGl0aW9ucyA9IGFycmF5W3N0YXJ0aW5nSW5kZXgrK107XG4gIHZhciBzbGljZVBhcnRpdGlvbnMgPSBhcnJheVtzdGFydGluZ0luZGV4KytdO1xuICB2YXIgc3ViZGl2aXNpb25zID0gYXJyYXlbc3RhcnRpbmdJbmRleCsrXTtcbiAgdmFyIG9mZnNldEF0dHJpYnV0ZSA9IGFycmF5W3N0YXJ0aW5nSW5kZXhdO1xuXG4gIGlmICghZGVmaW5lZChyZXN1bHQpKSB7XG4gICAgc2NyYXRjaE9wdGlvbnMubWluaW11bUNsb2NrID0gbWluaW11bUNsb2NrO1xuICAgIHNjcmF0Y2hPcHRpb25zLm1heGltdW1DbG9jayA9IG1heGltdW1DbG9jaztcbiAgICBzY3JhdGNoT3B0aW9ucy5taW5pbXVtQ29uZSA9IG1pbmltdW1Db25lO1xuICAgIHNjcmF0Y2hPcHRpb25zLm1heGltdW1Db25lID0gbWF4aW11bUNvbmU7XG4gICAgc2NyYXRjaE9wdGlvbnMuc3RhY2tQYXJ0aXRpb25zID0gc3RhY2tQYXJ0aXRpb25zO1xuICAgIHNjcmF0Y2hPcHRpb25zLnNsaWNlUGFydGl0aW9ucyA9IHNsaWNlUGFydGl0aW9ucztcbiAgICBzY3JhdGNoT3B0aW9ucy5zdWJkaXZpc2lvbnMgPSBzdWJkaXZpc2lvbnM7XG4gICAgc2NyYXRjaE9wdGlvbnMub2Zmc2V0QXR0cmlidXRlID1cbiAgICAgIG9mZnNldEF0dHJpYnV0ZSA9PT0gLTEgPyB1bmRlZmluZWQgOiBvZmZzZXRBdHRyaWJ1dGU7XG4gICAgcmV0dXJuIG5ldyBFbGxpcHNvaWRPdXRsaW5lR2VvbWV0cnkoc2NyYXRjaE9wdGlvbnMpO1xuICB9XG5cbiAgcmVzdWx0Ll9yYWRpaSA9IENhcnRlc2lhbjMuY2xvbmUocmFkaWksIHJlc3VsdC5fcmFkaWkpO1xuICByZXN1bHQuX2lubmVyUmFkaWkgPSBDYXJ0ZXNpYW4zLmNsb25lKGlubmVyUmFkaWksIHJlc3VsdC5faW5uZXJSYWRpaSk7XG4gIHJlc3VsdC5fbWluaW11bUNsb2NrID0gbWluaW11bUNsb2NrO1xuICByZXN1bHQuX21heGltdW1DbG9jayA9IG1heGltdW1DbG9jaztcbiAgcmVzdWx0Ll9taW5pbXVtQ29uZSA9IG1pbmltdW1Db25lO1xuICByZXN1bHQuX21heGltdW1Db25lID0gbWF4aW11bUNvbmU7XG4gIHJlc3VsdC5fc3RhY2tQYXJ0aXRpb25zID0gc3RhY2tQYXJ0aXRpb25zO1xuICByZXN1bHQuX3NsaWNlUGFydGl0aW9ucyA9IHNsaWNlUGFydGl0aW9ucztcbiAgcmVzdWx0Ll9zdWJkaXZpc2lvbnMgPSBzdWJkaXZpc2lvbnM7XG4gIHJlc3VsdC5fb2Zmc2V0QXR0cmlidXRlID1cbiAgICBvZmZzZXRBdHRyaWJ1dGUgPT09IC0xID8gdW5kZWZpbmVkIDogb2Zmc2V0QXR0cmlidXRlO1xuXG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG4vKipcbiAqIENvbXB1dGVzIHRoZSBnZW9tZXRyaWMgcmVwcmVzZW50YXRpb24gb2YgYW4gb3V0bGluZSBvZiBhbiBlbGxpcHNvaWQsIGluY2x1ZGluZyBpdHMgdmVydGljZXMsIGluZGljZXMsIGFuZCBhIGJvdW5kaW5nIHNwaGVyZS5cbiAqXG4gKiBAcGFyYW0ge0VsbGlwc29pZE91dGxpbmVHZW9tZXRyeX0gZWxsaXBzb2lkR2VvbWV0cnkgQSBkZXNjcmlwdGlvbiBvZiB0aGUgZWxsaXBzb2lkIG91dGxpbmUuXG4gKiBAcmV0dXJucyB7R2VvbWV0cnl8dW5kZWZpbmVkfSBUaGUgY29tcHV0ZWQgdmVydGljZXMgYW5kIGluZGljZXMuXG4gKi9cbkVsbGlwc29pZE91dGxpbmVHZW9tZXRyeS5jcmVhdGVHZW9tZXRyeSA9IGZ1bmN0aW9uIChlbGxpcHNvaWRHZW9tZXRyeSkge1xuICB2YXIgcmFkaWkgPSBlbGxpcHNvaWRHZW9tZXRyeS5fcmFkaWk7XG4gIGlmIChyYWRpaS54IDw9IDAgfHwgcmFkaWkueSA8PSAwIHx8IHJhZGlpLnogPD0gMCkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciBpbm5lclJhZGlpID0gZWxsaXBzb2lkR2VvbWV0cnkuX2lubmVyUmFkaWk7XG4gIGlmIChpbm5lclJhZGlpLnggPD0gMCB8fCBpbm5lclJhZGlpLnkgPD0gMCB8fCBpbm5lclJhZGlpLnogPD0gMCkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciBtaW5pbXVtQ2xvY2sgPSBlbGxpcHNvaWRHZW9tZXRyeS5fbWluaW11bUNsb2NrO1xuICB2YXIgbWF4aW11bUNsb2NrID0gZWxsaXBzb2lkR2VvbWV0cnkuX21heGltdW1DbG9jaztcbiAgdmFyIG1pbmltdW1Db25lID0gZWxsaXBzb2lkR2VvbWV0cnkuX21pbmltdW1Db25lO1xuICB2YXIgbWF4aW11bUNvbmUgPSBlbGxpcHNvaWRHZW9tZXRyeS5fbWF4aW11bUNvbmU7XG4gIHZhciBzdWJkaXZpc2lvbnMgPSBlbGxpcHNvaWRHZW9tZXRyeS5fc3ViZGl2aXNpb25zO1xuICB2YXIgZWxsaXBzb2lkID0gRWxsaXBzb2lkLmZyb21DYXJ0ZXNpYW4zKHJhZGlpKTtcblxuICAvLyBBZGQgYW4gZXh0cmEgc2xpY2UgYW5kIHN0YWNrIHRvIHJlbWFpbiBjb25zaXN0ZW50IHdpdGggRWxsaXBzb2lkR2VvbWV0cnlcbiAgdmFyIHNsaWNlUGFydGl0aW9ucyA9IGVsbGlwc29pZEdlb21ldHJ5Ll9zbGljZVBhcnRpdGlvbnMgKyAxO1xuICB2YXIgc3RhY2tQYXJ0aXRpb25zID0gZWxsaXBzb2lkR2VvbWV0cnkuX3N0YWNrUGFydGl0aW9ucyArIDE7XG5cbiAgc2xpY2VQYXJ0aXRpb25zID0gTWF0aC5yb3VuZChcbiAgICAoc2xpY2VQYXJ0aXRpb25zICogTWF0aC5hYnMobWF4aW11bUNsb2NrIC0gbWluaW11bUNsb2NrKSkgL1xuICAgICAgQ2VzaXVtTWF0aC5UV09fUElcbiAgKTtcbiAgc3RhY2tQYXJ0aXRpb25zID0gTWF0aC5yb3VuZChcbiAgICAoc3RhY2tQYXJ0aXRpb25zICogTWF0aC5hYnMobWF4aW11bUNvbmUgLSBtaW5pbXVtQ29uZSkpIC8gQ2VzaXVtTWF0aC5QSVxuICApO1xuXG4gIGlmIChzbGljZVBhcnRpdGlvbnMgPCAyKSB7XG4gICAgc2xpY2VQYXJ0aXRpb25zID0gMjtcbiAgfVxuICBpZiAoc3RhY2tQYXJ0aXRpb25zIDwgMikge1xuICAgIHN0YWNrUGFydGl0aW9ucyA9IDI7XG4gIH1cblxuICB2YXIgZXh0cmFJbmRpY2VzID0gMDtcbiAgdmFyIHZlcnRleE11bHRpcGxpZXIgPSAxLjA7XG4gIHZhciBoYXNJbm5lclN1cmZhY2UgPVxuICAgIGlubmVyUmFkaWkueCAhPT0gcmFkaWkueCB8fFxuICAgIGlubmVyUmFkaWkueSAhPT0gcmFkaWkueSB8fFxuICAgIGlubmVyUmFkaWkueiAhPT0gcmFkaWkuejtcbiAgdmFyIGlzVG9wT3BlbiA9IGZhbHNlO1xuICB2YXIgaXNCb3RPcGVuID0gZmFsc2U7XG4gIGlmIChoYXNJbm5lclN1cmZhY2UpIHtcbiAgICB2ZXJ0ZXhNdWx0aXBsaWVyID0gMi4wO1xuICAgIC8vIEFkZCAyeCBzbGljZVBhcnRpdGlvbnMgdG8gY29ubmVjdCB0aGUgdG9wL2JvdHRvbSBvZiB0aGUgb3V0ZXIgdG9cbiAgICAvLyB0aGUgdG9wL2JvdHRvbSBvZiB0aGUgaW5uZXJcbiAgICBpZiAobWluaW11bUNvbmUgPiAwLjApIHtcbiAgICAgIGlzVG9wT3BlbiA9IHRydWU7XG4gICAgICBleHRyYUluZGljZXMgKz0gc2xpY2VQYXJ0aXRpb25zO1xuICAgIH1cbiAgICBpZiAobWF4aW11bUNvbmUgPCBNYXRoLlBJKSB7XG4gICAgICBpc0JvdE9wZW4gPSB0cnVlO1xuICAgICAgZXh0cmFJbmRpY2VzICs9IHNsaWNlUGFydGl0aW9ucztcbiAgICB9XG4gIH1cblxuICB2YXIgdmVydGV4Q291bnQgPVxuICAgIHN1YmRpdmlzaW9ucyAqIHZlcnRleE11bHRpcGxpZXIgKiAoc3RhY2tQYXJ0aXRpb25zICsgc2xpY2VQYXJ0aXRpb25zKTtcbiAgdmFyIHBvc2l0aW9ucyA9IG5ldyBGbG9hdDY0QXJyYXkodmVydGV4Q291bnQgKiAzKTtcblxuICAvLyBNdWx0aXBseSBieSB0d28gYmVjYXVzZSB0d28gcG9pbnRzIGRlZmluZSBlYWNoIGxpbmUgc2VnbWVudFxuICB2YXIgbnVtSW5kaWNlcyA9XG4gICAgMiAqXG4gICAgKHZlcnRleENvdW50ICtcbiAgICAgIGV4dHJhSW5kaWNlcyAtXG4gICAgICAoc2xpY2VQYXJ0aXRpb25zICsgc3RhY2tQYXJ0aXRpb25zKSAqIHZlcnRleE11bHRpcGxpZXIpO1xuICB2YXIgaW5kaWNlcyA9IEluZGV4RGF0YXR5cGUuY3JlYXRlVHlwZWRBcnJheSh2ZXJ0ZXhDb3VudCwgbnVtSW5kaWNlcyk7XG5cbiAgdmFyIGk7XG4gIHZhciBqO1xuICB2YXIgdGhldGE7XG4gIHZhciBwaGk7XG4gIHZhciBpbmRleCA9IDA7XG5cbiAgLy8gQ2FsY3VsYXRlIHNpbi9jb3MgcGhpXG4gIHZhciBzaW5QaGkgPSBuZXcgQXJyYXkoc3RhY2tQYXJ0aXRpb25zKTtcbiAgdmFyIGNvc1BoaSA9IG5ldyBBcnJheShzdGFja1BhcnRpdGlvbnMpO1xuICBmb3IgKGkgPSAwOyBpIDwgc3RhY2tQYXJ0aXRpb25zOyBpKyspIHtcbiAgICBwaGkgPVxuICAgICAgbWluaW11bUNvbmUgKyAoaSAqIChtYXhpbXVtQ29uZSAtIG1pbmltdW1Db25lKSkgLyAoc3RhY2tQYXJ0aXRpb25zIC0gMSk7XG4gICAgc2luUGhpW2ldID0gc2luKHBoaSk7XG4gICAgY29zUGhpW2ldID0gY29zKHBoaSk7XG4gIH1cblxuICAvLyBDYWxjdWxhdGUgc2luL2NvcyB0aGV0YVxuICB2YXIgc2luVGhldGEgPSBuZXcgQXJyYXkoc3ViZGl2aXNpb25zKTtcbiAgdmFyIGNvc1RoZXRhID0gbmV3IEFycmF5KHN1YmRpdmlzaW9ucyk7XG4gIGZvciAoaSA9IDA7IGkgPCBzdWJkaXZpc2lvbnM7IGkrKykge1xuICAgIHRoZXRhID1cbiAgICAgIG1pbmltdW1DbG9jayArIChpICogKG1heGltdW1DbG9jayAtIG1pbmltdW1DbG9jaykpIC8gKHN1YmRpdmlzaW9ucyAtIDEpO1xuICAgIHNpblRoZXRhW2ldID0gc2luKHRoZXRhKTtcbiAgICBjb3NUaGV0YVtpXSA9IGNvcyh0aGV0YSk7XG4gIH1cblxuICAvLyBDYWxjdWxhdGUgdGhlIGxhdGl0dWRlIGxpbmVzIG9uIHRoZSBvdXRlciBzdXJmYWNlXG4gIGZvciAoaSA9IDA7IGkgPCBzdGFja1BhcnRpdGlvbnM7IGkrKykge1xuICAgIGZvciAoaiA9IDA7IGogPCBzdWJkaXZpc2lvbnM7IGorKykge1xuICAgICAgcG9zaXRpb25zW2luZGV4KytdID0gcmFkaWkueCAqIHNpblBoaVtpXSAqIGNvc1RoZXRhW2pdO1xuICAgICAgcG9zaXRpb25zW2luZGV4KytdID0gcmFkaWkueSAqIHNpblBoaVtpXSAqIHNpblRoZXRhW2pdO1xuICAgICAgcG9zaXRpb25zW2luZGV4KytdID0gcmFkaWkueiAqIGNvc1BoaVtpXTtcbiAgICB9XG4gIH1cblxuICAvLyBDYWxjdWxhdGUgdGhlIGxhdGl0dWRlIGxpbmVzIG9uIHRoZSBpbm5lciBzdXJmYWNlXG4gIGlmIChoYXNJbm5lclN1cmZhY2UpIHtcbiAgICBmb3IgKGkgPSAwOyBpIDwgc3RhY2tQYXJ0aXRpb25zOyBpKyspIHtcbiAgICAgIGZvciAoaiA9IDA7IGogPCBzdWJkaXZpc2lvbnM7IGorKykge1xuICAgICAgICBwb3NpdGlvbnNbaW5kZXgrK10gPSBpbm5lclJhZGlpLnggKiBzaW5QaGlbaV0gKiBjb3NUaGV0YVtqXTtcbiAgICAgICAgcG9zaXRpb25zW2luZGV4KytdID0gaW5uZXJSYWRpaS55ICogc2luUGhpW2ldICogc2luVGhldGFbal07XG4gICAgICAgIHBvc2l0aW9uc1tpbmRleCsrXSA9IGlubmVyUmFkaWkueiAqIGNvc1BoaVtpXTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvLyBDYWxjdWxhdGUgc2luL2NvcyBwaGlcbiAgc2luUGhpLmxlbmd0aCA9IHN1YmRpdmlzaW9ucztcbiAgY29zUGhpLmxlbmd0aCA9IHN1YmRpdmlzaW9ucztcbiAgZm9yIChpID0gMDsgaSA8IHN1YmRpdmlzaW9uczsgaSsrKSB7XG4gICAgcGhpID0gbWluaW11bUNvbmUgKyAoaSAqIChtYXhpbXVtQ29uZSAtIG1pbmltdW1Db25lKSkgLyAoc3ViZGl2aXNpb25zIC0gMSk7XG4gICAgc2luUGhpW2ldID0gc2luKHBoaSk7XG4gICAgY29zUGhpW2ldID0gY29zKHBoaSk7XG4gIH1cblxuICAvLyBDYWxjdWxhdGUgc2luL2NvcyB0aGV0YSBmb3IgZWFjaCBzbGljZSBwYXJ0aXRpb25cbiAgc2luVGhldGEubGVuZ3RoID0gc2xpY2VQYXJ0aXRpb25zO1xuICBjb3NUaGV0YS5sZW5ndGggPSBzbGljZVBhcnRpdGlvbnM7XG4gIGZvciAoaSA9IDA7IGkgPCBzbGljZVBhcnRpdGlvbnM7IGkrKykge1xuICAgIHRoZXRhID1cbiAgICAgIG1pbmltdW1DbG9jayArXG4gICAgICAoaSAqIChtYXhpbXVtQ2xvY2sgLSBtaW5pbXVtQ2xvY2spKSAvIChzbGljZVBhcnRpdGlvbnMgLSAxKTtcbiAgICBzaW5UaGV0YVtpXSA9IHNpbih0aGV0YSk7XG4gICAgY29zVGhldGFbaV0gPSBjb3ModGhldGEpO1xuICB9XG5cbiAgLy8gQ2FsY3VsYXRlIHRoZSBsb25naXR1ZGUgbGluZXMgb24gdGhlIG91dGVyIHN1cmZhY2VcbiAgZm9yIChpID0gMDsgaSA8IHN1YmRpdmlzaW9uczsgaSsrKSB7XG4gICAgZm9yIChqID0gMDsgaiA8IHNsaWNlUGFydGl0aW9uczsgaisrKSB7XG4gICAgICBwb3NpdGlvbnNbaW5kZXgrK10gPSByYWRpaS54ICogc2luUGhpW2ldICogY29zVGhldGFbal07XG4gICAgICBwb3NpdGlvbnNbaW5kZXgrK10gPSByYWRpaS55ICogc2luUGhpW2ldICogc2luVGhldGFbal07XG4gICAgICBwb3NpdGlvbnNbaW5kZXgrK10gPSByYWRpaS56ICogY29zUGhpW2ldO1xuICAgIH1cbiAgfVxuXG4gIC8vIENhbGN1bGF0ZSB0aGUgbG9uZ2l0dWRlIGxpbmVzIG9uIHRoZSBpbm5lciBzdXJmYWNlXG4gIGlmIChoYXNJbm5lclN1cmZhY2UpIHtcbiAgICBmb3IgKGkgPSAwOyBpIDwgc3ViZGl2aXNpb25zOyBpKyspIHtcbiAgICAgIGZvciAoaiA9IDA7IGogPCBzbGljZVBhcnRpdGlvbnM7IGorKykge1xuICAgICAgICBwb3NpdGlvbnNbaW5kZXgrK10gPSBpbm5lclJhZGlpLnggKiBzaW5QaGlbaV0gKiBjb3NUaGV0YVtqXTtcbiAgICAgICAgcG9zaXRpb25zW2luZGV4KytdID0gaW5uZXJSYWRpaS55ICogc2luUGhpW2ldICogc2luVGhldGFbal07XG4gICAgICAgIHBvc2l0aW9uc1tpbmRleCsrXSA9IGlubmVyUmFkaWkueiAqIGNvc1BoaVtpXTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvLyBDcmVhdGUgaW5kaWNlcyBmb3IgdGhlIGxhdGl0dWRlIGxpbmVzXG4gIGluZGV4ID0gMDtcbiAgZm9yIChpID0gMDsgaSA8IHN0YWNrUGFydGl0aW9ucyAqIHZlcnRleE11bHRpcGxpZXI7IGkrKykge1xuICAgIHZhciB0b3BPZmZzZXQgPSBpICogc3ViZGl2aXNpb25zO1xuICAgIGZvciAoaiA9IDA7IGogPCBzdWJkaXZpc2lvbnMgLSAxOyBqKyspIHtcbiAgICAgIGluZGljZXNbaW5kZXgrK10gPSB0b3BPZmZzZXQgKyBqO1xuICAgICAgaW5kaWNlc1tpbmRleCsrXSA9IHRvcE9mZnNldCArIGogKyAxO1xuICAgIH1cbiAgfVxuXG4gIC8vIENyZWF0ZSBpbmRpY2VzIGZvciB0aGUgb3V0ZXIgbG9uZ2l0dWRlIGxpbmVzXG4gIHZhciBvZmZzZXQgPSBzdGFja1BhcnRpdGlvbnMgKiBzdWJkaXZpc2lvbnMgKiB2ZXJ0ZXhNdWx0aXBsaWVyO1xuICBmb3IgKGkgPSAwOyBpIDwgc2xpY2VQYXJ0aXRpb25zOyBpKyspIHtcbiAgICBmb3IgKGogPSAwOyBqIDwgc3ViZGl2aXNpb25zIC0gMTsgaisrKSB7XG4gICAgICBpbmRpY2VzW2luZGV4KytdID0gb2Zmc2V0ICsgaSArIGogKiBzbGljZVBhcnRpdGlvbnM7XG4gICAgICBpbmRpY2VzW2luZGV4KytdID0gb2Zmc2V0ICsgaSArIChqICsgMSkgKiBzbGljZVBhcnRpdGlvbnM7XG4gICAgfVxuICB9XG5cbiAgLy8gQ3JlYXRlIGluZGljZXMgZm9yIHRoZSBpbm5lciBsb25naXR1ZGUgbGluZXNcbiAgaWYgKGhhc0lubmVyU3VyZmFjZSkge1xuICAgIG9mZnNldCA9XG4gICAgICBzdGFja1BhcnRpdGlvbnMgKiBzdWJkaXZpc2lvbnMgKiB2ZXJ0ZXhNdWx0aXBsaWVyICtcbiAgICAgIHNsaWNlUGFydGl0aW9ucyAqIHN1YmRpdmlzaW9ucztcbiAgICBmb3IgKGkgPSAwOyBpIDwgc2xpY2VQYXJ0aXRpb25zOyBpKyspIHtcbiAgICAgIGZvciAoaiA9IDA7IGogPCBzdWJkaXZpc2lvbnMgLSAxOyBqKyspIHtcbiAgICAgICAgaW5kaWNlc1tpbmRleCsrXSA9IG9mZnNldCArIGkgKyBqICogc2xpY2VQYXJ0aXRpb25zO1xuICAgICAgICBpbmRpY2VzW2luZGV4KytdID0gb2Zmc2V0ICsgaSArIChqICsgMSkgKiBzbGljZVBhcnRpdGlvbnM7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgaWYgKGhhc0lubmVyU3VyZmFjZSkge1xuICAgIHZhciBvdXRlck9mZnNldCA9IHN0YWNrUGFydGl0aW9ucyAqIHN1YmRpdmlzaW9ucyAqIHZlcnRleE11bHRpcGxpZXI7XG4gICAgdmFyIGlubmVyT2Zmc2V0ID0gb3V0ZXJPZmZzZXQgKyBzdWJkaXZpc2lvbnMgKiBzbGljZVBhcnRpdGlvbnM7XG4gICAgaWYgKGlzVG9wT3Blbikge1xuICAgICAgLy8gRHJhdyBsaW5lcyBmcm9tIHRoZSB0b3Agb2YgdGhlIGlubmVyIHN1cmZhY2UgdG8gdGhlIHRvcCBvZiB0aGUgb3V0ZXIgc3VyZmFjZVxuICAgICAgZm9yIChpID0gMDsgaSA8IHNsaWNlUGFydGl0aW9uczsgaSsrKSB7XG4gICAgICAgIGluZGljZXNbaW5kZXgrK10gPSBvdXRlck9mZnNldCArIGk7XG4gICAgICAgIGluZGljZXNbaW5kZXgrK10gPSBpbm5lck9mZnNldCArIGk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGlzQm90T3Blbikge1xuICAgICAgLy8gRHJhdyBsaW5lcyBmcm9tIHRoZSB0b3Agb2YgdGhlIGlubmVyIHN1cmZhY2UgdG8gdGhlIHRvcCBvZiB0aGUgb3V0ZXIgc3VyZmFjZVxuICAgICAgb3V0ZXJPZmZzZXQgKz0gc3ViZGl2aXNpb25zICogc2xpY2VQYXJ0aXRpb25zIC0gc2xpY2VQYXJ0aXRpb25zO1xuICAgICAgaW5uZXJPZmZzZXQgKz0gc3ViZGl2aXNpb25zICogc2xpY2VQYXJ0aXRpb25zIC0gc2xpY2VQYXJ0aXRpb25zO1xuICAgICAgZm9yIChpID0gMDsgaSA8IHNsaWNlUGFydGl0aW9uczsgaSsrKSB7XG4gICAgICAgIGluZGljZXNbaW5kZXgrK10gPSBvdXRlck9mZnNldCArIGk7XG4gICAgICAgIGluZGljZXNbaW5kZXgrK10gPSBpbm5lck9mZnNldCArIGk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgdmFyIGF0dHJpYnV0ZXMgPSBuZXcgR2VvbWV0cnlBdHRyaWJ1dGVzKHtcbiAgICBwb3NpdGlvbjogbmV3IEdlb21ldHJ5QXR0cmlidXRlKHtcbiAgICAgIGNvbXBvbmVudERhdGF0eXBlOiBDb21wb25lbnREYXRhdHlwZS5ET1VCTEUsXG4gICAgICBjb21wb25lbnRzUGVyQXR0cmlidXRlOiAzLFxuICAgICAgdmFsdWVzOiBwb3NpdGlvbnMsXG4gICAgfSksXG4gIH0pO1xuXG4gIGlmIChkZWZpbmVkKGVsbGlwc29pZEdlb21ldHJ5Ll9vZmZzZXRBdHRyaWJ1dGUpKSB7XG4gICAgdmFyIGxlbmd0aCA9IHBvc2l0aW9ucy5sZW5ndGg7XG4gICAgdmFyIGFwcGx5T2Zmc2V0ID0gbmV3IFVpbnQ4QXJyYXkobGVuZ3RoIC8gMyk7XG4gICAgdmFyIG9mZnNldFZhbHVlID1cbiAgICAgIGVsbGlwc29pZEdlb21ldHJ5Ll9vZmZzZXRBdHRyaWJ1dGUgPT09IEdlb21ldHJ5T2Zmc2V0QXR0cmlidXRlLk5PTkVcbiAgICAgICAgPyAwXG4gICAgICAgIDogMTtcbiAgICBhcnJheUZpbGwoYXBwbHlPZmZzZXQsIG9mZnNldFZhbHVlKTtcbiAgICBhdHRyaWJ1dGVzLmFwcGx5T2Zmc2V0ID0gbmV3IEdlb21ldHJ5QXR0cmlidXRlKHtcbiAgICAgIGNvbXBvbmVudERhdGF0eXBlOiBDb21wb25lbnREYXRhdHlwZS5VTlNJR05FRF9CWVRFLFxuICAgICAgY29tcG9uZW50c1BlckF0dHJpYnV0ZTogMSxcbiAgICAgIHZhbHVlczogYXBwbHlPZmZzZXQsXG4gICAgfSk7XG4gIH1cblxuICByZXR1cm4gbmV3IEdlb21ldHJ5KHtcbiAgICBhdHRyaWJ1dGVzOiBhdHRyaWJ1dGVzLFxuICAgIGluZGljZXM6IGluZGljZXMsXG4gICAgcHJpbWl0aXZlVHlwZTogUHJpbWl0aXZlVHlwZS5MSU5FUyxcbiAgICBib3VuZGluZ1NwaGVyZTogQm91bmRpbmdTcGhlcmUuZnJvbUVsbGlwc29pZChlbGxpcHNvaWQpLFxuICAgIG9mZnNldEF0dHJpYnV0ZTogZWxsaXBzb2lkR2VvbWV0cnkuX29mZnNldEF0dHJpYnV0ZSxcbiAgfSk7XG59O1xuZXhwb3J0IGRlZmF1bHQgRWxsaXBzb2lkT3V0bGluZUdlb21ldHJ5O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///75619\n')},8398:function(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__){eval('/* harmony import */ var _Cartesian3_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(60216);\n/* harmony import */ var _Cartographic_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(51688);\n/* harmony import */ var _Check_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(66553);\n/* harmony import */ var _defaultValue_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(62200);\n/* harmony import */ var _defined_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(82982);\n/* harmony import */ var _DeveloperError_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(12572);\n/* harmony import */ var _Ellipsoid_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(50491);\n/* harmony import */ var _Math_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(99417);\n\n\n\n\n\n\n\n\n\nfunction calculateM(ellipticity, major, latitude) {\n  if (ellipticity === 0.0) {\n    // sphere\n    return major * latitude;\n  }\n\n  var e2 = ellipticity * ellipticity;\n  var e4 = e2 * e2;\n  var e6 = e4 * e2;\n  var e8 = e6 * e2;\n  var e10 = e8 * e2;\n  var e12 = e10 * e2;\n  var phi = latitude;\n  var sin2Phi = Math.sin(2 * phi);\n  var sin4Phi = Math.sin(4 * phi);\n  var sin6Phi = Math.sin(6 * phi);\n  var sin8Phi = Math.sin(8 * phi);\n  var sin10Phi = Math.sin(10 * phi);\n  var sin12Phi = Math.sin(12 * phi);\n\n  return (\n    major *\n    ((1 -\n      e2 / 4 -\n      (3 * e4) / 64 -\n      (5 * e6) / 256 -\n      (175 * e8) / 16384 -\n      (441 * e10) / 65536 -\n      (4851 * e12) / 1048576) *\n      phi -\n      ((3 * e2) / 8 +\n        (3 * e4) / 32 +\n        (45 * e6) / 1024 +\n        (105 * e8) / 4096 +\n        (2205 * e10) / 131072 +\n        (6237 * e12) / 524288) *\n        sin2Phi +\n      ((15 * e4) / 256 +\n        (45 * e6) / 1024 +\n        (525 * e8) / 16384 +\n        (1575 * e10) / 65536 +\n        (155925 * e12) / 8388608) *\n        sin4Phi -\n      ((35 * e6) / 3072 +\n        (175 * e8) / 12288 +\n        (3675 * e10) / 262144 +\n        (13475 * e12) / 1048576) *\n        sin6Phi +\n      ((315 * e8) / 131072 + (2205 * e10) / 524288 + (43659 * e12) / 8388608) *\n        sin8Phi -\n      ((693 * e10) / 1310720 + (6237 * e12) / 5242880) * sin10Phi +\n      ((1001 * e12) / 8388608) * sin12Phi)\n  );\n}\n\nfunction calculateInverseM(M, ellipticity, major) {\n  var d = M / major;\n\n  if (ellipticity === 0.0) {\n    // sphere\n    return d;\n  }\n\n  var d2 = d * d;\n  var d3 = d2 * d;\n  var d4 = d3 * d;\n  var e = ellipticity;\n  var e2 = e * e;\n  var e4 = e2 * e2;\n  var e6 = e4 * e2;\n  var e8 = e6 * e2;\n  var e10 = e8 * e2;\n  var e12 = e10 * e2;\n  var sin2D = Math.sin(2 * d);\n  var cos2D = Math.cos(2 * d);\n  var sin4D = Math.sin(4 * d);\n  var cos4D = Math.cos(4 * d);\n  var sin6D = Math.sin(6 * d);\n  var cos6D = Math.cos(6 * d);\n  var sin8D = Math.sin(8 * d);\n  var cos8D = Math.cos(8 * d);\n  var sin10D = Math.sin(10 * d);\n  var cos10D = Math.cos(10 * d);\n  var sin12D = Math.sin(12 * d);\n\n  return (\n    d +\n    (d * e2) / 4 +\n    (7 * d * e4) / 64 +\n    (15 * d * e6) / 256 +\n    (579 * d * e8) / 16384 +\n    (1515 * d * e10) / 65536 +\n    (16837 * d * e12) / 1048576 +\n    ((3 * d * e4) / 16 +\n      (45 * d * e6) / 256 -\n      (d * (32 * d2 - 561) * e8) / 4096 -\n      (d * (232 * d2 - 1677) * e10) / 16384 +\n      (d * (399985 - 90560 * d2 + 512 * d4) * e12) / 5242880) *\n      cos2D +\n    ((21 * d * e6) / 256 +\n      (483 * d * e8) / 4096 -\n      (d * (224 * d2 - 1969) * e10) / 16384 -\n      (d * (33152 * d2 - 112599) * e12) / 1048576) *\n      cos4D +\n    ((151 * d * e8) / 4096 +\n      (4681 * d * e10) / 65536 +\n      (1479 * d * e12) / 16384 -\n      (453 * d3 * e12) / 32768) *\n      cos6D +\n    ((1097 * d * e10) / 65536 + (42783 * d * e12) / 1048576) * cos8D +\n    ((8011 * d * e12) / 1048576) * cos10D +\n    ((3 * e2) / 8 +\n      (3 * e4) / 16 +\n      (213 * e6) / 2048 -\n      (3 * d2 * e6) / 64 +\n      (255 * e8) / 4096 -\n      (33 * d2 * e8) / 512 +\n      (20861 * e10) / 524288 -\n      (33 * d2 * e10) / 512 +\n      (d4 * e10) / 1024 +\n      (28273 * e12) / 1048576 -\n      (471 * d2 * e12) / 8192 +\n      (9 * d4 * e12) / 4096) *\n      sin2D +\n    ((21 * e4) / 256 +\n      (21 * e6) / 256 +\n      (533 * e8) / 8192 -\n      (21 * d2 * e8) / 512 +\n      (197 * e10) / 4096 -\n      (315 * d2 * e10) / 4096 +\n      (584039 * e12) / 16777216 -\n      (12517 * d2 * e12) / 131072 +\n      (7 * d4 * e12) / 2048) *\n      sin4D +\n    ((151 * e6) / 6144 +\n      (151 * e8) / 4096 +\n      (5019 * e10) / 131072 -\n      (453 * d2 * e10) / 16384 +\n      (26965 * e12) / 786432 -\n      (8607 * d2 * e12) / 131072) *\n      sin6D +\n    ((1097 * e8) / 131072 +\n      (1097 * e10) / 65536 +\n      (225797 * e12) / 10485760 -\n      (1097 * d2 * e12) / 65536) *\n      sin8D +\n    ((8011 * e10) / 2621440 + (8011 * e12) / 1048576) * sin10D +\n    ((293393 * e12) / 251658240) * sin12D\n  );\n}\n\nfunction calculateSigma(ellipticity, latitude) {\n  if (ellipticity === 0.0) {\n    // sphere\n    return Math.log(Math.tan(0.5 * (_Math_js__WEBPACK_IMPORTED_MODULE_6__/* ["default"].PI_OVER_TWO */ .Z.PI_OVER_TWO + latitude)));\n  }\n\n  var eSinL = ellipticity * Math.sin(latitude);\n  return (\n    Math.log(Math.tan(0.5 * (_Math_js__WEBPACK_IMPORTED_MODULE_6__/* ["default"].PI_OVER_TWO */ .Z.PI_OVER_TWO + latitude))) -\n    (ellipticity / 2.0) * Math.log((1 + eSinL) / (1 - eSinL))\n  );\n}\n\nfunction calculateHeading(\n  ellipsoidRhumbLine,\n  firstLongitude,\n  firstLatitude,\n  secondLongitude,\n  secondLatitude\n) {\n  var sigma1 = calculateSigma(ellipsoidRhumbLine._ellipticity, firstLatitude);\n  var sigma2 = calculateSigma(ellipsoidRhumbLine._ellipticity, secondLatitude);\n  return Math.atan2(\n    _Math_js__WEBPACK_IMPORTED_MODULE_6__/* ["default"].negativePiToPi */ .Z.negativePiToPi(secondLongitude - firstLongitude),\n    sigma2 - sigma1\n  );\n}\n\nfunction calculateArcLength(\n  ellipsoidRhumbLine,\n  major,\n  minor,\n  firstLongitude,\n  firstLatitude,\n  secondLongitude,\n  secondLatitude\n) {\n  var heading = ellipsoidRhumbLine._heading;\n  var deltaLongitude = secondLongitude - firstLongitude;\n\n  var distance = 0.0;\n\n  //Check to see if the rhumb line has constant latitude\n  //This equation will diverge if heading gets close to 90 degrees\n  if (\n    _Math_js__WEBPACK_IMPORTED_MODULE_6__/* ["default"].equalsEpsilon */ .Z.equalsEpsilon(\n      Math.abs(heading),\n      _Math_js__WEBPACK_IMPORTED_MODULE_6__/* ["default"].PI_OVER_TWO */ .Z.PI_OVER_TWO,\n      _Math_js__WEBPACK_IMPORTED_MODULE_6__/* ["default"].EPSILON8 */ .Z.EPSILON8\n    )\n  ) {\n    //If heading is close to 90 degrees\n    if (major === minor) {\n      distance =\n        major *\n        Math.cos(firstLatitude) *\n        _Math_js__WEBPACK_IMPORTED_MODULE_6__/* ["default"].negativePiToPi */ .Z.negativePiToPi(deltaLongitude);\n    } else {\n      var sinPhi = Math.sin(firstLatitude);\n      distance =\n        (major *\n          Math.cos(firstLatitude) *\n          _Math_js__WEBPACK_IMPORTED_MODULE_6__/* ["default"].negativePiToPi */ .Z.negativePiToPi(deltaLongitude)) /\n        Math.sqrt(1 - ellipsoidRhumbLine._ellipticitySquared * sinPhi * sinPhi);\n    }\n  } else {\n    var M1 = calculateM(ellipsoidRhumbLine._ellipticity, major, firstLatitude);\n    var M2 = calculateM(ellipsoidRhumbLine._ellipticity, major, secondLatitude);\n\n    distance = (M2 - M1) / Math.cos(heading);\n  }\n  return Math.abs(distance);\n}\n\nvar scratchCart1 = new _Cartesian3_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .Z();\nvar scratchCart2 = new _Cartesian3_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .Z();\n\nfunction computeProperties(ellipsoidRhumbLine, start, end, ellipsoid) {\n  var firstCartesian = _Cartesian3_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].normalize */ .Z.normalize(\n    ellipsoid.cartographicToCartesian(start, scratchCart2),\n    scratchCart1\n  );\n  var lastCartesian = _Cartesian3_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].normalize */ .Z.normalize(\n    ellipsoid.cartographicToCartesian(end, scratchCart2),\n    scratchCart2\n  );\n\n  //>>includeStart(\'debug\', pragmas.debug);\n  _Check_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"].typeOf.number.greaterThanOrEquals */ .Z.typeOf.number.greaterThanOrEquals(\n    "value",\n    Math.abs(\n      Math.abs(_Cartesian3_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].angleBetween */ .Z.angleBetween(firstCartesian, lastCartesian)) - Math.PI\n    ),\n    0.0125\n  );\n  //>>includeEnd(\'debug\');\n\n  var major = ellipsoid.maximumRadius;\n  var minor = ellipsoid.minimumRadius;\n  var majorSquared = major * major;\n  var minorSquared = minor * minor;\n  ellipsoidRhumbLine._ellipticitySquared =\n    (majorSquared - minorSquared) / majorSquared;\n  ellipsoidRhumbLine._ellipticity = Math.sqrt(\n    ellipsoidRhumbLine._ellipticitySquared\n  );\n\n  ellipsoidRhumbLine._start = _Cartographic_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"].clone */ .Z.clone(\n    start,\n    ellipsoidRhumbLine._start\n  );\n  ellipsoidRhumbLine._start.height = 0;\n\n  ellipsoidRhumbLine._end = _Cartographic_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"].clone */ .Z.clone(end, ellipsoidRhumbLine._end);\n  ellipsoidRhumbLine._end.height = 0;\n\n  ellipsoidRhumbLine._heading = calculateHeading(\n    ellipsoidRhumbLine,\n    start.longitude,\n    start.latitude,\n    end.longitude,\n    end.latitude\n  );\n  ellipsoidRhumbLine._distance = calculateArcLength(\n    ellipsoidRhumbLine,\n    ellipsoid.maximumRadius,\n    ellipsoid.minimumRadius,\n    start.longitude,\n    start.latitude,\n    end.longitude,\n    end.latitude\n  );\n}\n\nfunction interpolateUsingSurfaceDistance(\n  start,\n  heading,\n  distance,\n  major,\n  ellipticity,\n  result\n) {\n  if (distance === 0.0) {\n    return _Cartographic_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"].clone */ .Z.clone(start, result);\n  }\n\n  var ellipticitySquared = ellipticity * ellipticity;\n\n  var longitude;\n  var latitude;\n  var deltaLongitude;\n\n  //Check to see if the rhumb line has constant latitude\n  //This won\'t converge if heading is close to 90 degrees\n  if (\n    Math.abs(_Math_js__WEBPACK_IMPORTED_MODULE_6__/* ["default"].PI_OVER_TWO */ .Z.PI_OVER_TWO - Math.abs(heading)) > _Math_js__WEBPACK_IMPORTED_MODULE_6__/* ["default"].EPSILON8 */ .Z.EPSILON8\n  ) {\n    //Calculate latitude of the second point\n    var M1 = calculateM(ellipticity, major, start.latitude);\n    var deltaM = distance * Math.cos(heading);\n    var M2 = M1 + deltaM;\n    latitude = calculateInverseM(M2, ellipticity, major);\n\n    //Now find the longitude of the second point\n    var sigma1 = calculateSigma(ellipticity, start.latitude);\n    var sigma2 = calculateSigma(ellipticity, latitude);\n    deltaLongitude = Math.tan(heading) * (sigma2 - sigma1);\n    longitude = _Math_js__WEBPACK_IMPORTED_MODULE_6__/* ["default"].negativePiToPi */ .Z.negativePiToPi(start.longitude + deltaLongitude);\n  } else {\n    //If heading is close to 90 degrees\n    latitude = start.latitude;\n    var localRad;\n\n    if (ellipticity === 0.0) {\n      // sphere\n      localRad = major * Math.cos(start.latitude);\n    } else {\n      var sinPhi = Math.sin(start.latitude);\n      localRad =\n        (major * Math.cos(start.latitude)) /\n        Math.sqrt(1 - ellipticitySquared * sinPhi * sinPhi);\n    }\n\n    deltaLongitude = distance / localRad;\n    if (heading > 0.0) {\n      longitude = _Math_js__WEBPACK_IMPORTED_MODULE_6__/* ["default"].negativePiToPi */ .Z.negativePiToPi(start.longitude + deltaLongitude);\n    } else {\n      longitude = _Math_js__WEBPACK_IMPORTED_MODULE_6__/* ["default"].negativePiToPi */ .Z.negativePiToPi(start.longitude - deltaLongitude);\n    }\n  }\n\n  if ((0,_defined_js__WEBPACK_IMPORTED_MODULE_7__/* ["default"] */ .Z)(result)) {\n    result.longitude = longitude;\n    result.latitude = latitude;\n    result.height = 0;\n\n    return result;\n  }\n\n  return new _Cartographic_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .Z(longitude, latitude, 0);\n}\n\n/**\n * Initializes a rhumb line on the ellipsoid connecting the two provided planetodetic points.\n *\n * @alias EllipsoidRhumbLine\n * @constructor\n *\n * @param {Cartographic} [start] The initial planetodetic point on the path.\n * @param {Cartographic} [end] The final planetodetic point on the path.\n * @param {Ellipsoid} [ellipsoid=Ellipsoid.WGS84] The ellipsoid on which the rhumb line lies.\n *\n * @exception {DeveloperError} angle between start and end must be at least 0.0125 radians.\n */\nfunction EllipsoidRhumbLine(start, end, ellipsoid) {\n  var e = (0,_defaultValue_js__WEBPACK_IMPORTED_MODULE_3__/* ["default"] */ .Z)(ellipsoid, _Ellipsoid_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"].WGS84 */ .Z.WGS84);\n  this._ellipsoid = e;\n  this._start = new _Cartographic_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .Z();\n  this._end = new _Cartographic_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .Z();\n\n  this._heading = undefined;\n  this._distance = undefined;\n  this._ellipticity = undefined;\n  this._ellipticitySquared = undefined;\n\n  if ((0,_defined_js__WEBPACK_IMPORTED_MODULE_7__/* ["default"] */ .Z)(start) && (0,_defined_js__WEBPACK_IMPORTED_MODULE_7__/* ["default"] */ .Z)(end)) {\n    computeProperties(this, start, end, e);\n  }\n}\n\nObject.defineProperties(EllipsoidRhumbLine.prototype, {\n  /**\n   * Gets the ellipsoid.\n   * @memberof EllipsoidRhumbLine.prototype\n   * @type {Ellipsoid}\n   * @readonly\n   */\n  ellipsoid: {\n    get: function () {\n      return this._ellipsoid;\n    },\n  },\n\n  /**\n   * Gets the surface distance between the start and end point\n   * @memberof EllipsoidRhumbLine.prototype\n   * @type {Number}\n   * @readonly\n   */\n  surfaceDistance: {\n    get: function () {\n      //>>includeStart(\'debug\', pragmas.debug);\n      _Check_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"].defined */ .Z.defined("distance", this._distance);\n      //>>includeEnd(\'debug\');\n\n      return this._distance;\n    },\n  },\n\n  /**\n   * Gets the initial planetodetic point on the path.\n   * @memberof EllipsoidRhumbLine.prototype\n   * @type {Cartographic}\n   * @readonly\n   */\n  start: {\n    get: function () {\n      return this._start;\n    },\n  },\n\n  /**\n   * Gets the final planetodetic point on the path.\n   * @memberof EllipsoidRhumbLine.prototype\n   * @type {Cartographic}\n   * @readonly\n   */\n  end: {\n    get: function () {\n      return this._end;\n    },\n  },\n\n  /**\n   * Gets the heading from the start point to the end point.\n   * @memberof EllipsoidRhumbLine.prototype\n   * @type {Number}\n   * @readonly\n   */\n  heading: {\n    get: function () {\n      //>>includeStart(\'debug\', pragmas.debug);\n      _Check_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"].defined */ .Z.defined("distance", this._distance);\n      //>>includeEnd(\'debug\');\n\n      return this._heading;\n    },\n  },\n});\n\n/**\n * Create a rhumb line using an initial position with a heading and distance.\n *\n * @param {Cartographic} start The initial planetodetic point on the path.\n * @param {Number} heading The heading in radians.\n * @param {Number} distance The rhumb line distance between the start and end point.\n * @param {Ellipsoid} [ellipsoid=Ellipsoid.WGS84] The ellipsoid on which the rhumb line lies.\n * @param {EllipsoidRhumbLine} [result] The object in which to store the result.\n * @returns {EllipsoidRhumbLine} The EllipsoidRhumbLine object.\n */\nEllipsoidRhumbLine.fromStartHeadingDistance = function (\n  start,\n  heading,\n  distance,\n  ellipsoid,\n  result\n) {\n  //>>includeStart(\'debug\', pragmas.debug);\n  _Check_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"].defined */ .Z.defined("start", start);\n  _Check_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"].defined */ .Z.defined("heading", heading);\n  _Check_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"].defined */ .Z.defined("distance", distance);\n  _Check_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"].typeOf.number.greaterThan */ .Z.typeOf.number.greaterThan("distance", distance, 0.0);\n  //>>includeEnd(\'debug\');\n\n  var e = (0,_defaultValue_js__WEBPACK_IMPORTED_MODULE_3__/* ["default"] */ .Z)(ellipsoid, _Ellipsoid_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"].WGS84 */ .Z.WGS84);\n  var major = e.maximumRadius;\n  var minor = e.minimumRadius;\n  var majorSquared = major * major;\n  var minorSquared = minor * minor;\n  var ellipticity = Math.sqrt((majorSquared - minorSquared) / majorSquared);\n\n  heading = _Math_js__WEBPACK_IMPORTED_MODULE_6__/* ["default"].negativePiToPi */ .Z.negativePiToPi(heading);\n  var end = interpolateUsingSurfaceDistance(\n    start,\n    heading,\n    distance,\n    e.maximumRadius,\n    ellipticity\n  );\n\n  if (\n    !(0,_defined_js__WEBPACK_IMPORTED_MODULE_7__/* ["default"] */ .Z)(result) ||\n    ((0,_defined_js__WEBPACK_IMPORTED_MODULE_7__/* ["default"] */ .Z)(ellipsoid) && !ellipsoid.equals(result.ellipsoid))\n  ) {\n    return new EllipsoidRhumbLine(start, end, e);\n  }\n\n  result.setEndPoints(start, end);\n  return result;\n};\n\n/**\n * Sets the start and end points of the rhumb line.\n *\n * @param {Cartographic} start The initial planetodetic point on the path.\n * @param {Cartographic} end The final planetodetic point on the path.\n */\nEllipsoidRhumbLine.prototype.setEndPoints = function (start, end) {\n  //>>includeStart(\'debug\', pragmas.debug);\n  _Check_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"].defined */ .Z.defined("start", start);\n  _Check_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"].defined */ .Z.defined("end", end);\n  //>>includeEnd(\'debug\');\n\n  computeProperties(this, start, end, this._ellipsoid);\n};\n\n/**\n * Provides the location of a point at the indicated portion along the rhumb line.\n *\n * @param {Number} fraction The portion of the distance between the initial and final points.\n * @param {Cartographic} [result] The object in which to store the result.\n * @returns {Cartographic} The location of the point along the rhumb line.\n */\nEllipsoidRhumbLine.prototype.interpolateUsingFraction = function (\n  fraction,\n  result\n) {\n  return this.interpolateUsingSurfaceDistance(\n    fraction * this._distance,\n    result\n  );\n};\n\n/**\n * Provides the location of a point at the indicated distance along the rhumb line.\n *\n * @param {Number} distance The distance from the inital point to the point of interest along the rhumbLine.\n * @param {Cartographic} [result] The object in which to store the result.\n * @returns {Cartographic} The location of the point along the rhumb line.\n *\n * @exception {DeveloperError} start and end must be set before calling function interpolateUsingSurfaceDistance\n */\nEllipsoidRhumbLine.prototype.interpolateUsingSurfaceDistance = function (\n  distance,\n  result\n) {\n  //>>includeStart(\'debug\', pragmas.debug);\n  _Check_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"].typeOf.number */ .Z.typeOf.number("distance", distance);\n  if (!(0,_defined_js__WEBPACK_IMPORTED_MODULE_7__/* ["default"] */ .Z)(this._distance) || this._distance === 0.0) {\n    throw new _DeveloperError_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .Z(\n      "EllipsoidRhumbLine must have distinct start and end set."\n    );\n  }\n  //>>includeEnd(\'debug\');\n\n  return interpolateUsingSurfaceDistance(\n    this._start,\n    this._heading,\n    distance,\n    this._ellipsoid.maximumRadius,\n    this._ellipticity,\n    result\n  );\n};\n\n/**\n * Provides the location of a point at the indicated longitude along the rhumb line.\n * If the longitude is outside the range of start and end points, the first intersection with the longitude from the start point in the direction of the heading is returned. This follows the spiral property of a rhumb line.\n *\n * @param {Number} intersectionLongitude The longitude, in radians, at which to find the intersection point from the starting point using the heading.\n * @param {Cartographic} [result] The object in which to store the result.\n * @returns {Cartographic} The location of the intersection point along the rhumb line, undefined if there is no intersection or infinite intersections.\n *\n * @exception {DeveloperError} start and end must be set before calling function findIntersectionWithLongitude.\n */\nEllipsoidRhumbLine.prototype.findIntersectionWithLongitude = function (\n  intersectionLongitude,\n  result\n) {\n  //>>includeStart(\'debug\', pragmas.debug);\n  _Check_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"].typeOf.number */ .Z.typeOf.number("intersectionLongitude", intersectionLongitude);\n  if (!(0,_defined_js__WEBPACK_IMPORTED_MODULE_7__/* ["default"] */ .Z)(this._distance) || this._distance === 0.0) {\n    throw new _DeveloperError_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .Z(\n      "EllipsoidRhumbLine must have distinct start and end set."\n    );\n  }\n  //>>includeEnd(\'debug\');\n\n  var ellipticity = this._ellipticity;\n  var heading = this._heading;\n  var absHeading = Math.abs(heading);\n  var start = this._start;\n\n  intersectionLongitude = _Math_js__WEBPACK_IMPORTED_MODULE_6__/* ["default"].negativePiToPi */ .Z.negativePiToPi(intersectionLongitude);\n\n  if (\n    _Math_js__WEBPACK_IMPORTED_MODULE_6__/* ["default"].equalsEpsilon */ .Z.equalsEpsilon(\n      Math.abs(intersectionLongitude),\n      Math.PI,\n      _Math_js__WEBPACK_IMPORTED_MODULE_6__/* ["default"].EPSILON14 */ .Z.EPSILON14\n    )\n  ) {\n    intersectionLongitude = _Math_js__WEBPACK_IMPORTED_MODULE_6__/* ["default"].sign */ .Z.sign(start.longitude) * Math.PI;\n  }\n\n  if (!(0,_defined_js__WEBPACK_IMPORTED_MODULE_7__/* ["default"] */ .Z)(result)) {\n    result = new _Cartographic_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .Z();\n  }\n\n  // If heading is -PI/2 or PI/2, this is an E-W rhumb line\n  // If heading is 0 or PI, this is an N-S rhumb line\n  if (Math.abs(_Math_js__WEBPACK_IMPORTED_MODULE_6__/* ["default"].PI_OVER_TWO */ .Z.PI_OVER_TWO - absHeading) <= _Math_js__WEBPACK_IMPORTED_MODULE_6__/* ["default"].EPSILON8 */ .Z.EPSILON8) {\n    result.longitude = intersectionLongitude;\n    result.latitude = start.latitude;\n    result.height = 0;\n    return result;\n  } else if (\n    _Math_js__WEBPACK_IMPORTED_MODULE_6__/* ["default"].equalsEpsilon */ .Z.equalsEpsilon(\n      Math.abs(_Math_js__WEBPACK_IMPORTED_MODULE_6__/* ["default"].PI_OVER_TWO */ .Z.PI_OVER_TWO - absHeading),\n      _Math_js__WEBPACK_IMPORTED_MODULE_6__/* ["default"].PI_OVER_TWO */ .Z.PI_OVER_TWO,\n      _Math_js__WEBPACK_IMPORTED_MODULE_6__/* ["default"].EPSILON8 */ .Z.EPSILON8\n    )\n  ) {\n    if (\n      _Math_js__WEBPACK_IMPORTED_MODULE_6__/* ["default"].equalsEpsilon */ .Z.equalsEpsilon(\n        intersectionLongitude,\n        start.longitude,\n        _Math_js__WEBPACK_IMPORTED_MODULE_6__/* ["default"].EPSILON12 */ .Z.EPSILON12\n      )\n    ) {\n      return undefined;\n    }\n\n    result.longitude = intersectionLongitude;\n    result.latitude =\n      _Math_js__WEBPACK_IMPORTED_MODULE_6__/* ["default"].PI_OVER_TWO */ .Z.PI_OVER_TWO *\n      _Math_js__WEBPACK_IMPORTED_MODULE_6__/* ["default"].sign */ .Z.sign(_Math_js__WEBPACK_IMPORTED_MODULE_6__/* ["default"].PI_OVER_TWO */ .Z.PI_OVER_TWO - heading);\n    result.height = 0;\n    return result;\n  }\n\n  // Use iterative solver from Equation 9 from http://edwilliams.org/ellipsoid/ellipsoid.pdf\n  var phi1 = start.latitude;\n  var eSinPhi1 = ellipticity * Math.sin(phi1);\n  var leftComponent =\n    Math.tan(0.5 * (_Math_js__WEBPACK_IMPORTED_MODULE_6__/* ["default"].PI_OVER_TWO */ .Z.PI_OVER_TWO + phi1)) *\n    Math.exp((intersectionLongitude - start.longitude) / Math.tan(heading));\n  var denominator = (1 + eSinPhi1) / (1 - eSinPhi1);\n\n  var newPhi = start.latitude;\n  var phi;\n  do {\n    phi = newPhi;\n    var eSinPhi = ellipticity * Math.sin(phi);\n    var numerator = (1 + eSinPhi) / (1 - eSinPhi);\n    newPhi =\n      2 *\n        Math.atan(\n          leftComponent * Math.pow(numerator / denominator, ellipticity / 2)\n        ) -\n      _Math_js__WEBPACK_IMPORTED_MODULE_6__/* ["default"].PI_OVER_TWO */ .Z.PI_OVER_TWO;\n  } while (!_Math_js__WEBPACK_IMPORTED_MODULE_6__/* ["default"].equalsEpsilon */ .Z.equalsEpsilon(newPhi, phi, _Math_js__WEBPACK_IMPORTED_MODULE_6__/* ["default"].EPSILON12 */ .Z.EPSILON12));\n\n  result.longitude = intersectionLongitude;\n  result.latitude = newPhi;\n  result.height = 0;\n  return result;\n};\n\n/**\n * Provides the location of a point at the indicated latitude along the rhumb line.\n * If the latitude is outside the range of start and end points, the first intersection with the latitude from that start point in the direction of the heading is returned. This follows the spiral property of a rhumb line.\n *\n * @param {Number} intersectionLatitude The latitude, in radians, at which to find the intersection point from the starting point using the heading.\n * @param {Cartographic} [result] The object in which to store the result.\n * @returns {Cartographic} The location of the intersection point along the rhumb line, undefined if there is no intersection or infinite intersections.\n *\n * @exception {DeveloperError} start and end must be set before calling function findIntersectionWithLongitude.\n */\nEllipsoidRhumbLine.prototype.findIntersectionWithLatitude = function (\n  intersectionLatitude,\n  result\n) {\n  //>>includeStart(\'debug\', pragmas.debug);\n  _Check_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"].typeOf.number */ .Z.typeOf.number("intersectionLatitude", intersectionLatitude);\n  if (!(0,_defined_js__WEBPACK_IMPORTED_MODULE_7__/* ["default"] */ .Z)(this._distance) || this._distance === 0.0) {\n    throw new _DeveloperError_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .Z(\n      "EllipsoidRhumbLine must have distinct start and end set."\n    );\n  }\n  //>>includeEnd(\'debug\');\n\n  var ellipticity = this._ellipticity;\n  var heading = this._heading;\n  var start = this._start;\n\n  // If start and end have same latitude, return undefined since it\'s either no intersection or infinite intersections\n  if (\n    _Math_js__WEBPACK_IMPORTED_MODULE_6__/* ["default"].equalsEpsilon */ .Z.equalsEpsilon(\n      Math.abs(heading),\n      _Math_js__WEBPACK_IMPORTED_MODULE_6__/* ["default"].PI_OVER_TWO */ .Z.PI_OVER_TWO,\n      _Math_js__WEBPACK_IMPORTED_MODULE_6__/* ["default"].EPSILON8 */ .Z.EPSILON8\n    )\n  ) {\n    return;\n  }\n\n  // Can be solved using the same equations from interpolateUsingSurfaceDistance\n  var sigma1 = calculateSigma(ellipticity, start.latitude);\n  var sigma2 = calculateSigma(ellipticity, intersectionLatitude);\n  var deltaLongitude = Math.tan(heading) * (sigma2 - sigma1);\n  var longitude = _Math_js__WEBPACK_IMPORTED_MODULE_6__/* ["default"].negativePiToPi */ .Z.negativePiToPi(start.longitude + deltaLongitude);\n\n  if ((0,_defined_js__WEBPACK_IMPORTED_MODULE_7__/* ["default"] */ .Z)(result)) {\n    result.longitude = longitude;\n    result.latitude = intersectionLatitude;\n    result.height = 0;\n\n    return result;\n  }\n\n  return new _Cartographic_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .Z(longitude, intersectionLatitude, 0);\n};\n/* harmony default export */ __webpack_exports__["Z"] = (EllipsoidRhumbLine);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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Q0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsY0FBYztBQUN6QixhQUFhLGNBQWM7QUFDM0I7QUFDQSxlQUFlLGdCQUFnQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFLHNGQUFtQjtBQUNyQixPQUFPLGdFQUFPO0FBQ2QsY0FBYyxtRUFBYztBQUM1QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUkscUZBQXdCO0FBQzVCO0FBQ0EsTUFBTSxpRkFBc0I7QUFDNUIsTUFBTSwyRUFBbUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsdUZBQXlCOztBQUUzQyxNQUFNLGdFQUFPO0FBQ2I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsYUFBYSxpRUFBWTtBQUN6QjtBQUNBLHlEQUFlLGtCQUFrQixFQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdnVlMy13ZWJwYWNrNS8uL25vZGVfbW9kdWxlcy9jZXNpdW0vU291cmNlL0NvcmUvRWxsaXBzb2lkUmh1bWJMaW5lLmpzPzhjMzIiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IENhcnRlc2lhbjMgZnJvbSBcIi4vQ2FydGVzaWFuMy5qc1wiO1xuaW1wb3J0IENhcnRvZ3JhcGhpYyBmcm9tIFwiLi9DYXJ0b2dyYXBoaWMuanNcIjtcbmltcG9ydCBDaGVjayBmcm9tIFwiLi9DaGVjay5qc1wiO1xuaW1wb3J0IGRlZmF1bHRWYWx1ZSBmcm9tIFwiLi9kZWZhdWx0VmFsdWUuanNcIjtcbmltcG9ydCBkZWZpbmVkIGZyb20gXCIuL2RlZmluZWQuanNcIjtcbmltcG9ydCBEZXZlbG9wZXJFcnJvciBmcm9tIFwiLi9EZXZlbG9wZXJFcnJvci5qc1wiO1xuaW1wb3J0IEVsbGlwc29pZCBmcm9tIFwiLi9FbGxpcHNvaWQuanNcIjtcbmltcG9ydCBDZXNpdW1NYXRoIGZyb20gXCIuL01hdGguanNcIjtcblxuZnVuY3Rpb24gY2FsY3VsYXRlTShlbGxpcHRpY2l0eSwgbWFqb3IsIGxhdGl0dWRlKSB7XG4gIGlmIChlbGxpcHRpY2l0eSA9PT0gMC4wKSB7XG4gICAgLy8gc3BoZXJlXG4gICAgcmV0dXJuIG1ham9yICogbGF0aXR1ZGU7XG4gIH1cblxuICB2YXIgZTIgPSBlbGxpcHRpY2l0eSAqIGVsbGlwdGljaXR5O1xuICB2YXIgZTQgPSBlMiAqIGUyO1xuICB2YXIgZTYgPSBlNCAqIGUyO1xuICB2YXIgZTggPSBlNiAqIGUyO1xuICB2YXIgZTEwID0gZTggKiBlMjtcbiAgdmFyIGUxMiA9IGUxMCAqIGUyO1xuICB2YXIgcGhpID0gbGF0aXR1ZGU7XG4gIHZhciBzaW4yUGhpID0gTWF0aC5zaW4oMiAqIHBoaSk7XG4gIHZhciBzaW40UGhpID0gTWF0aC5zaW4oNCAqIHBoaSk7XG4gIHZhciBzaW42UGhpID0gTWF0aC5zaW4oNiAqIHBoaSk7XG4gIHZhciBzaW44UGhpID0gTWF0aC5zaW4oOCAqIHBoaSk7XG4gIHZhciBzaW4xMFBoaSA9IE1hdGguc2luKDEwICogcGhpKTtcbiAgdmFyIHNpbjEyUGhpID0gTWF0aC5zaW4oMTIgKiBwaGkpO1xuXG4gIHJldHVybiAoXG4gICAgbWFqb3IgKlxuICAgICgoMSAtXG4gICAgICBlMiAvIDQgLVxuICAgICAgKDMgKiBlNCkgLyA2NCAtXG4gICAgICAoNSAqIGU2KSAvIDI1NiAtXG4gICAgICAoMTc1ICogZTgpIC8gMTYzODQgLVxuICAgICAgKDQ0MSAqIGUxMCkgLyA2NTUzNiAtXG4gICAgICAoNDg1MSAqIGUxMikgLyAxMDQ4NTc2KSAqXG4gICAgICBwaGkgLVxuICAgICAgKCgzICogZTIpIC8gOCArXG4gICAgICAgICgzICogZTQpIC8gMzIgK1xuICAgICAgICAoNDUgKiBlNikgLyAxMDI0ICtcbiAgICAgICAgKDEwNSAqIGU4KSAvIDQwOTYgK1xuICAgICAgICAoMjIwNSAqIGUxMCkgLyAxMzEwNzIgK1xuICAgICAgICAoNjIzNyAqIGUxMikgLyA1MjQyODgpICpcbiAgICAgICAgc2luMlBoaSArXG4gICAgICAoKDE1ICogZTQpIC8gMjU2ICtcbiAgICAgICAgKDQ1ICogZTYpIC8gMTAyNCArXG4gICAgICAgICg1MjUgKiBlOCkgLyAxNjM4NCArXG4gICAgICAgICgxNTc1ICogZTEwKSAvIDY1NTM2ICtcbiAgICAgICAgKDE1NTkyNSAqIGUxMikgLyA4Mzg4NjA4KSAqXG4gICAgICAgIHNpbjRQaGkgLVxuICAgICAgKCgzNSAqIGU2KSAvIDMwNzIgK1xuICAgICAgICAoMTc1ICogZTgpIC8gMTIyODggK1xuICAgICAgICAoMzY3NSAqIGUxMCkgLyAyNjIxNDQgK1xuICAgICAgICAoMTM0NzUgKiBlMTIpIC8gMTA0ODU3NikgKlxuICAgICAgICBzaW42UGhpICtcbiAgICAgICgoMzE1ICogZTgpIC8gMTMxMDcyICsgKDIyMDUgKiBlMTApIC8gNTI0Mjg4ICsgKDQzNjU5ICogZTEyKSAvIDgzODg2MDgpICpcbiAgICAgICAgc2luOFBoaSAtXG4gICAgICAoKDY5MyAqIGUxMCkgLyAxMzEwNzIwICsgKDYyMzcgKiBlMTIpIC8gNTI0Mjg4MCkgKiBzaW4xMFBoaSArXG4gICAgICAoKDEwMDEgKiBlMTIpIC8gODM4ODYwOCkgKiBzaW4xMlBoaSlcbiAgKTtcbn1cblxuZnVuY3Rpb24gY2FsY3VsYXRlSW52ZXJzZU0oTSwgZWxsaXB0aWNpdHksIG1ham9yKSB7XG4gIHZhciBkID0gTSAvIG1ham9yO1xuXG4gIGlmIChlbGxpcHRpY2l0eSA9PT0gMC4wKSB7XG4gICAgLy8gc3BoZXJlXG4gICAgcmV0dXJuIGQ7XG4gIH1cblxuICB2YXIgZDIgPSBkICogZDtcbiAgdmFyIGQzID0gZDIgKiBkO1xuICB2YXIgZDQgPSBkMyAqIGQ7XG4gIHZhciBlID0gZWxsaXB0aWNpdHk7XG4gIHZhciBlMiA9IGUgKiBlO1xuICB2YXIgZTQgPSBlMiAqIGUyO1xuICB2YXIgZTYgPSBlNCAqIGUyO1xuICB2YXIgZTggPSBlNiAqIGUyO1xuICB2YXIgZTEwID0gZTggKiBlMjtcbiAgdmFyIGUxMiA9IGUxMCAqIGUyO1xuICB2YXIgc2luMkQgPSBNYXRoLnNpbigyICogZCk7XG4gIHZhciBjb3MyRCA9IE1hdGguY29zKDIgKiBkKTtcbiAgdmFyIHNpbjREID0gTWF0aC5zaW4oNCAqIGQpO1xuICB2YXIgY29zNEQgPSBNYXRoLmNvcyg0ICogZCk7XG4gIHZhciBzaW42RCA9IE1hdGguc2luKDYgKiBkKTtcbiAgdmFyIGNvczZEID0gTWF0aC5jb3MoNiAqIGQpO1xuICB2YXIgc2luOEQgPSBNYXRoLnNpbig4ICogZCk7XG4gIHZhciBjb3M4RCA9IE1hdGguY29zKDggKiBkKTtcbiAgdmFyIHNpbjEwRCA9IE1hdGguc2luKDEwICogZCk7XG4gIHZhciBjb3MxMEQgPSBNYXRoLmNvcygxMCAqIGQpO1xuICB2YXIgc2luMTJEID0gTWF0aC5zaW4oMTIgKiBkKTtcblxuICByZXR1cm4gKFxuICAgIGQgK1xuICAgIChkICogZTIpIC8gNCArXG4gICAgKDcgKiBkICogZTQpIC8gNjQgK1xuICAgICgxNSAqIGQgKiBlNikgLyAyNTYgK1xuICAgICg1NzkgKiBkICogZTgpIC8gMTYzODQgK1xuICAgICgxNTE1ICogZCAqIGUxMCkgLyA2NTUzNiArXG4gICAgKDE2ODM3ICogZCAqIGUxMikgLyAxMDQ4NTc2ICtcbiAgICAoKDMgKiBkICogZTQpIC8gMTYgK1xuICAgICAgKDQ1ICogZCAqIGU2KSAvIDI1NiAtXG4gICAgICAoZCAqICgzMiAqIGQyIC0gNTYxKSAqIGU4KSAvIDQwOTYgLVxuICAgICAgKGQgKiAoMjMyICogZDIgLSAxNjc3KSAqIGUxMCkgLyAxNjM4NCArXG4gICAgICAoZCAqICgzOTk5ODUgLSA5MDU2MCAqIGQyICsgNTEyICogZDQpICogZTEyKSAvIDUyNDI4ODApICpcbiAgICAgIGNvczJEICtcbiAgICAoKDIxICogZCAqIGU2KSAvIDI1NiArXG4gICAgICAoNDgzICogZCAqIGU4KSAvIDQwOTYgLVxuICAgICAgKGQgKiAoMjI0ICogZDIgLSAxOTY5KSAqIGUxMCkgLyAxNjM4NCAtXG4gICAgICAoZCAqICgzMzE1MiAqIGQyIC0gMTEyNTk5KSAqIGUxMikgLyAxMDQ4NTc2KSAqXG4gICAgICBjb3M0RCArXG4gICAgKCgxNTEgKiBkICogZTgpIC8gNDA5NiArXG4gICAgICAoNDY4MSAqIGQgKiBlMTApIC8gNjU1MzYgK1xuICAgICAgKDE0NzkgKiBkICogZTEyKSAvIDE2Mzg0IC1cbiAgICAgICg0NTMgKiBkMyAqIGUxMikgLyAzMjc2OCkgKlxuICAgICAgY29zNkQgK1xuICAgICgoMTA5NyAqIGQgKiBlMTApIC8gNjU1MzYgKyAoNDI3ODMgKiBkICogZTEyKSAvIDEwNDg1NzYpICogY29zOEQgK1xuICAgICgoODAxMSAqIGQgKiBlMTIpIC8gMTA0ODU3NikgKiBjb3MxMEQgK1xuICAgICgoMyAqIGUyKSAvIDggK1xuICAgICAgKDMgKiBlNCkgLyAxNiArXG4gICAgICAoMjEzICogZTYpIC8gMjA0OCAtXG4gICAgICAoMyAqIGQyICogZTYpIC8gNjQgK1xuICAgICAgKDI1NSAqIGU4KSAvIDQwOTYgLVxuICAgICAgKDMzICogZDIgKiBlOCkgLyA1MTIgK1xuICAgICAgKDIwODYxICogZTEwKSAvIDUyNDI4OCAtXG4gICAgICAoMzMgKiBkMiAqIGUxMCkgLyA1MTIgK1xuICAgICAgKGQ0ICogZTEwKSAvIDEwMjQgK1xuICAgICAgKDI4MjczICogZTEyKSAvIDEwNDg1NzYgLVxuICAgICAgKDQ3MSAqIGQyICogZTEyKSAvIDgxOTIgK1xuICAgICAgKDkgKiBkNCAqIGUxMikgLyA0MDk2KSAqXG4gICAgICBzaW4yRCArXG4gICAgKCgyMSAqIGU0KSAvIDI1NiArXG4gICAgICAoMjEgKiBlNikgLyAyNTYgK1xuICAgICAgKDUzMyAqIGU4KSAvIDgxOTIgLVxuICAgICAgKDIxICogZDIgKiBlOCkgLyA1MTIgK1xuICAgICAgKDE5NyAqIGUxMCkgLyA0MDk2IC1cbiAgICAgICgzMTUgKiBkMiAqIGUxMCkgLyA0MDk2ICtcbiAgICAgICg1ODQwMzkgKiBlMTIpIC8gMTY3NzcyMTYgLVxuICAgICAgKDEyNTE3ICogZDIgKiBlMTIpIC8gMTMxMDcyICtcbiAgICAgICg3ICogZDQgKiBlMTIpIC8gMjA0OCkgKlxuICAgICAgc2luNEQgK1xuICAgICgoMTUxICogZTYpIC8gNjE0NCArXG4gICAgICAoMTUxICogZTgpIC8gNDA5NiArXG4gICAgICAoNTAxOSAqIGUxMCkgLyAxMzEwNzIgLVxuICAgICAgKDQ1MyAqIGQyICogZTEwKSAvIDE2Mzg0ICtcbiAgICAgICgyNjk2NSAqIGUxMikgLyA3ODY0MzIgLVxuICAgICAgKDg2MDcgKiBkMiAqIGUxMikgLyAxMzEwNzIpICpcbiAgICAgIHNpbjZEICtcbiAgICAoKDEwOTcgKiBlOCkgLyAxMzEwNzIgK1xuICAgICAgKDEwOTcgKiBlMTApIC8gNjU1MzYgK1xuICAgICAgKDIyNTc5NyAqIGUxMikgLyAxMDQ4NTc2MCAtXG4gICAgICAoMTA5NyAqIGQyICogZTEyKSAvIDY1NTM2KSAqXG4gICAgICBzaW44RCArXG4gICAgKCg4MDExICogZTEwKSAvIDI2MjE0NDAgKyAoODAxMSAqIGUxMikgLyAxMDQ4NTc2KSAqIHNpbjEwRCArXG4gICAgKCgyOTMzOTMgKiBlMTIpIC8gMjUxNjU4MjQwKSAqIHNpbjEyRFxuICApO1xufVxuXG5mdW5jdGlvbiBjYWxjdWxhdGVTaWdtYShlbGxpcHRpY2l0eSwgbGF0aXR1ZGUpIHtcbiAgaWYgKGVsbGlwdGljaXR5ID09PSAwLjApIHtcbiAgICAvLyBzcGhlcmVcbiAgICByZXR1cm4gTWF0aC5sb2coTWF0aC50YW4oMC41ICogKENlc2l1bU1hdGguUElfT1ZFUl9UV08gKyBsYXRpdHVkZSkpKTtcbiAgfVxuXG4gIHZhciBlU2luTCA9IGVsbGlwdGljaXR5ICogTWF0aC5zaW4obGF0aXR1ZGUpO1xuICByZXR1cm4gKFxuICAgIE1hdGgubG9nKE1hdGgudGFuKDAuNSAqIChDZXNpdW1NYXRoLlBJX09WRVJfVFdPICsgbGF0aXR1ZGUpKSkgLVxuICAgIChlbGxpcHRpY2l0eSAvIDIuMCkgKiBNYXRoLmxvZygoMSArIGVTaW5MKSAvICgxIC0gZVNpbkwpKVxuICApO1xufVxuXG5mdW5jdGlvbiBjYWxjdWxhdGVIZWFkaW5nKFxuICBlbGxpcHNvaWRSaHVtYkxpbmUsXG4gIGZpcnN0TG9uZ2l0dWRlLFxuICBmaXJzdExhdGl0dWRlLFxuICBzZWNvbmRMb25naXR1ZGUsXG4gIHNlY29uZExhdGl0dWRlXG4pIHtcbiAgdmFyIHNpZ21hMSA9IGNhbGN1bGF0ZVNpZ21hKGVsbGlwc29pZFJodW1iTGluZS5fZWxsaXB0aWNpdHksIGZpcnN0TGF0aXR1ZGUpO1xuICB2YXIgc2lnbWEyID0gY2FsY3VsYXRlU2lnbWEoZWxsaXBzb2lkUmh1bWJMaW5lLl9lbGxpcHRpY2l0eSwgc2Vjb25kTGF0aXR1ZGUpO1xuICByZXR1cm4gTWF0aC5hdGFuMihcbiAgICBDZXNpdW1NYXRoLm5lZ2F0aXZlUGlUb1BpKHNlY29uZExvbmdpdHVkZSAtIGZpcnN0TG9uZ2l0dWRlKSxcbiAgICBzaWdtYTIgLSBzaWdtYTFcbiAgKTtcbn1cblxuZnVuY3Rpb24gY2FsY3VsYXRlQXJjTGVuZ3RoKFxuICBlbGxpcHNvaWRSaHVtYkxpbmUsXG4gIG1ham9yLFxuICBtaW5vcixcbiAgZmlyc3RMb25naXR1ZGUsXG4gIGZpcnN0TGF0aXR1ZGUsXG4gIHNlY29uZExvbmdpdHVkZSxcbiAgc2Vjb25kTGF0aXR1ZGVcbikge1xuICB2YXIgaGVhZGluZyA9IGVsbGlwc29pZFJodW1iTGluZS5faGVhZGluZztcbiAgdmFyIGRlbHRhTG9uZ2l0dWRlID0gc2Vjb25kTG9uZ2l0dWRlIC0gZmlyc3RMb25naXR1ZGU7XG5cbiAgdmFyIGRpc3RhbmNlID0gMC4wO1xuXG4gIC8vQ2hlY2sgdG8gc2VlIGlmIHRoZSByaHVtYiBsaW5lIGhhcyBjb25zdGFudCBsYXRpdHVkZVxuICAvL1RoaXMgZXF1YXRpb24gd2lsbCBkaXZlcmdlIGlmIGhlYWRpbmcgZ2V0cyBjbG9zZSB0byA5MCBkZWdyZWVzXG4gIGlmIChcbiAgICBDZXNpdW1NYXRoLmVxdWFsc0Vwc2lsb24oXG4gICAgICBNYXRoLmFicyhoZWFkaW5nKSxcbiAgICAgIENlc2l1bU1hdGguUElfT1ZFUl9UV08sXG4gICAgICBDZXNpdW1NYXRoLkVQU0lMT044XG4gICAgKVxuICApIHtcbiAgICAvL0lmIGhlYWRpbmcgaXMgY2xvc2UgdG8gOTAgZGVncmVlc1xuICAgIGlmIChtYWpvciA9PT0gbWlub3IpIHtcbiAgICAgIGRpc3RhbmNlID1cbiAgICAgICAgbWFqb3IgKlxuICAgICAgICBNYXRoLmNvcyhmaXJzdExhdGl0dWRlKSAqXG4gICAgICAgIENlc2l1bU1hdGgubmVnYXRpdmVQaVRvUGkoZGVsdGFMb25naXR1ZGUpO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgc2luUGhpID0gTWF0aC5zaW4oZmlyc3RMYXRpdHVkZSk7XG4gICAgICBkaXN0YW5jZSA9XG4gICAgICAgIChtYWpvciAqXG4gICAgICAgICAgTWF0aC5jb3MoZmlyc3RMYXRpdHVkZSkgKlxuICAgICAgICAgIENlc2l1bU1hdGgubmVnYXRpdmVQaVRvUGkoZGVsdGFMb25naXR1ZGUpKSAvXG4gICAgICAgIE1hdGguc3FydCgxIC0gZWxsaXBzb2lkUmh1bWJMaW5lLl9lbGxpcHRpY2l0eVNxdWFyZWQgKiBzaW5QaGkgKiBzaW5QaGkpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB2YXIgTTEgPSBjYWxjdWxhdGVNKGVsbGlwc29pZFJodW1iTGluZS5fZWxsaXB0aWNpdHksIG1ham9yLCBmaXJzdExhdGl0dWRlKTtcbiAgICB2YXIgTTIgPSBjYWxjdWxhdGVNKGVsbGlwc29pZFJodW1iTGluZS5fZWxsaXB0aWNpdHksIG1ham9yLCBzZWNvbmRMYXRpdHVkZSk7XG5cbiAgICBkaXN0YW5jZSA9IChNMiAtIE0xKSAvIE1hdGguY29zKGhlYWRpbmcpO1xuICB9XG4gIHJldHVybiBNYXRoLmFicyhkaXN0YW5jZSk7XG59XG5cbnZhciBzY3JhdGNoQ2FydDEgPSBuZXcgQ2FydGVzaWFuMygpO1xudmFyIHNjcmF0Y2hDYXJ0MiA9IG5ldyBDYXJ0ZXNpYW4zKCk7XG5cbmZ1bmN0aW9uIGNvbXB1dGVQcm9wZXJ0aWVzKGVsbGlwc29pZFJodW1iTGluZSwgc3RhcnQsIGVuZCwgZWxsaXBzb2lkKSB7XG4gIHZhciBmaXJzdENhcnRlc2lhbiA9IENhcnRlc2lhbjMubm9ybWFsaXplKFxuICAgIGVsbGlwc29pZC5jYXJ0b2dyYXBoaWNUb0NhcnRlc2lhbihzdGFydCwgc2NyYXRjaENhcnQyKSxcbiAgICBzY3JhdGNoQ2FydDFcbiAgKTtcbiAgdmFyIGxhc3RDYXJ0ZXNpYW4gPSBDYXJ0ZXNpYW4zLm5vcm1hbGl6ZShcbiAgICBlbGxpcHNvaWQuY2FydG9ncmFwaGljVG9DYXJ0ZXNpYW4oZW5kLCBzY3JhdGNoQ2FydDIpLFxuICAgIHNjcmF0Y2hDYXJ0MlxuICApO1xuXG4gIC8vPj5pbmNsdWRlU3RhcnQoJ2RlYnVnJywgcHJhZ21hcy5kZWJ1Zyk7XG4gIENoZWNrLnR5cGVPZi5udW1iZXIuZ3JlYXRlclRoYW5PckVxdWFscyhcbiAgICBcInZhbHVlXCIsXG4gICAgTWF0aC5hYnMoXG4gICAgICBNYXRoLmFicyhDYXJ0ZXNpYW4zLmFuZ2xlQmV0d2VlbihmaXJzdENhcnRlc2lhbiwgbGFzdENhcnRlc2lhbikpIC0gTWF0aC5QSVxuICAgICksXG4gICAgMC4wMTI1XG4gICk7XG4gIC8vPj5pbmNsdWRlRW5kKCdkZWJ1ZycpO1xuXG4gIHZhciBtYWpvciA9IGVsbGlwc29pZC5tYXhpbXVtUmFkaXVzO1xuICB2YXIgbWlub3IgPSBlbGxpcHNvaWQubWluaW11bVJhZGl1cztcbiAgdmFyIG1ham9yU3F1YXJlZCA9IG1ham9yICogbWFqb3I7XG4gIHZhciBtaW5vclNxdWFyZWQgPSBtaW5vciAqIG1pbm9yO1xuICBlbGxpcHNvaWRSaHVtYkxpbmUuX2VsbGlwdGljaXR5U3F1YXJlZCA9XG4gICAgKG1ham9yU3F1YXJlZCAtIG1pbm9yU3F1YXJlZCkgLyBtYWpvclNxdWFyZWQ7XG4gIGVsbGlwc29pZFJodW1iTGluZS5fZWxsaXB0aWNpdHkgPSBNYXRoLnNxcnQoXG4gICAgZWxsaXBzb2lkUmh1bWJMaW5lLl9lbGxpcHRpY2l0eVNxdWFyZWRcbiAgKTtcblxuICBlbGxpcHNvaWRSaHVtYkxpbmUuX3N0YXJ0ID0gQ2FydG9ncmFwaGljLmNsb25lKFxuICAgIHN0YXJ0LFxuICAgIGVsbGlwc29pZFJodW1iTGluZS5fc3RhcnRcbiAgKTtcbiAgZWxsaXBzb2lkUmh1bWJMaW5lLl9zdGFydC5oZWlnaHQgPSAwO1xuXG4gIGVsbGlwc29pZFJodW1iTGluZS5fZW5kID0gQ2FydG9ncmFwaGljLmNsb25lKGVuZCwgZWxsaXBzb2lkUmh1bWJMaW5lLl9lbmQpO1xuICBlbGxpcHNvaWRSaHVtYkxpbmUuX2VuZC5oZWlnaHQgPSAwO1xuXG4gIGVsbGlwc29pZFJodW1iTGluZS5faGVhZGluZyA9IGNhbGN1bGF0ZUhlYWRpbmcoXG4gICAgZWxsaXBzb2lkUmh1bWJMaW5lLFxuICAgIHN0YXJ0LmxvbmdpdHVkZSxcbiAgICBzdGFydC5sYXRpdHVkZSxcbiAgICBlbmQubG9uZ2l0dWRlLFxuICAgIGVuZC5sYXRpdHVkZVxuICApO1xuICBlbGxpcHNvaWRSaHVtYkxpbmUuX2Rpc3RhbmNlID0gY2FsY3VsYXRlQXJjTGVuZ3RoKFxuICAgIGVsbGlwc29pZFJodW1iTGluZSxcbiAgICBlbGxpcHNvaWQubWF4aW11bVJhZGl1cyxcbiAgICBlbGxpcHNvaWQubWluaW11bVJhZGl1cyxcbiAgICBzdGFydC5sb25naXR1ZGUsXG4gICAgc3RhcnQubGF0aXR1ZGUsXG4gICAgZW5kLmxvbmdpdHVkZSxcbiAgICBlbmQubGF0aXR1ZGVcbiAgKTtcbn1cblxuZnVuY3Rpb24gaW50ZXJwb2xhdGVVc2luZ1N1cmZhY2VEaXN0YW5jZShcbiAgc3RhcnQsXG4gIGhlYWRpbmcsXG4gIGRpc3RhbmNlLFxuICBtYWpvcixcbiAgZWxsaXB0aWNpdHksXG4gIHJlc3VsdFxuKSB7XG4gIGlmIChkaXN0YW5jZSA9PT0gMC4wKSB7XG4gICAgcmV0dXJuIENhcnRvZ3JhcGhpYy5jbG9uZShzdGFydCwgcmVzdWx0KTtcbiAgfVxuXG4gIHZhciBlbGxpcHRpY2l0eVNxdWFyZWQgPSBlbGxpcHRpY2l0eSAqIGVsbGlwdGljaXR5O1xuXG4gIHZhciBsb25naXR1ZGU7XG4gIHZhciBsYXRpdHVkZTtcbiAgdmFyIGRlbHRhTG9uZ2l0dWRlO1xuXG4gIC8vQ2hlY2sgdG8gc2VlIGlmIHRoZSByaHVtYiBsaW5lIGhhcyBjb25zdGFudCBsYXRpdHVkZVxuICAvL1RoaXMgd29uJ3QgY29udmVyZ2UgaWYgaGVhZGluZyBpcyBjbG9zZSB0byA5MCBkZWdyZWVzXG4gIGlmIChcbiAgICBNYXRoLmFicyhDZXNpdW1NYXRoLlBJX09WRVJfVFdPIC0gTWF0aC5hYnMoaGVhZGluZykpID4gQ2VzaXVtTWF0aC5FUFNJTE9OOFxuICApIHtcbiAgICAvL0NhbGN1bGF0ZSBsYXRpdHVkZSBvZiB0aGUgc2Vjb25kIHBvaW50XG4gICAgdmFyIE0xID0gY2FsY3VsYXRlTShlbGxpcHRpY2l0eSwgbWFqb3IsIHN0YXJ0LmxhdGl0dWRlKTtcbiAgICB2YXIgZGVsdGFNID0gZGlzdGFuY2UgKiBNYXRoLmNvcyhoZWFkaW5nKTtcbiAgICB2YXIgTTIgPSBNMSArIGRlbHRhTTtcbiAgICBsYXRpdHVkZSA9IGNhbGN1bGF0ZUludmVyc2VNKE0yLCBlbGxpcHRpY2l0eSwgbWFqb3IpO1xuXG4gICAgLy9Ob3cgZmluZCB0aGUgbG9uZ2l0dWRlIG9mIHRoZSBzZWNvbmQgcG9pbnRcbiAgICB2YXIgc2lnbWExID0gY2FsY3VsYXRlU2lnbWEoZWxsaXB0aWNpdHksIHN0YXJ0LmxhdGl0dWRlKTtcbiAgICB2YXIgc2lnbWEyID0gY2FsY3VsYXRlU2lnbWEoZWxsaXB0aWNpdHksIGxhdGl0dWRlKTtcbiAgICBkZWx0YUxvbmdpdHVkZSA9IE1hdGgudGFuKGhlYWRpbmcpICogKHNpZ21hMiAtIHNpZ21hMSk7XG4gICAgbG9uZ2l0dWRlID0gQ2VzaXVtTWF0aC5uZWdhdGl2ZVBpVG9QaShzdGFydC5sb25naXR1ZGUgKyBkZWx0YUxvbmdpdHVkZSk7XG4gIH0gZWxzZSB7XG4gICAgLy9JZiBoZWFkaW5nIGlzIGNsb3NlIHRvIDkwIGRlZ3JlZXNcbiAgICBsYXRpdHVkZSA9IHN0YXJ0LmxhdGl0dWRlO1xuICAgIHZhciBsb2NhbFJhZDtcblxuICAgIGlmIChlbGxpcHRpY2l0eSA9PT0gMC4wKSB7XG4gICAgICAvLyBzcGhlcmVcbiAgICAgIGxvY2FsUmFkID0gbWFqb3IgKiBNYXRoLmNvcyhzdGFydC5sYXRpdHVkZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBzaW5QaGkgPSBNYXRoLnNpbihzdGFydC5sYXRpdHVkZSk7XG4gICAgICBsb2NhbFJhZCA9XG4gICAgICAgIChtYWpvciAqIE1hdGguY29zKHN0YXJ0LmxhdGl0dWRlKSkgL1xuICAgICAgICBNYXRoLnNxcnQoMSAtIGVsbGlwdGljaXR5U3F1YXJlZCAqIHNpblBoaSAqIHNpblBoaSk7XG4gICAgfVxuXG4gICAgZGVsdGFMb25naXR1ZGUgPSBkaXN0YW5jZSAvIGxvY2FsUmFkO1xuICAgIGlmIChoZWFkaW5nID4gMC4wKSB7XG4gICAgICBsb25naXR1ZGUgPSBDZXNpdW1NYXRoLm5lZ2F0aXZlUGlUb1BpKHN0YXJ0LmxvbmdpdHVkZSArIGRlbHRhTG9uZ2l0dWRlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbG9uZ2l0dWRlID0gQ2VzaXVtTWF0aC5uZWdhdGl2ZVBpVG9QaShzdGFydC5sb25naXR1ZGUgLSBkZWx0YUxvbmdpdHVkZSk7XG4gICAgfVxuICB9XG5cbiAgaWYgKGRlZmluZWQocmVzdWx0KSkge1xuICAgIHJlc3VsdC5sb25naXR1ZGUgPSBsb25naXR1ZGU7XG4gICAgcmVzdWx0LmxhdGl0dWRlID0gbGF0aXR1ZGU7XG4gICAgcmVzdWx0LmhlaWdodCA9IDA7XG5cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgcmV0dXJuIG5ldyBDYXJ0b2dyYXBoaWMobG9uZ2l0dWRlLCBsYXRpdHVkZSwgMCk7XG59XG5cbi8qKlxuICogSW5pdGlhbGl6ZXMgYSByaHVtYiBsaW5lIG9uIHRoZSBlbGxpcHNvaWQgY29ubmVjdGluZyB0aGUgdHdvIHByb3ZpZGVkIHBsYW5ldG9kZXRpYyBwb2ludHMuXG4gKlxuICogQGFsaWFzIEVsbGlwc29pZFJodW1iTGluZVxuICogQGNvbnN0cnVjdG9yXG4gKlxuICogQHBhcmFtIHtDYXJ0b2dyYXBoaWN9IFtzdGFydF0gVGhlIGluaXRpYWwgcGxhbmV0b2RldGljIHBvaW50IG9uIHRoZSBwYXRoLlxuICogQHBhcmFtIHtDYXJ0b2dyYXBoaWN9IFtlbmRdIFRoZSBmaW5hbCBwbGFuZXRvZGV0aWMgcG9pbnQgb24gdGhlIHBhdGguXG4gKiBAcGFyYW0ge0VsbGlwc29pZH0gW2VsbGlwc29pZD1FbGxpcHNvaWQuV0dTODRdIFRoZSBlbGxpcHNvaWQgb24gd2hpY2ggdGhlIHJodW1iIGxpbmUgbGllcy5cbiAqXG4gKiBAZXhjZXB0aW9uIHtEZXZlbG9wZXJFcnJvcn0gYW5nbGUgYmV0d2VlbiBzdGFydCBhbmQgZW5kIG11c3QgYmUgYXQgbGVhc3QgMC4wMTI1IHJhZGlhbnMuXG4gKi9cbmZ1bmN0aW9uIEVsbGlwc29pZFJodW1iTGluZShzdGFydCwgZW5kLCBlbGxpcHNvaWQpIHtcbiAgdmFyIGUgPSBkZWZhdWx0VmFsdWUoZWxsaXBzb2lkLCBFbGxpcHNvaWQuV0dTODQpO1xuICB0aGlzLl9lbGxpcHNvaWQgPSBlO1xuICB0aGlzLl9zdGFydCA9IG5ldyBDYXJ0b2dyYXBoaWMoKTtcbiAgdGhpcy5fZW5kID0gbmV3IENhcnRvZ3JhcGhpYygpO1xuXG4gIHRoaXMuX2hlYWRpbmcgPSB1bmRlZmluZWQ7XG4gIHRoaXMuX2Rpc3RhbmNlID0gdW5kZWZpbmVkO1xuICB0aGlzLl9lbGxpcHRpY2l0eSA9IHVuZGVmaW5lZDtcbiAgdGhpcy5fZWxsaXB0aWNpdHlTcXVhcmVkID0gdW5kZWZpbmVkO1xuXG4gIGlmIChkZWZpbmVkKHN0YXJ0KSAmJiBkZWZpbmVkKGVuZCkpIHtcbiAgICBjb21wdXRlUHJvcGVydGllcyh0aGlzLCBzdGFydCwgZW5kLCBlKTtcbiAgfVxufVxuXG5PYmplY3QuZGVmaW5lUHJvcGVydGllcyhFbGxpcHNvaWRSaHVtYkxpbmUucHJvdG90eXBlLCB7XG4gIC8qKlxuICAgKiBHZXRzIHRoZSBlbGxpcHNvaWQuXG4gICAqIEBtZW1iZXJvZiBFbGxpcHNvaWRSaHVtYkxpbmUucHJvdG90eXBlXG4gICAqIEB0eXBlIHtFbGxpcHNvaWR9XG4gICAqIEByZWFkb25seVxuICAgKi9cbiAgZWxsaXBzb2lkOiB7XG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fZWxsaXBzb2lkO1xuICAgIH0sXG4gIH0sXG5cbiAgLyoqXG4gICAqIEdldHMgdGhlIHN1cmZhY2UgZGlzdGFuY2UgYmV0d2VlbiB0aGUgc3RhcnQgYW5kIGVuZCBwb2ludFxuICAgKiBAbWVtYmVyb2YgRWxsaXBzb2lkUmh1bWJMaW5lLnByb3RvdHlwZVxuICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgKiBAcmVhZG9ubHlcbiAgICovXG4gIHN1cmZhY2VEaXN0YW5jZToge1xuICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgLy8+PmluY2x1ZGVTdGFydCgnZGVidWcnLCBwcmFnbWFzLmRlYnVnKTtcbiAgICAgIENoZWNrLmRlZmluZWQoXCJkaXN0YW5jZVwiLCB0aGlzLl9kaXN0YW5jZSk7XG4gICAgICAvLz4+aW5jbHVkZUVuZCgnZGVidWcnKTtcblxuICAgICAgcmV0dXJuIHRoaXMuX2Rpc3RhbmNlO1xuICAgIH0sXG4gIH0sXG5cbiAgLyoqXG4gICAqIEdldHMgdGhlIGluaXRpYWwgcGxhbmV0b2RldGljIHBvaW50IG9uIHRoZSBwYXRoLlxuICAgKiBAbWVtYmVyb2YgRWxsaXBzb2lkUmh1bWJMaW5lLnByb3RvdHlwZVxuICAgKiBAdHlwZSB7Q2FydG9ncmFwaGljfVxuICAgKiBAcmVhZG9ubHlcbiAgICovXG4gIHN0YXJ0OiB7XG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fc3RhcnQ7XG4gICAgfSxcbiAgfSxcblxuICAvKipcbiAgICogR2V0cyB0aGUgZmluYWwgcGxhbmV0b2RldGljIHBvaW50IG9uIHRoZSBwYXRoLlxuICAgKiBAbWVtYmVyb2YgRWxsaXBzb2lkUmh1bWJMaW5lLnByb3RvdHlwZVxuICAgKiBAdHlwZSB7Q2FydG9ncmFwaGljfVxuICAgKiBAcmVhZG9ubHlcbiAgICovXG4gIGVuZDoge1xuICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX2VuZDtcbiAgICB9LFxuICB9LFxuXG4gIC8qKlxuICAgKiBHZXRzIHRoZSBoZWFkaW5nIGZyb20gdGhlIHN0YXJ0IHBvaW50IHRvIHRoZSBlbmQgcG9pbnQuXG4gICAqIEBtZW1iZXJvZiBFbGxpcHNvaWRSaHVtYkxpbmUucHJvdG90eXBlXG4gICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAqIEByZWFkb25seVxuICAgKi9cbiAgaGVhZGluZzoge1xuICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgLy8+PmluY2x1ZGVTdGFydCgnZGVidWcnLCBwcmFnbWFzLmRlYnVnKTtcbiAgICAgIENoZWNrLmRlZmluZWQoXCJkaXN0YW5jZVwiLCB0aGlzLl9kaXN0YW5jZSk7XG4gICAgICAvLz4+aW5jbHVkZUVuZCgnZGVidWcnKTtcblxuICAgICAgcmV0dXJuIHRoaXMuX2hlYWRpbmc7XG4gICAgfSxcbiAgfSxcbn0pO1xuXG4vKipcbiAqIENyZWF0ZSBhIHJodW1iIGxpbmUgdXNpbmcgYW4gaW5pdGlhbCBwb3NpdGlvbiB3aXRoIGEgaGVhZGluZyBhbmQgZGlzdGFuY2UuXG4gKlxuICogQHBhcmFtIHtDYXJ0b2dyYXBoaWN9IHN0YXJ0IFRoZSBpbml0aWFsIHBsYW5ldG9kZXRpYyBwb2ludCBvbiB0aGUgcGF0aC5cbiAqIEBwYXJhbSB7TnVtYmVyfSBoZWFkaW5nIFRoZSBoZWFkaW5nIGluIHJhZGlhbnMuXG4gKiBAcGFyYW0ge051bWJlcn0gZGlzdGFuY2UgVGhlIHJodW1iIGxpbmUgZGlzdGFuY2UgYmV0d2VlbiB0aGUgc3RhcnQgYW5kIGVuZCBwb2ludC5cbiAqIEBwYXJhbSB7RWxsaXBzb2lkfSBbZWxsaXBzb2lkPUVsbGlwc29pZC5XR1M4NF0gVGhlIGVsbGlwc29pZCBvbiB3aGljaCB0aGUgcmh1bWIgbGluZSBsaWVzLlxuICogQHBhcmFtIHtFbGxpcHNvaWRSaHVtYkxpbmV9IFtyZXN1bHRdIFRoZSBvYmplY3QgaW4gd2hpY2ggdG8gc3RvcmUgdGhlIHJlc3VsdC5cbiAqIEByZXR1cm5zIHtFbGxpcHNvaWRSaHVtYkxpbmV9IFRoZSBFbGxpcHNvaWRSaHVtYkxpbmUgb2JqZWN0LlxuICovXG5FbGxpcHNvaWRSaHVtYkxpbmUuZnJvbVN0YXJ0SGVhZGluZ0Rpc3RhbmNlID0gZnVuY3Rpb24gKFxuICBzdGFydCxcbiAgaGVhZGluZyxcbiAgZGlzdGFuY2UsXG4gIGVsbGlwc29pZCxcbiAgcmVzdWx0XG4pIHtcbiAgLy8+PmluY2x1ZGVTdGFydCgnZGVidWcnLCBwcmFnbWFzLmRlYnVnKTtcbiAgQ2hlY2suZGVmaW5lZChcInN0YXJ0XCIsIHN0YXJ0KTtcbiAgQ2hlY2suZGVmaW5lZChcImhlYWRpbmdcIiwgaGVhZGluZyk7XG4gIENoZWNrLmRlZmluZWQoXCJkaXN0YW5jZVwiLCBkaXN0YW5jZSk7XG4gIENoZWNrLnR5cGVPZi5udW1iZXIuZ3JlYXRlclRoYW4oXCJkaXN0YW5jZVwiLCBkaXN0YW5jZSwgMC4wKTtcbiAgLy8+PmluY2x1ZGVFbmQoJ2RlYnVnJyk7XG5cbiAgdmFyIGUgPSBkZWZhdWx0VmFsdWUoZWxsaXBzb2lkLCBFbGxpcHNvaWQuV0dTODQpO1xuICB2YXIgbWFqb3IgPSBlLm1heGltdW1SYWRpdXM7XG4gIHZhciBtaW5vciA9IGUubWluaW11bVJhZGl1cztcbiAgdmFyIG1ham9yU3F1YXJlZCA9IG1ham9yICogbWFqb3I7XG4gIHZhciBtaW5vclNxdWFyZWQgPSBtaW5vciAqIG1pbm9yO1xuICB2YXIgZWxsaXB0aWNpdHkgPSBNYXRoLnNxcnQoKG1ham9yU3F1YXJlZCAtIG1pbm9yU3F1YXJlZCkgLyBtYWpvclNxdWFyZWQpO1xuXG4gIGhlYWRpbmcgPSBDZXNpdW1NYXRoLm5lZ2F0aXZlUGlUb1BpKGhlYWRpbmcpO1xuICB2YXIgZW5kID0gaW50ZXJwb2xhdGVVc2luZ1N1cmZhY2VEaXN0YW5jZShcbiAgICBzdGFydCxcbiAgICBoZWFkaW5nLFxuICAgIGRpc3RhbmNlLFxuICAgIGUubWF4aW11bVJhZGl1cyxcbiAgICBlbGxpcHRpY2l0eVxuICApO1xuXG4gIGlmIChcbiAgICAhZGVmaW5lZChyZXN1bHQpIHx8XG4gICAgKGRlZmluZWQoZWxsaXBzb2lkKSAmJiAhZWxsaXBzb2lkLmVxdWFscyhyZXN1bHQuZWxsaXBzb2lkKSlcbiAgKSB7XG4gICAgcmV0dXJuIG5ldyBFbGxpcHNvaWRSaHVtYkxpbmUoc3RhcnQsIGVuZCwgZSk7XG4gIH1cblxuICByZXN1bHQuc2V0RW5kUG9pbnRzKHN0YXJ0LCBlbmQpO1xuICByZXR1cm4gcmVzdWx0O1xufTtcblxuLyoqXG4gKiBTZXRzIHRoZSBzdGFydCBhbmQgZW5kIHBvaW50cyBvZiB0aGUgcmh1bWIgbGluZS5cbiAqXG4gKiBAcGFyYW0ge0NhcnRvZ3JhcGhpY30gc3RhcnQgVGhlIGluaXRpYWwgcGxhbmV0b2RldGljIHBvaW50IG9uIHRoZSBwYXRoLlxuICogQHBhcmFtIHtDYXJ0b2dyYXBoaWN9IGVuZCBUaGUgZmluYWwgcGxhbmV0b2RldGljIHBvaW50IG9uIHRoZSBwYXRoLlxuICovXG5FbGxpcHNvaWRSaHVtYkxpbmUucHJvdG90eXBlLnNldEVuZFBvaW50cyA9IGZ1bmN0aW9uIChzdGFydCwgZW5kKSB7XG4gIC8vPj5pbmNsdWRlU3RhcnQoJ2RlYnVnJywgcHJhZ21hcy5kZWJ1Zyk7XG4gIENoZWNrLmRlZmluZWQoXCJzdGFydFwiLCBzdGFydCk7XG4gIENoZWNrLmRlZmluZWQoXCJlbmRcIiwgZW5kKTtcbiAgLy8+PmluY2x1ZGVFbmQoJ2RlYnVnJyk7XG5cbiAgY29tcHV0ZVByb3BlcnRpZXModGhpcywgc3RhcnQsIGVuZCwgdGhpcy5fZWxsaXBzb2lkKTtcbn07XG5cbi8qKlxuICogUHJvdmlkZXMgdGhlIGxvY2F0aW9uIG9mIGEgcG9pbnQgYXQgdGhlIGluZGljYXRlZCBwb3J0aW9uIGFsb25nIHRoZSByaHVtYiBsaW5lLlxuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSBmcmFjdGlvbiBUaGUgcG9ydGlvbiBvZiB0aGUgZGlzdGFuY2UgYmV0d2VlbiB0aGUgaW5pdGlhbCBhbmQgZmluYWwgcG9pbnRzLlxuICogQHBhcmFtIHtDYXJ0b2dyYXBoaWN9IFtyZXN1bHRdIFRoZSBvYmplY3QgaW4gd2hpY2ggdG8gc3RvcmUgdGhlIHJlc3VsdC5cbiAqIEByZXR1cm5zIHtDYXJ0b2dyYXBoaWN9IFRoZSBsb2NhdGlvbiBvZiB0aGUgcG9pbnQgYWxvbmcgdGhlIHJodW1iIGxpbmUuXG4gKi9cbkVsbGlwc29pZFJodW1iTGluZS5wcm90b3R5cGUuaW50ZXJwb2xhdGVVc2luZ0ZyYWN0aW9uID0gZnVuY3Rpb24gKFxuICBmcmFjdGlvbixcbiAgcmVzdWx0XG4pIHtcbiAgcmV0dXJuIHRoaXMuaW50ZXJwb2xhdGVVc2luZ1N1cmZhY2VEaXN0YW5jZShcbiAgICBmcmFjdGlvbiAqIHRoaXMuX2Rpc3RhbmNlLFxuICAgIHJlc3VsdFxuICApO1xufTtcblxuLyoqXG4gKiBQcm92aWRlcyB0aGUgbG9jYXRpb24gb2YgYSBwb2ludCBhdCB0aGUgaW5kaWNhdGVkIGRpc3RhbmNlIGFsb25nIHRoZSByaHVtYiBsaW5lLlxuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSBkaXN0YW5jZSBUaGUgZGlzdGFuY2UgZnJvbSB0aGUgaW5pdGFsIHBvaW50IHRvIHRoZSBwb2ludCBvZiBpbnRlcmVzdCBhbG9uZyB0aGUgcmh1bWJMaW5lLlxuICogQHBhcmFtIHtDYXJ0b2dyYXBoaWN9IFtyZXN1bHRdIFRoZSBvYmplY3QgaW4gd2hpY2ggdG8gc3RvcmUgdGhlIHJlc3VsdC5cbiAqIEByZXR1cm5zIHtDYXJ0b2dyYXBoaWN9IFRoZSBsb2NhdGlvbiBvZiB0aGUgcG9pbnQgYWxvbmcgdGhlIHJodW1iIGxpbmUuXG4gKlxuICogQGV4Y2VwdGlvbiB7RGV2ZWxvcGVyRXJyb3J9IHN0YXJ0IGFuZCBlbmQgbXVzdCBiZSBzZXQgYmVmb3JlIGNhbGxpbmcgZnVuY3Rpb24gaW50ZXJwb2xhdGVVc2luZ1N1cmZhY2VEaXN0YW5jZVxuICovXG5FbGxpcHNvaWRSaHVtYkxpbmUucHJvdG90eXBlLmludGVycG9sYXRlVXNpbmdTdXJmYWNlRGlzdGFuY2UgPSBmdW5jdGlvbiAoXG4gIGRpc3RhbmNlLFxuICByZXN1bHRcbikge1xuICAvLz4+aW5jbHVkZVN0YXJ0KCdkZWJ1ZycsIHByYWdtYXMuZGVidWcpO1xuICBDaGVjay50eXBlT2YubnVtYmVyKFwiZGlzdGFuY2VcIiwgZGlzdGFuY2UpO1xuICBpZiAoIWRlZmluZWQodGhpcy5fZGlzdGFuY2UpIHx8IHRoaXMuX2Rpc3RhbmNlID09PSAwLjApIHtcbiAgICB0aHJvdyBuZXcgRGV2ZWxvcGVyRXJyb3IoXG4gICAgICBcIkVsbGlwc29pZFJodW1iTGluZSBtdXN0IGhhdmUgZGlzdGluY3Qgc3RhcnQgYW5kIGVuZCBzZXQuXCJcbiAgICApO1xuICB9XG4gIC8vPj5pbmNsdWRlRW5kKCdkZWJ1ZycpO1xuXG4gIHJldHVybiBpbnRlcnBvbGF0ZVVzaW5nU3VyZmFjZURpc3RhbmNlKFxuICAgIHRoaXMuX3N0YXJ0LFxuICAgIHRoaXMuX2hlYWRpbmcsXG4gICAgZGlzdGFuY2UsXG4gICAgdGhpcy5fZWxsaXBzb2lkLm1heGltdW1SYWRpdXMsXG4gICAgdGhpcy5fZWxsaXB0aWNpdHksXG4gICAgcmVzdWx0XG4gICk7XG59O1xuXG4vKipcbiAqIFByb3ZpZGVzIHRoZSBsb2NhdGlvbiBvZiBhIHBvaW50IGF0IHRoZSBpbmRpY2F0ZWQgbG9uZ2l0dWRlIGFsb25nIHRoZSByaHVtYiBsaW5lLlxuICogSWYgdGhlIGxvbmdpdHVkZSBpcyBvdXRzaWRlIHRoZSByYW5nZSBvZiBzdGFydCBhbmQgZW5kIHBvaW50cywgdGhlIGZpcnN0IGludGVyc2VjdGlvbiB3aXRoIHRoZSBsb25naXR1ZGUgZnJvbSB0aGUgc3RhcnQgcG9pbnQgaW4gdGhlIGRpcmVjdGlvbiBvZiB0aGUgaGVhZGluZyBpcyByZXR1cm5lZC4gVGhpcyBmb2xsb3dzIHRoZSBzcGlyYWwgcHJvcGVydHkgb2YgYSByaHVtYiBsaW5lLlxuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSBpbnRlcnNlY3Rpb25Mb25naXR1ZGUgVGhlIGxvbmdpdHVkZSwgaW4gcmFkaWFucywgYXQgd2hpY2ggdG8gZmluZCB0aGUgaW50ZXJzZWN0aW9uIHBvaW50IGZyb20gdGhlIHN0YXJ0aW5nIHBvaW50IHVzaW5nIHRoZSBoZWFkaW5nLlxuICogQHBhcmFtIHtDYXJ0b2dyYXBoaWN9IFtyZXN1bHRdIFRoZSBvYmplY3QgaW4gd2hpY2ggdG8gc3RvcmUgdGhlIHJlc3VsdC5cbiAqIEByZXR1cm5zIHtDYXJ0b2dyYXBoaWN9IFRoZSBsb2NhdGlvbiBvZiB0aGUgaW50ZXJzZWN0aW9uIHBvaW50IGFsb25nIHRoZSByaHVtYiBsaW5lLCB1bmRlZmluZWQgaWYgdGhlcmUgaXMgbm8gaW50ZXJzZWN0aW9uIG9yIGluZmluaXRlIGludGVyc2VjdGlvbnMuXG4gKlxuICogQGV4Y2VwdGlvbiB7RGV2ZWxvcGVyRXJyb3J9IHN0YXJ0IGFuZCBlbmQgbXVzdCBiZSBzZXQgYmVmb3JlIGNhbGxpbmcgZnVuY3Rpb24gZmluZEludGVyc2VjdGlvbldpdGhMb25naXR1ZGUuXG4gKi9cbkVsbGlwc29pZFJodW1iTGluZS5wcm90b3R5cGUuZmluZEludGVyc2VjdGlvbldpdGhMb25naXR1ZGUgPSBmdW5jdGlvbiAoXG4gIGludGVyc2VjdGlvbkxvbmdpdHVkZSxcbiAgcmVzdWx0XG4pIHtcbiAgLy8+PmluY2x1ZGVTdGFydCgnZGVidWcnLCBwcmFnbWFzLmRlYnVnKTtcbiAgQ2hlY2sudHlwZU9mLm51bWJlcihcImludGVyc2VjdGlvbkxvbmdpdHVkZVwiLCBpbnRlcnNlY3Rpb25Mb25naXR1ZGUpO1xuICBpZiAoIWRlZmluZWQodGhpcy5fZGlzdGFuY2UpIHx8IHRoaXMuX2Rpc3RhbmNlID09PSAwLjApIHtcbiAgICB0aHJvdyBuZXcgRGV2ZWxvcGVyRXJyb3IoXG4gICAgICBcIkVsbGlwc29pZFJodW1iTGluZSBtdXN0IGhhdmUgZGlzdGluY3Qgc3RhcnQgYW5kIGVuZCBzZXQuXCJcbiAgICApO1xuICB9XG4gIC8vPj5pbmNsdWRlRW5kKCdkZWJ1ZycpO1xuXG4gIHZhciBlbGxpcHRpY2l0eSA9IHRoaXMuX2VsbGlwdGljaXR5O1xuICB2YXIgaGVhZGluZyA9IHRoaXMuX2hlYWRpbmc7XG4gIHZhciBhYnNIZWFkaW5nID0gTWF0aC5hYnMoaGVhZGluZyk7XG4gIHZhciBzdGFydCA9IHRoaXMuX3N0YXJ0O1xuXG4gIGludGVyc2VjdGlvbkxvbmdpdHVkZSA9IENlc2l1bU1hdGgubmVnYXRpdmVQaVRvUGkoaW50ZXJzZWN0aW9uTG9uZ2l0dWRlKTtcblxuICBpZiAoXG4gICAgQ2VzaXVtTWF0aC5lcXVhbHNFcHNpbG9uKFxuICAgICAgTWF0aC5hYnMoaW50ZXJzZWN0aW9uTG9uZ2l0dWRlKSxcbiAgICAgIE1hdGguUEksXG4gICAgICBDZXNpdW1NYXRoLkVQU0lMT04xNFxuICAgIClcbiAgKSB7XG4gICAgaW50ZXJzZWN0aW9uTG9uZ2l0dWRlID0gQ2VzaXVtTWF0aC5zaWduKHN0YXJ0LmxvbmdpdHVkZSkgKiBNYXRoLlBJO1xuICB9XG5cbiAgaWYgKCFkZWZpbmVkKHJlc3VsdCkpIHtcbiAgICByZXN1bHQgPSBuZXcgQ2FydG9ncmFwaGljKCk7XG4gIH1cblxuICAvLyBJZiBoZWFkaW5nIGlzIC1QSS8yIG9yIFBJLzIsIHRoaXMgaXMgYW4gRS1XIHJodW1iIGxpbmVcbiAgLy8gSWYgaGVhZGluZyBpcyAwIG9yIFBJLCB0aGlzIGlzIGFuIE4tUyByaHVtYiBsaW5lXG4gIGlmIChNYXRoLmFicyhDZXNpdW1NYXRoLlBJX09WRVJfVFdPIC0gYWJzSGVhZGluZykgPD0gQ2VzaXVtTWF0aC5FUFNJTE9OOCkge1xuICAgIHJlc3VsdC5sb25naXR1ZGUgPSBpbnRlcnNlY3Rpb25Mb25naXR1ZGU7XG4gICAgcmVzdWx0LmxhdGl0dWRlID0gc3RhcnQubGF0aXR1ZGU7XG4gICAgcmVzdWx0LmhlaWdodCA9IDA7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfSBlbHNlIGlmIChcbiAgICBDZXNpdW1NYXRoLmVxdWFsc0Vwc2lsb24oXG4gICAgICBNYXRoLmFicyhDZXNpdW1NYXRoLlBJX09WRVJfVFdPIC0gYWJzSGVhZGluZyksXG4gICAgICBDZXNpdW1NYXRoLlBJX09WRVJfVFdPLFxuICAgICAgQ2VzaXVtTWF0aC5FUFNJTE9OOFxuICAgIClcbiAgKSB7XG4gICAgaWYgKFxuICAgICAgQ2VzaXVtTWF0aC5lcXVhbHNFcHNpbG9uKFxuICAgICAgICBpbnRlcnNlY3Rpb25Mb25naXR1ZGUsXG4gICAgICAgIHN0YXJ0LmxvbmdpdHVkZSxcbiAgICAgICAgQ2VzaXVtTWF0aC5FUFNJTE9OMTJcbiAgICAgIClcbiAgICApIHtcbiAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgcmVzdWx0LmxvbmdpdHVkZSA9IGludGVyc2VjdGlvbkxvbmdpdHVkZTtcbiAgICByZXN1bHQubGF0aXR1ZGUgPVxuICAgICAgQ2VzaXVtTWF0aC5QSV9PVkVSX1RXTyAqXG4gICAgICBDZXNpdW1NYXRoLnNpZ24oQ2VzaXVtTWF0aC5QSV9PVkVSX1RXTyAtIGhlYWRpbmcpO1xuICAgIHJlc3VsdC5oZWlnaHQgPSAwO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICAvLyBVc2UgaXRlcmF0aXZlIHNvbHZlciBmcm9tIEVxdWF0aW9uIDkgZnJvbSBodHRwOi8vZWR3aWxsaWFtcy5vcmcvZWxsaXBzb2lkL2VsbGlwc29pZC5wZGZcbiAgdmFyIHBoaTEgPSBzdGFydC5sYXRpdHVkZTtcbiAgdmFyIGVTaW5QaGkxID0gZWxsaXB0aWNpdHkgKiBNYXRoLnNpbihwaGkxKTtcbiAgdmFyIGxlZnRDb21wb25lbnQgPVxuICAgIE1hdGgudGFuKDAuNSAqIChDZXNpdW1NYXRoLlBJX09WRVJfVFdPICsgcGhpMSkpICpcbiAgICBNYXRoLmV4cCgoaW50ZXJzZWN0aW9uTG9uZ2l0dWRlIC0gc3RhcnQubG9uZ2l0dWRlKSAvIE1hdGgudGFuKGhlYWRpbmcpKTtcbiAgdmFyIGRlbm9taW5hdG9yID0gKDEgKyBlU2luUGhpMSkgLyAoMSAtIGVTaW5QaGkxKTtcblxuICB2YXIgbmV3UGhpID0gc3RhcnQubGF0aXR1ZGU7XG4gIHZhciBwaGk7XG4gIGRvIHtcbiAgICBwaGkgPSBuZXdQaGk7XG4gICAgdmFyIGVTaW5QaGkgPSBlbGxpcHRpY2l0eSAqIE1hdGguc2luKHBoaSk7XG4gICAgdmFyIG51bWVyYXRvciA9ICgxICsgZVNpblBoaSkgLyAoMSAtIGVTaW5QaGkpO1xuICAgIG5ld1BoaSA9XG4gICAgICAyICpcbiAgICAgICAgTWF0aC5hdGFuKFxuICAgICAgICAgIGxlZnRDb21wb25lbnQgKiBNYXRoLnBvdyhudW1lcmF0b3IgLyBkZW5vbWluYXRvciwgZWxsaXB0aWNpdHkgLyAyKVxuICAgICAgICApIC1cbiAgICAgIENlc2l1bU1hdGguUElfT1ZFUl9UV087XG4gIH0gd2hpbGUgKCFDZXNpdW1NYXRoLmVxdWFsc0Vwc2lsb24obmV3UGhpLCBwaGksIENlc2l1bU1hdGguRVBTSUxPTjEyKSk7XG5cbiAgcmVzdWx0LmxvbmdpdHVkZSA9IGludGVyc2VjdGlvbkxvbmdpdHVkZTtcbiAgcmVzdWx0LmxhdGl0dWRlID0gbmV3UGhpO1xuICByZXN1bHQuaGVpZ2h0ID0gMDtcbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbi8qKlxuICogUHJvdmlkZXMgdGhlIGxvY2F0aW9uIG9mIGEgcG9pbnQgYXQgdGhlIGluZGljYXRlZCBsYXRpdHVkZSBhbG9uZyB0aGUgcmh1bWIgbGluZS5cbiAqIElmIHRoZSBsYXRpdHVkZSBpcyBvdXRzaWRlIHRoZSByYW5nZSBvZiBzdGFydCBhbmQgZW5kIHBvaW50cywgdGhlIGZpcnN0IGludGVyc2VjdGlvbiB3aXRoIHRoZSBsYXRpdHVkZSBmcm9tIHRoYXQgc3RhcnQgcG9pbnQgaW4gdGhlIGRpcmVjdGlvbiBvZiB0aGUgaGVhZGluZyBpcyByZXR1cm5lZC4gVGhpcyBmb2xsb3dzIHRoZSBzcGlyYWwgcHJvcGVydHkgb2YgYSByaHVtYiBsaW5lLlxuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSBpbnRlcnNlY3Rpb25MYXRpdHVkZSBUaGUgbGF0aXR1ZGUsIGluIHJhZGlhbnMsIGF0IHdoaWNoIHRvIGZpbmQgdGhlIGludGVyc2VjdGlvbiBwb2ludCBmcm9tIHRoZSBzdGFydGluZyBwb2ludCB1c2luZyB0aGUgaGVhZGluZy5cbiAqIEBwYXJhbSB7Q2FydG9ncmFwaGljfSBbcmVzdWx0XSBUaGUgb2JqZWN0IGluIHdoaWNoIHRvIHN0b3JlIHRoZSByZXN1bHQuXG4gKiBAcmV0dXJucyB7Q2FydG9ncmFwaGljfSBUaGUgbG9jYXRpb24gb2YgdGhlIGludGVyc2VjdGlvbiBwb2ludCBhbG9uZyB0aGUgcmh1bWIgbGluZSwgdW5kZWZpbmVkIGlmIHRoZXJlIGlzIG5vIGludGVyc2VjdGlvbiBvciBpbmZpbml0ZSBpbnRlcnNlY3Rpb25zLlxuICpcbiAqIEBleGNlcHRpb24ge0RldmVsb3BlckVycm9yfSBzdGFydCBhbmQgZW5kIG11c3QgYmUgc2V0IGJlZm9yZSBjYWxsaW5nIGZ1bmN0aW9uIGZpbmRJbnRlcnNlY3Rpb25XaXRoTG9uZ2l0dWRlLlxuICovXG5FbGxpcHNvaWRSaHVtYkxpbmUucHJvdG90eXBlLmZpbmRJbnRlcnNlY3Rpb25XaXRoTGF0aXR1ZGUgPSBmdW5jdGlvbiAoXG4gIGludGVyc2VjdGlvbkxhdGl0dWRlLFxuICByZXN1bHRcbikge1xuICAvLz4+aW5jbHVkZVN0YXJ0KCdkZWJ1ZycsIHByYWdtYXMuZGVidWcpO1xuICBDaGVjay50eXBlT2YubnVtYmVyKFwiaW50ZXJzZWN0aW9uTGF0aXR1ZGVcIiwgaW50ZXJzZWN0aW9uTGF0aXR1ZGUpO1xuICBpZiAoIWRlZmluZWQodGhpcy5fZGlzdGFuY2UpIHx8IHRoaXMuX2Rpc3RhbmNlID09PSAwLjApIHtcbiAgICB0aHJvdyBuZXcgRGV2ZWxvcGVyRXJyb3IoXG4gICAgICBcIkVsbGlwc29pZFJodW1iTGluZSBtdXN0IGhhdmUgZGlzdGluY3Qgc3RhcnQgYW5kIGVuZCBzZXQuXCJcbiAgICApO1xuICB9XG4gIC8vPj5pbmNsdWRlRW5kKCdkZWJ1ZycpO1xuXG4gIHZhciBlbGxpcHRpY2l0eSA9IHRoaXMuX2VsbGlwdGljaXR5O1xuICB2YXIgaGVhZGluZyA9IHRoaXMuX2hlYWRpbmc7XG4gIHZhciBzdGFydCA9IHRoaXMuX3N0YXJ0O1xuXG4gIC8vIElmIHN0YXJ0IGFuZCBlbmQgaGF2ZSBzYW1lIGxhdGl0dWRlLCByZXR1cm4gdW5kZWZpbmVkIHNpbmNlIGl0J3MgZWl0aGVyIG5vIGludGVyc2VjdGlvbiBvciBpbmZpbml0ZSBpbnRlcnNlY3Rpb25zXG4gIGlmIChcbiAgICBDZXNpdW1NYXRoLmVxdWFsc0Vwc2lsb24oXG4gICAgICBNYXRoLmFicyhoZWFkaW5nKSxcbiAgICAgIENlc2l1bU1hdGguUElfT1ZFUl9UV08sXG4gICAgICBDZXNpdW1NYXRoLkVQU0lMT044XG4gICAgKVxuICApIHtcbiAgICByZXR1cm47XG4gIH1cblxuICAvLyBDYW4gYmUgc29sdmVkIHVzaW5nIHRoZSBzYW1lIGVxdWF0aW9ucyBmcm9tIGludGVycG9sYXRlVXNpbmdTdXJmYWNlRGlzdGFuY2VcbiAgdmFyIHNpZ21hMSA9IGNhbGN1bGF0ZVNpZ21hKGVsbGlwdGljaXR5LCBzdGFydC5sYXRpdHVkZSk7XG4gIHZhciBzaWdtYTIgPSBjYWxjdWxhdGVTaWdtYShlbGxpcHRpY2l0eSwgaW50ZXJzZWN0aW9uTGF0aXR1ZGUpO1xuICB2YXIgZGVsdGFMb25naXR1ZGUgPSBNYXRoLnRhbihoZWFkaW5nKSAqIChzaWdtYTIgLSBzaWdtYTEpO1xuICB2YXIgbG9uZ2l0dWRlID0gQ2VzaXVtTWF0aC5uZWdhdGl2ZVBpVG9QaShzdGFydC5sb25naXR1ZGUgKyBkZWx0YUxvbmdpdHVkZSk7XG5cbiAgaWYgKGRlZmluZWQocmVzdWx0KSkge1xuICAgIHJlc3VsdC5sb25naXR1ZGUgPSBsb25naXR1ZGU7XG4gICAgcmVzdWx0LmxhdGl0dWRlID0gaW50ZXJzZWN0aW9uTGF0aXR1ZGU7XG4gICAgcmVzdWx0LmhlaWdodCA9IDA7XG5cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgcmV0dXJuIG5ldyBDYXJ0b2dyYXBoaWMobG9uZ2l0dWRlLCBpbnRlcnNlY3Rpb25MYXRpdHVkZSwgMCk7XG59O1xuZXhwb3J0IGRlZmF1bHQgRWxsaXBzb2lkUmh1bWJMaW5lO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///8398\n')},74744:function(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__){eval('/* harmony import */ var _AxisAlignedBoundingBox_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(55829);\n/* harmony import */ var _Cartesian2_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(60838);\n/* harmony import */ var _Cartesian3_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(60216);\n/* harmony import */ var _Cartesian4_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(63367);\n/* harmony import */ var _Check_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(66553);\n/* harmony import */ var _defaultValue_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(62200);\n/* harmony import */ var _defined_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(82982);\n/* harmony import */ var _DeveloperError_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(12572);\n/* harmony import */ var _Ellipsoid_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(50491);\n/* harmony import */ var _IntersectionTests_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(67627);\n/* harmony import */ var _Matrix4_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(72248);\n/* harmony import */ var _Plane_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(7749);\n/* harmony import */ var _Ray_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(68457);\n/* harmony import */ var _Transforms_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(95555);\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nvar scratchCart4 = new _Cartesian4_js__WEBPACK_IMPORTED_MODULE_3__/* ["default"] */ .Z();\n/**\n * A plane tangent to the provided ellipsoid at the provided origin.\n * If origin is not on the surface of the ellipsoid, it\'s surface projection will be used.\n * If origin is at the center of the ellipsoid, an exception will be thrown.\n * @alias EllipsoidTangentPlane\n * @constructor\n *\n * @param {Cartesian3} origin The point on the surface of the ellipsoid where the tangent plane touches.\n * @param {Ellipsoid} [ellipsoid=Ellipsoid.WGS84] The ellipsoid to use.\n *\n * @exception {DeveloperError} origin must not be at the center of the ellipsoid.\n */\nfunction EllipsoidTangentPlane(origin, ellipsoid) {\n  //>>includeStart(\'debug\', pragmas.debug);\n  _Check_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"].defined */ .Z.defined("origin", origin);\n  //>>includeEnd(\'debug\');\n\n  ellipsoid = (0,_defaultValue_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"] */ .Z)(ellipsoid, _Ellipsoid_js__WEBPACK_IMPORTED_MODULE_7__/* ["default"].WGS84 */ .Z.WGS84);\n  origin = ellipsoid.scaleToGeodeticSurface(origin);\n\n  //>>includeStart(\'debug\', pragmas.debug);\n  if (!(0,_defined_js__WEBPACK_IMPORTED_MODULE_13__/* ["default"] */ .Z)(origin)) {\n    throw new _DeveloperError_js__WEBPACK_IMPORTED_MODULE_6__/* ["default"] */ .Z(\n      "origin must not be at the center of the ellipsoid."\n    );\n  }\n  //>>includeEnd(\'debug\');\n\n  var eastNorthUp = _Transforms_js__WEBPACK_IMPORTED_MODULE_12__/* ["default"].eastNorthUpToFixedFrame */ .Z.eastNorthUpToFixedFrame(origin, ellipsoid);\n  this._ellipsoid = ellipsoid;\n  this._origin = origin;\n  this._xAxis = _Cartesian3_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"].fromCartesian4 */ .Z.fromCartesian4(\n    _Matrix4_js__WEBPACK_IMPORTED_MODULE_9__/* ["default"].getColumn */ .Z.getColumn(eastNorthUp, 0, scratchCart4)\n  );\n  this._yAxis = _Cartesian3_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"].fromCartesian4 */ .Z.fromCartesian4(\n    _Matrix4_js__WEBPACK_IMPORTED_MODULE_9__/* ["default"].getColumn */ .Z.getColumn(eastNorthUp, 1, scratchCart4)\n  );\n\n  var normal = _Cartesian3_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"].fromCartesian4 */ .Z.fromCartesian4(\n    _Matrix4_js__WEBPACK_IMPORTED_MODULE_9__/* ["default"].getColumn */ .Z.getColumn(eastNorthUp, 2, scratchCart4)\n  );\n  this._plane = _Plane_js__WEBPACK_IMPORTED_MODULE_10__/* ["default"].fromPointNormal */ .Z.fromPointNormal(origin, normal);\n}\n\nObject.defineProperties(EllipsoidTangentPlane.prototype, {\n  /**\n   * Gets the ellipsoid.\n   * @memberof EllipsoidTangentPlane.prototype\n   * @type {Ellipsoid}\n   */\n  ellipsoid: {\n    get: function () {\n      return this._ellipsoid;\n    },\n  },\n\n  /**\n   * Gets the origin.\n   * @memberof EllipsoidTangentPlane.prototype\n   * @type {Cartesian3}\n   */\n  origin: {\n    get: function () {\n      return this._origin;\n    },\n  },\n\n  /**\n   * Gets the plane which is tangent to the ellipsoid.\n   * @memberof EllipsoidTangentPlane.prototype\n   * @readonly\n   * @type {Plane}\n   */\n  plane: {\n    get: function () {\n      return this._plane;\n    },\n  },\n\n  /**\n   * Gets the local X-axis (east) of the tangent plane.\n   * @memberof EllipsoidTangentPlane.prototype\n   * @readonly\n   * @type {Cartesian3}\n   */\n  xAxis: {\n    get: function () {\n      return this._xAxis;\n    },\n  },\n\n  /**\n   * Gets the local Y-axis (north) of the tangent plane.\n   * @memberof EllipsoidTangentPlane.prototype\n   * @readonly\n   * @type {Cartesian3}\n   */\n  yAxis: {\n    get: function () {\n      return this._yAxis;\n    },\n  },\n\n  /**\n   * Gets the local Z-axis (up) of the tangent plane.\n   * @memberof EllipsoidTangentPlane.prototype\n   * @readonly\n   * @type {Cartesian3}\n   */\n  zAxis: {\n    get: function () {\n      return this._plane.normal;\n    },\n  },\n});\n\nvar tmp = new _AxisAlignedBoundingBox_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .Z();\n/**\n * Creates a new instance from the provided ellipsoid and the center\n * point of the provided Cartesians.\n *\n * @param {Cartesian3[]} cartesians The list of positions surrounding the center point.\n * @param {Ellipsoid} [ellipsoid=Ellipsoid.WGS84] The ellipsoid to use.\n * @returns {EllipsoidTangentPlane} The new instance of EllipsoidTangentPlane.\n */\nEllipsoidTangentPlane.fromPoints = function (cartesians, ellipsoid) {\n  //>>includeStart(\'debug\', pragmas.debug);\n  _Check_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"].defined */ .Z.defined("cartesians", cartesians);\n  //>>includeEnd(\'debug\');\n\n  var box = _AxisAlignedBoundingBox_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].fromPoints */ .Z.fromPoints(cartesians, tmp);\n  return new EllipsoidTangentPlane(box.center, ellipsoid);\n};\n\nvar scratchProjectPointOntoPlaneRay = new _Ray_js__WEBPACK_IMPORTED_MODULE_11__/* ["default"] */ .Z();\nvar scratchProjectPointOntoPlaneCartesian3 = new _Cartesian3_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"] */ .Z();\n\n/**\n * Computes the projection of the provided 3D position onto the 2D plane, radially outward from the {@link EllipsoidTangentPlane.ellipsoid} coordinate system origin.\n *\n * @param {Cartesian3} cartesian The point to project.\n * @param {Cartesian2} [result] The object onto which to store the result.\n * @returns {Cartesian2} The modified result parameter or a new Cartesian2 instance if none was provided. Undefined if there is no intersection point\n */\nEllipsoidTangentPlane.prototype.projectPointOntoPlane = function (\n  cartesian,\n  result\n) {\n  //>>includeStart(\'debug\', pragmas.debug);\n  _Check_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"].defined */ .Z.defined("cartesian", cartesian);\n  //>>includeEnd(\'debug\');\n\n  var ray = scratchProjectPointOntoPlaneRay;\n  ray.origin = cartesian;\n  _Cartesian3_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"].normalize */ .Z.normalize(cartesian, ray.direction);\n\n  var intersectionPoint = _IntersectionTests_js__WEBPACK_IMPORTED_MODULE_8__/* ["default"].rayPlane */ .Z.rayPlane(\n    ray,\n    this._plane,\n    scratchProjectPointOntoPlaneCartesian3\n  );\n  if (!(0,_defined_js__WEBPACK_IMPORTED_MODULE_13__/* ["default"] */ .Z)(intersectionPoint)) {\n    _Cartesian3_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"].negate */ .Z.negate(ray.direction, ray.direction);\n    intersectionPoint = _IntersectionTests_js__WEBPACK_IMPORTED_MODULE_8__/* ["default"].rayPlane */ .Z.rayPlane(\n      ray,\n      this._plane,\n      scratchProjectPointOntoPlaneCartesian3\n    );\n  }\n\n  if ((0,_defined_js__WEBPACK_IMPORTED_MODULE_13__/* ["default"] */ .Z)(intersectionPoint)) {\n    var v = _Cartesian3_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"].subtract */ .Z.subtract(\n      intersectionPoint,\n      this._origin,\n      intersectionPoint\n    );\n    var x = _Cartesian3_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"].dot */ .Z.dot(this._xAxis, v);\n    var y = _Cartesian3_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"].dot */ .Z.dot(this._yAxis, v);\n\n    if (!(0,_defined_js__WEBPACK_IMPORTED_MODULE_13__/* ["default"] */ .Z)(result)) {\n      return new _Cartesian2_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .Z(x, y);\n    }\n    result.x = x;\n    result.y = y;\n    return result;\n  }\n  return undefined;\n};\n\n/**\n * Computes the projection of the provided 3D positions onto the 2D plane (where possible), radially outward from the global origin.\n * The resulting array may be shorter than the input array - if a single projection is impossible it will not be included.\n *\n * @see EllipsoidTangentPlane.projectPointOntoPlane\n *\n * @param {Cartesian3[]} cartesians The array of points to project.\n * @param {Cartesian2[]} [result] The array of Cartesian2 instances onto which to store results.\n * @returns {Cartesian2[]} The modified result parameter or a new array of Cartesian2 instances if none was provided.\n */\nEllipsoidTangentPlane.prototype.projectPointsOntoPlane = function (\n  cartesians,\n  result\n) {\n  //>>includeStart(\'debug\', pragmas.debug);\n  _Check_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"].defined */ .Z.defined("cartesians", cartesians);\n  //>>includeEnd(\'debug\');\n\n  if (!(0,_defined_js__WEBPACK_IMPORTED_MODULE_13__/* ["default"] */ .Z)(result)) {\n    result = [];\n  }\n\n  var count = 0;\n  var length = cartesians.length;\n  for (var i = 0; i < length; i++) {\n    var p = this.projectPointOntoPlane(cartesians[i], result[count]);\n    if ((0,_defined_js__WEBPACK_IMPORTED_MODULE_13__/* ["default"] */ .Z)(p)) {\n      result[count] = p;\n      count++;\n    }\n  }\n  result.length = count;\n  return result;\n};\n\n/**\n * Computes the projection of the provided 3D position onto the 2D plane, along the plane normal.\n *\n * @param {Cartesian3} cartesian The point to project.\n * @param {Cartesian2} [result] The object onto which to store the result.\n * @returns {Cartesian2} The modified result parameter or a new Cartesian2 instance if none was provided.\n */\nEllipsoidTangentPlane.prototype.projectPointToNearestOnPlane = function (\n  cartesian,\n  result\n) {\n  //>>includeStart(\'debug\', pragmas.debug);\n  _Check_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"].defined */ .Z.defined("cartesian", cartesian);\n  //>>includeEnd(\'debug\');\n\n  if (!(0,_defined_js__WEBPACK_IMPORTED_MODULE_13__/* ["default"] */ .Z)(result)) {\n    result = new _Cartesian2_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .Z();\n  }\n\n  var ray = scratchProjectPointOntoPlaneRay;\n  ray.origin = cartesian;\n  _Cartesian3_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"].clone */ .Z.clone(this._plane.normal, ray.direction);\n\n  var intersectionPoint = _IntersectionTests_js__WEBPACK_IMPORTED_MODULE_8__/* ["default"].rayPlane */ .Z.rayPlane(\n    ray,\n    this._plane,\n    scratchProjectPointOntoPlaneCartesian3\n  );\n  if (!(0,_defined_js__WEBPACK_IMPORTED_MODULE_13__/* ["default"] */ .Z)(intersectionPoint)) {\n    _Cartesian3_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"].negate */ .Z.negate(ray.direction, ray.direction);\n    intersectionPoint = _IntersectionTests_js__WEBPACK_IMPORTED_MODULE_8__/* ["default"].rayPlane */ .Z.rayPlane(\n      ray,\n      this._plane,\n      scratchProjectPointOntoPlaneCartesian3\n    );\n  }\n\n  var v = _Cartesian3_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"].subtract */ .Z.subtract(\n    intersectionPoint,\n    this._origin,\n    intersectionPoint\n  );\n  var x = _Cartesian3_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"].dot */ .Z.dot(this._xAxis, v);\n  var y = _Cartesian3_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"].dot */ .Z.dot(this._yAxis, v);\n\n  result.x = x;\n  result.y = y;\n  return result;\n};\n\n/**\n * Computes the projection of the provided 3D positions onto the 2D plane, along the plane normal.\n *\n * @see EllipsoidTangentPlane.projectPointToNearestOnPlane\n *\n * @param {Cartesian3[]} cartesians The array of points to project.\n * @param {Cartesian2[]} [result] The array of Cartesian2 instances onto which to store results.\n * @returns {Cartesian2[]} The modified result parameter or a new array of Cartesian2 instances if none was provided. This will have the same length as <code>cartesians</code>.\n */\nEllipsoidTangentPlane.prototype.projectPointsToNearestOnPlane = function (\n  cartesians,\n  result\n) {\n  //>>includeStart(\'debug\', pragmas.debug);\n  _Check_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"].defined */ .Z.defined("cartesians", cartesians);\n  //>>includeEnd(\'debug\');\n\n  if (!(0,_defined_js__WEBPACK_IMPORTED_MODULE_13__/* ["default"] */ .Z)(result)) {\n    result = [];\n  }\n\n  var length = cartesians.length;\n  result.length = length;\n  for (var i = 0; i < length; i++) {\n    result[i] = this.projectPointToNearestOnPlane(cartesians[i], result[i]);\n  }\n  return result;\n};\n\nvar projectPointsOntoEllipsoidScratch = new _Cartesian3_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"] */ .Z();\n/**\n * Computes the projection of the provided 2D position onto the 3D ellipsoid.\n *\n * @param {Cartesian2} cartesian The points to project.\n * @param {Cartesian3} [result] The Cartesian3 instance to store result.\n * @returns {Cartesian3} The modified result parameter or a new Cartesian3 instance if none was provided.\n */\nEllipsoidTangentPlane.prototype.projectPointOntoEllipsoid = function (\n  cartesian,\n  result\n) {\n  //>>includeStart(\'debug\', pragmas.debug);\n  _Check_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"].defined */ .Z.defined("cartesian", cartesian);\n  //>>includeEnd(\'debug\');\n\n  if (!(0,_defined_js__WEBPACK_IMPORTED_MODULE_13__/* ["default"] */ .Z)(result)) {\n    result = new _Cartesian3_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"] */ .Z();\n  }\n\n  var ellipsoid = this._ellipsoid;\n  var origin = this._origin;\n  var xAxis = this._xAxis;\n  var yAxis = this._yAxis;\n  var tmp = projectPointsOntoEllipsoidScratch;\n\n  _Cartesian3_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"].multiplyByScalar */ .Z.multiplyByScalar(xAxis, cartesian.x, tmp);\n  result = _Cartesian3_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"].add */ .Z.add(origin, tmp, result);\n  _Cartesian3_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"].multiplyByScalar */ .Z.multiplyByScalar(yAxis, cartesian.y, tmp);\n  _Cartesian3_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"].add */ .Z.add(result, tmp, result);\n  ellipsoid.scaleToGeocentricSurface(result, result);\n\n  return result;\n};\n\n/**\n * Computes the projection of the provided 2D positions onto the 3D ellipsoid.\n *\n * @param {Cartesian2[]} cartesians The array of points to project.\n * @param {Cartesian3[]} [result] The array of Cartesian3 instances onto which to store results.\n * @returns {Cartesian3[]} The modified result parameter or a new array of Cartesian3 instances if none was provided.\n */\nEllipsoidTangentPlane.prototype.projectPointsOntoEllipsoid = function (\n  cartesians,\n  result\n) {\n  //>>includeStart(\'debug\', pragmas.debug);\n  _Check_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"].defined */ .Z.defined("cartesians", cartesians);\n  //>>includeEnd(\'debug\');\n\n  var length = cartesians.length;\n  if (!(0,_defined_js__WEBPACK_IMPORTED_MODULE_13__/* ["default"] */ .Z)(result)) {\n    result = new Array(length);\n  } else {\n    result.length = length;\n  }\n\n  for (var i = 0; i < length; ++i) {\n    result[i] = this.projectPointOntoEllipsoid(cartesians[i], result[i]);\n  }\n\n  return result;\n};\n/* harmony default export */ __webpack_exports__["Z"] = (EllipsoidTangentPlane);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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ekIsRUFBRSxpR0FBMkI7QUFDN0IsRUFBRSx1RUFBYztBQUNoQjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsY0FBYztBQUN6QixXQUFXLGNBQWM7QUFDekIsYUFBYSxjQUFjO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUUsMEVBQWE7QUFDZjs7QUFFQTtBQUNBLE9BQU8saUVBQU87QUFDZDtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBLGtCQUFrQixZQUFZO0FBQzlCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHlEQUFlLHFCQUFxQixFQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdnVlMy13ZWJwYWNrNS8uL25vZGVfbW9kdWxlcy9jZXNpdW0vU291cmNlL0NvcmUvRWxsaXBzb2lkVGFuZ2VudFBsYW5lLmpzPzEzNTYiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IEF4aXNBbGlnbmVkQm91bmRpbmdCb3ggZnJvbSBcIi4vQXhpc0FsaWduZWRCb3VuZGluZ0JveC5qc1wiO1xuaW1wb3J0IENhcnRlc2lhbjIgZnJvbSBcIi4vQ2FydGVzaWFuMi5qc1wiO1xuaW1wb3J0IENhcnRlc2lhbjMgZnJvbSBcIi4vQ2FydGVzaWFuMy5qc1wiO1xuaW1wb3J0IENhcnRlc2lhbjQgZnJvbSBcIi4vQ2FydGVzaWFuNC5qc1wiO1xuaW1wb3J0IENoZWNrIGZyb20gXCIuL0NoZWNrLmpzXCI7XG5pbXBvcnQgZGVmYXVsdFZhbHVlIGZyb20gXCIuL2RlZmF1bHRWYWx1ZS5qc1wiO1xuaW1wb3J0IGRlZmluZWQgZnJvbSBcIi4vZGVmaW5lZC5qc1wiO1xuaW1wb3J0IERldmVsb3BlckVycm9yIGZyb20gXCIuL0RldmVsb3BlckVycm9yLmpzXCI7XG5pbXBvcnQgRWxsaXBzb2lkIGZyb20gXCIuL0VsbGlwc29pZC5qc1wiO1xuaW1wb3J0IEludGVyc2VjdGlvblRlc3RzIGZyb20gXCIuL0ludGVyc2VjdGlvblRlc3RzLmpzXCI7XG5pbXBvcnQgTWF0cml4NCBmcm9tIFwiLi9NYXRyaXg0LmpzXCI7XG5pbXBvcnQgUGxhbmUgZnJvbSBcIi4vUGxhbmUuanNcIjtcbmltcG9ydCBSYXkgZnJvbSBcIi4vUmF5LmpzXCI7XG5pbXBvcnQgVHJhbnNmb3JtcyBmcm9tIFwiLi9UcmFuc2Zvcm1zLmpzXCI7XG5cbnZhciBzY3JhdGNoQ2FydDQgPSBuZXcgQ2FydGVzaWFuNCgpO1xuLyoqXG4gKiBBIHBsYW5lIHRhbmdlbnQgdG8gdGhlIHByb3ZpZGVkIGVsbGlwc29pZCBhdCB0aGUgcHJvdmlkZWQgb3JpZ2luLlxuICogSWYgb3JpZ2luIGlzIG5vdCBvbiB0aGUgc3VyZmFjZSBvZiB0aGUgZWxsaXBzb2lkLCBpdCdzIHN1cmZhY2UgcHJvamVjdGlvbiB3aWxsIGJlIHVzZWQuXG4gKiBJZiBvcmlnaW4gaXMgYXQgdGhlIGNlbnRlciBvZiB0aGUgZWxsaXBzb2lkLCBhbiBleGNlcHRpb24gd2lsbCBiZSB0aHJvd24uXG4gKiBAYWxpYXMgRWxsaXBzb2lkVGFuZ2VudFBsYW5lXG4gKiBAY29uc3RydWN0b3JcbiAqXG4gKiBAcGFyYW0ge0NhcnRlc2lhbjN9IG9yaWdpbiBUaGUgcG9pbnQgb24gdGhlIHN1cmZhY2Ugb2YgdGhlIGVsbGlwc29pZCB3aGVyZSB0aGUgdGFuZ2VudCBwbGFuZSB0b3VjaGVzLlxuICogQHBhcmFtIHtFbGxpcHNvaWR9IFtlbGxpcHNvaWQ9RWxsaXBzb2lkLldHUzg0XSBUaGUgZWxsaXBzb2lkIHRvIHVzZS5cbiAqXG4gKiBAZXhjZXB0aW9uIHtEZXZlbG9wZXJFcnJvcn0gb3JpZ2luIG11c3Qgbm90IGJlIGF0IHRoZSBjZW50ZXIgb2YgdGhlIGVsbGlwc29pZC5cbiAqL1xuZnVuY3Rpb24gRWxsaXBzb2lkVGFuZ2VudFBsYW5lKG9yaWdpbiwgZWxsaXBzb2lkKSB7XG4gIC8vPj5pbmNsdWRlU3RhcnQoJ2RlYnVnJywgcHJhZ21hcy5kZWJ1Zyk7XG4gIENoZWNrLmRlZmluZWQoXCJvcmlnaW5cIiwgb3JpZ2luKTtcbiAgLy8+PmluY2x1ZGVFbmQoJ2RlYnVnJyk7XG5cbiAgZWxsaXBzb2lkID0gZGVmYXVsdFZhbHVlKGVsbGlwc29pZCwgRWxsaXBzb2lkLldHUzg0KTtcbiAgb3JpZ2luID0gZWxsaXBzb2lkLnNjYWxlVG9HZW9kZXRpY1N1cmZhY2Uob3JpZ2luKTtcblxuICAvLz4+aW5jbHVkZVN0YXJ0KCdkZWJ1ZycsIHByYWdtYXMuZGVidWcpO1xuICBpZiAoIWRlZmluZWQob3JpZ2luKSkge1xuICAgIHRocm93IG5ldyBEZXZlbG9wZXJFcnJvcihcbiAgICAgIFwib3JpZ2luIG11c3Qgbm90IGJlIGF0IHRoZSBjZW50ZXIgb2YgdGhlIGVsbGlwc29pZC5cIlxuICAgICk7XG4gIH1cbiAgLy8+PmluY2x1ZGVFbmQoJ2RlYnVnJyk7XG5cbiAgdmFyIGVhc3ROb3J0aFVwID0gVHJhbnNmb3Jtcy5lYXN0Tm9ydGhVcFRvRml4ZWRGcmFtZShvcmlnaW4sIGVsbGlwc29pZCk7XG4gIHRoaXMuX2VsbGlwc29pZCA9IGVsbGlwc29pZDtcbiAgdGhpcy5fb3JpZ2luID0gb3JpZ2luO1xuICB0aGlzLl94QXhpcyA9IENhcnRlc2lhbjMuZnJvbUNhcnRlc2lhbjQoXG4gICAgTWF0cml4NC5nZXRDb2x1bW4oZWFzdE5vcnRoVXAsIDAsIHNjcmF0Y2hDYXJ0NClcbiAgKTtcbiAgdGhpcy5feUF4aXMgPSBDYXJ0ZXNpYW4zLmZyb21DYXJ0ZXNpYW40KFxuICAgIE1hdHJpeDQuZ2V0Q29sdW1uKGVhc3ROb3J0aFVwLCAxLCBzY3JhdGNoQ2FydDQpXG4gICk7XG5cbiAgdmFyIG5vcm1hbCA9IENhcnRlc2lhbjMuZnJvbUNhcnRlc2lhbjQoXG4gICAgTWF0cml4NC5nZXRDb2x1bW4oZWFzdE5vcnRoVXAsIDIsIHNjcmF0Y2hDYXJ0NClcbiAgKTtcbiAgdGhpcy5fcGxhbmUgPSBQbGFuZS5mcm9tUG9pbnROb3JtYWwob3JpZ2luLCBub3JtYWwpO1xufVxuXG5PYmplY3QuZGVmaW5lUHJvcGVydGllcyhFbGxpcHNvaWRUYW5nZW50UGxhbmUucHJvdG90eXBlLCB7XG4gIC8qKlxuICAgKiBHZXRzIHRoZSBlbGxpcHNvaWQuXG4gICAqIEBtZW1iZXJvZiBFbGxpcHNvaWRUYW5nZW50UGxhbmUucHJvdG90eXBlXG4gICAqIEB0eXBlIHtFbGxpcHNvaWR9XG4gICAqL1xuICBlbGxpcHNvaWQ6IHtcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9lbGxpcHNvaWQ7XG4gICAgfSxcbiAgfSxcblxuICAvKipcbiAgICogR2V0cyB0aGUgb3JpZ2luLlxuICAgKiBAbWVtYmVyb2YgRWxsaXBzb2lkVGFuZ2VudFBsYW5lLnByb3RvdHlwZVxuICAgKiBAdHlwZSB7Q2FydGVzaWFuM31cbiAgICovXG4gIG9yaWdpbjoge1xuICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX29yaWdpbjtcbiAgICB9LFxuICB9LFxuXG4gIC8qKlxuICAgKiBHZXRzIHRoZSBwbGFuZSB3aGljaCBpcyB0YW5nZW50IHRvIHRoZSBlbGxpcHNvaWQuXG4gICAqIEBtZW1iZXJvZiBFbGxpcHNvaWRUYW5nZW50UGxhbmUucHJvdG90eXBlXG4gICAqIEByZWFkb25seVxuICAgKiBAdHlwZSB7UGxhbmV9XG4gICAqL1xuICBwbGFuZToge1xuICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX3BsYW5lO1xuICAgIH0sXG4gIH0sXG5cbiAgLyoqXG4gICAqIEdldHMgdGhlIGxvY2FsIFgtYXhpcyAoZWFzdCkgb2YgdGhlIHRhbmdlbnQgcGxhbmUuXG4gICAqIEBtZW1iZXJvZiBFbGxpcHNvaWRUYW5nZW50UGxhbmUucHJvdG90eXBlXG4gICAqIEByZWFkb25seVxuICAgKiBAdHlwZSB7Q2FydGVzaWFuM31cbiAgICovXG4gIHhBeGlzOiB7XG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5feEF4aXM7XG4gICAgfSxcbiAgfSxcblxuICAvKipcbiAgICogR2V0cyB0aGUgbG9jYWwgWS1heGlzIChub3J0aCkgb2YgdGhlIHRhbmdlbnQgcGxhbmUuXG4gICAqIEBtZW1iZXJvZiBFbGxpcHNvaWRUYW5nZW50UGxhbmUucHJvdG90eXBlXG4gICAqIEByZWFkb25seVxuICAgKiBAdHlwZSB7Q2FydGVzaWFuM31cbiAgICovXG4gIHlBeGlzOiB7XG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5feUF4aXM7XG4gICAgfSxcbiAgfSxcblxuICAvKipcbiAgICogR2V0cyB0aGUgbG9jYWwgWi1heGlzICh1cCkgb2YgdGhlIHRhbmdlbnQgcGxhbmUuXG4gICAqIEBtZW1iZXJvZiBFbGxpcHNvaWRUYW5nZW50UGxhbmUucHJvdG90eXBlXG4gICAqIEByZWFkb25seVxuICAgKiBAdHlwZSB7Q2FydGVzaWFuM31cbiAgICovXG4gIHpBeGlzOiB7XG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fcGxhbmUubm9ybWFsO1xuICAgIH0sXG4gIH0sXG59KTtcblxudmFyIHRtcCA9IG5ldyBBeGlzQWxpZ25lZEJvdW5kaW5nQm94KCk7XG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgaW5zdGFuY2UgZnJvbSB0aGUgcHJvdmlkZWQgZWxsaXBzb2lkIGFuZCB0aGUgY2VudGVyXG4gKiBwb2ludCBvZiB0aGUgcHJvdmlkZWQgQ2FydGVzaWFucy5cbiAqXG4gKiBAcGFyYW0ge0NhcnRlc2lhbjNbXX0gY2FydGVzaWFucyBUaGUgbGlzdCBvZiBwb3NpdGlvbnMgc3Vycm91bmRpbmcgdGhlIGNlbnRlciBwb2ludC5cbiAqIEBwYXJhbSB7RWxsaXBzb2lkfSBbZWxsaXBzb2lkPUVsbGlwc29pZC5XR1M4NF0gVGhlIGVsbGlwc29pZCB0byB1c2UuXG4gKiBAcmV0dXJucyB7RWxsaXBzb2lkVGFuZ2VudFBsYW5lfSBUaGUgbmV3IGluc3RhbmNlIG9mIEVsbGlwc29pZFRhbmdlbnRQbGFuZS5cbiAqL1xuRWxsaXBzb2lkVGFuZ2VudFBsYW5lLmZyb21Qb2ludHMgPSBmdW5jdGlvbiAoY2FydGVzaWFucywgZWxsaXBzb2lkKSB7XG4gIC8vPj5pbmNsdWRlU3RhcnQoJ2RlYnVnJywgcHJhZ21hcy5kZWJ1Zyk7XG4gIENoZWNrLmRlZmluZWQoXCJjYXJ0ZXNpYW5zXCIsIGNhcnRlc2lhbnMpO1xuICAvLz4+aW5jbHVkZUVuZCgnZGVidWcnKTtcblxuICB2YXIgYm94ID0gQXhpc0FsaWduZWRCb3VuZGluZ0JveC5mcm9tUG9pbnRzKGNhcnRlc2lhbnMsIHRtcCk7XG4gIHJldHVybiBuZXcgRWxsaXBzb2lkVGFuZ2VudFBsYW5lKGJveC5jZW50ZXIsIGVsbGlwc29pZCk7XG59O1xuXG52YXIgc2NyYXRjaFByb2plY3RQb2ludE9udG9QbGFuZVJheSA9IG5ldyBSYXkoKTtcbnZhciBzY3JhdGNoUHJvamVjdFBvaW50T250b1BsYW5lQ2FydGVzaWFuMyA9IG5ldyBDYXJ0ZXNpYW4zKCk7XG5cbi8qKlxuICogQ29tcHV0ZXMgdGhlIHByb2plY3Rpb24gb2YgdGhlIHByb3ZpZGVkIDNEIHBvc2l0aW9uIG9udG8gdGhlIDJEIHBsYW5lLCByYWRpYWxseSBvdXR3YXJkIGZyb20gdGhlIHtAbGluayBFbGxpcHNvaWRUYW5nZW50UGxhbmUuZWxsaXBzb2lkfSBjb29yZGluYXRlIHN5c3RlbSBvcmlnaW4uXG4gKlxuICogQHBhcmFtIHtDYXJ0ZXNpYW4zfSBjYXJ0ZXNpYW4gVGhlIHBvaW50IHRvIHByb2plY3QuXG4gKiBAcGFyYW0ge0NhcnRlc2lhbjJ9IFtyZXN1bHRdIFRoZSBvYmplY3Qgb250byB3aGljaCB0byBzdG9yZSB0aGUgcmVzdWx0LlxuICogQHJldHVybnMge0NhcnRlc2lhbjJ9IFRoZSBtb2RpZmllZCByZXN1bHQgcGFyYW1ldGVyIG9yIGEgbmV3IENhcnRlc2lhbjIgaW5zdGFuY2UgaWYgbm9uZSB3YXMgcHJvdmlkZWQuIFVuZGVmaW5lZCBpZiB0aGVyZSBpcyBubyBpbnRlcnNlY3Rpb24gcG9pbnRcbiAqL1xuRWxsaXBzb2lkVGFuZ2VudFBsYW5lLnByb3RvdHlwZS5wcm9qZWN0UG9pbnRPbnRvUGxhbmUgPSBmdW5jdGlvbiAoXG4gIGNhcnRlc2lhbixcbiAgcmVzdWx0XG4pIHtcbiAgLy8+PmluY2x1ZGVTdGFydCgnZGVidWcnLCBwcmFnbWFzLmRlYnVnKTtcbiAgQ2hlY2suZGVmaW5lZChcImNhcnRlc2lhblwiLCBjYXJ0ZXNpYW4pO1xuICAvLz4+aW5jbHVkZUVuZCgnZGVidWcnKTtcblxuICB2YXIgcmF5ID0gc2NyYXRjaFByb2plY3RQb2ludE9udG9QbGFuZVJheTtcbiAgcmF5Lm9yaWdpbiA9IGNhcnRlc2lhbjtcbiAgQ2FydGVzaWFuMy5ub3JtYWxpemUoY2FydGVzaWFuLCByYXkuZGlyZWN0aW9uKTtcblxuICB2YXIgaW50ZXJzZWN0aW9uUG9pbnQgPSBJbnRlcnNlY3Rpb25UZXN0cy5yYXlQbGFuZShcbiAgICByYXksXG4gICAgdGhpcy5fcGxhbmUsXG4gICAgc2NyYXRjaFByb2plY3RQb2ludE9udG9QbGFuZUNhcnRlc2lhbjNcbiAgKTtcbiAgaWYgKCFkZWZpbmVkKGludGVyc2VjdGlvblBvaW50KSkge1xuICAgIENhcnRlc2lhbjMubmVnYXRlKHJheS5kaXJlY3Rpb24sIHJheS5kaXJlY3Rpb24pO1xuICAgIGludGVyc2VjdGlvblBvaW50ID0gSW50ZXJzZWN0aW9uVGVzdHMucmF5UGxhbmUoXG4gICAgICByYXksXG4gICAgICB0aGlzLl9wbGFuZSxcbiAgICAgIHNjcmF0Y2hQcm9qZWN0UG9pbnRPbnRvUGxhbmVDYXJ0ZXNpYW4zXG4gICAgKTtcbiAgfVxuXG4gIGlmIChkZWZpbmVkKGludGVyc2VjdGlvblBvaW50KSkge1xuICAgIHZhciB2ID0gQ2FydGVzaWFuMy5zdWJ0cmFjdChcbiAgICAgIGludGVyc2VjdGlvblBvaW50LFxuICAgICAgdGhpcy5fb3JpZ2luLFxuICAgICAgaW50ZXJzZWN0aW9uUG9pbnRcbiAgICApO1xuICAgIHZhciB4ID0gQ2FydGVzaWFuMy5kb3QodGhpcy5feEF4aXMsIHYpO1xuICAgIHZhciB5ID0gQ2FydGVzaWFuMy5kb3QodGhpcy5feUF4aXMsIHYpO1xuXG4gICAgaWYgKCFkZWZpbmVkKHJlc3VsdCkpIHtcbiAgICAgIHJldHVybiBuZXcgQ2FydGVzaWFuMih4LCB5KTtcbiAgICB9XG4gICAgcmVzdWx0LnggPSB4O1xuICAgIHJlc3VsdC55ID0geTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG4gIHJldHVybiB1bmRlZmluZWQ7XG59O1xuXG4vKipcbiAqIENvbXB1dGVzIHRoZSBwcm9qZWN0aW9uIG9mIHRoZSBwcm92aWRlZCAzRCBwb3NpdGlvbnMgb250byB0aGUgMkQgcGxhbmUgKHdoZXJlIHBvc3NpYmxlKSwgcmFkaWFsbHkgb3V0d2FyZCBmcm9tIHRoZSBnbG9iYWwgb3JpZ2luLlxuICogVGhlIHJlc3VsdGluZyBhcnJheSBtYXkgYmUgc2hvcnRlciB0aGFuIHRoZSBpbnB1dCBhcnJheSAtIGlmIGEgc2luZ2xlIHByb2plY3Rpb24gaXMgaW1wb3NzaWJsZSBpdCB3aWxsIG5vdCBiZSBpbmNsdWRlZC5cbiAqXG4gKiBAc2VlIEVsbGlwc29pZFRhbmdlbnRQbGFuZS5wcm9qZWN0UG9pbnRPbnRvUGxhbmVcbiAqXG4gKiBAcGFyYW0ge0NhcnRlc2lhbjNbXX0gY2FydGVzaWFucyBUaGUgYXJyYXkgb2YgcG9pbnRzIHRvIHByb2plY3QuXG4gKiBAcGFyYW0ge0NhcnRlc2lhbjJbXX0gW3Jlc3VsdF0gVGhlIGFycmF5IG9mIENhcnRlc2lhbjIgaW5zdGFuY2VzIG9udG8gd2hpY2ggdG8gc3RvcmUgcmVzdWx0cy5cbiAqIEByZXR1cm5zIHtDYXJ0ZXNpYW4yW119IFRoZSBtb2RpZmllZCByZXN1bHQgcGFyYW1ldGVyIG9yIGEgbmV3IGFycmF5IG9mIENhcnRlc2lhbjIgaW5zdGFuY2VzIGlmIG5vbmUgd2FzIHByb3ZpZGVkLlxuICovXG5FbGxpcHNvaWRUYW5nZW50UGxhbmUucHJvdG90eXBlLnByb2plY3RQb2ludHNPbnRvUGxhbmUgPSBmdW5jdGlvbiAoXG4gIGNhcnRlc2lhbnMsXG4gIHJlc3VsdFxuKSB7XG4gIC8vPj5pbmNsdWRlU3RhcnQoJ2RlYnVnJywgcHJhZ21hcy5kZWJ1Zyk7XG4gIENoZWNrLmRlZmluZWQoXCJjYXJ0ZXNpYW5zXCIsIGNhcnRlc2lhbnMpO1xuICAvLz4+aW5jbHVkZUVuZCgnZGVidWcnKTtcblxuICBpZiAoIWRlZmluZWQocmVzdWx0KSkge1xuICAgIHJlc3VsdCA9IFtdO1xuICB9XG5cbiAgdmFyIGNvdW50ID0gMDtcbiAgdmFyIGxlbmd0aCA9IGNhcnRlc2lhbnMubGVuZ3RoO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHAgPSB0aGlzLnByb2plY3RQb2ludE9udG9QbGFuZShjYXJ0ZXNpYW5zW2ldLCByZXN1bHRbY291bnRdKTtcbiAgICBpZiAoZGVmaW5lZChwKSkge1xuICAgICAgcmVzdWx0W2NvdW50XSA9IHA7XG4gICAgICBjb3VudCsrO1xuICAgIH1cbiAgfVxuICByZXN1bHQubGVuZ3RoID0gY291bnQ7XG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG4vKipcbiAqIENvbXB1dGVzIHRoZSBwcm9qZWN0aW9uIG9mIHRoZSBwcm92aWRlZCAzRCBwb3NpdGlvbiBvbnRvIHRoZSAyRCBwbGFuZSwgYWxvbmcgdGhlIHBsYW5lIG5vcm1hbC5cbiAqXG4gKiBAcGFyYW0ge0NhcnRlc2lhbjN9IGNhcnRlc2lhbiBUaGUgcG9pbnQgdG8gcHJvamVjdC5cbiAqIEBwYXJhbSB7Q2FydGVzaWFuMn0gW3Jlc3VsdF0gVGhlIG9iamVjdCBvbnRvIHdoaWNoIHRvIHN0b3JlIHRoZSByZXN1bHQuXG4gKiBAcmV0dXJucyB7Q2FydGVzaWFuMn0gVGhlIG1vZGlmaWVkIHJlc3VsdCBwYXJhbWV0ZXIgb3IgYSBuZXcgQ2FydGVzaWFuMiBpbnN0YW5jZSBpZiBub25lIHdhcyBwcm92aWRlZC5cbiAqL1xuRWxsaXBzb2lkVGFuZ2VudFBsYW5lLnByb3RvdHlwZS5wcm9qZWN0UG9pbnRUb05lYXJlc3RPblBsYW5lID0gZnVuY3Rpb24gKFxuICBjYXJ0ZXNpYW4sXG4gIHJlc3VsdFxuKSB7XG4gIC8vPj5pbmNsdWRlU3RhcnQoJ2RlYnVnJywgcHJhZ21hcy5kZWJ1Zyk7XG4gIENoZWNrLmRlZmluZWQoXCJjYXJ0ZXNpYW5cIiwgY2FydGVzaWFuKTtcbiAgLy8+PmluY2x1ZGVFbmQoJ2RlYnVnJyk7XG5cbiAgaWYgKCFkZWZpbmVkKHJlc3VsdCkpIHtcbiAgICByZXN1bHQgPSBuZXcgQ2FydGVzaWFuMigpO1xuICB9XG5cbiAgdmFyIHJheSA9IHNjcmF0Y2hQcm9qZWN0UG9pbnRPbnRvUGxhbmVSYXk7XG4gIHJheS5vcmlnaW4gPSBjYXJ0ZXNpYW47XG4gIENhcnRlc2lhbjMuY2xvbmUodGhpcy5fcGxhbmUubm9ybWFsLCByYXkuZGlyZWN0aW9uKTtcblxuICB2YXIgaW50ZXJzZWN0aW9uUG9pbnQgPSBJbnRlcnNlY3Rpb25UZXN0cy5yYXlQbGFuZShcbiAgICByYXksXG4gICAgdGhpcy5fcGxhbmUsXG4gICAgc2NyYXRjaFByb2plY3RQb2ludE9udG9QbGFuZUNhcnRlc2lhbjNcbiAgKTtcbiAgaWYgKCFkZWZpbmVkKGludGVyc2VjdGlvblBvaW50KSkge1xuICAgIENhcnRlc2lhbjMubmVnYXRlKHJheS5kaXJlY3Rpb24sIHJheS5kaXJlY3Rpb24pO1xuICAgIGludGVyc2VjdGlvblBvaW50ID0gSW50ZXJzZWN0aW9uVGVzdHMucmF5UGxhbmUoXG4gICAgICByYXksXG4gICAgICB0aGlzLl9wbGFuZSxcbiAgICAgIHNjcmF0Y2hQcm9qZWN0UG9pbnRPbnRvUGxhbmVDYXJ0ZXNpYW4zXG4gICAgKTtcbiAgfVxuXG4gIHZhciB2ID0gQ2FydGVzaWFuMy5zdWJ0cmFjdChcbiAgICBpbnRlcnNlY3Rpb25Qb2ludCxcbiAgICB0aGlzLl9vcmlnaW4sXG4gICAgaW50ZXJzZWN0aW9uUG9pbnRcbiAgKTtcbiAgdmFyIHggPSBDYXJ0ZXNpYW4zLmRvdCh0aGlzLl94QXhpcywgdik7XG4gIHZhciB5ID0gQ2FydGVzaWFuMy5kb3QodGhpcy5feUF4aXMsIHYpO1xuXG4gIHJlc3VsdC54ID0geDtcbiAgcmVzdWx0LnkgPSB5O1xuICByZXR1cm4gcmVzdWx0O1xufTtcblxuLyoqXG4gKiBDb21wdXRlcyB0aGUgcHJvamVjdGlvbiBvZiB0aGUgcHJvdmlkZWQgM0QgcG9zaXRpb25zIG9udG8gdGhlIDJEIHBsYW5lLCBhbG9uZyB0aGUgcGxhbmUgbm9ybWFsLlxuICpcbiAqIEBzZWUgRWxsaXBzb2lkVGFuZ2VudFBsYW5lLnByb2plY3RQb2ludFRvTmVhcmVzdE9uUGxhbmVcbiAqXG4gKiBAcGFyYW0ge0NhcnRlc2lhbjNbXX0gY2FydGVzaWFucyBUaGUgYXJyYXkgb2YgcG9pbnRzIHRvIHByb2plY3QuXG4gKiBAcGFyYW0ge0NhcnRlc2lhbjJbXX0gW3Jlc3VsdF0gVGhlIGFycmF5IG9mIENhcnRlc2lhbjIgaW5zdGFuY2VzIG9udG8gd2hpY2ggdG8gc3RvcmUgcmVzdWx0cy5cbiAqIEByZXR1cm5zIHtDYXJ0ZXNpYW4yW119IFRoZSBtb2RpZmllZCByZXN1bHQgcGFyYW1ldGVyIG9yIGEgbmV3IGFycmF5IG9mIENhcnRlc2lhbjIgaW5zdGFuY2VzIGlmIG5vbmUgd2FzIHByb3ZpZGVkLiBUaGlzIHdpbGwgaGF2ZSB0aGUgc2FtZSBsZW5ndGggYXMgPGNvZGU+Y2FydGVzaWFuczwvY29kZT4uXG4gKi9cbkVsbGlwc29pZFRhbmdlbnRQbGFuZS5wcm90b3R5cGUucHJvamVjdFBvaW50c1RvTmVhcmVzdE9uUGxhbmUgPSBmdW5jdGlvbiAoXG4gIGNhcnRlc2lhbnMsXG4gIHJlc3VsdFxuKSB7XG4gIC8vPj5pbmNsdWRlU3RhcnQoJ2RlYnVnJywgcHJhZ21hcy5kZWJ1Zyk7XG4gIENoZWNrLmRlZmluZWQoXCJjYXJ0ZXNpYW5zXCIsIGNhcnRlc2lhbnMpO1xuICAvLz4+aW5jbHVkZUVuZCgnZGVidWcnKTtcblxuICBpZiAoIWRlZmluZWQocmVzdWx0KSkge1xuICAgIHJlc3VsdCA9IFtdO1xuICB9XG5cbiAgdmFyIGxlbmd0aCA9IGNhcnRlc2lhbnMubGVuZ3RoO1xuICByZXN1bHQubGVuZ3RoID0gbGVuZ3RoO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgcmVzdWx0W2ldID0gdGhpcy5wcm9qZWN0UG9pbnRUb05lYXJlc3RPblBsYW5lKGNhcnRlc2lhbnNbaV0sIHJlc3VsdFtpXSk7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbnZhciBwcm9qZWN0UG9pbnRzT250b0VsbGlwc29pZFNjcmF0Y2ggPSBuZXcgQ2FydGVzaWFuMygpO1xuLyoqXG4gKiBDb21wdXRlcyB0aGUgcHJvamVjdGlvbiBvZiB0aGUgcHJvdmlkZWQgMkQgcG9zaXRpb24gb250byB0aGUgM0QgZWxsaXBzb2lkLlxuICpcbiAqIEBwYXJhbSB7Q2FydGVzaWFuMn0gY2FydGVzaWFuIFRoZSBwb2ludHMgdG8gcHJvamVjdC5cbiAqIEBwYXJhbSB7Q2FydGVzaWFuM30gW3Jlc3VsdF0gVGhlIENhcnRlc2lhbjMgaW5zdGFuY2UgdG8gc3RvcmUgcmVzdWx0LlxuICogQHJldHVybnMge0NhcnRlc2lhbjN9IFRoZSBtb2RpZmllZCByZXN1bHQgcGFyYW1ldGVyIG9yIGEgbmV3IENhcnRlc2lhbjMgaW5zdGFuY2UgaWYgbm9uZSB3YXMgcHJvdmlkZWQuXG4gKi9cbkVsbGlwc29pZFRhbmdlbnRQbGFuZS5wcm90b3R5cGUucHJvamVjdFBvaW50T250b0VsbGlwc29pZCA9IGZ1bmN0aW9uIChcbiAgY2FydGVzaWFuLFxuICByZXN1bHRcbikge1xuICAvLz4+aW5jbHVkZVN0YXJ0KCdkZWJ1ZycsIHByYWdtYXMuZGVidWcpO1xuICBDaGVjay5kZWZpbmVkKFwiY2FydGVzaWFuXCIsIGNhcnRlc2lhbik7XG4gIC8vPj5pbmNsdWRlRW5kKCdkZWJ1ZycpO1xuXG4gIGlmICghZGVmaW5lZChyZXN1bHQpKSB7XG4gICAgcmVzdWx0ID0gbmV3IENhcnRlc2lhbjMoKTtcbiAgfVxuXG4gIHZhciBlbGxpcHNvaWQgPSB0aGlzLl9lbGxpcHNvaWQ7XG4gIHZhciBvcmlnaW4gPSB0aGlzLl9vcmlnaW47XG4gIHZhciB4QXhpcyA9IHRoaXMuX3hBeGlzO1xuICB2YXIgeUF4aXMgPSB0aGlzLl95QXhpcztcbiAgdmFyIHRtcCA9IHByb2plY3RQb2ludHNPbnRvRWxsaXBzb2lkU2NyYXRjaDtcblxuICBDYXJ0ZXNpYW4zLm11bHRpcGx5QnlTY2FsYXIoeEF4aXMsIGNhcnRlc2lhbi54LCB0bXApO1xuICByZXN1bHQgPSBDYXJ0ZXNpYW4zLmFkZChvcmlnaW4sIHRtcCwgcmVzdWx0KTtcbiAgQ2FydGVzaWFuMy5tdWx0aXBseUJ5U2NhbGFyKHlBeGlzLCBjYXJ0ZXNpYW4ueSwgdG1wKTtcbiAgQ2FydGVzaWFuMy5hZGQocmVzdWx0LCB0bXAsIHJlc3VsdCk7XG4gIGVsbGlwc29pZC5zY2FsZVRvR2VvY2VudHJpY1N1cmZhY2UocmVzdWx0LCByZXN1bHQpO1xuXG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG4vKipcbiAqIENvbXB1dGVzIHRoZSBwcm9qZWN0aW9uIG9mIHRoZSBwcm92aWRlZCAyRCBwb3NpdGlvbnMgb250byB0aGUgM0QgZWxsaXBzb2lkLlxuICpcbiAqIEBwYXJhbSB7Q2FydGVzaWFuMltdfSBjYXJ0ZXNpYW5zIFRoZSBhcnJheSBvZiBwb2ludHMgdG8gcHJvamVjdC5cbiAqIEBwYXJhbSB7Q2FydGVzaWFuM1tdfSBbcmVzdWx0XSBUaGUgYXJyYXkgb2YgQ2FydGVzaWFuMyBpbnN0YW5jZXMgb250byB3aGljaCB0byBzdG9yZSByZXN1bHRzLlxuICogQHJldHVybnMge0NhcnRlc2lhbjNbXX0gVGhlIG1vZGlmaWVkIHJlc3VsdCBwYXJhbWV0ZXIgb3IgYSBuZXcgYXJyYXkgb2YgQ2FydGVzaWFuMyBpbnN0YW5jZXMgaWYgbm9uZSB3YXMgcHJvdmlkZWQuXG4gKi9cbkVsbGlwc29pZFRhbmdlbnRQbGFuZS5wcm90b3R5cGUucHJvamVjdFBvaW50c09udG9FbGxpcHNvaWQgPSBmdW5jdGlvbiAoXG4gIGNhcnRlc2lhbnMsXG4gIHJlc3VsdFxuKSB7XG4gIC8vPj5pbmNsdWRlU3RhcnQoJ2RlYnVnJywgcHJhZ21hcy5kZWJ1Zyk7XG4gIENoZWNrLmRlZmluZWQoXCJjYXJ0ZXNpYW5zXCIsIGNhcnRlc2lhbnMpO1xuICAvLz4+aW5jbHVkZUVuZCgnZGVidWcnKTtcblxuICB2YXIgbGVuZ3RoID0gY2FydGVzaWFucy5sZW5ndGg7XG4gIGlmICghZGVmaW5lZChyZXN1bHQpKSB7XG4gICAgcmVzdWx0ID0gbmV3IEFycmF5KGxlbmd0aCk7XG4gIH0gZWxzZSB7XG4gICAgcmVzdWx0Lmxlbmd0aCA9IGxlbmd0aDtcbiAgfVxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kpIHtcbiAgICByZXN1bHRbaV0gPSB0aGlzLnByb2plY3RQb2ludE9udG9FbGxpcHNvaWQoY2FydGVzaWFuc1tpXSwgcmVzdWx0W2ldKTtcbiAgfVxuXG4gIHJldHVybiByZXN1bHQ7XG59O1xuZXhwb3J0IGRlZmF1bHQgRWxsaXBzb2lkVGFuZ2VudFBsYW5lO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///74744\n')},81176:function(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__){eval('/* harmony import */ var _ThirdParty_when_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(13222);\n/* harmony import */ var _defaultValue_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(62200);\n/* harmony import */ var _defined_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(82982);\n/* harmony import */ var _Ellipsoid_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(50491);\n/* harmony import */ var _Event_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(14459);\n/* harmony import */ var _GeographicTilingScheme_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(71351);\n/* harmony import */ var _HeightmapTerrainData_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(57134);\n/* harmony import */ var _TerrainProvider_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(1497);\n\n\n\n\n\n\n\n\n\n/**\n * A very simple {@link TerrainProvider} that produces geometry by tessellating an ellipsoidal\n * surface.\n *\n * @alias EllipsoidTerrainProvider\n * @constructor\n *\n * @param {Object} [options] Object with the following properties:\n * @param {TilingScheme} [options.tilingScheme] The tiling scheme specifying how the ellipsoidal\n * surface is broken into tiles.  If this parameter is not provided, a {@link GeographicTilingScheme}\n * is used.\n * @param {Ellipsoid} [options.ellipsoid] The ellipsoid.  If the tilingScheme is specified,\n * this parameter is ignored and the tiling scheme\'s ellipsoid is used instead. If neither\n * parameter is specified, the WGS84 ellipsoid is used.\n *\n * @see TerrainProvider\n */\nfunction EllipsoidTerrainProvider(options) {\n  options = (0,_defaultValue_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .Z)(options, _defaultValue_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"].EMPTY_OBJECT */ .Z.EMPTY_OBJECT);\n\n  this._tilingScheme = options.tilingScheme;\n  if (!(0,_defined_js__WEBPACK_IMPORTED_MODULE_7__/* ["default"] */ .Z)(this._tilingScheme)) {\n    this._tilingScheme = new _GeographicTilingScheme_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .Z({\n      ellipsoid: (0,_defaultValue_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .Z)(options.ellipsoid, _Ellipsoid_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"].WGS84 */ .Z.WGS84),\n    });\n  }\n\n  // Note: the 64 below does NOT need to match the actual vertex dimensions, because\n  // the ellipsoid is significantly smoother than actual terrain.\n  this._levelZeroMaximumGeometricError = _TerrainProvider_js__WEBPACK_IMPORTED_MODULE_6__/* ["default"].getEstimatedLevelZeroGeometricErrorForAHeightmap */ .Z.getEstimatedLevelZeroGeometricErrorForAHeightmap(\n    this._tilingScheme.ellipsoid,\n    64,\n    this._tilingScheme.getNumberOfXTilesAtLevel(0)\n  );\n\n  this._errorEvent = new _Event_js__WEBPACK_IMPORTED_MODULE_3__/* ["default"] */ .Z();\n  this._readyPromise = _ThirdParty_when_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].resolve */ .Z.resolve(true);\n}\n\nObject.defineProperties(EllipsoidTerrainProvider.prototype, {\n  /**\n   * Gets an event that is raised when the terrain provider encounters an asynchronous error.  By subscribing\n   * to the event, you will be notified of the error and can potentially recover from it.  Event listeners\n   * are passed an instance of {@link TileProviderError}.\n   * @memberof EllipsoidTerrainProvider.prototype\n   * @type {Event}\n   * @readonly\n   */\n  errorEvent: {\n    get: function () {\n      return this._errorEvent;\n    },\n  },\n\n  /**\n   * Gets the credit to display when this terrain provider is active.  Typically this is used to credit\n   * the source of the terrain.  This function should not be called before {@link EllipsoidTerrainProvider#ready} returns true.\n   * @memberof EllipsoidTerrainProvider.prototype\n   * @type {Credit}\n   * @readonly\n   */\n  credit: {\n    get: function () {\n      return undefined;\n    },\n  },\n\n  /**\n   * Gets the tiling scheme used by this provider.  This function should\n   * not be called before {@link EllipsoidTerrainProvider#ready} returns true.\n   * @memberof EllipsoidTerrainProvider.prototype\n   * @type {GeographicTilingScheme}\n   * @readonly\n   */\n  tilingScheme: {\n    get: function () {\n      return this._tilingScheme;\n    },\n  },\n\n  /**\n   * Gets a value indicating whether or not the provider is ready for use.\n   * @memberof EllipsoidTerrainProvider.prototype\n   * @type {Boolean}\n   * @readonly\n   */\n  ready: {\n    get: function () {\n      return true;\n    },\n  },\n\n  /**\n   * Gets a promise that resolves to true when the provider is ready for use.\n   * @memberof EllipsoidTerrainProvider.prototype\n   * @type {Promise.<Boolean>}\n   * @readonly\n   */\n  readyPromise: {\n    get: function () {\n      return this._readyPromise;\n    },\n  },\n\n  /**\n   * Gets a value indicating whether or not the provider includes a water mask.  The water mask\n   * indicates which areas of the globe are water rather than land, so they can be rendered\n   * as a reflective surface with animated waves.  This function should not be\n   * called before {@link EllipsoidTerrainProvider#ready} returns true.\n   * @memberof EllipsoidTerrainProvider.prototype\n   * @type {Boolean}\n   * @readonly\n   */\n  hasWaterMask: {\n    get: function () {\n      return false;\n    },\n  },\n\n  /**\n   * Gets a value indicating whether or not the requested tiles include vertex normals.\n   * This function should not be called before {@link EllipsoidTerrainProvider#ready} returns true.\n   * @memberof EllipsoidTerrainProvider.prototype\n   * @type {Boolean}\n   * @readonly\n   */\n  hasVertexNormals: {\n    get: function () {\n      return false;\n    },\n  },\n  /**\n   * Gets an object that can be used to determine availability of terrain from this provider, such as\n   * at points and in rectangles.  This function should not be called before\n   * {@link TerrainProvider#ready} returns true.  This property may be undefined if availability\n   * information is not available.\n   * @memberof EllipsoidTerrainProvider.prototype\n   * @type {TileAvailability}\n   * @readonly\n   */\n  availability: {\n    get: function () {\n      return undefined;\n    },\n  },\n});\n\n/**\n * Requests the geometry for a given tile.  This function should not be called before\n * {@link TerrainProvider#ready} returns true.  The result includes terrain\n * data and indicates that all child tiles are available.\n *\n * @param {Number} x The X coordinate of the tile for which to request geometry.\n * @param {Number} y The Y coordinate of the tile for which to request geometry.\n * @param {Number} level The level of the tile for which to request geometry.\n * @param {Request} [request] The request object. Intended for internal use only.\n *\n * @returns {Promise.<TerrainData>|undefined} A promise for the requested geometry.  If this method\n *          returns undefined instead of a promise, it is an indication that too many requests are already\n *          pending and the request will be retried later.\n */\nEllipsoidTerrainProvider.prototype.requestTileGeometry = function (\n  x,\n  y,\n  level,\n  request\n) {\n  var width = 16;\n  var height = 16;\n  return _ThirdParty_when_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].resolve */ .Z.resolve(\n    new _HeightmapTerrainData_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"] */ .Z({\n      buffer: new Uint8Array(width * height),\n      width: width,\n      height: height,\n    })\n  );\n};\n\n/**\n * Gets the maximum geometric error allowed in a tile at a given level.\n *\n * @param {Number} level The tile level for which to get the maximum geometric error.\n * @returns {Number} The maximum geometric error.\n */\nEllipsoidTerrainProvider.prototype.getLevelMaximumGeometricError = function (\n  level\n) {\n  return this._levelZeroMaximumGeometricError / (1 << level);\n};\n\n/**\n * Determines whether data for a tile is available to be loaded.\n *\n * @param {Number} x The X coordinate of the tile for which to request geometry.\n * @param {Number} y The Y coordinate of the tile for which to request geometry.\n * @param {Number} level The level of the tile for which to request geometry.\n * @returns {Boolean|undefined} Undefined if not supported, otherwise true or false.\n */\nEllipsoidTerrainProvider.prototype.getTileDataAvailable = function (\n  x,\n  y,\n  level\n) {\n  return undefined;\n};\n\n/**\n * Makes sure we load availability data for a tile\n *\n * @param {Number} x The X coordinate of the tile for which to request geometry.\n * @param {Number} y The Y coordinate of the tile for which to request geometry.\n * @param {Number} level The level of the tile for which to request geometry.\n * @returns {undefined|Promise<void>} Undefined if nothing need to be loaded or a Promise that resolves when all required tiles are loaded\n */\nEllipsoidTerrainProvider.prototype.loadTileDataAvailability = function (\n  x,\n  y,\n  level\n) {\n  return undefined;\n};\n/* harmony default export */ __webpack_exports__["Z"] = (EllipsoidTerrainProvider);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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ZTMtd2VicGFjazUvLi9ub2RlX21vZHVsZXMvY2VzaXVtL1NvdXJjZS9Db3JlL0VsbGlwc29pZFRlcnJhaW5Qcm92aWRlci5qcz9jMzQzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB3aGVuIGZyb20gXCIuLi9UaGlyZFBhcnR5L3doZW4uanNcIjtcbmltcG9ydCBkZWZhdWx0VmFsdWUgZnJvbSBcIi4vZGVmYXVsdFZhbHVlLmpzXCI7XG5pbXBvcnQgZGVmaW5lZCBmcm9tIFwiLi9kZWZpbmVkLmpzXCI7XG5pbXBvcnQgRWxsaXBzb2lkIGZyb20gXCIuL0VsbGlwc29pZC5qc1wiO1xuaW1wb3J0IEV2ZW50IGZyb20gXCIuL0V2ZW50LmpzXCI7XG5pbXBvcnQgR2VvZ3JhcGhpY1RpbGluZ1NjaGVtZSBmcm9tIFwiLi9HZW9ncmFwaGljVGlsaW5nU2NoZW1lLmpzXCI7XG5pbXBvcnQgSGVpZ2h0bWFwVGVycmFpbkRhdGEgZnJvbSBcIi4vSGVpZ2h0bWFwVGVycmFpbkRhdGEuanNcIjtcbmltcG9ydCBUZXJyYWluUHJvdmlkZXIgZnJvbSBcIi4vVGVycmFpblByb3ZpZGVyLmpzXCI7XG5cbi8qKlxuICogQSB2ZXJ5IHNpbXBsZSB7QGxpbmsgVGVycmFpblByb3ZpZGVyfSB0aGF0IHByb2R1Y2VzIGdlb21ldHJ5IGJ5IHRlc3NlbGxhdGluZyBhbiBlbGxpcHNvaWRhbFxuICogc3VyZmFjZS5cbiAqXG4gKiBAYWxpYXMgRWxsaXBzb2lkVGVycmFpblByb3ZpZGVyXG4gKiBAY29uc3RydWN0b3JcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIE9iamVjdCB3aXRoIHRoZSBmb2xsb3dpbmcgcHJvcGVydGllczpcbiAqIEBwYXJhbSB7VGlsaW5nU2NoZW1lfSBbb3B0aW9ucy50aWxpbmdTY2hlbWVdIFRoZSB0aWxpbmcgc2NoZW1lIHNwZWNpZnlpbmcgaG93IHRoZSBlbGxpcHNvaWRhbFxuICogc3VyZmFjZSBpcyBicm9rZW4gaW50byB0aWxlcy4gIElmIHRoaXMgcGFyYW1ldGVyIGlzIG5vdCBwcm92aWRlZCwgYSB7QGxpbmsgR2VvZ3JhcGhpY1RpbGluZ1NjaGVtZX1cbiAqIGlzIHVzZWQuXG4gKiBAcGFyYW0ge0VsbGlwc29pZH0gW29wdGlvbnMuZWxsaXBzb2lkXSBUaGUgZWxsaXBzb2lkLiAgSWYgdGhlIHRpbGluZ1NjaGVtZSBpcyBzcGVjaWZpZWQsXG4gKiB0aGlzIHBhcmFtZXRlciBpcyBpZ25vcmVkIGFuZCB0aGUgdGlsaW5nIHNjaGVtZSdzIGVsbGlwc29pZCBpcyB1c2VkIGluc3RlYWQuIElmIG5laXRoZXJcbiAqIHBhcmFtZXRlciBpcyBzcGVjaWZpZWQsIHRoZSBXR1M4NCBlbGxpcHNvaWQgaXMgdXNlZC5cbiAqXG4gKiBAc2VlIFRlcnJhaW5Qcm92aWRlclxuICovXG5mdW5jdGlvbiBFbGxpcHNvaWRUZXJyYWluUHJvdmlkZXIob3B0aW9ucykge1xuICBvcHRpb25zID0gZGVmYXVsdFZhbHVlKG9wdGlvbnMsIGRlZmF1bHRWYWx1ZS5FTVBUWV9PQkpFQ1QpO1xuXG4gIHRoaXMuX3RpbGluZ1NjaGVtZSA9IG9wdGlvbnMudGlsaW5nU2NoZW1lO1xuICBpZiAoIWRlZmluZWQodGhpcy5fdGlsaW5nU2NoZW1lKSkge1xuICAgIHRoaXMuX3RpbGluZ1NjaGVtZSA9IG5ldyBHZW9ncmFwaGljVGlsaW5nU2NoZW1lKHtcbiAgICAgIGVsbGlwc29pZDogZGVmYXVsdFZhbHVlKG9wdGlvbnMuZWxsaXBzb2lkLCBFbGxpcHNvaWQuV0dTODQpLFxuICAgIH0pO1xuICB9XG5cbiAgLy8gTm90ZTogdGhlIDY0IGJlbG93IGRvZXMgTk9UIG5lZWQgdG8gbWF0Y2ggdGhlIGFjdHVhbCB2ZXJ0ZXggZGltZW5zaW9ucywgYmVjYXVzZVxuICAvLyB0aGUgZWxsaXBzb2lkIGlzIHNpZ25pZmljYW50bHkgc21vb3RoZXIgdGhhbiBhY3R1YWwgdGVycmFpbi5cbiAgdGhpcy5fbGV2ZWxaZXJvTWF4aW11bUdlb21ldHJpY0Vycm9yID0gVGVycmFpblByb3ZpZGVyLmdldEVzdGltYXRlZExldmVsWmVyb0dlb21ldHJpY0Vycm9yRm9yQUhlaWdodG1hcChcbiAgICB0aGlzLl90aWxpbmdTY2hlbWUuZWxsaXBzb2lkLFxuICAgIDY0LFxuICAgIHRoaXMuX3RpbGluZ1NjaGVtZS5nZXROdW1iZXJPZlhUaWxlc0F0TGV2ZWwoMClcbiAgKTtcblxuICB0aGlzLl9lcnJvckV2ZW50ID0gbmV3IEV2ZW50KCk7XG4gIHRoaXMuX3JlYWR5UHJvbWlzZSA9IHdoZW4ucmVzb2x2ZSh0cnVlKTtcbn1cblxuT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoRWxsaXBzb2lkVGVycmFpblByb3ZpZGVyLnByb3RvdHlwZSwge1xuICAvKipcbiAgICogR2V0cyBhbiBldmVudCB0aGF0IGlzIHJhaXNlZCB3aGVuIHRoZSB0ZXJyYWluIHByb3ZpZGVyIGVuY291bnRlcnMgYW4gYXN5bmNocm9ub3VzIGVycm9yLiAgQnkgc3Vic2NyaWJpbmdcbiAgICogdG8gdGhlIGV2ZW50LCB5b3Ugd2lsbCBiZSBub3RpZmllZCBvZiB0aGUgZXJyb3IgYW5kIGNhbiBwb3RlbnRpYWxseSByZWNvdmVyIGZyb20gaXQuICBFdmVudCBsaXN0ZW5lcnNcbiAgICogYXJlIHBhc3NlZCBhbiBpbnN0YW5jZSBvZiB7QGxpbmsgVGlsZVByb3ZpZGVyRXJyb3J9LlxuICAgKiBAbWVtYmVyb2YgRWxsaXBzb2lkVGVycmFpblByb3ZpZGVyLnByb3RvdHlwZVxuICAgKiBAdHlwZSB7RXZlbnR9XG4gICAqIEByZWFkb25seVxuICAgKi9cbiAgZXJyb3JFdmVudDoge1xuICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX2Vycm9yRXZlbnQ7XG4gICAgfSxcbiAgfSxcblxuICAvKipcbiAgICogR2V0cyB0aGUgY3JlZGl0IHRvIGRpc3BsYXkgd2hlbiB0aGlzIHRlcnJhaW4gcHJvdmlkZXIgaXMgYWN0aXZlLiAgVHlwaWNhbGx5IHRoaXMgaXMgdXNlZCB0byBjcmVkaXRcbiAgICogdGhlIHNvdXJjZSBvZiB0aGUgdGVycmFpbi4gIFRoaXMgZnVuY3Rpb24gc2hvdWxkIG5vdCBiZSBjYWxsZWQgYmVmb3JlIHtAbGluayBFbGxpcHNvaWRUZXJyYWluUHJvdmlkZXIjcmVhZHl9IHJldHVybnMgdHJ1ZS5cbiAgICogQG1lbWJlcm9mIEVsbGlwc29pZFRlcnJhaW5Qcm92aWRlci5wcm90b3R5cGVcbiAgICogQHR5cGUge0NyZWRpdH1cbiAgICogQHJlYWRvbmx5XG4gICAqL1xuICBjcmVkaXQ6IHtcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfSxcbiAgfSxcblxuICAvKipcbiAgICogR2V0cyB0aGUgdGlsaW5nIHNjaGVtZSB1c2VkIGJ5IHRoaXMgcHJvdmlkZXIuICBUaGlzIGZ1bmN0aW9uIHNob3VsZFxuICAgKiBub3QgYmUgY2FsbGVkIGJlZm9yZSB7QGxpbmsgRWxsaXBzb2lkVGVycmFpblByb3ZpZGVyI3JlYWR5fSByZXR1cm5zIHRydWUuXG4gICAqIEBtZW1iZXJvZiBFbGxpcHNvaWRUZXJyYWluUHJvdmlkZXIucHJvdG90eXBlXG4gICAqIEB0eXBlIHtHZW9ncmFwaGljVGlsaW5nU2NoZW1lfVxuICAgKiBAcmVhZG9ubHlcbiAgICovXG4gIHRpbGluZ1NjaGVtZToge1xuICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX3RpbGluZ1NjaGVtZTtcbiAgICB9LFxuICB9LFxuXG4gIC8qKlxuICAgKiBHZXRzIGEgdmFsdWUgaW5kaWNhdGluZyB3aGV0aGVyIG9yIG5vdCB0aGUgcHJvdmlkZXIgaXMgcmVhZHkgZm9yIHVzZS5cbiAgICogQG1lbWJlcm9mIEVsbGlwc29pZFRlcnJhaW5Qcm92aWRlci5wcm90b3R5cGVcbiAgICogQHR5cGUge0Jvb2xlYW59XG4gICAqIEByZWFkb25seVxuICAgKi9cbiAgcmVhZHk6IHtcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0sXG4gIH0sXG5cbiAgLyoqXG4gICAqIEdldHMgYSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gdHJ1ZSB3aGVuIHRoZSBwcm92aWRlciBpcyByZWFkeSBmb3IgdXNlLlxuICAgKiBAbWVtYmVyb2YgRWxsaXBzb2lkVGVycmFpblByb3ZpZGVyLnByb3RvdHlwZVxuICAgKiBAdHlwZSB7UHJvbWlzZS48Qm9vbGVhbj59XG4gICAqIEByZWFkb25seVxuICAgKi9cbiAgcmVhZHlQcm9taXNlOiB7XG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fcmVhZHlQcm9taXNlO1xuICAgIH0sXG4gIH0sXG5cbiAgLyoqXG4gICAqIEdldHMgYSB2YWx1ZSBpbmRpY2F0aW5nIHdoZXRoZXIgb3Igbm90IHRoZSBwcm92aWRlciBpbmNsdWRlcyBhIHdhdGVyIG1hc2suICBUaGUgd2F0ZXIgbWFza1xuICAgKiBpbmRpY2F0ZXMgd2hpY2ggYXJlYXMgb2YgdGhlIGdsb2JlIGFyZSB3YXRlciByYXRoZXIgdGhhbiBsYW5kLCBzbyB0aGV5IGNhbiBiZSByZW5kZXJlZFxuICAgKiBhcyBhIHJlZmxlY3RpdmUgc3VyZmFjZSB3aXRoIGFuaW1hdGVkIHdhdmVzLiAgVGhpcyBmdW5jdGlvbiBzaG91bGQgbm90IGJlXG4gICAqIGNhbGxlZCBiZWZvcmUge0BsaW5rIEVsbGlwc29pZFRlcnJhaW5Qcm92aWRlciNyZWFkeX0gcmV0dXJucyB0cnVlLlxuICAgKiBAbWVtYmVyb2YgRWxsaXBzb2lkVGVycmFpblByb3ZpZGVyLnByb3RvdHlwZVxuICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICogQHJlYWRvbmx5XG4gICAqL1xuICBoYXNXYXRlck1hc2s6IHtcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9LFxuICB9LFxuXG4gIC8qKlxuICAgKiBHZXRzIGEgdmFsdWUgaW5kaWNhdGluZyB3aGV0aGVyIG9yIG5vdCB0aGUgcmVxdWVzdGVkIHRpbGVzIGluY2x1ZGUgdmVydGV4IG5vcm1hbHMuXG4gICAqIFRoaXMgZnVuY3Rpb24gc2hvdWxkIG5vdCBiZSBjYWxsZWQgYmVmb3JlIHtAbGluayBFbGxpcHNvaWRUZXJyYWluUHJvdmlkZXIjcmVhZHl9IHJldHVybnMgdHJ1ZS5cbiAgICogQG1lbWJlcm9mIEVsbGlwc29pZFRlcnJhaW5Qcm92aWRlci5wcm90b3R5cGVcbiAgICogQHR5cGUge0Jvb2xlYW59XG4gICAqIEByZWFkb25seVxuICAgKi9cbiAgaGFzVmVydGV4Tm9ybWFsczoge1xuICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0sXG4gIH0sXG4gIC8qKlxuICAgKiBHZXRzIGFuIG9iamVjdCB0aGF0IGNhbiBiZSB1c2VkIHRvIGRldGVybWluZSBhdmFpbGFiaWxpdHkgb2YgdGVycmFpbiBmcm9tIHRoaXMgcHJvdmlkZXIsIHN1Y2ggYXNcbiAgICogYXQgcG9pbnRzIGFuZCBpbiByZWN0YW5nbGVzLiAgVGhpcyBmdW5jdGlvbiBzaG91bGQgbm90IGJlIGNhbGxlZCBiZWZvcmVcbiAgICoge0BsaW5rIFRlcnJhaW5Qcm92aWRlciNyZWFkeX0gcmV0dXJucyB0cnVlLiAgVGhpcyBwcm9wZXJ0eSBtYXkgYmUgdW5kZWZpbmVkIGlmIGF2YWlsYWJpbGl0eVxuICAgKiBpbmZvcm1hdGlvbiBpcyBub3QgYXZhaWxhYmxlLlxuICAgKiBAbWVtYmVyb2YgRWxsaXBzb2lkVGVycmFpblByb3ZpZGVyLnByb3RvdHlwZVxuICAgKiBAdHlwZSB7VGlsZUF2YWlsYWJpbGl0eX1cbiAgICogQHJlYWRvbmx5XG4gICAqL1xuICBhdmFpbGFiaWxpdHk6IHtcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfSxcbiAgfSxcbn0pO1xuXG4vKipcbiAqIFJlcXVlc3RzIHRoZSBnZW9tZXRyeSBmb3IgYSBnaXZlbiB0aWxlLiAgVGhpcyBmdW5jdGlvbiBzaG91bGQgbm90IGJlIGNhbGxlZCBiZWZvcmVcbiAqIHtAbGluayBUZXJyYWluUHJvdmlkZXIjcmVhZHl9IHJldHVybnMgdHJ1ZS4gIFRoZSByZXN1bHQgaW5jbHVkZXMgdGVycmFpblxuICogZGF0YSBhbmQgaW5kaWNhdGVzIHRoYXQgYWxsIGNoaWxkIHRpbGVzIGFyZSBhdmFpbGFibGUuXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IHggVGhlIFggY29vcmRpbmF0ZSBvZiB0aGUgdGlsZSBmb3Igd2hpY2ggdG8gcmVxdWVzdCBnZW9tZXRyeS5cbiAqIEBwYXJhbSB7TnVtYmVyfSB5IFRoZSBZIGNvb3JkaW5hdGUgb2YgdGhlIHRpbGUgZm9yIHdoaWNoIHRvIHJlcXVlc3QgZ2VvbWV0cnkuXG4gKiBAcGFyYW0ge051bWJlcn0gbGV2ZWwgVGhlIGxldmVsIG9mIHRoZSB0aWxlIGZvciB3aGljaCB0byByZXF1ZXN0IGdlb21ldHJ5LlxuICogQHBhcmFtIHtSZXF1ZXN0fSBbcmVxdWVzdF0gVGhlIHJlcXVlc3Qgb2JqZWN0LiBJbnRlbmRlZCBmb3IgaW50ZXJuYWwgdXNlIG9ubHkuXG4gKlxuICogQHJldHVybnMge1Byb21pc2UuPFRlcnJhaW5EYXRhPnx1bmRlZmluZWR9IEEgcHJvbWlzZSBmb3IgdGhlIHJlcXVlc3RlZCBnZW9tZXRyeS4gIElmIHRoaXMgbWV0aG9kXG4gKiAgICAgICAgICByZXR1cm5zIHVuZGVmaW5lZCBpbnN0ZWFkIG9mIGEgcHJvbWlzZSwgaXQgaXMgYW4gaW5kaWNhdGlvbiB0aGF0IHRvbyBtYW55IHJlcXVlc3RzIGFyZSBhbHJlYWR5XG4gKiAgICAgICAgICBwZW5kaW5nIGFuZCB0aGUgcmVxdWVzdCB3aWxsIGJlIHJldHJpZWQgbGF0ZXIuXG4gKi9cbkVsbGlwc29pZFRlcnJhaW5Qcm92aWRlci5wcm90b3R5cGUucmVxdWVzdFRpbGVHZW9tZXRyeSA9IGZ1bmN0aW9uIChcbiAgeCxcbiAgeSxcbiAgbGV2ZWwsXG4gIHJlcXVlc3Rcbikge1xuICB2YXIgd2lkdGggPSAxNjtcbiAgdmFyIGhlaWdodCA9IDE2O1xuICByZXR1cm4gd2hlbi5yZXNvbHZlKFxuICAgIG5ldyBIZWlnaHRtYXBUZXJyYWluRGF0YSh7XG4gICAgICBidWZmZXI6IG5ldyBVaW50OEFycmF5KHdpZHRoICogaGVpZ2h0KSxcbiAgICAgIHdpZHRoOiB3aWR0aCxcbiAgICAgIGhlaWdodDogaGVpZ2h0LFxuICAgIH0pXG4gICk7XG59O1xuXG4vKipcbiAqIEdldHMgdGhlIG1heGltdW0gZ2VvbWV0cmljIGVycm9yIGFsbG93ZWQgaW4gYSB0aWxlIGF0IGEgZ2l2ZW4gbGV2ZWwuXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IGxldmVsIFRoZSB0aWxlIGxldmVsIGZvciB3aGljaCB0byBnZXQgdGhlIG1heGltdW0gZ2VvbWV0cmljIGVycm9yLlxuICogQHJldHVybnMge051bWJlcn0gVGhlIG1heGltdW0gZ2VvbWV0cmljIGVycm9yLlxuICovXG5FbGxpcHNvaWRUZXJyYWluUHJvdmlkZXIucHJvdG90eXBlLmdldExldmVsTWF4aW11bUdlb21ldHJpY0Vycm9yID0gZnVuY3Rpb24gKFxuICBsZXZlbFxuKSB7XG4gIHJldHVybiB0aGlzLl9sZXZlbFplcm9NYXhpbXVtR2VvbWV0cmljRXJyb3IgLyAoMSA8PCBsZXZlbCk7XG59O1xuXG4vKipcbiAqIERldGVybWluZXMgd2hldGhlciBkYXRhIGZvciBhIHRpbGUgaXMgYXZhaWxhYmxlIHRvIGJlIGxvYWRlZC5cbiAqXG4gKiBAcGFyYW0ge051bWJlcn0geCBUaGUgWCBjb29yZGluYXRlIG9mIHRoZSB0aWxlIGZvciB3aGljaCB0byByZXF1ZXN0IGdlb21ldHJ5LlxuICogQHBhcmFtIHtOdW1iZXJ9IHkgVGhlIFkgY29vcmRpbmF0ZSBvZiB0aGUgdGlsZSBmb3Igd2hpY2ggdG8gcmVxdWVzdCBnZW9tZXRyeS5cbiAqIEBwYXJhbSB7TnVtYmVyfSBsZXZlbCBUaGUgbGV2ZWwgb2YgdGhlIHRpbGUgZm9yIHdoaWNoIHRvIHJlcXVlc3QgZ2VvbWV0cnkuXG4gKiBAcmV0dXJucyB7Qm9vbGVhbnx1bmRlZmluZWR9IFVuZGVmaW5lZCBpZiBub3Qgc3VwcG9ydGVkLCBvdGhlcndpc2UgdHJ1ZSBvciBmYWxzZS5cbiAqL1xuRWxsaXBzb2lkVGVycmFpblByb3ZpZGVyLnByb3RvdHlwZS5nZXRUaWxlRGF0YUF2YWlsYWJsZSA9IGZ1bmN0aW9uIChcbiAgeCxcbiAgeSxcbiAgbGV2ZWxcbikge1xuICByZXR1cm4gdW5kZWZpbmVkO1xufTtcblxuLyoqXG4gKiBNYWtlcyBzdXJlIHdlIGxvYWQgYXZhaWxhYmlsaXR5IGRhdGEgZm9yIGEgdGlsZVxuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSB4IFRoZSBYIGNvb3JkaW5hdGUgb2YgdGhlIHRpbGUgZm9yIHdoaWNoIHRvIHJlcXVlc3QgZ2VvbWV0cnkuXG4gKiBAcGFyYW0ge051bWJlcn0geSBUaGUgWSBjb29yZGluYXRlIG9mIHRoZSB0aWxlIGZvciB3aGljaCB0byByZXF1ZXN0IGdlb21ldHJ5LlxuICogQHBhcmFtIHtOdW1iZXJ9IGxldmVsIFRoZSBsZXZlbCBvZiB0aGUgdGlsZSBmb3Igd2hpY2ggdG8gcmVxdWVzdCBnZW9tZXRyeS5cbiAqIEByZXR1cm5zIHt1bmRlZmluZWR8UHJvbWlzZTx2b2lkPn0gVW5kZWZpbmVkIGlmIG5vdGhpbmcgbmVlZCB0byBiZSBsb2FkZWQgb3IgYSBQcm9taXNlIHRoYXQgcmVzb2x2ZXMgd2hlbiBhbGwgcmVxdWlyZWQgdGlsZXMgYXJlIGxvYWRlZFxuICovXG5FbGxpcHNvaWRUZXJyYWluUHJvdmlkZXIucHJvdG90eXBlLmxvYWRUaWxlRGF0YUF2YWlsYWJpbGl0eSA9IGZ1bmN0aW9uIChcbiAgeCxcbiAgeSxcbiAgbGV2ZWxcbikge1xuICByZXR1cm4gdW5kZWZpbmVkO1xufTtcbmV4cG9ydCBkZWZhdWx0IEVsbGlwc29pZFRlcnJhaW5Qcm92aWRlcjtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///81176\n')},61252:function(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__){eval('/* harmony import */ var _BoundingSphere_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(48243);\n/* harmony import */ var _Cartesian3_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(60216);\n/* harmony import */ var _Check_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(66553);\n/* harmony import */ var _defaultValue_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(62200);\n/* harmony import */ var _defined_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(82982);\n/* harmony import */ var _Ellipsoid_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(50491);\n/* harmony import */ var _Rectangle_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(96190);\n\n\n\n\n\n\n\n\n/**\n * Determine whether or not other objects are visible or hidden behind the visible horizon defined by\n * an {@link Ellipsoid} and a camera position.  The ellipsoid is assumed to be located at the\n * origin of the coordinate system.  This class uses the algorithm described in the\n * {@link https://cesium.com/blog/2013/04/25/Horizon-culling/|Horizon Culling} blog post.\n *\n * @alias EllipsoidalOccluder\n *\n * @param {Ellipsoid} ellipsoid The ellipsoid to use as an occluder.\n * @param {Cartesian3} [cameraPosition] The coordinate of the viewer/camera.  If this parameter is not\n *        specified, {@link EllipsoidalOccluder#cameraPosition} must be called before\n *        testing visibility.\n *\n * @constructor\n *\n * @example\n * // Construct an ellipsoidal occluder with radii 1.0, 1.1, and 0.9.\n * var cameraPosition = new Cesium.Cartesian3(5.0, 6.0, 7.0);\n * var occluderEllipsoid = new Cesium.Ellipsoid(1.0, 1.1, 0.9);\n * var occluder = new Cesium.EllipsoidalOccluder(occluderEllipsoid, cameraPosition);\n *\n * @private\n */\nfunction EllipsoidalOccluder(ellipsoid, cameraPosition) {\n  //>>includeStart(\'debug\', pragmas.debug);\n  _Check_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"].typeOf.object */ .Z.typeOf.object("ellipsoid", ellipsoid);\n  //>>includeEnd(\'debug\');\n\n  this._ellipsoid = ellipsoid;\n  this._cameraPosition = new _Cartesian3_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .Z();\n  this._cameraPositionInScaledSpace = new _Cartesian3_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .Z();\n  this._distanceToLimbInScaledSpaceSquared = 0.0;\n\n  // cameraPosition fills in the above values\n  if ((0,_defined_js__WEBPACK_IMPORTED_MODULE_6__/* ["default"] */ .Z)(cameraPosition)) {\n    this.cameraPosition = cameraPosition;\n  }\n}\n\nObject.defineProperties(EllipsoidalOccluder.prototype, {\n  /**\n   * Gets the occluding ellipsoid.\n   * @memberof EllipsoidalOccluder.prototype\n   * @type {Ellipsoid}\n   */\n  ellipsoid: {\n    get: function () {\n      return this._ellipsoid;\n    },\n  },\n  /**\n   * Gets or sets the position of the camera.\n   * @memberof EllipsoidalOccluder.prototype\n   * @type {Cartesian3}\n   */\n  cameraPosition: {\n    get: function () {\n      return this._cameraPosition;\n    },\n    set: function (cameraPosition) {\n      // See https://cesium.com/blog/2013/04/25/Horizon-culling/\n      var ellipsoid = this._ellipsoid;\n      var cv = ellipsoid.transformPositionToScaledSpace(\n        cameraPosition,\n        this._cameraPositionInScaledSpace\n      );\n      var vhMagnitudeSquared = _Cartesian3_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"].magnitudeSquared */ .Z.magnitudeSquared(cv) - 1.0;\n\n      _Cartesian3_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"].clone */ .Z.clone(cameraPosition, this._cameraPosition);\n      this._cameraPositionInScaledSpace = cv;\n      this._distanceToLimbInScaledSpaceSquared = vhMagnitudeSquared;\n    },\n  },\n});\n\nvar scratchCartesian = new _Cartesian3_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .Z();\n\n/**\n * Determines whether or not a point, the <code>occludee</code>, is hidden from view by the occluder.\n *\n * @param {Cartesian3} occludee The point to test for visibility.\n * @returns {Boolean} <code>true</code> if the occludee is visible; otherwise <code>false</code>.\n *\n * @example\n * var cameraPosition = new Cesium.Cartesian3(0, 0, 2.5);\n * var ellipsoid = new Cesium.Ellipsoid(1.0, 1.1, 0.9);\n * var occluder = new Cesium.EllipsoidalOccluder(ellipsoid, cameraPosition);\n * var point = new Cesium.Cartesian3(0, -3, -3);\n * occluder.isPointVisible(point); //returns true\n */\nEllipsoidalOccluder.prototype.isPointVisible = function (occludee) {\n  var ellipsoid = this._ellipsoid;\n  var occludeeScaledSpacePosition = ellipsoid.transformPositionToScaledSpace(\n    occludee,\n    scratchCartesian\n  );\n  return isScaledSpacePointVisible(\n    occludeeScaledSpacePosition,\n    this._cameraPositionInScaledSpace,\n    this._distanceToLimbInScaledSpaceSquared\n  );\n};\n\n/**\n * Determines whether or not a point expressed in the ellipsoid scaled space, is hidden from view by the\n * occluder.  To transform a Cartesian X, Y, Z position in the coordinate system aligned with the ellipsoid\n * into the scaled space, call {@link Ellipsoid#transformPositionToScaledSpace}.\n *\n * @param {Cartesian3} occludeeScaledSpacePosition The point to test for visibility, represented in the scaled space.\n * @returns {Boolean} <code>true</code> if the occludee is visible; otherwise <code>false</code>.\n *\n * @example\n * var cameraPosition = new Cesium.Cartesian3(0, 0, 2.5);\n * var ellipsoid = new Cesium.Ellipsoid(1.0, 1.1, 0.9);\n * var occluder = new Cesium.EllipsoidalOccluder(ellipsoid, cameraPosition);\n * var point = new Cesium.Cartesian3(0, -3, -3);\n * var scaledSpacePoint = ellipsoid.transformPositionToScaledSpace(point);\n * occluder.isScaledSpacePointVisible(scaledSpacePoint); //returns true\n */\nEllipsoidalOccluder.prototype.isScaledSpacePointVisible = function (\n  occludeeScaledSpacePosition\n) {\n  return isScaledSpacePointVisible(\n    occludeeScaledSpacePosition,\n    this._cameraPositionInScaledSpace,\n    this._distanceToLimbInScaledSpaceSquared\n  );\n};\n\nvar scratchCameraPositionInScaledSpaceShrunk = new _Cartesian3_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .Z();\n\n/**\n * Similar to {@link EllipsoidalOccluder#isScaledSpacePointVisible} except tests against an\n * ellipsoid that has been shrunk by the minimum height when the minimum height is below\n * the ellipsoid. This is intended to be used with points generated by\n * {@link EllipsoidalOccluder#computeHorizonCullingPointPossiblyUnderEllipsoid} or\n * {@link EllipsoidalOccluder#computeHorizonCullingPointFromVerticesPossiblyUnderEllipsoid}.\n *\n * @param {Cartesian3} occludeeScaledSpacePosition The point to test for visibility, represented in the scaled space of the possibly-shrunk ellipsoid.\n * @returns {Boolean} <code>true</code> if the occludee is visible; otherwise <code>false</code>.\n */\nEllipsoidalOccluder.prototype.isScaledSpacePointVisiblePossiblyUnderEllipsoid = function (\n  occludeeScaledSpacePosition,\n  minimumHeight\n) {\n  var ellipsoid = this._ellipsoid;\n  var vhMagnitudeSquared;\n  var cv;\n\n  if (\n    (0,_defined_js__WEBPACK_IMPORTED_MODULE_6__/* ["default"] */ .Z)(minimumHeight) &&\n    minimumHeight < 0.0 &&\n    ellipsoid.minimumRadius > -minimumHeight\n  ) {\n    // This code is similar to the cameraPosition setter, but unrolled for performance because it will be called a lot.\n    cv = scratchCameraPositionInScaledSpaceShrunk;\n    cv.x = this._cameraPosition.x / (ellipsoid.radii.x + minimumHeight);\n    cv.y = this._cameraPosition.y / (ellipsoid.radii.y + minimumHeight);\n    cv.z = this._cameraPosition.z / (ellipsoid.radii.z + minimumHeight);\n    vhMagnitudeSquared = cv.x * cv.x + cv.y * cv.y + cv.z * cv.z - 1.0;\n  } else {\n    cv = this._cameraPositionInScaledSpace;\n    vhMagnitudeSquared = this._distanceToLimbInScaledSpaceSquared;\n  }\n\n  return isScaledSpacePointVisible(\n    occludeeScaledSpacePosition,\n    cv,\n    vhMagnitudeSquared\n  );\n};\n\n/**\n * Computes a point that can be used for horizon culling from a list of positions.  If the point is below\n * the horizon, all of the positions are guaranteed to be below the horizon as well.  The returned point\n * is expressed in the ellipsoid-scaled space and is suitable for use with\n * {@link EllipsoidalOccluder#isScaledSpacePointVisible}.\n *\n * @param {Cartesian3} directionToPoint The direction that the computed point will lie along.\n *                     A reasonable direction to use is the direction from the center of the ellipsoid to\n *                     the center of the bounding sphere computed from the positions.  The direction need not\n *                     be normalized.\n * @param {Cartesian3[]} positions The positions from which to compute the horizon culling point.  The positions\n *                       must be expressed in a reference frame centered at the ellipsoid and aligned with the\n *                       ellipsoid\'s axes.\n * @param {Cartesian3} [result] The instance on which to store the result instead of allocating a new instance.\n * @returns {Cartesian3} The computed horizon culling point, expressed in the ellipsoid-scaled space.\n */\nEllipsoidalOccluder.prototype.computeHorizonCullingPoint = function (\n  directionToPoint,\n  positions,\n  result\n) {\n  return computeHorizonCullingPointFromPositions(\n    this._ellipsoid,\n    directionToPoint,\n    positions,\n    result\n  );\n};\n\nvar scratchEllipsoidShrunk = _Ellipsoid_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"].clone */ .Z.clone(_Ellipsoid_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"].UNIT_SPHERE */ .Z.UNIT_SPHERE);\n\n/**\n * Similar to {@link EllipsoidalOccluder#computeHorizonCullingPoint} except computes the culling\n * point relative to an ellipsoid that has been shrunk by the minimum height when the minimum height is below\n * the ellipsoid. The returned point is expressed in the possibly-shrunk ellipsoid-scaled space and is suitable\n * for use with {@link EllipsoidalOccluder#isScaledSpacePointVisiblePossiblyUnderEllipsoid}.\n *\n * @param {Cartesian3} directionToPoint The direction that the computed point will lie along.\n *                     A reasonable direction to use is the direction from the center of the ellipsoid to\n *                     the center of the bounding sphere computed from the positions.  The direction need not\n *                     be normalized.\n * @param {Cartesian3[]} positions The positions from which to compute the horizon culling point.  The positions\n *                       must be expressed in a reference frame centered at the ellipsoid and aligned with the\n *                       ellipsoid\'s axes.\n * @param {Number} [minimumHeight] The minimum height of all positions. If this value is undefined, all positions are assumed to be above the ellipsoid.\n * @param {Cartesian3} [result] The instance on which to store the result instead of allocating a new instance.\n * @returns {Cartesian3} The computed horizon culling point, expressed in the possibly-shrunk ellipsoid-scaled space.\n */\nEllipsoidalOccluder.prototype.computeHorizonCullingPointPossiblyUnderEllipsoid = function (\n  directionToPoint,\n  positions,\n  minimumHeight,\n  result\n) {\n  var possiblyShrunkEllipsoid = getPossiblyShrunkEllipsoid(\n    this._ellipsoid,\n    minimumHeight,\n    scratchEllipsoidShrunk\n  );\n  return computeHorizonCullingPointFromPositions(\n    possiblyShrunkEllipsoid,\n    directionToPoint,\n    positions,\n    result\n  );\n};\n/**\n * Computes a point that can be used for horizon culling from a list of positions.  If the point is below\n * the horizon, all of the positions are guaranteed to be below the horizon as well.  The returned point\n * is expressed in the ellipsoid-scaled space and is suitable for use with\n * {@link EllipsoidalOccluder#isScaledSpacePointVisible}.\n *\n * @param {Cartesian3} directionToPoint The direction that the computed point will lie along.\n *                     A reasonable direction to use is the direction from the center of the ellipsoid to\n *                     the center of the bounding sphere computed from the positions.  The direction need not\n *                     be normalized.\n * @param {Number[]} vertices  The vertices from which to compute the horizon culling point.  The positions\n *                   must be expressed in a reference frame centered at the ellipsoid and aligned with the\n *                   ellipsoid\'s axes.\n * @param {Number} [stride=3]\n * @param {Cartesian3} [center=Cartesian3.ZERO]\n * @param {Cartesian3} [result] The instance on which to store the result instead of allocating a new instance.\n * @returns {Cartesian3} The computed horizon culling point, expressed in the ellipsoid-scaled space.\n */\nEllipsoidalOccluder.prototype.computeHorizonCullingPointFromVertices = function (\n  directionToPoint,\n  vertices,\n  stride,\n  center,\n  result\n) {\n  return computeHorizonCullingPointFromVertices(\n    this._ellipsoid,\n    directionToPoint,\n    vertices,\n    stride,\n    center,\n    result\n  );\n};\n\n/**\n * Similar to {@link EllipsoidalOccluder#computeHorizonCullingPointFromVertices} except computes the culling\n * point relative to an ellipsoid that has been shrunk by the minimum height when the minimum height is below\n * the ellipsoid. The returned point is expressed in the possibly-shrunk ellipsoid-scaled space and is suitable\n * for use with {@link EllipsoidalOccluder#isScaledSpacePointVisiblePossiblyUnderEllipsoid}.\n *\n * @param {Cartesian3} directionToPoint The direction that the computed point will lie along.\n *                     A reasonable direction to use is the direction from the center of the ellipsoid to\n *                     the center of the bounding sphere computed from the positions.  The direction need not\n *                     be normalized.\n * @param {Number[]} vertices  The vertices from which to compute the horizon culling point.  The positions\n *                   must be expressed in a reference frame centered at the ellipsoid and aligned with the\n *                   ellipsoid\'s axes.\n * @param {Number} [stride=3]\n * @param {Cartesian3} [center=Cartesian3.ZERO]\n * @param {Number} [minimumHeight] The minimum height of all vertices. If this value is undefined, all vertices are assumed to be above the ellipsoid.\n * @param {Cartesian3} [result] The instance on which to store the result instead of allocating a new instance.\n * @returns {Cartesian3} The computed horizon culling point, expressed in the possibly-shrunk ellipsoid-scaled space.\n */\nEllipsoidalOccluder.prototype.computeHorizonCullingPointFromVerticesPossiblyUnderEllipsoid = function (\n  directionToPoint,\n  vertices,\n  stride,\n  center,\n  minimumHeight,\n  result\n) {\n  var possiblyShrunkEllipsoid = getPossiblyShrunkEllipsoid(\n    this._ellipsoid,\n    minimumHeight,\n    scratchEllipsoidShrunk\n  );\n  return computeHorizonCullingPointFromVertices(\n    possiblyShrunkEllipsoid,\n    directionToPoint,\n    vertices,\n    stride,\n    center,\n    result\n  );\n};\n\nvar subsampleScratch = [];\n\n/**\n * Computes a point that can be used for horizon culling of a rectangle.  If the point is below\n * the horizon, the ellipsoid-conforming rectangle is guaranteed to be below the horizon as well.\n * The returned point is expressed in the ellipsoid-scaled space and is suitable for use with\n * {@link EllipsoidalOccluder#isScaledSpacePointVisible}.\n *\n * @param {Rectangle} rectangle The rectangle for which to compute the horizon culling point.\n * @param {Ellipsoid} ellipsoid The ellipsoid on which the rectangle is defined.  This may be different from\n *                    the ellipsoid used by this instance for occlusion testing.\n * @param {Cartesian3} [result] The instance on which to store the result instead of allocating a new instance.\n * @returns {Cartesian3} The computed horizon culling point, expressed in the ellipsoid-scaled space.\n */\nEllipsoidalOccluder.prototype.computeHorizonCullingPointFromRectangle = function (\n  rectangle,\n  ellipsoid,\n  result\n) {\n  //>>includeStart(\'debug\', pragmas.debug);\n  _Check_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"].typeOf.object */ .Z.typeOf.object("rectangle", rectangle);\n  //>>includeEnd(\'debug\');\n\n  var positions = _Rectangle_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"].subsample */ .Z.subsample(\n    rectangle,\n    ellipsoid,\n    0.0,\n    subsampleScratch\n  );\n  var bs = _BoundingSphere_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].fromPoints */ .Z.fromPoints(positions);\n\n  // If the bounding sphere center is too close to the center of the occluder, it doesn\'t make\n  // sense to try to horizon cull it.\n  if (_Cartesian3_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"].magnitude */ .Z.magnitude(bs.center) < 0.1 * ellipsoid.minimumRadius) {\n    return undefined;\n  }\n\n  return this.computeHorizonCullingPoint(bs.center, positions, result);\n};\n\nvar scratchEllipsoidShrunkRadii = new _Cartesian3_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .Z();\n\nfunction getPossiblyShrunkEllipsoid(ellipsoid, minimumHeight, result) {\n  if (\n    (0,_defined_js__WEBPACK_IMPORTED_MODULE_6__/* ["default"] */ .Z)(minimumHeight) &&\n    minimumHeight < 0.0 &&\n    ellipsoid.minimumRadius > -minimumHeight\n  ) {\n    var ellipsoidShrunkRadii = _Cartesian3_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"].fromElements */ .Z.fromElements(\n      ellipsoid.radii.x + minimumHeight,\n      ellipsoid.radii.y + minimumHeight,\n      ellipsoid.radii.z + minimumHeight,\n      scratchEllipsoidShrunkRadii\n    );\n    ellipsoid = _Ellipsoid_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"].fromCartesian3 */ .Z.fromCartesian3(ellipsoidShrunkRadii, result);\n  }\n  return ellipsoid;\n}\n\nfunction computeHorizonCullingPointFromPositions(\n  ellipsoid,\n  directionToPoint,\n  positions,\n  result\n) {\n  //>>includeStart(\'debug\', pragmas.debug);\n  _Check_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"].typeOf.object */ .Z.typeOf.object("directionToPoint", directionToPoint);\n  _Check_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"].defined */ .Z.defined("positions", positions);\n  //>>includeEnd(\'debug\');\n\n  if (!(0,_defined_js__WEBPACK_IMPORTED_MODULE_6__/* ["default"] */ .Z)(result)) {\n    result = new _Cartesian3_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .Z();\n  }\n\n  var scaledSpaceDirectionToPoint = computeScaledSpaceDirectionToPoint(\n    ellipsoid,\n    directionToPoint\n  );\n  var resultMagnitude = 0.0;\n\n  for (var i = 0, len = positions.length; i < len; ++i) {\n    var position = positions[i];\n    var candidateMagnitude = computeMagnitude(\n      ellipsoid,\n      position,\n      scaledSpaceDirectionToPoint\n    );\n    if (candidateMagnitude < 0.0) {\n      // all points should face the same direction, but this one doesn\'t, so return undefined\n      return undefined;\n    }\n    resultMagnitude = Math.max(resultMagnitude, candidateMagnitude);\n  }\n\n  return magnitudeToPoint(scaledSpaceDirectionToPoint, resultMagnitude, result);\n}\n\nvar positionScratch = new _Cartesian3_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .Z();\n\nfunction computeHorizonCullingPointFromVertices(\n  ellipsoid,\n  directionToPoint,\n  vertices,\n  stride,\n  center,\n  result\n) {\n  //>>includeStart(\'debug\', pragmas.debug);\n  _Check_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"].typeOf.object */ .Z.typeOf.object("directionToPoint", directionToPoint);\n  _Check_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"].defined */ .Z.defined("vertices", vertices);\n  _Check_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"].typeOf.number */ .Z.typeOf.number("stride", stride);\n  //>>includeEnd(\'debug\');\n\n  if (!(0,_defined_js__WEBPACK_IMPORTED_MODULE_6__/* ["default"] */ .Z)(result)) {\n    result = new _Cartesian3_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .Z();\n  }\n\n  stride = (0,_defaultValue_js__WEBPACK_IMPORTED_MODULE_3__/* ["default"] */ .Z)(stride, 3);\n  center = (0,_defaultValue_js__WEBPACK_IMPORTED_MODULE_3__/* ["default"] */ .Z)(center, _Cartesian3_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"].ZERO */ .Z.ZERO);\n  var scaledSpaceDirectionToPoint = computeScaledSpaceDirectionToPoint(\n    ellipsoid,\n    directionToPoint\n  );\n  var resultMagnitude = 0.0;\n\n  for (var i = 0, len = vertices.length; i < len; i += stride) {\n    positionScratch.x = vertices[i] + center.x;\n    positionScratch.y = vertices[i + 1] + center.y;\n    positionScratch.z = vertices[i + 2] + center.z;\n\n    var candidateMagnitude = computeMagnitude(\n      ellipsoid,\n      positionScratch,\n      scaledSpaceDirectionToPoint\n    );\n    if (candidateMagnitude < 0.0) {\n      // all points should face the same direction, but this one doesn\'t, so return undefined\n      return undefined;\n    }\n    resultMagnitude = Math.max(resultMagnitude, candidateMagnitude);\n  }\n\n  return magnitudeToPoint(scaledSpaceDirectionToPoint, resultMagnitude, result);\n}\n\nfunction isScaledSpacePointVisible(\n  occludeeScaledSpacePosition,\n  cameraPositionInScaledSpace,\n  distanceToLimbInScaledSpaceSquared\n) {\n  // See https://cesium.com/blog/2013/04/25/Horizon-culling/\n  var cv = cameraPositionInScaledSpace;\n  var vhMagnitudeSquared = distanceToLimbInScaledSpaceSquared;\n  var vt = _Cartesian3_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"].subtract */ .Z.subtract(\n    occludeeScaledSpacePosition,\n    cv,\n    scratchCartesian\n  );\n  var vtDotVc = -_Cartesian3_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"].dot */ .Z.dot(vt, cv);\n  // If vhMagnitudeSquared < 0 then we are below the surface of the ellipsoid and\n  // in this case, set the culling plane to be on V.\n  var isOccluded =\n    vhMagnitudeSquared < 0\n      ? vtDotVc > 0\n      : vtDotVc > vhMagnitudeSquared &&\n        (vtDotVc * vtDotVc) / _Cartesian3_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"].magnitudeSquared */ .Z.magnitudeSquared(vt) >\n          vhMagnitudeSquared;\n  return !isOccluded;\n}\n\nvar scaledSpaceScratch = new _Cartesian3_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .Z();\nvar directionScratch = new _Cartesian3_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .Z();\n\nfunction computeMagnitude(ellipsoid, position, scaledSpaceDirectionToPoint) {\n  var scaledSpacePosition = ellipsoid.transformPositionToScaledSpace(\n    position,\n    scaledSpaceScratch\n  );\n  var magnitudeSquared = _Cartesian3_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"].magnitudeSquared */ .Z.magnitudeSquared(scaledSpacePosition);\n  var magnitude = Math.sqrt(magnitudeSquared);\n  var direction = _Cartesian3_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"].divideByScalar */ .Z.divideByScalar(\n    scaledSpacePosition,\n    magnitude,\n    directionScratch\n  );\n\n  // For the purpose of this computation, points below the ellipsoid are consider to be on it instead.\n  magnitudeSquared = Math.max(1.0, magnitudeSquared);\n  magnitude = Math.max(1.0, magnitude);\n\n  var cosAlpha = _Cartesian3_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"].dot */ .Z.dot(direction, scaledSpaceDirectionToPoint);\n  var sinAlpha = _Cartesian3_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"].magnitude */ .Z.magnitude(\n    _Cartesian3_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"].cross */ .Z.cross(direction, scaledSpaceDirectionToPoint, direction)\n  );\n  var cosBeta = 1.0 / magnitude;\n  var sinBeta = Math.sqrt(magnitudeSquared - 1.0) * cosBeta;\n\n  return 1.0 / (cosAlpha * cosBeta - sinAlpha * sinBeta);\n}\n\nfunction magnitudeToPoint(\n  scaledSpaceDirectionToPoint,\n  resultMagnitude,\n  result\n) {\n  // The horizon culling point is undefined if there were no positions from which to compute it,\n  // the directionToPoint is pointing opposite all of the positions,  or if we computed NaN or infinity.\n  if (\n    resultMagnitude <= 0.0 ||\n    resultMagnitude === 1.0 / 0.0 ||\n    resultMagnitude !== resultMagnitude\n  ) {\n    return undefined;\n  }\n\n  return _Cartesian3_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"].multiplyByScalar */ .Z.multiplyByScalar(\n    scaledSpaceDirectionToPoint,\n    resultMagnitude,\n    result\n  );\n}\n\nvar directionToPointScratch = new _Cartesian3_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .Z();\n\nfunction computeScaledSpaceDirectionToPoint(ellipsoid, directionToPoint) {\n  if (_Cartesian3_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"].equals */ .Z.equals(directionToPoint, _Cartesian3_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"].ZERO */ .Z.ZERO)) {\n    return directionToPoint;\n  }\n\n  ellipsoid.transformPositionToScaledSpace(\n    directionToPoint,\n    directionToPointScratch\n  );\n  return _Cartesian3_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"].normalize */ .Z.normalize(directionToPointScratch, directionToPointScratch);\n}\n/* harmony default export */ __webpack_exports__["Z"] = (EllipsoidalOccluder);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QUF5QjtBQUMzQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsaUJBQWlCLHVFQUFjO0FBQy9CLGlCQUFpQixtRkFBb0I7QUFDckMsSUFBSSwyRUFBZ0I7QUFDcEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxTQUFTLGlHQUEyQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGtDQUFrQywrREFBVTs7QUFFNUM7QUFDQSxNQUFNLDZFQUFpQixtQkFBbUIseUVBQWU7QUFDekQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVMsbUZBQW9CO0FBQzdCO0FBQ0EseURBQWUsbUJBQW1CLEVBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly92dWUzLXdlYnBhY2s1Ly4vbm9kZV9tb2R1bGVzL2Nlc2l1bS9Tb3VyY2UvQ29yZS9FbGxpcHNvaWRhbE9jY2x1ZGVyLmpzPzkyY2UiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IEJvdW5kaW5nU3BoZXJlIGZyb20gXCIuL0JvdW5kaW5nU3BoZXJlLmpzXCI7XG5pbXBvcnQgQ2FydGVzaWFuMyBmcm9tIFwiLi9DYXJ0ZXNpYW4zLmpzXCI7XG5pbXBvcnQgQ2hlY2sgZnJvbSBcIi4vQ2hlY2suanNcIjtcbmltcG9ydCBkZWZhdWx0VmFsdWUgZnJvbSBcIi4vZGVmYXVsdFZhbHVlLmpzXCI7XG5pbXBvcnQgZGVmaW5lZCBmcm9tIFwiLi9kZWZpbmVkLmpzXCI7XG5pbXBvcnQgRWxsaXBzb2lkIGZyb20gXCIuL0VsbGlwc29pZC5qc1wiO1xuaW1wb3J0IFJlY3RhbmdsZSBmcm9tIFwiLi9SZWN0YW5nbGUuanNcIjtcblxuLyoqXG4gKiBEZXRlcm1pbmUgd2hldGhlciBvciBub3Qgb3RoZXIgb2JqZWN0cyBhcmUgdmlzaWJsZSBvciBoaWRkZW4gYmVoaW5kIHRoZSB2aXNpYmxlIGhvcml6b24gZGVmaW5lZCBieVxuICogYW4ge0BsaW5rIEVsbGlwc29pZH0gYW5kIGEgY2FtZXJhIHBvc2l0aW9uLiAgVGhlIGVsbGlwc29pZCBpcyBhc3N1bWVkIHRvIGJlIGxvY2F0ZWQgYXQgdGhlXG4gKiBvcmlnaW4gb2YgdGhlIGNvb3JkaW5hdGUgc3lzdGVtLiAgVGhpcyBjbGFzcyB1c2VzIHRoZSBhbGdvcml0aG0gZGVzY3JpYmVkIGluIHRoZVxuICoge0BsaW5rIGh0dHBzOi8vY2VzaXVtLmNvbS9ibG9nLzIwMTMvMDQvMjUvSG9yaXpvbi1jdWxsaW5nL3xIb3Jpem9uIEN1bGxpbmd9IGJsb2cgcG9zdC5cbiAqXG4gKiBAYWxpYXMgRWxsaXBzb2lkYWxPY2NsdWRlclxuICpcbiAqIEBwYXJhbSB7RWxsaXBzb2lkfSBlbGxpcHNvaWQgVGhlIGVsbGlwc29pZCB0byB1c2UgYXMgYW4gb2NjbHVkZXIuXG4gKiBAcGFyYW0ge0NhcnRlc2lhbjN9IFtjYW1lcmFQb3NpdGlvbl0gVGhlIGNvb3JkaW5hdGUgb2YgdGhlIHZpZXdlci9jYW1lcmEuICBJZiB0aGlzIHBhcmFtZXRlciBpcyBub3RcbiAqICAgICAgICBzcGVjaWZpZWQsIHtAbGluayBFbGxpcHNvaWRhbE9jY2x1ZGVyI2NhbWVyYVBvc2l0aW9ufSBtdXN0IGJlIGNhbGxlZCBiZWZvcmVcbiAqICAgICAgICB0ZXN0aW5nIHZpc2liaWxpdHkuXG4gKlxuICogQGNvbnN0cnVjdG9yXG4gKlxuICogQGV4YW1wbGVcbiAqIC8vIENvbnN0cnVjdCBhbiBlbGxpcHNvaWRhbCBvY2NsdWRlciB3aXRoIHJhZGlpIDEuMCwgMS4xLCBhbmQgMC45LlxuICogdmFyIGNhbWVyYVBvc2l0aW9uID0gbmV3IENlc2l1bS5DYXJ0ZXNpYW4zKDUuMCwgNi4wLCA3LjApO1xuICogdmFyIG9jY2x1ZGVyRWxsaXBzb2lkID0gbmV3IENlc2l1bS5FbGxpcHNvaWQoMS4wLCAxLjEsIDAuOSk7XG4gKiB2YXIgb2NjbHVkZXIgPSBuZXcgQ2VzaXVtLkVsbGlwc29pZGFsT2NjbHVkZXIob2NjbHVkZXJFbGxpcHNvaWQsIGNhbWVyYVBvc2l0aW9uKTtcbiAqXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBFbGxpcHNvaWRhbE9jY2x1ZGVyKGVsbGlwc29pZCwgY2FtZXJhUG9zaXRpb24pIHtcbiAgLy8+PmluY2x1ZGVTdGFydCgnZGVidWcnLCBwcmFnbWFzLmRlYnVnKTtcbiAgQ2hlY2sudHlwZU9mLm9iamVjdChcImVsbGlwc29pZFwiLCBlbGxpcHNvaWQpO1xuICAvLz4+aW5jbHVkZUVuZCgnZGVidWcnKTtcblxuICB0aGlzLl9lbGxpcHNvaWQgPSBlbGxpcHNvaWQ7XG4gIHRoaXMuX2NhbWVyYVBvc2l0aW9uID0gbmV3IENhcnRlc2lhbjMoKTtcbiAgdGhpcy5fY2FtZXJhUG9zaXRpb25JblNjYWxlZFNwYWNlID0gbmV3IENhcnRlc2lhbjMoKTtcbiAgdGhpcy5fZGlzdGFuY2VUb0xpbWJJblNjYWxlZFNwYWNlU3F1YXJlZCA9IDAuMDtcblxuICAvLyBjYW1lcmFQb3NpdGlvbiBmaWxscyBpbiB0aGUgYWJvdmUgdmFsdWVzXG4gIGlmIChkZWZpbmVkKGNhbWVyYVBvc2l0aW9uKSkge1xuICAgIHRoaXMuY2FtZXJhUG9zaXRpb24gPSBjYW1lcmFQb3NpdGlvbjtcbiAgfVxufVxuXG5PYmplY3QuZGVmaW5lUHJvcGVydGllcyhFbGxpcHNvaWRhbE9jY2x1ZGVyLnByb3RvdHlwZSwge1xuICAvKipcbiAgICogR2V0cyB0aGUgb2NjbHVkaW5nIGVsbGlwc29pZC5cbiAgICogQG1lbWJlcm9mIEVsbGlwc29pZGFsT2NjbHVkZXIucHJvdG90eXBlXG4gICAqIEB0eXBlIHtFbGxpcHNvaWR9XG4gICAqL1xuICBlbGxpcHNvaWQ6IHtcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9lbGxpcHNvaWQ7XG4gICAgfSxcbiAgfSxcbiAgLyoqXG4gICAqIEdldHMgb3Igc2V0cyB0aGUgcG9zaXRpb24gb2YgdGhlIGNhbWVyYS5cbiAgICogQG1lbWJlcm9mIEVsbGlwc29pZGFsT2NjbHVkZXIucHJvdG90eXBlXG4gICAqIEB0eXBlIHtDYXJ0ZXNpYW4zfVxuICAgKi9cbiAgY2FtZXJhUG9zaXRpb246IHtcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9jYW1lcmFQb3NpdGlvbjtcbiAgICB9LFxuICAgIHNldDogZnVuY3Rpb24gKGNhbWVyYVBvc2l0aW9uKSB7XG4gICAgICAvLyBTZWUgaHR0cHM6Ly9jZXNpdW0uY29tL2Jsb2cvMjAxMy8wNC8yNS9Ib3Jpem9uLWN1bGxpbmcvXG4gICAgICB2YXIgZWxsaXBzb2lkID0gdGhpcy5fZWxsaXBzb2lkO1xuICAgICAgdmFyIGN2ID0gZWxsaXBzb2lkLnRyYW5zZm9ybVBvc2l0aW9uVG9TY2FsZWRTcGFjZShcbiAgICAgICAgY2FtZXJhUG9zaXRpb24sXG4gICAgICAgIHRoaXMuX2NhbWVyYVBvc2l0aW9uSW5TY2FsZWRTcGFjZVxuICAgICAgKTtcbiAgICAgIHZhciB2aE1hZ25pdHVkZVNxdWFyZWQgPSBDYXJ0ZXNpYW4zLm1hZ25pdHVkZVNxdWFyZWQoY3YpIC0gMS4wO1xuXG4gICAgICBDYXJ0ZXNpYW4zLmNsb25lKGNhbWVyYVBvc2l0aW9uLCB0aGlzLl9jYW1lcmFQb3NpdGlvbik7XG4gICAgICB0aGlzLl9jYW1lcmFQb3NpdGlvbkluU2NhbGVkU3BhY2UgPSBjdjtcbiAgICAgIHRoaXMuX2Rpc3RhbmNlVG9MaW1iSW5TY2FsZWRTcGFjZVNxdWFyZWQgPSB2aE1hZ25pdHVkZVNxdWFyZWQ7XG4gICAgfSxcbiAgfSxcbn0pO1xuXG52YXIgc2NyYXRjaENhcnRlc2lhbiA9IG5ldyBDYXJ0ZXNpYW4zKCk7XG5cbi8qKlxuICogRGV0ZXJtaW5lcyB3aGV0aGVyIG9yIG5vdCBhIHBvaW50LCB0aGUgPGNvZGU+b2NjbHVkZWU8L2NvZGU+LCBpcyBoaWRkZW4gZnJvbSB2aWV3IGJ5IHRoZSBvY2NsdWRlci5cbiAqXG4gKiBAcGFyYW0ge0NhcnRlc2lhbjN9IG9jY2x1ZGVlIFRoZSBwb2ludCB0byB0ZXN0IGZvciB2aXNpYmlsaXR5LlxuICogQHJldHVybnMge0Jvb2xlYW59IDxjb2RlPnRydWU8L2NvZGU+IGlmIHRoZSBvY2NsdWRlZSBpcyB2aXNpYmxlOyBvdGhlcndpc2UgPGNvZGU+ZmFsc2U8L2NvZGU+LlxuICpcbiAqIEBleGFtcGxlXG4gKiB2YXIgY2FtZXJhUG9zaXRpb24gPSBuZXcgQ2VzaXVtLkNhcnRlc2lhbjMoMCwgMCwgMi41KTtcbiAqIHZhciBlbGxpcHNvaWQgPSBuZXcgQ2VzaXVtLkVsbGlwc29pZCgxLjAsIDEuMSwgMC45KTtcbiAqIHZhciBvY2NsdWRlciA9IG5ldyBDZXNpdW0uRWxsaXBzb2lkYWxPY2NsdWRlcihlbGxpcHNvaWQsIGNhbWVyYVBvc2l0aW9uKTtcbiAqIHZhciBwb2ludCA9IG5ldyBDZXNpdW0uQ2FydGVzaWFuMygwLCAtMywgLTMpO1xuICogb2NjbHVkZXIuaXNQb2ludFZpc2libGUocG9pbnQpOyAvL3JldHVybnMgdHJ1ZVxuICovXG5FbGxpcHNvaWRhbE9jY2x1ZGVyLnByb3RvdHlwZS5pc1BvaW50VmlzaWJsZSA9IGZ1bmN0aW9uIChvY2NsdWRlZSkge1xuICB2YXIgZWxsaXBzb2lkID0gdGhpcy5fZWxsaXBzb2lkO1xuICB2YXIgb2NjbHVkZWVTY2FsZWRTcGFjZVBvc2l0aW9uID0gZWxsaXBzb2lkLnRyYW5zZm9ybVBvc2l0aW9uVG9TY2FsZWRTcGFjZShcbiAgICBvY2NsdWRlZSxcbiAgICBzY3JhdGNoQ2FydGVzaWFuXG4gICk7XG4gIHJldHVybiBpc1NjYWxlZFNwYWNlUG9pbnRWaXNpYmxlKFxuICAgIG9jY2x1ZGVlU2NhbGVkU3BhY2VQb3NpdGlvbixcbiAgICB0aGlzLl9jYW1lcmFQb3NpdGlvbkluU2NhbGVkU3BhY2UsXG4gICAgdGhpcy5fZGlzdGFuY2VUb0xpbWJJblNjYWxlZFNwYWNlU3F1YXJlZFxuICApO1xufTtcblxuLyoqXG4gKiBEZXRlcm1pbmVzIHdoZXRoZXIgb3Igbm90IGEgcG9pbnQgZXhwcmVzc2VkIGluIHRoZSBlbGxpcHNvaWQgc2NhbGVkIHNwYWNlLCBpcyBoaWRkZW4gZnJvbSB2aWV3IGJ5IHRoZVxuICogb2NjbHVkZXIuICBUbyB0cmFuc2Zvcm0gYSBDYXJ0ZXNpYW4gWCwgWSwgWiBwb3NpdGlvbiBpbiB0aGUgY29vcmRpbmF0ZSBzeXN0ZW0gYWxpZ25lZCB3aXRoIHRoZSBlbGxpcHNvaWRcbiAqIGludG8gdGhlIHNjYWxlZCBzcGFjZSwgY2FsbCB7QGxpbmsgRWxsaXBzb2lkI3RyYW5zZm9ybVBvc2l0aW9uVG9TY2FsZWRTcGFjZX0uXG4gKlxuICogQHBhcmFtIHtDYXJ0ZXNpYW4zfSBvY2NsdWRlZVNjYWxlZFNwYWNlUG9zaXRpb24gVGhlIHBvaW50IHRvIHRlc3QgZm9yIHZpc2liaWxpdHksIHJlcHJlc2VudGVkIGluIHRoZSBzY2FsZWQgc3BhY2UuXG4gKiBAcmV0dXJucyB7Qm9vbGVhbn0gPGNvZGU+dHJ1ZTwvY29kZT4gaWYgdGhlIG9jY2x1ZGVlIGlzIHZpc2libGU7IG90aGVyd2lzZSA8Y29kZT5mYWxzZTwvY29kZT4uXG4gKlxuICogQGV4YW1wbGVcbiAqIHZhciBjYW1lcmFQb3NpdGlvbiA9IG5ldyBDZXNpdW0uQ2FydGVzaWFuMygwLCAwLCAyLjUpO1xuICogdmFyIGVsbGlwc29pZCA9IG5ldyBDZXNpdW0uRWxsaXBzb2lkKDEuMCwgMS4xLCAwLjkpO1xuICogdmFyIG9jY2x1ZGVyID0gbmV3IENlc2l1bS5FbGxpcHNvaWRhbE9jY2x1ZGVyKGVsbGlwc29pZCwgY2FtZXJhUG9zaXRpb24pO1xuICogdmFyIHBvaW50ID0gbmV3IENlc2l1bS5DYXJ0ZXNpYW4zKDAsIC0zLCAtMyk7XG4gKiB2YXIgc2NhbGVkU3BhY2VQb2ludCA9IGVsbGlwc29pZC50cmFuc2Zvcm1Qb3NpdGlvblRvU2NhbGVkU3BhY2UocG9pbnQpO1xuICogb2NjbHVkZXIuaXNTY2FsZWRTcGFjZVBvaW50VmlzaWJsZShzY2FsZWRTcGFjZVBvaW50KTsgLy9yZXR1cm5zIHRydWVcbiAqL1xuRWxsaXBzb2lkYWxPY2NsdWRlci5wcm90b3R5cGUuaXNTY2FsZWRTcGFjZVBvaW50VmlzaWJsZSA9IGZ1bmN0aW9uIChcbiAgb2NjbHVkZWVTY2FsZWRTcGFjZVBvc2l0aW9uXG4pIHtcbiAgcmV0dXJuIGlzU2NhbGVkU3BhY2VQb2ludFZpc2libGUoXG4gICAgb2NjbHVkZWVTY2FsZWRTcGFjZVBvc2l0aW9uLFxuICAgIHRoaXMuX2NhbWVyYVBvc2l0aW9uSW5TY2FsZWRTcGFjZSxcbiAgICB0aGlzLl9kaXN0YW5jZVRvTGltYkluU2NhbGVkU3BhY2VTcXVhcmVkXG4gICk7XG59O1xuXG52YXIgc2NyYXRjaENhbWVyYVBvc2l0aW9uSW5TY2FsZWRTcGFjZVNocnVuayA9IG5ldyBDYXJ0ZXNpYW4zKCk7XG5cbi8qKlxuICogU2ltaWxhciB0byB7QGxpbmsgRWxsaXBzb2lkYWxPY2NsdWRlciNpc1NjYWxlZFNwYWNlUG9pbnRWaXNpYmxlfSBleGNlcHQgdGVzdHMgYWdhaW5zdCBhblxuICogZWxsaXBzb2lkIHRoYXQgaGFzIGJlZW4gc2hydW5rIGJ5IHRoZSBtaW5pbXVtIGhlaWdodCB3aGVuIHRoZSBtaW5pbXVtIGhlaWdodCBpcyBiZWxvd1xuICogdGhlIGVsbGlwc29pZC4gVGhpcyBpcyBpbnRlbmRlZCB0byBiZSB1c2VkIHdpdGggcG9pbnRzIGdlbmVyYXRlZCBieVxuICoge0BsaW5rIEVsbGlwc29pZGFsT2NjbHVkZXIjY29tcHV0ZUhvcml6b25DdWxsaW5nUG9pbnRQb3NzaWJseVVuZGVyRWxsaXBzb2lkfSBvclxuICoge0BsaW5rIEVsbGlwc29pZGFsT2NjbHVkZXIjY29tcHV0ZUhvcml6b25DdWxsaW5nUG9pbnRGcm9tVmVydGljZXNQb3NzaWJseVVuZGVyRWxsaXBzb2lkfS5cbiAqXG4gKiBAcGFyYW0ge0NhcnRlc2lhbjN9IG9jY2x1ZGVlU2NhbGVkU3BhY2VQb3NpdGlvbiBUaGUgcG9pbnQgdG8gdGVzdCBmb3IgdmlzaWJpbGl0eSwgcmVwcmVzZW50ZWQgaW4gdGhlIHNjYWxlZCBzcGFjZSBvZiB0aGUgcG9zc2libHktc2hydW5rIGVsbGlwc29pZC5cbiAqIEByZXR1cm5zIHtCb29sZWFufSA8Y29kZT50cnVlPC9jb2RlPiBpZiB0aGUgb2NjbHVkZWUgaXMgdmlzaWJsZTsgb3RoZXJ3aXNlIDxjb2RlPmZhbHNlPC9jb2RlPi5cbiAqL1xuRWxsaXBzb2lkYWxPY2NsdWRlci5wcm90b3R5cGUuaXNTY2FsZWRTcGFjZVBvaW50VmlzaWJsZVBvc3NpYmx5VW5kZXJFbGxpcHNvaWQgPSBmdW5jdGlvbiAoXG4gIG9jY2x1ZGVlU2NhbGVkU3BhY2VQb3NpdGlvbixcbiAgbWluaW11bUhlaWdodFxuKSB7XG4gIHZhciBlbGxpcHNvaWQgPSB0aGlzLl9lbGxpcHNvaWQ7XG4gIHZhciB2aE1hZ25pdHVkZVNxdWFyZWQ7XG4gIHZhciBjdjtcblxuICBpZiAoXG4gICAgZGVmaW5lZChtaW5pbXVtSGVpZ2h0KSAmJlxuICAgIG1pbmltdW1IZWlnaHQgPCAwLjAgJiZcbiAgICBlbGxpcHNvaWQubWluaW11bVJhZGl1cyA+IC1taW5pbXVtSGVpZ2h0XG4gICkge1xuICAgIC8vIFRoaXMgY29kZSBpcyBzaW1pbGFyIHRvIHRoZSBjYW1lcmFQb3NpdGlvbiBzZXR0ZXIsIGJ1dCB1bnJvbGxlZCBmb3IgcGVyZm9ybWFuY2UgYmVjYXVzZSBpdCB3aWxsIGJlIGNhbGxlZCBhIGxvdC5cbiAgICBjdiA9IHNjcmF0Y2hDYW1lcmFQb3NpdGlvbkluU2NhbGVkU3BhY2VTaHJ1bms7XG4gICAgY3YueCA9IHRoaXMuX2NhbWVyYVBvc2l0aW9uLnggLyAoZWxsaXBzb2lkLnJhZGlpLnggKyBtaW5pbXVtSGVpZ2h0KTtcbiAgICBjdi55ID0gdGhpcy5fY2FtZXJhUG9zaXRpb24ueSAvIChlbGxpcHNvaWQucmFkaWkueSArIG1pbmltdW1IZWlnaHQpO1xuICAgIGN2LnogPSB0aGlzLl9jYW1lcmFQb3NpdGlvbi56IC8gKGVsbGlwc29pZC5yYWRpaS56ICsgbWluaW11bUhlaWdodCk7XG4gICAgdmhNYWduaXR1ZGVTcXVhcmVkID0gY3YueCAqIGN2LnggKyBjdi55ICogY3YueSArIGN2LnogKiBjdi56IC0gMS4wO1xuICB9IGVsc2Uge1xuICAgIGN2ID0gdGhpcy5fY2FtZXJhUG9zaXRpb25JblNjYWxlZFNwYWNlO1xuICAgIHZoTWFnbml0dWRlU3F1YXJlZCA9IHRoaXMuX2Rpc3RhbmNlVG9MaW1iSW5TY2FsZWRTcGFjZVNxdWFyZWQ7XG4gIH1cblxuICByZXR1cm4gaXNTY2FsZWRTcGFjZVBvaW50VmlzaWJsZShcbiAgICBvY2NsdWRlZVNjYWxlZFNwYWNlUG9zaXRpb24sXG4gICAgY3YsXG4gICAgdmhNYWduaXR1ZGVTcXVhcmVkXG4gICk7XG59O1xuXG4vKipcbiAqIENvbXB1dGVzIGEgcG9pbnQgdGhhdCBjYW4gYmUgdXNlZCBmb3IgaG9yaXpvbiBjdWxsaW5nIGZyb20gYSBsaXN0IG9mIHBvc2l0aW9ucy4gIElmIHRoZSBwb2ludCBpcyBiZWxvd1xuICogdGhlIGhvcml6b24sIGFsbCBvZiB0aGUgcG9zaXRpb25zIGFyZSBndWFyYW50ZWVkIHRvIGJlIGJlbG93IHRoZSBob3Jpem9uIGFzIHdlbGwuICBUaGUgcmV0dXJuZWQgcG9pbnRcbiAqIGlzIGV4cHJlc3NlZCBpbiB0aGUgZWxsaXBzb2lkLXNjYWxlZCBzcGFjZSBhbmQgaXMgc3VpdGFibGUgZm9yIHVzZSB3aXRoXG4gKiB7QGxpbmsgRWxsaXBzb2lkYWxPY2NsdWRlciNpc1NjYWxlZFNwYWNlUG9pbnRWaXNpYmxlfS5cbiAqXG4gKiBAcGFyYW0ge0NhcnRlc2lhbjN9IGRpcmVjdGlvblRvUG9pbnQgVGhlIGRpcmVjdGlvbiB0aGF0IHRoZSBjb21wdXRlZCBwb2ludCB3aWxsIGxpZSBhbG9uZy5cbiAqICAgICAgICAgICAgICAgICAgICAgQSByZWFzb25hYmxlIGRpcmVjdGlvbiB0byB1c2UgaXMgdGhlIGRpcmVjdGlvbiBmcm9tIHRoZSBjZW50ZXIgb2YgdGhlIGVsbGlwc29pZCB0b1xuICogICAgICAgICAgICAgICAgICAgICB0aGUgY2VudGVyIG9mIHRoZSBib3VuZGluZyBzcGhlcmUgY29tcHV0ZWQgZnJvbSB0aGUgcG9zaXRpb25zLiAgVGhlIGRpcmVjdGlvbiBuZWVkIG5vdFxuICogICAgICAgICAgICAgICAgICAgICBiZSBub3JtYWxpemVkLlxuICogQHBhcmFtIHtDYXJ0ZXNpYW4zW119IHBvc2l0aW9ucyBUaGUgcG9zaXRpb25zIGZyb20gd2hpY2ggdG8gY29tcHV0ZSB0aGUgaG9yaXpvbiBjdWxsaW5nIHBvaW50LiAgVGhlIHBvc2l0aW9uc1xuICogICAgICAgICAgICAgICAgICAgICAgIG11c3QgYmUgZXhwcmVzc2VkIGluIGEgcmVmZXJlbmNlIGZyYW1lIGNlbnRlcmVkIGF0IHRoZSBlbGxpcHNvaWQgYW5kIGFsaWduZWQgd2l0aCB0aGVcbiAqICAgICAgICAgICAgICAgICAgICAgICBlbGxpcHNvaWQncyBheGVzLlxuICogQHBhcmFtIHtDYXJ0ZXNpYW4zfSBbcmVzdWx0XSBUaGUgaW5zdGFuY2Ugb24gd2hpY2ggdG8gc3RvcmUgdGhlIHJlc3VsdCBpbnN0ZWFkIG9mIGFsbG9jYXRpbmcgYSBuZXcgaW5zdGFuY2UuXG4gKiBAcmV0dXJucyB7Q2FydGVzaWFuM30gVGhlIGNvbXB1dGVkIGhvcml6b24gY3VsbGluZyBwb2ludCwgZXhwcmVzc2VkIGluIHRoZSBlbGxpcHNvaWQtc2NhbGVkIHNwYWNlLlxuICovXG5FbGxpcHNvaWRhbE9jY2x1ZGVyLnByb3RvdHlwZS5jb21wdXRlSG9yaXpvbkN1bGxpbmdQb2ludCA9IGZ1bmN0aW9uIChcbiAgZGlyZWN0aW9uVG9Qb2ludCxcbiAgcG9zaXRpb25zLFxuICByZXN1bHRcbikge1xuICByZXR1cm4gY29tcHV0ZUhvcml6b25DdWxsaW5nUG9pbnRGcm9tUG9zaXRpb25zKFxuICAgIHRoaXMuX2VsbGlwc29pZCxcbiAgICBkaXJlY3Rpb25Ub1BvaW50LFxuICAgIHBvc2l0aW9ucyxcbiAgICByZXN1bHRcbiAgKTtcbn07XG5cbnZhciBzY3JhdGNoRWxsaXBzb2lkU2hydW5rID0gRWxsaXBzb2lkLmNsb25lKEVsbGlwc29pZC5VTklUX1NQSEVSRSk7XG5cbi8qKlxuICogU2ltaWxhciB0byB7QGxpbmsgRWxsaXBzb2lkYWxPY2NsdWRlciNjb21wdXRlSG9yaXpvbkN1bGxpbmdQb2ludH0gZXhjZXB0IGNvbXB1dGVzIHRoZSBjdWxsaW5nXG4gKiBwb2ludCByZWxhdGl2ZSB0byBhbiBlbGxpcHNvaWQgdGhhdCBoYXMgYmVlbiBzaHJ1bmsgYnkgdGhlIG1pbmltdW0gaGVpZ2h0IHdoZW4gdGhlIG1pbmltdW0gaGVpZ2h0IGlzIGJlbG93XG4gKiB0aGUgZWxsaXBzb2lkLiBUaGUgcmV0dXJuZWQgcG9pbnQgaXMgZXhwcmVzc2VkIGluIHRoZSBwb3NzaWJseS1zaHJ1bmsgZWxsaXBzb2lkLXNjYWxlZCBzcGFjZSBhbmQgaXMgc3VpdGFibGVcbiAqIGZvciB1c2Ugd2l0aCB7QGxpbmsgRWxsaXBzb2lkYWxPY2NsdWRlciNpc1NjYWxlZFNwYWNlUG9pbnRWaXNpYmxlUG9zc2libHlVbmRlckVsbGlwc29pZH0uXG4gKlxuICogQHBhcmFtIHtDYXJ0ZXNpYW4zfSBkaXJlY3Rpb25Ub1BvaW50IFRoZSBkaXJlY3Rpb24gdGhhdCB0aGUgY29tcHV0ZWQgcG9pbnQgd2lsbCBsaWUgYWxvbmcuXG4gKiAgICAgICAgICAgICAgICAgICAgIEEgcmVhc29uYWJsZSBkaXJlY3Rpb24gdG8gdXNlIGlzIHRoZSBkaXJlY3Rpb24gZnJvbSB0aGUgY2VudGVyIG9mIHRoZSBlbGxpcHNvaWQgdG9cbiAqICAgICAgICAgICAgICAgICAgICAgdGhlIGNlbnRlciBvZiB0aGUgYm91bmRpbmcgc3BoZXJlIGNvbXB1dGVkIGZyb20gdGhlIHBvc2l0aW9ucy4gIFRoZSBkaXJlY3Rpb24gbmVlZCBub3RcbiAqICAgICAgICAgICAgICAgICAgICAgYmUgbm9ybWFsaXplZC5cbiAqIEBwYXJhbSB7Q2FydGVzaWFuM1tdfSBwb3NpdGlvbnMgVGhlIHBvc2l0aW9ucyBmcm9tIHdoaWNoIHRvIGNvbXB1dGUgdGhlIGhvcml6b24gY3VsbGluZyBwb2ludC4gIFRoZSBwb3NpdGlvbnNcbiAqICAgICAgICAgICAgICAgICAgICAgICBtdXN0IGJlIGV4cHJlc3NlZCBpbiBhIHJlZmVyZW5jZSBmcmFtZSBjZW50ZXJlZCBhdCB0aGUgZWxsaXBzb2lkIGFuZCBhbGlnbmVkIHdpdGggdGhlXG4gKiAgICAgICAgICAgICAgICAgICAgICAgZWxsaXBzb2lkJ3MgYXhlcy5cbiAqIEBwYXJhbSB7TnVtYmVyfSBbbWluaW11bUhlaWdodF0gVGhlIG1pbmltdW0gaGVpZ2h0IG9mIGFsbCBwb3NpdGlvbnMuIElmIHRoaXMgdmFsdWUgaXMgdW5kZWZpbmVkLCBhbGwgcG9zaXRpb25zIGFyZSBhc3N1bWVkIHRvIGJlIGFib3ZlIHRoZSBlbGxpcHNvaWQuXG4gKiBAcGFyYW0ge0NhcnRlc2lhbjN9IFtyZXN1bHRdIFRoZSBpbnN0YW5jZSBvbiB3aGljaCB0byBzdG9yZSB0aGUgcmVzdWx0IGluc3RlYWQgb2YgYWxsb2NhdGluZyBhIG5ldyBpbnN0YW5jZS5cbiAqIEByZXR1cm5zIHtDYXJ0ZXNpYW4zfSBUaGUgY29tcHV0ZWQgaG9yaXpvbiBjdWxsaW5nIHBvaW50LCBleHByZXNzZWQgaW4gdGhlIHBvc3NpYmx5LXNocnVuayBlbGxpcHNvaWQtc2NhbGVkIHNwYWNlLlxuICovXG5FbGxpcHNvaWRhbE9jY2x1ZGVyLnByb3RvdHlwZS5jb21wdXRlSG9yaXpvbkN1bGxpbmdQb2ludFBvc3NpYmx5VW5kZXJFbGxpcHNvaWQgPSBmdW5jdGlvbiAoXG4gIGRpcmVjdGlvblRvUG9pbnQsXG4gIHBvc2l0aW9ucyxcbiAgbWluaW11bUhlaWdodCxcbiAgcmVzdWx0XG4pIHtcbiAgdmFyIHBvc3NpYmx5U2hydW5rRWxsaXBzb2lkID0gZ2V0UG9zc2libHlTaHJ1bmtFbGxpcHNvaWQoXG4gICAgdGhpcy5fZWxsaXBzb2lkLFxuICAgIG1pbmltdW1IZWlnaHQsXG4gICAgc2NyYXRjaEVsbGlwc29pZFNocnVua1xuICApO1xuICByZXR1cm4gY29tcHV0ZUhvcml6b25DdWxsaW5nUG9pbnRGcm9tUG9zaXRpb25zKFxuICAgIHBvc3NpYmx5U2hydW5rRWxsaXBzb2lkLFxuICAgIGRpcmVjdGlvblRvUG9pbnQsXG4gICAgcG9zaXRpb25zLFxuICAgIHJlc3VsdFxuICApO1xufTtcbi8qKlxuICogQ29tcHV0ZXMgYSBwb2ludCB0aGF0IGNhbiBiZSB1c2VkIGZvciBob3Jpem9uIGN1bGxpbmcgZnJvbSBhIGxpc3Qgb2YgcG9zaXRpb25zLiAgSWYgdGhlIHBvaW50IGlzIGJlbG93XG4gKiB0aGUgaG9yaXpvbiwgYWxsIG9mIHRoZSBwb3NpdGlvbnMgYXJlIGd1YXJhbnRlZWQgdG8gYmUgYmVsb3cgdGhlIGhvcml6b24gYXMgd2VsbC4gIFRoZSByZXR1cm5lZCBwb2ludFxuICogaXMgZXhwcmVzc2VkIGluIHRoZSBlbGxpcHNvaWQtc2NhbGVkIHNwYWNlIGFuZCBpcyBzdWl0YWJsZSBmb3IgdXNlIHdpdGhcbiAqIHtAbGluayBFbGxpcHNvaWRhbE9jY2x1ZGVyI2lzU2NhbGVkU3BhY2VQb2ludFZpc2libGV9LlxuICpcbiAqIEBwYXJhbSB7Q2FydGVzaWFuM30gZGlyZWN0aW9uVG9Qb2ludCBUaGUgZGlyZWN0aW9uIHRoYXQgdGhlIGNvbXB1dGVkIHBvaW50IHdpbGwgbGllIGFsb25nLlxuICogICAgICAgICAgICAgICAgICAgICBBIHJlYXNvbmFibGUgZGlyZWN0aW9uIHRvIHVzZSBpcyB0aGUgZGlyZWN0aW9uIGZyb20gdGhlIGNlbnRlciBvZiB0aGUgZWxsaXBzb2lkIHRvXG4gKiAgICAgICAgICAgICAgICAgICAgIHRoZSBjZW50ZXIgb2YgdGhlIGJvdW5kaW5nIHNwaGVyZSBjb21wdXRlZCBmcm9tIHRoZSBwb3NpdGlvbnMuICBUaGUgZGlyZWN0aW9uIG5lZWQgbm90XG4gKiAgICAgICAgICAgICAgICAgICAgIGJlIG5vcm1hbGl6ZWQuXG4gKiBAcGFyYW0ge051bWJlcltdfSB2ZXJ0aWNlcyAgVGhlIHZlcnRpY2VzIGZyb20gd2hpY2ggdG8gY29tcHV0ZSB0aGUgaG9yaXpvbiBjdWxsaW5nIHBvaW50LiAgVGhlIHBvc2l0aW9uc1xuICogICAgICAgICAgICAgICAgICAgbXVzdCBiZSBleHByZXNzZWQgaW4gYSByZWZlcmVuY2UgZnJhbWUgY2VudGVyZWQgYXQgdGhlIGVsbGlwc29pZCBhbmQgYWxpZ25lZCB3aXRoIHRoZVxuICogICAgICAgICAgICAgICAgICAgZWxsaXBzb2lkJ3MgYXhlcy5cbiAqIEBwYXJhbSB7TnVtYmVyfSBbc3RyaWRlPTNdXG4gKiBAcGFyYW0ge0NhcnRlc2lhbjN9IFtjZW50ZXI9Q2FydGVzaWFuMy5aRVJPXVxuICogQHBhcmFtIHtDYXJ0ZXNpYW4zfSBbcmVzdWx0XSBUaGUgaW5zdGFuY2Ugb24gd2hpY2ggdG8gc3RvcmUgdGhlIHJlc3VsdCBpbnN0ZWFkIG9mIGFsbG9jYXRpbmcgYSBuZXcgaW5zdGFuY2UuXG4gKiBAcmV0dXJucyB7Q2FydGVzaWFuM30gVGhlIGNvbXB1dGVkIGhvcml6b24gY3VsbGluZyBwb2ludCwgZXhwcmVzc2VkIGluIHRoZSBlbGxpcHNvaWQtc2NhbGVkIHNwYWNlLlxuICovXG5FbGxpcHNvaWRhbE9jY2x1ZGVyLnByb3RvdHlwZS5jb21wdXRlSG9yaXpvbkN1bGxpbmdQb2ludEZyb21WZXJ0aWNlcyA9IGZ1bmN0aW9uIChcbiAgZGlyZWN0aW9uVG9Qb2ludCxcbiAgdmVydGljZXMsXG4gIHN0cmlkZSxcbiAgY2VudGVyLFxuICByZXN1bHRcbikge1xuICByZXR1cm4gY29tcHV0ZUhvcml6b25DdWxsaW5nUG9pbnRGcm9tVmVydGljZXMoXG4gICAgdGhpcy5fZWxsaXBzb2lkLFxuICAgIGRpcmVjdGlvblRvUG9pbnQsXG4gICAgdmVydGljZXMsXG4gICAgc3RyaWRlLFxuICAgIGNlbnRlcixcbiAgICByZXN1bHRcbiAgKTtcbn07XG5cbi8qKlxuICogU2ltaWxhciB0byB7QGxpbmsgRWxsaXBzb2lkYWxPY2NsdWRlciNjb21wdXRlSG9yaXpvbkN1bGxpbmdQb2ludEZyb21WZXJ0aWNlc30gZXhjZXB0IGNvbXB1dGVzIHRoZSBjdWxsaW5nXG4gKiBwb2ludCByZWxhdGl2ZSB0byBhbiBlbGxpcHNvaWQgdGhhdCBoYXMgYmVlbiBzaHJ1bmsgYnkgdGhlIG1pbmltdW0gaGVpZ2h0IHdoZW4gdGhlIG1pbmltdW0gaGVpZ2h0IGlzIGJlbG93XG4gKiB0aGUgZWxsaXBzb2lkLiBUaGUgcmV0dXJuZWQgcG9pbnQgaXMgZXhwcmVzc2VkIGluIHRoZSBwb3NzaWJseS1zaHJ1bmsgZWxsaXBzb2lkLXNjYWxlZCBzcGFjZSBhbmQgaXMgc3VpdGFibGVcbiAqIGZvciB1c2Ugd2l0aCB7QGxpbmsgRWxsaXBzb2lkYWxPY2NsdWRlciNpc1NjYWxlZFNwYWNlUG9pbnRWaXNpYmxlUG9zc2libHlVbmRlckVsbGlwc29pZH0uXG4gKlxuICogQHBhcmFtIHtDYXJ0ZXNpYW4zfSBkaXJlY3Rpb25Ub1BvaW50IFRoZSBkaXJlY3Rpb24gdGhhdCB0aGUgY29tcHV0ZWQgcG9pbnQgd2lsbCBsaWUgYWxvbmcuXG4gKiAgICAgICAgICAgICAgICAgICAgIEEgcmVhc29uYWJsZSBkaXJlY3Rpb24gdG8gdXNlIGlzIHRoZSBkaXJlY3Rpb24gZnJvbSB0aGUgY2VudGVyIG9mIHRoZSBlbGxpcHNvaWQgdG9cbiAqICAgICAgICAgICAgICAgICAgICAgdGhlIGNlbnRlciBvZiB0aGUgYm91bmRpbmcgc3BoZXJlIGNvbXB1dGVkIGZyb20gdGhlIHBvc2l0aW9ucy4gIFRoZSBkaXJlY3Rpb24gbmVlZCBub3RcbiAqICAgICAgICAgICAgICAgICAgICAgYmUgbm9ybWFsaXplZC5cbiAqIEBwYXJhbSB7TnVtYmVyW119IHZlcnRpY2VzICBUaGUgdmVydGljZXMgZnJvbSB3aGljaCB0byBjb21wdXRlIHRoZSBob3Jpem9uIGN1bGxpbmcgcG9pbnQuICBUaGUgcG9zaXRpb25zXG4gKiAgICAgICAgICAgICAgICAgICBtdXN0IGJlIGV4cHJlc3NlZCBpbiBhIHJlZmVyZW5jZSBmcmFtZSBjZW50ZXJlZCBhdCB0aGUgZWxsaXBzb2lkIGFuZCBhbGlnbmVkIHdpdGggdGhlXG4gKiAgICAgICAgICAgICAgICAgICBlbGxpcHNvaWQncyBheGVzLlxuICogQHBhcmFtIHtOdW1iZXJ9IFtzdHJpZGU9M11cbiAqIEBwYXJhbSB7Q2FydGVzaWFuM30gW2NlbnRlcj1DYXJ0ZXNpYW4zLlpFUk9dXG4gKiBAcGFyYW0ge051bWJlcn0gW21pbmltdW1IZWlnaHRdIFRoZSBtaW5pbXVtIGhlaWdodCBvZiBhbGwgdmVydGljZXMuIElmIHRoaXMgdmFsdWUgaXMgdW5kZWZpbmVkLCBhbGwgdmVydGljZXMgYXJlIGFzc3VtZWQgdG8gYmUgYWJvdmUgdGhlIGVsbGlwc29pZC5cbiAqIEBwYXJhbSB7Q2FydGVzaWFuM30gW3Jlc3VsdF0gVGhlIGluc3RhbmNlIG9uIHdoaWNoIHRvIHN0b3JlIHRoZSByZXN1bHQgaW5zdGVhZCBvZiBhbGxvY2F0aW5nIGEgbmV3IGluc3RhbmNlLlxuICogQHJldHVybnMge0NhcnRlc2lhbjN9IFRoZSBjb21wdXRlZCBob3Jpem9uIGN1bGxpbmcgcG9pbnQsIGV4cHJlc3NlZCBpbiB0aGUgcG9zc2libHktc2hydW5rIGVsbGlwc29pZC1zY2FsZWQgc3BhY2UuXG4gKi9cbkVsbGlwc29pZGFsT2NjbHVkZXIucHJvdG90eXBlLmNvbXB1dGVIb3Jpem9uQ3VsbGluZ1BvaW50RnJvbVZlcnRpY2VzUG9zc2libHlVbmRlckVsbGlwc29pZCA9IGZ1bmN0aW9uIChcbiAgZGlyZWN0aW9uVG9Qb2ludCxcbiAgdmVydGljZXMsXG4gIHN0cmlkZSxcbiAgY2VudGVyLFxuICBtaW5pbXVtSGVpZ2h0LFxuICByZXN1bHRcbikge1xuICB2YXIgcG9zc2libHlTaHJ1bmtFbGxpcHNvaWQgPSBnZXRQb3NzaWJseVNocnVua0VsbGlwc29pZChcbiAgICB0aGlzLl9lbGxpcHNvaWQsXG4gICAgbWluaW11bUhlaWdodCxcbiAgICBzY3JhdGNoRWxsaXBzb2lkU2hydW5rXG4gICk7XG4gIHJldHVybiBjb21wdXRlSG9yaXpvbkN1bGxpbmdQb2ludEZyb21WZXJ0aWNlcyhcbiAgICBwb3NzaWJseVNocnVua0VsbGlwc29pZCxcbiAgICBkaXJlY3Rpb25Ub1BvaW50LFxuICAgIHZlcnRpY2VzLFxuICAgIHN0cmlkZSxcbiAgICBjZW50ZXIsXG4gICAgcmVzdWx0XG4gICk7XG59O1xuXG52YXIgc3Vic2FtcGxlU2NyYXRjaCA9IFtdO1xuXG4vKipcbiAqIENvbXB1dGVzIGEgcG9pbnQgdGhhdCBjYW4gYmUgdXNlZCBmb3IgaG9yaXpvbiBjdWxsaW5nIG9mIGEgcmVjdGFuZ2xlLiAgSWYgdGhlIHBvaW50IGlzIGJlbG93XG4gKiB0aGUgaG9yaXpvbiwgdGhlIGVsbGlwc29pZC1jb25mb3JtaW5nIHJlY3RhbmdsZSBpcyBndWFyYW50ZWVkIHRvIGJlIGJlbG93IHRoZSBob3Jpem9uIGFzIHdlbGwuXG4gKiBUaGUgcmV0dXJuZWQgcG9pbnQgaXMgZXhwcmVzc2VkIGluIHRoZSBlbGxpcHNvaWQtc2NhbGVkIHNwYWNlIGFuZCBpcyBzdWl0YWJsZSBmb3IgdXNlIHdpdGhcbiAqIHtAbGluayBFbGxpcHNvaWRhbE9jY2x1ZGVyI2lzU2NhbGVkU3BhY2VQb2ludFZpc2libGV9LlxuICpcbiAqIEBwYXJhbSB7UmVjdGFuZ2xlfSByZWN0YW5nbGUgVGhlIHJlY3RhbmdsZSBmb3Igd2hpY2ggdG8gY29tcHV0ZSB0aGUgaG9yaXpvbiBjdWxsaW5nIHBvaW50LlxuICogQHBhcmFtIHtFbGxpcHNvaWR9IGVsbGlwc29pZCBUaGUgZWxsaXBzb2lkIG9uIHdoaWNoIHRoZSByZWN0YW5nbGUgaXMgZGVmaW5lZC4gIFRoaXMgbWF5IGJlIGRpZmZlcmVudCBmcm9tXG4gKiAgICAgICAgICAgICAgICAgICAgdGhlIGVsbGlwc29pZCB1c2VkIGJ5IHRoaXMgaW5zdGFuY2UgZm9yIG9jY2x1c2lvbiB0ZXN0aW5nLlxuICogQHBhcmFtIHtDYXJ0ZXNpYW4zfSBbcmVzdWx0XSBUaGUgaW5zdGFuY2Ugb24gd2hpY2ggdG8gc3RvcmUgdGhlIHJlc3VsdCBpbnN0ZWFkIG9mIGFsbG9jYXRpbmcgYSBuZXcgaW5zdGFuY2UuXG4gKiBAcmV0dXJucyB7Q2FydGVzaWFuM30gVGhlIGNvbXB1dGVkIGhvcml6b24gY3VsbGluZyBwb2ludCwgZXhwcmVzc2VkIGluIHRoZSBlbGxpcHNvaWQtc2NhbGVkIHNwYWNlLlxuICovXG5FbGxpcHNvaWRhbE9jY2x1ZGVyLnByb3RvdHlwZS5jb21wdXRlSG9yaXpvbkN1bGxpbmdQb2ludEZyb21SZWN0YW5nbGUgPSBmdW5jdGlvbiAoXG4gIHJlY3RhbmdsZSxcbiAgZWxsaXBzb2lkLFxuICByZXN1bHRcbikge1xuICAvLz4+aW5jbHVkZVN0YXJ0KCdkZWJ1ZycsIHByYWdtYXMuZGVidWcpO1xuICBDaGVjay50eXBlT2Yub2JqZWN0KFwicmVjdGFuZ2xlXCIsIHJlY3RhbmdsZSk7XG4gIC8vPj5pbmNsdWRlRW5kKCdkZWJ1ZycpO1xuXG4gIHZhciBwb3NpdGlvbnMgPSBSZWN0YW5nbGUuc3Vic2FtcGxlKFxuICAgIHJlY3RhbmdsZSxcbiAgICBlbGxpcHNvaWQsXG4gICAgMC4wLFxuICAgIHN1YnNhbXBsZVNjcmF0Y2hcbiAgKTtcbiAgdmFyIGJzID0gQm91bmRpbmdTcGhlcmUuZnJvbVBvaW50cyhwb3NpdGlvbnMpO1xuXG4gIC8vIElmIHRoZSBib3VuZGluZyBzcGhlcmUgY2VudGVyIGlzIHRvbyBjbG9zZSB0byB0aGUgY2VudGVyIG9mIHRoZSBvY2NsdWRlciwgaXQgZG9lc24ndCBtYWtlXG4gIC8vIHNlbnNlIHRvIHRyeSB0byBob3Jpem9uIGN1bGwgaXQuXG4gIGlmIChDYXJ0ZXNpYW4zLm1hZ25pdHVkZShicy5jZW50ZXIpIDwgMC4xICogZWxsaXBzb2lkLm1pbmltdW1SYWRpdXMpIHtcbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG5cbiAgcmV0dXJuIHRoaXMuY29tcHV0ZUhvcml6b25DdWxsaW5nUG9pbnQoYnMuY2VudGVyLCBwb3NpdGlvbnMsIHJlc3VsdCk7XG59O1xuXG52YXIgc2NyYXRjaEVsbGlwc29pZFNocnVua1JhZGlpID0gbmV3IENhcnRlc2lhbjMoKTtcblxuZnVuY3Rpb24gZ2V0UG9zc2libHlTaHJ1bmtFbGxpcHNvaWQoZWxsaXBzb2lkLCBtaW5pbXVtSGVpZ2h0LCByZXN1bHQpIHtcbiAgaWYgKFxuICAgIGRlZmluZWQobWluaW11bUhlaWdodCkgJiZcbiAgICBtaW5pbXVtSGVpZ2h0IDwgMC4wICYmXG4gICAgZWxsaXBzb2lkLm1pbmltdW1SYWRpdXMgPiAtbWluaW11bUhlaWdodFxuICApIHtcbiAgICB2YXIgZWxsaXBzb2lkU2hydW5rUmFkaWkgPSBDYXJ0ZXNpYW4zLmZyb21FbGVtZW50cyhcbiAgICAgIGVsbGlwc29pZC5yYWRpaS54ICsgbWluaW11bUhlaWdodCxcbiAgICAgIGVsbGlwc29pZC5yYWRpaS55ICsgbWluaW11bUhlaWdodCxcbiAgICAgIGVsbGlwc29pZC5yYWRpaS56ICsgbWluaW11bUhlaWdodCxcbiAgICAgIHNjcmF0Y2hFbGxpcHNvaWRTaHJ1bmtSYWRpaVxuICAgICk7XG4gICAgZWxsaXBzb2lkID0gRWxsaXBzb2lkLmZyb21DYXJ0ZXNpYW4zKGVsbGlwc29pZFNocnVua1JhZGlpLCByZXN1bHQpO1xuICB9XG4gIHJldHVybiBlbGxpcHNvaWQ7XG59XG5cbmZ1bmN0aW9uIGNvbXB1dGVIb3Jpem9uQ3VsbGluZ1BvaW50RnJvbVBvc2l0aW9ucyhcbiAgZWxsaXBzb2lkLFxuICBkaXJlY3Rpb25Ub1BvaW50LFxuICBwb3NpdGlvbnMsXG4gIHJlc3VsdFxuKSB7XG4gIC8vPj5pbmNsdWRlU3RhcnQoJ2RlYnVnJywgcHJhZ21hcy5kZWJ1Zyk7XG4gIENoZWNrLnR5cGVPZi5vYmplY3QoXCJkaXJlY3Rpb25Ub1BvaW50XCIsIGRpcmVjdGlvblRvUG9pbnQpO1xuICBDaGVjay5kZWZpbmVkKFwicG9zaXRpb25zXCIsIHBvc2l0aW9ucyk7XG4gIC8vPj5pbmNsdWRlRW5kKCdkZWJ1ZycpO1xuXG4gIGlmICghZGVmaW5lZChyZXN1bHQpKSB7XG4gICAgcmVzdWx0ID0gbmV3IENhcnRlc2lhbjMoKTtcbiAgfVxuXG4gIHZhciBzY2FsZWRTcGFjZURpcmVjdGlvblRvUG9pbnQgPSBjb21wdXRlU2NhbGVkU3BhY2VEaXJlY3Rpb25Ub1BvaW50KFxuICAgIGVsbGlwc29pZCxcbiAgICBkaXJlY3Rpb25Ub1BvaW50XG4gICk7XG4gIHZhciByZXN1bHRNYWduaXR1ZGUgPSAwLjA7XG5cbiAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHBvc2l0aW9ucy5sZW5ndGg7IGkgPCBsZW47ICsraSkge1xuICAgIHZhciBwb3NpdGlvbiA9IHBvc2l0aW9uc1tpXTtcbiAgICB2YXIgY2FuZGlkYXRlTWFnbml0dWRlID0gY29tcHV0ZU1hZ25pdHVkZShcbiAgICAgIGVsbGlwc29pZCxcbiAgICAgIHBvc2l0aW9uLFxuICAgICAgc2NhbGVkU3BhY2VEaXJlY3Rpb25Ub1BvaW50XG4gICAgKTtcbiAgICBpZiAoY2FuZGlkYXRlTWFnbml0dWRlIDwgMC4wKSB7XG4gICAgICAvLyBhbGwgcG9pbnRzIHNob3VsZCBmYWNlIHRoZSBzYW1lIGRpcmVjdGlvbiwgYnV0IHRoaXMgb25lIGRvZXNuJ3QsIHNvIHJldHVybiB1bmRlZmluZWRcbiAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIHJlc3VsdE1hZ25pdHVkZSA9IE1hdGgubWF4KHJlc3VsdE1hZ25pdHVkZSwgY2FuZGlkYXRlTWFnbml0dWRlKTtcbiAgfVxuXG4gIHJldHVybiBtYWduaXR1ZGVUb1BvaW50KHNjYWxlZFNwYWNlRGlyZWN0aW9uVG9Qb2ludCwgcmVzdWx0TWFnbml0dWRlLCByZXN1bHQpO1xufVxuXG52YXIgcG9zaXRpb25TY3JhdGNoID0gbmV3IENhcnRlc2lhbjMoKTtcblxuZnVuY3Rpb24gY29tcHV0ZUhvcml6b25DdWxsaW5nUG9pbnRGcm9tVmVydGljZXMoXG4gIGVsbGlwc29pZCxcbiAgZGlyZWN0aW9uVG9Qb2ludCxcbiAgdmVydGljZXMsXG4gIHN0cmlkZSxcbiAgY2VudGVyLFxuICByZXN1bHRcbikge1xuICAvLz4+aW5jbHVkZVN0YXJ0KCdkZWJ1ZycsIHByYWdtYXMuZGVidWcpO1xuICBDaGVjay50eXBlT2Yub2JqZWN0KFwiZGlyZWN0aW9uVG9Qb2ludFwiLCBkaXJlY3Rpb25Ub1BvaW50KTtcbiAgQ2hlY2suZGVmaW5lZChcInZlcnRpY2VzXCIsIHZlcnRpY2VzKTtcbiAgQ2hlY2sudHlwZU9mLm51bWJlcihcInN0cmlkZVwiLCBzdHJpZGUpO1xuICAvLz4+aW5jbHVkZUVuZCgnZGVidWcnKTtcblxuICBpZiAoIWRlZmluZWQocmVzdWx0KSkge1xuICAgIHJlc3VsdCA9IG5ldyBDYXJ0ZXNpYW4zKCk7XG4gIH1cblxuICBzdHJpZGUgPSBkZWZhdWx0VmFsdWUoc3RyaWRlLCAzKTtcbiAgY2VudGVyID0gZGVmYXVsdFZhbHVlKGNlbnRlciwgQ2FydGVzaWFuMy5aRVJPKTtcbiAgdmFyIHNjYWxlZFNwYWNlRGlyZWN0aW9uVG9Qb2ludCA9IGNvbXB1dGVTY2FsZWRTcGFjZURpcmVjdGlvblRvUG9pbnQoXG4gICAgZWxsaXBzb2lkLFxuICAgIGRpcmVjdGlvblRvUG9pbnRcbiAgKTtcbiAgdmFyIHJlc3VsdE1hZ25pdHVkZSA9IDAuMDtcblxuICBmb3IgKHZhciBpID0gMCwgbGVuID0gdmVydGljZXMubGVuZ3RoOyBpIDwgbGVuOyBpICs9IHN0cmlkZSkge1xuICAgIHBvc2l0aW9uU2NyYXRjaC54ID0gdmVydGljZXNbaV0gKyBjZW50ZXIueDtcbiAgICBwb3NpdGlvblNjcmF0Y2gueSA9IHZlcnRpY2VzW2kgKyAxXSArIGNlbnRlci55O1xuICAgIHBvc2l0aW9uU2NyYXRjaC56ID0gdmVydGljZXNbaSArIDJdICsgY2VudGVyLno7XG5cbiAgICB2YXIgY2FuZGlkYXRlTWFnbml0dWRlID0gY29tcHV0ZU1hZ25pdHVkZShcbiAgICAgIGVsbGlwc29pZCxcbiAgICAgIHBvc2l0aW9uU2NyYXRjaCxcbiAgICAgIHNjYWxlZFNwYWNlRGlyZWN0aW9uVG9Qb2ludFxuICAgICk7XG4gICAgaWYgKGNhbmRpZGF0ZU1hZ25pdHVkZSA8IDAuMCkge1xuICAgICAgLy8gYWxsIHBvaW50cyBzaG91bGQgZmFjZSB0aGUgc2FtZSBkaXJlY3Rpb24sIGJ1dCB0aGlzIG9uZSBkb2Vzbid0LCBzbyByZXR1cm4gdW5kZWZpbmVkXG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbiAgICByZXN1bHRNYWduaXR1ZGUgPSBNYXRoLm1heChyZXN1bHRNYWduaXR1ZGUsIGNhbmRpZGF0ZU1hZ25pdHVkZSk7XG4gIH1cblxuICByZXR1cm4gbWFnbml0dWRlVG9Qb2ludChzY2FsZWRTcGFjZURpcmVjdGlvblRvUG9pbnQsIHJlc3VsdE1hZ25pdHVkZSwgcmVzdWx0KTtcbn1cblxuZnVuY3Rpb24gaXNTY2FsZWRTcGFjZVBvaW50VmlzaWJsZShcbiAgb2NjbHVkZWVTY2FsZWRTcGFjZVBvc2l0aW9uLFxuICBjYW1lcmFQb3NpdGlvbkluU2NhbGVkU3BhY2UsXG4gIGRpc3RhbmNlVG9MaW1iSW5TY2FsZWRTcGFjZVNxdWFyZWRcbikge1xuICAvLyBTZWUgaHR0cHM6Ly9jZXNpdW0uY29tL2Jsb2cvMjAxMy8wNC8yNS9Ib3Jpem9uLWN1bGxpbmcvXG4gIHZhciBjdiA9IGNhbWVyYVBvc2l0aW9uSW5TY2FsZWRTcGFjZTtcbiAgdmFyIHZoTWFnbml0dWRlU3F1YXJlZCA9IGRpc3RhbmNlVG9MaW1iSW5TY2FsZWRTcGFjZVNxdWFyZWQ7XG4gIHZhciB2dCA9IENhcnRlc2lhbjMuc3VidHJhY3QoXG4gICAgb2NjbHVkZWVTY2FsZWRTcGFjZVBvc2l0aW9uLFxuICAgIGN2LFxuICAgIHNjcmF0Y2hDYXJ0ZXNpYW5cbiAgKTtcbiAgdmFyIHZ0RG90VmMgPSAtQ2FydGVzaWFuMy5kb3QodnQsIGN2KTtcbiAgLy8gSWYgdmhNYWduaXR1ZGVTcXVhcmVkIDwgMCB0aGVuIHdlIGFyZSBiZWxvdyB0aGUgc3VyZmFjZSBvZiB0aGUgZWxsaXBzb2lkIGFuZFxuICAvLyBpbiB0aGlzIGNhc2UsIHNldCB0aGUgY3VsbGluZyBwbGFuZSB0byBiZSBvbiBWLlxuICB2YXIgaXNPY2NsdWRlZCA9XG4gICAgdmhNYWduaXR1ZGVTcXVhcmVkIDwgMFxuICAgICAgPyB2dERvdFZjID4gMFxuICAgICAgOiB2dERvdFZjID4gdmhNYWduaXR1ZGVTcXVhcmVkICYmXG4gICAgICAgICh2dERvdFZjICogdnREb3RWYykgLyBDYXJ0ZXNpYW4zLm1hZ25pdHVkZVNxdWFyZWQodnQpID5cbiAgICAgICAgICB2aE1hZ25pdHVkZVNxdWFyZWQ7XG4gIHJldHVybiAhaXNPY2NsdWRlZDtcbn1cblxudmFyIHNjYWxlZFNwYWNlU2NyYXRjaCA9IG5ldyBDYXJ0ZXNpYW4zKCk7XG52YXIgZGlyZWN0aW9uU2NyYXRjaCA9IG5ldyBDYXJ0ZXNpYW4zKCk7XG5cbmZ1bmN0aW9uIGNvbXB1dGVNYWduaXR1ZGUoZWxsaXBzb2lkLCBwb3NpdGlvbiwgc2NhbGVkU3BhY2VEaXJlY3Rpb25Ub1BvaW50KSB7XG4gIHZhciBzY2FsZWRTcGFjZVBvc2l0aW9uID0gZWxsaXBzb2lkLnRyYW5zZm9ybVBvc2l0aW9uVG9TY2FsZWRTcGFjZShcbiAgICBwb3NpdGlvbixcbiAgICBzY2FsZWRTcGFjZVNjcmF0Y2hcbiAgKTtcbiAgdmFyIG1hZ25pdHVkZVNxdWFyZWQgPSBDYXJ0ZXNpYW4zLm1hZ25pdHVkZVNxdWFyZWQoc2NhbGVkU3BhY2VQb3NpdGlvbik7XG4gIHZhciBtYWduaXR1ZGUgPSBNYXRoLnNxcnQobWFnbml0dWRlU3F1YXJlZCk7XG4gIHZhciBkaXJlY3Rpb24gPSBDYXJ0ZXNpYW4zLmRpdmlkZUJ5U2NhbGFyKFxuICAgIHNjYWxlZFNwYWNlUG9zaXRpb24sXG4gICAgbWFnbml0dWRlLFxuICAgIGRpcmVjdGlvblNjcmF0Y2hcbiAgKTtcblxuICAvLyBGb3IgdGhlIHB1cnBvc2Ugb2YgdGhpcyBjb21wdXRhdGlvbiwgcG9pbnRzIGJlbG93IHRoZSBlbGxpcHNvaWQgYXJlIGNvbnNpZGVyIHRvIGJlIG9uIGl0IGluc3RlYWQuXG4gIG1hZ25pdHVkZVNxdWFyZWQgPSBNYXRoLm1heCgxLjAsIG1hZ25pdHVkZVNxdWFyZWQpO1xuICBtYWduaXR1ZGUgPSBNYXRoLm1heCgxLjAsIG1hZ25pdHVkZSk7XG5cbiAgdmFyIGNvc0FscGhhID0gQ2FydGVzaWFuMy5kb3QoZGlyZWN0aW9uLCBzY2FsZWRTcGFjZURpcmVjdGlvblRvUG9pbnQpO1xuICB2YXIgc2luQWxwaGEgPSBDYXJ0ZXNpYW4zLm1hZ25pdHVkZShcbiAgICBDYXJ0ZXNpYW4zLmNyb3NzKGRpcmVjdGlvbiwgc2NhbGVkU3BhY2VEaXJlY3Rpb25Ub1BvaW50LCBkaXJlY3Rpb24pXG4gICk7XG4gIHZhciBjb3NCZXRhID0gMS4wIC8gbWFnbml0dWRlO1xuICB2YXIgc2luQmV0YSA9IE1hdGguc3FydChtYWduaXR1ZGVTcXVhcmVkIC0gMS4wKSAqIGNvc0JldGE7XG5cbiAgcmV0dXJuIDEuMCAvIChjb3NBbHBoYSAqIGNvc0JldGEgLSBzaW5BbHBoYSAqIHNpbkJldGEpO1xufVxuXG5mdW5jdGlvbiBtYWduaXR1ZGVUb1BvaW50KFxuICBzY2FsZWRTcGFjZURpcmVjdGlvblRvUG9pbnQsXG4gIHJlc3VsdE1hZ25pdHVkZSxcbiAgcmVzdWx0XG4pIHtcbiAgLy8gVGhlIGhvcml6b24gY3VsbGluZyBwb2ludCBpcyB1bmRlZmluZWQgaWYgdGhlcmUgd2VyZSBubyBwb3NpdGlvbnMgZnJvbSB3aGljaCB0byBjb21wdXRlIGl0LFxuICAvLyB0aGUgZGlyZWN0aW9uVG9Qb2ludCBpcyBwb2ludGluZyBvcHBvc2l0ZSBhbGwgb2YgdGhlIHBvc2l0aW9ucywgIG9yIGlmIHdlIGNvbXB1dGVkIE5hTiBvciBpbmZpbml0eS5cbiAgaWYgKFxuICAgIHJlc3VsdE1hZ25pdHVkZSA8PSAwLjAgfHxcbiAgICByZXN1bHRNYWduaXR1ZGUgPT09IDEuMCAvIDAuMCB8fFxuICAgIHJlc3VsdE1hZ25pdHVkZSAhPT0gcmVzdWx0TWFnbml0dWRlXG4gICkge1xuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cblxuICByZXR1cm4gQ2FydGVzaWFuMy5tdWx0aXBseUJ5U2NhbGFyKFxuICAgIHNjYWxlZFNwYWNlRGlyZWN0aW9uVG9Qb2ludCxcbiAgICByZXN1bHRNYWduaXR1ZGUsXG4gICAgcmVzdWx0XG4gICk7XG59XG5cbnZhciBkaXJlY3Rpb25Ub1BvaW50U2NyYXRjaCA9IG5ldyBDYXJ0ZXNpYW4zKCk7XG5cbmZ1bmN0aW9uIGNvbXB1dGVTY2FsZWRTcGFjZURpcmVjdGlvblRvUG9pbnQoZWxsaXBzb2lkLCBkaXJlY3Rpb25Ub1BvaW50KSB7XG4gIGlmIChDYXJ0ZXNpYW4zLmVxdWFscyhkaXJlY3Rpb25Ub1BvaW50LCBDYXJ0ZXNpYW4zLlpFUk8pKSB7XG4gICAgcmV0dXJuIGRpcmVjdGlvblRvUG9pbnQ7XG4gIH1cblxuICBlbGxpcHNvaWQudHJhbnNmb3JtUG9zaXRpb25Ub1NjYWxlZFNwYWNlKFxuICAgIGRpcmVjdGlvblRvUG9pbnQsXG4gICAgZGlyZWN0aW9uVG9Qb2ludFNjcmF0Y2hcbiAgKTtcbiAgcmV0dXJuIENhcnRlc2lhbjMubm9ybWFsaXplKGRpcmVjdGlvblRvUG9pbnRTY3JhdGNoLCBkaXJlY3Rpb25Ub1BvaW50U2NyYXRjaCk7XG59XG5leHBvcnQgZGVmYXVsdCBFbGxpcHNvaWRhbE9jY2x1ZGVyO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///61252\n')},74938:function(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__){eval('/* harmony import */ var _Cartesian3_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(60216);\n/* harmony import */ var _Check_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(66553);\n/* harmony import */ var _defined_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(82982);\n\n\n\n\n/**\n * A fixed-point encoding of a {@link Cartesian3} with 64-bit floating-point components, as two {@link Cartesian3}\n * values that, when converted to 32-bit floating-point and added, approximate the original input.\n * <p>\n * This is used to encode positions in vertex buffers for rendering without jittering artifacts\n * as described in {@link http://help.agi.com/AGIComponents/html/BlogPrecisionsPrecisions.htm|Precisions, Precisions}.\n * </p>\n *\n * @alias EncodedCartesian3\n * @constructor\n *\n * @private\n */\nfunction EncodedCartesian3() {\n  /**\n   * The high bits for each component.  Bits 0 to 22 store the whole value.  Bits 23 to 31 are not used.\n   *\n   * @type {Cartesian3}\n   * @default {@link Cartesian3.ZERO}\n   */\n  this.high = _Cartesian3_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].clone */ .Z.clone(_Cartesian3_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].ZERO */ .Z.ZERO);\n\n  /**\n   * The low bits for each component.  Bits 7 to 22 store the whole value, and bits 0 to 6 store the fraction.  Bits 23 to 31 are not used.\n   *\n   * @type {Cartesian3}\n   * @default {@link Cartesian3.ZERO}\n   */\n  this.low = _Cartesian3_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].clone */ .Z.clone(_Cartesian3_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].ZERO */ .Z.ZERO);\n}\n\n/**\n * Encodes a 64-bit floating-point value as two floating-point values that, when converted to\n * 32-bit floating-point and added, approximate the original input.  The returned object\n * has <code>high</code> and <code>low</code> properties for the high and low bits, respectively.\n * <p>\n * The fixed-point encoding follows {@link http://help.agi.com/AGIComponents/html/BlogPrecisionsPrecisions.htm|Precisions, Precisions}.\n * </p>\n *\n * @param {Number} value The floating-point value to encode.\n * @param {Object} [result] The object onto which to store the result.\n * @returns {Object} The modified result parameter or a new instance if one was not provided.\n *\n * @example\n * var value = 1234567.1234567;\n * var splitValue = Cesium.EncodedCartesian3.encode(value);\n */\nEncodedCartesian3.encode = function (value, result) {\n  //>>includeStart(\'debug\', pragmas.debug);\n  _Check_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"].typeOf.number */ .Z.typeOf.number("value", value);\n  //>>includeEnd(\'debug\');\n\n  if (!(0,_defined_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"] */ .Z)(result)) {\n    result = {\n      high: 0.0,\n      low: 0.0,\n    };\n  }\n\n  var doubleHigh;\n  if (value >= 0.0) {\n    doubleHigh = Math.floor(value / 65536.0) * 65536.0;\n    result.high = doubleHigh;\n    result.low = value - doubleHigh;\n  } else {\n    doubleHigh = Math.floor(-value / 65536.0) * 65536.0;\n    result.high = -doubleHigh;\n    result.low = value + doubleHigh;\n  }\n\n  return result;\n};\n\nvar scratchEncode = {\n  high: 0.0,\n  low: 0.0,\n};\n\n/**\n * Encodes a {@link Cartesian3} with 64-bit floating-point components as two {@link Cartesian3}\n * values that, when converted to 32-bit floating-point and added, approximate the original input.\n * <p>\n * The fixed-point encoding follows {@link https://help.agi.com/AGIComponents/html/BlogPrecisionsPrecisions.htm|Precisions, Precisions}.\n * </p>\n *\n * @param {Cartesian3} cartesian The cartesian to encode.\n * @param {EncodedCartesian3} [result] The object onto which to store the result.\n * @returns {EncodedCartesian3} The modified result parameter or a new EncodedCartesian3 instance if one was not provided.\n *\n * @example\n * var cart = new Cesium.Cartesian3(-10000000.0, 0.0, 10000000.0);\n * var encoded = Cesium.EncodedCartesian3.fromCartesian(cart);\n */\nEncodedCartesian3.fromCartesian = function (cartesian, result) {\n  //>>includeStart(\'debug\', pragmas.debug);\n  _Check_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"].typeOf.object */ .Z.typeOf.object("cartesian", cartesian);\n  //>>includeEnd(\'debug\');\n\n  if (!(0,_defined_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"] */ .Z)(result)) {\n    result = new EncodedCartesian3();\n  }\n\n  var high = result.high;\n  var low = result.low;\n\n  EncodedCartesian3.encode(cartesian.x, scratchEncode);\n  high.x = scratchEncode.high;\n  low.x = scratchEncode.low;\n\n  EncodedCartesian3.encode(cartesian.y, scratchEncode);\n  high.y = scratchEncode.high;\n  low.y = scratchEncode.low;\n\n  EncodedCartesian3.encode(cartesian.z, scratchEncode);\n  high.z = scratchEncode.high;\n  low.z = scratchEncode.low;\n\n  return result;\n};\n\nvar encodedP = new EncodedCartesian3();\n\n/**\n * Encodes the provided <code>cartesian</code>, and writes it to an array with <code>high</code>\n * components followed by <code>low</code> components, i.e. <code>[high.x, high.y, high.z, low.x, low.y, low.z]</code>.\n * <p>\n * This is used to create interleaved high-precision position vertex attributes.\n * </p>\n *\n * @param {Cartesian3} cartesian The cartesian to encode.\n * @param {Number[]} cartesianArray The array to write to.\n * @param {Number} index The index into the array to start writing.  Six elements will be written.\n *\n * @exception {DeveloperError} index must be a number greater than or equal to 0.\n *\n * @example\n * var positions = [\n *    new Cesium.Cartesian3(),\n *    // ...\n * ];\n * var encodedPositions = new Float32Array(2 * 3 * positions.length);\n * var j = 0;\n * for (var i = 0; i < positions.length; ++i) {\n *   Cesium.EncodedCartesian3.writeElement(positions[i], encodedPositions, j);\n *   j += 6;\n * }\n */\nEncodedCartesian3.writeElements = function (cartesian, cartesianArray, index) {\n  //>>includeStart(\'debug\', pragmas.debug);\n  _Check_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"].defined */ .Z.defined("cartesianArray", cartesianArray);\n  _Check_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"].typeOf.number */ .Z.typeOf.number("index", index);\n  _Check_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"].typeOf.number.greaterThanOrEquals */ .Z.typeOf.number.greaterThanOrEquals("index", index, 0);\n  //>>includeEnd(\'debug\');\n\n  EncodedCartesian3.fromCartesian(cartesian, encodedP);\n  var high = encodedP.high;\n  var low = encodedP.low;\n\n  cartesianArray[index] = high.x;\n  cartesianArray[index + 1] = high.y;\n  cartesianArray[index + 2] = high.z;\n  cartesianArray[index + 3] = low.x;\n  cartesianArray[index + 4] = low.y;\n  cartesianArray[index + 5] = low.z;\n};\n/* harmony default export */ __webpack_exports__["Z"] = (EncodedCartesian3);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNzQ5MzguanMiLCJtYXBwaW5ncyI6Ijs7O0FBQXlDO0FBQ1Y7QUFDSTs7QUFFbkM7QUFDQSxnQ0FBZ0Msa0JBQWtCLCtDQUErQztBQUNqRztBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsaUdBQWlHO0FBQ3JIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1osZUFBZTtBQUNmO0FBQ0EsY0FBYywyRUFBZ0IsQ0FBQyx5RUFBZTs7QUFFOUM7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaLGVBQWU7QUFDZjtBQUNBLGFBQWEsMkVBQWdCLENBQUMseUVBQWU7QUFDN0M7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQyxpR0FBaUc7QUFDdEk7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRSxzRkFBbUI7QUFDckI7O0FBRUEsT0FBTyxnRUFBTztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsY0FBYyxrQkFBa0IsOENBQThDO0FBQzlFO0FBQ0E7QUFDQSxxQ0FBcUMsa0dBQWtHO0FBQ3ZJO0FBQ0E7QUFDQSxXQUFXLFlBQVk7QUFDdkIsV0FBVyxtQkFBbUI7QUFDOUIsYUFBYSxtQkFBbUI7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFLHNGQUFtQjtBQUNyQjs7QUFFQSxPQUFPLGdFQUFPO0FBQ2Q7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFlBQVk7QUFDdkIsV0FBVyxVQUFVO0FBQ3JCLFdBQVcsUUFBUTtBQUNuQjtBQUNBLGVBQWUsZ0JBQWdCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsc0JBQXNCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUUsMEVBQWE7QUFDZixFQUFFLHNGQUFtQjtBQUNyQixFQUFFLDhIQUF1QztBQUN6Qzs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5REFBZSxpQkFBaUIsRUFBQyIsInNvdXJjZXMiOlsid2VicGFjazovL3Z1ZTMtd2VicGFjazUvLi9ub2RlX21vZHVsZXMvY2VzaXVtL1NvdXJjZS9Db3JlL0VuY29kZWRDYXJ0ZXNpYW4zLmpzP2FiM2QiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IENhcnRlc2lhbjMgZnJvbSBcIi4vQ2FydGVzaWFuMy5qc1wiO1xuaW1wb3J0IENoZWNrIGZyb20gXCIuL0NoZWNrLmpzXCI7XG5pbXBvcnQgZGVmaW5lZCBmcm9tIFwiLi9kZWZpbmVkLmpzXCI7XG5cbi8qKlxuICogQSBmaXhlZC1wb2ludCBlbmNvZGluZyBvZiBhIHtAbGluayBDYXJ0ZXNpYW4zfSB3aXRoIDY0LWJpdCBmbG9hdGluZy1wb2ludCBjb21wb25lbnRzLCBhcyB0d28ge0BsaW5rIENhcnRlc2lhbjN9XG4gKiB2YWx1ZXMgdGhhdCwgd2hlbiBjb252ZXJ0ZWQgdG8gMzItYml0IGZsb2F0aW5nLXBvaW50IGFuZCBhZGRlZCwgYXBwcm94aW1hdGUgdGhlIG9yaWdpbmFsIGlucHV0LlxuICogPHA+XG4gKiBUaGlzIGlzIHVzZWQgdG8gZW5jb2RlIHBvc2l0aW9ucyBpbiB2ZXJ0ZXggYnVmZmVycyBmb3IgcmVuZGVyaW5nIHdpdGhvdXQgaml0dGVyaW5nIGFydGlmYWN0c1xuICogYXMgZGVzY3JpYmVkIGluIHtAbGluayBodHRwOi8vaGVscC5hZ2kuY29tL0FHSUNvbXBvbmVudHMvaHRtbC9CbG9nUHJlY2lzaW9uc1ByZWNpc2lvbnMuaHRtfFByZWNpc2lvbnMsIFByZWNpc2lvbnN9LlxuICogPC9wPlxuICpcbiAqIEBhbGlhcyBFbmNvZGVkQ2FydGVzaWFuM1xuICogQGNvbnN0cnVjdG9yXG4gKlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gRW5jb2RlZENhcnRlc2lhbjMoKSB7XG4gIC8qKlxuICAgKiBUaGUgaGlnaCBiaXRzIGZvciBlYWNoIGNvbXBvbmVudC4gIEJpdHMgMCB0byAyMiBzdG9yZSB0aGUgd2hvbGUgdmFsdWUuICBCaXRzIDIzIHRvIDMxIGFyZSBub3QgdXNlZC5cbiAgICpcbiAgICogQHR5cGUge0NhcnRlc2lhbjN9XG4gICAqIEBkZWZhdWx0IHtAbGluayBDYXJ0ZXNpYW4zLlpFUk99XG4gICAqL1xuICB0aGlzLmhpZ2ggPSBDYXJ0ZXNpYW4zLmNsb25lKENhcnRlc2lhbjMuWkVSTyk7XG5cbiAgLyoqXG4gICAqIFRoZSBsb3cgYml0cyBmb3IgZWFjaCBjb21wb25lbnQuICBCaXRzIDcgdG8gMjIgc3RvcmUgdGhlIHdob2xlIHZhbHVlLCBhbmQgYml0cyAwIHRvIDYgc3RvcmUgdGhlIGZyYWN0aW9uLiAgQml0cyAyMyB0byAzMSBhcmUgbm90IHVzZWQuXG4gICAqXG4gICAqIEB0eXBlIHtDYXJ0ZXNpYW4zfVxuICAgKiBAZGVmYXVsdCB7QGxpbmsgQ2FydGVzaWFuMy5aRVJPfVxuICAgKi9cbiAgdGhpcy5sb3cgPSBDYXJ0ZXNpYW4zLmNsb25lKENhcnRlc2lhbjMuWkVSTyk7XG59XG5cbi8qKlxuICogRW5jb2RlcyBhIDY0LWJpdCBmbG9hdGluZy1wb2ludCB2YWx1ZSBhcyB0d28gZmxvYXRpbmctcG9pbnQgdmFsdWVzIHRoYXQsIHdoZW4gY29udmVydGVkIHRvXG4gKiAzMi1iaXQgZmxvYXRpbmctcG9pbnQgYW5kIGFkZGVkLCBhcHByb3hpbWF0ZSB0aGUgb3JpZ2luYWwgaW5wdXQuICBUaGUgcmV0dXJuZWQgb2JqZWN0XG4gKiBoYXMgPGNvZGU+aGlnaDwvY29kZT4gYW5kIDxjb2RlPmxvdzwvY29kZT4gcHJvcGVydGllcyBmb3IgdGhlIGhpZ2ggYW5kIGxvdyBiaXRzLCByZXNwZWN0aXZlbHkuXG4gKiA8cD5cbiAqIFRoZSBmaXhlZC1wb2ludCBlbmNvZGluZyBmb2xsb3dzIHtAbGluayBodHRwOi8vaGVscC5hZ2kuY29tL0FHSUNvbXBvbmVudHMvaHRtbC9CbG9nUHJlY2lzaW9uc1ByZWNpc2lvbnMuaHRtfFByZWNpc2lvbnMsIFByZWNpc2lvbnN9LlxuICogPC9wPlxuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSB2YWx1ZSBUaGUgZmxvYXRpbmctcG9pbnQgdmFsdWUgdG8gZW5jb2RlLlxuICogQHBhcmFtIHtPYmplY3R9IFtyZXN1bHRdIFRoZSBvYmplY3Qgb250byB3aGljaCB0byBzdG9yZSB0aGUgcmVzdWx0LlxuICogQHJldHVybnMge09iamVjdH0gVGhlIG1vZGlmaWVkIHJlc3VsdCBwYXJhbWV0ZXIgb3IgYSBuZXcgaW5zdGFuY2UgaWYgb25lIHdhcyBub3QgcHJvdmlkZWQuXG4gKlxuICogQGV4YW1wbGVcbiAqIHZhciB2YWx1ZSA9IDEyMzQ1NjcuMTIzNDU2NztcbiAqIHZhciBzcGxpdFZhbHVlID0gQ2VzaXVtLkVuY29kZWRDYXJ0ZXNpYW4zLmVuY29kZSh2YWx1ZSk7XG4gKi9cbkVuY29kZWRDYXJ0ZXNpYW4zLmVuY29kZSA9IGZ1bmN0aW9uICh2YWx1ZSwgcmVzdWx0KSB7XG4gIC8vPj5pbmNsdWRlU3RhcnQoJ2RlYnVnJywgcHJhZ21hcy5kZWJ1Zyk7XG4gIENoZWNrLnR5cGVPZi5udW1iZXIoXCJ2YWx1ZVwiLCB2YWx1ZSk7XG4gIC8vPj5pbmNsdWRlRW5kKCdkZWJ1ZycpO1xuXG4gIGlmICghZGVmaW5lZChyZXN1bHQpKSB7XG4gICAgcmVzdWx0ID0ge1xuICAgICAgaGlnaDogMC4wLFxuICAgICAgbG93OiAwLjAsXG4gICAgfTtcbiAgfVxuXG4gIHZhciBkb3VibGVIaWdoO1xuICBpZiAodmFsdWUgPj0gMC4wKSB7XG4gICAgZG91YmxlSGlnaCA9IE1hdGguZmxvb3IodmFsdWUgLyA2NTUzNi4wKSAqIDY1NTM2LjA7XG4gICAgcmVzdWx0LmhpZ2ggPSBkb3VibGVIaWdoO1xuICAgIHJlc3VsdC5sb3cgPSB2YWx1ZSAtIGRvdWJsZUhpZ2g7XG4gIH0gZWxzZSB7XG4gICAgZG91YmxlSGlnaCA9IE1hdGguZmxvb3IoLXZhbHVlIC8gNjU1MzYuMCkgKiA2NTUzNi4wO1xuICAgIHJlc3VsdC5oaWdoID0gLWRvdWJsZUhpZ2g7XG4gICAgcmVzdWx0LmxvdyA9IHZhbHVlICsgZG91YmxlSGlnaDtcbiAgfVxuXG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG52YXIgc2NyYXRjaEVuY29kZSA9IHtcbiAgaGlnaDogMC4wLFxuICBsb3c6IDAuMCxcbn07XG5cbi8qKlxuICogRW5jb2RlcyBhIHtAbGluayBDYXJ0ZXNpYW4zfSB3aXRoIDY0LWJpdCBmbG9hdGluZy1wb2ludCBjb21wb25lbnRzIGFzIHR3byB7QGxpbmsgQ2FydGVzaWFuM31cbiAqIHZhbHVlcyB0aGF0LCB3aGVuIGNvbnZlcnRlZCB0byAzMi1iaXQgZmxvYXRpbmctcG9pbnQgYW5kIGFkZGVkLCBhcHByb3hpbWF0ZSB0aGUgb3JpZ2luYWwgaW5wdXQuXG4gKiA8cD5cbiAqIFRoZSBmaXhlZC1wb2ludCBlbmNvZGluZyBmb2xsb3dzIHtAbGluayBodHRwczovL2hlbHAuYWdpLmNvbS9BR0lDb21wb25lbnRzL2h0bWwvQmxvZ1ByZWNpc2lvbnNQcmVjaXNpb25zLmh0bXxQcmVjaXNpb25zLCBQcmVjaXNpb25zfS5cbiAqIDwvcD5cbiAqXG4gKiBAcGFyYW0ge0NhcnRlc2lhbjN9IGNhcnRlc2lhbiBUaGUgY2FydGVzaWFuIHRvIGVuY29kZS5cbiAqIEBwYXJhbSB7RW5jb2RlZENhcnRlc2lhbjN9IFtyZXN1bHRdIFRoZSBvYmplY3Qgb250byB3aGljaCB0byBzdG9yZSB0aGUgcmVzdWx0LlxuICogQHJldHVybnMge0VuY29kZWRDYXJ0ZXNpYW4zfSBUaGUgbW9kaWZpZWQgcmVzdWx0IHBhcmFtZXRlciBvciBhIG5ldyBFbmNvZGVkQ2FydGVzaWFuMyBpbnN0YW5jZSBpZiBvbmUgd2FzIG5vdCBwcm92aWRlZC5cbiAqXG4gKiBAZXhhbXBsZVxuICogdmFyIGNhcnQgPSBuZXcgQ2VzaXVtLkNhcnRlc2lhbjMoLTEwMDAwMDAwLjAsIDAuMCwgMTAwMDAwMDAuMCk7XG4gKiB2YXIgZW5jb2RlZCA9IENlc2l1bS5FbmNvZGVkQ2FydGVzaWFuMy5mcm9tQ2FydGVzaWFuKGNhcnQpO1xuICovXG5FbmNvZGVkQ2FydGVzaWFuMy5mcm9tQ2FydGVzaWFuID0gZnVuY3Rpb24gKGNhcnRlc2lhbiwgcmVzdWx0KSB7XG4gIC8vPj5pbmNsdWRlU3RhcnQoJ2RlYnVnJywgcHJhZ21hcy5kZWJ1Zyk7XG4gIENoZWNrLnR5cGVPZi5vYmplY3QoXCJjYXJ0ZXNpYW5cIiwgY2FydGVzaWFuKTtcbiAgLy8+PmluY2x1ZGVFbmQoJ2RlYnVnJyk7XG5cbiAgaWYgKCFkZWZpbmVkKHJlc3VsdCkpIHtcbiAgICByZXN1bHQgPSBuZXcgRW5jb2RlZENhcnRlc2lhbjMoKTtcbiAgfVxuXG4gIHZhciBoaWdoID0gcmVzdWx0LmhpZ2g7XG4gIHZhciBsb3cgPSByZXN1bHQubG93O1xuXG4gIEVuY29kZWRDYXJ0ZXNpYW4zLmVuY29kZShjYXJ0ZXNpYW4ueCwgc2NyYXRjaEVuY29kZSk7XG4gIGhpZ2gueCA9IHNjcmF0Y2hFbmNvZGUuaGlnaDtcbiAgbG93LnggPSBzY3JhdGNoRW5jb2RlLmxvdztcblxuICBFbmNvZGVkQ2FydGVzaWFuMy5lbmNvZGUoY2FydGVzaWFuLnksIHNjcmF0Y2hFbmNvZGUpO1xuICBoaWdoLnkgPSBzY3JhdGNoRW5jb2RlLmhpZ2g7XG4gIGxvdy55ID0gc2NyYXRjaEVuY29kZS5sb3c7XG5cbiAgRW5jb2RlZENhcnRlc2lhbjMuZW5jb2RlKGNhcnRlc2lhbi56LCBzY3JhdGNoRW5jb2RlKTtcbiAgaGlnaC56ID0gc2NyYXRjaEVuY29kZS5oaWdoO1xuICBsb3cueiA9IHNjcmF0Y2hFbmNvZGUubG93O1xuXG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG52YXIgZW5jb2RlZFAgPSBuZXcgRW5jb2RlZENhcnRlc2lhbjMoKTtcblxuLyoqXG4gKiBFbmNvZGVzIHRoZSBwcm92aWRlZCA8Y29kZT5jYXJ0ZXNpYW48L2NvZGU+LCBhbmQgd3JpdGVzIGl0IHRvIGFuIGFycmF5IHdpdGggPGNvZGU+aGlnaDwvY29kZT5cbiAqIGNvbXBvbmVudHMgZm9sbG93ZWQgYnkgPGNvZGU+bG93PC9jb2RlPiBjb21wb25lbnRzLCBpLmUuIDxjb2RlPltoaWdoLngsIGhpZ2gueSwgaGlnaC56LCBsb3cueCwgbG93LnksIGxvdy56XTwvY29kZT4uXG4gKiA8cD5cbiAqIFRoaXMgaXMgdXNlZCB0byBjcmVhdGUgaW50ZXJsZWF2ZWQgaGlnaC1wcmVjaXNpb24gcG9zaXRpb24gdmVydGV4IGF0dHJpYnV0ZXMuXG4gKiA8L3A+XG4gKlxuICogQHBhcmFtIHtDYXJ0ZXNpYW4zfSBjYXJ0ZXNpYW4gVGhlIGNhcnRlc2lhbiB0byBlbmNvZGUuXG4gKiBAcGFyYW0ge051bWJlcltdfSBjYXJ0ZXNpYW5BcnJheSBUaGUgYXJyYXkgdG8gd3JpdGUgdG8uXG4gKiBAcGFyYW0ge051bWJlcn0gaW5kZXggVGhlIGluZGV4IGludG8gdGhlIGFycmF5IHRvIHN0YXJ0IHdyaXRpbmcuICBTaXggZWxlbWVudHMgd2lsbCBiZSB3cml0dGVuLlxuICpcbiAqIEBleGNlcHRpb24ge0RldmVsb3BlckVycm9yfSBpbmRleCBtdXN0IGJlIGEgbnVtYmVyIGdyZWF0ZXIgdGhhbiBvciBlcXVhbCB0byAwLlxuICpcbiAqIEBleGFtcGxlXG4gKiB2YXIgcG9zaXRpb25zID0gW1xuICogICAgbmV3IENlc2l1bS5DYXJ0ZXNpYW4zKCksXG4gKiAgICAvLyAuLi5cbiAqIF07XG4gKiB2YXIgZW5jb2RlZFBvc2l0aW9ucyA9IG5ldyBGbG9hdDMyQXJyYXkoMiAqIDMgKiBwb3NpdGlvbnMubGVuZ3RoKTtcbiAqIHZhciBqID0gMDtcbiAqIGZvciAodmFyIGkgPSAwOyBpIDwgcG9zaXRpb25zLmxlbmd0aDsgKytpKSB7XG4gKiAgIENlc2l1bS5FbmNvZGVkQ2FydGVzaWFuMy53cml0ZUVsZW1lbnQocG9zaXRpb25zW2ldLCBlbmNvZGVkUG9zaXRpb25zLCBqKTtcbiAqICAgaiArPSA2O1xuICogfVxuICovXG5FbmNvZGVkQ2FydGVzaWFuMy53cml0ZUVsZW1lbnRzID0gZnVuY3Rpb24gKGNhcnRlc2lhbiwgY2FydGVzaWFuQXJyYXksIGluZGV4KSB7XG4gIC8vPj5pbmNsdWRlU3RhcnQoJ2RlYnVnJywgcHJhZ21hcy5kZWJ1Zyk7XG4gIENoZWNrLmRlZmluZWQoXCJjYXJ0ZXNpYW5BcnJheVwiLCBjYXJ0ZXNpYW5BcnJheSk7XG4gIENoZWNrLnR5cGVPZi5udW1iZXIoXCJpbmRleFwiLCBpbmRleCk7XG4gIENoZWNrLnR5cGVPZi5udW1iZXIuZ3JlYXRlclRoYW5PckVxdWFscyhcImluZGV4XCIsIGluZGV4LCAwKTtcbiAgLy8+PmluY2x1ZGVFbmQoJ2RlYnVnJyk7XG5cbiAgRW5jb2RlZENhcnRlc2lhbjMuZnJvbUNhcnRlc2lhbihjYXJ0ZXNpYW4sIGVuY29kZWRQKTtcbiAgdmFyIGhpZ2ggPSBlbmNvZGVkUC5oaWdoO1xuICB2YXIgbG93ID0gZW5jb2RlZFAubG93O1xuXG4gIGNhcnRlc2lhbkFycmF5W2luZGV4XSA9IGhpZ2gueDtcbiAgY2FydGVzaWFuQXJyYXlbaW5kZXggKyAxXSA9IGhpZ2gueTtcbiAgY2FydGVzaWFuQXJyYXlbaW5kZXggKyAyXSA9IGhpZ2guejtcbiAgY2FydGVzaWFuQXJyYXlbaW5kZXggKyAzXSA9IGxvdy54O1xuICBjYXJ0ZXNpYW5BcnJheVtpbmRleCArIDRdID0gbG93Lnk7XG4gIGNhcnRlc2lhbkFycmF5W2luZGV4ICsgNV0gPSBsb3cuejtcbn07XG5leHBvcnQgZGVmYXVsdCBFbmNvZGVkQ2FydGVzaWFuMztcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///74938\n')},14459:function(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__){eval("/* harmony import */ var _Check_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(66553);\n/* harmony import */ var _defined_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(82982);\n\n\n\n/**\n * A generic utility class for managing subscribers for a particular event.\n * This class is usually instantiated inside of a container class and\n * exposed as a property for others to subscribe to.\n *\n * @alias Event\n * @constructor\n * @example\n * MyObject.prototype.myListener = function(arg1, arg2) {\n *     this.myArg1Copy = arg1;\n *     this.myArg2Copy = arg2;\n * }\n *\n * var myObjectInstance = new MyObject();\n * var evt = new Cesium.Event();\n * evt.addEventListener(MyObject.prototype.myListener, myObjectInstance);\n * evt.raiseEvent('1', '2');\n * evt.removeEventListener(MyObject.prototype.myListener);\n */\nfunction Event() {\n  this._listeners = [];\n  this._scopes = [];\n  this._toRemove = [];\n  this._insideRaiseEvent = false;\n}\n\nObject.defineProperties(Event.prototype, {\n  /**\n   * The number of listeners currently subscribed to the event.\n   * @memberof Event.prototype\n   * @type {Number}\n   * @readonly\n   */\n  numberOfListeners: {\n    get: function () {\n      return this._listeners.length - this._toRemove.length;\n    },\n  },\n});\n\n/**\n * Registers a callback function to be executed whenever the event is raised.\n * An optional scope can be provided to serve as the <code>this</code> pointer\n * in which the function will execute.\n *\n * @param {Function} listener The function to be executed when the event is raised.\n * @param {Object} [scope] An optional object scope to serve as the <code>this</code>\n *        pointer in which the listener function will execute.\n * @returns {Event.RemoveCallback} A function that will remove this event listener when invoked.\n *\n * @see Event#raiseEvent\n * @see Event#removeEventListener\n */\nEvent.prototype.addEventListener = function (listener, scope) {\n  //>>includeStart('debug', pragmas.debug);\n  _Check_js__WEBPACK_IMPORTED_MODULE_0__/* [\"default\"].typeOf.func */ .Z.typeOf.func(\"listener\", listener);\n  //>>includeEnd('debug');\n\n  this._listeners.push(listener);\n  this._scopes.push(scope);\n\n  var event = this;\n  return function () {\n    event.removeEventListener(listener, scope);\n  };\n};\n\n/**\n * Unregisters a previously registered callback.\n *\n * @param {Function} listener The function to be unregistered.\n * @param {Object} [scope] The scope that was originally passed to addEventListener.\n * @returns {Boolean} <code>true</code> if the listener was removed; <code>false</code> if the listener and scope are not registered with the event.\n *\n * @see Event#addEventListener\n * @see Event#raiseEvent\n */\nEvent.prototype.removeEventListener = function (listener, scope) {\n  //>>includeStart('debug', pragmas.debug);\n  _Check_js__WEBPACK_IMPORTED_MODULE_0__/* [\"default\"].typeOf.func */ .Z.typeOf.func(\"listener\", listener);\n  //>>includeEnd('debug');\n\n  var listeners = this._listeners;\n  var scopes = this._scopes;\n\n  var index = -1;\n  for (var i = 0; i < listeners.length; i++) {\n    if (listeners[i] === listener && scopes[i] === scope) {\n      index = i;\n      break;\n    }\n  }\n\n  if (index !== -1) {\n    if (this._insideRaiseEvent) {\n      //In order to allow removing an event subscription from within\n      //a callback, we don't actually remove the items here.  Instead\n      //remember the index they are at and undefined their value.\n      this._toRemove.push(index);\n      listeners[index] = undefined;\n      scopes[index] = undefined;\n    } else {\n      listeners.splice(index, 1);\n      scopes.splice(index, 1);\n    }\n    return true;\n  }\n\n  return false;\n};\n\nfunction compareNumber(a, b) {\n  return b - a;\n}\n\n/**\n * Raises the event by calling each registered listener with all supplied arguments.\n *\n * @param {...Object} arguments This method takes any number of parameters and passes them through to the listener functions.\n *\n * @see Event#addEventListener\n * @see Event#removeEventListener\n */\nEvent.prototype.raiseEvent = function () {\n  this._insideRaiseEvent = true;\n\n  var i;\n  var listeners = this._listeners;\n  var scopes = this._scopes;\n  var length = listeners.length;\n\n  for (i = 0; i < length; i++) {\n    var listener = listeners[i];\n    if ((0,_defined_js__WEBPACK_IMPORTED_MODULE_1__/* [\"default\"] */ .Z)(listener)) {\n      listeners[i].apply(scopes[i], arguments);\n    }\n  }\n\n  //Actually remove items removed in removeEventListener.\n  var toRemove = this._toRemove;\n  length = toRemove.length;\n  if (length > 0) {\n    toRemove.sort(compareNumber);\n    for (i = 0; i < length; i++) {\n      var index = toRemove[i];\n      listeners.splice(index, 1);\n      scopes.splice(index, 1);\n    }\n    toRemove.length = 0;\n  }\n\n  this._insideRaiseEvent = false;\n};\n\n/**\n * A function that removes a listener.\n * @callback Event.RemoveCallback\n */\n/* harmony default export */ __webpack_exports__[\"Z\"] = (Event);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTQ0NTkuanMiLCJtYXBwaW5ncyI6Ijs7QUFBK0I7QUFDSTs7QUFFbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0gsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxVQUFVO0FBQ3JCLFdBQVcsUUFBUTtBQUNuQjtBQUNBLGFBQWEsc0JBQXNCO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUUsa0ZBQWlCO0FBQ25COztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFVBQVU7QUFDckIsV0FBVyxRQUFRO0FBQ25CLGFBQWEsU0FBUywrQ0FBK0M7QUFDckU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRSxrRkFBaUI7QUFDbkI7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLGtCQUFrQixzQkFBc0I7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxXQUFXO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxjQUFjLFlBQVk7QUFDMUI7QUFDQSxRQUFRLGdFQUFPO0FBQ2Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsWUFBWTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlEQUFlLEtBQUssRUFBQyIsInNvdXJjZXMiOlsid2VicGFjazovL3Z1ZTMtd2VicGFjazUvLi9ub2RlX21vZHVsZXMvY2VzaXVtL1NvdXJjZS9Db3JlL0V2ZW50LmpzP2ViNjkiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IENoZWNrIGZyb20gXCIuL0NoZWNrLmpzXCI7XG5pbXBvcnQgZGVmaW5lZCBmcm9tIFwiLi9kZWZpbmVkLmpzXCI7XG5cbi8qKlxuICogQSBnZW5lcmljIHV0aWxpdHkgY2xhc3MgZm9yIG1hbmFnaW5nIHN1YnNjcmliZXJzIGZvciBhIHBhcnRpY3VsYXIgZXZlbnQuXG4gKiBUaGlzIGNsYXNzIGlzIHVzdWFsbHkgaW5zdGFudGlhdGVkIGluc2lkZSBvZiBhIGNvbnRhaW5lciBjbGFzcyBhbmRcbiAqIGV4cG9zZWQgYXMgYSBwcm9wZXJ0eSBmb3Igb3RoZXJzIHRvIHN1YnNjcmliZSB0by5cbiAqXG4gKiBAYWxpYXMgRXZlbnRcbiAqIEBjb25zdHJ1Y3RvclxuICogQGV4YW1wbGVcbiAqIE15T2JqZWN0LnByb3RvdHlwZS5teUxpc3RlbmVyID0gZnVuY3Rpb24oYXJnMSwgYXJnMikge1xuICogICAgIHRoaXMubXlBcmcxQ29weSA9IGFyZzE7XG4gKiAgICAgdGhpcy5teUFyZzJDb3B5ID0gYXJnMjtcbiAqIH1cbiAqXG4gKiB2YXIgbXlPYmplY3RJbnN0YW5jZSA9IG5ldyBNeU9iamVjdCgpO1xuICogdmFyIGV2dCA9IG5ldyBDZXNpdW0uRXZlbnQoKTtcbiAqIGV2dC5hZGRFdmVudExpc3RlbmVyKE15T2JqZWN0LnByb3RvdHlwZS5teUxpc3RlbmVyLCBteU9iamVjdEluc3RhbmNlKTtcbiAqIGV2dC5yYWlzZUV2ZW50KCcxJywgJzInKTtcbiAqIGV2dC5yZW1vdmVFdmVudExpc3RlbmVyKE15T2JqZWN0LnByb3RvdHlwZS5teUxpc3RlbmVyKTtcbiAqL1xuZnVuY3Rpb24gRXZlbnQoKSB7XG4gIHRoaXMuX2xpc3RlbmVycyA9IFtdO1xuICB0aGlzLl9zY29wZXMgPSBbXTtcbiAgdGhpcy5fdG9SZW1vdmUgPSBbXTtcbiAgdGhpcy5faW5zaWRlUmFpc2VFdmVudCA9IGZhbHNlO1xufVxuXG5PYmplY3QuZGVmaW5lUHJvcGVydGllcyhFdmVudC5wcm90b3R5cGUsIHtcbiAgLyoqXG4gICAqIFRoZSBudW1iZXIgb2YgbGlzdGVuZXJzIGN1cnJlbnRseSBzdWJzY3JpYmVkIHRvIHRoZSBldmVudC5cbiAgICogQG1lbWJlcm9mIEV2ZW50LnByb3RvdHlwZVxuICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgKiBAcmVhZG9ubHlcbiAgICovXG4gIG51bWJlck9mTGlzdGVuZXJzOiB7XG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fbGlzdGVuZXJzLmxlbmd0aCAtIHRoaXMuX3RvUmVtb3ZlLmxlbmd0aDtcbiAgICB9LFxuICB9LFxufSk7XG5cbi8qKlxuICogUmVnaXN0ZXJzIGEgY2FsbGJhY2sgZnVuY3Rpb24gdG8gYmUgZXhlY3V0ZWQgd2hlbmV2ZXIgdGhlIGV2ZW50IGlzIHJhaXNlZC5cbiAqIEFuIG9wdGlvbmFsIHNjb3BlIGNhbiBiZSBwcm92aWRlZCB0byBzZXJ2ZSBhcyB0aGUgPGNvZGU+dGhpczwvY29kZT4gcG9pbnRlclxuICogaW4gd2hpY2ggdGhlIGZ1bmN0aW9uIHdpbGwgZXhlY3V0ZS5cbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBsaXN0ZW5lciBUaGUgZnVuY3Rpb24gdG8gYmUgZXhlY3V0ZWQgd2hlbiB0aGUgZXZlbnQgaXMgcmFpc2VkLlxuICogQHBhcmFtIHtPYmplY3R9IFtzY29wZV0gQW4gb3B0aW9uYWwgb2JqZWN0IHNjb3BlIHRvIHNlcnZlIGFzIHRoZSA8Y29kZT50aGlzPC9jb2RlPlxuICogICAgICAgIHBvaW50ZXIgaW4gd2hpY2ggdGhlIGxpc3RlbmVyIGZ1bmN0aW9uIHdpbGwgZXhlY3V0ZS5cbiAqIEByZXR1cm5zIHtFdmVudC5SZW1vdmVDYWxsYmFja30gQSBmdW5jdGlvbiB0aGF0IHdpbGwgcmVtb3ZlIHRoaXMgZXZlbnQgbGlzdGVuZXIgd2hlbiBpbnZva2VkLlxuICpcbiAqIEBzZWUgRXZlbnQjcmFpc2VFdmVudFxuICogQHNlZSBFdmVudCNyZW1vdmVFdmVudExpc3RlbmVyXG4gKi9cbkV2ZW50LnByb3RvdHlwZS5hZGRFdmVudExpc3RlbmVyID0gZnVuY3Rpb24gKGxpc3RlbmVyLCBzY29wZSkge1xuICAvLz4+aW5jbHVkZVN0YXJ0KCdkZWJ1ZycsIHByYWdtYXMuZGVidWcpO1xuICBDaGVjay50eXBlT2YuZnVuYyhcImxpc3RlbmVyXCIsIGxpc3RlbmVyKTtcbiAgLy8+PmluY2x1ZGVFbmQoJ2RlYnVnJyk7XG5cbiAgdGhpcy5fbGlzdGVuZXJzLnB1c2gobGlzdGVuZXIpO1xuICB0aGlzLl9zY29wZXMucHVzaChzY29wZSk7XG5cbiAgdmFyIGV2ZW50ID0gdGhpcztcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICBldmVudC5yZW1vdmVFdmVudExpc3RlbmVyKGxpc3RlbmVyLCBzY29wZSk7XG4gIH07XG59O1xuXG4vKipcbiAqIFVucmVnaXN0ZXJzIGEgcHJldmlvdXNseSByZWdpc3RlcmVkIGNhbGxiYWNrLlxuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGxpc3RlbmVyIFRoZSBmdW5jdGlvbiB0byBiZSB1bnJlZ2lzdGVyZWQuXG4gKiBAcGFyYW0ge09iamVjdH0gW3Njb3BlXSBUaGUgc2NvcGUgdGhhdCB3YXMgb3JpZ2luYWxseSBwYXNzZWQgdG8gYWRkRXZlbnRMaXN0ZW5lci5cbiAqIEByZXR1cm5zIHtCb29sZWFufSA8Y29kZT50cnVlPC9jb2RlPiBpZiB0aGUgbGlzdGVuZXIgd2FzIHJlbW92ZWQ7IDxjb2RlPmZhbHNlPC9jb2RlPiBpZiB0aGUgbGlzdGVuZXIgYW5kIHNjb3BlIGFyZSBub3QgcmVnaXN0ZXJlZCB3aXRoIHRoZSBldmVudC5cbiAqXG4gKiBAc2VlIEV2ZW50I2FkZEV2ZW50TGlzdGVuZXJcbiAqIEBzZWUgRXZlbnQjcmFpc2VFdmVudFxuICovXG5FdmVudC5wcm90b3R5cGUucmVtb3ZlRXZlbnRMaXN0ZW5lciA9IGZ1bmN0aW9uIChsaXN0ZW5lciwgc2NvcGUpIHtcbiAgLy8+PmluY2x1ZGVTdGFydCgnZGVidWcnLCBwcmFnbWFzLmRlYnVnKTtcbiAgQ2hlY2sudHlwZU9mLmZ1bmMoXCJsaXN0ZW5lclwiLCBsaXN0ZW5lcik7XG4gIC8vPj5pbmNsdWRlRW5kKCdkZWJ1ZycpO1xuXG4gIHZhciBsaXN0ZW5lcnMgPSB0aGlzLl9saXN0ZW5lcnM7XG4gIHZhciBzY29wZXMgPSB0aGlzLl9zY29wZXM7XG5cbiAgdmFyIGluZGV4ID0gLTE7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGlzdGVuZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKGxpc3RlbmVyc1tpXSA9PT0gbGlzdGVuZXIgJiYgc2NvcGVzW2ldID09PSBzY29wZSkge1xuICAgICAgaW5kZXggPSBpO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG5cbiAgaWYgKGluZGV4ICE9PSAtMSkge1xuICAgIGlmICh0aGlzLl9pbnNpZGVSYWlzZUV2ZW50KSB7XG4gICAgICAvL0luIG9yZGVyIHRvIGFsbG93IHJlbW92aW5nIGFuIGV2ZW50IHN1YnNjcmlwdGlvbiBmcm9tIHdpdGhpblxuICAgICAgLy9hIGNhbGxiYWNrLCB3ZSBkb24ndCBhY3R1YWxseSByZW1vdmUgdGhlIGl0ZW1zIGhlcmUuICBJbnN0ZWFkXG4gICAgICAvL3JlbWVtYmVyIHRoZSBpbmRleCB0aGV5IGFyZSBhdCBhbmQgdW5kZWZpbmVkIHRoZWlyIHZhbHVlLlxuICAgICAgdGhpcy5fdG9SZW1vdmUucHVzaChpbmRleCk7XG4gICAgICBsaXN0ZW5lcnNbaW5kZXhdID0gdW5kZWZpbmVkO1xuICAgICAgc2NvcGVzW2luZGV4XSA9IHVuZGVmaW5lZDtcbiAgICB9IGVsc2Uge1xuICAgICAgbGlzdGVuZXJzLnNwbGljZShpbmRleCwgMSk7XG4gICAgICBzY29wZXMuc3BsaWNlKGluZGV4LCAxKTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59O1xuXG5mdW5jdGlvbiBjb21wYXJlTnVtYmVyKGEsIGIpIHtcbiAgcmV0dXJuIGIgLSBhO1xufVxuXG4vKipcbiAqIFJhaXNlcyB0aGUgZXZlbnQgYnkgY2FsbGluZyBlYWNoIHJlZ2lzdGVyZWQgbGlzdGVuZXIgd2l0aCBhbGwgc3VwcGxpZWQgYXJndW1lbnRzLlxuICpcbiAqIEBwYXJhbSB7Li4uT2JqZWN0fSBhcmd1bWVudHMgVGhpcyBtZXRob2QgdGFrZXMgYW55IG51bWJlciBvZiBwYXJhbWV0ZXJzIGFuZCBwYXNzZXMgdGhlbSB0aHJvdWdoIHRvIHRoZSBsaXN0ZW5lciBmdW5jdGlvbnMuXG4gKlxuICogQHNlZSBFdmVudCNhZGRFdmVudExpc3RlbmVyXG4gKiBAc2VlIEV2ZW50I3JlbW92ZUV2ZW50TGlzdGVuZXJcbiAqL1xuRXZlbnQucHJvdG90eXBlLnJhaXNlRXZlbnQgPSBmdW5jdGlvbiAoKSB7XG4gIHRoaXMuX2luc2lkZVJhaXNlRXZlbnQgPSB0cnVlO1xuXG4gIHZhciBpO1xuICB2YXIgbGlzdGVuZXJzID0gdGhpcy5fbGlzdGVuZXJzO1xuICB2YXIgc2NvcGVzID0gdGhpcy5fc2NvcGVzO1xuICB2YXIgbGVuZ3RoID0gbGlzdGVuZXJzLmxlbmd0aDtcblxuICBmb3IgKGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgbGlzdGVuZXIgPSBsaXN0ZW5lcnNbaV07XG4gICAgaWYgKGRlZmluZWQobGlzdGVuZXIpKSB7XG4gICAgICBsaXN0ZW5lcnNbaV0uYXBwbHkoc2NvcGVzW2ldLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgfVxuXG4gIC8vQWN0dWFsbHkgcmVtb3ZlIGl0ZW1zIHJlbW92ZWQgaW4gcmVtb3ZlRXZlbnRMaXN0ZW5lci5cbiAgdmFyIHRvUmVtb3ZlID0gdGhpcy5fdG9SZW1vdmU7XG4gIGxlbmd0aCA9IHRvUmVtb3ZlLmxlbmd0aDtcbiAgaWYgKGxlbmd0aCA+IDApIHtcbiAgICB0b1JlbW92ZS5zb3J0KGNvbXBhcmVOdW1iZXIpO1xuICAgIGZvciAoaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGluZGV4ID0gdG9SZW1vdmVbaV07XG4gICAgICBsaXN0ZW5lcnMuc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgIHNjb3Blcy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgIH1cbiAgICB0b1JlbW92ZS5sZW5ndGggPSAwO1xuICB9XG5cbiAgdGhpcy5faW5zaWRlUmFpc2VFdmVudCA9IGZhbHNlO1xufTtcblxuLyoqXG4gKiBBIGZ1bmN0aW9uIHRoYXQgcmVtb3ZlcyBhIGxpc3RlbmVyLlxuICogQGNhbGxiYWNrIEV2ZW50LlJlbW92ZUNhbGxiYWNrXG4gKi9cbmV4cG9ydCBkZWZhdWx0IEV2ZW50O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///14459\n")},79539:function(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__){eval('/* harmony import */ var _defined_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(82982);\n/* harmony import */ var _DeveloperError_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(12572);\n\n\n\n/**\n * A convenience object that simplifies the common pattern of attaching event listeners\n * to several events, then removing all those listeners at once later, for example, in\n * a destroy method.\n *\n * @alias EventHelper\n * @constructor\n *\n *\n * @example\n * var helper = new Cesium.EventHelper();\n *\n * helper.add(someObject.event, listener1, this);\n * helper.add(otherObject.event, listener2, this);\n *\n * // later...\n * helper.removeAll();\n *\n * @see Event\n */\nfunction EventHelper() {\n  this._removalFunctions = [];\n}\n\n/**\n * Adds a listener to an event, and records the registration to be cleaned up later.\n *\n * @param {Event} event The event to attach to.\n * @param {Function} listener The function to be executed when the event is raised.\n * @param {Object} [scope] An optional object scope to serve as the <code>this</code>\n *        pointer in which the listener function will execute.\n * @returns {EventHelper.RemoveCallback} A function that will remove this event listener when invoked.\n *\n * @see Event#addEventListener\n */\nEventHelper.prototype.add = function (event, listener, scope) {\n  //>>includeStart(\'debug\', pragmas.debug);\n  if (!(0,_defined_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .Z)(event)) {\n    throw new _DeveloperError_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .Z("event is required");\n  }\n  //>>includeEnd(\'debug\');\n\n  var removalFunction = event.addEventListener(listener, scope);\n  this._removalFunctions.push(removalFunction);\n\n  var that = this;\n  return function () {\n    removalFunction();\n    var removalFunctions = that._removalFunctions;\n    removalFunctions.splice(removalFunctions.indexOf(removalFunction), 1);\n  };\n};\n\n/**\n * Unregisters all previously added listeners.\n *\n * @see Event#removeEventListener\n */\nEventHelper.prototype.removeAll = function () {\n  var removalFunctions = this._removalFunctions;\n  for (var i = 0, len = removalFunctions.length; i < len; ++i) {\n    removalFunctions[i]();\n  }\n  removalFunctions.length = 0;\n};\n\n/**\n * A function that removes a listener.\n * @callback EventHelper.RemoveCallback\n */\n/* harmony default export */ __webpack_exports__["Z"] = (EventHelper);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNzk1MzkuanMiLCJtYXBwaW5ncyI6Ijs7QUFBbUM7QUFDYzs7QUFFakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsV0FBVyxVQUFVO0FBQ3JCLFdBQVcsUUFBUTtBQUNuQjtBQUNBLGFBQWEsNEJBQTRCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPLGdFQUFPO0FBQ2QsY0FBYyxtRUFBYztBQUM1QjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQsU0FBUztBQUMxRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlEQUFlLFdBQVcsRUFBQyIsInNvdXJjZXMiOlsid2VicGFjazovL3Z1ZTMtd2VicGFjazUvLi9ub2RlX21vZHVsZXMvY2VzaXVtL1NvdXJjZS9Db3JlL0V2ZW50SGVscGVyLmpzP2VhMDkiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IGRlZmluZWQgZnJvbSBcIi4vZGVmaW5lZC5qc1wiO1xuaW1wb3J0IERldmVsb3BlckVycm9yIGZyb20gXCIuL0RldmVsb3BlckVycm9yLmpzXCI7XG5cbi8qKlxuICogQSBjb252ZW5pZW5jZSBvYmplY3QgdGhhdCBzaW1wbGlmaWVzIHRoZSBjb21tb24gcGF0dGVybiBvZiBhdHRhY2hpbmcgZXZlbnQgbGlzdGVuZXJzXG4gKiB0byBzZXZlcmFsIGV2ZW50cywgdGhlbiByZW1vdmluZyBhbGwgdGhvc2UgbGlzdGVuZXJzIGF0IG9uY2UgbGF0ZXIsIGZvciBleGFtcGxlLCBpblxuICogYSBkZXN0cm95IG1ldGhvZC5cbiAqXG4gKiBAYWxpYXMgRXZlbnRIZWxwZXJcbiAqIEBjb25zdHJ1Y3RvclxuICpcbiAqXG4gKiBAZXhhbXBsZVxuICogdmFyIGhlbHBlciA9IG5ldyBDZXNpdW0uRXZlbnRIZWxwZXIoKTtcbiAqXG4gKiBoZWxwZXIuYWRkKHNvbWVPYmplY3QuZXZlbnQsIGxpc3RlbmVyMSwgdGhpcyk7XG4gKiBoZWxwZXIuYWRkKG90aGVyT2JqZWN0LmV2ZW50LCBsaXN0ZW5lcjIsIHRoaXMpO1xuICpcbiAqIC8vIGxhdGVyLi4uXG4gKiBoZWxwZXIucmVtb3ZlQWxsKCk7XG4gKlxuICogQHNlZSBFdmVudFxuICovXG5mdW5jdGlvbiBFdmVudEhlbHBlcigpIHtcbiAgdGhpcy5fcmVtb3ZhbEZ1bmN0aW9ucyA9IFtdO1xufVxuXG4vKipcbiAqIEFkZHMgYSBsaXN0ZW5lciB0byBhbiBldmVudCwgYW5kIHJlY29yZHMgdGhlIHJlZ2lzdHJhdGlvbiB0byBiZSBjbGVhbmVkIHVwIGxhdGVyLlxuICpcbiAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50IFRoZSBldmVudCB0byBhdHRhY2ggdG8uXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBsaXN0ZW5lciBUaGUgZnVuY3Rpb24gdG8gYmUgZXhlY3V0ZWQgd2hlbiB0aGUgZXZlbnQgaXMgcmFpc2VkLlxuICogQHBhcmFtIHtPYmplY3R9IFtzY29wZV0gQW4gb3B0aW9uYWwgb2JqZWN0IHNjb3BlIHRvIHNlcnZlIGFzIHRoZSA8Y29kZT50aGlzPC9jb2RlPlxuICogICAgICAgIHBvaW50ZXIgaW4gd2hpY2ggdGhlIGxpc3RlbmVyIGZ1bmN0aW9uIHdpbGwgZXhlY3V0ZS5cbiAqIEByZXR1cm5zIHtFdmVudEhlbHBlci5SZW1vdmVDYWxsYmFja30gQSBmdW5jdGlvbiB0aGF0IHdpbGwgcmVtb3ZlIHRoaXMgZXZlbnQgbGlzdGVuZXIgd2hlbiBpbnZva2VkLlxuICpcbiAqIEBzZWUgRXZlbnQjYWRkRXZlbnRMaXN0ZW5lclxuICovXG5FdmVudEhlbHBlci5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24gKGV2ZW50LCBsaXN0ZW5lciwgc2NvcGUpIHtcbiAgLy8+PmluY2x1ZGVTdGFydCgnZGVidWcnLCBwcmFnbWFzLmRlYnVnKTtcbiAgaWYgKCFkZWZpbmVkKGV2ZW50KSkge1xuICAgIHRocm93IG5ldyBEZXZlbG9wZXJFcnJvcihcImV2ZW50IGlzIHJlcXVpcmVkXCIpO1xuICB9XG4gIC8vPj5pbmNsdWRlRW5kKCdkZWJ1ZycpO1xuXG4gIHZhciByZW1vdmFsRnVuY3Rpb24gPSBldmVudC5hZGRFdmVudExpc3RlbmVyKGxpc3RlbmVyLCBzY29wZSk7XG4gIHRoaXMuX3JlbW92YWxGdW5jdGlvbnMucHVzaChyZW1vdmFsRnVuY3Rpb24pO1xuXG4gIHZhciB0aGF0ID0gdGhpcztcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICByZW1vdmFsRnVuY3Rpb24oKTtcbiAgICB2YXIgcmVtb3ZhbEZ1bmN0aW9ucyA9IHRoYXQuX3JlbW92YWxGdW5jdGlvbnM7XG4gICAgcmVtb3ZhbEZ1bmN0aW9ucy5zcGxpY2UocmVtb3ZhbEZ1bmN0aW9ucy5pbmRleE9mKHJlbW92YWxGdW5jdGlvbiksIDEpO1xuICB9O1xufTtcblxuLyoqXG4gKiBVbnJlZ2lzdGVycyBhbGwgcHJldmlvdXNseSBhZGRlZCBsaXN0ZW5lcnMuXG4gKlxuICogQHNlZSBFdmVudCNyZW1vdmVFdmVudExpc3RlbmVyXG4gKi9cbkV2ZW50SGVscGVyLnByb3RvdHlwZS5yZW1vdmVBbGwgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciByZW1vdmFsRnVuY3Rpb25zID0gdGhpcy5fcmVtb3ZhbEZ1bmN0aW9ucztcbiAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHJlbW92YWxGdW5jdGlvbnMubGVuZ3RoOyBpIDwgbGVuOyArK2kpIHtcbiAgICByZW1vdmFsRnVuY3Rpb25zW2ldKCk7XG4gIH1cbiAgcmVtb3ZhbEZ1bmN0aW9ucy5sZW5ndGggPSAwO1xufTtcblxuLyoqXG4gKiBBIGZ1bmN0aW9uIHRoYXQgcmVtb3ZlcyBhIGxpc3RlbmVyLlxuICogQGNhbGxiYWNrIEV2ZW50SGVscGVyLlJlbW92ZUNhbGxiYWNrXG4gKi9cbmV4cG9ydCBkZWZhdWx0IEV2ZW50SGVscGVyO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///79539\n')}}]);