"use strict";(self["webpackChunkvue3_webpack5"]=self["webpackChunkvue3_webpack5"]||[]).push([[7105],{50442:function(__unused_webpack___webpack_module__,__webpack_exports__){eval("//This file is automatically rebuilt by the Cesium build process.\n/* harmony default export */ __webpack_exports__[\"Z\"] = (\"uniform sampler2D u_noiseTexture;\\n\\\nuniform float u_noiseTextureLength;\\n\\\nuniform float u_noiseDetail;\\n\\\nvarying vec2 v_offset;\\n\\\nvarying vec3 v_maximumSize;\\n\\\nvarying float v_slice;\\n\\\nvarying float v_brightness;\\n\\\n\\n\\\nfloat wrap(float value, float rangeLength) {\\n\\\n    if(value < 0.0) {\\n\\\n        float absValue = abs(value);\\n\\\n        float modValue = mod(absValue, rangeLength);\\n\\\n        return mod(rangeLength - modValue, rangeLength);\\n\\\n    }\\n\\\n    return mod(value, rangeLength);\\n\\\n}\\n\\\n\\n\\\nvec3 wrapVec(vec3 value, float rangeLength) {\\n\\\n    return vec3(wrap(value.x, rangeLength),\\n\\\n                wrap(value.y, rangeLength),\\n\\\n                wrap(value.z, rangeLength));\\n\\\n}\\n\\\n\\n\\\nfloat noiseTextureLengthSquared = u_noiseTextureLength * u_noiseTextureLength;\\n\\\nvec3 dimensions = vec3(noiseTextureLengthSquared,\\n\\\n                       u_noiseTextureLength,\\n\\\n                       u_noiseTextureLength);\\n\\\n\\n\\\nvec4 sampleNoiseTexture(vec3 position) {\\n\\\n    vec3 recenteredPos = position + vec3(u_noiseTextureLength / 2.0);\\n\\\n    vec3 lerpValue = fract(recenteredPos);\\n\\\n\\n\\\n    vec3 slice = floor(recenteredPos);\\n\\\n    vec3 slice0 = wrapVec(slice, u_noiseTextureLength);\\n\\\n    vec3 slice1 = wrapVec(slice0 + vec3(1.0), u_noiseTextureLength);\\n\\\n    slice0 /= dimensions;\\n\\\n    slice1 /= dimensions;\\n\\\n\\n\\\n    float u00 = slice0.x + slice0.z;\\n\\\n    float u01 = slice0.x + slice1.z;\\n\\\n    float u10 = slice1.x + slice0.z;\\n\\\n    float u11 = slice1.x + slice1.z;\\n\\\n\\n\\\n    vec2 uv000 = vec2(u00, slice0.y);\\n\\\n    vec2 uv001 = vec2(u01, slice0.y);\\n\\\n    vec2 uv010 = vec2(u00, slice1.y);\\n\\\n    vec2 uv011 = vec2(u01, slice1.y);\\n\\\n    vec2 uv100 = vec2(u10, slice0.y);\\n\\\n    vec2 uv101 = vec2(u11, slice0.y);\\n\\\n    vec2 uv110 = vec2(u10, slice1.y);\\n\\\n    vec2 uv111 = vec2(u11, slice1.y);\\n\\\n\\n\\\n    vec4 sample000 = texture2D(u_noiseTexture, uv000);\\n\\\n    vec4 sample001 = texture2D(u_noiseTexture, uv001);\\n\\\n    vec4 sample010 = texture2D(u_noiseTexture, uv010);\\n\\\n    vec4 sample011 = texture2D(u_noiseTexture, uv011);\\n\\\n    vec4 sample100 = texture2D(u_noiseTexture, uv100);\\n\\\n    vec4 sample101 = texture2D(u_noiseTexture, uv101);\\n\\\n    vec4 sample110 = texture2D(u_noiseTexture, uv110);\\n\\\n    vec4 sample111 = texture2D(u_noiseTexture, uv111);\\n\\\n\\n\\\n    vec4 xLerp00 = mix(sample000, sample100, lerpValue.x);\\n\\\n    vec4 xLerp01 = mix(sample001, sample101, lerpValue.x);\\n\\\n    vec4 xLerp10 = mix(sample010, sample110, lerpValue.x);\\n\\\n    vec4 xLerp11 = mix(sample011, sample111, lerpValue.x);\\n\\\n\\n\\\n    vec4 yLerp0 = mix(xLerp00, xLerp10, lerpValue.y);\\n\\\n    vec4 yLerp1 = mix(xLerp01, xLerp11, lerpValue.y);\\n\\\n    return mix(yLerp0, yLerp1, lerpValue.z);\\n\\\n}\\n\\\n\\n\\\n// Intersection with a unit sphere with radius 0.5 at center (0, 0, 0).\\n\\\nbool intersectSphere(vec3 origin, vec3 dir, float slice,\\n\\\n                     out vec3 point, out vec3 normal) {  \\n\\\n    float A = dot(dir, dir);\\n\\\n    float B = dot(origin, dir);\\n\\\n    float C = dot(origin, origin) - 0.25;\\n\\\n    float discriminant = (B * B) - (A * C);\\n\\\n    if(discriminant < 0.0) {\\n\\\n        return false;\\n\\\n    }\\n\\\n    float root = sqrt(discriminant);\\n\\\n    float t = (-B - root) / A;\\n\\\n    if(t < 0.0) {\\n\\\n        t = (-B + root) / A;\\n\\\n    }\\n\\\n    point = origin + t * dir;\\n\\\n    \\n\\\n    if(slice >= 0.0) {\\n\\\n        point.z = (slice / 2.0) - 0.5;\\n\\\n        if(length(point) > 0.5) {\\n\\\n            return false;\\n\\\n        }\\n\\\n    }\\n\\\n\\n\\\n    normal = normalize(point);\\n\\\n    point -= czm_epsilon2 * normal;\\n\\\n\\n\\\n    return true;\\n\\\n}\\n\\\n\\n\\\n// Transforms the ray origin and direction into unit sphere space,\\n\\\n// then transforms the result back into the ellipsoid's space.\\n\\\nbool intersectEllipsoid(vec3 origin, vec3 dir, vec3 center, vec3 scale, float slice,\\n\\\n                        out vec3 point, out vec3 normal) {\\n\\\n    if(scale.x <= 0.01 || scale.y < 0.01 || scale.z < 0.01) {\\n\\\n        return false;\\n\\\n    }\\n\\\n\\n\\\n    vec3 o = (origin - center) / scale;\\n\\\n    vec3 d = dir / scale;\\n\\\n    vec3 p, n;\\n\\\n    bool intersected = intersectSphere(o, d, slice, p, n);\\n\\\n    if(intersected) {\\n\\\n        point = (p * scale) + center;\\n\\\n        normal = n;\\n\\\n    }\\n\\\n    return intersected;\\n\\\n}\\n\\\n\\n\\\n// Assume that if phase shift is being called for octave i,\\n\\\n// the frequency is of i - 1. This saves us from doing extra\\n\\\n// division / multiplication operations.\\n\\\nvec2 phaseShift2D(vec2 p, vec2 freq) {\\n\\\n    return (czm_pi / 2.0) * sin(freq.yx * p.yx); \\n\\\n}\\n\\\n\\n\\\nvec2 phaseShift3D(vec3 p, vec2 freq) {\\n\\\n    return phaseShift2D(p.xy, freq) + czm_pi * vec2(sin(freq.x * p.z));\\n\\\n}\\n\\\n\\n\\\n// The cloud texture function derived from Gardner's 1985 paper,\\n\\\n// \\\"Visual Simulation of Clouds.\\\"\\n\\\n// https://www.cs.drexel.edu/~david/Classes/Papers/p297-gardner.pdf\\n\\\nconst float T0    = 0.6;  // contrast of the texture pattern\\n\\\nconst float k     = 0.1;  // computed to produce a maximum value of 1 \\n\\\nconst float C0    = 0.8;  // coefficient\\n\\\nconst float FX0   = 0.6;  // frequency X\\n\\\nconst float FY0   = 0.6;  // frequency Y\\n\\\nconst int octaves = 5;\\n\\\n\\n\\\nfloat T(vec3 point) {\\n\\\n    vec2 sum = vec2(0.0);\\n\\\n    float Ci = C0;\\n\\\n    vec2 FXY = vec2(FX0, FY0);\\n\\\n    vec2 PXY = vec2(0.0);\\n\\\n    for(int i = 1; i <= octaves; i++) {\\n\\\n        PXY = phaseShift3D(point, FXY);\\n\\\n        Ci *= 0.707;\\n\\\n        FXY *= 2.0;\\n\\\n        vec2 sinTerm = sin(FXY * point.xy + PXY);\\n\\\n        sum += Ci * sinTerm + vec2(T0);\\n\\\n    }\\n\\\n    return k * sum.x * sum.y;\\n\\\n}\\n\\\n\\n\\\nconst float a = 0.5;  // fraction of surface reflection due to ambient or scattered light, \\n\\\nconst float t = 0.4;  // fraction of texture shading \\n\\\nconst float s = 0.25; // fraction of specular reflection\\n\\\n\\n\\\nfloat I(float Id, float Is, float It) {\\n\\\n    return (1.0 - a) * ((1.0 - t) * ((1.0 - s) * Id + s * Is) + t * It) + a;\\n\\\n}\\n\\\n\\n\\\nconst vec3 lightDir = normalize(vec3(0.2, -1.0, 0.7));\\n\\\n\\n\\\nvec4 drawCloud(vec3 rayOrigin, vec3 rayDir, vec3 cloudCenter, vec3 cloudScale, float cloudSlice,\\n\\\n               float brightness) {\\n\\\n    vec3 cloudPoint, cloudNormal;\\n\\\n    if(!intersectEllipsoid(rayOrigin, rayDir, cloudCenter, cloudScale, cloudSlice,\\n\\\n                            cloudPoint, cloudNormal)) {\\n\\\n        return vec4(0.0);\\n\\\n    }\\n\\\n\\n\\\n    float Id = clamp(dot(cloudNormal, -lightDir), 0.0, 1.0);  // diffuse reflection\\n\\\n    float Is = max(pow(dot(-lightDir, -rayDir), 2.0), 0.0);   // specular reflection\\n\\\n    float It = T(cloudPoint);                                 // texture function\\n\\\n    float intensity = I(Id, Is, It);\\n\\\n    vec3 color = intensity * clamp(brightness, 0.1, 1.0) * vec3(1.0);\\n\\\n\\n\\\n    vec4 noise = sampleNoiseTexture(u_noiseDetail * cloudPoint);\\n\\\n    float W = noise.x;\\n\\\n    float W2 = noise.y;\\n\\\n    float W3 = noise.z;\\n\\\n\\n\\\n    // The dot product between the cloud's normal and the ray's direction is greatest\\n\\\n    // in the center of the ellipsoid's surface. It decreases towards the edge.\\n\\\n    // Thus, it is used to blur the areas leading to the edges of the ellipsoid,\\n\\\n    // so that no harsh lines appear.\\n\\\n    \\n\\\n    // The first (and biggest) layer of worley noise is then subtracted from this.\\n\\\n    // The final result is scaled up so that the base cloud is not too translucent.\\n\\\n    float ndDot = clamp(dot(cloudNormal, -rayDir), 0.0, 1.0);\\n\\\n    float TR = pow(ndDot, 3.0) - W; // translucency\\n\\\n    TR *= 1.3;\\n\\\n    \\n\\\n    // Subtracting the second and third layers of worley noise is more complicated.\\n\\\n    // If these layers of noise were simply subtracted from the current translucency,\\n\\\n    // the shape derived from the first layer of noise would be completely deleted.\\n\\\n    // The erosion of this noise should thus be constricted to the edges of the cloud.\\n\\\n    // However, because the edges of the ellipsoid were already blurred away, mapping\\n\\\n    // the noise to (1.0 - ndDot) will have no impact on most of the cloud's appearance.\\n\\\n    // The value of (0.5 - ndDot) provides the best compromise.\\n\\\n    float minusDot = 0.5 - ndDot;\\n\\\n\\n\\\n    // Even with the previous calculation, subtracting the second layer of wnoise\\n\\\n    // erode too much of the cloud. The addition of it, however, will detailed\\n\\\n    // volume to the cloud. As long as the noise is only added and not subtracted,\\n\\\n    // the results are aesthetically pleasing.\\n\\\n    \\n\\\n    // The minusDot product is mapped in a way that it is larger at the edges of\\n\\\n    // the ellipsoid, so a subtraction and min operation are used instead of\\n\\\n    // an addition and max one.\\n\\\n    TR -= min(minusDot * W2, 0.0);\\n\\\n\\n\\\n    // The third level of worley noise is subtracted from the result, with some\\n\\\n    // modifications. First, a scalar is added to minusDot so that the noise\\n\\\n    // starts affecting the shape farther away from the center of the ellipsoid's\\n\\\n    // surface. Then, it is scaled down so its impact is not too intense.\\n\\\n    TR -= 0.8 * (minusDot + 0.25) * W3;\\n\\\n\\n\\\n    // The texture function's shading does not correlate with the shape of the cloud\\n\\\n    // produced by the layers of noise, so an extra shading scalar is calculated.\\n\\\n    // The darkest areas of the cloud are assigned to be where the noise erodes\\n\\\n    // the cloud the most. This is then interpolated based on the translucency\\n\\\n    // and the diffuse shading term of that point in the cloud.\\n\\\n    float shading = mix(1.0 - 0.8 * W * W, 1.0, Id * TR);\\n\\\n\\n\\\n    // To avoid values that are too dark, this scalar is increased by a small amount\\n\\\n    // and clamped so it never goes to zero.\\n\\\n    shading = clamp(shading + 0.2, 0.3, 1.0);\\n\\\n\\n\\\n    // Finally, the contrast of the cloud's color is increased.\\n\\\n    vec3 finalColor = mix(vec3(0.5), shading * color, 1.15);\\n\\\n    return vec4(finalColor, clamp(TR, 0.0, 1.0));\\n\\\n}\\n\\\n\\n\\\nvoid main() {\\n\\\n#ifdef DEBUG_BILLBOARDS\\n\\\n    gl_FragColor = vec4(0.0, 0.5, 0.5, 1.0);\\n\\\n#endif\\n\\\n    \\n\\\n    // To avoid calculations with high values,\\n\\\n    // we raycast from an arbitrarily smaller space.\\n\\\n    vec2 coordinate = v_maximumSize.xy * v_offset;\\n\\\n\\n\\\n    vec3 ellipsoidScale = 0.82 * v_maximumSize;\\n\\\n    vec3 ellipsoidCenter = vec3(0.0);\\n\\\n\\n\\\n    float zOffset = max(ellipsoidScale.z - 10.0, 0.0);\\n\\\n    vec3 eye = vec3(0, 0, -10.0 - zOffset);\\n\\\n    vec3 rayDir = normalize(vec3(coordinate, 1.0) - eye);\\n\\\n    vec3 rayOrigin = eye;\\n\\\n\\n\\\n#ifdef DEBUG_ELLIPSOIDS\\n\\\n    vec3 point, normal;\\n\\\n    if(intersectEllipsoid(rayOrigin, rayDir, ellipsoidCenter, ellipsoidScale, v_slice,\\n\\\n                          point, normal)) {\\n\\\n        gl_FragColor = v_brightness * vec4(1.0);\\n\\\n    }\\n\\\n#else\\n\\\n#ifndef DEBUG_BILLBOARDS\\n\\\n    vec4 cloud = drawCloud(rayOrigin, rayDir,\\n\\\n                           ellipsoidCenter, ellipsoidScale, v_slice, v_brightness);    \\n\\\n    if(cloud.w < 0.01) {\\n\\\n        discard;\\n\\\n    }\\n\\\n    gl_FragColor = cloud;\\n\\\n#endif\\n\\\n#endif\\n\\\n}\\n\\\n\");\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QTtBQUNBLENBQUM7QUFDRCxDQUFDLEVBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly92dWUzLXdlYnBhY2s1Ly4vbm9kZV9tb2R1bGVzL2Nlc2l1bS9Tb3VyY2UvU2hhZGVycy9DbG91ZENvbGxlY3Rpb25GUy5qcz8yNmI1Il0sInNvdXJjZXNDb250ZW50IjpbIi8vVGhpcyBmaWxlIGlzIGF1dG9tYXRpY2FsbHkgcmVidWlsdCBieSB0aGUgQ2VzaXVtIGJ1aWxkIHByb2Nlc3MuXG5leHBvcnQgZGVmYXVsdCBcInVuaWZvcm0gc2FtcGxlcjJEIHVfbm9pc2VUZXh0dXJlO1xcblxcXG51bmlmb3JtIGZsb2F0IHVfbm9pc2VUZXh0dXJlTGVuZ3RoO1xcblxcXG51bmlmb3JtIGZsb2F0IHVfbm9pc2VEZXRhaWw7XFxuXFxcbnZhcnlpbmcgdmVjMiB2X29mZnNldDtcXG5cXFxudmFyeWluZyB2ZWMzIHZfbWF4aW11bVNpemU7XFxuXFxcbnZhcnlpbmcgZmxvYXQgdl9zbGljZTtcXG5cXFxudmFyeWluZyBmbG9hdCB2X2JyaWdodG5lc3M7XFxuXFxcblxcblxcXG5mbG9hdCB3cmFwKGZsb2F0IHZhbHVlLCBmbG9hdCByYW5nZUxlbmd0aCkge1xcblxcXG4gICAgaWYodmFsdWUgPCAwLjApIHtcXG5cXFxuICAgICAgICBmbG9hdCBhYnNWYWx1ZSA9IGFicyh2YWx1ZSk7XFxuXFxcbiAgICAgICAgZmxvYXQgbW9kVmFsdWUgPSBtb2QoYWJzVmFsdWUsIHJhbmdlTGVuZ3RoKTtcXG5cXFxuICAgICAgICByZXR1cm4gbW9kKHJhbmdlTGVuZ3RoIC0gbW9kVmFsdWUsIHJhbmdlTGVuZ3RoKTtcXG5cXFxuICAgIH1cXG5cXFxuICAgIHJldHVybiBtb2QodmFsdWUsIHJhbmdlTGVuZ3RoKTtcXG5cXFxufVxcblxcXG5cXG5cXFxudmVjMyB3cmFwVmVjKHZlYzMgdmFsdWUsIGZsb2F0IHJhbmdlTGVuZ3RoKSB7XFxuXFxcbiAgICByZXR1cm4gdmVjMyh3cmFwKHZhbHVlLngsIHJhbmdlTGVuZ3RoKSxcXG5cXFxuICAgICAgICAgICAgICAgIHdyYXAodmFsdWUueSwgcmFuZ2VMZW5ndGgpLFxcblxcXG4gICAgICAgICAgICAgICAgd3JhcCh2YWx1ZS56LCByYW5nZUxlbmd0aCkpO1xcblxcXG59XFxuXFxcblxcblxcXG5mbG9hdCBub2lzZVRleHR1cmVMZW5ndGhTcXVhcmVkID0gdV9ub2lzZVRleHR1cmVMZW5ndGggKiB1X25vaXNlVGV4dHVyZUxlbmd0aDtcXG5cXFxudmVjMyBkaW1lbnNpb25zID0gdmVjMyhub2lzZVRleHR1cmVMZW5ndGhTcXVhcmVkLFxcblxcXG4gICAgICAgICAgICAgICAgICAgICAgIHVfbm9pc2VUZXh0dXJlTGVuZ3RoLFxcblxcXG4gICAgICAgICAgICAgICAgICAgICAgIHVfbm9pc2VUZXh0dXJlTGVuZ3RoKTtcXG5cXFxuXFxuXFxcbnZlYzQgc2FtcGxlTm9pc2VUZXh0dXJlKHZlYzMgcG9zaXRpb24pIHtcXG5cXFxuICAgIHZlYzMgcmVjZW50ZXJlZFBvcyA9IHBvc2l0aW9uICsgdmVjMyh1X25vaXNlVGV4dHVyZUxlbmd0aCAvIDIuMCk7XFxuXFxcbiAgICB2ZWMzIGxlcnBWYWx1ZSA9IGZyYWN0KHJlY2VudGVyZWRQb3MpO1xcblxcXG5cXG5cXFxuICAgIHZlYzMgc2xpY2UgPSBmbG9vcihyZWNlbnRlcmVkUG9zKTtcXG5cXFxuICAgIHZlYzMgc2xpY2UwID0gd3JhcFZlYyhzbGljZSwgdV9ub2lzZVRleHR1cmVMZW5ndGgpO1xcblxcXG4gICAgdmVjMyBzbGljZTEgPSB3cmFwVmVjKHNsaWNlMCArIHZlYzMoMS4wKSwgdV9ub2lzZVRleHR1cmVMZW5ndGgpO1xcblxcXG4gICAgc2xpY2UwIC89IGRpbWVuc2lvbnM7XFxuXFxcbiAgICBzbGljZTEgLz0gZGltZW5zaW9ucztcXG5cXFxuXFxuXFxcbiAgICBmbG9hdCB1MDAgPSBzbGljZTAueCArIHNsaWNlMC56O1xcblxcXG4gICAgZmxvYXQgdTAxID0gc2xpY2UwLnggKyBzbGljZTEuejtcXG5cXFxuICAgIGZsb2F0IHUxMCA9IHNsaWNlMS54ICsgc2xpY2UwLno7XFxuXFxcbiAgICBmbG9hdCB1MTEgPSBzbGljZTEueCArIHNsaWNlMS56O1xcblxcXG5cXG5cXFxuICAgIHZlYzIgdXYwMDAgPSB2ZWMyKHUwMCwgc2xpY2UwLnkpO1xcblxcXG4gICAgdmVjMiB1djAwMSA9IHZlYzIodTAxLCBzbGljZTAueSk7XFxuXFxcbiAgICB2ZWMyIHV2MDEwID0gdmVjMih1MDAsIHNsaWNlMS55KTtcXG5cXFxuICAgIHZlYzIgdXYwMTEgPSB2ZWMyKHUwMSwgc2xpY2UxLnkpO1xcblxcXG4gICAgdmVjMiB1djEwMCA9IHZlYzIodTEwLCBzbGljZTAueSk7XFxuXFxcbiAgICB2ZWMyIHV2MTAxID0gdmVjMih1MTEsIHNsaWNlMC55KTtcXG5cXFxuICAgIHZlYzIgdXYxMTAgPSB2ZWMyKHUxMCwgc2xpY2UxLnkpO1xcblxcXG4gICAgdmVjMiB1djExMSA9IHZlYzIodTExLCBzbGljZTEueSk7XFxuXFxcblxcblxcXG4gICAgdmVjNCBzYW1wbGUwMDAgPSB0ZXh0dXJlMkQodV9ub2lzZVRleHR1cmUsIHV2MDAwKTtcXG5cXFxuICAgIHZlYzQgc2FtcGxlMDAxID0gdGV4dHVyZTJEKHVfbm9pc2VUZXh0dXJlLCB1djAwMSk7XFxuXFxcbiAgICB2ZWM0IHNhbXBsZTAxMCA9IHRleHR1cmUyRCh1X25vaXNlVGV4dHVyZSwgdXYwMTApO1xcblxcXG4gICAgdmVjNCBzYW1wbGUwMTEgPSB0ZXh0dXJlMkQodV9ub2lzZVRleHR1cmUsIHV2MDExKTtcXG5cXFxuICAgIHZlYzQgc2FtcGxlMTAwID0gdGV4dHVyZTJEKHVfbm9pc2VUZXh0dXJlLCB1djEwMCk7XFxuXFxcbiAgICB2ZWM0IHNhbXBsZTEwMSA9IHRleHR1cmUyRCh1X25vaXNlVGV4dHVyZSwgdXYxMDEpO1xcblxcXG4gICAgdmVjNCBzYW1wbGUxMTAgPSB0ZXh0dXJlMkQodV9ub2lzZVRleHR1cmUsIHV2MTEwKTtcXG5cXFxuICAgIHZlYzQgc2FtcGxlMTExID0gdGV4dHVyZTJEKHVfbm9pc2VUZXh0dXJlLCB1djExMSk7XFxuXFxcblxcblxcXG4gICAgdmVjNCB4TGVycDAwID0gbWl4KHNhbXBsZTAwMCwgc2FtcGxlMTAwLCBsZXJwVmFsdWUueCk7XFxuXFxcbiAgICB2ZWM0IHhMZXJwMDEgPSBtaXgoc2FtcGxlMDAxLCBzYW1wbGUxMDEsIGxlcnBWYWx1ZS54KTtcXG5cXFxuICAgIHZlYzQgeExlcnAxMCA9IG1peChzYW1wbGUwMTAsIHNhbXBsZTExMCwgbGVycFZhbHVlLngpO1xcblxcXG4gICAgdmVjNCB4TGVycDExID0gbWl4KHNhbXBsZTAxMSwgc2FtcGxlMTExLCBsZXJwVmFsdWUueCk7XFxuXFxcblxcblxcXG4gICAgdmVjNCB5TGVycDAgPSBtaXgoeExlcnAwMCwgeExlcnAxMCwgbGVycFZhbHVlLnkpO1xcblxcXG4gICAgdmVjNCB5TGVycDEgPSBtaXgoeExlcnAwMSwgeExlcnAxMSwgbGVycFZhbHVlLnkpO1xcblxcXG4gICAgcmV0dXJuIG1peCh5TGVycDAsIHlMZXJwMSwgbGVycFZhbHVlLnopO1xcblxcXG59XFxuXFxcblxcblxcXG4vLyBJbnRlcnNlY3Rpb24gd2l0aCBhIHVuaXQgc3BoZXJlIHdpdGggcmFkaXVzIDAuNSBhdCBjZW50ZXIgKDAsIDAsIDApLlxcblxcXG5ib29sIGludGVyc2VjdFNwaGVyZSh2ZWMzIG9yaWdpbiwgdmVjMyBkaXIsIGZsb2F0IHNsaWNlLFxcblxcXG4gICAgICAgICAgICAgICAgICAgICBvdXQgdmVjMyBwb2ludCwgb3V0IHZlYzMgbm9ybWFsKSB7ICBcXG5cXFxuICAgIGZsb2F0IEEgPSBkb3QoZGlyLCBkaXIpO1xcblxcXG4gICAgZmxvYXQgQiA9IGRvdChvcmlnaW4sIGRpcik7XFxuXFxcbiAgICBmbG9hdCBDID0gZG90KG9yaWdpbiwgb3JpZ2luKSAtIDAuMjU7XFxuXFxcbiAgICBmbG9hdCBkaXNjcmltaW5hbnQgPSAoQiAqIEIpIC0gKEEgKiBDKTtcXG5cXFxuICAgIGlmKGRpc2NyaW1pbmFudCA8IDAuMCkge1xcblxcXG4gICAgICAgIHJldHVybiBmYWxzZTtcXG5cXFxuICAgIH1cXG5cXFxuICAgIGZsb2F0IHJvb3QgPSBzcXJ0KGRpc2NyaW1pbmFudCk7XFxuXFxcbiAgICBmbG9hdCB0ID0gKC1CIC0gcm9vdCkgLyBBO1xcblxcXG4gICAgaWYodCA8IDAuMCkge1xcblxcXG4gICAgICAgIHQgPSAoLUIgKyByb290KSAvIEE7XFxuXFxcbiAgICB9XFxuXFxcbiAgICBwb2ludCA9IG9yaWdpbiArIHQgKiBkaXI7XFxuXFxcbiAgICBcXG5cXFxuICAgIGlmKHNsaWNlID49IDAuMCkge1xcblxcXG4gICAgICAgIHBvaW50LnogPSAoc2xpY2UgLyAyLjApIC0gMC41O1xcblxcXG4gICAgICAgIGlmKGxlbmd0aChwb2ludCkgPiAwLjUpIHtcXG5cXFxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xcblxcXG4gICAgICAgIH1cXG5cXFxuICAgIH1cXG5cXFxuXFxuXFxcbiAgICBub3JtYWwgPSBub3JtYWxpemUocG9pbnQpO1xcblxcXG4gICAgcG9pbnQgLT0gY3ptX2Vwc2lsb24yICogbm9ybWFsO1xcblxcXG5cXG5cXFxuICAgIHJldHVybiB0cnVlO1xcblxcXG59XFxuXFxcblxcblxcXG4vLyBUcmFuc2Zvcm1zIHRoZSByYXkgb3JpZ2luIGFuZCBkaXJlY3Rpb24gaW50byB1bml0IHNwaGVyZSBzcGFjZSxcXG5cXFxuLy8gdGhlbiB0cmFuc2Zvcm1zIHRoZSByZXN1bHQgYmFjayBpbnRvIHRoZSBlbGxpcHNvaWQncyBzcGFjZS5cXG5cXFxuYm9vbCBpbnRlcnNlY3RFbGxpcHNvaWQodmVjMyBvcmlnaW4sIHZlYzMgZGlyLCB2ZWMzIGNlbnRlciwgdmVjMyBzY2FsZSwgZmxvYXQgc2xpY2UsXFxuXFxcbiAgICAgICAgICAgICAgICAgICAgICAgIG91dCB2ZWMzIHBvaW50LCBvdXQgdmVjMyBub3JtYWwpIHtcXG5cXFxuICAgIGlmKHNjYWxlLnggPD0gMC4wMSB8fCBzY2FsZS55IDwgMC4wMSB8fCBzY2FsZS56IDwgMC4wMSkge1xcblxcXG4gICAgICAgIHJldHVybiBmYWxzZTtcXG5cXFxuICAgIH1cXG5cXFxuXFxuXFxcbiAgICB2ZWMzIG8gPSAob3JpZ2luIC0gY2VudGVyKSAvIHNjYWxlO1xcblxcXG4gICAgdmVjMyBkID0gZGlyIC8gc2NhbGU7XFxuXFxcbiAgICB2ZWMzIHAsIG47XFxuXFxcbiAgICBib29sIGludGVyc2VjdGVkID0gaW50ZXJzZWN0U3BoZXJlKG8sIGQsIHNsaWNlLCBwLCBuKTtcXG5cXFxuICAgIGlmKGludGVyc2VjdGVkKSB7XFxuXFxcbiAgICAgICAgcG9pbnQgPSAocCAqIHNjYWxlKSArIGNlbnRlcjtcXG5cXFxuICAgICAgICBub3JtYWwgPSBuO1xcblxcXG4gICAgfVxcblxcXG4gICAgcmV0dXJuIGludGVyc2VjdGVkO1xcblxcXG59XFxuXFxcblxcblxcXG4vLyBBc3N1bWUgdGhhdCBpZiBwaGFzZSBzaGlmdCBpcyBiZWluZyBjYWxsZWQgZm9yIG9jdGF2ZSBpLFxcblxcXG4vLyB0aGUgZnJlcXVlbmN5IGlzIG9mIGkgLSAxLiBUaGlzIHNhdmVzIHVzIGZyb20gZG9pbmcgZXh0cmFcXG5cXFxuLy8gZGl2aXNpb24gLyBtdWx0aXBsaWNhdGlvbiBvcGVyYXRpb25zLlxcblxcXG52ZWMyIHBoYXNlU2hpZnQyRCh2ZWMyIHAsIHZlYzIgZnJlcSkge1xcblxcXG4gICAgcmV0dXJuIChjem1fcGkgLyAyLjApICogc2luKGZyZXEueXggKiBwLnl4KTsgXFxuXFxcbn1cXG5cXFxuXFxuXFxcbnZlYzIgcGhhc2VTaGlmdDNEKHZlYzMgcCwgdmVjMiBmcmVxKSB7XFxuXFxcbiAgICByZXR1cm4gcGhhc2VTaGlmdDJEKHAueHksIGZyZXEpICsgY3ptX3BpICogdmVjMihzaW4oZnJlcS54ICogcC56KSk7XFxuXFxcbn1cXG5cXFxuXFxuXFxcbi8vIFRoZSBjbG91ZCB0ZXh0dXJlIGZ1bmN0aW9uIGRlcml2ZWQgZnJvbSBHYXJkbmVyJ3MgMTk4NSBwYXBlcixcXG5cXFxuLy8gXFxcIlZpc3VhbCBTaW11bGF0aW9uIG9mIENsb3Vkcy5cXFwiXFxuXFxcbi8vIGh0dHBzOi8vd3d3LmNzLmRyZXhlbC5lZHUvfmRhdmlkL0NsYXNzZXMvUGFwZXJzL3AyOTctZ2FyZG5lci5wZGZcXG5cXFxuY29uc3QgZmxvYXQgVDAgICAgPSAwLjY7ICAvLyBjb250cmFzdCBvZiB0aGUgdGV4dHVyZSBwYXR0ZXJuXFxuXFxcbmNvbnN0IGZsb2F0IGsgICAgID0gMC4xOyAgLy8gY29tcHV0ZWQgdG8gcHJvZHVjZSBhIG1heGltdW0gdmFsdWUgb2YgMSBcXG5cXFxuY29uc3QgZmxvYXQgQzAgICAgPSAwLjg7ICAvLyBjb2VmZmljaWVudFxcblxcXG5jb25zdCBmbG9hdCBGWDAgICA9IDAuNjsgIC8vIGZyZXF1ZW5jeSBYXFxuXFxcbmNvbnN0IGZsb2F0IEZZMCAgID0gMC42OyAgLy8gZnJlcXVlbmN5IFlcXG5cXFxuY29uc3QgaW50IG9jdGF2ZXMgPSA1O1xcblxcXG5cXG5cXFxuZmxvYXQgVCh2ZWMzIHBvaW50KSB7XFxuXFxcbiAgICB2ZWMyIHN1bSA9IHZlYzIoMC4wKTtcXG5cXFxuICAgIGZsb2F0IENpID0gQzA7XFxuXFxcbiAgICB2ZWMyIEZYWSA9IHZlYzIoRlgwLCBGWTApO1xcblxcXG4gICAgdmVjMiBQWFkgPSB2ZWMyKDAuMCk7XFxuXFxcbiAgICBmb3IoaW50IGkgPSAxOyBpIDw9IG9jdGF2ZXM7IGkrKykge1xcblxcXG4gICAgICAgIFBYWSA9IHBoYXNlU2hpZnQzRChwb2ludCwgRlhZKTtcXG5cXFxuICAgICAgICBDaSAqPSAwLjcwNztcXG5cXFxuICAgICAgICBGWFkgKj0gMi4wO1xcblxcXG4gICAgICAgIHZlYzIgc2luVGVybSA9IHNpbihGWFkgKiBwb2ludC54eSArIFBYWSk7XFxuXFxcbiAgICAgICAgc3VtICs9IENpICogc2luVGVybSArIHZlYzIoVDApO1xcblxcXG4gICAgfVxcblxcXG4gICAgcmV0dXJuIGsgKiBzdW0ueCAqIHN1bS55O1xcblxcXG59XFxuXFxcblxcblxcXG5jb25zdCBmbG9hdCBhID0gMC41OyAgLy8gZnJhY3Rpb24gb2Ygc3VyZmFjZSByZWZsZWN0aW9uIGR1ZSB0byBhbWJpZW50IG9yIHNjYXR0ZXJlZCBsaWdodCwgXFxuXFxcbmNvbnN0IGZsb2F0IHQgPSAwLjQ7ICAvLyBmcmFjdGlvbiBvZiB0ZXh0dXJlIHNoYWRpbmcgXFxuXFxcbmNvbnN0IGZsb2F0IHMgPSAwLjI1OyAvLyBmcmFjdGlvbiBvZiBzcGVjdWxhciByZWZsZWN0aW9uXFxuXFxcblxcblxcXG5mbG9hdCBJKGZsb2F0IElkLCBmbG9hdCBJcywgZmxvYXQgSXQpIHtcXG5cXFxuICAgIHJldHVybiAoMS4wIC0gYSkgKiAoKDEuMCAtIHQpICogKCgxLjAgLSBzKSAqIElkICsgcyAqIElzKSArIHQgKiBJdCkgKyBhO1xcblxcXG59XFxuXFxcblxcblxcXG5jb25zdCB2ZWMzIGxpZ2h0RGlyID0gbm9ybWFsaXplKHZlYzMoMC4yLCAtMS4wLCAwLjcpKTtcXG5cXFxuXFxuXFxcbnZlYzQgZHJhd0Nsb3VkKHZlYzMgcmF5T3JpZ2luLCB2ZWMzIHJheURpciwgdmVjMyBjbG91ZENlbnRlciwgdmVjMyBjbG91ZFNjYWxlLCBmbG9hdCBjbG91ZFNsaWNlLFxcblxcXG4gICAgICAgICAgICAgICBmbG9hdCBicmlnaHRuZXNzKSB7XFxuXFxcbiAgICB2ZWMzIGNsb3VkUG9pbnQsIGNsb3VkTm9ybWFsO1xcblxcXG4gICAgaWYoIWludGVyc2VjdEVsbGlwc29pZChyYXlPcmlnaW4sIHJheURpciwgY2xvdWRDZW50ZXIsIGNsb3VkU2NhbGUsIGNsb3VkU2xpY2UsXFxuXFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbG91ZFBvaW50LCBjbG91ZE5vcm1hbCkpIHtcXG5cXFxuICAgICAgICByZXR1cm4gdmVjNCgwLjApO1xcblxcXG4gICAgfVxcblxcXG5cXG5cXFxuICAgIGZsb2F0IElkID0gY2xhbXAoZG90KGNsb3VkTm9ybWFsLCAtbGlnaHREaXIpLCAwLjAsIDEuMCk7ICAvLyBkaWZmdXNlIHJlZmxlY3Rpb25cXG5cXFxuICAgIGZsb2F0IElzID0gbWF4KHBvdyhkb3QoLWxpZ2h0RGlyLCAtcmF5RGlyKSwgMi4wKSwgMC4wKTsgICAvLyBzcGVjdWxhciByZWZsZWN0aW9uXFxuXFxcbiAgICBmbG9hdCBJdCA9IFQoY2xvdWRQb2ludCk7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gdGV4dHVyZSBmdW5jdGlvblxcblxcXG4gICAgZmxvYXQgaW50ZW5zaXR5ID0gSShJZCwgSXMsIEl0KTtcXG5cXFxuICAgIHZlYzMgY29sb3IgPSBpbnRlbnNpdHkgKiBjbGFtcChicmlnaHRuZXNzLCAwLjEsIDEuMCkgKiB2ZWMzKDEuMCk7XFxuXFxcblxcblxcXG4gICAgdmVjNCBub2lzZSA9IHNhbXBsZU5vaXNlVGV4dHVyZSh1X25vaXNlRGV0YWlsICogY2xvdWRQb2ludCk7XFxuXFxcbiAgICBmbG9hdCBXID0gbm9pc2UueDtcXG5cXFxuICAgIGZsb2F0IFcyID0gbm9pc2UueTtcXG5cXFxuICAgIGZsb2F0IFczID0gbm9pc2UuejtcXG5cXFxuXFxuXFxcbiAgICAvLyBUaGUgZG90IHByb2R1Y3QgYmV0d2VlbiB0aGUgY2xvdWQncyBub3JtYWwgYW5kIHRoZSByYXkncyBkaXJlY3Rpb24gaXMgZ3JlYXRlc3RcXG5cXFxuICAgIC8vIGluIHRoZSBjZW50ZXIgb2YgdGhlIGVsbGlwc29pZCdzIHN1cmZhY2UuIEl0IGRlY3JlYXNlcyB0b3dhcmRzIHRoZSBlZGdlLlxcblxcXG4gICAgLy8gVGh1cywgaXQgaXMgdXNlZCB0byBibHVyIHRoZSBhcmVhcyBsZWFkaW5nIHRvIHRoZSBlZGdlcyBvZiB0aGUgZWxsaXBzb2lkLFxcblxcXG4gICAgLy8gc28gdGhhdCBubyBoYXJzaCBsaW5lcyBhcHBlYXIuXFxuXFxcbiAgICBcXG5cXFxuICAgIC8vIFRoZSBmaXJzdCAoYW5kIGJpZ2dlc3QpIGxheWVyIG9mIHdvcmxleSBub2lzZSBpcyB0aGVuIHN1YnRyYWN0ZWQgZnJvbSB0aGlzLlxcblxcXG4gICAgLy8gVGhlIGZpbmFsIHJlc3VsdCBpcyBzY2FsZWQgdXAgc28gdGhhdCB0aGUgYmFzZSBjbG91ZCBpcyBub3QgdG9vIHRyYW5zbHVjZW50LlxcblxcXG4gICAgZmxvYXQgbmREb3QgPSBjbGFtcChkb3QoY2xvdWROb3JtYWwsIC1yYXlEaXIpLCAwLjAsIDEuMCk7XFxuXFxcbiAgICBmbG9hdCBUUiA9IHBvdyhuZERvdCwgMy4wKSAtIFc7IC8vIHRyYW5zbHVjZW5jeVxcblxcXG4gICAgVFIgKj0gMS4zO1xcblxcXG4gICAgXFxuXFxcbiAgICAvLyBTdWJ0cmFjdGluZyB0aGUgc2Vjb25kIGFuZCB0aGlyZCBsYXllcnMgb2Ygd29ybGV5IG5vaXNlIGlzIG1vcmUgY29tcGxpY2F0ZWQuXFxuXFxcbiAgICAvLyBJZiB0aGVzZSBsYXllcnMgb2Ygbm9pc2Ugd2VyZSBzaW1wbHkgc3VidHJhY3RlZCBmcm9tIHRoZSBjdXJyZW50IHRyYW5zbHVjZW5jeSxcXG5cXFxuICAgIC8vIHRoZSBzaGFwZSBkZXJpdmVkIGZyb20gdGhlIGZpcnN0IGxheWVyIG9mIG5vaXNlIHdvdWxkIGJlIGNvbXBsZXRlbHkgZGVsZXRlZC5cXG5cXFxuICAgIC8vIFRoZSBlcm9zaW9uIG9mIHRoaXMgbm9pc2Ugc2hvdWxkIHRodXMgYmUgY29uc3RyaWN0ZWQgdG8gdGhlIGVkZ2VzIG9mIHRoZSBjbG91ZC5cXG5cXFxuICAgIC8vIEhvd2V2ZXIsIGJlY2F1c2UgdGhlIGVkZ2VzIG9mIHRoZSBlbGxpcHNvaWQgd2VyZSBhbHJlYWR5IGJsdXJyZWQgYXdheSwgbWFwcGluZ1xcblxcXG4gICAgLy8gdGhlIG5vaXNlIHRvICgxLjAgLSBuZERvdCkgd2lsbCBoYXZlIG5vIGltcGFjdCBvbiBtb3N0IG9mIHRoZSBjbG91ZCdzIGFwcGVhcmFuY2UuXFxuXFxcbiAgICAvLyBUaGUgdmFsdWUgb2YgKDAuNSAtIG5kRG90KSBwcm92aWRlcyB0aGUgYmVzdCBjb21wcm9taXNlLlxcblxcXG4gICAgZmxvYXQgbWludXNEb3QgPSAwLjUgLSBuZERvdDtcXG5cXFxuXFxuXFxcbiAgICAvLyBFdmVuIHdpdGggdGhlIHByZXZpb3VzIGNhbGN1bGF0aW9uLCBzdWJ0cmFjdGluZyB0aGUgc2Vjb25kIGxheWVyIG9mIHdub2lzZVxcblxcXG4gICAgLy8gZXJvZGUgdG9vIG11Y2ggb2YgdGhlIGNsb3VkLiBUaGUgYWRkaXRpb24gb2YgaXQsIGhvd2V2ZXIsIHdpbGwgZGV0YWlsZWRcXG5cXFxuICAgIC8vIHZvbHVtZSB0byB0aGUgY2xvdWQuIEFzIGxvbmcgYXMgdGhlIG5vaXNlIGlzIG9ubHkgYWRkZWQgYW5kIG5vdCBzdWJ0cmFjdGVkLFxcblxcXG4gICAgLy8gdGhlIHJlc3VsdHMgYXJlIGFlc3RoZXRpY2FsbHkgcGxlYXNpbmcuXFxuXFxcbiAgICBcXG5cXFxuICAgIC8vIFRoZSBtaW51c0RvdCBwcm9kdWN0IGlzIG1hcHBlZCBpbiBhIHdheSB0aGF0IGl0IGlzIGxhcmdlciBhdCB0aGUgZWRnZXMgb2ZcXG5cXFxuICAgIC8vIHRoZSBlbGxpcHNvaWQsIHNvIGEgc3VidHJhY3Rpb24gYW5kIG1pbiBvcGVyYXRpb24gYXJlIHVzZWQgaW5zdGVhZCBvZlxcblxcXG4gICAgLy8gYW4gYWRkaXRpb24gYW5kIG1heCBvbmUuXFxuXFxcbiAgICBUUiAtPSBtaW4obWludXNEb3QgKiBXMiwgMC4wKTtcXG5cXFxuXFxuXFxcbiAgICAvLyBUaGUgdGhpcmQgbGV2ZWwgb2Ygd29ybGV5IG5vaXNlIGlzIHN1YnRyYWN0ZWQgZnJvbSB0aGUgcmVzdWx0LCB3aXRoIHNvbWVcXG5cXFxuICAgIC8vIG1vZGlmaWNhdGlvbnMuIEZpcnN0LCBhIHNjYWxhciBpcyBhZGRlZCB0byBtaW51c0RvdCBzbyB0aGF0IHRoZSBub2lzZVxcblxcXG4gICAgLy8gc3RhcnRzIGFmZmVjdGluZyB0aGUgc2hhcGUgZmFydGhlciBhd2F5IGZyb20gdGhlIGNlbnRlciBvZiB0aGUgZWxsaXBzb2lkJ3NcXG5cXFxuICAgIC8vIHN1cmZhY2UuIFRoZW4sIGl0IGlzIHNjYWxlZCBkb3duIHNvIGl0cyBpbXBhY3QgaXMgbm90IHRvbyBpbnRlbnNlLlxcblxcXG4gICAgVFIgLT0gMC44ICogKG1pbnVzRG90ICsgMC4yNSkgKiBXMztcXG5cXFxuXFxuXFxcbiAgICAvLyBUaGUgdGV4dHVyZSBmdW5jdGlvbidzIHNoYWRpbmcgZG9lcyBub3QgY29ycmVsYXRlIHdpdGggdGhlIHNoYXBlIG9mIHRoZSBjbG91ZFxcblxcXG4gICAgLy8gcHJvZHVjZWQgYnkgdGhlIGxheWVycyBvZiBub2lzZSwgc28gYW4gZXh0cmEgc2hhZGluZyBzY2FsYXIgaXMgY2FsY3VsYXRlZC5cXG5cXFxuICAgIC8vIFRoZSBkYXJrZXN0IGFyZWFzIG9mIHRoZSBjbG91ZCBhcmUgYXNzaWduZWQgdG8gYmUgd2hlcmUgdGhlIG5vaXNlIGVyb2Rlc1xcblxcXG4gICAgLy8gdGhlIGNsb3VkIHRoZSBtb3N0LiBUaGlzIGlzIHRoZW4gaW50ZXJwb2xhdGVkIGJhc2VkIG9uIHRoZSB0cmFuc2x1Y2VuY3lcXG5cXFxuICAgIC8vIGFuZCB0aGUgZGlmZnVzZSBzaGFkaW5nIHRlcm0gb2YgdGhhdCBwb2ludCBpbiB0aGUgY2xvdWQuXFxuXFxcbiAgICBmbG9hdCBzaGFkaW5nID0gbWl4KDEuMCAtIDAuOCAqIFcgKiBXLCAxLjAsIElkICogVFIpO1xcblxcXG5cXG5cXFxuICAgIC8vIFRvIGF2b2lkIHZhbHVlcyB0aGF0IGFyZSB0b28gZGFyaywgdGhpcyBzY2FsYXIgaXMgaW5jcmVhc2VkIGJ5IGEgc21hbGwgYW1vdW50XFxuXFxcbiAgICAvLyBhbmQgY2xhbXBlZCBzbyBpdCBuZXZlciBnb2VzIHRvIHplcm8uXFxuXFxcbiAgICBzaGFkaW5nID0gY2xhbXAoc2hhZGluZyArIDAuMiwgMC4zLCAxLjApO1xcblxcXG5cXG5cXFxuICAgIC8vIEZpbmFsbHksIHRoZSBjb250cmFzdCBvZiB0aGUgY2xvdWQncyBjb2xvciBpcyBpbmNyZWFzZWQuXFxuXFxcbiAgICB2ZWMzIGZpbmFsQ29sb3IgPSBtaXgodmVjMygwLjUpLCBzaGFkaW5nICogY29sb3IsIDEuMTUpO1xcblxcXG4gICAgcmV0dXJuIHZlYzQoZmluYWxDb2xvciwgY2xhbXAoVFIsIDAuMCwgMS4wKSk7XFxuXFxcbn1cXG5cXFxuXFxuXFxcbnZvaWQgbWFpbigpIHtcXG5cXFxuI2lmZGVmIERFQlVHX0JJTExCT0FSRFNcXG5cXFxuICAgIGdsX0ZyYWdDb2xvciA9IHZlYzQoMC4wLCAwLjUsIDAuNSwgMS4wKTtcXG5cXFxuI2VuZGlmXFxuXFxcbiAgICBcXG5cXFxuICAgIC8vIFRvIGF2b2lkIGNhbGN1bGF0aW9ucyB3aXRoIGhpZ2ggdmFsdWVzLFxcblxcXG4gICAgLy8gd2UgcmF5Y2FzdCBmcm9tIGFuIGFyYml0cmFyaWx5IHNtYWxsZXIgc3BhY2UuXFxuXFxcbiAgICB2ZWMyIGNvb3JkaW5hdGUgPSB2X21heGltdW1TaXplLnh5ICogdl9vZmZzZXQ7XFxuXFxcblxcblxcXG4gICAgdmVjMyBlbGxpcHNvaWRTY2FsZSA9IDAuODIgKiB2X21heGltdW1TaXplO1xcblxcXG4gICAgdmVjMyBlbGxpcHNvaWRDZW50ZXIgPSB2ZWMzKDAuMCk7XFxuXFxcblxcblxcXG4gICAgZmxvYXQgek9mZnNldCA9IG1heChlbGxpcHNvaWRTY2FsZS56IC0gMTAuMCwgMC4wKTtcXG5cXFxuICAgIHZlYzMgZXllID0gdmVjMygwLCAwLCAtMTAuMCAtIHpPZmZzZXQpO1xcblxcXG4gICAgdmVjMyByYXlEaXIgPSBub3JtYWxpemUodmVjMyhjb29yZGluYXRlLCAxLjApIC0gZXllKTtcXG5cXFxuICAgIHZlYzMgcmF5T3JpZ2luID0gZXllO1xcblxcXG5cXG5cXFxuI2lmZGVmIERFQlVHX0VMTElQU09JRFNcXG5cXFxuICAgIHZlYzMgcG9pbnQsIG5vcm1hbDtcXG5cXFxuICAgIGlmKGludGVyc2VjdEVsbGlwc29pZChyYXlPcmlnaW4sIHJheURpciwgZWxsaXBzb2lkQ2VudGVyLCBlbGxpcHNvaWRTY2FsZSwgdl9zbGljZSxcXG5cXFxuICAgICAgICAgICAgICAgICAgICAgICAgICBwb2ludCwgbm9ybWFsKSkge1xcblxcXG4gICAgICAgIGdsX0ZyYWdDb2xvciA9IHZfYnJpZ2h0bmVzcyAqIHZlYzQoMS4wKTtcXG5cXFxuICAgIH1cXG5cXFxuI2Vsc2VcXG5cXFxuI2lmbmRlZiBERUJVR19CSUxMQk9BUkRTXFxuXFxcbiAgICB2ZWM0IGNsb3VkID0gZHJhd0Nsb3VkKHJheU9yaWdpbiwgcmF5RGlyLFxcblxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICBlbGxpcHNvaWRDZW50ZXIsIGVsbGlwc29pZFNjYWxlLCB2X3NsaWNlLCB2X2JyaWdodG5lc3MpOyAgICBcXG5cXFxuICAgIGlmKGNsb3VkLncgPCAwLjAxKSB7XFxuXFxcbiAgICAgICAgZGlzY2FyZDtcXG5cXFxuICAgIH1cXG5cXFxuICAgIGdsX0ZyYWdDb2xvciA9IGNsb3VkO1xcblxcXG4jZW5kaWZcXG5cXFxuI2VuZGlmXFxuXFxcbn1cXG5cXFxuXCI7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///50442\n")},16999:function(__unused_webpack___webpack_module__,__webpack_exports__){eval('//This file is automatically rebuilt by the Cesium build process.\n/* harmony default export */ __webpack_exports__["Z"] = ("#ifdef INSTANCED\\n\\\nattribute vec2 direction;\\n\\\n#endif\\n\\\nattribute vec4 positionHighAndScaleX;\\n\\\nattribute vec4 positionLowAndScaleY;\\n\\\nattribute vec4 packedAttribute0;\\n\\\nattribute vec4 packedAttribute1;\\n\\\n\\n\\\nvarying vec2 v_offset;\\n\\\nvarying vec3 v_maximumSize;\\n\\\nvarying float v_slice;\\n\\\nvarying float v_brightness;\\n\\\n\\n\\\nvoid main() {\\n\\\n    // Unpack attributes.\\n\\\n    vec3 positionHigh = positionHighAndScaleX.xyz;\\n\\\n    vec3 positionLow = positionLowAndScaleY.xyz;\\n\\\n    vec2 scale = vec2(positionHighAndScaleX.w, positionLowAndScaleY.w);\\n\\\n\\n\\\n    float show = packedAttribute0.x;\\n\\\n    float brightness = packedAttribute0.y;\\n\\\n    vec2 coordinates = packedAttribute0.wz;\\n\\\n    vec3 maximumSize = packedAttribute1.xyz;\\n\\\n    float slice = packedAttribute1.w;\\n\\\n\\n\\\n#ifdef INSTANCED\\n\\\n    vec2 dir = direction;\\n\\\n#else\\n\\\n    vec2 dir = coordinates;\\n\\\n#endif\\n\\\n\\n\\\n    vec2 offset = dir - vec2(0.5, 0.5);\\n\\\n    vec2 scaledOffset = scale * offset;\\n\\\n    vec4 p = czm_translateRelativeToEye(positionHigh, positionLow);\\n\\\n    vec4 positionEC = czm_modelViewRelativeToEye * p;\\n\\\n    positionEC.xy += scaledOffset;\\n\\\n    \\n\\\n    positionEC.xyz *= show;\\n\\\n    gl_Position = czm_projection * positionEC;\\n\\\n\\n\\\n    v_offset = offset;\\n\\\n    v_maximumSize = maximumSize;\\n\\\n    v_slice = slice;\\n\\\n    v_brightness = brightness;\\n\\\n}\\n\\\n");\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTY5OTkuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQSx5REFBZTtBQUNmLHlCQUF5QjtBQUN6QjtBQUNBLHFDQUFxQztBQUNyQyxvQ0FBb0M7QUFDcEMsZ0NBQWdDO0FBQ2hDLGdDQUFnQztBQUNoQztBQUNBLHNCQUFzQjtBQUN0QiwyQkFBMkI7QUFDM0Isc0JBQXNCO0FBQ3RCLDJCQUEyQjtBQUMzQjtBQUNBLGFBQWE7QUFDYjtBQUNBLGtEQUFrRDtBQUNsRCxnREFBZ0Q7QUFDaEQsdUVBQXVFO0FBQ3ZFO0FBQ0Esb0NBQW9DO0FBQ3BDLDBDQUEwQztBQUMxQywyQ0FBMkM7QUFDM0MsNENBQTRDO0FBQzVDLHFDQUFxQztBQUNyQztBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQSx1Q0FBdUM7QUFDdkMsdUNBQXVDO0FBQ3ZDLG1FQUFtRTtBQUNuRSxxREFBcUQ7QUFDckQsa0NBQWtDO0FBQ2xDO0FBQ0EsMkJBQTJCO0FBQzNCLDhDQUE4QztBQUM5QztBQUNBLHNCQUFzQjtBQUN0QixnQ0FBZ0M7QUFDaEMsb0JBQW9CO0FBQ3BCLDhCQUE4QjtBQUM5QixDQUFDO0FBQ0QsQ0FBQyxFQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdnVlMy13ZWJwYWNrNS8uL25vZGVfbW9kdWxlcy9jZXNpdW0vU291cmNlL1NoYWRlcnMvQ2xvdWRDb2xsZWN0aW9uVlMuanM/ZWE0YyJdLCJzb3VyY2VzQ29udGVudCI6WyIvL1RoaXMgZmlsZSBpcyBhdXRvbWF0aWNhbGx5IHJlYnVpbHQgYnkgdGhlIENlc2l1bSBidWlsZCBwcm9jZXNzLlxuZXhwb3J0IGRlZmF1bHQgXCIjaWZkZWYgSU5TVEFOQ0VEXFxuXFxcbmF0dHJpYnV0ZSB2ZWMyIGRpcmVjdGlvbjtcXG5cXFxuI2VuZGlmXFxuXFxcbmF0dHJpYnV0ZSB2ZWM0IHBvc2l0aW9uSGlnaEFuZFNjYWxlWDtcXG5cXFxuYXR0cmlidXRlIHZlYzQgcG9zaXRpb25Mb3dBbmRTY2FsZVk7XFxuXFxcbmF0dHJpYnV0ZSB2ZWM0IHBhY2tlZEF0dHJpYnV0ZTA7XFxuXFxcbmF0dHJpYnV0ZSB2ZWM0IHBhY2tlZEF0dHJpYnV0ZTE7XFxuXFxcblxcblxcXG52YXJ5aW5nIHZlYzIgdl9vZmZzZXQ7XFxuXFxcbnZhcnlpbmcgdmVjMyB2X21heGltdW1TaXplO1xcblxcXG52YXJ5aW5nIGZsb2F0IHZfc2xpY2U7XFxuXFxcbnZhcnlpbmcgZmxvYXQgdl9icmlnaHRuZXNzO1xcblxcXG5cXG5cXFxudm9pZCBtYWluKCkge1xcblxcXG4gICAgLy8gVW5wYWNrIGF0dHJpYnV0ZXMuXFxuXFxcbiAgICB2ZWMzIHBvc2l0aW9uSGlnaCA9IHBvc2l0aW9uSGlnaEFuZFNjYWxlWC54eXo7XFxuXFxcbiAgICB2ZWMzIHBvc2l0aW9uTG93ID0gcG9zaXRpb25Mb3dBbmRTY2FsZVkueHl6O1xcblxcXG4gICAgdmVjMiBzY2FsZSA9IHZlYzIocG9zaXRpb25IaWdoQW5kU2NhbGVYLncsIHBvc2l0aW9uTG93QW5kU2NhbGVZLncpO1xcblxcXG5cXG5cXFxuICAgIGZsb2F0IHNob3cgPSBwYWNrZWRBdHRyaWJ1dGUwLng7XFxuXFxcbiAgICBmbG9hdCBicmlnaHRuZXNzID0gcGFja2VkQXR0cmlidXRlMC55O1xcblxcXG4gICAgdmVjMiBjb29yZGluYXRlcyA9IHBhY2tlZEF0dHJpYnV0ZTAud3o7XFxuXFxcbiAgICB2ZWMzIG1heGltdW1TaXplID0gcGFja2VkQXR0cmlidXRlMS54eXo7XFxuXFxcbiAgICBmbG9hdCBzbGljZSA9IHBhY2tlZEF0dHJpYnV0ZTEudztcXG5cXFxuXFxuXFxcbiNpZmRlZiBJTlNUQU5DRURcXG5cXFxuICAgIHZlYzIgZGlyID0gZGlyZWN0aW9uO1xcblxcXG4jZWxzZVxcblxcXG4gICAgdmVjMiBkaXIgPSBjb29yZGluYXRlcztcXG5cXFxuI2VuZGlmXFxuXFxcblxcblxcXG4gICAgdmVjMiBvZmZzZXQgPSBkaXIgLSB2ZWMyKDAuNSwgMC41KTtcXG5cXFxuICAgIHZlYzIgc2NhbGVkT2Zmc2V0ID0gc2NhbGUgKiBvZmZzZXQ7XFxuXFxcbiAgICB2ZWM0IHAgPSBjem1fdHJhbnNsYXRlUmVsYXRpdmVUb0V5ZShwb3NpdGlvbkhpZ2gsIHBvc2l0aW9uTG93KTtcXG5cXFxuICAgIHZlYzQgcG9zaXRpb25FQyA9IGN6bV9tb2RlbFZpZXdSZWxhdGl2ZVRvRXllICogcDtcXG5cXFxuICAgIHBvc2l0aW9uRUMueHkgKz0gc2NhbGVkT2Zmc2V0O1xcblxcXG4gICAgXFxuXFxcbiAgICBwb3NpdGlvbkVDLnh5eiAqPSBzaG93O1xcblxcXG4gICAgZ2xfUG9zaXRpb24gPSBjem1fcHJvamVjdGlvbiAqIHBvc2l0aW9uRUM7XFxuXFxcblxcblxcXG4gICAgdl9vZmZzZXQgPSBvZmZzZXQ7XFxuXFxcbiAgICB2X21heGltdW1TaXplID0gbWF4aW11bVNpemU7XFxuXFxcbiAgICB2X3NsaWNlID0gc2xpY2U7XFxuXFxcbiAgICB2X2JyaWdodG5lc3MgPSBicmlnaHRuZXNzO1xcblxcXG59XFxuXFxcblwiO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///16999\n')},12444:function(__unused_webpack___webpack_module__,__webpack_exports__){eval('//This file is automatically rebuilt by the Cesium build process.\n/* harmony default export */ __webpack_exports__["Z"] = ("uniform float u_noiseTextureLength;\\n\\\nuniform float u_noiseDetail;\\n\\\nuniform vec3 u_noiseOffset;\\n\\\nvarying vec2 v_position;\\n\\\n\\n\\\nfloat wrap(float value, float rangeLength) {\\n\\\n    if(value < 0.0) {\\n\\\n        float absValue = abs(value);\\n\\\n        float modValue = mod(absValue, rangeLength);\\n\\\n        return mod(rangeLength - modValue, rangeLength);\\n\\\n    }\\n\\\n    return mod(value, rangeLength);\\n\\\n}\\n\\\n\\n\\\nvec3 wrapVec(vec3 value, float rangeLength) {\\n\\\n    return vec3(wrap(value.x, rangeLength),\\n\\\n                wrap(value.y, rangeLength),\\n\\\n                wrap(value.z, rangeLength));\\n\\\n}\\n\\\n\\n\\\nvec3 random3(vec3 p) {\\n\\\n    float dot1 = dot(p, vec3(127.1, 311.7, 932.8));\\n\\\n    float dot2 = dot(p, vec3(269.5, 183.3, 421.4));\\n\\\n    return fract(vec3(sin(dot1 - dot2), cos(dot1 * dot2), dot1 * dot2));\\n\\\n}\\n\\\n\\n\\\n// Frequency corresponds to cell size.\\n\\\n// The higher the frequency, the smaller the cell size.\\n\\\nvec3 getWorleyCellPoint(vec3 centerCell, vec3 offset, float freq) {\\n\\\n    vec3 cell = centerCell + offset;\\n\\\n    cell = wrapVec(cell, u_noiseTextureLength / u_noiseDetail);\\n\\\n    cell += floor(u_noiseOffset / u_noiseDetail);\\n\\\n    vec3 p = offset + random3(cell);\\n\\\n    return p;\\n\\\n}\\n\\\n\\n\\\nfloat worleyNoise(vec3 p, float freq) {\\n\\\n    vec3 centerCell = floor(p * freq);\\n\\\n    vec3 pointInCell = fract(p * freq);\\n\\\n    float shortestDistance = 1000.0;\\n\\\n\\n\\\n    for(float z = -1.0; z <= 1.0; z++) {\\n\\\n        for(float y = -1.0; y <= 1.0; y++) {\\n\\\n            for(float x = -1.0; x <= 1.0; x++) {\\n\\\n                vec3 offset = vec3(x, y, z);\\n\\\n                vec3 point = getWorleyCellPoint(centerCell, offset, freq);\\n\\\n\\n\\\n                float distance = length(pointInCell - point);\\n\\\n                if(distance < shortestDistance) {\\n\\\n                    shortestDistance = distance;\\n\\\n                }\\n\\\n            }\\n\\\n        }\\n\\\n    }\\n\\\n\\n\\\n    return shortestDistance;\\n\\\n}\\n\\\n\\n\\\nconst float MAX_FBM_ITERATIONS = 10.0;\\n\\\n\\n\\\nfloat worleyFBMNoise(vec3 p, float octaves, float scale) {\\n\\\n    float noise = 0.0;\\n\\\n    float freq = 1.0;\\n\\\n    float persistence = 0.625;\\n\\\n    for(float i = 0.0; i < MAX_FBM_ITERATIONS; i++) {\\n\\\n        if(i >= octaves) {\\n\\\n            break;\\n\\\n        }\\n\\\n        \\n\\\n        noise += worleyNoise(p * scale, freq * scale) * persistence;\\n\\\n        persistence *= 0.5;\\n\\\n        freq *= 2.0;\\n\\\n    }\\n\\\n    return noise;\\n\\\n}\\n\\\n\\n\\\nvoid main() {   \\n\\\n    float z = floor(v_position.x / u_noiseTextureLength);\\n\\\n    float x = v_position.x - z * u_noiseTextureLength;\\n\\\n    vec3 position = vec3(x, v_position.y, z);\\n\\\n    position /= u_noiseDetail;\\n\\\n    float worley0 = clamp(worleyFBMNoise(position, 3.0, 1.0), 0.0, 1.0);\\n\\\n    float worley1 = clamp(worleyFBMNoise(position, 3.0, 2.0), 0.0, 1.0);\\n\\\n    float worley2 = clamp(worleyFBMNoise(position, 3.0, 3.0), 0.0, 1.0);\\n\\\n    gl_FragColor = vec4(worley0, worley1, worley2, 1.0);\\n\\\n}\\n\\\n");\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTI0NDQuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQSx5REFBZSxvQ0FBb0M7QUFDbkQsNEJBQTRCO0FBQzVCLDJCQUEyQjtBQUMzQix3QkFBd0I7QUFDeEI7QUFDQSw0Q0FBNEM7QUFDNUMscUJBQXFCO0FBQ3JCLG9DQUFvQztBQUNwQyxvREFBb0Q7QUFDcEQsd0RBQXdEO0FBQ3hELEtBQUs7QUFDTCxtQ0FBbUM7QUFDbkMsQ0FBQztBQUNEO0FBQ0EsNkNBQTZDO0FBQzdDO0FBQ0E7QUFDQSw0Q0FBNEM7QUFDNUMsQ0FBQztBQUNEO0FBQ0Esc0JBQXNCO0FBQ3RCLG1EQUFtRDtBQUNuRCxtREFBbUQ7QUFDbkQsd0VBQXdFO0FBQ3hFLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSxtRUFBbUU7QUFDbkUsb0NBQW9DO0FBQ3BDLCtEQUErRDtBQUMvRCxpREFBaUQ7QUFDakQsb0NBQW9DO0FBQ3BDLGFBQWE7QUFDYixDQUFDO0FBQ0Q7QUFDQSx1Q0FBdUM7QUFDdkMsc0NBQXNDO0FBQ3RDLHVDQUF1QztBQUN2QyxvQ0FBb0M7QUFDcEM7QUFDQSx3QkFBd0IsVUFBVSxNQUFNO0FBQ3hDLDRCQUE0QixVQUFVLE1BQU07QUFDNUMsZ0NBQWdDLFVBQVUsTUFBTTtBQUNoRCw0Q0FBNEM7QUFDNUMsMEVBQTBFO0FBQzFFO0FBQ0EsNkRBQTZEO0FBQzdELGlEQUFpRDtBQUNqRCxnREFBZ0Q7QUFDaEQsaUJBQWlCO0FBQ2pCLGFBQWE7QUFDYixTQUFTO0FBQ1QsS0FBSztBQUNMO0FBQ0EsNEJBQTRCO0FBQzVCLENBQUM7QUFDRDtBQUNBLHNDQUFzQztBQUN0QztBQUNBLDBEQUEwRDtBQUMxRCxzQkFBc0I7QUFDdEIscUJBQXFCO0FBQ3JCLDhCQUE4QjtBQUM5Qix1QkFBdUIsd0JBQXdCLE1BQU07QUFDckQsMEJBQTBCO0FBQzFCLGtCQUFrQjtBQUNsQixTQUFTO0FBQ1Q7QUFDQSxvRUFBb0U7QUFDcEUsMkJBQTJCO0FBQzNCLG9CQUFvQjtBQUNwQixLQUFLO0FBQ0wsaUJBQWlCO0FBQ2pCLENBQUM7QUFDRDtBQUNBLGdCQUFnQjtBQUNoQix5REFBeUQ7QUFDekQsc0RBQXNEO0FBQ3RELDZDQUE2QztBQUM3Qyw4QkFBOEI7QUFDOUIsd0VBQXdFO0FBQ3hFLHdFQUF3RTtBQUN4RSx3RUFBd0U7QUFDeEUsd0RBQXdEO0FBQ3hELENBQUM7QUFDRCxDQUFDLEVBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly92dWUzLXdlYnBhY2s1Ly4vbm9kZV9tb2R1bGVzL2Nlc2l1bS9Tb3VyY2UvU2hhZGVycy9DbG91ZE5vaXNlRlMuanM/Mzk5NiJdLCJzb3VyY2VzQ29udGVudCI6WyIvL1RoaXMgZmlsZSBpcyBhdXRvbWF0aWNhbGx5IHJlYnVpbHQgYnkgdGhlIENlc2l1bSBidWlsZCBwcm9jZXNzLlxuZXhwb3J0IGRlZmF1bHQgXCJ1bmlmb3JtIGZsb2F0IHVfbm9pc2VUZXh0dXJlTGVuZ3RoO1xcblxcXG51bmlmb3JtIGZsb2F0IHVfbm9pc2VEZXRhaWw7XFxuXFxcbnVuaWZvcm0gdmVjMyB1X25vaXNlT2Zmc2V0O1xcblxcXG52YXJ5aW5nIHZlYzIgdl9wb3NpdGlvbjtcXG5cXFxuXFxuXFxcbmZsb2F0IHdyYXAoZmxvYXQgdmFsdWUsIGZsb2F0IHJhbmdlTGVuZ3RoKSB7XFxuXFxcbiAgICBpZih2YWx1ZSA8IDAuMCkge1xcblxcXG4gICAgICAgIGZsb2F0IGFic1ZhbHVlID0gYWJzKHZhbHVlKTtcXG5cXFxuICAgICAgICBmbG9hdCBtb2RWYWx1ZSA9IG1vZChhYnNWYWx1ZSwgcmFuZ2VMZW5ndGgpO1xcblxcXG4gICAgICAgIHJldHVybiBtb2QocmFuZ2VMZW5ndGggLSBtb2RWYWx1ZSwgcmFuZ2VMZW5ndGgpO1xcblxcXG4gICAgfVxcblxcXG4gICAgcmV0dXJuIG1vZCh2YWx1ZSwgcmFuZ2VMZW5ndGgpO1xcblxcXG59XFxuXFxcblxcblxcXG52ZWMzIHdyYXBWZWModmVjMyB2YWx1ZSwgZmxvYXQgcmFuZ2VMZW5ndGgpIHtcXG5cXFxuICAgIHJldHVybiB2ZWMzKHdyYXAodmFsdWUueCwgcmFuZ2VMZW5ndGgpLFxcblxcXG4gICAgICAgICAgICAgICAgd3JhcCh2YWx1ZS55LCByYW5nZUxlbmd0aCksXFxuXFxcbiAgICAgICAgICAgICAgICB3cmFwKHZhbHVlLnosIHJhbmdlTGVuZ3RoKSk7XFxuXFxcbn1cXG5cXFxuXFxuXFxcbnZlYzMgcmFuZG9tMyh2ZWMzIHApIHtcXG5cXFxuICAgIGZsb2F0IGRvdDEgPSBkb3QocCwgdmVjMygxMjcuMSwgMzExLjcsIDkzMi44KSk7XFxuXFxcbiAgICBmbG9hdCBkb3QyID0gZG90KHAsIHZlYzMoMjY5LjUsIDE4My4zLCA0MjEuNCkpO1xcblxcXG4gICAgcmV0dXJuIGZyYWN0KHZlYzMoc2luKGRvdDEgLSBkb3QyKSwgY29zKGRvdDEgKiBkb3QyKSwgZG90MSAqIGRvdDIpKTtcXG5cXFxufVxcblxcXG5cXG5cXFxuLy8gRnJlcXVlbmN5IGNvcnJlc3BvbmRzIHRvIGNlbGwgc2l6ZS5cXG5cXFxuLy8gVGhlIGhpZ2hlciB0aGUgZnJlcXVlbmN5LCB0aGUgc21hbGxlciB0aGUgY2VsbCBzaXplLlxcblxcXG52ZWMzIGdldFdvcmxleUNlbGxQb2ludCh2ZWMzIGNlbnRlckNlbGwsIHZlYzMgb2Zmc2V0LCBmbG9hdCBmcmVxKSB7XFxuXFxcbiAgICB2ZWMzIGNlbGwgPSBjZW50ZXJDZWxsICsgb2Zmc2V0O1xcblxcXG4gICAgY2VsbCA9IHdyYXBWZWMoY2VsbCwgdV9ub2lzZVRleHR1cmVMZW5ndGggLyB1X25vaXNlRGV0YWlsKTtcXG5cXFxuICAgIGNlbGwgKz0gZmxvb3IodV9ub2lzZU9mZnNldCAvIHVfbm9pc2VEZXRhaWwpO1xcblxcXG4gICAgdmVjMyBwID0gb2Zmc2V0ICsgcmFuZG9tMyhjZWxsKTtcXG5cXFxuICAgIHJldHVybiBwO1xcblxcXG59XFxuXFxcblxcblxcXG5mbG9hdCB3b3JsZXlOb2lzZSh2ZWMzIHAsIGZsb2F0IGZyZXEpIHtcXG5cXFxuICAgIHZlYzMgY2VudGVyQ2VsbCA9IGZsb29yKHAgKiBmcmVxKTtcXG5cXFxuICAgIHZlYzMgcG9pbnRJbkNlbGwgPSBmcmFjdChwICogZnJlcSk7XFxuXFxcbiAgICBmbG9hdCBzaG9ydGVzdERpc3RhbmNlID0gMTAwMC4wO1xcblxcXG5cXG5cXFxuICAgIGZvcihmbG9hdCB6ID0gLTEuMDsgeiA8PSAxLjA7IHorKykge1xcblxcXG4gICAgICAgIGZvcihmbG9hdCB5ID0gLTEuMDsgeSA8PSAxLjA7IHkrKykge1xcblxcXG4gICAgICAgICAgICBmb3IoZmxvYXQgeCA9IC0xLjA7IHggPD0gMS4wOyB4KyspIHtcXG5cXFxuICAgICAgICAgICAgICAgIHZlYzMgb2Zmc2V0ID0gdmVjMyh4LCB5LCB6KTtcXG5cXFxuICAgICAgICAgICAgICAgIHZlYzMgcG9pbnQgPSBnZXRXb3JsZXlDZWxsUG9pbnQoY2VudGVyQ2VsbCwgb2Zmc2V0LCBmcmVxKTtcXG5cXFxuXFxuXFxcbiAgICAgICAgICAgICAgICBmbG9hdCBkaXN0YW5jZSA9IGxlbmd0aChwb2ludEluQ2VsbCAtIHBvaW50KTtcXG5cXFxuICAgICAgICAgICAgICAgIGlmKGRpc3RhbmNlIDwgc2hvcnRlc3REaXN0YW5jZSkge1xcblxcXG4gICAgICAgICAgICAgICAgICAgIHNob3J0ZXN0RGlzdGFuY2UgPSBkaXN0YW5jZTtcXG5cXFxuICAgICAgICAgICAgICAgIH1cXG5cXFxuICAgICAgICAgICAgfVxcblxcXG4gICAgICAgIH1cXG5cXFxuICAgIH1cXG5cXFxuXFxuXFxcbiAgICByZXR1cm4gc2hvcnRlc3REaXN0YW5jZTtcXG5cXFxufVxcblxcXG5cXG5cXFxuY29uc3QgZmxvYXQgTUFYX0ZCTV9JVEVSQVRJT05TID0gMTAuMDtcXG5cXFxuXFxuXFxcbmZsb2F0IHdvcmxleUZCTU5vaXNlKHZlYzMgcCwgZmxvYXQgb2N0YXZlcywgZmxvYXQgc2NhbGUpIHtcXG5cXFxuICAgIGZsb2F0IG5vaXNlID0gMC4wO1xcblxcXG4gICAgZmxvYXQgZnJlcSA9IDEuMDtcXG5cXFxuICAgIGZsb2F0IHBlcnNpc3RlbmNlID0gMC42MjU7XFxuXFxcbiAgICBmb3IoZmxvYXQgaSA9IDAuMDsgaSA8IE1BWF9GQk1fSVRFUkFUSU9OUzsgaSsrKSB7XFxuXFxcbiAgICAgICAgaWYoaSA+PSBvY3RhdmVzKSB7XFxuXFxcbiAgICAgICAgICAgIGJyZWFrO1xcblxcXG4gICAgICAgIH1cXG5cXFxuICAgICAgICBcXG5cXFxuICAgICAgICBub2lzZSArPSB3b3JsZXlOb2lzZShwICogc2NhbGUsIGZyZXEgKiBzY2FsZSkgKiBwZXJzaXN0ZW5jZTtcXG5cXFxuICAgICAgICBwZXJzaXN0ZW5jZSAqPSAwLjU7XFxuXFxcbiAgICAgICAgZnJlcSAqPSAyLjA7XFxuXFxcbiAgICB9XFxuXFxcbiAgICByZXR1cm4gbm9pc2U7XFxuXFxcbn1cXG5cXFxuXFxuXFxcbnZvaWQgbWFpbigpIHsgICBcXG5cXFxuICAgIGZsb2F0IHogPSBmbG9vcih2X3Bvc2l0aW9uLnggLyB1X25vaXNlVGV4dHVyZUxlbmd0aCk7XFxuXFxcbiAgICBmbG9hdCB4ID0gdl9wb3NpdGlvbi54IC0geiAqIHVfbm9pc2VUZXh0dXJlTGVuZ3RoO1xcblxcXG4gICAgdmVjMyBwb3NpdGlvbiA9IHZlYzMoeCwgdl9wb3NpdGlvbi55LCB6KTtcXG5cXFxuICAgIHBvc2l0aW9uIC89IHVfbm9pc2VEZXRhaWw7XFxuXFxcbiAgICBmbG9hdCB3b3JsZXkwID0gY2xhbXAod29ybGV5RkJNTm9pc2UocG9zaXRpb24sIDMuMCwgMS4wKSwgMC4wLCAxLjApO1xcblxcXG4gICAgZmxvYXQgd29ybGV5MSA9IGNsYW1wKHdvcmxleUZCTU5vaXNlKHBvc2l0aW9uLCAzLjAsIDIuMCksIDAuMCwgMS4wKTtcXG5cXFxuICAgIGZsb2F0IHdvcmxleTIgPSBjbGFtcCh3b3JsZXlGQk1Ob2lzZShwb3NpdGlvbiwgMy4wLCAzLjApLCAwLjAsIDEuMCk7XFxuXFxcbiAgICBnbF9GcmFnQ29sb3IgPSB2ZWM0KHdvcmxleTAsIHdvcmxleTEsIHdvcmxleTIsIDEuMCk7XFxuXFxcbn1cXG5cXFxuXCI7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///12444\n')},61968:function(__unused_webpack___webpack_module__,__webpack_exports__){eval('//This file is automatically rebuilt by the Cesium build process.\n/* harmony default export */ __webpack_exports__["Z"] = ("uniform float u_noiseTextureLength;\\n\\\nattribute vec2 position;\\n\\\n\\n\\\nvarying vec2 v_position;\\n\\\n\\n\\\nvoid main()\\n\\\n{\\n\\\n    gl_Position = vec4(position, 0.1, 1.0);\\n\\\n\\n\\\n    vec2 transformedPos = (position / 2.0) + vec2(0.5);\\n\\\n    transformedPos *= u_noiseTextureLength;\\n\\\n    transformedPos.x *= u_noiseTextureLength;\\n\\\n    v_position = transformedPos;\\n\\\n}\\n\\\n");\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNjE5NjguanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQSx5REFBZSxvQ0FBb0M7QUFDbkQsd0JBQXdCO0FBQ3hCO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQSxDQUFDO0FBQ0QsMkNBQTJDO0FBQzNDO0FBQ0EsdURBQXVEO0FBQ3ZELDJDQUEyQztBQUMzQyw2Q0FBNkM7QUFDN0MsZ0NBQWdDO0FBQ2hDLENBQUM7QUFDRCxDQUFDLEVBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly92dWUzLXdlYnBhY2s1Ly4vbm9kZV9tb2R1bGVzL2Nlc2l1bS9Tb3VyY2UvU2hhZGVycy9DbG91ZE5vaXNlVlMuanM/YzM1YSJdLCJzb3VyY2VzQ29udGVudCI6WyIvL1RoaXMgZmlsZSBpcyBhdXRvbWF0aWNhbGx5IHJlYnVpbHQgYnkgdGhlIENlc2l1bSBidWlsZCBwcm9jZXNzLlxuZXhwb3J0IGRlZmF1bHQgXCJ1bmlmb3JtIGZsb2F0IHVfbm9pc2VUZXh0dXJlTGVuZ3RoO1xcblxcXG5hdHRyaWJ1dGUgdmVjMiBwb3NpdGlvbjtcXG5cXFxuXFxuXFxcbnZhcnlpbmcgdmVjMiB2X3Bvc2l0aW9uO1xcblxcXG5cXG5cXFxudm9pZCBtYWluKClcXG5cXFxue1xcblxcXG4gICAgZ2xfUG9zaXRpb24gPSB2ZWM0KHBvc2l0aW9uLCAwLjEsIDEuMCk7XFxuXFxcblxcblxcXG4gICAgdmVjMiB0cmFuc2Zvcm1lZFBvcyA9IChwb3NpdGlvbiAvIDIuMCkgKyB2ZWMyKDAuNSk7XFxuXFxcbiAgICB0cmFuc2Zvcm1lZFBvcyAqPSB1X25vaXNlVGV4dHVyZUxlbmd0aDtcXG5cXFxuICAgIHRyYW5zZm9ybWVkUG9zLnggKj0gdV9ub2lzZVRleHR1cmVMZW5ndGg7XFxuXFxcbiAgICB2X3Bvc2l0aW9uID0gdHJhbnNmb3JtZWRQb3M7XFxuXFxcbn1cXG5cXFxuXCI7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///61968\n')},19447:function(__unused_webpack___webpack_module__,__webpack_exports__){eval('//This file is automatically rebuilt by the Cesium build process.\n/* harmony default export */ __webpack_exports__["Z"] = ("uniform sampler2D u_opaqueDepthTexture;\\n\\\nuniform sampler2D u_translucentDepthTexture;\\n\\\n\\n\\\nvarying vec2 v_textureCoordinates;\\n\\\n\\n\\\nvoid main()\\n\\\n{\\n\\\n    float opaqueDepth = texture2D(u_opaqueDepthTexture, v_textureCoordinates).r;\\n\\\n    float translucentDepth = texture2D(u_translucentDepthTexture, v_textureCoordinates).r;\\n\\\n    translucentDepth = czm_branchFreeTernary(translucentDepth > opaqueDepth, 1.0, translucentDepth);\\n\\\n    gl_FragColor = czm_packDepth(translucentDepth);\\n\\\n}\\n\\\n");\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTk0NDcuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQSx5REFBZSx3Q0FBd0M7QUFDdkQsNENBQTRDO0FBQzVDO0FBQ0Esa0NBQWtDO0FBQ2xDO0FBQ0E7QUFDQSxDQUFDO0FBQ0QsZ0ZBQWdGO0FBQ2hGLDBGQUEwRjtBQUMxRixvR0FBb0c7QUFDcEcsbURBQW1EO0FBQ25ELENBQUM7QUFDRCxDQUFDLEVBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly92dWUzLXdlYnBhY2s1Ly4vbm9kZV9tb2R1bGVzL2Nlc2l1bS9Tb3VyY2UvU2hhZGVycy9Db21wYXJlQW5kUGFja1RyYW5zbHVjZW50RGVwdGguanM/MTBlZCJdLCJzb3VyY2VzQ29udGVudCI6WyIvL1RoaXMgZmlsZSBpcyBhdXRvbWF0aWNhbGx5IHJlYnVpbHQgYnkgdGhlIENlc2l1bSBidWlsZCBwcm9jZXNzLlxuZXhwb3J0IGRlZmF1bHQgXCJ1bmlmb3JtIHNhbXBsZXIyRCB1X29wYXF1ZURlcHRoVGV4dHVyZTtcXG5cXFxudW5pZm9ybSBzYW1wbGVyMkQgdV90cmFuc2x1Y2VudERlcHRoVGV4dHVyZTtcXG5cXFxuXFxuXFxcbnZhcnlpbmcgdmVjMiB2X3RleHR1cmVDb29yZGluYXRlcztcXG5cXFxuXFxuXFxcbnZvaWQgbWFpbigpXFxuXFxcbntcXG5cXFxuICAgIGZsb2F0IG9wYXF1ZURlcHRoID0gdGV4dHVyZTJEKHVfb3BhcXVlRGVwdGhUZXh0dXJlLCB2X3RleHR1cmVDb29yZGluYXRlcykucjtcXG5cXFxuICAgIGZsb2F0IHRyYW5zbHVjZW50RGVwdGggPSB0ZXh0dXJlMkQodV90cmFuc2x1Y2VudERlcHRoVGV4dHVyZSwgdl90ZXh0dXJlQ29vcmRpbmF0ZXMpLnI7XFxuXFxcbiAgICB0cmFuc2x1Y2VudERlcHRoID0gY3ptX2JyYW5jaEZyZWVUZXJuYXJ5KHRyYW5zbHVjZW50RGVwdGggPiBvcGFxdWVEZXB0aCwgMS4wLCB0cmFuc2x1Y2VudERlcHRoKTtcXG5cXFxuICAgIGdsX0ZyYWdDb2xvciA9IGN6bV9wYWNrRGVwdGgodHJhbnNsdWNlbnREZXB0aCk7XFxuXFxcbn1cXG5cXFxuXCI7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///19447\n')},19065:function(__unused_webpack___webpack_module__,__webpack_exports__){eval('//This file is automatically rebuilt by the Cesium build process.\n/* harmony default export */ __webpack_exports__["Z"] = ("/**\\n\\\n * Compositing for Weighted Blended Order-Independent Transparency. See:\\n\\\n * - http://jcgt.org/published/0002/02/09/\\n\\\n * - http://casual-effects.blogspot.com/2014/03/weighted-blended-order-independent.html\\n\\\n */\\n\\\n\\n\\\nuniform sampler2D u_opaque;\\n\\\nuniform sampler2D u_accumulation;\\n\\\nuniform sampler2D u_revealage;\\n\\\n\\n\\\nvarying vec2 v_textureCoordinates;\\n\\\n\\n\\\nvoid main()\\n\\\n{\\n\\\n    vec4 opaque = texture2D(u_opaque, v_textureCoordinates);\\n\\\n    vec4 accum = texture2D(u_accumulation, v_textureCoordinates);\\n\\\n    float r = texture2D(u_revealage, v_textureCoordinates).r;\\n\\\n\\n\\\n#ifdef MRT\\n\\\n    vec4 transparent = vec4(accum.rgb / clamp(r, 1e-4, 5e4), accum.a);\\n\\\n#else\\n\\\n    vec4 transparent = vec4(accum.rgb / clamp(accum.a, 1e-4, 5e4), r);\\n\\\n#endif\\n\\\n\\n\\\n    gl_FragColor = (1.0 - transparent.a) * transparent + transparent.a * opaque;\\n\\\n\\n\\\n    if (opaque != czm_backgroundColor)\\n\\\n    {\\n\\\n        gl_FragColor.a = 1.0;\\n\\\n    }\\n\\\n}\\n\\\n");\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTkwNjUuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQSx5REFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0IsaUNBQWlDO0FBQ2pDLDhCQUE4QjtBQUM5QjtBQUNBLGtDQUFrQztBQUNsQztBQUNBO0FBQ0EsQ0FBQztBQUNELDREQUE0RDtBQUM1RCxpRUFBaUU7QUFDakUsNkRBQTZEO0FBQzdEO0FBQ0E7QUFDQSxzRUFBc0U7QUFDdEU7QUFDQSxzRUFBc0U7QUFDdEU7QUFDQTtBQUNBLGdGQUFnRjtBQUNoRjtBQUNBO0FBQ0EsS0FBSztBQUNMLDZCQUE2QjtBQUM3QixLQUFLO0FBQ0wsQ0FBQztBQUNELENBQUMsRUFBQyIsInNvdXJjZXMiOlsid2VicGFjazovL3Z1ZTMtd2VicGFjazUvLi9ub2RlX21vZHVsZXMvY2VzaXVtL1NvdXJjZS9TaGFkZXJzL0NvbXBvc2l0ZU9JVEZTLmpzPzMxNmUiXSwic291cmNlc0NvbnRlbnQiOlsiLy9UaGlzIGZpbGUgaXMgYXV0b21hdGljYWxseSByZWJ1aWx0IGJ5IHRoZSBDZXNpdW0gYnVpbGQgcHJvY2Vzcy5cbmV4cG9ydCBkZWZhdWx0IFwiLyoqXFxuXFxcbiAqIENvbXBvc2l0aW5nIGZvciBXZWlnaHRlZCBCbGVuZGVkIE9yZGVyLUluZGVwZW5kZW50IFRyYW5zcGFyZW5jeS4gU2VlOlxcblxcXG4gKiAtIGh0dHA6Ly9qY2d0Lm9yZy9wdWJsaXNoZWQvMDAwMi8wMi8wOS9cXG5cXFxuICogLSBodHRwOi8vY2FzdWFsLWVmZmVjdHMuYmxvZ3Nwb3QuY29tLzIwMTQvMDMvd2VpZ2h0ZWQtYmxlbmRlZC1vcmRlci1pbmRlcGVuZGVudC5odG1sXFxuXFxcbiAqL1xcblxcXG5cXG5cXFxudW5pZm9ybSBzYW1wbGVyMkQgdV9vcGFxdWU7XFxuXFxcbnVuaWZvcm0gc2FtcGxlcjJEIHVfYWNjdW11bGF0aW9uO1xcblxcXG51bmlmb3JtIHNhbXBsZXIyRCB1X3JldmVhbGFnZTtcXG5cXFxuXFxuXFxcbnZhcnlpbmcgdmVjMiB2X3RleHR1cmVDb29yZGluYXRlcztcXG5cXFxuXFxuXFxcbnZvaWQgbWFpbigpXFxuXFxcbntcXG5cXFxuICAgIHZlYzQgb3BhcXVlID0gdGV4dHVyZTJEKHVfb3BhcXVlLCB2X3RleHR1cmVDb29yZGluYXRlcyk7XFxuXFxcbiAgICB2ZWM0IGFjY3VtID0gdGV4dHVyZTJEKHVfYWNjdW11bGF0aW9uLCB2X3RleHR1cmVDb29yZGluYXRlcyk7XFxuXFxcbiAgICBmbG9hdCByID0gdGV4dHVyZTJEKHVfcmV2ZWFsYWdlLCB2X3RleHR1cmVDb29yZGluYXRlcykucjtcXG5cXFxuXFxuXFxcbiNpZmRlZiBNUlRcXG5cXFxuICAgIHZlYzQgdHJhbnNwYXJlbnQgPSB2ZWM0KGFjY3VtLnJnYiAvIGNsYW1wKHIsIDFlLTQsIDVlNCksIGFjY3VtLmEpO1xcblxcXG4jZWxzZVxcblxcXG4gICAgdmVjNCB0cmFuc3BhcmVudCA9IHZlYzQoYWNjdW0ucmdiIC8gY2xhbXAoYWNjdW0uYSwgMWUtNCwgNWU0KSwgcik7XFxuXFxcbiNlbmRpZlxcblxcXG5cXG5cXFxuICAgIGdsX0ZyYWdDb2xvciA9ICgxLjAgLSB0cmFuc3BhcmVudC5hKSAqIHRyYW5zcGFyZW50ICsgdHJhbnNwYXJlbnQuYSAqIG9wYXF1ZTtcXG5cXFxuXFxuXFxcbiAgICBpZiAob3BhcXVlICE9IGN6bV9iYWNrZ3JvdW5kQ29sb3IpXFxuXFxcbiAgICB7XFxuXFxcbiAgICAgICAgZ2xfRnJhZ0NvbG9yLmEgPSAxLjA7XFxuXFxcbiAgICB9XFxuXFxcbn1cXG5cXFxuXCI7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///19065\n')},10135:function(__unused_webpack___webpack_module__,__webpack_exports__){eval('//This file is automatically rebuilt by the Cesium build process.\n/* harmony default export */ __webpack_exports__["Z"] = ("varying vec4 positionEC;\\n\\\n\\n\\\nvoid main()\\n\\\n{\\n\\\n    vec3 position;\\n\\\n    vec3 direction;\\n\\\n    if (czm_orthographicIn3D == 1.0)\\n\\\n    {\\n\\\n        vec2 uv = (gl_FragCoord.xy -  czm_viewport.xy) / czm_viewport.zw;\\n\\\n        vec2 minPlane = vec2(czm_frustumPlanes.z, czm_frustumPlanes.y); // left, bottom\\n\\\n        vec2 maxPlane = vec2(czm_frustumPlanes.w, czm_frustumPlanes.x); // right, top\\n\\\n        position = vec3(mix(minPlane, maxPlane, uv), 0.0);\\n\\\n        direction = vec3(0.0, 0.0, -1.0);\\n\\\n    } \\n\\\n    else \\n\\\n    {\\n\\\n        position = vec3(0.0);\\n\\\n        direction = normalize(positionEC.xyz);\\n\\\n    }\\n\\\n\\n\\\n    czm_ray ray = czm_ray(position, direction);\\n\\\n\\n\\\n    vec3 ellipsoid_center = czm_view[3].xyz;\\n\\\n\\n\\\n    czm_raySegment intersection = czm_rayEllipsoidIntersectionInterval(ray, ellipsoid_center, czm_ellipsoidInverseRadii);\\n\\\n    if (!czm_isEmpty(intersection))\\n\\\n    {\\n\\\n        gl_FragColor = vec4(1.0, 1.0, 0.0, 1.0);\\n\\\n    }\\n\\\n    else\\n\\\n    {\\n\\\n        discard;\\n\\\n    }\\n\\\n\\n\\\n    czm_writeLogDepth();\\n\\\n}\\n\\\n");\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTAxMzUuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQSx5REFBZSx5QkFBeUI7QUFDeEM7QUFDQTtBQUNBLENBQUM7QUFDRCxrQkFBa0I7QUFDbEIsbUJBQW1CO0FBQ25CO0FBQ0EsS0FBSztBQUNMLHlFQUF5RTtBQUN6RSx3RUFBd0U7QUFDeEUsd0VBQXdFO0FBQ3hFLDBEQUEwRDtBQUMxRCx5Q0FBeUM7QUFDekMsTUFBTTtBQUNOO0FBQ0EsS0FBSztBQUNMLDZCQUE2QjtBQUM3Qiw4Q0FBOEM7QUFDOUMsS0FBSztBQUNMO0FBQ0EsK0NBQStDO0FBQy9DO0FBQ0EsNENBQTRDO0FBQzVDO0FBQ0EseUhBQXlIO0FBQ3pIO0FBQ0EsS0FBSztBQUNMLGdEQUFnRDtBQUNoRCxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0wsZ0JBQWdCO0FBQ2hCLEtBQUs7QUFDTDtBQUNBLHdCQUF3QjtBQUN4QixDQUFDO0FBQ0QsQ0FBQyxFQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdnVlMy13ZWJwYWNrNS8uL25vZGVfbW9kdWxlcy9jZXNpdW0vU291cmNlL1NoYWRlcnMvRGVwdGhQbGFuZUZTLmpzPzUwNjEiXSwic291cmNlc0NvbnRlbnQiOlsiLy9UaGlzIGZpbGUgaXMgYXV0b21hdGljYWxseSByZWJ1aWx0IGJ5IHRoZSBDZXNpdW0gYnVpbGQgcHJvY2Vzcy5cbmV4cG9ydCBkZWZhdWx0IFwidmFyeWluZyB2ZWM0IHBvc2l0aW9uRUM7XFxuXFxcblxcblxcXG52b2lkIG1haW4oKVxcblxcXG57XFxuXFxcbiAgICB2ZWMzIHBvc2l0aW9uO1xcblxcXG4gICAgdmVjMyBkaXJlY3Rpb247XFxuXFxcbiAgICBpZiAoY3ptX29ydGhvZ3JhcGhpY0luM0QgPT0gMS4wKVxcblxcXG4gICAge1xcblxcXG4gICAgICAgIHZlYzIgdXYgPSAoZ2xfRnJhZ0Nvb3JkLnh5IC0gIGN6bV92aWV3cG9ydC54eSkgLyBjem1fdmlld3BvcnQuenc7XFxuXFxcbiAgICAgICAgdmVjMiBtaW5QbGFuZSA9IHZlYzIoY3ptX2ZydXN0dW1QbGFuZXMueiwgY3ptX2ZydXN0dW1QbGFuZXMueSk7IC8vIGxlZnQsIGJvdHRvbVxcblxcXG4gICAgICAgIHZlYzIgbWF4UGxhbmUgPSB2ZWMyKGN6bV9mcnVzdHVtUGxhbmVzLncsIGN6bV9mcnVzdHVtUGxhbmVzLngpOyAvLyByaWdodCwgdG9wXFxuXFxcbiAgICAgICAgcG9zaXRpb24gPSB2ZWMzKG1peChtaW5QbGFuZSwgbWF4UGxhbmUsIHV2KSwgMC4wKTtcXG5cXFxuICAgICAgICBkaXJlY3Rpb24gPSB2ZWMzKDAuMCwgMC4wLCAtMS4wKTtcXG5cXFxuICAgIH0gXFxuXFxcbiAgICBlbHNlIFxcblxcXG4gICAge1xcblxcXG4gICAgICAgIHBvc2l0aW9uID0gdmVjMygwLjApO1xcblxcXG4gICAgICAgIGRpcmVjdGlvbiA9IG5vcm1hbGl6ZShwb3NpdGlvbkVDLnh5eik7XFxuXFxcbiAgICB9XFxuXFxcblxcblxcXG4gICAgY3ptX3JheSByYXkgPSBjem1fcmF5KHBvc2l0aW9uLCBkaXJlY3Rpb24pO1xcblxcXG5cXG5cXFxuICAgIHZlYzMgZWxsaXBzb2lkX2NlbnRlciA9IGN6bV92aWV3WzNdLnh5ejtcXG5cXFxuXFxuXFxcbiAgICBjem1fcmF5U2VnbWVudCBpbnRlcnNlY3Rpb24gPSBjem1fcmF5RWxsaXBzb2lkSW50ZXJzZWN0aW9uSW50ZXJ2YWwocmF5LCBlbGxpcHNvaWRfY2VudGVyLCBjem1fZWxsaXBzb2lkSW52ZXJzZVJhZGlpKTtcXG5cXFxuICAgIGlmICghY3ptX2lzRW1wdHkoaW50ZXJzZWN0aW9uKSlcXG5cXFxuICAgIHtcXG5cXFxuICAgICAgICBnbF9GcmFnQ29sb3IgPSB2ZWM0KDEuMCwgMS4wLCAwLjAsIDEuMCk7XFxuXFxcbiAgICB9XFxuXFxcbiAgICBlbHNlXFxuXFxcbiAgICB7XFxuXFxcbiAgICAgICAgZGlzY2FyZDtcXG5cXFxuICAgIH1cXG5cXFxuXFxuXFxcbiAgICBjem1fd3JpdGVMb2dEZXB0aCgpO1xcblxcXG59XFxuXFxcblwiO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///10135\n')},39774:function(__unused_webpack___webpack_module__,__webpack_exports__){eval('//This file is automatically rebuilt by the Cesium build process.\n/* harmony default export */ __webpack_exports__["Z"] = ("attribute vec4 position;\\n\\\n\\n\\\nvarying vec4 positionEC;\\n\\\n\\n\\\nvoid main()\\n\\\n{\\n\\\n    positionEC = czm_modelView * position;\\n\\\n    gl_Position = czm_projection * positionEC;\\n\\\n\\n\\\n    czm_vertexLogDepth();\\n\\\n}\\n\\\n");\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMzk3NzQuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQSx5REFBZSx5QkFBeUI7QUFDeEM7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBLENBQUM7QUFDRCwwQ0FBMEM7QUFDMUMsOENBQThDO0FBQzlDO0FBQ0EseUJBQXlCO0FBQ3pCLENBQUM7QUFDRCxDQUFDLEVBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly92dWUzLXdlYnBhY2s1Ly4vbm9kZV9tb2R1bGVzL2Nlc2l1bS9Tb3VyY2UvU2hhZGVycy9EZXB0aFBsYW5lVlMuanM/MWMxOSJdLCJzb3VyY2VzQ29udGVudCI6WyIvL1RoaXMgZmlsZSBpcyBhdXRvbWF0aWNhbGx5IHJlYnVpbHQgYnkgdGhlIENlc2l1bSBidWlsZCBwcm9jZXNzLlxuZXhwb3J0IGRlZmF1bHQgXCJhdHRyaWJ1dGUgdmVjNCBwb3NpdGlvbjtcXG5cXFxuXFxuXFxcbnZhcnlpbmcgdmVjNCBwb3NpdGlvbkVDO1xcblxcXG5cXG5cXFxudm9pZCBtYWluKClcXG5cXFxue1xcblxcXG4gICAgcG9zaXRpb25FQyA9IGN6bV9tb2RlbFZpZXcgKiBwb3NpdGlvbjtcXG5cXFxuICAgIGdsX1Bvc2l0aW9uID0gY3ptX3Byb2plY3Rpb24gKiBwb3NpdGlvbkVDO1xcblxcXG5cXG5cXFxuICAgIGN6bV92ZXJ0ZXhMb2dEZXB0aCgpO1xcblxcXG59XFxuXFxcblwiO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///39774\n')},90565:function(__unused_webpack___webpack_module__,__webpack_exports__){eval('//This file is automatically rebuilt by the Cesium build process.\n/* harmony default export */ __webpack_exports__["Z"] = ("#ifdef WRITE_DEPTH\\n\\\n#ifdef GL_EXT_frag_depth\\n\\\n#extension GL_EXT_frag_depth : enable\\n\\\n#endif\\n\\\n#endif\\n\\\n\\n\\\nuniform vec3 u_radii;\\n\\\nuniform vec3 u_oneOverEllipsoidRadiiSquared;\\n\\\n\\n\\\nvarying vec3 v_positionEC;\\n\\\n\\n\\\nvec4 computeEllipsoidColor(czm_ray ray, float intersection, float side)\\n\\\n{\\n\\\n    vec3 positionEC = czm_pointAlongRay(ray, intersection);\\n\\\n    vec3 positionMC = (czm_inverseModelView * vec4(positionEC, 1.0)).xyz;\\n\\\n    vec3 geodeticNormal = normalize(czm_geodeticSurfaceNormal(positionMC, vec3(0.0), u_oneOverEllipsoidRadiiSquared));\\n\\\n    vec3 sphericalNormal = normalize(positionMC / u_radii);\\n\\\n    vec3 normalMC = geodeticNormal * side;              // normalized surface normal (always facing the viewer) in model coordinates\\n\\\n    vec3 normalEC = normalize(czm_normal * normalMC);   // normalized surface normal in eye coordiantes\\n\\\n\\n\\\n    vec2 st = czm_ellipsoidWgs84TextureCoordinates(sphericalNormal);\\n\\\n    vec3 positionToEyeEC = -positionEC;\\n\\\n\\n\\\n    czm_materialInput materialInput;\\n\\\n    materialInput.s = st.s;\\n\\\n    materialInput.st = st;\\n\\\n    materialInput.str = (positionMC + u_radii) / u_radii;\\n\\\n    materialInput.normalEC = normalEC;\\n\\\n    materialInput.tangentToEyeMatrix = czm_eastNorthUpToEyeCoordinates(positionMC, normalEC);\\n\\\n    materialInput.positionToEyeEC = positionToEyeEC;\\n\\\n    czm_material material = czm_getMaterial(materialInput);\\n\\\n\\n\\\n#ifdef ONLY_SUN_LIGHTING\\n\\\n    return czm_private_phong(normalize(positionToEyeEC), material, czm_sunDirectionEC);\\n\\\n#else\\n\\\n    return czm_phong(normalize(positionToEyeEC), material, czm_lightDirectionEC);\\n\\\n#endif\\n\\\n}\\n\\\n\\n\\\nvoid main()\\n\\\n{\\n\\\n    // PERFORMANCE_TODO: When dynamic branching is available, compute ratio of maximum and minimum radii\\n\\\n    // in the vertex shader. Only when it is larger than some constant, march along the ray.\\n\\\n    // Otherwise perform one intersection test which will be the common case.\\n\\\n\\n\\\n    // Test if the ray intersects a sphere with the ellipsoid\'s maximum radius.\\n\\\n    // For very oblate ellipsoids, using the ellipsoid\'s radii for an intersection test\\n\\\n    // may cause false negatives. This will discard fragments before marching the ray forward.\\n\\\n    float maxRadius = max(u_radii.x, max(u_radii.y, u_radii.z)) * 1.5;\\n\\\n    vec3 direction = normalize(v_positionEC);\\n\\\n    vec3 ellipsoidCenter = czm_modelView[3].xyz;\\n\\\n\\n\\\n    float t1 = -1.0;\\n\\\n    float t2 = -1.0;\\n\\\n\\n\\\n    float b = -2.0 * dot(direction, ellipsoidCenter);\\n\\\n    float c = dot(ellipsoidCenter, ellipsoidCenter) - maxRadius * maxRadius;\\n\\\n\\n\\\n    float discriminant = b * b - 4.0 * c;\\n\\\n    if (discriminant >= 0.0) {\\n\\\n        t1 = (-b - sqrt(discriminant)) * 0.5;\\n\\\n        t2 = (-b + sqrt(discriminant)) * 0.5;\\n\\\n    }\\n\\\n\\n\\\n    if (t1 < 0.0 && t2 < 0.0) {\\n\\\n        discard;\\n\\\n    }\\n\\\n\\n\\\n    float t = min(t1, t2);\\n\\\n    if (t < 0.0) {\\n\\\n        t = 0.0;\\n\\\n    }\\n\\\n\\n\\\n    // March ray forward to intersection with larger sphere and find\\n\\\n    czm_ray ray = czm_ray(t * direction, direction);\\n\\\n\\n\\\n    vec3 ellipsoid_inverseRadii = vec3(1.0 / u_radii.x, 1.0 / u_radii.y, 1.0 / u_radii.z);\\n\\\n\\n\\\n    czm_raySegment intersection = czm_rayEllipsoidIntersectionInterval(ray, ellipsoidCenter, ellipsoid_inverseRadii);\\n\\\n\\n\\\n    if (czm_isEmpty(intersection))\\n\\\n    {\\n\\\n        discard;\\n\\\n    }\\n\\\n\\n\\\n    // If the viewer is outside, compute outsideFaceColor, with normals facing outward.\\n\\\n    vec4 outsideFaceColor = (intersection.start != 0.0) ? computeEllipsoidColor(ray, intersection.start, 1.0) : vec4(0.0);\\n\\\n\\n\\\n    // If the viewer either is inside or can see inside, compute insideFaceColor, with normals facing inward.\\n\\\n    vec4 insideFaceColor = (outsideFaceColor.a < 1.0) ? computeEllipsoidColor(ray, intersection.stop, -1.0) : vec4(0.0);\\n\\\n\\n\\\n    gl_FragColor = mix(insideFaceColor, outsideFaceColor, outsideFaceColor.a);\\n\\\n    gl_FragColor.a = 1.0 - (1.0 - insideFaceColor.a) * (1.0 - outsideFaceColor.a);\\n\\\n\\n\\\n#ifdef WRITE_DEPTH\\n\\\n#ifdef GL_EXT_frag_depth\\n\\\n    t = (intersection.start != 0.0) ? intersection.start : intersection.stop;\\n\\\n    vec3 positionEC = czm_pointAlongRay(ray, t);\\n\\\n    vec4 positionCC = czm_projection * vec4(positionEC, 1.0);\\n\\\n#ifdef LOG_DEPTH\\n\\\n    czm_writeLogDepth(1.0 + positionCC.w);\\n\\\n#else\\n\\\n    float z = positionCC.z / positionCC.w;\\n\\\n\\n\\\n    float n = czm_depthRange.near;\\n\\\n    float f = czm_depthRange.far;\\n\\\n\\n\\\n    gl_FragDepthEXT = (z * (f - n) + f + n) * 0.5;\\n\\\n#endif\\n\\\n#endif\\n\\\n#endif\\n\\\n}\\n\\\n");\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiOTA1NjUuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQSx5REFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckIsNENBQTRDO0FBQzVDO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQSxDQUFDO0FBQ0QsMkRBQTJEO0FBQzNELHlFQUF5RTtBQUN6RSxzSEFBc0g7QUFDdEgsMkRBQTJEO0FBQzNELHdEQUF3RDtBQUN4RCx3REFBd0Q7QUFDeEQ7QUFDQSxvRUFBb0U7QUFDcEUsdUNBQXVDO0FBQ3ZDO0FBQ0Esb0NBQW9DO0FBQ3BDLDJCQUEyQjtBQUMzQiwwQkFBMEI7QUFDMUIseURBQXlEO0FBQ3pELHNDQUFzQztBQUN0Qyw2RkFBNkY7QUFDN0Ysb0RBQW9EO0FBQ3BELDJEQUEyRDtBQUMzRDtBQUNBO0FBQ0EsdUZBQXVGO0FBQ3ZGO0FBQ0EsaUZBQWlGO0FBQ2pGO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzRUFBc0U7QUFDdEUsNkNBQTZDO0FBQzdDLGdEQUFnRDtBQUNoRDtBQUNBLG9CQUFvQjtBQUNwQixvQkFBb0I7QUFDcEI7QUFDQSxxREFBcUQ7QUFDckQsNEVBQTRFO0FBQzVFO0FBQ0EseUNBQXlDO0FBQ3pDLDhCQUE4QjtBQUM5Qiw2Q0FBNkM7QUFDN0MsNkNBQTZDO0FBQzdDLEtBQUs7QUFDTDtBQUNBLCtCQUErQjtBQUMvQixnQkFBZ0I7QUFDaEIsS0FBSztBQUNMO0FBQ0EsMEJBQTBCO0FBQzFCLGtCQUFrQjtBQUNsQixnQkFBZ0I7QUFDaEIsS0FBSztBQUNMO0FBQ0E7QUFDQSxvREFBb0Q7QUFDcEQ7QUFDQSwwRkFBMEY7QUFDMUY7QUFDQSxxSEFBcUg7QUFDckg7QUFDQTtBQUNBLEtBQUs7QUFDTCxnQkFBZ0I7QUFDaEIsS0FBSztBQUNMO0FBQ0E7QUFDQSwwSEFBMEg7QUFDMUg7QUFDQTtBQUNBLHdIQUF3SDtBQUN4SDtBQUNBLDhFQUE4RTtBQUM5RSxrRkFBa0Y7QUFDbEY7QUFDQTtBQUNBO0FBQ0EsNkVBQTZFO0FBQzdFLGdEQUFnRDtBQUNoRCw2REFBNkQ7QUFDN0Q7QUFDQSwwQ0FBMEM7QUFDMUM7QUFDQSwwQ0FBMEM7QUFDMUM7QUFDQSxrQ0FBa0M7QUFDbEMsaUNBQWlDO0FBQ2pDO0FBQ0Esa0RBQWtEO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRCxDQUFDLEVBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly92dWUzLXdlYnBhY2s1Ly4vbm9kZV9tb2R1bGVzL2Nlc2l1bS9Tb3VyY2UvU2hhZGVycy9FbGxpcHNvaWRGUy5qcz9lOTZjIl0sInNvdXJjZXNDb250ZW50IjpbIi8vVGhpcyBmaWxlIGlzIGF1dG9tYXRpY2FsbHkgcmVidWlsdCBieSB0aGUgQ2VzaXVtIGJ1aWxkIHByb2Nlc3MuXG5leHBvcnQgZGVmYXVsdCBcIiNpZmRlZiBXUklURV9ERVBUSFxcblxcXG4jaWZkZWYgR0xfRVhUX2ZyYWdfZGVwdGhcXG5cXFxuI2V4dGVuc2lvbiBHTF9FWFRfZnJhZ19kZXB0aCA6IGVuYWJsZVxcblxcXG4jZW5kaWZcXG5cXFxuI2VuZGlmXFxuXFxcblxcblxcXG51bmlmb3JtIHZlYzMgdV9yYWRpaTtcXG5cXFxudW5pZm9ybSB2ZWMzIHVfb25lT3ZlckVsbGlwc29pZFJhZGlpU3F1YXJlZDtcXG5cXFxuXFxuXFxcbnZhcnlpbmcgdmVjMyB2X3Bvc2l0aW9uRUM7XFxuXFxcblxcblxcXG52ZWM0IGNvbXB1dGVFbGxpcHNvaWRDb2xvcihjem1fcmF5IHJheSwgZmxvYXQgaW50ZXJzZWN0aW9uLCBmbG9hdCBzaWRlKVxcblxcXG57XFxuXFxcbiAgICB2ZWMzIHBvc2l0aW9uRUMgPSBjem1fcG9pbnRBbG9uZ1JheShyYXksIGludGVyc2VjdGlvbik7XFxuXFxcbiAgICB2ZWMzIHBvc2l0aW9uTUMgPSAoY3ptX2ludmVyc2VNb2RlbFZpZXcgKiB2ZWM0KHBvc2l0aW9uRUMsIDEuMCkpLnh5ejtcXG5cXFxuICAgIHZlYzMgZ2VvZGV0aWNOb3JtYWwgPSBub3JtYWxpemUoY3ptX2dlb2RldGljU3VyZmFjZU5vcm1hbChwb3NpdGlvbk1DLCB2ZWMzKDAuMCksIHVfb25lT3ZlckVsbGlwc29pZFJhZGlpU3F1YXJlZCkpO1xcblxcXG4gICAgdmVjMyBzcGhlcmljYWxOb3JtYWwgPSBub3JtYWxpemUocG9zaXRpb25NQyAvIHVfcmFkaWkpO1xcblxcXG4gICAgdmVjMyBub3JtYWxNQyA9IGdlb2RldGljTm9ybWFsICogc2lkZTsgICAgICAgICAgICAgIC8vIG5vcm1hbGl6ZWQgc3VyZmFjZSBub3JtYWwgKGFsd2F5cyBmYWNpbmcgdGhlIHZpZXdlcikgaW4gbW9kZWwgY29vcmRpbmF0ZXNcXG5cXFxuICAgIHZlYzMgbm9ybWFsRUMgPSBub3JtYWxpemUoY3ptX25vcm1hbCAqIG5vcm1hbE1DKTsgICAvLyBub3JtYWxpemVkIHN1cmZhY2Ugbm9ybWFsIGluIGV5ZSBjb29yZGlhbnRlc1xcblxcXG5cXG5cXFxuICAgIHZlYzIgc3QgPSBjem1fZWxsaXBzb2lkV2dzODRUZXh0dXJlQ29vcmRpbmF0ZXMoc3BoZXJpY2FsTm9ybWFsKTtcXG5cXFxuICAgIHZlYzMgcG9zaXRpb25Ub0V5ZUVDID0gLXBvc2l0aW9uRUM7XFxuXFxcblxcblxcXG4gICAgY3ptX21hdGVyaWFsSW5wdXQgbWF0ZXJpYWxJbnB1dDtcXG5cXFxuICAgIG1hdGVyaWFsSW5wdXQucyA9IHN0LnM7XFxuXFxcbiAgICBtYXRlcmlhbElucHV0LnN0ID0gc3Q7XFxuXFxcbiAgICBtYXRlcmlhbElucHV0LnN0ciA9IChwb3NpdGlvbk1DICsgdV9yYWRpaSkgLyB1X3JhZGlpO1xcblxcXG4gICAgbWF0ZXJpYWxJbnB1dC5ub3JtYWxFQyA9IG5vcm1hbEVDO1xcblxcXG4gICAgbWF0ZXJpYWxJbnB1dC50YW5nZW50VG9FeWVNYXRyaXggPSBjem1fZWFzdE5vcnRoVXBUb0V5ZUNvb3JkaW5hdGVzKHBvc2l0aW9uTUMsIG5vcm1hbEVDKTtcXG5cXFxuICAgIG1hdGVyaWFsSW5wdXQucG9zaXRpb25Ub0V5ZUVDID0gcG9zaXRpb25Ub0V5ZUVDO1xcblxcXG4gICAgY3ptX21hdGVyaWFsIG1hdGVyaWFsID0gY3ptX2dldE1hdGVyaWFsKG1hdGVyaWFsSW5wdXQpO1xcblxcXG5cXG5cXFxuI2lmZGVmIE9OTFlfU1VOX0xJR0hUSU5HXFxuXFxcbiAgICByZXR1cm4gY3ptX3ByaXZhdGVfcGhvbmcobm9ybWFsaXplKHBvc2l0aW9uVG9FeWVFQyksIG1hdGVyaWFsLCBjem1fc3VuRGlyZWN0aW9uRUMpO1xcblxcXG4jZWxzZVxcblxcXG4gICAgcmV0dXJuIGN6bV9waG9uZyhub3JtYWxpemUocG9zaXRpb25Ub0V5ZUVDKSwgbWF0ZXJpYWwsIGN6bV9saWdodERpcmVjdGlvbkVDKTtcXG5cXFxuI2VuZGlmXFxuXFxcbn1cXG5cXFxuXFxuXFxcbnZvaWQgbWFpbigpXFxuXFxcbntcXG5cXFxuICAgIC8vIFBFUkZPUk1BTkNFX1RPRE86IFdoZW4gZHluYW1pYyBicmFuY2hpbmcgaXMgYXZhaWxhYmxlLCBjb21wdXRlIHJhdGlvIG9mIG1heGltdW0gYW5kIG1pbmltdW0gcmFkaWlcXG5cXFxuICAgIC8vIGluIHRoZSB2ZXJ0ZXggc2hhZGVyLiBPbmx5IHdoZW4gaXQgaXMgbGFyZ2VyIHRoYW4gc29tZSBjb25zdGFudCwgbWFyY2ggYWxvbmcgdGhlIHJheS5cXG5cXFxuICAgIC8vIE90aGVyd2lzZSBwZXJmb3JtIG9uZSBpbnRlcnNlY3Rpb24gdGVzdCB3aGljaCB3aWxsIGJlIHRoZSBjb21tb24gY2FzZS5cXG5cXFxuXFxuXFxcbiAgICAvLyBUZXN0IGlmIHRoZSByYXkgaW50ZXJzZWN0cyBhIHNwaGVyZSB3aXRoIHRoZSBlbGxpcHNvaWQncyBtYXhpbXVtIHJhZGl1cy5cXG5cXFxuICAgIC8vIEZvciB2ZXJ5IG9ibGF0ZSBlbGxpcHNvaWRzLCB1c2luZyB0aGUgZWxsaXBzb2lkJ3MgcmFkaWkgZm9yIGFuIGludGVyc2VjdGlvbiB0ZXN0XFxuXFxcbiAgICAvLyBtYXkgY2F1c2UgZmFsc2UgbmVnYXRpdmVzLiBUaGlzIHdpbGwgZGlzY2FyZCBmcmFnbWVudHMgYmVmb3JlIG1hcmNoaW5nIHRoZSByYXkgZm9yd2FyZC5cXG5cXFxuICAgIGZsb2F0IG1heFJhZGl1cyA9IG1heCh1X3JhZGlpLngsIG1heCh1X3JhZGlpLnksIHVfcmFkaWkueikpICogMS41O1xcblxcXG4gICAgdmVjMyBkaXJlY3Rpb24gPSBub3JtYWxpemUodl9wb3NpdGlvbkVDKTtcXG5cXFxuICAgIHZlYzMgZWxsaXBzb2lkQ2VudGVyID0gY3ptX21vZGVsVmlld1szXS54eXo7XFxuXFxcblxcblxcXG4gICAgZmxvYXQgdDEgPSAtMS4wO1xcblxcXG4gICAgZmxvYXQgdDIgPSAtMS4wO1xcblxcXG5cXG5cXFxuICAgIGZsb2F0IGIgPSAtMi4wICogZG90KGRpcmVjdGlvbiwgZWxsaXBzb2lkQ2VudGVyKTtcXG5cXFxuICAgIGZsb2F0IGMgPSBkb3QoZWxsaXBzb2lkQ2VudGVyLCBlbGxpcHNvaWRDZW50ZXIpIC0gbWF4UmFkaXVzICogbWF4UmFkaXVzO1xcblxcXG5cXG5cXFxuICAgIGZsb2F0IGRpc2NyaW1pbmFudCA9IGIgKiBiIC0gNC4wICogYztcXG5cXFxuICAgIGlmIChkaXNjcmltaW5hbnQgPj0gMC4wKSB7XFxuXFxcbiAgICAgICAgdDEgPSAoLWIgLSBzcXJ0KGRpc2NyaW1pbmFudCkpICogMC41O1xcblxcXG4gICAgICAgIHQyID0gKC1iICsgc3FydChkaXNjcmltaW5hbnQpKSAqIDAuNTtcXG5cXFxuICAgIH1cXG5cXFxuXFxuXFxcbiAgICBpZiAodDEgPCAwLjAgJiYgdDIgPCAwLjApIHtcXG5cXFxuICAgICAgICBkaXNjYXJkO1xcblxcXG4gICAgfVxcblxcXG5cXG5cXFxuICAgIGZsb2F0IHQgPSBtaW4odDEsIHQyKTtcXG5cXFxuICAgIGlmICh0IDwgMC4wKSB7XFxuXFxcbiAgICAgICAgdCA9IDAuMDtcXG5cXFxuICAgIH1cXG5cXFxuXFxuXFxcbiAgICAvLyBNYXJjaCByYXkgZm9yd2FyZCB0byBpbnRlcnNlY3Rpb24gd2l0aCBsYXJnZXIgc3BoZXJlIGFuZCBmaW5kXFxuXFxcbiAgICBjem1fcmF5IHJheSA9IGN6bV9yYXkodCAqIGRpcmVjdGlvbiwgZGlyZWN0aW9uKTtcXG5cXFxuXFxuXFxcbiAgICB2ZWMzIGVsbGlwc29pZF9pbnZlcnNlUmFkaWkgPSB2ZWMzKDEuMCAvIHVfcmFkaWkueCwgMS4wIC8gdV9yYWRpaS55LCAxLjAgLyB1X3JhZGlpLnopO1xcblxcXG5cXG5cXFxuICAgIGN6bV9yYXlTZWdtZW50IGludGVyc2VjdGlvbiA9IGN6bV9yYXlFbGxpcHNvaWRJbnRlcnNlY3Rpb25JbnRlcnZhbChyYXksIGVsbGlwc29pZENlbnRlciwgZWxsaXBzb2lkX2ludmVyc2VSYWRpaSk7XFxuXFxcblxcblxcXG4gICAgaWYgKGN6bV9pc0VtcHR5KGludGVyc2VjdGlvbikpXFxuXFxcbiAgICB7XFxuXFxcbiAgICAgICAgZGlzY2FyZDtcXG5cXFxuICAgIH1cXG5cXFxuXFxuXFxcbiAgICAvLyBJZiB0aGUgdmlld2VyIGlzIG91dHNpZGUsIGNvbXB1dGUgb3V0c2lkZUZhY2VDb2xvciwgd2l0aCBub3JtYWxzIGZhY2luZyBvdXR3YXJkLlxcblxcXG4gICAgdmVjNCBvdXRzaWRlRmFjZUNvbG9yID0gKGludGVyc2VjdGlvbi5zdGFydCAhPSAwLjApID8gY29tcHV0ZUVsbGlwc29pZENvbG9yKHJheSwgaW50ZXJzZWN0aW9uLnN0YXJ0LCAxLjApIDogdmVjNCgwLjApO1xcblxcXG5cXG5cXFxuICAgIC8vIElmIHRoZSB2aWV3ZXIgZWl0aGVyIGlzIGluc2lkZSBvciBjYW4gc2VlIGluc2lkZSwgY29tcHV0ZSBpbnNpZGVGYWNlQ29sb3IsIHdpdGggbm9ybWFscyBmYWNpbmcgaW53YXJkLlxcblxcXG4gICAgdmVjNCBpbnNpZGVGYWNlQ29sb3IgPSAob3V0c2lkZUZhY2VDb2xvci5hIDwgMS4wKSA/IGNvbXB1dGVFbGxpcHNvaWRDb2xvcihyYXksIGludGVyc2VjdGlvbi5zdG9wLCAtMS4wKSA6IHZlYzQoMC4wKTtcXG5cXFxuXFxuXFxcbiAgICBnbF9GcmFnQ29sb3IgPSBtaXgoaW5zaWRlRmFjZUNvbG9yLCBvdXRzaWRlRmFjZUNvbG9yLCBvdXRzaWRlRmFjZUNvbG9yLmEpO1xcblxcXG4gICAgZ2xfRnJhZ0NvbG9yLmEgPSAxLjAgLSAoMS4wIC0gaW5zaWRlRmFjZUNvbG9yLmEpICogKDEuMCAtIG91dHNpZGVGYWNlQ29sb3IuYSk7XFxuXFxcblxcblxcXG4jaWZkZWYgV1JJVEVfREVQVEhcXG5cXFxuI2lmZGVmIEdMX0VYVF9mcmFnX2RlcHRoXFxuXFxcbiAgICB0ID0gKGludGVyc2VjdGlvbi5zdGFydCAhPSAwLjApID8gaW50ZXJzZWN0aW9uLnN0YXJ0IDogaW50ZXJzZWN0aW9uLnN0b3A7XFxuXFxcbiAgICB2ZWMzIHBvc2l0aW9uRUMgPSBjem1fcG9pbnRBbG9uZ1JheShyYXksIHQpO1xcblxcXG4gICAgdmVjNCBwb3NpdGlvbkNDID0gY3ptX3Byb2plY3Rpb24gKiB2ZWM0KHBvc2l0aW9uRUMsIDEuMCk7XFxuXFxcbiNpZmRlZiBMT0dfREVQVEhcXG5cXFxuICAgIGN6bV93cml0ZUxvZ0RlcHRoKDEuMCArIHBvc2l0aW9uQ0Mudyk7XFxuXFxcbiNlbHNlXFxuXFxcbiAgICBmbG9hdCB6ID0gcG9zaXRpb25DQy56IC8gcG9zaXRpb25DQy53O1xcblxcXG5cXG5cXFxuICAgIGZsb2F0IG4gPSBjem1fZGVwdGhSYW5nZS5uZWFyO1xcblxcXG4gICAgZmxvYXQgZiA9IGN6bV9kZXB0aFJhbmdlLmZhcjtcXG5cXFxuXFxuXFxcbiAgICBnbF9GcmFnRGVwdGhFWFQgPSAoeiAqIChmIC0gbikgKyBmICsgbikgKiAwLjU7XFxuXFxcbiNlbmRpZlxcblxcXG4jZW5kaWZcXG5cXFxuI2VuZGlmXFxuXFxcbn1cXG5cXFxuXCI7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///90565\n')},26440:function(__unused_webpack___webpack_module__,__webpack_exports__){eval('//This file is automatically rebuilt by the Cesium build process.\n/* harmony default export */ __webpack_exports__["Z"] = ("attribute vec3 position;\\n\\\n\\n\\\nuniform vec3 u_radii;\\n\\\n\\n\\\nvarying vec3 v_positionEC;\\n\\\n\\n\\\nvoid main()\\n\\\n{\\n\\\n    // In the vertex data, the cube goes from (-1.0, -1.0, -1.0) to (1.0, 1.0, 1.0) in model coordinates.\\n\\\n    // Scale to consider the radii.  We could also do this once on the CPU when using the BoxGeometry,\\n\\\n    // but doing it here allows us to change the radii without rewriting the vertex data, and\\n\\\n    // allows all ellipsoids to reuse the same vertex data.\\n\\\n    vec4 p = vec4(u_radii * position, 1.0);\\n\\\n\\n\\\n    v_positionEC = (czm_modelView * p).xyz;     // position in eye coordinates\\n\\\n    gl_Position = czm_modelViewProjection * p;  // position in clip coordinates\\n\\\n\\n\\\n    // With multi-frustum, when the ellipsoid primitive is positioned on the intersection of two frustums\\n\\\n    // and close to terrain, the terrain (writes depth) in the closest frustum can overwrite part of the\\n\\\n    // ellipsoid (does not write depth) that was rendered in the farther frustum.\\n\\\n    //\\n\\\n    // Here, we clamp the depth in the vertex shader to avoid being overwritten; however, this creates\\n\\\n    // artifacts since some fragments can be alpha blended twice.  This is solved by only rendering\\n\\\n    // the ellipsoid in the closest frustum to the viewer.\\n\\\n    gl_Position.z = clamp(gl_Position.z, czm_depthRange.near, czm_depthRange.far);\\n\\\n\\n\\\n    czm_vertexLogDepth();\\n\\\n}\\n\\\n");\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjY0NDAuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQSx5REFBZSx5QkFBeUI7QUFDeEM7QUFDQSxxQkFBcUI7QUFDckI7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQztBQUMzQztBQUNBLGdEQUFnRDtBQUNoRCxnREFBZ0Q7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlGQUFpRjtBQUNqRjtBQUNBO0FBQ0Esa0ZBQWtGO0FBQ2xGO0FBQ0EseUJBQXlCO0FBQ3pCLENBQUM7QUFDRCxDQUFDLEVBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly92dWUzLXdlYnBhY2s1Ly4vbm9kZV9tb2R1bGVzL2Nlc2l1bS9Tb3VyY2UvU2hhZGVycy9FbGxpcHNvaWRWUy5qcz8yNGU1Il0sInNvdXJjZXNDb250ZW50IjpbIi8vVGhpcyBmaWxlIGlzIGF1dG9tYXRpY2FsbHkgcmVidWlsdCBieSB0aGUgQ2VzaXVtIGJ1aWxkIHByb2Nlc3MuXG5leHBvcnQgZGVmYXVsdCBcImF0dHJpYnV0ZSB2ZWMzIHBvc2l0aW9uO1xcblxcXG5cXG5cXFxudW5pZm9ybSB2ZWMzIHVfcmFkaWk7XFxuXFxcblxcblxcXG52YXJ5aW5nIHZlYzMgdl9wb3NpdGlvbkVDO1xcblxcXG5cXG5cXFxudm9pZCBtYWluKClcXG5cXFxue1xcblxcXG4gICAgLy8gSW4gdGhlIHZlcnRleCBkYXRhLCB0aGUgY3ViZSBnb2VzIGZyb20gKC0xLjAsIC0xLjAsIC0xLjApIHRvICgxLjAsIDEuMCwgMS4wKSBpbiBtb2RlbCBjb29yZGluYXRlcy5cXG5cXFxuICAgIC8vIFNjYWxlIHRvIGNvbnNpZGVyIHRoZSByYWRpaS4gIFdlIGNvdWxkIGFsc28gZG8gdGhpcyBvbmNlIG9uIHRoZSBDUFUgd2hlbiB1c2luZyB0aGUgQm94R2VvbWV0cnksXFxuXFxcbiAgICAvLyBidXQgZG9pbmcgaXQgaGVyZSBhbGxvd3MgdXMgdG8gY2hhbmdlIHRoZSByYWRpaSB3aXRob3V0IHJld3JpdGluZyB0aGUgdmVydGV4IGRhdGEsIGFuZFxcblxcXG4gICAgLy8gYWxsb3dzIGFsbCBlbGxpcHNvaWRzIHRvIHJldXNlIHRoZSBzYW1lIHZlcnRleCBkYXRhLlxcblxcXG4gICAgdmVjNCBwID0gdmVjNCh1X3JhZGlpICogcG9zaXRpb24sIDEuMCk7XFxuXFxcblxcblxcXG4gICAgdl9wb3NpdGlvbkVDID0gKGN6bV9tb2RlbFZpZXcgKiBwKS54eXo7ICAgICAvLyBwb3NpdGlvbiBpbiBleWUgY29vcmRpbmF0ZXNcXG5cXFxuICAgIGdsX1Bvc2l0aW9uID0gY3ptX21vZGVsVmlld1Byb2plY3Rpb24gKiBwOyAgLy8gcG9zaXRpb24gaW4gY2xpcCBjb29yZGluYXRlc1xcblxcXG5cXG5cXFxuICAgIC8vIFdpdGggbXVsdGktZnJ1c3R1bSwgd2hlbiB0aGUgZWxsaXBzb2lkIHByaW1pdGl2ZSBpcyBwb3NpdGlvbmVkIG9uIHRoZSBpbnRlcnNlY3Rpb24gb2YgdHdvIGZydXN0dW1zXFxuXFxcbiAgICAvLyBhbmQgY2xvc2UgdG8gdGVycmFpbiwgdGhlIHRlcnJhaW4gKHdyaXRlcyBkZXB0aCkgaW4gdGhlIGNsb3Nlc3QgZnJ1c3R1bSBjYW4gb3ZlcndyaXRlIHBhcnQgb2YgdGhlXFxuXFxcbiAgICAvLyBlbGxpcHNvaWQgKGRvZXMgbm90IHdyaXRlIGRlcHRoKSB0aGF0IHdhcyByZW5kZXJlZCBpbiB0aGUgZmFydGhlciBmcnVzdHVtLlxcblxcXG4gICAgLy9cXG5cXFxuICAgIC8vIEhlcmUsIHdlIGNsYW1wIHRoZSBkZXB0aCBpbiB0aGUgdmVydGV4IHNoYWRlciB0byBhdm9pZCBiZWluZyBvdmVyd3JpdHRlbjsgaG93ZXZlciwgdGhpcyBjcmVhdGVzXFxuXFxcbiAgICAvLyBhcnRpZmFjdHMgc2luY2Ugc29tZSBmcmFnbWVudHMgY2FuIGJlIGFscGhhIGJsZW5kZWQgdHdpY2UuICBUaGlzIGlzIHNvbHZlZCBieSBvbmx5IHJlbmRlcmluZ1xcblxcXG4gICAgLy8gdGhlIGVsbGlwc29pZCBpbiB0aGUgY2xvc2VzdCBmcnVzdHVtIHRvIHRoZSB2aWV3ZXIuXFxuXFxcbiAgICBnbF9Qb3NpdGlvbi56ID0gY2xhbXAoZ2xfUG9zaXRpb24ueiwgY3ptX2RlcHRoUmFuZ2UubmVhciwgY3ptX2RlcHRoUmFuZ2UuZmFyKTtcXG5cXFxuXFxuXFxcbiAgICBjem1fdmVydGV4TG9nRGVwdGgoKTtcXG5cXFxufVxcblxcXG5cIjtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///26440\n')},61333:function(__unused_webpack___webpack_module__,__webpack_exports__){eval("/**\n * @license\n * Copyright (c) 2014-2015, NVIDIA CORPORATION. All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n *  * Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer.\n *  * Redistributions in binary form must reproduce the above copyright\n *    notice, this list of conditions and the following disclaimer in the\n *    documentation and/or other materials provided with the distribution.\n *  * Neither the name of NVIDIA CORPORATION nor the names of its\n *    contributors may be used to endorse or promote products derived\n *    from this software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS ``AS IS'' AND ANY\n * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR\n * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR\n * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,\n * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY\n * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n//This file is automatically rebuilt by the Cesium build process.\n/* harmony default export */ __webpack_exports__[\"Z\"] = (\"/**\\n\\\n * @license\\n\\\n * Copyright (c) 2014-2015, NVIDIA CORPORATION. All rights reserved.\\n\\\n *\\n\\\n * Redistribution and use in source and binary forms, with or without\\n\\\n * modification, are permitted provided that the following conditions\\n\\\n * are met:\\n\\\n *  * Redistributions of source code must retain the above copyright\\n\\\n *    notice, this list of conditions and the following disclaimer.\\n\\\n *  * Redistributions in binary form must reproduce the above copyright\\n\\\n *    notice, this list of conditions and the following disclaimer in the\\n\\\n *    documentation and/or other materials provided with the distribution.\\n\\\n *  * Neither the name of NVIDIA CORPORATION nor the names of its\\n\\\n *    contributors may be used to endorse or promote products derived\\n\\\n *    from this software without specific prior written permission.\\n\\\n *\\n\\\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS ``AS IS'' AND ANY\\n\\\n * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\\n\\\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR\\n\\\n * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR\\n\\\n * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,\\n\\\n * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\\n\\\n * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\\n\\\n * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY\\n\\\n * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\\n\\\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\\n\\\n * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\\n\\\n */\\n\\\n\\n\\\n// NVIDIA GameWorks Graphics Samples GitHub link: https://github.com/NVIDIAGameWorks/GraphicsSamples\\n\\\n// Original FXAA 3.11 shader link: https://github.com/NVIDIAGameWorks/GraphicsSamples/blob/master/samples/es3-kepler/FXAA/FXAA3_11.h\\n\\\n\\n\\\n// Steps used to integrate into Cesium:\\n\\\n// * The following defines are set:\\n\\\n//       #define FXAA_PC 1\\n\\\n//       #define FXAA_WEBGL_1 1\\n\\\n//       #define FXAA_GREEN_AS_LUMA 1\\n\\\n//       #define FXAA_EARLY_EXIT 1\\n\\\n//       #define FXAA_GLSL_120 1\\n\\\n// * All other preprocessor directives besides the FXAA_QUALITY__P* directives were removed.\\n\\\n// * Double underscores are invalid for preprocessor directives so replace them with a single underscore. Replace\\n\\\n//   /FXAA_QUALITY__P(.*)/g with /FXAA_QUALITY__P$1/.\\n\\\n// * There are no implicit conversions from ivec* to vec* so replace:\\n\\\n//       #define FxaaInt2 ivec2\\n\\\n//           with\\n\\\n//       #define FxaaInt2 vec2\\n\\\n// * The texture2DLod function is only available in vertex shaders so replace:\\n\\\n//       #define FxaaTexTop(t, p) texture2DLod(t, p, 0.0)\\n\\\n//       #define FxaaTexOff(t, p, o, r) texture2DLod(t, p + (o * r), 0.0)\\n\\\n//           with\\n\\\n//       #define FxaaTexTop(t, p) texture2D(t, p)\\n\\\n//       #define FxaaTexOff(t, p, o, r) texture2D(t, p + (o * r))\\n\\\n// * FXAA_QUALITY_PRESET is prepended in the javascript code. We may want to expose that setting in the future.\\n\\\n// * The following parameters to FxaaPixelShader are unused and can be removed:\\n\\\n//       fxaaConsolePosPos\\n\\\n//       fxaaConsoleRcpFrameOpt\\n\\\n//       fxaaConsoleRcpFrameOpt2\\n\\\n//       fxaaConsole360RcpFrameOpt2\\n\\\n//       fxaaConsoleEdgeSharpness\\n\\\n//       fxaaConsoleEdgeThreshold\\n\\\n//       fxaaConsoleEdgeThresholdMi\\n\\\n//       fxaaConsole360ConstDir\\n\\\n\\n\\\n//\\n\\\n// Choose the quality preset.\\n\\\n// This needs to be compiled into the shader as it effects code.\\n\\\n// Best option to include multiple presets is to\\n\\\n// in each shader define the preset, then include this file.\\n\\\n//\\n\\\n// OPTIONS\\n\\\n// -----------------------------------------------------------------------\\n\\\n// 10 to 15 - default medium dither (10=fastest, 15=highest quality)\\n\\\n// 20 to 29 - less dither, more expensive (20=fastest, 29=highest quality)\\n\\\n// 39       - no dither, very expensive\\n\\\n//\\n\\\n// NOTES\\n\\\n// -----------------------------------------------------------------------\\n\\\n// 12 = slightly faster then FXAA 3.9 and higher edge quality (default)\\n\\\n// 13 = about same speed as FXAA 3.9 and better than 12\\n\\\n// 23 = closest to FXAA 3.9 visually and performance wise\\n\\\n//  _ = the lowest digit is directly related to performance\\n\\\n// _  = the highest digit is directly related to style\\n\\\n//\\n\\\n//#define FXAA_QUALITY_PRESET 12\\n\\\n\\n\\\n\\n\\\n#if (FXAA_QUALITY_PRESET == 10)\\n\\\n    #define FXAA_QUALITY_PS 3\\n\\\n    #define FXAA_QUALITY_P0 1.5\\n\\\n    #define FXAA_QUALITY_P1 3.0\\n\\\n    #define FXAA_QUALITY_P2 12.0\\n\\\n#endif\\n\\\n#if (FXAA_QUALITY_PRESET == 11)\\n\\\n    #define FXAA_QUALITY_PS 4\\n\\\n    #define FXAA_QUALITY_P0 1.0\\n\\\n    #define FXAA_QUALITY_P1 1.5\\n\\\n    #define FXAA_QUALITY_P2 3.0\\n\\\n    #define FXAA_QUALITY_P3 12.0\\n\\\n#endif\\n\\\n#if (FXAA_QUALITY_PRESET == 12)\\n\\\n    #define FXAA_QUALITY_PS 5\\n\\\n    #define FXAA_QUALITY_P0 1.0\\n\\\n    #define FXAA_QUALITY_P1 1.5\\n\\\n    #define FXAA_QUALITY_P2 2.0\\n\\\n    #define FXAA_QUALITY_P3 4.0\\n\\\n    #define FXAA_QUALITY_P4 12.0\\n\\\n#endif\\n\\\n#if (FXAA_QUALITY_PRESET == 13)\\n\\\n    #define FXAA_QUALITY_PS 6\\n\\\n    #define FXAA_QUALITY_P0 1.0\\n\\\n    #define FXAA_QUALITY_P1 1.5\\n\\\n    #define FXAA_QUALITY_P2 2.0\\n\\\n    #define FXAA_QUALITY_P3 2.0\\n\\\n    #define FXAA_QUALITY_P4 4.0\\n\\\n    #define FXAA_QUALITY_P5 12.0\\n\\\n#endif\\n\\\n#if (FXAA_QUALITY_PRESET == 14)\\n\\\n    #define FXAA_QUALITY_PS 7\\n\\\n    #define FXAA_QUALITY_P0 1.0\\n\\\n    #define FXAA_QUALITY_P1 1.5\\n\\\n    #define FXAA_QUALITY_P2 2.0\\n\\\n    #define FXAA_QUALITY_P3 2.0\\n\\\n    #define FXAA_QUALITY_P4 2.0\\n\\\n    #define FXAA_QUALITY_P5 4.0\\n\\\n    #define FXAA_QUALITY_P6 12.0\\n\\\n#endif\\n\\\n#if (FXAA_QUALITY_PRESET == 15)\\n\\\n    #define FXAA_QUALITY_PS 8\\n\\\n    #define FXAA_QUALITY_P0 1.0\\n\\\n    #define FXAA_QUALITY_P1 1.5\\n\\\n    #define FXAA_QUALITY_P2 2.0\\n\\\n    #define FXAA_QUALITY_P3 2.0\\n\\\n    #define FXAA_QUALITY_P4 2.0\\n\\\n    #define FXAA_QUALITY_P5 2.0\\n\\\n    #define FXAA_QUALITY_P6 4.0\\n\\\n    #define FXAA_QUALITY_P7 12.0\\n\\\n#endif\\n\\\n#if (FXAA_QUALITY_PRESET == 20)\\n\\\n    #define FXAA_QUALITY_PS 3\\n\\\n    #define FXAA_QUALITY_P0 1.5\\n\\\n    #define FXAA_QUALITY_P1 2.0\\n\\\n    #define FXAA_QUALITY_P2 8.0\\n\\\n#endif\\n\\\n#if (FXAA_QUALITY_PRESET == 21)\\n\\\n    #define FXAA_QUALITY_PS 4\\n\\\n    #define FXAA_QUALITY_P0 1.0\\n\\\n    #define FXAA_QUALITY_P1 1.5\\n\\\n    #define FXAA_QUALITY_P2 2.0\\n\\\n    #define FXAA_QUALITY_P3 8.0\\n\\\n#endif\\n\\\n#if (FXAA_QUALITY_PRESET == 22)\\n\\\n    #define FXAA_QUALITY_PS 5\\n\\\n    #define FXAA_QUALITY_P0 1.0\\n\\\n    #define FXAA_QUALITY_P1 1.5\\n\\\n    #define FXAA_QUALITY_P2 2.0\\n\\\n    #define FXAA_QUALITY_P3 2.0\\n\\\n    #define FXAA_QUALITY_P4 8.0\\n\\\n#endif\\n\\\n#if (FXAA_QUALITY_PRESET == 23)\\n\\\n    #define FXAA_QUALITY_PS 6\\n\\\n    #define FXAA_QUALITY_P0 1.0\\n\\\n    #define FXAA_QUALITY_P1 1.5\\n\\\n    #define FXAA_QUALITY_P2 2.0\\n\\\n    #define FXAA_QUALITY_P3 2.0\\n\\\n    #define FXAA_QUALITY_P4 2.0\\n\\\n    #define FXAA_QUALITY_P5 8.0\\n\\\n#endif\\n\\\n#if (FXAA_QUALITY_PRESET == 24)\\n\\\n    #define FXAA_QUALITY_PS 7\\n\\\n    #define FXAA_QUALITY_P0 1.0\\n\\\n    #define FXAA_QUALITY_P1 1.5\\n\\\n    #define FXAA_QUALITY_P2 2.0\\n\\\n    #define FXAA_QUALITY_P3 2.0\\n\\\n    #define FXAA_QUALITY_P4 2.0\\n\\\n    #define FXAA_QUALITY_P5 3.0\\n\\\n    #define FXAA_QUALITY_P6 8.0\\n\\\n#endif\\n\\\n#if (FXAA_QUALITY_PRESET == 25)\\n\\\n    #define FXAA_QUALITY_PS 8\\n\\\n    #define FXAA_QUALITY_P0 1.0\\n\\\n    #define FXAA_QUALITY_P1 1.5\\n\\\n    #define FXAA_QUALITY_P2 2.0\\n\\\n    #define FXAA_QUALITY_P3 2.0\\n\\\n    #define FXAA_QUALITY_P4 2.0\\n\\\n    #define FXAA_QUALITY_P5 2.0\\n\\\n    #define FXAA_QUALITY_P6 4.0\\n\\\n    #define FXAA_QUALITY_P7 8.0\\n\\\n#endif\\n\\\n#if (FXAA_QUALITY_PRESET == 26)\\n\\\n    #define FXAA_QUALITY_PS 9\\n\\\n    #define FXAA_QUALITY_P0 1.0\\n\\\n    #define FXAA_QUALITY_P1 1.5\\n\\\n    #define FXAA_QUALITY_P2 2.0\\n\\\n    #define FXAA_QUALITY_P3 2.0\\n\\\n    #define FXAA_QUALITY_P4 2.0\\n\\\n    #define FXAA_QUALITY_P5 2.0\\n\\\n    #define FXAA_QUALITY_P6 2.0\\n\\\n    #define FXAA_QUALITY_P7 4.0\\n\\\n    #define FXAA_QUALITY_P8 8.0\\n\\\n#endif\\n\\\n#if (FXAA_QUALITY_PRESET == 27)\\n\\\n    #define FXAA_QUALITY_PS 10\\n\\\n    #define FXAA_QUALITY_P0 1.0\\n\\\n    #define FXAA_QUALITY_P1 1.5\\n\\\n    #define FXAA_QUALITY_P2 2.0\\n\\\n    #define FXAA_QUALITY_P3 2.0\\n\\\n    #define FXAA_QUALITY_P4 2.0\\n\\\n    #define FXAA_QUALITY_P5 2.0\\n\\\n    #define FXAA_QUALITY_P6 2.0\\n\\\n    #define FXAA_QUALITY_P7 2.0\\n\\\n    #define FXAA_QUALITY_P8 4.0\\n\\\n    #define FXAA_QUALITY_P9 8.0\\n\\\n#endif\\n\\\n#if (FXAA_QUALITY_PRESET == 28)\\n\\\n    #define FXAA_QUALITY_PS 11\\n\\\n    #define FXAA_QUALITY_P0 1.0\\n\\\n    #define FXAA_QUALITY_P1 1.5\\n\\\n    #define FXAA_QUALITY_P2 2.0\\n\\\n    #define FXAA_QUALITY_P3 2.0\\n\\\n    #define FXAA_QUALITY_P4 2.0\\n\\\n    #define FXAA_QUALITY_P5 2.0\\n\\\n    #define FXAA_QUALITY_P6 2.0\\n\\\n    #define FXAA_QUALITY_P7 2.0\\n\\\n    #define FXAA_QUALITY_P8 2.0\\n\\\n    #define FXAA_QUALITY_P9 4.0\\n\\\n    #define FXAA_QUALITY_P10 8.0\\n\\\n#endif\\n\\\n#if (FXAA_QUALITY_PRESET == 29)\\n\\\n    #define FXAA_QUALITY_PS 12\\n\\\n    #define FXAA_QUALITY_P0 1.0\\n\\\n    #define FXAA_QUALITY_P1 1.5\\n\\\n    #define FXAA_QUALITY_P2 2.0\\n\\\n    #define FXAA_QUALITY_P3 2.0\\n\\\n    #define FXAA_QUALITY_P4 2.0\\n\\\n    #define FXAA_QUALITY_P5 2.0\\n\\\n    #define FXAA_QUALITY_P6 2.0\\n\\\n    #define FXAA_QUALITY_P7 2.0\\n\\\n    #define FXAA_QUALITY_P8 2.0\\n\\\n    #define FXAA_QUALITY_P9 2.0\\n\\\n    #define FXAA_QUALITY_P10 4.0\\n\\\n    #define FXAA_QUALITY_P11 8.0\\n\\\n#endif\\n\\\n#if (FXAA_QUALITY_PRESET == 39)\\n\\\n    #define FXAA_QUALITY_PS 12\\n\\\n    #define FXAA_QUALITY_P0 1.0\\n\\\n    #define FXAA_QUALITY_P1 1.0\\n\\\n    #define FXAA_QUALITY_P2 1.0\\n\\\n    #define FXAA_QUALITY_P3 1.0\\n\\\n    #define FXAA_QUALITY_P4 1.0\\n\\\n    #define FXAA_QUALITY_P5 1.5\\n\\\n    #define FXAA_QUALITY_P6 2.0\\n\\\n    #define FXAA_QUALITY_P7 2.0\\n\\\n    #define FXAA_QUALITY_P8 2.0\\n\\\n    #define FXAA_QUALITY_P9 2.0\\n\\\n    #define FXAA_QUALITY_P10 4.0\\n\\\n    #define FXAA_QUALITY_P11 8.0\\n\\\n#endif\\n\\\n\\n\\\n#define FxaaBool bool\\n\\\n#define FxaaFloat float\\n\\\n#define FxaaFloat2 vec2\\n\\\n#define FxaaFloat3 vec3\\n\\\n#define FxaaFloat4 vec4\\n\\\n#define FxaaHalf float\\n\\\n#define FxaaHalf2 vec2\\n\\\n#define FxaaHalf3 vec3\\n\\\n#define FxaaHalf4 vec4\\n\\\n#define FxaaInt2 vec2\\n\\\n#define FxaaTex sampler2D\\n\\\n\\n\\\n#define FxaaSat(x) clamp(x, 0.0, 1.0)\\n\\\n#define FxaaTexTop(t, p) texture2D(t, p)\\n\\\n#define FxaaTexOff(t, p, o, r) texture2D(t, p + (o * r))\\n\\\n\\n\\\nFxaaFloat FxaaLuma(FxaaFloat4 rgba) { return rgba.y; }\\n\\\n\\n\\\nFxaaFloat4 FxaaPixelShader(\\n\\\n    //\\n\\\n    // Use noperspective interpolation here (turn off perspective interpolation).\\n\\\n    // {xy} = center of pixel\\n\\\n    FxaaFloat2 pos,\\n\\\n    //\\n\\\n    // Input color texture.\\n\\\n    // {rgb_} = color in linear or perceptual color space\\n\\\n    // if (FXAA_GREEN_AS_LUMA == 0)\\n\\\n    //     {___a} = luma in perceptual color space (not linear)\\n\\\n    FxaaTex tex,\\n\\\n    //\\n\\\n    // Only used on FXAA Quality.\\n\\\n    // This must be from a constant/uniform.\\n\\\n    // {x_} = 1.0/screenWidthInPixels\\n\\\n    // {_y} = 1.0/screenHeightInPixels\\n\\\n    FxaaFloat2 fxaaQualityRcpFrame,\\n\\\n    //\\n\\\n    // Only used on FXAA Quality.\\n\\\n    // This used to be the FXAA_QUALITY_SUBPIX define.\\n\\\n    // It is here now to allow easier tuning.\\n\\\n    // Choose the amount of sub-pixel aliasing removal.\\n\\\n    // This can effect sharpness.\\n\\\n    //   1.00 - upper limit (softer)\\n\\\n    //   0.75 - default amount of filtering\\n\\\n    //   0.50 - lower limit (sharper, less sub-pixel aliasing removal)\\n\\\n    //   0.25 - almost off\\n\\\n    //   0.00 - completely off\\n\\\n    FxaaFloat fxaaQualitySubpix,\\n\\\n    //\\n\\\n    // Only used on FXAA Quality.\\n\\\n    // This used to be the FXAA_QUALITY_EDGE_THRESHOLD define.\\n\\\n    // It is here now to allow easier tuning.\\n\\\n    // The minimum amount of local contrast required to apply algorithm.\\n\\\n    //   0.333 - too little (faster)\\n\\\n    //   0.250 - low quality\\n\\\n    //   0.166 - default\\n\\\n    //   0.125 - high quality\\n\\\n    //   0.063 - overkill (slower)\\n\\\n    FxaaFloat fxaaQualityEdgeThreshold,\\n\\\n    //\\n\\\n    // Only used on FXAA Quality.\\n\\\n    // This used to be the FXAA_QUALITY_EDGE_THRESHOLD_MIN define.\\n\\\n    // It is here now to allow easier tuning.\\n\\\n    // Trims the algorithm from processing darks.\\n\\\n    //   0.0833 - upper limit (default, the start of visible unfiltered edges)\\n\\\n    //   0.0625 - high quality (faster)\\n\\\n    //   0.0312 - visible limit (slower)\\n\\\n    // Special notes when using FXAA_GREEN_AS_LUMA,\\n\\\n    //   Likely want to set this to zero.\\n\\\n    //   As colors that are mostly not-green\\n\\\n    //   will appear very dark in the green channel!\\n\\\n    //   Tune by looking at mostly non-green content,\\n\\\n    //   then start at zero and increase until aliasing is a problem.\\n\\\n    FxaaFloat fxaaQualityEdgeThresholdMin\\n\\\n) {\\n\\\n/*--------------------------------------------------------------------------*/\\n\\\n    FxaaFloat2 posM;\\n\\\n    posM.x = pos.x;\\n\\\n    posM.y = pos.y;\\n\\\n    FxaaFloat4 rgbyM = FxaaTexTop(tex, posM);\\n\\\n    #define lumaM rgbyM.y\\n\\\n    FxaaFloat lumaS = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2( 0, 1), fxaaQualityRcpFrame.xy));\\n\\\n    FxaaFloat lumaE = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2( 1, 0), fxaaQualityRcpFrame.xy));\\n\\\n    FxaaFloat lumaN = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2( 0,-1), fxaaQualityRcpFrame.xy));\\n\\\n    FxaaFloat lumaW = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2(-1, 0), fxaaQualityRcpFrame.xy));\\n\\\n/*--------------------------------------------------------------------------*/\\n\\\n    FxaaFloat maxSM = max(lumaS, lumaM);\\n\\\n    FxaaFloat minSM = min(lumaS, lumaM);\\n\\\n    FxaaFloat maxESM = max(lumaE, maxSM);\\n\\\n    FxaaFloat minESM = min(lumaE, minSM);\\n\\\n    FxaaFloat maxWN = max(lumaN, lumaW);\\n\\\n    FxaaFloat minWN = min(lumaN, lumaW);\\n\\\n    FxaaFloat rangeMax = max(maxWN, maxESM);\\n\\\n    FxaaFloat rangeMin = min(minWN, minESM);\\n\\\n    FxaaFloat rangeMaxScaled = rangeMax * fxaaQualityEdgeThreshold;\\n\\\n    FxaaFloat range = rangeMax - rangeMin;\\n\\\n    FxaaFloat rangeMaxClamped = max(fxaaQualityEdgeThresholdMin, rangeMaxScaled);\\n\\\n    FxaaBool earlyExit = range < rangeMaxClamped;\\n\\\n/*--------------------------------------------------------------------------*/\\n\\\n    if(earlyExit)\\n\\\n        return rgbyM;\\n\\\n/*--------------------------------------------------------------------------*/\\n\\\n    FxaaFloat lumaNW = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2(-1,-1), fxaaQualityRcpFrame.xy));\\n\\\n    FxaaFloat lumaSE = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2( 1, 1), fxaaQualityRcpFrame.xy));\\n\\\n    FxaaFloat lumaNE = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2( 1,-1), fxaaQualityRcpFrame.xy));\\n\\\n    FxaaFloat lumaSW = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2(-1, 1), fxaaQualityRcpFrame.xy));\\n\\\n/*--------------------------------------------------------------------------*/\\n\\\n    FxaaFloat lumaNS = lumaN + lumaS;\\n\\\n    FxaaFloat lumaWE = lumaW + lumaE;\\n\\\n    FxaaFloat subpixRcpRange = 1.0/range;\\n\\\n    FxaaFloat subpixNSWE = lumaNS + lumaWE;\\n\\\n    FxaaFloat edgeHorz1 = (-2.0 * lumaM) + lumaNS;\\n\\\n    FxaaFloat edgeVert1 = (-2.0 * lumaM) + lumaWE;\\n\\\n/*--------------------------------------------------------------------------*/\\n\\\n    FxaaFloat lumaNESE = lumaNE + lumaSE;\\n\\\n    FxaaFloat lumaNWNE = lumaNW + lumaNE;\\n\\\n    FxaaFloat edgeHorz2 = (-2.0 * lumaE) + lumaNESE;\\n\\\n    FxaaFloat edgeVert2 = (-2.0 * lumaN) + lumaNWNE;\\n\\\n/*--------------------------------------------------------------------------*/\\n\\\n    FxaaFloat lumaNWSW = lumaNW + lumaSW;\\n\\\n    FxaaFloat lumaSWSE = lumaSW + lumaSE;\\n\\\n    FxaaFloat edgeHorz4 = (abs(edgeHorz1) * 2.0) + abs(edgeHorz2);\\n\\\n    FxaaFloat edgeVert4 = (abs(edgeVert1) * 2.0) + abs(edgeVert2);\\n\\\n    FxaaFloat edgeHorz3 = (-2.0 * lumaW) + lumaNWSW;\\n\\\n    FxaaFloat edgeVert3 = (-2.0 * lumaS) + lumaSWSE;\\n\\\n    FxaaFloat edgeHorz = abs(edgeHorz3) + edgeHorz4;\\n\\\n    FxaaFloat edgeVert = abs(edgeVert3) + edgeVert4;\\n\\\n/*--------------------------------------------------------------------------*/\\n\\\n    FxaaFloat subpixNWSWNESE = lumaNWSW + lumaNESE;\\n\\\n    FxaaFloat lengthSign = fxaaQualityRcpFrame.x;\\n\\\n    FxaaBool horzSpan = edgeHorz >= edgeVert;\\n\\\n    FxaaFloat subpixA = subpixNSWE * 2.0 + subpixNWSWNESE;\\n\\\n/*--------------------------------------------------------------------------*/\\n\\\n    if(!horzSpan) lumaN = lumaW;\\n\\\n    if(!horzSpan) lumaS = lumaE;\\n\\\n    if(horzSpan) lengthSign = fxaaQualityRcpFrame.y;\\n\\\n    FxaaFloat subpixB = (subpixA * (1.0/12.0)) - lumaM;\\n\\\n/*--------------------------------------------------------------------------*/\\n\\\n    FxaaFloat gradientN = lumaN - lumaM;\\n\\\n    FxaaFloat gradientS = lumaS - lumaM;\\n\\\n    FxaaFloat lumaNN = lumaN + lumaM;\\n\\\n    FxaaFloat lumaSS = lumaS + lumaM;\\n\\\n    FxaaBool pairN = abs(gradientN) >= abs(gradientS);\\n\\\n    FxaaFloat gradient = max(abs(gradientN), abs(gradientS));\\n\\\n    if(pairN) lengthSign = -lengthSign;\\n\\\n    FxaaFloat subpixC = FxaaSat(abs(subpixB) * subpixRcpRange);\\n\\\n/*--------------------------------------------------------------------------*/\\n\\\n    FxaaFloat2 posB;\\n\\\n    posB.x = posM.x;\\n\\\n    posB.y = posM.y;\\n\\\n    FxaaFloat2 offNP;\\n\\\n    offNP.x = (!horzSpan) ? 0.0 : fxaaQualityRcpFrame.x;\\n\\\n    offNP.y = ( horzSpan) ? 0.0 : fxaaQualityRcpFrame.y;\\n\\\n    if(!horzSpan) posB.x += lengthSign * 0.5;\\n\\\n    if( horzSpan) posB.y += lengthSign * 0.5;\\n\\\n/*--------------------------------------------------------------------------*/\\n\\\n    FxaaFloat2 posN;\\n\\\n    posN.x = posB.x - offNP.x * FXAA_QUALITY_P0;\\n\\\n    posN.y = posB.y - offNP.y * FXAA_QUALITY_P0;\\n\\\n    FxaaFloat2 posP;\\n\\\n    posP.x = posB.x + offNP.x * FXAA_QUALITY_P0;\\n\\\n    posP.y = posB.y + offNP.y * FXAA_QUALITY_P0;\\n\\\n    FxaaFloat subpixD = ((-2.0)*subpixC) + 3.0;\\n\\\n    FxaaFloat lumaEndN = FxaaLuma(FxaaTexTop(tex, posN));\\n\\\n    FxaaFloat subpixE = subpixC * subpixC;\\n\\\n    FxaaFloat lumaEndP = FxaaLuma(FxaaTexTop(tex, posP));\\n\\\n/*--------------------------------------------------------------------------*/\\n\\\n    if(!pairN) lumaNN = lumaSS;\\n\\\n    FxaaFloat gradientScaled = gradient * 1.0/4.0;\\n\\\n    FxaaFloat lumaMM = lumaM - lumaNN * 0.5;\\n\\\n    FxaaFloat subpixF = subpixD * subpixE;\\n\\\n    FxaaBool lumaMLTZero = lumaMM < 0.0;\\n\\\n/*--------------------------------------------------------------------------*/\\n\\\n    lumaEndN -= lumaNN * 0.5;\\n\\\n    lumaEndP -= lumaNN * 0.5;\\n\\\n    FxaaBool doneN = abs(lumaEndN) >= gradientScaled;\\n\\\n    FxaaBool doneP = abs(lumaEndP) >= gradientScaled;\\n\\\n    if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P1;\\n\\\n    if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P1;\\n\\\n    FxaaBool doneNP = (!doneN) || (!doneP);\\n\\\n    if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P1;\\n\\\n    if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P1;\\n\\\n/*--------------------------------------------------------------------------*/\\n\\\n    if(doneNP) {\\n\\\n        if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));\\n\\\n        if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));\\n\\\n        if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;\\n\\\n        if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;\\n\\\n        doneN = abs(lumaEndN) >= gradientScaled;\\n\\\n        doneP = abs(lumaEndP) >= gradientScaled;\\n\\\n        if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P2;\\n\\\n        if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P2;\\n\\\n        doneNP = (!doneN) || (!doneP);\\n\\\n        if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P2;\\n\\\n        if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P2;\\n\\\n/*--------------------------------------------------------------------------*/\\n\\\n        #if (FXAA_QUALITY_PS > 3)\\n\\\n        if(doneNP) {\\n\\\n            if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));\\n\\\n            if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));\\n\\\n            if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;\\n\\\n            if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;\\n\\\n            doneN = abs(lumaEndN) >= gradientScaled;\\n\\\n            doneP = abs(lumaEndP) >= gradientScaled;\\n\\\n            if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P3;\\n\\\n            if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P3;\\n\\\n            doneNP = (!doneN) || (!doneP);\\n\\\n            if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P3;\\n\\\n            if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P3;\\n\\\n/*--------------------------------------------------------------------------*/\\n\\\n            #if (FXAA_QUALITY_PS > 4)\\n\\\n            if(doneNP) {\\n\\\n                if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));\\n\\\n                if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));\\n\\\n                if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;\\n\\\n                if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;\\n\\\n                doneN = abs(lumaEndN) >= gradientScaled;\\n\\\n                doneP = abs(lumaEndP) >= gradientScaled;\\n\\\n                if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P4;\\n\\\n                if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P4;\\n\\\n                doneNP = (!doneN) || (!doneP);\\n\\\n                if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P4;\\n\\\n                if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P4;\\n\\\n/*--------------------------------------------------------------------------*/\\n\\\n                #if (FXAA_QUALITY_PS > 5)\\n\\\n                if(doneNP) {\\n\\\n                    if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));\\n\\\n                    if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));\\n\\\n                    if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;\\n\\\n                    if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;\\n\\\n                    doneN = abs(lumaEndN) >= gradientScaled;\\n\\\n                    doneP = abs(lumaEndP) >= gradientScaled;\\n\\\n                    if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P5;\\n\\\n                    if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P5;\\n\\\n                    doneNP = (!doneN) || (!doneP);\\n\\\n                    if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P5;\\n\\\n                    if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P5;\\n\\\n/*--------------------------------------------------------------------------*/\\n\\\n                    #if (FXAA_QUALITY_PS > 6)\\n\\\n                    if(doneNP) {\\n\\\n                        if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));\\n\\\n                        if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));\\n\\\n                        if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;\\n\\\n                        if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;\\n\\\n                        doneN = abs(lumaEndN) >= gradientScaled;\\n\\\n                        doneP = abs(lumaEndP) >= gradientScaled;\\n\\\n                        if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P6;\\n\\\n                        if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P6;\\n\\\n                        doneNP = (!doneN) || (!doneP);\\n\\\n                        if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P6;\\n\\\n                        if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P6;\\n\\\n/*--------------------------------------------------------------------------*/\\n\\\n                        #if (FXAA_QUALITY_PS > 7)\\n\\\n                        if(doneNP) {\\n\\\n                            if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));\\n\\\n                            if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));\\n\\\n                            if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;\\n\\\n                            if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;\\n\\\n                            doneN = abs(lumaEndN) >= gradientScaled;\\n\\\n                            doneP = abs(lumaEndP) >= gradientScaled;\\n\\\n                            if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P7;\\n\\\n                            if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P7;\\n\\\n                            doneNP = (!doneN) || (!doneP);\\n\\\n                            if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P7;\\n\\\n                            if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P7;\\n\\\n/*--------------------------------------------------------------------------*/\\n\\\n    #if (FXAA_QUALITY_PS > 8)\\n\\\n    if(doneNP) {\\n\\\n        if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));\\n\\\n        if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));\\n\\\n        if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;\\n\\\n        if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;\\n\\\n        doneN = abs(lumaEndN) >= gradientScaled;\\n\\\n        doneP = abs(lumaEndP) >= gradientScaled;\\n\\\n        if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P8;\\n\\\n        if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P8;\\n\\\n        doneNP = (!doneN) || (!doneP);\\n\\\n        if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P8;\\n\\\n        if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P8;\\n\\\n/*--------------------------------------------------------------------------*/\\n\\\n        #if (FXAA_QUALITY_PS > 9)\\n\\\n        if(doneNP) {\\n\\\n            if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));\\n\\\n            if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));\\n\\\n            if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;\\n\\\n            if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;\\n\\\n            doneN = abs(lumaEndN) >= gradientScaled;\\n\\\n            doneP = abs(lumaEndP) >= gradientScaled;\\n\\\n            if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P9;\\n\\\n            if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P9;\\n\\\n            doneNP = (!doneN) || (!doneP);\\n\\\n            if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P9;\\n\\\n            if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P9;\\n\\\n/*--------------------------------------------------------------------------*/\\n\\\n            #if (FXAA_QUALITY_PS > 10)\\n\\\n            if(doneNP) {\\n\\\n                if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));\\n\\\n                if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));\\n\\\n                if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;\\n\\\n                if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;\\n\\\n                doneN = abs(lumaEndN) >= gradientScaled;\\n\\\n                doneP = abs(lumaEndP) >= gradientScaled;\\n\\\n                if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P10;\\n\\\n                if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P10;\\n\\\n                doneNP = (!doneN) || (!doneP);\\n\\\n                if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P10;\\n\\\n                if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P10;\\n\\\n/*--------------------------------------------------------------------------*/\\n\\\n                #if (FXAA_QUALITY_PS > 11)\\n\\\n                if(doneNP) {\\n\\\n                    if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));\\n\\\n                    if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));\\n\\\n                    if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;\\n\\\n                    if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;\\n\\\n                    doneN = abs(lumaEndN) >= gradientScaled;\\n\\\n                    doneP = abs(lumaEndP) >= gradientScaled;\\n\\\n                    if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P11;\\n\\\n                    if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P11;\\n\\\n                    doneNP = (!doneN) || (!doneP);\\n\\\n                    if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P11;\\n\\\n                    if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P11;\\n\\\n/*--------------------------------------------------------------------------*/\\n\\\n                    #if (FXAA_QUALITY_PS > 12)\\n\\\n                    if(doneNP) {\\n\\\n                        if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));\\n\\\n                        if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));\\n\\\n                        if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;\\n\\\n                        if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;\\n\\\n                        doneN = abs(lumaEndN) >= gradientScaled;\\n\\\n                        doneP = abs(lumaEndP) >= gradientScaled;\\n\\\n                        if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P12;\\n\\\n                        if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P12;\\n\\\n                        doneNP = (!doneN) || (!doneP);\\n\\\n                        if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P12;\\n\\\n                        if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P12;\\n\\\n/*--------------------------------------------------------------------------*/\\n\\\n                    }\\n\\\n                    #endif\\n\\\n/*--------------------------------------------------------------------------*/\\n\\\n                }\\n\\\n                #endif\\n\\\n/*--------------------------------------------------------------------------*/\\n\\\n            }\\n\\\n            #endif\\n\\\n/*--------------------------------------------------------------------------*/\\n\\\n        }\\n\\\n        #endif\\n\\\n/*--------------------------------------------------------------------------*/\\n\\\n    }\\n\\\n    #endif\\n\\\n/*--------------------------------------------------------------------------*/\\n\\\n                        }\\n\\\n                        #endif\\n\\\n/*--------------------------------------------------------------------------*/\\n\\\n                    }\\n\\\n                    #endif\\n\\\n/*--------------------------------------------------------------------------*/\\n\\\n                }\\n\\\n                #endif\\n\\\n/*--------------------------------------------------------------------------*/\\n\\\n            }\\n\\\n            #endif\\n\\\n/*--------------------------------------------------------------------------*/\\n\\\n        }\\n\\\n        #endif\\n\\\n/*--------------------------------------------------------------------------*/\\n\\\n    }\\n\\\n/*--------------------------------------------------------------------------*/\\n\\\n    FxaaFloat dstN = posM.x - posN.x;\\n\\\n    FxaaFloat dstP = posP.x - posM.x;\\n\\\n    if(!horzSpan) dstN = posM.y - posN.y;\\n\\\n    if(!horzSpan) dstP = posP.y - posM.y;\\n\\\n/*--------------------------------------------------------------------------*/\\n\\\n    FxaaBool goodSpanN = (lumaEndN < 0.0) != lumaMLTZero;\\n\\\n    FxaaFloat spanLength = (dstP + dstN);\\n\\\n    FxaaBool goodSpanP = (lumaEndP < 0.0) != lumaMLTZero;\\n\\\n    FxaaFloat spanLengthRcp = 1.0/spanLength;\\n\\\n/*--------------------------------------------------------------------------*/\\n\\\n    FxaaBool directionN = dstN < dstP;\\n\\\n    FxaaFloat dst = min(dstN, dstP);\\n\\\n    FxaaBool goodSpan = directionN ? goodSpanN : goodSpanP;\\n\\\n    FxaaFloat subpixG = subpixF * subpixF;\\n\\\n    FxaaFloat pixelOffset = (dst * (-spanLengthRcp)) + 0.5;\\n\\\n    FxaaFloat subpixH = subpixG * fxaaQualitySubpix;\\n\\\n/*--------------------------------------------------------------------------*/\\n\\\n    FxaaFloat pixelOffsetGood = goodSpan ? pixelOffset : 0.0;\\n\\\n    FxaaFloat pixelOffsetSubpix = max(pixelOffsetGood, subpixH);\\n\\\n    if(!horzSpan) posM.x += pixelOffsetSubpix * lengthSign;\\n\\\n    if( horzSpan) posM.y += pixelOffsetSubpix * lengthSign;\\n\\\n    return FxaaFloat4(FxaaTexTop(tex, posM).xyz, lumaM);\\n\\\n}\\n\\\n\");\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNjEzMzMuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0Q7QUFDaEQsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5REFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRDtBQUNoRCxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0MsZ0JBQWdCO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSxJQUFJO0FBQ1o7QUFDQTtBQUNBO0FBQ0EsUUFBUSxNQUFNO0FBQ2Q7QUFDQSxZQUFZLE1BQU07QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLElBQUk7QUFDWixRQUFRLElBQUk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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QyxvQ0FBb0M7QUFDcEMsMkRBQTJEO0FBQzNELDBDQUEwQztBQUMxQywyREFBMkQ7QUFDM0Qsb0RBQW9EO0FBQ3BEO0FBQ0EsNkRBQTZEO0FBQzdELGdFQUFnRTtBQUNoRSwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELHdEQUF3RDtBQUN4RCxDQUFDO0FBQ0QsQ0FBQyxFQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdnVlMy13ZWJwYWNrNS8uL25vZGVfbW9kdWxlcy9jZXNpdW0vU291cmNlL1NoYWRlcnMvRlhBQTNfMTEuanM/M2Q5YiJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTQtMjAxNSwgTlZJRElBIENPUlBPUkFUSU9OLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFJlZGlzdHJpYnV0aW9uIGFuZCB1c2UgaW4gc291cmNlIGFuZCBiaW5hcnkgZm9ybXMsIHdpdGggb3Igd2l0aG91dFxuICogbW9kaWZpY2F0aW9uLCBhcmUgcGVybWl0dGVkIHByb3ZpZGVkIHRoYXQgdGhlIGZvbGxvd2luZyBjb25kaXRpb25zXG4gKiBhcmUgbWV0OlxuICogICogUmVkaXN0cmlidXRpb25zIG9mIHNvdXJjZSBjb2RlIG11c3QgcmV0YWluIHRoZSBhYm92ZSBjb3B5cmlnaHRcbiAqICAgIG5vdGljZSwgdGhpcyBsaXN0IG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmcgZGlzY2xhaW1lci5cbiAqICAqIFJlZGlzdHJpYnV0aW9ucyBpbiBiaW5hcnkgZm9ybSBtdXN0IHJlcHJvZHVjZSB0aGUgYWJvdmUgY29weXJpZ2h0XG4gKiAgICBub3RpY2UsIHRoaXMgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nIGRpc2NsYWltZXIgaW4gdGhlXG4gKiAgICBkb2N1bWVudGF0aW9uIGFuZC9vciBvdGhlciBtYXRlcmlhbHMgcHJvdmlkZWQgd2l0aCB0aGUgZGlzdHJpYnV0aW9uLlxuICogICogTmVpdGhlciB0aGUgbmFtZSBvZiBOVklESUEgQ09SUE9SQVRJT04gbm9yIHRoZSBuYW1lcyBvZiBpdHNcbiAqICAgIGNvbnRyaWJ1dG9ycyBtYXkgYmUgdXNlZCB0byBlbmRvcnNlIG9yIHByb21vdGUgcHJvZHVjdHMgZGVyaXZlZFxuICogICAgZnJvbSB0aGlzIHNvZnR3YXJlIHdpdGhvdXQgc3BlY2lmaWMgcHJpb3Igd3JpdHRlbiBwZXJtaXNzaW9uLlxuICpcbiAqIFRISVMgU09GVFdBUkUgSVMgUFJPVklERUQgQlkgVEhFIENPUFlSSUdIVCBIT0xERVJTIGBgQVMgSVMnJyBBTkQgQU5ZXG4gKiBFWFBSRVNTIE9SIElNUExJRUQgV0FSUkFOVElFUywgSU5DTFVESU5HLCBCVVQgTk9UIExJTUlURUQgVE8sIFRIRVxuICogSU1QTElFRCBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSBBTkQgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSXG4gKiBQVVJQT1NFIEFSRSBESVNDTEFJTUVELiAgSU4gTk8gRVZFTlQgU0hBTEwgVEhFIENPUFlSSUdIVCBPV05FUiBPUlxuICogQ09OVFJJQlVUT1JTIEJFIExJQUJMRSBGT1IgQU5ZIERJUkVDVCwgSU5ESVJFQ1QsIElOQ0lERU5UQUwsIFNQRUNJQUwsXG4gKiBFWEVNUExBUlksIE9SIENPTlNFUVVFTlRJQUwgREFNQUdFUyAoSU5DTFVESU5HLCBCVVQgTk9UIExJTUlURUQgVE8sXG4gKiBQUk9DVVJFTUVOVCBPRiBTVUJTVElUVVRFIEdPT0RTIE9SIFNFUlZJQ0VTOyBMT1NTIE9GIFVTRSwgREFUQSwgT1JcbiAqIFBST0ZJVFM7IE9SIEJVU0lORVNTIElOVEVSUlVQVElPTikgSE9XRVZFUiBDQVVTRUQgQU5EIE9OIEFOWSBUSEVPUllcbiAqIE9GIExJQUJJTElUWSwgV0hFVEhFUiBJTiBDT05UUkFDVCwgU1RSSUNUIExJQUJJTElUWSwgT1IgVE9SVFxuICogKElOQ0xVRElORyBORUdMSUdFTkNFIE9SIE9USEVSV0lTRSkgQVJJU0lORyBJTiBBTlkgV0FZIE9VVCBPRiBUSEUgVVNFXG4gKiBPRiBUSElTIFNPRlRXQVJFLCBFVkVOIElGIEFEVklTRUQgT0YgVEhFIFBPU1NJQklMSVRZIE9GIFNVQ0ggREFNQUdFLlxuICovXG4vL1RoaXMgZmlsZSBpcyBhdXRvbWF0aWNhbGx5IHJlYnVpbHQgYnkgdGhlIENlc2l1bSBidWlsZCBwcm9jZXNzLlxuZXhwb3J0IGRlZmF1bHQgXCIvKipcXG5cXFxuICogQGxpY2Vuc2VcXG5cXFxuICogQ29weXJpZ2h0IChjKSAyMDE0LTIwMTUsIE5WSURJQSBDT1JQT1JBVElPTi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cXG5cXFxuICpcXG5cXFxuICogUmVkaXN0cmlidXRpb24gYW5kIHVzZSBpbiBzb3VyY2UgYW5kIGJpbmFyeSBmb3Jtcywgd2l0aCBvciB3aXRob3V0XFxuXFxcbiAqIG1vZGlmaWNhdGlvbiwgYXJlIHBlcm1pdHRlZCBwcm92aWRlZCB0aGF0IHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uc1xcblxcXG4gKiBhcmUgbWV0OlxcblxcXG4gKiAgKiBSZWRpc3RyaWJ1dGlvbnMgb2Ygc291cmNlIGNvZGUgbXVzdCByZXRhaW4gdGhlIGFib3ZlIGNvcHlyaWdodFxcblxcXG4gKiAgICBub3RpY2UsIHRoaXMgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nIGRpc2NsYWltZXIuXFxuXFxcbiAqICAqIFJlZGlzdHJpYnV0aW9ucyBpbiBiaW5hcnkgZm9ybSBtdXN0IHJlcHJvZHVjZSB0aGUgYWJvdmUgY29weXJpZ2h0XFxuXFxcbiAqICAgIG5vdGljZSwgdGhpcyBsaXN0IG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmcgZGlzY2xhaW1lciBpbiB0aGVcXG5cXFxuICogICAgZG9jdW1lbnRhdGlvbiBhbmQvb3Igb3RoZXIgbWF0ZXJpYWxzIHByb3ZpZGVkIHdpdGggdGhlIGRpc3RyaWJ1dGlvbi5cXG5cXFxuICogICogTmVpdGhlciB0aGUgbmFtZSBvZiBOVklESUEgQ09SUE9SQVRJT04gbm9yIHRoZSBuYW1lcyBvZiBpdHNcXG5cXFxuICogICAgY29udHJpYnV0b3JzIG1heSBiZSB1c2VkIHRvIGVuZG9yc2Ugb3IgcHJvbW90ZSBwcm9kdWN0cyBkZXJpdmVkXFxuXFxcbiAqICAgIGZyb20gdGhpcyBzb2Z0d2FyZSB3aXRob3V0IHNwZWNpZmljIHByaW9yIHdyaXR0ZW4gcGVybWlzc2lvbi5cXG5cXFxuICpcXG5cXFxuICogVEhJUyBTT0ZUV0FSRSBJUyBQUk9WSURFRCBCWSBUSEUgQ09QWVJJR0hUIEhPTERFUlMgYGBBUyBJUycnIEFORCBBTllcXG5cXFxuICogRVhQUkVTUyBPUiBJTVBMSUVEIFdBUlJBTlRJRVMsIElOQ0xVRElORywgQlVUIE5PVCBMSU1JVEVEIFRPLCBUSEVcXG5cXFxuICogSU1QTElFRCBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSBBTkQgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSXFxuXFxcbiAqIFBVUlBPU0UgQVJFIERJU0NMQUlNRUQuICBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQ09QWVJJR0hUIE9XTkVSIE9SXFxuXFxcbiAqIENPTlRSSUJVVE9SUyBCRSBMSUFCTEUgRk9SIEFOWSBESVJFQ1QsIElORElSRUNULCBJTkNJREVOVEFMLCBTUEVDSUFMLFxcblxcXG4gKiBFWEVNUExBUlksIE9SIENPTlNFUVVFTlRJQUwgREFNQUdFUyAoSU5DTFVESU5HLCBCVVQgTk9UIExJTUlURUQgVE8sXFxuXFxcbiAqIFBST0NVUkVNRU5UIE9GIFNVQlNUSVRVVEUgR09PRFMgT1IgU0VSVklDRVM7IExPU1MgT0YgVVNFLCBEQVRBLCBPUlxcblxcXG4gKiBQUk9GSVRTOyBPUiBCVVNJTkVTUyBJTlRFUlJVUFRJT04pIEhPV0VWRVIgQ0FVU0VEIEFORCBPTiBBTlkgVEhFT1JZXFxuXFxcbiAqIE9GIExJQUJJTElUWSwgV0hFVEhFUiBJTiBDT05UUkFDVCwgU1RSSUNUIExJQUJJTElUWSwgT1IgVE9SVFxcblxcXG4gKiAoSU5DTFVESU5HIE5FR0xJR0VOQ0UgT1IgT1RIRVJXSVNFKSBBUklTSU5HIElOIEFOWSBXQVkgT1VUIE9GIFRIRSBVU0VcXG5cXFxuICogT0YgVEhJUyBTT0ZUV0FSRSwgRVZFTiBJRiBBRFZJU0VEIE9GIFRIRSBQT1NTSUJJTElUWSBPRiBTVUNIIERBTUFHRS5cXG5cXFxuICovXFxuXFxcblxcblxcXG4vLyBOVklESUEgR2FtZVdvcmtzIEdyYXBoaWNzIFNhbXBsZXMgR2l0SHViIGxpbms6IGh0dHBzOi8vZ2l0aHViLmNvbS9OVklESUFHYW1lV29ya3MvR3JhcGhpY3NTYW1wbGVzXFxuXFxcbi8vIE9yaWdpbmFsIEZYQUEgMy4xMSBzaGFkZXIgbGluazogaHR0cHM6Ly9naXRodWIuY29tL05WSURJQUdhbWVXb3Jrcy9HcmFwaGljc1NhbXBsZXMvYmxvYi9tYXN0ZXIvc2FtcGxlcy9lczMta2VwbGVyL0ZYQUEvRlhBQTNfMTEuaFxcblxcXG5cXG5cXFxuLy8gU3RlcHMgdXNlZCB0byBpbnRlZ3JhdGUgaW50byBDZXNpdW06XFxuXFxcbi8vICogVGhlIGZvbGxvd2luZyBkZWZpbmVzIGFyZSBzZXQ6XFxuXFxcbi8vICAgICAgICNkZWZpbmUgRlhBQV9QQyAxXFxuXFxcbi8vICAgICAgICNkZWZpbmUgRlhBQV9XRUJHTF8xIDFcXG5cXFxuLy8gICAgICAgI2RlZmluZSBGWEFBX0dSRUVOX0FTX0xVTUEgMVxcblxcXG4vLyAgICAgICAjZGVmaW5lIEZYQUFfRUFSTFlfRVhJVCAxXFxuXFxcbi8vICAgICAgICNkZWZpbmUgRlhBQV9HTFNMXzEyMCAxXFxuXFxcbi8vICogQWxsIG90aGVyIHByZXByb2Nlc3NvciBkaXJlY3RpdmVzIGJlc2lkZXMgdGhlIEZYQUFfUVVBTElUWV9fUCogZGlyZWN0aXZlcyB3ZXJlIHJlbW92ZWQuXFxuXFxcbi8vICogRG91YmxlIHVuZGVyc2NvcmVzIGFyZSBpbnZhbGlkIGZvciBwcmVwcm9jZXNzb3IgZGlyZWN0aXZlcyBzbyByZXBsYWNlIHRoZW0gd2l0aCBhIHNpbmdsZSB1bmRlcnNjb3JlLiBSZXBsYWNlXFxuXFxcbi8vICAgL0ZYQUFfUVVBTElUWV9fUCguKikvZyB3aXRoIC9GWEFBX1FVQUxJVFlfX1AkMS8uXFxuXFxcbi8vICogVGhlcmUgYXJlIG5vIGltcGxpY2l0IGNvbnZlcnNpb25zIGZyb20gaXZlYyogdG8gdmVjKiBzbyByZXBsYWNlOlxcblxcXG4vLyAgICAgICAjZGVmaW5lIEZ4YWFJbnQyIGl2ZWMyXFxuXFxcbi8vICAgICAgICAgICB3aXRoXFxuXFxcbi8vICAgICAgICNkZWZpbmUgRnhhYUludDIgdmVjMlxcblxcXG4vLyAqIFRoZSB0ZXh0dXJlMkRMb2QgZnVuY3Rpb24gaXMgb25seSBhdmFpbGFibGUgaW4gdmVydGV4IHNoYWRlcnMgc28gcmVwbGFjZTpcXG5cXFxuLy8gICAgICAgI2RlZmluZSBGeGFhVGV4VG9wKHQsIHApIHRleHR1cmUyRExvZCh0LCBwLCAwLjApXFxuXFxcbi8vICAgICAgICNkZWZpbmUgRnhhYVRleE9mZih0LCBwLCBvLCByKSB0ZXh0dXJlMkRMb2QodCwgcCArIChvICogciksIDAuMClcXG5cXFxuLy8gICAgICAgICAgIHdpdGhcXG5cXFxuLy8gICAgICAgI2RlZmluZSBGeGFhVGV4VG9wKHQsIHApIHRleHR1cmUyRCh0LCBwKVxcblxcXG4vLyAgICAgICAjZGVmaW5lIEZ4YWFUZXhPZmYodCwgcCwgbywgcikgdGV4dHVyZTJEKHQsIHAgKyAobyAqIHIpKVxcblxcXG4vLyAqIEZYQUFfUVVBTElUWV9QUkVTRVQgaXMgcHJlcGVuZGVkIGluIHRoZSBqYXZhc2NyaXB0IGNvZGUuIFdlIG1heSB3YW50IHRvIGV4cG9zZSB0aGF0IHNldHRpbmcgaW4gdGhlIGZ1dHVyZS5cXG5cXFxuLy8gKiBUaGUgZm9sbG93aW5nIHBhcmFtZXRlcnMgdG8gRnhhYVBpeGVsU2hhZGVyIGFyZSB1bnVzZWQgYW5kIGNhbiBiZSByZW1vdmVkOlxcblxcXG4vLyAgICAgICBmeGFhQ29uc29sZVBvc1Bvc1xcblxcXG4vLyAgICAgICBmeGFhQ29uc29sZVJjcEZyYW1lT3B0XFxuXFxcbi8vICAgICAgIGZ4YWFDb25zb2xlUmNwRnJhbWVPcHQyXFxuXFxcbi8vICAgICAgIGZ4YWFDb25zb2xlMzYwUmNwRnJhbWVPcHQyXFxuXFxcbi8vICAgICAgIGZ4YWFDb25zb2xlRWRnZVNoYXJwbmVzc1xcblxcXG4vLyAgICAgICBmeGFhQ29uc29sZUVkZ2VUaHJlc2hvbGRcXG5cXFxuLy8gICAgICAgZnhhYUNvbnNvbGVFZGdlVGhyZXNob2xkTWlcXG5cXFxuLy8gICAgICAgZnhhYUNvbnNvbGUzNjBDb25zdERpclxcblxcXG5cXG5cXFxuLy9cXG5cXFxuLy8gQ2hvb3NlIHRoZSBxdWFsaXR5IHByZXNldC5cXG5cXFxuLy8gVGhpcyBuZWVkcyB0byBiZSBjb21waWxlZCBpbnRvIHRoZSBzaGFkZXIgYXMgaXQgZWZmZWN0cyBjb2RlLlxcblxcXG4vLyBCZXN0IG9wdGlvbiB0byBpbmNsdWRlIG11bHRpcGxlIHByZXNldHMgaXMgdG9cXG5cXFxuLy8gaW4gZWFjaCBzaGFkZXIgZGVmaW5lIHRoZSBwcmVzZXQsIHRoZW4gaW5jbHVkZSB0aGlzIGZpbGUuXFxuXFxcbi8vXFxuXFxcbi8vIE9QVElPTlNcXG5cXFxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cXG5cXFxuLy8gMTAgdG8gMTUgLSBkZWZhdWx0IG1lZGl1bSBkaXRoZXIgKDEwPWZhc3Rlc3QsIDE1PWhpZ2hlc3QgcXVhbGl0eSlcXG5cXFxuLy8gMjAgdG8gMjkgLSBsZXNzIGRpdGhlciwgbW9yZSBleHBlbnNpdmUgKDIwPWZhc3Rlc3QsIDI5PWhpZ2hlc3QgcXVhbGl0eSlcXG5cXFxuLy8gMzkgICAgICAgLSBubyBkaXRoZXIsIHZlcnkgZXhwZW5zaXZlXFxuXFxcbi8vXFxuXFxcbi8vIE5PVEVTXFxuXFxcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXFxuXFxcbi8vIDEyID0gc2xpZ2h0bHkgZmFzdGVyIHRoZW4gRlhBQSAzLjkgYW5kIGhpZ2hlciBlZGdlIHF1YWxpdHkgKGRlZmF1bHQpXFxuXFxcbi8vIDEzID0gYWJvdXQgc2FtZSBzcGVlZCBhcyBGWEFBIDMuOSBhbmQgYmV0dGVyIHRoYW4gMTJcXG5cXFxuLy8gMjMgPSBjbG9zZXN0IHRvIEZYQUEgMy45IHZpc3VhbGx5IGFuZCBwZXJmb3JtYW5jZSB3aXNlXFxuXFxcbi8vICBfID0gdGhlIGxvd2VzdCBkaWdpdCBpcyBkaXJlY3RseSByZWxhdGVkIHRvIHBlcmZvcm1hbmNlXFxuXFxcbi8vIF8gID0gdGhlIGhpZ2hlc3QgZGlnaXQgaXMgZGlyZWN0bHkgcmVsYXRlZCB0byBzdHlsZVxcblxcXG4vL1xcblxcXG4vLyNkZWZpbmUgRlhBQV9RVUFMSVRZX1BSRVNFVCAxMlxcblxcXG5cXG5cXFxuXFxuXFxcbiNpZiAoRlhBQV9RVUFMSVRZX1BSRVNFVCA9PSAxMClcXG5cXFxuICAgICNkZWZpbmUgRlhBQV9RVUFMSVRZX1BTIDNcXG5cXFxuICAgICNkZWZpbmUgRlhBQV9RVUFMSVRZX1AwIDEuNVxcblxcXG4gICAgI2RlZmluZSBGWEFBX1FVQUxJVFlfUDEgMy4wXFxuXFxcbiAgICAjZGVmaW5lIEZYQUFfUVVBTElUWV9QMiAxMi4wXFxuXFxcbiNlbmRpZlxcblxcXG4jaWYgKEZYQUFfUVVBTElUWV9QUkVTRVQgPT0gMTEpXFxuXFxcbiAgICAjZGVmaW5lIEZYQUFfUVVBTElUWV9QUyA0XFxuXFxcbiAgICAjZGVmaW5lIEZYQUFfUVVBTElUWV9QMCAxLjBcXG5cXFxuICAgICNkZWZpbmUgRlhBQV9RVUFMSVRZX1AxIDEuNVxcblxcXG4gICAgI2RlZmluZSBGWEFBX1FVQUxJVFlfUDIgMy4wXFxuXFxcbiAgICAjZGVmaW5lIEZYQUFfUVVBTElUWV9QMyAxMi4wXFxuXFxcbiNlbmRpZlxcblxcXG4jaWYgKEZYQUFfUVVBTElUWV9QUkVTRVQgPT0gMTIpXFxuXFxcbiAgICAjZGVmaW5lIEZYQUFfUVVBTElUWV9QUyA1XFxuXFxcbiAgICAjZGVmaW5lIEZYQUFfUVVBTElUWV9QMCAxLjBcXG5cXFxuICAgICNkZWZpbmUgRlhBQV9RVUFMSVRZX1AxIDEuNVxcblxcXG4gICAgI2RlZmluZSBGWEFBX1FVQUxJVFlfUDIgMi4wXFxuXFxcbiAgICAjZGVmaW5lIEZYQUFfUVVBTElUWV9QMyA0LjBcXG5cXFxuICAgICNkZWZpbmUgRlhBQV9RVUFMSVRZX1A0IDEyLjBcXG5cXFxuI2VuZGlmXFxuXFxcbiNpZiAoRlhBQV9RVUFMSVRZX1BSRVNFVCA9PSAxMylcXG5cXFxuICAgICNkZWZpbmUgRlhBQV9RVUFMSVRZX1BTIDZcXG5cXFxuICAgICNkZWZpbmUgRlhBQV9RVUFMSVRZX1AwIDEuMFxcblxcXG4gICAgI2RlZmluZSBGWEFBX1FVQUxJVFlfUDEgMS41XFxuXFxcbiAgICAjZGVmaW5lIEZYQUFfUVVBTElUWV9QMiAyLjBcXG5cXFxuICAgICNkZWZpbmUgRlhBQV9RVUFMSVRZX1AzIDIuMFxcblxcXG4gICAgI2RlZmluZSBGWEFBX1FVQUxJVFlfUDQgNC4wXFxuXFxcbiAgICAjZGVmaW5lIEZYQUFfUVVBTElUWV9QNSAxMi4wXFxuXFxcbiNlbmRpZlxcblxcXG4jaWYgKEZYQUFfUVVBTElUWV9QUkVTRVQgPT0gMTQpXFxuXFxcbiAgICAjZGVmaW5lIEZYQUFfUVVBTElUWV9QUyA3XFxuXFxcbiAgICAjZGVmaW5lIEZYQUFfUVVBTElUWV9QMCAxLjBcXG5cXFxuICAgICNkZWZpbmUgRlhBQV9RVUFMSVRZX1AxIDEuNVxcblxcXG4gICAgI2RlZmluZSBGWEFBX1FVQUxJVFlfUDIgMi4wXFxuXFxcbiAgICAjZGVmaW5lIEZYQUFfUVVBTElUWV9QMyAyLjBcXG5cXFxuICAgICNkZWZpbmUgRlhBQV9RVUFMSVRZX1A0IDIuMFxcblxcXG4gICAgI2RlZmluZSBGWEFBX1FVQUxJVFlfUDUgNC4wXFxuXFxcbiAgICAjZGVmaW5lIEZYQUFfUVVBTElUWV9QNiAxMi4wXFxuXFxcbiNlbmRpZlxcblxcXG4jaWYgKEZYQUFfUVVBTElUWV9QUkVTRVQgPT0gMTUpXFxuXFxcbiAgICAjZGVmaW5lIEZYQUFfUVVBTElUWV9QUyA4XFxuXFxcbiAgICAjZGVmaW5lIEZYQUFfUVVBTElUWV9QMCAxLjBcXG5cXFxuICAgICNkZWZpbmUgRlhBQV9RVUFMSVRZX1AxIDEuNVxcblxcXG4gICAgI2RlZmluZSBGWEFBX1FVQUxJVFlfUDIgMi4wXFxuXFxcbiAgICAjZGVmaW5lIEZYQUFfUVVBTElUWV9QMyAyLjBcXG5cXFxuICAgICNkZWZpbmUgRlhBQV9RVUFMSVRZX1A0IDIuMFxcblxcXG4gICAgI2RlZmluZSBGWEFBX1FVQUxJVFlfUDUgMi4wXFxuXFxcbiAgICAjZGVmaW5lIEZYQUFfUVVBTElUWV9QNiA0LjBcXG5cXFxuICAgICNkZWZpbmUgRlhBQV9RVUFMSVRZX1A3IDEyLjBcXG5cXFxuI2VuZGlmXFxuXFxcbiNpZiAoRlhBQV9RVUFMSVRZX1BSRVNFVCA9PSAyMClcXG5cXFxuICAgICNkZWZpbmUgRlhBQV9RVUFMSVRZX1BTIDNcXG5cXFxuICAgICNkZWZpbmUgRlhBQV9RVUFMSVRZX1AwIDEuNVxcblxcXG4gICAgI2RlZmluZSBGWEFBX1FVQUxJVFlfUDEgMi4wXFxuXFxcbiAgICAjZGVmaW5lIEZYQUFfUVVBTElUWV9QMiA4LjBcXG5cXFxuI2VuZGlmXFxuXFxcbiNpZiAoRlhBQV9RVUFMSVRZX1BSRVNFVCA9PSAyMSlcXG5cXFxuICAgICNkZWZpbmUgRlhBQV9RVUFMSVRZX1BTIDRcXG5cXFxuICAgICNkZWZpbmUgRlhBQV9RVUFMSVRZX1AwIDEuMFxcblxcXG4gICAgI2RlZmluZSBGWEFBX1FVQUxJVFlfUDEgMS41XFxuXFxcbiAgICAjZGVmaW5lIEZYQUFfUVVBTElUWV9QMiAyLjBcXG5cXFxuICAgICNkZWZpbmUgRlhBQV9RVUFMSVRZX1AzIDguMFxcblxcXG4jZW5kaWZcXG5cXFxuI2lmIChGWEFBX1FVQUxJVFlfUFJFU0VUID09IDIyKVxcblxcXG4gICAgI2RlZmluZSBGWEFBX1FVQUxJVFlfUFMgNVxcblxcXG4gICAgI2RlZmluZSBGWEFBX1FVQUxJVFlfUDAgMS4wXFxuXFxcbiAgICAjZGVmaW5lIEZYQUFfUVVBTElUWV9QMSAxLjVcXG5cXFxuICAgICNkZWZpbmUgRlhBQV9RVUFMSVRZX1AyIDIuMFxcblxcXG4gICAgI2RlZmluZSBGWEFBX1FVQUxJVFlfUDMgMi4wXFxuXFxcbiAgICAjZGVmaW5lIEZYQUFfUVVBTElUWV9QNCA4LjBcXG5cXFxuI2VuZGlmXFxuXFxcbiNpZiAoRlhBQV9RVUFMSVRZX1BSRVNFVCA9PSAyMylcXG5cXFxuICAgICNkZWZpbmUgRlhBQV9RVUFMSVRZX1BTIDZcXG5cXFxuICAgICNkZWZpbmUgRlhBQV9RVUFMSVRZX1AwIDEuMFxcblxcXG4gICAgI2RlZmluZSBGWEFBX1FVQUxJVFlfUDEgMS41XFxuXFxcbiAgICAjZGVmaW5lIEZYQUFfUVVBTElUWV9QMiAyLjBcXG5cXFxuICAgICNkZWZpbmUgRlhBQV9RVUFMSVRZX1AzIDIuMFxcblxcXG4gICAgI2RlZmluZSBGWEFBX1FVQUxJVFlfUDQgMi4wXFxuXFxcbiAgICAjZGVmaW5lIEZYQUFfUVVBTElUWV9QNSA4LjBcXG5cXFxuI2VuZGlmXFxuXFxcbiNpZiAoRlhBQV9RVUFMSVRZX1BSRVNFVCA9PSAyNClcXG5cXFxuICAgICNkZWZpbmUgRlhBQV9RVUFMSVRZX1BTIDdcXG5cXFxuICAgICNkZWZpbmUgRlhBQV9RVUFMSVRZX1AwIDEuMFxcblxcXG4gICAgI2RlZmluZSBGWEFBX1FVQUxJVFlfUDEgMS41XFxuXFxcbiAgICAjZGVmaW5lIEZYQUFfUVVBTElUWV9QMiAyLjBcXG5cXFxuICAgICNkZWZpbmUgRlhBQV9RVUFMSVRZX1AzIDIuMFxcblxcXG4gICAgI2RlZmluZSBGWEFBX1FVQUxJVFlfUDQgMi4wXFxuXFxcbiAgICAjZGVmaW5lIEZYQUFfUVVBTElUWV9QNSAzLjBcXG5cXFxuICAgICNkZWZpbmUgRlhBQV9RVUFMSVRZX1A2IDguMFxcblxcXG4jZW5kaWZcXG5cXFxuI2lmIChGWEFBX1FVQUxJVFlfUFJFU0VUID09IDI1KVxcblxcXG4gICAgI2RlZmluZSBGWEFBX1FVQUxJVFlfUFMgOFxcblxcXG4gICAgI2RlZmluZSBGWEFBX1FVQUxJVFlfUDAgMS4wXFxuXFxcbiAgICAjZGVmaW5lIEZYQUFfUVVBTElUWV9QMSAxLjVcXG5cXFxuICAgICNkZWZpbmUgRlhBQV9RVUFMSVRZX1AyIDIuMFxcblxcXG4gICAgI2RlZmluZSBGWEFBX1FVQUxJVFlfUDMgMi4wXFxuXFxcbiAgICAjZGVmaW5lIEZYQUFfUVVBTElUWV9QNCAyLjBcXG5cXFxuICAgICNkZWZpbmUgRlhBQV9RVUFMSVRZX1A1IDIuMFxcblxcXG4gICAgI2RlZmluZSBGWEFBX1FVQUxJVFlfUDYgNC4wXFxuXFxcbiAgICAjZGVmaW5lIEZYQUFfUVVBTElUWV9QNyA4LjBcXG5cXFxuI2VuZGlmXFxuXFxcbiNpZiAoRlhBQV9RVUFMSVRZX1BSRVNFVCA9PSAyNilcXG5cXFxuICAgICNkZWZpbmUgRlhBQV9RVUFMSVRZX1BTIDlcXG5cXFxuICAgICNkZWZpbmUgRlhBQV9RVUFMSVRZX1AwIDEuMFxcblxcXG4gICAgI2RlZmluZSBGWEFBX1FVQUxJVFlfUDEgMS41XFxuXFxcbiAgICAjZGVmaW5lIEZYQUFfUVVBTElUWV9QMiAyLjBcXG5cXFxuICAgICNkZWZpbmUgRlhBQV9RVUFMSVRZX1AzIDIuMFxcblxcXG4gICAgI2RlZmluZSBGWEFBX1FVQUxJVFlfUDQgMi4wXFxuXFxcbiAgICAjZGVmaW5lIEZYQUFfUVVBTElUWV9QNSAyLjBcXG5cXFxuICAgICNkZWZpbmUgRlhBQV9RVUFMSVRZX1A2IDIuMFxcblxcXG4gICAgI2RlZmluZSBGWEFBX1FVQUxJVFlfUDcgNC4wXFxuXFxcbiAgICAjZGVmaW5lIEZYQUFfUVVBTElUWV9QOCA4LjBcXG5cXFxuI2VuZGlmXFxuXFxcbiNpZiAoRlhBQV9RVUFMSVRZX1BSRVNFVCA9PSAyNylcXG5cXFxuICAgICNkZWZpbmUgRlhBQV9RVUFMSVRZX1BTIDEwXFxuXFxcbiAgICAjZGVmaW5lIEZYQUFfUVVBTElUWV9QMCAxLjBcXG5cXFxuICAgICNkZWZpbmUgRlhBQV9RVUFMSVRZX1AxIDEuNVxcblxcXG4gICAgI2RlZmluZSBGWEFBX1FVQUxJVFlfUDIgMi4wXFxuXFxcbiAgICAjZGVmaW5lIEZYQUFfUVVBTElUWV9QMyAyLjBcXG5cXFxuICAgICNkZWZpbmUgRlhBQV9RVUFMSVRZX1A0IDIuMFxcblxcXG4gICAgI2RlZmluZSBGWEFBX1FVQUxJVFlfUDUgMi4wXFxuXFxcbiAgICAjZGVmaW5lIEZYQUFfUVVBTElUWV9QNiAyLjBcXG5cXFxuICAgICNkZWZpbmUgRlhBQV9RVUFMSVRZX1A3IDIuMFxcblxcXG4gICAgI2RlZmluZSBGWEFBX1FVQUxJVFlfUDggNC4wXFxuXFxcbiAgICAjZGVmaW5lIEZYQUFfUVVBTElUWV9QOSA4LjBcXG5cXFxuI2VuZGlmXFxuXFxcbiNpZiAoRlhBQV9RVUFMSVRZX1BSRVNFVCA9PSAyOClcXG5cXFxuICAgICNkZWZpbmUgRlhBQV9RVUFMSVRZX1BTIDExXFxuXFxcbiAgICAjZGVmaW5lIEZYQUFfUVVBTElUWV9QMCAxLjBcXG5cXFxuICAgICNkZWZpbmUgRlhBQV9RVUFMSVRZX1AxIDEuNVxcblxcXG4gICAgI2RlZmluZSBGWEFBX1FVQUxJVFlfUDIgMi4wXFxuXFxcbiAgICAjZGVmaW5lIEZYQUFfUVVBTElUWV9QMyAyLjBcXG5cXFxuICAgICNkZWZpbmUgRlhBQV9RVUFMSVRZX1A0IDIuMFxcblxcXG4gICAgI2RlZmluZSBGWEFBX1FVQUxJVFlfUDUgMi4wXFxuXFxcbiAgICAjZGVmaW5lIEZYQUFfUVVBTElUWV9QNiAyLjBcXG5cXFxuICAgICNkZWZpbmUgRlhBQV9RVUFMSVRZX1A3IDIuMFxcblxcXG4gICAgI2RlZmluZSBGWEFBX1FVQUxJVFlfUDggMi4wXFxuXFxcbiAgICAjZGVmaW5lIEZYQUFfUVVBTElUWV9QOSA0LjBcXG5cXFxuICAgICNkZWZpbmUgRlhBQV9RVUFMSVRZX1AxMCA4LjBcXG5cXFxuI2VuZGlmXFxuXFxcbiNpZiAoRlhBQV9RVUFMSVRZX1BSRVNFVCA9PSAyOSlcXG5cXFxuICAgICNkZWZpbmUgRlhBQV9RVUFMSVRZX1BTIDEyXFxuXFxcbiAgICAjZGVmaW5lIEZYQUFfUVVBTElUWV9QMCAxLjBcXG5cXFxuICAgICNkZWZpbmUgRlhBQV9RVUFMSVRZX1AxIDEuNVxcblxcXG4gICAgI2RlZmluZSBGWEFBX1FVQUxJVFlfUDIgMi4wXFxuXFxcbiAgICAjZGVmaW5lIEZYQUFfUVVBTElUWV9QMyAyLjBcXG5cXFxuICAgICNkZWZpbmUgRlhBQV9RVUFMSVRZX1A0IDIuMFxcblxcXG4gICAgI2RlZmluZSBGWEFBX1FVQUxJVFlfUDUgMi4wXFxuXFxcbiAgICAjZGVmaW5lIEZYQUFfUVVBTElUWV9QNiAyLjBcXG5cXFxuICAgICNkZWZpbmUgRlhBQV9RVUFMSVRZX1A3IDIuMFxcblxcXG4gICAgI2RlZmluZSBGWEFBX1FVQUxJVFlfUDggMi4wXFxuXFxcbiAgICAjZGVmaW5lIEZYQUFfUVVBTElUWV9QOSAyLjBcXG5cXFxuICAgICNkZWZpbmUgRlhBQV9RVUFMSVRZX1AxMCA0LjBcXG5cXFxuICAgICNkZWZpbmUgRlhBQV9RVUFMSVRZX1AxMSA4LjBcXG5cXFxuI2VuZGlmXFxuXFxcbiNpZiAoRlhBQV9RVUFMSVRZX1BSRVNFVCA9PSAzOSlcXG5cXFxuICAgICNkZWZpbmUgRlhBQV9RVUFMSVRZX1BTIDEyXFxuXFxcbiAgICAjZGVmaW5lIEZYQUFfUVVBTElUWV9QMCAxLjBcXG5cXFxuICAgICNkZWZpbmUgRlhBQV9RVUFMSVRZX1AxIDEuMFxcblxcXG4gICAgI2RlZmluZSBGWEFBX1FVQUxJVFlfUDIgMS4wXFxuXFxcbiAgICAjZGVmaW5lIEZYQUFfUVVBTElUWV9QMyAxLjBcXG5cXFxuICAgICNkZWZpbmUgRlhBQV9RVUFMSVRZX1A0IDEuMFxcblxcXG4gICAgI2RlZmluZSBGWEFBX1FVQUxJVFlfUDUgMS41XFxuXFxcbiAgICAjZGVmaW5lIEZYQUFfUVVBTElUWV9QNiAyLjBcXG5cXFxuICAgICNkZWZpbmUgRlhBQV9RVUFMSVRZX1A3IDIuMFxcblxcXG4gICAgI2RlZmluZSBGWEFBX1FVQUxJVFlfUDggMi4wXFxuXFxcbiAgICAjZGVmaW5lIEZYQUFfUVVBTElUWV9QOSAyLjBcXG5cXFxuICAgICNkZWZpbmUgRlhBQV9RVUFMSVRZX1AxMCA0LjBcXG5cXFxuICAgICNkZWZpbmUgRlhBQV9RVUFMSVRZX1AxMSA4LjBcXG5cXFxuI2VuZGlmXFxuXFxcblxcblxcXG4jZGVmaW5lIEZ4YWFCb29sIGJvb2xcXG5cXFxuI2RlZmluZSBGeGFhRmxvYXQgZmxvYXRcXG5cXFxuI2RlZmluZSBGeGFhRmxvYXQyIHZlYzJcXG5cXFxuI2RlZmluZSBGeGFhRmxvYXQzIHZlYzNcXG5cXFxuI2RlZmluZSBGeGFhRmxvYXQ0IHZlYzRcXG5cXFxuI2RlZmluZSBGeGFhSGFsZiBmbG9hdFxcblxcXG4jZGVmaW5lIEZ4YWFIYWxmMiB2ZWMyXFxuXFxcbiNkZWZpbmUgRnhhYUhhbGYzIHZlYzNcXG5cXFxuI2RlZmluZSBGeGFhSGFsZjQgdmVjNFxcblxcXG4jZGVmaW5lIEZ4YWFJbnQyIHZlYzJcXG5cXFxuI2RlZmluZSBGeGFhVGV4IHNhbXBsZXIyRFxcblxcXG5cXG5cXFxuI2RlZmluZSBGeGFhU2F0KHgpIGNsYW1wKHgsIDAuMCwgMS4wKVxcblxcXG4jZGVmaW5lIEZ4YWFUZXhUb3AodCwgcCkgdGV4dHVyZTJEKHQsIHApXFxuXFxcbiNkZWZpbmUgRnhhYVRleE9mZih0LCBwLCBvLCByKSB0ZXh0dXJlMkQodCwgcCArIChvICogcikpXFxuXFxcblxcblxcXG5GeGFhRmxvYXQgRnhhYUx1bWEoRnhhYUZsb2F0NCByZ2JhKSB7IHJldHVybiByZ2JhLnk7IH1cXG5cXFxuXFxuXFxcbkZ4YWFGbG9hdDQgRnhhYVBpeGVsU2hhZGVyKFxcblxcXG4gICAgLy9cXG5cXFxuICAgIC8vIFVzZSBub3BlcnNwZWN0aXZlIGludGVycG9sYXRpb24gaGVyZSAodHVybiBvZmYgcGVyc3BlY3RpdmUgaW50ZXJwb2xhdGlvbikuXFxuXFxcbiAgICAvLyB7eHl9ID0gY2VudGVyIG9mIHBpeGVsXFxuXFxcbiAgICBGeGFhRmxvYXQyIHBvcyxcXG5cXFxuICAgIC8vXFxuXFxcbiAgICAvLyBJbnB1dCBjb2xvciB0ZXh0dXJlLlxcblxcXG4gICAgLy8ge3JnYl99ID0gY29sb3IgaW4gbGluZWFyIG9yIHBlcmNlcHR1YWwgY29sb3Igc3BhY2VcXG5cXFxuICAgIC8vIGlmIChGWEFBX0dSRUVOX0FTX0xVTUEgPT0gMClcXG5cXFxuICAgIC8vICAgICB7X19fYX0gPSBsdW1hIGluIHBlcmNlcHR1YWwgY29sb3Igc3BhY2UgKG5vdCBsaW5lYXIpXFxuXFxcbiAgICBGeGFhVGV4IHRleCxcXG5cXFxuICAgIC8vXFxuXFxcbiAgICAvLyBPbmx5IHVzZWQgb24gRlhBQSBRdWFsaXR5LlxcblxcXG4gICAgLy8gVGhpcyBtdXN0IGJlIGZyb20gYSBjb25zdGFudC91bmlmb3JtLlxcblxcXG4gICAgLy8ge3hffSA9IDEuMC9zY3JlZW5XaWR0aEluUGl4ZWxzXFxuXFxcbiAgICAvLyB7X3l9ID0gMS4wL3NjcmVlbkhlaWdodEluUGl4ZWxzXFxuXFxcbiAgICBGeGFhRmxvYXQyIGZ4YWFRdWFsaXR5UmNwRnJhbWUsXFxuXFxcbiAgICAvL1xcblxcXG4gICAgLy8gT25seSB1c2VkIG9uIEZYQUEgUXVhbGl0eS5cXG5cXFxuICAgIC8vIFRoaXMgdXNlZCB0byBiZSB0aGUgRlhBQV9RVUFMSVRZX1NVQlBJWCBkZWZpbmUuXFxuXFxcbiAgICAvLyBJdCBpcyBoZXJlIG5vdyB0byBhbGxvdyBlYXNpZXIgdHVuaW5nLlxcblxcXG4gICAgLy8gQ2hvb3NlIHRoZSBhbW91bnQgb2Ygc3ViLXBpeGVsIGFsaWFzaW5nIHJlbW92YWwuXFxuXFxcbiAgICAvLyBUaGlzIGNhbiBlZmZlY3Qgc2hhcnBuZXNzLlxcblxcXG4gICAgLy8gICAxLjAwIC0gdXBwZXIgbGltaXQgKHNvZnRlcilcXG5cXFxuICAgIC8vICAgMC43NSAtIGRlZmF1bHQgYW1vdW50IG9mIGZpbHRlcmluZ1xcblxcXG4gICAgLy8gICAwLjUwIC0gbG93ZXIgbGltaXQgKHNoYXJwZXIsIGxlc3Mgc3ViLXBpeGVsIGFsaWFzaW5nIHJlbW92YWwpXFxuXFxcbiAgICAvLyAgIDAuMjUgLSBhbG1vc3Qgb2ZmXFxuXFxcbiAgICAvLyAgIDAuMDAgLSBjb21wbGV0ZWx5IG9mZlxcblxcXG4gICAgRnhhYUZsb2F0IGZ4YWFRdWFsaXR5U3VicGl4LFxcblxcXG4gICAgLy9cXG5cXFxuICAgIC8vIE9ubHkgdXNlZCBvbiBGWEFBIFF1YWxpdHkuXFxuXFxcbiAgICAvLyBUaGlzIHVzZWQgdG8gYmUgdGhlIEZYQUFfUVVBTElUWV9FREdFX1RIUkVTSE9MRCBkZWZpbmUuXFxuXFxcbiAgICAvLyBJdCBpcyBoZXJlIG5vdyB0byBhbGxvdyBlYXNpZXIgdHVuaW5nLlxcblxcXG4gICAgLy8gVGhlIG1pbmltdW0gYW1vdW50IG9mIGxvY2FsIGNvbnRyYXN0IHJlcXVpcmVkIHRvIGFwcGx5IGFsZ29yaXRobS5cXG5cXFxuICAgIC8vICAgMC4zMzMgLSB0b28gbGl0dGxlIChmYXN0ZXIpXFxuXFxcbiAgICAvLyAgIDAuMjUwIC0gbG93IHF1YWxpdHlcXG5cXFxuICAgIC8vICAgMC4xNjYgLSBkZWZhdWx0XFxuXFxcbiAgICAvLyAgIDAuMTI1IC0gaGlnaCBxdWFsaXR5XFxuXFxcbiAgICAvLyAgIDAuMDYzIC0gb3ZlcmtpbGwgKHNsb3dlcilcXG5cXFxuICAgIEZ4YWFGbG9hdCBmeGFhUXVhbGl0eUVkZ2VUaHJlc2hvbGQsXFxuXFxcbiAgICAvL1xcblxcXG4gICAgLy8gT25seSB1c2VkIG9uIEZYQUEgUXVhbGl0eS5cXG5cXFxuICAgIC8vIFRoaXMgdXNlZCB0byBiZSB0aGUgRlhBQV9RVUFMSVRZX0VER0VfVEhSRVNIT0xEX01JTiBkZWZpbmUuXFxuXFxcbiAgICAvLyBJdCBpcyBoZXJlIG5vdyB0byBhbGxvdyBlYXNpZXIgdHVuaW5nLlxcblxcXG4gICAgLy8gVHJpbXMgdGhlIGFsZ29yaXRobSBmcm9tIHByb2Nlc3NpbmcgZGFya3MuXFxuXFxcbiAgICAvLyAgIDAuMDgzMyAtIHVwcGVyIGxpbWl0IChkZWZhdWx0LCB0aGUgc3RhcnQgb2YgdmlzaWJsZSB1bmZpbHRlcmVkIGVkZ2VzKVxcblxcXG4gICAgLy8gICAwLjA2MjUgLSBoaWdoIHF1YWxpdHkgKGZhc3RlcilcXG5cXFxuICAgIC8vICAgMC4wMzEyIC0gdmlzaWJsZSBsaW1pdCAoc2xvd2VyKVxcblxcXG4gICAgLy8gU3BlY2lhbCBub3RlcyB3aGVuIHVzaW5nIEZYQUFfR1JFRU5fQVNfTFVNQSxcXG5cXFxuICAgIC8vICAgTGlrZWx5IHdhbnQgdG8gc2V0IHRoaXMgdG8gemVyby5cXG5cXFxuICAgIC8vICAgQXMgY29sb3JzIHRoYXQgYXJlIG1vc3RseSBub3QtZ3JlZW5cXG5cXFxuICAgIC8vICAgd2lsbCBhcHBlYXIgdmVyeSBkYXJrIGluIHRoZSBncmVlbiBjaGFubmVsIVxcblxcXG4gICAgLy8gICBUdW5lIGJ5IGxvb2tpbmcgYXQgbW9zdGx5IG5vbi1ncmVlbiBjb250ZW50LFxcblxcXG4gICAgLy8gICB0aGVuIHN0YXJ0IGF0IHplcm8gYW5kIGluY3JlYXNlIHVudGlsIGFsaWFzaW5nIGlzIGEgcHJvYmxlbS5cXG5cXFxuICAgIEZ4YWFGbG9hdCBmeGFhUXVhbGl0eUVkZ2VUaHJlc2hvbGRNaW5cXG5cXFxuKSB7XFxuXFxcbi8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xcblxcXG4gICAgRnhhYUZsb2F0MiBwb3NNO1xcblxcXG4gICAgcG9zTS54ID0gcG9zLng7XFxuXFxcbiAgICBwb3NNLnkgPSBwb3MueTtcXG5cXFxuICAgIEZ4YWFGbG9hdDQgcmdieU0gPSBGeGFhVGV4VG9wKHRleCwgcG9zTSk7XFxuXFxcbiAgICAjZGVmaW5lIGx1bWFNIHJnYnlNLnlcXG5cXFxuICAgIEZ4YWFGbG9hdCBsdW1hUyA9IEZ4YWFMdW1hKEZ4YWFUZXhPZmYodGV4LCBwb3NNLCBGeGFhSW50MiggMCwgMSksIGZ4YWFRdWFsaXR5UmNwRnJhbWUueHkpKTtcXG5cXFxuICAgIEZ4YWFGbG9hdCBsdW1hRSA9IEZ4YWFMdW1hKEZ4YWFUZXhPZmYodGV4LCBwb3NNLCBGeGFhSW50MiggMSwgMCksIGZ4YWFRdWFsaXR5UmNwRnJhbWUueHkpKTtcXG5cXFxuICAgIEZ4YWFGbG9hdCBsdW1hTiA9IEZ4YWFMdW1hKEZ4YWFUZXhPZmYodGV4LCBwb3NNLCBGeGFhSW50MiggMCwtMSksIGZ4YWFRdWFsaXR5UmNwRnJhbWUueHkpKTtcXG5cXFxuICAgIEZ4YWFGbG9hdCBsdW1hVyA9IEZ4YWFMdW1hKEZ4YWFUZXhPZmYodGV4LCBwb3NNLCBGeGFhSW50MigtMSwgMCksIGZ4YWFRdWFsaXR5UmNwRnJhbWUueHkpKTtcXG5cXFxuLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXFxuXFxcbiAgICBGeGFhRmxvYXQgbWF4U00gPSBtYXgobHVtYVMsIGx1bWFNKTtcXG5cXFxuICAgIEZ4YWFGbG9hdCBtaW5TTSA9IG1pbihsdW1hUywgbHVtYU0pO1xcblxcXG4gICAgRnhhYUZsb2F0IG1heEVTTSA9IG1heChsdW1hRSwgbWF4U00pO1xcblxcXG4gICAgRnhhYUZsb2F0IG1pbkVTTSA9IG1pbihsdW1hRSwgbWluU00pO1xcblxcXG4gICAgRnhhYUZsb2F0IG1heFdOID0gbWF4KGx1bWFOLCBsdW1hVyk7XFxuXFxcbiAgICBGeGFhRmxvYXQgbWluV04gPSBtaW4obHVtYU4sIGx1bWFXKTtcXG5cXFxuICAgIEZ4YWFGbG9hdCByYW5nZU1heCA9IG1heChtYXhXTiwgbWF4RVNNKTtcXG5cXFxuICAgIEZ4YWFGbG9hdCByYW5nZU1pbiA9IG1pbihtaW5XTiwgbWluRVNNKTtcXG5cXFxuICAgIEZ4YWFGbG9hdCByYW5nZU1heFNjYWxlZCA9IHJhbmdlTWF4ICogZnhhYVF1YWxpdHlFZGdlVGhyZXNob2xkO1xcblxcXG4gICAgRnhhYUZsb2F0IHJhbmdlID0gcmFuZ2VNYXggLSByYW5nZU1pbjtcXG5cXFxuICAgIEZ4YWFGbG9hdCByYW5nZU1heENsYW1wZWQgPSBtYXgoZnhhYVF1YWxpdHlFZGdlVGhyZXNob2xkTWluLCByYW5nZU1heFNjYWxlZCk7XFxuXFxcbiAgICBGeGFhQm9vbCBlYXJseUV4aXQgPSByYW5nZSA8IHJhbmdlTWF4Q2xhbXBlZDtcXG5cXFxuLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXFxuXFxcbiAgICBpZihlYXJseUV4aXQpXFxuXFxcbiAgICAgICAgcmV0dXJuIHJnYnlNO1xcblxcXG4vKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cXG5cXFxuICAgIEZ4YWFGbG9hdCBsdW1hTlcgPSBGeGFhTHVtYShGeGFhVGV4T2ZmKHRleCwgcG9zTSwgRnhhYUludDIoLTEsLTEpLCBmeGFhUXVhbGl0eVJjcEZyYW1lLnh5KSk7XFxuXFxcbiAgICBGeGFhRmxvYXQgbHVtYVNFID0gRnhhYUx1bWEoRnhhYVRleE9mZih0ZXgsIHBvc00sIEZ4YWFJbnQyKCAxLCAxKSwgZnhhYVF1YWxpdHlSY3BGcmFtZS54eSkpO1xcblxcXG4gICAgRnhhYUZsb2F0IGx1bWFORSA9IEZ4YWFMdW1hKEZ4YWFUZXhPZmYodGV4LCBwb3NNLCBGeGFhSW50MiggMSwtMSksIGZ4YWFRdWFsaXR5UmNwRnJhbWUueHkpKTtcXG5cXFxuICAgIEZ4YWFGbG9hdCBsdW1hU1cgPSBGeGFhTHVtYShGeGFhVGV4T2ZmKHRleCwgcG9zTSwgRnhhYUludDIoLTEsIDEpLCBmeGFhUXVhbGl0eVJjcEZyYW1lLnh5KSk7XFxuXFxcbi8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xcblxcXG4gICAgRnhhYUZsb2F0IGx1bWFOUyA9IGx1bWFOICsgbHVtYVM7XFxuXFxcbiAgICBGeGFhRmxvYXQgbHVtYVdFID0gbHVtYVcgKyBsdW1hRTtcXG5cXFxuICAgIEZ4YWFGbG9hdCBzdWJwaXhSY3BSYW5nZSA9IDEuMC9yYW5nZTtcXG5cXFxuICAgIEZ4YWFGbG9hdCBzdWJwaXhOU1dFID0gbHVtYU5TICsgbHVtYVdFO1xcblxcXG4gICAgRnhhYUZsb2F0IGVkZ2VIb3J6MSA9ICgtMi4wICogbHVtYU0pICsgbHVtYU5TO1xcblxcXG4gICAgRnhhYUZsb2F0IGVkZ2VWZXJ0MSA9ICgtMi4wICogbHVtYU0pICsgbHVtYVdFO1xcblxcXG4vKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cXG5cXFxuICAgIEZ4YWFGbG9hdCBsdW1hTkVTRSA9IGx1bWFORSArIGx1bWFTRTtcXG5cXFxuICAgIEZ4YWFGbG9hdCBsdW1hTldORSA9IGx1bWFOVyArIGx1bWFORTtcXG5cXFxuICAgIEZ4YWFGbG9hdCBlZGdlSG9yejIgPSAoLTIuMCAqIGx1bWFFKSArIGx1bWFORVNFO1xcblxcXG4gICAgRnhhYUZsb2F0IGVkZ2VWZXJ0MiA9ICgtMi4wICogbHVtYU4pICsgbHVtYU5XTkU7XFxuXFxcbi8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xcblxcXG4gICAgRnhhYUZsb2F0IGx1bWFOV1NXID0gbHVtYU5XICsgbHVtYVNXO1xcblxcXG4gICAgRnhhYUZsb2F0IGx1bWFTV1NFID0gbHVtYVNXICsgbHVtYVNFO1xcblxcXG4gICAgRnhhYUZsb2F0IGVkZ2VIb3J6NCA9IChhYnMoZWRnZUhvcnoxKSAqIDIuMCkgKyBhYnMoZWRnZUhvcnoyKTtcXG5cXFxuICAgIEZ4YWFGbG9hdCBlZGdlVmVydDQgPSAoYWJzKGVkZ2VWZXJ0MSkgKiAyLjApICsgYWJzKGVkZ2VWZXJ0Mik7XFxuXFxcbiAgICBGeGFhRmxvYXQgZWRnZUhvcnozID0gKC0yLjAgKiBsdW1hVykgKyBsdW1hTldTVztcXG5cXFxuICAgIEZ4YWFGbG9hdCBlZGdlVmVydDMgPSAoLTIuMCAqIGx1bWFTKSArIGx1bWFTV1NFO1xcblxcXG4gICAgRnhhYUZsb2F0IGVkZ2VIb3J6ID0gYWJzKGVkZ2VIb3J6MykgKyBlZGdlSG9yejQ7XFxuXFxcbiAgICBGeGFhRmxvYXQgZWRnZVZlcnQgPSBhYnMoZWRnZVZlcnQzKSArIGVkZ2VWZXJ0NDtcXG5cXFxuLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXFxuXFxcbiAgICBGeGFhRmxvYXQgc3VicGl4TldTV05FU0UgPSBsdW1hTldTVyArIGx1bWFORVNFO1xcblxcXG4gICAgRnhhYUZsb2F0IGxlbmd0aFNpZ24gPSBmeGFhUXVhbGl0eVJjcEZyYW1lLng7XFxuXFxcbiAgICBGeGFhQm9vbCBob3J6U3BhbiA9IGVkZ2VIb3J6ID49IGVkZ2VWZXJ0O1xcblxcXG4gICAgRnhhYUZsb2F0IHN1YnBpeEEgPSBzdWJwaXhOU1dFICogMi4wICsgc3VicGl4TldTV05FU0U7XFxuXFxcbi8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xcblxcXG4gICAgaWYoIWhvcnpTcGFuKSBsdW1hTiA9IGx1bWFXO1xcblxcXG4gICAgaWYoIWhvcnpTcGFuKSBsdW1hUyA9IGx1bWFFO1xcblxcXG4gICAgaWYoaG9yelNwYW4pIGxlbmd0aFNpZ24gPSBmeGFhUXVhbGl0eVJjcEZyYW1lLnk7XFxuXFxcbiAgICBGeGFhRmxvYXQgc3VicGl4QiA9IChzdWJwaXhBICogKDEuMC8xMi4wKSkgLSBsdW1hTTtcXG5cXFxuLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXFxuXFxcbiAgICBGeGFhRmxvYXQgZ3JhZGllbnROID0gbHVtYU4gLSBsdW1hTTtcXG5cXFxuICAgIEZ4YWFGbG9hdCBncmFkaWVudFMgPSBsdW1hUyAtIGx1bWFNO1xcblxcXG4gICAgRnhhYUZsb2F0IGx1bWFOTiA9IGx1bWFOICsgbHVtYU07XFxuXFxcbiAgICBGeGFhRmxvYXQgbHVtYVNTID0gbHVtYVMgKyBsdW1hTTtcXG5cXFxuICAgIEZ4YWFCb29sIHBhaXJOID0gYWJzKGdyYWRpZW50TikgPj0gYWJzKGdyYWRpZW50Uyk7XFxuXFxcbiAgICBGeGFhRmxvYXQgZ3JhZGllbnQgPSBtYXgoYWJzKGdyYWRpZW50TiksIGFicyhncmFkaWVudFMpKTtcXG5cXFxuICAgIGlmKHBhaXJOKSBsZW5ndGhTaWduID0gLWxlbmd0aFNpZ247XFxuXFxcbiAgICBGeGFhRmxvYXQgc3VicGl4QyA9IEZ4YWFTYXQoYWJzKHN1YnBpeEIpICogc3VicGl4UmNwUmFuZ2UpO1xcblxcXG4vKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cXG5cXFxuICAgIEZ4YWFGbG9hdDIgcG9zQjtcXG5cXFxuICAgIHBvc0IueCA9IHBvc00ueDtcXG5cXFxuICAgIHBvc0IueSA9IHBvc00ueTtcXG5cXFxuICAgIEZ4YWFGbG9hdDIgb2ZmTlA7XFxuXFxcbiAgICBvZmZOUC54ID0gKCFob3J6U3BhbikgPyAwLjAgOiBmeGFhUXVhbGl0eVJjcEZyYW1lLng7XFxuXFxcbiAgICBvZmZOUC55ID0gKCBob3J6U3BhbikgPyAwLjAgOiBmeGFhUXVhbGl0eVJjcEZyYW1lLnk7XFxuXFxcbiAgICBpZighaG9yelNwYW4pIHBvc0IueCArPSBsZW5ndGhTaWduICogMC41O1xcblxcXG4gICAgaWYoIGhvcnpTcGFuKSBwb3NCLnkgKz0gbGVuZ3RoU2lnbiAqIDAuNTtcXG5cXFxuLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXFxuXFxcbiAgICBGeGFhRmxvYXQyIHBvc047XFxuXFxcbiAgICBwb3NOLnggPSBwb3NCLnggLSBvZmZOUC54ICogRlhBQV9RVUFMSVRZX1AwO1xcblxcXG4gICAgcG9zTi55ID0gcG9zQi55IC0gb2ZmTlAueSAqIEZYQUFfUVVBTElUWV9QMDtcXG5cXFxuICAgIEZ4YWFGbG9hdDIgcG9zUDtcXG5cXFxuICAgIHBvc1AueCA9IHBvc0IueCArIG9mZk5QLnggKiBGWEFBX1FVQUxJVFlfUDA7XFxuXFxcbiAgICBwb3NQLnkgPSBwb3NCLnkgKyBvZmZOUC55ICogRlhBQV9RVUFMSVRZX1AwO1xcblxcXG4gICAgRnhhYUZsb2F0IHN1YnBpeEQgPSAoKC0yLjApKnN1YnBpeEMpICsgMy4wO1xcblxcXG4gICAgRnhhYUZsb2F0IGx1bWFFbmROID0gRnhhYUx1bWEoRnhhYVRleFRvcCh0ZXgsIHBvc04pKTtcXG5cXFxuICAgIEZ4YWFGbG9hdCBzdWJwaXhFID0gc3VicGl4QyAqIHN1YnBpeEM7XFxuXFxcbiAgICBGeGFhRmxvYXQgbHVtYUVuZFAgPSBGeGFhTHVtYShGeGFhVGV4VG9wKHRleCwgcG9zUCkpO1xcblxcXG4vKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cXG5cXFxuICAgIGlmKCFwYWlyTikgbHVtYU5OID0gbHVtYVNTO1xcblxcXG4gICAgRnhhYUZsb2F0IGdyYWRpZW50U2NhbGVkID0gZ3JhZGllbnQgKiAxLjAvNC4wO1xcblxcXG4gICAgRnhhYUZsb2F0IGx1bWFNTSA9IGx1bWFNIC0gbHVtYU5OICogMC41O1xcblxcXG4gICAgRnhhYUZsb2F0IHN1YnBpeEYgPSBzdWJwaXhEICogc3VicGl4RTtcXG5cXFxuICAgIEZ4YWFCb29sIGx1bWFNTFRaZXJvID0gbHVtYU1NIDwgMC4wO1xcblxcXG4vKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cXG5cXFxuICAgIGx1bWFFbmROIC09IGx1bWFOTiAqIDAuNTtcXG5cXFxuICAgIGx1bWFFbmRQIC09IGx1bWFOTiAqIDAuNTtcXG5cXFxuICAgIEZ4YWFCb29sIGRvbmVOID0gYWJzKGx1bWFFbmROKSA+PSBncmFkaWVudFNjYWxlZDtcXG5cXFxuICAgIEZ4YWFCb29sIGRvbmVQID0gYWJzKGx1bWFFbmRQKSA+PSBncmFkaWVudFNjYWxlZDtcXG5cXFxuICAgIGlmKCFkb25lTikgcG9zTi54IC09IG9mZk5QLnggKiBGWEFBX1FVQUxJVFlfUDE7XFxuXFxcbiAgICBpZighZG9uZU4pIHBvc04ueSAtPSBvZmZOUC55ICogRlhBQV9RVUFMSVRZX1AxO1xcblxcXG4gICAgRnhhYUJvb2wgZG9uZU5QID0gKCFkb25lTikgfHwgKCFkb25lUCk7XFxuXFxcbiAgICBpZighZG9uZVApIHBvc1AueCArPSBvZmZOUC54ICogRlhBQV9RVUFMSVRZX1AxO1xcblxcXG4gICAgaWYoIWRvbmVQKSBwb3NQLnkgKz0gb2ZmTlAueSAqIEZYQUFfUVVBTElUWV9QMTtcXG5cXFxuLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXFxuXFxcbiAgICBpZihkb25lTlApIHtcXG5cXFxuICAgICAgICBpZighZG9uZU4pIGx1bWFFbmROID0gRnhhYUx1bWEoRnhhYVRleFRvcCh0ZXgsIHBvc04ueHkpKTtcXG5cXFxuICAgICAgICBpZighZG9uZVApIGx1bWFFbmRQID0gRnhhYUx1bWEoRnhhYVRleFRvcCh0ZXgsIHBvc1AueHkpKTtcXG5cXFxuICAgICAgICBpZighZG9uZU4pIGx1bWFFbmROID0gbHVtYUVuZE4gLSBsdW1hTk4gKiAwLjU7XFxuXFxcbiAgICAgICAgaWYoIWRvbmVQKSBsdW1hRW5kUCA9IGx1bWFFbmRQIC0gbHVtYU5OICogMC41O1xcblxcXG4gICAgICAgIGRvbmVOID0gYWJzKGx1bWFFbmROKSA+PSBncmFkaWVudFNjYWxlZDtcXG5cXFxuICAgICAgICBkb25lUCA9IGFicyhsdW1hRW5kUCkgPj0gZ3JhZGllbnRTY2FsZWQ7XFxuXFxcbiAgICAgICAgaWYoIWRvbmVOKSBwb3NOLnggLT0gb2ZmTlAueCAqIEZYQUFfUVVBTElUWV9QMjtcXG5cXFxuICAgICAgICBpZighZG9uZU4pIHBvc04ueSAtPSBvZmZOUC55ICogRlhBQV9RVUFMSVRZX1AyO1xcblxcXG4gICAgICAgIGRvbmVOUCA9ICghZG9uZU4pIHx8ICghZG9uZVApO1xcblxcXG4gICAgICAgIGlmKCFkb25lUCkgcG9zUC54ICs9IG9mZk5QLnggKiBGWEFBX1FVQUxJVFlfUDI7XFxuXFxcbiAgICAgICAgaWYoIWRvbmVQKSBwb3NQLnkgKz0gb2ZmTlAueSAqIEZYQUFfUVVBTElUWV9QMjtcXG5cXFxuLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXFxuXFxcbiAgICAgICAgI2lmIChGWEFBX1FVQUxJVFlfUFMgPiAzKVxcblxcXG4gICAgICAgIGlmKGRvbmVOUCkge1xcblxcXG4gICAgICAgICAgICBpZighZG9uZU4pIGx1bWFFbmROID0gRnhhYUx1bWEoRnhhYVRleFRvcCh0ZXgsIHBvc04ueHkpKTtcXG5cXFxuICAgICAgICAgICAgaWYoIWRvbmVQKSBsdW1hRW5kUCA9IEZ4YWFMdW1hKEZ4YWFUZXhUb3AodGV4LCBwb3NQLnh5KSk7XFxuXFxcbiAgICAgICAgICAgIGlmKCFkb25lTikgbHVtYUVuZE4gPSBsdW1hRW5kTiAtIGx1bWFOTiAqIDAuNTtcXG5cXFxuICAgICAgICAgICAgaWYoIWRvbmVQKSBsdW1hRW5kUCA9IGx1bWFFbmRQIC0gbHVtYU5OICogMC41O1xcblxcXG4gICAgICAgICAgICBkb25lTiA9IGFicyhsdW1hRW5kTikgPj0gZ3JhZGllbnRTY2FsZWQ7XFxuXFxcbiAgICAgICAgICAgIGRvbmVQID0gYWJzKGx1bWFFbmRQKSA+PSBncmFkaWVudFNjYWxlZDtcXG5cXFxuICAgICAgICAgICAgaWYoIWRvbmVOKSBwb3NOLnggLT0gb2ZmTlAueCAqIEZYQUFfUVVBTElUWV9QMztcXG5cXFxuICAgICAgICAgICAgaWYoIWRvbmVOKSBwb3NOLnkgLT0gb2ZmTlAueSAqIEZYQUFfUVVBTElUWV9QMztcXG5cXFxuICAgICAgICAgICAgZG9uZU5QID0gKCFkb25lTikgfHwgKCFkb25lUCk7XFxuXFxcbiAgICAgICAgICAgIGlmKCFkb25lUCkgcG9zUC54ICs9IG9mZk5QLnggKiBGWEFBX1FVQUxJVFlfUDM7XFxuXFxcbiAgICAgICAgICAgIGlmKCFkb25lUCkgcG9zUC55ICs9IG9mZk5QLnkgKiBGWEFBX1FVQUxJVFlfUDM7XFxuXFxcbi8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xcblxcXG4gICAgICAgICAgICAjaWYgKEZYQUFfUVVBTElUWV9QUyA+IDQpXFxuXFxcbiAgICAgICAgICAgIGlmKGRvbmVOUCkge1xcblxcXG4gICAgICAgICAgICAgICAgaWYoIWRvbmVOKSBsdW1hRW5kTiA9IEZ4YWFMdW1hKEZ4YWFUZXhUb3AodGV4LCBwb3NOLnh5KSk7XFxuXFxcbiAgICAgICAgICAgICAgICBpZighZG9uZVApIGx1bWFFbmRQID0gRnhhYUx1bWEoRnhhYVRleFRvcCh0ZXgsIHBvc1AueHkpKTtcXG5cXFxuICAgICAgICAgICAgICAgIGlmKCFkb25lTikgbHVtYUVuZE4gPSBsdW1hRW5kTiAtIGx1bWFOTiAqIDAuNTtcXG5cXFxuICAgICAgICAgICAgICAgIGlmKCFkb25lUCkgbHVtYUVuZFAgPSBsdW1hRW5kUCAtIGx1bWFOTiAqIDAuNTtcXG5cXFxuICAgICAgICAgICAgICAgIGRvbmVOID0gYWJzKGx1bWFFbmROKSA+PSBncmFkaWVudFNjYWxlZDtcXG5cXFxuICAgICAgICAgICAgICAgIGRvbmVQID0gYWJzKGx1bWFFbmRQKSA+PSBncmFkaWVudFNjYWxlZDtcXG5cXFxuICAgICAgICAgICAgICAgIGlmKCFkb25lTikgcG9zTi54IC09IG9mZk5QLnggKiBGWEFBX1FVQUxJVFlfUDQ7XFxuXFxcbiAgICAgICAgICAgICAgICBpZighZG9uZU4pIHBvc04ueSAtPSBvZmZOUC55ICogRlhBQV9RVUFMSVRZX1A0O1xcblxcXG4gICAgICAgICAgICAgICAgZG9uZU5QID0gKCFkb25lTikgfHwgKCFkb25lUCk7XFxuXFxcbiAgICAgICAgICAgICAgICBpZighZG9uZVApIHBvc1AueCArPSBvZmZOUC54ICogRlhBQV9RVUFMSVRZX1A0O1xcblxcXG4gICAgICAgICAgICAgICAgaWYoIWRvbmVQKSBwb3NQLnkgKz0gb2ZmTlAueSAqIEZYQUFfUVVBTElUWV9QNDtcXG5cXFxuLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXFxuXFxcbiAgICAgICAgICAgICAgICAjaWYgKEZYQUFfUVVBTElUWV9QUyA+IDUpXFxuXFxcbiAgICAgICAgICAgICAgICBpZihkb25lTlApIHtcXG5cXFxuICAgICAgICAgICAgICAgICAgICBpZighZG9uZU4pIGx1bWFFbmROID0gRnhhYUx1bWEoRnhhYVRleFRvcCh0ZXgsIHBvc04ueHkpKTtcXG5cXFxuICAgICAgICAgICAgICAgICAgICBpZighZG9uZVApIGx1bWFFbmRQID0gRnhhYUx1bWEoRnhhYVRleFRvcCh0ZXgsIHBvc1AueHkpKTtcXG5cXFxuICAgICAgICAgICAgICAgICAgICBpZighZG9uZU4pIGx1bWFFbmROID0gbHVtYUVuZE4gLSBsdW1hTk4gKiAwLjU7XFxuXFxcbiAgICAgICAgICAgICAgICAgICAgaWYoIWRvbmVQKSBsdW1hRW5kUCA9IGx1bWFFbmRQIC0gbHVtYU5OICogMC41O1xcblxcXG4gICAgICAgICAgICAgICAgICAgIGRvbmVOID0gYWJzKGx1bWFFbmROKSA+PSBncmFkaWVudFNjYWxlZDtcXG5cXFxuICAgICAgICAgICAgICAgICAgICBkb25lUCA9IGFicyhsdW1hRW5kUCkgPj0gZ3JhZGllbnRTY2FsZWQ7XFxuXFxcbiAgICAgICAgICAgICAgICAgICAgaWYoIWRvbmVOKSBwb3NOLnggLT0gb2ZmTlAueCAqIEZYQUFfUVVBTElUWV9QNTtcXG5cXFxuICAgICAgICAgICAgICAgICAgICBpZighZG9uZU4pIHBvc04ueSAtPSBvZmZOUC55ICogRlhBQV9RVUFMSVRZX1A1O1xcblxcXG4gICAgICAgICAgICAgICAgICAgIGRvbmVOUCA9ICghZG9uZU4pIHx8ICghZG9uZVApO1xcblxcXG4gICAgICAgICAgICAgICAgICAgIGlmKCFkb25lUCkgcG9zUC54ICs9IG9mZk5QLnggKiBGWEFBX1FVQUxJVFlfUDU7XFxuXFxcbiAgICAgICAgICAgICAgICAgICAgaWYoIWRvbmVQKSBwb3NQLnkgKz0gb2ZmTlAueSAqIEZYQUFfUVVBTElUWV9QNTtcXG5cXFxuLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXFxuXFxcbiAgICAgICAgICAgICAgICAgICAgI2lmIChGWEFBX1FVQUxJVFlfUFMgPiA2KVxcblxcXG4gICAgICAgICAgICAgICAgICAgIGlmKGRvbmVOUCkge1xcblxcXG4gICAgICAgICAgICAgICAgICAgICAgICBpZighZG9uZU4pIGx1bWFFbmROID0gRnhhYUx1bWEoRnhhYVRleFRvcCh0ZXgsIHBvc04ueHkpKTtcXG5cXFxuICAgICAgICAgICAgICAgICAgICAgICAgaWYoIWRvbmVQKSBsdW1hRW5kUCA9IEZ4YWFMdW1hKEZ4YWFUZXhUb3AodGV4LCBwb3NQLnh5KSk7XFxuXFxcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmKCFkb25lTikgbHVtYUVuZE4gPSBsdW1hRW5kTiAtIGx1bWFOTiAqIDAuNTtcXG5cXFxuICAgICAgICAgICAgICAgICAgICAgICAgaWYoIWRvbmVQKSBsdW1hRW5kUCA9IGx1bWFFbmRQIC0gbHVtYU5OICogMC41O1xcblxcXG4gICAgICAgICAgICAgICAgICAgICAgICBkb25lTiA9IGFicyhsdW1hRW5kTikgPj0gZ3JhZGllbnRTY2FsZWQ7XFxuXFxcbiAgICAgICAgICAgICAgICAgICAgICAgIGRvbmVQID0gYWJzKGx1bWFFbmRQKSA+PSBncmFkaWVudFNjYWxlZDtcXG5cXFxuICAgICAgICAgICAgICAgICAgICAgICAgaWYoIWRvbmVOKSBwb3NOLnggLT0gb2ZmTlAueCAqIEZYQUFfUVVBTElUWV9QNjtcXG5cXFxuICAgICAgICAgICAgICAgICAgICAgICAgaWYoIWRvbmVOKSBwb3NOLnkgLT0gb2ZmTlAueSAqIEZYQUFfUVVBTElUWV9QNjtcXG5cXFxuICAgICAgICAgICAgICAgICAgICAgICAgZG9uZU5QID0gKCFkb25lTikgfHwgKCFkb25lUCk7XFxuXFxcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmKCFkb25lUCkgcG9zUC54ICs9IG9mZk5QLnggKiBGWEFBX1FVQUxJVFlfUDY7XFxuXFxcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmKCFkb25lUCkgcG9zUC55ICs9IG9mZk5QLnkgKiBGWEFBX1FVQUxJVFlfUDY7XFxuXFxcbi8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xcblxcXG4gICAgICAgICAgICAgICAgICAgICAgICAjaWYgKEZYQUFfUVVBTElUWV9QUyA+IDcpXFxuXFxcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmKGRvbmVOUCkge1xcblxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYoIWRvbmVOKSBsdW1hRW5kTiA9IEZ4YWFMdW1hKEZ4YWFUZXhUb3AodGV4LCBwb3NOLnh5KSk7XFxuXFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZighZG9uZVApIGx1bWFFbmRQID0gRnhhYUx1bWEoRnhhYVRleFRvcCh0ZXgsIHBvc1AueHkpKTtcXG5cXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmKCFkb25lTikgbHVtYUVuZE4gPSBsdW1hRW5kTiAtIGx1bWFOTiAqIDAuNTtcXG5cXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmKCFkb25lUCkgbHVtYUVuZFAgPSBsdW1hRW5kUCAtIGx1bWFOTiAqIDAuNTtcXG5cXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRvbmVOID0gYWJzKGx1bWFFbmROKSA+PSBncmFkaWVudFNjYWxlZDtcXG5cXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRvbmVQID0gYWJzKGx1bWFFbmRQKSA+PSBncmFkaWVudFNjYWxlZDtcXG5cXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmKCFkb25lTikgcG9zTi54IC09IG9mZk5QLnggKiBGWEFBX1FVQUxJVFlfUDc7XFxuXFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZighZG9uZU4pIHBvc04ueSAtPSBvZmZOUC55ICogRlhBQV9RVUFMSVRZX1A3O1xcblxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZG9uZU5QID0gKCFkb25lTikgfHwgKCFkb25lUCk7XFxuXFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZighZG9uZVApIHBvc1AueCArPSBvZmZOUC54ICogRlhBQV9RVUFMSVRZX1A3O1xcblxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYoIWRvbmVQKSBwb3NQLnkgKz0gb2ZmTlAueSAqIEZYQUFfUVVBTElUWV9QNztcXG5cXFxuLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXFxuXFxcbiAgICAjaWYgKEZYQUFfUVVBTElUWV9QUyA+IDgpXFxuXFxcbiAgICBpZihkb25lTlApIHtcXG5cXFxuICAgICAgICBpZighZG9uZU4pIGx1bWFFbmROID0gRnhhYUx1bWEoRnhhYVRleFRvcCh0ZXgsIHBvc04ueHkpKTtcXG5cXFxuICAgICAgICBpZighZG9uZVApIGx1bWFFbmRQID0gRnhhYUx1bWEoRnhhYVRleFRvcCh0ZXgsIHBvc1AueHkpKTtcXG5cXFxuICAgICAgICBpZighZG9uZU4pIGx1bWFFbmROID0gbHVtYUVuZE4gLSBsdW1hTk4gKiAwLjU7XFxuXFxcbiAgICAgICAgaWYoIWRvbmVQKSBsdW1hRW5kUCA9IGx1bWFFbmRQIC0gbHVtYU5OICogMC41O1xcblxcXG4gICAgICAgIGRvbmVOID0gYWJzKGx1bWFFbmROKSA+PSBncmFkaWVudFNjYWxlZDtcXG5cXFxuICAgICAgICBkb25lUCA9IGFicyhsdW1hRW5kUCkgPj0gZ3JhZGllbnRTY2FsZWQ7XFxuXFxcbiAgICAgICAgaWYoIWRvbmVOKSBwb3NOLnggLT0gb2ZmTlAueCAqIEZYQUFfUVVBTElUWV9QODtcXG5cXFxuICAgICAgICBpZighZG9uZU4pIHBvc04ueSAtPSBvZmZOUC55ICogRlhBQV9RVUFMSVRZX1A4O1xcblxcXG4gICAgICAgIGRvbmVOUCA9ICghZG9uZU4pIHx8ICghZG9uZVApO1xcblxcXG4gICAgICAgIGlmKCFkb25lUCkgcG9zUC54ICs9IG9mZk5QLnggKiBGWEFBX1FVQUxJVFlfUDg7XFxuXFxcbiAgICAgICAgaWYoIWRvbmVQKSBwb3NQLnkgKz0gb2ZmTlAueSAqIEZYQUFfUVVBTElUWV9QODtcXG5cXFxuLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXFxuXFxcbiAgICAgICAgI2lmIChGWEFBX1FVQUxJVFlfUFMgPiA5KVxcblxcXG4gICAgICAgIGlmKGRvbmVOUCkge1xcblxcXG4gICAgICAgICAgICBpZighZG9uZU4pIGx1bWFFbmROID0gRnhhYUx1bWEoRnhhYVRleFRvcCh0ZXgsIHBvc04ueHkpKTtcXG5cXFxuICAgICAgICAgICAgaWYoIWRvbmVQKSBsdW1hRW5kUCA9IEZ4YWFMdW1hKEZ4YWFUZXhUb3AodGV4LCBwb3NQLnh5KSk7XFxuXFxcbiAgICAgICAgICAgIGlmKCFkb25lTikgbHVtYUVuZE4gPSBsdW1hRW5kTiAtIGx1bWFOTiAqIDAuNTtcXG5cXFxuICAgICAgICAgICAgaWYoIWRvbmVQKSBsdW1hRW5kUCA9IGx1bWFFbmRQIC0gbHVtYU5OICogMC41O1xcblxcXG4gICAgICAgICAgICBkb25lTiA9IGFicyhsdW1hRW5kTikgPj0gZ3JhZGllbnRTY2FsZWQ7XFxuXFxcbiAgICAgICAgICAgIGRvbmVQID0gYWJzKGx1bWFFbmRQKSA+PSBncmFkaWVudFNjYWxlZDtcXG5cXFxuICAgICAgICAgICAgaWYoIWRvbmVOKSBwb3NOLnggLT0gb2ZmTlAueCAqIEZYQUFfUVVBTElUWV9QOTtcXG5cXFxuICAgICAgICAgICAgaWYoIWRvbmVOKSBwb3NOLnkgLT0gb2ZmTlAueSAqIEZYQUFfUVVBTElUWV9QOTtcXG5cXFxuICAgICAgICAgICAgZG9uZU5QID0gKCFkb25lTikgfHwgKCFkb25lUCk7XFxuXFxcbiAgICAgICAgICAgIGlmKCFkb25lUCkgcG9zUC54ICs9IG9mZk5QLnggKiBGWEFBX1FVQUxJVFlfUDk7XFxuXFxcbiAgICAgICAgICAgIGlmKCFkb25lUCkgcG9zUC55ICs9IG9mZk5QLnkgKiBGWEFBX1FVQUxJVFlfUDk7XFxuXFxcbi8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xcblxcXG4gICAgICAgICAgICAjaWYgKEZYQUFfUVVBTElUWV9QUyA+IDEwKVxcblxcXG4gICAgICAgICAgICBpZihkb25lTlApIHtcXG5cXFxuICAgICAgICAgICAgICAgIGlmKCFkb25lTikgbHVtYUVuZE4gPSBGeGFhTHVtYShGeGFhVGV4VG9wKHRleCwgcG9zTi54eSkpO1xcblxcXG4gICAgICAgICAgICAgICAgaWYoIWRvbmVQKSBsdW1hRW5kUCA9IEZ4YWFMdW1hKEZ4YWFUZXhUb3AodGV4LCBwb3NQLnh5KSk7XFxuXFxcbiAgICAgICAgICAgICAgICBpZighZG9uZU4pIGx1bWFFbmROID0gbHVtYUVuZE4gLSBsdW1hTk4gKiAwLjU7XFxuXFxcbiAgICAgICAgICAgICAgICBpZighZG9uZVApIGx1bWFFbmRQID0gbHVtYUVuZFAgLSBsdW1hTk4gKiAwLjU7XFxuXFxcbiAgICAgICAgICAgICAgICBkb25lTiA9IGFicyhsdW1hRW5kTikgPj0gZ3JhZGllbnRTY2FsZWQ7XFxuXFxcbiAgICAgICAgICAgICAgICBkb25lUCA9IGFicyhsdW1hRW5kUCkgPj0gZ3JhZGllbnRTY2FsZWQ7XFxuXFxcbiAgICAgICAgICAgICAgICBpZighZG9uZU4pIHBvc04ueCAtPSBvZmZOUC54ICogRlhBQV9RVUFMSVRZX1AxMDtcXG5cXFxuICAgICAgICAgICAgICAgIGlmKCFkb25lTikgcG9zTi55IC09IG9mZk5QLnkgKiBGWEFBX1FVQUxJVFlfUDEwO1xcblxcXG4gICAgICAgICAgICAgICAgZG9uZU5QID0gKCFkb25lTikgfHwgKCFkb25lUCk7XFxuXFxcbiAgICAgICAgICAgICAgICBpZighZG9uZVApIHBvc1AueCArPSBvZmZOUC54ICogRlhBQV9RVUFMSVRZX1AxMDtcXG5cXFxuICAgICAgICAgICAgICAgIGlmKCFkb25lUCkgcG9zUC55ICs9IG9mZk5QLnkgKiBGWEFBX1FVQUxJVFlfUDEwO1xcblxcXG4vKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cXG5cXFxuICAgICAgICAgICAgICAgICNpZiAoRlhBQV9RVUFMSVRZX1BTID4gMTEpXFxuXFxcbiAgICAgICAgICAgICAgICBpZihkb25lTlApIHtcXG5cXFxuICAgICAgICAgICAgICAgICAgICBpZighZG9uZU4pIGx1bWFFbmROID0gRnhhYUx1bWEoRnhhYVRleFRvcCh0ZXgsIHBvc04ueHkpKTtcXG5cXFxuICAgICAgICAgICAgICAgICAgICBpZighZG9uZVApIGx1bWFFbmRQID0gRnhhYUx1bWEoRnhhYVRleFRvcCh0ZXgsIHBvc1AueHkpKTtcXG5cXFxuICAgICAgICAgICAgICAgICAgICBpZighZG9uZU4pIGx1bWFFbmROID0gbHVtYUVuZE4gLSBsdW1hTk4gKiAwLjU7XFxuXFxcbiAgICAgICAgICAgICAgICAgICAgaWYoIWRvbmVQKSBsdW1hRW5kUCA9IGx1bWFFbmRQIC0gbHVtYU5OICogMC41O1xcblxcXG4gICAgICAgICAgICAgICAgICAgIGRvbmVOID0gYWJzKGx1bWFFbmROKSA+PSBncmFkaWVudFNjYWxlZDtcXG5cXFxuICAgICAgICAgICAgICAgICAgICBkb25lUCA9IGFicyhsdW1hRW5kUCkgPj0gZ3JhZGllbnRTY2FsZWQ7XFxuXFxcbiAgICAgICAgICAgICAgICAgICAgaWYoIWRvbmVOKSBwb3NOLnggLT0gb2ZmTlAueCAqIEZYQUFfUVVBTElUWV9QMTE7XFxuXFxcbiAgICAgICAgICAgICAgICAgICAgaWYoIWRvbmVOKSBwb3NOLnkgLT0gb2ZmTlAueSAqIEZYQUFfUVVBTElUWV9QMTE7XFxuXFxcbiAgICAgICAgICAgICAgICAgICAgZG9uZU5QID0gKCFkb25lTikgfHwgKCFkb25lUCk7XFxuXFxcbiAgICAgICAgICAgICAgICAgICAgaWYoIWRvbmVQKSBwb3NQLnggKz0gb2ZmTlAueCAqIEZYQUFfUVVBTElUWV9QMTE7XFxuXFxcbiAgICAgICAgICAgICAgICAgICAgaWYoIWRvbmVQKSBwb3NQLnkgKz0gb2ZmTlAueSAqIEZYQUFfUVVBTElUWV9QMTE7XFxuXFxcbi8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xcblxcXG4gICAgICAgICAgICAgICAgICAgICNpZiAoRlhBQV9RVUFMSVRZX1BTID4gMTIpXFxuXFxcbiAgICAgICAgICAgICAgICAgICAgaWYoZG9uZU5QKSB7XFxuXFxcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmKCFkb25lTikgbHVtYUVuZE4gPSBGeGFhTHVtYShGeGFhVGV4VG9wKHRleCwgcG9zTi54eSkpO1xcblxcXG4gICAgICAgICAgICAgICAgICAgICAgICBpZighZG9uZVApIGx1bWFFbmRQID0gRnhhYUx1bWEoRnhhYVRleFRvcCh0ZXgsIHBvc1AueHkpKTtcXG5cXFxuICAgICAgICAgICAgICAgICAgICAgICAgaWYoIWRvbmVOKSBsdW1hRW5kTiA9IGx1bWFFbmROIC0gbHVtYU5OICogMC41O1xcblxcXG4gICAgICAgICAgICAgICAgICAgICAgICBpZighZG9uZVApIGx1bWFFbmRQID0gbHVtYUVuZFAgLSBsdW1hTk4gKiAwLjU7XFxuXFxcbiAgICAgICAgICAgICAgICAgICAgICAgIGRvbmVOID0gYWJzKGx1bWFFbmROKSA+PSBncmFkaWVudFNjYWxlZDtcXG5cXFxuICAgICAgICAgICAgICAgICAgICAgICAgZG9uZVAgPSBhYnMobHVtYUVuZFApID49IGdyYWRpZW50U2NhbGVkO1xcblxcXG4gICAgICAgICAgICAgICAgICAgICAgICBpZighZG9uZU4pIHBvc04ueCAtPSBvZmZOUC54ICogRlhBQV9RVUFMSVRZX1AxMjtcXG5cXFxuICAgICAgICAgICAgICAgICAgICAgICAgaWYoIWRvbmVOKSBwb3NOLnkgLT0gb2ZmTlAueSAqIEZYQUFfUVVBTElUWV9QMTI7XFxuXFxcbiAgICAgICAgICAgICAgICAgICAgICAgIGRvbmVOUCA9ICghZG9uZU4pIHx8ICghZG9uZVApO1xcblxcXG4gICAgICAgICAgICAgICAgICAgICAgICBpZighZG9uZVApIHBvc1AueCArPSBvZmZOUC54ICogRlhBQV9RVUFMSVRZX1AxMjtcXG5cXFxuICAgICAgICAgICAgICAgICAgICAgICAgaWYoIWRvbmVQKSBwb3NQLnkgKz0gb2ZmTlAueSAqIEZYQUFfUVVBTElUWV9QMTI7XFxuXFxcbi8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xcblxcXG4gICAgICAgICAgICAgICAgICAgIH1cXG5cXFxuICAgICAgICAgICAgICAgICAgICAjZW5kaWZcXG5cXFxuLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXFxuXFxcbiAgICAgICAgICAgICAgICB9XFxuXFxcbiAgICAgICAgICAgICAgICAjZW5kaWZcXG5cXFxuLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXFxuXFxcbiAgICAgICAgICAgIH1cXG5cXFxuICAgICAgICAgICAgI2VuZGlmXFxuXFxcbi8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xcblxcXG4gICAgICAgIH1cXG5cXFxuICAgICAgICAjZW5kaWZcXG5cXFxuLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXFxuXFxcbiAgICB9XFxuXFxcbiAgICAjZW5kaWZcXG5cXFxuLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXFxuXFxcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cXG5cXFxuICAgICAgICAgICAgICAgICAgICAgICAgI2VuZGlmXFxuXFxcbi8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xcblxcXG4gICAgICAgICAgICAgICAgICAgIH1cXG5cXFxuICAgICAgICAgICAgICAgICAgICAjZW5kaWZcXG5cXFxuLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXFxuXFxcbiAgICAgICAgICAgICAgICB9XFxuXFxcbiAgICAgICAgICAgICAgICAjZW5kaWZcXG5cXFxuLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXFxuXFxcbiAgICAgICAgICAgIH1cXG5cXFxuICAgICAgICAgICAgI2VuZGlmXFxuXFxcbi8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xcblxcXG4gICAgICAgIH1cXG5cXFxuICAgICAgICAjZW5kaWZcXG5cXFxuLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXFxuXFxcbiAgICB9XFxuXFxcbi8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xcblxcXG4gICAgRnhhYUZsb2F0IGRzdE4gPSBwb3NNLnggLSBwb3NOLng7XFxuXFxcbiAgICBGeGFhRmxvYXQgZHN0UCA9IHBvc1AueCAtIHBvc00ueDtcXG5cXFxuICAgIGlmKCFob3J6U3BhbikgZHN0TiA9IHBvc00ueSAtIHBvc04ueTtcXG5cXFxuICAgIGlmKCFob3J6U3BhbikgZHN0UCA9IHBvc1AueSAtIHBvc00ueTtcXG5cXFxuLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXFxuXFxcbiAgICBGeGFhQm9vbCBnb29kU3Bhbk4gPSAobHVtYUVuZE4gPCAwLjApICE9IGx1bWFNTFRaZXJvO1xcblxcXG4gICAgRnhhYUZsb2F0IHNwYW5MZW5ndGggPSAoZHN0UCArIGRzdE4pO1xcblxcXG4gICAgRnhhYUJvb2wgZ29vZFNwYW5QID0gKGx1bWFFbmRQIDwgMC4wKSAhPSBsdW1hTUxUWmVybztcXG5cXFxuICAgIEZ4YWFGbG9hdCBzcGFuTGVuZ3RoUmNwID0gMS4wL3NwYW5MZW5ndGg7XFxuXFxcbi8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xcblxcXG4gICAgRnhhYUJvb2wgZGlyZWN0aW9uTiA9IGRzdE4gPCBkc3RQO1xcblxcXG4gICAgRnhhYUZsb2F0IGRzdCA9IG1pbihkc3ROLCBkc3RQKTtcXG5cXFxuICAgIEZ4YWFCb29sIGdvb2RTcGFuID0gZGlyZWN0aW9uTiA/IGdvb2RTcGFuTiA6IGdvb2RTcGFuUDtcXG5cXFxuICAgIEZ4YWFGbG9hdCBzdWJwaXhHID0gc3VicGl4RiAqIHN1YnBpeEY7XFxuXFxcbiAgICBGeGFhRmxvYXQgcGl4ZWxPZmZzZXQgPSAoZHN0ICogKC1zcGFuTGVuZ3RoUmNwKSkgKyAwLjU7XFxuXFxcbiAgICBGeGFhRmxvYXQgc3VicGl4SCA9IHN1YnBpeEcgKiBmeGFhUXVhbGl0eVN1YnBpeDtcXG5cXFxuLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXFxuXFxcbiAgICBGeGFhRmxvYXQgcGl4ZWxPZmZzZXRHb29kID0gZ29vZFNwYW4gPyBwaXhlbE9mZnNldCA6IDAuMDtcXG5cXFxuICAgIEZ4YWFGbG9hdCBwaXhlbE9mZnNldFN1YnBpeCA9IG1heChwaXhlbE9mZnNldEdvb2QsIHN1YnBpeEgpO1xcblxcXG4gICAgaWYoIWhvcnpTcGFuKSBwb3NNLnggKz0gcGl4ZWxPZmZzZXRTdWJwaXggKiBsZW5ndGhTaWduO1xcblxcXG4gICAgaWYoIGhvcnpTcGFuKSBwb3NNLnkgKz0gcGl4ZWxPZmZzZXRTdWJwaXggKiBsZW5ndGhTaWduO1xcblxcXG4gICAgcmV0dXJuIEZ4YWFGbG9hdDQoRnhhYVRleFRvcCh0ZXgsIHBvc00pLnh5eiwgbHVtYU0pO1xcblxcXG59XFxuXFxcblwiO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///61333\n")}}]);