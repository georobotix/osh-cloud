"use strict";(self["webpackChunkvue3_webpack5"]=self["webpackChunkvue3_webpack5"]||[]).push([[8689],{29826:function(__unused_webpack_module,__webpack_exports__,__webpack_require__){eval("\n// EXPORTS\n__webpack_require__.d(__webpack_exports__, {\n  \"Z\": function() { return /* binding */ TileLayer; }\n});\n\n// EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/esm/defineProperty.js\nvar defineProperty = __webpack_require__(82482);\n// EXTERNAL MODULE: ./node_modules/@deck.gl/core/dist/esm/lib/composite-layer.js\nvar composite_layer = __webpack_require__(78918);\n// EXTERNAL MODULE: ./node_modules/@deck.gl/core/dist/esm/utils/flatten.js\nvar flatten = __webpack_require__(61855);\n// EXTERNAL MODULE: ./node_modules/@deck.gl/layers/dist/esm/utils.js\nvar utils = __webpack_require__(98452);\n;// CONCATENATED MODULE: ./node_modules/@deck.gl/layers/dist/esm/geojson-layer/geojson-binary.js\nfunction binaryToFeatureForAccesor(data, index) {\n  if (!data) {\n    return null;\n  }\n\n  const featureIndex = 'startIndices' in data ? data.startIndices[index] : index;\n  const geometryIndex = data.featureIds.value[featureIndex];\n\n  if (featureIndex !== -1) {\n    return getPropertiesForIndex(data, geometryIndex, featureIndex);\n  }\n\n  return null;\n}\n\nfunction getPropertiesForIndex(data, propertiesIndex, numericPropsIndex) {\n  const feature = {\n    properties: { ...data.properties[propertiesIndex]\n    }\n  };\n\n  for (const prop in data.numericProps) {\n    feature.properties[prop] = data.numericProps[prop].value[numericPropsIndex];\n  }\n\n  return feature;\n}\n\nfunction calculatePickingColors(geojsonBinary, encodePickingColor) {\n  const pickingColors = {\n    points: null,\n    lines: null,\n    polygons: null\n  };\n\n  for (const key in pickingColors) {\n    const featureIds = geojsonBinary[key].globalFeatureIds.value;\n    pickingColors[key] = new Uint8ClampedArray(featureIds.length * 3);\n    const pickingColor = [];\n\n    for (let i = 0; i < featureIds.length; i++) {\n      encodePickingColor(featureIds[i], pickingColor);\n      pickingColors[key][i * 3 + 0] = pickingColor[0];\n      pickingColors[key][i * 3 + 1] = pickingColor[1];\n      pickingColors[key][i * 3 + 2] = pickingColor[2];\n    }\n  }\n\n  return pickingColors;\n}\n//# sourceMappingURL=geojson-binary.js.map\n// EXTERNAL MODULE: ./node_modules/@deck.gl/layers/dist/esm/icon-layer/icon-layer.js + 3 modules\nvar icon_layer = __webpack_require__(13418);\n// EXTERNAL MODULE: ./node_modules/@deck.gl/core/dist/esm/lib/layer.js + 3 modules\nvar lib_layer = __webpack_require__(52447);\n// EXTERNAL MODULE: ./node_modules/@deck.gl/core/dist/esm/shaderlib/project32/project32.js\nvar project32 = __webpack_require__(93844);\n// EXTERNAL MODULE: ./node_modules/@deck.gl/core/dist/esm/shaderlib/picking/picking.js\nvar picking = __webpack_require__(43844);\n// EXTERNAL MODULE: ./node_modules/@deck.gl/core/dist/esm/lib/constants.js\nvar constants = __webpack_require__(24088);\n// EXTERNAL MODULE: ./node_modules/@luma.gl/engine/dist/esm/lib/model.js + 1 modules\nvar model = __webpack_require__(80210);\n// EXTERNAL MODULE: ./node_modules/@luma.gl/engine/dist/esm/geometry/geometry.js\nvar geometry = __webpack_require__(53982);\n;// CONCATENATED MODULE: ./node_modules/@deck.gl/layers/dist/esm/scatterplot-layer/scatterplot-layer-vertex.glsl.js\n/* harmony default export */ var scatterplot_layer_vertex_glsl = (\"#define SHADER_NAME scatterplot-layer-vertex-shader\\n\\nattribute vec3 positions;\\n\\nattribute vec3 instancePositions;\\nattribute vec3 instancePositions64Low;\\nattribute float instanceRadius;\\nattribute float instanceLineWidths;\\nattribute vec4 instanceFillColors;\\nattribute vec4 instanceLineColors;\\nattribute vec3 instancePickingColors;\\n\\nuniform float opacity;\\nuniform float radiusScale;\\nuniform float radiusMinPixels;\\nuniform float radiusMaxPixels;\\nuniform float lineWidthScale;\\nuniform float lineWidthMinPixels;\\nuniform float lineWidthMaxPixels;\\nuniform float stroked;\\nuniform bool filled;\\nuniform bool antialiasing;\\nuniform bool billboard;\\nuniform int radiusUnits;\\nuniform int lineWidthUnits;\\n\\nvarying vec4 vFillColor;\\nvarying vec4 vLineColor;\\nvarying vec2 unitPosition;\\nvarying float innerUnitRadius;\\nvarying float outerRadiusPixels;\\n\\n\\nvoid main(void) {\\n  geometry.worldPosition = instancePositions;\\n  outerRadiusPixels = clamp(\\n    project_size_to_pixel(radiusScale * instanceRadius, radiusUnits),\\n    radiusMinPixels, radiusMaxPixels\\n  );\\n  float lineWidthPixels = clamp(\\n    project_size_to_pixel(lineWidthScale * instanceLineWidths, lineWidthUnits),\\n    lineWidthMinPixels, lineWidthMaxPixels\\n  );\\n  outerRadiusPixels += stroked * lineWidthPixels / 2.0;\\n  float edgePadding = antialiasing ? (outerRadiusPixels + SMOOTH_EDGE_RADIUS) / outerRadiusPixels : 1.0;\\n  unitPosition = edgePadding * positions.xy;\\n  geometry.uv = unitPosition;\\n  geometry.pickingColor = instancePickingColors;\\n\\n  innerUnitRadius = 1.0 - stroked * lineWidthPixels / outerRadiusPixels;\\n  \\n  if (billboard) {\\n    gl_Position = project_position_to_clipspace(instancePositions, instancePositions64Low, vec3(0.0), geometry.position);\\n    DECKGL_FILTER_GL_POSITION(gl_Position, geometry);\\n    vec3 offset = edgePadding * positions * outerRadiusPixels;\\n    DECKGL_FILTER_SIZE(offset, geometry);\\n    gl_Position.xy += project_pixel_size_to_clipspace(offset.xy);\\n  } else {\\n    vec3 offset = edgePadding * positions * project_pixel_size(outerRadiusPixels);\\n    DECKGL_FILTER_SIZE(offset, geometry);\\n    gl_Position = project_position_to_clipspace(instancePositions, instancePositions64Low, offset, geometry.position);\\n    DECKGL_FILTER_GL_POSITION(gl_Position, geometry);\\n  }\\n  vFillColor = vec4(instanceFillColors.rgb, instanceFillColors.a * opacity);\\n  DECKGL_FILTER_COLOR(vFillColor, geometry);\\n  vLineColor = vec4(instanceLineColors.rgb, instanceLineColors.a * opacity);\\n  DECKGL_FILTER_COLOR(vLineColor, geometry);\\n}\\n\");\n//# sourceMappingURL=scatterplot-layer-vertex.glsl.js.map\n;// CONCATENATED MODULE: ./node_modules/@deck.gl/layers/dist/esm/scatterplot-layer/scatterplot-layer-fragment.glsl.js\n/* harmony default export */ var scatterplot_layer_fragment_glsl = (\"#define SHADER_NAME scatterplot-layer-fragment-shader\\n\\nprecision highp float;\\n\\nuniform bool filled;\\nuniform float stroked;\\nuniform bool antialiasing;\\n\\nvarying vec4 vFillColor;\\nvarying vec4 vLineColor;\\nvarying vec2 unitPosition;\\nvarying float innerUnitRadius;\\nvarying float outerRadiusPixels;\\n\\nvoid main(void) {\\n  geometry.uv = unitPosition;\\n\\n  float distToCenter = length(unitPosition) * outerRadiusPixels;\\n  float inCircle = antialiasing ? \\n    smoothedge(distToCenter, outerRadiusPixels) : \\n    step(distToCenter, outerRadiusPixels);\\n\\n  if (inCircle == 0.0) {\\n    discard;\\n  }\\n\\n  if (stroked > 0.5) {\\n    float isLine = antialiasing ? \\n      smoothedge(innerUnitRadius * outerRadiusPixels, distToCenter) :\\n      step(innerUnitRadius * outerRadiusPixels, distToCenter);\\n\\n    if (filled) {\\n      gl_FragColor = mix(vFillColor, vLineColor, isLine);\\n    } else {\\n      if (isLine == 0.0) {\\n        discard;\\n      }\\n      gl_FragColor = vec4(vLineColor.rgb, vLineColor.a * isLine);\\n    }\\n  } else if (filled) {\\n    gl_FragColor = vFillColor;\\n  } else {\\n    discard;\\n  }\\n\\n  gl_FragColor.a *= inCircle;\\n  DECKGL_FILTER_COLOR(gl_FragColor, geometry);\\n}\\n\");\n//# sourceMappingURL=scatterplot-layer-fragment.glsl.js.map\n;// CONCATENATED MODULE: ./node_modules/@deck.gl/layers/dist/esm/scatterplot-layer/scatterplot-layer.js\n\n\n\n\n\nconst DEFAULT_COLOR = [0, 0, 0, 255];\nconst defaultProps = {\n  radiusUnits: 'meters',\n  radiusScale: {\n    type: 'number',\n    min: 0,\n    value: 1\n  },\n  radiusMinPixels: {\n    type: 'number',\n    min: 0,\n    value: 0\n  },\n  radiusMaxPixels: {\n    type: 'number',\n    min: 0,\n    value: Number.MAX_SAFE_INTEGER\n  },\n  lineWidthUnits: 'meters',\n  lineWidthScale: {\n    type: 'number',\n    min: 0,\n    value: 1\n  },\n  lineWidthMinPixels: {\n    type: 'number',\n    min: 0,\n    value: 0\n  },\n  lineWidthMaxPixels: {\n    type: 'number',\n    min: 0,\n    value: Number.MAX_SAFE_INTEGER\n  },\n  stroked: false,\n  filled: true,\n  billboard: false,\n  antialiasing: true,\n  getPosition: {\n    type: 'accessor',\n    value: x => x.position\n  },\n  getRadius: {\n    type: 'accessor',\n    value: 1\n  },\n  getFillColor: {\n    type: 'accessor',\n    value: DEFAULT_COLOR\n  },\n  getLineColor: {\n    type: 'accessor',\n    value: DEFAULT_COLOR\n  },\n  getLineWidth: {\n    type: 'accessor',\n    value: 1\n  },\n  strokeWidth: {\n    deprecatedFor: 'getLineWidth'\n  },\n  outline: {\n    deprecatedFor: 'stroked'\n  },\n  getColor: {\n    deprecatedFor: ['getFillColor', 'getLineColor']\n  }\n};\nclass ScatterplotLayer extends lib_layer/* default */.Z {\n  getShaders() {\n    return super.getShaders({\n      vs: scatterplot_layer_vertex_glsl,\n      fs: scatterplot_layer_fragment_glsl,\n      modules: [project32/* default */.Z, picking/* default */.Z]\n    });\n  }\n\n  initializeState() {\n    this.getAttributeManager().addInstanced({\n      instancePositions: {\n        size: 3,\n        type: 5130,\n        fp64: this.use64bitPositions(),\n        transition: true,\n        accessor: 'getPosition'\n      },\n      instanceRadius: {\n        size: 1,\n        transition: true,\n        accessor: 'getRadius',\n        defaultValue: 1\n      },\n      instanceFillColors: {\n        size: this.props.colorFormat.length,\n        transition: true,\n        normalized: true,\n        type: 5121,\n        accessor: 'getFillColor',\n        defaultValue: [0, 0, 0, 255]\n      },\n      instanceLineColors: {\n        size: this.props.colorFormat.length,\n        transition: true,\n        normalized: true,\n        type: 5121,\n        accessor: 'getLineColor',\n        defaultValue: [0, 0, 0, 255]\n      },\n      instanceLineWidths: {\n        size: 1,\n        transition: true,\n        accessor: 'getLineWidth',\n        defaultValue: 1\n      }\n    });\n  }\n\n  updateState(params) {\n    super.updateState(params);\n\n    if (params.changeFlags.extensionsChanged) {\n      var _this$state$model;\n\n      const {\n        gl\n      } = this.context;\n      (_this$state$model = this.state.model) === null || _this$state$model === void 0 ? void 0 : _this$state$model.delete();\n      this.state.model = this._getModel(gl);\n      this.getAttributeManager().invalidateAll();\n    }\n  }\n\n  draw({\n    uniforms\n  }) {\n    const {\n      radiusUnits,\n      radiusScale,\n      radiusMinPixels,\n      radiusMaxPixels,\n      stroked,\n      filled,\n      billboard,\n      antialiasing,\n      lineWidthUnits,\n      lineWidthScale,\n      lineWidthMinPixels,\n      lineWidthMaxPixels\n    } = this.props;\n    this.state.model.setUniforms(uniforms).setUniforms({\n      stroked: stroked ? 1 : 0,\n      filled,\n      billboard,\n      antialiasing,\n      radiusUnits: constants/* UNIT */.iI[radiusUnits],\n      radiusScale,\n      radiusMinPixels,\n      radiusMaxPixels,\n      lineWidthUnits: constants/* UNIT */.iI[lineWidthUnits],\n      lineWidthScale,\n      lineWidthMinPixels,\n      lineWidthMaxPixels\n    }).draw();\n  }\n\n  _getModel(gl) {\n    const positions = [-1, -1, 0, 1, -1, 0, 1, 1, 0, -1, 1, 0];\n    return new model/* default */.Z(gl, { ...this.getShaders(),\n      id: this.props.id,\n      geometry: new geometry/* default */.Z({\n        drawMode: 6,\n        vertexCount: 4,\n        attributes: {\n          positions: {\n            size: 3,\n            value: new Float32Array(positions)\n          }\n        }\n      }),\n      isInstanced: true\n    });\n  }\n\n}\n\n(0,defineProperty/* default */.Z)(ScatterplotLayer, \"defaultProps\", defaultProps);\n\n(0,defineProperty/* default */.Z)(ScatterplotLayer, \"layerName\", 'ScatterplotLayer');\n//# sourceMappingURL=scatterplot-layer.js.map\n// EXTERNAL MODULE: ./node_modules/@deck.gl/core/dist/esm/utils/log.js\nvar log = __webpack_require__(80744);\n// EXTERNAL MODULE: ./node_modules/@deck.gl/core/dist/esm/utils/iterable-utils.js\nvar iterable_utils = __webpack_require__(38550);\n;// CONCATENATED MODULE: ./node_modules/@deck.gl/layers/dist/esm/text-layer/multi-icon-layer/multi-icon-layer-fragment.glsl.js\n/* harmony default export */ var multi_icon_layer_fragment_glsl = (\"#define SHADER_NAME multi-icon-layer-fragment-shader\\n\\nprecision highp float;\\n\\nuniform float opacity;\\nuniform sampler2D iconsTexture;\\nuniform float gamma;\\nuniform bool sdf;\\nuniform float alphaCutoff;\\nuniform float sdfBuffer;\\nuniform float outlineBuffer;\\nuniform vec4 outlineColor;\\n\\nvarying vec4 vColor;\\nvarying vec2 vTextureCoords;\\nvarying vec2 uv;\\n\\nvoid main(void) {\\n  geometry.uv = uv;\\n\\n  if (!picking_uActive) {\\n    float alpha = texture2D(iconsTexture, vTextureCoords).a;\\n    vec4 color = vColor;\\n    if (sdf) {\\n      float distance = alpha;\\n      alpha = smoothstep(sdfBuffer - gamma, sdfBuffer + gamma, distance);\\n\\n      if (outlineBuffer > 0.0) {\\n        float inFill = alpha;\\n        float inBorder = smoothstep(outlineBuffer - gamma, outlineBuffer + gamma, distance);\\n        color = mix(outlineColor, vColor, inFill);\\n        alpha = inBorder;\\n      }\\n    }\\n    float a = alpha * color.a;\\n    \\n    if (a < alphaCutoff) {\\n      discard;\\n    }\\n\\n    gl_FragColor = vec4(color.rgb, a * opacity);\\n  }\\n\\n  DECKGL_FILTER_COLOR(gl_FragColor, geometry);\\n}\\n\");\n//# sourceMappingURL=multi-icon-layer-fragment.glsl.js.map\n;// CONCATENATED MODULE: ./node_modules/@deck.gl/layers/dist/esm/text-layer/multi-icon-layer/multi-icon-layer.js\n\n\n\n\nconst DEFAULT_BUFFER = 192.0 / 256;\nconst EMPTY_ARRAY = [];\nconst multi_icon_layer_defaultProps = {\n  getIconOffsets: {\n    type: 'accessor',\n    value: x => x.offsets\n  },\n  alphaCutoff: 0.001,\n  smoothing: 0.1,\n  outlineWidth: 0,\n  outlineColor: {\n    type: 'color',\n    value: [0, 0, 0, 255]\n  }\n};\nclass MultiIconLayer extends icon_layer/* default */.Z {\n  constructor(...args) {\n    super(...args);\n\n    (0,defineProperty/* default */.Z)(this, \"state\", void 0);\n  }\n\n  getShaders() {\n    return { ...super.getShaders(),\n      fs: multi_icon_layer_fragment_glsl\n    };\n  }\n\n  initializeState() {\n    super.initializeState();\n    const attributeManager = this.getAttributeManager();\n    attributeManager.addInstanced({\n      instanceOffsets: {\n        size: 2,\n        accessor: 'getIconOffsets'\n      },\n      instancePickingColors: {\n        type: 5121,\n        size: 3,\n        accessor: (object, {\n          index,\n          target: value\n        }) => this.encodePickingColor(index, value)\n      }\n    });\n  }\n\n  updateState(params) {\n    super.updateState(params);\n    const {\n      props,\n      oldProps\n    } = params;\n    let {\n      outlineColor\n    } = props;\n\n    if (outlineColor !== oldProps.outlineColor) {\n      outlineColor = outlineColor.map(x => x / 255);\n      outlineColor[3] = Number.isFinite(outlineColor[3]) ? outlineColor[3] : 1;\n      this.setState({\n        outlineColor\n      });\n    }\n\n    if (!props.sdf && props.outlineWidth) {\n      log/* default.warn */.Z.warn(\"\".concat(this.id, \": fontSettings.sdf is required to render outline\"))();\n    }\n  }\n\n  draw(params) {\n    const {\n      sdf,\n      smoothing,\n      outlineWidth\n    } = this.props;\n    const {\n      outlineColor\n    } = this.state;\n    const outlineBuffer = outlineWidth ? Math.max(smoothing, DEFAULT_BUFFER * (1 - outlineWidth)) : -1;\n    params.uniforms = { ...params.uniforms,\n      sdfBuffer: DEFAULT_BUFFER,\n      outlineBuffer,\n      gamma: smoothing,\n      sdf: Boolean(sdf),\n      outlineColor\n    };\n    super.draw(params);\n\n    if (sdf && outlineWidth) {\n      const {\n        iconManager\n      } = this.state;\n      const iconsTexture = iconManager.getTexture();\n\n      if (iconsTexture) {\n        this.state.model.draw({\n          uniforms: {\n            outlineBuffer: DEFAULT_BUFFER\n          }\n        });\n      }\n    }\n  }\n\n  getInstanceOffset(icons) {\n    return icons ? Array.from(icons).flatMap(icon => super.getInstanceOffset(icon)) : EMPTY_ARRAY;\n  }\n\n  getInstanceColorMode(icons) {\n    return 1;\n  }\n\n  getInstanceIconFrame(icons) {\n    return icons ? Array.from(icons).flatMap(icon => super.getInstanceIconFrame(icon)) : EMPTY_ARRAY;\n  }\n\n}\n\n(0,defineProperty/* default */.Z)(MultiIconLayer, \"defaultProps\", multi_icon_layer_defaultProps);\n\n(0,defineProperty/* default */.Z)(MultiIconLayer, \"layerName\", 'MultiIconLayer');\n//# sourceMappingURL=multi-icon-layer.js.map\n// EXTERNAL MODULE: ./node_modules/@mapbox/tiny-sdf/index.js\nvar tiny_sdf = __webpack_require__(39875);\n;// CONCATENATED MODULE: ./node_modules/@deck.gl/layers/dist/esm/text-layer/utils.js\n\nconst MISSING_CHAR_WIDTH = 32;\nconst SINGLE_LINE = [];\nfunction nextPowOfTwo(number) {\n  return Math.pow(2, Math.ceil(Math.log2(number)));\n}\nfunction buildMapping({\n  characterSet,\n  getFontWidth,\n  fontHeight,\n  buffer,\n  maxCanvasWidth,\n  mapping = {},\n  xOffset = 0,\n  yOffset = 0\n}) {\n  let row = 0;\n  let x = xOffset;\n  const rowHeight = fontHeight + buffer * 2;\n\n  for (const char of characterSet) {\n    if (!mapping[char]) {\n      const width = getFontWidth(char);\n\n      if (x + width + buffer * 2 > maxCanvasWidth) {\n        x = 0;\n        row++;\n      }\n\n      mapping[char] = {\n        x: x + buffer,\n        y: yOffset + row * rowHeight + buffer,\n        width,\n        height: rowHeight,\n        layoutWidth: width,\n        layoutHeight: fontHeight\n      };\n      x += width + buffer * 2;\n    }\n  }\n\n  return {\n    mapping,\n    xOffset: x,\n    yOffset: yOffset + row * rowHeight,\n    canvasHeight: nextPowOfTwo(yOffset + (row + 1) * rowHeight)\n  };\n}\n\nfunction getTextWidth(text, startIndex, endIndex, mapping) {\n  let width = 0;\n\n  for (let i = startIndex; i < endIndex; i++) {\n    var _mapping$character;\n\n    const character = text[i];\n    width += ((_mapping$character = mapping[character]) === null || _mapping$character === void 0 ? void 0 : _mapping$character.layoutWidth) || 0;\n  }\n\n  return width;\n}\n\nfunction breakAll(text, startIndex, endIndex, maxWidth, iconMapping, target) {\n  let rowStartCharIndex = startIndex;\n  let rowOffsetLeft = 0;\n\n  for (let i = startIndex; i < endIndex; i++) {\n    const textWidth = getTextWidth(text, i, i + 1, iconMapping);\n\n    if (rowOffsetLeft + textWidth > maxWidth) {\n      if (rowStartCharIndex < i) {\n        target.push(i);\n      }\n\n      rowStartCharIndex = i;\n      rowOffsetLeft = 0;\n    }\n\n    rowOffsetLeft += textWidth;\n  }\n\n  return rowOffsetLeft;\n}\n\nfunction breakWord(text, startIndex, endIndex, maxWidth, iconMapping, target) {\n  let rowStartCharIndex = startIndex;\n  let groupStartCharIndex = startIndex;\n  let groupEndCharIndex = startIndex;\n  let rowOffsetLeft = 0;\n\n  for (let i = startIndex; i < endIndex; i++) {\n    if (text[i] === ' ') {\n      groupEndCharIndex = i + 1;\n    } else if (text[i + 1] === ' ' || i + 1 === endIndex) {\n      groupEndCharIndex = i + 1;\n    }\n\n    if (groupEndCharIndex > groupStartCharIndex) {\n      let groupWidth = getTextWidth(text, groupStartCharIndex, groupEndCharIndex, iconMapping);\n\n      if (rowOffsetLeft + groupWidth > maxWidth) {\n        if (rowStartCharIndex < groupStartCharIndex) {\n          target.push(groupStartCharIndex);\n          rowStartCharIndex = groupStartCharIndex;\n          rowOffsetLeft = 0;\n        }\n\n        if (groupWidth > maxWidth) {\n          groupWidth = breakAll(text, groupStartCharIndex, groupEndCharIndex, maxWidth, iconMapping, target);\n          rowStartCharIndex = target[target.length - 1];\n        }\n      }\n\n      groupStartCharIndex = groupEndCharIndex;\n      rowOffsetLeft += groupWidth;\n    }\n  }\n\n  return rowOffsetLeft;\n}\n\nfunction autoWrapping(text, wordBreak, maxWidth, iconMapping, startIndex = 0, endIndex) {\n  if (endIndex === undefined) {\n    endIndex = text.length;\n  }\n\n  const result = [];\n\n  if (wordBreak === 'break-all') {\n    breakAll(text, startIndex, endIndex, maxWidth, iconMapping, result);\n  } else {\n    breakWord(text, startIndex, endIndex, maxWidth, iconMapping, result);\n  }\n\n  return result;\n}\n\nfunction transformRow(line, startIndex, endIndex, iconMapping, leftOffsets, rowSize) {\n  let x = 0;\n  let rowHeight = 0;\n\n  for (let i = startIndex; i < endIndex; i++) {\n    const character = line[i];\n    const frame = iconMapping[character];\n\n    if (frame) {\n      if (!rowHeight) {\n        rowHeight = frame.layoutHeight;\n      }\n\n      leftOffsets[i] = x + frame.layoutWidth / 2;\n      x += frame.layoutWidth;\n    } else {\n      log/* default.warn */.Z.warn(\"Missing character: \".concat(character, \" (\").concat(character.codePointAt(0), \")\"))();\n      leftOffsets[i] = x;\n      x += MISSING_CHAR_WIDTH;\n    }\n  }\n\n  rowSize[0] = x;\n  rowSize[1] = rowHeight;\n}\n\nfunction transformParagraph(paragraph, lineHeight, wordBreak, maxWidth, iconMapping) {\n  const characters = Array.from(paragraph);\n  const numCharacters = characters.length;\n  const x = new Array(numCharacters);\n  const y = new Array(numCharacters);\n  const rowWidth = new Array(numCharacters);\n  const autoWrappingEnabled = (wordBreak === 'break-word' || wordBreak === 'break-all') && isFinite(maxWidth) && maxWidth > 0;\n  const size = [0, 0];\n  const rowSize = [0, 0];\n  let rowOffsetTop = 0;\n  let lineStartIndex = 0;\n  let lineEndIndex = 0;\n\n  for (let i = 0; i <= numCharacters; i++) {\n    const char = characters[i];\n\n    if (char === '\\n' || i === numCharacters) {\n      lineEndIndex = i;\n    }\n\n    if (lineEndIndex > lineStartIndex) {\n      const rows = autoWrappingEnabled ? autoWrapping(characters, wordBreak, maxWidth, iconMapping, lineStartIndex, lineEndIndex) : SINGLE_LINE;\n\n      for (let rowIndex = 0; rowIndex <= rows.length; rowIndex++) {\n        const rowStart = rowIndex === 0 ? lineStartIndex : rows[rowIndex - 1];\n        const rowEnd = rowIndex < rows.length ? rows[rowIndex] : lineEndIndex;\n        transformRow(characters, rowStart, rowEnd, iconMapping, x, rowSize);\n\n        for (let j = rowStart; j < rowEnd; j++) {\n          var _iconMapping$char;\n\n          const char = characters[j];\n          const layoutOffsetY = ((_iconMapping$char = iconMapping[char]) === null || _iconMapping$char === void 0 ? void 0 : _iconMapping$char.layoutOffsetY) || 0;\n          y[j] = rowOffsetTop + rowSize[1] / 2 + layoutOffsetY;\n          rowWidth[j] = rowSize[0];\n        }\n\n        rowOffsetTop = rowOffsetTop + rowSize[1] * lineHeight;\n        size[0] = Math.max(size[0], rowSize[0]);\n      }\n\n      lineStartIndex = lineEndIndex;\n    }\n\n    if (char === '\\n') {\n      x[lineStartIndex] = 0;\n      y[lineStartIndex] = 0;\n      rowWidth[lineStartIndex] = 0;\n      lineStartIndex++;\n    }\n  }\n\n  size[1] = rowOffsetTop;\n  return {\n    x,\n    y,\n    rowWidth,\n    size\n  };\n}\nfunction getTextFromBuffer({\n  value,\n  length,\n  stride,\n  offset,\n  startIndices,\n  characterSet\n}) {\n  const bytesPerElement = value.BYTES_PER_ELEMENT;\n  const elementStride = stride ? stride / bytesPerElement : 1;\n  const elementOffset = offset ? offset / bytesPerElement : 0;\n  const characterCount = startIndices[length] || Math.ceil((value.length - elementOffset) / elementStride);\n  const autoCharacterSet = characterSet && new Set();\n  const texts = new Array(length);\n  let codes = value;\n\n  if (elementStride > 1 || elementOffset > 0) {\n    const ArrayType = value.constructor;\n    codes = new ArrayType(characterCount);\n\n    for (let i = 0; i < characterCount; i++) {\n      codes[i] = value[i * elementStride + elementOffset];\n    }\n  }\n\n  for (let index = 0; index < length; index++) {\n    const startIndex = startIndices[index];\n    const endIndex = startIndices[index + 1] || characterCount;\n    const codesAtIndex = codes.subarray(startIndex, endIndex);\n    texts[index] = String.fromCodePoint.apply(null, codesAtIndex);\n\n    if (autoCharacterSet) {\n      codesAtIndex.forEach(autoCharacterSet.add, autoCharacterSet);\n    }\n  }\n\n  if (autoCharacterSet) {\n    for (const charCode of autoCharacterSet) {\n      characterSet.add(String.fromCodePoint(charCode));\n    }\n  }\n\n  return {\n    texts,\n    characterCount\n  };\n}\n//# sourceMappingURL=utils.js.map\n;// CONCATENATED MODULE: ./node_modules/@deck.gl/layers/dist/esm/text-layer/lru-cache.js\n\nclass LRUCache {\n  constructor(limit = 5) {\n    (0,defineProperty/* default */.Z)(this, \"limit\", void 0);\n\n    (0,defineProperty/* default */.Z)(this, \"_cache\", {});\n\n    (0,defineProperty/* default */.Z)(this, \"_order\", []);\n\n    this.limit = limit;\n  }\n\n  get(key) {\n    const value = this._cache[key];\n\n    if (value) {\n      this._deleteOrder(key);\n\n      this._appendOrder(key);\n    }\n\n    return value;\n  }\n\n  set(key, value) {\n    if (!this._cache[key]) {\n      if (Object.keys(this._cache).length === this.limit) {\n        this.delete(this._order[0]);\n      }\n\n      this._cache[key] = value;\n\n      this._appendOrder(key);\n    } else {\n      this.delete(key);\n      this._cache[key] = value;\n\n      this._appendOrder(key);\n    }\n  }\n\n  delete(key) {\n    const value = this._cache[key];\n\n    if (value) {\n      delete this._cache[key];\n\n      this._deleteOrder(key);\n    }\n  }\n\n  _deleteOrder(key) {\n    const index = this._order.indexOf(key);\n\n    if (index >= 0) {\n      this._order.splice(index, 1);\n    }\n  }\n\n  _appendOrder(key) {\n    this._order.push(key);\n  }\n\n}\n//# sourceMappingURL=lru-cache.js.map\n;// CONCATENATED MODULE: ./node_modules/@deck.gl/layers/dist/esm/text-layer/font-atlas-manager.js\n\n\n\n\n\n\nfunction getDefaultCharacterSet() {\n  const charSet = [];\n\n  for (let i = 32; i < 128; i++) {\n    charSet.push(String.fromCharCode(i));\n  }\n\n  return charSet;\n}\n\nconst DEFAULT_FONT_SETTINGS = {\n  fontFamily: 'Monaco, monospace',\n  fontWeight: 'normal',\n  characterSet: getDefaultCharacterSet(),\n  fontSize: 64,\n  buffer: 4,\n  sdf: false,\n  cutoff: 0.25,\n  radius: 12,\n  smoothing: 0.1\n};\nconst MAX_CANVAS_WIDTH = 1024;\nconst BASELINE_SCALE = 0.9;\nconst HEIGHT_SCALE = 1.2;\nconst CACHE_LIMIT = 3;\nlet cache = new LRUCache(CACHE_LIMIT);\n\nfunction getNewChars(cacheKey, characterSet) {\n  let newCharSet;\n\n  if (typeof characterSet === 'string') {\n    newCharSet = new Set(Array.from(characterSet));\n  } else {\n    newCharSet = new Set(characterSet);\n  }\n\n  const cachedFontAtlas = cache.get(cacheKey);\n\n  if (!cachedFontAtlas) {\n    return newCharSet;\n  }\n\n  for (const char in cachedFontAtlas.mapping) {\n    if (newCharSet.has(char)) {\n      newCharSet.delete(char);\n    }\n  }\n\n  return newCharSet;\n}\n\nfunction populateAlphaChannel(alphaChannel, imageData) {\n  for (let i = 0; i < alphaChannel.length; i++) {\n    imageData.data[4 * i + 3] = alphaChannel[i];\n  }\n}\n\nfunction setTextStyle(ctx, fontFamily, fontSize, fontWeight) {\n  ctx.font = \"\".concat(fontWeight, \" \").concat(fontSize, \"px \").concat(fontFamily);\n  ctx.fillStyle = '#000';\n  ctx.textBaseline = 'alphabetic';\n  ctx.textAlign = 'left';\n}\n\nfunction setFontAtlasCacheLimit(limit) {\n  log/* default.assert */.Z.assert(Number.isFinite(limit) && limit >= CACHE_LIMIT, 'Invalid cache limit');\n  cache = new LRUCache(limit);\n}\nclass FontAtlasManager {\n  constructor() {\n    (0,defineProperty/* default */.Z)(this, \"props\", { ...DEFAULT_FONT_SETTINGS\n    });\n\n    (0,defineProperty/* default */.Z)(this, \"_key\", void 0);\n\n    (0,defineProperty/* default */.Z)(this, \"_atlas\", void 0);\n  }\n\n  get texture() {\n    return this._atlas;\n  }\n\n  get mapping() {\n    return this._atlas && this._atlas.mapping;\n  }\n\n  get scale() {\n    const {\n      fontSize,\n      buffer\n    } = this.props;\n    return (fontSize * HEIGHT_SCALE + buffer * 2) / fontSize;\n  }\n\n  setProps(props = {}) {\n    Object.assign(this.props, props);\n    this._key = this._getKey();\n    const charSet = getNewChars(this._key, this.props.characterSet);\n    const cachedFontAtlas = cache.get(this._key);\n\n    if (cachedFontAtlas && charSet.size === 0) {\n      if (this._atlas !== cachedFontAtlas) {\n        this._atlas = cachedFontAtlas;\n      }\n\n      return;\n    }\n\n    const fontAtlas = this._generateFontAtlas(charSet, cachedFontAtlas);\n\n    this._atlas = fontAtlas;\n    cache.set(this._key, fontAtlas);\n  }\n\n  _generateFontAtlas(characterSet, cachedFontAtlas) {\n    const {\n      fontFamily,\n      fontWeight,\n      fontSize,\n      buffer,\n      sdf,\n      radius,\n      cutoff\n    } = this.props;\n    let canvas = cachedFontAtlas && cachedFontAtlas.data;\n\n    if (!canvas) {\n      canvas = document.createElement('canvas');\n      canvas.width = MAX_CANVAS_WIDTH;\n    }\n\n    const ctx = canvas.getContext('2d', {\n      willReadFrequently: true\n    });\n    setTextStyle(ctx, fontFamily, fontSize, fontWeight);\n    const {\n      mapping,\n      canvasHeight,\n      xOffset,\n      yOffset\n    } = buildMapping({\n      getFontWidth: char => ctx.measureText(char).width,\n      fontHeight: fontSize * HEIGHT_SCALE,\n      buffer,\n      characterSet,\n      maxCanvasWidth: MAX_CANVAS_WIDTH,\n      ...(cachedFontAtlas && {\n        mapping: cachedFontAtlas.mapping,\n        xOffset: cachedFontAtlas.xOffset,\n        yOffset: cachedFontAtlas.yOffset\n      })\n    });\n\n    if (canvas.height !== canvasHeight) {\n      const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);\n      canvas.height = canvasHeight;\n      ctx.putImageData(imageData, 0, 0);\n    }\n\n    setTextStyle(ctx, fontFamily, fontSize, fontWeight);\n\n    if (sdf) {\n      const tinySDF = new tiny_sdf/* default */.Z({\n        fontSize,\n        buffer,\n        radius,\n        cutoff,\n        fontFamily,\n        fontWeight: \"\".concat(fontWeight)\n      });\n\n      for (const char of characterSet) {\n        const {\n          data,\n          width,\n          height,\n          glyphTop\n        } = tinySDF.draw(char);\n        mapping[char].width = width;\n        mapping[char].layoutOffsetY = fontSize * BASELINE_SCALE - glyphTop;\n        const imageData = ctx.createImageData(width, height);\n        populateAlphaChannel(data, imageData);\n        ctx.putImageData(imageData, mapping[char].x, mapping[char].y);\n      }\n    } else {\n      for (const char of characterSet) {\n        ctx.fillText(char, mapping[char].x, mapping[char].y + buffer + fontSize * BASELINE_SCALE);\n      }\n    }\n\n    return {\n      xOffset,\n      yOffset,\n      mapping,\n      data: canvas,\n      width: canvas.width,\n      height: canvas.height\n    };\n  }\n\n  _getKey() {\n    const {\n      fontFamily,\n      fontWeight,\n      fontSize,\n      buffer,\n      sdf,\n      radius,\n      cutoff\n    } = this.props;\n\n    if (sdf) {\n      return \"\".concat(fontFamily, \" \").concat(fontWeight, \" \").concat(fontSize, \" \").concat(buffer, \" \").concat(radius, \" \").concat(cutoff);\n    }\n\n    return \"\".concat(fontFamily, \" \").concat(fontWeight, \" \").concat(fontSize, \" \").concat(buffer);\n  }\n\n}\n//# sourceMappingURL=font-atlas-manager.js.map\n;// CONCATENATED MODULE: ./node_modules/@deck.gl/layers/dist/esm/text-layer/text-background-layer/text-background-layer-vertex.glsl.js\n/* harmony default export */ var text_background_layer_vertex_glsl = (\"#define SHADER_NAME text-background-layer-vertex-shader\\n\\nattribute vec2 positions;\\n\\nattribute vec3 instancePositions;\\nattribute vec3 instancePositions64Low;\\nattribute vec4 instanceRects;\\nattribute float instanceSizes;\\nattribute float instanceAngles;\\nattribute vec2 instancePixelOffsets;\\nattribute float instanceLineWidths;\\nattribute vec4 instanceFillColors;\\nattribute vec4 instanceLineColors;\\nattribute vec3 instancePickingColors;\\n\\nuniform bool billboard;\\nuniform float opacity;\\nuniform float sizeScale;\\nuniform float sizeMinPixels;\\nuniform float sizeMaxPixels;\\nuniform vec4 padding;\\nuniform int sizeUnits;\\n\\nvarying vec4 vFillColor;\\nvarying vec4 vLineColor;\\nvarying float vLineWidth;\\nvarying vec2 uv;\\nvarying vec2 dimensions;\\n\\nvec2 rotate_by_angle(vec2 vertex, float angle) {\\n  float angle_radian = radians(angle);\\n  float cos_angle = cos(angle_radian);\\n  float sin_angle = sin(angle_radian);\\n  mat2 rotationMatrix = mat2(cos_angle, -sin_angle, sin_angle, cos_angle);\\n  return rotationMatrix * vertex;\\n}\\n\\nvoid main(void) {\\n  geometry.worldPosition = instancePositions;\\n  geometry.uv = positions;\\n  geometry.pickingColor = instancePickingColors;\\n  uv = positions;\\n  vLineWidth = instanceLineWidths;\\n  float sizePixels = clamp(\\n    project_size_to_pixel(instanceSizes * sizeScale, sizeUnits),\\n    sizeMinPixels, sizeMaxPixels\\n  );\\n\\n  dimensions = instanceRects.zw * sizePixels + padding.xy + padding.zw;\\n\\n  vec2 pixelOffset = (positions * instanceRects.zw + instanceRects.xy) * sizePixels + mix(-padding.xy, padding.zw, positions);\\n  pixelOffset = rotate_by_angle(pixelOffset, instanceAngles);\\n  pixelOffset += instancePixelOffsets;\\n  pixelOffset.y *= -1.0;\\n\\n  if (billboard)  {\\n    gl_Position = project_position_to_clipspace(instancePositions, instancePositions64Low, vec3(0.0), geometry.position);\\n    DECKGL_FILTER_GL_POSITION(gl_Position, geometry);\\n    vec3 offset = vec3(pixelOffset, 0.0);\\n    DECKGL_FILTER_SIZE(offset, geometry);\\n    gl_Position.xy += project_pixel_size_to_clipspace(offset.xy);\\n  } else {\\n    vec3 offset_common = vec3(project_pixel_size(pixelOffset), 0.0);\\n    DECKGL_FILTER_SIZE(offset_common, geometry);\\n    gl_Position = project_position_to_clipspace(instancePositions, instancePositions64Low, offset_common, geometry.position);\\n    DECKGL_FILTER_GL_POSITION(gl_Position, geometry);\\n  }\\n  vFillColor = vec4(instanceFillColors.rgb, instanceFillColors.a * opacity);\\n  DECKGL_FILTER_COLOR(vFillColor, geometry);\\n  vLineColor = vec4(instanceLineColors.rgb, instanceLineColors.a * opacity);\\n  DECKGL_FILTER_COLOR(vLineColor, geometry);\\n}\\n\");\n//# sourceMappingURL=text-background-layer-vertex.glsl.js.map\n;// CONCATENATED MODULE: ./node_modules/@deck.gl/layers/dist/esm/text-layer/text-background-layer/text-background-layer-fragment.glsl.js\n/* harmony default export */ var text_background_layer_fragment_glsl = (\"#define SHADER_NAME text-background-layer-fragment-shader\\n\\nprecision highp float;\\n\\nuniform bool stroked;\\n\\nvarying vec4 vFillColor;\\nvarying vec4 vLineColor;\\nvarying float vLineWidth;\\nvarying vec2 uv;\\nvarying vec2 dimensions;\\n\\nvoid main(void) {\\n  geometry.uv = uv;\\n\\n  vec2 pixelPosition = uv * dimensions;\\n  if (stroked) {\\n    float distToEdge = min(\\n      min(pixelPosition.x, dimensions.x - pixelPosition.x),\\n      min(pixelPosition.y, dimensions.y - pixelPosition.y)\\n    );\\n    float isBorder = smoothedge(distToEdge, vLineWidth);\\n    gl_FragColor = mix(vFillColor, vLineColor, isBorder);\\n  } else {\\n    gl_FragColor = vFillColor;\\n  }\\n\\n  DECKGL_FILTER_COLOR(gl_FragColor, geometry);\\n}\\n\");\n//# sourceMappingURL=text-background-layer-fragment.glsl.js.map\n;// CONCATENATED MODULE: ./node_modules/@deck.gl/layers/dist/esm/text-layer/text-background-layer/text-background-layer.js\n\n\n\n\n\nconst text_background_layer_defaultProps = {\n  billboard: true,\n  sizeScale: 1,\n  sizeUnits: 'pixels',\n  sizeMinPixels: 0,\n  sizeMaxPixels: Number.MAX_SAFE_INTEGER,\n  padding: {\n    type: 'array',\n    value: [0, 0, 0, 0]\n  },\n  getPosition: {\n    type: 'accessor',\n    value: x => x.position\n  },\n  getSize: {\n    type: 'accessor',\n    value: 1\n  },\n  getAngle: {\n    type: 'accessor',\n    value: 0\n  },\n  getPixelOffset: {\n    type: 'accessor',\n    value: [0, 0]\n  },\n  getBoundingRect: {\n    type: 'accessor',\n    value: [0, 0, 0, 0]\n  },\n  getFillColor: {\n    type: 'accessor',\n    value: [0, 0, 0, 255]\n  },\n  getLineColor: {\n    type: 'accessor',\n    value: [0, 0, 0, 255]\n  },\n  getLineWidth: {\n    type: 'accessor',\n    value: 1\n  }\n};\nclass TextBackgroundLayer extends lib_layer/* default */.Z {\n  constructor(...args) {\n    super(...args);\n\n    (0,defineProperty/* default */.Z)(this, \"state\", void 0);\n  }\n\n  getShaders() {\n    return super.getShaders({\n      vs: text_background_layer_vertex_glsl,\n      fs: text_background_layer_fragment_glsl,\n      modules: [project32/* default */.Z, picking/* default */.Z]\n    });\n  }\n\n  initializeState() {\n    this.getAttributeManager().addInstanced({\n      instancePositions: {\n        size: 3,\n        type: 5130,\n        fp64: this.use64bitPositions(),\n        transition: true,\n        accessor: 'getPosition'\n      },\n      instanceSizes: {\n        size: 1,\n        transition: true,\n        accessor: 'getSize',\n        defaultValue: 1\n      },\n      instanceAngles: {\n        size: 1,\n        transition: true,\n        accessor: 'getAngle'\n      },\n      instanceRects: {\n        size: 4,\n        accessor: 'getBoundingRect'\n      },\n      instancePixelOffsets: {\n        size: 2,\n        transition: true,\n        accessor: 'getPixelOffset'\n      },\n      instanceFillColors: {\n        size: 4,\n        transition: true,\n        normalized: true,\n        type: 5121,\n        accessor: 'getFillColor',\n        defaultValue: [0, 0, 0, 255]\n      },\n      instanceLineColors: {\n        size: 4,\n        transition: true,\n        normalized: true,\n        type: 5121,\n        accessor: 'getLineColor',\n        defaultValue: [0, 0, 0, 255]\n      },\n      instanceLineWidths: {\n        size: 1,\n        transition: true,\n        accessor: 'getLineWidth',\n        defaultValue: 1\n      }\n    });\n  }\n\n  updateState(params) {\n    super.updateState(params);\n    const {\n      changeFlags\n    } = params;\n\n    if (changeFlags.extensionsChanged) {\n      var _this$state$model;\n\n      const {\n        gl\n      } = this.context;\n      (_this$state$model = this.state.model) === null || _this$state$model === void 0 ? void 0 : _this$state$model.delete();\n      this.state.model = this._getModel(gl);\n      this.getAttributeManager().invalidateAll();\n    }\n  }\n\n  draw({\n    uniforms\n  }) {\n    const {\n      billboard,\n      sizeScale,\n      sizeUnits,\n      sizeMinPixels,\n      sizeMaxPixels,\n      getLineWidth\n    } = this.props;\n    let {\n      padding\n    } = this.props;\n\n    if (padding.length < 4) {\n      padding = [padding[0], padding[1], padding[0], padding[1]];\n    }\n\n    this.state.model.setUniforms(uniforms).setUniforms({\n      billboard,\n      stroked: Boolean(getLineWidth),\n      padding,\n      sizeUnits: constants/* UNIT */.iI[sizeUnits],\n      sizeScale,\n      sizeMinPixels,\n      sizeMaxPixels\n    }).draw();\n  }\n\n  _getModel(gl) {\n    const positions = [0, 0, 1, 0, 1, 1, 0, 1];\n    return new model/* default */.Z(gl, { ...this.getShaders(),\n      id: this.props.id,\n      geometry: new geometry/* default */.Z({\n        drawMode: 6,\n        vertexCount: 4,\n        attributes: {\n          positions: {\n            size: 2,\n            value: new Float32Array(positions)\n          }\n        }\n      }),\n      isInstanced: true\n    });\n  }\n\n}\n\n(0,defineProperty/* default */.Z)(TextBackgroundLayer, \"defaultProps\", text_background_layer_defaultProps);\n\n(0,defineProperty/* default */.Z)(TextBackgroundLayer, \"layerName\", 'TextBackgroundLayer');\n//# sourceMappingURL=text-background-layer.js.map\n;// CONCATENATED MODULE: ./node_modules/@deck.gl/layers/dist/esm/text-layer/text-layer.js\n\n\n\n\n\n\nconst TEXT_ANCHOR = {\n  start: 1,\n  middle: 0,\n  end: -1\n};\nconst ALIGNMENT_BASELINE = {\n  top: 1,\n  center: 0,\n  bottom: -1\n};\nconst text_layer_DEFAULT_COLOR = [0, 0, 0, 255];\nconst DEFAULT_LINE_HEIGHT = 1.0;\nconst text_layer_defaultProps = {\n  billboard: true,\n  sizeScale: 1,\n  sizeUnits: 'pixels',\n  sizeMinPixels: 0,\n  sizeMaxPixels: Number.MAX_SAFE_INTEGER,\n  background: false,\n  getBackgroundColor: {\n    type: 'accessor',\n    value: [255, 255, 255, 255]\n  },\n  getBorderColor: {\n    type: 'accessor',\n    value: text_layer_DEFAULT_COLOR\n  },\n  getBorderWidth: {\n    type: 'accessor',\n    value: 0\n  },\n  backgroundPadding: {\n    type: 'array',\n    value: [0, 0, 0, 0]\n  },\n  characterSet: {\n    type: 'object',\n    value: DEFAULT_FONT_SETTINGS.characterSet\n  },\n  fontFamily: DEFAULT_FONT_SETTINGS.fontFamily,\n  fontWeight: DEFAULT_FONT_SETTINGS.fontWeight,\n  lineHeight: DEFAULT_LINE_HEIGHT,\n  outlineWidth: {\n    type: 'number',\n    value: 0,\n    min: 0\n  },\n  outlineColor: {\n    type: 'color',\n    value: text_layer_DEFAULT_COLOR\n  },\n  fontSettings: {\n    type: 'object',\n    value: {},\n    compare: 1\n  },\n  wordBreak: 'break-word',\n  maxWidth: {\n    type: 'number',\n    value: -1\n  },\n  getText: {\n    type: 'accessor',\n    value: x => x.text\n  },\n  getPosition: {\n    type: 'accessor',\n    value: x => x.position\n  },\n  getColor: {\n    type: 'accessor',\n    value: text_layer_DEFAULT_COLOR\n  },\n  getSize: {\n    type: 'accessor',\n    value: 32\n  },\n  getAngle: {\n    type: 'accessor',\n    value: 0\n  },\n  getTextAnchor: {\n    type: 'accessor',\n    value: 'middle'\n  },\n  getAlignmentBaseline: {\n    type: 'accessor',\n    value: 'center'\n  },\n  getPixelOffset: {\n    type: 'accessor',\n    value: [0, 0]\n  },\n  backgroundColor: {\n    deprecatedFor: ['background', 'getBackgroundColor']\n  }\n};\nclass TextLayer extends composite_layer/* default */.Z {\n  constructor(...args) {\n    super(...args);\n\n    (0,defineProperty/* default */.Z)(this, \"state\", void 0);\n\n    (0,defineProperty/* default */.Z)(this, \"getBoundingRect\", (object, objectInfo) => {\n      let {\n        size: [width, height]\n      } = this.transformParagraph(object, objectInfo);\n      const {\n        fontSize\n      } = this.state.fontAtlasManager.props;\n      width /= fontSize;\n      height /= fontSize;\n      const {\n        getTextAnchor,\n        getAlignmentBaseline\n      } = this.props;\n      const anchorX = TEXT_ANCHOR[typeof getTextAnchor === 'function' ? getTextAnchor(object, objectInfo) : getTextAnchor];\n      const anchorY = ALIGNMENT_BASELINE[typeof getAlignmentBaseline === 'function' ? getAlignmentBaseline(object, objectInfo) : getAlignmentBaseline];\n      return [(anchorX - 1) * width / 2, (anchorY - 1) * height / 2, width, height];\n    });\n\n    (0,defineProperty/* default */.Z)(this, \"getIconOffsets\", (object, objectInfo) => {\n      const {\n        getTextAnchor,\n        getAlignmentBaseline\n      } = this.props;\n      const {\n        x,\n        y,\n        rowWidth,\n        size: [width, height]\n      } = this.transformParagraph(object, objectInfo);\n      const anchorX = TEXT_ANCHOR[typeof getTextAnchor === 'function' ? getTextAnchor(object, objectInfo) : getTextAnchor];\n      const anchorY = ALIGNMENT_BASELINE[typeof getAlignmentBaseline === 'function' ? getAlignmentBaseline(object, objectInfo) : getAlignmentBaseline];\n      const numCharacters = x.length;\n      const offsets = new Array(numCharacters * 2);\n      let index = 0;\n\n      for (let i = 0; i < numCharacters; i++) {\n        const rowOffset = (1 - anchorX) * (width - rowWidth[i]) / 2;\n        offsets[index++] = (anchorX - 1) * width / 2 + rowOffset + x[i];\n        offsets[index++] = (anchorY - 1) * height / 2 + y[i];\n      }\n\n      return offsets;\n    });\n  }\n\n  initializeState() {\n    this.state = {\n      styleVersion: 0,\n      fontAtlasManager: new FontAtlasManager()\n    };\n\n    if (this.props.maxWidth > 0) {\n      log/* default.warn */.Z.warn('v8.9 breaking change: TextLayer maxWidth is now relative to text size')();\n    }\n  }\n\n  updateState(params) {\n    const {\n      props,\n      oldProps,\n      changeFlags\n    } = params;\n    const textChanged = changeFlags.dataChanged || changeFlags.updateTriggersChanged && (changeFlags.updateTriggersChanged.all || changeFlags.updateTriggersChanged.getText);\n\n    if (textChanged) {\n      this._updateText();\n    }\n\n    const fontChanged = this._updateFontAtlas();\n\n    const styleChanged = fontChanged || props.lineHeight !== oldProps.lineHeight || props.wordBreak !== oldProps.wordBreak || props.maxWidth !== oldProps.maxWidth;\n\n    if (styleChanged) {\n      this.setState({\n        styleVersion: this.state.styleVersion + 1\n      });\n    }\n  }\n\n  getPickingInfo({\n    info\n  }) {\n    info.object = info.index >= 0 ? this.props.data[info.index] : null;\n    return info;\n  }\n\n  _updateFontAtlas() {\n    const {\n      fontSettings,\n      fontFamily,\n      fontWeight\n    } = this.props;\n    const {\n      fontAtlasManager,\n      characterSet\n    } = this.state;\n    const fontProps = { ...fontSettings,\n      characterSet,\n      fontFamily,\n      fontWeight\n    };\n\n    if (!fontAtlasManager.mapping) {\n      fontAtlasManager.setProps(fontProps);\n      return true;\n    }\n\n    for (const key in fontProps) {\n      if (fontProps[key] !== fontAtlasManager.props[key]) {\n        fontAtlasManager.setProps(fontProps);\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n  _updateText() {\n    var _attributes;\n\n    const {\n      data,\n      characterSet\n    } = this.props;\n    const textBuffer = (_attributes = data.attributes) === null || _attributes === void 0 ? void 0 : _attributes.getText;\n    let {\n      getText\n    } = this.props;\n    let startIndices = data.startIndices;\n    let numInstances;\n    const autoCharacterSet = characterSet === 'auto' && new Set();\n\n    if (textBuffer && startIndices) {\n      const {\n        texts,\n        characterCount\n      } = getTextFromBuffer({ ...(ArrayBuffer.isView(textBuffer) ? {\n          value: textBuffer\n        } : textBuffer),\n        length: data.length,\n        startIndices,\n        characterSet: autoCharacterSet\n      });\n      numInstances = characterCount;\n\n      getText = (_, {\n        index\n      }) => texts[index];\n    } else {\n      const {\n        iterable,\n        objectInfo\n      } = (0,iterable_utils/* createIterable */.jB)(data);\n      startIndices = [0];\n      numInstances = 0;\n\n      for (const object of iterable) {\n        objectInfo.index++;\n        const text = Array.from(getText(object, objectInfo) || '');\n\n        if (autoCharacterSet) {\n          text.forEach(autoCharacterSet.add, autoCharacterSet);\n        }\n\n        numInstances += text.length;\n        startIndices.push(numInstances);\n      }\n    }\n\n    this.setState({\n      getText,\n      startIndices,\n      numInstances,\n      characterSet: autoCharacterSet || characterSet\n    });\n  }\n\n  transformParagraph(object, objectInfo) {\n    const {\n      fontAtlasManager\n    } = this.state;\n    const iconMapping = fontAtlasManager.mapping;\n    const getText = this.state.getText;\n    const {\n      wordBreak,\n      lineHeight,\n      maxWidth\n    } = this.props;\n    const paragraph = getText(object, objectInfo) || '';\n    return transformParagraph(paragraph, lineHeight, wordBreak, maxWidth * fontAtlasManager.props.fontSize, iconMapping);\n  }\n\n  renderLayers() {\n    const {\n      startIndices,\n      numInstances,\n      getText,\n      fontAtlasManager: {\n        scale,\n        texture,\n        mapping\n      },\n      styleVersion\n    } = this.state;\n    const {\n      data,\n      _dataDiff,\n      getPosition,\n      getColor,\n      getSize,\n      getAngle,\n      getPixelOffset,\n      getBackgroundColor,\n      getBorderColor,\n      getBorderWidth,\n      backgroundPadding,\n      background,\n      billboard,\n      fontSettings,\n      outlineWidth,\n      outlineColor,\n      sizeScale,\n      sizeUnits,\n      sizeMinPixels,\n      sizeMaxPixels,\n      transitions,\n      updateTriggers\n    } = this.props;\n    const CharactersLayerClass = this.getSubLayerClass('characters', MultiIconLayer);\n    const BackgroundLayerClass = this.getSubLayerClass('background', TextBackgroundLayer);\n    return [background && new BackgroundLayerClass({\n      getFillColor: getBackgroundColor,\n      getLineColor: getBorderColor,\n      getLineWidth: getBorderWidth,\n      padding: backgroundPadding,\n      getPosition,\n      getSize,\n      getAngle,\n      getPixelOffset,\n      billboard,\n      sizeScale,\n      sizeUnits,\n      sizeMinPixels,\n      sizeMaxPixels,\n      transitions: transitions && {\n        getPosition: transitions.getPosition,\n        getAngle: transitions.getAngle,\n        getSize: transitions.getSize,\n        getFillColor: transitions.getBackgroundColor,\n        getLineColor: transitions.getBorderColor,\n        getLineWidth: transitions.getBorderWidth,\n        getPixelOffset: transitions.getPixelOffset\n      }\n    }, this.getSubLayerProps({\n      id: 'background',\n      updateTriggers: {\n        getPosition: updateTriggers.getPosition,\n        getAngle: updateTriggers.getAngle,\n        getSize: updateTriggers.getSize,\n        getFillColor: updateTriggers.getBackgroundColor,\n        getLineColor: updateTriggers.getBorderColor,\n        getLineWidth: updateTriggers.getBorderWidth,\n        getPixelOffset: updateTriggers.getPixelOffset,\n        getBoundingRect: {\n          getText: updateTriggers.getText,\n          getTextAnchor: updateTriggers.getTextAnchor,\n          getAlignmentBaseline: updateTriggers.getAlignmentBaseline,\n          styleVersion\n        }\n      }\n    }), {\n      data: data.attributes && data.attributes.background ? {\n        length: data.length,\n        attributes: data.attributes.background\n      } : data,\n      _dataDiff,\n      autoHighlight: false,\n      getBoundingRect: this.getBoundingRect\n    }), new CharactersLayerClass({\n      sdf: fontSettings.sdf,\n      smoothing: Number.isFinite(fontSettings.smoothing) ? fontSettings.smoothing : DEFAULT_FONT_SETTINGS.smoothing,\n      outlineWidth: outlineWidth / (fontSettings.radius || DEFAULT_FONT_SETTINGS.radius),\n      outlineColor,\n      iconAtlas: texture,\n      iconMapping: mapping,\n      getPosition,\n      getColor,\n      getSize,\n      getAngle,\n      getPixelOffset,\n      billboard,\n      sizeScale: sizeScale * scale,\n      sizeUnits,\n      sizeMinPixels: sizeMinPixels * scale,\n      sizeMaxPixels: sizeMaxPixels * scale,\n      transitions: transitions && {\n        getPosition: transitions.getPosition,\n        getAngle: transitions.getAngle,\n        getColor: transitions.getColor,\n        getSize: transitions.getSize,\n        getPixelOffset: transitions.getPixelOffset\n      }\n    }, this.getSubLayerProps({\n      id: 'characters',\n      updateTriggers: {\n        all: updateTriggers.getText,\n        getPosition: updateTriggers.getPosition,\n        getAngle: updateTriggers.getAngle,\n        getColor: updateTriggers.getColor,\n        getSize: updateTriggers.getSize,\n        getPixelOffset: updateTriggers.getPixelOffset,\n        getIconOffsets: {\n          getTextAnchor: updateTriggers.getTextAnchor,\n          getAlignmentBaseline: updateTriggers.getAlignmentBaseline,\n          styleVersion\n        }\n      }\n    }), {\n      data,\n      _dataDiff,\n      startIndices,\n      numInstances,\n      getIconOffsets: this.getIconOffsets,\n      getIcon: getText\n    })];\n  }\n\n  static set fontAtlasCacheLimit(limit) {\n    setFontAtlasCacheLimit(limit);\n  }\n\n}\n\n(0,defineProperty/* default */.Z)(TextLayer, \"defaultProps\", text_layer_defaultProps);\n\n(0,defineProperty/* default */.Z)(TextLayer, \"layerName\", 'TextLayer');\n//# sourceMappingURL=text-layer.js.map\n// EXTERNAL MODULE: ./node_modules/@deck.gl/layers/dist/esm/path-layer/path-layer.js + 4 modules\nvar path_layer = __webpack_require__(41990);\n// EXTERNAL MODULE: ./node_modules/@deck.gl/layers/dist/esm/solid-polygon-layer/solid-polygon-layer.js + 5 modules\nvar solid_polygon_layer = __webpack_require__(56923);\n;// CONCATENATED MODULE: ./node_modules/@deck.gl/layers/dist/esm/geojson-layer/sub-layer-map.js\n\n\n\n\n\nconst POINT_LAYER = {\n  circle: {\n    type: ScatterplotLayer,\n    props: {\n      filled: 'filled',\n      stroked: 'stroked',\n      lineWidthMaxPixels: 'lineWidthMaxPixels',\n      lineWidthMinPixels: 'lineWidthMinPixels',\n      lineWidthScale: 'lineWidthScale',\n      lineWidthUnits: 'lineWidthUnits',\n      pointRadiusMaxPixels: 'radiusMaxPixels',\n      pointRadiusMinPixels: 'radiusMinPixels',\n      pointRadiusScale: 'radiusScale',\n      pointRadiusUnits: 'radiusUnits',\n      pointAntialiasing: 'antialiasing',\n      pointBillboard: 'billboard',\n      getFillColor: 'getFillColor',\n      getLineColor: 'getLineColor',\n      getLineWidth: 'getLineWidth',\n      getPointRadius: 'getRadius'\n    }\n  },\n  icon: {\n    type: icon_layer/* default */.Z,\n    props: {\n      iconAtlas: 'iconAtlas',\n      iconMapping: 'iconMapping',\n      iconSizeMaxPixels: 'sizeMaxPixels',\n      iconSizeMinPixels: 'sizeMinPixels',\n      iconSizeScale: 'sizeScale',\n      iconSizeUnits: 'sizeUnits',\n      iconAlphaCutoff: 'alphaCutoff',\n      iconBillboard: 'billboard',\n      getIcon: 'getIcon',\n      getIconAngle: 'getAngle',\n      getIconColor: 'getColor',\n      getIconPixelOffset: 'getPixelOffset',\n      getIconSize: 'getSize'\n    }\n  },\n  text: {\n    type: TextLayer,\n    props: {\n      textSizeMaxPixels: 'sizeMaxPixels',\n      textSizeMinPixels: 'sizeMinPixels',\n      textSizeScale: 'sizeScale',\n      textSizeUnits: 'sizeUnits',\n      textBackground: 'background',\n      textBackgroundPadding: 'backgroundPadding',\n      textFontFamily: 'fontFamily',\n      textFontWeight: 'fontWeight',\n      textLineHeight: 'lineHeight',\n      textMaxWidth: 'maxWidth',\n      textOutlineColor: 'outlineColor',\n      textOutlineWidth: 'outlineWidth',\n      textWordBreak: 'wordBreak',\n      textCharacterSet: 'characterSet',\n      textBillboard: 'billboard',\n      textFontSettings: 'fontSettings',\n      getText: 'getText',\n      getTextAngle: 'getAngle',\n      getTextColor: 'getColor',\n      getTextPixelOffset: 'getPixelOffset',\n      getTextSize: 'getSize',\n      getTextAnchor: 'getTextAnchor',\n      getTextAlignmentBaseline: 'getAlignmentBaseline',\n      getTextBackgroundColor: 'getBackgroundColor',\n      getTextBorderColor: 'getBorderColor',\n      getTextBorderWidth: 'getBorderWidth'\n    }\n  }\n};\nconst LINE_LAYER = {\n  type: path_layer/* default */.Z,\n  props: {\n    lineWidthUnits: 'widthUnits',\n    lineWidthScale: 'widthScale',\n    lineWidthMinPixels: 'widthMinPixels',\n    lineWidthMaxPixels: 'widthMaxPixels',\n    lineJointRounded: 'jointRounded',\n    lineCapRounded: 'capRounded',\n    lineMiterLimit: 'miterLimit',\n    lineBillboard: 'billboard',\n    getLineColor: 'getColor',\n    getLineWidth: 'getWidth'\n  }\n};\nconst POLYGON_LAYER = {\n  type: solid_polygon_layer/* default */.Z,\n  props: {\n    extruded: 'extruded',\n    filled: 'filled',\n    wireframe: 'wireframe',\n    elevationScale: 'elevationScale',\n    material: 'material',\n    _full3d: '_full3d',\n    getElevation: 'getElevation',\n    getFillColor: 'getFillColor',\n    getLineColor: 'getLineColor'\n  }\n};\nfunction getDefaultProps({\n  type,\n  props\n}) {\n  const result = {};\n\n  for (const key in props) {\n    result[key] = type.defaultProps[props[key]];\n  }\n\n  return result;\n}\nfunction forwardProps(layer, mapping) {\n  const {\n    transitions,\n    updateTriggers\n  } = layer.props;\n  const result = {\n    updateTriggers: {},\n    transitions: transitions && {\n      getPosition: transitions.geometry\n    }\n  };\n\n  for (const sourceKey in mapping) {\n    const targetKey = mapping[sourceKey];\n    let value = layer.props[sourceKey];\n\n    if (sourceKey.startsWith('get')) {\n      value = layer.getSubLayerAccessor(value);\n      result.updateTriggers[targetKey] = updateTriggers[sourceKey];\n\n      if (transitions) {\n        result.transitions[targetKey] = transitions[sourceKey];\n      }\n    }\n\n    result[targetKey] = value;\n  }\n\n  return result;\n}\n//# sourceMappingURL=sub-layer-map.js.map\n;// CONCATENATED MODULE: ./node_modules/@deck.gl/layers/dist/esm/geojson-layer/geojson.js\n\nfunction getGeojsonFeatures(geojson) {\n  if (Array.isArray(geojson)) {\n    return geojson;\n  }\n\n  log/* default.assert */.Z.assert(geojson.type, 'GeoJSON does not have type');\n\n  switch (geojson.type) {\n    case 'Feature':\n      return [geojson];\n\n    case 'FeatureCollection':\n      log/* default.assert */.Z.assert(Array.isArray(geojson.features), 'GeoJSON does not have features array');\n      return geojson.features;\n\n    default:\n      return [{\n        geometry: geojson\n      }];\n  }\n}\nfunction separateGeojsonFeatures(features, wrapFeature, dataRange = {}) {\n  const separated = {\n    pointFeatures: [],\n    lineFeatures: [],\n    polygonFeatures: [],\n    polygonOutlineFeatures: []\n  };\n  const {\n    startRow = 0,\n    endRow = features.length\n  } = dataRange;\n\n  for (let featureIndex = startRow; featureIndex < endRow; featureIndex++) {\n    const feature = features[featureIndex];\n    const {\n      geometry\n    } = feature;\n\n    if (!geometry) {\n      continue;\n    }\n\n    if (geometry.type === 'GeometryCollection') {\n      log/* default.assert */.Z.assert(Array.isArray(geometry.geometries), 'GeoJSON does not have geometries array');\n      const {\n        geometries\n      } = geometry;\n\n      for (let i = 0; i < geometries.length; i++) {\n        const subGeometry = geometries[i];\n        separateGeometry(subGeometry, separated, wrapFeature, feature, featureIndex);\n      }\n    } else {\n      separateGeometry(geometry, separated, wrapFeature, feature, featureIndex);\n    }\n  }\n\n  return separated;\n}\n\nfunction separateGeometry(geometry, separated, wrapFeature, sourceFeature, sourceFeatureIndex) {\n  const {\n    type,\n    coordinates\n  } = geometry;\n  const {\n    pointFeatures,\n    lineFeatures,\n    polygonFeatures,\n    polygonOutlineFeatures\n  } = separated;\n\n  if (!validateGeometry(type, coordinates)) {\n    log/* default.warn */.Z.warn(\"\".concat(type, \" coordinates are malformed\"))();\n    return;\n  }\n\n  switch (type) {\n    case 'Point':\n      pointFeatures.push(wrapFeature({\n        geometry\n      }, sourceFeature, sourceFeatureIndex));\n      break;\n\n    case 'MultiPoint':\n      coordinates.forEach(point => {\n        pointFeatures.push(wrapFeature({\n          geometry: {\n            type: 'Point',\n            coordinates: point\n          }\n        }, sourceFeature, sourceFeatureIndex));\n      });\n      break;\n\n    case 'LineString':\n      lineFeatures.push(wrapFeature({\n        geometry\n      }, sourceFeature, sourceFeatureIndex));\n      break;\n\n    case 'MultiLineString':\n      coordinates.forEach(path => {\n        lineFeatures.push(wrapFeature({\n          geometry: {\n            type: 'LineString',\n            coordinates: path\n          }\n        }, sourceFeature, sourceFeatureIndex));\n      });\n      break;\n\n    case 'Polygon':\n      polygonFeatures.push(wrapFeature({\n        geometry\n      }, sourceFeature, sourceFeatureIndex));\n      coordinates.forEach(path => {\n        polygonOutlineFeatures.push(wrapFeature({\n          geometry: {\n            type: 'LineString',\n            coordinates: path\n          }\n        }, sourceFeature, sourceFeatureIndex));\n      });\n      break;\n\n    case 'MultiPolygon':\n      coordinates.forEach(polygon => {\n        polygonFeatures.push(wrapFeature({\n          geometry: {\n            type: 'Polygon',\n            coordinates: polygon\n          }\n        }, sourceFeature, sourceFeatureIndex));\n        polygon.forEach(path => {\n          polygonOutlineFeatures.push(wrapFeature({\n            geometry: {\n              type: 'LineString',\n              coordinates: path\n            }\n          }, sourceFeature, sourceFeatureIndex));\n        });\n      });\n      break;\n\n    default:\n  }\n}\n\nconst COORDINATE_NEST_LEVEL = {\n  Point: 1,\n  MultiPoint: 2,\n  LineString: 2,\n  MultiLineString: 3,\n  Polygon: 3,\n  MultiPolygon: 4\n};\nfunction validateGeometry(type, coordinates) {\n  let nestLevel = COORDINATE_NEST_LEVEL[type];\n  log/* default.assert */.Z.assert(nestLevel, \"Unknown GeoJSON type \".concat(type));\n\n  while (coordinates && --nestLevel > 0) {\n    coordinates = coordinates[0];\n  }\n\n  return coordinates && Number.isFinite(coordinates[0]);\n}\n//# sourceMappingURL=geojson.js.map\n;// CONCATENATED MODULE: ./node_modules/@deck.gl/layers/dist/esm/geojson-layer/geojson-layer-props.js\n\n\nfunction createEmptyLayerProps() {\n  return {\n    points: {},\n    lines: {},\n    polygons: {},\n    polygonsOutline: {}\n  };\n}\n\nfunction getCoordinates(f) {\n  return f.geometry.coordinates;\n}\n\nfunction createLayerPropsFromFeatures(features, featuresDiff) {\n  const layerProps = createEmptyLayerProps();\n  const {\n    pointFeatures,\n    lineFeatures,\n    polygonFeatures,\n    polygonOutlineFeatures\n  } = features;\n  layerProps.points.data = pointFeatures;\n\n  layerProps.points._dataDiff = featuresDiff.pointFeatures && (() => featuresDiff.pointFeatures);\n\n  layerProps.points.getPosition = getCoordinates;\n  layerProps.lines.data = lineFeatures;\n\n  layerProps.lines._dataDiff = featuresDiff.lineFeatures && (() => featuresDiff.lineFeatures);\n\n  layerProps.lines.getPath = getCoordinates;\n  layerProps.polygons.data = polygonFeatures;\n\n  layerProps.polygons._dataDiff = featuresDiff.polygonFeatures && (() => featuresDiff.polygonFeatures);\n\n  layerProps.polygons.getPolygon = getCoordinates;\n  layerProps.polygonsOutline.data = polygonOutlineFeatures;\n\n  layerProps.polygonsOutline._dataDiff = featuresDiff.polygonOutlineFeatures && (() => featuresDiff.polygonOutlineFeatures);\n\n  layerProps.polygonsOutline.getPath = getCoordinates;\n  return layerProps;\n}\nfunction createLayerPropsFromBinary(geojsonBinary, encodePickingColor) {\n  const layerProps = createEmptyLayerProps();\n  const {\n    points,\n    lines,\n    polygons\n  } = geojsonBinary;\n  const customPickingColors = calculatePickingColors(geojsonBinary, encodePickingColor);\n  layerProps.points.data = {\n    length: points.positions.value.length / points.positions.size,\n    attributes: { ...points.attributes,\n      getPosition: points.positions,\n      instancePickingColors: {\n        size: 3,\n        value: customPickingColors.points\n      }\n    },\n    properties: points.properties,\n    numericProps: points.numericProps,\n    featureIds: points.featureIds\n  };\n  layerProps.lines.data = {\n    length: lines.pathIndices.value.length - 1,\n    startIndices: lines.pathIndices.value,\n    attributes: { ...lines.attributes,\n      getPath: lines.positions,\n      instancePickingColors: {\n        size: 3,\n        value: customPickingColors.lines\n      }\n    },\n    properties: lines.properties,\n    numericProps: lines.numericProps,\n    featureIds: lines.featureIds\n  };\n  layerProps.lines._pathType = 'open';\n  layerProps.polygons.data = {\n    length: polygons.polygonIndices.value.length - 1,\n    startIndices: polygons.polygonIndices.value,\n    attributes: { ...polygons.attributes,\n      getPolygon: polygons.positions,\n      pickingColors: {\n        size: 3,\n        value: customPickingColors.polygons\n      }\n    },\n    properties: polygons.properties,\n    numericProps: polygons.numericProps,\n    featureIds: polygons.featureIds\n  };\n  layerProps.polygons._normalize = false;\n\n  if (polygons.triangles) {\n    layerProps.polygons.data.attributes.indices = polygons.triangles.value;\n  }\n\n  layerProps.polygonsOutline.data = {\n    length: polygons.primitivePolygonIndices.value.length - 1,\n    startIndices: polygons.primitivePolygonIndices.value,\n    attributes: { ...polygons.attributes,\n      getPath: polygons.positions,\n      instancePickingColors: {\n        size: 3,\n        value: customPickingColors.polygons\n      }\n    },\n    properties: polygons.properties,\n    numericProps: polygons.numericProps,\n    featureIds: polygons.featureIds\n  };\n  layerProps.polygonsOutline._pathType = 'open';\n  return layerProps;\n}\n//# sourceMappingURL=geojson-layer-props.js.map\n;// CONCATENATED MODULE: ./node_modules/@deck.gl/layers/dist/esm/geojson-layer/geojson-layer.js\n\n\n\n\n\n\n\nconst FEATURE_TYPES = ['points', 'linestrings', 'polygons'];\nconst geojson_layer_defaultProps = { ...getDefaultProps(POINT_LAYER.circle),\n  ...getDefaultProps(POINT_LAYER.icon),\n  ...getDefaultProps(POINT_LAYER.text),\n  ...getDefaultProps(LINE_LAYER),\n  ...getDefaultProps(POLYGON_LAYER),\n  stroked: true,\n  filled: true,\n  extruded: false,\n  wireframe: false,\n  _full3d: false,\n  iconAtlas: {\n    type: 'object',\n    value: null\n  },\n  iconMapping: {\n    type: 'object',\n    value: {}\n  },\n  getIcon: {\n    type: 'accessor',\n    value: f => f.properties.icon\n  },\n  getText: {\n    type: 'accessor',\n    value: f => f.properties.text\n  },\n  pointType: 'circle',\n  getRadius: {\n    deprecatedFor: 'getPointRadius'\n  }\n};\nclass GeoJsonLayer extends composite_layer/* default */.Z {\n  initializeState() {\n    this.state = {\n      layerProps: {},\n      features: {}\n    };\n  }\n\n  updateState({\n    props,\n    changeFlags\n  }) {\n    if (!changeFlags.dataChanged) {\n      return;\n    }\n\n    const {\n      data\n    } = this.props;\n    const binary = data && 'points' in data && 'polygons' in data && 'lines' in data;\n    this.setState({\n      binary\n    });\n\n    if (binary) {\n      this._updateStateBinary({\n        props,\n        changeFlags\n      });\n    } else {\n      this._updateStateJSON({\n        props,\n        changeFlags\n      });\n    }\n  }\n\n  _updateStateBinary({\n    props,\n    changeFlags\n  }) {\n    const layerProps = createLayerPropsFromBinary(props.data, this.encodePickingColor);\n    this.setState({\n      layerProps\n    });\n  }\n\n  _updateStateJSON({\n    props,\n    changeFlags\n  }) {\n    const features = getGeojsonFeatures(props.data);\n    const wrapFeature = this.getSubLayerRow.bind(this);\n    let newFeatures = {};\n    const featuresDiff = {};\n\n    if (Array.isArray(changeFlags.dataChanged)) {\n      const oldFeatures = this.state.features;\n\n      for (const key in oldFeatures) {\n        newFeatures[key] = oldFeatures[key].slice();\n        featuresDiff[key] = [];\n      }\n\n      for (const dataRange of changeFlags.dataChanged) {\n        const partialFeatures = separateGeojsonFeatures(features, wrapFeature, dataRange);\n\n        for (const key in oldFeatures) {\n          featuresDiff[key].push((0,utils/* replaceInRange */.b)({\n            data: newFeatures[key],\n            getIndex: f => f.__source.index,\n            dataRange,\n            replace: partialFeatures[key]\n          }));\n        }\n      }\n    } else {\n      newFeatures = separateGeojsonFeatures(features, wrapFeature);\n    }\n\n    const layerProps = createLayerPropsFromFeatures(newFeatures, featuresDiff);\n    this.setState({\n      features: newFeatures,\n      featuresDiff,\n      layerProps\n    });\n  }\n\n  getPickingInfo(params) {\n    const info = super.getPickingInfo(params);\n    const {\n      index,\n      sourceLayer\n    } = info;\n    info.featureType = FEATURE_TYPES.find(ft => sourceLayer.id.startsWith(\"\".concat(this.id, \"-\").concat(ft, \"-\")));\n\n    if (index >= 0 && sourceLayer.id.startsWith(\"\".concat(this.id, \"-points-text\")) && this.state.binary) {\n      info.index = this.props.data.points.globalFeatureIds.value[index];\n    }\n\n    return info;\n  }\n\n  _updateAutoHighlight(info) {\n    const pointLayerIdPrefix = \"\".concat(this.id, \"-points-\");\n    const sourceIsPoints = info.featureType === 'points';\n\n    for (const layer of this.getSubLayers()) {\n      if (layer.id.startsWith(pointLayerIdPrefix) === sourceIsPoints) {\n        layer.updateAutoHighlight(info);\n      }\n    }\n  }\n\n  _renderPolygonLayer() {\n    const {\n      extruded,\n      wireframe\n    } = this.props;\n    const {\n      layerProps\n    } = this.state;\n    const id = 'polygons-fill';\n    const PolygonFillLayer = this.shouldRenderSubLayer(id, layerProps.polygons.data) && this.getSubLayerClass(id, POLYGON_LAYER.type);\n\n    if (PolygonFillLayer) {\n      const forwardedProps = forwardProps(this, POLYGON_LAYER.props);\n      const useLineColor = extruded && wireframe;\n\n      if (!useLineColor) {\n        delete forwardedProps.getLineColor;\n      }\n\n      forwardedProps.updateTriggers.lineColors = useLineColor;\n      return new PolygonFillLayer(forwardedProps, this.getSubLayerProps({\n        id,\n        updateTriggers: forwardedProps.updateTriggers\n      }), layerProps.polygons);\n    }\n\n    return null;\n  }\n\n  _renderLineLayers() {\n    const {\n      extruded,\n      stroked\n    } = this.props;\n    const {\n      layerProps\n    } = this.state;\n    const polygonStrokeLayerId = 'polygons-stroke';\n    const lineStringsLayerId = 'linestrings';\n    const PolygonStrokeLayer = !extruded && stroked && this.shouldRenderSubLayer(polygonStrokeLayerId, layerProps.polygonsOutline.data) && this.getSubLayerClass(polygonStrokeLayerId, LINE_LAYER.type);\n    const LineStringsLayer = this.shouldRenderSubLayer(lineStringsLayerId, layerProps.lines.data) && this.getSubLayerClass(lineStringsLayerId, LINE_LAYER.type);\n\n    if (PolygonStrokeLayer || LineStringsLayer) {\n      const forwardedProps = forwardProps(this, LINE_LAYER.props);\n      return [PolygonStrokeLayer && new PolygonStrokeLayer(forwardedProps, this.getSubLayerProps({\n        id: polygonStrokeLayerId,\n        updateTriggers: forwardedProps.updateTriggers\n      }), layerProps.polygonsOutline), LineStringsLayer && new LineStringsLayer(forwardedProps, this.getSubLayerProps({\n        id: lineStringsLayerId,\n        updateTriggers: forwardedProps.updateTriggers\n      }), layerProps.lines)];\n    }\n\n    return null;\n  }\n\n  _renderPointLayers() {\n    const {\n      pointType\n    } = this.props;\n    const {\n      layerProps,\n      binary\n    } = this.state;\n    let {\n      highlightedObjectIndex\n    } = this.props;\n\n    if (!binary && Number.isFinite(highlightedObjectIndex)) {\n      highlightedObjectIndex = layerProps.points.data.findIndex(d => d.__source.index === highlightedObjectIndex);\n    }\n\n    const types = new Set(pointType.split('+'));\n    const pointLayers = [];\n\n    for (const type of types) {\n      const id = \"points-\".concat(type);\n      const PointLayerMapping = POINT_LAYER[type];\n      const PointsLayer = PointLayerMapping && this.shouldRenderSubLayer(id, layerProps.points.data) && this.getSubLayerClass(id, PointLayerMapping.type);\n\n      if (PointsLayer) {\n        const forwardedProps = forwardProps(this, PointLayerMapping.props);\n        let pointsLayerProps = layerProps.points;\n\n        if (type === 'text' && binary) {\n          const {\n            instancePickingColors,\n            ...rest\n          } = pointsLayerProps.data.attributes;\n          pointsLayerProps = { ...pointsLayerProps,\n            data: { ...pointsLayerProps.data,\n              attributes: rest\n            }\n          };\n        }\n\n        pointLayers.push(new PointsLayer(forwardedProps, this.getSubLayerProps({\n          id,\n          updateTriggers: forwardedProps.updateTriggers,\n          highlightedObjectIndex\n        }), pointsLayerProps));\n      }\n    }\n\n    return pointLayers;\n  }\n\n  renderLayers() {\n    const {\n      extruded\n    } = this.props;\n\n    const polygonFillLayer = this._renderPolygonLayer();\n\n    const lineLayers = this._renderLineLayers();\n\n    const pointLayers = this._renderPointLayers();\n\n    return [!extruded && polygonFillLayer, lineLayers, pointLayers, extruded && polygonFillLayer];\n  }\n\n  getSubLayerAccessor(accessor) {\n    const {\n      binary\n    } = this.state;\n\n    if (!binary || typeof accessor !== 'function') {\n      return super.getSubLayerAccessor(accessor);\n    }\n\n    return (object, info) => {\n      const {\n        data,\n        index\n      } = info;\n      const feature = binaryToFeatureForAccesor(data, index);\n      return accessor(feature, info);\n    };\n  }\n\n}\n\n(0,defineProperty/* default */.Z)(GeoJsonLayer, \"layerName\", 'GeoJsonLayer');\n\n(0,defineProperty/* default */.Z)(GeoJsonLayer, \"defaultProps\", geojson_layer_defaultProps);\n//# sourceMappingURL=geojson-layer.js.map\n// EXTERNAL MODULE: ./node_modules/@loaders.gl/loader-utils/dist/esm/lib/request-utils/request-scheduler.js\nvar request_scheduler = __webpack_require__(78634);\n// EXTERNAL MODULE: ./node_modules/@math.gl/core/dist/esm/classes/matrix4.js\nvar matrix4 = __webpack_require__(85451);\n// EXTERNAL MODULE: ./node_modules/@math.gl/core/dist/esm/lib/common.js\nvar common = __webpack_require__(14034);\n;// CONCATENATED MODULE: ./node_modules/@deck.gl/geo-layers/dist/esm/tileset-2d/tile-2d-header.js\n\nclass Tile2DHeader {\n  constructor(index) {\n    (0,defineProperty/* default */.Z)(this, \"index\", void 0);\n\n    (0,defineProperty/* default */.Z)(this, \"isVisible\", void 0);\n\n    (0,defineProperty/* default */.Z)(this, \"isSelected\", void 0);\n\n    (0,defineProperty/* default */.Z)(this, \"parent\", void 0);\n\n    (0,defineProperty/* default */.Z)(this, \"children\", void 0);\n\n    (0,defineProperty/* default */.Z)(this, \"content\", void 0);\n\n    (0,defineProperty/* default */.Z)(this, \"state\", void 0);\n\n    (0,defineProperty/* default */.Z)(this, \"layers\", void 0);\n\n    (0,defineProperty/* default */.Z)(this, \"id\", void 0);\n\n    (0,defineProperty/* default */.Z)(this, \"bbox\", void 0);\n\n    (0,defineProperty/* default */.Z)(this, \"zoom\", void 0);\n\n    (0,defineProperty/* default */.Z)(this, \"userData\", void 0);\n\n    (0,defineProperty/* default */.Z)(this, \"_abortController\", void 0);\n\n    (0,defineProperty/* default */.Z)(this, \"_loader\", void 0);\n\n    (0,defineProperty/* default */.Z)(this, \"_loaderId\", void 0);\n\n    (0,defineProperty/* default */.Z)(this, \"_isLoaded\", void 0);\n\n    (0,defineProperty/* default */.Z)(this, \"_isCancelled\", void 0);\n\n    (0,defineProperty/* default */.Z)(this, \"_needsReload\", void 0);\n\n    this.index = index;\n    this.isVisible = false;\n    this.isSelected = false;\n    this.parent = null;\n    this.children = [];\n    this.content = null;\n    this._loader = undefined;\n    this._abortController = null;\n    this._loaderId = 0;\n    this._isLoaded = false;\n    this._isCancelled = false;\n    this._needsReload = false;\n  }\n\n  get data() {\n    return this.isLoading && this._loader ? this._loader.then(() => this.data) : this.content;\n  }\n\n  get isLoaded() {\n    return this._isLoaded && !this._needsReload;\n  }\n\n  get isLoading() {\n    return Boolean(this._loader) && !this._isCancelled;\n  }\n\n  get needsReload() {\n    return this._needsReload || this._isCancelled;\n  }\n\n  get byteLength() {\n    const result = this.content ? this.content.byteLength : 0;\n\n    if (!Number.isFinite(result)) {\n      console.error('byteLength not defined in tile data');\n    }\n\n    return result;\n  }\n\n  async _loadData({\n    getData,\n    requestScheduler,\n    onLoad,\n    onError\n  }) {\n    const {\n      index,\n      id,\n      bbox,\n      userData,\n      zoom\n    } = this;\n    const loaderId = this._loaderId;\n    this._abortController = new AbortController();\n    const {\n      signal\n    } = this._abortController;\n    const requestToken = await requestScheduler.scheduleRequest(this, tile => {\n      return tile.isSelected ? 1 : -1;\n    });\n\n    if (!requestToken) {\n      this._isCancelled = true;\n      return;\n    }\n\n    if (this._isCancelled) {\n      requestToken.done();\n      return;\n    }\n\n    let tileData = null;\n    let error;\n\n    try {\n      tileData = await getData({\n        index,\n        id,\n        bbox,\n        userData,\n        zoom,\n        signal\n      });\n    } catch (err) {\n      error = err || true;\n    } finally {\n      requestToken.done();\n    }\n\n    if (loaderId !== this._loaderId) {\n      return;\n    }\n\n    this._loader = undefined;\n    this.content = tileData;\n\n    if (this._isCancelled && !tileData) {\n      this._isLoaded = false;\n      return;\n    }\n\n    this._isLoaded = true;\n    this._isCancelled = false;\n\n    if (error) {\n      onError(error, this);\n    } else {\n      onLoad(this);\n    }\n  }\n\n  loadData(opts) {\n    this._isLoaded = false;\n    this._isCancelled = false;\n    this._needsReload = false;\n    this._loaderId++;\n    this._loader = this._loadData(opts);\n    return this._loader;\n  }\n\n  setNeedsReload() {\n    if (this.isLoading) {\n      this.abort();\n      this._loader = undefined;\n    }\n\n    this._needsReload = true;\n  }\n\n  abort() {\n    var _this$_abortControlle;\n\n    if (this.isLoaded) {\n      return;\n    }\n\n    this._isCancelled = true;\n    (_this$_abortControlle = this._abortController) === null || _this$_abortControlle === void 0 ? void 0 : _this$_abortControlle.abort();\n  }\n\n}\n//# sourceMappingURL=tile-2d-header.js.map\n// EXTERNAL MODULE: ./node_modules/@deck.gl/core/dist/esm/viewports/globe-viewport.js\nvar globe_viewport = __webpack_require__(73131);\n// EXTERNAL MODULE: ./node_modules/@deck.gl/core/dist/esm/viewports/web-mercator-viewport.js\nvar web_mercator_viewport = __webpack_require__(96935);\n// EXTERNAL MODULE: ./node_modules/@math.gl/culling/dist/esm/index.js + 12 modules\nvar esm = __webpack_require__(36772);\n// EXTERNAL MODULE: ./node_modules/@math.gl/web-mercator/dist/esm/index.js + 8 modules\nvar dist_esm = __webpack_require__(78866);\n;// CONCATENATED MODULE: ./node_modules/@deck.gl/geo-layers/dist/esm/tileset-2d/tile-2d-traversal.js\n\n\n\n\n\nconst TILE_SIZE = 512;\nconst MAX_MAPS = 3;\nconst REF_POINTS_5 = [[0.5, 0.5], [0, 0], [0, 1], [1, 0], [1, 1]];\nconst REF_POINTS_9 = REF_POINTS_5.concat([[0, 0.5], [0.5, 0], [1, 0.5], [0.5, 1]]);\nconst REF_POINTS_11 = REF_POINTS_9.concat([[0.25, 0.5], [0.75, 0.5]]);\n\nclass OSMNode {\n  constructor(x, y, z) {\n    (0,defineProperty/* default */.Z)(this, \"x\", void 0);\n\n    (0,defineProperty/* default */.Z)(this, \"y\", void 0);\n\n    (0,defineProperty/* default */.Z)(this, \"z\", void 0);\n\n    (0,defineProperty/* default */.Z)(this, \"childVisible\", void 0);\n\n    (0,defineProperty/* default */.Z)(this, \"selected\", void 0);\n\n    (0,defineProperty/* default */.Z)(this, \"_children\", void 0);\n\n    this.x = x;\n    this.y = y;\n    this.z = z;\n  }\n\n  get children() {\n    if (!this._children) {\n      const x = this.x * 2;\n      const y = this.y * 2;\n      const z = this.z + 1;\n      this._children = [new OSMNode(x, y, z), new OSMNode(x, y + 1, z), new OSMNode(x + 1, y, z), new OSMNode(x + 1, y + 1, z)];\n    }\n\n    return this._children;\n  }\n\n  update(params) {\n    const {\n      viewport,\n      cullingVolume,\n      elevationBounds,\n      minZ,\n      maxZ,\n      bounds,\n      offset,\n      project\n    } = params;\n    const boundingVolume = this.getBoundingVolume(elevationBounds, offset, project);\n\n    if (bounds && !this.insideBounds(bounds)) {\n      return false;\n    }\n\n    const isInside = cullingVolume.computeVisibility(boundingVolume);\n\n    if (isInside < 0) {\n      return false;\n    }\n\n    if (!this.childVisible) {\n      let {\n        z\n      } = this;\n\n      if (z < maxZ && z >= minZ) {\n        const distance = boundingVolume.distanceTo(viewport.cameraPosition) * viewport.scale / viewport.height;\n        z += Math.floor(Math.log2(distance));\n      }\n\n      if (z >= maxZ) {\n        this.selected = true;\n        return true;\n      }\n    }\n\n    this.selected = false;\n    this.childVisible = true;\n\n    for (const child of this.children) {\n      child.update(params);\n    }\n\n    return true;\n  }\n\n  getSelected(result = []) {\n    if (this.selected) {\n      result.push(this);\n    }\n\n    if (this._children) {\n      for (const node of this._children) {\n        node.getSelected(result);\n      }\n    }\n\n    return result;\n  }\n\n  insideBounds([minX, minY, maxX, maxY]) {\n    const scale = Math.pow(2, this.z);\n    const extent = TILE_SIZE / scale;\n    return this.x * extent < maxX && this.y * extent < maxY && (this.x + 1) * extent > minX && (this.y + 1) * extent > minY;\n  }\n\n  getBoundingVolume(zRange, worldOffset, project) {\n    if (project) {\n      const refPoints = this.z < 1 ? REF_POINTS_11 : this.z < 2 ? REF_POINTS_9 : REF_POINTS_5;\n      const refPointPositions = [];\n\n      for (const p of refPoints) {\n        const lngLat = osmTile2lngLat(this.x + p[0], this.y + p[1], this.z);\n        lngLat[2] = zRange[0];\n        refPointPositions.push(project(lngLat));\n\n        if (zRange[0] !== zRange[1]) {\n          lngLat[2] = zRange[1];\n          refPointPositions.push(project(lngLat));\n        }\n      }\n\n      return (0,esm/* makeOrientedBoundingBoxFromPoints */.du)(refPointPositions);\n    }\n\n    const scale = Math.pow(2, this.z);\n    const extent = TILE_SIZE / scale;\n    const originX = this.x * extent + worldOffset * TILE_SIZE;\n    const originY = TILE_SIZE - (this.y + 1) * extent;\n    return new esm/* AxisAlignedBoundingBox */.Xx([originX, originY, zRange[0]], [originX + extent, originY + extent, zRange[1]]);\n  }\n\n}\n\nfunction getOSMTileIndices(viewport, maxZ, zRange, bounds) {\n  const project = viewport instanceof globe_viewport/* default */.Z && viewport.resolution ? viewport.projectPosition : null;\n  const planes = Object.values(viewport.getFrustumPlanes()).map(({\n    normal,\n    distance\n  }) => new esm/* Plane */.JO(normal.clone().negate(), distance));\n  const cullingVolume = new esm/* CullingVolume */.Mh(planes);\n  const unitsPerMeter = viewport.distanceScales.unitsPerMeter[2];\n  const elevationMin = zRange && zRange[0] * unitsPerMeter || 0;\n  const elevationMax = zRange && zRange[1] * unitsPerMeter || 0;\n  const minZ = viewport instanceof web_mercator_viewport/* default */.Z && viewport.pitch <= 60 ? maxZ : 0;\n\n  if (bounds) {\n    const [minLng, minLat, maxLng, maxLat] = bounds;\n    const topLeft = (0,dist_esm/* lngLatToWorld */.w5)([minLng, maxLat]);\n    const bottomRight = (0,dist_esm/* lngLatToWorld */.w5)([maxLng, minLat]);\n    bounds = [topLeft[0], TILE_SIZE - topLeft[1], bottomRight[0], TILE_SIZE - bottomRight[1]];\n  }\n\n  const root = new OSMNode(0, 0, 0);\n  const traversalParams = {\n    viewport,\n    project,\n    cullingVolume,\n    elevationBounds: [elevationMin, elevationMax],\n    minZ,\n    maxZ,\n    bounds,\n    offset: 0\n  };\n  root.update(traversalParams);\n\n  if (viewport instanceof web_mercator_viewport/* default */.Z && viewport.subViewports && viewport.subViewports.length > 1) {\n    traversalParams.offset = -1;\n\n    while (root.update(traversalParams)) {\n      if (--traversalParams.offset < -MAX_MAPS) {\n        break;\n      }\n    }\n\n    traversalParams.offset = 1;\n\n    while (root.update(traversalParams)) {\n      if (++traversalParams.offset > MAX_MAPS) {\n        break;\n      }\n    }\n  }\n\n  return root.getSelected();\n}\n//# sourceMappingURL=tile-2d-traversal.js.map\n;// CONCATENATED MODULE: ./node_modules/@deck.gl/geo-layers/dist/esm/tileset-2d/utils.js\n\nconst utils_TILE_SIZE = 512;\nconst DEFAULT_EXTENT = [-Infinity, -Infinity, Infinity, Infinity];\nconst urlType = {\n  type: 'object',\n  value: null,\n  validate: (value, propType) => propType.optional && value === null || typeof value === 'string' || Array.isArray(value) && value.every(url => typeof url === 'string'),\n  equal: (value1, value2) => {\n    if (value1 === value2) {\n      return true;\n    }\n\n    if (!Array.isArray(value1) || !Array.isArray(value2)) {\n      return false;\n    }\n\n    const len = value1.length;\n\n    if (len !== value2.length) {\n      return false;\n    }\n\n    for (let i = 0; i < len; i++) {\n      if (value1[i] !== value2[i]) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n};\n\nfunction transformBox(bbox, modelMatrix) {\n  const transformedCoords = [modelMatrix.transformAsPoint([bbox[0], bbox[1]]), modelMatrix.transformAsPoint([bbox[2], bbox[1]]), modelMatrix.transformAsPoint([bbox[0], bbox[3]]), modelMatrix.transformAsPoint([bbox[2], bbox[3]])];\n  const transformedBox = [Math.min(...transformedCoords.map(i => i[0])), Math.min(...transformedCoords.map(i => i[1])), Math.max(...transformedCoords.map(i => i[0])), Math.max(...transformedCoords.map(i => i[1]))];\n  return transformedBox;\n}\n\nfunction stringHash(s) {\n  return Math.abs(s.split('').reduce((a, b) => (a << 5) - a + b.charCodeAt(0) | 0, 0));\n}\n\nfunction getURLFromTemplate(template, tile) {\n  if (!template || !template.length) {\n    return null;\n  }\n\n  const {\n    index,\n    id\n  } = tile;\n\n  if (Array.isArray(template)) {\n    const i = stringHash(id) % template.length;\n    template = template[i];\n  }\n\n  let url = template;\n\n  for (const key of Object.keys(index)) {\n    const regex = new RegExp(\"{\".concat(key, \"}\"), 'g');\n    url = url.replace(regex, String(index[key]));\n  }\n\n  if (Number.isInteger(index.y) && Number.isInteger(index.z)) {\n    url = url.replace(/\\{-y\\}/g, String(Math.pow(2, index.z) - index.y - 1));\n  }\n\n  return url;\n}\n\nfunction getBoundingBox(viewport, zRange, extent) {\n  let bounds;\n\n  if (zRange && zRange.length === 2) {\n    const [minZ, maxZ] = zRange;\n    const bounds0 = viewport.getBounds({\n      z: minZ\n    });\n    const bounds1 = viewport.getBounds({\n      z: maxZ\n    });\n    bounds = [Math.min(bounds0[0], bounds1[0]), Math.min(bounds0[1], bounds1[1]), Math.max(bounds0[2], bounds1[2]), Math.max(bounds0[3], bounds1[3])];\n  } else {\n    bounds = viewport.getBounds();\n  }\n\n  if (!viewport.isGeospatial) {\n    return [Math.max(Math.min(bounds[0], extent[2]), extent[0]), Math.max(Math.min(bounds[1], extent[3]), extent[1]), Math.min(Math.max(bounds[2], extent[0]), extent[2]), Math.min(Math.max(bounds[3], extent[1]), extent[3])];\n  }\n\n  return [Math.max(bounds[0], extent[0]), Math.max(bounds[1], extent[1]), Math.min(bounds[2], extent[2]), Math.min(bounds[3], extent[3])];\n}\n\nfunction getCullBounds({\n  viewport,\n  z = 0,\n  cullRect\n}) {\n  const subViewports = viewport.subViewports || [viewport];\n  return subViewports.map(v => getCullBoundsInViewport(v, z, cullRect));\n}\n\nfunction getCullBoundsInViewport(viewport, z, cullRect) {\n  if (!Array.isArray(z)) {\n    const x = cullRect.x - viewport.x;\n    const y = cullRect.y - viewport.y;\n    const {\n      width,\n      height\n    } = cullRect;\n    const unprojectOption = {\n      targetZ: z\n    };\n    const topLeft = viewport.unproject([x, y], unprojectOption);\n    const topRight = viewport.unproject([x + width, y], unprojectOption);\n    const bottomLeft = viewport.unproject([x, y + height], unprojectOption);\n    const bottomRight = viewport.unproject([x + width, y + height], unprojectOption);\n    return [Math.min(topLeft[0], topRight[0], bottomLeft[0], bottomRight[0]), Math.min(topLeft[1], topRight[1], bottomLeft[1], bottomRight[1]), Math.max(topLeft[0], topRight[0], bottomLeft[0], bottomRight[0]), Math.max(topLeft[1], topRight[1], bottomLeft[1], bottomRight[1])];\n  }\n\n  const bounds0 = getCullBoundsInViewport(viewport, z[0], cullRect);\n  const bounds1 = getCullBoundsInViewport(viewport, z[1], cullRect);\n  return [Math.min(bounds0[0], bounds1[0]), Math.min(bounds0[1], bounds1[1]), Math.max(bounds0[2], bounds1[2]), Math.max(bounds0[3], bounds1[3])];\n}\n\nfunction getIndexingCoords(bbox, scale, modelMatrixInverse) {\n  if (modelMatrixInverse) {\n    const transformedTileIndex = transformBox(bbox, modelMatrixInverse).map(i => i * scale / utils_TILE_SIZE);\n    return transformedTileIndex;\n  }\n\n  return bbox.map(i => i * scale / utils_TILE_SIZE);\n}\n\nfunction getScale(z, tileSize) {\n  return Math.pow(2, z) * utils_TILE_SIZE / tileSize;\n}\n\nfunction osmTile2lngLat(x, y, z) {\n  const scale = getScale(z, utils_TILE_SIZE);\n  const lng = x / scale * 360 - 180;\n  const n = Math.PI - 2 * Math.PI * y / scale;\n  const lat = 180 / Math.PI * Math.atan(0.5 * (Math.exp(n) - Math.exp(-n)));\n  return [lng, lat];\n}\n\nfunction tile2XY(x, y, z, tileSize) {\n  const scale = getScale(z, tileSize);\n  return [x / scale * utils_TILE_SIZE, y / scale * utils_TILE_SIZE];\n}\n\nfunction tileToBoundingBox(viewport, x, y, z, tileSize = utils_TILE_SIZE) {\n  if (viewport.isGeospatial) {\n    const [west, north] = osmTile2lngLat(x, y, z);\n    const [east, south] = osmTile2lngLat(x + 1, y + 1, z);\n    return {\n      west,\n      north,\n      east,\n      south\n    };\n  }\n\n  const [left, top] = tile2XY(x, y, z, tileSize);\n  const [right, bottom] = tile2XY(x + 1, y + 1, z, tileSize);\n  return {\n    left,\n    top,\n    right,\n    bottom\n  };\n}\n\nfunction getIdentityTileIndices(viewport, z, tileSize, extent, modelMatrixInverse) {\n  const bbox = getBoundingBox(viewport, null, extent);\n  const scale = getScale(z, tileSize);\n  const [minX, minY, maxX, maxY] = getIndexingCoords(bbox, scale, modelMatrixInverse);\n  const indices = [];\n\n  for (let x = Math.floor(minX); x < maxX; x++) {\n    for (let y = Math.floor(minY); y < maxY; y++) {\n      indices.push({\n        x,\n        y,\n        z\n      });\n    }\n  }\n\n  return indices;\n}\n\nfunction getTileIndices({\n  viewport,\n  maxZoom,\n  minZoom,\n  zRange,\n  extent,\n  tileSize = utils_TILE_SIZE,\n  modelMatrix,\n  modelMatrixInverse,\n  zoomOffset = 0\n}) {\n  let z = viewport.isGeospatial ? Math.round(viewport.zoom + Math.log2(utils_TILE_SIZE / tileSize)) + zoomOffset : Math.ceil(viewport.zoom) + zoomOffset;\n\n  if (typeof minZoom === 'number' && Number.isFinite(minZoom) && z < minZoom) {\n    if (!extent) {\n      return [];\n    }\n\n    z = minZoom;\n  }\n\n  if (typeof maxZoom === 'number' && Number.isFinite(maxZoom) && z > maxZoom) {\n    z = maxZoom;\n  }\n\n  let transformedExtent = extent;\n\n  if (modelMatrix && modelMatrixInverse && extent && !viewport.isGeospatial) {\n    transformedExtent = transformBox(extent, modelMatrix);\n  }\n\n  return viewport.isGeospatial ? getOSMTileIndices(viewport, z, zRange, extent) : getIdentityTileIndices(viewport, z, tileSize, transformedExtent || DEFAULT_EXTENT, modelMatrixInverse);\n}\nfunction isURLTemplate(s) {\n  return /(?=.*{z})(?=.*{x})(?=.*({y}|{-y}))/.test(s);\n}\nfunction isGeoBoundingBox(v) {\n  return Number.isFinite(v.west) && Number.isFinite(v.north) && Number.isFinite(v.east) && Number.isFinite(v.south);\n}\n//# sourceMappingURL=utils.js.map\n;// CONCATENATED MODULE: ./node_modules/@deck.gl/geo-layers/dist/esm/tileset-2d/memoize.js\nfunction memoize(compute) {\n  let cachedArgs = {};\n  let cachedResult;\n  return args => {\n    for (const key in args) {\n      if (!isEqual(args[key], cachedArgs[key])) {\n        cachedResult = compute(args);\n        cachedArgs = args;\n        break;\n      }\n    }\n\n    return cachedResult;\n  };\n}\n\nfunction isEqual(a, b) {\n  if (a === b) {\n    return true;\n  }\n\n  if (Array.isArray(a)) {\n    const len = a.length;\n\n    if (!b || b.length !== len) {\n      return false;\n    }\n\n    for (let i = 0; i < len; i++) {\n      if (a[i] !== b[i]) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  return false;\n}\n//# sourceMappingURL=memoize.js.map\n;// CONCATENATED MODULE: ./node_modules/@deck.gl/geo-layers/dist/esm/tileset-2d/tileset-2d.js\n\n\n\n\n\n\nconst TILE_STATE_VISITED = 1;\nconst TILE_STATE_VISIBLE = 2;\nconst STRATEGY_NEVER = 'never';\nconst STRATEGY_REPLACE = 'no-overlap';\nconst STRATEGY_DEFAULT = 'best-available';\nconst DEFAULT_CACHE_SCALE = 5;\nconst STRATEGIES = {\n  [STRATEGY_DEFAULT]: updateTileStateDefault,\n  [STRATEGY_REPLACE]: updateTileStateReplace,\n  [STRATEGY_NEVER]: () => {}\n};\nconst DEFAULT_TILESET2D_PROPS = {\n  extent: null,\n  tileSize: 512,\n  maxZoom: null,\n  minZoom: null,\n  maxCacheSize: null,\n  maxCacheByteSize: null,\n  refinementStrategy: 'best-available',\n  zRange: null,\n  maxRequests: 6,\n  zoomOffset: 0,\n  onTileLoad: () => {},\n  onTileUnload: () => {},\n  onTileError: () => {}\n};\nclass Tileset2D {\n  constructor(opts) {\n    (0,defineProperty/* default */.Z)(this, \"opts\", void 0);\n\n    (0,defineProperty/* default */.Z)(this, \"_requestScheduler\", void 0);\n\n    (0,defineProperty/* default */.Z)(this, \"_cache\", void 0);\n\n    (0,defineProperty/* default */.Z)(this, \"_dirty\", void 0);\n\n    (0,defineProperty/* default */.Z)(this, \"_tiles\", void 0);\n\n    (0,defineProperty/* default */.Z)(this, \"_cacheByteSize\", void 0);\n\n    (0,defineProperty/* default */.Z)(this, \"_viewport\", void 0);\n\n    (0,defineProperty/* default */.Z)(this, \"_zRange\", void 0);\n\n    (0,defineProperty/* default */.Z)(this, \"_selectedTiles\", void 0);\n\n    (0,defineProperty/* default */.Z)(this, \"_frameNumber\", void 0);\n\n    (0,defineProperty/* default */.Z)(this, \"_modelMatrix\", void 0);\n\n    (0,defineProperty/* default */.Z)(this, \"_modelMatrixInverse\", void 0);\n\n    (0,defineProperty/* default */.Z)(this, \"_maxZoom\", void 0);\n\n    (0,defineProperty/* default */.Z)(this, \"_minZoom\", void 0);\n\n    (0,defineProperty/* default */.Z)(this, \"onTileLoad\", void 0);\n\n    (0,defineProperty/* default */.Z)(this, \"_getCullBounds\", memoize(getCullBounds));\n\n    this.opts = { ...DEFAULT_TILESET2D_PROPS,\n      ...opts\n    };\n\n    this.onTileLoad = tile => {\n      var _this$opts$onTileLoad, _this$opts;\n\n      (_this$opts$onTileLoad = (_this$opts = this.opts).onTileLoad) === null || _this$opts$onTileLoad === void 0 ? void 0 : _this$opts$onTileLoad.call(_this$opts, tile);\n\n      if (this.opts.maxCacheByteSize) {\n        this._cacheByteSize += tile.byteLength;\n\n        this._resizeCache();\n      }\n    };\n\n    this._requestScheduler = new request_scheduler/* default */.Z({\n      maxRequests: opts.maxRequests,\n      throttleRequests: Boolean(opts.maxRequests && opts.maxRequests > 0)\n    });\n    this._cache = new Map();\n    this._tiles = [];\n    this._dirty = false;\n    this._cacheByteSize = 0;\n    this._viewport = null;\n    this._selectedTiles = null;\n    this._frameNumber = 0;\n    this._modelMatrix = new matrix4/* default */.Z();\n    this._modelMatrixInverse = new matrix4/* default */.Z();\n    this.setOptions(opts);\n  }\n\n  get tiles() {\n    return this._tiles;\n  }\n\n  get selectedTiles() {\n    return this._selectedTiles;\n  }\n\n  get isLoaded() {\n    return this._selectedTiles !== null && this._selectedTiles.every(tile => tile.isLoaded);\n  }\n\n  get needsReload() {\n    return this._selectedTiles !== null && this._selectedTiles.some(tile => tile.needsReload);\n  }\n\n  setOptions(opts) {\n    Object.assign(this.opts, opts);\n\n    if (Number.isFinite(opts.maxZoom)) {\n      this._maxZoom = Math.floor(opts.maxZoom);\n    }\n\n    if (Number.isFinite(opts.minZoom)) {\n      this._minZoom = Math.ceil(opts.minZoom);\n    }\n  }\n\n  finalize() {\n    for (const tile of this._cache.values()) {\n      if (tile.isLoading) {\n        tile.abort();\n      }\n    }\n\n    this._cache.clear();\n\n    this._tiles = [];\n    this._selectedTiles = null;\n  }\n\n  reloadAll() {\n    for (const id of this._cache.keys()) {\n      const tile = this._cache.get(id);\n\n      if (!this._selectedTiles || !this._selectedTiles.includes(tile)) {\n        this._cache.delete(id);\n      } else {\n        tile.setNeedsReload();\n      }\n    }\n  }\n\n  update(viewport, {\n    zRange,\n    modelMatrix\n  } = {}) {\n    const modelMatrixAsMatrix4 = new matrix4/* default */.Z(modelMatrix);\n    const isModelMatrixNew = !modelMatrixAsMatrix4.equals(this._modelMatrix);\n\n    if (!this._viewport || !viewport.equals(this._viewport) || !(0,common/* equals */.fS)(this._zRange, zRange) || isModelMatrixNew) {\n      if (isModelMatrixNew) {\n        this._modelMatrixInverse = modelMatrixAsMatrix4.clone().invert();\n        this._modelMatrix = modelMatrixAsMatrix4;\n      }\n\n      this._viewport = viewport;\n      this._zRange = zRange;\n      const tileIndices = this.getTileIndices({\n        viewport,\n        maxZoom: this._maxZoom,\n        minZoom: this._minZoom,\n        zRange,\n        modelMatrix: this._modelMatrix,\n        modelMatrixInverse: this._modelMatrixInverse\n      });\n      this._selectedTiles = tileIndices.map(index => this._getTile(index, true));\n\n      if (this._dirty) {\n        this._rebuildTree();\n      }\n    } else if (this.needsReload) {\n      this._selectedTiles = this._selectedTiles.map(tile => this._getTile(tile.index, true));\n    }\n\n    const changed = this.updateTileStates();\n\n    this._pruneRequests();\n\n    if (this._dirty) {\n      this._resizeCache();\n    }\n\n    if (changed) {\n      this._frameNumber++;\n    }\n\n    return this._frameNumber;\n  }\n\n  isTileVisible(tile, cullRect) {\n    if (!tile.isVisible) {\n      return false;\n    }\n\n    if (cullRect && this._viewport) {\n      const boundsArr = this._getCullBounds({\n        viewport: this._viewport,\n        z: this._zRange,\n        cullRect\n      });\n\n      const {\n        bbox\n      } = tile;\n\n      for (const [minX, minY, maxX, maxY] of boundsArr) {\n        let overlaps;\n\n        if ('west' in bbox) {\n          overlaps = bbox.west < maxX && bbox.east > minX && bbox.south < maxY && bbox.north > minY;\n        } else {\n          const y0 = Math.min(bbox.top, bbox.bottom);\n          const y1 = Math.max(bbox.top, bbox.bottom);\n          overlaps = bbox.left < maxX && bbox.right > minX && y0 < maxY && y1 > minY;\n        }\n\n        if (overlaps) {\n          return true;\n        }\n      }\n\n      return false;\n    }\n\n    return true;\n  }\n\n  getTileIndices({\n    viewport,\n    maxZoom,\n    minZoom,\n    zRange,\n    modelMatrix,\n    modelMatrixInverse\n  }) {\n    const {\n      tileSize,\n      extent,\n      zoomOffset\n    } = this.opts;\n    return getTileIndices({\n      viewport,\n      maxZoom,\n      minZoom,\n      zRange,\n      tileSize,\n      extent: extent,\n      modelMatrix,\n      modelMatrixInverse,\n      zoomOffset\n    });\n  }\n\n  getTileId(index) {\n    return \"\".concat(index.x, \"-\").concat(index.y, \"-\").concat(index.z);\n  }\n\n  getTileZoom(index) {\n    return index.z;\n  }\n\n  getTileMetadata(index) {\n    const {\n      tileSize\n    } = this.opts;\n    return {\n      bbox: tileToBoundingBox(this._viewport, index.x, index.y, index.z, tileSize)\n    };\n  }\n\n  getParentIndex(index) {\n    const x = Math.floor(index.x / 2);\n    const y = Math.floor(index.y / 2);\n    const z = index.z - 1;\n    return {\n      x,\n      y,\n      z\n    };\n  }\n\n  updateTileStates() {\n    const refinementStrategy = this.opts.refinementStrategy || STRATEGY_DEFAULT;\n    const visibilities = new Array(this._cache.size);\n    let i = 0;\n\n    for (const tile of this._cache.values()) {\n      visibilities[i++] = tile.isVisible;\n      tile.isSelected = false;\n      tile.isVisible = false;\n    }\n\n    for (const tile of this._selectedTiles) {\n      tile.isSelected = true;\n      tile.isVisible = true;\n    }\n\n    (typeof refinementStrategy === 'function' ? refinementStrategy : STRATEGIES[refinementStrategy])(Array.from(this._cache.values()));\n    i = 0;\n\n    for (const tile of this._cache.values()) {\n      if (visibilities[i++] !== tile.isVisible) {\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n  _pruneRequests() {\n    const {\n      maxRequests = 0\n    } = this.opts;\n    const abortCandidates = [];\n    let ongoingRequestCount = 0;\n\n    for (const tile of this._cache.values()) {\n      if (tile.isLoading) {\n        ongoingRequestCount++;\n\n        if (!tile.isSelected && !tile.isVisible) {\n          abortCandidates.push(tile);\n        }\n      }\n    }\n\n    while (maxRequests > 0 && ongoingRequestCount > maxRequests && abortCandidates.length > 0) {\n      const tile = abortCandidates.shift();\n      tile.abort();\n      ongoingRequestCount--;\n    }\n  }\n\n  _rebuildTree() {\n    const {\n      _cache\n    } = this;\n\n    for (const tile of _cache.values()) {\n      tile.parent = null;\n\n      if (tile.children) {\n        tile.children.length = 0;\n      }\n    }\n\n    for (const tile of _cache.values()) {\n      const parent = this._getNearestAncestor(tile);\n\n      tile.parent = parent;\n\n      if (parent !== null && parent !== void 0 && parent.children) {\n        parent.children.push(tile);\n      }\n    }\n  }\n\n  _resizeCache() {\n    const {\n      _cache,\n      opts\n    } = this;\n    const maxCacheSize = opts.maxCacheSize || (opts.maxCacheByteSize ? Infinity : DEFAULT_CACHE_SCALE * this.selectedTiles.length);\n    const maxCacheByteSize = opts.maxCacheByteSize || Infinity;\n    const overflown = _cache.size > maxCacheSize || this._cacheByteSize > maxCacheByteSize;\n\n    if (overflown) {\n      for (const [id, tile] of _cache) {\n        if (!tile.isVisible && !tile.isSelected) {\n          var _this$opts$onTileUnlo, _this$opts2;\n\n          this._cacheByteSize -= opts.maxCacheByteSize ? tile.byteLength : 0;\n\n          _cache.delete(id);\n\n          (_this$opts$onTileUnlo = (_this$opts2 = this.opts).onTileUnload) === null || _this$opts$onTileUnlo === void 0 ? void 0 : _this$opts$onTileUnlo.call(_this$opts2, tile);\n        }\n\n        if (_cache.size <= maxCacheSize && this._cacheByteSize <= maxCacheByteSize) {\n          break;\n        }\n      }\n\n      this._rebuildTree();\n\n      this._dirty = true;\n    }\n\n    if (this._dirty) {\n      this._tiles = Array.from(this._cache.values()).sort((t1, t2) => t1.zoom - t2.zoom);\n      this._dirty = false;\n    }\n  }\n\n  _getTile(index, create) {\n    const id = this.getTileId(index);\n\n    let tile = this._cache.get(id);\n\n    let needsReload = false;\n\n    if (!tile && create) {\n      tile = new Tile2DHeader(index);\n      Object.assign(tile, this.getTileMetadata(tile.index));\n      Object.assign(tile, {\n        id,\n        zoom: this.getTileZoom(tile.index)\n      });\n      needsReload = true;\n\n      this._cache.set(id, tile);\n\n      this._dirty = true;\n    } else if (tile && tile.needsReload) {\n      needsReload = true;\n    }\n\n    if (tile && needsReload) {\n      tile.loadData({\n        getData: this.opts.getTileData,\n        requestScheduler: this._requestScheduler,\n        onLoad: this.onTileLoad,\n        onError: this.opts.onTileError\n      });\n    }\n\n    return tile;\n  }\n\n  _getNearestAncestor(tile) {\n    const {\n      _minZoom = 0\n    } = this;\n    let index = tile.index;\n\n    while (this.getTileZoom(index) > _minZoom) {\n      index = this.getParentIndex(index);\n\n      const parent = this._getTile(index);\n\n      if (parent) {\n        return parent;\n      }\n    }\n\n    return null;\n  }\n\n}\n\nfunction updateTileStateDefault(allTiles) {\n  for (const tile of allTiles) {\n    tile.state = 0;\n  }\n\n  for (const tile of allTiles) {\n    if (tile.isSelected && !getPlaceholderInAncestors(tile)) {\n      getPlaceholderInChildren(tile);\n    }\n  }\n\n  for (const tile of allTiles) {\n    tile.isVisible = Boolean(tile.state & TILE_STATE_VISIBLE);\n  }\n}\n\nfunction updateTileStateReplace(allTiles) {\n  for (const tile of allTiles) {\n    tile.state = 0;\n  }\n\n  for (const tile of allTiles) {\n    if (tile.isSelected) {\n      getPlaceholderInAncestors(tile);\n    }\n  }\n\n  const sortedTiles = Array.from(allTiles).sort((t1, t2) => t1.zoom - t2.zoom);\n\n  for (const tile of sortedTiles) {\n    tile.isVisible = Boolean(tile.state & TILE_STATE_VISIBLE);\n\n    if (tile.children && (tile.isVisible || tile.state & TILE_STATE_VISITED)) {\n      for (const child of tile.children) {\n        child.state = TILE_STATE_VISITED;\n      }\n    } else if (tile.isSelected) {\n      getPlaceholderInChildren(tile);\n    }\n  }\n}\n\nfunction getPlaceholderInAncestors(startTile) {\n  let tile = startTile;\n\n  while (tile) {\n    if (tile.isLoaded || tile.content) {\n      tile.state |= TILE_STATE_VISIBLE;\n      return true;\n    }\n\n    tile = tile.parent;\n  }\n\n  return false;\n}\n\nfunction getPlaceholderInChildren(tile) {\n  for (const child of tile.children) {\n    if (child.isLoaded || child.content) {\n      child.state |= TILE_STATE_VISIBLE;\n    } else {\n      getPlaceholderInChildren(child);\n    }\n  }\n}\n//# sourceMappingURL=tileset-2d.js.map\n;// CONCATENATED MODULE: ./node_modules/@deck.gl/geo-layers/dist/esm/tile-layer/tile-layer.js\n\n\n\n\n\nconst tile_layer_defaultProps = {\n  TilesetClass: Tileset2D,\n  data: {\n    type: 'data',\n    value: []\n  },\n  dataComparator: urlType.equal,\n  renderSubLayers: {\n    type: 'function',\n    value: props => new GeoJsonLayer(props)\n  },\n  getTileData: {\n    type: 'function',\n    optional: true,\n    value: null\n  },\n  onViewportLoad: {\n    type: 'function',\n    optional: true,\n    value: null\n  },\n  onTileLoad: {\n    type: 'function',\n    value: tile => {}\n  },\n  onTileUnload: {\n    type: 'function',\n    value: tile => {}\n  },\n  onTileError: {\n    type: 'function',\n    value: err => console.error(err)\n  },\n  extent: {\n    type: 'array',\n    optional: true,\n    value: null,\n    compare: true\n  },\n  tileSize: 512,\n  maxZoom: null,\n  minZoom: 0,\n  maxCacheSize: null,\n  maxCacheByteSize: null,\n  refinementStrategy: STRATEGY_DEFAULT,\n  zRange: null,\n  maxRequests: 6,\n  zoomOffset: 0\n};\nclass TileLayer extends composite_layer/* default */.Z {\n  initializeState() {\n    this.state = {\n      tileset: null,\n      isLoaded: false\n    };\n  }\n\n  finalizeState() {\n    var _this$state, _this$state$tileset;\n\n    (_this$state = this.state) === null || _this$state === void 0 ? void 0 : (_this$state$tileset = _this$state.tileset) === null || _this$state$tileset === void 0 ? void 0 : _this$state$tileset.finalize();\n  }\n\n  get isLoaded() {\n    var _this$state2, _this$state2$tileset;\n\n    return (_this$state2 = this.state) === null || _this$state2 === void 0 ? void 0 : (_this$state2$tileset = _this$state2.tileset) === null || _this$state2$tileset === void 0 ? void 0 : _this$state2$tileset.selectedTiles.every(tile => tile.isLoaded && tile.layers && tile.layers.every(layer => layer.isLoaded));\n  }\n\n  shouldUpdateState({\n    changeFlags\n  }) {\n    return changeFlags.somethingChanged;\n  }\n\n  updateState({\n    changeFlags\n  }) {\n    let {\n      tileset\n    } = this.state;\n    const propsChanged = changeFlags.propsOrDataChanged || changeFlags.updateTriggersChanged;\n    const dataChanged = changeFlags.dataChanged || changeFlags.updateTriggersChanged && (changeFlags.updateTriggersChanged.all || changeFlags.updateTriggersChanged.getTileData);\n\n    if (!tileset) {\n      tileset = new this.props.TilesetClass(this._getTilesetOptions());\n      this.setState({\n        tileset\n      });\n    } else if (propsChanged) {\n      tileset.setOptions(this._getTilesetOptions());\n\n      if (dataChanged) {\n        tileset.reloadAll();\n      } else {\n        this.state.tileset.tiles.forEach(tile => {\n          tile.layers = null;\n        });\n      }\n    }\n\n    this._updateTileset();\n  }\n\n  _getTilesetOptions() {\n    const {\n      tileSize,\n      maxCacheSize,\n      maxCacheByteSize,\n      refinementStrategy,\n      extent,\n      maxZoom,\n      minZoom,\n      maxRequests,\n      zoomOffset\n    } = this.props;\n    return {\n      maxCacheSize,\n      maxCacheByteSize,\n      maxZoom,\n      minZoom,\n      tileSize,\n      refinementStrategy,\n      extent,\n      maxRequests,\n      zoomOffset,\n      getTileData: this.getTileData.bind(this),\n      onTileLoad: this._onTileLoad.bind(this),\n      onTileError: this._onTileError.bind(this),\n      onTileUnload: this._onTileUnload.bind(this)\n    };\n  }\n\n  _updateTileset() {\n    const {\n      tileset\n    } = this.state;\n    const {\n      zRange,\n      modelMatrix\n    } = this.props;\n    const frameNumber = tileset.update(this.context.viewport, {\n      zRange,\n      modelMatrix\n    });\n    const {\n      isLoaded\n    } = tileset;\n    const loadingStateChanged = this.state.isLoaded !== isLoaded;\n    const tilesetChanged = this.state.frameNumber !== frameNumber;\n\n    if (isLoaded && (loadingStateChanged || tilesetChanged)) {\n      this._onViewportLoad();\n    }\n\n    if (tilesetChanged) {\n      this.setState({\n        frameNumber\n      });\n    }\n\n    this.state.isLoaded = isLoaded;\n  }\n\n  _onViewportLoad() {\n    const {\n      tileset\n    } = this.state;\n    const {\n      onViewportLoad\n    } = this.props;\n\n    if (onViewportLoad) {\n      onViewportLoad(tileset.selectedTiles);\n    }\n  }\n\n  _onTileLoad(tile) {\n    this.props.onTileLoad(tile);\n    tile.layers = null;\n    this.setNeedsUpdate();\n  }\n\n  _onTileError(error, tile) {\n    this.props.onTileError(error);\n    tile.layers = null;\n    this.setNeedsUpdate();\n  }\n\n  _onTileUnload(tile) {\n    this.props.onTileUnload(tile);\n  }\n\n  getTileData(tile) {\n    const {\n      data,\n      getTileData,\n      fetch\n    } = this.props;\n    const {\n      signal\n    } = tile;\n    tile.url = typeof data === 'string' || Array.isArray(data) ? getURLFromTemplate(data, tile) : null;\n\n    if (getTileData) {\n      return getTileData(tile);\n    }\n\n    if (fetch && tile.url) {\n      return fetch(tile.url, {\n        propName: 'data',\n        layer: this,\n        signal\n      });\n    }\n\n    return null;\n  }\n\n  renderSubLayers(props) {\n    return this.props.renderSubLayers(props);\n  }\n\n  getSubLayerPropsByTile(tile) {\n    return null;\n  }\n\n  getPickingInfo({\n    info,\n    sourceLayer\n  }) {\n    const sourceTile = sourceLayer.props.tile;\n\n    if (info.picked) {\n      info.tile = sourceTile;\n    }\n\n    info.sourceTile = sourceTile;\n    return info;\n  }\n\n  _updateAutoHighlight(info) {\n    const sourceTile = info.sourceTile;\n\n    if (sourceTile && sourceTile.layers) {\n      for (const layer of sourceTile.layers) {\n        layer.updateAutoHighlight(info);\n      }\n    }\n  }\n\n  renderLayers() {\n    return this.state.tileset.tiles.map(tile => {\n      const subLayerProps = this.getSubLayerPropsByTile(tile);\n\n      if (!tile.isLoaded && !tile.content) {} else if (!tile.layers) {\n        const layers = this.renderSubLayers({ ...this.props,\n          id: \"\".concat(this.id, \"-\").concat(tile.id),\n          data: tile.content,\n          _offset: 0,\n          tile\n        });\n        tile.layers = (0,flatten/* flatten */.x)(layers, Boolean).map(layer => layer.clone({\n          tile,\n          ...subLayerProps\n        }));\n      } else if (subLayerProps && tile.layers[0] && Object.keys(subLayerProps).some(propName => tile.layers[0].props[propName] !== subLayerProps[propName])) {\n        tile.layers = tile.layers.map(layer => layer.clone(subLayerProps));\n      }\n\n      return tile.layers;\n    });\n  }\n\n  filterSubLayer({\n    layer,\n    cullRect\n  }) {\n    const {\n      tile\n    } = layer.props;\n    return this.state.tileset.isTileVisible(tile, cullRect);\n  }\n\n}\n\n(0,defineProperty/* default */.Z)(TileLayer, \"defaultProps\", tile_layer_defaultProps);\n\n(0,defineProperty/* default */.Z)(TileLayer, \"layerName\", 'TileLayer');\n//# sourceMappingURL=tile-layer.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjk4MjYuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7O0FBQU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG9CQUFvQix1QkFBdUI7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSwwQzs7Ozs7Ozs7Ozs7Ozs7OztBQ2xEQSxrRUFBZSxpRkFBaUYscUNBQXFDLHdDQUF3QyxpQ0FBaUMscUNBQXFDLG9DQUFvQyxvQ0FBb0MsdUNBQXVDLDBCQUEwQiw0QkFBNEIsZ0NBQWdDLGdDQUFnQywrQkFBK0IsbUNBQW1DLG1DQUFtQyx3QkFBd0Isc0JBQXNCLDRCQUE0Qix5QkFBeUIsMEJBQTBCLDZCQUE2Qiw0QkFBNEIsMEJBQTBCLDRCQUE0QixnQ0FBZ0Msa0NBQWtDLHVCQUF1QiwrQ0FBK0MsaUpBQWlKLHFLQUFxSyx5REFBeUQsMEdBQTBHLDhDQUE4QywrQkFBK0Isa0RBQWtELDRFQUE0RSx3QkFBd0IsMkhBQTJILHVEQUF1RCxnRUFBZ0UsMkNBQTJDLG1FQUFtRSxNQUFNLE1BQU0sb0ZBQW9GLDJDQUEyQyx3SEFBd0gsdURBQXVELEtBQUssOEVBQThFLDhDQUE4Qyw4RUFBOEUsOENBQThDLEdBQUcsR0FBRyxFQUFDO0FBQzNnRix5RDs7QUNEQSxvRUFBZSxnRkFBZ0Ysd0JBQXdCLHdCQUF3Qiw0QkFBNEIsNEJBQTRCLDBCQUEwQiw0QkFBNEIsZ0NBQWdDLGtDQUFrQyxxQkFBcUIsK0JBQStCLG9FQUFvRSxvSUFBb0ksNEJBQTRCLGNBQWMsS0FBSywwQkFBMEIsMktBQTJLLHFCQUFxQiwyREFBMkQsUUFBUSxNQUFNLDRCQUE0QixrQkFBa0IsU0FBUyxtRUFBbUUsT0FBTyxNQUFNLGtCQUFrQixnQ0FBZ0MsTUFBTSxNQUFNLGNBQWMsS0FBSyxpQ0FBaUMsZ0RBQWdELEdBQUcsR0FBRyxFQUFDO0FBQzdyQywyRDs7QUNEd0U7QUFDUjtBQUNoQjtBQUNDO0FBQ0U7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ2UsK0JBQStCLHdCQUFLO0FBQ25EO0FBQ0E7QUFDQSxRQUFRO0FBQ1IsUUFBUTtBQUNSLGdCQUFnQix3QkFBUyxFQUFFLHNCQUFPO0FBQ2xDLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLHNCQUFJO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixzQkFBSTtBQUMxQjtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBLGVBQWUsb0JBQUssT0FBTztBQUMzQjtBQUNBLG9CQUFvQix1QkFBUTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsS0FBSztBQUNMOztBQUVBOztBQUVBLGlDQUFlOztBQUVmLGlDQUFlO0FBQ2YsNkM7Ozs7OztBQ2pNQSxtRUFBZSwrRUFBK0UsMEJBQTBCLGlDQUFpQyxzQkFBc0IsbUJBQW1CLDRCQUE0QiwwQkFBMEIsOEJBQThCLDRCQUE0Qix3QkFBd0IsOEJBQThCLGtCQUFrQixxQkFBcUIscUJBQXFCLDZCQUE2Qiw4REFBOEQsMEJBQTBCLGdCQUFnQiwrQkFBK0IsMkVBQTJFLG9DQUFvQywrQkFBK0IsOEZBQThGLG9EQUFvRCwyQkFBMkIsU0FBUyxPQUFPLGdDQUFnQyxrQ0FBa0MsZ0JBQWdCLE9BQU8sb0RBQW9ELEtBQUssa0RBQWtELEdBQUcsR0FBRyxFQUFDO0FBQzlsQywwRDs7QUNEd0U7QUFDcEM7QUFDZ0I7QUFDRjtBQUNsRDtBQUNBO0FBQ0EsTUFBTSw2QkFBWTtBQUNsQjtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNlLDZCQUE2Qix5QkFBUztBQUNyRDtBQUNBOztBQUVBLElBQUksaUNBQWU7QUFDbkI7O0FBRUE7QUFDQSxhQUFhO0FBQ2IsUUFBUTtBQUNSO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLE1BQU07O0FBRU47QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBLE1BQU0sNEJBQVE7QUFDZDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsaUNBQWUsaUNBQWlDLDZCQUFZOztBQUU1RCxpQ0FBZTtBQUNmLDRDOzs7O0FDOUhvQztBQUNwQztBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsMkJBQTJCLGNBQWM7QUFDekM7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLDJCQUEyQixjQUFjO0FBQ3pDOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSwyQkFBMkIsY0FBYztBQUN6QztBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVPO0FBQ1A7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSwyQkFBMkIsY0FBYztBQUN6QztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ04sTUFBTSw0QkFBUTtBQUNkO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsa0JBQWtCLG9CQUFvQjtBQUN0Qzs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSw2QkFBNkIseUJBQXlCO0FBQ3REO0FBQ0E7QUFDQTs7QUFFQSwrQkFBK0IsWUFBWTtBQUMzQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsb0JBQW9CLG9CQUFvQjtBQUN4QztBQUNBO0FBQ0E7O0FBRUEsc0JBQXNCLGdCQUFnQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQzs7QUM5UXdFO0FBQ3pEO0FBQ2Y7QUFDQSxJQUFJLGlDQUFlOztBQUVuQixJQUFJLGlDQUFlLG1CQUFtQjs7QUFFdEMsSUFBSSxpQ0FBZTs7QUFFbkI7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHFDOztBQ2hFd0U7QUFDakM7QUFDSDtBQUNHO0FBQ0o7O0FBRW5DO0FBQ0E7O0FBRUEsbUJBQW1CLFNBQVM7QUFDNUI7QUFDQTs7QUFFQTtBQUNBOztBQUVPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixRQUFROztBQUV4QjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0Esa0JBQWtCLHlCQUF5QjtBQUMzQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVPO0FBQ1AsRUFBRSxnQ0FBVTtBQUNaLGNBQWMsUUFBUTtBQUN0QjtBQUNlO0FBQ2Y7QUFDQSxJQUFJLGlDQUFlLGtCQUFrQjtBQUNyQyxLQUFLOztBQUVMLElBQUksaUNBQWU7O0FBRW5CLElBQUksaUNBQWU7QUFDbkI7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNLEVBQUUsWUFBWTtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsMEJBQTBCLHVCQUFPO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTs7QUFFTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLDhDOztBQ2pPQSxzRUFBZSxxRkFBcUYscUNBQXFDLHdDQUF3QywrQkFBK0IsZ0NBQWdDLGlDQUFpQyxzQ0FBc0MscUNBQXFDLG9DQUFvQyxvQ0FBb0MsdUNBQXVDLDJCQUEyQix3QkFBd0IsMEJBQTBCLDhCQUE4Qiw4QkFBOEIsdUJBQXVCLHdCQUF3Qiw0QkFBNEIsMEJBQTBCLDJCQUEyQixrQkFBa0IsMEJBQTBCLG9EQUFvRCx3Q0FBd0Msd0NBQXdDLHdDQUF3Qyw0RUFBNEUsbUNBQW1DLEdBQUcscUJBQXFCLCtDQUErQyw0QkFBNEIsa0RBQWtELG1CQUFtQixvQ0FBb0MsdUlBQXVJLDJFQUEyRSxrSUFBa0ksK0RBQStELHdDQUF3QywwQkFBMEIsdUJBQXVCLDJIQUEySCx1REFBdUQsMkNBQTJDLDJDQUEyQyxtRUFBbUUsTUFBTSxNQUFNLHNFQUFzRSxrREFBa0QsK0hBQStILHVEQUF1RCxLQUFLLDhFQUE4RSw4Q0FBOEMsOEVBQThFLDhDQUE4QyxHQUFHLEdBQUcsRUFBQztBQUM1bEYsNkQ7O0FDREEsd0VBQWUsb0ZBQW9GLHlCQUF5Qiw0QkFBNEIsMEJBQTBCLDJCQUEyQixrQkFBa0IsMEJBQTBCLHFCQUFxQixxQkFBcUIsMkNBQTJDLGtCQUFrQiw4SkFBOEosMERBQTBELDJEQUEyRCxNQUFNLE1BQU0sZ0NBQWdDLEtBQUssa0RBQWtELEdBQUcsR0FBRyxFQUFDO0FBQzd0QiwrRDs7QUNEd0U7QUFDUjtBQUNoQjtBQUNLO0FBQ0U7QUFDdkQsTUFBTSxrQ0FBWTtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ2Usa0NBQWtDLHdCQUFLO0FBQ3REO0FBQ0E7O0FBRUEsSUFBSSxpQ0FBZTtBQUNuQjs7QUFFQTtBQUNBO0FBQ0EsUUFBUTtBQUNSLFFBQVE7QUFDUixnQkFBZ0Isd0JBQVMsRUFBRSxzQkFBTztBQUNsQyxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNOztBQUVOO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLE1BQU07O0FBRU47QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLHNCQUFJO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0EsZUFBZSxvQkFBSyxPQUFPO0FBQzNCO0FBQ0Esb0JBQW9CLHVCQUFRO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7O0FBRUEsaUNBQWUsc0NBQXNDLGtDQUFZOztBQUVqRSxpQ0FBZTtBQUNmLGlEOztBQzVMd0U7QUFDSjtBQUNIO0FBQ3NDO0FBQ3ZDO0FBQ2dCO0FBQ2hGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTSx3QkFBYTtBQUNuQjtBQUNBLE1BQU0sdUJBQVk7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxXQUFXLHdCQUFhO0FBQ3hCLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxXQUFXLGtDQUFrQztBQUM3QyxHQUFHO0FBQ0gsY0FBYyxnQ0FBZ0M7QUFDOUMsY0FBYyxnQ0FBZ0M7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsV0FBVyx3QkFBYTtBQUN4QixHQUFHO0FBQ0g7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxXQUFXLHdCQUFhO0FBQ3hCLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ2Usd0JBQXdCLDhCQUFjO0FBQ3JEO0FBQ0E7O0FBRUEsSUFBSSxpQ0FBZTs7QUFFbkIsSUFBSSxpQ0FBZTtBQUNuQjtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMLElBQUksaUNBQWU7QUFDbkI7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxzQkFBc0IsbUJBQW1CO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixnQkFBZ0I7QUFDNUM7O0FBRUE7QUFDQSxNQUFNLDRCQUFRO0FBQ2Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTix3QkFBd0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsRUFBRSxpQkFBaUIsR0FBRztBQUM5QjtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBLE9BQU87QUFDUCxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsUUFBUSxFQUFFLHlDQUFjO0FBQ3hCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxXQUFXLGtCQUFrQjtBQUM3Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTixxRUFBcUUsY0FBYztBQUNuRixxRUFBcUUsbUJBQW1CO0FBQ3hGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLG9GQUFvRiwrQkFBK0I7QUFDbkgsMkRBQTJELDRCQUE0QjtBQUN2RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0EsSUFBSSxzQkFBc0I7QUFDMUI7O0FBRUE7O0FBRUEsaUNBQWUsNEJBQTRCLHVCQUFZOztBQUV2RCxpQ0FBZTtBQUNmLHNDOzs7Ozs7QUM3YmlEO0FBQ3FCO0FBQ3JCO0FBQ0E7QUFDMEI7QUFDcEU7QUFDUDtBQUNBLFVBQVUsZ0JBQWdCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLFVBQVUseUJBQVM7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsVUFBVSxTQUFTO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1AsUUFBUSx5QkFBUztBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1AsUUFBUSxrQ0FBaUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0EsQ0FBQztBQUNEOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx5Qzs7QUNwSm9DO0FBQzdCO0FBQ1A7QUFDQTtBQUNBOztBQUVBLEVBQUUsZ0NBQVU7O0FBRVo7QUFDQTtBQUNBOztBQUVBO0FBQ0EsTUFBTSxnQ0FBVTtBQUNoQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNPLHNFQUFzRTtBQUM3RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKLG9DQUFvQyx1QkFBdUI7QUFDM0Q7QUFDQTtBQUNBO0FBQ0EsTUFBTTs7QUFFTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxNQUFNLGdDQUFVO0FBQ2hCO0FBQ0E7QUFDQSxRQUFROztBQUVSLHNCQUFzQix1QkFBdUI7QUFDN0M7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0EsSUFBSSw0QkFBUTtBQUNaO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYLFNBQVM7QUFDVCxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0EsRUFBRSxnQ0FBVTs7QUFFWjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG1DOztBQ3pLMEQ7O0FBRTFEO0FBQ0E7QUFDQSxjQUFjO0FBQ2QsYUFBYTtBQUNiLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSiw4QkFBOEIsc0JBQXNCO0FBQ3BEO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDOztBQ3RId0U7QUFDekI7QUFDTDtBQUNtQjtBQUMyQztBQUNoQztBQUN5QjtBQUNqRztBQUNBLE1BQU0sMEJBQVksS0FBSyxHQUFHLGVBQWUsQ0FBQyxrQkFBa0I7QUFDNUQsS0FBSyxlQUFlLENBQUMsZ0JBQWdCO0FBQ3JDLEtBQUssZUFBZSxDQUFDLGdCQUFnQjtBQUNyQyxLQUFLLGVBQWUsQ0FBQyxVQUFVO0FBQy9CLEtBQUssZUFBZSxDQUFDLGFBQWE7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ2UsMkJBQTJCLDhCQUFjO0FBQ3hEO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsdUJBQXVCLDBCQUEwQjtBQUNqRDtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxxQkFBcUIsa0JBQWtCO0FBQ3ZDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZ0NBQWdDLHVCQUF1Qjs7QUFFdkQ7QUFDQSxpQ0FBaUMsK0JBQWM7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBLE1BQU07QUFDTixvQkFBb0IsdUJBQXVCO0FBQzNDOztBQUVBLHVCQUF1Qiw0QkFBNEI7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxrSEFBa0gsa0JBQWtCOztBQUVwSTtBQUNBLDZCQUE2QixZQUFZLE9BQU8sbUJBQW1CO0FBQ25FOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLHVMQUF1TCxlQUFlO0FBQ3RNLCtJQUErSSxlQUFlOztBQUU5SjtBQUNBLDZCQUE2QixZQUFZLE9BQU8sZ0JBQWdCO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsTUFBTTs7QUFFTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZ0NBQWdDLFdBQVc7QUFDM0M7O0FBRUE7QUFDQSwrQkFBK0IsWUFBWTtBQUMzQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWiwrQkFBK0I7QUFDL0Isb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNOztBQUVOOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTs7QUFFTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1Isc0JBQXNCLHlCQUF5QjtBQUMvQztBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsaUNBQWU7O0FBRWYsaUNBQWUsK0JBQStCLDBCQUFZO0FBQzFELHlDOzs7Ozs7OztBQzFTd0U7QUFDakU7QUFDUDtBQUNBLElBQUksaUNBQWU7O0FBRW5CLElBQUksaUNBQWU7O0FBRW5CLElBQUksaUNBQWU7O0FBRW5CLElBQUksaUNBQWU7O0FBRW5CLElBQUksaUNBQWU7O0FBRW5CLElBQUksaUNBQWU7O0FBRW5CLElBQUksaUNBQWU7O0FBRW5CLElBQUksaUNBQWU7O0FBRW5CLElBQUksaUNBQWU7O0FBRW5CLElBQUksaUNBQWU7O0FBRW5CLElBQUksaUNBQWU7O0FBRW5CLElBQUksaUNBQWU7O0FBRW5CLElBQUksaUNBQWU7O0FBRW5CLElBQUksaUNBQWU7O0FBRW5CLElBQUksaUNBQWU7O0FBRW5CLElBQUksaUNBQWU7O0FBRW5CLElBQUksaUNBQWU7O0FBRW5CLElBQUksaUNBQWU7O0FBRW5CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDBDOzs7Ozs7Ozs7O0FDckx3RTtBQUNKO0FBQytDO0FBQzdEO0FBQ2I7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSSxpQ0FBZTs7QUFFbkIsSUFBSSxpQ0FBZTs7QUFFbkIsSUFBSSxpQ0FBZTs7QUFFbkIsSUFBSSxpQ0FBZTs7QUFFbkIsSUFBSSxpQ0FBZTs7QUFFbkIsSUFBSSxpQ0FBZTs7QUFFbkI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7O0FBRVI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsdUJBQXVCLGNBQWM7QUFDckM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGFBQWEsaURBQWlDO0FBQzlDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxrQ0FBc0I7QUFDckM7O0FBRUE7O0FBRU87QUFDUCxzQ0FBc0MsNkJBQWM7QUFDcEQ7QUFDQTtBQUNBO0FBQ0EsR0FBRyxTQUFTLGlCQUFLO0FBQ2pCLDRCQUE0Qix5QkFBYTtBQUN6QztBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsb0NBQW1COztBQUV0RDtBQUNBO0FBQ0Esb0JBQW9CLGtDQUFhO0FBQ2pDLHdCQUF3QixrQ0FBYTtBQUNyQztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSwwQkFBMEIsb0NBQW1CO0FBQzdDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSw2Qzs7QUM5THdEO0FBQ3hELE1BQU0sZUFBUztBQUNmO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBLG9CQUFvQixTQUFTO0FBQzdCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsK0JBQStCLGdCQUFnQjtBQUMvQztBQUNBOztBQUVBO0FBQ0EseUJBQXlCLElBQUk7QUFDN0I7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFTztBQUNQO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSw2RkFBNkYsZUFBUztBQUN0RztBQUNBOztBQUVBLG1DQUFtQyxlQUFTO0FBQzVDOztBQUVBO0FBQ0EsMEJBQTBCLGVBQVM7QUFDbkM7O0FBRU87QUFDUCw0QkFBNEIsZUFBUztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxzQkFBc0IsZUFBUyxjQUFjLGVBQVM7QUFDdEQ7O0FBRU8seURBQXlELGVBQVM7QUFDekU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsaUNBQWlDLFVBQVU7QUFDM0MsbUNBQW1DLFVBQVU7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBOztBQUVPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsZUFBUztBQUN0QjtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0QsdUVBQXVFLGVBQVM7O0FBRWhGO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxpQ0FBaUMsaUJBQWlCO0FBQ2xEO0FBQ087QUFDUCxnQkFBZ0IsRUFBRSxPQUFPLEVBQUUsUUFBUSxFQUFFLEVBQUUsR0FBRztBQUMxQztBQUNPO0FBQ1A7QUFDQTtBQUNBLGlDOztBQ3hPTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxvQkFBb0IsU0FBUztBQUM3QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxtQzs7QUN2Q3dFO0FBQ1o7QUFDWjtBQUNBO0FBQzJCO0FBQ3ZDO0FBQ3BDO0FBQ0E7QUFDTztBQUNBO0FBQ0E7QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ087QUFDUDtBQUNBLElBQUksaUNBQWU7O0FBRW5CLElBQUksaUNBQWU7O0FBRW5CLElBQUksaUNBQWU7O0FBRW5CLElBQUksaUNBQWU7O0FBRW5CLElBQUksaUNBQWU7O0FBRW5CLElBQUksaUNBQWU7O0FBRW5CLElBQUksaUNBQWU7O0FBRW5CLElBQUksaUNBQWU7O0FBRW5CLElBQUksaUNBQWU7O0FBRW5CLElBQUksaUNBQWU7O0FBRW5CLElBQUksaUNBQWU7O0FBRW5CLElBQUksaUNBQWU7O0FBRW5CLElBQUksaUNBQWU7O0FBRW5CLElBQUksaUNBQWU7O0FBRW5CLElBQUksaUNBQWU7O0FBRW5CLElBQUksaUNBQWUseUJBQXlCLE9BQU8sQ0FBQyxhQUFhOztBQUVqRSxrQkFBa0I7QUFDbEI7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLGlDQUFpQyxnQ0FBZ0I7QUFDakQ7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixzQkFBTztBQUNuQyxtQ0FBbUMsc0JBQU87QUFDMUM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLElBQUk7QUFDUixxQ0FBcUMsc0JBQU87QUFDNUM7O0FBRUEsZ0VBQWdFLHlCQUFNO0FBQ3RFO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBLFFBQVE7O0FBRVI7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTixXQUFXLGNBQWM7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsWUFBWSxpQkFBaUI7QUFDN0I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNOztBQUVOO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0EsaUJBQWlCLFlBQVk7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7O0FBRUE7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQzs7QUM3Z0J3RTtBQUNKO0FBQ3JCO0FBQ2E7QUFDQTtBQUM1RCxNQUFNLHVCQUFZO0FBQ2xCLGdCQUFnQixTQUFTO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxrQkFBa0IsYUFBYTtBQUMvQjtBQUNBO0FBQ0Esd0JBQXdCLFlBQVk7QUFDcEMsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixnQkFBZ0I7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDZSx3QkFBd0IsOEJBQWM7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLE1BQU07QUFDTjs7QUFFQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLE1BQU07O0FBRU47QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxNQUFNO0FBQ04saUVBQWlFLGtCQUFrQjs7QUFFbkY7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSw4Q0FBOEM7QUFDOUMsOENBQThDO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULHNCQUFzQiwwQkFBTztBQUM3QjtBQUNBO0FBQ0EsU0FBUztBQUNULFFBQVE7QUFDUjtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7O0FBRUEsaUNBQWUsNEJBQTRCLHVCQUFZOztBQUV2RCxpQ0FBZTtBQUNmIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdnVlMy13ZWJwYWNrNS8uL25vZGVfbW9kdWxlcy9AZGVjay5nbC9sYXllcnMvZGlzdC9lc20vZ2VvanNvbi1sYXllci9nZW9qc29uLWJpbmFyeS5qcz8wZmNmIiwid2VicGFjazovL3Z1ZTMtd2VicGFjazUvLi9ub2RlX21vZHVsZXMvQGRlY2suZ2wvbGF5ZXJzL2Rpc3QvZXNtL3NjYXR0ZXJwbG90LWxheWVyL3NjYXR0ZXJwbG90LWxheWVyLXZlcnRleC5nbHNsLmpzPzQyMWQiLCJ3ZWJwYWNrOi8vdnVlMy13ZWJwYWNrNS8uL25vZGVfbW9kdWxlcy9AZGVjay5nbC9sYXllcnMvZGlzdC9lc20vc2NhdHRlcnBsb3QtbGF5ZXIvc2NhdHRlcnBsb3QtbGF5ZXItZnJhZ21lbnQuZ2xzbC5qcz9mMTAxIiwid2VicGFjazovL3Z1ZTMtd2VicGFjazUvLi9ub2RlX21vZHVsZXMvQGRlY2suZ2wvbGF5ZXJzL2Rpc3QvZXNtL3NjYXR0ZXJwbG90LWxheWVyL3NjYXR0ZXJwbG90LWxheWVyLmpzPzIxZjYiLCJ3ZWJwYWNrOi8vdnVlMy13ZWJwYWNrNS8uL25vZGVfbW9kdWxlcy9AZGVjay5nbC9sYXllcnMvZGlzdC9lc20vdGV4dC1sYXllci9tdWx0aS1pY29uLWxheWVyL211bHRpLWljb24tbGF5ZXItZnJhZ21lbnQuZ2xzbC5qcz80MTRmIiwid2VicGFjazovL3Z1ZTMtd2VicGFjazUvLi9ub2RlX21vZHVsZXMvQGRlY2suZ2wvbGF5ZXJzL2Rpc3QvZXNtL3RleHQtbGF5ZXIvbXVsdGktaWNvbi1sYXllci9tdWx0aS1pY29uLWxheWVyLmpzPzA1YjkiLCJ3ZWJwYWNrOi8vdnVlMy13ZWJwYWNrNS8uL25vZGVfbW9kdWxlcy9AZGVjay5nbC9sYXllcnMvZGlzdC9lc20vdGV4dC1sYXllci91dGlscy5qcz8wOWMyIiwid2VicGFjazovL3Z1ZTMtd2VicGFjazUvLi9ub2RlX21vZHVsZXMvQGRlY2suZ2wvbGF5ZXJzL2Rpc3QvZXNtL3RleHQtbGF5ZXIvbHJ1LWNhY2hlLmpzPzZhMjciLCJ3ZWJwYWNrOi8vdnVlMy13ZWJwYWNrNS8uL25vZGVfbW9kdWxlcy9AZGVjay5nbC9sYXllcnMvZGlzdC9lc20vdGV4dC1sYXllci9mb250LWF0bGFzLW1hbmFnZXIuanM/MTQxMSIsIndlYnBhY2s6Ly92dWUzLXdlYnBhY2s1Ly4vbm9kZV9tb2R1bGVzL0BkZWNrLmdsL2xheWVycy9kaXN0L2VzbS90ZXh0LWxheWVyL3RleHQtYmFja2dyb3VuZC1sYXllci90ZXh0LWJhY2tncm91bmQtbGF5ZXItdmVydGV4Lmdsc2wuanM/YTRhYSIsIndlYnBhY2s6Ly92dWUzLXdlYnBhY2s1Ly4vbm9kZV9tb2R1bGVzL0BkZWNrLmdsL2xheWVycy9kaXN0L2VzbS90ZXh0LWxheWVyL3RleHQtYmFja2dyb3VuZC1sYXllci90ZXh0LWJhY2tncm91bmQtbGF5ZXItZnJhZ21lbnQuZ2xzbC5qcz9kZjIyIiwid2VicGFjazovL3Z1ZTMtd2VicGFjazUvLi9ub2RlX21vZHVsZXMvQGRlY2suZ2wvbGF5ZXJzL2Rpc3QvZXNtL3RleHQtbGF5ZXIvdGV4dC1iYWNrZ3JvdW5kLWxheWVyL3RleHQtYmFja2dyb3VuZC1sYXllci5qcz83YzA0Iiwid2VicGFjazovL3Z1ZTMtd2VicGFjazUvLi9ub2RlX21vZHVsZXMvQGRlY2suZ2wvbGF5ZXJzL2Rpc3QvZXNtL3RleHQtbGF5ZXIvdGV4dC1sYXllci5qcz9iMGMxIiwid2VicGFjazovL3Z1ZTMtd2VicGFjazUvLi9ub2RlX21vZHVsZXMvQGRlY2suZ2wvbGF5ZXJzL2Rpc3QvZXNtL2dlb2pzb24tbGF5ZXIvc3ViLWxheWVyLW1hcC5qcz9kOTJjIiwid2VicGFjazovL3Z1ZTMtd2VicGFjazUvLi9ub2RlX21vZHVsZXMvQGRlY2suZ2wvbGF5ZXJzL2Rpc3QvZXNtL2dlb2pzb24tbGF5ZXIvZ2VvanNvbi5qcz85MzI4Iiwid2VicGFjazovL3Z1ZTMtd2VicGFjazUvLi9ub2RlX21vZHVsZXMvQGRlY2suZ2wvbGF5ZXJzL2Rpc3QvZXNtL2dlb2pzb24tbGF5ZXIvZ2VvanNvbi1sYXllci1wcm9wcy5qcz83YTk0Iiwid2VicGFjazovL3Z1ZTMtd2VicGFjazUvLi9ub2RlX21vZHVsZXMvQGRlY2suZ2wvbGF5ZXJzL2Rpc3QvZXNtL2dlb2pzb24tbGF5ZXIvZ2VvanNvbi1sYXllci5qcz80NjUxIiwid2VicGFjazovL3Z1ZTMtd2VicGFjazUvLi9ub2RlX21vZHVsZXMvQGRlY2suZ2wvZ2VvLWxheWVycy9kaXN0L2VzbS90aWxlc2V0LTJkL3RpbGUtMmQtaGVhZGVyLmpzP2M5ZjMiLCJ3ZWJwYWNrOi8vdnVlMy13ZWJwYWNrNS8uL25vZGVfbW9kdWxlcy9AZGVjay5nbC9nZW8tbGF5ZXJzL2Rpc3QvZXNtL3RpbGVzZXQtMmQvdGlsZS0yZC10cmF2ZXJzYWwuanM/NThlZiIsIndlYnBhY2s6Ly92dWUzLXdlYnBhY2s1Ly4vbm9kZV9tb2R1bGVzL0BkZWNrLmdsL2dlby1sYXllcnMvZGlzdC9lc20vdGlsZXNldC0yZC91dGlscy5qcz8wNWJjIiwid2VicGFjazovL3Z1ZTMtd2VicGFjazUvLi9ub2RlX21vZHVsZXMvQGRlY2suZ2wvZ2VvLWxheWVycy9kaXN0L2VzbS90aWxlc2V0LTJkL21lbW9pemUuanM/ZDlkOSIsIndlYnBhY2s6Ly92dWUzLXdlYnBhY2s1Ly4vbm9kZV9tb2R1bGVzL0BkZWNrLmdsL2dlby1sYXllcnMvZGlzdC9lc20vdGlsZXNldC0yZC90aWxlc2V0LTJkLmpzPzM4NTMiLCJ3ZWJwYWNrOi8vdnVlMy13ZWJwYWNrNS8uL25vZGVfbW9kdWxlcy9AZGVjay5nbC9nZW8tbGF5ZXJzL2Rpc3QvZXNtL3RpbGUtbGF5ZXIvdGlsZS1sYXllci5qcz9jMTJhIl0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCBmdW5jdGlvbiBiaW5hcnlUb0ZlYXR1cmVGb3JBY2Nlc29yKGRhdGEsIGluZGV4KSB7XG4gIGlmICghZGF0YSkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgY29uc3QgZmVhdHVyZUluZGV4ID0gJ3N0YXJ0SW5kaWNlcycgaW4gZGF0YSA/IGRhdGEuc3RhcnRJbmRpY2VzW2luZGV4XSA6IGluZGV4O1xuICBjb25zdCBnZW9tZXRyeUluZGV4ID0gZGF0YS5mZWF0dXJlSWRzLnZhbHVlW2ZlYXR1cmVJbmRleF07XG5cbiAgaWYgKGZlYXR1cmVJbmRleCAhPT0gLTEpIHtcbiAgICByZXR1cm4gZ2V0UHJvcGVydGllc0ZvckluZGV4KGRhdGEsIGdlb21ldHJ5SW5kZXgsIGZlYXR1cmVJbmRleCk7XG4gIH1cblxuICByZXR1cm4gbnVsbDtcbn1cblxuZnVuY3Rpb24gZ2V0UHJvcGVydGllc0ZvckluZGV4KGRhdGEsIHByb3BlcnRpZXNJbmRleCwgbnVtZXJpY1Byb3BzSW5kZXgpIHtcbiAgY29uc3QgZmVhdHVyZSA9IHtcbiAgICBwcm9wZXJ0aWVzOiB7IC4uLmRhdGEucHJvcGVydGllc1twcm9wZXJ0aWVzSW5kZXhdXG4gICAgfVxuICB9O1xuXG4gIGZvciAoY29uc3QgcHJvcCBpbiBkYXRhLm51bWVyaWNQcm9wcykge1xuICAgIGZlYXR1cmUucHJvcGVydGllc1twcm9wXSA9IGRhdGEubnVtZXJpY1Byb3BzW3Byb3BdLnZhbHVlW251bWVyaWNQcm9wc0luZGV4XTtcbiAgfVxuXG4gIHJldHVybiBmZWF0dXJlO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gY2FsY3VsYXRlUGlja2luZ0NvbG9ycyhnZW9qc29uQmluYXJ5LCBlbmNvZGVQaWNraW5nQ29sb3IpIHtcbiAgY29uc3QgcGlja2luZ0NvbG9ycyA9IHtcbiAgICBwb2ludHM6IG51bGwsXG4gICAgbGluZXM6IG51bGwsXG4gICAgcG9seWdvbnM6IG51bGxcbiAgfTtcblxuICBmb3IgKGNvbnN0IGtleSBpbiBwaWNraW5nQ29sb3JzKSB7XG4gICAgY29uc3QgZmVhdHVyZUlkcyA9IGdlb2pzb25CaW5hcnlba2V5XS5nbG9iYWxGZWF0dXJlSWRzLnZhbHVlO1xuICAgIHBpY2tpbmdDb2xvcnNba2V5XSA9IG5ldyBVaW50OENsYW1wZWRBcnJheShmZWF0dXJlSWRzLmxlbmd0aCAqIDMpO1xuICAgIGNvbnN0IHBpY2tpbmdDb2xvciA9IFtdO1xuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBmZWF0dXJlSWRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBlbmNvZGVQaWNraW5nQ29sb3IoZmVhdHVyZUlkc1tpXSwgcGlja2luZ0NvbG9yKTtcbiAgICAgIHBpY2tpbmdDb2xvcnNba2V5XVtpICogMyArIDBdID0gcGlja2luZ0NvbG9yWzBdO1xuICAgICAgcGlja2luZ0NvbG9yc1trZXldW2kgKiAzICsgMV0gPSBwaWNraW5nQ29sb3JbMV07XG4gICAgICBwaWNraW5nQ29sb3JzW2tleV1baSAqIDMgKyAyXSA9IHBpY2tpbmdDb2xvclsyXTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gcGlja2luZ0NvbG9ycztcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWdlb2pzb24tYmluYXJ5LmpzLm1hcCIsImV4cG9ydCBkZWZhdWx0IFwiI2RlZmluZSBTSEFERVJfTkFNRSBzY2F0dGVycGxvdC1sYXllci12ZXJ0ZXgtc2hhZGVyXFxuXFxuYXR0cmlidXRlIHZlYzMgcG9zaXRpb25zO1xcblxcbmF0dHJpYnV0ZSB2ZWMzIGluc3RhbmNlUG9zaXRpb25zO1xcbmF0dHJpYnV0ZSB2ZWMzIGluc3RhbmNlUG9zaXRpb25zNjRMb3c7XFxuYXR0cmlidXRlIGZsb2F0IGluc3RhbmNlUmFkaXVzO1xcbmF0dHJpYnV0ZSBmbG9hdCBpbnN0YW5jZUxpbmVXaWR0aHM7XFxuYXR0cmlidXRlIHZlYzQgaW5zdGFuY2VGaWxsQ29sb3JzO1xcbmF0dHJpYnV0ZSB2ZWM0IGluc3RhbmNlTGluZUNvbG9ycztcXG5hdHRyaWJ1dGUgdmVjMyBpbnN0YW5jZVBpY2tpbmdDb2xvcnM7XFxuXFxudW5pZm9ybSBmbG9hdCBvcGFjaXR5O1xcbnVuaWZvcm0gZmxvYXQgcmFkaXVzU2NhbGU7XFxudW5pZm9ybSBmbG9hdCByYWRpdXNNaW5QaXhlbHM7XFxudW5pZm9ybSBmbG9hdCByYWRpdXNNYXhQaXhlbHM7XFxudW5pZm9ybSBmbG9hdCBsaW5lV2lkdGhTY2FsZTtcXG51bmlmb3JtIGZsb2F0IGxpbmVXaWR0aE1pblBpeGVscztcXG51bmlmb3JtIGZsb2F0IGxpbmVXaWR0aE1heFBpeGVscztcXG51bmlmb3JtIGZsb2F0IHN0cm9rZWQ7XFxudW5pZm9ybSBib29sIGZpbGxlZDtcXG51bmlmb3JtIGJvb2wgYW50aWFsaWFzaW5nO1xcbnVuaWZvcm0gYm9vbCBiaWxsYm9hcmQ7XFxudW5pZm9ybSBpbnQgcmFkaXVzVW5pdHM7XFxudW5pZm9ybSBpbnQgbGluZVdpZHRoVW5pdHM7XFxuXFxudmFyeWluZyB2ZWM0IHZGaWxsQ29sb3I7XFxudmFyeWluZyB2ZWM0IHZMaW5lQ29sb3I7XFxudmFyeWluZyB2ZWMyIHVuaXRQb3NpdGlvbjtcXG52YXJ5aW5nIGZsb2F0IGlubmVyVW5pdFJhZGl1cztcXG52YXJ5aW5nIGZsb2F0IG91dGVyUmFkaXVzUGl4ZWxzO1xcblxcblxcbnZvaWQgbWFpbih2b2lkKSB7XFxuICBnZW9tZXRyeS53b3JsZFBvc2l0aW9uID0gaW5zdGFuY2VQb3NpdGlvbnM7XFxuICBvdXRlclJhZGl1c1BpeGVscyA9IGNsYW1wKFxcbiAgICBwcm9qZWN0X3NpemVfdG9fcGl4ZWwocmFkaXVzU2NhbGUgKiBpbnN0YW5jZVJhZGl1cywgcmFkaXVzVW5pdHMpLFxcbiAgICByYWRpdXNNaW5QaXhlbHMsIHJhZGl1c01heFBpeGVsc1xcbiAgKTtcXG4gIGZsb2F0IGxpbmVXaWR0aFBpeGVscyA9IGNsYW1wKFxcbiAgICBwcm9qZWN0X3NpemVfdG9fcGl4ZWwobGluZVdpZHRoU2NhbGUgKiBpbnN0YW5jZUxpbmVXaWR0aHMsIGxpbmVXaWR0aFVuaXRzKSxcXG4gICAgbGluZVdpZHRoTWluUGl4ZWxzLCBsaW5lV2lkdGhNYXhQaXhlbHNcXG4gICk7XFxuICBvdXRlclJhZGl1c1BpeGVscyArPSBzdHJva2VkICogbGluZVdpZHRoUGl4ZWxzIC8gMi4wO1xcbiAgZmxvYXQgZWRnZVBhZGRpbmcgPSBhbnRpYWxpYXNpbmcgPyAob3V0ZXJSYWRpdXNQaXhlbHMgKyBTTU9PVEhfRURHRV9SQURJVVMpIC8gb3V0ZXJSYWRpdXNQaXhlbHMgOiAxLjA7XFxuICB1bml0UG9zaXRpb24gPSBlZGdlUGFkZGluZyAqIHBvc2l0aW9ucy54eTtcXG4gIGdlb21ldHJ5LnV2ID0gdW5pdFBvc2l0aW9uO1xcbiAgZ2VvbWV0cnkucGlja2luZ0NvbG9yID0gaW5zdGFuY2VQaWNraW5nQ29sb3JzO1xcblxcbiAgaW5uZXJVbml0UmFkaXVzID0gMS4wIC0gc3Ryb2tlZCAqIGxpbmVXaWR0aFBpeGVscyAvIG91dGVyUmFkaXVzUGl4ZWxzO1xcbiAgXFxuICBpZiAoYmlsbGJvYXJkKSB7XFxuICAgIGdsX1Bvc2l0aW9uID0gcHJvamVjdF9wb3NpdGlvbl90b19jbGlwc3BhY2UoaW5zdGFuY2VQb3NpdGlvbnMsIGluc3RhbmNlUG9zaXRpb25zNjRMb3csIHZlYzMoMC4wKSwgZ2VvbWV0cnkucG9zaXRpb24pO1xcbiAgICBERUNLR0xfRklMVEVSX0dMX1BPU0lUSU9OKGdsX1Bvc2l0aW9uLCBnZW9tZXRyeSk7XFxuICAgIHZlYzMgb2Zmc2V0ID0gZWRnZVBhZGRpbmcgKiBwb3NpdGlvbnMgKiBvdXRlclJhZGl1c1BpeGVscztcXG4gICAgREVDS0dMX0ZJTFRFUl9TSVpFKG9mZnNldCwgZ2VvbWV0cnkpO1xcbiAgICBnbF9Qb3NpdGlvbi54eSArPSBwcm9qZWN0X3BpeGVsX3NpemVfdG9fY2xpcHNwYWNlKG9mZnNldC54eSk7XFxuICB9IGVsc2Uge1xcbiAgICB2ZWMzIG9mZnNldCA9IGVkZ2VQYWRkaW5nICogcG9zaXRpb25zICogcHJvamVjdF9waXhlbF9zaXplKG91dGVyUmFkaXVzUGl4ZWxzKTtcXG4gICAgREVDS0dMX0ZJTFRFUl9TSVpFKG9mZnNldCwgZ2VvbWV0cnkpO1xcbiAgICBnbF9Qb3NpdGlvbiA9IHByb2plY3RfcG9zaXRpb25fdG9fY2xpcHNwYWNlKGluc3RhbmNlUG9zaXRpb25zLCBpbnN0YW5jZVBvc2l0aW9uczY0TG93LCBvZmZzZXQsIGdlb21ldHJ5LnBvc2l0aW9uKTtcXG4gICAgREVDS0dMX0ZJTFRFUl9HTF9QT1NJVElPTihnbF9Qb3NpdGlvbiwgZ2VvbWV0cnkpO1xcbiAgfVxcbiAgdkZpbGxDb2xvciA9IHZlYzQoaW5zdGFuY2VGaWxsQ29sb3JzLnJnYiwgaW5zdGFuY2VGaWxsQ29sb3JzLmEgKiBvcGFjaXR5KTtcXG4gIERFQ0tHTF9GSUxURVJfQ09MT1IodkZpbGxDb2xvciwgZ2VvbWV0cnkpO1xcbiAgdkxpbmVDb2xvciA9IHZlYzQoaW5zdGFuY2VMaW5lQ29sb3JzLnJnYiwgaW5zdGFuY2VMaW5lQ29sb3JzLmEgKiBvcGFjaXR5KTtcXG4gIERFQ0tHTF9GSUxURVJfQ09MT1IodkxpbmVDb2xvciwgZ2VvbWV0cnkpO1xcbn1cXG5cIjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXNjYXR0ZXJwbG90LWxheWVyLXZlcnRleC5nbHNsLmpzLm1hcCIsImV4cG9ydCBkZWZhdWx0IFwiI2RlZmluZSBTSEFERVJfTkFNRSBzY2F0dGVycGxvdC1sYXllci1mcmFnbWVudC1zaGFkZXJcXG5cXG5wcmVjaXNpb24gaGlnaHAgZmxvYXQ7XFxuXFxudW5pZm9ybSBib29sIGZpbGxlZDtcXG51bmlmb3JtIGZsb2F0IHN0cm9rZWQ7XFxudW5pZm9ybSBib29sIGFudGlhbGlhc2luZztcXG5cXG52YXJ5aW5nIHZlYzQgdkZpbGxDb2xvcjtcXG52YXJ5aW5nIHZlYzQgdkxpbmVDb2xvcjtcXG52YXJ5aW5nIHZlYzIgdW5pdFBvc2l0aW9uO1xcbnZhcnlpbmcgZmxvYXQgaW5uZXJVbml0UmFkaXVzO1xcbnZhcnlpbmcgZmxvYXQgb3V0ZXJSYWRpdXNQaXhlbHM7XFxuXFxudm9pZCBtYWluKHZvaWQpIHtcXG4gIGdlb21ldHJ5LnV2ID0gdW5pdFBvc2l0aW9uO1xcblxcbiAgZmxvYXQgZGlzdFRvQ2VudGVyID0gbGVuZ3RoKHVuaXRQb3NpdGlvbikgKiBvdXRlclJhZGl1c1BpeGVscztcXG4gIGZsb2F0IGluQ2lyY2xlID0gYW50aWFsaWFzaW5nID8gXFxuICAgIHNtb290aGVkZ2UoZGlzdFRvQ2VudGVyLCBvdXRlclJhZGl1c1BpeGVscykgOiBcXG4gICAgc3RlcChkaXN0VG9DZW50ZXIsIG91dGVyUmFkaXVzUGl4ZWxzKTtcXG5cXG4gIGlmIChpbkNpcmNsZSA9PSAwLjApIHtcXG4gICAgZGlzY2FyZDtcXG4gIH1cXG5cXG4gIGlmIChzdHJva2VkID4gMC41KSB7XFxuICAgIGZsb2F0IGlzTGluZSA9IGFudGlhbGlhc2luZyA/IFxcbiAgICAgIHNtb290aGVkZ2UoaW5uZXJVbml0UmFkaXVzICogb3V0ZXJSYWRpdXNQaXhlbHMsIGRpc3RUb0NlbnRlcikgOlxcbiAgICAgIHN0ZXAoaW5uZXJVbml0UmFkaXVzICogb3V0ZXJSYWRpdXNQaXhlbHMsIGRpc3RUb0NlbnRlcik7XFxuXFxuICAgIGlmIChmaWxsZWQpIHtcXG4gICAgICBnbF9GcmFnQ29sb3IgPSBtaXgodkZpbGxDb2xvciwgdkxpbmVDb2xvciwgaXNMaW5lKTtcXG4gICAgfSBlbHNlIHtcXG4gICAgICBpZiAoaXNMaW5lID09IDAuMCkge1xcbiAgICAgICAgZGlzY2FyZDtcXG4gICAgICB9XFxuICAgICAgZ2xfRnJhZ0NvbG9yID0gdmVjNCh2TGluZUNvbG9yLnJnYiwgdkxpbmVDb2xvci5hICogaXNMaW5lKTtcXG4gICAgfVxcbiAgfSBlbHNlIGlmIChmaWxsZWQpIHtcXG4gICAgZ2xfRnJhZ0NvbG9yID0gdkZpbGxDb2xvcjtcXG4gIH0gZWxzZSB7XFxuICAgIGRpc2NhcmQ7XFxuICB9XFxuXFxuICBnbF9GcmFnQ29sb3IuYSAqPSBpbkNpcmNsZTtcXG4gIERFQ0tHTF9GSUxURVJfQ09MT1IoZ2xfRnJhZ0NvbG9yLCBnZW9tZXRyeSk7XFxufVxcblwiO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c2NhdHRlcnBsb3QtbGF5ZXItZnJhZ21lbnQuZ2xzbC5qcy5tYXAiLCJpbXBvcnQgX2RlZmluZVByb3BlcnR5IGZyb20gXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9kZWZpbmVQcm9wZXJ0eVwiO1xuaW1wb3J0IHsgTGF5ZXIsIHByb2plY3QzMiwgcGlja2luZywgVU5JVCB9IGZyb20gJ0BkZWNrLmdsL2NvcmUnO1xuaW1wb3J0IHsgTW9kZWwsIEdlb21ldHJ5IH0gZnJvbSAnQGx1bWEuZ2wvY29yZSc7XG5pbXBvcnQgdnMgZnJvbSAnLi9zY2F0dGVycGxvdC1sYXllci12ZXJ0ZXguZ2xzbCc7XG5pbXBvcnQgZnMgZnJvbSAnLi9zY2F0dGVycGxvdC1sYXllci1mcmFnbWVudC5nbHNsJztcbmNvbnN0IERFRkFVTFRfQ09MT1IgPSBbMCwgMCwgMCwgMjU1XTtcbmNvbnN0IGRlZmF1bHRQcm9wcyA9IHtcbiAgcmFkaXVzVW5pdHM6ICdtZXRlcnMnLFxuICByYWRpdXNTY2FsZToge1xuICAgIHR5cGU6ICdudW1iZXInLFxuICAgIG1pbjogMCxcbiAgICB2YWx1ZTogMVxuICB9LFxuICByYWRpdXNNaW5QaXhlbHM6IHtcbiAgICB0eXBlOiAnbnVtYmVyJyxcbiAgICBtaW46IDAsXG4gICAgdmFsdWU6IDBcbiAgfSxcbiAgcmFkaXVzTWF4UGl4ZWxzOiB7XG4gICAgdHlwZTogJ251bWJlcicsXG4gICAgbWluOiAwLFxuICAgIHZhbHVlOiBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUlxuICB9LFxuICBsaW5lV2lkdGhVbml0czogJ21ldGVycycsXG4gIGxpbmVXaWR0aFNjYWxlOiB7XG4gICAgdHlwZTogJ251bWJlcicsXG4gICAgbWluOiAwLFxuICAgIHZhbHVlOiAxXG4gIH0sXG4gIGxpbmVXaWR0aE1pblBpeGVsczoge1xuICAgIHR5cGU6ICdudW1iZXInLFxuICAgIG1pbjogMCxcbiAgICB2YWx1ZTogMFxuICB9LFxuICBsaW5lV2lkdGhNYXhQaXhlbHM6IHtcbiAgICB0eXBlOiAnbnVtYmVyJyxcbiAgICBtaW46IDAsXG4gICAgdmFsdWU6IE51bWJlci5NQVhfU0FGRV9JTlRFR0VSXG4gIH0sXG4gIHN0cm9rZWQ6IGZhbHNlLFxuICBmaWxsZWQ6IHRydWUsXG4gIGJpbGxib2FyZDogZmFsc2UsXG4gIGFudGlhbGlhc2luZzogdHJ1ZSxcbiAgZ2V0UG9zaXRpb246IHtcbiAgICB0eXBlOiAnYWNjZXNzb3InLFxuICAgIHZhbHVlOiB4ID0+IHgucG9zaXRpb25cbiAgfSxcbiAgZ2V0UmFkaXVzOiB7XG4gICAgdHlwZTogJ2FjY2Vzc29yJyxcbiAgICB2YWx1ZTogMVxuICB9LFxuICBnZXRGaWxsQ29sb3I6IHtcbiAgICB0eXBlOiAnYWNjZXNzb3InLFxuICAgIHZhbHVlOiBERUZBVUxUX0NPTE9SXG4gIH0sXG4gIGdldExpbmVDb2xvcjoge1xuICAgIHR5cGU6ICdhY2Nlc3NvcicsXG4gICAgdmFsdWU6IERFRkFVTFRfQ09MT1JcbiAgfSxcbiAgZ2V0TGluZVdpZHRoOiB7XG4gICAgdHlwZTogJ2FjY2Vzc29yJyxcbiAgICB2YWx1ZTogMVxuICB9LFxuICBzdHJva2VXaWR0aDoge1xuICAgIGRlcHJlY2F0ZWRGb3I6ICdnZXRMaW5lV2lkdGgnXG4gIH0sXG4gIG91dGxpbmU6IHtcbiAgICBkZXByZWNhdGVkRm9yOiAnc3Ryb2tlZCdcbiAgfSxcbiAgZ2V0Q29sb3I6IHtcbiAgICBkZXByZWNhdGVkRm9yOiBbJ2dldEZpbGxDb2xvcicsICdnZXRMaW5lQ29sb3InXVxuICB9XG59O1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgU2NhdHRlcnBsb3RMYXllciBleHRlbmRzIExheWVyIHtcbiAgZ2V0U2hhZGVycygpIHtcbiAgICByZXR1cm4gc3VwZXIuZ2V0U2hhZGVycyh7XG4gICAgICB2cyxcbiAgICAgIGZzLFxuICAgICAgbW9kdWxlczogW3Byb2plY3QzMiwgcGlja2luZ11cbiAgICB9KTtcbiAgfVxuXG4gIGluaXRpYWxpemVTdGF0ZSgpIHtcbiAgICB0aGlzLmdldEF0dHJpYnV0ZU1hbmFnZXIoKS5hZGRJbnN0YW5jZWQoe1xuICAgICAgaW5zdGFuY2VQb3NpdGlvbnM6IHtcbiAgICAgICAgc2l6ZTogMyxcbiAgICAgICAgdHlwZTogNTEzMCxcbiAgICAgICAgZnA2NDogdGhpcy51c2U2NGJpdFBvc2l0aW9ucygpLFxuICAgICAgICB0cmFuc2l0aW9uOiB0cnVlLFxuICAgICAgICBhY2Nlc3NvcjogJ2dldFBvc2l0aW9uJ1xuICAgICAgfSxcbiAgICAgIGluc3RhbmNlUmFkaXVzOiB7XG4gICAgICAgIHNpemU6IDEsXG4gICAgICAgIHRyYW5zaXRpb246IHRydWUsXG4gICAgICAgIGFjY2Vzc29yOiAnZ2V0UmFkaXVzJyxcbiAgICAgICAgZGVmYXVsdFZhbHVlOiAxXG4gICAgICB9LFxuICAgICAgaW5zdGFuY2VGaWxsQ29sb3JzOiB7XG4gICAgICAgIHNpemU6IHRoaXMucHJvcHMuY29sb3JGb3JtYXQubGVuZ3RoLFxuICAgICAgICB0cmFuc2l0aW9uOiB0cnVlLFxuICAgICAgICBub3JtYWxpemVkOiB0cnVlLFxuICAgICAgICB0eXBlOiA1MTIxLFxuICAgICAgICBhY2Nlc3NvcjogJ2dldEZpbGxDb2xvcicsXG4gICAgICAgIGRlZmF1bHRWYWx1ZTogWzAsIDAsIDAsIDI1NV1cbiAgICAgIH0sXG4gICAgICBpbnN0YW5jZUxpbmVDb2xvcnM6IHtcbiAgICAgICAgc2l6ZTogdGhpcy5wcm9wcy5jb2xvckZvcm1hdC5sZW5ndGgsXG4gICAgICAgIHRyYW5zaXRpb246IHRydWUsXG4gICAgICAgIG5vcm1hbGl6ZWQ6IHRydWUsXG4gICAgICAgIHR5cGU6IDUxMjEsXG4gICAgICAgIGFjY2Vzc29yOiAnZ2V0TGluZUNvbG9yJyxcbiAgICAgICAgZGVmYXVsdFZhbHVlOiBbMCwgMCwgMCwgMjU1XVxuICAgICAgfSxcbiAgICAgIGluc3RhbmNlTGluZVdpZHRoczoge1xuICAgICAgICBzaXplOiAxLFxuICAgICAgICB0cmFuc2l0aW9uOiB0cnVlLFxuICAgICAgICBhY2Nlc3NvcjogJ2dldExpbmVXaWR0aCcsXG4gICAgICAgIGRlZmF1bHRWYWx1ZTogMVxuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgdXBkYXRlU3RhdGUocGFyYW1zKSB7XG4gICAgc3VwZXIudXBkYXRlU3RhdGUocGFyYW1zKTtcblxuICAgIGlmIChwYXJhbXMuY2hhbmdlRmxhZ3MuZXh0ZW5zaW9uc0NoYW5nZWQpIHtcbiAgICAgIHZhciBfdGhpcyRzdGF0ZSRtb2RlbDtcblxuICAgICAgY29uc3Qge1xuICAgICAgICBnbFxuICAgICAgfSA9IHRoaXMuY29udGV4dDtcbiAgICAgIChfdGhpcyRzdGF0ZSRtb2RlbCA9IHRoaXMuc3RhdGUubW9kZWwpID09PSBudWxsIHx8IF90aGlzJHN0YXRlJG1vZGVsID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfdGhpcyRzdGF0ZSRtb2RlbC5kZWxldGUoKTtcbiAgICAgIHRoaXMuc3RhdGUubW9kZWwgPSB0aGlzLl9nZXRNb2RlbChnbCk7XG4gICAgICB0aGlzLmdldEF0dHJpYnV0ZU1hbmFnZXIoKS5pbnZhbGlkYXRlQWxsKCk7XG4gICAgfVxuICB9XG5cbiAgZHJhdyh7XG4gICAgdW5pZm9ybXNcbiAgfSkge1xuICAgIGNvbnN0IHtcbiAgICAgIHJhZGl1c1VuaXRzLFxuICAgICAgcmFkaXVzU2NhbGUsXG4gICAgICByYWRpdXNNaW5QaXhlbHMsXG4gICAgICByYWRpdXNNYXhQaXhlbHMsXG4gICAgICBzdHJva2VkLFxuICAgICAgZmlsbGVkLFxuICAgICAgYmlsbGJvYXJkLFxuICAgICAgYW50aWFsaWFzaW5nLFxuICAgICAgbGluZVdpZHRoVW5pdHMsXG4gICAgICBsaW5lV2lkdGhTY2FsZSxcbiAgICAgIGxpbmVXaWR0aE1pblBpeGVscyxcbiAgICAgIGxpbmVXaWR0aE1heFBpeGVsc1xuICAgIH0gPSB0aGlzLnByb3BzO1xuICAgIHRoaXMuc3RhdGUubW9kZWwuc2V0VW5pZm9ybXModW5pZm9ybXMpLnNldFVuaWZvcm1zKHtcbiAgICAgIHN0cm9rZWQ6IHN0cm9rZWQgPyAxIDogMCxcbiAgICAgIGZpbGxlZCxcbiAgICAgIGJpbGxib2FyZCxcbiAgICAgIGFudGlhbGlhc2luZyxcbiAgICAgIHJhZGl1c1VuaXRzOiBVTklUW3JhZGl1c1VuaXRzXSxcbiAgICAgIHJhZGl1c1NjYWxlLFxuICAgICAgcmFkaXVzTWluUGl4ZWxzLFxuICAgICAgcmFkaXVzTWF4UGl4ZWxzLFxuICAgICAgbGluZVdpZHRoVW5pdHM6IFVOSVRbbGluZVdpZHRoVW5pdHNdLFxuICAgICAgbGluZVdpZHRoU2NhbGUsXG4gICAgICBsaW5lV2lkdGhNaW5QaXhlbHMsXG4gICAgICBsaW5lV2lkdGhNYXhQaXhlbHNcbiAgICB9KS5kcmF3KCk7XG4gIH1cblxuICBfZ2V0TW9kZWwoZ2wpIHtcbiAgICBjb25zdCBwb3NpdGlvbnMgPSBbLTEsIC0xLCAwLCAxLCAtMSwgMCwgMSwgMSwgMCwgLTEsIDEsIDBdO1xuICAgIHJldHVybiBuZXcgTW9kZWwoZ2wsIHsgLi4udGhpcy5nZXRTaGFkZXJzKCksXG4gICAgICBpZDogdGhpcy5wcm9wcy5pZCxcbiAgICAgIGdlb21ldHJ5OiBuZXcgR2VvbWV0cnkoe1xuICAgICAgICBkcmF3TW9kZTogNixcbiAgICAgICAgdmVydGV4Q291bnQ6IDQsXG4gICAgICAgIGF0dHJpYnV0ZXM6IHtcbiAgICAgICAgICBwb3NpdGlvbnM6IHtcbiAgICAgICAgICAgIHNpemU6IDMsXG4gICAgICAgICAgICB2YWx1ZTogbmV3IEZsb2F0MzJBcnJheShwb3NpdGlvbnMpXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KSxcbiAgICAgIGlzSW5zdGFuY2VkOiB0cnVlXG4gICAgfSk7XG4gIH1cblxufVxuXG5fZGVmaW5lUHJvcGVydHkoU2NhdHRlcnBsb3RMYXllciwgXCJkZWZhdWx0UHJvcHNcIiwgZGVmYXVsdFByb3BzKTtcblxuX2RlZmluZVByb3BlcnR5KFNjYXR0ZXJwbG90TGF5ZXIsIFwibGF5ZXJOYW1lXCIsICdTY2F0dGVycGxvdExheWVyJyk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zY2F0dGVycGxvdC1sYXllci5qcy5tYXAiLCJleHBvcnQgZGVmYXVsdCBcIiNkZWZpbmUgU0hBREVSX05BTUUgbXVsdGktaWNvbi1sYXllci1mcmFnbWVudC1zaGFkZXJcXG5cXG5wcmVjaXNpb24gaGlnaHAgZmxvYXQ7XFxuXFxudW5pZm9ybSBmbG9hdCBvcGFjaXR5O1xcbnVuaWZvcm0gc2FtcGxlcjJEIGljb25zVGV4dHVyZTtcXG51bmlmb3JtIGZsb2F0IGdhbW1hO1xcbnVuaWZvcm0gYm9vbCBzZGY7XFxudW5pZm9ybSBmbG9hdCBhbHBoYUN1dG9mZjtcXG51bmlmb3JtIGZsb2F0IHNkZkJ1ZmZlcjtcXG51bmlmb3JtIGZsb2F0IG91dGxpbmVCdWZmZXI7XFxudW5pZm9ybSB2ZWM0IG91dGxpbmVDb2xvcjtcXG5cXG52YXJ5aW5nIHZlYzQgdkNvbG9yO1xcbnZhcnlpbmcgdmVjMiB2VGV4dHVyZUNvb3JkcztcXG52YXJ5aW5nIHZlYzIgdXY7XFxuXFxudm9pZCBtYWluKHZvaWQpIHtcXG4gIGdlb21ldHJ5LnV2ID0gdXY7XFxuXFxuICBpZiAoIXBpY2tpbmdfdUFjdGl2ZSkge1xcbiAgICBmbG9hdCBhbHBoYSA9IHRleHR1cmUyRChpY29uc1RleHR1cmUsIHZUZXh0dXJlQ29vcmRzKS5hO1xcbiAgICB2ZWM0IGNvbG9yID0gdkNvbG9yO1xcbiAgICBpZiAoc2RmKSB7XFxuICAgICAgZmxvYXQgZGlzdGFuY2UgPSBhbHBoYTtcXG4gICAgICBhbHBoYSA9IHNtb290aHN0ZXAoc2RmQnVmZmVyIC0gZ2FtbWEsIHNkZkJ1ZmZlciArIGdhbW1hLCBkaXN0YW5jZSk7XFxuXFxuICAgICAgaWYgKG91dGxpbmVCdWZmZXIgPiAwLjApIHtcXG4gICAgICAgIGZsb2F0IGluRmlsbCA9IGFscGhhO1xcbiAgICAgICAgZmxvYXQgaW5Cb3JkZXIgPSBzbW9vdGhzdGVwKG91dGxpbmVCdWZmZXIgLSBnYW1tYSwgb3V0bGluZUJ1ZmZlciArIGdhbW1hLCBkaXN0YW5jZSk7XFxuICAgICAgICBjb2xvciA9IG1peChvdXRsaW5lQ29sb3IsIHZDb2xvciwgaW5GaWxsKTtcXG4gICAgICAgIGFscGhhID0gaW5Cb3JkZXI7XFxuICAgICAgfVxcbiAgICB9XFxuICAgIGZsb2F0IGEgPSBhbHBoYSAqIGNvbG9yLmE7XFxuICAgIFxcbiAgICBpZiAoYSA8IGFscGhhQ3V0b2ZmKSB7XFxuICAgICAgZGlzY2FyZDtcXG4gICAgfVxcblxcbiAgICBnbF9GcmFnQ29sb3IgPSB2ZWM0KGNvbG9yLnJnYiwgYSAqIG9wYWNpdHkpO1xcbiAgfVxcblxcbiAgREVDS0dMX0ZJTFRFUl9DT0xPUihnbF9GcmFnQ29sb3IsIGdlb21ldHJ5KTtcXG59XFxuXCI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1tdWx0aS1pY29uLWxheWVyLWZyYWdtZW50Lmdsc2wuanMubWFwIiwiaW1wb3J0IF9kZWZpbmVQcm9wZXJ0eSBmcm9tIFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vZGVmaW5lUHJvcGVydHlcIjtcbmltcG9ydCB7IGxvZyB9IGZyb20gJ0BkZWNrLmdsL2NvcmUnO1xuaW1wb3J0IEljb25MYXllciBmcm9tICcuLi8uLi9pY29uLWxheWVyL2ljb24tbGF5ZXInO1xuaW1wb3J0IGZzIGZyb20gJy4vbXVsdGktaWNvbi1sYXllci1mcmFnbWVudC5nbHNsJztcbmNvbnN0IERFRkFVTFRfQlVGRkVSID0gMTkyLjAgLyAyNTY7XG5jb25zdCBFTVBUWV9BUlJBWSA9IFtdO1xuY29uc3QgZGVmYXVsdFByb3BzID0ge1xuICBnZXRJY29uT2Zmc2V0czoge1xuICAgIHR5cGU6ICdhY2Nlc3NvcicsXG4gICAgdmFsdWU6IHggPT4geC5vZmZzZXRzXG4gIH0sXG4gIGFscGhhQ3V0b2ZmOiAwLjAwMSxcbiAgc21vb3RoaW5nOiAwLjEsXG4gIG91dGxpbmVXaWR0aDogMCxcbiAgb3V0bGluZUNvbG9yOiB7XG4gICAgdHlwZTogJ2NvbG9yJyxcbiAgICB2YWx1ZTogWzAsIDAsIDAsIDI1NV1cbiAgfVxufTtcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIE11bHRpSWNvbkxheWVyIGV4dGVuZHMgSWNvbkxheWVyIHtcbiAgY29uc3RydWN0b3IoLi4uYXJncykge1xuICAgIHN1cGVyKC4uLmFyZ3MpO1xuXG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwic3RhdGVcIiwgdm9pZCAwKTtcbiAgfVxuXG4gIGdldFNoYWRlcnMoKSB7XG4gICAgcmV0dXJuIHsgLi4uc3VwZXIuZ2V0U2hhZGVycygpLFxuICAgICAgZnNcbiAgICB9O1xuICB9XG5cbiAgaW5pdGlhbGl6ZVN0YXRlKCkge1xuICAgIHN1cGVyLmluaXRpYWxpemVTdGF0ZSgpO1xuICAgIGNvbnN0IGF0dHJpYnV0ZU1hbmFnZXIgPSB0aGlzLmdldEF0dHJpYnV0ZU1hbmFnZXIoKTtcbiAgICBhdHRyaWJ1dGVNYW5hZ2VyLmFkZEluc3RhbmNlZCh7XG4gICAgICBpbnN0YW5jZU9mZnNldHM6IHtcbiAgICAgICAgc2l6ZTogMixcbiAgICAgICAgYWNjZXNzb3I6ICdnZXRJY29uT2Zmc2V0cydcbiAgICAgIH0sXG4gICAgICBpbnN0YW5jZVBpY2tpbmdDb2xvcnM6IHtcbiAgICAgICAgdHlwZTogNTEyMSxcbiAgICAgICAgc2l6ZTogMyxcbiAgICAgICAgYWNjZXNzb3I6IChvYmplY3QsIHtcbiAgICAgICAgICBpbmRleCxcbiAgICAgICAgICB0YXJnZXQ6IHZhbHVlXG4gICAgICAgIH0pID0+IHRoaXMuZW5jb2RlUGlja2luZ0NvbG9yKGluZGV4LCB2YWx1ZSlcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIHVwZGF0ZVN0YXRlKHBhcmFtcykge1xuICAgIHN1cGVyLnVwZGF0ZVN0YXRlKHBhcmFtcyk7XG4gICAgY29uc3Qge1xuICAgICAgcHJvcHMsXG4gICAgICBvbGRQcm9wc1xuICAgIH0gPSBwYXJhbXM7XG4gICAgbGV0IHtcbiAgICAgIG91dGxpbmVDb2xvclxuICAgIH0gPSBwcm9wcztcblxuICAgIGlmIChvdXRsaW5lQ29sb3IgIT09IG9sZFByb3BzLm91dGxpbmVDb2xvcikge1xuICAgICAgb3V0bGluZUNvbG9yID0gb3V0bGluZUNvbG9yLm1hcCh4ID0+IHggLyAyNTUpO1xuICAgICAgb3V0bGluZUNvbG9yWzNdID0gTnVtYmVyLmlzRmluaXRlKG91dGxpbmVDb2xvclszXSkgPyBvdXRsaW5lQ29sb3JbM10gOiAxO1xuICAgICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICAgIG91dGxpbmVDb2xvclxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgaWYgKCFwcm9wcy5zZGYgJiYgcHJvcHMub3V0bGluZVdpZHRoKSB7XG4gICAgICBsb2cud2FybihcIlwiLmNvbmNhdCh0aGlzLmlkLCBcIjogZm9udFNldHRpbmdzLnNkZiBpcyByZXF1aXJlZCB0byByZW5kZXIgb3V0bGluZVwiKSkoKTtcbiAgICB9XG4gIH1cblxuICBkcmF3KHBhcmFtcykge1xuICAgIGNvbnN0IHtcbiAgICAgIHNkZixcbiAgICAgIHNtb290aGluZyxcbiAgICAgIG91dGxpbmVXaWR0aFxuICAgIH0gPSB0aGlzLnByb3BzO1xuICAgIGNvbnN0IHtcbiAgICAgIG91dGxpbmVDb2xvclxuICAgIH0gPSB0aGlzLnN0YXRlO1xuICAgIGNvbnN0IG91dGxpbmVCdWZmZXIgPSBvdXRsaW5lV2lkdGggPyBNYXRoLm1heChzbW9vdGhpbmcsIERFRkFVTFRfQlVGRkVSICogKDEgLSBvdXRsaW5lV2lkdGgpKSA6IC0xO1xuICAgIHBhcmFtcy51bmlmb3JtcyA9IHsgLi4ucGFyYW1zLnVuaWZvcm1zLFxuICAgICAgc2RmQnVmZmVyOiBERUZBVUxUX0JVRkZFUixcbiAgICAgIG91dGxpbmVCdWZmZXIsXG4gICAgICBnYW1tYTogc21vb3RoaW5nLFxuICAgICAgc2RmOiBCb29sZWFuKHNkZiksXG4gICAgICBvdXRsaW5lQ29sb3JcbiAgICB9O1xuICAgIHN1cGVyLmRyYXcocGFyYW1zKTtcblxuICAgIGlmIChzZGYgJiYgb3V0bGluZVdpZHRoKSB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIGljb25NYW5hZ2VyXG4gICAgICB9ID0gdGhpcy5zdGF0ZTtcbiAgICAgIGNvbnN0IGljb25zVGV4dHVyZSA9IGljb25NYW5hZ2VyLmdldFRleHR1cmUoKTtcblxuICAgICAgaWYgKGljb25zVGV4dHVyZSkge1xuICAgICAgICB0aGlzLnN0YXRlLm1vZGVsLmRyYXcoe1xuICAgICAgICAgIHVuaWZvcm1zOiB7XG4gICAgICAgICAgICBvdXRsaW5lQnVmZmVyOiBERUZBVUxUX0JVRkZFUlxuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZ2V0SW5zdGFuY2VPZmZzZXQoaWNvbnMpIHtcbiAgICByZXR1cm4gaWNvbnMgPyBBcnJheS5mcm9tKGljb25zKS5mbGF0TWFwKGljb24gPT4gc3VwZXIuZ2V0SW5zdGFuY2VPZmZzZXQoaWNvbikpIDogRU1QVFlfQVJSQVk7XG4gIH1cblxuICBnZXRJbnN0YW5jZUNvbG9yTW9kZShpY29ucykge1xuICAgIHJldHVybiAxO1xuICB9XG5cbiAgZ2V0SW5zdGFuY2VJY29uRnJhbWUoaWNvbnMpIHtcbiAgICByZXR1cm4gaWNvbnMgPyBBcnJheS5mcm9tKGljb25zKS5mbGF0TWFwKGljb24gPT4gc3VwZXIuZ2V0SW5zdGFuY2VJY29uRnJhbWUoaWNvbikpIDogRU1QVFlfQVJSQVk7XG4gIH1cblxufVxuXG5fZGVmaW5lUHJvcGVydHkoTXVsdGlJY29uTGF5ZXIsIFwiZGVmYXVsdFByb3BzXCIsIGRlZmF1bHRQcm9wcyk7XG5cbl9kZWZpbmVQcm9wZXJ0eShNdWx0aUljb25MYXllciwgXCJsYXllck5hbWVcIiwgJ011bHRpSWNvbkxheWVyJyk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1tdWx0aS1pY29uLWxheWVyLmpzLm1hcCIsImltcG9ydCB7IGxvZyB9IGZyb20gJ0BkZWNrLmdsL2NvcmUnO1xuY29uc3QgTUlTU0lOR19DSEFSX1dJRFRIID0gMzI7XG5jb25zdCBTSU5HTEVfTElORSA9IFtdO1xuZXhwb3J0IGZ1bmN0aW9uIG5leHRQb3dPZlR3byhudW1iZXIpIHtcbiAgcmV0dXJuIE1hdGgucG93KDIsIE1hdGguY2VpbChNYXRoLmxvZzIobnVtYmVyKSkpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGJ1aWxkTWFwcGluZyh7XG4gIGNoYXJhY3RlclNldCxcbiAgZ2V0Rm9udFdpZHRoLFxuICBmb250SGVpZ2h0LFxuICBidWZmZXIsXG4gIG1heENhbnZhc1dpZHRoLFxuICBtYXBwaW5nID0ge30sXG4gIHhPZmZzZXQgPSAwLFxuICB5T2Zmc2V0ID0gMFxufSkge1xuICBsZXQgcm93ID0gMDtcbiAgbGV0IHggPSB4T2Zmc2V0O1xuICBjb25zdCByb3dIZWlnaHQgPSBmb250SGVpZ2h0ICsgYnVmZmVyICogMjtcblxuICBmb3IgKGNvbnN0IGNoYXIgb2YgY2hhcmFjdGVyU2V0KSB7XG4gICAgaWYgKCFtYXBwaW5nW2NoYXJdKSB7XG4gICAgICBjb25zdCB3aWR0aCA9IGdldEZvbnRXaWR0aChjaGFyKTtcblxuICAgICAgaWYgKHggKyB3aWR0aCArIGJ1ZmZlciAqIDIgPiBtYXhDYW52YXNXaWR0aCkge1xuICAgICAgICB4ID0gMDtcbiAgICAgICAgcm93Kys7XG4gICAgICB9XG5cbiAgICAgIG1hcHBpbmdbY2hhcl0gPSB7XG4gICAgICAgIHg6IHggKyBidWZmZXIsXG4gICAgICAgIHk6IHlPZmZzZXQgKyByb3cgKiByb3dIZWlnaHQgKyBidWZmZXIsXG4gICAgICAgIHdpZHRoLFxuICAgICAgICBoZWlnaHQ6IHJvd0hlaWdodCxcbiAgICAgICAgbGF5b3V0V2lkdGg6IHdpZHRoLFxuICAgICAgICBsYXlvdXRIZWlnaHQ6IGZvbnRIZWlnaHRcbiAgICAgIH07XG4gICAgICB4ICs9IHdpZHRoICsgYnVmZmVyICogMjtcbiAgICB9XG4gIH1cblxuICByZXR1cm4ge1xuICAgIG1hcHBpbmcsXG4gICAgeE9mZnNldDogeCxcbiAgICB5T2Zmc2V0OiB5T2Zmc2V0ICsgcm93ICogcm93SGVpZ2h0LFxuICAgIGNhbnZhc0hlaWdodDogbmV4dFBvd09mVHdvKHlPZmZzZXQgKyAocm93ICsgMSkgKiByb3dIZWlnaHQpXG4gIH07XG59XG5cbmZ1bmN0aW9uIGdldFRleHRXaWR0aCh0ZXh0LCBzdGFydEluZGV4LCBlbmRJbmRleCwgbWFwcGluZykge1xuICBsZXQgd2lkdGggPSAwO1xuXG4gIGZvciAobGV0IGkgPSBzdGFydEluZGV4OyBpIDwgZW5kSW5kZXg7IGkrKykge1xuICAgIHZhciBfbWFwcGluZyRjaGFyYWN0ZXI7XG5cbiAgICBjb25zdCBjaGFyYWN0ZXIgPSB0ZXh0W2ldO1xuICAgIHdpZHRoICs9ICgoX21hcHBpbmckY2hhcmFjdGVyID0gbWFwcGluZ1tjaGFyYWN0ZXJdKSA9PT0gbnVsbCB8fCBfbWFwcGluZyRjaGFyYWN0ZXIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9tYXBwaW5nJGNoYXJhY3Rlci5sYXlvdXRXaWR0aCkgfHwgMDtcbiAgfVxuXG4gIHJldHVybiB3aWR0aDtcbn1cblxuZnVuY3Rpb24gYnJlYWtBbGwodGV4dCwgc3RhcnRJbmRleCwgZW5kSW5kZXgsIG1heFdpZHRoLCBpY29uTWFwcGluZywgdGFyZ2V0KSB7XG4gIGxldCByb3dTdGFydENoYXJJbmRleCA9IHN0YXJ0SW5kZXg7XG4gIGxldCByb3dPZmZzZXRMZWZ0ID0gMDtcblxuICBmb3IgKGxldCBpID0gc3RhcnRJbmRleDsgaSA8IGVuZEluZGV4OyBpKyspIHtcbiAgICBjb25zdCB0ZXh0V2lkdGggPSBnZXRUZXh0V2lkdGgodGV4dCwgaSwgaSArIDEsIGljb25NYXBwaW5nKTtcblxuICAgIGlmIChyb3dPZmZzZXRMZWZ0ICsgdGV4dFdpZHRoID4gbWF4V2lkdGgpIHtcbiAgICAgIGlmIChyb3dTdGFydENoYXJJbmRleCA8IGkpIHtcbiAgICAgICAgdGFyZ2V0LnB1c2goaSk7XG4gICAgICB9XG5cbiAgICAgIHJvd1N0YXJ0Q2hhckluZGV4ID0gaTtcbiAgICAgIHJvd09mZnNldExlZnQgPSAwO1xuICAgIH1cblxuICAgIHJvd09mZnNldExlZnQgKz0gdGV4dFdpZHRoO1xuICB9XG5cbiAgcmV0dXJuIHJvd09mZnNldExlZnQ7XG59XG5cbmZ1bmN0aW9uIGJyZWFrV29yZCh0ZXh0LCBzdGFydEluZGV4LCBlbmRJbmRleCwgbWF4V2lkdGgsIGljb25NYXBwaW5nLCB0YXJnZXQpIHtcbiAgbGV0IHJvd1N0YXJ0Q2hhckluZGV4ID0gc3RhcnRJbmRleDtcbiAgbGV0IGdyb3VwU3RhcnRDaGFySW5kZXggPSBzdGFydEluZGV4O1xuICBsZXQgZ3JvdXBFbmRDaGFySW5kZXggPSBzdGFydEluZGV4O1xuICBsZXQgcm93T2Zmc2V0TGVmdCA9IDA7XG5cbiAgZm9yIChsZXQgaSA9IHN0YXJ0SW5kZXg7IGkgPCBlbmRJbmRleDsgaSsrKSB7XG4gICAgaWYgKHRleHRbaV0gPT09ICcgJykge1xuICAgICAgZ3JvdXBFbmRDaGFySW5kZXggPSBpICsgMTtcbiAgICB9IGVsc2UgaWYgKHRleHRbaSArIDFdID09PSAnICcgfHwgaSArIDEgPT09IGVuZEluZGV4KSB7XG4gICAgICBncm91cEVuZENoYXJJbmRleCA9IGkgKyAxO1xuICAgIH1cblxuICAgIGlmIChncm91cEVuZENoYXJJbmRleCA+IGdyb3VwU3RhcnRDaGFySW5kZXgpIHtcbiAgICAgIGxldCBncm91cFdpZHRoID0gZ2V0VGV4dFdpZHRoKHRleHQsIGdyb3VwU3RhcnRDaGFySW5kZXgsIGdyb3VwRW5kQ2hhckluZGV4LCBpY29uTWFwcGluZyk7XG5cbiAgICAgIGlmIChyb3dPZmZzZXRMZWZ0ICsgZ3JvdXBXaWR0aCA+IG1heFdpZHRoKSB7XG4gICAgICAgIGlmIChyb3dTdGFydENoYXJJbmRleCA8IGdyb3VwU3RhcnRDaGFySW5kZXgpIHtcbiAgICAgICAgICB0YXJnZXQucHVzaChncm91cFN0YXJ0Q2hhckluZGV4KTtcbiAgICAgICAgICByb3dTdGFydENoYXJJbmRleCA9IGdyb3VwU3RhcnRDaGFySW5kZXg7XG4gICAgICAgICAgcm93T2Zmc2V0TGVmdCA9IDA7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZ3JvdXBXaWR0aCA+IG1heFdpZHRoKSB7XG4gICAgICAgICAgZ3JvdXBXaWR0aCA9IGJyZWFrQWxsKHRleHQsIGdyb3VwU3RhcnRDaGFySW5kZXgsIGdyb3VwRW5kQ2hhckluZGV4LCBtYXhXaWR0aCwgaWNvbk1hcHBpbmcsIHRhcmdldCk7XG4gICAgICAgICAgcm93U3RhcnRDaGFySW5kZXggPSB0YXJnZXRbdGFyZ2V0Lmxlbmd0aCAtIDFdO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGdyb3VwU3RhcnRDaGFySW5kZXggPSBncm91cEVuZENoYXJJbmRleDtcbiAgICAgIHJvd09mZnNldExlZnQgKz0gZ3JvdXBXaWR0aDtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gcm93T2Zmc2V0TGVmdDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGF1dG9XcmFwcGluZyh0ZXh0LCB3b3JkQnJlYWssIG1heFdpZHRoLCBpY29uTWFwcGluZywgc3RhcnRJbmRleCA9IDAsIGVuZEluZGV4KSB7XG4gIGlmIChlbmRJbmRleCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgZW5kSW5kZXggPSB0ZXh0Lmxlbmd0aDtcbiAgfVxuXG4gIGNvbnN0IHJlc3VsdCA9IFtdO1xuXG4gIGlmICh3b3JkQnJlYWsgPT09ICdicmVhay1hbGwnKSB7XG4gICAgYnJlYWtBbGwodGV4dCwgc3RhcnRJbmRleCwgZW5kSW5kZXgsIG1heFdpZHRoLCBpY29uTWFwcGluZywgcmVzdWx0KTtcbiAgfSBlbHNlIHtcbiAgICBicmVha1dvcmQodGV4dCwgc3RhcnRJbmRleCwgZW5kSW5kZXgsIG1heFdpZHRoLCBpY29uTWFwcGluZywgcmVzdWx0KTtcbiAgfVxuXG4gIHJldHVybiByZXN1bHQ7XG59XG5cbmZ1bmN0aW9uIHRyYW5zZm9ybVJvdyhsaW5lLCBzdGFydEluZGV4LCBlbmRJbmRleCwgaWNvbk1hcHBpbmcsIGxlZnRPZmZzZXRzLCByb3dTaXplKSB7XG4gIGxldCB4ID0gMDtcbiAgbGV0IHJvd0hlaWdodCA9IDA7XG5cbiAgZm9yIChsZXQgaSA9IHN0YXJ0SW5kZXg7IGkgPCBlbmRJbmRleDsgaSsrKSB7XG4gICAgY29uc3QgY2hhcmFjdGVyID0gbGluZVtpXTtcbiAgICBjb25zdCBmcmFtZSA9IGljb25NYXBwaW5nW2NoYXJhY3Rlcl07XG5cbiAgICBpZiAoZnJhbWUpIHtcbiAgICAgIGlmICghcm93SGVpZ2h0KSB7XG4gICAgICAgIHJvd0hlaWdodCA9IGZyYW1lLmxheW91dEhlaWdodDtcbiAgICAgIH1cblxuICAgICAgbGVmdE9mZnNldHNbaV0gPSB4ICsgZnJhbWUubGF5b3V0V2lkdGggLyAyO1xuICAgICAgeCArPSBmcmFtZS5sYXlvdXRXaWR0aDtcbiAgICB9IGVsc2Uge1xuICAgICAgbG9nLndhcm4oXCJNaXNzaW5nIGNoYXJhY3RlcjogXCIuY29uY2F0KGNoYXJhY3RlciwgXCIgKFwiKS5jb25jYXQoY2hhcmFjdGVyLmNvZGVQb2ludEF0KDApLCBcIilcIikpKCk7XG4gICAgICBsZWZ0T2Zmc2V0c1tpXSA9IHg7XG4gICAgICB4ICs9IE1JU1NJTkdfQ0hBUl9XSURUSDtcbiAgICB9XG4gIH1cblxuICByb3dTaXplWzBdID0geDtcbiAgcm93U2l6ZVsxXSA9IHJvd0hlaWdodDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHRyYW5zZm9ybVBhcmFncmFwaChwYXJhZ3JhcGgsIGxpbmVIZWlnaHQsIHdvcmRCcmVhaywgbWF4V2lkdGgsIGljb25NYXBwaW5nKSB7XG4gIGNvbnN0IGNoYXJhY3RlcnMgPSBBcnJheS5mcm9tKHBhcmFncmFwaCk7XG4gIGNvbnN0IG51bUNoYXJhY3RlcnMgPSBjaGFyYWN0ZXJzLmxlbmd0aDtcbiAgY29uc3QgeCA9IG5ldyBBcnJheShudW1DaGFyYWN0ZXJzKTtcbiAgY29uc3QgeSA9IG5ldyBBcnJheShudW1DaGFyYWN0ZXJzKTtcbiAgY29uc3Qgcm93V2lkdGggPSBuZXcgQXJyYXkobnVtQ2hhcmFjdGVycyk7XG4gIGNvbnN0IGF1dG9XcmFwcGluZ0VuYWJsZWQgPSAod29yZEJyZWFrID09PSAnYnJlYWstd29yZCcgfHwgd29yZEJyZWFrID09PSAnYnJlYWstYWxsJykgJiYgaXNGaW5pdGUobWF4V2lkdGgpICYmIG1heFdpZHRoID4gMDtcbiAgY29uc3Qgc2l6ZSA9IFswLCAwXTtcbiAgY29uc3Qgcm93U2l6ZSA9IFswLCAwXTtcbiAgbGV0IHJvd09mZnNldFRvcCA9IDA7XG4gIGxldCBsaW5lU3RhcnRJbmRleCA9IDA7XG4gIGxldCBsaW5lRW5kSW5kZXggPSAwO1xuXG4gIGZvciAobGV0IGkgPSAwOyBpIDw9IG51bUNoYXJhY3RlcnM7IGkrKykge1xuICAgIGNvbnN0IGNoYXIgPSBjaGFyYWN0ZXJzW2ldO1xuXG4gICAgaWYgKGNoYXIgPT09ICdcXG4nIHx8IGkgPT09IG51bUNoYXJhY3RlcnMpIHtcbiAgICAgIGxpbmVFbmRJbmRleCA9IGk7XG4gICAgfVxuXG4gICAgaWYgKGxpbmVFbmRJbmRleCA+IGxpbmVTdGFydEluZGV4KSB7XG4gICAgICBjb25zdCByb3dzID0gYXV0b1dyYXBwaW5nRW5hYmxlZCA/IGF1dG9XcmFwcGluZyhjaGFyYWN0ZXJzLCB3b3JkQnJlYWssIG1heFdpZHRoLCBpY29uTWFwcGluZywgbGluZVN0YXJ0SW5kZXgsIGxpbmVFbmRJbmRleCkgOiBTSU5HTEVfTElORTtcblxuICAgICAgZm9yIChsZXQgcm93SW5kZXggPSAwOyByb3dJbmRleCA8PSByb3dzLmxlbmd0aDsgcm93SW5kZXgrKykge1xuICAgICAgICBjb25zdCByb3dTdGFydCA9IHJvd0luZGV4ID09PSAwID8gbGluZVN0YXJ0SW5kZXggOiByb3dzW3Jvd0luZGV4IC0gMV07XG4gICAgICAgIGNvbnN0IHJvd0VuZCA9IHJvd0luZGV4IDwgcm93cy5sZW5ndGggPyByb3dzW3Jvd0luZGV4XSA6IGxpbmVFbmRJbmRleDtcbiAgICAgICAgdHJhbnNmb3JtUm93KGNoYXJhY3RlcnMsIHJvd1N0YXJ0LCByb3dFbmQsIGljb25NYXBwaW5nLCB4LCByb3dTaXplKTtcblxuICAgICAgICBmb3IgKGxldCBqID0gcm93U3RhcnQ7IGogPCByb3dFbmQ7IGorKykge1xuICAgICAgICAgIHZhciBfaWNvbk1hcHBpbmckY2hhcjtcblxuICAgICAgICAgIGNvbnN0IGNoYXIgPSBjaGFyYWN0ZXJzW2pdO1xuICAgICAgICAgIGNvbnN0IGxheW91dE9mZnNldFkgPSAoKF9pY29uTWFwcGluZyRjaGFyID0gaWNvbk1hcHBpbmdbY2hhcl0pID09PSBudWxsIHx8IF9pY29uTWFwcGluZyRjaGFyID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfaWNvbk1hcHBpbmckY2hhci5sYXlvdXRPZmZzZXRZKSB8fCAwO1xuICAgICAgICAgIHlbal0gPSByb3dPZmZzZXRUb3AgKyByb3dTaXplWzFdIC8gMiArIGxheW91dE9mZnNldFk7XG4gICAgICAgICAgcm93V2lkdGhbal0gPSByb3dTaXplWzBdO1xuICAgICAgICB9XG5cbiAgICAgICAgcm93T2Zmc2V0VG9wID0gcm93T2Zmc2V0VG9wICsgcm93U2l6ZVsxXSAqIGxpbmVIZWlnaHQ7XG4gICAgICAgIHNpemVbMF0gPSBNYXRoLm1heChzaXplWzBdLCByb3dTaXplWzBdKTtcbiAgICAgIH1cblxuICAgICAgbGluZVN0YXJ0SW5kZXggPSBsaW5lRW5kSW5kZXg7XG4gICAgfVxuXG4gICAgaWYgKGNoYXIgPT09ICdcXG4nKSB7XG4gICAgICB4W2xpbmVTdGFydEluZGV4XSA9IDA7XG4gICAgICB5W2xpbmVTdGFydEluZGV4XSA9IDA7XG4gICAgICByb3dXaWR0aFtsaW5lU3RhcnRJbmRleF0gPSAwO1xuICAgICAgbGluZVN0YXJ0SW5kZXgrKztcbiAgICB9XG4gIH1cblxuICBzaXplWzFdID0gcm93T2Zmc2V0VG9wO1xuICByZXR1cm4ge1xuICAgIHgsXG4gICAgeSxcbiAgICByb3dXaWR0aCxcbiAgICBzaXplXG4gIH07XG59XG5leHBvcnQgZnVuY3Rpb24gZ2V0VGV4dEZyb21CdWZmZXIoe1xuICB2YWx1ZSxcbiAgbGVuZ3RoLFxuICBzdHJpZGUsXG4gIG9mZnNldCxcbiAgc3RhcnRJbmRpY2VzLFxuICBjaGFyYWN0ZXJTZXRcbn0pIHtcbiAgY29uc3QgYnl0ZXNQZXJFbGVtZW50ID0gdmFsdWUuQllURVNfUEVSX0VMRU1FTlQ7XG4gIGNvbnN0IGVsZW1lbnRTdHJpZGUgPSBzdHJpZGUgPyBzdHJpZGUgLyBieXRlc1BlckVsZW1lbnQgOiAxO1xuICBjb25zdCBlbGVtZW50T2Zmc2V0ID0gb2Zmc2V0ID8gb2Zmc2V0IC8gYnl0ZXNQZXJFbGVtZW50IDogMDtcbiAgY29uc3QgY2hhcmFjdGVyQ291bnQgPSBzdGFydEluZGljZXNbbGVuZ3RoXSB8fCBNYXRoLmNlaWwoKHZhbHVlLmxlbmd0aCAtIGVsZW1lbnRPZmZzZXQpIC8gZWxlbWVudFN0cmlkZSk7XG4gIGNvbnN0IGF1dG9DaGFyYWN0ZXJTZXQgPSBjaGFyYWN0ZXJTZXQgJiYgbmV3IFNldCgpO1xuICBjb25zdCB0ZXh0cyA9IG5ldyBBcnJheShsZW5ndGgpO1xuICBsZXQgY29kZXMgPSB2YWx1ZTtcblxuICBpZiAoZWxlbWVudFN0cmlkZSA+IDEgfHwgZWxlbWVudE9mZnNldCA+IDApIHtcbiAgICBjb25zdCBBcnJheVR5cGUgPSB2YWx1ZS5jb25zdHJ1Y3RvcjtcbiAgICBjb2RlcyA9IG5ldyBBcnJheVR5cGUoY2hhcmFjdGVyQ291bnQpO1xuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjaGFyYWN0ZXJDb3VudDsgaSsrKSB7XG4gICAgICBjb2Rlc1tpXSA9IHZhbHVlW2kgKiBlbGVtZW50U3RyaWRlICsgZWxlbWVudE9mZnNldF07XG4gICAgfVxuICB9XG5cbiAgZm9yIChsZXQgaW5kZXggPSAwOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKykge1xuICAgIGNvbnN0IHN0YXJ0SW5kZXggPSBzdGFydEluZGljZXNbaW5kZXhdO1xuICAgIGNvbnN0IGVuZEluZGV4ID0gc3RhcnRJbmRpY2VzW2luZGV4ICsgMV0gfHwgY2hhcmFjdGVyQ291bnQ7XG4gICAgY29uc3QgY29kZXNBdEluZGV4ID0gY29kZXMuc3ViYXJyYXkoc3RhcnRJbmRleCwgZW5kSW5kZXgpO1xuICAgIHRleHRzW2luZGV4XSA9IFN0cmluZy5mcm9tQ29kZVBvaW50LmFwcGx5KG51bGwsIGNvZGVzQXRJbmRleCk7XG5cbiAgICBpZiAoYXV0b0NoYXJhY3RlclNldCkge1xuICAgICAgY29kZXNBdEluZGV4LmZvckVhY2goYXV0b0NoYXJhY3RlclNldC5hZGQsIGF1dG9DaGFyYWN0ZXJTZXQpO1xuICAgIH1cbiAgfVxuXG4gIGlmIChhdXRvQ2hhcmFjdGVyU2V0KSB7XG4gICAgZm9yIChjb25zdCBjaGFyQ29kZSBvZiBhdXRvQ2hhcmFjdGVyU2V0KSB7XG4gICAgICBjaGFyYWN0ZXJTZXQuYWRkKFN0cmluZy5mcm9tQ29kZVBvaW50KGNoYXJDb2RlKSk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHtcbiAgICB0ZXh0cyxcbiAgICBjaGFyYWN0ZXJDb3VudFxuICB9O1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dXRpbHMuanMubWFwIiwiaW1wb3J0IF9kZWZpbmVQcm9wZXJ0eSBmcm9tIFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vZGVmaW5lUHJvcGVydHlcIjtcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIExSVUNhY2hlIHtcbiAgY29uc3RydWN0b3IobGltaXQgPSA1KSB7XG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwibGltaXRcIiwgdm9pZCAwKTtcblxuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIl9jYWNoZVwiLCB7fSk7XG5cbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJfb3JkZXJcIiwgW10pO1xuXG4gICAgdGhpcy5saW1pdCA9IGxpbWl0O1xuICB9XG5cbiAgZ2V0KGtleSkge1xuICAgIGNvbnN0IHZhbHVlID0gdGhpcy5fY2FjaGVba2V5XTtcblxuICAgIGlmICh2YWx1ZSkge1xuICAgICAgdGhpcy5fZGVsZXRlT3JkZXIoa2V5KTtcblxuICAgICAgdGhpcy5fYXBwZW5kT3JkZXIoa2V5KTtcbiAgICB9XG5cbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cblxuICBzZXQoa2V5LCB2YWx1ZSkge1xuICAgIGlmICghdGhpcy5fY2FjaGVba2V5XSkge1xuICAgICAgaWYgKE9iamVjdC5rZXlzKHRoaXMuX2NhY2hlKS5sZW5ndGggPT09IHRoaXMubGltaXQpIHtcbiAgICAgICAgdGhpcy5kZWxldGUodGhpcy5fb3JkZXJbMF0pO1xuICAgICAgfVxuXG4gICAgICB0aGlzLl9jYWNoZVtrZXldID0gdmFsdWU7XG5cbiAgICAgIHRoaXMuX2FwcGVuZE9yZGVyKGtleSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuZGVsZXRlKGtleSk7XG4gICAgICB0aGlzLl9jYWNoZVtrZXldID0gdmFsdWU7XG5cbiAgICAgIHRoaXMuX2FwcGVuZE9yZGVyKGtleSk7XG4gICAgfVxuICB9XG5cbiAgZGVsZXRlKGtleSkge1xuICAgIGNvbnN0IHZhbHVlID0gdGhpcy5fY2FjaGVba2V5XTtcblxuICAgIGlmICh2YWx1ZSkge1xuICAgICAgZGVsZXRlIHRoaXMuX2NhY2hlW2tleV07XG5cbiAgICAgIHRoaXMuX2RlbGV0ZU9yZGVyKGtleSk7XG4gICAgfVxuICB9XG5cbiAgX2RlbGV0ZU9yZGVyKGtleSkge1xuICAgIGNvbnN0IGluZGV4ID0gdGhpcy5fb3JkZXIuaW5kZXhPZihrZXkpO1xuXG4gICAgaWYgKGluZGV4ID49IDApIHtcbiAgICAgIHRoaXMuX29yZGVyLnNwbGljZShpbmRleCwgMSk7XG4gICAgfVxuICB9XG5cbiAgX2FwcGVuZE9yZGVyKGtleSkge1xuICAgIHRoaXMuX29yZGVyLnB1c2goa2V5KTtcbiAgfVxuXG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1scnUtY2FjaGUuanMubWFwIiwiaW1wb3J0IF9kZWZpbmVQcm9wZXJ0eSBmcm9tIFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vZGVmaW5lUHJvcGVydHlcIjtcbmltcG9ydCBUaW55U0RGIGZyb20gJ0BtYXBib3gvdGlueS1zZGYnO1xuaW1wb3J0IHsgbG9nIH0gZnJvbSAnQGRlY2suZ2wvY29yZSc7XG5pbXBvcnQgeyBidWlsZE1hcHBpbmcgfSBmcm9tICcuL3V0aWxzJztcbmltcG9ydCBMUlVDYWNoZSBmcm9tICcuL2xydS1jYWNoZSc7XG5cbmZ1bmN0aW9uIGdldERlZmF1bHRDaGFyYWN0ZXJTZXQoKSB7XG4gIGNvbnN0IGNoYXJTZXQgPSBbXTtcblxuICBmb3IgKGxldCBpID0gMzI7IGkgPCAxMjg7IGkrKykge1xuICAgIGNoYXJTZXQucHVzaChTdHJpbmcuZnJvbUNoYXJDb2RlKGkpKTtcbiAgfVxuXG4gIHJldHVybiBjaGFyU2V0O1xufVxuXG5leHBvcnQgY29uc3QgREVGQVVMVF9GT05UX1NFVFRJTkdTID0ge1xuICBmb250RmFtaWx5OiAnTW9uYWNvLCBtb25vc3BhY2UnLFxuICBmb250V2VpZ2h0OiAnbm9ybWFsJyxcbiAgY2hhcmFjdGVyU2V0OiBnZXREZWZhdWx0Q2hhcmFjdGVyU2V0KCksXG4gIGZvbnRTaXplOiA2NCxcbiAgYnVmZmVyOiA0LFxuICBzZGY6IGZhbHNlLFxuICBjdXRvZmY6IDAuMjUsXG4gIHJhZGl1czogMTIsXG4gIHNtb290aGluZzogMC4xXG59O1xuY29uc3QgTUFYX0NBTlZBU19XSURUSCA9IDEwMjQ7XG5jb25zdCBCQVNFTElORV9TQ0FMRSA9IDAuOTtcbmNvbnN0IEhFSUdIVF9TQ0FMRSA9IDEuMjtcbmNvbnN0IENBQ0hFX0xJTUlUID0gMztcbmxldCBjYWNoZSA9IG5ldyBMUlVDYWNoZShDQUNIRV9MSU1JVCk7XG5cbmZ1bmN0aW9uIGdldE5ld0NoYXJzKGNhY2hlS2V5LCBjaGFyYWN0ZXJTZXQpIHtcbiAgbGV0IG5ld0NoYXJTZXQ7XG5cbiAgaWYgKHR5cGVvZiBjaGFyYWN0ZXJTZXQgPT09ICdzdHJpbmcnKSB7XG4gICAgbmV3Q2hhclNldCA9IG5ldyBTZXQoQXJyYXkuZnJvbShjaGFyYWN0ZXJTZXQpKTtcbiAgfSBlbHNlIHtcbiAgICBuZXdDaGFyU2V0ID0gbmV3IFNldChjaGFyYWN0ZXJTZXQpO1xuICB9XG5cbiAgY29uc3QgY2FjaGVkRm9udEF0bGFzID0gY2FjaGUuZ2V0KGNhY2hlS2V5KTtcblxuICBpZiAoIWNhY2hlZEZvbnRBdGxhcykge1xuICAgIHJldHVybiBuZXdDaGFyU2V0O1xuICB9XG5cbiAgZm9yIChjb25zdCBjaGFyIGluIGNhY2hlZEZvbnRBdGxhcy5tYXBwaW5nKSB7XG4gICAgaWYgKG5ld0NoYXJTZXQuaGFzKGNoYXIpKSB7XG4gICAgICBuZXdDaGFyU2V0LmRlbGV0ZShjaGFyKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gbmV3Q2hhclNldDtcbn1cblxuZnVuY3Rpb24gcG9wdWxhdGVBbHBoYUNoYW5uZWwoYWxwaGFDaGFubmVsLCBpbWFnZURhdGEpIHtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBhbHBoYUNoYW5uZWwubGVuZ3RoOyBpKyspIHtcbiAgICBpbWFnZURhdGEuZGF0YVs0ICogaSArIDNdID0gYWxwaGFDaGFubmVsW2ldO1xuICB9XG59XG5cbmZ1bmN0aW9uIHNldFRleHRTdHlsZShjdHgsIGZvbnRGYW1pbHksIGZvbnRTaXplLCBmb250V2VpZ2h0KSB7XG4gIGN0eC5mb250ID0gXCJcIi5jb25jYXQoZm9udFdlaWdodCwgXCIgXCIpLmNvbmNhdChmb250U2l6ZSwgXCJweCBcIikuY29uY2F0KGZvbnRGYW1pbHkpO1xuICBjdHguZmlsbFN0eWxlID0gJyMwMDAnO1xuICBjdHgudGV4dEJhc2VsaW5lID0gJ2FscGhhYmV0aWMnO1xuICBjdHgudGV4dEFsaWduID0gJ2xlZnQnO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gc2V0Rm9udEF0bGFzQ2FjaGVMaW1pdChsaW1pdCkge1xuICBsb2cuYXNzZXJ0KE51bWJlci5pc0Zpbml0ZShsaW1pdCkgJiYgbGltaXQgPj0gQ0FDSEVfTElNSVQsICdJbnZhbGlkIGNhY2hlIGxpbWl0Jyk7XG4gIGNhY2hlID0gbmV3IExSVUNhY2hlKGxpbWl0KTtcbn1cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEZvbnRBdGxhc01hbmFnZXIge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJwcm9wc1wiLCB7IC4uLkRFRkFVTFRfRk9OVF9TRVRUSU5HU1xuICAgIH0pO1xuXG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwiX2tleVwiLCB2b2lkIDApO1xuXG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwiX2F0bGFzXCIsIHZvaWQgMCk7XG4gIH1cblxuICBnZXQgdGV4dHVyZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fYXRsYXM7XG4gIH1cblxuICBnZXQgbWFwcGluZygpIHtcbiAgICByZXR1cm4gdGhpcy5fYXRsYXMgJiYgdGhpcy5fYXRsYXMubWFwcGluZztcbiAgfVxuXG4gIGdldCBzY2FsZSgpIHtcbiAgICBjb25zdCB7XG4gICAgICBmb250U2l6ZSxcbiAgICAgIGJ1ZmZlclxuICAgIH0gPSB0aGlzLnByb3BzO1xuICAgIHJldHVybiAoZm9udFNpemUgKiBIRUlHSFRfU0NBTEUgKyBidWZmZXIgKiAyKSAvIGZvbnRTaXplO1xuICB9XG5cbiAgc2V0UHJvcHMocHJvcHMgPSB7fSkge1xuICAgIE9iamVjdC5hc3NpZ24odGhpcy5wcm9wcywgcHJvcHMpO1xuICAgIHRoaXMuX2tleSA9IHRoaXMuX2dldEtleSgpO1xuICAgIGNvbnN0IGNoYXJTZXQgPSBnZXROZXdDaGFycyh0aGlzLl9rZXksIHRoaXMucHJvcHMuY2hhcmFjdGVyU2V0KTtcbiAgICBjb25zdCBjYWNoZWRGb250QXRsYXMgPSBjYWNoZS5nZXQodGhpcy5fa2V5KTtcblxuICAgIGlmIChjYWNoZWRGb250QXRsYXMgJiYgY2hhclNldC5zaXplID09PSAwKSB7XG4gICAgICBpZiAodGhpcy5fYXRsYXMgIT09IGNhY2hlZEZvbnRBdGxhcykge1xuICAgICAgICB0aGlzLl9hdGxhcyA9IGNhY2hlZEZvbnRBdGxhcztcbiAgICAgIH1cblxuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IGZvbnRBdGxhcyA9IHRoaXMuX2dlbmVyYXRlRm9udEF0bGFzKGNoYXJTZXQsIGNhY2hlZEZvbnRBdGxhcyk7XG5cbiAgICB0aGlzLl9hdGxhcyA9IGZvbnRBdGxhcztcbiAgICBjYWNoZS5zZXQodGhpcy5fa2V5LCBmb250QXRsYXMpO1xuICB9XG5cbiAgX2dlbmVyYXRlRm9udEF0bGFzKGNoYXJhY3RlclNldCwgY2FjaGVkRm9udEF0bGFzKSB7XG4gICAgY29uc3Qge1xuICAgICAgZm9udEZhbWlseSxcbiAgICAgIGZvbnRXZWlnaHQsXG4gICAgICBmb250U2l6ZSxcbiAgICAgIGJ1ZmZlcixcbiAgICAgIHNkZixcbiAgICAgIHJhZGl1cyxcbiAgICAgIGN1dG9mZlxuICAgIH0gPSB0aGlzLnByb3BzO1xuICAgIGxldCBjYW52YXMgPSBjYWNoZWRGb250QXRsYXMgJiYgY2FjaGVkRm9udEF0bGFzLmRhdGE7XG5cbiAgICBpZiAoIWNhbnZhcykge1xuICAgICAgY2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyk7XG4gICAgICBjYW52YXMud2lkdGggPSBNQVhfQ0FOVkFTX1dJRFRIO1xuICAgIH1cblxuICAgIGNvbnN0IGN0eCA9IGNhbnZhcy5nZXRDb250ZXh0KCcyZCcsIHtcbiAgICAgIHdpbGxSZWFkRnJlcXVlbnRseTogdHJ1ZVxuICAgIH0pO1xuICAgIHNldFRleHRTdHlsZShjdHgsIGZvbnRGYW1pbHksIGZvbnRTaXplLCBmb250V2VpZ2h0KTtcbiAgICBjb25zdCB7XG4gICAgICBtYXBwaW5nLFxuICAgICAgY2FudmFzSGVpZ2h0LFxuICAgICAgeE9mZnNldCxcbiAgICAgIHlPZmZzZXRcbiAgICB9ID0gYnVpbGRNYXBwaW5nKHtcbiAgICAgIGdldEZvbnRXaWR0aDogY2hhciA9PiBjdHgubWVhc3VyZVRleHQoY2hhcikud2lkdGgsXG4gICAgICBmb250SGVpZ2h0OiBmb250U2l6ZSAqIEhFSUdIVF9TQ0FMRSxcbiAgICAgIGJ1ZmZlcixcbiAgICAgIGNoYXJhY3RlclNldCxcbiAgICAgIG1heENhbnZhc1dpZHRoOiBNQVhfQ0FOVkFTX1dJRFRILFxuICAgICAgLi4uKGNhY2hlZEZvbnRBdGxhcyAmJiB7XG4gICAgICAgIG1hcHBpbmc6IGNhY2hlZEZvbnRBdGxhcy5tYXBwaW5nLFxuICAgICAgICB4T2Zmc2V0OiBjYWNoZWRGb250QXRsYXMueE9mZnNldCxcbiAgICAgICAgeU9mZnNldDogY2FjaGVkRm9udEF0bGFzLnlPZmZzZXRcbiAgICAgIH0pXG4gICAgfSk7XG5cbiAgICBpZiAoY2FudmFzLmhlaWdodCAhPT0gY2FudmFzSGVpZ2h0KSB7XG4gICAgICBjb25zdCBpbWFnZURhdGEgPSBjdHguZ2V0SW1hZ2VEYXRhKDAsIDAsIGNhbnZhcy53aWR0aCwgY2FudmFzLmhlaWdodCk7XG4gICAgICBjYW52YXMuaGVpZ2h0ID0gY2FudmFzSGVpZ2h0O1xuICAgICAgY3R4LnB1dEltYWdlRGF0YShpbWFnZURhdGEsIDAsIDApO1xuICAgIH1cblxuICAgIHNldFRleHRTdHlsZShjdHgsIGZvbnRGYW1pbHksIGZvbnRTaXplLCBmb250V2VpZ2h0KTtcblxuICAgIGlmIChzZGYpIHtcbiAgICAgIGNvbnN0IHRpbnlTREYgPSBuZXcgVGlueVNERih7XG4gICAgICAgIGZvbnRTaXplLFxuICAgICAgICBidWZmZXIsXG4gICAgICAgIHJhZGl1cyxcbiAgICAgICAgY3V0b2ZmLFxuICAgICAgICBmb250RmFtaWx5LFxuICAgICAgICBmb250V2VpZ2h0OiBcIlwiLmNvbmNhdChmb250V2VpZ2h0KVxuICAgICAgfSk7XG5cbiAgICAgIGZvciAoY29uc3QgY2hhciBvZiBjaGFyYWN0ZXJTZXQpIHtcbiAgICAgICAgY29uc3Qge1xuICAgICAgICAgIGRhdGEsXG4gICAgICAgICAgd2lkdGgsXG4gICAgICAgICAgaGVpZ2h0LFxuICAgICAgICAgIGdseXBoVG9wXG4gICAgICAgIH0gPSB0aW55U0RGLmRyYXcoY2hhcik7XG4gICAgICAgIG1hcHBpbmdbY2hhcl0ud2lkdGggPSB3aWR0aDtcbiAgICAgICAgbWFwcGluZ1tjaGFyXS5sYXlvdXRPZmZzZXRZID0gZm9udFNpemUgKiBCQVNFTElORV9TQ0FMRSAtIGdseXBoVG9wO1xuICAgICAgICBjb25zdCBpbWFnZURhdGEgPSBjdHguY3JlYXRlSW1hZ2VEYXRhKHdpZHRoLCBoZWlnaHQpO1xuICAgICAgICBwb3B1bGF0ZUFscGhhQ2hhbm5lbChkYXRhLCBpbWFnZURhdGEpO1xuICAgICAgICBjdHgucHV0SW1hZ2VEYXRhKGltYWdlRGF0YSwgbWFwcGluZ1tjaGFyXS54LCBtYXBwaW5nW2NoYXJdLnkpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBmb3IgKGNvbnN0IGNoYXIgb2YgY2hhcmFjdGVyU2V0KSB7XG4gICAgICAgIGN0eC5maWxsVGV4dChjaGFyLCBtYXBwaW5nW2NoYXJdLngsIG1hcHBpbmdbY2hhcl0ueSArIGJ1ZmZlciArIGZvbnRTaXplICogQkFTRUxJTkVfU0NBTEUpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICB4T2Zmc2V0LFxuICAgICAgeU9mZnNldCxcbiAgICAgIG1hcHBpbmcsXG4gICAgICBkYXRhOiBjYW52YXMsXG4gICAgICB3aWR0aDogY2FudmFzLndpZHRoLFxuICAgICAgaGVpZ2h0OiBjYW52YXMuaGVpZ2h0XG4gICAgfTtcbiAgfVxuXG4gIF9nZXRLZXkoKSB7XG4gICAgY29uc3Qge1xuICAgICAgZm9udEZhbWlseSxcbiAgICAgIGZvbnRXZWlnaHQsXG4gICAgICBmb250U2l6ZSxcbiAgICAgIGJ1ZmZlcixcbiAgICAgIHNkZixcbiAgICAgIHJhZGl1cyxcbiAgICAgIGN1dG9mZlxuICAgIH0gPSB0aGlzLnByb3BzO1xuXG4gICAgaWYgKHNkZikge1xuICAgICAgcmV0dXJuIFwiXCIuY29uY2F0KGZvbnRGYW1pbHksIFwiIFwiKS5jb25jYXQoZm9udFdlaWdodCwgXCIgXCIpLmNvbmNhdChmb250U2l6ZSwgXCIgXCIpLmNvbmNhdChidWZmZXIsIFwiIFwiKS5jb25jYXQocmFkaXVzLCBcIiBcIikuY29uY2F0KGN1dG9mZik7XG4gICAgfVxuXG4gICAgcmV0dXJuIFwiXCIuY29uY2F0KGZvbnRGYW1pbHksIFwiIFwiKS5jb25jYXQoZm9udFdlaWdodCwgXCIgXCIpLmNvbmNhdChmb250U2l6ZSwgXCIgXCIpLmNvbmNhdChidWZmZXIpO1xuICB9XG5cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWZvbnQtYXRsYXMtbWFuYWdlci5qcy5tYXAiLCJleHBvcnQgZGVmYXVsdCBcIiNkZWZpbmUgU0hBREVSX05BTUUgdGV4dC1iYWNrZ3JvdW5kLWxheWVyLXZlcnRleC1zaGFkZXJcXG5cXG5hdHRyaWJ1dGUgdmVjMiBwb3NpdGlvbnM7XFxuXFxuYXR0cmlidXRlIHZlYzMgaW5zdGFuY2VQb3NpdGlvbnM7XFxuYXR0cmlidXRlIHZlYzMgaW5zdGFuY2VQb3NpdGlvbnM2NExvdztcXG5hdHRyaWJ1dGUgdmVjNCBpbnN0YW5jZVJlY3RzO1xcbmF0dHJpYnV0ZSBmbG9hdCBpbnN0YW5jZVNpemVzO1xcbmF0dHJpYnV0ZSBmbG9hdCBpbnN0YW5jZUFuZ2xlcztcXG5hdHRyaWJ1dGUgdmVjMiBpbnN0YW5jZVBpeGVsT2Zmc2V0cztcXG5hdHRyaWJ1dGUgZmxvYXQgaW5zdGFuY2VMaW5lV2lkdGhzO1xcbmF0dHJpYnV0ZSB2ZWM0IGluc3RhbmNlRmlsbENvbG9ycztcXG5hdHRyaWJ1dGUgdmVjNCBpbnN0YW5jZUxpbmVDb2xvcnM7XFxuYXR0cmlidXRlIHZlYzMgaW5zdGFuY2VQaWNraW5nQ29sb3JzO1xcblxcbnVuaWZvcm0gYm9vbCBiaWxsYm9hcmQ7XFxudW5pZm9ybSBmbG9hdCBvcGFjaXR5O1xcbnVuaWZvcm0gZmxvYXQgc2l6ZVNjYWxlO1xcbnVuaWZvcm0gZmxvYXQgc2l6ZU1pblBpeGVscztcXG51bmlmb3JtIGZsb2F0IHNpemVNYXhQaXhlbHM7XFxudW5pZm9ybSB2ZWM0IHBhZGRpbmc7XFxudW5pZm9ybSBpbnQgc2l6ZVVuaXRzO1xcblxcbnZhcnlpbmcgdmVjNCB2RmlsbENvbG9yO1xcbnZhcnlpbmcgdmVjNCB2TGluZUNvbG9yO1xcbnZhcnlpbmcgZmxvYXQgdkxpbmVXaWR0aDtcXG52YXJ5aW5nIHZlYzIgdXY7XFxudmFyeWluZyB2ZWMyIGRpbWVuc2lvbnM7XFxuXFxudmVjMiByb3RhdGVfYnlfYW5nbGUodmVjMiB2ZXJ0ZXgsIGZsb2F0IGFuZ2xlKSB7XFxuICBmbG9hdCBhbmdsZV9yYWRpYW4gPSByYWRpYW5zKGFuZ2xlKTtcXG4gIGZsb2F0IGNvc19hbmdsZSA9IGNvcyhhbmdsZV9yYWRpYW4pO1xcbiAgZmxvYXQgc2luX2FuZ2xlID0gc2luKGFuZ2xlX3JhZGlhbik7XFxuICBtYXQyIHJvdGF0aW9uTWF0cml4ID0gbWF0Mihjb3NfYW5nbGUsIC1zaW5fYW5nbGUsIHNpbl9hbmdsZSwgY29zX2FuZ2xlKTtcXG4gIHJldHVybiByb3RhdGlvbk1hdHJpeCAqIHZlcnRleDtcXG59XFxuXFxudm9pZCBtYWluKHZvaWQpIHtcXG4gIGdlb21ldHJ5LndvcmxkUG9zaXRpb24gPSBpbnN0YW5jZVBvc2l0aW9ucztcXG4gIGdlb21ldHJ5LnV2ID0gcG9zaXRpb25zO1xcbiAgZ2VvbWV0cnkucGlja2luZ0NvbG9yID0gaW5zdGFuY2VQaWNraW5nQ29sb3JzO1xcbiAgdXYgPSBwb3NpdGlvbnM7XFxuICB2TGluZVdpZHRoID0gaW5zdGFuY2VMaW5lV2lkdGhzO1xcbiAgZmxvYXQgc2l6ZVBpeGVscyA9IGNsYW1wKFxcbiAgICBwcm9qZWN0X3NpemVfdG9fcGl4ZWwoaW5zdGFuY2VTaXplcyAqIHNpemVTY2FsZSwgc2l6ZVVuaXRzKSxcXG4gICAgc2l6ZU1pblBpeGVscywgc2l6ZU1heFBpeGVsc1xcbiAgKTtcXG5cXG4gIGRpbWVuc2lvbnMgPSBpbnN0YW5jZVJlY3RzLnp3ICogc2l6ZVBpeGVscyArIHBhZGRpbmcueHkgKyBwYWRkaW5nLnp3O1xcblxcbiAgdmVjMiBwaXhlbE9mZnNldCA9IChwb3NpdGlvbnMgKiBpbnN0YW5jZVJlY3RzLnp3ICsgaW5zdGFuY2VSZWN0cy54eSkgKiBzaXplUGl4ZWxzICsgbWl4KC1wYWRkaW5nLnh5LCBwYWRkaW5nLnp3LCBwb3NpdGlvbnMpO1xcbiAgcGl4ZWxPZmZzZXQgPSByb3RhdGVfYnlfYW5nbGUocGl4ZWxPZmZzZXQsIGluc3RhbmNlQW5nbGVzKTtcXG4gIHBpeGVsT2Zmc2V0ICs9IGluc3RhbmNlUGl4ZWxPZmZzZXRzO1xcbiAgcGl4ZWxPZmZzZXQueSAqPSAtMS4wO1xcblxcbiAgaWYgKGJpbGxib2FyZCkgIHtcXG4gICAgZ2xfUG9zaXRpb24gPSBwcm9qZWN0X3Bvc2l0aW9uX3RvX2NsaXBzcGFjZShpbnN0YW5jZVBvc2l0aW9ucywgaW5zdGFuY2VQb3NpdGlvbnM2NExvdywgdmVjMygwLjApLCBnZW9tZXRyeS5wb3NpdGlvbik7XFxuICAgIERFQ0tHTF9GSUxURVJfR0xfUE9TSVRJT04oZ2xfUG9zaXRpb24sIGdlb21ldHJ5KTtcXG4gICAgdmVjMyBvZmZzZXQgPSB2ZWMzKHBpeGVsT2Zmc2V0LCAwLjApO1xcbiAgICBERUNLR0xfRklMVEVSX1NJWkUob2Zmc2V0LCBnZW9tZXRyeSk7XFxuICAgIGdsX1Bvc2l0aW9uLnh5ICs9IHByb2plY3RfcGl4ZWxfc2l6ZV90b19jbGlwc3BhY2Uob2Zmc2V0Lnh5KTtcXG4gIH0gZWxzZSB7XFxuICAgIHZlYzMgb2Zmc2V0X2NvbW1vbiA9IHZlYzMocHJvamVjdF9waXhlbF9zaXplKHBpeGVsT2Zmc2V0KSwgMC4wKTtcXG4gICAgREVDS0dMX0ZJTFRFUl9TSVpFKG9mZnNldF9jb21tb24sIGdlb21ldHJ5KTtcXG4gICAgZ2xfUG9zaXRpb24gPSBwcm9qZWN0X3Bvc2l0aW9uX3RvX2NsaXBzcGFjZShpbnN0YW5jZVBvc2l0aW9ucywgaW5zdGFuY2VQb3NpdGlvbnM2NExvdywgb2Zmc2V0X2NvbW1vbiwgZ2VvbWV0cnkucG9zaXRpb24pO1xcbiAgICBERUNLR0xfRklMVEVSX0dMX1BPU0lUSU9OKGdsX1Bvc2l0aW9uLCBnZW9tZXRyeSk7XFxuICB9XFxuICB2RmlsbENvbG9yID0gdmVjNChpbnN0YW5jZUZpbGxDb2xvcnMucmdiLCBpbnN0YW5jZUZpbGxDb2xvcnMuYSAqIG9wYWNpdHkpO1xcbiAgREVDS0dMX0ZJTFRFUl9DT0xPUih2RmlsbENvbG9yLCBnZW9tZXRyeSk7XFxuICB2TGluZUNvbG9yID0gdmVjNChpbnN0YW5jZUxpbmVDb2xvcnMucmdiLCBpbnN0YW5jZUxpbmVDb2xvcnMuYSAqIG9wYWNpdHkpO1xcbiAgREVDS0dMX0ZJTFRFUl9DT0xPUih2TGluZUNvbG9yLCBnZW9tZXRyeSk7XFxufVxcblwiO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dGV4dC1iYWNrZ3JvdW5kLWxheWVyLXZlcnRleC5nbHNsLmpzLm1hcCIsImV4cG9ydCBkZWZhdWx0IFwiI2RlZmluZSBTSEFERVJfTkFNRSB0ZXh0LWJhY2tncm91bmQtbGF5ZXItZnJhZ21lbnQtc2hhZGVyXFxuXFxucHJlY2lzaW9uIGhpZ2hwIGZsb2F0O1xcblxcbnVuaWZvcm0gYm9vbCBzdHJva2VkO1xcblxcbnZhcnlpbmcgdmVjNCB2RmlsbENvbG9yO1xcbnZhcnlpbmcgdmVjNCB2TGluZUNvbG9yO1xcbnZhcnlpbmcgZmxvYXQgdkxpbmVXaWR0aDtcXG52YXJ5aW5nIHZlYzIgdXY7XFxudmFyeWluZyB2ZWMyIGRpbWVuc2lvbnM7XFxuXFxudm9pZCBtYWluKHZvaWQpIHtcXG4gIGdlb21ldHJ5LnV2ID0gdXY7XFxuXFxuICB2ZWMyIHBpeGVsUG9zaXRpb24gPSB1diAqIGRpbWVuc2lvbnM7XFxuICBpZiAoc3Ryb2tlZCkge1xcbiAgICBmbG9hdCBkaXN0VG9FZGdlID0gbWluKFxcbiAgICAgIG1pbihwaXhlbFBvc2l0aW9uLngsIGRpbWVuc2lvbnMueCAtIHBpeGVsUG9zaXRpb24ueCksXFxuICAgICAgbWluKHBpeGVsUG9zaXRpb24ueSwgZGltZW5zaW9ucy55IC0gcGl4ZWxQb3NpdGlvbi55KVxcbiAgICApO1xcbiAgICBmbG9hdCBpc0JvcmRlciA9IHNtb290aGVkZ2UoZGlzdFRvRWRnZSwgdkxpbmVXaWR0aCk7XFxuICAgIGdsX0ZyYWdDb2xvciA9IG1peCh2RmlsbENvbG9yLCB2TGluZUNvbG9yLCBpc0JvcmRlcik7XFxuICB9IGVsc2Uge1xcbiAgICBnbF9GcmFnQ29sb3IgPSB2RmlsbENvbG9yO1xcbiAgfVxcblxcbiAgREVDS0dMX0ZJTFRFUl9DT0xPUihnbF9GcmFnQ29sb3IsIGdlb21ldHJ5KTtcXG59XFxuXCI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD10ZXh0LWJhY2tncm91bmQtbGF5ZXItZnJhZ21lbnQuZ2xzbC5qcy5tYXAiLCJpbXBvcnQgX2RlZmluZVByb3BlcnR5IGZyb20gXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9kZWZpbmVQcm9wZXJ0eVwiO1xuaW1wb3J0IHsgTGF5ZXIsIHByb2plY3QzMiwgcGlja2luZywgVU5JVCB9IGZyb20gJ0BkZWNrLmdsL2NvcmUnO1xuaW1wb3J0IHsgTW9kZWwsIEdlb21ldHJ5IH0gZnJvbSAnQGx1bWEuZ2wvY29yZSc7XG5pbXBvcnQgdnMgZnJvbSAnLi90ZXh0LWJhY2tncm91bmQtbGF5ZXItdmVydGV4Lmdsc2wnO1xuaW1wb3J0IGZzIGZyb20gJy4vdGV4dC1iYWNrZ3JvdW5kLWxheWVyLWZyYWdtZW50Lmdsc2wnO1xuY29uc3QgZGVmYXVsdFByb3BzID0ge1xuICBiaWxsYm9hcmQ6IHRydWUsXG4gIHNpemVTY2FsZTogMSxcbiAgc2l6ZVVuaXRzOiAncGl4ZWxzJyxcbiAgc2l6ZU1pblBpeGVsczogMCxcbiAgc2l6ZU1heFBpeGVsczogTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVIsXG4gIHBhZGRpbmc6IHtcbiAgICB0eXBlOiAnYXJyYXknLFxuICAgIHZhbHVlOiBbMCwgMCwgMCwgMF1cbiAgfSxcbiAgZ2V0UG9zaXRpb246IHtcbiAgICB0eXBlOiAnYWNjZXNzb3InLFxuICAgIHZhbHVlOiB4ID0+IHgucG9zaXRpb25cbiAgfSxcbiAgZ2V0U2l6ZToge1xuICAgIHR5cGU6ICdhY2Nlc3NvcicsXG4gICAgdmFsdWU6IDFcbiAgfSxcbiAgZ2V0QW5nbGU6IHtcbiAgICB0eXBlOiAnYWNjZXNzb3InLFxuICAgIHZhbHVlOiAwXG4gIH0sXG4gIGdldFBpeGVsT2Zmc2V0OiB7XG4gICAgdHlwZTogJ2FjY2Vzc29yJyxcbiAgICB2YWx1ZTogWzAsIDBdXG4gIH0sXG4gIGdldEJvdW5kaW5nUmVjdDoge1xuICAgIHR5cGU6ICdhY2Nlc3NvcicsXG4gICAgdmFsdWU6IFswLCAwLCAwLCAwXVxuICB9LFxuICBnZXRGaWxsQ29sb3I6IHtcbiAgICB0eXBlOiAnYWNjZXNzb3InLFxuICAgIHZhbHVlOiBbMCwgMCwgMCwgMjU1XVxuICB9LFxuICBnZXRMaW5lQ29sb3I6IHtcbiAgICB0eXBlOiAnYWNjZXNzb3InLFxuICAgIHZhbHVlOiBbMCwgMCwgMCwgMjU1XVxuICB9LFxuICBnZXRMaW5lV2lkdGg6IHtcbiAgICB0eXBlOiAnYWNjZXNzb3InLFxuICAgIHZhbHVlOiAxXG4gIH1cbn07XG5leHBvcnQgZGVmYXVsdCBjbGFzcyBUZXh0QmFja2dyb3VuZExheWVyIGV4dGVuZHMgTGF5ZXIge1xuICBjb25zdHJ1Y3RvciguLi5hcmdzKSB7XG4gICAgc3VwZXIoLi4uYXJncyk7XG5cbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJzdGF0ZVwiLCB2b2lkIDApO1xuICB9XG5cbiAgZ2V0U2hhZGVycygpIHtcbiAgICByZXR1cm4gc3VwZXIuZ2V0U2hhZGVycyh7XG4gICAgICB2cyxcbiAgICAgIGZzLFxuICAgICAgbW9kdWxlczogW3Byb2plY3QzMiwgcGlja2luZ11cbiAgICB9KTtcbiAgfVxuXG4gIGluaXRpYWxpemVTdGF0ZSgpIHtcbiAgICB0aGlzLmdldEF0dHJpYnV0ZU1hbmFnZXIoKS5hZGRJbnN0YW5jZWQoe1xuICAgICAgaW5zdGFuY2VQb3NpdGlvbnM6IHtcbiAgICAgICAgc2l6ZTogMyxcbiAgICAgICAgdHlwZTogNTEzMCxcbiAgICAgICAgZnA2NDogdGhpcy51c2U2NGJpdFBvc2l0aW9ucygpLFxuICAgICAgICB0cmFuc2l0aW9uOiB0cnVlLFxuICAgICAgICBhY2Nlc3NvcjogJ2dldFBvc2l0aW9uJ1xuICAgICAgfSxcbiAgICAgIGluc3RhbmNlU2l6ZXM6IHtcbiAgICAgICAgc2l6ZTogMSxcbiAgICAgICAgdHJhbnNpdGlvbjogdHJ1ZSxcbiAgICAgICAgYWNjZXNzb3I6ICdnZXRTaXplJyxcbiAgICAgICAgZGVmYXVsdFZhbHVlOiAxXG4gICAgICB9LFxuICAgICAgaW5zdGFuY2VBbmdsZXM6IHtcbiAgICAgICAgc2l6ZTogMSxcbiAgICAgICAgdHJhbnNpdGlvbjogdHJ1ZSxcbiAgICAgICAgYWNjZXNzb3I6ICdnZXRBbmdsZSdcbiAgICAgIH0sXG4gICAgICBpbnN0YW5jZVJlY3RzOiB7XG4gICAgICAgIHNpemU6IDQsXG4gICAgICAgIGFjY2Vzc29yOiAnZ2V0Qm91bmRpbmdSZWN0J1xuICAgICAgfSxcbiAgICAgIGluc3RhbmNlUGl4ZWxPZmZzZXRzOiB7XG4gICAgICAgIHNpemU6IDIsXG4gICAgICAgIHRyYW5zaXRpb246IHRydWUsXG4gICAgICAgIGFjY2Vzc29yOiAnZ2V0UGl4ZWxPZmZzZXQnXG4gICAgICB9LFxuICAgICAgaW5zdGFuY2VGaWxsQ29sb3JzOiB7XG4gICAgICAgIHNpemU6IDQsXG4gICAgICAgIHRyYW5zaXRpb246IHRydWUsXG4gICAgICAgIG5vcm1hbGl6ZWQ6IHRydWUsXG4gICAgICAgIHR5cGU6IDUxMjEsXG4gICAgICAgIGFjY2Vzc29yOiAnZ2V0RmlsbENvbG9yJyxcbiAgICAgICAgZGVmYXVsdFZhbHVlOiBbMCwgMCwgMCwgMjU1XVxuICAgICAgfSxcbiAgICAgIGluc3RhbmNlTGluZUNvbG9yczoge1xuICAgICAgICBzaXplOiA0LFxuICAgICAgICB0cmFuc2l0aW9uOiB0cnVlLFxuICAgICAgICBub3JtYWxpemVkOiB0cnVlLFxuICAgICAgICB0eXBlOiA1MTIxLFxuICAgICAgICBhY2Nlc3NvcjogJ2dldExpbmVDb2xvcicsXG4gICAgICAgIGRlZmF1bHRWYWx1ZTogWzAsIDAsIDAsIDI1NV1cbiAgICAgIH0sXG4gICAgICBpbnN0YW5jZUxpbmVXaWR0aHM6IHtcbiAgICAgICAgc2l6ZTogMSxcbiAgICAgICAgdHJhbnNpdGlvbjogdHJ1ZSxcbiAgICAgICAgYWNjZXNzb3I6ICdnZXRMaW5lV2lkdGgnLFxuICAgICAgICBkZWZhdWx0VmFsdWU6IDFcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIHVwZGF0ZVN0YXRlKHBhcmFtcykge1xuICAgIHN1cGVyLnVwZGF0ZVN0YXRlKHBhcmFtcyk7XG4gICAgY29uc3Qge1xuICAgICAgY2hhbmdlRmxhZ3NcbiAgICB9ID0gcGFyYW1zO1xuXG4gICAgaWYgKGNoYW5nZUZsYWdzLmV4dGVuc2lvbnNDaGFuZ2VkKSB7XG4gICAgICB2YXIgX3RoaXMkc3RhdGUkbW9kZWw7XG5cbiAgICAgIGNvbnN0IHtcbiAgICAgICAgZ2xcbiAgICAgIH0gPSB0aGlzLmNvbnRleHQ7XG4gICAgICAoX3RoaXMkc3RhdGUkbW9kZWwgPSB0aGlzLnN0YXRlLm1vZGVsKSA9PT0gbnVsbCB8fCBfdGhpcyRzdGF0ZSRtb2RlbCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX3RoaXMkc3RhdGUkbW9kZWwuZGVsZXRlKCk7XG4gICAgICB0aGlzLnN0YXRlLm1vZGVsID0gdGhpcy5fZ2V0TW9kZWwoZ2wpO1xuICAgICAgdGhpcy5nZXRBdHRyaWJ1dGVNYW5hZ2VyKCkuaW52YWxpZGF0ZUFsbCgpO1xuICAgIH1cbiAgfVxuXG4gIGRyYXcoe1xuICAgIHVuaWZvcm1zXG4gIH0pIHtcbiAgICBjb25zdCB7XG4gICAgICBiaWxsYm9hcmQsXG4gICAgICBzaXplU2NhbGUsXG4gICAgICBzaXplVW5pdHMsXG4gICAgICBzaXplTWluUGl4ZWxzLFxuICAgICAgc2l6ZU1heFBpeGVscyxcbiAgICAgIGdldExpbmVXaWR0aFxuICAgIH0gPSB0aGlzLnByb3BzO1xuICAgIGxldCB7XG4gICAgICBwYWRkaW5nXG4gICAgfSA9IHRoaXMucHJvcHM7XG5cbiAgICBpZiAocGFkZGluZy5sZW5ndGggPCA0KSB7XG4gICAgICBwYWRkaW5nID0gW3BhZGRpbmdbMF0sIHBhZGRpbmdbMV0sIHBhZGRpbmdbMF0sIHBhZGRpbmdbMV1dO1xuICAgIH1cblxuICAgIHRoaXMuc3RhdGUubW9kZWwuc2V0VW5pZm9ybXModW5pZm9ybXMpLnNldFVuaWZvcm1zKHtcbiAgICAgIGJpbGxib2FyZCxcbiAgICAgIHN0cm9rZWQ6IEJvb2xlYW4oZ2V0TGluZVdpZHRoKSxcbiAgICAgIHBhZGRpbmcsXG4gICAgICBzaXplVW5pdHM6IFVOSVRbc2l6ZVVuaXRzXSxcbiAgICAgIHNpemVTY2FsZSxcbiAgICAgIHNpemVNaW5QaXhlbHMsXG4gICAgICBzaXplTWF4UGl4ZWxzXG4gICAgfSkuZHJhdygpO1xuICB9XG5cbiAgX2dldE1vZGVsKGdsKSB7XG4gICAgY29uc3QgcG9zaXRpb25zID0gWzAsIDAsIDEsIDAsIDEsIDEsIDAsIDFdO1xuICAgIHJldHVybiBuZXcgTW9kZWwoZ2wsIHsgLi4udGhpcy5nZXRTaGFkZXJzKCksXG4gICAgICBpZDogdGhpcy5wcm9wcy5pZCxcbiAgICAgIGdlb21ldHJ5OiBuZXcgR2VvbWV0cnkoe1xuICAgICAgICBkcmF3TW9kZTogNixcbiAgICAgICAgdmVydGV4Q291bnQ6IDQsXG4gICAgICAgIGF0dHJpYnV0ZXM6IHtcbiAgICAgICAgICBwb3NpdGlvbnM6IHtcbiAgICAgICAgICAgIHNpemU6IDIsXG4gICAgICAgICAgICB2YWx1ZTogbmV3IEZsb2F0MzJBcnJheShwb3NpdGlvbnMpXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KSxcbiAgICAgIGlzSW5zdGFuY2VkOiB0cnVlXG4gICAgfSk7XG4gIH1cblxufVxuXG5fZGVmaW5lUHJvcGVydHkoVGV4dEJhY2tncm91bmRMYXllciwgXCJkZWZhdWx0UHJvcHNcIiwgZGVmYXVsdFByb3BzKTtcblxuX2RlZmluZVByb3BlcnR5KFRleHRCYWNrZ3JvdW5kTGF5ZXIsIFwibGF5ZXJOYW1lXCIsICdUZXh0QmFja2dyb3VuZExheWVyJyk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD10ZXh0LWJhY2tncm91bmQtbGF5ZXIuanMubWFwIiwiaW1wb3J0IF9kZWZpbmVQcm9wZXJ0eSBmcm9tIFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vZGVmaW5lUHJvcGVydHlcIjtcbmltcG9ydCB7IENvbXBvc2l0ZUxheWVyLCBjcmVhdGVJdGVyYWJsZSwgbG9nIH0gZnJvbSAnQGRlY2suZ2wvY29yZSc7XG5pbXBvcnQgTXVsdGlJY29uTGF5ZXIgZnJvbSAnLi9tdWx0aS1pY29uLWxheWVyL211bHRpLWljb24tbGF5ZXInO1xuaW1wb3J0IEZvbnRBdGxhc01hbmFnZXIsIHsgREVGQVVMVF9GT05UX1NFVFRJTkdTLCBzZXRGb250QXRsYXNDYWNoZUxpbWl0IH0gZnJvbSAnLi9mb250LWF0bGFzLW1hbmFnZXInO1xuaW1wb3J0IHsgdHJhbnNmb3JtUGFyYWdyYXBoLCBnZXRUZXh0RnJvbUJ1ZmZlciB9IGZyb20gJy4vdXRpbHMnO1xuaW1wb3J0IFRleHRCYWNrZ3JvdW5kTGF5ZXIgZnJvbSAnLi90ZXh0LWJhY2tncm91bmQtbGF5ZXIvdGV4dC1iYWNrZ3JvdW5kLWxheWVyJztcbmNvbnN0IFRFWFRfQU5DSE9SID0ge1xuICBzdGFydDogMSxcbiAgbWlkZGxlOiAwLFxuICBlbmQ6IC0xXG59O1xuY29uc3QgQUxJR05NRU5UX0JBU0VMSU5FID0ge1xuICB0b3A6IDEsXG4gIGNlbnRlcjogMCxcbiAgYm90dG9tOiAtMVxufTtcbmNvbnN0IERFRkFVTFRfQ09MT1IgPSBbMCwgMCwgMCwgMjU1XTtcbmNvbnN0IERFRkFVTFRfTElORV9IRUlHSFQgPSAxLjA7XG5jb25zdCBkZWZhdWx0UHJvcHMgPSB7XG4gIGJpbGxib2FyZDogdHJ1ZSxcbiAgc2l6ZVNjYWxlOiAxLFxuICBzaXplVW5pdHM6ICdwaXhlbHMnLFxuICBzaXplTWluUGl4ZWxzOiAwLFxuICBzaXplTWF4UGl4ZWxzOiBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUixcbiAgYmFja2dyb3VuZDogZmFsc2UsXG4gIGdldEJhY2tncm91bmRDb2xvcjoge1xuICAgIHR5cGU6ICdhY2Nlc3NvcicsXG4gICAgdmFsdWU6IFsyNTUsIDI1NSwgMjU1LCAyNTVdXG4gIH0sXG4gIGdldEJvcmRlckNvbG9yOiB7XG4gICAgdHlwZTogJ2FjY2Vzc29yJyxcbiAgICB2YWx1ZTogREVGQVVMVF9DT0xPUlxuICB9LFxuICBnZXRCb3JkZXJXaWR0aDoge1xuICAgIHR5cGU6ICdhY2Nlc3NvcicsXG4gICAgdmFsdWU6IDBcbiAgfSxcbiAgYmFja2dyb3VuZFBhZGRpbmc6IHtcbiAgICB0eXBlOiAnYXJyYXknLFxuICAgIHZhbHVlOiBbMCwgMCwgMCwgMF1cbiAgfSxcbiAgY2hhcmFjdGVyU2V0OiB7XG4gICAgdHlwZTogJ29iamVjdCcsXG4gICAgdmFsdWU6IERFRkFVTFRfRk9OVF9TRVRUSU5HUy5jaGFyYWN0ZXJTZXRcbiAgfSxcbiAgZm9udEZhbWlseTogREVGQVVMVF9GT05UX1NFVFRJTkdTLmZvbnRGYW1pbHksXG4gIGZvbnRXZWlnaHQ6IERFRkFVTFRfRk9OVF9TRVRUSU5HUy5mb250V2VpZ2h0LFxuICBsaW5lSGVpZ2h0OiBERUZBVUxUX0xJTkVfSEVJR0hULFxuICBvdXRsaW5lV2lkdGg6IHtcbiAgICB0eXBlOiAnbnVtYmVyJyxcbiAgICB2YWx1ZTogMCxcbiAgICBtaW46IDBcbiAgfSxcbiAgb3V0bGluZUNvbG9yOiB7XG4gICAgdHlwZTogJ2NvbG9yJyxcbiAgICB2YWx1ZTogREVGQVVMVF9DT0xPUlxuICB9LFxuICBmb250U2V0dGluZ3M6IHtcbiAgICB0eXBlOiAnb2JqZWN0JyxcbiAgICB2YWx1ZToge30sXG4gICAgY29tcGFyZTogMVxuICB9LFxuICB3b3JkQnJlYWs6ICdicmVhay13b3JkJyxcbiAgbWF4V2lkdGg6IHtcbiAgICB0eXBlOiAnbnVtYmVyJyxcbiAgICB2YWx1ZTogLTFcbiAgfSxcbiAgZ2V0VGV4dDoge1xuICAgIHR5cGU6ICdhY2Nlc3NvcicsXG4gICAgdmFsdWU6IHggPT4geC50ZXh0XG4gIH0sXG4gIGdldFBvc2l0aW9uOiB7XG4gICAgdHlwZTogJ2FjY2Vzc29yJyxcbiAgICB2YWx1ZTogeCA9PiB4LnBvc2l0aW9uXG4gIH0sXG4gIGdldENvbG9yOiB7XG4gICAgdHlwZTogJ2FjY2Vzc29yJyxcbiAgICB2YWx1ZTogREVGQVVMVF9DT0xPUlxuICB9LFxuICBnZXRTaXplOiB7XG4gICAgdHlwZTogJ2FjY2Vzc29yJyxcbiAgICB2YWx1ZTogMzJcbiAgfSxcbiAgZ2V0QW5nbGU6IHtcbiAgICB0eXBlOiAnYWNjZXNzb3InLFxuICAgIHZhbHVlOiAwXG4gIH0sXG4gIGdldFRleHRBbmNob3I6IHtcbiAgICB0eXBlOiAnYWNjZXNzb3InLFxuICAgIHZhbHVlOiAnbWlkZGxlJ1xuICB9LFxuICBnZXRBbGlnbm1lbnRCYXNlbGluZToge1xuICAgIHR5cGU6ICdhY2Nlc3NvcicsXG4gICAgdmFsdWU6ICdjZW50ZXInXG4gIH0sXG4gIGdldFBpeGVsT2Zmc2V0OiB7XG4gICAgdHlwZTogJ2FjY2Vzc29yJyxcbiAgICB2YWx1ZTogWzAsIDBdXG4gIH0sXG4gIGJhY2tncm91bmRDb2xvcjoge1xuICAgIGRlcHJlY2F0ZWRGb3I6IFsnYmFja2dyb3VuZCcsICdnZXRCYWNrZ3JvdW5kQ29sb3InXVxuICB9XG59O1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgVGV4dExheWVyIGV4dGVuZHMgQ29tcG9zaXRlTGF5ZXIge1xuICBjb25zdHJ1Y3RvciguLi5hcmdzKSB7XG4gICAgc3VwZXIoLi4uYXJncyk7XG5cbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJzdGF0ZVwiLCB2b2lkIDApO1xuXG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwiZ2V0Qm91bmRpbmdSZWN0XCIsIChvYmplY3QsIG9iamVjdEluZm8pID0+IHtcbiAgICAgIGxldCB7XG4gICAgICAgIHNpemU6IFt3aWR0aCwgaGVpZ2h0XVxuICAgICAgfSA9IHRoaXMudHJhbnNmb3JtUGFyYWdyYXBoKG9iamVjdCwgb2JqZWN0SW5mbyk7XG4gICAgICBjb25zdCB7XG4gICAgICAgIGZvbnRTaXplXG4gICAgICB9ID0gdGhpcy5zdGF0ZS5mb250QXRsYXNNYW5hZ2VyLnByb3BzO1xuICAgICAgd2lkdGggLz0gZm9udFNpemU7XG4gICAgICBoZWlnaHQgLz0gZm9udFNpemU7XG4gICAgICBjb25zdCB7XG4gICAgICAgIGdldFRleHRBbmNob3IsXG4gICAgICAgIGdldEFsaWdubWVudEJhc2VsaW5lXG4gICAgICB9ID0gdGhpcy5wcm9wcztcbiAgICAgIGNvbnN0IGFuY2hvclggPSBURVhUX0FOQ0hPUlt0eXBlb2YgZ2V0VGV4dEFuY2hvciA9PT0gJ2Z1bmN0aW9uJyA/IGdldFRleHRBbmNob3Iob2JqZWN0LCBvYmplY3RJbmZvKSA6IGdldFRleHRBbmNob3JdO1xuICAgICAgY29uc3QgYW5jaG9yWSA9IEFMSUdOTUVOVF9CQVNFTElORVt0eXBlb2YgZ2V0QWxpZ25tZW50QmFzZWxpbmUgPT09ICdmdW5jdGlvbicgPyBnZXRBbGlnbm1lbnRCYXNlbGluZShvYmplY3QsIG9iamVjdEluZm8pIDogZ2V0QWxpZ25tZW50QmFzZWxpbmVdO1xuICAgICAgcmV0dXJuIFsoYW5jaG9yWCAtIDEpICogd2lkdGggLyAyLCAoYW5jaG9yWSAtIDEpICogaGVpZ2h0IC8gMiwgd2lkdGgsIGhlaWdodF07XG4gICAgfSk7XG5cbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJnZXRJY29uT2Zmc2V0c1wiLCAob2JqZWN0LCBvYmplY3RJbmZvKSA9PiB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIGdldFRleHRBbmNob3IsXG4gICAgICAgIGdldEFsaWdubWVudEJhc2VsaW5lXG4gICAgICB9ID0gdGhpcy5wcm9wcztcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgeCxcbiAgICAgICAgeSxcbiAgICAgICAgcm93V2lkdGgsXG4gICAgICAgIHNpemU6IFt3aWR0aCwgaGVpZ2h0XVxuICAgICAgfSA9IHRoaXMudHJhbnNmb3JtUGFyYWdyYXBoKG9iamVjdCwgb2JqZWN0SW5mbyk7XG4gICAgICBjb25zdCBhbmNob3JYID0gVEVYVF9BTkNIT1JbdHlwZW9mIGdldFRleHRBbmNob3IgPT09ICdmdW5jdGlvbicgPyBnZXRUZXh0QW5jaG9yKG9iamVjdCwgb2JqZWN0SW5mbykgOiBnZXRUZXh0QW5jaG9yXTtcbiAgICAgIGNvbnN0IGFuY2hvclkgPSBBTElHTk1FTlRfQkFTRUxJTkVbdHlwZW9mIGdldEFsaWdubWVudEJhc2VsaW5lID09PSAnZnVuY3Rpb24nID8gZ2V0QWxpZ25tZW50QmFzZWxpbmUob2JqZWN0LCBvYmplY3RJbmZvKSA6IGdldEFsaWdubWVudEJhc2VsaW5lXTtcbiAgICAgIGNvbnN0IG51bUNoYXJhY3RlcnMgPSB4Lmxlbmd0aDtcbiAgICAgIGNvbnN0IG9mZnNldHMgPSBuZXcgQXJyYXkobnVtQ2hhcmFjdGVycyAqIDIpO1xuICAgICAgbGV0IGluZGV4ID0gMDtcblxuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBudW1DaGFyYWN0ZXJzOyBpKyspIHtcbiAgICAgICAgY29uc3Qgcm93T2Zmc2V0ID0gKDEgLSBhbmNob3JYKSAqICh3aWR0aCAtIHJvd1dpZHRoW2ldKSAvIDI7XG4gICAgICAgIG9mZnNldHNbaW5kZXgrK10gPSAoYW5jaG9yWCAtIDEpICogd2lkdGggLyAyICsgcm93T2Zmc2V0ICsgeFtpXTtcbiAgICAgICAgb2Zmc2V0c1tpbmRleCsrXSA9IChhbmNob3JZIC0gMSkgKiBoZWlnaHQgLyAyICsgeVtpXTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG9mZnNldHM7XG4gICAgfSk7XG4gIH1cblxuICBpbml0aWFsaXplU3RhdGUoKSB7XG4gICAgdGhpcy5zdGF0ZSA9IHtcbiAgICAgIHN0eWxlVmVyc2lvbjogMCxcbiAgICAgIGZvbnRBdGxhc01hbmFnZXI6IG5ldyBGb250QXRsYXNNYW5hZ2VyKClcbiAgICB9O1xuXG4gICAgaWYgKHRoaXMucHJvcHMubWF4V2lkdGggPiAwKSB7XG4gICAgICBsb2cud2FybigndjguOSBicmVha2luZyBjaGFuZ2U6IFRleHRMYXllciBtYXhXaWR0aCBpcyBub3cgcmVsYXRpdmUgdG8gdGV4dCBzaXplJykoKTtcbiAgICB9XG4gIH1cblxuICB1cGRhdGVTdGF0ZShwYXJhbXMpIHtcbiAgICBjb25zdCB7XG4gICAgICBwcm9wcyxcbiAgICAgIG9sZFByb3BzLFxuICAgICAgY2hhbmdlRmxhZ3NcbiAgICB9ID0gcGFyYW1zO1xuICAgIGNvbnN0IHRleHRDaGFuZ2VkID0gY2hhbmdlRmxhZ3MuZGF0YUNoYW5nZWQgfHwgY2hhbmdlRmxhZ3MudXBkYXRlVHJpZ2dlcnNDaGFuZ2VkICYmIChjaGFuZ2VGbGFncy51cGRhdGVUcmlnZ2Vyc0NoYW5nZWQuYWxsIHx8IGNoYW5nZUZsYWdzLnVwZGF0ZVRyaWdnZXJzQ2hhbmdlZC5nZXRUZXh0KTtcblxuICAgIGlmICh0ZXh0Q2hhbmdlZCkge1xuICAgICAgdGhpcy5fdXBkYXRlVGV4dCgpO1xuICAgIH1cblxuICAgIGNvbnN0IGZvbnRDaGFuZ2VkID0gdGhpcy5fdXBkYXRlRm9udEF0bGFzKCk7XG5cbiAgICBjb25zdCBzdHlsZUNoYW5nZWQgPSBmb250Q2hhbmdlZCB8fCBwcm9wcy5saW5lSGVpZ2h0ICE9PSBvbGRQcm9wcy5saW5lSGVpZ2h0IHx8IHByb3BzLndvcmRCcmVhayAhPT0gb2xkUHJvcHMud29yZEJyZWFrIHx8IHByb3BzLm1heFdpZHRoICE9PSBvbGRQcm9wcy5tYXhXaWR0aDtcblxuICAgIGlmIChzdHlsZUNoYW5nZWQpIHtcbiAgICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgICAgICBzdHlsZVZlcnNpb246IHRoaXMuc3RhdGUuc3R5bGVWZXJzaW9uICsgMVxuICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgZ2V0UGlja2luZ0luZm8oe1xuICAgIGluZm9cbiAgfSkge1xuICAgIGluZm8ub2JqZWN0ID0gaW5mby5pbmRleCA+PSAwID8gdGhpcy5wcm9wcy5kYXRhW2luZm8uaW5kZXhdIDogbnVsbDtcbiAgICByZXR1cm4gaW5mbztcbiAgfVxuXG4gIF91cGRhdGVGb250QXRsYXMoKSB7XG4gICAgY29uc3Qge1xuICAgICAgZm9udFNldHRpbmdzLFxuICAgICAgZm9udEZhbWlseSxcbiAgICAgIGZvbnRXZWlnaHRcbiAgICB9ID0gdGhpcy5wcm9wcztcbiAgICBjb25zdCB7XG4gICAgICBmb250QXRsYXNNYW5hZ2VyLFxuICAgICAgY2hhcmFjdGVyU2V0XG4gICAgfSA9IHRoaXMuc3RhdGU7XG4gICAgY29uc3QgZm9udFByb3BzID0geyAuLi5mb250U2V0dGluZ3MsXG4gICAgICBjaGFyYWN0ZXJTZXQsXG4gICAgICBmb250RmFtaWx5LFxuICAgICAgZm9udFdlaWdodFxuICAgIH07XG5cbiAgICBpZiAoIWZvbnRBdGxhc01hbmFnZXIubWFwcGluZykge1xuICAgICAgZm9udEF0bGFzTWFuYWdlci5zZXRQcm9wcyhmb250UHJvcHMpO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgZm9yIChjb25zdCBrZXkgaW4gZm9udFByb3BzKSB7XG4gICAgICBpZiAoZm9udFByb3BzW2tleV0gIT09IGZvbnRBdGxhc01hbmFnZXIucHJvcHNba2V5XSkge1xuICAgICAgICBmb250QXRsYXNNYW5hZ2VyLnNldFByb3BzKGZvbnRQcm9wcyk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIF91cGRhdGVUZXh0KCkge1xuICAgIHZhciBfYXR0cmlidXRlcztcblxuICAgIGNvbnN0IHtcbiAgICAgIGRhdGEsXG4gICAgICBjaGFyYWN0ZXJTZXRcbiAgICB9ID0gdGhpcy5wcm9wcztcbiAgICBjb25zdCB0ZXh0QnVmZmVyID0gKF9hdHRyaWJ1dGVzID0gZGF0YS5hdHRyaWJ1dGVzKSA9PT0gbnVsbCB8fCBfYXR0cmlidXRlcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2F0dHJpYnV0ZXMuZ2V0VGV4dDtcbiAgICBsZXQge1xuICAgICAgZ2V0VGV4dFxuICAgIH0gPSB0aGlzLnByb3BzO1xuICAgIGxldCBzdGFydEluZGljZXMgPSBkYXRhLnN0YXJ0SW5kaWNlcztcbiAgICBsZXQgbnVtSW5zdGFuY2VzO1xuICAgIGNvbnN0IGF1dG9DaGFyYWN0ZXJTZXQgPSBjaGFyYWN0ZXJTZXQgPT09ICdhdXRvJyAmJiBuZXcgU2V0KCk7XG5cbiAgICBpZiAodGV4dEJ1ZmZlciAmJiBzdGFydEluZGljZXMpIHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgdGV4dHMsXG4gICAgICAgIGNoYXJhY3RlckNvdW50XG4gICAgICB9ID0gZ2V0VGV4dEZyb21CdWZmZXIoeyAuLi4oQXJyYXlCdWZmZXIuaXNWaWV3KHRleHRCdWZmZXIpID8ge1xuICAgICAgICAgIHZhbHVlOiB0ZXh0QnVmZmVyXG4gICAgICAgIH0gOiB0ZXh0QnVmZmVyKSxcbiAgICAgICAgbGVuZ3RoOiBkYXRhLmxlbmd0aCxcbiAgICAgICAgc3RhcnRJbmRpY2VzLFxuICAgICAgICBjaGFyYWN0ZXJTZXQ6IGF1dG9DaGFyYWN0ZXJTZXRcbiAgICAgIH0pO1xuICAgICAgbnVtSW5zdGFuY2VzID0gY2hhcmFjdGVyQ291bnQ7XG5cbiAgICAgIGdldFRleHQgPSAoXywge1xuICAgICAgICBpbmRleFxuICAgICAgfSkgPT4gdGV4dHNbaW5kZXhdO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIGl0ZXJhYmxlLFxuICAgICAgICBvYmplY3RJbmZvXG4gICAgICB9ID0gY3JlYXRlSXRlcmFibGUoZGF0YSk7XG4gICAgICBzdGFydEluZGljZXMgPSBbMF07XG4gICAgICBudW1JbnN0YW5jZXMgPSAwO1xuXG4gICAgICBmb3IgKGNvbnN0IG9iamVjdCBvZiBpdGVyYWJsZSkge1xuICAgICAgICBvYmplY3RJbmZvLmluZGV4Kys7XG4gICAgICAgIGNvbnN0IHRleHQgPSBBcnJheS5mcm9tKGdldFRleHQob2JqZWN0LCBvYmplY3RJbmZvKSB8fCAnJyk7XG5cbiAgICAgICAgaWYgKGF1dG9DaGFyYWN0ZXJTZXQpIHtcbiAgICAgICAgICB0ZXh0LmZvckVhY2goYXV0b0NoYXJhY3RlclNldC5hZGQsIGF1dG9DaGFyYWN0ZXJTZXQpO1xuICAgICAgICB9XG5cbiAgICAgICAgbnVtSW5zdGFuY2VzICs9IHRleHQubGVuZ3RoO1xuICAgICAgICBzdGFydEluZGljZXMucHVzaChudW1JbnN0YW5jZXMpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgICAgZ2V0VGV4dCxcbiAgICAgIHN0YXJ0SW5kaWNlcyxcbiAgICAgIG51bUluc3RhbmNlcyxcbiAgICAgIGNoYXJhY3RlclNldDogYXV0b0NoYXJhY3RlclNldCB8fCBjaGFyYWN0ZXJTZXRcbiAgICB9KTtcbiAgfVxuXG4gIHRyYW5zZm9ybVBhcmFncmFwaChvYmplY3QsIG9iamVjdEluZm8pIHtcbiAgICBjb25zdCB7XG4gICAgICBmb250QXRsYXNNYW5hZ2VyXG4gICAgfSA9IHRoaXMuc3RhdGU7XG4gICAgY29uc3QgaWNvbk1hcHBpbmcgPSBmb250QXRsYXNNYW5hZ2VyLm1hcHBpbmc7XG4gICAgY29uc3QgZ2V0VGV4dCA9IHRoaXMuc3RhdGUuZ2V0VGV4dDtcbiAgICBjb25zdCB7XG4gICAgICB3b3JkQnJlYWssXG4gICAgICBsaW5lSGVpZ2h0LFxuICAgICAgbWF4V2lkdGhcbiAgICB9ID0gdGhpcy5wcm9wcztcbiAgICBjb25zdCBwYXJhZ3JhcGggPSBnZXRUZXh0KG9iamVjdCwgb2JqZWN0SW5mbykgfHwgJyc7XG4gICAgcmV0dXJuIHRyYW5zZm9ybVBhcmFncmFwaChwYXJhZ3JhcGgsIGxpbmVIZWlnaHQsIHdvcmRCcmVhaywgbWF4V2lkdGggKiBmb250QXRsYXNNYW5hZ2VyLnByb3BzLmZvbnRTaXplLCBpY29uTWFwcGluZyk7XG4gIH1cblxuICByZW5kZXJMYXllcnMoKSB7XG4gICAgY29uc3Qge1xuICAgICAgc3RhcnRJbmRpY2VzLFxuICAgICAgbnVtSW5zdGFuY2VzLFxuICAgICAgZ2V0VGV4dCxcbiAgICAgIGZvbnRBdGxhc01hbmFnZXI6IHtcbiAgICAgICAgc2NhbGUsXG4gICAgICAgIHRleHR1cmUsXG4gICAgICAgIG1hcHBpbmdcbiAgICAgIH0sXG4gICAgICBzdHlsZVZlcnNpb25cbiAgICB9ID0gdGhpcy5zdGF0ZTtcbiAgICBjb25zdCB7XG4gICAgICBkYXRhLFxuICAgICAgX2RhdGFEaWZmLFxuICAgICAgZ2V0UG9zaXRpb24sXG4gICAgICBnZXRDb2xvcixcbiAgICAgIGdldFNpemUsXG4gICAgICBnZXRBbmdsZSxcbiAgICAgIGdldFBpeGVsT2Zmc2V0LFxuICAgICAgZ2V0QmFja2dyb3VuZENvbG9yLFxuICAgICAgZ2V0Qm9yZGVyQ29sb3IsXG4gICAgICBnZXRCb3JkZXJXaWR0aCxcbiAgICAgIGJhY2tncm91bmRQYWRkaW5nLFxuICAgICAgYmFja2dyb3VuZCxcbiAgICAgIGJpbGxib2FyZCxcbiAgICAgIGZvbnRTZXR0aW5ncyxcbiAgICAgIG91dGxpbmVXaWR0aCxcbiAgICAgIG91dGxpbmVDb2xvcixcbiAgICAgIHNpemVTY2FsZSxcbiAgICAgIHNpemVVbml0cyxcbiAgICAgIHNpemVNaW5QaXhlbHMsXG4gICAgICBzaXplTWF4UGl4ZWxzLFxuICAgICAgdHJhbnNpdGlvbnMsXG4gICAgICB1cGRhdGVUcmlnZ2Vyc1xuICAgIH0gPSB0aGlzLnByb3BzO1xuICAgIGNvbnN0IENoYXJhY3RlcnNMYXllckNsYXNzID0gdGhpcy5nZXRTdWJMYXllckNsYXNzKCdjaGFyYWN0ZXJzJywgTXVsdGlJY29uTGF5ZXIpO1xuICAgIGNvbnN0IEJhY2tncm91bmRMYXllckNsYXNzID0gdGhpcy5nZXRTdWJMYXllckNsYXNzKCdiYWNrZ3JvdW5kJywgVGV4dEJhY2tncm91bmRMYXllcik7XG4gICAgcmV0dXJuIFtiYWNrZ3JvdW5kICYmIG5ldyBCYWNrZ3JvdW5kTGF5ZXJDbGFzcyh7XG4gICAgICBnZXRGaWxsQ29sb3I6IGdldEJhY2tncm91bmRDb2xvcixcbiAgICAgIGdldExpbmVDb2xvcjogZ2V0Qm9yZGVyQ29sb3IsXG4gICAgICBnZXRMaW5lV2lkdGg6IGdldEJvcmRlcldpZHRoLFxuICAgICAgcGFkZGluZzogYmFja2dyb3VuZFBhZGRpbmcsXG4gICAgICBnZXRQb3NpdGlvbixcbiAgICAgIGdldFNpemUsXG4gICAgICBnZXRBbmdsZSxcbiAgICAgIGdldFBpeGVsT2Zmc2V0LFxuICAgICAgYmlsbGJvYXJkLFxuICAgICAgc2l6ZVNjYWxlLFxuICAgICAgc2l6ZVVuaXRzLFxuICAgICAgc2l6ZU1pblBpeGVscyxcbiAgICAgIHNpemVNYXhQaXhlbHMsXG4gICAgICB0cmFuc2l0aW9uczogdHJhbnNpdGlvbnMgJiYge1xuICAgICAgICBnZXRQb3NpdGlvbjogdHJhbnNpdGlvbnMuZ2V0UG9zaXRpb24sXG4gICAgICAgIGdldEFuZ2xlOiB0cmFuc2l0aW9ucy5nZXRBbmdsZSxcbiAgICAgICAgZ2V0U2l6ZTogdHJhbnNpdGlvbnMuZ2V0U2l6ZSxcbiAgICAgICAgZ2V0RmlsbENvbG9yOiB0cmFuc2l0aW9ucy5nZXRCYWNrZ3JvdW5kQ29sb3IsXG4gICAgICAgIGdldExpbmVDb2xvcjogdHJhbnNpdGlvbnMuZ2V0Qm9yZGVyQ29sb3IsXG4gICAgICAgIGdldExpbmVXaWR0aDogdHJhbnNpdGlvbnMuZ2V0Qm9yZGVyV2lkdGgsXG4gICAgICAgIGdldFBpeGVsT2Zmc2V0OiB0cmFuc2l0aW9ucy5nZXRQaXhlbE9mZnNldFxuICAgICAgfVxuICAgIH0sIHRoaXMuZ2V0U3ViTGF5ZXJQcm9wcyh7XG4gICAgICBpZDogJ2JhY2tncm91bmQnLFxuICAgICAgdXBkYXRlVHJpZ2dlcnM6IHtcbiAgICAgICAgZ2V0UG9zaXRpb246IHVwZGF0ZVRyaWdnZXJzLmdldFBvc2l0aW9uLFxuICAgICAgICBnZXRBbmdsZTogdXBkYXRlVHJpZ2dlcnMuZ2V0QW5nbGUsXG4gICAgICAgIGdldFNpemU6IHVwZGF0ZVRyaWdnZXJzLmdldFNpemUsXG4gICAgICAgIGdldEZpbGxDb2xvcjogdXBkYXRlVHJpZ2dlcnMuZ2V0QmFja2dyb3VuZENvbG9yLFxuICAgICAgICBnZXRMaW5lQ29sb3I6IHVwZGF0ZVRyaWdnZXJzLmdldEJvcmRlckNvbG9yLFxuICAgICAgICBnZXRMaW5lV2lkdGg6IHVwZGF0ZVRyaWdnZXJzLmdldEJvcmRlcldpZHRoLFxuICAgICAgICBnZXRQaXhlbE9mZnNldDogdXBkYXRlVHJpZ2dlcnMuZ2V0UGl4ZWxPZmZzZXQsXG4gICAgICAgIGdldEJvdW5kaW5nUmVjdDoge1xuICAgICAgICAgIGdldFRleHQ6IHVwZGF0ZVRyaWdnZXJzLmdldFRleHQsXG4gICAgICAgICAgZ2V0VGV4dEFuY2hvcjogdXBkYXRlVHJpZ2dlcnMuZ2V0VGV4dEFuY2hvcixcbiAgICAgICAgICBnZXRBbGlnbm1lbnRCYXNlbGluZTogdXBkYXRlVHJpZ2dlcnMuZ2V0QWxpZ25tZW50QmFzZWxpbmUsXG4gICAgICAgICAgc3R5bGVWZXJzaW9uXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KSwge1xuICAgICAgZGF0YTogZGF0YS5hdHRyaWJ1dGVzICYmIGRhdGEuYXR0cmlidXRlcy5iYWNrZ3JvdW5kID8ge1xuICAgICAgICBsZW5ndGg6IGRhdGEubGVuZ3RoLFxuICAgICAgICBhdHRyaWJ1dGVzOiBkYXRhLmF0dHJpYnV0ZXMuYmFja2dyb3VuZFxuICAgICAgfSA6IGRhdGEsXG4gICAgICBfZGF0YURpZmYsXG4gICAgICBhdXRvSGlnaGxpZ2h0OiBmYWxzZSxcbiAgICAgIGdldEJvdW5kaW5nUmVjdDogdGhpcy5nZXRCb3VuZGluZ1JlY3RcbiAgICB9KSwgbmV3IENoYXJhY3RlcnNMYXllckNsYXNzKHtcbiAgICAgIHNkZjogZm9udFNldHRpbmdzLnNkZixcbiAgICAgIHNtb290aGluZzogTnVtYmVyLmlzRmluaXRlKGZvbnRTZXR0aW5ncy5zbW9vdGhpbmcpID8gZm9udFNldHRpbmdzLnNtb290aGluZyA6IERFRkFVTFRfRk9OVF9TRVRUSU5HUy5zbW9vdGhpbmcsXG4gICAgICBvdXRsaW5lV2lkdGg6IG91dGxpbmVXaWR0aCAvIChmb250U2V0dGluZ3MucmFkaXVzIHx8IERFRkFVTFRfRk9OVF9TRVRUSU5HUy5yYWRpdXMpLFxuICAgICAgb3V0bGluZUNvbG9yLFxuICAgICAgaWNvbkF0bGFzOiB0ZXh0dXJlLFxuICAgICAgaWNvbk1hcHBpbmc6IG1hcHBpbmcsXG4gICAgICBnZXRQb3NpdGlvbixcbiAgICAgIGdldENvbG9yLFxuICAgICAgZ2V0U2l6ZSxcbiAgICAgIGdldEFuZ2xlLFxuICAgICAgZ2V0UGl4ZWxPZmZzZXQsXG4gICAgICBiaWxsYm9hcmQsXG4gICAgICBzaXplU2NhbGU6IHNpemVTY2FsZSAqIHNjYWxlLFxuICAgICAgc2l6ZVVuaXRzLFxuICAgICAgc2l6ZU1pblBpeGVsczogc2l6ZU1pblBpeGVscyAqIHNjYWxlLFxuICAgICAgc2l6ZU1heFBpeGVsczogc2l6ZU1heFBpeGVscyAqIHNjYWxlLFxuICAgICAgdHJhbnNpdGlvbnM6IHRyYW5zaXRpb25zICYmIHtcbiAgICAgICAgZ2V0UG9zaXRpb246IHRyYW5zaXRpb25zLmdldFBvc2l0aW9uLFxuICAgICAgICBnZXRBbmdsZTogdHJhbnNpdGlvbnMuZ2V0QW5nbGUsXG4gICAgICAgIGdldENvbG9yOiB0cmFuc2l0aW9ucy5nZXRDb2xvcixcbiAgICAgICAgZ2V0U2l6ZTogdHJhbnNpdGlvbnMuZ2V0U2l6ZSxcbiAgICAgICAgZ2V0UGl4ZWxPZmZzZXQ6IHRyYW5zaXRpb25zLmdldFBpeGVsT2Zmc2V0XG4gICAgICB9XG4gICAgfSwgdGhpcy5nZXRTdWJMYXllclByb3BzKHtcbiAgICAgIGlkOiAnY2hhcmFjdGVycycsXG4gICAgICB1cGRhdGVUcmlnZ2Vyczoge1xuICAgICAgICBhbGw6IHVwZGF0ZVRyaWdnZXJzLmdldFRleHQsXG4gICAgICAgIGdldFBvc2l0aW9uOiB1cGRhdGVUcmlnZ2Vycy5nZXRQb3NpdGlvbixcbiAgICAgICAgZ2V0QW5nbGU6IHVwZGF0ZVRyaWdnZXJzLmdldEFuZ2xlLFxuICAgICAgICBnZXRDb2xvcjogdXBkYXRlVHJpZ2dlcnMuZ2V0Q29sb3IsXG4gICAgICAgIGdldFNpemU6IHVwZGF0ZVRyaWdnZXJzLmdldFNpemUsXG4gICAgICAgIGdldFBpeGVsT2Zmc2V0OiB1cGRhdGVUcmlnZ2Vycy5nZXRQaXhlbE9mZnNldCxcbiAgICAgICAgZ2V0SWNvbk9mZnNldHM6IHtcbiAgICAgICAgICBnZXRUZXh0QW5jaG9yOiB1cGRhdGVUcmlnZ2Vycy5nZXRUZXh0QW5jaG9yLFxuICAgICAgICAgIGdldEFsaWdubWVudEJhc2VsaW5lOiB1cGRhdGVUcmlnZ2Vycy5nZXRBbGlnbm1lbnRCYXNlbGluZSxcbiAgICAgICAgICBzdHlsZVZlcnNpb25cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pLCB7XG4gICAgICBkYXRhLFxuICAgICAgX2RhdGFEaWZmLFxuICAgICAgc3RhcnRJbmRpY2VzLFxuICAgICAgbnVtSW5zdGFuY2VzLFxuICAgICAgZ2V0SWNvbk9mZnNldHM6IHRoaXMuZ2V0SWNvbk9mZnNldHMsXG4gICAgICBnZXRJY29uOiBnZXRUZXh0XG4gICAgfSldO1xuICB9XG5cbiAgc3RhdGljIHNldCBmb250QXRsYXNDYWNoZUxpbWl0KGxpbWl0KSB7XG4gICAgc2V0Rm9udEF0bGFzQ2FjaGVMaW1pdChsaW1pdCk7XG4gIH1cblxufVxuXG5fZGVmaW5lUHJvcGVydHkoVGV4dExheWVyLCBcImRlZmF1bHRQcm9wc1wiLCBkZWZhdWx0UHJvcHMpO1xuXG5fZGVmaW5lUHJvcGVydHkoVGV4dExheWVyLCBcImxheWVyTmFtZVwiLCAnVGV4dExheWVyJyk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD10ZXh0LWxheWVyLmpzLm1hcCIsImltcG9ydCBJY29uTGF5ZXIgZnJvbSAnLi4vaWNvbi1sYXllci9pY29uLWxheWVyJztcbmltcG9ydCBTY2F0dGVycGxvdExheWVyIGZyb20gJy4uL3NjYXR0ZXJwbG90LWxheWVyL3NjYXR0ZXJwbG90LWxheWVyJztcbmltcG9ydCBUZXh0TGF5ZXIgZnJvbSAnLi4vdGV4dC1sYXllci90ZXh0LWxheWVyJztcbmltcG9ydCBQYXRoTGF5ZXIgZnJvbSAnLi4vcGF0aC1sYXllci9wYXRoLWxheWVyJztcbmltcG9ydCBTb2xpZFBvbHlnb25MYXllciBmcm9tICcuLi9zb2xpZC1wb2x5Z29uLWxheWVyL3NvbGlkLXBvbHlnb24tbGF5ZXInO1xuZXhwb3J0IGNvbnN0IFBPSU5UX0xBWUVSID0ge1xuICBjaXJjbGU6IHtcbiAgICB0eXBlOiBTY2F0dGVycGxvdExheWVyLFxuICAgIHByb3BzOiB7XG4gICAgICBmaWxsZWQ6ICdmaWxsZWQnLFxuICAgICAgc3Ryb2tlZDogJ3N0cm9rZWQnLFxuICAgICAgbGluZVdpZHRoTWF4UGl4ZWxzOiAnbGluZVdpZHRoTWF4UGl4ZWxzJyxcbiAgICAgIGxpbmVXaWR0aE1pblBpeGVsczogJ2xpbmVXaWR0aE1pblBpeGVscycsXG4gICAgICBsaW5lV2lkdGhTY2FsZTogJ2xpbmVXaWR0aFNjYWxlJyxcbiAgICAgIGxpbmVXaWR0aFVuaXRzOiAnbGluZVdpZHRoVW5pdHMnLFxuICAgICAgcG9pbnRSYWRpdXNNYXhQaXhlbHM6ICdyYWRpdXNNYXhQaXhlbHMnLFxuICAgICAgcG9pbnRSYWRpdXNNaW5QaXhlbHM6ICdyYWRpdXNNaW5QaXhlbHMnLFxuICAgICAgcG9pbnRSYWRpdXNTY2FsZTogJ3JhZGl1c1NjYWxlJyxcbiAgICAgIHBvaW50UmFkaXVzVW5pdHM6ICdyYWRpdXNVbml0cycsXG4gICAgICBwb2ludEFudGlhbGlhc2luZzogJ2FudGlhbGlhc2luZycsXG4gICAgICBwb2ludEJpbGxib2FyZDogJ2JpbGxib2FyZCcsXG4gICAgICBnZXRGaWxsQ29sb3I6ICdnZXRGaWxsQ29sb3InLFxuICAgICAgZ2V0TGluZUNvbG9yOiAnZ2V0TGluZUNvbG9yJyxcbiAgICAgIGdldExpbmVXaWR0aDogJ2dldExpbmVXaWR0aCcsXG4gICAgICBnZXRQb2ludFJhZGl1czogJ2dldFJhZGl1cydcbiAgICB9XG4gIH0sXG4gIGljb246IHtcbiAgICB0eXBlOiBJY29uTGF5ZXIsXG4gICAgcHJvcHM6IHtcbiAgICAgIGljb25BdGxhczogJ2ljb25BdGxhcycsXG4gICAgICBpY29uTWFwcGluZzogJ2ljb25NYXBwaW5nJyxcbiAgICAgIGljb25TaXplTWF4UGl4ZWxzOiAnc2l6ZU1heFBpeGVscycsXG4gICAgICBpY29uU2l6ZU1pblBpeGVsczogJ3NpemVNaW5QaXhlbHMnLFxuICAgICAgaWNvblNpemVTY2FsZTogJ3NpemVTY2FsZScsXG4gICAgICBpY29uU2l6ZVVuaXRzOiAnc2l6ZVVuaXRzJyxcbiAgICAgIGljb25BbHBoYUN1dG9mZjogJ2FscGhhQ3V0b2ZmJyxcbiAgICAgIGljb25CaWxsYm9hcmQ6ICdiaWxsYm9hcmQnLFxuICAgICAgZ2V0SWNvbjogJ2dldEljb24nLFxuICAgICAgZ2V0SWNvbkFuZ2xlOiAnZ2V0QW5nbGUnLFxuICAgICAgZ2V0SWNvbkNvbG9yOiAnZ2V0Q29sb3InLFxuICAgICAgZ2V0SWNvblBpeGVsT2Zmc2V0OiAnZ2V0UGl4ZWxPZmZzZXQnLFxuICAgICAgZ2V0SWNvblNpemU6ICdnZXRTaXplJ1xuICAgIH1cbiAgfSxcbiAgdGV4dDoge1xuICAgIHR5cGU6IFRleHRMYXllcixcbiAgICBwcm9wczoge1xuICAgICAgdGV4dFNpemVNYXhQaXhlbHM6ICdzaXplTWF4UGl4ZWxzJyxcbiAgICAgIHRleHRTaXplTWluUGl4ZWxzOiAnc2l6ZU1pblBpeGVscycsXG4gICAgICB0ZXh0U2l6ZVNjYWxlOiAnc2l6ZVNjYWxlJyxcbiAgICAgIHRleHRTaXplVW5pdHM6ICdzaXplVW5pdHMnLFxuICAgICAgdGV4dEJhY2tncm91bmQ6ICdiYWNrZ3JvdW5kJyxcbiAgICAgIHRleHRCYWNrZ3JvdW5kUGFkZGluZzogJ2JhY2tncm91bmRQYWRkaW5nJyxcbiAgICAgIHRleHRGb250RmFtaWx5OiAnZm9udEZhbWlseScsXG4gICAgICB0ZXh0Rm9udFdlaWdodDogJ2ZvbnRXZWlnaHQnLFxuICAgICAgdGV4dExpbmVIZWlnaHQ6ICdsaW5lSGVpZ2h0JyxcbiAgICAgIHRleHRNYXhXaWR0aDogJ21heFdpZHRoJyxcbiAgICAgIHRleHRPdXRsaW5lQ29sb3I6ICdvdXRsaW5lQ29sb3InLFxuICAgICAgdGV4dE91dGxpbmVXaWR0aDogJ291dGxpbmVXaWR0aCcsXG4gICAgICB0ZXh0V29yZEJyZWFrOiAnd29yZEJyZWFrJyxcbiAgICAgIHRleHRDaGFyYWN0ZXJTZXQ6ICdjaGFyYWN0ZXJTZXQnLFxuICAgICAgdGV4dEJpbGxib2FyZDogJ2JpbGxib2FyZCcsXG4gICAgICB0ZXh0Rm9udFNldHRpbmdzOiAnZm9udFNldHRpbmdzJyxcbiAgICAgIGdldFRleHQ6ICdnZXRUZXh0JyxcbiAgICAgIGdldFRleHRBbmdsZTogJ2dldEFuZ2xlJyxcbiAgICAgIGdldFRleHRDb2xvcjogJ2dldENvbG9yJyxcbiAgICAgIGdldFRleHRQaXhlbE9mZnNldDogJ2dldFBpeGVsT2Zmc2V0JyxcbiAgICAgIGdldFRleHRTaXplOiAnZ2V0U2l6ZScsXG4gICAgICBnZXRUZXh0QW5jaG9yOiAnZ2V0VGV4dEFuY2hvcicsXG4gICAgICBnZXRUZXh0QWxpZ25tZW50QmFzZWxpbmU6ICdnZXRBbGlnbm1lbnRCYXNlbGluZScsXG4gICAgICBnZXRUZXh0QmFja2dyb3VuZENvbG9yOiAnZ2V0QmFja2dyb3VuZENvbG9yJyxcbiAgICAgIGdldFRleHRCb3JkZXJDb2xvcjogJ2dldEJvcmRlckNvbG9yJyxcbiAgICAgIGdldFRleHRCb3JkZXJXaWR0aDogJ2dldEJvcmRlcldpZHRoJ1xuICAgIH1cbiAgfVxufTtcbmV4cG9ydCBjb25zdCBMSU5FX0xBWUVSID0ge1xuICB0eXBlOiBQYXRoTGF5ZXIsXG4gIHByb3BzOiB7XG4gICAgbGluZVdpZHRoVW5pdHM6ICd3aWR0aFVuaXRzJyxcbiAgICBsaW5lV2lkdGhTY2FsZTogJ3dpZHRoU2NhbGUnLFxuICAgIGxpbmVXaWR0aE1pblBpeGVsczogJ3dpZHRoTWluUGl4ZWxzJyxcbiAgICBsaW5lV2lkdGhNYXhQaXhlbHM6ICd3aWR0aE1heFBpeGVscycsXG4gICAgbGluZUpvaW50Um91bmRlZDogJ2pvaW50Um91bmRlZCcsXG4gICAgbGluZUNhcFJvdW5kZWQ6ICdjYXBSb3VuZGVkJyxcbiAgICBsaW5lTWl0ZXJMaW1pdDogJ21pdGVyTGltaXQnLFxuICAgIGxpbmVCaWxsYm9hcmQ6ICdiaWxsYm9hcmQnLFxuICAgIGdldExpbmVDb2xvcjogJ2dldENvbG9yJyxcbiAgICBnZXRMaW5lV2lkdGg6ICdnZXRXaWR0aCdcbiAgfVxufTtcbmV4cG9ydCBjb25zdCBQT0xZR09OX0xBWUVSID0ge1xuICB0eXBlOiBTb2xpZFBvbHlnb25MYXllcixcbiAgcHJvcHM6IHtcbiAgICBleHRydWRlZDogJ2V4dHJ1ZGVkJyxcbiAgICBmaWxsZWQ6ICdmaWxsZWQnLFxuICAgIHdpcmVmcmFtZTogJ3dpcmVmcmFtZScsXG4gICAgZWxldmF0aW9uU2NhbGU6ICdlbGV2YXRpb25TY2FsZScsXG4gICAgbWF0ZXJpYWw6ICdtYXRlcmlhbCcsXG4gICAgX2Z1bGwzZDogJ19mdWxsM2QnLFxuICAgIGdldEVsZXZhdGlvbjogJ2dldEVsZXZhdGlvbicsXG4gICAgZ2V0RmlsbENvbG9yOiAnZ2V0RmlsbENvbG9yJyxcbiAgICBnZXRMaW5lQ29sb3I6ICdnZXRMaW5lQ29sb3InXG4gIH1cbn07XG5leHBvcnQgZnVuY3Rpb24gZ2V0RGVmYXVsdFByb3BzKHtcbiAgdHlwZSxcbiAgcHJvcHNcbn0pIHtcbiAgY29uc3QgcmVzdWx0ID0ge307XG5cbiAgZm9yIChjb25zdCBrZXkgaW4gcHJvcHMpIHtcbiAgICByZXN1bHRba2V5XSA9IHR5cGUuZGVmYXVsdFByb3BzW3Byb3BzW2tleV1dO1xuICB9XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn1cbmV4cG9ydCBmdW5jdGlvbiBmb3J3YXJkUHJvcHMobGF5ZXIsIG1hcHBpbmcpIHtcbiAgY29uc3Qge1xuICAgIHRyYW5zaXRpb25zLFxuICAgIHVwZGF0ZVRyaWdnZXJzXG4gIH0gPSBsYXllci5wcm9wcztcbiAgY29uc3QgcmVzdWx0ID0ge1xuICAgIHVwZGF0ZVRyaWdnZXJzOiB7fSxcbiAgICB0cmFuc2l0aW9uczogdHJhbnNpdGlvbnMgJiYge1xuICAgICAgZ2V0UG9zaXRpb246IHRyYW5zaXRpb25zLmdlb21ldHJ5XG4gICAgfVxuICB9O1xuXG4gIGZvciAoY29uc3Qgc291cmNlS2V5IGluIG1hcHBpbmcpIHtcbiAgICBjb25zdCB0YXJnZXRLZXkgPSBtYXBwaW5nW3NvdXJjZUtleV07XG4gICAgbGV0IHZhbHVlID0gbGF5ZXIucHJvcHNbc291cmNlS2V5XTtcblxuICAgIGlmIChzb3VyY2VLZXkuc3RhcnRzV2l0aCgnZ2V0JykpIHtcbiAgICAgIHZhbHVlID0gbGF5ZXIuZ2V0U3ViTGF5ZXJBY2Nlc3Nvcih2YWx1ZSk7XG4gICAgICByZXN1bHQudXBkYXRlVHJpZ2dlcnNbdGFyZ2V0S2V5XSA9IHVwZGF0ZVRyaWdnZXJzW3NvdXJjZUtleV07XG5cbiAgICAgIGlmICh0cmFuc2l0aW9ucykge1xuICAgICAgICByZXN1bHQudHJhbnNpdGlvbnNbdGFyZ2V0S2V5XSA9IHRyYW5zaXRpb25zW3NvdXJjZUtleV07XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmVzdWx0W3RhcmdldEtleV0gPSB2YWx1ZTtcbiAgfVxuXG4gIHJldHVybiByZXN1bHQ7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zdWItbGF5ZXItbWFwLmpzLm1hcCIsImltcG9ydCB7IGxvZyB9IGZyb20gJ0BkZWNrLmdsL2NvcmUnO1xuZXhwb3J0IGZ1bmN0aW9uIGdldEdlb2pzb25GZWF0dXJlcyhnZW9qc29uKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KGdlb2pzb24pKSB7XG4gICAgcmV0dXJuIGdlb2pzb247XG4gIH1cblxuICBsb2cuYXNzZXJ0KGdlb2pzb24udHlwZSwgJ0dlb0pTT04gZG9lcyBub3QgaGF2ZSB0eXBlJyk7XG5cbiAgc3dpdGNoIChnZW9qc29uLnR5cGUpIHtcbiAgICBjYXNlICdGZWF0dXJlJzpcbiAgICAgIHJldHVybiBbZ2VvanNvbl07XG5cbiAgICBjYXNlICdGZWF0dXJlQ29sbGVjdGlvbic6XG4gICAgICBsb2cuYXNzZXJ0KEFycmF5LmlzQXJyYXkoZ2VvanNvbi5mZWF0dXJlcyksICdHZW9KU09OIGRvZXMgbm90IGhhdmUgZmVhdHVyZXMgYXJyYXknKTtcbiAgICAgIHJldHVybiBnZW9qc29uLmZlYXR1cmVzO1xuXG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBbe1xuICAgICAgICBnZW9tZXRyeTogZ2VvanNvblxuICAgICAgfV07XG4gIH1cbn1cbmV4cG9ydCBmdW5jdGlvbiBzZXBhcmF0ZUdlb2pzb25GZWF0dXJlcyhmZWF0dXJlcywgd3JhcEZlYXR1cmUsIGRhdGFSYW5nZSA9IHt9KSB7XG4gIGNvbnN0IHNlcGFyYXRlZCA9IHtcbiAgICBwb2ludEZlYXR1cmVzOiBbXSxcbiAgICBsaW5lRmVhdHVyZXM6IFtdLFxuICAgIHBvbHlnb25GZWF0dXJlczogW10sXG4gICAgcG9seWdvbk91dGxpbmVGZWF0dXJlczogW11cbiAgfTtcbiAgY29uc3Qge1xuICAgIHN0YXJ0Um93ID0gMCxcbiAgICBlbmRSb3cgPSBmZWF0dXJlcy5sZW5ndGhcbiAgfSA9IGRhdGFSYW5nZTtcblxuICBmb3IgKGxldCBmZWF0dXJlSW5kZXggPSBzdGFydFJvdzsgZmVhdHVyZUluZGV4IDwgZW5kUm93OyBmZWF0dXJlSW5kZXgrKykge1xuICAgIGNvbnN0IGZlYXR1cmUgPSBmZWF0dXJlc1tmZWF0dXJlSW5kZXhdO1xuICAgIGNvbnN0IHtcbiAgICAgIGdlb21ldHJ5XG4gICAgfSA9IGZlYXR1cmU7XG5cbiAgICBpZiAoIWdlb21ldHJ5KSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICBpZiAoZ2VvbWV0cnkudHlwZSA9PT0gJ0dlb21ldHJ5Q29sbGVjdGlvbicpIHtcbiAgICAgIGxvZy5hc3NlcnQoQXJyYXkuaXNBcnJheShnZW9tZXRyeS5nZW9tZXRyaWVzKSwgJ0dlb0pTT04gZG9lcyBub3QgaGF2ZSBnZW9tZXRyaWVzIGFycmF5Jyk7XG4gICAgICBjb25zdCB7XG4gICAgICAgIGdlb21ldHJpZXNcbiAgICAgIH0gPSBnZW9tZXRyeTtcblxuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBnZW9tZXRyaWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IHN1Ykdlb21ldHJ5ID0gZ2VvbWV0cmllc1tpXTtcbiAgICAgICAgc2VwYXJhdGVHZW9tZXRyeShzdWJHZW9tZXRyeSwgc2VwYXJhdGVkLCB3cmFwRmVhdHVyZSwgZmVhdHVyZSwgZmVhdHVyZUluZGV4KTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgc2VwYXJhdGVHZW9tZXRyeShnZW9tZXRyeSwgc2VwYXJhdGVkLCB3cmFwRmVhdHVyZSwgZmVhdHVyZSwgZmVhdHVyZUluZGV4KTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gc2VwYXJhdGVkO1xufVxuXG5mdW5jdGlvbiBzZXBhcmF0ZUdlb21ldHJ5KGdlb21ldHJ5LCBzZXBhcmF0ZWQsIHdyYXBGZWF0dXJlLCBzb3VyY2VGZWF0dXJlLCBzb3VyY2VGZWF0dXJlSW5kZXgpIHtcbiAgY29uc3Qge1xuICAgIHR5cGUsXG4gICAgY29vcmRpbmF0ZXNcbiAgfSA9IGdlb21ldHJ5O1xuICBjb25zdCB7XG4gICAgcG9pbnRGZWF0dXJlcyxcbiAgICBsaW5lRmVhdHVyZXMsXG4gICAgcG9seWdvbkZlYXR1cmVzLFxuICAgIHBvbHlnb25PdXRsaW5lRmVhdHVyZXNcbiAgfSA9IHNlcGFyYXRlZDtcblxuICBpZiAoIXZhbGlkYXRlR2VvbWV0cnkodHlwZSwgY29vcmRpbmF0ZXMpKSB7XG4gICAgbG9nLndhcm4oXCJcIi5jb25jYXQodHlwZSwgXCIgY29vcmRpbmF0ZXMgYXJlIG1hbGZvcm1lZFwiKSkoKTtcbiAgICByZXR1cm47XG4gIH1cblxuICBzd2l0Y2ggKHR5cGUpIHtcbiAgICBjYXNlICdQb2ludCc6XG4gICAgICBwb2ludEZlYXR1cmVzLnB1c2god3JhcEZlYXR1cmUoe1xuICAgICAgICBnZW9tZXRyeVxuICAgICAgfSwgc291cmNlRmVhdHVyZSwgc291cmNlRmVhdHVyZUluZGV4KSk7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgJ011bHRpUG9pbnQnOlxuICAgICAgY29vcmRpbmF0ZXMuZm9yRWFjaChwb2ludCA9PiB7XG4gICAgICAgIHBvaW50RmVhdHVyZXMucHVzaCh3cmFwRmVhdHVyZSh7XG4gICAgICAgICAgZ2VvbWV0cnk6IHtcbiAgICAgICAgICAgIHR5cGU6ICdQb2ludCcsXG4gICAgICAgICAgICBjb29yZGluYXRlczogcG9pbnRcbiAgICAgICAgICB9XG4gICAgICAgIH0sIHNvdXJjZUZlYXR1cmUsIHNvdXJjZUZlYXR1cmVJbmRleCkpO1xuICAgICAgfSk7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgJ0xpbmVTdHJpbmcnOlxuICAgICAgbGluZUZlYXR1cmVzLnB1c2god3JhcEZlYXR1cmUoe1xuICAgICAgICBnZW9tZXRyeVxuICAgICAgfSwgc291cmNlRmVhdHVyZSwgc291cmNlRmVhdHVyZUluZGV4KSk7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgJ011bHRpTGluZVN0cmluZyc6XG4gICAgICBjb29yZGluYXRlcy5mb3JFYWNoKHBhdGggPT4ge1xuICAgICAgICBsaW5lRmVhdHVyZXMucHVzaCh3cmFwRmVhdHVyZSh7XG4gICAgICAgICAgZ2VvbWV0cnk6IHtcbiAgICAgICAgICAgIHR5cGU6ICdMaW5lU3RyaW5nJyxcbiAgICAgICAgICAgIGNvb3JkaW5hdGVzOiBwYXRoXG4gICAgICAgICAgfVxuICAgICAgICB9LCBzb3VyY2VGZWF0dXJlLCBzb3VyY2VGZWF0dXJlSW5kZXgpKTtcbiAgICAgIH0pO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlICdQb2x5Z29uJzpcbiAgICAgIHBvbHlnb25GZWF0dXJlcy5wdXNoKHdyYXBGZWF0dXJlKHtcbiAgICAgICAgZ2VvbWV0cnlcbiAgICAgIH0sIHNvdXJjZUZlYXR1cmUsIHNvdXJjZUZlYXR1cmVJbmRleCkpO1xuICAgICAgY29vcmRpbmF0ZXMuZm9yRWFjaChwYXRoID0+IHtcbiAgICAgICAgcG9seWdvbk91dGxpbmVGZWF0dXJlcy5wdXNoKHdyYXBGZWF0dXJlKHtcbiAgICAgICAgICBnZW9tZXRyeToge1xuICAgICAgICAgICAgdHlwZTogJ0xpbmVTdHJpbmcnLFxuICAgICAgICAgICAgY29vcmRpbmF0ZXM6IHBhdGhcbiAgICAgICAgICB9XG4gICAgICAgIH0sIHNvdXJjZUZlYXR1cmUsIHNvdXJjZUZlYXR1cmVJbmRleCkpO1xuICAgICAgfSk7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgJ011bHRpUG9seWdvbic6XG4gICAgICBjb29yZGluYXRlcy5mb3JFYWNoKHBvbHlnb24gPT4ge1xuICAgICAgICBwb2x5Z29uRmVhdHVyZXMucHVzaCh3cmFwRmVhdHVyZSh7XG4gICAgICAgICAgZ2VvbWV0cnk6IHtcbiAgICAgICAgICAgIHR5cGU6ICdQb2x5Z29uJyxcbiAgICAgICAgICAgIGNvb3JkaW5hdGVzOiBwb2x5Z29uXG4gICAgICAgICAgfVxuICAgICAgICB9LCBzb3VyY2VGZWF0dXJlLCBzb3VyY2VGZWF0dXJlSW5kZXgpKTtcbiAgICAgICAgcG9seWdvbi5mb3JFYWNoKHBhdGggPT4ge1xuICAgICAgICAgIHBvbHlnb25PdXRsaW5lRmVhdHVyZXMucHVzaCh3cmFwRmVhdHVyZSh7XG4gICAgICAgICAgICBnZW9tZXRyeToge1xuICAgICAgICAgICAgICB0eXBlOiAnTGluZVN0cmluZycsXG4gICAgICAgICAgICAgIGNvb3JkaW5hdGVzOiBwYXRoXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSwgc291cmNlRmVhdHVyZSwgc291cmNlRmVhdHVyZUluZGV4KSk7XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgICBicmVhaztcblxuICAgIGRlZmF1bHQ6XG4gIH1cbn1cblxuY29uc3QgQ09PUkRJTkFURV9ORVNUX0xFVkVMID0ge1xuICBQb2ludDogMSxcbiAgTXVsdGlQb2ludDogMixcbiAgTGluZVN0cmluZzogMixcbiAgTXVsdGlMaW5lU3RyaW5nOiAzLFxuICBQb2x5Z29uOiAzLFxuICBNdWx0aVBvbHlnb246IDRcbn07XG5leHBvcnQgZnVuY3Rpb24gdmFsaWRhdGVHZW9tZXRyeSh0eXBlLCBjb29yZGluYXRlcykge1xuICBsZXQgbmVzdExldmVsID0gQ09PUkRJTkFURV9ORVNUX0xFVkVMW3R5cGVdO1xuICBsb2cuYXNzZXJ0KG5lc3RMZXZlbCwgXCJVbmtub3duIEdlb0pTT04gdHlwZSBcIi5jb25jYXQodHlwZSkpO1xuXG4gIHdoaWxlIChjb29yZGluYXRlcyAmJiAtLW5lc3RMZXZlbCA+IDApIHtcbiAgICBjb29yZGluYXRlcyA9IGNvb3JkaW5hdGVzWzBdO1xuICB9XG5cbiAgcmV0dXJuIGNvb3JkaW5hdGVzICYmIE51bWJlci5pc0Zpbml0ZShjb29yZGluYXRlc1swXSk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1nZW9qc29uLmpzLm1hcCIsImltcG9ydCB7IGNhbGN1bGF0ZVBpY2tpbmdDb2xvcnMgfSBmcm9tICcuL2dlb2pzb24tYmluYXJ5JztcblxuZnVuY3Rpb24gY3JlYXRlRW1wdHlMYXllclByb3BzKCkge1xuICByZXR1cm4ge1xuICAgIHBvaW50czoge30sXG4gICAgbGluZXM6IHt9LFxuICAgIHBvbHlnb25zOiB7fSxcbiAgICBwb2x5Z29uc091dGxpbmU6IHt9XG4gIH07XG59XG5cbmZ1bmN0aW9uIGdldENvb3JkaW5hdGVzKGYpIHtcbiAgcmV0dXJuIGYuZ2VvbWV0cnkuY29vcmRpbmF0ZXM7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVMYXllclByb3BzRnJvbUZlYXR1cmVzKGZlYXR1cmVzLCBmZWF0dXJlc0RpZmYpIHtcbiAgY29uc3QgbGF5ZXJQcm9wcyA9IGNyZWF0ZUVtcHR5TGF5ZXJQcm9wcygpO1xuICBjb25zdCB7XG4gICAgcG9pbnRGZWF0dXJlcyxcbiAgICBsaW5lRmVhdHVyZXMsXG4gICAgcG9seWdvbkZlYXR1cmVzLFxuICAgIHBvbHlnb25PdXRsaW5lRmVhdHVyZXNcbiAgfSA9IGZlYXR1cmVzO1xuICBsYXllclByb3BzLnBvaW50cy5kYXRhID0gcG9pbnRGZWF0dXJlcztcblxuICBsYXllclByb3BzLnBvaW50cy5fZGF0YURpZmYgPSBmZWF0dXJlc0RpZmYucG9pbnRGZWF0dXJlcyAmJiAoKCkgPT4gZmVhdHVyZXNEaWZmLnBvaW50RmVhdHVyZXMpO1xuXG4gIGxheWVyUHJvcHMucG9pbnRzLmdldFBvc2l0aW9uID0gZ2V0Q29vcmRpbmF0ZXM7XG4gIGxheWVyUHJvcHMubGluZXMuZGF0YSA9IGxpbmVGZWF0dXJlcztcblxuICBsYXllclByb3BzLmxpbmVzLl9kYXRhRGlmZiA9IGZlYXR1cmVzRGlmZi5saW5lRmVhdHVyZXMgJiYgKCgpID0+IGZlYXR1cmVzRGlmZi5saW5lRmVhdHVyZXMpO1xuXG4gIGxheWVyUHJvcHMubGluZXMuZ2V0UGF0aCA9IGdldENvb3JkaW5hdGVzO1xuICBsYXllclByb3BzLnBvbHlnb25zLmRhdGEgPSBwb2x5Z29uRmVhdHVyZXM7XG5cbiAgbGF5ZXJQcm9wcy5wb2x5Z29ucy5fZGF0YURpZmYgPSBmZWF0dXJlc0RpZmYucG9seWdvbkZlYXR1cmVzICYmICgoKSA9PiBmZWF0dXJlc0RpZmYucG9seWdvbkZlYXR1cmVzKTtcblxuICBsYXllclByb3BzLnBvbHlnb25zLmdldFBvbHlnb24gPSBnZXRDb29yZGluYXRlcztcbiAgbGF5ZXJQcm9wcy5wb2x5Z29uc091dGxpbmUuZGF0YSA9IHBvbHlnb25PdXRsaW5lRmVhdHVyZXM7XG5cbiAgbGF5ZXJQcm9wcy5wb2x5Z29uc091dGxpbmUuX2RhdGFEaWZmID0gZmVhdHVyZXNEaWZmLnBvbHlnb25PdXRsaW5lRmVhdHVyZXMgJiYgKCgpID0+IGZlYXR1cmVzRGlmZi5wb2x5Z29uT3V0bGluZUZlYXR1cmVzKTtcblxuICBsYXllclByb3BzLnBvbHlnb25zT3V0bGluZS5nZXRQYXRoID0gZ2V0Q29vcmRpbmF0ZXM7XG4gIHJldHVybiBsYXllclByb3BzO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZUxheWVyUHJvcHNGcm9tQmluYXJ5KGdlb2pzb25CaW5hcnksIGVuY29kZVBpY2tpbmdDb2xvcikge1xuICBjb25zdCBsYXllclByb3BzID0gY3JlYXRlRW1wdHlMYXllclByb3BzKCk7XG4gIGNvbnN0IHtcbiAgICBwb2ludHMsXG4gICAgbGluZXMsXG4gICAgcG9seWdvbnNcbiAgfSA9IGdlb2pzb25CaW5hcnk7XG4gIGNvbnN0IGN1c3RvbVBpY2tpbmdDb2xvcnMgPSBjYWxjdWxhdGVQaWNraW5nQ29sb3JzKGdlb2pzb25CaW5hcnksIGVuY29kZVBpY2tpbmdDb2xvcik7XG4gIGxheWVyUHJvcHMucG9pbnRzLmRhdGEgPSB7XG4gICAgbGVuZ3RoOiBwb2ludHMucG9zaXRpb25zLnZhbHVlLmxlbmd0aCAvIHBvaW50cy5wb3NpdGlvbnMuc2l6ZSxcbiAgICBhdHRyaWJ1dGVzOiB7IC4uLnBvaW50cy5hdHRyaWJ1dGVzLFxuICAgICAgZ2V0UG9zaXRpb246IHBvaW50cy5wb3NpdGlvbnMsXG4gICAgICBpbnN0YW5jZVBpY2tpbmdDb2xvcnM6IHtcbiAgICAgICAgc2l6ZTogMyxcbiAgICAgICAgdmFsdWU6IGN1c3RvbVBpY2tpbmdDb2xvcnMucG9pbnRzXG4gICAgICB9XG4gICAgfSxcbiAgICBwcm9wZXJ0aWVzOiBwb2ludHMucHJvcGVydGllcyxcbiAgICBudW1lcmljUHJvcHM6IHBvaW50cy5udW1lcmljUHJvcHMsXG4gICAgZmVhdHVyZUlkczogcG9pbnRzLmZlYXR1cmVJZHNcbiAgfTtcbiAgbGF5ZXJQcm9wcy5saW5lcy5kYXRhID0ge1xuICAgIGxlbmd0aDogbGluZXMucGF0aEluZGljZXMudmFsdWUubGVuZ3RoIC0gMSxcbiAgICBzdGFydEluZGljZXM6IGxpbmVzLnBhdGhJbmRpY2VzLnZhbHVlLFxuICAgIGF0dHJpYnV0ZXM6IHsgLi4ubGluZXMuYXR0cmlidXRlcyxcbiAgICAgIGdldFBhdGg6IGxpbmVzLnBvc2l0aW9ucyxcbiAgICAgIGluc3RhbmNlUGlja2luZ0NvbG9yczoge1xuICAgICAgICBzaXplOiAzLFxuICAgICAgICB2YWx1ZTogY3VzdG9tUGlja2luZ0NvbG9ycy5saW5lc1xuICAgICAgfVxuICAgIH0sXG4gICAgcHJvcGVydGllczogbGluZXMucHJvcGVydGllcyxcbiAgICBudW1lcmljUHJvcHM6IGxpbmVzLm51bWVyaWNQcm9wcyxcbiAgICBmZWF0dXJlSWRzOiBsaW5lcy5mZWF0dXJlSWRzXG4gIH07XG4gIGxheWVyUHJvcHMubGluZXMuX3BhdGhUeXBlID0gJ29wZW4nO1xuICBsYXllclByb3BzLnBvbHlnb25zLmRhdGEgPSB7XG4gICAgbGVuZ3RoOiBwb2x5Z29ucy5wb2x5Z29uSW5kaWNlcy52YWx1ZS5sZW5ndGggLSAxLFxuICAgIHN0YXJ0SW5kaWNlczogcG9seWdvbnMucG9seWdvbkluZGljZXMudmFsdWUsXG4gICAgYXR0cmlidXRlczogeyAuLi5wb2x5Z29ucy5hdHRyaWJ1dGVzLFxuICAgICAgZ2V0UG9seWdvbjogcG9seWdvbnMucG9zaXRpb25zLFxuICAgICAgcGlja2luZ0NvbG9yczoge1xuICAgICAgICBzaXplOiAzLFxuICAgICAgICB2YWx1ZTogY3VzdG9tUGlja2luZ0NvbG9ycy5wb2x5Z29uc1xuICAgICAgfVxuICAgIH0sXG4gICAgcHJvcGVydGllczogcG9seWdvbnMucHJvcGVydGllcyxcbiAgICBudW1lcmljUHJvcHM6IHBvbHlnb25zLm51bWVyaWNQcm9wcyxcbiAgICBmZWF0dXJlSWRzOiBwb2x5Z29ucy5mZWF0dXJlSWRzXG4gIH07XG4gIGxheWVyUHJvcHMucG9seWdvbnMuX25vcm1hbGl6ZSA9IGZhbHNlO1xuXG4gIGlmIChwb2x5Z29ucy50cmlhbmdsZXMpIHtcbiAgICBsYXllclByb3BzLnBvbHlnb25zLmRhdGEuYXR0cmlidXRlcy5pbmRpY2VzID0gcG9seWdvbnMudHJpYW5nbGVzLnZhbHVlO1xuICB9XG5cbiAgbGF5ZXJQcm9wcy5wb2x5Z29uc091dGxpbmUuZGF0YSA9IHtcbiAgICBsZW5ndGg6IHBvbHlnb25zLnByaW1pdGl2ZVBvbHlnb25JbmRpY2VzLnZhbHVlLmxlbmd0aCAtIDEsXG4gICAgc3RhcnRJbmRpY2VzOiBwb2x5Z29ucy5wcmltaXRpdmVQb2x5Z29uSW5kaWNlcy52YWx1ZSxcbiAgICBhdHRyaWJ1dGVzOiB7IC4uLnBvbHlnb25zLmF0dHJpYnV0ZXMsXG4gICAgICBnZXRQYXRoOiBwb2x5Z29ucy5wb3NpdGlvbnMsXG4gICAgICBpbnN0YW5jZVBpY2tpbmdDb2xvcnM6IHtcbiAgICAgICAgc2l6ZTogMyxcbiAgICAgICAgdmFsdWU6IGN1c3RvbVBpY2tpbmdDb2xvcnMucG9seWdvbnNcbiAgICAgIH1cbiAgICB9LFxuICAgIHByb3BlcnRpZXM6IHBvbHlnb25zLnByb3BlcnRpZXMsXG4gICAgbnVtZXJpY1Byb3BzOiBwb2x5Z29ucy5udW1lcmljUHJvcHMsXG4gICAgZmVhdHVyZUlkczogcG9seWdvbnMuZmVhdHVyZUlkc1xuICB9O1xuICBsYXllclByb3BzLnBvbHlnb25zT3V0bGluZS5fcGF0aFR5cGUgPSAnb3Blbic7XG4gIHJldHVybiBsYXllclByb3BzO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Z2VvanNvbi1sYXllci1wcm9wcy5qcy5tYXAiLCJpbXBvcnQgX2RlZmluZVByb3BlcnR5IGZyb20gXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9kZWZpbmVQcm9wZXJ0eVwiO1xuaW1wb3J0IHsgQ29tcG9zaXRlTGF5ZXIgfSBmcm9tICdAZGVjay5nbC9jb3JlJztcbmltcG9ydCB7IHJlcGxhY2VJblJhbmdlIH0gZnJvbSAnLi4vdXRpbHMnO1xuaW1wb3J0IHsgYmluYXJ5VG9GZWF0dXJlRm9yQWNjZXNvciB9IGZyb20gJy4vZ2VvanNvbi1iaW5hcnknO1xuaW1wb3J0IHsgUE9JTlRfTEFZRVIsIExJTkVfTEFZRVIsIFBPTFlHT05fTEFZRVIsIGdldERlZmF1bHRQcm9wcywgZm9yd2FyZFByb3BzIH0gZnJvbSAnLi9zdWItbGF5ZXItbWFwJztcbmltcG9ydCB7IGdldEdlb2pzb25GZWF0dXJlcywgc2VwYXJhdGVHZW9qc29uRmVhdHVyZXMgfSBmcm9tICcuL2dlb2pzb24nO1xuaW1wb3J0IHsgY3JlYXRlTGF5ZXJQcm9wc0Zyb21GZWF0dXJlcywgY3JlYXRlTGF5ZXJQcm9wc0Zyb21CaW5hcnkgfSBmcm9tICcuL2dlb2pzb24tbGF5ZXItcHJvcHMnO1xuY29uc3QgRkVBVFVSRV9UWVBFUyA9IFsncG9pbnRzJywgJ2xpbmVzdHJpbmdzJywgJ3BvbHlnb25zJ107XG5jb25zdCBkZWZhdWx0UHJvcHMgPSB7IC4uLmdldERlZmF1bHRQcm9wcyhQT0lOVF9MQVlFUi5jaXJjbGUpLFxuICAuLi5nZXREZWZhdWx0UHJvcHMoUE9JTlRfTEFZRVIuaWNvbiksXG4gIC4uLmdldERlZmF1bHRQcm9wcyhQT0lOVF9MQVlFUi50ZXh0KSxcbiAgLi4uZ2V0RGVmYXVsdFByb3BzKExJTkVfTEFZRVIpLFxuICAuLi5nZXREZWZhdWx0UHJvcHMoUE9MWUdPTl9MQVlFUiksXG4gIHN0cm9rZWQ6IHRydWUsXG4gIGZpbGxlZDogdHJ1ZSxcbiAgZXh0cnVkZWQ6IGZhbHNlLFxuICB3aXJlZnJhbWU6IGZhbHNlLFxuICBfZnVsbDNkOiBmYWxzZSxcbiAgaWNvbkF0bGFzOiB7XG4gICAgdHlwZTogJ29iamVjdCcsXG4gICAgdmFsdWU6IG51bGxcbiAgfSxcbiAgaWNvbk1hcHBpbmc6IHtcbiAgICB0eXBlOiAnb2JqZWN0JyxcbiAgICB2YWx1ZToge31cbiAgfSxcbiAgZ2V0SWNvbjoge1xuICAgIHR5cGU6ICdhY2Nlc3NvcicsXG4gICAgdmFsdWU6IGYgPT4gZi5wcm9wZXJ0aWVzLmljb25cbiAgfSxcbiAgZ2V0VGV4dDoge1xuICAgIHR5cGU6ICdhY2Nlc3NvcicsXG4gICAgdmFsdWU6IGYgPT4gZi5wcm9wZXJ0aWVzLnRleHRcbiAgfSxcbiAgcG9pbnRUeXBlOiAnY2lyY2xlJyxcbiAgZ2V0UmFkaXVzOiB7XG4gICAgZGVwcmVjYXRlZEZvcjogJ2dldFBvaW50UmFkaXVzJ1xuICB9XG59O1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgR2VvSnNvbkxheWVyIGV4dGVuZHMgQ29tcG9zaXRlTGF5ZXIge1xuICBpbml0aWFsaXplU3RhdGUoKSB7XG4gICAgdGhpcy5zdGF0ZSA9IHtcbiAgICAgIGxheWVyUHJvcHM6IHt9LFxuICAgICAgZmVhdHVyZXM6IHt9XG4gICAgfTtcbiAgfVxuXG4gIHVwZGF0ZVN0YXRlKHtcbiAgICBwcm9wcyxcbiAgICBjaGFuZ2VGbGFnc1xuICB9KSB7XG4gICAgaWYgKCFjaGFuZ2VGbGFncy5kYXRhQ2hhbmdlZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IHtcbiAgICAgIGRhdGFcbiAgICB9ID0gdGhpcy5wcm9wcztcbiAgICBjb25zdCBiaW5hcnkgPSBkYXRhICYmICdwb2ludHMnIGluIGRhdGEgJiYgJ3BvbHlnb25zJyBpbiBkYXRhICYmICdsaW5lcycgaW4gZGF0YTtcbiAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgIGJpbmFyeVxuICAgIH0pO1xuXG4gICAgaWYgKGJpbmFyeSkge1xuICAgICAgdGhpcy5fdXBkYXRlU3RhdGVCaW5hcnkoe1xuICAgICAgICBwcm9wcyxcbiAgICAgICAgY2hhbmdlRmxhZ3NcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl91cGRhdGVTdGF0ZUpTT04oe1xuICAgICAgICBwcm9wcyxcbiAgICAgICAgY2hhbmdlRmxhZ3NcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIF91cGRhdGVTdGF0ZUJpbmFyeSh7XG4gICAgcHJvcHMsXG4gICAgY2hhbmdlRmxhZ3NcbiAgfSkge1xuICAgIGNvbnN0IGxheWVyUHJvcHMgPSBjcmVhdGVMYXllclByb3BzRnJvbUJpbmFyeShwcm9wcy5kYXRhLCB0aGlzLmVuY29kZVBpY2tpbmdDb2xvcik7XG4gICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICBsYXllclByb3BzXG4gICAgfSk7XG4gIH1cblxuICBfdXBkYXRlU3RhdGVKU09OKHtcbiAgICBwcm9wcyxcbiAgICBjaGFuZ2VGbGFnc1xuICB9KSB7XG4gICAgY29uc3QgZmVhdHVyZXMgPSBnZXRHZW9qc29uRmVhdHVyZXMocHJvcHMuZGF0YSk7XG4gICAgY29uc3Qgd3JhcEZlYXR1cmUgPSB0aGlzLmdldFN1YkxheWVyUm93LmJpbmQodGhpcyk7XG4gICAgbGV0IG5ld0ZlYXR1cmVzID0ge307XG4gICAgY29uc3QgZmVhdHVyZXNEaWZmID0ge307XG5cbiAgICBpZiAoQXJyYXkuaXNBcnJheShjaGFuZ2VGbGFncy5kYXRhQ2hhbmdlZCkpIHtcbiAgICAgIGNvbnN0IG9sZEZlYXR1cmVzID0gdGhpcy5zdGF0ZS5mZWF0dXJlcztcblxuICAgICAgZm9yIChjb25zdCBrZXkgaW4gb2xkRmVhdHVyZXMpIHtcbiAgICAgICAgbmV3RmVhdHVyZXNba2V5XSA9IG9sZEZlYXR1cmVzW2tleV0uc2xpY2UoKTtcbiAgICAgICAgZmVhdHVyZXNEaWZmW2tleV0gPSBbXTtcbiAgICAgIH1cblxuICAgICAgZm9yIChjb25zdCBkYXRhUmFuZ2Ugb2YgY2hhbmdlRmxhZ3MuZGF0YUNoYW5nZWQpIHtcbiAgICAgICAgY29uc3QgcGFydGlhbEZlYXR1cmVzID0gc2VwYXJhdGVHZW9qc29uRmVhdHVyZXMoZmVhdHVyZXMsIHdyYXBGZWF0dXJlLCBkYXRhUmFuZ2UpO1xuXG4gICAgICAgIGZvciAoY29uc3Qga2V5IGluIG9sZEZlYXR1cmVzKSB7XG4gICAgICAgICAgZmVhdHVyZXNEaWZmW2tleV0ucHVzaChyZXBsYWNlSW5SYW5nZSh7XG4gICAgICAgICAgICBkYXRhOiBuZXdGZWF0dXJlc1trZXldLFxuICAgICAgICAgICAgZ2V0SW5kZXg6IGYgPT4gZi5fX3NvdXJjZS5pbmRleCxcbiAgICAgICAgICAgIGRhdGFSYW5nZSxcbiAgICAgICAgICAgIHJlcGxhY2U6IHBhcnRpYWxGZWF0dXJlc1trZXldXG4gICAgICAgICAgfSkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIG5ld0ZlYXR1cmVzID0gc2VwYXJhdGVHZW9qc29uRmVhdHVyZXMoZmVhdHVyZXMsIHdyYXBGZWF0dXJlKTtcbiAgICB9XG5cbiAgICBjb25zdCBsYXllclByb3BzID0gY3JlYXRlTGF5ZXJQcm9wc0Zyb21GZWF0dXJlcyhuZXdGZWF0dXJlcywgZmVhdHVyZXNEaWZmKTtcbiAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgIGZlYXR1cmVzOiBuZXdGZWF0dXJlcyxcbiAgICAgIGZlYXR1cmVzRGlmZixcbiAgICAgIGxheWVyUHJvcHNcbiAgICB9KTtcbiAgfVxuXG4gIGdldFBpY2tpbmdJbmZvKHBhcmFtcykge1xuICAgIGNvbnN0IGluZm8gPSBzdXBlci5nZXRQaWNraW5nSW5mbyhwYXJhbXMpO1xuICAgIGNvbnN0IHtcbiAgICAgIGluZGV4LFxuICAgICAgc291cmNlTGF5ZXJcbiAgICB9ID0gaW5mbztcbiAgICBpbmZvLmZlYXR1cmVUeXBlID0gRkVBVFVSRV9UWVBFUy5maW5kKGZ0ID0+IHNvdXJjZUxheWVyLmlkLnN0YXJ0c1dpdGgoXCJcIi5jb25jYXQodGhpcy5pZCwgXCItXCIpLmNvbmNhdChmdCwgXCItXCIpKSk7XG5cbiAgICBpZiAoaW5kZXggPj0gMCAmJiBzb3VyY2VMYXllci5pZC5zdGFydHNXaXRoKFwiXCIuY29uY2F0KHRoaXMuaWQsIFwiLXBvaW50cy10ZXh0XCIpKSAmJiB0aGlzLnN0YXRlLmJpbmFyeSkge1xuICAgICAgaW5mby5pbmRleCA9IHRoaXMucHJvcHMuZGF0YS5wb2ludHMuZ2xvYmFsRmVhdHVyZUlkcy52YWx1ZVtpbmRleF07XG4gICAgfVxuXG4gICAgcmV0dXJuIGluZm87XG4gIH1cblxuICBfdXBkYXRlQXV0b0hpZ2hsaWdodChpbmZvKSB7XG4gICAgY29uc3QgcG9pbnRMYXllcklkUHJlZml4ID0gXCJcIi5jb25jYXQodGhpcy5pZCwgXCItcG9pbnRzLVwiKTtcbiAgICBjb25zdCBzb3VyY2VJc1BvaW50cyA9IGluZm8uZmVhdHVyZVR5cGUgPT09ICdwb2ludHMnO1xuXG4gICAgZm9yIChjb25zdCBsYXllciBvZiB0aGlzLmdldFN1YkxheWVycygpKSB7XG4gICAgICBpZiAobGF5ZXIuaWQuc3RhcnRzV2l0aChwb2ludExheWVySWRQcmVmaXgpID09PSBzb3VyY2VJc1BvaW50cykge1xuICAgICAgICBsYXllci51cGRhdGVBdXRvSGlnaGxpZ2h0KGluZm8pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIF9yZW5kZXJQb2x5Z29uTGF5ZXIoKSB7XG4gICAgY29uc3Qge1xuICAgICAgZXh0cnVkZWQsXG4gICAgICB3aXJlZnJhbWVcbiAgICB9ID0gdGhpcy5wcm9wcztcbiAgICBjb25zdCB7XG4gICAgICBsYXllclByb3BzXG4gICAgfSA9IHRoaXMuc3RhdGU7XG4gICAgY29uc3QgaWQgPSAncG9seWdvbnMtZmlsbCc7XG4gICAgY29uc3QgUG9seWdvbkZpbGxMYXllciA9IHRoaXMuc2hvdWxkUmVuZGVyU3ViTGF5ZXIoaWQsIGxheWVyUHJvcHMucG9seWdvbnMuZGF0YSkgJiYgdGhpcy5nZXRTdWJMYXllckNsYXNzKGlkLCBQT0xZR09OX0xBWUVSLnR5cGUpO1xuXG4gICAgaWYgKFBvbHlnb25GaWxsTGF5ZXIpIHtcbiAgICAgIGNvbnN0IGZvcndhcmRlZFByb3BzID0gZm9yd2FyZFByb3BzKHRoaXMsIFBPTFlHT05fTEFZRVIucHJvcHMpO1xuICAgICAgY29uc3QgdXNlTGluZUNvbG9yID0gZXh0cnVkZWQgJiYgd2lyZWZyYW1lO1xuXG4gICAgICBpZiAoIXVzZUxpbmVDb2xvcikge1xuICAgICAgICBkZWxldGUgZm9yd2FyZGVkUHJvcHMuZ2V0TGluZUNvbG9yO1xuICAgICAgfVxuXG4gICAgICBmb3J3YXJkZWRQcm9wcy51cGRhdGVUcmlnZ2Vycy5saW5lQ29sb3JzID0gdXNlTGluZUNvbG9yO1xuICAgICAgcmV0dXJuIG5ldyBQb2x5Z29uRmlsbExheWVyKGZvcndhcmRlZFByb3BzLCB0aGlzLmdldFN1YkxheWVyUHJvcHMoe1xuICAgICAgICBpZCxcbiAgICAgICAgdXBkYXRlVHJpZ2dlcnM6IGZvcndhcmRlZFByb3BzLnVwZGF0ZVRyaWdnZXJzXG4gICAgICB9KSwgbGF5ZXJQcm9wcy5wb2x5Z29ucyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBfcmVuZGVyTGluZUxheWVycygpIHtcbiAgICBjb25zdCB7XG4gICAgICBleHRydWRlZCxcbiAgICAgIHN0cm9rZWRcbiAgICB9ID0gdGhpcy5wcm9wcztcbiAgICBjb25zdCB7XG4gICAgICBsYXllclByb3BzXG4gICAgfSA9IHRoaXMuc3RhdGU7XG4gICAgY29uc3QgcG9seWdvblN0cm9rZUxheWVySWQgPSAncG9seWdvbnMtc3Ryb2tlJztcbiAgICBjb25zdCBsaW5lU3RyaW5nc0xheWVySWQgPSAnbGluZXN0cmluZ3MnO1xuICAgIGNvbnN0IFBvbHlnb25TdHJva2VMYXllciA9ICFleHRydWRlZCAmJiBzdHJva2VkICYmIHRoaXMuc2hvdWxkUmVuZGVyU3ViTGF5ZXIocG9seWdvblN0cm9rZUxheWVySWQsIGxheWVyUHJvcHMucG9seWdvbnNPdXRsaW5lLmRhdGEpICYmIHRoaXMuZ2V0U3ViTGF5ZXJDbGFzcyhwb2x5Z29uU3Ryb2tlTGF5ZXJJZCwgTElORV9MQVlFUi50eXBlKTtcbiAgICBjb25zdCBMaW5lU3RyaW5nc0xheWVyID0gdGhpcy5zaG91bGRSZW5kZXJTdWJMYXllcihsaW5lU3RyaW5nc0xheWVySWQsIGxheWVyUHJvcHMubGluZXMuZGF0YSkgJiYgdGhpcy5nZXRTdWJMYXllckNsYXNzKGxpbmVTdHJpbmdzTGF5ZXJJZCwgTElORV9MQVlFUi50eXBlKTtcblxuICAgIGlmIChQb2x5Z29uU3Ryb2tlTGF5ZXIgfHwgTGluZVN0cmluZ3NMYXllcikge1xuICAgICAgY29uc3QgZm9yd2FyZGVkUHJvcHMgPSBmb3J3YXJkUHJvcHModGhpcywgTElORV9MQVlFUi5wcm9wcyk7XG4gICAgICByZXR1cm4gW1BvbHlnb25TdHJva2VMYXllciAmJiBuZXcgUG9seWdvblN0cm9rZUxheWVyKGZvcndhcmRlZFByb3BzLCB0aGlzLmdldFN1YkxheWVyUHJvcHMoe1xuICAgICAgICBpZDogcG9seWdvblN0cm9rZUxheWVySWQsXG4gICAgICAgIHVwZGF0ZVRyaWdnZXJzOiBmb3J3YXJkZWRQcm9wcy51cGRhdGVUcmlnZ2Vyc1xuICAgICAgfSksIGxheWVyUHJvcHMucG9seWdvbnNPdXRsaW5lKSwgTGluZVN0cmluZ3NMYXllciAmJiBuZXcgTGluZVN0cmluZ3NMYXllcihmb3J3YXJkZWRQcm9wcywgdGhpcy5nZXRTdWJMYXllclByb3BzKHtcbiAgICAgICAgaWQ6IGxpbmVTdHJpbmdzTGF5ZXJJZCxcbiAgICAgICAgdXBkYXRlVHJpZ2dlcnM6IGZvcndhcmRlZFByb3BzLnVwZGF0ZVRyaWdnZXJzXG4gICAgICB9KSwgbGF5ZXJQcm9wcy5saW5lcyldO1xuICAgIH1cblxuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgX3JlbmRlclBvaW50TGF5ZXJzKCkge1xuICAgIGNvbnN0IHtcbiAgICAgIHBvaW50VHlwZVxuICAgIH0gPSB0aGlzLnByb3BzO1xuICAgIGNvbnN0IHtcbiAgICAgIGxheWVyUHJvcHMsXG4gICAgICBiaW5hcnlcbiAgICB9ID0gdGhpcy5zdGF0ZTtcbiAgICBsZXQge1xuICAgICAgaGlnaGxpZ2h0ZWRPYmplY3RJbmRleFxuICAgIH0gPSB0aGlzLnByb3BzO1xuXG4gICAgaWYgKCFiaW5hcnkgJiYgTnVtYmVyLmlzRmluaXRlKGhpZ2hsaWdodGVkT2JqZWN0SW5kZXgpKSB7XG4gICAgICBoaWdobGlnaHRlZE9iamVjdEluZGV4ID0gbGF5ZXJQcm9wcy5wb2ludHMuZGF0YS5maW5kSW5kZXgoZCA9PiBkLl9fc291cmNlLmluZGV4ID09PSBoaWdobGlnaHRlZE9iamVjdEluZGV4KTtcbiAgICB9XG5cbiAgICBjb25zdCB0eXBlcyA9IG5ldyBTZXQocG9pbnRUeXBlLnNwbGl0KCcrJykpO1xuICAgIGNvbnN0IHBvaW50TGF5ZXJzID0gW107XG5cbiAgICBmb3IgKGNvbnN0IHR5cGUgb2YgdHlwZXMpIHtcbiAgICAgIGNvbnN0IGlkID0gXCJwb2ludHMtXCIuY29uY2F0KHR5cGUpO1xuICAgICAgY29uc3QgUG9pbnRMYXllck1hcHBpbmcgPSBQT0lOVF9MQVlFUlt0eXBlXTtcbiAgICAgIGNvbnN0IFBvaW50c0xheWVyID0gUG9pbnRMYXllck1hcHBpbmcgJiYgdGhpcy5zaG91bGRSZW5kZXJTdWJMYXllcihpZCwgbGF5ZXJQcm9wcy5wb2ludHMuZGF0YSkgJiYgdGhpcy5nZXRTdWJMYXllckNsYXNzKGlkLCBQb2ludExheWVyTWFwcGluZy50eXBlKTtcblxuICAgICAgaWYgKFBvaW50c0xheWVyKSB7XG4gICAgICAgIGNvbnN0IGZvcndhcmRlZFByb3BzID0gZm9yd2FyZFByb3BzKHRoaXMsIFBvaW50TGF5ZXJNYXBwaW5nLnByb3BzKTtcbiAgICAgICAgbGV0IHBvaW50c0xheWVyUHJvcHMgPSBsYXllclByb3BzLnBvaW50cztcblxuICAgICAgICBpZiAodHlwZSA9PT0gJ3RleHQnICYmIGJpbmFyeSkge1xuICAgICAgICAgIGNvbnN0IHtcbiAgICAgICAgICAgIGluc3RhbmNlUGlja2luZ0NvbG9ycyxcbiAgICAgICAgICAgIC4uLnJlc3RcbiAgICAgICAgICB9ID0gcG9pbnRzTGF5ZXJQcm9wcy5kYXRhLmF0dHJpYnV0ZXM7XG4gICAgICAgICAgcG9pbnRzTGF5ZXJQcm9wcyA9IHsgLi4ucG9pbnRzTGF5ZXJQcm9wcyxcbiAgICAgICAgICAgIGRhdGE6IHsgLi4ucG9pbnRzTGF5ZXJQcm9wcy5kYXRhLFxuICAgICAgICAgICAgICBhdHRyaWJ1dGVzOiByZXN0XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIHBvaW50TGF5ZXJzLnB1c2gobmV3IFBvaW50c0xheWVyKGZvcndhcmRlZFByb3BzLCB0aGlzLmdldFN1YkxheWVyUHJvcHMoe1xuICAgICAgICAgIGlkLFxuICAgICAgICAgIHVwZGF0ZVRyaWdnZXJzOiBmb3J3YXJkZWRQcm9wcy51cGRhdGVUcmlnZ2VycyxcbiAgICAgICAgICBoaWdobGlnaHRlZE9iamVjdEluZGV4XG4gICAgICAgIH0pLCBwb2ludHNMYXllclByb3BzKSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHBvaW50TGF5ZXJzO1xuICB9XG5cbiAgcmVuZGVyTGF5ZXJzKCkge1xuICAgIGNvbnN0IHtcbiAgICAgIGV4dHJ1ZGVkXG4gICAgfSA9IHRoaXMucHJvcHM7XG5cbiAgICBjb25zdCBwb2x5Z29uRmlsbExheWVyID0gdGhpcy5fcmVuZGVyUG9seWdvbkxheWVyKCk7XG5cbiAgICBjb25zdCBsaW5lTGF5ZXJzID0gdGhpcy5fcmVuZGVyTGluZUxheWVycygpO1xuXG4gICAgY29uc3QgcG9pbnRMYXllcnMgPSB0aGlzLl9yZW5kZXJQb2ludExheWVycygpO1xuXG4gICAgcmV0dXJuIFshZXh0cnVkZWQgJiYgcG9seWdvbkZpbGxMYXllciwgbGluZUxheWVycywgcG9pbnRMYXllcnMsIGV4dHJ1ZGVkICYmIHBvbHlnb25GaWxsTGF5ZXJdO1xuICB9XG5cbiAgZ2V0U3ViTGF5ZXJBY2Nlc3NvcihhY2Nlc3Nvcikge1xuICAgIGNvbnN0IHtcbiAgICAgIGJpbmFyeVxuICAgIH0gPSB0aGlzLnN0YXRlO1xuXG4gICAgaWYgKCFiaW5hcnkgfHwgdHlwZW9mIGFjY2Vzc29yICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICByZXR1cm4gc3VwZXIuZ2V0U3ViTGF5ZXJBY2Nlc3NvcihhY2Nlc3Nvcik7XG4gICAgfVxuXG4gICAgcmV0dXJuIChvYmplY3QsIGluZm8pID0+IHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgZGF0YSxcbiAgICAgICAgaW5kZXhcbiAgICAgIH0gPSBpbmZvO1xuICAgICAgY29uc3QgZmVhdHVyZSA9IGJpbmFyeVRvRmVhdHVyZUZvckFjY2Vzb3IoZGF0YSwgaW5kZXgpO1xuICAgICAgcmV0dXJuIGFjY2Vzc29yKGZlYXR1cmUsIGluZm8pO1xuICAgIH07XG4gIH1cblxufVxuXG5fZGVmaW5lUHJvcGVydHkoR2VvSnNvbkxheWVyLCBcImxheWVyTmFtZVwiLCAnR2VvSnNvbkxheWVyJyk7XG5cbl9kZWZpbmVQcm9wZXJ0eShHZW9Kc29uTGF5ZXIsIFwiZGVmYXVsdFByb3BzXCIsIGRlZmF1bHRQcm9wcyk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1nZW9qc29uLWxheWVyLmpzLm1hcCIsImltcG9ydCBfZGVmaW5lUHJvcGVydHkgZnJvbSBcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL2RlZmluZVByb3BlcnR5XCI7XG5leHBvcnQgY2xhc3MgVGlsZTJESGVhZGVyIHtcbiAgY29uc3RydWN0b3IoaW5kZXgpIHtcbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJpbmRleFwiLCB2b2lkIDApO1xuXG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwiaXNWaXNpYmxlXCIsIHZvaWQgMCk7XG5cbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJpc1NlbGVjdGVkXCIsIHZvaWQgMCk7XG5cbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJwYXJlbnRcIiwgdm9pZCAwKTtcblxuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImNoaWxkcmVuXCIsIHZvaWQgMCk7XG5cbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJjb250ZW50XCIsIHZvaWQgMCk7XG5cbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJzdGF0ZVwiLCB2b2lkIDApO1xuXG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwibGF5ZXJzXCIsIHZvaWQgMCk7XG5cbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJpZFwiLCB2b2lkIDApO1xuXG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwiYmJveFwiLCB2b2lkIDApO1xuXG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwiem9vbVwiLCB2b2lkIDApO1xuXG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwidXNlckRhdGFcIiwgdm9pZCAwKTtcblxuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIl9hYm9ydENvbnRyb2xsZXJcIiwgdm9pZCAwKTtcblxuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIl9sb2FkZXJcIiwgdm9pZCAwKTtcblxuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIl9sb2FkZXJJZFwiLCB2b2lkIDApO1xuXG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwiX2lzTG9hZGVkXCIsIHZvaWQgMCk7XG5cbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJfaXNDYW5jZWxsZWRcIiwgdm9pZCAwKTtcblxuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIl9uZWVkc1JlbG9hZFwiLCB2b2lkIDApO1xuXG4gICAgdGhpcy5pbmRleCA9IGluZGV4O1xuICAgIHRoaXMuaXNWaXNpYmxlID0gZmFsc2U7XG4gICAgdGhpcy5pc1NlbGVjdGVkID0gZmFsc2U7XG4gICAgdGhpcy5wYXJlbnQgPSBudWxsO1xuICAgIHRoaXMuY2hpbGRyZW4gPSBbXTtcbiAgICB0aGlzLmNvbnRlbnQgPSBudWxsO1xuICAgIHRoaXMuX2xvYWRlciA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLl9hYm9ydENvbnRyb2xsZXIgPSBudWxsO1xuICAgIHRoaXMuX2xvYWRlcklkID0gMDtcbiAgICB0aGlzLl9pc0xvYWRlZCA9IGZhbHNlO1xuICAgIHRoaXMuX2lzQ2FuY2VsbGVkID0gZmFsc2U7XG4gICAgdGhpcy5fbmVlZHNSZWxvYWQgPSBmYWxzZTtcbiAgfVxuXG4gIGdldCBkYXRhKCkge1xuICAgIHJldHVybiB0aGlzLmlzTG9hZGluZyAmJiB0aGlzLl9sb2FkZXIgPyB0aGlzLl9sb2FkZXIudGhlbigoKSA9PiB0aGlzLmRhdGEpIDogdGhpcy5jb250ZW50O1xuICB9XG5cbiAgZ2V0IGlzTG9hZGVkKCkge1xuICAgIHJldHVybiB0aGlzLl9pc0xvYWRlZCAmJiAhdGhpcy5fbmVlZHNSZWxvYWQ7XG4gIH1cblxuICBnZXQgaXNMb2FkaW5nKCkge1xuICAgIHJldHVybiBCb29sZWFuKHRoaXMuX2xvYWRlcikgJiYgIXRoaXMuX2lzQ2FuY2VsbGVkO1xuICB9XG5cbiAgZ2V0IG5lZWRzUmVsb2FkKCkge1xuICAgIHJldHVybiB0aGlzLl9uZWVkc1JlbG9hZCB8fCB0aGlzLl9pc0NhbmNlbGxlZDtcbiAgfVxuXG4gIGdldCBieXRlTGVuZ3RoKCkge1xuICAgIGNvbnN0IHJlc3VsdCA9IHRoaXMuY29udGVudCA/IHRoaXMuY29udGVudC5ieXRlTGVuZ3RoIDogMDtcblxuICAgIGlmICghTnVtYmVyLmlzRmluaXRlKHJlc3VsdCkpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ2J5dGVMZW5ndGggbm90IGRlZmluZWQgaW4gdGlsZSBkYXRhJyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIGFzeW5jIF9sb2FkRGF0YSh7XG4gICAgZ2V0RGF0YSxcbiAgICByZXF1ZXN0U2NoZWR1bGVyLFxuICAgIG9uTG9hZCxcbiAgICBvbkVycm9yXG4gIH0pIHtcbiAgICBjb25zdCB7XG4gICAgICBpbmRleCxcbiAgICAgIGlkLFxuICAgICAgYmJveCxcbiAgICAgIHVzZXJEYXRhLFxuICAgICAgem9vbVxuICAgIH0gPSB0aGlzO1xuICAgIGNvbnN0IGxvYWRlcklkID0gdGhpcy5fbG9hZGVySWQ7XG4gICAgdGhpcy5fYWJvcnRDb250cm9sbGVyID0gbmV3IEFib3J0Q29udHJvbGxlcigpO1xuICAgIGNvbnN0IHtcbiAgICAgIHNpZ25hbFxuICAgIH0gPSB0aGlzLl9hYm9ydENvbnRyb2xsZXI7XG4gICAgY29uc3QgcmVxdWVzdFRva2VuID0gYXdhaXQgcmVxdWVzdFNjaGVkdWxlci5zY2hlZHVsZVJlcXVlc3QodGhpcywgdGlsZSA9PiB7XG4gICAgICByZXR1cm4gdGlsZS5pc1NlbGVjdGVkID8gMSA6IC0xO1xuICAgIH0pO1xuXG4gICAgaWYgKCFyZXF1ZXN0VG9rZW4pIHtcbiAgICAgIHRoaXMuX2lzQ2FuY2VsbGVkID0gdHJ1ZTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5faXNDYW5jZWxsZWQpIHtcbiAgICAgIHJlcXVlc3RUb2tlbi5kb25lKCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgbGV0IHRpbGVEYXRhID0gbnVsbDtcbiAgICBsZXQgZXJyb3I7XG5cbiAgICB0cnkge1xuICAgICAgdGlsZURhdGEgPSBhd2FpdCBnZXREYXRhKHtcbiAgICAgICAgaW5kZXgsXG4gICAgICAgIGlkLFxuICAgICAgICBiYm94LFxuICAgICAgICB1c2VyRGF0YSxcbiAgICAgICAgem9vbSxcbiAgICAgICAgc2lnbmFsXG4gICAgICB9KTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIGVycm9yID0gZXJyIHx8IHRydWU7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIHJlcXVlc3RUb2tlbi5kb25lKCk7XG4gICAgfVxuXG4gICAgaWYgKGxvYWRlcklkICE9PSB0aGlzLl9sb2FkZXJJZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMuX2xvYWRlciA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLmNvbnRlbnQgPSB0aWxlRGF0YTtcblxuICAgIGlmICh0aGlzLl9pc0NhbmNlbGxlZCAmJiAhdGlsZURhdGEpIHtcbiAgICAgIHRoaXMuX2lzTG9hZGVkID0gZmFsc2U7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy5faXNMb2FkZWQgPSB0cnVlO1xuICAgIHRoaXMuX2lzQ2FuY2VsbGVkID0gZmFsc2U7XG5cbiAgICBpZiAoZXJyb3IpIHtcbiAgICAgIG9uRXJyb3IoZXJyb3IsIHRoaXMpO1xuICAgIH0gZWxzZSB7XG4gICAgICBvbkxvYWQodGhpcyk7XG4gICAgfVxuICB9XG5cbiAgbG9hZERhdGEob3B0cykge1xuICAgIHRoaXMuX2lzTG9hZGVkID0gZmFsc2U7XG4gICAgdGhpcy5faXNDYW5jZWxsZWQgPSBmYWxzZTtcbiAgICB0aGlzLl9uZWVkc1JlbG9hZCA9IGZhbHNlO1xuICAgIHRoaXMuX2xvYWRlcklkKys7XG4gICAgdGhpcy5fbG9hZGVyID0gdGhpcy5fbG9hZERhdGEob3B0cyk7XG4gICAgcmV0dXJuIHRoaXMuX2xvYWRlcjtcbiAgfVxuXG4gIHNldE5lZWRzUmVsb2FkKCkge1xuICAgIGlmICh0aGlzLmlzTG9hZGluZykge1xuICAgICAgdGhpcy5hYm9ydCgpO1xuICAgICAgdGhpcy5fbG9hZGVyID0gdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIHRoaXMuX25lZWRzUmVsb2FkID0gdHJ1ZTtcbiAgfVxuXG4gIGFib3J0KCkge1xuICAgIHZhciBfdGhpcyRfYWJvcnRDb250cm9sbGU7XG5cbiAgICBpZiAodGhpcy5pc0xvYWRlZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMuX2lzQ2FuY2VsbGVkID0gdHJ1ZTtcbiAgICAoX3RoaXMkX2Fib3J0Q29udHJvbGxlID0gdGhpcy5fYWJvcnRDb250cm9sbGVyKSA9PT0gbnVsbCB8fCBfdGhpcyRfYWJvcnRDb250cm9sbGUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF90aGlzJF9hYm9ydENvbnRyb2xsZS5hYm9ydCgpO1xuICB9XG5cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXRpbGUtMmQtaGVhZGVyLmpzLm1hcCIsImltcG9ydCBfZGVmaW5lUHJvcGVydHkgZnJvbSBcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL2RlZmluZVByb3BlcnR5XCI7XG5pbXBvcnQgeyBXZWJNZXJjYXRvclZpZXdwb3J0LCBfR2xvYmVWaWV3cG9ydCB9IGZyb20gJ0BkZWNrLmdsL2NvcmUnO1xuaW1wb3J0IHsgQ3VsbGluZ1ZvbHVtZSwgUGxhbmUsIEF4aXNBbGlnbmVkQm91bmRpbmdCb3gsIG1ha2VPcmllbnRlZEJvdW5kaW5nQm94RnJvbVBvaW50cyB9IGZyb20gJ0BtYXRoLmdsL2N1bGxpbmcnO1xuaW1wb3J0IHsgbG5nTGF0VG9Xb3JsZCB9IGZyb20gJ0BtYXRoLmdsL3dlYi1tZXJjYXRvcic7XG5pbXBvcnQgeyBvc21UaWxlMmxuZ0xhdCB9IGZyb20gJy4vdXRpbHMnO1xuY29uc3QgVElMRV9TSVpFID0gNTEyO1xuY29uc3QgTUFYX01BUFMgPSAzO1xuY29uc3QgUkVGX1BPSU5UU181ID0gW1swLjUsIDAuNV0sIFswLCAwXSwgWzAsIDFdLCBbMSwgMF0sIFsxLCAxXV07XG5jb25zdCBSRUZfUE9JTlRTXzkgPSBSRUZfUE9JTlRTXzUuY29uY2F0KFtbMCwgMC41XSwgWzAuNSwgMF0sIFsxLCAwLjVdLCBbMC41LCAxXV0pO1xuY29uc3QgUkVGX1BPSU5UU18xMSA9IFJFRl9QT0lOVFNfOS5jb25jYXQoW1swLjI1LCAwLjVdLCBbMC43NSwgMC41XV0pO1xuXG5jbGFzcyBPU01Ob2RlIHtcbiAgY29uc3RydWN0b3IoeCwgeSwgeikge1xuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInhcIiwgdm9pZCAwKTtcblxuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInlcIiwgdm9pZCAwKTtcblxuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInpcIiwgdm9pZCAwKTtcblxuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImNoaWxkVmlzaWJsZVwiLCB2b2lkIDApO1xuXG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwic2VsZWN0ZWRcIiwgdm9pZCAwKTtcblxuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIl9jaGlsZHJlblwiLCB2b2lkIDApO1xuXG4gICAgdGhpcy54ID0geDtcbiAgICB0aGlzLnkgPSB5O1xuICAgIHRoaXMueiA9IHo7XG4gIH1cblxuICBnZXQgY2hpbGRyZW4oKSB7XG4gICAgaWYgKCF0aGlzLl9jaGlsZHJlbikge1xuICAgICAgY29uc3QgeCA9IHRoaXMueCAqIDI7XG4gICAgICBjb25zdCB5ID0gdGhpcy55ICogMjtcbiAgICAgIGNvbnN0IHogPSB0aGlzLnogKyAxO1xuICAgICAgdGhpcy5fY2hpbGRyZW4gPSBbbmV3IE9TTU5vZGUoeCwgeSwgeiksIG5ldyBPU01Ob2RlKHgsIHkgKyAxLCB6KSwgbmV3IE9TTU5vZGUoeCArIDEsIHksIHopLCBuZXcgT1NNTm9kZSh4ICsgMSwgeSArIDEsIHopXTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5fY2hpbGRyZW47XG4gIH1cblxuICB1cGRhdGUocGFyYW1zKSB7XG4gICAgY29uc3Qge1xuICAgICAgdmlld3BvcnQsXG4gICAgICBjdWxsaW5nVm9sdW1lLFxuICAgICAgZWxldmF0aW9uQm91bmRzLFxuICAgICAgbWluWixcbiAgICAgIG1heFosXG4gICAgICBib3VuZHMsXG4gICAgICBvZmZzZXQsXG4gICAgICBwcm9qZWN0XG4gICAgfSA9IHBhcmFtcztcbiAgICBjb25zdCBib3VuZGluZ1ZvbHVtZSA9IHRoaXMuZ2V0Qm91bmRpbmdWb2x1bWUoZWxldmF0aW9uQm91bmRzLCBvZmZzZXQsIHByb2plY3QpO1xuXG4gICAgaWYgKGJvdW5kcyAmJiAhdGhpcy5pbnNpZGVCb3VuZHMoYm91bmRzKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGNvbnN0IGlzSW5zaWRlID0gY3VsbGluZ1ZvbHVtZS5jb21wdXRlVmlzaWJpbGl0eShib3VuZGluZ1ZvbHVtZSk7XG5cbiAgICBpZiAoaXNJbnNpZGUgPCAwKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgaWYgKCF0aGlzLmNoaWxkVmlzaWJsZSkge1xuICAgICAgbGV0IHtcbiAgICAgICAgelxuICAgICAgfSA9IHRoaXM7XG5cbiAgICAgIGlmICh6IDwgbWF4WiAmJiB6ID49IG1pblopIHtcbiAgICAgICAgY29uc3QgZGlzdGFuY2UgPSBib3VuZGluZ1ZvbHVtZS5kaXN0YW5jZVRvKHZpZXdwb3J0LmNhbWVyYVBvc2l0aW9uKSAqIHZpZXdwb3J0LnNjYWxlIC8gdmlld3BvcnQuaGVpZ2h0O1xuICAgICAgICB6ICs9IE1hdGguZmxvb3IoTWF0aC5sb2cyKGRpc3RhbmNlKSk7XG4gICAgICB9XG5cbiAgICAgIGlmICh6ID49IG1heFopIHtcbiAgICAgICAgdGhpcy5zZWxlY3RlZCA9IHRydWU7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMuc2VsZWN0ZWQgPSBmYWxzZTtcbiAgICB0aGlzLmNoaWxkVmlzaWJsZSA9IHRydWU7XG5cbiAgICBmb3IgKGNvbnN0IGNoaWxkIG9mIHRoaXMuY2hpbGRyZW4pIHtcbiAgICAgIGNoaWxkLnVwZGF0ZShwYXJhbXMpO1xuICAgIH1cblxuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgZ2V0U2VsZWN0ZWQocmVzdWx0ID0gW10pIHtcbiAgICBpZiAodGhpcy5zZWxlY3RlZCkge1xuICAgICAgcmVzdWx0LnB1c2godGhpcyk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX2NoaWxkcmVuKSB7XG4gICAgICBmb3IgKGNvbnN0IG5vZGUgb2YgdGhpcy5fY2hpbGRyZW4pIHtcbiAgICAgICAgbm9kZS5nZXRTZWxlY3RlZChyZXN1bHQpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICBpbnNpZGVCb3VuZHMoW21pblgsIG1pblksIG1heFgsIG1heFldKSB7XG4gICAgY29uc3Qgc2NhbGUgPSBNYXRoLnBvdygyLCB0aGlzLnopO1xuICAgIGNvbnN0IGV4dGVudCA9IFRJTEVfU0laRSAvIHNjYWxlO1xuICAgIHJldHVybiB0aGlzLnggKiBleHRlbnQgPCBtYXhYICYmIHRoaXMueSAqIGV4dGVudCA8IG1heFkgJiYgKHRoaXMueCArIDEpICogZXh0ZW50ID4gbWluWCAmJiAodGhpcy55ICsgMSkgKiBleHRlbnQgPiBtaW5ZO1xuICB9XG5cbiAgZ2V0Qm91bmRpbmdWb2x1bWUoelJhbmdlLCB3b3JsZE9mZnNldCwgcHJvamVjdCkge1xuICAgIGlmIChwcm9qZWN0KSB7XG4gICAgICBjb25zdCByZWZQb2ludHMgPSB0aGlzLnogPCAxID8gUkVGX1BPSU5UU18xMSA6IHRoaXMueiA8IDIgPyBSRUZfUE9JTlRTXzkgOiBSRUZfUE9JTlRTXzU7XG4gICAgICBjb25zdCByZWZQb2ludFBvc2l0aW9ucyA9IFtdO1xuXG4gICAgICBmb3IgKGNvbnN0IHAgb2YgcmVmUG9pbnRzKSB7XG4gICAgICAgIGNvbnN0IGxuZ0xhdCA9IG9zbVRpbGUybG5nTGF0KHRoaXMueCArIHBbMF0sIHRoaXMueSArIHBbMV0sIHRoaXMueik7XG4gICAgICAgIGxuZ0xhdFsyXSA9IHpSYW5nZVswXTtcbiAgICAgICAgcmVmUG9pbnRQb3NpdGlvbnMucHVzaChwcm9qZWN0KGxuZ0xhdCkpO1xuXG4gICAgICAgIGlmICh6UmFuZ2VbMF0gIT09IHpSYW5nZVsxXSkge1xuICAgICAgICAgIGxuZ0xhdFsyXSA9IHpSYW5nZVsxXTtcbiAgICAgICAgICByZWZQb2ludFBvc2l0aW9ucy5wdXNoKHByb2plY3QobG5nTGF0KSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG1ha2VPcmllbnRlZEJvdW5kaW5nQm94RnJvbVBvaW50cyhyZWZQb2ludFBvc2l0aW9ucyk7XG4gICAgfVxuXG4gICAgY29uc3Qgc2NhbGUgPSBNYXRoLnBvdygyLCB0aGlzLnopO1xuICAgIGNvbnN0IGV4dGVudCA9IFRJTEVfU0laRSAvIHNjYWxlO1xuICAgIGNvbnN0IG9yaWdpblggPSB0aGlzLnggKiBleHRlbnQgKyB3b3JsZE9mZnNldCAqIFRJTEVfU0laRTtcbiAgICBjb25zdCBvcmlnaW5ZID0gVElMRV9TSVpFIC0gKHRoaXMueSArIDEpICogZXh0ZW50O1xuICAgIHJldHVybiBuZXcgQXhpc0FsaWduZWRCb3VuZGluZ0JveChbb3JpZ2luWCwgb3JpZ2luWSwgelJhbmdlWzBdXSwgW29yaWdpblggKyBleHRlbnQsIG9yaWdpblkgKyBleHRlbnQsIHpSYW5nZVsxXV0pO1xuICB9XG5cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdldE9TTVRpbGVJbmRpY2VzKHZpZXdwb3J0LCBtYXhaLCB6UmFuZ2UsIGJvdW5kcykge1xuICBjb25zdCBwcm9qZWN0ID0gdmlld3BvcnQgaW5zdGFuY2VvZiBfR2xvYmVWaWV3cG9ydCAmJiB2aWV3cG9ydC5yZXNvbHV0aW9uID8gdmlld3BvcnQucHJvamVjdFBvc2l0aW9uIDogbnVsbDtcbiAgY29uc3QgcGxhbmVzID0gT2JqZWN0LnZhbHVlcyh2aWV3cG9ydC5nZXRGcnVzdHVtUGxhbmVzKCkpLm1hcCgoe1xuICAgIG5vcm1hbCxcbiAgICBkaXN0YW5jZVxuICB9KSA9PiBuZXcgUGxhbmUobm9ybWFsLmNsb25lKCkubmVnYXRlKCksIGRpc3RhbmNlKSk7XG4gIGNvbnN0IGN1bGxpbmdWb2x1bWUgPSBuZXcgQ3VsbGluZ1ZvbHVtZShwbGFuZXMpO1xuICBjb25zdCB1bml0c1Blck1ldGVyID0gdmlld3BvcnQuZGlzdGFuY2VTY2FsZXMudW5pdHNQZXJNZXRlclsyXTtcbiAgY29uc3QgZWxldmF0aW9uTWluID0gelJhbmdlICYmIHpSYW5nZVswXSAqIHVuaXRzUGVyTWV0ZXIgfHwgMDtcbiAgY29uc3QgZWxldmF0aW9uTWF4ID0gelJhbmdlICYmIHpSYW5nZVsxXSAqIHVuaXRzUGVyTWV0ZXIgfHwgMDtcbiAgY29uc3QgbWluWiA9IHZpZXdwb3J0IGluc3RhbmNlb2YgV2ViTWVyY2F0b3JWaWV3cG9ydCAmJiB2aWV3cG9ydC5waXRjaCA8PSA2MCA/IG1heFogOiAwO1xuXG4gIGlmIChib3VuZHMpIHtcbiAgICBjb25zdCBbbWluTG5nLCBtaW5MYXQsIG1heExuZywgbWF4TGF0XSA9IGJvdW5kcztcbiAgICBjb25zdCB0b3BMZWZ0ID0gbG5nTGF0VG9Xb3JsZChbbWluTG5nLCBtYXhMYXRdKTtcbiAgICBjb25zdCBib3R0b21SaWdodCA9IGxuZ0xhdFRvV29ybGQoW21heExuZywgbWluTGF0XSk7XG4gICAgYm91bmRzID0gW3RvcExlZnRbMF0sIFRJTEVfU0laRSAtIHRvcExlZnRbMV0sIGJvdHRvbVJpZ2h0WzBdLCBUSUxFX1NJWkUgLSBib3R0b21SaWdodFsxXV07XG4gIH1cblxuICBjb25zdCByb290ID0gbmV3IE9TTU5vZGUoMCwgMCwgMCk7XG4gIGNvbnN0IHRyYXZlcnNhbFBhcmFtcyA9IHtcbiAgICB2aWV3cG9ydCxcbiAgICBwcm9qZWN0LFxuICAgIGN1bGxpbmdWb2x1bWUsXG4gICAgZWxldmF0aW9uQm91bmRzOiBbZWxldmF0aW9uTWluLCBlbGV2YXRpb25NYXhdLFxuICAgIG1pblosXG4gICAgbWF4WixcbiAgICBib3VuZHMsXG4gICAgb2Zmc2V0OiAwXG4gIH07XG4gIHJvb3QudXBkYXRlKHRyYXZlcnNhbFBhcmFtcyk7XG5cbiAgaWYgKHZpZXdwb3J0IGluc3RhbmNlb2YgV2ViTWVyY2F0b3JWaWV3cG9ydCAmJiB2aWV3cG9ydC5zdWJWaWV3cG9ydHMgJiYgdmlld3BvcnQuc3ViVmlld3BvcnRzLmxlbmd0aCA+IDEpIHtcbiAgICB0cmF2ZXJzYWxQYXJhbXMub2Zmc2V0ID0gLTE7XG5cbiAgICB3aGlsZSAocm9vdC51cGRhdGUodHJhdmVyc2FsUGFyYW1zKSkge1xuICAgICAgaWYgKC0tdHJhdmVyc2FsUGFyYW1zLm9mZnNldCA8IC1NQVhfTUFQUykge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0cmF2ZXJzYWxQYXJhbXMub2Zmc2V0ID0gMTtcblxuICAgIHdoaWxlIChyb290LnVwZGF0ZSh0cmF2ZXJzYWxQYXJhbXMpKSB7XG4gICAgICBpZiAoKyt0cmF2ZXJzYWxQYXJhbXMub2Zmc2V0ID4gTUFYX01BUFMpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHJvb3QuZ2V0U2VsZWN0ZWQoKTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXRpbGUtMmQtdHJhdmVyc2FsLmpzLm1hcCIsImltcG9ydCB7IGdldE9TTVRpbGVJbmRpY2VzIH0gZnJvbSAnLi90aWxlLTJkLXRyYXZlcnNhbCc7XG5jb25zdCBUSUxFX1NJWkUgPSA1MTI7XG5jb25zdCBERUZBVUxUX0VYVEVOVCA9IFstSW5maW5pdHksIC1JbmZpbml0eSwgSW5maW5pdHksIEluZmluaXR5XTtcbmV4cG9ydCBjb25zdCB1cmxUeXBlID0ge1xuICB0eXBlOiAnb2JqZWN0JyxcbiAgdmFsdWU6IG51bGwsXG4gIHZhbGlkYXRlOiAodmFsdWUsIHByb3BUeXBlKSA9PiBwcm9wVHlwZS5vcHRpb25hbCAmJiB2YWx1ZSA9PT0gbnVsbCB8fCB0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnIHx8IEFycmF5LmlzQXJyYXkodmFsdWUpICYmIHZhbHVlLmV2ZXJ5KHVybCA9PiB0eXBlb2YgdXJsID09PSAnc3RyaW5nJyksXG4gIGVxdWFsOiAodmFsdWUxLCB2YWx1ZTIpID0+IHtcbiAgICBpZiAodmFsdWUxID09PSB2YWx1ZTIpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIGlmICghQXJyYXkuaXNBcnJheSh2YWx1ZTEpIHx8ICFBcnJheS5pc0FycmF5KHZhbHVlMikpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBjb25zdCBsZW4gPSB2YWx1ZTEubGVuZ3RoO1xuXG4gICAgaWYgKGxlbiAhPT0gdmFsdWUyLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIGlmICh2YWx1ZTFbaV0gIT09IHZhbHVlMltpXSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbn07XG5cbmZ1bmN0aW9uIHRyYW5zZm9ybUJveChiYm94LCBtb2RlbE1hdHJpeCkge1xuICBjb25zdCB0cmFuc2Zvcm1lZENvb3JkcyA9IFttb2RlbE1hdHJpeC50cmFuc2Zvcm1Bc1BvaW50KFtiYm94WzBdLCBiYm94WzFdXSksIG1vZGVsTWF0cml4LnRyYW5zZm9ybUFzUG9pbnQoW2Jib3hbMl0sIGJib3hbMV1dKSwgbW9kZWxNYXRyaXgudHJhbnNmb3JtQXNQb2ludChbYmJveFswXSwgYmJveFszXV0pLCBtb2RlbE1hdHJpeC50cmFuc2Zvcm1Bc1BvaW50KFtiYm94WzJdLCBiYm94WzNdXSldO1xuICBjb25zdCB0cmFuc2Zvcm1lZEJveCA9IFtNYXRoLm1pbiguLi50cmFuc2Zvcm1lZENvb3Jkcy5tYXAoaSA9PiBpWzBdKSksIE1hdGgubWluKC4uLnRyYW5zZm9ybWVkQ29vcmRzLm1hcChpID0+IGlbMV0pKSwgTWF0aC5tYXgoLi4udHJhbnNmb3JtZWRDb29yZHMubWFwKGkgPT4gaVswXSkpLCBNYXRoLm1heCguLi50cmFuc2Zvcm1lZENvb3Jkcy5tYXAoaSA9PiBpWzFdKSldO1xuICByZXR1cm4gdHJhbnNmb3JtZWRCb3g7XG59XG5cbmZ1bmN0aW9uIHN0cmluZ0hhc2gocykge1xuICByZXR1cm4gTWF0aC5hYnMocy5zcGxpdCgnJykucmVkdWNlKChhLCBiKSA9PiAoYSA8PCA1KSAtIGEgKyBiLmNoYXJDb2RlQXQoMCkgfCAwLCAwKSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRVUkxGcm9tVGVtcGxhdGUodGVtcGxhdGUsIHRpbGUpIHtcbiAgaWYgKCF0ZW1wbGF0ZSB8fCAhdGVtcGxhdGUubGVuZ3RoKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBjb25zdCB7XG4gICAgaW5kZXgsXG4gICAgaWRcbiAgfSA9IHRpbGU7XG5cbiAgaWYgKEFycmF5LmlzQXJyYXkodGVtcGxhdGUpKSB7XG4gICAgY29uc3QgaSA9IHN0cmluZ0hhc2goaWQpICUgdGVtcGxhdGUubGVuZ3RoO1xuICAgIHRlbXBsYXRlID0gdGVtcGxhdGVbaV07XG4gIH1cblxuICBsZXQgdXJsID0gdGVtcGxhdGU7XG5cbiAgZm9yIChjb25zdCBrZXkgb2YgT2JqZWN0LmtleXMoaW5kZXgpKSB7XG4gICAgY29uc3QgcmVnZXggPSBuZXcgUmVnRXhwKFwie1wiLmNvbmNhdChrZXksIFwifVwiKSwgJ2cnKTtcbiAgICB1cmwgPSB1cmwucmVwbGFjZShyZWdleCwgU3RyaW5nKGluZGV4W2tleV0pKTtcbiAgfVxuXG4gIGlmIChOdW1iZXIuaXNJbnRlZ2VyKGluZGV4LnkpICYmIE51bWJlci5pc0ludGVnZXIoaW5kZXgueikpIHtcbiAgICB1cmwgPSB1cmwucmVwbGFjZSgvXFx7LXlcXH0vZywgU3RyaW5nKE1hdGgucG93KDIsIGluZGV4LnopIC0gaW5kZXgueSAtIDEpKTtcbiAgfVxuXG4gIHJldHVybiB1cmw7XG59XG5cbmZ1bmN0aW9uIGdldEJvdW5kaW5nQm94KHZpZXdwb3J0LCB6UmFuZ2UsIGV4dGVudCkge1xuICBsZXQgYm91bmRzO1xuXG4gIGlmICh6UmFuZ2UgJiYgelJhbmdlLmxlbmd0aCA9PT0gMikge1xuICAgIGNvbnN0IFttaW5aLCBtYXhaXSA9IHpSYW5nZTtcbiAgICBjb25zdCBib3VuZHMwID0gdmlld3BvcnQuZ2V0Qm91bmRzKHtcbiAgICAgIHo6IG1pblpcbiAgICB9KTtcbiAgICBjb25zdCBib3VuZHMxID0gdmlld3BvcnQuZ2V0Qm91bmRzKHtcbiAgICAgIHo6IG1heFpcbiAgICB9KTtcbiAgICBib3VuZHMgPSBbTWF0aC5taW4oYm91bmRzMFswXSwgYm91bmRzMVswXSksIE1hdGgubWluKGJvdW5kczBbMV0sIGJvdW5kczFbMV0pLCBNYXRoLm1heChib3VuZHMwWzJdLCBib3VuZHMxWzJdKSwgTWF0aC5tYXgoYm91bmRzMFszXSwgYm91bmRzMVszXSldO1xuICB9IGVsc2Uge1xuICAgIGJvdW5kcyA9IHZpZXdwb3J0LmdldEJvdW5kcygpO1xuICB9XG5cbiAgaWYgKCF2aWV3cG9ydC5pc0dlb3NwYXRpYWwpIHtcbiAgICByZXR1cm4gW01hdGgubWF4KE1hdGgubWluKGJvdW5kc1swXSwgZXh0ZW50WzJdKSwgZXh0ZW50WzBdKSwgTWF0aC5tYXgoTWF0aC5taW4oYm91bmRzWzFdLCBleHRlbnRbM10pLCBleHRlbnRbMV0pLCBNYXRoLm1pbihNYXRoLm1heChib3VuZHNbMl0sIGV4dGVudFswXSksIGV4dGVudFsyXSksIE1hdGgubWluKE1hdGgubWF4KGJvdW5kc1szXSwgZXh0ZW50WzFdKSwgZXh0ZW50WzNdKV07XG4gIH1cblxuICByZXR1cm4gW01hdGgubWF4KGJvdW5kc1swXSwgZXh0ZW50WzBdKSwgTWF0aC5tYXgoYm91bmRzWzFdLCBleHRlbnRbMV0pLCBNYXRoLm1pbihib3VuZHNbMl0sIGV4dGVudFsyXSksIE1hdGgubWluKGJvdW5kc1szXSwgZXh0ZW50WzNdKV07XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRDdWxsQm91bmRzKHtcbiAgdmlld3BvcnQsXG4gIHogPSAwLFxuICBjdWxsUmVjdFxufSkge1xuICBjb25zdCBzdWJWaWV3cG9ydHMgPSB2aWV3cG9ydC5zdWJWaWV3cG9ydHMgfHwgW3ZpZXdwb3J0XTtcbiAgcmV0dXJuIHN1YlZpZXdwb3J0cy5tYXAodiA9PiBnZXRDdWxsQm91bmRzSW5WaWV3cG9ydCh2LCB6LCBjdWxsUmVjdCkpO1xufVxuXG5mdW5jdGlvbiBnZXRDdWxsQm91bmRzSW5WaWV3cG9ydCh2aWV3cG9ydCwgeiwgY3VsbFJlY3QpIHtcbiAgaWYgKCFBcnJheS5pc0FycmF5KHopKSB7XG4gICAgY29uc3QgeCA9IGN1bGxSZWN0LnggLSB2aWV3cG9ydC54O1xuICAgIGNvbnN0IHkgPSBjdWxsUmVjdC55IC0gdmlld3BvcnQueTtcbiAgICBjb25zdCB7XG4gICAgICB3aWR0aCxcbiAgICAgIGhlaWdodFxuICAgIH0gPSBjdWxsUmVjdDtcbiAgICBjb25zdCB1bnByb2plY3RPcHRpb24gPSB7XG4gICAgICB0YXJnZXRaOiB6XG4gICAgfTtcbiAgICBjb25zdCB0b3BMZWZ0ID0gdmlld3BvcnQudW5wcm9qZWN0KFt4LCB5XSwgdW5wcm9qZWN0T3B0aW9uKTtcbiAgICBjb25zdCB0b3BSaWdodCA9IHZpZXdwb3J0LnVucHJvamVjdChbeCArIHdpZHRoLCB5XSwgdW5wcm9qZWN0T3B0aW9uKTtcbiAgICBjb25zdCBib3R0b21MZWZ0ID0gdmlld3BvcnQudW5wcm9qZWN0KFt4LCB5ICsgaGVpZ2h0XSwgdW5wcm9qZWN0T3B0aW9uKTtcbiAgICBjb25zdCBib3R0b21SaWdodCA9IHZpZXdwb3J0LnVucHJvamVjdChbeCArIHdpZHRoLCB5ICsgaGVpZ2h0XSwgdW5wcm9qZWN0T3B0aW9uKTtcbiAgICByZXR1cm4gW01hdGgubWluKHRvcExlZnRbMF0sIHRvcFJpZ2h0WzBdLCBib3R0b21MZWZ0WzBdLCBib3R0b21SaWdodFswXSksIE1hdGgubWluKHRvcExlZnRbMV0sIHRvcFJpZ2h0WzFdLCBib3R0b21MZWZ0WzFdLCBib3R0b21SaWdodFsxXSksIE1hdGgubWF4KHRvcExlZnRbMF0sIHRvcFJpZ2h0WzBdLCBib3R0b21MZWZ0WzBdLCBib3R0b21SaWdodFswXSksIE1hdGgubWF4KHRvcExlZnRbMV0sIHRvcFJpZ2h0WzFdLCBib3R0b21MZWZ0WzFdLCBib3R0b21SaWdodFsxXSldO1xuICB9XG5cbiAgY29uc3QgYm91bmRzMCA9IGdldEN1bGxCb3VuZHNJblZpZXdwb3J0KHZpZXdwb3J0LCB6WzBdLCBjdWxsUmVjdCk7XG4gIGNvbnN0IGJvdW5kczEgPSBnZXRDdWxsQm91bmRzSW5WaWV3cG9ydCh2aWV3cG9ydCwgelsxXSwgY3VsbFJlY3QpO1xuICByZXR1cm4gW01hdGgubWluKGJvdW5kczBbMF0sIGJvdW5kczFbMF0pLCBNYXRoLm1pbihib3VuZHMwWzFdLCBib3VuZHMxWzFdKSwgTWF0aC5tYXgoYm91bmRzMFsyXSwgYm91bmRzMVsyXSksIE1hdGgubWF4KGJvdW5kczBbM10sIGJvdW5kczFbM10pXTtcbn1cblxuZnVuY3Rpb24gZ2V0SW5kZXhpbmdDb29yZHMoYmJveCwgc2NhbGUsIG1vZGVsTWF0cml4SW52ZXJzZSkge1xuICBpZiAobW9kZWxNYXRyaXhJbnZlcnNlKSB7XG4gICAgY29uc3QgdHJhbnNmb3JtZWRUaWxlSW5kZXggPSB0cmFuc2Zvcm1Cb3goYmJveCwgbW9kZWxNYXRyaXhJbnZlcnNlKS5tYXAoaSA9PiBpICogc2NhbGUgLyBUSUxFX1NJWkUpO1xuICAgIHJldHVybiB0cmFuc2Zvcm1lZFRpbGVJbmRleDtcbiAgfVxuXG4gIHJldHVybiBiYm94Lm1hcChpID0+IGkgKiBzY2FsZSAvIFRJTEVfU0laRSk7XG59XG5cbmZ1bmN0aW9uIGdldFNjYWxlKHosIHRpbGVTaXplKSB7XG4gIHJldHVybiBNYXRoLnBvdygyLCB6KSAqIFRJTEVfU0laRSAvIHRpbGVTaXplO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gb3NtVGlsZTJsbmdMYXQoeCwgeSwgeikge1xuICBjb25zdCBzY2FsZSA9IGdldFNjYWxlKHosIFRJTEVfU0laRSk7XG4gIGNvbnN0IGxuZyA9IHggLyBzY2FsZSAqIDM2MCAtIDE4MDtcbiAgY29uc3QgbiA9IE1hdGguUEkgLSAyICogTWF0aC5QSSAqIHkgLyBzY2FsZTtcbiAgY29uc3QgbGF0ID0gMTgwIC8gTWF0aC5QSSAqIE1hdGguYXRhbigwLjUgKiAoTWF0aC5leHAobikgLSBNYXRoLmV4cCgtbikpKTtcbiAgcmV0dXJuIFtsbmcsIGxhdF07XG59XG5cbmZ1bmN0aW9uIHRpbGUyWFkoeCwgeSwgeiwgdGlsZVNpemUpIHtcbiAgY29uc3Qgc2NhbGUgPSBnZXRTY2FsZSh6LCB0aWxlU2l6ZSk7XG4gIHJldHVybiBbeCAvIHNjYWxlICogVElMRV9TSVpFLCB5IC8gc2NhbGUgKiBUSUxFX1NJWkVdO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gdGlsZVRvQm91bmRpbmdCb3godmlld3BvcnQsIHgsIHksIHosIHRpbGVTaXplID0gVElMRV9TSVpFKSB7XG4gIGlmICh2aWV3cG9ydC5pc0dlb3NwYXRpYWwpIHtcbiAgICBjb25zdCBbd2VzdCwgbm9ydGhdID0gb3NtVGlsZTJsbmdMYXQoeCwgeSwgeik7XG4gICAgY29uc3QgW2Vhc3QsIHNvdXRoXSA9IG9zbVRpbGUybG5nTGF0KHggKyAxLCB5ICsgMSwgeik7XG4gICAgcmV0dXJuIHtcbiAgICAgIHdlc3QsXG4gICAgICBub3J0aCxcbiAgICAgIGVhc3QsXG4gICAgICBzb3V0aFxuICAgIH07XG4gIH1cblxuICBjb25zdCBbbGVmdCwgdG9wXSA9IHRpbGUyWFkoeCwgeSwgeiwgdGlsZVNpemUpO1xuICBjb25zdCBbcmlnaHQsIGJvdHRvbV0gPSB0aWxlMlhZKHggKyAxLCB5ICsgMSwgeiwgdGlsZVNpemUpO1xuICByZXR1cm4ge1xuICAgIGxlZnQsXG4gICAgdG9wLFxuICAgIHJpZ2h0LFxuICAgIGJvdHRvbVxuICB9O1xufVxuXG5mdW5jdGlvbiBnZXRJZGVudGl0eVRpbGVJbmRpY2VzKHZpZXdwb3J0LCB6LCB0aWxlU2l6ZSwgZXh0ZW50LCBtb2RlbE1hdHJpeEludmVyc2UpIHtcbiAgY29uc3QgYmJveCA9IGdldEJvdW5kaW5nQm94KHZpZXdwb3J0LCBudWxsLCBleHRlbnQpO1xuICBjb25zdCBzY2FsZSA9IGdldFNjYWxlKHosIHRpbGVTaXplKTtcbiAgY29uc3QgW21pblgsIG1pblksIG1heFgsIG1heFldID0gZ2V0SW5kZXhpbmdDb29yZHMoYmJveCwgc2NhbGUsIG1vZGVsTWF0cml4SW52ZXJzZSk7XG4gIGNvbnN0IGluZGljZXMgPSBbXTtcblxuICBmb3IgKGxldCB4ID0gTWF0aC5mbG9vcihtaW5YKTsgeCA8IG1heFg7IHgrKykge1xuICAgIGZvciAobGV0IHkgPSBNYXRoLmZsb29yKG1pblkpOyB5IDwgbWF4WTsgeSsrKSB7XG4gICAgICBpbmRpY2VzLnB1c2goe1xuICAgICAgICB4LFxuICAgICAgICB5LFxuICAgICAgICB6XG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gaW5kaWNlcztcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdldFRpbGVJbmRpY2VzKHtcbiAgdmlld3BvcnQsXG4gIG1heFpvb20sXG4gIG1pblpvb20sXG4gIHpSYW5nZSxcbiAgZXh0ZW50LFxuICB0aWxlU2l6ZSA9IFRJTEVfU0laRSxcbiAgbW9kZWxNYXRyaXgsXG4gIG1vZGVsTWF0cml4SW52ZXJzZSxcbiAgem9vbU9mZnNldCA9IDBcbn0pIHtcbiAgbGV0IHogPSB2aWV3cG9ydC5pc0dlb3NwYXRpYWwgPyBNYXRoLnJvdW5kKHZpZXdwb3J0Lnpvb20gKyBNYXRoLmxvZzIoVElMRV9TSVpFIC8gdGlsZVNpemUpKSArIHpvb21PZmZzZXQgOiBNYXRoLmNlaWwodmlld3BvcnQuem9vbSkgKyB6b29tT2Zmc2V0O1xuXG4gIGlmICh0eXBlb2YgbWluWm9vbSA9PT0gJ251bWJlcicgJiYgTnVtYmVyLmlzRmluaXRlKG1pblpvb20pICYmIHogPCBtaW5ab29tKSB7XG4gICAgaWYgKCFleHRlbnQpIHtcbiAgICAgIHJldHVybiBbXTtcbiAgICB9XG5cbiAgICB6ID0gbWluWm9vbTtcbiAgfVxuXG4gIGlmICh0eXBlb2YgbWF4Wm9vbSA9PT0gJ251bWJlcicgJiYgTnVtYmVyLmlzRmluaXRlKG1heFpvb20pICYmIHogPiBtYXhab29tKSB7XG4gICAgeiA9IG1heFpvb207XG4gIH1cblxuICBsZXQgdHJhbnNmb3JtZWRFeHRlbnQgPSBleHRlbnQ7XG5cbiAgaWYgKG1vZGVsTWF0cml4ICYmIG1vZGVsTWF0cml4SW52ZXJzZSAmJiBleHRlbnQgJiYgIXZpZXdwb3J0LmlzR2Vvc3BhdGlhbCkge1xuICAgIHRyYW5zZm9ybWVkRXh0ZW50ID0gdHJhbnNmb3JtQm94KGV4dGVudCwgbW9kZWxNYXRyaXgpO1xuICB9XG5cbiAgcmV0dXJuIHZpZXdwb3J0LmlzR2Vvc3BhdGlhbCA/IGdldE9TTVRpbGVJbmRpY2VzKHZpZXdwb3J0LCB6LCB6UmFuZ2UsIGV4dGVudCkgOiBnZXRJZGVudGl0eVRpbGVJbmRpY2VzKHZpZXdwb3J0LCB6LCB0aWxlU2l6ZSwgdHJhbnNmb3JtZWRFeHRlbnQgfHwgREVGQVVMVF9FWFRFTlQsIG1vZGVsTWF0cml4SW52ZXJzZSk7XG59XG5leHBvcnQgZnVuY3Rpb24gaXNVUkxUZW1wbGF0ZShzKSB7XG4gIHJldHVybiAvKD89Lip7en0pKD89Lip7eH0pKD89Liooe3l9fHsteX0pKS8udGVzdChzKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBpc0dlb0JvdW5kaW5nQm94KHYpIHtcbiAgcmV0dXJuIE51bWJlci5pc0Zpbml0ZSh2Lndlc3QpICYmIE51bWJlci5pc0Zpbml0ZSh2Lm5vcnRoKSAmJiBOdW1iZXIuaXNGaW5pdGUodi5lYXN0KSAmJiBOdW1iZXIuaXNGaW5pdGUodi5zb3V0aCk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD11dGlscy5qcy5tYXAiLCJleHBvcnQgZnVuY3Rpb24gbWVtb2l6ZShjb21wdXRlKSB7XG4gIGxldCBjYWNoZWRBcmdzID0ge307XG4gIGxldCBjYWNoZWRSZXN1bHQ7XG4gIHJldHVybiBhcmdzID0+IHtcbiAgICBmb3IgKGNvbnN0IGtleSBpbiBhcmdzKSB7XG4gICAgICBpZiAoIWlzRXF1YWwoYXJnc1trZXldLCBjYWNoZWRBcmdzW2tleV0pKSB7XG4gICAgICAgIGNhY2hlZFJlc3VsdCA9IGNvbXB1dGUoYXJncyk7XG4gICAgICAgIGNhY2hlZEFyZ3MgPSBhcmdzO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gY2FjaGVkUmVzdWx0O1xuICB9O1xufVxuXG5mdW5jdGlvbiBpc0VxdWFsKGEsIGIpIHtcbiAgaWYgKGEgPT09IGIpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIGlmIChBcnJheS5pc0FycmF5KGEpKSB7XG4gICAgY29uc3QgbGVuID0gYS5sZW5ndGg7XG5cbiAgICBpZiAoIWIgfHwgYi5sZW5ndGggIT09IGxlbikge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIGlmIChhW2ldICE9PSBiW2ldKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW1lbW9pemUuanMubWFwIiwiaW1wb3J0IF9kZWZpbmVQcm9wZXJ0eSBmcm9tIFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vZGVmaW5lUHJvcGVydHlcIjtcbmltcG9ydCB7IFJlcXVlc3RTY2hlZHVsZXIgfSBmcm9tICdAbG9hZGVycy5nbC9sb2FkZXItdXRpbHMnO1xuaW1wb3J0IHsgTWF0cml4NCwgZXF1YWxzIH0gZnJvbSAnQG1hdGguZ2wvY29yZSc7XG5pbXBvcnQgeyBUaWxlMkRIZWFkZXIgfSBmcm9tICcuL3RpbGUtMmQtaGVhZGVyJztcbmltcG9ydCB7IGdldFRpbGVJbmRpY2VzLCB0aWxlVG9Cb3VuZGluZ0JveCwgZ2V0Q3VsbEJvdW5kcyB9IGZyb20gJy4vdXRpbHMnO1xuaW1wb3J0IHsgbWVtb2l6ZSB9IGZyb20gJy4vbWVtb2l6ZSc7XG5jb25zdCBUSUxFX1NUQVRFX1ZJU0lURUQgPSAxO1xuY29uc3QgVElMRV9TVEFURV9WSVNJQkxFID0gMjtcbmV4cG9ydCBjb25zdCBTVFJBVEVHWV9ORVZFUiA9ICduZXZlcic7XG5leHBvcnQgY29uc3QgU1RSQVRFR1lfUkVQTEFDRSA9ICduby1vdmVybGFwJztcbmV4cG9ydCBjb25zdCBTVFJBVEVHWV9ERUZBVUxUID0gJ2Jlc3QtYXZhaWxhYmxlJztcbmNvbnN0IERFRkFVTFRfQ0FDSEVfU0NBTEUgPSA1O1xuY29uc3QgU1RSQVRFR0lFUyA9IHtcbiAgW1NUUkFURUdZX0RFRkFVTFRdOiB1cGRhdGVUaWxlU3RhdGVEZWZhdWx0LFxuICBbU1RSQVRFR1lfUkVQTEFDRV06IHVwZGF0ZVRpbGVTdGF0ZVJlcGxhY2UsXG4gIFtTVFJBVEVHWV9ORVZFUl06ICgpID0+IHt9XG59O1xuZXhwb3J0IGNvbnN0IERFRkFVTFRfVElMRVNFVDJEX1BST1BTID0ge1xuICBleHRlbnQ6IG51bGwsXG4gIHRpbGVTaXplOiA1MTIsXG4gIG1heFpvb206IG51bGwsXG4gIG1pblpvb206IG51bGwsXG4gIG1heENhY2hlU2l6ZTogbnVsbCxcbiAgbWF4Q2FjaGVCeXRlU2l6ZTogbnVsbCxcbiAgcmVmaW5lbWVudFN0cmF0ZWd5OiAnYmVzdC1hdmFpbGFibGUnLFxuICB6UmFuZ2U6IG51bGwsXG4gIG1heFJlcXVlc3RzOiA2LFxuICB6b29tT2Zmc2V0OiAwLFxuICBvblRpbGVMb2FkOiAoKSA9PiB7fSxcbiAgb25UaWxlVW5sb2FkOiAoKSA9PiB7fSxcbiAgb25UaWxlRXJyb3I6ICgpID0+IHt9XG59O1xuZXhwb3J0IGNsYXNzIFRpbGVzZXQyRCB7XG4gIGNvbnN0cnVjdG9yKG9wdHMpIHtcbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJvcHRzXCIsIHZvaWQgMCk7XG5cbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJfcmVxdWVzdFNjaGVkdWxlclwiLCB2b2lkIDApO1xuXG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwiX2NhY2hlXCIsIHZvaWQgMCk7XG5cbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJfZGlydHlcIiwgdm9pZCAwKTtcblxuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIl90aWxlc1wiLCB2b2lkIDApO1xuXG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwiX2NhY2hlQnl0ZVNpemVcIiwgdm9pZCAwKTtcblxuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIl92aWV3cG9ydFwiLCB2b2lkIDApO1xuXG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwiX3pSYW5nZVwiLCB2b2lkIDApO1xuXG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwiX3NlbGVjdGVkVGlsZXNcIiwgdm9pZCAwKTtcblxuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIl9mcmFtZU51bWJlclwiLCB2b2lkIDApO1xuXG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwiX21vZGVsTWF0cml4XCIsIHZvaWQgMCk7XG5cbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJfbW9kZWxNYXRyaXhJbnZlcnNlXCIsIHZvaWQgMCk7XG5cbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJfbWF4Wm9vbVwiLCB2b2lkIDApO1xuXG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwiX21pblpvb21cIiwgdm9pZCAwKTtcblxuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIm9uVGlsZUxvYWRcIiwgdm9pZCAwKTtcblxuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIl9nZXRDdWxsQm91bmRzXCIsIG1lbW9pemUoZ2V0Q3VsbEJvdW5kcykpO1xuXG4gICAgdGhpcy5vcHRzID0geyAuLi5ERUZBVUxUX1RJTEVTRVQyRF9QUk9QUyxcbiAgICAgIC4uLm9wdHNcbiAgICB9O1xuXG4gICAgdGhpcy5vblRpbGVMb2FkID0gdGlsZSA9PiB7XG4gICAgICB2YXIgX3RoaXMkb3B0cyRvblRpbGVMb2FkLCBfdGhpcyRvcHRzO1xuXG4gICAgICAoX3RoaXMkb3B0cyRvblRpbGVMb2FkID0gKF90aGlzJG9wdHMgPSB0aGlzLm9wdHMpLm9uVGlsZUxvYWQpID09PSBudWxsIHx8IF90aGlzJG9wdHMkb25UaWxlTG9hZCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX3RoaXMkb3B0cyRvblRpbGVMb2FkLmNhbGwoX3RoaXMkb3B0cywgdGlsZSk7XG5cbiAgICAgIGlmICh0aGlzLm9wdHMubWF4Q2FjaGVCeXRlU2l6ZSkge1xuICAgICAgICB0aGlzLl9jYWNoZUJ5dGVTaXplICs9IHRpbGUuYnl0ZUxlbmd0aDtcblxuICAgICAgICB0aGlzLl9yZXNpemVDYWNoZSgpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICB0aGlzLl9yZXF1ZXN0U2NoZWR1bGVyID0gbmV3IFJlcXVlc3RTY2hlZHVsZXIoe1xuICAgICAgbWF4UmVxdWVzdHM6IG9wdHMubWF4UmVxdWVzdHMsXG4gICAgICB0aHJvdHRsZVJlcXVlc3RzOiBCb29sZWFuKG9wdHMubWF4UmVxdWVzdHMgJiYgb3B0cy5tYXhSZXF1ZXN0cyA+IDApXG4gICAgfSk7XG4gICAgdGhpcy5fY2FjaGUgPSBuZXcgTWFwKCk7XG4gICAgdGhpcy5fdGlsZXMgPSBbXTtcbiAgICB0aGlzLl9kaXJ0eSA9IGZhbHNlO1xuICAgIHRoaXMuX2NhY2hlQnl0ZVNpemUgPSAwO1xuICAgIHRoaXMuX3ZpZXdwb3J0ID0gbnVsbDtcbiAgICB0aGlzLl9zZWxlY3RlZFRpbGVzID0gbnVsbDtcbiAgICB0aGlzLl9mcmFtZU51bWJlciA9IDA7XG4gICAgdGhpcy5fbW9kZWxNYXRyaXggPSBuZXcgTWF0cml4NCgpO1xuICAgIHRoaXMuX21vZGVsTWF0cml4SW52ZXJzZSA9IG5ldyBNYXRyaXg0KCk7XG4gICAgdGhpcy5zZXRPcHRpb25zKG9wdHMpO1xuICB9XG5cbiAgZ2V0IHRpbGVzKCkge1xuICAgIHJldHVybiB0aGlzLl90aWxlcztcbiAgfVxuXG4gIGdldCBzZWxlY3RlZFRpbGVzKCkge1xuICAgIHJldHVybiB0aGlzLl9zZWxlY3RlZFRpbGVzO1xuICB9XG5cbiAgZ2V0IGlzTG9hZGVkKCkge1xuICAgIHJldHVybiB0aGlzLl9zZWxlY3RlZFRpbGVzICE9PSBudWxsICYmIHRoaXMuX3NlbGVjdGVkVGlsZXMuZXZlcnkodGlsZSA9PiB0aWxlLmlzTG9hZGVkKTtcbiAgfVxuXG4gIGdldCBuZWVkc1JlbG9hZCgpIHtcbiAgICByZXR1cm4gdGhpcy5fc2VsZWN0ZWRUaWxlcyAhPT0gbnVsbCAmJiB0aGlzLl9zZWxlY3RlZFRpbGVzLnNvbWUodGlsZSA9PiB0aWxlLm5lZWRzUmVsb2FkKTtcbiAgfVxuXG4gIHNldE9wdGlvbnMob3B0cykge1xuICAgIE9iamVjdC5hc3NpZ24odGhpcy5vcHRzLCBvcHRzKTtcblxuICAgIGlmIChOdW1iZXIuaXNGaW5pdGUob3B0cy5tYXhab29tKSkge1xuICAgICAgdGhpcy5fbWF4Wm9vbSA9IE1hdGguZmxvb3Iob3B0cy5tYXhab29tKTtcbiAgICB9XG5cbiAgICBpZiAoTnVtYmVyLmlzRmluaXRlKG9wdHMubWluWm9vbSkpIHtcbiAgICAgIHRoaXMuX21pblpvb20gPSBNYXRoLmNlaWwob3B0cy5taW5ab29tKTtcbiAgICB9XG4gIH1cblxuICBmaW5hbGl6ZSgpIHtcbiAgICBmb3IgKGNvbnN0IHRpbGUgb2YgdGhpcy5fY2FjaGUudmFsdWVzKCkpIHtcbiAgICAgIGlmICh0aWxlLmlzTG9hZGluZykge1xuICAgICAgICB0aWxlLmFib3J0KCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy5fY2FjaGUuY2xlYXIoKTtcblxuICAgIHRoaXMuX3RpbGVzID0gW107XG4gICAgdGhpcy5fc2VsZWN0ZWRUaWxlcyA9IG51bGw7XG4gIH1cblxuICByZWxvYWRBbGwoKSB7XG4gICAgZm9yIChjb25zdCBpZCBvZiB0aGlzLl9jYWNoZS5rZXlzKCkpIHtcbiAgICAgIGNvbnN0IHRpbGUgPSB0aGlzLl9jYWNoZS5nZXQoaWQpO1xuXG4gICAgICBpZiAoIXRoaXMuX3NlbGVjdGVkVGlsZXMgfHwgIXRoaXMuX3NlbGVjdGVkVGlsZXMuaW5jbHVkZXModGlsZSkpIHtcbiAgICAgICAgdGhpcy5fY2FjaGUuZGVsZXRlKGlkKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRpbGUuc2V0TmVlZHNSZWxvYWQoKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICB1cGRhdGUodmlld3BvcnQsIHtcbiAgICB6UmFuZ2UsXG4gICAgbW9kZWxNYXRyaXhcbiAgfSA9IHt9KSB7XG4gICAgY29uc3QgbW9kZWxNYXRyaXhBc01hdHJpeDQgPSBuZXcgTWF0cml4NChtb2RlbE1hdHJpeCk7XG4gICAgY29uc3QgaXNNb2RlbE1hdHJpeE5ldyA9ICFtb2RlbE1hdHJpeEFzTWF0cml4NC5lcXVhbHModGhpcy5fbW9kZWxNYXRyaXgpO1xuXG4gICAgaWYgKCF0aGlzLl92aWV3cG9ydCB8fCAhdmlld3BvcnQuZXF1YWxzKHRoaXMuX3ZpZXdwb3J0KSB8fCAhZXF1YWxzKHRoaXMuX3pSYW5nZSwgelJhbmdlKSB8fCBpc01vZGVsTWF0cml4TmV3KSB7XG4gICAgICBpZiAoaXNNb2RlbE1hdHJpeE5ldykge1xuICAgICAgICB0aGlzLl9tb2RlbE1hdHJpeEludmVyc2UgPSBtb2RlbE1hdHJpeEFzTWF0cml4NC5jbG9uZSgpLmludmVydCgpO1xuICAgICAgICB0aGlzLl9tb2RlbE1hdHJpeCA9IG1vZGVsTWF0cml4QXNNYXRyaXg0O1xuICAgICAgfVxuXG4gICAgICB0aGlzLl92aWV3cG9ydCA9IHZpZXdwb3J0O1xuICAgICAgdGhpcy5felJhbmdlID0gelJhbmdlO1xuICAgICAgY29uc3QgdGlsZUluZGljZXMgPSB0aGlzLmdldFRpbGVJbmRpY2VzKHtcbiAgICAgICAgdmlld3BvcnQsXG4gICAgICAgIG1heFpvb206IHRoaXMuX21heFpvb20sXG4gICAgICAgIG1pblpvb206IHRoaXMuX21pblpvb20sXG4gICAgICAgIHpSYW5nZSxcbiAgICAgICAgbW9kZWxNYXRyaXg6IHRoaXMuX21vZGVsTWF0cml4LFxuICAgICAgICBtb2RlbE1hdHJpeEludmVyc2U6IHRoaXMuX21vZGVsTWF0cml4SW52ZXJzZVxuICAgICAgfSk7XG4gICAgICB0aGlzLl9zZWxlY3RlZFRpbGVzID0gdGlsZUluZGljZXMubWFwKGluZGV4ID0+IHRoaXMuX2dldFRpbGUoaW5kZXgsIHRydWUpKTtcblxuICAgICAgaWYgKHRoaXMuX2RpcnR5KSB7XG4gICAgICAgIHRoaXMuX3JlYnVpbGRUcmVlKCk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICh0aGlzLm5lZWRzUmVsb2FkKSB7XG4gICAgICB0aGlzLl9zZWxlY3RlZFRpbGVzID0gdGhpcy5fc2VsZWN0ZWRUaWxlcy5tYXAodGlsZSA9PiB0aGlzLl9nZXRUaWxlKHRpbGUuaW5kZXgsIHRydWUpKTtcbiAgICB9XG5cbiAgICBjb25zdCBjaGFuZ2VkID0gdGhpcy51cGRhdGVUaWxlU3RhdGVzKCk7XG5cbiAgICB0aGlzLl9wcnVuZVJlcXVlc3RzKCk7XG5cbiAgICBpZiAodGhpcy5fZGlydHkpIHtcbiAgICAgIHRoaXMuX3Jlc2l6ZUNhY2hlKCk7XG4gICAgfVxuXG4gICAgaWYgKGNoYW5nZWQpIHtcbiAgICAgIHRoaXMuX2ZyYW1lTnVtYmVyKys7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuX2ZyYW1lTnVtYmVyO1xuICB9XG5cbiAgaXNUaWxlVmlzaWJsZSh0aWxlLCBjdWxsUmVjdCkge1xuICAgIGlmICghdGlsZS5pc1Zpc2libGUpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBpZiAoY3VsbFJlY3QgJiYgdGhpcy5fdmlld3BvcnQpIHtcbiAgICAgIGNvbnN0IGJvdW5kc0FyciA9IHRoaXMuX2dldEN1bGxCb3VuZHMoe1xuICAgICAgICB2aWV3cG9ydDogdGhpcy5fdmlld3BvcnQsXG4gICAgICAgIHo6IHRoaXMuX3pSYW5nZSxcbiAgICAgICAgY3VsbFJlY3RcbiAgICAgIH0pO1xuXG4gICAgICBjb25zdCB7XG4gICAgICAgIGJib3hcbiAgICAgIH0gPSB0aWxlO1xuXG4gICAgICBmb3IgKGNvbnN0IFttaW5YLCBtaW5ZLCBtYXhYLCBtYXhZXSBvZiBib3VuZHNBcnIpIHtcbiAgICAgICAgbGV0IG92ZXJsYXBzO1xuXG4gICAgICAgIGlmICgnd2VzdCcgaW4gYmJveCkge1xuICAgICAgICAgIG92ZXJsYXBzID0gYmJveC53ZXN0IDwgbWF4WCAmJiBiYm94LmVhc3QgPiBtaW5YICYmIGJib3guc291dGggPCBtYXhZICYmIGJib3gubm9ydGggPiBtaW5ZO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvbnN0IHkwID0gTWF0aC5taW4oYmJveC50b3AsIGJib3guYm90dG9tKTtcbiAgICAgICAgICBjb25zdCB5MSA9IE1hdGgubWF4KGJib3gudG9wLCBiYm94LmJvdHRvbSk7XG4gICAgICAgICAgb3ZlcmxhcHMgPSBiYm94LmxlZnQgPCBtYXhYICYmIGJib3gucmlnaHQgPiBtaW5YICYmIHkwIDwgbWF4WSAmJiB5MSA+IG1pblk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAob3ZlcmxhcHMpIHtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICBnZXRUaWxlSW5kaWNlcyh7XG4gICAgdmlld3BvcnQsXG4gICAgbWF4Wm9vbSxcbiAgICBtaW5ab29tLFxuICAgIHpSYW5nZSxcbiAgICBtb2RlbE1hdHJpeCxcbiAgICBtb2RlbE1hdHJpeEludmVyc2VcbiAgfSkge1xuICAgIGNvbnN0IHtcbiAgICAgIHRpbGVTaXplLFxuICAgICAgZXh0ZW50LFxuICAgICAgem9vbU9mZnNldFxuICAgIH0gPSB0aGlzLm9wdHM7XG4gICAgcmV0dXJuIGdldFRpbGVJbmRpY2VzKHtcbiAgICAgIHZpZXdwb3J0LFxuICAgICAgbWF4Wm9vbSxcbiAgICAgIG1pblpvb20sXG4gICAgICB6UmFuZ2UsXG4gICAgICB0aWxlU2l6ZSxcbiAgICAgIGV4dGVudDogZXh0ZW50LFxuICAgICAgbW9kZWxNYXRyaXgsXG4gICAgICBtb2RlbE1hdHJpeEludmVyc2UsXG4gICAgICB6b29tT2Zmc2V0XG4gICAgfSk7XG4gIH1cblxuICBnZXRUaWxlSWQoaW5kZXgpIHtcbiAgICByZXR1cm4gXCJcIi5jb25jYXQoaW5kZXgueCwgXCItXCIpLmNvbmNhdChpbmRleC55LCBcIi1cIikuY29uY2F0KGluZGV4LnopO1xuICB9XG5cbiAgZ2V0VGlsZVpvb20oaW5kZXgpIHtcbiAgICByZXR1cm4gaW5kZXguejtcbiAgfVxuXG4gIGdldFRpbGVNZXRhZGF0YShpbmRleCkge1xuICAgIGNvbnN0IHtcbiAgICAgIHRpbGVTaXplXG4gICAgfSA9IHRoaXMub3B0cztcbiAgICByZXR1cm4ge1xuICAgICAgYmJveDogdGlsZVRvQm91bmRpbmdCb3godGhpcy5fdmlld3BvcnQsIGluZGV4LngsIGluZGV4LnksIGluZGV4LnosIHRpbGVTaXplKVxuICAgIH07XG4gIH1cblxuICBnZXRQYXJlbnRJbmRleChpbmRleCkge1xuICAgIGNvbnN0IHggPSBNYXRoLmZsb29yKGluZGV4LnggLyAyKTtcbiAgICBjb25zdCB5ID0gTWF0aC5mbG9vcihpbmRleC55IC8gMik7XG4gICAgY29uc3QgeiA9IGluZGV4LnogLSAxO1xuICAgIHJldHVybiB7XG4gICAgICB4LFxuICAgICAgeSxcbiAgICAgIHpcbiAgICB9O1xuICB9XG5cbiAgdXBkYXRlVGlsZVN0YXRlcygpIHtcbiAgICBjb25zdCByZWZpbmVtZW50U3RyYXRlZ3kgPSB0aGlzLm9wdHMucmVmaW5lbWVudFN0cmF0ZWd5IHx8IFNUUkFURUdZX0RFRkFVTFQ7XG4gICAgY29uc3QgdmlzaWJpbGl0aWVzID0gbmV3IEFycmF5KHRoaXMuX2NhY2hlLnNpemUpO1xuICAgIGxldCBpID0gMDtcblxuICAgIGZvciAoY29uc3QgdGlsZSBvZiB0aGlzLl9jYWNoZS52YWx1ZXMoKSkge1xuICAgICAgdmlzaWJpbGl0aWVzW2krK10gPSB0aWxlLmlzVmlzaWJsZTtcbiAgICAgIHRpbGUuaXNTZWxlY3RlZCA9IGZhbHNlO1xuICAgICAgdGlsZS5pc1Zpc2libGUgPSBmYWxzZTtcbiAgICB9XG5cbiAgICBmb3IgKGNvbnN0IHRpbGUgb2YgdGhpcy5fc2VsZWN0ZWRUaWxlcykge1xuICAgICAgdGlsZS5pc1NlbGVjdGVkID0gdHJ1ZTtcbiAgICAgIHRpbGUuaXNWaXNpYmxlID0gdHJ1ZTtcbiAgICB9XG5cbiAgICAodHlwZW9mIHJlZmluZW1lbnRTdHJhdGVneSA9PT0gJ2Z1bmN0aW9uJyA/IHJlZmluZW1lbnRTdHJhdGVneSA6IFNUUkFURUdJRVNbcmVmaW5lbWVudFN0cmF0ZWd5XSkoQXJyYXkuZnJvbSh0aGlzLl9jYWNoZS52YWx1ZXMoKSkpO1xuICAgIGkgPSAwO1xuXG4gICAgZm9yIChjb25zdCB0aWxlIG9mIHRoaXMuX2NhY2hlLnZhbHVlcygpKSB7XG4gICAgICBpZiAodmlzaWJpbGl0aWVzW2krK10gIT09IHRpbGUuaXNWaXNpYmxlKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIF9wcnVuZVJlcXVlc3RzKCkge1xuICAgIGNvbnN0IHtcbiAgICAgIG1heFJlcXVlc3RzID0gMFxuICAgIH0gPSB0aGlzLm9wdHM7XG4gICAgY29uc3QgYWJvcnRDYW5kaWRhdGVzID0gW107XG4gICAgbGV0IG9uZ29pbmdSZXF1ZXN0Q291bnQgPSAwO1xuXG4gICAgZm9yIChjb25zdCB0aWxlIG9mIHRoaXMuX2NhY2hlLnZhbHVlcygpKSB7XG4gICAgICBpZiAodGlsZS5pc0xvYWRpbmcpIHtcbiAgICAgICAgb25nb2luZ1JlcXVlc3RDb3VudCsrO1xuXG4gICAgICAgIGlmICghdGlsZS5pc1NlbGVjdGVkICYmICF0aWxlLmlzVmlzaWJsZSkge1xuICAgICAgICAgIGFib3J0Q2FuZGlkYXRlcy5wdXNoKHRpbGUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgd2hpbGUgKG1heFJlcXVlc3RzID4gMCAmJiBvbmdvaW5nUmVxdWVzdENvdW50ID4gbWF4UmVxdWVzdHMgJiYgYWJvcnRDYW5kaWRhdGVzLmxlbmd0aCA+IDApIHtcbiAgICAgIGNvbnN0IHRpbGUgPSBhYm9ydENhbmRpZGF0ZXMuc2hpZnQoKTtcbiAgICAgIHRpbGUuYWJvcnQoKTtcbiAgICAgIG9uZ29pbmdSZXF1ZXN0Q291bnQtLTtcbiAgICB9XG4gIH1cblxuICBfcmVidWlsZFRyZWUoKSB7XG4gICAgY29uc3Qge1xuICAgICAgX2NhY2hlXG4gICAgfSA9IHRoaXM7XG5cbiAgICBmb3IgKGNvbnN0IHRpbGUgb2YgX2NhY2hlLnZhbHVlcygpKSB7XG4gICAgICB0aWxlLnBhcmVudCA9IG51bGw7XG5cbiAgICAgIGlmICh0aWxlLmNoaWxkcmVuKSB7XG4gICAgICAgIHRpbGUuY2hpbGRyZW4ubGVuZ3RoID0gMDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmb3IgKGNvbnN0IHRpbGUgb2YgX2NhY2hlLnZhbHVlcygpKSB7XG4gICAgICBjb25zdCBwYXJlbnQgPSB0aGlzLl9nZXROZWFyZXN0QW5jZXN0b3IodGlsZSk7XG5cbiAgICAgIHRpbGUucGFyZW50ID0gcGFyZW50O1xuXG4gICAgICBpZiAocGFyZW50ICE9PSBudWxsICYmIHBhcmVudCAhPT0gdm9pZCAwICYmIHBhcmVudC5jaGlsZHJlbikge1xuICAgICAgICBwYXJlbnQuY2hpbGRyZW4ucHVzaCh0aWxlKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBfcmVzaXplQ2FjaGUoKSB7XG4gICAgY29uc3Qge1xuICAgICAgX2NhY2hlLFxuICAgICAgb3B0c1xuICAgIH0gPSB0aGlzO1xuICAgIGNvbnN0IG1heENhY2hlU2l6ZSA9IG9wdHMubWF4Q2FjaGVTaXplIHx8IChvcHRzLm1heENhY2hlQnl0ZVNpemUgPyBJbmZpbml0eSA6IERFRkFVTFRfQ0FDSEVfU0NBTEUgKiB0aGlzLnNlbGVjdGVkVGlsZXMubGVuZ3RoKTtcbiAgICBjb25zdCBtYXhDYWNoZUJ5dGVTaXplID0gb3B0cy5tYXhDYWNoZUJ5dGVTaXplIHx8IEluZmluaXR5O1xuICAgIGNvbnN0IG92ZXJmbG93biA9IF9jYWNoZS5zaXplID4gbWF4Q2FjaGVTaXplIHx8IHRoaXMuX2NhY2hlQnl0ZVNpemUgPiBtYXhDYWNoZUJ5dGVTaXplO1xuXG4gICAgaWYgKG92ZXJmbG93bikge1xuICAgICAgZm9yIChjb25zdCBbaWQsIHRpbGVdIG9mIF9jYWNoZSkge1xuICAgICAgICBpZiAoIXRpbGUuaXNWaXNpYmxlICYmICF0aWxlLmlzU2VsZWN0ZWQpIHtcbiAgICAgICAgICB2YXIgX3RoaXMkb3B0cyRvblRpbGVVbmxvLCBfdGhpcyRvcHRzMjtcblxuICAgICAgICAgIHRoaXMuX2NhY2hlQnl0ZVNpemUgLT0gb3B0cy5tYXhDYWNoZUJ5dGVTaXplID8gdGlsZS5ieXRlTGVuZ3RoIDogMDtcblxuICAgICAgICAgIF9jYWNoZS5kZWxldGUoaWQpO1xuXG4gICAgICAgICAgKF90aGlzJG9wdHMkb25UaWxlVW5sbyA9IChfdGhpcyRvcHRzMiA9IHRoaXMub3B0cykub25UaWxlVW5sb2FkKSA9PT0gbnVsbCB8fCBfdGhpcyRvcHRzJG9uVGlsZVVubG8gPT09IHZvaWQgMCA/IHZvaWQgMCA6IF90aGlzJG9wdHMkb25UaWxlVW5sby5jYWxsKF90aGlzJG9wdHMyLCB0aWxlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChfY2FjaGUuc2l6ZSA8PSBtYXhDYWNoZVNpemUgJiYgdGhpcy5fY2FjaGVCeXRlU2l6ZSA8PSBtYXhDYWNoZUJ5dGVTaXplKSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdGhpcy5fcmVidWlsZFRyZWUoKTtcblxuICAgICAgdGhpcy5fZGlydHkgPSB0cnVlO1xuICAgIH1cblxuICAgIGlmICh0aGlzLl9kaXJ0eSkge1xuICAgICAgdGhpcy5fdGlsZXMgPSBBcnJheS5mcm9tKHRoaXMuX2NhY2hlLnZhbHVlcygpKS5zb3J0KCh0MSwgdDIpID0+IHQxLnpvb20gLSB0Mi56b29tKTtcbiAgICAgIHRoaXMuX2RpcnR5ID0gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgX2dldFRpbGUoaW5kZXgsIGNyZWF0ZSkge1xuICAgIGNvbnN0IGlkID0gdGhpcy5nZXRUaWxlSWQoaW5kZXgpO1xuXG4gICAgbGV0IHRpbGUgPSB0aGlzLl9jYWNoZS5nZXQoaWQpO1xuXG4gICAgbGV0IG5lZWRzUmVsb2FkID0gZmFsc2U7XG5cbiAgICBpZiAoIXRpbGUgJiYgY3JlYXRlKSB7XG4gICAgICB0aWxlID0gbmV3IFRpbGUyREhlYWRlcihpbmRleCk7XG4gICAgICBPYmplY3QuYXNzaWduKHRpbGUsIHRoaXMuZ2V0VGlsZU1ldGFkYXRhKHRpbGUuaW5kZXgpKTtcbiAgICAgIE9iamVjdC5hc3NpZ24odGlsZSwge1xuICAgICAgICBpZCxcbiAgICAgICAgem9vbTogdGhpcy5nZXRUaWxlWm9vbSh0aWxlLmluZGV4KVxuICAgICAgfSk7XG4gICAgICBuZWVkc1JlbG9hZCA9IHRydWU7XG5cbiAgICAgIHRoaXMuX2NhY2hlLnNldChpZCwgdGlsZSk7XG5cbiAgICAgIHRoaXMuX2RpcnR5ID0gdHJ1ZTtcbiAgICB9IGVsc2UgaWYgKHRpbGUgJiYgdGlsZS5uZWVkc1JlbG9hZCkge1xuICAgICAgbmVlZHNSZWxvYWQgPSB0cnVlO1xuICAgIH1cblxuICAgIGlmICh0aWxlICYmIG5lZWRzUmVsb2FkKSB7XG4gICAgICB0aWxlLmxvYWREYXRhKHtcbiAgICAgICAgZ2V0RGF0YTogdGhpcy5vcHRzLmdldFRpbGVEYXRhLFxuICAgICAgICByZXF1ZXN0U2NoZWR1bGVyOiB0aGlzLl9yZXF1ZXN0U2NoZWR1bGVyLFxuICAgICAgICBvbkxvYWQ6IHRoaXMub25UaWxlTG9hZCxcbiAgICAgICAgb25FcnJvcjogdGhpcy5vcHRzLm9uVGlsZUVycm9yXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGlsZTtcbiAgfVxuXG4gIF9nZXROZWFyZXN0QW5jZXN0b3IodGlsZSkge1xuICAgIGNvbnN0IHtcbiAgICAgIF9taW5ab29tID0gMFxuICAgIH0gPSB0aGlzO1xuICAgIGxldCBpbmRleCA9IHRpbGUuaW5kZXg7XG5cbiAgICB3aGlsZSAodGhpcy5nZXRUaWxlWm9vbShpbmRleCkgPiBfbWluWm9vbSkge1xuICAgICAgaW5kZXggPSB0aGlzLmdldFBhcmVudEluZGV4KGluZGV4KTtcblxuICAgICAgY29uc3QgcGFyZW50ID0gdGhpcy5fZ2V0VGlsZShpbmRleCk7XG5cbiAgICAgIGlmIChwYXJlbnQpIHtcbiAgICAgICAgcmV0dXJuIHBhcmVudDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG59XG5cbmZ1bmN0aW9uIHVwZGF0ZVRpbGVTdGF0ZURlZmF1bHQoYWxsVGlsZXMpIHtcbiAgZm9yIChjb25zdCB0aWxlIG9mIGFsbFRpbGVzKSB7XG4gICAgdGlsZS5zdGF0ZSA9IDA7XG4gIH1cblxuICBmb3IgKGNvbnN0IHRpbGUgb2YgYWxsVGlsZXMpIHtcbiAgICBpZiAodGlsZS5pc1NlbGVjdGVkICYmICFnZXRQbGFjZWhvbGRlckluQW5jZXN0b3JzKHRpbGUpKSB7XG4gICAgICBnZXRQbGFjZWhvbGRlckluQ2hpbGRyZW4odGlsZSk7XG4gICAgfVxuICB9XG5cbiAgZm9yIChjb25zdCB0aWxlIG9mIGFsbFRpbGVzKSB7XG4gICAgdGlsZS5pc1Zpc2libGUgPSBCb29sZWFuKHRpbGUuc3RhdGUgJiBUSUxFX1NUQVRFX1ZJU0lCTEUpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZVRpbGVTdGF0ZVJlcGxhY2UoYWxsVGlsZXMpIHtcbiAgZm9yIChjb25zdCB0aWxlIG9mIGFsbFRpbGVzKSB7XG4gICAgdGlsZS5zdGF0ZSA9IDA7XG4gIH1cblxuICBmb3IgKGNvbnN0IHRpbGUgb2YgYWxsVGlsZXMpIHtcbiAgICBpZiAodGlsZS5pc1NlbGVjdGVkKSB7XG4gICAgICBnZXRQbGFjZWhvbGRlckluQW5jZXN0b3JzKHRpbGUpO1xuICAgIH1cbiAgfVxuXG4gIGNvbnN0IHNvcnRlZFRpbGVzID0gQXJyYXkuZnJvbShhbGxUaWxlcykuc29ydCgodDEsIHQyKSA9PiB0MS56b29tIC0gdDIuem9vbSk7XG5cbiAgZm9yIChjb25zdCB0aWxlIG9mIHNvcnRlZFRpbGVzKSB7XG4gICAgdGlsZS5pc1Zpc2libGUgPSBCb29sZWFuKHRpbGUuc3RhdGUgJiBUSUxFX1NUQVRFX1ZJU0lCTEUpO1xuXG4gICAgaWYgKHRpbGUuY2hpbGRyZW4gJiYgKHRpbGUuaXNWaXNpYmxlIHx8IHRpbGUuc3RhdGUgJiBUSUxFX1NUQVRFX1ZJU0lURUQpKSB7XG4gICAgICBmb3IgKGNvbnN0IGNoaWxkIG9mIHRpbGUuY2hpbGRyZW4pIHtcbiAgICAgICAgY2hpbGQuc3RhdGUgPSBUSUxFX1NUQVRFX1ZJU0lURUQ7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICh0aWxlLmlzU2VsZWN0ZWQpIHtcbiAgICAgIGdldFBsYWNlaG9sZGVySW5DaGlsZHJlbih0aWxlKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gZ2V0UGxhY2Vob2xkZXJJbkFuY2VzdG9ycyhzdGFydFRpbGUpIHtcbiAgbGV0IHRpbGUgPSBzdGFydFRpbGU7XG5cbiAgd2hpbGUgKHRpbGUpIHtcbiAgICBpZiAodGlsZS5pc0xvYWRlZCB8fCB0aWxlLmNvbnRlbnQpIHtcbiAgICAgIHRpbGUuc3RhdGUgfD0gVElMRV9TVEFURV9WSVNJQkxFO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgdGlsZSA9IHRpbGUucGFyZW50O1xuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBnZXRQbGFjZWhvbGRlckluQ2hpbGRyZW4odGlsZSkge1xuICBmb3IgKGNvbnN0IGNoaWxkIG9mIHRpbGUuY2hpbGRyZW4pIHtcbiAgICBpZiAoY2hpbGQuaXNMb2FkZWQgfHwgY2hpbGQuY29udGVudCkge1xuICAgICAgY2hpbGQuc3RhdGUgfD0gVElMRV9TVEFURV9WSVNJQkxFO1xuICAgIH0gZWxzZSB7XG4gICAgICBnZXRQbGFjZWhvbGRlckluQ2hpbGRyZW4oY2hpbGQpO1xuICAgIH1cbiAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dGlsZXNldC0yZC5qcy5tYXAiLCJpbXBvcnQgX2RlZmluZVByb3BlcnR5IGZyb20gXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9kZWZpbmVQcm9wZXJ0eVwiO1xuaW1wb3J0IHsgQ29tcG9zaXRlTGF5ZXIsIF9mbGF0dGVuIGFzIGZsYXR0ZW4gfSBmcm9tICdAZGVjay5nbC9jb3JlJztcbmltcG9ydCB7IEdlb0pzb25MYXllciB9IGZyb20gJ0BkZWNrLmdsL2xheWVycyc7XG5pbXBvcnQgeyBUaWxlc2V0MkQsIFNUUkFURUdZX0RFRkFVTFQgfSBmcm9tICcuLi90aWxlc2V0LTJkJztcbmltcG9ydCB7IHVybFR5cGUsIGdldFVSTEZyb21UZW1wbGF0ZSB9IGZyb20gJy4uL3RpbGVzZXQtMmQnO1xuY29uc3QgZGVmYXVsdFByb3BzID0ge1xuICBUaWxlc2V0Q2xhc3M6IFRpbGVzZXQyRCxcbiAgZGF0YToge1xuICAgIHR5cGU6ICdkYXRhJyxcbiAgICB2YWx1ZTogW11cbiAgfSxcbiAgZGF0YUNvbXBhcmF0b3I6IHVybFR5cGUuZXF1YWwsXG4gIHJlbmRlclN1YkxheWVyczoge1xuICAgIHR5cGU6ICdmdW5jdGlvbicsXG4gICAgdmFsdWU6IHByb3BzID0+IG5ldyBHZW9Kc29uTGF5ZXIocHJvcHMpXG4gIH0sXG4gIGdldFRpbGVEYXRhOiB7XG4gICAgdHlwZTogJ2Z1bmN0aW9uJyxcbiAgICBvcHRpb25hbDogdHJ1ZSxcbiAgICB2YWx1ZTogbnVsbFxuICB9LFxuICBvblZpZXdwb3J0TG9hZDoge1xuICAgIHR5cGU6ICdmdW5jdGlvbicsXG4gICAgb3B0aW9uYWw6IHRydWUsXG4gICAgdmFsdWU6IG51bGxcbiAgfSxcbiAgb25UaWxlTG9hZDoge1xuICAgIHR5cGU6ICdmdW5jdGlvbicsXG4gICAgdmFsdWU6IHRpbGUgPT4ge31cbiAgfSxcbiAgb25UaWxlVW5sb2FkOiB7XG4gICAgdHlwZTogJ2Z1bmN0aW9uJyxcbiAgICB2YWx1ZTogdGlsZSA9PiB7fVxuICB9LFxuICBvblRpbGVFcnJvcjoge1xuICAgIHR5cGU6ICdmdW5jdGlvbicsXG4gICAgdmFsdWU6IGVyciA9PiBjb25zb2xlLmVycm9yKGVycilcbiAgfSxcbiAgZXh0ZW50OiB7XG4gICAgdHlwZTogJ2FycmF5JyxcbiAgICBvcHRpb25hbDogdHJ1ZSxcbiAgICB2YWx1ZTogbnVsbCxcbiAgICBjb21wYXJlOiB0cnVlXG4gIH0sXG4gIHRpbGVTaXplOiA1MTIsXG4gIG1heFpvb206IG51bGwsXG4gIG1pblpvb206IDAsXG4gIG1heENhY2hlU2l6ZTogbnVsbCxcbiAgbWF4Q2FjaGVCeXRlU2l6ZTogbnVsbCxcbiAgcmVmaW5lbWVudFN0cmF0ZWd5OiBTVFJBVEVHWV9ERUZBVUxULFxuICB6UmFuZ2U6IG51bGwsXG4gIG1heFJlcXVlc3RzOiA2LFxuICB6b29tT2Zmc2V0OiAwXG59O1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgVGlsZUxheWVyIGV4dGVuZHMgQ29tcG9zaXRlTGF5ZXIge1xuICBpbml0aWFsaXplU3RhdGUoKSB7XG4gICAgdGhpcy5zdGF0ZSA9IHtcbiAgICAgIHRpbGVzZXQ6IG51bGwsXG4gICAgICBpc0xvYWRlZDogZmFsc2VcbiAgICB9O1xuICB9XG5cbiAgZmluYWxpemVTdGF0ZSgpIHtcbiAgICB2YXIgX3RoaXMkc3RhdGUsIF90aGlzJHN0YXRlJHRpbGVzZXQ7XG5cbiAgICAoX3RoaXMkc3RhdGUgPSB0aGlzLnN0YXRlKSA9PT0gbnVsbCB8fCBfdGhpcyRzdGF0ZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogKF90aGlzJHN0YXRlJHRpbGVzZXQgPSBfdGhpcyRzdGF0ZS50aWxlc2V0KSA9PT0gbnVsbCB8fCBfdGhpcyRzdGF0ZSR0aWxlc2V0ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfdGhpcyRzdGF0ZSR0aWxlc2V0LmZpbmFsaXplKCk7XG4gIH1cblxuICBnZXQgaXNMb2FkZWQoKSB7XG4gICAgdmFyIF90aGlzJHN0YXRlMiwgX3RoaXMkc3RhdGUyJHRpbGVzZXQ7XG5cbiAgICByZXR1cm4gKF90aGlzJHN0YXRlMiA9IHRoaXMuc3RhdGUpID09PSBudWxsIHx8IF90aGlzJHN0YXRlMiA9PT0gdm9pZCAwID8gdm9pZCAwIDogKF90aGlzJHN0YXRlMiR0aWxlc2V0ID0gX3RoaXMkc3RhdGUyLnRpbGVzZXQpID09PSBudWxsIHx8IF90aGlzJHN0YXRlMiR0aWxlc2V0ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfdGhpcyRzdGF0ZTIkdGlsZXNldC5zZWxlY3RlZFRpbGVzLmV2ZXJ5KHRpbGUgPT4gdGlsZS5pc0xvYWRlZCAmJiB0aWxlLmxheWVycyAmJiB0aWxlLmxheWVycy5ldmVyeShsYXllciA9PiBsYXllci5pc0xvYWRlZCkpO1xuICB9XG5cbiAgc2hvdWxkVXBkYXRlU3RhdGUoe1xuICAgIGNoYW5nZUZsYWdzXG4gIH0pIHtcbiAgICByZXR1cm4gY2hhbmdlRmxhZ3Muc29tZXRoaW5nQ2hhbmdlZDtcbiAgfVxuXG4gIHVwZGF0ZVN0YXRlKHtcbiAgICBjaGFuZ2VGbGFnc1xuICB9KSB7XG4gICAgbGV0IHtcbiAgICAgIHRpbGVzZXRcbiAgICB9ID0gdGhpcy5zdGF0ZTtcbiAgICBjb25zdCBwcm9wc0NoYW5nZWQgPSBjaGFuZ2VGbGFncy5wcm9wc09yRGF0YUNoYW5nZWQgfHwgY2hhbmdlRmxhZ3MudXBkYXRlVHJpZ2dlcnNDaGFuZ2VkO1xuICAgIGNvbnN0IGRhdGFDaGFuZ2VkID0gY2hhbmdlRmxhZ3MuZGF0YUNoYW5nZWQgfHwgY2hhbmdlRmxhZ3MudXBkYXRlVHJpZ2dlcnNDaGFuZ2VkICYmIChjaGFuZ2VGbGFncy51cGRhdGVUcmlnZ2Vyc0NoYW5nZWQuYWxsIHx8IGNoYW5nZUZsYWdzLnVwZGF0ZVRyaWdnZXJzQ2hhbmdlZC5nZXRUaWxlRGF0YSk7XG5cbiAgICBpZiAoIXRpbGVzZXQpIHtcbiAgICAgIHRpbGVzZXQgPSBuZXcgdGhpcy5wcm9wcy5UaWxlc2V0Q2xhc3ModGhpcy5fZ2V0VGlsZXNldE9wdGlvbnMoKSk7XG4gICAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgICAgdGlsZXNldFxuICAgICAgfSk7XG4gICAgfSBlbHNlIGlmIChwcm9wc0NoYW5nZWQpIHtcbiAgICAgIHRpbGVzZXQuc2V0T3B0aW9ucyh0aGlzLl9nZXRUaWxlc2V0T3B0aW9ucygpKTtcblxuICAgICAgaWYgKGRhdGFDaGFuZ2VkKSB7XG4gICAgICAgIHRpbGVzZXQucmVsb2FkQWxsKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnN0YXRlLnRpbGVzZXQudGlsZXMuZm9yRWFjaCh0aWxlID0+IHtcbiAgICAgICAgICB0aWxlLmxheWVycyA9IG51bGw7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMuX3VwZGF0ZVRpbGVzZXQoKTtcbiAgfVxuXG4gIF9nZXRUaWxlc2V0T3B0aW9ucygpIHtcbiAgICBjb25zdCB7XG4gICAgICB0aWxlU2l6ZSxcbiAgICAgIG1heENhY2hlU2l6ZSxcbiAgICAgIG1heENhY2hlQnl0ZVNpemUsXG4gICAgICByZWZpbmVtZW50U3RyYXRlZ3ksXG4gICAgICBleHRlbnQsXG4gICAgICBtYXhab29tLFxuICAgICAgbWluWm9vbSxcbiAgICAgIG1heFJlcXVlc3RzLFxuICAgICAgem9vbU9mZnNldFxuICAgIH0gPSB0aGlzLnByb3BzO1xuICAgIHJldHVybiB7XG4gICAgICBtYXhDYWNoZVNpemUsXG4gICAgICBtYXhDYWNoZUJ5dGVTaXplLFxuICAgICAgbWF4Wm9vbSxcbiAgICAgIG1pblpvb20sXG4gICAgICB0aWxlU2l6ZSxcbiAgICAgIHJlZmluZW1lbnRTdHJhdGVneSxcbiAgICAgIGV4dGVudCxcbiAgICAgIG1heFJlcXVlc3RzLFxuICAgICAgem9vbU9mZnNldCxcbiAgICAgIGdldFRpbGVEYXRhOiB0aGlzLmdldFRpbGVEYXRhLmJpbmQodGhpcyksXG4gICAgICBvblRpbGVMb2FkOiB0aGlzLl9vblRpbGVMb2FkLmJpbmQodGhpcyksXG4gICAgICBvblRpbGVFcnJvcjogdGhpcy5fb25UaWxlRXJyb3IuYmluZCh0aGlzKSxcbiAgICAgIG9uVGlsZVVubG9hZDogdGhpcy5fb25UaWxlVW5sb2FkLmJpbmQodGhpcylcbiAgICB9O1xuICB9XG5cbiAgX3VwZGF0ZVRpbGVzZXQoKSB7XG4gICAgY29uc3Qge1xuICAgICAgdGlsZXNldFxuICAgIH0gPSB0aGlzLnN0YXRlO1xuICAgIGNvbnN0IHtcbiAgICAgIHpSYW5nZSxcbiAgICAgIG1vZGVsTWF0cml4XG4gICAgfSA9IHRoaXMucHJvcHM7XG4gICAgY29uc3QgZnJhbWVOdW1iZXIgPSB0aWxlc2V0LnVwZGF0ZSh0aGlzLmNvbnRleHQudmlld3BvcnQsIHtcbiAgICAgIHpSYW5nZSxcbiAgICAgIG1vZGVsTWF0cml4XG4gICAgfSk7XG4gICAgY29uc3Qge1xuICAgICAgaXNMb2FkZWRcbiAgICB9ID0gdGlsZXNldDtcbiAgICBjb25zdCBsb2FkaW5nU3RhdGVDaGFuZ2VkID0gdGhpcy5zdGF0ZS5pc0xvYWRlZCAhPT0gaXNMb2FkZWQ7XG4gICAgY29uc3QgdGlsZXNldENoYW5nZWQgPSB0aGlzLnN0YXRlLmZyYW1lTnVtYmVyICE9PSBmcmFtZU51bWJlcjtcblxuICAgIGlmIChpc0xvYWRlZCAmJiAobG9hZGluZ1N0YXRlQ2hhbmdlZCB8fCB0aWxlc2V0Q2hhbmdlZCkpIHtcbiAgICAgIHRoaXMuX29uVmlld3BvcnRMb2FkKCk7XG4gICAgfVxuXG4gICAgaWYgKHRpbGVzZXRDaGFuZ2VkKSB7XG4gICAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgICAgZnJhbWVOdW1iZXJcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHRoaXMuc3RhdGUuaXNMb2FkZWQgPSBpc0xvYWRlZDtcbiAgfVxuXG4gIF9vblZpZXdwb3J0TG9hZCgpIHtcbiAgICBjb25zdCB7XG4gICAgICB0aWxlc2V0XG4gICAgfSA9IHRoaXMuc3RhdGU7XG4gICAgY29uc3Qge1xuICAgICAgb25WaWV3cG9ydExvYWRcbiAgICB9ID0gdGhpcy5wcm9wcztcblxuICAgIGlmIChvblZpZXdwb3J0TG9hZCkge1xuICAgICAgb25WaWV3cG9ydExvYWQodGlsZXNldC5zZWxlY3RlZFRpbGVzKTtcbiAgICB9XG4gIH1cblxuICBfb25UaWxlTG9hZCh0aWxlKSB7XG4gICAgdGhpcy5wcm9wcy5vblRpbGVMb2FkKHRpbGUpO1xuICAgIHRpbGUubGF5ZXJzID0gbnVsbDtcbiAgICB0aGlzLnNldE5lZWRzVXBkYXRlKCk7XG4gIH1cblxuICBfb25UaWxlRXJyb3IoZXJyb3IsIHRpbGUpIHtcbiAgICB0aGlzLnByb3BzLm9uVGlsZUVycm9yKGVycm9yKTtcbiAgICB0aWxlLmxheWVycyA9IG51bGw7XG4gICAgdGhpcy5zZXROZWVkc1VwZGF0ZSgpO1xuICB9XG5cbiAgX29uVGlsZVVubG9hZCh0aWxlKSB7XG4gICAgdGhpcy5wcm9wcy5vblRpbGVVbmxvYWQodGlsZSk7XG4gIH1cblxuICBnZXRUaWxlRGF0YSh0aWxlKSB7XG4gICAgY29uc3Qge1xuICAgICAgZGF0YSxcbiAgICAgIGdldFRpbGVEYXRhLFxuICAgICAgZmV0Y2hcbiAgICB9ID0gdGhpcy5wcm9wcztcbiAgICBjb25zdCB7XG4gICAgICBzaWduYWxcbiAgICB9ID0gdGlsZTtcbiAgICB0aWxlLnVybCA9IHR5cGVvZiBkYXRhID09PSAnc3RyaW5nJyB8fCBBcnJheS5pc0FycmF5KGRhdGEpID8gZ2V0VVJMRnJvbVRlbXBsYXRlKGRhdGEsIHRpbGUpIDogbnVsbDtcblxuICAgIGlmIChnZXRUaWxlRGF0YSkge1xuICAgICAgcmV0dXJuIGdldFRpbGVEYXRhKHRpbGUpO1xuICAgIH1cblxuICAgIGlmIChmZXRjaCAmJiB0aWxlLnVybCkge1xuICAgICAgcmV0dXJuIGZldGNoKHRpbGUudXJsLCB7XG4gICAgICAgIHByb3BOYW1lOiAnZGF0YScsXG4gICAgICAgIGxheWVyOiB0aGlzLFxuICAgICAgICBzaWduYWxcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgcmVuZGVyU3ViTGF5ZXJzKHByb3BzKSB7XG4gICAgcmV0dXJuIHRoaXMucHJvcHMucmVuZGVyU3ViTGF5ZXJzKHByb3BzKTtcbiAgfVxuXG4gIGdldFN1YkxheWVyUHJvcHNCeVRpbGUodGlsZSkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgZ2V0UGlja2luZ0luZm8oe1xuICAgIGluZm8sXG4gICAgc291cmNlTGF5ZXJcbiAgfSkge1xuICAgIGNvbnN0IHNvdXJjZVRpbGUgPSBzb3VyY2VMYXllci5wcm9wcy50aWxlO1xuXG4gICAgaWYgKGluZm8ucGlja2VkKSB7XG4gICAgICBpbmZvLnRpbGUgPSBzb3VyY2VUaWxlO1xuICAgIH1cblxuICAgIGluZm8uc291cmNlVGlsZSA9IHNvdXJjZVRpbGU7XG4gICAgcmV0dXJuIGluZm87XG4gIH1cblxuICBfdXBkYXRlQXV0b0hpZ2hsaWdodChpbmZvKSB7XG4gICAgY29uc3Qgc291cmNlVGlsZSA9IGluZm8uc291cmNlVGlsZTtcblxuICAgIGlmIChzb3VyY2VUaWxlICYmIHNvdXJjZVRpbGUubGF5ZXJzKSB7XG4gICAgICBmb3IgKGNvbnN0IGxheWVyIG9mIHNvdXJjZVRpbGUubGF5ZXJzKSB7XG4gICAgICAgIGxheWVyLnVwZGF0ZUF1dG9IaWdobGlnaHQoaW5mbyk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmVuZGVyTGF5ZXJzKCkge1xuICAgIHJldHVybiB0aGlzLnN0YXRlLnRpbGVzZXQudGlsZXMubWFwKHRpbGUgPT4ge1xuICAgICAgY29uc3Qgc3ViTGF5ZXJQcm9wcyA9IHRoaXMuZ2V0U3ViTGF5ZXJQcm9wc0J5VGlsZSh0aWxlKTtcblxuICAgICAgaWYgKCF0aWxlLmlzTG9hZGVkICYmICF0aWxlLmNvbnRlbnQpIHt9IGVsc2UgaWYgKCF0aWxlLmxheWVycykge1xuICAgICAgICBjb25zdCBsYXllcnMgPSB0aGlzLnJlbmRlclN1YkxheWVycyh7IC4uLnRoaXMucHJvcHMsXG4gICAgICAgICAgaWQ6IFwiXCIuY29uY2F0KHRoaXMuaWQsIFwiLVwiKS5jb25jYXQodGlsZS5pZCksXG4gICAgICAgICAgZGF0YTogdGlsZS5jb250ZW50LFxuICAgICAgICAgIF9vZmZzZXQ6IDAsXG4gICAgICAgICAgdGlsZVxuICAgICAgICB9KTtcbiAgICAgICAgdGlsZS5sYXllcnMgPSBmbGF0dGVuKGxheWVycywgQm9vbGVhbikubWFwKGxheWVyID0+IGxheWVyLmNsb25lKHtcbiAgICAgICAgICB0aWxlLFxuICAgICAgICAgIC4uLnN1YkxheWVyUHJvcHNcbiAgICAgICAgfSkpO1xuICAgICAgfSBlbHNlIGlmIChzdWJMYXllclByb3BzICYmIHRpbGUubGF5ZXJzWzBdICYmIE9iamVjdC5rZXlzKHN1YkxheWVyUHJvcHMpLnNvbWUocHJvcE5hbWUgPT4gdGlsZS5sYXllcnNbMF0ucHJvcHNbcHJvcE5hbWVdICE9PSBzdWJMYXllclByb3BzW3Byb3BOYW1lXSkpIHtcbiAgICAgICAgdGlsZS5sYXllcnMgPSB0aWxlLmxheWVycy5tYXAobGF5ZXIgPT4gbGF5ZXIuY2xvbmUoc3ViTGF5ZXJQcm9wcykpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGlsZS5sYXllcnM7XG4gICAgfSk7XG4gIH1cblxuICBmaWx0ZXJTdWJMYXllcih7XG4gICAgbGF5ZXIsXG4gICAgY3VsbFJlY3RcbiAgfSkge1xuICAgIGNvbnN0IHtcbiAgICAgIHRpbGVcbiAgICB9ID0gbGF5ZXIucHJvcHM7XG4gICAgcmV0dXJuIHRoaXMuc3RhdGUudGlsZXNldC5pc1RpbGVWaXNpYmxlKHRpbGUsIGN1bGxSZWN0KTtcbiAgfVxuXG59XG5cbl9kZWZpbmVQcm9wZXJ0eShUaWxlTGF5ZXIsIFwiZGVmYXVsdFByb3BzXCIsIGRlZmF1bHRQcm9wcyk7XG5cbl9kZWZpbmVQcm9wZXJ0eShUaWxlTGF5ZXIsIFwibGF5ZXJOYW1lXCIsICdUaWxlTGF5ZXInKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXRpbGUtbGF5ZXIuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///29826\n")},13863:function(__unused_webpack_module,__webpack_exports__,__webpack_require__){eval("\n// EXPORTS\n__webpack_require__.d(__webpack_exports__, {\n  \"Z\": function() { return /* binding */ BitmapLayer; }\n});\n\n// EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/esm/defineProperty.js\nvar defineProperty = __webpack_require__(82482);\n// EXTERNAL MODULE: ./node_modules/@deck.gl/core/dist/esm/lib/constants.js\nvar constants = __webpack_require__(24088);\n// EXTERNAL MODULE: ./node_modules/@deck.gl/core/dist/esm/lib/layer.js + 3 modules\nvar lib_layer = __webpack_require__(52447);\n// EXTERNAL MODULE: ./node_modules/@deck.gl/core/dist/esm/shaderlib/project32/project32.js\nvar project32 = __webpack_require__(93844);\n// EXTERNAL MODULE: ./node_modules/@deck.gl/core/dist/esm/shaderlib/picking/picking.js\nvar picking = __webpack_require__(43844);\n// EXTERNAL MODULE: ./node_modules/@luma.gl/engine/dist/esm/lib/model.js + 1 modules\nvar model = __webpack_require__(80210);\n// EXTERNAL MODULE: ./node_modules/@luma.gl/engine/dist/esm/geometry/geometry.js\nvar geometry = __webpack_require__(53982);\n// EXTERNAL MODULE: ./node_modules/@math.gl/web-mercator/dist/esm/index.js + 8 modules\nvar esm = __webpack_require__(78866);\n// EXTERNAL MODULE: ./node_modules/@math.gl/core/dist/esm/lib/common.js\nvar common = __webpack_require__(14034);\n;// CONCATENATED MODULE: ./node_modules/@deck.gl/layers/dist/esm/bitmap-layer/create-mesh.js\n\nconst DEFAULT_INDICES = new Uint16Array([0, 2, 1, 0, 3, 2]);\nconst DEFAULT_TEX_COORDS = new Float32Array([0, 1, 0, 0, 1, 0, 1, 1]);\nfunction createMesh(bounds, resolution) {\n  if (!resolution) {\n    return createQuad(bounds);\n  }\n\n  const maxXSpan = Math.max(Math.abs(bounds[0][0] - bounds[3][0]), Math.abs(bounds[1][0] - bounds[2][0]));\n  const maxYSpan = Math.max(Math.abs(bounds[1][1] - bounds[0][1]), Math.abs(bounds[2][1] - bounds[3][1]));\n  const uCount = Math.ceil(maxXSpan / resolution) + 1;\n  const vCount = Math.ceil(maxYSpan / resolution) + 1;\n  const vertexCount = (uCount - 1) * (vCount - 1) * 6;\n  const indices = new Uint32Array(vertexCount);\n  const texCoords = new Float32Array(uCount * vCount * 2);\n  const positions = new Float64Array(uCount * vCount * 3);\n  let vertex = 0;\n  let index = 0;\n\n  for (let u = 0; u < uCount; u++) {\n    const ut = u / (uCount - 1);\n\n    for (let v = 0; v < vCount; v++) {\n      const vt = v / (vCount - 1);\n      const p = interpolateQuad(bounds, ut, vt);\n      positions[vertex * 3 + 0] = p[0];\n      positions[vertex * 3 + 1] = p[1];\n      positions[vertex * 3 + 2] = p[2] || 0;\n      texCoords[vertex * 2 + 0] = ut;\n      texCoords[vertex * 2 + 1] = 1 - vt;\n\n      if (u > 0 && v > 0) {\n        indices[index++] = vertex - vCount;\n        indices[index++] = vertex - vCount - 1;\n        indices[index++] = vertex - 1;\n        indices[index++] = vertex - vCount;\n        indices[index++] = vertex - 1;\n        indices[index++] = vertex;\n      }\n\n      vertex++;\n    }\n  }\n\n  return {\n    vertexCount,\n    positions,\n    indices,\n    texCoords\n  };\n}\n\nfunction createQuad(bounds) {\n  const positions = new Float64Array(12);\n\n  for (let i = 0; i < bounds.length; i++) {\n    positions[i * 3 + 0] = bounds[i][0];\n    positions[i * 3 + 1] = bounds[i][1];\n    positions[i * 3 + 2] = bounds[i][2] || 0;\n  }\n\n  return {\n    vertexCount: 6,\n    positions,\n    indices: DEFAULT_INDICES,\n    texCoords: DEFAULT_TEX_COORDS\n  };\n}\n\nfunction interpolateQuad(quad, ut, vt) {\n  return (0,common/* lerp */.t7)((0,common/* lerp */.t7)(quad[0], quad[1], vt), (0,common/* lerp */.t7)(quad[3], quad[2], vt), ut);\n}\n//# sourceMappingURL=create-mesh.js.map\n;// CONCATENATED MODULE: ./node_modules/@deck.gl/layers/dist/esm/bitmap-layer/bitmap-layer-vertex.js\n/* harmony default export */ var bitmap_layer_vertex = (\"\\n#define SHADER_NAME bitmap-layer-vertex-shader\\n\\nattribute vec2 texCoords;\\nattribute vec3 positions;\\nattribute vec3 positions64Low;\\n\\nvarying vec2 vTexCoord;\\nvarying vec2 vTexPos;\\n\\nuniform float coordinateConversion;\\n\\nconst vec3 pickingColor = vec3(1.0, 0.0, 0.0);\\n\\nvoid main(void) {\\n  geometry.worldPosition = positions;\\n  geometry.uv = texCoords;\\n  geometry.pickingColor = pickingColor;\\n\\n  gl_Position = project_position_to_clipspace(positions, positions64Low, vec3(0.0), geometry.position);\\n  DECKGL_FILTER_GL_POSITION(gl_Position, geometry);\\n\\n  vTexCoord = texCoords;\\n\\n  if (coordinateConversion < -0.5) {\\n    vTexPos = geometry.position.xy + project_uCommonOrigin.xy;\\n  } else if (coordinateConversion > 0.5) {\\n    vTexPos = geometry.worldPosition.xy;\\n  }\\n\\n  vec4 color = vec4(0.0);\\n  DECKGL_FILTER_COLOR(color, geometry);\\n}\\n\");\n//# sourceMappingURL=bitmap-layer-vertex.js.map\n;// CONCATENATED MODULE: ./node_modules/@deck.gl/layers/dist/esm/bitmap-layer/bitmap-layer-fragment.js\nconst packUVsIntoRGB = \"\\nvec3 packUVsIntoRGB(vec2 uv) {\\n  // Extract the top 8 bits. We want values to be truncated down so we can add a fraction\\n  vec2 uv8bit = floor(uv * 256.);\\n\\n  // Calculate the normalized remainders of u and v parts that do not fit into 8 bits\\n  // Scale and clamp to 0-1 range\\n  vec2 uvFraction = fract(uv * 256.);\\n  vec2 uvFraction4bit = floor(uvFraction * 16.);\\n\\n  // Remainder can be encoded in blue channel, encode as 4 bits for pixel coordinates\\n  float fractions = uvFraction4bit.x + uvFraction4bit.y * 16.;\\n\\n  return vec3(uv8bit, fractions) / 255.;\\n}\\n\";\n/* harmony default export */ var bitmap_layer_fragment = (\"\\n#define SHADER_NAME bitmap-layer-fragment-shader\\n\\n#ifdef GL_ES\\nprecision highp float;\\n#endif\\n\\nuniform sampler2D bitmapTexture;\\n\\nvarying vec2 vTexCoord;\\nvarying vec2 vTexPos;\\n\\nuniform float desaturate;\\nuniform vec4 transparentColor;\\nuniform vec3 tintColor;\\nuniform float opacity;\\n\\nuniform float coordinateConversion;\\nuniform vec4 bounds;\\n\\n/* projection utils */\\nconst float TILE_SIZE = 512.0;\\nconst float PI = 3.1415926536;\\nconst float WORLD_SCALE = TILE_SIZE / PI / 2.0;\\n\\n// from degrees to Web Mercator\\nvec2 lnglat_to_mercator(vec2 lnglat) {\\n  float x = lnglat.x;\\n  float y = clamp(lnglat.y, -89.9, 89.9);\\n  return vec2(\\n    radians(x) + PI,\\n    PI + log(tan(PI * 0.25 + radians(y) * 0.5))\\n  ) * WORLD_SCALE;\\n}\\n\\n// from Web Mercator to degrees\\nvec2 mercator_to_lnglat(vec2 xy) {\\n  xy /= WORLD_SCALE;\\n  return degrees(vec2(\\n    xy.x - PI,\\n    atan(exp(xy.y - PI)) * 2.0 - PI * 0.5\\n  ));\\n}\\n/* End projection utils */\\n\\n// apply desaturation\\nvec3 color_desaturate(vec3 color) {\\n  float luminance = (color.r + color.g + color.b) * 0.333333333;\\n  return mix(color, vec3(luminance), desaturate);\\n}\\n\\n// apply tint\\nvec3 color_tint(vec3 color) {\\n  return color * tintColor;\\n}\\n\\n// blend with background color\\nvec4 apply_opacity(vec3 color, float alpha) {\\n  if (transparentColor.a == 0.0) {\\n    return vec4(color, alpha);\\n  }\\n  float blendedAlpha = alpha + transparentColor.a * (1.0 - alpha);\\n  float highLightRatio = alpha / blendedAlpha;\\n  vec3 blendedRGB = mix(transparentColor.rgb, color, highLightRatio);\\n  return vec4(blendedRGB, blendedAlpha);\\n}\\n\\nvec2 getUV(vec2 pos) {\\n  return vec2(\\n    (pos.x - bounds[0]) / (bounds[2] - bounds[0]),\\n    (pos.y - bounds[3]) / (bounds[1] - bounds[3])\\n  );\\n}\\n\\n\".concat(packUVsIntoRGB, \"\\n\\nvoid main(void) {\\n  vec2 uv = vTexCoord;\\n  if (coordinateConversion < -0.5) {\\n    vec2 lnglat = mercator_to_lnglat(vTexPos);\\n    uv = getUV(lnglat);\\n  } else if (coordinateConversion > 0.5) {\\n    vec2 commonPos = lnglat_to_mercator(vTexPos);\\n    uv = getUV(commonPos);\\n  }\\n  vec4 bitmapColor = texture2D(bitmapTexture, uv);\\n\\n  gl_FragColor = apply_opacity(color_tint(color_desaturate(bitmapColor.rgb)), bitmapColor.a * opacity);\\n\\n  geometry.uv = uv;\\n  DECKGL_FILTER_COLOR(gl_FragColor, geometry);\\n\\n  if (picking_uActive && !picking_uAttribute) {\\n    // Since instance information is not used, we can use picking color for pixel index\\n    gl_FragColor.rgb = packUVsIntoRGB(uv);\\n  }\\n}\\n\"));\n//# sourceMappingURL=bitmap-layer-fragment.js.map\n;// CONCATENATED MODULE: ./node_modules/@deck.gl/layers/dist/esm/bitmap-layer/bitmap-layer.js\n\n\n\n\n\n\n\nconst defaultProps = {\n  image: {\n    type: 'image',\n    value: null,\n    async: true\n  },\n  bounds: {\n    type: 'array',\n    value: [1, 0, 0, 1],\n    compare: true\n  },\n  _imageCoordinateSystem: constants/* COORDINATE_SYSTEM.DEFAULT */.Df.DEFAULT,\n  desaturate: {\n    type: 'number',\n    min: 0,\n    max: 1,\n    value: 0\n  },\n  transparentColor: {\n    type: 'color',\n    value: [0, 0, 0, 0]\n  },\n  tintColor: {\n    type: 'color',\n    value: [255, 255, 255]\n  },\n  textureParameters: {\n    type: 'object',\n    ignore: true\n  }\n};\nclass BitmapLayer extends lib_layer/* default */.Z {\n  constructor(...args) {\n    super(...args);\n\n    (0,defineProperty/* default */.Z)(this, \"state\", void 0);\n  }\n\n  getShaders() {\n    return super.getShaders({\n      vs: bitmap_layer_vertex,\n      fs: bitmap_layer_fragment,\n      modules: [project32/* default */.Z, picking/* default */.Z]\n    });\n  }\n\n  initializeState() {\n    const attributeManager = this.getAttributeManager();\n    attributeManager.remove(['instancePickingColors']);\n    const noAlloc = true;\n    attributeManager.add({\n      indices: {\n        size: 1,\n        isIndexed: true,\n        update: attribute => attribute.value = this.state.mesh.indices,\n        noAlloc\n      },\n      positions: {\n        size: 3,\n        type: 5130,\n        fp64: this.use64bitPositions(),\n        update: attribute => attribute.value = this.state.mesh.positions,\n        noAlloc\n      },\n      texCoords: {\n        size: 2,\n        update: attribute => attribute.value = this.state.mesh.texCoords,\n        noAlloc\n      }\n    });\n  }\n\n  updateState({\n    props,\n    oldProps,\n    changeFlags\n  }) {\n    const attributeManager = this.getAttributeManager();\n\n    if (changeFlags.extensionsChanged) {\n      var _this$state$model;\n\n      const {\n        gl\n      } = this.context;\n      (_this$state$model = this.state.model) === null || _this$state$model === void 0 ? void 0 : _this$state$model.delete();\n      this.state.model = this._getModel(gl);\n      attributeManager.invalidateAll();\n    }\n\n    if (props.bounds !== oldProps.bounds) {\n      const oldMesh = this.state.mesh;\n\n      const mesh = this._createMesh();\n\n      this.state.model.setVertexCount(mesh.vertexCount);\n\n      for (const key in mesh) {\n        if (oldMesh && oldMesh[key] !== mesh[key]) {\n          attributeManager.invalidate(key);\n        }\n      }\n\n      this.setState({\n        mesh,\n        ...this._getCoordinateUniforms()\n      });\n    } else if (props._imageCoordinateSystem !== oldProps._imageCoordinateSystem) {\n      this.setState(this._getCoordinateUniforms());\n    }\n  }\n\n  getPickingInfo(params) {\n    const {\n      image\n    } = this.props;\n    const info = params.info;\n\n    if (!info.color || !image) {\n      info.bitmap = null;\n      return info;\n    }\n\n    const {\n      width,\n      height\n    } = image;\n    info.index = 0;\n    const uv = unpackUVsFromRGB(info.color);\n    const pixel = [Math.floor(uv[0] * width), Math.floor(uv[1] * height)];\n    info.bitmap = {\n      size: {\n        width,\n        height\n      },\n      uv,\n      pixel\n    };\n    return info;\n  }\n\n  disablePickingIndex() {\n    this.setState({\n      disablePicking: true\n    });\n  }\n\n  restorePickingColors() {\n    this.setState({\n      disablePicking: false\n    });\n  }\n\n  _updateAutoHighlight(info) {\n    super._updateAutoHighlight({ ...info,\n      color: this.encodePickingColor(0)\n    });\n  }\n\n  _createMesh() {\n    const {\n      bounds\n    } = this.props;\n    let normalizedBounds = bounds;\n\n    if (isRectangularBounds(bounds)) {\n      normalizedBounds = [[bounds[0], bounds[1]], [bounds[0], bounds[3]], [bounds[2], bounds[3]], [bounds[2], bounds[1]]];\n    }\n\n    return createMesh(normalizedBounds, this.context.viewport.resolution);\n  }\n\n  _getModel(gl) {\n    if (!gl) {\n      return null;\n    }\n\n    return new model/* default */.Z(gl, { ...this.getShaders(),\n      id: this.props.id,\n      geometry: new geometry/* default */.Z({\n        drawMode: 4,\n        vertexCount: 6\n      }),\n      isInstanced: false\n    });\n  }\n\n  draw(opts) {\n    const {\n      uniforms,\n      moduleParameters\n    } = opts;\n    const {\n      model,\n      coordinateConversion,\n      bounds,\n      disablePicking\n    } = this.state;\n    const {\n      image,\n      desaturate,\n      transparentColor,\n      tintColor\n    } = this.props;\n\n    if (moduleParameters.pickingActive && disablePicking) {\n      return;\n    }\n\n    if (image && model) {\n      model.setUniforms(uniforms).setUniforms({\n        bitmapTexture: image,\n        desaturate,\n        transparentColor: transparentColor.map(x => x / 255),\n        tintColor: tintColor.slice(0, 3).map(x => x / 255),\n        coordinateConversion,\n        bounds\n      }).draw();\n    }\n  }\n\n  _getCoordinateUniforms() {\n    const {\n      LNGLAT,\n      CARTESIAN,\n      DEFAULT\n    } = constants/* COORDINATE_SYSTEM */.Df;\n    let {\n      _imageCoordinateSystem: imageCoordinateSystem\n    } = this.props;\n\n    if (imageCoordinateSystem !== DEFAULT) {\n      const {\n        bounds\n      } = this.props;\n\n      if (!isRectangularBounds(bounds)) {\n        throw new Error('_imageCoordinateSystem only supports rectangular bounds');\n      }\n\n      const defaultImageCoordinateSystem = this.context.viewport.resolution ? LNGLAT : CARTESIAN;\n      imageCoordinateSystem = imageCoordinateSystem === LNGLAT ? LNGLAT : CARTESIAN;\n\n      if (imageCoordinateSystem === LNGLAT && defaultImageCoordinateSystem === CARTESIAN) {\n        return {\n          coordinateConversion: -1,\n          bounds\n        };\n      }\n\n      if (imageCoordinateSystem === CARTESIAN && defaultImageCoordinateSystem === LNGLAT) {\n        const bottomLeft = (0,esm/* lngLatToWorld */.w5)([bounds[0], bounds[1]]);\n        const topRight = (0,esm/* lngLatToWorld */.w5)([bounds[2], bounds[3]]);\n        return {\n          coordinateConversion: 1,\n          bounds: [bottomLeft[0], bottomLeft[1], topRight[0], topRight[1]]\n        };\n      }\n    }\n\n    return {\n      coordinateConversion: 0,\n      bounds: [0, 0, 0, 0]\n    };\n  }\n\n}\n\n(0,defineProperty/* default */.Z)(BitmapLayer, \"layerName\", 'BitmapLayer');\n\n(0,defineProperty/* default */.Z)(BitmapLayer, \"defaultProps\", defaultProps);\n\nfunction unpackUVsFromRGB(color) {\n  const [u, v, fracUV] = color;\n  const vFrac = (fracUV & 0xf0) / 256;\n  const uFrac = (fracUV & 0x0f) / 16;\n  return [(u + uFrac) / 256, (v + vFrac) / 256];\n}\n\nfunction isRectangularBounds(bounds) {\n  return Number.isFinite(bounds[0]);\n}\n//# sourceMappingURL=bitmap-layer.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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aUNBQWU7O0FBRWYsaUNBQWU7O0FBRWY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdnVlMy13ZWJwYWNrNS8uL25vZGVfbW9kdWxlcy9AZGVjay5nbC9sYXllcnMvZGlzdC9lc20vYml0bWFwLWxheWVyL2NyZWF0ZS1tZXNoLmpzPzY5MmMiLCJ3ZWJwYWNrOi8vdnVlMy13ZWJwYWNrNS8uL25vZGVfbW9kdWxlcy9AZGVjay5nbC9sYXllcnMvZGlzdC9lc20vYml0bWFwLWxheWVyL2JpdG1hcC1sYXllci12ZXJ0ZXguanM/NzIwMyIsIndlYnBhY2s6Ly92dWUzLXdlYnBhY2s1Ly4vbm9kZV9tb2R1bGVzL0BkZWNrLmdsL2xheWVycy9kaXN0L2VzbS9iaXRtYXAtbGF5ZXIvYml0bWFwLWxheWVyLWZyYWdtZW50LmpzP2U2MmYiLCJ3ZWJwYWNrOi8vdnVlMy13ZWJwYWNrNS8uL25vZGVfbW9kdWxlcy9AZGVjay5nbC9sYXllcnMvZGlzdC9lc20vYml0bWFwLWxheWVyL2JpdG1hcC1sYXllci5qcz8xYjUzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGxlcnAgfSBmcm9tICdAbWF0aC5nbC9jb3JlJztcbmNvbnN0IERFRkFVTFRfSU5ESUNFUyA9IG5ldyBVaW50MTZBcnJheShbMCwgMiwgMSwgMCwgMywgMl0pO1xuY29uc3QgREVGQVVMVF9URVhfQ09PUkRTID0gbmV3IEZsb2F0MzJBcnJheShbMCwgMSwgMCwgMCwgMSwgMCwgMSwgMV0pO1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gY3JlYXRlTWVzaChib3VuZHMsIHJlc29sdXRpb24pIHtcbiAgaWYgKCFyZXNvbHV0aW9uKSB7XG4gICAgcmV0dXJuIGNyZWF0ZVF1YWQoYm91bmRzKTtcbiAgfVxuXG4gIGNvbnN0IG1heFhTcGFuID0gTWF0aC5tYXgoTWF0aC5hYnMoYm91bmRzWzBdWzBdIC0gYm91bmRzWzNdWzBdKSwgTWF0aC5hYnMoYm91bmRzWzFdWzBdIC0gYm91bmRzWzJdWzBdKSk7XG4gIGNvbnN0IG1heFlTcGFuID0gTWF0aC5tYXgoTWF0aC5hYnMoYm91bmRzWzFdWzFdIC0gYm91bmRzWzBdWzFdKSwgTWF0aC5hYnMoYm91bmRzWzJdWzFdIC0gYm91bmRzWzNdWzFdKSk7XG4gIGNvbnN0IHVDb3VudCA9IE1hdGguY2VpbChtYXhYU3BhbiAvIHJlc29sdXRpb24pICsgMTtcbiAgY29uc3QgdkNvdW50ID0gTWF0aC5jZWlsKG1heFlTcGFuIC8gcmVzb2x1dGlvbikgKyAxO1xuICBjb25zdCB2ZXJ0ZXhDb3VudCA9ICh1Q291bnQgLSAxKSAqICh2Q291bnQgLSAxKSAqIDY7XG4gIGNvbnN0IGluZGljZXMgPSBuZXcgVWludDMyQXJyYXkodmVydGV4Q291bnQpO1xuICBjb25zdCB0ZXhDb29yZHMgPSBuZXcgRmxvYXQzMkFycmF5KHVDb3VudCAqIHZDb3VudCAqIDIpO1xuICBjb25zdCBwb3NpdGlvbnMgPSBuZXcgRmxvYXQ2NEFycmF5KHVDb3VudCAqIHZDb3VudCAqIDMpO1xuICBsZXQgdmVydGV4ID0gMDtcbiAgbGV0IGluZGV4ID0gMDtcblxuICBmb3IgKGxldCB1ID0gMDsgdSA8IHVDb3VudDsgdSsrKSB7XG4gICAgY29uc3QgdXQgPSB1IC8gKHVDb3VudCAtIDEpO1xuXG4gICAgZm9yIChsZXQgdiA9IDA7IHYgPCB2Q291bnQ7IHYrKykge1xuICAgICAgY29uc3QgdnQgPSB2IC8gKHZDb3VudCAtIDEpO1xuICAgICAgY29uc3QgcCA9IGludGVycG9sYXRlUXVhZChib3VuZHMsIHV0LCB2dCk7XG4gICAgICBwb3NpdGlvbnNbdmVydGV4ICogMyArIDBdID0gcFswXTtcbiAgICAgIHBvc2l0aW9uc1t2ZXJ0ZXggKiAzICsgMV0gPSBwWzFdO1xuICAgICAgcG9zaXRpb25zW3ZlcnRleCAqIDMgKyAyXSA9IHBbMl0gfHwgMDtcbiAgICAgIHRleENvb3Jkc1t2ZXJ0ZXggKiAyICsgMF0gPSB1dDtcbiAgICAgIHRleENvb3Jkc1t2ZXJ0ZXggKiAyICsgMV0gPSAxIC0gdnQ7XG5cbiAgICAgIGlmICh1ID4gMCAmJiB2ID4gMCkge1xuICAgICAgICBpbmRpY2VzW2luZGV4KytdID0gdmVydGV4IC0gdkNvdW50O1xuICAgICAgICBpbmRpY2VzW2luZGV4KytdID0gdmVydGV4IC0gdkNvdW50IC0gMTtcbiAgICAgICAgaW5kaWNlc1tpbmRleCsrXSA9IHZlcnRleCAtIDE7XG4gICAgICAgIGluZGljZXNbaW5kZXgrK10gPSB2ZXJ0ZXggLSB2Q291bnQ7XG4gICAgICAgIGluZGljZXNbaW5kZXgrK10gPSB2ZXJ0ZXggLSAxO1xuICAgICAgICBpbmRpY2VzW2luZGV4KytdID0gdmVydGV4O1xuICAgICAgfVxuXG4gICAgICB2ZXJ0ZXgrKztcbiAgICB9XG4gIH1cblxuICByZXR1cm4ge1xuICAgIHZlcnRleENvdW50LFxuICAgIHBvc2l0aW9ucyxcbiAgICBpbmRpY2VzLFxuICAgIHRleENvb3Jkc1xuICB9O1xufVxuXG5mdW5jdGlvbiBjcmVhdGVRdWFkKGJvdW5kcykge1xuICBjb25zdCBwb3NpdGlvbnMgPSBuZXcgRmxvYXQ2NEFycmF5KDEyKTtcblxuICBmb3IgKGxldCBpID0gMDsgaSA8IGJvdW5kcy5sZW5ndGg7IGkrKykge1xuICAgIHBvc2l0aW9uc1tpICogMyArIDBdID0gYm91bmRzW2ldWzBdO1xuICAgIHBvc2l0aW9uc1tpICogMyArIDFdID0gYm91bmRzW2ldWzFdO1xuICAgIHBvc2l0aW9uc1tpICogMyArIDJdID0gYm91bmRzW2ldWzJdIHx8IDA7XG4gIH1cblxuICByZXR1cm4ge1xuICAgIHZlcnRleENvdW50OiA2LFxuICAgIHBvc2l0aW9ucyxcbiAgICBpbmRpY2VzOiBERUZBVUxUX0lORElDRVMsXG4gICAgdGV4Q29vcmRzOiBERUZBVUxUX1RFWF9DT09SRFNcbiAgfTtcbn1cblxuZnVuY3Rpb24gaW50ZXJwb2xhdGVRdWFkKHF1YWQsIHV0LCB2dCkge1xuICByZXR1cm4gbGVycChsZXJwKHF1YWRbMF0sIHF1YWRbMV0sIHZ0KSwgbGVycChxdWFkWzNdLCBxdWFkWzJdLCB2dCksIHV0KTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNyZWF0ZS1tZXNoLmpzLm1hcCIsImV4cG9ydCBkZWZhdWx0IFwiXFxuI2RlZmluZSBTSEFERVJfTkFNRSBiaXRtYXAtbGF5ZXItdmVydGV4LXNoYWRlclxcblxcbmF0dHJpYnV0ZSB2ZWMyIHRleENvb3JkcztcXG5hdHRyaWJ1dGUgdmVjMyBwb3NpdGlvbnM7XFxuYXR0cmlidXRlIHZlYzMgcG9zaXRpb25zNjRMb3c7XFxuXFxudmFyeWluZyB2ZWMyIHZUZXhDb29yZDtcXG52YXJ5aW5nIHZlYzIgdlRleFBvcztcXG5cXG51bmlmb3JtIGZsb2F0IGNvb3JkaW5hdGVDb252ZXJzaW9uO1xcblxcbmNvbnN0IHZlYzMgcGlja2luZ0NvbG9yID0gdmVjMygxLjAsIDAuMCwgMC4wKTtcXG5cXG52b2lkIG1haW4odm9pZCkge1xcbiAgZ2VvbWV0cnkud29ybGRQb3NpdGlvbiA9IHBvc2l0aW9ucztcXG4gIGdlb21ldHJ5LnV2ID0gdGV4Q29vcmRzO1xcbiAgZ2VvbWV0cnkucGlja2luZ0NvbG9yID0gcGlja2luZ0NvbG9yO1xcblxcbiAgZ2xfUG9zaXRpb24gPSBwcm9qZWN0X3Bvc2l0aW9uX3RvX2NsaXBzcGFjZShwb3NpdGlvbnMsIHBvc2l0aW9uczY0TG93LCB2ZWMzKDAuMCksIGdlb21ldHJ5LnBvc2l0aW9uKTtcXG4gIERFQ0tHTF9GSUxURVJfR0xfUE9TSVRJT04oZ2xfUG9zaXRpb24sIGdlb21ldHJ5KTtcXG5cXG4gIHZUZXhDb29yZCA9IHRleENvb3JkcztcXG5cXG4gIGlmIChjb29yZGluYXRlQ29udmVyc2lvbiA8IC0wLjUpIHtcXG4gICAgdlRleFBvcyA9IGdlb21ldHJ5LnBvc2l0aW9uLnh5ICsgcHJvamVjdF91Q29tbW9uT3JpZ2luLnh5O1xcbiAgfSBlbHNlIGlmIChjb29yZGluYXRlQ29udmVyc2lvbiA+IDAuNSkge1xcbiAgICB2VGV4UG9zID0gZ2VvbWV0cnkud29ybGRQb3NpdGlvbi54eTtcXG4gIH1cXG5cXG4gIHZlYzQgY29sb3IgPSB2ZWM0KDAuMCk7XFxuICBERUNLR0xfRklMVEVSX0NPTE9SKGNvbG9yLCBnZW9tZXRyeSk7XFxufVxcblwiO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Yml0bWFwLWxheWVyLXZlcnRleC5qcy5tYXAiLCJjb25zdCBwYWNrVVZzSW50b1JHQiA9IFwiXFxudmVjMyBwYWNrVVZzSW50b1JHQih2ZWMyIHV2KSB7XFxuICAvLyBFeHRyYWN0IHRoZSB0b3AgOCBiaXRzLiBXZSB3YW50IHZhbHVlcyB0byBiZSB0cnVuY2F0ZWQgZG93biBzbyB3ZSBjYW4gYWRkIGEgZnJhY3Rpb25cXG4gIHZlYzIgdXY4Yml0ID0gZmxvb3IodXYgKiAyNTYuKTtcXG5cXG4gIC8vIENhbGN1bGF0ZSB0aGUgbm9ybWFsaXplZCByZW1haW5kZXJzIG9mIHUgYW5kIHYgcGFydHMgdGhhdCBkbyBub3QgZml0IGludG8gOCBiaXRzXFxuICAvLyBTY2FsZSBhbmQgY2xhbXAgdG8gMC0xIHJhbmdlXFxuICB2ZWMyIHV2RnJhY3Rpb24gPSBmcmFjdCh1diAqIDI1Ni4pO1xcbiAgdmVjMiB1dkZyYWN0aW9uNGJpdCA9IGZsb29yKHV2RnJhY3Rpb24gKiAxNi4pO1xcblxcbiAgLy8gUmVtYWluZGVyIGNhbiBiZSBlbmNvZGVkIGluIGJsdWUgY2hhbm5lbCwgZW5jb2RlIGFzIDQgYml0cyBmb3IgcGl4ZWwgY29vcmRpbmF0ZXNcXG4gIGZsb2F0IGZyYWN0aW9ucyA9IHV2RnJhY3Rpb240Yml0LnggKyB1dkZyYWN0aW9uNGJpdC55ICogMTYuO1xcblxcbiAgcmV0dXJuIHZlYzModXY4Yml0LCBmcmFjdGlvbnMpIC8gMjU1LjtcXG59XFxuXCI7XG5leHBvcnQgZGVmYXVsdCBcIlxcbiNkZWZpbmUgU0hBREVSX05BTUUgYml0bWFwLWxheWVyLWZyYWdtZW50LXNoYWRlclxcblxcbiNpZmRlZiBHTF9FU1xcbnByZWNpc2lvbiBoaWdocCBmbG9hdDtcXG4jZW5kaWZcXG5cXG51bmlmb3JtIHNhbXBsZXIyRCBiaXRtYXBUZXh0dXJlO1xcblxcbnZhcnlpbmcgdmVjMiB2VGV4Q29vcmQ7XFxudmFyeWluZyB2ZWMyIHZUZXhQb3M7XFxuXFxudW5pZm9ybSBmbG9hdCBkZXNhdHVyYXRlO1xcbnVuaWZvcm0gdmVjNCB0cmFuc3BhcmVudENvbG9yO1xcbnVuaWZvcm0gdmVjMyB0aW50Q29sb3I7XFxudW5pZm9ybSBmbG9hdCBvcGFjaXR5O1xcblxcbnVuaWZvcm0gZmxvYXQgY29vcmRpbmF0ZUNvbnZlcnNpb247XFxudW5pZm9ybSB2ZWM0IGJvdW5kcztcXG5cXG4vKiBwcm9qZWN0aW9uIHV0aWxzICovXFxuY29uc3QgZmxvYXQgVElMRV9TSVpFID0gNTEyLjA7XFxuY29uc3QgZmxvYXQgUEkgPSAzLjE0MTU5MjY1MzY7XFxuY29uc3QgZmxvYXQgV09STERfU0NBTEUgPSBUSUxFX1NJWkUgLyBQSSAvIDIuMDtcXG5cXG4vLyBmcm9tIGRlZ3JlZXMgdG8gV2ViIE1lcmNhdG9yXFxudmVjMiBsbmdsYXRfdG9fbWVyY2F0b3IodmVjMiBsbmdsYXQpIHtcXG4gIGZsb2F0IHggPSBsbmdsYXQueDtcXG4gIGZsb2F0IHkgPSBjbGFtcChsbmdsYXQueSwgLTg5LjksIDg5LjkpO1xcbiAgcmV0dXJuIHZlYzIoXFxuICAgIHJhZGlhbnMoeCkgKyBQSSxcXG4gICAgUEkgKyBsb2codGFuKFBJICogMC4yNSArIHJhZGlhbnMoeSkgKiAwLjUpKVxcbiAgKSAqIFdPUkxEX1NDQUxFO1xcbn1cXG5cXG4vLyBmcm9tIFdlYiBNZXJjYXRvciB0byBkZWdyZWVzXFxudmVjMiBtZXJjYXRvcl90b19sbmdsYXQodmVjMiB4eSkge1xcbiAgeHkgLz0gV09STERfU0NBTEU7XFxuICByZXR1cm4gZGVncmVlcyh2ZWMyKFxcbiAgICB4eS54IC0gUEksXFxuICAgIGF0YW4oZXhwKHh5LnkgLSBQSSkpICogMi4wIC0gUEkgKiAwLjVcXG4gICkpO1xcbn1cXG4vKiBFbmQgcHJvamVjdGlvbiB1dGlscyAqL1xcblxcbi8vIGFwcGx5IGRlc2F0dXJhdGlvblxcbnZlYzMgY29sb3JfZGVzYXR1cmF0ZSh2ZWMzIGNvbG9yKSB7XFxuICBmbG9hdCBsdW1pbmFuY2UgPSAoY29sb3IuciArIGNvbG9yLmcgKyBjb2xvci5iKSAqIDAuMzMzMzMzMzMzO1xcbiAgcmV0dXJuIG1peChjb2xvciwgdmVjMyhsdW1pbmFuY2UpLCBkZXNhdHVyYXRlKTtcXG59XFxuXFxuLy8gYXBwbHkgdGludFxcbnZlYzMgY29sb3JfdGludCh2ZWMzIGNvbG9yKSB7XFxuICByZXR1cm4gY29sb3IgKiB0aW50Q29sb3I7XFxufVxcblxcbi8vIGJsZW5kIHdpdGggYmFja2dyb3VuZCBjb2xvclxcbnZlYzQgYXBwbHlfb3BhY2l0eSh2ZWMzIGNvbG9yLCBmbG9hdCBhbHBoYSkge1xcbiAgaWYgKHRyYW5zcGFyZW50Q29sb3IuYSA9PSAwLjApIHtcXG4gICAgcmV0dXJuIHZlYzQoY29sb3IsIGFscGhhKTtcXG4gIH1cXG4gIGZsb2F0IGJsZW5kZWRBbHBoYSA9IGFscGhhICsgdHJhbnNwYXJlbnRDb2xvci5hICogKDEuMCAtIGFscGhhKTtcXG4gIGZsb2F0IGhpZ2hMaWdodFJhdGlvID0gYWxwaGEgLyBibGVuZGVkQWxwaGE7XFxuICB2ZWMzIGJsZW5kZWRSR0IgPSBtaXgodHJhbnNwYXJlbnRDb2xvci5yZ2IsIGNvbG9yLCBoaWdoTGlnaHRSYXRpbyk7XFxuICByZXR1cm4gdmVjNChibGVuZGVkUkdCLCBibGVuZGVkQWxwaGEpO1xcbn1cXG5cXG52ZWMyIGdldFVWKHZlYzIgcG9zKSB7XFxuICByZXR1cm4gdmVjMihcXG4gICAgKHBvcy54IC0gYm91bmRzWzBdKSAvIChib3VuZHNbMl0gLSBib3VuZHNbMF0pLFxcbiAgICAocG9zLnkgLSBib3VuZHNbM10pIC8gKGJvdW5kc1sxXSAtIGJvdW5kc1szXSlcXG4gICk7XFxufVxcblxcblwiLmNvbmNhdChwYWNrVVZzSW50b1JHQiwgXCJcXG5cXG52b2lkIG1haW4odm9pZCkge1xcbiAgdmVjMiB1diA9IHZUZXhDb29yZDtcXG4gIGlmIChjb29yZGluYXRlQ29udmVyc2lvbiA8IC0wLjUpIHtcXG4gICAgdmVjMiBsbmdsYXQgPSBtZXJjYXRvcl90b19sbmdsYXQodlRleFBvcyk7XFxuICAgIHV2ID0gZ2V0VVYobG5nbGF0KTtcXG4gIH0gZWxzZSBpZiAoY29vcmRpbmF0ZUNvbnZlcnNpb24gPiAwLjUpIHtcXG4gICAgdmVjMiBjb21tb25Qb3MgPSBsbmdsYXRfdG9fbWVyY2F0b3IodlRleFBvcyk7XFxuICAgIHV2ID0gZ2V0VVYoY29tbW9uUG9zKTtcXG4gIH1cXG4gIHZlYzQgYml0bWFwQ29sb3IgPSB0ZXh0dXJlMkQoYml0bWFwVGV4dHVyZSwgdXYpO1xcblxcbiAgZ2xfRnJhZ0NvbG9yID0gYXBwbHlfb3BhY2l0eShjb2xvcl90aW50KGNvbG9yX2Rlc2F0dXJhdGUoYml0bWFwQ29sb3IucmdiKSksIGJpdG1hcENvbG9yLmEgKiBvcGFjaXR5KTtcXG5cXG4gIGdlb21ldHJ5LnV2ID0gdXY7XFxuICBERUNLR0xfRklMVEVSX0NPTE9SKGdsX0ZyYWdDb2xvciwgZ2VvbWV0cnkpO1xcblxcbiAgaWYgKHBpY2tpbmdfdUFjdGl2ZSAmJiAhcGlja2luZ191QXR0cmlidXRlKSB7XFxuICAgIC8vIFNpbmNlIGluc3RhbmNlIGluZm9ybWF0aW9uIGlzIG5vdCB1c2VkLCB3ZSBjYW4gdXNlIHBpY2tpbmcgY29sb3IgZm9yIHBpeGVsIGluZGV4XFxuICAgIGdsX0ZyYWdDb2xvci5yZ2IgPSBwYWNrVVZzSW50b1JHQih1dik7XFxuICB9XFxufVxcblwiKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWJpdG1hcC1sYXllci1mcmFnbWVudC5qcy5tYXAiLCJpbXBvcnQgX2RlZmluZVByb3BlcnR5IGZyb20gXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9kZWZpbmVQcm9wZXJ0eVwiO1xuaW1wb3J0IHsgTGF5ZXIsIHByb2plY3QzMiwgcGlja2luZywgQ09PUkRJTkFURV9TWVNURU0gfSBmcm9tICdAZGVjay5nbC9jb3JlJztcbmltcG9ydCB7IE1vZGVsLCBHZW9tZXRyeSB9IGZyb20gJ0BsdW1hLmdsL2NvcmUnO1xuaW1wb3J0IHsgbG5nTGF0VG9Xb3JsZCB9IGZyb20gJ0BtYXRoLmdsL3dlYi1tZXJjYXRvcic7XG5pbXBvcnQgY3JlYXRlTWVzaCBmcm9tICcuL2NyZWF0ZS1tZXNoJztcbmltcG9ydCB2cyBmcm9tICcuL2JpdG1hcC1sYXllci12ZXJ0ZXgnO1xuaW1wb3J0IGZzIGZyb20gJy4vYml0bWFwLWxheWVyLWZyYWdtZW50JztcbmNvbnN0IGRlZmF1bHRQcm9wcyA9IHtcbiAgaW1hZ2U6IHtcbiAgICB0eXBlOiAnaW1hZ2UnLFxuICAgIHZhbHVlOiBudWxsLFxuICAgIGFzeW5jOiB0cnVlXG4gIH0sXG4gIGJvdW5kczoge1xuICAgIHR5cGU6ICdhcnJheScsXG4gICAgdmFsdWU6IFsxLCAwLCAwLCAxXSxcbiAgICBjb21wYXJlOiB0cnVlXG4gIH0sXG4gIF9pbWFnZUNvb3JkaW5hdGVTeXN0ZW06IENPT1JESU5BVEVfU1lTVEVNLkRFRkFVTFQsXG4gIGRlc2F0dXJhdGU6IHtcbiAgICB0eXBlOiAnbnVtYmVyJyxcbiAgICBtaW46IDAsXG4gICAgbWF4OiAxLFxuICAgIHZhbHVlOiAwXG4gIH0sXG4gIHRyYW5zcGFyZW50Q29sb3I6IHtcbiAgICB0eXBlOiAnY29sb3InLFxuICAgIHZhbHVlOiBbMCwgMCwgMCwgMF1cbiAgfSxcbiAgdGludENvbG9yOiB7XG4gICAgdHlwZTogJ2NvbG9yJyxcbiAgICB2YWx1ZTogWzI1NSwgMjU1LCAyNTVdXG4gIH0sXG4gIHRleHR1cmVQYXJhbWV0ZXJzOiB7XG4gICAgdHlwZTogJ29iamVjdCcsXG4gICAgaWdub3JlOiB0cnVlXG4gIH1cbn07XG5leHBvcnQgZGVmYXVsdCBjbGFzcyBCaXRtYXBMYXllciBleHRlbmRzIExheWVyIHtcbiAgY29uc3RydWN0b3IoLi4uYXJncykge1xuICAgIHN1cGVyKC4uLmFyZ3MpO1xuXG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwic3RhdGVcIiwgdm9pZCAwKTtcbiAgfVxuXG4gIGdldFNoYWRlcnMoKSB7XG4gICAgcmV0dXJuIHN1cGVyLmdldFNoYWRlcnMoe1xuICAgICAgdnMsXG4gICAgICBmcyxcbiAgICAgIG1vZHVsZXM6IFtwcm9qZWN0MzIsIHBpY2tpbmddXG4gICAgfSk7XG4gIH1cblxuICBpbml0aWFsaXplU3RhdGUoKSB7XG4gICAgY29uc3QgYXR0cmlidXRlTWFuYWdlciA9IHRoaXMuZ2V0QXR0cmlidXRlTWFuYWdlcigpO1xuICAgIGF0dHJpYnV0ZU1hbmFnZXIucmVtb3ZlKFsnaW5zdGFuY2VQaWNraW5nQ29sb3JzJ10pO1xuICAgIGNvbnN0IG5vQWxsb2MgPSB0cnVlO1xuICAgIGF0dHJpYnV0ZU1hbmFnZXIuYWRkKHtcbiAgICAgIGluZGljZXM6IHtcbiAgICAgICAgc2l6ZTogMSxcbiAgICAgICAgaXNJbmRleGVkOiB0cnVlLFxuICAgICAgICB1cGRhdGU6IGF0dHJpYnV0ZSA9PiBhdHRyaWJ1dGUudmFsdWUgPSB0aGlzLnN0YXRlLm1lc2guaW5kaWNlcyxcbiAgICAgICAgbm9BbGxvY1xuICAgICAgfSxcbiAgICAgIHBvc2l0aW9uczoge1xuICAgICAgICBzaXplOiAzLFxuICAgICAgICB0eXBlOiA1MTMwLFxuICAgICAgICBmcDY0OiB0aGlzLnVzZTY0Yml0UG9zaXRpb25zKCksXG4gICAgICAgIHVwZGF0ZTogYXR0cmlidXRlID0+IGF0dHJpYnV0ZS52YWx1ZSA9IHRoaXMuc3RhdGUubWVzaC5wb3NpdGlvbnMsXG4gICAgICAgIG5vQWxsb2NcbiAgICAgIH0sXG4gICAgICB0ZXhDb29yZHM6IHtcbiAgICAgICAgc2l6ZTogMixcbiAgICAgICAgdXBkYXRlOiBhdHRyaWJ1dGUgPT4gYXR0cmlidXRlLnZhbHVlID0gdGhpcy5zdGF0ZS5tZXNoLnRleENvb3JkcyxcbiAgICAgICAgbm9BbGxvY1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgdXBkYXRlU3RhdGUoe1xuICAgIHByb3BzLFxuICAgIG9sZFByb3BzLFxuICAgIGNoYW5nZUZsYWdzXG4gIH0pIHtcbiAgICBjb25zdCBhdHRyaWJ1dGVNYW5hZ2VyID0gdGhpcy5nZXRBdHRyaWJ1dGVNYW5hZ2VyKCk7XG5cbiAgICBpZiAoY2hhbmdlRmxhZ3MuZXh0ZW5zaW9uc0NoYW5nZWQpIHtcbiAgICAgIHZhciBfdGhpcyRzdGF0ZSRtb2RlbDtcblxuICAgICAgY29uc3Qge1xuICAgICAgICBnbFxuICAgICAgfSA9IHRoaXMuY29udGV4dDtcbiAgICAgIChfdGhpcyRzdGF0ZSRtb2RlbCA9IHRoaXMuc3RhdGUubW9kZWwpID09PSBudWxsIHx8IF90aGlzJHN0YXRlJG1vZGVsID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfdGhpcyRzdGF0ZSRtb2RlbC5kZWxldGUoKTtcbiAgICAgIHRoaXMuc3RhdGUubW9kZWwgPSB0aGlzLl9nZXRNb2RlbChnbCk7XG4gICAgICBhdHRyaWJ1dGVNYW5hZ2VyLmludmFsaWRhdGVBbGwoKTtcbiAgICB9XG5cbiAgICBpZiAocHJvcHMuYm91bmRzICE9PSBvbGRQcm9wcy5ib3VuZHMpIHtcbiAgICAgIGNvbnN0IG9sZE1lc2ggPSB0aGlzLnN0YXRlLm1lc2g7XG5cbiAgICAgIGNvbnN0IG1lc2ggPSB0aGlzLl9jcmVhdGVNZXNoKCk7XG5cbiAgICAgIHRoaXMuc3RhdGUubW9kZWwuc2V0VmVydGV4Q291bnQobWVzaC52ZXJ0ZXhDb3VudCk7XG5cbiAgICAgIGZvciAoY29uc3Qga2V5IGluIG1lc2gpIHtcbiAgICAgICAgaWYgKG9sZE1lc2ggJiYgb2xkTWVzaFtrZXldICE9PSBtZXNoW2tleV0pIHtcbiAgICAgICAgICBhdHRyaWJ1dGVNYW5hZ2VyLmludmFsaWRhdGUoa2V5KTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgICAgbWVzaCxcbiAgICAgICAgLi4udGhpcy5fZ2V0Q29vcmRpbmF0ZVVuaWZvcm1zKClcbiAgICAgIH0pO1xuICAgIH0gZWxzZSBpZiAocHJvcHMuX2ltYWdlQ29vcmRpbmF0ZVN5c3RlbSAhPT0gb2xkUHJvcHMuX2ltYWdlQ29vcmRpbmF0ZVN5c3RlbSkge1xuICAgICAgdGhpcy5zZXRTdGF0ZSh0aGlzLl9nZXRDb29yZGluYXRlVW5pZm9ybXMoKSk7XG4gICAgfVxuICB9XG5cbiAgZ2V0UGlja2luZ0luZm8ocGFyYW1zKSB7XG4gICAgY29uc3Qge1xuICAgICAgaW1hZ2VcbiAgICB9ID0gdGhpcy5wcm9wcztcbiAgICBjb25zdCBpbmZvID0gcGFyYW1zLmluZm87XG5cbiAgICBpZiAoIWluZm8uY29sb3IgfHwgIWltYWdlKSB7XG4gICAgICBpbmZvLmJpdG1hcCA9IG51bGw7XG4gICAgICByZXR1cm4gaW5mbztcbiAgICB9XG5cbiAgICBjb25zdCB7XG4gICAgICB3aWR0aCxcbiAgICAgIGhlaWdodFxuICAgIH0gPSBpbWFnZTtcbiAgICBpbmZvLmluZGV4ID0gMDtcbiAgICBjb25zdCB1diA9IHVucGFja1VWc0Zyb21SR0IoaW5mby5jb2xvcik7XG4gICAgY29uc3QgcGl4ZWwgPSBbTWF0aC5mbG9vcih1dlswXSAqIHdpZHRoKSwgTWF0aC5mbG9vcih1dlsxXSAqIGhlaWdodCldO1xuICAgIGluZm8uYml0bWFwID0ge1xuICAgICAgc2l6ZToge1xuICAgICAgICB3aWR0aCxcbiAgICAgICAgaGVpZ2h0XG4gICAgICB9LFxuICAgICAgdXYsXG4gICAgICBwaXhlbFxuICAgIH07XG4gICAgcmV0dXJuIGluZm87XG4gIH1cblxuICBkaXNhYmxlUGlja2luZ0luZGV4KCkge1xuICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgICAgZGlzYWJsZVBpY2tpbmc6IHRydWVcbiAgICB9KTtcbiAgfVxuXG4gIHJlc3RvcmVQaWNraW5nQ29sb3JzKCkge1xuICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgICAgZGlzYWJsZVBpY2tpbmc6IGZhbHNlXG4gICAgfSk7XG4gIH1cblxuICBfdXBkYXRlQXV0b0hpZ2hsaWdodChpbmZvKSB7XG4gICAgc3VwZXIuX3VwZGF0ZUF1dG9IaWdobGlnaHQoeyAuLi5pbmZvLFxuICAgICAgY29sb3I6IHRoaXMuZW5jb2RlUGlja2luZ0NvbG9yKDApXG4gICAgfSk7XG4gIH1cblxuICBfY3JlYXRlTWVzaCgpIHtcbiAgICBjb25zdCB7XG4gICAgICBib3VuZHNcbiAgICB9ID0gdGhpcy5wcm9wcztcbiAgICBsZXQgbm9ybWFsaXplZEJvdW5kcyA9IGJvdW5kcztcblxuICAgIGlmIChpc1JlY3Rhbmd1bGFyQm91bmRzKGJvdW5kcykpIHtcbiAgICAgIG5vcm1hbGl6ZWRCb3VuZHMgPSBbW2JvdW5kc1swXSwgYm91bmRzWzFdXSwgW2JvdW5kc1swXSwgYm91bmRzWzNdXSwgW2JvdW5kc1syXSwgYm91bmRzWzNdXSwgW2JvdW5kc1syXSwgYm91bmRzWzFdXV07XG4gICAgfVxuXG4gICAgcmV0dXJuIGNyZWF0ZU1lc2gobm9ybWFsaXplZEJvdW5kcywgdGhpcy5jb250ZXh0LnZpZXdwb3J0LnJlc29sdXRpb24pO1xuICB9XG5cbiAgX2dldE1vZGVsKGdsKSB7XG4gICAgaWYgKCFnbCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5ldyBNb2RlbChnbCwgeyAuLi50aGlzLmdldFNoYWRlcnMoKSxcbiAgICAgIGlkOiB0aGlzLnByb3BzLmlkLFxuICAgICAgZ2VvbWV0cnk6IG5ldyBHZW9tZXRyeSh7XG4gICAgICAgIGRyYXdNb2RlOiA0LFxuICAgICAgICB2ZXJ0ZXhDb3VudDogNlxuICAgICAgfSksXG4gICAgICBpc0luc3RhbmNlZDogZmFsc2VcbiAgICB9KTtcbiAgfVxuXG4gIGRyYXcob3B0cykge1xuICAgIGNvbnN0IHtcbiAgICAgIHVuaWZvcm1zLFxuICAgICAgbW9kdWxlUGFyYW1ldGVyc1xuICAgIH0gPSBvcHRzO1xuICAgIGNvbnN0IHtcbiAgICAgIG1vZGVsLFxuICAgICAgY29vcmRpbmF0ZUNvbnZlcnNpb24sXG4gICAgICBib3VuZHMsXG4gICAgICBkaXNhYmxlUGlja2luZ1xuICAgIH0gPSB0aGlzLnN0YXRlO1xuICAgIGNvbnN0IHtcbiAgICAgIGltYWdlLFxuICAgICAgZGVzYXR1cmF0ZSxcbiAgICAgIHRyYW5zcGFyZW50Q29sb3IsXG4gICAgICB0aW50Q29sb3JcbiAgICB9ID0gdGhpcy5wcm9wcztcblxuICAgIGlmIChtb2R1bGVQYXJhbWV0ZXJzLnBpY2tpbmdBY3RpdmUgJiYgZGlzYWJsZVBpY2tpbmcpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoaW1hZ2UgJiYgbW9kZWwpIHtcbiAgICAgIG1vZGVsLnNldFVuaWZvcm1zKHVuaWZvcm1zKS5zZXRVbmlmb3Jtcyh7XG4gICAgICAgIGJpdG1hcFRleHR1cmU6IGltYWdlLFxuICAgICAgICBkZXNhdHVyYXRlLFxuICAgICAgICB0cmFuc3BhcmVudENvbG9yOiB0cmFuc3BhcmVudENvbG9yLm1hcCh4ID0+IHggLyAyNTUpLFxuICAgICAgICB0aW50Q29sb3I6IHRpbnRDb2xvci5zbGljZSgwLCAzKS5tYXAoeCA9PiB4IC8gMjU1KSxcbiAgICAgICAgY29vcmRpbmF0ZUNvbnZlcnNpb24sXG4gICAgICAgIGJvdW5kc1xuICAgICAgfSkuZHJhdygpO1xuICAgIH1cbiAgfVxuXG4gIF9nZXRDb29yZGluYXRlVW5pZm9ybXMoKSB7XG4gICAgY29uc3Qge1xuICAgICAgTE5HTEFULFxuICAgICAgQ0FSVEVTSUFOLFxuICAgICAgREVGQVVMVFxuICAgIH0gPSBDT09SRElOQVRFX1NZU1RFTTtcbiAgICBsZXQge1xuICAgICAgX2ltYWdlQ29vcmRpbmF0ZVN5c3RlbTogaW1hZ2VDb29yZGluYXRlU3lzdGVtXG4gICAgfSA9IHRoaXMucHJvcHM7XG5cbiAgICBpZiAoaW1hZ2VDb29yZGluYXRlU3lzdGVtICE9PSBERUZBVUxUKSB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIGJvdW5kc1xuICAgICAgfSA9IHRoaXMucHJvcHM7XG5cbiAgICAgIGlmICghaXNSZWN0YW5ndWxhckJvdW5kcyhib3VuZHMpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignX2ltYWdlQ29vcmRpbmF0ZVN5c3RlbSBvbmx5IHN1cHBvcnRzIHJlY3Rhbmd1bGFyIGJvdW5kcycpO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBkZWZhdWx0SW1hZ2VDb29yZGluYXRlU3lzdGVtID0gdGhpcy5jb250ZXh0LnZpZXdwb3J0LnJlc29sdXRpb24gPyBMTkdMQVQgOiBDQVJURVNJQU47XG4gICAgICBpbWFnZUNvb3JkaW5hdGVTeXN0ZW0gPSBpbWFnZUNvb3JkaW5hdGVTeXN0ZW0gPT09IExOR0xBVCA/IExOR0xBVCA6IENBUlRFU0lBTjtcblxuICAgICAgaWYgKGltYWdlQ29vcmRpbmF0ZVN5c3RlbSA9PT0gTE5HTEFUICYmIGRlZmF1bHRJbWFnZUNvb3JkaW5hdGVTeXN0ZW0gPT09IENBUlRFU0lBTikge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGNvb3JkaW5hdGVDb252ZXJzaW9uOiAtMSxcbiAgICAgICAgICBib3VuZHNcbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgaWYgKGltYWdlQ29vcmRpbmF0ZVN5c3RlbSA9PT0gQ0FSVEVTSUFOICYmIGRlZmF1bHRJbWFnZUNvb3JkaW5hdGVTeXN0ZW0gPT09IExOR0xBVCkge1xuICAgICAgICBjb25zdCBib3R0b21MZWZ0ID0gbG5nTGF0VG9Xb3JsZChbYm91bmRzWzBdLCBib3VuZHNbMV1dKTtcbiAgICAgICAgY29uc3QgdG9wUmlnaHQgPSBsbmdMYXRUb1dvcmxkKFtib3VuZHNbMl0sIGJvdW5kc1szXV0pO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGNvb3JkaW5hdGVDb252ZXJzaW9uOiAxLFxuICAgICAgICAgIGJvdW5kczogW2JvdHRvbUxlZnRbMF0sIGJvdHRvbUxlZnRbMV0sIHRvcFJpZ2h0WzBdLCB0b3BSaWdodFsxXV1cbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgY29vcmRpbmF0ZUNvbnZlcnNpb246IDAsXG4gICAgICBib3VuZHM6IFswLCAwLCAwLCAwXVxuICAgIH07XG4gIH1cblxufVxuXG5fZGVmaW5lUHJvcGVydHkoQml0bWFwTGF5ZXIsIFwibGF5ZXJOYW1lXCIsICdCaXRtYXBMYXllcicpO1xuXG5fZGVmaW5lUHJvcGVydHkoQml0bWFwTGF5ZXIsIFwiZGVmYXVsdFByb3BzXCIsIGRlZmF1bHRQcm9wcyk7XG5cbmZ1bmN0aW9uIHVucGFja1VWc0Zyb21SR0IoY29sb3IpIHtcbiAgY29uc3QgW3UsIHYsIGZyYWNVVl0gPSBjb2xvcjtcbiAgY29uc3QgdkZyYWMgPSAoZnJhY1VWICYgMHhmMCkgLyAyNTY7XG4gIGNvbnN0IHVGcmFjID0gKGZyYWNVViAmIDB4MGYpIC8gMTY7XG4gIHJldHVybiBbKHUgKyB1RnJhYykgLyAyNTYsICh2ICsgdkZyYWMpIC8gMjU2XTtcbn1cblxuZnVuY3Rpb24gaXNSZWN0YW5ndWxhckJvdW5kcyhib3VuZHMpIHtcbiAgcmV0dXJuIE51bWJlci5pc0Zpbml0ZShib3VuZHNbMF0pO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Yml0bWFwLWxheWVyLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///13863\n")},13418:function(__unused_webpack_module,__webpack_exports__,__webpack_require__){eval("\n// EXPORTS\n__webpack_require__.d(__webpack_exports__, {\n  \"Z\": function() { return /* binding */ IconLayer; }\n});\n\n// EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/esm/defineProperty.js\nvar defineProperty = __webpack_require__(82482);\n// EXTERNAL MODULE: ./node_modules/@deck.gl/core/dist/esm/lib/layer.js + 3 modules\nvar lib_layer = __webpack_require__(52447);\n// EXTERNAL MODULE: ./node_modules/@deck.gl/core/dist/esm/shaderlib/project32/project32.js\nvar project32 = __webpack_require__(93844);\n// EXTERNAL MODULE: ./node_modules/@deck.gl/core/dist/esm/shaderlib/picking/picking.js\nvar picking = __webpack_require__(43844);\n// EXTERNAL MODULE: ./node_modules/@deck.gl/core/dist/esm/lib/constants.js\nvar constants = __webpack_require__(24088);\n// EXTERNAL MODULE: ./node_modules/@deck.gl/core/dist/esm/utils/log.js\nvar log = __webpack_require__(80744);\n// EXTERNAL MODULE: ./node_modules/@luma.gl/engine/dist/esm/lib/model.js + 1 modules\nvar model = __webpack_require__(80210);\n// EXTERNAL MODULE: ./node_modules/@luma.gl/engine/dist/esm/geometry/geometry.js\nvar geometry = __webpack_require__(53982);\n;// CONCATENATED MODULE: ./node_modules/@deck.gl/layers/dist/esm/icon-layer/icon-layer-vertex.glsl.js\n/* harmony default export */ var icon_layer_vertex_glsl = (\"#define SHADER_NAME icon-layer-vertex-shader\\n\\nattribute vec2 positions;\\n\\nattribute vec3 instancePositions;\\nattribute vec3 instancePositions64Low;\\nattribute float instanceSizes;\\nattribute float instanceAngles;\\nattribute vec4 instanceColors;\\nattribute vec3 instancePickingColors;\\nattribute vec4 instanceIconFrames;\\nattribute float instanceColorModes;\\nattribute vec2 instanceOffsets;\\nattribute vec2 instancePixelOffset;\\n\\nuniform float sizeScale;\\nuniform vec2 iconsTextureDim;\\nuniform float sizeMinPixels;\\nuniform float sizeMaxPixels;\\nuniform bool billboard;\\nuniform int sizeUnits;\\n\\nvarying float vColorMode;\\nvarying vec4 vColor;\\nvarying vec2 vTextureCoords;\\nvarying vec2 uv;\\n\\nvec2 rotate_by_angle(vec2 vertex, float angle) {\\n  float angle_radian = angle * PI / 180.0;\\n  float cos_angle = cos(angle_radian);\\n  float sin_angle = sin(angle_radian);\\n  mat2 rotationMatrix = mat2(cos_angle, -sin_angle, sin_angle, cos_angle);\\n  return rotationMatrix * vertex;\\n}\\n\\nvoid main(void) {\\n  geometry.worldPosition = instancePositions;\\n  geometry.uv = positions;\\n  geometry.pickingColor = instancePickingColors;\\n  uv = positions;\\n\\n  vec2 iconSize = instanceIconFrames.zw;\\n  float sizePixels = clamp(\\n    project_size_to_pixel(instanceSizes * sizeScale, sizeUnits), \\n    sizeMinPixels, sizeMaxPixels\\n  );\\n  float instanceScale = iconSize.y == 0.0 ? 0.0 : sizePixels / iconSize.y;\\n  vec2 pixelOffset = positions / 2.0 * iconSize + instanceOffsets;\\n  pixelOffset = rotate_by_angle(pixelOffset, instanceAngles) * instanceScale;\\n  pixelOffset += instancePixelOffset;\\n  pixelOffset.y *= -1.0;\\n\\n  if (billboard)  {\\n    gl_Position = project_position_to_clipspace(instancePositions, instancePositions64Low, vec3(0.0), geometry.position);\\n    DECKGL_FILTER_GL_POSITION(gl_Position, geometry);\\n    vec3 offset = vec3(pixelOffset, 0.0);\\n    DECKGL_FILTER_SIZE(offset, geometry);\\n    gl_Position.xy += project_pixel_size_to_clipspace(offset.xy);\\n\\n  } else {\\n    vec3 offset_common = vec3(project_pixel_size(pixelOffset), 0.0);\\n    DECKGL_FILTER_SIZE(offset_common, geometry);\\n    gl_Position = project_position_to_clipspace(instancePositions, instancePositions64Low, offset_common, geometry.position); \\n    DECKGL_FILTER_GL_POSITION(gl_Position, geometry);\\n  }\\n\\n  vTextureCoords = mix(\\n    instanceIconFrames.xy,\\n    instanceIconFrames.xy + iconSize,\\n    (positions.xy + 1.0) / 2.0\\n  ) / iconsTextureDim;\\n\\n  vColor = instanceColors;\\n  DECKGL_FILTER_COLOR(vColor, geometry);\\n\\n  vColorMode = instanceColorModes;\\n}\\n\");\n//# sourceMappingURL=icon-layer-vertex.glsl.js.map\n;// CONCATENATED MODULE: ./node_modules/@deck.gl/layers/dist/esm/icon-layer/icon-layer-fragment.glsl.js\n/* harmony default export */ var icon_layer_fragment_glsl = (\"#define SHADER_NAME icon-layer-fragment-shader\\n\\nprecision highp float;\\n\\nuniform float opacity;\\nuniform sampler2D iconsTexture;\\nuniform float alphaCutoff;\\n\\nvarying float vColorMode;\\nvarying vec4 vColor;\\nvarying vec2 vTextureCoords;\\nvarying vec2 uv;\\n\\nvoid main(void) {\\n  geometry.uv = uv;\\n\\n  vec4 texColor = texture2D(iconsTexture, vTextureCoords);\\n  vec3 color = mix(texColor.rgb, vColor.rgb, vColorMode);\\n  float a = texColor.a * opacity * vColor.a;\\n\\n  if (a < alphaCutoff) {\\n    discard;\\n  }\\n\\n  gl_FragColor = vec4(color, a);\\n  DECKGL_FILTER_COLOR(gl_FragColor, geometry);\\n}\\n\");\n//# sourceMappingURL=icon-layer-fragment.glsl.js.map\n// EXTERNAL MODULE: ./node_modules/@luma.gl/webgl/dist/esm/classes/texture-2d.js + 1 modules\nvar texture_2d = __webpack_require__(51621);\n// EXTERNAL MODULE: ./node_modules/@luma.gl/webgl/dist/esm/classes/copy-and-blit.js + 1 modules\nvar copy_and_blit = __webpack_require__(81913);\n// EXTERNAL MODULE: ./node_modules/@loaders.gl/core/dist/esm/lib/api/load.js + 24 modules\nvar load = __webpack_require__(44534);\n// EXTERNAL MODULE: ./node_modules/@deck.gl/core/dist/esm/utils/iterable-utils.js\nvar iterable_utils = __webpack_require__(38550);\n;// CONCATENATED MODULE: ./node_modules/@deck.gl/layers/dist/esm/icon-layer/icon-manager.js\n\n\n\n\nconst DEFAULT_CANVAS_WIDTH = 1024;\nconst DEFAULT_BUFFER = 4;\n\nconst noop = () => {};\n\nconst DEFAULT_TEXTURE_PARAMETERS = {\n  [10241]: 9987,\n  [10240]: 9729,\n  [10242]: 33071,\n  [10243]: 33071\n};\n\nfunction nextPowOfTwo(number) {\n  return Math.pow(2, Math.ceil(Math.log2(number)));\n}\n\nfunction resizeImage(ctx, imageData, maxWidth, maxHeight) {\n  const resizeRatio = Math.min(maxWidth / imageData.width, maxHeight / imageData.height);\n  const width = Math.floor(imageData.width * resizeRatio);\n  const height = Math.floor(imageData.height * resizeRatio);\n\n  if (resizeRatio === 1) {\n    return {\n      data: imageData,\n      width,\n      height\n    };\n  }\n\n  ctx.canvas.height = height;\n  ctx.canvas.width = width;\n  ctx.clearRect(0, 0, width, height);\n  ctx.drawImage(imageData, 0, 0, imageData.width, imageData.height, 0, 0, width, height);\n  return {\n    data: ctx.canvas,\n    width,\n    height\n  };\n}\n\nfunction getIconId(icon) {\n  return icon && (icon.id || icon.url);\n}\n\nfunction resizeTexture(texture, width, height, parameters) {\n  const oldWidth = texture.width;\n  const oldHeight = texture.height;\n  const newTexture = new texture_2d/* default */.Z(texture.gl, {\n    width,\n    height,\n    parameters\n  });\n  (0,copy_and_blit/* copyToTexture */.Lv)(texture, newTexture, {\n    targetY: 0,\n    width: oldWidth,\n    height: oldHeight\n  });\n  texture.delete();\n  return newTexture;\n}\n\nfunction buildRowMapping(mapping, columns, yOffset) {\n  for (let i = 0; i < columns.length; i++) {\n    const {\n      icon,\n      xOffset\n    } = columns[i];\n    const id = getIconId(icon);\n    mapping[id] = { ...icon,\n      x: xOffset,\n      y: yOffset\n    };\n  }\n}\n\nfunction buildMapping({\n  icons,\n  buffer,\n  mapping = {},\n  xOffset = 0,\n  yOffset = 0,\n  rowHeight = 0,\n  canvasWidth\n}) {\n  let columns = [];\n\n  for (let i = 0; i < icons.length; i++) {\n    const icon = icons[i];\n    const id = getIconId(icon);\n\n    if (!mapping[id]) {\n      const {\n        height,\n        width\n      } = icon;\n\n      if (xOffset + width + buffer > canvasWidth) {\n        buildRowMapping(mapping, columns, yOffset);\n        xOffset = 0;\n        yOffset = rowHeight + yOffset + buffer;\n        rowHeight = 0;\n        columns = [];\n      }\n\n      columns.push({\n        icon,\n        xOffset\n      });\n      xOffset = xOffset + width + buffer;\n      rowHeight = Math.max(rowHeight, height);\n    }\n  }\n\n  if (columns.length > 0) {\n    buildRowMapping(mapping, columns, yOffset);\n  }\n\n  return {\n    mapping,\n    rowHeight,\n    xOffset,\n    yOffset,\n    canvasWidth,\n    canvasHeight: nextPowOfTwo(rowHeight + yOffset + buffer)\n  };\n}\nfunction getDiffIcons(data, getIcon, cachedIcons) {\n  if (!data || !getIcon) {\n    return null;\n  }\n\n  cachedIcons = cachedIcons || {};\n  const icons = {};\n  const {\n    iterable,\n    objectInfo\n  } = (0,iterable_utils/* createIterable */.jB)(data);\n\n  for (const object of iterable) {\n    objectInfo.index++;\n    const icon = getIcon(object, objectInfo);\n    const id = getIconId(icon);\n\n    if (!icon) {\n      throw new Error('Icon is missing.');\n    }\n\n    if (!icon.url) {\n      throw new Error('Icon url is missing.');\n    }\n\n    if (!icons[id] && (!cachedIcons[id] || icon.url !== cachedIcons[id].url)) {\n      icons[id] = { ...icon,\n        source: object,\n        sourceIndex: objectInfo.index\n      };\n    }\n  }\n\n  return icons;\n}\nclass IconManager {\n  constructor(gl, {\n    onUpdate = noop,\n    onError = noop\n  }) {\n    (0,defineProperty/* default */.Z)(this, \"gl\", void 0);\n\n    (0,defineProperty/* default */.Z)(this, \"onUpdate\", void 0);\n\n    (0,defineProperty/* default */.Z)(this, \"onError\", void 0);\n\n    (0,defineProperty/* default */.Z)(this, \"_loadOptions\", null);\n\n    (0,defineProperty/* default */.Z)(this, \"_texture\", null);\n\n    (0,defineProperty/* default */.Z)(this, \"_externalTexture\", null);\n\n    (0,defineProperty/* default */.Z)(this, \"_mapping\", {});\n\n    (0,defineProperty/* default */.Z)(this, \"_textureParameters\", null);\n\n    (0,defineProperty/* default */.Z)(this, \"_pendingCount\", 0);\n\n    (0,defineProperty/* default */.Z)(this, \"_autoPacking\", false);\n\n    (0,defineProperty/* default */.Z)(this, \"_xOffset\", 0);\n\n    (0,defineProperty/* default */.Z)(this, \"_yOffset\", 0);\n\n    (0,defineProperty/* default */.Z)(this, \"_rowHeight\", 0);\n\n    (0,defineProperty/* default */.Z)(this, \"_buffer\", DEFAULT_BUFFER);\n\n    (0,defineProperty/* default */.Z)(this, \"_canvasWidth\", DEFAULT_CANVAS_WIDTH);\n\n    (0,defineProperty/* default */.Z)(this, \"_canvasHeight\", 0);\n\n    (0,defineProperty/* default */.Z)(this, \"_canvas\", null);\n\n    this.gl = gl;\n    this.onUpdate = onUpdate;\n    this.onError = onError;\n  }\n\n  finalize() {\n    var _this$_texture;\n\n    (_this$_texture = this._texture) === null || _this$_texture === void 0 ? void 0 : _this$_texture.delete();\n  }\n\n  getTexture() {\n    return this._texture || this._externalTexture;\n  }\n\n  getIconMapping(icon) {\n    const id = this._autoPacking ? getIconId(icon) : icon;\n    return this._mapping[id] || {};\n  }\n\n  setProps({\n    loadOptions,\n    autoPacking,\n    iconAtlas,\n    iconMapping,\n    textureParameters\n  }) {\n    if (loadOptions) {\n      this._loadOptions = loadOptions;\n    }\n\n    if (autoPacking !== undefined) {\n      this._autoPacking = autoPacking;\n    }\n\n    if (iconMapping) {\n      this._mapping = iconMapping;\n    }\n\n    if (iconAtlas) {\n      var _this$_texture2;\n\n      (_this$_texture2 = this._texture) === null || _this$_texture2 === void 0 ? void 0 : _this$_texture2.delete();\n      this._texture = null;\n      this._externalTexture = iconAtlas;\n    }\n\n    if (textureParameters) {\n      this._textureParameters = textureParameters;\n    }\n  }\n\n  get isLoaded() {\n    return this._pendingCount === 0;\n  }\n\n  packIcons(data, getIcon) {\n    if (!this._autoPacking || typeof document === 'undefined') {\n      return;\n    }\n\n    const icons = Object.values(getDiffIcons(data, getIcon, this._mapping) || {});\n\n    if (icons.length > 0) {\n      const {\n        mapping,\n        xOffset,\n        yOffset,\n        rowHeight,\n        canvasHeight\n      } = buildMapping({\n        icons,\n        buffer: this._buffer,\n        canvasWidth: this._canvasWidth,\n        mapping: this._mapping,\n        rowHeight: this._rowHeight,\n        xOffset: this._xOffset,\n        yOffset: this._yOffset\n      });\n      this._rowHeight = rowHeight;\n      this._mapping = mapping;\n      this._xOffset = xOffset;\n      this._yOffset = yOffset;\n      this._canvasHeight = canvasHeight;\n\n      if (!this._texture) {\n        this._texture = new texture_2d/* default */.Z(this.gl, {\n          width: this._canvasWidth,\n          height: this._canvasHeight,\n          parameters: this._textureParameters || DEFAULT_TEXTURE_PARAMETERS\n        });\n      }\n\n      if (this._texture.height !== this._canvasHeight) {\n        this._texture = resizeTexture(this._texture, this._canvasWidth, this._canvasHeight, this._textureParameters || DEFAULT_TEXTURE_PARAMETERS);\n      }\n\n      this.onUpdate();\n      this._canvas = this._canvas || document.createElement('canvas');\n\n      this._loadIcons(icons);\n    }\n  }\n\n  _loadIcons(icons) {\n    const ctx = this._canvas.getContext('2d', {\n      willReadFrequently: true\n    });\n\n    for (const icon of icons) {\n      this._pendingCount++;\n      (0,load/* load */.z)(icon.url, this._loadOptions).then(imageData => {\n        const id = getIconId(icon);\n        const iconDef = this._mapping[id];\n        const {\n          x,\n          y,\n          width: maxWidth,\n          height: maxHeight\n        } = iconDef;\n        const {\n          data,\n          width,\n          height\n        } = resizeImage(ctx, imageData, maxWidth, maxHeight);\n\n        this._texture.setSubImageData({\n          data,\n          x: x + (maxWidth - width) / 2,\n          y: y + (maxHeight - height) / 2,\n          width,\n          height\n        });\n\n        iconDef.width = width;\n        iconDef.height = height;\n\n        this._texture.generateMipmap();\n\n        this.onUpdate();\n      }).catch(error => {\n        this.onError({\n          url: icon.url,\n          source: icon.source,\n          sourceIndex: icon.sourceIndex,\n          loadOptions: this._loadOptions,\n          error\n        });\n      }).finally(() => {\n        this._pendingCount--;\n      });\n    }\n  }\n\n}\n//# sourceMappingURL=icon-manager.js.map\n;// CONCATENATED MODULE: ./node_modules/@deck.gl/layers/dist/esm/icon-layer/icon-layer.js\n\n\n\n\n\n\nconst DEFAULT_COLOR = [0, 0, 0, 255];\nconst defaultProps = {\n  iconAtlas: {\n    type: 'image',\n    value: null,\n    async: true\n  },\n  iconMapping: {\n    type: 'object',\n    value: {},\n    async: true\n  },\n  sizeScale: {\n    type: 'number',\n    value: 1,\n    min: 0\n  },\n  billboard: true,\n  sizeUnits: 'pixels',\n  sizeMinPixels: {\n    type: 'number',\n    min: 0,\n    value: 0\n  },\n  sizeMaxPixels: {\n    type: 'number',\n    min: 0,\n    value: Number.MAX_SAFE_INTEGER\n  },\n  alphaCutoff: {\n    type: 'number',\n    value: 0.05,\n    min: 0,\n    max: 1\n  },\n  getPosition: {\n    type: 'accessor',\n    value: x => x.position\n  },\n  getIcon: {\n    type: 'accessor',\n    value: x => x.icon\n  },\n  getColor: {\n    type: 'accessor',\n    value: DEFAULT_COLOR\n  },\n  getSize: {\n    type: 'accessor',\n    value: 1\n  },\n  getAngle: {\n    type: 'accessor',\n    value: 0\n  },\n  getPixelOffset: {\n    type: 'accessor',\n    value: [0, 0]\n  },\n  onIconError: {\n    type: 'function',\n    value: null,\n    optional: true\n  },\n  textureParameters: {\n    type: 'object',\n    ignore: true\n  }\n};\nclass IconLayer extends lib_layer/* default */.Z {\n  constructor(...args) {\n    super(...args);\n\n    (0,defineProperty/* default */.Z)(this, \"state\", void 0);\n  }\n\n  getShaders() {\n    return super.getShaders({\n      vs: icon_layer_vertex_glsl,\n      fs: icon_layer_fragment_glsl,\n      modules: [project32/* default */.Z, picking/* default */.Z]\n    });\n  }\n\n  initializeState() {\n    this.state = {\n      iconManager: new IconManager(this.context.gl, {\n        onUpdate: this._onUpdate.bind(this),\n        onError: this._onError.bind(this)\n      })\n    };\n    const attributeManager = this.getAttributeManager();\n    attributeManager.addInstanced({\n      instancePositions: {\n        size: 3,\n        type: 5130,\n        fp64: this.use64bitPositions(),\n        transition: true,\n        accessor: 'getPosition'\n      },\n      instanceSizes: {\n        size: 1,\n        transition: true,\n        accessor: 'getSize',\n        defaultValue: 1\n      },\n      instanceOffsets: {\n        size: 2,\n        accessor: 'getIcon',\n        transform: this.getInstanceOffset\n      },\n      instanceIconFrames: {\n        size: 4,\n        accessor: 'getIcon',\n        transform: this.getInstanceIconFrame\n      },\n      instanceColorModes: {\n        size: 1,\n        type: 5121,\n        accessor: 'getIcon',\n        transform: this.getInstanceColorMode\n      },\n      instanceColors: {\n        size: this.props.colorFormat.length,\n        type: 5121,\n        normalized: true,\n        transition: true,\n        accessor: 'getColor',\n        defaultValue: DEFAULT_COLOR\n      },\n      instanceAngles: {\n        size: 1,\n        transition: true,\n        accessor: 'getAngle'\n      },\n      instancePixelOffset: {\n        size: 2,\n        transition: true,\n        accessor: 'getPixelOffset'\n      }\n    });\n  }\n\n  updateState(params) {\n    super.updateState(params);\n    const {\n      props,\n      oldProps,\n      changeFlags\n    } = params;\n    const attributeManager = this.getAttributeManager();\n    const {\n      iconAtlas,\n      iconMapping,\n      data,\n      getIcon,\n      textureParameters\n    } = props;\n    const {\n      iconManager\n    } = this.state;\n    const prePacked = iconAtlas || this.internalState.isAsyncPropLoading('iconAtlas');\n    iconManager.setProps({\n      loadOptions: props.loadOptions,\n      autoPacking: !prePacked,\n      iconAtlas,\n      iconMapping: prePacked ? iconMapping : null,\n      textureParameters\n    });\n\n    if (prePacked) {\n      if (oldProps.iconMapping !== props.iconMapping) {\n        attributeManager.invalidate('getIcon');\n      }\n    } else if (changeFlags.dataChanged || changeFlags.updateTriggersChanged && (changeFlags.updateTriggersChanged.all || changeFlags.updateTriggersChanged.getIcon)) {\n      iconManager.packIcons(data, getIcon);\n    }\n\n    if (changeFlags.extensionsChanged) {\n      var _this$state$model;\n\n      const {\n        gl\n      } = this.context;\n      (_this$state$model = this.state.model) === null || _this$state$model === void 0 ? void 0 : _this$state$model.delete();\n      this.state.model = this._getModel(gl);\n      attributeManager.invalidateAll();\n    }\n  }\n\n  get isLoaded() {\n    return super.isLoaded && this.state.iconManager.isLoaded;\n  }\n\n  finalizeState(context) {\n    super.finalizeState(context);\n    this.state.iconManager.finalize();\n  }\n\n  draw({\n    uniforms\n  }) {\n    const {\n      sizeScale,\n      sizeMinPixels,\n      sizeMaxPixels,\n      sizeUnits,\n      billboard,\n      alphaCutoff\n    } = this.props;\n    const {\n      iconManager\n    } = this.state;\n    const iconsTexture = iconManager.getTexture();\n\n    if (iconsTexture) {\n      this.state.model.setUniforms(uniforms).setUniforms({\n        iconsTexture,\n        iconsTextureDim: [iconsTexture.width, iconsTexture.height],\n        sizeUnits: constants/* UNIT */.iI[sizeUnits],\n        sizeScale,\n        sizeMinPixels,\n        sizeMaxPixels,\n        billboard,\n        alphaCutoff\n      }).draw();\n    }\n  }\n\n  _getModel(gl) {\n    const positions = [-1, -1, -1, 1, 1, 1, 1, -1];\n    return new model/* default */.Z(gl, { ...this.getShaders(),\n      id: this.props.id,\n      geometry: new geometry/* default */.Z({\n        drawMode: 6,\n        attributes: {\n          positions: {\n            size: 2,\n            value: new Float32Array(positions)\n          }\n        }\n      }),\n      isInstanced: true\n    });\n  }\n\n  _onUpdate() {\n    this.setNeedsRedraw();\n  }\n\n  _onError(evt) {\n    var _this$getCurrentLayer;\n\n    const onIconError = (_this$getCurrentLayer = this.getCurrentLayer()) === null || _this$getCurrentLayer === void 0 ? void 0 : _this$getCurrentLayer.props.onIconError;\n\n    if (onIconError) {\n      onIconError(evt);\n    } else {\n      log/* default.error */.Z.error(evt.error.message)();\n    }\n  }\n\n  getInstanceOffset(icon) {\n    const {\n      width,\n      height,\n      anchorX = width / 2,\n      anchorY = height / 2\n    } = this.state.iconManager.getIconMapping(icon);\n    return [width / 2 - anchorX, height / 2 - anchorY];\n  }\n\n  getInstanceColorMode(icon) {\n    const mapping = this.state.iconManager.getIconMapping(icon);\n    return mapping.mask ? 1 : 0;\n  }\n\n  getInstanceIconFrame(icon) {\n    const {\n      x,\n      y,\n      width,\n      height\n    } = this.state.iconManager.getIconMapping(icon);\n    return [x, y, width, height];\n  }\n\n}\n\n(0,defineProperty/* default */.Z)(IconLayer, \"defaultProps\", defaultProps);\n\n(0,defineProperty/* default */.Z)(IconLayer, \"layerName\", 'IconLayer');\n//# sourceMappingURL=icon-layer.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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O0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLE1BQU07QUFDTjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixzQkFBSTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGVBQWUsb0JBQUssT0FBTztBQUMzQjtBQUNBLG9CQUFvQix1QkFBUTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOLE1BQU0sOEJBQVM7QUFDZjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBOztBQUVBLGlDQUFlOztBQUVmLGlDQUFlO0FBQ2YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly92dWUzLXdlYnBhY2s1Ly4vbm9kZV9tb2R1bGVzL0BkZWNrLmdsL2xheWVycy9kaXN0L2VzbS9pY29uLWxheWVyL2ljb24tbGF5ZXItdmVydGV4Lmdsc2wuanM/NTk3MCIsIndlYnBhY2s6Ly92dWUzLXdlYnBhY2s1Ly4vbm9kZV9tb2R1bGVzL0BkZWNrLmdsL2xheWVycy9kaXN0L2VzbS9pY29uLWxheWVyL2ljb24tbGF5ZXItZnJhZ21lbnQuZ2xzbC5qcz84YWMyIiwid2VicGFjazovL3Z1ZTMtd2VicGFjazUvLi9ub2RlX21vZHVsZXMvQGRlY2suZ2wvbGF5ZXJzL2Rpc3QvZXNtL2ljb24tbGF5ZXIvaWNvbi1tYW5hZ2VyLmpzPzM4NjQiLCJ3ZWJwYWNrOi8vdnVlMy13ZWJwYWNrNS8uL25vZGVfbW9kdWxlcy9AZGVjay5nbC9sYXllcnMvZGlzdC9lc20vaWNvbi1sYXllci9pY29uLWxheWVyLmpzPzUzOWUiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IGRlZmF1bHQgXCIjZGVmaW5lIFNIQURFUl9OQU1FIGljb24tbGF5ZXItdmVydGV4LXNoYWRlclxcblxcbmF0dHJpYnV0ZSB2ZWMyIHBvc2l0aW9ucztcXG5cXG5hdHRyaWJ1dGUgdmVjMyBpbnN0YW5jZVBvc2l0aW9ucztcXG5hdHRyaWJ1dGUgdmVjMyBpbnN0YW5jZVBvc2l0aW9uczY0TG93O1xcbmF0dHJpYnV0ZSBmbG9hdCBpbnN0YW5jZVNpemVzO1xcbmF0dHJpYnV0ZSBmbG9hdCBpbnN0YW5jZUFuZ2xlcztcXG5hdHRyaWJ1dGUgdmVjNCBpbnN0YW5jZUNvbG9ycztcXG5hdHRyaWJ1dGUgdmVjMyBpbnN0YW5jZVBpY2tpbmdDb2xvcnM7XFxuYXR0cmlidXRlIHZlYzQgaW5zdGFuY2VJY29uRnJhbWVzO1xcbmF0dHJpYnV0ZSBmbG9hdCBpbnN0YW5jZUNvbG9yTW9kZXM7XFxuYXR0cmlidXRlIHZlYzIgaW5zdGFuY2VPZmZzZXRzO1xcbmF0dHJpYnV0ZSB2ZWMyIGluc3RhbmNlUGl4ZWxPZmZzZXQ7XFxuXFxudW5pZm9ybSBmbG9hdCBzaXplU2NhbGU7XFxudW5pZm9ybSB2ZWMyIGljb25zVGV4dHVyZURpbTtcXG51bmlmb3JtIGZsb2F0IHNpemVNaW5QaXhlbHM7XFxudW5pZm9ybSBmbG9hdCBzaXplTWF4UGl4ZWxzO1xcbnVuaWZvcm0gYm9vbCBiaWxsYm9hcmQ7XFxudW5pZm9ybSBpbnQgc2l6ZVVuaXRzO1xcblxcbnZhcnlpbmcgZmxvYXQgdkNvbG9yTW9kZTtcXG52YXJ5aW5nIHZlYzQgdkNvbG9yO1xcbnZhcnlpbmcgdmVjMiB2VGV4dHVyZUNvb3JkcztcXG52YXJ5aW5nIHZlYzIgdXY7XFxuXFxudmVjMiByb3RhdGVfYnlfYW5nbGUodmVjMiB2ZXJ0ZXgsIGZsb2F0IGFuZ2xlKSB7XFxuICBmbG9hdCBhbmdsZV9yYWRpYW4gPSBhbmdsZSAqIFBJIC8gMTgwLjA7XFxuICBmbG9hdCBjb3NfYW5nbGUgPSBjb3MoYW5nbGVfcmFkaWFuKTtcXG4gIGZsb2F0IHNpbl9hbmdsZSA9IHNpbihhbmdsZV9yYWRpYW4pO1xcbiAgbWF0MiByb3RhdGlvbk1hdHJpeCA9IG1hdDIoY29zX2FuZ2xlLCAtc2luX2FuZ2xlLCBzaW5fYW5nbGUsIGNvc19hbmdsZSk7XFxuICByZXR1cm4gcm90YXRpb25NYXRyaXggKiB2ZXJ0ZXg7XFxufVxcblxcbnZvaWQgbWFpbih2b2lkKSB7XFxuICBnZW9tZXRyeS53b3JsZFBvc2l0aW9uID0gaW5zdGFuY2VQb3NpdGlvbnM7XFxuICBnZW9tZXRyeS51diA9IHBvc2l0aW9ucztcXG4gIGdlb21ldHJ5LnBpY2tpbmdDb2xvciA9IGluc3RhbmNlUGlja2luZ0NvbG9ycztcXG4gIHV2ID0gcG9zaXRpb25zO1xcblxcbiAgdmVjMiBpY29uU2l6ZSA9IGluc3RhbmNlSWNvbkZyYW1lcy56dztcXG4gIGZsb2F0IHNpemVQaXhlbHMgPSBjbGFtcChcXG4gICAgcHJvamVjdF9zaXplX3RvX3BpeGVsKGluc3RhbmNlU2l6ZXMgKiBzaXplU2NhbGUsIHNpemVVbml0cyksIFxcbiAgICBzaXplTWluUGl4ZWxzLCBzaXplTWF4UGl4ZWxzXFxuICApO1xcbiAgZmxvYXQgaW5zdGFuY2VTY2FsZSA9IGljb25TaXplLnkgPT0gMC4wID8gMC4wIDogc2l6ZVBpeGVscyAvIGljb25TaXplLnk7XFxuICB2ZWMyIHBpeGVsT2Zmc2V0ID0gcG9zaXRpb25zIC8gMi4wICogaWNvblNpemUgKyBpbnN0YW5jZU9mZnNldHM7XFxuICBwaXhlbE9mZnNldCA9IHJvdGF0ZV9ieV9hbmdsZShwaXhlbE9mZnNldCwgaW5zdGFuY2VBbmdsZXMpICogaW5zdGFuY2VTY2FsZTtcXG4gIHBpeGVsT2Zmc2V0ICs9IGluc3RhbmNlUGl4ZWxPZmZzZXQ7XFxuICBwaXhlbE9mZnNldC55ICo9IC0xLjA7XFxuXFxuICBpZiAoYmlsbGJvYXJkKSAge1xcbiAgICBnbF9Qb3NpdGlvbiA9IHByb2plY3RfcG9zaXRpb25fdG9fY2xpcHNwYWNlKGluc3RhbmNlUG9zaXRpb25zLCBpbnN0YW5jZVBvc2l0aW9uczY0TG93LCB2ZWMzKDAuMCksIGdlb21ldHJ5LnBvc2l0aW9uKTtcXG4gICAgREVDS0dMX0ZJTFRFUl9HTF9QT1NJVElPTihnbF9Qb3NpdGlvbiwgZ2VvbWV0cnkpO1xcbiAgICB2ZWMzIG9mZnNldCA9IHZlYzMocGl4ZWxPZmZzZXQsIDAuMCk7XFxuICAgIERFQ0tHTF9GSUxURVJfU0laRShvZmZzZXQsIGdlb21ldHJ5KTtcXG4gICAgZ2xfUG9zaXRpb24ueHkgKz0gcHJvamVjdF9waXhlbF9zaXplX3RvX2NsaXBzcGFjZShvZmZzZXQueHkpO1xcblxcbiAgfSBlbHNlIHtcXG4gICAgdmVjMyBvZmZzZXRfY29tbW9uID0gdmVjMyhwcm9qZWN0X3BpeGVsX3NpemUocGl4ZWxPZmZzZXQpLCAwLjApO1xcbiAgICBERUNLR0xfRklMVEVSX1NJWkUob2Zmc2V0X2NvbW1vbiwgZ2VvbWV0cnkpO1xcbiAgICBnbF9Qb3NpdGlvbiA9IHByb2plY3RfcG9zaXRpb25fdG9fY2xpcHNwYWNlKGluc3RhbmNlUG9zaXRpb25zLCBpbnN0YW5jZVBvc2l0aW9uczY0TG93LCBvZmZzZXRfY29tbW9uLCBnZW9tZXRyeS5wb3NpdGlvbik7IFxcbiAgICBERUNLR0xfRklMVEVSX0dMX1BPU0lUSU9OKGdsX1Bvc2l0aW9uLCBnZW9tZXRyeSk7XFxuICB9XFxuXFxuICB2VGV4dHVyZUNvb3JkcyA9IG1peChcXG4gICAgaW5zdGFuY2VJY29uRnJhbWVzLnh5LFxcbiAgICBpbnN0YW5jZUljb25GcmFtZXMueHkgKyBpY29uU2l6ZSxcXG4gICAgKHBvc2l0aW9ucy54eSArIDEuMCkgLyAyLjBcXG4gICkgLyBpY29uc1RleHR1cmVEaW07XFxuXFxuICB2Q29sb3IgPSBpbnN0YW5jZUNvbG9ycztcXG4gIERFQ0tHTF9GSUxURVJfQ09MT1IodkNvbG9yLCBnZW9tZXRyeSk7XFxuXFxuICB2Q29sb3JNb2RlID0gaW5zdGFuY2VDb2xvck1vZGVzO1xcbn1cXG5cIjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWljb24tbGF5ZXItdmVydGV4Lmdsc2wuanMubWFwIiwiZXhwb3J0IGRlZmF1bHQgXCIjZGVmaW5lIFNIQURFUl9OQU1FIGljb24tbGF5ZXItZnJhZ21lbnQtc2hhZGVyXFxuXFxucHJlY2lzaW9uIGhpZ2hwIGZsb2F0O1xcblxcbnVuaWZvcm0gZmxvYXQgb3BhY2l0eTtcXG51bmlmb3JtIHNhbXBsZXIyRCBpY29uc1RleHR1cmU7XFxudW5pZm9ybSBmbG9hdCBhbHBoYUN1dG9mZjtcXG5cXG52YXJ5aW5nIGZsb2F0IHZDb2xvck1vZGU7XFxudmFyeWluZyB2ZWM0IHZDb2xvcjtcXG52YXJ5aW5nIHZlYzIgdlRleHR1cmVDb29yZHM7XFxudmFyeWluZyB2ZWMyIHV2O1xcblxcbnZvaWQgbWFpbih2b2lkKSB7XFxuICBnZW9tZXRyeS51diA9IHV2O1xcblxcbiAgdmVjNCB0ZXhDb2xvciA9IHRleHR1cmUyRChpY29uc1RleHR1cmUsIHZUZXh0dXJlQ29vcmRzKTtcXG4gIHZlYzMgY29sb3IgPSBtaXgodGV4Q29sb3IucmdiLCB2Q29sb3IucmdiLCB2Q29sb3JNb2RlKTtcXG4gIGZsb2F0IGEgPSB0ZXhDb2xvci5hICogb3BhY2l0eSAqIHZDb2xvci5hO1xcblxcbiAgaWYgKGEgPCBhbHBoYUN1dG9mZikge1xcbiAgICBkaXNjYXJkO1xcbiAgfVxcblxcbiAgZ2xfRnJhZ0NvbG9yID0gdmVjNChjb2xvciwgYSk7XFxuICBERUNLR0xfRklMVEVSX0NPTE9SKGdsX0ZyYWdDb2xvciwgZ2VvbWV0cnkpO1xcbn1cXG5cIjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWljb24tbGF5ZXItZnJhZ21lbnQuZ2xzbC5qcy5tYXAiLCJpbXBvcnQgX2RlZmluZVByb3BlcnR5IGZyb20gXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9kZWZpbmVQcm9wZXJ0eVwiO1xuaW1wb3J0IHsgVGV4dHVyZTJELCBjb3B5VG9UZXh0dXJlIH0gZnJvbSAnQGx1bWEuZ2wvY29yZSc7XG5pbXBvcnQgeyBsb2FkIH0gZnJvbSAnQGxvYWRlcnMuZ2wvY29yZSc7XG5pbXBvcnQgeyBjcmVhdGVJdGVyYWJsZSB9IGZyb20gJ0BkZWNrLmdsL2NvcmUnO1xuY29uc3QgREVGQVVMVF9DQU5WQVNfV0lEVEggPSAxMDI0O1xuY29uc3QgREVGQVVMVF9CVUZGRVIgPSA0O1xuXG5jb25zdCBub29wID0gKCkgPT4ge307XG5cbmNvbnN0IERFRkFVTFRfVEVYVFVSRV9QQVJBTUVURVJTID0ge1xuICBbMTAyNDFdOiA5OTg3LFxuICBbMTAyNDBdOiA5NzI5LFxuICBbMTAyNDJdOiAzMzA3MSxcbiAgWzEwMjQzXTogMzMwNzFcbn07XG5cbmZ1bmN0aW9uIG5leHRQb3dPZlR3byhudW1iZXIpIHtcbiAgcmV0dXJuIE1hdGgucG93KDIsIE1hdGguY2VpbChNYXRoLmxvZzIobnVtYmVyKSkpO1xufVxuXG5mdW5jdGlvbiByZXNpemVJbWFnZShjdHgsIGltYWdlRGF0YSwgbWF4V2lkdGgsIG1heEhlaWdodCkge1xuICBjb25zdCByZXNpemVSYXRpbyA9IE1hdGgubWluKG1heFdpZHRoIC8gaW1hZ2VEYXRhLndpZHRoLCBtYXhIZWlnaHQgLyBpbWFnZURhdGEuaGVpZ2h0KTtcbiAgY29uc3Qgd2lkdGggPSBNYXRoLmZsb29yKGltYWdlRGF0YS53aWR0aCAqIHJlc2l6ZVJhdGlvKTtcbiAgY29uc3QgaGVpZ2h0ID0gTWF0aC5mbG9vcihpbWFnZURhdGEuaGVpZ2h0ICogcmVzaXplUmF0aW8pO1xuXG4gIGlmIChyZXNpemVSYXRpbyA9PT0gMSkge1xuICAgIHJldHVybiB7XG4gICAgICBkYXRhOiBpbWFnZURhdGEsXG4gICAgICB3aWR0aCxcbiAgICAgIGhlaWdodFxuICAgIH07XG4gIH1cblxuICBjdHguY2FudmFzLmhlaWdodCA9IGhlaWdodDtcbiAgY3R4LmNhbnZhcy53aWR0aCA9IHdpZHRoO1xuICBjdHguY2xlYXJSZWN0KDAsIDAsIHdpZHRoLCBoZWlnaHQpO1xuICBjdHguZHJhd0ltYWdlKGltYWdlRGF0YSwgMCwgMCwgaW1hZ2VEYXRhLndpZHRoLCBpbWFnZURhdGEuaGVpZ2h0LCAwLCAwLCB3aWR0aCwgaGVpZ2h0KTtcbiAgcmV0dXJuIHtcbiAgICBkYXRhOiBjdHguY2FudmFzLFxuICAgIHdpZHRoLFxuICAgIGhlaWdodFxuICB9O1xufVxuXG5mdW5jdGlvbiBnZXRJY29uSWQoaWNvbikge1xuICByZXR1cm4gaWNvbiAmJiAoaWNvbi5pZCB8fCBpY29uLnVybCk7XG59XG5cbmZ1bmN0aW9uIHJlc2l6ZVRleHR1cmUodGV4dHVyZSwgd2lkdGgsIGhlaWdodCwgcGFyYW1ldGVycykge1xuICBjb25zdCBvbGRXaWR0aCA9IHRleHR1cmUud2lkdGg7XG4gIGNvbnN0IG9sZEhlaWdodCA9IHRleHR1cmUuaGVpZ2h0O1xuICBjb25zdCBuZXdUZXh0dXJlID0gbmV3IFRleHR1cmUyRCh0ZXh0dXJlLmdsLCB7XG4gICAgd2lkdGgsXG4gICAgaGVpZ2h0LFxuICAgIHBhcmFtZXRlcnNcbiAgfSk7XG4gIGNvcHlUb1RleHR1cmUodGV4dHVyZSwgbmV3VGV4dHVyZSwge1xuICAgIHRhcmdldFk6IDAsXG4gICAgd2lkdGg6IG9sZFdpZHRoLFxuICAgIGhlaWdodDogb2xkSGVpZ2h0XG4gIH0pO1xuICB0ZXh0dXJlLmRlbGV0ZSgpO1xuICByZXR1cm4gbmV3VGV4dHVyZTtcbn1cblxuZnVuY3Rpb24gYnVpbGRSb3dNYXBwaW5nKG1hcHBpbmcsIGNvbHVtbnMsIHlPZmZzZXQpIHtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBjb2x1bW5zLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3Qge1xuICAgICAgaWNvbixcbiAgICAgIHhPZmZzZXRcbiAgICB9ID0gY29sdW1uc1tpXTtcbiAgICBjb25zdCBpZCA9IGdldEljb25JZChpY29uKTtcbiAgICBtYXBwaW5nW2lkXSA9IHsgLi4uaWNvbixcbiAgICAgIHg6IHhPZmZzZXQsXG4gICAgICB5OiB5T2Zmc2V0XG4gICAgfTtcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gYnVpbGRNYXBwaW5nKHtcbiAgaWNvbnMsXG4gIGJ1ZmZlcixcbiAgbWFwcGluZyA9IHt9LFxuICB4T2Zmc2V0ID0gMCxcbiAgeU9mZnNldCA9IDAsXG4gIHJvd0hlaWdodCA9IDAsXG4gIGNhbnZhc1dpZHRoXG59KSB7XG4gIGxldCBjb2x1bW5zID0gW107XG5cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBpY29ucy5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IGljb24gPSBpY29uc1tpXTtcbiAgICBjb25zdCBpZCA9IGdldEljb25JZChpY29uKTtcblxuICAgIGlmICghbWFwcGluZ1tpZF0pIHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgaGVpZ2h0LFxuICAgICAgICB3aWR0aFxuICAgICAgfSA9IGljb247XG5cbiAgICAgIGlmICh4T2Zmc2V0ICsgd2lkdGggKyBidWZmZXIgPiBjYW52YXNXaWR0aCkge1xuICAgICAgICBidWlsZFJvd01hcHBpbmcobWFwcGluZywgY29sdW1ucywgeU9mZnNldCk7XG4gICAgICAgIHhPZmZzZXQgPSAwO1xuICAgICAgICB5T2Zmc2V0ID0gcm93SGVpZ2h0ICsgeU9mZnNldCArIGJ1ZmZlcjtcbiAgICAgICAgcm93SGVpZ2h0ID0gMDtcbiAgICAgICAgY29sdW1ucyA9IFtdO1xuICAgICAgfVxuXG4gICAgICBjb2x1bW5zLnB1c2goe1xuICAgICAgICBpY29uLFxuICAgICAgICB4T2Zmc2V0XG4gICAgICB9KTtcbiAgICAgIHhPZmZzZXQgPSB4T2Zmc2V0ICsgd2lkdGggKyBidWZmZXI7XG4gICAgICByb3dIZWlnaHQgPSBNYXRoLm1heChyb3dIZWlnaHQsIGhlaWdodCk7XG4gICAgfVxuICB9XG5cbiAgaWYgKGNvbHVtbnMubGVuZ3RoID4gMCkge1xuICAgIGJ1aWxkUm93TWFwcGluZyhtYXBwaW5nLCBjb2x1bW5zLCB5T2Zmc2V0KTtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgbWFwcGluZyxcbiAgICByb3dIZWlnaHQsXG4gICAgeE9mZnNldCxcbiAgICB5T2Zmc2V0LFxuICAgIGNhbnZhc1dpZHRoLFxuICAgIGNhbnZhc0hlaWdodDogbmV4dFBvd09mVHdvKHJvd0hlaWdodCArIHlPZmZzZXQgKyBidWZmZXIpXG4gIH07XG59XG5leHBvcnQgZnVuY3Rpb24gZ2V0RGlmZkljb25zKGRhdGEsIGdldEljb24sIGNhY2hlZEljb25zKSB7XG4gIGlmICghZGF0YSB8fCAhZ2V0SWNvbikge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgY2FjaGVkSWNvbnMgPSBjYWNoZWRJY29ucyB8fCB7fTtcbiAgY29uc3QgaWNvbnMgPSB7fTtcbiAgY29uc3Qge1xuICAgIGl0ZXJhYmxlLFxuICAgIG9iamVjdEluZm9cbiAgfSA9IGNyZWF0ZUl0ZXJhYmxlKGRhdGEpO1xuXG4gIGZvciAoY29uc3Qgb2JqZWN0IG9mIGl0ZXJhYmxlKSB7XG4gICAgb2JqZWN0SW5mby5pbmRleCsrO1xuICAgIGNvbnN0IGljb24gPSBnZXRJY29uKG9iamVjdCwgb2JqZWN0SW5mbyk7XG4gICAgY29uc3QgaWQgPSBnZXRJY29uSWQoaWNvbik7XG5cbiAgICBpZiAoIWljb24pIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSWNvbiBpcyBtaXNzaW5nLicpO1xuICAgIH1cblxuICAgIGlmICghaWNvbi51cmwpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSWNvbiB1cmwgaXMgbWlzc2luZy4nKTtcbiAgICB9XG5cbiAgICBpZiAoIWljb25zW2lkXSAmJiAoIWNhY2hlZEljb25zW2lkXSB8fCBpY29uLnVybCAhPT0gY2FjaGVkSWNvbnNbaWRdLnVybCkpIHtcbiAgICAgIGljb25zW2lkXSA9IHsgLi4uaWNvbixcbiAgICAgICAgc291cmNlOiBvYmplY3QsXG4gICAgICAgIHNvdXJjZUluZGV4OiBvYmplY3RJbmZvLmluZGV4XG4gICAgICB9O1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBpY29ucztcbn1cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEljb25NYW5hZ2VyIHtcbiAgY29uc3RydWN0b3IoZ2wsIHtcbiAgICBvblVwZGF0ZSA9IG5vb3AsXG4gICAgb25FcnJvciA9IG5vb3BcbiAgfSkge1xuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImdsXCIsIHZvaWQgMCk7XG5cbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJvblVwZGF0ZVwiLCB2b2lkIDApO1xuXG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwib25FcnJvclwiLCB2b2lkIDApO1xuXG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwiX2xvYWRPcHRpb25zXCIsIG51bGwpO1xuXG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwiX3RleHR1cmVcIiwgbnVsbCk7XG5cbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJfZXh0ZXJuYWxUZXh0dXJlXCIsIG51bGwpO1xuXG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwiX21hcHBpbmdcIiwge30pO1xuXG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwiX3RleHR1cmVQYXJhbWV0ZXJzXCIsIG51bGwpO1xuXG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwiX3BlbmRpbmdDb3VudFwiLCAwKTtcblxuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIl9hdXRvUGFja2luZ1wiLCBmYWxzZSk7XG5cbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJfeE9mZnNldFwiLCAwKTtcblxuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIl95T2Zmc2V0XCIsIDApO1xuXG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwiX3Jvd0hlaWdodFwiLCAwKTtcblxuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIl9idWZmZXJcIiwgREVGQVVMVF9CVUZGRVIpO1xuXG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwiX2NhbnZhc1dpZHRoXCIsIERFRkFVTFRfQ0FOVkFTX1dJRFRIKTtcblxuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIl9jYW52YXNIZWlnaHRcIiwgMCk7XG5cbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJfY2FudmFzXCIsIG51bGwpO1xuXG4gICAgdGhpcy5nbCA9IGdsO1xuICAgIHRoaXMub25VcGRhdGUgPSBvblVwZGF0ZTtcbiAgICB0aGlzLm9uRXJyb3IgPSBvbkVycm9yO1xuICB9XG5cbiAgZmluYWxpemUoKSB7XG4gICAgdmFyIF90aGlzJF90ZXh0dXJlO1xuXG4gICAgKF90aGlzJF90ZXh0dXJlID0gdGhpcy5fdGV4dHVyZSkgPT09IG51bGwgfHwgX3RoaXMkX3RleHR1cmUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF90aGlzJF90ZXh0dXJlLmRlbGV0ZSgpO1xuICB9XG5cbiAgZ2V0VGV4dHVyZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fdGV4dHVyZSB8fCB0aGlzLl9leHRlcm5hbFRleHR1cmU7XG4gIH1cblxuICBnZXRJY29uTWFwcGluZyhpY29uKSB7XG4gICAgY29uc3QgaWQgPSB0aGlzLl9hdXRvUGFja2luZyA/IGdldEljb25JZChpY29uKSA6IGljb247XG4gICAgcmV0dXJuIHRoaXMuX21hcHBpbmdbaWRdIHx8IHt9O1xuICB9XG5cbiAgc2V0UHJvcHMoe1xuICAgIGxvYWRPcHRpb25zLFxuICAgIGF1dG9QYWNraW5nLFxuICAgIGljb25BdGxhcyxcbiAgICBpY29uTWFwcGluZyxcbiAgICB0ZXh0dXJlUGFyYW1ldGVyc1xuICB9KSB7XG4gICAgaWYgKGxvYWRPcHRpb25zKSB7XG4gICAgICB0aGlzLl9sb2FkT3B0aW9ucyA9IGxvYWRPcHRpb25zO1xuICAgIH1cblxuICAgIGlmIChhdXRvUGFja2luZyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aGlzLl9hdXRvUGFja2luZyA9IGF1dG9QYWNraW5nO1xuICAgIH1cblxuICAgIGlmIChpY29uTWFwcGluZykge1xuICAgICAgdGhpcy5fbWFwcGluZyA9IGljb25NYXBwaW5nO1xuICAgIH1cblxuICAgIGlmIChpY29uQXRsYXMpIHtcbiAgICAgIHZhciBfdGhpcyRfdGV4dHVyZTI7XG5cbiAgICAgIChfdGhpcyRfdGV4dHVyZTIgPSB0aGlzLl90ZXh0dXJlKSA9PT0gbnVsbCB8fCBfdGhpcyRfdGV4dHVyZTIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF90aGlzJF90ZXh0dXJlMi5kZWxldGUoKTtcbiAgICAgIHRoaXMuX3RleHR1cmUgPSBudWxsO1xuICAgICAgdGhpcy5fZXh0ZXJuYWxUZXh0dXJlID0gaWNvbkF0bGFzO1xuICAgIH1cblxuICAgIGlmICh0ZXh0dXJlUGFyYW1ldGVycykge1xuICAgICAgdGhpcy5fdGV4dHVyZVBhcmFtZXRlcnMgPSB0ZXh0dXJlUGFyYW1ldGVycztcbiAgICB9XG4gIH1cblxuICBnZXQgaXNMb2FkZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3BlbmRpbmdDb3VudCA9PT0gMDtcbiAgfVxuXG4gIHBhY2tJY29ucyhkYXRhLCBnZXRJY29uKSB7XG4gICAgaWYgKCF0aGlzLl9hdXRvUGFja2luZyB8fCB0eXBlb2YgZG9jdW1lbnQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3QgaWNvbnMgPSBPYmplY3QudmFsdWVzKGdldERpZmZJY29ucyhkYXRhLCBnZXRJY29uLCB0aGlzLl9tYXBwaW5nKSB8fCB7fSk7XG5cbiAgICBpZiAoaWNvbnMubGVuZ3RoID4gMCkge1xuICAgICAgY29uc3Qge1xuICAgICAgICBtYXBwaW5nLFxuICAgICAgICB4T2Zmc2V0LFxuICAgICAgICB5T2Zmc2V0LFxuICAgICAgICByb3dIZWlnaHQsXG4gICAgICAgIGNhbnZhc0hlaWdodFxuICAgICAgfSA9IGJ1aWxkTWFwcGluZyh7XG4gICAgICAgIGljb25zLFxuICAgICAgICBidWZmZXI6IHRoaXMuX2J1ZmZlcixcbiAgICAgICAgY2FudmFzV2lkdGg6IHRoaXMuX2NhbnZhc1dpZHRoLFxuICAgICAgICBtYXBwaW5nOiB0aGlzLl9tYXBwaW5nLFxuICAgICAgICByb3dIZWlnaHQ6IHRoaXMuX3Jvd0hlaWdodCxcbiAgICAgICAgeE9mZnNldDogdGhpcy5feE9mZnNldCxcbiAgICAgICAgeU9mZnNldDogdGhpcy5feU9mZnNldFxuICAgICAgfSk7XG4gICAgICB0aGlzLl9yb3dIZWlnaHQgPSByb3dIZWlnaHQ7XG4gICAgICB0aGlzLl9tYXBwaW5nID0gbWFwcGluZztcbiAgICAgIHRoaXMuX3hPZmZzZXQgPSB4T2Zmc2V0O1xuICAgICAgdGhpcy5feU9mZnNldCA9IHlPZmZzZXQ7XG4gICAgICB0aGlzLl9jYW52YXNIZWlnaHQgPSBjYW52YXNIZWlnaHQ7XG5cbiAgICAgIGlmICghdGhpcy5fdGV4dHVyZSkge1xuICAgICAgICB0aGlzLl90ZXh0dXJlID0gbmV3IFRleHR1cmUyRCh0aGlzLmdsLCB7XG4gICAgICAgICAgd2lkdGg6IHRoaXMuX2NhbnZhc1dpZHRoLFxuICAgICAgICAgIGhlaWdodDogdGhpcy5fY2FudmFzSGVpZ2h0LFxuICAgICAgICAgIHBhcmFtZXRlcnM6IHRoaXMuX3RleHR1cmVQYXJhbWV0ZXJzIHx8IERFRkFVTFRfVEVYVFVSRV9QQVJBTUVURVJTXG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5fdGV4dHVyZS5oZWlnaHQgIT09IHRoaXMuX2NhbnZhc0hlaWdodCkge1xuICAgICAgICB0aGlzLl90ZXh0dXJlID0gcmVzaXplVGV4dHVyZSh0aGlzLl90ZXh0dXJlLCB0aGlzLl9jYW52YXNXaWR0aCwgdGhpcy5fY2FudmFzSGVpZ2h0LCB0aGlzLl90ZXh0dXJlUGFyYW1ldGVycyB8fCBERUZBVUxUX1RFWFRVUkVfUEFSQU1FVEVSUyk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMub25VcGRhdGUoKTtcbiAgICAgIHRoaXMuX2NhbnZhcyA9IHRoaXMuX2NhbnZhcyB8fCBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKTtcblxuICAgICAgdGhpcy5fbG9hZEljb25zKGljb25zKTtcbiAgICB9XG4gIH1cblxuICBfbG9hZEljb25zKGljb25zKSB7XG4gICAgY29uc3QgY3R4ID0gdGhpcy5fY2FudmFzLmdldENvbnRleHQoJzJkJywge1xuICAgICAgd2lsbFJlYWRGcmVxdWVudGx5OiB0cnVlXG4gICAgfSk7XG5cbiAgICBmb3IgKGNvbnN0IGljb24gb2YgaWNvbnMpIHtcbiAgICAgIHRoaXMuX3BlbmRpbmdDb3VudCsrO1xuICAgICAgbG9hZChpY29uLnVybCwgdGhpcy5fbG9hZE9wdGlvbnMpLnRoZW4oaW1hZ2VEYXRhID0+IHtcbiAgICAgICAgY29uc3QgaWQgPSBnZXRJY29uSWQoaWNvbik7XG4gICAgICAgIGNvbnN0IGljb25EZWYgPSB0aGlzLl9tYXBwaW5nW2lkXTtcbiAgICAgICAgY29uc3Qge1xuICAgICAgICAgIHgsXG4gICAgICAgICAgeSxcbiAgICAgICAgICB3aWR0aDogbWF4V2lkdGgsXG4gICAgICAgICAgaGVpZ2h0OiBtYXhIZWlnaHRcbiAgICAgICAgfSA9IGljb25EZWY7XG4gICAgICAgIGNvbnN0IHtcbiAgICAgICAgICBkYXRhLFxuICAgICAgICAgIHdpZHRoLFxuICAgICAgICAgIGhlaWdodFxuICAgICAgICB9ID0gcmVzaXplSW1hZ2UoY3R4LCBpbWFnZURhdGEsIG1heFdpZHRoLCBtYXhIZWlnaHQpO1xuXG4gICAgICAgIHRoaXMuX3RleHR1cmUuc2V0U3ViSW1hZ2VEYXRhKHtcbiAgICAgICAgICBkYXRhLFxuICAgICAgICAgIHg6IHggKyAobWF4V2lkdGggLSB3aWR0aCkgLyAyLFxuICAgICAgICAgIHk6IHkgKyAobWF4SGVpZ2h0IC0gaGVpZ2h0KSAvIDIsXG4gICAgICAgICAgd2lkdGgsXG4gICAgICAgICAgaGVpZ2h0XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGljb25EZWYud2lkdGggPSB3aWR0aDtcbiAgICAgICAgaWNvbkRlZi5oZWlnaHQgPSBoZWlnaHQ7XG5cbiAgICAgICAgdGhpcy5fdGV4dHVyZS5nZW5lcmF0ZU1pcG1hcCgpO1xuXG4gICAgICAgIHRoaXMub25VcGRhdGUoKTtcbiAgICAgIH0pLmNhdGNoKGVycm9yID0+IHtcbiAgICAgICAgdGhpcy5vbkVycm9yKHtcbiAgICAgICAgICB1cmw6IGljb24udXJsLFxuICAgICAgICAgIHNvdXJjZTogaWNvbi5zb3VyY2UsXG4gICAgICAgICAgc291cmNlSW5kZXg6IGljb24uc291cmNlSW5kZXgsXG4gICAgICAgICAgbG9hZE9wdGlvbnM6IHRoaXMuX2xvYWRPcHRpb25zLFxuICAgICAgICAgIGVycm9yXG4gICAgICAgIH0pO1xuICAgICAgfSkuZmluYWxseSgoKSA9PiB7XG4gICAgICAgIHRoaXMuX3BlbmRpbmdDb3VudC0tO1xuICAgICAgfSk7XG4gICAgfVxuICB9XG5cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWljb24tbWFuYWdlci5qcy5tYXAiLCJpbXBvcnQgX2RlZmluZVByb3BlcnR5IGZyb20gXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9kZWZpbmVQcm9wZXJ0eVwiO1xuaW1wb3J0IHsgTGF5ZXIsIHByb2plY3QzMiwgcGlja2luZywgbG9nLCBVTklUIH0gZnJvbSAnQGRlY2suZ2wvY29yZSc7XG5pbXBvcnQgeyBNb2RlbCwgR2VvbWV0cnkgfSBmcm9tICdAbHVtYS5nbC9jb3JlJztcbmltcG9ydCB2cyBmcm9tICcuL2ljb24tbGF5ZXItdmVydGV4Lmdsc2wnO1xuaW1wb3J0IGZzIGZyb20gJy4vaWNvbi1sYXllci1mcmFnbWVudC5nbHNsJztcbmltcG9ydCBJY29uTWFuYWdlciBmcm9tICcuL2ljb24tbWFuYWdlcic7XG5jb25zdCBERUZBVUxUX0NPTE9SID0gWzAsIDAsIDAsIDI1NV07XG5jb25zdCBkZWZhdWx0UHJvcHMgPSB7XG4gIGljb25BdGxhczoge1xuICAgIHR5cGU6ICdpbWFnZScsXG4gICAgdmFsdWU6IG51bGwsXG4gICAgYXN5bmM6IHRydWVcbiAgfSxcbiAgaWNvbk1hcHBpbmc6IHtcbiAgICB0eXBlOiAnb2JqZWN0JyxcbiAgICB2YWx1ZToge30sXG4gICAgYXN5bmM6IHRydWVcbiAgfSxcbiAgc2l6ZVNjYWxlOiB7XG4gICAgdHlwZTogJ251bWJlcicsXG4gICAgdmFsdWU6IDEsXG4gICAgbWluOiAwXG4gIH0sXG4gIGJpbGxib2FyZDogdHJ1ZSxcbiAgc2l6ZVVuaXRzOiAncGl4ZWxzJyxcbiAgc2l6ZU1pblBpeGVsczoge1xuICAgIHR5cGU6ICdudW1iZXInLFxuICAgIG1pbjogMCxcbiAgICB2YWx1ZTogMFxuICB9LFxuICBzaXplTWF4UGl4ZWxzOiB7XG4gICAgdHlwZTogJ251bWJlcicsXG4gICAgbWluOiAwLFxuICAgIHZhbHVlOiBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUlxuICB9LFxuICBhbHBoYUN1dG9mZjoge1xuICAgIHR5cGU6ICdudW1iZXInLFxuICAgIHZhbHVlOiAwLjA1LFxuICAgIG1pbjogMCxcbiAgICBtYXg6IDFcbiAgfSxcbiAgZ2V0UG9zaXRpb246IHtcbiAgICB0eXBlOiAnYWNjZXNzb3InLFxuICAgIHZhbHVlOiB4ID0+IHgucG9zaXRpb25cbiAgfSxcbiAgZ2V0SWNvbjoge1xuICAgIHR5cGU6ICdhY2Nlc3NvcicsXG4gICAgdmFsdWU6IHggPT4geC5pY29uXG4gIH0sXG4gIGdldENvbG9yOiB7XG4gICAgdHlwZTogJ2FjY2Vzc29yJyxcbiAgICB2YWx1ZTogREVGQVVMVF9DT0xPUlxuICB9LFxuICBnZXRTaXplOiB7XG4gICAgdHlwZTogJ2FjY2Vzc29yJyxcbiAgICB2YWx1ZTogMVxuICB9LFxuICBnZXRBbmdsZToge1xuICAgIHR5cGU6ICdhY2Nlc3NvcicsXG4gICAgdmFsdWU6IDBcbiAgfSxcbiAgZ2V0UGl4ZWxPZmZzZXQ6IHtcbiAgICB0eXBlOiAnYWNjZXNzb3InLFxuICAgIHZhbHVlOiBbMCwgMF1cbiAgfSxcbiAgb25JY29uRXJyb3I6IHtcbiAgICB0eXBlOiAnZnVuY3Rpb24nLFxuICAgIHZhbHVlOiBudWxsLFxuICAgIG9wdGlvbmFsOiB0cnVlXG4gIH0sXG4gIHRleHR1cmVQYXJhbWV0ZXJzOiB7XG4gICAgdHlwZTogJ29iamVjdCcsXG4gICAgaWdub3JlOiB0cnVlXG4gIH1cbn07XG5leHBvcnQgZGVmYXVsdCBjbGFzcyBJY29uTGF5ZXIgZXh0ZW5kcyBMYXllciB7XG4gIGNvbnN0cnVjdG9yKC4uLmFyZ3MpIHtcbiAgICBzdXBlciguLi5hcmdzKTtcblxuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInN0YXRlXCIsIHZvaWQgMCk7XG4gIH1cblxuICBnZXRTaGFkZXJzKCkge1xuICAgIHJldHVybiBzdXBlci5nZXRTaGFkZXJzKHtcbiAgICAgIHZzLFxuICAgICAgZnMsXG4gICAgICBtb2R1bGVzOiBbcHJvamVjdDMyLCBwaWNraW5nXVxuICAgIH0pO1xuICB9XG5cbiAgaW5pdGlhbGl6ZVN0YXRlKCkge1xuICAgIHRoaXMuc3RhdGUgPSB7XG4gICAgICBpY29uTWFuYWdlcjogbmV3IEljb25NYW5hZ2VyKHRoaXMuY29udGV4dC5nbCwge1xuICAgICAgICBvblVwZGF0ZTogdGhpcy5fb25VcGRhdGUuYmluZCh0aGlzKSxcbiAgICAgICAgb25FcnJvcjogdGhpcy5fb25FcnJvci5iaW5kKHRoaXMpXG4gICAgICB9KVxuICAgIH07XG4gICAgY29uc3QgYXR0cmlidXRlTWFuYWdlciA9IHRoaXMuZ2V0QXR0cmlidXRlTWFuYWdlcigpO1xuICAgIGF0dHJpYnV0ZU1hbmFnZXIuYWRkSW5zdGFuY2VkKHtcbiAgICAgIGluc3RhbmNlUG9zaXRpb25zOiB7XG4gICAgICAgIHNpemU6IDMsXG4gICAgICAgIHR5cGU6IDUxMzAsXG4gICAgICAgIGZwNjQ6IHRoaXMudXNlNjRiaXRQb3NpdGlvbnMoKSxcbiAgICAgICAgdHJhbnNpdGlvbjogdHJ1ZSxcbiAgICAgICAgYWNjZXNzb3I6ICdnZXRQb3NpdGlvbidcbiAgICAgIH0sXG4gICAgICBpbnN0YW5jZVNpemVzOiB7XG4gICAgICAgIHNpemU6IDEsXG4gICAgICAgIHRyYW5zaXRpb246IHRydWUsXG4gICAgICAgIGFjY2Vzc29yOiAnZ2V0U2l6ZScsXG4gICAgICAgIGRlZmF1bHRWYWx1ZTogMVxuICAgICAgfSxcbiAgICAgIGluc3RhbmNlT2Zmc2V0czoge1xuICAgICAgICBzaXplOiAyLFxuICAgICAgICBhY2Nlc3NvcjogJ2dldEljb24nLFxuICAgICAgICB0cmFuc2Zvcm06IHRoaXMuZ2V0SW5zdGFuY2VPZmZzZXRcbiAgICAgIH0sXG4gICAgICBpbnN0YW5jZUljb25GcmFtZXM6IHtcbiAgICAgICAgc2l6ZTogNCxcbiAgICAgICAgYWNjZXNzb3I6ICdnZXRJY29uJyxcbiAgICAgICAgdHJhbnNmb3JtOiB0aGlzLmdldEluc3RhbmNlSWNvbkZyYW1lXG4gICAgICB9LFxuICAgICAgaW5zdGFuY2VDb2xvck1vZGVzOiB7XG4gICAgICAgIHNpemU6IDEsXG4gICAgICAgIHR5cGU6IDUxMjEsXG4gICAgICAgIGFjY2Vzc29yOiAnZ2V0SWNvbicsXG4gICAgICAgIHRyYW5zZm9ybTogdGhpcy5nZXRJbnN0YW5jZUNvbG9yTW9kZVxuICAgICAgfSxcbiAgICAgIGluc3RhbmNlQ29sb3JzOiB7XG4gICAgICAgIHNpemU6IHRoaXMucHJvcHMuY29sb3JGb3JtYXQubGVuZ3RoLFxuICAgICAgICB0eXBlOiA1MTIxLFxuICAgICAgICBub3JtYWxpemVkOiB0cnVlLFxuICAgICAgICB0cmFuc2l0aW9uOiB0cnVlLFxuICAgICAgICBhY2Nlc3NvcjogJ2dldENvbG9yJyxcbiAgICAgICAgZGVmYXVsdFZhbHVlOiBERUZBVUxUX0NPTE9SXG4gICAgICB9LFxuICAgICAgaW5zdGFuY2VBbmdsZXM6IHtcbiAgICAgICAgc2l6ZTogMSxcbiAgICAgICAgdHJhbnNpdGlvbjogdHJ1ZSxcbiAgICAgICAgYWNjZXNzb3I6ICdnZXRBbmdsZSdcbiAgICAgIH0sXG4gICAgICBpbnN0YW5jZVBpeGVsT2Zmc2V0OiB7XG4gICAgICAgIHNpemU6IDIsXG4gICAgICAgIHRyYW5zaXRpb246IHRydWUsXG4gICAgICAgIGFjY2Vzc29yOiAnZ2V0UGl4ZWxPZmZzZXQnXG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICB1cGRhdGVTdGF0ZShwYXJhbXMpIHtcbiAgICBzdXBlci51cGRhdGVTdGF0ZShwYXJhbXMpO1xuICAgIGNvbnN0IHtcbiAgICAgIHByb3BzLFxuICAgICAgb2xkUHJvcHMsXG4gICAgICBjaGFuZ2VGbGFnc1xuICAgIH0gPSBwYXJhbXM7XG4gICAgY29uc3QgYXR0cmlidXRlTWFuYWdlciA9IHRoaXMuZ2V0QXR0cmlidXRlTWFuYWdlcigpO1xuICAgIGNvbnN0IHtcbiAgICAgIGljb25BdGxhcyxcbiAgICAgIGljb25NYXBwaW5nLFxuICAgICAgZGF0YSxcbiAgICAgIGdldEljb24sXG4gICAgICB0ZXh0dXJlUGFyYW1ldGVyc1xuICAgIH0gPSBwcm9wcztcbiAgICBjb25zdCB7XG4gICAgICBpY29uTWFuYWdlclxuICAgIH0gPSB0aGlzLnN0YXRlO1xuICAgIGNvbnN0IHByZVBhY2tlZCA9IGljb25BdGxhcyB8fCB0aGlzLmludGVybmFsU3RhdGUuaXNBc3luY1Byb3BMb2FkaW5nKCdpY29uQXRsYXMnKTtcbiAgICBpY29uTWFuYWdlci5zZXRQcm9wcyh7XG4gICAgICBsb2FkT3B0aW9uczogcHJvcHMubG9hZE9wdGlvbnMsXG4gICAgICBhdXRvUGFja2luZzogIXByZVBhY2tlZCxcbiAgICAgIGljb25BdGxhcyxcbiAgICAgIGljb25NYXBwaW5nOiBwcmVQYWNrZWQgPyBpY29uTWFwcGluZyA6IG51bGwsXG4gICAgICB0ZXh0dXJlUGFyYW1ldGVyc1xuICAgIH0pO1xuXG4gICAgaWYgKHByZVBhY2tlZCkge1xuICAgICAgaWYgKG9sZFByb3BzLmljb25NYXBwaW5nICE9PSBwcm9wcy5pY29uTWFwcGluZykge1xuICAgICAgICBhdHRyaWJ1dGVNYW5hZ2VyLmludmFsaWRhdGUoJ2dldEljb24nKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGNoYW5nZUZsYWdzLmRhdGFDaGFuZ2VkIHx8IGNoYW5nZUZsYWdzLnVwZGF0ZVRyaWdnZXJzQ2hhbmdlZCAmJiAoY2hhbmdlRmxhZ3MudXBkYXRlVHJpZ2dlcnNDaGFuZ2VkLmFsbCB8fCBjaGFuZ2VGbGFncy51cGRhdGVUcmlnZ2Vyc0NoYW5nZWQuZ2V0SWNvbikpIHtcbiAgICAgIGljb25NYW5hZ2VyLnBhY2tJY29ucyhkYXRhLCBnZXRJY29uKTtcbiAgICB9XG5cbiAgICBpZiAoY2hhbmdlRmxhZ3MuZXh0ZW5zaW9uc0NoYW5nZWQpIHtcbiAgICAgIHZhciBfdGhpcyRzdGF0ZSRtb2RlbDtcblxuICAgICAgY29uc3Qge1xuICAgICAgICBnbFxuICAgICAgfSA9IHRoaXMuY29udGV4dDtcbiAgICAgIChfdGhpcyRzdGF0ZSRtb2RlbCA9IHRoaXMuc3RhdGUubW9kZWwpID09PSBudWxsIHx8IF90aGlzJHN0YXRlJG1vZGVsID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfdGhpcyRzdGF0ZSRtb2RlbC5kZWxldGUoKTtcbiAgICAgIHRoaXMuc3RhdGUubW9kZWwgPSB0aGlzLl9nZXRNb2RlbChnbCk7XG4gICAgICBhdHRyaWJ1dGVNYW5hZ2VyLmludmFsaWRhdGVBbGwoKTtcbiAgICB9XG4gIH1cblxuICBnZXQgaXNMb2FkZWQoKSB7XG4gICAgcmV0dXJuIHN1cGVyLmlzTG9hZGVkICYmIHRoaXMuc3RhdGUuaWNvbk1hbmFnZXIuaXNMb2FkZWQ7XG4gIH1cblxuICBmaW5hbGl6ZVN0YXRlKGNvbnRleHQpIHtcbiAgICBzdXBlci5maW5hbGl6ZVN0YXRlKGNvbnRleHQpO1xuICAgIHRoaXMuc3RhdGUuaWNvbk1hbmFnZXIuZmluYWxpemUoKTtcbiAgfVxuXG4gIGRyYXcoe1xuICAgIHVuaWZvcm1zXG4gIH0pIHtcbiAgICBjb25zdCB7XG4gICAgICBzaXplU2NhbGUsXG4gICAgICBzaXplTWluUGl4ZWxzLFxuICAgICAgc2l6ZU1heFBpeGVscyxcbiAgICAgIHNpemVVbml0cyxcbiAgICAgIGJpbGxib2FyZCxcbiAgICAgIGFscGhhQ3V0b2ZmXG4gICAgfSA9IHRoaXMucHJvcHM7XG4gICAgY29uc3Qge1xuICAgICAgaWNvbk1hbmFnZXJcbiAgICB9ID0gdGhpcy5zdGF0ZTtcbiAgICBjb25zdCBpY29uc1RleHR1cmUgPSBpY29uTWFuYWdlci5nZXRUZXh0dXJlKCk7XG5cbiAgICBpZiAoaWNvbnNUZXh0dXJlKSB7XG4gICAgICB0aGlzLnN0YXRlLm1vZGVsLnNldFVuaWZvcm1zKHVuaWZvcm1zKS5zZXRVbmlmb3Jtcyh7XG4gICAgICAgIGljb25zVGV4dHVyZSxcbiAgICAgICAgaWNvbnNUZXh0dXJlRGltOiBbaWNvbnNUZXh0dXJlLndpZHRoLCBpY29uc1RleHR1cmUuaGVpZ2h0XSxcbiAgICAgICAgc2l6ZVVuaXRzOiBVTklUW3NpemVVbml0c10sXG4gICAgICAgIHNpemVTY2FsZSxcbiAgICAgICAgc2l6ZU1pblBpeGVscyxcbiAgICAgICAgc2l6ZU1heFBpeGVscyxcbiAgICAgICAgYmlsbGJvYXJkLFxuICAgICAgICBhbHBoYUN1dG9mZlxuICAgICAgfSkuZHJhdygpO1xuICAgIH1cbiAgfVxuXG4gIF9nZXRNb2RlbChnbCkge1xuICAgIGNvbnN0IHBvc2l0aW9ucyA9IFstMSwgLTEsIC0xLCAxLCAxLCAxLCAxLCAtMV07XG4gICAgcmV0dXJuIG5ldyBNb2RlbChnbCwgeyAuLi50aGlzLmdldFNoYWRlcnMoKSxcbiAgICAgIGlkOiB0aGlzLnByb3BzLmlkLFxuICAgICAgZ2VvbWV0cnk6IG5ldyBHZW9tZXRyeSh7XG4gICAgICAgIGRyYXdNb2RlOiA2LFxuICAgICAgICBhdHRyaWJ1dGVzOiB7XG4gICAgICAgICAgcG9zaXRpb25zOiB7XG4gICAgICAgICAgICBzaXplOiAyLFxuICAgICAgICAgICAgdmFsdWU6IG5ldyBGbG9hdDMyQXJyYXkocG9zaXRpb25zKVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSksXG4gICAgICBpc0luc3RhbmNlZDogdHJ1ZVxuICAgIH0pO1xuICB9XG5cbiAgX29uVXBkYXRlKCkge1xuICAgIHRoaXMuc2V0TmVlZHNSZWRyYXcoKTtcbiAgfVxuXG4gIF9vbkVycm9yKGV2dCkge1xuICAgIHZhciBfdGhpcyRnZXRDdXJyZW50TGF5ZXI7XG5cbiAgICBjb25zdCBvbkljb25FcnJvciA9IChfdGhpcyRnZXRDdXJyZW50TGF5ZXIgPSB0aGlzLmdldEN1cnJlbnRMYXllcigpKSA9PT0gbnVsbCB8fCBfdGhpcyRnZXRDdXJyZW50TGF5ZXIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF90aGlzJGdldEN1cnJlbnRMYXllci5wcm9wcy5vbkljb25FcnJvcjtcblxuICAgIGlmIChvbkljb25FcnJvcikge1xuICAgICAgb25JY29uRXJyb3IoZXZ0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgbG9nLmVycm9yKGV2dC5lcnJvci5tZXNzYWdlKSgpO1xuICAgIH1cbiAgfVxuXG4gIGdldEluc3RhbmNlT2Zmc2V0KGljb24pIHtcbiAgICBjb25zdCB7XG4gICAgICB3aWR0aCxcbiAgICAgIGhlaWdodCxcbiAgICAgIGFuY2hvclggPSB3aWR0aCAvIDIsXG4gICAgICBhbmNob3JZID0gaGVpZ2h0IC8gMlxuICAgIH0gPSB0aGlzLnN0YXRlLmljb25NYW5hZ2VyLmdldEljb25NYXBwaW5nKGljb24pO1xuICAgIHJldHVybiBbd2lkdGggLyAyIC0gYW5jaG9yWCwgaGVpZ2h0IC8gMiAtIGFuY2hvclldO1xuICB9XG5cbiAgZ2V0SW5zdGFuY2VDb2xvck1vZGUoaWNvbikge1xuICAgIGNvbnN0IG1hcHBpbmcgPSB0aGlzLnN0YXRlLmljb25NYW5hZ2VyLmdldEljb25NYXBwaW5nKGljb24pO1xuICAgIHJldHVybiBtYXBwaW5nLm1hc2sgPyAxIDogMDtcbiAgfVxuXG4gIGdldEluc3RhbmNlSWNvbkZyYW1lKGljb24pIHtcbiAgICBjb25zdCB7XG4gICAgICB4LFxuICAgICAgeSxcbiAgICAgIHdpZHRoLFxuICAgICAgaGVpZ2h0XG4gICAgfSA9IHRoaXMuc3RhdGUuaWNvbk1hbmFnZXIuZ2V0SWNvbk1hcHBpbmcoaWNvbik7XG4gICAgcmV0dXJuIFt4LCB5LCB3aWR0aCwgaGVpZ2h0XTtcbiAgfVxuXG59XG5cbl9kZWZpbmVQcm9wZXJ0eShJY29uTGF5ZXIsIFwiZGVmYXVsdFByb3BzXCIsIGRlZmF1bHRQcm9wcyk7XG5cbl9kZWZpbmVQcm9wZXJ0eShJY29uTGF5ZXIsIFwibGF5ZXJOYW1lXCIsICdJY29uTGF5ZXInKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWljb24tbGF5ZXIuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///13418\n")},41990:function(__unused_webpack_module,__webpack_exports__,__webpack_require__){eval("\n// EXPORTS\n__webpack_require__.d(__webpack_exports__, {\n  \"Z\": function() { return /* binding */ PathLayer; }\n});\n\n// EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/esm/defineProperty.js\nvar defineProperty = __webpack_require__(82482);\n// EXTERNAL MODULE: ./node_modules/@deck.gl/core/dist/esm/lib/layer.js + 3 modules\nvar lib_layer = __webpack_require__(52447);\n// EXTERNAL MODULE: ./node_modules/@deck.gl/core/dist/esm/shaderlib/project32/project32.js\nvar project32 = __webpack_require__(93844);\n// EXTERNAL MODULE: ./node_modules/@deck.gl/core/dist/esm/shaderlib/picking/picking.js\nvar picking = __webpack_require__(43844);\n// EXTERNAL MODULE: ./node_modules/@deck.gl/core/dist/esm/lib/constants.js\nvar constants = __webpack_require__(24088);\n// EXTERNAL MODULE: ./node_modules/@luma.gl/engine/dist/esm/lib/model.js + 1 modules\nvar model = __webpack_require__(80210);\n// EXTERNAL MODULE: ./node_modules/@luma.gl/engine/dist/esm/geometry/geometry.js\nvar geometry = __webpack_require__(53982);\n// EXTERNAL MODULE: ./node_modules/@deck.gl/core/dist/esm/utils/tesselator.js\nvar tesselator = __webpack_require__(28005);\n// EXTERNAL MODULE: ./node_modules/@math.gl/polygon/dist/esm/index.js + 7 modules\nvar esm = __webpack_require__(89513);\n;// CONCATENATED MODULE: ./node_modules/@deck.gl/layers/dist/esm/path-layer/path.js\n\nfunction normalizePath(path, size, gridResolution, wrapLongitude) {\n  let flatPath;\n\n  if (Array.isArray(path[0])) {\n    const length = path.length * size;\n    flatPath = new Array(length);\n\n    for (let i = 0; i < path.length; i++) {\n      for (let j = 0; j < size; j++) {\n        flatPath[i * size + j] = path[i][j] || 0;\n      }\n    }\n  } else {\n    flatPath = path;\n  }\n\n  if (gridResolution) {\n    return (0,esm/* cutPolylineByGrid */.dj)(flatPath, {\n      size,\n      gridResolution\n    });\n  }\n\n  if (wrapLongitude) {\n    return (0,esm/* cutPolylineByMercatorBounds */.ct)(flatPath, {\n      size\n    });\n  }\n\n  return flatPath;\n}\n//# sourceMappingURL=path.js.map\n;// CONCATENATED MODULE: ./node_modules/@deck.gl/layers/dist/esm/path-layer/path-tesselator.js\n\n\nconst START_CAP = 1;\nconst END_CAP = 2;\nconst INVALID = 4;\nclass PathTesselator extends tesselator/* default */.Z {\n  constructor(opts) {\n    super({ ...opts,\n      attributes: {\n        positions: {\n          size: 3,\n          padding: 18,\n          initialize: true,\n          type: opts.fp64 ? Float64Array : Float32Array\n        },\n        segmentTypes: {\n          size: 1,\n          type: Uint8ClampedArray\n        }\n      }\n    });\n  }\n\n  get(attributeName) {\n    return this.attributes[attributeName];\n  }\n\n  getGeometryFromBuffer(buffer) {\n    if (this.normalize) {\n      return super.getGeometryFromBuffer(buffer);\n    }\n\n    return null;\n  }\n\n  normalizeGeometry(path) {\n    if (this.normalize) {\n      return normalizePath(path, this.positionSize, this.opts.resolution, this.opts.wrapLongitude);\n    }\n\n    return path;\n  }\n\n  getGeometrySize(path) {\n    if (isCut(path)) {\n      let size = 0;\n\n      for (const subPath of path) {\n        size += this.getGeometrySize(subPath);\n      }\n\n      return size;\n    }\n\n    const numPoints = this.getPathLength(path);\n\n    if (numPoints < 2) {\n      return 0;\n    }\n\n    if (this.isClosed(path)) {\n      return numPoints < 3 ? 0 : numPoints + 2;\n    }\n\n    return numPoints;\n  }\n\n  updateGeometryAttributes(path, context) {\n    if (context.geometrySize === 0) {\n      return;\n    }\n\n    if (path && isCut(path)) {\n      for (const subPath of path) {\n        const geometrySize = this.getGeometrySize(subPath);\n        context.geometrySize = geometrySize;\n        this.updateGeometryAttributes(subPath, context);\n        context.vertexStart += geometrySize;\n      }\n    } else {\n      this._updateSegmentTypes(path, context);\n\n      this._updatePositions(path, context);\n    }\n  }\n\n  _updateSegmentTypes(path, context) {\n    const segmentTypes = this.attributes.segmentTypes;\n    const isPathClosed = path ? this.isClosed(path) : false;\n    const {\n      vertexStart,\n      geometrySize\n    } = context;\n    segmentTypes.fill(0, vertexStart, vertexStart + geometrySize);\n\n    if (isPathClosed) {\n      segmentTypes[vertexStart] = INVALID;\n      segmentTypes[vertexStart + geometrySize - 2] = INVALID;\n    } else {\n      segmentTypes[vertexStart] += START_CAP;\n      segmentTypes[vertexStart + geometrySize - 2] += END_CAP;\n    }\n\n    segmentTypes[vertexStart + geometrySize - 1] = INVALID;\n  }\n\n  _updatePositions(path, context) {\n    const {\n      positions\n    } = this.attributes;\n\n    if (!positions || !path) {\n      return;\n    }\n\n    const {\n      vertexStart,\n      geometrySize\n    } = context;\n    const p = new Array(3);\n\n    for (let i = vertexStart, ptIndex = 0; ptIndex < geometrySize; i++, ptIndex++) {\n      this.getPointOnPath(path, ptIndex, p);\n      positions[i * 3] = p[0];\n      positions[i * 3 + 1] = p[1];\n      positions[i * 3 + 2] = p[2];\n    }\n  }\n\n  getPathLength(path) {\n    return path.length / this.positionSize;\n  }\n\n  getPointOnPath(path, index, target = []) {\n    const {\n      positionSize\n    } = this;\n\n    if (index * positionSize >= path.length) {\n      index += 1 - path.length / positionSize;\n    }\n\n    const i = index * positionSize;\n    target[0] = path[i];\n    target[1] = path[i + 1];\n    target[2] = positionSize === 3 && path[i + 2] || 0;\n    return target;\n  }\n\n  isClosed(path) {\n    if (!this.normalize) {\n      return Boolean(this.opts.loop);\n    }\n\n    const {\n      positionSize\n    } = this;\n    const lastPointIndex = path.length - positionSize;\n    return path[0] === path[lastPointIndex] && path[1] === path[lastPointIndex + 1] && (positionSize === 2 || path[2] === path[lastPointIndex + 2]);\n  }\n\n}\n\nfunction isCut(path) {\n  return Array.isArray(path[0]);\n}\n//# sourceMappingURL=path-tesselator.js.map\n;// CONCATENATED MODULE: ./node_modules/@deck.gl/layers/dist/esm/path-layer/path-layer-vertex.glsl.js\n/* harmony default export */ var path_layer_vertex_glsl = (\"#define SHADER_NAME path-layer-vertex-shader\\n\\nattribute vec2 positions;\\n\\nattribute float instanceTypes;\\nattribute vec3 instanceStartPositions;\\nattribute vec3 instanceEndPositions;\\nattribute vec3 instanceLeftPositions;\\nattribute vec3 instanceRightPositions;\\nattribute vec3 instanceLeftPositions64Low;\\nattribute vec3 instanceStartPositions64Low;\\nattribute vec3 instanceEndPositions64Low;\\nattribute vec3 instanceRightPositions64Low;\\nattribute float instanceStrokeWidths;\\nattribute vec4 instanceColors;\\nattribute vec3 instancePickingColors;\\n\\nuniform float widthScale;\\nuniform float widthMinPixels;\\nuniform float widthMaxPixels;\\nuniform float jointType;\\nuniform float capType;\\nuniform float miterLimit;\\nuniform bool billboard;\\nuniform int widthUnits;\\n\\nuniform float opacity;\\n\\nvarying vec4 vColor;\\nvarying vec2 vCornerOffset;\\nvarying float vMiterLength;\\nvarying vec2 vPathPosition;\\nvarying float vPathLength;\\nvarying float vJointType;\\n\\nconst float EPSILON = 0.001;\\nconst vec3 ZERO_OFFSET = vec3(0.0);\\n\\nfloat flipIfTrue(bool flag) {\\n  return -(float(flag) * 2. - 1.);\\n}\\nvec3 getLineJoinOffset(\\n  vec3 prevPoint, vec3 currPoint, vec3 nextPoint,\\n  vec2 width\\n) {\\n  bool isEnd = positions.x > 0.0;\\n  float sideOfPath = positions.y;\\n  float isJoint = float(sideOfPath == 0.0);\\n\\n  vec3 deltaA3 = (currPoint - prevPoint);\\n  vec3 deltaB3 = (nextPoint - currPoint);\\n\\n  mat3 rotationMatrix;\\n  bool needsRotation = !billboard && project_needs_rotation(currPoint, rotationMatrix);\\n  if (needsRotation) {\\n    deltaA3 = deltaA3 * rotationMatrix;\\n    deltaB3 = deltaB3 * rotationMatrix;\\n  }\\n  vec2 deltaA = deltaA3.xy / width;\\n  vec2 deltaB = deltaB3.xy / width;\\n\\n  float lenA = length(deltaA);\\n  float lenB = length(deltaB);\\n\\n  vec2 dirA = lenA > 0. ? normalize(deltaA) : vec2(0.0, 0.0);\\n  vec2 dirB = lenB > 0. ? normalize(deltaB) : vec2(0.0, 0.0);\\n\\n  vec2 perpA = vec2(-dirA.y, dirA.x);\\n  vec2 perpB = vec2(-dirB.y, dirB.x);\\n  vec2 tangent = dirA + dirB;\\n  tangent = length(tangent) > 0. ? normalize(tangent) : perpA;\\n  vec2 miterVec = vec2(-tangent.y, tangent.x);\\n  vec2 dir = isEnd ? dirA : dirB;\\n  vec2 perp = isEnd ? perpA : perpB;\\n  float L = isEnd ? lenA : lenB;\\n  float sinHalfA = abs(dot(miterVec, perp));\\n  float cosHalfA = abs(dot(dirA, miterVec));\\n  float turnDirection = flipIfTrue(dirA.x * dirB.y >= dirA.y * dirB.x);\\n  float cornerPosition = sideOfPath * turnDirection;\\n\\n  float miterSize = 1.0 / max(sinHalfA, EPSILON);\\n  miterSize = mix(\\n    min(miterSize, max(lenA, lenB) / max(cosHalfA, EPSILON)),\\n    miterSize,\\n    step(0.0, cornerPosition)\\n  );\\n\\n  vec2 offsetVec = mix(miterVec * miterSize, perp, step(0.5, cornerPosition))\\n    * (sideOfPath + isJoint * turnDirection);\\n  bool isStartCap = lenA == 0.0 || (!isEnd && (instanceTypes == 1.0 || instanceTypes == 3.0));\\n  bool isEndCap = lenB == 0.0 || (isEnd && (instanceTypes == 2.0 || instanceTypes == 3.0));\\n  bool isCap = isStartCap || isEndCap;\\n  if (isCap) {\\n    offsetVec = mix(perp * sideOfPath, dir * capType * 4.0 * flipIfTrue(isStartCap), isJoint);\\n    vJointType = capType;\\n  } else {\\n    vJointType = jointType;\\n  }\\n  vPathLength = L;\\n  vCornerOffset = offsetVec;\\n  vMiterLength = dot(vCornerOffset, miterVec * turnDirection);\\n  vMiterLength = isCap ? isJoint : vMiterLength;\\n\\n  vec2 offsetFromStartOfPath = vCornerOffset + deltaA * float(isEnd);\\n  vPathPosition = vec2(\\n    dot(offsetFromStartOfPath, perp),\\n    dot(offsetFromStartOfPath, dir)\\n  );\\n  geometry.uv = vPathPosition;\\n\\n  float isValid = step(instanceTypes, 3.5);\\n  vec3 offset = vec3(offsetVec * width * isValid, 0.0);\\n\\n  if (needsRotation) {\\n    offset = rotationMatrix * offset;\\n  }\\n  return offset;\\n}\\nvoid clipLine(inout vec4 position, vec4 refPosition) {\\n  if (position.w < EPSILON) {\\n    float r = (EPSILON - refPosition.w) / (position.w - refPosition.w);\\n    position = refPosition + (position - refPosition) * r;\\n  }\\n}\\n\\nvoid main() {\\n  geometry.pickingColor = instancePickingColors;\\n\\n  vColor = vec4(instanceColors.rgb, instanceColors.a * opacity);\\n\\n  float isEnd = positions.x;\\n\\n  vec3 prevPosition = mix(instanceLeftPositions, instanceStartPositions, isEnd);\\n  vec3 prevPosition64Low = mix(instanceLeftPositions64Low, instanceStartPositions64Low, isEnd);\\n\\n  vec3 currPosition = mix(instanceStartPositions, instanceEndPositions, isEnd);\\n  vec3 currPosition64Low = mix(instanceStartPositions64Low, instanceEndPositions64Low, isEnd);\\n\\n  vec3 nextPosition = mix(instanceEndPositions, instanceRightPositions, isEnd);\\n  vec3 nextPosition64Low = mix(instanceEndPositions64Low, instanceRightPositions64Low, isEnd);\\n\\n  geometry.worldPosition = currPosition;\\n  vec2 widthPixels = vec2(clamp(\\n    project_size_to_pixel(instanceStrokeWidths * widthScale, widthUnits),\\n    widthMinPixels, widthMaxPixels) / 2.0);\\n  vec3 width;\\n\\n  if (billboard) {\\n    vec4 prevPositionScreen = project_position_to_clipspace(prevPosition, prevPosition64Low, ZERO_OFFSET);\\n    vec4 currPositionScreen = project_position_to_clipspace(currPosition, currPosition64Low, ZERO_OFFSET, geometry.position);\\n    vec4 nextPositionScreen = project_position_to_clipspace(nextPosition, nextPosition64Low, ZERO_OFFSET);\\n\\n    clipLine(prevPositionScreen, currPositionScreen);\\n    clipLine(nextPositionScreen, currPositionScreen);\\n    clipLine(currPositionScreen, mix(nextPositionScreen, prevPositionScreen, isEnd));\\n\\n    width = vec3(widthPixels, 0.0);\\n    DECKGL_FILTER_SIZE(width, geometry);\\n\\n    vec3 offset = getLineJoinOffset(\\n      prevPositionScreen.xyz / prevPositionScreen.w,\\n      currPositionScreen.xyz / currPositionScreen.w,\\n      nextPositionScreen.xyz / nextPositionScreen.w,\\n      project_pixel_size_to_clipspace(width.xy)\\n    );\\n\\n    DECKGL_FILTER_GL_POSITION(currPositionScreen, geometry);\\n    gl_Position = vec4(currPositionScreen.xyz + offset * currPositionScreen.w, currPositionScreen.w);\\n  } else {\\n    prevPosition = project_position(prevPosition, prevPosition64Low);\\n    currPosition = project_position(currPosition, currPosition64Low);\\n    nextPosition = project_position(nextPosition, nextPosition64Low);\\n\\n    width = vec3(project_pixel_size(widthPixels), 0.0);\\n    DECKGL_FILTER_SIZE(width, geometry);\\n\\n    vec3 offset = getLineJoinOffset(prevPosition, currPosition, nextPosition, width.xy);\\n    geometry.position = vec4(currPosition + offset, 1.0);\\n    gl_Position = project_common_position_to_clipspace(geometry.position);\\n    DECKGL_FILTER_GL_POSITION(gl_Position, geometry);\\n  }\\n  DECKGL_FILTER_COLOR(vColor, geometry);\\n}\\n\");\n//# sourceMappingURL=path-layer-vertex.glsl.js.map\n;// CONCATENATED MODULE: ./node_modules/@deck.gl/layers/dist/esm/path-layer/path-layer-fragment.glsl.js\n/* harmony default export */ var path_layer_fragment_glsl = (\"#define SHADER_NAME path-layer-fragment-shader\\n\\nprecision highp float;\\n\\nuniform float miterLimit;\\n\\nvarying vec4 vColor;\\nvarying vec2 vCornerOffset;\\nvarying float vMiterLength;\\nvarying vec2 vPathPosition;\\nvarying float vPathLength;\\nvarying float vJointType;\\n\\nvoid main(void) {\\n  geometry.uv = vPathPosition;\\n\\n  if (vPathPosition.y < 0.0 || vPathPosition.y > vPathLength) {\\n    if (vJointType > 0.5 && length(vCornerOffset) > 1.0) {\\n      discard;\\n    }\\n    if (vJointType < 0.5 && vMiterLength > miterLimit + 1.0) {\\n      discard;\\n    }\\n  }\\n  gl_FragColor = vColor;\\n\\n  DECKGL_FILTER_COLOR(gl_FragColor, geometry);\\n}\\n\");\n//# sourceMappingURL=path-layer-fragment.glsl.js.map\n;// CONCATENATED MODULE: ./node_modules/@deck.gl/layers/dist/esm/path-layer/path-layer.js\n\n\n\n\n\n\nconst DEFAULT_COLOR = [0, 0, 0, 255];\nconst defaultProps = {\n  widthUnits: 'meters',\n  widthScale: {\n    type: 'number',\n    min: 0,\n    value: 1\n  },\n  widthMinPixels: {\n    type: 'number',\n    min: 0,\n    value: 0\n  },\n  widthMaxPixels: {\n    type: 'number',\n    min: 0,\n    value: Number.MAX_SAFE_INTEGER\n  },\n  jointRounded: false,\n  capRounded: false,\n  miterLimit: {\n    type: 'number',\n    min: 0,\n    value: 4\n  },\n  billboard: false,\n  _pathType: null,\n  getPath: {\n    type: 'accessor',\n    value: object => object.path\n  },\n  getColor: {\n    type: 'accessor',\n    value: DEFAULT_COLOR\n  },\n  getWidth: {\n    type: 'accessor',\n    value: 1\n  },\n  rounded: {\n    deprecatedFor: ['jointRounded', 'capRounded']\n  }\n};\nconst ATTRIBUTE_TRANSITION = {\n  enter: (value, chunk) => {\n    return chunk.length ? chunk.subarray(chunk.length - value.length) : value;\n  }\n};\nclass PathLayer extends lib_layer/* default */.Z {\n  constructor(...args) {\n    super(...args);\n\n    (0,defineProperty/* default */.Z)(this, \"state\", void 0);\n  }\n\n  getShaders() {\n    return super.getShaders({\n      vs: path_layer_vertex_glsl,\n      fs: path_layer_fragment_glsl,\n      modules: [project32/* default */.Z, picking/* default */.Z]\n    });\n  }\n\n  get wrapLongitude() {\n    return false;\n  }\n\n  initializeState() {\n    const noAlloc = true;\n    const attributeManager = this.getAttributeManager();\n    attributeManager.addInstanced({\n      positions: {\n        size: 3,\n        vertexOffset: 1,\n        type: 5130,\n        fp64: this.use64bitPositions(),\n        transition: ATTRIBUTE_TRANSITION,\n        accessor: 'getPath',\n        update: this.calculatePositions,\n        noAlloc,\n        shaderAttributes: {\n          instanceLeftPositions: {\n            vertexOffset: 0\n          },\n          instanceStartPositions: {\n            vertexOffset: 1\n          },\n          instanceEndPositions: {\n            vertexOffset: 2\n          },\n          instanceRightPositions: {\n            vertexOffset: 3\n          }\n        }\n      },\n      instanceTypes: {\n        size: 1,\n        type: 5121,\n        update: this.calculateSegmentTypes,\n        noAlloc\n      },\n      instanceStrokeWidths: {\n        size: 1,\n        accessor: 'getWidth',\n        transition: ATTRIBUTE_TRANSITION,\n        defaultValue: 1\n      },\n      instanceColors: {\n        size: this.props.colorFormat.length,\n        type: 5121,\n        normalized: true,\n        accessor: 'getColor',\n        transition: ATTRIBUTE_TRANSITION,\n        defaultValue: DEFAULT_COLOR\n      },\n      instancePickingColors: {\n        size: 3,\n        type: 5121,\n        accessor: (object, {\n          index,\n          target: value\n        }) => this.encodePickingColor(object && object.__source ? object.__source.index : index, value)\n      }\n    });\n    this.setState({\n      pathTesselator: new PathTesselator({\n        fp64: this.use64bitPositions()\n      })\n    });\n  }\n\n  updateState(params) {\n    super.updateState(params);\n    const {\n      props,\n      changeFlags\n    } = params;\n    const attributeManager = this.getAttributeManager();\n    const geometryChanged = changeFlags.dataChanged || changeFlags.updateTriggersChanged && (changeFlags.updateTriggersChanged.all || changeFlags.updateTriggersChanged.getPath);\n\n    if (geometryChanged) {\n      const {\n        pathTesselator\n      } = this.state;\n      const buffers = props.data.attributes || {};\n      pathTesselator.updateGeometry({\n        data: props.data,\n        geometryBuffer: buffers.getPath,\n        buffers,\n        normalize: !props._pathType,\n        loop: props._pathType === 'loop',\n        getGeometry: props.getPath,\n        positionFormat: props.positionFormat,\n        wrapLongitude: props.wrapLongitude,\n        resolution: this.context.viewport.resolution,\n        dataChanged: changeFlags.dataChanged\n      });\n      this.setState({\n        numInstances: pathTesselator.instanceCount,\n        startIndices: pathTesselator.vertexStarts\n      });\n\n      if (!changeFlags.dataChanged) {\n        attributeManager.invalidateAll();\n      }\n    }\n\n    if (changeFlags.extensionsChanged) {\n      var _this$state$model;\n\n      const {\n        gl\n      } = this.context;\n      (_this$state$model = this.state.model) === null || _this$state$model === void 0 ? void 0 : _this$state$model.delete();\n      this.state.model = this._getModel(gl);\n      attributeManager.invalidateAll();\n    }\n  }\n\n  getPickingInfo(params) {\n    const info = super.getPickingInfo(params);\n    const {\n      index\n    } = info;\n    const {\n      data\n    } = this.props;\n\n    if (data[0] && data[0].__source) {\n      info.object = data.find(d => d.__source.index === index);\n    }\n\n    return info;\n  }\n\n  disablePickingIndex(objectIndex) {\n    const {\n      data\n    } = this.props;\n\n    if (data[0] && data[0].__source) {\n      for (let i = 0; i < data.length; i++) {\n        if (data[i].__source.index === objectIndex) {\n          this._disablePickingIndex(i);\n        }\n      }\n    } else {\n      this._disablePickingIndex(objectIndex);\n    }\n  }\n\n  draw({\n    uniforms\n  }) {\n    const {\n      jointRounded,\n      capRounded,\n      billboard,\n      miterLimit,\n      widthUnits,\n      widthScale,\n      widthMinPixels,\n      widthMaxPixels\n    } = this.props;\n    this.state.model.setUniforms(uniforms).setUniforms({\n      jointType: Number(jointRounded),\n      capType: Number(capRounded),\n      billboard,\n      widthUnits: constants/* UNIT */.iI[widthUnits],\n      widthScale,\n      miterLimit,\n      widthMinPixels,\n      widthMaxPixels\n    }).draw();\n  }\n\n  _getModel(gl) {\n    const SEGMENT_INDICES = [0, 1, 2, 1, 4, 2, 1, 3, 4, 3, 5, 4];\n    const SEGMENT_POSITIONS = [0, 0, 0, -1, 0, 1, 1, -1, 1, 1, 1, 0];\n    return new model/* default */.Z(gl, { ...this.getShaders(),\n      id: this.props.id,\n      geometry: new geometry/* default */.Z({\n        drawMode: 4,\n        attributes: {\n          indices: new Uint16Array(SEGMENT_INDICES),\n          positions: {\n            value: new Float32Array(SEGMENT_POSITIONS),\n            size: 2\n          }\n        }\n      }),\n      isInstanced: true\n    });\n  }\n\n  calculatePositions(attribute) {\n    const {\n      pathTesselator\n    } = this.state;\n    attribute.startIndices = pathTesselator.vertexStarts;\n    attribute.value = pathTesselator.get('positions');\n  }\n\n  calculateSegmentTypes(attribute) {\n    const {\n      pathTesselator\n    } = this.state;\n    attribute.startIndices = pathTesselator.vertexStarts;\n    attribute.value = pathTesselator.get('segmentTypes');\n  }\n\n}\n\n(0,defineProperty/* default */.Z)(PathLayer, \"defaultProps\", defaultProps);\n\n(0,defineProperty/* default */.Z)(PathLayer, \"layerName\", 'PathLayer');\n//# sourceMappingURL=path-layer.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNDE5OTAuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFrRjtBQUMzRTtBQUNQOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxvQkFBb0IsaUJBQWlCO0FBQ3JDLHNCQUFzQixVQUFVO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0EsV0FBVyxpQ0FBaUI7QUFDNUI7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBLFdBQVcsMkNBQTJCO0FBQ3RDO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQSxnQzs7QUNoQzJDO0FBQ0o7QUFDdkM7QUFDQTtBQUNBO0FBQ2UsNkJBQTZCLHlCQUFVO0FBQ3REO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxhQUFhLGFBQWE7QUFDMUI7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07O0FBRU47QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjs7QUFFQSwyQ0FBMkMsd0JBQXdCO0FBQ25FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTs7QUFFTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDJDOztBQ3RLQSwyREFBZSwwRUFBMEUsa0NBQWtDLHdDQUF3QyxzQ0FBc0MsdUNBQXVDLHdDQUF3Qyw0Q0FBNEMsNkNBQTZDLDJDQUEyQyw2Q0FBNkMsdUNBQXVDLGdDQUFnQyx1Q0FBdUMsNkJBQTZCLCtCQUErQiwrQkFBK0IsMEJBQTBCLHdCQUF3QiwyQkFBMkIseUJBQXlCLHlCQUF5QiwwQkFBMEIsd0JBQXdCLDZCQUE2Qiw2QkFBNkIsNkJBQTZCLDRCQUE0QiwyQkFBMkIsZ0NBQWdDLHFDQUFxQyxpQ0FBaUMsb0NBQW9DLEdBQUcsK0ZBQStGLG1DQUFtQyxtQ0FBbUMsNkNBQTZDLDZDQUE2QywyQ0FBMkMsMEJBQTBCLHlGQUF5Rix3QkFBd0IseUNBQXlDLHlDQUF5QyxLQUFLLHFDQUFxQyxxQ0FBcUMsa0NBQWtDLGdDQUFnQyxpRUFBaUUsK0RBQStELHlDQUF5Qyx1Q0FBdUMsK0JBQStCLGdFQUFnRSxnREFBZ0QsbUNBQW1DLHNDQUFzQyxrQ0FBa0MsOENBQThDLDhDQUE4Qyx5RUFBeUUsc0RBQXNELHFEQUFxRCx3SUFBd0ksZ0lBQWdJLGdHQUFnRyw2RkFBNkYsd0NBQXdDLGdCQUFnQixnR0FBZ0csMkJBQTJCLE1BQU0sTUFBTSw2QkFBNkIsS0FBSyxvQkFBb0IsOEJBQThCLGdFQUFnRSxrREFBa0QseUVBQXlFLDJHQUEyRyxnQ0FBZ0MsK0NBQStDLHlEQUF5RCwwQkFBMEIsdUNBQXVDLEtBQUssa0JBQWtCLEdBQUcsd0RBQXdELCtCQUErQix5RUFBeUUsNERBQTRELEtBQUssR0FBRyxpQkFBaUIsa0RBQWtELG9FQUFvRSxnQ0FBZ0Msb0ZBQW9GLGlHQUFpRyxtRkFBbUYsZ0dBQWdHLG1GQUFtRixnR0FBZ0csNENBQTRDLDBKQUEwSixlQUFlLHNCQUFzQiw0R0FBNEcsK0hBQStILDRHQUE0Ryx5REFBeUQsdURBQXVELHVGQUF1Rix1Q0FBdUMsMENBQTBDLG1RQUFtUSxnRUFBZ0UsdUdBQXVHLE1BQU0sTUFBTSx1RUFBdUUsdUVBQXVFLHVFQUF1RSwyREFBMkQsMENBQTBDLDRGQUE0RiwyREFBMkQsNEVBQTRFLHVEQUF1RCxLQUFLLDBDQUEwQyxHQUFHLEdBQUcsRUFBQztBQUNqL00sa0Q7O0FDREEsNkRBQWUseUVBQXlFLDZCQUE2Qix3QkFBd0IsNkJBQTZCLDZCQUE2Qiw2QkFBNkIsNEJBQTRCLDJCQUEyQixxQkFBcUIsZ0NBQWdDLG1FQUFtRSw0REFBNEQsZ0JBQWdCLE9BQU8sZ0VBQWdFLGdCQUFnQixPQUFPLEtBQUssMEJBQTBCLGtEQUFrRCxHQUFHLEdBQUcsRUFBQztBQUNycEIsb0Q7O0FDRHdFO0FBQ1I7QUFDaEI7QUFDRDtBQUNMO0FBQ0U7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDZSx3QkFBd0Isd0JBQUs7QUFDNUM7QUFDQTs7QUFFQSxJQUFJLGlDQUFlO0FBQ25COztBQUVBO0FBQ0E7QUFDQSxRQUFRO0FBQ1IsUUFBUTtBQUNSLGdCQUFnQix3QkFBUyxFQUFFLHNCQUFPO0FBQ2xDLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxLQUFLO0FBQ0w7QUFDQSwwQkFBMEIsY0FBYztBQUN4QztBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsTUFBTTs7QUFFTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNOztBQUVOO0FBQ0Esc0JBQXNCLGlCQUFpQjtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0Isc0JBQUk7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZUFBZSxvQkFBSyxPQUFPO0FBQzNCO0FBQ0Esb0JBQW9CLHVCQUFRO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBOztBQUVBLGlDQUFlOztBQUVmLGlDQUFlO0FBQ2YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly92dWUzLXdlYnBhY2s1Ly4vbm9kZV9tb2R1bGVzL0BkZWNrLmdsL2xheWVycy9kaXN0L2VzbS9wYXRoLWxheWVyL3BhdGguanM/YTUwMSIsIndlYnBhY2s6Ly92dWUzLXdlYnBhY2s1Ly4vbm9kZV9tb2R1bGVzL0BkZWNrLmdsL2xheWVycy9kaXN0L2VzbS9wYXRoLWxheWVyL3BhdGgtdGVzc2VsYXRvci5qcz8xYTE1Iiwid2VicGFjazovL3Z1ZTMtd2VicGFjazUvLi9ub2RlX21vZHVsZXMvQGRlY2suZ2wvbGF5ZXJzL2Rpc3QvZXNtL3BhdGgtbGF5ZXIvcGF0aC1sYXllci12ZXJ0ZXguZ2xzbC5qcz9kNTIyIiwid2VicGFjazovL3Z1ZTMtd2VicGFjazUvLi9ub2RlX21vZHVsZXMvQGRlY2suZ2wvbGF5ZXJzL2Rpc3QvZXNtL3BhdGgtbGF5ZXIvcGF0aC1sYXllci1mcmFnbWVudC5nbHNsLmpzPzJiMDgiLCJ3ZWJwYWNrOi8vdnVlMy13ZWJwYWNrNS8uL25vZGVfbW9kdWxlcy9AZGVjay5nbC9sYXllcnMvZGlzdC9lc20vcGF0aC1sYXllci9wYXRoLWxheWVyLmpzP2I2YjEiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgY3V0UG9seWxpbmVCeUdyaWQsIGN1dFBvbHlsaW5lQnlNZXJjYXRvckJvdW5kcyB9IGZyb20gJ0BtYXRoLmdsL3BvbHlnb24nO1xuZXhwb3J0IGZ1bmN0aW9uIG5vcm1hbGl6ZVBhdGgocGF0aCwgc2l6ZSwgZ3JpZFJlc29sdXRpb24sIHdyYXBMb25naXR1ZGUpIHtcbiAgbGV0IGZsYXRQYXRoO1xuXG4gIGlmIChBcnJheS5pc0FycmF5KHBhdGhbMF0pKSB7XG4gICAgY29uc3QgbGVuZ3RoID0gcGF0aC5sZW5ndGggKiBzaXplO1xuICAgIGZsYXRQYXRoID0gbmV3IEFycmF5KGxlbmd0aCk7XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHBhdGgubGVuZ3RoOyBpKyspIHtcbiAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgc2l6ZTsgaisrKSB7XG4gICAgICAgIGZsYXRQYXRoW2kgKiBzaXplICsgal0gPSBwYXRoW2ldW2pdIHx8IDA7XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGZsYXRQYXRoID0gcGF0aDtcbiAgfVxuXG4gIGlmIChncmlkUmVzb2x1dGlvbikge1xuICAgIHJldHVybiBjdXRQb2x5bGluZUJ5R3JpZChmbGF0UGF0aCwge1xuICAgICAgc2l6ZSxcbiAgICAgIGdyaWRSZXNvbHV0aW9uXG4gICAgfSk7XG4gIH1cblxuICBpZiAod3JhcExvbmdpdHVkZSkge1xuICAgIHJldHVybiBjdXRQb2x5bGluZUJ5TWVyY2F0b3JCb3VuZHMoZmxhdFBhdGgsIHtcbiAgICAgIHNpemVcbiAgICB9KTtcbiAgfVxuXG4gIHJldHVybiBmbGF0UGF0aDtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXBhdGguanMubWFwIiwiaW1wb3J0IHsgVGVzc2VsYXRvciB9IGZyb20gJ0BkZWNrLmdsL2NvcmUnO1xuaW1wb3J0IHsgbm9ybWFsaXplUGF0aCB9IGZyb20gJy4vcGF0aCc7XG5jb25zdCBTVEFSVF9DQVAgPSAxO1xuY29uc3QgRU5EX0NBUCA9IDI7XG5jb25zdCBJTlZBTElEID0gNDtcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFBhdGhUZXNzZWxhdG9yIGV4dGVuZHMgVGVzc2VsYXRvciB7XG4gIGNvbnN0cnVjdG9yKG9wdHMpIHtcbiAgICBzdXBlcih7IC4uLm9wdHMsXG4gICAgICBhdHRyaWJ1dGVzOiB7XG4gICAgICAgIHBvc2l0aW9uczoge1xuICAgICAgICAgIHNpemU6IDMsXG4gICAgICAgICAgcGFkZGluZzogMTgsXG4gICAgICAgICAgaW5pdGlhbGl6ZTogdHJ1ZSxcbiAgICAgICAgICB0eXBlOiBvcHRzLmZwNjQgPyBGbG9hdDY0QXJyYXkgOiBGbG9hdDMyQXJyYXlcbiAgICAgICAgfSxcbiAgICAgICAgc2VnbWVudFR5cGVzOiB7XG4gICAgICAgICAgc2l6ZTogMSxcbiAgICAgICAgICB0eXBlOiBVaW50OENsYW1wZWRBcnJheVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICBnZXQoYXR0cmlidXRlTmFtZSkge1xuICAgIHJldHVybiB0aGlzLmF0dHJpYnV0ZXNbYXR0cmlidXRlTmFtZV07XG4gIH1cblxuICBnZXRHZW9tZXRyeUZyb21CdWZmZXIoYnVmZmVyKSB7XG4gICAgaWYgKHRoaXMubm9ybWFsaXplKSB7XG4gICAgICByZXR1cm4gc3VwZXIuZ2V0R2VvbWV0cnlGcm9tQnVmZmVyKGJ1ZmZlcik7XG4gICAgfVxuXG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBub3JtYWxpemVHZW9tZXRyeShwYXRoKSB7XG4gICAgaWYgKHRoaXMubm9ybWFsaXplKSB7XG4gICAgICByZXR1cm4gbm9ybWFsaXplUGF0aChwYXRoLCB0aGlzLnBvc2l0aW9uU2l6ZSwgdGhpcy5vcHRzLnJlc29sdXRpb24sIHRoaXMub3B0cy53cmFwTG9uZ2l0dWRlKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcGF0aDtcbiAgfVxuXG4gIGdldEdlb21ldHJ5U2l6ZShwYXRoKSB7XG4gICAgaWYgKGlzQ3V0KHBhdGgpKSB7XG4gICAgICBsZXQgc2l6ZSA9IDA7XG5cbiAgICAgIGZvciAoY29uc3Qgc3ViUGF0aCBvZiBwYXRoKSB7XG4gICAgICAgIHNpemUgKz0gdGhpcy5nZXRHZW9tZXRyeVNpemUoc3ViUGF0aCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBzaXplO1xuICAgIH1cblxuICAgIGNvbnN0IG51bVBvaW50cyA9IHRoaXMuZ2V0UGF0aExlbmd0aChwYXRoKTtcblxuICAgIGlmIChudW1Qb2ludHMgPCAyKSB7XG4gICAgICByZXR1cm4gMDtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5pc0Nsb3NlZChwYXRoKSkge1xuICAgICAgcmV0dXJuIG51bVBvaW50cyA8IDMgPyAwIDogbnVtUG9pbnRzICsgMjtcbiAgICB9XG5cbiAgICByZXR1cm4gbnVtUG9pbnRzO1xuICB9XG5cbiAgdXBkYXRlR2VvbWV0cnlBdHRyaWJ1dGVzKHBhdGgsIGNvbnRleHQpIHtcbiAgICBpZiAoY29udGV4dC5nZW9tZXRyeVNpemUgPT09IDApIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAocGF0aCAmJiBpc0N1dChwYXRoKSkge1xuICAgICAgZm9yIChjb25zdCBzdWJQYXRoIG9mIHBhdGgpIHtcbiAgICAgICAgY29uc3QgZ2VvbWV0cnlTaXplID0gdGhpcy5nZXRHZW9tZXRyeVNpemUoc3ViUGF0aCk7XG4gICAgICAgIGNvbnRleHQuZ2VvbWV0cnlTaXplID0gZ2VvbWV0cnlTaXplO1xuICAgICAgICB0aGlzLnVwZGF0ZUdlb21ldHJ5QXR0cmlidXRlcyhzdWJQYXRoLCBjb250ZXh0KTtcbiAgICAgICAgY29udGV4dC52ZXJ0ZXhTdGFydCArPSBnZW9tZXRyeVNpemU7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX3VwZGF0ZVNlZ21lbnRUeXBlcyhwYXRoLCBjb250ZXh0KTtcblxuICAgICAgdGhpcy5fdXBkYXRlUG9zaXRpb25zKHBhdGgsIGNvbnRleHQpO1xuICAgIH1cbiAgfVxuXG4gIF91cGRhdGVTZWdtZW50VHlwZXMocGF0aCwgY29udGV4dCkge1xuICAgIGNvbnN0IHNlZ21lbnRUeXBlcyA9IHRoaXMuYXR0cmlidXRlcy5zZWdtZW50VHlwZXM7XG4gICAgY29uc3QgaXNQYXRoQ2xvc2VkID0gcGF0aCA/IHRoaXMuaXNDbG9zZWQocGF0aCkgOiBmYWxzZTtcbiAgICBjb25zdCB7XG4gICAgICB2ZXJ0ZXhTdGFydCxcbiAgICAgIGdlb21ldHJ5U2l6ZVxuICAgIH0gPSBjb250ZXh0O1xuICAgIHNlZ21lbnRUeXBlcy5maWxsKDAsIHZlcnRleFN0YXJ0LCB2ZXJ0ZXhTdGFydCArIGdlb21ldHJ5U2l6ZSk7XG5cbiAgICBpZiAoaXNQYXRoQ2xvc2VkKSB7XG4gICAgICBzZWdtZW50VHlwZXNbdmVydGV4U3RhcnRdID0gSU5WQUxJRDtcbiAgICAgIHNlZ21lbnRUeXBlc1t2ZXJ0ZXhTdGFydCArIGdlb21ldHJ5U2l6ZSAtIDJdID0gSU5WQUxJRDtcbiAgICB9IGVsc2Uge1xuICAgICAgc2VnbWVudFR5cGVzW3ZlcnRleFN0YXJ0XSArPSBTVEFSVF9DQVA7XG4gICAgICBzZWdtZW50VHlwZXNbdmVydGV4U3RhcnQgKyBnZW9tZXRyeVNpemUgLSAyXSArPSBFTkRfQ0FQO1xuICAgIH1cblxuICAgIHNlZ21lbnRUeXBlc1t2ZXJ0ZXhTdGFydCArIGdlb21ldHJ5U2l6ZSAtIDFdID0gSU5WQUxJRDtcbiAgfVxuXG4gIF91cGRhdGVQb3NpdGlvbnMocGF0aCwgY29udGV4dCkge1xuICAgIGNvbnN0IHtcbiAgICAgIHBvc2l0aW9uc1xuICAgIH0gPSB0aGlzLmF0dHJpYnV0ZXM7XG5cbiAgICBpZiAoIXBvc2l0aW9ucyB8fCAhcGF0aCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IHtcbiAgICAgIHZlcnRleFN0YXJ0LFxuICAgICAgZ2VvbWV0cnlTaXplXG4gICAgfSA9IGNvbnRleHQ7XG4gICAgY29uc3QgcCA9IG5ldyBBcnJheSgzKTtcblxuICAgIGZvciAobGV0IGkgPSB2ZXJ0ZXhTdGFydCwgcHRJbmRleCA9IDA7IHB0SW5kZXggPCBnZW9tZXRyeVNpemU7IGkrKywgcHRJbmRleCsrKSB7XG4gICAgICB0aGlzLmdldFBvaW50T25QYXRoKHBhdGgsIHB0SW5kZXgsIHApO1xuICAgICAgcG9zaXRpb25zW2kgKiAzXSA9IHBbMF07XG4gICAgICBwb3NpdGlvbnNbaSAqIDMgKyAxXSA9IHBbMV07XG4gICAgICBwb3NpdGlvbnNbaSAqIDMgKyAyXSA9IHBbMl07XG4gICAgfVxuICB9XG5cbiAgZ2V0UGF0aExlbmd0aChwYXRoKSB7XG4gICAgcmV0dXJuIHBhdGgubGVuZ3RoIC8gdGhpcy5wb3NpdGlvblNpemU7XG4gIH1cblxuICBnZXRQb2ludE9uUGF0aChwYXRoLCBpbmRleCwgdGFyZ2V0ID0gW10pIHtcbiAgICBjb25zdCB7XG4gICAgICBwb3NpdGlvblNpemVcbiAgICB9ID0gdGhpcztcblxuICAgIGlmIChpbmRleCAqIHBvc2l0aW9uU2l6ZSA+PSBwYXRoLmxlbmd0aCkge1xuICAgICAgaW5kZXggKz0gMSAtIHBhdGgubGVuZ3RoIC8gcG9zaXRpb25TaXplO1xuICAgIH1cblxuICAgIGNvbnN0IGkgPSBpbmRleCAqIHBvc2l0aW9uU2l6ZTtcbiAgICB0YXJnZXRbMF0gPSBwYXRoW2ldO1xuICAgIHRhcmdldFsxXSA9IHBhdGhbaSArIDFdO1xuICAgIHRhcmdldFsyXSA9IHBvc2l0aW9uU2l6ZSA9PT0gMyAmJiBwYXRoW2kgKyAyXSB8fCAwO1xuICAgIHJldHVybiB0YXJnZXQ7XG4gIH1cblxuICBpc0Nsb3NlZChwYXRoKSB7XG4gICAgaWYgKCF0aGlzLm5vcm1hbGl6ZSkge1xuICAgICAgcmV0dXJuIEJvb2xlYW4odGhpcy5vcHRzLmxvb3ApO1xuICAgIH1cblxuICAgIGNvbnN0IHtcbiAgICAgIHBvc2l0aW9uU2l6ZVxuICAgIH0gPSB0aGlzO1xuICAgIGNvbnN0IGxhc3RQb2ludEluZGV4ID0gcGF0aC5sZW5ndGggLSBwb3NpdGlvblNpemU7XG4gICAgcmV0dXJuIHBhdGhbMF0gPT09IHBhdGhbbGFzdFBvaW50SW5kZXhdICYmIHBhdGhbMV0gPT09IHBhdGhbbGFzdFBvaW50SW5kZXggKyAxXSAmJiAocG9zaXRpb25TaXplID09PSAyIHx8IHBhdGhbMl0gPT09IHBhdGhbbGFzdFBvaW50SW5kZXggKyAyXSk7XG4gIH1cblxufVxuXG5mdW5jdGlvbiBpc0N1dChwYXRoKSB7XG4gIHJldHVybiBBcnJheS5pc0FycmF5KHBhdGhbMF0pO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cGF0aC10ZXNzZWxhdG9yLmpzLm1hcCIsImV4cG9ydCBkZWZhdWx0IFwiI2RlZmluZSBTSEFERVJfTkFNRSBwYXRoLWxheWVyLXZlcnRleC1zaGFkZXJcXG5cXG5hdHRyaWJ1dGUgdmVjMiBwb3NpdGlvbnM7XFxuXFxuYXR0cmlidXRlIGZsb2F0IGluc3RhbmNlVHlwZXM7XFxuYXR0cmlidXRlIHZlYzMgaW5zdGFuY2VTdGFydFBvc2l0aW9ucztcXG5hdHRyaWJ1dGUgdmVjMyBpbnN0YW5jZUVuZFBvc2l0aW9ucztcXG5hdHRyaWJ1dGUgdmVjMyBpbnN0YW5jZUxlZnRQb3NpdGlvbnM7XFxuYXR0cmlidXRlIHZlYzMgaW5zdGFuY2VSaWdodFBvc2l0aW9ucztcXG5hdHRyaWJ1dGUgdmVjMyBpbnN0YW5jZUxlZnRQb3NpdGlvbnM2NExvdztcXG5hdHRyaWJ1dGUgdmVjMyBpbnN0YW5jZVN0YXJ0UG9zaXRpb25zNjRMb3c7XFxuYXR0cmlidXRlIHZlYzMgaW5zdGFuY2VFbmRQb3NpdGlvbnM2NExvdztcXG5hdHRyaWJ1dGUgdmVjMyBpbnN0YW5jZVJpZ2h0UG9zaXRpb25zNjRMb3c7XFxuYXR0cmlidXRlIGZsb2F0IGluc3RhbmNlU3Ryb2tlV2lkdGhzO1xcbmF0dHJpYnV0ZSB2ZWM0IGluc3RhbmNlQ29sb3JzO1xcbmF0dHJpYnV0ZSB2ZWMzIGluc3RhbmNlUGlja2luZ0NvbG9ycztcXG5cXG51bmlmb3JtIGZsb2F0IHdpZHRoU2NhbGU7XFxudW5pZm9ybSBmbG9hdCB3aWR0aE1pblBpeGVscztcXG51bmlmb3JtIGZsb2F0IHdpZHRoTWF4UGl4ZWxzO1xcbnVuaWZvcm0gZmxvYXQgam9pbnRUeXBlO1xcbnVuaWZvcm0gZmxvYXQgY2FwVHlwZTtcXG51bmlmb3JtIGZsb2F0IG1pdGVyTGltaXQ7XFxudW5pZm9ybSBib29sIGJpbGxib2FyZDtcXG51bmlmb3JtIGludCB3aWR0aFVuaXRzO1xcblxcbnVuaWZvcm0gZmxvYXQgb3BhY2l0eTtcXG5cXG52YXJ5aW5nIHZlYzQgdkNvbG9yO1xcbnZhcnlpbmcgdmVjMiB2Q29ybmVyT2Zmc2V0O1xcbnZhcnlpbmcgZmxvYXQgdk1pdGVyTGVuZ3RoO1xcbnZhcnlpbmcgdmVjMiB2UGF0aFBvc2l0aW9uO1xcbnZhcnlpbmcgZmxvYXQgdlBhdGhMZW5ndGg7XFxudmFyeWluZyBmbG9hdCB2Sm9pbnRUeXBlO1xcblxcbmNvbnN0IGZsb2F0IEVQU0lMT04gPSAwLjAwMTtcXG5jb25zdCB2ZWMzIFpFUk9fT0ZGU0VUID0gdmVjMygwLjApO1xcblxcbmZsb2F0IGZsaXBJZlRydWUoYm9vbCBmbGFnKSB7XFxuICByZXR1cm4gLShmbG9hdChmbGFnKSAqIDIuIC0gMS4pO1xcbn1cXG52ZWMzIGdldExpbmVKb2luT2Zmc2V0KFxcbiAgdmVjMyBwcmV2UG9pbnQsIHZlYzMgY3VyclBvaW50LCB2ZWMzIG5leHRQb2ludCxcXG4gIHZlYzIgd2lkdGhcXG4pIHtcXG4gIGJvb2wgaXNFbmQgPSBwb3NpdGlvbnMueCA+IDAuMDtcXG4gIGZsb2F0IHNpZGVPZlBhdGggPSBwb3NpdGlvbnMueTtcXG4gIGZsb2F0IGlzSm9pbnQgPSBmbG9hdChzaWRlT2ZQYXRoID09IDAuMCk7XFxuXFxuICB2ZWMzIGRlbHRhQTMgPSAoY3VyclBvaW50IC0gcHJldlBvaW50KTtcXG4gIHZlYzMgZGVsdGFCMyA9IChuZXh0UG9pbnQgLSBjdXJyUG9pbnQpO1xcblxcbiAgbWF0MyByb3RhdGlvbk1hdHJpeDtcXG4gIGJvb2wgbmVlZHNSb3RhdGlvbiA9ICFiaWxsYm9hcmQgJiYgcHJvamVjdF9uZWVkc19yb3RhdGlvbihjdXJyUG9pbnQsIHJvdGF0aW9uTWF0cml4KTtcXG4gIGlmIChuZWVkc1JvdGF0aW9uKSB7XFxuICAgIGRlbHRhQTMgPSBkZWx0YUEzICogcm90YXRpb25NYXRyaXg7XFxuICAgIGRlbHRhQjMgPSBkZWx0YUIzICogcm90YXRpb25NYXRyaXg7XFxuICB9XFxuICB2ZWMyIGRlbHRhQSA9IGRlbHRhQTMueHkgLyB3aWR0aDtcXG4gIHZlYzIgZGVsdGFCID0gZGVsdGFCMy54eSAvIHdpZHRoO1xcblxcbiAgZmxvYXQgbGVuQSA9IGxlbmd0aChkZWx0YUEpO1xcbiAgZmxvYXQgbGVuQiA9IGxlbmd0aChkZWx0YUIpO1xcblxcbiAgdmVjMiBkaXJBID0gbGVuQSA+IDAuID8gbm9ybWFsaXplKGRlbHRhQSkgOiB2ZWMyKDAuMCwgMC4wKTtcXG4gIHZlYzIgZGlyQiA9IGxlbkIgPiAwLiA/IG5vcm1hbGl6ZShkZWx0YUIpIDogdmVjMigwLjAsIDAuMCk7XFxuXFxuICB2ZWMyIHBlcnBBID0gdmVjMigtZGlyQS55LCBkaXJBLngpO1xcbiAgdmVjMiBwZXJwQiA9IHZlYzIoLWRpckIueSwgZGlyQi54KTtcXG4gIHZlYzIgdGFuZ2VudCA9IGRpckEgKyBkaXJCO1xcbiAgdGFuZ2VudCA9IGxlbmd0aCh0YW5nZW50KSA+IDAuID8gbm9ybWFsaXplKHRhbmdlbnQpIDogcGVycEE7XFxuICB2ZWMyIG1pdGVyVmVjID0gdmVjMigtdGFuZ2VudC55LCB0YW5nZW50LngpO1xcbiAgdmVjMiBkaXIgPSBpc0VuZCA/IGRpckEgOiBkaXJCO1xcbiAgdmVjMiBwZXJwID0gaXNFbmQgPyBwZXJwQSA6IHBlcnBCO1xcbiAgZmxvYXQgTCA9IGlzRW5kID8gbGVuQSA6IGxlbkI7XFxuICBmbG9hdCBzaW5IYWxmQSA9IGFicyhkb3QobWl0ZXJWZWMsIHBlcnApKTtcXG4gIGZsb2F0IGNvc0hhbGZBID0gYWJzKGRvdChkaXJBLCBtaXRlclZlYykpO1xcbiAgZmxvYXQgdHVybkRpcmVjdGlvbiA9IGZsaXBJZlRydWUoZGlyQS54ICogZGlyQi55ID49IGRpckEueSAqIGRpckIueCk7XFxuICBmbG9hdCBjb3JuZXJQb3NpdGlvbiA9IHNpZGVPZlBhdGggKiB0dXJuRGlyZWN0aW9uO1xcblxcbiAgZmxvYXQgbWl0ZXJTaXplID0gMS4wIC8gbWF4KHNpbkhhbGZBLCBFUFNJTE9OKTtcXG4gIG1pdGVyU2l6ZSA9IG1peChcXG4gICAgbWluKG1pdGVyU2l6ZSwgbWF4KGxlbkEsIGxlbkIpIC8gbWF4KGNvc0hhbGZBLCBFUFNJTE9OKSksXFxuICAgIG1pdGVyU2l6ZSxcXG4gICAgc3RlcCgwLjAsIGNvcm5lclBvc2l0aW9uKVxcbiAgKTtcXG5cXG4gIHZlYzIgb2Zmc2V0VmVjID0gbWl4KG1pdGVyVmVjICogbWl0ZXJTaXplLCBwZXJwLCBzdGVwKDAuNSwgY29ybmVyUG9zaXRpb24pKVxcbiAgICAqIChzaWRlT2ZQYXRoICsgaXNKb2ludCAqIHR1cm5EaXJlY3Rpb24pO1xcbiAgYm9vbCBpc1N0YXJ0Q2FwID0gbGVuQSA9PSAwLjAgfHwgKCFpc0VuZCAmJiAoaW5zdGFuY2VUeXBlcyA9PSAxLjAgfHwgaW5zdGFuY2VUeXBlcyA9PSAzLjApKTtcXG4gIGJvb2wgaXNFbmRDYXAgPSBsZW5CID09IDAuMCB8fCAoaXNFbmQgJiYgKGluc3RhbmNlVHlwZXMgPT0gMi4wIHx8IGluc3RhbmNlVHlwZXMgPT0gMy4wKSk7XFxuICBib29sIGlzQ2FwID0gaXNTdGFydENhcCB8fCBpc0VuZENhcDtcXG4gIGlmIChpc0NhcCkge1xcbiAgICBvZmZzZXRWZWMgPSBtaXgocGVycCAqIHNpZGVPZlBhdGgsIGRpciAqIGNhcFR5cGUgKiA0LjAgKiBmbGlwSWZUcnVlKGlzU3RhcnRDYXApLCBpc0pvaW50KTtcXG4gICAgdkpvaW50VHlwZSA9IGNhcFR5cGU7XFxuICB9IGVsc2Uge1xcbiAgICB2Sm9pbnRUeXBlID0gam9pbnRUeXBlO1xcbiAgfVxcbiAgdlBhdGhMZW5ndGggPSBMO1xcbiAgdkNvcm5lck9mZnNldCA9IG9mZnNldFZlYztcXG4gIHZNaXRlckxlbmd0aCA9IGRvdCh2Q29ybmVyT2Zmc2V0LCBtaXRlclZlYyAqIHR1cm5EaXJlY3Rpb24pO1xcbiAgdk1pdGVyTGVuZ3RoID0gaXNDYXAgPyBpc0pvaW50IDogdk1pdGVyTGVuZ3RoO1xcblxcbiAgdmVjMiBvZmZzZXRGcm9tU3RhcnRPZlBhdGggPSB2Q29ybmVyT2Zmc2V0ICsgZGVsdGFBICogZmxvYXQoaXNFbmQpO1xcbiAgdlBhdGhQb3NpdGlvbiA9IHZlYzIoXFxuICAgIGRvdChvZmZzZXRGcm9tU3RhcnRPZlBhdGgsIHBlcnApLFxcbiAgICBkb3Qob2Zmc2V0RnJvbVN0YXJ0T2ZQYXRoLCBkaXIpXFxuICApO1xcbiAgZ2VvbWV0cnkudXYgPSB2UGF0aFBvc2l0aW9uO1xcblxcbiAgZmxvYXQgaXNWYWxpZCA9IHN0ZXAoaW5zdGFuY2VUeXBlcywgMy41KTtcXG4gIHZlYzMgb2Zmc2V0ID0gdmVjMyhvZmZzZXRWZWMgKiB3aWR0aCAqIGlzVmFsaWQsIDAuMCk7XFxuXFxuICBpZiAobmVlZHNSb3RhdGlvbikge1xcbiAgICBvZmZzZXQgPSByb3RhdGlvbk1hdHJpeCAqIG9mZnNldDtcXG4gIH1cXG4gIHJldHVybiBvZmZzZXQ7XFxufVxcbnZvaWQgY2xpcExpbmUoaW5vdXQgdmVjNCBwb3NpdGlvbiwgdmVjNCByZWZQb3NpdGlvbikge1xcbiAgaWYgKHBvc2l0aW9uLncgPCBFUFNJTE9OKSB7XFxuICAgIGZsb2F0IHIgPSAoRVBTSUxPTiAtIHJlZlBvc2l0aW9uLncpIC8gKHBvc2l0aW9uLncgLSByZWZQb3NpdGlvbi53KTtcXG4gICAgcG9zaXRpb24gPSByZWZQb3NpdGlvbiArIChwb3NpdGlvbiAtIHJlZlBvc2l0aW9uKSAqIHI7XFxuICB9XFxufVxcblxcbnZvaWQgbWFpbigpIHtcXG4gIGdlb21ldHJ5LnBpY2tpbmdDb2xvciA9IGluc3RhbmNlUGlja2luZ0NvbG9ycztcXG5cXG4gIHZDb2xvciA9IHZlYzQoaW5zdGFuY2VDb2xvcnMucmdiLCBpbnN0YW5jZUNvbG9ycy5hICogb3BhY2l0eSk7XFxuXFxuICBmbG9hdCBpc0VuZCA9IHBvc2l0aW9ucy54O1xcblxcbiAgdmVjMyBwcmV2UG9zaXRpb24gPSBtaXgoaW5zdGFuY2VMZWZ0UG9zaXRpb25zLCBpbnN0YW5jZVN0YXJ0UG9zaXRpb25zLCBpc0VuZCk7XFxuICB2ZWMzIHByZXZQb3NpdGlvbjY0TG93ID0gbWl4KGluc3RhbmNlTGVmdFBvc2l0aW9uczY0TG93LCBpbnN0YW5jZVN0YXJ0UG9zaXRpb25zNjRMb3csIGlzRW5kKTtcXG5cXG4gIHZlYzMgY3VyclBvc2l0aW9uID0gbWl4KGluc3RhbmNlU3RhcnRQb3NpdGlvbnMsIGluc3RhbmNlRW5kUG9zaXRpb25zLCBpc0VuZCk7XFxuICB2ZWMzIGN1cnJQb3NpdGlvbjY0TG93ID0gbWl4KGluc3RhbmNlU3RhcnRQb3NpdGlvbnM2NExvdywgaW5zdGFuY2VFbmRQb3NpdGlvbnM2NExvdywgaXNFbmQpO1xcblxcbiAgdmVjMyBuZXh0UG9zaXRpb24gPSBtaXgoaW5zdGFuY2VFbmRQb3NpdGlvbnMsIGluc3RhbmNlUmlnaHRQb3NpdGlvbnMsIGlzRW5kKTtcXG4gIHZlYzMgbmV4dFBvc2l0aW9uNjRMb3cgPSBtaXgoaW5zdGFuY2VFbmRQb3NpdGlvbnM2NExvdywgaW5zdGFuY2VSaWdodFBvc2l0aW9uczY0TG93LCBpc0VuZCk7XFxuXFxuICBnZW9tZXRyeS53b3JsZFBvc2l0aW9uID0gY3VyclBvc2l0aW9uO1xcbiAgdmVjMiB3aWR0aFBpeGVscyA9IHZlYzIoY2xhbXAoXFxuICAgIHByb2plY3Rfc2l6ZV90b19waXhlbChpbnN0YW5jZVN0cm9rZVdpZHRocyAqIHdpZHRoU2NhbGUsIHdpZHRoVW5pdHMpLFxcbiAgICB3aWR0aE1pblBpeGVscywgd2lkdGhNYXhQaXhlbHMpIC8gMi4wKTtcXG4gIHZlYzMgd2lkdGg7XFxuXFxuICBpZiAoYmlsbGJvYXJkKSB7XFxuICAgIHZlYzQgcHJldlBvc2l0aW9uU2NyZWVuID0gcHJvamVjdF9wb3NpdGlvbl90b19jbGlwc3BhY2UocHJldlBvc2l0aW9uLCBwcmV2UG9zaXRpb242NExvdywgWkVST19PRkZTRVQpO1xcbiAgICB2ZWM0IGN1cnJQb3NpdGlvblNjcmVlbiA9IHByb2plY3RfcG9zaXRpb25fdG9fY2xpcHNwYWNlKGN1cnJQb3NpdGlvbiwgY3VyclBvc2l0aW9uNjRMb3csIFpFUk9fT0ZGU0VULCBnZW9tZXRyeS5wb3NpdGlvbik7XFxuICAgIHZlYzQgbmV4dFBvc2l0aW9uU2NyZWVuID0gcHJvamVjdF9wb3NpdGlvbl90b19jbGlwc3BhY2UobmV4dFBvc2l0aW9uLCBuZXh0UG9zaXRpb242NExvdywgWkVST19PRkZTRVQpO1xcblxcbiAgICBjbGlwTGluZShwcmV2UG9zaXRpb25TY3JlZW4sIGN1cnJQb3NpdGlvblNjcmVlbik7XFxuICAgIGNsaXBMaW5lKG5leHRQb3NpdGlvblNjcmVlbiwgY3VyclBvc2l0aW9uU2NyZWVuKTtcXG4gICAgY2xpcExpbmUoY3VyclBvc2l0aW9uU2NyZWVuLCBtaXgobmV4dFBvc2l0aW9uU2NyZWVuLCBwcmV2UG9zaXRpb25TY3JlZW4sIGlzRW5kKSk7XFxuXFxuICAgIHdpZHRoID0gdmVjMyh3aWR0aFBpeGVscywgMC4wKTtcXG4gICAgREVDS0dMX0ZJTFRFUl9TSVpFKHdpZHRoLCBnZW9tZXRyeSk7XFxuXFxuICAgIHZlYzMgb2Zmc2V0ID0gZ2V0TGluZUpvaW5PZmZzZXQoXFxuICAgICAgcHJldlBvc2l0aW9uU2NyZWVuLnh5eiAvIHByZXZQb3NpdGlvblNjcmVlbi53LFxcbiAgICAgIGN1cnJQb3NpdGlvblNjcmVlbi54eXogLyBjdXJyUG9zaXRpb25TY3JlZW4udyxcXG4gICAgICBuZXh0UG9zaXRpb25TY3JlZW4ueHl6IC8gbmV4dFBvc2l0aW9uU2NyZWVuLncsXFxuICAgICAgcHJvamVjdF9waXhlbF9zaXplX3RvX2NsaXBzcGFjZSh3aWR0aC54eSlcXG4gICAgKTtcXG5cXG4gICAgREVDS0dMX0ZJTFRFUl9HTF9QT1NJVElPTihjdXJyUG9zaXRpb25TY3JlZW4sIGdlb21ldHJ5KTtcXG4gICAgZ2xfUG9zaXRpb24gPSB2ZWM0KGN1cnJQb3NpdGlvblNjcmVlbi54eXogKyBvZmZzZXQgKiBjdXJyUG9zaXRpb25TY3JlZW4udywgY3VyclBvc2l0aW9uU2NyZWVuLncpO1xcbiAgfSBlbHNlIHtcXG4gICAgcHJldlBvc2l0aW9uID0gcHJvamVjdF9wb3NpdGlvbihwcmV2UG9zaXRpb24sIHByZXZQb3NpdGlvbjY0TG93KTtcXG4gICAgY3VyclBvc2l0aW9uID0gcHJvamVjdF9wb3NpdGlvbihjdXJyUG9zaXRpb24sIGN1cnJQb3NpdGlvbjY0TG93KTtcXG4gICAgbmV4dFBvc2l0aW9uID0gcHJvamVjdF9wb3NpdGlvbihuZXh0UG9zaXRpb24sIG5leHRQb3NpdGlvbjY0TG93KTtcXG5cXG4gICAgd2lkdGggPSB2ZWMzKHByb2plY3RfcGl4ZWxfc2l6ZSh3aWR0aFBpeGVscyksIDAuMCk7XFxuICAgIERFQ0tHTF9GSUxURVJfU0laRSh3aWR0aCwgZ2VvbWV0cnkpO1xcblxcbiAgICB2ZWMzIG9mZnNldCA9IGdldExpbmVKb2luT2Zmc2V0KHByZXZQb3NpdGlvbiwgY3VyclBvc2l0aW9uLCBuZXh0UG9zaXRpb24sIHdpZHRoLnh5KTtcXG4gICAgZ2VvbWV0cnkucG9zaXRpb24gPSB2ZWM0KGN1cnJQb3NpdGlvbiArIG9mZnNldCwgMS4wKTtcXG4gICAgZ2xfUG9zaXRpb24gPSBwcm9qZWN0X2NvbW1vbl9wb3NpdGlvbl90b19jbGlwc3BhY2UoZ2VvbWV0cnkucG9zaXRpb24pO1xcbiAgICBERUNLR0xfRklMVEVSX0dMX1BPU0lUSU9OKGdsX1Bvc2l0aW9uLCBnZW9tZXRyeSk7XFxuICB9XFxuICBERUNLR0xfRklMVEVSX0NPTE9SKHZDb2xvciwgZ2VvbWV0cnkpO1xcbn1cXG5cIjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXBhdGgtbGF5ZXItdmVydGV4Lmdsc2wuanMubWFwIiwiZXhwb3J0IGRlZmF1bHQgXCIjZGVmaW5lIFNIQURFUl9OQU1FIHBhdGgtbGF5ZXItZnJhZ21lbnQtc2hhZGVyXFxuXFxucHJlY2lzaW9uIGhpZ2hwIGZsb2F0O1xcblxcbnVuaWZvcm0gZmxvYXQgbWl0ZXJMaW1pdDtcXG5cXG52YXJ5aW5nIHZlYzQgdkNvbG9yO1xcbnZhcnlpbmcgdmVjMiB2Q29ybmVyT2Zmc2V0O1xcbnZhcnlpbmcgZmxvYXQgdk1pdGVyTGVuZ3RoO1xcbnZhcnlpbmcgdmVjMiB2UGF0aFBvc2l0aW9uO1xcbnZhcnlpbmcgZmxvYXQgdlBhdGhMZW5ndGg7XFxudmFyeWluZyBmbG9hdCB2Sm9pbnRUeXBlO1xcblxcbnZvaWQgbWFpbih2b2lkKSB7XFxuICBnZW9tZXRyeS51diA9IHZQYXRoUG9zaXRpb247XFxuXFxuICBpZiAodlBhdGhQb3NpdGlvbi55IDwgMC4wIHx8IHZQYXRoUG9zaXRpb24ueSA+IHZQYXRoTGVuZ3RoKSB7XFxuICAgIGlmICh2Sm9pbnRUeXBlID4gMC41ICYmIGxlbmd0aCh2Q29ybmVyT2Zmc2V0KSA+IDEuMCkge1xcbiAgICAgIGRpc2NhcmQ7XFxuICAgIH1cXG4gICAgaWYgKHZKb2ludFR5cGUgPCAwLjUgJiYgdk1pdGVyTGVuZ3RoID4gbWl0ZXJMaW1pdCArIDEuMCkge1xcbiAgICAgIGRpc2NhcmQ7XFxuICAgIH1cXG4gIH1cXG4gIGdsX0ZyYWdDb2xvciA9IHZDb2xvcjtcXG5cXG4gIERFQ0tHTF9GSUxURVJfQ09MT1IoZ2xfRnJhZ0NvbG9yLCBnZW9tZXRyeSk7XFxufVxcblwiO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cGF0aC1sYXllci1mcmFnbWVudC5nbHNsLmpzLm1hcCIsImltcG9ydCBfZGVmaW5lUHJvcGVydHkgZnJvbSBcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL2RlZmluZVByb3BlcnR5XCI7XG5pbXBvcnQgeyBMYXllciwgcHJvamVjdDMyLCBwaWNraW5nLCBVTklUIH0gZnJvbSAnQGRlY2suZ2wvY29yZSc7XG5pbXBvcnQgeyBNb2RlbCwgR2VvbWV0cnkgfSBmcm9tICdAbHVtYS5nbC9jb3JlJztcbmltcG9ydCBQYXRoVGVzc2VsYXRvciBmcm9tICcuL3BhdGgtdGVzc2VsYXRvcic7XG5pbXBvcnQgdnMgZnJvbSAnLi9wYXRoLWxheWVyLXZlcnRleC5nbHNsJztcbmltcG9ydCBmcyBmcm9tICcuL3BhdGgtbGF5ZXItZnJhZ21lbnQuZ2xzbCc7XG5jb25zdCBERUZBVUxUX0NPTE9SID0gWzAsIDAsIDAsIDI1NV07XG5jb25zdCBkZWZhdWx0UHJvcHMgPSB7XG4gIHdpZHRoVW5pdHM6ICdtZXRlcnMnLFxuICB3aWR0aFNjYWxlOiB7XG4gICAgdHlwZTogJ251bWJlcicsXG4gICAgbWluOiAwLFxuICAgIHZhbHVlOiAxXG4gIH0sXG4gIHdpZHRoTWluUGl4ZWxzOiB7XG4gICAgdHlwZTogJ251bWJlcicsXG4gICAgbWluOiAwLFxuICAgIHZhbHVlOiAwXG4gIH0sXG4gIHdpZHRoTWF4UGl4ZWxzOiB7XG4gICAgdHlwZTogJ251bWJlcicsXG4gICAgbWluOiAwLFxuICAgIHZhbHVlOiBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUlxuICB9LFxuICBqb2ludFJvdW5kZWQ6IGZhbHNlLFxuICBjYXBSb3VuZGVkOiBmYWxzZSxcbiAgbWl0ZXJMaW1pdDoge1xuICAgIHR5cGU6ICdudW1iZXInLFxuICAgIG1pbjogMCxcbiAgICB2YWx1ZTogNFxuICB9LFxuICBiaWxsYm9hcmQ6IGZhbHNlLFxuICBfcGF0aFR5cGU6IG51bGwsXG4gIGdldFBhdGg6IHtcbiAgICB0eXBlOiAnYWNjZXNzb3InLFxuICAgIHZhbHVlOiBvYmplY3QgPT4gb2JqZWN0LnBhdGhcbiAgfSxcbiAgZ2V0Q29sb3I6IHtcbiAgICB0eXBlOiAnYWNjZXNzb3InLFxuICAgIHZhbHVlOiBERUZBVUxUX0NPTE9SXG4gIH0sXG4gIGdldFdpZHRoOiB7XG4gICAgdHlwZTogJ2FjY2Vzc29yJyxcbiAgICB2YWx1ZTogMVxuICB9LFxuICByb3VuZGVkOiB7XG4gICAgZGVwcmVjYXRlZEZvcjogWydqb2ludFJvdW5kZWQnLCAnY2FwUm91bmRlZCddXG4gIH1cbn07XG5jb25zdCBBVFRSSUJVVEVfVFJBTlNJVElPTiA9IHtcbiAgZW50ZXI6ICh2YWx1ZSwgY2h1bmspID0+IHtcbiAgICByZXR1cm4gY2h1bmsubGVuZ3RoID8gY2h1bmsuc3ViYXJyYXkoY2h1bmsubGVuZ3RoIC0gdmFsdWUubGVuZ3RoKSA6IHZhbHVlO1xuICB9XG59O1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgUGF0aExheWVyIGV4dGVuZHMgTGF5ZXIge1xuICBjb25zdHJ1Y3RvciguLi5hcmdzKSB7XG4gICAgc3VwZXIoLi4uYXJncyk7XG5cbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJzdGF0ZVwiLCB2b2lkIDApO1xuICB9XG5cbiAgZ2V0U2hhZGVycygpIHtcbiAgICByZXR1cm4gc3VwZXIuZ2V0U2hhZGVycyh7XG4gICAgICB2cyxcbiAgICAgIGZzLFxuICAgICAgbW9kdWxlczogW3Byb2plY3QzMiwgcGlja2luZ11cbiAgICB9KTtcbiAgfVxuXG4gIGdldCB3cmFwTG9uZ2l0dWRlKCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGluaXRpYWxpemVTdGF0ZSgpIHtcbiAgICBjb25zdCBub0FsbG9jID0gdHJ1ZTtcbiAgICBjb25zdCBhdHRyaWJ1dGVNYW5hZ2VyID0gdGhpcy5nZXRBdHRyaWJ1dGVNYW5hZ2VyKCk7XG4gICAgYXR0cmlidXRlTWFuYWdlci5hZGRJbnN0YW5jZWQoe1xuICAgICAgcG9zaXRpb25zOiB7XG4gICAgICAgIHNpemU6IDMsXG4gICAgICAgIHZlcnRleE9mZnNldDogMSxcbiAgICAgICAgdHlwZTogNTEzMCxcbiAgICAgICAgZnA2NDogdGhpcy51c2U2NGJpdFBvc2l0aW9ucygpLFxuICAgICAgICB0cmFuc2l0aW9uOiBBVFRSSUJVVEVfVFJBTlNJVElPTixcbiAgICAgICAgYWNjZXNzb3I6ICdnZXRQYXRoJyxcbiAgICAgICAgdXBkYXRlOiB0aGlzLmNhbGN1bGF0ZVBvc2l0aW9ucyxcbiAgICAgICAgbm9BbGxvYyxcbiAgICAgICAgc2hhZGVyQXR0cmlidXRlczoge1xuICAgICAgICAgIGluc3RhbmNlTGVmdFBvc2l0aW9uczoge1xuICAgICAgICAgICAgdmVydGV4T2Zmc2V0OiAwXG4gICAgICAgICAgfSxcbiAgICAgICAgICBpbnN0YW5jZVN0YXJ0UG9zaXRpb25zOiB7XG4gICAgICAgICAgICB2ZXJ0ZXhPZmZzZXQ6IDFcbiAgICAgICAgICB9LFxuICAgICAgICAgIGluc3RhbmNlRW5kUG9zaXRpb25zOiB7XG4gICAgICAgICAgICB2ZXJ0ZXhPZmZzZXQ6IDJcbiAgICAgICAgICB9LFxuICAgICAgICAgIGluc3RhbmNlUmlnaHRQb3NpdGlvbnM6IHtcbiAgICAgICAgICAgIHZlcnRleE9mZnNldDogM1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIGluc3RhbmNlVHlwZXM6IHtcbiAgICAgICAgc2l6ZTogMSxcbiAgICAgICAgdHlwZTogNTEyMSxcbiAgICAgICAgdXBkYXRlOiB0aGlzLmNhbGN1bGF0ZVNlZ21lbnRUeXBlcyxcbiAgICAgICAgbm9BbGxvY1xuICAgICAgfSxcbiAgICAgIGluc3RhbmNlU3Ryb2tlV2lkdGhzOiB7XG4gICAgICAgIHNpemU6IDEsXG4gICAgICAgIGFjY2Vzc29yOiAnZ2V0V2lkdGgnLFxuICAgICAgICB0cmFuc2l0aW9uOiBBVFRSSUJVVEVfVFJBTlNJVElPTixcbiAgICAgICAgZGVmYXVsdFZhbHVlOiAxXG4gICAgICB9LFxuICAgICAgaW5zdGFuY2VDb2xvcnM6IHtcbiAgICAgICAgc2l6ZTogdGhpcy5wcm9wcy5jb2xvckZvcm1hdC5sZW5ndGgsXG4gICAgICAgIHR5cGU6IDUxMjEsXG4gICAgICAgIG5vcm1hbGl6ZWQ6IHRydWUsXG4gICAgICAgIGFjY2Vzc29yOiAnZ2V0Q29sb3InLFxuICAgICAgICB0cmFuc2l0aW9uOiBBVFRSSUJVVEVfVFJBTlNJVElPTixcbiAgICAgICAgZGVmYXVsdFZhbHVlOiBERUZBVUxUX0NPTE9SXG4gICAgICB9LFxuICAgICAgaW5zdGFuY2VQaWNraW5nQ29sb3JzOiB7XG4gICAgICAgIHNpemU6IDMsXG4gICAgICAgIHR5cGU6IDUxMjEsXG4gICAgICAgIGFjY2Vzc29yOiAob2JqZWN0LCB7XG4gICAgICAgICAgaW5kZXgsXG4gICAgICAgICAgdGFyZ2V0OiB2YWx1ZVxuICAgICAgICB9KSA9PiB0aGlzLmVuY29kZVBpY2tpbmdDb2xvcihvYmplY3QgJiYgb2JqZWN0Ll9fc291cmNlID8gb2JqZWN0Ll9fc291cmNlLmluZGV4IDogaW5kZXgsIHZhbHVlKVxuICAgICAgfVxuICAgIH0pO1xuICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgICAgcGF0aFRlc3NlbGF0b3I6IG5ldyBQYXRoVGVzc2VsYXRvcih7XG4gICAgICAgIGZwNjQ6IHRoaXMudXNlNjRiaXRQb3NpdGlvbnMoKVxuICAgICAgfSlcbiAgICB9KTtcbiAgfVxuXG4gIHVwZGF0ZVN0YXRlKHBhcmFtcykge1xuICAgIHN1cGVyLnVwZGF0ZVN0YXRlKHBhcmFtcyk7XG4gICAgY29uc3Qge1xuICAgICAgcHJvcHMsXG4gICAgICBjaGFuZ2VGbGFnc1xuICAgIH0gPSBwYXJhbXM7XG4gICAgY29uc3QgYXR0cmlidXRlTWFuYWdlciA9IHRoaXMuZ2V0QXR0cmlidXRlTWFuYWdlcigpO1xuICAgIGNvbnN0IGdlb21ldHJ5Q2hhbmdlZCA9IGNoYW5nZUZsYWdzLmRhdGFDaGFuZ2VkIHx8IGNoYW5nZUZsYWdzLnVwZGF0ZVRyaWdnZXJzQ2hhbmdlZCAmJiAoY2hhbmdlRmxhZ3MudXBkYXRlVHJpZ2dlcnNDaGFuZ2VkLmFsbCB8fCBjaGFuZ2VGbGFncy51cGRhdGVUcmlnZ2Vyc0NoYW5nZWQuZ2V0UGF0aCk7XG5cbiAgICBpZiAoZ2VvbWV0cnlDaGFuZ2VkKSB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIHBhdGhUZXNzZWxhdG9yXG4gICAgICB9ID0gdGhpcy5zdGF0ZTtcbiAgICAgIGNvbnN0IGJ1ZmZlcnMgPSBwcm9wcy5kYXRhLmF0dHJpYnV0ZXMgfHwge307XG4gICAgICBwYXRoVGVzc2VsYXRvci51cGRhdGVHZW9tZXRyeSh7XG4gICAgICAgIGRhdGE6IHByb3BzLmRhdGEsXG4gICAgICAgIGdlb21ldHJ5QnVmZmVyOiBidWZmZXJzLmdldFBhdGgsXG4gICAgICAgIGJ1ZmZlcnMsXG4gICAgICAgIG5vcm1hbGl6ZTogIXByb3BzLl9wYXRoVHlwZSxcbiAgICAgICAgbG9vcDogcHJvcHMuX3BhdGhUeXBlID09PSAnbG9vcCcsXG4gICAgICAgIGdldEdlb21ldHJ5OiBwcm9wcy5nZXRQYXRoLFxuICAgICAgICBwb3NpdGlvbkZvcm1hdDogcHJvcHMucG9zaXRpb25Gb3JtYXQsXG4gICAgICAgIHdyYXBMb25naXR1ZGU6IHByb3BzLndyYXBMb25naXR1ZGUsXG4gICAgICAgIHJlc29sdXRpb246IHRoaXMuY29udGV4dC52aWV3cG9ydC5yZXNvbHV0aW9uLFxuICAgICAgICBkYXRhQ2hhbmdlZDogY2hhbmdlRmxhZ3MuZGF0YUNoYW5nZWRcbiAgICAgIH0pO1xuICAgICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICAgIG51bUluc3RhbmNlczogcGF0aFRlc3NlbGF0b3IuaW5zdGFuY2VDb3VudCxcbiAgICAgICAgc3RhcnRJbmRpY2VzOiBwYXRoVGVzc2VsYXRvci52ZXJ0ZXhTdGFydHNcbiAgICAgIH0pO1xuXG4gICAgICBpZiAoIWNoYW5nZUZsYWdzLmRhdGFDaGFuZ2VkKSB7XG4gICAgICAgIGF0dHJpYnV0ZU1hbmFnZXIuaW52YWxpZGF0ZUFsbCgpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChjaGFuZ2VGbGFncy5leHRlbnNpb25zQ2hhbmdlZCkge1xuICAgICAgdmFyIF90aGlzJHN0YXRlJG1vZGVsO1xuXG4gICAgICBjb25zdCB7XG4gICAgICAgIGdsXG4gICAgICB9ID0gdGhpcy5jb250ZXh0O1xuICAgICAgKF90aGlzJHN0YXRlJG1vZGVsID0gdGhpcy5zdGF0ZS5tb2RlbCkgPT09IG51bGwgfHwgX3RoaXMkc3RhdGUkbW9kZWwgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF90aGlzJHN0YXRlJG1vZGVsLmRlbGV0ZSgpO1xuICAgICAgdGhpcy5zdGF0ZS5tb2RlbCA9IHRoaXMuX2dldE1vZGVsKGdsKTtcbiAgICAgIGF0dHJpYnV0ZU1hbmFnZXIuaW52YWxpZGF0ZUFsbCgpO1xuICAgIH1cbiAgfVxuXG4gIGdldFBpY2tpbmdJbmZvKHBhcmFtcykge1xuICAgIGNvbnN0IGluZm8gPSBzdXBlci5nZXRQaWNraW5nSW5mbyhwYXJhbXMpO1xuICAgIGNvbnN0IHtcbiAgICAgIGluZGV4XG4gICAgfSA9IGluZm87XG4gICAgY29uc3Qge1xuICAgICAgZGF0YVxuICAgIH0gPSB0aGlzLnByb3BzO1xuXG4gICAgaWYgKGRhdGFbMF0gJiYgZGF0YVswXS5fX3NvdXJjZSkge1xuICAgICAgaW5mby5vYmplY3QgPSBkYXRhLmZpbmQoZCA9PiBkLl9fc291cmNlLmluZGV4ID09PSBpbmRleCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGluZm87XG4gIH1cblxuICBkaXNhYmxlUGlja2luZ0luZGV4KG9iamVjdEluZGV4KSB7XG4gICAgY29uc3Qge1xuICAgICAgZGF0YVxuICAgIH0gPSB0aGlzLnByb3BzO1xuXG4gICAgaWYgKGRhdGFbMF0gJiYgZGF0YVswXS5fX3NvdXJjZSkge1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBkYXRhLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmIChkYXRhW2ldLl9fc291cmNlLmluZGV4ID09PSBvYmplY3RJbmRleCkge1xuICAgICAgICAgIHRoaXMuX2Rpc2FibGVQaWNraW5nSW5kZXgoaSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5fZGlzYWJsZVBpY2tpbmdJbmRleChvYmplY3RJbmRleCk7XG4gICAgfVxuICB9XG5cbiAgZHJhdyh7XG4gICAgdW5pZm9ybXNcbiAgfSkge1xuICAgIGNvbnN0IHtcbiAgICAgIGpvaW50Um91bmRlZCxcbiAgICAgIGNhcFJvdW5kZWQsXG4gICAgICBiaWxsYm9hcmQsXG4gICAgICBtaXRlckxpbWl0LFxuICAgICAgd2lkdGhVbml0cyxcbiAgICAgIHdpZHRoU2NhbGUsXG4gICAgICB3aWR0aE1pblBpeGVscyxcbiAgICAgIHdpZHRoTWF4UGl4ZWxzXG4gICAgfSA9IHRoaXMucHJvcHM7XG4gICAgdGhpcy5zdGF0ZS5tb2RlbC5zZXRVbmlmb3Jtcyh1bmlmb3Jtcykuc2V0VW5pZm9ybXMoe1xuICAgICAgam9pbnRUeXBlOiBOdW1iZXIoam9pbnRSb3VuZGVkKSxcbiAgICAgIGNhcFR5cGU6IE51bWJlcihjYXBSb3VuZGVkKSxcbiAgICAgIGJpbGxib2FyZCxcbiAgICAgIHdpZHRoVW5pdHM6IFVOSVRbd2lkdGhVbml0c10sXG4gICAgICB3aWR0aFNjYWxlLFxuICAgICAgbWl0ZXJMaW1pdCxcbiAgICAgIHdpZHRoTWluUGl4ZWxzLFxuICAgICAgd2lkdGhNYXhQaXhlbHNcbiAgICB9KS5kcmF3KCk7XG4gIH1cblxuICBfZ2V0TW9kZWwoZ2wpIHtcbiAgICBjb25zdCBTRUdNRU5UX0lORElDRVMgPSBbMCwgMSwgMiwgMSwgNCwgMiwgMSwgMywgNCwgMywgNSwgNF07XG4gICAgY29uc3QgU0VHTUVOVF9QT1NJVElPTlMgPSBbMCwgMCwgMCwgLTEsIDAsIDEsIDEsIC0xLCAxLCAxLCAxLCAwXTtcbiAgICByZXR1cm4gbmV3IE1vZGVsKGdsLCB7IC4uLnRoaXMuZ2V0U2hhZGVycygpLFxuICAgICAgaWQ6IHRoaXMucHJvcHMuaWQsXG4gICAgICBnZW9tZXRyeTogbmV3IEdlb21ldHJ5KHtcbiAgICAgICAgZHJhd01vZGU6IDQsXG4gICAgICAgIGF0dHJpYnV0ZXM6IHtcbiAgICAgICAgICBpbmRpY2VzOiBuZXcgVWludDE2QXJyYXkoU0VHTUVOVF9JTkRJQ0VTKSxcbiAgICAgICAgICBwb3NpdGlvbnM6IHtcbiAgICAgICAgICAgIHZhbHVlOiBuZXcgRmxvYXQzMkFycmF5KFNFR01FTlRfUE9TSVRJT05TKSxcbiAgICAgICAgICAgIHNpemU6IDJcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pLFxuICAgICAgaXNJbnN0YW5jZWQ6IHRydWVcbiAgICB9KTtcbiAgfVxuXG4gIGNhbGN1bGF0ZVBvc2l0aW9ucyhhdHRyaWJ1dGUpIHtcbiAgICBjb25zdCB7XG4gICAgICBwYXRoVGVzc2VsYXRvclxuICAgIH0gPSB0aGlzLnN0YXRlO1xuICAgIGF0dHJpYnV0ZS5zdGFydEluZGljZXMgPSBwYXRoVGVzc2VsYXRvci52ZXJ0ZXhTdGFydHM7XG4gICAgYXR0cmlidXRlLnZhbHVlID0gcGF0aFRlc3NlbGF0b3IuZ2V0KCdwb3NpdGlvbnMnKTtcbiAgfVxuXG4gIGNhbGN1bGF0ZVNlZ21lbnRUeXBlcyhhdHRyaWJ1dGUpIHtcbiAgICBjb25zdCB7XG4gICAgICBwYXRoVGVzc2VsYXRvclxuICAgIH0gPSB0aGlzLnN0YXRlO1xuICAgIGF0dHJpYnV0ZS5zdGFydEluZGljZXMgPSBwYXRoVGVzc2VsYXRvci52ZXJ0ZXhTdGFydHM7XG4gICAgYXR0cmlidXRlLnZhbHVlID0gcGF0aFRlc3NlbGF0b3IuZ2V0KCdzZWdtZW50VHlwZXMnKTtcbiAgfVxuXG59XG5cbl9kZWZpbmVQcm9wZXJ0eShQYXRoTGF5ZXIsIFwiZGVmYXVsdFByb3BzXCIsIGRlZmF1bHRQcm9wcyk7XG5cbl9kZWZpbmVQcm9wZXJ0eShQYXRoTGF5ZXIsIFwibGF5ZXJOYW1lXCIsICdQYXRoTGF5ZXInKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXBhdGgtbGF5ZXIuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///41990\n")},33121:function(__unused_webpack_module,__webpack_exports__,__webpack_require__){eval("/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Z\": function() { return /* binding */ PolygonLayer; }\n/* harmony export */ });\n/* harmony import */ var _babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(82482);\n/* harmony import */ var _deck_gl_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(78918);\n/* harmony import */ var _deck_gl_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(80744);\n/* harmony import */ var _deck_gl_core__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(38550);\n/* harmony import */ var _solid_polygon_layer_solid_polygon_layer__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(56923);\n/* harmony import */ var _path_layer_path_layer__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(41990);\n/* harmony import */ var _solid_polygon_layer_polygon__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(99890);\n/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(98452);\n\n\n\n\n\n\nconst defaultLineColor = [0, 0, 0, 255];\nconst defaultFillColor = [0, 0, 0, 255];\nconst defaultProps = {\n  stroked: true,\n  filled: true,\n  extruded: false,\n  elevationScale: 1,\n  wireframe: false,\n  _normalize: true,\n  _windingOrder: 'CW',\n  lineWidthUnits: 'meters',\n  lineWidthScale: 1,\n  lineWidthMinPixels: 0,\n  lineWidthMaxPixels: Number.MAX_SAFE_INTEGER,\n  lineJointRounded: false,\n  lineMiterLimit: 4,\n  getPolygon: {\n    type: 'accessor',\n    value: f => f.polygon\n  },\n  getFillColor: {\n    type: 'accessor',\n    value: defaultFillColor\n  },\n  getLineColor: {\n    type: 'accessor',\n    value: defaultLineColor\n  },\n  getLineWidth: {\n    type: 'accessor',\n    value: 1\n  },\n  getElevation: {\n    type: 'accessor',\n    value: 1000\n  },\n  material: true\n};\nclass PolygonLayer extends _deck_gl_core__WEBPACK_IMPORTED_MODULE_0__/* [\"default\"] */ .Z {\n  initializeState() {\n    this.state = {\n      paths: []\n    };\n\n    if (this.props.getLineDashArray) {\n      _deck_gl_core__WEBPACK_IMPORTED_MODULE_1__/* [\"default\"].removed */ .Z.removed('getLineDashArray', 'PathStyleExtension')();\n    }\n  }\n\n  updateState({\n    changeFlags\n  }) {\n    const geometryChanged = changeFlags.dataChanged || changeFlags.updateTriggersChanged && (changeFlags.updateTriggersChanged.all || changeFlags.updateTriggersChanged.getPolygon);\n\n    if (geometryChanged && Array.isArray(changeFlags.dataChanged)) {\n      const paths = this.state.paths.slice();\n      const pathsDiff = changeFlags.dataChanged.map(dataRange => (0,_utils__WEBPACK_IMPORTED_MODULE_2__/* .replaceInRange */ .b)({\n        data: paths,\n        getIndex: p => p.__source.index,\n        dataRange,\n        replace: this._getPaths(dataRange)\n      }));\n      this.setState({\n        paths,\n        pathsDiff\n      });\n    } else if (geometryChanged) {\n      this.setState({\n        paths: this._getPaths(),\n        pathsDiff: null\n      });\n    }\n  }\n\n  _getPaths(dataRange = {}) {\n    const {\n      data,\n      getPolygon,\n      positionFormat,\n      _normalize\n    } = this.props;\n    const paths = [];\n    const positionSize = positionFormat === 'XY' ? 2 : 3;\n    const {\n      startRow,\n      endRow\n    } = dataRange;\n    const {\n      iterable,\n      objectInfo\n    } = (0,_deck_gl_core__WEBPACK_IMPORTED_MODULE_3__/* .createIterable */ .jB)(data, startRow, endRow);\n\n    for (const object of iterable) {\n      objectInfo.index++;\n      let polygon = getPolygon(object, objectInfo);\n\n      if (_normalize) {\n        polygon = _solid_polygon_layer_polygon__WEBPACK_IMPORTED_MODULE_4__/* .normalize */ .Fv(polygon, positionSize);\n      }\n\n      const {\n        holeIndices\n      } = polygon;\n      const positions = polygon.positions || polygon;\n\n      if (holeIndices) {\n        for (let i = 0; i <= holeIndices.length; i++) {\n          const path = positions.slice(holeIndices[i - 1] || 0, holeIndices[i] || positions.length);\n          paths.push(this.getSubLayerRow({\n            path\n          }, object, objectInfo.index));\n        }\n      } else {\n        paths.push(this.getSubLayerRow({\n          path: positions\n        }, object, objectInfo.index));\n      }\n    }\n\n    return paths;\n  }\n\n  renderLayers() {\n    const {\n      data,\n      _dataDiff,\n      stroked,\n      filled,\n      extruded,\n      wireframe,\n      _normalize,\n      _windingOrder,\n      elevationScale,\n      transitions,\n      positionFormat\n    } = this.props;\n    const {\n      lineWidthUnits,\n      lineWidthScale,\n      lineWidthMinPixels,\n      lineWidthMaxPixels,\n      lineJointRounded,\n      lineMiterLimit,\n      lineDashJustified\n    } = this.props;\n    const {\n      getFillColor,\n      getLineColor,\n      getLineWidth,\n      getLineDashArray,\n      getElevation,\n      getPolygon,\n      updateTriggers,\n      material\n    } = this.props;\n    const {\n      paths,\n      pathsDiff\n    } = this.state;\n    const FillLayer = this.getSubLayerClass('fill', _solid_polygon_layer_solid_polygon_layer__WEBPACK_IMPORTED_MODULE_5__/* [\"default\"] */ .Z);\n    const StrokeLayer = this.getSubLayerClass('stroke', _path_layer_path_layer__WEBPACK_IMPORTED_MODULE_6__/* [\"default\"] */ .Z);\n    const polygonLayer = this.shouldRenderSubLayer('fill', paths) && new FillLayer({\n      _dataDiff,\n      extruded,\n      elevationScale,\n      filled,\n      wireframe,\n      _normalize,\n      _windingOrder,\n      getElevation,\n      getFillColor,\n      getLineColor: extruded && wireframe ? getLineColor : defaultLineColor,\n      material,\n      transitions\n    }, this.getSubLayerProps({\n      id: 'fill',\n      updateTriggers: updateTriggers && {\n        getPolygon: updateTriggers.getPolygon,\n        getElevation: updateTriggers.getElevation,\n        getFillColor: updateTriggers.getFillColor,\n        lineColors: extruded && wireframe,\n        getLineColor: updateTriggers.getLineColor\n      }\n    }), {\n      data,\n      positionFormat,\n      getPolygon\n    });\n    const polygonLineLayer = !extruded && stroked && this.shouldRenderSubLayer('stroke', paths) && new StrokeLayer({\n      _dataDiff: pathsDiff && (() => pathsDiff),\n      widthUnits: lineWidthUnits,\n      widthScale: lineWidthScale,\n      widthMinPixels: lineWidthMinPixels,\n      widthMaxPixels: lineWidthMaxPixels,\n      jointRounded: lineJointRounded,\n      miterLimit: lineMiterLimit,\n      dashJustified: lineDashJustified,\n      _pathType: 'loop',\n      transitions: transitions && {\n        getWidth: transitions.getLineWidth,\n        getColor: transitions.getLineColor,\n        getPath: transitions.getPolygon\n      },\n      getColor: this.getSubLayerAccessor(getLineColor),\n      getWidth: this.getSubLayerAccessor(getLineWidth),\n      getDashArray: this.getSubLayerAccessor(getLineDashArray)\n    }, this.getSubLayerProps({\n      id: 'stroke',\n      updateTriggers: updateTriggers && {\n        getWidth: updateTriggers.getLineWidth,\n        getColor: updateTriggers.getLineColor,\n        getDashArray: updateTriggers.getLineDashArray\n      }\n    }), {\n      data: paths,\n      positionFormat,\n      getPath: x => x.path\n    });\n    return [!extruded && polygonLayer, polygonLineLayer, extruded && polygonLayer];\n  }\n\n}\n\n(0,_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_7__/* [\"default\"] */ .Z)(PolygonLayer, \"layerName\", 'PolygonLayer');\n\n(0,_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_7__/* [\"default\"] */ .Z)(PolygonLayer, \"defaultProps\", defaultProps);\n//# sourceMappingURL=polygon-layer.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMzMxMjEuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7QUFBd0U7QUFDSjtBQUNPO0FBQzFCO0FBQ1M7QUFDaEI7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDZSwyQkFBMkIsOERBQWM7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxNQUFNLDhFQUFXO0FBQ2pCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0EsaUVBQWlFLCtEQUFjO0FBQy9FO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUEsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxNQUFNLEVBQUUsdUVBQWM7O0FBRXRCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGtCQUFrQiw2RUFBaUI7QUFDbkM7O0FBRUE7QUFDQTtBQUNBLFFBQVE7QUFDUjs7QUFFQTtBQUNBLHdCQUF3Qix5QkFBeUI7QUFDakQ7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTixvREFBb0QseUZBQWlCO0FBQ3JFLHdEQUF3RCx1RUFBUztBQUNqRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7O0FBRUEsOEZBQWU7O0FBRWYsOEZBQWU7QUFDZiIsInNvdXJjZXMiOlsid2VicGFjazovL3Z1ZTMtd2VicGFjazUvLi9ub2RlX21vZHVsZXMvQGRlY2suZ2wvbGF5ZXJzL2Rpc3QvZXNtL3BvbHlnb24tbGF5ZXIvcG9seWdvbi1sYXllci5qcz83YzJhIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBfZGVmaW5lUHJvcGVydHkgZnJvbSBcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL2RlZmluZVByb3BlcnR5XCI7XG5pbXBvcnQgeyBDb21wb3NpdGVMYXllciwgY3JlYXRlSXRlcmFibGUsIGxvZyB9IGZyb20gJ0BkZWNrLmdsL2NvcmUnO1xuaW1wb3J0IFNvbGlkUG9seWdvbkxheWVyIGZyb20gJy4uL3NvbGlkLXBvbHlnb24tbGF5ZXIvc29saWQtcG9seWdvbi1sYXllcic7XG5pbXBvcnQgUGF0aExheWVyIGZyb20gJy4uL3BhdGgtbGF5ZXIvcGF0aC1sYXllcic7XG5pbXBvcnQgKiBhcyBQb2x5Z29uIGZyb20gJy4uL3NvbGlkLXBvbHlnb24tbGF5ZXIvcG9seWdvbic7XG5pbXBvcnQgeyByZXBsYWNlSW5SYW5nZSB9IGZyb20gJy4uL3V0aWxzJztcbmNvbnN0IGRlZmF1bHRMaW5lQ29sb3IgPSBbMCwgMCwgMCwgMjU1XTtcbmNvbnN0IGRlZmF1bHRGaWxsQ29sb3IgPSBbMCwgMCwgMCwgMjU1XTtcbmNvbnN0IGRlZmF1bHRQcm9wcyA9IHtcbiAgc3Ryb2tlZDogdHJ1ZSxcbiAgZmlsbGVkOiB0cnVlLFxuICBleHRydWRlZDogZmFsc2UsXG4gIGVsZXZhdGlvblNjYWxlOiAxLFxuICB3aXJlZnJhbWU6IGZhbHNlLFxuICBfbm9ybWFsaXplOiB0cnVlLFxuICBfd2luZGluZ09yZGVyOiAnQ1cnLFxuICBsaW5lV2lkdGhVbml0czogJ21ldGVycycsXG4gIGxpbmVXaWR0aFNjYWxlOiAxLFxuICBsaW5lV2lkdGhNaW5QaXhlbHM6IDAsXG4gIGxpbmVXaWR0aE1heFBpeGVsczogTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVIsXG4gIGxpbmVKb2ludFJvdW5kZWQ6IGZhbHNlLFxuICBsaW5lTWl0ZXJMaW1pdDogNCxcbiAgZ2V0UG9seWdvbjoge1xuICAgIHR5cGU6ICdhY2Nlc3NvcicsXG4gICAgdmFsdWU6IGYgPT4gZi5wb2x5Z29uXG4gIH0sXG4gIGdldEZpbGxDb2xvcjoge1xuICAgIHR5cGU6ICdhY2Nlc3NvcicsXG4gICAgdmFsdWU6IGRlZmF1bHRGaWxsQ29sb3JcbiAgfSxcbiAgZ2V0TGluZUNvbG9yOiB7XG4gICAgdHlwZTogJ2FjY2Vzc29yJyxcbiAgICB2YWx1ZTogZGVmYXVsdExpbmVDb2xvclxuICB9LFxuICBnZXRMaW5lV2lkdGg6IHtcbiAgICB0eXBlOiAnYWNjZXNzb3InLFxuICAgIHZhbHVlOiAxXG4gIH0sXG4gIGdldEVsZXZhdGlvbjoge1xuICAgIHR5cGU6ICdhY2Nlc3NvcicsXG4gICAgdmFsdWU6IDEwMDBcbiAgfSxcbiAgbWF0ZXJpYWw6IHRydWVcbn07XG5leHBvcnQgZGVmYXVsdCBjbGFzcyBQb2x5Z29uTGF5ZXIgZXh0ZW5kcyBDb21wb3NpdGVMYXllciB7XG4gIGluaXRpYWxpemVTdGF0ZSgpIHtcbiAgICB0aGlzLnN0YXRlID0ge1xuICAgICAgcGF0aHM6IFtdXG4gICAgfTtcblxuICAgIGlmICh0aGlzLnByb3BzLmdldExpbmVEYXNoQXJyYXkpIHtcbiAgICAgIGxvZy5yZW1vdmVkKCdnZXRMaW5lRGFzaEFycmF5JywgJ1BhdGhTdHlsZUV4dGVuc2lvbicpKCk7XG4gICAgfVxuICB9XG5cbiAgdXBkYXRlU3RhdGUoe1xuICAgIGNoYW5nZUZsYWdzXG4gIH0pIHtcbiAgICBjb25zdCBnZW9tZXRyeUNoYW5nZWQgPSBjaGFuZ2VGbGFncy5kYXRhQ2hhbmdlZCB8fCBjaGFuZ2VGbGFncy51cGRhdGVUcmlnZ2Vyc0NoYW5nZWQgJiYgKGNoYW5nZUZsYWdzLnVwZGF0ZVRyaWdnZXJzQ2hhbmdlZC5hbGwgfHwgY2hhbmdlRmxhZ3MudXBkYXRlVHJpZ2dlcnNDaGFuZ2VkLmdldFBvbHlnb24pO1xuXG4gICAgaWYgKGdlb21ldHJ5Q2hhbmdlZCAmJiBBcnJheS5pc0FycmF5KGNoYW5nZUZsYWdzLmRhdGFDaGFuZ2VkKSkge1xuICAgICAgY29uc3QgcGF0aHMgPSB0aGlzLnN0YXRlLnBhdGhzLnNsaWNlKCk7XG4gICAgICBjb25zdCBwYXRoc0RpZmYgPSBjaGFuZ2VGbGFncy5kYXRhQ2hhbmdlZC5tYXAoZGF0YVJhbmdlID0+IHJlcGxhY2VJblJhbmdlKHtcbiAgICAgICAgZGF0YTogcGF0aHMsXG4gICAgICAgIGdldEluZGV4OiBwID0+IHAuX19zb3VyY2UuaW5kZXgsXG4gICAgICAgIGRhdGFSYW5nZSxcbiAgICAgICAgcmVwbGFjZTogdGhpcy5fZ2V0UGF0aHMoZGF0YVJhbmdlKVxuICAgICAgfSkpO1xuICAgICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICAgIHBhdGhzLFxuICAgICAgICBwYXRoc0RpZmZcbiAgICAgIH0pO1xuICAgIH0gZWxzZSBpZiAoZ2VvbWV0cnlDaGFuZ2VkKSB7XG4gICAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgICAgcGF0aHM6IHRoaXMuX2dldFBhdGhzKCksXG4gICAgICAgIHBhdGhzRGlmZjogbnVsbFxuICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgX2dldFBhdGhzKGRhdGFSYW5nZSA9IHt9KSB7XG4gICAgY29uc3Qge1xuICAgICAgZGF0YSxcbiAgICAgIGdldFBvbHlnb24sXG4gICAgICBwb3NpdGlvbkZvcm1hdCxcbiAgICAgIF9ub3JtYWxpemVcbiAgICB9ID0gdGhpcy5wcm9wcztcbiAgICBjb25zdCBwYXRocyA9IFtdO1xuICAgIGNvbnN0IHBvc2l0aW9uU2l6ZSA9IHBvc2l0aW9uRm9ybWF0ID09PSAnWFknID8gMiA6IDM7XG4gICAgY29uc3Qge1xuICAgICAgc3RhcnRSb3csXG4gICAgICBlbmRSb3dcbiAgICB9ID0gZGF0YVJhbmdlO1xuICAgIGNvbnN0IHtcbiAgICAgIGl0ZXJhYmxlLFxuICAgICAgb2JqZWN0SW5mb1xuICAgIH0gPSBjcmVhdGVJdGVyYWJsZShkYXRhLCBzdGFydFJvdywgZW5kUm93KTtcblxuICAgIGZvciAoY29uc3Qgb2JqZWN0IG9mIGl0ZXJhYmxlKSB7XG4gICAgICBvYmplY3RJbmZvLmluZGV4Kys7XG4gICAgICBsZXQgcG9seWdvbiA9IGdldFBvbHlnb24ob2JqZWN0LCBvYmplY3RJbmZvKTtcblxuICAgICAgaWYgKF9ub3JtYWxpemUpIHtcbiAgICAgICAgcG9seWdvbiA9IFBvbHlnb24ubm9ybWFsaXplKHBvbHlnb24sIHBvc2l0aW9uU2l6ZSk7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHtcbiAgICAgICAgaG9sZUluZGljZXNcbiAgICAgIH0gPSBwb2x5Z29uO1xuICAgICAgY29uc3QgcG9zaXRpb25zID0gcG9seWdvbi5wb3NpdGlvbnMgfHwgcG9seWdvbjtcblxuICAgICAgaWYgKGhvbGVJbmRpY2VzKSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDw9IGhvbGVJbmRpY2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgY29uc3QgcGF0aCA9IHBvc2l0aW9ucy5zbGljZShob2xlSW5kaWNlc1tpIC0gMV0gfHwgMCwgaG9sZUluZGljZXNbaV0gfHwgcG9zaXRpb25zLmxlbmd0aCk7XG4gICAgICAgICAgcGF0aHMucHVzaCh0aGlzLmdldFN1YkxheWVyUm93KHtcbiAgICAgICAgICAgIHBhdGhcbiAgICAgICAgICB9LCBvYmplY3QsIG9iamVjdEluZm8uaW5kZXgpKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcGF0aHMucHVzaCh0aGlzLmdldFN1YkxheWVyUm93KHtcbiAgICAgICAgICBwYXRoOiBwb3NpdGlvbnNcbiAgICAgICAgfSwgb2JqZWN0LCBvYmplY3RJbmZvLmluZGV4KSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHBhdGhzO1xuICB9XG5cbiAgcmVuZGVyTGF5ZXJzKCkge1xuICAgIGNvbnN0IHtcbiAgICAgIGRhdGEsXG4gICAgICBfZGF0YURpZmYsXG4gICAgICBzdHJva2VkLFxuICAgICAgZmlsbGVkLFxuICAgICAgZXh0cnVkZWQsXG4gICAgICB3aXJlZnJhbWUsXG4gICAgICBfbm9ybWFsaXplLFxuICAgICAgX3dpbmRpbmdPcmRlcixcbiAgICAgIGVsZXZhdGlvblNjYWxlLFxuICAgICAgdHJhbnNpdGlvbnMsXG4gICAgICBwb3NpdGlvbkZvcm1hdFxuICAgIH0gPSB0aGlzLnByb3BzO1xuICAgIGNvbnN0IHtcbiAgICAgIGxpbmVXaWR0aFVuaXRzLFxuICAgICAgbGluZVdpZHRoU2NhbGUsXG4gICAgICBsaW5lV2lkdGhNaW5QaXhlbHMsXG4gICAgICBsaW5lV2lkdGhNYXhQaXhlbHMsXG4gICAgICBsaW5lSm9pbnRSb3VuZGVkLFxuICAgICAgbGluZU1pdGVyTGltaXQsXG4gICAgICBsaW5lRGFzaEp1c3RpZmllZFxuICAgIH0gPSB0aGlzLnByb3BzO1xuICAgIGNvbnN0IHtcbiAgICAgIGdldEZpbGxDb2xvcixcbiAgICAgIGdldExpbmVDb2xvcixcbiAgICAgIGdldExpbmVXaWR0aCxcbiAgICAgIGdldExpbmVEYXNoQXJyYXksXG4gICAgICBnZXRFbGV2YXRpb24sXG4gICAgICBnZXRQb2x5Z29uLFxuICAgICAgdXBkYXRlVHJpZ2dlcnMsXG4gICAgICBtYXRlcmlhbFxuICAgIH0gPSB0aGlzLnByb3BzO1xuICAgIGNvbnN0IHtcbiAgICAgIHBhdGhzLFxuICAgICAgcGF0aHNEaWZmXG4gICAgfSA9IHRoaXMuc3RhdGU7XG4gICAgY29uc3QgRmlsbExheWVyID0gdGhpcy5nZXRTdWJMYXllckNsYXNzKCdmaWxsJywgU29saWRQb2x5Z29uTGF5ZXIpO1xuICAgIGNvbnN0IFN0cm9rZUxheWVyID0gdGhpcy5nZXRTdWJMYXllckNsYXNzKCdzdHJva2UnLCBQYXRoTGF5ZXIpO1xuICAgIGNvbnN0IHBvbHlnb25MYXllciA9IHRoaXMuc2hvdWxkUmVuZGVyU3ViTGF5ZXIoJ2ZpbGwnLCBwYXRocykgJiYgbmV3IEZpbGxMYXllcih7XG4gICAgICBfZGF0YURpZmYsXG4gICAgICBleHRydWRlZCxcbiAgICAgIGVsZXZhdGlvblNjYWxlLFxuICAgICAgZmlsbGVkLFxuICAgICAgd2lyZWZyYW1lLFxuICAgICAgX25vcm1hbGl6ZSxcbiAgICAgIF93aW5kaW5nT3JkZXIsXG4gICAgICBnZXRFbGV2YXRpb24sXG4gICAgICBnZXRGaWxsQ29sb3IsXG4gICAgICBnZXRMaW5lQ29sb3I6IGV4dHJ1ZGVkICYmIHdpcmVmcmFtZSA/IGdldExpbmVDb2xvciA6IGRlZmF1bHRMaW5lQ29sb3IsXG4gICAgICBtYXRlcmlhbCxcbiAgICAgIHRyYW5zaXRpb25zXG4gICAgfSwgdGhpcy5nZXRTdWJMYXllclByb3BzKHtcbiAgICAgIGlkOiAnZmlsbCcsXG4gICAgICB1cGRhdGVUcmlnZ2VyczogdXBkYXRlVHJpZ2dlcnMgJiYge1xuICAgICAgICBnZXRQb2x5Z29uOiB1cGRhdGVUcmlnZ2Vycy5nZXRQb2x5Z29uLFxuICAgICAgICBnZXRFbGV2YXRpb246IHVwZGF0ZVRyaWdnZXJzLmdldEVsZXZhdGlvbixcbiAgICAgICAgZ2V0RmlsbENvbG9yOiB1cGRhdGVUcmlnZ2Vycy5nZXRGaWxsQ29sb3IsXG4gICAgICAgIGxpbmVDb2xvcnM6IGV4dHJ1ZGVkICYmIHdpcmVmcmFtZSxcbiAgICAgICAgZ2V0TGluZUNvbG9yOiB1cGRhdGVUcmlnZ2Vycy5nZXRMaW5lQ29sb3JcbiAgICAgIH1cbiAgICB9KSwge1xuICAgICAgZGF0YSxcbiAgICAgIHBvc2l0aW9uRm9ybWF0LFxuICAgICAgZ2V0UG9seWdvblxuICAgIH0pO1xuICAgIGNvbnN0IHBvbHlnb25MaW5lTGF5ZXIgPSAhZXh0cnVkZWQgJiYgc3Ryb2tlZCAmJiB0aGlzLnNob3VsZFJlbmRlclN1YkxheWVyKCdzdHJva2UnLCBwYXRocykgJiYgbmV3IFN0cm9rZUxheWVyKHtcbiAgICAgIF9kYXRhRGlmZjogcGF0aHNEaWZmICYmICgoKSA9PiBwYXRoc0RpZmYpLFxuICAgICAgd2lkdGhVbml0czogbGluZVdpZHRoVW5pdHMsXG4gICAgICB3aWR0aFNjYWxlOiBsaW5lV2lkdGhTY2FsZSxcbiAgICAgIHdpZHRoTWluUGl4ZWxzOiBsaW5lV2lkdGhNaW5QaXhlbHMsXG4gICAgICB3aWR0aE1heFBpeGVsczogbGluZVdpZHRoTWF4UGl4ZWxzLFxuICAgICAgam9pbnRSb3VuZGVkOiBsaW5lSm9pbnRSb3VuZGVkLFxuICAgICAgbWl0ZXJMaW1pdDogbGluZU1pdGVyTGltaXQsXG4gICAgICBkYXNoSnVzdGlmaWVkOiBsaW5lRGFzaEp1c3RpZmllZCxcbiAgICAgIF9wYXRoVHlwZTogJ2xvb3AnLFxuICAgICAgdHJhbnNpdGlvbnM6IHRyYW5zaXRpb25zICYmIHtcbiAgICAgICAgZ2V0V2lkdGg6IHRyYW5zaXRpb25zLmdldExpbmVXaWR0aCxcbiAgICAgICAgZ2V0Q29sb3I6IHRyYW5zaXRpb25zLmdldExpbmVDb2xvcixcbiAgICAgICAgZ2V0UGF0aDogdHJhbnNpdGlvbnMuZ2V0UG9seWdvblxuICAgICAgfSxcbiAgICAgIGdldENvbG9yOiB0aGlzLmdldFN1YkxheWVyQWNjZXNzb3IoZ2V0TGluZUNvbG9yKSxcbiAgICAgIGdldFdpZHRoOiB0aGlzLmdldFN1YkxheWVyQWNjZXNzb3IoZ2V0TGluZVdpZHRoKSxcbiAgICAgIGdldERhc2hBcnJheTogdGhpcy5nZXRTdWJMYXllckFjY2Vzc29yKGdldExpbmVEYXNoQXJyYXkpXG4gICAgfSwgdGhpcy5nZXRTdWJMYXllclByb3BzKHtcbiAgICAgIGlkOiAnc3Ryb2tlJyxcbiAgICAgIHVwZGF0ZVRyaWdnZXJzOiB1cGRhdGVUcmlnZ2VycyAmJiB7XG4gICAgICAgIGdldFdpZHRoOiB1cGRhdGVUcmlnZ2Vycy5nZXRMaW5lV2lkdGgsXG4gICAgICAgIGdldENvbG9yOiB1cGRhdGVUcmlnZ2Vycy5nZXRMaW5lQ29sb3IsXG4gICAgICAgIGdldERhc2hBcnJheTogdXBkYXRlVHJpZ2dlcnMuZ2V0TGluZURhc2hBcnJheVxuICAgICAgfVxuICAgIH0pLCB7XG4gICAgICBkYXRhOiBwYXRocyxcbiAgICAgIHBvc2l0aW9uRm9ybWF0LFxuICAgICAgZ2V0UGF0aDogeCA9PiB4LnBhdGhcbiAgICB9KTtcbiAgICByZXR1cm4gWyFleHRydWRlZCAmJiBwb2x5Z29uTGF5ZXIsIHBvbHlnb25MaW5lTGF5ZXIsIGV4dHJ1ZGVkICYmIHBvbHlnb25MYXllcl07XG4gIH1cblxufVxuXG5fZGVmaW5lUHJvcGVydHkoUG9seWdvbkxheWVyLCBcImxheWVyTmFtZVwiLCAnUG9seWdvbkxheWVyJyk7XG5cbl9kZWZpbmVQcm9wZXJ0eShQb2x5Z29uTGF5ZXIsIFwiZGVmYXVsdFByb3BzXCIsIGRlZmF1bHRQcm9wcyk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1wb2x5Z29uLWxheWVyLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///33121\n")},99890:function(__unused_webpack_module,__webpack_exports__,__webpack_require__){eval("/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Fv\": function() { return /* binding */ normalize; },\n/* harmony export */   \"Gd\": function() { return /* binding */ getHoleIndices; },\n/* harmony export */   \"k8\": function() { return /* binding */ getPositions; },\n/* harmony export */   \"mD\": function() { return /* binding */ getSurfaceIndices; }\n/* harmony export */ });\n/* harmony import */ var earcut__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(9187);\n/* harmony import */ var earcut__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(earcut__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _math_gl_polygon__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(89513);\n\n\nconst OUTER_POLYGON_WINDING = _math_gl_polygon__WEBPACK_IMPORTED_MODULE_1__/* .WINDING.CLOCKWISE */ .wG.CLOCKWISE;\nconst HOLE_POLYGON_WINDING = _math_gl_polygon__WEBPACK_IMPORTED_MODULE_1__/* .WINDING.COUNTER_CLOCKWISE */ .wG.COUNTER_CLOCKWISE;\nconst windingOptions = {\n  isClosed: true\n};\n\nfunction validate(polygon) {\n  polygon = polygon && polygon.positions || polygon;\n\n  if (!Array.isArray(polygon) && !ArrayBuffer.isView(polygon)) {\n    throw new Error('invalid polygon');\n  }\n}\n\nfunction getPositions(polygon) {\n  return 'positions' in polygon ? polygon.positions : polygon;\n}\nfunction getHoleIndices(polygon) {\n  return 'holeIndices' in polygon ? polygon.holeIndices : null;\n}\n\nfunction isNested(polygon) {\n  return Array.isArray(polygon[0]);\n}\n\nfunction isSimple(polygon) {\n  return polygon.length >= 1 && polygon[0].length >= 2 && Number.isFinite(polygon[0][0]);\n}\n\nfunction isNestedRingClosed(simplePolygon) {\n  const p0 = simplePolygon[0];\n  const p1 = simplePolygon[simplePolygon.length - 1];\n  return p0[0] === p1[0] && p0[1] === p1[1] && p0[2] === p1[2];\n}\n\nfunction isFlatRingClosed(positions, size, startIndex, endIndex) {\n  for (let i = 0; i < size; i++) {\n    if (positions[startIndex + i] !== positions[endIndex - size + i]) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\nfunction copyNestedRing(target, targetStartIndex, simplePolygon, size, windingDirection) {\n  let targetIndex = targetStartIndex;\n  const len = simplePolygon.length;\n\n  for (let i = 0; i < len; i++) {\n    for (let j = 0; j < size; j++) {\n      target[targetIndex++] = simplePolygon[i][j] || 0;\n    }\n  }\n\n  if (!isNestedRingClosed(simplePolygon)) {\n    for (let j = 0; j < size; j++) {\n      target[targetIndex++] = simplePolygon[0][j] || 0;\n    }\n  }\n\n  windingOptions.start = targetStartIndex;\n  windingOptions.end = targetIndex;\n  windingOptions.size = size;\n  (0,_math_gl_polygon__WEBPACK_IMPORTED_MODULE_1__/* .modifyPolygonWindingDirection */ .Ny)(target, windingDirection, windingOptions);\n  return targetIndex;\n}\n\nfunction copyFlatRing(target, targetStartIndex, positions, size, srcStartIndex = 0, srcEndIndex, windingDirection) {\n  srcEndIndex = srcEndIndex || positions.length;\n  const srcLength = srcEndIndex - srcStartIndex;\n\n  if (srcLength <= 0) {\n    return targetStartIndex;\n  }\n\n  let targetIndex = targetStartIndex;\n\n  for (let i = 0; i < srcLength; i++) {\n    target[targetIndex++] = positions[srcStartIndex + i];\n  }\n\n  if (!isFlatRingClosed(positions, size, srcStartIndex, srcEndIndex)) {\n    for (let i = 0; i < size; i++) {\n      target[targetIndex++] = positions[srcStartIndex + i];\n    }\n  }\n\n  windingOptions.start = targetStartIndex;\n  windingOptions.end = targetIndex;\n  windingOptions.size = size;\n  (0,_math_gl_polygon__WEBPACK_IMPORTED_MODULE_1__/* .modifyPolygonWindingDirection */ .Ny)(target, windingDirection, windingOptions);\n  return targetIndex;\n}\n\nfunction normalize(polygon, positionSize) {\n  validate(polygon);\n  const positions = [];\n  const holeIndices = [];\n\n  if ('positions' in polygon) {\n    const {\n      positions: srcPositions,\n      holeIndices: srcHoleIndices\n    } = polygon;\n\n    if (srcHoleIndices) {\n      let targetIndex = 0;\n\n      for (let i = 0; i <= srcHoleIndices.length; i++) {\n        targetIndex = copyFlatRing(positions, targetIndex, srcPositions, positionSize, srcHoleIndices[i - 1], srcHoleIndices[i], i === 0 ? OUTER_POLYGON_WINDING : HOLE_POLYGON_WINDING);\n        holeIndices.push(targetIndex);\n      }\n\n      holeIndices.pop();\n      return {\n        positions,\n        holeIndices\n      };\n    }\n\n    polygon = srcPositions;\n  }\n\n  if (!isNested(polygon)) {\n    copyFlatRing(positions, 0, polygon, positionSize, 0, positions.length, OUTER_POLYGON_WINDING);\n    return positions;\n  }\n\n  if (!isSimple(polygon)) {\n    let targetIndex = 0;\n\n    for (const [polygonIndex, simplePolygon] of polygon.entries()) {\n      targetIndex = copyNestedRing(positions, targetIndex, simplePolygon, positionSize, polygonIndex === 0 ? OUTER_POLYGON_WINDING : HOLE_POLYGON_WINDING);\n      holeIndices.push(targetIndex);\n    }\n\n    holeIndices.pop();\n    return {\n      positions,\n      holeIndices\n    };\n  }\n\n  copyNestedRing(positions, 0, polygon, positionSize, OUTER_POLYGON_WINDING);\n  return positions;\n}\n\nfunction getPlaneArea(positions, xIndex, yIndex) {\n  const numVerts = positions.length / 3;\n  let area = 0;\n\n  for (let i = 0; i < numVerts; i++) {\n    const j = (i + 1) % numVerts;\n    area += positions[i * 3 + xIndex] * positions[j * 3 + yIndex];\n    area -= positions[j * 3 + xIndex] * positions[i * 3 + yIndex];\n  }\n\n  return Math.abs(area / 2);\n}\n\nfunction permutePositions(positions, xIndex, yIndex, zIndex) {\n  const numVerts = positions.length / 3;\n\n  for (let i = 0; i < numVerts; i++) {\n    const o = i * 3;\n    const x = positions[o + 0];\n    const y = positions[o + 1];\n    const z = positions[o + 2];\n    positions[o + xIndex] = x;\n    positions[o + yIndex] = y;\n    positions[o + zIndex] = z;\n  }\n}\n\nfunction getSurfaceIndices(polygon, positionSize, preproject, full3d) {\n  let holeIndices = getHoleIndices(polygon);\n\n  if (holeIndices) {\n    holeIndices = holeIndices.map(positionIndex => positionIndex / positionSize);\n  }\n\n  let positions = getPositions(polygon);\n  const is3d = full3d && positionSize === 3;\n\n  if (preproject) {\n    const n = positions.length;\n    positions = positions.slice();\n    const p = [];\n\n    for (let i = 0; i < n; i += positionSize) {\n      p[0] = positions[i];\n      p[1] = positions[i + 1];\n\n      if (is3d) {\n        p[2] = positions[i + 2];\n      }\n\n      const xy = preproject(p);\n      positions[i] = xy[0];\n      positions[i + 1] = xy[1];\n\n      if (is3d) {\n        positions[i + 2] = xy[2];\n      }\n    }\n  }\n\n  if (is3d) {\n    const xyArea = getPlaneArea(positions, 0, 1);\n    const xzArea = getPlaneArea(positions, 0, 2);\n    const yzArea = getPlaneArea(positions, 1, 2);\n\n    if (!xyArea && !xzArea && !yzArea) {\n      return [];\n    }\n\n    if (xyArea > xzArea && xyArea > yzArea) {} else if (xzArea > yzArea) {\n      if (!preproject) {\n        positions = positions.slice();\n      }\n\n      permutePositions(positions, 0, 2, 1);\n    } else {\n      if (!preproject) {\n        positions = positions.slice();\n      }\n\n      permutePositions(positions, 1, 2, 0);\n    }\n  }\n\n  return earcut__WEBPACK_IMPORTED_MODULE_0___default()(positions, holeIndices, positionSize);\n}\n//# sourceMappingURL=polygon.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiOTk4OTAuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBQTRCO0FBQzhDO0FBQzFFLDhCQUE4QixtRkFBaUI7QUFDL0MsNkJBQTZCLG1HQUF5QjtBQUN0RDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFTztBQUNQO0FBQ0E7QUFDTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esa0JBQWtCLFVBQVU7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsa0JBQWtCLFNBQVM7QUFDM0Isb0JBQW9CLFVBQVU7QUFDOUI7QUFDQTtBQUNBOztBQUVBO0FBQ0Esb0JBQW9CLFVBQVU7QUFDOUI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEVBQUUseUZBQTZCO0FBQy9CO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxrQkFBa0IsZUFBZTtBQUNqQztBQUNBOztBQUVBO0FBQ0Esb0JBQW9CLFVBQVU7QUFDOUI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEVBQUUseUZBQTZCO0FBQy9CO0FBQ0E7O0FBRU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNOztBQUVOO0FBQ0E7O0FBRUEsc0JBQXNCLDRCQUE0QjtBQUNsRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxrQkFBa0IsY0FBYztBQUNoQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsa0JBQWtCLGNBQWM7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsb0JBQW9CLE9BQU87QUFDM0I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLCtDQUErQztBQUMvQztBQUNBO0FBQ0E7O0FBRUE7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxTQUFTLDZDQUFNO0FBQ2Y7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3Z1ZTMtd2VicGFjazUvLi9ub2RlX21vZHVsZXMvQGRlY2suZ2wvbGF5ZXJzL2Rpc3QvZXNtL3NvbGlkLXBvbHlnb24tbGF5ZXIvcG9seWdvbi5qcz84ZWJmIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBlYXJjdXQgZnJvbSAnZWFyY3V0JztcbmltcG9ydCB7IG1vZGlmeVBvbHlnb25XaW5kaW5nRGlyZWN0aW9uLCBXSU5ESU5HIH0gZnJvbSAnQG1hdGguZ2wvcG9seWdvbic7XG5jb25zdCBPVVRFUl9QT0xZR09OX1dJTkRJTkcgPSBXSU5ESU5HLkNMT0NLV0lTRTtcbmNvbnN0IEhPTEVfUE9MWUdPTl9XSU5ESU5HID0gV0lORElORy5DT1VOVEVSX0NMT0NLV0lTRTtcbmNvbnN0IHdpbmRpbmdPcHRpb25zID0ge1xuICBpc0Nsb3NlZDogdHJ1ZVxufTtcblxuZnVuY3Rpb24gdmFsaWRhdGUocG9seWdvbikge1xuICBwb2x5Z29uID0gcG9seWdvbiAmJiBwb2x5Z29uLnBvc2l0aW9ucyB8fCBwb2x5Z29uO1xuXG4gIGlmICghQXJyYXkuaXNBcnJheShwb2x5Z29uKSAmJiAhQXJyYXlCdWZmZXIuaXNWaWV3KHBvbHlnb24pKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIHBvbHlnb24nKTtcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0UG9zaXRpb25zKHBvbHlnb24pIHtcbiAgcmV0dXJuICdwb3NpdGlvbnMnIGluIHBvbHlnb24gPyBwb2x5Z29uLnBvc2l0aW9ucyA6IHBvbHlnb247XG59XG5leHBvcnQgZnVuY3Rpb24gZ2V0SG9sZUluZGljZXMocG9seWdvbikge1xuICByZXR1cm4gJ2hvbGVJbmRpY2VzJyBpbiBwb2x5Z29uID8gcG9seWdvbi5ob2xlSW5kaWNlcyA6IG51bGw7XG59XG5cbmZ1bmN0aW9uIGlzTmVzdGVkKHBvbHlnb24pIHtcbiAgcmV0dXJuIEFycmF5LmlzQXJyYXkocG9seWdvblswXSk7XG59XG5cbmZ1bmN0aW9uIGlzU2ltcGxlKHBvbHlnb24pIHtcbiAgcmV0dXJuIHBvbHlnb24ubGVuZ3RoID49IDEgJiYgcG9seWdvblswXS5sZW5ndGggPj0gMiAmJiBOdW1iZXIuaXNGaW5pdGUocG9seWdvblswXVswXSk7XG59XG5cbmZ1bmN0aW9uIGlzTmVzdGVkUmluZ0Nsb3NlZChzaW1wbGVQb2x5Z29uKSB7XG4gIGNvbnN0IHAwID0gc2ltcGxlUG9seWdvblswXTtcbiAgY29uc3QgcDEgPSBzaW1wbGVQb2x5Z29uW3NpbXBsZVBvbHlnb24ubGVuZ3RoIC0gMV07XG4gIHJldHVybiBwMFswXSA9PT0gcDFbMF0gJiYgcDBbMV0gPT09IHAxWzFdICYmIHAwWzJdID09PSBwMVsyXTtcbn1cblxuZnVuY3Rpb24gaXNGbGF0UmluZ0Nsb3NlZChwb3NpdGlvbnMsIHNpemUsIHN0YXJ0SW5kZXgsIGVuZEluZGV4KSB7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgc2l6ZTsgaSsrKSB7XG4gICAgaWYgKHBvc2l0aW9uc1tzdGFydEluZGV4ICsgaV0gIT09IHBvc2l0aW9uc1tlbmRJbmRleCAtIHNpemUgKyBpXSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufVxuXG5mdW5jdGlvbiBjb3B5TmVzdGVkUmluZyh0YXJnZXQsIHRhcmdldFN0YXJ0SW5kZXgsIHNpbXBsZVBvbHlnb24sIHNpemUsIHdpbmRpbmdEaXJlY3Rpb24pIHtcbiAgbGV0IHRhcmdldEluZGV4ID0gdGFyZ2V0U3RhcnRJbmRleDtcbiAgY29uc3QgbGVuID0gc2ltcGxlUG9seWdvbi5sZW5ndGg7XG5cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgIGZvciAobGV0IGogPSAwOyBqIDwgc2l6ZTsgaisrKSB7XG4gICAgICB0YXJnZXRbdGFyZ2V0SW5kZXgrK10gPSBzaW1wbGVQb2x5Z29uW2ldW2pdIHx8IDA7XG4gICAgfVxuICB9XG5cbiAgaWYgKCFpc05lc3RlZFJpbmdDbG9zZWQoc2ltcGxlUG9seWdvbikpIHtcbiAgICBmb3IgKGxldCBqID0gMDsgaiA8IHNpemU7IGorKykge1xuICAgICAgdGFyZ2V0W3RhcmdldEluZGV4KytdID0gc2ltcGxlUG9seWdvblswXVtqXSB8fCAwO1xuICAgIH1cbiAgfVxuXG4gIHdpbmRpbmdPcHRpb25zLnN0YXJ0ID0gdGFyZ2V0U3RhcnRJbmRleDtcbiAgd2luZGluZ09wdGlvbnMuZW5kID0gdGFyZ2V0SW5kZXg7XG4gIHdpbmRpbmdPcHRpb25zLnNpemUgPSBzaXplO1xuICBtb2RpZnlQb2x5Z29uV2luZGluZ0RpcmVjdGlvbih0YXJnZXQsIHdpbmRpbmdEaXJlY3Rpb24sIHdpbmRpbmdPcHRpb25zKTtcbiAgcmV0dXJuIHRhcmdldEluZGV4O1xufVxuXG5mdW5jdGlvbiBjb3B5RmxhdFJpbmcodGFyZ2V0LCB0YXJnZXRTdGFydEluZGV4LCBwb3NpdGlvbnMsIHNpemUsIHNyY1N0YXJ0SW5kZXggPSAwLCBzcmNFbmRJbmRleCwgd2luZGluZ0RpcmVjdGlvbikge1xuICBzcmNFbmRJbmRleCA9IHNyY0VuZEluZGV4IHx8IHBvc2l0aW9ucy5sZW5ndGg7XG4gIGNvbnN0IHNyY0xlbmd0aCA9IHNyY0VuZEluZGV4IC0gc3JjU3RhcnRJbmRleDtcblxuICBpZiAoc3JjTGVuZ3RoIDw9IDApIHtcbiAgICByZXR1cm4gdGFyZ2V0U3RhcnRJbmRleDtcbiAgfVxuXG4gIGxldCB0YXJnZXRJbmRleCA9IHRhcmdldFN0YXJ0SW5kZXg7XG5cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBzcmNMZW5ndGg7IGkrKykge1xuICAgIHRhcmdldFt0YXJnZXRJbmRleCsrXSA9IHBvc2l0aW9uc1tzcmNTdGFydEluZGV4ICsgaV07XG4gIH1cblxuICBpZiAoIWlzRmxhdFJpbmdDbG9zZWQocG9zaXRpb25zLCBzaXplLCBzcmNTdGFydEluZGV4LCBzcmNFbmRJbmRleCkpIHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNpemU7IGkrKykge1xuICAgICAgdGFyZ2V0W3RhcmdldEluZGV4KytdID0gcG9zaXRpb25zW3NyY1N0YXJ0SW5kZXggKyBpXTtcbiAgICB9XG4gIH1cblxuICB3aW5kaW5nT3B0aW9ucy5zdGFydCA9IHRhcmdldFN0YXJ0SW5kZXg7XG4gIHdpbmRpbmdPcHRpb25zLmVuZCA9IHRhcmdldEluZGV4O1xuICB3aW5kaW5nT3B0aW9ucy5zaXplID0gc2l6ZTtcbiAgbW9kaWZ5UG9seWdvbldpbmRpbmdEaXJlY3Rpb24odGFyZ2V0LCB3aW5kaW5nRGlyZWN0aW9uLCB3aW5kaW5nT3B0aW9ucyk7XG4gIHJldHVybiB0YXJnZXRJbmRleDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIG5vcm1hbGl6ZShwb2x5Z29uLCBwb3NpdGlvblNpemUpIHtcbiAgdmFsaWRhdGUocG9seWdvbik7XG4gIGNvbnN0IHBvc2l0aW9ucyA9IFtdO1xuICBjb25zdCBob2xlSW5kaWNlcyA9IFtdO1xuXG4gIGlmICgncG9zaXRpb25zJyBpbiBwb2x5Z29uKSB7XG4gICAgY29uc3Qge1xuICAgICAgcG9zaXRpb25zOiBzcmNQb3NpdGlvbnMsXG4gICAgICBob2xlSW5kaWNlczogc3JjSG9sZUluZGljZXNcbiAgICB9ID0gcG9seWdvbjtcblxuICAgIGlmIChzcmNIb2xlSW5kaWNlcykge1xuICAgICAgbGV0IHRhcmdldEluZGV4ID0gMDtcblxuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPD0gc3JjSG9sZUluZGljZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdGFyZ2V0SW5kZXggPSBjb3B5RmxhdFJpbmcocG9zaXRpb25zLCB0YXJnZXRJbmRleCwgc3JjUG9zaXRpb25zLCBwb3NpdGlvblNpemUsIHNyY0hvbGVJbmRpY2VzW2kgLSAxXSwgc3JjSG9sZUluZGljZXNbaV0sIGkgPT09IDAgPyBPVVRFUl9QT0xZR09OX1dJTkRJTkcgOiBIT0xFX1BPTFlHT05fV0lORElORyk7XG4gICAgICAgIGhvbGVJbmRpY2VzLnB1c2godGFyZ2V0SW5kZXgpO1xuICAgICAgfVxuXG4gICAgICBob2xlSW5kaWNlcy5wb3AoKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHBvc2l0aW9ucyxcbiAgICAgICAgaG9sZUluZGljZXNcbiAgICAgIH07XG4gICAgfVxuXG4gICAgcG9seWdvbiA9IHNyY1Bvc2l0aW9ucztcbiAgfVxuXG4gIGlmICghaXNOZXN0ZWQocG9seWdvbikpIHtcbiAgICBjb3B5RmxhdFJpbmcocG9zaXRpb25zLCAwLCBwb2x5Z29uLCBwb3NpdGlvblNpemUsIDAsIHBvc2l0aW9ucy5sZW5ndGgsIE9VVEVSX1BPTFlHT05fV0lORElORyk7XG4gICAgcmV0dXJuIHBvc2l0aW9ucztcbiAgfVxuXG4gIGlmICghaXNTaW1wbGUocG9seWdvbikpIHtcbiAgICBsZXQgdGFyZ2V0SW5kZXggPSAwO1xuXG4gICAgZm9yIChjb25zdCBbcG9seWdvbkluZGV4LCBzaW1wbGVQb2x5Z29uXSBvZiBwb2x5Z29uLmVudHJpZXMoKSkge1xuICAgICAgdGFyZ2V0SW5kZXggPSBjb3B5TmVzdGVkUmluZyhwb3NpdGlvbnMsIHRhcmdldEluZGV4LCBzaW1wbGVQb2x5Z29uLCBwb3NpdGlvblNpemUsIHBvbHlnb25JbmRleCA9PT0gMCA/IE9VVEVSX1BPTFlHT05fV0lORElORyA6IEhPTEVfUE9MWUdPTl9XSU5ESU5HKTtcbiAgICAgIGhvbGVJbmRpY2VzLnB1c2godGFyZ2V0SW5kZXgpO1xuICAgIH1cblxuICAgIGhvbGVJbmRpY2VzLnBvcCgpO1xuICAgIHJldHVybiB7XG4gICAgICBwb3NpdGlvbnMsXG4gICAgICBob2xlSW5kaWNlc1xuICAgIH07XG4gIH1cblxuICBjb3B5TmVzdGVkUmluZyhwb3NpdGlvbnMsIDAsIHBvbHlnb24sIHBvc2l0aW9uU2l6ZSwgT1VURVJfUE9MWUdPTl9XSU5ESU5HKTtcbiAgcmV0dXJuIHBvc2l0aW9ucztcbn1cblxuZnVuY3Rpb24gZ2V0UGxhbmVBcmVhKHBvc2l0aW9ucywgeEluZGV4LCB5SW5kZXgpIHtcbiAgY29uc3QgbnVtVmVydHMgPSBwb3NpdGlvbnMubGVuZ3RoIC8gMztcbiAgbGV0IGFyZWEgPSAwO1xuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbnVtVmVydHM7IGkrKykge1xuICAgIGNvbnN0IGogPSAoaSArIDEpICUgbnVtVmVydHM7XG4gICAgYXJlYSArPSBwb3NpdGlvbnNbaSAqIDMgKyB4SW5kZXhdICogcG9zaXRpb25zW2ogKiAzICsgeUluZGV4XTtcbiAgICBhcmVhIC09IHBvc2l0aW9uc1tqICogMyArIHhJbmRleF0gKiBwb3NpdGlvbnNbaSAqIDMgKyB5SW5kZXhdO1xuICB9XG5cbiAgcmV0dXJuIE1hdGguYWJzKGFyZWEgLyAyKTtcbn1cblxuZnVuY3Rpb24gcGVybXV0ZVBvc2l0aW9ucyhwb3NpdGlvbnMsIHhJbmRleCwgeUluZGV4LCB6SW5kZXgpIHtcbiAgY29uc3QgbnVtVmVydHMgPSBwb3NpdGlvbnMubGVuZ3RoIC8gMztcblxuICBmb3IgKGxldCBpID0gMDsgaSA8IG51bVZlcnRzOyBpKyspIHtcbiAgICBjb25zdCBvID0gaSAqIDM7XG4gICAgY29uc3QgeCA9IHBvc2l0aW9uc1tvICsgMF07XG4gICAgY29uc3QgeSA9IHBvc2l0aW9uc1tvICsgMV07XG4gICAgY29uc3QgeiA9IHBvc2l0aW9uc1tvICsgMl07XG4gICAgcG9zaXRpb25zW28gKyB4SW5kZXhdID0geDtcbiAgICBwb3NpdGlvbnNbbyArIHlJbmRleF0gPSB5O1xuICAgIHBvc2l0aW9uc1tvICsgekluZGV4XSA9IHo7XG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdldFN1cmZhY2VJbmRpY2VzKHBvbHlnb24sIHBvc2l0aW9uU2l6ZSwgcHJlcHJvamVjdCwgZnVsbDNkKSB7XG4gIGxldCBob2xlSW5kaWNlcyA9IGdldEhvbGVJbmRpY2VzKHBvbHlnb24pO1xuXG4gIGlmIChob2xlSW5kaWNlcykge1xuICAgIGhvbGVJbmRpY2VzID0gaG9sZUluZGljZXMubWFwKHBvc2l0aW9uSW5kZXggPT4gcG9zaXRpb25JbmRleCAvIHBvc2l0aW9uU2l6ZSk7XG4gIH1cblxuICBsZXQgcG9zaXRpb25zID0gZ2V0UG9zaXRpb25zKHBvbHlnb24pO1xuICBjb25zdCBpczNkID0gZnVsbDNkICYmIHBvc2l0aW9uU2l6ZSA9PT0gMztcblxuICBpZiAocHJlcHJvamVjdCkge1xuICAgIGNvbnN0IG4gPSBwb3NpdGlvbnMubGVuZ3RoO1xuICAgIHBvc2l0aW9ucyA9IHBvc2l0aW9ucy5zbGljZSgpO1xuICAgIGNvbnN0IHAgPSBbXTtcblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbjsgaSArPSBwb3NpdGlvblNpemUpIHtcbiAgICAgIHBbMF0gPSBwb3NpdGlvbnNbaV07XG4gICAgICBwWzFdID0gcG9zaXRpb25zW2kgKyAxXTtcblxuICAgICAgaWYgKGlzM2QpIHtcbiAgICAgICAgcFsyXSA9IHBvc2l0aW9uc1tpICsgMl07XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHh5ID0gcHJlcHJvamVjdChwKTtcbiAgICAgIHBvc2l0aW9uc1tpXSA9IHh5WzBdO1xuICAgICAgcG9zaXRpb25zW2kgKyAxXSA9IHh5WzFdO1xuXG4gICAgICBpZiAoaXMzZCkge1xuICAgICAgICBwb3NpdGlvbnNbaSArIDJdID0geHlbMl07XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgaWYgKGlzM2QpIHtcbiAgICBjb25zdCB4eUFyZWEgPSBnZXRQbGFuZUFyZWEocG9zaXRpb25zLCAwLCAxKTtcbiAgICBjb25zdCB4ekFyZWEgPSBnZXRQbGFuZUFyZWEocG9zaXRpb25zLCAwLCAyKTtcbiAgICBjb25zdCB5ekFyZWEgPSBnZXRQbGFuZUFyZWEocG9zaXRpb25zLCAxLCAyKTtcblxuICAgIGlmICgheHlBcmVhICYmICF4ekFyZWEgJiYgIXl6QXJlYSkge1xuICAgICAgcmV0dXJuIFtdO1xuICAgIH1cblxuICAgIGlmICh4eUFyZWEgPiB4ekFyZWEgJiYgeHlBcmVhID4geXpBcmVhKSB7fSBlbHNlIGlmICh4ekFyZWEgPiB5ekFyZWEpIHtcbiAgICAgIGlmICghcHJlcHJvamVjdCkge1xuICAgICAgICBwb3NpdGlvbnMgPSBwb3NpdGlvbnMuc2xpY2UoKTtcbiAgICAgIH1cblxuICAgICAgcGVybXV0ZVBvc2l0aW9ucyhwb3NpdGlvbnMsIDAsIDIsIDEpO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoIXByZXByb2plY3QpIHtcbiAgICAgICAgcG9zaXRpb25zID0gcG9zaXRpb25zLnNsaWNlKCk7XG4gICAgICB9XG5cbiAgICAgIHBlcm11dGVQb3NpdGlvbnMocG9zaXRpb25zLCAxLCAyLCAwKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZWFyY3V0KHBvc2l0aW9ucywgaG9sZUluZGljZXMsIHBvc2l0aW9uU2l6ZSk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1wb2x5Z29uLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///99890\n")},56923:function(__unused_webpack_module,__webpack_exports__,__webpack_require__){eval("\n// EXPORTS\n__webpack_require__.d(__webpack_exports__, {\n  \"Z\": function() { return /* binding */ SolidPolygonLayer; }\n});\n\n// EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/esm/defineProperty.js\nvar defineProperty = __webpack_require__(82482);\n// EXTERNAL MODULE: ./node_modules/@deck.gl/core/dist/esm/lib/layer.js + 3 modules\nvar lib_layer = __webpack_require__(52447);\n// EXTERNAL MODULE: ./node_modules/@deck.gl/core/dist/esm/shaderlib/project32/project32.js\nvar project32 = __webpack_require__(93844);\n// EXTERNAL MODULE: ./node_modules/@luma.gl/shadertools/dist/esm/modules/phong-lighting/phong-lighting.js + 1 modules\nvar phong_lighting = __webpack_require__(8674);\n// EXTERNAL MODULE: ./node_modules/@deck.gl/core/dist/esm/shaderlib/picking/picking.js\nvar picking = __webpack_require__(43844);\n// EXTERNAL MODULE: ./node_modules/@deck.gl/core/dist/esm/lib/constants.js\nvar constants = __webpack_require__(24088);\n// EXTERNAL MODULE: ./node_modules/@luma.gl/webgl/dist/esm/features/features.js\nvar features = __webpack_require__(44211);\n// EXTERNAL MODULE: ./node_modules/@luma.gl/webgl/dist/esm/features/webgl-features-table.js\nvar webgl_features_table = __webpack_require__(6948);\n// EXTERNAL MODULE: ./node_modules/@luma.gl/engine/dist/esm/lib/model.js + 1 modules\nvar model = __webpack_require__(80210);\n// EXTERNAL MODULE: ./node_modules/@luma.gl/engine/dist/esm/geometry/geometry.js\nvar geometry = __webpack_require__(53982);\n// EXTERNAL MODULE: ./node_modules/@deck.gl/layers/dist/esm/solid-polygon-layer/polygon.js\nvar solid_polygon_layer_polygon = __webpack_require__(99890);\n// EXTERNAL MODULE: ./node_modules/@deck.gl/core/dist/esm/utils/tesselator.js\nvar tesselator = __webpack_require__(28005);\n// EXTERNAL MODULE: ./node_modules/@math.gl/polygon/dist/esm/index.js + 7 modules\nvar esm = __webpack_require__(89513);\n;// CONCATENATED MODULE: ./node_modules/@deck.gl/layers/dist/esm/solid-polygon-layer/polygon-tesselator.js\n\n\n\nclass PolygonTesselator extends tesselator/* default */.Z {\n  constructor(opts) {\n    const {\n      fp64,\n      IndexType = Uint32Array\n    } = opts;\n    super({ ...opts,\n      attributes: {\n        positions: {\n          size: 3,\n          type: fp64 ? Float64Array : Float32Array\n        },\n        vertexValid: {\n          type: Uint8ClampedArray,\n          size: 1\n        },\n        indices: {\n          type: IndexType,\n          size: 1\n        }\n      }\n    });\n  }\n\n  get(attributeName) {\n    const {\n      attributes\n    } = this;\n\n    if (attributeName === 'indices') {\n      return attributes.indices && attributes.indices.subarray(0, this.vertexCount);\n    }\n\n    return attributes[attributeName];\n  }\n\n  updateGeometry(opts) {\n    super.updateGeometry(opts);\n    const externalIndices = this.buffers.indices;\n\n    if (externalIndices) {\n      this.vertexCount = (externalIndices.value || externalIndices).length;\n    } else if (this.data && !this.getGeometry) {\n      throw new Error('missing indices buffer');\n    }\n  }\n\n  normalizeGeometry(polygon) {\n    if (this.normalize) {\n      const normalizedPolygon = solid_polygon_layer_polygon/* normalize */.Fv(polygon, this.positionSize);\n\n      if (this.opts.resolution) {\n        return (0,esm/* cutPolygonByGrid */.WZ)(solid_polygon_layer_polygon/* getPositions */.k8(normalizedPolygon), solid_polygon_layer_polygon/* getHoleIndices */.Gd(normalizedPolygon), {\n          size: this.positionSize,\n          gridResolution: this.opts.resolution,\n          edgeTypes: true\n        });\n      }\n\n      if (this.opts.wrapLongitude) {\n        return (0,esm/* cutPolygonByMercatorBounds */.GU)(solid_polygon_layer_polygon/* getPositions */.k8(normalizedPolygon), solid_polygon_layer_polygon/* getHoleIndices */.Gd(normalizedPolygon), {\n          size: this.positionSize,\n          maxLatitude: 86,\n          edgeTypes: true\n        });\n      }\n\n      return normalizedPolygon;\n    }\n\n    return polygon;\n  }\n\n  getGeometrySize(polygon) {\n    if (isCut(polygon)) {\n      let size = 0;\n\n      for (const subPolygon of polygon) {\n        size += this.getGeometrySize(subPolygon);\n      }\n\n      return size;\n    }\n\n    return solid_polygon_layer_polygon/* getPositions */.k8(polygon).length / this.positionSize;\n  }\n\n  getGeometryFromBuffer(buffer) {\n    if (this.normalize || !this.buffers.indices) {\n      return super.getGeometryFromBuffer(buffer);\n    }\n\n    return null;\n  }\n\n  updateGeometryAttributes(polygon, context) {\n    if (polygon && isCut(polygon)) {\n      for (const subPolygon of polygon) {\n        const geometrySize = this.getGeometrySize(subPolygon);\n        context.geometrySize = geometrySize;\n        this.updateGeometryAttributes(subPolygon, context);\n        context.vertexStart += geometrySize;\n        context.indexStart = this.indexStarts[context.geometryIndex + 1];\n      }\n    } else {\n      this._updateIndices(polygon, context);\n\n      this._updatePositions(polygon, context);\n\n      this._updateVertexValid(polygon, context);\n    }\n  }\n\n  _updateIndices(polygon, {\n    geometryIndex,\n    vertexStart: offset,\n    indexStart\n  }) {\n    const {\n      attributes,\n      indexStarts,\n      typedArrayManager\n    } = this;\n    let target = attributes.indices;\n\n    if (!target || !polygon) {\n      return;\n    }\n\n    let i = indexStart;\n    const indices = solid_polygon_layer_polygon/* getSurfaceIndices */.mD(polygon, this.positionSize, this.opts.preproject, this.opts.full3d);\n    target = typedArrayManager.allocate(target, indexStart + indices.length, {\n      copy: true\n    });\n\n    for (let j = 0; j < indices.length; j++) {\n      target[i++] = indices[j] + offset;\n    }\n\n    indexStarts[geometryIndex + 1] = indexStart + indices.length;\n    attributes.indices = target;\n  }\n\n  _updatePositions(polygon, {\n    vertexStart,\n    geometrySize\n  }) {\n    const {\n      attributes: {\n        positions\n      },\n      positionSize\n    } = this;\n\n    if (!positions || !polygon) {\n      return;\n    }\n\n    const polygonPositions = solid_polygon_layer_polygon/* getPositions */.k8(polygon);\n\n    for (let i = vertexStart, j = 0; j < geometrySize; i++, j++) {\n      const x = polygonPositions[j * positionSize];\n      const y = polygonPositions[j * positionSize + 1];\n      const z = positionSize > 2 ? polygonPositions[j * positionSize + 2] : 0;\n      positions[i * 3] = x;\n      positions[i * 3 + 1] = y;\n      positions[i * 3 + 2] = z;\n    }\n  }\n\n  _updateVertexValid(polygon, {\n    vertexStart,\n    geometrySize\n  }) {\n    const {\n      positionSize\n    } = this;\n    const vertexValid = this.attributes.vertexValid;\n    const holeIndices = polygon && solid_polygon_layer_polygon/* getHoleIndices */.Gd(polygon);\n\n    if (polygon && polygon.edgeTypes) {\n      vertexValid.set(polygon.edgeTypes, vertexStart);\n    } else {\n      vertexValid.fill(1, vertexStart, vertexStart + geometrySize);\n    }\n\n    if (holeIndices) {\n      for (let j = 0; j < holeIndices.length; j++) {\n        vertexValid[vertexStart + holeIndices[j] / positionSize - 1] = 0;\n      }\n    }\n\n    vertexValid[vertexStart + geometrySize - 1] = 0;\n  }\n\n}\n\nfunction isCut(polygon) {\n  return Array.isArray(polygon) && polygon.length > 0 && !Number.isFinite(polygon[0]);\n}\n//# sourceMappingURL=polygon-tesselator.js.map\n;// CONCATENATED MODULE: ./node_modules/@deck.gl/layers/dist/esm/solid-polygon-layer/solid-polygon-layer-vertex-main.glsl.js\n/* harmony default export */ var solid_polygon_layer_vertex_main_glsl = (\"\\nattribute vec2 vertexPositions;\\nattribute float vertexValid;\\n\\nuniform bool extruded;\\nuniform bool isWireframe;\\nuniform float elevationScale;\\nuniform float opacity;\\n\\nvarying vec4 vColor;\\n\\nstruct PolygonProps {\\n  vec4 fillColors;\\n  vec4 lineColors;\\n  vec3 positions;\\n  vec3 nextPositions;\\n  vec3 pickingColors;\\n  vec3 positions64Low;\\n  vec3 nextPositions64Low;\\n  float elevations;\\n};\\n\\nvec3 project_offset_normal(vec3 vector) {\\n  if (project_uCoordinateSystem == COORDINATE_SYSTEM_LNGLAT ||\\n    project_uCoordinateSystem == COORDINATE_SYSTEM_LNGLAT_OFFSETS) {\\n    return normalize(vector * project_uCommonUnitsPerWorldUnit);\\n  }\\n  return project_normal(vector);\\n}\\n\\nvoid calculatePosition(PolygonProps props) {\\n#ifdef IS_SIDE_VERTEX\\n  if(vertexValid < 0.5){\\n    gl_Position = vec4(0.);\\n    return;\\n  }\\n#endif\\n\\n  vec3 pos;\\n  vec3 pos64Low;\\n  vec3 normal;\\n  vec4 colors = isWireframe ? props.lineColors : props.fillColors;\\n\\n  geometry.worldPosition = props.positions;\\n  geometry.worldPositionAlt = props.nextPositions;\\n  geometry.pickingColor = props.pickingColors;\\n\\n#ifdef IS_SIDE_VERTEX\\n  pos = mix(props.positions, props.nextPositions, vertexPositions.x);\\n  pos64Low = mix(props.positions64Low, props.nextPositions64Low, vertexPositions.x);\\n#else\\n  pos = props.positions;\\n  pos64Low = props.positions64Low;\\n#endif\\n\\n  if (extruded) {\\n    pos.z += props.elevations * vertexPositions.y * elevationScale;\\n  }\\n  gl_Position = project_position_to_clipspace(pos, pos64Low, vec3(0.), geometry.position);\\n\\n  DECKGL_FILTER_GL_POSITION(gl_Position, geometry);\\n\\n  if (extruded) {\\n  #ifdef IS_SIDE_VERTEX\\n    normal = vec3(\\n      props.positions.y - props.nextPositions.y + (props.positions64Low.y - props.nextPositions64Low.y),\\n      props.nextPositions.x - props.positions.x + (props.nextPositions64Low.x - props.positions64Low.x),\\n      0.0);\\n    normal = project_offset_normal(normal);\\n  #else\\n    normal = project_normal(vec3(0.0, 0.0, 1.0));\\n  #endif\\n    geometry.normal = normal;\\n    vec3 lightColor = lighting_getLightColor(colors.rgb, project_uCameraPosition, geometry.position.xyz, normal);\\n    vColor = vec4(lightColor, colors.a * opacity);\\n  } else {\\n    vColor = vec4(colors.rgb, colors.a * opacity);\\n  }\\n  DECKGL_FILTER_COLOR(vColor, geometry);\\n}\\n\");\n//# sourceMappingURL=solid-polygon-layer-vertex-main.glsl.js.map\n;// CONCATENATED MODULE: ./node_modules/@deck.gl/layers/dist/esm/solid-polygon-layer/solid-polygon-layer-vertex-top.glsl.js\n\n/* harmony default export */ var solid_polygon_layer_vertex_top_glsl = (\"#define SHADER_NAME solid-polygon-layer-vertex-shader\\n\\nattribute vec3 positions;\\nattribute vec3 positions64Low;\\nattribute float elevations;\\nattribute vec4 fillColors;\\nattribute vec4 lineColors;\\nattribute vec3 pickingColors;\\n\\n\".concat(solid_polygon_layer_vertex_main_glsl, \"\\n\\nvoid main(void) {\\n  PolygonProps props;\\n\\n  props.positions = positions;\\n  props.positions64Low = positions64Low;\\n  props.elevations = elevations;\\n  props.fillColors = fillColors;\\n  props.lineColors = lineColors;\\n  props.pickingColors = pickingColors;\\n\\n  calculatePosition(props);\\n}\\n\"));\n//# sourceMappingURL=solid-polygon-layer-vertex-top.glsl.js.map\n;// CONCATENATED MODULE: ./node_modules/@deck.gl/layers/dist/esm/solid-polygon-layer/solid-polygon-layer-vertex-side.glsl.js\n\n/* harmony default export */ var solid_polygon_layer_vertex_side_glsl = (\"#define SHADER_NAME solid-polygon-layer-vertex-shader-side\\n#define IS_SIDE_VERTEX\\n\\n\\nattribute vec3 instancePositions;\\nattribute vec3 nextPositions;\\nattribute vec3 instancePositions64Low;\\nattribute vec3 nextPositions64Low;\\nattribute float instanceElevations;\\nattribute vec4 instanceFillColors;\\nattribute vec4 instanceLineColors;\\nattribute vec3 instancePickingColors;\\n\\n\".concat(solid_polygon_layer_vertex_main_glsl, \"\\n\\nvoid main(void) {\\n  PolygonProps props;\\n\\n  #if RING_WINDING_ORDER_CW == 1\\n    props.positions = instancePositions;\\n    props.positions64Low = instancePositions64Low;\\n    props.nextPositions = nextPositions;\\n    props.nextPositions64Low = nextPositions64Low;\\n  #else\\n    props.positions = nextPositions;\\n    props.positions64Low = nextPositions64Low;\\n    props.nextPositions = instancePositions;\\n    props.nextPositions64Low = instancePositions64Low;\\n  #endif\\n  props.elevations = instanceElevations;\\n  props.fillColors = instanceFillColors;\\n  props.lineColors = instanceLineColors;\\n  props.pickingColors = instancePickingColors;\\n\\n  calculatePosition(props);\\n}\\n\"));\n//# sourceMappingURL=solid-polygon-layer-vertex-side.glsl.js.map\n;// CONCATENATED MODULE: ./node_modules/@deck.gl/layers/dist/esm/solid-polygon-layer/solid-polygon-layer-fragment.glsl.js\n/* harmony default export */ var solid_polygon_layer_fragment_glsl = (\"#define SHADER_NAME solid-polygon-layer-fragment-shader\\n\\nprecision highp float;\\n\\nvarying vec4 vColor;\\n\\nvoid main(void) {\\n  gl_FragColor = vColor;\\n\\n  DECKGL_FILTER_COLOR(gl_FragColor, geometry);\\n}\\n\");\n//# sourceMappingURL=solid-polygon-layer-fragment.glsl.js.map\n;// CONCATENATED MODULE: ./node_modules/@deck.gl/layers/dist/esm/solid-polygon-layer/solid-polygon-layer.js\n\n\n\n\n\n\n\nconst DEFAULT_COLOR = [0, 0, 0, 255];\nconst defaultProps = {\n  filled: true,\n  extruded: false,\n  wireframe: false,\n  _normalize: true,\n  _windingOrder: 'CW',\n  _full3d: false,\n  elevationScale: {\n    type: 'number',\n    min: 0,\n    value: 1\n  },\n  getPolygon: {\n    type: 'accessor',\n    value: f => f.polygon\n  },\n  getElevation: {\n    type: 'accessor',\n    value: 1000\n  },\n  getFillColor: {\n    type: 'accessor',\n    value: DEFAULT_COLOR\n  },\n  getLineColor: {\n    type: 'accessor',\n    value: DEFAULT_COLOR\n  },\n  material: true\n};\nconst ATTRIBUTE_TRANSITION = {\n  enter: (value, chunk) => {\n    return chunk.length ? chunk.subarray(chunk.length - value.length) : value;\n  }\n};\nclass SolidPolygonLayer extends lib_layer/* default */.Z {\n  constructor(...args) {\n    super(...args);\n\n    (0,defineProperty/* default */.Z)(this, \"state\", void 0);\n  }\n\n  getShaders(type) {\n    return super.getShaders({\n      vs: type === 'top' ? solid_polygon_layer_vertex_top_glsl : solid_polygon_layer_vertex_side_glsl,\n      fs: solid_polygon_layer_fragment_glsl,\n      defines: {\n        RING_WINDING_ORDER_CW: !this.props._normalize && this.props._windingOrder === 'CCW' ? 0 : 1\n      },\n      modules: [project32/* default */.Z, phong_lighting/* gouraudLighting */.N, picking/* default */.Z]\n    });\n  }\n\n  get wrapLongitude() {\n    return false;\n  }\n\n  initializeState() {\n    const {\n      gl,\n      viewport\n    } = this.context;\n    let {\n      coordinateSystem\n    } = this.props;\n    const {\n      _full3d\n    } = this.props;\n\n    if (viewport.isGeospatial && coordinateSystem === constants/* COORDINATE_SYSTEM.DEFAULT */.Df.DEFAULT) {\n      coordinateSystem = constants/* COORDINATE_SYSTEM.LNGLAT */.Df.LNGLAT;\n    }\n\n    let preproject;\n\n    if (coordinateSystem === constants/* COORDINATE_SYSTEM.LNGLAT */.Df.LNGLAT) {\n      if (_full3d) {\n        preproject = viewport.projectPosition.bind(viewport);\n      } else {\n        preproject = viewport.projectFlat.bind(viewport);\n      }\n    }\n\n    this.setState({\n      numInstances: 0,\n      polygonTesselator: new PolygonTesselator({\n        preproject,\n        fp64: this.use64bitPositions(),\n        IndexType: !gl || (0,features/* hasFeatures */.ag)(gl, webgl_features_table/* FEATURES.ELEMENT_INDEX_UINT32 */.h.ELEMENT_INDEX_UINT32) ? Uint32Array : Uint16Array\n      })\n    });\n    const attributeManager = this.getAttributeManager();\n    const noAlloc = true;\n    attributeManager.remove(['instancePickingColors']);\n    attributeManager.add({\n      indices: {\n        size: 1,\n        isIndexed: true,\n        update: this.calculateIndices,\n        noAlloc\n      },\n      positions: {\n        size: 3,\n        type: 5130,\n        fp64: this.use64bitPositions(),\n        transition: ATTRIBUTE_TRANSITION,\n        accessor: 'getPolygon',\n        update: this.calculatePositions,\n        noAlloc,\n        shaderAttributes: {\n          positions: {\n            vertexOffset: 0,\n            divisor: 0\n          },\n          instancePositions: {\n            vertexOffset: 0,\n            divisor: 1\n          },\n          nextPositions: {\n            vertexOffset: 1,\n            divisor: 1\n          }\n        }\n      },\n      vertexValid: {\n        size: 1,\n        divisor: 1,\n        type: 5121,\n        update: this.calculateVertexValid,\n        noAlloc\n      },\n      elevations: {\n        size: 1,\n        transition: ATTRIBUTE_TRANSITION,\n        accessor: 'getElevation',\n        shaderAttributes: {\n          elevations: {\n            divisor: 0\n          },\n          instanceElevations: {\n            divisor: 1\n          }\n        }\n      },\n      fillColors: {\n        size: this.props.colorFormat.length,\n        type: 5121,\n        normalized: true,\n        transition: ATTRIBUTE_TRANSITION,\n        accessor: 'getFillColor',\n        defaultValue: DEFAULT_COLOR,\n        shaderAttributes: {\n          fillColors: {\n            divisor: 0\n          },\n          instanceFillColors: {\n            divisor: 1\n          }\n        }\n      },\n      lineColors: {\n        size: this.props.colorFormat.length,\n        type: 5121,\n        normalized: true,\n        transition: ATTRIBUTE_TRANSITION,\n        accessor: 'getLineColor',\n        defaultValue: DEFAULT_COLOR,\n        shaderAttributes: {\n          lineColors: {\n            divisor: 0\n          },\n          instanceLineColors: {\n            divisor: 1\n          }\n        }\n      },\n      pickingColors: {\n        size: 3,\n        type: 5121,\n        accessor: (object, {\n          index,\n          target: value\n        }) => this.encodePickingColor(object && object.__source ? object.__source.index : index, value),\n        shaderAttributes: {\n          pickingColors: {\n            divisor: 0\n          },\n          instancePickingColors: {\n            divisor: 1\n          }\n        }\n      }\n    });\n  }\n\n  getPickingInfo(params) {\n    const info = super.getPickingInfo(params);\n    const {\n      index\n    } = info;\n    const {\n      data\n    } = this.props;\n\n    if (data[0] && data[0].__source) {\n      info.object = data.find(d => d.__source.index === index);\n    }\n\n    return info;\n  }\n\n  disablePickingIndex(objectIndex) {\n    const {\n      data\n    } = this.props;\n\n    if (data[0] && data[0].__source) {\n      for (let i = 0; i < data.length; i++) {\n        if (data[i].__source.index === objectIndex) {\n          this._disablePickingIndex(i);\n        }\n      }\n    } else {\n      this._disablePickingIndex(objectIndex);\n    }\n  }\n\n  draw({\n    uniforms\n  }) {\n    const {\n      extruded,\n      filled,\n      wireframe,\n      elevationScale\n    } = this.props;\n    const {\n      topModel,\n      sideModel,\n      polygonTesselator\n    } = this.state;\n    const renderUniforms = { ...uniforms,\n      extruded: Boolean(extruded),\n      elevationScale\n    };\n\n    if (sideModel) {\n      sideModel.setInstanceCount(polygonTesselator.instanceCount - 1);\n      sideModel.setUniforms(renderUniforms);\n\n      if (wireframe) {\n        sideModel.setDrawMode(3);\n        sideModel.setUniforms({\n          isWireframe: true\n        }).draw();\n      }\n\n      if (filled) {\n        sideModel.setDrawMode(6);\n        sideModel.setUniforms({\n          isWireframe: false\n        }).draw();\n      }\n    }\n\n    if (topModel) {\n      topModel.setVertexCount(polygonTesselator.vertexCount);\n      topModel.setUniforms(renderUniforms).draw();\n    }\n  }\n\n  updateState(updateParams) {\n    super.updateState(updateParams);\n    this.updateGeometry(updateParams);\n    const {\n      props,\n      oldProps,\n      changeFlags\n    } = updateParams;\n    const attributeManager = this.getAttributeManager();\n    const regenerateModels = changeFlags.extensionsChanged || props.filled !== oldProps.filled || props.extruded !== oldProps.extruded;\n\n    if (regenerateModels) {\n      var _this$state$models;\n\n      (_this$state$models = this.state.models) === null || _this$state$models === void 0 ? void 0 : _this$state$models.forEach(model => model.delete());\n      this.setState(this._getModels(this.context.gl));\n      attributeManager.invalidateAll();\n    }\n  }\n\n  updateGeometry({\n    props,\n    oldProps,\n    changeFlags\n  }) {\n    const geometryConfigChanged = changeFlags.dataChanged || changeFlags.updateTriggersChanged && (changeFlags.updateTriggersChanged.all || changeFlags.updateTriggersChanged.getPolygon);\n\n    if (geometryConfigChanged) {\n      const {\n        polygonTesselator\n      } = this.state;\n      const buffers = props.data.attributes || {};\n      polygonTesselator.updateGeometry({\n        data: props.data,\n        normalize: props._normalize,\n        geometryBuffer: buffers.getPolygon,\n        buffers,\n        getGeometry: props.getPolygon,\n        positionFormat: props.positionFormat,\n        wrapLongitude: props.wrapLongitude,\n        resolution: this.context.viewport.resolution,\n        fp64: this.use64bitPositions(),\n        dataChanged: changeFlags.dataChanged,\n        full3d: props._full3d\n      });\n      this.setState({\n        numInstances: polygonTesselator.instanceCount,\n        startIndices: polygonTesselator.vertexStarts\n      });\n\n      if (!changeFlags.dataChanged) {\n        this.getAttributeManager().invalidateAll();\n      }\n    }\n  }\n\n  _getModels(gl) {\n    const {\n      id,\n      filled,\n      extruded\n    } = this.props;\n    let topModel;\n    let sideModel;\n\n    if (filled) {\n      const shaders = this.getShaders('top');\n      shaders.defines.NON_INSTANCED_MODEL = 1;\n      topModel = new model/* default */.Z(gl, { ...shaders,\n        id: \"\".concat(id, \"-top\"),\n        drawMode: 4,\n        attributes: {\n          vertexPositions: new Float32Array([0, 1])\n        },\n        uniforms: {\n          isWireframe: false,\n          isSideVertex: false\n        },\n        vertexCount: 0,\n        isIndexed: true\n      });\n    }\n\n    if (extruded) {\n      sideModel = new model/* default */.Z(gl, { ...this.getShaders('side'),\n        id: \"\".concat(id, \"-side\"),\n        geometry: new geometry/* default */.Z({\n          drawMode: 1,\n          vertexCount: 4,\n          attributes: {\n            vertexPositions: {\n              size: 2,\n              value: new Float32Array([1, 0, 0, 0, 0, 1, 1, 1])\n            }\n          }\n        }),\n        instanceCount: 0,\n        isInstanced: 1\n      });\n      sideModel.userData.excludeAttributes = {\n        indices: true\n      };\n    }\n\n    return {\n      models: [sideModel, topModel].filter(Boolean),\n      topModel,\n      sideModel\n    };\n  }\n\n  calculateIndices(attribute) {\n    const {\n      polygonTesselator\n    } = this.state;\n    attribute.startIndices = polygonTesselator.indexStarts;\n    attribute.value = polygonTesselator.get('indices');\n  }\n\n  calculatePositions(attribute) {\n    const {\n      polygonTesselator\n    } = this.state;\n    attribute.startIndices = polygonTesselator.vertexStarts;\n    attribute.value = polygonTesselator.get('positions');\n  }\n\n  calculateVertexValid(attribute) {\n    attribute.value = this.state.polygonTesselator.get('vertexValid');\n  }\n\n}\n\n(0,defineProperty/* default */.Z)(SolidPolygonLayer, \"defaultProps\", defaultProps);\n\n(0,defineProperty/* default */.Z)(SolidPolygonLayer, \"layerName\", 'SolidPolygonLayer');\n//# sourceMappingURL=solid-polygon-layer.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBLGlDQUFlOztBQUVmLGlDQUFlO0FBQ2YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly92dWUzLXdlYnBhY2s1Ly4vbm9kZV9tb2R1bGVzL0BkZWNrLmdsL2xheWVycy9kaXN0L2VzbS9zb2xpZC1wb2x5Z29uLWxheWVyL3BvbHlnb24tdGVzc2VsYXRvci5qcz82OTY2Iiwid2VicGFjazovL3Z1ZTMtd2VicGFjazUvLi9ub2RlX21vZHVsZXMvQGRlY2suZ2wvbGF5ZXJzL2Rpc3QvZXNtL3NvbGlkLXBvbHlnb24tbGF5ZXIvc29saWQtcG9seWdvbi1sYXllci12ZXJ0ZXgtbWFpbi5nbHNsLmpzP2JmZDgiLCJ3ZWJwYWNrOi8vdnVlMy13ZWJwYWNrNS8uL25vZGVfbW9kdWxlcy9AZGVjay5nbC9sYXllcnMvZGlzdC9lc20vc29saWQtcG9seWdvbi1sYXllci9zb2xpZC1wb2x5Z29uLWxheWVyLXZlcnRleC10b3AuZ2xzbC5qcz8yZTA3Iiwid2VicGFjazovL3Z1ZTMtd2VicGFjazUvLi9ub2RlX21vZHVsZXMvQGRlY2suZ2wvbGF5ZXJzL2Rpc3QvZXNtL3NvbGlkLXBvbHlnb24tbGF5ZXIvc29saWQtcG9seWdvbi1sYXllci12ZXJ0ZXgtc2lkZS5nbHNsLmpzPzlmNTQiLCJ3ZWJwYWNrOi8vdnVlMy13ZWJwYWNrNS8uL25vZGVfbW9kdWxlcy9AZGVjay5nbC9sYXllcnMvZGlzdC9lc20vc29saWQtcG9seWdvbi1sYXllci9zb2xpZC1wb2x5Z29uLWxheWVyLWZyYWdtZW50Lmdsc2wuanM/NTVmMyIsIndlYnBhY2s6Ly92dWUzLXdlYnBhY2s1Ly4vbm9kZV9tb2R1bGVzL0BkZWNrLmdsL2xheWVycy9kaXN0L2VzbS9zb2xpZC1wb2x5Z29uLWxheWVyL3NvbGlkLXBvbHlnb24tbGF5ZXIuanM/NzIyOCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgKiBhcyBQb2x5Z29uIGZyb20gJy4vcG9seWdvbic7XG5pbXBvcnQgeyBUZXNzZWxhdG9yIH0gZnJvbSAnQGRlY2suZ2wvY29yZSc7XG5pbXBvcnQgeyBjdXRQb2x5Z29uQnlHcmlkLCBjdXRQb2x5Z29uQnlNZXJjYXRvckJvdW5kcyB9IGZyb20gJ0BtYXRoLmdsL3BvbHlnb24nO1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgUG9seWdvblRlc3NlbGF0b3IgZXh0ZW5kcyBUZXNzZWxhdG9yIHtcbiAgY29uc3RydWN0b3Iob3B0cykge1xuICAgIGNvbnN0IHtcbiAgICAgIGZwNjQsXG4gICAgICBJbmRleFR5cGUgPSBVaW50MzJBcnJheVxuICAgIH0gPSBvcHRzO1xuICAgIHN1cGVyKHsgLi4ub3B0cyxcbiAgICAgIGF0dHJpYnV0ZXM6IHtcbiAgICAgICAgcG9zaXRpb25zOiB7XG4gICAgICAgICAgc2l6ZTogMyxcbiAgICAgICAgICB0eXBlOiBmcDY0ID8gRmxvYXQ2NEFycmF5IDogRmxvYXQzMkFycmF5XG4gICAgICAgIH0sXG4gICAgICAgIHZlcnRleFZhbGlkOiB7XG4gICAgICAgICAgdHlwZTogVWludDhDbGFtcGVkQXJyYXksXG4gICAgICAgICAgc2l6ZTogMVxuICAgICAgICB9LFxuICAgICAgICBpbmRpY2VzOiB7XG4gICAgICAgICAgdHlwZTogSW5kZXhUeXBlLFxuICAgICAgICAgIHNpemU6IDFcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgZ2V0KGF0dHJpYnV0ZU5hbWUpIHtcbiAgICBjb25zdCB7XG4gICAgICBhdHRyaWJ1dGVzXG4gICAgfSA9IHRoaXM7XG5cbiAgICBpZiAoYXR0cmlidXRlTmFtZSA9PT0gJ2luZGljZXMnKSB7XG4gICAgICByZXR1cm4gYXR0cmlidXRlcy5pbmRpY2VzICYmIGF0dHJpYnV0ZXMuaW5kaWNlcy5zdWJhcnJheSgwLCB0aGlzLnZlcnRleENvdW50KTtcbiAgICB9XG5cbiAgICByZXR1cm4gYXR0cmlidXRlc1thdHRyaWJ1dGVOYW1lXTtcbiAgfVxuXG4gIHVwZGF0ZUdlb21ldHJ5KG9wdHMpIHtcbiAgICBzdXBlci51cGRhdGVHZW9tZXRyeShvcHRzKTtcbiAgICBjb25zdCBleHRlcm5hbEluZGljZXMgPSB0aGlzLmJ1ZmZlcnMuaW5kaWNlcztcblxuICAgIGlmIChleHRlcm5hbEluZGljZXMpIHtcbiAgICAgIHRoaXMudmVydGV4Q291bnQgPSAoZXh0ZXJuYWxJbmRpY2VzLnZhbHVlIHx8IGV4dGVybmFsSW5kaWNlcykubGVuZ3RoO1xuICAgIH0gZWxzZSBpZiAodGhpcy5kYXRhICYmICF0aGlzLmdldEdlb21ldHJ5KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ21pc3NpbmcgaW5kaWNlcyBidWZmZXInKTtcbiAgICB9XG4gIH1cblxuICBub3JtYWxpemVHZW9tZXRyeShwb2x5Z29uKSB7XG4gICAgaWYgKHRoaXMubm9ybWFsaXplKSB7XG4gICAgICBjb25zdCBub3JtYWxpemVkUG9seWdvbiA9IFBvbHlnb24ubm9ybWFsaXplKHBvbHlnb24sIHRoaXMucG9zaXRpb25TaXplKTtcblxuICAgICAgaWYgKHRoaXMub3B0cy5yZXNvbHV0aW9uKSB7XG4gICAgICAgIHJldHVybiBjdXRQb2x5Z29uQnlHcmlkKFBvbHlnb24uZ2V0UG9zaXRpb25zKG5vcm1hbGl6ZWRQb2x5Z29uKSwgUG9seWdvbi5nZXRIb2xlSW5kaWNlcyhub3JtYWxpemVkUG9seWdvbiksIHtcbiAgICAgICAgICBzaXplOiB0aGlzLnBvc2l0aW9uU2l6ZSxcbiAgICAgICAgICBncmlkUmVzb2x1dGlvbjogdGhpcy5vcHRzLnJlc29sdXRpb24sXG4gICAgICAgICAgZWRnZVR5cGVzOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5vcHRzLndyYXBMb25naXR1ZGUpIHtcbiAgICAgICAgcmV0dXJuIGN1dFBvbHlnb25CeU1lcmNhdG9yQm91bmRzKFBvbHlnb24uZ2V0UG9zaXRpb25zKG5vcm1hbGl6ZWRQb2x5Z29uKSwgUG9seWdvbi5nZXRIb2xlSW5kaWNlcyhub3JtYWxpemVkUG9seWdvbiksIHtcbiAgICAgICAgICBzaXplOiB0aGlzLnBvc2l0aW9uU2l6ZSxcbiAgICAgICAgICBtYXhMYXRpdHVkZTogODYsXG4gICAgICAgICAgZWRnZVR5cGVzOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gbm9ybWFsaXplZFBvbHlnb247XG4gICAgfVxuXG4gICAgcmV0dXJuIHBvbHlnb247XG4gIH1cblxuICBnZXRHZW9tZXRyeVNpemUocG9seWdvbikge1xuICAgIGlmIChpc0N1dChwb2x5Z29uKSkge1xuICAgICAgbGV0IHNpemUgPSAwO1xuXG4gICAgICBmb3IgKGNvbnN0IHN1YlBvbHlnb24gb2YgcG9seWdvbikge1xuICAgICAgICBzaXplICs9IHRoaXMuZ2V0R2VvbWV0cnlTaXplKHN1YlBvbHlnb24pO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gc2l6ZTtcbiAgICB9XG5cbiAgICByZXR1cm4gUG9seWdvbi5nZXRQb3NpdGlvbnMocG9seWdvbikubGVuZ3RoIC8gdGhpcy5wb3NpdGlvblNpemU7XG4gIH1cblxuICBnZXRHZW9tZXRyeUZyb21CdWZmZXIoYnVmZmVyKSB7XG4gICAgaWYgKHRoaXMubm9ybWFsaXplIHx8ICF0aGlzLmJ1ZmZlcnMuaW5kaWNlcykge1xuICAgICAgcmV0dXJuIHN1cGVyLmdldEdlb21ldHJ5RnJvbUJ1ZmZlcihidWZmZXIpO1xuICAgIH1cblxuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgdXBkYXRlR2VvbWV0cnlBdHRyaWJ1dGVzKHBvbHlnb24sIGNvbnRleHQpIHtcbiAgICBpZiAocG9seWdvbiAmJiBpc0N1dChwb2x5Z29uKSkge1xuICAgICAgZm9yIChjb25zdCBzdWJQb2x5Z29uIG9mIHBvbHlnb24pIHtcbiAgICAgICAgY29uc3QgZ2VvbWV0cnlTaXplID0gdGhpcy5nZXRHZW9tZXRyeVNpemUoc3ViUG9seWdvbik7XG4gICAgICAgIGNvbnRleHQuZ2VvbWV0cnlTaXplID0gZ2VvbWV0cnlTaXplO1xuICAgICAgICB0aGlzLnVwZGF0ZUdlb21ldHJ5QXR0cmlidXRlcyhzdWJQb2x5Z29uLCBjb250ZXh0KTtcbiAgICAgICAgY29udGV4dC52ZXJ0ZXhTdGFydCArPSBnZW9tZXRyeVNpemU7XG4gICAgICAgIGNvbnRleHQuaW5kZXhTdGFydCA9IHRoaXMuaW5kZXhTdGFydHNbY29udGV4dC5nZW9tZXRyeUluZGV4ICsgMV07XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX3VwZGF0ZUluZGljZXMocG9seWdvbiwgY29udGV4dCk7XG5cbiAgICAgIHRoaXMuX3VwZGF0ZVBvc2l0aW9ucyhwb2x5Z29uLCBjb250ZXh0KTtcblxuICAgICAgdGhpcy5fdXBkYXRlVmVydGV4VmFsaWQocG9seWdvbiwgY29udGV4dCk7XG4gICAgfVxuICB9XG5cbiAgX3VwZGF0ZUluZGljZXMocG9seWdvbiwge1xuICAgIGdlb21ldHJ5SW5kZXgsXG4gICAgdmVydGV4U3RhcnQ6IG9mZnNldCxcbiAgICBpbmRleFN0YXJ0XG4gIH0pIHtcbiAgICBjb25zdCB7XG4gICAgICBhdHRyaWJ1dGVzLFxuICAgICAgaW5kZXhTdGFydHMsXG4gICAgICB0eXBlZEFycmF5TWFuYWdlclxuICAgIH0gPSB0aGlzO1xuICAgIGxldCB0YXJnZXQgPSBhdHRyaWJ1dGVzLmluZGljZXM7XG5cbiAgICBpZiAoIXRhcmdldCB8fCAhcG9seWdvbikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGxldCBpID0gaW5kZXhTdGFydDtcbiAgICBjb25zdCBpbmRpY2VzID0gUG9seWdvbi5nZXRTdXJmYWNlSW5kaWNlcyhwb2x5Z29uLCB0aGlzLnBvc2l0aW9uU2l6ZSwgdGhpcy5vcHRzLnByZXByb2plY3QsIHRoaXMub3B0cy5mdWxsM2QpO1xuICAgIHRhcmdldCA9IHR5cGVkQXJyYXlNYW5hZ2VyLmFsbG9jYXRlKHRhcmdldCwgaW5kZXhTdGFydCArIGluZGljZXMubGVuZ3RoLCB7XG4gICAgICBjb3B5OiB0cnVlXG4gICAgfSk7XG5cbiAgICBmb3IgKGxldCBqID0gMDsgaiA8IGluZGljZXMubGVuZ3RoOyBqKyspIHtcbiAgICAgIHRhcmdldFtpKytdID0gaW5kaWNlc1tqXSArIG9mZnNldDtcbiAgICB9XG5cbiAgICBpbmRleFN0YXJ0c1tnZW9tZXRyeUluZGV4ICsgMV0gPSBpbmRleFN0YXJ0ICsgaW5kaWNlcy5sZW5ndGg7XG4gICAgYXR0cmlidXRlcy5pbmRpY2VzID0gdGFyZ2V0O1xuICB9XG5cbiAgX3VwZGF0ZVBvc2l0aW9ucyhwb2x5Z29uLCB7XG4gICAgdmVydGV4U3RhcnQsXG4gICAgZ2VvbWV0cnlTaXplXG4gIH0pIHtcbiAgICBjb25zdCB7XG4gICAgICBhdHRyaWJ1dGVzOiB7XG4gICAgICAgIHBvc2l0aW9uc1xuICAgICAgfSxcbiAgICAgIHBvc2l0aW9uU2l6ZVxuICAgIH0gPSB0aGlzO1xuXG4gICAgaWYgKCFwb3NpdGlvbnMgfHwgIXBvbHlnb24pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCBwb2x5Z29uUG9zaXRpb25zID0gUG9seWdvbi5nZXRQb3NpdGlvbnMocG9seWdvbik7XG5cbiAgICBmb3IgKGxldCBpID0gdmVydGV4U3RhcnQsIGogPSAwOyBqIDwgZ2VvbWV0cnlTaXplOyBpKyssIGorKykge1xuICAgICAgY29uc3QgeCA9IHBvbHlnb25Qb3NpdGlvbnNbaiAqIHBvc2l0aW9uU2l6ZV07XG4gICAgICBjb25zdCB5ID0gcG9seWdvblBvc2l0aW9uc1tqICogcG9zaXRpb25TaXplICsgMV07XG4gICAgICBjb25zdCB6ID0gcG9zaXRpb25TaXplID4gMiA/IHBvbHlnb25Qb3NpdGlvbnNbaiAqIHBvc2l0aW9uU2l6ZSArIDJdIDogMDtcbiAgICAgIHBvc2l0aW9uc1tpICogM10gPSB4O1xuICAgICAgcG9zaXRpb25zW2kgKiAzICsgMV0gPSB5O1xuICAgICAgcG9zaXRpb25zW2kgKiAzICsgMl0gPSB6O1xuICAgIH1cbiAgfVxuXG4gIF91cGRhdGVWZXJ0ZXhWYWxpZChwb2x5Z29uLCB7XG4gICAgdmVydGV4U3RhcnQsXG4gICAgZ2VvbWV0cnlTaXplXG4gIH0pIHtcbiAgICBjb25zdCB7XG4gICAgICBwb3NpdGlvblNpemVcbiAgICB9ID0gdGhpcztcbiAgICBjb25zdCB2ZXJ0ZXhWYWxpZCA9IHRoaXMuYXR0cmlidXRlcy52ZXJ0ZXhWYWxpZDtcbiAgICBjb25zdCBob2xlSW5kaWNlcyA9IHBvbHlnb24gJiYgUG9seWdvbi5nZXRIb2xlSW5kaWNlcyhwb2x5Z29uKTtcblxuICAgIGlmIChwb2x5Z29uICYmIHBvbHlnb24uZWRnZVR5cGVzKSB7XG4gICAgICB2ZXJ0ZXhWYWxpZC5zZXQocG9seWdvbi5lZGdlVHlwZXMsIHZlcnRleFN0YXJ0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmVydGV4VmFsaWQuZmlsbCgxLCB2ZXJ0ZXhTdGFydCwgdmVydGV4U3RhcnQgKyBnZW9tZXRyeVNpemUpO1xuICAgIH1cblxuICAgIGlmIChob2xlSW5kaWNlcykge1xuICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBob2xlSW5kaWNlcy5sZW5ndGg7IGorKykge1xuICAgICAgICB2ZXJ0ZXhWYWxpZFt2ZXJ0ZXhTdGFydCArIGhvbGVJbmRpY2VzW2pdIC8gcG9zaXRpb25TaXplIC0gMV0gPSAwO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZlcnRleFZhbGlkW3ZlcnRleFN0YXJ0ICsgZ2VvbWV0cnlTaXplIC0gMV0gPSAwO1xuICB9XG5cbn1cblxuZnVuY3Rpb24gaXNDdXQocG9seWdvbikge1xuICByZXR1cm4gQXJyYXkuaXNBcnJheShwb2x5Z29uKSAmJiBwb2x5Z29uLmxlbmd0aCA+IDAgJiYgIU51bWJlci5pc0Zpbml0ZShwb2x5Z29uWzBdKTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXBvbHlnb24tdGVzc2VsYXRvci5qcy5tYXAiLCJleHBvcnQgZGVmYXVsdCBcIlxcbmF0dHJpYnV0ZSB2ZWMyIHZlcnRleFBvc2l0aW9ucztcXG5hdHRyaWJ1dGUgZmxvYXQgdmVydGV4VmFsaWQ7XFxuXFxudW5pZm9ybSBib29sIGV4dHJ1ZGVkO1xcbnVuaWZvcm0gYm9vbCBpc1dpcmVmcmFtZTtcXG51bmlmb3JtIGZsb2F0IGVsZXZhdGlvblNjYWxlO1xcbnVuaWZvcm0gZmxvYXQgb3BhY2l0eTtcXG5cXG52YXJ5aW5nIHZlYzQgdkNvbG9yO1xcblxcbnN0cnVjdCBQb2x5Z29uUHJvcHMge1xcbiAgdmVjNCBmaWxsQ29sb3JzO1xcbiAgdmVjNCBsaW5lQ29sb3JzO1xcbiAgdmVjMyBwb3NpdGlvbnM7XFxuICB2ZWMzIG5leHRQb3NpdGlvbnM7XFxuICB2ZWMzIHBpY2tpbmdDb2xvcnM7XFxuICB2ZWMzIHBvc2l0aW9uczY0TG93O1xcbiAgdmVjMyBuZXh0UG9zaXRpb25zNjRMb3c7XFxuICBmbG9hdCBlbGV2YXRpb25zO1xcbn07XFxuXFxudmVjMyBwcm9qZWN0X29mZnNldF9ub3JtYWwodmVjMyB2ZWN0b3IpIHtcXG4gIGlmIChwcm9qZWN0X3VDb29yZGluYXRlU3lzdGVtID09IENPT1JESU5BVEVfU1lTVEVNX0xOR0xBVCB8fFxcbiAgICBwcm9qZWN0X3VDb29yZGluYXRlU3lzdGVtID09IENPT1JESU5BVEVfU1lTVEVNX0xOR0xBVF9PRkZTRVRTKSB7XFxuICAgIHJldHVybiBub3JtYWxpemUodmVjdG9yICogcHJvamVjdF91Q29tbW9uVW5pdHNQZXJXb3JsZFVuaXQpO1xcbiAgfVxcbiAgcmV0dXJuIHByb2plY3Rfbm9ybWFsKHZlY3Rvcik7XFxufVxcblxcbnZvaWQgY2FsY3VsYXRlUG9zaXRpb24oUG9seWdvblByb3BzIHByb3BzKSB7XFxuI2lmZGVmIElTX1NJREVfVkVSVEVYXFxuICBpZih2ZXJ0ZXhWYWxpZCA8IDAuNSl7XFxuICAgIGdsX1Bvc2l0aW9uID0gdmVjNCgwLik7XFxuICAgIHJldHVybjtcXG4gIH1cXG4jZW5kaWZcXG5cXG4gIHZlYzMgcG9zO1xcbiAgdmVjMyBwb3M2NExvdztcXG4gIHZlYzMgbm9ybWFsO1xcbiAgdmVjNCBjb2xvcnMgPSBpc1dpcmVmcmFtZSA/IHByb3BzLmxpbmVDb2xvcnMgOiBwcm9wcy5maWxsQ29sb3JzO1xcblxcbiAgZ2VvbWV0cnkud29ybGRQb3NpdGlvbiA9IHByb3BzLnBvc2l0aW9ucztcXG4gIGdlb21ldHJ5LndvcmxkUG9zaXRpb25BbHQgPSBwcm9wcy5uZXh0UG9zaXRpb25zO1xcbiAgZ2VvbWV0cnkucGlja2luZ0NvbG9yID0gcHJvcHMucGlja2luZ0NvbG9ycztcXG5cXG4jaWZkZWYgSVNfU0lERV9WRVJURVhcXG4gIHBvcyA9IG1peChwcm9wcy5wb3NpdGlvbnMsIHByb3BzLm5leHRQb3NpdGlvbnMsIHZlcnRleFBvc2l0aW9ucy54KTtcXG4gIHBvczY0TG93ID0gbWl4KHByb3BzLnBvc2l0aW9uczY0TG93LCBwcm9wcy5uZXh0UG9zaXRpb25zNjRMb3csIHZlcnRleFBvc2l0aW9ucy54KTtcXG4jZWxzZVxcbiAgcG9zID0gcHJvcHMucG9zaXRpb25zO1xcbiAgcG9zNjRMb3cgPSBwcm9wcy5wb3NpdGlvbnM2NExvdztcXG4jZW5kaWZcXG5cXG4gIGlmIChleHRydWRlZCkge1xcbiAgICBwb3MueiArPSBwcm9wcy5lbGV2YXRpb25zICogdmVydGV4UG9zaXRpb25zLnkgKiBlbGV2YXRpb25TY2FsZTtcXG4gIH1cXG4gIGdsX1Bvc2l0aW9uID0gcHJvamVjdF9wb3NpdGlvbl90b19jbGlwc3BhY2UocG9zLCBwb3M2NExvdywgdmVjMygwLiksIGdlb21ldHJ5LnBvc2l0aW9uKTtcXG5cXG4gIERFQ0tHTF9GSUxURVJfR0xfUE9TSVRJT04oZ2xfUG9zaXRpb24sIGdlb21ldHJ5KTtcXG5cXG4gIGlmIChleHRydWRlZCkge1xcbiAgI2lmZGVmIElTX1NJREVfVkVSVEVYXFxuICAgIG5vcm1hbCA9IHZlYzMoXFxuICAgICAgcHJvcHMucG9zaXRpb25zLnkgLSBwcm9wcy5uZXh0UG9zaXRpb25zLnkgKyAocHJvcHMucG9zaXRpb25zNjRMb3cueSAtIHByb3BzLm5leHRQb3NpdGlvbnM2NExvdy55KSxcXG4gICAgICBwcm9wcy5uZXh0UG9zaXRpb25zLnggLSBwcm9wcy5wb3NpdGlvbnMueCArIChwcm9wcy5uZXh0UG9zaXRpb25zNjRMb3cueCAtIHByb3BzLnBvc2l0aW9uczY0TG93LngpLFxcbiAgICAgIDAuMCk7XFxuICAgIG5vcm1hbCA9IHByb2plY3Rfb2Zmc2V0X25vcm1hbChub3JtYWwpO1xcbiAgI2Vsc2VcXG4gICAgbm9ybWFsID0gcHJvamVjdF9ub3JtYWwodmVjMygwLjAsIDAuMCwgMS4wKSk7XFxuICAjZW5kaWZcXG4gICAgZ2VvbWV0cnkubm9ybWFsID0gbm9ybWFsO1xcbiAgICB2ZWMzIGxpZ2h0Q29sb3IgPSBsaWdodGluZ19nZXRMaWdodENvbG9yKGNvbG9ycy5yZ2IsIHByb2plY3RfdUNhbWVyYVBvc2l0aW9uLCBnZW9tZXRyeS5wb3NpdGlvbi54eXosIG5vcm1hbCk7XFxuICAgIHZDb2xvciA9IHZlYzQobGlnaHRDb2xvciwgY29sb3JzLmEgKiBvcGFjaXR5KTtcXG4gIH0gZWxzZSB7XFxuICAgIHZDb2xvciA9IHZlYzQoY29sb3JzLnJnYiwgY29sb3JzLmEgKiBvcGFjaXR5KTtcXG4gIH1cXG4gIERFQ0tHTF9GSUxURVJfQ09MT1IodkNvbG9yLCBnZW9tZXRyeSk7XFxufVxcblwiO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c29saWQtcG9seWdvbi1sYXllci12ZXJ0ZXgtbWFpbi5nbHNsLmpzLm1hcCIsImltcG9ydCBtYWluIGZyb20gJy4vc29saWQtcG9seWdvbi1sYXllci12ZXJ0ZXgtbWFpbi5nbHNsJztcbmV4cG9ydCBkZWZhdWx0IFwiI2RlZmluZSBTSEFERVJfTkFNRSBzb2xpZC1wb2x5Z29uLWxheWVyLXZlcnRleC1zaGFkZXJcXG5cXG5hdHRyaWJ1dGUgdmVjMyBwb3NpdGlvbnM7XFxuYXR0cmlidXRlIHZlYzMgcG9zaXRpb25zNjRMb3c7XFxuYXR0cmlidXRlIGZsb2F0IGVsZXZhdGlvbnM7XFxuYXR0cmlidXRlIHZlYzQgZmlsbENvbG9ycztcXG5hdHRyaWJ1dGUgdmVjNCBsaW5lQ29sb3JzO1xcbmF0dHJpYnV0ZSB2ZWMzIHBpY2tpbmdDb2xvcnM7XFxuXFxuXCIuY29uY2F0KG1haW4sIFwiXFxuXFxudm9pZCBtYWluKHZvaWQpIHtcXG4gIFBvbHlnb25Qcm9wcyBwcm9wcztcXG5cXG4gIHByb3BzLnBvc2l0aW9ucyA9IHBvc2l0aW9ucztcXG4gIHByb3BzLnBvc2l0aW9uczY0TG93ID0gcG9zaXRpb25zNjRMb3c7XFxuICBwcm9wcy5lbGV2YXRpb25zID0gZWxldmF0aW9ucztcXG4gIHByb3BzLmZpbGxDb2xvcnMgPSBmaWxsQ29sb3JzO1xcbiAgcHJvcHMubGluZUNvbG9ycyA9IGxpbmVDb2xvcnM7XFxuICBwcm9wcy5waWNraW5nQ29sb3JzID0gcGlja2luZ0NvbG9ycztcXG5cXG4gIGNhbGN1bGF0ZVBvc2l0aW9uKHByb3BzKTtcXG59XFxuXCIpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c29saWQtcG9seWdvbi1sYXllci12ZXJ0ZXgtdG9wLmdsc2wuanMubWFwIiwiaW1wb3J0IG1haW4gZnJvbSAnLi9zb2xpZC1wb2x5Z29uLWxheWVyLXZlcnRleC1tYWluLmdsc2wnO1xuZXhwb3J0IGRlZmF1bHQgXCIjZGVmaW5lIFNIQURFUl9OQU1FIHNvbGlkLXBvbHlnb24tbGF5ZXItdmVydGV4LXNoYWRlci1zaWRlXFxuI2RlZmluZSBJU19TSURFX1ZFUlRFWFxcblxcblxcbmF0dHJpYnV0ZSB2ZWMzIGluc3RhbmNlUG9zaXRpb25zO1xcbmF0dHJpYnV0ZSB2ZWMzIG5leHRQb3NpdGlvbnM7XFxuYXR0cmlidXRlIHZlYzMgaW5zdGFuY2VQb3NpdGlvbnM2NExvdztcXG5hdHRyaWJ1dGUgdmVjMyBuZXh0UG9zaXRpb25zNjRMb3c7XFxuYXR0cmlidXRlIGZsb2F0IGluc3RhbmNlRWxldmF0aW9ucztcXG5hdHRyaWJ1dGUgdmVjNCBpbnN0YW5jZUZpbGxDb2xvcnM7XFxuYXR0cmlidXRlIHZlYzQgaW5zdGFuY2VMaW5lQ29sb3JzO1xcbmF0dHJpYnV0ZSB2ZWMzIGluc3RhbmNlUGlja2luZ0NvbG9ycztcXG5cXG5cIi5jb25jYXQobWFpbiwgXCJcXG5cXG52b2lkIG1haW4odm9pZCkge1xcbiAgUG9seWdvblByb3BzIHByb3BzO1xcblxcbiAgI2lmIFJJTkdfV0lORElOR19PUkRFUl9DVyA9PSAxXFxuICAgIHByb3BzLnBvc2l0aW9ucyA9IGluc3RhbmNlUG9zaXRpb25zO1xcbiAgICBwcm9wcy5wb3NpdGlvbnM2NExvdyA9IGluc3RhbmNlUG9zaXRpb25zNjRMb3c7XFxuICAgIHByb3BzLm5leHRQb3NpdGlvbnMgPSBuZXh0UG9zaXRpb25zO1xcbiAgICBwcm9wcy5uZXh0UG9zaXRpb25zNjRMb3cgPSBuZXh0UG9zaXRpb25zNjRMb3c7XFxuICAjZWxzZVxcbiAgICBwcm9wcy5wb3NpdGlvbnMgPSBuZXh0UG9zaXRpb25zO1xcbiAgICBwcm9wcy5wb3NpdGlvbnM2NExvdyA9IG5leHRQb3NpdGlvbnM2NExvdztcXG4gICAgcHJvcHMubmV4dFBvc2l0aW9ucyA9IGluc3RhbmNlUG9zaXRpb25zO1xcbiAgICBwcm9wcy5uZXh0UG9zaXRpb25zNjRMb3cgPSBpbnN0YW5jZVBvc2l0aW9uczY0TG93O1xcbiAgI2VuZGlmXFxuICBwcm9wcy5lbGV2YXRpb25zID0gaW5zdGFuY2VFbGV2YXRpb25zO1xcbiAgcHJvcHMuZmlsbENvbG9ycyA9IGluc3RhbmNlRmlsbENvbG9ycztcXG4gIHByb3BzLmxpbmVDb2xvcnMgPSBpbnN0YW5jZUxpbmVDb2xvcnM7XFxuICBwcm9wcy5waWNraW5nQ29sb3JzID0gaW5zdGFuY2VQaWNraW5nQ29sb3JzO1xcblxcbiAgY2FsY3VsYXRlUG9zaXRpb24ocHJvcHMpO1xcbn1cXG5cIik7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zb2xpZC1wb2x5Z29uLWxheWVyLXZlcnRleC1zaWRlLmdsc2wuanMubWFwIiwiZXhwb3J0IGRlZmF1bHQgXCIjZGVmaW5lIFNIQURFUl9OQU1FIHNvbGlkLXBvbHlnb24tbGF5ZXItZnJhZ21lbnQtc2hhZGVyXFxuXFxucHJlY2lzaW9uIGhpZ2hwIGZsb2F0O1xcblxcbnZhcnlpbmcgdmVjNCB2Q29sb3I7XFxuXFxudm9pZCBtYWluKHZvaWQpIHtcXG4gIGdsX0ZyYWdDb2xvciA9IHZDb2xvcjtcXG5cXG4gIERFQ0tHTF9GSUxURVJfQ09MT1IoZ2xfRnJhZ0NvbG9yLCBnZW9tZXRyeSk7XFxufVxcblwiO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c29saWQtcG9seWdvbi1sYXllci1mcmFnbWVudC5nbHNsLmpzLm1hcCIsImltcG9ydCBfZGVmaW5lUHJvcGVydHkgZnJvbSBcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL2RlZmluZVByb3BlcnR5XCI7XG5pbXBvcnQgeyBMYXllciwgcHJvamVjdDMyLCBnb3VyYXVkTGlnaHRpbmcsIHBpY2tpbmcsIENPT1JESU5BVEVfU1lTVEVNIH0gZnJvbSAnQGRlY2suZ2wvY29yZSc7XG5pbXBvcnQgeyBNb2RlbCwgR2VvbWV0cnksIGhhc0ZlYXR1cmVzLCBGRUFUVVJFUyB9IGZyb20gJ0BsdW1hLmdsL2NvcmUnO1xuaW1wb3J0IFBvbHlnb25UZXNzZWxhdG9yIGZyb20gJy4vcG9seWdvbi10ZXNzZWxhdG9yJztcbmltcG9ydCB2c1RvcCBmcm9tICcuL3NvbGlkLXBvbHlnb24tbGF5ZXItdmVydGV4LXRvcC5nbHNsJztcbmltcG9ydCB2c1NpZGUgZnJvbSAnLi9zb2xpZC1wb2x5Z29uLWxheWVyLXZlcnRleC1zaWRlLmdsc2wnO1xuaW1wb3J0IGZzIGZyb20gJy4vc29saWQtcG9seWdvbi1sYXllci1mcmFnbWVudC5nbHNsJztcbmNvbnN0IERFRkFVTFRfQ09MT1IgPSBbMCwgMCwgMCwgMjU1XTtcbmNvbnN0IGRlZmF1bHRQcm9wcyA9IHtcbiAgZmlsbGVkOiB0cnVlLFxuICBleHRydWRlZDogZmFsc2UsXG4gIHdpcmVmcmFtZTogZmFsc2UsXG4gIF9ub3JtYWxpemU6IHRydWUsXG4gIF93aW5kaW5nT3JkZXI6ICdDVycsXG4gIF9mdWxsM2Q6IGZhbHNlLFxuICBlbGV2YXRpb25TY2FsZToge1xuICAgIHR5cGU6ICdudW1iZXInLFxuICAgIG1pbjogMCxcbiAgICB2YWx1ZTogMVxuICB9LFxuICBnZXRQb2x5Z29uOiB7XG4gICAgdHlwZTogJ2FjY2Vzc29yJyxcbiAgICB2YWx1ZTogZiA9PiBmLnBvbHlnb25cbiAgfSxcbiAgZ2V0RWxldmF0aW9uOiB7XG4gICAgdHlwZTogJ2FjY2Vzc29yJyxcbiAgICB2YWx1ZTogMTAwMFxuICB9LFxuICBnZXRGaWxsQ29sb3I6IHtcbiAgICB0eXBlOiAnYWNjZXNzb3InLFxuICAgIHZhbHVlOiBERUZBVUxUX0NPTE9SXG4gIH0sXG4gIGdldExpbmVDb2xvcjoge1xuICAgIHR5cGU6ICdhY2Nlc3NvcicsXG4gICAgdmFsdWU6IERFRkFVTFRfQ09MT1JcbiAgfSxcbiAgbWF0ZXJpYWw6IHRydWVcbn07XG5jb25zdCBBVFRSSUJVVEVfVFJBTlNJVElPTiA9IHtcbiAgZW50ZXI6ICh2YWx1ZSwgY2h1bmspID0+IHtcbiAgICByZXR1cm4gY2h1bmsubGVuZ3RoID8gY2h1bmsuc3ViYXJyYXkoY2h1bmsubGVuZ3RoIC0gdmFsdWUubGVuZ3RoKSA6IHZhbHVlO1xuICB9XG59O1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgU29saWRQb2x5Z29uTGF5ZXIgZXh0ZW5kcyBMYXllciB7XG4gIGNvbnN0cnVjdG9yKC4uLmFyZ3MpIHtcbiAgICBzdXBlciguLi5hcmdzKTtcblxuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInN0YXRlXCIsIHZvaWQgMCk7XG4gIH1cblxuICBnZXRTaGFkZXJzKHR5cGUpIHtcbiAgICByZXR1cm4gc3VwZXIuZ2V0U2hhZGVycyh7XG4gICAgICB2czogdHlwZSA9PT0gJ3RvcCcgPyB2c1RvcCA6IHZzU2lkZSxcbiAgICAgIGZzLFxuICAgICAgZGVmaW5lczoge1xuICAgICAgICBSSU5HX1dJTkRJTkdfT1JERVJfQ1c6ICF0aGlzLnByb3BzLl9ub3JtYWxpemUgJiYgdGhpcy5wcm9wcy5fd2luZGluZ09yZGVyID09PSAnQ0NXJyA/IDAgOiAxXG4gICAgICB9LFxuICAgICAgbW9kdWxlczogW3Byb2plY3QzMiwgZ291cmF1ZExpZ2h0aW5nLCBwaWNraW5nXVxuICAgIH0pO1xuICB9XG5cbiAgZ2V0IHdyYXBMb25naXR1ZGUoKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgaW5pdGlhbGl6ZVN0YXRlKCkge1xuICAgIGNvbnN0IHtcbiAgICAgIGdsLFxuICAgICAgdmlld3BvcnRcbiAgICB9ID0gdGhpcy5jb250ZXh0O1xuICAgIGxldCB7XG4gICAgICBjb29yZGluYXRlU3lzdGVtXG4gICAgfSA9IHRoaXMucHJvcHM7XG4gICAgY29uc3Qge1xuICAgICAgX2Z1bGwzZFxuICAgIH0gPSB0aGlzLnByb3BzO1xuXG4gICAgaWYgKHZpZXdwb3J0LmlzR2Vvc3BhdGlhbCAmJiBjb29yZGluYXRlU3lzdGVtID09PSBDT09SRElOQVRFX1NZU1RFTS5ERUZBVUxUKSB7XG4gICAgICBjb29yZGluYXRlU3lzdGVtID0gQ09PUkRJTkFURV9TWVNURU0uTE5HTEFUO1xuICAgIH1cblxuICAgIGxldCBwcmVwcm9qZWN0O1xuXG4gICAgaWYgKGNvb3JkaW5hdGVTeXN0ZW0gPT09IENPT1JESU5BVEVfU1lTVEVNLkxOR0xBVCkge1xuICAgICAgaWYgKF9mdWxsM2QpIHtcbiAgICAgICAgcHJlcHJvamVjdCA9IHZpZXdwb3J0LnByb2plY3RQb3NpdGlvbi5iaW5kKHZpZXdwb3J0KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHByZXByb2plY3QgPSB2aWV3cG9ydC5wcm9qZWN0RmxhdC5iaW5kKHZpZXdwb3J0KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgIG51bUluc3RhbmNlczogMCxcbiAgICAgIHBvbHlnb25UZXNzZWxhdG9yOiBuZXcgUG9seWdvblRlc3NlbGF0b3Ioe1xuICAgICAgICBwcmVwcm9qZWN0LFxuICAgICAgICBmcDY0OiB0aGlzLnVzZTY0Yml0UG9zaXRpb25zKCksXG4gICAgICAgIEluZGV4VHlwZTogIWdsIHx8IGhhc0ZlYXR1cmVzKGdsLCBGRUFUVVJFUy5FTEVNRU5UX0lOREVYX1VJTlQzMikgPyBVaW50MzJBcnJheSA6IFVpbnQxNkFycmF5XG4gICAgICB9KVxuICAgIH0pO1xuICAgIGNvbnN0IGF0dHJpYnV0ZU1hbmFnZXIgPSB0aGlzLmdldEF0dHJpYnV0ZU1hbmFnZXIoKTtcbiAgICBjb25zdCBub0FsbG9jID0gdHJ1ZTtcbiAgICBhdHRyaWJ1dGVNYW5hZ2VyLnJlbW92ZShbJ2luc3RhbmNlUGlja2luZ0NvbG9ycyddKTtcbiAgICBhdHRyaWJ1dGVNYW5hZ2VyLmFkZCh7XG4gICAgICBpbmRpY2VzOiB7XG4gICAgICAgIHNpemU6IDEsXG4gICAgICAgIGlzSW5kZXhlZDogdHJ1ZSxcbiAgICAgICAgdXBkYXRlOiB0aGlzLmNhbGN1bGF0ZUluZGljZXMsXG4gICAgICAgIG5vQWxsb2NcbiAgICAgIH0sXG4gICAgICBwb3NpdGlvbnM6IHtcbiAgICAgICAgc2l6ZTogMyxcbiAgICAgICAgdHlwZTogNTEzMCxcbiAgICAgICAgZnA2NDogdGhpcy51c2U2NGJpdFBvc2l0aW9ucygpLFxuICAgICAgICB0cmFuc2l0aW9uOiBBVFRSSUJVVEVfVFJBTlNJVElPTixcbiAgICAgICAgYWNjZXNzb3I6ICdnZXRQb2x5Z29uJyxcbiAgICAgICAgdXBkYXRlOiB0aGlzLmNhbGN1bGF0ZVBvc2l0aW9ucyxcbiAgICAgICAgbm9BbGxvYyxcbiAgICAgICAgc2hhZGVyQXR0cmlidXRlczoge1xuICAgICAgICAgIHBvc2l0aW9uczoge1xuICAgICAgICAgICAgdmVydGV4T2Zmc2V0OiAwLFxuICAgICAgICAgICAgZGl2aXNvcjogMFxuICAgICAgICAgIH0sXG4gICAgICAgICAgaW5zdGFuY2VQb3NpdGlvbnM6IHtcbiAgICAgICAgICAgIHZlcnRleE9mZnNldDogMCxcbiAgICAgICAgICAgIGRpdmlzb3I6IDFcbiAgICAgICAgICB9LFxuICAgICAgICAgIG5leHRQb3NpdGlvbnM6IHtcbiAgICAgICAgICAgIHZlcnRleE9mZnNldDogMSxcbiAgICAgICAgICAgIGRpdmlzb3I6IDFcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICB2ZXJ0ZXhWYWxpZDoge1xuICAgICAgICBzaXplOiAxLFxuICAgICAgICBkaXZpc29yOiAxLFxuICAgICAgICB0eXBlOiA1MTIxLFxuICAgICAgICB1cGRhdGU6IHRoaXMuY2FsY3VsYXRlVmVydGV4VmFsaWQsXG4gICAgICAgIG5vQWxsb2NcbiAgICAgIH0sXG4gICAgICBlbGV2YXRpb25zOiB7XG4gICAgICAgIHNpemU6IDEsXG4gICAgICAgIHRyYW5zaXRpb246IEFUVFJJQlVURV9UUkFOU0lUSU9OLFxuICAgICAgICBhY2Nlc3NvcjogJ2dldEVsZXZhdGlvbicsXG4gICAgICAgIHNoYWRlckF0dHJpYnV0ZXM6IHtcbiAgICAgICAgICBlbGV2YXRpb25zOiB7XG4gICAgICAgICAgICBkaXZpc29yOiAwXG4gICAgICAgICAgfSxcbiAgICAgICAgICBpbnN0YW5jZUVsZXZhdGlvbnM6IHtcbiAgICAgICAgICAgIGRpdmlzb3I6IDFcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBmaWxsQ29sb3JzOiB7XG4gICAgICAgIHNpemU6IHRoaXMucHJvcHMuY29sb3JGb3JtYXQubGVuZ3RoLFxuICAgICAgICB0eXBlOiA1MTIxLFxuICAgICAgICBub3JtYWxpemVkOiB0cnVlLFxuICAgICAgICB0cmFuc2l0aW9uOiBBVFRSSUJVVEVfVFJBTlNJVElPTixcbiAgICAgICAgYWNjZXNzb3I6ICdnZXRGaWxsQ29sb3InLFxuICAgICAgICBkZWZhdWx0VmFsdWU6IERFRkFVTFRfQ09MT1IsXG4gICAgICAgIHNoYWRlckF0dHJpYnV0ZXM6IHtcbiAgICAgICAgICBmaWxsQ29sb3JzOiB7XG4gICAgICAgICAgICBkaXZpc29yOiAwXG4gICAgICAgICAgfSxcbiAgICAgICAgICBpbnN0YW5jZUZpbGxDb2xvcnM6IHtcbiAgICAgICAgICAgIGRpdmlzb3I6IDFcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBsaW5lQ29sb3JzOiB7XG4gICAgICAgIHNpemU6IHRoaXMucHJvcHMuY29sb3JGb3JtYXQubGVuZ3RoLFxuICAgICAgICB0eXBlOiA1MTIxLFxuICAgICAgICBub3JtYWxpemVkOiB0cnVlLFxuICAgICAgICB0cmFuc2l0aW9uOiBBVFRSSUJVVEVfVFJBTlNJVElPTixcbiAgICAgICAgYWNjZXNzb3I6ICdnZXRMaW5lQ29sb3InLFxuICAgICAgICBkZWZhdWx0VmFsdWU6IERFRkFVTFRfQ09MT1IsXG4gICAgICAgIHNoYWRlckF0dHJpYnV0ZXM6IHtcbiAgICAgICAgICBsaW5lQ29sb3JzOiB7XG4gICAgICAgICAgICBkaXZpc29yOiAwXG4gICAgICAgICAgfSxcbiAgICAgICAgICBpbnN0YW5jZUxpbmVDb2xvcnM6IHtcbiAgICAgICAgICAgIGRpdmlzb3I6IDFcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBwaWNraW5nQ29sb3JzOiB7XG4gICAgICAgIHNpemU6IDMsXG4gICAgICAgIHR5cGU6IDUxMjEsXG4gICAgICAgIGFjY2Vzc29yOiAob2JqZWN0LCB7XG4gICAgICAgICAgaW5kZXgsXG4gICAgICAgICAgdGFyZ2V0OiB2YWx1ZVxuICAgICAgICB9KSA9PiB0aGlzLmVuY29kZVBpY2tpbmdDb2xvcihvYmplY3QgJiYgb2JqZWN0Ll9fc291cmNlID8gb2JqZWN0Ll9fc291cmNlLmluZGV4IDogaW5kZXgsIHZhbHVlKSxcbiAgICAgICAgc2hhZGVyQXR0cmlidXRlczoge1xuICAgICAgICAgIHBpY2tpbmdDb2xvcnM6IHtcbiAgICAgICAgICAgIGRpdmlzb3I6IDBcbiAgICAgICAgICB9LFxuICAgICAgICAgIGluc3RhbmNlUGlja2luZ0NvbG9yczoge1xuICAgICAgICAgICAgZGl2aXNvcjogMVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgZ2V0UGlja2luZ0luZm8ocGFyYW1zKSB7XG4gICAgY29uc3QgaW5mbyA9IHN1cGVyLmdldFBpY2tpbmdJbmZvKHBhcmFtcyk7XG4gICAgY29uc3Qge1xuICAgICAgaW5kZXhcbiAgICB9ID0gaW5mbztcbiAgICBjb25zdCB7XG4gICAgICBkYXRhXG4gICAgfSA9IHRoaXMucHJvcHM7XG5cbiAgICBpZiAoZGF0YVswXSAmJiBkYXRhWzBdLl9fc291cmNlKSB7XG4gICAgICBpbmZvLm9iamVjdCA9IGRhdGEuZmluZChkID0+IGQuX19zb3VyY2UuaW5kZXggPT09IGluZGV4KTtcbiAgICB9XG5cbiAgICByZXR1cm4gaW5mbztcbiAgfVxuXG4gIGRpc2FibGVQaWNraW5nSW5kZXgob2JqZWN0SW5kZXgpIHtcbiAgICBjb25zdCB7XG4gICAgICBkYXRhXG4gICAgfSA9IHRoaXMucHJvcHM7XG5cbiAgICBpZiAoZGF0YVswXSAmJiBkYXRhWzBdLl9fc291cmNlKSB7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGRhdGEubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKGRhdGFbaV0uX19zb3VyY2UuaW5kZXggPT09IG9iamVjdEluZGV4KSB7XG4gICAgICAgICAgdGhpcy5fZGlzYWJsZVBpY2tpbmdJbmRleChpKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9kaXNhYmxlUGlja2luZ0luZGV4KG9iamVjdEluZGV4KTtcbiAgICB9XG4gIH1cblxuICBkcmF3KHtcbiAgICB1bmlmb3Jtc1xuICB9KSB7XG4gICAgY29uc3Qge1xuICAgICAgZXh0cnVkZWQsXG4gICAgICBmaWxsZWQsXG4gICAgICB3aXJlZnJhbWUsXG4gICAgICBlbGV2YXRpb25TY2FsZVxuICAgIH0gPSB0aGlzLnByb3BzO1xuICAgIGNvbnN0IHtcbiAgICAgIHRvcE1vZGVsLFxuICAgICAgc2lkZU1vZGVsLFxuICAgICAgcG9seWdvblRlc3NlbGF0b3JcbiAgICB9ID0gdGhpcy5zdGF0ZTtcbiAgICBjb25zdCByZW5kZXJVbmlmb3JtcyA9IHsgLi4udW5pZm9ybXMsXG4gICAgICBleHRydWRlZDogQm9vbGVhbihleHRydWRlZCksXG4gICAgICBlbGV2YXRpb25TY2FsZVxuICAgIH07XG5cbiAgICBpZiAoc2lkZU1vZGVsKSB7XG4gICAgICBzaWRlTW9kZWwuc2V0SW5zdGFuY2VDb3VudChwb2x5Z29uVGVzc2VsYXRvci5pbnN0YW5jZUNvdW50IC0gMSk7XG4gICAgICBzaWRlTW9kZWwuc2V0VW5pZm9ybXMocmVuZGVyVW5pZm9ybXMpO1xuXG4gICAgICBpZiAod2lyZWZyYW1lKSB7XG4gICAgICAgIHNpZGVNb2RlbC5zZXREcmF3TW9kZSgzKTtcbiAgICAgICAgc2lkZU1vZGVsLnNldFVuaWZvcm1zKHtcbiAgICAgICAgICBpc1dpcmVmcmFtZTogdHJ1ZVxuICAgICAgICB9KS5kcmF3KCk7XG4gICAgICB9XG5cbiAgICAgIGlmIChmaWxsZWQpIHtcbiAgICAgICAgc2lkZU1vZGVsLnNldERyYXdNb2RlKDYpO1xuICAgICAgICBzaWRlTW9kZWwuc2V0VW5pZm9ybXMoe1xuICAgICAgICAgIGlzV2lyZWZyYW1lOiBmYWxzZVxuICAgICAgICB9KS5kcmF3KCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHRvcE1vZGVsKSB7XG4gICAgICB0b3BNb2RlbC5zZXRWZXJ0ZXhDb3VudChwb2x5Z29uVGVzc2VsYXRvci52ZXJ0ZXhDb3VudCk7XG4gICAgICB0b3BNb2RlbC5zZXRVbmlmb3JtcyhyZW5kZXJVbmlmb3JtcykuZHJhdygpO1xuICAgIH1cbiAgfVxuXG4gIHVwZGF0ZVN0YXRlKHVwZGF0ZVBhcmFtcykge1xuICAgIHN1cGVyLnVwZGF0ZVN0YXRlKHVwZGF0ZVBhcmFtcyk7XG4gICAgdGhpcy51cGRhdGVHZW9tZXRyeSh1cGRhdGVQYXJhbXMpO1xuICAgIGNvbnN0IHtcbiAgICAgIHByb3BzLFxuICAgICAgb2xkUHJvcHMsXG4gICAgICBjaGFuZ2VGbGFnc1xuICAgIH0gPSB1cGRhdGVQYXJhbXM7XG4gICAgY29uc3QgYXR0cmlidXRlTWFuYWdlciA9IHRoaXMuZ2V0QXR0cmlidXRlTWFuYWdlcigpO1xuICAgIGNvbnN0IHJlZ2VuZXJhdGVNb2RlbHMgPSBjaGFuZ2VGbGFncy5leHRlbnNpb25zQ2hhbmdlZCB8fCBwcm9wcy5maWxsZWQgIT09IG9sZFByb3BzLmZpbGxlZCB8fCBwcm9wcy5leHRydWRlZCAhPT0gb2xkUHJvcHMuZXh0cnVkZWQ7XG5cbiAgICBpZiAocmVnZW5lcmF0ZU1vZGVscykge1xuICAgICAgdmFyIF90aGlzJHN0YXRlJG1vZGVscztcblxuICAgICAgKF90aGlzJHN0YXRlJG1vZGVscyA9IHRoaXMuc3RhdGUubW9kZWxzKSA9PT0gbnVsbCB8fCBfdGhpcyRzdGF0ZSRtb2RlbHMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF90aGlzJHN0YXRlJG1vZGVscy5mb3JFYWNoKG1vZGVsID0+IG1vZGVsLmRlbGV0ZSgpKTtcbiAgICAgIHRoaXMuc2V0U3RhdGUodGhpcy5fZ2V0TW9kZWxzKHRoaXMuY29udGV4dC5nbCkpO1xuICAgICAgYXR0cmlidXRlTWFuYWdlci5pbnZhbGlkYXRlQWxsKCk7XG4gICAgfVxuICB9XG5cbiAgdXBkYXRlR2VvbWV0cnkoe1xuICAgIHByb3BzLFxuICAgIG9sZFByb3BzLFxuICAgIGNoYW5nZUZsYWdzXG4gIH0pIHtcbiAgICBjb25zdCBnZW9tZXRyeUNvbmZpZ0NoYW5nZWQgPSBjaGFuZ2VGbGFncy5kYXRhQ2hhbmdlZCB8fCBjaGFuZ2VGbGFncy51cGRhdGVUcmlnZ2Vyc0NoYW5nZWQgJiYgKGNoYW5nZUZsYWdzLnVwZGF0ZVRyaWdnZXJzQ2hhbmdlZC5hbGwgfHwgY2hhbmdlRmxhZ3MudXBkYXRlVHJpZ2dlcnNDaGFuZ2VkLmdldFBvbHlnb24pO1xuXG4gICAgaWYgKGdlb21ldHJ5Q29uZmlnQ2hhbmdlZCkge1xuICAgICAgY29uc3Qge1xuICAgICAgICBwb2x5Z29uVGVzc2VsYXRvclxuICAgICAgfSA9IHRoaXMuc3RhdGU7XG4gICAgICBjb25zdCBidWZmZXJzID0gcHJvcHMuZGF0YS5hdHRyaWJ1dGVzIHx8IHt9O1xuICAgICAgcG9seWdvblRlc3NlbGF0b3IudXBkYXRlR2VvbWV0cnkoe1xuICAgICAgICBkYXRhOiBwcm9wcy5kYXRhLFxuICAgICAgICBub3JtYWxpemU6IHByb3BzLl9ub3JtYWxpemUsXG4gICAgICAgIGdlb21ldHJ5QnVmZmVyOiBidWZmZXJzLmdldFBvbHlnb24sXG4gICAgICAgIGJ1ZmZlcnMsXG4gICAgICAgIGdldEdlb21ldHJ5OiBwcm9wcy5nZXRQb2x5Z29uLFxuICAgICAgICBwb3NpdGlvbkZvcm1hdDogcHJvcHMucG9zaXRpb25Gb3JtYXQsXG4gICAgICAgIHdyYXBMb25naXR1ZGU6IHByb3BzLndyYXBMb25naXR1ZGUsXG4gICAgICAgIHJlc29sdXRpb246IHRoaXMuY29udGV4dC52aWV3cG9ydC5yZXNvbHV0aW9uLFxuICAgICAgICBmcDY0OiB0aGlzLnVzZTY0Yml0UG9zaXRpb25zKCksXG4gICAgICAgIGRhdGFDaGFuZ2VkOiBjaGFuZ2VGbGFncy5kYXRhQ2hhbmdlZCxcbiAgICAgICAgZnVsbDNkOiBwcm9wcy5fZnVsbDNkXG4gICAgICB9KTtcbiAgICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgICAgICBudW1JbnN0YW5jZXM6IHBvbHlnb25UZXNzZWxhdG9yLmluc3RhbmNlQ291bnQsXG4gICAgICAgIHN0YXJ0SW5kaWNlczogcG9seWdvblRlc3NlbGF0b3IudmVydGV4U3RhcnRzXG4gICAgICB9KTtcblxuICAgICAgaWYgKCFjaGFuZ2VGbGFncy5kYXRhQ2hhbmdlZCkge1xuICAgICAgICB0aGlzLmdldEF0dHJpYnV0ZU1hbmFnZXIoKS5pbnZhbGlkYXRlQWxsKCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgX2dldE1vZGVscyhnbCkge1xuICAgIGNvbnN0IHtcbiAgICAgIGlkLFxuICAgICAgZmlsbGVkLFxuICAgICAgZXh0cnVkZWRcbiAgICB9ID0gdGhpcy5wcm9wcztcbiAgICBsZXQgdG9wTW9kZWw7XG4gICAgbGV0IHNpZGVNb2RlbDtcblxuICAgIGlmIChmaWxsZWQpIHtcbiAgICAgIGNvbnN0IHNoYWRlcnMgPSB0aGlzLmdldFNoYWRlcnMoJ3RvcCcpO1xuICAgICAgc2hhZGVycy5kZWZpbmVzLk5PTl9JTlNUQU5DRURfTU9ERUwgPSAxO1xuICAgICAgdG9wTW9kZWwgPSBuZXcgTW9kZWwoZ2wsIHsgLi4uc2hhZGVycyxcbiAgICAgICAgaWQ6IFwiXCIuY29uY2F0KGlkLCBcIi10b3BcIiksXG4gICAgICAgIGRyYXdNb2RlOiA0LFxuICAgICAgICBhdHRyaWJ1dGVzOiB7XG4gICAgICAgICAgdmVydGV4UG9zaXRpb25zOiBuZXcgRmxvYXQzMkFycmF5KFswLCAxXSlcbiAgICAgICAgfSxcbiAgICAgICAgdW5pZm9ybXM6IHtcbiAgICAgICAgICBpc1dpcmVmcmFtZTogZmFsc2UsXG4gICAgICAgICAgaXNTaWRlVmVydGV4OiBmYWxzZVxuICAgICAgICB9LFxuICAgICAgICB2ZXJ0ZXhDb3VudDogMCxcbiAgICAgICAgaXNJbmRleGVkOiB0cnVlXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBpZiAoZXh0cnVkZWQpIHtcbiAgICAgIHNpZGVNb2RlbCA9IG5ldyBNb2RlbChnbCwgeyAuLi50aGlzLmdldFNoYWRlcnMoJ3NpZGUnKSxcbiAgICAgICAgaWQ6IFwiXCIuY29uY2F0KGlkLCBcIi1zaWRlXCIpLFxuICAgICAgICBnZW9tZXRyeTogbmV3IEdlb21ldHJ5KHtcbiAgICAgICAgICBkcmF3TW9kZTogMSxcbiAgICAgICAgICB2ZXJ0ZXhDb3VudDogNCxcbiAgICAgICAgICBhdHRyaWJ1dGVzOiB7XG4gICAgICAgICAgICB2ZXJ0ZXhQb3NpdGlvbnM6IHtcbiAgICAgICAgICAgICAgc2l6ZTogMixcbiAgICAgICAgICAgICAgdmFsdWU6IG5ldyBGbG9hdDMyQXJyYXkoWzEsIDAsIDAsIDAsIDAsIDEsIDEsIDFdKVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSksXG4gICAgICAgIGluc3RhbmNlQ291bnQ6IDAsXG4gICAgICAgIGlzSW5zdGFuY2VkOiAxXG4gICAgICB9KTtcbiAgICAgIHNpZGVNb2RlbC51c2VyRGF0YS5leGNsdWRlQXR0cmlidXRlcyA9IHtcbiAgICAgICAgaW5kaWNlczogdHJ1ZVxuICAgICAgfTtcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgbW9kZWxzOiBbc2lkZU1vZGVsLCB0b3BNb2RlbF0uZmlsdGVyKEJvb2xlYW4pLFxuICAgICAgdG9wTW9kZWwsXG4gICAgICBzaWRlTW9kZWxcbiAgICB9O1xuICB9XG5cbiAgY2FsY3VsYXRlSW5kaWNlcyhhdHRyaWJ1dGUpIHtcbiAgICBjb25zdCB7XG4gICAgICBwb2x5Z29uVGVzc2VsYXRvclxuICAgIH0gPSB0aGlzLnN0YXRlO1xuICAgIGF0dHJpYnV0ZS5zdGFydEluZGljZXMgPSBwb2x5Z29uVGVzc2VsYXRvci5pbmRleFN0YXJ0cztcbiAgICBhdHRyaWJ1dGUudmFsdWUgPSBwb2x5Z29uVGVzc2VsYXRvci5nZXQoJ2luZGljZXMnKTtcbiAgfVxuXG4gIGNhbGN1bGF0ZVBvc2l0aW9ucyhhdHRyaWJ1dGUpIHtcbiAgICBjb25zdCB7XG4gICAgICBwb2x5Z29uVGVzc2VsYXRvclxuICAgIH0gPSB0aGlzLnN0YXRlO1xuICAgIGF0dHJpYnV0ZS5zdGFydEluZGljZXMgPSBwb2x5Z29uVGVzc2VsYXRvci52ZXJ0ZXhTdGFydHM7XG4gICAgYXR0cmlidXRlLnZhbHVlID0gcG9seWdvblRlc3NlbGF0b3IuZ2V0KCdwb3NpdGlvbnMnKTtcbiAgfVxuXG4gIGNhbGN1bGF0ZVZlcnRleFZhbGlkKGF0dHJpYnV0ZSkge1xuICAgIGF0dHJpYnV0ZS52YWx1ZSA9IHRoaXMuc3RhdGUucG9seWdvblRlc3NlbGF0b3IuZ2V0KCd2ZXJ0ZXhWYWxpZCcpO1xuICB9XG5cbn1cblxuX2RlZmluZVByb3BlcnR5KFNvbGlkUG9seWdvbkxheWVyLCBcImRlZmF1bHRQcm9wc1wiLCBkZWZhdWx0UHJvcHMpO1xuXG5fZGVmaW5lUHJvcGVydHkoU29saWRQb2x5Z29uTGF5ZXIsIFwibGF5ZXJOYW1lXCIsICdTb2xpZFBvbHlnb25MYXllcicpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c29saWQtcG9seWdvbi1sYXllci5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///56923\n")},98452:function(__unused_webpack_module,__webpack_exports__,__webpack_require__){eval('/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "b": function() { return /* binding */ replaceInRange; }\n/* harmony export */ });\nfunction replaceInRange({\n  data,\n  getIndex,\n  dataRange,\n  replace\n}) {\n  const {\n    startRow = 0,\n    endRow = Infinity\n  } = dataRange;\n  const count = data.length;\n  let replaceStart = count;\n  let replaceEnd = count;\n\n  for (let i = 0; i < count; i++) {\n    const row = getIndex(data[i]);\n\n    if (replaceStart > i && row >= startRow) {\n      replaceStart = i;\n    }\n\n    if (row >= endRow) {\n      replaceEnd = i;\n      break;\n    }\n  }\n\n  let index = replaceStart;\n  const dataLengthChanged = replaceEnd - replaceStart !== replace.length;\n  const endChunk = dataLengthChanged ? data.slice(replaceEnd) : undefined;\n\n  for (let i = 0; i < replace.length; i++) {\n    data[index++] = replace[i];\n  }\n\n  if (endChunk) {\n    for (let i = 0; i < endChunk.length; i++) {\n      data[index++] = endChunk[i];\n    }\n\n    data.length = index;\n  }\n\n  return {\n    startRow: replaceStart,\n    endRow: replaceStart + replace.length\n  };\n}\n//# sourceMappingURL=utils.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiOTg0NTIuanMiLCJtYXBwaW5ncyI6Ijs7O0FBQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBLGtCQUFrQixXQUFXO0FBQzdCOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxrQkFBa0Isb0JBQW9CO0FBQ3RDO0FBQ0E7O0FBRUE7QUFDQSxvQkFBb0IscUJBQXFCO0FBQ3pDO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly92dWUzLXdlYnBhY2s1Ly4vbm9kZV9tb2R1bGVzL0BkZWNrLmdsL2xheWVycy9kaXN0L2VzbS91dGlscy5qcz8yNjFlIl0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCBmdW5jdGlvbiByZXBsYWNlSW5SYW5nZSh7XG4gIGRhdGEsXG4gIGdldEluZGV4LFxuICBkYXRhUmFuZ2UsXG4gIHJlcGxhY2Vcbn0pIHtcbiAgY29uc3Qge1xuICAgIHN0YXJ0Um93ID0gMCxcbiAgICBlbmRSb3cgPSBJbmZpbml0eVxuICB9ID0gZGF0YVJhbmdlO1xuICBjb25zdCBjb3VudCA9IGRhdGEubGVuZ3RoO1xuICBsZXQgcmVwbGFjZVN0YXJ0ID0gY291bnQ7XG4gIGxldCByZXBsYWNlRW5kID0gY291bnQ7XG5cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBjb3VudDsgaSsrKSB7XG4gICAgY29uc3Qgcm93ID0gZ2V0SW5kZXgoZGF0YVtpXSk7XG5cbiAgICBpZiAocmVwbGFjZVN0YXJ0ID4gaSAmJiByb3cgPj0gc3RhcnRSb3cpIHtcbiAgICAgIHJlcGxhY2VTdGFydCA9IGk7XG4gICAgfVxuXG4gICAgaWYgKHJvdyA+PSBlbmRSb3cpIHtcbiAgICAgIHJlcGxhY2VFbmQgPSBpO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG5cbiAgbGV0IGluZGV4ID0gcmVwbGFjZVN0YXJ0O1xuICBjb25zdCBkYXRhTGVuZ3RoQ2hhbmdlZCA9IHJlcGxhY2VFbmQgLSByZXBsYWNlU3RhcnQgIT09IHJlcGxhY2UubGVuZ3RoO1xuICBjb25zdCBlbmRDaHVuayA9IGRhdGFMZW5ndGhDaGFuZ2VkID8gZGF0YS5zbGljZShyZXBsYWNlRW5kKSA6IHVuZGVmaW5lZDtcblxuICBmb3IgKGxldCBpID0gMDsgaSA8IHJlcGxhY2UubGVuZ3RoOyBpKyspIHtcbiAgICBkYXRhW2luZGV4KytdID0gcmVwbGFjZVtpXTtcbiAgfVxuXG4gIGlmIChlbmRDaHVuaykge1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZW5kQ2h1bmsubGVuZ3RoOyBpKyspIHtcbiAgICAgIGRhdGFbaW5kZXgrK10gPSBlbmRDaHVua1tpXTtcbiAgICB9XG5cbiAgICBkYXRhLmxlbmd0aCA9IGluZGV4O1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBzdGFydFJvdzogcmVwbGFjZVN0YXJ0LFxuICAgIGVuZFJvdzogcmVwbGFjZVN0YXJ0ICsgcmVwbGFjZS5sZW5ndGhcbiAgfTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXV0aWxzLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///98452\n')}}]);