"use strict";(self["webpackChunkvue3_webpack5"]=self["webpackChunkvue3_webpack5"]||[]).push([[8440],{74333:function(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__){eval('/* harmony import */ var _Core_defined_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(82982);\n/* harmony import */ var _Core_DeveloperError_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(12572);\n\n\n\n/**\n * A model\'s material with modifiable parameters.  A glTF material\n * contains parameters defined by the material\'s technique with values\n * defined by the technique and potentially overridden by the material.\n * This class allows changing these values at runtime.\n * <p>\n * Use {@link Model#getMaterial} to create an instance.\n * </p>\n *\n * @alias ModelMaterial\n * @internalConstructor\n * @class\n *\n * @see Model#getMaterial\n */\nfunction ModelMaterial(model, material, id) {\n  this._name = material.name;\n  this._id = id;\n  this._uniformMap = model._uniformMaps[id];\n\n  this._technique = undefined;\n  this._program = undefined;\n  this._values = undefined;\n}\n\nObject.defineProperties(ModelMaterial.prototype, {\n  /**\n   * The value of the <code>name</code> property of this material.\n   *\n   * @memberof ModelMaterial.prototype\n   *\n   * @type {String}\n   * @readonly\n   */\n  name: {\n    get: function () {\n      return this._name;\n    },\n  },\n\n  /**\n   * The index of the material.\n   *\n   * @memberof ModelMaterial.prototype\n   *\n   * @type {String}\n   * @readonly\n   */\n  id: {\n    get: function () {\n      return this._id;\n    },\n  },\n});\n\n/**\n * Assigns a value to a material parameter.  The type for <code>value</code>\n * depends on the glTF type of the parameter.  It will be a floating-point\n * number, Cartesian, or matrix.\n *\n * @param {String} name The name of the parameter.\n * @param {*} [value] The value to assign to the parameter.\n *\n * @exception {DeveloperError} name must match a parameter name in the material\'s technique that is targetable and not optimized out.\n *\n * @example\n * material.setValue(\'diffuse\', new Cesium.Cartesian4(1.0, 0.0, 0.0, 1.0));  // vec4\n * material.setValue(\'shininess\', 256.0); // scalar\n */\nModelMaterial.prototype.setValue = function (name, value) {\n  //>>includeStart(\'debug\', pragmas.debug);\n  if (!(0,_Core_defined_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .Z)(name)) {\n    throw new _Core_DeveloperError_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .Z("name is required.");\n  }\n  //>>includeEnd(\'debug\');\n\n  var uniformName = "u_" + name;\n  var v = this._uniformMap.values[uniformName];\n\n  //>>includeStart(\'debug\', pragmas.debug);\n  if (!(0,_Core_defined_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .Z)(v)) {\n    throw new _Core_DeveloperError_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .Z(\n      "name must match a parameter name in the material\'s technique that is targetable and not optimized out."\n    );\n  }\n  //>>includeEnd(\'debug\');\n\n  v.value = v.clone(value, v.value);\n};\n\n/**\n * Returns the value of the parameter with the given <code>name</code>.  The type of the\n * returned object depends on the glTF type of the parameter.  It will be a floating-point\n * number, Cartesian, or matrix.\n *\n * @param {String} name The name of the parameter.\n * @returns {*} The value of the parameter or <code>undefined</code> if the parameter does not exist.\n */\nModelMaterial.prototype.getValue = function (name) {\n  //>>includeStart(\'debug\', pragmas.debug);\n  if (!(0,_Core_defined_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .Z)(name)) {\n    throw new _Core_DeveloperError_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .Z("name is required.");\n  }\n  //>>includeEnd(\'debug\');\n\n  var uniformName = "u_" + name;\n  var v = this._uniformMap.values[uniformName];\n\n  if (!(0,_Core_defined_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .Z)(v)) {\n    return undefined;\n  }\n\n  return v.value;\n};\n/* harmony default export */ __webpack_exports__["Z"] = (ModelMaterial);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNzQzMzMuanMiLCJtYXBwaW5ncyI6Ijs7QUFBeUM7QUFDYzs7QUFFdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSx5QkFBeUI7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSCxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxHQUFHO0FBQ2Q7QUFDQSxlQUFlLGdCQUFnQjtBQUMvQjtBQUNBO0FBQ0EsNkVBQTZFO0FBQzdFLDBDQUEwQztBQUMxQztBQUNBO0FBQ0E7QUFDQSxPQUFPLHFFQUFPO0FBQ2QsY0FBYyx3RUFBYztBQUM1QjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxPQUFPLHFFQUFPO0FBQ2QsY0FBYyx3RUFBYztBQUM1QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsYUFBYSxHQUFHO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBLE9BQU8scUVBQU87QUFDZCxjQUFjLHdFQUFjO0FBQzVCO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxPQUFPLHFFQUFPO0FBQ2Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0EseURBQWUsYUFBYSxFQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdnVlMy13ZWJwYWNrNS8uL25vZGVfbW9kdWxlcy9jZXNpdW0vU291cmNlL1NjZW5lL01vZGVsTWF0ZXJpYWwuanM/ODEzMCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgZGVmaW5lZCBmcm9tIFwiLi4vQ29yZS9kZWZpbmVkLmpzXCI7XG5pbXBvcnQgRGV2ZWxvcGVyRXJyb3IgZnJvbSBcIi4uL0NvcmUvRGV2ZWxvcGVyRXJyb3IuanNcIjtcblxuLyoqXG4gKiBBIG1vZGVsJ3MgbWF0ZXJpYWwgd2l0aCBtb2RpZmlhYmxlIHBhcmFtZXRlcnMuICBBIGdsVEYgbWF0ZXJpYWxcbiAqIGNvbnRhaW5zIHBhcmFtZXRlcnMgZGVmaW5lZCBieSB0aGUgbWF0ZXJpYWwncyB0ZWNobmlxdWUgd2l0aCB2YWx1ZXNcbiAqIGRlZmluZWQgYnkgdGhlIHRlY2huaXF1ZSBhbmQgcG90ZW50aWFsbHkgb3ZlcnJpZGRlbiBieSB0aGUgbWF0ZXJpYWwuXG4gKiBUaGlzIGNsYXNzIGFsbG93cyBjaGFuZ2luZyB0aGVzZSB2YWx1ZXMgYXQgcnVudGltZS5cbiAqIDxwPlxuICogVXNlIHtAbGluayBNb2RlbCNnZXRNYXRlcmlhbH0gdG8gY3JlYXRlIGFuIGluc3RhbmNlLlxuICogPC9wPlxuICpcbiAqIEBhbGlhcyBNb2RlbE1hdGVyaWFsXG4gKiBAaW50ZXJuYWxDb25zdHJ1Y3RvclxuICogQGNsYXNzXG4gKlxuICogQHNlZSBNb2RlbCNnZXRNYXRlcmlhbFxuICovXG5mdW5jdGlvbiBNb2RlbE1hdGVyaWFsKG1vZGVsLCBtYXRlcmlhbCwgaWQpIHtcbiAgdGhpcy5fbmFtZSA9IG1hdGVyaWFsLm5hbWU7XG4gIHRoaXMuX2lkID0gaWQ7XG4gIHRoaXMuX3VuaWZvcm1NYXAgPSBtb2RlbC5fdW5pZm9ybU1hcHNbaWRdO1xuXG4gIHRoaXMuX3RlY2huaXF1ZSA9IHVuZGVmaW5lZDtcbiAgdGhpcy5fcHJvZ3JhbSA9IHVuZGVmaW5lZDtcbiAgdGhpcy5fdmFsdWVzID0gdW5kZWZpbmVkO1xufVxuXG5PYmplY3QuZGVmaW5lUHJvcGVydGllcyhNb2RlbE1hdGVyaWFsLnByb3RvdHlwZSwge1xuICAvKipcbiAgICogVGhlIHZhbHVlIG9mIHRoZSA8Y29kZT5uYW1lPC9jb2RlPiBwcm9wZXJ0eSBvZiB0aGlzIG1hdGVyaWFsLlxuICAgKlxuICAgKiBAbWVtYmVyb2YgTW9kZWxNYXRlcmlhbC5wcm90b3R5cGVcbiAgICpcbiAgICogQHR5cGUge1N0cmluZ31cbiAgICogQHJlYWRvbmx5XG4gICAqL1xuICBuYW1lOiB7XG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fbmFtZTtcbiAgICB9LFxuICB9LFxuXG4gIC8qKlxuICAgKiBUaGUgaW5kZXggb2YgdGhlIG1hdGVyaWFsLlxuICAgKlxuICAgKiBAbWVtYmVyb2YgTW9kZWxNYXRlcmlhbC5wcm90b3R5cGVcbiAgICpcbiAgICogQHR5cGUge1N0cmluZ31cbiAgICogQHJlYWRvbmx5XG4gICAqL1xuICBpZDoge1xuICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX2lkO1xuICAgIH0sXG4gIH0sXG59KTtcblxuLyoqXG4gKiBBc3NpZ25zIGEgdmFsdWUgdG8gYSBtYXRlcmlhbCBwYXJhbWV0ZXIuICBUaGUgdHlwZSBmb3IgPGNvZGU+dmFsdWU8L2NvZGU+XG4gKiBkZXBlbmRzIG9uIHRoZSBnbFRGIHR5cGUgb2YgdGhlIHBhcmFtZXRlci4gIEl0IHdpbGwgYmUgYSBmbG9hdGluZy1wb2ludFxuICogbnVtYmVyLCBDYXJ0ZXNpYW4sIG9yIG1hdHJpeC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZSBUaGUgbmFtZSBvZiB0aGUgcGFyYW1ldGVyLlxuICogQHBhcmFtIHsqfSBbdmFsdWVdIFRoZSB2YWx1ZSB0byBhc3NpZ24gdG8gdGhlIHBhcmFtZXRlci5cbiAqXG4gKiBAZXhjZXB0aW9uIHtEZXZlbG9wZXJFcnJvcn0gbmFtZSBtdXN0IG1hdGNoIGEgcGFyYW1ldGVyIG5hbWUgaW4gdGhlIG1hdGVyaWFsJ3MgdGVjaG5pcXVlIHRoYXQgaXMgdGFyZ2V0YWJsZSBhbmQgbm90IG9wdGltaXplZCBvdXQuXG4gKlxuICogQGV4YW1wbGVcbiAqIG1hdGVyaWFsLnNldFZhbHVlKCdkaWZmdXNlJywgbmV3IENlc2l1bS5DYXJ0ZXNpYW40KDEuMCwgMC4wLCAwLjAsIDEuMCkpOyAgLy8gdmVjNFxuICogbWF0ZXJpYWwuc2V0VmFsdWUoJ3NoaW5pbmVzcycsIDI1Ni4wKTsgLy8gc2NhbGFyXG4gKi9cbk1vZGVsTWF0ZXJpYWwucHJvdG90eXBlLnNldFZhbHVlID0gZnVuY3Rpb24gKG5hbWUsIHZhbHVlKSB7XG4gIC8vPj5pbmNsdWRlU3RhcnQoJ2RlYnVnJywgcHJhZ21hcy5kZWJ1Zyk7XG4gIGlmICghZGVmaW5lZChuYW1lKSkge1xuICAgIHRocm93IG5ldyBEZXZlbG9wZXJFcnJvcihcIm5hbWUgaXMgcmVxdWlyZWQuXCIpO1xuICB9XG4gIC8vPj5pbmNsdWRlRW5kKCdkZWJ1ZycpO1xuXG4gIHZhciB1bmlmb3JtTmFtZSA9IFwidV9cIiArIG5hbWU7XG4gIHZhciB2ID0gdGhpcy5fdW5pZm9ybU1hcC52YWx1ZXNbdW5pZm9ybU5hbWVdO1xuXG4gIC8vPj5pbmNsdWRlU3RhcnQoJ2RlYnVnJywgcHJhZ21hcy5kZWJ1Zyk7XG4gIGlmICghZGVmaW5lZCh2KSkge1xuICAgIHRocm93IG5ldyBEZXZlbG9wZXJFcnJvcihcbiAgICAgIFwibmFtZSBtdXN0IG1hdGNoIGEgcGFyYW1ldGVyIG5hbWUgaW4gdGhlIG1hdGVyaWFsJ3MgdGVjaG5pcXVlIHRoYXQgaXMgdGFyZ2V0YWJsZSBhbmQgbm90IG9wdGltaXplZCBvdXQuXCJcbiAgICApO1xuICB9XG4gIC8vPj5pbmNsdWRlRW5kKCdkZWJ1ZycpO1xuXG4gIHYudmFsdWUgPSB2LmNsb25lKHZhbHVlLCB2LnZhbHVlKTtcbn07XG5cbi8qKlxuICogUmV0dXJucyB0aGUgdmFsdWUgb2YgdGhlIHBhcmFtZXRlciB3aXRoIHRoZSBnaXZlbiA8Y29kZT5uYW1lPC9jb2RlPi4gIFRoZSB0eXBlIG9mIHRoZVxuICogcmV0dXJuZWQgb2JqZWN0IGRlcGVuZHMgb24gdGhlIGdsVEYgdHlwZSBvZiB0aGUgcGFyYW1ldGVyLiAgSXQgd2lsbCBiZSBhIGZsb2F0aW5nLXBvaW50XG4gKiBudW1iZXIsIENhcnRlc2lhbiwgb3IgbWF0cml4LlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lIFRoZSBuYW1lIG9mIHRoZSBwYXJhbWV0ZXIuXG4gKiBAcmV0dXJucyB7Kn0gVGhlIHZhbHVlIG9mIHRoZSBwYXJhbWV0ZXIgb3IgPGNvZGU+dW5kZWZpbmVkPC9jb2RlPiBpZiB0aGUgcGFyYW1ldGVyIGRvZXMgbm90IGV4aXN0LlxuICovXG5Nb2RlbE1hdGVyaWFsLnByb3RvdHlwZS5nZXRWYWx1ZSA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gIC8vPj5pbmNsdWRlU3RhcnQoJ2RlYnVnJywgcHJhZ21hcy5kZWJ1Zyk7XG4gIGlmICghZGVmaW5lZChuYW1lKSkge1xuICAgIHRocm93IG5ldyBEZXZlbG9wZXJFcnJvcihcIm5hbWUgaXMgcmVxdWlyZWQuXCIpO1xuICB9XG4gIC8vPj5pbmNsdWRlRW5kKCdkZWJ1ZycpO1xuXG4gIHZhciB1bmlmb3JtTmFtZSA9IFwidV9cIiArIG5hbWU7XG4gIHZhciB2ID0gdGhpcy5fdW5pZm9ybU1hcC52YWx1ZXNbdW5pZm9ybU5hbWVdO1xuXG4gIGlmICghZGVmaW5lZCh2KSkge1xuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cblxuICByZXR1cm4gdi52YWx1ZTtcbn07XG5leHBvcnQgZGVmYXVsdCBNb2RlbE1hdGVyaWFsO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///74333\n')},55531:function(__unused_webpack___webpack_module__,__webpack_exports__){eval("/**\n * A model's mesh and its materials.\n * <p>\n * Use {@link Model#getMesh} to create an instance.\n * </p>\n *\n * @alias ModelMesh\n * @internalConstructor\n * @class\n *\n * @see Model#getMesh\n */\nfunction ModelMesh(mesh, runtimeMaterialsById, id) {\n  var materials = [];\n  var primitives = mesh.primitives;\n  var length = primitives.length;\n  for (var i = 0; i < length; ++i) {\n    var p = primitives[i];\n    materials[i] = runtimeMaterialsById[p.material];\n  }\n\n  this._name = mesh.name;\n  this._materials = materials;\n  this._id = id;\n}\n\nObject.defineProperties(ModelMesh.prototype, {\n  /**\n   * The value of the <code>name</code> property of this mesh.\n   *\n   * @memberof ModelMesh.prototype\n   *\n   * @type {String}\n   * @readonly\n   */\n  name: {\n    get: function () {\n      return this._name;\n    },\n  },\n\n  /**\n   * The index of the mesh.\n   *\n   * @memberof ModelMesh.prototype\n   *\n   * @type {String}\n   * @readonly\n   */\n  id: {\n    get: function () {\n      return this._id;\n    },\n  },\n\n  /**\n   * An array of {@link ModelMaterial} instances indexed by the mesh's\n   * primitive indices.\n   *\n   * @memberof ModelMesh.prototype\n   *\n   * @type {ModelMaterial[]}\n   * @readonly\n   */\n  materials: {\n    get: function () {\n      return this._materials;\n    },\n  },\n});\n/* harmony default export */ __webpack_exports__[\"Z\"] = (ModelMesh);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNTU1MzEuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0EsUUFBUSxxQkFBcUI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLFlBQVk7QUFDOUI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7O0FBRUg7QUFDQSxrQkFBa0IscUJBQXFCO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNILENBQUM7QUFDRCx5REFBZSxTQUFTLEVBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly92dWUzLXdlYnBhY2s1Ly4vbm9kZV9tb2R1bGVzL2Nlc2l1bS9Tb3VyY2UvU2NlbmUvTW9kZWxNZXNoLmpzPzJhM2IiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBBIG1vZGVsJ3MgbWVzaCBhbmQgaXRzIG1hdGVyaWFscy5cbiAqIDxwPlxuICogVXNlIHtAbGluayBNb2RlbCNnZXRNZXNofSB0byBjcmVhdGUgYW4gaW5zdGFuY2UuXG4gKiA8L3A+XG4gKlxuICogQGFsaWFzIE1vZGVsTWVzaFxuICogQGludGVybmFsQ29uc3RydWN0b3JcbiAqIEBjbGFzc1xuICpcbiAqIEBzZWUgTW9kZWwjZ2V0TWVzaFxuICovXG5mdW5jdGlvbiBNb2RlbE1lc2gobWVzaCwgcnVudGltZU1hdGVyaWFsc0J5SWQsIGlkKSB7XG4gIHZhciBtYXRlcmlhbHMgPSBbXTtcbiAgdmFyIHByaW1pdGl2ZXMgPSBtZXNoLnByaW1pdGl2ZXM7XG4gIHZhciBsZW5ndGggPSBwcmltaXRpdmVzLmxlbmd0aDtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7ICsraSkge1xuICAgIHZhciBwID0gcHJpbWl0aXZlc1tpXTtcbiAgICBtYXRlcmlhbHNbaV0gPSBydW50aW1lTWF0ZXJpYWxzQnlJZFtwLm1hdGVyaWFsXTtcbiAgfVxuXG4gIHRoaXMuX25hbWUgPSBtZXNoLm5hbWU7XG4gIHRoaXMuX21hdGVyaWFscyA9IG1hdGVyaWFscztcbiAgdGhpcy5faWQgPSBpZDtcbn1cblxuT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoTW9kZWxNZXNoLnByb3RvdHlwZSwge1xuICAvKipcbiAgICogVGhlIHZhbHVlIG9mIHRoZSA8Y29kZT5uYW1lPC9jb2RlPiBwcm9wZXJ0eSBvZiB0aGlzIG1lc2guXG4gICAqXG4gICAqIEBtZW1iZXJvZiBNb2RlbE1lc2gucHJvdG90eXBlXG4gICAqXG4gICAqIEB0eXBlIHtTdHJpbmd9XG4gICAqIEByZWFkb25seVxuICAgKi9cbiAgbmFtZToge1xuICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX25hbWU7XG4gICAgfSxcbiAgfSxcblxuICAvKipcbiAgICogVGhlIGluZGV4IG9mIHRoZSBtZXNoLlxuICAgKlxuICAgKiBAbWVtYmVyb2YgTW9kZWxNZXNoLnByb3RvdHlwZVxuICAgKlxuICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgKiBAcmVhZG9ubHlcbiAgICovXG4gIGlkOiB7XG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5faWQ7XG4gICAgfSxcbiAgfSxcblxuICAvKipcbiAgICogQW4gYXJyYXkgb2Yge0BsaW5rIE1vZGVsTWF0ZXJpYWx9IGluc3RhbmNlcyBpbmRleGVkIGJ5IHRoZSBtZXNoJ3NcbiAgICogcHJpbWl0aXZlIGluZGljZXMuXG4gICAqXG4gICAqIEBtZW1iZXJvZiBNb2RlbE1lc2gucHJvdG90eXBlXG4gICAqXG4gICAqIEB0eXBlIHtNb2RlbE1hdGVyaWFsW119XG4gICAqIEByZWFkb25seVxuICAgKi9cbiAgbWF0ZXJpYWxzOiB7XG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fbWF0ZXJpYWxzO1xuICAgIH0sXG4gIH0sXG59KTtcbmV4cG9ydCBkZWZhdWx0IE1vZGVsTWVzaDtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///55531\n")},10531:function(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__){eval('/* harmony import */ var _Core_Matrix4_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(72248);\n\n\n/**\n * A model node with a transform for user-defined animations.  A glTF asset can\n * contain animations that target a node\'s transform.  This class allows\n * changing a node\'s transform externally so animation can be driven by another\n * source, not just an animation in the glTF asset.\n * <p>\n * Use {@link Model#getNode} to create an instance.\n * </p>\n *\n * @alias ModelNode\n * @internalConstructor\n * @class\n *\n * @example\n * var node = model.getNode(\'LOD3sp\');\n * node.matrix = Cesium.Matrix4.fromScale(new Cesium.Cartesian3(5.0, 1.0, 1.0), node.matrix);\n *\n * @see Model#getNode\n */\nfunction ModelNode(model, node, runtimeNode, id, matrix) {\n  this._model = model;\n  this._runtimeNode = runtimeNode;\n  this._name = node.name;\n  this._id = id;\n\n  /**\n   * @private\n   */\n  this.useMatrix = false;\n\n  this._show = true;\n  this._matrix = _Core_Matrix4_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].clone */ .Z.clone(matrix);\n  this._originalMatrix = _Core_Matrix4_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].clone */ .Z.clone(matrix);\n}\n\nObject.defineProperties(ModelNode.prototype, {\n  /**\n   * The value of the <code>name</code> property of this node.\n   *\n   * @memberof ModelNode.prototype\n   *\n   * @type {String}\n   * @readonly\n   */\n  name: {\n    get: function () {\n      return this._name;\n    },\n  },\n\n  /**\n   * The index of the node.\n   *\n   * @memberof ModelNode.prototype\n   *\n   * @type {String}\n   * @readonly\n   */\n  id: {\n    get: function () {\n      return this._id;\n    },\n  },\n\n  /**\n   * Determines if this node and its children will be shown.\n   *\n   * @memberof ModelNode.prototype\n   * @type {Boolean}\n   *\n   * @default true\n   */\n  show: {\n    get: function () {\n      return this._show;\n    },\n    set: function (value) {\n      if (this._show !== value) {\n        this._show = value;\n        this._model._perNodeShowDirty = true;\n      }\n    },\n  },\n\n  /**\n   * The node\'s 4x4 matrix transform from its local coordinates to\n   * its parent\'s.\n   * <p>\n   * For changes to take effect, this property must be assigned to;\n   * setting individual elements of the matrix will not work.\n   * </p>\n   *\n   * @memberof ModelNode.prototype\n   * @type {Matrix4}\n   */\n  matrix: {\n    get: function () {\n      return this._matrix;\n    },\n    set: function (value) {\n      this._matrix = _Core_Matrix4_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].clone */ .Z.clone(value, this._matrix);\n      this.useMatrix = true;\n\n      var model = this._model;\n      model._cesiumAnimationsDirty = true;\n      this._runtimeNode.dirtyNumber = model._maxDirtyNumber;\n    },\n  },\n\n  /**\n   * Gets the node\'s original 4x4 matrix transform from its local coordinates to\n   * its parent\'s, without any node transformations or articulations applied.\n   *\n   * @memberof ModelNode.prototype\n   * @type {Matrix4}\n   */\n  originalMatrix: {\n    get: function () {\n      return this._originalMatrix;\n    },\n  },\n});\n\n/**\n * @private\n */\nModelNode.prototype.setMatrix = function (matrix) {\n  // Update matrix but do not set the dirty flag since this is used internally\n  // to keep the matrix in-sync during a glTF animation.\n  _Core_Matrix4_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].clone */ .Z.clone(matrix, this._matrix);\n};\n/* harmony default export */ __webpack_exports__["Z"] = (ModelNode);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTA1MzEuanMiLCJtYXBwaW5ncyI6IjtBQUF5Qzs7QUFFekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSxxQkFBcUI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGlCQUFpQiw2RUFBYTtBQUM5Qix5QkFBeUIsNkVBQWE7QUFDdEM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLHFCQUFxQiw2RUFBYTtBQUNsQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSCxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUUsNkVBQWE7QUFDZjtBQUNBLHlEQUFlLFNBQVMsRUFBQyIsInNvdXJjZXMiOlsid2VicGFjazovL3Z1ZTMtd2VicGFjazUvLi9ub2RlX21vZHVsZXMvY2VzaXVtL1NvdXJjZS9TY2VuZS9Nb2RlbE5vZGUuanM/YjUyNCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgTWF0cml4NCBmcm9tIFwiLi4vQ29yZS9NYXRyaXg0LmpzXCI7XG5cbi8qKlxuICogQSBtb2RlbCBub2RlIHdpdGggYSB0cmFuc2Zvcm0gZm9yIHVzZXItZGVmaW5lZCBhbmltYXRpb25zLiAgQSBnbFRGIGFzc2V0IGNhblxuICogY29udGFpbiBhbmltYXRpb25zIHRoYXQgdGFyZ2V0IGEgbm9kZSdzIHRyYW5zZm9ybS4gIFRoaXMgY2xhc3MgYWxsb3dzXG4gKiBjaGFuZ2luZyBhIG5vZGUncyB0cmFuc2Zvcm0gZXh0ZXJuYWxseSBzbyBhbmltYXRpb24gY2FuIGJlIGRyaXZlbiBieSBhbm90aGVyXG4gKiBzb3VyY2UsIG5vdCBqdXN0IGFuIGFuaW1hdGlvbiBpbiB0aGUgZ2xURiBhc3NldC5cbiAqIDxwPlxuICogVXNlIHtAbGluayBNb2RlbCNnZXROb2RlfSB0byBjcmVhdGUgYW4gaW5zdGFuY2UuXG4gKiA8L3A+XG4gKlxuICogQGFsaWFzIE1vZGVsTm9kZVxuICogQGludGVybmFsQ29uc3RydWN0b3JcbiAqIEBjbGFzc1xuICpcbiAqIEBleGFtcGxlXG4gKiB2YXIgbm9kZSA9IG1vZGVsLmdldE5vZGUoJ0xPRDNzcCcpO1xuICogbm9kZS5tYXRyaXggPSBDZXNpdW0uTWF0cml4NC5mcm9tU2NhbGUobmV3IENlc2l1bS5DYXJ0ZXNpYW4zKDUuMCwgMS4wLCAxLjApLCBub2RlLm1hdHJpeCk7XG4gKlxuICogQHNlZSBNb2RlbCNnZXROb2RlXG4gKi9cbmZ1bmN0aW9uIE1vZGVsTm9kZShtb2RlbCwgbm9kZSwgcnVudGltZU5vZGUsIGlkLCBtYXRyaXgpIHtcbiAgdGhpcy5fbW9kZWwgPSBtb2RlbDtcbiAgdGhpcy5fcnVudGltZU5vZGUgPSBydW50aW1lTm9kZTtcbiAgdGhpcy5fbmFtZSA9IG5vZGUubmFtZTtcbiAgdGhpcy5faWQgPSBpZDtcblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICovXG4gIHRoaXMudXNlTWF0cml4ID0gZmFsc2U7XG5cbiAgdGhpcy5fc2hvdyA9IHRydWU7XG4gIHRoaXMuX21hdHJpeCA9IE1hdHJpeDQuY2xvbmUobWF0cml4KTtcbiAgdGhpcy5fb3JpZ2luYWxNYXRyaXggPSBNYXRyaXg0LmNsb25lKG1hdHJpeCk7XG59XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKE1vZGVsTm9kZS5wcm90b3R5cGUsIHtcbiAgLyoqXG4gICAqIFRoZSB2YWx1ZSBvZiB0aGUgPGNvZGU+bmFtZTwvY29kZT4gcHJvcGVydHkgb2YgdGhpcyBub2RlLlxuICAgKlxuICAgKiBAbWVtYmVyb2YgTW9kZWxOb2RlLnByb3RvdHlwZVxuICAgKlxuICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgKiBAcmVhZG9ubHlcbiAgICovXG4gIG5hbWU6IHtcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9uYW1lO1xuICAgIH0sXG4gIH0sXG5cbiAgLyoqXG4gICAqIFRoZSBpbmRleCBvZiB0aGUgbm9kZS5cbiAgICpcbiAgICogQG1lbWJlcm9mIE1vZGVsTm9kZS5wcm90b3R5cGVcbiAgICpcbiAgICogQHR5cGUge1N0cmluZ31cbiAgICogQHJlYWRvbmx5XG4gICAqL1xuICBpZDoge1xuICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX2lkO1xuICAgIH0sXG4gIH0sXG5cbiAgLyoqXG4gICAqIERldGVybWluZXMgaWYgdGhpcyBub2RlIGFuZCBpdHMgY2hpbGRyZW4gd2lsbCBiZSBzaG93bi5cbiAgICpcbiAgICogQG1lbWJlcm9mIE1vZGVsTm9kZS5wcm90b3R5cGVcbiAgICogQHR5cGUge0Jvb2xlYW59XG4gICAqXG4gICAqIEBkZWZhdWx0IHRydWVcbiAgICovXG4gIHNob3c6IHtcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9zaG93O1xuICAgIH0sXG4gICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgIGlmICh0aGlzLl9zaG93ICE9PSB2YWx1ZSkge1xuICAgICAgICB0aGlzLl9zaG93ID0gdmFsdWU7XG4gICAgICAgIHRoaXMuX21vZGVsLl9wZXJOb2RlU2hvd0RpcnR5ID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9LFxuICB9LFxuXG4gIC8qKlxuICAgKiBUaGUgbm9kZSdzIDR4NCBtYXRyaXggdHJhbnNmb3JtIGZyb20gaXRzIGxvY2FsIGNvb3JkaW5hdGVzIHRvXG4gICAqIGl0cyBwYXJlbnQncy5cbiAgICogPHA+XG4gICAqIEZvciBjaGFuZ2VzIHRvIHRha2UgZWZmZWN0LCB0aGlzIHByb3BlcnR5IG11c3QgYmUgYXNzaWduZWQgdG87XG4gICAqIHNldHRpbmcgaW5kaXZpZHVhbCBlbGVtZW50cyBvZiB0aGUgbWF0cml4IHdpbGwgbm90IHdvcmsuXG4gICAqIDwvcD5cbiAgICpcbiAgICogQG1lbWJlcm9mIE1vZGVsTm9kZS5wcm90b3R5cGVcbiAgICogQHR5cGUge01hdHJpeDR9XG4gICAqL1xuICBtYXRyaXg6IHtcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9tYXRyaXg7XG4gICAgfSxcbiAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgdGhpcy5fbWF0cml4ID0gTWF0cml4NC5jbG9uZSh2YWx1ZSwgdGhpcy5fbWF0cml4KTtcbiAgICAgIHRoaXMudXNlTWF0cml4ID0gdHJ1ZTtcblxuICAgICAgdmFyIG1vZGVsID0gdGhpcy5fbW9kZWw7XG4gICAgICBtb2RlbC5fY2VzaXVtQW5pbWF0aW9uc0RpcnR5ID0gdHJ1ZTtcbiAgICAgIHRoaXMuX3J1bnRpbWVOb2RlLmRpcnR5TnVtYmVyID0gbW9kZWwuX21heERpcnR5TnVtYmVyO1xuICAgIH0sXG4gIH0sXG5cbiAgLyoqXG4gICAqIEdldHMgdGhlIG5vZGUncyBvcmlnaW5hbCA0eDQgbWF0cml4IHRyYW5zZm9ybSBmcm9tIGl0cyBsb2NhbCBjb29yZGluYXRlcyB0b1xuICAgKiBpdHMgcGFyZW50J3MsIHdpdGhvdXQgYW55IG5vZGUgdHJhbnNmb3JtYXRpb25zIG9yIGFydGljdWxhdGlvbnMgYXBwbGllZC5cbiAgICpcbiAgICogQG1lbWJlcm9mIE1vZGVsTm9kZS5wcm90b3R5cGVcbiAgICogQHR5cGUge01hdHJpeDR9XG4gICAqL1xuICBvcmlnaW5hbE1hdHJpeDoge1xuICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX29yaWdpbmFsTWF0cml4O1xuICAgIH0sXG4gIH0sXG59KTtcblxuLyoqXG4gKiBAcHJpdmF0ZVxuICovXG5Nb2RlbE5vZGUucHJvdG90eXBlLnNldE1hdHJpeCA9IGZ1bmN0aW9uIChtYXRyaXgpIHtcbiAgLy8gVXBkYXRlIG1hdHJpeCBidXQgZG8gbm90IHNldCB0aGUgZGlydHkgZmxhZyBzaW5jZSB0aGlzIGlzIHVzZWQgaW50ZXJuYWxseVxuICAvLyB0byBrZWVwIHRoZSBtYXRyaXggaW4tc3luYyBkdXJpbmcgYSBnbFRGIGFuaW1hdGlvbi5cbiAgTWF0cml4NC5jbG9uZShtYXRyaXgsIHRoaXMuX21hdHJpeCk7XG59O1xuZXhwb3J0IGRlZmF1bHQgTW9kZWxOb2RlO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///10531\n')},32851:function(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__){eval('/* harmony import */ var _Core_defined_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(82982);\n/* harmony import */ var _Core_PixelFormat_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(38443);\n/* harmony import */ var _Renderer_ContextLimits_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(20521);\n/* harmony import */ var _Renderer_Sampler_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(87721);\n/* harmony import */ var _Renderer_Texture_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(8743);\n/* harmony import */ var _Renderer_TextureMagnificationFilter_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(42246);\n/* harmony import */ var _Renderer_TextureMinificationFilter_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(80188);\n/* harmony import */ var _Renderer_TextureWrap_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(88453);\n/* harmony import */ var _GltfPipeline_ForEach_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(56629);\n\n\n\n\n\n\n\n\n\n\n// glTF does not allow an index value of 65535 because this is the primitive\n// restart value in some APIs.\nvar MAX_GLTF_UINT16_INDEX = 65534;\n\n/**\n * Creates face outlines for glTF primitives with the `CESIUM_primitive_outline` extension.\n * @private\n */\nfunction ModelOutlineLoader() {}\n\n/**\n * Returns true if the model uses or requires CESIUM_primitive_outline.\n * @private\n */\nModelOutlineLoader.hasExtension = function (model) {\n  return (\n    (0,_Core_defined_js__WEBPACK_IMPORTED_MODULE_8__/* ["default"] */ .Z)(model.extensionsRequired.CESIUM_primitive_outline) ||\n    (0,_Core_defined_js__WEBPACK_IMPORTED_MODULE_8__/* ["default"] */ .Z)(model.extensionsUsed.CESIUM_primitive_outline)\n  );\n};\n\n/**\n * Arranges to outline any primitives with the CESIUM_primitive_outline extension.\n * It is expected that all buffer data is loaded and available in\n * `extras._pipeline.source` before this function is called, and that vertex\n * and index WebGL buffers are not yet created.\n * @private\n */\nModelOutlineLoader.outlinePrimitives = function (model) {\n  if (!ModelOutlineLoader.hasExtension(model)) {\n    return;\n  }\n\n  var gltf = model.gltf;\n\n  // Assumption: A single bufferView contains a single zero-indexed range of vertices.\n  // No trickery with using large accessor byteOffsets to store multiple zero-based\n  // ranges of vertices in a single bufferView. Use separate bufferViews for that,\n  // you monster.\n  // Note that interleaved vertex attributes (e.g. position0, normal0, uv0,\n  // position1, normal1, uv1, ...) _are_ supported and should not be confused with\n  // the above.\n\n  var vertexNumberingScopes = [];\n\n  _GltfPipeline_ForEach_js__WEBPACK_IMPORTED_MODULE_7__/* ["default"].mesh */ .Z.mesh(gltf, function (mesh, meshId) {\n    _GltfPipeline_ForEach_js__WEBPACK_IMPORTED_MODULE_7__/* ["default"].meshPrimitive */ .Z.meshPrimitive(mesh, function (primitive, primitiveId) {\n      if (!(0,_Core_defined_js__WEBPACK_IMPORTED_MODULE_8__/* ["default"] */ .Z)(primitive.extensions)) {\n        return;\n      }\n\n      var outlineData = primitive.extensions.CESIUM_primitive_outline;\n      if (!(0,_Core_defined_js__WEBPACK_IMPORTED_MODULE_8__/* ["default"] */ .Z)(outlineData)) {\n        return;\n      }\n\n      var vertexNumberingScope = getVertexNumberingScope(model, primitive);\n      if (vertexNumberingScope === undefined) {\n        return;\n      }\n\n      if (vertexNumberingScopes.indexOf(vertexNumberingScope) < 0) {\n        vertexNumberingScopes.push(vertexNumberingScope);\n      }\n\n      // Add the outline to this primitive\n      addOutline(\n        model,\n        meshId,\n        primitiveId,\n        outlineData.indices,\n        vertexNumberingScope\n      );\n    });\n  });\n\n  // Update all relevant bufferViews to include the duplicate vertices that are\n  // needed for outlining.\n  for (var i = 0; i < vertexNumberingScopes.length; ++i) {\n    updateBufferViewsWithNewVertices(\n      model,\n      vertexNumberingScopes[i].bufferViews\n    );\n  }\n\n  // Remove data not referenced by any bufferViews anymore.\n  compactBuffers(model);\n};\n\nModelOutlineLoader.createTexture = function (model, context) {\n  var cache = context.cache.modelOutliningCache;\n  if (!(0,_Core_defined_js__WEBPACK_IMPORTED_MODULE_8__/* ["default"] */ .Z)(cache)) {\n    cache = context.cache.modelOutliningCache = {};\n  }\n\n  if ((0,_Core_defined_js__WEBPACK_IMPORTED_MODULE_8__/* ["default"] */ .Z)(cache.outlineTexture)) {\n    return cache.outlineTexture;\n  }\n\n  var maxSize = Math.min(4096, _Renderer_ContextLimits_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"].maximumTextureSize */ .Z.maximumTextureSize);\n\n  var size = maxSize;\n  var levelZero = createTexture(size);\n\n  var mipLevels = [];\n\n  while (size > 1) {\n    size >>= 1;\n    mipLevels.push(createTexture(size));\n  }\n\n  var texture = new _Renderer_Texture_js__WEBPACK_IMPORTED_MODULE_3__/* ["default"] */ .Z({\n    context: context,\n    source: {\n      arrayBufferView: levelZero,\n      mipLevels: mipLevels,\n    },\n    width: maxSize,\n    height: 1,\n    pixelFormat: _Core_PixelFormat_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].LUMINANCE */ .Z.LUMINANCE,\n    sampler: new _Renderer_Sampler_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"] */ .Z({\n      wrapS: _Renderer_TextureWrap_js__WEBPACK_IMPORTED_MODULE_6__/* ["default"].CLAMP_TO_EDGE */ .Z.CLAMP_TO_EDGE,\n      wrapT: _Renderer_TextureWrap_js__WEBPACK_IMPORTED_MODULE_6__/* ["default"].CLAMP_TO_EDGE */ .Z.CLAMP_TO_EDGE,\n      minificationFilter: _Renderer_TextureMinificationFilter_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"].LINEAR_MIPMAP_LINEAR */ .Z.LINEAR_MIPMAP_LINEAR,\n      magnificationFilter: _Renderer_TextureMagnificationFilter_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"].LINEAR */ .Z.LINEAR,\n    }),\n  });\n\n  cache.outlineTexture = texture;\n\n  return texture;\n};\n\nfunction addOutline(\n  model,\n  meshId,\n  primitiveId,\n  edgeIndicesAccessorId,\n  vertexNumberingScope\n) {\n  var vertexCopies = vertexNumberingScope.vertexCopies;\n  var extraVertices = vertexNumberingScope.extraVertices;\n  var outlineCoordinates = vertexNumberingScope.outlineCoordinates;\n\n  var gltf = model.gltf;\n  var mesh = gltf.meshes[meshId];\n  var primitive = mesh.primitives[primitiveId];\n  var accessors = gltf.accessors;\n  var bufferViews = gltf.bufferViews;\n\n  // Find the number of vertices in this primitive by looking at\n  // the first attribute. Others are required to be the same.\n  var numVertices;\n  for (var semantic in primitive.attributes) {\n    if (primitive.attributes.hasOwnProperty(semantic)) {\n      var attributeId = primitive.attributes[semantic];\n      var accessor = accessors[attributeId];\n      if ((0,_Core_defined_js__WEBPACK_IMPORTED_MODULE_8__/* ["default"] */ .Z)(accessor)) {\n        numVertices = accessor.count;\n        break;\n      }\n    }\n  }\n\n  if (!(0,_Core_defined_js__WEBPACK_IMPORTED_MODULE_8__/* ["default"] */ .Z)(numVertices)) {\n    return undefined;\n  }\n\n  var triangleIndexAccessorGltf = accessors[primitive.indices];\n  var triangleIndexBufferViewGltf =\n    bufferViews[triangleIndexAccessorGltf.bufferView];\n  var edgeIndexAccessorGltf = accessors[edgeIndicesAccessorId];\n  var edgeIndexBufferViewGltf = bufferViews[edgeIndexAccessorGltf.bufferView];\n\n  var loadResources = model._loadResources;\n  var triangleIndexBufferView = loadResources.getBuffer(\n    triangleIndexBufferViewGltf\n  );\n  var edgeIndexBufferView = loadResources.getBuffer(edgeIndexBufferViewGltf);\n\n  var triangleIndices =\n    triangleIndexAccessorGltf.componentType === 5123\n      ? new Uint16Array(\n          triangleIndexBufferView.buffer,\n          triangleIndexBufferView.byteOffset +\n            triangleIndexAccessorGltf.byteOffset,\n          triangleIndexAccessorGltf.count\n        )\n      : new Uint32Array(\n          triangleIndexBufferView.buffer,\n          triangleIndexBufferView.byteOffset +\n            triangleIndexAccessorGltf.byteOffset,\n          triangleIndexAccessorGltf.count\n        );\n  var edgeIndices =\n    edgeIndexAccessorGltf.componentType === 5123\n      ? new Uint16Array(\n          edgeIndexBufferView.buffer,\n          edgeIndexBufferView.byteOffset + edgeIndexAccessorGltf.byteOffset,\n          edgeIndexAccessorGltf.count\n        )\n      : new Uint32Array(\n          edgeIndexBufferView.buffer,\n          edgeIndexBufferView.byteOffset + edgeIndexAccessorGltf.byteOffset,\n          edgeIndexAccessorGltf.count\n        );\n\n  // Make a hash table for quick lookups of whether an edge exists between two\n  // vertices. The hash is a sparse array indexed by\n  //   `smallerVertexIndex * totalNumberOfVertices + biggerVertexIndex`\n  // A value of 1 indicates an edge exists between the two vertex indices; any\n  // other value indicates that it does not. We store the\n  // `edgeSmallMultipler` - that is, the number of vertices in the equation\n  // above - at index 0 for easy access to it later.\n\n  var edgeSmallMultiplier = numVertices;\n\n  var edges = [edgeSmallMultiplier];\n  var i;\n  for (i = 0; i < edgeIndices.length; i += 2) {\n    var a = edgeIndices[i];\n    var b = edgeIndices[i + 1];\n    var small = Math.min(a, b);\n    var big = Math.max(a, b);\n    edges[small * edgeSmallMultiplier + big] = 1;\n  }\n\n  // For each triangle, adjust vertex data so that the correct edges are outlined.\n  for (i = 0; i < triangleIndices.length; i += 3) {\n    var i0 = triangleIndices[i];\n    var i1 = triangleIndices[i + 1];\n    var i2 = triangleIndices[i + 2];\n\n    var all = false; // set this to true to draw a full wireframe.\n    var has01 = all || isHighlighted(edges, i0, i1);\n    var has12 = all || isHighlighted(edges, i1, i2);\n    var has20 = all || isHighlighted(edges, i2, i0);\n\n    var unmatchableVertexIndex = matchAndStoreCoordinates(\n      outlineCoordinates,\n      i0,\n      i1,\n      i2,\n      has01,\n      has12,\n      has20\n    );\n    while (unmatchableVertexIndex >= 0) {\n      // Copy the unmatchable index and try again.\n      var copy;\n      if (unmatchableVertexIndex === i0) {\n        copy = vertexCopies[i0];\n      } else if (unmatchableVertexIndex === i1) {\n        copy = vertexCopies[i1];\n      } else {\n        copy = vertexCopies[i2];\n      }\n\n      if (copy === undefined) {\n        copy = numVertices + extraVertices.length;\n\n        var original = unmatchableVertexIndex;\n        while (original >= numVertices) {\n          original = extraVertices[original - numVertices];\n        }\n        extraVertices.push(original);\n        vertexCopies[unmatchableVertexIndex] = copy;\n      }\n\n      if (\n        copy > MAX_GLTF_UINT16_INDEX &&\n        triangleIndices instanceof Uint16Array\n      ) {\n        // We outgrew a 16-bit index buffer, switch to 32-bit.\n        triangleIndices = new Uint32Array(triangleIndices);\n        triangleIndexAccessorGltf.componentType = 5125; // UNSIGNED_INT\n        triangleIndexBufferViewGltf.buffer =\n          gltf.buffers.push({\n            byteLength: triangleIndices.byteLength,\n            extras: {\n              _pipeline: {\n                source: triangleIndices.buffer,\n              },\n            },\n          }) - 1;\n        triangleIndexBufferViewGltf.byteLength = triangleIndices.byteLength;\n        triangleIndexBufferViewGltf.byteOffset = 0;\n        model._loadResources.buffers[\n          triangleIndexBufferViewGltf.buffer\n        ] = new Uint8Array(\n          triangleIndices.buffer,\n          0,\n          triangleIndices.byteLength\n        );\n\n        // The index componentType is also squirreled away in ModelLoadResources.\n        // Hackily update it, or else we\'ll end up creating the wrong type\n        // of index buffer later.\n        loadResources.indexBuffersToCreate._array.forEach(function (toCreate) {\n          if (toCreate.id === triangleIndexAccessorGltf.bufferView) {\n            toCreate.componentType = triangleIndexAccessorGltf.componentType;\n          }\n        });\n      }\n\n      if (unmatchableVertexIndex === i0) {\n        i0 = copy;\n        triangleIndices[i] = copy;\n      } else if (unmatchableVertexIndex === i1) {\n        i1 = copy;\n        triangleIndices[i + 1] = copy;\n      } else {\n        i2 = copy;\n        triangleIndices[i + 2] = copy;\n      }\n\n      if ((0,_Core_defined_js__WEBPACK_IMPORTED_MODULE_8__/* ["default"] */ .Z)(triangleIndexAccessorGltf.max)) {\n        triangleIndexAccessorGltf.max[0] = Math.max(\n          triangleIndexAccessorGltf.max[0],\n          copy\n        );\n      }\n\n      unmatchableVertexIndex = matchAndStoreCoordinates(\n        outlineCoordinates,\n        i0,\n        i1,\n        i2,\n        has01,\n        has12,\n        has20\n      );\n    }\n  }\n}\n\n// Each vertex has three coordinates, a, b, and c.\n// a is the coordinate that applies to edge 2-0 for the vertex.\n// b is the coordinate that applies to edge 0-1 for the vertex.\n// c is the coordinate that applies to edge 1-2 for the vertex.\n\n// A single triangle with all edges highlighted:\n//\n//                 | a | b | c |\n//                 | 1 | 1 | 0 |\n//                       0\n//                      / \\\n//                     /   \\\n//           edge 0-1 /     \\ edge 2-0\n//                   /       \\\n//                  /         \\\n// | a | b | c |   1-----------2   | a | b | c |\n// | 0 | 1 | 1 |     edge 1-2      | 1 | 0 | 1 |\n//\n// There are 6 possible orderings of coordinates a, b, and c:\n// 0 - abc\n// 1 - acb\n// 2 - bac\n// 3 - bca\n// 4 - cab\n// 5 - cba\n\n// All vertices must use the _same ordering_ for the edges to be rendered\n// correctly. So we compute a bitmask for each vertex, where the bit at\n// each position indicates whether that ordering works (i.e. doesn\'t\n// conflict with already-assigned coordinates) for that vertex.\n\n// Then we can find an ordering that works for all three vertices with a\n// bitwise AND.\n\nfunction computeOrderMask(outlineCoordinates, vertexIndex, a, b, c) {\n  var startIndex = vertexIndex * 3;\n  var first = outlineCoordinates[startIndex];\n  var second = outlineCoordinates[startIndex + 1];\n  var third = outlineCoordinates[startIndex + 2];\n\n  if (first === undefined) {\n    // If one coordinate is undefined, they all are, and all orderings are fine.\n    return 63; // 0b111111;\n  }\n\n  return (\n    ((first === a && second === b && third === c) << 0) +\n    ((first === a && second === c && third === b) << 1) +\n    ((first === b && second === a && third === c) << 2) +\n    ((first === b && second === c && third === a) << 3) +\n    ((first === c && second === a && third === b) << 4) +\n    ((first === c && second === b && third === a) << 5)\n  );\n}\n\n// popcount for integers 0-63, inclusive.\n// i.e. how many 1s are in the binary representation of the integer.\nfunction popcount0to63(value) {\n  return (\n    (value & 1) +\n    ((value >> 1) & 1) +\n    ((value >> 2) & 1) +\n    ((value >> 3) & 1) +\n    ((value >> 4) & 1) +\n    ((value >> 5) & 1)\n  );\n}\n\nfunction matchAndStoreCoordinates(\n  outlineCoordinates,\n  i0,\n  i1,\n  i2,\n  has01,\n  has12,\n  has20\n) {\n  var a0 = has20 ? 1.0 : 0.0;\n  var b0 = has01 ? 1.0 : 0.0;\n  var c0 = 0.0;\n\n  var i0Mask = computeOrderMask(outlineCoordinates, i0, a0, b0, c0);\n  if (i0Mask === 0) {\n    return i0;\n  }\n\n  var a1 = 0.0;\n  var b1 = has01 ? 1.0 : 0.0;\n  var c1 = has12 ? 1.0 : 0.0;\n\n  var i1Mask = computeOrderMask(outlineCoordinates, i1, a1, b1, c1);\n  if (i1Mask === 0) {\n    return i1;\n  }\n\n  var a2 = has20 ? 1.0 : 0.0;\n  var b2 = 0.0;\n  var c2 = has12 ? 1.0 : 0.0;\n\n  var i2Mask = computeOrderMask(outlineCoordinates, i2, a2, b2, c2);\n  if (i2Mask === 0) {\n    return i2;\n  }\n\n  var workingOrders = i0Mask & i1Mask & i2Mask;\n\n  var a, b, c;\n\n  if (workingOrders & (1 << 0)) {\n    // 0 - abc\n    a = 0;\n    b = 1;\n    c = 2;\n  } else if (workingOrders & (1 << 1)) {\n    // 1 - acb\n    a = 0;\n    c = 1;\n    b = 2;\n  } else if (workingOrders & (1 << 2)) {\n    // 2 - bac\n    b = 0;\n    a = 1;\n    c = 2;\n  } else if (workingOrders & (1 << 3)) {\n    // 3 - bca\n    b = 0;\n    c = 1;\n    a = 2;\n  } else if (workingOrders & (1 << 4)) {\n    // 4 - cab\n    c = 0;\n    a = 1;\n    b = 2;\n  } else if (workingOrders & (1 << 5)) {\n    // 5 - cba\n    c = 0;\n    b = 1;\n    a = 2;\n  } else {\n    // No ordering works.\n    // Report the most constrained vertex as unmatched so we copy that one.\n    var i0Popcount = popcount0to63(i0Mask);\n    var i1Popcount = popcount0to63(i1Mask);\n    var i2Popcount = popcount0to63(i2Mask);\n    if (i0Popcount < i1Popcount && i0Popcount < i2Popcount) {\n      return i0;\n    } else if (i1Popcount < i2Popcount) {\n      return i1;\n    }\n    return i2;\n  }\n\n  var i0Start = i0 * 3;\n  outlineCoordinates[i0Start + a] = a0;\n  outlineCoordinates[i0Start + b] = b0;\n  outlineCoordinates[i0Start + c] = c0;\n\n  var i1Start = i1 * 3;\n  outlineCoordinates[i1Start + a] = a1;\n  outlineCoordinates[i1Start + b] = b1;\n  outlineCoordinates[i1Start + c] = c1;\n\n  var i2Start = i2 * 3;\n  outlineCoordinates[i2Start + a] = a2;\n  outlineCoordinates[i2Start + b] = b2;\n  outlineCoordinates[i2Start + c] = c2;\n\n  return -1;\n}\n\nfunction isHighlighted(edges, i0, i1) {\n  var edgeSmallMultiplier = edges[0];\n  var index = Math.min(i0, i1) * edgeSmallMultiplier + Math.max(i0, i1);\n\n  // If i0 and i1 are both 0, then our index will be 0 and we\'ll end up\n  // accessing the edgeSmallMultiplier that we\'ve sneakily squirreled away\n  // in index 0. But it makes no sense to have an edge between vertex 0 and\n  // itself, so for any edgeSmallMultiplier other than 1 we\'ll return the\n  // correct answer: false. If edgeSmallMultiplier is 1, that means there is\n  // only a single vertex, so no danger of forming a meaningful triangle\n  // with that.\n  return edges[index] === 1;\n}\n\nfunction createTexture(size) {\n  var texture = new Uint8Array(size);\n  texture[size - 1] = 192;\n  if (size === 8) {\n    texture[size - 1] = 96;\n  } else if (size === 4) {\n    texture[size - 1] = 48;\n  } else if (size === 2) {\n    texture[size - 1] = 24;\n  } else if (size === 1) {\n    texture[size - 1] = 12;\n  }\n  return texture;\n}\n\nfunction updateBufferViewsWithNewVertices(model, bufferViews) {\n  var gltf = model.gltf;\n  var loadResources = model._loadResources;\n\n  var i, j;\n  for (i = 0; i < bufferViews.length; ++i) {\n    var bufferView = bufferViews[i];\n    var vertexNumberingScope = bufferView.extras._pipeline.vertexNumberingScope;\n\n    // Let the temporary data be garbage collected.\n    bufferView.extras._pipeline.vertexNumberingScope = undefined;\n\n    var newVertices = vertexNumberingScope.extraVertices;\n\n    var sourceData = loadResources.getBuffer(bufferView);\n    var byteStride = bufferView.byteStride || 4;\n    var newVerticesLength = newVertices.length;\n    var destData = new Uint8Array(\n      sourceData.byteLength + newVerticesLength * byteStride\n    );\n\n    // Copy the original vertices\n    destData.set(sourceData);\n\n    // Copy the vertices added for outlining\n    for (j = 0; j < newVerticesLength; ++j) {\n      var sourceIndex = newVertices[j] * byteStride;\n      var destIndex = sourceData.length + j * byteStride;\n      for (var k = 0; k < byteStride; ++k) {\n        destData[destIndex + k] = destData[sourceIndex + k];\n      }\n    }\n\n    // This bufferView is an independent buffer now. Update the model accordingly.\n    bufferView.byteOffset = 0;\n    bufferView.byteLength = destData.byteLength;\n\n    var bufferId =\n      gltf.buffers.push({\n        byteLength: destData.byteLength,\n        extras: {\n          _pipeline: {\n            source: destData.buffer,\n          },\n        },\n      }) - 1;\n\n    bufferView.buffer = bufferId;\n    loadResources.buffers[bufferId] = destData;\n\n    // Update the accessors to reflect the added vertices.\n    var accessors = vertexNumberingScope.accessors;\n    for (j = 0; j < accessors.length; ++j) {\n      var accessorId = accessors[j];\n      gltf.accessors[accessorId].count += newVerticesLength;\n    }\n\n    if (!vertexNumberingScope.createdOutlines) {\n      // Create the buffers, views, and accessors for the outline texture coordinates.\n      var outlineCoordinates = vertexNumberingScope.outlineCoordinates;\n      var outlineCoordinateBuffer = new Float32Array(outlineCoordinates);\n      var bufferIndex =\n        model.gltf.buffers.push({\n          byteLength: outlineCoordinateBuffer.byteLength,\n          extras: {\n            _pipeline: {\n              source: outlineCoordinateBuffer.buffer,\n            },\n          },\n        }) - 1;\n      loadResources.buffers[bufferIndex] = new Uint8Array(\n        outlineCoordinateBuffer.buffer,\n        0,\n        outlineCoordinateBuffer.byteLength\n      );\n\n      var bufferViewIndex =\n        model.gltf.bufferViews.push({\n          buffer: bufferIndex,\n          byteLength: outlineCoordinateBuffer.byteLength,\n          byteOffset: 0,\n          byteStride: 3 * Float32Array.BYTES_PER_ELEMENT,\n          target: 34962,\n        }) - 1;\n\n      var accessorIndex =\n        model.gltf.accessors.push({\n          bufferView: bufferViewIndex,\n          byteOffset: 0,\n          componentType: 5126,\n          count: outlineCoordinateBuffer.length / 3,\n          type: "VEC3",\n          min: [0.0, 0.0, 0.0],\n          max: [1.0, 1.0, 1.0],\n        }) - 1;\n\n      var primitives = vertexNumberingScope.primitives;\n      for (j = 0; j < primitives.length; ++j) {\n        primitives[j].attributes._OUTLINE_COORDINATES = accessorIndex;\n      }\n\n      loadResources.vertexBuffersToCreate.enqueue(bufferViewIndex);\n\n      vertexNumberingScope.createdOutlines = true;\n    }\n  }\n}\n\nfunction compactBuffers(model) {\n  var gltf = model.gltf;\n  var loadResources = model._loadResources;\n\n  var i;\n  for (i = 0; i < gltf.buffers.length; ++i) {\n    var buffer = gltf.buffers[i];\n    var bufferViewsUsingThisBuffer = gltf.bufferViews.filter(\n      usesBuffer.bind(undefined, i)\n    );\n    var newLength = bufferViewsUsingThisBuffer.reduce(function (\n      previous,\n      current\n    ) {\n      return previous + current.byteLength;\n    },\n    0);\n    if (newLength === buffer.byteLength) {\n      continue;\n    }\n\n    var newBuffer = new Uint8Array(newLength);\n    var offset = 0;\n    for (var j = 0; j < bufferViewsUsingThisBuffer.length; ++j) {\n      var bufferView = bufferViewsUsingThisBuffer[j];\n      var sourceData = loadResources.getBuffer(bufferView);\n      newBuffer.set(sourceData, offset);\n\n      bufferView.byteOffset = offset;\n      offset += sourceData.byteLength;\n    }\n\n    loadResources.buffers[i] = newBuffer;\n    buffer.extras._pipeline.source = newBuffer.buffer;\n    buffer.byteLength = newLength;\n  }\n}\n\nfunction usesBuffer(bufferId, bufferView) {\n  return bufferView.buffer === bufferId;\n}\n\nfunction getVertexNumberingScope(model, primitive) {\n  var attributes = primitive.attributes;\n  if (attributes === undefined) {\n    return undefined;\n  }\n\n  var gltf = model.gltf;\n\n  var vertexNumberingScope;\n\n  // Initialize common details for all bufferViews used by this primitive\'s vertices.\n  // All bufferViews used by this primitive must use a common vertex numbering scheme.\n  for (var semantic in attributes) {\n    if (!attributes.hasOwnProperty(semantic)) {\n      continue;\n    }\n\n    var accessorId = attributes[semantic];\n    var accessor = gltf.accessors[accessorId];\n    var bufferViewId = accessor.bufferView;\n    var bufferView = gltf.bufferViews[bufferViewId];\n\n    if (!(0,_Core_defined_js__WEBPACK_IMPORTED_MODULE_8__/* ["default"] */ .Z)(bufferView.extras)) {\n      bufferView.extras = {};\n    }\n    if (!(0,_Core_defined_js__WEBPACK_IMPORTED_MODULE_8__/* ["default"] */ .Z)(bufferView.extras._pipeline)) {\n      bufferView.extras._pipeline = {};\n    }\n\n    if (!(0,_Core_defined_js__WEBPACK_IMPORTED_MODULE_8__/* ["default"] */ .Z)(bufferView.extras._pipeline.vertexNumberingScope)) {\n      bufferView.extras._pipeline.vertexNumberingScope = vertexNumberingScope || {\n        // Each element in this array is:\n        // a) undefined, if the vertex at this index has no copies\n        // b) the index of the copy.\n        vertexCopies: [],\n\n        // Extra vertices appended after the ones originally included in the model.\n        // Each element is the index of the vertex that this one is a copy of.\n        extraVertices: [],\n\n        // The texture coordinates used for outlining, three floats per vertex.\n        outlineCoordinates: [],\n\n        // The IDs of accessors that use this vertex numbering.\n        accessors: [],\n\n        // The IDs of bufferViews that use this vertex numbering.\n        bufferViews: [],\n\n        // The primitives that use this vertex numbering.\n        primitives: [],\n\n        // True if the buffer for the outlines has already been created.\n        createdOutlines: false,\n      };\n    } else if (\n      vertexNumberingScope !== undefined &&\n      bufferView.extras._pipeline.vertexNumberingScope !== vertexNumberingScope\n    ) {\n      // Conflicting vertex numbering, let\'s give up.\n      return undefined;\n    }\n\n    vertexNumberingScope = bufferView.extras._pipeline.vertexNumberingScope;\n\n    if (vertexNumberingScope.bufferViews.indexOf(bufferView) < 0) {\n      vertexNumberingScope.bufferViews.push(bufferView);\n    }\n\n    if (vertexNumberingScope.accessors.indexOf(accessorId) < 0) {\n      vertexNumberingScope.accessors.push(accessorId);\n    }\n  }\n\n  vertexNumberingScope.primitives.push(primitive);\n\n  return vertexNumberingScope;\n}\n\n/* harmony default export */ __webpack_exports__["Z"] = (ModelOutlineLoader);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBOztBQUVBLFVBQVUscUVBQU87QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGVBQWU7QUFDZjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsY0FBYyx3QkFBd0I7QUFDdEM7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsZ0JBQWdCLHVCQUF1QjtBQUN2QztBQUNBO0FBQ0Esc0JBQXNCLGdCQUFnQjtBQUN0QztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWCxTQUFTO0FBQ1QsT0FBTzs7QUFFUDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxnQkFBZ0Isc0JBQXNCO0FBQ3RDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixXQUFXO0FBQ1gsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQSxrQkFBa0IsdUJBQXVCO0FBQ3pDO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsY0FBYyx5QkFBeUI7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxvQkFBb0IsdUNBQXVDO0FBQzNEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsU0FBUyxxRUFBTztBQUNoQjtBQUNBO0FBQ0EsU0FBUyxxRUFBTztBQUNoQjtBQUNBOztBQUVBLFNBQVMscUVBQU87QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLHlEQUFlLGtCQUFrQixFQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdnVlMy13ZWJwYWNrNS8uL25vZGVfbW9kdWxlcy9jZXNpdW0vU291cmNlL1NjZW5lL01vZGVsT3V0bGluZUxvYWRlci5qcz8xNmZmIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBkZWZpbmVkIGZyb20gXCIuLi9Db3JlL2RlZmluZWQuanNcIjtcbmltcG9ydCBQaXhlbEZvcm1hdCBmcm9tIFwiLi4vQ29yZS9QaXhlbEZvcm1hdC5qc1wiO1xuaW1wb3J0IENvbnRleHRMaW1pdHMgZnJvbSBcIi4uL1JlbmRlcmVyL0NvbnRleHRMaW1pdHMuanNcIjtcbmltcG9ydCBTYW1wbGVyIGZyb20gXCIuLi9SZW5kZXJlci9TYW1wbGVyLmpzXCI7XG5pbXBvcnQgVGV4dHVyZSBmcm9tIFwiLi4vUmVuZGVyZXIvVGV4dHVyZS5qc1wiO1xuaW1wb3J0IFRleHR1cmVNYWduaWZpY2F0aW9uRmlsdGVyIGZyb20gXCIuLi9SZW5kZXJlci9UZXh0dXJlTWFnbmlmaWNhdGlvbkZpbHRlci5qc1wiO1xuaW1wb3J0IFRleHR1cmVNaW5pZmljYXRpb25GaWx0ZXIgZnJvbSBcIi4uL1JlbmRlcmVyL1RleHR1cmVNaW5pZmljYXRpb25GaWx0ZXIuanNcIjtcbmltcG9ydCBUZXh0dXJlV3JhcCBmcm9tIFwiLi4vUmVuZGVyZXIvVGV4dHVyZVdyYXAuanNcIjtcbmltcG9ydCBGb3JFYWNoIGZyb20gXCIuL0dsdGZQaXBlbGluZS9Gb3JFYWNoLmpzXCI7XG5cbi8vIGdsVEYgZG9lcyBub3QgYWxsb3cgYW4gaW5kZXggdmFsdWUgb2YgNjU1MzUgYmVjYXVzZSB0aGlzIGlzIHRoZSBwcmltaXRpdmVcbi8vIHJlc3RhcnQgdmFsdWUgaW4gc29tZSBBUElzLlxudmFyIE1BWF9HTFRGX1VJTlQxNl9JTkRFWCA9IDY1NTM0O1xuXG4vKipcbiAqIENyZWF0ZXMgZmFjZSBvdXRsaW5lcyBmb3IgZ2xURiBwcmltaXRpdmVzIHdpdGggdGhlIGBDRVNJVU1fcHJpbWl0aXZlX291dGxpbmVgIGV4dGVuc2lvbi5cbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIE1vZGVsT3V0bGluZUxvYWRlcigpIHt9XG5cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIHRoZSBtb2RlbCB1c2VzIG9yIHJlcXVpcmVzIENFU0lVTV9wcmltaXRpdmVfb3V0bGluZS5cbiAqIEBwcml2YXRlXG4gKi9cbk1vZGVsT3V0bGluZUxvYWRlci5oYXNFeHRlbnNpb24gPSBmdW5jdGlvbiAobW9kZWwpIHtcbiAgcmV0dXJuIChcbiAgICBkZWZpbmVkKG1vZGVsLmV4dGVuc2lvbnNSZXF1aXJlZC5DRVNJVU1fcHJpbWl0aXZlX291dGxpbmUpIHx8XG4gICAgZGVmaW5lZChtb2RlbC5leHRlbnNpb25zVXNlZC5DRVNJVU1fcHJpbWl0aXZlX291dGxpbmUpXG4gICk7XG59O1xuXG4vKipcbiAqIEFycmFuZ2VzIHRvIG91dGxpbmUgYW55IHByaW1pdGl2ZXMgd2l0aCB0aGUgQ0VTSVVNX3ByaW1pdGl2ZV9vdXRsaW5lIGV4dGVuc2lvbi5cbiAqIEl0IGlzIGV4cGVjdGVkIHRoYXQgYWxsIGJ1ZmZlciBkYXRhIGlzIGxvYWRlZCBhbmQgYXZhaWxhYmxlIGluXG4gKiBgZXh0cmFzLl9waXBlbGluZS5zb3VyY2VgIGJlZm9yZSB0aGlzIGZ1bmN0aW9uIGlzIGNhbGxlZCwgYW5kIHRoYXQgdmVydGV4XG4gKiBhbmQgaW5kZXggV2ViR0wgYnVmZmVycyBhcmUgbm90IHlldCBjcmVhdGVkLlxuICogQHByaXZhdGVcbiAqL1xuTW9kZWxPdXRsaW5lTG9hZGVyLm91dGxpbmVQcmltaXRpdmVzID0gZnVuY3Rpb24gKG1vZGVsKSB7XG4gIGlmICghTW9kZWxPdXRsaW5lTG9hZGVyLmhhc0V4dGVuc2lvbihtb2RlbCkpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgZ2x0ZiA9IG1vZGVsLmdsdGY7XG5cbiAgLy8gQXNzdW1wdGlvbjogQSBzaW5nbGUgYnVmZmVyVmlldyBjb250YWlucyBhIHNpbmdsZSB6ZXJvLWluZGV4ZWQgcmFuZ2Ugb2YgdmVydGljZXMuXG4gIC8vIE5vIHRyaWNrZXJ5IHdpdGggdXNpbmcgbGFyZ2UgYWNjZXNzb3IgYnl0ZU9mZnNldHMgdG8gc3RvcmUgbXVsdGlwbGUgemVyby1iYXNlZFxuICAvLyByYW5nZXMgb2YgdmVydGljZXMgaW4gYSBzaW5nbGUgYnVmZmVyVmlldy4gVXNlIHNlcGFyYXRlIGJ1ZmZlclZpZXdzIGZvciB0aGF0LFxuICAvLyB5b3UgbW9uc3Rlci5cbiAgLy8gTm90ZSB0aGF0IGludGVybGVhdmVkIHZlcnRleCBhdHRyaWJ1dGVzIChlLmcuIHBvc2l0aW9uMCwgbm9ybWFsMCwgdXYwLFxuICAvLyBwb3NpdGlvbjEsIG5vcm1hbDEsIHV2MSwgLi4uKSBfYXJlXyBzdXBwb3J0ZWQgYW5kIHNob3VsZCBub3QgYmUgY29uZnVzZWQgd2l0aFxuICAvLyB0aGUgYWJvdmUuXG5cbiAgdmFyIHZlcnRleE51bWJlcmluZ1Njb3BlcyA9IFtdO1xuXG4gIEZvckVhY2gubWVzaChnbHRmLCBmdW5jdGlvbiAobWVzaCwgbWVzaElkKSB7XG4gICAgRm9yRWFjaC5tZXNoUHJpbWl0aXZlKG1lc2gsIGZ1bmN0aW9uIChwcmltaXRpdmUsIHByaW1pdGl2ZUlkKSB7XG4gICAgICBpZiAoIWRlZmluZWQocHJpbWl0aXZlLmV4dGVuc2lvbnMpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdmFyIG91dGxpbmVEYXRhID0gcHJpbWl0aXZlLmV4dGVuc2lvbnMuQ0VTSVVNX3ByaW1pdGl2ZV9vdXRsaW5lO1xuICAgICAgaWYgKCFkZWZpbmVkKG91dGxpbmVEYXRhKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHZhciB2ZXJ0ZXhOdW1iZXJpbmdTY29wZSA9IGdldFZlcnRleE51bWJlcmluZ1Njb3BlKG1vZGVsLCBwcmltaXRpdmUpO1xuICAgICAgaWYgKHZlcnRleE51bWJlcmluZ1Njb3BlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiAodmVydGV4TnVtYmVyaW5nU2NvcGVzLmluZGV4T2YodmVydGV4TnVtYmVyaW5nU2NvcGUpIDwgMCkge1xuICAgICAgICB2ZXJ0ZXhOdW1iZXJpbmdTY29wZXMucHVzaCh2ZXJ0ZXhOdW1iZXJpbmdTY29wZSk7XG4gICAgICB9XG5cbiAgICAgIC8vIEFkZCB0aGUgb3V0bGluZSB0byB0aGlzIHByaW1pdGl2ZVxuICAgICAgYWRkT3V0bGluZShcbiAgICAgICAgbW9kZWwsXG4gICAgICAgIG1lc2hJZCxcbiAgICAgICAgcHJpbWl0aXZlSWQsXG4gICAgICAgIG91dGxpbmVEYXRhLmluZGljZXMsXG4gICAgICAgIHZlcnRleE51bWJlcmluZ1Njb3BlXG4gICAgICApO1xuICAgIH0pO1xuICB9KTtcblxuICAvLyBVcGRhdGUgYWxsIHJlbGV2YW50IGJ1ZmZlclZpZXdzIHRvIGluY2x1ZGUgdGhlIGR1cGxpY2F0ZSB2ZXJ0aWNlcyB0aGF0IGFyZVxuICAvLyBuZWVkZWQgZm9yIG91dGxpbmluZy5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB2ZXJ0ZXhOdW1iZXJpbmdTY29wZXMubGVuZ3RoOyArK2kpIHtcbiAgICB1cGRhdGVCdWZmZXJWaWV3c1dpdGhOZXdWZXJ0aWNlcyhcbiAgICAgIG1vZGVsLFxuICAgICAgdmVydGV4TnVtYmVyaW5nU2NvcGVzW2ldLmJ1ZmZlclZpZXdzXG4gICAgKTtcbiAgfVxuXG4gIC8vIFJlbW92ZSBkYXRhIG5vdCByZWZlcmVuY2VkIGJ5IGFueSBidWZmZXJWaWV3cyBhbnltb3JlLlxuICBjb21wYWN0QnVmZmVycyhtb2RlbCk7XG59O1xuXG5Nb2RlbE91dGxpbmVMb2FkZXIuY3JlYXRlVGV4dHVyZSA9IGZ1bmN0aW9uIChtb2RlbCwgY29udGV4dCkge1xuICB2YXIgY2FjaGUgPSBjb250ZXh0LmNhY2hlLm1vZGVsT3V0bGluaW5nQ2FjaGU7XG4gIGlmICghZGVmaW5lZChjYWNoZSkpIHtcbiAgICBjYWNoZSA9IGNvbnRleHQuY2FjaGUubW9kZWxPdXRsaW5pbmdDYWNoZSA9IHt9O1xuICB9XG5cbiAgaWYgKGRlZmluZWQoY2FjaGUub3V0bGluZVRleHR1cmUpKSB7XG4gICAgcmV0dXJuIGNhY2hlLm91dGxpbmVUZXh0dXJlO1xuICB9XG5cbiAgdmFyIG1heFNpemUgPSBNYXRoLm1pbig0MDk2LCBDb250ZXh0TGltaXRzLm1heGltdW1UZXh0dXJlU2l6ZSk7XG5cbiAgdmFyIHNpemUgPSBtYXhTaXplO1xuICB2YXIgbGV2ZWxaZXJvID0gY3JlYXRlVGV4dHVyZShzaXplKTtcblxuICB2YXIgbWlwTGV2ZWxzID0gW107XG5cbiAgd2hpbGUgKHNpemUgPiAxKSB7XG4gICAgc2l6ZSA+Pj0gMTtcbiAgICBtaXBMZXZlbHMucHVzaChjcmVhdGVUZXh0dXJlKHNpemUpKTtcbiAgfVxuXG4gIHZhciB0ZXh0dXJlID0gbmV3IFRleHR1cmUoe1xuICAgIGNvbnRleHQ6IGNvbnRleHQsXG4gICAgc291cmNlOiB7XG4gICAgICBhcnJheUJ1ZmZlclZpZXc6IGxldmVsWmVybyxcbiAgICAgIG1pcExldmVsczogbWlwTGV2ZWxzLFxuICAgIH0sXG4gICAgd2lkdGg6IG1heFNpemUsXG4gICAgaGVpZ2h0OiAxLFxuICAgIHBpeGVsRm9ybWF0OiBQaXhlbEZvcm1hdC5MVU1JTkFOQ0UsXG4gICAgc2FtcGxlcjogbmV3IFNhbXBsZXIoe1xuICAgICAgd3JhcFM6IFRleHR1cmVXcmFwLkNMQU1QX1RPX0VER0UsXG4gICAgICB3cmFwVDogVGV4dHVyZVdyYXAuQ0xBTVBfVE9fRURHRSxcbiAgICAgIG1pbmlmaWNhdGlvbkZpbHRlcjogVGV4dHVyZU1pbmlmaWNhdGlvbkZpbHRlci5MSU5FQVJfTUlQTUFQX0xJTkVBUixcbiAgICAgIG1hZ25pZmljYXRpb25GaWx0ZXI6IFRleHR1cmVNYWduaWZpY2F0aW9uRmlsdGVyLkxJTkVBUixcbiAgICB9KSxcbiAgfSk7XG5cbiAgY2FjaGUub3V0bGluZVRleHR1cmUgPSB0ZXh0dXJlO1xuXG4gIHJldHVybiB0ZXh0dXJlO1xufTtcblxuZnVuY3Rpb24gYWRkT3V0bGluZShcbiAgbW9kZWwsXG4gIG1lc2hJZCxcbiAgcHJpbWl0aXZlSWQsXG4gIGVkZ2VJbmRpY2VzQWNjZXNzb3JJZCxcbiAgdmVydGV4TnVtYmVyaW5nU2NvcGVcbikge1xuICB2YXIgdmVydGV4Q29waWVzID0gdmVydGV4TnVtYmVyaW5nU2NvcGUudmVydGV4Q29waWVzO1xuICB2YXIgZXh0cmFWZXJ0aWNlcyA9IHZlcnRleE51bWJlcmluZ1Njb3BlLmV4dHJhVmVydGljZXM7XG4gIHZhciBvdXRsaW5lQ29vcmRpbmF0ZXMgPSB2ZXJ0ZXhOdW1iZXJpbmdTY29wZS5vdXRsaW5lQ29vcmRpbmF0ZXM7XG5cbiAgdmFyIGdsdGYgPSBtb2RlbC5nbHRmO1xuICB2YXIgbWVzaCA9IGdsdGYubWVzaGVzW21lc2hJZF07XG4gIHZhciBwcmltaXRpdmUgPSBtZXNoLnByaW1pdGl2ZXNbcHJpbWl0aXZlSWRdO1xuICB2YXIgYWNjZXNzb3JzID0gZ2x0Zi5hY2Nlc3NvcnM7XG4gIHZhciBidWZmZXJWaWV3cyA9IGdsdGYuYnVmZmVyVmlld3M7XG5cbiAgLy8gRmluZCB0aGUgbnVtYmVyIG9mIHZlcnRpY2VzIGluIHRoaXMgcHJpbWl0aXZlIGJ5IGxvb2tpbmcgYXRcbiAgLy8gdGhlIGZpcnN0IGF0dHJpYnV0ZS4gT3RoZXJzIGFyZSByZXF1aXJlZCB0byBiZSB0aGUgc2FtZS5cbiAgdmFyIG51bVZlcnRpY2VzO1xuICBmb3IgKHZhciBzZW1hbnRpYyBpbiBwcmltaXRpdmUuYXR0cmlidXRlcykge1xuICAgIGlmIChwcmltaXRpdmUuYXR0cmlidXRlcy5oYXNPd25Qcm9wZXJ0eShzZW1hbnRpYykpIHtcbiAgICAgIHZhciBhdHRyaWJ1dGVJZCA9IHByaW1pdGl2ZS5hdHRyaWJ1dGVzW3NlbWFudGljXTtcbiAgICAgIHZhciBhY2Nlc3NvciA9IGFjY2Vzc29yc1thdHRyaWJ1dGVJZF07XG4gICAgICBpZiAoZGVmaW5lZChhY2Nlc3NvcikpIHtcbiAgICAgICAgbnVtVmVydGljZXMgPSBhY2Nlc3Nvci5jb3VudDtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgaWYgKCFkZWZpbmVkKG51bVZlcnRpY2VzKSkge1xuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cblxuICB2YXIgdHJpYW5nbGVJbmRleEFjY2Vzc29yR2x0ZiA9IGFjY2Vzc29yc1twcmltaXRpdmUuaW5kaWNlc107XG4gIHZhciB0cmlhbmdsZUluZGV4QnVmZmVyVmlld0dsdGYgPVxuICAgIGJ1ZmZlclZpZXdzW3RyaWFuZ2xlSW5kZXhBY2Nlc3NvckdsdGYuYnVmZmVyVmlld107XG4gIHZhciBlZGdlSW5kZXhBY2Nlc3NvckdsdGYgPSBhY2Nlc3NvcnNbZWRnZUluZGljZXNBY2Nlc3NvcklkXTtcbiAgdmFyIGVkZ2VJbmRleEJ1ZmZlclZpZXdHbHRmID0gYnVmZmVyVmlld3NbZWRnZUluZGV4QWNjZXNzb3JHbHRmLmJ1ZmZlclZpZXddO1xuXG4gIHZhciBsb2FkUmVzb3VyY2VzID0gbW9kZWwuX2xvYWRSZXNvdXJjZXM7XG4gIHZhciB0cmlhbmdsZUluZGV4QnVmZmVyVmlldyA9IGxvYWRSZXNvdXJjZXMuZ2V0QnVmZmVyKFxuICAgIHRyaWFuZ2xlSW5kZXhCdWZmZXJWaWV3R2x0ZlxuICApO1xuICB2YXIgZWRnZUluZGV4QnVmZmVyVmlldyA9IGxvYWRSZXNvdXJjZXMuZ2V0QnVmZmVyKGVkZ2VJbmRleEJ1ZmZlclZpZXdHbHRmKTtcblxuICB2YXIgdHJpYW5nbGVJbmRpY2VzID1cbiAgICB0cmlhbmdsZUluZGV4QWNjZXNzb3JHbHRmLmNvbXBvbmVudFR5cGUgPT09IDUxMjNcbiAgICAgID8gbmV3IFVpbnQxNkFycmF5KFxuICAgICAgICAgIHRyaWFuZ2xlSW5kZXhCdWZmZXJWaWV3LmJ1ZmZlcixcbiAgICAgICAgICB0cmlhbmdsZUluZGV4QnVmZmVyVmlldy5ieXRlT2Zmc2V0ICtcbiAgICAgICAgICAgIHRyaWFuZ2xlSW5kZXhBY2Nlc3NvckdsdGYuYnl0ZU9mZnNldCxcbiAgICAgICAgICB0cmlhbmdsZUluZGV4QWNjZXNzb3JHbHRmLmNvdW50XG4gICAgICAgIClcbiAgICAgIDogbmV3IFVpbnQzMkFycmF5KFxuICAgICAgICAgIHRyaWFuZ2xlSW5kZXhCdWZmZXJWaWV3LmJ1ZmZlcixcbiAgICAgICAgICB0cmlhbmdsZUluZGV4QnVmZmVyVmlldy5ieXRlT2Zmc2V0ICtcbiAgICAgICAgICAgIHRyaWFuZ2xlSW5kZXhBY2Nlc3NvckdsdGYuYnl0ZU9mZnNldCxcbiAgICAgICAgICB0cmlhbmdsZUluZGV4QWNjZXNzb3JHbHRmLmNvdW50XG4gICAgICAgICk7XG4gIHZhciBlZGdlSW5kaWNlcyA9XG4gICAgZWRnZUluZGV4QWNjZXNzb3JHbHRmLmNvbXBvbmVudFR5cGUgPT09IDUxMjNcbiAgICAgID8gbmV3IFVpbnQxNkFycmF5KFxuICAgICAgICAgIGVkZ2VJbmRleEJ1ZmZlclZpZXcuYnVmZmVyLFxuICAgICAgICAgIGVkZ2VJbmRleEJ1ZmZlclZpZXcuYnl0ZU9mZnNldCArIGVkZ2VJbmRleEFjY2Vzc29yR2x0Zi5ieXRlT2Zmc2V0LFxuICAgICAgICAgIGVkZ2VJbmRleEFjY2Vzc29yR2x0Zi5jb3VudFxuICAgICAgICApXG4gICAgICA6IG5ldyBVaW50MzJBcnJheShcbiAgICAgICAgICBlZGdlSW5kZXhCdWZmZXJWaWV3LmJ1ZmZlcixcbiAgICAgICAgICBlZGdlSW5kZXhCdWZmZXJWaWV3LmJ5dGVPZmZzZXQgKyBlZGdlSW5kZXhBY2Nlc3NvckdsdGYuYnl0ZU9mZnNldCxcbiAgICAgICAgICBlZGdlSW5kZXhBY2Nlc3NvckdsdGYuY291bnRcbiAgICAgICAgKTtcblxuICAvLyBNYWtlIGEgaGFzaCB0YWJsZSBmb3IgcXVpY2sgbG9va3VwcyBvZiB3aGV0aGVyIGFuIGVkZ2UgZXhpc3RzIGJldHdlZW4gdHdvXG4gIC8vIHZlcnRpY2VzLiBUaGUgaGFzaCBpcyBhIHNwYXJzZSBhcnJheSBpbmRleGVkIGJ5XG4gIC8vICAgYHNtYWxsZXJWZXJ0ZXhJbmRleCAqIHRvdGFsTnVtYmVyT2ZWZXJ0aWNlcyArIGJpZ2dlclZlcnRleEluZGV4YFxuICAvLyBBIHZhbHVlIG9mIDEgaW5kaWNhdGVzIGFuIGVkZ2UgZXhpc3RzIGJldHdlZW4gdGhlIHR3byB2ZXJ0ZXggaW5kaWNlczsgYW55XG4gIC8vIG90aGVyIHZhbHVlIGluZGljYXRlcyB0aGF0IGl0IGRvZXMgbm90LiBXZSBzdG9yZSB0aGVcbiAgLy8gYGVkZ2VTbWFsbE11bHRpcGxlcmAgLSB0aGF0IGlzLCB0aGUgbnVtYmVyIG9mIHZlcnRpY2VzIGluIHRoZSBlcXVhdGlvblxuICAvLyBhYm92ZSAtIGF0IGluZGV4IDAgZm9yIGVhc3kgYWNjZXNzIHRvIGl0IGxhdGVyLlxuXG4gIHZhciBlZGdlU21hbGxNdWx0aXBsaWVyID0gbnVtVmVydGljZXM7XG5cbiAgdmFyIGVkZ2VzID0gW2VkZ2VTbWFsbE11bHRpcGxpZXJdO1xuICB2YXIgaTtcbiAgZm9yIChpID0gMDsgaSA8IGVkZ2VJbmRpY2VzLmxlbmd0aDsgaSArPSAyKSB7XG4gICAgdmFyIGEgPSBlZGdlSW5kaWNlc1tpXTtcbiAgICB2YXIgYiA9IGVkZ2VJbmRpY2VzW2kgKyAxXTtcbiAgICB2YXIgc21hbGwgPSBNYXRoLm1pbihhLCBiKTtcbiAgICB2YXIgYmlnID0gTWF0aC5tYXgoYSwgYik7XG4gICAgZWRnZXNbc21hbGwgKiBlZGdlU21hbGxNdWx0aXBsaWVyICsgYmlnXSA9IDE7XG4gIH1cblxuICAvLyBGb3IgZWFjaCB0cmlhbmdsZSwgYWRqdXN0IHZlcnRleCBkYXRhIHNvIHRoYXQgdGhlIGNvcnJlY3QgZWRnZXMgYXJlIG91dGxpbmVkLlxuICBmb3IgKGkgPSAwOyBpIDwgdHJpYW5nbGVJbmRpY2VzLmxlbmd0aDsgaSArPSAzKSB7XG4gICAgdmFyIGkwID0gdHJpYW5nbGVJbmRpY2VzW2ldO1xuICAgIHZhciBpMSA9IHRyaWFuZ2xlSW5kaWNlc1tpICsgMV07XG4gICAgdmFyIGkyID0gdHJpYW5nbGVJbmRpY2VzW2kgKyAyXTtcblxuICAgIHZhciBhbGwgPSBmYWxzZTsgLy8gc2V0IHRoaXMgdG8gdHJ1ZSB0byBkcmF3IGEgZnVsbCB3aXJlZnJhbWUuXG4gICAgdmFyIGhhczAxID0gYWxsIHx8IGlzSGlnaGxpZ2h0ZWQoZWRnZXMsIGkwLCBpMSk7XG4gICAgdmFyIGhhczEyID0gYWxsIHx8IGlzSGlnaGxpZ2h0ZWQoZWRnZXMsIGkxLCBpMik7XG4gICAgdmFyIGhhczIwID0gYWxsIHx8IGlzSGlnaGxpZ2h0ZWQoZWRnZXMsIGkyLCBpMCk7XG5cbiAgICB2YXIgdW5tYXRjaGFibGVWZXJ0ZXhJbmRleCA9IG1hdGNoQW5kU3RvcmVDb29yZGluYXRlcyhcbiAgICAgIG91dGxpbmVDb29yZGluYXRlcyxcbiAgICAgIGkwLFxuICAgICAgaTEsXG4gICAgICBpMixcbiAgICAgIGhhczAxLFxuICAgICAgaGFzMTIsXG4gICAgICBoYXMyMFxuICAgICk7XG4gICAgd2hpbGUgKHVubWF0Y2hhYmxlVmVydGV4SW5kZXggPj0gMCkge1xuICAgICAgLy8gQ29weSB0aGUgdW5tYXRjaGFibGUgaW5kZXggYW5kIHRyeSBhZ2Fpbi5cbiAgICAgIHZhciBjb3B5O1xuICAgICAgaWYgKHVubWF0Y2hhYmxlVmVydGV4SW5kZXggPT09IGkwKSB7XG4gICAgICAgIGNvcHkgPSB2ZXJ0ZXhDb3BpZXNbaTBdO1xuICAgICAgfSBlbHNlIGlmICh1bm1hdGNoYWJsZVZlcnRleEluZGV4ID09PSBpMSkge1xuICAgICAgICBjb3B5ID0gdmVydGV4Q29waWVzW2kxXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvcHkgPSB2ZXJ0ZXhDb3BpZXNbaTJdO1xuICAgICAgfVxuXG4gICAgICBpZiAoY29weSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGNvcHkgPSBudW1WZXJ0aWNlcyArIGV4dHJhVmVydGljZXMubGVuZ3RoO1xuXG4gICAgICAgIHZhciBvcmlnaW5hbCA9IHVubWF0Y2hhYmxlVmVydGV4SW5kZXg7XG4gICAgICAgIHdoaWxlIChvcmlnaW5hbCA+PSBudW1WZXJ0aWNlcykge1xuICAgICAgICAgIG9yaWdpbmFsID0gZXh0cmFWZXJ0aWNlc1tvcmlnaW5hbCAtIG51bVZlcnRpY2VzXTtcbiAgICAgICAgfVxuICAgICAgICBleHRyYVZlcnRpY2VzLnB1c2gob3JpZ2luYWwpO1xuICAgICAgICB2ZXJ0ZXhDb3BpZXNbdW5tYXRjaGFibGVWZXJ0ZXhJbmRleF0gPSBjb3B5O1xuICAgICAgfVxuXG4gICAgICBpZiAoXG4gICAgICAgIGNvcHkgPiBNQVhfR0xURl9VSU5UMTZfSU5ERVggJiZcbiAgICAgICAgdHJpYW5nbGVJbmRpY2VzIGluc3RhbmNlb2YgVWludDE2QXJyYXlcbiAgICAgICkge1xuICAgICAgICAvLyBXZSBvdXRncmV3IGEgMTYtYml0IGluZGV4IGJ1ZmZlciwgc3dpdGNoIHRvIDMyLWJpdC5cbiAgICAgICAgdHJpYW5nbGVJbmRpY2VzID0gbmV3IFVpbnQzMkFycmF5KHRyaWFuZ2xlSW5kaWNlcyk7XG4gICAgICAgIHRyaWFuZ2xlSW5kZXhBY2Nlc3NvckdsdGYuY29tcG9uZW50VHlwZSA9IDUxMjU7IC8vIFVOU0lHTkVEX0lOVFxuICAgICAgICB0cmlhbmdsZUluZGV4QnVmZmVyVmlld0dsdGYuYnVmZmVyID1cbiAgICAgICAgICBnbHRmLmJ1ZmZlcnMucHVzaCh7XG4gICAgICAgICAgICBieXRlTGVuZ3RoOiB0cmlhbmdsZUluZGljZXMuYnl0ZUxlbmd0aCxcbiAgICAgICAgICAgIGV4dHJhczoge1xuICAgICAgICAgICAgICBfcGlwZWxpbmU6IHtcbiAgICAgICAgICAgICAgICBzb3VyY2U6IHRyaWFuZ2xlSW5kaWNlcy5idWZmZXIsXG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9LFxuICAgICAgICAgIH0pIC0gMTtcbiAgICAgICAgdHJpYW5nbGVJbmRleEJ1ZmZlclZpZXdHbHRmLmJ5dGVMZW5ndGggPSB0cmlhbmdsZUluZGljZXMuYnl0ZUxlbmd0aDtcbiAgICAgICAgdHJpYW5nbGVJbmRleEJ1ZmZlclZpZXdHbHRmLmJ5dGVPZmZzZXQgPSAwO1xuICAgICAgICBtb2RlbC5fbG9hZFJlc291cmNlcy5idWZmZXJzW1xuICAgICAgICAgIHRyaWFuZ2xlSW5kZXhCdWZmZXJWaWV3R2x0Zi5idWZmZXJcbiAgICAgICAgXSA9IG5ldyBVaW50OEFycmF5KFxuICAgICAgICAgIHRyaWFuZ2xlSW5kaWNlcy5idWZmZXIsXG4gICAgICAgICAgMCxcbiAgICAgICAgICB0cmlhbmdsZUluZGljZXMuYnl0ZUxlbmd0aFxuICAgICAgICApO1xuXG4gICAgICAgIC8vIFRoZSBpbmRleCBjb21wb25lbnRUeXBlIGlzIGFsc28gc3F1aXJyZWxlZCBhd2F5IGluIE1vZGVsTG9hZFJlc291cmNlcy5cbiAgICAgICAgLy8gSGFja2lseSB1cGRhdGUgaXQsIG9yIGVsc2Ugd2UnbGwgZW5kIHVwIGNyZWF0aW5nIHRoZSB3cm9uZyB0eXBlXG4gICAgICAgIC8vIG9mIGluZGV4IGJ1ZmZlciBsYXRlci5cbiAgICAgICAgbG9hZFJlc291cmNlcy5pbmRleEJ1ZmZlcnNUb0NyZWF0ZS5fYXJyYXkuZm9yRWFjaChmdW5jdGlvbiAodG9DcmVhdGUpIHtcbiAgICAgICAgICBpZiAodG9DcmVhdGUuaWQgPT09IHRyaWFuZ2xlSW5kZXhBY2Nlc3NvckdsdGYuYnVmZmVyVmlldykge1xuICAgICAgICAgICAgdG9DcmVhdGUuY29tcG9uZW50VHlwZSA9IHRyaWFuZ2xlSW5kZXhBY2Nlc3NvckdsdGYuY29tcG9uZW50VHlwZTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICBpZiAodW5tYXRjaGFibGVWZXJ0ZXhJbmRleCA9PT0gaTApIHtcbiAgICAgICAgaTAgPSBjb3B5O1xuICAgICAgICB0cmlhbmdsZUluZGljZXNbaV0gPSBjb3B5O1xuICAgICAgfSBlbHNlIGlmICh1bm1hdGNoYWJsZVZlcnRleEluZGV4ID09PSBpMSkge1xuICAgICAgICBpMSA9IGNvcHk7XG4gICAgICAgIHRyaWFuZ2xlSW5kaWNlc1tpICsgMV0gPSBjb3B5O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaTIgPSBjb3B5O1xuICAgICAgICB0cmlhbmdsZUluZGljZXNbaSArIDJdID0gY29weTtcbiAgICAgIH1cblxuICAgICAgaWYgKGRlZmluZWQodHJpYW5nbGVJbmRleEFjY2Vzc29yR2x0Zi5tYXgpKSB7XG4gICAgICAgIHRyaWFuZ2xlSW5kZXhBY2Nlc3NvckdsdGYubWF4WzBdID0gTWF0aC5tYXgoXG4gICAgICAgICAgdHJpYW5nbGVJbmRleEFjY2Vzc29yR2x0Zi5tYXhbMF0sXG4gICAgICAgICAgY29weVxuICAgICAgICApO1xuICAgICAgfVxuXG4gICAgICB1bm1hdGNoYWJsZVZlcnRleEluZGV4ID0gbWF0Y2hBbmRTdG9yZUNvb3JkaW5hdGVzKFxuICAgICAgICBvdXRsaW5lQ29vcmRpbmF0ZXMsXG4gICAgICAgIGkwLFxuICAgICAgICBpMSxcbiAgICAgICAgaTIsXG4gICAgICAgIGhhczAxLFxuICAgICAgICBoYXMxMixcbiAgICAgICAgaGFzMjBcbiAgICAgICk7XG4gICAgfVxuICB9XG59XG5cbi8vIEVhY2ggdmVydGV4IGhhcyB0aHJlZSBjb29yZGluYXRlcywgYSwgYiwgYW5kIGMuXG4vLyBhIGlzIHRoZSBjb29yZGluYXRlIHRoYXQgYXBwbGllcyB0byBlZGdlIDItMCBmb3IgdGhlIHZlcnRleC5cbi8vIGIgaXMgdGhlIGNvb3JkaW5hdGUgdGhhdCBhcHBsaWVzIHRvIGVkZ2UgMC0xIGZvciB0aGUgdmVydGV4LlxuLy8gYyBpcyB0aGUgY29vcmRpbmF0ZSB0aGF0IGFwcGxpZXMgdG8gZWRnZSAxLTIgZm9yIHRoZSB2ZXJ0ZXguXG5cbi8vIEEgc2luZ2xlIHRyaWFuZ2xlIHdpdGggYWxsIGVkZ2VzIGhpZ2hsaWdodGVkOlxuLy9cbi8vICAgICAgICAgICAgICAgICB8IGEgfCBiIHwgYyB8XG4vLyAgICAgICAgICAgICAgICAgfCAxIHwgMSB8IDAgfFxuLy8gICAgICAgICAgICAgICAgICAgICAgIDBcbi8vICAgICAgICAgICAgICAgICAgICAgIC8gXFxcbi8vICAgICAgICAgICAgICAgICAgICAgLyAgIFxcXG4vLyAgICAgICAgICAgZWRnZSAwLTEgLyAgICAgXFwgZWRnZSAyLTBcbi8vICAgICAgICAgICAgICAgICAgIC8gICAgICAgXFxcbi8vICAgICAgICAgICAgICAgICAgLyAgICAgICAgIFxcXG4vLyB8IGEgfCBiIHwgYyB8ICAgMS0tLS0tLS0tLS0tMiAgIHwgYSB8IGIgfCBjIHxcbi8vIHwgMCB8IDEgfCAxIHwgICAgIGVkZ2UgMS0yICAgICAgfCAxIHwgMCB8IDEgfFxuLy9cbi8vIFRoZXJlIGFyZSA2IHBvc3NpYmxlIG9yZGVyaW5ncyBvZiBjb29yZGluYXRlcyBhLCBiLCBhbmQgYzpcbi8vIDAgLSBhYmNcbi8vIDEgLSBhY2Jcbi8vIDIgLSBiYWNcbi8vIDMgLSBiY2Fcbi8vIDQgLSBjYWJcbi8vIDUgLSBjYmFcblxuLy8gQWxsIHZlcnRpY2VzIG11c3QgdXNlIHRoZSBfc2FtZSBvcmRlcmluZ18gZm9yIHRoZSBlZGdlcyB0byBiZSByZW5kZXJlZFxuLy8gY29ycmVjdGx5LiBTbyB3ZSBjb21wdXRlIGEgYml0bWFzayBmb3IgZWFjaCB2ZXJ0ZXgsIHdoZXJlIHRoZSBiaXQgYXRcbi8vIGVhY2ggcG9zaXRpb24gaW5kaWNhdGVzIHdoZXRoZXIgdGhhdCBvcmRlcmluZyB3b3JrcyAoaS5lLiBkb2Vzbid0XG4vLyBjb25mbGljdCB3aXRoIGFscmVhZHktYXNzaWduZWQgY29vcmRpbmF0ZXMpIGZvciB0aGF0IHZlcnRleC5cblxuLy8gVGhlbiB3ZSBjYW4gZmluZCBhbiBvcmRlcmluZyB0aGF0IHdvcmtzIGZvciBhbGwgdGhyZWUgdmVydGljZXMgd2l0aCBhXG4vLyBiaXR3aXNlIEFORC5cblxuZnVuY3Rpb24gY29tcHV0ZU9yZGVyTWFzayhvdXRsaW5lQ29vcmRpbmF0ZXMsIHZlcnRleEluZGV4LCBhLCBiLCBjKSB7XG4gIHZhciBzdGFydEluZGV4ID0gdmVydGV4SW5kZXggKiAzO1xuICB2YXIgZmlyc3QgPSBvdXRsaW5lQ29vcmRpbmF0ZXNbc3RhcnRJbmRleF07XG4gIHZhciBzZWNvbmQgPSBvdXRsaW5lQ29vcmRpbmF0ZXNbc3RhcnRJbmRleCArIDFdO1xuICB2YXIgdGhpcmQgPSBvdXRsaW5lQ29vcmRpbmF0ZXNbc3RhcnRJbmRleCArIDJdO1xuXG4gIGlmIChmaXJzdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgLy8gSWYgb25lIGNvb3JkaW5hdGUgaXMgdW5kZWZpbmVkLCB0aGV5IGFsbCBhcmUsIGFuZCBhbGwgb3JkZXJpbmdzIGFyZSBmaW5lLlxuICAgIHJldHVybiA2MzsgLy8gMGIxMTExMTE7XG4gIH1cblxuICByZXR1cm4gKFxuICAgICgoZmlyc3QgPT09IGEgJiYgc2Vjb25kID09PSBiICYmIHRoaXJkID09PSBjKSA8PCAwKSArXG4gICAgKChmaXJzdCA9PT0gYSAmJiBzZWNvbmQgPT09IGMgJiYgdGhpcmQgPT09IGIpIDw8IDEpICtcbiAgICAoKGZpcnN0ID09PSBiICYmIHNlY29uZCA9PT0gYSAmJiB0aGlyZCA9PT0gYykgPDwgMikgK1xuICAgICgoZmlyc3QgPT09IGIgJiYgc2Vjb25kID09PSBjICYmIHRoaXJkID09PSBhKSA8PCAzKSArXG4gICAgKChmaXJzdCA9PT0gYyAmJiBzZWNvbmQgPT09IGEgJiYgdGhpcmQgPT09IGIpIDw8IDQpICtcbiAgICAoKGZpcnN0ID09PSBjICYmIHNlY29uZCA9PT0gYiAmJiB0aGlyZCA9PT0gYSkgPDwgNSlcbiAgKTtcbn1cblxuLy8gcG9wY291bnQgZm9yIGludGVnZXJzIDAtNjMsIGluY2x1c2l2ZS5cbi8vIGkuZS4gaG93IG1hbnkgMXMgYXJlIGluIHRoZSBiaW5hcnkgcmVwcmVzZW50YXRpb24gb2YgdGhlIGludGVnZXIuXG5mdW5jdGlvbiBwb3Bjb3VudDB0bzYzKHZhbHVlKSB7XG4gIHJldHVybiAoXG4gICAgKHZhbHVlICYgMSkgK1xuICAgICgodmFsdWUgPj4gMSkgJiAxKSArXG4gICAgKCh2YWx1ZSA+PiAyKSAmIDEpICtcbiAgICAoKHZhbHVlID4+IDMpICYgMSkgK1xuICAgICgodmFsdWUgPj4gNCkgJiAxKSArXG4gICAgKCh2YWx1ZSA+PiA1KSAmIDEpXG4gICk7XG59XG5cbmZ1bmN0aW9uIG1hdGNoQW5kU3RvcmVDb29yZGluYXRlcyhcbiAgb3V0bGluZUNvb3JkaW5hdGVzLFxuICBpMCxcbiAgaTEsXG4gIGkyLFxuICBoYXMwMSxcbiAgaGFzMTIsXG4gIGhhczIwXG4pIHtcbiAgdmFyIGEwID0gaGFzMjAgPyAxLjAgOiAwLjA7XG4gIHZhciBiMCA9IGhhczAxID8gMS4wIDogMC4wO1xuICB2YXIgYzAgPSAwLjA7XG5cbiAgdmFyIGkwTWFzayA9IGNvbXB1dGVPcmRlck1hc2sob3V0bGluZUNvb3JkaW5hdGVzLCBpMCwgYTAsIGIwLCBjMCk7XG4gIGlmIChpME1hc2sgPT09IDApIHtcbiAgICByZXR1cm4gaTA7XG4gIH1cblxuICB2YXIgYTEgPSAwLjA7XG4gIHZhciBiMSA9IGhhczAxID8gMS4wIDogMC4wO1xuICB2YXIgYzEgPSBoYXMxMiA/IDEuMCA6IDAuMDtcblxuICB2YXIgaTFNYXNrID0gY29tcHV0ZU9yZGVyTWFzayhvdXRsaW5lQ29vcmRpbmF0ZXMsIGkxLCBhMSwgYjEsIGMxKTtcbiAgaWYgKGkxTWFzayA9PT0gMCkge1xuICAgIHJldHVybiBpMTtcbiAgfVxuXG4gIHZhciBhMiA9IGhhczIwID8gMS4wIDogMC4wO1xuICB2YXIgYjIgPSAwLjA7XG4gIHZhciBjMiA9IGhhczEyID8gMS4wIDogMC4wO1xuXG4gIHZhciBpMk1hc2sgPSBjb21wdXRlT3JkZXJNYXNrKG91dGxpbmVDb29yZGluYXRlcywgaTIsIGEyLCBiMiwgYzIpO1xuICBpZiAoaTJNYXNrID09PSAwKSB7XG4gICAgcmV0dXJuIGkyO1xuICB9XG5cbiAgdmFyIHdvcmtpbmdPcmRlcnMgPSBpME1hc2sgJiBpMU1hc2sgJiBpMk1hc2s7XG5cbiAgdmFyIGEsIGIsIGM7XG5cbiAgaWYgKHdvcmtpbmdPcmRlcnMgJiAoMSA8PCAwKSkge1xuICAgIC8vIDAgLSBhYmNcbiAgICBhID0gMDtcbiAgICBiID0gMTtcbiAgICBjID0gMjtcbiAgfSBlbHNlIGlmICh3b3JraW5nT3JkZXJzICYgKDEgPDwgMSkpIHtcbiAgICAvLyAxIC0gYWNiXG4gICAgYSA9IDA7XG4gICAgYyA9IDE7XG4gICAgYiA9IDI7XG4gIH0gZWxzZSBpZiAod29ya2luZ09yZGVycyAmICgxIDw8IDIpKSB7XG4gICAgLy8gMiAtIGJhY1xuICAgIGIgPSAwO1xuICAgIGEgPSAxO1xuICAgIGMgPSAyO1xuICB9IGVsc2UgaWYgKHdvcmtpbmdPcmRlcnMgJiAoMSA8PCAzKSkge1xuICAgIC8vIDMgLSBiY2FcbiAgICBiID0gMDtcbiAgICBjID0gMTtcbiAgICBhID0gMjtcbiAgfSBlbHNlIGlmICh3b3JraW5nT3JkZXJzICYgKDEgPDwgNCkpIHtcbiAgICAvLyA0IC0gY2FiXG4gICAgYyA9IDA7XG4gICAgYSA9IDE7XG4gICAgYiA9IDI7XG4gIH0gZWxzZSBpZiAod29ya2luZ09yZGVycyAmICgxIDw8IDUpKSB7XG4gICAgLy8gNSAtIGNiYVxuICAgIGMgPSAwO1xuICAgIGIgPSAxO1xuICAgIGEgPSAyO1xuICB9IGVsc2Uge1xuICAgIC8vIE5vIG9yZGVyaW5nIHdvcmtzLlxuICAgIC8vIFJlcG9ydCB0aGUgbW9zdCBjb25zdHJhaW5lZCB2ZXJ0ZXggYXMgdW5tYXRjaGVkIHNvIHdlIGNvcHkgdGhhdCBvbmUuXG4gICAgdmFyIGkwUG9wY291bnQgPSBwb3Bjb3VudDB0bzYzKGkwTWFzayk7XG4gICAgdmFyIGkxUG9wY291bnQgPSBwb3Bjb3VudDB0bzYzKGkxTWFzayk7XG4gICAgdmFyIGkyUG9wY291bnQgPSBwb3Bjb3VudDB0bzYzKGkyTWFzayk7XG4gICAgaWYgKGkwUG9wY291bnQgPCBpMVBvcGNvdW50ICYmIGkwUG9wY291bnQgPCBpMlBvcGNvdW50KSB7XG4gICAgICByZXR1cm4gaTA7XG4gICAgfSBlbHNlIGlmIChpMVBvcGNvdW50IDwgaTJQb3Bjb3VudCkge1xuICAgICAgcmV0dXJuIGkxO1xuICAgIH1cbiAgICByZXR1cm4gaTI7XG4gIH1cblxuICB2YXIgaTBTdGFydCA9IGkwICogMztcbiAgb3V0bGluZUNvb3JkaW5hdGVzW2kwU3RhcnQgKyBhXSA9IGEwO1xuICBvdXRsaW5lQ29vcmRpbmF0ZXNbaTBTdGFydCArIGJdID0gYjA7XG4gIG91dGxpbmVDb29yZGluYXRlc1tpMFN0YXJ0ICsgY10gPSBjMDtcblxuICB2YXIgaTFTdGFydCA9IGkxICogMztcbiAgb3V0bGluZUNvb3JkaW5hdGVzW2kxU3RhcnQgKyBhXSA9IGExO1xuICBvdXRsaW5lQ29vcmRpbmF0ZXNbaTFTdGFydCArIGJdID0gYjE7XG4gIG91dGxpbmVDb29yZGluYXRlc1tpMVN0YXJ0ICsgY10gPSBjMTtcblxuICB2YXIgaTJTdGFydCA9IGkyICogMztcbiAgb3V0bGluZUNvb3JkaW5hdGVzW2kyU3RhcnQgKyBhXSA9IGEyO1xuICBvdXRsaW5lQ29vcmRpbmF0ZXNbaTJTdGFydCArIGJdID0gYjI7XG4gIG91dGxpbmVDb29yZGluYXRlc1tpMlN0YXJ0ICsgY10gPSBjMjtcblxuICByZXR1cm4gLTE7XG59XG5cbmZ1bmN0aW9uIGlzSGlnaGxpZ2h0ZWQoZWRnZXMsIGkwLCBpMSkge1xuICB2YXIgZWRnZVNtYWxsTXVsdGlwbGllciA9IGVkZ2VzWzBdO1xuICB2YXIgaW5kZXggPSBNYXRoLm1pbihpMCwgaTEpICogZWRnZVNtYWxsTXVsdGlwbGllciArIE1hdGgubWF4KGkwLCBpMSk7XG5cbiAgLy8gSWYgaTAgYW5kIGkxIGFyZSBib3RoIDAsIHRoZW4gb3VyIGluZGV4IHdpbGwgYmUgMCBhbmQgd2UnbGwgZW5kIHVwXG4gIC8vIGFjY2Vzc2luZyB0aGUgZWRnZVNtYWxsTXVsdGlwbGllciB0aGF0IHdlJ3ZlIHNuZWFraWx5IHNxdWlycmVsZWQgYXdheVxuICAvLyBpbiBpbmRleCAwLiBCdXQgaXQgbWFrZXMgbm8gc2Vuc2UgdG8gaGF2ZSBhbiBlZGdlIGJldHdlZW4gdmVydGV4IDAgYW5kXG4gIC8vIGl0c2VsZiwgc28gZm9yIGFueSBlZGdlU21hbGxNdWx0aXBsaWVyIG90aGVyIHRoYW4gMSB3ZSdsbCByZXR1cm4gdGhlXG4gIC8vIGNvcnJlY3QgYW5zd2VyOiBmYWxzZS4gSWYgZWRnZVNtYWxsTXVsdGlwbGllciBpcyAxLCB0aGF0IG1lYW5zIHRoZXJlIGlzXG4gIC8vIG9ubHkgYSBzaW5nbGUgdmVydGV4LCBzbyBubyBkYW5nZXIgb2YgZm9ybWluZyBhIG1lYW5pbmdmdWwgdHJpYW5nbGVcbiAgLy8gd2l0aCB0aGF0LlxuICByZXR1cm4gZWRnZXNbaW5kZXhdID09PSAxO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVUZXh0dXJlKHNpemUpIHtcbiAgdmFyIHRleHR1cmUgPSBuZXcgVWludDhBcnJheShzaXplKTtcbiAgdGV4dHVyZVtzaXplIC0gMV0gPSAxOTI7XG4gIGlmIChzaXplID09PSA4KSB7XG4gICAgdGV4dHVyZVtzaXplIC0gMV0gPSA5NjtcbiAgfSBlbHNlIGlmIChzaXplID09PSA0KSB7XG4gICAgdGV4dHVyZVtzaXplIC0gMV0gPSA0ODtcbiAgfSBlbHNlIGlmIChzaXplID09PSAyKSB7XG4gICAgdGV4dHVyZVtzaXplIC0gMV0gPSAyNDtcbiAgfSBlbHNlIGlmIChzaXplID09PSAxKSB7XG4gICAgdGV4dHVyZVtzaXplIC0gMV0gPSAxMjtcbiAgfVxuICByZXR1cm4gdGV4dHVyZTtcbn1cblxuZnVuY3Rpb24gdXBkYXRlQnVmZmVyVmlld3NXaXRoTmV3VmVydGljZXMobW9kZWwsIGJ1ZmZlclZpZXdzKSB7XG4gIHZhciBnbHRmID0gbW9kZWwuZ2x0ZjtcbiAgdmFyIGxvYWRSZXNvdXJjZXMgPSBtb2RlbC5fbG9hZFJlc291cmNlcztcblxuICB2YXIgaSwgajtcbiAgZm9yIChpID0gMDsgaSA8IGJ1ZmZlclZpZXdzLmxlbmd0aDsgKytpKSB7XG4gICAgdmFyIGJ1ZmZlclZpZXcgPSBidWZmZXJWaWV3c1tpXTtcbiAgICB2YXIgdmVydGV4TnVtYmVyaW5nU2NvcGUgPSBidWZmZXJWaWV3LmV4dHJhcy5fcGlwZWxpbmUudmVydGV4TnVtYmVyaW5nU2NvcGU7XG5cbiAgICAvLyBMZXQgdGhlIHRlbXBvcmFyeSBkYXRhIGJlIGdhcmJhZ2UgY29sbGVjdGVkLlxuICAgIGJ1ZmZlclZpZXcuZXh0cmFzLl9waXBlbGluZS52ZXJ0ZXhOdW1iZXJpbmdTY29wZSA9IHVuZGVmaW5lZDtcblxuICAgIHZhciBuZXdWZXJ0aWNlcyA9IHZlcnRleE51bWJlcmluZ1Njb3BlLmV4dHJhVmVydGljZXM7XG5cbiAgICB2YXIgc291cmNlRGF0YSA9IGxvYWRSZXNvdXJjZXMuZ2V0QnVmZmVyKGJ1ZmZlclZpZXcpO1xuICAgIHZhciBieXRlU3RyaWRlID0gYnVmZmVyVmlldy5ieXRlU3RyaWRlIHx8IDQ7XG4gICAgdmFyIG5ld1ZlcnRpY2VzTGVuZ3RoID0gbmV3VmVydGljZXMubGVuZ3RoO1xuICAgIHZhciBkZXN0RGF0YSA9IG5ldyBVaW50OEFycmF5KFxuICAgICAgc291cmNlRGF0YS5ieXRlTGVuZ3RoICsgbmV3VmVydGljZXNMZW5ndGggKiBieXRlU3RyaWRlXG4gICAgKTtcblxuICAgIC8vIENvcHkgdGhlIG9yaWdpbmFsIHZlcnRpY2VzXG4gICAgZGVzdERhdGEuc2V0KHNvdXJjZURhdGEpO1xuXG4gICAgLy8gQ29weSB0aGUgdmVydGljZXMgYWRkZWQgZm9yIG91dGxpbmluZ1xuICAgIGZvciAoaiA9IDA7IGogPCBuZXdWZXJ0aWNlc0xlbmd0aDsgKytqKSB7XG4gICAgICB2YXIgc291cmNlSW5kZXggPSBuZXdWZXJ0aWNlc1tqXSAqIGJ5dGVTdHJpZGU7XG4gICAgICB2YXIgZGVzdEluZGV4ID0gc291cmNlRGF0YS5sZW5ndGggKyBqICogYnl0ZVN0cmlkZTtcbiAgICAgIGZvciAodmFyIGsgPSAwOyBrIDwgYnl0ZVN0cmlkZTsgKytrKSB7XG4gICAgICAgIGRlc3REYXRhW2Rlc3RJbmRleCArIGtdID0gZGVzdERhdGFbc291cmNlSW5kZXggKyBrXTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBUaGlzIGJ1ZmZlclZpZXcgaXMgYW4gaW5kZXBlbmRlbnQgYnVmZmVyIG5vdy4gVXBkYXRlIHRoZSBtb2RlbCBhY2NvcmRpbmdseS5cbiAgICBidWZmZXJWaWV3LmJ5dGVPZmZzZXQgPSAwO1xuICAgIGJ1ZmZlclZpZXcuYnl0ZUxlbmd0aCA9IGRlc3REYXRhLmJ5dGVMZW5ndGg7XG5cbiAgICB2YXIgYnVmZmVySWQgPVxuICAgICAgZ2x0Zi5idWZmZXJzLnB1c2goe1xuICAgICAgICBieXRlTGVuZ3RoOiBkZXN0RGF0YS5ieXRlTGVuZ3RoLFxuICAgICAgICBleHRyYXM6IHtcbiAgICAgICAgICBfcGlwZWxpbmU6IHtcbiAgICAgICAgICAgIHNvdXJjZTogZGVzdERhdGEuYnVmZmVyLFxuICAgICAgICAgIH0sXG4gICAgICAgIH0sXG4gICAgICB9KSAtIDE7XG5cbiAgICBidWZmZXJWaWV3LmJ1ZmZlciA9IGJ1ZmZlcklkO1xuICAgIGxvYWRSZXNvdXJjZXMuYnVmZmVyc1tidWZmZXJJZF0gPSBkZXN0RGF0YTtcblxuICAgIC8vIFVwZGF0ZSB0aGUgYWNjZXNzb3JzIHRvIHJlZmxlY3QgdGhlIGFkZGVkIHZlcnRpY2VzLlxuICAgIHZhciBhY2Nlc3NvcnMgPSB2ZXJ0ZXhOdW1iZXJpbmdTY29wZS5hY2Nlc3NvcnM7XG4gICAgZm9yIChqID0gMDsgaiA8IGFjY2Vzc29ycy5sZW5ndGg7ICsraikge1xuICAgICAgdmFyIGFjY2Vzc29ySWQgPSBhY2Nlc3NvcnNbal07XG4gICAgICBnbHRmLmFjY2Vzc29yc1thY2Nlc3NvcklkXS5jb3VudCArPSBuZXdWZXJ0aWNlc0xlbmd0aDtcbiAgICB9XG5cbiAgICBpZiAoIXZlcnRleE51bWJlcmluZ1Njb3BlLmNyZWF0ZWRPdXRsaW5lcykge1xuICAgICAgLy8gQ3JlYXRlIHRoZSBidWZmZXJzLCB2aWV3cywgYW5kIGFjY2Vzc29ycyBmb3IgdGhlIG91dGxpbmUgdGV4dHVyZSBjb29yZGluYXRlcy5cbiAgICAgIHZhciBvdXRsaW5lQ29vcmRpbmF0ZXMgPSB2ZXJ0ZXhOdW1iZXJpbmdTY29wZS5vdXRsaW5lQ29vcmRpbmF0ZXM7XG4gICAgICB2YXIgb3V0bGluZUNvb3JkaW5hdGVCdWZmZXIgPSBuZXcgRmxvYXQzMkFycmF5KG91dGxpbmVDb29yZGluYXRlcyk7XG4gICAgICB2YXIgYnVmZmVySW5kZXggPVxuICAgICAgICBtb2RlbC5nbHRmLmJ1ZmZlcnMucHVzaCh7XG4gICAgICAgICAgYnl0ZUxlbmd0aDogb3V0bGluZUNvb3JkaW5hdGVCdWZmZXIuYnl0ZUxlbmd0aCxcbiAgICAgICAgICBleHRyYXM6IHtcbiAgICAgICAgICAgIF9waXBlbGluZToge1xuICAgICAgICAgICAgICBzb3VyY2U6IG91dGxpbmVDb29yZGluYXRlQnVmZmVyLmJ1ZmZlcixcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgfSxcbiAgICAgICAgfSkgLSAxO1xuICAgICAgbG9hZFJlc291cmNlcy5idWZmZXJzW2J1ZmZlckluZGV4XSA9IG5ldyBVaW50OEFycmF5KFxuICAgICAgICBvdXRsaW5lQ29vcmRpbmF0ZUJ1ZmZlci5idWZmZXIsXG4gICAgICAgIDAsXG4gICAgICAgIG91dGxpbmVDb29yZGluYXRlQnVmZmVyLmJ5dGVMZW5ndGhcbiAgICAgICk7XG5cbiAgICAgIHZhciBidWZmZXJWaWV3SW5kZXggPVxuICAgICAgICBtb2RlbC5nbHRmLmJ1ZmZlclZpZXdzLnB1c2goe1xuICAgICAgICAgIGJ1ZmZlcjogYnVmZmVySW5kZXgsXG4gICAgICAgICAgYnl0ZUxlbmd0aDogb3V0bGluZUNvb3JkaW5hdGVCdWZmZXIuYnl0ZUxlbmd0aCxcbiAgICAgICAgICBieXRlT2Zmc2V0OiAwLFxuICAgICAgICAgIGJ5dGVTdHJpZGU6IDMgKiBGbG9hdDMyQXJyYXkuQllURVNfUEVSX0VMRU1FTlQsXG4gICAgICAgICAgdGFyZ2V0OiAzNDk2MixcbiAgICAgICAgfSkgLSAxO1xuXG4gICAgICB2YXIgYWNjZXNzb3JJbmRleCA9XG4gICAgICAgIG1vZGVsLmdsdGYuYWNjZXNzb3JzLnB1c2goe1xuICAgICAgICAgIGJ1ZmZlclZpZXc6IGJ1ZmZlclZpZXdJbmRleCxcbiAgICAgICAgICBieXRlT2Zmc2V0OiAwLFxuICAgICAgICAgIGNvbXBvbmVudFR5cGU6IDUxMjYsXG4gICAgICAgICAgY291bnQ6IG91dGxpbmVDb29yZGluYXRlQnVmZmVyLmxlbmd0aCAvIDMsXG4gICAgICAgICAgdHlwZTogXCJWRUMzXCIsXG4gICAgICAgICAgbWluOiBbMC4wLCAwLjAsIDAuMF0sXG4gICAgICAgICAgbWF4OiBbMS4wLCAxLjAsIDEuMF0sXG4gICAgICAgIH0pIC0gMTtcblxuICAgICAgdmFyIHByaW1pdGl2ZXMgPSB2ZXJ0ZXhOdW1iZXJpbmdTY29wZS5wcmltaXRpdmVzO1xuICAgICAgZm9yIChqID0gMDsgaiA8IHByaW1pdGl2ZXMubGVuZ3RoOyArK2opIHtcbiAgICAgICAgcHJpbWl0aXZlc1tqXS5hdHRyaWJ1dGVzLl9PVVRMSU5FX0NPT1JESU5BVEVTID0gYWNjZXNzb3JJbmRleDtcbiAgICAgIH1cblxuICAgICAgbG9hZFJlc291cmNlcy52ZXJ0ZXhCdWZmZXJzVG9DcmVhdGUuZW5xdWV1ZShidWZmZXJWaWV3SW5kZXgpO1xuXG4gICAgICB2ZXJ0ZXhOdW1iZXJpbmdTY29wZS5jcmVhdGVkT3V0bGluZXMgPSB0cnVlO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBjb21wYWN0QnVmZmVycyhtb2RlbCkge1xuICB2YXIgZ2x0ZiA9IG1vZGVsLmdsdGY7XG4gIHZhciBsb2FkUmVzb3VyY2VzID0gbW9kZWwuX2xvYWRSZXNvdXJjZXM7XG5cbiAgdmFyIGk7XG4gIGZvciAoaSA9IDA7IGkgPCBnbHRmLmJ1ZmZlcnMubGVuZ3RoOyArK2kpIHtcbiAgICB2YXIgYnVmZmVyID0gZ2x0Zi5idWZmZXJzW2ldO1xuICAgIHZhciBidWZmZXJWaWV3c1VzaW5nVGhpc0J1ZmZlciA9IGdsdGYuYnVmZmVyVmlld3MuZmlsdGVyKFxuICAgICAgdXNlc0J1ZmZlci5iaW5kKHVuZGVmaW5lZCwgaSlcbiAgICApO1xuICAgIHZhciBuZXdMZW5ndGggPSBidWZmZXJWaWV3c1VzaW5nVGhpc0J1ZmZlci5yZWR1Y2UoZnVuY3Rpb24gKFxuICAgICAgcHJldmlvdXMsXG4gICAgICBjdXJyZW50XG4gICAgKSB7XG4gICAgICByZXR1cm4gcHJldmlvdXMgKyBjdXJyZW50LmJ5dGVMZW5ndGg7XG4gICAgfSxcbiAgICAwKTtcbiAgICBpZiAobmV3TGVuZ3RoID09PSBidWZmZXIuYnl0ZUxlbmd0aCkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgdmFyIG5ld0J1ZmZlciA9IG5ldyBVaW50OEFycmF5KG5ld0xlbmd0aCk7XG4gICAgdmFyIG9mZnNldCA9IDA7XG4gICAgZm9yICh2YXIgaiA9IDA7IGogPCBidWZmZXJWaWV3c1VzaW5nVGhpc0J1ZmZlci5sZW5ndGg7ICsraikge1xuICAgICAgdmFyIGJ1ZmZlclZpZXcgPSBidWZmZXJWaWV3c1VzaW5nVGhpc0J1ZmZlcltqXTtcbiAgICAgIHZhciBzb3VyY2VEYXRhID0gbG9hZFJlc291cmNlcy5nZXRCdWZmZXIoYnVmZmVyVmlldyk7XG4gICAgICBuZXdCdWZmZXIuc2V0KHNvdXJjZURhdGEsIG9mZnNldCk7XG5cbiAgICAgIGJ1ZmZlclZpZXcuYnl0ZU9mZnNldCA9IG9mZnNldDtcbiAgICAgIG9mZnNldCArPSBzb3VyY2VEYXRhLmJ5dGVMZW5ndGg7XG4gICAgfVxuXG4gICAgbG9hZFJlc291cmNlcy5idWZmZXJzW2ldID0gbmV3QnVmZmVyO1xuICAgIGJ1ZmZlci5leHRyYXMuX3BpcGVsaW5lLnNvdXJjZSA9IG5ld0J1ZmZlci5idWZmZXI7XG4gICAgYnVmZmVyLmJ5dGVMZW5ndGggPSBuZXdMZW5ndGg7XG4gIH1cbn1cblxuZnVuY3Rpb24gdXNlc0J1ZmZlcihidWZmZXJJZCwgYnVmZmVyVmlldykge1xuICByZXR1cm4gYnVmZmVyVmlldy5idWZmZXIgPT09IGJ1ZmZlcklkO1xufVxuXG5mdW5jdGlvbiBnZXRWZXJ0ZXhOdW1iZXJpbmdTY29wZShtb2RlbCwgcHJpbWl0aXZlKSB7XG4gIHZhciBhdHRyaWJ1dGVzID0gcHJpbWl0aXZlLmF0dHJpYnV0ZXM7XG4gIGlmIChhdHRyaWJ1dGVzID09PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG5cbiAgdmFyIGdsdGYgPSBtb2RlbC5nbHRmO1xuXG4gIHZhciB2ZXJ0ZXhOdW1iZXJpbmdTY29wZTtcblxuICAvLyBJbml0aWFsaXplIGNvbW1vbiBkZXRhaWxzIGZvciBhbGwgYnVmZmVyVmlld3MgdXNlZCBieSB0aGlzIHByaW1pdGl2ZSdzIHZlcnRpY2VzLlxuICAvLyBBbGwgYnVmZmVyVmlld3MgdXNlZCBieSB0aGlzIHByaW1pdGl2ZSBtdXN0IHVzZSBhIGNvbW1vbiB2ZXJ0ZXggbnVtYmVyaW5nIHNjaGVtZS5cbiAgZm9yICh2YXIgc2VtYW50aWMgaW4gYXR0cmlidXRlcykge1xuICAgIGlmICghYXR0cmlidXRlcy5oYXNPd25Qcm9wZXJ0eShzZW1hbnRpYykpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIHZhciBhY2Nlc3NvcklkID0gYXR0cmlidXRlc1tzZW1hbnRpY107XG4gICAgdmFyIGFjY2Vzc29yID0gZ2x0Zi5hY2Nlc3NvcnNbYWNjZXNzb3JJZF07XG4gICAgdmFyIGJ1ZmZlclZpZXdJZCA9IGFjY2Vzc29yLmJ1ZmZlclZpZXc7XG4gICAgdmFyIGJ1ZmZlclZpZXcgPSBnbHRmLmJ1ZmZlclZpZXdzW2J1ZmZlclZpZXdJZF07XG5cbiAgICBpZiAoIWRlZmluZWQoYnVmZmVyVmlldy5leHRyYXMpKSB7XG4gICAgICBidWZmZXJWaWV3LmV4dHJhcyA9IHt9O1xuICAgIH1cbiAgICBpZiAoIWRlZmluZWQoYnVmZmVyVmlldy5leHRyYXMuX3BpcGVsaW5lKSkge1xuICAgICAgYnVmZmVyVmlldy5leHRyYXMuX3BpcGVsaW5lID0ge307XG4gICAgfVxuXG4gICAgaWYgKCFkZWZpbmVkKGJ1ZmZlclZpZXcuZXh0cmFzLl9waXBlbGluZS52ZXJ0ZXhOdW1iZXJpbmdTY29wZSkpIHtcbiAgICAgIGJ1ZmZlclZpZXcuZXh0cmFzLl9waXBlbGluZS52ZXJ0ZXhOdW1iZXJpbmdTY29wZSA9IHZlcnRleE51bWJlcmluZ1Njb3BlIHx8IHtcbiAgICAgICAgLy8gRWFjaCBlbGVtZW50IGluIHRoaXMgYXJyYXkgaXM6XG4gICAgICAgIC8vIGEpIHVuZGVmaW5lZCwgaWYgdGhlIHZlcnRleCBhdCB0aGlzIGluZGV4IGhhcyBubyBjb3BpZXNcbiAgICAgICAgLy8gYikgdGhlIGluZGV4IG9mIHRoZSBjb3B5LlxuICAgICAgICB2ZXJ0ZXhDb3BpZXM6IFtdLFxuXG4gICAgICAgIC8vIEV4dHJhIHZlcnRpY2VzIGFwcGVuZGVkIGFmdGVyIHRoZSBvbmVzIG9yaWdpbmFsbHkgaW5jbHVkZWQgaW4gdGhlIG1vZGVsLlxuICAgICAgICAvLyBFYWNoIGVsZW1lbnQgaXMgdGhlIGluZGV4IG9mIHRoZSB2ZXJ0ZXggdGhhdCB0aGlzIG9uZSBpcyBhIGNvcHkgb2YuXG4gICAgICAgIGV4dHJhVmVydGljZXM6IFtdLFxuXG4gICAgICAgIC8vIFRoZSB0ZXh0dXJlIGNvb3JkaW5hdGVzIHVzZWQgZm9yIG91dGxpbmluZywgdGhyZWUgZmxvYXRzIHBlciB2ZXJ0ZXguXG4gICAgICAgIG91dGxpbmVDb29yZGluYXRlczogW10sXG5cbiAgICAgICAgLy8gVGhlIElEcyBvZiBhY2Nlc3NvcnMgdGhhdCB1c2UgdGhpcyB2ZXJ0ZXggbnVtYmVyaW5nLlxuICAgICAgICBhY2Nlc3NvcnM6IFtdLFxuXG4gICAgICAgIC8vIFRoZSBJRHMgb2YgYnVmZmVyVmlld3MgdGhhdCB1c2UgdGhpcyB2ZXJ0ZXggbnVtYmVyaW5nLlxuICAgICAgICBidWZmZXJWaWV3czogW10sXG5cbiAgICAgICAgLy8gVGhlIHByaW1pdGl2ZXMgdGhhdCB1c2UgdGhpcyB2ZXJ0ZXggbnVtYmVyaW5nLlxuICAgICAgICBwcmltaXRpdmVzOiBbXSxcblxuICAgICAgICAvLyBUcnVlIGlmIHRoZSBidWZmZXIgZm9yIHRoZSBvdXRsaW5lcyBoYXMgYWxyZWFkeSBiZWVuIGNyZWF0ZWQuXG4gICAgICAgIGNyZWF0ZWRPdXRsaW5lczogZmFsc2UsXG4gICAgICB9O1xuICAgIH0gZWxzZSBpZiAoXG4gICAgICB2ZXJ0ZXhOdW1iZXJpbmdTY29wZSAhPT0gdW5kZWZpbmVkICYmXG4gICAgICBidWZmZXJWaWV3LmV4dHJhcy5fcGlwZWxpbmUudmVydGV4TnVtYmVyaW5nU2NvcGUgIT09IHZlcnRleE51bWJlcmluZ1Njb3BlXG4gICAgKSB7XG4gICAgICAvLyBDb25mbGljdGluZyB2ZXJ0ZXggbnVtYmVyaW5nLCBsZXQncyBnaXZlIHVwLlxuICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICB2ZXJ0ZXhOdW1iZXJpbmdTY29wZSA9IGJ1ZmZlclZpZXcuZXh0cmFzLl9waXBlbGluZS52ZXJ0ZXhOdW1iZXJpbmdTY29wZTtcblxuICAgIGlmICh2ZXJ0ZXhOdW1iZXJpbmdTY29wZS5idWZmZXJWaWV3cy5pbmRleE9mKGJ1ZmZlclZpZXcpIDwgMCkge1xuICAgICAgdmVydGV4TnVtYmVyaW5nU2NvcGUuYnVmZmVyVmlld3MucHVzaChidWZmZXJWaWV3KTtcbiAgICB9XG5cbiAgICBpZiAodmVydGV4TnVtYmVyaW5nU2NvcGUuYWNjZXNzb3JzLmluZGV4T2YoYWNjZXNzb3JJZCkgPCAwKSB7XG4gICAgICB2ZXJ0ZXhOdW1iZXJpbmdTY29wZS5hY2Nlc3NvcnMucHVzaChhY2Nlc3NvcklkKTtcbiAgICB9XG4gIH1cblxuICB2ZXJ0ZXhOdW1iZXJpbmdTY29wZS5wcmltaXRpdmVzLnB1c2gocHJpbWl0aXZlKTtcblxuICByZXR1cm4gdmVydGV4TnVtYmVyaW5nU2NvcGU7XG59XG5cbmV4cG9ydCBkZWZhdWx0IE1vZGVsT3V0bGluZUxvYWRlcjtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///32851\n')},15322:function(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__){eval('/* harmony import */ var _Core_BoundingSphere_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(48243);\n/* harmony import */ var _Core_Cartesian2_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(60838);\n/* harmony import */ var _Core_Cartesian3_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(60216);\n/* harmony import */ var _Core_Cartesian4_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(63367);\n/* harmony import */ var _Core_clone_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(83856);\n/* harmony import */ var _Core_defined_js__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(82982);\n/* harmony import */ var _Core_Matrix2_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(71171);\n/* harmony import */ var _Core_Matrix3_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(68201);\n/* harmony import */ var _Core_Matrix4_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(72248);\n/* harmony import */ var _Core_Quaternion_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(87811);\n/* harmony import */ var _Core_RuntimeError_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(9407);\n/* harmony import */ var _Core_WebGLConstants_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(52200);\n/* harmony import */ var _Renderer_ShaderSource_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(53642);\n/* harmony import */ var _GltfPipeline_addToArray_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(9919);\n/* harmony import */ var _GltfPipeline_ForEach_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(56629);\n/* harmony import */ var _GltfPipeline_usesExtension_js__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(29745);\n/* harmony import */ var _AttributeType_js__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(77072);\n/* harmony import */ var _Axis_js__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(66577);\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n/**\n * @private\n */\nvar ModelUtility = {};\n\n/**\n * Updates the model\'s forward axis if the model is not a 2.0 model.\n *\n * @param {Object} model The model to update.\n */\nModelUtility.updateForwardAxis = function (model) {\n  var cachedSourceVersion = model.gltf.extras.sourceVersion;\n\n  if (\n    ((0,_Core_defined_js__WEBPACK_IMPORTED_MODULE_16__/* ["default"] */ .Z)(cachedSourceVersion) && cachedSourceVersion !== "2.0") ||\n    ModelUtility.getAssetVersion(model.gltf) !== "2.0"\n  ) {\n    model._gltfForwardAxis = _Axis_js__WEBPACK_IMPORTED_MODULE_15__/* ["default"].X */ .Z.X;\n  }\n};\n\n/**\n *  Gets the string representing the glTF asset version.\n *\n *  @param {Object} gltf A javascript object containing a glTF asset.\n *  @returns {String} The glTF asset version string.\n */\nModelUtility.getAssetVersion = function (gltf) {\n  // In glTF 1.0 it was valid to omit the version number.\n  if (!(0,_Core_defined_js__WEBPACK_IMPORTED_MODULE_16__/* ["default"] */ .Z)(gltf.asset) || !(0,_Core_defined_js__WEBPACK_IMPORTED_MODULE_16__/* ["default"] */ .Z)(gltf.asset.version)) {\n    return "1.0";\n  }\n\n  return gltf.asset.version;\n};\n\n/**\n * Splits primitive materials with values incompatible for generating techniques.\n *\n * @param {Object} gltf A javascript object containing a glTF asset.\n * @returns {Object} The glTF asset with modified materials.\n */\nModelUtility.splitIncompatibleMaterials = function (gltf) {\n  var accessors = gltf.accessors;\n  var materials = gltf.materials;\n  var primitiveInfoByMaterial = {};\n  _GltfPipeline_ForEach_js__WEBPACK_IMPORTED_MODULE_13__/* ["default"].mesh */ .Z.mesh(gltf, function (mesh) {\n    _GltfPipeline_ForEach_js__WEBPACK_IMPORTED_MODULE_13__/* ["default"].meshPrimitive */ .Z.meshPrimitive(mesh, function (primitive) {\n      var materialIndex = primitive.material;\n      var material = materials[materialIndex];\n\n      var jointAccessorId = primitive.attributes.JOINTS_0;\n      var componentType;\n      var accessorType;\n      if ((0,_Core_defined_js__WEBPACK_IMPORTED_MODULE_16__/* ["default"] */ .Z)(jointAccessorId)) {\n        var jointAccessor = accessors[jointAccessorId];\n        componentType = jointAccessor.componentType;\n        accessorType = jointAccessor.type;\n      }\n      var isSkinned = (0,_Core_defined_js__WEBPACK_IMPORTED_MODULE_16__/* ["default"] */ .Z)(jointAccessorId) && accessorType === "VEC4";\n      var hasVertexColors = (0,_Core_defined_js__WEBPACK_IMPORTED_MODULE_16__/* ["default"] */ .Z)(primitive.attributes.COLOR_0);\n      var hasMorphTargets = (0,_Core_defined_js__WEBPACK_IMPORTED_MODULE_16__/* ["default"] */ .Z)(primitive.targets);\n      var hasNormals = (0,_Core_defined_js__WEBPACK_IMPORTED_MODULE_16__/* ["default"] */ .Z)(primitive.attributes.NORMAL);\n      var hasTangents = (0,_Core_defined_js__WEBPACK_IMPORTED_MODULE_16__/* ["default"] */ .Z)(primitive.attributes.TANGENT);\n      var hasTexCoords = (0,_Core_defined_js__WEBPACK_IMPORTED_MODULE_16__/* ["default"] */ .Z)(primitive.attributes.TEXCOORD_0);\n      var hasTexCoord1 =\n        hasTexCoords && (0,_Core_defined_js__WEBPACK_IMPORTED_MODULE_16__/* ["default"] */ .Z)(primitive.attributes.TEXCOORD_1);\n      var hasOutline =\n        (0,_Core_defined_js__WEBPACK_IMPORTED_MODULE_16__/* ["default"] */ .Z)(primitive.extensions) &&\n        (0,_Core_defined_js__WEBPACK_IMPORTED_MODULE_16__/* ["default"] */ .Z)(primitive.extensions.CESIUM_primitive_outline);\n\n      var primitiveInfo = primitiveInfoByMaterial[materialIndex];\n      if (!(0,_Core_defined_js__WEBPACK_IMPORTED_MODULE_16__/* ["default"] */ .Z)(primitiveInfo)) {\n        primitiveInfoByMaterial[materialIndex] = {\n          skinning: {\n            skinned: isSkinned,\n            componentType: componentType,\n          },\n          hasVertexColors: hasVertexColors,\n          hasMorphTargets: hasMorphTargets,\n          hasNormals: hasNormals,\n          hasTangents: hasTangents,\n          hasTexCoords: hasTexCoords,\n          hasTexCoord1: hasTexCoord1,\n          hasOutline: hasOutline,\n        };\n      } else if (\n        primitiveInfo.skinning.skinned !== isSkinned ||\n        primitiveInfo.hasVertexColors !== hasVertexColors ||\n        primitiveInfo.hasMorphTargets !== hasMorphTargets ||\n        primitiveInfo.hasNormals !== hasNormals ||\n        primitiveInfo.hasTangents !== hasTangents ||\n        primitiveInfo.hasTexCoords !== hasTexCoords ||\n        primitiveInfo.hasTexCoord1 !== hasTexCoord1 ||\n        primitiveInfo.hasOutline !== hasOutline\n      ) {\n        // This primitive uses the same material as another one that either:\n        // * Isn\'t skinned\n        // * Uses a different type to store joints and weights\n        // * Doesn\'t have vertex colors, morph targets, normals, tangents, or texCoords\n        // * Doesn\'t have a CESIUM_primitive_outline extension.\n        var clonedMaterial = (0,_Core_clone_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .Z)(material, true);\n        // Split this off as a separate material\n        materialIndex = (0,_GltfPipeline_addToArray_js__WEBPACK_IMPORTED_MODULE_12__/* ["default"] */ .Z)(materials, clonedMaterial);\n        primitive.material = materialIndex;\n        primitiveInfoByMaterial[materialIndex] = {\n          skinning: {\n            skinned: isSkinned,\n            componentType: componentType,\n          },\n          hasVertexColors: hasVertexColors,\n          hasMorphTargets: hasMorphTargets,\n          hasNormals: hasNormals,\n          hasTangents: hasTangents,\n          hasTexCoords: hasTexCoords,\n          hasTexCoord1: hasTexCoord1,\n          hasOutline: hasOutline,\n        };\n      }\n    });\n  });\n\n  return primitiveInfoByMaterial;\n};\n\nModelUtility.getShaderVariable = function (type) {\n  if (type === "SCALAR") {\n    return "float";\n  }\n  return type.toLowerCase();\n};\n\nModelUtility.ModelState = {\n  NEEDS_LOAD: 0,\n  LOADING: 1,\n  LOADED: 2, // Renderable, but textures can still be pending when incrementallyLoadTextures is true.\n  FAILED: 3,\n};\n\nModelUtility.getFailedLoadFunction = function (model, type, path) {\n  return function (error) {\n    model._state = ModelUtility.ModelState.FAILED;\n    var message = "Failed to load " + type + ": " + path;\n    if ((0,_Core_defined_js__WEBPACK_IMPORTED_MODULE_16__/* ["default"] */ .Z)(error)) {\n      message += "\\n" + error.message;\n    }\n    model._readyPromise.reject(new _Core_RuntimeError_js__WEBPACK_IMPORTED_MODULE_9__/* ["default"] */ .Z(message));\n  };\n};\n\nModelUtility.parseBuffers = function (model, bufferLoad) {\n  var loadResources = model._loadResources;\n  _GltfPipeline_ForEach_js__WEBPACK_IMPORTED_MODULE_13__/* ["default"].buffer */ .Z.buffer(model.gltf, function (buffer, bufferViewId) {\n    if ((0,_Core_defined_js__WEBPACK_IMPORTED_MODULE_16__/* ["default"] */ .Z)(buffer.extras._pipeline.source)) {\n      loadResources.buffers[bufferViewId] = buffer.extras._pipeline.source;\n    } else if ((0,_Core_defined_js__WEBPACK_IMPORTED_MODULE_16__/* ["default"] */ .Z)(bufferLoad)) {\n      var bufferResource = model._resource.getDerivedResource({\n        url: buffer.uri,\n      });\n      ++loadResources.pendingBufferLoads;\n      bufferResource\n        .fetchArrayBuffer()\n        .then(bufferLoad(model, bufferViewId))\n        .otherwise(\n          ModelUtility.getFailedLoadFunction(\n            model,\n            "buffer",\n            bufferResource.url\n          )\n        );\n    }\n  });\n};\n\nvar aMinScratch = new _Core_Cartesian3_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"] */ .Z();\nvar aMaxScratch = new _Core_Cartesian3_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"] */ .Z();\n\nModelUtility.computeBoundingSphere = function (model) {\n  var gltf = model.gltf;\n  var gltfNodes = gltf.nodes;\n  var gltfMeshes = gltf.meshes;\n  var rootNodes = gltf.scenes[gltf.scene].nodes;\n  var rootNodesLength = rootNodes.length;\n\n  var nodeStack = [];\n\n  var min = new _Core_Cartesian3_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"] */ .Z(\n    Number.MAX_VALUE,\n    Number.MAX_VALUE,\n    Number.MAX_VALUE\n  );\n  var max = new _Core_Cartesian3_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"] */ .Z(\n    -Number.MAX_VALUE,\n    -Number.MAX_VALUE,\n    -Number.MAX_VALUE\n  );\n\n  for (var i = 0; i < rootNodesLength; ++i) {\n    var n = gltfNodes[rootNodes[i]];\n    n._transformToRoot = ModelUtility.getTransform(n);\n    nodeStack.push(n);\n\n    while (nodeStack.length > 0) {\n      n = nodeStack.pop();\n      var transformToRoot = n._transformToRoot;\n\n      var meshId = n.mesh;\n      if ((0,_Core_defined_js__WEBPACK_IMPORTED_MODULE_16__/* ["default"] */ .Z)(meshId)) {\n        var mesh = gltfMeshes[meshId];\n        var primitives = mesh.primitives;\n        var primitivesLength = primitives.length;\n        for (var m = 0; m < primitivesLength; ++m) {\n          var positionAccessor = primitives[m].attributes.POSITION;\n          if ((0,_Core_defined_js__WEBPACK_IMPORTED_MODULE_16__/* ["default"] */ .Z)(positionAccessor)) {\n            var minMax = ModelUtility.getAccessorMinMax(gltf, positionAccessor);\n            if ((0,_Core_defined_js__WEBPACK_IMPORTED_MODULE_16__/* ["default"] */ .Z)(minMax.min) && (0,_Core_defined_js__WEBPACK_IMPORTED_MODULE_16__/* ["default"] */ .Z)(minMax.max)) {\n              var aMin = _Core_Cartesian3_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"].fromArray */ .Z.fromArray(minMax.min, 0, aMinScratch);\n              var aMax = _Core_Cartesian3_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"].fromArray */ .Z.fromArray(minMax.max, 0, aMaxScratch);\n\n              _Core_Matrix4_js__WEBPACK_IMPORTED_MODULE_7__/* ["default"].multiplyByPoint */ .Z.multiplyByPoint(transformToRoot, aMin, aMin);\n              _Core_Matrix4_js__WEBPACK_IMPORTED_MODULE_7__/* ["default"].multiplyByPoint */ .Z.multiplyByPoint(transformToRoot, aMax, aMax);\n              _Core_Cartesian3_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"].minimumByComponent */ .Z.minimumByComponent(min, aMin, min);\n              _Core_Cartesian3_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"].maximumByComponent */ .Z.maximumByComponent(max, aMax, max);\n            }\n          }\n        }\n      }\n\n      var children = n.children;\n      if ((0,_Core_defined_js__WEBPACK_IMPORTED_MODULE_16__/* ["default"] */ .Z)(children)) {\n        var childrenLength = children.length;\n        for (var k = 0; k < childrenLength; ++k) {\n          var child = gltfNodes[children[k]];\n          child._transformToRoot = ModelUtility.getTransform(child);\n          _Core_Matrix4_js__WEBPACK_IMPORTED_MODULE_7__/* ["default"].multiplyTransformation */ .Z.multiplyTransformation(\n            transformToRoot,\n            child._transformToRoot,\n            child._transformToRoot\n          );\n          nodeStack.push(child);\n        }\n      }\n      delete n._transformToRoot;\n    }\n  }\n\n  var boundingSphere = _Core_BoundingSphere_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].fromCornerPoints */ .Z.fromCornerPoints(min, max);\n  if (model._forwardAxis === _Axis_js__WEBPACK_IMPORTED_MODULE_15__/* ["default"].Z */ .Z.Z) {\n    // glTF 2.0 has a Z-forward convention that must be adapted here to X-forward.\n    _Core_BoundingSphere_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].transformWithoutScale */ .Z.transformWithoutScale(\n      boundingSphere,\n      _Axis_js__WEBPACK_IMPORTED_MODULE_15__/* ["default"].Z_UP_TO_X_UP */ .Z.Z_UP_TO_X_UP,\n      boundingSphere\n    );\n  }\n  if (model._upAxis === _Axis_js__WEBPACK_IMPORTED_MODULE_15__/* ["default"].Y */ .Z.Y) {\n    _Core_BoundingSphere_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].transformWithoutScale */ .Z.transformWithoutScale(\n      boundingSphere,\n      _Axis_js__WEBPACK_IMPORTED_MODULE_15__/* ["default"].Y_UP_TO_Z_UP */ .Z.Y_UP_TO_Z_UP,\n      boundingSphere\n    );\n  } else if (model._upAxis === _Axis_js__WEBPACK_IMPORTED_MODULE_15__/* ["default"].X */ .Z.X) {\n    _Core_BoundingSphere_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].transformWithoutScale */ .Z.transformWithoutScale(\n      boundingSphere,\n      _Axis_js__WEBPACK_IMPORTED_MODULE_15__/* ["default"].X_UP_TO_Z_UP */ .Z.X_UP_TO_Z_UP,\n      boundingSphere\n    );\n  }\n  return boundingSphere;\n};\n\nfunction techniqueAttributeForSemantic(technique, semantic) {\n  return _GltfPipeline_ForEach_js__WEBPACK_IMPORTED_MODULE_13__/* ["default"].techniqueAttribute */ .Z.techniqueAttribute(technique, function (\n    attribute,\n    attributeName\n  ) {\n    if (attribute.semantic === semantic) {\n      return attributeName;\n    }\n  });\n}\n\nfunction ensureSemanticExistenceForPrimitive(gltf, primitive) {\n  var accessors = gltf.accessors;\n  var materials = gltf.materials;\n  var techniquesWebgl = gltf.extensions.KHR_techniques_webgl;\n\n  var techniques = techniquesWebgl.techniques;\n  var programs = techniquesWebgl.programs;\n  var shaders = techniquesWebgl.shaders;\n  var targets = primitive.targets;\n\n  var attributes = primitive.attributes;\n  for (var target in targets) {\n    if (targets.hasOwnProperty(target)) {\n      var targetAttributes = targets[target];\n      for (var attribute in targetAttributes) {\n        if (attribute !== "extras") {\n          attributes[attribute + "_" + target] = targetAttributes[attribute];\n        }\n      }\n    }\n  }\n\n  var material = materials[primitive.material];\n  var technique =\n    techniques[material.extensions.KHR_techniques_webgl.technique];\n  var program = programs[technique.program];\n  var vertexShader = shaders[program.vertexShader];\n\n  for (var semantic in attributes) {\n    if (attributes.hasOwnProperty(semantic)) {\n      if (!(0,_Core_defined_js__WEBPACK_IMPORTED_MODULE_16__/* ["default"] */ .Z)(techniqueAttributeForSemantic(technique, semantic))) {\n        var accessorId = attributes[semantic];\n        var accessor = accessors[accessorId];\n        var lowerCase = semantic.toLowerCase();\n        if (lowerCase.charAt(0) === "_") {\n          lowerCase = lowerCase.slice(1);\n        }\n        var attributeName = "a_" + lowerCase;\n        technique.attributes[attributeName] = {\n          semantic: semantic,\n          type: accessor.componentType,\n        };\n        var pipelineExtras = vertexShader.extras._pipeline;\n        var shaderText = pipelineExtras.source;\n        shaderText =\n          "attribute " +\n          ModelUtility.getShaderVariable(accessor.type) +\n          " " +\n          attributeName +\n          ";\\n" +\n          shaderText;\n        pipelineExtras.source = shaderText;\n      }\n    }\n  }\n}\n\n/**\n * Ensures all attributes present on the primitive are present in the technique and\n * vertex shader.\n *\n * @param {Object} gltf A javascript object containing a glTF asset.\n * @returns {Object} The glTF asset, including any additional attributes.\n */\nModelUtility.ensureSemanticExistence = function (gltf) {\n  _GltfPipeline_ForEach_js__WEBPACK_IMPORTED_MODULE_13__/* ["default"].mesh */ .Z.mesh(gltf, function (mesh) {\n    _GltfPipeline_ForEach_js__WEBPACK_IMPORTED_MODULE_13__/* ["default"].meshPrimitive */ .Z.meshPrimitive(mesh, function (primitive) {\n      ensureSemanticExistenceForPrimitive(gltf, primitive);\n    });\n  });\n\n  return gltf;\n};\n\n/**\n * Creates attribute location for all attributes required by a technique.\n *\n * @param {Object} technique A glTF KHR_techniques_webgl technique object.\n * @param {Object} precreatedAttributes A dictionary object of pre-created attributes for which to also create locations.\n * @returns {Object} A dictionary object containing attribute names and their locations.\n */\nModelUtility.createAttributeLocations = function (\n  technique,\n  precreatedAttributes\n) {\n  var attributeLocations = {};\n  var hasIndex0 = false;\n  var i = 1;\n\n  _GltfPipeline_ForEach_js__WEBPACK_IMPORTED_MODULE_13__/* ["default"].techniqueAttribute */ .Z.techniqueAttribute(technique, function (attribute, attributeName) {\n    // Set the position attribute to the 0th index. In some WebGL implementations the shader\n    // will not work correctly if the 0th attribute is not active. For example, some glTF models\n    // list the normal attribute first but derived shaders like the cast-shadows shader do not use\n    // the normal attribute.\n    if (/pos/i.test(attributeName) && !hasIndex0) {\n      attributeLocations[attributeName] = 0;\n      hasIndex0 = true;\n    } else {\n      attributeLocations[attributeName] = i++;\n    }\n  });\n\n  if ((0,_Core_defined_js__WEBPACK_IMPORTED_MODULE_16__/* ["default"] */ .Z)(precreatedAttributes)) {\n    for (var attributeName in precreatedAttributes) {\n      if (precreatedAttributes.hasOwnProperty(attributeName)) {\n        attributeLocations[attributeName] = i++;\n      }\n    }\n  }\n\n  return attributeLocations;\n};\n\nModelUtility.getAccessorMinMax = function (gltf, accessorId) {\n  var accessor = gltf.accessors[accessorId];\n  var extensions = accessor.extensions;\n  var accessorMin = accessor.min;\n  var accessorMax = accessor.max;\n  // If this accessor is quantized, we should use the decoded min and max\n  if ((0,_Core_defined_js__WEBPACK_IMPORTED_MODULE_16__/* ["default"] */ .Z)(extensions)) {\n    var quantizedAttributes = extensions.WEB3D_quantized_attributes;\n    if ((0,_Core_defined_js__WEBPACK_IMPORTED_MODULE_16__/* ["default"] */ .Z)(quantizedAttributes)) {\n      accessorMin = quantizedAttributes.decodedMin;\n      accessorMax = quantizedAttributes.decodedMax;\n    }\n  }\n  return {\n    min: accessorMin,\n    max: accessorMax,\n  };\n};\n\nfunction getTechniqueAttributeOrUniformFunction(\n  gltf,\n  technique,\n  semantic,\n  ignoreNodes\n) {\n  if ((0,_GltfPipeline_usesExtension_js__WEBPACK_IMPORTED_MODULE_17__/* ["default"] */ .Z)(gltf, "KHR_techniques_webgl")) {\n    return function (attributeOrUniform, attributeOrUniformName) {\n      if (\n        attributeOrUniform.semantic === semantic &&\n        (!ignoreNodes || !(0,_Core_defined_js__WEBPACK_IMPORTED_MODULE_16__/* ["default"] */ .Z)(attributeOrUniform.node))\n      ) {\n        return attributeOrUniformName;\n      }\n    };\n  }\n\n  return function (parameterName, attributeOrUniformName) {\n    var attributeOrUniform = technique.parameters[parameterName];\n    if (\n      attributeOrUniform.semantic === semantic &&\n      (!ignoreNodes || !(0,_Core_defined_js__WEBPACK_IMPORTED_MODULE_16__/* ["default"] */ .Z)(attributeOrUniform.node))\n    ) {\n      return attributeOrUniformName;\n    }\n  };\n}\n\nModelUtility.getAttributeOrUniformBySemantic = function (\n  gltf,\n  semantic,\n  programId,\n  ignoreNodes\n) {\n  return _GltfPipeline_ForEach_js__WEBPACK_IMPORTED_MODULE_13__/* ["default"].technique */ .Z.technique(gltf, function (technique) {\n    if ((0,_Core_defined_js__WEBPACK_IMPORTED_MODULE_16__/* ["default"] */ .Z)(programId) && technique.program !== programId) {\n      return;\n    }\n\n    var value = _GltfPipeline_ForEach_js__WEBPACK_IMPORTED_MODULE_13__/* ["default"].techniqueAttribute */ .Z.techniqueAttribute(\n      technique,\n      getTechniqueAttributeOrUniformFunction(\n        gltf,\n        technique,\n        semantic,\n        ignoreNodes\n      )\n    );\n\n    if ((0,_Core_defined_js__WEBPACK_IMPORTED_MODULE_16__/* ["default"] */ .Z)(value)) {\n      return value;\n    }\n\n    return _GltfPipeline_ForEach_js__WEBPACK_IMPORTED_MODULE_13__/* ["default"].techniqueUniform */ .Z.techniqueUniform(\n      technique,\n      getTechniqueAttributeOrUniformFunction(\n        gltf,\n        technique,\n        semantic,\n        ignoreNodes\n      )\n    );\n  });\n};\n\nModelUtility.getDiffuseAttributeOrUniform = function (gltf, programId) {\n  var diffuseUniformName = ModelUtility.getAttributeOrUniformBySemantic(\n    gltf,\n    "COLOR_0",\n    programId\n  );\n  if (!(0,_Core_defined_js__WEBPACK_IMPORTED_MODULE_16__/* ["default"] */ .Z)(diffuseUniformName)) {\n    diffuseUniformName = ModelUtility.getAttributeOrUniformBySemantic(\n      gltf,\n      "_3DTILESDIFFUSE",\n      programId\n    );\n  }\n  return diffuseUniformName;\n};\n\nvar nodeTranslationScratch = new _Core_Cartesian3_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"] */ .Z();\nvar nodeQuaternionScratch = new _Core_Quaternion_js__WEBPACK_IMPORTED_MODULE_8__/* ["default"] */ .Z();\nvar nodeScaleScratch = new _Core_Cartesian3_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"] */ .Z();\n\nModelUtility.getTransform = function (node, result) {\n  if ((0,_Core_defined_js__WEBPACK_IMPORTED_MODULE_16__/* ["default"] */ .Z)(node.matrix)) {\n    return _Core_Matrix4_js__WEBPACK_IMPORTED_MODULE_7__/* ["default"].fromColumnMajorArray */ .Z.fromColumnMajorArray(node.matrix, result);\n  }\n\n  return _Core_Matrix4_js__WEBPACK_IMPORTED_MODULE_7__/* ["default"].fromTranslationQuaternionRotationScale */ .Z.fromTranslationQuaternionRotationScale(\n    _Core_Cartesian3_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"].fromArray */ .Z.fromArray(node.translation, 0, nodeTranslationScratch),\n    _Core_Quaternion_js__WEBPACK_IMPORTED_MODULE_8__/* ["default"].unpack */ .Z.unpack(node.rotation, 0, nodeQuaternionScratch),\n    _Core_Cartesian3_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"].fromArray */ .Z.fromArray(node.scale, 0, nodeScaleScratch),\n    result\n  );\n};\n\nModelUtility.getUsedExtensions = function (gltf) {\n  var extensionsUsed = gltf.extensionsUsed;\n  var cachedExtensionsUsed = {};\n\n  if ((0,_Core_defined_js__WEBPACK_IMPORTED_MODULE_16__/* ["default"] */ .Z)(extensionsUsed)) {\n    var extensionsUsedLength = extensionsUsed.length;\n    for (var i = 0; i < extensionsUsedLength; i++) {\n      var extension = extensionsUsed[i];\n      cachedExtensionsUsed[extension] = true;\n    }\n  }\n  return cachedExtensionsUsed;\n};\n\nModelUtility.getRequiredExtensions = function (gltf) {\n  var extensionsRequired = gltf.extensionsRequired;\n  var cachedExtensionsRequired = {};\n\n  if ((0,_Core_defined_js__WEBPACK_IMPORTED_MODULE_16__/* ["default"] */ .Z)(extensionsRequired)) {\n    var extensionsRequiredLength = extensionsRequired.length;\n    for (var i = 0; i < extensionsRequiredLength; i++) {\n      var extension = extensionsRequired[i];\n      cachedExtensionsRequired[extension] = true;\n    }\n  }\n\n  return cachedExtensionsRequired;\n};\n\nModelUtility.supportedExtensions = {\n  AGI_articulations: true,\n  CESIUM_RTC: true,\n  EXT_texture_webp: true,\n  KHR_blend: true,\n  KHR_binary_glTF: true,\n  KHR_texture_basisu: true,\n  KHR_draco_mesh_compression: true,\n  KHR_materials_common: true,\n  KHR_techniques_webgl: true,\n  KHR_materials_unlit: true,\n  KHR_materials_pbrSpecularGlossiness: true,\n  KHR_texture_transform: true,\n  WEB3D_quantized_attributes: true,\n};\n\nModelUtility.checkSupportedExtensions = function (\n  extensionsRequired,\n  browserSupportsWebp\n) {\n  for (var extension in extensionsRequired) {\n    if (extensionsRequired.hasOwnProperty(extension)) {\n      if (!ModelUtility.supportedExtensions[extension]) {\n        throw new _Core_RuntimeError_js__WEBPACK_IMPORTED_MODULE_9__/* ["default"] */ .Z("Unsupported glTF Extension: " + extension);\n      }\n\n      if (extension === "EXT_texture_webp" && browserSupportsWebp === false) {\n        throw new _Core_RuntimeError_js__WEBPACK_IMPORTED_MODULE_9__/* ["default"] */ .Z(\n          "Loaded model requires WebP but browser does not support it."\n        );\n      }\n    }\n  }\n};\n\nModelUtility.checkSupportedGlExtensions = function (extensionsUsed, context) {\n  if ((0,_Core_defined_js__WEBPACK_IMPORTED_MODULE_16__/* ["default"] */ .Z)(extensionsUsed)) {\n    var glExtensionsUsedLength = extensionsUsed.length;\n    for (var i = 0; i < glExtensionsUsedLength; i++) {\n      var extension = extensionsUsed[i];\n      if (extension !== "OES_element_index_uint") {\n        throw new _Core_RuntimeError_js__WEBPACK_IMPORTED_MODULE_9__/* ["default"] */ .Z("Unsupported WebGL Extension: " + extension);\n      } else if (!context.elementIndexUint) {\n        throw new _Core_RuntimeError_js__WEBPACK_IMPORTED_MODULE_9__/* ["default"] */ .Z(\n          "OES_element_index_uint WebGL extension is not enabled."\n        );\n      }\n    }\n  }\n};\n\nfunction replaceAllButFirstInString(string, find, replace) {\n  // Limit search to strings that are not a subset of other tokens.\n  find += "(?!\\\\w)";\n  find = new RegExp(find, "g");\n\n  var index = string.search(find);\n  return string.replace(find, function (match, offset) {\n    return index === offset ? match : replace;\n  });\n}\n\nfunction getQuantizedAttributes(gltf, accessorId) {\n  var accessor = gltf.accessors[accessorId];\n  var extensions = accessor.extensions;\n  if ((0,_Core_defined_js__WEBPACK_IMPORTED_MODULE_16__/* ["default"] */ .Z)(extensions)) {\n    return extensions.WEB3D_quantized_attributes;\n  }\n  return undefined;\n}\n\nfunction getAttributeVariableName(gltf, primitive, attributeSemantic) {\n  var materialId = primitive.material;\n  var material = gltf.materials[materialId];\n\n  if (\n    !(0,_GltfPipeline_usesExtension_js__WEBPACK_IMPORTED_MODULE_17__/* ["default"] */ .Z)(gltf, "KHR_techniques_webgl") ||\n    !(0,_Core_defined_js__WEBPACK_IMPORTED_MODULE_16__/* ["default"] */ .Z)(material.extensions) ||\n    !(0,_Core_defined_js__WEBPACK_IMPORTED_MODULE_16__/* ["default"] */ .Z)(material.extensions.KHR_techniques_webgl)\n  ) {\n    return;\n  }\n\n  var techniqueId = material.extensions.KHR_techniques_webgl.technique;\n  var techniquesWebgl = gltf.extensions.KHR_techniques_webgl;\n  var technique = techniquesWebgl.techniques[techniqueId];\n  return _GltfPipeline_ForEach_js__WEBPACK_IMPORTED_MODULE_13__/* ["default"].techniqueAttribute */ .Z.techniqueAttribute(technique, function (\n    attribute,\n    attributeName\n  ) {\n    var semantic = attribute.semantic;\n    if (semantic === attributeSemantic) {\n      return attributeName;\n    }\n  });\n}\n\nModelUtility.modifyShaderForDracoQuantizedAttributes = function (\n  gltf,\n  primitive,\n  shader,\n  decodedAttributes\n) {\n  var quantizedUniforms = {};\n  for (var attributeSemantic in decodedAttributes) {\n    if (decodedAttributes.hasOwnProperty(attributeSemantic)) {\n      var attribute = decodedAttributes[attributeSemantic];\n      var quantization = attribute.quantization;\n      if (!(0,_Core_defined_js__WEBPACK_IMPORTED_MODULE_16__/* ["default"] */ .Z)(quantization)) {\n        continue;\n      }\n\n      var attributeVarName = getAttributeVariableName(\n        gltf,\n        primitive,\n        attributeSemantic\n      );\n\n      if (attributeSemantic.charAt(0) === "_") {\n        attributeSemantic = attributeSemantic.substring(1);\n      }\n      var decodeUniformVarName =\n        "gltf_u_dec_" + attributeSemantic.toLowerCase();\n\n      if (!(0,_Core_defined_js__WEBPACK_IMPORTED_MODULE_16__/* ["default"] */ .Z)(quantizedUniforms[decodeUniformVarName])) {\n        var newMain = "gltf_decoded_" + attributeSemantic;\n        var decodedAttributeVarName = attributeVarName.replace(\n          "a_",\n          "gltf_a_dec_"\n        );\n        var size = attribute.componentsPerAttribute;\n\n        // replace usages of the original attribute with the decoded version, but not the declaration\n        shader = replaceAllButFirstInString(\n          shader,\n          attributeVarName,\n          decodedAttributeVarName\n        );\n\n        // declare decoded attribute\n        var variableType;\n        if (quantization.octEncoded) {\n          variableType = "vec3";\n        } else if (size > 1) {\n          variableType = "vec" + size;\n        } else {\n          variableType = "float";\n        }\n        shader = variableType + " " + decodedAttributeVarName + ";\\n" + shader;\n\n        // The gltf 2.0 COLOR_0 vertex attribute can be VEC4 or VEC3\n        var vec3Color = size === 3 && attributeSemantic === "COLOR_0";\n        if (vec3Color) {\n          shader = replaceAllButFirstInString(\n            shader,\n            decodedAttributeVarName,\n            "vec4(" + decodedAttributeVarName + ", 1.0)"\n          );\n        }\n\n        // splice decode function into the shader\n        var decode = "";\n        if (quantization.octEncoded) {\n          var decodeUniformVarNameRangeConstant =\n            decodeUniformVarName + "_rangeConstant";\n          shader =\n            "uniform float " +\n            decodeUniformVarNameRangeConstant +\n            ";\\n" +\n            shader;\n          decode =\n            "\\n" +\n            "void main() {\\n" +\n            // Draco oct-encoding decodes to zxy order\n            "    " +\n            decodedAttributeVarName +\n            " = czm_octDecode(" +\n            attributeVarName +\n            ".xy, " +\n            decodeUniformVarNameRangeConstant +\n            ").zxy;\\n" +\n            "    " +\n            newMain +\n            "();\\n" +\n            "}\\n";\n        } else {\n          var decodeUniformVarNameNormConstant =\n            decodeUniformVarName + "_normConstant";\n          var decodeUniformVarNameMin = decodeUniformVarName + "_min";\n          shader =\n            "uniform float " +\n            decodeUniformVarNameNormConstant +\n            ";\\n" +\n            "uniform " +\n            variableType +\n            " " +\n            decodeUniformVarNameMin +\n            ";\\n" +\n            shader;\n          var attributeVarAccess = vec3Color ? ".xyz" : "";\n          decode =\n            "\\n" +\n            "void main() {\\n" +\n            "    " +\n            decodedAttributeVarName +\n            " = " +\n            decodeUniformVarNameMin +\n            " + " +\n            attributeVarName +\n            attributeVarAccess +\n            " * " +\n            decodeUniformVarNameNormConstant +\n            ";\\n" +\n            "    " +\n            newMain +\n            "();\\n" +\n            "}\\n";\n        }\n\n        shader = _Renderer_ShaderSource_js__WEBPACK_IMPORTED_MODULE_11__/* ["default"].replaceMain */ .Z.replaceMain(shader, newMain);\n        shader += decode;\n      }\n    }\n  }\n  return {\n    shader: shader,\n  };\n};\n\nModelUtility.modifyShaderForQuantizedAttributes = function (\n  gltf,\n  primitive,\n  shader\n) {\n  var quantizedUniforms = {};\n  var attributes = primitive.attributes;\n  for (var attributeSemantic in attributes) {\n    if (attributes.hasOwnProperty(attributeSemantic)) {\n      var attributeVarName = getAttributeVariableName(\n        gltf,\n        primitive,\n        attributeSemantic\n      );\n      var accessorId = primitive.attributes[attributeSemantic];\n\n      if (attributeSemantic.charAt(0) === "_") {\n        attributeSemantic = attributeSemantic.substring(1);\n      }\n      var decodeUniformVarName =\n        "gltf_u_dec_" + attributeSemantic.toLowerCase();\n\n      var decodeUniformVarNameScale = decodeUniformVarName + "_scale";\n      var decodeUniformVarNameTranslate = decodeUniformVarName + "_translate";\n      if (\n        !(0,_Core_defined_js__WEBPACK_IMPORTED_MODULE_16__/* ["default"] */ .Z)(quantizedUniforms[decodeUniformVarName]) &&\n        !(0,_Core_defined_js__WEBPACK_IMPORTED_MODULE_16__/* ["default"] */ .Z)(quantizedUniforms[decodeUniformVarNameScale])\n      ) {\n        var quantizedAttributes = getQuantizedAttributes(gltf, accessorId);\n        if ((0,_Core_defined_js__WEBPACK_IMPORTED_MODULE_16__/* ["default"] */ .Z)(quantizedAttributes)) {\n          var decodeMatrix = quantizedAttributes.decodeMatrix;\n          var newMain = "gltf_decoded_" + attributeSemantic;\n          var decodedAttributeVarName = attributeVarName.replace(\n            "a_",\n            "gltf_a_dec_"\n          );\n          var size = Math.floor(Math.sqrt(decodeMatrix.length));\n\n          // replace usages of the original attribute with the decoded version, but not the declaration\n          shader = replaceAllButFirstInString(\n            shader,\n            attributeVarName,\n            decodedAttributeVarName\n          );\n          // declare decoded attribute\n          var variableType;\n          if (size > 2) {\n            variableType = "vec" + (size - 1);\n          } else {\n            variableType = "float";\n          }\n          shader =\n            variableType + " " + decodedAttributeVarName + ";\\n" + shader;\n          // splice decode function into the shader - attributes are pre-multiplied with the decode matrix\n          // uniform in the shader (32-bit floating point)\n          var decode = "";\n          if (size === 5) {\n            // separate scale and translate since glsl doesn\'t have mat5\n            shader =\n              "uniform mat4 " + decodeUniformVarNameScale + ";\\n" + shader;\n            shader =\n              "uniform vec4 " + decodeUniformVarNameTranslate + ";\\n" + shader;\n            decode =\n              "\\n" +\n              "void main() {\\n" +\n              "    " +\n              decodedAttributeVarName +\n              " = " +\n              decodeUniformVarNameScale +\n              " * " +\n              attributeVarName +\n              " + " +\n              decodeUniformVarNameTranslate +\n              ";\\n" +\n              "    " +\n              newMain +\n              "();\\n" +\n              "}\\n";\n\n            quantizedUniforms[decodeUniformVarNameScale] = { mat: 4 };\n            quantizedUniforms[decodeUniformVarNameTranslate] = { vec: 4 };\n          } else {\n            shader =\n              "uniform mat" +\n              size +\n              " " +\n              decodeUniformVarName +\n              ";\\n" +\n              shader;\n            decode =\n              "\\n" +\n              "void main() {\\n" +\n              "    " +\n              decodedAttributeVarName +\n              " = " +\n              variableType +\n              "(" +\n              decodeUniformVarName +\n              " * vec" +\n              size +\n              "(" +\n              attributeVarName +\n              ",1.0));\\n" +\n              "    " +\n              newMain +\n              "();\\n" +\n              "}\\n";\n\n            quantizedUniforms[decodeUniformVarName] = { mat: size };\n          }\n          shader = _Renderer_ShaderSource_js__WEBPACK_IMPORTED_MODULE_11__/* ["default"].replaceMain */ .Z.replaceMain(shader, newMain);\n          shader += decode;\n        }\n      }\n    }\n  }\n  return {\n    shader: shader,\n    uniforms: quantizedUniforms,\n  };\n};\n\nfunction getScalarUniformFunction(value) {\n  var that = {\n    value: value,\n    clone: function (source, result) {\n      return source;\n    },\n    func: function () {\n      return that.value;\n    },\n  };\n  return that;\n}\n\nfunction getVec2UniformFunction(value) {\n  var that = {\n    value: _Core_Cartesian2_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"].fromArray */ .Z.fromArray(value),\n    clone: _Core_Cartesian2_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"].clone */ .Z.clone,\n    func: function () {\n      return that.value;\n    },\n  };\n  return that;\n}\n\nfunction getVec3UniformFunction(value) {\n  var that = {\n    value: _Core_Cartesian3_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"].fromArray */ .Z.fromArray(value),\n    clone: _Core_Cartesian3_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"].clone */ .Z.clone,\n    func: function () {\n      return that.value;\n    },\n  };\n  return that;\n}\n\nfunction getVec4UniformFunction(value) {\n  var that = {\n    value: _Core_Cartesian4_js__WEBPACK_IMPORTED_MODULE_3__/* ["default"].fromArray */ .Z.fromArray(value),\n    clone: _Core_Cartesian4_js__WEBPACK_IMPORTED_MODULE_3__/* ["default"].clone */ .Z.clone,\n    func: function () {\n      return that.value;\n    },\n  };\n  return that;\n}\n\nfunction getMat2UniformFunction(value) {\n  var that = {\n    value: _Core_Matrix2_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"].fromColumnMajorArray */ .Z.fromColumnMajorArray(value),\n    clone: _Core_Matrix2_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"].clone */ .Z.clone,\n    func: function () {\n      return that.value;\n    },\n  };\n  return that;\n}\n\nfunction getMat3UniformFunction(value) {\n  var that = {\n    value: _Core_Matrix3_js__WEBPACK_IMPORTED_MODULE_6__/* ["default"].fromColumnMajorArray */ .Z.fromColumnMajorArray(value),\n    clone: _Core_Matrix3_js__WEBPACK_IMPORTED_MODULE_6__/* ["default"].clone */ .Z.clone,\n    func: function () {\n      return that.value;\n    },\n  };\n  return that;\n}\n\nfunction getMat4UniformFunction(value) {\n  var that = {\n    value: _Core_Matrix4_js__WEBPACK_IMPORTED_MODULE_7__/* ["default"].fromColumnMajorArray */ .Z.fromColumnMajorArray(value),\n    clone: _Core_Matrix4_js__WEBPACK_IMPORTED_MODULE_7__/* ["default"].clone */ .Z.clone,\n    func: function () {\n      return that.value;\n    },\n  };\n  return that;\n}\n\n///////////////////////////////////////////////////////////////////////////\n\nfunction DelayLoadedTextureUniform(value, textures, defaultTexture) {\n  this._value = undefined;\n  this._textureId = value.index;\n  this._textures = textures;\n  this._defaultTexture = defaultTexture;\n}\n\nObject.defineProperties(DelayLoadedTextureUniform.prototype, {\n  value: {\n    get: function () {\n      // Use the default texture (1x1 white) until the model\'s texture is loaded\n      if (!(0,_Core_defined_js__WEBPACK_IMPORTED_MODULE_16__/* ["default"] */ .Z)(this._value)) {\n        var texture = this._textures[this._textureId];\n        if ((0,_Core_defined_js__WEBPACK_IMPORTED_MODULE_16__/* ["default"] */ .Z)(texture)) {\n          this._value = texture;\n        } else {\n          return this._defaultTexture;\n        }\n      }\n\n      return this._value;\n    },\n    set: function (value) {\n      this._value = value;\n    },\n  },\n});\n\nDelayLoadedTextureUniform.prototype.clone = function (source) {\n  return source;\n};\n\nDelayLoadedTextureUniform.prototype.func = undefined;\n\n///////////////////////////////////////////////////////////////////////////\n\nfunction getTextureUniformFunction(value, textures, defaultTexture) {\n  var uniform = new DelayLoadedTextureUniform(value, textures, defaultTexture);\n  // Define function here to access closure since \'this\' can\'t be\n  // used when the Renderer sets uniforms.\n  uniform.func = function () {\n    return uniform.value;\n  };\n  return uniform;\n}\n\nvar gltfUniformFunctions = {};\ngltfUniformFunctions[_Core_WebGLConstants_js__WEBPACK_IMPORTED_MODULE_10__/* ["default"].FLOAT */ .Z.FLOAT] = getScalarUniformFunction;\ngltfUniformFunctions[_Core_WebGLConstants_js__WEBPACK_IMPORTED_MODULE_10__/* ["default"].FLOAT_VEC2 */ .Z.FLOAT_VEC2] = getVec2UniformFunction;\ngltfUniformFunctions[_Core_WebGLConstants_js__WEBPACK_IMPORTED_MODULE_10__/* ["default"].FLOAT_VEC3 */ .Z.FLOAT_VEC3] = getVec3UniformFunction;\ngltfUniformFunctions[_Core_WebGLConstants_js__WEBPACK_IMPORTED_MODULE_10__/* ["default"].FLOAT_VEC4 */ .Z.FLOAT_VEC4] = getVec4UniformFunction;\ngltfUniformFunctions[_Core_WebGLConstants_js__WEBPACK_IMPORTED_MODULE_10__/* ["default"].INT */ .Z.INT] = getScalarUniformFunction;\ngltfUniformFunctions[_Core_WebGLConstants_js__WEBPACK_IMPORTED_MODULE_10__/* ["default"].INT_VEC2 */ .Z.INT_VEC2] = getVec2UniformFunction;\ngltfUniformFunctions[_Core_WebGLConstants_js__WEBPACK_IMPORTED_MODULE_10__/* ["default"].INT_VEC3 */ .Z.INT_VEC3] = getVec3UniformFunction;\ngltfUniformFunctions[_Core_WebGLConstants_js__WEBPACK_IMPORTED_MODULE_10__/* ["default"].INT_VEC4 */ .Z.INT_VEC4] = getVec4UniformFunction;\ngltfUniformFunctions[_Core_WebGLConstants_js__WEBPACK_IMPORTED_MODULE_10__/* ["default"].BOOL */ .Z.BOOL] = getScalarUniformFunction;\ngltfUniformFunctions[_Core_WebGLConstants_js__WEBPACK_IMPORTED_MODULE_10__/* ["default"].BOOL_VEC2 */ .Z.BOOL_VEC2] = getVec2UniformFunction;\ngltfUniformFunctions[_Core_WebGLConstants_js__WEBPACK_IMPORTED_MODULE_10__/* ["default"].BOOL_VEC3 */ .Z.BOOL_VEC3] = getVec3UniformFunction;\ngltfUniformFunctions[_Core_WebGLConstants_js__WEBPACK_IMPORTED_MODULE_10__/* ["default"].BOOL_VEC4 */ .Z.BOOL_VEC4] = getVec4UniformFunction;\ngltfUniformFunctions[_Core_WebGLConstants_js__WEBPACK_IMPORTED_MODULE_10__/* ["default"].FLOAT_MAT2 */ .Z.FLOAT_MAT2] = getMat2UniformFunction;\ngltfUniformFunctions[_Core_WebGLConstants_js__WEBPACK_IMPORTED_MODULE_10__/* ["default"].FLOAT_MAT3 */ .Z.FLOAT_MAT3] = getMat3UniformFunction;\ngltfUniformFunctions[_Core_WebGLConstants_js__WEBPACK_IMPORTED_MODULE_10__/* ["default"].FLOAT_MAT4 */ .Z.FLOAT_MAT4] = getMat4UniformFunction;\ngltfUniformFunctions[_Core_WebGLConstants_js__WEBPACK_IMPORTED_MODULE_10__/* ["default"].SAMPLER_2D */ .Z.SAMPLER_2D] = getTextureUniformFunction;\n// GLTF_SPEC: Support SAMPLER_CUBE. https://github.com/KhronosGroup/glTF/issues/40\n\nModelUtility.createUniformFunction = function (\n  type,\n  value,\n  textures,\n  defaultTexture\n) {\n  return gltfUniformFunctions[type](value, textures, defaultTexture);\n};\n\nfunction scaleFromMatrix5Array(matrix) {\n  return [\n    matrix[0],\n    matrix[1],\n    matrix[2],\n    matrix[3],\n    matrix[5],\n    matrix[6],\n    matrix[7],\n    matrix[8],\n    matrix[10],\n    matrix[11],\n    matrix[12],\n    matrix[13],\n    matrix[15],\n    matrix[16],\n    matrix[17],\n    matrix[18],\n  ];\n}\n\nfunction translateFromMatrix5Array(matrix) {\n  return [matrix[20], matrix[21], matrix[22], matrix[23]];\n}\n\nModelUtility.createUniformsForDracoQuantizedAttributes = function (\n  decodedAttributes\n) {\n  var uniformMap = {};\n  for (var attribute in decodedAttributes) {\n    if (decodedAttributes.hasOwnProperty(attribute)) {\n      var decodedData = decodedAttributes[attribute];\n      var quantization = decodedData.quantization;\n\n      if (!(0,_Core_defined_js__WEBPACK_IMPORTED_MODULE_16__/* ["default"] */ .Z)(quantization)) {\n        continue;\n      }\n\n      if (attribute.charAt(0) === "_") {\n        attribute = attribute.substring(1);\n      }\n\n      var uniformVarName = "gltf_u_dec_" + attribute.toLowerCase();\n\n      if (quantization.octEncoded) {\n        var uniformVarNameRangeConstant = uniformVarName + "_rangeConstant";\n        var rangeConstant = (1 << quantization.quantizationBits) - 1.0;\n        uniformMap[uniformVarNameRangeConstant] = getScalarUniformFunction(\n          rangeConstant\n        ).func;\n        continue;\n      }\n\n      var uniformVarNameNormConstant = uniformVarName + "_normConstant";\n      var normConstant =\n        quantization.range / (1 << quantization.quantizationBits);\n      uniformMap[uniformVarNameNormConstant] = getScalarUniformFunction(\n        normConstant\n      ).func;\n\n      var uniformVarNameMin = uniformVarName + "_min";\n      switch (decodedData.componentsPerAttribute) {\n        case 1:\n          uniformMap[uniformVarNameMin] = getScalarUniformFunction(\n            quantization.minValues\n          ).func;\n          break;\n        case 2:\n          uniformMap[uniformVarNameMin] = getVec2UniformFunction(\n            quantization.minValues\n          ).func;\n          break;\n        case 3:\n          uniformMap[uniformVarNameMin] = getVec3UniformFunction(\n            quantization.minValues\n          ).func;\n          break;\n        case 4:\n          uniformMap[uniformVarNameMin] = getVec4UniformFunction(\n            quantization.minValues\n          ).func;\n          break;\n      }\n    }\n  }\n\n  return uniformMap;\n};\n\nModelUtility.createUniformsForQuantizedAttributes = function (\n  gltf,\n  primitive,\n  quantizedUniforms\n) {\n  var accessors = gltf.accessors;\n  var setUniforms = {};\n  var uniformMap = {};\n\n  var attributes = primitive.attributes;\n  for (var attribute in attributes) {\n    if (attributes.hasOwnProperty(attribute)) {\n      var accessorId = attributes[attribute];\n      var a = accessors[accessorId];\n      var extensions = a.extensions;\n\n      if (attribute.charAt(0) === "_") {\n        attribute = attribute.substring(1);\n      }\n\n      if ((0,_Core_defined_js__WEBPACK_IMPORTED_MODULE_16__/* ["default"] */ .Z)(extensions)) {\n        var quantizedAttributes = extensions.WEB3D_quantized_attributes;\n        if ((0,_Core_defined_js__WEBPACK_IMPORTED_MODULE_16__/* ["default"] */ .Z)(quantizedAttributes)) {\n          var decodeMatrix = quantizedAttributes.decodeMatrix;\n          var uniformVariable = "gltf_u_dec_" + attribute.toLowerCase();\n\n          switch (a.type) {\n            case _AttributeType_js__WEBPACK_IMPORTED_MODULE_14__/* ["default"].SCALAR */ .Z.SCALAR:\n              uniformMap[uniformVariable] = getMat2UniformFunction(\n                decodeMatrix\n              ).func;\n              setUniforms[uniformVariable] = true;\n              break;\n            case _AttributeType_js__WEBPACK_IMPORTED_MODULE_14__/* ["default"].VEC2 */ .Z.VEC2:\n              uniformMap[uniformVariable] = getMat3UniformFunction(\n                decodeMatrix\n              ).func;\n              setUniforms[uniformVariable] = true;\n              break;\n            case _AttributeType_js__WEBPACK_IMPORTED_MODULE_14__/* ["default"].VEC3 */ .Z.VEC3:\n              uniformMap[uniformVariable] = getMat4UniformFunction(\n                decodeMatrix\n              ).func;\n              setUniforms[uniformVariable] = true;\n              break;\n            case _AttributeType_js__WEBPACK_IMPORTED_MODULE_14__/* ["default"].VEC4 */ .Z.VEC4:\n              // VEC4 attributes are split into scale and translate because there is no mat5 in GLSL\n              var uniformVariableScale = uniformVariable + "_scale";\n              var uniformVariableTranslate = uniformVariable + "_translate";\n              uniformMap[uniformVariableScale] = getMat4UniformFunction(\n                scaleFromMatrix5Array(decodeMatrix)\n              ).func;\n              uniformMap[uniformVariableTranslate] = getVec4UniformFunction(\n                translateFromMatrix5Array(decodeMatrix)\n              ).func;\n              setUniforms[uniformVariableScale] = true;\n              setUniforms[uniformVariableTranslate] = true;\n              break;\n          }\n        }\n      }\n    }\n  }\n\n  // If there are any unset quantized uniforms in this program, they should be set to the identity\n  for (var quantizedUniform in quantizedUniforms) {\n    if (quantizedUniforms.hasOwnProperty(quantizedUniform)) {\n      if (!setUniforms[quantizedUniform]) {\n        var properties = quantizedUniforms[quantizedUniform];\n        if ((0,_Core_defined_js__WEBPACK_IMPORTED_MODULE_16__/* ["default"] */ .Z)(properties.mat)) {\n          if (properties.mat === 2) {\n            uniformMap[quantizedUniform] = getMat2UniformFunction(\n              _Core_Matrix2_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"].IDENTITY */ .Z.IDENTITY\n            ).func;\n          } else if (properties.mat === 3) {\n            uniformMap[quantizedUniform] = getMat3UniformFunction(\n              _Core_Matrix3_js__WEBPACK_IMPORTED_MODULE_6__/* ["default"].IDENTITY */ .Z.IDENTITY\n            ).func;\n          } else if (properties.mat === 4) {\n            uniformMap[quantizedUniform] = getMat4UniformFunction(\n              _Core_Matrix4_js__WEBPACK_IMPORTED_MODULE_7__/* ["default"].IDENTITY */ .Z.IDENTITY\n            ).func;\n          }\n        }\n        if ((0,_Core_defined_js__WEBPACK_IMPORTED_MODULE_16__/* ["default"] */ .Z)(properties.vec)) {\n          if (properties.vec === 4) {\n            uniformMap[quantizedUniform] = getVec4UniformFunction([\n              0,\n              0,\n              0,\n              0,\n            ]).func;\n          }\n        }\n      }\n    }\n  }\n  return uniformMap;\n};\n\n// This doesn\'t support LOCAL, which we could add if it is ever used.\nvar scratchTranslationRtc = new _Core_Cartesian3_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"] */ .Z();\nvar gltfSemanticUniforms = {\n  MODEL: function (uniformState, model) {\n    return function () {\n      return uniformState.model;\n    };\n  },\n  VIEW: function (uniformState, model) {\n    return function () {\n      return uniformState.view;\n    };\n  },\n  PROJECTION: function (uniformState, model) {\n    return function () {\n      return uniformState.projection;\n    };\n  },\n  MODELVIEW: function (uniformState, model) {\n    return function () {\n      return uniformState.modelView;\n    };\n  },\n  CESIUM_RTC_MODELVIEW: function (uniformState, model) {\n    // CESIUM_RTC extension\n    var mvRtc = new _Core_Matrix4_js__WEBPACK_IMPORTED_MODULE_7__/* ["default"] */ .Z();\n    return function () {\n      if ((0,_Core_defined_js__WEBPACK_IMPORTED_MODULE_16__/* ["default"] */ .Z)(model._rtcCenter)) {\n        _Core_Matrix4_js__WEBPACK_IMPORTED_MODULE_7__/* ["default"].getTranslation */ .Z.getTranslation(uniformState.model, scratchTranslationRtc);\n        _Core_Cartesian3_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"].add */ .Z.add(\n          scratchTranslationRtc,\n          model._rtcCenter,\n          scratchTranslationRtc\n        );\n        _Core_Matrix4_js__WEBPACK_IMPORTED_MODULE_7__/* ["default"].multiplyByPoint */ .Z.multiplyByPoint(\n          uniformState.view,\n          scratchTranslationRtc,\n          scratchTranslationRtc\n        );\n        return _Core_Matrix4_js__WEBPACK_IMPORTED_MODULE_7__/* ["default"].setTranslation */ .Z.setTranslation(\n          uniformState.modelView,\n          scratchTranslationRtc,\n          mvRtc\n        );\n      }\n      return uniformState.modelView;\n    };\n  },\n  MODELVIEWPROJECTION: function (uniformState, model) {\n    return function () {\n      return uniformState.modelViewProjection;\n    };\n  },\n  MODELINVERSE: function (uniformState, model) {\n    return function () {\n      return uniformState.inverseModel;\n    };\n  },\n  VIEWINVERSE: function (uniformState, model) {\n    return function () {\n      return uniformState.inverseView;\n    };\n  },\n  PROJECTIONINVERSE: function (uniformState, model) {\n    return function () {\n      return uniformState.inverseProjection;\n    };\n  },\n  MODELVIEWINVERSE: function (uniformState, model) {\n    return function () {\n      return uniformState.inverseModelView;\n    };\n  },\n  MODELVIEWPROJECTIONINVERSE: function (uniformState, model) {\n    return function () {\n      return uniformState.inverseModelViewProjection;\n    };\n  },\n  MODELINVERSETRANSPOSE: function (uniformState, model) {\n    return function () {\n      return uniformState.inverseTransposeModel;\n    };\n  },\n  MODELVIEWINVERSETRANSPOSE: function (uniformState, model) {\n    return function () {\n      return uniformState.normal;\n    };\n  },\n  VIEWPORT: function (uniformState, model) {\n    return function () {\n      return uniformState.viewportCartesian4;\n    };\n  },\n  // JOINTMATRIX created in createCommand()\n};\n\nModelUtility.getGltfSemanticUniforms = function () {\n  return gltfSemanticUniforms;\n};\n/* harmony default export */ __webpack_exports__["Z"] = (ModelUtility);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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b2RlX21vZHVsZXMvY2VzaXVtL1NvdXJjZS9TY2VuZS9Nb2RlbFV0aWxpdHkuanM/ZGQzNyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgQm91bmRpbmdTcGhlcmUgZnJvbSBcIi4uL0NvcmUvQm91bmRpbmdTcGhlcmUuanNcIjtcbmltcG9ydCBDYXJ0ZXNpYW4yIGZyb20gXCIuLi9Db3JlL0NhcnRlc2lhbjIuanNcIjtcbmltcG9ydCBDYXJ0ZXNpYW4zIGZyb20gXCIuLi9Db3JlL0NhcnRlc2lhbjMuanNcIjtcbmltcG9ydCBDYXJ0ZXNpYW40IGZyb20gXCIuLi9Db3JlL0NhcnRlc2lhbjQuanNcIjtcbmltcG9ydCBjbG9uZSBmcm9tIFwiLi4vQ29yZS9jbG9uZS5qc1wiO1xuaW1wb3J0IGRlZmluZWQgZnJvbSBcIi4uL0NvcmUvZGVmaW5lZC5qc1wiO1xuaW1wb3J0IE1hdHJpeDIgZnJvbSBcIi4uL0NvcmUvTWF0cml4Mi5qc1wiO1xuaW1wb3J0IE1hdHJpeDMgZnJvbSBcIi4uL0NvcmUvTWF0cml4My5qc1wiO1xuaW1wb3J0IE1hdHJpeDQgZnJvbSBcIi4uL0NvcmUvTWF0cml4NC5qc1wiO1xuaW1wb3J0IFF1YXRlcm5pb24gZnJvbSBcIi4uL0NvcmUvUXVhdGVybmlvbi5qc1wiO1xuaW1wb3J0IFJ1bnRpbWVFcnJvciBmcm9tIFwiLi4vQ29yZS9SdW50aW1lRXJyb3IuanNcIjtcbmltcG9ydCBXZWJHTENvbnN0YW50cyBmcm9tIFwiLi4vQ29yZS9XZWJHTENvbnN0YW50cy5qc1wiO1xuaW1wb3J0IFNoYWRlclNvdXJjZSBmcm9tIFwiLi4vUmVuZGVyZXIvU2hhZGVyU291cmNlLmpzXCI7XG5pbXBvcnQgYWRkVG9BcnJheSBmcm9tIFwiLi9HbHRmUGlwZWxpbmUvYWRkVG9BcnJheS5qc1wiO1xuaW1wb3J0IEZvckVhY2ggZnJvbSBcIi4vR2x0ZlBpcGVsaW5lL0ZvckVhY2guanNcIjtcbmltcG9ydCB1c2VzRXh0ZW5zaW9uIGZyb20gXCIuL0dsdGZQaXBlbGluZS91c2VzRXh0ZW5zaW9uLmpzXCI7XG5pbXBvcnQgQXR0cmlidXRlVHlwZSBmcm9tIFwiLi9BdHRyaWJ1dGVUeXBlLmpzXCI7XG5pbXBvcnQgQXhpcyBmcm9tIFwiLi9BeGlzLmpzXCI7XG5cbi8qKlxuICogQHByaXZhdGVcbiAqL1xudmFyIE1vZGVsVXRpbGl0eSA9IHt9O1xuXG4vKipcbiAqIFVwZGF0ZXMgdGhlIG1vZGVsJ3MgZm9yd2FyZCBheGlzIGlmIHRoZSBtb2RlbCBpcyBub3QgYSAyLjAgbW9kZWwuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG1vZGVsIFRoZSBtb2RlbCB0byB1cGRhdGUuXG4gKi9cbk1vZGVsVXRpbGl0eS51cGRhdGVGb3J3YXJkQXhpcyA9IGZ1bmN0aW9uIChtb2RlbCkge1xuICB2YXIgY2FjaGVkU291cmNlVmVyc2lvbiA9IG1vZGVsLmdsdGYuZXh0cmFzLnNvdXJjZVZlcnNpb247XG5cbiAgaWYgKFxuICAgIChkZWZpbmVkKGNhY2hlZFNvdXJjZVZlcnNpb24pICYmIGNhY2hlZFNvdXJjZVZlcnNpb24gIT09IFwiMi4wXCIpIHx8XG4gICAgTW9kZWxVdGlsaXR5LmdldEFzc2V0VmVyc2lvbihtb2RlbC5nbHRmKSAhPT0gXCIyLjBcIlxuICApIHtcbiAgICBtb2RlbC5fZ2x0ZkZvcndhcmRBeGlzID0gQXhpcy5YO1xuICB9XG59O1xuXG4vKipcbiAqICBHZXRzIHRoZSBzdHJpbmcgcmVwcmVzZW50aW5nIHRoZSBnbFRGIGFzc2V0IHZlcnNpb24uXG4gKlxuICogIEBwYXJhbSB7T2JqZWN0fSBnbHRmIEEgamF2YXNjcmlwdCBvYmplY3QgY29udGFpbmluZyBhIGdsVEYgYXNzZXQuXG4gKiAgQHJldHVybnMge1N0cmluZ30gVGhlIGdsVEYgYXNzZXQgdmVyc2lvbiBzdHJpbmcuXG4gKi9cbk1vZGVsVXRpbGl0eS5nZXRBc3NldFZlcnNpb24gPSBmdW5jdGlvbiAoZ2x0Zikge1xuICAvLyBJbiBnbFRGIDEuMCBpdCB3YXMgdmFsaWQgdG8gb21pdCB0aGUgdmVyc2lvbiBudW1iZXIuXG4gIGlmICghZGVmaW5lZChnbHRmLmFzc2V0KSB8fCAhZGVmaW5lZChnbHRmLmFzc2V0LnZlcnNpb24pKSB7XG4gICAgcmV0dXJuIFwiMS4wXCI7XG4gIH1cblxuICByZXR1cm4gZ2x0Zi5hc3NldC52ZXJzaW9uO1xufTtcblxuLyoqXG4gKiBTcGxpdHMgcHJpbWl0aXZlIG1hdGVyaWFscyB3aXRoIHZhbHVlcyBpbmNvbXBhdGlibGUgZm9yIGdlbmVyYXRpbmcgdGVjaG5pcXVlcy5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gZ2x0ZiBBIGphdmFzY3JpcHQgb2JqZWN0IGNvbnRhaW5pbmcgYSBnbFRGIGFzc2V0LlxuICogQHJldHVybnMge09iamVjdH0gVGhlIGdsVEYgYXNzZXQgd2l0aCBtb2RpZmllZCBtYXRlcmlhbHMuXG4gKi9cbk1vZGVsVXRpbGl0eS5zcGxpdEluY29tcGF0aWJsZU1hdGVyaWFscyA9IGZ1bmN0aW9uIChnbHRmKSB7XG4gIHZhciBhY2Nlc3NvcnMgPSBnbHRmLmFjY2Vzc29ycztcbiAgdmFyIG1hdGVyaWFscyA9IGdsdGYubWF0ZXJpYWxzO1xuICB2YXIgcHJpbWl0aXZlSW5mb0J5TWF0ZXJpYWwgPSB7fTtcbiAgRm9yRWFjaC5tZXNoKGdsdGYsIGZ1bmN0aW9uIChtZXNoKSB7XG4gICAgRm9yRWFjaC5tZXNoUHJpbWl0aXZlKG1lc2gsIGZ1bmN0aW9uIChwcmltaXRpdmUpIHtcbiAgICAgIHZhciBtYXRlcmlhbEluZGV4ID0gcHJpbWl0aXZlLm1hdGVyaWFsO1xuICAgICAgdmFyIG1hdGVyaWFsID0gbWF0ZXJpYWxzW21hdGVyaWFsSW5kZXhdO1xuXG4gICAgICB2YXIgam9pbnRBY2Nlc3NvcklkID0gcHJpbWl0aXZlLmF0dHJpYnV0ZXMuSk9JTlRTXzA7XG4gICAgICB2YXIgY29tcG9uZW50VHlwZTtcbiAgICAgIHZhciBhY2Nlc3NvclR5cGU7XG4gICAgICBpZiAoZGVmaW5lZChqb2ludEFjY2Vzc29ySWQpKSB7XG4gICAgICAgIHZhciBqb2ludEFjY2Vzc29yID0gYWNjZXNzb3JzW2pvaW50QWNjZXNzb3JJZF07XG4gICAgICAgIGNvbXBvbmVudFR5cGUgPSBqb2ludEFjY2Vzc29yLmNvbXBvbmVudFR5cGU7XG4gICAgICAgIGFjY2Vzc29yVHlwZSA9IGpvaW50QWNjZXNzb3IudHlwZTtcbiAgICAgIH1cbiAgICAgIHZhciBpc1NraW5uZWQgPSBkZWZpbmVkKGpvaW50QWNjZXNzb3JJZCkgJiYgYWNjZXNzb3JUeXBlID09PSBcIlZFQzRcIjtcbiAgICAgIHZhciBoYXNWZXJ0ZXhDb2xvcnMgPSBkZWZpbmVkKHByaW1pdGl2ZS5hdHRyaWJ1dGVzLkNPTE9SXzApO1xuICAgICAgdmFyIGhhc01vcnBoVGFyZ2V0cyA9IGRlZmluZWQocHJpbWl0aXZlLnRhcmdldHMpO1xuICAgICAgdmFyIGhhc05vcm1hbHMgPSBkZWZpbmVkKHByaW1pdGl2ZS5hdHRyaWJ1dGVzLk5PUk1BTCk7XG4gICAgICB2YXIgaGFzVGFuZ2VudHMgPSBkZWZpbmVkKHByaW1pdGl2ZS5hdHRyaWJ1dGVzLlRBTkdFTlQpO1xuICAgICAgdmFyIGhhc1RleENvb3JkcyA9IGRlZmluZWQocHJpbWl0aXZlLmF0dHJpYnV0ZXMuVEVYQ09PUkRfMCk7XG4gICAgICB2YXIgaGFzVGV4Q29vcmQxID1cbiAgICAgICAgaGFzVGV4Q29vcmRzICYmIGRlZmluZWQocHJpbWl0aXZlLmF0dHJpYnV0ZXMuVEVYQ09PUkRfMSk7XG4gICAgICB2YXIgaGFzT3V0bGluZSA9XG4gICAgICAgIGRlZmluZWQocHJpbWl0aXZlLmV4dGVuc2lvbnMpICYmXG4gICAgICAgIGRlZmluZWQocHJpbWl0aXZlLmV4dGVuc2lvbnMuQ0VTSVVNX3ByaW1pdGl2ZV9vdXRsaW5lKTtcblxuICAgICAgdmFyIHByaW1pdGl2ZUluZm8gPSBwcmltaXRpdmVJbmZvQnlNYXRlcmlhbFttYXRlcmlhbEluZGV4XTtcbiAgICAgIGlmICghZGVmaW5lZChwcmltaXRpdmVJbmZvKSkge1xuICAgICAgICBwcmltaXRpdmVJbmZvQnlNYXRlcmlhbFttYXRlcmlhbEluZGV4XSA9IHtcbiAgICAgICAgICBza2lubmluZzoge1xuICAgICAgICAgICAgc2tpbm5lZDogaXNTa2lubmVkLFxuICAgICAgICAgICAgY29tcG9uZW50VHlwZTogY29tcG9uZW50VHlwZSxcbiAgICAgICAgICB9LFxuICAgICAgICAgIGhhc1ZlcnRleENvbG9yczogaGFzVmVydGV4Q29sb3JzLFxuICAgICAgICAgIGhhc01vcnBoVGFyZ2V0czogaGFzTW9ycGhUYXJnZXRzLFxuICAgICAgICAgIGhhc05vcm1hbHM6IGhhc05vcm1hbHMsXG4gICAgICAgICAgaGFzVGFuZ2VudHM6IGhhc1RhbmdlbnRzLFxuICAgICAgICAgIGhhc1RleENvb3JkczogaGFzVGV4Q29vcmRzLFxuICAgICAgICAgIGhhc1RleENvb3JkMTogaGFzVGV4Q29vcmQxLFxuICAgICAgICAgIGhhc091dGxpbmU6IGhhc091dGxpbmUsXG4gICAgICAgIH07XG4gICAgICB9IGVsc2UgaWYgKFxuICAgICAgICBwcmltaXRpdmVJbmZvLnNraW5uaW5nLnNraW5uZWQgIT09IGlzU2tpbm5lZCB8fFxuICAgICAgICBwcmltaXRpdmVJbmZvLmhhc1ZlcnRleENvbG9ycyAhPT0gaGFzVmVydGV4Q29sb3JzIHx8XG4gICAgICAgIHByaW1pdGl2ZUluZm8uaGFzTW9ycGhUYXJnZXRzICE9PSBoYXNNb3JwaFRhcmdldHMgfHxcbiAgICAgICAgcHJpbWl0aXZlSW5mby5oYXNOb3JtYWxzICE9PSBoYXNOb3JtYWxzIHx8XG4gICAgICAgIHByaW1pdGl2ZUluZm8uaGFzVGFuZ2VudHMgIT09IGhhc1RhbmdlbnRzIHx8XG4gICAgICAgIHByaW1pdGl2ZUluZm8uaGFzVGV4Q29vcmRzICE9PSBoYXNUZXhDb29yZHMgfHxcbiAgICAgICAgcHJpbWl0aXZlSW5mby5oYXNUZXhDb29yZDEgIT09IGhhc1RleENvb3JkMSB8fFxuICAgICAgICBwcmltaXRpdmVJbmZvLmhhc091dGxpbmUgIT09IGhhc091dGxpbmVcbiAgICAgICkge1xuICAgICAgICAvLyBUaGlzIHByaW1pdGl2ZSB1c2VzIHRoZSBzYW1lIG1hdGVyaWFsIGFzIGFub3RoZXIgb25lIHRoYXQgZWl0aGVyOlxuICAgICAgICAvLyAqIElzbid0IHNraW5uZWRcbiAgICAgICAgLy8gKiBVc2VzIGEgZGlmZmVyZW50IHR5cGUgdG8gc3RvcmUgam9pbnRzIGFuZCB3ZWlnaHRzXG4gICAgICAgIC8vICogRG9lc24ndCBoYXZlIHZlcnRleCBjb2xvcnMsIG1vcnBoIHRhcmdldHMsIG5vcm1hbHMsIHRhbmdlbnRzLCBvciB0ZXhDb29yZHNcbiAgICAgICAgLy8gKiBEb2Vzbid0IGhhdmUgYSBDRVNJVU1fcHJpbWl0aXZlX291dGxpbmUgZXh0ZW5zaW9uLlxuICAgICAgICB2YXIgY2xvbmVkTWF0ZXJpYWwgPSBjbG9uZShtYXRlcmlhbCwgdHJ1ZSk7XG4gICAgICAgIC8vIFNwbGl0IHRoaXMgb2ZmIGFzIGEgc2VwYXJhdGUgbWF0ZXJpYWxcbiAgICAgICAgbWF0ZXJpYWxJbmRleCA9IGFkZFRvQXJyYXkobWF0ZXJpYWxzLCBjbG9uZWRNYXRlcmlhbCk7XG4gICAgICAgIHByaW1pdGl2ZS5tYXRlcmlhbCA9IG1hdGVyaWFsSW5kZXg7XG4gICAgICAgIHByaW1pdGl2ZUluZm9CeU1hdGVyaWFsW21hdGVyaWFsSW5kZXhdID0ge1xuICAgICAgICAgIHNraW5uaW5nOiB7XG4gICAgICAgICAgICBza2lubmVkOiBpc1NraW5uZWQsXG4gICAgICAgICAgICBjb21wb25lbnRUeXBlOiBjb21wb25lbnRUeXBlLFxuICAgICAgICAgIH0sXG4gICAgICAgICAgaGFzVmVydGV4Q29sb3JzOiBoYXNWZXJ0ZXhDb2xvcnMsXG4gICAgICAgICAgaGFzTW9ycGhUYXJnZXRzOiBoYXNNb3JwaFRhcmdldHMsXG4gICAgICAgICAgaGFzTm9ybWFsczogaGFzTm9ybWFscyxcbiAgICAgICAgICBoYXNUYW5nZW50czogaGFzVGFuZ2VudHMsXG4gICAgICAgICAgaGFzVGV4Q29vcmRzOiBoYXNUZXhDb29yZHMsXG4gICAgICAgICAgaGFzVGV4Q29vcmQxOiBoYXNUZXhDb29yZDEsXG4gICAgICAgICAgaGFzT3V0bGluZTogaGFzT3V0bGluZSxcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSk7XG5cbiAgcmV0dXJuIHByaW1pdGl2ZUluZm9CeU1hdGVyaWFsO1xufTtcblxuTW9kZWxVdGlsaXR5LmdldFNoYWRlclZhcmlhYmxlID0gZnVuY3Rpb24gKHR5cGUpIHtcbiAgaWYgKHR5cGUgPT09IFwiU0NBTEFSXCIpIHtcbiAgICByZXR1cm4gXCJmbG9hdFwiO1xuICB9XG4gIHJldHVybiB0eXBlLnRvTG93ZXJDYXNlKCk7XG59O1xuXG5Nb2RlbFV0aWxpdHkuTW9kZWxTdGF0ZSA9IHtcbiAgTkVFRFNfTE9BRDogMCxcbiAgTE9BRElORzogMSxcbiAgTE9BREVEOiAyLCAvLyBSZW5kZXJhYmxlLCBidXQgdGV4dHVyZXMgY2FuIHN0aWxsIGJlIHBlbmRpbmcgd2hlbiBpbmNyZW1lbnRhbGx5TG9hZFRleHR1cmVzIGlzIHRydWUuXG4gIEZBSUxFRDogMyxcbn07XG5cbk1vZGVsVXRpbGl0eS5nZXRGYWlsZWRMb2FkRnVuY3Rpb24gPSBmdW5jdGlvbiAobW9kZWwsIHR5cGUsIHBhdGgpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIChlcnJvcikge1xuICAgIG1vZGVsLl9zdGF0ZSA9IE1vZGVsVXRpbGl0eS5Nb2RlbFN0YXRlLkZBSUxFRDtcbiAgICB2YXIgbWVzc2FnZSA9IFwiRmFpbGVkIHRvIGxvYWQgXCIgKyB0eXBlICsgXCI6IFwiICsgcGF0aDtcbiAgICBpZiAoZGVmaW5lZChlcnJvcikpIHtcbiAgICAgIG1lc3NhZ2UgKz0gXCJcXG5cIiArIGVycm9yLm1lc3NhZ2U7XG4gICAgfVxuICAgIG1vZGVsLl9yZWFkeVByb21pc2UucmVqZWN0KG5ldyBSdW50aW1lRXJyb3IobWVzc2FnZSkpO1xuICB9O1xufTtcblxuTW9kZWxVdGlsaXR5LnBhcnNlQnVmZmVycyA9IGZ1bmN0aW9uIChtb2RlbCwgYnVmZmVyTG9hZCkge1xuICB2YXIgbG9hZFJlc291cmNlcyA9IG1vZGVsLl9sb2FkUmVzb3VyY2VzO1xuICBGb3JFYWNoLmJ1ZmZlcihtb2RlbC5nbHRmLCBmdW5jdGlvbiAoYnVmZmVyLCBidWZmZXJWaWV3SWQpIHtcbiAgICBpZiAoZGVmaW5lZChidWZmZXIuZXh0cmFzLl9waXBlbGluZS5zb3VyY2UpKSB7XG4gICAgICBsb2FkUmVzb3VyY2VzLmJ1ZmZlcnNbYnVmZmVyVmlld0lkXSA9IGJ1ZmZlci5leHRyYXMuX3BpcGVsaW5lLnNvdXJjZTtcbiAgICB9IGVsc2UgaWYgKGRlZmluZWQoYnVmZmVyTG9hZCkpIHtcbiAgICAgIHZhciBidWZmZXJSZXNvdXJjZSA9IG1vZGVsLl9yZXNvdXJjZS5nZXREZXJpdmVkUmVzb3VyY2Uoe1xuICAgICAgICB1cmw6IGJ1ZmZlci51cmksXG4gICAgICB9KTtcbiAgICAgICsrbG9hZFJlc291cmNlcy5wZW5kaW5nQnVmZmVyTG9hZHM7XG4gICAgICBidWZmZXJSZXNvdXJjZVxuICAgICAgICAuZmV0Y2hBcnJheUJ1ZmZlcigpXG4gICAgICAgIC50aGVuKGJ1ZmZlckxvYWQobW9kZWwsIGJ1ZmZlclZpZXdJZCkpXG4gICAgICAgIC5vdGhlcndpc2UoXG4gICAgICAgICAgTW9kZWxVdGlsaXR5LmdldEZhaWxlZExvYWRGdW5jdGlvbihcbiAgICAgICAgICAgIG1vZGVsLFxuICAgICAgICAgICAgXCJidWZmZXJcIixcbiAgICAgICAgICAgIGJ1ZmZlclJlc291cmNlLnVybFxuICAgICAgICAgIClcbiAgICAgICAgKTtcbiAgICB9XG4gIH0pO1xufTtcblxudmFyIGFNaW5TY3JhdGNoID0gbmV3IENhcnRlc2lhbjMoKTtcbnZhciBhTWF4U2NyYXRjaCA9IG5ldyBDYXJ0ZXNpYW4zKCk7XG5cbk1vZGVsVXRpbGl0eS5jb21wdXRlQm91bmRpbmdTcGhlcmUgPSBmdW5jdGlvbiAobW9kZWwpIHtcbiAgdmFyIGdsdGYgPSBtb2RlbC5nbHRmO1xuICB2YXIgZ2x0Zk5vZGVzID0gZ2x0Zi5ub2RlcztcbiAgdmFyIGdsdGZNZXNoZXMgPSBnbHRmLm1lc2hlcztcbiAgdmFyIHJvb3ROb2RlcyA9IGdsdGYuc2NlbmVzW2dsdGYuc2NlbmVdLm5vZGVzO1xuICB2YXIgcm9vdE5vZGVzTGVuZ3RoID0gcm9vdE5vZGVzLmxlbmd0aDtcblxuICB2YXIgbm9kZVN0YWNrID0gW107XG5cbiAgdmFyIG1pbiA9IG5ldyBDYXJ0ZXNpYW4zKFxuICAgIE51bWJlci5NQVhfVkFMVUUsXG4gICAgTnVtYmVyLk1BWF9WQUxVRSxcbiAgICBOdW1iZXIuTUFYX1ZBTFVFXG4gICk7XG4gIHZhciBtYXggPSBuZXcgQ2FydGVzaWFuMyhcbiAgICAtTnVtYmVyLk1BWF9WQUxVRSxcbiAgICAtTnVtYmVyLk1BWF9WQUxVRSxcbiAgICAtTnVtYmVyLk1BWF9WQUxVRVxuICApO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcm9vdE5vZGVzTGVuZ3RoOyArK2kpIHtcbiAgICB2YXIgbiA9IGdsdGZOb2Rlc1tyb290Tm9kZXNbaV1dO1xuICAgIG4uX3RyYW5zZm9ybVRvUm9vdCA9IE1vZGVsVXRpbGl0eS5nZXRUcmFuc2Zvcm0obik7XG4gICAgbm9kZVN0YWNrLnB1c2gobik7XG5cbiAgICB3aGlsZSAobm9kZVN0YWNrLmxlbmd0aCA+IDApIHtcbiAgICAgIG4gPSBub2RlU3RhY2sucG9wKCk7XG4gICAgICB2YXIgdHJhbnNmb3JtVG9Sb290ID0gbi5fdHJhbnNmb3JtVG9Sb290O1xuXG4gICAgICB2YXIgbWVzaElkID0gbi5tZXNoO1xuICAgICAgaWYgKGRlZmluZWQobWVzaElkKSkge1xuICAgICAgICB2YXIgbWVzaCA9IGdsdGZNZXNoZXNbbWVzaElkXTtcbiAgICAgICAgdmFyIHByaW1pdGl2ZXMgPSBtZXNoLnByaW1pdGl2ZXM7XG4gICAgICAgIHZhciBwcmltaXRpdmVzTGVuZ3RoID0gcHJpbWl0aXZlcy5sZW5ndGg7XG4gICAgICAgIGZvciAodmFyIG0gPSAwOyBtIDwgcHJpbWl0aXZlc0xlbmd0aDsgKyttKSB7XG4gICAgICAgICAgdmFyIHBvc2l0aW9uQWNjZXNzb3IgPSBwcmltaXRpdmVzW21dLmF0dHJpYnV0ZXMuUE9TSVRJT047XG4gICAgICAgICAgaWYgKGRlZmluZWQocG9zaXRpb25BY2Nlc3NvcikpIHtcbiAgICAgICAgICAgIHZhciBtaW5NYXggPSBNb2RlbFV0aWxpdHkuZ2V0QWNjZXNzb3JNaW5NYXgoZ2x0ZiwgcG9zaXRpb25BY2Nlc3Nvcik7XG4gICAgICAgICAgICBpZiAoZGVmaW5lZChtaW5NYXgubWluKSAmJiBkZWZpbmVkKG1pbk1heC5tYXgpKSB7XG4gICAgICAgICAgICAgIHZhciBhTWluID0gQ2FydGVzaWFuMy5mcm9tQXJyYXkobWluTWF4Lm1pbiwgMCwgYU1pblNjcmF0Y2gpO1xuICAgICAgICAgICAgICB2YXIgYU1heCA9IENhcnRlc2lhbjMuZnJvbUFycmF5KG1pbk1heC5tYXgsIDAsIGFNYXhTY3JhdGNoKTtcblxuICAgICAgICAgICAgICBNYXRyaXg0Lm11bHRpcGx5QnlQb2ludCh0cmFuc2Zvcm1Ub1Jvb3QsIGFNaW4sIGFNaW4pO1xuICAgICAgICAgICAgICBNYXRyaXg0Lm11bHRpcGx5QnlQb2ludCh0cmFuc2Zvcm1Ub1Jvb3QsIGFNYXgsIGFNYXgpO1xuICAgICAgICAgICAgICBDYXJ0ZXNpYW4zLm1pbmltdW1CeUNvbXBvbmVudChtaW4sIGFNaW4sIG1pbik7XG4gICAgICAgICAgICAgIENhcnRlc2lhbjMubWF4aW11bUJ5Q29tcG9uZW50KG1heCwgYU1heCwgbWF4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdmFyIGNoaWxkcmVuID0gbi5jaGlsZHJlbjtcbiAgICAgIGlmIChkZWZpbmVkKGNoaWxkcmVuKSkge1xuICAgICAgICB2YXIgY2hpbGRyZW5MZW5ndGggPSBjaGlsZHJlbi5sZW5ndGg7XG4gICAgICAgIGZvciAodmFyIGsgPSAwOyBrIDwgY2hpbGRyZW5MZW5ndGg7ICsraykge1xuICAgICAgICAgIHZhciBjaGlsZCA9IGdsdGZOb2Rlc1tjaGlsZHJlbltrXV07XG4gICAgICAgICAgY2hpbGQuX3RyYW5zZm9ybVRvUm9vdCA9IE1vZGVsVXRpbGl0eS5nZXRUcmFuc2Zvcm0oY2hpbGQpO1xuICAgICAgICAgIE1hdHJpeDQubXVsdGlwbHlUcmFuc2Zvcm1hdGlvbihcbiAgICAgICAgICAgIHRyYW5zZm9ybVRvUm9vdCxcbiAgICAgICAgICAgIGNoaWxkLl90cmFuc2Zvcm1Ub1Jvb3QsXG4gICAgICAgICAgICBjaGlsZC5fdHJhbnNmb3JtVG9Sb290XG4gICAgICAgICAgKTtcbiAgICAgICAgICBub2RlU3RhY2sucHVzaChjaGlsZCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGRlbGV0ZSBuLl90cmFuc2Zvcm1Ub1Jvb3Q7XG4gICAgfVxuICB9XG5cbiAgdmFyIGJvdW5kaW5nU3BoZXJlID0gQm91bmRpbmdTcGhlcmUuZnJvbUNvcm5lclBvaW50cyhtaW4sIG1heCk7XG4gIGlmIChtb2RlbC5fZm9yd2FyZEF4aXMgPT09IEF4aXMuWikge1xuICAgIC8vIGdsVEYgMi4wIGhhcyBhIFotZm9yd2FyZCBjb252ZW50aW9uIHRoYXQgbXVzdCBiZSBhZGFwdGVkIGhlcmUgdG8gWC1mb3J3YXJkLlxuICAgIEJvdW5kaW5nU3BoZXJlLnRyYW5zZm9ybVdpdGhvdXRTY2FsZShcbiAgICAgIGJvdW5kaW5nU3BoZXJlLFxuICAgICAgQXhpcy5aX1VQX1RPX1hfVVAsXG4gICAgICBib3VuZGluZ1NwaGVyZVxuICAgICk7XG4gIH1cbiAgaWYgKG1vZGVsLl91cEF4aXMgPT09IEF4aXMuWSkge1xuICAgIEJvdW5kaW5nU3BoZXJlLnRyYW5zZm9ybVdpdGhvdXRTY2FsZShcbiAgICAgIGJvdW5kaW5nU3BoZXJlLFxuICAgICAgQXhpcy5ZX1VQX1RPX1pfVVAsXG4gICAgICBib3VuZGluZ1NwaGVyZVxuICAgICk7XG4gIH0gZWxzZSBpZiAobW9kZWwuX3VwQXhpcyA9PT0gQXhpcy5YKSB7XG4gICAgQm91bmRpbmdTcGhlcmUudHJhbnNmb3JtV2l0aG91dFNjYWxlKFxuICAgICAgYm91bmRpbmdTcGhlcmUsXG4gICAgICBBeGlzLlhfVVBfVE9fWl9VUCxcbiAgICAgIGJvdW5kaW5nU3BoZXJlXG4gICAgKTtcbiAgfVxuICByZXR1cm4gYm91bmRpbmdTcGhlcmU7XG59O1xuXG5mdW5jdGlvbiB0ZWNobmlxdWVBdHRyaWJ1dGVGb3JTZW1hbnRpYyh0ZWNobmlxdWUsIHNlbWFudGljKSB7XG4gIHJldHVybiBGb3JFYWNoLnRlY2huaXF1ZUF0dHJpYnV0ZSh0ZWNobmlxdWUsIGZ1bmN0aW9uIChcbiAgICBhdHRyaWJ1dGUsXG4gICAgYXR0cmlidXRlTmFtZVxuICApIHtcbiAgICBpZiAoYXR0cmlidXRlLnNlbWFudGljID09PSBzZW1hbnRpYykge1xuICAgICAgcmV0dXJuIGF0dHJpYnV0ZU5hbWU7XG4gICAgfVxuICB9KTtcbn1cblxuZnVuY3Rpb24gZW5zdXJlU2VtYW50aWNFeGlzdGVuY2VGb3JQcmltaXRpdmUoZ2x0ZiwgcHJpbWl0aXZlKSB7XG4gIHZhciBhY2Nlc3NvcnMgPSBnbHRmLmFjY2Vzc29ycztcbiAgdmFyIG1hdGVyaWFscyA9IGdsdGYubWF0ZXJpYWxzO1xuICB2YXIgdGVjaG5pcXVlc1dlYmdsID0gZ2x0Zi5leHRlbnNpb25zLktIUl90ZWNobmlxdWVzX3dlYmdsO1xuXG4gIHZhciB0ZWNobmlxdWVzID0gdGVjaG5pcXVlc1dlYmdsLnRlY2huaXF1ZXM7XG4gIHZhciBwcm9ncmFtcyA9IHRlY2huaXF1ZXNXZWJnbC5wcm9ncmFtcztcbiAgdmFyIHNoYWRlcnMgPSB0ZWNobmlxdWVzV2ViZ2wuc2hhZGVycztcbiAgdmFyIHRhcmdldHMgPSBwcmltaXRpdmUudGFyZ2V0cztcblxuICB2YXIgYXR0cmlidXRlcyA9IHByaW1pdGl2ZS5hdHRyaWJ1dGVzO1xuICBmb3IgKHZhciB0YXJnZXQgaW4gdGFyZ2V0cykge1xuICAgIGlmICh0YXJnZXRzLmhhc093blByb3BlcnR5KHRhcmdldCkpIHtcbiAgICAgIHZhciB0YXJnZXRBdHRyaWJ1dGVzID0gdGFyZ2V0c1t0YXJnZXRdO1xuICAgICAgZm9yICh2YXIgYXR0cmlidXRlIGluIHRhcmdldEF0dHJpYnV0ZXMpIHtcbiAgICAgICAgaWYgKGF0dHJpYnV0ZSAhPT0gXCJleHRyYXNcIikge1xuICAgICAgICAgIGF0dHJpYnV0ZXNbYXR0cmlidXRlICsgXCJfXCIgKyB0YXJnZXRdID0gdGFyZ2V0QXR0cmlidXRlc1thdHRyaWJ1dGVdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgdmFyIG1hdGVyaWFsID0gbWF0ZXJpYWxzW3ByaW1pdGl2ZS5tYXRlcmlhbF07XG4gIHZhciB0ZWNobmlxdWUgPVxuICAgIHRlY2huaXF1ZXNbbWF0ZXJpYWwuZXh0ZW5zaW9ucy5LSFJfdGVjaG5pcXVlc193ZWJnbC50ZWNobmlxdWVdO1xuICB2YXIgcHJvZ3JhbSA9IHByb2dyYW1zW3RlY2huaXF1ZS5wcm9ncmFtXTtcbiAgdmFyIHZlcnRleFNoYWRlciA9IHNoYWRlcnNbcHJvZ3JhbS52ZXJ0ZXhTaGFkZXJdO1xuXG4gIGZvciAodmFyIHNlbWFudGljIGluIGF0dHJpYnV0ZXMpIHtcbiAgICBpZiAoYXR0cmlidXRlcy5oYXNPd25Qcm9wZXJ0eShzZW1hbnRpYykpIHtcbiAgICAgIGlmICghZGVmaW5lZCh0ZWNobmlxdWVBdHRyaWJ1dGVGb3JTZW1hbnRpYyh0ZWNobmlxdWUsIHNlbWFudGljKSkpIHtcbiAgICAgICAgdmFyIGFjY2Vzc29ySWQgPSBhdHRyaWJ1dGVzW3NlbWFudGljXTtcbiAgICAgICAgdmFyIGFjY2Vzc29yID0gYWNjZXNzb3JzW2FjY2Vzc29ySWRdO1xuICAgICAgICB2YXIgbG93ZXJDYXNlID0gc2VtYW50aWMudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgaWYgKGxvd2VyQ2FzZS5jaGFyQXQoMCkgPT09IFwiX1wiKSB7XG4gICAgICAgICAgbG93ZXJDYXNlID0gbG93ZXJDYXNlLnNsaWNlKDEpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBhdHRyaWJ1dGVOYW1lID0gXCJhX1wiICsgbG93ZXJDYXNlO1xuICAgICAgICB0ZWNobmlxdWUuYXR0cmlidXRlc1thdHRyaWJ1dGVOYW1lXSA9IHtcbiAgICAgICAgICBzZW1hbnRpYzogc2VtYW50aWMsXG4gICAgICAgICAgdHlwZTogYWNjZXNzb3IuY29tcG9uZW50VHlwZSxcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIHBpcGVsaW5lRXh0cmFzID0gdmVydGV4U2hhZGVyLmV4dHJhcy5fcGlwZWxpbmU7XG4gICAgICAgIHZhciBzaGFkZXJUZXh0ID0gcGlwZWxpbmVFeHRyYXMuc291cmNlO1xuICAgICAgICBzaGFkZXJUZXh0ID1cbiAgICAgICAgICBcImF0dHJpYnV0ZSBcIiArXG4gICAgICAgICAgTW9kZWxVdGlsaXR5LmdldFNoYWRlclZhcmlhYmxlKGFjY2Vzc29yLnR5cGUpICtcbiAgICAgICAgICBcIiBcIiArXG4gICAgICAgICAgYXR0cmlidXRlTmFtZSArXG4gICAgICAgICAgXCI7XFxuXCIgK1xuICAgICAgICAgIHNoYWRlclRleHQ7XG4gICAgICAgIHBpcGVsaW5lRXh0cmFzLnNvdXJjZSA9IHNoYWRlclRleHQ7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogRW5zdXJlcyBhbGwgYXR0cmlidXRlcyBwcmVzZW50IG9uIHRoZSBwcmltaXRpdmUgYXJlIHByZXNlbnQgaW4gdGhlIHRlY2huaXF1ZSBhbmRcbiAqIHZlcnRleCBzaGFkZXIuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IGdsdGYgQSBqYXZhc2NyaXB0IG9iamVjdCBjb250YWluaW5nIGEgZ2xURiBhc3NldC5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFRoZSBnbFRGIGFzc2V0LCBpbmNsdWRpbmcgYW55IGFkZGl0aW9uYWwgYXR0cmlidXRlcy5cbiAqL1xuTW9kZWxVdGlsaXR5LmVuc3VyZVNlbWFudGljRXhpc3RlbmNlID0gZnVuY3Rpb24gKGdsdGYpIHtcbiAgRm9yRWFjaC5tZXNoKGdsdGYsIGZ1bmN0aW9uIChtZXNoKSB7XG4gICAgRm9yRWFjaC5tZXNoUHJpbWl0aXZlKG1lc2gsIGZ1bmN0aW9uIChwcmltaXRpdmUpIHtcbiAgICAgIGVuc3VyZVNlbWFudGljRXhpc3RlbmNlRm9yUHJpbWl0aXZlKGdsdGYsIHByaW1pdGl2ZSk7XG4gICAgfSk7XG4gIH0pO1xuXG4gIHJldHVybiBnbHRmO1xufTtcblxuLyoqXG4gKiBDcmVhdGVzIGF0dHJpYnV0ZSBsb2NhdGlvbiBmb3IgYWxsIGF0dHJpYnV0ZXMgcmVxdWlyZWQgYnkgYSB0ZWNobmlxdWUuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHRlY2huaXF1ZSBBIGdsVEYgS0hSX3RlY2huaXF1ZXNfd2ViZ2wgdGVjaG5pcXVlIG9iamVjdC5cbiAqIEBwYXJhbSB7T2JqZWN0fSBwcmVjcmVhdGVkQXR0cmlidXRlcyBBIGRpY3Rpb25hcnkgb2JqZWN0IG9mIHByZS1jcmVhdGVkIGF0dHJpYnV0ZXMgZm9yIHdoaWNoIHRvIGFsc28gY3JlYXRlIGxvY2F0aW9ucy5cbiAqIEByZXR1cm5zIHtPYmplY3R9IEEgZGljdGlvbmFyeSBvYmplY3QgY29udGFpbmluZyBhdHRyaWJ1dGUgbmFtZXMgYW5kIHRoZWlyIGxvY2F0aW9ucy5cbiAqL1xuTW9kZWxVdGlsaXR5LmNyZWF0ZUF0dHJpYnV0ZUxvY2F0aW9ucyA9IGZ1bmN0aW9uIChcbiAgdGVjaG5pcXVlLFxuICBwcmVjcmVhdGVkQXR0cmlidXRlc1xuKSB7XG4gIHZhciBhdHRyaWJ1dGVMb2NhdGlvbnMgPSB7fTtcbiAgdmFyIGhhc0luZGV4MCA9IGZhbHNlO1xuICB2YXIgaSA9IDE7XG5cbiAgRm9yRWFjaC50ZWNobmlxdWVBdHRyaWJ1dGUodGVjaG5pcXVlLCBmdW5jdGlvbiAoYXR0cmlidXRlLCBhdHRyaWJ1dGVOYW1lKSB7XG4gICAgLy8gU2V0IHRoZSBwb3NpdGlvbiBhdHRyaWJ1dGUgdG8gdGhlIDB0aCBpbmRleC4gSW4gc29tZSBXZWJHTCBpbXBsZW1lbnRhdGlvbnMgdGhlIHNoYWRlclxuICAgIC8vIHdpbGwgbm90IHdvcmsgY29ycmVjdGx5IGlmIHRoZSAwdGggYXR0cmlidXRlIGlzIG5vdCBhY3RpdmUuIEZvciBleGFtcGxlLCBzb21lIGdsVEYgbW9kZWxzXG4gICAgLy8gbGlzdCB0aGUgbm9ybWFsIGF0dHJpYnV0ZSBmaXJzdCBidXQgZGVyaXZlZCBzaGFkZXJzIGxpa2UgdGhlIGNhc3Qtc2hhZG93cyBzaGFkZXIgZG8gbm90IHVzZVxuICAgIC8vIHRoZSBub3JtYWwgYXR0cmlidXRlLlxuICAgIGlmICgvcG9zL2kudGVzdChhdHRyaWJ1dGVOYW1lKSAmJiAhaGFzSW5kZXgwKSB7XG4gICAgICBhdHRyaWJ1dGVMb2NhdGlvbnNbYXR0cmlidXRlTmFtZV0gPSAwO1xuICAgICAgaGFzSW5kZXgwID0gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgYXR0cmlidXRlTG9jYXRpb25zW2F0dHJpYnV0ZU5hbWVdID0gaSsrO1xuICAgIH1cbiAgfSk7XG5cbiAgaWYgKGRlZmluZWQocHJlY3JlYXRlZEF0dHJpYnV0ZXMpKSB7XG4gICAgZm9yICh2YXIgYXR0cmlidXRlTmFtZSBpbiBwcmVjcmVhdGVkQXR0cmlidXRlcykge1xuICAgICAgaWYgKHByZWNyZWF0ZWRBdHRyaWJ1dGVzLmhhc093blByb3BlcnR5KGF0dHJpYnV0ZU5hbWUpKSB7XG4gICAgICAgIGF0dHJpYnV0ZUxvY2F0aW9uc1thdHRyaWJ1dGVOYW1lXSA9IGkrKztcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gYXR0cmlidXRlTG9jYXRpb25zO1xufTtcblxuTW9kZWxVdGlsaXR5LmdldEFjY2Vzc29yTWluTWF4ID0gZnVuY3Rpb24gKGdsdGYsIGFjY2Vzc29ySWQpIHtcbiAgdmFyIGFjY2Vzc29yID0gZ2x0Zi5hY2Nlc3NvcnNbYWNjZXNzb3JJZF07XG4gIHZhciBleHRlbnNpb25zID0gYWNjZXNzb3IuZXh0ZW5zaW9ucztcbiAgdmFyIGFjY2Vzc29yTWluID0gYWNjZXNzb3IubWluO1xuICB2YXIgYWNjZXNzb3JNYXggPSBhY2Nlc3Nvci5tYXg7XG4gIC8vIElmIHRoaXMgYWNjZXNzb3IgaXMgcXVhbnRpemVkLCB3ZSBzaG91bGQgdXNlIHRoZSBkZWNvZGVkIG1pbiBhbmQgbWF4XG4gIGlmIChkZWZpbmVkKGV4dGVuc2lvbnMpKSB7XG4gICAgdmFyIHF1YW50aXplZEF0dHJpYnV0ZXMgPSBleHRlbnNpb25zLldFQjNEX3F1YW50aXplZF9hdHRyaWJ1dGVzO1xuICAgIGlmIChkZWZpbmVkKHF1YW50aXplZEF0dHJpYnV0ZXMpKSB7XG4gICAgICBhY2Nlc3Nvck1pbiA9IHF1YW50aXplZEF0dHJpYnV0ZXMuZGVjb2RlZE1pbjtcbiAgICAgIGFjY2Vzc29yTWF4ID0gcXVhbnRpemVkQXR0cmlidXRlcy5kZWNvZGVkTWF4O1xuICAgIH1cbiAgfVxuICByZXR1cm4ge1xuICAgIG1pbjogYWNjZXNzb3JNaW4sXG4gICAgbWF4OiBhY2Nlc3Nvck1heCxcbiAgfTtcbn07XG5cbmZ1bmN0aW9uIGdldFRlY2huaXF1ZUF0dHJpYnV0ZU9yVW5pZm9ybUZ1bmN0aW9uKFxuICBnbHRmLFxuICB0ZWNobmlxdWUsXG4gIHNlbWFudGljLFxuICBpZ25vcmVOb2Rlc1xuKSB7XG4gIGlmICh1c2VzRXh0ZW5zaW9uKGdsdGYsIFwiS0hSX3RlY2huaXF1ZXNfd2ViZ2xcIikpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGF0dHJpYnV0ZU9yVW5pZm9ybSwgYXR0cmlidXRlT3JVbmlmb3JtTmFtZSkge1xuICAgICAgaWYgKFxuICAgICAgICBhdHRyaWJ1dGVPclVuaWZvcm0uc2VtYW50aWMgPT09IHNlbWFudGljICYmXG4gICAgICAgICghaWdub3JlTm9kZXMgfHwgIWRlZmluZWQoYXR0cmlidXRlT3JVbmlmb3JtLm5vZGUpKVxuICAgICAgKSB7XG4gICAgICAgIHJldHVybiBhdHRyaWJ1dGVPclVuaWZvcm1OYW1lO1xuICAgICAgfVxuICAgIH07XG4gIH1cblxuICByZXR1cm4gZnVuY3Rpb24gKHBhcmFtZXRlck5hbWUsIGF0dHJpYnV0ZU9yVW5pZm9ybU5hbWUpIHtcbiAgICB2YXIgYXR0cmlidXRlT3JVbmlmb3JtID0gdGVjaG5pcXVlLnBhcmFtZXRlcnNbcGFyYW1ldGVyTmFtZV07XG4gICAgaWYgKFxuICAgICAgYXR0cmlidXRlT3JVbmlmb3JtLnNlbWFudGljID09PSBzZW1hbnRpYyAmJlxuICAgICAgKCFpZ25vcmVOb2RlcyB8fCAhZGVmaW5lZChhdHRyaWJ1dGVPclVuaWZvcm0ubm9kZSkpXG4gICAgKSB7XG4gICAgICByZXR1cm4gYXR0cmlidXRlT3JVbmlmb3JtTmFtZTtcbiAgICB9XG4gIH07XG59XG5cbk1vZGVsVXRpbGl0eS5nZXRBdHRyaWJ1dGVPclVuaWZvcm1CeVNlbWFudGljID0gZnVuY3Rpb24gKFxuICBnbHRmLFxuICBzZW1hbnRpYyxcbiAgcHJvZ3JhbUlkLFxuICBpZ25vcmVOb2Rlc1xuKSB7XG4gIHJldHVybiBGb3JFYWNoLnRlY2huaXF1ZShnbHRmLCBmdW5jdGlvbiAodGVjaG5pcXVlKSB7XG4gICAgaWYgKGRlZmluZWQocHJvZ3JhbUlkKSAmJiB0ZWNobmlxdWUucHJvZ3JhbSAhPT0gcHJvZ3JhbUlkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIHZhbHVlID0gRm9yRWFjaC50ZWNobmlxdWVBdHRyaWJ1dGUoXG4gICAgICB0ZWNobmlxdWUsXG4gICAgICBnZXRUZWNobmlxdWVBdHRyaWJ1dGVPclVuaWZvcm1GdW5jdGlvbihcbiAgICAgICAgZ2x0ZixcbiAgICAgICAgdGVjaG5pcXVlLFxuICAgICAgICBzZW1hbnRpYyxcbiAgICAgICAgaWdub3JlTm9kZXNcbiAgICAgIClcbiAgICApO1xuXG4gICAgaWYgKGRlZmluZWQodmFsdWUpKSB7XG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuXG4gICAgcmV0dXJuIEZvckVhY2gudGVjaG5pcXVlVW5pZm9ybShcbiAgICAgIHRlY2huaXF1ZSxcbiAgICAgIGdldFRlY2huaXF1ZUF0dHJpYnV0ZU9yVW5pZm9ybUZ1bmN0aW9uKFxuICAgICAgICBnbHRmLFxuICAgICAgICB0ZWNobmlxdWUsXG4gICAgICAgIHNlbWFudGljLFxuICAgICAgICBpZ25vcmVOb2Rlc1xuICAgICAgKVxuICAgICk7XG4gIH0pO1xufTtcblxuTW9kZWxVdGlsaXR5LmdldERpZmZ1c2VBdHRyaWJ1dGVPclVuaWZvcm0gPSBmdW5jdGlvbiAoZ2x0ZiwgcHJvZ3JhbUlkKSB7XG4gIHZhciBkaWZmdXNlVW5pZm9ybU5hbWUgPSBNb2RlbFV0aWxpdHkuZ2V0QXR0cmlidXRlT3JVbmlmb3JtQnlTZW1hbnRpYyhcbiAgICBnbHRmLFxuICAgIFwiQ09MT1JfMFwiLFxuICAgIHByb2dyYW1JZFxuICApO1xuICBpZiAoIWRlZmluZWQoZGlmZnVzZVVuaWZvcm1OYW1lKSkge1xuICAgIGRpZmZ1c2VVbmlmb3JtTmFtZSA9IE1vZGVsVXRpbGl0eS5nZXRBdHRyaWJ1dGVPclVuaWZvcm1CeVNlbWFudGljKFxuICAgICAgZ2x0ZixcbiAgICAgIFwiXzNEVElMRVNESUZGVVNFXCIsXG4gICAgICBwcm9ncmFtSWRcbiAgICApO1xuICB9XG4gIHJldHVybiBkaWZmdXNlVW5pZm9ybU5hbWU7XG59O1xuXG52YXIgbm9kZVRyYW5zbGF0aW9uU2NyYXRjaCA9IG5ldyBDYXJ0ZXNpYW4zKCk7XG52YXIgbm9kZVF1YXRlcm5pb25TY3JhdGNoID0gbmV3IFF1YXRlcm5pb24oKTtcbnZhciBub2RlU2NhbGVTY3JhdGNoID0gbmV3IENhcnRlc2lhbjMoKTtcblxuTW9kZWxVdGlsaXR5LmdldFRyYW5zZm9ybSA9IGZ1bmN0aW9uIChub2RlLCByZXN1bHQpIHtcbiAgaWYgKGRlZmluZWQobm9kZS5tYXRyaXgpKSB7XG4gICAgcmV0dXJuIE1hdHJpeDQuZnJvbUNvbHVtbk1ham9yQXJyYXkobm9kZS5tYXRyaXgsIHJlc3VsdCk7XG4gIH1cblxuICByZXR1cm4gTWF0cml4NC5mcm9tVHJhbnNsYXRpb25RdWF0ZXJuaW9uUm90YXRpb25TY2FsZShcbiAgICBDYXJ0ZXNpYW4zLmZyb21BcnJheShub2RlLnRyYW5zbGF0aW9uLCAwLCBub2RlVHJhbnNsYXRpb25TY3JhdGNoKSxcbiAgICBRdWF0ZXJuaW9uLnVucGFjayhub2RlLnJvdGF0aW9uLCAwLCBub2RlUXVhdGVybmlvblNjcmF0Y2gpLFxuICAgIENhcnRlc2lhbjMuZnJvbUFycmF5KG5vZGUuc2NhbGUsIDAsIG5vZGVTY2FsZVNjcmF0Y2gpLFxuICAgIHJlc3VsdFxuICApO1xufTtcblxuTW9kZWxVdGlsaXR5LmdldFVzZWRFeHRlbnNpb25zID0gZnVuY3Rpb24gKGdsdGYpIHtcbiAgdmFyIGV4dGVuc2lvbnNVc2VkID0gZ2x0Zi5leHRlbnNpb25zVXNlZDtcbiAgdmFyIGNhY2hlZEV4dGVuc2lvbnNVc2VkID0ge307XG5cbiAgaWYgKGRlZmluZWQoZXh0ZW5zaW9uc1VzZWQpKSB7XG4gICAgdmFyIGV4dGVuc2lvbnNVc2VkTGVuZ3RoID0gZXh0ZW5zaW9uc1VzZWQubGVuZ3RoO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZXh0ZW5zaW9uc1VzZWRMZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGV4dGVuc2lvbiA9IGV4dGVuc2lvbnNVc2VkW2ldO1xuICAgICAgY2FjaGVkRXh0ZW5zaW9uc1VzZWRbZXh0ZW5zaW9uXSA9IHRydWU7XG4gICAgfVxuICB9XG4gIHJldHVybiBjYWNoZWRFeHRlbnNpb25zVXNlZDtcbn07XG5cbk1vZGVsVXRpbGl0eS5nZXRSZXF1aXJlZEV4dGVuc2lvbnMgPSBmdW5jdGlvbiAoZ2x0Zikge1xuICB2YXIgZXh0ZW5zaW9uc1JlcXVpcmVkID0gZ2x0Zi5leHRlbnNpb25zUmVxdWlyZWQ7XG4gIHZhciBjYWNoZWRFeHRlbnNpb25zUmVxdWlyZWQgPSB7fTtcblxuICBpZiAoZGVmaW5lZChleHRlbnNpb25zUmVxdWlyZWQpKSB7XG4gICAgdmFyIGV4dGVuc2lvbnNSZXF1aXJlZExlbmd0aCA9IGV4dGVuc2lvbnNSZXF1aXJlZC5sZW5ndGg7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBleHRlbnNpb25zUmVxdWlyZWRMZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGV4dGVuc2lvbiA9IGV4dGVuc2lvbnNSZXF1aXJlZFtpXTtcbiAgICAgIGNhY2hlZEV4dGVuc2lvbnNSZXF1aXJlZFtleHRlbnNpb25dID0gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gY2FjaGVkRXh0ZW5zaW9uc1JlcXVpcmVkO1xufTtcblxuTW9kZWxVdGlsaXR5LnN1cHBvcnRlZEV4dGVuc2lvbnMgPSB7XG4gIEFHSV9hcnRpY3VsYXRpb25zOiB0cnVlLFxuICBDRVNJVU1fUlRDOiB0cnVlLFxuICBFWFRfdGV4dHVyZV93ZWJwOiB0cnVlLFxuICBLSFJfYmxlbmQ6IHRydWUsXG4gIEtIUl9iaW5hcnlfZ2xURjogdHJ1ZSxcbiAgS0hSX3RleHR1cmVfYmFzaXN1OiB0cnVlLFxuICBLSFJfZHJhY29fbWVzaF9jb21wcmVzc2lvbjogdHJ1ZSxcbiAgS0hSX21hdGVyaWFsc19jb21tb246IHRydWUsXG4gIEtIUl90ZWNobmlxdWVzX3dlYmdsOiB0cnVlLFxuICBLSFJfbWF0ZXJpYWxzX3VubGl0OiB0cnVlLFxuICBLSFJfbWF0ZXJpYWxzX3BiclNwZWN1bGFyR2xvc3NpbmVzczogdHJ1ZSxcbiAgS0hSX3RleHR1cmVfdHJhbnNmb3JtOiB0cnVlLFxuICBXRUIzRF9xdWFudGl6ZWRfYXR0cmlidXRlczogdHJ1ZSxcbn07XG5cbk1vZGVsVXRpbGl0eS5jaGVja1N1cHBvcnRlZEV4dGVuc2lvbnMgPSBmdW5jdGlvbiAoXG4gIGV4dGVuc2lvbnNSZXF1aXJlZCxcbiAgYnJvd3NlclN1cHBvcnRzV2VicFxuKSB7XG4gIGZvciAodmFyIGV4dGVuc2lvbiBpbiBleHRlbnNpb25zUmVxdWlyZWQpIHtcbiAgICBpZiAoZXh0ZW5zaW9uc1JlcXVpcmVkLmhhc093blByb3BlcnR5KGV4dGVuc2lvbikpIHtcbiAgICAgIGlmICghTW9kZWxVdGlsaXR5LnN1cHBvcnRlZEV4dGVuc2lvbnNbZXh0ZW5zaW9uXSkge1xuICAgICAgICB0aHJvdyBuZXcgUnVudGltZUVycm9yKFwiVW5zdXBwb3J0ZWQgZ2xURiBFeHRlbnNpb246IFwiICsgZXh0ZW5zaW9uKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGV4dGVuc2lvbiA9PT0gXCJFWFRfdGV4dHVyZV93ZWJwXCIgJiYgYnJvd3NlclN1cHBvcnRzV2VicCA9PT0gZmFsc2UpIHtcbiAgICAgICAgdGhyb3cgbmV3IFJ1bnRpbWVFcnJvcihcbiAgICAgICAgICBcIkxvYWRlZCBtb2RlbCByZXF1aXJlcyBXZWJQIGJ1dCBicm93c2VyIGRvZXMgbm90IHN1cHBvcnQgaXQuXCJcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn07XG5cbk1vZGVsVXRpbGl0eS5jaGVja1N1cHBvcnRlZEdsRXh0ZW5zaW9ucyA9IGZ1bmN0aW9uIChleHRlbnNpb25zVXNlZCwgY29udGV4dCkge1xuICBpZiAoZGVmaW5lZChleHRlbnNpb25zVXNlZCkpIHtcbiAgICB2YXIgZ2xFeHRlbnNpb25zVXNlZExlbmd0aCA9IGV4dGVuc2lvbnNVc2VkLmxlbmd0aDtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGdsRXh0ZW5zaW9uc1VzZWRMZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGV4dGVuc2lvbiA9IGV4dGVuc2lvbnNVc2VkW2ldO1xuICAgICAgaWYgKGV4dGVuc2lvbiAhPT0gXCJPRVNfZWxlbWVudF9pbmRleF91aW50XCIpIHtcbiAgICAgICAgdGhyb3cgbmV3IFJ1bnRpbWVFcnJvcihcIlVuc3VwcG9ydGVkIFdlYkdMIEV4dGVuc2lvbjogXCIgKyBleHRlbnNpb24pO1xuICAgICAgfSBlbHNlIGlmICghY29udGV4dC5lbGVtZW50SW5kZXhVaW50KSB7XG4gICAgICAgIHRocm93IG5ldyBSdW50aW1lRXJyb3IoXG4gICAgICAgICAgXCJPRVNfZWxlbWVudF9pbmRleF91aW50IFdlYkdMIGV4dGVuc2lvbiBpcyBub3QgZW5hYmxlZC5cIlxuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cbiAgfVxufTtcblxuZnVuY3Rpb24gcmVwbGFjZUFsbEJ1dEZpcnN0SW5TdHJpbmcoc3RyaW5nLCBmaW5kLCByZXBsYWNlKSB7XG4gIC8vIExpbWl0IHNlYXJjaCB0byBzdHJpbmdzIHRoYXQgYXJlIG5vdCBhIHN1YnNldCBvZiBvdGhlciB0b2tlbnMuXG4gIGZpbmQgKz0gXCIoPyFcXFxcdylcIjtcbiAgZmluZCA9IG5ldyBSZWdFeHAoZmluZCwgXCJnXCIpO1xuXG4gIHZhciBpbmRleCA9IHN0cmluZy5zZWFyY2goZmluZCk7XG4gIHJldHVybiBzdHJpbmcucmVwbGFjZShmaW5kLCBmdW5jdGlvbiAobWF0Y2gsIG9mZnNldCkge1xuICAgIHJldHVybiBpbmRleCA9PT0gb2Zmc2V0ID8gbWF0Y2ggOiByZXBsYWNlO1xuICB9KTtcbn1cblxuZnVuY3Rpb24gZ2V0UXVhbnRpemVkQXR0cmlidXRlcyhnbHRmLCBhY2Nlc3NvcklkKSB7XG4gIHZhciBhY2Nlc3NvciA9IGdsdGYuYWNjZXNzb3JzW2FjY2Vzc29ySWRdO1xuICB2YXIgZXh0ZW5zaW9ucyA9IGFjY2Vzc29yLmV4dGVuc2lvbnM7XG4gIGlmIChkZWZpbmVkKGV4dGVuc2lvbnMpKSB7XG4gICAgcmV0dXJuIGV4dGVuc2lvbnMuV0VCM0RfcXVhbnRpemVkX2F0dHJpYnV0ZXM7XG4gIH1cbiAgcmV0dXJuIHVuZGVmaW5lZDtcbn1cblxuZnVuY3Rpb24gZ2V0QXR0cmlidXRlVmFyaWFibGVOYW1lKGdsdGYsIHByaW1pdGl2ZSwgYXR0cmlidXRlU2VtYW50aWMpIHtcbiAgdmFyIG1hdGVyaWFsSWQgPSBwcmltaXRpdmUubWF0ZXJpYWw7XG4gIHZhciBtYXRlcmlhbCA9IGdsdGYubWF0ZXJpYWxzW21hdGVyaWFsSWRdO1xuXG4gIGlmIChcbiAgICAhdXNlc0V4dGVuc2lvbihnbHRmLCBcIktIUl90ZWNobmlxdWVzX3dlYmdsXCIpIHx8XG4gICAgIWRlZmluZWQobWF0ZXJpYWwuZXh0ZW5zaW9ucykgfHxcbiAgICAhZGVmaW5lZChtYXRlcmlhbC5leHRlbnNpb25zLktIUl90ZWNobmlxdWVzX3dlYmdsKVxuICApIHtcbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgdGVjaG5pcXVlSWQgPSBtYXRlcmlhbC5leHRlbnNpb25zLktIUl90ZWNobmlxdWVzX3dlYmdsLnRlY2huaXF1ZTtcbiAgdmFyIHRlY2huaXF1ZXNXZWJnbCA9IGdsdGYuZXh0ZW5zaW9ucy5LSFJfdGVjaG5pcXVlc193ZWJnbDtcbiAgdmFyIHRlY2huaXF1ZSA9IHRlY2huaXF1ZXNXZWJnbC50ZWNobmlxdWVzW3RlY2huaXF1ZUlkXTtcbiAgcmV0dXJuIEZvckVhY2gudGVjaG5pcXVlQXR0cmlidXRlKHRlY2huaXF1ZSwgZnVuY3Rpb24gKFxuICAgIGF0dHJpYnV0ZSxcbiAgICBhdHRyaWJ1dGVOYW1lXG4gICkge1xuICAgIHZhciBzZW1hbnRpYyA9IGF0dHJpYnV0ZS5zZW1hbnRpYztcbiAgICBpZiAoc2VtYW50aWMgPT09IGF0dHJpYnV0ZVNlbWFudGljKSB7XG4gICAgICByZXR1cm4gYXR0cmlidXRlTmFtZTtcbiAgICB9XG4gIH0pO1xufVxuXG5Nb2RlbFV0aWxpdHkubW9kaWZ5U2hhZGVyRm9yRHJhY29RdWFudGl6ZWRBdHRyaWJ1dGVzID0gZnVuY3Rpb24gKFxuICBnbHRmLFxuICBwcmltaXRpdmUsXG4gIHNoYWRlcixcbiAgZGVjb2RlZEF0dHJpYnV0ZXNcbikge1xuICB2YXIgcXVhbnRpemVkVW5pZm9ybXMgPSB7fTtcbiAgZm9yICh2YXIgYXR0cmlidXRlU2VtYW50aWMgaW4gZGVjb2RlZEF0dHJpYnV0ZXMpIHtcbiAgICBpZiAoZGVjb2RlZEF0dHJpYnV0ZXMuaGFzT3duUHJvcGVydHkoYXR0cmlidXRlU2VtYW50aWMpKSB7XG4gICAgICB2YXIgYXR0cmlidXRlID0gZGVjb2RlZEF0dHJpYnV0ZXNbYXR0cmlidXRlU2VtYW50aWNdO1xuICAgICAgdmFyIHF1YW50aXphdGlvbiA9IGF0dHJpYnV0ZS5xdWFudGl6YXRpb247XG4gICAgICBpZiAoIWRlZmluZWQocXVhbnRpemF0aW9uKSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgdmFyIGF0dHJpYnV0ZVZhck5hbWUgPSBnZXRBdHRyaWJ1dGVWYXJpYWJsZU5hbWUoXG4gICAgICAgIGdsdGYsXG4gICAgICAgIHByaW1pdGl2ZSxcbiAgICAgICAgYXR0cmlidXRlU2VtYW50aWNcbiAgICAgICk7XG5cbiAgICAgIGlmIChhdHRyaWJ1dGVTZW1hbnRpYy5jaGFyQXQoMCkgPT09IFwiX1wiKSB7XG4gICAgICAgIGF0dHJpYnV0ZVNlbWFudGljID0gYXR0cmlidXRlU2VtYW50aWMuc3Vic3RyaW5nKDEpO1xuICAgICAgfVxuICAgICAgdmFyIGRlY29kZVVuaWZvcm1WYXJOYW1lID1cbiAgICAgICAgXCJnbHRmX3VfZGVjX1wiICsgYXR0cmlidXRlU2VtYW50aWMudG9Mb3dlckNhc2UoKTtcblxuICAgICAgaWYgKCFkZWZpbmVkKHF1YW50aXplZFVuaWZvcm1zW2RlY29kZVVuaWZvcm1WYXJOYW1lXSkpIHtcbiAgICAgICAgdmFyIG5ld01haW4gPSBcImdsdGZfZGVjb2RlZF9cIiArIGF0dHJpYnV0ZVNlbWFudGljO1xuICAgICAgICB2YXIgZGVjb2RlZEF0dHJpYnV0ZVZhck5hbWUgPSBhdHRyaWJ1dGVWYXJOYW1lLnJlcGxhY2UoXG4gICAgICAgICAgXCJhX1wiLFxuICAgICAgICAgIFwiZ2x0Zl9hX2RlY19cIlxuICAgICAgICApO1xuICAgICAgICB2YXIgc2l6ZSA9IGF0dHJpYnV0ZS5jb21wb25lbnRzUGVyQXR0cmlidXRlO1xuXG4gICAgICAgIC8vIHJlcGxhY2UgdXNhZ2VzIG9mIHRoZSBvcmlnaW5hbCBhdHRyaWJ1dGUgd2l0aCB0aGUgZGVjb2RlZCB2ZXJzaW9uLCBidXQgbm90IHRoZSBkZWNsYXJhdGlvblxuICAgICAgICBzaGFkZXIgPSByZXBsYWNlQWxsQnV0Rmlyc3RJblN0cmluZyhcbiAgICAgICAgICBzaGFkZXIsXG4gICAgICAgICAgYXR0cmlidXRlVmFyTmFtZSxcbiAgICAgICAgICBkZWNvZGVkQXR0cmlidXRlVmFyTmFtZVxuICAgICAgICApO1xuXG4gICAgICAgIC8vIGRlY2xhcmUgZGVjb2RlZCBhdHRyaWJ1dGVcbiAgICAgICAgdmFyIHZhcmlhYmxlVHlwZTtcbiAgICAgICAgaWYgKHF1YW50aXphdGlvbi5vY3RFbmNvZGVkKSB7XG4gICAgICAgICAgdmFyaWFibGVUeXBlID0gXCJ2ZWMzXCI7XG4gICAgICAgIH0gZWxzZSBpZiAoc2l6ZSA+IDEpIHtcbiAgICAgICAgICB2YXJpYWJsZVR5cGUgPSBcInZlY1wiICsgc2l6ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YXJpYWJsZVR5cGUgPSBcImZsb2F0XCI7XG4gICAgICAgIH1cbiAgICAgICAgc2hhZGVyID0gdmFyaWFibGVUeXBlICsgXCIgXCIgKyBkZWNvZGVkQXR0cmlidXRlVmFyTmFtZSArIFwiO1xcblwiICsgc2hhZGVyO1xuXG4gICAgICAgIC8vIFRoZSBnbHRmIDIuMCBDT0xPUl8wIHZlcnRleCBhdHRyaWJ1dGUgY2FuIGJlIFZFQzQgb3IgVkVDM1xuICAgICAgICB2YXIgdmVjM0NvbG9yID0gc2l6ZSA9PT0gMyAmJiBhdHRyaWJ1dGVTZW1hbnRpYyA9PT0gXCJDT0xPUl8wXCI7XG4gICAgICAgIGlmICh2ZWMzQ29sb3IpIHtcbiAgICAgICAgICBzaGFkZXIgPSByZXBsYWNlQWxsQnV0Rmlyc3RJblN0cmluZyhcbiAgICAgICAgICAgIHNoYWRlcixcbiAgICAgICAgICAgIGRlY29kZWRBdHRyaWJ1dGVWYXJOYW1lLFxuICAgICAgICAgICAgXCJ2ZWM0KFwiICsgZGVjb2RlZEF0dHJpYnV0ZVZhck5hbWUgKyBcIiwgMS4wKVwiXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHNwbGljZSBkZWNvZGUgZnVuY3Rpb24gaW50byB0aGUgc2hhZGVyXG4gICAgICAgIHZhciBkZWNvZGUgPSBcIlwiO1xuICAgICAgICBpZiAocXVhbnRpemF0aW9uLm9jdEVuY29kZWQpIHtcbiAgICAgICAgICB2YXIgZGVjb2RlVW5pZm9ybVZhck5hbWVSYW5nZUNvbnN0YW50ID1cbiAgICAgICAgICAgIGRlY29kZVVuaWZvcm1WYXJOYW1lICsgXCJfcmFuZ2VDb25zdGFudFwiO1xuICAgICAgICAgIHNoYWRlciA9XG4gICAgICAgICAgICBcInVuaWZvcm0gZmxvYXQgXCIgK1xuICAgICAgICAgICAgZGVjb2RlVW5pZm9ybVZhck5hbWVSYW5nZUNvbnN0YW50ICtcbiAgICAgICAgICAgIFwiO1xcblwiICtcbiAgICAgICAgICAgIHNoYWRlcjtcbiAgICAgICAgICBkZWNvZGUgPVxuICAgICAgICAgICAgXCJcXG5cIiArXG4gICAgICAgICAgICBcInZvaWQgbWFpbigpIHtcXG5cIiArXG4gICAgICAgICAgICAvLyBEcmFjbyBvY3QtZW5jb2RpbmcgZGVjb2RlcyB0byB6eHkgb3JkZXJcbiAgICAgICAgICAgIFwiICAgIFwiICtcbiAgICAgICAgICAgIGRlY29kZWRBdHRyaWJ1dGVWYXJOYW1lICtcbiAgICAgICAgICAgIFwiID0gY3ptX29jdERlY29kZShcIiArXG4gICAgICAgICAgICBhdHRyaWJ1dGVWYXJOYW1lICtcbiAgICAgICAgICAgIFwiLnh5LCBcIiArXG4gICAgICAgICAgICBkZWNvZGVVbmlmb3JtVmFyTmFtZVJhbmdlQ29uc3RhbnQgK1xuICAgICAgICAgICAgXCIpLnp4eTtcXG5cIiArXG4gICAgICAgICAgICBcIiAgICBcIiArXG4gICAgICAgICAgICBuZXdNYWluICtcbiAgICAgICAgICAgIFwiKCk7XFxuXCIgK1xuICAgICAgICAgICAgXCJ9XFxuXCI7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIGRlY29kZVVuaWZvcm1WYXJOYW1lTm9ybUNvbnN0YW50ID1cbiAgICAgICAgICAgIGRlY29kZVVuaWZvcm1WYXJOYW1lICsgXCJfbm9ybUNvbnN0YW50XCI7XG4gICAgICAgICAgdmFyIGRlY29kZVVuaWZvcm1WYXJOYW1lTWluID0gZGVjb2RlVW5pZm9ybVZhck5hbWUgKyBcIl9taW5cIjtcbiAgICAgICAgICBzaGFkZXIgPVxuICAgICAgICAgICAgXCJ1bmlmb3JtIGZsb2F0IFwiICtcbiAgICAgICAgICAgIGRlY29kZVVuaWZvcm1WYXJOYW1lTm9ybUNvbnN0YW50ICtcbiAgICAgICAgICAgIFwiO1xcblwiICtcbiAgICAgICAgICAgIFwidW5pZm9ybSBcIiArXG4gICAgICAgICAgICB2YXJpYWJsZVR5cGUgK1xuICAgICAgICAgICAgXCIgXCIgK1xuICAgICAgICAgICAgZGVjb2RlVW5pZm9ybVZhck5hbWVNaW4gK1xuICAgICAgICAgICAgXCI7XFxuXCIgK1xuICAgICAgICAgICAgc2hhZGVyO1xuICAgICAgICAgIHZhciBhdHRyaWJ1dGVWYXJBY2Nlc3MgPSB2ZWMzQ29sb3IgPyBcIi54eXpcIiA6IFwiXCI7XG4gICAgICAgICAgZGVjb2RlID1cbiAgICAgICAgICAgIFwiXFxuXCIgK1xuICAgICAgICAgICAgXCJ2b2lkIG1haW4oKSB7XFxuXCIgK1xuICAgICAgICAgICAgXCIgICAgXCIgK1xuICAgICAgICAgICAgZGVjb2RlZEF0dHJpYnV0ZVZhck5hbWUgK1xuICAgICAgICAgICAgXCIgPSBcIiArXG4gICAgICAgICAgICBkZWNvZGVVbmlmb3JtVmFyTmFtZU1pbiArXG4gICAgICAgICAgICBcIiArIFwiICtcbiAgICAgICAgICAgIGF0dHJpYnV0ZVZhck5hbWUgK1xuICAgICAgICAgICAgYXR0cmlidXRlVmFyQWNjZXNzICtcbiAgICAgICAgICAgIFwiICogXCIgK1xuICAgICAgICAgICAgZGVjb2RlVW5pZm9ybVZhck5hbWVOb3JtQ29uc3RhbnQgK1xuICAgICAgICAgICAgXCI7XFxuXCIgK1xuICAgICAgICAgICAgXCIgICAgXCIgK1xuICAgICAgICAgICAgbmV3TWFpbiArXG4gICAgICAgICAgICBcIigpO1xcblwiICtcbiAgICAgICAgICAgIFwifVxcblwiO1xuICAgICAgICB9XG5cbiAgICAgICAgc2hhZGVyID0gU2hhZGVyU291cmNlLnJlcGxhY2VNYWluKHNoYWRlciwgbmV3TWFpbik7XG4gICAgICAgIHNoYWRlciArPSBkZWNvZGU7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiB7XG4gICAgc2hhZGVyOiBzaGFkZXIsXG4gIH07XG59O1xuXG5Nb2RlbFV0aWxpdHkubW9kaWZ5U2hhZGVyRm9yUXVhbnRpemVkQXR0cmlidXRlcyA9IGZ1bmN0aW9uIChcbiAgZ2x0ZixcbiAgcHJpbWl0aXZlLFxuICBzaGFkZXJcbikge1xuICB2YXIgcXVhbnRpemVkVW5pZm9ybXMgPSB7fTtcbiAgdmFyIGF0dHJpYnV0ZXMgPSBwcmltaXRpdmUuYXR0cmlidXRlcztcbiAgZm9yICh2YXIgYXR0cmlidXRlU2VtYW50aWMgaW4gYXR0cmlidXRlcykge1xuICAgIGlmIChhdHRyaWJ1dGVzLmhhc093blByb3BlcnR5KGF0dHJpYnV0ZVNlbWFudGljKSkge1xuICAgICAgdmFyIGF0dHJpYnV0ZVZhck5hbWUgPSBnZXRBdHRyaWJ1dGVWYXJpYWJsZU5hbWUoXG4gICAgICAgIGdsdGYsXG4gICAgICAgIHByaW1pdGl2ZSxcbiAgICAgICAgYXR0cmlidXRlU2VtYW50aWNcbiAgICAgICk7XG4gICAgICB2YXIgYWNjZXNzb3JJZCA9IHByaW1pdGl2ZS5hdHRyaWJ1dGVzW2F0dHJpYnV0ZVNlbWFudGljXTtcblxuICAgICAgaWYgKGF0dHJpYnV0ZVNlbWFudGljLmNoYXJBdCgwKSA9PT0gXCJfXCIpIHtcbiAgICAgICAgYXR0cmlidXRlU2VtYW50aWMgPSBhdHRyaWJ1dGVTZW1hbnRpYy5zdWJzdHJpbmcoMSk7XG4gICAgICB9XG4gICAgICB2YXIgZGVjb2RlVW5pZm9ybVZhck5hbWUgPVxuICAgICAgICBcImdsdGZfdV9kZWNfXCIgKyBhdHRyaWJ1dGVTZW1hbnRpYy50b0xvd2VyQ2FzZSgpO1xuXG4gICAgICB2YXIgZGVjb2RlVW5pZm9ybVZhck5hbWVTY2FsZSA9IGRlY29kZVVuaWZvcm1WYXJOYW1lICsgXCJfc2NhbGVcIjtcbiAgICAgIHZhciBkZWNvZGVVbmlmb3JtVmFyTmFtZVRyYW5zbGF0ZSA9IGRlY29kZVVuaWZvcm1WYXJOYW1lICsgXCJfdHJhbnNsYXRlXCI7XG4gICAgICBpZiAoXG4gICAgICAgICFkZWZpbmVkKHF1YW50aXplZFVuaWZvcm1zW2RlY29kZVVuaWZvcm1WYXJOYW1lXSkgJiZcbiAgICAgICAgIWRlZmluZWQocXVhbnRpemVkVW5pZm9ybXNbZGVjb2RlVW5pZm9ybVZhck5hbWVTY2FsZV0pXG4gICAgICApIHtcbiAgICAgICAgdmFyIHF1YW50aXplZEF0dHJpYnV0ZXMgPSBnZXRRdWFudGl6ZWRBdHRyaWJ1dGVzKGdsdGYsIGFjY2Vzc29ySWQpO1xuICAgICAgICBpZiAoZGVmaW5lZChxdWFudGl6ZWRBdHRyaWJ1dGVzKSkge1xuICAgICAgICAgIHZhciBkZWNvZGVNYXRyaXggPSBxdWFudGl6ZWRBdHRyaWJ1dGVzLmRlY29kZU1hdHJpeDtcbiAgICAgICAgICB2YXIgbmV3TWFpbiA9IFwiZ2x0Zl9kZWNvZGVkX1wiICsgYXR0cmlidXRlU2VtYW50aWM7XG4gICAgICAgICAgdmFyIGRlY29kZWRBdHRyaWJ1dGVWYXJOYW1lID0gYXR0cmlidXRlVmFyTmFtZS5yZXBsYWNlKFxuICAgICAgICAgICAgXCJhX1wiLFxuICAgICAgICAgICAgXCJnbHRmX2FfZGVjX1wiXG4gICAgICAgICAgKTtcbiAgICAgICAgICB2YXIgc2l6ZSA9IE1hdGguZmxvb3IoTWF0aC5zcXJ0KGRlY29kZU1hdHJpeC5sZW5ndGgpKTtcblxuICAgICAgICAgIC8vIHJlcGxhY2UgdXNhZ2VzIG9mIHRoZSBvcmlnaW5hbCBhdHRyaWJ1dGUgd2l0aCB0aGUgZGVjb2RlZCB2ZXJzaW9uLCBidXQgbm90IHRoZSBkZWNsYXJhdGlvblxuICAgICAgICAgIHNoYWRlciA9IHJlcGxhY2VBbGxCdXRGaXJzdEluU3RyaW5nKFxuICAgICAgICAgICAgc2hhZGVyLFxuICAgICAgICAgICAgYXR0cmlidXRlVmFyTmFtZSxcbiAgICAgICAgICAgIGRlY29kZWRBdHRyaWJ1dGVWYXJOYW1lXG4gICAgICAgICAgKTtcbiAgICAgICAgICAvLyBkZWNsYXJlIGRlY29kZWQgYXR0cmlidXRlXG4gICAgICAgICAgdmFyIHZhcmlhYmxlVHlwZTtcbiAgICAgICAgICBpZiAoc2l6ZSA+IDIpIHtcbiAgICAgICAgICAgIHZhcmlhYmxlVHlwZSA9IFwidmVjXCIgKyAoc2l6ZSAtIDEpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YXJpYWJsZVR5cGUgPSBcImZsb2F0XCI7XG4gICAgICAgICAgfVxuICAgICAgICAgIHNoYWRlciA9XG4gICAgICAgICAgICB2YXJpYWJsZVR5cGUgKyBcIiBcIiArIGRlY29kZWRBdHRyaWJ1dGVWYXJOYW1lICsgXCI7XFxuXCIgKyBzaGFkZXI7XG4gICAgICAgICAgLy8gc3BsaWNlIGRlY29kZSBmdW5jdGlvbiBpbnRvIHRoZSBzaGFkZXIgLSBhdHRyaWJ1dGVzIGFyZSBwcmUtbXVsdGlwbGllZCB3aXRoIHRoZSBkZWNvZGUgbWF0cml4XG4gICAgICAgICAgLy8gdW5pZm9ybSBpbiB0aGUgc2hhZGVyICgzMi1iaXQgZmxvYXRpbmcgcG9pbnQpXG4gICAgICAgICAgdmFyIGRlY29kZSA9IFwiXCI7XG4gICAgICAgICAgaWYgKHNpemUgPT09IDUpIHtcbiAgICAgICAgICAgIC8vIHNlcGFyYXRlIHNjYWxlIGFuZCB0cmFuc2xhdGUgc2luY2UgZ2xzbCBkb2Vzbid0IGhhdmUgbWF0NVxuICAgICAgICAgICAgc2hhZGVyID1cbiAgICAgICAgICAgICAgXCJ1bmlmb3JtIG1hdDQgXCIgKyBkZWNvZGVVbmlmb3JtVmFyTmFtZVNjYWxlICsgXCI7XFxuXCIgKyBzaGFkZXI7XG4gICAgICAgICAgICBzaGFkZXIgPVxuICAgICAgICAgICAgICBcInVuaWZvcm0gdmVjNCBcIiArIGRlY29kZVVuaWZvcm1WYXJOYW1lVHJhbnNsYXRlICsgXCI7XFxuXCIgKyBzaGFkZXI7XG4gICAgICAgICAgICBkZWNvZGUgPVxuICAgICAgICAgICAgICBcIlxcblwiICtcbiAgICAgICAgICAgICAgXCJ2b2lkIG1haW4oKSB7XFxuXCIgK1xuICAgICAgICAgICAgICBcIiAgICBcIiArXG4gICAgICAgICAgICAgIGRlY29kZWRBdHRyaWJ1dGVWYXJOYW1lICtcbiAgICAgICAgICAgICAgXCIgPSBcIiArXG4gICAgICAgICAgICAgIGRlY29kZVVuaWZvcm1WYXJOYW1lU2NhbGUgK1xuICAgICAgICAgICAgICBcIiAqIFwiICtcbiAgICAgICAgICAgICAgYXR0cmlidXRlVmFyTmFtZSArXG4gICAgICAgICAgICAgIFwiICsgXCIgK1xuICAgICAgICAgICAgICBkZWNvZGVVbmlmb3JtVmFyTmFtZVRyYW5zbGF0ZSArXG4gICAgICAgICAgICAgIFwiO1xcblwiICtcbiAgICAgICAgICAgICAgXCIgICAgXCIgK1xuICAgICAgICAgICAgICBuZXdNYWluICtcbiAgICAgICAgICAgICAgXCIoKTtcXG5cIiArXG4gICAgICAgICAgICAgIFwifVxcblwiO1xuXG4gICAgICAgICAgICBxdWFudGl6ZWRVbmlmb3Jtc1tkZWNvZGVVbmlmb3JtVmFyTmFtZVNjYWxlXSA9IHsgbWF0OiA0IH07XG4gICAgICAgICAgICBxdWFudGl6ZWRVbmlmb3Jtc1tkZWNvZGVVbmlmb3JtVmFyTmFtZVRyYW5zbGF0ZV0gPSB7IHZlYzogNCB9O1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzaGFkZXIgPVxuICAgICAgICAgICAgICBcInVuaWZvcm0gbWF0XCIgK1xuICAgICAgICAgICAgICBzaXplICtcbiAgICAgICAgICAgICAgXCIgXCIgK1xuICAgICAgICAgICAgICBkZWNvZGVVbmlmb3JtVmFyTmFtZSArXG4gICAgICAgICAgICAgIFwiO1xcblwiICtcbiAgICAgICAgICAgICAgc2hhZGVyO1xuICAgICAgICAgICAgZGVjb2RlID1cbiAgICAgICAgICAgICAgXCJcXG5cIiArXG4gICAgICAgICAgICAgIFwidm9pZCBtYWluKCkge1xcblwiICtcbiAgICAgICAgICAgICAgXCIgICAgXCIgK1xuICAgICAgICAgICAgICBkZWNvZGVkQXR0cmlidXRlVmFyTmFtZSArXG4gICAgICAgICAgICAgIFwiID0gXCIgK1xuICAgICAgICAgICAgICB2YXJpYWJsZVR5cGUgK1xuICAgICAgICAgICAgICBcIihcIiArXG4gICAgICAgICAgICAgIGRlY29kZVVuaWZvcm1WYXJOYW1lICtcbiAgICAgICAgICAgICAgXCIgKiB2ZWNcIiArXG4gICAgICAgICAgICAgIHNpemUgK1xuICAgICAgICAgICAgICBcIihcIiArXG4gICAgICAgICAgICAgIGF0dHJpYnV0ZVZhck5hbWUgK1xuICAgICAgICAgICAgICBcIiwxLjApKTtcXG5cIiArXG4gICAgICAgICAgICAgIFwiICAgIFwiICtcbiAgICAgICAgICAgICAgbmV3TWFpbiArXG4gICAgICAgICAgICAgIFwiKCk7XFxuXCIgK1xuICAgICAgICAgICAgICBcIn1cXG5cIjtcblxuICAgICAgICAgICAgcXVhbnRpemVkVW5pZm9ybXNbZGVjb2RlVW5pZm9ybVZhck5hbWVdID0geyBtYXQ6IHNpemUgfTtcbiAgICAgICAgICB9XG4gICAgICAgICAgc2hhZGVyID0gU2hhZGVyU291cmNlLnJlcGxhY2VNYWluKHNoYWRlciwgbmV3TWFpbik7XG4gICAgICAgICAgc2hhZGVyICs9IGRlY29kZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4ge1xuICAgIHNoYWRlcjogc2hhZGVyLFxuICAgIHVuaWZvcm1zOiBxdWFudGl6ZWRVbmlmb3JtcyxcbiAgfTtcbn07XG5cbmZ1bmN0aW9uIGdldFNjYWxhclVuaWZvcm1GdW5jdGlvbih2YWx1ZSkge1xuICB2YXIgdGhhdCA9IHtcbiAgICB2YWx1ZTogdmFsdWUsXG4gICAgY2xvbmU6IGZ1bmN0aW9uIChzb3VyY2UsIHJlc3VsdCkge1xuICAgICAgcmV0dXJuIHNvdXJjZTtcbiAgICB9LFxuICAgIGZ1bmM6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGF0LnZhbHVlO1xuICAgIH0sXG4gIH07XG4gIHJldHVybiB0aGF0O1xufVxuXG5mdW5jdGlvbiBnZXRWZWMyVW5pZm9ybUZ1bmN0aW9uKHZhbHVlKSB7XG4gIHZhciB0aGF0ID0ge1xuICAgIHZhbHVlOiBDYXJ0ZXNpYW4yLmZyb21BcnJheSh2YWx1ZSksXG4gICAgY2xvbmU6IENhcnRlc2lhbjIuY2xvbmUsXG4gICAgZnVuYzogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoYXQudmFsdWU7XG4gICAgfSxcbiAgfTtcbiAgcmV0dXJuIHRoYXQ7XG59XG5cbmZ1bmN0aW9uIGdldFZlYzNVbmlmb3JtRnVuY3Rpb24odmFsdWUpIHtcbiAgdmFyIHRoYXQgPSB7XG4gICAgdmFsdWU6IENhcnRlc2lhbjMuZnJvbUFycmF5KHZhbHVlKSxcbiAgICBjbG9uZTogQ2FydGVzaWFuMy5jbG9uZSxcbiAgICBmdW5jOiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhhdC52YWx1ZTtcbiAgICB9LFxuICB9O1xuICByZXR1cm4gdGhhdDtcbn1cblxuZnVuY3Rpb24gZ2V0VmVjNFVuaWZvcm1GdW5jdGlvbih2YWx1ZSkge1xuICB2YXIgdGhhdCA9IHtcbiAgICB2YWx1ZTogQ2FydGVzaWFuNC5mcm9tQXJyYXkodmFsdWUpLFxuICAgIGNsb25lOiBDYXJ0ZXNpYW40LmNsb25lLFxuICAgIGZ1bmM6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGF0LnZhbHVlO1xuICAgIH0sXG4gIH07XG4gIHJldHVybiB0aGF0O1xufVxuXG5mdW5jdGlvbiBnZXRNYXQyVW5pZm9ybUZ1bmN0aW9uKHZhbHVlKSB7XG4gIHZhciB0aGF0ID0ge1xuICAgIHZhbHVlOiBNYXRyaXgyLmZyb21Db2x1bW5NYWpvckFycmF5KHZhbHVlKSxcbiAgICBjbG9uZTogTWF0cml4Mi5jbG9uZSxcbiAgICBmdW5jOiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhhdC52YWx1ZTtcbiAgICB9LFxuICB9O1xuICByZXR1cm4gdGhhdDtcbn1cblxuZnVuY3Rpb24gZ2V0TWF0M1VuaWZvcm1GdW5jdGlvbih2YWx1ZSkge1xuICB2YXIgdGhhdCA9IHtcbiAgICB2YWx1ZTogTWF0cml4My5mcm9tQ29sdW1uTWFqb3JBcnJheSh2YWx1ZSksXG4gICAgY2xvbmU6IE1hdHJpeDMuY2xvbmUsXG4gICAgZnVuYzogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoYXQudmFsdWU7XG4gICAgfSxcbiAgfTtcbiAgcmV0dXJuIHRoYXQ7XG59XG5cbmZ1bmN0aW9uIGdldE1hdDRVbmlmb3JtRnVuY3Rpb24odmFsdWUpIHtcbiAgdmFyIHRoYXQgPSB7XG4gICAgdmFsdWU6IE1hdHJpeDQuZnJvbUNvbHVtbk1ham9yQXJyYXkodmFsdWUpLFxuICAgIGNsb25lOiBNYXRyaXg0LmNsb25lLFxuICAgIGZ1bmM6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGF0LnZhbHVlO1xuICAgIH0sXG4gIH07XG4gIHJldHVybiB0aGF0O1xufVxuXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblxuZnVuY3Rpb24gRGVsYXlMb2FkZWRUZXh0dXJlVW5pZm9ybSh2YWx1ZSwgdGV4dHVyZXMsIGRlZmF1bHRUZXh0dXJlKSB7XG4gIHRoaXMuX3ZhbHVlID0gdW5kZWZpbmVkO1xuICB0aGlzLl90ZXh0dXJlSWQgPSB2YWx1ZS5pbmRleDtcbiAgdGhpcy5fdGV4dHVyZXMgPSB0ZXh0dXJlcztcbiAgdGhpcy5fZGVmYXVsdFRleHR1cmUgPSBkZWZhdWx0VGV4dHVyZTtcbn1cblxuT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoRGVsYXlMb2FkZWRUZXh0dXJlVW5pZm9ybS5wcm90b3R5cGUsIHtcbiAgdmFsdWU6IHtcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIC8vIFVzZSB0aGUgZGVmYXVsdCB0ZXh0dXJlICgxeDEgd2hpdGUpIHVudGlsIHRoZSBtb2RlbCdzIHRleHR1cmUgaXMgbG9hZGVkXG4gICAgICBpZiAoIWRlZmluZWQodGhpcy5fdmFsdWUpKSB7XG4gICAgICAgIHZhciB0ZXh0dXJlID0gdGhpcy5fdGV4dHVyZXNbdGhpcy5fdGV4dHVyZUlkXTtcbiAgICAgICAgaWYgKGRlZmluZWQodGV4dHVyZSkpIHtcbiAgICAgICAgICB0aGlzLl92YWx1ZSA9IHRleHR1cmU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuX2RlZmF1bHRUZXh0dXJlO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzLl92YWx1ZTtcbiAgICB9LFxuICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICB0aGlzLl92YWx1ZSA9IHZhbHVlO1xuICAgIH0sXG4gIH0sXG59KTtcblxuRGVsYXlMb2FkZWRUZXh0dXJlVW5pZm9ybS5wcm90b3R5cGUuY2xvbmUgPSBmdW5jdGlvbiAoc291cmNlKSB7XG4gIHJldHVybiBzb3VyY2U7XG59O1xuXG5EZWxheUxvYWRlZFRleHR1cmVVbmlmb3JtLnByb3RvdHlwZS5mdW5jID0gdW5kZWZpbmVkO1xuXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblxuZnVuY3Rpb24gZ2V0VGV4dHVyZVVuaWZvcm1GdW5jdGlvbih2YWx1ZSwgdGV4dHVyZXMsIGRlZmF1bHRUZXh0dXJlKSB7XG4gIHZhciB1bmlmb3JtID0gbmV3IERlbGF5TG9hZGVkVGV4dHVyZVVuaWZvcm0odmFsdWUsIHRleHR1cmVzLCBkZWZhdWx0VGV4dHVyZSk7XG4gIC8vIERlZmluZSBmdW5jdGlvbiBoZXJlIHRvIGFjY2VzcyBjbG9zdXJlIHNpbmNlICd0aGlzJyBjYW4ndCBiZVxuICAvLyB1c2VkIHdoZW4gdGhlIFJlbmRlcmVyIHNldHMgdW5pZm9ybXMuXG4gIHVuaWZvcm0uZnVuYyA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdW5pZm9ybS52YWx1ZTtcbiAgfTtcbiAgcmV0dXJuIHVuaWZvcm07XG59XG5cbnZhciBnbHRmVW5pZm9ybUZ1bmN0aW9ucyA9IHt9O1xuZ2x0ZlVuaWZvcm1GdW5jdGlvbnNbV2ViR0xDb25zdGFudHMuRkxPQVRdID0gZ2V0U2NhbGFyVW5pZm9ybUZ1bmN0aW9uO1xuZ2x0ZlVuaWZvcm1GdW5jdGlvbnNbV2ViR0xDb25zdGFudHMuRkxPQVRfVkVDMl0gPSBnZXRWZWMyVW5pZm9ybUZ1bmN0aW9uO1xuZ2x0ZlVuaWZvcm1GdW5jdGlvbnNbV2ViR0xDb25zdGFudHMuRkxPQVRfVkVDM10gPSBnZXRWZWMzVW5pZm9ybUZ1bmN0aW9uO1xuZ2x0ZlVuaWZvcm1GdW5jdGlvbnNbV2ViR0xDb25zdGFudHMuRkxPQVRfVkVDNF0gPSBnZXRWZWM0VW5pZm9ybUZ1bmN0aW9uO1xuZ2x0ZlVuaWZvcm1GdW5jdGlvbnNbV2ViR0xDb25zdGFudHMuSU5UXSA9IGdldFNjYWxhclVuaWZvcm1GdW5jdGlvbjtcbmdsdGZVbmlmb3JtRnVuY3Rpb25zW1dlYkdMQ29uc3RhbnRzLklOVF9WRUMyXSA9IGdldFZlYzJVbmlmb3JtRnVuY3Rpb247XG5nbHRmVW5pZm9ybUZ1bmN0aW9uc1tXZWJHTENvbnN0YW50cy5JTlRfVkVDM10gPSBnZXRWZWMzVW5pZm9ybUZ1bmN0aW9uO1xuZ2x0ZlVuaWZvcm1GdW5jdGlvbnNbV2ViR0xDb25zdGFudHMuSU5UX1ZFQzRdID0gZ2V0VmVjNFVuaWZvcm1GdW5jdGlvbjtcbmdsdGZVbmlmb3JtRnVuY3Rpb25zW1dlYkdMQ29uc3RhbnRzLkJPT0xdID0gZ2V0U2NhbGFyVW5pZm9ybUZ1bmN0aW9uO1xuZ2x0ZlVuaWZvcm1GdW5jdGlvbnNbV2ViR0xDb25zdGFudHMuQk9PTF9WRUMyXSA9IGdldFZlYzJVbmlmb3JtRnVuY3Rpb247XG5nbHRmVW5pZm9ybUZ1bmN0aW9uc1tXZWJHTENvbnN0YW50cy5CT09MX1ZFQzNdID0gZ2V0VmVjM1VuaWZvcm1GdW5jdGlvbjtcbmdsdGZVbmlmb3JtRnVuY3Rpb25zW1dlYkdMQ29uc3RhbnRzLkJPT0xfVkVDNF0gPSBnZXRWZWM0VW5pZm9ybUZ1bmN0aW9uO1xuZ2x0ZlVuaWZvcm1GdW5jdGlvbnNbV2ViR0xDb25zdGFudHMuRkxPQVRfTUFUMl0gPSBnZXRNYXQyVW5pZm9ybUZ1bmN0aW9uO1xuZ2x0ZlVuaWZvcm1GdW5jdGlvbnNbV2ViR0xDb25zdGFudHMuRkxPQVRfTUFUM10gPSBnZXRNYXQzVW5pZm9ybUZ1bmN0aW9uO1xuZ2x0ZlVuaWZvcm1GdW5jdGlvbnNbV2ViR0xDb25zdGFudHMuRkxPQVRfTUFUNF0gPSBnZXRNYXQ0VW5pZm9ybUZ1bmN0aW9uO1xuZ2x0ZlVuaWZvcm1GdW5jdGlvbnNbV2ViR0xDb25zdGFudHMuU0FNUExFUl8yRF0gPSBnZXRUZXh0dXJlVW5pZm9ybUZ1bmN0aW9uO1xuLy8gR0xURl9TUEVDOiBTdXBwb3J0IFNBTVBMRVJfQ1VCRS4gaHR0cHM6Ly9naXRodWIuY29tL0tocm9ub3NHcm91cC9nbFRGL2lzc3Vlcy80MFxuXG5Nb2RlbFV0aWxpdHkuY3JlYXRlVW5pZm9ybUZ1bmN0aW9uID0gZnVuY3Rpb24gKFxuICB0eXBlLFxuICB2YWx1ZSxcbiAgdGV4dHVyZXMsXG4gIGRlZmF1bHRUZXh0dXJlXG4pIHtcbiAgcmV0dXJuIGdsdGZVbmlmb3JtRnVuY3Rpb25zW3R5cGVdKHZhbHVlLCB0ZXh0dXJlcywgZGVmYXVsdFRleHR1cmUpO1xufTtcblxuZnVuY3Rpb24gc2NhbGVGcm9tTWF0cml4NUFycmF5KG1hdHJpeCkge1xuICByZXR1cm4gW1xuICAgIG1hdHJpeFswXSxcbiAgICBtYXRyaXhbMV0sXG4gICAgbWF0cml4WzJdLFxuICAgIG1hdHJpeFszXSxcbiAgICBtYXRyaXhbNV0sXG4gICAgbWF0cml4WzZdLFxuICAgIG1hdHJpeFs3XSxcbiAgICBtYXRyaXhbOF0sXG4gICAgbWF0cml4WzEwXSxcbiAgICBtYXRyaXhbMTFdLFxuICAgIG1hdHJpeFsxMl0sXG4gICAgbWF0cml4WzEzXSxcbiAgICBtYXRyaXhbMTVdLFxuICAgIG1hdHJpeFsxNl0sXG4gICAgbWF0cml4WzE3XSxcbiAgICBtYXRyaXhbMThdLFxuICBdO1xufVxuXG5mdW5jdGlvbiB0cmFuc2xhdGVGcm9tTWF0cml4NUFycmF5KG1hdHJpeCkge1xuICByZXR1cm4gW21hdHJpeFsyMF0sIG1hdHJpeFsyMV0sIG1hdHJpeFsyMl0sIG1hdHJpeFsyM11dO1xufVxuXG5Nb2RlbFV0aWxpdHkuY3JlYXRlVW5pZm9ybXNGb3JEcmFjb1F1YW50aXplZEF0dHJpYnV0ZXMgPSBmdW5jdGlvbiAoXG4gIGRlY29kZWRBdHRyaWJ1dGVzXG4pIHtcbiAgdmFyIHVuaWZvcm1NYXAgPSB7fTtcbiAgZm9yICh2YXIgYXR0cmlidXRlIGluIGRlY29kZWRBdHRyaWJ1dGVzKSB7XG4gICAgaWYgKGRlY29kZWRBdHRyaWJ1dGVzLmhhc093blByb3BlcnR5KGF0dHJpYnV0ZSkpIHtcbiAgICAgIHZhciBkZWNvZGVkRGF0YSA9IGRlY29kZWRBdHRyaWJ1dGVzW2F0dHJpYnV0ZV07XG4gICAgICB2YXIgcXVhbnRpemF0aW9uID0gZGVjb2RlZERhdGEucXVhbnRpemF0aW9uO1xuXG4gICAgICBpZiAoIWRlZmluZWQocXVhbnRpemF0aW9uKSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgaWYgKGF0dHJpYnV0ZS5jaGFyQXQoMCkgPT09IFwiX1wiKSB7XG4gICAgICAgIGF0dHJpYnV0ZSA9IGF0dHJpYnV0ZS5zdWJzdHJpbmcoMSk7XG4gICAgICB9XG5cbiAgICAgIHZhciB1bmlmb3JtVmFyTmFtZSA9IFwiZ2x0Zl91X2RlY19cIiArIGF0dHJpYnV0ZS50b0xvd2VyQ2FzZSgpO1xuXG4gICAgICBpZiAocXVhbnRpemF0aW9uLm9jdEVuY29kZWQpIHtcbiAgICAgICAgdmFyIHVuaWZvcm1WYXJOYW1lUmFuZ2VDb25zdGFudCA9IHVuaWZvcm1WYXJOYW1lICsgXCJfcmFuZ2VDb25zdGFudFwiO1xuICAgICAgICB2YXIgcmFuZ2VDb25zdGFudCA9ICgxIDw8IHF1YW50aXphdGlvbi5xdWFudGl6YXRpb25CaXRzKSAtIDEuMDtcbiAgICAgICAgdW5pZm9ybU1hcFt1bmlmb3JtVmFyTmFtZVJhbmdlQ29uc3RhbnRdID0gZ2V0U2NhbGFyVW5pZm9ybUZ1bmN0aW9uKFxuICAgICAgICAgIHJhbmdlQ29uc3RhbnRcbiAgICAgICAgKS5mdW5jO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgdmFyIHVuaWZvcm1WYXJOYW1lTm9ybUNvbnN0YW50ID0gdW5pZm9ybVZhck5hbWUgKyBcIl9ub3JtQ29uc3RhbnRcIjtcbiAgICAgIHZhciBub3JtQ29uc3RhbnQgPVxuICAgICAgICBxdWFudGl6YXRpb24ucmFuZ2UgLyAoMSA8PCBxdWFudGl6YXRpb24ucXVhbnRpemF0aW9uQml0cyk7XG4gICAgICB1bmlmb3JtTWFwW3VuaWZvcm1WYXJOYW1lTm9ybUNvbnN0YW50XSA9IGdldFNjYWxhclVuaWZvcm1GdW5jdGlvbihcbiAgICAgICAgbm9ybUNvbnN0YW50XG4gICAgICApLmZ1bmM7XG5cbiAgICAgIHZhciB1bmlmb3JtVmFyTmFtZU1pbiA9IHVuaWZvcm1WYXJOYW1lICsgXCJfbWluXCI7XG4gICAgICBzd2l0Y2ggKGRlY29kZWREYXRhLmNvbXBvbmVudHNQZXJBdHRyaWJ1dGUpIHtcbiAgICAgICAgY2FzZSAxOlxuICAgICAgICAgIHVuaWZvcm1NYXBbdW5pZm9ybVZhck5hbWVNaW5dID0gZ2V0U2NhbGFyVW5pZm9ybUZ1bmN0aW9uKFxuICAgICAgICAgICAgcXVhbnRpemF0aW9uLm1pblZhbHVlc1xuICAgICAgICAgICkuZnVuYztcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAyOlxuICAgICAgICAgIHVuaWZvcm1NYXBbdW5pZm9ybVZhck5hbWVNaW5dID0gZ2V0VmVjMlVuaWZvcm1GdW5jdGlvbihcbiAgICAgICAgICAgIHF1YW50aXphdGlvbi5taW5WYWx1ZXNcbiAgICAgICAgICApLmZ1bmM7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMzpcbiAgICAgICAgICB1bmlmb3JtTWFwW3VuaWZvcm1WYXJOYW1lTWluXSA9IGdldFZlYzNVbmlmb3JtRnVuY3Rpb24oXG4gICAgICAgICAgICBxdWFudGl6YXRpb24ubWluVmFsdWVzXG4gICAgICAgICAgKS5mdW5jO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgdW5pZm9ybU1hcFt1bmlmb3JtVmFyTmFtZU1pbl0gPSBnZXRWZWM0VW5pZm9ybUZ1bmN0aW9uKFxuICAgICAgICAgICAgcXVhbnRpemF0aW9uLm1pblZhbHVlc1xuICAgICAgICAgICkuZnVuYztcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gdW5pZm9ybU1hcDtcbn07XG5cbk1vZGVsVXRpbGl0eS5jcmVhdGVVbmlmb3Jtc0ZvclF1YW50aXplZEF0dHJpYnV0ZXMgPSBmdW5jdGlvbiAoXG4gIGdsdGYsXG4gIHByaW1pdGl2ZSxcbiAgcXVhbnRpemVkVW5pZm9ybXNcbikge1xuICB2YXIgYWNjZXNzb3JzID0gZ2x0Zi5hY2Nlc3NvcnM7XG4gIHZhciBzZXRVbmlmb3JtcyA9IHt9O1xuICB2YXIgdW5pZm9ybU1hcCA9IHt9O1xuXG4gIHZhciBhdHRyaWJ1dGVzID0gcHJpbWl0aXZlLmF0dHJpYnV0ZXM7XG4gIGZvciAodmFyIGF0dHJpYnV0ZSBpbiBhdHRyaWJ1dGVzKSB7XG4gICAgaWYgKGF0dHJpYnV0ZXMuaGFzT3duUHJvcGVydHkoYXR0cmlidXRlKSkge1xuICAgICAgdmFyIGFjY2Vzc29ySWQgPSBhdHRyaWJ1dGVzW2F0dHJpYnV0ZV07XG4gICAgICB2YXIgYSA9IGFjY2Vzc29yc1thY2Nlc3NvcklkXTtcbiAgICAgIHZhciBleHRlbnNpb25zID0gYS5leHRlbnNpb25zO1xuXG4gICAgICBpZiAoYXR0cmlidXRlLmNoYXJBdCgwKSA9PT0gXCJfXCIpIHtcbiAgICAgICAgYXR0cmlidXRlID0gYXR0cmlidXRlLnN1YnN0cmluZygxKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGRlZmluZWQoZXh0ZW5zaW9ucykpIHtcbiAgICAgICAgdmFyIHF1YW50aXplZEF0dHJpYnV0ZXMgPSBleHRlbnNpb25zLldFQjNEX3F1YW50aXplZF9hdHRyaWJ1dGVzO1xuICAgICAgICBpZiAoZGVmaW5lZChxdWFudGl6ZWRBdHRyaWJ1dGVzKSkge1xuICAgICAgICAgIHZhciBkZWNvZGVNYXRyaXggPSBxdWFudGl6ZWRBdHRyaWJ1dGVzLmRlY29kZU1hdHJpeDtcbiAgICAgICAgICB2YXIgdW5pZm9ybVZhcmlhYmxlID0gXCJnbHRmX3VfZGVjX1wiICsgYXR0cmlidXRlLnRvTG93ZXJDYXNlKCk7XG5cbiAgICAgICAgICBzd2l0Y2ggKGEudHlwZSkge1xuICAgICAgICAgICAgY2FzZSBBdHRyaWJ1dGVUeXBlLlNDQUxBUjpcbiAgICAgICAgICAgICAgdW5pZm9ybU1hcFt1bmlmb3JtVmFyaWFibGVdID0gZ2V0TWF0MlVuaWZvcm1GdW5jdGlvbihcbiAgICAgICAgICAgICAgICBkZWNvZGVNYXRyaXhcbiAgICAgICAgICAgICAgKS5mdW5jO1xuICAgICAgICAgICAgICBzZXRVbmlmb3Jtc1t1bmlmb3JtVmFyaWFibGVdID0gdHJ1ZTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIEF0dHJpYnV0ZVR5cGUuVkVDMjpcbiAgICAgICAgICAgICAgdW5pZm9ybU1hcFt1bmlmb3JtVmFyaWFibGVdID0gZ2V0TWF0M1VuaWZvcm1GdW5jdGlvbihcbiAgICAgICAgICAgICAgICBkZWNvZGVNYXRyaXhcbiAgICAgICAgICAgICAgKS5mdW5jO1xuICAgICAgICAgICAgICBzZXRVbmlmb3Jtc1t1bmlmb3JtVmFyaWFibGVdID0gdHJ1ZTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIEF0dHJpYnV0ZVR5cGUuVkVDMzpcbiAgICAgICAgICAgICAgdW5pZm9ybU1hcFt1bmlmb3JtVmFyaWFibGVdID0gZ2V0TWF0NFVuaWZvcm1GdW5jdGlvbihcbiAgICAgICAgICAgICAgICBkZWNvZGVNYXRyaXhcbiAgICAgICAgICAgICAgKS5mdW5jO1xuICAgICAgICAgICAgICBzZXRVbmlmb3Jtc1t1bmlmb3JtVmFyaWFibGVdID0gdHJ1ZTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIEF0dHJpYnV0ZVR5cGUuVkVDNDpcbiAgICAgICAgICAgICAgLy8gVkVDNCBhdHRyaWJ1dGVzIGFyZSBzcGxpdCBpbnRvIHNjYWxlIGFuZCB0cmFuc2xhdGUgYmVjYXVzZSB0aGVyZSBpcyBubyBtYXQ1IGluIEdMU0xcbiAgICAgICAgICAgICAgdmFyIHVuaWZvcm1WYXJpYWJsZVNjYWxlID0gdW5pZm9ybVZhcmlhYmxlICsgXCJfc2NhbGVcIjtcbiAgICAgICAgICAgICAgdmFyIHVuaWZvcm1WYXJpYWJsZVRyYW5zbGF0ZSA9IHVuaWZvcm1WYXJpYWJsZSArIFwiX3RyYW5zbGF0ZVwiO1xuICAgICAgICAgICAgICB1bmlmb3JtTWFwW3VuaWZvcm1WYXJpYWJsZVNjYWxlXSA9IGdldE1hdDRVbmlmb3JtRnVuY3Rpb24oXG4gICAgICAgICAgICAgICAgc2NhbGVGcm9tTWF0cml4NUFycmF5KGRlY29kZU1hdHJpeClcbiAgICAgICAgICAgICAgKS5mdW5jO1xuICAgICAgICAgICAgICB1bmlmb3JtTWFwW3VuaWZvcm1WYXJpYWJsZVRyYW5zbGF0ZV0gPSBnZXRWZWM0VW5pZm9ybUZ1bmN0aW9uKFxuICAgICAgICAgICAgICAgIHRyYW5zbGF0ZUZyb21NYXRyaXg1QXJyYXkoZGVjb2RlTWF0cml4KVxuICAgICAgICAgICAgICApLmZ1bmM7XG4gICAgICAgICAgICAgIHNldFVuaWZvcm1zW3VuaWZvcm1WYXJpYWJsZVNjYWxlXSA9IHRydWU7XG4gICAgICAgICAgICAgIHNldFVuaWZvcm1zW3VuaWZvcm1WYXJpYWJsZVRyYW5zbGF0ZV0gPSB0cnVlO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvLyBJZiB0aGVyZSBhcmUgYW55IHVuc2V0IHF1YW50aXplZCB1bmlmb3JtcyBpbiB0aGlzIHByb2dyYW0sIHRoZXkgc2hvdWxkIGJlIHNldCB0byB0aGUgaWRlbnRpdHlcbiAgZm9yICh2YXIgcXVhbnRpemVkVW5pZm9ybSBpbiBxdWFudGl6ZWRVbmlmb3Jtcykge1xuICAgIGlmIChxdWFudGl6ZWRVbmlmb3Jtcy5oYXNPd25Qcm9wZXJ0eShxdWFudGl6ZWRVbmlmb3JtKSkge1xuICAgICAgaWYgKCFzZXRVbmlmb3Jtc1txdWFudGl6ZWRVbmlmb3JtXSkge1xuICAgICAgICB2YXIgcHJvcGVydGllcyA9IHF1YW50aXplZFVuaWZvcm1zW3F1YW50aXplZFVuaWZvcm1dO1xuICAgICAgICBpZiAoZGVmaW5lZChwcm9wZXJ0aWVzLm1hdCkpIHtcbiAgICAgICAgICBpZiAocHJvcGVydGllcy5tYXQgPT09IDIpIHtcbiAgICAgICAgICAgIHVuaWZvcm1NYXBbcXVhbnRpemVkVW5pZm9ybV0gPSBnZXRNYXQyVW5pZm9ybUZ1bmN0aW9uKFxuICAgICAgICAgICAgICBNYXRyaXgyLklERU5USVRZXG4gICAgICAgICAgICApLmZ1bmM7XG4gICAgICAgICAgfSBlbHNlIGlmIChwcm9wZXJ0aWVzLm1hdCA9PT0gMykge1xuICAgICAgICAgICAgdW5pZm9ybU1hcFtxdWFudGl6ZWRVbmlmb3JtXSA9IGdldE1hdDNVbmlmb3JtRnVuY3Rpb24oXG4gICAgICAgICAgICAgIE1hdHJpeDMuSURFTlRJVFlcbiAgICAgICAgICAgICkuZnVuYztcbiAgICAgICAgICB9IGVsc2UgaWYgKHByb3BlcnRpZXMubWF0ID09PSA0KSB7XG4gICAgICAgICAgICB1bmlmb3JtTWFwW3F1YW50aXplZFVuaWZvcm1dID0gZ2V0TWF0NFVuaWZvcm1GdW5jdGlvbihcbiAgICAgICAgICAgICAgTWF0cml4NC5JREVOVElUWVxuICAgICAgICAgICAgKS5mdW5jO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoZGVmaW5lZChwcm9wZXJ0aWVzLnZlYykpIHtcbiAgICAgICAgICBpZiAocHJvcGVydGllcy52ZWMgPT09IDQpIHtcbiAgICAgICAgICAgIHVuaWZvcm1NYXBbcXVhbnRpemVkVW5pZm9ybV0gPSBnZXRWZWM0VW5pZm9ybUZ1bmN0aW9uKFtcbiAgICAgICAgICAgICAgMCxcbiAgICAgICAgICAgICAgMCxcbiAgICAgICAgICAgICAgMCxcbiAgICAgICAgICAgICAgMCxcbiAgICAgICAgICAgIF0pLmZ1bmM7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiB1bmlmb3JtTWFwO1xufTtcblxuLy8gVGhpcyBkb2Vzbid0IHN1cHBvcnQgTE9DQUwsIHdoaWNoIHdlIGNvdWxkIGFkZCBpZiBpdCBpcyBldmVyIHVzZWQuXG52YXIgc2NyYXRjaFRyYW5zbGF0aW9uUnRjID0gbmV3IENhcnRlc2lhbjMoKTtcbnZhciBnbHRmU2VtYW50aWNVbmlmb3JtcyA9IHtcbiAgTU9ERUw6IGZ1bmN0aW9uICh1bmlmb3JtU3RhdGUsIG1vZGVsKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB1bmlmb3JtU3RhdGUubW9kZWw7XG4gICAgfTtcbiAgfSxcbiAgVklFVzogZnVuY3Rpb24gKHVuaWZvcm1TdGF0ZSwgbW9kZWwpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHVuaWZvcm1TdGF0ZS52aWV3O1xuICAgIH07XG4gIH0sXG4gIFBST0pFQ1RJT046IGZ1bmN0aW9uICh1bmlmb3JtU3RhdGUsIG1vZGVsKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB1bmlmb3JtU3RhdGUucHJvamVjdGlvbjtcbiAgICB9O1xuICB9LFxuICBNT0RFTFZJRVc6IGZ1bmN0aW9uICh1bmlmb3JtU3RhdGUsIG1vZGVsKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB1bmlmb3JtU3RhdGUubW9kZWxWaWV3O1xuICAgIH07XG4gIH0sXG4gIENFU0lVTV9SVENfTU9ERUxWSUVXOiBmdW5jdGlvbiAodW5pZm9ybVN0YXRlLCBtb2RlbCkge1xuICAgIC8vIENFU0lVTV9SVEMgZXh0ZW5zaW9uXG4gICAgdmFyIG12UnRjID0gbmV3IE1hdHJpeDQoKTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKGRlZmluZWQobW9kZWwuX3J0Y0NlbnRlcikpIHtcbiAgICAgICAgTWF0cml4NC5nZXRUcmFuc2xhdGlvbih1bmlmb3JtU3RhdGUubW9kZWwsIHNjcmF0Y2hUcmFuc2xhdGlvblJ0Yyk7XG4gICAgICAgIENhcnRlc2lhbjMuYWRkKFxuICAgICAgICAgIHNjcmF0Y2hUcmFuc2xhdGlvblJ0YyxcbiAgICAgICAgICBtb2RlbC5fcnRjQ2VudGVyLFxuICAgICAgICAgIHNjcmF0Y2hUcmFuc2xhdGlvblJ0Y1xuICAgICAgICApO1xuICAgICAgICBNYXRyaXg0Lm11bHRpcGx5QnlQb2ludChcbiAgICAgICAgICB1bmlmb3JtU3RhdGUudmlldyxcbiAgICAgICAgICBzY3JhdGNoVHJhbnNsYXRpb25SdGMsXG4gICAgICAgICAgc2NyYXRjaFRyYW5zbGF0aW9uUnRjXG4gICAgICAgICk7XG4gICAgICAgIHJldHVybiBNYXRyaXg0LnNldFRyYW5zbGF0aW9uKFxuICAgICAgICAgIHVuaWZvcm1TdGF0ZS5tb2RlbFZpZXcsXG4gICAgICAgICAgc2NyYXRjaFRyYW5zbGF0aW9uUnRjLFxuICAgICAgICAgIG12UnRjXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdW5pZm9ybVN0YXRlLm1vZGVsVmlldztcbiAgICB9O1xuICB9LFxuICBNT0RFTFZJRVdQUk9KRUNUSU9OOiBmdW5jdGlvbiAodW5pZm9ybVN0YXRlLCBtb2RlbCkge1xuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdW5pZm9ybVN0YXRlLm1vZGVsVmlld1Byb2plY3Rpb247XG4gICAgfTtcbiAgfSxcbiAgTU9ERUxJTlZFUlNFOiBmdW5jdGlvbiAodW5pZm9ybVN0YXRlLCBtb2RlbCkge1xuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdW5pZm9ybVN0YXRlLmludmVyc2VNb2RlbDtcbiAgICB9O1xuICB9LFxuICBWSUVXSU5WRVJTRTogZnVuY3Rpb24gKHVuaWZvcm1TdGF0ZSwgbW9kZWwpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHVuaWZvcm1TdGF0ZS5pbnZlcnNlVmlldztcbiAgICB9O1xuICB9LFxuICBQUk9KRUNUSU9OSU5WRVJTRTogZnVuY3Rpb24gKHVuaWZvcm1TdGF0ZSwgbW9kZWwpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHVuaWZvcm1TdGF0ZS5pbnZlcnNlUHJvamVjdGlvbjtcbiAgICB9O1xuICB9LFxuICBNT0RFTFZJRVdJTlZFUlNFOiBmdW5jdGlvbiAodW5pZm9ybVN0YXRlLCBtb2RlbCkge1xuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdW5pZm9ybVN0YXRlLmludmVyc2VNb2RlbFZpZXc7XG4gICAgfTtcbiAgfSxcbiAgTU9ERUxWSUVXUFJPSkVDVElPTklOVkVSU0U6IGZ1bmN0aW9uICh1bmlmb3JtU3RhdGUsIG1vZGVsKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB1bmlmb3JtU3RhdGUuaW52ZXJzZU1vZGVsVmlld1Byb2plY3Rpb247XG4gICAgfTtcbiAgfSxcbiAgTU9ERUxJTlZFUlNFVFJBTlNQT1NFOiBmdW5jdGlvbiAodW5pZm9ybVN0YXRlLCBtb2RlbCkge1xuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdW5pZm9ybVN0YXRlLmludmVyc2VUcmFuc3Bvc2VNb2RlbDtcbiAgICB9O1xuICB9LFxuICBNT0RFTFZJRVdJTlZFUlNFVFJBTlNQT1NFOiBmdW5jdGlvbiAodW5pZm9ybVN0YXRlLCBtb2RlbCkge1xuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdW5pZm9ybVN0YXRlLm5vcm1hbDtcbiAgICB9O1xuICB9LFxuICBWSUVXUE9SVDogZnVuY3Rpb24gKHVuaWZvcm1TdGF0ZSwgbW9kZWwpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHVuaWZvcm1TdGF0ZS52aWV3cG9ydENhcnRlc2lhbjQ7XG4gICAgfTtcbiAgfSxcbiAgLy8gSk9JTlRNQVRSSVggY3JlYXRlZCBpbiBjcmVhdGVDb21tYW5kKClcbn07XG5cbk1vZGVsVXRpbGl0eS5nZXRHbHRmU2VtYW50aWNVbmlmb3JtcyA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIGdsdGZTZW1hbnRpY1VuaWZvcm1zO1xufTtcbmV4cG9ydCBkZWZhdWx0IE1vZGVsVXRpbGl0eTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///15322\n')}}]);