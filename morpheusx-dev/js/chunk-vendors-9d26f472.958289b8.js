"use strict";(self["webpackChunkvue3_webpack5"]=self["webpackChunkvue3_webpack5"]||[]).push([[1731],{53773:function(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__){eval('/* harmony import */ var _BoundingSphere_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(48243);\n/* harmony import */ var _buildModuleUrl_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(72000);\n/* harmony import */ var _Cartesian2_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(60838);\n/* harmony import */ var _Cartesian3_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(60216);\n/* harmony import */ var _Cartographic_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(51688);\n/* harmony import */ var _Check_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(66553);\n/* harmony import */ var _defaultValue_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(62200);\n/* harmony import */ var _defined_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(82982);\n/* harmony import */ var _DeveloperError_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(12572);\n/* harmony import */ var _Ellipsoid_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(50491);\n/* harmony import */ var _GeographicTilingScheme_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(71351);\n/* harmony import */ var _Rectangle_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(96190);\n/* harmony import */ var _Resource_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(68985);\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nvar scratchDiagonalCartesianNE = new _Cartesian3_js__WEBPACK_IMPORTED_MODULE_3__/* ["default"] */ .Z();\nvar scratchDiagonalCartesianSW = new _Cartesian3_js__WEBPACK_IMPORTED_MODULE_3__/* ["default"] */ .Z();\nvar scratchDiagonalCartographic = new _Cartographic_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .Z();\nvar scratchCenterCartesian = new _Cartesian3_js__WEBPACK_IMPORTED_MODULE_3__/* ["default"] */ .Z();\nvar scratchSurfaceCartesian = new _Cartesian3_js__WEBPACK_IMPORTED_MODULE_3__/* ["default"] */ .Z();\n\nvar scratchBoundingSphere = new _BoundingSphere_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .Z();\nvar tilingScheme = new _GeographicTilingScheme_js__WEBPACK_IMPORTED_MODULE_9__/* ["default"] */ .Z();\nvar scratchCorners = [\n  new _Cartographic_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .Z(),\n  new _Cartographic_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .Z(),\n  new _Cartographic_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .Z(),\n  new _Cartographic_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .Z(),\n];\nvar scratchTileXY = new _Cartesian2_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"] */ .Z();\n\n/**\n * A collection of functions for approximating terrain height\n * @private\n */\nvar ApproximateTerrainHeights = {};\n\n/**\n * Initializes the minimum and maximum terrain heights\n * @return {Promise<void>}\n */\nApproximateTerrainHeights.initialize = function () {\n  var initPromise = ApproximateTerrainHeights._initPromise;\n  if ((0,_defined_js__WEBPACK_IMPORTED_MODULE_12__/* ["default"] */ .Z)(initPromise)) {\n    return initPromise;\n  }\n\n  initPromise = _Resource_js__WEBPACK_IMPORTED_MODULE_11__/* ["default"].fetchJson */ .Z.fetchJson(\n    (0,_buildModuleUrl_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .Z)("Assets/approximateTerrainHeights.json")\n  ).then(function (json) {\n    ApproximateTerrainHeights._terrainHeights = json;\n  });\n  ApproximateTerrainHeights._initPromise = initPromise;\n\n  return initPromise;\n};\n\n/**\n * Computes the minimum and maximum terrain heights for a given rectangle\n * @param {Rectangle} rectangle The bounding rectangle\n * @param {Ellipsoid} [ellipsoid=Ellipsoid.WGS84] The ellipsoid\n * @return {{minimumTerrainHeight: Number, maximumTerrainHeight: Number}}\n */\nApproximateTerrainHeights.getMinimumMaximumHeights = function (\n  rectangle,\n  ellipsoid\n) {\n  //>>includeStart(\'debug\', pragmas.debug);\n  _Check_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"].defined */ .Z.defined("rectangle", rectangle);\n  if (!(0,_defined_js__WEBPACK_IMPORTED_MODULE_12__/* ["default"] */ .Z)(ApproximateTerrainHeights._terrainHeights)) {\n    throw new _DeveloperError_js__WEBPACK_IMPORTED_MODULE_7__/* ["default"] */ .Z(\n      "You must call ApproximateTerrainHeights.initialize and wait for the promise to resolve before using this function"\n    );\n  }\n  //>>includeEnd(\'debug\');\n  ellipsoid = (0,_defaultValue_js__WEBPACK_IMPORTED_MODULE_6__/* ["default"] */ .Z)(ellipsoid, _Ellipsoid_js__WEBPACK_IMPORTED_MODULE_8__/* ["default"].WGS84 */ .Z.WGS84);\n\n  var xyLevel = getTileXYLevel(rectangle);\n\n  // Get the terrain min/max for that tile\n  var minTerrainHeight = ApproximateTerrainHeights._defaultMinTerrainHeight;\n  var maxTerrainHeight = ApproximateTerrainHeights._defaultMaxTerrainHeight;\n  if ((0,_defined_js__WEBPACK_IMPORTED_MODULE_12__/* ["default"] */ .Z)(xyLevel)) {\n    var key = xyLevel.level + "-" + xyLevel.x + "-" + xyLevel.y;\n    var heights = ApproximateTerrainHeights._terrainHeights[key];\n    if ((0,_defined_js__WEBPACK_IMPORTED_MODULE_12__/* ["default"] */ .Z)(heights)) {\n      minTerrainHeight = heights[0];\n      maxTerrainHeight = heights[1];\n    }\n\n    // Compute min by taking the center of the NE->SW diagonal and finding distance to the surface\n    ellipsoid.cartographicToCartesian(\n      _Rectangle_js__WEBPACK_IMPORTED_MODULE_10__/* ["default"].northeast */ .Z.northeast(rectangle, scratchDiagonalCartographic),\n      scratchDiagonalCartesianNE\n    );\n    ellipsoid.cartographicToCartesian(\n      _Rectangle_js__WEBPACK_IMPORTED_MODULE_10__/* ["default"].southwest */ .Z.southwest(rectangle, scratchDiagonalCartographic),\n      scratchDiagonalCartesianSW\n    );\n\n    _Cartesian3_js__WEBPACK_IMPORTED_MODULE_3__/* ["default"].midpoint */ .Z.midpoint(\n      scratchDiagonalCartesianSW,\n      scratchDiagonalCartesianNE,\n      scratchCenterCartesian\n    );\n    var surfacePosition = ellipsoid.scaleToGeodeticSurface(\n      scratchCenterCartesian,\n      scratchSurfaceCartesian\n    );\n    if ((0,_defined_js__WEBPACK_IMPORTED_MODULE_12__/* ["default"] */ .Z)(surfacePosition)) {\n      var distance = _Cartesian3_js__WEBPACK_IMPORTED_MODULE_3__/* ["default"].distance */ .Z.distance(\n        scratchCenterCartesian,\n        surfacePosition\n      );\n      minTerrainHeight = Math.min(minTerrainHeight, -distance);\n    } else {\n      minTerrainHeight = ApproximateTerrainHeights._defaultMinTerrainHeight;\n    }\n  }\n\n  minTerrainHeight = Math.max(\n    ApproximateTerrainHeights._defaultMinTerrainHeight,\n    minTerrainHeight\n  );\n\n  return {\n    minimumTerrainHeight: minTerrainHeight,\n    maximumTerrainHeight: maxTerrainHeight,\n  };\n};\n\n/**\n * Computes the bounding sphere based on the tile heights in the rectangle\n * @param {Rectangle} rectangle The bounding rectangle\n * @param {Ellipsoid} [ellipsoid=Ellipsoid.WGS84] The ellipsoid\n * @return {BoundingSphere} The result bounding sphere\n */\nApproximateTerrainHeights.getBoundingSphere = function (rectangle, ellipsoid) {\n  //>>includeStart(\'debug\', pragmas.debug);\n  _Check_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"].defined */ .Z.defined("rectangle", rectangle);\n  if (!(0,_defined_js__WEBPACK_IMPORTED_MODULE_12__/* ["default"] */ .Z)(ApproximateTerrainHeights._terrainHeights)) {\n    throw new _DeveloperError_js__WEBPACK_IMPORTED_MODULE_7__/* ["default"] */ .Z(\n      "You must call ApproximateTerrainHeights.initialize and wait for the promise to resolve before using this function"\n    );\n  }\n  //>>includeEnd(\'debug\');\n  ellipsoid = (0,_defaultValue_js__WEBPACK_IMPORTED_MODULE_6__/* ["default"] */ .Z)(ellipsoid, _Ellipsoid_js__WEBPACK_IMPORTED_MODULE_8__/* ["default"].WGS84 */ .Z.WGS84);\n\n  var xyLevel = getTileXYLevel(rectangle);\n\n  // Get the terrain max for that tile\n  var maxTerrainHeight = ApproximateTerrainHeights._defaultMaxTerrainHeight;\n  if ((0,_defined_js__WEBPACK_IMPORTED_MODULE_12__/* ["default"] */ .Z)(xyLevel)) {\n    var key = xyLevel.level + "-" + xyLevel.x + "-" + xyLevel.y;\n    var heights = ApproximateTerrainHeights._terrainHeights[key];\n    if ((0,_defined_js__WEBPACK_IMPORTED_MODULE_12__/* ["default"] */ .Z)(heights)) {\n      maxTerrainHeight = heights[1];\n    }\n  }\n\n  var result = _BoundingSphere_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].fromRectangle3D */ .Z.fromRectangle3D(rectangle, ellipsoid, 0.0);\n  _BoundingSphere_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].fromRectangle3D */ .Z.fromRectangle3D(\n    rectangle,\n    ellipsoid,\n    maxTerrainHeight,\n    scratchBoundingSphere\n  );\n\n  return _BoundingSphere_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].union */ .Z.union(result, scratchBoundingSphere, result);\n};\n\nfunction getTileXYLevel(rectangle) {\n  _Cartographic_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"].fromRadians */ .Z.fromRadians(\n    rectangle.east,\n    rectangle.north,\n    0.0,\n    scratchCorners[0]\n  );\n  _Cartographic_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"].fromRadians */ .Z.fromRadians(\n    rectangle.west,\n    rectangle.north,\n    0.0,\n    scratchCorners[1]\n  );\n  _Cartographic_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"].fromRadians */ .Z.fromRadians(\n    rectangle.east,\n    rectangle.south,\n    0.0,\n    scratchCorners[2]\n  );\n  _Cartographic_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"].fromRadians */ .Z.fromRadians(\n    rectangle.west,\n    rectangle.south,\n    0.0,\n    scratchCorners[3]\n  );\n\n  // Determine which tile the bounding rectangle is in\n  var lastLevelX = 0,\n    lastLevelY = 0;\n  var currentX = 0,\n    currentY = 0;\n  var maxLevel = ApproximateTerrainHeights._terrainHeightsMaxLevel;\n  var i;\n  for (i = 0; i <= maxLevel; ++i) {\n    var failed = false;\n    for (var j = 0; j < 4; ++j) {\n      var corner = scratchCorners[j];\n      tilingScheme.positionToTileXY(corner, i, scratchTileXY);\n      if (j === 0) {\n        currentX = scratchTileXY.x;\n        currentY = scratchTileXY.y;\n      } else if (currentX !== scratchTileXY.x || currentY !== scratchTileXY.y) {\n        failed = true;\n        break;\n      }\n    }\n\n    if (failed) {\n      break;\n    }\n\n    lastLevelX = currentX;\n    lastLevelY = currentY;\n  }\n\n  if (i === 0) {\n    return undefined;\n  }\n\n  return {\n    x: lastLevelX,\n    y: lastLevelY,\n    level: i > maxLevel ? maxLevel : i - 1,\n  };\n}\n\nApproximateTerrainHeights._terrainHeightsMaxLevel = 6;\nApproximateTerrainHeights._defaultMaxTerrainHeight = 9000.0;\nApproximateTerrainHeights._defaultMinTerrainHeight = -100000.0;\nApproximateTerrainHeights._terrainHeights = undefined;\nApproximateTerrainHeights._initPromise = undefined;\n\nObject.defineProperties(ApproximateTerrainHeights, {\n  /**\n   * Determines if the terrain heights are initialized and ready to use. To initialize the terrain heights,\n   * call {@link ApproximateTerrainHeights#initialize} and wait for the returned promise to resolve.\n   * @type {Boolean}\n   * @readonly\n   * @memberof ApproximateTerrainHeights\n   */\n  initialized: {\n    get: function () {\n      return (0,_defined_js__WEBPACK_IMPORTED_MODULE_12__/* ["default"] */ .Z)(ApproximateTerrainHeights._terrainHeights);\n    },\n  },\n});\n/* harmony default export */ __webpack_exports__["Z"] = (ApproximateTerrainHeights);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QUFDQSxXQUFXLDRDQUE0QztBQUN2RCxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsaUVBQU87QUFDcEIsS0FBSztBQUNMLEdBQUc7QUFDSCxDQUFDO0FBQ0QseURBQWUseUJBQXlCLEVBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly92dWUzLXdlYnBhY2s1Ly4vbm9kZV9tb2R1bGVzL2Nlc2l1bS9Tb3VyY2UvQ29yZS9BcHByb3hpbWF0ZVRlcnJhaW5IZWlnaHRzLmpzP2UxOGMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IEJvdW5kaW5nU3BoZXJlIGZyb20gXCIuL0JvdW5kaW5nU3BoZXJlLmpzXCI7XG5pbXBvcnQgYnVpbGRNb2R1bGVVcmwgZnJvbSBcIi4vYnVpbGRNb2R1bGVVcmwuanNcIjtcbmltcG9ydCBDYXJ0ZXNpYW4yIGZyb20gXCIuL0NhcnRlc2lhbjIuanNcIjtcbmltcG9ydCBDYXJ0ZXNpYW4zIGZyb20gXCIuL0NhcnRlc2lhbjMuanNcIjtcbmltcG9ydCBDYXJ0b2dyYXBoaWMgZnJvbSBcIi4vQ2FydG9ncmFwaGljLmpzXCI7XG5pbXBvcnQgQ2hlY2sgZnJvbSBcIi4vQ2hlY2suanNcIjtcbmltcG9ydCBkZWZhdWx0VmFsdWUgZnJvbSBcIi4vZGVmYXVsdFZhbHVlLmpzXCI7XG5pbXBvcnQgZGVmaW5lZCBmcm9tIFwiLi9kZWZpbmVkLmpzXCI7XG5pbXBvcnQgRGV2ZWxvcGVyRXJyb3IgZnJvbSBcIi4vRGV2ZWxvcGVyRXJyb3IuanNcIjtcbmltcG9ydCBFbGxpcHNvaWQgZnJvbSBcIi4vRWxsaXBzb2lkLmpzXCI7XG5pbXBvcnQgR2VvZ3JhcGhpY1RpbGluZ1NjaGVtZSBmcm9tIFwiLi9HZW9ncmFwaGljVGlsaW5nU2NoZW1lLmpzXCI7XG5pbXBvcnQgUmVjdGFuZ2xlIGZyb20gXCIuL1JlY3RhbmdsZS5qc1wiO1xuaW1wb3J0IFJlc291cmNlIGZyb20gXCIuL1Jlc291cmNlLmpzXCI7XG5cbnZhciBzY3JhdGNoRGlhZ29uYWxDYXJ0ZXNpYW5ORSA9IG5ldyBDYXJ0ZXNpYW4zKCk7XG52YXIgc2NyYXRjaERpYWdvbmFsQ2FydGVzaWFuU1cgPSBuZXcgQ2FydGVzaWFuMygpO1xudmFyIHNjcmF0Y2hEaWFnb25hbENhcnRvZ3JhcGhpYyA9IG5ldyBDYXJ0b2dyYXBoaWMoKTtcbnZhciBzY3JhdGNoQ2VudGVyQ2FydGVzaWFuID0gbmV3IENhcnRlc2lhbjMoKTtcbnZhciBzY3JhdGNoU3VyZmFjZUNhcnRlc2lhbiA9IG5ldyBDYXJ0ZXNpYW4zKCk7XG5cbnZhciBzY3JhdGNoQm91bmRpbmdTcGhlcmUgPSBuZXcgQm91bmRpbmdTcGhlcmUoKTtcbnZhciB0aWxpbmdTY2hlbWUgPSBuZXcgR2VvZ3JhcGhpY1RpbGluZ1NjaGVtZSgpO1xudmFyIHNjcmF0Y2hDb3JuZXJzID0gW1xuICBuZXcgQ2FydG9ncmFwaGljKCksXG4gIG5ldyBDYXJ0b2dyYXBoaWMoKSxcbiAgbmV3IENhcnRvZ3JhcGhpYygpLFxuICBuZXcgQ2FydG9ncmFwaGljKCksXG5dO1xudmFyIHNjcmF0Y2hUaWxlWFkgPSBuZXcgQ2FydGVzaWFuMigpO1xuXG4vKipcbiAqIEEgY29sbGVjdGlvbiBvZiBmdW5jdGlvbnMgZm9yIGFwcHJveGltYXRpbmcgdGVycmFpbiBoZWlnaHRcbiAqIEBwcml2YXRlXG4gKi9cbnZhciBBcHByb3hpbWF0ZVRlcnJhaW5IZWlnaHRzID0ge307XG5cbi8qKlxuICogSW5pdGlhbGl6ZXMgdGhlIG1pbmltdW0gYW5kIG1heGltdW0gdGVycmFpbiBoZWlnaHRzXG4gKiBAcmV0dXJuIHtQcm9taXNlPHZvaWQ+fVxuICovXG5BcHByb3hpbWF0ZVRlcnJhaW5IZWlnaHRzLmluaXRpYWxpemUgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBpbml0UHJvbWlzZSA9IEFwcHJveGltYXRlVGVycmFpbkhlaWdodHMuX2luaXRQcm9taXNlO1xuICBpZiAoZGVmaW5lZChpbml0UHJvbWlzZSkpIHtcbiAgICByZXR1cm4gaW5pdFByb21pc2U7XG4gIH1cblxuICBpbml0UHJvbWlzZSA9IFJlc291cmNlLmZldGNoSnNvbihcbiAgICBidWlsZE1vZHVsZVVybChcIkFzc2V0cy9hcHByb3hpbWF0ZVRlcnJhaW5IZWlnaHRzLmpzb25cIilcbiAgKS50aGVuKGZ1bmN0aW9uIChqc29uKSB7XG4gICAgQXBwcm94aW1hdGVUZXJyYWluSGVpZ2h0cy5fdGVycmFpbkhlaWdodHMgPSBqc29uO1xuICB9KTtcbiAgQXBwcm94aW1hdGVUZXJyYWluSGVpZ2h0cy5faW5pdFByb21pc2UgPSBpbml0UHJvbWlzZTtcblxuICByZXR1cm4gaW5pdFByb21pc2U7XG59O1xuXG4vKipcbiAqIENvbXB1dGVzIHRoZSBtaW5pbXVtIGFuZCBtYXhpbXVtIHRlcnJhaW4gaGVpZ2h0cyBmb3IgYSBnaXZlbiByZWN0YW5nbGVcbiAqIEBwYXJhbSB7UmVjdGFuZ2xlfSByZWN0YW5nbGUgVGhlIGJvdW5kaW5nIHJlY3RhbmdsZVxuICogQHBhcmFtIHtFbGxpcHNvaWR9IFtlbGxpcHNvaWQ9RWxsaXBzb2lkLldHUzg0XSBUaGUgZWxsaXBzb2lkXG4gKiBAcmV0dXJuIHt7bWluaW11bVRlcnJhaW5IZWlnaHQ6IE51bWJlciwgbWF4aW11bVRlcnJhaW5IZWlnaHQ6IE51bWJlcn19XG4gKi9cbkFwcHJveGltYXRlVGVycmFpbkhlaWdodHMuZ2V0TWluaW11bU1heGltdW1IZWlnaHRzID0gZnVuY3Rpb24gKFxuICByZWN0YW5nbGUsXG4gIGVsbGlwc29pZFxuKSB7XG4gIC8vPj5pbmNsdWRlU3RhcnQoJ2RlYnVnJywgcHJhZ21hcy5kZWJ1Zyk7XG4gIENoZWNrLmRlZmluZWQoXCJyZWN0YW5nbGVcIiwgcmVjdGFuZ2xlKTtcbiAgaWYgKCFkZWZpbmVkKEFwcHJveGltYXRlVGVycmFpbkhlaWdodHMuX3RlcnJhaW5IZWlnaHRzKSkge1xuICAgIHRocm93IG5ldyBEZXZlbG9wZXJFcnJvcihcbiAgICAgIFwiWW91IG11c3QgY2FsbCBBcHByb3hpbWF0ZVRlcnJhaW5IZWlnaHRzLmluaXRpYWxpemUgYW5kIHdhaXQgZm9yIHRoZSBwcm9taXNlIHRvIHJlc29sdmUgYmVmb3JlIHVzaW5nIHRoaXMgZnVuY3Rpb25cIlxuICAgICk7XG4gIH1cbiAgLy8+PmluY2x1ZGVFbmQoJ2RlYnVnJyk7XG4gIGVsbGlwc29pZCA9IGRlZmF1bHRWYWx1ZShlbGxpcHNvaWQsIEVsbGlwc29pZC5XR1M4NCk7XG5cbiAgdmFyIHh5TGV2ZWwgPSBnZXRUaWxlWFlMZXZlbChyZWN0YW5nbGUpO1xuXG4gIC8vIEdldCB0aGUgdGVycmFpbiBtaW4vbWF4IGZvciB0aGF0IHRpbGVcbiAgdmFyIG1pblRlcnJhaW5IZWlnaHQgPSBBcHByb3hpbWF0ZVRlcnJhaW5IZWlnaHRzLl9kZWZhdWx0TWluVGVycmFpbkhlaWdodDtcbiAgdmFyIG1heFRlcnJhaW5IZWlnaHQgPSBBcHByb3hpbWF0ZVRlcnJhaW5IZWlnaHRzLl9kZWZhdWx0TWF4VGVycmFpbkhlaWdodDtcbiAgaWYgKGRlZmluZWQoeHlMZXZlbCkpIHtcbiAgICB2YXIga2V5ID0geHlMZXZlbC5sZXZlbCArIFwiLVwiICsgeHlMZXZlbC54ICsgXCItXCIgKyB4eUxldmVsLnk7XG4gICAgdmFyIGhlaWdodHMgPSBBcHByb3hpbWF0ZVRlcnJhaW5IZWlnaHRzLl90ZXJyYWluSGVpZ2h0c1trZXldO1xuICAgIGlmIChkZWZpbmVkKGhlaWdodHMpKSB7XG4gICAgICBtaW5UZXJyYWluSGVpZ2h0ID0gaGVpZ2h0c1swXTtcbiAgICAgIG1heFRlcnJhaW5IZWlnaHQgPSBoZWlnaHRzWzFdO1xuICAgIH1cblxuICAgIC8vIENvbXB1dGUgbWluIGJ5IHRha2luZyB0aGUgY2VudGVyIG9mIHRoZSBORS0+U1cgZGlhZ29uYWwgYW5kIGZpbmRpbmcgZGlzdGFuY2UgdG8gdGhlIHN1cmZhY2VcbiAgICBlbGxpcHNvaWQuY2FydG9ncmFwaGljVG9DYXJ0ZXNpYW4oXG4gICAgICBSZWN0YW5nbGUubm9ydGhlYXN0KHJlY3RhbmdsZSwgc2NyYXRjaERpYWdvbmFsQ2FydG9ncmFwaGljKSxcbiAgICAgIHNjcmF0Y2hEaWFnb25hbENhcnRlc2lhbk5FXG4gICAgKTtcbiAgICBlbGxpcHNvaWQuY2FydG9ncmFwaGljVG9DYXJ0ZXNpYW4oXG4gICAgICBSZWN0YW5nbGUuc291dGh3ZXN0KHJlY3RhbmdsZSwgc2NyYXRjaERpYWdvbmFsQ2FydG9ncmFwaGljKSxcbiAgICAgIHNjcmF0Y2hEaWFnb25hbENhcnRlc2lhblNXXG4gICAgKTtcblxuICAgIENhcnRlc2lhbjMubWlkcG9pbnQoXG4gICAgICBzY3JhdGNoRGlhZ29uYWxDYXJ0ZXNpYW5TVyxcbiAgICAgIHNjcmF0Y2hEaWFnb25hbENhcnRlc2lhbk5FLFxuICAgICAgc2NyYXRjaENlbnRlckNhcnRlc2lhblxuICAgICk7XG4gICAgdmFyIHN1cmZhY2VQb3NpdGlvbiA9IGVsbGlwc29pZC5zY2FsZVRvR2VvZGV0aWNTdXJmYWNlKFxuICAgICAgc2NyYXRjaENlbnRlckNhcnRlc2lhbixcbiAgICAgIHNjcmF0Y2hTdXJmYWNlQ2FydGVzaWFuXG4gICAgKTtcbiAgICBpZiAoZGVmaW5lZChzdXJmYWNlUG9zaXRpb24pKSB7XG4gICAgICB2YXIgZGlzdGFuY2UgPSBDYXJ0ZXNpYW4zLmRpc3RhbmNlKFxuICAgICAgICBzY3JhdGNoQ2VudGVyQ2FydGVzaWFuLFxuICAgICAgICBzdXJmYWNlUG9zaXRpb25cbiAgICAgICk7XG4gICAgICBtaW5UZXJyYWluSGVpZ2h0ID0gTWF0aC5taW4obWluVGVycmFpbkhlaWdodCwgLWRpc3RhbmNlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbWluVGVycmFpbkhlaWdodCA9IEFwcHJveGltYXRlVGVycmFpbkhlaWdodHMuX2RlZmF1bHRNaW5UZXJyYWluSGVpZ2h0O1xuICAgIH1cbiAgfVxuXG4gIG1pblRlcnJhaW5IZWlnaHQgPSBNYXRoLm1heChcbiAgICBBcHByb3hpbWF0ZVRlcnJhaW5IZWlnaHRzLl9kZWZhdWx0TWluVGVycmFpbkhlaWdodCxcbiAgICBtaW5UZXJyYWluSGVpZ2h0XG4gICk7XG5cbiAgcmV0dXJuIHtcbiAgICBtaW5pbXVtVGVycmFpbkhlaWdodDogbWluVGVycmFpbkhlaWdodCxcbiAgICBtYXhpbXVtVGVycmFpbkhlaWdodDogbWF4VGVycmFpbkhlaWdodCxcbiAgfTtcbn07XG5cbi8qKlxuICogQ29tcHV0ZXMgdGhlIGJvdW5kaW5nIHNwaGVyZSBiYXNlZCBvbiB0aGUgdGlsZSBoZWlnaHRzIGluIHRoZSByZWN0YW5nbGVcbiAqIEBwYXJhbSB7UmVjdGFuZ2xlfSByZWN0YW5nbGUgVGhlIGJvdW5kaW5nIHJlY3RhbmdsZVxuICogQHBhcmFtIHtFbGxpcHNvaWR9IFtlbGxpcHNvaWQ9RWxsaXBzb2lkLldHUzg0XSBUaGUgZWxsaXBzb2lkXG4gKiBAcmV0dXJuIHtCb3VuZGluZ1NwaGVyZX0gVGhlIHJlc3VsdCBib3VuZGluZyBzcGhlcmVcbiAqL1xuQXBwcm94aW1hdGVUZXJyYWluSGVpZ2h0cy5nZXRCb3VuZGluZ1NwaGVyZSA9IGZ1bmN0aW9uIChyZWN0YW5nbGUsIGVsbGlwc29pZCkge1xuICAvLz4+aW5jbHVkZVN0YXJ0KCdkZWJ1ZycsIHByYWdtYXMuZGVidWcpO1xuICBDaGVjay5kZWZpbmVkKFwicmVjdGFuZ2xlXCIsIHJlY3RhbmdsZSk7XG4gIGlmICghZGVmaW5lZChBcHByb3hpbWF0ZVRlcnJhaW5IZWlnaHRzLl90ZXJyYWluSGVpZ2h0cykpIHtcbiAgICB0aHJvdyBuZXcgRGV2ZWxvcGVyRXJyb3IoXG4gICAgICBcIllvdSBtdXN0IGNhbGwgQXBwcm94aW1hdGVUZXJyYWluSGVpZ2h0cy5pbml0aWFsaXplIGFuZCB3YWl0IGZvciB0aGUgcHJvbWlzZSB0byByZXNvbHZlIGJlZm9yZSB1c2luZyB0aGlzIGZ1bmN0aW9uXCJcbiAgICApO1xuICB9XG4gIC8vPj5pbmNsdWRlRW5kKCdkZWJ1ZycpO1xuICBlbGxpcHNvaWQgPSBkZWZhdWx0VmFsdWUoZWxsaXBzb2lkLCBFbGxpcHNvaWQuV0dTODQpO1xuXG4gIHZhciB4eUxldmVsID0gZ2V0VGlsZVhZTGV2ZWwocmVjdGFuZ2xlKTtcblxuICAvLyBHZXQgdGhlIHRlcnJhaW4gbWF4IGZvciB0aGF0IHRpbGVcbiAgdmFyIG1heFRlcnJhaW5IZWlnaHQgPSBBcHByb3hpbWF0ZVRlcnJhaW5IZWlnaHRzLl9kZWZhdWx0TWF4VGVycmFpbkhlaWdodDtcbiAgaWYgKGRlZmluZWQoeHlMZXZlbCkpIHtcbiAgICB2YXIga2V5ID0geHlMZXZlbC5sZXZlbCArIFwiLVwiICsgeHlMZXZlbC54ICsgXCItXCIgKyB4eUxldmVsLnk7XG4gICAgdmFyIGhlaWdodHMgPSBBcHByb3hpbWF0ZVRlcnJhaW5IZWlnaHRzLl90ZXJyYWluSGVpZ2h0c1trZXldO1xuICAgIGlmIChkZWZpbmVkKGhlaWdodHMpKSB7XG4gICAgICBtYXhUZXJyYWluSGVpZ2h0ID0gaGVpZ2h0c1sxXTtcbiAgICB9XG4gIH1cblxuICB2YXIgcmVzdWx0ID0gQm91bmRpbmdTcGhlcmUuZnJvbVJlY3RhbmdsZTNEKHJlY3RhbmdsZSwgZWxsaXBzb2lkLCAwLjApO1xuICBCb3VuZGluZ1NwaGVyZS5mcm9tUmVjdGFuZ2xlM0QoXG4gICAgcmVjdGFuZ2xlLFxuICAgIGVsbGlwc29pZCxcbiAgICBtYXhUZXJyYWluSGVpZ2h0LFxuICAgIHNjcmF0Y2hCb3VuZGluZ1NwaGVyZVxuICApO1xuXG4gIHJldHVybiBCb3VuZGluZ1NwaGVyZS51bmlvbihyZXN1bHQsIHNjcmF0Y2hCb3VuZGluZ1NwaGVyZSwgcmVzdWx0KTtcbn07XG5cbmZ1bmN0aW9uIGdldFRpbGVYWUxldmVsKHJlY3RhbmdsZSkge1xuICBDYXJ0b2dyYXBoaWMuZnJvbVJhZGlhbnMoXG4gICAgcmVjdGFuZ2xlLmVhc3QsXG4gICAgcmVjdGFuZ2xlLm5vcnRoLFxuICAgIDAuMCxcbiAgICBzY3JhdGNoQ29ybmVyc1swXVxuICApO1xuICBDYXJ0b2dyYXBoaWMuZnJvbVJhZGlhbnMoXG4gICAgcmVjdGFuZ2xlLndlc3QsXG4gICAgcmVjdGFuZ2xlLm5vcnRoLFxuICAgIDAuMCxcbiAgICBzY3JhdGNoQ29ybmVyc1sxXVxuICApO1xuICBDYXJ0b2dyYXBoaWMuZnJvbVJhZGlhbnMoXG4gICAgcmVjdGFuZ2xlLmVhc3QsXG4gICAgcmVjdGFuZ2xlLnNvdXRoLFxuICAgIDAuMCxcbiAgICBzY3JhdGNoQ29ybmVyc1syXVxuICApO1xuICBDYXJ0b2dyYXBoaWMuZnJvbVJhZGlhbnMoXG4gICAgcmVjdGFuZ2xlLndlc3QsXG4gICAgcmVjdGFuZ2xlLnNvdXRoLFxuICAgIDAuMCxcbiAgICBzY3JhdGNoQ29ybmVyc1szXVxuICApO1xuXG4gIC8vIERldGVybWluZSB3aGljaCB0aWxlIHRoZSBib3VuZGluZyByZWN0YW5nbGUgaXMgaW5cbiAgdmFyIGxhc3RMZXZlbFggPSAwLFxuICAgIGxhc3RMZXZlbFkgPSAwO1xuICB2YXIgY3VycmVudFggPSAwLFxuICAgIGN1cnJlbnRZID0gMDtcbiAgdmFyIG1heExldmVsID0gQXBwcm94aW1hdGVUZXJyYWluSGVpZ2h0cy5fdGVycmFpbkhlaWdodHNNYXhMZXZlbDtcbiAgdmFyIGk7XG4gIGZvciAoaSA9IDA7IGkgPD0gbWF4TGV2ZWw7ICsraSkge1xuICAgIHZhciBmYWlsZWQgPSBmYWxzZTtcbiAgICBmb3IgKHZhciBqID0gMDsgaiA8IDQ7ICsraikge1xuICAgICAgdmFyIGNvcm5lciA9IHNjcmF0Y2hDb3JuZXJzW2pdO1xuICAgICAgdGlsaW5nU2NoZW1lLnBvc2l0aW9uVG9UaWxlWFkoY29ybmVyLCBpLCBzY3JhdGNoVGlsZVhZKTtcbiAgICAgIGlmIChqID09PSAwKSB7XG4gICAgICAgIGN1cnJlbnRYID0gc2NyYXRjaFRpbGVYWS54O1xuICAgICAgICBjdXJyZW50WSA9IHNjcmF0Y2hUaWxlWFkueTtcbiAgICAgIH0gZWxzZSBpZiAoY3VycmVudFggIT09IHNjcmF0Y2hUaWxlWFkueCB8fCBjdXJyZW50WSAhPT0gc2NyYXRjaFRpbGVYWS55KSB7XG4gICAgICAgIGZhaWxlZCA9IHRydWU7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChmYWlsZWQpIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIGxhc3RMZXZlbFggPSBjdXJyZW50WDtcbiAgICBsYXN0TGV2ZWxZID0gY3VycmVudFk7XG4gIH1cblxuICBpZiAoaSA9PT0gMCkge1xuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cblxuICByZXR1cm4ge1xuICAgIHg6IGxhc3RMZXZlbFgsXG4gICAgeTogbGFzdExldmVsWSxcbiAgICBsZXZlbDogaSA+IG1heExldmVsID8gbWF4TGV2ZWwgOiBpIC0gMSxcbiAgfTtcbn1cblxuQXBwcm94aW1hdGVUZXJyYWluSGVpZ2h0cy5fdGVycmFpbkhlaWdodHNNYXhMZXZlbCA9IDY7XG5BcHByb3hpbWF0ZVRlcnJhaW5IZWlnaHRzLl9kZWZhdWx0TWF4VGVycmFpbkhlaWdodCA9IDkwMDAuMDtcbkFwcHJveGltYXRlVGVycmFpbkhlaWdodHMuX2RlZmF1bHRNaW5UZXJyYWluSGVpZ2h0ID0gLTEwMDAwMC4wO1xuQXBwcm94aW1hdGVUZXJyYWluSGVpZ2h0cy5fdGVycmFpbkhlaWdodHMgPSB1bmRlZmluZWQ7XG5BcHByb3hpbWF0ZVRlcnJhaW5IZWlnaHRzLl9pbml0UHJvbWlzZSA9IHVuZGVmaW5lZDtcblxuT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoQXBwcm94aW1hdGVUZXJyYWluSGVpZ2h0cywge1xuICAvKipcbiAgICogRGV0ZXJtaW5lcyBpZiB0aGUgdGVycmFpbiBoZWlnaHRzIGFyZSBpbml0aWFsaXplZCBhbmQgcmVhZHkgdG8gdXNlLiBUbyBpbml0aWFsaXplIHRoZSB0ZXJyYWluIGhlaWdodHMsXG4gICAqIGNhbGwge0BsaW5rIEFwcHJveGltYXRlVGVycmFpbkhlaWdodHMjaW5pdGlhbGl6ZX0gYW5kIHdhaXQgZm9yIHRoZSByZXR1cm5lZCBwcm9taXNlIHRvIHJlc29sdmUuXG4gICAqIEB0eXBlIHtCb29sZWFufVxuICAgKiBAcmVhZG9ubHlcbiAgICogQG1lbWJlcm9mIEFwcHJveGltYXRlVGVycmFpbkhlaWdodHNcbiAgICovXG4gIGluaXRpYWxpemVkOiB7XG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gZGVmaW5lZChBcHByb3hpbWF0ZVRlcnJhaW5IZWlnaHRzLl90ZXJyYWluSGVpZ2h0cyk7XG4gICAgfSxcbiAgfSxcbn0pO1xuZXhwb3J0IGRlZmF1bHQgQXBwcm94aW1hdGVUZXJyYWluSGVpZ2h0cztcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///53773\n')},52890:function(__unused_webpack___webpack_module__,__unused_webpack___webpack_exports__,__webpack_require__){eval('/* harmony import */ var _ThirdParty_when_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(13222);\n/* harmony import */ var _Cartesian2_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(60838);\n/* harmony import */ var _Credit_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(52975);\n/* harmony import */ var _defaultValue_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(62200);\n/* harmony import */ var _defined_js__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(82982);\n/* harmony import */ var _DeveloperError_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(12572);\n/* harmony import */ var _Ellipsoid_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(50491);\n/* harmony import */ var _Event_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(14459);\n/* harmony import */ var _GeographicTilingScheme_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(71351);\n/* harmony import */ var _HeightmapEncoding_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(25489);\n/* harmony import */ var _HeightmapTerrainData_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(57134);\n/* harmony import */ var _Rectangle_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(96190);\n/* harmony import */ var _Request_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(22426);\n/* harmony import */ var _RequestState_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(6224);\n/* harmony import */ var _RequestType_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(82968);\n/* harmony import */ var _Resource_js__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(68985);\n/* harmony import */ var _RuntimeError_js__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(9407);\n/* harmony import */ var _TerrainProvider_js__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(1497);\n/* harmony import */ var _TileAvailability_js__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(25707);\n/* harmony import */ var _TileProviderError_js__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(9121);\n/* harmony import */ var _WebMercatorTilingScheme_js__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(42423);\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nvar ALL_CHILDREN = 15;\n\n/**\n * A {@link TerrainProvider} that produces terrain geometry by tessellating height maps\n * retrieved from Elevation Tiles of an an ArcGIS ImageService.\n *\n * @alias ArcGISTiledElevationTerrainProvider\n * @constructor\n *\n * @param {Object} options Object with the following properties:\n * @param {Resource|String|Promise<Resource>|Promise<String>} options.url The URL of the ArcGIS ImageServer service.\n * @param {String} [options.token] The authorization token to use to connect to the service.\n * @param {Ellipsoid} [options.ellipsoid] The ellipsoid.  If the tilingScheme is specified,\n *                    this parameter is ignored and the tiling scheme\'s ellipsoid is used instead.\n *                    If neither parameter is specified, the WGS84 ellipsoid is used.\n *\n * @example\n * var terrainProvider = new Cesium.ArcGISTiledElevationTerrainProvider({\n *   url : \'https://elevation3d.arcgis.com/arcgis/rest/services/WorldElevation3D/Terrain3D/ImageServer\',\n *   token : \'KED1aF_I4UzXOHy3BnhwyBHU4l5oY6rO6walkmHoYqGp4XyIWUd5YZUC1ZrLAzvV40pR6gBXQayh0eFA8m6vPg..\'\n * });\n * viewer.terrainProvider = terrainProvider;\n *\n *  @see TerrainProvider\n */\nfunction ArcGISTiledElevationTerrainProvider(options) {\n  //>>includeStart(\'debug\', pragmas.debug);\n  if (!(0,_defined_js__WEBPACK_IMPORTED_MODULE_20__/* ["default"] */ .Z)(options) || !(0,_defined_js__WEBPACK_IMPORTED_MODULE_20__/* ["default"] */ .Z)(options.url)) {\n    throw new _DeveloperError_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .Z("options.url is required.");\n  }\n  //>>includeEnd(\'debug\');\n\n  this._resource = undefined;\n  this._credit = undefined;\n  this._tilingScheme = undefined;\n  this._levelZeroMaximumGeometricError = undefined;\n  this._maxLevel = undefined;\n  this._terrainDataStructure = undefined;\n  this._ready = false;\n  this._width = undefined;\n  this._height = undefined;\n  this._encoding = undefined;\n  var token = options.token;\n\n  this._hasAvailability = false;\n  this._tilesAvailable = undefined;\n  this._tilesAvailablityLoaded = undefined;\n  this._availableCache = {};\n\n  var that = this;\n  var ellipsoid = (0,_defaultValue_js__WEBPACK_IMPORTED_MODULE_3__/* ["default"] */ .Z)(options.ellipsoid, _Ellipsoid_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"].WGS84 */ .Z.WGS84);\n  this._readyPromise = (0,_ThirdParty_when_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .Z)(options.url)\n    .then(function (url) {\n      var resource = _Resource_js__WEBPACK_IMPORTED_MODULE_14__/* ["default"].createIfNeeded */ .Z.createIfNeeded(url);\n      resource.appendForwardSlash();\n      if ((0,_defined_js__WEBPACK_IMPORTED_MODULE_20__/* ["default"] */ .Z)(token)) {\n        resource = resource.getDerivedResource({\n          queryParameters: {\n            token: token,\n          },\n        });\n      }\n      that._resource = resource;\n\n      var metadataResource = resource.getDerivedResource({\n        queryParameters: {\n          f: "pjson",\n        },\n      });\n\n      return metadataResource.fetchJson();\n    })\n    .then(function (metadata) {\n      var copyrightText = metadata.copyrightText;\n      if ((0,_defined_js__WEBPACK_IMPORTED_MODULE_20__/* ["default"] */ .Z)(copyrightText)) {\n        that._credit = new _Credit_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"] */ .Z(copyrightText);\n      }\n\n      var spatialReference = metadata.spatialReference;\n      var wkid = (0,_defaultValue_js__WEBPACK_IMPORTED_MODULE_3__/* ["default"] */ .Z)(\n        spatialReference.latestWkid,\n        spatialReference.wkid\n      );\n      var extent = metadata.extent;\n      var tilingSchemeOptions = {\n        ellipsoid: ellipsoid,\n      };\n      if (wkid === 4326) {\n        tilingSchemeOptions.rectangle = _Rectangle_js__WEBPACK_IMPORTED_MODULE_10__/* ["default"].fromDegrees */ .Z.fromDegrees(\n          extent.xmin,\n          extent.ymin,\n          extent.xmax,\n          extent.ymax\n        );\n        that._tilingScheme = new _GeographicTilingScheme_js__WEBPACK_IMPORTED_MODULE_7__/* ["default"] */ .Z(tilingSchemeOptions);\n      } else if (wkid === 3857) {\n        tilingSchemeOptions.rectangleSouthwestInMeters = new _Cartesian2_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .Z(\n          extent.xmin,\n          extent.ymin\n        );\n        tilingSchemeOptions.rectangleNortheastInMeters = new _Cartesian2_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .Z(\n          extent.xmax,\n          extent.ymax\n        );\n        that._tilingScheme = new _WebMercatorTilingScheme_js__WEBPACK_IMPORTED_MODULE_19__/* ["default"] */ .Z(tilingSchemeOptions);\n      } else {\n        return _ThirdParty_when_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].reject */ .Z.reject(new _RuntimeError_js__WEBPACK_IMPORTED_MODULE_15__/* ["default"] */ .Z("Invalid spatial reference"));\n      }\n\n      var tileInfo = metadata.tileInfo;\n      if (!(0,_defined_js__WEBPACK_IMPORTED_MODULE_20__/* ["default"] */ .Z)(tileInfo)) {\n        return _ThirdParty_when_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].reject */ .Z.reject(new _RuntimeError_js__WEBPACK_IMPORTED_MODULE_15__/* ["default"] */ .Z("tileInfo is required"));\n      }\n\n      that._width = tileInfo.rows + 1;\n      that._height = tileInfo.cols + 1;\n      that._encoding =\n        tileInfo.format === "LERC"\n          ? _HeightmapEncoding_js__WEBPACK_IMPORTED_MODULE_8__/* ["default"].LERC */ .Z.LERC\n          : _HeightmapEncoding_js__WEBPACK_IMPORTED_MODULE_8__/* ["default"].NONE */ .Z.NONE;\n      that._lodCount = tileInfo.lods.length - 1;\n\n      var hasAvailability = (that._hasAvailability =\n        metadata.capabilities.indexOf("Tilemap") !== -1);\n      if (hasAvailability) {\n        that._tilesAvailable = new _TileAvailability_js__WEBPACK_IMPORTED_MODULE_17__/* ["default"] */ .Z(\n          that._tilingScheme,\n          that._lodCount\n        );\n        that._tilesAvailable.addAvailableTileRange(\n          0,\n          0,\n          0,\n          that._tilingScheme.getNumberOfXTilesAtLevel(0),\n          that._tilingScheme.getNumberOfYTilesAtLevel(0)\n        );\n        that._tilesAvailablityLoaded = new _TileAvailability_js__WEBPACK_IMPORTED_MODULE_17__/* ["default"] */ .Z(\n          that._tilingScheme,\n          that._lodCount\n        );\n      }\n\n      that._levelZeroMaximumGeometricError = _TerrainProvider_js__WEBPACK_IMPORTED_MODULE_16__/* ["default"].getEstimatedLevelZeroGeometricErrorForAHeightmap */ .Z.getEstimatedLevelZeroGeometricErrorForAHeightmap(\n        that._tilingScheme.ellipsoid,\n        that._width,\n        that._tilingScheme.getNumberOfXTilesAtLevel(0)\n      );\n\n      if (metadata.bandCount > 1) {\n        console.log(\n          "ArcGISTiledElevationTerrainProvider: Terrain data has more than 1 band. Using the first one."\n        );\n      }\n\n      that._terrainDataStructure = {\n        elementMultiplier: 1.0,\n        lowestEncodedHeight: metadata.minValues[0],\n        highestEncodedHeight: metadata.maxValues[0],\n      };\n\n      that._ready = true;\n\n      return true;\n    })\n    .otherwise(function (error) {\n      var message =\n        "An error occurred while accessing " + that._resource.url + ".";\n      _TileProviderError_js__WEBPACK_IMPORTED_MODULE_18__/* ["default"].handleError */ .Z.handleError(undefined, that, that._errorEvent, message);\n      return _ThirdParty_when_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].reject */ .Z.reject(error);\n    });\n\n  this._errorEvent = new _Event_js__WEBPACK_IMPORTED_MODULE_6__/* ["default"] */ .Z();\n}\n\nObject.defineProperties(ArcGISTiledElevationTerrainProvider.prototype, {\n  /**\n   * Gets an event that is raised when the terrain provider encounters an asynchronous error.  By subscribing\n   * to the event, you will be notified of the error and can potentially recover from it.  Event listeners\n   * are passed an instance of {@link TileProviderError}.\n   * @memberof ArcGISTiledElevationTerrainProvider.prototype\n   * @type {Event}\n   * @readonly\n   */\n  errorEvent: {\n    get: function () {\n      return this._errorEvent;\n    },\n  },\n\n  /**\n   * Gets the credit to display when this terrain provider is active.  Typically this is used to credit\n   * the source of the terrain.  This function should not be called before {@link ArcGISTiledElevationTerrainProvider#ready} returns true.\n   * @memberof ArcGISTiledElevationTerrainProvider.prototype\n   * @type {Credit}\n   * @readonly\n   */\n  credit: {\n    get: function () {\n      //>>includeStart(\'debug\', pragmas.debug);\n      if (!this.ready) {\n        throw new _DeveloperError_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .Z(\n          "credit must not be called before ready returns true."\n        );\n      }\n      //>>includeEnd(\'debug\');\n      return this._credit;\n    },\n  },\n\n  /**\n   * Gets the tiling scheme used by this provider.  This function should\n   * not be called before {@link ArcGISTiledElevationTerrainProvider#ready} returns true.\n   * @memberof ArcGISTiledElevationTerrainProvider.prototype\n   * @type {GeographicTilingScheme}\n   * @readonly\n   */\n  tilingScheme: {\n    get: function () {\n      //>>includeStart(\'debug\', pragmas.debug);\n      if (!this.ready) {\n        throw new _DeveloperError_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .Z(\n          "tilingScheme must not be called before ready returns true."\n        );\n      }\n      //>>includeEnd(\'debug\');\n      return this._tilingScheme;\n    },\n  },\n\n  /**\n   * Gets a value indicating whether or not the provider is ready for use.\n   * @memberof ArcGISTiledElevationTerrainProvider.prototype\n   * @type {Boolean}\n   * @readonly\n   */\n  ready: {\n    get: function () {\n      return this._ready;\n    },\n  },\n\n  /**\n   * Gets a promise that resolves to true when the provider is ready for use.\n   * @memberof ArcGISTiledElevationTerrainProvider.prototype\n   * @type {Promise.<Boolean>}\n   * @readonly\n   */\n  readyPromise: {\n    get: function () {\n      return this._readyPromise;\n    },\n  },\n\n  /**\n   * Gets a value indicating whether or not the provider includes a water mask.  The water mask\n   * indicates which areas of the globe are water rather than land, so they can be rendered\n   * as a reflective surface with animated waves.  This function should not be\n   * called before {@link ArcGISTiledElevationTerrainProvider#ready} returns true.\n   * @memberof ArcGISTiledElevationTerrainProvider.prototype\n   * @type {Boolean}\n   * @readonly\n   */\n  hasWaterMask: {\n    get: function () {\n      return false;\n    },\n  },\n\n  /**\n   * Gets a value indicating whether or not the requested tiles include vertex normals.\n   * This function should not be called before {@link ArcGISTiledElevationTerrainProvider#ready} returns true.\n   * @memberof ArcGISTiledElevationTerrainProvider.prototype\n   * @type {Boolean}\n   * @readonly\n   */\n  hasVertexNormals: {\n    get: function () {\n      return false;\n    },\n  },\n  /**\n   * Gets an object that can be used to determine availability of terrain from this provider, such as\n   * at points and in rectangles.  This function should not be called before\n   * {@link TerrainProvider#ready} returns true.  This property may be undefined if availability\n   * information is not available.\n   * @memberof ArcGISTiledElevationTerrainProvider.prototype\n   * @type {TileAvailability}\n   * @readonly\n   */\n  availability: {\n    get: function () {\n      //>>includeStart(\'debug\', pragmas.debug)\n      if (!this._ready) {\n        throw new _DeveloperError_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .Z(\n          "availability must not be called before the terrain provider is ready."\n        );\n      }\n      //>>includeEnd(\'debug\');\n      return this._tilesAvailable;\n    },\n  },\n});\n\n/**\n * Requests the geometry for a given tile.  This function should not be called before\n * {@link ArcGISTiledElevationTerrainProvider#ready} returns true.  The result includes terrain\n * data and indicates that all child tiles are available.\n *\n * @param {Number} x The X coordinate of the tile for which to request geometry.\n * @param {Number} y The Y coordinate of the tile for which to request geometry.\n * @param {Number} level The level of the tile for which to request geometry.\n * @param {Request} [request] The request object. Intended for internal use only.\n * @returns {Promise.<TerrainData>|undefined} A promise for the requested geometry.  If this method\n *          returns undefined instead of a promise, it is an indication that too many requests are already\n *          pending and the request will be retried later.\n */\nArcGISTiledElevationTerrainProvider.prototype.requestTileGeometry = function (\n  x,\n  y,\n  level,\n  request\n) {\n  //>>includeStart(\'debug\', pragmas.debug)\n  if (!this._ready) {\n    throw new _DeveloperError_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .Z(\n      "requestTileGeometry must not be called before the terrain provider is ready."\n    );\n  }\n  //>>includeEnd(\'debug\');\n\n  var tileResource = this._resource.getDerivedResource({\n    url: "tile/" + level + "/" + y + "/" + x,\n    request: request,\n  });\n\n  var hasAvailability = this._hasAvailability;\n  var availabilityPromise = _ThirdParty_when_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].resolve */ .Z.resolve(true);\n  var availabilityRequest;\n  if (\n    hasAvailability &&\n    !(0,_defined_js__WEBPACK_IMPORTED_MODULE_20__/* ["default"] */ .Z)(isTileAvailable(this, level + 1, x * 2, y * 2))\n  ) {\n    // We need to load child availability\n    var availabilityResult = requestAvailability(this, level + 1, x * 2, y * 2);\n\n    availabilityPromise = availabilityResult.promise;\n    availabilityRequest = availabilityResult.request;\n  }\n\n  var promise = tileResource.fetchArrayBuffer();\n  if (!(0,_defined_js__WEBPACK_IMPORTED_MODULE_20__/* ["default"] */ .Z)(promise) || !(0,_defined_js__WEBPACK_IMPORTED_MODULE_20__/* ["default"] */ .Z)(availabilityPromise)) {\n    return undefined;\n  }\n\n  var that = this;\n  var tilesAvailable = this._tilesAvailable;\n  return _ThirdParty_when_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].join */ .Z.join(promise, availabilityPromise)\n    .then(function (result) {\n      return new _HeightmapTerrainData_js__WEBPACK_IMPORTED_MODULE_9__/* ["default"] */ .Z({\n        buffer: result[0],\n        width: that._width,\n        height: that._height,\n        childTileMask: hasAvailability\n          ? tilesAvailable.computeChildMaskForTile(level, x, y)\n          : ALL_CHILDREN,\n        structure: that._terrainDataStructure,\n        encoding: that._encoding,\n      });\n    })\n    .otherwise(function (error) {\n      if (\n        (0,_defined_js__WEBPACK_IMPORTED_MODULE_20__/* ["default"] */ .Z)(availabilityRequest) &&\n        availabilityRequest.state === _RequestState_js__WEBPACK_IMPORTED_MODULE_12__/* ["default"].CANCELLED */ .Z.CANCELLED\n      ) {\n        request.cancel();\n\n        // Don\'t reject the promise till the request is actually cancelled\n        // Otherwise it will think the request failed, but it didn\'t.\n        return request.deferred.promise.always(function () {\n          request.state = _RequestState_js__WEBPACK_IMPORTED_MODULE_12__/* ["default"].CANCELLED */ .Z.CANCELLED;\n          return _ThirdParty_when_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].reject */ .Z.reject(error);\n        });\n      }\n      return _ThirdParty_when_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].reject */ .Z.reject(error);\n    });\n};\n\nfunction isTileAvailable(that, level, x, y) {\n  if (!that._hasAvailability) {\n    return undefined;\n  }\n\n  var tilesAvailablityLoaded = that._tilesAvailablityLoaded;\n  var tilesAvailable = that._tilesAvailable;\n\n  if (level > that._lodCount) {\n    return false;\n  }\n\n  // Check if tiles are known to be available\n  if (tilesAvailable.isTileAvailable(level, x, y)) {\n    return true;\n  }\n\n  // or to not be available\n  if (tilesAvailablityLoaded.isTileAvailable(level, x, y)) {\n    return false;\n  }\n\n  return undefined;\n}\n\n/**\n * Gets the maximum geometric error allowed in a tile at a given level.\n *\n * @param {Number} level The tile level for which to get the maximum geometric error.\n * @returns {Number} The maximum geometric error.\n */\nArcGISTiledElevationTerrainProvider.prototype.getLevelMaximumGeometricError = function (\n  level\n) {\n  //>>includeStart(\'debug\', pragmas.debug);\n  if (!this.ready) {\n    throw new _DeveloperError_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .Z(\n      "getLevelMaximumGeometricError must not be called before ready returns true."\n    );\n  }\n  //>>includeEnd(\'debug\');\n\n  return this._levelZeroMaximumGeometricError / (1 << level);\n};\n\n/**\n * Determines whether data for a tile is available to be loaded.\n *\n * @param {Number} x The X coordinate of the tile for which to request geometry.\n * @param {Number} y The Y coordinate of the tile for which to request geometry.\n * @param {Number} level The level of the tile for which to request geometry.\n * @returns {Boolean|undefined} Undefined if not supported, otherwise true or false.\n */\nArcGISTiledElevationTerrainProvider.prototype.getTileDataAvailable = function (\n  x,\n  y,\n  level\n) {\n  if (!this._hasAvailability) {\n    return undefined;\n  }\n\n  var result = isTileAvailable(this, level, x, y);\n  if ((0,_defined_js__WEBPACK_IMPORTED_MODULE_20__/* ["default"] */ .Z)(result)) {\n    return result;\n  }\n\n  requestAvailability(this, level, x, y);\n\n  return undefined;\n};\n\n/**\n * Makes sure we load availability data for a tile\n *\n * @param {Number} x The X coordinate of the tile for which to request geometry.\n * @param {Number} y The Y coordinate of the tile for which to request geometry.\n * @param {Number} level The level of the tile for which to request geometry.\n * @returns {undefined|Promise<void>} Undefined if nothing need to be loaded or a Promise that resolves when all required tiles are loaded\n */\nArcGISTiledElevationTerrainProvider.prototype.loadTileDataAvailability = function (\n  x,\n  y,\n  level\n) {\n  return undefined;\n};\n\nfunction findRange(origin, width, height, data) {\n  var endCol = width - 1;\n  var endRow = height - 1;\n\n  var value = data[origin.y * width + origin.x];\n  var endingIndices = [];\n  var range = {\n    startX: origin.x,\n    startY: origin.y,\n    endX: 0,\n    endY: 0,\n  };\n\n  var corner = new _Cartesian2_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .Z(origin.x + 1, origin.y + 1);\n  var doneX = false;\n  var doneY = false;\n  while (!(doneX && doneY)) {\n    // We want to use the original value when checking Y,\n    //  so get it before it possibly gets incremented\n    var endX = corner.x;\n\n    // If we no longer move in the Y direction we need to check the corner tile in X pass\n    var endY = doneY ? corner.y + 1 : corner.y;\n\n    // Check X range\n    if (!doneX) {\n      for (var y = origin.y; y < endY; ++y) {\n        if (data[y * width + corner.x] !== value) {\n          doneX = true;\n          break;\n        }\n      }\n\n      if (doneX) {\n        endingIndices.push(new _Cartesian2_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .Z(corner.x, origin.y));\n\n        // Use the last good column so we can continue with Y\n        --corner.x;\n        --endX;\n        range.endX = corner.x;\n      } else if (corner.x === endCol) {\n        range.endX = corner.x;\n        doneX = true;\n      } else {\n        ++corner.x;\n      }\n    }\n\n    // Check Y range - The corner tile is checked here\n    if (!doneY) {\n      var col = corner.y * width;\n      for (var x = origin.x; x <= endX; ++x) {\n        if (data[col + x] !== value) {\n          doneY = true;\n          break;\n        }\n      }\n\n      if (doneY) {\n        endingIndices.push(new _Cartesian2_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .Z(origin.x, corner.y));\n\n        // Use the last good row so we can continue with X\n        --corner.y;\n        range.endY = corner.y;\n      } else if (corner.y === endRow) {\n        range.endY = corner.y;\n        doneY = true;\n      } else {\n        ++corner.y;\n      }\n    }\n  }\n\n  return {\n    endingIndices: endingIndices,\n    range: range,\n    value: value,\n  };\n}\n\nfunction computeAvailability(x, y, width, height, data) {\n  var ranges = [];\n\n  var singleValue = data.every(function (val) {\n    return val === data[0];\n  });\n  if (singleValue) {\n    if (data[0] === 1) {\n      ranges.push({\n        startX: x,\n        startY: y,\n        endX: x + width - 1,\n        endY: y + height - 1,\n      });\n    }\n\n    return ranges;\n  }\n\n  var positions = [new _Cartesian2_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .Z(0, 0)];\n  while (positions.length > 0) {\n    var origin = positions.pop();\n    var result = findRange(origin, width, height, data);\n\n    if (result.value === 1) {\n      // Convert range into the array into global tile coordinates\n      var range = result.range;\n      range.startX += x;\n      range.endX += x;\n      range.startY += y;\n      range.endY += y;\n      ranges.push(range);\n    }\n\n    var endingIndices = result.endingIndices;\n    if (endingIndices.length > 0) {\n      positions = positions.concat(endingIndices);\n    }\n  }\n\n  return ranges;\n}\n\nfunction requestAvailability(that, level, x, y) {\n  if (!that._hasAvailability) {\n    return {};\n  }\n\n  // Fetch 128x128 availability list, so we make the minimum amount of requests\n  var xOffset = Math.floor(x / 128) * 128;\n  var yOffset = Math.floor(y / 128) * 128;\n\n  var dim = Math.min(1 << level, 128);\n  var url =\n    "tilemap/" + level + "/" + yOffset + "/" + xOffset + "/" + dim + "/" + dim;\n\n  var availableCache = that._availableCache;\n  if ((0,_defined_js__WEBPACK_IMPORTED_MODULE_20__/* ["default"] */ .Z)(availableCache[url])) {\n    return availableCache[url];\n  }\n\n  var request = new _Request_js__WEBPACK_IMPORTED_MODULE_11__/* ["default"] */ .Z({\n    throttle: false,\n    throttleByServer: true,\n    type: _RequestType_js__WEBPACK_IMPORTED_MODULE_13__/* ["default"].TERRAIN */ .Z.TERRAIN,\n  });\n\n  var tilemapResource = that._resource.getDerivedResource({\n    url: url,\n    request: request,\n  });\n\n  var promise = tilemapResource.fetchJson();\n  if (!(0,_defined_js__WEBPACK_IMPORTED_MODULE_20__/* ["default"] */ .Z)(promise)) {\n    return {};\n  }\n\n  promise = promise.then(function (result) {\n    var available = computeAvailability(\n      xOffset,\n      yOffset,\n      dim,\n      dim,\n      result.data\n    );\n\n    // Mark whole area as having availability loaded\n    that._tilesAvailablityLoaded.addAvailableTileRange(\n      level,\n      xOffset,\n      yOffset,\n      xOffset + dim,\n      yOffset + dim\n    );\n\n    var tilesAvailable = that._tilesAvailable;\n    for (var i = 0; i < available.length; ++i) {\n      var range = available[i];\n      tilesAvailable.addAvailableTileRange(\n        level,\n        range.startX,\n        range.startY,\n        range.endX,\n        range.endY\n      );\n    }\n\n    // Conveniently return availability of original tile\n    return isTileAvailable(that, level, x, y);\n  });\n\n  availableCache[url] = {\n    promise: promise,\n    request: request,\n  };\n\n  promise = promise.always(function (result) {\n    delete availableCache[url];\n\n    return result;\n  });\n\n  return {\n    promise: promise,\n    request: request,\n  };\n}\n/* unused harmony default export */ var __WEBPACK_DEFAULT_EXPORT__ = ((/* unused pure expression or super */ null && (ArcGISTiledElevationTerrainProvider)));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0VBQWUsbUZBQW1DLElBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly92dWUzLXdlYnBhY2s1Ly4vbm9kZV9tb2R1bGVzL2Nlc2l1bS9Tb3VyY2UvQ29yZS9BcmNHSVNUaWxlZEVsZXZhdGlvblRlcnJhaW5Qcm92aWRlci5qcz8wNzA4Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB3aGVuIGZyb20gXCIuLi9UaGlyZFBhcnR5L3doZW4uanNcIjtcbmltcG9ydCBDYXJ0ZXNpYW4yIGZyb20gXCIuL0NhcnRlc2lhbjIuanNcIjtcbmltcG9ydCBDcmVkaXQgZnJvbSBcIi4vQ3JlZGl0LmpzXCI7XG5pbXBvcnQgZGVmYXVsdFZhbHVlIGZyb20gXCIuL2RlZmF1bHRWYWx1ZS5qc1wiO1xuaW1wb3J0IGRlZmluZWQgZnJvbSBcIi4vZGVmaW5lZC5qc1wiO1xuaW1wb3J0IERldmVsb3BlckVycm9yIGZyb20gXCIuL0RldmVsb3BlckVycm9yLmpzXCI7XG5pbXBvcnQgRWxsaXBzb2lkIGZyb20gXCIuL0VsbGlwc29pZC5qc1wiO1xuaW1wb3J0IEV2ZW50IGZyb20gXCIuL0V2ZW50LmpzXCI7XG5pbXBvcnQgR2VvZ3JhcGhpY1RpbGluZ1NjaGVtZSBmcm9tIFwiLi9HZW9ncmFwaGljVGlsaW5nU2NoZW1lLmpzXCI7XG5pbXBvcnQgSGVpZ2h0bWFwRW5jb2RpbmcgZnJvbSBcIi4vSGVpZ2h0bWFwRW5jb2RpbmcuanNcIjtcbmltcG9ydCBIZWlnaHRtYXBUZXJyYWluRGF0YSBmcm9tIFwiLi9IZWlnaHRtYXBUZXJyYWluRGF0YS5qc1wiO1xuaW1wb3J0IFJlY3RhbmdsZSBmcm9tIFwiLi9SZWN0YW5nbGUuanNcIjtcbmltcG9ydCBSZXF1ZXN0IGZyb20gXCIuL1JlcXVlc3QuanNcIjtcbmltcG9ydCBSZXF1ZXN0U3RhdGUgZnJvbSBcIi4vUmVxdWVzdFN0YXRlLmpzXCI7XG5pbXBvcnQgUmVxdWVzdFR5cGUgZnJvbSBcIi4vUmVxdWVzdFR5cGUuanNcIjtcbmltcG9ydCBSZXNvdXJjZSBmcm9tIFwiLi9SZXNvdXJjZS5qc1wiO1xuaW1wb3J0IFJ1bnRpbWVFcnJvciBmcm9tIFwiLi9SdW50aW1lRXJyb3IuanNcIjtcbmltcG9ydCBUZXJyYWluUHJvdmlkZXIgZnJvbSBcIi4vVGVycmFpblByb3ZpZGVyLmpzXCI7XG5pbXBvcnQgVGlsZUF2YWlsYWJpbGl0eSBmcm9tIFwiLi9UaWxlQXZhaWxhYmlsaXR5LmpzXCI7XG5pbXBvcnQgVGlsZVByb3ZpZGVyRXJyb3IgZnJvbSBcIi4vVGlsZVByb3ZpZGVyRXJyb3IuanNcIjtcbmltcG9ydCBXZWJNZXJjYXRvclRpbGluZ1NjaGVtZSBmcm9tIFwiLi9XZWJNZXJjYXRvclRpbGluZ1NjaGVtZS5qc1wiO1xuXG52YXIgQUxMX0NISUxEUkVOID0gMTU7XG5cbi8qKlxuICogQSB7QGxpbmsgVGVycmFpblByb3ZpZGVyfSB0aGF0IHByb2R1Y2VzIHRlcnJhaW4gZ2VvbWV0cnkgYnkgdGVzc2VsbGF0aW5nIGhlaWdodCBtYXBzXG4gKiByZXRyaWV2ZWQgZnJvbSBFbGV2YXRpb24gVGlsZXMgb2YgYW4gYW4gQXJjR0lTIEltYWdlU2VydmljZS5cbiAqXG4gKiBAYWxpYXMgQXJjR0lTVGlsZWRFbGV2YXRpb25UZXJyYWluUHJvdmlkZXJcbiAqIEBjb25zdHJ1Y3RvclxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIE9iamVjdCB3aXRoIHRoZSBmb2xsb3dpbmcgcHJvcGVydGllczpcbiAqIEBwYXJhbSB7UmVzb3VyY2V8U3RyaW5nfFByb21pc2U8UmVzb3VyY2U+fFByb21pc2U8U3RyaW5nPn0gb3B0aW9ucy51cmwgVGhlIFVSTCBvZiB0aGUgQXJjR0lTIEltYWdlU2VydmVyIHNlcnZpY2UuXG4gKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMudG9rZW5dIFRoZSBhdXRob3JpemF0aW9uIHRva2VuIHRvIHVzZSB0byBjb25uZWN0IHRvIHRoZSBzZXJ2aWNlLlxuICogQHBhcmFtIHtFbGxpcHNvaWR9IFtvcHRpb25zLmVsbGlwc29pZF0gVGhlIGVsbGlwc29pZC4gIElmIHRoZSB0aWxpbmdTY2hlbWUgaXMgc3BlY2lmaWVkLFxuICogICAgICAgICAgICAgICAgICAgIHRoaXMgcGFyYW1ldGVyIGlzIGlnbm9yZWQgYW5kIHRoZSB0aWxpbmcgc2NoZW1lJ3MgZWxsaXBzb2lkIGlzIHVzZWQgaW5zdGVhZC5cbiAqICAgICAgICAgICAgICAgICAgICBJZiBuZWl0aGVyIHBhcmFtZXRlciBpcyBzcGVjaWZpZWQsIHRoZSBXR1M4NCBlbGxpcHNvaWQgaXMgdXNlZC5cbiAqXG4gKiBAZXhhbXBsZVxuICogdmFyIHRlcnJhaW5Qcm92aWRlciA9IG5ldyBDZXNpdW0uQXJjR0lTVGlsZWRFbGV2YXRpb25UZXJyYWluUHJvdmlkZXIoe1xuICogICB1cmwgOiAnaHR0cHM6Ly9lbGV2YXRpb24zZC5hcmNnaXMuY29tL2FyY2dpcy9yZXN0L3NlcnZpY2VzL1dvcmxkRWxldmF0aW9uM0QvVGVycmFpbjNEL0ltYWdlU2VydmVyJyxcbiAqICAgdG9rZW4gOiAnS0VEMWFGX0k0VXpYT0h5M0JuaHd5QkhVNGw1b1k2ck82d2Fsa21Ib1lxR3A0WHlJV1VkNVlaVUMxWnJMQXp2VjQwcFI2Z0JYUWF5aDBlRkE4bTZ2UGcuLidcbiAqIH0pO1xuICogdmlld2VyLnRlcnJhaW5Qcm92aWRlciA9IHRlcnJhaW5Qcm92aWRlcjtcbiAqXG4gKiAgQHNlZSBUZXJyYWluUHJvdmlkZXJcbiAqL1xuZnVuY3Rpb24gQXJjR0lTVGlsZWRFbGV2YXRpb25UZXJyYWluUHJvdmlkZXIob3B0aW9ucykge1xuICAvLz4+aW5jbHVkZVN0YXJ0KCdkZWJ1ZycsIHByYWdtYXMuZGVidWcpO1xuICBpZiAoIWRlZmluZWQob3B0aW9ucykgfHwgIWRlZmluZWQob3B0aW9ucy51cmwpKSB7XG4gICAgdGhyb3cgbmV3IERldmVsb3BlckVycm9yKFwib3B0aW9ucy51cmwgaXMgcmVxdWlyZWQuXCIpO1xuICB9XG4gIC8vPj5pbmNsdWRlRW5kKCdkZWJ1ZycpO1xuXG4gIHRoaXMuX3Jlc291cmNlID0gdW5kZWZpbmVkO1xuICB0aGlzLl9jcmVkaXQgPSB1bmRlZmluZWQ7XG4gIHRoaXMuX3RpbGluZ1NjaGVtZSA9IHVuZGVmaW5lZDtcbiAgdGhpcy5fbGV2ZWxaZXJvTWF4aW11bUdlb21ldHJpY0Vycm9yID0gdW5kZWZpbmVkO1xuICB0aGlzLl9tYXhMZXZlbCA9IHVuZGVmaW5lZDtcbiAgdGhpcy5fdGVycmFpbkRhdGFTdHJ1Y3R1cmUgPSB1bmRlZmluZWQ7XG4gIHRoaXMuX3JlYWR5ID0gZmFsc2U7XG4gIHRoaXMuX3dpZHRoID0gdW5kZWZpbmVkO1xuICB0aGlzLl9oZWlnaHQgPSB1bmRlZmluZWQ7XG4gIHRoaXMuX2VuY29kaW5nID0gdW5kZWZpbmVkO1xuICB2YXIgdG9rZW4gPSBvcHRpb25zLnRva2VuO1xuXG4gIHRoaXMuX2hhc0F2YWlsYWJpbGl0eSA9IGZhbHNlO1xuICB0aGlzLl90aWxlc0F2YWlsYWJsZSA9IHVuZGVmaW5lZDtcbiAgdGhpcy5fdGlsZXNBdmFpbGFibGl0eUxvYWRlZCA9IHVuZGVmaW5lZDtcbiAgdGhpcy5fYXZhaWxhYmxlQ2FjaGUgPSB7fTtcblxuICB2YXIgdGhhdCA9IHRoaXM7XG4gIHZhciBlbGxpcHNvaWQgPSBkZWZhdWx0VmFsdWUob3B0aW9ucy5lbGxpcHNvaWQsIEVsbGlwc29pZC5XR1M4NCk7XG4gIHRoaXMuX3JlYWR5UHJvbWlzZSA9IHdoZW4ob3B0aW9ucy51cmwpXG4gICAgLnRoZW4oZnVuY3Rpb24gKHVybCkge1xuICAgICAgdmFyIHJlc291cmNlID0gUmVzb3VyY2UuY3JlYXRlSWZOZWVkZWQodXJsKTtcbiAgICAgIHJlc291cmNlLmFwcGVuZEZvcndhcmRTbGFzaCgpO1xuICAgICAgaWYgKGRlZmluZWQodG9rZW4pKSB7XG4gICAgICAgIHJlc291cmNlID0gcmVzb3VyY2UuZ2V0RGVyaXZlZFJlc291cmNlKHtcbiAgICAgICAgICBxdWVyeVBhcmFtZXRlcnM6IHtcbiAgICAgICAgICAgIHRva2VuOiB0b2tlbixcbiAgICAgICAgICB9LFxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIHRoYXQuX3Jlc291cmNlID0gcmVzb3VyY2U7XG5cbiAgICAgIHZhciBtZXRhZGF0YVJlc291cmNlID0gcmVzb3VyY2UuZ2V0RGVyaXZlZFJlc291cmNlKHtcbiAgICAgICAgcXVlcnlQYXJhbWV0ZXJzOiB7XG4gICAgICAgICAgZjogXCJwanNvblwiLFxuICAgICAgICB9LFxuICAgICAgfSk7XG5cbiAgICAgIHJldHVybiBtZXRhZGF0YVJlc291cmNlLmZldGNoSnNvbigpO1xuICAgIH0pXG4gICAgLnRoZW4oZnVuY3Rpb24gKG1ldGFkYXRhKSB7XG4gICAgICB2YXIgY29weXJpZ2h0VGV4dCA9IG1ldGFkYXRhLmNvcHlyaWdodFRleHQ7XG4gICAgICBpZiAoZGVmaW5lZChjb3B5cmlnaHRUZXh0KSkge1xuICAgICAgICB0aGF0Ll9jcmVkaXQgPSBuZXcgQ3JlZGl0KGNvcHlyaWdodFRleHQpO1xuICAgICAgfVxuXG4gICAgICB2YXIgc3BhdGlhbFJlZmVyZW5jZSA9IG1ldGFkYXRhLnNwYXRpYWxSZWZlcmVuY2U7XG4gICAgICB2YXIgd2tpZCA9IGRlZmF1bHRWYWx1ZShcbiAgICAgICAgc3BhdGlhbFJlZmVyZW5jZS5sYXRlc3RXa2lkLFxuICAgICAgICBzcGF0aWFsUmVmZXJlbmNlLndraWRcbiAgICAgICk7XG4gICAgICB2YXIgZXh0ZW50ID0gbWV0YWRhdGEuZXh0ZW50O1xuICAgICAgdmFyIHRpbGluZ1NjaGVtZU9wdGlvbnMgPSB7XG4gICAgICAgIGVsbGlwc29pZDogZWxsaXBzb2lkLFxuICAgICAgfTtcbiAgICAgIGlmICh3a2lkID09PSA0MzI2KSB7XG4gICAgICAgIHRpbGluZ1NjaGVtZU9wdGlvbnMucmVjdGFuZ2xlID0gUmVjdGFuZ2xlLmZyb21EZWdyZWVzKFxuICAgICAgICAgIGV4dGVudC54bWluLFxuICAgICAgICAgIGV4dGVudC55bWluLFxuICAgICAgICAgIGV4dGVudC54bWF4LFxuICAgICAgICAgIGV4dGVudC55bWF4XG4gICAgICAgICk7XG4gICAgICAgIHRoYXQuX3RpbGluZ1NjaGVtZSA9IG5ldyBHZW9ncmFwaGljVGlsaW5nU2NoZW1lKHRpbGluZ1NjaGVtZU9wdGlvbnMpO1xuICAgICAgfSBlbHNlIGlmICh3a2lkID09PSAzODU3KSB7XG4gICAgICAgIHRpbGluZ1NjaGVtZU9wdGlvbnMucmVjdGFuZ2xlU291dGh3ZXN0SW5NZXRlcnMgPSBuZXcgQ2FydGVzaWFuMihcbiAgICAgICAgICBleHRlbnQueG1pbixcbiAgICAgICAgICBleHRlbnQueW1pblxuICAgICAgICApO1xuICAgICAgICB0aWxpbmdTY2hlbWVPcHRpb25zLnJlY3RhbmdsZU5vcnRoZWFzdEluTWV0ZXJzID0gbmV3IENhcnRlc2lhbjIoXG4gICAgICAgICAgZXh0ZW50LnhtYXgsXG4gICAgICAgICAgZXh0ZW50LnltYXhcbiAgICAgICAgKTtcbiAgICAgICAgdGhhdC5fdGlsaW5nU2NoZW1lID0gbmV3IFdlYk1lcmNhdG9yVGlsaW5nU2NoZW1lKHRpbGluZ1NjaGVtZU9wdGlvbnMpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHdoZW4ucmVqZWN0KG5ldyBSdW50aW1lRXJyb3IoXCJJbnZhbGlkIHNwYXRpYWwgcmVmZXJlbmNlXCIpKTtcbiAgICAgIH1cblxuICAgICAgdmFyIHRpbGVJbmZvID0gbWV0YWRhdGEudGlsZUluZm87XG4gICAgICBpZiAoIWRlZmluZWQodGlsZUluZm8pKSB7XG4gICAgICAgIHJldHVybiB3aGVuLnJlamVjdChuZXcgUnVudGltZUVycm9yKFwidGlsZUluZm8gaXMgcmVxdWlyZWRcIikpO1xuICAgICAgfVxuXG4gICAgICB0aGF0Ll93aWR0aCA9IHRpbGVJbmZvLnJvd3MgKyAxO1xuICAgICAgdGhhdC5faGVpZ2h0ID0gdGlsZUluZm8uY29scyArIDE7XG4gICAgICB0aGF0Ll9lbmNvZGluZyA9XG4gICAgICAgIHRpbGVJbmZvLmZvcm1hdCA9PT0gXCJMRVJDXCJcbiAgICAgICAgICA/IEhlaWdodG1hcEVuY29kaW5nLkxFUkNcbiAgICAgICAgICA6IEhlaWdodG1hcEVuY29kaW5nLk5PTkU7XG4gICAgICB0aGF0Ll9sb2RDb3VudCA9IHRpbGVJbmZvLmxvZHMubGVuZ3RoIC0gMTtcblxuICAgICAgdmFyIGhhc0F2YWlsYWJpbGl0eSA9ICh0aGF0Ll9oYXNBdmFpbGFiaWxpdHkgPVxuICAgICAgICBtZXRhZGF0YS5jYXBhYmlsaXRpZXMuaW5kZXhPZihcIlRpbGVtYXBcIikgIT09IC0xKTtcbiAgICAgIGlmIChoYXNBdmFpbGFiaWxpdHkpIHtcbiAgICAgICAgdGhhdC5fdGlsZXNBdmFpbGFibGUgPSBuZXcgVGlsZUF2YWlsYWJpbGl0eShcbiAgICAgICAgICB0aGF0Ll90aWxpbmdTY2hlbWUsXG4gICAgICAgICAgdGhhdC5fbG9kQ291bnRcbiAgICAgICAgKTtcbiAgICAgICAgdGhhdC5fdGlsZXNBdmFpbGFibGUuYWRkQXZhaWxhYmxlVGlsZVJhbmdlKFxuICAgICAgICAgIDAsXG4gICAgICAgICAgMCxcbiAgICAgICAgICAwLFxuICAgICAgICAgIHRoYXQuX3RpbGluZ1NjaGVtZS5nZXROdW1iZXJPZlhUaWxlc0F0TGV2ZWwoMCksXG4gICAgICAgICAgdGhhdC5fdGlsaW5nU2NoZW1lLmdldE51bWJlck9mWVRpbGVzQXRMZXZlbCgwKVxuICAgICAgICApO1xuICAgICAgICB0aGF0Ll90aWxlc0F2YWlsYWJsaXR5TG9hZGVkID0gbmV3IFRpbGVBdmFpbGFiaWxpdHkoXG4gICAgICAgICAgdGhhdC5fdGlsaW5nU2NoZW1lLFxuICAgICAgICAgIHRoYXQuX2xvZENvdW50XG4gICAgICAgICk7XG4gICAgICB9XG5cbiAgICAgIHRoYXQuX2xldmVsWmVyb01heGltdW1HZW9tZXRyaWNFcnJvciA9IFRlcnJhaW5Qcm92aWRlci5nZXRFc3RpbWF0ZWRMZXZlbFplcm9HZW9tZXRyaWNFcnJvckZvckFIZWlnaHRtYXAoXG4gICAgICAgIHRoYXQuX3RpbGluZ1NjaGVtZS5lbGxpcHNvaWQsXG4gICAgICAgIHRoYXQuX3dpZHRoLFxuICAgICAgICB0aGF0Ll90aWxpbmdTY2hlbWUuZ2V0TnVtYmVyT2ZYVGlsZXNBdExldmVsKDApXG4gICAgICApO1xuXG4gICAgICBpZiAobWV0YWRhdGEuYmFuZENvdW50ID4gMSkge1xuICAgICAgICBjb25zb2xlLmxvZyhcbiAgICAgICAgICBcIkFyY0dJU1RpbGVkRWxldmF0aW9uVGVycmFpblByb3ZpZGVyOiBUZXJyYWluIGRhdGEgaGFzIG1vcmUgdGhhbiAxIGJhbmQuIFVzaW5nIHRoZSBmaXJzdCBvbmUuXCJcbiAgICAgICAgKTtcbiAgICAgIH1cblxuICAgICAgdGhhdC5fdGVycmFpbkRhdGFTdHJ1Y3R1cmUgPSB7XG4gICAgICAgIGVsZW1lbnRNdWx0aXBsaWVyOiAxLjAsXG4gICAgICAgIGxvd2VzdEVuY29kZWRIZWlnaHQ6IG1ldGFkYXRhLm1pblZhbHVlc1swXSxcbiAgICAgICAgaGlnaGVzdEVuY29kZWRIZWlnaHQ6IG1ldGFkYXRhLm1heFZhbHVlc1swXSxcbiAgICAgIH07XG5cbiAgICAgIHRoYXQuX3JlYWR5ID0gdHJ1ZTtcblxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSlcbiAgICAub3RoZXJ3aXNlKGZ1bmN0aW9uIChlcnJvcikge1xuICAgICAgdmFyIG1lc3NhZ2UgPVxuICAgICAgICBcIkFuIGVycm9yIG9jY3VycmVkIHdoaWxlIGFjY2Vzc2luZyBcIiArIHRoYXQuX3Jlc291cmNlLnVybCArIFwiLlwiO1xuICAgICAgVGlsZVByb3ZpZGVyRXJyb3IuaGFuZGxlRXJyb3IodW5kZWZpbmVkLCB0aGF0LCB0aGF0Ll9lcnJvckV2ZW50LCBtZXNzYWdlKTtcbiAgICAgIHJldHVybiB3aGVuLnJlamVjdChlcnJvcik7XG4gICAgfSk7XG5cbiAgdGhpcy5fZXJyb3JFdmVudCA9IG5ldyBFdmVudCgpO1xufVxuXG5PYmplY3QuZGVmaW5lUHJvcGVydGllcyhBcmNHSVNUaWxlZEVsZXZhdGlvblRlcnJhaW5Qcm92aWRlci5wcm90b3R5cGUsIHtcbiAgLyoqXG4gICAqIEdldHMgYW4gZXZlbnQgdGhhdCBpcyByYWlzZWQgd2hlbiB0aGUgdGVycmFpbiBwcm92aWRlciBlbmNvdW50ZXJzIGFuIGFzeW5jaHJvbm91cyBlcnJvci4gIEJ5IHN1YnNjcmliaW5nXG4gICAqIHRvIHRoZSBldmVudCwgeW91IHdpbGwgYmUgbm90aWZpZWQgb2YgdGhlIGVycm9yIGFuZCBjYW4gcG90ZW50aWFsbHkgcmVjb3ZlciBmcm9tIGl0LiAgRXZlbnQgbGlzdGVuZXJzXG4gICAqIGFyZSBwYXNzZWQgYW4gaW5zdGFuY2Ugb2Yge0BsaW5rIFRpbGVQcm92aWRlckVycm9yfS5cbiAgICogQG1lbWJlcm9mIEFyY0dJU1RpbGVkRWxldmF0aW9uVGVycmFpblByb3ZpZGVyLnByb3RvdHlwZVxuICAgKiBAdHlwZSB7RXZlbnR9XG4gICAqIEByZWFkb25seVxuICAgKi9cbiAgZXJyb3JFdmVudDoge1xuICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX2Vycm9yRXZlbnQ7XG4gICAgfSxcbiAgfSxcblxuICAvKipcbiAgICogR2V0cyB0aGUgY3JlZGl0IHRvIGRpc3BsYXkgd2hlbiB0aGlzIHRlcnJhaW4gcHJvdmlkZXIgaXMgYWN0aXZlLiAgVHlwaWNhbGx5IHRoaXMgaXMgdXNlZCB0byBjcmVkaXRcbiAgICogdGhlIHNvdXJjZSBvZiB0aGUgdGVycmFpbi4gIFRoaXMgZnVuY3Rpb24gc2hvdWxkIG5vdCBiZSBjYWxsZWQgYmVmb3JlIHtAbGluayBBcmNHSVNUaWxlZEVsZXZhdGlvblRlcnJhaW5Qcm92aWRlciNyZWFkeX0gcmV0dXJucyB0cnVlLlxuICAgKiBAbWVtYmVyb2YgQXJjR0lTVGlsZWRFbGV2YXRpb25UZXJyYWluUHJvdmlkZXIucHJvdG90eXBlXG4gICAqIEB0eXBlIHtDcmVkaXR9XG4gICAqIEByZWFkb25seVxuICAgKi9cbiAgY3JlZGl0OiB7XG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAvLz4+aW5jbHVkZVN0YXJ0KCdkZWJ1ZycsIHByYWdtYXMuZGVidWcpO1xuICAgICAgaWYgKCF0aGlzLnJlYWR5KSB7XG4gICAgICAgIHRocm93IG5ldyBEZXZlbG9wZXJFcnJvcihcbiAgICAgICAgICBcImNyZWRpdCBtdXN0IG5vdCBiZSBjYWxsZWQgYmVmb3JlIHJlYWR5IHJldHVybnMgdHJ1ZS5cIlxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgLy8+PmluY2x1ZGVFbmQoJ2RlYnVnJyk7XG4gICAgICByZXR1cm4gdGhpcy5fY3JlZGl0O1xuICAgIH0sXG4gIH0sXG5cbiAgLyoqXG4gICAqIEdldHMgdGhlIHRpbGluZyBzY2hlbWUgdXNlZCBieSB0aGlzIHByb3ZpZGVyLiAgVGhpcyBmdW5jdGlvbiBzaG91bGRcbiAgICogbm90IGJlIGNhbGxlZCBiZWZvcmUge0BsaW5rIEFyY0dJU1RpbGVkRWxldmF0aW9uVGVycmFpblByb3ZpZGVyI3JlYWR5fSByZXR1cm5zIHRydWUuXG4gICAqIEBtZW1iZXJvZiBBcmNHSVNUaWxlZEVsZXZhdGlvblRlcnJhaW5Qcm92aWRlci5wcm90b3R5cGVcbiAgICogQHR5cGUge0dlb2dyYXBoaWNUaWxpbmdTY2hlbWV9XG4gICAqIEByZWFkb25seVxuICAgKi9cbiAgdGlsaW5nU2NoZW1lOiB7XG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAvLz4+aW5jbHVkZVN0YXJ0KCdkZWJ1ZycsIHByYWdtYXMuZGVidWcpO1xuICAgICAgaWYgKCF0aGlzLnJlYWR5KSB7XG4gICAgICAgIHRocm93IG5ldyBEZXZlbG9wZXJFcnJvcihcbiAgICAgICAgICBcInRpbGluZ1NjaGVtZSBtdXN0IG5vdCBiZSBjYWxsZWQgYmVmb3JlIHJlYWR5IHJldHVybnMgdHJ1ZS5cIlxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgLy8+PmluY2x1ZGVFbmQoJ2RlYnVnJyk7XG4gICAgICByZXR1cm4gdGhpcy5fdGlsaW5nU2NoZW1lO1xuICAgIH0sXG4gIH0sXG5cbiAgLyoqXG4gICAqIEdldHMgYSB2YWx1ZSBpbmRpY2F0aW5nIHdoZXRoZXIgb3Igbm90IHRoZSBwcm92aWRlciBpcyByZWFkeSBmb3IgdXNlLlxuICAgKiBAbWVtYmVyb2YgQXJjR0lTVGlsZWRFbGV2YXRpb25UZXJyYWluUHJvdmlkZXIucHJvdG90eXBlXG4gICAqIEB0eXBlIHtCb29sZWFufVxuICAgKiBAcmVhZG9ubHlcbiAgICovXG4gIHJlYWR5OiB7XG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fcmVhZHk7XG4gICAgfSxcbiAgfSxcblxuICAvKipcbiAgICogR2V0cyBhIHByb21pc2UgdGhhdCByZXNvbHZlcyB0byB0cnVlIHdoZW4gdGhlIHByb3ZpZGVyIGlzIHJlYWR5IGZvciB1c2UuXG4gICAqIEBtZW1iZXJvZiBBcmNHSVNUaWxlZEVsZXZhdGlvblRlcnJhaW5Qcm92aWRlci5wcm90b3R5cGVcbiAgICogQHR5cGUge1Byb21pc2UuPEJvb2xlYW4+fVxuICAgKiBAcmVhZG9ubHlcbiAgICovXG4gIHJlYWR5UHJvbWlzZToge1xuICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX3JlYWR5UHJvbWlzZTtcbiAgICB9LFxuICB9LFxuXG4gIC8qKlxuICAgKiBHZXRzIGEgdmFsdWUgaW5kaWNhdGluZyB3aGV0aGVyIG9yIG5vdCB0aGUgcHJvdmlkZXIgaW5jbHVkZXMgYSB3YXRlciBtYXNrLiAgVGhlIHdhdGVyIG1hc2tcbiAgICogaW5kaWNhdGVzIHdoaWNoIGFyZWFzIG9mIHRoZSBnbG9iZSBhcmUgd2F0ZXIgcmF0aGVyIHRoYW4gbGFuZCwgc28gdGhleSBjYW4gYmUgcmVuZGVyZWRcbiAgICogYXMgYSByZWZsZWN0aXZlIHN1cmZhY2Ugd2l0aCBhbmltYXRlZCB3YXZlcy4gIFRoaXMgZnVuY3Rpb24gc2hvdWxkIG5vdCBiZVxuICAgKiBjYWxsZWQgYmVmb3JlIHtAbGluayBBcmNHSVNUaWxlZEVsZXZhdGlvblRlcnJhaW5Qcm92aWRlciNyZWFkeX0gcmV0dXJucyB0cnVlLlxuICAgKiBAbWVtYmVyb2YgQXJjR0lTVGlsZWRFbGV2YXRpb25UZXJyYWluUHJvdmlkZXIucHJvdG90eXBlXG4gICAqIEB0eXBlIHtCb29sZWFufVxuICAgKiBAcmVhZG9ubHlcbiAgICovXG4gIGhhc1dhdGVyTWFzazoge1xuICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0sXG4gIH0sXG5cbiAgLyoqXG4gICAqIEdldHMgYSB2YWx1ZSBpbmRpY2F0aW5nIHdoZXRoZXIgb3Igbm90IHRoZSByZXF1ZXN0ZWQgdGlsZXMgaW5jbHVkZSB2ZXJ0ZXggbm9ybWFscy5cbiAgICogVGhpcyBmdW5jdGlvbiBzaG91bGQgbm90IGJlIGNhbGxlZCBiZWZvcmUge0BsaW5rIEFyY0dJU1RpbGVkRWxldmF0aW9uVGVycmFpblByb3ZpZGVyI3JlYWR5fSByZXR1cm5zIHRydWUuXG4gICAqIEBtZW1iZXJvZiBBcmNHSVNUaWxlZEVsZXZhdGlvblRlcnJhaW5Qcm92aWRlci5wcm90b3R5cGVcbiAgICogQHR5cGUge0Jvb2xlYW59XG4gICAqIEByZWFkb25seVxuICAgKi9cbiAgaGFzVmVydGV4Tm9ybWFsczoge1xuICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0sXG4gIH0sXG4gIC8qKlxuICAgKiBHZXRzIGFuIG9iamVjdCB0aGF0IGNhbiBiZSB1c2VkIHRvIGRldGVybWluZSBhdmFpbGFiaWxpdHkgb2YgdGVycmFpbiBmcm9tIHRoaXMgcHJvdmlkZXIsIHN1Y2ggYXNcbiAgICogYXQgcG9pbnRzIGFuZCBpbiByZWN0YW5nbGVzLiAgVGhpcyBmdW5jdGlvbiBzaG91bGQgbm90IGJlIGNhbGxlZCBiZWZvcmVcbiAgICoge0BsaW5rIFRlcnJhaW5Qcm92aWRlciNyZWFkeX0gcmV0dXJucyB0cnVlLiAgVGhpcyBwcm9wZXJ0eSBtYXkgYmUgdW5kZWZpbmVkIGlmIGF2YWlsYWJpbGl0eVxuICAgKiBpbmZvcm1hdGlvbiBpcyBub3QgYXZhaWxhYmxlLlxuICAgKiBAbWVtYmVyb2YgQXJjR0lTVGlsZWRFbGV2YXRpb25UZXJyYWluUHJvdmlkZXIucHJvdG90eXBlXG4gICAqIEB0eXBlIHtUaWxlQXZhaWxhYmlsaXR5fVxuICAgKiBAcmVhZG9ubHlcbiAgICovXG4gIGF2YWlsYWJpbGl0eToge1xuICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgLy8+PmluY2x1ZGVTdGFydCgnZGVidWcnLCBwcmFnbWFzLmRlYnVnKVxuICAgICAgaWYgKCF0aGlzLl9yZWFkeSkge1xuICAgICAgICB0aHJvdyBuZXcgRGV2ZWxvcGVyRXJyb3IoXG4gICAgICAgICAgXCJhdmFpbGFiaWxpdHkgbXVzdCBub3QgYmUgY2FsbGVkIGJlZm9yZSB0aGUgdGVycmFpbiBwcm92aWRlciBpcyByZWFkeS5cIlxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgLy8+PmluY2x1ZGVFbmQoJ2RlYnVnJyk7XG4gICAgICByZXR1cm4gdGhpcy5fdGlsZXNBdmFpbGFibGU7XG4gICAgfSxcbiAgfSxcbn0pO1xuXG4vKipcbiAqIFJlcXVlc3RzIHRoZSBnZW9tZXRyeSBmb3IgYSBnaXZlbiB0aWxlLiAgVGhpcyBmdW5jdGlvbiBzaG91bGQgbm90IGJlIGNhbGxlZCBiZWZvcmVcbiAqIHtAbGluayBBcmNHSVNUaWxlZEVsZXZhdGlvblRlcnJhaW5Qcm92aWRlciNyZWFkeX0gcmV0dXJucyB0cnVlLiAgVGhlIHJlc3VsdCBpbmNsdWRlcyB0ZXJyYWluXG4gKiBkYXRhIGFuZCBpbmRpY2F0ZXMgdGhhdCBhbGwgY2hpbGQgdGlsZXMgYXJlIGF2YWlsYWJsZS5cbiAqXG4gKiBAcGFyYW0ge051bWJlcn0geCBUaGUgWCBjb29yZGluYXRlIG9mIHRoZSB0aWxlIGZvciB3aGljaCB0byByZXF1ZXN0IGdlb21ldHJ5LlxuICogQHBhcmFtIHtOdW1iZXJ9IHkgVGhlIFkgY29vcmRpbmF0ZSBvZiB0aGUgdGlsZSBmb3Igd2hpY2ggdG8gcmVxdWVzdCBnZW9tZXRyeS5cbiAqIEBwYXJhbSB7TnVtYmVyfSBsZXZlbCBUaGUgbGV2ZWwgb2YgdGhlIHRpbGUgZm9yIHdoaWNoIHRvIHJlcXVlc3QgZ2VvbWV0cnkuXG4gKiBAcGFyYW0ge1JlcXVlc3R9IFtyZXF1ZXN0XSBUaGUgcmVxdWVzdCBvYmplY3QuIEludGVuZGVkIGZvciBpbnRlcm5hbCB1c2Ugb25seS5cbiAqIEByZXR1cm5zIHtQcm9taXNlLjxUZXJyYWluRGF0YT58dW5kZWZpbmVkfSBBIHByb21pc2UgZm9yIHRoZSByZXF1ZXN0ZWQgZ2VvbWV0cnkuICBJZiB0aGlzIG1ldGhvZFxuICogICAgICAgICAgcmV0dXJucyB1bmRlZmluZWQgaW5zdGVhZCBvZiBhIHByb21pc2UsIGl0IGlzIGFuIGluZGljYXRpb24gdGhhdCB0b28gbWFueSByZXF1ZXN0cyBhcmUgYWxyZWFkeVxuICogICAgICAgICAgcGVuZGluZyBhbmQgdGhlIHJlcXVlc3Qgd2lsbCBiZSByZXRyaWVkIGxhdGVyLlxuICovXG5BcmNHSVNUaWxlZEVsZXZhdGlvblRlcnJhaW5Qcm92aWRlci5wcm90b3R5cGUucmVxdWVzdFRpbGVHZW9tZXRyeSA9IGZ1bmN0aW9uIChcbiAgeCxcbiAgeSxcbiAgbGV2ZWwsXG4gIHJlcXVlc3Rcbikge1xuICAvLz4+aW5jbHVkZVN0YXJ0KCdkZWJ1ZycsIHByYWdtYXMuZGVidWcpXG4gIGlmICghdGhpcy5fcmVhZHkpIHtcbiAgICB0aHJvdyBuZXcgRGV2ZWxvcGVyRXJyb3IoXG4gICAgICBcInJlcXVlc3RUaWxlR2VvbWV0cnkgbXVzdCBub3QgYmUgY2FsbGVkIGJlZm9yZSB0aGUgdGVycmFpbiBwcm92aWRlciBpcyByZWFkeS5cIlxuICAgICk7XG4gIH1cbiAgLy8+PmluY2x1ZGVFbmQoJ2RlYnVnJyk7XG5cbiAgdmFyIHRpbGVSZXNvdXJjZSA9IHRoaXMuX3Jlc291cmNlLmdldERlcml2ZWRSZXNvdXJjZSh7XG4gICAgdXJsOiBcInRpbGUvXCIgKyBsZXZlbCArIFwiL1wiICsgeSArIFwiL1wiICsgeCxcbiAgICByZXF1ZXN0OiByZXF1ZXN0LFxuICB9KTtcblxuICB2YXIgaGFzQXZhaWxhYmlsaXR5ID0gdGhpcy5faGFzQXZhaWxhYmlsaXR5O1xuICB2YXIgYXZhaWxhYmlsaXR5UHJvbWlzZSA9IHdoZW4ucmVzb2x2ZSh0cnVlKTtcbiAgdmFyIGF2YWlsYWJpbGl0eVJlcXVlc3Q7XG4gIGlmIChcbiAgICBoYXNBdmFpbGFiaWxpdHkgJiZcbiAgICAhZGVmaW5lZChpc1RpbGVBdmFpbGFibGUodGhpcywgbGV2ZWwgKyAxLCB4ICogMiwgeSAqIDIpKVxuICApIHtcbiAgICAvLyBXZSBuZWVkIHRvIGxvYWQgY2hpbGQgYXZhaWxhYmlsaXR5XG4gICAgdmFyIGF2YWlsYWJpbGl0eVJlc3VsdCA9IHJlcXVlc3RBdmFpbGFiaWxpdHkodGhpcywgbGV2ZWwgKyAxLCB4ICogMiwgeSAqIDIpO1xuXG4gICAgYXZhaWxhYmlsaXR5UHJvbWlzZSA9IGF2YWlsYWJpbGl0eVJlc3VsdC5wcm9taXNlO1xuICAgIGF2YWlsYWJpbGl0eVJlcXVlc3QgPSBhdmFpbGFiaWxpdHlSZXN1bHQucmVxdWVzdDtcbiAgfVxuXG4gIHZhciBwcm9taXNlID0gdGlsZVJlc291cmNlLmZldGNoQXJyYXlCdWZmZXIoKTtcbiAgaWYgKCFkZWZpbmVkKHByb21pc2UpIHx8ICFkZWZpbmVkKGF2YWlsYWJpbGl0eVByb21pc2UpKSB7XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxuXG4gIHZhciB0aGF0ID0gdGhpcztcbiAgdmFyIHRpbGVzQXZhaWxhYmxlID0gdGhpcy5fdGlsZXNBdmFpbGFibGU7XG4gIHJldHVybiB3aGVuXG4gICAgLmpvaW4ocHJvbWlzZSwgYXZhaWxhYmlsaXR5UHJvbWlzZSlcbiAgICAudGhlbihmdW5jdGlvbiAocmVzdWx0KSB7XG4gICAgICByZXR1cm4gbmV3IEhlaWdodG1hcFRlcnJhaW5EYXRhKHtcbiAgICAgICAgYnVmZmVyOiByZXN1bHRbMF0sXG4gICAgICAgIHdpZHRoOiB0aGF0Ll93aWR0aCxcbiAgICAgICAgaGVpZ2h0OiB0aGF0Ll9oZWlnaHQsXG4gICAgICAgIGNoaWxkVGlsZU1hc2s6IGhhc0F2YWlsYWJpbGl0eVxuICAgICAgICAgID8gdGlsZXNBdmFpbGFibGUuY29tcHV0ZUNoaWxkTWFza0ZvclRpbGUobGV2ZWwsIHgsIHkpXG4gICAgICAgICAgOiBBTExfQ0hJTERSRU4sXG4gICAgICAgIHN0cnVjdHVyZTogdGhhdC5fdGVycmFpbkRhdGFTdHJ1Y3R1cmUsXG4gICAgICAgIGVuY29kaW5nOiB0aGF0Ll9lbmNvZGluZyxcbiAgICAgIH0pO1xuICAgIH0pXG4gICAgLm90aGVyd2lzZShmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICAgIGlmIChcbiAgICAgICAgZGVmaW5lZChhdmFpbGFiaWxpdHlSZXF1ZXN0KSAmJlxuICAgICAgICBhdmFpbGFiaWxpdHlSZXF1ZXN0LnN0YXRlID09PSBSZXF1ZXN0U3RhdGUuQ0FOQ0VMTEVEXG4gICAgICApIHtcbiAgICAgICAgcmVxdWVzdC5jYW5jZWwoKTtcblxuICAgICAgICAvLyBEb24ndCByZWplY3QgdGhlIHByb21pc2UgdGlsbCB0aGUgcmVxdWVzdCBpcyBhY3R1YWxseSBjYW5jZWxsZWRcbiAgICAgICAgLy8gT3RoZXJ3aXNlIGl0IHdpbGwgdGhpbmsgdGhlIHJlcXVlc3QgZmFpbGVkLCBidXQgaXQgZGlkbid0LlxuICAgICAgICByZXR1cm4gcmVxdWVzdC5kZWZlcnJlZC5wcm9taXNlLmFsd2F5cyhmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmVxdWVzdC5zdGF0ZSA9IFJlcXVlc3RTdGF0ZS5DQU5DRUxMRUQ7XG4gICAgICAgICAgcmV0dXJuIHdoZW4ucmVqZWN0KGVycm9yKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gd2hlbi5yZWplY3QoZXJyb3IpO1xuICAgIH0pO1xufTtcblxuZnVuY3Rpb24gaXNUaWxlQXZhaWxhYmxlKHRoYXQsIGxldmVsLCB4LCB5KSB7XG4gIGlmICghdGhhdC5faGFzQXZhaWxhYmlsaXR5KSB7XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxuXG4gIHZhciB0aWxlc0F2YWlsYWJsaXR5TG9hZGVkID0gdGhhdC5fdGlsZXNBdmFpbGFibGl0eUxvYWRlZDtcbiAgdmFyIHRpbGVzQXZhaWxhYmxlID0gdGhhdC5fdGlsZXNBdmFpbGFibGU7XG5cbiAgaWYgKGxldmVsID4gdGhhdC5fbG9kQ291bnQpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICAvLyBDaGVjayBpZiB0aWxlcyBhcmUga25vd24gdG8gYmUgYXZhaWxhYmxlXG4gIGlmICh0aWxlc0F2YWlsYWJsZS5pc1RpbGVBdmFpbGFibGUobGV2ZWwsIHgsIHkpKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICAvLyBvciB0byBub3QgYmUgYXZhaWxhYmxlXG4gIGlmICh0aWxlc0F2YWlsYWJsaXR5TG9hZGVkLmlzVGlsZUF2YWlsYWJsZShsZXZlbCwgeCwgeSkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICByZXR1cm4gdW5kZWZpbmVkO1xufVxuXG4vKipcbiAqIEdldHMgdGhlIG1heGltdW0gZ2VvbWV0cmljIGVycm9yIGFsbG93ZWQgaW4gYSB0aWxlIGF0IGEgZ2l2ZW4gbGV2ZWwuXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IGxldmVsIFRoZSB0aWxlIGxldmVsIGZvciB3aGljaCB0byBnZXQgdGhlIG1heGltdW0gZ2VvbWV0cmljIGVycm9yLlxuICogQHJldHVybnMge051bWJlcn0gVGhlIG1heGltdW0gZ2VvbWV0cmljIGVycm9yLlxuICovXG5BcmNHSVNUaWxlZEVsZXZhdGlvblRlcnJhaW5Qcm92aWRlci5wcm90b3R5cGUuZ2V0TGV2ZWxNYXhpbXVtR2VvbWV0cmljRXJyb3IgPSBmdW5jdGlvbiAoXG4gIGxldmVsXG4pIHtcbiAgLy8+PmluY2x1ZGVTdGFydCgnZGVidWcnLCBwcmFnbWFzLmRlYnVnKTtcbiAgaWYgKCF0aGlzLnJlYWR5KSB7XG4gICAgdGhyb3cgbmV3IERldmVsb3BlckVycm9yKFxuICAgICAgXCJnZXRMZXZlbE1heGltdW1HZW9tZXRyaWNFcnJvciBtdXN0IG5vdCBiZSBjYWxsZWQgYmVmb3JlIHJlYWR5IHJldHVybnMgdHJ1ZS5cIlxuICAgICk7XG4gIH1cbiAgLy8+PmluY2x1ZGVFbmQoJ2RlYnVnJyk7XG5cbiAgcmV0dXJuIHRoaXMuX2xldmVsWmVyb01heGltdW1HZW9tZXRyaWNFcnJvciAvICgxIDw8IGxldmVsKTtcbn07XG5cbi8qKlxuICogRGV0ZXJtaW5lcyB3aGV0aGVyIGRhdGEgZm9yIGEgdGlsZSBpcyBhdmFpbGFibGUgdG8gYmUgbG9hZGVkLlxuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSB4IFRoZSBYIGNvb3JkaW5hdGUgb2YgdGhlIHRpbGUgZm9yIHdoaWNoIHRvIHJlcXVlc3QgZ2VvbWV0cnkuXG4gKiBAcGFyYW0ge051bWJlcn0geSBUaGUgWSBjb29yZGluYXRlIG9mIHRoZSB0aWxlIGZvciB3aGljaCB0byByZXF1ZXN0IGdlb21ldHJ5LlxuICogQHBhcmFtIHtOdW1iZXJ9IGxldmVsIFRoZSBsZXZlbCBvZiB0aGUgdGlsZSBmb3Igd2hpY2ggdG8gcmVxdWVzdCBnZW9tZXRyeS5cbiAqIEByZXR1cm5zIHtCb29sZWFufHVuZGVmaW5lZH0gVW5kZWZpbmVkIGlmIG5vdCBzdXBwb3J0ZWQsIG90aGVyd2lzZSB0cnVlIG9yIGZhbHNlLlxuICovXG5BcmNHSVNUaWxlZEVsZXZhdGlvblRlcnJhaW5Qcm92aWRlci5wcm90b3R5cGUuZ2V0VGlsZURhdGFBdmFpbGFibGUgPSBmdW5jdGlvbiAoXG4gIHgsXG4gIHksXG4gIGxldmVsXG4pIHtcbiAgaWYgKCF0aGlzLl9oYXNBdmFpbGFiaWxpdHkpIHtcbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG5cbiAgdmFyIHJlc3VsdCA9IGlzVGlsZUF2YWlsYWJsZSh0aGlzLCBsZXZlbCwgeCwgeSk7XG4gIGlmIChkZWZpbmVkKHJlc3VsdCkpIHtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgcmVxdWVzdEF2YWlsYWJpbGl0eSh0aGlzLCBsZXZlbCwgeCwgeSk7XG5cbiAgcmV0dXJuIHVuZGVmaW5lZDtcbn07XG5cbi8qKlxuICogTWFrZXMgc3VyZSB3ZSBsb2FkIGF2YWlsYWJpbGl0eSBkYXRhIGZvciBhIHRpbGVcbiAqXG4gKiBAcGFyYW0ge051bWJlcn0geCBUaGUgWCBjb29yZGluYXRlIG9mIHRoZSB0aWxlIGZvciB3aGljaCB0byByZXF1ZXN0IGdlb21ldHJ5LlxuICogQHBhcmFtIHtOdW1iZXJ9IHkgVGhlIFkgY29vcmRpbmF0ZSBvZiB0aGUgdGlsZSBmb3Igd2hpY2ggdG8gcmVxdWVzdCBnZW9tZXRyeS5cbiAqIEBwYXJhbSB7TnVtYmVyfSBsZXZlbCBUaGUgbGV2ZWwgb2YgdGhlIHRpbGUgZm9yIHdoaWNoIHRvIHJlcXVlc3QgZ2VvbWV0cnkuXG4gKiBAcmV0dXJucyB7dW5kZWZpbmVkfFByb21pc2U8dm9pZD59IFVuZGVmaW5lZCBpZiBub3RoaW5nIG5lZWQgdG8gYmUgbG9hZGVkIG9yIGEgUHJvbWlzZSB0aGF0IHJlc29sdmVzIHdoZW4gYWxsIHJlcXVpcmVkIHRpbGVzIGFyZSBsb2FkZWRcbiAqL1xuQXJjR0lTVGlsZWRFbGV2YXRpb25UZXJyYWluUHJvdmlkZXIucHJvdG90eXBlLmxvYWRUaWxlRGF0YUF2YWlsYWJpbGl0eSA9IGZ1bmN0aW9uIChcbiAgeCxcbiAgeSxcbiAgbGV2ZWxcbikge1xuICByZXR1cm4gdW5kZWZpbmVkO1xufTtcblxuZnVuY3Rpb24gZmluZFJhbmdlKG9yaWdpbiwgd2lkdGgsIGhlaWdodCwgZGF0YSkge1xuICB2YXIgZW5kQ29sID0gd2lkdGggLSAxO1xuICB2YXIgZW5kUm93ID0gaGVpZ2h0IC0gMTtcblxuICB2YXIgdmFsdWUgPSBkYXRhW29yaWdpbi55ICogd2lkdGggKyBvcmlnaW4ueF07XG4gIHZhciBlbmRpbmdJbmRpY2VzID0gW107XG4gIHZhciByYW5nZSA9IHtcbiAgICBzdGFydFg6IG9yaWdpbi54LFxuICAgIHN0YXJ0WTogb3JpZ2luLnksXG4gICAgZW5kWDogMCxcbiAgICBlbmRZOiAwLFxuICB9O1xuXG4gIHZhciBjb3JuZXIgPSBuZXcgQ2FydGVzaWFuMihvcmlnaW4ueCArIDEsIG9yaWdpbi55ICsgMSk7XG4gIHZhciBkb25lWCA9IGZhbHNlO1xuICB2YXIgZG9uZVkgPSBmYWxzZTtcbiAgd2hpbGUgKCEoZG9uZVggJiYgZG9uZVkpKSB7XG4gICAgLy8gV2Ugd2FudCB0byB1c2UgdGhlIG9yaWdpbmFsIHZhbHVlIHdoZW4gY2hlY2tpbmcgWSxcbiAgICAvLyAgc28gZ2V0IGl0IGJlZm9yZSBpdCBwb3NzaWJseSBnZXRzIGluY3JlbWVudGVkXG4gICAgdmFyIGVuZFggPSBjb3JuZXIueDtcblxuICAgIC8vIElmIHdlIG5vIGxvbmdlciBtb3ZlIGluIHRoZSBZIGRpcmVjdGlvbiB3ZSBuZWVkIHRvIGNoZWNrIHRoZSBjb3JuZXIgdGlsZSBpbiBYIHBhc3NcbiAgICB2YXIgZW5kWSA9IGRvbmVZID8gY29ybmVyLnkgKyAxIDogY29ybmVyLnk7XG5cbiAgICAvLyBDaGVjayBYIHJhbmdlXG4gICAgaWYgKCFkb25lWCkge1xuICAgICAgZm9yICh2YXIgeSA9IG9yaWdpbi55OyB5IDwgZW5kWTsgKyt5KSB7XG4gICAgICAgIGlmIChkYXRhW3kgKiB3aWR0aCArIGNvcm5lci54XSAhPT0gdmFsdWUpIHtcbiAgICAgICAgICBkb25lWCA9IHRydWU7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKGRvbmVYKSB7XG4gICAgICAgIGVuZGluZ0luZGljZXMucHVzaChuZXcgQ2FydGVzaWFuMihjb3JuZXIueCwgb3JpZ2luLnkpKTtcblxuICAgICAgICAvLyBVc2UgdGhlIGxhc3QgZ29vZCBjb2x1bW4gc28gd2UgY2FuIGNvbnRpbnVlIHdpdGggWVxuICAgICAgICAtLWNvcm5lci54O1xuICAgICAgICAtLWVuZFg7XG4gICAgICAgIHJhbmdlLmVuZFggPSBjb3JuZXIueDtcbiAgICAgIH0gZWxzZSBpZiAoY29ybmVyLnggPT09IGVuZENvbCkge1xuICAgICAgICByYW5nZS5lbmRYID0gY29ybmVyLng7XG4gICAgICAgIGRvbmVYID0gdHJ1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgICsrY29ybmVyLng7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gQ2hlY2sgWSByYW5nZSAtIFRoZSBjb3JuZXIgdGlsZSBpcyBjaGVja2VkIGhlcmVcbiAgICBpZiAoIWRvbmVZKSB7XG4gICAgICB2YXIgY29sID0gY29ybmVyLnkgKiB3aWR0aDtcbiAgICAgIGZvciAodmFyIHggPSBvcmlnaW4ueDsgeCA8PSBlbmRYOyArK3gpIHtcbiAgICAgICAgaWYgKGRhdGFbY29sICsgeF0gIT09IHZhbHVlKSB7XG4gICAgICAgICAgZG9uZVkgPSB0cnVlO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChkb25lWSkge1xuICAgICAgICBlbmRpbmdJbmRpY2VzLnB1c2gobmV3IENhcnRlc2lhbjIob3JpZ2luLngsIGNvcm5lci55KSk7XG5cbiAgICAgICAgLy8gVXNlIHRoZSBsYXN0IGdvb2Qgcm93IHNvIHdlIGNhbiBjb250aW51ZSB3aXRoIFhcbiAgICAgICAgLS1jb3JuZXIueTtcbiAgICAgICAgcmFuZ2UuZW5kWSA9IGNvcm5lci55O1xuICAgICAgfSBlbHNlIGlmIChjb3JuZXIueSA9PT0gZW5kUm93KSB7XG4gICAgICAgIHJhbmdlLmVuZFkgPSBjb3JuZXIueTtcbiAgICAgICAgZG9uZVkgPSB0cnVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgKytjb3JuZXIueTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4ge1xuICAgIGVuZGluZ0luZGljZXM6IGVuZGluZ0luZGljZXMsXG4gICAgcmFuZ2U6IHJhbmdlLFxuICAgIHZhbHVlOiB2YWx1ZSxcbiAgfTtcbn1cblxuZnVuY3Rpb24gY29tcHV0ZUF2YWlsYWJpbGl0eSh4LCB5LCB3aWR0aCwgaGVpZ2h0LCBkYXRhKSB7XG4gIHZhciByYW5nZXMgPSBbXTtcblxuICB2YXIgc2luZ2xlVmFsdWUgPSBkYXRhLmV2ZXJ5KGZ1bmN0aW9uICh2YWwpIHtcbiAgICByZXR1cm4gdmFsID09PSBkYXRhWzBdO1xuICB9KTtcbiAgaWYgKHNpbmdsZVZhbHVlKSB7XG4gICAgaWYgKGRhdGFbMF0gPT09IDEpIHtcbiAgICAgIHJhbmdlcy5wdXNoKHtcbiAgICAgICAgc3RhcnRYOiB4LFxuICAgICAgICBzdGFydFk6IHksXG4gICAgICAgIGVuZFg6IHggKyB3aWR0aCAtIDEsXG4gICAgICAgIGVuZFk6IHkgKyBoZWlnaHQgLSAxLFxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJhbmdlcztcbiAgfVxuXG4gIHZhciBwb3NpdGlvbnMgPSBbbmV3IENhcnRlc2lhbjIoMCwgMCldO1xuICB3aGlsZSAocG9zaXRpb25zLmxlbmd0aCA+IDApIHtcbiAgICB2YXIgb3JpZ2luID0gcG9zaXRpb25zLnBvcCgpO1xuICAgIHZhciByZXN1bHQgPSBmaW5kUmFuZ2Uob3JpZ2luLCB3aWR0aCwgaGVpZ2h0LCBkYXRhKTtcblxuICAgIGlmIChyZXN1bHQudmFsdWUgPT09IDEpIHtcbiAgICAgIC8vIENvbnZlcnQgcmFuZ2UgaW50byB0aGUgYXJyYXkgaW50byBnbG9iYWwgdGlsZSBjb29yZGluYXRlc1xuICAgICAgdmFyIHJhbmdlID0gcmVzdWx0LnJhbmdlO1xuICAgICAgcmFuZ2Uuc3RhcnRYICs9IHg7XG4gICAgICByYW5nZS5lbmRYICs9IHg7XG4gICAgICByYW5nZS5zdGFydFkgKz0geTtcbiAgICAgIHJhbmdlLmVuZFkgKz0geTtcbiAgICAgIHJhbmdlcy5wdXNoKHJhbmdlKTtcbiAgICB9XG5cbiAgICB2YXIgZW5kaW5nSW5kaWNlcyA9IHJlc3VsdC5lbmRpbmdJbmRpY2VzO1xuICAgIGlmIChlbmRpbmdJbmRpY2VzLmxlbmd0aCA+IDApIHtcbiAgICAgIHBvc2l0aW9ucyA9IHBvc2l0aW9ucy5jb25jYXQoZW5kaW5nSW5kaWNlcyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHJhbmdlcztcbn1cblxuZnVuY3Rpb24gcmVxdWVzdEF2YWlsYWJpbGl0eSh0aGF0LCBsZXZlbCwgeCwgeSkge1xuICBpZiAoIXRoYXQuX2hhc0F2YWlsYWJpbGl0eSkge1xuICAgIHJldHVybiB7fTtcbiAgfVxuXG4gIC8vIEZldGNoIDEyOHgxMjggYXZhaWxhYmlsaXR5IGxpc3QsIHNvIHdlIG1ha2UgdGhlIG1pbmltdW0gYW1vdW50IG9mIHJlcXVlc3RzXG4gIHZhciB4T2Zmc2V0ID0gTWF0aC5mbG9vcih4IC8gMTI4KSAqIDEyODtcbiAgdmFyIHlPZmZzZXQgPSBNYXRoLmZsb29yKHkgLyAxMjgpICogMTI4O1xuXG4gIHZhciBkaW0gPSBNYXRoLm1pbigxIDw8IGxldmVsLCAxMjgpO1xuICB2YXIgdXJsID1cbiAgICBcInRpbGVtYXAvXCIgKyBsZXZlbCArIFwiL1wiICsgeU9mZnNldCArIFwiL1wiICsgeE9mZnNldCArIFwiL1wiICsgZGltICsgXCIvXCIgKyBkaW07XG5cbiAgdmFyIGF2YWlsYWJsZUNhY2hlID0gdGhhdC5fYXZhaWxhYmxlQ2FjaGU7XG4gIGlmIChkZWZpbmVkKGF2YWlsYWJsZUNhY2hlW3VybF0pKSB7XG4gICAgcmV0dXJuIGF2YWlsYWJsZUNhY2hlW3VybF07XG4gIH1cblxuICB2YXIgcmVxdWVzdCA9IG5ldyBSZXF1ZXN0KHtcbiAgICB0aHJvdHRsZTogZmFsc2UsXG4gICAgdGhyb3R0bGVCeVNlcnZlcjogdHJ1ZSxcbiAgICB0eXBlOiBSZXF1ZXN0VHlwZS5URVJSQUlOLFxuICB9KTtcblxuICB2YXIgdGlsZW1hcFJlc291cmNlID0gdGhhdC5fcmVzb3VyY2UuZ2V0RGVyaXZlZFJlc291cmNlKHtcbiAgICB1cmw6IHVybCxcbiAgICByZXF1ZXN0OiByZXF1ZXN0LFxuICB9KTtcblxuICB2YXIgcHJvbWlzZSA9IHRpbGVtYXBSZXNvdXJjZS5mZXRjaEpzb24oKTtcbiAgaWYgKCFkZWZpbmVkKHByb21pc2UpKSB7XG4gICAgcmV0dXJuIHt9O1xuICB9XG5cbiAgcHJvbWlzZSA9IHByb21pc2UudGhlbihmdW5jdGlvbiAocmVzdWx0KSB7XG4gICAgdmFyIGF2YWlsYWJsZSA9IGNvbXB1dGVBdmFpbGFiaWxpdHkoXG4gICAgICB4T2Zmc2V0LFxuICAgICAgeU9mZnNldCxcbiAgICAgIGRpbSxcbiAgICAgIGRpbSxcbiAgICAgIHJlc3VsdC5kYXRhXG4gICAgKTtcblxuICAgIC8vIE1hcmsgd2hvbGUgYXJlYSBhcyBoYXZpbmcgYXZhaWxhYmlsaXR5IGxvYWRlZFxuICAgIHRoYXQuX3RpbGVzQXZhaWxhYmxpdHlMb2FkZWQuYWRkQXZhaWxhYmxlVGlsZVJhbmdlKFxuICAgICAgbGV2ZWwsXG4gICAgICB4T2Zmc2V0LFxuICAgICAgeU9mZnNldCxcbiAgICAgIHhPZmZzZXQgKyBkaW0sXG4gICAgICB5T2Zmc2V0ICsgZGltXG4gICAgKTtcblxuICAgIHZhciB0aWxlc0F2YWlsYWJsZSA9IHRoYXQuX3RpbGVzQXZhaWxhYmxlO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXZhaWxhYmxlLmxlbmd0aDsgKytpKSB7XG4gICAgICB2YXIgcmFuZ2UgPSBhdmFpbGFibGVbaV07XG4gICAgICB0aWxlc0F2YWlsYWJsZS5hZGRBdmFpbGFibGVUaWxlUmFuZ2UoXG4gICAgICAgIGxldmVsLFxuICAgICAgICByYW5nZS5zdGFydFgsXG4gICAgICAgIHJhbmdlLnN0YXJ0WSxcbiAgICAgICAgcmFuZ2UuZW5kWCxcbiAgICAgICAgcmFuZ2UuZW5kWVxuICAgICAgKTtcbiAgICB9XG5cbiAgICAvLyBDb252ZW5pZW50bHkgcmV0dXJuIGF2YWlsYWJpbGl0eSBvZiBvcmlnaW5hbCB0aWxlXG4gICAgcmV0dXJuIGlzVGlsZUF2YWlsYWJsZSh0aGF0LCBsZXZlbCwgeCwgeSk7XG4gIH0pO1xuXG4gIGF2YWlsYWJsZUNhY2hlW3VybF0gPSB7XG4gICAgcHJvbWlzZTogcHJvbWlzZSxcbiAgICByZXF1ZXN0OiByZXF1ZXN0LFxuICB9O1xuXG4gIHByb21pc2UgPSBwcm9taXNlLmFsd2F5cyhmdW5jdGlvbiAocmVzdWx0KSB7XG4gICAgZGVsZXRlIGF2YWlsYWJsZUNhY2hlW3VybF07XG5cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9KTtcblxuICByZXR1cm4ge1xuICAgIHByb21pc2U6IHByb21pc2UsXG4gICAgcmVxdWVzdDogcmVxdWVzdCxcbiAgfTtcbn1cbmV4cG9ydCBkZWZhdWx0IEFyY0dJU1RpbGVkRWxldmF0aW9uVGVycmFpblByb3ZpZGVyO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///52890\n')}}]);