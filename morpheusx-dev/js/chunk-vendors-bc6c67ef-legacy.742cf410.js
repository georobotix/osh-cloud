"use strict";(self["webpackChunkvue3_webpack5"]=self["webpackChunkvue3_webpack5"]||[]).push([[2108],{48055:function(__unused_webpack_module,__webpack_exports__,__webpack_require__){eval('/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "T": function() { return /* binding */ Timeline; }\n/* harmony export */ });\nlet channelHandles = 1;\nlet animationHandles = 1;\nclass Timeline {\n  constructor() {\n    this.time = 0;\n    this.channels = new Map();\n    this.animations = new Map();\n    this.playing = false;\n    this.lastEngineTime = -1;\n  }\n\n  addChannel(props) {\n    const {\n      delay = 0,\n      duration = Number.POSITIVE_INFINITY,\n      rate = 1,\n      repeat = 1\n    } = props;\n    const handle = channelHandles++;\n    const channel = {\n      time: 0,\n      delay,\n      duration,\n      rate,\n      repeat\n    };\n\n    this._setChannelTime(channel, this.time);\n\n    this.channels.set(handle, channel);\n    return handle;\n  }\n\n  removeChannel(handle) {\n    this.channels.delete(handle);\n\n    for (const [animationHandle, animation] of this.animations) {\n      if (animation.channel === handle) {\n        this.detachAnimation(animationHandle);\n      }\n    }\n  }\n\n  isFinished(handle) {\n    const channel = this.channels.get(handle);\n\n    if (channel === undefined) {\n      return false;\n    }\n\n    return this.time >= channel.delay + channel.duration * channel.repeat;\n  }\n\n  getTime(handle) {\n    if (handle === undefined) {\n      return this.time;\n    }\n\n    const channel = this.channels.get(handle);\n\n    if (channel === undefined) {\n      return -1;\n    }\n\n    return channel.time;\n  }\n\n  setTime(time) {\n    this.time = Math.max(0, time);\n    const channels = this.channels.values();\n\n    for (const channel of channels) {\n      this._setChannelTime(channel, this.time);\n    }\n\n    const animations = this.animations.values();\n\n    for (const animationData of animations) {\n      const {\n        animation,\n        channel\n      } = animationData;\n      animation.setTime(this.getTime(channel));\n    }\n  }\n\n  play() {\n    this.playing = true;\n  }\n\n  pause() {\n    this.playing = false;\n    this.lastEngineTime = -1;\n  }\n\n  reset() {\n    this.setTime(0);\n  }\n\n  attachAnimation(animation, channelHandle) {\n    const animationHandle = animationHandles++;\n    this.animations.set(animationHandle, {\n      animation,\n      channel: channelHandle\n    });\n    animation.setTime(this.getTime(channelHandle));\n    return animationHandle;\n  }\n\n  detachAnimation(handle) {\n    this.animations.delete(handle);\n  }\n\n  update(engineTime) {\n    if (this.playing) {\n      if (this.lastEngineTime === -1) {\n        this.lastEngineTime = engineTime;\n      }\n\n      this.setTime(this.time + (engineTime - this.lastEngineTime));\n      this.lastEngineTime = engineTime;\n    }\n  }\n\n  _setChannelTime(channel, time) {\n    const offsetTime = time - channel.delay;\n    const totalDuration = channel.duration * channel.repeat;\n\n    if (offsetTime >= totalDuration) {\n      channel.time = channel.duration * channel.rate;\n    } else {\n      channel.time = Math.max(0, offsetTime) % channel.duration;\n      channel.time *= channel.rate;\n    }\n  }\n\n}\n//# sourceMappingURL=timeline.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNDgwNTUuanMiLCJtYXBwaW5ncyI6Ijs7O0FBQUE7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdnVlMy13ZWJwYWNrNS8uL25vZGVfbW9kdWxlcy9AbHVtYS5nbC9lbmdpbmUvZGlzdC9lc20vYW5pbWF0aW9uL3RpbWVsaW5lLmpzP2VkNTkiXSwic291cmNlc0NvbnRlbnQiOlsibGV0IGNoYW5uZWxIYW5kbGVzID0gMTtcbmxldCBhbmltYXRpb25IYW5kbGVzID0gMTtcbmV4cG9ydCBjbGFzcyBUaW1lbGluZSB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMudGltZSA9IDA7XG4gICAgdGhpcy5jaGFubmVscyA9IG5ldyBNYXAoKTtcbiAgICB0aGlzLmFuaW1hdGlvbnMgPSBuZXcgTWFwKCk7XG4gICAgdGhpcy5wbGF5aW5nID0gZmFsc2U7XG4gICAgdGhpcy5sYXN0RW5naW5lVGltZSA9IC0xO1xuICB9XG5cbiAgYWRkQ2hhbm5lbChwcm9wcykge1xuICAgIGNvbnN0IHtcbiAgICAgIGRlbGF5ID0gMCxcbiAgICAgIGR1cmF0aW9uID0gTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZLFxuICAgICAgcmF0ZSA9IDEsXG4gICAgICByZXBlYXQgPSAxXG4gICAgfSA9IHByb3BzO1xuICAgIGNvbnN0IGhhbmRsZSA9IGNoYW5uZWxIYW5kbGVzKys7XG4gICAgY29uc3QgY2hhbm5lbCA9IHtcbiAgICAgIHRpbWU6IDAsXG4gICAgICBkZWxheSxcbiAgICAgIGR1cmF0aW9uLFxuICAgICAgcmF0ZSxcbiAgICAgIHJlcGVhdFxuICAgIH07XG5cbiAgICB0aGlzLl9zZXRDaGFubmVsVGltZShjaGFubmVsLCB0aGlzLnRpbWUpO1xuXG4gICAgdGhpcy5jaGFubmVscy5zZXQoaGFuZGxlLCBjaGFubmVsKTtcbiAgICByZXR1cm4gaGFuZGxlO1xuICB9XG5cbiAgcmVtb3ZlQ2hhbm5lbChoYW5kbGUpIHtcbiAgICB0aGlzLmNoYW5uZWxzLmRlbGV0ZShoYW5kbGUpO1xuXG4gICAgZm9yIChjb25zdCBbYW5pbWF0aW9uSGFuZGxlLCBhbmltYXRpb25dIG9mIHRoaXMuYW5pbWF0aW9ucykge1xuICAgICAgaWYgKGFuaW1hdGlvbi5jaGFubmVsID09PSBoYW5kbGUpIHtcbiAgICAgICAgdGhpcy5kZXRhY2hBbmltYXRpb24oYW5pbWF0aW9uSGFuZGxlKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBpc0ZpbmlzaGVkKGhhbmRsZSkge1xuICAgIGNvbnN0IGNoYW5uZWwgPSB0aGlzLmNoYW5uZWxzLmdldChoYW5kbGUpO1xuXG4gICAgaWYgKGNoYW5uZWwgPT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLnRpbWUgPj0gY2hhbm5lbC5kZWxheSArIGNoYW5uZWwuZHVyYXRpb24gKiBjaGFubmVsLnJlcGVhdDtcbiAgfVxuXG4gIGdldFRpbWUoaGFuZGxlKSB7XG4gICAgaWYgKGhhbmRsZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gdGhpcy50aW1lO1xuICAgIH1cblxuICAgIGNvbnN0IGNoYW5uZWwgPSB0aGlzLmNoYW5uZWxzLmdldChoYW5kbGUpO1xuXG4gICAgaWYgKGNoYW5uZWwgPT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIC0xO1xuICAgIH1cblxuICAgIHJldHVybiBjaGFubmVsLnRpbWU7XG4gIH1cblxuICBzZXRUaW1lKHRpbWUpIHtcbiAgICB0aGlzLnRpbWUgPSBNYXRoLm1heCgwLCB0aW1lKTtcbiAgICBjb25zdCBjaGFubmVscyA9IHRoaXMuY2hhbm5lbHMudmFsdWVzKCk7XG5cbiAgICBmb3IgKGNvbnN0IGNoYW5uZWwgb2YgY2hhbm5lbHMpIHtcbiAgICAgIHRoaXMuX3NldENoYW5uZWxUaW1lKGNoYW5uZWwsIHRoaXMudGltZSk7XG4gICAgfVxuXG4gICAgY29uc3QgYW5pbWF0aW9ucyA9IHRoaXMuYW5pbWF0aW9ucy52YWx1ZXMoKTtcblxuICAgIGZvciAoY29uc3QgYW5pbWF0aW9uRGF0YSBvZiBhbmltYXRpb25zKSB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIGFuaW1hdGlvbixcbiAgICAgICAgY2hhbm5lbFxuICAgICAgfSA9IGFuaW1hdGlvbkRhdGE7XG4gICAgICBhbmltYXRpb24uc2V0VGltZSh0aGlzLmdldFRpbWUoY2hhbm5lbCkpO1xuICAgIH1cbiAgfVxuXG4gIHBsYXkoKSB7XG4gICAgdGhpcy5wbGF5aW5nID0gdHJ1ZTtcbiAgfVxuXG4gIHBhdXNlKCkge1xuICAgIHRoaXMucGxheWluZyA9IGZhbHNlO1xuICAgIHRoaXMubGFzdEVuZ2luZVRpbWUgPSAtMTtcbiAgfVxuXG4gIHJlc2V0KCkge1xuICAgIHRoaXMuc2V0VGltZSgwKTtcbiAgfVxuXG4gIGF0dGFjaEFuaW1hdGlvbihhbmltYXRpb24sIGNoYW5uZWxIYW5kbGUpIHtcbiAgICBjb25zdCBhbmltYXRpb25IYW5kbGUgPSBhbmltYXRpb25IYW5kbGVzKys7XG4gICAgdGhpcy5hbmltYXRpb25zLnNldChhbmltYXRpb25IYW5kbGUsIHtcbiAgICAgIGFuaW1hdGlvbixcbiAgICAgIGNoYW5uZWw6IGNoYW5uZWxIYW5kbGVcbiAgICB9KTtcbiAgICBhbmltYXRpb24uc2V0VGltZSh0aGlzLmdldFRpbWUoY2hhbm5lbEhhbmRsZSkpO1xuICAgIHJldHVybiBhbmltYXRpb25IYW5kbGU7XG4gIH1cblxuICBkZXRhY2hBbmltYXRpb24oaGFuZGxlKSB7XG4gICAgdGhpcy5hbmltYXRpb25zLmRlbGV0ZShoYW5kbGUpO1xuICB9XG5cbiAgdXBkYXRlKGVuZ2luZVRpbWUpIHtcbiAgICBpZiAodGhpcy5wbGF5aW5nKSB7XG4gICAgICBpZiAodGhpcy5sYXN0RW5naW5lVGltZSA9PT0gLTEpIHtcbiAgICAgICAgdGhpcy5sYXN0RW5naW5lVGltZSA9IGVuZ2luZVRpbWU7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuc2V0VGltZSh0aGlzLnRpbWUgKyAoZW5naW5lVGltZSAtIHRoaXMubGFzdEVuZ2luZVRpbWUpKTtcbiAgICAgIHRoaXMubGFzdEVuZ2luZVRpbWUgPSBlbmdpbmVUaW1lO1xuICAgIH1cbiAgfVxuXG4gIF9zZXRDaGFubmVsVGltZShjaGFubmVsLCB0aW1lKSB7XG4gICAgY29uc3Qgb2Zmc2V0VGltZSA9IHRpbWUgLSBjaGFubmVsLmRlbGF5O1xuICAgIGNvbnN0IHRvdGFsRHVyYXRpb24gPSBjaGFubmVsLmR1cmF0aW9uICogY2hhbm5lbC5yZXBlYXQ7XG5cbiAgICBpZiAob2Zmc2V0VGltZSA+PSB0b3RhbER1cmF0aW9uKSB7XG4gICAgICBjaGFubmVsLnRpbWUgPSBjaGFubmVsLmR1cmF0aW9uICogY2hhbm5lbC5yYXRlO1xuICAgIH0gZWxzZSB7XG4gICAgICBjaGFubmVsLnRpbWUgPSBNYXRoLm1heCgwLCBvZmZzZXRUaW1lKSAlIGNoYW5uZWwuZHVyYXRpb247XG4gICAgICBjaGFubmVsLnRpbWUgKj0gY2hhbm5lbC5yYXRlO1xuICAgIH1cbiAgfVxuXG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD10aW1lbGluZS5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///48055\n')},53982:function(__unused_webpack_module,__webpack_exports__,__webpack_require__){eval('/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "Z": function() { return /* binding */ Geometry; }\n/* harmony export */ });\n/* unused harmony export DRAW_MODE */\n/* harmony import */ var _luma_gl_webgl__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(74538);\n/* harmony import */ var _luma_gl_webgl__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(22525);\n\nconst DRAW_MODE = {\n  POINTS: 0x0000,\n  LINES: 0x0001,\n  LINE_LOOP: 0x0002,\n  LINE_STRIP: 0x0003,\n  TRIANGLES: 0x0004,\n  TRIANGLE_STRIP: 0x0005,\n  TRIANGLE_FAN: 0x0006\n};\nclass Geometry {\n  static get DRAW_MODE() {\n    return DRAW_MODE;\n  }\n\n  constructor() {\n    let props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    const {\n      id = (0,_luma_gl_webgl__WEBPACK_IMPORTED_MODULE_0__/* .uid */ .hQ)(\'geometry\'),\n      drawMode = DRAW_MODE.TRIANGLES,\n      attributes = {},\n      indices = null,\n      vertexCount = null\n    } = props;\n    this.id = id;\n    this.drawMode = drawMode | 0;\n    this.attributes = {};\n    this.userData = {};\n\n    this._setAttributes(attributes, indices);\n\n    this.vertexCount = vertexCount || this._calculateVertexCount(this.attributes, this.indices);\n  }\n\n  get mode() {\n    return this.drawMode;\n  }\n\n  getVertexCount() {\n    return this.vertexCount;\n  }\n\n  getAttributes() {\n    return this.indices ? {\n      indices: this.indices,\n      ...this.attributes\n    } : this.attributes;\n  }\n\n  _print(attributeName) {\n    return "Geometry ".concat(this.id, " attribute ").concat(attributeName);\n  }\n\n  _setAttributes(attributes, indices) {\n    if (indices) {\n      this.indices = ArrayBuffer.isView(indices) ? {\n        value: indices,\n        size: 1\n      } : indices;\n    }\n\n    for (const attributeName in attributes) {\n      let attribute = attributes[attributeName];\n      attribute = ArrayBuffer.isView(attribute) ? {\n        value: attribute\n      } : attribute;\n      (0,_luma_gl_webgl__WEBPACK_IMPORTED_MODULE_1__/* .assert */ .h)(ArrayBuffer.isView(attribute.value), "".concat(this._print(attributeName), ": must be typed array or object with value as typed array"));\n\n      if ((attributeName === \'POSITION\' || attributeName === \'positions\') && !attribute.size) {\n        attribute.size = 3;\n      }\n\n      if (attributeName === \'indices\') {\n        (0,_luma_gl_webgl__WEBPACK_IMPORTED_MODULE_1__/* .assert */ .h)(!this.indices);\n        this.indices = attribute;\n      } else {\n        this.attributes[attributeName] = attribute;\n      }\n    }\n\n    if (this.indices && this.indices.isIndexed !== undefined) {\n      this.indices = Object.assign({}, this.indices);\n      delete this.indices.isIndexed;\n    }\n\n    return this;\n  }\n\n  _calculateVertexCount(attributes, indices) {\n    if (indices) {\n      return indices.value.length;\n    }\n\n    let vertexCount = Infinity;\n\n    for (const attributeName in attributes) {\n      const attribute = attributes[attributeName];\n      const {\n        value,\n        size,\n        constant\n      } = attribute;\n\n      if (!constant && value && size >= 1) {\n        vertexCount = Math.min(vertexCount, value.length / size);\n      }\n    }\n\n    (0,_luma_gl_webgl__WEBPACK_IMPORTED_MODULE_1__/* .assert */ .h)(Number.isFinite(vertexCount));\n    return vertexCount;\n  }\n\n}\n//# sourceMappingURL=geometry.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNTM5ODIuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQTZDO0FBQ3RDO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNlO0FBQ2Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsNkRBQUc7QUFDZDtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUixNQUFNLCtEQUFNOztBQUVaO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFFBQVEsK0RBQU07QUFDZDtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxxQ0FBcUM7QUFDckM7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7O0FBRVI7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsSUFBSSwrREFBTTtBQUNWO0FBQ0E7O0FBRUE7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3Z1ZTMtd2VicGFjazUvLi9ub2RlX21vZHVsZXMvQGx1bWEuZ2wvZW5naW5lL2Rpc3QvZXNtL2dlb21ldHJ5L2dlb21ldHJ5LmpzP2E4ZjMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgdWlkLCBhc3NlcnQgfSBmcm9tICdAbHVtYS5nbC93ZWJnbCc7XG5leHBvcnQgY29uc3QgRFJBV19NT0RFID0ge1xuICBQT0lOVFM6IDB4MDAwMCxcbiAgTElORVM6IDB4MDAwMSxcbiAgTElORV9MT09QOiAweDAwMDIsXG4gIExJTkVfU1RSSVA6IDB4MDAwMyxcbiAgVFJJQU5HTEVTOiAweDAwMDQsXG4gIFRSSUFOR0xFX1NUUklQOiAweDAwMDUsXG4gIFRSSUFOR0xFX0ZBTjogMHgwMDA2XG59O1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgR2VvbWV0cnkge1xuICBzdGF0aWMgZ2V0IERSQVdfTU9ERSgpIHtcbiAgICByZXR1cm4gRFJBV19NT0RFO1xuICB9XG5cbiAgY29uc3RydWN0b3IoKSB7XG4gICAgbGV0IHByb3BzID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fTtcbiAgICBjb25zdCB7XG4gICAgICBpZCA9IHVpZCgnZ2VvbWV0cnknKSxcbiAgICAgIGRyYXdNb2RlID0gRFJBV19NT0RFLlRSSUFOR0xFUyxcbiAgICAgIGF0dHJpYnV0ZXMgPSB7fSxcbiAgICAgIGluZGljZXMgPSBudWxsLFxuICAgICAgdmVydGV4Q291bnQgPSBudWxsXG4gICAgfSA9IHByb3BzO1xuICAgIHRoaXMuaWQgPSBpZDtcbiAgICB0aGlzLmRyYXdNb2RlID0gZHJhd01vZGUgfCAwO1xuICAgIHRoaXMuYXR0cmlidXRlcyA9IHt9O1xuICAgIHRoaXMudXNlckRhdGEgPSB7fTtcblxuICAgIHRoaXMuX3NldEF0dHJpYnV0ZXMoYXR0cmlidXRlcywgaW5kaWNlcyk7XG5cbiAgICB0aGlzLnZlcnRleENvdW50ID0gdmVydGV4Q291bnQgfHwgdGhpcy5fY2FsY3VsYXRlVmVydGV4Q291bnQodGhpcy5hdHRyaWJ1dGVzLCB0aGlzLmluZGljZXMpO1xuICB9XG5cbiAgZ2V0IG1vZGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuZHJhd01vZGU7XG4gIH1cblxuICBnZXRWZXJ0ZXhDb3VudCgpIHtcbiAgICByZXR1cm4gdGhpcy52ZXJ0ZXhDb3VudDtcbiAgfVxuXG4gIGdldEF0dHJpYnV0ZXMoKSB7XG4gICAgcmV0dXJuIHRoaXMuaW5kaWNlcyA/IHtcbiAgICAgIGluZGljZXM6IHRoaXMuaW5kaWNlcyxcbiAgICAgIC4uLnRoaXMuYXR0cmlidXRlc1xuICAgIH0gOiB0aGlzLmF0dHJpYnV0ZXM7XG4gIH1cblxuICBfcHJpbnQoYXR0cmlidXRlTmFtZSkge1xuICAgIHJldHVybiBcIkdlb21ldHJ5IFwiLmNvbmNhdCh0aGlzLmlkLCBcIiBhdHRyaWJ1dGUgXCIpLmNvbmNhdChhdHRyaWJ1dGVOYW1lKTtcbiAgfVxuXG4gIF9zZXRBdHRyaWJ1dGVzKGF0dHJpYnV0ZXMsIGluZGljZXMpIHtcbiAgICBpZiAoaW5kaWNlcykge1xuICAgICAgdGhpcy5pbmRpY2VzID0gQXJyYXlCdWZmZXIuaXNWaWV3KGluZGljZXMpID8ge1xuICAgICAgICB2YWx1ZTogaW5kaWNlcyxcbiAgICAgICAgc2l6ZTogMVxuICAgICAgfSA6IGluZGljZXM7XG4gICAgfVxuXG4gICAgZm9yIChjb25zdCBhdHRyaWJ1dGVOYW1lIGluIGF0dHJpYnV0ZXMpIHtcbiAgICAgIGxldCBhdHRyaWJ1dGUgPSBhdHRyaWJ1dGVzW2F0dHJpYnV0ZU5hbWVdO1xuICAgICAgYXR0cmlidXRlID0gQXJyYXlCdWZmZXIuaXNWaWV3KGF0dHJpYnV0ZSkgPyB7XG4gICAgICAgIHZhbHVlOiBhdHRyaWJ1dGVcbiAgICAgIH0gOiBhdHRyaWJ1dGU7XG4gICAgICBhc3NlcnQoQXJyYXlCdWZmZXIuaXNWaWV3KGF0dHJpYnV0ZS52YWx1ZSksIFwiXCIuY29uY2F0KHRoaXMuX3ByaW50KGF0dHJpYnV0ZU5hbWUpLCBcIjogbXVzdCBiZSB0eXBlZCBhcnJheSBvciBvYmplY3Qgd2l0aCB2YWx1ZSBhcyB0eXBlZCBhcnJheVwiKSk7XG5cbiAgICAgIGlmICgoYXR0cmlidXRlTmFtZSA9PT0gJ1BPU0lUSU9OJyB8fCBhdHRyaWJ1dGVOYW1lID09PSAncG9zaXRpb25zJykgJiYgIWF0dHJpYnV0ZS5zaXplKSB7XG4gICAgICAgIGF0dHJpYnV0ZS5zaXplID0gMztcbiAgICAgIH1cblxuICAgICAgaWYgKGF0dHJpYnV0ZU5hbWUgPT09ICdpbmRpY2VzJykge1xuICAgICAgICBhc3NlcnQoIXRoaXMuaW5kaWNlcyk7XG4gICAgICAgIHRoaXMuaW5kaWNlcyA9IGF0dHJpYnV0ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuYXR0cmlidXRlc1thdHRyaWJ1dGVOYW1lXSA9IGF0dHJpYnV0ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAodGhpcy5pbmRpY2VzICYmIHRoaXMuaW5kaWNlcy5pc0luZGV4ZWQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhpcy5pbmRpY2VzID0gT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5pbmRpY2VzKTtcbiAgICAgIGRlbGV0ZSB0aGlzLmluZGljZXMuaXNJbmRleGVkO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgX2NhbGN1bGF0ZVZlcnRleENvdW50KGF0dHJpYnV0ZXMsIGluZGljZXMpIHtcbiAgICBpZiAoaW5kaWNlcykge1xuICAgICAgcmV0dXJuIGluZGljZXMudmFsdWUubGVuZ3RoO1xuICAgIH1cblxuICAgIGxldCB2ZXJ0ZXhDb3VudCA9IEluZmluaXR5O1xuXG4gICAgZm9yIChjb25zdCBhdHRyaWJ1dGVOYW1lIGluIGF0dHJpYnV0ZXMpIHtcbiAgICAgIGNvbnN0IGF0dHJpYnV0ZSA9IGF0dHJpYnV0ZXNbYXR0cmlidXRlTmFtZV07XG4gICAgICBjb25zdCB7XG4gICAgICAgIHZhbHVlLFxuICAgICAgICBzaXplLFxuICAgICAgICBjb25zdGFudFxuICAgICAgfSA9IGF0dHJpYnV0ZTtcblxuICAgICAgaWYgKCFjb25zdGFudCAmJiB2YWx1ZSAmJiBzaXplID49IDEpIHtcbiAgICAgICAgdmVydGV4Q291bnQgPSBNYXRoLm1pbih2ZXJ0ZXhDb3VudCwgdmFsdWUubGVuZ3RoIC8gc2l6ZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgYXNzZXJ0KE51bWJlci5pc0Zpbml0ZSh2ZXJ0ZXhDb3VudCkpO1xuICAgIHJldHVybiB2ZXJ0ZXhDb3VudDtcbiAgfVxuXG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1nZW9tZXRyeS5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///53982\n')},16816:function(__unused_webpack_module,__webpack_exports__,__webpack_require__){eval("/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Z\": function() { return /* binding */ AnimationLoop; }\n/* harmony export */ });\n/* harmony import */ var _luma_gl_gltools__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(1418);\n/* harmony import */ var _luma_gl_webgl__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(49835);\n/* harmony import */ var _luma_gl_webgl__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(22525);\n/* harmony import */ var _luma_gl_webgl__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(14178);\n/* harmony import */ var _luma_gl_webgl__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(37178);\n/* harmony import */ var _luma_gl_webgl__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(53849);\n/* harmony import */ var _probe_gl_env__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(93370);\n\n\n\nconst isPage = (0,_probe_gl_env__WEBPACK_IMPORTED_MODULE_1__/* [\"default\"] */ .Z)() && typeof document !== 'undefined';\nlet statIdCounter = 0;\nclass AnimationLoop {\n  constructor() {\n    let props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    const {\n      onCreateContext = opts => (0,_luma_gl_gltools__WEBPACK_IMPORTED_MODULE_0__/* .createGLContext */ .s9)(opts),\n      onAddHTML = null,\n      onInitialize = () => {},\n      onRender = () => {},\n      onFinalize = () => {},\n      onError,\n      gl = null,\n      glOptions = {},\n      debug = false,\n      createFramebuffer = false,\n      autoResizeViewport = true,\n      autoResizeDrawingBuffer = true,\n      stats = _luma_gl_webgl__WEBPACK_IMPORTED_MODULE_2__/* .lumaStats.get */ .lR.get(\"animation-loop-\".concat(statIdCounter++))\n    } = props;\n    let {\n      useDevicePixels = true\n    } = props;\n\n    if ('useDevicePixelRatio' in props) {\n      _luma_gl_gltools__WEBPACK_IMPORTED_MODULE_0__/* .log.deprecated */ .cM.deprecated('useDevicePixelRatio', 'useDevicePixels')();\n      useDevicePixels = props.useDevicePixelRatio;\n    }\n\n    this.props = {\n      onCreateContext,\n      onAddHTML,\n      onInitialize,\n      onRender,\n      onFinalize,\n      onError,\n      gl,\n      glOptions,\n      debug,\n      createFramebuffer\n    };\n    this.gl = gl;\n    this.needsRedraw = null;\n    this.timeline = null;\n    this.stats = stats;\n    this.cpuTime = this.stats.get('CPU Time');\n    this.gpuTime = this.stats.get('GPU Time');\n    this.frameRate = this.stats.get('Frame Rate');\n    this._initialized = false;\n    this._running = false;\n    this._animationFrameId = null;\n    this._nextFramePromise = null;\n    this._resolveNextFrame = null;\n    this._cpuStartTime = 0;\n    this.setProps({\n      autoResizeViewport,\n      autoResizeDrawingBuffer,\n      useDevicePixels\n    });\n    this.start = this.start.bind(this);\n    this.stop = this.stop.bind(this);\n    this._pageLoadPromise = null;\n    this._onMousemove = this._onMousemove.bind(this);\n    this._onMouseleave = this._onMouseleave.bind(this);\n  }\n\n  delete() {\n    this.stop();\n\n    this._setDisplay(null);\n  }\n\n  setNeedsRedraw(reason) {\n    (0,_luma_gl_webgl__WEBPACK_IMPORTED_MODULE_3__/* .assert */ .h)(typeof reason === 'string');\n    this.needsRedraw = this.needsRedraw || reason;\n    return this;\n  }\n\n  setProps(props) {\n    if ('autoResizeViewport' in props) {\n      this.autoResizeViewport = props.autoResizeViewport;\n    }\n\n    if ('autoResizeDrawingBuffer' in props) {\n      this.autoResizeDrawingBuffer = props.autoResizeDrawingBuffer;\n    }\n\n    if ('useDevicePixels' in props) {\n      this.useDevicePixels = props.useDevicePixels;\n    }\n\n    return this;\n  }\n\n  start() {\n    let opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    if (this._running) {\n      return this;\n    }\n\n    this._running = true;\n\n    const startPromise = this._getPageLoadPromise().then(() => {\n      if (!this._running || this._initialized) {\n        return null;\n      }\n\n      this._createWebGLContext(opts);\n\n      this._createFramebuffer();\n\n      this._startEventHandling();\n\n      this._initializeCallbackData();\n\n      this._updateCallbackData();\n\n      this._resizeCanvasDrawingBuffer();\n\n      this._resizeViewport();\n\n      this._gpuTimeQuery = _luma_gl_webgl__WEBPACK_IMPORTED_MODULE_4__/* [\"default\"].isSupported */ .Z.isSupported(this.gl, ['timers']) ? new _luma_gl_webgl__WEBPACK_IMPORTED_MODULE_4__/* [\"default\"] */ .Z(this.gl) : null;\n      this._initialized = true;\n      return this.onInitialize(this.animationProps);\n    }).then(appContext => {\n      if (this._running) {\n        this._addCallbackData(appContext || {});\n\n        if (appContext !== false) {\n          this._startLoop();\n        }\n      }\n    });\n\n    if (this.props.onError) {\n      startPromise.catch(this.props.onError);\n    }\n\n    return this;\n  }\n\n  redraw() {\n    if (this.isContextLost()) {\n      return this;\n    }\n\n    this._beginTimers();\n\n    this._setupFrame();\n\n    this._updateCallbackData();\n\n    this._renderFrame(this.animationProps);\n\n    this._clearNeedsRedraw();\n\n    if (this.offScreen && this.gl.commit) {\n      this.gl.commit();\n    }\n\n    if (this._resolveNextFrame) {\n      this._resolveNextFrame(this);\n\n      this._nextFramePromise = null;\n      this._resolveNextFrame = null;\n    }\n\n    this._endTimers();\n\n    return this;\n  }\n\n  stop() {\n    if (this._running) {\n      this._finalizeCallbackData();\n\n      this._cancelAnimationFrame(this._animationFrameId);\n\n      this._nextFramePromise = null;\n      this._resolveNextFrame = null;\n      this._animationFrameId = null;\n      this._running = false;\n    }\n\n    return this;\n  }\n\n  attachTimeline(timeline) {\n    this.timeline = timeline;\n    return this.timeline;\n  }\n\n  detachTimeline() {\n    this.timeline = null;\n  }\n\n  waitForRender() {\n    this.setNeedsRedraw('waitForRender');\n\n    if (!this._nextFramePromise) {\n      this._nextFramePromise = new Promise(resolve => {\n        this._resolveNextFrame = resolve;\n      });\n    }\n\n    return this._nextFramePromise;\n  }\n\n  async toDataURL() {\n    this.setNeedsRedraw('toDataURL');\n    await this.waitForRender();\n    return this.gl.canvas.toDataURL();\n  }\n\n  isContextLost() {\n    return this.gl.isContextLost();\n  }\n\n  onCreateContext() {\n    return this.props.onCreateContext(...arguments);\n  }\n\n  onInitialize() {\n    return this.props.onInitialize(...arguments);\n  }\n\n  onRender() {\n    return this.props.onRender(...arguments);\n  }\n\n  onFinalize() {\n    return this.props.onFinalize(...arguments);\n  }\n\n  getHTMLControlValue(id) {\n    let defaultValue = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\n    const element = document.getElementById(id);\n    return element ? Number(element.value) : defaultValue;\n  }\n\n  setViewParameters() {\n    _luma_gl_gltools__WEBPACK_IMPORTED_MODULE_0__/* .log.removed */ .cM.removed('AnimationLoop.setViewParameters', 'AnimationLoop.setProps')();\n    return this;\n  }\n\n  _startLoop() {\n    const renderFrame = () => {\n      if (!this._running) {\n        return;\n      }\n\n      this.redraw();\n      this._animationFrameId = this._requestAnimationFrame(renderFrame);\n    };\n\n    this._cancelAnimationFrame(this._animationFrameId);\n\n    this._animationFrameId = this._requestAnimationFrame(renderFrame);\n  }\n\n  _getPageLoadPromise() {\n    if (!this._pageLoadPromise) {\n      this._pageLoadPromise = isPage ? new Promise((resolve, reject) => {\n        if (isPage && document.readyState === 'complete') {\n          resolve(document);\n          return;\n        }\n\n        window.addEventListener('load', () => {\n          resolve(document);\n        });\n      }) : Promise.resolve({});\n    }\n\n    return this._pageLoadPromise;\n  }\n\n  _setDisplay(display) {\n    if (this.display) {\n      this.display.delete();\n      this.display.animationLoop = null;\n    }\n\n    if (display) {\n      display.animationLoop = this;\n    }\n\n    this.display = display;\n  }\n\n  _cancelAnimationFrame(animationFrameId) {\n    if (this.display && this.display.cancelAnimationFrame) {\n      return this.display.cancelAnimationFrame(animationFrameId);\n    }\n\n    return (0,_luma_gl_webgl__WEBPACK_IMPORTED_MODULE_5__/* .cancelAnimationFrame */ .W)(animationFrameId);\n  }\n\n  _requestAnimationFrame(renderFrameCallback) {\n    if (this._running) {\n      if (this.display && this.display.requestAnimationFrame) {\n        return this.display.requestAnimationFrame(renderFrameCallback);\n      }\n\n      return (0,_luma_gl_webgl__WEBPACK_IMPORTED_MODULE_5__/* .requestAnimationFrame */ .U)(renderFrameCallback);\n    }\n\n    return undefined;\n  }\n\n  _renderFrame() {\n    if (this.display) {\n      this.display._renderFrame(...arguments);\n\n      return;\n    }\n\n    this.onRender(...arguments);\n  }\n\n  _clearNeedsRedraw() {\n    this.needsRedraw = null;\n  }\n\n  _setupFrame() {\n    this._resizeCanvasDrawingBuffer();\n\n    this._resizeViewport();\n\n    this._resizeFramebuffer();\n  }\n\n  _initializeCallbackData() {\n    this.animationProps = {\n      gl: this.gl,\n      stop: this.stop,\n      canvas: this.gl.canvas,\n      framebuffer: this.framebuffer,\n      useDevicePixels: this.useDevicePixels,\n      needsRedraw: null,\n      startTime: Date.now(),\n      engineTime: 0,\n      tick: 0,\n      tock: 0,\n      time: 0,\n      _timeline: this.timeline,\n      _loop: this,\n      _animationLoop: this,\n      _mousePosition: null\n    };\n  }\n\n  _updateCallbackData() {\n    const {\n      width,\n      height,\n      aspect\n    } = this._getSizeAndAspect();\n\n    if (width !== this.animationProps.width || height !== this.animationProps.height) {\n      this.setNeedsRedraw('drawing buffer resized');\n    }\n\n    if (aspect !== this.animationProps.aspect) {\n      this.setNeedsRedraw('drawing buffer aspect changed');\n    }\n\n    this.animationProps.width = width;\n    this.animationProps.height = height;\n    this.animationProps.aspect = aspect;\n    this.animationProps.needsRedraw = this.needsRedraw;\n    this.animationProps.engineTime = Date.now() - this.animationProps.startTime;\n\n    if (this.timeline) {\n      this.timeline.update(this.animationProps.engineTime);\n    }\n\n    this.animationProps.tick = Math.floor(this.animationProps.time / 1000 * 60);\n    this.animationProps.tock++;\n    this.animationProps.time = this.timeline ? this.timeline.getTime() : this.animationProps.engineTime;\n    this.animationProps._offScreen = this.offScreen;\n  }\n\n  _finalizeCallbackData() {\n    this.onFinalize(this.animationProps);\n  }\n\n  _addCallbackData(appContext) {\n    if (typeof appContext === 'object' && appContext !== null) {\n      this.animationProps = Object.assign({}, this.animationProps, appContext);\n    }\n  }\n\n  _createWebGLContext(opts) {\n    this.offScreen = opts.canvas && typeof OffscreenCanvas !== 'undefined' && opts.canvas instanceof OffscreenCanvas;\n    opts = Object.assign({}, opts, this.props.glOptions);\n    this.gl = this.props.gl ? (0,_luma_gl_gltools__WEBPACK_IMPORTED_MODULE_0__/* .instrumentGLContext */ .yW)(this.props.gl, opts) : this.onCreateContext(opts);\n\n    if (!(0,_luma_gl_gltools__WEBPACK_IMPORTED_MODULE_0__/* .isWebGL */ .UF)(this.gl)) {\n      throw new Error('AnimationLoop.onCreateContext - illegal context returned');\n    }\n\n    (0,_luma_gl_gltools__WEBPACK_IMPORTED_MODULE_0__/* .resetParameters */ .kL)(this.gl);\n\n    this._createInfoDiv();\n  }\n\n  _createInfoDiv() {\n    if (this.gl.canvas && this.props.onAddHTML) {\n      const wrapperDiv = document.createElement('div');\n      document.body.appendChild(wrapperDiv);\n      wrapperDiv.style.position = 'relative';\n      const div = document.createElement('div');\n      div.style.position = 'absolute';\n      div.style.left = '10px';\n      div.style.bottom = '10px';\n      div.style.width = '300px';\n      div.style.background = 'white';\n      wrapperDiv.appendChild(this.gl.canvas);\n      wrapperDiv.appendChild(div);\n      const html = this.props.onAddHTML(div);\n\n      if (html) {\n        div.innerHTML = html;\n      }\n    }\n  }\n\n  _getSizeAndAspect() {\n    const width = this.gl.drawingBufferWidth;\n    const height = this.gl.drawingBufferHeight;\n    let aspect = 1;\n    const {\n      canvas\n    } = this.gl;\n\n    if (canvas && canvas.clientHeight) {\n      aspect = canvas.clientWidth / canvas.clientHeight;\n    } else if (width > 0 && height > 0) {\n      aspect = width / height;\n    }\n\n    return {\n      width,\n      height,\n      aspect\n    };\n  }\n\n  _resizeViewport() {\n    if (this.autoResizeViewport) {\n      this.gl.viewport(0, 0, this.gl.drawingBufferWidth, this.gl.drawingBufferHeight);\n    }\n  }\n\n  _resizeCanvasDrawingBuffer() {\n    if (this.autoResizeDrawingBuffer) {\n      (0,_luma_gl_gltools__WEBPACK_IMPORTED_MODULE_0__/* .resizeGLContext */ .aQ)(this.gl, {\n        useDevicePixels: this.useDevicePixels\n      });\n    }\n  }\n\n  _createFramebuffer() {\n    if (this.props.createFramebuffer) {\n      this.framebuffer = new _luma_gl_webgl__WEBPACK_IMPORTED_MODULE_6__/* [\"default\"] */ .Z(this.gl);\n    }\n  }\n\n  _resizeFramebuffer() {\n    if (this.framebuffer) {\n      this.framebuffer.resize({\n        width: this.gl.drawingBufferWidth,\n        height: this.gl.drawingBufferHeight\n      });\n    }\n  }\n\n  _beginTimers() {\n    this.frameRate.timeEnd();\n    this.frameRate.timeStart();\n\n    if (this._gpuTimeQuery && this._gpuTimeQuery.isResultAvailable() && !this._gpuTimeQuery.isTimerDisjoint()) {\n      this.stats.get('GPU Time').addTime(this._gpuTimeQuery.getTimerMilliseconds());\n    }\n\n    if (this._gpuTimeQuery) {\n      this._gpuTimeQuery.beginTimeElapsedQuery();\n    }\n\n    this.cpuTime.timeStart();\n  }\n\n  _endTimers() {\n    this.cpuTime.timeEnd();\n\n    if (this._gpuTimeQuery) {\n      this._gpuTimeQuery.end();\n    }\n  }\n\n  _startEventHandling() {\n    const {\n      canvas\n    } = this.gl;\n\n    if (canvas) {\n      canvas.addEventListener('mousemove', this._onMousemove);\n      canvas.addEventListener('mouseleave', this._onMouseleave);\n    }\n  }\n\n  _onMousemove(e) {\n    this.animationProps._mousePosition = [e.offsetX, e.offsetY];\n  }\n\n  _onMouseleave(e) {\n    this.animationProps._mousePosition = null;\n  }\n\n}\n//# sourceMappingURL=animation-loop.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTY4MTYuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7OztBQUFtSDtBQUNNO0FBQy9FO0FBQzFDLGVBQWUsa0VBQVM7QUFDeEI7QUFDZTtBQUNmO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQywyRUFBZTtBQUMvQztBQUNBLDZCQUE2QjtBQUM3Qix5QkFBeUI7QUFDekIsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLHVFQUFhO0FBQzNCLE1BQU07QUFDTjtBQUNBO0FBQ0EsTUFBTTs7QUFFTjtBQUNBLE1BQU0saUZBQWM7QUFDcEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxJQUFJLCtEQUFNO0FBQ1Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSwyQkFBMkIsdUZBQWlCLDRCQUE0QiwrREFBSztBQUM3RTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsOENBQThDOztBQUU5QztBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLElBQUksMkVBQVc7QUFDZjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPLHNCQUFzQjtBQUM3Qjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsV0FBVyw2RUFBb0I7QUFDL0I7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxhQUFhLDhFQUFxQjtBQUNsQzs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTs7QUFFTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSw0Q0FBNEM7QUFDNUM7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCLDhCQUE4QiwrRUFBbUI7O0FBRWpELFNBQVMsbUVBQU87QUFDaEI7QUFDQTs7QUFFQSxJQUFJLDJFQUFlOztBQUVuQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNOztBQUVOO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTSwyRUFBZTtBQUNyQjtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQSw2QkFBNkIsK0RBQVc7QUFDeEM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07O0FBRU47QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly92dWUzLXdlYnBhY2s1Ly4vbm9kZV9tb2R1bGVzL0BsdW1hLmdsL2VuZ2luZS9kaXN0L2VzbS9saWIvYW5pbWF0aW9uLWxvb3AuanM/ODcwYSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBpc1dlYkdMLCBjcmVhdGVHTENvbnRleHQsIGluc3RydW1lbnRHTENvbnRleHQsIHJlc2l6ZUdMQ29udGV4dCwgcmVzZXRQYXJhbWV0ZXJzIH0gZnJvbSAnQGx1bWEuZ2wvZ2x0b29scyc7XG5pbXBvcnQgeyByZXF1ZXN0QW5pbWF0aW9uRnJhbWUsIGNhbmNlbEFuaW1hdGlvbkZyYW1lLCBRdWVyeSwgbHVtYVN0YXRzLCBGcmFtZWJ1ZmZlciwgbG9nLCBhc3NlcnQgfSBmcm9tICdAbHVtYS5nbC93ZWJnbCc7XG5pbXBvcnQgeyBpc0Jyb3dzZXIgfSBmcm9tICdAcHJvYmUuZ2wvZW52JztcbmNvbnN0IGlzUGFnZSA9IGlzQnJvd3NlcigpICYmIHR5cGVvZiBkb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCc7XG5sZXQgc3RhdElkQ291bnRlciA9IDA7XG5leHBvcnQgZGVmYXVsdCBjbGFzcyBBbmltYXRpb25Mb29wIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgbGV0IHByb3BzID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fTtcbiAgICBjb25zdCB7XG4gICAgICBvbkNyZWF0ZUNvbnRleHQgPSBvcHRzID0+IGNyZWF0ZUdMQ29udGV4dChvcHRzKSxcbiAgICAgIG9uQWRkSFRNTCA9IG51bGwsXG4gICAgICBvbkluaXRpYWxpemUgPSAoKSA9PiB7fSxcbiAgICAgIG9uUmVuZGVyID0gKCkgPT4ge30sXG4gICAgICBvbkZpbmFsaXplID0gKCkgPT4ge30sXG4gICAgICBvbkVycm9yLFxuICAgICAgZ2wgPSBudWxsLFxuICAgICAgZ2xPcHRpb25zID0ge30sXG4gICAgICBkZWJ1ZyA9IGZhbHNlLFxuICAgICAgY3JlYXRlRnJhbWVidWZmZXIgPSBmYWxzZSxcbiAgICAgIGF1dG9SZXNpemVWaWV3cG9ydCA9IHRydWUsXG4gICAgICBhdXRvUmVzaXplRHJhd2luZ0J1ZmZlciA9IHRydWUsXG4gICAgICBzdGF0cyA9IGx1bWFTdGF0cy5nZXQoXCJhbmltYXRpb24tbG9vcC1cIi5jb25jYXQoc3RhdElkQ291bnRlcisrKSlcbiAgICB9ID0gcHJvcHM7XG4gICAgbGV0IHtcbiAgICAgIHVzZURldmljZVBpeGVscyA9IHRydWVcbiAgICB9ID0gcHJvcHM7XG5cbiAgICBpZiAoJ3VzZURldmljZVBpeGVsUmF0aW8nIGluIHByb3BzKSB7XG4gICAgICBsb2cuZGVwcmVjYXRlZCgndXNlRGV2aWNlUGl4ZWxSYXRpbycsICd1c2VEZXZpY2VQaXhlbHMnKSgpO1xuICAgICAgdXNlRGV2aWNlUGl4ZWxzID0gcHJvcHMudXNlRGV2aWNlUGl4ZWxSYXRpbztcbiAgICB9XG5cbiAgICB0aGlzLnByb3BzID0ge1xuICAgICAgb25DcmVhdGVDb250ZXh0LFxuICAgICAgb25BZGRIVE1MLFxuICAgICAgb25Jbml0aWFsaXplLFxuICAgICAgb25SZW5kZXIsXG4gICAgICBvbkZpbmFsaXplLFxuICAgICAgb25FcnJvcixcbiAgICAgIGdsLFxuICAgICAgZ2xPcHRpb25zLFxuICAgICAgZGVidWcsXG4gICAgICBjcmVhdGVGcmFtZWJ1ZmZlclxuICAgIH07XG4gICAgdGhpcy5nbCA9IGdsO1xuICAgIHRoaXMubmVlZHNSZWRyYXcgPSBudWxsO1xuICAgIHRoaXMudGltZWxpbmUgPSBudWxsO1xuICAgIHRoaXMuc3RhdHMgPSBzdGF0cztcbiAgICB0aGlzLmNwdVRpbWUgPSB0aGlzLnN0YXRzLmdldCgnQ1BVIFRpbWUnKTtcbiAgICB0aGlzLmdwdVRpbWUgPSB0aGlzLnN0YXRzLmdldCgnR1BVIFRpbWUnKTtcbiAgICB0aGlzLmZyYW1lUmF0ZSA9IHRoaXMuc3RhdHMuZ2V0KCdGcmFtZSBSYXRlJyk7XG4gICAgdGhpcy5faW5pdGlhbGl6ZWQgPSBmYWxzZTtcbiAgICB0aGlzLl9ydW5uaW5nID0gZmFsc2U7XG4gICAgdGhpcy5fYW5pbWF0aW9uRnJhbWVJZCA9IG51bGw7XG4gICAgdGhpcy5fbmV4dEZyYW1lUHJvbWlzZSA9IG51bGw7XG4gICAgdGhpcy5fcmVzb2x2ZU5leHRGcmFtZSA9IG51bGw7XG4gICAgdGhpcy5fY3B1U3RhcnRUaW1lID0gMDtcbiAgICB0aGlzLnNldFByb3BzKHtcbiAgICAgIGF1dG9SZXNpemVWaWV3cG9ydCxcbiAgICAgIGF1dG9SZXNpemVEcmF3aW5nQnVmZmVyLFxuICAgICAgdXNlRGV2aWNlUGl4ZWxzXG4gICAgfSk7XG4gICAgdGhpcy5zdGFydCA9IHRoaXMuc3RhcnQuYmluZCh0aGlzKTtcbiAgICB0aGlzLnN0b3AgPSB0aGlzLnN0b3AuYmluZCh0aGlzKTtcbiAgICB0aGlzLl9wYWdlTG9hZFByb21pc2UgPSBudWxsO1xuICAgIHRoaXMuX29uTW91c2Vtb3ZlID0gdGhpcy5fb25Nb3VzZW1vdmUuYmluZCh0aGlzKTtcbiAgICB0aGlzLl9vbk1vdXNlbGVhdmUgPSB0aGlzLl9vbk1vdXNlbGVhdmUuYmluZCh0aGlzKTtcbiAgfVxuXG4gIGRlbGV0ZSgpIHtcbiAgICB0aGlzLnN0b3AoKTtcblxuICAgIHRoaXMuX3NldERpc3BsYXkobnVsbCk7XG4gIH1cblxuICBzZXROZWVkc1JlZHJhdyhyZWFzb24pIHtcbiAgICBhc3NlcnQodHlwZW9mIHJlYXNvbiA9PT0gJ3N0cmluZycpO1xuICAgIHRoaXMubmVlZHNSZWRyYXcgPSB0aGlzLm5lZWRzUmVkcmF3IHx8IHJlYXNvbjtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIHNldFByb3BzKHByb3BzKSB7XG4gICAgaWYgKCdhdXRvUmVzaXplVmlld3BvcnQnIGluIHByb3BzKSB7XG4gICAgICB0aGlzLmF1dG9SZXNpemVWaWV3cG9ydCA9IHByb3BzLmF1dG9SZXNpemVWaWV3cG9ydDtcbiAgICB9XG5cbiAgICBpZiAoJ2F1dG9SZXNpemVEcmF3aW5nQnVmZmVyJyBpbiBwcm9wcykge1xuICAgICAgdGhpcy5hdXRvUmVzaXplRHJhd2luZ0J1ZmZlciA9IHByb3BzLmF1dG9SZXNpemVEcmF3aW5nQnVmZmVyO1xuICAgIH1cblxuICAgIGlmICgndXNlRGV2aWNlUGl4ZWxzJyBpbiBwcm9wcykge1xuICAgICAgdGhpcy51c2VEZXZpY2VQaXhlbHMgPSBwcm9wcy51c2VEZXZpY2VQaXhlbHM7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICBzdGFydCgpIHtcbiAgICBsZXQgb3B0cyA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge307XG5cbiAgICBpZiAodGhpcy5fcnVubmluZykge1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgdGhpcy5fcnVubmluZyA9IHRydWU7XG5cbiAgICBjb25zdCBzdGFydFByb21pc2UgPSB0aGlzLl9nZXRQYWdlTG9hZFByb21pc2UoKS50aGVuKCgpID0+IHtcbiAgICAgIGlmICghdGhpcy5fcnVubmluZyB8fCB0aGlzLl9pbml0aWFsaXplZCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cblxuICAgICAgdGhpcy5fY3JlYXRlV2ViR0xDb250ZXh0KG9wdHMpO1xuXG4gICAgICB0aGlzLl9jcmVhdGVGcmFtZWJ1ZmZlcigpO1xuXG4gICAgICB0aGlzLl9zdGFydEV2ZW50SGFuZGxpbmcoKTtcblxuICAgICAgdGhpcy5faW5pdGlhbGl6ZUNhbGxiYWNrRGF0YSgpO1xuXG4gICAgICB0aGlzLl91cGRhdGVDYWxsYmFja0RhdGEoKTtcblxuICAgICAgdGhpcy5fcmVzaXplQ2FudmFzRHJhd2luZ0J1ZmZlcigpO1xuXG4gICAgICB0aGlzLl9yZXNpemVWaWV3cG9ydCgpO1xuXG4gICAgICB0aGlzLl9ncHVUaW1lUXVlcnkgPSBRdWVyeS5pc1N1cHBvcnRlZCh0aGlzLmdsLCBbJ3RpbWVycyddKSA/IG5ldyBRdWVyeSh0aGlzLmdsKSA6IG51bGw7XG4gICAgICB0aGlzLl9pbml0aWFsaXplZCA9IHRydWU7XG4gICAgICByZXR1cm4gdGhpcy5vbkluaXRpYWxpemUodGhpcy5hbmltYXRpb25Qcm9wcyk7XG4gICAgfSkudGhlbihhcHBDb250ZXh0ID0+IHtcbiAgICAgIGlmICh0aGlzLl9ydW5uaW5nKSB7XG4gICAgICAgIHRoaXMuX2FkZENhbGxiYWNrRGF0YShhcHBDb250ZXh0IHx8IHt9KTtcblxuICAgICAgICBpZiAoYXBwQ29udGV4dCAhPT0gZmFsc2UpIHtcbiAgICAgICAgICB0aGlzLl9zdGFydExvb3AoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuXG4gICAgaWYgKHRoaXMucHJvcHMub25FcnJvcikge1xuICAgICAgc3RhcnRQcm9taXNlLmNhdGNoKHRoaXMucHJvcHMub25FcnJvcik7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICByZWRyYXcoKSB7XG4gICAgaWYgKHRoaXMuaXNDb250ZXh0TG9zdCgpKSB7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICB0aGlzLl9iZWdpblRpbWVycygpO1xuXG4gICAgdGhpcy5fc2V0dXBGcmFtZSgpO1xuXG4gICAgdGhpcy5fdXBkYXRlQ2FsbGJhY2tEYXRhKCk7XG5cbiAgICB0aGlzLl9yZW5kZXJGcmFtZSh0aGlzLmFuaW1hdGlvblByb3BzKTtcblxuICAgIHRoaXMuX2NsZWFyTmVlZHNSZWRyYXcoKTtcblxuICAgIGlmICh0aGlzLm9mZlNjcmVlbiAmJiB0aGlzLmdsLmNvbW1pdCkge1xuICAgICAgdGhpcy5nbC5jb21taXQoKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5fcmVzb2x2ZU5leHRGcmFtZSkge1xuICAgICAgdGhpcy5fcmVzb2x2ZU5leHRGcmFtZSh0aGlzKTtcblxuICAgICAgdGhpcy5fbmV4dEZyYW1lUHJvbWlzZSA9IG51bGw7XG4gICAgICB0aGlzLl9yZXNvbHZlTmV4dEZyYW1lID0gbnVsbDtcbiAgICB9XG5cbiAgICB0aGlzLl9lbmRUaW1lcnMoKTtcblxuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgc3RvcCgpIHtcbiAgICBpZiAodGhpcy5fcnVubmluZykge1xuICAgICAgdGhpcy5fZmluYWxpemVDYWxsYmFja0RhdGEoKTtcblxuICAgICAgdGhpcy5fY2FuY2VsQW5pbWF0aW9uRnJhbWUodGhpcy5fYW5pbWF0aW9uRnJhbWVJZCk7XG5cbiAgICAgIHRoaXMuX25leHRGcmFtZVByb21pc2UgPSBudWxsO1xuICAgICAgdGhpcy5fcmVzb2x2ZU5leHRGcmFtZSA9IG51bGw7XG4gICAgICB0aGlzLl9hbmltYXRpb25GcmFtZUlkID0gbnVsbDtcbiAgICAgIHRoaXMuX3J1bm5pbmcgPSBmYWxzZTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIGF0dGFjaFRpbWVsaW5lKHRpbWVsaW5lKSB7XG4gICAgdGhpcy50aW1lbGluZSA9IHRpbWVsaW5lO1xuICAgIHJldHVybiB0aGlzLnRpbWVsaW5lO1xuICB9XG5cbiAgZGV0YWNoVGltZWxpbmUoKSB7XG4gICAgdGhpcy50aW1lbGluZSA9IG51bGw7XG4gIH1cblxuICB3YWl0Rm9yUmVuZGVyKCkge1xuICAgIHRoaXMuc2V0TmVlZHNSZWRyYXcoJ3dhaXRGb3JSZW5kZXInKTtcblxuICAgIGlmICghdGhpcy5fbmV4dEZyYW1lUHJvbWlzZSkge1xuICAgICAgdGhpcy5fbmV4dEZyYW1lUHJvbWlzZSA9IG5ldyBQcm9taXNlKHJlc29sdmUgPT4ge1xuICAgICAgICB0aGlzLl9yZXNvbHZlTmV4dEZyYW1lID0gcmVzb2x2ZTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLl9uZXh0RnJhbWVQcm9taXNlO1xuICB9XG5cbiAgYXN5bmMgdG9EYXRhVVJMKCkge1xuICAgIHRoaXMuc2V0TmVlZHNSZWRyYXcoJ3RvRGF0YVVSTCcpO1xuICAgIGF3YWl0IHRoaXMud2FpdEZvclJlbmRlcigpO1xuICAgIHJldHVybiB0aGlzLmdsLmNhbnZhcy50b0RhdGFVUkwoKTtcbiAgfVxuXG4gIGlzQ29udGV4dExvc3QoKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2wuaXNDb250ZXh0TG9zdCgpO1xuICB9XG5cbiAgb25DcmVhdGVDb250ZXh0KCkge1xuICAgIHJldHVybiB0aGlzLnByb3BzLm9uQ3JlYXRlQ29udGV4dCguLi5hcmd1bWVudHMpO1xuICB9XG5cbiAgb25Jbml0aWFsaXplKCkge1xuICAgIHJldHVybiB0aGlzLnByb3BzLm9uSW5pdGlhbGl6ZSguLi5hcmd1bWVudHMpO1xuICB9XG5cbiAgb25SZW5kZXIoKSB7XG4gICAgcmV0dXJuIHRoaXMucHJvcHMub25SZW5kZXIoLi4uYXJndW1lbnRzKTtcbiAgfVxuXG4gIG9uRmluYWxpemUoKSB7XG4gICAgcmV0dXJuIHRoaXMucHJvcHMub25GaW5hbGl6ZSguLi5hcmd1bWVudHMpO1xuICB9XG5cbiAgZ2V0SFRNTENvbnRyb2xWYWx1ZShpZCkge1xuICAgIGxldCBkZWZhdWx0VmFsdWUgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IDE7XG4gICAgY29uc3QgZWxlbWVudCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGlkKTtcbiAgICByZXR1cm4gZWxlbWVudCA/IE51bWJlcihlbGVtZW50LnZhbHVlKSA6IGRlZmF1bHRWYWx1ZTtcbiAgfVxuXG4gIHNldFZpZXdQYXJhbWV0ZXJzKCkge1xuICAgIGxvZy5yZW1vdmVkKCdBbmltYXRpb25Mb29wLnNldFZpZXdQYXJhbWV0ZXJzJywgJ0FuaW1hdGlvbkxvb3Auc2V0UHJvcHMnKSgpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgX3N0YXJ0TG9vcCgpIHtcbiAgICBjb25zdCByZW5kZXJGcmFtZSA9ICgpID0+IHtcbiAgICAgIGlmICghdGhpcy5fcnVubmluZykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHRoaXMucmVkcmF3KCk7XG4gICAgICB0aGlzLl9hbmltYXRpb25GcmFtZUlkID0gdGhpcy5fcmVxdWVzdEFuaW1hdGlvbkZyYW1lKHJlbmRlckZyYW1lKTtcbiAgICB9O1xuXG4gICAgdGhpcy5fY2FuY2VsQW5pbWF0aW9uRnJhbWUodGhpcy5fYW5pbWF0aW9uRnJhbWVJZCk7XG5cbiAgICB0aGlzLl9hbmltYXRpb25GcmFtZUlkID0gdGhpcy5fcmVxdWVzdEFuaW1hdGlvbkZyYW1lKHJlbmRlckZyYW1lKTtcbiAgfVxuXG4gIF9nZXRQYWdlTG9hZFByb21pc2UoKSB7XG4gICAgaWYgKCF0aGlzLl9wYWdlTG9hZFByb21pc2UpIHtcbiAgICAgIHRoaXMuX3BhZ2VMb2FkUHJvbWlzZSA9IGlzUGFnZSA/IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgaWYgKGlzUGFnZSAmJiBkb2N1bWVudC5yZWFkeVN0YXRlID09PSAnY29tcGxldGUnKSB7XG4gICAgICAgICAgcmVzb2x2ZShkb2N1bWVudCk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ2xvYWQnLCAoKSA9PiB7XG4gICAgICAgICAgcmVzb2x2ZShkb2N1bWVudCk7XG4gICAgICAgIH0pO1xuICAgICAgfSkgOiBQcm9taXNlLnJlc29sdmUoe30pO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLl9wYWdlTG9hZFByb21pc2U7XG4gIH1cblxuICBfc2V0RGlzcGxheShkaXNwbGF5KSB7XG4gICAgaWYgKHRoaXMuZGlzcGxheSkge1xuICAgICAgdGhpcy5kaXNwbGF5LmRlbGV0ZSgpO1xuICAgICAgdGhpcy5kaXNwbGF5LmFuaW1hdGlvbkxvb3AgPSBudWxsO1xuICAgIH1cblxuICAgIGlmIChkaXNwbGF5KSB7XG4gICAgICBkaXNwbGF5LmFuaW1hdGlvbkxvb3AgPSB0aGlzO1xuICAgIH1cblxuICAgIHRoaXMuZGlzcGxheSA9IGRpc3BsYXk7XG4gIH1cblxuICBfY2FuY2VsQW5pbWF0aW9uRnJhbWUoYW5pbWF0aW9uRnJhbWVJZCkge1xuICAgIGlmICh0aGlzLmRpc3BsYXkgJiYgdGhpcy5kaXNwbGF5LmNhbmNlbEFuaW1hdGlvbkZyYW1lKSB7XG4gICAgICByZXR1cm4gdGhpcy5kaXNwbGF5LmNhbmNlbEFuaW1hdGlvbkZyYW1lKGFuaW1hdGlvbkZyYW1lSWQpO1xuICAgIH1cblxuICAgIHJldHVybiBjYW5jZWxBbmltYXRpb25GcmFtZShhbmltYXRpb25GcmFtZUlkKTtcbiAgfVxuXG4gIF9yZXF1ZXN0QW5pbWF0aW9uRnJhbWUocmVuZGVyRnJhbWVDYWxsYmFjaykge1xuICAgIGlmICh0aGlzLl9ydW5uaW5nKSB7XG4gICAgICBpZiAodGhpcy5kaXNwbGF5ICYmIHRoaXMuZGlzcGxheS5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGlzcGxheS5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUocmVuZGVyRnJhbWVDYWxsYmFjayk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiByZXF1ZXN0QW5pbWF0aW9uRnJhbWUocmVuZGVyRnJhbWVDYWxsYmFjayk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxuXG4gIF9yZW5kZXJGcmFtZSgpIHtcbiAgICBpZiAodGhpcy5kaXNwbGF5KSB7XG4gICAgICB0aGlzLmRpc3BsYXkuX3JlbmRlckZyYW1lKC4uLmFyZ3VtZW50cyk7XG5cbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLm9uUmVuZGVyKC4uLmFyZ3VtZW50cyk7XG4gIH1cblxuICBfY2xlYXJOZWVkc1JlZHJhdygpIHtcbiAgICB0aGlzLm5lZWRzUmVkcmF3ID0gbnVsbDtcbiAgfVxuXG4gIF9zZXR1cEZyYW1lKCkge1xuICAgIHRoaXMuX3Jlc2l6ZUNhbnZhc0RyYXdpbmdCdWZmZXIoKTtcblxuICAgIHRoaXMuX3Jlc2l6ZVZpZXdwb3J0KCk7XG5cbiAgICB0aGlzLl9yZXNpemVGcmFtZWJ1ZmZlcigpO1xuICB9XG5cbiAgX2luaXRpYWxpemVDYWxsYmFja0RhdGEoKSB7XG4gICAgdGhpcy5hbmltYXRpb25Qcm9wcyA9IHtcbiAgICAgIGdsOiB0aGlzLmdsLFxuICAgICAgc3RvcDogdGhpcy5zdG9wLFxuICAgICAgY2FudmFzOiB0aGlzLmdsLmNhbnZhcyxcbiAgICAgIGZyYW1lYnVmZmVyOiB0aGlzLmZyYW1lYnVmZmVyLFxuICAgICAgdXNlRGV2aWNlUGl4ZWxzOiB0aGlzLnVzZURldmljZVBpeGVscyxcbiAgICAgIG5lZWRzUmVkcmF3OiBudWxsLFxuICAgICAgc3RhcnRUaW1lOiBEYXRlLm5vdygpLFxuICAgICAgZW5naW5lVGltZTogMCxcbiAgICAgIHRpY2s6IDAsXG4gICAgICB0b2NrOiAwLFxuICAgICAgdGltZTogMCxcbiAgICAgIF90aW1lbGluZTogdGhpcy50aW1lbGluZSxcbiAgICAgIF9sb29wOiB0aGlzLFxuICAgICAgX2FuaW1hdGlvbkxvb3A6IHRoaXMsXG4gICAgICBfbW91c2VQb3NpdGlvbjogbnVsbFxuICAgIH07XG4gIH1cblxuICBfdXBkYXRlQ2FsbGJhY2tEYXRhKCkge1xuICAgIGNvbnN0IHtcbiAgICAgIHdpZHRoLFxuICAgICAgaGVpZ2h0LFxuICAgICAgYXNwZWN0XG4gICAgfSA9IHRoaXMuX2dldFNpemVBbmRBc3BlY3QoKTtcblxuICAgIGlmICh3aWR0aCAhPT0gdGhpcy5hbmltYXRpb25Qcm9wcy53aWR0aCB8fCBoZWlnaHQgIT09IHRoaXMuYW5pbWF0aW9uUHJvcHMuaGVpZ2h0KSB7XG4gICAgICB0aGlzLnNldE5lZWRzUmVkcmF3KCdkcmF3aW5nIGJ1ZmZlciByZXNpemVkJyk7XG4gICAgfVxuXG4gICAgaWYgKGFzcGVjdCAhPT0gdGhpcy5hbmltYXRpb25Qcm9wcy5hc3BlY3QpIHtcbiAgICAgIHRoaXMuc2V0TmVlZHNSZWRyYXcoJ2RyYXdpbmcgYnVmZmVyIGFzcGVjdCBjaGFuZ2VkJyk7XG4gICAgfVxuXG4gICAgdGhpcy5hbmltYXRpb25Qcm9wcy53aWR0aCA9IHdpZHRoO1xuICAgIHRoaXMuYW5pbWF0aW9uUHJvcHMuaGVpZ2h0ID0gaGVpZ2h0O1xuICAgIHRoaXMuYW5pbWF0aW9uUHJvcHMuYXNwZWN0ID0gYXNwZWN0O1xuICAgIHRoaXMuYW5pbWF0aW9uUHJvcHMubmVlZHNSZWRyYXcgPSB0aGlzLm5lZWRzUmVkcmF3O1xuICAgIHRoaXMuYW5pbWF0aW9uUHJvcHMuZW5naW5lVGltZSA9IERhdGUubm93KCkgLSB0aGlzLmFuaW1hdGlvblByb3BzLnN0YXJ0VGltZTtcblxuICAgIGlmICh0aGlzLnRpbWVsaW5lKSB7XG4gICAgICB0aGlzLnRpbWVsaW5lLnVwZGF0ZSh0aGlzLmFuaW1hdGlvblByb3BzLmVuZ2luZVRpbWUpO1xuICAgIH1cblxuICAgIHRoaXMuYW5pbWF0aW9uUHJvcHMudGljayA9IE1hdGguZmxvb3IodGhpcy5hbmltYXRpb25Qcm9wcy50aW1lIC8gMTAwMCAqIDYwKTtcbiAgICB0aGlzLmFuaW1hdGlvblByb3BzLnRvY2srKztcbiAgICB0aGlzLmFuaW1hdGlvblByb3BzLnRpbWUgPSB0aGlzLnRpbWVsaW5lID8gdGhpcy50aW1lbGluZS5nZXRUaW1lKCkgOiB0aGlzLmFuaW1hdGlvblByb3BzLmVuZ2luZVRpbWU7XG4gICAgdGhpcy5hbmltYXRpb25Qcm9wcy5fb2ZmU2NyZWVuID0gdGhpcy5vZmZTY3JlZW47XG4gIH1cblxuICBfZmluYWxpemVDYWxsYmFja0RhdGEoKSB7XG4gICAgdGhpcy5vbkZpbmFsaXplKHRoaXMuYW5pbWF0aW9uUHJvcHMpO1xuICB9XG5cbiAgX2FkZENhbGxiYWNrRGF0YShhcHBDb250ZXh0KSB7XG4gICAgaWYgKHR5cGVvZiBhcHBDb250ZXh0ID09PSAnb2JqZWN0JyAmJiBhcHBDb250ZXh0ICE9PSBudWxsKSB7XG4gICAgICB0aGlzLmFuaW1hdGlvblByb3BzID0gT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5hbmltYXRpb25Qcm9wcywgYXBwQ29udGV4dCk7XG4gICAgfVxuICB9XG5cbiAgX2NyZWF0ZVdlYkdMQ29udGV4dChvcHRzKSB7XG4gICAgdGhpcy5vZmZTY3JlZW4gPSBvcHRzLmNhbnZhcyAmJiB0eXBlb2YgT2Zmc2NyZWVuQ2FudmFzICE9PSAndW5kZWZpbmVkJyAmJiBvcHRzLmNhbnZhcyBpbnN0YW5jZW9mIE9mZnNjcmVlbkNhbnZhcztcbiAgICBvcHRzID0gT2JqZWN0LmFzc2lnbih7fSwgb3B0cywgdGhpcy5wcm9wcy5nbE9wdGlvbnMpO1xuICAgIHRoaXMuZ2wgPSB0aGlzLnByb3BzLmdsID8gaW5zdHJ1bWVudEdMQ29udGV4dCh0aGlzLnByb3BzLmdsLCBvcHRzKSA6IHRoaXMub25DcmVhdGVDb250ZXh0KG9wdHMpO1xuXG4gICAgaWYgKCFpc1dlYkdMKHRoaXMuZ2wpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0FuaW1hdGlvbkxvb3Aub25DcmVhdGVDb250ZXh0IC0gaWxsZWdhbCBjb250ZXh0IHJldHVybmVkJyk7XG4gICAgfVxuXG4gICAgcmVzZXRQYXJhbWV0ZXJzKHRoaXMuZ2wpO1xuXG4gICAgdGhpcy5fY3JlYXRlSW5mb0RpdigpO1xuICB9XG5cbiAgX2NyZWF0ZUluZm9EaXYoKSB7XG4gICAgaWYgKHRoaXMuZ2wuY2FudmFzICYmIHRoaXMucHJvcHMub25BZGRIVE1MKSB7XG4gICAgICBjb25zdCB3cmFwcGVyRGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKHdyYXBwZXJEaXYpO1xuICAgICAgd3JhcHBlckRpdi5zdHlsZS5wb3NpdGlvbiA9ICdyZWxhdGl2ZSc7XG4gICAgICBjb25zdCBkaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgIGRpdi5zdHlsZS5wb3NpdGlvbiA9ICdhYnNvbHV0ZSc7XG4gICAgICBkaXYuc3R5bGUubGVmdCA9ICcxMHB4JztcbiAgICAgIGRpdi5zdHlsZS5ib3R0b20gPSAnMTBweCc7XG4gICAgICBkaXYuc3R5bGUud2lkdGggPSAnMzAwcHgnO1xuICAgICAgZGl2LnN0eWxlLmJhY2tncm91bmQgPSAnd2hpdGUnO1xuICAgICAgd3JhcHBlckRpdi5hcHBlbmRDaGlsZCh0aGlzLmdsLmNhbnZhcyk7XG4gICAgICB3cmFwcGVyRGl2LmFwcGVuZENoaWxkKGRpdik7XG4gICAgICBjb25zdCBodG1sID0gdGhpcy5wcm9wcy5vbkFkZEhUTUwoZGl2KTtcblxuICAgICAgaWYgKGh0bWwpIHtcbiAgICAgICAgZGl2LmlubmVySFRNTCA9IGh0bWw7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgX2dldFNpemVBbmRBc3BlY3QoKSB7XG4gICAgY29uc3Qgd2lkdGggPSB0aGlzLmdsLmRyYXdpbmdCdWZmZXJXaWR0aDtcbiAgICBjb25zdCBoZWlnaHQgPSB0aGlzLmdsLmRyYXdpbmdCdWZmZXJIZWlnaHQ7XG4gICAgbGV0IGFzcGVjdCA9IDE7XG4gICAgY29uc3Qge1xuICAgICAgY2FudmFzXG4gICAgfSA9IHRoaXMuZ2w7XG5cbiAgICBpZiAoY2FudmFzICYmIGNhbnZhcy5jbGllbnRIZWlnaHQpIHtcbiAgICAgIGFzcGVjdCA9IGNhbnZhcy5jbGllbnRXaWR0aCAvIGNhbnZhcy5jbGllbnRIZWlnaHQ7XG4gICAgfSBlbHNlIGlmICh3aWR0aCA+IDAgJiYgaGVpZ2h0ID4gMCkge1xuICAgICAgYXNwZWN0ID0gd2lkdGggLyBoZWlnaHQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIHdpZHRoLFxuICAgICAgaGVpZ2h0LFxuICAgICAgYXNwZWN0XG4gICAgfTtcbiAgfVxuXG4gIF9yZXNpemVWaWV3cG9ydCgpIHtcbiAgICBpZiAodGhpcy5hdXRvUmVzaXplVmlld3BvcnQpIHtcbiAgICAgIHRoaXMuZ2wudmlld3BvcnQoMCwgMCwgdGhpcy5nbC5kcmF3aW5nQnVmZmVyV2lkdGgsIHRoaXMuZ2wuZHJhd2luZ0J1ZmZlckhlaWdodCk7XG4gICAgfVxuICB9XG5cbiAgX3Jlc2l6ZUNhbnZhc0RyYXdpbmdCdWZmZXIoKSB7XG4gICAgaWYgKHRoaXMuYXV0b1Jlc2l6ZURyYXdpbmdCdWZmZXIpIHtcbiAgICAgIHJlc2l6ZUdMQ29udGV4dCh0aGlzLmdsLCB7XG4gICAgICAgIHVzZURldmljZVBpeGVsczogdGhpcy51c2VEZXZpY2VQaXhlbHNcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIF9jcmVhdGVGcmFtZWJ1ZmZlcigpIHtcbiAgICBpZiAodGhpcy5wcm9wcy5jcmVhdGVGcmFtZWJ1ZmZlcikge1xuICAgICAgdGhpcy5mcmFtZWJ1ZmZlciA9IG5ldyBGcmFtZWJ1ZmZlcih0aGlzLmdsKTtcbiAgICB9XG4gIH1cblxuICBfcmVzaXplRnJhbWVidWZmZXIoKSB7XG4gICAgaWYgKHRoaXMuZnJhbWVidWZmZXIpIHtcbiAgICAgIHRoaXMuZnJhbWVidWZmZXIucmVzaXplKHtcbiAgICAgICAgd2lkdGg6IHRoaXMuZ2wuZHJhd2luZ0J1ZmZlcldpZHRoLFxuICAgICAgICBoZWlnaHQ6IHRoaXMuZ2wuZHJhd2luZ0J1ZmZlckhlaWdodFxuICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgX2JlZ2luVGltZXJzKCkge1xuICAgIHRoaXMuZnJhbWVSYXRlLnRpbWVFbmQoKTtcbiAgICB0aGlzLmZyYW1lUmF0ZS50aW1lU3RhcnQoKTtcblxuICAgIGlmICh0aGlzLl9ncHVUaW1lUXVlcnkgJiYgdGhpcy5fZ3B1VGltZVF1ZXJ5LmlzUmVzdWx0QXZhaWxhYmxlKCkgJiYgIXRoaXMuX2dwdVRpbWVRdWVyeS5pc1RpbWVyRGlzam9pbnQoKSkge1xuICAgICAgdGhpcy5zdGF0cy5nZXQoJ0dQVSBUaW1lJykuYWRkVGltZSh0aGlzLl9ncHVUaW1lUXVlcnkuZ2V0VGltZXJNaWxsaXNlY29uZHMoKSk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX2dwdVRpbWVRdWVyeSkge1xuICAgICAgdGhpcy5fZ3B1VGltZVF1ZXJ5LmJlZ2luVGltZUVsYXBzZWRRdWVyeSgpO1xuICAgIH1cblxuICAgIHRoaXMuY3B1VGltZS50aW1lU3RhcnQoKTtcbiAgfVxuXG4gIF9lbmRUaW1lcnMoKSB7XG4gICAgdGhpcy5jcHVUaW1lLnRpbWVFbmQoKTtcblxuICAgIGlmICh0aGlzLl9ncHVUaW1lUXVlcnkpIHtcbiAgICAgIHRoaXMuX2dwdVRpbWVRdWVyeS5lbmQoKTtcbiAgICB9XG4gIH1cblxuICBfc3RhcnRFdmVudEhhbmRsaW5nKCkge1xuICAgIGNvbnN0IHtcbiAgICAgIGNhbnZhc1xuICAgIH0gPSB0aGlzLmdsO1xuXG4gICAgaWYgKGNhbnZhcykge1xuICAgICAgY2FudmFzLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlbW92ZScsIHRoaXMuX29uTW91c2Vtb3ZlKTtcbiAgICAgIGNhbnZhcy5hZGRFdmVudExpc3RlbmVyKCdtb3VzZWxlYXZlJywgdGhpcy5fb25Nb3VzZWxlYXZlKTtcbiAgICB9XG4gIH1cblxuICBfb25Nb3VzZW1vdmUoZSkge1xuICAgIHRoaXMuYW5pbWF0aW9uUHJvcHMuX21vdXNlUG9zaXRpb24gPSBbZS5vZmZzZXRYLCBlLm9mZnNldFldO1xuICB9XG5cbiAgX29uTW91c2VsZWF2ZShlKSB7XG4gICAgdGhpcy5hbmltYXRpb25Qcm9wcy5fbW91c2VQb3NpdGlvbiA9IG51bGw7XG4gIH1cblxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YW5pbWF0aW9uLWxvb3AuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///16816\n")},80210:function(__unused_webpack_module,__webpack_exports__,__webpack_require__){eval("\n// EXPORTS\n__webpack_require__.d(__webpack_exports__, {\n  \"Z\": function() { return /* binding */ Model; }\n});\n\n// EXTERNAL MODULE: ./node_modules/@luma.gl/gltools/dist/esm/index.js + 13 modules\nvar esm = __webpack_require__(1418);\n// EXTERNAL MODULE: ./node_modules/@luma.gl/engine/dist/esm/lib/program-manager.js + 8 modules\nvar program_manager = __webpack_require__(43426);\n// EXTERNAL MODULE: ./node_modules/@luma.gl/webgl/dist/esm/utils/utils.js\nvar utils = __webpack_require__(74538);\n// EXTERNAL MODULE: ./node_modules/@luma.gl/webgl/dist/esm/utils/assert.js\nvar assert = __webpack_require__(22525);\n// EXTERNAL MODULE: ./node_modules/@luma.gl/webgl/dist/esm/classes/clear.js\nvar clear = __webpack_require__(26047);\n// EXTERNAL MODULE: ./node_modules/@luma.gl/webgl/dist/esm/classes/program.js + 6 modules\nvar classes_program = __webpack_require__(75433);\n// EXTERNAL MODULE: ./node_modules/@luma.gl/webgl/dist/esm/classes/vertex-array.js + 2 modules\nvar vertex_array = __webpack_require__(55045);\n// EXTERNAL MODULE: ./node_modules/@luma.gl/webgl/dist/esm/classes/buffer.js\nvar classes_buffer = __webpack_require__(53478);\n// EXTERNAL MODULE: ./node_modules/@luma.gl/webgl/dist/esm/classes/transform-feedback.js\nvar transform_feedback = __webpack_require__(51053);\n// EXTERNAL MODULE: ./node_modules/@luma.gl/webgl/dist/esm/debug/debug-vertex-array.js\nvar debug_vertex_array = __webpack_require__(61713);\n// EXTERNAL MODULE: ./node_modules/@luma.gl/webgl/dist/esm/debug/debug-uniforms.js\nvar debug_uniforms = __webpack_require__(49258);\n// EXTERNAL MODULE: ./node_modules/@luma.gl/webgl/dist/esm/debug/debug-program-configuration.js\nvar debug_program_configuration = __webpack_require__(3124);\n;// CONCATENATED MODULE: ./node_modules/@luma.gl/engine/dist/esm/lib/model-utils.js\n\nconst GLTF_TO_LUMA_ATTRIBUTE_MAP = {\n  POSITION: 'positions',\n  NORMAL: 'normals',\n  COLOR_0: 'colors',\n  TEXCOORD_0: 'texCoords',\n  TEXCOORD_1: 'texCoords1',\n  TEXCOORD_2: 'texCoords2'\n};\nfunction getBuffersFromGeometry(gl, geometry, options) {\n  const buffers = {};\n  let indices = geometry.indices;\n\n  for (const name in geometry.attributes) {\n    const attribute = geometry.attributes[name];\n    const remappedName = mapAttributeName(name, options);\n\n    if (name === 'indices') {\n      indices = attribute;\n    } else if (attribute.constant) {\n      buffers[remappedName] = attribute.value;\n    } else {\n      const typedArray = attribute.value;\n      const accessor = { ...attribute\n      };\n      delete accessor.value;\n      buffers[remappedName] = [new classes_buffer/* default */.Z(gl, typedArray), accessor];\n      inferAttributeAccessor(name, accessor);\n    }\n  }\n\n  if (indices) {\n    const data = indices.value || indices;\n    (0,assert/* assert */.h)(data instanceof Uint16Array || data instanceof Uint32Array, 'attribute array for \"indices\" must be of integer type');\n    const accessor = {\n      size: 1,\n      isIndexed: indices.isIndexed === undefined ? true : indices.isIndexed\n    };\n    buffers.indices = [new classes_buffer/* default */.Z(gl, {\n      data,\n      target: 34963\n    }), accessor];\n  }\n\n  return buffers;\n}\n\nfunction mapAttributeName(name, options) {\n  const {\n    attributeMap = GLTF_TO_LUMA_ATTRIBUTE_MAP\n  } = options || {};\n  return attributeMap && attributeMap[name] || name;\n}\n\nfunction inferAttributeAccessor(attributeName, attribute) {\n  let category;\n\n  switch (attributeName) {\n    case 'texCoords':\n    case 'texCoord1':\n    case 'texCoord2':\n    case 'texCoord3':\n      category = 'uvs';\n      break;\n\n    case 'vertices':\n    case 'positions':\n    case 'normals':\n    case 'pickingColors':\n      category = 'vectors';\n      break;\n\n    default:\n  }\n\n  switch (category) {\n    case 'vectors':\n      attribute.size = attribute.size || 3;\n      break;\n\n    case 'uvs':\n      attribute.size = attribute.size || 2;\n      break;\n\n    default:\n  }\n\n  (0,assert/* assert */.h)(Number.isFinite(attribute.size), \"attribute \".concat(attributeName, \" needs size\"));\n}\n//# sourceMappingURL=model-utils.js.map\n;// CONCATENATED MODULE: ./node_modules/@luma.gl/engine/dist/esm/lib/model.js\n\n\n\n\n\nconst LOG_DRAW_PRIORITY = 2;\nconst LOG_DRAW_TIMEOUT = 10000;\nconst ERR_MODEL_PARAMS = 'Model needs drawMode and vertexCount';\n\nconst NOOP = () => {};\n\nconst DRAW_PARAMS = {};\nclass Model {\n  constructor(gl) {\n    let props = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    const {\n      id = (0,utils/* uid */.hQ)('model')\n    } = props;\n    (0,assert/* assert */.h)((0,esm/* isWebGL */.UF)(gl));\n    this.id = id;\n    this.gl = gl;\n    this.id = props.id || (0,utils/* uid */.hQ)('Model');\n    this.lastLogTime = 0;\n    this.animated = false;\n    this.initialize(props);\n  }\n\n  initialize(props) {\n    this.props = {};\n    this.programManager = props.programManager || program_manager/* default.getDefaultProgramManager */.Z.getDefaultProgramManager(this.gl);\n    this._programManagerState = -1;\n    this._managedProgram = false;\n    const {\n      program = null,\n      vs,\n      fs,\n      modules,\n      defines,\n      inject,\n      varyings,\n      bufferMode,\n      transpileToGLSL100\n    } = props;\n    this.programProps = {\n      program,\n      vs,\n      fs,\n      modules,\n      defines,\n      inject,\n      varyings,\n      bufferMode,\n      transpileToGLSL100\n    };\n    this.program = null;\n    this.vertexArray = null;\n    this._programDirty = true;\n    this.userData = {};\n    this.needsRedraw = true;\n    this._attributes = {};\n    this.attributes = {};\n    this.uniforms = {};\n    this.pickable = true;\n\n    this._checkProgram();\n\n    this.setUniforms(Object.assign({}, this.getModuleUniforms(props.moduleSettings)));\n    this.drawMode = props.drawMode !== undefined ? props.drawMode : 4;\n    this.vertexCount = props.vertexCount || 0;\n    this.geometryBuffers = {};\n    this.isInstanced = props.isInstanced || props.instanced || props.instanceCount > 0;\n\n    this._setModelProps(props);\n\n    this.geometry = {};\n    (0,assert/* assert */.h)(this.drawMode !== undefined && Number.isFinite(this.vertexCount), ERR_MODEL_PARAMS);\n  }\n\n  setProps(props) {\n    this._setModelProps(props);\n  }\n\n  delete() {\n    for (const key in this._attributes) {\n      if (this._attributes[key] !== this.attributes[key]) {\n        this._attributes[key].delete();\n      }\n    }\n\n    if (this._managedProgram) {\n      this.programManager.release(this.program);\n      this._managedProgram = false;\n    }\n\n    this.vertexArray.delete();\n\n    this._deleteGeometryBuffers();\n  }\n\n  getDrawMode() {\n    return this.drawMode;\n  }\n\n  getVertexCount() {\n    return this.vertexCount;\n  }\n\n  getInstanceCount() {\n    return this.instanceCount;\n  }\n\n  getAttributes() {\n    return this.attributes;\n  }\n\n  getProgram() {\n    return this.program;\n  }\n\n  setProgram(props) {\n    const {\n      program,\n      vs,\n      fs,\n      modules,\n      defines,\n      inject,\n      varyings,\n      bufferMode,\n      transpileToGLSL100\n    } = props;\n    this.programProps = {\n      program,\n      vs,\n      fs,\n      modules,\n      defines,\n      inject,\n      varyings,\n      bufferMode,\n      transpileToGLSL100\n    };\n    this._programDirty = true;\n  }\n\n  getUniforms() {\n    return this.uniforms;\n  }\n\n  setDrawMode(drawMode) {\n    this.drawMode = drawMode;\n    return this;\n  }\n\n  setVertexCount(vertexCount) {\n    (0,assert/* assert */.h)(Number.isFinite(vertexCount));\n    this.vertexCount = vertexCount;\n    return this;\n  }\n\n  setInstanceCount(instanceCount) {\n    (0,assert/* assert */.h)(Number.isFinite(instanceCount));\n    this.instanceCount = instanceCount;\n    return this;\n  }\n\n  setGeometry(geometry) {\n    this.drawMode = geometry.drawMode;\n    this.vertexCount = geometry.getVertexCount();\n\n    this._deleteGeometryBuffers();\n\n    this.geometryBuffers = getBuffersFromGeometry(this.gl, geometry);\n    this.vertexArray.setAttributes(this.geometryBuffers);\n    return this;\n  }\n\n  setAttributes() {\n    let attributes = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    if ((0,utils/* isObjectEmpty */.nK)(attributes)) {\n      return this;\n    }\n\n    const normalizedAttributes = {};\n\n    for (const name in attributes) {\n      const attribute = attributes[name];\n      normalizedAttributes[name] = attribute.getValue ? attribute.getValue() : attribute;\n    }\n\n    this.vertexArray.setAttributes(normalizedAttributes);\n    return this;\n  }\n\n  setUniforms() {\n    let uniforms = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    Object.assign(this.uniforms, uniforms);\n    return this;\n  }\n\n  getModuleUniforms(opts) {\n    this._checkProgram();\n\n    const getUniforms = this.programManager.getUniforms(this.program);\n\n    if (getUniforms) {\n      return getUniforms(opts);\n    }\n\n    return {};\n  }\n\n  updateModuleSettings(opts) {\n    const uniforms = this.getModuleUniforms(opts || {});\n    return this.setUniforms(uniforms);\n  }\n\n  clear(opts) {\n    (0,clear/* clear */.Z)(this.program.gl, opts);\n    return this;\n  }\n\n  draw() {\n    let opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    this._checkProgram();\n\n    const {\n      moduleSettings = null,\n      framebuffer,\n      uniforms = {},\n      attributes = {},\n      transformFeedback = this.transformFeedback,\n      parameters = {},\n      vertexArray = this.vertexArray\n    } = opts;\n    this.setAttributes(attributes);\n    this.updateModuleSettings(moduleSettings);\n    this.setUniforms(uniforms);\n    let logPriority;\n\n    if (esm/* log.priority */.cM.priority >= LOG_DRAW_PRIORITY) {\n      logPriority = this._logDrawCallStart(LOG_DRAW_PRIORITY);\n    }\n\n    const drawParams = this.vertexArray.getDrawParams();\n    const {\n      isIndexed = drawParams.isIndexed,\n      indexType = drawParams.indexType,\n      indexOffset = drawParams.indexOffset,\n      vertexArrayInstanced = drawParams.isInstanced\n    } = this.props;\n\n    if (vertexArrayInstanced && !this.isInstanced) {\n      esm/* log.warn */.cM.warn('Found instanced attributes on non-instanced model', this.id)();\n    }\n\n    const {\n      isInstanced,\n      instanceCount\n    } = this;\n    const {\n      onBeforeRender = NOOP,\n      onAfterRender = NOOP\n    } = this.props;\n    onBeforeRender();\n    this.program.setUniforms(this.uniforms);\n    const didDraw = this.program.draw(Object.assign(DRAW_PARAMS, opts, {\n      logPriority,\n      uniforms: null,\n      framebuffer,\n      parameters,\n      drawMode: this.getDrawMode(),\n      vertexCount: this.getVertexCount(),\n      vertexArray,\n      transformFeedback,\n      isIndexed,\n      indexType,\n      isInstanced,\n      instanceCount,\n      offset: isIndexed ? indexOffset : 0\n    }));\n    onAfterRender();\n\n    if (esm/* log.priority */.cM.priority >= LOG_DRAW_PRIORITY) {\n      this._logDrawCallEnd(logPriority, vertexArray, framebuffer);\n    }\n\n    return didDraw;\n  }\n\n  transform() {\n    let opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    const {\n      discard = true,\n      feedbackBuffers,\n      unbindModels = []\n    } = opts;\n    let {\n      parameters\n    } = opts;\n\n    if (feedbackBuffers) {\n      this._setFeedbackBuffers(feedbackBuffers);\n    }\n\n    if (discard) {\n      parameters = Object.assign({}, parameters, {\n        [35977]: discard\n      });\n    }\n\n    unbindModels.forEach(model => model.vertexArray.unbindBuffers());\n\n    try {\n      this.draw(Object.assign({}, opts, {\n        parameters\n      }));\n    } finally {\n      unbindModels.forEach(model => model.vertexArray.bindBuffers());\n    }\n\n    return this;\n  }\n\n  render() {\n    let uniforms = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    esm/* log.warn */.cM.warn('Model.render() is deprecated. Use Model.setUniforms() and Model.draw()')();\n    return this.setUniforms(uniforms).draw();\n  }\n\n  _setModelProps(props) {\n    Object.assign(this.props, props);\n\n    if ('uniforms' in props) {\n      this.setUniforms(props.uniforms);\n    }\n\n    if ('pickable' in props) {\n      this.pickable = props.pickable;\n    }\n\n    if ('instanceCount' in props) {\n      this.instanceCount = props.instanceCount;\n    }\n\n    if ('geometry' in props) {\n      this.setGeometry(props.geometry);\n    }\n\n    if ('attributes' in props) {\n      this.setAttributes(props.attributes);\n    }\n\n    if ('_feedbackBuffers' in props) {\n      this._setFeedbackBuffers(props._feedbackBuffers);\n    }\n  }\n\n  _checkProgram() {\n    const needsUpdate = this._programDirty || this.programManager.stateHash !== this._programManagerState;\n\n    if (!needsUpdate) {\n      return;\n    }\n\n    let {\n      program\n    } = this.programProps;\n\n    if (program) {\n      this._managedProgram = false;\n    } else {\n      const {\n        vs,\n        fs,\n        modules,\n        inject,\n        defines,\n        varyings,\n        bufferMode,\n        transpileToGLSL100\n      } = this.programProps;\n      program = this.programManager.get({\n        vs,\n        fs,\n        modules,\n        inject,\n        defines,\n        varyings,\n        bufferMode,\n        transpileToGLSL100\n      });\n\n      if (this.program && this._managedProgram) {\n        this.programManager.release(this.program);\n      }\n\n      this._programManagerState = this.programManager.stateHash;\n      this._managedProgram = true;\n    }\n\n    (0,assert/* assert */.h)(program instanceof classes_program/* default */.Z, 'Model needs a program');\n    this._programDirty = false;\n\n    if (program === this.program) {\n      return;\n    }\n\n    this.program = program;\n\n    if (this.vertexArray) {\n      this.vertexArray.setProps({\n        program: this.program,\n        attributes: this.vertexArray.attributes\n      });\n    } else {\n      this.vertexArray = new vertex_array/* default */.Z(this.gl, {\n        program: this.program\n      });\n    }\n\n    this.setUniforms(Object.assign({}, this.getModuleUniforms()));\n  }\n\n  _deleteGeometryBuffers() {\n    for (const name in this.geometryBuffers) {\n      const buffer = this.geometryBuffers[name][0] || this.geometryBuffers[name];\n\n      if (buffer instanceof classes_buffer/* default */.Z) {\n        buffer.delete();\n      }\n    }\n  }\n\n  _setAnimationProps(animationProps) {\n    if (this.animated) {\n      (0,assert/* assert */.h)(animationProps, 'Model.draw(): animated uniforms but no animationProps');\n    }\n  }\n\n  _setFeedbackBuffers() {\n    let feedbackBuffers = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    if ((0,utils/* isObjectEmpty */.nK)(feedbackBuffers)) {\n      return this;\n    }\n\n    const {\n      gl\n    } = this.program;\n    this.transformFeedback = this.transformFeedback || new transform_feedback/* default */.Z(gl, {\n      program: this.program\n    });\n    this.transformFeedback.setBuffers(feedbackBuffers);\n    return this;\n  }\n\n  _logDrawCallStart(logLevel) {\n    const logDrawTimeout = logLevel > 3 ? 0 : LOG_DRAW_TIMEOUT;\n\n    if (Date.now() - this.lastLogTime < logDrawTimeout) {\n      return undefined;\n    }\n\n    this.lastLogTime = Date.now();\n    esm/* log.group */.cM.group(LOG_DRAW_PRIORITY, \">>> DRAWING MODEL \".concat(this.id), {\n      collapsed: esm/* log.level */.cM.level <= 2\n    })();\n    return logLevel;\n  }\n\n  _logDrawCallEnd(logLevel, vertexArray, uniforms, framebuffer) {\n    if (logLevel === undefined) {\n      return;\n    }\n\n    const attributeTable = (0,debug_vertex_array/* getDebugTableForVertexArray */.L)({\n      vertexArray,\n      header: \"\".concat(this.id, \" attributes\"),\n      attributes: this._attributes\n    });\n    const {\n      table: uniformTable,\n      unusedTable,\n      unusedCount\n    } = (0,debug_uniforms/* getDebugTableForUniforms */.d)({\n      header: \"\".concat(this.id, \" uniforms\"),\n      program: this.program,\n      uniforms: Object.assign({}, this.program.uniforms, uniforms)\n    });\n    const {\n      table: missingTable,\n      count: missingCount\n    } = (0,debug_uniforms/* getDebugTableForUniforms */.d)({\n      header: \"\".concat(this.id, \" uniforms\"),\n      program: this.program,\n      uniforms: Object.assign({}, this.program.uniforms, uniforms),\n      undefinedOnly: true\n    });\n\n    if (missingCount > 0) {\n      esm/* log.log */.cM.log('MISSING UNIFORMS', Object.keys(missingTable))();\n    }\n\n    if (unusedCount > 0) {\n      esm/* log.log */.cM.log('UNUSED UNIFORMS', Object.keys(unusedTable))();\n    }\n\n    const configTable = (0,debug_program_configuration/* getDebugTableForProgramConfiguration */.n)(this.vertexArray.configuration);\n    esm/* log.table */.cM.table(logLevel, attributeTable)();\n    esm/* log.table */.cM.table(logLevel, uniformTable)();\n    esm/* log.table */.cM.table(logLevel + 1, configTable)();\n\n    if (framebuffer) {\n      framebuffer.log({\n        logLevel: LOG_DRAW_PRIORITY,\n        message: \"Rendered to \".concat(framebuffer.id)\n      });\n    }\n\n    esm/* log.groupEnd */.cM.groupEnd(LOG_DRAW_PRIORITY)();\n  }\n\n}\n//# sourceMappingURL=model.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QTtBQUNBO0FBQ0EsT0FBTztBQUNQLE1BQU07QUFDTiw2QkFBNkIsMkJBQVc7QUFDeEM7QUFDQSxPQUFPO0FBQ1A7O0FBRUEscUNBQXFDO0FBQ3JDOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSw0QkFBNEIsNkJBQU07QUFDbEM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU0sd0JBQU07QUFDWjtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsUUFBUSwrQkFBYTtBQUNyQjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ04sMkRBQTJELGlDQUFpQjtBQUM1RTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxJQUFJLDJCQUFTO0FBQ2IsaUJBQWlCLDJCQUFTO0FBQzFCLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDJCQUEyQix5REFBMkI7QUFDdEQ7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTSxFQUFFLGtEQUF3QjtBQUNoQztBQUNBO0FBQ0EsZ0NBQWdDO0FBQ2hDLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxNQUFNLEVBQUUsa0RBQXdCO0FBQ2hDO0FBQ0E7QUFDQSxnQ0FBZ0M7QUFDaEM7QUFDQSxLQUFLOztBQUVMO0FBQ0EsTUFBTSx1QkFBTztBQUNiOztBQUVBO0FBQ0EsTUFBTSx1QkFBTztBQUNiOztBQUVBLHdCQUF3QiwyRUFBb0M7QUFDNUQsSUFBSSwyQkFBUztBQUNiLElBQUksMkJBQVM7QUFDYixJQUFJLDJCQUFTOztBQUViO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBLElBQUksaUNBQVk7QUFDaEI7O0FBRUE7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3Z1ZTMtd2VicGFjazUvLi9ub2RlX21vZHVsZXMvQGx1bWEuZ2wvZW5naW5lL2Rpc3QvZXNtL2xpYi9tb2RlbC11dGlscy5qcz8yZDgxIiwid2VicGFjazovL3Z1ZTMtd2VicGFjazUvLi9ub2RlX21vZHVsZXMvQGx1bWEuZ2wvZW5naW5lL2Rpc3QvZXNtL2xpYi9tb2RlbC5qcz9lMjJmIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEJ1ZmZlciwgYXNzZXJ0IH0gZnJvbSAnQGx1bWEuZ2wvd2ViZ2wnO1xuY29uc3QgR0xURl9UT19MVU1BX0FUVFJJQlVURV9NQVAgPSB7XG4gIFBPU0lUSU9OOiAncG9zaXRpb25zJyxcbiAgTk9STUFMOiAnbm9ybWFscycsXG4gIENPTE9SXzA6ICdjb2xvcnMnLFxuICBURVhDT09SRF8wOiAndGV4Q29vcmRzJyxcbiAgVEVYQ09PUkRfMTogJ3RleENvb3JkczEnLFxuICBURVhDT09SRF8yOiAndGV4Q29vcmRzMidcbn07XG5leHBvcnQgZnVuY3Rpb24gZ2V0QnVmZmVyc0Zyb21HZW9tZXRyeShnbCwgZ2VvbWV0cnksIG9wdGlvbnMpIHtcbiAgY29uc3QgYnVmZmVycyA9IHt9O1xuICBsZXQgaW5kaWNlcyA9IGdlb21ldHJ5LmluZGljZXM7XG5cbiAgZm9yIChjb25zdCBuYW1lIGluIGdlb21ldHJ5LmF0dHJpYnV0ZXMpIHtcbiAgICBjb25zdCBhdHRyaWJ1dGUgPSBnZW9tZXRyeS5hdHRyaWJ1dGVzW25hbWVdO1xuICAgIGNvbnN0IHJlbWFwcGVkTmFtZSA9IG1hcEF0dHJpYnV0ZU5hbWUobmFtZSwgb3B0aW9ucyk7XG5cbiAgICBpZiAobmFtZSA9PT0gJ2luZGljZXMnKSB7XG4gICAgICBpbmRpY2VzID0gYXR0cmlidXRlO1xuICAgIH0gZWxzZSBpZiAoYXR0cmlidXRlLmNvbnN0YW50KSB7XG4gICAgICBidWZmZXJzW3JlbWFwcGVkTmFtZV0gPSBhdHRyaWJ1dGUudmFsdWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IHR5cGVkQXJyYXkgPSBhdHRyaWJ1dGUudmFsdWU7XG4gICAgICBjb25zdCBhY2Nlc3NvciA9IHsgLi4uYXR0cmlidXRlXG4gICAgICB9O1xuICAgICAgZGVsZXRlIGFjY2Vzc29yLnZhbHVlO1xuICAgICAgYnVmZmVyc1tyZW1hcHBlZE5hbWVdID0gW25ldyBCdWZmZXIoZ2wsIHR5cGVkQXJyYXkpLCBhY2Nlc3Nvcl07XG4gICAgICBpbmZlckF0dHJpYnV0ZUFjY2Vzc29yKG5hbWUsIGFjY2Vzc29yKTtcbiAgICB9XG4gIH1cblxuICBpZiAoaW5kaWNlcykge1xuICAgIGNvbnN0IGRhdGEgPSBpbmRpY2VzLnZhbHVlIHx8IGluZGljZXM7XG4gICAgYXNzZXJ0KGRhdGEgaW5zdGFuY2VvZiBVaW50MTZBcnJheSB8fCBkYXRhIGluc3RhbmNlb2YgVWludDMyQXJyYXksICdhdHRyaWJ1dGUgYXJyYXkgZm9yIFwiaW5kaWNlc1wiIG11c3QgYmUgb2YgaW50ZWdlciB0eXBlJyk7XG4gICAgY29uc3QgYWNjZXNzb3IgPSB7XG4gICAgICBzaXplOiAxLFxuICAgICAgaXNJbmRleGVkOiBpbmRpY2VzLmlzSW5kZXhlZCA9PT0gdW5kZWZpbmVkID8gdHJ1ZSA6IGluZGljZXMuaXNJbmRleGVkXG4gICAgfTtcbiAgICBidWZmZXJzLmluZGljZXMgPSBbbmV3IEJ1ZmZlcihnbCwge1xuICAgICAgZGF0YSxcbiAgICAgIHRhcmdldDogMzQ5NjNcbiAgICB9KSwgYWNjZXNzb3JdO1xuICB9XG5cbiAgcmV0dXJuIGJ1ZmZlcnM7XG59XG5cbmZ1bmN0aW9uIG1hcEF0dHJpYnV0ZU5hbWUobmFtZSwgb3B0aW9ucykge1xuICBjb25zdCB7XG4gICAgYXR0cmlidXRlTWFwID0gR0xURl9UT19MVU1BX0FUVFJJQlVURV9NQVBcbiAgfSA9IG9wdGlvbnMgfHwge307XG4gIHJldHVybiBhdHRyaWJ1dGVNYXAgJiYgYXR0cmlidXRlTWFwW25hbWVdIHx8IG5hbWU7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBpbmZlckF0dHJpYnV0ZUFjY2Vzc29yKGF0dHJpYnV0ZU5hbWUsIGF0dHJpYnV0ZSkge1xuICBsZXQgY2F0ZWdvcnk7XG5cbiAgc3dpdGNoIChhdHRyaWJ1dGVOYW1lKSB7XG4gICAgY2FzZSAndGV4Q29vcmRzJzpcbiAgICBjYXNlICd0ZXhDb29yZDEnOlxuICAgIGNhc2UgJ3RleENvb3JkMic6XG4gICAgY2FzZSAndGV4Q29vcmQzJzpcbiAgICAgIGNhdGVnb3J5ID0gJ3V2cyc7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgJ3ZlcnRpY2VzJzpcbiAgICBjYXNlICdwb3NpdGlvbnMnOlxuICAgIGNhc2UgJ25vcm1hbHMnOlxuICAgIGNhc2UgJ3BpY2tpbmdDb2xvcnMnOlxuICAgICAgY2F0ZWdvcnkgPSAndmVjdG9ycyc7XG4gICAgICBicmVhaztcblxuICAgIGRlZmF1bHQ6XG4gIH1cblxuICBzd2l0Y2ggKGNhdGVnb3J5KSB7XG4gICAgY2FzZSAndmVjdG9ycyc6XG4gICAgICBhdHRyaWJ1dGUuc2l6ZSA9IGF0dHJpYnV0ZS5zaXplIHx8IDM7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgJ3V2cyc6XG4gICAgICBhdHRyaWJ1dGUuc2l6ZSA9IGF0dHJpYnV0ZS5zaXplIHx8IDI7XG4gICAgICBicmVhaztcblxuICAgIGRlZmF1bHQ6XG4gIH1cblxuICBhc3NlcnQoTnVtYmVyLmlzRmluaXRlKGF0dHJpYnV0ZS5zaXplKSwgXCJhdHRyaWJ1dGUgXCIuY29uY2F0KGF0dHJpYnV0ZU5hbWUsIFwiIG5lZWRzIHNpemVcIikpO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bW9kZWwtdXRpbHMuanMubWFwIiwiaW1wb3J0IHsgaXNXZWJHTCB9IGZyb20gJ0BsdW1hLmdsL2dsdG9vbHMnO1xuaW1wb3J0IFByb2dyYW1NYW5hZ2VyIGZyb20gJy4vcHJvZ3JhbS1tYW5hZ2VyJztcbmltcG9ydCB7IFByb2dyYW0sIFZlcnRleEFycmF5LCBjbGVhciwgVHJhbnNmb3JtRmVlZGJhY2ssIEJ1ZmZlciwgbG9nLCBpc09iamVjdEVtcHR5LCB1aWQsIGFzc2VydCB9IGZyb20gJ0BsdW1hLmdsL3dlYmdsJztcbmltcG9ydCB7IGdldERlYnVnVGFibGVGb3JVbmlmb3JtcywgZ2V0RGVidWdUYWJsZUZvclZlcnRleEFycmF5LCBnZXREZWJ1Z1RhYmxlRm9yUHJvZ3JhbUNvbmZpZ3VyYXRpb24gfSBmcm9tICdAbHVtYS5nbC93ZWJnbCc7XG5pbXBvcnQgeyBnZXRCdWZmZXJzRnJvbUdlb21ldHJ5IH0gZnJvbSAnLi9tb2RlbC11dGlscyc7XG5jb25zdCBMT0dfRFJBV19QUklPUklUWSA9IDI7XG5jb25zdCBMT0dfRFJBV19USU1FT1VUID0gMTAwMDA7XG5jb25zdCBFUlJfTU9ERUxfUEFSQU1TID0gJ01vZGVsIG5lZWRzIGRyYXdNb2RlIGFuZCB2ZXJ0ZXhDb3VudCc7XG5cbmNvbnN0IE5PT1AgPSAoKSA9PiB7fTtcblxuY29uc3QgRFJBV19QQVJBTVMgPSB7fTtcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIE1vZGVsIHtcbiAgY29uc3RydWN0b3IoZ2wpIHtcbiAgICBsZXQgcHJvcHMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuICAgIGNvbnN0IHtcbiAgICAgIGlkID0gdWlkKCdtb2RlbCcpXG4gICAgfSA9IHByb3BzO1xuICAgIGFzc2VydChpc1dlYkdMKGdsKSk7XG4gICAgdGhpcy5pZCA9IGlkO1xuICAgIHRoaXMuZ2wgPSBnbDtcbiAgICB0aGlzLmlkID0gcHJvcHMuaWQgfHwgdWlkKCdNb2RlbCcpO1xuICAgIHRoaXMubGFzdExvZ1RpbWUgPSAwO1xuICAgIHRoaXMuYW5pbWF0ZWQgPSBmYWxzZTtcbiAgICB0aGlzLmluaXRpYWxpemUocHJvcHMpO1xuICB9XG5cbiAgaW5pdGlhbGl6ZShwcm9wcykge1xuICAgIHRoaXMucHJvcHMgPSB7fTtcbiAgICB0aGlzLnByb2dyYW1NYW5hZ2VyID0gcHJvcHMucHJvZ3JhbU1hbmFnZXIgfHwgUHJvZ3JhbU1hbmFnZXIuZ2V0RGVmYXVsdFByb2dyYW1NYW5hZ2VyKHRoaXMuZ2wpO1xuICAgIHRoaXMuX3Byb2dyYW1NYW5hZ2VyU3RhdGUgPSAtMTtcbiAgICB0aGlzLl9tYW5hZ2VkUHJvZ3JhbSA9IGZhbHNlO1xuICAgIGNvbnN0IHtcbiAgICAgIHByb2dyYW0gPSBudWxsLFxuICAgICAgdnMsXG4gICAgICBmcyxcbiAgICAgIG1vZHVsZXMsXG4gICAgICBkZWZpbmVzLFxuICAgICAgaW5qZWN0LFxuICAgICAgdmFyeWluZ3MsXG4gICAgICBidWZmZXJNb2RlLFxuICAgICAgdHJhbnNwaWxlVG9HTFNMMTAwXG4gICAgfSA9IHByb3BzO1xuICAgIHRoaXMucHJvZ3JhbVByb3BzID0ge1xuICAgICAgcHJvZ3JhbSxcbiAgICAgIHZzLFxuICAgICAgZnMsXG4gICAgICBtb2R1bGVzLFxuICAgICAgZGVmaW5lcyxcbiAgICAgIGluamVjdCxcbiAgICAgIHZhcnlpbmdzLFxuICAgICAgYnVmZmVyTW9kZSxcbiAgICAgIHRyYW5zcGlsZVRvR0xTTDEwMFxuICAgIH07XG4gICAgdGhpcy5wcm9ncmFtID0gbnVsbDtcbiAgICB0aGlzLnZlcnRleEFycmF5ID0gbnVsbDtcbiAgICB0aGlzLl9wcm9ncmFtRGlydHkgPSB0cnVlO1xuICAgIHRoaXMudXNlckRhdGEgPSB7fTtcbiAgICB0aGlzLm5lZWRzUmVkcmF3ID0gdHJ1ZTtcbiAgICB0aGlzLl9hdHRyaWJ1dGVzID0ge307XG4gICAgdGhpcy5hdHRyaWJ1dGVzID0ge307XG4gICAgdGhpcy51bmlmb3JtcyA9IHt9O1xuICAgIHRoaXMucGlja2FibGUgPSB0cnVlO1xuXG4gICAgdGhpcy5fY2hlY2tQcm9ncmFtKCk7XG5cbiAgICB0aGlzLnNldFVuaWZvcm1zKE9iamVjdC5hc3NpZ24oe30sIHRoaXMuZ2V0TW9kdWxlVW5pZm9ybXMocHJvcHMubW9kdWxlU2V0dGluZ3MpKSk7XG4gICAgdGhpcy5kcmF3TW9kZSA9IHByb3BzLmRyYXdNb2RlICE9PSB1bmRlZmluZWQgPyBwcm9wcy5kcmF3TW9kZSA6IDQ7XG4gICAgdGhpcy52ZXJ0ZXhDb3VudCA9IHByb3BzLnZlcnRleENvdW50IHx8IDA7XG4gICAgdGhpcy5nZW9tZXRyeUJ1ZmZlcnMgPSB7fTtcbiAgICB0aGlzLmlzSW5zdGFuY2VkID0gcHJvcHMuaXNJbnN0YW5jZWQgfHwgcHJvcHMuaW5zdGFuY2VkIHx8IHByb3BzLmluc3RhbmNlQ291bnQgPiAwO1xuXG4gICAgdGhpcy5fc2V0TW9kZWxQcm9wcyhwcm9wcyk7XG5cbiAgICB0aGlzLmdlb21ldHJ5ID0ge307XG4gICAgYXNzZXJ0KHRoaXMuZHJhd01vZGUgIT09IHVuZGVmaW5lZCAmJiBOdW1iZXIuaXNGaW5pdGUodGhpcy52ZXJ0ZXhDb3VudCksIEVSUl9NT0RFTF9QQVJBTVMpO1xuICB9XG5cbiAgc2V0UHJvcHMocHJvcHMpIHtcbiAgICB0aGlzLl9zZXRNb2RlbFByb3BzKHByb3BzKTtcbiAgfVxuXG4gIGRlbGV0ZSgpIHtcbiAgICBmb3IgKGNvbnN0IGtleSBpbiB0aGlzLl9hdHRyaWJ1dGVzKSB7XG4gICAgICBpZiAodGhpcy5fYXR0cmlidXRlc1trZXldICE9PSB0aGlzLmF0dHJpYnV0ZXNba2V5XSkge1xuICAgICAgICB0aGlzLl9hdHRyaWJ1dGVzW2tleV0uZGVsZXRlKCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX21hbmFnZWRQcm9ncmFtKSB7XG4gICAgICB0aGlzLnByb2dyYW1NYW5hZ2VyLnJlbGVhc2UodGhpcy5wcm9ncmFtKTtcbiAgICAgIHRoaXMuX21hbmFnZWRQcm9ncmFtID0gZmFsc2U7XG4gICAgfVxuXG4gICAgdGhpcy52ZXJ0ZXhBcnJheS5kZWxldGUoKTtcblxuICAgIHRoaXMuX2RlbGV0ZUdlb21ldHJ5QnVmZmVycygpO1xuICB9XG5cbiAgZ2V0RHJhd01vZGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuZHJhd01vZGU7XG4gIH1cblxuICBnZXRWZXJ0ZXhDb3VudCgpIHtcbiAgICByZXR1cm4gdGhpcy52ZXJ0ZXhDb3VudDtcbiAgfVxuXG4gIGdldEluc3RhbmNlQ291bnQoKSB7XG4gICAgcmV0dXJuIHRoaXMuaW5zdGFuY2VDb3VudDtcbiAgfVxuXG4gIGdldEF0dHJpYnV0ZXMoKSB7XG4gICAgcmV0dXJuIHRoaXMuYXR0cmlidXRlcztcbiAgfVxuXG4gIGdldFByb2dyYW0oKSB7XG4gICAgcmV0dXJuIHRoaXMucHJvZ3JhbTtcbiAgfVxuXG4gIHNldFByb2dyYW0ocHJvcHMpIHtcbiAgICBjb25zdCB7XG4gICAgICBwcm9ncmFtLFxuICAgICAgdnMsXG4gICAgICBmcyxcbiAgICAgIG1vZHVsZXMsXG4gICAgICBkZWZpbmVzLFxuICAgICAgaW5qZWN0LFxuICAgICAgdmFyeWluZ3MsXG4gICAgICBidWZmZXJNb2RlLFxuICAgICAgdHJhbnNwaWxlVG9HTFNMMTAwXG4gICAgfSA9IHByb3BzO1xuICAgIHRoaXMucHJvZ3JhbVByb3BzID0ge1xuICAgICAgcHJvZ3JhbSxcbiAgICAgIHZzLFxuICAgICAgZnMsXG4gICAgICBtb2R1bGVzLFxuICAgICAgZGVmaW5lcyxcbiAgICAgIGluamVjdCxcbiAgICAgIHZhcnlpbmdzLFxuICAgICAgYnVmZmVyTW9kZSxcbiAgICAgIHRyYW5zcGlsZVRvR0xTTDEwMFxuICAgIH07XG4gICAgdGhpcy5fcHJvZ3JhbURpcnR5ID0gdHJ1ZTtcbiAgfVxuXG4gIGdldFVuaWZvcm1zKCkge1xuICAgIHJldHVybiB0aGlzLnVuaWZvcm1zO1xuICB9XG5cbiAgc2V0RHJhd01vZGUoZHJhd01vZGUpIHtcbiAgICB0aGlzLmRyYXdNb2RlID0gZHJhd01vZGU7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICBzZXRWZXJ0ZXhDb3VudCh2ZXJ0ZXhDb3VudCkge1xuICAgIGFzc2VydChOdW1iZXIuaXNGaW5pdGUodmVydGV4Q291bnQpKTtcbiAgICB0aGlzLnZlcnRleENvdW50ID0gdmVydGV4Q291bnQ7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICBzZXRJbnN0YW5jZUNvdW50KGluc3RhbmNlQ291bnQpIHtcbiAgICBhc3NlcnQoTnVtYmVyLmlzRmluaXRlKGluc3RhbmNlQ291bnQpKTtcbiAgICB0aGlzLmluc3RhbmNlQ291bnQgPSBpbnN0YW5jZUNvdW50O1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgc2V0R2VvbWV0cnkoZ2VvbWV0cnkpIHtcbiAgICB0aGlzLmRyYXdNb2RlID0gZ2VvbWV0cnkuZHJhd01vZGU7XG4gICAgdGhpcy52ZXJ0ZXhDb3VudCA9IGdlb21ldHJ5LmdldFZlcnRleENvdW50KCk7XG5cbiAgICB0aGlzLl9kZWxldGVHZW9tZXRyeUJ1ZmZlcnMoKTtcblxuICAgIHRoaXMuZ2VvbWV0cnlCdWZmZXJzID0gZ2V0QnVmZmVyc0Zyb21HZW9tZXRyeSh0aGlzLmdsLCBnZW9tZXRyeSk7XG4gICAgdGhpcy52ZXJ0ZXhBcnJheS5zZXRBdHRyaWJ1dGVzKHRoaXMuZ2VvbWV0cnlCdWZmZXJzKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIHNldEF0dHJpYnV0ZXMoKSB7XG4gICAgbGV0IGF0dHJpYnV0ZXMgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHt9O1xuXG4gICAgaWYgKGlzT2JqZWN0RW1wdHkoYXR0cmlidXRlcykpIHtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIGNvbnN0IG5vcm1hbGl6ZWRBdHRyaWJ1dGVzID0ge307XG5cbiAgICBmb3IgKGNvbnN0IG5hbWUgaW4gYXR0cmlidXRlcykge1xuICAgICAgY29uc3QgYXR0cmlidXRlID0gYXR0cmlidXRlc1tuYW1lXTtcbiAgICAgIG5vcm1hbGl6ZWRBdHRyaWJ1dGVzW25hbWVdID0gYXR0cmlidXRlLmdldFZhbHVlID8gYXR0cmlidXRlLmdldFZhbHVlKCkgOiBhdHRyaWJ1dGU7XG4gICAgfVxuXG4gICAgdGhpcy52ZXJ0ZXhBcnJheS5zZXRBdHRyaWJ1dGVzKG5vcm1hbGl6ZWRBdHRyaWJ1dGVzKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIHNldFVuaWZvcm1zKCkge1xuICAgIGxldCB1bmlmb3JtcyA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge307XG4gICAgT2JqZWN0LmFzc2lnbih0aGlzLnVuaWZvcm1zLCB1bmlmb3Jtcyk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICBnZXRNb2R1bGVVbmlmb3JtcyhvcHRzKSB7XG4gICAgdGhpcy5fY2hlY2tQcm9ncmFtKCk7XG5cbiAgICBjb25zdCBnZXRVbmlmb3JtcyA9IHRoaXMucHJvZ3JhbU1hbmFnZXIuZ2V0VW5pZm9ybXModGhpcy5wcm9ncmFtKTtcblxuICAgIGlmIChnZXRVbmlmb3Jtcykge1xuICAgICAgcmV0dXJuIGdldFVuaWZvcm1zKG9wdHMpO1xuICAgIH1cblxuICAgIHJldHVybiB7fTtcbiAgfVxuXG4gIHVwZGF0ZU1vZHVsZVNldHRpbmdzKG9wdHMpIHtcbiAgICBjb25zdCB1bmlmb3JtcyA9IHRoaXMuZ2V0TW9kdWxlVW5pZm9ybXMob3B0cyB8fCB7fSk7XG4gICAgcmV0dXJuIHRoaXMuc2V0VW5pZm9ybXModW5pZm9ybXMpO1xuICB9XG5cbiAgY2xlYXIob3B0cykge1xuICAgIGNsZWFyKHRoaXMucHJvZ3JhbS5nbCwgb3B0cyk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICBkcmF3KCkge1xuICAgIGxldCBvcHRzID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fTtcblxuICAgIHRoaXMuX2NoZWNrUHJvZ3JhbSgpO1xuXG4gICAgY29uc3Qge1xuICAgICAgbW9kdWxlU2V0dGluZ3MgPSBudWxsLFxuICAgICAgZnJhbWVidWZmZXIsXG4gICAgICB1bmlmb3JtcyA9IHt9LFxuICAgICAgYXR0cmlidXRlcyA9IHt9LFxuICAgICAgdHJhbnNmb3JtRmVlZGJhY2sgPSB0aGlzLnRyYW5zZm9ybUZlZWRiYWNrLFxuICAgICAgcGFyYW1ldGVycyA9IHt9LFxuICAgICAgdmVydGV4QXJyYXkgPSB0aGlzLnZlcnRleEFycmF5XG4gICAgfSA9IG9wdHM7XG4gICAgdGhpcy5zZXRBdHRyaWJ1dGVzKGF0dHJpYnV0ZXMpO1xuICAgIHRoaXMudXBkYXRlTW9kdWxlU2V0dGluZ3MobW9kdWxlU2V0dGluZ3MpO1xuICAgIHRoaXMuc2V0VW5pZm9ybXModW5pZm9ybXMpO1xuICAgIGxldCBsb2dQcmlvcml0eTtcblxuICAgIGlmIChsb2cucHJpb3JpdHkgPj0gTE9HX0RSQVdfUFJJT1JJVFkpIHtcbiAgICAgIGxvZ1ByaW9yaXR5ID0gdGhpcy5fbG9nRHJhd0NhbGxTdGFydChMT0dfRFJBV19QUklPUklUWSk7XG4gICAgfVxuXG4gICAgY29uc3QgZHJhd1BhcmFtcyA9IHRoaXMudmVydGV4QXJyYXkuZ2V0RHJhd1BhcmFtcygpO1xuICAgIGNvbnN0IHtcbiAgICAgIGlzSW5kZXhlZCA9IGRyYXdQYXJhbXMuaXNJbmRleGVkLFxuICAgICAgaW5kZXhUeXBlID0gZHJhd1BhcmFtcy5pbmRleFR5cGUsXG4gICAgICBpbmRleE9mZnNldCA9IGRyYXdQYXJhbXMuaW5kZXhPZmZzZXQsXG4gICAgICB2ZXJ0ZXhBcnJheUluc3RhbmNlZCA9IGRyYXdQYXJhbXMuaXNJbnN0YW5jZWRcbiAgICB9ID0gdGhpcy5wcm9wcztcblxuICAgIGlmICh2ZXJ0ZXhBcnJheUluc3RhbmNlZCAmJiAhdGhpcy5pc0luc3RhbmNlZCkge1xuICAgICAgbG9nLndhcm4oJ0ZvdW5kIGluc3RhbmNlZCBhdHRyaWJ1dGVzIG9uIG5vbi1pbnN0YW5jZWQgbW9kZWwnLCB0aGlzLmlkKSgpO1xuICAgIH1cblxuICAgIGNvbnN0IHtcbiAgICAgIGlzSW5zdGFuY2VkLFxuICAgICAgaW5zdGFuY2VDb3VudFxuICAgIH0gPSB0aGlzO1xuICAgIGNvbnN0IHtcbiAgICAgIG9uQmVmb3JlUmVuZGVyID0gTk9PUCxcbiAgICAgIG9uQWZ0ZXJSZW5kZXIgPSBOT09QXG4gICAgfSA9IHRoaXMucHJvcHM7XG4gICAgb25CZWZvcmVSZW5kZXIoKTtcbiAgICB0aGlzLnByb2dyYW0uc2V0VW5pZm9ybXModGhpcy51bmlmb3Jtcyk7XG4gICAgY29uc3QgZGlkRHJhdyA9IHRoaXMucHJvZ3JhbS5kcmF3KE9iamVjdC5hc3NpZ24oRFJBV19QQVJBTVMsIG9wdHMsIHtcbiAgICAgIGxvZ1ByaW9yaXR5LFxuICAgICAgdW5pZm9ybXM6IG51bGwsXG4gICAgICBmcmFtZWJ1ZmZlcixcbiAgICAgIHBhcmFtZXRlcnMsXG4gICAgICBkcmF3TW9kZTogdGhpcy5nZXREcmF3TW9kZSgpLFxuICAgICAgdmVydGV4Q291bnQ6IHRoaXMuZ2V0VmVydGV4Q291bnQoKSxcbiAgICAgIHZlcnRleEFycmF5LFxuICAgICAgdHJhbnNmb3JtRmVlZGJhY2ssXG4gICAgICBpc0luZGV4ZWQsXG4gICAgICBpbmRleFR5cGUsXG4gICAgICBpc0luc3RhbmNlZCxcbiAgICAgIGluc3RhbmNlQ291bnQsXG4gICAgICBvZmZzZXQ6IGlzSW5kZXhlZCA/IGluZGV4T2Zmc2V0IDogMFxuICAgIH0pKTtcbiAgICBvbkFmdGVyUmVuZGVyKCk7XG5cbiAgICBpZiAobG9nLnByaW9yaXR5ID49IExPR19EUkFXX1BSSU9SSVRZKSB7XG4gICAgICB0aGlzLl9sb2dEcmF3Q2FsbEVuZChsb2dQcmlvcml0eSwgdmVydGV4QXJyYXksIGZyYW1lYnVmZmVyKTtcbiAgICB9XG5cbiAgICByZXR1cm4gZGlkRHJhdztcbiAgfVxuXG4gIHRyYW5zZm9ybSgpIHtcbiAgICBsZXQgb3B0cyA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge307XG4gICAgY29uc3Qge1xuICAgICAgZGlzY2FyZCA9IHRydWUsXG4gICAgICBmZWVkYmFja0J1ZmZlcnMsXG4gICAgICB1bmJpbmRNb2RlbHMgPSBbXVxuICAgIH0gPSBvcHRzO1xuICAgIGxldCB7XG4gICAgICBwYXJhbWV0ZXJzXG4gICAgfSA9IG9wdHM7XG5cbiAgICBpZiAoZmVlZGJhY2tCdWZmZXJzKSB7XG4gICAgICB0aGlzLl9zZXRGZWVkYmFja0J1ZmZlcnMoZmVlZGJhY2tCdWZmZXJzKTtcbiAgICB9XG5cbiAgICBpZiAoZGlzY2FyZCkge1xuICAgICAgcGFyYW1ldGVycyA9IE9iamVjdC5hc3NpZ24oe30sIHBhcmFtZXRlcnMsIHtcbiAgICAgICAgWzM1OTc3XTogZGlzY2FyZFxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgdW5iaW5kTW9kZWxzLmZvckVhY2gobW9kZWwgPT4gbW9kZWwudmVydGV4QXJyYXkudW5iaW5kQnVmZmVycygpKTtcblxuICAgIHRyeSB7XG4gICAgICB0aGlzLmRyYXcoT2JqZWN0LmFzc2lnbih7fSwgb3B0cywge1xuICAgICAgICBwYXJhbWV0ZXJzXG4gICAgICB9KSk7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIHVuYmluZE1vZGVscy5mb3JFYWNoKG1vZGVsID0+IG1vZGVsLnZlcnRleEFycmF5LmJpbmRCdWZmZXJzKCkpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgcmVuZGVyKCkge1xuICAgIGxldCB1bmlmb3JtcyA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge307XG4gICAgbG9nLndhcm4oJ01vZGVsLnJlbmRlcigpIGlzIGRlcHJlY2F0ZWQuIFVzZSBNb2RlbC5zZXRVbmlmb3JtcygpIGFuZCBNb2RlbC5kcmF3KCknKSgpO1xuICAgIHJldHVybiB0aGlzLnNldFVuaWZvcm1zKHVuaWZvcm1zKS5kcmF3KCk7XG4gIH1cblxuICBfc2V0TW9kZWxQcm9wcyhwcm9wcykge1xuICAgIE9iamVjdC5hc3NpZ24odGhpcy5wcm9wcywgcHJvcHMpO1xuXG4gICAgaWYgKCd1bmlmb3JtcycgaW4gcHJvcHMpIHtcbiAgICAgIHRoaXMuc2V0VW5pZm9ybXMocHJvcHMudW5pZm9ybXMpO1xuICAgIH1cblxuICAgIGlmICgncGlja2FibGUnIGluIHByb3BzKSB7XG4gICAgICB0aGlzLnBpY2thYmxlID0gcHJvcHMucGlja2FibGU7XG4gICAgfVxuXG4gICAgaWYgKCdpbnN0YW5jZUNvdW50JyBpbiBwcm9wcykge1xuICAgICAgdGhpcy5pbnN0YW5jZUNvdW50ID0gcHJvcHMuaW5zdGFuY2VDb3VudDtcbiAgICB9XG5cbiAgICBpZiAoJ2dlb21ldHJ5JyBpbiBwcm9wcykge1xuICAgICAgdGhpcy5zZXRHZW9tZXRyeShwcm9wcy5nZW9tZXRyeSk7XG4gICAgfVxuXG4gICAgaWYgKCdhdHRyaWJ1dGVzJyBpbiBwcm9wcykge1xuICAgICAgdGhpcy5zZXRBdHRyaWJ1dGVzKHByb3BzLmF0dHJpYnV0ZXMpO1xuICAgIH1cblxuICAgIGlmICgnX2ZlZWRiYWNrQnVmZmVycycgaW4gcHJvcHMpIHtcbiAgICAgIHRoaXMuX3NldEZlZWRiYWNrQnVmZmVycyhwcm9wcy5fZmVlZGJhY2tCdWZmZXJzKTtcbiAgICB9XG4gIH1cblxuICBfY2hlY2tQcm9ncmFtKCkge1xuICAgIGNvbnN0IG5lZWRzVXBkYXRlID0gdGhpcy5fcHJvZ3JhbURpcnR5IHx8IHRoaXMucHJvZ3JhbU1hbmFnZXIuc3RhdGVIYXNoICE9PSB0aGlzLl9wcm9ncmFtTWFuYWdlclN0YXRlO1xuXG4gICAgaWYgKCFuZWVkc1VwZGF0ZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGxldCB7XG4gICAgICBwcm9ncmFtXG4gICAgfSA9IHRoaXMucHJvZ3JhbVByb3BzO1xuXG4gICAgaWYgKHByb2dyYW0pIHtcbiAgICAgIHRoaXMuX21hbmFnZWRQcm9ncmFtID0gZmFsc2U7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgdnMsXG4gICAgICAgIGZzLFxuICAgICAgICBtb2R1bGVzLFxuICAgICAgICBpbmplY3QsXG4gICAgICAgIGRlZmluZXMsXG4gICAgICAgIHZhcnlpbmdzLFxuICAgICAgICBidWZmZXJNb2RlLFxuICAgICAgICB0cmFuc3BpbGVUb0dMU0wxMDBcbiAgICAgIH0gPSB0aGlzLnByb2dyYW1Qcm9wcztcbiAgICAgIHByb2dyYW0gPSB0aGlzLnByb2dyYW1NYW5hZ2VyLmdldCh7XG4gICAgICAgIHZzLFxuICAgICAgICBmcyxcbiAgICAgICAgbW9kdWxlcyxcbiAgICAgICAgaW5qZWN0LFxuICAgICAgICBkZWZpbmVzLFxuICAgICAgICB2YXJ5aW5ncyxcbiAgICAgICAgYnVmZmVyTW9kZSxcbiAgICAgICAgdHJhbnNwaWxlVG9HTFNMMTAwXG4gICAgICB9KTtcblxuICAgICAgaWYgKHRoaXMucHJvZ3JhbSAmJiB0aGlzLl9tYW5hZ2VkUHJvZ3JhbSkge1xuICAgICAgICB0aGlzLnByb2dyYW1NYW5hZ2VyLnJlbGVhc2UodGhpcy5wcm9ncmFtKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5fcHJvZ3JhbU1hbmFnZXJTdGF0ZSA9IHRoaXMucHJvZ3JhbU1hbmFnZXIuc3RhdGVIYXNoO1xuICAgICAgdGhpcy5fbWFuYWdlZFByb2dyYW0gPSB0cnVlO1xuICAgIH1cblxuICAgIGFzc2VydChwcm9ncmFtIGluc3RhbmNlb2YgUHJvZ3JhbSwgJ01vZGVsIG5lZWRzIGEgcHJvZ3JhbScpO1xuICAgIHRoaXMuX3Byb2dyYW1EaXJ0eSA9IGZhbHNlO1xuXG4gICAgaWYgKHByb2dyYW0gPT09IHRoaXMucHJvZ3JhbSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMucHJvZ3JhbSA9IHByb2dyYW07XG5cbiAgICBpZiAodGhpcy52ZXJ0ZXhBcnJheSkge1xuICAgICAgdGhpcy52ZXJ0ZXhBcnJheS5zZXRQcm9wcyh7XG4gICAgICAgIHByb2dyYW06IHRoaXMucHJvZ3JhbSxcbiAgICAgICAgYXR0cmlidXRlczogdGhpcy52ZXJ0ZXhBcnJheS5hdHRyaWJ1dGVzXG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy52ZXJ0ZXhBcnJheSA9IG5ldyBWZXJ0ZXhBcnJheSh0aGlzLmdsLCB7XG4gICAgICAgIHByb2dyYW06IHRoaXMucHJvZ3JhbVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgdGhpcy5zZXRVbmlmb3JtcyhPYmplY3QuYXNzaWduKHt9LCB0aGlzLmdldE1vZHVsZVVuaWZvcm1zKCkpKTtcbiAgfVxuXG4gIF9kZWxldGVHZW9tZXRyeUJ1ZmZlcnMoKSB7XG4gICAgZm9yIChjb25zdCBuYW1lIGluIHRoaXMuZ2VvbWV0cnlCdWZmZXJzKSB7XG4gICAgICBjb25zdCBidWZmZXIgPSB0aGlzLmdlb21ldHJ5QnVmZmVyc1tuYW1lXVswXSB8fCB0aGlzLmdlb21ldHJ5QnVmZmVyc1tuYW1lXTtcblxuICAgICAgaWYgKGJ1ZmZlciBpbnN0YW5jZW9mIEJ1ZmZlcikge1xuICAgICAgICBidWZmZXIuZGVsZXRlKCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgX3NldEFuaW1hdGlvblByb3BzKGFuaW1hdGlvblByb3BzKSB7XG4gICAgaWYgKHRoaXMuYW5pbWF0ZWQpIHtcbiAgICAgIGFzc2VydChhbmltYXRpb25Qcm9wcywgJ01vZGVsLmRyYXcoKTogYW5pbWF0ZWQgdW5pZm9ybXMgYnV0IG5vIGFuaW1hdGlvblByb3BzJyk7XG4gICAgfVxuICB9XG5cbiAgX3NldEZlZWRiYWNrQnVmZmVycygpIHtcbiAgICBsZXQgZmVlZGJhY2tCdWZmZXJzID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fTtcblxuICAgIGlmIChpc09iamVjdEVtcHR5KGZlZWRiYWNrQnVmZmVycykpIHtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIGNvbnN0IHtcbiAgICAgIGdsXG4gICAgfSA9IHRoaXMucHJvZ3JhbTtcbiAgICB0aGlzLnRyYW5zZm9ybUZlZWRiYWNrID0gdGhpcy50cmFuc2Zvcm1GZWVkYmFjayB8fCBuZXcgVHJhbnNmb3JtRmVlZGJhY2soZ2wsIHtcbiAgICAgIHByb2dyYW06IHRoaXMucHJvZ3JhbVxuICAgIH0pO1xuICAgIHRoaXMudHJhbnNmb3JtRmVlZGJhY2suc2V0QnVmZmVycyhmZWVkYmFja0J1ZmZlcnMpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgX2xvZ0RyYXdDYWxsU3RhcnQobG9nTGV2ZWwpIHtcbiAgICBjb25zdCBsb2dEcmF3VGltZW91dCA9IGxvZ0xldmVsID4gMyA/IDAgOiBMT0dfRFJBV19USU1FT1VUO1xuXG4gICAgaWYgKERhdGUubm93KCkgLSB0aGlzLmxhc3RMb2dUaW1lIDwgbG9nRHJhd1RpbWVvdXQpIHtcbiAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgdGhpcy5sYXN0TG9nVGltZSA9IERhdGUubm93KCk7XG4gICAgbG9nLmdyb3VwKExPR19EUkFXX1BSSU9SSVRZLCBcIj4+PiBEUkFXSU5HIE1PREVMIFwiLmNvbmNhdCh0aGlzLmlkKSwge1xuICAgICAgY29sbGFwc2VkOiBsb2cubGV2ZWwgPD0gMlxuICAgIH0pKCk7XG4gICAgcmV0dXJuIGxvZ0xldmVsO1xuICB9XG5cbiAgX2xvZ0RyYXdDYWxsRW5kKGxvZ0xldmVsLCB2ZXJ0ZXhBcnJheSwgdW5pZm9ybXMsIGZyYW1lYnVmZmVyKSB7XG4gICAgaWYgKGxvZ0xldmVsID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCBhdHRyaWJ1dGVUYWJsZSA9IGdldERlYnVnVGFibGVGb3JWZXJ0ZXhBcnJheSh7XG4gICAgICB2ZXJ0ZXhBcnJheSxcbiAgICAgIGhlYWRlcjogXCJcIi5jb25jYXQodGhpcy5pZCwgXCIgYXR0cmlidXRlc1wiKSxcbiAgICAgIGF0dHJpYnV0ZXM6IHRoaXMuX2F0dHJpYnV0ZXNcbiAgICB9KTtcbiAgICBjb25zdCB7XG4gICAgICB0YWJsZTogdW5pZm9ybVRhYmxlLFxuICAgICAgdW51c2VkVGFibGUsXG4gICAgICB1bnVzZWRDb3VudFxuICAgIH0gPSBnZXREZWJ1Z1RhYmxlRm9yVW5pZm9ybXMoe1xuICAgICAgaGVhZGVyOiBcIlwiLmNvbmNhdCh0aGlzLmlkLCBcIiB1bmlmb3Jtc1wiKSxcbiAgICAgIHByb2dyYW06IHRoaXMucHJvZ3JhbSxcbiAgICAgIHVuaWZvcm1zOiBPYmplY3QuYXNzaWduKHt9LCB0aGlzLnByb2dyYW0udW5pZm9ybXMsIHVuaWZvcm1zKVxuICAgIH0pO1xuICAgIGNvbnN0IHtcbiAgICAgIHRhYmxlOiBtaXNzaW5nVGFibGUsXG4gICAgICBjb3VudDogbWlzc2luZ0NvdW50XG4gICAgfSA9IGdldERlYnVnVGFibGVGb3JVbmlmb3Jtcyh7XG4gICAgICBoZWFkZXI6IFwiXCIuY29uY2F0KHRoaXMuaWQsIFwiIHVuaWZvcm1zXCIpLFxuICAgICAgcHJvZ3JhbTogdGhpcy5wcm9ncmFtLFxuICAgICAgdW5pZm9ybXM6IE9iamVjdC5hc3NpZ24oe30sIHRoaXMucHJvZ3JhbS51bmlmb3JtcywgdW5pZm9ybXMpLFxuICAgICAgdW5kZWZpbmVkT25seTogdHJ1ZVxuICAgIH0pO1xuXG4gICAgaWYgKG1pc3NpbmdDb3VudCA+IDApIHtcbiAgICAgIGxvZy5sb2coJ01JU1NJTkcgVU5JRk9STVMnLCBPYmplY3Qua2V5cyhtaXNzaW5nVGFibGUpKSgpO1xuICAgIH1cblxuICAgIGlmICh1bnVzZWRDb3VudCA+IDApIHtcbiAgICAgIGxvZy5sb2coJ1VOVVNFRCBVTklGT1JNUycsIE9iamVjdC5rZXlzKHVudXNlZFRhYmxlKSkoKTtcbiAgICB9XG5cbiAgICBjb25zdCBjb25maWdUYWJsZSA9IGdldERlYnVnVGFibGVGb3JQcm9ncmFtQ29uZmlndXJhdGlvbih0aGlzLnZlcnRleEFycmF5LmNvbmZpZ3VyYXRpb24pO1xuICAgIGxvZy50YWJsZShsb2dMZXZlbCwgYXR0cmlidXRlVGFibGUpKCk7XG4gICAgbG9nLnRhYmxlKGxvZ0xldmVsLCB1bmlmb3JtVGFibGUpKCk7XG4gICAgbG9nLnRhYmxlKGxvZ0xldmVsICsgMSwgY29uZmlnVGFibGUpKCk7XG5cbiAgICBpZiAoZnJhbWVidWZmZXIpIHtcbiAgICAgIGZyYW1lYnVmZmVyLmxvZyh7XG4gICAgICAgIGxvZ0xldmVsOiBMT0dfRFJBV19QUklPUklUWSxcbiAgICAgICAgbWVzc2FnZTogXCJSZW5kZXJlZCB0byBcIi5jb25jYXQoZnJhbWVidWZmZXIuaWQpXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBsb2cuZ3JvdXBFbmQoTE9HX0RSQVdfUFJJT1JJVFkpKCk7XG4gIH1cblxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bW9kZWwuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///80210\n")},43426:function(__unused_webpack_module,__webpack_exports__,__webpack_require__){eval("\n// EXPORTS\n__webpack_require__.d(__webpack_exports__, {\n  \"Z\": function() { return /* binding */ ProgramManager; }\n});\n\n// EXTERNAL MODULE: ./node_modules/@luma.gl/shadertools/dist/esm/lib/constants.js\nvar constants = __webpack_require__(75682);\n// EXTERNAL MODULE: ./node_modules/@luma.gl/shadertools/dist/esm/utils/assert.js\nvar assert = __webpack_require__(29047);\n;// CONCATENATED MODULE: ./node_modules/@luma.gl/shadertools/dist/esm/lib/filters/prop-types.js\nconst TYPE_DEFINITIONS = {\n  number: {\n    validate(value, propType) {\n      return Number.isFinite(value) && (!('max' in propType) || value <= propType.max) && (!('min' in propType) || value >= propType.min);\n    }\n\n  },\n  array: {\n    validate(value, propType) {\n      return Array.isArray(value) || ArrayBuffer.isView(value);\n    }\n\n  }\n};\nfunction parsePropTypes(propDefs) {\n  const propTypes = {};\n\n  for (const propName in propDefs) {\n    const propDef = propDefs[propName];\n    const propType = parsePropType(propDef);\n    propTypes[propName] = propType;\n  }\n\n  return propTypes;\n}\n\nfunction parsePropType(propDef) {\n  let type = getTypeOf(propDef);\n\n  if (type === 'object') {\n    if (!propDef) {\n      return {\n        type: 'object',\n        value: null\n      };\n    }\n\n    if ('type' in propDef) {\n      return Object.assign({}, propDef, TYPE_DEFINITIONS[propDef.type]);\n    }\n\n    if (!('value' in propDef)) {\n      return {\n        type: 'object',\n        value: propDef\n      };\n    }\n\n    type = getTypeOf(propDef.value);\n    return Object.assign({\n      type\n    }, propDef, TYPE_DEFINITIONS[type]);\n  }\n\n  return Object.assign({\n    type,\n    value: propDef\n  }, TYPE_DEFINITIONS[type]);\n}\n\nfunction getTypeOf(value) {\n  if (Array.isArray(value) || ArrayBuffer.isView(value)) {\n    return 'array';\n  }\n\n  return typeof value;\n}\n//# sourceMappingURL=prop-types.js.map\n;// CONCATENATED MODULE: ./node_modules/@luma.gl/shadertools/dist/esm/lib/shader-module.js\n\n\nconst VERTEX_SHADER = 'vs';\nconst FRAGMENT_SHADER = 'fs';\nclass ShaderModule {\n  constructor(_ref) {\n    let {\n      name,\n      vs,\n      fs,\n      dependencies = [],\n      uniforms,\n      getUniforms,\n      deprecations = [],\n      defines = {},\n      inject = {},\n      vertexShader,\n      fragmentShader\n    } = _ref;\n    (0,assert/* default */.Z)(typeof name === 'string');\n    this.name = name;\n    this.vs = vs || vertexShader;\n    this.fs = fs || fragmentShader;\n    this.getModuleUniforms = getUniforms;\n    this.dependencies = dependencies;\n    this.deprecations = this._parseDeprecationDefinitions(deprecations);\n    this.defines = defines;\n    this.injections = normalizeInjections(inject);\n\n    if (uniforms) {\n      this.uniforms = parsePropTypes(uniforms);\n    }\n  }\n\n  getModuleSource(type) {\n    let moduleSource;\n\n    switch (type) {\n      case VERTEX_SHADER:\n        moduleSource = this.vs || '';\n        break;\n\n      case FRAGMENT_SHADER:\n        moduleSource = this.fs || '';\n        break;\n\n      default:\n        (0,assert/* default */.Z)(false);\n    }\n\n    return \"#define MODULE_\".concat(this.name.toUpperCase().replace(/[^0-9a-z]/gi, '_'), \"\\n\").concat(moduleSource, \"// END MODULE_\").concat(this.name, \"\\n\\n\");\n  }\n\n  getUniforms(opts, uniforms) {\n    if (this.getModuleUniforms) {\n      return this.getModuleUniforms(opts, uniforms);\n    }\n\n    if (this.uniforms) {\n      return this._defaultGetUniforms(opts);\n    }\n\n    return {};\n  }\n\n  getDefines() {\n    return this.defines;\n  }\n\n  checkDeprecations(shaderSource, log) {\n    this.deprecations.forEach(def => {\n      if (def.regex.test(shaderSource)) {\n        if (def.deprecated) {\n          log.deprecated(def.old, def.new)();\n        } else {\n          log.removed(def.old, def.new)();\n        }\n      }\n    });\n  }\n\n  _parseDeprecationDefinitions(deprecations) {\n    deprecations.forEach(def => {\n      switch (def.type) {\n        case 'function':\n          def.regex = new RegExp(\"\\\\b\".concat(def.old, \"\\\\(\"));\n          break;\n\n        default:\n          def.regex = new RegExp(\"\".concat(def.type, \" \").concat(def.old, \";\"));\n      }\n    });\n    return deprecations;\n  }\n\n  _defaultGetUniforms() {\n    let opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    const uniforms = {};\n    const propTypes = this.uniforms;\n\n    for (const key in propTypes) {\n      const propDef = propTypes[key];\n\n      if (key in opts && !propDef.private) {\n        if (propDef.validate) {\n          (0,assert/* default */.Z)(propDef.validate(opts[key], propDef), \"\".concat(this.name, \": invalid \").concat(key));\n        }\n\n        uniforms[key] = opts[key];\n      } else {\n        uniforms[key] = propDef.value;\n      }\n    }\n\n    return uniforms;\n  }\n\n}\nfunction normalizeShaderModule(module) {\n  if (!module.normalized) {\n    module.normalized = true;\n\n    if (module.uniforms && !module.getUniforms) {\n      const shaderModule = new ShaderModule(module);\n      module.getUniforms = shaderModule.getUniforms.bind(shaderModule);\n    }\n  }\n\n  return module;\n}\n\nfunction normalizeInjections(injections) {\n  const result = {\n    vs: {},\n    fs: {}\n  };\n\n  for (const hook in injections) {\n    let injection = injections[hook];\n    const stage = hook.slice(0, 2);\n\n    if (typeof injection === 'string') {\n      injection = {\n        order: 0,\n        injection\n      };\n    }\n\n    result[stage][hook] = injection;\n  }\n\n  return result;\n}\n//# sourceMappingURL=shader-module.js.map\n;// CONCATENATED MODULE: ./node_modules/@luma.gl/shadertools/dist/esm/lib/resolve-modules.js\n\n\nfunction resolveModules(modules) {\n  return getShaderDependencies(instantiateModules(modules));\n}\n\nfunction getShaderDependencies(modules) {\n  const moduleMap = {};\n  const moduleDepth = {};\n  getDependencyGraph({\n    modules,\n    level: 0,\n    moduleMap,\n    moduleDepth\n  });\n  return Object.keys(moduleDepth).sort((a, b) => moduleDepth[b] - moduleDepth[a]).map(name => moduleMap[name]);\n}\n\nfunction getDependencyGraph(_ref) {\n  let {\n    modules,\n    level,\n    moduleMap,\n    moduleDepth\n  } = _ref;\n\n  if (level >= 5) {\n    throw new Error('Possible loop in shader dependency graph');\n  }\n\n  for (const module of modules) {\n    moduleMap[module.name] = module;\n\n    if (moduleDepth[module.name] === undefined || moduleDepth[module.name] < level) {\n      moduleDepth[module.name] = level;\n    }\n  }\n\n  for (const module of modules) {\n    if (module.dependencies) {\n      getDependencyGraph({\n        modules: module.dependencies,\n        level: level + 1,\n        moduleMap,\n        moduleDepth\n      });\n    }\n  }\n}\n\nfunction instantiateModules(modules, seen) {\n  return modules.map(module => {\n    if (module instanceof ShaderModule) {\n      return module;\n    }\n\n    (0,assert/* default */.Z)(typeof module !== 'string', \"Shader module use by name is deprecated. Import shader module '\".concat(module, \"' and use it directly.\"));\n    (0,assert/* default */.Z)(module.name, 'shader module has no name');\n    module = new ShaderModule(module);\n    module.dependencies = instantiateModules(module.dependencies);\n    return module;\n  });\n}\n\nconst TEST_EXPORTS = {\n  getShaderDependencies,\n  getDependencyGraph\n};\n//# sourceMappingURL=resolve-modules.js.map\n;// CONCATENATED MODULE: ./node_modules/@luma.gl/shadertools/dist/esm/utils/is-old-ie.js\nfunction isOldIE() {\n  let opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  const navigator = typeof window !== 'undefined' ? window.navigator || {} : {};\n  const userAgent = opts.userAgent || navigator.userAgent || '';\n  const isMSIE = userAgent.indexOf('MSIE ') !== -1;\n  const isTrident = userAgent.indexOf('Trident/') !== -1;\n  return isMSIE || isTrident;\n}\n//# sourceMappingURL=is-old-ie.js.map\n;// CONCATENATED MODULE: ./node_modules/@luma.gl/shadertools/dist/esm/utils/webgl-info.js\n\n\nconst GL_VENDOR = 0x1f00;\nconst GL_RENDERER = 0x1f01;\nconst GL_VERSION = 0x1f02;\nconst GL_SHADING_LANGUAGE_VERSION = 0x8b8c;\nconst WEBGL_FEATURES = {\n  GLSL_FRAG_DATA: ['WEBGL_draw_buffers', true],\n  GLSL_FRAG_DEPTH: ['EXT_frag_depth', true],\n  GLSL_DERIVATIVES: ['OES_standard_derivatives', true],\n  GLSL_TEXTURE_LOD: ['EXT_shader_texture_lod', true]\n};\nconst FEATURES = {};\nObject.keys(WEBGL_FEATURES).forEach(key => {\n  FEATURES[key] = key;\n});\n\n\nfunction isWebGL2(gl) {\n  if (typeof WebGL2RenderingContext !== 'undefined' && gl instanceof WebGL2RenderingContext) {\n    return true;\n  }\n\n  return Boolean(gl && gl._version === 2);\n}\n\nfunction getContextInfo(gl) {\n  const info = gl.getExtension('WEBGL_debug_renderer_info');\n  const vendor = gl.getParameter(info && info.UNMASKED_VENDOR_WEBGL || GL_VENDOR);\n  const renderer = gl.getParameter(info && info.UNMASKED_RENDERER_WEBGL || GL_RENDERER);\n  const gpuVendor = identifyGPUVendor(vendor, renderer);\n  const gpuInfo = {\n    gpuVendor,\n    vendor,\n    renderer,\n    version: gl.getParameter(GL_VERSION),\n    shadingLanguageVersion: gl.getParameter(GL_SHADING_LANGUAGE_VERSION)\n  };\n  return gpuInfo;\n}\n\nfunction identifyGPUVendor(vendor, renderer) {\n  if (vendor.match(/NVIDIA/i) || renderer.match(/NVIDIA/i)) {\n    return 'NVIDIA';\n  }\n\n  if (vendor.match(/INTEL/i) || renderer.match(/INTEL/i)) {\n    return 'INTEL';\n  }\n\n  if (vendor.match(/AMD/i) || renderer.match(/AMD/i) || vendor.match(/ATI/i) || renderer.match(/ATI/i)) {\n    return 'AMD';\n  }\n\n  return 'UNKNOWN GPU';\n}\n\nconst compiledGlslExtensions = {};\nfunction canCompileGLGSExtension(gl, cap) {\n  let opts = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  const feature = WEBGL_FEATURES[cap];\n  (0,assert/* default */.Z)(feature, cap);\n\n  if (!isOldIE(opts)) {\n    return true;\n  }\n\n  if (cap in compiledGlslExtensions) {\n    return compiledGlslExtensions[cap];\n  }\n\n  const extensionName = feature[0];\n  const behavior = opts.behavior || 'enable';\n  const source = \"#extension GL_\".concat(extensionName, \" : \").concat(behavior, \"\\nvoid main(void) {}\");\n  const shader = gl.createShader(35633);\n  gl.shaderSource(shader, source);\n  gl.compileShader(shader);\n  const canCompile = gl.getShaderParameter(shader, 35713);\n  gl.deleteShader(shader);\n  compiledGlslExtensions[cap] = canCompile;\n  return canCompile;\n}\n\nfunction getFeature(gl, cap) {\n  const feature = WEBGL_FEATURES[cap];\n  (0,assert/* default */.Z)(feature, cap);\n  const extensionName = isWebGL2(gl) ? feature[1] || feature[0] : feature[0];\n  const value = typeof extensionName === 'string' ? Boolean(gl.getExtension(extensionName)) : extensionName;\n  (0,assert/* default */.Z)(value === false || value === true);\n  return value;\n}\n\nfunction hasFeatures(gl, features) {\n  features = Array.isArray(features) ? features : [features];\n  return features.every(feature => getFeature(gl, feature));\n}\n//# sourceMappingURL=webgl-info.js.map\n;// CONCATENATED MODULE: ./node_modules/@luma.gl/shadertools/dist/esm/lib/platform-defines.js\n\nfunction getPlatformShaderDefines(gl) {\n  const debugInfo = getContextInfo(gl);\n\n  switch (debugInfo.gpuVendor.toLowerCase()) {\n    case 'nvidia':\n      return \"#define NVIDIA_GPU\\n// Nvidia optimizes away the calculation necessary for emulated fp64\\n#define LUMA_FP64_CODE_ELIMINATION_WORKAROUND 1\\n\";\n\n    case 'intel':\n      return \"#define INTEL_GPU\\n// Intel optimizes away the calculation necessary for emulated fp64\\n#define LUMA_FP64_CODE_ELIMINATION_WORKAROUND 1\\n// Intel's built-in 'tan' function doesn't have acceptable precision\\n#define LUMA_FP32_TAN_PRECISION_WORKAROUND 1\\n// Intel GPU doesn't have full 32 bits precision in same cases, causes overflow\\n#define LUMA_FP64_HIGH_BITS_OVERFLOW_WORKAROUND 1\\n\";\n\n    case 'amd':\n      return \"#define AMD_GPU\\n\";\n\n    default:\n      return \"#define DEFAULT_GPU\\n// Prevent driver from optimizing away the calculation necessary for emulated fp64\\n#define LUMA_FP64_CODE_ELIMINATION_WORKAROUND 1\\n// Intel's built-in 'tan' function doesn't have acceptable precision\\n#define LUMA_FP32_TAN_PRECISION_WORKAROUND 1\\n// Intel GPU doesn't have full 32 bits precision in same cases, causes overflow\\n#define LUMA_FP64_HIGH_BITS_OVERFLOW_WORKAROUND 1\\n\";\n  }\n}\nfunction getVersionDefines(gl, glslVersion, isFragment) {\n  let versionDefines = \"#if (__VERSION__ > 120)\\n\\n# define FEATURE_GLSL_DERIVATIVES\\n# define FEATURE_GLSL_DRAW_BUFFERS\\n# define FEATURE_GLSL_FRAG_DEPTH\\n# define FEATURE_GLSL_TEXTURE_LOD\\n\\n// DEPRECATED FLAGS, remove in v9\\n# define FRAG_DEPTH\\n# define DERIVATIVES\\n# define DRAW_BUFFERS\\n# define TEXTURE_LOD\\n\\n#endif // __VERSION\\n\";\n\n  if (hasFeatures(gl, FEATURES.GLSL_FRAG_DEPTH)) {\n    versionDefines += \"\\n// FRAG_DEPTH => gl_FragDepth is available\\n#ifdef GL_EXT_frag_depth\\n#extension GL_EXT_frag_depth : enable\\n# define FEATURE_GLSL_FRAG_DEPTH\\n# define FRAG_DEPTH\\n# define gl_FragDepth gl_FragDepthEXT\\n#endif\\n\";\n  }\n\n  if (hasFeatures(gl, FEATURES.GLSL_DERIVATIVES) && canCompileGLGSExtension(gl, FEATURES.GLSL_DERIVATIVES)) {\n    versionDefines += \"\\n// DERIVATIVES => dxdF, dxdY and fwidth are available\\n#ifdef GL_OES_standard_derivatives\\n#extension GL_OES_standard_derivatives : enable\\n# define FEATURE_GLSL_DERIVATIVES\\n# define DERIVATIVES\\n#endif\\n\";\n  }\n\n  if (hasFeatures(gl, FEATURES.GLSL_FRAG_DATA) && canCompileGLGSExtension(gl, FEATURES.GLSL_FRAG_DATA, {\n    behavior: 'require'\n  })) {\n    versionDefines += \"\\n// DRAW_BUFFERS => gl_FragData[] is available\\n#ifdef GL_EXT_draw_buffers\\n#extension GL_EXT_draw_buffers : require\\n#define FEATURE_GLSL_DRAW_BUFFERS\\n#define DRAW_BUFFERS\\n#endif\\n\";\n  }\n\n  if (hasFeatures(gl, FEATURES.GLSL_TEXTURE_LOD)) {\n    versionDefines += \"// TEXTURE_LOD => texture2DLod etc are available\\n#ifdef GL_EXT_shader_texture_lod\\n#extension GL_EXT_shader_texture_lod : enable\\n\\n# define FEATURE_GLSL_TEXTURE_LOD\\n# define TEXTURE_LOD\\n\\n#endif\\n\";\n  }\n\n  return versionDefines;\n}\n//# sourceMappingURL=platform-defines.js.map\n// EXTERNAL MODULE: ./node_modules/@luma.gl/shadertools/dist/esm/lib/inject-shader.js + 1 modules\nvar inject_shader = __webpack_require__(60827);\n;// CONCATENATED MODULE: ./node_modules/@luma.gl/shadertools/dist/esm/lib/transpile-shader.js\nfunction testVariable(qualifier) {\n  return new RegExp(\"\\\\b\".concat(qualifier, \"[ \\\\t]+(\\\\w+[ \\\\t]+\\\\w+(\\\\[\\\\w+\\\\])?;)\"), 'g');\n}\n\nconst ES300_REPLACEMENTS = [[/^(#version[ \\t]+(100|300[ \\t]+es))?[ \\t]*\\n/, '#version 300 es\\n'], [/\\btexture(2D|2DProj|Cube)Lod(EXT)?\\(/g, 'textureLod('], [/\\btexture(2D|2DProj|Cube)(EXT)?\\(/g, 'texture(']];\nconst ES300_VERTEX_REPLACEMENTS = [...ES300_REPLACEMENTS, [testVariable('attribute'), 'in $1'], [testVariable('varying'), 'out $1']];\nconst ES300_FRAGMENT_REPLACEMENTS = [...ES300_REPLACEMENTS, [testVariable('varying'), 'in $1']];\nconst ES100_REPLACEMENTS = [[/^#version[ \\t]+300[ \\t]+es/, '#version 100'], [/\\btexture(2D|2DProj|Cube)Lod\\(/g, 'texture$1LodEXT('], [/\\btexture\\(/g, 'texture2D('], [/\\btextureLod\\(/g, 'texture2DLodEXT(']];\nconst ES100_VERTEX_REPLACEMENTS = [...ES100_REPLACEMENTS, [testVariable('in'), 'attribute $1'], [testVariable('out'), 'varying $1']];\nconst ES100_FRAGMENT_REPLACEMENTS = [...ES100_REPLACEMENTS, [testVariable('in'), 'varying $1']];\nconst ES100_FRAGMENT_OUTPUT_NAME = 'gl_FragColor';\nconst ES300_FRAGMENT_OUTPUT_REGEX = /\\bout[ \\t]+vec4[ \\t]+(\\w+)[ \\t]*;\\n?/;\nconst REGEX_START_OF_MAIN = /void\\s+main\\s*\\([^)]*\\)\\s*\\{\\n?/;\nfunction transpileShader(source, targetGLSLVersion, isVertex) {\n  switch (targetGLSLVersion) {\n    case 300:\n      return isVertex ? convertShader(source, ES300_VERTEX_REPLACEMENTS) : convertFragmentShaderTo300(source);\n\n    case 100:\n      return isVertex ? convertShader(source, ES100_VERTEX_REPLACEMENTS) : convertFragmentShaderTo100(source);\n\n    default:\n      throw new Error(\"unknown GLSL version \".concat(targetGLSLVersion));\n  }\n}\n\nfunction convertShader(source, replacements) {\n  for (const [pattern, replacement] of replacements) {\n    source = source.replace(pattern, replacement);\n  }\n\n  return source;\n}\n\nfunction convertFragmentShaderTo300(source) {\n  source = convertShader(source, ES300_FRAGMENT_REPLACEMENTS);\n  const outputMatch = source.match(ES300_FRAGMENT_OUTPUT_REGEX);\n\n  if (outputMatch) {\n    const outputName = outputMatch[1];\n    source = source.replace(new RegExp(\"\\\\b\".concat(ES100_FRAGMENT_OUTPUT_NAME, \"\\\\b\"), 'g'), outputName);\n  } else {\n    const outputName = 'fragmentColor';\n    source = source.replace(REGEX_START_OF_MAIN, match => \"out vec4 \".concat(outputName, \";\\n\").concat(match)).replace(new RegExp(\"\\\\b\".concat(ES100_FRAGMENT_OUTPUT_NAME, \"\\\\b\"), 'g'), outputName);\n  }\n\n  return source;\n}\n\nfunction convertFragmentShaderTo100(source) {\n  source = convertShader(source, ES100_FRAGMENT_REPLACEMENTS);\n  const outputMatch = source.match(ES300_FRAGMENT_OUTPUT_REGEX);\n\n  if (outputMatch) {\n    const outputName = outputMatch[1];\n    source = source.replace(ES300_FRAGMENT_OUTPUT_REGEX, '').replace(new RegExp(\"\\\\b\".concat(outputName, \"\\\\b\"), 'g'), ES100_FRAGMENT_OUTPUT_NAME);\n  }\n\n  return source;\n}\n//# sourceMappingURL=transpile-shader.js.map\n;// CONCATENATED MODULE: ./node_modules/@luma.gl/shadertools/dist/esm/lib/assemble-shaders.js\n\n\n\n\n\n\nconst INJECT_SHADER_DECLARATIONS = \"\\n\\n\".concat(inject_shader/* DECLARATION_INJECT_MARKER */.O_, \"\\n\\n\");\nconst SHADER_TYPE = {\n  [constants/* VERTEX_SHADER */.H]: 'vertex',\n  [constants/* FRAGMENT_SHADER */.Y]: 'fragment'\n};\nconst FRAGMENT_SHADER_PROLOGUE = \"precision highp float;\\n\\n\";\nfunction assembleShaders(gl, opts) {\n  const {\n    vs,\n    fs\n  } = opts;\n  const modules = resolveModules(opts.modules || []);\n  return {\n    gl,\n    vs: assembleShader(gl, Object.assign({}, opts, {\n      source: vs,\n      type: constants/* VERTEX_SHADER */.H,\n      modules\n    })),\n    fs: assembleShader(gl, Object.assign({}, opts, {\n      source: fs,\n      type: constants/* FRAGMENT_SHADER */.Y,\n      modules\n    })),\n    getUniforms: assembleGetUniforms(modules)\n  };\n}\n\nfunction assembleShader(gl, _ref) {\n  let {\n    id,\n    source,\n    type,\n    modules,\n    defines = {},\n    hookFunctions = [],\n    inject = {},\n    transpileToGLSL100 = false,\n    prologue = true,\n    log\n  } = _ref;\n  (0,assert/* default */.Z)(typeof source === 'string', 'shader source must be a string');\n  const isVertex = type === constants/* VERTEX_SHADER */.H;\n  const sourceLines = source.split('\\n');\n  let glslVersion = 100;\n  let versionLine = '';\n  let coreSource = source;\n\n  if (sourceLines[0].indexOf('#version ') === 0) {\n    glslVersion = 300;\n    versionLine = sourceLines[0];\n    coreSource = sourceLines.slice(1).join('\\n');\n  } else {\n    versionLine = \"#version \".concat(glslVersion);\n  }\n\n  const allDefines = {};\n  modules.forEach(module => {\n    Object.assign(allDefines, module.getDefines());\n  });\n  Object.assign(allDefines, defines);\n  let assembledSource = prologue ? \"\".concat(versionLine, \"\\n\").concat(getShaderName({\n    id,\n    source,\n    type\n  }), \"\\n\").concat(getShaderType({\n    type\n  }), \"\\n\").concat(getPlatformShaderDefines(gl), \"\\n\").concat(getVersionDefines(gl, glslVersion, !isVertex), \"\\n\").concat(getApplicationDefines(allDefines), \"\\n\").concat(isVertex ? '' : FRAGMENT_SHADER_PROLOGUE, \"\\n\") : \"\".concat(versionLine, \"\\n\");\n  const hookFunctionMap = normalizeHookFunctions(hookFunctions);\n  const hookInjections = {};\n  const declInjections = {};\n  const mainInjections = {};\n\n  for (const key in inject) {\n    const injection = typeof inject[key] === 'string' ? {\n      injection: inject[key],\n      order: 0\n    } : inject[key];\n    const match = key.match(/^(v|f)s:(#)?([\\w-]+)$/);\n\n    if (match) {\n      const hash = match[2];\n      const name = match[3];\n\n      if (hash) {\n        if (name === 'decl') {\n          declInjections[key] = [injection];\n        } else {\n          mainInjections[key] = [injection];\n        }\n      } else {\n        hookInjections[key] = [injection];\n      }\n    } else {\n      mainInjections[key] = [injection];\n    }\n  }\n\n  for (const module of modules) {\n    if (log) {\n      module.checkDeprecations(coreSource, log);\n    }\n\n    const moduleSource = module.getModuleSource(type, glslVersion);\n    assembledSource += moduleSource;\n    const injections = module.injections[type];\n\n    for (const key in injections) {\n      const match = key.match(/^(v|f)s:#([\\w-]+)$/);\n\n      if (match) {\n        const name = match[2];\n        const injectionType = name === 'decl' ? declInjections : mainInjections;\n        injectionType[key] = injectionType[key] || [];\n        injectionType[key].push(injections[key]);\n      } else {\n        hookInjections[key] = hookInjections[key] || [];\n        hookInjections[key].push(injections[key]);\n      }\n    }\n  }\n\n  assembledSource += INJECT_SHADER_DECLARATIONS;\n  assembledSource = (0,inject_shader/* default */.ZP)(assembledSource, type, declInjections);\n  assembledSource += getHookFunctions(hookFunctionMap[type], hookInjections);\n  assembledSource += coreSource;\n  assembledSource = (0,inject_shader/* default */.ZP)(assembledSource, type, mainInjections);\n  assembledSource = transpileShader(assembledSource, transpileToGLSL100 ? 100 : glslVersion, isVertex);\n  return assembledSource;\n}\n\nfunction assembleGetUniforms(modules) {\n  return function getUniforms(opts) {\n    const uniforms = {};\n\n    for (const module of modules) {\n      const moduleUniforms = module.getUniforms(opts, uniforms);\n      Object.assign(uniforms, moduleUniforms);\n    }\n\n    return uniforms;\n  };\n}\n\nfunction getShaderType(_ref2) {\n  let {\n    type\n  } = _ref2;\n  return \"\\n#define SHADER_TYPE_\".concat(SHADER_TYPE[type].toUpperCase(), \"\\n\");\n}\n\nfunction getShaderName(_ref3) {\n  let {\n    id,\n    source,\n    type\n  } = _ref3;\n  const injectShaderName = id && typeof id === 'string' && source.indexOf('SHADER_NAME') === -1;\n  return injectShaderName ? \"\\n#define SHADER_NAME \".concat(id, \"_\").concat(SHADER_TYPE[type], \"\\n\\n\") : '';\n}\n\nfunction getApplicationDefines() {\n  let defines = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  let count = 0;\n  let sourceText = '';\n\n  for (const define in defines) {\n    if (count === 0) {\n      sourceText += '\\n// APPLICATION DEFINES\\n';\n    }\n\n    count++;\n    const value = defines[define];\n\n    if (value || Number.isFinite(value)) {\n      sourceText += \"#define \".concat(define.toUpperCase(), \" \").concat(defines[define], \"\\n\");\n    }\n  }\n\n  if (count === 0) {\n    sourceText += '\\n';\n  }\n\n  return sourceText;\n}\n\nfunction getHookFunctions(hookFunctions, hookInjections) {\n  let result = '';\n\n  for (const hookName in hookFunctions) {\n    const hookFunction = hookFunctions[hookName];\n    result += \"void \".concat(hookFunction.signature, \" {\\n\");\n\n    if (hookFunction.header) {\n      result += \"  \".concat(hookFunction.header);\n    }\n\n    if (hookInjections[hookName]) {\n      const injections = hookInjections[hookName];\n      injections.sort((a, b) => a.order - b.order);\n\n      for (const injection of injections) {\n        result += \"  \".concat(injection.injection, \"\\n\");\n      }\n    }\n\n    if (hookFunction.footer) {\n      result += \"  \".concat(hookFunction.footer);\n    }\n\n    result += '}\\n';\n  }\n\n  return result;\n}\n\nfunction normalizeHookFunctions(hookFunctions) {\n  const result = {\n    vs: {},\n    fs: {}\n  };\n  hookFunctions.forEach(hook => {\n    let opts;\n\n    if (typeof hook !== 'string') {\n      opts = hook;\n      hook = opts.hook;\n    } else {\n      opts = {};\n    }\n\n    hook = hook.trim();\n    const [stage, signature] = hook.split(':');\n    const name = hook.replace(/\\(.+/, '');\n    result[stage][name] = Object.assign(opts, {\n      signature\n    });\n  });\n  return result;\n}\n//# sourceMappingURL=assemble-shaders.js.map\n// EXTERNAL MODULE: ./node_modules/@luma.gl/webgl/dist/esm/classes/program.js + 6 modules\nvar program = __webpack_require__(75433);\n;// CONCATENATED MODULE: ./node_modules/@luma.gl/engine/dist/esm/lib/program-manager.js\n\n\nclass ProgramManager {\n  static getDefaultProgramManager(gl) {\n    gl.luma = gl.luma || {};\n    gl.luma.defaultProgramManager = gl.luma.defaultProgramManager || new ProgramManager(gl);\n    return gl.luma.defaultProgramManager;\n  }\n\n  constructor(gl) {\n    this.gl = gl;\n    this._programCache = {};\n    this._getUniforms = {};\n    this._registeredModules = {};\n    this._hookFunctions = [];\n    this._defaultModules = [];\n    this._hashes = {};\n    this._hashCounter = 0;\n    this.stateHash = 0;\n    this._useCounts = {};\n  }\n\n  addDefaultModule(module) {\n    if (!this._defaultModules.find(m => m.name === module.name)) {\n      this._defaultModules.push(module);\n    }\n\n    this.stateHash++;\n  }\n\n  removeDefaultModule(module) {\n    const moduleName = typeof module === 'string' ? module : module.name;\n    this._defaultModules = this._defaultModules.filter(m => m.name !== moduleName);\n    this.stateHash++;\n  }\n\n  addShaderHook(hook, opts) {\n    if (opts) {\n      hook = Object.assign(opts, {\n        hook\n      });\n    }\n\n    this._hookFunctions.push(hook);\n\n    this.stateHash++;\n  }\n\n  get() {\n    let props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    const {\n      vs = '',\n      fs = '',\n      defines = {},\n      inject = {},\n      varyings = [],\n      bufferMode = 0x8c8d,\n      transpileToGLSL100 = false\n    } = props;\n\n    const modules = this._getModuleList(props.modules);\n\n    const vsHash = this._getHash(vs);\n\n    const fsHash = this._getHash(fs);\n\n    const moduleHashes = modules.map(m => this._getHash(m.name)).sort();\n    const varyingHashes = varyings.map(v => this._getHash(v));\n    const defineKeys = Object.keys(defines).sort();\n    const injectKeys = Object.keys(inject).sort();\n    const defineHashes = [];\n    const injectHashes = [];\n\n    for (const key of defineKeys) {\n      defineHashes.push(this._getHash(key));\n      defineHashes.push(this._getHash(defines[key]));\n    }\n\n    for (const key of injectKeys) {\n      injectHashes.push(this._getHash(key));\n      injectHashes.push(this._getHash(inject[key]));\n    }\n\n    const hash = \"\".concat(vsHash, \"/\").concat(fsHash, \"D\").concat(defineHashes.join('/'), \"M\").concat(moduleHashes.join('/'), \"I\").concat(injectHashes.join('/'), \"V\").concat(varyingHashes.join('/'), \"H\").concat(this.stateHash, \"B\").concat(bufferMode).concat(transpileToGLSL100 ? 'T' : '');\n\n    if (!this._programCache[hash]) {\n      const assembled = assembleShaders(this.gl, {\n        vs,\n        fs,\n        modules,\n        inject,\n        defines,\n        hookFunctions: this._hookFunctions,\n        transpileToGLSL100\n      });\n      this._programCache[hash] = new program/* default */.Z(this.gl, {\n        hash,\n        vs: assembled.vs,\n        fs: assembled.fs,\n        varyings,\n        bufferMode\n      });\n\n      this._getUniforms[hash] = assembled.getUniforms || (x => {});\n\n      this._useCounts[hash] = 0;\n    }\n\n    this._useCounts[hash]++;\n    return this._programCache[hash];\n  }\n\n  getUniforms(program) {\n    return this._getUniforms[program.hash] || null;\n  }\n\n  release(program) {\n    const hash = program.hash;\n    this._useCounts[hash]--;\n\n    if (this._useCounts[hash] === 0) {\n      this._programCache[hash].delete();\n\n      delete this._programCache[hash];\n      delete this._getUniforms[hash];\n      delete this._useCounts[hash];\n    }\n  }\n\n  _getHash(key) {\n    if (this._hashes[key] === undefined) {\n      this._hashes[key] = this._hashCounter++;\n    }\n\n    return this._hashes[key];\n  }\n\n  _getModuleList() {\n    let appModules = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n    const modules = new Array(this._defaultModules.length + appModules.length);\n    const seen = {};\n    let count = 0;\n\n    for (let i = 0, len = this._defaultModules.length; i < len; ++i) {\n      const module = this._defaultModules[i];\n      const name = module.name;\n      modules[count++] = module;\n      seen[name] = true;\n    }\n\n    for (let i = 0, len = appModules.length; i < len; ++i) {\n      const module = appModules[i];\n      const name = module.name;\n\n      if (!seen[name]) {\n        modules[count++] = module;\n        seen[name] = true;\n      }\n    }\n\n    modules.length = count;\n    return modules;\n  }\n\n}\n//# sourceMappingURL=program-manager.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLHdCQUF3QixlQUFlO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLHFDQUFxQyxzQkFBTztBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUCxpRUFBaUU7O0FBRWpFO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx1REFBdUQsU0FBUztBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDZDQUE2QyxTQUFTO0FBQ3REO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3Z1ZTMtd2VicGFjazUvLi9ub2RlX21vZHVsZXMvQGx1bWEuZ2wvc2hhZGVydG9vbHMvZGlzdC9lc20vbGliL2ZpbHRlcnMvcHJvcC10eXBlcy5qcz82YWYwIiwid2VicGFjazovL3Z1ZTMtd2VicGFjazUvLi9ub2RlX21vZHVsZXMvQGx1bWEuZ2wvc2hhZGVydG9vbHMvZGlzdC9lc20vbGliL3NoYWRlci1tb2R1bGUuanM/MmZlNCIsIndlYnBhY2s6Ly92dWUzLXdlYnBhY2s1Ly4vbm9kZV9tb2R1bGVzL0BsdW1hLmdsL3NoYWRlcnRvb2xzL2Rpc3QvZXNtL2xpYi9yZXNvbHZlLW1vZHVsZXMuanM/ODUwNCIsIndlYnBhY2s6Ly92dWUzLXdlYnBhY2s1Ly4vbm9kZV9tb2R1bGVzL0BsdW1hLmdsL3NoYWRlcnRvb2xzL2Rpc3QvZXNtL3V0aWxzL2lzLW9sZC1pZS5qcz8yNmM3Iiwid2VicGFjazovL3Z1ZTMtd2VicGFjazUvLi9ub2RlX21vZHVsZXMvQGx1bWEuZ2wvc2hhZGVydG9vbHMvZGlzdC9lc20vdXRpbHMvd2ViZ2wtaW5mby5qcz9lY2VkIiwid2VicGFjazovL3Z1ZTMtd2VicGFjazUvLi9ub2RlX21vZHVsZXMvQGx1bWEuZ2wvc2hhZGVydG9vbHMvZGlzdC9lc20vbGliL3BsYXRmb3JtLWRlZmluZXMuanM/ZGE5YiIsIndlYnBhY2s6Ly92dWUzLXdlYnBhY2s1Ly4vbm9kZV9tb2R1bGVzL0BsdW1hLmdsL3NoYWRlcnRvb2xzL2Rpc3QvZXNtL2xpYi90cmFuc3BpbGUtc2hhZGVyLmpzPzdhOWMiLCJ3ZWJwYWNrOi8vdnVlMy13ZWJwYWNrNS8uL25vZGVfbW9kdWxlcy9AbHVtYS5nbC9zaGFkZXJ0b29scy9kaXN0L2VzbS9saWIvYXNzZW1ibGUtc2hhZGVycy5qcz9lODNkIiwid2VicGFjazovL3Z1ZTMtd2VicGFjazUvLi9ub2RlX21vZHVsZXMvQGx1bWEuZ2wvZW5naW5lL2Rpc3QvZXNtL2xpYi9wcm9ncmFtLW1hbmFnZXIuanM/ODg1NCJdLCJzb3VyY2VzQ29udGVudCI6WyJjb25zdCBUWVBFX0RFRklOSVRJT05TID0ge1xuICBudW1iZXI6IHtcbiAgICB2YWxpZGF0ZSh2YWx1ZSwgcHJvcFR5cGUpIHtcbiAgICAgIHJldHVybiBOdW1iZXIuaXNGaW5pdGUodmFsdWUpICYmICghKCdtYXgnIGluIHByb3BUeXBlKSB8fCB2YWx1ZSA8PSBwcm9wVHlwZS5tYXgpICYmICghKCdtaW4nIGluIHByb3BUeXBlKSB8fCB2YWx1ZSA+PSBwcm9wVHlwZS5taW4pO1xuICAgIH1cblxuICB9LFxuICBhcnJheToge1xuICAgIHZhbGlkYXRlKHZhbHVlLCBwcm9wVHlwZSkge1xuICAgICAgcmV0dXJuIEFycmF5LmlzQXJyYXkodmFsdWUpIHx8IEFycmF5QnVmZmVyLmlzVmlldyh2YWx1ZSk7XG4gICAgfVxuXG4gIH1cbn07XG5leHBvcnQgZnVuY3Rpb24gcGFyc2VQcm9wVHlwZXMocHJvcERlZnMpIHtcbiAgY29uc3QgcHJvcFR5cGVzID0ge307XG5cbiAgZm9yIChjb25zdCBwcm9wTmFtZSBpbiBwcm9wRGVmcykge1xuICAgIGNvbnN0IHByb3BEZWYgPSBwcm9wRGVmc1twcm9wTmFtZV07XG4gICAgY29uc3QgcHJvcFR5cGUgPSBwYXJzZVByb3BUeXBlKHByb3BEZWYpO1xuICAgIHByb3BUeXBlc1twcm9wTmFtZV0gPSBwcm9wVHlwZTtcbiAgfVxuXG4gIHJldHVybiBwcm9wVHlwZXM7XG59XG5cbmZ1bmN0aW9uIHBhcnNlUHJvcFR5cGUocHJvcERlZikge1xuICBsZXQgdHlwZSA9IGdldFR5cGVPZihwcm9wRGVmKTtcblxuICBpZiAodHlwZSA9PT0gJ29iamVjdCcpIHtcbiAgICBpZiAoIXByb3BEZWYpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6ICdvYmplY3QnLFxuICAgICAgICB2YWx1ZTogbnVsbFxuICAgICAgfTtcbiAgICB9XG5cbiAgICBpZiAoJ3R5cGUnIGluIHByb3BEZWYpIHtcbiAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKHt9LCBwcm9wRGVmLCBUWVBFX0RFRklOSVRJT05TW3Byb3BEZWYudHlwZV0pO1xuICAgIH1cblxuICAgIGlmICghKCd2YWx1ZScgaW4gcHJvcERlZikpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6ICdvYmplY3QnLFxuICAgICAgICB2YWx1ZTogcHJvcERlZlxuICAgICAgfTtcbiAgICB9XG5cbiAgICB0eXBlID0gZ2V0VHlwZU9mKHByb3BEZWYudmFsdWUpO1xuICAgIHJldHVybiBPYmplY3QuYXNzaWduKHtcbiAgICAgIHR5cGVcbiAgICB9LCBwcm9wRGVmLCBUWVBFX0RFRklOSVRJT05TW3R5cGVdKTtcbiAgfVxuXG4gIHJldHVybiBPYmplY3QuYXNzaWduKHtcbiAgICB0eXBlLFxuICAgIHZhbHVlOiBwcm9wRGVmXG4gIH0sIFRZUEVfREVGSU5JVElPTlNbdHlwZV0pO1xufVxuXG5mdW5jdGlvbiBnZXRUeXBlT2YodmFsdWUpIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpIHx8IEFycmF5QnVmZmVyLmlzVmlldyh2YWx1ZSkpIHtcbiAgICByZXR1cm4gJ2FycmF5JztcbiAgfVxuXG4gIHJldHVybiB0eXBlb2YgdmFsdWU7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1wcm9wLXR5cGVzLmpzLm1hcCIsImltcG9ydCB7IGFzc2VydCB9IGZyb20gJy4uL3V0aWxzJztcbmltcG9ydCB7IHBhcnNlUHJvcFR5cGVzIH0gZnJvbSAnLi9maWx0ZXJzL3Byb3AtdHlwZXMnO1xuY29uc3QgVkVSVEVYX1NIQURFUiA9ICd2cyc7XG5jb25zdCBGUkFHTUVOVF9TSEFERVIgPSAnZnMnO1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgU2hhZGVyTW9kdWxlIHtcbiAgY29uc3RydWN0b3IoX3JlZikge1xuICAgIGxldCB7XG4gICAgICBuYW1lLFxuICAgICAgdnMsXG4gICAgICBmcyxcbiAgICAgIGRlcGVuZGVuY2llcyA9IFtdLFxuICAgICAgdW5pZm9ybXMsXG4gICAgICBnZXRVbmlmb3JtcyxcbiAgICAgIGRlcHJlY2F0aW9ucyA9IFtdLFxuICAgICAgZGVmaW5lcyA9IHt9LFxuICAgICAgaW5qZWN0ID0ge30sXG4gICAgICB2ZXJ0ZXhTaGFkZXIsXG4gICAgICBmcmFnbWVudFNoYWRlclxuICAgIH0gPSBfcmVmO1xuICAgIGFzc2VydCh0eXBlb2YgbmFtZSA9PT0gJ3N0cmluZycpO1xuICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gICAgdGhpcy52cyA9IHZzIHx8IHZlcnRleFNoYWRlcjtcbiAgICB0aGlzLmZzID0gZnMgfHwgZnJhZ21lbnRTaGFkZXI7XG4gICAgdGhpcy5nZXRNb2R1bGVVbmlmb3JtcyA9IGdldFVuaWZvcm1zO1xuICAgIHRoaXMuZGVwZW5kZW5jaWVzID0gZGVwZW5kZW5jaWVzO1xuICAgIHRoaXMuZGVwcmVjYXRpb25zID0gdGhpcy5fcGFyc2VEZXByZWNhdGlvbkRlZmluaXRpb25zKGRlcHJlY2F0aW9ucyk7XG4gICAgdGhpcy5kZWZpbmVzID0gZGVmaW5lcztcbiAgICB0aGlzLmluamVjdGlvbnMgPSBub3JtYWxpemVJbmplY3Rpb25zKGluamVjdCk7XG5cbiAgICBpZiAodW5pZm9ybXMpIHtcbiAgICAgIHRoaXMudW5pZm9ybXMgPSBwYXJzZVByb3BUeXBlcyh1bmlmb3Jtcyk7XG4gICAgfVxuICB9XG5cbiAgZ2V0TW9kdWxlU291cmNlKHR5cGUpIHtcbiAgICBsZXQgbW9kdWxlU291cmNlO1xuXG4gICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICBjYXNlIFZFUlRFWF9TSEFERVI6XG4gICAgICAgIG1vZHVsZVNvdXJjZSA9IHRoaXMudnMgfHwgJyc7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlIEZSQUdNRU5UX1NIQURFUjpcbiAgICAgICAgbW9kdWxlU291cmNlID0gdGhpcy5mcyB8fCAnJztcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGFzc2VydChmYWxzZSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIFwiI2RlZmluZSBNT0RVTEVfXCIuY29uY2F0KHRoaXMubmFtZS50b1VwcGVyQ2FzZSgpLnJlcGxhY2UoL1teMC05YS16XS9naSwgJ18nKSwgXCJcXG5cIikuY29uY2F0KG1vZHVsZVNvdXJjZSwgXCIvLyBFTkQgTU9EVUxFX1wiKS5jb25jYXQodGhpcy5uYW1lLCBcIlxcblxcblwiKTtcbiAgfVxuXG4gIGdldFVuaWZvcm1zKG9wdHMsIHVuaWZvcm1zKSB7XG4gICAgaWYgKHRoaXMuZ2V0TW9kdWxlVW5pZm9ybXMpIHtcbiAgICAgIHJldHVybiB0aGlzLmdldE1vZHVsZVVuaWZvcm1zKG9wdHMsIHVuaWZvcm1zKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy51bmlmb3Jtcykge1xuICAgICAgcmV0dXJuIHRoaXMuX2RlZmF1bHRHZXRVbmlmb3JtcyhvcHRzKTtcbiAgICB9XG5cbiAgICByZXR1cm4ge307XG4gIH1cblxuICBnZXREZWZpbmVzKCkge1xuICAgIHJldHVybiB0aGlzLmRlZmluZXM7XG4gIH1cblxuICBjaGVja0RlcHJlY2F0aW9ucyhzaGFkZXJTb3VyY2UsIGxvZykge1xuICAgIHRoaXMuZGVwcmVjYXRpb25zLmZvckVhY2goZGVmID0+IHtcbiAgICAgIGlmIChkZWYucmVnZXgudGVzdChzaGFkZXJTb3VyY2UpKSB7XG4gICAgICAgIGlmIChkZWYuZGVwcmVjYXRlZCkge1xuICAgICAgICAgIGxvZy5kZXByZWNhdGVkKGRlZi5vbGQsIGRlZi5uZXcpKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbG9nLnJlbW92ZWQoZGVmLm9sZCwgZGVmLm5ldykoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgX3BhcnNlRGVwcmVjYXRpb25EZWZpbml0aW9ucyhkZXByZWNhdGlvbnMpIHtcbiAgICBkZXByZWNhdGlvbnMuZm9yRWFjaChkZWYgPT4ge1xuICAgICAgc3dpdGNoIChkZWYudHlwZSkge1xuICAgICAgICBjYXNlICdmdW5jdGlvbic6XG4gICAgICAgICAgZGVmLnJlZ2V4ID0gbmV3IFJlZ0V4cChcIlxcXFxiXCIuY29uY2F0KGRlZi5vbGQsIFwiXFxcXChcIikpO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgZGVmLnJlZ2V4ID0gbmV3IFJlZ0V4cChcIlwiLmNvbmNhdChkZWYudHlwZSwgXCIgXCIpLmNvbmNhdChkZWYub2xkLCBcIjtcIikpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBkZXByZWNhdGlvbnM7XG4gIH1cblxuICBfZGVmYXVsdEdldFVuaWZvcm1zKCkge1xuICAgIGxldCBvcHRzID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fTtcbiAgICBjb25zdCB1bmlmb3JtcyA9IHt9O1xuICAgIGNvbnN0IHByb3BUeXBlcyA9IHRoaXMudW5pZm9ybXM7XG5cbiAgICBmb3IgKGNvbnN0IGtleSBpbiBwcm9wVHlwZXMpIHtcbiAgICAgIGNvbnN0IHByb3BEZWYgPSBwcm9wVHlwZXNba2V5XTtcblxuICAgICAgaWYgKGtleSBpbiBvcHRzICYmICFwcm9wRGVmLnByaXZhdGUpIHtcbiAgICAgICAgaWYgKHByb3BEZWYudmFsaWRhdGUpIHtcbiAgICAgICAgICBhc3NlcnQocHJvcERlZi52YWxpZGF0ZShvcHRzW2tleV0sIHByb3BEZWYpLCBcIlwiLmNvbmNhdCh0aGlzLm5hbWUsIFwiOiBpbnZhbGlkIFwiKS5jb25jYXQoa2V5KSk7XG4gICAgICAgIH1cblxuICAgICAgICB1bmlmb3Jtc1trZXldID0gb3B0c1trZXldO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdW5pZm9ybXNba2V5XSA9IHByb3BEZWYudmFsdWU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHVuaWZvcm1zO1xuICB9XG5cbn1cbmV4cG9ydCBmdW5jdGlvbiBub3JtYWxpemVTaGFkZXJNb2R1bGUobW9kdWxlKSB7XG4gIGlmICghbW9kdWxlLm5vcm1hbGl6ZWQpIHtcbiAgICBtb2R1bGUubm9ybWFsaXplZCA9IHRydWU7XG5cbiAgICBpZiAobW9kdWxlLnVuaWZvcm1zICYmICFtb2R1bGUuZ2V0VW5pZm9ybXMpIHtcbiAgICAgIGNvbnN0IHNoYWRlck1vZHVsZSA9IG5ldyBTaGFkZXJNb2R1bGUobW9kdWxlKTtcbiAgICAgIG1vZHVsZS5nZXRVbmlmb3JtcyA9IHNoYWRlck1vZHVsZS5nZXRVbmlmb3Jtcy5iaW5kKHNoYWRlck1vZHVsZSk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG1vZHVsZTtcbn1cblxuZnVuY3Rpb24gbm9ybWFsaXplSW5qZWN0aW9ucyhpbmplY3Rpb25zKSB7XG4gIGNvbnN0IHJlc3VsdCA9IHtcbiAgICB2czoge30sXG4gICAgZnM6IHt9XG4gIH07XG5cbiAgZm9yIChjb25zdCBob29rIGluIGluamVjdGlvbnMpIHtcbiAgICBsZXQgaW5qZWN0aW9uID0gaW5qZWN0aW9uc1tob29rXTtcbiAgICBjb25zdCBzdGFnZSA9IGhvb2suc2xpY2UoMCwgMik7XG5cbiAgICBpZiAodHlwZW9mIGluamVjdGlvbiA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGluamVjdGlvbiA9IHtcbiAgICAgICAgb3JkZXI6IDAsXG4gICAgICAgIGluamVjdGlvblxuICAgICAgfTtcbiAgICB9XG5cbiAgICByZXN1bHRbc3RhZ2VdW2hvb2tdID0gaW5qZWN0aW9uO1xuICB9XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXNoYWRlci1tb2R1bGUuanMubWFwIiwiaW1wb3J0IFNoYWRlck1vZHVsZSBmcm9tICcuL3NoYWRlci1tb2R1bGUnO1xuaW1wb3J0IHsgYXNzZXJ0IH0gZnJvbSAnLi4vdXRpbHMnO1xuZXhwb3J0IGZ1bmN0aW9uIHJlc29sdmVNb2R1bGVzKG1vZHVsZXMpIHtcbiAgcmV0dXJuIGdldFNoYWRlckRlcGVuZGVuY2llcyhpbnN0YW50aWF0ZU1vZHVsZXMobW9kdWxlcykpO1xufVxuXG5mdW5jdGlvbiBnZXRTaGFkZXJEZXBlbmRlbmNpZXMobW9kdWxlcykge1xuICBjb25zdCBtb2R1bGVNYXAgPSB7fTtcbiAgY29uc3QgbW9kdWxlRGVwdGggPSB7fTtcbiAgZ2V0RGVwZW5kZW5jeUdyYXBoKHtcbiAgICBtb2R1bGVzLFxuICAgIGxldmVsOiAwLFxuICAgIG1vZHVsZU1hcCxcbiAgICBtb2R1bGVEZXB0aFxuICB9KTtcbiAgcmV0dXJuIE9iamVjdC5rZXlzKG1vZHVsZURlcHRoKS5zb3J0KChhLCBiKSA9PiBtb2R1bGVEZXB0aFtiXSAtIG1vZHVsZURlcHRoW2FdKS5tYXAobmFtZSA9PiBtb2R1bGVNYXBbbmFtZV0pO1xufVxuXG5mdW5jdGlvbiBnZXREZXBlbmRlbmN5R3JhcGgoX3JlZikge1xuICBsZXQge1xuICAgIG1vZHVsZXMsXG4gICAgbGV2ZWwsXG4gICAgbW9kdWxlTWFwLFxuICAgIG1vZHVsZURlcHRoXG4gIH0gPSBfcmVmO1xuXG4gIGlmIChsZXZlbCA+PSA1KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdQb3NzaWJsZSBsb29wIGluIHNoYWRlciBkZXBlbmRlbmN5IGdyYXBoJyk7XG4gIH1cblxuICBmb3IgKGNvbnN0IG1vZHVsZSBvZiBtb2R1bGVzKSB7XG4gICAgbW9kdWxlTWFwW21vZHVsZS5uYW1lXSA9IG1vZHVsZTtcblxuICAgIGlmIChtb2R1bGVEZXB0aFttb2R1bGUubmFtZV0gPT09IHVuZGVmaW5lZCB8fCBtb2R1bGVEZXB0aFttb2R1bGUubmFtZV0gPCBsZXZlbCkge1xuICAgICAgbW9kdWxlRGVwdGhbbW9kdWxlLm5hbWVdID0gbGV2ZWw7XG4gICAgfVxuICB9XG5cbiAgZm9yIChjb25zdCBtb2R1bGUgb2YgbW9kdWxlcykge1xuICAgIGlmIChtb2R1bGUuZGVwZW5kZW5jaWVzKSB7XG4gICAgICBnZXREZXBlbmRlbmN5R3JhcGgoe1xuICAgICAgICBtb2R1bGVzOiBtb2R1bGUuZGVwZW5kZW5jaWVzLFxuICAgICAgICBsZXZlbDogbGV2ZWwgKyAxLFxuICAgICAgICBtb2R1bGVNYXAsXG4gICAgICAgIG1vZHVsZURlcHRoXG4gICAgICB9KTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gaW5zdGFudGlhdGVNb2R1bGVzKG1vZHVsZXMsIHNlZW4pIHtcbiAgcmV0dXJuIG1vZHVsZXMubWFwKG1vZHVsZSA9PiB7XG4gICAgaWYgKG1vZHVsZSBpbnN0YW5jZW9mIFNoYWRlck1vZHVsZSkge1xuICAgICAgcmV0dXJuIG1vZHVsZTtcbiAgICB9XG5cbiAgICBhc3NlcnQodHlwZW9mIG1vZHVsZSAhPT0gJ3N0cmluZycsIFwiU2hhZGVyIG1vZHVsZSB1c2UgYnkgbmFtZSBpcyBkZXByZWNhdGVkLiBJbXBvcnQgc2hhZGVyIG1vZHVsZSAnXCIuY29uY2F0KG1vZHVsZSwgXCInIGFuZCB1c2UgaXQgZGlyZWN0bHkuXCIpKTtcbiAgICBhc3NlcnQobW9kdWxlLm5hbWUsICdzaGFkZXIgbW9kdWxlIGhhcyBubyBuYW1lJyk7XG4gICAgbW9kdWxlID0gbmV3IFNoYWRlck1vZHVsZShtb2R1bGUpO1xuICAgIG1vZHVsZS5kZXBlbmRlbmNpZXMgPSBpbnN0YW50aWF0ZU1vZHVsZXMobW9kdWxlLmRlcGVuZGVuY2llcyk7XG4gICAgcmV0dXJuIG1vZHVsZTtcbiAgfSk7XG59XG5cbmV4cG9ydCBjb25zdCBURVNUX0VYUE9SVFMgPSB7XG4gIGdldFNoYWRlckRlcGVuZGVuY2llcyxcbiAgZ2V0RGVwZW5kZW5jeUdyYXBoXG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cmVzb2x2ZS1tb2R1bGVzLmpzLm1hcCIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGlzT2xkSUUoKSB7XG4gIGxldCBvcHRzID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fTtcbiAgY29uc3QgbmF2aWdhdG9yID0gdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgPyB3aW5kb3cubmF2aWdhdG9yIHx8IHt9IDoge307XG4gIGNvbnN0IHVzZXJBZ2VudCA9IG9wdHMudXNlckFnZW50IHx8IG5hdmlnYXRvci51c2VyQWdlbnQgfHwgJyc7XG4gIGNvbnN0IGlzTVNJRSA9IHVzZXJBZ2VudC5pbmRleE9mKCdNU0lFICcpICE9PSAtMTtcbiAgY29uc3QgaXNUcmlkZW50ID0gdXNlckFnZW50LmluZGV4T2YoJ1RyaWRlbnQvJykgIT09IC0xO1xuICByZXR1cm4gaXNNU0lFIHx8IGlzVHJpZGVudDtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWlzLW9sZC1pZS5qcy5tYXAiLCJpbXBvcnQgaXNPbGRJRSBmcm9tICcuL2lzLW9sZC1pZSc7XG5pbXBvcnQgYXNzZXJ0IGZyb20gJy4vYXNzZXJ0JztcbmNvbnN0IEdMX1ZFTkRPUiA9IDB4MWYwMDtcbmNvbnN0IEdMX1JFTkRFUkVSID0gMHgxZjAxO1xuY29uc3QgR0xfVkVSU0lPTiA9IDB4MWYwMjtcbmNvbnN0IEdMX1NIQURJTkdfTEFOR1VBR0VfVkVSU0lPTiA9IDB4OGI4YztcbmNvbnN0IFdFQkdMX0ZFQVRVUkVTID0ge1xuICBHTFNMX0ZSQUdfREFUQTogWydXRUJHTF9kcmF3X2J1ZmZlcnMnLCB0cnVlXSxcbiAgR0xTTF9GUkFHX0RFUFRIOiBbJ0VYVF9mcmFnX2RlcHRoJywgdHJ1ZV0sXG4gIEdMU0xfREVSSVZBVElWRVM6IFsnT0VTX3N0YW5kYXJkX2Rlcml2YXRpdmVzJywgdHJ1ZV0sXG4gIEdMU0xfVEVYVFVSRV9MT0Q6IFsnRVhUX3NoYWRlcl90ZXh0dXJlX2xvZCcsIHRydWVdXG59O1xuY29uc3QgRkVBVFVSRVMgPSB7fTtcbk9iamVjdC5rZXlzKFdFQkdMX0ZFQVRVUkVTKS5mb3JFYWNoKGtleSA9PiB7XG4gIEZFQVRVUkVTW2tleV0gPSBrZXk7XG59KTtcbmV4cG9ydCB7IEZFQVRVUkVTIH07XG5cbmZ1bmN0aW9uIGlzV2ViR0wyKGdsKSB7XG4gIGlmICh0eXBlb2YgV2ViR0wyUmVuZGVyaW5nQ29udGV4dCAhPT0gJ3VuZGVmaW5lZCcgJiYgZ2wgaW5zdGFuY2VvZiBXZWJHTDJSZW5kZXJpbmdDb250ZXh0KSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICByZXR1cm4gQm9vbGVhbihnbCAmJiBnbC5fdmVyc2lvbiA9PT0gMik7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRDb250ZXh0SW5mbyhnbCkge1xuICBjb25zdCBpbmZvID0gZ2wuZ2V0RXh0ZW5zaW9uKCdXRUJHTF9kZWJ1Z19yZW5kZXJlcl9pbmZvJyk7XG4gIGNvbnN0IHZlbmRvciA9IGdsLmdldFBhcmFtZXRlcihpbmZvICYmIGluZm8uVU5NQVNLRURfVkVORE9SX1dFQkdMIHx8IEdMX1ZFTkRPUik7XG4gIGNvbnN0IHJlbmRlcmVyID0gZ2wuZ2V0UGFyYW1ldGVyKGluZm8gJiYgaW5mby5VTk1BU0tFRF9SRU5ERVJFUl9XRUJHTCB8fCBHTF9SRU5ERVJFUik7XG4gIGNvbnN0IGdwdVZlbmRvciA9IGlkZW50aWZ5R1BVVmVuZG9yKHZlbmRvciwgcmVuZGVyZXIpO1xuICBjb25zdCBncHVJbmZvID0ge1xuICAgIGdwdVZlbmRvcixcbiAgICB2ZW5kb3IsXG4gICAgcmVuZGVyZXIsXG4gICAgdmVyc2lvbjogZ2wuZ2V0UGFyYW1ldGVyKEdMX1ZFUlNJT04pLFxuICAgIHNoYWRpbmdMYW5ndWFnZVZlcnNpb246IGdsLmdldFBhcmFtZXRlcihHTF9TSEFESU5HX0xBTkdVQUdFX1ZFUlNJT04pXG4gIH07XG4gIHJldHVybiBncHVJbmZvO1xufVxuXG5mdW5jdGlvbiBpZGVudGlmeUdQVVZlbmRvcih2ZW5kb3IsIHJlbmRlcmVyKSB7XG4gIGlmICh2ZW5kb3IubWF0Y2goL05WSURJQS9pKSB8fCByZW5kZXJlci5tYXRjaCgvTlZJRElBL2kpKSB7XG4gICAgcmV0dXJuICdOVklESUEnO1xuICB9XG5cbiAgaWYgKHZlbmRvci5tYXRjaCgvSU5URUwvaSkgfHwgcmVuZGVyZXIubWF0Y2goL0lOVEVML2kpKSB7XG4gICAgcmV0dXJuICdJTlRFTCc7XG4gIH1cblxuICBpZiAodmVuZG9yLm1hdGNoKC9BTUQvaSkgfHwgcmVuZGVyZXIubWF0Y2goL0FNRC9pKSB8fCB2ZW5kb3IubWF0Y2goL0FUSS9pKSB8fCByZW5kZXJlci5tYXRjaCgvQVRJL2kpKSB7XG4gICAgcmV0dXJuICdBTUQnO1xuICB9XG5cbiAgcmV0dXJuICdVTktOT1dOIEdQVSc7XG59XG5cbmNvbnN0IGNvbXBpbGVkR2xzbEV4dGVuc2lvbnMgPSB7fTtcbmV4cG9ydCBmdW5jdGlvbiBjYW5Db21waWxlR0xHU0V4dGVuc2lvbihnbCwgY2FwKSB7XG4gIGxldCBvcHRzID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiB7fTtcbiAgY29uc3QgZmVhdHVyZSA9IFdFQkdMX0ZFQVRVUkVTW2NhcF07XG4gIGFzc2VydChmZWF0dXJlLCBjYXApO1xuXG4gIGlmICghaXNPbGRJRShvcHRzKSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgaWYgKGNhcCBpbiBjb21waWxlZEdsc2xFeHRlbnNpb25zKSB7XG4gICAgcmV0dXJuIGNvbXBpbGVkR2xzbEV4dGVuc2lvbnNbY2FwXTtcbiAgfVxuXG4gIGNvbnN0IGV4dGVuc2lvbk5hbWUgPSBmZWF0dXJlWzBdO1xuICBjb25zdCBiZWhhdmlvciA9IG9wdHMuYmVoYXZpb3IgfHwgJ2VuYWJsZSc7XG4gIGNvbnN0IHNvdXJjZSA9IFwiI2V4dGVuc2lvbiBHTF9cIi5jb25jYXQoZXh0ZW5zaW9uTmFtZSwgXCIgOiBcIikuY29uY2F0KGJlaGF2aW9yLCBcIlxcbnZvaWQgbWFpbih2b2lkKSB7fVwiKTtcbiAgY29uc3Qgc2hhZGVyID0gZ2wuY3JlYXRlU2hhZGVyKDM1NjMzKTtcbiAgZ2wuc2hhZGVyU291cmNlKHNoYWRlciwgc291cmNlKTtcbiAgZ2wuY29tcGlsZVNoYWRlcihzaGFkZXIpO1xuICBjb25zdCBjYW5Db21waWxlID0gZ2wuZ2V0U2hhZGVyUGFyYW1ldGVyKHNoYWRlciwgMzU3MTMpO1xuICBnbC5kZWxldGVTaGFkZXIoc2hhZGVyKTtcbiAgY29tcGlsZWRHbHNsRXh0ZW5zaW9uc1tjYXBdID0gY2FuQ29tcGlsZTtcbiAgcmV0dXJuIGNhbkNvbXBpbGU7XG59XG5cbmZ1bmN0aW9uIGdldEZlYXR1cmUoZ2wsIGNhcCkge1xuICBjb25zdCBmZWF0dXJlID0gV0VCR0xfRkVBVFVSRVNbY2FwXTtcbiAgYXNzZXJ0KGZlYXR1cmUsIGNhcCk7XG4gIGNvbnN0IGV4dGVuc2lvbk5hbWUgPSBpc1dlYkdMMihnbCkgPyBmZWF0dXJlWzFdIHx8IGZlYXR1cmVbMF0gOiBmZWF0dXJlWzBdO1xuICBjb25zdCB2YWx1ZSA9IHR5cGVvZiBleHRlbnNpb25OYW1lID09PSAnc3RyaW5nJyA/IEJvb2xlYW4oZ2wuZ2V0RXh0ZW5zaW9uKGV4dGVuc2lvbk5hbWUpKSA6IGV4dGVuc2lvbk5hbWU7XG4gIGFzc2VydCh2YWx1ZSA9PT0gZmFsc2UgfHwgdmFsdWUgPT09IHRydWUpO1xuICByZXR1cm4gdmFsdWU7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBoYXNGZWF0dXJlcyhnbCwgZmVhdHVyZXMpIHtcbiAgZmVhdHVyZXMgPSBBcnJheS5pc0FycmF5KGZlYXR1cmVzKSA/IGZlYXR1cmVzIDogW2ZlYXR1cmVzXTtcbiAgcmV0dXJuIGZlYXR1cmVzLmV2ZXJ5KGZlYXR1cmUgPT4gZ2V0RmVhdHVyZShnbCwgZmVhdHVyZSkpO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9d2ViZ2wtaW5mby5qcy5tYXAiLCJpbXBvcnQgeyBnZXRDb250ZXh0SW5mbywgaGFzRmVhdHVyZXMsIGNhbkNvbXBpbGVHTEdTRXh0ZW5zaW9uLCBGRUFUVVJFUyB9IGZyb20gJy4uL3V0aWxzL3dlYmdsLWluZm8nO1xuZXhwb3J0IGZ1bmN0aW9uIGdldFBsYXRmb3JtU2hhZGVyRGVmaW5lcyhnbCkge1xuICBjb25zdCBkZWJ1Z0luZm8gPSBnZXRDb250ZXh0SW5mbyhnbCk7XG5cbiAgc3dpdGNoIChkZWJ1Z0luZm8uZ3B1VmVuZG9yLnRvTG93ZXJDYXNlKCkpIHtcbiAgICBjYXNlICdudmlkaWEnOlxuICAgICAgcmV0dXJuIFwiI2RlZmluZSBOVklESUFfR1BVXFxuLy8gTnZpZGlhIG9wdGltaXplcyBhd2F5IHRoZSBjYWxjdWxhdGlvbiBuZWNlc3NhcnkgZm9yIGVtdWxhdGVkIGZwNjRcXG4jZGVmaW5lIExVTUFfRlA2NF9DT0RFX0VMSU1JTkFUSU9OX1dPUktBUk9VTkQgMVxcblwiO1xuXG4gICAgY2FzZSAnaW50ZWwnOlxuICAgICAgcmV0dXJuIFwiI2RlZmluZSBJTlRFTF9HUFVcXG4vLyBJbnRlbCBvcHRpbWl6ZXMgYXdheSB0aGUgY2FsY3VsYXRpb24gbmVjZXNzYXJ5IGZvciBlbXVsYXRlZCBmcDY0XFxuI2RlZmluZSBMVU1BX0ZQNjRfQ09ERV9FTElNSU5BVElPTl9XT1JLQVJPVU5EIDFcXG4vLyBJbnRlbCdzIGJ1aWx0LWluICd0YW4nIGZ1bmN0aW9uIGRvZXNuJ3QgaGF2ZSBhY2NlcHRhYmxlIHByZWNpc2lvblxcbiNkZWZpbmUgTFVNQV9GUDMyX1RBTl9QUkVDSVNJT05fV09SS0FST1VORCAxXFxuLy8gSW50ZWwgR1BVIGRvZXNuJ3QgaGF2ZSBmdWxsIDMyIGJpdHMgcHJlY2lzaW9uIGluIHNhbWUgY2FzZXMsIGNhdXNlcyBvdmVyZmxvd1xcbiNkZWZpbmUgTFVNQV9GUDY0X0hJR0hfQklUU19PVkVSRkxPV19XT1JLQVJPVU5EIDFcXG5cIjtcblxuICAgIGNhc2UgJ2FtZCc6XG4gICAgICByZXR1cm4gXCIjZGVmaW5lIEFNRF9HUFVcXG5cIjtcblxuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gXCIjZGVmaW5lIERFRkFVTFRfR1BVXFxuLy8gUHJldmVudCBkcml2ZXIgZnJvbSBvcHRpbWl6aW5nIGF3YXkgdGhlIGNhbGN1bGF0aW9uIG5lY2Vzc2FyeSBmb3IgZW11bGF0ZWQgZnA2NFxcbiNkZWZpbmUgTFVNQV9GUDY0X0NPREVfRUxJTUlOQVRJT05fV09SS0FST1VORCAxXFxuLy8gSW50ZWwncyBidWlsdC1pbiAndGFuJyBmdW5jdGlvbiBkb2Vzbid0IGhhdmUgYWNjZXB0YWJsZSBwcmVjaXNpb25cXG4jZGVmaW5lIExVTUFfRlAzMl9UQU5fUFJFQ0lTSU9OX1dPUktBUk9VTkQgMVxcbi8vIEludGVsIEdQVSBkb2Vzbid0IGhhdmUgZnVsbCAzMiBiaXRzIHByZWNpc2lvbiBpbiBzYW1lIGNhc2VzLCBjYXVzZXMgb3ZlcmZsb3dcXG4jZGVmaW5lIExVTUFfRlA2NF9ISUdIX0JJVFNfT1ZFUkZMT1dfV09SS0FST1VORCAxXFxuXCI7XG4gIH1cbn1cbmV4cG9ydCBmdW5jdGlvbiBnZXRWZXJzaW9uRGVmaW5lcyhnbCwgZ2xzbFZlcnNpb24sIGlzRnJhZ21lbnQpIHtcbiAgbGV0IHZlcnNpb25EZWZpbmVzID0gXCIjaWYgKF9fVkVSU0lPTl9fID4gMTIwKVxcblxcbiMgZGVmaW5lIEZFQVRVUkVfR0xTTF9ERVJJVkFUSVZFU1xcbiMgZGVmaW5lIEZFQVRVUkVfR0xTTF9EUkFXX0JVRkZFUlNcXG4jIGRlZmluZSBGRUFUVVJFX0dMU0xfRlJBR19ERVBUSFxcbiMgZGVmaW5lIEZFQVRVUkVfR0xTTF9URVhUVVJFX0xPRFxcblxcbi8vIERFUFJFQ0FURUQgRkxBR1MsIHJlbW92ZSBpbiB2OVxcbiMgZGVmaW5lIEZSQUdfREVQVEhcXG4jIGRlZmluZSBERVJJVkFUSVZFU1xcbiMgZGVmaW5lIERSQVdfQlVGRkVSU1xcbiMgZGVmaW5lIFRFWFRVUkVfTE9EXFxuXFxuI2VuZGlmIC8vIF9fVkVSU0lPTlxcblwiO1xuXG4gIGlmIChoYXNGZWF0dXJlcyhnbCwgRkVBVFVSRVMuR0xTTF9GUkFHX0RFUFRIKSkge1xuICAgIHZlcnNpb25EZWZpbmVzICs9IFwiXFxuLy8gRlJBR19ERVBUSCA9PiBnbF9GcmFnRGVwdGggaXMgYXZhaWxhYmxlXFxuI2lmZGVmIEdMX0VYVF9mcmFnX2RlcHRoXFxuI2V4dGVuc2lvbiBHTF9FWFRfZnJhZ19kZXB0aCA6IGVuYWJsZVxcbiMgZGVmaW5lIEZFQVRVUkVfR0xTTF9GUkFHX0RFUFRIXFxuIyBkZWZpbmUgRlJBR19ERVBUSFxcbiMgZGVmaW5lIGdsX0ZyYWdEZXB0aCBnbF9GcmFnRGVwdGhFWFRcXG4jZW5kaWZcXG5cIjtcbiAgfVxuXG4gIGlmIChoYXNGZWF0dXJlcyhnbCwgRkVBVFVSRVMuR0xTTF9ERVJJVkFUSVZFUykgJiYgY2FuQ29tcGlsZUdMR1NFeHRlbnNpb24oZ2wsIEZFQVRVUkVTLkdMU0xfREVSSVZBVElWRVMpKSB7XG4gICAgdmVyc2lvbkRlZmluZXMgKz0gXCJcXG4vLyBERVJJVkFUSVZFUyA9PiBkeGRGLCBkeGRZIGFuZCBmd2lkdGggYXJlIGF2YWlsYWJsZVxcbiNpZmRlZiBHTF9PRVNfc3RhbmRhcmRfZGVyaXZhdGl2ZXNcXG4jZXh0ZW5zaW9uIEdMX09FU19zdGFuZGFyZF9kZXJpdmF0aXZlcyA6IGVuYWJsZVxcbiMgZGVmaW5lIEZFQVRVUkVfR0xTTF9ERVJJVkFUSVZFU1xcbiMgZGVmaW5lIERFUklWQVRJVkVTXFxuI2VuZGlmXFxuXCI7XG4gIH1cblxuICBpZiAoaGFzRmVhdHVyZXMoZ2wsIEZFQVRVUkVTLkdMU0xfRlJBR19EQVRBKSAmJiBjYW5Db21waWxlR0xHU0V4dGVuc2lvbihnbCwgRkVBVFVSRVMuR0xTTF9GUkFHX0RBVEEsIHtcbiAgICBiZWhhdmlvcjogJ3JlcXVpcmUnXG4gIH0pKSB7XG4gICAgdmVyc2lvbkRlZmluZXMgKz0gXCJcXG4vLyBEUkFXX0JVRkZFUlMgPT4gZ2xfRnJhZ0RhdGFbXSBpcyBhdmFpbGFibGVcXG4jaWZkZWYgR0xfRVhUX2RyYXdfYnVmZmVyc1xcbiNleHRlbnNpb24gR0xfRVhUX2RyYXdfYnVmZmVycyA6IHJlcXVpcmVcXG4jZGVmaW5lIEZFQVRVUkVfR0xTTF9EUkFXX0JVRkZFUlNcXG4jZGVmaW5lIERSQVdfQlVGRkVSU1xcbiNlbmRpZlxcblwiO1xuICB9XG5cbiAgaWYgKGhhc0ZlYXR1cmVzKGdsLCBGRUFUVVJFUy5HTFNMX1RFWFRVUkVfTE9EKSkge1xuICAgIHZlcnNpb25EZWZpbmVzICs9IFwiLy8gVEVYVFVSRV9MT0QgPT4gdGV4dHVyZTJETG9kIGV0YyBhcmUgYXZhaWxhYmxlXFxuI2lmZGVmIEdMX0VYVF9zaGFkZXJfdGV4dHVyZV9sb2RcXG4jZXh0ZW5zaW9uIEdMX0VYVF9zaGFkZXJfdGV4dHVyZV9sb2QgOiBlbmFibGVcXG5cXG4jIGRlZmluZSBGRUFUVVJFX0dMU0xfVEVYVFVSRV9MT0RcXG4jIGRlZmluZSBURVhUVVJFX0xPRFxcblxcbiNlbmRpZlxcblwiO1xuICB9XG5cbiAgcmV0dXJuIHZlcnNpb25EZWZpbmVzO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cGxhdGZvcm0tZGVmaW5lcy5qcy5tYXAiLCJmdW5jdGlvbiB0ZXN0VmFyaWFibGUocXVhbGlmaWVyKSB7XG4gIHJldHVybiBuZXcgUmVnRXhwKFwiXFxcXGJcIi5jb25jYXQocXVhbGlmaWVyLCBcIlsgXFxcXHRdKyhcXFxcdytbIFxcXFx0XStcXFxcdysoXFxcXFtcXFxcdytcXFxcXSk/OylcIiksICdnJyk7XG59XG5cbmNvbnN0IEVTMzAwX1JFUExBQ0VNRU5UUyA9IFtbL14oI3ZlcnNpb25bIFxcdF0rKDEwMHwzMDBbIFxcdF0rZXMpKT9bIFxcdF0qXFxuLywgJyN2ZXJzaW9uIDMwMCBlc1xcbiddLCBbL1xcYnRleHR1cmUoMkR8MkRQcm9qfEN1YmUpTG9kKEVYVCk/XFwoL2csICd0ZXh0dXJlTG9kKCddLCBbL1xcYnRleHR1cmUoMkR8MkRQcm9qfEN1YmUpKEVYVCk/XFwoL2csICd0ZXh0dXJlKCddXTtcbmNvbnN0IEVTMzAwX1ZFUlRFWF9SRVBMQUNFTUVOVFMgPSBbLi4uRVMzMDBfUkVQTEFDRU1FTlRTLCBbdGVzdFZhcmlhYmxlKCdhdHRyaWJ1dGUnKSwgJ2luICQxJ10sIFt0ZXN0VmFyaWFibGUoJ3ZhcnlpbmcnKSwgJ291dCAkMSddXTtcbmNvbnN0IEVTMzAwX0ZSQUdNRU5UX1JFUExBQ0VNRU5UUyA9IFsuLi5FUzMwMF9SRVBMQUNFTUVOVFMsIFt0ZXN0VmFyaWFibGUoJ3ZhcnlpbmcnKSwgJ2luICQxJ11dO1xuY29uc3QgRVMxMDBfUkVQTEFDRU1FTlRTID0gW1svXiN2ZXJzaW9uWyBcXHRdKzMwMFsgXFx0XStlcy8sICcjdmVyc2lvbiAxMDAnXSwgWy9cXGJ0ZXh0dXJlKDJEfDJEUHJvanxDdWJlKUxvZFxcKC9nLCAndGV4dHVyZSQxTG9kRVhUKCddLCBbL1xcYnRleHR1cmVcXCgvZywgJ3RleHR1cmUyRCgnXSwgWy9cXGJ0ZXh0dXJlTG9kXFwoL2csICd0ZXh0dXJlMkRMb2RFWFQoJ11dO1xuY29uc3QgRVMxMDBfVkVSVEVYX1JFUExBQ0VNRU5UUyA9IFsuLi5FUzEwMF9SRVBMQUNFTUVOVFMsIFt0ZXN0VmFyaWFibGUoJ2luJyksICdhdHRyaWJ1dGUgJDEnXSwgW3Rlc3RWYXJpYWJsZSgnb3V0JyksICd2YXJ5aW5nICQxJ11dO1xuY29uc3QgRVMxMDBfRlJBR01FTlRfUkVQTEFDRU1FTlRTID0gWy4uLkVTMTAwX1JFUExBQ0VNRU5UUywgW3Rlc3RWYXJpYWJsZSgnaW4nKSwgJ3ZhcnlpbmcgJDEnXV07XG5jb25zdCBFUzEwMF9GUkFHTUVOVF9PVVRQVVRfTkFNRSA9ICdnbF9GcmFnQ29sb3InO1xuY29uc3QgRVMzMDBfRlJBR01FTlRfT1VUUFVUX1JFR0VYID0gL1xcYm91dFsgXFx0XSt2ZWM0WyBcXHRdKyhcXHcrKVsgXFx0XSo7XFxuPy87XG5jb25zdCBSRUdFWF9TVEFSVF9PRl9NQUlOID0gL3ZvaWRcXHMrbWFpblxccypcXChbXildKlxcKVxccypcXHtcXG4/LztcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIHRyYW5zcGlsZVNoYWRlcihzb3VyY2UsIHRhcmdldEdMU0xWZXJzaW9uLCBpc1ZlcnRleCkge1xuICBzd2l0Y2ggKHRhcmdldEdMU0xWZXJzaW9uKSB7XG4gICAgY2FzZSAzMDA6XG4gICAgICByZXR1cm4gaXNWZXJ0ZXggPyBjb252ZXJ0U2hhZGVyKHNvdXJjZSwgRVMzMDBfVkVSVEVYX1JFUExBQ0VNRU5UUykgOiBjb252ZXJ0RnJhZ21lbnRTaGFkZXJUbzMwMChzb3VyY2UpO1xuXG4gICAgY2FzZSAxMDA6XG4gICAgICByZXR1cm4gaXNWZXJ0ZXggPyBjb252ZXJ0U2hhZGVyKHNvdXJjZSwgRVMxMDBfVkVSVEVYX1JFUExBQ0VNRU5UUykgOiBjb252ZXJ0RnJhZ21lbnRTaGFkZXJUbzEwMChzb3VyY2UpO1xuXG4gICAgZGVmYXVsdDpcbiAgICAgIHRocm93IG5ldyBFcnJvcihcInVua25vd24gR0xTTCB2ZXJzaW9uIFwiLmNvbmNhdCh0YXJnZXRHTFNMVmVyc2lvbikpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGNvbnZlcnRTaGFkZXIoc291cmNlLCByZXBsYWNlbWVudHMpIHtcbiAgZm9yIChjb25zdCBbcGF0dGVybiwgcmVwbGFjZW1lbnRdIG9mIHJlcGxhY2VtZW50cykge1xuICAgIHNvdXJjZSA9IHNvdXJjZS5yZXBsYWNlKHBhdHRlcm4sIHJlcGxhY2VtZW50KTtcbiAgfVxuXG4gIHJldHVybiBzb3VyY2U7XG59XG5cbmZ1bmN0aW9uIGNvbnZlcnRGcmFnbWVudFNoYWRlclRvMzAwKHNvdXJjZSkge1xuICBzb3VyY2UgPSBjb252ZXJ0U2hhZGVyKHNvdXJjZSwgRVMzMDBfRlJBR01FTlRfUkVQTEFDRU1FTlRTKTtcbiAgY29uc3Qgb3V0cHV0TWF0Y2ggPSBzb3VyY2UubWF0Y2goRVMzMDBfRlJBR01FTlRfT1VUUFVUX1JFR0VYKTtcblxuICBpZiAob3V0cHV0TWF0Y2gpIHtcbiAgICBjb25zdCBvdXRwdXROYW1lID0gb3V0cHV0TWF0Y2hbMV07XG4gICAgc291cmNlID0gc291cmNlLnJlcGxhY2UobmV3IFJlZ0V4cChcIlxcXFxiXCIuY29uY2F0KEVTMTAwX0ZSQUdNRU5UX09VVFBVVF9OQU1FLCBcIlxcXFxiXCIpLCAnZycpLCBvdXRwdXROYW1lKTtcbiAgfSBlbHNlIHtcbiAgICBjb25zdCBvdXRwdXROYW1lID0gJ2ZyYWdtZW50Q29sb3InO1xuICAgIHNvdXJjZSA9IHNvdXJjZS5yZXBsYWNlKFJFR0VYX1NUQVJUX09GX01BSU4sIG1hdGNoID0+IFwib3V0IHZlYzQgXCIuY29uY2F0KG91dHB1dE5hbWUsIFwiO1xcblwiKS5jb25jYXQobWF0Y2gpKS5yZXBsYWNlKG5ldyBSZWdFeHAoXCJcXFxcYlwiLmNvbmNhdChFUzEwMF9GUkFHTUVOVF9PVVRQVVRfTkFNRSwgXCJcXFxcYlwiKSwgJ2cnKSwgb3V0cHV0TmFtZSk7XG4gIH1cblxuICByZXR1cm4gc291cmNlO1xufVxuXG5mdW5jdGlvbiBjb252ZXJ0RnJhZ21lbnRTaGFkZXJUbzEwMChzb3VyY2UpIHtcbiAgc291cmNlID0gY29udmVydFNoYWRlcihzb3VyY2UsIEVTMTAwX0ZSQUdNRU5UX1JFUExBQ0VNRU5UUyk7XG4gIGNvbnN0IG91dHB1dE1hdGNoID0gc291cmNlLm1hdGNoKEVTMzAwX0ZSQUdNRU5UX09VVFBVVF9SRUdFWCk7XG5cbiAgaWYgKG91dHB1dE1hdGNoKSB7XG4gICAgY29uc3Qgb3V0cHV0TmFtZSA9IG91dHB1dE1hdGNoWzFdO1xuICAgIHNvdXJjZSA9IHNvdXJjZS5yZXBsYWNlKEVTMzAwX0ZSQUdNRU5UX09VVFBVVF9SRUdFWCwgJycpLnJlcGxhY2UobmV3IFJlZ0V4cChcIlxcXFxiXCIuY29uY2F0KG91dHB1dE5hbWUsIFwiXFxcXGJcIiksICdnJyksIEVTMTAwX0ZSQUdNRU5UX09VVFBVVF9OQU1FKTtcbiAgfVxuXG4gIHJldHVybiBzb3VyY2U7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD10cmFuc3BpbGUtc2hhZGVyLmpzLm1hcCIsImltcG9ydCB7IFZFUlRFWF9TSEFERVIsIEZSQUdNRU5UX1NIQURFUiB9IGZyb20gJy4vY29uc3RhbnRzJztcbmltcG9ydCB7IHJlc29sdmVNb2R1bGVzIH0gZnJvbSAnLi9yZXNvbHZlLW1vZHVsZXMnO1xuaW1wb3J0IHsgZ2V0UGxhdGZvcm1TaGFkZXJEZWZpbmVzLCBnZXRWZXJzaW9uRGVmaW5lcyB9IGZyb20gJy4vcGxhdGZvcm0tZGVmaW5lcyc7XG5pbXBvcnQgaW5qZWN0U2hhZGVyLCB7IERFQ0xBUkFUSU9OX0lOSkVDVF9NQVJLRVIgfSBmcm9tICcuL2luamVjdC1zaGFkZXInO1xuaW1wb3J0IHRyYW5zcGlsZVNoYWRlciBmcm9tICcuL3RyYW5zcGlsZS1zaGFkZXInO1xuaW1wb3J0IHsgYXNzZXJ0IH0gZnJvbSAnLi4vdXRpbHMnO1xuY29uc3QgSU5KRUNUX1NIQURFUl9ERUNMQVJBVElPTlMgPSBcIlxcblxcblwiLmNvbmNhdChERUNMQVJBVElPTl9JTkpFQ1RfTUFSS0VSLCBcIlxcblxcblwiKTtcbmNvbnN0IFNIQURFUl9UWVBFID0ge1xuICBbVkVSVEVYX1NIQURFUl06ICd2ZXJ0ZXgnLFxuICBbRlJBR01FTlRfU0hBREVSXTogJ2ZyYWdtZW50J1xufTtcbmNvbnN0IEZSQUdNRU5UX1NIQURFUl9QUk9MT0dVRSA9IFwicHJlY2lzaW9uIGhpZ2hwIGZsb2F0O1xcblxcblwiO1xuZXhwb3J0IGZ1bmN0aW9uIGFzc2VtYmxlU2hhZGVycyhnbCwgb3B0cykge1xuICBjb25zdCB7XG4gICAgdnMsXG4gICAgZnNcbiAgfSA9IG9wdHM7XG4gIGNvbnN0IG1vZHVsZXMgPSByZXNvbHZlTW9kdWxlcyhvcHRzLm1vZHVsZXMgfHwgW10pO1xuICByZXR1cm4ge1xuICAgIGdsLFxuICAgIHZzOiBhc3NlbWJsZVNoYWRlcihnbCwgT2JqZWN0LmFzc2lnbih7fSwgb3B0cywge1xuICAgICAgc291cmNlOiB2cyxcbiAgICAgIHR5cGU6IFZFUlRFWF9TSEFERVIsXG4gICAgICBtb2R1bGVzXG4gICAgfSkpLFxuICAgIGZzOiBhc3NlbWJsZVNoYWRlcihnbCwgT2JqZWN0LmFzc2lnbih7fSwgb3B0cywge1xuICAgICAgc291cmNlOiBmcyxcbiAgICAgIHR5cGU6IEZSQUdNRU5UX1NIQURFUixcbiAgICAgIG1vZHVsZXNcbiAgICB9KSksXG4gICAgZ2V0VW5pZm9ybXM6IGFzc2VtYmxlR2V0VW5pZm9ybXMobW9kdWxlcylcbiAgfTtcbn1cblxuZnVuY3Rpb24gYXNzZW1ibGVTaGFkZXIoZ2wsIF9yZWYpIHtcbiAgbGV0IHtcbiAgICBpZCxcbiAgICBzb3VyY2UsXG4gICAgdHlwZSxcbiAgICBtb2R1bGVzLFxuICAgIGRlZmluZXMgPSB7fSxcbiAgICBob29rRnVuY3Rpb25zID0gW10sXG4gICAgaW5qZWN0ID0ge30sXG4gICAgdHJhbnNwaWxlVG9HTFNMMTAwID0gZmFsc2UsXG4gICAgcHJvbG9ndWUgPSB0cnVlLFxuICAgIGxvZ1xuICB9ID0gX3JlZjtcbiAgYXNzZXJ0KHR5cGVvZiBzb3VyY2UgPT09ICdzdHJpbmcnLCAnc2hhZGVyIHNvdXJjZSBtdXN0IGJlIGEgc3RyaW5nJyk7XG4gIGNvbnN0IGlzVmVydGV4ID0gdHlwZSA9PT0gVkVSVEVYX1NIQURFUjtcbiAgY29uc3Qgc291cmNlTGluZXMgPSBzb3VyY2Uuc3BsaXQoJ1xcbicpO1xuICBsZXQgZ2xzbFZlcnNpb24gPSAxMDA7XG4gIGxldCB2ZXJzaW9uTGluZSA9ICcnO1xuICBsZXQgY29yZVNvdXJjZSA9IHNvdXJjZTtcblxuICBpZiAoc291cmNlTGluZXNbMF0uaW5kZXhPZignI3ZlcnNpb24gJykgPT09IDApIHtcbiAgICBnbHNsVmVyc2lvbiA9IDMwMDtcbiAgICB2ZXJzaW9uTGluZSA9IHNvdXJjZUxpbmVzWzBdO1xuICAgIGNvcmVTb3VyY2UgPSBzb3VyY2VMaW5lcy5zbGljZSgxKS5qb2luKCdcXG4nKTtcbiAgfSBlbHNlIHtcbiAgICB2ZXJzaW9uTGluZSA9IFwiI3ZlcnNpb24gXCIuY29uY2F0KGdsc2xWZXJzaW9uKTtcbiAgfVxuXG4gIGNvbnN0IGFsbERlZmluZXMgPSB7fTtcbiAgbW9kdWxlcy5mb3JFYWNoKG1vZHVsZSA9PiB7XG4gICAgT2JqZWN0LmFzc2lnbihhbGxEZWZpbmVzLCBtb2R1bGUuZ2V0RGVmaW5lcygpKTtcbiAgfSk7XG4gIE9iamVjdC5hc3NpZ24oYWxsRGVmaW5lcywgZGVmaW5lcyk7XG4gIGxldCBhc3NlbWJsZWRTb3VyY2UgPSBwcm9sb2d1ZSA/IFwiXCIuY29uY2F0KHZlcnNpb25MaW5lLCBcIlxcblwiKS5jb25jYXQoZ2V0U2hhZGVyTmFtZSh7XG4gICAgaWQsXG4gICAgc291cmNlLFxuICAgIHR5cGVcbiAgfSksIFwiXFxuXCIpLmNvbmNhdChnZXRTaGFkZXJUeXBlKHtcbiAgICB0eXBlXG4gIH0pLCBcIlxcblwiKS5jb25jYXQoZ2V0UGxhdGZvcm1TaGFkZXJEZWZpbmVzKGdsKSwgXCJcXG5cIikuY29uY2F0KGdldFZlcnNpb25EZWZpbmVzKGdsLCBnbHNsVmVyc2lvbiwgIWlzVmVydGV4KSwgXCJcXG5cIikuY29uY2F0KGdldEFwcGxpY2F0aW9uRGVmaW5lcyhhbGxEZWZpbmVzKSwgXCJcXG5cIikuY29uY2F0KGlzVmVydGV4ID8gJycgOiBGUkFHTUVOVF9TSEFERVJfUFJPTE9HVUUsIFwiXFxuXCIpIDogXCJcIi5jb25jYXQodmVyc2lvbkxpbmUsIFwiXFxuXCIpO1xuICBjb25zdCBob29rRnVuY3Rpb25NYXAgPSBub3JtYWxpemVIb29rRnVuY3Rpb25zKGhvb2tGdW5jdGlvbnMpO1xuICBjb25zdCBob29rSW5qZWN0aW9ucyA9IHt9O1xuICBjb25zdCBkZWNsSW5qZWN0aW9ucyA9IHt9O1xuICBjb25zdCBtYWluSW5qZWN0aW9ucyA9IHt9O1xuXG4gIGZvciAoY29uc3Qga2V5IGluIGluamVjdCkge1xuICAgIGNvbnN0IGluamVjdGlvbiA9IHR5cGVvZiBpbmplY3Rba2V5XSA9PT0gJ3N0cmluZycgPyB7XG4gICAgICBpbmplY3Rpb246IGluamVjdFtrZXldLFxuICAgICAgb3JkZXI6IDBcbiAgICB9IDogaW5qZWN0W2tleV07XG4gICAgY29uc3QgbWF0Y2ggPSBrZXkubWF0Y2goL14odnxmKXM6KCMpPyhbXFx3LV0rKSQvKTtcblxuICAgIGlmIChtYXRjaCkge1xuICAgICAgY29uc3QgaGFzaCA9IG1hdGNoWzJdO1xuICAgICAgY29uc3QgbmFtZSA9IG1hdGNoWzNdO1xuXG4gICAgICBpZiAoaGFzaCkge1xuICAgICAgICBpZiAobmFtZSA9PT0gJ2RlY2wnKSB7XG4gICAgICAgICAgZGVjbEluamVjdGlvbnNba2V5XSA9IFtpbmplY3Rpb25dO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG1haW5JbmplY3Rpb25zW2tleV0gPSBbaW5qZWN0aW9uXTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaG9va0luamVjdGlvbnNba2V5XSA9IFtpbmplY3Rpb25dO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBtYWluSW5qZWN0aW9uc1trZXldID0gW2luamVjdGlvbl07XG4gICAgfVxuICB9XG5cbiAgZm9yIChjb25zdCBtb2R1bGUgb2YgbW9kdWxlcykge1xuICAgIGlmIChsb2cpIHtcbiAgICAgIG1vZHVsZS5jaGVja0RlcHJlY2F0aW9ucyhjb3JlU291cmNlLCBsb2cpO1xuICAgIH1cblxuICAgIGNvbnN0IG1vZHVsZVNvdXJjZSA9IG1vZHVsZS5nZXRNb2R1bGVTb3VyY2UodHlwZSwgZ2xzbFZlcnNpb24pO1xuICAgIGFzc2VtYmxlZFNvdXJjZSArPSBtb2R1bGVTb3VyY2U7XG4gICAgY29uc3QgaW5qZWN0aW9ucyA9IG1vZHVsZS5pbmplY3Rpb25zW3R5cGVdO1xuXG4gICAgZm9yIChjb25zdCBrZXkgaW4gaW5qZWN0aW9ucykge1xuICAgICAgY29uc3QgbWF0Y2ggPSBrZXkubWF0Y2goL14odnxmKXM6IyhbXFx3LV0rKSQvKTtcblxuICAgICAgaWYgKG1hdGNoKSB7XG4gICAgICAgIGNvbnN0IG5hbWUgPSBtYXRjaFsyXTtcbiAgICAgICAgY29uc3QgaW5qZWN0aW9uVHlwZSA9IG5hbWUgPT09ICdkZWNsJyA/IGRlY2xJbmplY3Rpb25zIDogbWFpbkluamVjdGlvbnM7XG4gICAgICAgIGluamVjdGlvblR5cGVba2V5XSA9IGluamVjdGlvblR5cGVba2V5XSB8fCBbXTtcbiAgICAgICAgaW5qZWN0aW9uVHlwZVtrZXldLnB1c2goaW5qZWN0aW9uc1trZXldKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGhvb2tJbmplY3Rpb25zW2tleV0gPSBob29rSW5qZWN0aW9uc1trZXldIHx8IFtdO1xuICAgICAgICBob29rSW5qZWN0aW9uc1trZXldLnB1c2goaW5qZWN0aW9uc1trZXldKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBhc3NlbWJsZWRTb3VyY2UgKz0gSU5KRUNUX1NIQURFUl9ERUNMQVJBVElPTlM7XG4gIGFzc2VtYmxlZFNvdXJjZSA9IGluamVjdFNoYWRlcihhc3NlbWJsZWRTb3VyY2UsIHR5cGUsIGRlY2xJbmplY3Rpb25zKTtcbiAgYXNzZW1ibGVkU291cmNlICs9IGdldEhvb2tGdW5jdGlvbnMoaG9va0Z1bmN0aW9uTWFwW3R5cGVdLCBob29rSW5qZWN0aW9ucyk7XG4gIGFzc2VtYmxlZFNvdXJjZSArPSBjb3JlU291cmNlO1xuICBhc3NlbWJsZWRTb3VyY2UgPSBpbmplY3RTaGFkZXIoYXNzZW1ibGVkU291cmNlLCB0eXBlLCBtYWluSW5qZWN0aW9ucyk7XG4gIGFzc2VtYmxlZFNvdXJjZSA9IHRyYW5zcGlsZVNoYWRlcihhc3NlbWJsZWRTb3VyY2UsIHRyYW5zcGlsZVRvR0xTTDEwMCA/IDEwMCA6IGdsc2xWZXJzaW9uLCBpc1ZlcnRleCk7XG4gIHJldHVybiBhc3NlbWJsZWRTb3VyY2U7XG59XG5cbmZ1bmN0aW9uIGFzc2VtYmxlR2V0VW5pZm9ybXMobW9kdWxlcykge1xuICByZXR1cm4gZnVuY3Rpb24gZ2V0VW5pZm9ybXMob3B0cykge1xuICAgIGNvbnN0IHVuaWZvcm1zID0ge307XG5cbiAgICBmb3IgKGNvbnN0IG1vZHVsZSBvZiBtb2R1bGVzKSB7XG4gICAgICBjb25zdCBtb2R1bGVVbmlmb3JtcyA9IG1vZHVsZS5nZXRVbmlmb3JtcyhvcHRzLCB1bmlmb3Jtcyk7XG4gICAgICBPYmplY3QuYXNzaWduKHVuaWZvcm1zLCBtb2R1bGVVbmlmb3Jtcyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHVuaWZvcm1zO1xuICB9O1xufVxuXG5mdW5jdGlvbiBnZXRTaGFkZXJUeXBlKF9yZWYyKSB7XG4gIGxldCB7XG4gICAgdHlwZVxuICB9ID0gX3JlZjI7XG4gIHJldHVybiBcIlxcbiNkZWZpbmUgU0hBREVSX1RZUEVfXCIuY29uY2F0KFNIQURFUl9UWVBFW3R5cGVdLnRvVXBwZXJDYXNlKCksIFwiXFxuXCIpO1xufVxuXG5mdW5jdGlvbiBnZXRTaGFkZXJOYW1lKF9yZWYzKSB7XG4gIGxldCB7XG4gICAgaWQsXG4gICAgc291cmNlLFxuICAgIHR5cGVcbiAgfSA9IF9yZWYzO1xuICBjb25zdCBpbmplY3RTaGFkZXJOYW1lID0gaWQgJiYgdHlwZW9mIGlkID09PSAnc3RyaW5nJyAmJiBzb3VyY2UuaW5kZXhPZignU0hBREVSX05BTUUnKSA9PT0gLTE7XG4gIHJldHVybiBpbmplY3RTaGFkZXJOYW1lID8gXCJcXG4jZGVmaW5lIFNIQURFUl9OQU1FIFwiLmNvbmNhdChpZCwgXCJfXCIpLmNvbmNhdChTSEFERVJfVFlQRVt0eXBlXSwgXCJcXG5cXG5cIikgOiAnJztcbn1cblxuZnVuY3Rpb24gZ2V0QXBwbGljYXRpb25EZWZpbmVzKCkge1xuICBsZXQgZGVmaW5lcyA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge307XG4gIGxldCBjb3VudCA9IDA7XG4gIGxldCBzb3VyY2VUZXh0ID0gJyc7XG5cbiAgZm9yIChjb25zdCBkZWZpbmUgaW4gZGVmaW5lcykge1xuICAgIGlmIChjb3VudCA9PT0gMCkge1xuICAgICAgc291cmNlVGV4dCArPSAnXFxuLy8gQVBQTElDQVRJT04gREVGSU5FU1xcbic7XG4gICAgfVxuXG4gICAgY291bnQrKztcbiAgICBjb25zdCB2YWx1ZSA9IGRlZmluZXNbZGVmaW5lXTtcblxuICAgIGlmICh2YWx1ZSB8fCBOdW1iZXIuaXNGaW5pdGUodmFsdWUpKSB7XG4gICAgICBzb3VyY2VUZXh0ICs9IFwiI2RlZmluZSBcIi5jb25jYXQoZGVmaW5lLnRvVXBwZXJDYXNlKCksIFwiIFwiKS5jb25jYXQoZGVmaW5lc1tkZWZpbmVdLCBcIlxcblwiKTtcbiAgICB9XG4gIH1cblxuICBpZiAoY291bnQgPT09IDApIHtcbiAgICBzb3VyY2VUZXh0ICs9ICdcXG4nO1xuICB9XG5cbiAgcmV0dXJuIHNvdXJjZVRleHQ7XG59XG5cbmZ1bmN0aW9uIGdldEhvb2tGdW5jdGlvbnMoaG9va0Z1bmN0aW9ucywgaG9va0luamVjdGlvbnMpIHtcbiAgbGV0IHJlc3VsdCA9ICcnO1xuXG4gIGZvciAoY29uc3QgaG9va05hbWUgaW4gaG9va0Z1bmN0aW9ucykge1xuICAgIGNvbnN0IGhvb2tGdW5jdGlvbiA9IGhvb2tGdW5jdGlvbnNbaG9va05hbWVdO1xuICAgIHJlc3VsdCArPSBcInZvaWQgXCIuY29uY2F0KGhvb2tGdW5jdGlvbi5zaWduYXR1cmUsIFwiIHtcXG5cIik7XG5cbiAgICBpZiAoaG9va0Z1bmN0aW9uLmhlYWRlcikge1xuICAgICAgcmVzdWx0ICs9IFwiICBcIi5jb25jYXQoaG9va0Z1bmN0aW9uLmhlYWRlcik7XG4gICAgfVxuXG4gICAgaWYgKGhvb2tJbmplY3Rpb25zW2hvb2tOYW1lXSkge1xuICAgICAgY29uc3QgaW5qZWN0aW9ucyA9IGhvb2tJbmplY3Rpb25zW2hvb2tOYW1lXTtcbiAgICAgIGluamVjdGlvbnMuc29ydCgoYSwgYikgPT4gYS5vcmRlciAtIGIub3JkZXIpO1xuXG4gICAgICBmb3IgKGNvbnN0IGluamVjdGlvbiBvZiBpbmplY3Rpb25zKSB7XG4gICAgICAgIHJlc3VsdCArPSBcIiAgXCIuY29uY2F0KGluamVjdGlvbi5pbmplY3Rpb24sIFwiXFxuXCIpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChob29rRnVuY3Rpb24uZm9vdGVyKSB7XG4gICAgICByZXN1bHQgKz0gXCIgIFwiLmNvbmNhdChob29rRnVuY3Rpb24uZm9vdGVyKTtcbiAgICB9XG5cbiAgICByZXN1bHQgKz0gJ31cXG4nO1xuICB9XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZnVuY3Rpb24gbm9ybWFsaXplSG9va0Z1bmN0aW9ucyhob29rRnVuY3Rpb25zKSB7XG4gIGNvbnN0IHJlc3VsdCA9IHtcbiAgICB2czoge30sXG4gICAgZnM6IHt9XG4gIH07XG4gIGhvb2tGdW5jdGlvbnMuZm9yRWFjaChob29rID0+IHtcbiAgICBsZXQgb3B0cztcblxuICAgIGlmICh0eXBlb2YgaG9vayAhPT0gJ3N0cmluZycpIHtcbiAgICAgIG9wdHMgPSBob29rO1xuICAgICAgaG9vayA9IG9wdHMuaG9vaztcbiAgICB9IGVsc2Uge1xuICAgICAgb3B0cyA9IHt9O1xuICAgIH1cblxuICAgIGhvb2sgPSBob29rLnRyaW0oKTtcbiAgICBjb25zdCBbc3RhZ2UsIHNpZ25hdHVyZV0gPSBob29rLnNwbGl0KCc6Jyk7XG4gICAgY29uc3QgbmFtZSA9IGhvb2sucmVwbGFjZSgvXFwoLisvLCAnJyk7XG4gICAgcmVzdWx0W3N0YWdlXVtuYW1lXSA9IE9iamVjdC5hc3NpZ24ob3B0cywge1xuICAgICAgc2lnbmF0dXJlXG4gICAgfSk7XG4gIH0pO1xuICByZXR1cm4gcmVzdWx0O1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YXNzZW1ibGUtc2hhZGVycy5qcy5tYXAiLCJpbXBvcnQgeyBhc3NlbWJsZVNoYWRlcnMgfSBmcm9tICdAbHVtYS5nbC9zaGFkZXJ0b29scyc7XG5pbXBvcnQgeyBQcm9ncmFtIH0gZnJvbSAnQGx1bWEuZ2wvd2ViZ2wnO1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgUHJvZ3JhbU1hbmFnZXIge1xuICBzdGF0aWMgZ2V0RGVmYXVsdFByb2dyYW1NYW5hZ2VyKGdsKSB7XG4gICAgZ2wubHVtYSA9IGdsLmx1bWEgfHwge307XG4gICAgZ2wubHVtYS5kZWZhdWx0UHJvZ3JhbU1hbmFnZXIgPSBnbC5sdW1hLmRlZmF1bHRQcm9ncmFtTWFuYWdlciB8fCBuZXcgUHJvZ3JhbU1hbmFnZXIoZ2wpO1xuICAgIHJldHVybiBnbC5sdW1hLmRlZmF1bHRQcm9ncmFtTWFuYWdlcjtcbiAgfVxuXG4gIGNvbnN0cnVjdG9yKGdsKSB7XG4gICAgdGhpcy5nbCA9IGdsO1xuICAgIHRoaXMuX3Byb2dyYW1DYWNoZSA9IHt9O1xuICAgIHRoaXMuX2dldFVuaWZvcm1zID0ge307XG4gICAgdGhpcy5fcmVnaXN0ZXJlZE1vZHVsZXMgPSB7fTtcbiAgICB0aGlzLl9ob29rRnVuY3Rpb25zID0gW107XG4gICAgdGhpcy5fZGVmYXVsdE1vZHVsZXMgPSBbXTtcbiAgICB0aGlzLl9oYXNoZXMgPSB7fTtcbiAgICB0aGlzLl9oYXNoQ291bnRlciA9IDA7XG4gICAgdGhpcy5zdGF0ZUhhc2ggPSAwO1xuICAgIHRoaXMuX3VzZUNvdW50cyA9IHt9O1xuICB9XG5cbiAgYWRkRGVmYXVsdE1vZHVsZShtb2R1bGUpIHtcbiAgICBpZiAoIXRoaXMuX2RlZmF1bHRNb2R1bGVzLmZpbmQobSA9PiBtLm5hbWUgPT09IG1vZHVsZS5uYW1lKSkge1xuICAgICAgdGhpcy5fZGVmYXVsdE1vZHVsZXMucHVzaChtb2R1bGUpO1xuICAgIH1cblxuICAgIHRoaXMuc3RhdGVIYXNoKys7XG4gIH1cblxuICByZW1vdmVEZWZhdWx0TW9kdWxlKG1vZHVsZSkge1xuICAgIGNvbnN0IG1vZHVsZU5hbWUgPSB0eXBlb2YgbW9kdWxlID09PSAnc3RyaW5nJyA/IG1vZHVsZSA6IG1vZHVsZS5uYW1lO1xuICAgIHRoaXMuX2RlZmF1bHRNb2R1bGVzID0gdGhpcy5fZGVmYXVsdE1vZHVsZXMuZmlsdGVyKG0gPT4gbS5uYW1lICE9PSBtb2R1bGVOYW1lKTtcbiAgICB0aGlzLnN0YXRlSGFzaCsrO1xuICB9XG5cbiAgYWRkU2hhZGVySG9vayhob29rLCBvcHRzKSB7XG4gICAgaWYgKG9wdHMpIHtcbiAgICAgIGhvb2sgPSBPYmplY3QuYXNzaWduKG9wdHMsIHtcbiAgICAgICAgaG9va1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgdGhpcy5faG9va0Z1bmN0aW9ucy5wdXNoKGhvb2spO1xuXG4gICAgdGhpcy5zdGF0ZUhhc2grKztcbiAgfVxuXG4gIGdldCgpIHtcbiAgICBsZXQgcHJvcHMgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHt9O1xuICAgIGNvbnN0IHtcbiAgICAgIHZzID0gJycsXG4gICAgICBmcyA9ICcnLFxuICAgICAgZGVmaW5lcyA9IHt9LFxuICAgICAgaW5qZWN0ID0ge30sXG4gICAgICB2YXJ5aW5ncyA9IFtdLFxuICAgICAgYnVmZmVyTW9kZSA9IDB4OGM4ZCxcbiAgICAgIHRyYW5zcGlsZVRvR0xTTDEwMCA9IGZhbHNlXG4gICAgfSA9IHByb3BzO1xuXG4gICAgY29uc3QgbW9kdWxlcyA9IHRoaXMuX2dldE1vZHVsZUxpc3QocHJvcHMubW9kdWxlcyk7XG5cbiAgICBjb25zdCB2c0hhc2ggPSB0aGlzLl9nZXRIYXNoKHZzKTtcblxuICAgIGNvbnN0IGZzSGFzaCA9IHRoaXMuX2dldEhhc2goZnMpO1xuXG4gICAgY29uc3QgbW9kdWxlSGFzaGVzID0gbW9kdWxlcy5tYXAobSA9PiB0aGlzLl9nZXRIYXNoKG0ubmFtZSkpLnNvcnQoKTtcbiAgICBjb25zdCB2YXJ5aW5nSGFzaGVzID0gdmFyeWluZ3MubWFwKHYgPT4gdGhpcy5fZ2V0SGFzaCh2KSk7XG4gICAgY29uc3QgZGVmaW5lS2V5cyA9IE9iamVjdC5rZXlzKGRlZmluZXMpLnNvcnQoKTtcbiAgICBjb25zdCBpbmplY3RLZXlzID0gT2JqZWN0LmtleXMoaW5qZWN0KS5zb3J0KCk7XG4gICAgY29uc3QgZGVmaW5lSGFzaGVzID0gW107XG4gICAgY29uc3QgaW5qZWN0SGFzaGVzID0gW107XG5cbiAgICBmb3IgKGNvbnN0IGtleSBvZiBkZWZpbmVLZXlzKSB7XG4gICAgICBkZWZpbmVIYXNoZXMucHVzaCh0aGlzLl9nZXRIYXNoKGtleSkpO1xuICAgICAgZGVmaW5lSGFzaGVzLnB1c2godGhpcy5fZ2V0SGFzaChkZWZpbmVzW2tleV0pKTtcbiAgICB9XG5cbiAgICBmb3IgKGNvbnN0IGtleSBvZiBpbmplY3RLZXlzKSB7XG4gICAgICBpbmplY3RIYXNoZXMucHVzaCh0aGlzLl9nZXRIYXNoKGtleSkpO1xuICAgICAgaW5qZWN0SGFzaGVzLnB1c2godGhpcy5fZ2V0SGFzaChpbmplY3Rba2V5XSkpO1xuICAgIH1cblxuICAgIGNvbnN0IGhhc2ggPSBcIlwiLmNvbmNhdCh2c0hhc2gsIFwiL1wiKS5jb25jYXQoZnNIYXNoLCBcIkRcIikuY29uY2F0KGRlZmluZUhhc2hlcy5qb2luKCcvJyksIFwiTVwiKS5jb25jYXQobW9kdWxlSGFzaGVzLmpvaW4oJy8nKSwgXCJJXCIpLmNvbmNhdChpbmplY3RIYXNoZXMuam9pbignLycpLCBcIlZcIikuY29uY2F0KHZhcnlpbmdIYXNoZXMuam9pbignLycpLCBcIkhcIikuY29uY2F0KHRoaXMuc3RhdGVIYXNoLCBcIkJcIikuY29uY2F0KGJ1ZmZlck1vZGUpLmNvbmNhdCh0cmFuc3BpbGVUb0dMU0wxMDAgPyAnVCcgOiAnJyk7XG5cbiAgICBpZiAoIXRoaXMuX3Byb2dyYW1DYWNoZVtoYXNoXSkge1xuICAgICAgY29uc3QgYXNzZW1ibGVkID0gYXNzZW1ibGVTaGFkZXJzKHRoaXMuZ2wsIHtcbiAgICAgICAgdnMsXG4gICAgICAgIGZzLFxuICAgICAgICBtb2R1bGVzLFxuICAgICAgICBpbmplY3QsXG4gICAgICAgIGRlZmluZXMsXG4gICAgICAgIGhvb2tGdW5jdGlvbnM6IHRoaXMuX2hvb2tGdW5jdGlvbnMsXG4gICAgICAgIHRyYW5zcGlsZVRvR0xTTDEwMFxuICAgICAgfSk7XG4gICAgICB0aGlzLl9wcm9ncmFtQ2FjaGVbaGFzaF0gPSBuZXcgUHJvZ3JhbSh0aGlzLmdsLCB7XG4gICAgICAgIGhhc2gsXG4gICAgICAgIHZzOiBhc3NlbWJsZWQudnMsXG4gICAgICAgIGZzOiBhc3NlbWJsZWQuZnMsXG4gICAgICAgIHZhcnlpbmdzLFxuICAgICAgICBidWZmZXJNb2RlXG4gICAgICB9KTtcblxuICAgICAgdGhpcy5fZ2V0VW5pZm9ybXNbaGFzaF0gPSBhc3NlbWJsZWQuZ2V0VW5pZm9ybXMgfHwgKHggPT4ge30pO1xuXG4gICAgICB0aGlzLl91c2VDb3VudHNbaGFzaF0gPSAwO1xuICAgIH1cblxuICAgIHRoaXMuX3VzZUNvdW50c1toYXNoXSsrO1xuICAgIHJldHVybiB0aGlzLl9wcm9ncmFtQ2FjaGVbaGFzaF07XG4gIH1cblxuICBnZXRVbmlmb3Jtcyhwcm9ncmFtKSB7XG4gICAgcmV0dXJuIHRoaXMuX2dldFVuaWZvcm1zW3Byb2dyYW0uaGFzaF0gfHwgbnVsbDtcbiAgfVxuXG4gIHJlbGVhc2UocHJvZ3JhbSkge1xuICAgIGNvbnN0IGhhc2ggPSBwcm9ncmFtLmhhc2g7XG4gICAgdGhpcy5fdXNlQ291bnRzW2hhc2hdLS07XG5cbiAgICBpZiAodGhpcy5fdXNlQ291bnRzW2hhc2hdID09PSAwKSB7XG4gICAgICB0aGlzLl9wcm9ncmFtQ2FjaGVbaGFzaF0uZGVsZXRlKCk7XG5cbiAgICAgIGRlbGV0ZSB0aGlzLl9wcm9ncmFtQ2FjaGVbaGFzaF07XG4gICAgICBkZWxldGUgdGhpcy5fZ2V0VW5pZm9ybXNbaGFzaF07XG4gICAgICBkZWxldGUgdGhpcy5fdXNlQ291bnRzW2hhc2hdO1xuICAgIH1cbiAgfVxuXG4gIF9nZXRIYXNoKGtleSkge1xuICAgIGlmICh0aGlzLl9oYXNoZXNba2V5XSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aGlzLl9oYXNoZXNba2V5XSA9IHRoaXMuX2hhc2hDb3VudGVyKys7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuX2hhc2hlc1trZXldO1xuICB9XG5cbiAgX2dldE1vZHVsZUxpc3QoKSB7XG4gICAgbGV0IGFwcE1vZHVsZXMgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IFtdO1xuICAgIGNvbnN0IG1vZHVsZXMgPSBuZXcgQXJyYXkodGhpcy5fZGVmYXVsdE1vZHVsZXMubGVuZ3RoICsgYXBwTW9kdWxlcy5sZW5ndGgpO1xuICAgIGNvbnN0IHNlZW4gPSB7fTtcbiAgICBsZXQgY291bnQgPSAwO1xuXG4gICAgZm9yIChsZXQgaSA9IDAsIGxlbiA9IHRoaXMuX2RlZmF1bHRNb2R1bGVzLmxlbmd0aDsgaSA8IGxlbjsgKytpKSB7XG4gICAgICBjb25zdCBtb2R1bGUgPSB0aGlzLl9kZWZhdWx0TW9kdWxlc1tpXTtcbiAgICAgIGNvbnN0IG5hbWUgPSBtb2R1bGUubmFtZTtcbiAgICAgIG1vZHVsZXNbY291bnQrK10gPSBtb2R1bGU7XG4gICAgICBzZWVuW25hbWVdID0gdHJ1ZTtcbiAgICB9XG5cbiAgICBmb3IgKGxldCBpID0gMCwgbGVuID0gYXBwTW9kdWxlcy5sZW5ndGg7IGkgPCBsZW47ICsraSkge1xuICAgICAgY29uc3QgbW9kdWxlID0gYXBwTW9kdWxlc1tpXTtcbiAgICAgIGNvbnN0IG5hbWUgPSBtb2R1bGUubmFtZTtcblxuICAgICAgaWYgKCFzZWVuW25hbWVdKSB7XG4gICAgICAgIG1vZHVsZXNbY291bnQrK10gPSBtb2R1bGU7XG4gICAgICAgIHNlZW5bbmFtZV0gPSB0cnVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIG1vZHVsZXMubGVuZ3RoID0gY291bnQ7XG4gICAgcmV0dXJuIG1vZHVsZXM7XG4gIH1cblxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cHJvZ3JhbS1tYW5hZ2VyLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///43426\n")},19718:function(__unused_webpack_module,__webpack_exports__,__webpack_require__){eval('\n// EXPORTS\n__webpack_require__.d(__webpack_exports__, {\n  "Z": function() { return /* binding */ Transform; }\n});\n\n// EXTERNAL MODULE: ./node_modules/@luma.gl/shadertools/dist/esm/utils/assert.js\nvar assert = __webpack_require__(29047);\n;// CONCATENATED MODULE: ./node_modules/@luma.gl/shadertools/dist/esm/utils/shader-utils.js\n\nconst FS100 = "void main() {gl_FragColor = vec4(0);}";\nconst FS_GLES = "out vec4 transform_output;\\nvoid main() {\\n  transform_output = vec4(0);\\n}";\nconst FS300 = "#version 300 es\\n".concat(FS_GLES);\nfunction getQualifierDetails(line, qualifiers) {\n  qualifiers = Array.isArray(qualifiers) ? qualifiers : [qualifiers];\n  const words = line.replace(/^\\s+/, \'\').split(/\\s+/);\n  const [qualifier, type, definition] = words;\n\n  if (!qualifiers.includes(qualifier) || !type || !definition) {\n    return null;\n  }\n\n  const name = definition.split(\';\')[0];\n  return {\n    qualifier,\n    type,\n    name\n  };\n}\nfunction getPassthroughFS() {\n  let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  const {\n    version = 100,\n    input,\n    inputType,\n    output\n  } = options;\n\n  if (!input) {\n    if (version === 300) {\n      return FS300;\n    } else if (version > 300) {\n      return "#version ".concat(version, "\\n").concat(FS_GLES);\n    }\n\n    return FS100;\n  }\n\n  const outputValue = convertToVec4(input, inputType);\n\n  if (version >= 300) {\n    return "#version ".concat(version, " ").concat(version === 300 ? \'es\' : \'\', "\\nin ").concat(inputType, " ").concat(input, ";\\nout vec4 ").concat(output, ";\\nvoid main() {\\n  ").concat(output, " = ").concat(outputValue, ";\\n}");\n  }\n\n  return "varying ".concat(inputType, " ").concat(input, ";\\nvoid main() {\\n  gl_FragColor = ").concat(outputValue, ";\\n}");\n}\nfunction typeToChannelSuffix(type) {\n  switch (type) {\n    case \'float\':\n      return \'x\';\n\n    case \'vec2\':\n      return \'xy\';\n\n    case \'vec3\':\n      return \'xyz\';\n\n    case \'vec4\':\n      return \'xyzw\';\n\n    default:\n      (0,assert/* default */.Z)(false);\n      return null;\n  }\n}\nfunction typeToChannelCount(type) {\n  switch (type) {\n    case \'float\':\n      return 1;\n\n    case \'vec2\':\n      return 2;\n\n    case \'vec3\':\n      return 3;\n\n    case \'vec4\':\n      return 4;\n\n    default:\n      (0,assert/* default */.Z)(false);\n      return null;\n  }\n}\nfunction convertToVec4(variable, type) {\n  switch (type) {\n    case \'float\':\n      return "vec4(".concat(variable, ", 0.0, 0.0, 1.0)");\n\n    case \'vec2\':\n      return "vec4(".concat(variable, ", 0.0, 1.0)");\n\n    case \'vec3\':\n      return "vec4(".concat(variable, ", 1.0)");\n\n    case \'vec4\':\n      return variable;\n\n    default:\n      (0,assert/* default */.Z)(false);\n      return null;\n  }\n}\n//# sourceMappingURL=shader-utils.js.map\n// EXTERNAL MODULE: ./node_modules/@luma.gl/gltools/dist/esm/index.js + 13 modules\nvar esm = __webpack_require__(1418);\n// EXTERNAL MODULE: ./node_modules/@luma.gl/webgl/dist/esm/classes/buffer.js\nvar classes_buffer = __webpack_require__(53478);\n// EXTERNAL MODULE: ./node_modules/@luma.gl/webgl/dist/esm/classes/transform-feedback.js\nvar transform_feedback = __webpack_require__(51053);\n// EXTERNAL MODULE: ./node_modules/@luma.gl/webgl/dist/esm/utils/assert.js\nvar utils_assert = __webpack_require__(22525);\n;// CONCATENATED MODULE: ./node_modules/@luma.gl/engine/dist/esm/transform/buffer-transform.js\n\n\n\nclass BufferTransform {\n  constructor(gl) {\n    let props = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    this.gl = gl;\n    this.currentIndex = 0;\n    this.feedbackMap = {};\n    this.varyings = null;\n    this.bindings = [];\n    this.resources = {};\n\n    this._initialize(props);\n\n    Object.seal(this);\n  }\n\n  setupResources(opts) {\n    for (const binding of this.bindings) {\n      this._setupTransformFeedback(binding, opts);\n    }\n  }\n\n  updateModelProps() {\n    let props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    const {\n      varyings\n    } = this;\n\n    if (varyings.length > 0) {\n      props = Object.assign({}, props, {\n        varyings\n      });\n    }\n\n    return props;\n  }\n\n  getDrawOptions() {\n    let opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    const binding = this.bindings[this.currentIndex];\n    const {\n      sourceBuffers,\n      transformFeedback\n    } = binding;\n    const attributes = Object.assign({}, sourceBuffers, opts.attributes);\n    return {\n      attributes,\n      transformFeedback\n    };\n  }\n\n  swap() {\n    if (this.feedbackMap) {\n      this.currentIndex = this._getNextIndex();\n      return true;\n    }\n\n    return false;\n  }\n\n  update() {\n    let opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    this._setupBuffers(opts);\n  }\n\n  getBuffer(varyingName) {\n    const {\n      feedbackBuffers\n    } = this.bindings[this.currentIndex];\n    const bufferOrParams = varyingName ? feedbackBuffers[varyingName] : null;\n\n    if (!bufferOrParams) {\n      return null;\n    }\n\n    return bufferOrParams instanceof classes_buffer/* default */.Z ? bufferOrParams : bufferOrParams.buffer;\n  }\n\n  getData() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    const {\n      varyingName\n    } = options;\n    const buffer = this.getBuffer(varyingName);\n\n    if (buffer) {\n      return buffer.getData();\n    }\n\n    return null;\n  }\n\n  delete() {\n    for (const name in this.resources) {\n      this.resources[name].delete();\n    }\n  }\n\n  _initialize() {\n    let props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    this._setupBuffers(props);\n\n    this.varyings = props.varyings || Object.keys(this.bindings[this.currentIndex].feedbackBuffers);\n\n    if (this.varyings.length > 0) {\n      (0,utils_assert/* assert */.h)((0,esm/* isWebGL2 */.D0)(this.gl));\n    }\n  }\n\n  _getFeedbackBuffers(props) {\n    const {\n      sourceBuffers = {}\n    } = props;\n    const feedbackBuffers = {};\n\n    if (this.bindings[this.currentIndex]) {\n      Object.assign(feedbackBuffers, this.bindings[this.currentIndex].feedbackBuffers);\n    }\n\n    if (this.feedbackMap) {\n      for (const sourceName in this.feedbackMap) {\n        const feedbackName = this.feedbackMap[sourceName];\n\n        if (sourceName in sourceBuffers) {\n          feedbackBuffers[feedbackName] = sourceName;\n        }\n      }\n    }\n\n    Object.assign(feedbackBuffers, props.feedbackBuffers);\n\n    for (const bufferName in feedbackBuffers) {\n      const bufferOrRef = feedbackBuffers[bufferName];\n\n      if (typeof bufferOrRef === \'string\') {\n        const sourceBuffer = sourceBuffers[bufferOrRef];\n        const {\n          byteLength,\n          usage,\n          accessor\n        } = sourceBuffer;\n        feedbackBuffers[bufferName] = this._createNewBuffer(bufferName, {\n          byteLength,\n          usage,\n          accessor\n        });\n      }\n    }\n\n    return feedbackBuffers;\n  }\n\n  _setupBuffers() {\n    let props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    const {\n      sourceBuffers = null\n    } = props;\n    Object.assign(this.feedbackMap, props.feedbackMap);\n\n    const feedbackBuffers = this._getFeedbackBuffers(props);\n\n    this._updateBindings({\n      sourceBuffers,\n      feedbackBuffers\n    });\n  }\n\n  _setupTransformFeedback(binding, _ref) {\n    let {\n      model\n    } = _ref;\n    const {\n      program\n    } = model;\n    binding.transformFeedback = new transform_feedback/* default */.Z(this.gl, {\n      program,\n      buffers: binding.feedbackBuffers\n    });\n  }\n\n  _updateBindings(opts) {\n    this.bindings[this.currentIndex] = this._updateBinding(this.bindings[this.currentIndex], opts);\n\n    if (this.feedbackMap) {\n      const {\n        sourceBuffers,\n        feedbackBuffers\n      } = this._swapBuffers(this.bindings[this.currentIndex]);\n\n      const nextIndex = this._getNextIndex();\n\n      this.bindings[nextIndex] = this._updateBinding(this.bindings[nextIndex], {\n        sourceBuffers,\n        feedbackBuffers\n      });\n    }\n  }\n\n  _updateBinding(binding, opts) {\n    if (!binding) {\n      return {\n        sourceBuffers: Object.assign({}, opts.sourceBuffers),\n        feedbackBuffers: Object.assign({}, opts.feedbackBuffers)\n      };\n    }\n\n    Object.assign(binding.sourceBuffers, opts.sourceBuffers);\n    Object.assign(binding.feedbackBuffers, opts.feedbackBuffers);\n\n    if (binding.transformFeedback) {\n      binding.transformFeedback.setBuffers(binding.feedbackBuffers);\n    }\n\n    return binding;\n  }\n\n  _swapBuffers(opts) {\n    if (!this.feedbackMap) {\n      return null;\n    }\n\n    const sourceBuffers = Object.assign({}, opts.sourceBuffers);\n    const feedbackBuffers = Object.assign({}, opts.feedbackBuffers);\n\n    for (const srcName in this.feedbackMap) {\n      const dstName = this.feedbackMap[srcName];\n      sourceBuffers[srcName] = opts.feedbackBuffers[dstName];\n      feedbackBuffers[dstName] = opts.sourceBuffers[srcName];\n      (0,utils_assert/* assert */.h)(feedbackBuffers[dstName] instanceof classes_buffer/* default */.Z);\n    }\n\n    return {\n      sourceBuffers,\n      feedbackBuffers\n    };\n  }\n\n  _createNewBuffer(name, opts) {\n    const buffer = new classes_buffer/* default */.Z(this.gl, opts);\n\n    if (this.resources[name]) {\n      this.resources[name].delete();\n    }\n\n    this.resources[name] = buffer;\n    return buffer;\n  }\n\n  _getNextIndex() {\n    return (this.currentIndex + 1) % 2;\n  }\n\n}\n//# sourceMappingURL=buffer-transform.js.map\n// EXTERNAL MODULE: ./node_modules/@luma.gl/webgl/dist/esm/classes/copy-and-blit.js + 1 modules\nvar copy_and_blit = __webpack_require__(81913);\n// EXTERNAL MODULE: ./node_modules/@luma.gl/webgl/dist/esm/classes/texture-2d.js + 1 modules\nvar texture_2d = __webpack_require__(51621);\n// EXTERNAL MODULE: ./node_modules/@luma.gl/webgl/dist/esm/classes/framebuffer.js\nvar classes_framebuffer = __webpack_require__(53849);\n// EXTERNAL MODULE: ./node_modules/@luma.gl/webgl/dist/esm/webgl-utils/texture-utils.js + 2 modules\nvar texture_utils = __webpack_require__(73462);\n// EXTERNAL MODULE: ./node_modules/@luma.gl/webgl/dist/esm/glsl-utils/get-shader-version.js\nvar get_shader_version = __webpack_require__(27588);\n// EXTERNAL MODULE: ./node_modules/@luma.gl/shadertools/dist/esm/lib/inject-shader.js + 1 modules\nvar inject_shader = __webpack_require__(60827);\n;// CONCATENATED MODULE: ./node_modules/@luma.gl/shadertools/dist/esm/modules/transform/transform.js\nconst vs = "attribute float transform_elementID;\\nvec2 transform_getPixelSizeHalf(vec2 size) {\\n  return vec2(1.) / (2. * size);\\n}\\n\\nvec2 transform_getPixelIndices(vec2 texSize, vec2 pixelSizeHalf) {\\n  float yIndex = floor((transform_elementID / texSize[0]) + pixelSizeHalf[1]);\\n  float xIndex = transform_elementID - (yIndex * texSize[0]);\\n  return vec2(xIndex, yIndex);\\n}\\nvec2 transform_getTexCoord(vec2 size) {\\n  vec2 pixelSizeHalf = transform_getPixelSizeHalf(size);\\n  vec2 indices = transform_getPixelIndices(size, pixelSizeHalf);\\n  vec2 coord = indices / size + pixelSizeHalf;\\n  return coord;\\n}\\nvec2 transform_getPos(vec2 size) {\\n  vec2 texCoord = transform_getTexCoord(size);\\n  vec2 pos = (texCoord * (2.0, 2.0)) - (1., 1.);\\n  return pos;\\n}\\nvec4 transform_getInput(sampler2D texSampler, vec2 size) {\\n  vec2 texCoord = transform_getTexCoord(size);\\n  vec4 textureColor = texture2D(texSampler, texCoord);\\n  return textureColor;\\n}\\n";\nconst transform = {\n  name: \'transform\',\n  vs,\n  fs: null\n};\n//# sourceMappingURL=transform.js.map\n;// CONCATENATED MODULE: ./node_modules/@luma.gl/engine/dist/esm/transform/transform-shader-utils.js\n\n\nconst SAMPLER_UNIFORM_PREFIX = \'transform_uSampler_\';\nconst SIZE_UNIFORM_PREFIX = \'transform_uSize_\';\nconst VS_POS_VARIABLE = \'transform_position\';\nfunction updateForTextures(_ref) {\n  let {\n    vs,\n    sourceTextureMap,\n    targetTextureVarying,\n    targetTexture\n  } = _ref;\n  const texAttributeNames = Object.keys(sourceTextureMap);\n  let sourceCount = texAttributeNames.length;\n  let targetTextureType = null;\n  const samplerTextureMap = {};\n  let updatedVs = vs;\n  let finalInject = {};\n\n  if (sourceCount > 0 || targetTextureVarying) {\n    const vsLines = updatedVs.split(\'\\n\');\n    const updateVsLines = vsLines.slice();\n    vsLines.forEach((line, index, lines) => {\n      if (sourceCount > 0) {\n        const updated = processAttributeDefinition(line, sourceTextureMap);\n\n        if (updated) {\n          const {\n            updatedLine,\n            inject\n          } = updated;\n          updateVsLines[index] = updatedLine;\n          finalInject = (0,inject_shader/* combineInjects */.Lm)([finalInject, inject]);\n          Object.assign(samplerTextureMap, updated.samplerTextureMap);\n          sourceCount--;\n        }\n      }\n\n      if (targetTextureVarying && !targetTextureType) {\n        targetTextureType = getVaryingType(line, targetTextureVarying);\n      }\n    });\n\n    if (targetTextureVarying) {\n      (0,utils_assert/* assert */.h)(targetTexture);\n      const sizeName = "".concat(SIZE_UNIFORM_PREFIX).concat(targetTextureVarying);\n      const uniformDeclaration = "uniform vec2 ".concat(sizeName, ";\\n");\n      const posInstructions = "     vec2 ".concat(VS_POS_VARIABLE, " = transform_getPos(").concat(sizeName, ");\\n     gl_Position = vec4(").concat(VS_POS_VARIABLE, ", 0, 1.);\\n");\n      const inject = {\n        \'vs:#decl\': uniformDeclaration,\n        \'vs:#main-start\': posInstructions\n      };\n      finalInject = (0,inject_shader/* combineInjects */.Lm)([finalInject, inject]);\n    }\n\n    updatedVs = updateVsLines.join(\'\\n\');\n  }\n\n  return {\n    vs: updatedVs,\n    targetTextureType,\n    inject: finalInject,\n    samplerTextureMap\n  };\n}\nfunction getSizeUniforms(_ref2) {\n  let {\n    sourceTextureMap,\n    targetTextureVarying,\n    targetTexture\n  } = _ref2;\n  const uniforms = {};\n  let width;\n  let height;\n\n  if (targetTextureVarying) {\n    ({\n      width,\n      height\n    } = targetTexture);\n    uniforms["".concat(SIZE_UNIFORM_PREFIX).concat(targetTextureVarying)] = [width, height];\n  }\n\n  for (const textureName in sourceTextureMap) {\n    ({\n      width,\n      height\n    } = sourceTextureMap[textureName]);\n    uniforms["".concat(SIZE_UNIFORM_PREFIX).concat(textureName)] = [width, height];\n  }\n\n  return uniforms;\n}\n\nfunction getAttributeDefinition(line) {\n  return getQualifierDetails(line, [\'attribute\', \'in\']);\n}\n\nfunction getSamplerDeclerations(textureName) {\n  const samplerName = "".concat(SAMPLER_UNIFORM_PREFIX).concat(textureName);\n  const sizeName = "".concat(SIZE_UNIFORM_PREFIX).concat(textureName);\n  const uniformDeclerations = "  uniform sampler2D ".concat(samplerName, ";\\n  uniform vec2 ").concat(sizeName, ";");\n  return {\n    samplerName,\n    sizeName,\n    uniformDeclerations\n  };\n}\n\nfunction getVaryingType(line, varying) {\n  const qualaiferDetails = getQualifierDetails(line, [\'varying\', \'out\']);\n\n  if (!qualaiferDetails) {\n    return null;\n  }\n\n  return qualaiferDetails.name === varying ? qualaiferDetails.type : null;\n}\nfunction processAttributeDefinition(line, textureMap) {\n  const samplerTextureMap = {};\n  const attributeData = getAttributeDefinition(line);\n\n  if (!attributeData) {\n    return null;\n  }\n\n  const {\n    type,\n    name\n  } = attributeData;\n\n  if (name && textureMap[name]) {\n    const updatedLine = "// ".concat(line, " => Replaced by Transform with a sampler");\n    const {\n      samplerName,\n      sizeName,\n      uniformDeclerations\n    } = getSamplerDeclerations(name);\n    const channels = typeToChannelSuffix(type);\n    const sampleInstruction = "  ".concat(type, " ").concat(name, " = transform_getInput(").concat(samplerName, ", ").concat(sizeName, ").").concat(channels, ";\\n");\n    samplerTextureMap[samplerName] = name;\n    const inject = {\n      \'vs:#decl\': uniformDeclerations,\n      \'vs:#main-start\': sampleInstruction\n    };\n    return {\n      updatedLine,\n      inject,\n      samplerTextureMap\n    };\n  }\n\n  return null;\n}\n//# sourceMappingURL=transform-shader-utils.js.map\n;// CONCATENATED MODULE: ./node_modules/@luma.gl/engine/dist/esm/transform/texture-transform.js\n\n\n\nconst SRC_TEX_PARAMETER_OVERRIDES = {\n  [10241]: 9728,\n  [10240]: 9728,\n  [10242]: 33071,\n  [10243]: 33071\n};\nconst FS_OUTPUT_VARIABLE = \'transform_output\';\nclass TextureTransform {\n  constructor(gl) {\n    let props = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    this.gl = gl;\n    this.id = this.currentIndex = 0;\n    this._swapTexture = null;\n    this.targetTextureVarying = null;\n    this.targetTextureType = null;\n    this.samplerTextureMap = null;\n    this.bindings = [];\n    this.resources = {};\n\n    this._initialize(props);\n\n    Object.seal(this);\n  }\n\n  updateModelProps() {\n    let props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    const updatedModelProps = this._processVertexShader(props);\n\n    return Object.assign({}, props, updatedModelProps);\n  }\n\n  getDrawOptions() {\n    let opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    const {\n      sourceBuffers,\n      sourceTextures,\n      framebuffer,\n      targetTexture\n    } = this.bindings[this.currentIndex];\n    const attributes = Object.assign({}, sourceBuffers, opts.attributes);\n    const uniforms = Object.assign({}, opts.uniforms);\n    const parameters = Object.assign({}, opts.parameters);\n    let discard = opts.discard;\n\n    if (this.hasSourceTextures || this.hasTargetTexture) {\n      attributes.transform_elementID = this.elementIDBuffer;\n\n      for (const sampler in this.samplerTextureMap) {\n        const textureName = this.samplerTextureMap[sampler];\n        uniforms[sampler] = sourceTextures[textureName];\n      }\n\n      this._setSourceTextureParameters();\n\n      const sizeUniforms = getSizeUniforms({\n        sourceTextureMap: sourceTextures,\n        targetTextureVarying: this.targetTextureVarying,\n        targetTexture\n      });\n      Object.assign(uniforms, sizeUniforms);\n    }\n\n    if (this.hasTargetTexture) {\n      discard = false;\n      parameters.viewport = [0, 0, framebuffer.width, framebuffer.height];\n    }\n\n    return {\n      attributes,\n      framebuffer,\n      uniforms,\n      discard,\n      parameters\n    };\n  }\n\n  swap() {\n    if (this._swapTexture) {\n      this.currentIndex = this._getNextIndex();\n      return true;\n    }\n\n    return false;\n  }\n\n  update() {\n    let opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    this._setupTextures(opts);\n  }\n\n  getTargetTexture() {\n    const {\n      targetTexture\n    } = this.bindings[this.currentIndex];\n    return targetTexture;\n  }\n\n  getData() {\n    let {\n      packed = false\n    } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    const {\n      framebuffer\n    } = this.bindings[this.currentIndex];\n    const pixels = (0,copy_and_blit/* readPixelsToArray */.z6)(framebuffer);\n\n    if (!packed) {\n      return pixels;\n    }\n\n    const ArrayType = pixels.constructor;\n    const channelCount = typeToChannelCount(this.targetTextureType);\n    const packedPixels = new ArrayType(pixels.length * channelCount / 4);\n    let packCount = 0;\n\n    for (let i = 0; i < pixels.length; i += 4) {\n      for (let j = 0; j < channelCount; j++) {\n        packedPixels[packCount++] = pixels[i + j];\n      }\n    }\n\n    return packedPixels;\n  }\n\n  getFramebuffer() {\n    const currentResources = this.bindings[this.currentIndex];\n    return currentResources.framebuffer;\n  }\n\n  delete() {\n    if (this.ownTexture) {\n      this.ownTexture.delete();\n    }\n\n    if (this.elementIDBuffer) {\n      this.elementIDBuffer.delete();\n    }\n  }\n\n  _initialize() {\n    let props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    const {\n      _targetTextureVarying,\n      _swapTexture\n    } = props;\n    this._swapTexture = _swapTexture;\n    this.targetTextureVarying = _targetTextureVarying;\n    this.hasTargetTexture = _targetTextureVarying;\n\n    this._setupTextures(props);\n  }\n\n  _createTargetTexture(props) {\n    const {\n      sourceTextures,\n      textureOrReference\n    } = props;\n\n    if (textureOrReference instanceof texture_2d/* default */.Z) {\n      return textureOrReference;\n    }\n\n    const refTexture = sourceTextures[textureOrReference];\n\n    if (!refTexture) {\n      return null;\n    }\n\n    this._targetRefTexName = textureOrReference;\n    return this._createNewTexture(refTexture);\n  }\n\n  _setupTextures() {\n    let props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    const {\n      sourceBuffers,\n      _sourceTextures = {},\n      _targetTexture\n    } = props;\n\n    const targetTexture = this._createTargetTexture({\n      sourceTextures: _sourceTextures,\n      textureOrReference: _targetTexture\n    });\n\n    this.hasSourceTextures = this.hasSourceTextures || _sourceTextures && Object.keys(_sourceTextures).length > 0;\n\n    this._updateBindings({\n      sourceBuffers,\n      sourceTextures: _sourceTextures,\n      targetTexture\n    });\n\n    if (\'elementCount\' in props) {\n      this._updateElementIDBuffer(props.elementCount);\n    }\n  }\n\n  _updateElementIDBuffer(elementCount) {\n    if (typeof elementCount !== \'number\' || this.elementCount >= elementCount) {\n      return;\n    }\n\n    const elementIds = new Float32Array(elementCount);\n    elementIds.forEach((_, index, array) => {\n      array[index] = index;\n    });\n\n    if (!this.elementIDBuffer) {\n      this.elementIDBuffer = new classes_buffer/* default */.Z(this.gl, {\n        data: elementIds,\n        accessor: {\n          size: 1\n        }\n      });\n    } else {\n      this.elementIDBuffer.setData({\n        data: elementIds\n      });\n    }\n\n    this.elementCount = elementCount;\n  }\n\n  _updateBindings(opts) {\n    this.bindings[this.currentIndex] = this._updateBinding(this.bindings[this.currentIndex], opts);\n\n    if (this._swapTexture) {\n      const {\n        sourceTextures,\n        targetTexture\n      } = this._swapTextures(this.bindings[this.currentIndex]);\n\n      const nextIndex = this._getNextIndex();\n\n      this.bindings[nextIndex] = this._updateBinding(this.bindings[nextIndex], {\n        sourceTextures,\n        targetTexture\n      });\n    }\n  }\n\n  _updateBinding(binding, opts) {\n    const {\n      sourceBuffers,\n      sourceTextures,\n      targetTexture\n    } = opts;\n\n    if (!binding) {\n      binding = {\n        sourceBuffers: {},\n        sourceTextures: {},\n        targetTexture: null\n      };\n    }\n\n    Object.assign(binding.sourceTextures, sourceTextures);\n    Object.assign(binding.sourceBuffers, sourceBuffers);\n\n    if (targetTexture) {\n      binding.targetTexture = targetTexture;\n      const {\n        width,\n        height\n      } = targetTexture;\n      const {\n        framebuffer\n      } = binding;\n\n      if (framebuffer) {\n        framebuffer.update({\n          attachments: {\n            [36064]: targetTexture\n          },\n          resizeAttachments: false\n        });\n        framebuffer.resize({\n          width,\n          height\n        });\n      } else {\n        binding.framebuffer = new classes_framebuffer/* default */.Z(this.gl, {\n          id: "transform-framebuffer",\n          width,\n          height,\n          attachments: {\n            [36064]: targetTexture\n          }\n        });\n      }\n    }\n\n    return binding;\n  }\n\n  _setSourceTextureParameters() {\n    const index = this.currentIndex;\n    const {\n      sourceTextures\n    } = this.bindings[index];\n\n    for (const name in sourceTextures) {\n      sourceTextures[name].setParameters(SRC_TEX_PARAMETER_OVERRIDES);\n    }\n  }\n\n  _swapTextures(opts) {\n    if (!this._swapTexture) {\n      return null;\n    }\n\n    const sourceTextures = Object.assign({}, opts.sourceTextures);\n    sourceTextures[this._swapTexture] = opts.targetTexture;\n    const targetTexture = opts.sourceTextures[this._swapTexture];\n    return {\n      sourceTextures,\n      targetTexture\n    };\n  }\n\n  _createNewTexture(refTexture) {\n    const texture = (0,texture_utils/* cloneTextureFrom */.h)(refTexture, {\n      parameters: {\n        [10241]: 9728,\n        [10240]: 9728,\n        [10242]: 33071,\n        [10243]: 33071\n      },\n      pixelStore: {\n        [37440]: false\n      }\n    });\n\n    if (this.ownTexture) {\n      this.ownTexture.delete();\n    }\n\n    this.ownTexture = texture;\n    return texture;\n  }\n\n  _getNextIndex() {\n    return (this.currentIndex + 1) % 2;\n  }\n\n  _processVertexShader() {\n    let props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    const {\n      sourceTextures,\n      targetTexture\n    } = this.bindings[this.currentIndex];\n    const {\n      vs,\n      uniforms,\n      targetTextureType,\n      inject,\n      samplerTextureMap\n    } = updateForTextures({\n      vs: props.vs,\n      sourceTextureMap: sourceTextures,\n      targetTextureVarying: this.targetTextureVarying,\n      targetTexture\n    });\n    const combinedInject = (0,inject_shader/* combineInjects */.Lm)([props.inject || {}, inject]);\n    this.targetTextureType = targetTextureType;\n    this.samplerTextureMap = samplerTextureMap;\n    const fs = props._fs || getPassthroughFS({\n      version: (0,get_shader_version/* default */.Z)(vs),\n      input: this.targetTextureVarying,\n      inputType: targetTextureType,\n      output: FS_OUTPUT_VARIABLE\n    });\n    const modules = this.hasSourceTextures || this.targetTextureVarying ? [transform].concat(props.modules || []) : props.modules;\n    return {\n      vs,\n      fs,\n      modules,\n      uniforms,\n      inject: combinedInject\n    };\n  }\n\n}\n//# sourceMappingURL=texture-transform.js.map\n// EXTERNAL MODULE: ./node_modules/@luma.gl/webgl/dist/esm/utils/utils.js\nvar utils = __webpack_require__(74538);\n// EXTERNAL MODULE: ./node_modules/@luma.gl/engine/dist/esm/lib/model.js + 1 modules\nvar model = __webpack_require__(80210);\n;// CONCATENATED MODULE: ./node_modules/@luma.gl/engine/dist/esm/transform/transform.js\n\n\n\n\n\n\nclass Transform {\n  static isSupported(gl) {\n    return (0,esm/* isWebGL2 */.D0)(gl);\n  }\n\n  constructor(gl) {\n    let props = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    this.gl = gl;\n    this.model = null;\n    this.elementCount = 0;\n    this.bufferTransform = null;\n    this.textureTransform = null;\n    this.elementIDBuffer = null;\n\n    this._initialize(props);\n\n    Object.seal(this);\n  }\n\n  delete() {\n    const {\n      model,\n      bufferTransform,\n      textureTransform\n    } = this;\n\n    if (model) {\n      model.delete();\n    }\n\n    if (bufferTransform) {\n      bufferTransform.delete();\n    }\n\n    if (textureTransform) {\n      textureTransform.delete();\n    }\n  }\n\n  run() {\n    let opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    const {\n      clearRenderTarget = true\n    } = opts;\n\n    const updatedOpts = this._updateDrawOptions(opts);\n\n    if (clearRenderTarget && updatedOpts.framebuffer) {\n      updatedOpts.framebuffer.clear({\n        color: true\n      });\n    }\n\n    this.model.transform(updatedOpts);\n  }\n\n  swap() {\n    let swapped = false;\n    const resourceTransforms = [this.bufferTransform, this.textureTransform].filter(Boolean);\n\n    for (const resourceTransform of resourceTransforms) {\n      swapped = swapped || resourceTransform.swap();\n    }\n\n    (0,utils_assert/* assert */.h)(swapped, \'Nothing to swap\');\n  }\n\n  getBuffer() {\n    let varyingName = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n    return this.bufferTransform && this.bufferTransform.getBuffer(varyingName);\n  }\n\n  getData() {\n    let opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    const resourceTransforms = [this.bufferTransform, this.textureTransform].filter(Boolean);\n\n    for (const resourceTransform of resourceTransforms) {\n      const data = resourceTransform.getData(opts);\n\n      if (data) {\n        return data;\n      }\n    }\n\n    return null;\n  }\n\n  getFramebuffer() {\n    return this.textureTransform && this.textureTransform.getFramebuffer();\n  }\n\n  update() {\n    let opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    if (\'elementCount\' in opts) {\n      this.model.setVertexCount(opts.elementCount);\n    }\n\n    const resourceTransforms = [this.bufferTransform, this.textureTransform].filter(Boolean);\n\n    for (const resourceTransform of resourceTransforms) {\n      resourceTransform.update(opts);\n    }\n  }\n\n  _initialize() {\n    let props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    const {\n      gl\n    } = this;\n\n    this._buildResourceTransforms(gl, props);\n\n    props = this._updateModelProps(props);\n    this.model = new model/* default */.Z(gl, Object.assign({}, props, {\n      fs: props.fs || getPassthroughFS({\n        version: (0,get_shader_version/* default */.Z)(props.vs)\n      }),\n      id: props.id || \'transform-model\',\n      drawMode: props.drawMode || 0,\n      vertexCount: props.elementCount\n    }));\n    this.bufferTransform && this.bufferTransform.setupResources({\n      model: this.model\n    });\n  }\n\n  _updateModelProps(props) {\n    let updatedProps = Object.assign({}, props);\n    const resourceTransforms = [this.bufferTransform, this.textureTransform].filter(Boolean);\n\n    for (const resourceTransform of resourceTransforms) {\n      updatedProps = resourceTransform.updateModelProps(updatedProps);\n    }\n\n    return updatedProps;\n  }\n\n  _buildResourceTransforms(gl, props) {\n    if (canCreateBufferTransform(props)) {\n      this.bufferTransform = new BufferTransform(gl, props);\n    }\n\n    if (canCreateTextureTransform(props)) {\n      this.textureTransform = new TextureTransform(gl, props);\n    }\n\n    (0,utils_assert/* assert */.h)(this.bufferTransform || this.textureTransform, \'must provide source/feedback buffers or source/target textures\');\n  }\n\n  _updateDrawOptions(opts) {\n    let updatedOpts = Object.assign({}, opts);\n    const resourceTransforms = [this.bufferTransform, this.textureTransform].filter(Boolean);\n\n    for (const resourceTransform of resourceTransforms) {\n      updatedOpts = Object.assign(updatedOpts, resourceTransform.getDrawOptions(updatedOpts));\n    }\n\n    return updatedOpts;\n  }\n\n}\n\nfunction canCreateBufferTransform(props) {\n  if (!(0,utils/* isObjectEmpty */.nK)(props.feedbackBuffers) || !(0,utils/* isObjectEmpty */.nK)(props.feedbackMap) || props.varyings && props.varyings.length > 0) {\n    return true;\n  }\n\n  return false;\n}\n\nfunction canCreateTextureTransform(props) {\n  if (!(0,utils/* isObjectEmpty */.nK)(props._sourceTextures) || props._targetTexture || props._targetTextureVarying) {\n    return true;\n  }\n\n  return false;\n}\n//# sourceMappingURL=transform.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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OztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTs7QUFFTjs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLElBQUksOEJBQU07QUFDVjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07O0FBRU47O0FBRUE7QUFDQSxxQkFBcUIsb0JBQUsscUJBQXFCO0FBQy9DLHNCQUFzQixnQkFBZ0I7QUFDdEMsaUJBQWlCLHFDQUFnQjtBQUNqQyxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQSx1Q0FBdUM7QUFDdkM7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGlDQUFpQyxlQUFlO0FBQ2hEOztBQUVBO0FBQ0Esa0NBQWtDLGdCQUFnQjtBQUNsRDs7QUFFQSxJQUFJLDhCQUFNO0FBQ1Y7O0FBRUE7QUFDQSxzQ0FBc0M7QUFDdEM7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxPQUFPLCtCQUFhLDRCQUE0QiwrQkFBYTtBQUM3RDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxPQUFPLCtCQUFhO0FBQ3BCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdnVlMy13ZWJwYWNrNS8uL25vZGVfbW9kdWxlcy9AbHVtYS5nbC9zaGFkZXJ0b29scy9kaXN0L2VzbS91dGlscy9zaGFkZXItdXRpbHMuanM/YTVkYyIsIndlYnBhY2s6Ly92dWUzLXdlYnBhY2s1Ly4vbm9kZV9tb2R1bGVzL0BsdW1hLmdsL2VuZ2luZS9kaXN0L2VzbS90cmFuc2Zvcm0vYnVmZmVyLXRyYW5zZm9ybS5qcz82YzAyIiwid2VicGFjazovL3Z1ZTMtd2VicGFjazUvLi9ub2RlX21vZHVsZXMvQGx1bWEuZ2wvc2hhZGVydG9vbHMvZGlzdC9lc20vbW9kdWxlcy90cmFuc2Zvcm0vdHJhbnNmb3JtLmpzPzg1ZDAiLCJ3ZWJwYWNrOi8vdnVlMy13ZWJwYWNrNS8uL25vZGVfbW9kdWxlcy9AbHVtYS5nbC9lbmdpbmUvZGlzdC9lc20vdHJhbnNmb3JtL3RyYW5zZm9ybS1zaGFkZXItdXRpbHMuanM/MzNhNSIsIndlYnBhY2s6Ly92dWUzLXdlYnBhY2s1Ly4vbm9kZV9tb2R1bGVzL0BsdW1hLmdsL2VuZ2luZS9kaXN0L2VzbS90cmFuc2Zvcm0vdGV4dHVyZS10cmFuc2Zvcm0uanM/NGExYiIsIndlYnBhY2s6Ly92dWUzLXdlYnBhY2s1Ly4vbm9kZV9tb2R1bGVzL0BsdW1hLmdsL2VuZ2luZS9kaXN0L2VzbS90cmFuc2Zvcm0vdHJhbnNmb3JtLmpzP2ZjMGUiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgYXNzZXJ0IH0gZnJvbSAnLi4vdXRpbHMnO1xuY29uc3QgRlMxMDAgPSBcInZvaWQgbWFpbigpIHtnbF9GcmFnQ29sb3IgPSB2ZWM0KDApO31cIjtcbmNvbnN0IEZTX0dMRVMgPSBcIm91dCB2ZWM0IHRyYW5zZm9ybV9vdXRwdXQ7XFxudm9pZCBtYWluKCkge1xcbiAgdHJhbnNmb3JtX291dHB1dCA9IHZlYzQoMCk7XFxufVwiO1xuY29uc3QgRlMzMDAgPSBcIiN2ZXJzaW9uIDMwMCBlc1xcblwiLmNvbmNhdChGU19HTEVTKTtcbmV4cG9ydCBmdW5jdGlvbiBnZXRRdWFsaWZpZXJEZXRhaWxzKGxpbmUsIHF1YWxpZmllcnMpIHtcbiAgcXVhbGlmaWVycyA9IEFycmF5LmlzQXJyYXkocXVhbGlmaWVycykgPyBxdWFsaWZpZXJzIDogW3F1YWxpZmllcnNdO1xuICBjb25zdCB3b3JkcyA9IGxpbmUucmVwbGFjZSgvXlxccysvLCAnJykuc3BsaXQoL1xccysvKTtcbiAgY29uc3QgW3F1YWxpZmllciwgdHlwZSwgZGVmaW5pdGlvbl0gPSB3b3JkcztcblxuICBpZiAoIXF1YWxpZmllcnMuaW5jbHVkZXMocXVhbGlmaWVyKSB8fCAhdHlwZSB8fCAhZGVmaW5pdGlvbikge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgY29uc3QgbmFtZSA9IGRlZmluaXRpb24uc3BsaXQoJzsnKVswXTtcbiAgcmV0dXJuIHtcbiAgICBxdWFsaWZpZXIsXG4gICAgdHlwZSxcbiAgICBuYW1lXG4gIH07XG59XG5leHBvcnQgZnVuY3Rpb24gZ2V0UGFzc3Rocm91Z2hGUygpIHtcbiAgbGV0IG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHt9O1xuICBjb25zdCB7XG4gICAgdmVyc2lvbiA9IDEwMCxcbiAgICBpbnB1dCxcbiAgICBpbnB1dFR5cGUsXG4gICAgb3V0cHV0XG4gIH0gPSBvcHRpb25zO1xuXG4gIGlmICghaW5wdXQpIHtcbiAgICBpZiAodmVyc2lvbiA9PT0gMzAwKSB7XG4gICAgICByZXR1cm4gRlMzMDA7XG4gICAgfSBlbHNlIGlmICh2ZXJzaW9uID4gMzAwKSB7XG4gICAgICByZXR1cm4gXCIjdmVyc2lvbiBcIi5jb25jYXQodmVyc2lvbiwgXCJcXG5cIikuY29uY2F0KEZTX0dMRVMpO1xuICAgIH1cblxuICAgIHJldHVybiBGUzEwMDtcbiAgfVxuXG4gIGNvbnN0IG91dHB1dFZhbHVlID0gY29udmVydFRvVmVjNChpbnB1dCwgaW5wdXRUeXBlKTtcblxuICBpZiAodmVyc2lvbiA+PSAzMDApIHtcbiAgICByZXR1cm4gXCIjdmVyc2lvbiBcIi5jb25jYXQodmVyc2lvbiwgXCIgXCIpLmNvbmNhdCh2ZXJzaW9uID09PSAzMDAgPyAnZXMnIDogJycsIFwiXFxuaW4gXCIpLmNvbmNhdChpbnB1dFR5cGUsIFwiIFwiKS5jb25jYXQoaW5wdXQsIFwiO1xcbm91dCB2ZWM0IFwiKS5jb25jYXQob3V0cHV0LCBcIjtcXG52b2lkIG1haW4oKSB7XFxuICBcIikuY29uY2F0KG91dHB1dCwgXCIgPSBcIikuY29uY2F0KG91dHB1dFZhbHVlLCBcIjtcXG59XCIpO1xuICB9XG5cbiAgcmV0dXJuIFwidmFyeWluZyBcIi5jb25jYXQoaW5wdXRUeXBlLCBcIiBcIikuY29uY2F0KGlucHV0LCBcIjtcXG52b2lkIG1haW4oKSB7XFxuICBnbF9GcmFnQ29sb3IgPSBcIikuY29uY2F0KG91dHB1dFZhbHVlLCBcIjtcXG59XCIpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIHR5cGVUb0NoYW5uZWxTdWZmaXgodHlwZSkge1xuICBzd2l0Y2ggKHR5cGUpIHtcbiAgICBjYXNlICdmbG9hdCc6XG4gICAgICByZXR1cm4gJ3gnO1xuXG4gICAgY2FzZSAndmVjMic6XG4gICAgICByZXR1cm4gJ3h5JztcblxuICAgIGNhc2UgJ3ZlYzMnOlxuICAgICAgcmV0dXJuICd4eXonO1xuXG4gICAgY2FzZSAndmVjNCc6XG4gICAgICByZXR1cm4gJ3h5encnO1xuXG4gICAgZGVmYXVsdDpcbiAgICAgIGFzc2VydChmYWxzZSk7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgfVxufVxuZXhwb3J0IGZ1bmN0aW9uIHR5cGVUb0NoYW5uZWxDb3VudCh0eXBlKSB7XG4gIHN3aXRjaCAodHlwZSkge1xuICAgIGNhc2UgJ2Zsb2F0JzpcbiAgICAgIHJldHVybiAxO1xuXG4gICAgY2FzZSAndmVjMic6XG4gICAgICByZXR1cm4gMjtcblxuICAgIGNhc2UgJ3ZlYzMnOlxuICAgICAgcmV0dXJuIDM7XG5cbiAgICBjYXNlICd2ZWM0JzpcbiAgICAgIHJldHVybiA0O1xuXG4gICAgZGVmYXVsdDpcbiAgICAgIGFzc2VydChmYWxzZSk7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgfVxufVxuZXhwb3J0IGZ1bmN0aW9uIGNvbnZlcnRUb1ZlYzQodmFyaWFibGUsIHR5cGUpIHtcbiAgc3dpdGNoICh0eXBlKSB7XG4gICAgY2FzZSAnZmxvYXQnOlxuICAgICAgcmV0dXJuIFwidmVjNChcIi5jb25jYXQodmFyaWFibGUsIFwiLCAwLjAsIDAuMCwgMS4wKVwiKTtcblxuICAgIGNhc2UgJ3ZlYzInOlxuICAgICAgcmV0dXJuIFwidmVjNChcIi5jb25jYXQodmFyaWFibGUsIFwiLCAwLjAsIDEuMClcIik7XG5cbiAgICBjYXNlICd2ZWMzJzpcbiAgICAgIHJldHVybiBcInZlYzQoXCIuY29uY2F0KHZhcmlhYmxlLCBcIiwgMS4wKVwiKTtcblxuICAgIGNhc2UgJ3ZlYzQnOlxuICAgICAgcmV0dXJuIHZhcmlhYmxlO1xuXG4gICAgZGVmYXVsdDpcbiAgICAgIGFzc2VydChmYWxzZSk7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c2hhZGVyLXV0aWxzLmpzLm1hcCIsImltcG9ydCB7IGlzV2ViR0wyIH0gZnJvbSAnQGx1bWEuZ2wvZ2x0b29scyc7XG5pbXBvcnQgeyBCdWZmZXIsIFRyYW5zZm9ybUZlZWRiYWNrIH0gZnJvbSAnQGx1bWEuZ2wvd2ViZ2wnO1xuaW1wb3J0IHsgYXNzZXJ0IH0gZnJvbSAnQGx1bWEuZ2wvd2ViZ2wnO1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQnVmZmVyVHJhbnNmb3JtIHtcbiAgY29uc3RydWN0b3IoZ2wpIHtcbiAgICBsZXQgcHJvcHMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuICAgIHRoaXMuZ2wgPSBnbDtcbiAgICB0aGlzLmN1cnJlbnRJbmRleCA9IDA7XG4gICAgdGhpcy5mZWVkYmFja01hcCA9IHt9O1xuICAgIHRoaXMudmFyeWluZ3MgPSBudWxsO1xuICAgIHRoaXMuYmluZGluZ3MgPSBbXTtcbiAgICB0aGlzLnJlc291cmNlcyA9IHt9O1xuXG4gICAgdGhpcy5faW5pdGlhbGl6ZShwcm9wcyk7XG5cbiAgICBPYmplY3Quc2VhbCh0aGlzKTtcbiAgfVxuXG4gIHNldHVwUmVzb3VyY2VzKG9wdHMpIHtcbiAgICBmb3IgKGNvbnN0IGJpbmRpbmcgb2YgdGhpcy5iaW5kaW5ncykge1xuICAgICAgdGhpcy5fc2V0dXBUcmFuc2Zvcm1GZWVkYmFjayhiaW5kaW5nLCBvcHRzKTtcbiAgICB9XG4gIH1cblxuICB1cGRhdGVNb2RlbFByb3BzKCkge1xuICAgIGxldCBwcm9wcyA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge307XG4gICAgY29uc3Qge1xuICAgICAgdmFyeWluZ3NcbiAgICB9ID0gdGhpcztcblxuICAgIGlmICh2YXJ5aW5ncy5sZW5ndGggPiAwKSB7XG4gICAgICBwcm9wcyA9IE9iamVjdC5hc3NpZ24oe30sIHByb3BzLCB7XG4gICAgICAgIHZhcnlpbmdzXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICByZXR1cm4gcHJvcHM7XG4gIH1cblxuICBnZXREcmF3T3B0aW9ucygpIHtcbiAgICBsZXQgb3B0cyA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge307XG4gICAgY29uc3QgYmluZGluZyA9IHRoaXMuYmluZGluZ3NbdGhpcy5jdXJyZW50SW5kZXhdO1xuICAgIGNvbnN0IHtcbiAgICAgIHNvdXJjZUJ1ZmZlcnMsXG4gICAgICB0cmFuc2Zvcm1GZWVkYmFja1xuICAgIH0gPSBiaW5kaW5nO1xuICAgIGNvbnN0IGF0dHJpYnV0ZXMgPSBPYmplY3QuYXNzaWduKHt9LCBzb3VyY2VCdWZmZXJzLCBvcHRzLmF0dHJpYnV0ZXMpO1xuICAgIHJldHVybiB7XG4gICAgICBhdHRyaWJ1dGVzLFxuICAgICAgdHJhbnNmb3JtRmVlZGJhY2tcbiAgICB9O1xuICB9XG5cbiAgc3dhcCgpIHtcbiAgICBpZiAodGhpcy5mZWVkYmFja01hcCkge1xuICAgICAgdGhpcy5jdXJyZW50SW5kZXggPSB0aGlzLl9nZXROZXh0SW5kZXgoKTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHVwZGF0ZSgpIHtcbiAgICBsZXQgb3B0cyA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge307XG5cbiAgICB0aGlzLl9zZXR1cEJ1ZmZlcnMob3B0cyk7XG4gIH1cblxuICBnZXRCdWZmZXIodmFyeWluZ05hbWUpIHtcbiAgICBjb25zdCB7XG4gICAgICBmZWVkYmFja0J1ZmZlcnNcbiAgICB9ID0gdGhpcy5iaW5kaW5nc1t0aGlzLmN1cnJlbnRJbmRleF07XG4gICAgY29uc3QgYnVmZmVyT3JQYXJhbXMgPSB2YXJ5aW5nTmFtZSA/IGZlZWRiYWNrQnVmZmVyc1t2YXJ5aW5nTmFtZV0gOiBudWxsO1xuXG4gICAgaWYgKCFidWZmZXJPclBhcmFtcykge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgcmV0dXJuIGJ1ZmZlck9yUGFyYW1zIGluc3RhbmNlb2YgQnVmZmVyID8gYnVmZmVyT3JQYXJhbXMgOiBidWZmZXJPclBhcmFtcy5idWZmZXI7XG4gIH1cblxuICBnZXREYXRhKCkge1xuICAgIGxldCBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fTtcbiAgICBjb25zdCB7XG4gICAgICB2YXJ5aW5nTmFtZVxuICAgIH0gPSBvcHRpb25zO1xuICAgIGNvbnN0IGJ1ZmZlciA9IHRoaXMuZ2V0QnVmZmVyKHZhcnlpbmdOYW1lKTtcblxuICAgIGlmIChidWZmZXIpIHtcbiAgICAgIHJldHVybiBidWZmZXIuZ2V0RGF0YSgpO1xuICAgIH1cblxuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgZGVsZXRlKCkge1xuICAgIGZvciAoY29uc3QgbmFtZSBpbiB0aGlzLnJlc291cmNlcykge1xuICAgICAgdGhpcy5yZXNvdXJjZXNbbmFtZV0uZGVsZXRlKCk7XG4gICAgfVxuICB9XG5cbiAgX2luaXRpYWxpemUoKSB7XG4gICAgbGV0IHByb3BzID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fTtcblxuICAgIHRoaXMuX3NldHVwQnVmZmVycyhwcm9wcyk7XG5cbiAgICB0aGlzLnZhcnlpbmdzID0gcHJvcHMudmFyeWluZ3MgfHwgT2JqZWN0LmtleXModGhpcy5iaW5kaW5nc1t0aGlzLmN1cnJlbnRJbmRleF0uZmVlZGJhY2tCdWZmZXJzKTtcblxuICAgIGlmICh0aGlzLnZhcnlpbmdzLmxlbmd0aCA+IDApIHtcbiAgICAgIGFzc2VydChpc1dlYkdMMih0aGlzLmdsKSk7XG4gICAgfVxuICB9XG5cbiAgX2dldEZlZWRiYWNrQnVmZmVycyhwcm9wcykge1xuICAgIGNvbnN0IHtcbiAgICAgIHNvdXJjZUJ1ZmZlcnMgPSB7fVxuICAgIH0gPSBwcm9wcztcbiAgICBjb25zdCBmZWVkYmFja0J1ZmZlcnMgPSB7fTtcblxuICAgIGlmICh0aGlzLmJpbmRpbmdzW3RoaXMuY3VycmVudEluZGV4XSkge1xuICAgICAgT2JqZWN0LmFzc2lnbihmZWVkYmFja0J1ZmZlcnMsIHRoaXMuYmluZGluZ3NbdGhpcy5jdXJyZW50SW5kZXhdLmZlZWRiYWNrQnVmZmVycyk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuZmVlZGJhY2tNYXApIHtcbiAgICAgIGZvciAoY29uc3Qgc291cmNlTmFtZSBpbiB0aGlzLmZlZWRiYWNrTWFwKSB7XG4gICAgICAgIGNvbnN0IGZlZWRiYWNrTmFtZSA9IHRoaXMuZmVlZGJhY2tNYXBbc291cmNlTmFtZV07XG5cbiAgICAgICAgaWYgKHNvdXJjZU5hbWUgaW4gc291cmNlQnVmZmVycykge1xuICAgICAgICAgIGZlZWRiYWNrQnVmZmVyc1tmZWVkYmFja05hbWVdID0gc291cmNlTmFtZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIE9iamVjdC5hc3NpZ24oZmVlZGJhY2tCdWZmZXJzLCBwcm9wcy5mZWVkYmFja0J1ZmZlcnMpO1xuXG4gICAgZm9yIChjb25zdCBidWZmZXJOYW1lIGluIGZlZWRiYWNrQnVmZmVycykge1xuICAgICAgY29uc3QgYnVmZmVyT3JSZWYgPSBmZWVkYmFja0J1ZmZlcnNbYnVmZmVyTmFtZV07XG5cbiAgICAgIGlmICh0eXBlb2YgYnVmZmVyT3JSZWYgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIGNvbnN0IHNvdXJjZUJ1ZmZlciA9IHNvdXJjZUJ1ZmZlcnNbYnVmZmVyT3JSZWZdO1xuICAgICAgICBjb25zdCB7XG4gICAgICAgICAgYnl0ZUxlbmd0aCxcbiAgICAgICAgICB1c2FnZSxcbiAgICAgICAgICBhY2Nlc3NvclxuICAgICAgICB9ID0gc291cmNlQnVmZmVyO1xuICAgICAgICBmZWVkYmFja0J1ZmZlcnNbYnVmZmVyTmFtZV0gPSB0aGlzLl9jcmVhdGVOZXdCdWZmZXIoYnVmZmVyTmFtZSwge1xuICAgICAgICAgIGJ5dGVMZW5ndGgsXG4gICAgICAgICAgdXNhZ2UsXG4gICAgICAgICAgYWNjZXNzb3JcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGZlZWRiYWNrQnVmZmVycztcbiAgfVxuXG4gIF9zZXR1cEJ1ZmZlcnMoKSB7XG4gICAgbGV0IHByb3BzID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fTtcbiAgICBjb25zdCB7XG4gICAgICBzb3VyY2VCdWZmZXJzID0gbnVsbFxuICAgIH0gPSBwcm9wcztcbiAgICBPYmplY3QuYXNzaWduKHRoaXMuZmVlZGJhY2tNYXAsIHByb3BzLmZlZWRiYWNrTWFwKTtcblxuICAgIGNvbnN0IGZlZWRiYWNrQnVmZmVycyA9IHRoaXMuX2dldEZlZWRiYWNrQnVmZmVycyhwcm9wcyk7XG5cbiAgICB0aGlzLl91cGRhdGVCaW5kaW5ncyh7XG4gICAgICBzb3VyY2VCdWZmZXJzLFxuICAgICAgZmVlZGJhY2tCdWZmZXJzXG4gICAgfSk7XG4gIH1cblxuICBfc2V0dXBUcmFuc2Zvcm1GZWVkYmFjayhiaW5kaW5nLCBfcmVmKSB7XG4gICAgbGV0IHtcbiAgICAgIG1vZGVsXG4gICAgfSA9IF9yZWY7XG4gICAgY29uc3Qge1xuICAgICAgcHJvZ3JhbVxuICAgIH0gPSBtb2RlbDtcbiAgICBiaW5kaW5nLnRyYW5zZm9ybUZlZWRiYWNrID0gbmV3IFRyYW5zZm9ybUZlZWRiYWNrKHRoaXMuZ2wsIHtcbiAgICAgIHByb2dyYW0sXG4gICAgICBidWZmZXJzOiBiaW5kaW5nLmZlZWRiYWNrQnVmZmVyc1xuICAgIH0pO1xuICB9XG5cbiAgX3VwZGF0ZUJpbmRpbmdzKG9wdHMpIHtcbiAgICB0aGlzLmJpbmRpbmdzW3RoaXMuY3VycmVudEluZGV4XSA9IHRoaXMuX3VwZGF0ZUJpbmRpbmcodGhpcy5iaW5kaW5nc1t0aGlzLmN1cnJlbnRJbmRleF0sIG9wdHMpO1xuXG4gICAgaWYgKHRoaXMuZmVlZGJhY2tNYXApIHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgc291cmNlQnVmZmVycyxcbiAgICAgICAgZmVlZGJhY2tCdWZmZXJzXG4gICAgICB9ID0gdGhpcy5fc3dhcEJ1ZmZlcnModGhpcy5iaW5kaW5nc1t0aGlzLmN1cnJlbnRJbmRleF0pO1xuXG4gICAgICBjb25zdCBuZXh0SW5kZXggPSB0aGlzLl9nZXROZXh0SW5kZXgoKTtcblxuICAgICAgdGhpcy5iaW5kaW5nc1tuZXh0SW5kZXhdID0gdGhpcy5fdXBkYXRlQmluZGluZyh0aGlzLmJpbmRpbmdzW25leHRJbmRleF0sIHtcbiAgICAgICAgc291cmNlQnVmZmVycyxcbiAgICAgICAgZmVlZGJhY2tCdWZmZXJzXG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICBfdXBkYXRlQmluZGluZyhiaW5kaW5nLCBvcHRzKSB7XG4gICAgaWYgKCFiaW5kaW5nKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBzb3VyY2VCdWZmZXJzOiBPYmplY3QuYXNzaWduKHt9LCBvcHRzLnNvdXJjZUJ1ZmZlcnMpLFxuICAgICAgICBmZWVkYmFja0J1ZmZlcnM6IE9iamVjdC5hc3NpZ24oe30sIG9wdHMuZmVlZGJhY2tCdWZmZXJzKVxuICAgICAgfTtcbiAgICB9XG5cbiAgICBPYmplY3QuYXNzaWduKGJpbmRpbmcuc291cmNlQnVmZmVycywgb3B0cy5zb3VyY2VCdWZmZXJzKTtcbiAgICBPYmplY3QuYXNzaWduKGJpbmRpbmcuZmVlZGJhY2tCdWZmZXJzLCBvcHRzLmZlZWRiYWNrQnVmZmVycyk7XG5cbiAgICBpZiAoYmluZGluZy50cmFuc2Zvcm1GZWVkYmFjaykge1xuICAgICAgYmluZGluZy50cmFuc2Zvcm1GZWVkYmFjay5zZXRCdWZmZXJzKGJpbmRpbmcuZmVlZGJhY2tCdWZmZXJzKTtcbiAgICB9XG5cbiAgICByZXR1cm4gYmluZGluZztcbiAgfVxuXG4gIF9zd2FwQnVmZmVycyhvcHRzKSB7XG4gICAgaWYgKCF0aGlzLmZlZWRiYWNrTWFwKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICBjb25zdCBzb3VyY2VCdWZmZXJzID0gT2JqZWN0LmFzc2lnbih7fSwgb3B0cy5zb3VyY2VCdWZmZXJzKTtcbiAgICBjb25zdCBmZWVkYmFja0J1ZmZlcnMgPSBPYmplY3QuYXNzaWduKHt9LCBvcHRzLmZlZWRiYWNrQnVmZmVycyk7XG5cbiAgICBmb3IgKGNvbnN0IHNyY05hbWUgaW4gdGhpcy5mZWVkYmFja01hcCkge1xuICAgICAgY29uc3QgZHN0TmFtZSA9IHRoaXMuZmVlZGJhY2tNYXBbc3JjTmFtZV07XG4gICAgICBzb3VyY2VCdWZmZXJzW3NyY05hbWVdID0gb3B0cy5mZWVkYmFja0J1ZmZlcnNbZHN0TmFtZV07XG4gICAgICBmZWVkYmFja0J1ZmZlcnNbZHN0TmFtZV0gPSBvcHRzLnNvdXJjZUJ1ZmZlcnNbc3JjTmFtZV07XG4gICAgICBhc3NlcnQoZmVlZGJhY2tCdWZmZXJzW2RzdE5hbWVdIGluc3RhbmNlb2YgQnVmZmVyKTtcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgc291cmNlQnVmZmVycyxcbiAgICAgIGZlZWRiYWNrQnVmZmVyc1xuICAgIH07XG4gIH1cblxuICBfY3JlYXRlTmV3QnVmZmVyKG5hbWUsIG9wdHMpIHtcbiAgICBjb25zdCBidWZmZXIgPSBuZXcgQnVmZmVyKHRoaXMuZ2wsIG9wdHMpO1xuXG4gICAgaWYgKHRoaXMucmVzb3VyY2VzW25hbWVdKSB7XG4gICAgICB0aGlzLnJlc291cmNlc1tuYW1lXS5kZWxldGUoKTtcbiAgICB9XG5cbiAgICB0aGlzLnJlc291cmNlc1tuYW1lXSA9IGJ1ZmZlcjtcbiAgICByZXR1cm4gYnVmZmVyO1xuICB9XG5cbiAgX2dldE5leHRJbmRleCgpIHtcbiAgICByZXR1cm4gKHRoaXMuY3VycmVudEluZGV4ICsgMSkgJSAyO1xuICB9XG5cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWJ1ZmZlci10cmFuc2Zvcm0uanMubWFwIiwiY29uc3QgdnMgPSBcImF0dHJpYnV0ZSBmbG9hdCB0cmFuc2Zvcm1fZWxlbWVudElEO1xcbnZlYzIgdHJhbnNmb3JtX2dldFBpeGVsU2l6ZUhhbGYodmVjMiBzaXplKSB7XFxuICByZXR1cm4gdmVjMigxLikgLyAoMi4gKiBzaXplKTtcXG59XFxuXFxudmVjMiB0cmFuc2Zvcm1fZ2V0UGl4ZWxJbmRpY2VzKHZlYzIgdGV4U2l6ZSwgdmVjMiBwaXhlbFNpemVIYWxmKSB7XFxuICBmbG9hdCB5SW5kZXggPSBmbG9vcigodHJhbnNmb3JtX2VsZW1lbnRJRCAvIHRleFNpemVbMF0pICsgcGl4ZWxTaXplSGFsZlsxXSk7XFxuICBmbG9hdCB4SW5kZXggPSB0cmFuc2Zvcm1fZWxlbWVudElEIC0gKHlJbmRleCAqIHRleFNpemVbMF0pO1xcbiAgcmV0dXJuIHZlYzIoeEluZGV4LCB5SW5kZXgpO1xcbn1cXG52ZWMyIHRyYW5zZm9ybV9nZXRUZXhDb29yZCh2ZWMyIHNpemUpIHtcXG4gIHZlYzIgcGl4ZWxTaXplSGFsZiA9IHRyYW5zZm9ybV9nZXRQaXhlbFNpemVIYWxmKHNpemUpO1xcbiAgdmVjMiBpbmRpY2VzID0gdHJhbnNmb3JtX2dldFBpeGVsSW5kaWNlcyhzaXplLCBwaXhlbFNpemVIYWxmKTtcXG4gIHZlYzIgY29vcmQgPSBpbmRpY2VzIC8gc2l6ZSArIHBpeGVsU2l6ZUhhbGY7XFxuICByZXR1cm4gY29vcmQ7XFxufVxcbnZlYzIgdHJhbnNmb3JtX2dldFBvcyh2ZWMyIHNpemUpIHtcXG4gIHZlYzIgdGV4Q29vcmQgPSB0cmFuc2Zvcm1fZ2V0VGV4Q29vcmQoc2l6ZSk7XFxuICB2ZWMyIHBvcyA9ICh0ZXhDb29yZCAqICgyLjAsIDIuMCkpIC0gKDEuLCAxLik7XFxuICByZXR1cm4gcG9zO1xcbn1cXG52ZWM0IHRyYW5zZm9ybV9nZXRJbnB1dChzYW1wbGVyMkQgdGV4U2FtcGxlciwgdmVjMiBzaXplKSB7XFxuICB2ZWMyIHRleENvb3JkID0gdHJhbnNmb3JtX2dldFRleENvb3JkKHNpemUpO1xcbiAgdmVjNCB0ZXh0dXJlQ29sb3IgPSB0ZXh0dXJlMkQodGV4U2FtcGxlciwgdGV4Q29vcmQpO1xcbiAgcmV0dXJuIHRleHR1cmVDb2xvcjtcXG59XFxuXCI7XG5leHBvcnQgY29uc3QgdHJhbnNmb3JtID0ge1xuICBuYW1lOiAndHJhbnNmb3JtJyxcbiAgdnMsXG4gIGZzOiBudWxsXG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dHJhbnNmb3JtLmpzLm1hcCIsImltcG9ydCB7IGFzc2VydCB9IGZyb20gJ0BsdW1hLmdsL3dlYmdsJztcbmltcG9ydCB7IGNvbWJpbmVJbmplY3RzLCBnZXRRdWFsaWZpZXJEZXRhaWxzLCB0eXBlVG9DaGFubmVsU3VmZml4IH0gZnJvbSAnQGx1bWEuZ2wvc2hhZGVydG9vbHMnO1xuY29uc3QgU0FNUExFUl9VTklGT1JNX1BSRUZJWCA9ICd0cmFuc2Zvcm1fdVNhbXBsZXJfJztcbmNvbnN0IFNJWkVfVU5JRk9STV9QUkVGSVggPSAndHJhbnNmb3JtX3VTaXplXyc7XG5jb25zdCBWU19QT1NfVkFSSUFCTEUgPSAndHJhbnNmb3JtX3Bvc2l0aW9uJztcbmV4cG9ydCBmdW5jdGlvbiB1cGRhdGVGb3JUZXh0dXJlcyhfcmVmKSB7XG4gIGxldCB7XG4gICAgdnMsXG4gICAgc291cmNlVGV4dHVyZU1hcCxcbiAgICB0YXJnZXRUZXh0dXJlVmFyeWluZyxcbiAgICB0YXJnZXRUZXh0dXJlXG4gIH0gPSBfcmVmO1xuICBjb25zdCB0ZXhBdHRyaWJ1dGVOYW1lcyA9IE9iamVjdC5rZXlzKHNvdXJjZVRleHR1cmVNYXApO1xuICBsZXQgc291cmNlQ291bnQgPSB0ZXhBdHRyaWJ1dGVOYW1lcy5sZW5ndGg7XG4gIGxldCB0YXJnZXRUZXh0dXJlVHlwZSA9IG51bGw7XG4gIGNvbnN0IHNhbXBsZXJUZXh0dXJlTWFwID0ge307XG4gIGxldCB1cGRhdGVkVnMgPSB2cztcbiAgbGV0IGZpbmFsSW5qZWN0ID0ge307XG5cbiAgaWYgKHNvdXJjZUNvdW50ID4gMCB8fCB0YXJnZXRUZXh0dXJlVmFyeWluZykge1xuICAgIGNvbnN0IHZzTGluZXMgPSB1cGRhdGVkVnMuc3BsaXQoJ1xcbicpO1xuICAgIGNvbnN0IHVwZGF0ZVZzTGluZXMgPSB2c0xpbmVzLnNsaWNlKCk7XG4gICAgdnNMaW5lcy5mb3JFYWNoKChsaW5lLCBpbmRleCwgbGluZXMpID0+IHtcbiAgICAgIGlmIChzb3VyY2VDb3VudCA+IDApIHtcbiAgICAgICAgY29uc3QgdXBkYXRlZCA9IHByb2Nlc3NBdHRyaWJ1dGVEZWZpbml0aW9uKGxpbmUsIHNvdXJjZVRleHR1cmVNYXApO1xuXG4gICAgICAgIGlmICh1cGRhdGVkKSB7XG4gICAgICAgICAgY29uc3Qge1xuICAgICAgICAgICAgdXBkYXRlZExpbmUsXG4gICAgICAgICAgICBpbmplY3RcbiAgICAgICAgICB9ID0gdXBkYXRlZDtcbiAgICAgICAgICB1cGRhdGVWc0xpbmVzW2luZGV4XSA9IHVwZGF0ZWRMaW5lO1xuICAgICAgICAgIGZpbmFsSW5qZWN0ID0gY29tYmluZUluamVjdHMoW2ZpbmFsSW5qZWN0LCBpbmplY3RdKTtcbiAgICAgICAgICBPYmplY3QuYXNzaWduKHNhbXBsZXJUZXh0dXJlTWFwLCB1cGRhdGVkLnNhbXBsZXJUZXh0dXJlTWFwKTtcbiAgICAgICAgICBzb3VyY2VDb3VudC0tO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmICh0YXJnZXRUZXh0dXJlVmFyeWluZyAmJiAhdGFyZ2V0VGV4dHVyZVR5cGUpIHtcbiAgICAgICAgdGFyZ2V0VGV4dHVyZVR5cGUgPSBnZXRWYXJ5aW5nVHlwZShsaW5lLCB0YXJnZXRUZXh0dXJlVmFyeWluZyk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBpZiAodGFyZ2V0VGV4dHVyZVZhcnlpbmcpIHtcbiAgICAgIGFzc2VydCh0YXJnZXRUZXh0dXJlKTtcbiAgICAgIGNvbnN0IHNpemVOYW1lID0gXCJcIi5jb25jYXQoU0laRV9VTklGT1JNX1BSRUZJWCkuY29uY2F0KHRhcmdldFRleHR1cmVWYXJ5aW5nKTtcbiAgICAgIGNvbnN0IHVuaWZvcm1EZWNsYXJhdGlvbiA9IFwidW5pZm9ybSB2ZWMyIFwiLmNvbmNhdChzaXplTmFtZSwgXCI7XFxuXCIpO1xuICAgICAgY29uc3QgcG9zSW5zdHJ1Y3Rpb25zID0gXCIgICAgIHZlYzIgXCIuY29uY2F0KFZTX1BPU19WQVJJQUJMRSwgXCIgPSB0cmFuc2Zvcm1fZ2V0UG9zKFwiKS5jb25jYXQoc2l6ZU5hbWUsIFwiKTtcXG4gICAgIGdsX1Bvc2l0aW9uID0gdmVjNChcIikuY29uY2F0KFZTX1BPU19WQVJJQUJMRSwgXCIsIDAsIDEuKTtcXG5cIik7XG4gICAgICBjb25zdCBpbmplY3QgPSB7XG4gICAgICAgICd2czojZGVjbCc6IHVuaWZvcm1EZWNsYXJhdGlvbixcbiAgICAgICAgJ3ZzOiNtYWluLXN0YXJ0JzogcG9zSW5zdHJ1Y3Rpb25zXG4gICAgICB9O1xuICAgICAgZmluYWxJbmplY3QgPSBjb21iaW5lSW5qZWN0cyhbZmluYWxJbmplY3QsIGluamVjdF0pO1xuICAgIH1cblxuICAgIHVwZGF0ZWRWcyA9IHVwZGF0ZVZzTGluZXMuam9pbignXFxuJyk7XG4gIH1cblxuICByZXR1cm4ge1xuICAgIHZzOiB1cGRhdGVkVnMsXG4gICAgdGFyZ2V0VGV4dHVyZVR5cGUsXG4gICAgaW5qZWN0OiBmaW5hbEluamVjdCxcbiAgICBzYW1wbGVyVGV4dHVyZU1hcFxuICB9O1xufVxuZXhwb3J0IGZ1bmN0aW9uIGdldFNpemVVbmlmb3JtcyhfcmVmMikge1xuICBsZXQge1xuICAgIHNvdXJjZVRleHR1cmVNYXAsXG4gICAgdGFyZ2V0VGV4dHVyZVZhcnlpbmcsXG4gICAgdGFyZ2V0VGV4dHVyZVxuICB9ID0gX3JlZjI7XG4gIGNvbnN0IHVuaWZvcm1zID0ge307XG4gIGxldCB3aWR0aDtcbiAgbGV0IGhlaWdodDtcblxuICBpZiAodGFyZ2V0VGV4dHVyZVZhcnlpbmcpIHtcbiAgICAoe1xuICAgICAgd2lkdGgsXG4gICAgICBoZWlnaHRcbiAgICB9ID0gdGFyZ2V0VGV4dHVyZSk7XG4gICAgdW5pZm9ybXNbXCJcIi5jb25jYXQoU0laRV9VTklGT1JNX1BSRUZJWCkuY29uY2F0KHRhcmdldFRleHR1cmVWYXJ5aW5nKV0gPSBbd2lkdGgsIGhlaWdodF07XG4gIH1cblxuICBmb3IgKGNvbnN0IHRleHR1cmVOYW1lIGluIHNvdXJjZVRleHR1cmVNYXApIHtcbiAgICAoe1xuICAgICAgd2lkdGgsXG4gICAgICBoZWlnaHRcbiAgICB9ID0gc291cmNlVGV4dHVyZU1hcFt0ZXh0dXJlTmFtZV0pO1xuICAgIHVuaWZvcm1zW1wiXCIuY29uY2F0KFNJWkVfVU5JRk9STV9QUkVGSVgpLmNvbmNhdCh0ZXh0dXJlTmFtZSldID0gW3dpZHRoLCBoZWlnaHRdO1xuICB9XG5cbiAgcmV0dXJuIHVuaWZvcm1zO1xufVxuXG5mdW5jdGlvbiBnZXRBdHRyaWJ1dGVEZWZpbml0aW9uKGxpbmUpIHtcbiAgcmV0dXJuIGdldFF1YWxpZmllckRldGFpbHMobGluZSwgWydhdHRyaWJ1dGUnLCAnaW4nXSk7XG59XG5cbmZ1bmN0aW9uIGdldFNhbXBsZXJEZWNsZXJhdGlvbnModGV4dHVyZU5hbWUpIHtcbiAgY29uc3Qgc2FtcGxlck5hbWUgPSBcIlwiLmNvbmNhdChTQU1QTEVSX1VOSUZPUk1fUFJFRklYKS5jb25jYXQodGV4dHVyZU5hbWUpO1xuICBjb25zdCBzaXplTmFtZSA9IFwiXCIuY29uY2F0KFNJWkVfVU5JRk9STV9QUkVGSVgpLmNvbmNhdCh0ZXh0dXJlTmFtZSk7XG4gIGNvbnN0IHVuaWZvcm1EZWNsZXJhdGlvbnMgPSBcIiAgdW5pZm9ybSBzYW1wbGVyMkQgXCIuY29uY2F0KHNhbXBsZXJOYW1lLCBcIjtcXG4gIHVuaWZvcm0gdmVjMiBcIikuY29uY2F0KHNpemVOYW1lLCBcIjtcIik7XG4gIHJldHVybiB7XG4gICAgc2FtcGxlck5hbWUsXG4gICAgc2l6ZU5hbWUsXG4gICAgdW5pZm9ybURlY2xlcmF0aW9uc1xuICB9O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0VmFyeWluZ1R5cGUobGluZSwgdmFyeWluZykge1xuICBjb25zdCBxdWFsYWlmZXJEZXRhaWxzID0gZ2V0UXVhbGlmaWVyRGV0YWlscyhsaW5lLCBbJ3ZhcnlpbmcnLCAnb3V0J10pO1xuXG4gIGlmICghcXVhbGFpZmVyRGV0YWlscykge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgcmV0dXJuIHF1YWxhaWZlckRldGFpbHMubmFtZSA9PT0gdmFyeWluZyA/IHF1YWxhaWZlckRldGFpbHMudHlwZSA6IG51bGw7XG59XG5leHBvcnQgZnVuY3Rpb24gcHJvY2Vzc0F0dHJpYnV0ZURlZmluaXRpb24obGluZSwgdGV4dHVyZU1hcCkge1xuICBjb25zdCBzYW1wbGVyVGV4dHVyZU1hcCA9IHt9O1xuICBjb25zdCBhdHRyaWJ1dGVEYXRhID0gZ2V0QXR0cmlidXRlRGVmaW5pdGlvbihsaW5lKTtcblxuICBpZiAoIWF0dHJpYnV0ZURhdGEpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIGNvbnN0IHtcbiAgICB0eXBlLFxuICAgIG5hbWVcbiAgfSA9IGF0dHJpYnV0ZURhdGE7XG5cbiAgaWYgKG5hbWUgJiYgdGV4dHVyZU1hcFtuYW1lXSkge1xuICAgIGNvbnN0IHVwZGF0ZWRMaW5lID0gXCIvLyBcIi5jb25jYXQobGluZSwgXCIgPT4gUmVwbGFjZWQgYnkgVHJhbnNmb3JtIHdpdGggYSBzYW1wbGVyXCIpO1xuICAgIGNvbnN0IHtcbiAgICAgIHNhbXBsZXJOYW1lLFxuICAgICAgc2l6ZU5hbWUsXG4gICAgICB1bmlmb3JtRGVjbGVyYXRpb25zXG4gICAgfSA9IGdldFNhbXBsZXJEZWNsZXJhdGlvbnMobmFtZSk7XG4gICAgY29uc3QgY2hhbm5lbHMgPSB0eXBlVG9DaGFubmVsU3VmZml4KHR5cGUpO1xuICAgIGNvbnN0IHNhbXBsZUluc3RydWN0aW9uID0gXCIgIFwiLmNvbmNhdCh0eXBlLCBcIiBcIikuY29uY2F0KG5hbWUsIFwiID0gdHJhbnNmb3JtX2dldElucHV0KFwiKS5jb25jYXQoc2FtcGxlck5hbWUsIFwiLCBcIikuY29uY2F0KHNpemVOYW1lLCBcIikuXCIpLmNvbmNhdChjaGFubmVscywgXCI7XFxuXCIpO1xuICAgIHNhbXBsZXJUZXh0dXJlTWFwW3NhbXBsZXJOYW1lXSA9IG5hbWU7XG4gICAgY29uc3QgaW5qZWN0ID0ge1xuICAgICAgJ3ZzOiNkZWNsJzogdW5pZm9ybURlY2xlcmF0aW9ucyxcbiAgICAgICd2czojbWFpbi1zdGFydCc6IHNhbXBsZUluc3RydWN0aW9uXG4gICAgfTtcbiAgICByZXR1cm4ge1xuICAgICAgdXBkYXRlZExpbmUsXG4gICAgICBpbmplY3QsXG4gICAgICBzYW1wbGVyVGV4dHVyZU1hcFxuICAgIH07XG4gIH1cblxuICByZXR1cm4gbnVsbDtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXRyYW5zZm9ybS1zaGFkZXItdXRpbHMuanMubWFwIiwiaW1wb3J0IHsgY2xvbmVUZXh0dXJlRnJvbSwgcmVhZFBpeGVsc1RvQXJyYXksIGdldFNoYWRlclZlcnNpb24sIEJ1ZmZlciwgVGV4dHVyZTJELCBGcmFtZWJ1ZmZlciB9IGZyb20gJ0BsdW1hLmdsL3dlYmdsJztcbmltcG9ydCB7IF90cmFuc2Zvcm0gYXMgdHJhbnNmb3JtTW9kdWxlLCBnZXRQYXNzdGhyb3VnaEZTLCB0eXBlVG9DaGFubmVsQ291bnQsIGNvbWJpbmVJbmplY3RzIH0gZnJvbSAnQGx1bWEuZ2wvc2hhZGVydG9vbHMnO1xuaW1wb3J0IHsgdXBkYXRlRm9yVGV4dHVyZXMsIGdldFNpemVVbmlmb3JtcyB9IGZyb20gJy4vdHJhbnNmb3JtLXNoYWRlci11dGlscyc7XG5jb25zdCBTUkNfVEVYX1BBUkFNRVRFUl9PVkVSUklERVMgPSB7XG4gIFsxMDI0MV06IDk3MjgsXG4gIFsxMDI0MF06IDk3MjgsXG4gIFsxMDI0Ml06IDMzMDcxLFxuICBbMTAyNDNdOiAzMzA3MVxufTtcbmNvbnN0IEZTX09VVFBVVF9WQVJJQUJMRSA9ICd0cmFuc2Zvcm1fb3V0cHV0JztcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFRleHR1cmVUcmFuc2Zvcm0ge1xuICBjb25zdHJ1Y3RvcihnbCkge1xuICAgIGxldCBwcm9wcyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG4gICAgdGhpcy5nbCA9IGdsO1xuICAgIHRoaXMuaWQgPSB0aGlzLmN1cnJlbnRJbmRleCA9IDA7XG4gICAgdGhpcy5fc3dhcFRleHR1cmUgPSBudWxsO1xuICAgIHRoaXMudGFyZ2V0VGV4dHVyZVZhcnlpbmcgPSBudWxsO1xuICAgIHRoaXMudGFyZ2V0VGV4dHVyZVR5cGUgPSBudWxsO1xuICAgIHRoaXMuc2FtcGxlclRleHR1cmVNYXAgPSBudWxsO1xuICAgIHRoaXMuYmluZGluZ3MgPSBbXTtcbiAgICB0aGlzLnJlc291cmNlcyA9IHt9O1xuXG4gICAgdGhpcy5faW5pdGlhbGl6ZShwcm9wcyk7XG5cbiAgICBPYmplY3Quc2VhbCh0aGlzKTtcbiAgfVxuXG4gIHVwZGF0ZU1vZGVsUHJvcHMoKSB7XG4gICAgbGV0IHByb3BzID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fTtcblxuICAgIGNvbnN0IHVwZGF0ZWRNb2RlbFByb3BzID0gdGhpcy5fcHJvY2Vzc1ZlcnRleFNoYWRlcihwcm9wcyk7XG5cbiAgICByZXR1cm4gT2JqZWN0LmFzc2lnbih7fSwgcHJvcHMsIHVwZGF0ZWRNb2RlbFByb3BzKTtcbiAgfVxuXG4gIGdldERyYXdPcHRpb25zKCkge1xuICAgIGxldCBvcHRzID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fTtcbiAgICBjb25zdCB7XG4gICAgICBzb3VyY2VCdWZmZXJzLFxuICAgICAgc291cmNlVGV4dHVyZXMsXG4gICAgICBmcmFtZWJ1ZmZlcixcbiAgICAgIHRhcmdldFRleHR1cmVcbiAgICB9ID0gdGhpcy5iaW5kaW5nc1t0aGlzLmN1cnJlbnRJbmRleF07XG4gICAgY29uc3QgYXR0cmlidXRlcyA9IE9iamVjdC5hc3NpZ24oe30sIHNvdXJjZUJ1ZmZlcnMsIG9wdHMuYXR0cmlidXRlcyk7XG4gICAgY29uc3QgdW5pZm9ybXMgPSBPYmplY3QuYXNzaWduKHt9LCBvcHRzLnVuaWZvcm1zKTtcbiAgICBjb25zdCBwYXJhbWV0ZXJzID0gT2JqZWN0LmFzc2lnbih7fSwgb3B0cy5wYXJhbWV0ZXJzKTtcbiAgICBsZXQgZGlzY2FyZCA9IG9wdHMuZGlzY2FyZDtcblxuICAgIGlmICh0aGlzLmhhc1NvdXJjZVRleHR1cmVzIHx8IHRoaXMuaGFzVGFyZ2V0VGV4dHVyZSkge1xuICAgICAgYXR0cmlidXRlcy50cmFuc2Zvcm1fZWxlbWVudElEID0gdGhpcy5lbGVtZW50SURCdWZmZXI7XG5cbiAgICAgIGZvciAoY29uc3Qgc2FtcGxlciBpbiB0aGlzLnNhbXBsZXJUZXh0dXJlTWFwKSB7XG4gICAgICAgIGNvbnN0IHRleHR1cmVOYW1lID0gdGhpcy5zYW1wbGVyVGV4dHVyZU1hcFtzYW1wbGVyXTtcbiAgICAgICAgdW5pZm9ybXNbc2FtcGxlcl0gPSBzb3VyY2VUZXh0dXJlc1t0ZXh0dXJlTmFtZV07XG4gICAgICB9XG5cbiAgICAgIHRoaXMuX3NldFNvdXJjZVRleHR1cmVQYXJhbWV0ZXJzKCk7XG5cbiAgICAgIGNvbnN0IHNpemVVbmlmb3JtcyA9IGdldFNpemVVbmlmb3Jtcyh7XG4gICAgICAgIHNvdXJjZVRleHR1cmVNYXA6IHNvdXJjZVRleHR1cmVzLFxuICAgICAgICB0YXJnZXRUZXh0dXJlVmFyeWluZzogdGhpcy50YXJnZXRUZXh0dXJlVmFyeWluZyxcbiAgICAgICAgdGFyZ2V0VGV4dHVyZVxuICAgICAgfSk7XG4gICAgICBPYmplY3QuYXNzaWduKHVuaWZvcm1zLCBzaXplVW5pZm9ybXMpO1xuICAgIH1cblxuICAgIGlmICh0aGlzLmhhc1RhcmdldFRleHR1cmUpIHtcbiAgICAgIGRpc2NhcmQgPSBmYWxzZTtcbiAgICAgIHBhcmFtZXRlcnMudmlld3BvcnQgPSBbMCwgMCwgZnJhbWVidWZmZXIud2lkdGgsIGZyYW1lYnVmZmVyLmhlaWdodF07XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIGF0dHJpYnV0ZXMsXG4gICAgICBmcmFtZWJ1ZmZlcixcbiAgICAgIHVuaWZvcm1zLFxuICAgICAgZGlzY2FyZCxcbiAgICAgIHBhcmFtZXRlcnNcbiAgICB9O1xuICB9XG5cbiAgc3dhcCgpIHtcbiAgICBpZiAodGhpcy5fc3dhcFRleHR1cmUpIHtcbiAgICAgIHRoaXMuY3VycmVudEluZGV4ID0gdGhpcy5fZ2V0TmV4dEluZGV4KCk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICB1cGRhdGUoKSB7XG4gICAgbGV0IG9wdHMgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHt9O1xuXG4gICAgdGhpcy5fc2V0dXBUZXh0dXJlcyhvcHRzKTtcbiAgfVxuXG4gIGdldFRhcmdldFRleHR1cmUoKSB7XG4gICAgY29uc3Qge1xuICAgICAgdGFyZ2V0VGV4dHVyZVxuICAgIH0gPSB0aGlzLmJpbmRpbmdzW3RoaXMuY3VycmVudEluZGV4XTtcbiAgICByZXR1cm4gdGFyZ2V0VGV4dHVyZTtcbiAgfVxuXG4gIGdldERhdGEoKSB7XG4gICAgbGV0IHtcbiAgICAgIHBhY2tlZCA9IGZhbHNlXG4gICAgfSA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge307XG4gICAgY29uc3Qge1xuICAgICAgZnJhbWVidWZmZXJcbiAgICB9ID0gdGhpcy5iaW5kaW5nc1t0aGlzLmN1cnJlbnRJbmRleF07XG4gICAgY29uc3QgcGl4ZWxzID0gcmVhZFBpeGVsc1RvQXJyYXkoZnJhbWVidWZmZXIpO1xuXG4gICAgaWYgKCFwYWNrZWQpIHtcbiAgICAgIHJldHVybiBwaXhlbHM7XG4gICAgfVxuXG4gICAgY29uc3QgQXJyYXlUeXBlID0gcGl4ZWxzLmNvbnN0cnVjdG9yO1xuICAgIGNvbnN0IGNoYW5uZWxDb3VudCA9IHR5cGVUb0NoYW5uZWxDb3VudCh0aGlzLnRhcmdldFRleHR1cmVUeXBlKTtcbiAgICBjb25zdCBwYWNrZWRQaXhlbHMgPSBuZXcgQXJyYXlUeXBlKHBpeGVscy5sZW5ndGggKiBjaGFubmVsQ291bnQgLyA0KTtcbiAgICBsZXQgcGFja0NvdW50ID0gMDtcblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcGl4ZWxzLmxlbmd0aDsgaSArPSA0KSB7XG4gICAgICBmb3IgKGxldCBqID0gMDsgaiA8IGNoYW5uZWxDb3VudDsgaisrKSB7XG4gICAgICAgIHBhY2tlZFBpeGVsc1twYWNrQ291bnQrK10gPSBwaXhlbHNbaSArIGpdO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBwYWNrZWRQaXhlbHM7XG4gIH1cblxuICBnZXRGcmFtZWJ1ZmZlcigpIHtcbiAgICBjb25zdCBjdXJyZW50UmVzb3VyY2VzID0gdGhpcy5iaW5kaW5nc1t0aGlzLmN1cnJlbnRJbmRleF07XG4gICAgcmV0dXJuIGN1cnJlbnRSZXNvdXJjZXMuZnJhbWVidWZmZXI7XG4gIH1cblxuICBkZWxldGUoKSB7XG4gICAgaWYgKHRoaXMub3duVGV4dHVyZSkge1xuICAgICAgdGhpcy5vd25UZXh0dXJlLmRlbGV0ZSgpO1xuICAgIH1cblxuICAgIGlmICh0aGlzLmVsZW1lbnRJREJ1ZmZlcikge1xuICAgICAgdGhpcy5lbGVtZW50SURCdWZmZXIuZGVsZXRlKCk7XG4gICAgfVxuICB9XG5cbiAgX2luaXRpYWxpemUoKSB7XG4gICAgbGV0IHByb3BzID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fTtcbiAgICBjb25zdCB7XG4gICAgICBfdGFyZ2V0VGV4dHVyZVZhcnlpbmcsXG4gICAgICBfc3dhcFRleHR1cmVcbiAgICB9ID0gcHJvcHM7XG4gICAgdGhpcy5fc3dhcFRleHR1cmUgPSBfc3dhcFRleHR1cmU7XG4gICAgdGhpcy50YXJnZXRUZXh0dXJlVmFyeWluZyA9IF90YXJnZXRUZXh0dXJlVmFyeWluZztcbiAgICB0aGlzLmhhc1RhcmdldFRleHR1cmUgPSBfdGFyZ2V0VGV4dHVyZVZhcnlpbmc7XG5cbiAgICB0aGlzLl9zZXR1cFRleHR1cmVzKHByb3BzKTtcbiAgfVxuXG4gIF9jcmVhdGVUYXJnZXRUZXh0dXJlKHByb3BzKSB7XG4gICAgY29uc3Qge1xuICAgICAgc291cmNlVGV4dHVyZXMsXG4gICAgICB0ZXh0dXJlT3JSZWZlcmVuY2VcbiAgICB9ID0gcHJvcHM7XG5cbiAgICBpZiAodGV4dHVyZU9yUmVmZXJlbmNlIGluc3RhbmNlb2YgVGV4dHVyZTJEKSB7XG4gICAgICByZXR1cm4gdGV4dHVyZU9yUmVmZXJlbmNlO1xuICAgIH1cblxuICAgIGNvbnN0IHJlZlRleHR1cmUgPSBzb3VyY2VUZXh0dXJlc1t0ZXh0dXJlT3JSZWZlcmVuY2VdO1xuXG4gICAgaWYgKCFyZWZUZXh0dXJlKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICB0aGlzLl90YXJnZXRSZWZUZXhOYW1lID0gdGV4dHVyZU9yUmVmZXJlbmNlO1xuICAgIHJldHVybiB0aGlzLl9jcmVhdGVOZXdUZXh0dXJlKHJlZlRleHR1cmUpO1xuICB9XG5cbiAgX3NldHVwVGV4dHVyZXMoKSB7XG4gICAgbGV0IHByb3BzID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fTtcbiAgICBjb25zdCB7XG4gICAgICBzb3VyY2VCdWZmZXJzLFxuICAgICAgX3NvdXJjZVRleHR1cmVzID0ge30sXG4gICAgICBfdGFyZ2V0VGV4dHVyZVxuICAgIH0gPSBwcm9wcztcblxuICAgIGNvbnN0IHRhcmdldFRleHR1cmUgPSB0aGlzLl9jcmVhdGVUYXJnZXRUZXh0dXJlKHtcbiAgICAgIHNvdXJjZVRleHR1cmVzOiBfc291cmNlVGV4dHVyZXMsXG4gICAgICB0ZXh0dXJlT3JSZWZlcmVuY2U6IF90YXJnZXRUZXh0dXJlXG4gICAgfSk7XG5cbiAgICB0aGlzLmhhc1NvdXJjZVRleHR1cmVzID0gdGhpcy5oYXNTb3VyY2VUZXh0dXJlcyB8fCBfc291cmNlVGV4dHVyZXMgJiYgT2JqZWN0LmtleXMoX3NvdXJjZVRleHR1cmVzKS5sZW5ndGggPiAwO1xuXG4gICAgdGhpcy5fdXBkYXRlQmluZGluZ3Moe1xuICAgICAgc291cmNlQnVmZmVycyxcbiAgICAgIHNvdXJjZVRleHR1cmVzOiBfc291cmNlVGV4dHVyZXMsXG4gICAgICB0YXJnZXRUZXh0dXJlXG4gICAgfSk7XG5cbiAgICBpZiAoJ2VsZW1lbnRDb3VudCcgaW4gcHJvcHMpIHtcbiAgICAgIHRoaXMuX3VwZGF0ZUVsZW1lbnRJREJ1ZmZlcihwcm9wcy5lbGVtZW50Q291bnQpO1xuICAgIH1cbiAgfVxuXG4gIF91cGRhdGVFbGVtZW50SURCdWZmZXIoZWxlbWVudENvdW50KSB7XG4gICAgaWYgKHR5cGVvZiBlbGVtZW50Q291bnQgIT09ICdudW1iZXInIHx8IHRoaXMuZWxlbWVudENvdW50ID49IGVsZW1lbnRDb3VudCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IGVsZW1lbnRJZHMgPSBuZXcgRmxvYXQzMkFycmF5KGVsZW1lbnRDb3VudCk7XG4gICAgZWxlbWVudElkcy5mb3JFYWNoKChfLCBpbmRleCwgYXJyYXkpID0+IHtcbiAgICAgIGFycmF5W2luZGV4XSA9IGluZGV4O1xuICAgIH0pO1xuXG4gICAgaWYgKCF0aGlzLmVsZW1lbnRJREJ1ZmZlcikge1xuICAgICAgdGhpcy5lbGVtZW50SURCdWZmZXIgPSBuZXcgQnVmZmVyKHRoaXMuZ2wsIHtcbiAgICAgICAgZGF0YTogZWxlbWVudElkcyxcbiAgICAgICAgYWNjZXNzb3I6IHtcbiAgICAgICAgICBzaXplOiAxXG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmVsZW1lbnRJREJ1ZmZlci5zZXREYXRhKHtcbiAgICAgICAgZGF0YTogZWxlbWVudElkc1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgdGhpcy5lbGVtZW50Q291bnQgPSBlbGVtZW50Q291bnQ7XG4gIH1cblxuICBfdXBkYXRlQmluZGluZ3Mob3B0cykge1xuICAgIHRoaXMuYmluZGluZ3NbdGhpcy5jdXJyZW50SW5kZXhdID0gdGhpcy5fdXBkYXRlQmluZGluZyh0aGlzLmJpbmRpbmdzW3RoaXMuY3VycmVudEluZGV4XSwgb3B0cyk7XG5cbiAgICBpZiAodGhpcy5fc3dhcFRleHR1cmUpIHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgc291cmNlVGV4dHVyZXMsXG4gICAgICAgIHRhcmdldFRleHR1cmVcbiAgICAgIH0gPSB0aGlzLl9zd2FwVGV4dHVyZXModGhpcy5iaW5kaW5nc1t0aGlzLmN1cnJlbnRJbmRleF0pO1xuXG4gICAgICBjb25zdCBuZXh0SW5kZXggPSB0aGlzLl9nZXROZXh0SW5kZXgoKTtcblxuICAgICAgdGhpcy5iaW5kaW5nc1tuZXh0SW5kZXhdID0gdGhpcy5fdXBkYXRlQmluZGluZyh0aGlzLmJpbmRpbmdzW25leHRJbmRleF0sIHtcbiAgICAgICAgc291cmNlVGV4dHVyZXMsXG4gICAgICAgIHRhcmdldFRleHR1cmVcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIF91cGRhdGVCaW5kaW5nKGJpbmRpbmcsIG9wdHMpIHtcbiAgICBjb25zdCB7XG4gICAgICBzb3VyY2VCdWZmZXJzLFxuICAgICAgc291cmNlVGV4dHVyZXMsXG4gICAgICB0YXJnZXRUZXh0dXJlXG4gICAgfSA9IG9wdHM7XG5cbiAgICBpZiAoIWJpbmRpbmcpIHtcbiAgICAgIGJpbmRpbmcgPSB7XG4gICAgICAgIHNvdXJjZUJ1ZmZlcnM6IHt9LFxuICAgICAgICBzb3VyY2VUZXh0dXJlczoge30sXG4gICAgICAgIHRhcmdldFRleHR1cmU6IG51bGxcbiAgICAgIH07XG4gICAgfVxuXG4gICAgT2JqZWN0LmFzc2lnbihiaW5kaW5nLnNvdXJjZVRleHR1cmVzLCBzb3VyY2VUZXh0dXJlcyk7XG4gICAgT2JqZWN0LmFzc2lnbihiaW5kaW5nLnNvdXJjZUJ1ZmZlcnMsIHNvdXJjZUJ1ZmZlcnMpO1xuXG4gICAgaWYgKHRhcmdldFRleHR1cmUpIHtcbiAgICAgIGJpbmRpbmcudGFyZ2V0VGV4dHVyZSA9IHRhcmdldFRleHR1cmU7XG4gICAgICBjb25zdCB7XG4gICAgICAgIHdpZHRoLFxuICAgICAgICBoZWlnaHRcbiAgICAgIH0gPSB0YXJnZXRUZXh0dXJlO1xuICAgICAgY29uc3Qge1xuICAgICAgICBmcmFtZWJ1ZmZlclxuICAgICAgfSA9IGJpbmRpbmc7XG5cbiAgICAgIGlmIChmcmFtZWJ1ZmZlcikge1xuICAgICAgICBmcmFtZWJ1ZmZlci51cGRhdGUoe1xuICAgICAgICAgIGF0dGFjaG1lbnRzOiB7XG4gICAgICAgICAgICBbMzYwNjRdOiB0YXJnZXRUZXh0dXJlXG4gICAgICAgICAgfSxcbiAgICAgICAgICByZXNpemVBdHRhY2htZW50czogZmFsc2VcbiAgICAgICAgfSk7XG4gICAgICAgIGZyYW1lYnVmZmVyLnJlc2l6ZSh7XG4gICAgICAgICAgd2lkdGgsXG4gICAgICAgICAgaGVpZ2h0XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYmluZGluZy5mcmFtZWJ1ZmZlciA9IG5ldyBGcmFtZWJ1ZmZlcih0aGlzLmdsLCB7XG4gICAgICAgICAgaWQ6IFwidHJhbnNmb3JtLWZyYW1lYnVmZmVyXCIsXG4gICAgICAgICAgd2lkdGgsXG4gICAgICAgICAgaGVpZ2h0LFxuICAgICAgICAgIGF0dGFjaG1lbnRzOiB7XG4gICAgICAgICAgICBbMzYwNjRdOiB0YXJnZXRUZXh0dXJlXG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gYmluZGluZztcbiAgfVxuXG4gIF9zZXRTb3VyY2VUZXh0dXJlUGFyYW1ldGVycygpIHtcbiAgICBjb25zdCBpbmRleCA9IHRoaXMuY3VycmVudEluZGV4O1xuICAgIGNvbnN0IHtcbiAgICAgIHNvdXJjZVRleHR1cmVzXG4gICAgfSA9IHRoaXMuYmluZGluZ3NbaW5kZXhdO1xuXG4gICAgZm9yIChjb25zdCBuYW1lIGluIHNvdXJjZVRleHR1cmVzKSB7XG4gICAgICBzb3VyY2VUZXh0dXJlc1tuYW1lXS5zZXRQYXJhbWV0ZXJzKFNSQ19URVhfUEFSQU1FVEVSX09WRVJSSURFUyk7XG4gICAgfVxuICB9XG5cbiAgX3N3YXBUZXh0dXJlcyhvcHRzKSB7XG4gICAgaWYgKCF0aGlzLl9zd2FwVGV4dHVyZSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgY29uc3Qgc291cmNlVGV4dHVyZXMgPSBPYmplY3QuYXNzaWduKHt9LCBvcHRzLnNvdXJjZVRleHR1cmVzKTtcbiAgICBzb3VyY2VUZXh0dXJlc1t0aGlzLl9zd2FwVGV4dHVyZV0gPSBvcHRzLnRhcmdldFRleHR1cmU7XG4gICAgY29uc3QgdGFyZ2V0VGV4dHVyZSA9IG9wdHMuc291cmNlVGV4dHVyZXNbdGhpcy5fc3dhcFRleHR1cmVdO1xuICAgIHJldHVybiB7XG4gICAgICBzb3VyY2VUZXh0dXJlcyxcbiAgICAgIHRhcmdldFRleHR1cmVcbiAgICB9O1xuICB9XG5cbiAgX2NyZWF0ZU5ld1RleHR1cmUocmVmVGV4dHVyZSkge1xuICAgIGNvbnN0IHRleHR1cmUgPSBjbG9uZVRleHR1cmVGcm9tKHJlZlRleHR1cmUsIHtcbiAgICAgIHBhcmFtZXRlcnM6IHtcbiAgICAgICAgWzEwMjQxXTogOTcyOCxcbiAgICAgICAgWzEwMjQwXTogOTcyOCxcbiAgICAgICAgWzEwMjQyXTogMzMwNzEsXG4gICAgICAgIFsxMDI0M106IDMzMDcxXG4gICAgICB9LFxuICAgICAgcGl4ZWxTdG9yZToge1xuICAgICAgICBbMzc0NDBdOiBmYWxzZVxuICAgICAgfVxuICAgIH0pO1xuXG4gICAgaWYgKHRoaXMub3duVGV4dHVyZSkge1xuICAgICAgdGhpcy5vd25UZXh0dXJlLmRlbGV0ZSgpO1xuICAgIH1cblxuICAgIHRoaXMub3duVGV4dHVyZSA9IHRleHR1cmU7XG4gICAgcmV0dXJuIHRleHR1cmU7XG4gIH1cblxuICBfZ2V0TmV4dEluZGV4KCkge1xuICAgIHJldHVybiAodGhpcy5jdXJyZW50SW5kZXggKyAxKSAlIDI7XG4gIH1cblxuICBfcHJvY2Vzc1ZlcnRleFNoYWRlcigpIHtcbiAgICBsZXQgcHJvcHMgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHt9O1xuICAgIGNvbnN0IHtcbiAgICAgIHNvdXJjZVRleHR1cmVzLFxuICAgICAgdGFyZ2V0VGV4dHVyZVxuICAgIH0gPSB0aGlzLmJpbmRpbmdzW3RoaXMuY3VycmVudEluZGV4XTtcbiAgICBjb25zdCB7XG4gICAgICB2cyxcbiAgICAgIHVuaWZvcm1zLFxuICAgICAgdGFyZ2V0VGV4dHVyZVR5cGUsXG4gICAgICBpbmplY3QsXG4gICAgICBzYW1wbGVyVGV4dHVyZU1hcFxuICAgIH0gPSB1cGRhdGVGb3JUZXh0dXJlcyh7XG4gICAgICB2czogcHJvcHMudnMsXG4gICAgICBzb3VyY2VUZXh0dXJlTWFwOiBzb3VyY2VUZXh0dXJlcyxcbiAgICAgIHRhcmdldFRleHR1cmVWYXJ5aW5nOiB0aGlzLnRhcmdldFRleHR1cmVWYXJ5aW5nLFxuICAgICAgdGFyZ2V0VGV4dHVyZVxuICAgIH0pO1xuICAgIGNvbnN0IGNvbWJpbmVkSW5qZWN0ID0gY29tYmluZUluamVjdHMoW3Byb3BzLmluamVjdCB8fCB7fSwgaW5qZWN0XSk7XG4gICAgdGhpcy50YXJnZXRUZXh0dXJlVHlwZSA9IHRhcmdldFRleHR1cmVUeXBlO1xuICAgIHRoaXMuc2FtcGxlclRleHR1cmVNYXAgPSBzYW1wbGVyVGV4dHVyZU1hcDtcbiAgICBjb25zdCBmcyA9IHByb3BzLl9mcyB8fCBnZXRQYXNzdGhyb3VnaEZTKHtcbiAgICAgIHZlcnNpb246IGdldFNoYWRlclZlcnNpb24odnMpLFxuICAgICAgaW5wdXQ6IHRoaXMudGFyZ2V0VGV4dHVyZVZhcnlpbmcsXG4gICAgICBpbnB1dFR5cGU6IHRhcmdldFRleHR1cmVUeXBlLFxuICAgICAgb3V0cHV0OiBGU19PVVRQVVRfVkFSSUFCTEVcbiAgICB9KTtcbiAgICBjb25zdCBtb2R1bGVzID0gdGhpcy5oYXNTb3VyY2VUZXh0dXJlcyB8fCB0aGlzLnRhcmdldFRleHR1cmVWYXJ5aW5nID8gW3RyYW5zZm9ybU1vZHVsZV0uY29uY2F0KHByb3BzLm1vZHVsZXMgfHwgW10pIDogcHJvcHMubW9kdWxlcztcbiAgICByZXR1cm4ge1xuICAgICAgdnMsXG4gICAgICBmcyxcbiAgICAgIG1vZHVsZXMsXG4gICAgICB1bmlmb3JtcyxcbiAgICAgIGluamVjdDogY29tYmluZWRJbmplY3RcbiAgICB9O1xuICB9XG5cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXRleHR1cmUtdHJhbnNmb3JtLmpzLm1hcCIsImltcG9ydCB7IGdldFBhc3N0aHJvdWdoRlMgfSBmcm9tICdAbHVtYS5nbC9zaGFkZXJ0b29scyc7XG5pbXBvcnQgQnVmZmVyVHJhbnNmb3JtIGZyb20gJy4vYnVmZmVyLXRyYW5zZm9ybSc7XG5pbXBvcnQgVGV4dHVyZVRyYW5zZm9ybSBmcm9tICcuL3RleHR1cmUtdHJhbnNmb3JtJztcbmltcG9ydCB7IGlzV2ViR0wyIH0gZnJvbSAnQGx1bWEuZ2wvZ2x0b29scyc7XG5pbXBvcnQgeyBhc3NlcnQsIGlzT2JqZWN0RW1wdHksIGdldFNoYWRlclZlcnNpb24gfSBmcm9tICdAbHVtYS5nbC93ZWJnbCc7XG5pbXBvcnQgTW9kZWwgZnJvbSAnLi4vbGliL21vZGVsJztcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFRyYW5zZm9ybSB7XG4gIHN0YXRpYyBpc1N1cHBvcnRlZChnbCkge1xuICAgIHJldHVybiBpc1dlYkdMMihnbCk7XG4gIH1cblxuICBjb25zdHJ1Y3RvcihnbCkge1xuICAgIGxldCBwcm9wcyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG4gICAgdGhpcy5nbCA9IGdsO1xuICAgIHRoaXMubW9kZWwgPSBudWxsO1xuICAgIHRoaXMuZWxlbWVudENvdW50ID0gMDtcbiAgICB0aGlzLmJ1ZmZlclRyYW5zZm9ybSA9IG51bGw7XG4gICAgdGhpcy50ZXh0dXJlVHJhbnNmb3JtID0gbnVsbDtcbiAgICB0aGlzLmVsZW1lbnRJREJ1ZmZlciA9IG51bGw7XG5cbiAgICB0aGlzLl9pbml0aWFsaXplKHByb3BzKTtcblxuICAgIE9iamVjdC5zZWFsKHRoaXMpO1xuICB9XG5cbiAgZGVsZXRlKCkge1xuICAgIGNvbnN0IHtcbiAgICAgIG1vZGVsLFxuICAgICAgYnVmZmVyVHJhbnNmb3JtLFxuICAgICAgdGV4dHVyZVRyYW5zZm9ybVxuICAgIH0gPSB0aGlzO1xuXG4gICAgaWYgKG1vZGVsKSB7XG4gICAgICBtb2RlbC5kZWxldGUoKTtcbiAgICB9XG5cbiAgICBpZiAoYnVmZmVyVHJhbnNmb3JtKSB7XG4gICAgICBidWZmZXJUcmFuc2Zvcm0uZGVsZXRlKCk7XG4gICAgfVxuXG4gICAgaWYgKHRleHR1cmVUcmFuc2Zvcm0pIHtcbiAgICAgIHRleHR1cmVUcmFuc2Zvcm0uZGVsZXRlKCk7XG4gICAgfVxuICB9XG5cbiAgcnVuKCkge1xuICAgIGxldCBvcHRzID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fTtcbiAgICBjb25zdCB7XG4gICAgICBjbGVhclJlbmRlclRhcmdldCA9IHRydWVcbiAgICB9ID0gb3B0cztcblxuICAgIGNvbnN0IHVwZGF0ZWRPcHRzID0gdGhpcy5fdXBkYXRlRHJhd09wdGlvbnMob3B0cyk7XG5cbiAgICBpZiAoY2xlYXJSZW5kZXJUYXJnZXQgJiYgdXBkYXRlZE9wdHMuZnJhbWVidWZmZXIpIHtcbiAgICAgIHVwZGF0ZWRPcHRzLmZyYW1lYnVmZmVyLmNsZWFyKHtcbiAgICAgICAgY29sb3I6IHRydWVcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHRoaXMubW9kZWwudHJhbnNmb3JtKHVwZGF0ZWRPcHRzKTtcbiAgfVxuXG4gIHN3YXAoKSB7XG4gICAgbGV0IHN3YXBwZWQgPSBmYWxzZTtcbiAgICBjb25zdCByZXNvdXJjZVRyYW5zZm9ybXMgPSBbdGhpcy5idWZmZXJUcmFuc2Zvcm0sIHRoaXMudGV4dHVyZVRyYW5zZm9ybV0uZmlsdGVyKEJvb2xlYW4pO1xuXG4gICAgZm9yIChjb25zdCByZXNvdXJjZVRyYW5zZm9ybSBvZiByZXNvdXJjZVRyYW5zZm9ybXMpIHtcbiAgICAgIHN3YXBwZWQgPSBzd2FwcGVkIHx8IHJlc291cmNlVHJhbnNmb3JtLnN3YXAoKTtcbiAgICB9XG5cbiAgICBhc3NlcnQoc3dhcHBlZCwgJ05vdGhpbmcgdG8gc3dhcCcpO1xuICB9XG5cbiAgZ2V0QnVmZmVyKCkge1xuICAgIGxldCB2YXJ5aW5nTmFtZSA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogbnVsbDtcbiAgICByZXR1cm4gdGhpcy5idWZmZXJUcmFuc2Zvcm0gJiYgdGhpcy5idWZmZXJUcmFuc2Zvcm0uZ2V0QnVmZmVyKHZhcnlpbmdOYW1lKTtcbiAgfVxuXG4gIGdldERhdGEoKSB7XG4gICAgbGV0IG9wdHMgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHt9O1xuICAgIGNvbnN0IHJlc291cmNlVHJhbnNmb3JtcyA9IFt0aGlzLmJ1ZmZlclRyYW5zZm9ybSwgdGhpcy50ZXh0dXJlVHJhbnNmb3JtXS5maWx0ZXIoQm9vbGVhbik7XG5cbiAgICBmb3IgKGNvbnN0IHJlc291cmNlVHJhbnNmb3JtIG9mIHJlc291cmNlVHJhbnNmb3Jtcykge1xuICAgICAgY29uc3QgZGF0YSA9IHJlc291cmNlVHJhbnNmb3JtLmdldERhdGEob3B0cyk7XG5cbiAgICAgIGlmIChkYXRhKSB7XG4gICAgICAgIHJldHVybiBkYXRhO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgZ2V0RnJhbWVidWZmZXIoKSB7XG4gICAgcmV0dXJuIHRoaXMudGV4dHVyZVRyYW5zZm9ybSAmJiB0aGlzLnRleHR1cmVUcmFuc2Zvcm0uZ2V0RnJhbWVidWZmZXIoKTtcbiAgfVxuXG4gIHVwZGF0ZSgpIHtcbiAgICBsZXQgb3B0cyA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge307XG5cbiAgICBpZiAoJ2VsZW1lbnRDb3VudCcgaW4gb3B0cykge1xuICAgICAgdGhpcy5tb2RlbC5zZXRWZXJ0ZXhDb3VudChvcHRzLmVsZW1lbnRDb3VudCk7XG4gICAgfVxuXG4gICAgY29uc3QgcmVzb3VyY2VUcmFuc2Zvcm1zID0gW3RoaXMuYnVmZmVyVHJhbnNmb3JtLCB0aGlzLnRleHR1cmVUcmFuc2Zvcm1dLmZpbHRlcihCb29sZWFuKTtcblxuICAgIGZvciAoY29uc3QgcmVzb3VyY2VUcmFuc2Zvcm0gb2YgcmVzb3VyY2VUcmFuc2Zvcm1zKSB7XG4gICAgICByZXNvdXJjZVRyYW5zZm9ybS51cGRhdGUob3B0cyk7XG4gICAgfVxuICB9XG5cbiAgX2luaXRpYWxpemUoKSB7XG4gICAgbGV0IHByb3BzID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fTtcbiAgICBjb25zdCB7XG4gICAgICBnbFxuICAgIH0gPSB0aGlzO1xuXG4gICAgdGhpcy5fYnVpbGRSZXNvdXJjZVRyYW5zZm9ybXMoZ2wsIHByb3BzKTtcblxuICAgIHByb3BzID0gdGhpcy5fdXBkYXRlTW9kZWxQcm9wcyhwcm9wcyk7XG4gICAgdGhpcy5tb2RlbCA9IG5ldyBNb2RlbChnbCwgT2JqZWN0LmFzc2lnbih7fSwgcHJvcHMsIHtcbiAgICAgIGZzOiBwcm9wcy5mcyB8fCBnZXRQYXNzdGhyb3VnaEZTKHtcbiAgICAgICAgdmVyc2lvbjogZ2V0U2hhZGVyVmVyc2lvbihwcm9wcy52cylcbiAgICAgIH0pLFxuICAgICAgaWQ6IHByb3BzLmlkIHx8ICd0cmFuc2Zvcm0tbW9kZWwnLFxuICAgICAgZHJhd01vZGU6IHByb3BzLmRyYXdNb2RlIHx8IDAsXG4gICAgICB2ZXJ0ZXhDb3VudDogcHJvcHMuZWxlbWVudENvdW50XG4gICAgfSkpO1xuICAgIHRoaXMuYnVmZmVyVHJhbnNmb3JtICYmIHRoaXMuYnVmZmVyVHJhbnNmb3JtLnNldHVwUmVzb3VyY2VzKHtcbiAgICAgIG1vZGVsOiB0aGlzLm1vZGVsXG4gICAgfSk7XG4gIH1cblxuICBfdXBkYXRlTW9kZWxQcm9wcyhwcm9wcykge1xuICAgIGxldCB1cGRhdGVkUHJvcHMgPSBPYmplY3QuYXNzaWduKHt9LCBwcm9wcyk7XG4gICAgY29uc3QgcmVzb3VyY2VUcmFuc2Zvcm1zID0gW3RoaXMuYnVmZmVyVHJhbnNmb3JtLCB0aGlzLnRleHR1cmVUcmFuc2Zvcm1dLmZpbHRlcihCb29sZWFuKTtcblxuICAgIGZvciAoY29uc3QgcmVzb3VyY2VUcmFuc2Zvcm0gb2YgcmVzb3VyY2VUcmFuc2Zvcm1zKSB7XG4gICAgICB1cGRhdGVkUHJvcHMgPSByZXNvdXJjZVRyYW5zZm9ybS51cGRhdGVNb2RlbFByb3BzKHVwZGF0ZWRQcm9wcyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHVwZGF0ZWRQcm9wcztcbiAgfVxuXG4gIF9idWlsZFJlc291cmNlVHJhbnNmb3JtcyhnbCwgcHJvcHMpIHtcbiAgICBpZiAoY2FuQ3JlYXRlQnVmZmVyVHJhbnNmb3JtKHByb3BzKSkge1xuICAgICAgdGhpcy5idWZmZXJUcmFuc2Zvcm0gPSBuZXcgQnVmZmVyVHJhbnNmb3JtKGdsLCBwcm9wcyk7XG4gICAgfVxuXG4gICAgaWYgKGNhbkNyZWF0ZVRleHR1cmVUcmFuc2Zvcm0ocHJvcHMpKSB7XG4gICAgICB0aGlzLnRleHR1cmVUcmFuc2Zvcm0gPSBuZXcgVGV4dHVyZVRyYW5zZm9ybShnbCwgcHJvcHMpO1xuICAgIH1cblxuICAgIGFzc2VydCh0aGlzLmJ1ZmZlclRyYW5zZm9ybSB8fCB0aGlzLnRleHR1cmVUcmFuc2Zvcm0sICdtdXN0IHByb3ZpZGUgc291cmNlL2ZlZWRiYWNrIGJ1ZmZlcnMgb3Igc291cmNlL3RhcmdldCB0ZXh0dXJlcycpO1xuICB9XG5cbiAgX3VwZGF0ZURyYXdPcHRpb25zKG9wdHMpIHtcbiAgICBsZXQgdXBkYXRlZE9wdHMgPSBPYmplY3QuYXNzaWduKHt9LCBvcHRzKTtcbiAgICBjb25zdCByZXNvdXJjZVRyYW5zZm9ybXMgPSBbdGhpcy5idWZmZXJUcmFuc2Zvcm0sIHRoaXMudGV4dHVyZVRyYW5zZm9ybV0uZmlsdGVyKEJvb2xlYW4pO1xuXG4gICAgZm9yIChjb25zdCByZXNvdXJjZVRyYW5zZm9ybSBvZiByZXNvdXJjZVRyYW5zZm9ybXMpIHtcbiAgICAgIHVwZGF0ZWRPcHRzID0gT2JqZWN0LmFzc2lnbih1cGRhdGVkT3B0cywgcmVzb3VyY2VUcmFuc2Zvcm0uZ2V0RHJhd09wdGlvbnModXBkYXRlZE9wdHMpKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdXBkYXRlZE9wdHM7XG4gIH1cblxufVxuXG5mdW5jdGlvbiBjYW5DcmVhdGVCdWZmZXJUcmFuc2Zvcm0ocHJvcHMpIHtcbiAgaWYgKCFpc09iamVjdEVtcHR5KHByb3BzLmZlZWRiYWNrQnVmZmVycykgfHwgIWlzT2JqZWN0RW1wdHkocHJvcHMuZmVlZGJhY2tNYXApIHx8IHByb3BzLnZhcnlpbmdzICYmIHByb3BzLnZhcnlpbmdzLmxlbmd0aCA+IDApIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gY2FuQ3JlYXRlVGV4dHVyZVRyYW5zZm9ybShwcm9wcykge1xuICBpZiAoIWlzT2JqZWN0RW1wdHkocHJvcHMuX3NvdXJjZVRleHR1cmVzKSB8fCBwcm9wcy5fdGFyZ2V0VGV4dHVyZSB8fCBwcm9wcy5fdGFyZ2V0VGV4dHVyZVZhcnlpbmcpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXRyYW5zZm9ybS5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///19718\n')},77910:function(__unused_webpack_module,__webpack_exports__,__webpack_require__){eval("\n// EXPORTS\n__webpack_require__.d(__webpack_exports__, {\n  \"Z\": function() { return /* binding */ createGLTFObjects; }\n});\n\n// EXTERNAL MODULE: ./node_modules/@math.gl/core/dist/esm/classes/matrix4.js\nvar matrix4 = __webpack_require__(85451);\n// EXTERNAL MODULE: ./node_modules/@luma.gl/gltools/dist/esm/index.js + 13 modules\nvar esm = __webpack_require__(1418);\n// EXTERNAL MODULE: ./node_modules/@luma.gl/webgl/dist/esm/classes/buffer.js\nvar buffer = __webpack_require__(53478);\n// EXTERNAL MODULE: ./node_modules/@luma.gl/webgl/dist/esm/classes/accessor.js\nvar classes_accessor = __webpack_require__(14072);\n// EXTERNAL MODULE: ./node_modules/@math.gl/core/dist/esm/classes/vector3.js\nvar vector3 = __webpack_require__(43855);\n// EXTERNAL MODULE: ./node_modules/@luma.gl/experimental/dist/esm/scenegraph/scenegraph-node.js\nvar scenegraph_node = __webpack_require__(44522);\n;// CONCATENATED MODULE: ./node_modules/@luma.gl/experimental/dist/esm/scenegraph/group-node.js\n\n\n\nclass GroupNode extends scenegraph_node/* default */.Z {\n  constructor() {\n    let props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    props = Array.isArray(props) ? {\n      children: props\n    } : props;\n    const {\n      children = []\n    } = props;\n    esm/* log.assert */.cM.assert(children.every(child => child instanceof scenegraph_node/* default */.Z), 'every child must an instance of ScenegraphNode');\n    super(props);\n    this.children = children;\n  }\n\n  add() {\n    for (var _len = arguments.length, children = new Array(_len), _key = 0; _key < _len; _key++) {\n      children[_key] = arguments[_key];\n    }\n\n    for (const child of children) {\n      if (Array.isArray(child)) {\n        this.add(...child);\n      } else {\n        this.children.push(child);\n      }\n    }\n\n    return this;\n  }\n\n  remove(child) {\n    const children = this.children;\n    const indexOf = children.indexOf(child);\n\n    if (indexOf > -1) {\n      children.splice(indexOf, 1);\n    }\n\n    return this;\n  }\n\n  removeAll() {\n    this.children = [];\n    return this;\n  }\n\n  delete() {\n    this.children.forEach(child => child.delete());\n    this.removeAll();\n    super.delete();\n  }\n\n  getBounds() {\n    const result = [[Infinity, Infinity, Infinity], [-Infinity, -Infinity, -Infinity]];\n    this.traverse((node, _ref) => {\n      let {\n        worldMatrix\n      } = _ref;\n      const bounds = node.getBounds();\n\n      if (!bounds) {\n        return;\n      }\n\n      const [min, max] = bounds;\n      const center = new vector3/* default */.Z(min).add(max).divide([2, 2, 2]);\n      worldMatrix.transformAsPoint(center, center);\n      const halfSize = new vector3/* default */.Z(max).subtract(min).divide([2, 2, 2]);\n      worldMatrix.transformAsVector(halfSize, halfSize);\n\n      for (let v = 0; v < 8; v++) {\n        const position = new vector3/* default */.Z(v & 0b001 ? -1 : 1, v & 0b010 ? -1 : 1, v & 0b100 ? -1 : 1).multiply(halfSize).add(center);\n\n        for (let i = 0; i < 3; i++) {\n          result[0][i] = Math.min(result[0][i], position[i]);\n          result[1][i] = Math.max(result[1][i], position[i]);\n        }\n      }\n    });\n\n    if (!Number.isFinite(result[0][0])) {\n      return null;\n    }\n\n    return result;\n  }\n\n  traverse(visitor) {\n    let {\n      worldMatrix = new matrix4/* default */.Z()\n    } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    const modelMatrix = new matrix4/* default */.Z(worldMatrix).multiplyRight(this.matrix);\n\n    for (const child of this.children) {\n      if (child instanceof GroupNode) {\n        child.traverse(visitor, {\n          worldMatrix: modelMatrix\n        });\n      } else {\n        visitor(child, {\n          worldMatrix: modelMatrix\n        });\n      }\n    }\n  }\n\n}\n//# sourceMappingURL=group-node.js.map\n// EXTERNAL MODULE: ./node_modules/@luma.gl/webgl/dist/esm/utils/assert.js\nvar assert = __webpack_require__(22525);\n// EXTERNAL MODULE: ./node_modules/@math.gl/core/dist/esm/classes/quaternion.js + 1 modules\nvar quaternion = __webpack_require__(43897);\n;// CONCATENATED MODULE: ./node_modules/@luma.gl/experimental/dist/esm/gltf/gltf-animator.js\n\n\nconst ATTRIBUTE_TYPE_TO_COMPONENTS = {\n  SCALAR: 1,\n  VEC2: 2,\n  VEC3: 3,\n  VEC4: 4,\n  MAT2: 4,\n  MAT3: 9,\n  MAT4: 16\n};\nconst ATTRIBUTE_COMPONENT_TYPE_TO_ARRAY = {\n  5120: Int8Array,\n  5121: Uint8Array,\n  5122: Int16Array,\n  5123: Uint16Array,\n  5125: Uint32Array,\n  5126: Float32Array\n};\n\nfunction accessorToJsArray(accessor) {\n  if (!accessor._animation) {\n    const ArrayType = ATTRIBUTE_COMPONENT_TYPE_TO_ARRAY[accessor.componentType];\n    const components = ATTRIBUTE_TYPE_TO_COMPONENTS[accessor.type];\n    const length = components * accessor.count;\n    const {\n      buffer,\n      byteOffset\n    } = accessor.bufferView.data;\n    const array = new ArrayType(buffer, byteOffset + (accessor.byteOffset || 0), length);\n\n    if (components === 1) {\n      accessor._animation = Array.from(array);\n    } else {\n      const slicedArray = [];\n\n      for (let i = 0; i < array.length; i += components) {\n        slicedArray.push(Array.from(array.slice(i, i + components)));\n      }\n\n      accessor._animation = slicedArray;\n    }\n  }\n\n  return accessor._animation;\n}\n\nconst helperMatrix = new matrix4/* default */.Z();\n\nfunction applyTranslationRotationScale(gltfNode, node) {\n  node.matrix.identity();\n\n  if (gltfNode.translation) {\n    node.matrix.translate(gltfNode.translation);\n  }\n\n  if (gltfNode.rotation) {\n    const rotationMatrix = helperMatrix.fromQuaternion(gltfNode.rotation);\n    node.matrix.multiplyRight(rotationMatrix);\n  }\n\n  if (gltfNode.scale) {\n    node.matrix.scale(gltfNode.scale);\n  }\n}\n\nconst gltf_animator_quaternion = new quaternion/* default */.Z();\n\nfunction linearInterpolate(target, path, start, stop, ratio) {\n  if (path === 'rotation') {\n    gltf_animator_quaternion.slerp({\n      start,\n      target: stop,\n      ratio\n    });\n\n    for (let i = 0; i < gltf_animator_quaternion.length; i++) {\n      target[path][i] = gltf_animator_quaternion[i];\n    }\n  } else {\n    for (let i = 0; i < start.length; i++) {\n      target[path][i] = ratio * stop[i] + (1 - ratio) * start[i];\n    }\n  }\n}\n\nfunction cubicsplineInterpolate(target, path, _ref) {\n  let {\n    p0,\n    outTangent0,\n    inTangent1,\n    p1,\n    tDiff,\n    ratio: t\n  } = _ref;\n\n  for (let i = 0; i < target[path].length; i++) {\n    const m0 = outTangent0[i] * tDiff;\n    const m1 = inTangent1[i] * tDiff;\n    target[path][i] = (2 * Math.pow(t, 3) - 3 * Math.pow(t, 2) + 1) * p0[i] + (Math.pow(t, 3) - 2 * Math.pow(t, 2) + t) * m0 + (-2 * Math.pow(t, 3) + 3 * Math.pow(t, 2)) * p1[i] + (Math.pow(t, 3) - Math.pow(t, 2)) * m1;\n  }\n}\n\nfunction stepInterpolate(target, path, value) {\n  for (let i = 0; i < value.length; i++) {\n    target[path][i] = value[i];\n  }\n}\n\nfunction interpolate(time, _ref2, target, path) {\n  let {\n    input,\n    interpolation,\n    output\n  } = _ref2;\n  const maxTime = input[input.length - 1];\n  const animationTime = time % maxTime;\n  const nextIndex = input.findIndex(t => t >= animationTime);\n  const previousIndex = Math.max(0, nextIndex - 1);\n\n  if (!Array.isArray(target[path])) {\n    switch (path) {\n      case 'translation':\n        target[path] = [0, 0, 0];\n        break;\n\n      case 'rotation':\n        target[path] = [0, 0, 0, 1];\n        break;\n\n      case 'scale':\n        target[path] = [1, 1, 1];\n        break;\n\n      default:\n        esm/* log.warn */.cM.warn(\"Bad animation path \".concat(path))();\n    }\n  }\n\n  (0,assert/* assert */.h)(target[path].length === output[previousIndex].length);\n  const previousTime = input[previousIndex];\n  const nextTime = input[nextIndex];\n\n  switch (interpolation) {\n    case 'STEP':\n      stepInterpolate(target, path, output[previousIndex]);\n      break;\n\n    case 'LINEAR':\n      if (nextTime > previousTime) {\n        const ratio = (animationTime - previousTime) / (nextTime - previousTime);\n        linearInterpolate(target, path, output[previousIndex], output[nextIndex], ratio);\n      }\n\n      break;\n\n    case 'CUBICSPLINE':\n      if (nextTime > previousTime) {\n        const ratio = (animationTime - previousTime) / (nextTime - previousTime);\n        const tDiff = nextTime - previousTime;\n        const p0 = output[3 * previousIndex + 1];\n        const outTangent0 = output[3 * previousIndex + 2];\n        const inTangent1 = output[3 * nextIndex + 0];\n        const p1 = output[3 * nextIndex + 1];\n        cubicsplineInterpolate(target, path, {\n          p0,\n          outTangent0,\n          inTangent1,\n          p1,\n          tDiff,\n          ratio\n        });\n      }\n\n      break;\n\n    default:\n      esm/* log.warn */.cM.warn(\"Interpolation \".concat(interpolation, \" not supported\"))();\n      break;\n  }\n}\n\nclass GLTFAnimation {\n  constructor(props) {\n    this.startTime = 0;\n    this.playing = true;\n    this.speed = 1;\n    this.channels = [];\n    Object.assign(this, props);\n  }\n\n  animate(timeMs) {\n    if (!this.playing) {\n      return;\n    }\n\n    const absTime = timeMs / 1000;\n    const time = (absTime - this.startTime) * this.speed;\n    this.channels.forEach(_ref3 => {\n      let {\n        sampler,\n        target,\n        path\n      } = _ref3;\n      interpolate(time, sampler, target, path);\n      applyTranslationRotationScale(target, target._node);\n    });\n  }\n\n}\n\nclass GLTFAnimator {\n  constructor(gltf) {\n    this.animations = gltf.animations.map((animation, index) => {\n      const name = animation.name || \"Animation-\".concat(index);\n      const samplers = animation.samplers.map(_ref4 => {\n        let {\n          input,\n          interpolation = 'LINEAR',\n          output\n        } = _ref4;\n        return {\n          input: accessorToJsArray(gltf.accessors[input]),\n          interpolation,\n          output: accessorToJsArray(gltf.accessors[output])\n        };\n      });\n      const channels = animation.channels.map(_ref5 => {\n        let {\n          sampler,\n          target\n        } = _ref5;\n        return {\n          sampler: samplers[sampler],\n          target: gltf.nodes[target.node],\n          path: target.path\n        };\n      });\n      return new GLTFAnimation({\n        name,\n        channels\n      });\n    });\n  }\n\n  animate(time) {\n    this.setTime(time);\n  }\n\n  setTime(time) {\n    this.animations.forEach(animation => animation.animate(time));\n  }\n\n  getAnimations() {\n    return this.animations;\n  }\n\n}\n//# sourceMappingURL=gltf-animator.js.map\n// EXTERNAL MODULE: ./node_modules/@luma.gl/shadertools/dist/esm/modules/pbr/pbr.js + 2 modules\nvar pbr = __webpack_require__(49764);\n// EXTERNAL MODULE: ./node_modules/@luma.gl/engine/dist/esm/lib/model.js + 1 modules\nvar model = __webpack_require__(80210);\n;// CONCATENATED MODULE: ./node_modules/@luma.gl/experimental/dist/esm/scenegraph/model-node.js\n\n\nclass ModelNode extends scenegraph_node/* default */.Z {\n  constructor(gl) {\n    let props = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    super(props);\n    this.onBeforeRender = null;\n    this.AfterRender = null;\n\n    if (gl instanceof model/* default */.Z) {\n      this.model = gl;\n\n      this._setModelNodeProps(props);\n    } else {\n      this.model = new model/* default */.Z(gl, props);\n    }\n\n    this.bounds = null;\n    this.managedResources = props.managedResources || [];\n  }\n\n  setProps(props) {\n    super.setProps(props);\n\n    this._setModelNodeProps(props);\n\n    return this;\n  }\n\n  getBounds() {\n    return this.bounds;\n  }\n\n  delete() {\n    if (this.model) {\n      this.model.delete();\n      this.model = null;\n    }\n\n    this.managedResources.forEach(resource => resource.delete());\n    this.managedResources = [];\n  }\n\n  draw() {\n    return this.model.draw(...arguments);\n  }\n\n  setUniforms() {\n    this.model.setUniforms(...arguments);\n    return this;\n  }\n\n  setAttributes() {\n    this.model.setAttributes(...arguments);\n    return this;\n  }\n\n  updateModuleSettings() {\n    this.model.updateModuleSettings(...arguments);\n    return this;\n  }\n\n  _setModelNodeProps(props) {\n    this.model.setProps(props);\n  }\n\n}\n//# sourceMappingURL=model-node.js.map\n// EXTERNAL MODULE: ./node_modules/@luma.gl/webgl/dist/esm/features/features.js\nvar features = __webpack_require__(44211);\n// EXTERNAL MODULE: ./node_modules/@luma.gl/webgl/dist/esm/features/webgl-features-table.js\nvar webgl_features_table = __webpack_require__(6948);\n// EXTERNAL MODULE: ./node_modules/@luma.gl/webgl/dist/esm/classes/texture-2d.js + 1 modules\nvar texture_2d = __webpack_require__(51621);\n;// CONCATENATED MODULE: ./node_modules/@luma.gl/experimental/dist/esm/gltf/gltf-material-parser.js\n\nclass GLTFMaterialParser {\n  constructor(gl, _ref) {\n    let {\n      attributes,\n      material,\n      pbrDebug,\n      imageBasedLightingEnvironment,\n      lights,\n      useTangents\n    } = _ref;\n    this.gl = gl;\n    this.defines = {\n      MANUAL_SRGB: 1,\n      SRGB_FAST_APPROXIMATION: 1\n    };\n\n    if ((0,features/* hasFeature */.U6)(gl, webgl_features_table/* FEATURES.GLSL_TEXTURE_LOD */.h.GLSL_TEXTURE_LOD)) {\n      this.defines.USE_TEX_LOD = 1;\n    }\n\n    this.uniforms = {\n      u_Camera: [0, 0, 0],\n      u_MetallicRoughnessValues: [1, 1]\n    };\n    this.parameters = {};\n    this.generatedTextures = [];\n\n    if (imageBasedLightingEnvironment) {\n      this.uniforms.u_DiffuseEnvSampler = imageBasedLightingEnvironment.getDiffuseEnvSampler();\n      this.uniforms.u_SpecularEnvSampler = imageBasedLightingEnvironment.getSpecularEnvSampler();\n      this.uniforms.u_brdfLUT = imageBasedLightingEnvironment.getBrdfTexture();\n      this.uniforms.u_ScaleIBLAmbient = [1, 1];\n    }\n\n    if (pbrDebug) {\n      this.uniforms.u_ScaleDiffBaseMR = [0, 0, 0, 0];\n      this.uniforms.u_ScaleFGDSpec = [0, 0, 0, 0];\n    }\n\n    this.defineIfPresent(attributes.NORMAL, 'HAS_NORMALS');\n    this.defineIfPresent(attributes.TANGENT && useTangents, 'HAS_TANGENTS');\n    this.defineIfPresent(attributes.TEXCOORD_0, 'HAS_UV');\n    this.defineIfPresent(imageBasedLightingEnvironment, 'USE_IBL');\n    this.defineIfPresent(lights, 'USE_LIGHTS');\n    this.defineIfPresent(pbrDebug, 'PBR_DEBUG');\n\n    if (material) {\n      this.parseMaterial(material);\n    }\n  }\n\n  defineIfPresent(value, name) {\n    if (value) {\n      this.defines[name] = 1;\n    }\n  }\n\n  parseTexture(gltfTexture, name) {\n    let define = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n    const parameters = gltfTexture.texture && gltfTexture.texture.sampler && gltfTexture.texture.sampler.parameters || {};\n    const image = gltfTexture.texture.source.image;\n    let textureOptions;\n    let specialTextureParameters = {};\n\n    if (image.compressed) {\n      textureOptions = image;\n      specialTextureParameters = {\n        [this.gl.TEXTURE_MIN_FILTER]: image.data.length > 1 ? this.gl.LINEAR_MIPMAP_NEAREST : this.gl.LINEAR\n      };\n    } else {\n      textureOptions = {\n        data: image\n      };\n    }\n\n    const texture = new texture_2d/* default */.Z(this.gl, {\n      id: gltfTexture.name || gltfTexture.id,\n      parameters: { ...parameters,\n        ...specialTextureParameters\n      },\n      pixelStore: {\n        [this.gl.UNPACK_FLIP_Y_WEBGL]: false\n      },\n      ...textureOptions\n    });\n    this.uniforms[name] = texture;\n    this.defineIfPresent(define, define);\n    this.generatedTextures.push(texture);\n  }\n\n  parsePbrMetallicRoughness(pbrMetallicRoughness) {\n    if (pbrMetallicRoughness.baseColorTexture) {\n      this.parseTexture(pbrMetallicRoughness.baseColorTexture, 'u_BaseColorSampler', 'HAS_BASECOLORMAP');\n    }\n\n    this.uniforms.u_BaseColorFactor = pbrMetallicRoughness.baseColorFactor || [1, 1, 1, 1];\n\n    if (pbrMetallicRoughness.metallicRoughnessTexture) {\n      this.parseTexture(pbrMetallicRoughness.metallicRoughnessTexture, 'u_MetallicRoughnessSampler', 'HAS_METALROUGHNESSMAP');\n    }\n\n    const {\n      metallicFactor = 1,\n      roughnessFactor = 1\n    } = pbrMetallicRoughness;\n    this.uniforms.u_MetallicRoughnessValues = [metallicFactor, roughnessFactor];\n  }\n\n  parseMaterial(material) {\n    this.uniforms.pbr_uUnlit = Boolean(material.unlit);\n\n    if (material.pbrMetallicRoughness) {\n      this.parsePbrMetallicRoughness(material.pbrMetallicRoughness);\n    }\n\n    if (material.normalTexture) {\n      this.parseTexture(material.normalTexture, 'u_NormalSampler', 'HAS_NORMALMAP');\n      const {\n        scale = 1\n      } = material.normalTexture;\n      this.uniforms.u_NormalScale = scale;\n    }\n\n    if (material.occlusionTexture) {\n      this.parseTexture(material.occlusionTexture, 'u_OcclusionSampler', 'HAS_OCCLUSIONMAP');\n      const {\n        strength = 1\n      } = material.occlusionTexture;\n      this.uniforms.u_OcclusionStrength = strength;\n    }\n\n    if (material.emissiveTexture) {\n      this.parseTexture(material.emissiveTexture, 'u_EmissiveSampler', 'HAS_EMISSIVEMAP');\n      this.uniforms.u_EmissiveFactor = material.emissiveFactor || [0, 0, 0];\n    }\n\n    if (material.alphaMode === 'MASK') {\n      const {\n        alphaCutoff = 0.5\n      } = material;\n      this.defines.ALPHA_CUTOFF = 1;\n      this.uniforms.u_AlphaCutoff = alphaCutoff;\n    } else if (material.alphaMode === 'BLEND') {\n      esm/* log.warn */.cM.warn('BLEND alphaMode might not work well because it requires mesh sorting')();\n      Object.assign(this.parameters, {\n        blend: true,\n        blendEquation: this.gl.FUNC_ADD,\n        blendFunc: [this.gl.SRC_ALPHA, this.gl.ONE_MINUS_SRC_ALPHA, this.gl.ONE, this.gl.ONE_MINUS_SRC_ALPHA]\n      });\n    }\n  }\n\n  delete() {\n    this.generatedTextures.forEach(texture => texture.delete());\n  }\n\n}\n//# sourceMappingURL=gltf-material-parser.js.map\n;// CONCATENATED MODULE: ./node_modules/@luma.gl/experimental/dist/esm/gltf/create-gltf-model.js\n\n\n\n\n\nconst vs = \"\\n#if (__VERSION__ < 300)\\n  #define _attr attribute\\n#else\\n  #define _attr in\\n#endif\\n\\n  _attr vec4 POSITION;\\n\\n  #ifdef HAS_NORMALS\\n    _attr vec4 NORMAL;\\n  #endif\\n\\n  #ifdef HAS_TANGENTS\\n    _attr vec4 TANGENT;\\n  #endif\\n\\n  #ifdef HAS_UV\\n    _attr vec2 TEXCOORD_0;\\n  #endif\\n\\n  void main(void) {\\n    vec4 _NORMAL = vec4(0.);\\n    vec4 _TANGENT = vec4(0.);\\n    vec2 _TEXCOORD_0 = vec2(0.);\\n\\n    #ifdef HAS_NORMALS\\n      _NORMAL = NORMAL;\\n    #endif\\n\\n    #ifdef HAS_TANGENTS\\n      _TANGENT = TANGENT;\\n    #endif\\n\\n    #ifdef HAS_UV\\n      _TEXCOORD_0 = TEXCOORD_0;\\n    #endif\\n\\n    pbr_setPositionNormalTangentUV(POSITION, _NORMAL, _TANGENT, _TEXCOORD_0);\\n    gl_Position = u_MVPMatrix * POSITION;\\n  }\\n\";\nconst fs = \"\\n#if (__VERSION__ < 300)\\n  #define fragmentColor gl_FragColor\\n#else\\n  out vec4 fragmentColor;\\n#endif\\n\\n  void main(void) {\\n    fragmentColor = pbr_filterColor(vec4(0));\\n  }\\n\";\n\nfunction addVersionToShader(gl, source) {\n  if ((0,esm/* isWebGL2 */.D0)(gl)) {\n    return \"#version 300 es\\n\".concat(source);\n  }\n\n  return source;\n}\n\nfunction createGLTFModel(gl, options) {\n  const {\n    id,\n    drawMode,\n    vertexCount,\n    attributes,\n    modelOptions\n  } = options;\n  const materialParser = new GLTFMaterialParser(gl, options);\n  esm/* log.info */.cM.info(4, 'createGLTFModel defines: ', materialParser.defines)();\n  const managedResources = [];\n  managedResources.push(...materialParser.generatedTextures);\n  managedResources.push(...Object.values(attributes).map(attribute => attribute.buffer));\n  const model = new ModelNode(gl, Object.assign({\n    id,\n    drawMode,\n    vertexCount,\n    modules: [pbr/* pbr */.b],\n    defines: materialParser.defines,\n    parameters: materialParser.parameters,\n    vs: addVersionToShader(gl, vs),\n    fs: addVersionToShader(gl, fs),\n    managedResources\n  }, modelOptions));\n  model.setProps({\n    attributes\n  });\n  model.setUniforms(materialParser.uniforms);\n  return model;\n}\n//# sourceMappingURL=create-gltf-model.js.map\n;// CONCATENATED MODULE: ./node_modules/@luma.gl/experimental/dist/esm/gltf/gltf-instantiator.js\n\n\n\n\n\nconst gltf_instantiator_ATTRIBUTE_TYPE_TO_COMPONENTS = {\n  SCALAR: 1,\n  VEC2: 2,\n  VEC3: 3,\n  VEC4: 4,\n  MAT2: 4,\n  MAT3: 9,\n  MAT4: 16\n};\nconst DEFAULT_OPTIONS = {\n  modelOptions: {},\n  pbrDebug: false,\n  imageBasedLightingEnvironment: null,\n  lights: true,\n  useTangents: false\n};\nclass GLTFInstantiator {\n  constructor(gl) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    this.gl = gl;\n    this.options = Object.assign({}, DEFAULT_OPTIONS, options);\n  }\n\n  instantiate(gltf) {\n    this.gltf = gltf;\n    const scenes = (gltf.scenes || []).map(scene => this.createScene(scene));\n    return scenes;\n  }\n\n  createAnimator() {\n    if (Array.isArray(this.gltf.animations)) {\n      return new GLTFAnimator(this.gltf);\n    }\n\n    return null;\n  }\n\n  createScene(gltfScene) {\n    const gltfNodes = gltfScene.nodes || [];\n    const nodes = gltfNodes.map(node => this.createNode(node));\n    const scene = new GroupNode({\n      id: gltfScene.name || gltfScene.id,\n      children: nodes\n    });\n    return scene;\n  }\n\n  createNode(gltfNode) {\n    if (!gltfNode._node) {\n      const gltfChildren = gltfNode.children || [];\n      const children = gltfChildren.map(child => this.createNode(child));\n\n      if (gltfNode.mesh) {\n        children.push(this.createMesh(gltfNode.mesh));\n      }\n\n      const node = new GroupNode({\n        id: gltfNode.name || gltfNode.id,\n        children\n      });\n\n      if (gltfNode.matrix) {\n        node.setMatrix(gltfNode.matrix);\n      } else {\n        node.matrix.identity();\n\n        if (gltfNode.translation) {\n          node.matrix.translate(gltfNode.translation);\n        }\n\n        if (gltfNode.rotation) {\n          const rotationMatrix = new matrix4/* default */.Z().fromQuaternion(gltfNode.rotation);\n          node.matrix.multiplyRight(rotationMatrix);\n        }\n\n        if (gltfNode.scale) {\n          node.matrix.scale(gltfNode.scale);\n        }\n      }\n\n      gltfNode._node = node;\n    }\n\n    return gltfNode._node;\n  }\n\n  createMesh(gltfMesh) {\n    if (!gltfMesh._mesh) {\n      const gltfPrimitives = gltfMesh.primitives || [];\n      const primitives = gltfPrimitives.map((gltfPrimitive, i) => this.createPrimitive(gltfPrimitive, i, gltfMesh));\n      const mesh = new GroupNode({\n        id: gltfMesh.name || gltfMesh.id,\n        children: primitives\n      });\n      gltfMesh._mesh = mesh;\n    }\n\n    return gltfMesh._mesh;\n  }\n\n  getVertexCount(attributes) {\n    esm/* log.warn */.cM.warn('getVertexCount() not found')();\n  }\n\n  createPrimitive(gltfPrimitive, i, gltfMesh) {\n    const model = createGLTFModel(this.gl, Object.assign({\n      id: gltfPrimitive.name || \"\".concat(gltfMesh.name || gltfMesh.id, \"-primitive-\").concat(i),\n      drawMode: gltfPrimitive.mode || 4,\n      vertexCount: gltfPrimitive.indices ? gltfPrimitive.indices.count : this.getVertexCount(gltfPrimitive.attributes),\n      attributes: this.createAttributes(gltfPrimitive.attributes, gltfPrimitive.indices),\n      material: gltfPrimitive.material\n    }, this.options));\n    model.bounds = [gltfPrimitive.attributes.POSITION.min, gltfPrimitive.attributes.POSITION.max];\n    return model;\n  }\n\n  createAttributes(attributes, indices) {\n    const loadedAttributes = {};\n    Object.keys(attributes).forEach(attrName => {\n      loadedAttributes[attrName] = this.createAccessor(attributes[attrName], this.createBuffer(attributes[attrName], this.gl.ARRAY_BUFFER));\n    });\n\n    if (indices) {\n      loadedAttributes.indices = this.createAccessor(indices, this.createBuffer(indices, this.gl.ELEMENT_ARRAY_BUFFER));\n    }\n\n    esm/* log.info */.cM.info(4, 'glTF Attributes', {\n      attributes,\n      indices,\n      generated: loadedAttributes\n    })();\n    return loadedAttributes;\n  }\n\n  createBuffer(attribute, target) {\n    if (!attribute.bufferView) {\n      attribute.bufferView = {};\n    }\n\n    const {\n      bufferView\n    } = attribute;\n\n    if (!bufferView.lumaBuffers) {\n      bufferView.lumaBuffers = {};\n    }\n\n    if (!bufferView.lumaBuffers[target]) {\n      bufferView.lumaBuffers[target] = new buffer/* default */.Z(this.gl, {\n        id: \"from-\".concat(bufferView.id),\n        data: bufferView.data || attribute.value,\n        target\n      });\n    }\n\n    return bufferView.lumaBuffers[target];\n  }\n\n  createAccessor(accessor, buffer) {\n    return new classes_accessor/* default */.Z({\n      buffer,\n      offset: accessor.byteOffset || 0,\n      stride: accessor.bufferView.byteStride || 0,\n      type: accessor.componentType,\n      size: gltf_instantiator_ATTRIBUTE_TYPE_TO_COMPONENTS[accessor.type]\n    });\n  }\n\n  createSampler(gltfSampler) {\n    return gltfSampler;\n  }\n\n  needsPOT() {\n    return false;\n  }\n\n}\n//# sourceMappingURL=gltf-instantiator.js.map\n;// CONCATENATED MODULE: ./node_modules/@luma.gl/experimental/dist/esm/gltf/create-gltf-objects.js\n\nfunction createGLTFObjects(gl, gltf, options) {\n  const instantiator = new GLTFInstantiator(gl, options);\n  const scenes = instantiator.instantiate(gltf);\n  const animator = instantiator.createAnimator();\n  return {\n    scenes,\n    animator\n  };\n}\n//# sourceMappingURL=create-gltf-objects.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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O0FBQ1o7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07O0FBRU47QUFDQTtBQUNBOztBQUVBO0FBQ0EsMkNBQTJDLHFCQUFNO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsZUFBZSwrQkFBUTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksOENBQTRCO0FBQ3hDLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsNkM7O0FDdExtRDtBQUNwQztBQUNmLDJCQUEyQixnQkFBZ0I7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3Z1ZTMtd2VicGFjazUvLi9ub2RlX21vZHVsZXMvQGx1bWEuZ2wvZXhwZXJpbWVudGFsL2Rpc3QvZXNtL3NjZW5lZ3JhcGgvZ3JvdXAtbm9kZS5qcz82MjRhIiwid2VicGFjazovL3Z1ZTMtd2VicGFjazUvLi9ub2RlX21vZHVsZXMvQGx1bWEuZ2wvZXhwZXJpbWVudGFsL2Rpc3QvZXNtL2dsdGYvZ2x0Zi1hbmltYXRvci5qcz9mNmQ5Iiwid2VicGFjazovL3Z1ZTMtd2VicGFjazUvLi9ub2RlX21vZHVsZXMvQGx1bWEuZ2wvZXhwZXJpbWVudGFsL2Rpc3QvZXNtL3NjZW5lZ3JhcGgvbW9kZWwtbm9kZS5qcz83MmE4Iiwid2VicGFjazovL3Z1ZTMtd2VicGFjazUvLi9ub2RlX21vZHVsZXMvQGx1bWEuZ2wvZXhwZXJpbWVudGFsL2Rpc3QvZXNtL2dsdGYvZ2x0Zi1tYXRlcmlhbC1wYXJzZXIuanM/MWUxOCIsIndlYnBhY2s6Ly92dWUzLXdlYnBhY2s1Ly4vbm9kZV9tb2R1bGVzL0BsdW1hLmdsL2V4cGVyaW1lbnRhbC9kaXN0L2VzbS9nbHRmL2NyZWF0ZS1nbHRmLW1vZGVsLmpzPzViOGQiLCJ3ZWJwYWNrOi8vdnVlMy13ZWJwYWNrNS8uL25vZGVfbW9kdWxlcy9AbHVtYS5nbC9leHBlcmltZW50YWwvZGlzdC9lc20vZ2x0Zi9nbHRmLWluc3RhbnRpYXRvci5qcz8zOTNlIiwid2VicGFjazovL3Z1ZTMtd2VicGFjazUvLi9ub2RlX21vZHVsZXMvQGx1bWEuZ2wvZXhwZXJpbWVudGFsL2Rpc3QvZXNtL2dsdGYvY3JlYXRlLWdsdGYtb2JqZWN0cy5qcz8xNzMwIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IE1hdHJpeDQsIFZlY3RvcjMgfSBmcm9tICdAbWF0aC5nbC9jb3JlJztcbmltcG9ydCB7IGxvZyB9IGZyb20gJ0BsdW1hLmdsL3dlYmdsJztcbmltcG9ydCBTY2VuZWdyYXBoTm9kZSBmcm9tICcuL3NjZW5lZ3JhcGgtbm9kZSc7XG5leHBvcnQgZGVmYXVsdCBjbGFzcyBHcm91cE5vZGUgZXh0ZW5kcyBTY2VuZWdyYXBoTm9kZSB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIGxldCBwcm9wcyA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge307XG4gICAgcHJvcHMgPSBBcnJheS5pc0FycmF5KHByb3BzKSA/IHtcbiAgICAgIGNoaWxkcmVuOiBwcm9wc1xuICAgIH0gOiBwcm9wcztcbiAgICBjb25zdCB7XG4gICAgICBjaGlsZHJlbiA9IFtdXG4gICAgfSA9IHByb3BzO1xuICAgIGxvZy5hc3NlcnQoY2hpbGRyZW4uZXZlcnkoY2hpbGQgPT4gY2hpbGQgaW5zdGFuY2VvZiBTY2VuZWdyYXBoTm9kZSksICdldmVyeSBjaGlsZCBtdXN0IGFuIGluc3RhbmNlIG9mIFNjZW5lZ3JhcGhOb2RlJyk7XG4gICAgc3VwZXIocHJvcHMpO1xuICAgIHRoaXMuY2hpbGRyZW4gPSBjaGlsZHJlbjtcbiAgfVxuXG4gIGFkZCgpIHtcbiAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgY2hpbGRyZW4gPSBuZXcgQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICBjaGlsZHJlbltfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICB9XG5cbiAgICBmb3IgKGNvbnN0IGNoaWxkIG9mIGNoaWxkcmVuKSB7XG4gICAgICBpZiAoQXJyYXkuaXNBcnJheShjaGlsZCkpIHtcbiAgICAgICAgdGhpcy5hZGQoLi4uY2hpbGQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5jaGlsZHJlbi5wdXNoKGNoaWxkKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIHJlbW92ZShjaGlsZCkge1xuICAgIGNvbnN0IGNoaWxkcmVuID0gdGhpcy5jaGlsZHJlbjtcbiAgICBjb25zdCBpbmRleE9mID0gY2hpbGRyZW4uaW5kZXhPZihjaGlsZCk7XG5cbiAgICBpZiAoaW5kZXhPZiA+IC0xKSB7XG4gICAgICBjaGlsZHJlbi5zcGxpY2UoaW5kZXhPZiwgMSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICByZW1vdmVBbGwoKSB7XG4gICAgdGhpcy5jaGlsZHJlbiA9IFtdO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgZGVsZXRlKCkge1xuICAgIHRoaXMuY2hpbGRyZW4uZm9yRWFjaChjaGlsZCA9PiBjaGlsZC5kZWxldGUoKSk7XG4gICAgdGhpcy5yZW1vdmVBbGwoKTtcbiAgICBzdXBlci5kZWxldGUoKTtcbiAgfVxuXG4gIGdldEJvdW5kcygpIHtcbiAgICBjb25zdCByZXN1bHQgPSBbW0luZmluaXR5LCBJbmZpbml0eSwgSW5maW5pdHldLCBbLUluZmluaXR5LCAtSW5maW5pdHksIC1JbmZpbml0eV1dO1xuICAgIHRoaXMudHJhdmVyc2UoKG5vZGUsIF9yZWYpID0+IHtcbiAgICAgIGxldCB7XG4gICAgICAgIHdvcmxkTWF0cml4XG4gICAgICB9ID0gX3JlZjtcbiAgICAgIGNvbnN0IGJvdW5kcyA9IG5vZGUuZ2V0Qm91bmRzKCk7XG5cbiAgICAgIGlmICghYm91bmRzKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgY29uc3QgW21pbiwgbWF4XSA9IGJvdW5kcztcbiAgICAgIGNvbnN0IGNlbnRlciA9IG5ldyBWZWN0b3IzKG1pbikuYWRkKG1heCkuZGl2aWRlKFsyLCAyLCAyXSk7XG4gICAgICB3b3JsZE1hdHJpeC50cmFuc2Zvcm1Bc1BvaW50KGNlbnRlciwgY2VudGVyKTtcbiAgICAgIGNvbnN0IGhhbGZTaXplID0gbmV3IFZlY3RvcjMobWF4KS5zdWJ0cmFjdChtaW4pLmRpdmlkZShbMiwgMiwgMl0pO1xuICAgICAgd29ybGRNYXRyaXgudHJhbnNmb3JtQXNWZWN0b3IoaGFsZlNpemUsIGhhbGZTaXplKTtcblxuICAgICAgZm9yIChsZXQgdiA9IDA7IHYgPCA4OyB2KyspIHtcbiAgICAgICAgY29uc3QgcG9zaXRpb24gPSBuZXcgVmVjdG9yMyh2ICYgMGIwMDEgPyAtMSA6IDEsIHYgJiAwYjAxMCA/IC0xIDogMSwgdiAmIDBiMTAwID8gLTEgOiAxKS5tdWx0aXBseShoYWxmU2l6ZSkuYWRkKGNlbnRlcik7XG5cbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCAzOyBpKyspIHtcbiAgICAgICAgICByZXN1bHRbMF1baV0gPSBNYXRoLm1pbihyZXN1bHRbMF1baV0sIHBvc2l0aW9uW2ldKTtcbiAgICAgICAgICByZXN1bHRbMV1baV0gPSBNYXRoLm1heChyZXN1bHRbMV1baV0sIHBvc2l0aW9uW2ldKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuXG4gICAgaWYgKCFOdW1iZXIuaXNGaW5pdGUocmVzdWx0WzBdWzBdKSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIHRyYXZlcnNlKHZpc2l0b3IpIHtcbiAgICBsZXQge1xuICAgICAgd29ybGRNYXRyaXggPSBuZXcgTWF0cml4NCgpXG4gICAgfSA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG4gICAgY29uc3QgbW9kZWxNYXRyaXggPSBuZXcgTWF0cml4NCh3b3JsZE1hdHJpeCkubXVsdGlwbHlSaWdodCh0aGlzLm1hdHJpeCk7XG5cbiAgICBmb3IgKGNvbnN0IGNoaWxkIG9mIHRoaXMuY2hpbGRyZW4pIHtcbiAgICAgIGlmIChjaGlsZCBpbnN0YW5jZW9mIEdyb3VwTm9kZSkge1xuICAgICAgICBjaGlsZC50cmF2ZXJzZSh2aXNpdG9yLCB7XG4gICAgICAgICAgd29ybGRNYXRyaXg6IG1vZGVsTWF0cml4XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmlzaXRvcihjaGlsZCwge1xuICAgICAgICAgIHdvcmxkTWF0cml4OiBtb2RlbE1hdHJpeFxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Z3JvdXAtbm9kZS5qcy5tYXAiLCJpbXBvcnQgeyBhc3NlcnQsIGxvZyB9IGZyb20gJ0BsdW1hLmdsL3dlYmdsJztcbmltcG9ydCB7IE1hdHJpeDQsIFF1YXRlcm5pb24gfSBmcm9tICdAbWF0aC5nbC9jb3JlJztcbmV4cG9ydCBjb25zdCBBVFRSSUJVVEVfVFlQRV9UT19DT01QT05FTlRTID0ge1xuICBTQ0FMQVI6IDEsXG4gIFZFQzI6IDIsXG4gIFZFQzM6IDMsXG4gIFZFQzQ6IDQsXG4gIE1BVDI6IDQsXG4gIE1BVDM6IDksXG4gIE1BVDQ6IDE2XG59O1xuZXhwb3J0IGNvbnN0IEFUVFJJQlVURV9DT01QT05FTlRfVFlQRV9UT19BUlJBWSA9IHtcbiAgNTEyMDogSW50OEFycmF5LFxuICA1MTIxOiBVaW50OEFycmF5LFxuICA1MTIyOiBJbnQxNkFycmF5LFxuICA1MTIzOiBVaW50MTZBcnJheSxcbiAgNTEyNTogVWludDMyQXJyYXksXG4gIDUxMjY6IEZsb2F0MzJBcnJheVxufTtcblxuZnVuY3Rpb24gYWNjZXNzb3JUb0pzQXJyYXkoYWNjZXNzb3IpIHtcbiAgaWYgKCFhY2Nlc3Nvci5fYW5pbWF0aW9uKSB7XG4gICAgY29uc3QgQXJyYXlUeXBlID0gQVRUUklCVVRFX0NPTVBPTkVOVF9UWVBFX1RPX0FSUkFZW2FjY2Vzc29yLmNvbXBvbmVudFR5cGVdO1xuICAgIGNvbnN0IGNvbXBvbmVudHMgPSBBVFRSSUJVVEVfVFlQRV9UT19DT01QT05FTlRTW2FjY2Vzc29yLnR5cGVdO1xuICAgIGNvbnN0IGxlbmd0aCA9IGNvbXBvbmVudHMgKiBhY2Nlc3Nvci5jb3VudDtcbiAgICBjb25zdCB7XG4gICAgICBidWZmZXIsXG4gICAgICBieXRlT2Zmc2V0XG4gICAgfSA9IGFjY2Vzc29yLmJ1ZmZlclZpZXcuZGF0YTtcbiAgICBjb25zdCBhcnJheSA9IG5ldyBBcnJheVR5cGUoYnVmZmVyLCBieXRlT2Zmc2V0ICsgKGFjY2Vzc29yLmJ5dGVPZmZzZXQgfHwgMCksIGxlbmd0aCk7XG5cbiAgICBpZiAoY29tcG9uZW50cyA9PT0gMSkge1xuICAgICAgYWNjZXNzb3IuX2FuaW1hdGlvbiA9IEFycmF5LmZyb20oYXJyYXkpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBzbGljZWRBcnJheSA9IFtdO1xuXG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGFycmF5Lmxlbmd0aDsgaSArPSBjb21wb25lbnRzKSB7XG4gICAgICAgIHNsaWNlZEFycmF5LnB1c2goQXJyYXkuZnJvbShhcnJheS5zbGljZShpLCBpICsgY29tcG9uZW50cykpKTtcbiAgICAgIH1cblxuICAgICAgYWNjZXNzb3IuX2FuaW1hdGlvbiA9IHNsaWNlZEFycmF5O1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBhY2Nlc3Nvci5fYW5pbWF0aW9uO1xufVxuXG5jb25zdCBoZWxwZXJNYXRyaXggPSBuZXcgTWF0cml4NCgpO1xuXG5mdW5jdGlvbiBhcHBseVRyYW5zbGF0aW9uUm90YXRpb25TY2FsZShnbHRmTm9kZSwgbm9kZSkge1xuICBub2RlLm1hdHJpeC5pZGVudGl0eSgpO1xuXG4gIGlmIChnbHRmTm9kZS50cmFuc2xhdGlvbikge1xuICAgIG5vZGUubWF0cml4LnRyYW5zbGF0ZShnbHRmTm9kZS50cmFuc2xhdGlvbik7XG4gIH1cblxuICBpZiAoZ2x0Zk5vZGUucm90YXRpb24pIHtcbiAgICBjb25zdCByb3RhdGlvbk1hdHJpeCA9IGhlbHBlck1hdHJpeC5mcm9tUXVhdGVybmlvbihnbHRmTm9kZS5yb3RhdGlvbik7XG4gICAgbm9kZS5tYXRyaXgubXVsdGlwbHlSaWdodChyb3RhdGlvbk1hdHJpeCk7XG4gIH1cblxuICBpZiAoZ2x0Zk5vZGUuc2NhbGUpIHtcbiAgICBub2RlLm1hdHJpeC5zY2FsZShnbHRmTm9kZS5zY2FsZSk7XG4gIH1cbn1cblxuY29uc3QgcXVhdGVybmlvbiA9IG5ldyBRdWF0ZXJuaW9uKCk7XG5cbmZ1bmN0aW9uIGxpbmVhckludGVycG9sYXRlKHRhcmdldCwgcGF0aCwgc3RhcnQsIHN0b3AsIHJhdGlvKSB7XG4gIGlmIChwYXRoID09PSAncm90YXRpb24nKSB7XG4gICAgcXVhdGVybmlvbi5zbGVycCh7XG4gICAgICBzdGFydCxcbiAgICAgIHRhcmdldDogc3RvcCxcbiAgICAgIHJhdGlvXG4gICAgfSk7XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHF1YXRlcm5pb24ubGVuZ3RoOyBpKyspIHtcbiAgICAgIHRhcmdldFtwYXRoXVtpXSA9IHF1YXRlcm5pb25baV07XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc3RhcnQubGVuZ3RoOyBpKyspIHtcbiAgICAgIHRhcmdldFtwYXRoXVtpXSA9IHJhdGlvICogc3RvcFtpXSArICgxIC0gcmF0aW8pICogc3RhcnRbaV07XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGN1Ymljc3BsaW5lSW50ZXJwb2xhdGUodGFyZ2V0LCBwYXRoLCBfcmVmKSB7XG4gIGxldCB7XG4gICAgcDAsXG4gICAgb3V0VGFuZ2VudDAsXG4gICAgaW5UYW5nZW50MSxcbiAgICBwMSxcbiAgICB0RGlmZixcbiAgICByYXRpbzogdFxuICB9ID0gX3JlZjtcblxuICBmb3IgKGxldCBpID0gMDsgaSA8IHRhcmdldFtwYXRoXS5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IG0wID0gb3V0VGFuZ2VudDBbaV0gKiB0RGlmZjtcbiAgICBjb25zdCBtMSA9IGluVGFuZ2VudDFbaV0gKiB0RGlmZjtcbiAgICB0YXJnZXRbcGF0aF1baV0gPSAoMiAqIE1hdGgucG93KHQsIDMpIC0gMyAqIE1hdGgucG93KHQsIDIpICsgMSkgKiBwMFtpXSArIChNYXRoLnBvdyh0LCAzKSAtIDIgKiBNYXRoLnBvdyh0LCAyKSArIHQpICogbTAgKyAoLTIgKiBNYXRoLnBvdyh0LCAzKSArIDMgKiBNYXRoLnBvdyh0LCAyKSkgKiBwMVtpXSArIChNYXRoLnBvdyh0LCAzKSAtIE1hdGgucG93KHQsIDIpKSAqIG0xO1xuICB9XG59XG5cbmZ1bmN0aW9uIHN0ZXBJbnRlcnBvbGF0ZSh0YXJnZXQsIHBhdGgsIHZhbHVlKSB7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgdmFsdWUubGVuZ3RoOyBpKyspIHtcbiAgICB0YXJnZXRbcGF0aF1baV0gPSB2YWx1ZVtpXTtcbiAgfVxufVxuXG5mdW5jdGlvbiBpbnRlcnBvbGF0ZSh0aW1lLCBfcmVmMiwgdGFyZ2V0LCBwYXRoKSB7XG4gIGxldCB7XG4gICAgaW5wdXQsXG4gICAgaW50ZXJwb2xhdGlvbixcbiAgICBvdXRwdXRcbiAgfSA9IF9yZWYyO1xuICBjb25zdCBtYXhUaW1lID0gaW5wdXRbaW5wdXQubGVuZ3RoIC0gMV07XG4gIGNvbnN0IGFuaW1hdGlvblRpbWUgPSB0aW1lICUgbWF4VGltZTtcbiAgY29uc3QgbmV4dEluZGV4ID0gaW5wdXQuZmluZEluZGV4KHQgPT4gdCA+PSBhbmltYXRpb25UaW1lKTtcbiAgY29uc3QgcHJldmlvdXNJbmRleCA9IE1hdGgubWF4KDAsIG5leHRJbmRleCAtIDEpO1xuXG4gIGlmICghQXJyYXkuaXNBcnJheSh0YXJnZXRbcGF0aF0pKSB7XG4gICAgc3dpdGNoIChwYXRoKSB7XG4gICAgICBjYXNlICd0cmFuc2xhdGlvbic6XG4gICAgICAgIHRhcmdldFtwYXRoXSA9IFswLCAwLCAwXTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgJ3JvdGF0aW9uJzpcbiAgICAgICAgdGFyZ2V0W3BhdGhdID0gWzAsIDAsIDAsIDFdO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSAnc2NhbGUnOlxuICAgICAgICB0YXJnZXRbcGF0aF0gPSBbMSwgMSwgMV07XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICBsb2cud2FybihcIkJhZCBhbmltYXRpb24gcGF0aCBcIi5jb25jYXQocGF0aCkpKCk7XG4gICAgfVxuICB9XG5cbiAgYXNzZXJ0KHRhcmdldFtwYXRoXS5sZW5ndGggPT09IG91dHB1dFtwcmV2aW91c0luZGV4XS5sZW5ndGgpO1xuICBjb25zdCBwcmV2aW91c1RpbWUgPSBpbnB1dFtwcmV2aW91c0luZGV4XTtcbiAgY29uc3QgbmV4dFRpbWUgPSBpbnB1dFtuZXh0SW5kZXhdO1xuXG4gIHN3aXRjaCAoaW50ZXJwb2xhdGlvbikge1xuICAgIGNhc2UgJ1NURVAnOlxuICAgICAgc3RlcEludGVycG9sYXRlKHRhcmdldCwgcGF0aCwgb3V0cHV0W3ByZXZpb3VzSW5kZXhdKTtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSAnTElORUFSJzpcbiAgICAgIGlmIChuZXh0VGltZSA+IHByZXZpb3VzVGltZSkge1xuICAgICAgICBjb25zdCByYXRpbyA9IChhbmltYXRpb25UaW1lIC0gcHJldmlvdXNUaW1lKSAvIChuZXh0VGltZSAtIHByZXZpb3VzVGltZSk7XG4gICAgICAgIGxpbmVhckludGVycG9sYXRlKHRhcmdldCwgcGF0aCwgb3V0cHV0W3ByZXZpb3VzSW5kZXhdLCBvdXRwdXRbbmV4dEluZGV4XSwgcmF0aW8pO1xuICAgICAgfVxuXG4gICAgICBicmVhaztcblxuICAgIGNhc2UgJ0NVQklDU1BMSU5FJzpcbiAgICAgIGlmIChuZXh0VGltZSA+IHByZXZpb3VzVGltZSkge1xuICAgICAgICBjb25zdCByYXRpbyA9IChhbmltYXRpb25UaW1lIC0gcHJldmlvdXNUaW1lKSAvIChuZXh0VGltZSAtIHByZXZpb3VzVGltZSk7XG4gICAgICAgIGNvbnN0IHREaWZmID0gbmV4dFRpbWUgLSBwcmV2aW91c1RpbWU7XG4gICAgICAgIGNvbnN0IHAwID0gb3V0cHV0WzMgKiBwcmV2aW91c0luZGV4ICsgMV07XG4gICAgICAgIGNvbnN0IG91dFRhbmdlbnQwID0gb3V0cHV0WzMgKiBwcmV2aW91c0luZGV4ICsgMl07XG4gICAgICAgIGNvbnN0IGluVGFuZ2VudDEgPSBvdXRwdXRbMyAqIG5leHRJbmRleCArIDBdO1xuICAgICAgICBjb25zdCBwMSA9IG91dHB1dFszICogbmV4dEluZGV4ICsgMV07XG4gICAgICAgIGN1Ymljc3BsaW5lSW50ZXJwb2xhdGUodGFyZ2V0LCBwYXRoLCB7XG4gICAgICAgICAgcDAsXG4gICAgICAgICAgb3V0VGFuZ2VudDAsXG4gICAgICAgICAgaW5UYW5nZW50MSxcbiAgICAgICAgICBwMSxcbiAgICAgICAgICB0RGlmZixcbiAgICAgICAgICByYXRpb1xuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgYnJlYWs7XG5cbiAgICBkZWZhdWx0OlxuICAgICAgbG9nLndhcm4oXCJJbnRlcnBvbGF0aW9uIFwiLmNvbmNhdChpbnRlcnBvbGF0aW9uLCBcIiBub3Qgc3VwcG9ydGVkXCIpKSgpO1xuICAgICAgYnJlYWs7XG4gIH1cbn1cblxuY2xhc3MgR0xURkFuaW1hdGlvbiB7XG4gIGNvbnN0cnVjdG9yKHByb3BzKSB7XG4gICAgdGhpcy5zdGFydFRpbWUgPSAwO1xuICAgIHRoaXMucGxheWluZyA9IHRydWU7XG4gICAgdGhpcy5zcGVlZCA9IDE7XG4gICAgdGhpcy5jaGFubmVscyA9IFtdO1xuICAgIE9iamVjdC5hc3NpZ24odGhpcywgcHJvcHMpO1xuICB9XG5cbiAgYW5pbWF0ZSh0aW1lTXMpIHtcbiAgICBpZiAoIXRoaXMucGxheWluZykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IGFic1RpbWUgPSB0aW1lTXMgLyAxMDAwO1xuICAgIGNvbnN0IHRpbWUgPSAoYWJzVGltZSAtIHRoaXMuc3RhcnRUaW1lKSAqIHRoaXMuc3BlZWQ7XG4gICAgdGhpcy5jaGFubmVscy5mb3JFYWNoKF9yZWYzID0+IHtcbiAgICAgIGxldCB7XG4gICAgICAgIHNhbXBsZXIsXG4gICAgICAgIHRhcmdldCxcbiAgICAgICAgcGF0aFxuICAgICAgfSA9IF9yZWYzO1xuICAgICAgaW50ZXJwb2xhdGUodGltZSwgc2FtcGxlciwgdGFyZ2V0LCBwYXRoKTtcbiAgICAgIGFwcGx5VHJhbnNsYXRpb25Sb3RhdGlvblNjYWxlKHRhcmdldCwgdGFyZ2V0Ll9ub2RlKTtcbiAgICB9KTtcbiAgfVxuXG59XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEdMVEZBbmltYXRvciB7XG4gIGNvbnN0cnVjdG9yKGdsdGYpIHtcbiAgICB0aGlzLmFuaW1hdGlvbnMgPSBnbHRmLmFuaW1hdGlvbnMubWFwKChhbmltYXRpb24sIGluZGV4KSA9PiB7XG4gICAgICBjb25zdCBuYW1lID0gYW5pbWF0aW9uLm5hbWUgfHwgXCJBbmltYXRpb24tXCIuY29uY2F0KGluZGV4KTtcbiAgICAgIGNvbnN0IHNhbXBsZXJzID0gYW5pbWF0aW9uLnNhbXBsZXJzLm1hcChfcmVmNCA9PiB7XG4gICAgICAgIGxldCB7XG4gICAgICAgICAgaW5wdXQsXG4gICAgICAgICAgaW50ZXJwb2xhdGlvbiA9ICdMSU5FQVInLFxuICAgICAgICAgIG91dHB1dFxuICAgICAgICB9ID0gX3JlZjQ7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgaW5wdXQ6IGFjY2Vzc29yVG9Kc0FycmF5KGdsdGYuYWNjZXNzb3JzW2lucHV0XSksXG4gICAgICAgICAgaW50ZXJwb2xhdGlvbixcbiAgICAgICAgICBvdXRwdXQ6IGFjY2Vzc29yVG9Kc0FycmF5KGdsdGYuYWNjZXNzb3JzW291dHB1dF0pXG4gICAgICAgIH07XG4gICAgICB9KTtcbiAgICAgIGNvbnN0IGNoYW5uZWxzID0gYW5pbWF0aW9uLmNoYW5uZWxzLm1hcChfcmVmNSA9PiB7XG4gICAgICAgIGxldCB7XG4gICAgICAgICAgc2FtcGxlcixcbiAgICAgICAgICB0YXJnZXRcbiAgICAgICAgfSA9IF9yZWY1O1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHNhbXBsZXI6IHNhbXBsZXJzW3NhbXBsZXJdLFxuICAgICAgICAgIHRhcmdldDogZ2x0Zi5ub2Rlc1t0YXJnZXQubm9kZV0sXG4gICAgICAgICAgcGF0aDogdGFyZ2V0LnBhdGhcbiAgICAgICAgfTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIG5ldyBHTFRGQW5pbWF0aW9uKHtcbiAgICAgICAgbmFtZSxcbiAgICAgICAgY2hhbm5lbHNcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG5cbiAgYW5pbWF0ZSh0aW1lKSB7XG4gICAgdGhpcy5zZXRUaW1lKHRpbWUpO1xuICB9XG5cbiAgc2V0VGltZSh0aW1lKSB7XG4gICAgdGhpcy5hbmltYXRpb25zLmZvckVhY2goYW5pbWF0aW9uID0+IGFuaW1hdGlvbi5hbmltYXRlKHRpbWUpKTtcbiAgfVxuXG4gIGdldEFuaW1hdGlvbnMoKSB7XG4gICAgcmV0dXJuIHRoaXMuYW5pbWF0aW9ucztcbiAgfVxuXG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1nbHRmLWFuaW1hdG9yLmpzLm1hcCIsImltcG9ydCB7IE1vZGVsIH0gZnJvbSAnQGx1bWEuZ2wvZW5naW5lJztcbmltcG9ydCBTY2VuZWdyYXBoTm9kZSBmcm9tICcuL3NjZW5lZ3JhcGgtbm9kZSc7XG5leHBvcnQgZGVmYXVsdCBjbGFzcyBNb2RlbE5vZGUgZXh0ZW5kcyBTY2VuZWdyYXBoTm9kZSB7XG4gIGNvbnN0cnVjdG9yKGdsKSB7XG4gICAgbGV0IHByb3BzID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcbiAgICBzdXBlcihwcm9wcyk7XG4gICAgdGhpcy5vbkJlZm9yZVJlbmRlciA9IG51bGw7XG4gICAgdGhpcy5BZnRlclJlbmRlciA9IG51bGw7XG5cbiAgICBpZiAoZ2wgaW5zdGFuY2VvZiBNb2RlbCkge1xuICAgICAgdGhpcy5tb2RlbCA9IGdsO1xuXG4gICAgICB0aGlzLl9zZXRNb2RlbE5vZGVQcm9wcyhwcm9wcyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMubW9kZWwgPSBuZXcgTW9kZWwoZ2wsIHByb3BzKTtcbiAgICB9XG5cbiAgICB0aGlzLmJvdW5kcyA9IG51bGw7XG4gICAgdGhpcy5tYW5hZ2VkUmVzb3VyY2VzID0gcHJvcHMubWFuYWdlZFJlc291cmNlcyB8fCBbXTtcbiAgfVxuXG4gIHNldFByb3BzKHByb3BzKSB7XG4gICAgc3VwZXIuc2V0UHJvcHMocHJvcHMpO1xuXG4gICAgdGhpcy5fc2V0TW9kZWxOb2RlUHJvcHMocHJvcHMpO1xuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICBnZXRCb3VuZHMoKSB7XG4gICAgcmV0dXJuIHRoaXMuYm91bmRzO1xuICB9XG5cbiAgZGVsZXRlKCkge1xuICAgIGlmICh0aGlzLm1vZGVsKSB7XG4gICAgICB0aGlzLm1vZGVsLmRlbGV0ZSgpO1xuICAgICAgdGhpcy5tb2RlbCA9IG51bGw7XG4gICAgfVxuXG4gICAgdGhpcy5tYW5hZ2VkUmVzb3VyY2VzLmZvckVhY2gocmVzb3VyY2UgPT4gcmVzb3VyY2UuZGVsZXRlKCkpO1xuICAgIHRoaXMubWFuYWdlZFJlc291cmNlcyA9IFtdO1xuICB9XG5cbiAgZHJhdygpIHtcbiAgICByZXR1cm4gdGhpcy5tb2RlbC5kcmF3KC4uLmFyZ3VtZW50cyk7XG4gIH1cblxuICBzZXRVbmlmb3JtcygpIHtcbiAgICB0aGlzLm1vZGVsLnNldFVuaWZvcm1zKC4uLmFyZ3VtZW50cyk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICBzZXRBdHRyaWJ1dGVzKCkge1xuICAgIHRoaXMubW9kZWwuc2V0QXR0cmlidXRlcyguLi5hcmd1bWVudHMpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgdXBkYXRlTW9kdWxlU2V0dGluZ3MoKSB7XG4gICAgdGhpcy5tb2RlbC51cGRhdGVNb2R1bGVTZXR0aW5ncyguLi5hcmd1bWVudHMpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgX3NldE1vZGVsTm9kZVByb3BzKHByb3BzKSB7XG4gICAgdGhpcy5tb2RlbC5zZXRQcm9wcyhwcm9wcyk7XG4gIH1cblxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bW9kZWwtbm9kZS5qcy5tYXAiLCJpbXBvcnQgeyBUZXh0dXJlMkQsIGhhc0ZlYXR1cmUsIEZFQVRVUkVTLCBsb2cgfSBmcm9tICdAbHVtYS5nbC93ZWJnbCc7XG5leHBvcnQgZGVmYXVsdCBjbGFzcyBHTFRGTWF0ZXJpYWxQYXJzZXIge1xuICBjb25zdHJ1Y3RvcihnbCwgX3JlZikge1xuICAgIGxldCB7XG4gICAgICBhdHRyaWJ1dGVzLFxuICAgICAgbWF0ZXJpYWwsXG4gICAgICBwYnJEZWJ1ZyxcbiAgICAgIGltYWdlQmFzZWRMaWdodGluZ0Vudmlyb25tZW50LFxuICAgICAgbGlnaHRzLFxuICAgICAgdXNlVGFuZ2VudHNcbiAgICB9ID0gX3JlZjtcbiAgICB0aGlzLmdsID0gZ2w7XG4gICAgdGhpcy5kZWZpbmVzID0ge1xuICAgICAgTUFOVUFMX1NSR0I6IDEsXG4gICAgICBTUkdCX0ZBU1RfQVBQUk9YSU1BVElPTjogMVxuICAgIH07XG5cbiAgICBpZiAoaGFzRmVhdHVyZShnbCwgRkVBVFVSRVMuR0xTTF9URVhUVVJFX0xPRCkpIHtcbiAgICAgIHRoaXMuZGVmaW5lcy5VU0VfVEVYX0xPRCA9IDE7XG4gICAgfVxuXG4gICAgdGhpcy51bmlmb3JtcyA9IHtcbiAgICAgIHVfQ2FtZXJhOiBbMCwgMCwgMF0sXG4gICAgICB1X01ldGFsbGljUm91Z2huZXNzVmFsdWVzOiBbMSwgMV1cbiAgICB9O1xuICAgIHRoaXMucGFyYW1ldGVycyA9IHt9O1xuICAgIHRoaXMuZ2VuZXJhdGVkVGV4dHVyZXMgPSBbXTtcblxuICAgIGlmIChpbWFnZUJhc2VkTGlnaHRpbmdFbnZpcm9ubWVudCkge1xuICAgICAgdGhpcy51bmlmb3Jtcy51X0RpZmZ1c2VFbnZTYW1wbGVyID0gaW1hZ2VCYXNlZExpZ2h0aW5nRW52aXJvbm1lbnQuZ2V0RGlmZnVzZUVudlNhbXBsZXIoKTtcbiAgICAgIHRoaXMudW5pZm9ybXMudV9TcGVjdWxhckVudlNhbXBsZXIgPSBpbWFnZUJhc2VkTGlnaHRpbmdFbnZpcm9ubWVudC5nZXRTcGVjdWxhckVudlNhbXBsZXIoKTtcbiAgICAgIHRoaXMudW5pZm9ybXMudV9icmRmTFVUID0gaW1hZ2VCYXNlZExpZ2h0aW5nRW52aXJvbm1lbnQuZ2V0QnJkZlRleHR1cmUoKTtcbiAgICAgIHRoaXMudW5pZm9ybXMudV9TY2FsZUlCTEFtYmllbnQgPSBbMSwgMV07XG4gICAgfVxuXG4gICAgaWYgKHBickRlYnVnKSB7XG4gICAgICB0aGlzLnVuaWZvcm1zLnVfU2NhbGVEaWZmQmFzZU1SID0gWzAsIDAsIDAsIDBdO1xuICAgICAgdGhpcy51bmlmb3Jtcy51X1NjYWxlRkdEU3BlYyA9IFswLCAwLCAwLCAwXTtcbiAgICB9XG5cbiAgICB0aGlzLmRlZmluZUlmUHJlc2VudChhdHRyaWJ1dGVzLk5PUk1BTCwgJ0hBU19OT1JNQUxTJyk7XG4gICAgdGhpcy5kZWZpbmVJZlByZXNlbnQoYXR0cmlidXRlcy5UQU5HRU5UICYmIHVzZVRhbmdlbnRzLCAnSEFTX1RBTkdFTlRTJyk7XG4gICAgdGhpcy5kZWZpbmVJZlByZXNlbnQoYXR0cmlidXRlcy5URVhDT09SRF8wLCAnSEFTX1VWJyk7XG4gICAgdGhpcy5kZWZpbmVJZlByZXNlbnQoaW1hZ2VCYXNlZExpZ2h0aW5nRW52aXJvbm1lbnQsICdVU0VfSUJMJyk7XG4gICAgdGhpcy5kZWZpbmVJZlByZXNlbnQobGlnaHRzLCAnVVNFX0xJR0hUUycpO1xuICAgIHRoaXMuZGVmaW5lSWZQcmVzZW50KHBickRlYnVnLCAnUEJSX0RFQlVHJyk7XG5cbiAgICBpZiAobWF0ZXJpYWwpIHtcbiAgICAgIHRoaXMucGFyc2VNYXRlcmlhbChtYXRlcmlhbCk7XG4gICAgfVxuICB9XG5cbiAgZGVmaW5lSWZQcmVzZW50KHZhbHVlLCBuYW1lKSB7XG4gICAgaWYgKHZhbHVlKSB7XG4gICAgICB0aGlzLmRlZmluZXNbbmFtZV0gPSAxO1xuICAgIH1cbiAgfVxuXG4gIHBhcnNlVGV4dHVyZShnbHRmVGV4dHVyZSwgbmFtZSkge1xuICAgIGxldCBkZWZpbmUgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IG51bGw7XG4gICAgY29uc3QgcGFyYW1ldGVycyA9IGdsdGZUZXh0dXJlLnRleHR1cmUgJiYgZ2x0ZlRleHR1cmUudGV4dHVyZS5zYW1wbGVyICYmIGdsdGZUZXh0dXJlLnRleHR1cmUuc2FtcGxlci5wYXJhbWV0ZXJzIHx8IHt9O1xuICAgIGNvbnN0IGltYWdlID0gZ2x0ZlRleHR1cmUudGV4dHVyZS5zb3VyY2UuaW1hZ2U7XG4gICAgbGV0IHRleHR1cmVPcHRpb25zO1xuICAgIGxldCBzcGVjaWFsVGV4dHVyZVBhcmFtZXRlcnMgPSB7fTtcblxuICAgIGlmIChpbWFnZS5jb21wcmVzc2VkKSB7XG4gICAgICB0ZXh0dXJlT3B0aW9ucyA9IGltYWdlO1xuICAgICAgc3BlY2lhbFRleHR1cmVQYXJhbWV0ZXJzID0ge1xuICAgICAgICBbdGhpcy5nbC5URVhUVVJFX01JTl9GSUxURVJdOiBpbWFnZS5kYXRhLmxlbmd0aCA+IDEgPyB0aGlzLmdsLkxJTkVBUl9NSVBNQVBfTkVBUkVTVCA6IHRoaXMuZ2wuTElORUFSXG4gICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICB0ZXh0dXJlT3B0aW9ucyA9IHtcbiAgICAgICAgZGF0YTogaW1hZ2VcbiAgICAgIH07XG4gICAgfVxuXG4gICAgY29uc3QgdGV4dHVyZSA9IG5ldyBUZXh0dXJlMkQodGhpcy5nbCwge1xuICAgICAgaWQ6IGdsdGZUZXh0dXJlLm5hbWUgfHwgZ2x0ZlRleHR1cmUuaWQsXG4gICAgICBwYXJhbWV0ZXJzOiB7IC4uLnBhcmFtZXRlcnMsXG4gICAgICAgIC4uLnNwZWNpYWxUZXh0dXJlUGFyYW1ldGVyc1xuICAgICAgfSxcbiAgICAgIHBpeGVsU3RvcmU6IHtcbiAgICAgICAgW3RoaXMuZ2wuVU5QQUNLX0ZMSVBfWV9XRUJHTF06IGZhbHNlXG4gICAgICB9LFxuICAgICAgLi4udGV4dHVyZU9wdGlvbnNcbiAgICB9KTtcbiAgICB0aGlzLnVuaWZvcm1zW25hbWVdID0gdGV4dHVyZTtcbiAgICB0aGlzLmRlZmluZUlmUHJlc2VudChkZWZpbmUsIGRlZmluZSk7XG4gICAgdGhpcy5nZW5lcmF0ZWRUZXh0dXJlcy5wdXNoKHRleHR1cmUpO1xuICB9XG5cbiAgcGFyc2VQYnJNZXRhbGxpY1JvdWdobmVzcyhwYnJNZXRhbGxpY1JvdWdobmVzcykge1xuICAgIGlmIChwYnJNZXRhbGxpY1JvdWdobmVzcy5iYXNlQ29sb3JUZXh0dXJlKSB7XG4gICAgICB0aGlzLnBhcnNlVGV4dHVyZShwYnJNZXRhbGxpY1JvdWdobmVzcy5iYXNlQ29sb3JUZXh0dXJlLCAndV9CYXNlQ29sb3JTYW1wbGVyJywgJ0hBU19CQVNFQ09MT1JNQVAnKTtcbiAgICB9XG5cbiAgICB0aGlzLnVuaWZvcm1zLnVfQmFzZUNvbG9yRmFjdG9yID0gcGJyTWV0YWxsaWNSb3VnaG5lc3MuYmFzZUNvbG9yRmFjdG9yIHx8IFsxLCAxLCAxLCAxXTtcblxuICAgIGlmIChwYnJNZXRhbGxpY1JvdWdobmVzcy5tZXRhbGxpY1JvdWdobmVzc1RleHR1cmUpIHtcbiAgICAgIHRoaXMucGFyc2VUZXh0dXJlKHBick1ldGFsbGljUm91Z2huZXNzLm1ldGFsbGljUm91Z2huZXNzVGV4dHVyZSwgJ3VfTWV0YWxsaWNSb3VnaG5lc3NTYW1wbGVyJywgJ0hBU19NRVRBTFJPVUdITkVTU01BUCcpO1xuICAgIH1cblxuICAgIGNvbnN0IHtcbiAgICAgIG1ldGFsbGljRmFjdG9yID0gMSxcbiAgICAgIHJvdWdobmVzc0ZhY3RvciA9IDFcbiAgICB9ID0gcGJyTWV0YWxsaWNSb3VnaG5lc3M7XG4gICAgdGhpcy51bmlmb3Jtcy51X01ldGFsbGljUm91Z2huZXNzVmFsdWVzID0gW21ldGFsbGljRmFjdG9yLCByb3VnaG5lc3NGYWN0b3JdO1xuICB9XG5cbiAgcGFyc2VNYXRlcmlhbChtYXRlcmlhbCkge1xuICAgIHRoaXMudW5pZm9ybXMucGJyX3VVbmxpdCA9IEJvb2xlYW4obWF0ZXJpYWwudW5saXQpO1xuXG4gICAgaWYgKG1hdGVyaWFsLnBick1ldGFsbGljUm91Z2huZXNzKSB7XG4gICAgICB0aGlzLnBhcnNlUGJyTWV0YWxsaWNSb3VnaG5lc3MobWF0ZXJpYWwucGJyTWV0YWxsaWNSb3VnaG5lc3MpO1xuICAgIH1cblxuICAgIGlmIChtYXRlcmlhbC5ub3JtYWxUZXh0dXJlKSB7XG4gICAgICB0aGlzLnBhcnNlVGV4dHVyZShtYXRlcmlhbC5ub3JtYWxUZXh0dXJlLCAndV9Ob3JtYWxTYW1wbGVyJywgJ0hBU19OT1JNQUxNQVAnKTtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgc2NhbGUgPSAxXG4gICAgICB9ID0gbWF0ZXJpYWwubm9ybWFsVGV4dHVyZTtcbiAgICAgIHRoaXMudW5pZm9ybXMudV9Ob3JtYWxTY2FsZSA9IHNjYWxlO1xuICAgIH1cblxuICAgIGlmIChtYXRlcmlhbC5vY2NsdXNpb25UZXh0dXJlKSB7XG4gICAgICB0aGlzLnBhcnNlVGV4dHVyZShtYXRlcmlhbC5vY2NsdXNpb25UZXh0dXJlLCAndV9PY2NsdXNpb25TYW1wbGVyJywgJ0hBU19PQ0NMVVNJT05NQVAnKTtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgc3RyZW5ndGggPSAxXG4gICAgICB9ID0gbWF0ZXJpYWwub2NjbHVzaW9uVGV4dHVyZTtcbiAgICAgIHRoaXMudW5pZm9ybXMudV9PY2NsdXNpb25TdHJlbmd0aCA9IHN0cmVuZ3RoO1xuICAgIH1cblxuICAgIGlmIChtYXRlcmlhbC5lbWlzc2l2ZVRleHR1cmUpIHtcbiAgICAgIHRoaXMucGFyc2VUZXh0dXJlKG1hdGVyaWFsLmVtaXNzaXZlVGV4dHVyZSwgJ3VfRW1pc3NpdmVTYW1wbGVyJywgJ0hBU19FTUlTU0lWRU1BUCcpO1xuICAgICAgdGhpcy51bmlmb3Jtcy51X0VtaXNzaXZlRmFjdG9yID0gbWF0ZXJpYWwuZW1pc3NpdmVGYWN0b3IgfHwgWzAsIDAsIDBdO1xuICAgIH1cblxuICAgIGlmIChtYXRlcmlhbC5hbHBoYU1vZGUgPT09ICdNQVNLJykge1xuICAgICAgY29uc3Qge1xuICAgICAgICBhbHBoYUN1dG9mZiA9IDAuNVxuICAgICAgfSA9IG1hdGVyaWFsO1xuICAgICAgdGhpcy5kZWZpbmVzLkFMUEhBX0NVVE9GRiA9IDE7XG4gICAgICB0aGlzLnVuaWZvcm1zLnVfQWxwaGFDdXRvZmYgPSBhbHBoYUN1dG9mZjtcbiAgICB9IGVsc2UgaWYgKG1hdGVyaWFsLmFscGhhTW9kZSA9PT0gJ0JMRU5EJykge1xuICAgICAgbG9nLndhcm4oJ0JMRU5EIGFscGhhTW9kZSBtaWdodCBub3Qgd29yayB3ZWxsIGJlY2F1c2UgaXQgcmVxdWlyZXMgbWVzaCBzb3J0aW5nJykoKTtcbiAgICAgIE9iamVjdC5hc3NpZ24odGhpcy5wYXJhbWV0ZXJzLCB7XG4gICAgICAgIGJsZW5kOiB0cnVlLFxuICAgICAgICBibGVuZEVxdWF0aW9uOiB0aGlzLmdsLkZVTkNfQURELFxuICAgICAgICBibGVuZEZ1bmM6IFt0aGlzLmdsLlNSQ19BTFBIQSwgdGhpcy5nbC5PTkVfTUlOVVNfU1JDX0FMUEhBLCB0aGlzLmdsLk9ORSwgdGhpcy5nbC5PTkVfTUlOVVNfU1JDX0FMUEhBXVxuICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgZGVsZXRlKCkge1xuICAgIHRoaXMuZ2VuZXJhdGVkVGV4dHVyZXMuZm9yRWFjaCh0ZXh0dXJlID0+IHRleHR1cmUuZGVsZXRlKCkpO1xuICB9XG5cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWdsdGYtbWF0ZXJpYWwtcGFyc2VyLmpzLm1hcCIsImltcG9ydCB7IGlzV2ViR0wyIH0gZnJvbSAnQGx1bWEuZ2wvZ2x0b29scyc7XG5pbXBvcnQgeyBsb2cgfSBmcm9tICdAbHVtYS5nbC93ZWJnbCc7XG5pbXBvcnQgeyBwYnIgfSBmcm9tICdAbHVtYS5nbC9zaGFkZXJ0b29scyc7XG5pbXBvcnQgTW9kZWxOb2RlIGZyb20gJy4uL3NjZW5lZ3JhcGgvbW9kZWwtbm9kZSc7XG5pbXBvcnQgR0xURk1hdGVyaWFsUGFyc2VyIGZyb20gJy4vZ2x0Zi1tYXRlcmlhbC1wYXJzZXInO1xuY29uc3QgdnMgPSBcIlxcbiNpZiAoX19WRVJTSU9OX18gPCAzMDApXFxuICAjZGVmaW5lIF9hdHRyIGF0dHJpYnV0ZVxcbiNlbHNlXFxuICAjZGVmaW5lIF9hdHRyIGluXFxuI2VuZGlmXFxuXFxuICBfYXR0ciB2ZWM0IFBPU0lUSU9OO1xcblxcbiAgI2lmZGVmIEhBU19OT1JNQUxTXFxuICAgIF9hdHRyIHZlYzQgTk9STUFMO1xcbiAgI2VuZGlmXFxuXFxuICAjaWZkZWYgSEFTX1RBTkdFTlRTXFxuICAgIF9hdHRyIHZlYzQgVEFOR0VOVDtcXG4gICNlbmRpZlxcblxcbiAgI2lmZGVmIEhBU19VVlxcbiAgICBfYXR0ciB2ZWMyIFRFWENPT1JEXzA7XFxuICAjZW5kaWZcXG5cXG4gIHZvaWQgbWFpbih2b2lkKSB7XFxuICAgIHZlYzQgX05PUk1BTCA9IHZlYzQoMC4pO1xcbiAgICB2ZWM0IF9UQU5HRU5UID0gdmVjNCgwLik7XFxuICAgIHZlYzIgX1RFWENPT1JEXzAgPSB2ZWMyKDAuKTtcXG5cXG4gICAgI2lmZGVmIEhBU19OT1JNQUxTXFxuICAgICAgX05PUk1BTCA9IE5PUk1BTDtcXG4gICAgI2VuZGlmXFxuXFxuICAgICNpZmRlZiBIQVNfVEFOR0VOVFNcXG4gICAgICBfVEFOR0VOVCA9IFRBTkdFTlQ7XFxuICAgICNlbmRpZlxcblxcbiAgICAjaWZkZWYgSEFTX1VWXFxuICAgICAgX1RFWENPT1JEXzAgPSBURVhDT09SRF8wO1xcbiAgICAjZW5kaWZcXG5cXG4gICAgcGJyX3NldFBvc2l0aW9uTm9ybWFsVGFuZ2VudFVWKFBPU0lUSU9OLCBfTk9STUFMLCBfVEFOR0VOVCwgX1RFWENPT1JEXzApO1xcbiAgICBnbF9Qb3NpdGlvbiA9IHVfTVZQTWF0cml4ICogUE9TSVRJT047XFxuICB9XFxuXCI7XG5jb25zdCBmcyA9IFwiXFxuI2lmIChfX1ZFUlNJT05fXyA8IDMwMClcXG4gICNkZWZpbmUgZnJhZ21lbnRDb2xvciBnbF9GcmFnQ29sb3JcXG4jZWxzZVxcbiAgb3V0IHZlYzQgZnJhZ21lbnRDb2xvcjtcXG4jZW5kaWZcXG5cXG4gIHZvaWQgbWFpbih2b2lkKSB7XFxuICAgIGZyYWdtZW50Q29sb3IgPSBwYnJfZmlsdGVyQ29sb3IodmVjNCgwKSk7XFxuICB9XFxuXCI7XG5cbmZ1bmN0aW9uIGFkZFZlcnNpb25Ub1NoYWRlcihnbCwgc291cmNlKSB7XG4gIGlmIChpc1dlYkdMMihnbCkpIHtcbiAgICByZXR1cm4gXCIjdmVyc2lvbiAzMDAgZXNcXG5cIi5jb25jYXQoc291cmNlKTtcbiAgfVxuXG4gIHJldHVybiBzb3VyY2U7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGNyZWF0ZUdMVEZNb2RlbChnbCwgb3B0aW9ucykge1xuICBjb25zdCB7XG4gICAgaWQsXG4gICAgZHJhd01vZGUsXG4gICAgdmVydGV4Q291bnQsXG4gICAgYXR0cmlidXRlcyxcbiAgICBtb2RlbE9wdGlvbnNcbiAgfSA9IG9wdGlvbnM7XG4gIGNvbnN0IG1hdGVyaWFsUGFyc2VyID0gbmV3IEdMVEZNYXRlcmlhbFBhcnNlcihnbCwgb3B0aW9ucyk7XG4gIGxvZy5pbmZvKDQsICdjcmVhdGVHTFRGTW9kZWwgZGVmaW5lczogJywgbWF0ZXJpYWxQYXJzZXIuZGVmaW5lcykoKTtcbiAgY29uc3QgbWFuYWdlZFJlc291cmNlcyA9IFtdO1xuICBtYW5hZ2VkUmVzb3VyY2VzLnB1c2goLi4ubWF0ZXJpYWxQYXJzZXIuZ2VuZXJhdGVkVGV4dHVyZXMpO1xuICBtYW5hZ2VkUmVzb3VyY2VzLnB1c2goLi4uT2JqZWN0LnZhbHVlcyhhdHRyaWJ1dGVzKS5tYXAoYXR0cmlidXRlID0+IGF0dHJpYnV0ZS5idWZmZXIpKTtcbiAgY29uc3QgbW9kZWwgPSBuZXcgTW9kZWxOb2RlKGdsLCBPYmplY3QuYXNzaWduKHtcbiAgICBpZCxcbiAgICBkcmF3TW9kZSxcbiAgICB2ZXJ0ZXhDb3VudCxcbiAgICBtb2R1bGVzOiBbcGJyXSxcbiAgICBkZWZpbmVzOiBtYXRlcmlhbFBhcnNlci5kZWZpbmVzLFxuICAgIHBhcmFtZXRlcnM6IG1hdGVyaWFsUGFyc2VyLnBhcmFtZXRlcnMsXG4gICAgdnM6IGFkZFZlcnNpb25Ub1NoYWRlcihnbCwgdnMpLFxuICAgIGZzOiBhZGRWZXJzaW9uVG9TaGFkZXIoZ2wsIGZzKSxcbiAgICBtYW5hZ2VkUmVzb3VyY2VzXG4gIH0sIG1vZGVsT3B0aW9ucykpO1xuICBtb2RlbC5zZXRQcm9wcyh7XG4gICAgYXR0cmlidXRlc1xuICB9KTtcbiAgbW9kZWwuc2V0VW5pZm9ybXMobWF0ZXJpYWxQYXJzZXIudW5pZm9ybXMpO1xuICByZXR1cm4gbW9kZWw7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jcmVhdGUtZ2x0Zi1tb2RlbC5qcy5tYXAiLCJpbXBvcnQgeyBNYXRyaXg0IH0gZnJvbSAnQG1hdGguZ2wvY29yZSc7XG5pbXBvcnQgeyBCdWZmZXIsIEFjY2Vzc29yLCBsb2cgfSBmcm9tICdAbHVtYS5nbC93ZWJnbCc7XG5pbXBvcnQgR3JvdXBOb2RlIGZyb20gJy4uL3NjZW5lZ3JhcGgvZ3JvdXAtbm9kZSc7XG5pbXBvcnQgR0xURkFuaW1hdG9yIGZyb20gJy4vZ2x0Zi1hbmltYXRvcic7XG5pbXBvcnQgY3JlYXRlR0xURk1vZGVsIGZyb20gJy4vY3JlYXRlLWdsdGYtbW9kZWwnO1xuY29uc3QgQVRUUklCVVRFX1RZUEVfVE9fQ09NUE9ORU5UUyA9IHtcbiAgU0NBTEFSOiAxLFxuICBWRUMyOiAyLFxuICBWRUMzOiAzLFxuICBWRUM0OiA0LFxuICBNQVQyOiA0LFxuICBNQVQzOiA5LFxuICBNQVQ0OiAxNlxufTtcbmNvbnN0IERFRkFVTFRfT1BUSU9OUyA9IHtcbiAgbW9kZWxPcHRpb25zOiB7fSxcbiAgcGJyRGVidWc6IGZhbHNlLFxuICBpbWFnZUJhc2VkTGlnaHRpbmdFbnZpcm9ubWVudDogbnVsbCxcbiAgbGlnaHRzOiB0cnVlLFxuICB1c2VUYW5nZW50czogZmFsc2Vcbn07XG5leHBvcnQgZGVmYXVsdCBjbGFzcyBHTFRGSW5zdGFudGlhdG9yIHtcbiAgY29uc3RydWN0b3IoZ2wpIHtcbiAgICBsZXQgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG4gICAgdGhpcy5nbCA9IGdsO1xuICAgIHRoaXMub3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oe30sIERFRkFVTFRfT1BUSU9OUywgb3B0aW9ucyk7XG4gIH1cblxuICBpbnN0YW50aWF0ZShnbHRmKSB7XG4gICAgdGhpcy5nbHRmID0gZ2x0ZjtcbiAgICBjb25zdCBzY2VuZXMgPSAoZ2x0Zi5zY2VuZXMgfHwgW10pLm1hcChzY2VuZSA9PiB0aGlzLmNyZWF0ZVNjZW5lKHNjZW5lKSk7XG4gICAgcmV0dXJuIHNjZW5lcztcbiAgfVxuXG4gIGNyZWF0ZUFuaW1hdG9yKCkge1xuICAgIGlmIChBcnJheS5pc0FycmF5KHRoaXMuZ2x0Zi5hbmltYXRpb25zKSkge1xuICAgICAgcmV0dXJuIG5ldyBHTFRGQW5pbWF0b3IodGhpcy5nbHRmKTtcbiAgICB9XG5cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIGNyZWF0ZVNjZW5lKGdsdGZTY2VuZSkge1xuICAgIGNvbnN0IGdsdGZOb2RlcyA9IGdsdGZTY2VuZS5ub2RlcyB8fCBbXTtcbiAgICBjb25zdCBub2RlcyA9IGdsdGZOb2Rlcy5tYXAobm9kZSA9PiB0aGlzLmNyZWF0ZU5vZGUobm9kZSkpO1xuICAgIGNvbnN0IHNjZW5lID0gbmV3IEdyb3VwTm9kZSh7XG4gICAgICBpZDogZ2x0ZlNjZW5lLm5hbWUgfHwgZ2x0ZlNjZW5lLmlkLFxuICAgICAgY2hpbGRyZW46IG5vZGVzXG4gICAgfSk7XG4gICAgcmV0dXJuIHNjZW5lO1xuICB9XG5cbiAgY3JlYXRlTm9kZShnbHRmTm9kZSkge1xuICAgIGlmICghZ2x0Zk5vZGUuX25vZGUpIHtcbiAgICAgIGNvbnN0IGdsdGZDaGlsZHJlbiA9IGdsdGZOb2RlLmNoaWxkcmVuIHx8IFtdO1xuICAgICAgY29uc3QgY2hpbGRyZW4gPSBnbHRmQ2hpbGRyZW4ubWFwKGNoaWxkID0+IHRoaXMuY3JlYXRlTm9kZShjaGlsZCkpO1xuXG4gICAgICBpZiAoZ2x0Zk5vZGUubWVzaCkge1xuICAgICAgICBjaGlsZHJlbi5wdXNoKHRoaXMuY3JlYXRlTWVzaChnbHRmTm9kZS5tZXNoKSk7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IG5vZGUgPSBuZXcgR3JvdXBOb2RlKHtcbiAgICAgICAgaWQ6IGdsdGZOb2RlLm5hbWUgfHwgZ2x0Zk5vZGUuaWQsXG4gICAgICAgIGNoaWxkcmVuXG4gICAgICB9KTtcblxuICAgICAgaWYgKGdsdGZOb2RlLm1hdHJpeCkge1xuICAgICAgICBub2RlLnNldE1hdHJpeChnbHRmTm9kZS5tYXRyaXgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbm9kZS5tYXRyaXguaWRlbnRpdHkoKTtcblxuICAgICAgICBpZiAoZ2x0Zk5vZGUudHJhbnNsYXRpb24pIHtcbiAgICAgICAgICBub2RlLm1hdHJpeC50cmFuc2xhdGUoZ2x0Zk5vZGUudHJhbnNsYXRpb24pO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGdsdGZOb2RlLnJvdGF0aW9uKSB7XG4gICAgICAgICAgY29uc3Qgcm90YXRpb25NYXRyaXggPSBuZXcgTWF0cml4NCgpLmZyb21RdWF0ZXJuaW9uKGdsdGZOb2RlLnJvdGF0aW9uKTtcbiAgICAgICAgICBub2RlLm1hdHJpeC5tdWx0aXBseVJpZ2h0KHJvdGF0aW9uTWF0cml4KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChnbHRmTm9kZS5zY2FsZSkge1xuICAgICAgICAgIG5vZGUubWF0cml4LnNjYWxlKGdsdGZOb2RlLnNjYWxlKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBnbHRmTm9kZS5fbm9kZSA9IG5vZGU7XG4gICAgfVxuXG4gICAgcmV0dXJuIGdsdGZOb2RlLl9ub2RlO1xuICB9XG5cbiAgY3JlYXRlTWVzaChnbHRmTWVzaCkge1xuICAgIGlmICghZ2x0Zk1lc2guX21lc2gpIHtcbiAgICAgIGNvbnN0IGdsdGZQcmltaXRpdmVzID0gZ2x0Zk1lc2gucHJpbWl0aXZlcyB8fCBbXTtcbiAgICAgIGNvbnN0IHByaW1pdGl2ZXMgPSBnbHRmUHJpbWl0aXZlcy5tYXAoKGdsdGZQcmltaXRpdmUsIGkpID0+IHRoaXMuY3JlYXRlUHJpbWl0aXZlKGdsdGZQcmltaXRpdmUsIGksIGdsdGZNZXNoKSk7XG4gICAgICBjb25zdCBtZXNoID0gbmV3IEdyb3VwTm9kZSh7XG4gICAgICAgIGlkOiBnbHRmTWVzaC5uYW1lIHx8IGdsdGZNZXNoLmlkLFxuICAgICAgICBjaGlsZHJlbjogcHJpbWl0aXZlc1xuICAgICAgfSk7XG4gICAgICBnbHRmTWVzaC5fbWVzaCA9IG1lc2g7XG4gICAgfVxuXG4gICAgcmV0dXJuIGdsdGZNZXNoLl9tZXNoO1xuICB9XG5cbiAgZ2V0VmVydGV4Q291bnQoYXR0cmlidXRlcykge1xuICAgIGxvZy53YXJuKCdnZXRWZXJ0ZXhDb3VudCgpIG5vdCBmb3VuZCcpKCk7XG4gIH1cblxuICBjcmVhdGVQcmltaXRpdmUoZ2x0ZlByaW1pdGl2ZSwgaSwgZ2x0Zk1lc2gpIHtcbiAgICBjb25zdCBtb2RlbCA9IGNyZWF0ZUdMVEZNb2RlbCh0aGlzLmdsLCBPYmplY3QuYXNzaWduKHtcbiAgICAgIGlkOiBnbHRmUHJpbWl0aXZlLm5hbWUgfHwgXCJcIi5jb25jYXQoZ2x0Zk1lc2gubmFtZSB8fCBnbHRmTWVzaC5pZCwgXCItcHJpbWl0aXZlLVwiKS5jb25jYXQoaSksXG4gICAgICBkcmF3TW9kZTogZ2x0ZlByaW1pdGl2ZS5tb2RlIHx8IDQsXG4gICAgICB2ZXJ0ZXhDb3VudDogZ2x0ZlByaW1pdGl2ZS5pbmRpY2VzID8gZ2x0ZlByaW1pdGl2ZS5pbmRpY2VzLmNvdW50IDogdGhpcy5nZXRWZXJ0ZXhDb3VudChnbHRmUHJpbWl0aXZlLmF0dHJpYnV0ZXMpLFxuICAgICAgYXR0cmlidXRlczogdGhpcy5jcmVhdGVBdHRyaWJ1dGVzKGdsdGZQcmltaXRpdmUuYXR0cmlidXRlcywgZ2x0ZlByaW1pdGl2ZS5pbmRpY2VzKSxcbiAgICAgIG1hdGVyaWFsOiBnbHRmUHJpbWl0aXZlLm1hdGVyaWFsXG4gICAgfSwgdGhpcy5vcHRpb25zKSk7XG4gICAgbW9kZWwuYm91bmRzID0gW2dsdGZQcmltaXRpdmUuYXR0cmlidXRlcy5QT1NJVElPTi5taW4sIGdsdGZQcmltaXRpdmUuYXR0cmlidXRlcy5QT1NJVElPTi5tYXhdO1xuICAgIHJldHVybiBtb2RlbDtcbiAgfVxuXG4gIGNyZWF0ZUF0dHJpYnV0ZXMoYXR0cmlidXRlcywgaW5kaWNlcykge1xuICAgIGNvbnN0IGxvYWRlZEF0dHJpYnV0ZXMgPSB7fTtcbiAgICBPYmplY3Qua2V5cyhhdHRyaWJ1dGVzKS5mb3JFYWNoKGF0dHJOYW1lID0+IHtcbiAgICAgIGxvYWRlZEF0dHJpYnV0ZXNbYXR0ck5hbWVdID0gdGhpcy5jcmVhdGVBY2Nlc3NvcihhdHRyaWJ1dGVzW2F0dHJOYW1lXSwgdGhpcy5jcmVhdGVCdWZmZXIoYXR0cmlidXRlc1thdHRyTmFtZV0sIHRoaXMuZ2wuQVJSQVlfQlVGRkVSKSk7XG4gICAgfSk7XG5cbiAgICBpZiAoaW5kaWNlcykge1xuICAgICAgbG9hZGVkQXR0cmlidXRlcy5pbmRpY2VzID0gdGhpcy5jcmVhdGVBY2Nlc3NvcihpbmRpY2VzLCB0aGlzLmNyZWF0ZUJ1ZmZlcihpbmRpY2VzLCB0aGlzLmdsLkVMRU1FTlRfQVJSQVlfQlVGRkVSKSk7XG4gICAgfVxuXG4gICAgbG9nLmluZm8oNCwgJ2dsVEYgQXR0cmlidXRlcycsIHtcbiAgICAgIGF0dHJpYnV0ZXMsXG4gICAgICBpbmRpY2VzLFxuICAgICAgZ2VuZXJhdGVkOiBsb2FkZWRBdHRyaWJ1dGVzXG4gICAgfSkoKTtcbiAgICByZXR1cm4gbG9hZGVkQXR0cmlidXRlcztcbiAgfVxuXG4gIGNyZWF0ZUJ1ZmZlcihhdHRyaWJ1dGUsIHRhcmdldCkge1xuICAgIGlmICghYXR0cmlidXRlLmJ1ZmZlclZpZXcpIHtcbiAgICAgIGF0dHJpYnV0ZS5idWZmZXJWaWV3ID0ge307XG4gICAgfVxuXG4gICAgY29uc3Qge1xuICAgICAgYnVmZmVyVmlld1xuICAgIH0gPSBhdHRyaWJ1dGU7XG5cbiAgICBpZiAoIWJ1ZmZlclZpZXcubHVtYUJ1ZmZlcnMpIHtcbiAgICAgIGJ1ZmZlclZpZXcubHVtYUJ1ZmZlcnMgPSB7fTtcbiAgICB9XG5cbiAgICBpZiAoIWJ1ZmZlclZpZXcubHVtYUJ1ZmZlcnNbdGFyZ2V0XSkge1xuICAgICAgYnVmZmVyVmlldy5sdW1hQnVmZmVyc1t0YXJnZXRdID0gbmV3IEJ1ZmZlcih0aGlzLmdsLCB7XG4gICAgICAgIGlkOiBcImZyb20tXCIuY29uY2F0KGJ1ZmZlclZpZXcuaWQpLFxuICAgICAgICBkYXRhOiBidWZmZXJWaWV3LmRhdGEgfHwgYXR0cmlidXRlLnZhbHVlLFxuICAgICAgICB0YXJnZXRcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHJldHVybiBidWZmZXJWaWV3Lmx1bWFCdWZmZXJzW3RhcmdldF07XG4gIH1cblxuICBjcmVhdGVBY2Nlc3NvcihhY2Nlc3NvciwgYnVmZmVyKSB7XG4gICAgcmV0dXJuIG5ldyBBY2Nlc3Nvcih7XG4gICAgICBidWZmZXIsXG4gICAgICBvZmZzZXQ6IGFjY2Vzc29yLmJ5dGVPZmZzZXQgfHwgMCxcbiAgICAgIHN0cmlkZTogYWNjZXNzb3IuYnVmZmVyVmlldy5ieXRlU3RyaWRlIHx8IDAsXG4gICAgICB0eXBlOiBhY2Nlc3Nvci5jb21wb25lbnRUeXBlLFxuICAgICAgc2l6ZTogQVRUUklCVVRFX1RZUEVfVE9fQ09NUE9ORU5UU1thY2Nlc3Nvci50eXBlXVxuICAgIH0pO1xuICB9XG5cbiAgY3JlYXRlU2FtcGxlcihnbHRmU2FtcGxlcikge1xuICAgIHJldHVybiBnbHRmU2FtcGxlcjtcbiAgfVxuXG4gIG5lZWRzUE9UKCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1nbHRmLWluc3RhbnRpYXRvci5qcy5tYXAiLCJpbXBvcnQgR0xURkluc3RhbnRpYXRvciBmcm9tICcuL2dsdGYtaW5zdGFudGlhdG9yJztcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGNyZWF0ZUdMVEZPYmplY3RzKGdsLCBnbHRmLCBvcHRpb25zKSB7XG4gIGNvbnN0IGluc3RhbnRpYXRvciA9IG5ldyBHTFRGSW5zdGFudGlhdG9yKGdsLCBvcHRpb25zKTtcbiAgY29uc3Qgc2NlbmVzID0gaW5zdGFudGlhdG9yLmluc3RhbnRpYXRlKGdsdGYpO1xuICBjb25zdCBhbmltYXRvciA9IGluc3RhbnRpYXRvci5jcmVhdGVBbmltYXRvcigpO1xuICByZXR1cm4ge1xuICAgIHNjZW5lcyxcbiAgICBhbmltYXRvclxuICB9O1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y3JlYXRlLWdsdGYtb2JqZWN0cy5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///77910\n")},44522:function(__unused_webpack_module,__webpack_exports__,__webpack_require__){eval("/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Z\": function() { return /* binding */ ScenegraphNode; }\n/* harmony export */ });\n/* harmony import */ var _math_gl_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(43855);\n/* harmony import */ var _math_gl_core__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(85451);\n/* harmony import */ var _luma_gl_webgl__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(74538);\n/* harmony import */ var _luma_gl_webgl__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(22525);\n\n\nclass ScenegraphNode {\n  constructor() {\n    let props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    const {\n      id\n    } = props;\n    this.id = id || (0,_luma_gl_webgl__WEBPACK_IMPORTED_MODULE_0__/* .uid */ .hQ)(this.constructor.name);\n    this.display = true;\n    this.position = new _math_gl_core__WEBPACK_IMPORTED_MODULE_1__/* [\"default\"] */ .Z();\n    this.rotation = new _math_gl_core__WEBPACK_IMPORTED_MODULE_1__/* [\"default\"] */ .Z();\n    this.scale = new _math_gl_core__WEBPACK_IMPORTED_MODULE_1__/* [\"default\"] */ .Z(1, 1, 1);\n    this.matrix = new _math_gl_core__WEBPACK_IMPORTED_MODULE_2__/* [\"default\"] */ .Z();\n    this.userData = {};\n    this.props = {};\n\n    this._setScenegraphNodeProps(props);\n  }\n\n  delete() {}\n\n  setProps(props) {\n    this._setScenegraphNodeProps(props);\n\n    return this;\n  }\n\n  toString() {\n    return \"{type: ScenegraphNode, id: \".concat(this.id, \")}\");\n  }\n\n  getBounds() {\n    return null;\n  }\n\n  setPosition(position) {\n    (0,_luma_gl_webgl__WEBPACK_IMPORTED_MODULE_3__/* .assert */ .h)(position.length === 3, 'setPosition requires vector argument');\n    this.position = position;\n    return this;\n  }\n\n  setRotation(rotation) {\n    (0,_luma_gl_webgl__WEBPACK_IMPORTED_MODULE_3__/* .assert */ .h)(rotation.length === 3, 'setRotation requires vector argument');\n    this.rotation = rotation;\n    return this;\n  }\n\n  setScale(scale) {\n    (0,_luma_gl_webgl__WEBPACK_IMPORTED_MODULE_3__/* .assert */ .h)(scale.length === 3, 'setScale requires vector argument');\n    this.scale = scale;\n    return this;\n  }\n\n  setMatrix(matrix) {\n    let copyMatrix = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n\n    if (copyMatrix) {\n      this.matrix.copy(matrix);\n    } else {\n      this.matrix = matrix;\n    }\n  }\n\n  setMatrixComponents(_ref) {\n    let {\n      position,\n      rotation,\n      scale,\n      update = true\n    } = _ref;\n\n    if (position) {\n      this.setPosition(position);\n    }\n\n    if (rotation) {\n      this.setRotation(rotation);\n    }\n\n    if (scale) {\n      this.setScale(scale);\n    }\n\n    if (update) {\n      this.updateMatrix();\n    }\n\n    return this;\n  }\n\n  updateMatrix() {\n    const pos = this.position;\n    const rot = this.rotation;\n    const scale = this.scale;\n    this.matrix.identity();\n    this.matrix.translate(pos);\n    this.matrix.rotateXYZ(rot);\n    this.matrix.scale(scale);\n    return this;\n  }\n\n  update() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    const {\n      position,\n      rotation,\n      scale\n    } = options;\n\n    if (position) {\n      this.setPosition(position);\n    }\n\n    if (rotation) {\n      this.setRotation(rotation);\n    }\n\n    if (scale) {\n      this.setScale(scale);\n    }\n\n    this.updateMatrix();\n    return this;\n  }\n\n  getCoordinateUniforms(viewMatrix, modelMatrix) {\n    (0,_luma_gl_webgl__WEBPACK_IMPORTED_MODULE_3__/* .assert */ .h)(viewMatrix);\n    modelMatrix = modelMatrix || this.matrix;\n    const worldMatrix = new _math_gl_core__WEBPACK_IMPORTED_MODULE_2__/* [\"default\"] */ .Z(viewMatrix).multiplyRight(modelMatrix);\n    const worldInverse = worldMatrix.invert();\n    const worldInverseTranspose = worldInverse.transpose();\n    return {\n      viewMatrix,\n      modelMatrix,\n      objectMatrix: modelMatrix,\n      worldMatrix,\n      worldInverseMatrix: worldInverse,\n      worldInverseTransposeMatrix: worldInverseTranspose\n    };\n  }\n\n  _setScenegraphNodeProps(props) {\n    if ('display' in props) {\n      this.display = props.display;\n    }\n\n    if ('position' in props) {\n      this.setPosition(props.position);\n    }\n\n    if ('rotation' in props) {\n      this.setRotation(props.rotation);\n    }\n\n    if ('scale' in props) {\n      this.setScale(props.scale);\n    }\n\n    if ('matrix' in props) {\n      this.setMatrix(props.matrix);\n    }\n\n    Object.assign(this.props, props);\n  }\n\n}\n//# sourceMappingURL=scenegraph-node.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNDQ1MjIuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUFpRDtBQUNKO0FBQzlCO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ04sb0JBQW9CLDZEQUFHO0FBQ3ZCO0FBQ0Esd0JBQXdCLDhEQUFPO0FBQy9CLHdCQUF3Qiw4REFBTztBQUMvQixxQkFBcUIsOERBQU87QUFDNUIsc0JBQXNCLDhEQUFPO0FBQzdCO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxhQUFhLCtDQUErQztBQUM1RDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxJQUFJLCtEQUFNO0FBQ1Y7QUFDQTtBQUNBOztBQUVBO0FBQ0EsSUFBSSwrREFBTTtBQUNWO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLElBQUksK0RBQU07QUFDVjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNOztBQUVOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07O0FBRU47QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsSUFBSSwrREFBTTtBQUNWO0FBQ0EsNEJBQTRCLDhEQUFPO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3Z1ZTMtd2VicGFjazUvLi9ub2RlX21vZHVsZXMvQGx1bWEuZ2wvZXhwZXJpbWVudGFsL2Rpc3QvZXNtL3NjZW5lZ3JhcGgvc2NlbmVncmFwaC1ub2RlLmpzPzk3ZWMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgVmVjdG9yMywgTWF0cml4NCB9IGZyb20gJ0BtYXRoLmdsL2NvcmUnO1xuaW1wb3J0IHsgYXNzZXJ0LCB1aWQgfSBmcm9tICdAbHVtYS5nbC93ZWJnbCc7XG5leHBvcnQgZGVmYXVsdCBjbGFzcyBTY2VuZWdyYXBoTm9kZSB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIGxldCBwcm9wcyA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge307XG4gICAgY29uc3Qge1xuICAgICAgaWRcbiAgICB9ID0gcHJvcHM7XG4gICAgdGhpcy5pZCA9IGlkIHx8IHVpZCh0aGlzLmNvbnN0cnVjdG9yLm5hbWUpO1xuICAgIHRoaXMuZGlzcGxheSA9IHRydWU7XG4gICAgdGhpcy5wb3NpdGlvbiA9IG5ldyBWZWN0b3IzKCk7XG4gICAgdGhpcy5yb3RhdGlvbiA9IG5ldyBWZWN0b3IzKCk7XG4gICAgdGhpcy5zY2FsZSA9IG5ldyBWZWN0b3IzKDEsIDEsIDEpO1xuICAgIHRoaXMubWF0cml4ID0gbmV3IE1hdHJpeDQoKTtcbiAgICB0aGlzLnVzZXJEYXRhID0ge307XG4gICAgdGhpcy5wcm9wcyA9IHt9O1xuXG4gICAgdGhpcy5fc2V0U2NlbmVncmFwaE5vZGVQcm9wcyhwcm9wcyk7XG4gIH1cblxuICBkZWxldGUoKSB7fVxuXG4gIHNldFByb3BzKHByb3BzKSB7XG4gICAgdGhpcy5fc2V0U2NlbmVncmFwaE5vZGVQcm9wcyhwcm9wcyk7XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIHRvU3RyaW5nKCkge1xuICAgIHJldHVybiBcInt0eXBlOiBTY2VuZWdyYXBoTm9kZSwgaWQ6IFwiLmNvbmNhdCh0aGlzLmlkLCBcIil9XCIpO1xuICB9XG5cbiAgZ2V0Qm91bmRzKCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgc2V0UG9zaXRpb24ocG9zaXRpb24pIHtcbiAgICBhc3NlcnQocG9zaXRpb24ubGVuZ3RoID09PSAzLCAnc2V0UG9zaXRpb24gcmVxdWlyZXMgdmVjdG9yIGFyZ3VtZW50Jyk7XG4gICAgdGhpcy5wb3NpdGlvbiA9IHBvc2l0aW9uO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgc2V0Um90YXRpb24ocm90YXRpb24pIHtcbiAgICBhc3NlcnQocm90YXRpb24ubGVuZ3RoID09PSAzLCAnc2V0Um90YXRpb24gcmVxdWlyZXMgdmVjdG9yIGFyZ3VtZW50Jyk7XG4gICAgdGhpcy5yb3RhdGlvbiA9IHJvdGF0aW9uO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgc2V0U2NhbGUoc2NhbGUpIHtcbiAgICBhc3NlcnQoc2NhbGUubGVuZ3RoID09PSAzLCAnc2V0U2NhbGUgcmVxdWlyZXMgdmVjdG9yIGFyZ3VtZW50Jyk7XG4gICAgdGhpcy5zY2FsZSA9IHNjYWxlO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgc2V0TWF0cml4KG1hdHJpeCkge1xuICAgIGxldCBjb3B5TWF0cml4ID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB0cnVlO1xuXG4gICAgaWYgKGNvcHlNYXRyaXgpIHtcbiAgICAgIHRoaXMubWF0cml4LmNvcHkobWF0cml4KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5tYXRyaXggPSBtYXRyaXg7XG4gICAgfVxuICB9XG5cbiAgc2V0TWF0cml4Q29tcG9uZW50cyhfcmVmKSB7XG4gICAgbGV0IHtcbiAgICAgIHBvc2l0aW9uLFxuICAgICAgcm90YXRpb24sXG4gICAgICBzY2FsZSxcbiAgICAgIHVwZGF0ZSA9IHRydWVcbiAgICB9ID0gX3JlZjtcblxuICAgIGlmIChwb3NpdGlvbikge1xuICAgICAgdGhpcy5zZXRQb3NpdGlvbihwb3NpdGlvbik7XG4gICAgfVxuXG4gICAgaWYgKHJvdGF0aW9uKSB7XG4gICAgICB0aGlzLnNldFJvdGF0aW9uKHJvdGF0aW9uKTtcbiAgICB9XG5cbiAgICBpZiAoc2NhbGUpIHtcbiAgICAgIHRoaXMuc2V0U2NhbGUoc2NhbGUpO1xuICAgIH1cblxuICAgIGlmICh1cGRhdGUpIHtcbiAgICAgIHRoaXMudXBkYXRlTWF0cml4KCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICB1cGRhdGVNYXRyaXgoKSB7XG4gICAgY29uc3QgcG9zID0gdGhpcy5wb3NpdGlvbjtcbiAgICBjb25zdCByb3QgPSB0aGlzLnJvdGF0aW9uO1xuICAgIGNvbnN0IHNjYWxlID0gdGhpcy5zY2FsZTtcbiAgICB0aGlzLm1hdHJpeC5pZGVudGl0eSgpO1xuICAgIHRoaXMubWF0cml4LnRyYW5zbGF0ZShwb3MpO1xuICAgIHRoaXMubWF0cml4LnJvdGF0ZVhZWihyb3QpO1xuICAgIHRoaXMubWF0cml4LnNjYWxlKHNjYWxlKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIHVwZGF0ZSgpIHtcbiAgICBsZXQgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge307XG4gICAgY29uc3Qge1xuICAgICAgcG9zaXRpb24sXG4gICAgICByb3RhdGlvbixcbiAgICAgIHNjYWxlXG4gICAgfSA9IG9wdGlvbnM7XG5cbiAgICBpZiAocG9zaXRpb24pIHtcbiAgICAgIHRoaXMuc2V0UG9zaXRpb24ocG9zaXRpb24pO1xuICAgIH1cblxuICAgIGlmIChyb3RhdGlvbikge1xuICAgICAgdGhpcy5zZXRSb3RhdGlvbihyb3RhdGlvbik7XG4gICAgfVxuXG4gICAgaWYgKHNjYWxlKSB7XG4gICAgICB0aGlzLnNldFNjYWxlKHNjYWxlKTtcbiAgICB9XG5cbiAgICB0aGlzLnVwZGF0ZU1hdHJpeCgpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgZ2V0Q29vcmRpbmF0ZVVuaWZvcm1zKHZpZXdNYXRyaXgsIG1vZGVsTWF0cml4KSB7XG4gICAgYXNzZXJ0KHZpZXdNYXRyaXgpO1xuICAgIG1vZGVsTWF0cml4ID0gbW9kZWxNYXRyaXggfHwgdGhpcy5tYXRyaXg7XG4gICAgY29uc3Qgd29ybGRNYXRyaXggPSBuZXcgTWF0cml4NCh2aWV3TWF0cml4KS5tdWx0aXBseVJpZ2h0KG1vZGVsTWF0cml4KTtcbiAgICBjb25zdCB3b3JsZEludmVyc2UgPSB3b3JsZE1hdHJpeC5pbnZlcnQoKTtcbiAgICBjb25zdCB3b3JsZEludmVyc2VUcmFuc3Bvc2UgPSB3b3JsZEludmVyc2UudHJhbnNwb3NlKCk7XG4gICAgcmV0dXJuIHtcbiAgICAgIHZpZXdNYXRyaXgsXG4gICAgICBtb2RlbE1hdHJpeCxcbiAgICAgIG9iamVjdE1hdHJpeDogbW9kZWxNYXRyaXgsXG4gICAgICB3b3JsZE1hdHJpeCxcbiAgICAgIHdvcmxkSW52ZXJzZU1hdHJpeDogd29ybGRJbnZlcnNlLFxuICAgICAgd29ybGRJbnZlcnNlVHJhbnNwb3NlTWF0cml4OiB3b3JsZEludmVyc2VUcmFuc3Bvc2VcbiAgICB9O1xuICB9XG5cbiAgX3NldFNjZW5lZ3JhcGhOb2RlUHJvcHMocHJvcHMpIHtcbiAgICBpZiAoJ2Rpc3BsYXknIGluIHByb3BzKSB7XG4gICAgICB0aGlzLmRpc3BsYXkgPSBwcm9wcy5kaXNwbGF5O1xuICAgIH1cblxuICAgIGlmICgncG9zaXRpb24nIGluIHByb3BzKSB7XG4gICAgICB0aGlzLnNldFBvc2l0aW9uKHByb3BzLnBvc2l0aW9uKTtcbiAgICB9XG5cbiAgICBpZiAoJ3JvdGF0aW9uJyBpbiBwcm9wcykge1xuICAgICAgdGhpcy5zZXRSb3RhdGlvbihwcm9wcy5yb3RhdGlvbik7XG4gICAgfVxuXG4gICAgaWYgKCdzY2FsZScgaW4gcHJvcHMpIHtcbiAgICAgIHRoaXMuc2V0U2NhbGUocHJvcHMuc2NhbGUpO1xuICAgIH1cblxuICAgIGlmICgnbWF0cml4JyBpbiBwcm9wcykge1xuICAgICAgdGhpcy5zZXRNYXRyaXgocHJvcHMubWF0cml4KTtcbiAgICB9XG5cbiAgICBPYmplY3QuYXNzaWduKHRoaXMucHJvcHMsIHByb3BzKTtcbiAgfVxuXG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zY2VuZWdyYXBoLW5vZGUuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///44522\n")},1418:function(__unused_webpack_module,__webpack_exports__,__webpack_require__){eval("\n// EXPORTS\n__webpack_require__.d(__webpack_exports__, {\n  \"KQ\": function() { return /* reexport */ assertWebGL2Context; },\n  \"JD\": function() { return /* reexport */ assertWebGLContext; },\n  \"s9\": function() { return /* reexport */ createGLContext; },\n  \"JY\": function() { return /* reexport */ cssToDevicePixels; },\n  \"w\": function() { return /* reexport */ cssToDeviceRatio; },\n  \"vd\": function() { return /* reexport */ getWebGL2Context; },\n  \"yW\": function() { return /* reexport */ instrumentGLContext; },\n  \"UF\": function() { return /* reexport */ isWebGL; },\n  \"D0\": function() { return /* reexport */ isWebGL2; },\n  \"cM\": function() { return /* reexport */ log_log; },\n  \"kL\": function() { return /* reexport */ resetParameters; },\n  \"aQ\": function() { return /* reexport */ resizeGLContext; },\n  \"dR\": function() { return /* reexport */ setParameters; },\n  \"s8\": function() { return /* reexport */ withParameters; }\n});\n\n// UNUSED EXPORTS: getContextDebugInfo, getParameters, polyfillContext, popContextState, pushContextState, trackContextState\n\n// EXTERNAL MODULE: ./node_modules/@probe.gl/log/dist/esm/log.js + 8 modules\nvar log = __webpack_require__(56426);\n;// CONCATENATED MODULE: ./node_modules/@luma.gl/gltools/dist/esm/utils/log.js\n\nconst log_log = new log/* Log */.Z({\n  id: 'luma.gl'\n});\n//# sourceMappingURL=log.js.map\n;// CONCATENATED MODULE: ./node_modules/@luma.gl/gltools/dist/esm/utils/assert.js\nfunction assert(condition, message) {\n  if (!condition) {\n    throw new Error(message || 'luma.gl: assertion failed.');\n  }\n}\n//# sourceMappingURL=assert.js.map\n;// CONCATENATED MODULE: ./node_modules/@luma.gl/gltools/dist/esm/utils/webgl-checks.js\n\nconst ERR_CONTEXT = 'Invalid WebGLRenderingContext';\nconst ERR_WEBGL = (/* unused pure expression or super */ null && (ERR_CONTEXT));\nconst ERR_WEBGL2 = 'Requires WebGL2';\nfunction isWebGL(gl) {\n  if (typeof WebGLRenderingContext !== 'undefined' && gl instanceof WebGLRenderingContext) {\n    return true;\n  }\n\n  if (typeof WebGL2RenderingContext !== 'undefined' && gl instanceof WebGL2RenderingContext) {\n    return true;\n  }\n\n  return Boolean(gl && Number.isFinite(gl._version));\n}\nfunction isWebGL2(gl) {\n  if (typeof WebGL2RenderingContext !== 'undefined' && gl instanceof WebGL2RenderingContext) {\n    return true;\n  }\n\n  return Boolean(gl && gl._version === 2);\n}\nfunction getWebGL2Context(gl) {\n  return isWebGL2(gl) ? gl : null;\n}\nfunction assertWebGLContext(gl) {\n  assert(isWebGL(gl), ERR_CONTEXT);\n  return gl;\n}\nfunction assertWebGL2Context(gl) {\n  assert(isWebGL2(gl), ERR_WEBGL2);\n  return gl;\n}\n//# sourceMappingURL=webgl-checks.js.map\n;// CONCATENATED MODULE: ./node_modules/@luma.gl/gltools/dist/esm/polyfill/polyfill-vertex-array-object.js\nconst glErrorShadow = {};\n\nfunction error(msg) {\n  if (globalThis.console && globalThis.console.error) {\n    globalThis.console.error(msg);\n  }\n}\n\nfunction polyfill_vertex_array_object_log(msg) {\n  if (globalThis.console && globalThis.console.log) {\n    globalThis.console.log(msg);\n  }\n}\n\nfunction synthesizeGLError(err, opt_msg) {\n  glErrorShadow[err] = true;\n\n  if (opt_msg !== undefined) {\n    error(opt_msg);\n  }\n}\n\nfunction wrapGLError(gl) {\n  const f = gl.getError;\n\n  gl.getError = function getError() {\n    let err;\n\n    do {\n      err = f.apply(gl);\n\n      if (err !== 0) {\n        glErrorShadow[err] = true;\n      }\n    } while (err !== 0);\n\n    for (err in glErrorShadow) {\n      if (glErrorShadow[err]) {\n        delete glErrorShadow[err];\n        return parseInt(err, 10);\n      }\n    }\n\n    return 0;\n  };\n}\n\nconst WebGLVertexArrayObjectOES = function WebGLVertexArrayObjectOES(ext) {\n  const gl = ext.gl;\n  this.ext = ext;\n  this.isAlive = true;\n  this.hasBeenBound = false;\n  this.elementArrayBuffer = null;\n  this.attribs = new Array(ext.maxVertexAttribs);\n\n  for (let n = 0; n < this.attribs.length; n++) {\n    const attrib = new WebGLVertexArrayObjectOES.VertexAttrib(gl);\n    this.attribs[n] = attrib;\n  }\n\n  this.maxAttrib = 0;\n};\n\nWebGLVertexArrayObjectOES.VertexAttrib = function VertexAttrib(gl) {\n  this.enabled = false;\n  this.buffer = null;\n  this.size = 4;\n  this.type = 5126;\n  this.normalized = false;\n  this.stride = 16;\n  this.offset = 0;\n  this.cached = '';\n  this.recache();\n};\n\nWebGLVertexArrayObjectOES.VertexAttrib.prototype.recache = function recache() {\n  this.cached = [this.size, this.type, this.normalized, this.stride, this.offset].join(':');\n};\n\nconst OESVertexArrayObject = function OESVertexArrayObject(gl) {\n  const self = this;\n  this.gl = gl;\n  wrapGLError(gl);\n  const original = this.original = {\n    getParameter: gl.getParameter,\n    enableVertexAttribArray: gl.enableVertexAttribArray,\n    disableVertexAttribArray: gl.disableVertexAttribArray,\n    bindBuffer: gl.bindBuffer,\n    getVertexAttrib: gl.getVertexAttrib,\n    vertexAttribPointer: gl.vertexAttribPointer\n  };\n\n  gl.getParameter = function getParameter(pname) {\n    if (pname === self.VERTEX_ARRAY_BINDING_OES) {\n      if (self.currentVertexArrayObject === self.defaultVertexArrayObject) {\n        return null;\n      }\n\n      return self.currentVertexArrayObject;\n    }\n\n    return original.getParameter.apply(this, arguments);\n  };\n\n  gl.enableVertexAttribArray = function enableVertexAttribArray(index) {\n    const vao = self.currentVertexArrayObject;\n    vao.maxAttrib = Math.max(vao.maxAttrib, index);\n    const attrib = vao.attribs[index];\n    attrib.enabled = true;\n    return original.enableVertexAttribArray.apply(this, arguments);\n  };\n\n  gl.disableVertexAttribArray = function disableVertexAttribArray(index) {\n    const vao = self.currentVertexArrayObject;\n    vao.maxAttrib = Math.max(vao.maxAttrib, index);\n    const attrib = vao.attribs[index];\n    attrib.enabled = false;\n    return original.disableVertexAttribArray.apply(this, arguments);\n  };\n\n  gl.bindBuffer = function bindBuffer(target, buffer) {\n    switch (target) {\n      case 34962:\n        self.currentArrayBuffer = buffer;\n        break;\n\n      case 34963:\n        self.currentVertexArrayObject.elementArrayBuffer = buffer;\n        break;\n\n      default:\n    }\n\n    return original.bindBuffer.apply(this, arguments);\n  };\n\n  gl.getVertexAttrib = function getVertexAttrib(index, pname) {\n    const vao = self.currentVertexArrayObject;\n    const attrib = vao.attribs[index];\n\n    switch (pname) {\n      case 34975:\n        return attrib.buffer;\n\n      case 34338:\n        return attrib.enabled;\n\n      case 34339:\n        return attrib.size;\n\n      case 34340:\n        return attrib.stride;\n\n      case 34341:\n        return attrib.type;\n\n      case 34922:\n        return attrib.normalized;\n\n      default:\n        return original.getVertexAttrib.apply(this, arguments);\n    }\n  };\n\n  gl.vertexAttribPointer = function vertexAttribPointer(indx, size, type, normalized, stride, offset) {\n    const vao = self.currentVertexArrayObject;\n    vao.maxAttrib = Math.max(vao.maxAttrib, indx);\n    const attrib = vao.attribs[indx];\n    attrib.buffer = self.currentArrayBuffer;\n    attrib.size = size;\n    attrib.type = type;\n    attrib.normalized = normalized;\n    attrib.stride = stride;\n    attrib.offset = offset;\n    attrib.recache();\n    return original.vertexAttribPointer.apply(this, arguments);\n  };\n\n  if (gl.instrumentExtension) {\n    gl.instrumentExtension(this, 'OES_vertex_array_object');\n  }\n\n  if (gl.canvas) {\n    gl.canvas.addEventListener('webglcontextrestored', () => {\n      polyfill_vertex_array_object_log('OESVertexArrayObject emulation library context restored');\n      self.reset_();\n    }, true);\n  }\n\n  this.reset_();\n};\n\nOESVertexArrayObject.prototype.VERTEX_ARRAY_BINDING_OES = 0x85b5;\n\nOESVertexArrayObject.prototype.reset_ = function reset_() {\n  const contextWasLost = this.vertexArrayObjects !== undefined;\n\n  if (contextWasLost) {\n    for (let ii = 0; ii < this.vertexArrayObjects.length; ++ii) {\n      this.vertexArrayObjects.isAlive = false;\n    }\n  }\n\n  const gl = this.gl;\n  this.maxVertexAttribs = gl.getParameter(34921);\n  this.defaultVertexArrayObject = new WebGLVertexArrayObjectOES(this);\n  this.currentVertexArrayObject = null;\n  this.currentArrayBuffer = null;\n  this.vertexArrayObjects = [this.defaultVertexArrayObject];\n  this.bindVertexArrayOES(null);\n};\n\nOESVertexArrayObject.prototype.createVertexArrayOES = function createVertexArrayOES() {\n  const arrayObject = new WebGLVertexArrayObjectOES(this);\n  this.vertexArrayObjects.push(arrayObject);\n  return arrayObject;\n};\n\nOESVertexArrayObject.prototype.deleteVertexArrayOES = function deleteVertexArrayOES(arrayObject) {\n  arrayObject.isAlive = false;\n  this.vertexArrayObjects.splice(this.vertexArrayObjects.indexOf(arrayObject), 1);\n\n  if (this.currentVertexArrayObject === arrayObject) {\n    this.bindVertexArrayOES(null);\n  }\n};\n\nOESVertexArrayObject.prototype.isVertexArrayOES = function isVertexArrayOES(arrayObject) {\n  if (arrayObject && arrayObject instanceof WebGLVertexArrayObjectOES) {\n    if (arrayObject.hasBeenBound && arrayObject.ext === this) {\n      return true;\n    }\n  }\n\n  return false;\n};\n\nOESVertexArrayObject.prototype.bindVertexArrayOES = function bindVertexArrayOES(arrayObject) {\n  const gl = this.gl;\n\n  if (arrayObject && !arrayObject.isAlive) {\n    synthesizeGLError(1282, 'bindVertexArrayOES: attempt to bind deleted arrayObject');\n    return;\n  }\n\n  const original = this.original;\n  const oldVAO = this.currentVertexArrayObject;\n  this.currentVertexArrayObject = arrayObject || this.defaultVertexArrayObject;\n  this.currentVertexArrayObject.hasBeenBound = true;\n  const newVAO = this.currentVertexArrayObject;\n\n  if (oldVAO === newVAO) {\n    return;\n  }\n\n  if (!oldVAO || newVAO.elementArrayBuffer !== oldVAO.elementArrayBuffer) {\n    original.bindBuffer.call(gl, 34963, newVAO.elementArrayBuffer);\n  }\n\n  let currentBinding = this.currentArrayBuffer;\n  const maxAttrib = Math.max(oldVAO ? oldVAO.maxAttrib : 0, newVAO.maxAttrib);\n\n  for (let n = 0; n <= maxAttrib; n++) {\n    const attrib = newVAO.attribs[n];\n    const oldAttrib = oldVAO ? oldVAO.attribs[n] : null;\n\n    if (!oldVAO || attrib.enabled !== oldAttrib.enabled) {\n      if (attrib.enabled) {\n        original.enableVertexAttribArray.call(gl, n);\n      } else {\n        original.disableVertexAttribArray.call(gl, n);\n      }\n    }\n\n    if (attrib.enabled) {\n      let bufferChanged = false;\n\n      if (!oldVAO || attrib.buffer !== oldAttrib.buffer) {\n        if (currentBinding !== attrib.buffer) {\n          original.bindBuffer.call(gl, 34962, attrib.buffer);\n          currentBinding = attrib.buffer;\n        }\n\n        bufferChanged = true;\n      }\n\n      if (bufferChanged || attrib.cached !== oldAttrib.cached) {\n        original.vertexAttribPointer.call(gl, n, attrib.size, attrib.type, attrib.normalized, attrib.stride, attrib.offset);\n      }\n    }\n  }\n\n  if (this.currentArrayBuffer !== currentBinding) {\n    original.bindBuffer.call(gl, 34962, this.currentArrayBuffer);\n  }\n};\n\nfunction polyfillVertexArrayObject(gl) {\n  if (typeof gl.createVertexArray === 'function') {\n    return;\n  }\n\n  const original_getSupportedExtensions = gl.getSupportedExtensions;\n\n  gl.getSupportedExtensions = function getSupportedExtensions() {\n    const list = original_getSupportedExtensions.call(this) || [];\n\n    if (list.indexOf('OES_vertex_array_object') < 0) {\n      list.push('OES_vertex_array_object');\n    }\n\n    return list;\n  };\n\n  const original_getExtension = gl.getExtension;\n\n  gl.getExtension = function getExtension(name) {\n    const ext = original_getExtension.call(this, name);\n\n    if (ext) {\n      return ext;\n    }\n\n    if (name !== 'OES_vertex_array_object') {\n      return null;\n    }\n\n    if (!gl.__OESVertexArrayObject) {\n      this.__OESVertexArrayObject = new OESVertexArrayObject(this);\n    }\n\n    return this.__OESVertexArrayObject;\n  };\n}\n//# sourceMappingURL=polyfill-vertex-array-object.js.map\n;// CONCATENATED MODULE: ./node_modules/@luma.gl/gltools/dist/esm/polyfill/get-parameter-polyfill.js\n\nconst OES_element_index = 'OES_element_index';\nconst WEBGL_draw_buffers = 'WEBGL_draw_buffers';\nconst EXT_disjoint_timer_query = 'EXT_disjoint_timer_query';\nconst EXT_disjoint_timer_query_webgl2 = 'EXT_disjoint_timer_query_webgl2';\nconst EXT_texture_filter_anisotropic = 'EXT_texture_filter_anisotropic';\nconst WEBGL_debug_renderer_info = 'WEBGL_debug_renderer_info';\nconst GL_FRAGMENT_SHADER_DERIVATIVE_HINT = 0x8b8b;\nconst GL_DONT_CARE = 0x1100;\nconst GL_GPU_DISJOINT_EXT = 0x8fbb;\nconst GL_MAX_TEXTURE_MAX_ANISOTROPY_EXT = 0x84ff;\nconst GL_UNMASKED_VENDOR_WEBGL = 0x9245;\nconst GL_UNMASKED_RENDERER_WEBGL = 0x9246;\n\nconst getWebGL2ValueOrZero = gl => !isWebGL2(gl) ? 0 : undefined;\n\nconst WEBGL_PARAMETERS = {\n  [3074]: gl => !isWebGL2(gl) ? 36064 : undefined,\n  [GL_FRAGMENT_SHADER_DERIVATIVE_HINT]: gl => !isWebGL2(gl) ? GL_DONT_CARE : undefined,\n  [35977]: getWebGL2ValueOrZero,\n  [32937]: getWebGL2ValueOrZero,\n  [GL_GPU_DISJOINT_EXT]: (gl, getParameter) => {\n    const ext = isWebGL2(gl) ? gl.getExtension(EXT_disjoint_timer_query_webgl2) : gl.getExtension(EXT_disjoint_timer_query);\n    return ext && ext.GPU_DISJOINT_EXT ? getParameter(ext.GPU_DISJOINT_EXT) : 0;\n  },\n  [GL_UNMASKED_VENDOR_WEBGL]: (gl, getParameter) => {\n    const ext = gl.getExtension(WEBGL_debug_renderer_info);\n    return getParameter(ext && ext.UNMASKED_VENDOR_WEBGL || 7936);\n  },\n  [GL_UNMASKED_RENDERER_WEBGL]: (gl, getParameter) => {\n    const ext = gl.getExtension(WEBGL_debug_renderer_info);\n    return getParameter(ext && ext.UNMASKED_RENDERER_WEBGL || 7937);\n  },\n  [GL_MAX_TEXTURE_MAX_ANISOTROPY_EXT]: (gl, getParameter) => {\n    const ext = gl.luma.extensions[EXT_texture_filter_anisotropic];\n    return ext ? getParameter(ext.MAX_TEXTURE_MAX_ANISOTROPY_EXT) : 1.0;\n  },\n  [32883]: getWebGL2ValueOrZero,\n  [35071]: getWebGL2ValueOrZero,\n  [37447]: getWebGL2ValueOrZero,\n  [36063]: (gl, getParameter) => {\n    if (!isWebGL2(gl)) {\n      const ext = gl.getExtension(WEBGL_draw_buffers);\n      return ext ? getParameter(ext.MAX_COLOR_ATTACHMENTS_WEBGL) : 0;\n    }\n\n    return undefined;\n  },\n  [35379]: getWebGL2ValueOrZero,\n  [35374]: getWebGL2ValueOrZero,\n  [35377]: getWebGL2ValueOrZero,\n  [34852]: gl => {\n    if (!isWebGL2(gl)) {\n      const ext = gl.getExtension(WEBGL_draw_buffers);\n      return ext ? ext.MAX_DRAW_BUFFERS_WEBGL : 0;\n    }\n\n    return undefined;\n  },\n  [36203]: gl => gl.getExtension(OES_element_index) ? 2147483647 : 65535,\n  [33001]: gl => gl.getExtension(OES_element_index) ? 16777216 : 65535,\n  [33000]: gl => 16777216,\n  [37157]: getWebGL2ValueOrZero,\n  [35373]: getWebGL2ValueOrZero,\n  [35657]: getWebGL2ValueOrZero,\n  [36183]: getWebGL2ValueOrZero,\n  [37137]: getWebGL2ValueOrZero,\n  [34045]: getWebGL2ValueOrZero,\n  [35978]: getWebGL2ValueOrZero,\n  [35979]: getWebGL2ValueOrZero,\n  [35968]: getWebGL2ValueOrZero,\n  [35376]: getWebGL2ValueOrZero,\n  [35375]: getWebGL2ValueOrZero,\n  [35659]: getWebGL2ValueOrZero,\n  [37154]: getWebGL2ValueOrZero,\n  [35371]: getWebGL2ValueOrZero,\n  [35658]: getWebGL2ValueOrZero,\n  [35076]: getWebGL2ValueOrZero,\n  [35077]: getWebGL2ValueOrZero,\n  [35380]: getWebGL2ValueOrZero\n};\nfunction getParameterPolyfill(gl, originalGetParameter, pname) {\n  const limit = WEBGL_PARAMETERS[pname];\n  const value = typeof limit === 'function' ? limit(gl, originalGetParameter, pname) : limit;\n  const result = value !== undefined ? value : originalGetParameter(pname);\n  return result;\n}\n//# sourceMappingURL=get-parameter-polyfill.js.map\n;// CONCATENATED MODULE: ./node_modules/@luma.gl/gltools/dist/esm/polyfill/polyfill-table.js\n\n\n\nconst OES_vertex_array_object = 'OES_vertex_array_object';\nconst ANGLE_instanced_arrays = 'ANGLE_instanced_arrays';\nconst polyfill_table_WEBGL_draw_buffers = 'WEBGL_draw_buffers';\nconst polyfill_table_EXT_disjoint_timer_query = 'EXT_disjoint_timer_query';\nconst polyfill_table_EXT_texture_filter_anisotropic = 'EXT_texture_filter_anisotropic';\nconst ERR_VAO_NOT_SUPPORTED = 'VertexArray requires WebGL2 or OES_vertex_array_object extension';\n\nfunction getExtensionData(gl, extension) {\n  return {\n    webgl2: isWebGL2(gl),\n    ext: gl.getExtension(extension)\n  };\n}\n\nconst WEBGL2_CONTEXT_POLYFILLS = {\n  [OES_vertex_array_object]: {\n    meta: {\n      suffix: 'OES'\n    },\n    createVertexArray: () => {\n      assert(false, ERR_VAO_NOT_SUPPORTED);\n    },\n    deleteVertexArray: () => {},\n    bindVertexArray: () => {},\n    isVertexArray: () => false\n  },\n  [ANGLE_instanced_arrays]: {\n    meta: {\n      suffix: 'ANGLE'\n    },\n\n    vertexAttribDivisor(location, divisor) {\n      assert(divisor === 0, 'WebGL instanced rendering not supported');\n    },\n\n    drawElementsInstanced: () => {},\n    drawArraysInstanced: () => {}\n  },\n  [polyfill_table_WEBGL_draw_buffers]: {\n    meta: {\n      suffix: 'WEBGL'\n    },\n    drawBuffers: () => {\n      assert(false);\n    }\n  },\n  [polyfill_table_EXT_disjoint_timer_query]: {\n    meta: {\n      suffix: 'EXT'\n    },\n    createQuery: () => {\n      assert(false);\n    },\n    deleteQuery: () => {\n      assert(false);\n    },\n    beginQuery: () => {\n      assert(false);\n    },\n    endQuery: () => {},\n\n    getQuery(handle, pname) {\n      return this.getQueryObject(handle, pname);\n    },\n\n    getQueryParameter(handle, pname) {\n      return this.getQueryObject(handle, pname);\n    },\n\n    getQueryObject: () => {}\n  }\n};\nconst WEBGL2_CONTEXT_OVERRIDES = {\n  readBuffer: (gl, originalFunc, attachment) => {\n    if (isWebGL2(gl)) {\n      originalFunc(attachment);\n    } else {}\n  },\n  getVertexAttrib: (gl, originalFunc, location, pname) => {\n    const {\n      webgl2,\n      ext\n    } = getExtensionData(gl, ANGLE_instanced_arrays);\n    let result;\n\n    switch (pname) {\n      case 35069:\n        result = !webgl2 ? false : undefined;\n        break;\n\n      case 35070:\n        result = !webgl2 && !ext ? 0 : undefined;\n        break;\n\n      default:\n    }\n\n    return result !== undefined ? result : originalFunc(location, pname);\n  },\n  getProgramParameter: (gl, originalFunc, program, pname) => {\n    if (!isWebGL2(gl)) {\n      switch (pname) {\n        case 35967:\n          return 35981;\n\n        case 35971:\n          return 0;\n\n        case 35382:\n          return 0;\n\n        default:\n      }\n    }\n\n    return originalFunc(program, pname);\n  },\n  getInternalformatParameter: (gl, originalFunc, target, format, pname) => {\n    if (!isWebGL2(gl)) {\n      switch (pname) {\n        case 32937:\n          return new Int32Array([0]);\n\n        default:\n      }\n    }\n\n    return gl.getInternalformatParameter(target, format, pname);\n  },\n\n  getTexParameter(gl, originalFunc, target, pname) {\n    switch (pname) {\n      case 34046:\n        const {\n          extensions\n        } = gl.luma;\n        const ext = extensions[polyfill_table_EXT_texture_filter_anisotropic];\n        pname = ext && ext.TEXTURE_MAX_ANISOTROPY_EXT || 34046;\n        break;\n\n      default:\n    }\n\n    return originalFunc(target, pname);\n  },\n\n  getParameter: getParameterPolyfill,\n\n  hint(gl, originalFunc, pname, value) {\n    return originalFunc(pname, value);\n  }\n\n};\n//# sourceMappingURL=polyfill-table.js.map\n;// CONCATENATED MODULE: ./node_modules/@luma.gl/gltools/dist/esm/polyfill/polyfill-context.js\n\n\n\nfunction polyfillContext(gl) {\n  gl.luma = gl.luma || {};\n  const {\n    luma\n  } = gl;\n\n  if (!luma.polyfilled) {\n    polyfillVertexArrayObject(gl);\n    initializeExtensions(gl);\n    installPolyfills(gl, WEBGL2_CONTEXT_POLYFILLS);\n    installOverrides(gl, {\n      target: luma,\n      target2: gl\n    });\n    luma.polyfilled = true;\n  }\n\n  return gl;\n}\nglobalThis.polyfillContext = polyfillContext;\n\nfunction initializeExtensions(gl) {\n  gl.luma.extensions = {};\n  const EXTENSIONS = gl.getSupportedExtensions() || [];\n\n  for (const extension of EXTENSIONS) {\n    gl.luma[extension] = gl.getExtension(extension);\n  }\n}\n\nfunction installOverrides(gl, _ref) {\n  let {\n    target,\n    target2\n  } = _ref;\n  Object.keys(WEBGL2_CONTEXT_OVERRIDES).forEach(key => {\n    if (typeof WEBGL2_CONTEXT_OVERRIDES[key] === 'function') {\n      const originalFunc = gl[key] ? gl[key].bind(gl) : () => {};\n      const polyfill = WEBGL2_CONTEXT_OVERRIDES[key].bind(null, gl, originalFunc);\n      target[key] = polyfill;\n      target2[key] = polyfill;\n    }\n  });\n}\n\nfunction installPolyfills(gl, polyfills) {\n  for (const extension of Object.getOwnPropertyNames(polyfills)) {\n    if (extension !== 'overrides') {\n      polyfillExtension(gl, {\n        extension,\n        target: gl.luma,\n        target2: gl\n      });\n    }\n  }\n}\n\nfunction polyfillExtension(gl, _ref2) {\n  let {\n    extension,\n    target,\n    target2\n  } = _ref2;\n  const defaults = WEBGL2_CONTEXT_POLYFILLS[extension];\n  assert(defaults);\n  const {\n    meta = {}\n  } = defaults;\n  const {\n    suffix = ''\n  } = meta;\n  const ext = gl.getExtension(extension);\n\n  for (const key of Object.keys(defaults)) {\n    const extKey = \"\".concat(key).concat(suffix);\n    let polyfill = null;\n\n    if (key === 'meta') {} else if (typeof gl[key] === 'function') {} else if (ext && typeof ext[extKey] === 'function') {\n      polyfill = function () {\n        return ext[extKey](...arguments);\n      };\n    } else if (typeof defaults[key] === 'function') {\n      polyfill = defaults[key].bind(target);\n    }\n\n    if (polyfill) {\n      target[key] = polyfill;\n      target2[key] = polyfill;\n    }\n  }\n}\n//# sourceMappingURL=polyfill-context.js.map\n;// CONCATENATED MODULE: ./node_modules/@luma.gl/gltools/dist/esm/state-tracker/webgl-parameter-tables.js\n\nconst GL_PARAMETER_DEFAULTS = {\n  [3042]: false,\n  [32773]: new Float32Array([0, 0, 0, 0]),\n  [32777]: 32774,\n  [34877]: 32774,\n  [32969]: 1,\n  [32968]: 0,\n  [32971]: 1,\n  [32970]: 0,\n  [3106]: new Float32Array([0, 0, 0, 0]),\n  [3107]: [true, true, true, true],\n  [2884]: false,\n  [2885]: 1029,\n  [2929]: false,\n  [2931]: 1,\n  [2932]: 513,\n  [2928]: new Float32Array([0, 1]),\n  [2930]: true,\n  [3024]: true,\n  [36006]: null,\n  [2886]: 2305,\n  [33170]: 4352,\n  [2849]: 1,\n  [32823]: false,\n  [32824]: 0,\n  [10752]: 0,\n  [32938]: 1.0,\n  [32939]: false,\n  [3089]: false,\n  [3088]: new Int32Array([0, 0, 1024, 1024]),\n  [2960]: false,\n  [2961]: 0,\n  [2968]: 0xffffffff,\n  [36005]: 0xffffffff,\n  [2962]: 519,\n  [2967]: 0,\n  [2963]: 0xffffffff,\n  [34816]: 519,\n  [36003]: 0,\n  [36004]: 0xffffffff,\n  [2964]: 7680,\n  [2965]: 7680,\n  [2966]: 7680,\n  [34817]: 7680,\n  [34818]: 7680,\n  [34819]: 7680,\n  [2978]: [0, 0, 1024, 1024],\n  [3333]: 4,\n  [3317]: 4,\n  [37440]: false,\n  [37441]: false,\n  [37443]: 37444,\n  [35723]: 4352,\n  [36010]: null,\n  [35977]: false,\n  [3330]: 0,\n  [3332]: 0,\n  [3331]: 0,\n  [3314]: 0,\n  [32878]: 0,\n  [3316]: 0,\n  [3315]: 0,\n  [32877]: 0\n};\n\nconst enable = (gl, value, key) => value ? gl.enable(key) : gl.disable(key);\n\nconst hint = (gl, value, key) => gl.hint(key, value);\n\nconst pixelStorei = (gl, value, key) => gl.pixelStorei(key, value);\n\nconst drawFramebuffer = (gl, value) => {\n  const target = isWebGL2(gl) ? 36009 : 36160;\n  return gl.bindFramebuffer(target, value);\n};\n\nconst readFramebuffer = (gl, value) => {\n  return gl.bindFramebuffer(36008, value);\n};\n\nfunction isArray(array) {\n  return Array.isArray(array) || ArrayBuffer.isView(array);\n}\n\nconst GL_PARAMETER_SETTERS = {\n  [3042]: enable,\n  [32773]: (gl, value) => gl.blendColor(...value),\n  [32777]: 'blendEquation',\n  [34877]: 'blendEquation',\n  [32969]: 'blendFunc',\n  [32968]: 'blendFunc',\n  [32971]: 'blendFunc',\n  [32970]: 'blendFunc',\n  [3106]: (gl, value) => gl.clearColor(...value),\n  [3107]: (gl, value) => gl.colorMask(...value),\n  [2884]: enable,\n  [2885]: (gl, value) => gl.cullFace(value),\n  [2929]: enable,\n  [2931]: (gl, value) => gl.clearDepth(value),\n  [2932]: (gl, value) => gl.depthFunc(value),\n  [2928]: (gl, value) => gl.depthRange(...value),\n  [2930]: (gl, value) => gl.depthMask(value),\n  [3024]: enable,\n  [35723]: hint,\n  [36006]: drawFramebuffer,\n  [2886]: (gl, value) => gl.frontFace(value),\n  [33170]: hint,\n  [2849]: (gl, value) => gl.lineWidth(value),\n  [32823]: enable,\n  [32824]: 'polygonOffset',\n  [10752]: 'polygonOffset',\n  [35977]: enable,\n  [32938]: 'sampleCoverage',\n  [32939]: 'sampleCoverage',\n  [3089]: enable,\n  [3088]: (gl, value) => gl.scissor(...value),\n  [2960]: enable,\n  [2961]: (gl, value) => gl.clearStencil(value),\n  [2968]: (gl, value) => gl.stencilMaskSeparate(1028, value),\n  [36005]: (gl, value) => gl.stencilMaskSeparate(1029, value),\n  [2962]: 'stencilFuncFront',\n  [2967]: 'stencilFuncFront',\n  [2963]: 'stencilFuncFront',\n  [34816]: 'stencilFuncBack',\n  [36003]: 'stencilFuncBack',\n  [36004]: 'stencilFuncBack',\n  [2964]: 'stencilOpFront',\n  [2965]: 'stencilOpFront',\n  [2966]: 'stencilOpFront',\n  [34817]: 'stencilOpBack',\n  [34818]: 'stencilOpBack',\n  [34819]: 'stencilOpBack',\n  [2978]: (gl, value) => gl.viewport(...value),\n  [3333]: pixelStorei,\n  [3317]: pixelStorei,\n  [37440]: pixelStorei,\n  [37441]: pixelStorei,\n  [37443]: pixelStorei,\n  [3330]: pixelStorei,\n  [3332]: pixelStorei,\n  [3331]: pixelStorei,\n  [36010]: readFramebuffer,\n  [3314]: pixelStorei,\n  [32878]: pixelStorei,\n  [3316]: pixelStorei,\n  [3315]: pixelStorei,\n  [32877]: pixelStorei,\n  framebuffer: (gl, framebuffer) => {\n    const handle = framebuffer && 'handle' in framebuffer ? framebuffer.handle : framebuffer;\n    return gl.bindFramebuffer(36160, handle);\n  },\n  blend: (gl, value) => value ? gl.enable(3042) : gl.disable(3042),\n  blendColor: (gl, value) => gl.blendColor(...value),\n  blendEquation: (gl, args) => {\n    args = isArray(args) ? args : [args, args];\n    gl.blendEquationSeparate(...args);\n  },\n  blendFunc: (gl, args) => {\n    args = isArray(args) && args.length === 2 ? [...args, ...args] : args;\n    gl.blendFuncSeparate(...args);\n  },\n  clearColor: (gl, value) => gl.clearColor(...value),\n  clearDepth: (gl, value) => gl.clearDepth(value),\n  clearStencil: (gl, value) => gl.clearStencil(value),\n  colorMask: (gl, value) => gl.colorMask(...value),\n  cull: (gl, value) => value ? gl.enable(2884) : gl.disable(2884),\n  cullFace: (gl, value) => gl.cullFace(value),\n  depthTest: (gl, value) => value ? gl.enable(2929) : gl.disable(2929),\n  depthFunc: (gl, value) => gl.depthFunc(value),\n  depthMask: (gl, value) => gl.depthMask(value),\n  depthRange: (gl, value) => gl.depthRange(...value),\n  dither: (gl, value) => value ? gl.enable(3024) : gl.disable(3024),\n  derivativeHint: (gl, value) => {\n    gl.hint(35723, value);\n  },\n  frontFace: (gl, value) => gl.frontFace(value),\n  mipmapHint: (gl, value) => gl.hint(33170, value),\n  lineWidth: (gl, value) => gl.lineWidth(value),\n  polygonOffsetFill: (gl, value) => value ? gl.enable(32823) : gl.disable(32823),\n  polygonOffset: (gl, value) => gl.polygonOffset(...value),\n  sampleCoverage: (gl, value) => gl.sampleCoverage(...value),\n  scissorTest: (gl, value) => value ? gl.enable(3089) : gl.disable(3089),\n  scissor: (gl, value) => gl.scissor(...value),\n  stencilTest: (gl, value) => value ? gl.enable(2960) : gl.disable(2960),\n  stencilMask: (gl, value) => {\n    value = isArray(value) ? value : [value, value];\n    const [mask, backMask] = value;\n    gl.stencilMaskSeparate(1028, mask);\n    gl.stencilMaskSeparate(1029, backMask);\n  },\n  stencilFunc: (gl, args) => {\n    args = isArray(args) && args.length === 3 ? [...args, ...args] : args;\n    const [func, ref, mask, backFunc, backRef, backMask] = args;\n    gl.stencilFuncSeparate(1028, func, ref, mask);\n    gl.stencilFuncSeparate(1029, backFunc, backRef, backMask);\n  },\n  stencilOp: (gl, args) => {\n    args = isArray(args) && args.length === 3 ? [...args, ...args] : args;\n    const [sfail, dpfail, dppass, backSfail, backDpfail, backDppass] = args;\n    gl.stencilOpSeparate(1028, sfail, dpfail, dppass);\n    gl.stencilOpSeparate(1029, backSfail, backDpfail, backDppass);\n  },\n  viewport: (gl, value) => gl.viewport(...value)\n};\n\nfunction getValue(glEnum, values, cache) {\n  return values[glEnum] !== undefined ? values[glEnum] : cache[glEnum];\n}\n\nconst GL_COMPOSITE_PARAMETER_SETTERS = {\n  blendEquation: (gl, values, cache) => gl.blendEquationSeparate(getValue(32777, values, cache), getValue(34877, values, cache)),\n  blendFunc: (gl, values, cache) => gl.blendFuncSeparate(getValue(32969, values, cache), getValue(32968, values, cache), getValue(32971, values, cache), getValue(32970, values, cache)),\n  polygonOffset: (gl, values, cache) => gl.polygonOffset(getValue(32824, values, cache), getValue(10752, values, cache)),\n  sampleCoverage: (gl, values, cache) => gl.sampleCoverage(getValue(32938, values, cache), getValue(32939, values, cache)),\n  stencilFuncFront: (gl, values, cache) => gl.stencilFuncSeparate(1028, getValue(2962, values, cache), getValue(2967, values, cache), getValue(2963, values, cache)),\n  stencilFuncBack: (gl, values, cache) => gl.stencilFuncSeparate(1029, getValue(34816, values, cache), getValue(36003, values, cache), getValue(36004, values, cache)),\n  stencilOpFront: (gl, values, cache) => gl.stencilOpSeparate(1028, getValue(2964, values, cache), getValue(2965, values, cache), getValue(2966, values, cache)),\n  stencilOpBack: (gl, values, cache) => gl.stencilOpSeparate(1029, getValue(34817, values, cache), getValue(34818, values, cache), getValue(34819, values, cache))\n};\nconst GL_HOOKED_SETTERS = {\n  enable: (update, capability) => update({\n    [capability]: true\n  }),\n  disable: (update, capability) => update({\n    [capability]: false\n  }),\n  pixelStorei: (update, pname, value) => update({\n    [pname]: value\n  }),\n  hint: (update, pname, hint) => update({\n    [pname]: hint\n  }),\n  bindFramebuffer: (update, target, framebuffer) => {\n    switch (target) {\n      case 36160:\n        return update({\n          [36006]: framebuffer,\n          [36010]: framebuffer\n        });\n\n      case 36009:\n        return update({\n          [36006]: framebuffer\n        });\n\n      case 36008:\n        return update({\n          [36010]: framebuffer\n        });\n\n      default:\n        return null;\n    }\n  },\n  blendColor: (update, r, g, b, a) => update({\n    [32773]: new Float32Array([r, g, b, a])\n  }),\n  blendEquation: (update, mode) => update({\n    [32777]: mode,\n    [34877]: mode\n  }),\n  blendEquationSeparate: (update, modeRGB, modeAlpha) => update({\n    [32777]: modeRGB,\n    [34877]: modeAlpha\n  }),\n  blendFunc: (update, src, dst) => update({\n    [32969]: src,\n    [32968]: dst,\n    [32971]: src,\n    [32970]: dst\n  }),\n  blendFuncSeparate: (update, srcRGB, dstRGB, srcAlpha, dstAlpha) => update({\n    [32969]: srcRGB,\n    [32968]: dstRGB,\n    [32971]: srcAlpha,\n    [32970]: dstAlpha\n  }),\n  clearColor: (update, r, g, b, a) => update({\n    [3106]: new Float32Array([r, g, b, a])\n  }),\n  clearDepth: (update, depth) => update({\n    [2931]: depth\n  }),\n  clearStencil: (update, s) => update({\n    [2961]: s\n  }),\n  colorMask: (update, r, g, b, a) => update({\n    [3107]: [r, g, b, a]\n  }),\n  cullFace: (update, mode) => update({\n    [2885]: mode\n  }),\n  depthFunc: (update, func) => update({\n    [2932]: func\n  }),\n  depthRange: (update, zNear, zFar) => update({\n    [2928]: new Float32Array([zNear, zFar])\n  }),\n  depthMask: (update, mask) => update({\n    [2930]: mask\n  }),\n  frontFace: (update, face) => update({\n    [2886]: face\n  }),\n  lineWidth: (update, width) => update({\n    [2849]: width\n  }),\n  polygonOffset: (update, factor, units) => update({\n    [32824]: factor,\n    [10752]: units\n  }),\n  sampleCoverage: (update, value, invert) => update({\n    [32938]: value,\n    [32939]: invert\n  }),\n  scissor: (update, x, y, width, height) => update({\n    [3088]: new Int32Array([x, y, width, height])\n  }),\n  stencilMask: (update, mask) => update({\n    [2968]: mask,\n    [36005]: mask\n  }),\n  stencilMaskSeparate: (update, face, mask) => update({\n    [face === 1028 ? 2968 : 36005]: mask\n  }),\n  stencilFunc: (update, func, ref, mask) => update({\n    [2962]: func,\n    [2967]: ref,\n    [2963]: mask,\n    [34816]: func,\n    [36003]: ref,\n    [36004]: mask\n  }),\n  stencilFuncSeparate: (update, face, func, ref, mask) => update({\n    [face === 1028 ? 2962 : 34816]: func,\n    [face === 1028 ? 2967 : 36003]: ref,\n    [face === 1028 ? 2963 : 36004]: mask\n  }),\n  stencilOp: (update, fail, zfail, zpass) => update({\n    [2964]: fail,\n    [2965]: zfail,\n    [2966]: zpass,\n    [34817]: fail,\n    [34818]: zfail,\n    [34819]: zpass\n  }),\n  stencilOpSeparate: (update, face, fail, zfail, zpass) => update({\n    [face === 1028 ? 2964 : 34817]: fail,\n    [face === 1028 ? 2965 : 34818]: zfail,\n    [face === 1028 ? 2966 : 34819]: zpass\n  }),\n  viewport: (update, x, y, width, height) => update({\n    [2978]: [x, y, width, height]\n  })\n};\n\nconst isEnabled = (gl, key) => gl.isEnabled(key);\n\nconst GL_PARAMETER_GETTERS = {\n  [3042]: isEnabled,\n  [2884]: isEnabled,\n  [2929]: isEnabled,\n  [3024]: isEnabled,\n  [32823]: isEnabled,\n  [32926]: isEnabled,\n  [32928]: isEnabled,\n  [3089]: isEnabled,\n  [2960]: isEnabled,\n  [35977]: isEnabled\n};\n//# sourceMappingURL=webgl-parameter-tables.js.map\n;// CONCATENATED MODULE: ./node_modules/@luma.gl/gltools/dist/esm/utils/utils.js\nfunction isObjectEmpty(object) {\n  for (const key in object) {\n    return false;\n  }\n\n  return true;\n}\nfunction deepArrayEqual(x, y) {\n  if (x === y) {\n    return true;\n  }\n\n  const isArrayX = Array.isArray(x) || ArrayBuffer.isView(x);\n  const isArrayY = Array.isArray(y) || ArrayBuffer.isView(y);\n\n  if (isArrayX && isArrayY && x.length === y.length) {\n    for (let i = 0; i < x.length; ++i) {\n      if (x[i] !== y[i]) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  return false;\n}\n//# sourceMappingURL=utils.js.map\n;// CONCATENATED MODULE: ./node_modules/@luma.gl/gltools/dist/esm/state-tracker/track-context-state.js\n\n\n\n\n\nfunction installGetterOverride(gl, functionName) {\n  const originalGetterFunc = gl[functionName].bind(gl);\n\n  gl[functionName] = function get() {\n    const pname = arguments.length <= 0 ? undefined : arguments[0];\n\n    if (!(pname in gl.state.cache)) {\n      return originalGetterFunc(...arguments);\n    }\n\n    return gl.state.enable ? gl.state.cache[pname] : originalGetterFunc(...arguments);\n  };\n\n  Object.defineProperty(gl[functionName], 'name', {\n    value: \"\".concat(functionName, \"-from-cache\"),\n    configurable: false\n  });\n}\n\nfunction installSetterSpy(gl, functionName, setter) {\n  const originalSetterFunc = gl[functionName].bind(gl);\n\n  gl[functionName] = function set() {\n    for (var _len = arguments.length, params = new Array(_len), _key = 0; _key < _len; _key++) {\n      params[_key] = arguments[_key];\n    }\n\n    const {\n      valueChanged,\n      oldValue\n    } = setter(gl.state._updateCache, ...params);\n\n    if (valueChanged) {\n      originalSetterFunc(...params);\n    }\n\n    return oldValue;\n  };\n\n  Object.defineProperty(gl[functionName], 'name', {\n    value: \"\".concat(functionName, \"-to-cache\"),\n    configurable: false\n  });\n}\n\nfunction installProgramSpy(gl) {\n  const originalUseProgram = gl.useProgram.bind(gl);\n\n  gl.useProgram = function useProgramLuma(handle) {\n    if (gl.state.program !== handle) {\n      originalUseProgram(handle);\n      gl.state.program = handle;\n    }\n  };\n}\n\nclass GLState {\n  constructor(gl) {\n    let {\n      copyState = false,\n      log = () => {}\n    } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    this.gl = gl;\n    this.program = null;\n    this.stateStack = [];\n    this.enable = true;\n    this.cache = copyState ? getParameters(gl) : Object.assign({}, GL_PARAMETER_DEFAULTS);\n    this.log = log;\n    this._updateCache = this._updateCache.bind(this);\n    Object.seal(this);\n  }\n\n  push() {\n    let values = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    this.stateStack.push({});\n  }\n\n  pop() {\n    assert(this.stateStack.length > 0);\n    const oldValues = this.stateStack[this.stateStack.length - 1];\n    setParameters(this.gl, oldValues);\n    this.stateStack.pop();\n  }\n\n  _updateCache(values) {\n    let valueChanged = false;\n    let oldValue;\n    const oldValues = this.stateStack.length > 0 && this.stateStack[this.stateStack.length - 1];\n\n    for (const key in values) {\n      assert(key !== undefined);\n      const value = values[key];\n      const cached = this.cache[key];\n\n      if (!deepArrayEqual(value, cached)) {\n        valueChanged = true;\n        oldValue = cached;\n\n        if (oldValues && !(key in oldValues)) {\n          oldValues[key] = cached;\n        }\n\n        this.cache[key] = value;\n      }\n    }\n\n    return {\n      valueChanged,\n      oldValue\n    };\n  }\n\n}\n\nfunction trackContextState(gl) {\n  let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  const {\n    enable = true,\n    copyState\n  } = options;\n  assert(copyState !== undefined);\n\n  if (!gl.state) {\n    const {\n      polyfillContext\n    } = globalThis;\n\n    if (polyfillContext) {\n      polyfillContext(gl);\n    }\n\n    gl.state = new GLState(gl, {\n      copyState\n    });\n    installProgramSpy(gl);\n\n    for (const key in GL_HOOKED_SETTERS) {\n      const setter = GL_HOOKED_SETTERS[key];\n      installSetterSpy(gl, key, setter);\n    }\n\n    installGetterOverride(gl, 'getParameter');\n    installGetterOverride(gl, 'isEnabled');\n  }\n\n  gl.state.enable = enable;\n  return gl;\n}\nfunction pushContextState(gl) {\n  if (!gl.state) {\n    trackContextState(gl, {\n      copyState: false\n    });\n  }\n\n  gl.state.push();\n}\nfunction popContextState(gl) {\n  assert(gl.state);\n  gl.state.pop();\n}\n//# sourceMappingURL=track-context-state.js.map\n;// CONCATENATED MODULE: ./node_modules/@luma.gl/gltools/dist/esm/state-tracker/unified-parameter-api.js\n\n\n\n\n\nfunction setParameters(gl, values) {\n  assert(isWebGL(gl), 'setParameters requires a WebGL context');\n\n  if (isObjectEmpty(values)) {\n    return;\n  }\n\n  const compositeSetters = {};\n\n  for (const key in values) {\n    const glConstant = Number(key);\n    const setter = GL_PARAMETER_SETTERS[key];\n\n    if (setter) {\n      if (typeof setter === 'string') {\n        compositeSetters[setter] = true;\n      } else {\n        setter(gl, values[key], glConstant);\n      }\n    }\n  }\n\n  const cache = gl.state && gl.state.cache;\n\n  if (cache) {\n    for (const key in compositeSetters) {\n      const compositeSetter = GL_COMPOSITE_PARAMETER_SETTERS[key];\n      compositeSetter(gl, values, cache);\n    }\n  }\n}\nfunction getParameters(gl, parameters) {\n  parameters = parameters || GL_PARAMETER_DEFAULTS;\n\n  if (typeof parameters === 'number') {\n    const key = parameters;\n    const getter = GL_PARAMETER_GETTERS[key];\n    return getter ? getter(gl, key) : gl.getParameter(key);\n  }\n\n  const parameterKeys = Array.isArray(parameters) ? parameters : Object.keys(parameters);\n  const state = {};\n\n  for (const key of parameterKeys) {\n    const getter = GL_PARAMETER_GETTERS[key];\n    state[key] = getter ? getter(gl, Number(key)) : gl.getParameter(Number(key));\n  }\n\n  return state;\n}\nfunction resetParameters(gl) {\n  setParameters(gl, GL_PARAMETER_DEFAULTS);\n}\nfunction withParameters(gl, parameters, func) {\n  if (isObjectEmpty(parameters)) {\n    return func(gl);\n  }\n\n  const {\n    nocatch = true\n  } = parameters;\n  pushContextState(gl);\n  setParameters(gl, parameters);\n  let value;\n\n  if (nocatch) {\n    value = func(gl);\n    popContextState(gl);\n  } else {\n    try {\n      value = func(gl);\n    } finally {\n      popContextState(gl);\n    }\n  }\n\n  return value;\n}\n//# sourceMappingURL=unified-parameter-api.js.map\n// EXTERNAL MODULE: ./node_modules/@probe.gl/env/dist/esm/lib/is-browser.js\nvar is_browser = __webpack_require__(93370);\n;// CONCATENATED MODULE: ./node_modules/@luma.gl/gltools/dist/esm/utils/device-pixels.js\nfunction cssToDeviceRatio(gl) {\n  const {\n    luma\n  } = gl;\n\n  if (gl.canvas && luma) {\n    const {\n      clientWidth\n    } = luma.canvasSizeInfo;\n    return clientWidth ? gl.drawingBufferWidth / clientWidth : 1;\n  }\n\n  return 1;\n}\nfunction cssToDevicePixels(gl, cssPixel) {\n  let yInvert = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n  const ratio = cssToDeviceRatio(gl);\n  const width = gl.drawingBufferWidth;\n  const height = gl.drawingBufferHeight;\n  return scalePixels(cssPixel, ratio, width, height, yInvert);\n}\nfunction getDevicePixelRatio(useDevicePixels) {\n  const windowRatio = typeof window === 'undefined' ? 1 : window.devicePixelRatio || 1;\n\n  if (Number.isFinite(useDevicePixels)) {\n    return useDevicePixels <= 0 ? 1 : useDevicePixels;\n  }\n\n  return useDevicePixels ? windowRatio : 1;\n}\n\nfunction scalePixels(pixel, ratio, width, height, yInvert) {\n  const x = scaleX(pixel[0], ratio, width);\n  let y = scaleY(pixel[1], ratio, height, yInvert);\n  let t = scaleX(pixel[0] + 1, ratio, width);\n  const xHigh = t === width - 1 ? t : t - 1;\n  t = scaleY(pixel[1] + 1, ratio, height, yInvert);\n  let yHigh;\n\n  if (yInvert) {\n    t = t === 0 ? t : t + 1;\n    yHigh = y;\n    y = t;\n  } else {\n    yHigh = t === height - 1 ? t : t - 1;\n  }\n\n  return {\n    x,\n    y,\n    width: Math.max(xHigh - x + 1, 1),\n    height: Math.max(yHigh - y + 1, 1)\n  };\n}\n\nfunction scaleX(x, ratio, width) {\n  const r = Math.min(Math.round(x * ratio), width - 1);\n  return r;\n}\n\nfunction scaleY(y, ratio, height, yInvert) {\n  return yInvert ? Math.max(0, height - 1 - Math.round(y * ratio)) : Math.min(Math.round(y * ratio), height - 1);\n}\n//# sourceMappingURL=device-pixels.js.map\n;// CONCATENATED MODULE: ./node_modules/@luma.gl/gltools/dist/esm/context/context.js\n\n\n\n\n\n\nconst isBrowser = (0,is_browser/* default */.Z)();\nconst isPage = isBrowser && typeof document !== 'undefined';\nconst CONTEXT_DEFAULTS = {\n  webgl2: true,\n  webgl1: true,\n  throwOnError: true,\n  manageState: true,\n  canvas: null,\n  debug: false,\n  width: 800,\n  height: 600\n};\nfunction createGLContext() {\n  let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  assert(isBrowser, \"createGLContext only available in the browser.\\nCreate your own headless context or use 'createHeadlessContext' from @luma.gl/test-utils\");\n  options = Object.assign({}, CONTEXT_DEFAULTS, options);\n  const {\n    width,\n    height\n  } = options;\n\n  function onError(message) {\n    if (options.throwOnError) {\n      throw new Error(message);\n    }\n\n    console.error(message);\n    return null;\n  }\n\n  options.onError = onError;\n  let gl;\n  const {\n    canvas\n  } = options;\n  const targetCanvas = getCanvas({\n    canvas,\n    width,\n    height,\n    onError\n  });\n  gl = createBrowserContext(targetCanvas, options);\n\n  if (!gl) {\n    return null;\n  }\n\n  gl = instrumentGLContext(gl, options);\n  logInfo(gl);\n  return gl;\n}\nfunction instrumentGLContext(gl) {\n  let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n  if (!gl || gl._instrumented) {\n    return gl;\n  }\n\n  gl._version = gl._version || getVersion(gl);\n  gl.luma = gl.luma || {};\n  gl.luma.canvasSizeInfo = gl.luma.canvasSizeInfo || {};\n  options = Object.assign({}, CONTEXT_DEFAULTS, options);\n  const {\n    manageState,\n    debug\n  } = options;\n\n  if (manageState) {\n    trackContextState(gl, {\n      copyState: false,\n      log: function () {\n        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n          args[_key] = arguments[_key];\n        }\n\n        return log_log.log(1, ...args)();\n      }\n    });\n  }\n\n  if (isBrowser && debug) {\n    if (!globalThis.makeDebugContext) {\n      log_log.warn('WebGL debug mode not activated. import \"@luma.gl/debug\" to enable.')();\n    } else {\n      gl = globalThis.makeDebugContext(gl, options);\n      log_log.level = Math.max(log_log.level, 1);\n    }\n  }\n\n  gl._instrumented = true;\n  return gl;\n}\nfunction getContextDebugInfo(gl) {\n  const vendorMasked = gl.getParameter(7936);\n  const rendererMasked = gl.getParameter(7937);\n  const ext = gl.getExtension('WEBGL_debug_renderer_info');\n  const vendorUnmasked = ext && gl.getParameter(ext.UNMASKED_VENDOR_WEBGL || 7936);\n  const rendererUnmasked = ext && gl.getParameter(ext.UNMASKED_RENDERER_WEBGL || 7937);\n  return {\n    vendor: vendorUnmasked || vendorMasked,\n    renderer: rendererUnmasked || rendererMasked,\n    vendorMasked,\n    rendererMasked,\n    version: gl.getParameter(7938),\n    shadingLanguageVersion: gl.getParameter(35724)\n  };\n}\nfunction resizeGLContext(gl) {\n  let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n  if (gl.canvas) {\n    const devicePixelRatio = getDevicePixelRatio(options.useDevicePixels);\n    setDevicePixelRatio(gl, devicePixelRatio, options);\n    return;\n  }\n\n  const ext = gl.getExtension('STACKGL_resize_drawingbuffer');\n\n  if (ext && \"width\" in options && \"height\" in options) {\n    ext.resize(options.width, options.height);\n  }\n}\n\nfunction createBrowserContext(canvas, options) {\n  const {\n    onError\n  } = options;\n  let errorMessage = null;\n\n  const onCreateError = error => errorMessage = error.statusMessage || errorMessage;\n\n  canvas.addEventListener('webglcontextcreationerror', onCreateError, false);\n  const {\n    webgl1 = true,\n    webgl2 = true\n  } = options;\n  let gl = null;\n\n  if (webgl2) {\n    gl = gl || canvas.getContext('webgl2', options);\n    gl = gl || canvas.getContext('experimental-webgl2', options);\n  }\n\n  if (webgl1) {\n    gl = gl || canvas.getContext('webgl', options);\n    gl = gl || canvas.getContext('experimental-webgl', options);\n  }\n\n  canvas.removeEventListener('webglcontextcreationerror', onCreateError, false);\n\n  if (!gl) {\n    return onError(\"Failed to create \".concat(webgl2 && !webgl1 ? 'WebGL2' : 'WebGL', \" context: \").concat(errorMessage || 'Unknown error'));\n  }\n\n  if (options.onContextLost) {\n    canvas.addEventListener('webglcontextlost', options.onContextLost, false);\n  }\n\n  if (options.onContextRestored) {\n    canvas.addEventListener('webglcontextrestored', options.onContextRestored, false);\n  }\n\n  return gl;\n}\n\nfunction getCanvas(_ref) {\n  let {\n    canvas,\n    width = 800,\n    height = 600,\n    onError\n  } = _ref;\n  let targetCanvas;\n\n  if (typeof canvas === 'string') {\n    const isPageLoaded = isPage && document.readyState === 'complete';\n\n    if (!isPageLoaded) {\n      onError(\"createGLContext called on canvas '\".concat(canvas, \"' before page was loaded\"));\n    }\n\n    targetCanvas = document.getElementById(canvas);\n  } else if (canvas) {\n    targetCanvas = canvas;\n  } else {\n    targetCanvas = document.createElement('canvas');\n    targetCanvas.id = 'lumagl-canvas';\n    targetCanvas.style.width = Number.isFinite(width) ? \"\".concat(width, \"px\") : '100%';\n    targetCanvas.style.height = Number.isFinite(height) ? \"\".concat(height, \"px\") : '100%';\n    document.body.insertBefore(targetCanvas, document.body.firstChild);\n  }\n\n  return targetCanvas;\n}\n\nfunction logInfo(gl) {\n  const webGL = isWebGL2(gl) ? 'WebGL2' : 'WebGL1';\n  const info = getContextDebugInfo(gl);\n  const driver = info ? \"(\".concat(info.vendor, \",\").concat(info.renderer, \")\") : '';\n  const debug = gl.debug ? ' debug' : '';\n  log_log.info(1, \"\".concat(webGL).concat(debug, \" context \").concat(driver))();\n}\n\nfunction getVersion(gl) {\n  if (typeof WebGL2RenderingContext !== 'undefined' && gl instanceof WebGL2RenderingContext) {\n    return 2;\n  }\n\n  return 1;\n}\n\nfunction setDevicePixelRatio(gl, devicePixelRatio, options) {\n  let clientWidth = 'width' in options ? options.width : gl.canvas.clientWidth;\n  let clientHeight = 'height' in options ? options.height : gl.canvas.clientHeight;\n\n  if (!clientWidth || !clientHeight) {\n    log_log.log(1, 'Canvas clientWidth/clientHeight is 0')();\n    devicePixelRatio = 1;\n    clientWidth = gl.canvas.width || 1;\n    clientHeight = gl.canvas.height || 1;\n  }\n\n  gl.luma = gl.luma || {};\n  gl.luma.canvasSizeInfo = gl.luma.canvasSizeInfo || {};\n  const cachedSize = gl.luma.canvasSizeInfo;\n\n  if (cachedSize.clientWidth !== clientWidth || cachedSize.clientHeight !== clientHeight || cachedSize.devicePixelRatio !== devicePixelRatio) {\n    let clampedPixelRatio = devicePixelRatio;\n    const canvasWidth = Math.floor(clientWidth * clampedPixelRatio);\n    const canvasHeight = Math.floor(clientHeight * clampedPixelRatio);\n    gl.canvas.width = canvasWidth;\n    gl.canvas.height = canvasHeight;\n\n    if (gl.drawingBufferWidth !== canvasWidth || gl.drawingBufferHeight !== canvasHeight) {\n      log_log.warn(\"Device pixel ratio clamped\")();\n      clampedPixelRatio = Math.min(gl.drawingBufferWidth / clientWidth, gl.drawingBufferHeight / clientHeight);\n      gl.canvas.width = Math.floor(clientWidth * clampedPixelRatio);\n      gl.canvas.height = Math.floor(clientHeight * clampedPixelRatio);\n    }\n\n    Object.assign(gl.luma.canvasSizeInfo, {\n      clientWidth,\n      clientHeight,\n      devicePixelRatio\n    });\n  }\n}\n//# sourceMappingURL=context.js.map\n;// CONCATENATED MODULE: ./node_modules/@luma.gl/gltools/dist/esm/index.js\n\n\n\n\n\n\n\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTQxOC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBb0M7QUFDN0IsTUFBTSxPQUFHLE9BQU8sY0FBRztBQUMxQjtBQUNBLENBQUM7QUFDRCwrQjs7QUNKTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0M7O0FDTGtDO0FBQ2xDO0FBQ08sa0JBQWtCLDJEQUFXO0FBQzdCO0FBQ0E7QUFDUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ087QUFDUCxFQUFFLE1BQU07QUFDUjtBQUNBO0FBQ087QUFDUCxFQUFFLE1BQU07QUFDUjtBQUNBO0FBQ0Esd0M7O0FDakNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsU0FBUyxnQ0FBRztBQUNaO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTs7QUFFTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGtCQUFrQix5QkFBeUI7QUFDM0M7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU0sZ0NBQUc7QUFDVDtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxxQkFBcUIscUNBQXFDO0FBQzFEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsa0JBQWtCLGdCQUFnQjtBQUNsQztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFF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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztB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QUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxnQkFBZ0IsUUFBUTtBQUN4QjtBQUNBO0FBQ0E7QUFDQSxFQUFFLFlBQVE7QUFDVjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLElBQUksV0FBTztBQUNYO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxNQUFNLFlBQVE7QUFDZDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsbUM7O0FDN1BrQztBQUNrRjtBQUN0RDtBQUN3RDtBQUNYO0FBQ0k7QUFDbkM7QUFDNUUiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly92dWUzLXdlYnBhY2s1Ly4vbm9kZV9tb2R1bGVzL0BsdW1hLmdsL2dsdG9vbHMvZGlzdC9lc20vdXRpbHMvbG9nLmpzPzk3MDciLCJ3ZWJwYWNrOi8vdnVlMy13ZWJwYWNrNS8uL25vZGVfbW9kdWxlcy9AbHVtYS5nbC9nbHRvb2xzL2Rpc3QvZXNtL3V0aWxzL2Fzc2VydC5qcz82NWM3Iiwid2VicGFjazovL3Z1ZTMtd2VicGFjazUvLi9ub2RlX21vZHVsZXMvQGx1bWEuZ2wvZ2x0b29scy9kaXN0L2VzbS91dGlscy93ZWJnbC1jaGVja3MuanM/MjFkZSIsIndlYnBhY2s6Ly92dWUzLXdlYnBhY2s1Ly4vbm9kZV9tb2R1bGVzL0BsdW1hLmdsL2dsdG9vbHMvZGlzdC9lc20vcG9seWZpbGwvcG9seWZpbGwtdmVydGV4LWFycmF5LW9iamVjdC5qcz9kNDdhIiwid2VicGFjazovL3Z1ZTMtd2VicGFjazUvLi9ub2RlX21vZHVsZXMvQGx1bWEuZ2wvZ2x0b29scy9kaXN0L2VzbS9wb2x5ZmlsbC9nZXQtcGFyYW1ldGVyLXBvbHlmaWxsLmpzPzM0NzQiLCJ3ZWJwYWNrOi8vdnVlMy13ZWJwYWNrNS8uL25vZGVfbW9kdWxlcy9AbHVtYS5nbC9nbHRvb2xzL2Rpc3QvZXNtL3BvbHlmaWxsL3BvbHlmaWxsLXRhYmxlLmpzPzc4NjUiLCJ3ZWJwYWNrOi8vdnVlMy13ZWJwYWNrNS8uL25vZGVfbW9kdWxlcy9AbHVtYS5nbC9nbHRvb2xzL2Rpc3QvZXNtL3BvbHlmaWxsL3BvbHlmaWxsLWNvbnRleHQuanM/OTE1YSIsIndlYnBhY2s6Ly92dWUzLXdlYnBhY2s1Ly4vbm9kZV9tb2R1bGVzL0BsdW1hLmdsL2dsdG9vbHMvZGlzdC9lc20vc3RhdGUtdHJhY2tlci93ZWJnbC1wYXJhbWV0ZXItdGFibGVzLmpzP2ZhZjYiLCJ3ZWJwYWNrOi8vdnVlMy13ZWJwYWNrNS8uL25vZGVfbW9kdWxlcy9AbHVtYS5nbC9nbHRvb2xzL2Rpc3QvZXNtL3V0aWxzL3V0aWxzLmpzPzg5YWMiLCJ3ZWJwYWNrOi8vdnVlMy13ZWJwYWNrNS8uL25vZGVfbW9kdWxlcy9AbHVtYS5nbC9nbHRvb2xzL2Rpc3QvZXNtL3N0YXRlLXRyYWNrZXIvdHJhY2stY29udGV4dC1zdGF0ZS5qcz8wZDBkIiwid2VicGFjazovL3Z1ZTMtd2VicGFjazUvLi9ub2RlX21vZHVsZXMvQGx1bWEuZ2wvZ2x0b29scy9kaXN0L2VzbS9zdGF0ZS10cmFja2VyL3VuaWZpZWQtcGFyYW1ldGVyLWFwaS5qcz9jZDRjIiwid2VicGFjazovL3Z1ZTMtd2VicGFjazUvLi9ub2RlX21vZHVsZXMvQGx1bWEuZ2wvZ2x0b29scy9kaXN0L2VzbS91dGlscy9kZXZpY2UtcGl4ZWxzLmpzPzg4ZWEiLCJ3ZWJwYWNrOi8vdnVlMy13ZWJwYWNrNS8uL25vZGVfbW9kdWxlcy9AbHVtYS5nbC9nbHRvb2xzL2Rpc3QvZXNtL2NvbnRleHQvY29udGV4dC5qcz9kOTg3Iiwid2VicGFjazovL3Z1ZTMtd2VicGFjazUvLi9ub2RlX21vZHVsZXMvQGx1bWEuZ2wvZ2x0b29scy9kaXN0L2VzbS9pbmRleC5qcz9jZDdmIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IExvZyB9IGZyb20gJ0Bwcm9iZS5nbC9sb2cnO1xuZXhwb3J0IGNvbnN0IGxvZyA9IG5ldyBMb2coe1xuICBpZDogJ2x1bWEuZ2wnXG59KTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWxvZy5qcy5tYXAiLCJleHBvcnQgZnVuY3Rpb24gYXNzZXJ0KGNvbmRpdGlvbiwgbWVzc2FnZSkge1xuICBpZiAoIWNvbmRpdGlvbikge1xuICAgIHRocm93IG5ldyBFcnJvcihtZXNzYWdlIHx8ICdsdW1hLmdsOiBhc3NlcnRpb24gZmFpbGVkLicpO1xuICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1hc3NlcnQuanMubWFwIiwiaW1wb3J0IHsgYXNzZXJ0IH0gZnJvbSAnLi9hc3NlcnQnO1xuY29uc3QgRVJSX0NPTlRFWFQgPSAnSW52YWxpZCBXZWJHTFJlbmRlcmluZ0NvbnRleHQnO1xuZXhwb3J0IGNvbnN0IEVSUl9XRUJHTCA9IEVSUl9DT05URVhUO1xuZXhwb3J0IGNvbnN0IEVSUl9XRUJHTDIgPSAnUmVxdWlyZXMgV2ViR0wyJztcbmV4cG9ydCBmdW5jdGlvbiBpc1dlYkdMKGdsKSB7XG4gIGlmICh0eXBlb2YgV2ViR0xSZW5kZXJpbmdDb250ZXh0ICE9PSAndW5kZWZpbmVkJyAmJiBnbCBpbnN0YW5jZW9mIFdlYkdMUmVuZGVyaW5nQ29udGV4dCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgaWYgKHR5cGVvZiBXZWJHTDJSZW5kZXJpbmdDb250ZXh0ICE9PSAndW5kZWZpbmVkJyAmJiBnbCBpbnN0YW5jZW9mIFdlYkdMMlJlbmRlcmluZ0NvbnRleHQpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIHJldHVybiBCb29sZWFuKGdsICYmIE51bWJlci5pc0Zpbml0ZShnbC5fdmVyc2lvbikpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGlzV2ViR0wyKGdsKSB7XG4gIGlmICh0eXBlb2YgV2ViR0wyUmVuZGVyaW5nQ29udGV4dCAhPT0gJ3VuZGVmaW5lZCcgJiYgZ2wgaW5zdGFuY2VvZiBXZWJHTDJSZW5kZXJpbmdDb250ZXh0KSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICByZXR1cm4gQm9vbGVhbihnbCAmJiBnbC5fdmVyc2lvbiA9PT0gMik7XG59XG5leHBvcnQgZnVuY3Rpb24gZ2V0V2ViR0wyQ29udGV4dChnbCkge1xuICByZXR1cm4gaXNXZWJHTDIoZ2wpID8gZ2wgOiBudWxsO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGFzc2VydFdlYkdMQ29udGV4dChnbCkge1xuICBhc3NlcnQoaXNXZWJHTChnbCksIEVSUl9DT05URVhUKTtcbiAgcmV0dXJuIGdsO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGFzc2VydFdlYkdMMkNvbnRleHQoZ2wpIHtcbiAgYXNzZXJ0KGlzV2ViR0wyKGdsKSwgRVJSX1dFQkdMMik7XG4gIHJldHVybiBnbDtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXdlYmdsLWNoZWNrcy5qcy5tYXAiLCJjb25zdCBnbEVycm9yU2hhZG93ID0ge307XG5cbmZ1bmN0aW9uIGVycm9yKG1zZykge1xuICBpZiAoZ2xvYmFsVGhpcy5jb25zb2xlICYmIGdsb2JhbFRoaXMuY29uc29sZS5lcnJvcikge1xuICAgIGdsb2JhbFRoaXMuY29uc29sZS5lcnJvcihtc2cpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGxvZyhtc2cpIHtcbiAgaWYgKGdsb2JhbFRoaXMuY29uc29sZSAmJiBnbG9iYWxUaGlzLmNvbnNvbGUubG9nKSB7XG4gICAgZ2xvYmFsVGhpcy5jb25zb2xlLmxvZyhtc2cpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHN5bnRoZXNpemVHTEVycm9yKGVyciwgb3B0X21zZykge1xuICBnbEVycm9yU2hhZG93W2Vycl0gPSB0cnVlO1xuXG4gIGlmIChvcHRfbXNnICE9PSB1bmRlZmluZWQpIHtcbiAgICBlcnJvcihvcHRfbXNnKTtcbiAgfVxufVxuXG5mdW5jdGlvbiB3cmFwR0xFcnJvcihnbCkge1xuICBjb25zdCBmID0gZ2wuZ2V0RXJyb3I7XG5cbiAgZ2wuZ2V0RXJyb3IgPSBmdW5jdGlvbiBnZXRFcnJvcigpIHtcbiAgICBsZXQgZXJyO1xuXG4gICAgZG8ge1xuICAgICAgZXJyID0gZi5hcHBseShnbCk7XG5cbiAgICAgIGlmIChlcnIgIT09IDApIHtcbiAgICAgICAgZ2xFcnJvclNoYWRvd1tlcnJdID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9IHdoaWxlIChlcnIgIT09IDApO1xuXG4gICAgZm9yIChlcnIgaW4gZ2xFcnJvclNoYWRvdykge1xuICAgICAgaWYgKGdsRXJyb3JTaGFkb3dbZXJyXSkge1xuICAgICAgICBkZWxldGUgZ2xFcnJvclNoYWRvd1tlcnJdO1xuICAgICAgICByZXR1cm4gcGFyc2VJbnQoZXJyLCAxMCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIDA7XG4gIH07XG59XG5cbmNvbnN0IFdlYkdMVmVydGV4QXJyYXlPYmplY3RPRVMgPSBmdW5jdGlvbiBXZWJHTFZlcnRleEFycmF5T2JqZWN0T0VTKGV4dCkge1xuICBjb25zdCBnbCA9IGV4dC5nbDtcbiAgdGhpcy5leHQgPSBleHQ7XG4gIHRoaXMuaXNBbGl2ZSA9IHRydWU7XG4gIHRoaXMuaGFzQmVlbkJvdW5kID0gZmFsc2U7XG4gIHRoaXMuZWxlbWVudEFycmF5QnVmZmVyID0gbnVsbDtcbiAgdGhpcy5hdHRyaWJzID0gbmV3IEFycmF5KGV4dC5tYXhWZXJ0ZXhBdHRyaWJzKTtcblxuICBmb3IgKGxldCBuID0gMDsgbiA8IHRoaXMuYXR0cmlicy5sZW5ndGg7IG4rKykge1xuICAgIGNvbnN0IGF0dHJpYiA9IG5ldyBXZWJHTFZlcnRleEFycmF5T2JqZWN0T0VTLlZlcnRleEF0dHJpYihnbCk7XG4gICAgdGhpcy5hdHRyaWJzW25dID0gYXR0cmliO1xuICB9XG5cbiAgdGhpcy5tYXhBdHRyaWIgPSAwO1xufTtcblxuV2ViR0xWZXJ0ZXhBcnJheU9iamVjdE9FUy5WZXJ0ZXhBdHRyaWIgPSBmdW5jdGlvbiBWZXJ0ZXhBdHRyaWIoZ2wpIHtcbiAgdGhpcy5lbmFibGVkID0gZmFsc2U7XG4gIHRoaXMuYnVmZmVyID0gbnVsbDtcbiAgdGhpcy5zaXplID0gNDtcbiAgdGhpcy50eXBlID0gNTEyNjtcbiAgdGhpcy5ub3JtYWxpemVkID0gZmFsc2U7XG4gIHRoaXMuc3RyaWRlID0gMTY7XG4gIHRoaXMub2Zmc2V0ID0gMDtcbiAgdGhpcy5jYWNoZWQgPSAnJztcbiAgdGhpcy5yZWNhY2hlKCk7XG59O1xuXG5XZWJHTFZlcnRleEFycmF5T2JqZWN0T0VTLlZlcnRleEF0dHJpYi5wcm90b3R5cGUucmVjYWNoZSA9IGZ1bmN0aW9uIHJlY2FjaGUoKSB7XG4gIHRoaXMuY2FjaGVkID0gW3RoaXMuc2l6ZSwgdGhpcy50eXBlLCB0aGlzLm5vcm1hbGl6ZWQsIHRoaXMuc3RyaWRlLCB0aGlzLm9mZnNldF0uam9pbignOicpO1xufTtcblxuY29uc3QgT0VTVmVydGV4QXJyYXlPYmplY3QgPSBmdW5jdGlvbiBPRVNWZXJ0ZXhBcnJheU9iamVjdChnbCkge1xuICBjb25zdCBzZWxmID0gdGhpcztcbiAgdGhpcy5nbCA9IGdsO1xuICB3cmFwR0xFcnJvcihnbCk7XG4gIGNvbnN0IG9yaWdpbmFsID0gdGhpcy5vcmlnaW5hbCA9IHtcbiAgICBnZXRQYXJhbWV0ZXI6IGdsLmdldFBhcmFtZXRlcixcbiAgICBlbmFibGVWZXJ0ZXhBdHRyaWJBcnJheTogZ2wuZW5hYmxlVmVydGV4QXR0cmliQXJyYXksXG4gICAgZGlzYWJsZVZlcnRleEF0dHJpYkFycmF5OiBnbC5kaXNhYmxlVmVydGV4QXR0cmliQXJyYXksXG4gICAgYmluZEJ1ZmZlcjogZ2wuYmluZEJ1ZmZlcixcbiAgICBnZXRWZXJ0ZXhBdHRyaWI6IGdsLmdldFZlcnRleEF0dHJpYixcbiAgICB2ZXJ0ZXhBdHRyaWJQb2ludGVyOiBnbC52ZXJ0ZXhBdHRyaWJQb2ludGVyXG4gIH07XG5cbiAgZ2wuZ2V0UGFyYW1ldGVyID0gZnVuY3Rpb24gZ2V0UGFyYW1ldGVyKHBuYW1lKSB7XG4gICAgaWYgKHBuYW1lID09PSBzZWxmLlZFUlRFWF9BUlJBWV9CSU5ESU5HX09FUykge1xuICAgICAgaWYgKHNlbGYuY3VycmVudFZlcnRleEFycmF5T2JqZWN0ID09PSBzZWxmLmRlZmF1bHRWZXJ0ZXhBcnJheU9iamVjdCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHNlbGYuY3VycmVudFZlcnRleEFycmF5T2JqZWN0O1xuICAgIH1cblxuICAgIHJldHVybiBvcmlnaW5hbC5nZXRQYXJhbWV0ZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgfTtcblxuICBnbC5lbmFibGVWZXJ0ZXhBdHRyaWJBcnJheSA9IGZ1bmN0aW9uIGVuYWJsZVZlcnRleEF0dHJpYkFycmF5KGluZGV4KSB7XG4gICAgY29uc3QgdmFvID0gc2VsZi5jdXJyZW50VmVydGV4QXJyYXlPYmplY3Q7XG4gICAgdmFvLm1heEF0dHJpYiA9IE1hdGgubWF4KHZhby5tYXhBdHRyaWIsIGluZGV4KTtcbiAgICBjb25zdCBhdHRyaWIgPSB2YW8uYXR0cmlic1tpbmRleF07XG4gICAgYXR0cmliLmVuYWJsZWQgPSB0cnVlO1xuICAgIHJldHVybiBvcmlnaW5hbC5lbmFibGVWZXJ0ZXhBdHRyaWJBcnJheS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICB9O1xuXG4gIGdsLmRpc2FibGVWZXJ0ZXhBdHRyaWJBcnJheSA9IGZ1bmN0aW9uIGRpc2FibGVWZXJ0ZXhBdHRyaWJBcnJheShpbmRleCkge1xuICAgIGNvbnN0IHZhbyA9IHNlbGYuY3VycmVudFZlcnRleEFycmF5T2JqZWN0O1xuICAgIHZhby5tYXhBdHRyaWIgPSBNYXRoLm1heCh2YW8ubWF4QXR0cmliLCBpbmRleCk7XG4gICAgY29uc3QgYXR0cmliID0gdmFvLmF0dHJpYnNbaW5kZXhdO1xuICAgIGF0dHJpYi5lbmFibGVkID0gZmFsc2U7XG4gICAgcmV0dXJuIG9yaWdpbmFsLmRpc2FibGVWZXJ0ZXhBdHRyaWJBcnJheS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICB9O1xuXG4gIGdsLmJpbmRCdWZmZXIgPSBmdW5jdGlvbiBiaW5kQnVmZmVyKHRhcmdldCwgYnVmZmVyKSB7XG4gICAgc3dpdGNoICh0YXJnZXQpIHtcbiAgICAgIGNhc2UgMzQ5NjI6XG4gICAgICAgIHNlbGYuY3VycmVudEFycmF5QnVmZmVyID0gYnVmZmVyO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSAzNDk2MzpcbiAgICAgICAgc2VsZi5jdXJyZW50VmVydGV4QXJyYXlPYmplY3QuZWxlbWVudEFycmF5QnVmZmVyID0gYnVmZmVyO1xuICAgICAgICBicmVhaztcblxuICAgICAgZGVmYXVsdDpcbiAgICB9XG5cbiAgICByZXR1cm4gb3JpZ2luYWwuYmluZEJ1ZmZlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICB9O1xuXG4gIGdsLmdldFZlcnRleEF0dHJpYiA9IGZ1bmN0aW9uIGdldFZlcnRleEF0dHJpYihpbmRleCwgcG5hbWUpIHtcbiAgICBjb25zdCB2YW8gPSBzZWxmLmN1cnJlbnRWZXJ0ZXhBcnJheU9iamVjdDtcbiAgICBjb25zdCBhdHRyaWIgPSB2YW8uYXR0cmlic1tpbmRleF07XG5cbiAgICBzd2l0Y2ggKHBuYW1lKSB7XG4gICAgICBjYXNlIDM0OTc1OlxuICAgICAgICByZXR1cm4gYXR0cmliLmJ1ZmZlcjtcblxuICAgICAgY2FzZSAzNDMzODpcbiAgICAgICAgcmV0dXJuIGF0dHJpYi5lbmFibGVkO1xuXG4gICAgICBjYXNlIDM0MzM5OlxuICAgICAgICByZXR1cm4gYXR0cmliLnNpemU7XG5cbiAgICAgIGNhc2UgMzQzNDA6XG4gICAgICAgIHJldHVybiBhdHRyaWIuc3RyaWRlO1xuXG4gICAgICBjYXNlIDM0MzQxOlxuICAgICAgICByZXR1cm4gYXR0cmliLnR5cGU7XG5cbiAgICAgIGNhc2UgMzQ5MjI6XG4gICAgICAgIHJldHVybiBhdHRyaWIubm9ybWFsaXplZDtcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIG9yaWdpbmFsLmdldFZlcnRleEF0dHJpYi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgfTtcblxuICBnbC52ZXJ0ZXhBdHRyaWJQb2ludGVyID0gZnVuY3Rpb24gdmVydGV4QXR0cmliUG9pbnRlcihpbmR4LCBzaXplLCB0eXBlLCBub3JtYWxpemVkLCBzdHJpZGUsIG9mZnNldCkge1xuICAgIGNvbnN0IHZhbyA9IHNlbGYuY3VycmVudFZlcnRleEFycmF5T2JqZWN0O1xuICAgIHZhby5tYXhBdHRyaWIgPSBNYXRoLm1heCh2YW8ubWF4QXR0cmliLCBpbmR4KTtcbiAgICBjb25zdCBhdHRyaWIgPSB2YW8uYXR0cmlic1tpbmR4XTtcbiAgICBhdHRyaWIuYnVmZmVyID0gc2VsZi5jdXJyZW50QXJyYXlCdWZmZXI7XG4gICAgYXR0cmliLnNpemUgPSBzaXplO1xuICAgIGF0dHJpYi50eXBlID0gdHlwZTtcbiAgICBhdHRyaWIubm9ybWFsaXplZCA9IG5vcm1hbGl6ZWQ7XG4gICAgYXR0cmliLnN0cmlkZSA9IHN0cmlkZTtcbiAgICBhdHRyaWIub2Zmc2V0ID0gb2Zmc2V0O1xuICAgIGF0dHJpYi5yZWNhY2hlKCk7XG4gICAgcmV0dXJuIG9yaWdpbmFsLnZlcnRleEF0dHJpYlBvaW50ZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgfTtcblxuICBpZiAoZ2wuaW5zdHJ1bWVudEV4dGVuc2lvbikge1xuICAgIGdsLmluc3RydW1lbnRFeHRlbnNpb24odGhpcywgJ09FU192ZXJ0ZXhfYXJyYXlfb2JqZWN0Jyk7XG4gIH1cblxuICBpZiAoZ2wuY2FudmFzKSB7XG4gICAgZ2wuY2FudmFzLmFkZEV2ZW50TGlzdGVuZXIoJ3dlYmdsY29udGV4dHJlc3RvcmVkJywgKCkgPT4ge1xuICAgICAgbG9nKCdPRVNWZXJ0ZXhBcnJheU9iamVjdCBlbXVsYXRpb24gbGlicmFyeSBjb250ZXh0IHJlc3RvcmVkJyk7XG4gICAgICBzZWxmLnJlc2V0XygpO1xuICAgIH0sIHRydWUpO1xuICB9XG5cbiAgdGhpcy5yZXNldF8oKTtcbn07XG5cbk9FU1ZlcnRleEFycmF5T2JqZWN0LnByb3RvdHlwZS5WRVJURVhfQVJSQVlfQklORElOR19PRVMgPSAweDg1YjU7XG5cbk9FU1ZlcnRleEFycmF5T2JqZWN0LnByb3RvdHlwZS5yZXNldF8gPSBmdW5jdGlvbiByZXNldF8oKSB7XG4gIGNvbnN0IGNvbnRleHRXYXNMb3N0ID0gdGhpcy52ZXJ0ZXhBcnJheU9iamVjdHMgIT09IHVuZGVmaW5lZDtcblxuICBpZiAoY29udGV4dFdhc0xvc3QpIHtcbiAgICBmb3IgKGxldCBpaSA9IDA7IGlpIDwgdGhpcy52ZXJ0ZXhBcnJheU9iamVjdHMubGVuZ3RoOyArK2lpKSB7XG4gICAgICB0aGlzLnZlcnRleEFycmF5T2JqZWN0cy5pc0FsaXZlID0gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgY29uc3QgZ2wgPSB0aGlzLmdsO1xuICB0aGlzLm1heFZlcnRleEF0dHJpYnMgPSBnbC5nZXRQYXJhbWV0ZXIoMzQ5MjEpO1xuICB0aGlzLmRlZmF1bHRWZXJ0ZXhBcnJheU9iamVjdCA9IG5ldyBXZWJHTFZlcnRleEFycmF5T2JqZWN0T0VTKHRoaXMpO1xuICB0aGlzLmN1cnJlbnRWZXJ0ZXhBcnJheU9iamVjdCA9IG51bGw7XG4gIHRoaXMuY3VycmVudEFycmF5QnVmZmVyID0gbnVsbDtcbiAgdGhpcy52ZXJ0ZXhBcnJheU9iamVjdHMgPSBbdGhpcy5kZWZhdWx0VmVydGV4QXJyYXlPYmplY3RdO1xuICB0aGlzLmJpbmRWZXJ0ZXhBcnJheU9FUyhudWxsKTtcbn07XG5cbk9FU1ZlcnRleEFycmF5T2JqZWN0LnByb3RvdHlwZS5jcmVhdGVWZXJ0ZXhBcnJheU9FUyA9IGZ1bmN0aW9uIGNyZWF0ZVZlcnRleEFycmF5T0VTKCkge1xuICBjb25zdCBhcnJheU9iamVjdCA9IG5ldyBXZWJHTFZlcnRleEFycmF5T2JqZWN0T0VTKHRoaXMpO1xuICB0aGlzLnZlcnRleEFycmF5T2JqZWN0cy5wdXNoKGFycmF5T2JqZWN0KTtcbiAgcmV0dXJuIGFycmF5T2JqZWN0O1xufTtcblxuT0VTVmVydGV4QXJyYXlPYmplY3QucHJvdG90eXBlLmRlbGV0ZVZlcnRleEFycmF5T0VTID0gZnVuY3Rpb24gZGVsZXRlVmVydGV4QXJyYXlPRVMoYXJyYXlPYmplY3QpIHtcbiAgYXJyYXlPYmplY3QuaXNBbGl2ZSA9IGZhbHNlO1xuICB0aGlzLnZlcnRleEFycmF5T2JqZWN0cy5zcGxpY2UodGhpcy52ZXJ0ZXhBcnJheU9iamVjdHMuaW5kZXhPZihhcnJheU9iamVjdCksIDEpO1xuXG4gIGlmICh0aGlzLmN1cnJlbnRWZXJ0ZXhBcnJheU9iamVjdCA9PT0gYXJyYXlPYmplY3QpIHtcbiAgICB0aGlzLmJpbmRWZXJ0ZXhBcnJheU9FUyhudWxsKTtcbiAgfVxufTtcblxuT0VTVmVydGV4QXJyYXlPYmplY3QucHJvdG90eXBlLmlzVmVydGV4QXJyYXlPRVMgPSBmdW5jdGlvbiBpc1ZlcnRleEFycmF5T0VTKGFycmF5T2JqZWN0KSB7XG4gIGlmIChhcnJheU9iamVjdCAmJiBhcnJheU9iamVjdCBpbnN0YW5jZW9mIFdlYkdMVmVydGV4QXJyYXlPYmplY3RPRVMpIHtcbiAgICBpZiAoYXJyYXlPYmplY3QuaGFzQmVlbkJvdW5kICYmIGFycmF5T2JqZWN0LmV4dCA9PT0gdGhpcykge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufTtcblxuT0VTVmVydGV4QXJyYXlPYmplY3QucHJvdG90eXBlLmJpbmRWZXJ0ZXhBcnJheU9FUyA9IGZ1bmN0aW9uIGJpbmRWZXJ0ZXhBcnJheU9FUyhhcnJheU9iamVjdCkge1xuICBjb25zdCBnbCA9IHRoaXMuZ2w7XG5cbiAgaWYgKGFycmF5T2JqZWN0ICYmICFhcnJheU9iamVjdC5pc0FsaXZlKSB7XG4gICAgc3ludGhlc2l6ZUdMRXJyb3IoMTI4MiwgJ2JpbmRWZXJ0ZXhBcnJheU9FUzogYXR0ZW1wdCB0byBiaW5kIGRlbGV0ZWQgYXJyYXlPYmplY3QnKTtcbiAgICByZXR1cm47XG4gIH1cblxuICBjb25zdCBvcmlnaW5hbCA9IHRoaXMub3JpZ2luYWw7XG4gIGNvbnN0IG9sZFZBTyA9IHRoaXMuY3VycmVudFZlcnRleEFycmF5T2JqZWN0O1xuICB0aGlzLmN1cnJlbnRWZXJ0ZXhBcnJheU9iamVjdCA9IGFycmF5T2JqZWN0IHx8IHRoaXMuZGVmYXVsdFZlcnRleEFycmF5T2JqZWN0O1xuICB0aGlzLmN1cnJlbnRWZXJ0ZXhBcnJheU9iamVjdC5oYXNCZWVuQm91bmQgPSB0cnVlO1xuICBjb25zdCBuZXdWQU8gPSB0aGlzLmN1cnJlbnRWZXJ0ZXhBcnJheU9iamVjdDtcblxuICBpZiAob2xkVkFPID09PSBuZXdWQU8pIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBpZiAoIW9sZFZBTyB8fCBuZXdWQU8uZWxlbWVudEFycmF5QnVmZmVyICE9PSBvbGRWQU8uZWxlbWVudEFycmF5QnVmZmVyKSB7XG4gICAgb3JpZ2luYWwuYmluZEJ1ZmZlci5jYWxsKGdsLCAzNDk2MywgbmV3VkFPLmVsZW1lbnRBcnJheUJ1ZmZlcik7XG4gIH1cblxuICBsZXQgY3VycmVudEJpbmRpbmcgPSB0aGlzLmN1cnJlbnRBcnJheUJ1ZmZlcjtcbiAgY29uc3QgbWF4QXR0cmliID0gTWF0aC5tYXgob2xkVkFPID8gb2xkVkFPLm1heEF0dHJpYiA6IDAsIG5ld1ZBTy5tYXhBdHRyaWIpO1xuXG4gIGZvciAobGV0IG4gPSAwOyBuIDw9IG1heEF0dHJpYjsgbisrKSB7XG4gICAgY29uc3QgYXR0cmliID0gbmV3VkFPLmF0dHJpYnNbbl07XG4gICAgY29uc3Qgb2xkQXR0cmliID0gb2xkVkFPID8gb2xkVkFPLmF0dHJpYnNbbl0gOiBudWxsO1xuXG4gICAgaWYgKCFvbGRWQU8gfHwgYXR0cmliLmVuYWJsZWQgIT09IG9sZEF0dHJpYi5lbmFibGVkKSB7XG4gICAgICBpZiAoYXR0cmliLmVuYWJsZWQpIHtcbiAgICAgICAgb3JpZ2luYWwuZW5hYmxlVmVydGV4QXR0cmliQXJyYXkuY2FsbChnbCwgbik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBvcmlnaW5hbC5kaXNhYmxlVmVydGV4QXR0cmliQXJyYXkuY2FsbChnbCwgbik7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGF0dHJpYi5lbmFibGVkKSB7XG4gICAgICBsZXQgYnVmZmVyQ2hhbmdlZCA9IGZhbHNlO1xuXG4gICAgICBpZiAoIW9sZFZBTyB8fCBhdHRyaWIuYnVmZmVyICE9PSBvbGRBdHRyaWIuYnVmZmVyKSB7XG4gICAgICAgIGlmIChjdXJyZW50QmluZGluZyAhPT0gYXR0cmliLmJ1ZmZlcikge1xuICAgICAgICAgIG9yaWdpbmFsLmJpbmRCdWZmZXIuY2FsbChnbCwgMzQ5NjIsIGF0dHJpYi5idWZmZXIpO1xuICAgICAgICAgIGN1cnJlbnRCaW5kaW5nID0gYXR0cmliLmJ1ZmZlcjtcbiAgICAgICAgfVxuXG4gICAgICAgIGJ1ZmZlckNoYW5nZWQgPSB0cnVlO1xuICAgICAgfVxuXG4gICAgICBpZiAoYnVmZmVyQ2hhbmdlZCB8fCBhdHRyaWIuY2FjaGVkICE9PSBvbGRBdHRyaWIuY2FjaGVkKSB7XG4gICAgICAgIG9yaWdpbmFsLnZlcnRleEF0dHJpYlBvaW50ZXIuY2FsbChnbCwgbiwgYXR0cmliLnNpemUsIGF0dHJpYi50eXBlLCBhdHRyaWIubm9ybWFsaXplZCwgYXR0cmliLnN0cmlkZSwgYXR0cmliLm9mZnNldCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgaWYgKHRoaXMuY3VycmVudEFycmF5QnVmZmVyICE9PSBjdXJyZW50QmluZGluZykge1xuICAgIG9yaWdpbmFsLmJpbmRCdWZmZXIuY2FsbChnbCwgMzQ5NjIsIHRoaXMuY3VycmVudEFycmF5QnVmZmVyKTtcbiAgfVxufTtcblxuZXhwb3J0IGZ1bmN0aW9uIHBvbHlmaWxsVmVydGV4QXJyYXlPYmplY3QoZ2wpIHtcbiAgaWYgKHR5cGVvZiBnbC5jcmVhdGVWZXJ0ZXhBcnJheSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGNvbnN0IG9yaWdpbmFsX2dldFN1cHBvcnRlZEV4dGVuc2lvbnMgPSBnbC5nZXRTdXBwb3J0ZWRFeHRlbnNpb25zO1xuXG4gIGdsLmdldFN1cHBvcnRlZEV4dGVuc2lvbnMgPSBmdW5jdGlvbiBnZXRTdXBwb3J0ZWRFeHRlbnNpb25zKCkge1xuICAgIGNvbnN0IGxpc3QgPSBvcmlnaW5hbF9nZXRTdXBwb3J0ZWRFeHRlbnNpb25zLmNhbGwodGhpcykgfHwgW107XG5cbiAgICBpZiAobGlzdC5pbmRleE9mKCdPRVNfdmVydGV4X2FycmF5X29iamVjdCcpIDwgMCkge1xuICAgICAgbGlzdC5wdXNoKCdPRVNfdmVydGV4X2FycmF5X29iamVjdCcpO1xuICAgIH1cblxuICAgIHJldHVybiBsaXN0O1xuICB9O1xuXG4gIGNvbnN0IG9yaWdpbmFsX2dldEV4dGVuc2lvbiA9IGdsLmdldEV4dGVuc2lvbjtcblxuICBnbC5nZXRFeHRlbnNpb24gPSBmdW5jdGlvbiBnZXRFeHRlbnNpb24obmFtZSkge1xuICAgIGNvbnN0IGV4dCA9IG9yaWdpbmFsX2dldEV4dGVuc2lvbi5jYWxsKHRoaXMsIG5hbWUpO1xuXG4gICAgaWYgKGV4dCkge1xuICAgICAgcmV0dXJuIGV4dDtcbiAgICB9XG5cbiAgICBpZiAobmFtZSAhPT0gJ09FU192ZXJ0ZXhfYXJyYXlfb2JqZWN0Jykge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgaWYgKCFnbC5fX09FU1ZlcnRleEFycmF5T2JqZWN0KSB7XG4gICAgICB0aGlzLl9fT0VTVmVydGV4QXJyYXlPYmplY3QgPSBuZXcgT0VTVmVydGV4QXJyYXlPYmplY3QodGhpcyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuX19PRVNWZXJ0ZXhBcnJheU9iamVjdDtcbiAgfTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXBvbHlmaWxsLXZlcnRleC1hcnJheS1vYmplY3QuanMubWFwIiwiaW1wb3J0IHsgaXNXZWJHTDIgfSBmcm9tICcuLi91dGlscy93ZWJnbC1jaGVja3MnO1xuY29uc3QgT0VTX2VsZW1lbnRfaW5kZXggPSAnT0VTX2VsZW1lbnRfaW5kZXgnO1xuY29uc3QgV0VCR0xfZHJhd19idWZmZXJzID0gJ1dFQkdMX2RyYXdfYnVmZmVycyc7XG5jb25zdCBFWFRfZGlzam9pbnRfdGltZXJfcXVlcnkgPSAnRVhUX2Rpc2pvaW50X3RpbWVyX3F1ZXJ5JztcbmNvbnN0IEVYVF9kaXNqb2ludF90aW1lcl9xdWVyeV93ZWJnbDIgPSAnRVhUX2Rpc2pvaW50X3RpbWVyX3F1ZXJ5X3dlYmdsMic7XG5jb25zdCBFWFRfdGV4dHVyZV9maWx0ZXJfYW5pc290cm9waWMgPSAnRVhUX3RleHR1cmVfZmlsdGVyX2FuaXNvdHJvcGljJztcbmNvbnN0IFdFQkdMX2RlYnVnX3JlbmRlcmVyX2luZm8gPSAnV0VCR0xfZGVidWdfcmVuZGVyZXJfaW5mbyc7XG5jb25zdCBHTF9GUkFHTUVOVF9TSEFERVJfREVSSVZBVElWRV9ISU5UID0gMHg4YjhiO1xuY29uc3QgR0xfRE9OVF9DQVJFID0gMHgxMTAwO1xuY29uc3QgR0xfR1BVX0RJU0pPSU5UX0VYVCA9IDB4OGZiYjtcbmNvbnN0IEdMX01BWF9URVhUVVJFX01BWF9BTklTT1RST1BZX0VYVCA9IDB4ODRmZjtcbmNvbnN0IEdMX1VOTUFTS0VEX1ZFTkRPUl9XRUJHTCA9IDB4OTI0NTtcbmNvbnN0IEdMX1VOTUFTS0VEX1JFTkRFUkVSX1dFQkdMID0gMHg5MjQ2O1xuXG5jb25zdCBnZXRXZWJHTDJWYWx1ZU9yWmVybyA9IGdsID0+ICFpc1dlYkdMMihnbCkgPyAwIDogdW5kZWZpbmVkO1xuXG5jb25zdCBXRUJHTF9QQVJBTUVURVJTID0ge1xuICBbMzA3NF06IGdsID0+ICFpc1dlYkdMMihnbCkgPyAzNjA2NCA6IHVuZGVmaW5lZCxcbiAgW0dMX0ZSQUdNRU5UX1NIQURFUl9ERVJJVkFUSVZFX0hJTlRdOiBnbCA9PiAhaXNXZWJHTDIoZ2wpID8gR0xfRE9OVF9DQVJFIDogdW5kZWZpbmVkLFxuICBbMzU5NzddOiBnZXRXZWJHTDJWYWx1ZU9yWmVybyxcbiAgWzMyOTM3XTogZ2V0V2ViR0wyVmFsdWVPclplcm8sXG4gIFtHTF9HUFVfRElTSk9JTlRfRVhUXTogKGdsLCBnZXRQYXJhbWV0ZXIpID0+IHtcbiAgICBjb25zdCBleHQgPSBpc1dlYkdMMihnbCkgPyBnbC5nZXRFeHRlbnNpb24oRVhUX2Rpc2pvaW50X3RpbWVyX3F1ZXJ5X3dlYmdsMikgOiBnbC5nZXRFeHRlbnNpb24oRVhUX2Rpc2pvaW50X3RpbWVyX3F1ZXJ5KTtcbiAgICByZXR1cm4gZXh0ICYmIGV4dC5HUFVfRElTSk9JTlRfRVhUID8gZ2V0UGFyYW1ldGVyKGV4dC5HUFVfRElTSk9JTlRfRVhUKSA6IDA7XG4gIH0sXG4gIFtHTF9VTk1BU0tFRF9WRU5ET1JfV0VCR0xdOiAoZ2wsIGdldFBhcmFtZXRlcikgPT4ge1xuICAgIGNvbnN0IGV4dCA9IGdsLmdldEV4dGVuc2lvbihXRUJHTF9kZWJ1Z19yZW5kZXJlcl9pbmZvKTtcbiAgICByZXR1cm4gZ2V0UGFyYW1ldGVyKGV4dCAmJiBleHQuVU5NQVNLRURfVkVORE9SX1dFQkdMIHx8IDc5MzYpO1xuICB9LFxuICBbR0xfVU5NQVNLRURfUkVOREVSRVJfV0VCR0xdOiAoZ2wsIGdldFBhcmFtZXRlcikgPT4ge1xuICAgIGNvbnN0IGV4dCA9IGdsLmdldEV4dGVuc2lvbihXRUJHTF9kZWJ1Z19yZW5kZXJlcl9pbmZvKTtcbiAgICByZXR1cm4gZ2V0UGFyYW1ldGVyKGV4dCAmJiBleHQuVU5NQVNLRURfUkVOREVSRVJfV0VCR0wgfHwgNzkzNyk7XG4gIH0sXG4gIFtHTF9NQVhfVEVYVFVSRV9NQVhfQU5JU09UUk9QWV9FWFRdOiAoZ2wsIGdldFBhcmFtZXRlcikgPT4ge1xuICAgIGNvbnN0IGV4dCA9IGdsLmx1bWEuZXh0ZW5zaW9uc1tFWFRfdGV4dHVyZV9maWx0ZXJfYW5pc290cm9waWNdO1xuICAgIHJldHVybiBleHQgPyBnZXRQYXJhbWV0ZXIoZXh0Lk1BWF9URVhUVVJFX01BWF9BTklTT1RST1BZX0VYVCkgOiAxLjA7XG4gIH0sXG4gIFszMjg4M106IGdldFdlYkdMMlZhbHVlT3JaZXJvLFxuICBbMzUwNzFdOiBnZXRXZWJHTDJWYWx1ZU9yWmVybyxcbiAgWzM3NDQ3XTogZ2V0V2ViR0wyVmFsdWVPclplcm8sXG4gIFszNjA2M106IChnbCwgZ2V0UGFyYW1ldGVyKSA9PiB7XG4gICAgaWYgKCFpc1dlYkdMMihnbCkpIHtcbiAgICAgIGNvbnN0IGV4dCA9IGdsLmdldEV4dGVuc2lvbihXRUJHTF9kcmF3X2J1ZmZlcnMpO1xuICAgICAgcmV0dXJuIGV4dCA/IGdldFBhcmFtZXRlcihleHQuTUFYX0NPTE9SX0FUVEFDSE1FTlRTX1dFQkdMKSA6IDA7XG4gICAgfVxuXG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfSxcbiAgWzM1Mzc5XTogZ2V0V2ViR0wyVmFsdWVPclplcm8sXG4gIFszNTM3NF06IGdldFdlYkdMMlZhbHVlT3JaZXJvLFxuICBbMzUzNzddOiBnZXRXZWJHTDJWYWx1ZU9yWmVybyxcbiAgWzM0ODUyXTogZ2wgPT4ge1xuICAgIGlmICghaXNXZWJHTDIoZ2wpKSB7XG4gICAgICBjb25zdCBleHQgPSBnbC5nZXRFeHRlbnNpb24oV0VCR0xfZHJhd19idWZmZXJzKTtcbiAgICAgIHJldHVybiBleHQgPyBleHQuTUFYX0RSQVdfQlVGRkVSU19XRUJHTCA6IDA7XG4gICAgfVxuXG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfSxcbiAgWzM2MjAzXTogZ2wgPT4gZ2wuZ2V0RXh0ZW5zaW9uKE9FU19lbGVtZW50X2luZGV4KSA/IDIxNDc0ODM2NDcgOiA2NTUzNSxcbiAgWzMzMDAxXTogZ2wgPT4gZ2wuZ2V0RXh0ZW5zaW9uKE9FU19lbGVtZW50X2luZGV4KSA/IDE2Nzc3MjE2IDogNjU1MzUsXG4gIFszMzAwMF06IGdsID0+IDE2Nzc3MjE2LFxuICBbMzcxNTddOiBnZXRXZWJHTDJWYWx1ZU9yWmVybyxcbiAgWzM1MzczXTogZ2V0V2ViR0wyVmFsdWVPclplcm8sXG4gIFszNTY1N106IGdldFdlYkdMMlZhbHVlT3JaZXJvLFxuICBbMzYxODNdOiBnZXRXZWJHTDJWYWx1ZU9yWmVybyxcbiAgWzM3MTM3XTogZ2V0V2ViR0wyVmFsdWVPclplcm8sXG4gIFszNDA0NV06IGdldFdlYkdMMlZhbHVlT3JaZXJvLFxuICBbMzU5NzhdOiBnZXRXZWJHTDJWYWx1ZU9yWmVybyxcbiAgWzM1OTc5XTogZ2V0V2ViR0wyVmFsdWVPclplcm8sXG4gIFszNTk2OF06IGdldFdlYkdMMlZhbHVlT3JaZXJvLFxuICBbMzUzNzZdOiBnZXRXZWJHTDJWYWx1ZU9yWmVybyxcbiAgWzM1Mzc1XTogZ2V0V2ViR0wyVmFsdWVPclplcm8sXG4gIFszNTY1OV06IGdldFdlYkdMMlZhbHVlT3JaZXJvLFxuICBbMzcxNTRdOiBnZXRXZWJHTDJWYWx1ZU9yWmVybyxcbiAgWzM1MzcxXTogZ2V0V2ViR0wyVmFsdWVPclplcm8sXG4gIFszNTY1OF06IGdldFdlYkdMMlZhbHVlT3JaZXJvLFxuICBbMzUwNzZdOiBnZXRXZWJHTDJWYWx1ZU9yWmVybyxcbiAgWzM1MDc3XTogZ2V0V2ViR0wyVmFsdWVPclplcm8sXG4gIFszNTM4MF06IGdldFdlYkdMMlZhbHVlT3JaZXJvXG59O1xuZXhwb3J0IGZ1bmN0aW9uIGdldFBhcmFtZXRlclBvbHlmaWxsKGdsLCBvcmlnaW5hbEdldFBhcmFtZXRlciwgcG5hbWUpIHtcbiAgY29uc3QgbGltaXQgPSBXRUJHTF9QQVJBTUVURVJTW3BuYW1lXTtcbiAgY29uc3QgdmFsdWUgPSB0eXBlb2YgbGltaXQgPT09ICdmdW5jdGlvbicgPyBsaW1pdChnbCwgb3JpZ2luYWxHZXRQYXJhbWV0ZXIsIHBuYW1lKSA6IGxpbWl0O1xuICBjb25zdCByZXN1bHQgPSB2YWx1ZSAhPT0gdW5kZWZpbmVkID8gdmFsdWUgOiBvcmlnaW5hbEdldFBhcmFtZXRlcihwbmFtZSk7XG4gIHJldHVybiByZXN1bHQ7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1nZXQtcGFyYW1ldGVyLXBvbHlmaWxsLmpzLm1hcCIsImltcG9ydCB7IGFzc2VydCB9IGZyb20gJy4uL3V0aWxzL2Fzc2VydCc7XG5pbXBvcnQgeyBpc1dlYkdMMiB9IGZyb20gJy4uL3V0aWxzL3dlYmdsLWNoZWNrcyc7XG5pbXBvcnQgeyBnZXRQYXJhbWV0ZXJQb2x5ZmlsbCB9IGZyb20gJy4vZ2V0LXBhcmFtZXRlci1wb2x5ZmlsbCc7XG5jb25zdCBPRVNfdmVydGV4X2FycmF5X29iamVjdCA9ICdPRVNfdmVydGV4X2FycmF5X29iamVjdCc7XG5jb25zdCBBTkdMRV9pbnN0YW5jZWRfYXJyYXlzID0gJ0FOR0xFX2luc3RhbmNlZF9hcnJheXMnO1xuY29uc3QgV0VCR0xfZHJhd19idWZmZXJzID0gJ1dFQkdMX2RyYXdfYnVmZmVycyc7XG5jb25zdCBFWFRfZGlzam9pbnRfdGltZXJfcXVlcnkgPSAnRVhUX2Rpc2pvaW50X3RpbWVyX3F1ZXJ5JztcbmNvbnN0IEVYVF90ZXh0dXJlX2ZpbHRlcl9hbmlzb3Ryb3BpYyA9ICdFWFRfdGV4dHVyZV9maWx0ZXJfYW5pc290cm9waWMnO1xuY29uc3QgRVJSX1ZBT19OT1RfU1VQUE9SVEVEID0gJ1ZlcnRleEFycmF5IHJlcXVpcmVzIFdlYkdMMiBvciBPRVNfdmVydGV4X2FycmF5X29iamVjdCBleHRlbnNpb24nO1xuXG5mdW5jdGlvbiBnZXRFeHRlbnNpb25EYXRhKGdsLCBleHRlbnNpb24pIHtcbiAgcmV0dXJuIHtcbiAgICB3ZWJnbDI6IGlzV2ViR0wyKGdsKSxcbiAgICBleHQ6IGdsLmdldEV4dGVuc2lvbihleHRlbnNpb24pXG4gIH07XG59XG5cbmV4cG9ydCBjb25zdCBXRUJHTDJfQ09OVEVYVF9QT0xZRklMTFMgPSB7XG4gIFtPRVNfdmVydGV4X2FycmF5X29iamVjdF06IHtcbiAgICBtZXRhOiB7XG4gICAgICBzdWZmaXg6ICdPRVMnXG4gICAgfSxcbiAgICBjcmVhdGVWZXJ0ZXhBcnJheTogKCkgPT4ge1xuICAgICAgYXNzZXJ0KGZhbHNlLCBFUlJfVkFPX05PVF9TVVBQT1JURUQpO1xuICAgIH0sXG4gICAgZGVsZXRlVmVydGV4QXJyYXk6ICgpID0+IHt9LFxuICAgIGJpbmRWZXJ0ZXhBcnJheTogKCkgPT4ge30sXG4gICAgaXNWZXJ0ZXhBcnJheTogKCkgPT4gZmFsc2VcbiAgfSxcbiAgW0FOR0xFX2luc3RhbmNlZF9hcnJheXNdOiB7XG4gICAgbWV0YToge1xuICAgICAgc3VmZml4OiAnQU5HTEUnXG4gICAgfSxcblxuICAgIHZlcnRleEF0dHJpYkRpdmlzb3IobG9jYXRpb24sIGRpdmlzb3IpIHtcbiAgICAgIGFzc2VydChkaXZpc29yID09PSAwLCAnV2ViR0wgaW5zdGFuY2VkIHJlbmRlcmluZyBub3Qgc3VwcG9ydGVkJyk7XG4gICAgfSxcblxuICAgIGRyYXdFbGVtZW50c0luc3RhbmNlZDogKCkgPT4ge30sXG4gICAgZHJhd0FycmF5c0luc3RhbmNlZDogKCkgPT4ge31cbiAgfSxcbiAgW1dFQkdMX2RyYXdfYnVmZmVyc106IHtcbiAgICBtZXRhOiB7XG4gICAgICBzdWZmaXg6ICdXRUJHTCdcbiAgICB9LFxuICAgIGRyYXdCdWZmZXJzOiAoKSA9PiB7XG4gICAgICBhc3NlcnQoZmFsc2UpO1xuICAgIH1cbiAgfSxcbiAgW0VYVF9kaXNqb2ludF90aW1lcl9xdWVyeV06IHtcbiAgICBtZXRhOiB7XG4gICAgICBzdWZmaXg6ICdFWFQnXG4gICAgfSxcbiAgICBjcmVhdGVRdWVyeTogKCkgPT4ge1xuICAgICAgYXNzZXJ0KGZhbHNlKTtcbiAgICB9LFxuICAgIGRlbGV0ZVF1ZXJ5OiAoKSA9PiB7XG4gICAgICBhc3NlcnQoZmFsc2UpO1xuICAgIH0sXG4gICAgYmVnaW5RdWVyeTogKCkgPT4ge1xuICAgICAgYXNzZXJ0KGZhbHNlKTtcbiAgICB9LFxuICAgIGVuZFF1ZXJ5OiAoKSA9PiB7fSxcblxuICAgIGdldFF1ZXJ5KGhhbmRsZSwgcG5hbWUpIHtcbiAgICAgIHJldHVybiB0aGlzLmdldFF1ZXJ5T2JqZWN0KGhhbmRsZSwgcG5hbWUpO1xuICAgIH0sXG5cbiAgICBnZXRRdWVyeVBhcmFtZXRlcihoYW5kbGUsIHBuYW1lKSB7XG4gICAgICByZXR1cm4gdGhpcy5nZXRRdWVyeU9iamVjdChoYW5kbGUsIHBuYW1lKTtcbiAgICB9LFxuXG4gICAgZ2V0UXVlcnlPYmplY3Q6ICgpID0+IHt9XG4gIH1cbn07XG5leHBvcnQgY29uc3QgV0VCR0wyX0NPTlRFWFRfT1ZFUlJJREVTID0ge1xuICByZWFkQnVmZmVyOiAoZ2wsIG9yaWdpbmFsRnVuYywgYXR0YWNobWVudCkgPT4ge1xuICAgIGlmIChpc1dlYkdMMihnbCkpIHtcbiAgICAgIG9yaWdpbmFsRnVuYyhhdHRhY2htZW50KTtcbiAgICB9IGVsc2Uge31cbiAgfSxcbiAgZ2V0VmVydGV4QXR0cmliOiAoZ2wsIG9yaWdpbmFsRnVuYywgbG9jYXRpb24sIHBuYW1lKSA9PiB7XG4gICAgY29uc3Qge1xuICAgICAgd2ViZ2wyLFxuICAgICAgZXh0XG4gICAgfSA9IGdldEV4dGVuc2lvbkRhdGEoZ2wsIEFOR0xFX2luc3RhbmNlZF9hcnJheXMpO1xuICAgIGxldCByZXN1bHQ7XG5cbiAgICBzd2l0Y2ggKHBuYW1lKSB7XG4gICAgICBjYXNlIDM1MDY5OlxuICAgICAgICByZXN1bHQgPSAhd2ViZ2wyID8gZmFsc2UgOiB1bmRlZmluZWQ7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlIDM1MDcwOlxuICAgICAgICByZXN1bHQgPSAhd2ViZ2wyICYmICFleHQgPyAwIDogdW5kZWZpbmVkO1xuICAgICAgICBicmVhaztcblxuICAgICAgZGVmYXVsdDpcbiAgICB9XG5cbiAgICByZXR1cm4gcmVzdWx0ICE9PSB1bmRlZmluZWQgPyByZXN1bHQgOiBvcmlnaW5hbEZ1bmMobG9jYXRpb24sIHBuYW1lKTtcbiAgfSxcbiAgZ2V0UHJvZ3JhbVBhcmFtZXRlcjogKGdsLCBvcmlnaW5hbEZ1bmMsIHByb2dyYW0sIHBuYW1lKSA9PiB7XG4gICAgaWYgKCFpc1dlYkdMMihnbCkpIHtcbiAgICAgIHN3aXRjaCAocG5hbWUpIHtcbiAgICAgICAgY2FzZSAzNTk2NzpcbiAgICAgICAgICByZXR1cm4gMzU5ODE7XG5cbiAgICAgICAgY2FzZSAzNTk3MTpcbiAgICAgICAgICByZXR1cm4gMDtcblxuICAgICAgICBjYXNlIDM1MzgyOlxuICAgICAgICAgIHJldHVybiAwO1xuXG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIG9yaWdpbmFsRnVuYyhwcm9ncmFtLCBwbmFtZSk7XG4gIH0sXG4gIGdldEludGVybmFsZm9ybWF0UGFyYW1ldGVyOiAoZ2wsIG9yaWdpbmFsRnVuYywgdGFyZ2V0LCBmb3JtYXQsIHBuYW1lKSA9PiB7XG4gICAgaWYgKCFpc1dlYkdMMihnbCkpIHtcbiAgICAgIHN3aXRjaCAocG5hbWUpIHtcbiAgICAgICAgY2FzZSAzMjkzNzpcbiAgICAgICAgICByZXR1cm4gbmV3IEludDMyQXJyYXkoWzBdKTtcblxuICAgICAgICBkZWZhdWx0OlxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBnbC5nZXRJbnRlcm5hbGZvcm1hdFBhcmFtZXRlcih0YXJnZXQsIGZvcm1hdCwgcG5hbWUpO1xuICB9LFxuXG4gIGdldFRleFBhcmFtZXRlcihnbCwgb3JpZ2luYWxGdW5jLCB0YXJnZXQsIHBuYW1lKSB7XG4gICAgc3dpdGNoIChwbmFtZSkge1xuICAgICAgY2FzZSAzNDA0NjpcbiAgICAgICAgY29uc3Qge1xuICAgICAgICAgIGV4dGVuc2lvbnNcbiAgICAgICAgfSA9IGdsLmx1bWE7XG4gICAgICAgIGNvbnN0IGV4dCA9IGV4dGVuc2lvbnNbRVhUX3RleHR1cmVfZmlsdGVyX2FuaXNvdHJvcGljXTtcbiAgICAgICAgcG5hbWUgPSBleHQgJiYgZXh0LlRFWFRVUkVfTUFYX0FOSVNPVFJPUFlfRVhUIHx8IDM0MDQ2O1xuICAgICAgICBicmVhaztcblxuICAgICAgZGVmYXVsdDpcbiAgICB9XG5cbiAgICByZXR1cm4gb3JpZ2luYWxGdW5jKHRhcmdldCwgcG5hbWUpO1xuICB9LFxuXG4gIGdldFBhcmFtZXRlcjogZ2V0UGFyYW1ldGVyUG9seWZpbGwsXG5cbiAgaGludChnbCwgb3JpZ2luYWxGdW5jLCBwbmFtZSwgdmFsdWUpIHtcbiAgICByZXR1cm4gb3JpZ2luYWxGdW5jKHBuYW1lLCB2YWx1ZSk7XG4gIH1cblxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXBvbHlmaWxsLXRhYmxlLmpzLm1hcCIsImltcG9ydCB7IHBvbHlmaWxsVmVydGV4QXJyYXlPYmplY3QgfSBmcm9tICcuL3BvbHlmaWxsLXZlcnRleC1hcnJheS1vYmplY3QnO1xuaW1wb3J0IHsgYXNzZXJ0IH0gZnJvbSAnLi4vdXRpbHMvYXNzZXJ0JztcbmltcG9ydCB7IFdFQkdMMl9DT05URVhUX1BPTFlGSUxMUywgV0VCR0wyX0NPTlRFWFRfT1ZFUlJJREVTIH0gZnJvbSAnLi9wb2x5ZmlsbC10YWJsZSc7XG5leHBvcnQgZnVuY3Rpb24gcG9seWZpbGxDb250ZXh0KGdsKSB7XG4gIGdsLmx1bWEgPSBnbC5sdW1hIHx8IHt9O1xuICBjb25zdCB7XG4gICAgbHVtYVxuICB9ID0gZ2w7XG5cbiAgaWYgKCFsdW1hLnBvbHlmaWxsZWQpIHtcbiAgICBwb2x5ZmlsbFZlcnRleEFycmF5T2JqZWN0KGdsKTtcbiAgICBpbml0aWFsaXplRXh0ZW5zaW9ucyhnbCk7XG4gICAgaW5zdGFsbFBvbHlmaWxscyhnbCwgV0VCR0wyX0NPTlRFWFRfUE9MWUZJTExTKTtcbiAgICBpbnN0YWxsT3ZlcnJpZGVzKGdsLCB7XG4gICAgICB0YXJnZXQ6IGx1bWEsXG4gICAgICB0YXJnZXQyOiBnbFxuICAgIH0pO1xuICAgIGx1bWEucG9seWZpbGxlZCA9IHRydWU7XG4gIH1cblxuICByZXR1cm4gZ2w7XG59XG5nbG9iYWxUaGlzLnBvbHlmaWxsQ29udGV4dCA9IHBvbHlmaWxsQ29udGV4dDtcblxuZnVuY3Rpb24gaW5pdGlhbGl6ZUV4dGVuc2lvbnMoZ2wpIHtcbiAgZ2wubHVtYS5leHRlbnNpb25zID0ge307XG4gIGNvbnN0IEVYVEVOU0lPTlMgPSBnbC5nZXRTdXBwb3J0ZWRFeHRlbnNpb25zKCkgfHwgW107XG5cbiAgZm9yIChjb25zdCBleHRlbnNpb24gb2YgRVhURU5TSU9OUykge1xuICAgIGdsLmx1bWFbZXh0ZW5zaW9uXSA9IGdsLmdldEV4dGVuc2lvbihleHRlbnNpb24pO1xuICB9XG59XG5cbmZ1bmN0aW9uIGluc3RhbGxPdmVycmlkZXMoZ2wsIF9yZWYpIHtcbiAgbGV0IHtcbiAgICB0YXJnZXQsXG4gICAgdGFyZ2V0MlxuICB9ID0gX3JlZjtcbiAgT2JqZWN0LmtleXMoV0VCR0wyX0NPTlRFWFRfT1ZFUlJJREVTKS5mb3JFYWNoKGtleSA9PiB7XG4gICAgaWYgKHR5cGVvZiBXRUJHTDJfQ09OVEVYVF9PVkVSUklERVNba2V5XSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgY29uc3Qgb3JpZ2luYWxGdW5jID0gZ2xba2V5XSA/IGdsW2tleV0uYmluZChnbCkgOiAoKSA9PiB7fTtcbiAgICAgIGNvbnN0IHBvbHlmaWxsID0gV0VCR0wyX0NPTlRFWFRfT1ZFUlJJREVTW2tleV0uYmluZChudWxsLCBnbCwgb3JpZ2luYWxGdW5jKTtcbiAgICAgIHRhcmdldFtrZXldID0gcG9seWZpbGw7XG4gICAgICB0YXJnZXQyW2tleV0gPSBwb2x5ZmlsbDtcbiAgICB9XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBpbnN0YWxsUG9seWZpbGxzKGdsLCBwb2x5ZmlsbHMpIHtcbiAgZm9yIChjb25zdCBleHRlbnNpb24gb2YgT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMocG9seWZpbGxzKSkge1xuICAgIGlmIChleHRlbnNpb24gIT09ICdvdmVycmlkZXMnKSB7XG4gICAgICBwb2x5ZmlsbEV4dGVuc2lvbihnbCwge1xuICAgICAgICBleHRlbnNpb24sXG4gICAgICAgIHRhcmdldDogZ2wubHVtYSxcbiAgICAgICAgdGFyZ2V0MjogZ2xcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBwb2x5ZmlsbEV4dGVuc2lvbihnbCwgX3JlZjIpIHtcbiAgbGV0IHtcbiAgICBleHRlbnNpb24sXG4gICAgdGFyZ2V0LFxuICAgIHRhcmdldDJcbiAgfSA9IF9yZWYyO1xuICBjb25zdCBkZWZhdWx0cyA9IFdFQkdMMl9DT05URVhUX1BPTFlGSUxMU1tleHRlbnNpb25dO1xuICBhc3NlcnQoZGVmYXVsdHMpO1xuICBjb25zdCB7XG4gICAgbWV0YSA9IHt9XG4gIH0gPSBkZWZhdWx0cztcbiAgY29uc3Qge1xuICAgIHN1ZmZpeCA9ICcnXG4gIH0gPSBtZXRhO1xuICBjb25zdCBleHQgPSBnbC5nZXRFeHRlbnNpb24oZXh0ZW5zaW9uKTtcblxuICBmb3IgKGNvbnN0IGtleSBvZiBPYmplY3Qua2V5cyhkZWZhdWx0cykpIHtcbiAgICBjb25zdCBleHRLZXkgPSBcIlwiLmNvbmNhdChrZXkpLmNvbmNhdChzdWZmaXgpO1xuICAgIGxldCBwb2x5ZmlsbCA9IG51bGw7XG5cbiAgICBpZiAoa2V5ID09PSAnbWV0YScpIHt9IGVsc2UgaWYgKHR5cGVvZiBnbFtrZXldID09PSAnZnVuY3Rpb24nKSB7fSBlbHNlIGlmIChleHQgJiYgdHlwZW9mIGV4dFtleHRLZXldID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBwb2x5ZmlsbCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIGV4dFtleHRLZXldKC4uLmFyZ3VtZW50cyk7XG4gICAgICB9O1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIGRlZmF1bHRzW2tleV0gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHBvbHlmaWxsID0gZGVmYXVsdHNba2V5XS5iaW5kKHRhcmdldCk7XG4gICAgfVxuXG4gICAgaWYgKHBvbHlmaWxsKSB7XG4gICAgICB0YXJnZXRba2V5XSA9IHBvbHlmaWxsO1xuICAgICAgdGFyZ2V0MltrZXldID0gcG9seWZpbGw7XG4gICAgfVxuICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1wb2x5ZmlsbC1jb250ZXh0LmpzLm1hcCIsImltcG9ydCB7IGlzV2ViR0wyIH0gZnJvbSAnLi4vdXRpbHMvd2ViZ2wtY2hlY2tzJztcbmV4cG9ydCBjb25zdCBHTF9QQVJBTUVURVJfREVGQVVMVFMgPSB7XG4gIFszMDQyXTogZmFsc2UsXG4gIFszMjc3M106IG5ldyBGbG9hdDMyQXJyYXkoWzAsIDAsIDAsIDBdKSxcbiAgWzMyNzc3XTogMzI3NzQsXG4gIFszNDg3N106IDMyNzc0LFxuICBbMzI5NjldOiAxLFxuICBbMzI5NjhdOiAwLFxuICBbMzI5NzFdOiAxLFxuICBbMzI5NzBdOiAwLFxuICBbMzEwNl06IG5ldyBGbG9hdDMyQXJyYXkoWzAsIDAsIDAsIDBdKSxcbiAgWzMxMDddOiBbdHJ1ZSwgdHJ1ZSwgdHJ1ZSwgdHJ1ZV0sXG4gIFsyODg0XTogZmFsc2UsXG4gIFsyODg1XTogMTAyOSxcbiAgWzI5MjldOiBmYWxzZSxcbiAgWzI5MzFdOiAxLFxuICBbMjkzMl06IDUxMyxcbiAgWzI5MjhdOiBuZXcgRmxvYXQzMkFycmF5KFswLCAxXSksXG4gIFsyOTMwXTogdHJ1ZSxcbiAgWzMwMjRdOiB0cnVlLFxuICBbMzYwMDZdOiBudWxsLFxuICBbMjg4Nl06IDIzMDUsXG4gIFszMzE3MF06IDQzNTIsXG4gIFsyODQ5XTogMSxcbiAgWzMyODIzXTogZmFsc2UsXG4gIFszMjgyNF06IDAsXG4gIFsxMDc1Ml06IDAsXG4gIFszMjkzOF06IDEuMCxcbiAgWzMyOTM5XTogZmFsc2UsXG4gIFszMDg5XTogZmFsc2UsXG4gIFszMDg4XTogbmV3IEludDMyQXJyYXkoWzAsIDAsIDEwMjQsIDEwMjRdKSxcbiAgWzI5NjBdOiBmYWxzZSxcbiAgWzI5NjFdOiAwLFxuICBbMjk2OF06IDB4ZmZmZmZmZmYsXG4gIFszNjAwNV06IDB4ZmZmZmZmZmYsXG4gIFsyOTYyXTogNTE5LFxuICBbMjk2N106IDAsXG4gIFsyOTYzXTogMHhmZmZmZmZmZixcbiAgWzM0ODE2XTogNTE5LFxuICBbMzYwMDNdOiAwLFxuICBbMzYwMDRdOiAweGZmZmZmZmZmLFxuICBbMjk2NF06IDc2ODAsXG4gIFsyOTY1XTogNzY4MCxcbiAgWzI5NjZdOiA3NjgwLFxuICBbMzQ4MTddOiA3NjgwLFxuICBbMzQ4MThdOiA3NjgwLFxuICBbMzQ4MTldOiA3NjgwLFxuICBbMjk3OF06IFswLCAwLCAxMDI0LCAxMDI0XSxcbiAgWzMzMzNdOiA0LFxuICBbMzMxN106IDQsXG4gIFszNzQ0MF06IGZhbHNlLFxuICBbMzc0NDFdOiBmYWxzZSxcbiAgWzM3NDQzXTogMzc0NDQsXG4gIFszNTcyM106IDQzNTIsXG4gIFszNjAxMF06IG51bGwsXG4gIFszNTk3N106IGZhbHNlLFxuICBbMzMzMF06IDAsXG4gIFszMzMyXTogMCxcbiAgWzMzMzFdOiAwLFxuICBbMzMxNF06IDAsXG4gIFszMjg3OF06IDAsXG4gIFszMzE2XTogMCxcbiAgWzMzMTVdOiAwLFxuICBbMzI4NzddOiAwXG59O1xuXG5jb25zdCBlbmFibGUgPSAoZ2wsIHZhbHVlLCBrZXkpID0+IHZhbHVlID8gZ2wuZW5hYmxlKGtleSkgOiBnbC5kaXNhYmxlKGtleSk7XG5cbmNvbnN0IGhpbnQgPSAoZ2wsIHZhbHVlLCBrZXkpID0+IGdsLmhpbnQoa2V5LCB2YWx1ZSk7XG5cbmNvbnN0IHBpeGVsU3RvcmVpID0gKGdsLCB2YWx1ZSwga2V5KSA9PiBnbC5waXhlbFN0b3JlaShrZXksIHZhbHVlKTtcblxuY29uc3QgZHJhd0ZyYW1lYnVmZmVyID0gKGdsLCB2YWx1ZSkgPT4ge1xuICBjb25zdCB0YXJnZXQgPSBpc1dlYkdMMihnbCkgPyAzNjAwOSA6IDM2MTYwO1xuICByZXR1cm4gZ2wuYmluZEZyYW1lYnVmZmVyKHRhcmdldCwgdmFsdWUpO1xufTtcblxuY29uc3QgcmVhZEZyYW1lYnVmZmVyID0gKGdsLCB2YWx1ZSkgPT4ge1xuICByZXR1cm4gZ2wuYmluZEZyYW1lYnVmZmVyKDM2MDA4LCB2YWx1ZSk7XG59O1xuXG5mdW5jdGlvbiBpc0FycmF5KGFycmF5KSB7XG4gIHJldHVybiBBcnJheS5pc0FycmF5KGFycmF5KSB8fCBBcnJheUJ1ZmZlci5pc1ZpZXcoYXJyYXkpO1xufVxuXG5leHBvcnQgY29uc3QgR0xfUEFSQU1FVEVSX1NFVFRFUlMgPSB7XG4gIFszMDQyXTogZW5hYmxlLFxuICBbMzI3NzNdOiAoZ2wsIHZhbHVlKSA9PiBnbC5ibGVuZENvbG9yKC4uLnZhbHVlKSxcbiAgWzMyNzc3XTogJ2JsZW5kRXF1YXRpb24nLFxuICBbMzQ4NzddOiAnYmxlbmRFcXVhdGlvbicsXG4gIFszMjk2OV06ICdibGVuZEZ1bmMnLFxuICBbMzI5NjhdOiAnYmxlbmRGdW5jJyxcbiAgWzMyOTcxXTogJ2JsZW5kRnVuYycsXG4gIFszMjk3MF06ICdibGVuZEZ1bmMnLFxuICBbMzEwNl06IChnbCwgdmFsdWUpID0+IGdsLmNsZWFyQ29sb3IoLi4udmFsdWUpLFxuICBbMzEwN106IChnbCwgdmFsdWUpID0+IGdsLmNvbG9yTWFzayguLi52YWx1ZSksXG4gIFsyODg0XTogZW5hYmxlLFxuICBbMjg4NV06IChnbCwgdmFsdWUpID0+IGdsLmN1bGxGYWNlKHZhbHVlKSxcbiAgWzI5MjldOiBlbmFibGUsXG4gIFsyOTMxXTogKGdsLCB2YWx1ZSkgPT4gZ2wuY2xlYXJEZXB0aCh2YWx1ZSksXG4gIFsyOTMyXTogKGdsLCB2YWx1ZSkgPT4gZ2wuZGVwdGhGdW5jKHZhbHVlKSxcbiAgWzI5MjhdOiAoZ2wsIHZhbHVlKSA9PiBnbC5kZXB0aFJhbmdlKC4uLnZhbHVlKSxcbiAgWzI5MzBdOiAoZ2wsIHZhbHVlKSA9PiBnbC5kZXB0aE1hc2sodmFsdWUpLFxuICBbMzAyNF06IGVuYWJsZSxcbiAgWzM1NzIzXTogaGludCxcbiAgWzM2MDA2XTogZHJhd0ZyYW1lYnVmZmVyLFxuICBbMjg4Nl06IChnbCwgdmFsdWUpID0+IGdsLmZyb250RmFjZSh2YWx1ZSksXG4gIFszMzE3MF06IGhpbnQsXG4gIFsyODQ5XTogKGdsLCB2YWx1ZSkgPT4gZ2wubGluZVdpZHRoKHZhbHVlKSxcbiAgWzMyODIzXTogZW5hYmxlLFxuICBbMzI4MjRdOiAncG9seWdvbk9mZnNldCcsXG4gIFsxMDc1Ml06ICdwb2x5Z29uT2Zmc2V0JyxcbiAgWzM1OTc3XTogZW5hYmxlLFxuICBbMzI5MzhdOiAnc2FtcGxlQ292ZXJhZ2UnLFxuICBbMzI5MzldOiAnc2FtcGxlQ292ZXJhZ2UnLFxuICBbMzA4OV06IGVuYWJsZSxcbiAgWzMwODhdOiAoZ2wsIHZhbHVlKSA9PiBnbC5zY2lzc29yKC4uLnZhbHVlKSxcbiAgWzI5NjBdOiBlbmFibGUsXG4gIFsyOTYxXTogKGdsLCB2YWx1ZSkgPT4gZ2wuY2xlYXJTdGVuY2lsKHZhbHVlKSxcbiAgWzI5NjhdOiAoZ2wsIHZhbHVlKSA9PiBnbC5zdGVuY2lsTWFza1NlcGFyYXRlKDEwMjgsIHZhbHVlKSxcbiAgWzM2MDA1XTogKGdsLCB2YWx1ZSkgPT4gZ2wuc3RlbmNpbE1hc2tTZXBhcmF0ZSgxMDI5LCB2YWx1ZSksXG4gIFsyOTYyXTogJ3N0ZW5jaWxGdW5jRnJvbnQnLFxuICBbMjk2N106ICdzdGVuY2lsRnVuY0Zyb250JyxcbiAgWzI5NjNdOiAnc3RlbmNpbEZ1bmNGcm9udCcsXG4gIFszNDgxNl06ICdzdGVuY2lsRnVuY0JhY2snLFxuICBbMzYwMDNdOiAnc3RlbmNpbEZ1bmNCYWNrJyxcbiAgWzM2MDA0XTogJ3N0ZW5jaWxGdW5jQmFjaycsXG4gIFsyOTY0XTogJ3N0ZW5jaWxPcEZyb250JyxcbiAgWzI5NjVdOiAnc3RlbmNpbE9wRnJvbnQnLFxuICBbMjk2Nl06ICdzdGVuY2lsT3BGcm9udCcsXG4gIFszNDgxN106ICdzdGVuY2lsT3BCYWNrJyxcbiAgWzM0ODE4XTogJ3N0ZW5jaWxPcEJhY2snLFxuICBbMzQ4MTldOiAnc3RlbmNpbE9wQmFjaycsXG4gIFsyOTc4XTogKGdsLCB2YWx1ZSkgPT4gZ2wudmlld3BvcnQoLi4udmFsdWUpLFxuICBbMzMzM106IHBpeGVsU3RvcmVpLFxuICBbMzMxN106IHBpeGVsU3RvcmVpLFxuICBbMzc0NDBdOiBwaXhlbFN0b3JlaSxcbiAgWzM3NDQxXTogcGl4ZWxTdG9yZWksXG4gIFszNzQ0M106IHBpeGVsU3RvcmVpLFxuICBbMzMzMF06IHBpeGVsU3RvcmVpLFxuICBbMzMzMl06IHBpeGVsU3RvcmVpLFxuICBbMzMzMV06IHBpeGVsU3RvcmVpLFxuICBbMzYwMTBdOiByZWFkRnJhbWVidWZmZXIsXG4gIFszMzE0XTogcGl4ZWxTdG9yZWksXG4gIFszMjg3OF06IHBpeGVsU3RvcmVpLFxuICBbMzMxNl06IHBpeGVsU3RvcmVpLFxuICBbMzMxNV06IHBpeGVsU3RvcmVpLFxuICBbMzI4NzddOiBwaXhlbFN0b3JlaSxcbiAgZnJhbWVidWZmZXI6IChnbCwgZnJhbWVidWZmZXIpID0+IHtcbiAgICBjb25zdCBoYW5kbGUgPSBmcmFtZWJ1ZmZlciAmJiAnaGFuZGxlJyBpbiBmcmFtZWJ1ZmZlciA/IGZyYW1lYnVmZmVyLmhhbmRsZSA6IGZyYW1lYnVmZmVyO1xuICAgIHJldHVybiBnbC5iaW5kRnJhbWVidWZmZXIoMzYxNjAsIGhhbmRsZSk7XG4gIH0sXG4gIGJsZW5kOiAoZ2wsIHZhbHVlKSA9PiB2YWx1ZSA/IGdsLmVuYWJsZSgzMDQyKSA6IGdsLmRpc2FibGUoMzA0MiksXG4gIGJsZW5kQ29sb3I6IChnbCwgdmFsdWUpID0+IGdsLmJsZW5kQ29sb3IoLi4udmFsdWUpLFxuICBibGVuZEVxdWF0aW9uOiAoZ2wsIGFyZ3MpID0+IHtcbiAgICBhcmdzID0gaXNBcnJheShhcmdzKSA/IGFyZ3MgOiBbYXJncywgYXJnc107XG4gICAgZ2wuYmxlbmRFcXVhdGlvblNlcGFyYXRlKC4uLmFyZ3MpO1xuICB9LFxuICBibGVuZEZ1bmM6IChnbCwgYXJncykgPT4ge1xuICAgIGFyZ3MgPSBpc0FycmF5KGFyZ3MpICYmIGFyZ3MubGVuZ3RoID09PSAyID8gWy4uLmFyZ3MsIC4uLmFyZ3NdIDogYXJncztcbiAgICBnbC5ibGVuZEZ1bmNTZXBhcmF0ZSguLi5hcmdzKTtcbiAgfSxcbiAgY2xlYXJDb2xvcjogKGdsLCB2YWx1ZSkgPT4gZ2wuY2xlYXJDb2xvciguLi52YWx1ZSksXG4gIGNsZWFyRGVwdGg6IChnbCwgdmFsdWUpID0+IGdsLmNsZWFyRGVwdGgodmFsdWUpLFxuICBjbGVhclN0ZW5jaWw6IChnbCwgdmFsdWUpID0+IGdsLmNsZWFyU3RlbmNpbCh2YWx1ZSksXG4gIGNvbG9yTWFzazogKGdsLCB2YWx1ZSkgPT4gZ2wuY29sb3JNYXNrKC4uLnZhbHVlKSxcbiAgY3VsbDogKGdsLCB2YWx1ZSkgPT4gdmFsdWUgPyBnbC5lbmFibGUoMjg4NCkgOiBnbC5kaXNhYmxlKDI4ODQpLFxuICBjdWxsRmFjZTogKGdsLCB2YWx1ZSkgPT4gZ2wuY3VsbEZhY2UodmFsdWUpLFxuICBkZXB0aFRlc3Q6IChnbCwgdmFsdWUpID0+IHZhbHVlID8gZ2wuZW5hYmxlKDI5MjkpIDogZ2wuZGlzYWJsZSgyOTI5KSxcbiAgZGVwdGhGdW5jOiAoZ2wsIHZhbHVlKSA9PiBnbC5kZXB0aEZ1bmModmFsdWUpLFxuICBkZXB0aE1hc2s6IChnbCwgdmFsdWUpID0+IGdsLmRlcHRoTWFzayh2YWx1ZSksXG4gIGRlcHRoUmFuZ2U6IChnbCwgdmFsdWUpID0+IGdsLmRlcHRoUmFuZ2UoLi4udmFsdWUpLFxuICBkaXRoZXI6IChnbCwgdmFsdWUpID0+IHZhbHVlID8gZ2wuZW5hYmxlKDMwMjQpIDogZ2wuZGlzYWJsZSgzMDI0KSxcbiAgZGVyaXZhdGl2ZUhpbnQ6IChnbCwgdmFsdWUpID0+IHtcbiAgICBnbC5oaW50KDM1NzIzLCB2YWx1ZSk7XG4gIH0sXG4gIGZyb250RmFjZTogKGdsLCB2YWx1ZSkgPT4gZ2wuZnJvbnRGYWNlKHZhbHVlKSxcbiAgbWlwbWFwSGludDogKGdsLCB2YWx1ZSkgPT4gZ2wuaGludCgzMzE3MCwgdmFsdWUpLFxuICBsaW5lV2lkdGg6IChnbCwgdmFsdWUpID0+IGdsLmxpbmVXaWR0aCh2YWx1ZSksXG4gIHBvbHlnb25PZmZzZXRGaWxsOiAoZ2wsIHZhbHVlKSA9PiB2YWx1ZSA/IGdsLmVuYWJsZSgzMjgyMykgOiBnbC5kaXNhYmxlKDMyODIzKSxcbiAgcG9seWdvbk9mZnNldDogKGdsLCB2YWx1ZSkgPT4gZ2wucG9seWdvbk9mZnNldCguLi52YWx1ZSksXG4gIHNhbXBsZUNvdmVyYWdlOiAoZ2wsIHZhbHVlKSA9PiBnbC5zYW1wbGVDb3ZlcmFnZSguLi52YWx1ZSksXG4gIHNjaXNzb3JUZXN0OiAoZ2wsIHZhbHVlKSA9PiB2YWx1ZSA/IGdsLmVuYWJsZSgzMDg5KSA6IGdsLmRpc2FibGUoMzA4OSksXG4gIHNjaXNzb3I6IChnbCwgdmFsdWUpID0+IGdsLnNjaXNzb3IoLi4udmFsdWUpLFxuICBzdGVuY2lsVGVzdDogKGdsLCB2YWx1ZSkgPT4gdmFsdWUgPyBnbC5lbmFibGUoMjk2MCkgOiBnbC5kaXNhYmxlKDI5NjApLFxuICBzdGVuY2lsTWFzazogKGdsLCB2YWx1ZSkgPT4ge1xuICAgIHZhbHVlID0gaXNBcnJheSh2YWx1ZSkgPyB2YWx1ZSA6IFt2YWx1ZSwgdmFsdWVdO1xuICAgIGNvbnN0IFttYXNrLCBiYWNrTWFza10gPSB2YWx1ZTtcbiAgICBnbC5zdGVuY2lsTWFza1NlcGFyYXRlKDEwMjgsIG1hc2spO1xuICAgIGdsLnN0ZW5jaWxNYXNrU2VwYXJhdGUoMTAyOSwgYmFja01hc2spO1xuICB9LFxuICBzdGVuY2lsRnVuYzogKGdsLCBhcmdzKSA9PiB7XG4gICAgYXJncyA9IGlzQXJyYXkoYXJncykgJiYgYXJncy5sZW5ndGggPT09IDMgPyBbLi4uYXJncywgLi4uYXJnc10gOiBhcmdzO1xuICAgIGNvbnN0IFtmdW5jLCByZWYsIG1hc2ssIGJhY2tGdW5jLCBiYWNrUmVmLCBiYWNrTWFza10gPSBhcmdzO1xuICAgIGdsLnN0ZW5jaWxGdW5jU2VwYXJhdGUoMTAyOCwgZnVuYywgcmVmLCBtYXNrKTtcbiAgICBnbC5zdGVuY2lsRnVuY1NlcGFyYXRlKDEwMjksIGJhY2tGdW5jLCBiYWNrUmVmLCBiYWNrTWFzayk7XG4gIH0sXG4gIHN0ZW5jaWxPcDogKGdsLCBhcmdzKSA9PiB7XG4gICAgYXJncyA9IGlzQXJyYXkoYXJncykgJiYgYXJncy5sZW5ndGggPT09IDMgPyBbLi4uYXJncywgLi4uYXJnc10gOiBhcmdzO1xuICAgIGNvbnN0IFtzZmFpbCwgZHBmYWlsLCBkcHBhc3MsIGJhY2tTZmFpbCwgYmFja0RwZmFpbCwgYmFja0RwcGFzc10gPSBhcmdzO1xuICAgIGdsLnN0ZW5jaWxPcFNlcGFyYXRlKDEwMjgsIHNmYWlsLCBkcGZhaWwsIGRwcGFzcyk7XG4gICAgZ2wuc3RlbmNpbE9wU2VwYXJhdGUoMTAyOSwgYmFja1NmYWlsLCBiYWNrRHBmYWlsLCBiYWNrRHBwYXNzKTtcbiAgfSxcbiAgdmlld3BvcnQ6IChnbCwgdmFsdWUpID0+IGdsLnZpZXdwb3J0KC4uLnZhbHVlKVxufTtcblxuZnVuY3Rpb24gZ2V0VmFsdWUoZ2xFbnVtLCB2YWx1ZXMsIGNhY2hlKSB7XG4gIHJldHVybiB2YWx1ZXNbZ2xFbnVtXSAhPT0gdW5kZWZpbmVkID8gdmFsdWVzW2dsRW51bV0gOiBjYWNoZVtnbEVudW1dO1xufVxuXG5leHBvcnQgY29uc3QgR0xfQ09NUE9TSVRFX1BBUkFNRVRFUl9TRVRURVJTID0ge1xuICBibGVuZEVxdWF0aW9uOiAoZ2wsIHZhbHVlcywgY2FjaGUpID0+IGdsLmJsZW5kRXF1YXRpb25TZXBhcmF0ZShnZXRWYWx1ZSgzMjc3NywgdmFsdWVzLCBjYWNoZSksIGdldFZhbHVlKDM0ODc3LCB2YWx1ZXMsIGNhY2hlKSksXG4gIGJsZW5kRnVuYzogKGdsLCB2YWx1ZXMsIGNhY2hlKSA9PiBnbC5ibGVuZEZ1bmNTZXBhcmF0ZShnZXRWYWx1ZSgzMjk2OSwgdmFsdWVzLCBjYWNoZSksIGdldFZhbHVlKDMyOTY4LCB2YWx1ZXMsIGNhY2hlKSwgZ2V0VmFsdWUoMzI5NzEsIHZhbHVlcywgY2FjaGUpLCBnZXRWYWx1ZSgzMjk3MCwgdmFsdWVzLCBjYWNoZSkpLFxuICBwb2x5Z29uT2Zmc2V0OiAoZ2wsIHZhbHVlcywgY2FjaGUpID0+IGdsLnBvbHlnb25PZmZzZXQoZ2V0VmFsdWUoMzI4MjQsIHZhbHVlcywgY2FjaGUpLCBnZXRWYWx1ZSgxMDc1MiwgdmFsdWVzLCBjYWNoZSkpLFxuICBzYW1wbGVDb3ZlcmFnZTogKGdsLCB2YWx1ZXMsIGNhY2hlKSA9PiBnbC5zYW1wbGVDb3ZlcmFnZShnZXRWYWx1ZSgzMjkzOCwgdmFsdWVzLCBjYWNoZSksIGdldFZhbHVlKDMyOTM5LCB2YWx1ZXMsIGNhY2hlKSksXG4gIHN0ZW5jaWxGdW5jRnJvbnQ6IChnbCwgdmFsdWVzLCBjYWNoZSkgPT4gZ2wuc3RlbmNpbEZ1bmNTZXBhcmF0ZSgxMDI4LCBnZXRWYWx1ZSgyOTYyLCB2YWx1ZXMsIGNhY2hlKSwgZ2V0VmFsdWUoMjk2NywgdmFsdWVzLCBjYWNoZSksIGdldFZhbHVlKDI5NjMsIHZhbHVlcywgY2FjaGUpKSxcbiAgc3RlbmNpbEZ1bmNCYWNrOiAoZ2wsIHZhbHVlcywgY2FjaGUpID0+IGdsLnN0ZW5jaWxGdW5jU2VwYXJhdGUoMTAyOSwgZ2V0VmFsdWUoMzQ4MTYsIHZhbHVlcywgY2FjaGUpLCBnZXRWYWx1ZSgzNjAwMywgdmFsdWVzLCBjYWNoZSksIGdldFZhbHVlKDM2MDA0LCB2YWx1ZXMsIGNhY2hlKSksXG4gIHN0ZW5jaWxPcEZyb250OiAoZ2wsIHZhbHVlcywgY2FjaGUpID0+IGdsLnN0ZW5jaWxPcFNlcGFyYXRlKDEwMjgsIGdldFZhbHVlKDI5NjQsIHZhbHVlcywgY2FjaGUpLCBnZXRWYWx1ZSgyOTY1LCB2YWx1ZXMsIGNhY2hlKSwgZ2V0VmFsdWUoMjk2NiwgdmFsdWVzLCBjYWNoZSkpLFxuICBzdGVuY2lsT3BCYWNrOiAoZ2wsIHZhbHVlcywgY2FjaGUpID0+IGdsLnN0ZW5jaWxPcFNlcGFyYXRlKDEwMjksIGdldFZhbHVlKDM0ODE3LCB2YWx1ZXMsIGNhY2hlKSwgZ2V0VmFsdWUoMzQ4MTgsIHZhbHVlcywgY2FjaGUpLCBnZXRWYWx1ZSgzNDgxOSwgdmFsdWVzLCBjYWNoZSkpXG59O1xuZXhwb3J0IGNvbnN0IEdMX0hPT0tFRF9TRVRURVJTID0ge1xuICBlbmFibGU6ICh1cGRhdGUsIGNhcGFiaWxpdHkpID0+IHVwZGF0ZSh7XG4gICAgW2NhcGFiaWxpdHldOiB0cnVlXG4gIH0pLFxuICBkaXNhYmxlOiAodXBkYXRlLCBjYXBhYmlsaXR5KSA9PiB1cGRhdGUoe1xuICAgIFtjYXBhYmlsaXR5XTogZmFsc2VcbiAgfSksXG4gIHBpeGVsU3RvcmVpOiAodXBkYXRlLCBwbmFtZSwgdmFsdWUpID0+IHVwZGF0ZSh7XG4gICAgW3BuYW1lXTogdmFsdWVcbiAgfSksXG4gIGhpbnQ6ICh1cGRhdGUsIHBuYW1lLCBoaW50KSA9PiB1cGRhdGUoe1xuICAgIFtwbmFtZV06IGhpbnRcbiAgfSksXG4gIGJpbmRGcmFtZWJ1ZmZlcjogKHVwZGF0ZSwgdGFyZ2V0LCBmcmFtZWJ1ZmZlcikgPT4ge1xuICAgIHN3aXRjaCAodGFyZ2V0KSB7XG4gICAgICBjYXNlIDM2MTYwOlxuICAgICAgICByZXR1cm4gdXBkYXRlKHtcbiAgICAgICAgICBbMzYwMDZdOiBmcmFtZWJ1ZmZlcixcbiAgICAgICAgICBbMzYwMTBdOiBmcmFtZWJ1ZmZlclxuICAgICAgICB9KTtcblxuICAgICAgY2FzZSAzNjAwOTpcbiAgICAgICAgcmV0dXJuIHVwZGF0ZSh7XG4gICAgICAgICAgWzM2MDA2XTogZnJhbWVidWZmZXJcbiAgICAgICAgfSk7XG5cbiAgICAgIGNhc2UgMzYwMDg6XG4gICAgICAgIHJldHVybiB1cGRhdGUoe1xuICAgICAgICAgIFszNjAxMF06IGZyYW1lYnVmZmVyXG4gICAgICAgIH0pO1xuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gIH0sXG4gIGJsZW5kQ29sb3I6ICh1cGRhdGUsIHIsIGcsIGIsIGEpID0+IHVwZGF0ZSh7XG4gICAgWzMyNzczXTogbmV3IEZsb2F0MzJBcnJheShbciwgZywgYiwgYV0pXG4gIH0pLFxuICBibGVuZEVxdWF0aW9uOiAodXBkYXRlLCBtb2RlKSA9PiB1cGRhdGUoe1xuICAgIFszMjc3N106IG1vZGUsXG4gICAgWzM0ODc3XTogbW9kZVxuICB9KSxcbiAgYmxlbmRFcXVhdGlvblNlcGFyYXRlOiAodXBkYXRlLCBtb2RlUkdCLCBtb2RlQWxwaGEpID0+IHVwZGF0ZSh7XG4gICAgWzMyNzc3XTogbW9kZVJHQixcbiAgICBbMzQ4NzddOiBtb2RlQWxwaGFcbiAgfSksXG4gIGJsZW5kRnVuYzogKHVwZGF0ZSwgc3JjLCBkc3QpID0+IHVwZGF0ZSh7XG4gICAgWzMyOTY5XTogc3JjLFxuICAgIFszMjk2OF06IGRzdCxcbiAgICBbMzI5NzFdOiBzcmMsXG4gICAgWzMyOTcwXTogZHN0XG4gIH0pLFxuICBibGVuZEZ1bmNTZXBhcmF0ZTogKHVwZGF0ZSwgc3JjUkdCLCBkc3RSR0IsIHNyY0FscGhhLCBkc3RBbHBoYSkgPT4gdXBkYXRlKHtcbiAgICBbMzI5NjldOiBzcmNSR0IsXG4gICAgWzMyOTY4XTogZHN0UkdCLFxuICAgIFszMjk3MV06IHNyY0FscGhhLFxuICAgIFszMjk3MF06IGRzdEFscGhhXG4gIH0pLFxuICBjbGVhckNvbG9yOiAodXBkYXRlLCByLCBnLCBiLCBhKSA9PiB1cGRhdGUoe1xuICAgIFszMTA2XTogbmV3IEZsb2F0MzJBcnJheShbciwgZywgYiwgYV0pXG4gIH0pLFxuICBjbGVhckRlcHRoOiAodXBkYXRlLCBkZXB0aCkgPT4gdXBkYXRlKHtcbiAgICBbMjkzMV06IGRlcHRoXG4gIH0pLFxuICBjbGVhclN0ZW5jaWw6ICh1cGRhdGUsIHMpID0+IHVwZGF0ZSh7XG4gICAgWzI5NjFdOiBzXG4gIH0pLFxuICBjb2xvck1hc2s6ICh1cGRhdGUsIHIsIGcsIGIsIGEpID0+IHVwZGF0ZSh7XG4gICAgWzMxMDddOiBbciwgZywgYiwgYV1cbiAgfSksXG4gIGN1bGxGYWNlOiAodXBkYXRlLCBtb2RlKSA9PiB1cGRhdGUoe1xuICAgIFsyODg1XTogbW9kZVxuICB9KSxcbiAgZGVwdGhGdW5jOiAodXBkYXRlLCBmdW5jKSA9PiB1cGRhdGUoe1xuICAgIFsyOTMyXTogZnVuY1xuICB9KSxcbiAgZGVwdGhSYW5nZTogKHVwZGF0ZSwgek5lYXIsIHpGYXIpID0+IHVwZGF0ZSh7XG4gICAgWzI5MjhdOiBuZXcgRmxvYXQzMkFycmF5KFt6TmVhciwgekZhcl0pXG4gIH0pLFxuICBkZXB0aE1hc2s6ICh1cGRhdGUsIG1hc2spID0+IHVwZGF0ZSh7XG4gICAgWzI5MzBdOiBtYXNrXG4gIH0pLFxuICBmcm9udEZhY2U6ICh1cGRhdGUsIGZhY2UpID0+IHVwZGF0ZSh7XG4gICAgWzI4ODZdOiBmYWNlXG4gIH0pLFxuICBsaW5lV2lkdGg6ICh1cGRhdGUsIHdpZHRoKSA9PiB1cGRhdGUoe1xuICAgIFsyODQ5XTogd2lkdGhcbiAgfSksXG4gIHBvbHlnb25PZmZzZXQ6ICh1cGRhdGUsIGZhY3RvciwgdW5pdHMpID0+IHVwZGF0ZSh7XG4gICAgWzMyODI0XTogZmFjdG9yLFxuICAgIFsxMDc1Ml06IHVuaXRzXG4gIH0pLFxuICBzYW1wbGVDb3ZlcmFnZTogKHVwZGF0ZSwgdmFsdWUsIGludmVydCkgPT4gdXBkYXRlKHtcbiAgICBbMzI5MzhdOiB2YWx1ZSxcbiAgICBbMzI5MzldOiBpbnZlcnRcbiAgfSksXG4gIHNjaXNzb3I6ICh1cGRhdGUsIHgsIHksIHdpZHRoLCBoZWlnaHQpID0+IHVwZGF0ZSh7XG4gICAgWzMwODhdOiBuZXcgSW50MzJBcnJheShbeCwgeSwgd2lkdGgsIGhlaWdodF0pXG4gIH0pLFxuICBzdGVuY2lsTWFzazogKHVwZGF0ZSwgbWFzaykgPT4gdXBkYXRlKHtcbiAgICBbMjk2OF06IG1hc2ssXG4gICAgWzM2MDA1XTogbWFza1xuICB9KSxcbiAgc3RlbmNpbE1hc2tTZXBhcmF0ZTogKHVwZGF0ZSwgZmFjZSwgbWFzaykgPT4gdXBkYXRlKHtcbiAgICBbZmFjZSA9PT0gMTAyOCA/IDI5NjggOiAzNjAwNV06IG1hc2tcbiAgfSksXG4gIHN0ZW5jaWxGdW5jOiAodXBkYXRlLCBmdW5jLCByZWYsIG1hc2spID0+IHVwZGF0ZSh7XG4gICAgWzI5NjJdOiBmdW5jLFxuICAgIFsyOTY3XTogcmVmLFxuICAgIFsyOTYzXTogbWFzayxcbiAgICBbMzQ4MTZdOiBmdW5jLFxuICAgIFszNjAwM106IHJlZixcbiAgICBbMzYwMDRdOiBtYXNrXG4gIH0pLFxuICBzdGVuY2lsRnVuY1NlcGFyYXRlOiAodXBkYXRlLCBmYWNlLCBmdW5jLCByZWYsIG1hc2spID0+IHVwZGF0ZSh7XG4gICAgW2ZhY2UgPT09IDEwMjggPyAyOTYyIDogMzQ4MTZdOiBmdW5jLFxuICAgIFtmYWNlID09PSAxMDI4ID8gMjk2NyA6IDM2MDAzXTogcmVmLFxuICAgIFtmYWNlID09PSAxMDI4ID8gMjk2MyA6IDM2MDA0XTogbWFza1xuICB9KSxcbiAgc3RlbmNpbE9wOiAodXBkYXRlLCBmYWlsLCB6ZmFpbCwgenBhc3MpID0+IHVwZGF0ZSh7XG4gICAgWzI5NjRdOiBmYWlsLFxuICAgIFsyOTY1XTogemZhaWwsXG4gICAgWzI5NjZdOiB6cGFzcyxcbiAgICBbMzQ4MTddOiBmYWlsLFxuICAgIFszNDgxOF06IHpmYWlsLFxuICAgIFszNDgxOV06IHpwYXNzXG4gIH0pLFxuICBzdGVuY2lsT3BTZXBhcmF0ZTogKHVwZGF0ZSwgZmFjZSwgZmFpbCwgemZhaWwsIHpwYXNzKSA9PiB1cGRhdGUoe1xuICAgIFtmYWNlID09PSAxMDI4ID8gMjk2NCA6IDM0ODE3XTogZmFpbCxcbiAgICBbZmFjZSA9PT0gMTAyOCA/IDI5NjUgOiAzNDgxOF06IHpmYWlsLFxuICAgIFtmYWNlID09PSAxMDI4ID8gMjk2NiA6IDM0ODE5XTogenBhc3NcbiAgfSksXG4gIHZpZXdwb3J0OiAodXBkYXRlLCB4LCB5LCB3aWR0aCwgaGVpZ2h0KSA9PiB1cGRhdGUoe1xuICAgIFsyOTc4XTogW3gsIHksIHdpZHRoLCBoZWlnaHRdXG4gIH0pXG59O1xuXG5jb25zdCBpc0VuYWJsZWQgPSAoZ2wsIGtleSkgPT4gZ2wuaXNFbmFibGVkKGtleSk7XG5cbmV4cG9ydCBjb25zdCBHTF9QQVJBTUVURVJfR0VUVEVSUyA9IHtcbiAgWzMwNDJdOiBpc0VuYWJsZWQsXG4gIFsyODg0XTogaXNFbmFibGVkLFxuICBbMjkyOV06IGlzRW5hYmxlZCxcbiAgWzMwMjRdOiBpc0VuYWJsZWQsXG4gIFszMjgyM106IGlzRW5hYmxlZCxcbiAgWzMyOTI2XTogaXNFbmFibGVkLFxuICBbMzI5MjhdOiBpc0VuYWJsZWQsXG4gIFszMDg5XTogaXNFbmFibGVkLFxuICBbMjk2MF06IGlzRW5hYmxlZCxcbiAgWzM1OTc3XTogaXNFbmFibGVkXG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9d2ViZ2wtcGFyYW1ldGVyLXRhYmxlcy5qcy5tYXAiLCJleHBvcnQgZnVuY3Rpb24gaXNPYmplY3RFbXB0eShvYmplY3QpIHtcbiAgZm9yIChjb25zdCBrZXkgaW4gb2JqZWN0KSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59XG5leHBvcnQgZnVuY3Rpb24gZGVlcEFycmF5RXF1YWwoeCwgeSkge1xuICBpZiAoeCA9PT0geSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgY29uc3QgaXNBcnJheVggPSBBcnJheS5pc0FycmF5KHgpIHx8IEFycmF5QnVmZmVyLmlzVmlldyh4KTtcbiAgY29uc3QgaXNBcnJheVkgPSBBcnJheS5pc0FycmF5KHkpIHx8IEFycmF5QnVmZmVyLmlzVmlldyh5KTtcblxuICBpZiAoaXNBcnJheVggJiYgaXNBcnJheVkgJiYgeC5sZW5ndGggPT09IHkubGVuZ3RoKSB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB4Lmxlbmd0aDsgKytpKSB7XG4gICAgICBpZiAoeFtpXSAhPT0geVtpXSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD11dGlscy5qcy5tYXAiLCJpbXBvcnQgeyBHTF9QQVJBTUVURVJfREVGQVVMVFMsIEdMX0hPT0tFRF9TRVRURVJTIH0gZnJvbSAnLi93ZWJnbC1wYXJhbWV0ZXItdGFibGVzJztcbmltcG9ydCB7IHNldFBhcmFtZXRlcnMsIGdldFBhcmFtZXRlcnMgfSBmcm9tICcuL3VuaWZpZWQtcGFyYW1ldGVyLWFwaSc7XG5pbXBvcnQgeyBhc3NlcnQgfSBmcm9tICcuLi91dGlscy9hc3NlcnQnO1xuaW1wb3J0IHsgZGVlcEFycmF5RXF1YWwgfSBmcm9tICcuLi91dGlscy91dGlscyc7XG5cbmZ1bmN0aW9uIGluc3RhbGxHZXR0ZXJPdmVycmlkZShnbCwgZnVuY3Rpb25OYW1lKSB7XG4gIGNvbnN0IG9yaWdpbmFsR2V0dGVyRnVuYyA9IGdsW2Z1bmN0aW9uTmFtZV0uYmluZChnbCk7XG5cbiAgZ2xbZnVuY3Rpb25OYW1lXSA9IGZ1bmN0aW9uIGdldCgpIHtcbiAgICBjb25zdCBwbmFtZSA9IGFyZ3VtZW50cy5sZW5ndGggPD0gMCA/IHVuZGVmaW5lZCA6IGFyZ3VtZW50c1swXTtcblxuICAgIGlmICghKHBuYW1lIGluIGdsLnN0YXRlLmNhY2hlKSkge1xuICAgICAgcmV0dXJuIG9yaWdpbmFsR2V0dGVyRnVuYyguLi5hcmd1bWVudHMpO1xuICAgIH1cblxuICAgIHJldHVybiBnbC5zdGF0ZS5lbmFibGUgPyBnbC5zdGF0ZS5jYWNoZVtwbmFtZV0gOiBvcmlnaW5hbEdldHRlckZ1bmMoLi4uYXJndW1lbnRzKTtcbiAgfTtcblxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZ2xbZnVuY3Rpb25OYW1lXSwgJ25hbWUnLCB7XG4gICAgdmFsdWU6IFwiXCIuY29uY2F0KGZ1bmN0aW9uTmFtZSwgXCItZnJvbS1jYWNoZVwiKSxcbiAgICBjb25maWd1cmFibGU6IGZhbHNlXG4gIH0pO1xufVxuXG5mdW5jdGlvbiBpbnN0YWxsU2V0dGVyU3B5KGdsLCBmdW5jdGlvbk5hbWUsIHNldHRlcikge1xuICBjb25zdCBvcmlnaW5hbFNldHRlckZ1bmMgPSBnbFtmdW5jdGlvbk5hbWVdLmJpbmQoZ2wpO1xuXG4gIGdsW2Z1bmN0aW9uTmFtZV0gPSBmdW5jdGlvbiBzZXQoKSB7XG4gICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIHBhcmFtcyA9IG5ldyBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICAgIHBhcmFtc1tfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICB9XG5cbiAgICBjb25zdCB7XG4gICAgICB2YWx1ZUNoYW5nZWQsXG4gICAgICBvbGRWYWx1ZVxuICAgIH0gPSBzZXR0ZXIoZ2wuc3RhdGUuX3VwZGF0ZUNhY2hlLCAuLi5wYXJhbXMpO1xuXG4gICAgaWYgKHZhbHVlQ2hhbmdlZCkge1xuICAgICAgb3JpZ2luYWxTZXR0ZXJGdW5jKC4uLnBhcmFtcyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG9sZFZhbHVlO1xuICB9O1xuXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShnbFtmdW5jdGlvbk5hbWVdLCAnbmFtZScsIHtcbiAgICB2YWx1ZTogXCJcIi5jb25jYXQoZnVuY3Rpb25OYW1lLCBcIi10by1jYWNoZVwiKSxcbiAgICBjb25maWd1cmFibGU6IGZhbHNlXG4gIH0pO1xufVxuXG5mdW5jdGlvbiBpbnN0YWxsUHJvZ3JhbVNweShnbCkge1xuICBjb25zdCBvcmlnaW5hbFVzZVByb2dyYW0gPSBnbC51c2VQcm9ncmFtLmJpbmQoZ2wpO1xuXG4gIGdsLnVzZVByb2dyYW0gPSBmdW5jdGlvbiB1c2VQcm9ncmFtTHVtYShoYW5kbGUpIHtcbiAgICBpZiAoZ2wuc3RhdGUucHJvZ3JhbSAhPT0gaGFuZGxlKSB7XG4gICAgICBvcmlnaW5hbFVzZVByb2dyYW0oaGFuZGxlKTtcbiAgICAgIGdsLnN0YXRlLnByb2dyYW0gPSBoYW5kbGU7XG4gICAgfVxuICB9O1xufVxuXG5jbGFzcyBHTFN0YXRlIHtcbiAgY29uc3RydWN0b3IoZ2wpIHtcbiAgICBsZXQge1xuICAgICAgY29weVN0YXRlID0gZmFsc2UsXG4gICAgICBsb2cgPSAoKSA9PiB7fVxuICAgIH0gPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuICAgIHRoaXMuZ2wgPSBnbDtcbiAgICB0aGlzLnByb2dyYW0gPSBudWxsO1xuICAgIHRoaXMuc3RhdGVTdGFjayA9IFtdO1xuICAgIHRoaXMuZW5hYmxlID0gdHJ1ZTtcbiAgICB0aGlzLmNhY2hlID0gY29weVN0YXRlID8gZ2V0UGFyYW1ldGVycyhnbCkgOiBPYmplY3QuYXNzaWduKHt9LCBHTF9QQVJBTUVURVJfREVGQVVMVFMpO1xuICAgIHRoaXMubG9nID0gbG9nO1xuICAgIHRoaXMuX3VwZGF0ZUNhY2hlID0gdGhpcy5fdXBkYXRlQ2FjaGUuYmluZCh0aGlzKTtcbiAgICBPYmplY3Quc2VhbCh0aGlzKTtcbiAgfVxuXG4gIHB1c2goKSB7XG4gICAgbGV0IHZhbHVlcyA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge307XG4gICAgdGhpcy5zdGF0ZVN0YWNrLnB1c2goe30pO1xuICB9XG5cbiAgcG9wKCkge1xuICAgIGFzc2VydCh0aGlzLnN0YXRlU3RhY2subGVuZ3RoID4gMCk7XG4gICAgY29uc3Qgb2xkVmFsdWVzID0gdGhpcy5zdGF0ZVN0YWNrW3RoaXMuc3RhdGVTdGFjay5sZW5ndGggLSAxXTtcbiAgICBzZXRQYXJhbWV0ZXJzKHRoaXMuZ2wsIG9sZFZhbHVlcyk7XG4gICAgdGhpcy5zdGF0ZVN0YWNrLnBvcCgpO1xuICB9XG5cbiAgX3VwZGF0ZUNhY2hlKHZhbHVlcykge1xuICAgIGxldCB2YWx1ZUNoYW5nZWQgPSBmYWxzZTtcbiAgICBsZXQgb2xkVmFsdWU7XG4gICAgY29uc3Qgb2xkVmFsdWVzID0gdGhpcy5zdGF0ZVN0YWNrLmxlbmd0aCA+IDAgJiYgdGhpcy5zdGF0ZVN0YWNrW3RoaXMuc3RhdGVTdGFjay5sZW5ndGggLSAxXTtcblxuICAgIGZvciAoY29uc3Qga2V5IGluIHZhbHVlcykge1xuICAgICAgYXNzZXJ0KGtleSAhPT0gdW5kZWZpbmVkKTtcbiAgICAgIGNvbnN0IHZhbHVlID0gdmFsdWVzW2tleV07XG4gICAgICBjb25zdCBjYWNoZWQgPSB0aGlzLmNhY2hlW2tleV07XG5cbiAgICAgIGlmICghZGVlcEFycmF5RXF1YWwodmFsdWUsIGNhY2hlZCkpIHtcbiAgICAgICAgdmFsdWVDaGFuZ2VkID0gdHJ1ZTtcbiAgICAgICAgb2xkVmFsdWUgPSBjYWNoZWQ7XG5cbiAgICAgICAgaWYgKG9sZFZhbHVlcyAmJiAhKGtleSBpbiBvbGRWYWx1ZXMpKSB7XG4gICAgICAgICAgb2xkVmFsdWVzW2tleV0gPSBjYWNoZWQ7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmNhY2hlW2tleV0gPSB2YWx1ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgdmFsdWVDaGFuZ2VkLFxuICAgICAgb2xkVmFsdWVcbiAgICB9O1xuICB9XG5cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHRyYWNrQ29udGV4dFN0YXRlKGdsKSB7XG4gIGxldCBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcbiAgY29uc3Qge1xuICAgIGVuYWJsZSA9IHRydWUsXG4gICAgY29weVN0YXRlXG4gIH0gPSBvcHRpb25zO1xuICBhc3NlcnQoY29weVN0YXRlICE9PSB1bmRlZmluZWQpO1xuXG4gIGlmICghZ2wuc3RhdGUpIHtcbiAgICBjb25zdCB7XG4gICAgICBwb2x5ZmlsbENvbnRleHRcbiAgICB9ID0gZ2xvYmFsVGhpcztcblxuICAgIGlmIChwb2x5ZmlsbENvbnRleHQpIHtcbiAgICAgIHBvbHlmaWxsQ29udGV4dChnbCk7XG4gICAgfVxuXG4gICAgZ2wuc3RhdGUgPSBuZXcgR0xTdGF0ZShnbCwge1xuICAgICAgY29weVN0YXRlXG4gICAgfSk7XG4gICAgaW5zdGFsbFByb2dyYW1TcHkoZ2wpO1xuXG4gICAgZm9yIChjb25zdCBrZXkgaW4gR0xfSE9PS0VEX1NFVFRFUlMpIHtcbiAgICAgIGNvbnN0IHNldHRlciA9IEdMX0hPT0tFRF9TRVRURVJTW2tleV07XG4gICAgICBpbnN0YWxsU2V0dGVyU3B5KGdsLCBrZXksIHNldHRlcik7XG4gICAgfVxuXG4gICAgaW5zdGFsbEdldHRlck92ZXJyaWRlKGdsLCAnZ2V0UGFyYW1ldGVyJyk7XG4gICAgaW5zdGFsbEdldHRlck92ZXJyaWRlKGdsLCAnaXNFbmFibGVkJyk7XG4gIH1cblxuICBnbC5zdGF0ZS5lbmFibGUgPSBlbmFibGU7XG4gIHJldHVybiBnbDtcbn1cbmV4cG9ydCBmdW5jdGlvbiBwdXNoQ29udGV4dFN0YXRlKGdsKSB7XG4gIGlmICghZ2wuc3RhdGUpIHtcbiAgICB0cmFja0NvbnRleHRTdGF0ZShnbCwge1xuICAgICAgY29weVN0YXRlOiBmYWxzZVxuICAgIH0pO1xuICB9XG5cbiAgZ2wuc3RhdGUucHVzaCgpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIHBvcENvbnRleHRTdGF0ZShnbCkge1xuICBhc3NlcnQoZ2wuc3RhdGUpO1xuICBnbC5zdGF0ZS5wb3AoKTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXRyYWNrLWNvbnRleHQtc3RhdGUuanMubWFwIiwiaW1wb3J0IHsgR0xfUEFSQU1FVEVSX0RFRkFVTFRTLCBHTF9QQVJBTUVURVJfU0VUVEVSUywgR0xfQ09NUE9TSVRFX1BBUkFNRVRFUl9TRVRURVJTLCBHTF9QQVJBTUVURVJfR0VUVEVSUyB9IGZyb20gJy4vd2ViZ2wtcGFyYW1ldGVyLXRhYmxlcyc7XG5pbXBvcnQgeyBwdXNoQ29udGV4dFN0YXRlLCBwb3BDb250ZXh0U3RhdGUgfSBmcm9tICcuL3RyYWNrLWNvbnRleHQtc3RhdGUnO1xuaW1wb3J0IHsgYXNzZXJ0IH0gZnJvbSAnLi4vdXRpbHMvYXNzZXJ0JztcbmltcG9ydCB7IGlzV2ViR0wgfSBmcm9tICcuLi91dGlscy93ZWJnbC1jaGVja3MnO1xuaW1wb3J0IHsgaXNPYmplY3RFbXB0eSB9IGZyb20gJy4uL3V0aWxzL3V0aWxzJztcbmV4cG9ydCBmdW5jdGlvbiBzZXRQYXJhbWV0ZXJzKGdsLCB2YWx1ZXMpIHtcbiAgYXNzZXJ0KGlzV2ViR0woZ2wpLCAnc2V0UGFyYW1ldGVycyByZXF1aXJlcyBhIFdlYkdMIGNvbnRleHQnKTtcblxuICBpZiAoaXNPYmplY3RFbXB0eSh2YWx1ZXMpKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgY29uc3QgY29tcG9zaXRlU2V0dGVycyA9IHt9O1xuXG4gIGZvciAoY29uc3Qga2V5IGluIHZhbHVlcykge1xuICAgIGNvbnN0IGdsQ29uc3RhbnQgPSBOdW1iZXIoa2V5KTtcbiAgICBjb25zdCBzZXR0ZXIgPSBHTF9QQVJBTUVURVJfU0VUVEVSU1trZXldO1xuXG4gICAgaWYgKHNldHRlcikge1xuICAgICAgaWYgKHR5cGVvZiBzZXR0ZXIgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIGNvbXBvc2l0ZVNldHRlcnNbc2V0dGVyXSA9IHRydWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzZXR0ZXIoZ2wsIHZhbHVlc1trZXldLCBnbENvbnN0YW50KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBjb25zdCBjYWNoZSA9IGdsLnN0YXRlICYmIGdsLnN0YXRlLmNhY2hlO1xuXG4gIGlmIChjYWNoZSkge1xuICAgIGZvciAoY29uc3Qga2V5IGluIGNvbXBvc2l0ZVNldHRlcnMpIHtcbiAgICAgIGNvbnN0IGNvbXBvc2l0ZVNldHRlciA9IEdMX0NPTVBPU0lURV9QQVJBTUVURVJfU0VUVEVSU1trZXldO1xuICAgICAgY29tcG9zaXRlU2V0dGVyKGdsLCB2YWx1ZXMsIGNhY2hlKTtcbiAgICB9XG4gIH1cbn1cbmV4cG9ydCBmdW5jdGlvbiBnZXRQYXJhbWV0ZXJzKGdsLCBwYXJhbWV0ZXJzKSB7XG4gIHBhcmFtZXRlcnMgPSBwYXJhbWV0ZXJzIHx8IEdMX1BBUkFNRVRFUl9ERUZBVUxUUztcblxuICBpZiAodHlwZW9mIHBhcmFtZXRlcnMgPT09ICdudW1iZXInKSB7XG4gICAgY29uc3Qga2V5ID0gcGFyYW1ldGVycztcbiAgICBjb25zdCBnZXR0ZXIgPSBHTF9QQVJBTUVURVJfR0VUVEVSU1trZXldO1xuICAgIHJldHVybiBnZXR0ZXIgPyBnZXR0ZXIoZ2wsIGtleSkgOiBnbC5nZXRQYXJhbWV0ZXIoa2V5KTtcbiAgfVxuXG4gIGNvbnN0IHBhcmFtZXRlcktleXMgPSBBcnJheS5pc0FycmF5KHBhcmFtZXRlcnMpID8gcGFyYW1ldGVycyA6IE9iamVjdC5rZXlzKHBhcmFtZXRlcnMpO1xuICBjb25zdCBzdGF0ZSA9IHt9O1xuXG4gIGZvciAoY29uc3Qga2V5IG9mIHBhcmFtZXRlcktleXMpIHtcbiAgICBjb25zdCBnZXR0ZXIgPSBHTF9QQVJBTUVURVJfR0VUVEVSU1trZXldO1xuICAgIHN0YXRlW2tleV0gPSBnZXR0ZXIgPyBnZXR0ZXIoZ2wsIE51bWJlcihrZXkpKSA6IGdsLmdldFBhcmFtZXRlcihOdW1iZXIoa2V5KSk7XG4gIH1cblxuICByZXR1cm4gc3RhdGU7XG59XG5leHBvcnQgZnVuY3Rpb24gcmVzZXRQYXJhbWV0ZXJzKGdsKSB7XG4gIHNldFBhcmFtZXRlcnMoZ2wsIEdMX1BBUkFNRVRFUl9ERUZBVUxUUyk7XG59XG5leHBvcnQgZnVuY3Rpb24gd2l0aFBhcmFtZXRlcnMoZ2wsIHBhcmFtZXRlcnMsIGZ1bmMpIHtcbiAgaWYgKGlzT2JqZWN0RW1wdHkocGFyYW1ldGVycykpIHtcbiAgICByZXR1cm4gZnVuYyhnbCk7XG4gIH1cblxuICBjb25zdCB7XG4gICAgbm9jYXRjaCA9IHRydWVcbiAgfSA9IHBhcmFtZXRlcnM7XG4gIHB1c2hDb250ZXh0U3RhdGUoZ2wpO1xuICBzZXRQYXJhbWV0ZXJzKGdsLCBwYXJhbWV0ZXJzKTtcbiAgbGV0IHZhbHVlO1xuXG4gIGlmIChub2NhdGNoKSB7XG4gICAgdmFsdWUgPSBmdW5jKGdsKTtcbiAgICBwb3BDb250ZXh0U3RhdGUoZ2wpO1xuICB9IGVsc2Uge1xuICAgIHRyeSB7XG4gICAgICB2YWx1ZSA9IGZ1bmMoZ2wpO1xuICAgIH0gZmluYWxseSB7XG4gICAgICBwb3BDb250ZXh0U3RhdGUoZ2wpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB2YWx1ZTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXVuaWZpZWQtcGFyYW1ldGVyLWFwaS5qcy5tYXAiLCJleHBvcnQgZnVuY3Rpb24gY3NzVG9EZXZpY2VSYXRpbyhnbCkge1xuICBjb25zdCB7XG4gICAgbHVtYVxuICB9ID0gZ2w7XG5cbiAgaWYgKGdsLmNhbnZhcyAmJiBsdW1hKSB7XG4gICAgY29uc3Qge1xuICAgICAgY2xpZW50V2lkdGhcbiAgICB9ID0gbHVtYS5jYW52YXNTaXplSW5mbztcbiAgICByZXR1cm4gY2xpZW50V2lkdGggPyBnbC5kcmF3aW5nQnVmZmVyV2lkdGggLyBjbGllbnRXaWR0aCA6IDE7XG4gIH1cblxuICByZXR1cm4gMTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBjc3NUb0RldmljZVBpeGVscyhnbCwgY3NzUGl4ZWwpIHtcbiAgbGV0IHlJbnZlcnQgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IHRydWU7XG4gIGNvbnN0IHJhdGlvID0gY3NzVG9EZXZpY2VSYXRpbyhnbCk7XG4gIGNvbnN0IHdpZHRoID0gZ2wuZHJhd2luZ0J1ZmZlcldpZHRoO1xuICBjb25zdCBoZWlnaHQgPSBnbC5kcmF3aW5nQnVmZmVySGVpZ2h0O1xuICByZXR1cm4gc2NhbGVQaXhlbHMoY3NzUGl4ZWwsIHJhdGlvLCB3aWR0aCwgaGVpZ2h0LCB5SW52ZXJ0KTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBnZXREZXZpY2VQaXhlbFJhdGlvKHVzZURldmljZVBpeGVscykge1xuICBjb25zdCB3aW5kb3dSYXRpbyA9IHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnID8gMSA6IHdpbmRvdy5kZXZpY2VQaXhlbFJhdGlvIHx8IDE7XG5cbiAgaWYgKE51bWJlci5pc0Zpbml0ZSh1c2VEZXZpY2VQaXhlbHMpKSB7XG4gICAgcmV0dXJuIHVzZURldmljZVBpeGVscyA8PSAwID8gMSA6IHVzZURldmljZVBpeGVscztcbiAgfVxuXG4gIHJldHVybiB1c2VEZXZpY2VQaXhlbHMgPyB3aW5kb3dSYXRpbyA6IDE7XG59XG5cbmZ1bmN0aW9uIHNjYWxlUGl4ZWxzKHBpeGVsLCByYXRpbywgd2lkdGgsIGhlaWdodCwgeUludmVydCkge1xuICBjb25zdCB4ID0gc2NhbGVYKHBpeGVsWzBdLCByYXRpbywgd2lkdGgpO1xuICBsZXQgeSA9IHNjYWxlWShwaXhlbFsxXSwgcmF0aW8sIGhlaWdodCwgeUludmVydCk7XG4gIGxldCB0ID0gc2NhbGVYKHBpeGVsWzBdICsgMSwgcmF0aW8sIHdpZHRoKTtcbiAgY29uc3QgeEhpZ2ggPSB0ID09PSB3aWR0aCAtIDEgPyB0IDogdCAtIDE7XG4gIHQgPSBzY2FsZVkocGl4ZWxbMV0gKyAxLCByYXRpbywgaGVpZ2h0LCB5SW52ZXJ0KTtcbiAgbGV0IHlIaWdoO1xuXG4gIGlmICh5SW52ZXJ0KSB7XG4gICAgdCA9IHQgPT09IDAgPyB0IDogdCArIDE7XG4gICAgeUhpZ2ggPSB5O1xuICAgIHkgPSB0O1xuICB9IGVsc2Uge1xuICAgIHlIaWdoID0gdCA9PT0gaGVpZ2h0IC0gMSA/IHQgOiB0IC0gMTtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgeCxcbiAgICB5LFxuICAgIHdpZHRoOiBNYXRoLm1heCh4SGlnaCAtIHggKyAxLCAxKSxcbiAgICBoZWlnaHQ6IE1hdGgubWF4KHlIaWdoIC0geSArIDEsIDEpXG4gIH07XG59XG5cbmZ1bmN0aW9uIHNjYWxlWCh4LCByYXRpbywgd2lkdGgpIHtcbiAgY29uc3QgciA9IE1hdGgubWluKE1hdGgucm91bmQoeCAqIHJhdGlvKSwgd2lkdGggLSAxKTtcbiAgcmV0dXJuIHI7XG59XG5cbmZ1bmN0aW9uIHNjYWxlWSh5LCByYXRpbywgaGVpZ2h0LCB5SW52ZXJ0KSB7XG4gIHJldHVybiB5SW52ZXJ0ID8gTWF0aC5tYXgoMCwgaGVpZ2h0IC0gMSAtIE1hdGgucm91bmQoeSAqIHJhdGlvKSkgOiBNYXRoLm1pbihNYXRoLnJvdW5kKHkgKiByYXRpbyksIGhlaWdodCAtIDEpO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGV2aWNlLXBpeGVscy5qcy5tYXAiLCJpbXBvcnQgeyBpc0Jyb3dzZXIgYXMgZ2V0SXNCcm93c2VyIH0gZnJvbSAnQHByb2JlLmdsL2Vudic7XG5pbXBvcnQgeyB0cmFja0NvbnRleHRTdGF0ZSB9IGZyb20gJy4uL3N0YXRlLXRyYWNrZXIvdHJhY2stY29udGV4dC1zdGF0ZSc7XG5pbXBvcnQgeyBsb2cgfSBmcm9tICcuLi91dGlscy9sb2cnO1xuaW1wb3J0IHsgYXNzZXJ0IH0gZnJvbSAnLi4vdXRpbHMvYXNzZXJ0JztcbmltcG9ydCB7IGdldERldmljZVBpeGVsUmF0aW8gfSBmcm9tICcuLi91dGlscy9kZXZpY2UtcGl4ZWxzJztcbmltcG9ydCB7IGlzV2ViR0wyIH0gZnJvbSAnLi4vdXRpbHMvd2ViZ2wtY2hlY2tzJztcbmNvbnN0IGlzQnJvd3NlciA9IGdldElzQnJvd3NlcigpO1xuY29uc3QgaXNQYWdlID0gaXNCcm93c2VyICYmIHR5cGVvZiBkb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCc7XG5jb25zdCBDT05URVhUX0RFRkFVTFRTID0ge1xuICB3ZWJnbDI6IHRydWUsXG4gIHdlYmdsMTogdHJ1ZSxcbiAgdGhyb3dPbkVycm9yOiB0cnVlLFxuICBtYW5hZ2VTdGF0ZTogdHJ1ZSxcbiAgY2FudmFzOiBudWxsLFxuICBkZWJ1ZzogZmFsc2UsXG4gIHdpZHRoOiA4MDAsXG4gIGhlaWdodDogNjAwXG59O1xuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZUdMQ29udGV4dCgpIHtcbiAgbGV0IG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHt9O1xuICBhc3NlcnQoaXNCcm93c2VyLCBcImNyZWF0ZUdMQ29udGV4dCBvbmx5IGF2YWlsYWJsZSBpbiB0aGUgYnJvd3Nlci5cXG5DcmVhdGUgeW91ciBvd24gaGVhZGxlc3MgY29udGV4dCBvciB1c2UgJ2NyZWF0ZUhlYWRsZXNzQ29udGV4dCcgZnJvbSBAbHVtYS5nbC90ZXN0LXV0aWxzXCIpO1xuICBvcHRpb25zID0gT2JqZWN0LmFzc2lnbih7fSwgQ09OVEVYVF9ERUZBVUxUUywgb3B0aW9ucyk7XG4gIGNvbnN0IHtcbiAgICB3aWR0aCxcbiAgICBoZWlnaHRcbiAgfSA9IG9wdGlvbnM7XG5cbiAgZnVuY3Rpb24gb25FcnJvcihtZXNzYWdlKSB7XG4gICAgaWYgKG9wdGlvbnMudGhyb3dPbkVycm9yKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IobWVzc2FnZSk7XG4gICAgfVxuXG4gICAgY29uc29sZS5lcnJvcihtZXNzYWdlKTtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIG9wdGlvbnMub25FcnJvciA9IG9uRXJyb3I7XG4gIGxldCBnbDtcbiAgY29uc3Qge1xuICAgIGNhbnZhc1xuICB9ID0gb3B0aW9ucztcbiAgY29uc3QgdGFyZ2V0Q2FudmFzID0gZ2V0Q2FudmFzKHtcbiAgICBjYW52YXMsXG4gICAgd2lkdGgsXG4gICAgaGVpZ2h0LFxuICAgIG9uRXJyb3JcbiAgfSk7XG4gIGdsID0gY3JlYXRlQnJvd3NlckNvbnRleHQodGFyZ2V0Q2FudmFzLCBvcHRpb25zKTtcblxuICBpZiAoIWdsKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBnbCA9IGluc3RydW1lbnRHTENvbnRleHQoZ2wsIG9wdGlvbnMpO1xuICBsb2dJbmZvKGdsKTtcbiAgcmV0dXJuIGdsO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGluc3RydW1lbnRHTENvbnRleHQoZ2wpIHtcbiAgbGV0IG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuXG4gIGlmICghZ2wgfHwgZ2wuX2luc3RydW1lbnRlZCkge1xuICAgIHJldHVybiBnbDtcbiAgfVxuXG4gIGdsLl92ZXJzaW9uID0gZ2wuX3ZlcnNpb24gfHwgZ2V0VmVyc2lvbihnbCk7XG4gIGdsLmx1bWEgPSBnbC5sdW1hIHx8IHt9O1xuICBnbC5sdW1hLmNhbnZhc1NpemVJbmZvID0gZ2wubHVtYS5jYW52YXNTaXplSW5mbyB8fCB7fTtcbiAgb3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oe30sIENPTlRFWFRfREVGQVVMVFMsIG9wdGlvbnMpO1xuICBjb25zdCB7XG4gICAgbWFuYWdlU3RhdGUsXG4gICAgZGVidWdcbiAgfSA9IG9wdGlvbnM7XG5cbiAgaWYgKG1hbmFnZVN0YXRlKSB7XG4gICAgdHJhY2tDb250ZXh0U3RhdGUoZ2wsIHtcbiAgICAgIGNvcHlTdGF0ZTogZmFsc2UsXG4gICAgICBsb2c6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICAgICAgYXJnc1tfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBsb2cubG9nKDEsIC4uLmFyZ3MpKCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICBpZiAoaXNCcm93c2VyICYmIGRlYnVnKSB7XG4gICAgaWYgKCFnbG9iYWxUaGlzLm1ha2VEZWJ1Z0NvbnRleHQpIHtcbiAgICAgIGxvZy53YXJuKCdXZWJHTCBkZWJ1ZyBtb2RlIG5vdCBhY3RpdmF0ZWQuIGltcG9ydCBcIkBsdW1hLmdsL2RlYnVnXCIgdG8gZW5hYmxlLicpKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGdsID0gZ2xvYmFsVGhpcy5tYWtlRGVidWdDb250ZXh0KGdsLCBvcHRpb25zKTtcbiAgICAgIGxvZy5sZXZlbCA9IE1hdGgubWF4KGxvZy5sZXZlbCwgMSk7XG4gICAgfVxuICB9XG5cbiAgZ2wuX2luc3RydW1lbnRlZCA9IHRydWU7XG4gIHJldHVybiBnbDtcbn1cbmV4cG9ydCBmdW5jdGlvbiBnZXRDb250ZXh0RGVidWdJbmZvKGdsKSB7XG4gIGNvbnN0IHZlbmRvck1hc2tlZCA9IGdsLmdldFBhcmFtZXRlcig3OTM2KTtcbiAgY29uc3QgcmVuZGVyZXJNYXNrZWQgPSBnbC5nZXRQYXJhbWV0ZXIoNzkzNyk7XG4gIGNvbnN0IGV4dCA9IGdsLmdldEV4dGVuc2lvbignV0VCR0xfZGVidWdfcmVuZGVyZXJfaW5mbycpO1xuICBjb25zdCB2ZW5kb3JVbm1hc2tlZCA9IGV4dCAmJiBnbC5nZXRQYXJhbWV0ZXIoZXh0LlVOTUFTS0VEX1ZFTkRPUl9XRUJHTCB8fCA3OTM2KTtcbiAgY29uc3QgcmVuZGVyZXJVbm1hc2tlZCA9IGV4dCAmJiBnbC5nZXRQYXJhbWV0ZXIoZXh0LlVOTUFTS0VEX1JFTkRFUkVSX1dFQkdMIHx8IDc5MzcpO1xuICByZXR1cm4ge1xuICAgIHZlbmRvcjogdmVuZG9yVW5tYXNrZWQgfHwgdmVuZG9yTWFza2VkLFxuICAgIHJlbmRlcmVyOiByZW5kZXJlclVubWFza2VkIHx8IHJlbmRlcmVyTWFza2VkLFxuICAgIHZlbmRvck1hc2tlZCxcbiAgICByZW5kZXJlck1hc2tlZCxcbiAgICB2ZXJzaW9uOiBnbC5nZXRQYXJhbWV0ZXIoNzkzOCksXG4gICAgc2hhZGluZ0xhbmd1YWdlVmVyc2lvbjogZ2wuZ2V0UGFyYW1ldGVyKDM1NzI0KVxuICB9O1xufVxuZXhwb3J0IGZ1bmN0aW9uIHJlc2l6ZUdMQ29udGV4dChnbCkge1xuICBsZXQgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG5cbiAgaWYgKGdsLmNhbnZhcykge1xuICAgIGNvbnN0IGRldmljZVBpeGVsUmF0aW8gPSBnZXREZXZpY2VQaXhlbFJhdGlvKG9wdGlvbnMudXNlRGV2aWNlUGl4ZWxzKTtcbiAgICBzZXREZXZpY2VQaXhlbFJhdGlvKGdsLCBkZXZpY2VQaXhlbFJhdGlvLCBvcHRpb25zKTtcbiAgICByZXR1cm47XG4gIH1cblxuICBjb25zdCBleHQgPSBnbC5nZXRFeHRlbnNpb24oJ1NUQUNLR0xfcmVzaXplX2RyYXdpbmdidWZmZXInKTtcblxuICBpZiAoZXh0ICYmIFwid2lkdGhcIiBpbiBvcHRpb25zICYmIFwiaGVpZ2h0XCIgaW4gb3B0aW9ucykge1xuICAgIGV4dC5yZXNpemUob3B0aW9ucy53aWR0aCwgb3B0aW9ucy5oZWlnaHQpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUJyb3dzZXJDb250ZXh0KGNhbnZhcywgb3B0aW9ucykge1xuICBjb25zdCB7XG4gICAgb25FcnJvclxuICB9ID0gb3B0aW9ucztcbiAgbGV0IGVycm9yTWVzc2FnZSA9IG51bGw7XG5cbiAgY29uc3Qgb25DcmVhdGVFcnJvciA9IGVycm9yID0+IGVycm9yTWVzc2FnZSA9IGVycm9yLnN0YXR1c01lc3NhZ2UgfHwgZXJyb3JNZXNzYWdlO1xuXG4gIGNhbnZhcy5hZGRFdmVudExpc3RlbmVyKCd3ZWJnbGNvbnRleHRjcmVhdGlvbmVycm9yJywgb25DcmVhdGVFcnJvciwgZmFsc2UpO1xuICBjb25zdCB7XG4gICAgd2ViZ2wxID0gdHJ1ZSxcbiAgICB3ZWJnbDIgPSB0cnVlXG4gIH0gPSBvcHRpb25zO1xuICBsZXQgZ2wgPSBudWxsO1xuXG4gIGlmICh3ZWJnbDIpIHtcbiAgICBnbCA9IGdsIHx8IGNhbnZhcy5nZXRDb250ZXh0KCd3ZWJnbDInLCBvcHRpb25zKTtcbiAgICBnbCA9IGdsIHx8IGNhbnZhcy5nZXRDb250ZXh0KCdleHBlcmltZW50YWwtd2ViZ2wyJywgb3B0aW9ucyk7XG4gIH1cblxuICBpZiAod2ViZ2wxKSB7XG4gICAgZ2wgPSBnbCB8fCBjYW52YXMuZ2V0Q29udGV4dCgnd2ViZ2wnLCBvcHRpb25zKTtcbiAgICBnbCA9IGdsIHx8IGNhbnZhcy5nZXRDb250ZXh0KCdleHBlcmltZW50YWwtd2ViZ2wnLCBvcHRpb25zKTtcbiAgfVxuXG4gIGNhbnZhcy5yZW1vdmVFdmVudExpc3RlbmVyKCd3ZWJnbGNvbnRleHRjcmVhdGlvbmVycm9yJywgb25DcmVhdGVFcnJvciwgZmFsc2UpO1xuXG4gIGlmICghZ2wpIHtcbiAgICByZXR1cm4gb25FcnJvcihcIkZhaWxlZCB0byBjcmVhdGUgXCIuY29uY2F0KHdlYmdsMiAmJiAhd2ViZ2wxID8gJ1dlYkdMMicgOiAnV2ViR0wnLCBcIiBjb250ZXh0OiBcIikuY29uY2F0KGVycm9yTWVzc2FnZSB8fCAnVW5rbm93biBlcnJvcicpKTtcbiAgfVxuXG4gIGlmIChvcHRpb25zLm9uQ29udGV4dExvc3QpIHtcbiAgICBjYW52YXMuYWRkRXZlbnRMaXN0ZW5lcignd2ViZ2xjb250ZXh0bG9zdCcsIG9wdGlvbnMub25Db250ZXh0TG9zdCwgZmFsc2UpO1xuICB9XG5cbiAgaWYgKG9wdGlvbnMub25Db250ZXh0UmVzdG9yZWQpIHtcbiAgICBjYW52YXMuYWRkRXZlbnRMaXN0ZW5lcignd2ViZ2xjb250ZXh0cmVzdG9yZWQnLCBvcHRpb25zLm9uQ29udGV4dFJlc3RvcmVkLCBmYWxzZSk7XG4gIH1cblxuICByZXR1cm4gZ2w7XG59XG5cbmZ1bmN0aW9uIGdldENhbnZhcyhfcmVmKSB7XG4gIGxldCB7XG4gICAgY2FudmFzLFxuICAgIHdpZHRoID0gODAwLFxuICAgIGhlaWdodCA9IDYwMCxcbiAgICBvbkVycm9yXG4gIH0gPSBfcmVmO1xuICBsZXQgdGFyZ2V0Q2FudmFzO1xuXG4gIGlmICh0eXBlb2YgY2FudmFzID09PSAnc3RyaW5nJykge1xuICAgIGNvbnN0IGlzUGFnZUxvYWRlZCA9IGlzUGFnZSAmJiBkb2N1bWVudC5yZWFkeVN0YXRlID09PSAnY29tcGxldGUnO1xuXG4gICAgaWYgKCFpc1BhZ2VMb2FkZWQpIHtcbiAgICAgIG9uRXJyb3IoXCJjcmVhdGVHTENvbnRleHQgY2FsbGVkIG9uIGNhbnZhcyAnXCIuY29uY2F0KGNhbnZhcywgXCInIGJlZm9yZSBwYWdlIHdhcyBsb2FkZWRcIikpO1xuICAgIH1cblxuICAgIHRhcmdldENhbnZhcyA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGNhbnZhcyk7XG4gIH0gZWxzZSBpZiAoY2FudmFzKSB7XG4gICAgdGFyZ2V0Q2FudmFzID0gY2FudmFzO1xuICB9IGVsc2Uge1xuICAgIHRhcmdldENhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpO1xuICAgIHRhcmdldENhbnZhcy5pZCA9ICdsdW1hZ2wtY2FudmFzJztcbiAgICB0YXJnZXRDYW52YXMuc3R5bGUud2lkdGggPSBOdW1iZXIuaXNGaW5pdGUod2lkdGgpID8gXCJcIi5jb25jYXQod2lkdGgsIFwicHhcIikgOiAnMTAwJSc7XG4gICAgdGFyZ2V0Q2FudmFzLnN0eWxlLmhlaWdodCA9IE51bWJlci5pc0Zpbml0ZShoZWlnaHQpID8gXCJcIi5jb25jYXQoaGVpZ2h0LCBcInB4XCIpIDogJzEwMCUnO1xuICAgIGRvY3VtZW50LmJvZHkuaW5zZXJ0QmVmb3JlKHRhcmdldENhbnZhcywgZG9jdW1lbnQuYm9keS5maXJzdENoaWxkKTtcbiAgfVxuXG4gIHJldHVybiB0YXJnZXRDYW52YXM7XG59XG5cbmZ1bmN0aW9uIGxvZ0luZm8oZ2wpIHtcbiAgY29uc3Qgd2ViR0wgPSBpc1dlYkdMMihnbCkgPyAnV2ViR0wyJyA6ICdXZWJHTDEnO1xuICBjb25zdCBpbmZvID0gZ2V0Q29udGV4dERlYnVnSW5mbyhnbCk7XG4gIGNvbnN0IGRyaXZlciA9IGluZm8gPyBcIihcIi5jb25jYXQoaW5mby52ZW5kb3IsIFwiLFwiKS5jb25jYXQoaW5mby5yZW5kZXJlciwgXCIpXCIpIDogJyc7XG4gIGNvbnN0IGRlYnVnID0gZ2wuZGVidWcgPyAnIGRlYnVnJyA6ICcnO1xuICBsb2cuaW5mbygxLCBcIlwiLmNvbmNhdCh3ZWJHTCkuY29uY2F0KGRlYnVnLCBcIiBjb250ZXh0IFwiKS5jb25jYXQoZHJpdmVyKSkoKTtcbn1cblxuZnVuY3Rpb24gZ2V0VmVyc2lvbihnbCkge1xuICBpZiAodHlwZW9mIFdlYkdMMlJlbmRlcmluZ0NvbnRleHQgIT09ICd1bmRlZmluZWQnICYmIGdsIGluc3RhbmNlb2YgV2ViR0wyUmVuZGVyaW5nQ29udGV4dCkge1xuICAgIHJldHVybiAyO1xuICB9XG5cbiAgcmV0dXJuIDE7XG59XG5cbmZ1bmN0aW9uIHNldERldmljZVBpeGVsUmF0aW8oZ2wsIGRldmljZVBpeGVsUmF0aW8sIG9wdGlvbnMpIHtcbiAgbGV0IGNsaWVudFdpZHRoID0gJ3dpZHRoJyBpbiBvcHRpb25zID8gb3B0aW9ucy53aWR0aCA6IGdsLmNhbnZhcy5jbGllbnRXaWR0aDtcbiAgbGV0IGNsaWVudEhlaWdodCA9ICdoZWlnaHQnIGluIG9wdGlvbnMgPyBvcHRpb25zLmhlaWdodCA6IGdsLmNhbnZhcy5jbGllbnRIZWlnaHQ7XG5cbiAgaWYgKCFjbGllbnRXaWR0aCB8fCAhY2xpZW50SGVpZ2h0KSB7XG4gICAgbG9nLmxvZygxLCAnQ2FudmFzIGNsaWVudFdpZHRoL2NsaWVudEhlaWdodCBpcyAwJykoKTtcbiAgICBkZXZpY2VQaXhlbFJhdGlvID0gMTtcbiAgICBjbGllbnRXaWR0aCA9IGdsLmNhbnZhcy53aWR0aCB8fCAxO1xuICAgIGNsaWVudEhlaWdodCA9IGdsLmNhbnZhcy5oZWlnaHQgfHwgMTtcbiAgfVxuXG4gIGdsLmx1bWEgPSBnbC5sdW1hIHx8IHt9O1xuICBnbC5sdW1hLmNhbnZhc1NpemVJbmZvID0gZ2wubHVtYS5jYW52YXNTaXplSW5mbyB8fCB7fTtcbiAgY29uc3QgY2FjaGVkU2l6ZSA9IGdsLmx1bWEuY2FudmFzU2l6ZUluZm87XG5cbiAgaWYgKGNhY2hlZFNpemUuY2xpZW50V2lkdGggIT09IGNsaWVudFdpZHRoIHx8IGNhY2hlZFNpemUuY2xpZW50SGVpZ2h0ICE9PSBjbGllbnRIZWlnaHQgfHwgY2FjaGVkU2l6ZS5kZXZpY2VQaXhlbFJhdGlvICE9PSBkZXZpY2VQaXhlbFJhdGlvKSB7XG4gICAgbGV0IGNsYW1wZWRQaXhlbFJhdGlvID0gZGV2aWNlUGl4ZWxSYXRpbztcbiAgICBjb25zdCBjYW52YXNXaWR0aCA9IE1hdGguZmxvb3IoY2xpZW50V2lkdGggKiBjbGFtcGVkUGl4ZWxSYXRpbyk7XG4gICAgY29uc3QgY2FudmFzSGVpZ2h0ID0gTWF0aC5mbG9vcihjbGllbnRIZWlnaHQgKiBjbGFtcGVkUGl4ZWxSYXRpbyk7XG4gICAgZ2wuY2FudmFzLndpZHRoID0gY2FudmFzV2lkdGg7XG4gICAgZ2wuY2FudmFzLmhlaWdodCA9IGNhbnZhc0hlaWdodDtcblxuICAgIGlmIChnbC5kcmF3aW5nQnVmZmVyV2lkdGggIT09IGNhbnZhc1dpZHRoIHx8IGdsLmRyYXdpbmdCdWZmZXJIZWlnaHQgIT09IGNhbnZhc0hlaWdodCkge1xuICAgICAgbG9nLndhcm4oXCJEZXZpY2UgcGl4ZWwgcmF0aW8gY2xhbXBlZFwiKSgpO1xuICAgICAgY2xhbXBlZFBpeGVsUmF0aW8gPSBNYXRoLm1pbihnbC5kcmF3aW5nQnVmZmVyV2lkdGggLyBjbGllbnRXaWR0aCwgZ2wuZHJhd2luZ0J1ZmZlckhlaWdodCAvIGNsaWVudEhlaWdodCk7XG4gICAgICBnbC5jYW52YXMud2lkdGggPSBNYXRoLmZsb29yKGNsaWVudFdpZHRoICogY2xhbXBlZFBpeGVsUmF0aW8pO1xuICAgICAgZ2wuY2FudmFzLmhlaWdodCA9IE1hdGguZmxvb3IoY2xpZW50SGVpZ2h0ICogY2xhbXBlZFBpeGVsUmF0aW8pO1xuICAgIH1cblxuICAgIE9iamVjdC5hc3NpZ24oZ2wubHVtYS5jYW52YXNTaXplSW5mbywge1xuICAgICAgY2xpZW50V2lkdGgsXG4gICAgICBjbGllbnRIZWlnaHQsXG4gICAgICBkZXZpY2VQaXhlbFJhdGlvXG4gICAgfSk7XG4gIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNvbnRleHQuanMubWFwIiwiZXhwb3J0IHsgbG9nIH0gZnJvbSAnLi91dGlscy9sb2cnO1xuZXhwb3J0IHsgaXNXZWJHTCwgaXNXZWJHTDIsIGdldFdlYkdMMkNvbnRleHQsIGFzc2VydFdlYkdMQ29udGV4dCwgYXNzZXJ0V2ViR0wyQ29udGV4dCB9IGZyb20gJy4vdXRpbHMvd2ViZ2wtY2hlY2tzJztcbmV4cG9ydCB7IHBvbHlmaWxsQ29udGV4dCB9IGZyb20gJy4vcG9seWZpbGwvcG9seWZpbGwtY29udGV4dCc7XG5leHBvcnQgeyBnZXRQYXJhbWV0ZXJzLCBzZXRQYXJhbWV0ZXJzLCByZXNldFBhcmFtZXRlcnMsIHdpdGhQYXJhbWV0ZXJzIH0gZnJvbSAnLi9zdGF0ZS10cmFja2VyL3VuaWZpZWQtcGFyYW1ldGVyLWFwaSc7XG5leHBvcnQgeyB0cmFja0NvbnRleHRTdGF0ZSwgcHVzaENvbnRleHRTdGF0ZSwgcG9wQ29udGV4dFN0YXRlIH0gZnJvbSAnLi9zdGF0ZS10cmFja2VyL3RyYWNrLWNvbnRleHQtc3RhdGUnO1xuZXhwb3J0IHsgY3JlYXRlR0xDb250ZXh0LCByZXNpemVHTENvbnRleHQsIGluc3RydW1lbnRHTENvbnRleHQsIGdldENvbnRleHREZWJ1Z0luZm8gfSBmcm9tICcuL2NvbnRleHQvY29udGV4dCc7XG5leHBvcnQgeyBjc3NUb0RldmljZVJhdGlvLCBjc3NUb0RldmljZVBpeGVscyB9IGZyb20gJy4vdXRpbHMvZGV2aWNlLXBpeGVscyc7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///1418\n")},75682:function(__unused_webpack_module,__webpack_exports__,__webpack_require__){eval("/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"H\": function() { return /* binding */ VERTEX_SHADER; },\n/* harmony export */   \"Y\": function() { return /* binding */ FRAGMENT_SHADER; }\n/* harmony export */ });\nconst VERTEX_SHADER = 'vs';\nconst FRAGMENT_SHADER = 'fs';\n//# sourceMappingURL=constants.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNzU2ODIuanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFPO0FBQ0E7QUFDUCIsInNvdXJjZXMiOlsid2VicGFjazovL3Z1ZTMtd2VicGFjazUvLi9ub2RlX21vZHVsZXMvQGx1bWEuZ2wvc2hhZGVydG9vbHMvZGlzdC9lc20vbGliL2NvbnN0YW50cy5qcz9kZDg2Il0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCBjb25zdCBWRVJURVhfU0hBREVSID0gJ3ZzJztcbmV4cG9ydCBjb25zdCBGUkFHTUVOVF9TSEFERVIgPSAnZnMnO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y29uc3RhbnRzLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///75682\n")},60827:function(__unused_webpack_module,__webpack_exports__,__webpack_require__){eval("\n// EXPORTS\n__webpack_require__.d(__webpack_exports__, {\n  \"O_\": function() { return /* binding */ DECLARATION_INJECT_MARKER; },\n  \"Lm\": function() { return /* binding */ combineInjects; },\n  \"ZP\": function() { return /* binding */ injectShader; }\n});\n\n;// CONCATENATED MODULE: ./node_modules/@luma.gl/shadertools/dist/esm/modules/module-injectors.js\nconst MODULE_INJECTORS_VS = \"#ifdef MODULE_LOGDEPTH\\n  logdepth_adjustPosition(gl_Position);\\n#endif\\n\";\nconst MODULE_INJECTORS_FS = \"#ifdef MODULE_MATERIAL\\n  gl_FragColor = material_filterColor(gl_FragColor);\\n#endif\\n\\n#ifdef MODULE_LIGHTING\\n  gl_FragColor = lighting_filterColor(gl_FragColor);\\n#endif\\n\\n#ifdef MODULE_FOG\\n  gl_FragColor = fog_filterColor(gl_FragColor);\\n#endif\\n\\n#ifdef MODULE_PICKING\\n  gl_FragColor = picking_filterHighlightColor(gl_FragColor);\\n  gl_FragColor = picking_filterPickingColor(gl_FragColor);\\n#endif\\n\\n#ifdef MODULE_LOGDEPTH\\n  logdepth_setFragDepth();\\n#endif\\n\";\n//# sourceMappingURL=module-injectors.js.map\n// EXTERNAL MODULE: ./node_modules/@luma.gl/shadertools/dist/esm/lib/constants.js\nvar constants = __webpack_require__(75682);\n// EXTERNAL MODULE: ./node_modules/@luma.gl/shadertools/dist/esm/utils/assert.js\nvar assert = __webpack_require__(29047);\n;// CONCATENATED MODULE: ./node_modules/@luma.gl/shadertools/dist/esm/lib/inject-shader.js\n\n\n\nconst MODULE_INJECTORS = {\n  [constants/* VERTEX_SHADER */.H]: MODULE_INJECTORS_VS,\n  [constants/* FRAGMENT_SHADER */.Y]: MODULE_INJECTORS_FS\n};\nconst DECLARATION_INJECT_MARKER = '__LUMA_INJECT_DECLARATIONS__';\nconst REGEX_START_OF_MAIN = /void\\s+main\\s*\\([^)]*\\)\\s*\\{\\n?/;\nconst REGEX_END_OF_MAIN = /}\\n?[^{}]*$/;\nconst fragments = [];\nfunction injectShader(source, type, inject) {\n  let injectStandardStubs = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n  const isVertex = type === constants/* VERTEX_SHADER */.H;\n\n  for (const key in inject) {\n    const fragmentData = inject[key];\n    fragmentData.sort((a, b) => a.order - b.order);\n    fragments.length = fragmentData.length;\n\n    for (let i = 0, len = fragmentData.length; i < len; ++i) {\n      fragments[i] = fragmentData[i].injection;\n    }\n\n    const fragmentString = \"\".concat(fragments.join('\\n'), \"\\n\");\n\n    switch (key) {\n      case 'vs:#decl':\n        if (isVertex) {\n          source = source.replace(DECLARATION_INJECT_MARKER, fragmentString);\n        }\n\n        break;\n\n      case 'vs:#main-start':\n        if (isVertex) {\n          source = source.replace(REGEX_START_OF_MAIN, match => match + fragmentString);\n        }\n\n        break;\n\n      case 'vs:#main-end':\n        if (isVertex) {\n          source = source.replace(REGEX_END_OF_MAIN, match => fragmentString + match);\n        }\n\n        break;\n\n      case 'fs:#decl':\n        if (!isVertex) {\n          source = source.replace(DECLARATION_INJECT_MARKER, fragmentString);\n        }\n\n        break;\n\n      case 'fs:#main-start':\n        if (!isVertex) {\n          source = source.replace(REGEX_START_OF_MAIN, match => match + fragmentString);\n        }\n\n        break;\n\n      case 'fs:#main-end':\n        if (!isVertex) {\n          source = source.replace(REGEX_END_OF_MAIN, match => fragmentString + match);\n        }\n\n        break;\n\n      default:\n        source = source.replace(key, match => match + fragmentString);\n    }\n  }\n\n  source = source.replace(DECLARATION_INJECT_MARKER, '');\n\n  if (injectStandardStubs) {\n    source = source.replace(/\\}\\s*$/, match => match + MODULE_INJECTORS[type]);\n  }\n\n  return source;\n}\nfunction combineInjects(injects) {\n  const result = {};\n  (0,assert/* default */.Z)(Array.isArray(injects) && injects.length > 1);\n  injects.forEach(inject => {\n    for (const key in inject) {\n      result[key] = result[key] ? \"\".concat(result[key], \"\\n\").concat(inject[key]) : inject[key];\n    }\n  });\n  return result;\n}\n//# sourceMappingURL=inject-shader.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNjA4MjcuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBQU8sNEZBQTRGO0FBQzVGLHlHQUF5Ryx3RkFBd0YsOEVBQThFLCtGQUErRiw0REFBNEQsOERBQThEO0FBQy9lLDRDOzs7Ozs7QUNGdUY7QUFDMUI7QUFDM0I7QUFDbEM7QUFDQSxHQUFHLDhCQUFhLEdBQUcsbUJBQW1CO0FBQ3RDLEdBQUcsZ0NBQWUsR0FBRyxtQkFBbUI7QUFDeEM7QUFDTztBQUNQLHlEQUF5RDtBQUN6RCw0QkFBNEIsT0FBTztBQUNuQztBQUNlO0FBQ2Y7QUFDQSw0QkFBNEIsOEJBQWE7O0FBRXpDO0FBQ0E7QUFDQTtBQUNBOztBQUVBLCtDQUErQyxTQUFTO0FBQ3hEO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLCtCQUErQjtBQUMvQjs7QUFFQTtBQUNBO0FBQ087QUFDUDtBQUNBLEVBQUUseUJBQU07QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly92dWUzLXdlYnBhY2s1Ly4vbm9kZV9tb2R1bGVzL0BsdW1hLmdsL3NoYWRlcnRvb2xzL2Rpc3QvZXNtL21vZHVsZXMvbW9kdWxlLWluamVjdG9ycy5qcz8yMjg1Iiwid2VicGFjazovL3Z1ZTMtd2VicGFjazUvLi9ub2RlX21vZHVsZXMvQGx1bWEuZ2wvc2hhZGVydG9vbHMvZGlzdC9lc20vbGliL2luamVjdC1zaGFkZXIuanM/NGNmOSJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgY29uc3QgTU9EVUxFX0lOSkVDVE9SU19WUyA9IFwiI2lmZGVmIE1PRFVMRV9MT0dERVBUSFxcbiAgbG9nZGVwdGhfYWRqdXN0UG9zaXRpb24oZ2xfUG9zaXRpb24pO1xcbiNlbmRpZlxcblwiO1xuZXhwb3J0IGNvbnN0IE1PRFVMRV9JTkpFQ1RPUlNfRlMgPSBcIiNpZmRlZiBNT0RVTEVfTUFURVJJQUxcXG4gIGdsX0ZyYWdDb2xvciA9IG1hdGVyaWFsX2ZpbHRlckNvbG9yKGdsX0ZyYWdDb2xvcik7XFxuI2VuZGlmXFxuXFxuI2lmZGVmIE1PRFVMRV9MSUdIVElOR1xcbiAgZ2xfRnJhZ0NvbG9yID0gbGlnaHRpbmdfZmlsdGVyQ29sb3IoZ2xfRnJhZ0NvbG9yKTtcXG4jZW5kaWZcXG5cXG4jaWZkZWYgTU9EVUxFX0ZPR1xcbiAgZ2xfRnJhZ0NvbG9yID0gZm9nX2ZpbHRlckNvbG9yKGdsX0ZyYWdDb2xvcik7XFxuI2VuZGlmXFxuXFxuI2lmZGVmIE1PRFVMRV9QSUNLSU5HXFxuICBnbF9GcmFnQ29sb3IgPSBwaWNraW5nX2ZpbHRlckhpZ2hsaWdodENvbG9yKGdsX0ZyYWdDb2xvcik7XFxuICBnbF9GcmFnQ29sb3IgPSBwaWNraW5nX2ZpbHRlclBpY2tpbmdDb2xvcihnbF9GcmFnQ29sb3IpO1xcbiNlbmRpZlxcblxcbiNpZmRlZiBNT0RVTEVfTE9HREVQVEhcXG4gIGxvZ2RlcHRoX3NldEZyYWdEZXB0aCgpO1xcbiNlbmRpZlxcblwiO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bW9kdWxlLWluamVjdG9ycy5qcy5tYXAiLCJpbXBvcnQgeyBNT0RVTEVfSU5KRUNUT1JTX1ZTLCBNT0RVTEVfSU5KRUNUT1JTX0ZTIH0gZnJvbSAnLi4vbW9kdWxlcy9tb2R1bGUtaW5qZWN0b3JzJztcbmltcG9ydCB7IFZFUlRFWF9TSEFERVIsIEZSQUdNRU5UX1NIQURFUiB9IGZyb20gJy4vY29uc3RhbnRzJztcbmltcG9ydCB7IGFzc2VydCB9IGZyb20gJy4uL3V0aWxzJztcbmNvbnN0IE1PRFVMRV9JTkpFQ1RPUlMgPSB7XG4gIFtWRVJURVhfU0hBREVSXTogTU9EVUxFX0lOSkVDVE9SU19WUyxcbiAgW0ZSQUdNRU5UX1NIQURFUl06IE1PRFVMRV9JTkpFQ1RPUlNfRlNcbn07XG5leHBvcnQgY29uc3QgREVDTEFSQVRJT05fSU5KRUNUX01BUktFUiA9ICdfX0xVTUFfSU5KRUNUX0RFQ0xBUkFUSU9OU19fJztcbmNvbnN0IFJFR0VYX1NUQVJUX09GX01BSU4gPSAvdm9pZFxccyttYWluXFxzKlxcKFteKV0qXFwpXFxzKlxce1xcbj8vO1xuY29uc3QgUkVHRVhfRU5EX09GX01BSU4gPSAvfVxcbj9bXnt9XSokLztcbmNvbnN0IGZyYWdtZW50cyA9IFtdO1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gaW5qZWN0U2hhZGVyKHNvdXJjZSwgdHlwZSwgaW5qZWN0KSB7XG4gIGxldCBpbmplY3RTdGFuZGFyZFN0dWJzID0gYXJndW1lbnRzLmxlbmd0aCA+IDMgJiYgYXJndW1lbnRzWzNdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbM10gOiBmYWxzZTtcbiAgY29uc3QgaXNWZXJ0ZXggPSB0eXBlID09PSBWRVJURVhfU0hBREVSO1xuXG4gIGZvciAoY29uc3Qga2V5IGluIGluamVjdCkge1xuICAgIGNvbnN0IGZyYWdtZW50RGF0YSA9IGluamVjdFtrZXldO1xuICAgIGZyYWdtZW50RGF0YS5zb3J0KChhLCBiKSA9PiBhLm9yZGVyIC0gYi5vcmRlcik7XG4gICAgZnJhZ21lbnRzLmxlbmd0aCA9IGZyYWdtZW50RGF0YS5sZW5ndGg7XG5cbiAgICBmb3IgKGxldCBpID0gMCwgbGVuID0gZnJhZ21lbnREYXRhLmxlbmd0aDsgaSA8IGxlbjsgKytpKSB7XG4gICAgICBmcmFnbWVudHNbaV0gPSBmcmFnbWVudERhdGFbaV0uaW5qZWN0aW9uO1xuICAgIH1cblxuICAgIGNvbnN0IGZyYWdtZW50U3RyaW5nID0gXCJcIi5jb25jYXQoZnJhZ21lbnRzLmpvaW4oJ1xcbicpLCBcIlxcblwiKTtcblxuICAgIHN3aXRjaCAoa2V5KSB7XG4gICAgICBjYXNlICd2czojZGVjbCc6XG4gICAgICAgIGlmIChpc1ZlcnRleCkge1xuICAgICAgICAgIHNvdXJjZSA9IHNvdXJjZS5yZXBsYWNlKERFQ0xBUkFUSU9OX0lOSkVDVF9NQVJLRVIsIGZyYWdtZW50U3RyaW5nKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlICd2czojbWFpbi1zdGFydCc6XG4gICAgICAgIGlmIChpc1ZlcnRleCkge1xuICAgICAgICAgIHNvdXJjZSA9IHNvdXJjZS5yZXBsYWNlKFJFR0VYX1NUQVJUX09GX01BSU4sIG1hdGNoID0+IG1hdGNoICsgZnJhZ21lbnRTdHJpbmcpO1xuICAgICAgICB9XG5cbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgJ3ZzOiNtYWluLWVuZCc6XG4gICAgICAgIGlmIChpc1ZlcnRleCkge1xuICAgICAgICAgIHNvdXJjZSA9IHNvdXJjZS5yZXBsYWNlKFJFR0VYX0VORF9PRl9NQUlOLCBtYXRjaCA9PiBmcmFnbWVudFN0cmluZyArIG1hdGNoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlICdmczojZGVjbCc6XG4gICAgICAgIGlmICghaXNWZXJ0ZXgpIHtcbiAgICAgICAgICBzb3VyY2UgPSBzb3VyY2UucmVwbGFjZShERUNMQVJBVElPTl9JTkpFQ1RfTUFSS0VSLCBmcmFnbWVudFN0cmluZyk7XG4gICAgICAgIH1cblxuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSAnZnM6I21haW4tc3RhcnQnOlxuICAgICAgICBpZiAoIWlzVmVydGV4KSB7XG4gICAgICAgICAgc291cmNlID0gc291cmNlLnJlcGxhY2UoUkVHRVhfU1RBUlRfT0ZfTUFJTiwgbWF0Y2ggPT4gbWF0Y2ggKyBmcmFnbWVudFN0cmluZyk7XG4gICAgICAgIH1cblxuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSAnZnM6I21haW4tZW5kJzpcbiAgICAgICAgaWYgKCFpc1ZlcnRleCkge1xuICAgICAgICAgIHNvdXJjZSA9IHNvdXJjZS5yZXBsYWNlKFJFR0VYX0VORF9PRl9NQUlOLCBtYXRjaCA9PiBmcmFnbWVudFN0cmluZyArIG1hdGNoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICBzb3VyY2UgPSBzb3VyY2UucmVwbGFjZShrZXksIG1hdGNoID0+IG1hdGNoICsgZnJhZ21lbnRTdHJpbmcpO1xuICAgIH1cbiAgfVxuXG4gIHNvdXJjZSA9IHNvdXJjZS5yZXBsYWNlKERFQ0xBUkFUSU9OX0lOSkVDVF9NQVJLRVIsICcnKTtcblxuICBpZiAoaW5qZWN0U3RhbmRhcmRTdHVicykge1xuICAgIHNvdXJjZSA9IHNvdXJjZS5yZXBsYWNlKC9cXH1cXHMqJC8sIG1hdGNoID0+IG1hdGNoICsgTU9EVUxFX0lOSkVDVE9SU1t0eXBlXSk7XG4gIH1cblxuICByZXR1cm4gc291cmNlO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGNvbWJpbmVJbmplY3RzKGluamVjdHMpIHtcbiAgY29uc3QgcmVzdWx0ID0ge307XG4gIGFzc2VydChBcnJheS5pc0FycmF5KGluamVjdHMpICYmIGluamVjdHMubGVuZ3RoID4gMSk7XG4gIGluamVjdHMuZm9yRWFjaChpbmplY3QgPT4ge1xuICAgIGZvciAoY29uc3Qga2V5IGluIGluamVjdCkge1xuICAgICAgcmVzdWx0W2tleV0gPSByZXN1bHRba2V5XSA/IFwiXCIuY29uY2F0KHJlc3VsdFtrZXldLCBcIlxcblwiKS5jb25jYXQoaW5qZWN0W2tleV0pIDogaW5qZWN0W2tleV07XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluamVjdC1zaGFkZXIuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///60827\n")},25502:function(__unused_webpack_module,__webpack_exports__,__webpack_require__){eval('/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "O": function() { return /* binding */ fp32; }\n/* harmony export */ });\nconst fp32shader = "#ifdef LUMA_FP32_TAN_PRECISION_WORKAROUND\\nconst float TWO_PI = 6.2831854820251465;\\nconst float PI_2 = 1.5707963705062866;\\nconst float PI_16 = 0.1963495463132858;\\n\\nconst float SIN_TABLE_0 = 0.19509032368659973;\\nconst float SIN_TABLE_1 = 0.3826834261417389;\\nconst float SIN_TABLE_2 = 0.5555702447891235;\\nconst float SIN_TABLE_3 = 0.7071067690849304;\\n\\nconst float COS_TABLE_0 = 0.9807852506637573;\\nconst float COS_TABLE_1 = 0.9238795042037964;\\nconst float COS_TABLE_2 = 0.8314695954322815;\\nconst float COS_TABLE_3 = 0.7071067690849304;\\n\\nconst float INVERSE_FACTORIAL_3 = 1.666666716337204e-01;\\nconst float INVERSE_FACTORIAL_5 = 8.333333767950535e-03;\\nconst float INVERSE_FACTORIAL_7 = 1.9841270113829523e-04;\\nconst float INVERSE_FACTORIAL_9 = 2.75573188446287533e-06;\\n\\nfloat sin_taylor_fp32(float a) {\\n  float r, s, t, x;\\n\\n  if (a == 0.0) {\\n    return 0.0;\\n  }\\n\\n  x = -a * a;\\n  s = a;\\n  r = a;\\n\\n  r = r * x;\\n  t = r * INVERSE_FACTORIAL_3;\\n  s = s + t;\\n\\n  r = r * x;\\n  t = r * INVERSE_FACTORIAL_5;\\n  s = s + t;\\n\\n  r = r * x;\\n  t = r * INVERSE_FACTORIAL_7;\\n  s = s + t;\\n\\n  r = r * x;\\n  t = r * INVERSE_FACTORIAL_9;\\n  s = s + t;\\n\\n  return s;\\n}\\n\\nvoid sincos_taylor_fp32(float a, out float sin_t, out float cos_t) {\\n  if (a == 0.0) {\\n    sin_t = 0.0;\\n    cos_t = 1.0;\\n  }\\n  sin_t = sin_taylor_fp32(a);\\n  cos_t = sqrt(1.0 - sin_t * sin_t);\\n}\\n\\nfloat tan_taylor_fp32(float a) {\\n    float sin_a;\\n    float cos_a;\\n\\n    if (a == 0.0) {\\n        return 0.0;\\n    }\\n    float z = floor(a / TWO_PI);\\n    float r = a - TWO_PI * z;\\n\\n    float t;\\n    float q = floor(r / PI_2 + 0.5);\\n    int j = int(q);\\n\\n    if (j < -2 || j > 2) {\\n        return 1.0 / 0.0;\\n    }\\n\\n    t = r - PI_2 * q;\\n\\n    q = floor(t / PI_16 + 0.5);\\n    int k = int(q);\\n    int abs_k = int(abs(float(k)));\\n\\n    if (abs_k > 4) {\\n        return 1.0 / 0.0;\\n    } else {\\n        t = t - PI_16 * q;\\n    }\\n\\n    float u = 0.0;\\n    float v = 0.0;\\n\\n    float sin_t, cos_t;\\n    float s, c;\\n    sincos_taylor_fp32(t, sin_t, cos_t);\\n\\n    if (k == 0) {\\n        s = sin_t;\\n        c = cos_t;\\n    } else {\\n        if (abs(float(abs_k) - 1.0) < 0.5) {\\n            u = COS_TABLE_0;\\n            v = SIN_TABLE_0;\\n        } else if (abs(float(abs_k) - 2.0) < 0.5) {\\n            u = COS_TABLE_1;\\n            v = SIN_TABLE_1;\\n        } else if (abs(float(abs_k) - 3.0) < 0.5) {\\n            u = COS_TABLE_2;\\n            v = SIN_TABLE_2;\\n        } else if (abs(float(abs_k) - 4.0) < 0.5) {\\n            u = COS_TABLE_3;\\n            v = SIN_TABLE_3;\\n        }\\n        if (k > 0) {\\n            s = u * sin_t + v * cos_t;\\n            c = u * cos_t - v * sin_t;\\n        } else {\\n            s = u * sin_t - v * cos_t;\\n            c = u * cos_t + v * sin_t;\\n        }\\n    }\\n\\n    if (j == 0) {\\n        sin_a = s;\\n        cos_a = c;\\n    } else if (j == 1) {\\n        sin_a = c;\\n        cos_a = -s;\\n    } else if (j == -1) {\\n        sin_a = -c;\\n        cos_a = s;\\n    } else {\\n        sin_a = -s;\\n        cos_a = -c;\\n    }\\n    return sin_a / cos_a;\\n}\\n#endif\\n\\nfloat tan_fp32(float a) {\\n#ifdef LUMA_FP32_TAN_PRECISION_WORKAROUND\\n  return tan_taylor_fp32(a);\\n#else\\n  return tan(a);\\n#endif\\n}\\n";\nconst fp32 = {\n  name: \'fp32\',\n  vs: fp32shader,\n  fs: null\n};\n//# sourceMappingURL=fp32.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjU1MDIuanMiLCJtYXBwaW5ncyI6Ijs7O0FBQUEsdUdBQXVHLHdDQUF3Qyx5Q0FBeUMsa0RBQWtELCtDQUErQywrQ0FBK0MsK0NBQStDLGlEQUFpRCwrQ0FBK0MsK0NBQStDLCtDQUErQyw0REFBNEQsMERBQTBELDJEQUEyRCw0REFBNEQsb0NBQW9DLHFCQUFxQixxQkFBcUIsaUJBQWlCLEtBQUssaUJBQWlCLFVBQVUsVUFBVSxnQkFBZ0IsZ0NBQWdDLGNBQWMsZ0JBQWdCLGdDQUFnQyxjQUFjLGdCQUFnQixnQ0FBZ0MsY0FBYyxnQkFBZ0IsZ0NBQWdDLGNBQWMsZUFBZSxHQUFHLHdFQUF3RSxtQkFBbUIsa0JBQWtCLGtCQUFrQixLQUFLLCtCQUErQixzQ0FBc0MsR0FBRyxvQ0FBb0Msa0JBQWtCLGtCQUFrQix1QkFBdUIscUJBQXFCLE9BQU8sa0NBQWtDLCtCQUErQixnQkFBZ0Isc0NBQXNDLHFCQUFxQiw4QkFBOEIsMkJBQTJCLE9BQU8seUJBQXlCLG1DQUFtQyxxQkFBcUIscUNBQXFDLHdCQUF3QiwyQkFBMkIsUUFBUSxNQUFNLDRCQUE0QixPQUFPLHNCQUFzQixvQkFBb0IsMkJBQTJCLGlCQUFpQiwwQ0FBMEMscUJBQXFCLG9CQUFvQixvQkFBb0IsUUFBUSxNQUFNLDhDQUE4Qyw4QkFBOEIsOEJBQThCLFlBQVkseUNBQXlDLDhCQUE4Qiw4QkFBOEIsWUFBWSx5Q0FBeUMsOEJBQThCLDhCQUE4QixZQUFZLHlDQUF5Qyw4QkFBOEIsOEJBQThCLFdBQVcsc0JBQXNCLHdDQUF3Qyx3Q0FBd0MsWUFBWSxNQUFNLHdDQUF3Qyx3Q0FBd0MsV0FBVyxPQUFPLHFCQUFxQixvQkFBb0Isb0JBQW9CLFFBQVEsa0JBQWtCLG9CQUFvQixxQkFBcUIsUUFBUSxtQkFBbUIscUJBQXFCLG9CQUFvQixRQUFRLE1BQU0scUJBQXFCLHFCQUFxQixPQUFPLDJCQUEyQixHQUFHLHFDQUFxQyx5RUFBeUUseUJBQXlCLFdBQVc7QUFDM3JHO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3Z1ZTMtd2VicGFjazUvLi9ub2RlX21vZHVsZXMvQGx1bWEuZ2wvc2hhZGVydG9vbHMvZGlzdC9lc20vbW9kdWxlcy9mcDMyL2ZwMzIuanM/N2IzMiJdLCJzb3VyY2VzQ29udGVudCI6WyJjb25zdCBmcDMyc2hhZGVyID0gXCIjaWZkZWYgTFVNQV9GUDMyX1RBTl9QUkVDSVNJT05fV09SS0FST1VORFxcbmNvbnN0IGZsb2F0IFRXT19QSSA9IDYuMjgzMTg1NDgyMDI1MTQ2NTtcXG5jb25zdCBmbG9hdCBQSV8yID0gMS41NzA3OTYzNzA1MDYyODY2O1xcbmNvbnN0IGZsb2F0IFBJXzE2ID0gMC4xOTYzNDk1NDYzMTMyODU4O1xcblxcbmNvbnN0IGZsb2F0IFNJTl9UQUJMRV8wID0gMC4xOTUwOTAzMjM2ODY1OTk3MztcXG5jb25zdCBmbG9hdCBTSU5fVEFCTEVfMSA9IDAuMzgyNjgzNDI2MTQxNzM4OTtcXG5jb25zdCBmbG9hdCBTSU5fVEFCTEVfMiA9IDAuNTU1NTcwMjQ0Nzg5MTIzNTtcXG5jb25zdCBmbG9hdCBTSU5fVEFCTEVfMyA9IDAuNzA3MTA2NzY5MDg0OTMwNDtcXG5cXG5jb25zdCBmbG9hdCBDT1NfVEFCTEVfMCA9IDAuOTgwNzg1MjUwNjYzNzU3MztcXG5jb25zdCBmbG9hdCBDT1NfVEFCTEVfMSA9IDAuOTIzODc5NTA0MjAzNzk2NDtcXG5jb25zdCBmbG9hdCBDT1NfVEFCTEVfMiA9IDAuODMxNDY5NTk1NDMyMjgxNTtcXG5jb25zdCBmbG9hdCBDT1NfVEFCTEVfMyA9IDAuNzA3MTA2NzY5MDg0OTMwNDtcXG5cXG5jb25zdCBmbG9hdCBJTlZFUlNFX0ZBQ1RPUklBTF8zID0gMS42NjY2NjY3MTYzMzcyMDRlLTAxO1xcbmNvbnN0IGZsb2F0IElOVkVSU0VfRkFDVE9SSUFMXzUgPSA4LjMzMzMzMzc2Nzk1MDUzNWUtMDM7XFxuY29uc3QgZmxvYXQgSU5WRVJTRV9GQUNUT1JJQUxfNyA9IDEuOTg0MTI3MDExMzgyOTUyM2UtMDQ7XFxuY29uc3QgZmxvYXQgSU5WRVJTRV9GQUNUT1JJQUxfOSA9IDIuNzU1NzMxODg0NDYyODc1MzNlLTA2O1xcblxcbmZsb2F0IHNpbl90YXlsb3JfZnAzMihmbG9hdCBhKSB7XFxuICBmbG9hdCByLCBzLCB0LCB4O1xcblxcbiAgaWYgKGEgPT0gMC4wKSB7XFxuICAgIHJldHVybiAwLjA7XFxuICB9XFxuXFxuICB4ID0gLWEgKiBhO1xcbiAgcyA9IGE7XFxuICByID0gYTtcXG5cXG4gIHIgPSByICogeDtcXG4gIHQgPSByICogSU5WRVJTRV9GQUNUT1JJQUxfMztcXG4gIHMgPSBzICsgdDtcXG5cXG4gIHIgPSByICogeDtcXG4gIHQgPSByICogSU5WRVJTRV9GQUNUT1JJQUxfNTtcXG4gIHMgPSBzICsgdDtcXG5cXG4gIHIgPSByICogeDtcXG4gIHQgPSByICogSU5WRVJTRV9GQUNUT1JJQUxfNztcXG4gIHMgPSBzICsgdDtcXG5cXG4gIHIgPSByICogeDtcXG4gIHQgPSByICogSU5WRVJTRV9GQUNUT1JJQUxfOTtcXG4gIHMgPSBzICsgdDtcXG5cXG4gIHJldHVybiBzO1xcbn1cXG5cXG52b2lkIHNpbmNvc190YXlsb3JfZnAzMihmbG9hdCBhLCBvdXQgZmxvYXQgc2luX3QsIG91dCBmbG9hdCBjb3NfdCkge1xcbiAgaWYgKGEgPT0gMC4wKSB7XFxuICAgIHNpbl90ID0gMC4wO1xcbiAgICBjb3NfdCA9IDEuMDtcXG4gIH1cXG4gIHNpbl90ID0gc2luX3RheWxvcl9mcDMyKGEpO1xcbiAgY29zX3QgPSBzcXJ0KDEuMCAtIHNpbl90ICogc2luX3QpO1xcbn1cXG5cXG5mbG9hdCB0YW5fdGF5bG9yX2ZwMzIoZmxvYXQgYSkge1xcbiAgICBmbG9hdCBzaW5fYTtcXG4gICAgZmxvYXQgY29zX2E7XFxuXFxuICAgIGlmIChhID09IDAuMCkge1xcbiAgICAgICAgcmV0dXJuIDAuMDtcXG4gICAgfVxcbiAgICBmbG9hdCB6ID0gZmxvb3IoYSAvIFRXT19QSSk7XFxuICAgIGZsb2F0IHIgPSBhIC0gVFdPX1BJICogejtcXG5cXG4gICAgZmxvYXQgdDtcXG4gICAgZmxvYXQgcSA9IGZsb29yKHIgLyBQSV8yICsgMC41KTtcXG4gICAgaW50IGogPSBpbnQocSk7XFxuXFxuICAgIGlmIChqIDwgLTIgfHwgaiA+IDIpIHtcXG4gICAgICAgIHJldHVybiAxLjAgLyAwLjA7XFxuICAgIH1cXG5cXG4gICAgdCA9IHIgLSBQSV8yICogcTtcXG5cXG4gICAgcSA9IGZsb29yKHQgLyBQSV8xNiArIDAuNSk7XFxuICAgIGludCBrID0gaW50KHEpO1xcbiAgICBpbnQgYWJzX2sgPSBpbnQoYWJzKGZsb2F0KGspKSk7XFxuXFxuICAgIGlmIChhYnNfayA+IDQpIHtcXG4gICAgICAgIHJldHVybiAxLjAgLyAwLjA7XFxuICAgIH0gZWxzZSB7XFxuICAgICAgICB0ID0gdCAtIFBJXzE2ICogcTtcXG4gICAgfVxcblxcbiAgICBmbG9hdCB1ID0gMC4wO1xcbiAgICBmbG9hdCB2ID0gMC4wO1xcblxcbiAgICBmbG9hdCBzaW5fdCwgY29zX3Q7XFxuICAgIGZsb2F0IHMsIGM7XFxuICAgIHNpbmNvc190YXlsb3JfZnAzMih0LCBzaW5fdCwgY29zX3QpO1xcblxcbiAgICBpZiAoayA9PSAwKSB7XFxuICAgICAgICBzID0gc2luX3Q7XFxuICAgICAgICBjID0gY29zX3Q7XFxuICAgIH0gZWxzZSB7XFxuICAgICAgICBpZiAoYWJzKGZsb2F0KGFic19rKSAtIDEuMCkgPCAwLjUpIHtcXG4gICAgICAgICAgICB1ID0gQ09TX1RBQkxFXzA7XFxuICAgICAgICAgICAgdiA9IFNJTl9UQUJMRV8wO1xcbiAgICAgICAgfSBlbHNlIGlmIChhYnMoZmxvYXQoYWJzX2spIC0gMi4wKSA8IDAuNSkge1xcbiAgICAgICAgICAgIHUgPSBDT1NfVEFCTEVfMTtcXG4gICAgICAgICAgICB2ID0gU0lOX1RBQkxFXzE7XFxuICAgICAgICB9IGVsc2UgaWYgKGFicyhmbG9hdChhYnNfaykgLSAzLjApIDwgMC41KSB7XFxuICAgICAgICAgICAgdSA9IENPU19UQUJMRV8yO1xcbiAgICAgICAgICAgIHYgPSBTSU5fVEFCTEVfMjtcXG4gICAgICAgIH0gZWxzZSBpZiAoYWJzKGZsb2F0KGFic19rKSAtIDQuMCkgPCAwLjUpIHtcXG4gICAgICAgICAgICB1ID0gQ09TX1RBQkxFXzM7XFxuICAgICAgICAgICAgdiA9IFNJTl9UQUJMRV8zO1xcbiAgICAgICAgfVxcbiAgICAgICAgaWYgKGsgPiAwKSB7XFxuICAgICAgICAgICAgcyA9IHUgKiBzaW5fdCArIHYgKiBjb3NfdDtcXG4gICAgICAgICAgICBjID0gdSAqIGNvc190IC0gdiAqIHNpbl90O1xcbiAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgICBzID0gdSAqIHNpbl90IC0gdiAqIGNvc190O1xcbiAgICAgICAgICAgIGMgPSB1ICogY29zX3QgKyB2ICogc2luX3Q7XFxuICAgICAgICB9XFxuICAgIH1cXG5cXG4gICAgaWYgKGogPT0gMCkge1xcbiAgICAgICAgc2luX2EgPSBzO1xcbiAgICAgICAgY29zX2EgPSBjO1xcbiAgICB9IGVsc2UgaWYgKGogPT0gMSkge1xcbiAgICAgICAgc2luX2EgPSBjO1xcbiAgICAgICAgY29zX2EgPSAtcztcXG4gICAgfSBlbHNlIGlmIChqID09IC0xKSB7XFxuICAgICAgICBzaW5fYSA9IC1jO1xcbiAgICAgICAgY29zX2EgPSBzO1xcbiAgICB9IGVsc2Uge1xcbiAgICAgICAgc2luX2EgPSAtcztcXG4gICAgICAgIGNvc19hID0gLWM7XFxuICAgIH1cXG4gICAgcmV0dXJuIHNpbl9hIC8gY29zX2E7XFxufVxcbiNlbmRpZlxcblxcbmZsb2F0IHRhbl9mcDMyKGZsb2F0IGEpIHtcXG4jaWZkZWYgTFVNQV9GUDMyX1RBTl9QUkVDSVNJT05fV09SS0FST1VORFxcbiAgcmV0dXJuIHRhbl90YXlsb3JfZnAzMihhKTtcXG4jZWxzZVxcbiAgcmV0dXJuIHRhbihhKTtcXG4jZW5kaWZcXG59XFxuXCI7XG5leHBvcnQgY29uc3QgZnAzMiA9IHtcbiAgbmFtZTogJ2ZwMzInLFxuICB2czogZnAzMnNoYWRlcixcbiAgZnM6IG51bGxcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1mcDMyLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///25502\n')},66931:function(__unused_webpack_module,__webpack_exports__,__webpack_require__){eval('\n// EXPORTS\n__webpack_require__.d(__webpack_exports__, {\n  "H": function() { return /* binding */ lights; }\n});\n\n;// CONCATENATED MODULE: ./node_modules/@luma.gl/shadertools/dist/esm/modules/lights/lights.glsl.js\n/* harmony default export */ var lights_glsl = ("#if (defined(SHADER_TYPE_FRAGMENT) && defined(LIGHTING_FRAGMENT)) || (defined(SHADER_TYPE_VERTEX) && defined(LIGHTING_VERTEX))\\n\\nstruct AmbientLight {\\n vec3 color;\\n};\\n\\nstruct PointLight {\\n vec3 color;\\n vec3 position;\\n vec3 attenuation;\\n};\\n\\nstruct DirectionalLight {\\n  vec3 color;\\n  vec3 direction;\\n};\\n\\nuniform AmbientLight lighting_uAmbientLight;\\nuniform PointLight lighting_uPointLight[MAX_LIGHTS];\\nuniform DirectionalLight lighting_uDirectionalLight[MAX_LIGHTS];\\nuniform int lighting_uPointLightCount;\\nuniform int lighting_uDirectionalLightCount;\\n\\nuniform bool lighting_uEnabled;\\n\\nfloat getPointLightAttenuation(PointLight pointLight, float distance) {\\n  return pointLight.attenuation.x\\n       + pointLight.attenuation.y * distance\\n       + pointLight.attenuation.z * distance * distance;\\n}\\n\\n#endif\\n");\n//# sourceMappingURL=lights.glsl.js.map\n;// CONCATENATED MODULE: ./node_modules/@luma.gl/shadertools/dist/esm/modules/lights/lights.js\n\nconst INITIAL_MODULE_OPTIONS = {\n  lightSources: {}\n};\n\nfunction convertColor() {\n  let {\n    color = [0, 0, 0],\n    intensity = 1.0\n  } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  return color.map(component => component * intensity / 255.0);\n}\n\nfunction getLightSourceUniforms(_ref) {\n  let {\n    ambientLight,\n    pointLights = [],\n    directionalLights = []\n  } = _ref;\n  const lightSourceUniforms = {};\n\n  if (ambientLight) {\n    lightSourceUniforms[\'lighting_uAmbientLight.color\'] = convertColor(ambientLight);\n  } else {\n    lightSourceUniforms[\'lighting_uAmbientLight.color\'] = [0, 0, 0];\n  }\n\n  pointLights.forEach((pointLight, index) => {\n    lightSourceUniforms["lighting_uPointLight[".concat(index, "].color")] = convertColor(pointLight);\n    lightSourceUniforms["lighting_uPointLight[".concat(index, "].position")] = pointLight.position;\n    lightSourceUniforms["lighting_uPointLight[".concat(index, "].attenuation")] = pointLight.attenuation || [1, 0, 0];\n  });\n  lightSourceUniforms.lighting_uPointLightCount = pointLights.length;\n  directionalLights.forEach((directionalLight, index) => {\n    lightSourceUniforms["lighting_uDirectionalLight[".concat(index, "].color")] = convertColor(directionalLight);\n    lightSourceUniforms["lighting_uDirectionalLight[".concat(index, "].direction")] = directionalLight.direction;\n  });\n  lightSourceUniforms.lighting_uDirectionalLightCount = directionalLights.length;\n  return lightSourceUniforms;\n}\n\nfunction getUniforms() {\n  let opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : INITIAL_MODULE_OPTIONS;\n\n  if (\'lightSources\' in opts) {\n    const {\n      ambientLight,\n      pointLights,\n      directionalLights\n    } = opts.lightSources || {};\n    const hasLights = ambientLight || pointLights && pointLights.length > 0 || directionalLights && directionalLights.length > 0;\n\n    if (!hasLights) {\n      return {\n        lighting_uEnabled: false\n      };\n    }\n\n    return Object.assign({}, getLightSourceUniforms({\n      ambientLight,\n      pointLights,\n      directionalLights\n    }), {\n      lighting_uEnabled: true\n    });\n  }\n\n  if (\'lights\' in opts) {\n    const lightSources = {\n      pointLights: [],\n      directionalLights: []\n    };\n\n    for (const light of opts.lights || []) {\n      switch (light.type) {\n        case \'ambient\':\n          lightSources.ambientLight = light;\n          break;\n\n        case \'directional\':\n          lightSources.directionalLights.push(light);\n          break;\n\n        case \'point\':\n          lightSources.pointLights.push(light);\n          break;\n\n        default:\n      }\n    }\n\n    return getUniforms({\n      lightSources\n    });\n  }\n\n  return {};\n}\n\nconst lights = {\n  name: \'lights\',\n  vs: lights_glsl,\n  fs: lights_glsl,\n  getUniforms,\n  defines: {\n    MAX_LIGHTS: 3\n  }\n};\n//# sourceMappingURL=lights.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNjY5MzEuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUFBLGdEQUFlLHdKQUF3SixjQUFjLElBQUksdUJBQXVCLGNBQWMsaUJBQWlCLG9CQUFvQixJQUFJLDZCQUE2QixlQUFlLG1CQUFtQixJQUFJLGdEQUFnRCxzREFBc0Qsa0VBQWtFLHdDQUF3Qyw4Q0FBOEMsbUNBQW1DLDJFQUEyRSwySUFBMkksR0FBRyxhQUFhLEVBQUM7QUFDbDFCLHVDOztBQ0QyQztBQUMzQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKOztBQUVBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBOztBQUVPO0FBQ1A7QUFDQSxNQUFNLFdBQWM7QUFDcEIsTUFBTSxXQUFjO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3Z1ZTMtd2VicGFjazUvLi9ub2RlX21vZHVsZXMvQGx1bWEuZ2wvc2hhZGVydG9vbHMvZGlzdC9lc20vbW9kdWxlcy9saWdodHMvbGlnaHRzLmdsc2wuanM/ZTJiNCIsIndlYnBhY2s6Ly92dWUzLXdlYnBhY2s1Ly4vbm9kZV9tb2R1bGVzL0BsdW1hLmdsL3NoYWRlcnRvb2xzL2Rpc3QvZXNtL21vZHVsZXMvbGlnaHRzL2xpZ2h0cy5qcz82Mjk1Il0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCBkZWZhdWx0IFwiI2lmIChkZWZpbmVkKFNIQURFUl9UWVBFX0ZSQUdNRU5UKSAmJiBkZWZpbmVkKExJR0hUSU5HX0ZSQUdNRU5UKSkgfHwgKGRlZmluZWQoU0hBREVSX1RZUEVfVkVSVEVYKSAmJiBkZWZpbmVkKExJR0hUSU5HX1ZFUlRFWCkpXFxuXFxuc3RydWN0IEFtYmllbnRMaWdodCB7XFxuIHZlYzMgY29sb3I7XFxufTtcXG5cXG5zdHJ1Y3QgUG9pbnRMaWdodCB7XFxuIHZlYzMgY29sb3I7XFxuIHZlYzMgcG9zaXRpb247XFxuIHZlYzMgYXR0ZW51YXRpb247XFxufTtcXG5cXG5zdHJ1Y3QgRGlyZWN0aW9uYWxMaWdodCB7XFxuICB2ZWMzIGNvbG9yO1xcbiAgdmVjMyBkaXJlY3Rpb247XFxufTtcXG5cXG51bmlmb3JtIEFtYmllbnRMaWdodCBsaWdodGluZ191QW1iaWVudExpZ2h0O1xcbnVuaWZvcm0gUG9pbnRMaWdodCBsaWdodGluZ191UG9pbnRMaWdodFtNQVhfTElHSFRTXTtcXG51bmlmb3JtIERpcmVjdGlvbmFsTGlnaHQgbGlnaHRpbmdfdURpcmVjdGlvbmFsTGlnaHRbTUFYX0xJR0hUU107XFxudW5pZm9ybSBpbnQgbGlnaHRpbmdfdVBvaW50TGlnaHRDb3VudDtcXG51bmlmb3JtIGludCBsaWdodGluZ191RGlyZWN0aW9uYWxMaWdodENvdW50O1xcblxcbnVuaWZvcm0gYm9vbCBsaWdodGluZ191RW5hYmxlZDtcXG5cXG5mbG9hdCBnZXRQb2ludExpZ2h0QXR0ZW51YXRpb24oUG9pbnRMaWdodCBwb2ludExpZ2h0LCBmbG9hdCBkaXN0YW5jZSkge1xcbiAgcmV0dXJuIHBvaW50TGlnaHQuYXR0ZW51YXRpb24ueFxcbiAgICAgICArIHBvaW50TGlnaHQuYXR0ZW51YXRpb24ueSAqIGRpc3RhbmNlXFxuICAgICAgICsgcG9pbnRMaWdodC5hdHRlbnVhdGlvbi56ICogZGlzdGFuY2UgKiBkaXN0YW5jZTtcXG59XFxuXFxuI2VuZGlmXFxuXCI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1saWdodHMuZ2xzbC5qcy5tYXAiLCJpbXBvcnQgbGlnaHRpbmdTaGFkZXIgZnJvbSAnLi9saWdodHMuZ2xzbCc7XG5jb25zdCBJTklUSUFMX01PRFVMRV9PUFRJT05TID0ge1xuICBsaWdodFNvdXJjZXM6IHt9XG59O1xuXG5mdW5jdGlvbiBjb252ZXJ0Q29sb3IoKSB7XG4gIGxldCB7XG4gICAgY29sb3IgPSBbMCwgMCwgMF0sXG4gICAgaW50ZW5zaXR5ID0gMS4wXG4gIH0gPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHt9O1xuICByZXR1cm4gY29sb3IubWFwKGNvbXBvbmVudCA9PiBjb21wb25lbnQgKiBpbnRlbnNpdHkgLyAyNTUuMCk7XG59XG5cbmZ1bmN0aW9uIGdldExpZ2h0U291cmNlVW5pZm9ybXMoX3JlZikge1xuICBsZXQge1xuICAgIGFtYmllbnRMaWdodCxcbiAgICBwb2ludExpZ2h0cyA9IFtdLFxuICAgIGRpcmVjdGlvbmFsTGlnaHRzID0gW11cbiAgfSA9IF9yZWY7XG4gIGNvbnN0IGxpZ2h0U291cmNlVW5pZm9ybXMgPSB7fTtcblxuICBpZiAoYW1iaWVudExpZ2h0KSB7XG4gICAgbGlnaHRTb3VyY2VVbmlmb3Jtc1snbGlnaHRpbmdfdUFtYmllbnRMaWdodC5jb2xvciddID0gY29udmVydENvbG9yKGFtYmllbnRMaWdodCk7XG4gIH0gZWxzZSB7XG4gICAgbGlnaHRTb3VyY2VVbmlmb3Jtc1snbGlnaHRpbmdfdUFtYmllbnRMaWdodC5jb2xvciddID0gWzAsIDAsIDBdO1xuICB9XG5cbiAgcG9pbnRMaWdodHMuZm9yRWFjaCgocG9pbnRMaWdodCwgaW5kZXgpID0+IHtcbiAgICBsaWdodFNvdXJjZVVuaWZvcm1zW1wibGlnaHRpbmdfdVBvaW50TGlnaHRbXCIuY29uY2F0KGluZGV4LCBcIl0uY29sb3JcIildID0gY29udmVydENvbG9yKHBvaW50TGlnaHQpO1xuICAgIGxpZ2h0U291cmNlVW5pZm9ybXNbXCJsaWdodGluZ191UG9pbnRMaWdodFtcIi5jb25jYXQoaW5kZXgsIFwiXS5wb3NpdGlvblwiKV0gPSBwb2ludExpZ2h0LnBvc2l0aW9uO1xuICAgIGxpZ2h0U291cmNlVW5pZm9ybXNbXCJsaWdodGluZ191UG9pbnRMaWdodFtcIi5jb25jYXQoaW5kZXgsIFwiXS5hdHRlbnVhdGlvblwiKV0gPSBwb2ludExpZ2h0LmF0dGVudWF0aW9uIHx8IFsxLCAwLCAwXTtcbiAgfSk7XG4gIGxpZ2h0U291cmNlVW5pZm9ybXMubGlnaHRpbmdfdVBvaW50TGlnaHRDb3VudCA9IHBvaW50TGlnaHRzLmxlbmd0aDtcbiAgZGlyZWN0aW9uYWxMaWdodHMuZm9yRWFjaCgoZGlyZWN0aW9uYWxMaWdodCwgaW5kZXgpID0+IHtcbiAgICBsaWdodFNvdXJjZVVuaWZvcm1zW1wibGlnaHRpbmdfdURpcmVjdGlvbmFsTGlnaHRbXCIuY29uY2F0KGluZGV4LCBcIl0uY29sb3JcIildID0gY29udmVydENvbG9yKGRpcmVjdGlvbmFsTGlnaHQpO1xuICAgIGxpZ2h0U291cmNlVW5pZm9ybXNbXCJsaWdodGluZ191RGlyZWN0aW9uYWxMaWdodFtcIi5jb25jYXQoaW5kZXgsIFwiXS5kaXJlY3Rpb25cIildID0gZGlyZWN0aW9uYWxMaWdodC5kaXJlY3Rpb247XG4gIH0pO1xuICBsaWdodFNvdXJjZVVuaWZvcm1zLmxpZ2h0aW5nX3VEaXJlY3Rpb25hbExpZ2h0Q291bnQgPSBkaXJlY3Rpb25hbExpZ2h0cy5sZW5ndGg7XG4gIHJldHVybiBsaWdodFNvdXJjZVVuaWZvcm1zO1xufVxuXG5mdW5jdGlvbiBnZXRVbmlmb3JtcygpIHtcbiAgbGV0IG9wdHMgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IElOSVRJQUxfTU9EVUxFX09QVElPTlM7XG5cbiAgaWYgKCdsaWdodFNvdXJjZXMnIGluIG9wdHMpIHtcbiAgICBjb25zdCB7XG4gICAgICBhbWJpZW50TGlnaHQsXG4gICAgICBwb2ludExpZ2h0cyxcbiAgICAgIGRpcmVjdGlvbmFsTGlnaHRzXG4gICAgfSA9IG9wdHMubGlnaHRTb3VyY2VzIHx8IHt9O1xuICAgIGNvbnN0IGhhc0xpZ2h0cyA9IGFtYmllbnRMaWdodCB8fCBwb2ludExpZ2h0cyAmJiBwb2ludExpZ2h0cy5sZW5ndGggPiAwIHx8IGRpcmVjdGlvbmFsTGlnaHRzICYmIGRpcmVjdGlvbmFsTGlnaHRzLmxlbmd0aCA+IDA7XG5cbiAgICBpZiAoIWhhc0xpZ2h0cykge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgbGlnaHRpbmdfdUVuYWJsZWQ6IGZhbHNlXG4gICAgICB9O1xuICAgIH1cblxuICAgIHJldHVybiBPYmplY3QuYXNzaWduKHt9LCBnZXRMaWdodFNvdXJjZVVuaWZvcm1zKHtcbiAgICAgIGFtYmllbnRMaWdodCxcbiAgICAgIHBvaW50TGlnaHRzLFxuICAgICAgZGlyZWN0aW9uYWxMaWdodHNcbiAgICB9KSwge1xuICAgICAgbGlnaHRpbmdfdUVuYWJsZWQ6IHRydWVcbiAgICB9KTtcbiAgfVxuXG4gIGlmICgnbGlnaHRzJyBpbiBvcHRzKSB7XG4gICAgY29uc3QgbGlnaHRTb3VyY2VzID0ge1xuICAgICAgcG9pbnRMaWdodHM6IFtdLFxuICAgICAgZGlyZWN0aW9uYWxMaWdodHM6IFtdXG4gICAgfTtcblxuICAgIGZvciAoY29uc3QgbGlnaHQgb2Ygb3B0cy5saWdodHMgfHwgW10pIHtcbiAgICAgIHN3aXRjaCAobGlnaHQudHlwZSkge1xuICAgICAgICBjYXNlICdhbWJpZW50JzpcbiAgICAgICAgICBsaWdodFNvdXJjZXMuYW1iaWVudExpZ2h0ID0gbGlnaHQ7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAnZGlyZWN0aW9uYWwnOlxuICAgICAgICAgIGxpZ2h0U291cmNlcy5kaXJlY3Rpb25hbExpZ2h0cy5wdXNoKGxpZ2h0KTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICdwb2ludCc6XG4gICAgICAgICAgbGlnaHRTb3VyY2VzLnBvaW50TGlnaHRzLnB1c2gobGlnaHQpO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGdldFVuaWZvcm1zKHtcbiAgICAgIGxpZ2h0U291cmNlc1xuICAgIH0pO1xuICB9XG5cbiAgcmV0dXJuIHt9O1xufVxuXG5leHBvcnQgY29uc3QgbGlnaHRzID0ge1xuICBuYW1lOiAnbGlnaHRzJyxcbiAgdnM6IGxpZ2h0aW5nU2hhZGVyLFxuICBmczogbGlnaHRpbmdTaGFkZXIsXG4gIGdldFVuaWZvcm1zLFxuICBkZWZpbmVzOiB7XG4gICAgTUFYX0xJR0hUUzogM1xuICB9XG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bGlnaHRzLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///66931\n')},49764:function(__unused_webpack_module,__webpack_exports__,__webpack_require__){eval('\n// EXPORTS\n__webpack_require__.d(__webpack_exports__, {\n  "b": function() { return /* binding */ pbr; }\n});\n\n// EXTERNAL MODULE: ./node_modules/@luma.gl/shadertools/dist/esm/modules/lights/lights.js + 1 modules\nvar lights = __webpack_require__(66931);\n;// CONCATENATED MODULE: ./node_modules/@luma.gl/shadertools/dist/esm/modules/pbr/pbr-vertex.glsl.js\n/* harmony default export */ var pbr_vertex_glsl = ("uniform mat4 u_MVPMatrix;\\nuniform mat4 u_ModelMatrix;\\nuniform mat4 u_NormalMatrix;\\n\\nvarying vec3 pbr_vPosition;\\nvarying vec2 pbr_vUV;\\n\\n#ifdef HAS_NORMALS\\n# ifdef HAS_TANGENTS\\nvarying mat3 pbr_vTBN;\\n# else\\nvarying vec3 pbr_vNormal;\\n# endif\\n#endif\\n\\nvoid pbr_setPositionNormalTangentUV(vec4 position, vec4 normal, vec4 tangent, vec2 uv)\\n{\\n  vec4 pos = u_ModelMatrix * position;\\n  pbr_vPosition = vec3(pos.xyz) / pos.w;\\n\\n#ifdef HAS_NORMALS\\n#ifdef HAS_TANGENTS\\n  vec3 normalW = normalize(vec3(u_NormalMatrix * vec4(normal.xyz, 0.0)));\\n  vec3 tangentW = normalize(vec3(u_ModelMatrix * vec4(tangent.xyz, 0.0)));\\n  vec3 bitangentW = cross(normalW, tangentW) * tangent.w;\\n  pbr_vTBN = mat3(tangentW, bitangentW, normalW);\\n#else\\n  pbr_vNormal = normalize(vec3(u_ModelMatrix * vec4(normal.xyz, 0.0)));\\n#endif\\n#endif\\n\\n#ifdef HAS_UV\\n  pbr_vUV = uv;\\n#else\\n  pbr_vUV = vec2(0.,0.);\\n#endif\\n}\\n");\n//# sourceMappingURL=pbr-vertex.glsl.js.map\n;// CONCATENATED MODULE: ./node_modules/@luma.gl/shadertools/dist/esm/modules/pbr/pbr-fragment.glsl.js\n/* harmony default export */ var pbr_fragment_glsl = ("#if defined(USE_TEX_LOD) && !defined(FEATURE_GLSL_TEXTURE_LOD)\\n# error PBR fragment shader: Texture LOD is not available\\n#endif\\n\\n#if !defined(HAS_TANGENTS) && !defined(FEATURE_GLSL_DERIVATIVES)\\n# error PBR fragment shader: Derivatives are not available\\n#endif\\n\\n\\n#if (__VERSION__ < 300)\\n  #define SMART_FOR(INIT, WEBGL1COND, WEBGL2COND, INCR) for (INIT; WEBGL1COND; INCR)\\n#else\\n  #define SMART_FOR(INIT, WEBGL1COND, WEBGL2COND, INCR) for (INIT; WEBGL2COND; INCR)\\n#endif\\n\\nprecision highp float;\\n\\nuniform bool pbr_uUnlit;\\n\\n#ifdef USE_IBL\\nuniform samplerCube u_DiffuseEnvSampler;\\nuniform samplerCube u_SpecularEnvSampler;\\nuniform sampler2D u_brdfLUT;\\nuniform vec2 u_ScaleIBLAmbient;\\n#endif\\n\\n#ifdef HAS_BASECOLORMAP\\nuniform sampler2D u_BaseColorSampler;\\n#endif\\n#ifdef HAS_NORMALMAP\\nuniform sampler2D u_NormalSampler;\\nuniform float u_NormalScale;\\n#endif\\n#ifdef HAS_EMISSIVEMAP\\nuniform sampler2D u_EmissiveSampler;\\nuniform vec3 u_EmissiveFactor;\\n#endif\\n#ifdef HAS_METALROUGHNESSMAP\\nuniform sampler2D u_MetallicRoughnessSampler;\\n#endif\\n#ifdef HAS_OCCLUSIONMAP\\nuniform sampler2D u_OcclusionSampler;\\nuniform float u_OcclusionStrength;\\n#endif\\n\\n#ifdef ALPHA_CUTOFF\\nuniform float u_AlphaCutoff;\\n#endif\\n\\nuniform vec2 u_MetallicRoughnessValues;\\nuniform vec4 u_BaseColorFactor;\\n\\nuniform vec3 u_Camera;\\n#ifdef PBR_DEBUG\\nuniform vec4 u_ScaleDiffBaseMR;\\nuniform vec4 u_ScaleFGDSpec;\\n#endif\\n\\nvarying vec3 pbr_vPosition;\\n\\nvarying vec2 pbr_vUV;\\n\\n#ifdef HAS_NORMALS\\n#ifdef HAS_TANGENTS\\nvarying mat3 pbr_vTBN;\\n#else\\nvarying vec3 pbr_vNormal;\\n#endif\\n#endif\\n\\n\\nstruct PBRInfo\\n{\\n  float NdotL;\\n  float NdotV;\\n  float NdotH;\\n  float LdotH;\\n  float VdotH;\\n  float perceptualRoughness;\\n  float metalness;\\n  vec3 reflectance0;\\n  vec3 reflectance90;\\n  float alphaRoughness;\\n  vec3 diffuseColor;\\n  vec3 specularColor;\\n  vec3 n;\\n  vec3 v;\\n};\\n\\nconst float M_PI = 3.141592653589793;\\nconst float c_MinRoughness = 0.04;\\n\\nvec4 SRGBtoLINEAR(vec4 srgbIn)\\n{\\n#ifdef MANUAL_SRGB\\n#ifdef SRGB_FAST_APPROXIMATION\\n  vec3 linOut = pow(srgbIn.xyz,vec3(2.2));\\n#else\\n  vec3 bLess = step(vec3(0.04045),srgbIn.xyz);\\n  vec3 linOut = mix( srgbIn.xyz/vec3(12.92), pow((srgbIn.xyz+vec3(0.055))/vec3(1.055),vec3(2.4)), bLess );\\n#endif\\n  return vec4(linOut,srgbIn.w);;\\n#else\\n  return srgbIn;\\n#endif\\n}\\n\\nvec3 getNormal()\\n{\\n#ifndef HAS_TANGENTS\\n  vec3 pos_dx = dFdx(pbr_vPosition);\\n  vec3 pos_dy = dFdy(pbr_vPosition);\\n  vec3 tex_dx = dFdx(vec3(pbr_vUV, 0.0));\\n  vec3 tex_dy = dFdy(vec3(pbr_vUV, 0.0));\\n  vec3 t = (tex_dy.t * pos_dx - tex_dx.t * pos_dy) / (tex_dx.s * tex_dy.t - tex_dy.s * tex_dx.t);\\n\\n#ifdef HAS_NORMALS\\n  vec3 ng = normalize(pbr_vNormal);\\n#else\\n  vec3 ng = cross(pos_dx, pos_dy);\\n#endif\\n\\n  t = normalize(t - ng * dot(ng, t));\\n  vec3 b = normalize(cross(ng, t));\\n  mat3 tbn = mat3(t, b, ng);\\n#else\\n  mat3 tbn = pbr_vTBN;\\n#endif\\n\\n#ifdef HAS_NORMALMAP\\n  vec3 n = texture2D(u_NormalSampler, pbr_vUV).rgb;\\n  n = normalize(tbn * ((2.0 * n - 1.0) * vec3(u_NormalScale, u_NormalScale, 1.0)));\\n#else\\n  vec3 n = normalize(tbn[2].xyz);\\n#endif\\n\\n  return n;\\n}\\n\\n\\n#ifdef USE_IBL\\nvec3 getIBLContribution(PBRInfo pbrInputs, vec3 n, vec3 reflection)\\n{\\n  float mipCount = 9.0;\\n  float lod = (pbrInputs.perceptualRoughness * mipCount);\\n  vec3 brdf = SRGBtoLINEAR(texture2D(u_brdfLUT,\\n    vec2(pbrInputs.NdotV, 1.0 - pbrInputs.perceptualRoughness))).rgb;\\n  vec3 diffuseLight = SRGBtoLINEAR(textureCube(u_DiffuseEnvSampler, n)).rgb;\\n\\n#ifdef USE_TEX_LOD\\n  vec3 specularLight = SRGBtoLINEAR(textureCubeLod(u_SpecularEnvSampler, reflection, lod)).rgb;\\n#else\\n  vec3 specularLight = SRGBtoLINEAR(textureCube(u_SpecularEnvSampler, reflection)).rgb;\\n#endif\\n\\n  vec3 diffuse = diffuseLight * pbrInputs.diffuseColor;\\n  vec3 specular = specularLight * (pbrInputs.specularColor * brdf.x + brdf.y);\\n  diffuse *= u_ScaleIBLAmbient.x;\\n  specular *= u_ScaleIBLAmbient.y;\\n\\n  return diffuse + specular;\\n}\\n#endif\\n\\n\\nvec3 diffuse(PBRInfo pbrInputs)\\n{\\n  return pbrInputs.diffuseColor / M_PI;\\n}\\n\\nvec3 specularReflection(PBRInfo pbrInputs)\\n{\\n  return pbrInputs.reflectance0 +\\n    (pbrInputs.reflectance90 - pbrInputs.reflectance0) *\\n    pow(clamp(1.0 - pbrInputs.VdotH, 0.0, 1.0), 5.0);\\n}\\n\\n\\n\\nfloat geometricOcclusion(PBRInfo pbrInputs)\\n{\\n  float NdotL = pbrInputs.NdotL;\\n  float NdotV = pbrInputs.NdotV;\\n  float r = pbrInputs.alphaRoughness;\\n\\n  float attenuationL = 2.0 * NdotL / (NdotL + sqrt(r * r + (1.0 - r * r) * (NdotL * NdotL)));\\n  float attenuationV = 2.0 * NdotV / (NdotV + sqrt(r * r + (1.0 - r * r) * (NdotV * NdotV)));\\n  return attenuationL * attenuationV;\\n}\\n\\n\\n\\n\\n\\nfloat microfacetDistribution(PBRInfo pbrInputs)\\n{\\n  float roughnessSq = pbrInputs.alphaRoughness * pbrInputs.alphaRoughness;\\n  float f = (pbrInputs.NdotH * roughnessSq - pbrInputs.NdotH) * pbrInputs.NdotH + 1.0;\\n  return roughnessSq / (M_PI * f * f);\\n}\\n\\nvoid PBRInfo_setAmbientLight(inout PBRInfo pbrInputs) {\\n  pbrInputs.NdotL = 1.0;\\n  pbrInputs.NdotH = 0.0;\\n  pbrInputs.LdotH = 0.0;\\n  pbrInputs.VdotH = 1.0;\\n}\\n\\nvoid PBRInfo_setDirectionalLight(inout PBRInfo pbrInputs, vec3 lightDirection) {\\n  vec3 n = pbrInputs.n;\\n  vec3 v = pbrInputs.v;\\n  vec3 l = normalize(lightDirection);\\n  vec3 h = normalize(l+v);\\n\\n  pbrInputs.NdotL = clamp(dot(n, l), 0.001, 1.0);\\n  pbrInputs.NdotH = clamp(dot(n, h), 0.0, 1.0);\\n  pbrInputs.LdotH = clamp(dot(l, h), 0.0, 1.0);\\n  pbrInputs.VdotH = clamp(dot(v, h), 0.0, 1.0);\\n}\\n\\nvoid PBRInfo_setPointLight(inout PBRInfo pbrInputs, PointLight pointLight) {\\n  vec3 light_direction = normalize(pointLight.position - pbr_vPosition);\\n  PBRInfo_setDirectionalLight(pbrInputs, light_direction);\\n}\\n\\nvec3 calculateFinalColor(PBRInfo pbrInputs, vec3 lightColor) {\\n  vec3 F = specularReflection(pbrInputs);\\n  float G = geometricOcclusion(pbrInputs);\\n  float D = microfacetDistribution(pbrInputs);\\n  vec3 diffuseContrib = (1.0 - F) * diffuse(pbrInputs);\\n  vec3 specContrib = F * G * D / (4.0 * pbrInputs.NdotL * pbrInputs.NdotV);\\n  return pbrInputs.NdotL * lightColor * (diffuseContrib + specContrib);\\n}\\n\\nvec4 pbr_filterColor(vec4 colorUnused)\\n{\\n#ifdef HAS_BASECOLORMAP\\n  vec4 baseColor = SRGBtoLINEAR(texture2D(u_BaseColorSampler, pbr_vUV)) * u_BaseColorFactor;\\n#else\\n  vec4 baseColor = u_BaseColorFactor;\\n#endif\\n\\n#ifdef ALPHA_CUTOFF\\n  if (baseColor.a < u_AlphaCutoff) {\\n    discard;\\n  }\\n#endif\\n\\n  vec3 color = vec3(0, 0, 0);\\n\\n  if(pbr_uUnlit){\\n    color.rgb = baseColor.rgb;\\n  }\\n  else{\\n\\n\\n    float perceptualRoughness = u_MetallicRoughnessValues.y;\\n    float metallic = u_MetallicRoughnessValues.x;\\n#ifdef HAS_METALROUGHNESSMAP\\n\\n    vec4 mrSample = texture2D(u_MetallicRoughnessSampler, pbr_vUV);\\n    perceptualRoughness = mrSample.g * perceptualRoughness;\\n    metallic = mrSample.b * metallic;\\n#endif\\n    perceptualRoughness = clamp(perceptualRoughness, c_MinRoughness, 1.0);\\n    metallic = clamp(metallic, 0.0, 1.0);\\n\\n    float alphaRoughness = perceptualRoughness * perceptualRoughness;\\n\\n    vec3 f0 = vec3(0.04);\\n    vec3 diffuseColor = baseColor.rgb * (vec3(1.0) - f0);\\n    diffuseColor *= 1.0 - metallic;\\n    vec3 specularColor = mix(f0, baseColor.rgb, metallic);\\n    float reflectance = max(max(specularColor.r, specularColor.g), specularColor.b);\\n\\n\\n\\n    float reflectance90 = clamp(reflectance * 25.0, 0.0, 1.0);\\n    vec3 specularEnvironmentR0 = specularColor.rgb;\\n    vec3 specularEnvironmentR90 = vec3(1.0, 1.0, 1.0) * reflectance90;\\n\\n    vec3 n = getNormal();\\n    vec3 v = normalize(u_Camera - pbr_vPosition);\\n\\n    float NdotV = clamp(abs(dot(n, v)), 0.001, 1.0);\\n    vec3 reflection = -normalize(reflect(v, n));\\n\\n    PBRInfo pbrInputs = PBRInfo(\\n      0.0,\\n      NdotV,\\n      0.0,\\n      0.0,\\n      0.0,\\n      perceptualRoughness,\\n      metallic,\\n      specularEnvironmentR0,\\n      specularEnvironmentR90,\\n      alphaRoughness,\\n      diffuseColor,\\n      specularColor,\\n      n,\\n      v\\n    );\\n\\n#ifdef USE_LIGHTS\\n    PBRInfo_setAmbientLight(pbrInputs);\\n    color += calculateFinalColor(pbrInputs, lighting_uAmbientLight.color);\\n    SMART_FOR(int i = 0, i < MAX_LIGHTS, i < lighting_uDirectionalLightCount, i++) {\\n      if (i < lighting_uDirectionalLightCount) {\\n        PBRInfo_setDirectionalLight(pbrInputs, lighting_uDirectionalLight[i].direction);\\n        color += calculateFinalColor(pbrInputs, lighting_uDirectionalLight[i].color);\\n      }\\n    }\\n    SMART_FOR(int i = 0, i < MAX_LIGHTS, i < lighting_uPointLightCount, i++) {\\n      if (i < lighting_uPointLightCount) {\\n        PBRInfo_setPointLight(pbrInputs, lighting_uPointLight[i]);\\n        float attenuation = getPointLightAttenuation(lighting_uPointLight[i], distance(lighting_uPointLight[i].position, pbr_vPosition));\\n        color += calculateFinalColor(pbrInputs, lighting_uPointLight[i].color / attenuation);\\n      }\\n    }\\n#endif\\n#ifdef USE_IBL\\n    color += getIBLContribution(pbrInputs, n, reflection);\\n#endif\\n#ifdef HAS_OCCLUSIONMAP\\n    float ao = texture2D(u_OcclusionSampler, pbr_vUV).r;\\n    color = mix(color, color * ao, u_OcclusionStrength);\\n#endif\\n\\n#ifdef HAS_EMISSIVEMAP\\n    vec3 emissive = SRGBtoLINEAR(texture2D(u_EmissiveSampler, pbr_vUV)).rgb * u_EmissiveFactor;\\n    color += emissive;\\n#endif\\n\\n#ifdef PBR_DEBUG\\n\\n\\n\\n\\n\\n    color = mix(color, baseColor.rgb, u_ScaleDiffBaseMR.y);\\n    color = mix(color, vec3(metallic), u_ScaleDiffBaseMR.z);\\n    color = mix(color, vec3(perceptualRoughness), u_ScaleDiffBaseMR.w);\\n#endif\\n\\n  }\\n\\n  return vec4(pow(color,vec3(1.0/2.2)), baseColor.a);\\n}\\n");\n//# sourceMappingURL=pbr-fragment.glsl.js.map\n;// CONCATENATED MODULE: ./node_modules/@luma.gl/shadertools/dist/esm/modules/pbr/pbr.js\n\n\n\nconst pbr = {\n  name: \'pbr\',\n  vs: pbr_vertex_glsl,\n  fs: pbr_fragment_glsl,\n  defines: {\n    LIGHTING_FRAGMENT: 1\n  },\n  dependencies: [lights/* lights */.H]\n};\n//# sourceMappingURL=pbr.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNDk3NjQuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBQUEsb0RBQWUsMEJBQTBCLDZCQUE2Qiw4QkFBOEIsK0JBQStCLHVCQUF1QixvRUFBb0UsbUNBQW1DLDhHQUE4Ryx3Q0FBd0MsMENBQTBDLHNIQUFzSCw0RUFBNEUsMkRBQTJELG1EQUFtRCxnRkFBZ0Ysa0RBQWtELGlDQUFpQyxXQUFXLEdBQUcsRUFBQztBQUNuNkIsMkM7O0FDREEsc0RBQWUsNFdBQTRXLFlBQVksaUZBQWlGLFlBQVksdUNBQXVDLDRCQUE0Qiw0REFBNEQsMkNBQTJDLDhCQUE4QixpQ0FBaUMsMEVBQTBFLGtFQUFrRSw4QkFBOEIsc0VBQXNFLGdDQUFnQyxxRkFBcUYsd0VBQXdFLG9DQUFvQyw2REFBNkQsbURBQW1ELGlDQUFpQywwQkFBMEIsbURBQW1ELDhCQUE4Qix1Q0FBdUMseUJBQXlCLG1FQUFtRSxrQ0FBa0MsdUNBQXVDLGdCQUFnQixnQkFBZ0IsZ0JBQWdCLGdCQUFnQixnQkFBZ0IsOEJBQThCLG9CQUFvQixzQkFBc0IsdUJBQXVCLHlCQUF5QixzQkFBc0IsdUJBQXVCLFdBQVcsV0FBVyxJQUFJLHlDQUF5QyxvQ0FBb0MscUNBQXFDLGdHQUFnRyx1REFBdUQsNEdBQTRHLDBDQUEwQyx5QkFBeUIsV0FBVyx1QkFBdUIsNERBQTRELHNDQUFzQywyQ0FBMkMsMkNBQTJDLG1HQUFtRywyREFBMkQsMkNBQTJDLGlEQUFpRCxxQ0FBcUMsOEJBQThCLCtCQUErQixxRkFBcUYscUZBQXFGLDBDQUEwQyx1QkFBdUIsR0FBRyw0RkFBNEYseUJBQXlCLDJEQUEyRCx3SEFBd0gsOEVBQThFLHVIQUF1SCxnR0FBZ0csbUVBQW1FLGdGQUFnRixtQ0FBbUMsb0NBQW9DLGdDQUFnQyxHQUFHLGdEQUFnRCx5Q0FBeUMsR0FBRyxpREFBaUQsb0pBQW9KLEdBQUcsc0RBQXNELGtDQUFrQyxrQ0FBa0MsdUNBQXVDLGlHQUFpRywrRkFBK0YsdUNBQXVDLEdBQUcsOERBQThELDRFQUE0RSx3RkFBd0Ysd0NBQXdDLEdBQUcsMkRBQTJELDBCQUEwQiwwQkFBMEIsMEJBQTBCLDBCQUEwQixHQUFHLG9GQUFvRix5QkFBeUIseUJBQXlCLHVDQUF1Qyw0QkFBNEIscURBQXFELGlEQUFpRCxpREFBaUQsaURBQWlELEdBQUcsZ0ZBQWdGLDBFQUEwRSw0REFBNEQsR0FBRyxrRUFBa0UsMkNBQTJDLDRDQUE0QyxnREFBZ0QseURBQXlELDZFQUE2RSx5RUFBeUUsR0FBRyw2Q0FBNkMsdUhBQXVILDhDQUE4QyxxRUFBcUUsY0FBYyxLQUFLLHlDQUF5QyxxQkFBcUIsZ0NBQWdDLEtBQUssU0FBUyxrRUFBa0UsbURBQW1ELHFHQUFxRyw2REFBNkQsdUNBQXVDLG9GQUFvRiwyQ0FBMkMseUVBQXlFLDZCQUE2QiwyREFBMkQscUNBQXFDLDREQUE0RCxzRkFBc0Ysc0VBQXNFLHFEQUFxRCx3RUFBd0UsNkJBQTZCLG1EQUFtRCx3REFBd0Qsa0RBQWtELHlTQUF5Uyw4REFBOEQsNEVBQTRFLHNGQUFzRixrREFBa0QsMEZBQTBGLHVGQUF1RixTQUFTLE9BQU8sZ0ZBQWdGLDRDQUE0QyxvRUFBb0UsMklBQTJJLCtGQUErRixTQUFTLE9BQU8sb0ZBQW9GLDJGQUEyRiwwREFBMEQsbUlBQW1JLHdCQUF3QixtR0FBbUcsOERBQThELHlFQUF5RSxlQUFlLHlEQUF5RCxHQUFHLEdBQUcsRUFBQztBQUNoNlMsNkM7O0FDRDBDO0FBQ1A7QUFDRTtBQUM5QjtBQUNQO0FBQ0EsSUFBSTtBQUNKLElBQUk7QUFDSjtBQUNBO0FBQ0EsR0FBRztBQUNILGlCQUFpQixvQkFBTTtBQUN2QjtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdnVlMy13ZWJwYWNrNS8uL25vZGVfbW9kdWxlcy9AbHVtYS5nbC9zaGFkZXJ0b29scy9kaXN0L2VzbS9tb2R1bGVzL3Bici9wYnItdmVydGV4Lmdsc2wuanM/ZDQ3MCIsIndlYnBhY2s6Ly92dWUzLXdlYnBhY2s1Ly4vbm9kZV9tb2R1bGVzL0BsdW1hLmdsL3NoYWRlcnRvb2xzL2Rpc3QvZXNtL21vZHVsZXMvcGJyL3Bici1mcmFnbWVudC5nbHNsLmpzPzUwOWEiLCJ3ZWJwYWNrOi8vdnVlMy13ZWJwYWNrNS8uL25vZGVfbW9kdWxlcy9AbHVtYS5nbC9zaGFkZXJ0b29scy9kaXN0L2VzbS9tb2R1bGVzL3Bici9wYnIuanM/NDMyMiJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgZGVmYXVsdCBcInVuaWZvcm0gbWF0NCB1X01WUE1hdHJpeDtcXG51bmlmb3JtIG1hdDQgdV9Nb2RlbE1hdHJpeDtcXG51bmlmb3JtIG1hdDQgdV9Ob3JtYWxNYXRyaXg7XFxuXFxudmFyeWluZyB2ZWMzIHBicl92UG9zaXRpb247XFxudmFyeWluZyB2ZWMyIHBicl92VVY7XFxuXFxuI2lmZGVmIEhBU19OT1JNQUxTXFxuIyBpZmRlZiBIQVNfVEFOR0VOVFNcXG52YXJ5aW5nIG1hdDMgcGJyX3ZUQk47XFxuIyBlbHNlXFxudmFyeWluZyB2ZWMzIHBicl92Tm9ybWFsO1xcbiMgZW5kaWZcXG4jZW5kaWZcXG5cXG52b2lkIHBicl9zZXRQb3NpdGlvbk5vcm1hbFRhbmdlbnRVVih2ZWM0IHBvc2l0aW9uLCB2ZWM0IG5vcm1hbCwgdmVjNCB0YW5nZW50LCB2ZWMyIHV2KVxcbntcXG4gIHZlYzQgcG9zID0gdV9Nb2RlbE1hdHJpeCAqIHBvc2l0aW9uO1xcbiAgcGJyX3ZQb3NpdGlvbiA9IHZlYzMocG9zLnh5eikgLyBwb3MudztcXG5cXG4jaWZkZWYgSEFTX05PUk1BTFNcXG4jaWZkZWYgSEFTX1RBTkdFTlRTXFxuICB2ZWMzIG5vcm1hbFcgPSBub3JtYWxpemUodmVjMyh1X05vcm1hbE1hdHJpeCAqIHZlYzQobm9ybWFsLnh5eiwgMC4wKSkpO1xcbiAgdmVjMyB0YW5nZW50VyA9IG5vcm1hbGl6ZSh2ZWMzKHVfTW9kZWxNYXRyaXggKiB2ZWM0KHRhbmdlbnQueHl6LCAwLjApKSk7XFxuICB2ZWMzIGJpdGFuZ2VudFcgPSBjcm9zcyhub3JtYWxXLCB0YW5nZW50VykgKiB0YW5nZW50Lnc7XFxuICBwYnJfdlRCTiA9IG1hdDModGFuZ2VudFcsIGJpdGFuZ2VudFcsIG5vcm1hbFcpO1xcbiNlbHNlXFxuICBwYnJfdk5vcm1hbCA9IG5vcm1hbGl6ZSh2ZWMzKHVfTW9kZWxNYXRyaXggKiB2ZWM0KG5vcm1hbC54eXosIDAuMCkpKTtcXG4jZW5kaWZcXG4jZW5kaWZcXG5cXG4jaWZkZWYgSEFTX1VWXFxuICBwYnJfdlVWID0gdXY7XFxuI2Vsc2VcXG4gIHBicl92VVYgPSB2ZWMyKDAuLDAuKTtcXG4jZW5kaWZcXG59XFxuXCI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1wYnItdmVydGV4Lmdsc2wuanMubWFwIiwiZXhwb3J0IGRlZmF1bHQgXCIjaWYgZGVmaW5lZChVU0VfVEVYX0xPRCkgJiYgIWRlZmluZWQoRkVBVFVSRV9HTFNMX1RFWFRVUkVfTE9EKVxcbiMgZXJyb3IgUEJSIGZyYWdtZW50IHNoYWRlcjogVGV4dHVyZSBMT0QgaXMgbm90IGF2YWlsYWJsZVxcbiNlbmRpZlxcblxcbiNpZiAhZGVmaW5lZChIQVNfVEFOR0VOVFMpICYmICFkZWZpbmVkKEZFQVRVUkVfR0xTTF9ERVJJVkFUSVZFUylcXG4jIGVycm9yIFBCUiBmcmFnbWVudCBzaGFkZXI6IERlcml2YXRpdmVzIGFyZSBub3QgYXZhaWxhYmxlXFxuI2VuZGlmXFxuXFxuXFxuI2lmIChfX1ZFUlNJT05fXyA8IDMwMClcXG4gICNkZWZpbmUgU01BUlRfRk9SKElOSVQsIFdFQkdMMUNPTkQsIFdFQkdMMkNPTkQsIElOQ1IpIGZvciAoSU5JVDsgV0VCR0wxQ09ORDsgSU5DUilcXG4jZWxzZVxcbiAgI2RlZmluZSBTTUFSVF9GT1IoSU5JVCwgV0VCR0wxQ09ORCwgV0VCR0wyQ09ORCwgSU5DUikgZm9yIChJTklUOyBXRUJHTDJDT05EOyBJTkNSKVxcbiNlbmRpZlxcblxcbnByZWNpc2lvbiBoaWdocCBmbG9hdDtcXG5cXG51bmlmb3JtIGJvb2wgcGJyX3VVbmxpdDtcXG5cXG4jaWZkZWYgVVNFX0lCTFxcbnVuaWZvcm0gc2FtcGxlckN1YmUgdV9EaWZmdXNlRW52U2FtcGxlcjtcXG51bmlmb3JtIHNhbXBsZXJDdWJlIHVfU3BlY3VsYXJFbnZTYW1wbGVyO1xcbnVuaWZvcm0gc2FtcGxlcjJEIHVfYnJkZkxVVDtcXG51bmlmb3JtIHZlYzIgdV9TY2FsZUlCTEFtYmllbnQ7XFxuI2VuZGlmXFxuXFxuI2lmZGVmIEhBU19CQVNFQ09MT1JNQVBcXG51bmlmb3JtIHNhbXBsZXIyRCB1X0Jhc2VDb2xvclNhbXBsZXI7XFxuI2VuZGlmXFxuI2lmZGVmIEhBU19OT1JNQUxNQVBcXG51bmlmb3JtIHNhbXBsZXIyRCB1X05vcm1hbFNhbXBsZXI7XFxudW5pZm9ybSBmbG9hdCB1X05vcm1hbFNjYWxlO1xcbiNlbmRpZlxcbiNpZmRlZiBIQVNfRU1JU1NJVkVNQVBcXG51bmlmb3JtIHNhbXBsZXIyRCB1X0VtaXNzaXZlU2FtcGxlcjtcXG51bmlmb3JtIHZlYzMgdV9FbWlzc2l2ZUZhY3RvcjtcXG4jZW5kaWZcXG4jaWZkZWYgSEFTX01FVEFMUk9VR0hORVNTTUFQXFxudW5pZm9ybSBzYW1wbGVyMkQgdV9NZXRhbGxpY1JvdWdobmVzc1NhbXBsZXI7XFxuI2VuZGlmXFxuI2lmZGVmIEhBU19PQ0NMVVNJT05NQVBcXG51bmlmb3JtIHNhbXBsZXIyRCB1X09jY2x1c2lvblNhbXBsZXI7XFxudW5pZm9ybSBmbG9hdCB1X09jY2x1c2lvblN0cmVuZ3RoO1xcbiNlbmRpZlxcblxcbiNpZmRlZiBBTFBIQV9DVVRPRkZcXG51bmlmb3JtIGZsb2F0IHVfQWxwaGFDdXRvZmY7XFxuI2VuZGlmXFxuXFxudW5pZm9ybSB2ZWMyIHVfTWV0YWxsaWNSb3VnaG5lc3NWYWx1ZXM7XFxudW5pZm9ybSB2ZWM0IHVfQmFzZUNvbG9yRmFjdG9yO1xcblxcbnVuaWZvcm0gdmVjMyB1X0NhbWVyYTtcXG4jaWZkZWYgUEJSX0RFQlVHXFxudW5pZm9ybSB2ZWM0IHVfU2NhbGVEaWZmQmFzZU1SO1xcbnVuaWZvcm0gdmVjNCB1X1NjYWxlRkdEU3BlYztcXG4jZW5kaWZcXG5cXG52YXJ5aW5nIHZlYzMgcGJyX3ZQb3NpdGlvbjtcXG5cXG52YXJ5aW5nIHZlYzIgcGJyX3ZVVjtcXG5cXG4jaWZkZWYgSEFTX05PUk1BTFNcXG4jaWZkZWYgSEFTX1RBTkdFTlRTXFxudmFyeWluZyBtYXQzIHBicl92VEJOO1xcbiNlbHNlXFxudmFyeWluZyB2ZWMzIHBicl92Tm9ybWFsO1xcbiNlbmRpZlxcbiNlbmRpZlxcblxcblxcbnN0cnVjdCBQQlJJbmZvXFxue1xcbiAgZmxvYXQgTmRvdEw7XFxuICBmbG9hdCBOZG90VjtcXG4gIGZsb2F0IE5kb3RIO1xcbiAgZmxvYXQgTGRvdEg7XFxuICBmbG9hdCBWZG90SDtcXG4gIGZsb2F0IHBlcmNlcHR1YWxSb3VnaG5lc3M7XFxuICBmbG9hdCBtZXRhbG5lc3M7XFxuICB2ZWMzIHJlZmxlY3RhbmNlMDtcXG4gIHZlYzMgcmVmbGVjdGFuY2U5MDtcXG4gIGZsb2F0IGFscGhhUm91Z2huZXNzO1xcbiAgdmVjMyBkaWZmdXNlQ29sb3I7XFxuICB2ZWMzIHNwZWN1bGFyQ29sb3I7XFxuICB2ZWMzIG47XFxuICB2ZWMzIHY7XFxufTtcXG5cXG5jb25zdCBmbG9hdCBNX1BJID0gMy4xNDE1OTI2NTM1ODk3OTM7XFxuY29uc3QgZmxvYXQgY19NaW5Sb3VnaG5lc3MgPSAwLjA0O1xcblxcbnZlYzQgU1JHQnRvTElORUFSKHZlYzQgc3JnYkluKVxcbntcXG4jaWZkZWYgTUFOVUFMX1NSR0JcXG4jaWZkZWYgU1JHQl9GQVNUX0FQUFJPWElNQVRJT05cXG4gIHZlYzMgbGluT3V0ID0gcG93KHNyZ2JJbi54eXosdmVjMygyLjIpKTtcXG4jZWxzZVxcbiAgdmVjMyBiTGVzcyA9IHN0ZXAodmVjMygwLjA0MDQ1KSxzcmdiSW4ueHl6KTtcXG4gIHZlYzMgbGluT3V0ID0gbWl4KCBzcmdiSW4ueHl6L3ZlYzMoMTIuOTIpLCBwb3coKHNyZ2JJbi54eXordmVjMygwLjA1NSkpL3ZlYzMoMS4wNTUpLHZlYzMoMi40KSksIGJMZXNzICk7XFxuI2VuZGlmXFxuICByZXR1cm4gdmVjNChsaW5PdXQsc3JnYkluLncpOztcXG4jZWxzZVxcbiAgcmV0dXJuIHNyZ2JJbjtcXG4jZW5kaWZcXG59XFxuXFxudmVjMyBnZXROb3JtYWwoKVxcbntcXG4jaWZuZGVmIEhBU19UQU5HRU5UU1xcbiAgdmVjMyBwb3NfZHggPSBkRmR4KHBicl92UG9zaXRpb24pO1xcbiAgdmVjMyBwb3NfZHkgPSBkRmR5KHBicl92UG9zaXRpb24pO1xcbiAgdmVjMyB0ZXhfZHggPSBkRmR4KHZlYzMocGJyX3ZVViwgMC4wKSk7XFxuICB2ZWMzIHRleF9keSA9IGRGZHkodmVjMyhwYnJfdlVWLCAwLjApKTtcXG4gIHZlYzMgdCA9ICh0ZXhfZHkudCAqIHBvc19keCAtIHRleF9keC50ICogcG9zX2R5KSAvICh0ZXhfZHgucyAqIHRleF9keS50IC0gdGV4X2R5LnMgKiB0ZXhfZHgudCk7XFxuXFxuI2lmZGVmIEhBU19OT1JNQUxTXFxuICB2ZWMzIG5nID0gbm9ybWFsaXplKHBicl92Tm9ybWFsKTtcXG4jZWxzZVxcbiAgdmVjMyBuZyA9IGNyb3NzKHBvc19keCwgcG9zX2R5KTtcXG4jZW5kaWZcXG5cXG4gIHQgPSBub3JtYWxpemUodCAtIG5nICogZG90KG5nLCB0KSk7XFxuICB2ZWMzIGIgPSBub3JtYWxpemUoY3Jvc3MobmcsIHQpKTtcXG4gIG1hdDMgdGJuID0gbWF0Myh0LCBiLCBuZyk7XFxuI2Vsc2VcXG4gIG1hdDMgdGJuID0gcGJyX3ZUQk47XFxuI2VuZGlmXFxuXFxuI2lmZGVmIEhBU19OT1JNQUxNQVBcXG4gIHZlYzMgbiA9IHRleHR1cmUyRCh1X05vcm1hbFNhbXBsZXIsIHBicl92VVYpLnJnYjtcXG4gIG4gPSBub3JtYWxpemUodGJuICogKCgyLjAgKiBuIC0gMS4wKSAqIHZlYzModV9Ob3JtYWxTY2FsZSwgdV9Ob3JtYWxTY2FsZSwgMS4wKSkpO1xcbiNlbHNlXFxuICB2ZWMzIG4gPSBub3JtYWxpemUodGJuWzJdLnh5eik7XFxuI2VuZGlmXFxuXFxuICByZXR1cm4gbjtcXG59XFxuXFxuXFxuI2lmZGVmIFVTRV9JQkxcXG52ZWMzIGdldElCTENvbnRyaWJ1dGlvbihQQlJJbmZvIHBicklucHV0cywgdmVjMyBuLCB2ZWMzIHJlZmxlY3Rpb24pXFxue1xcbiAgZmxvYXQgbWlwQ291bnQgPSA5LjA7XFxuICBmbG9hdCBsb2QgPSAocGJySW5wdXRzLnBlcmNlcHR1YWxSb3VnaG5lc3MgKiBtaXBDb3VudCk7XFxuICB2ZWMzIGJyZGYgPSBTUkdCdG9MSU5FQVIodGV4dHVyZTJEKHVfYnJkZkxVVCxcXG4gICAgdmVjMihwYnJJbnB1dHMuTmRvdFYsIDEuMCAtIHBicklucHV0cy5wZXJjZXB0dWFsUm91Z2huZXNzKSkpLnJnYjtcXG4gIHZlYzMgZGlmZnVzZUxpZ2h0ID0gU1JHQnRvTElORUFSKHRleHR1cmVDdWJlKHVfRGlmZnVzZUVudlNhbXBsZXIsIG4pKS5yZ2I7XFxuXFxuI2lmZGVmIFVTRV9URVhfTE9EXFxuICB2ZWMzIHNwZWN1bGFyTGlnaHQgPSBTUkdCdG9MSU5FQVIodGV4dHVyZUN1YmVMb2QodV9TcGVjdWxhckVudlNhbXBsZXIsIHJlZmxlY3Rpb24sIGxvZCkpLnJnYjtcXG4jZWxzZVxcbiAgdmVjMyBzcGVjdWxhckxpZ2h0ID0gU1JHQnRvTElORUFSKHRleHR1cmVDdWJlKHVfU3BlY3VsYXJFbnZTYW1wbGVyLCByZWZsZWN0aW9uKSkucmdiO1xcbiNlbmRpZlxcblxcbiAgdmVjMyBkaWZmdXNlID0gZGlmZnVzZUxpZ2h0ICogcGJySW5wdXRzLmRpZmZ1c2VDb2xvcjtcXG4gIHZlYzMgc3BlY3VsYXIgPSBzcGVjdWxhckxpZ2h0ICogKHBicklucHV0cy5zcGVjdWxhckNvbG9yICogYnJkZi54ICsgYnJkZi55KTtcXG4gIGRpZmZ1c2UgKj0gdV9TY2FsZUlCTEFtYmllbnQueDtcXG4gIHNwZWN1bGFyICo9IHVfU2NhbGVJQkxBbWJpZW50Lnk7XFxuXFxuICByZXR1cm4gZGlmZnVzZSArIHNwZWN1bGFyO1xcbn1cXG4jZW5kaWZcXG5cXG5cXG52ZWMzIGRpZmZ1c2UoUEJSSW5mbyBwYnJJbnB1dHMpXFxue1xcbiAgcmV0dXJuIHBicklucHV0cy5kaWZmdXNlQ29sb3IgLyBNX1BJO1xcbn1cXG5cXG52ZWMzIHNwZWN1bGFyUmVmbGVjdGlvbihQQlJJbmZvIHBicklucHV0cylcXG57XFxuICByZXR1cm4gcGJySW5wdXRzLnJlZmxlY3RhbmNlMCArXFxuICAgIChwYnJJbnB1dHMucmVmbGVjdGFuY2U5MCAtIHBicklucHV0cy5yZWZsZWN0YW5jZTApICpcXG4gICAgcG93KGNsYW1wKDEuMCAtIHBicklucHV0cy5WZG90SCwgMC4wLCAxLjApLCA1LjApO1xcbn1cXG5cXG5cXG5cXG5mbG9hdCBnZW9tZXRyaWNPY2NsdXNpb24oUEJSSW5mbyBwYnJJbnB1dHMpXFxue1xcbiAgZmxvYXQgTmRvdEwgPSBwYnJJbnB1dHMuTmRvdEw7XFxuICBmbG9hdCBOZG90ViA9IHBicklucHV0cy5OZG90VjtcXG4gIGZsb2F0IHIgPSBwYnJJbnB1dHMuYWxwaGFSb3VnaG5lc3M7XFxuXFxuICBmbG9hdCBhdHRlbnVhdGlvbkwgPSAyLjAgKiBOZG90TCAvIChOZG90TCArIHNxcnQociAqIHIgKyAoMS4wIC0gciAqIHIpICogKE5kb3RMICogTmRvdEwpKSk7XFxuICBmbG9hdCBhdHRlbnVhdGlvblYgPSAyLjAgKiBOZG90ViAvIChOZG90ViArIHNxcnQociAqIHIgKyAoMS4wIC0gciAqIHIpICogKE5kb3RWICogTmRvdFYpKSk7XFxuICByZXR1cm4gYXR0ZW51YXRpb25MICogYXR0ZW51YXRpb25WO1xcbn1cXG5cXG5cXG5cXG5cXG5cXG5mbG9hdCBtaWNyb2ZhY2V0RGlzdHJpYnV0aW9uKFBCUkluZm8gcGJySW5wdXRzKVxcbntcXG4gIGZsb2F0IHJvdWdobmVzc1NxID0gcGJySW5wdXRzLmFscGhhUm91Z2huZXNzICogcGJySW5wdXRzLmFscGhhUm91Z2huZXNzO1xcbiAgZmxvYXQgZiA9IChwYnJJbnB1dHMuTmRvdEggKiByb3VnaG5lc3NTcSAtIHBicklucHV0cy5OZG90SCkgKiBwYnJJbnB1dHMuTmRvdEggKyAxLjA7XFxuICByZXR1cm4gcm91Z2huZXNzU3EgLyAoTV9QSSAqIGYgKiBmKTtcXG59XFxuXFxudm9pZCBQQlJJbmZvX3NldEFtYmllbnRMaWdodChpbm91dCBQQlJJbmZvIHBicklucHV0cykge1xcbiAgcGJySW5wdXRzLk5kb3RMID0gMS4wO1xcbiAgcGJySW5wdXRzLk5kb3RIID0gMC4wO1xcbiAgcGJySW5wdXRzLkxkb3RIID0gMC4wO1xcbiAgcGJySW5wdXRzLlZkb3RIID0gMS4wO1xcbn1cXG5cXG52b2lkIFBCUkluZm9fc2V0RGlyZWN0aW9uYWxMaWdodChpbm91dCBQQlJJbmZvIHBicklucHV0cywgdmVjMyBsaWdodERpcmVjdGlvbikge1xcbiAgdmVjMyBuID0gcGJySW5wdXRzLm47XFxuICB2ZWMzIHYgPSBwYnJJbnB1dHMudjtcXG4gIHZlYzMgbCA9IG5vcm1hbGl6ZShsaWdodERpcmVjdGlvbik7XFxuICB2ZWMzIGggPSBub3JtYWxpemUobCt2KTtcXG5cXG4gIHBicklucHV0cy5OZG90TCA9IGNsYW1wKGRvdChuLCBsKSwgMC4wMDEsIDEuMCk7XFxuICBwYnJJbnB1dHMuTmRvdEggPSBjbGFtcChkb3QobiwgaCksIDAuMCwgMS4wKTtcXG4gIHBicklucHV0cy5MZG90SCA9IGNsYW1wKGRvdChsLCBoKSwgMC4wLCAxLjApO1xcbiAgcGJySW5wdXRzLlZkb3RIID0gY2xhbXAoZG90KHYsIGgpLCAwLjAsIDEuMCk7XFxufVxcblxcbnZvaWQgUEJSSW5mb19zZXRQb2ludExpZ2h0KGlub3V0IFBCUkluZm8gcGJySW5wdXRzLCBQb2ludExpZ2h0IHBvaW50TGlnaHQpIHtcXG4gIHZlYzMgbGlnaHRfZGlyZWN0aW9uID0gbm9ybWFsaXplKHBvaW50TGlnaHQucG9zaXRpb24gLSBwYnJfdlBvc2l0aW9uKTtcXG4gIFBCUkluZm9fc2V0RGlyZWN0aW9uYWxMaWdodChwYnJJbnB1dHMsIGxpZ2h0X2RpcmVjdGlvbik7XFxufVxcblxcbnZlYzMgY2FsY3VsYXRlRmluYWxDb2xvcihQQlJJbmZvIHBicklucHV0cywgdmVjMyBsaWdodENvbG9yKSB7XFxuICB2ZWMzIEYgPSBzcGVjdWxhclJlZmxlY3Rpb24ocGJySW5wdXRzKTtcXG4gIGZsb2F0IEcgPSBnZW9tZXRyaWNPY2NsdXNpb24ocGJySW5wdXRzKTtcXG4gIGZsb2F0IEQgPSBtaWNyb2ZhY2V0RGlzdHJpYnV0aW9uKHBicklucHV0cyk7XFxuICB2ZWMzIGRpZmZ1c2VDb250cmliID0gKDEuMCAtIEYpICogZGlmZnVzZShwYnJJbnB1dHMpO1xcbiAgdmVjMyBzcGVjQ29udHJpYiA9IEYgKiBHICogRCAvICg0LjAgKiBwYnJJbnB1dHMuTmRvdEwgKiBwYnJJbnB1dHMuTmRvdFYpO1xcbiAgcmV0dXJuIHBicklucHV0cy5OZG90TCAqIGxpZ2h0Q29sb3IgKiAoZGlmZnVzZUNvbnRyaWIgKyBzcGVjQ29udHJpYik7XFxufVxcblxcbnZlYzQgcGJyX2ZpbHRlckNvbG9yKHZlYzQgY29sb3JVbnVzZWQpXFxue1xcbiNpZmRlZiBIQVNfQkFTRUNPTE9STUFQXFxuICB2ZWM0IGJhc2VDb2xvciA9IFNSR0J0b0xJTkVBUih0ZXh0dXJlMkQodV9CYXNlQ29sb3JTYW1wbGVyLCBwYnJfdlVWKSkgKiB1X0Jhc2VDb2xvckZhY3RvcjtcXG4jZWxzZVxcbiAgdmVjNCBiYXNlQ29sb3IgPSB1X0Jhc2VDb2xvckZhY3RvcjtcXG4jZW5kaWZcXG5cXG4jaWZkZWYgQUxQSEFfQ1VUT0ZGXFxuICBpZiAoYmFzZUNvbG9yLmEgPCB1X0FscGhhQ3V0b2ZmKSB7XFxuICAgIGRpc2NhcmQ7XFxuICB9XFxuI2VuZGlmXFxuXFxuICB2ZWMzIGNvbG9yID0gdmVjMygwLCAwLCAwKTtcXG5cXG4gIGlmKHBicl91VW5saXQpe1xcbiAgICBjb2xvci5yZ2IgPSBiYXNlQ29sb3IucmdiO1xcbiAgfVxcbiAgZWxzZXtcXG5cXG5cXG4gICAgZmxvYXQgcGVyY2VwdHVhbFJvdWdobmVzcyA9IHVfTWV0YWxsaWNSb3VnaG5lc3NWYWx1ZXMueTtcXG4gICAgZmxvYXQgbWV0YWxsaWMgPSB1X01ldGFsbGljUm91Z2huZXNzVmFsdWVzLng7XFxuI2lmZGVmIEhBU19NRVRBTFJPVUdITkVTU01BUFxcblxcbiAgICB2ZWM0IG1yU2FtcGxlID0gdGV4dHVyZTJEKHVfTWV0YWxsaWNSb3VnaG5lc3NTYW1wbGVyLCBwYnJfdlVWKTtcXG4gICAgcGVyY2VwdHVhbFJvdWdobmVzcyA9IG1yU2FtcGxlLmcgKiBwZXJjZXB0dWFsUm91Z2huZXNzO1xcbiAgICBtZXRhbGxpYyA9IG1yU2FtcGxlLmIgKiBtZXRhbGxpYztcXG4jZW5kaWZcXG4gICAgcGVyY2VwdHVhbFJvdWdobmVzcyA9IGNsYW1wKHBlcmNlcHR1YWxSb3VnaG5lc3MsIGNfTWluUm91Z2huZXNzLCAxLjApO1xcbiAgICBtZXRhbGxpYyA9IGNsYW1wKG1ldGFsbGljLCAwLjAsIDEuMCk7XFxuXFxuICAgIGZsb2F0IGFscGhhUm91Z2huZXNzID0gcGVyY2VwdHVhbFJvdWdobmVzcyAqIHBlcmNlcHR1YWxSb3VnaG5lc3M7XFxuXFxuICAgIHZlYzMgZjAgPSB2ZWMzKDAuMDQpO1xcbiAgICB2ZWMzIGRpZmZ1c2VDb2xvciA9IGJhc2VDb2xvci5yZ2IgKiAodmVjMygxLjApIC0gZjApO1xcbiAgICBkaWZmdXNlQ29sb3IgKj0gMS4wIC0gbWV0YWxsaWM7XFxuICAgIHZlYzMgc3BlY3VsYXJDb2xvciA9IG1peChmMCwgYmFzZUNvbG9yLnJnYiwgbWV0YWxsaWMpO1xcbiAgICBmbG9hdCByZWZsZWN0YW5jZSA9IG1heChtYXgoc3BlY3VsYXJDb2xvci5yLCBzcGVjdWxhckNvbG9yLmcpLCBzcGVjdWxhckNvbG9yLmIpO1xcblxcblxcblxcbiAgICBmbG9hdCByZWZsZWN0YW5jZTkwID0gY2xhbXAocmVmbGVjdGFuY2UgKiAyNS4wLCAwLjAsIDEuMCk7XFxuICAgIHZlYzMgc3BlY3VsYXJFbnZpcm9ubWVudFIwID0gc3BlY3VsYXJDb2xvci5yZ2I7XFxuICAgIHZlYzMgc3BlY3VsYXJFbnZpcm9ubWVudFI5MCA9IHZlYzMoMS4wLCAxLjAsIDEuMCkgKiByZWZsZWN0YW5jZTkwO1xcblxcbiAgICB2ZWMzIG4gPSBnZXROb3JtYWwoKTtcXG4gICAgdmVjMyB2ID0gbm9ybWFsaXplKHVfQ2FtZXJhIC0gcGJyX3ZQb3NpdGlvbik7XFxuXFxuICAgIGZsb2F0IE5kb3RWID0gY2xhbXAoYWJzKGRvdChuLCB2KSksIDAuMDAxLCAxLjApO1xcbiAgICB2ZWMzIHJlZmxlY3Rpb24gPSAtbm9ybWFsaXplKHJlZmxlY3QodiwgbikpO1xcblxcbiAgICBQQlJJbmZvIHBicklucHV0cyA9IFBCUkluZm8oXFxuICAgICAgMC4wLFxcbiAgICAgIE5kb3RWLFxcbiAgICAgIDAuMCxcXG4gICAgICAwLjAsXFxuICAgICAgMC4wLFxcbiAgICAgIHBlcmNlcHR1YWxSb3VnaG5lc3MsXFxuICAgICAgbWV0YWxsaWMsXFxuICAgICAgc3BlY3VsYXJFbnZpcm9ubWVudFIwLFxcbiAgICAgIHNwZWN1bGFyRW52aXJvbm1lbnRSOTAsXFxuICAgICAgYWxwaGFSb3VnaG5lc3MsXFxuICAgICAgZGlmZnVzZUNvbG9yLFxcbiAgICAgIHNwZWN1bGFyQ29sb3IsXFxuICAgICAgbixcXG4gICAgICB2XFxuICAgICk7XFxuXFxuI2lmZGVmIFVTRV9MSUdIVFNcXG4gICAgUEJSSW5mb19zZXRBbWJpZW50TGlnaHQocGJySW5wdXRzKTtcXG4gICAgY29sb3IgKz0gY2FsY3VsYXRlRmluYWxDb2xvcihwYnJJbnB1dHMsIGxpZ2h0aW5nX3VBbWJpZW50TGlnaHQuY29sb3IpO1xcbiAgICBTTUFSVF9GT1IoaW50IGkgPSAwLCBpIDwgTUFYX0xJR0hUUywgaSA8IGxpZ2h0aW5nX3VEaXJlY3Rpb25hbExpZ2h0Q291bnQsIGkrKykge1xcbiAgICAgIGlmIChpIDwgbGlnaHRpbmdfdURpcmVjdGlvbmFsTGlnaHRDb3VudCkge1xcbiAgICAgICAgUEJSSW5mb19zZXREaXJlY3Rpb25hbExpZ2h0KHBicklucHV0cywgbGlnaHRpbmdfdURpcmVjdGlvbmFsTGlnaHRbaV0uZGlyZWN0aW9uKTtcXG4gICAgICAgIGNvbG9yICs9IGNhbGN1bGF0ZUZpbmFsQ29sb3IocGJySW5wdXRzLCBsaWdodGluZ191RGlyZWN0aW9uYWxMaWdodFtpXS5jb2xvcik7XFxuICAgICAgfVxcbiAgICB9XFxuICAgIFNNQVJUX0ZPUihpbnQgaSA9IDAsIGkgPCBNQVhfTElHSFRTLCBpIDwgbGlnaHRpbmdfdVBvaW50TGlnaHRDb3VudCwgaSsrKSB7XFxuICAgICAgaWYgKGkgPCBsaWdodGluZ191UG9pbnRMaWdodENvdW50KSB7XFxuICAgICAgICBQQlJJbmZvX3NldFBvaW50TGlnaHQocGJySW5wdXRzLCBsaWdodGluZ191UG9pbnRMaWdodFtpXSk7XFxuICAgICAgICBmbG9hdCBhdHRlbnVhdGlvbiA9IGdldFBvaW50TGlnaHRBdHRlbnVhdGlvbihsaWdodGluZ191UG9pbnRMaWdodFtpXSwgZGlzdGFuY2UobGlnaHRpbmdfdVBvaW50TGlnaHRbaV0ucG9zaXRpb24sIHBicl92UG9zaXRpb24pKTtcXG4gICAgICAgIGNvbG9yICs9IGNhbGN1bGF0ZUZpbmFsQ29sb3IocGJySW5wdXRzLCBsaWdodGluZ191UG9pbnRMaWdodFtpXS5jb2xvciAvIGF0dGVudWF0aW9uKTtcXG4gICAgICB9XFxuICAgIH1cXG4jZW5kaWZcXG4jaWZkZWYgVVNFX0lCTFxcbiAgICBjb2xvciArPSBnZXRJQkxDb250cmlidXRpb24ocGJySW5wdXRzLCBuLCByZWZsZWN0aW9uKTtcXG4jZW5kaWZcXG4jaWZkZWYgSEFTX09DQ0xVU0lPTk1BUFxcbiAgICBmbG9hdCBhbyA9IHRleHR1cmUyRCh1X09jY2x1c2lvblNhbXBsZXIsIHBicl92VVYpLnI7XFxuICAgIGNvbG9yID0gbWl4KGNvbG9yLCBjb2xvciAqIGFvLCB1X09jY2x1c2lvblN0cmVuZ3RoKTtcXG4jZW5kaWZcXG5cXG4jaWZkZWYgSEFTX0VNSVNTSVZFTUFQXFxuICAgIHZlYzMgZW1pc3NpdmUgPSBTUkdCdG9MSU5FQVIodGV4dHVyZTJEKHVfRW1pc3NpdmVTYW1wbGVyLCBwYnJfdlVWKSkucmdiICogdV9FbWlzc2l2ZUZhY3RvcjtcXG4gICAgY29sb3IgKz0gZW1pc3NpdmU7XFxuI2VuZGlmXFxuXFxuI2lmZGVmIFBCUl9ERUJVR1xcblxcblxcblxcblxcblxcbiAgICBjb2xvciA9IG1peChjb2xvciwgYmFzZUNvbG9yLnJnYiwgdV9TY2FsZURpZmZCYXNlTVIueSk7XFxuICAgIGNvbG9yID0gbWl4KGNvbG9yLCB2ZWMzKG1ldGFsbGljKSwgdV9TY2FsZURpZmZCYXNlTVIueik7XFxuICAgIGNvbG9yID0gbWl4KGNvbG9yLCB2ZWMzKHBlcmNlcHR1YWxSb3VnaG5lc3MpLCB1X1NjYWxlRGlmZkJhc2VNUi53KTtcXG4jZW5kaWZcXG5cXG4gIH1cXG5cXG4gIHJldHVybiB2ZWM0KHBvdyhjb2xvcix2ZWMzKDEuMC8yLjIpKSwgYmFzZUNvbG9yLmEpO1xcbn1cXG5cIjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXBici1mcmFnbWVudC5nbHNsLmpzLm1hcCIsImltcG9ydCB7IGxpZ2h0cyB9IGZyb20gJy4uL2xpZ2h0cy9saWdodHMnO1xuaW1wb3J0IHZzIGZyb20gJy4vcGJyLXZlcnRleC5nbHNsJztcbmltcG9ydCBmcyBmcm9tICcuL3Bici1mcmFnbWVudC5nbHNsJztcbmV4cG9ydCBjb25zdCBwYnIgPSB7XG4gIG5hbWU6ICdwYnInLFxuICB2cyxcbiAgZnMsXG4gIGRlZmluZXM6IHtcbiAgICBMSUdIVElOR19GUkFHTUVOVDogMVxuICB9LFxuICBkZXBlbmRlbmNpZXM6IFtsaWdodHNdXG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cGJyLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///49764\n')},8674:function(__unused_webpack_module,__webpack_exports__,__webpack_require__){eval("\n// EXPORTS\n__webpack_require__.d(__webpack_exports__, {\n  \"N\": function() { return /* binding */ gouraudLighting; }\n});\n\n// UNUSED EXPORTS: phongLighting\n\n// EXTERNAL MODULE: ./node_modules/@luma.gl/shadertools/dist/esm/modules/lights/lights.js + 1 modules\nvar lights = __webpack_require__(66931);\n;// CONCATENATED MODULE: ./node_modules/@luma.gl/shadertools/dist/esm/modules/phong-lighting/phong-lighting.glsl.js\n/* harmony default export */ var phong_lighting_glsl = (\"\\nuniform float lighting_uAmbient;\\nuniform float lighting_uDiffuse;\\nuniform float lighting_uShininess;\\nuniform vec3  lighting_uSpecularColor;\\n\\nvec3 lighting_getLightColor(vec3 surfaceColor, vec3 light_direction, vec3 view_direction, vec3 normal_worldspace, vec3 color) {\\n    vec3 halfway_direction = normalize(light_direction + view_direction);\\n    float lambertian = dot(light_direction, normal_worldspace);\\n    float specular = 0.0;\\n    if (lambertian > 0.0) {\\n      float specular_angle = max(dot(normal_worldspace, halfway_direction), 0.0);\\n      specular = pow(specular_angle, lighting_uShininess);\\n    }\\n    lambertian = max(lambertian, 0.0);\\n    return (lambertian * lighting_uDiffuse * surfaceColor + specular * lighting_uSpecularColor) * color;\\n}\\n\\nvec3 lighting_getLightColor(vec3 surfaceColor, vec3 cameraPosition, vec3 position_worldspace, vec3 normal_worldspace) {\\n  vec3 lightColor = surfaceColor;\\n\\n  if (lighting_uEnabled) {\\n    vec3 view_direction = normalize(cameraPosition - position_worldspace);\\n    lightColor = lighting_uAmbient * surfaceColor * lighting_uAmbientLight.color;\\n\\n    for (int i = 0; i < MAX_LIGHTS; i++) {\\n      if (i >= lighting_uPointLightCount) {\\n        break;\\n      }\\n      PointLight pointLight = lighting_uPointLight[i];\\n      vec3 light_position_worldspace = pointLight.position;\\n      vec3 light_direction = normalize(light_position_worldspace - position_worldspace);\\n      lightColor += lighting_getLightColor(surfaceColor, light_direction, view_direction, normal_worldspace, pointLight.color);\\n    }\\n\\n    for (int i = 0; i < MAX_LIGHTS; i++) {\\n      if (i >= lighting_uDirectionalLightCount) {\\n        break;\\n      }\\n      DirectionalLight directionalLight = lighting_uDirectionalLight[i];\\n      lightColor += lighting_getLightColor(surfaceColor, -directionalLight.direction, view_direction, normal_worldspace, directionalLight.color);\\n    }\\n  }\\n  return lightColor;\\n}\\n\\nvec3 lighting_getSpecularLightColor(vec3 cameraPosition, vec3 position_worldspace, vec3 normal_worldspace) {\\n  vec3 lightColor = vec3(0, 0, 0);\\n  vec3 surfaceColor = vec3(0, 0, 0);\\n\\n  if (lighting_uEnabled) {\\n    vec3 view_direction = normalize(cameraPosition - position_worldspace);\\n\\n    for (int i = 0; i < MAX_LIGHTS; i++) {\\n      if (i >= lighting_uPointLightCount) {\\n        break;\\n      }\\n      PointLight pointLight = lighting_uPointLight[i];\\n      vec3 light_position_worldspace = pointLight.position;\\n      vec3 light_direction = normalize(light_position_worldspace - position_worldspace);\\n      lightColor += lighting_getLightColor(surfaceColor, light_direction, view_direction, normal_worldspace, pointLight.color);\\n    }\\n\\n    for (int i = 0; i < MAX_LIGHTS; i++) {\\n      if (i >= lighting_uDirectionalLightCount) {\\n        break;\\n      }\\n      DirectionalLight directionalLight = lighting_uDirectionalLight[i];\\n      lightColor += lighting_getLightColor(surfaceColor, -directionalLight.direction, view_direction, normal_worldspace, directionalLight.color);\\n    }\\n  }\\n  return lightColor;\\n}\\n\");\n//# sourceMappingURL=phong-lighting.glsl.js.map\n;// CONCATENATED MODULE: ./node_modules/@luma.gl/shadertools/dist/esm/modules/phong-lighting/phong-lighting.js\n\n\nconst INITIAL_MODULE_OPTIONS = {};\n\nfunction getMaterialUniforms(material) {\n  const {\n    ambient = 0.35,\n    diffuse = 0.6,\n    shininess = 32,\n    specularColor = [30, 30, 30]\n  } = material;\n  return {\n    lighting_uAmbient: ambient,\n    lighting_uDiffuse: diffuse,\n    lighting_uShininess: shininess,\n    lighting_uSpecularColor: specularColor.map(x => x / 255)\n  };\n}\n\nfunction getUniforms() {\n  let opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : INITIAL_MODULE_OPTIONS;\n\n  if (!('material' in opts)) {\n    return {};\n  }\n\n  const {\n    material\n  } = opts;\n\n  if (!material) {\n    return {\n      lighting_uEnabled: false\n    };\n  }\n\n  return getMaterialUniforms(material);\n}\n\nconst gouraudLighting = {\n  name: 'gouraud-lighting',\n  dependencies: [lights/* lights */.H],\n  vs: phong_lighting_glsl,\n  defines: {\n    LIGHTING_VERTEX: 1\n  },\n  getUniforms\n};\nconst phongLighting = {\n  name: 'phong-lighting',\n  dependencies: [lights/* lights */.H],\n  fs: phong_lighting_glsl,\n  defines: {\n    LIGHTING_FRAGMENT: 1\n  },\n  getUniforms\n};\n//# sourceMappingURL=phong-lighting.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiODY3NC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7OztBQUFBLHdEQUFlLG1DQUFtQyxrQ0FBa0Msb0NBQW9DLHdDQUF3QyxtSUFBbUksMkVBQTJFLGlFQUFpRSwyQkFBMkIsNkJBQTZCLG1GQUFtRiw0REFBNEQsT0FBTyx3Q0FBd0MsMEdBQTBHLEdBQUcsMkhBQTJILG1DQUFtQyw4QkFBOEIsNEVBQTRFLG1GQUFtRix3QkFBd0IsZ0JBQWdCLE1BQU0sNkNBQTZDLGdCQUFnQixTQUFTLHdEQUF3RCw2REFBNkQsMEZBQTBGLGlJQUFpSSxPQUFPLHdCQUF3QixnQkFBZ0IsTUFBTSxtREFBbUQsZ0JBQWdCLFNBQVMsMEVBQTBFLG1KQUFtSixPQUFPLEtBQUssc0JBQXNCLEdBQUcsZ0hBQWdILG9DQUFvQyxzQ0FBc0MsOEJBQThCLDRFQUE0RSx3QkFBd0IsZ0JBQWdCLE1BQU0sNkNBQTZDLGdCQUFnQixTQUFTLHdEQUF3RCw2REFBNkQsMEZBQTBGLGlJQUFpSSxPQUFPLHdCQUF3QixnQkFBZ0IsTUFBTSxtREFBbUQsZ0JBQWdCLFNBQVMsMEVBQTBFLG1KQUFtSixPQUFPLEtBQUssc0JBQXNCLEdBQUcsR0FBRyxFQUFDO0FBQ25pRywrQzs7QUNEMEM7QUFDUztBQUNuRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVPO0FBQ1A7QUFDQSxpQkFBaUIsb0JBQU07QUFDdkIsTUFBTSxtQkFBYztBQUNwQjtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDTztBQUNQO0FBQ0EsaUJBQWlCLG9CQUFNO0FBQ3ZCLE1BQU0sbUJBQWM7QUFDcEI7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly92dWUzLXdlYnBhY2s1Ly4vbm9kZV9tb2R1bGVzL0BsdW1hLmdsL3NoYWRlcnRvb2xzL2Rpc3QvZXNtL21vZHVsZXMvcGhvbmctbGlnaHRpbmcvcGhvbmctbGlnaHRpbmcuZ2xzbC5qcz8xZjQ4Iiwid2VicGFjazovL3Z1ZTMtd2VicGFjazUvLi9ub2RlX21vZHVsZXMvQGx1bWEuZ2wvc2hhZGVydG9vbHMvZGlzdC9lc20vbW9kdWxlcy9waG9uZy1saWdodGluZy9waG9uZy1saWdodGluZy5qcz9lNzRiIl0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCBkZWZhdWx0IFwiXFxudW5pZm9ybSBmbG9hdCBsaWdodGluZ191QW1iaWVudDtcXG51bmlmb3JtIGZsb2F0IGxpZ2h0aW5nX3VEaWZmdXNlO1xcbnVuaWZvcm0gZmxvYXQgbGlnaHRpbmdfdVNoaW5pbmVzcztcXG51bmlmb3JtIHZlYzMgIGxpZ2h0aW5nX3VTcGVjdWxhckNvbG9yO1xcblxcbnZlYzMgbGlnaHRpbmdfZ2V0TGlnaHRDb2xvcih2ZWMzIHN1cmZhY2VDb2xvciwgdmVjMyBsaWdodF9kaXJlY3Rpb24sIHZlYzMgdmlld19kaXJlY3Rpb24sIHZlYzMgbm9ybWFsX3dvcmxkc3BhY2UsIHZlYzMgY29sb3IpIHtcXG4gICAgdmVjMyBoYWxmd2F5X2RpcmVjdGlvbiA9IG5vcm1hbGl6ZShsaWdodF9kaXJlY3Rpb24gKyB2aWV3X2RpcmVjdGlvbik7XFxuICAgIGZsb2F0IGxhbWJlcnRpYW4gPSBkb3QobGlnaHRfZGlyZWN0aW9uLCBub3JtYWxfd29ybGRzcGFjZSk7XFxuICAgIGZsb2F0IHNwZWN1bGFyID0gMC4wO1xcbiAgICBpZiAobGFtYmVydGlhbiA+IDAuMCkge1xcbiAgICAgIGZsb2F0IHNwZWN1bGFyX2FuZ2xlID0gbWF4KGRvdChub3JtYWxfd29ybGRzcGFjZSwgaGFsZndheV9kaXJlY3Rpb24pLCAwLjApO1xcbiAgICAgIHNwZWN1bGFyID0gcG93KHNwZWN1bGFyX2FuZ2xlLCBsaWdodGluZ191U2hpbmluZXNzKTtcXG4gICAgfVxcbiAgICBsYW1iZXJ0aWFuID0gbWF4KGxhbWJlcnRpYW4sIDAuMCk7XFxuICAgIHJldHVybiAobGFtYmVydGlhbiAqIGxpZ2h0aW5nX3VEaWZmdXNlICogc3VyZmFjZUNvbG9yICsgc3BlY3VsYXIgKiBsaWdodGluZ191U3BlY3VsYXJDb2xvcikgKiBjb2xvcjtcXG59XFxuXFxudmVjMyBsaWdodGluZ19nZXRMaWdodENvbG9yKHZlYzMgc3VyZmFjZUNvbG9yLCB2ZWMzIGNhbWVyYVBvc2l0aW9uLCB2ZWMzIHBvc2l0aW9uX3dvcmxkc3BhY2UsIHZlYzMgbm9ybWFsX3dvcmxkc3BhY2UpIHtcXG4gIHZlYzMgbGlnaHRDb2xvciA9IHN1cmZhY2VDb2xvcjtcXG5cXG4gIGlmIChsaWdodGluZ191RW5hYmxlZCkge1xcbiAgICB2ZWMzIHZpZXdfZGlyZWN0aW9uID0gbm9ybWFsaXplKGNhbWVyYVBvc2l0aW9uIC0gcG9zaXRpb25fd29ybGRzcGFjZSk7XFxuICAgIGxpZ2h0Q29sb3IgPSBsaWdodGluZ191QW1iaWVudCAqIHN1cmZhY2VDb2xvciAqIGxpZ2h0aW5nX3VBbWJpZW50TGlnaHQuY29sb3I7XFxuXFxuICAgIGZvciAoaW50IGkgPSAwOyBpIDwgTUFYX0xJR0hUUzsgaSsrKSB7XFxuICAgICAgaWYgKGkgPj0gbGlnaHRpbmdfdVBvaW50TGlnaHRDb3VudCkge1xcbiAgICAgICAgYnJlYWs7XFxuICAgICAgfVxcbiAgICAgIFBvaW50TGlnaHQgcG9pbnRMaWdodCA9IGxpZ2h0aW5nX3VQb2ludExpZ2h0W2ldO1xcbiAgICAgIHZlYzMgbGlnaHRfcG9zaXRpb25fd29ybGRzcGFjZSA9IHBvaW50TGlnaHQucG9zaXRpb247XFxuICAgICAgdmVjMyBsaWdodF9kaXJlY3Rpb24gPSBub3JtYWxpemUobGlnaHRfcG9zaXRpb25fd29ybGRzcGFjZSAtIHBvc2l0aW9uX3dvcmxkc3BhY2UpO1xcbiAgICAgIGxpZ2h0Q29sb3IgKz0gbGlnaHRpbmdfZ2V0TGlnaHRDb2xvcihzdXJmYWNlQ29sb3IsIGxpZ2h0X2RpcmVjdGlvbiwgdmlld19kaXJlY3Rpb24sIG5vcm1hbF93b3JsZHNwYWNlLCBwb2ludExpZ2h0LmNvbG9yKTtcXG4gICAgfVxcblxcbiAgICBmb3IgKGludCBpID0gMDsgaSA8IE1BWF9MSUdIVFM7IGkrKykge1xcbiAgICAgIGlmIChpID49IGxpZ2h0aW5nX3VEaXJlY3Rpb25hbExpZ2h0Q291bnQpIHtcXG4gICAgICAgIGJyZWFrO1xcbiAgICAgIH1cXG4gICAgICBEaXJlY3Rpb25hbExpZ2h0IGRpcmVjdGlvbmFsTGlnaHQgPSBsaWdodGluZ191RGlyZWN0aW9uYWxMaWdodFtpXTtcXG4gICAgICBsaWdodENvbG9yICs9IGxpZ2h0aW5nX2dldExpZ2h0Q29sb3Ioc3VyZmFjZUNvbG9yLCAtZGlyZWN0aW9uYWxMaWdodC5kaXJlY3Rpb24sIHZpZXdfZGlyZWN0aW9uLCBub3JtYWxfd29ybGRzcGFjZSwgZGlyZWN0aW9uYWxMaWdodC5jb2xvcik7XFxuICAgIH1cXG4gIH1cXG4gIHJldHVybiBsaWdodENvbG9yO1xcbn1cXG5cXG52ZWMzIGxpZ2h0aW5nX2dldFNwZWN1bGFyTGlnaHRDb2xvcih2ZWMzIGNhbWVyYVBvc2l0aW9uLCB2ZWMzIHBvc2l0aW9uX3dvcmxkc3BhY2UsIHZlYzMgbm9ybWFsX3dvcmxkc3BhY2UpIHtcXG4gIHZlYzMgbGlnaHRDb2xvciA9IHZlYzMoMCwgMCwgMCk7XFxuICB2ZWMzIHN1cmZhY2VDb2xvciA9IHZlYzMoMCwgMCwgMCk7XFxuXFxuICBpZiAobGlnaHRpbmdfdUVuYWJsZWQpIHtcXG4gICAgdmVjMyB2aWV3X2RpcmVjdGlvbiA9IG5vcm1hbGl6ZShjYW1lcmFQb3NpdGlvbiAtIHBvc2l0aW9uX3dvcmxkc3BhY2UpO1xcblxcbiAgICBmb3IgKGludCBpID0gMDsgaSA8IE1BWF9MSUdIVFM7IGkrKykge1xcbiAgICAgIGlmIChpID49IGxpZ2h0aW5nX3VQb2ludExpZ2h0Q291bnQpIHtcXG4gICAgICAgIGJyZWFrO1xcbiAgICAgIH1cXG4gICAgICBQb2ludExpZ2h0IHBvaW50TGlnaHQgPSBsaWdodGluZ191UG9pbnRMaWdodFtpXTtcXG4gICAgICB2ZWMzIGxpZ2h0X3Bvc2l0aW9uX3dvcmxkc3BhY2UgPSBwb2ludExpZ2h0LnBvc2l0aW9uO1xcbiAgICAgIHZlYzMgbGlnaHRfZGlyZWN0aW9uID0gbm9ybWFsaXplKGxpZ2h0X3Bvc2l0aW9uX3dvcmxkc3BhY2UgLSBwb3NpdGlvbl93b3JsZHNwYWNlKTtcXG4gICAgICBsaWdodENvbG9yICs9IGxpZ2h0aW5nX2dldExpZ2h0Q29sb3Ioc3VyZmFjZUNvbG9yLCBsaWdodF9kaXJlY3Rpb24sIHZpZXdfZGlyZWN0aW9uLCBub3JtYWxfd29ybGRzcGFjZSwgcG9pbnRMaWdodC5jb2xvcik7XFxuICAgIH1cXG5cXG4gICAgZm9yIChpbnQgaSA9IDA7IGkgPCBNQVhfTElHSFRTOyBpKyspIHtcXG4gICAgICBpZiAoaSA+PSBsaWdodGluZ191RGlyZWN0aW9uYWxMaWdodENvdW50KSB7XFxuICAgICAgICBicmVhaztcXG4gICAgICB9XFxuICAgICAgRGlyZWN0aW9uYWxMaWdodCBkaXJlY3Rpb25hbExpZ2h0ID0gbGlnaHRpbmdfdURpcmVjdGlvbmFsTGlnaHRbaV07XFxuICAgICAgbGlnaHRDb2xvciArPSBsaWdodGluZ19nZXRMaWdodENvbG9yKHN1cmZhY2VDb2xvciwgLWRpcmVjdGlvbmFsTGlnaHQuZGlyZWN0aW9uLCB2aWV3X2RpcmVjdGlvbiwgbm9ybWFsX3dvcmxkc3BhY2UsIGRpcmVjdGlvbmFsTGlnaHQuY29sb3IpO1xcbiAgICB9XFxuICB9XFxuICByZXR1cm4gbGlnaHRDb2xvcjtcXG59XFxuXCI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1waG9uZy1saWdodGluZy5nbHNsLmpzLm1hcCIsImltcG9ydCB7IGxpZ2h0cyB9IGZyb20gJy4uL2xpZ2h0cy9saWdodHMnO1xuaW1wb3J0IGxpZ2h0aW5nU2hhZGVyIGZyb20gJy4vcGhvbmctbGlnaHRpbmcuZ2xzbCc7XG5jb25zdCBJTklUSUFMX01PRFVMRV9PUFRJT05TID0ge307XG5cbmZ1bmN0aW9uIGdldE1hdGVyaWFsVW5pZm9ybXMobWF0ZXJpYWwpIHtcbiAgY29uc3Qge1xuICAgIGFtYmllbnQgPSAwLjM1LFxuICAgIGRpZmZ1c2UgPSAwLjYsXG4gICAgc2hpbmluZXNzID0gMzIsXG4gICAgc3BlY3VsYXJDb2xvciA9IFszMCwgMzAsIDMwXVxuICB9ID0gbWF0ZXJpYWw7XG4gIHJldHVybiB7XG4gICAgbGlnaHRpbmdfdUFtYmllbnQ6IGFtYmllbnQsXG4gICAgbGlnaHRpbmdfdURpZmZ1c2U6IGRpZmZ1c2UsXG4gICAgbGlnaHRpbmdfdVNoaW5pbmVzczogc2hpbmluZXNzLFxuICAgIGxpZ2h0aW5nX3VTcGVjdWxhckNvbG9yOiBzcGVjdWxhckNvbG9yLm1hcCh4ID0+IHggLyAyNTUpXG4gIH07XG59XG5cbmZ1bmN0aW9uIGdldFVuaWZvcm1zKCkge1xuICBsZXQgb3B0cyA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogSU5JVElBTF9NT0RVTEVfT1BUSU9OUztcblxuICBpZiAoISgnbWF0ZXJpYWwnIGluIG9wdHMpKSB7XG4gICAgcmV0dXJuIHt9O1xuICB9XG5cbiAgY29uc3Qge1xuICAgIG1hdGVyaWFsXG4gIH0gPSBvcHRzO1xuXG4gIGlmICghbWF0ZXJpYWwpIHtcbiAgICByZXR1cm4ge1xuICAgICAgbGlnaHRpbmdfdUVuYWJsZWQ6IGZhbHNlXG4gICAgfTtcbiAgfVxuXG4gIHJldHVybiBnZXRNYXRlcmlhbFVuaWZvcm1zKG1hdGVyaWFsKTtcbn1cblxuZXhwb3J0IGNvbnN0IGdvdXJhdWRMaWdodGluZyA9IHtcbiAgbmFtZTogJ2dvdXJhdWQtbGlnaHRpbmcnLFxuICBkZXBlbmRlbmNpZXM6IFtsaWdodHNdLFxuICB2czogbGlnaHRpbmdTaGFkZXIsXG4gIGRlZmluZXM6IHtcbiAgICBMSUdIVElOR19WRVJURVg6IDFcbiAgfSxcbiAgZ2V0VW5pZm9ybXNcbn07XG5leHBvcnQgY29uc3QgcGhvbmdMaWdodGluZyA9IHtcbiAgbmFtZTogJ3Bob25nLWxpZ2h0aW5nJyxcbiAgZGVwZW5kZW5jaWVzOiBbbGlnaHRzXSxcbiAgZnM6IGxpZ2h0aW5nU2hhZGVyLFxuICBkZWZpbmVzOiB7XG4gICAgTElHSFRJTkdfRlJBR01FTlQ6IDFcbiAgfSxcbiAgZ2V0VW5pZm9ybXNcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1waG9uZy1saWdodGluZy5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///8674\n")},83330:function(__unused_webpack_module,__webpack_exports__,__webpack_require__){eval('/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "q": function() { return /* binding */ picking; }\n/* harmony export */ });\nconst DEFAULT_HIGHLIGHT_COLOR = new Uint8Array([0, 255, 255, 255]);\nconst DEFAULT_MODULE_OPTIONS = {\n  pickingSelectedColor: null,\n  pickingHighlightColor: DEFAULT_HIGHLIGHT_COLOR,\n  pickingActive: false,\n  pickingAttribute: false\n};\n\nfunction getUniforms() {\n  let opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : DEFAULT_MODULE_OPTIONS;\n  const uniforms = {};\n\n  if (opts.pickingSelectedColor !== undefined) {\n    if (!opts.pickingSelectedColor) {\n      uniforms.picking_uSelectedColorValid = 0;\n    } else {\n      const selectedColor = opts.pickingSelectedColor.slice(0, 3);\n      uniforms.picking_uSelectedColorValid = 1;\n      uniforms.picking_uSelectedColor = selectedColor;\n    }\n  }\n\n  if (opts.pickingHighlightColor) {\n    const color = Array.from(opts.pickingHighlightColor, x => x / 255);\n\n    if (!Number.isFinite(color[3])) {\n      color[3] = 1;\n    }\n\n    uniforms.picking_uHighlightColor = color;\n  }\n\n  if (opts.pickingActive !== undefined) {\n    uniforms.picking_uActive = Boolean(opts.pickingActive);\n    uniforms.picking_uAttribute = Boolean(opts.pickingAttribute);\n  }\n\n  return uniforms;\n}\n\nconst vs = "uniform bool picking_uActive;\\nuniform bool picking_uAttribute;\\nuniform vec3 picking_uSelectedColor;\\nuniform bool picking_uSelectedColorValid;\\n\\nout vec4 picking_vRGBcolor_Avalid;\\n\\nconst float COLOR_SCALE = 1. / 255.;\\n\\nbool picking_isColorValid(vec3 color) {\\n  return dot(color, vec3(1.0)) > 0.001;\\n}\\n\\nbool isVertexPicked(vec3 vertexColor) {\\n  return\\n    picking_uSelectedColorValid &&\\n    !picking_isColorValid(abs(vertexColor - picking_uSelectedColor));\\n}\\n\\nvoid picking_setPickingColor(vec3 pickingColor) {\\n  if (picking_uActive) {\\n    picking_vRGBcolor_Avalid.a = float(picking_isColorValid(pickingColor));\\n\\n    if (!picking_uAttribute) {\\n      picking_vRGBcolor_Avalid.rgb = pickingColor * COLOR_SCALE;\\n    }\\n  } else {\\n    picking_vRGBcolor_Avalid.a = float(isVertexPicked(pickingColor));\\n  }\\n}\\n\\nvoid picking_setPickingAttribute(float value) {\\n  if (picking_uAttribute) {\\n    picking_vRGBcolor_Avalid.r = value;\\n  }\\n}\\nvoid picking_setPickingAttribute(vec2 value) {\\n  if (picking_uAttribute) {\\n    picking_vRGBcolor_Avalid.rg = value;\\n  }\\n}\\nvoid picking_setPickingAttribute(vec3 value) {\\n  if (picking_uAttribute) {\\n    picking_vRGBcolor_Avalid.rgb = value;\\n  }\\n}\\n";\nconst fs = "uniform bool picking_uActive;\\nuniform vec3 picking_uSelectedColor;\\nuniform vec4 picking_uHighlightColor;\\n\\nin vec4 picking_vRGBcolor_Avalid;\\nvec4 picking_filterHighlightColor(vec4 color) {\\n  if (picking_uActive) {\\n    return color;\\n  }\\n  bool selected = bool(picking_vRGBcolor_Avalid.a);\\n\\n  if (selected) {\\n    float highLightAlpha = picking_uHighlightColor.a;\\n    float blendedAlpha = highLightAlpha + color.a * (1.0 - highLightAlpha);\\n    float highLightRatio = highLightAlpha / blendedAlpha;\\n\\n    vec3 blendedRGB = mix(color.rgb, picking_uHighlightColor.rgb, highLightRatio);\\n    return vec4(blendedRGB, blendedAlpha);\\n  } else {\\n    return color;\\n  }\\n}\\nvec4 picking_filterPickingColor(vec4 color) {\\n  if (picking_uActive) {\\n    if (picking_vRGBcolor_Avalid.a == 0.0) {\\n      discard;\\n    }\\n    return picking_vRGBcolor_Avalid;\\n  }\\n  return color;\\n}\\nvec4 picking_filterColor(vec4 color) {\\n  vec4 highightColor = picking_filterHighlightColor(color);\\n  return picking_filterPickingColor(highightColor);\\n}\\n\\n";\nconst picking = {\n  name: \'picking\',\n  vs,\n  fs,\n  getUniforms\n};\n//# sourceMappingURL=picking.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiODMzMzAuanMiLCJtYXBwaW5ncyI6Ijs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSx5Q0FBeUMsa0NBQWtDLHNDQUFzQywyQ0FBMkMsc0NBQXNDLHdDQUF3QywyQ0FBMkMseUNBQXlDLEdBQUcsMkNBQTJDLHFIQUFxSCxHQUFHLHFEQUFxRCwwQkFBMEIsNkVBQTZFLGtDQUFrQyxrRUFBa0UsT0FBTyxNQUFNLE1BQU0sdUVBQXVFLEtBQUssR0FBRyxtREFBbUQsNkJBQTZCLHlDQUF5QyxLQUFLLEdBQUcsZ0RBQWdELDZCQUE2QiwwQ0FBMEMsS0FBSyxHQUFHLGdEQUFnRCw2QkFBNkIsMkNBQTJDLEtBQUssR0FBRztBQUN0c0MseUNBQXlDLHNDQUFzQyx1Q0FBdUMscUNBQXFDLGlEQUFpRCwwQkFBMEIsbUJBQW1CLEtBQUsscURBQXFELHFCQUFxQix1REFBdUQsNkVBQTZFLDJEQUEyRCxzRkFBc0YsNENBQTRDLE1BQU0sTUFBTSxtQkFBbUIsS0FBSyxHQUFHLCtDQUErQywwQkFBMEIsOENBQThDLGdCQUFnQixPQUFPLHNDQUFzQyxLQUFLLGlCQUFpQixHQUFHLHdDQUF3Qyw2REFBNkQscURBQXFELEdBQUc7QUFDbmhDO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdnVlMy13ZWJwYWNrNS8uL25vZGVfbW9kdWxlcy9AbHVtYS5nbC9zaGFkZXJ0b29scy9kaXN0L2VzbS9tb2R1bGVzL3BpY2tpbmcvcGlja2luZy5qcz9mODRkIl0sInNvdXJjZXNDb250ZW50IjpbImNvbnN0IERFRkFVTFRfSElHSExJR0hUX0NPTE9SID0gbmV3IFVpbnQ4QXJyYXkoWzAsIDI1NSwgMjU1LCAyNTVdKTtcbmNvbnN0IERFRkFVTFRfTU9EVUxFX09QVElPTlMgPSB7XG4gIHBpY2tpbmdTZWxlY3RlZENvbG9yOiBudWxsLFxuICBwaWNraW5nSGlnaGxpZ2h0Q29sb3I6IERFRkFVTFRfSElHSExJR0hUX0NPTE9SLFxuICBwaWNraW5nQWN0aXZlOiBmYWxzZSxcbiAgcGlja2luZ0F0dHJpYnV0ZTogZmFsc2Vcbn07XG5cbmZ1bmN0aW9uIGdldFVuaWZvcm1zKCkge1xuICBsZXQgb3B0cyA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogREVGQVVMVF9NT0RVTEVfT1BUSU9OUztcbiAgY29uc3QgdW5pZm9ybXMgPSB7fTtcblxuICBpZiAob3B0cy5waWNraW5nU2VsZWN0ZWRDb2xvciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgaWYgKCFvcHRzLnBpY2tpbmdTZWxlY3RlZENvbG9yKSB7XG4gICAgICB1bmlmb3Jtcy5waWNraW5nX3VTZWxlY3RlZENvbG9yVmFsaWQgPSAwO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBzZWxlY3RlZENvbG9yID0gb3B0cy5waWNraW5nU2VsZWN0ZWRDb2xvci5zbGljZSgwLCAzKTtcbiAgICAgIHVuaWZvcm1zLnBpY2tpbmdfdVNlbGVjdGVkQ29sb3JWYWxpZCA9IDE7XG4gICAgICB1bmlmb3Jtcy5waWNraW5nX3VTZWxlY3RlZENvbG9yID0gc2VsZWN0ZWRDb2xvcjtcbiAgICB9XG4gIH1cblxuICBpZiAob3B0cy5waWNraW5nSGlnaGxpZ2h0Q29sb3IpIHtcbiAgICBjb25zdCBjb2xvciA9IEFycmF5LmZyb20ob3B0cy5waWNraW5nSGlnaGxpZ2h0Q29sb3IsIHggPT4geCAvIDI1NSk7XG5cbiAgICBpZiAoIU51bWJlci5pc0Zpbml0ZShjb2xvclszXSkpIHtcbiAgICAgIGNvbG9yWzNdID0gMTtcbiAgICB9XG5cbiAgICB1bmlmb3Jtcy5waWNraW5nX3VIaWdobGlnaHRDb2xvciA9IGNvbG9yO1xuICB9XG5cbiAgaWYgKG9wdHMucGlja2luZ0FjdGl2ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgdW5pZm9ybXMucGlja2luZ191QWN0aXZlID0gQm9vbGVhbihvcHRzLnBpY2tpbmdBY3RpdmUpO1xuICAgIHVuaWZvcm1zLnBpY2tpbmdfdUF0dHJpYnV0ZSA9IEJvb2xlYW4ob3B0cy5waWNraW5nQXR0cmlidXRlKTtcbiAgfVxuXG4gIHJldHVybiB1bmlmb3Jtcztcbn1cblxuY29uc3QgdnMgPSBcInVuaWZvcm0gYm9vbCBwaWNraW5nX3VBY3RpdmU7XFxudW5pZm9ybSBib29sIHBpY2tpbmdfdUF0dHJpYnV0ZTtcXG51bmlmb3JtIHZlYzMgcGlja2luZ191U2VsZWN0ZWRDb2xvcjtcXG51bmlmb3JtIGJvb2wgcGlja2luZ191U2VsZWN0ZWRDb2xvclZhbGlkO1xcblxcbm91dCB2ZWM0IHBpY2tpbmdfdlJHQmNvbG9yX0F2YWxpZDtcXG5cXG5jb25zdCBmbG9hdCBDT0xPUl9TQ0FMRSA9IDEuIC8gMjU1LjtcXG5cXG5ib29sIHBpY2tpbmdfaXNDb2xvclZhbGlkKHZlYzMgY29sb3IpIHtcXG4gIHJldHVybiBkb3QoY29sb3IsIHZlYzMoMS4wKSkgPiAwLjAwMTtcXG59XFxuXFxuYm9vbCBpc1ZlcnRleFBpY2tlZCh2ZWMzIHZlcnRleENvbG9yKSB7XFxuICByZXR1cm5cXG4gICAgcGlja2luZ191U2VsZWN0ZWRDb2xvclZhbGlkICYmXFxuICAgICFwaWNraW5nX2lzQ29sb3JWYWxpZChhYnModmVydGV4Q29sb3IgLSBwaWNraW5nX3VTZWxlY3RlZENvbG9yKSk7XFxufVxcblxcbnZvaWQgcGlja2luZ19zZXRQaWNraW5nQ29sb3IodmVjMyBwaWNraW5nQ29sb3IpIHtcXG4gIGlmIChwaWNraW5nX3VBY3RpdmUpIHtcXG4gICAgcGlja2luZ192UkdCY29sb3JfQXZhbGlkLmEgPSBmbG9hdChwaWNraW5nX2lzQ29sb3JWYWxpZChwaWNraW5nQ29sb3IpKTtcXG5cXG4gICAgaWYgKCFwaWNraW5nX3VBdHRyaWJ1dGUpIHtcXG4gICAgICBwaWNraW5nX3ZSR0Jjb2xvcl9BdmFsaWQucmdiID0gcGlja2luZ0NvbG9yICogQ09MT1JfU0NBTEU7XFxuICAgIH1cXG4gIH0gZWxzZSB7XFxuICAgIHBpY2tpbmdfdlJHQmNvbG9yX0F2YWxpZC5hID0gZmxvYXQoaXNWZXJ0ZXhQaWNrZWQocGlja2luZ0NvbG9yKSk7XFxuICB9XFxufVxcblxcbnZvaWQgcGlja2luZ19zZXRQaWNraW5nQXR0cmlidXRlKGZsb2F0IHZhbHVlKSB7XFxuICBpZiAocGlja2luZ191QXR0cmlidXRlKSB7XFxuICAgIHBpY2tpbmdfdlJHQmNvbG9yX0F2YWxpZC5yID0gdmFsdWU7XFxuICB9XFxufVxcbnZvaWQgcGlja2luZ19zZXRQaWNraW5nQXR0cmlidXRlKHZlYzIgdmFsdWUpIHtcXG4gIGlmIChwaWNraW5nX3VBdHRyaWJ1dGUpIHtcXG4gICAgcGlja2luZ192UkdCY29sb3JfQXZhbGlkLnJnID0gdmFsdWU7XFxuICB9XFxufVxcbnZvaWQgcGlja2luZ19zZXRQaWNraW5nQXR0cmlidXRlKHZlYzMgdmFsdWUpIHtcXG4gIGlmIChwaWNraW5nX3VBdHRyaWJ1dGUpIHtcXG4gICAgcGlja2luZ192UkdCY29sb3JfQXZhbGlkLnJnYiA9IHZhbHVlO1xcbiAgfVxcbn1cXG5cIjtcbmNvbnN0IGZzID0gXCJ1bmlmb3JtIGJvb2wgcGlja2luZ191QWN0aXZlO1xcbnVuaWZvcm0gdmVjMyBwaWNraW5nX3VTZWxlY3RlZENvbG9yO1xcbnVuaWZvcm0gdmVjNCBwaWNraW5nX3VIaWdobGlnaHRDb2xvcjtcXG5cXG5pbiB2ZWM0IHBpY2tpbmdfdlJHQmNvbG9yX0F2YWxpZDtcXG52ZWM0IHBpY2tpbmdfZmlsdGVySGlnaGxpZ2h0Q29sb3IodmVjNCBjb2xvcikge1xcbiAgaWYgKHBpY2tpbmdfdUFjdGl2ZSkge1xcbiAgICByZXR1cm4gY29sb3I7XFxuICB9XFxuICBib29sIHNlbGVjdGVkID0gYm9vbChwaWNraW5nX3ZSR0Jjb2xvcl9BdmFsaWQuYSk7XFxuXFxuICBpZiAoc2VsZWN0ZWQpIHtcXG4gICAgZmxvYXQgaGlnaExpZ2h0QWxwaGEgPSBwaWNraW5nX3VIaWdobGlnaHRDb2xvci5hO1xcbiAgICBmbG9hdCBibGVuZGVkQWxwaGEgPSBoaWdoTGlnaHRBbHBoYSArIGNvbG9yLmEgKiAoMS4wIC0gaGlnaExpZ2h0QWxwaGEpO1xcbiAgICBmbG9hdCBoaWdoTGlnaHRSYXRpbyA9IGhpZ2hMaWdodEFscGhhIC8gYmxlbmRlZEFscGhhO1xcblxcbiAgICB2ZWMzIGJsZW5kZWRSR0IgPSBtaXgoY29sb3IucmdiLCBwaWNraW5nX3VIaWdobGlnaHRDb2xvci5yZ2IsIGhpZ2hMaWdodFJhdGlvKTtcXG4gICAgcmV0dXJuIHZlYzQoYmxlbmRlZFJHQiwgYmxlbmRlZEFscGhhKTtcXG4gIH0gZWxzZSB7XFxuICAgIHJldHVybiBjb2xvcjtcXG4gIH1cXG59XFxudmVjNCBwaWNraW5nX2ZpbHRlclBpY2tpbmdDb2xvcih2ZWM0IGNvbG9yKSB7XFxuICBpZiAocGlja2luZ191QWN0aXZlKSB7XFxuICAgIGlmIChwaWNraW5nX3ZSR0Jjb2xvcl9BdmFsaWQuYSA9PSAwLjApIHtcXG4gICAgICBkaXNjYXJkO1xcbiAgICB9XFxuICAgIHJldHVybiBwaWNraW5nX3ZSR0Jjb2xvcl9BdmFsaWQ7XFxuICB9XFxuICByZXR1cm4gY29sb3I7XFxufVxcbnZlYzQgcGlja2luZ19maWx0ZXJDb2xvcih2ZWM0IGNvbG9yKSB7XFxuICB2ZWM0IGhpZ2hpZ2h0Q29sb3IgPSBwaWNraW5nX2ZpbHRlckhpZ2hsaWdodENvbG9yKGNvbG9yKTtcXG4gIHJldHVybiBwaWNraW5nX2ZpbHRlclBpY2tpbmdDb2xvcihoaWdoaWdodENvbG9yKTtcXG59XFxuXFxuXCI7XG5leHBvcnQgY29uc3QgcGlja2luZyA9IHtcbiAgbmFtZTogJ3BpY2tpbmcnLFxuICB2cyxcbiAgZnMsXG4gIGdldFVuaWZvcm1zXG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cGlja2luZy5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///83330\n')},29047:function(__unused_webpack_module,__webpack_exports__,__webpack_require__){eval("/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Z\": function() { return /* binding */ assert; }\n/* harmony export */ });\nfunction assert(condition, message) {\n  if (!condition) {\n    throw new Error(message || 'shadertools: assertion failed.');\n  }\n}\n//# sourceMappingURL=assert.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjkwNDcuanMiLCJtYXBwaW5ncyI6Ijs7O0FBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdnVlMy13ZWJwYWNrNS8uL25vZGVfbW9kdWxlcy9AbHVtYS5nbC9zaGFkZXJ0b29scy9kaXN0L2VzbS91dGlscy9hc3NlcnQuanM/ZGU5NCJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBhc3NlcnQoY29uZGl0aW9uLCBtZXNzYWdlKSB7XG4gIGlmICghY29uZGl0aW9uKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKG1lc3NhZ2UgfHwgJ3NoYWRlcnRvb2xzOiBhc3NlcnRpb24gZmFpbGVkLicpO1xuICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1hc3NlcnQuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///29047\n")}}]);