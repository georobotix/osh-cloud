"use strict";(self["webpackChunkvue3_webpack5"]=self["webpackChunkvue3_webpack5"]||[]).push([[9046],{20909:function(__unused_webpack___webpack_module__,__webpack_exports__){eval('//This file is automatically rebuilt by the Cesium build process.\n/* harmony default export */ __webpack_exports__["Z"] = ("uniform vec4 u_initialColor;\\n\\\n\\n\\\n#if TEXTURE_UNITS > 0\\n\\\nuniform sampler2D u_dayTextures[TEXTURE_UNITS];\\n\\\nuniform vec4 u_dayTextureTranslationAndScale[TEXTURE_UNITS];\\n\\\nuniform bool u_dayTextureUseWebMercatorT[TEXTURE_UNITS];\\n\\\n\\n\\\n#ifdef APPLY_ALPHA\\n\\\nuniform float u_dayTextureAlpha[TEXTURE_UNITS];\\n\\\n#endif\\n\\\n\\n\\\n#ifdef APPLY_DAY_NIGHT_ALPHA\\n\\\nuniform float u_dayTextureNightAlpha[TEXTURE_UNITS];\\n\\\nuniform float u_dayTextureDayAlpha[TEXTURE_UNITS];\\n\\\n#endif\\n\\\n\\n\\\n#ifdef APPLY_SPLIT\\n\\\nuniform float u_dayTextureSplit[TEXTURE_UNITS];\\n\\\n#endif\\n\\\n\\n\\\n#ifdef APPLY_BRIGHTNESS\\n\\\nuniform float u_dayTextureBrightness[TEXTURE_UNITS];\\n\\\n#endif\\n\\\n\\n\\\n#ifdef APPLY_CONTRAST\\n\\\nuniform float u_dayTextureContrast[TEXTURE_UNITS];\\n\\\n#endif\\n\\\n\\n\\\n#ifdef APPLY_HUE\\n\\\nuniform float u_dayTextureHue[TEXTURE_UNITS];\\n\\\n#endif\\n\\\n\\n\\\n#ifdef APPLY_SATURATION\\n\\\nuniform float u_dayTextureSaturation[TEXTURE_UNITS];\\n\\\n#endif\\n\\\n\\n\\\n#ifdef APPLY_GAMMA\\n\\\nuniform float u_dayTextureOneOverGamma[TEXTURE_UNITS];\\n\\\n#endif\\n\\\n\\n\\\n#ifdef APPLY_IMAGERY_CUTOUT\\n\\\nuniform vec4 u_dayTextureCutoutRectangles[TEXTURE_UNITS];\\n\\\n#endif\\n\\\n\\n\\\n#ifdef APPLY_COLOR_TO_ALPHA\\n\\\nuniform vec4 u_colorsToAlpha[TEXTURE_UNITS];\\n\\\n#endif\\n\\\n\\n\\\nuniform vec4 u_dayTextureTexCoordsRectangle[TEXTURE_UNITS];\\n\\\n#endif\\n\\\n\\n\\\n#ifdef SHOW_REFLECTIVE_OCEAN\\n\\\nuniform sampler2D u_waterMask;\\n\\\nuniform vec4 u_waterMaskTranslationAndScale;\\n\\\nuniform float u_zoomedOutOceanSpecularIntensity;\\n\\\n#endif\\n\\\n\\n\\\n#ifdef SHOW_OCEAN_WAVES\\n\\\nuniform sampler2D u_oceanNormalMap;\\n\\\n#endif\\n\\\n\\n\\\n#if defined(ENABLE_DAYNIGHT_SHADING) || defined(GROUND_ATMOSPHERE)\\n\\\nuniform vec2 u_lightingFadeDistance;\\n\\\n#endif\\n\\\n\\n\\\n#ifdef TILE_LIMIT_RECTANGLE\\n\\\nuniform vec4 u_cartographicLimitRectangle;\\n\\\n#endif\\n\\\n\\n\\\n#ifdef GROUND_ATMOSPHERE\\n\\\nuniform vec2 u_nightFadeDistance;\\n\\\n#endif\\n\\\n\\n\\\n#ifdef ENABLE_CLIPPING_PLANES\\n\\\nuniform highp sampler2D u_clippingPlanes;\\n\\\nuniform mat4 u_clippingPlanesMatrix;\\n\\\nuniform vec4 u_clippingPlanesEdgeStyle;\\n\\\n#endif\\n\\\n\\n\\\n#if defined(FOG) && defined(DYNAMIC_ATMOSPHERE_LIGHTING) && (defined(ENABLE_VERTEX_LIGHTING) || defined(ENABLE_DAYNIGHT_SHADING))\\n\\\nuniform float u_minimumBrightness;\\n\\\n#endif\\n\\\n\\n\\\n#ifdef COLOR_CORRECT\\n\\\nuniform vec3 u_hsbShift; // Hue, saturation, brightness\\n\\\n#endif\\n\\\n\\n\\\n#ifdef HIGHLIGHT_FILL_TILE\\n\\\nuniform vec4 u_fillHighlightColor;\\n\\\n#endif\\n\\\n\\n\\\n#ifdef TRANSLUCENT\\n\\\nuniform vec4 u_frontFaceAlphaByDistance;\\n\\\nuniform vec4 u_backFaceAlphaByDistance;\\n\\\nuniform vec4 u_translucencyRectangle;\\n\\\n#endif\\n\\\n\\n\\\n#ifdef UNDERGROUND_COLOR\\n\\\nuniform vec4 u_undergroundColor;\\n\\\nuniform vec4 u_undergroundColorAlphaByDistance;\\n\\\n#endif\\n\\\n\\n\\\nvarying vec3 v_positionMC;\\n\\\nvarying vec3 v_positionEC;\\n\\\nvarying vec3 v_textureCoordinates;\\n\\\nvarying vec3 v_normalMC;\\n\\\nvarying vec3 v_normalEC;\\n\\\n\\n\\\n#ifdef APPLY_MATERIAL\\n\\\nvarying float v_height;\\n\\\nvarying float v_slope;\\n\\\nvarying float v_aspect;\\n\\\n#endif\\n\\\n\\n\\\n#if defined(FOG) || defined(GROUND_ATMOSPHERE) || defined(UNDERGROUND_COLOR) || defined(TRANSLUCENT)\\n\\\nvarying float v_distance;\\n\\\n#endif\\n\\\n\\n\\\n#if defined(FOG) || defined(GROUND_ATMOSPHERE)\\n\\\nvarying vec3 v_fogRayleighColor;\\n\\\nvarying vec3 v_fogMieColor;\\n\\\n#endif\\n\\\n\\n\\\n#ifdef GROUND_ATMOSPHERE\\n\\\nvarying vec3 v_rayleighColor;\\n\\\nvarying vec3 v_mieColor;\\n\\\n#endif\\n\\\n\\n\\\n#if defined(UNDERGROUND_COLOR) || defined(TRANSLUCENT)\\n\\\nfloat interpolateByDistance(vec4 nearFarScalar, float distance)\\n\\\n{\\n\\\n    float startDistance = nearFarScalar.x;\\n\\\n    float startValue = nearFarScalar.y;\\n\\\n    float endDistance = nearFarScalar.z;\\n\\\n    float endValue = nearFarScalar.w;\\n\\\n    float t = clamp((distance - startDistance) / (endDistance - startDistance), 0.0, 1.0);\\n\\\n    return mix(startValue, endValue, t);\\n\\\n}\\n\\\n#endif\\n\\\n\\n\\\n#if defined(UNDERGROUND_COLOR) || defined(TRANSLUCENT) || defined(APPLY_MATERIAL)\\n\\\nvec4 alphaBlend(vec4 sourceColor, vec4 destinationColor)\\n\\\n{\\n\\\n    return sourceColor * vec4(sourceColor.aaa, 1.0) + destinationColor * (1.0 - sourceColor.a);\\n\\\n}\\n\\\n#endif\\n\\\n\\n\\\n#ifdef TRANSLUCENT\\n\\\nbool inTranslucencyRectangle()\\n\\\n{\\n\\\n    return\\n\\\n        v_textureCoordinates.x > u_translucencyRectangle.x &&\\n\\\n        v_textureCoordinates.x < u_translucencyRectangle.z &&\\n\\\n        v_textureCoordinates.y > u_translucencyRectangle.y &&\\n\\\n        v_textureCoordinates.y < u_translucencyRectangle.w;\\n\\\n}\\n\\\n#endif\\n\\\n\\n\\\nvec4 sampleAndBlend(\\n\\\n    vec4 previousColor,\\n\\\n    sampler2D textureToSample,\\n\\\n    vec2 tileTextureCoordinates,\\n\\\n    vec4 textureCoordinateRectangle,\\n\\\n    vec4 textureCoordinateTranslationAndScale,\\n\\\n    float textureAlpha,\\n\\\n    float textureNightAlpha,\\n\\\n    float textureDayAlpha,\\n\\\n    float textureBrightness,\\n\\\n    float textureContrast,\\n\\\n    float textureHue,\\n\\\n    float textureSaturation,\\n\\\n    float textureOneOverGamma,\\n\\\n    float split,\\n\\\n    vec4 colorToAlpha,\\n\\\n    float nightBlend)\\n\\\n{\\n\\\n    // This crazy step stuff sets the alpha to 0.0 if this following condition is true:\\n\\\n    //    tileTextureCoordinates.s < textureCoordinateRectangle.s ||\\n\\\n    //    tileTextureCoordinates.s > textureCoordinateRectangle.p ||\\n\\\n    //    tileTextureCoordinates.t < textureCoordinateRectangle.t ||\\n\\\n    //    tileTextureCoordinates.t > textureCoordinateRectangle.q\\n\\\n    // In other words, the alpha is zero if the fragment is outside the rectangle\\n\\\n    // covered by this texture.  Would an actual \'if\' yield better performance?\\n\\\n    vec2 alphaMultiplier = step(textureCoordinateRectangle.st, tileTextureCoordinates);\\n\\\n    textureAlpha = textureAlpha * alphaMultiplier.x * alphaMultiplier.y;\\n\\\n\\n\\\n    alphaMultiplier = step(vec2(0.0), textureCoordinateRectangle.pq - tileTextureCoordinates);\\n\\\n    textureAlpha = textureAlpha * alphaMultiplier.x * alphaMultiplier.y;\\n\\\n\\n\\\n#if defined(APPLY_DAY_NIGHT_ALPHA) && defined(ENABLE_DAYNIGHT_SHADING)\\n\\\n    textureAlpha *= mix(textureDayAlpha, textureNightAlpha, nightBlend);\\n\\\n#endif\\n\\\n\\n\\\n    vec2 translation = textureCoordinateTranslationAndScale.xy;\\n\\\n    vec2 scale = textureCoordinateTranslationAndScale.zw;\\n\\\n    vec2 textureCoordinates = tileTextureCoordinates * scale + translation;\\n\\\n    vec4 value = texture2D(textureToSample, textureCoordinates);\\n\\\n    vec3 color = value.rgb;\\n\\\n    float alpha = value.a;\\n\\\n\\n\\\n#ifdef APPLY_COLOR_TO_ALPHA\\n\\\n    vec3 colorDiff = abs(color.rgb - colorToAlpha.rgb);\\n\\\n    colorDiff.r = max(max(colorDiff.r, colorDiff.g), colorDiff.b);\\n\\\n    alpha = czm_branchFreeTernary(colorDiff.r < colorToAlpha.a, 0.0, alpha);\\n\\\n#endif\\n\\\n\\n\\\n#if !defined(APPLY_GAMMA)\\n\\\n    vec4 tempColor = czm_gammaCorrect(vec4(color, alpha));\\n\\\n    color = tempColor.rgb;\\n\\\n    alpha = tempColor.a;\\n\\\n#else\\n\\\n    color = pow(color, vec3(textureOneOverGamma));\\n\\\n#endif\\n\\\n\\n\\\n#ifdef APPLY_SPLIT\\n\\\n    float splitPosition = czm_imagerySplitPosition;\\n\\\n    // Split to the left\\n\\\n    if (split < 0.0 && gl_FragCoord.x > splitPosition) {\\n\\\n       alpha = 0.0;\\n\\\n    }\\n\\\n    // Split to the right\\n\\\n    else if (split > 0.0 && gl_FragCoord.x < splitPosition) {\\n\\\n       alpha = 0.0;\\n\\\n    }\\n\\\n#endif\\n\\\n\\n\\\n#ifdef APPLY_BRIGHTNESS\\n\\\n    color = mix(vec3(0.0), color, textureBrightness);\\n\\\n#endif\\n\\\n\\n\\\n#ifdef APPLY_CONTRAST\\n\\\n    color = mix(vec3(0.5), color, textureContrast);\\n\\\n#endif\\n\\\n\\n\\\n#ifdef APPLY_HUE\\n\\\n    color = czm_hue(color, textureHue);\\n\\\n#endif\\n\\\n\\n\\\n#ifdef APPLY_SATURATION\\n\\\n    color = czm_saturation(color, textureSaturation);\\n\\\n#endif\\n\\\n\\n\\\n    float sourceAlpha = alpha * textureAlpha;\\n\\\n    float outAlpha = mix(previousColor.a, 1.0, sourceAlpha);\\n\\\n    outAlpha += sign(outAlpha) - 1.0;\\n\\\n\\n\\\n    vec3 outColor = mix(previousColor.rgb * previousColor.a, color, sourceAlpha) / outAlpha;\\n\\\n\\n\\\n    // When rendering imagery for a tile in multiple passes,\\n\\\n    // some GPU/WebGL implementation combinations will not blend fragments in\\n\\\n    // additional passes correctly if their computation includes an unmasked\\n\\\n    // divide-by-zero operation,\\n\\\n    // even if it\'s not in the output or if the output has alpha zero.\\n\\\n    //\\n\\\n    // For example, without sanitization for outAlpha,\\n\\\n    // this renders without artifacts:\\n\\\n    //   if (outAlpha == 0.0) { outColor = vec3(0.0); }\\n\\\n    //\\n\\\n    // but using czm_branchFreeTernary will cause portions of the tile that are\\n\\\n    // alpha-zero in the additional pass to render as black instead of blending\\n\\\n    // with the previous pass:\\n\\\n    //   outColor = czm_branchFreeTernary(outAlpha == 0.0, vec3(0.0), outColor);\\n\\\n    //\\n\\\n    // So instead, sanitize against divide-by-zero,\\n\\\n    // store this state on the sign of outAlpha, and correct on return.\\n\\\n\\n\\\n    return vec4(outColor, max(outAlpha, 0.0));\\n\\\n}\\n\\\n\\n\\\nvec3 colorCorrect(vec3 rgb) {\\n\\\n#ifdef COLOR_CORRECT\\n\\\n    // Convert rgb color to hsb\\n\\\n    vec3 hsb = czm_RGBToHSB(rgb);\\n\\\n    // Perform hsb shift\\n\\\n    hsb.x += u_hsbShift.x; // hue\\n\\\n    hsb.y = clamp(hsb.y + u_hsbShift.y, 0.0, 1.0); // saturation\\n\\\n    hsb.z = hsb.z > czm_epsilon7 ? hsb.z + u_hsbShift.z : 0.0; // brightness\\n\\\n    // Convert shifted hsb back to rgb\\n\\\n    rgb = czm_HSBToRGB(hsb);\\n\\\n#endif\\n\\\n    return rgb;\\n\\\n}\\n\\\n\\n\\\nvec4 computeDayColor(vec4 initialColor, vec3 textureCoordinates, float nightBlend);\\n\\\nvec4 computeWaterColor(vec3 positionEyeCoordinates, vec2 textureCoordinates, mat3 enuToEye, vec4 imageryColor, float specularMapValue, float fade);\\n\\\n\\n\\\n#ifdef GROUND_ATMOSPHERE\\n\\\nvec3 computeGroundAtmosphereColor(vec3 fogColor, vec4 finalColor, vec3 atmosphereLightDirection, float cameraDist);\\n\\\n#endif\\n\\\n\\n\\\nconst float fExposure = 2.0;\\n\\\n\\n\\\nvoid main()\\n\\\n{\\n\\\n#ifdef TILE_LIMIT_RECTANGLE\\n\\\n    if (v_textureCoordinates.x < u_cartographicLimitRectangle.x || u_cartographicLimitRectangle.z < v_textureCoordinates.x ||\\n\\\n        v_textureCoordinates.y < u_cartographicLimitRectangle.y || u_cartographicLimitRectangle.w < v_textureCoordinates.y)\\n\\\n        {\\n\\\n            discard;\\n\\\n        }\\n\\\n#endif\\n\\\n\\n\\\n#ifdef ENABLE_CLIPPING_PLANES\\n\\\n    float clipDistance = clip(gl_FragCoord, u_clippingPlanes, u_clippingPlanesMatrix);\\n\\\n#endif\\n\\\n\\n\\\n#if defined(SHOW_REFLECTIVE_OCEAN) || defined(ENABLE_DAYNIGHT_SHADING) || defined(HDR)\\n\\\n    vec3 normalMC = czm_geodeticSurfaceNormal(v_positionMC, vec3(0.0), vec3(1.0));   // normalized surface normal in model coordinates\\n\\\n    vec3 normalEC = czm_normal3D * normalMC;                                         // normalized surface normal in eye coordiantes\\n\\\n#endif\\n\\\n\\n\\\n#if defined(APPLY_DAY_NIGHT_ALPHA) && defined(ENABLE_DAYNIGHT_SHADING)\\n\\\n    float nightBlend = 1.0 - clamp(czm_getLambertDiffuse(czm_lightDirectionEC, normalEC) * 5.0, 0.0, 1.0);\\n\\\n#else\\n\\\n    float nightBlend = 0.0;\\n\\\n#endif\\n\\\n\\n\\\n    // The clamp below works around an apparent bug in Chrome Canary v23.0.1241.0\\n\\\n    // where the fragment shader sees textures coordinates < 0.0 and > 1.0 for the\\n\\\n    // fragments on the edges of tiles even though the vertex shader is outputting\\n\\\n    // coordinates strictly in the 0-1 range.\\n\\\n    vec4 color = computeDayColor(u_initialColor, clamp(v_textureCoordinates, 0.0, 1.0), nightBlend);\\n\\\n\\n\\\n#ifdef SHOW_TILE_BOUNDARIES\\n\\\n    if (v_textureCoordinates.x < (1.0/256.0) || v_textureCoordinates.x > (255.0/256.0) ||\\n\\\n        v_textureCoordinates.y < (1.0/256.0) || v_textureCoordinates.y > (255.0/256.0))\\n\\\n    {\\n\\\n        color = vec4(1.0, 0.0, 0.0, 1.0);\\n\\\n    }\\n\\\n#endif\\n\\\n\\n\\\n#if defined(ENABLE_DAYNIGHT_SHADING) || defined(GROUND_ATMOSPHERE)\\n\\\n    float cameraDist;\\n\\\n    if (czm_sceneMode == czm_sceneMode2D)\\n\\\n    {\\n\\\n        cameraDist = max(czm_frustumPlanes.x - czm_frustumPlanes.y, czm_frustumPlanes.w - czm_frustumPlanes.z) * 0.5;\\n\\\n    }\\n\\\n    else if (czm_sceneMode == czm_sceneModeColumbusView)\\n\\\n    {\\n\\\n        cameraDist = -czm_view[3].z;\\n\\\n    }\\n\\\n    else\\n\\\n    {\\n\\\n        cameraDist = length(czm_view[3]);\\n\\\n    }\\n\\\n    float fadeOutDist = u_lightingFadeDistance.x;\\n\\\n    float fadeInDist = u_lightingFadeDistance.y;\\n\\\n    if (czm_sceneMode != czm_sceneMode3D) {\\n\\\n        vec3 radii = czm_ellipsoidRadii;\\n\\\n        float maxRadii = max(radii.x, max(radii.y, radii.z));\\n\\\n        fadeOutDist -= maxRadii;\\n\\\n        fadeInDist -= maxRadii;\\n\\\n    }\\n\\\n    float fade = clamp((cameraDist - fadeOutDist) / (fadeInDist - fadeOutDist), 0.0, 1.0);\\n\\\n#else\\n\\\n    float fade = 0.0;\\n\\\n#endif\\n\\\n\\n\\\n#ifdef SHOW_REFLECTIVE_OCEAN\\n\\\n    vec2 waterMaskTranslation = u_waterMaskTranslationAndScale.xy;\\n\\\n    vec2 waterMaskScale = u_waterMaskTranslationAndScale.zw;\\n\\\n    vec2 waterMaskTextureCoordinates = v_textureCoordinates.xy * waterMaskScale + waterMaskTranslation;\\n\\\n    waterMaskTextureCoordinates.y = 1.0 - waterMaskTextureCoordinates.y;\\n\\\n\\n\\\n    float mask = texture2D(u_waterMask, waterMaskTextureCoordinates).r;\\n\\\n\\n\\\n    if (mask > 0.0)\\n\\\n    {\\n\\\n        mat3 enuToEye = czm_eastNorthUpToEyeCoordinates(v_positionMC, normalEC);\\n\\\n\\n\\\n        vec2 ellipsoidTextureCoordinates = czm_ellipsoidWgs84TextureCoordinates(normalMC);\\n\\\n        vec2 ellipsoidFlippedTextureCoordinates = czm_ellipsoidWgs84TextureCoordinates(normalMC.zyx);\\n\\\n\\n\\\n        vec2 textureCoordinates = mix(ellipsoidTextureCoordinates, ellipsoidFlippedTextureCoordinates, czm_morphTime * smoothstep(0.9, 0.95, normalMC.z));\\n\\\n\\n\\\n        color = computeWaterColor(v_positionEC, textureCoordinates, enuToEye, color, mask, fade);\\n\\\n    }\\n\\\n#endif\\n\\\n\\n\\\n#ifdef APPLY_MATERIAL\\n\\\n    czm_materialInput materialInput;\\n\\\n    materialInput.st = v_textureCoordinates.st;\\n\\\n    materialInput.normalEC = normalize(v_normalEC);\\n\\\n    materialInput.positionToEyeEC = -v_positionEC;\\n\\\n    materialInput.tangentToEyeMatrix = czm_eastNorthUpToEyeCoordinates(v_positionMC, normalize(v_normalEC));     \\n\\\n    materialInput.slope = v_slope;\\n\\\n    materialInput.height = v_height;\\n\\\n    materialInput.aspect = v_aspect;\\n\\\n    czm_material material = czm_getMaterial(materialInput);\\n\\\n    vec4 materialColor = vec4(material.diffuse, material.alpha);\\n\\\n    color = alphaBlend(materialColor, color);\\n\\\n#endif\\n\\\n\\n\\\n#ifdef ENABLE_VERTEX_LIGHTING\\n\\\n    float diffuseIntensity = clamp(czm_getLambertDiffuse(czm_lightDirectionEC, normalize(v_normalEC)) * 0.9 + 0.3, 0.0, 1.0);\\n\\\n    vec4 finalColor = vec4(color.rgb * czm_lightColor * diffuseIntensity, color.a);\\n\\\n#elif defined(ENABLE_DAYNIGHT_SHADING)\\n\\\n    float diffuseIntensity = clamp(czm_getLambertDiffuse(czm_lightDirectionEC, normalEC) * 5.0 + 0.3, 0.0, 1.0);\\n\\\n    diffuseIntensity = mix(1.0, diffuseIntensity, fade);\\n\\\n    vec4 finalColor = vec4(color.rgb * czm_lightColor * diffuseIntensity, color.a);\\n\\\n#else\\n\\\n    vec4 finalColor = color;\\n\\\n#endif\\n\\\n\\n\\\n#ifdef ENABLE_CLIPPING_PLANES\\n\\\n    vec4 clippingPlanesEdgeColor = vec4(1.0);\\n\\\n    clippingPlanesEdgeColor.rgb = u_clippingPlanesEdgeStyle.rgb;\\n\\\n    float clippingPlanesEdgeWidth = u_clippingPlanesEdgeStyle.a;\\n\\\n\\n\\\n    if (clipDistance < clippingPlanesEdgeWidth)\\n\\\n    {\\n\\\n        finalColor = clippingPlanesEdgeColor;\\n\\\n    }\\n\\\n#endif\\n\\\n\\n\\\n#ifdef HIGHLIGHT_FILL_TILE\\n\\\n    finalColor = vec4(mix(finalColor.rgb, u_fillHighlightColor.rgb, u_fillHighlightColor.a), finalColor.a);\\n\\\n#endif\\n\\\n\\n\\\n#if defined(FOG) || defined(GROUND_ATMOSPHERE)\\n\\\n    vec3 fogColor = colorCorrect(v_fogMieColor) + finalColor.rgb * colorCorrect(v_fogRayleighColor);\\n\\\n#ifndef HDR\\n\\\n    fogColor = vec3(1.0) - exp(-fExposure * fogColor);\\n\\\n#endif\\n\\\n#endif\\n\\\n\\n\\\n#if defined(DYNAMIC_ATMOSPHERE_LIGHTING_FROM_SUN)\\n\\\n    vec3 atmosphereLightDirection = czm_sunDirectionWC;\\n\\\n#else\\n\\\n    vec3 atmosphereLightDirection = czm_lightDirectionWC;\\n\\\n#endif\\n\\\n\\n\\\n#ifdef FOG\\n\\\n#if defined(DYNAMIC_ATMOSPHERE_LIGHTING) && (defined(ENABLE_VERTEX_LIGHTING) || defined(ENABLE_DAYNIGHT_SHADING))\\n\\\n    float darken = clamp(dot(normalize(czm_viewerPositionWC), atmosphereLightDirection), u_minimumBrightness, 1.0);\\n\\\n    fogColor *= darken;\\n\\\n#endif\\n\\\n\\n\\\n#ifdef HDR\\n\\\n    const float modifier = 0.15;\\n\\\n    finalColor = vec4(czm_fog(v_distance, finalColor.rgb, fogColor, modifier), finalColor.a);\\n\\\n#else\\n\\\n    finalColor = vec4(czm_fog(v_distance, finalColor.rgb, fogColor), finalColor.a);\\n\\\n#endif\\n\\\n#endif\\n\\\n\\n\\\n#ifdef GROUND_ATMOSPHERE\\n\\\n    if (!czm_backFacing())\\n\\\n    {\\n\\\n        vec3 groundAtmosphereColor = computeGroundAtmosphereColor(fogColor, finalColor, atmosphereLightDirection, cameraDist);\\n\\\n        finalColor = vec4(mix(finalColor.rgb, groundAtmosphereColor, fade), finalColor.a);\\n\\\n    }\\n\\\n#endif\\n\\\n\\n\\\n#ifdef UNDERGROUND_COLOR\\n\\\n    if (czm_backFacing())\\n\\\n    {\\n\\\n        float distanceFromEllipsoid = max(czm_eyeHeight, 0.0);\\n\\\n        float distance = max(v_distance - distanceFromEllipsoid, 0.0);\\n\\\n        float blendAmount = interpolateByDistance(u_undergroundColorAlphaByDistance, distance);\\n\\\n        vec4 undergroundColor = vec4(u_undergroundColor.rgb, u_undergroundColor.a * blendAmount);\\n\\\n        finalColor = alphaBlend(undergroundColor, finalColor);\\n\\\n    }\\n\\\n#endif\\n\\\n\\n\\\n#ifdef TRANSLUCENT\\n\\\n    if (inTranslucencyRectangle())\\n\\\n    {\\n\\\n      vec4 alphaByDistance = gl_FrontFacing ? u_frontFaceAlphaByDistance : u_backFaceAlphaByDistance;\\n\\\n      finalColor.a *= interpolateByDistance(alphaByDistance, v_distance);\\n\\\n    }\\n\\\n#endif\\n\\\n\\n\\\n    gl_FragColor = finalColor;\\n\\\n}\\n\\\n\\n\\\n#ifdef GROUND_ATMOSPHERE\\n\\\nvec3 computeGroundAtmosphereColor(vec3 fogColor, vec4 finalColor, vec3 atmosphereLightDirection, float cameraDist)\\n\\\n{\\n\\\n#if defined(PER_FRAGMENT_GROUND_ATMOSPHERE) && defined(DYNAMIC_ATMOSPHERE_LIGHTING) && (defined(ENABLE_DAYNIGHT_SHADING) || defined(ENABLE_VERTEX_LIGHTING))\\n\\\n    float mpp = czm_metersPerPixel(vec4(0.0, 0.0, -czm_currentFrustum.x, 1.0), 1.0);\\n\\\n    vec2 xy = gl_FragCoord.xy / czm_viewport.zw * 2.0 - vec2(1.0);\\n\\\n    xy *= czm_viewport.zw * mpp * 0.5;\\n\\\n\\n\\\n    vec3 direction = normalize(vec3(xy, -czm_currentFrustum.x));\\n\\\n    czm_ray ray = czm_ray(vec3(0.0), direction);\\n\\\n\\n\\\n    vec3 ellipsoid_center = czm_view[3].xyz;\\n\\\n\\n\\\n    czm_raySegment intersection = czm_rayEllipsoidIntersectionInterval(ray, ellipsoid_center, czm_ellipsoidInverseRadii);\\n\\\n\\n\\\n    vec3 ellipsoidPosition = czm_pointAlongRay(ray, intersection.start);\\n\\\n    ellipsoidPosition = (czm_inverseView * vec4(ellipsoidPosition, 1.0)).xyz;\\n\\\n    AtmosphereColor atmosColor = computeGroundAtmosphereFromSpace(ellipsoidPosition, true, atmosphereLightDirection);\\n\\\n\\n\\\n    vec3 groundAtmosphereColor = colorCorrect(atmosColor.mie) + finalColor.rgb * colorCorrect(atmosColor.rayleigh);\\n\\\n#ifndef HDR\\n\\\n    groundAtmosphereColor = vec3(1.0) - exp(-fExposure * groundAtmosphereColor);\\n\\\n#endif\\n\\\n\\n\\\n    float fadeInDist = u_nightFadeDistance.x;\\n\\\n    float fadeOutDist = u_nightFadeDistance.y;\\n\\\n\\n\\\n    float sunlitAtmosphereIntensity = clamp((cameraDist - fadeOutDist) / (fadeInDist - fadeOutDist), 0.0, 1.0);\\n\\\n\\n\\\n#ifdef HDR\\n\\\n    // Some tweaking to make HDR look better\\n\\\n    sunlitAtmosphereIntensity = max(sunlitAtmosphereIntensity * sunlitAtmosphereIntensity, 0.03);\\n\\\n#endif\\n\\\n\\n\\\n    groundAtmosphereColor = mix(groundAtmosphereColor, fogColor, sunlitAtmosphereIntensity);\\n\\\n#else\\n\\\n    vec3 groundAtmosphereColor = fogColor;\\n\\\n#endif\\n\\\n\\n\\\n#ifdef HDR\\n\\\n    // Some tweaking to make HDR look better\\n\\\n    groundAtmosphereColor = czm_saturation(groundAtmosphereColor, 1.6);\\n\\\n#endif\\n\\\n\\n\\\n    return groundAtmosphereColor;\\n\\\n}\\n\\\n#endif\\n\\\n\\n\\\n#ifdef SHOW_REFLECTIVE_OCEAN\\n\\\n\\n\\\nfloat waveFade(float edge0, float edge1, float x)\\n\\\n{\\n\\\n    float y = clamp((x - edge0) / (edge1 - edge0), 0.0, 1.0);\\n\\\n    return pow(1.0 - y, 5.0);\\n\\\n}\\n\\\n\\n\\\nfloat linearFade(float edge0, float edge1, float x)\\n\\\n{\\n\\\n    return clamp((x - edge0) / (edge1 - edge0), 0.0, 1.0);\\n\\\n}\\n\\\n\\n\\\n// Based on water rendering by Jonas Wagner:\\n\\\n// http://29a.ch/2012/7/19/webgl-terrain-rendering-water-fog\\n\\\n\\n\\\n// low altitude wave settings\\n\\\nconst float oceanFrequencyLowAltitude = 825000.0;\\n\\\nconst float oceanAnimationSpeedLowAltitude = 0.004;\\n\\\nconst float oceanOneOverAmplitudeLowAltitude = 1.0 / 2.0;\\n\\\nconst float oceanSpecularIntensity = 0.5;\\n\\\n\\n\\\n// high altitude wave settings\\n\\\nconst float oceanFrequencyHighAltitude = 125000.0;\\n\\\nconst float oceanAnimationSpeedHighAltitude = 0.008;\\n\\\nconst float oceanOneOverAmplitudeHighAltitude = 1.0 / 2.0;\\n\\\n\\n\\\nvec4 computeWaterColor(vec3 positionEyeCoordinates, vec2 textureCoordinates, mat3 enuToEye, vec4 imageryColor, float maskValue, float fade)\\n\\\n{\\n\\\n    vec3 positionToEyeEC = -positionEyeCoordinates;\\n\\\n    float positionToEyeECLength = length(positionToEyeEC);\\n\\\n\\n\\\n    // The double normalize below works around a bug in Firefox on Android devices.\\n\\\n    vec3 normalizedPositionToEyeEC = normalize(normalize(positionToEyeEC));\\n\\\n\\n\\\n    // Fade out the waves as the camera moves far from the surface.\\n\\\n    float waveIntensity = waveFade(70000.0, 1000000.0, positionToEyeECLength);\\n\\\n\\n\\\n#ifdef SHOW_OCEAN_WAVES\\n\\\n    // high altitude waves\\n\\\n    float time = czm_frameNumber * oceanAnimationSpeedHighAltitude;\\n\\\n    vec4 noise = czm_getWaterNoise(u_oceanNormalMap, textureCoordinates * oceanFrequencyHighAltitude, time, 0.0);\\n\\\n    vec3 normalTangentSpaceHighAltitude = vec3(noise.xy, noise.z * oceanOneOverAmplitudeHighAltitude);\\n\\\n\\n\\\n    // low altitude waves\\n\\\n    time = czm_frameNumber * oceanAnimationSpeedLowAltitude;\\n\\\n    noise = czm_getWaterNoise(u_oceanNormalMap, textureCoordinates * oceanFrequencyLowAltitude, time, 0.0);\\n\\\n    vec3 normalTangentSpaceLowAltitude = vec3(noise.xy, noise.z * oceanOneOverAmplitudeLowAltitude);\\n\\\n\\n\\\n    // blend the 2 wave layers based on distance to surface\\n\\\n    float highAltitudeFade = linearFade(0.0, 60000.0, positionToEyeECLength);\\n\\\n    float lowAltitudeFade = 1.0 - linearFade(20000.0, 60000.0, positionToEyeECLength);\\n\\\n    vec3 normalTangentSpace =\\n\\\n        (highAltitudeFade * normalTangentSpaceHighAltitude) +\\n\\\n        (lowAltitudeFade * normalTangentSpaceLowAltitude);\\n\\\n    normalTangentSpace = normalize(normalTangentSpace);\\n\\\n\\n\\\n    // fade out the normal perturbation as we move farther from the water surface\\n\\\n    normalTangentSpace.xy *= waveIntensity;\\n\\\n    normalTangentSpace = normalize(normalTangentSpace);\\n\\\n#else\\n\\\n    vec3 normalTangentSpace = vec3(0.0, 0.0, 1.0);\\n\\\n#endif\\n\\\n\\n\\\n    vec3 normalEC = enuToEye * normalTangentSpace;\\n\\\n\\n\\\n    const vec3 waveHighlightColor = vec3(0.3, 0.45, 0.6);\\n\\\n\\n\\\n    // Use diffuse light to highlight the waves\\n\\\n    float diffuseIntensity = czm_getLambertDiffuse(czm_lightDirectionEC, normalEC) * maskValue;\\n\\\n    vec3 diffuseHighlight = waveHighlightColor * diffuseIntensity * (1.0 - fade);\\n\\\n\\n\\\n#ifdef SHOW_OCEAN_WAVES\\n\\\n    // Where diffuse light is low or non-existent, use wave highlights based solely on\\n\\\n    // the wave bumpiness and no particular light direction.\\n\\\n    float tsPerturbationRatio = normalTangentSpace.z;\\n\\\n    vec3 nonDiffuseHighlight = mix(waveHighlightColor * 5.0 * (1.0 - tsPerturbationRatio), vec3(0.0), diffuseIntensity);\\n\\\n#else\\n\\\n    vec3 nonDiffuseHighlight = vec3(0.0);\\n\\\n#endif\\n\\\n\\n\\\n    // Add specular highlights in 3D, and in all modes when zoomed in.\\n\\\n    float specularIntensity = czm_getSpecular(czm_lightDirectionEC, normalizedPositionToEyeEC, normalEC, 10.0);\\n\\\n    float surfaceReflectance = mix(0.0, mix(u_zoomedOutOceanSpecularIntensity, oceanSpecularIntensity, waveIntensity), maskValue);\\n\\\n    float specular = specularIntensity * surfaceReflectance;\\n\\\n\\n\\\n#ifdef HDR\\n\\\n    specular *= 1.4;\\n\\\n\\n\\\n    float e = 0.2;\\n\\\n    float d = 3.3;\\n\\\n    float c = 1.7;\\n\\\n\\n\\\n    vec3 color = imageryColor.rgb + (c * (vec3(e) + imageryColor.rgb * d) * (diffuseHighlight + nonDiffuseHighlight + specular));\\n\\\n#else\\n\\\n    vec3 color = imageryColor.rgb + diffuseHighlight + nonDiffuseHighlight + specular;\\n\\\n#endif\\n\\\n\\n\\\n    return vec4(color, imageryColor.a);\\n\\\n}\\n\\\n\\n\\\n#endif // #ifdef SHOW_REFLECTIVE_OCEAN\\n\\\n");\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjA5MDkuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQSx5REFBZSw2QkFBNkI7QUFDNUM7QUFDQTtBQUNBLCtDQUErQztBQUMvQyw0REFBNEQ7QUFDNUQsd0RBQXdEO0FBQ3hEO0FBQ0E7QUFDQSwrQ0FBK0M7QUFDL0M7QUFDQTtBQUNBO0FBQ0Esb0RBQW9EO0FBQ3BELGtEQUFrRDtBQUNsRDtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0M7QUFDL0M7QUFDQTtBQUNBO0FBQ0Esb0RBQW9EO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRDtBQUNsRDtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkM7QUFDN0M7QUFDQTtBQUNBO0FBQ0Esb0RBQW9EO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBLHNEQUFzRDtBQUN0RDtBQUNBO0FBQ0E7QUFDQSx5REFBeUQ7QUFDekQ7QUFDQTtBQUNBO0FBQ0EsNENBQTRDO0FBQzVDO0FBQ0E7QUFDQSwyREFBMkQ7QUFDM0Q7QUFDQTtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCLDRDQUE0QztBQUM1QyxnREFBZ0Q7QUFDaEQ7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DO0FBQ25DO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQztBQUNwQztBQUNBO0FBQ0E7QUFDQSwwQ0FBMEM7QUFDMUM7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QztBQUN6QyxvQ0FBb0M7QUFDcEMsdUNBQXVDO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQztBQUNsQztBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QztBQUN4Qyx1Q0FBdUM7QUFDdkMscUNBQXFDO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQztBQUNoQywrQ0FBK0M7QUFDL0M7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQiwwQkFBMEI7QUFDMUIsa0NBQWtDO0FBQ2xDLHdCQUF3QjtBQUN4Qix3QkFBd0I7QUFDeEI7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QixzQkFBc0I7QUFDdEIsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0M7QUFDaEMsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3Qix3QkFBd0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0QsMENBQTBDO0FBQzFDLHVDQUF1QztBQUN2Qyx3Q0FBd0M7QUFDeEMscUNBQXFDO0FBQ3JDLDBGQUEwRjtBQUMxRix3Q0FBd0M7QUFDeEMsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNELCtGQUErRjtBQUMvRixDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyREFBMkQ7QUFDM0QsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUZBQXVGO0FBQ3ZGLHdFQUF3RTtBQUN4RTtBQUNBLDhGQUE4RjtBQUM5Rix3RUFBd0U7QUFDeEU7QUFDQTtBQUNBLHdFQUF3RTtBQUN4RTtBQUNBO0FBQ0EsK0RBQStEO0FBQy9ELHlEQUF5RDtBQUN6RCwyRUFBMkU7QUFDM0UsZ0VBQWdFO0FBQ2hFLDJCQUEyQjtBQUMzQiwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBLHVEQUF1RDtBQUN2RCxrRUFBa0U7QUFDbEUsNEVBQTRFO0FBQzVFO0FBQ0E7QUFDQTtBQUNBLDBEQUEwRDtBQUMxRCwwQkFBMEI7QUFDMUIsd0JBQXdCO0FBQ3hCO0FBQ0Esa0RBQWtEO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBLG1EQUFtRDtBQUNuRDtBQUNBLHdEQUF3RDtBQUN4RCxtQkFBbUI7QUFDbkIsS0FBSztBQUNMO0FBQ0EsNkRBQTZEO0FBQzdELG1CQUFtQjtBQUNuQixLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EscURBQXFEO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBLG1EQUFtRDtBQUNuRDtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUM7QUFDdkM7QUFDQTtBQUNBO0FBQ0EscURBQXFEO0FBQ3JEO0FBQ0E7QUFDQSw2Q0FBNkM7QUFDN0MsNERBQTREO0FBQzVELHFDQUFxQztBQUNyQztBQUNBLDRGQUE0RjtBQUM1RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsdUJBQXVCO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0ZBQWdGO0FBQ2hGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDO0FBQzlDLENBQUM7QUFDRDtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0EsaUNBQWlDO0FBQ2pDO0FBQ0EsMkJBQTJCO0FBQzNCLG1EQUFtRDtBQUNuRCwrREFBK0Q7QUFDL0Q7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQSxlQUFlO0FBQ2YsQ0FBQztBQUNEO0FBQ0EsbUZBQW1GO0FBQ25GLG1KQUFtSjtBQUNuSjtBQUNBO0FBQ0EsbUhBQW1IO0FBQ25IO0FBQ0E7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Qsb0JBQW9CO0FBQ3BCLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxzRkFBc0Y7QUFDdEY7QUFDQTtBQUNBO0FBQ0EscUZBQXFGO0FBQ3JGLHFGQUFxRjtBQUNyRjtBQUNBO0FBQ0E7QUFDQSwwR0FBMEc7QUFDMUc7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0dBQW9HO0FBQ3BHO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLHlDQUF5QztBQUN6QyxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0EsS0FBSztBQUNMLHFIQUFxSDtBQUNySCxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0wsb0NBQW9DO0FBQ3BDLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTCx5Q0FBeUM7QUFDekMsS0FBSztBQUNMLGlEQUFpRDtBQUNqRCxnREFBZ0Q7QUFDaEQsMkNBQTJDO0FBQzNDLHdDQUF3QztBQUN4Qyw2REFBNkQ7QUFDN0QsZ0NBQWdDO0FBQ2hDLCtCQUErQjtBQUMvQixLQUFLO0FBQ0wsMEZBQTBGO0FBQzFGO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBLGtFQUFrRTtBQUNsRSw0REFBNEQ7QUFDNUQsdUdBQXVHO0FBQ3ZHLHdFQUF3RTtBQUN4RTtBQUNBLHVFQUF1RTtBQUN2RTtBQUNBO0FBQ0EsS0FBSztBQUNMLGdGQUFnRjtBQUNoRjtBQUNBLDBGQUEwRjtBQUMxRixxR0FBcUc7QUFDckc7QUFDQSwwSkFBMEo7QUFDMUo7QUFDQSxpR0FBaUc7QUFDakcsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQztBQUNwQywrQ0FBK0M7QUFDL0MsbURBQW1EO0FBQ25ELGtEQUFrRDtBQUNsRCxpSEFBaUg7QUFDakgsa0NBQWtDO0FBQ2xDLG9DQUFvQztBQUNwQyxvQ0FBb0M7QUFDcEMsMkRBQTJEO0FBQzNELGdFQUFnRTtBQUNoRSw2Q0FBNkM7QUFDN0M7QUFDQTtBQUNBO0FBQ0EsNkhBQTZIO0FBQzdILG1GQUFtRjtBQUNuRjtBQUNBLGdIQUFnSDtBQUNoSCx3REFBd0Q7QUFDeEQsbUZBQW1GO0FBQ25GO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QztBQUM3QyxnRUFBZ0U7QUFDaEUsZ0VBQWdFO0FBQ2hFO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsNkNBQTZDO0FBQzdDLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSwyR0FBMkc7QUFDM0c7QUFDQTtBQUNBO0FBQ0Esb0dBQW9HO0FBQ3BHO0FBQ0Esc0RBQXNEO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdURBQXVEO0FBQ3ZEO0FBQ0EseURBQXlEO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUhBQW1IO0FBQ25ILHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0M7QUFDaEMsNkZBQTZGO0FBQzdGO0FBQ0EsbUZBQW1GO0FBQ25GO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsOEhBQThIO0FBQzlILDBGQUEwRjtBQUMxRixLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsOERBQThEO0FBQzlELHNFQUFzRTtBQUN0RSwrRkFBK0Y7QUFDL0YsaUdBQWlHO0FBQ2pHLDhEQUE4RDtBQUM5RCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wscUdBQXFHO0FBQ3JHLHlFQUF5RTtBQUN6RSxLQUFLO0FBQ0w7QUFDQTtBQUNBLDhCQUE4QjtBQUM5QixDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0Esb0ZBQW9GO0FBQ3BGLGtFQUFrRTtBQUNsRSxzQ0FBc0M7QUFDdEM7QUFDQSxnRUFBZ0U7QUFDaEUsZ0RBQWdEO0FBQ2hEO0FBQ0EsNENBQTRDO0FBQzVDO0FBQ0EseUhBQXlIO0FBQ3pIO0FBQ0Esd0VBQXdFO0FBQ3hFLDZFQUE2RTtBQUM3RSxxSEFBcUg7QUFDckg7QUFDQSxtSEFBbUg7QUFDbkg7QUFDQSxnRkFBZ0Y7QUFDaEY7QUFDQTtBQUNBLDZDQUE2QztBQUM3Qyw4Q0FBOEM7QUFDOUM7QUFDQSwrR0FBK0c7QUFDL0c7QUFDQTtBQUNBO0FBQ0EsaUdBQWlHO0FBQ2pHO0FBQ0E7QUFDQSw0RkFBNEY7QUFDNUY7QUFDQSwwQ0FBMEM7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1RUFBdUU7QUFDdkU7QUFDQTtBQUNBLGlDQUFpQztBQUNqQyxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRCw2REFBNkQ7QUFDN0QsNkJBQTZCO0FBQzdCLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNELDBEQUEwRDtBQUMxRCxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRDtBQUNqRCxtREFBbUQ7QUFDbkQseURBQXlEO0FBQ3pELHlDQUF5QztBQUN6QztBQUNBO0FBQ0Esa0RBQWtEO0FBQ2xELG9EQUFvRDtBQUNwRCwwREFBMEQ7QUFDMUQ7QUFDQTtBQUNBLENBQUM7QUFDRCxtREFBbUQ7QUFDbkQsMERBQTBEO0FBQzFEO0FBQ0E7QUFDQSwyRUFBMkU7QUFDM0U7QUFDQTtBQUNBLDhFQUE4RTtBQUM5RTtBQUNBO0FBQ0E7QUFDQSxtRUFBbUU7QUFDbkUsaUhBQWlIO0FBQ2pILHNHQUFzRztBQUN0RztBQUNBO0FBQ0EsNERBQTREO0FBQzVELDJHQUEyRztBQUMzRyxvR0FBb0c7QUFDcEc7QUFDQTtBQUNBLDZFQUE2RTtBQUM3RSxzRkFBc0Y7QUFDdEY7QUFDQTtBQUNBLDBEQUEwRDtBQUMxRCx1REFBdUQ7QUFDdkQ7QUFDQTtBQUNBLDJDQUEyQztBQUMzQyx1REFBdUQ7QUFDdkQ7QUFDQSxrREFBa0Q7QUFDbEQ7QUFDQTtBQUNBLGtEQUFrRDtBQUNsRDtBQUNBLHlEQUF5RDtBQUN6RDtBQUNBO0FBQ0EsK0ZBQStGO0FBQy9GLGlGQUFpRjtBQUNqRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFEQUFxRDtBQUNyRCx3SEFBd0g7QUFDeEg7QUFDQSx5Q0FBeUM7QUFDekM7QUFDQTtBQUNBO0FBQ0EsK0dBQStHO0FBQy9HLGtJQUFrSTtBQUNsSSw0REFBNEQ7QUFDNUQ7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBLGtCQUFrQjtBQUNsQixrQkFBa0I7QUFDbEIsa0JBQWtCO0FBQ2xCO0FBQ0EsaUlBQWlJO0FBQ2pJO0FBQ0Esc0ZBQXNGO0FBQ3RGO0FBQ0E7QUFDQSx1Q0FBdUM7QUFDdkMsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDLEVBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly92dWUzLXdlYnBhY2s1Ly4vbm9kZV9tb2R1bGVzL2Nlc2l1bS9Tb3VyY2UvU2hhZGVycy9HbG9iZUZTLmpzP2IxYmUiXSwic291cmNlc0NvbnRlbnQiOlsiLy9UaGlzIGZpbGUgaXMgYXV0b21hdGljYWxseSByZWJ1aWx0IGJ5IHRoZSBDZXNpdW0gYnVpbGQgcHJvY2Vzcy5cbmV4cG9ydCBkZWZhdWx0IFwidW5pZm9ybSB2ZWM0IHVfaW5pdGlhbENvbG9yO1xcblxcXG5cXG5cXFxuI2lmIFRFWFRVUkVfVU5JVFMgPiAwXFxuXFxcbnVuaWZvcm0gc2FtcGxlcjJEIHVfZGF5VGV4dHVyZXNbVEVYVFVSRV9VTklUU107XFxuXFxcbnVuaWZvcm0gdmVjNCB1X2RheVRleHR1cmVUcmFuc2xhdGlvbkFuZFNjYWxlW1RFWFRVUkVfVU5JVFNdO1xcblxcXG51bmlmb3JtIGJvb2wgdV9kYXlUZXh0dXJlVXNlV2ViTWVyY2F0b3JUW1RFWFRVUkVfVU5JVFNdO1xcblxcXG5cXG5cXFxuI2lmZGVmIEFQUExZX0FMUEhBXFxuXFxcbnVuaWZvcm0gZmxvYXQgdV9kYXlUZXh0dXJlQWxwaGFbVEVYVFVSRV9VTklUU107XFxuXFxcbiNlbmRpZlxcblxcXG5cXG5cXFxuI2lmZGVmIEFQUExZX0RBWV9OSUdIVF9BTFBIQVxcblxcXG51bmlmb3JtIGZsb2F0IHVfZGF5VGV4dHVyZU5pZ2h0QWxwaGFbVEVYVFVSRV9VTklUU107XFxuXFxcbnVuaWZvcm0gZmxvYXQgdV9kYXlUZXh0dXJlRGF5QWxwaGFbVEVYVFVSRV9VTklUU107XFxuXFxcbiNlbmRpZlxcblxcXG5cXG5cXFxuI2lmZGVmIEFQUExZX1NQTElUXFxuXFxcbnVuaWZvcm0gZmxvYXQgdV9kYXlUZXh0dXJlU3BsaXRbVEVYVFVSRV9VTklUU107XFxuXFxcbiNlbmRpZlxcblxcXG5cXG5cXFxuI2lmZGVmIEFQUExZX0JSSUdIVE5FU1NcXG5cXFxudW5pZm9ybSBmbG9hdCB1X2RheVRleHR1cmVCcmlnaHRuZXNzW1RFWFRVUkVfVU5JVFNdO1xcblxcXG4jZW5kaWZcXG5cXFxuXFxuXFxcbiNpZmRlZiBBUFBMWV9DT05UUkFTVFxcblxcXG51bmlmb3JtIGZsb2F0IHVfZGF5VGV4dHVyZUNvbnRyYXN0W1RFWFRVUkVfVU5JVFNdO1xcblxcXG4jZW5kaWZcXG5cXFxuXFxuXFxcbiNpZmRlZiBBUFBMWV9IVUVcXG5cXFxudW5pZm9ybSBmbG9hdCB1X2RheVRleHR1cmVIdWVbVEVYVFVSRV9VTklUU107XFxuXFxcbiNlbmRpZlxcblxcXG5cXG5cXFxuI2lmZGVmIEFQUExZX1NBVFVSQVRJT05cXG5cXFxudW5pZm9ybSBmbG9hdCB1X2RheVRleHR1cmVTYXR1cmF0aW9uW1RFWFRVUkVfVU5JVFNdO1xcblxcXG4jZW5kaWZcXG5cXFxuXFxuXFxcbiNpZmRlZiBBUFBMWV9HQU1NQVxcblxcXG51bmlmb3JtIGZsb2F0IHVfZGF5VGV4dHVyZU9uZU92ZXJHYW1tYVtURVhUVVJFX1VOSVRTXTtcXG5cXFxuI2VuZGlmXFxuXFxcblxcblxcXG4jaWZkZWYgQVBQTFlfSU1BR0VSWV9DVVRPVVRcXG5cXFxudW5pZm9ybSB2ZWM0IHVfZGF5VGV4dHVyZUN1dG91dFJlY3RhbmdsZXNbVEVYVFVSRV9VTklUU107XFxuXFxcbiNlbmRpZlxcblxcXG5cXG5cXFxuI2lmZGVmIEFQUExZX0NPTE9SX1RPX0FMUEhBXFxuXFxcbnVuaWZvcm0gdmVjNCB1X2NvbG9yc1RvQWxwaGFbVEVYVFVSRV9VTklUU107XFxuXFxcbiNlbmRpZlxcblxcXG5cXG5cXFxudW5pZm9ybSB2ZWM0IHVfZGF5VGV4dHVyZVRleENvb3Jkc1JlY3RhbmdsZVtURVhUVVJFX1VOSVRTXTtcXG5cXFxuI2VuZGlmXFxuXFxcblxcblxcXG4jaWZkZWYgU0hPV19SRUZMRUNUSVZFX09DRUFOXFxuXFxcbnVuaWZvcm0gc2FtcGxlcjJEIHVfd2F0ZXJNYXNrO1xcblxcXG51bmlmb3JtIHZlYzQgdV93YXRlck1hc2tUcmFuc2xhdGlvbkFuZFNjYWxlO1xcblxcXG51bmlmb3JtIGZsb2F0IHVfem9vbWVkT3V0T2NlYW5TcGVjdWxhckludGVuc2l0eTtcXG5cXFxuI2VuZGlmXFxuXFxcblxcblxcXG4jaWZkZWYgU0hPV19PQ0VBTl9XQVZFU1xcblxcXG51bmlmb3JtIHNhbXBsZXIyRCB1X29jZWFuTm9ybWFsTWFwO1xcblxcXG4jZW5kaWZcXG5cXFxuXFxuXFxcbiNpZiBkZWZpbmVkKEVOQUJMRV9EQVlOSUdIVF9TSEFESU5HKSB8fCBkZWZpbmVkKEdST1VORF9BVE1PU1BIRVJFKVxcblxcXG51bmlmb3JtIHZlYzIgdV9saWdodGluZ0ZhZGVEaXN0YW5jZTtcXG5cXFxuI2VuZGlmXFxuXFxcblxcblxcXG4jaWZkZWYgVElMRV9MSU1JVF9SRUNUQU5HTEVcXG5cXFxudW5pZm9ybSB2ZWM0IHVfY2FydG9ncmFwaGljTGltaXRSZWN0YW5nbGU7XFxuXFxcbiNlbmRpZlxcblxcXG5cXG5cXFxuI2lmZGVmIEdST1VORF9BVE1PU1BIRVJFXFxuXFxcbnVuaWZvcm0gdmVjMiB1X25pZ2h0RmFkZURpc3RhbmNlO1xcblxcXG4jZW5kaWZcXG5cXFxuXFxuXFxcbiNpZmRlZiBFTkFCTEVfQ0xJUFBJTkdfUExBTkVTXFxuXFxcbnVuaWZvcm0gaGlnaHAgc2FtcGxlcjJEIHVfY2xpcHBpbmdQbGFuZXM7XFxuXFxcbnVuaWZvcm0gbWF0NCB1X2NsaXBwaW5nUGxhbmVzTWF0cml4O1xcblxcXG51bmlmb3JtIHZlYzQgdV9jbGlwcGluZ1BsYW5lc0VkZ2VTdHlsZTtcXG5cXFxuI2VuZGlmXFxuXFxcblxcblxcXG4jaWYgZGVmaW5lZChGT0cpICYmIGRlZmluZWQoRFlOQU1JQ19BVE1PU1BIRVJFX0xJR0hUSU5HKSAmJiAoZGVmaW5lZChFTkFCTEVfVkVSVEVYX0xJR0hUSU5HKSB8fCBkZWZpbmVkKEVOQUJMRV9EQVlOSUdIVF9TSEFESU5HKSlcXG5cXFxudW5pZm9ybSBmbG9hdCB1X21pbmltdW1CcmlnaHRuZXNzO1xcblxcXG4jZW5kaWZcXG5cXFxuXFxuXFxcbiNpZmRlZiBDT0xPUl9DT1JSRUNUXFxuXFxcbnVuaWZvcm0gdmVjMyB1X2hzYlNoaWZ0OyAvLyBIdWUsIHNhdHVyYXRpb24sIGJyaWdodG5lc3NcXG5cXFxuI2VuZGlmXFxuXFxcblxcblxcXG4jaWZkZWYgSElHSExJR0hUX0ZJTExfVElMRVxcblxcXG51bmlmb3JtIHZlYzQgdV9maWxsSGlnaGxpZ2h0Q29sb3I7XFxuXFxcbiNlbmRpZlxcblxcXG5cXG5cXFxuI2lmZGVmIFRSQU5TTFVDRU5UXFxuXFxcbnVuaWZvcm0gdmVjNCB1X2Zyb250RmFjZUFscGhhQnlEaXN0YW5jZTtcXG5cXFxudW5pZm9ybSB2ZWM0IHVfYmFja0ZhY2VBbHBoYUJ5RGlzdGFuY2U7XFxuXFxcbnVuaWZvcm0gdmVjNCB1X3RyYW5zbHVjZW5jeVJlY3RhbmdsZTtcXG5cXFxuI2VuZGlmXFxuXFxcblxcblxcXG4jaWZkZWYgVU5ERVJHUk9VTkRfQ09MT1JcXG5cXFxudW5pZm9ybSB2ZWM0IHVfdW5kZXJncm91bmRDb2xvcjtcXG5cXFxudW5pZm9ybSB2ZWM0IHVfdW5kZXJncm91bmRDb2xvckFscGhhQnlEaXN0YW5jZTtcXG5cXFxuI2VuZGlmXFxuXFxcblxcblxcXG52YXJ5aW5nIHZlYzMgdl9wb3NpdGlvbk1DO1xcblxcXG52YXJ5aW5nIHZlYzMgdl9wb3NpdGlvbkVDO1xcblxcXG52YXJ5aW5nIHZlYzMgdl90ZXh0dXJlQ29vcmRpbmF0ZXM7XFxuXFxcbnZhcnlpbmcgdmVjMyB2X25vcm1hbE1DO1xcblxcXG52YXJ5aW5nIHZlYzMgdl9ub3JtYWxFQztcXG5cXFxuXFxuXFxcbiNpZmRlZiBBUFBMWV9NQVRFUklBTFxcblxcXG52YXJ5aW5nIGZsb2F0IHZfaGVpZ2h0O1xcblxcXG52YXJ5aW5nIGZsb2F0IHZfc2xvcGU7XFxuXFxcbnZhcnlpbmcgZmxvYXQgdl9hc3BlY3Q7XFxuXFxcbiNlbmRpZlxcblxcXG5cXG5cXFxuI2lmIGRlZmluZWQoRk9HKSB8fCBkZWZpbmVkKEdST1VORF9BVE1PU1BIRVJFKSB8fCBkZWZpbmVkKFVOREVSR1JPVU5EX0NPTE9SKSB8fCBkZWZpbmVkKFRSQU5TTFVDRU5UKVxcblxcXG52YXJ5aW5nIGZsb2F0IHZfZGlzdGFuY2U7XFxuXFxcbiNlbmRpZlxcblxcXG5cXG5cXFxuI2lmIGRlZmluZWQoRk9HKSB8fCBkZWZpbmVkKEdST1VORF9BVE1PU1BIRVJFKVxcblxcXG52YXJ5aW5nIHZlYzMgdl9mb2dSYXlsZWlnaENvbG9yO1xcblxcXG52YXJ5aW5nIHZlYzMgdl9mb2dNaWVDb2xvcjtcXG5cXFxuI2VuZGlmXFxuXFxcblxcblxcXG4jaWZkZWYgR1JPVU5EX0FUTU9TUEhFUkVcXG5cXFxudmFyeWluZyB2ZWMzIHZfcmF5bGVpZ2hDb2xvcjtcXG5cXFxudmFyeWluZyB2ZWMzIHZfbWllQ29sb3I7XFxuXFxcbiNlbmRpZlxcblxcXG5cXG5cXFxuI2lmIGRlZmluZWQoVU5ERVJHUk9VTkRfQ09MT1IpIHx8IGRlZmluZWQoVFJBTlNMVUNFTlQpXFxuXFxcbmZsb2F0IGludGVycG9sYXRlQnlEaXN0YW5jZSh2ZWM0IG5lYXJGYXJTY2FsYXIsIGZsb2F0IGRpc3RhbmNlKVxcblxcXG57XFxuXFxcbiAgICBmbG9hdCBzdGFydERpc3RhbmNlID0gbmVhckZhclNjYWxhci54O1xcblxcXG4gICAgZmxvYXQgc3RhcnRWYWx1ZSA9IG5lYXJGYXJTY2FsYXIueTtcXG5cXFxuICAgIGZsb2F0IGVuZERpc3RhbmNlID0gbmVhckZhclNjYWxhci56O1xcblxcXG4gICAgZmxvYXQgZW5kVmFsdWUgPSBuZWFyRmFyU2NhbGFyLnc7XFxuXFxcbiAgICBmbG9hdCB0ID0gY2xhbXAoKGRpc3RhbmNlIC0gc3RhcnREaXN0YW5jZSkgLyAoZW5kRGlzdGFuY2UgLSBzdGFydERpc3RhbmNlKSwgMC4wLCAxLjApO1xcblxcXG4gICAgcmV0dXJuIG1peChzdGFydFZhbHVlLCBlbmRWYWx1ZSwgdCk7XFxuXFxcbn1cXG5cXFxuI2VuZGlmXFxuXFxcblxcblxcXG4jaWYgZGVmaW5lZChVTkRFUkdST1VORF9DT0xPUikgfHwgZGVmaW5lZChUUkFOU0xVQ0VOVCkgfHwgZGVmaW5lZChBUFBMWV9NQVRFUklBTClcXG5cXFxudmVjNCBhbHBoYUJsZW5kKHZlYzQgc291cmNlQ29sb3IsIHZlYzQgZGVzdGluYXRpb25Db2xvcilcXG5cXFxue1xcblxcXG4gICAgcmV0dXJuIHNvdXJjZUNvbG9yICogdmVjNChzb3VyY2VDb2xvci5hYWEsIDEuMCkgKyBkZXN0aW5hdGlvbkNvbG9yICogKDEuMCAtIHNvdXJjZUNvbG9yLmEpO1xcblxcXG59XFxuXFxcbiNlbmRpZlxcblxcXG5cXG5cXFxuI2lmZGVmIFRSQU5TTFVDRU5UXFxuXFxcbmJvb2wgaW5UcmFuc2x1Y2VuY3lSZWN0YW5nbGUoKVxcblxcXG57XFxuXFxcbiAgICByZXR1cm5cXG5cXFxuICAgICAgICB2X3RleHR1cmVDb29yZGluYXRlcy54ID4gdV90cmFuc2x1Y2VuY3lSZWN0YW5nbGUueCAmJlxcblxcXG4gICAgICAgIHZfdGV4dHVyZUNvb3JkaW5hdGVzLnggPCB1X3RyYW5zbHVjZW5jeVJlY3RhbmdsZS56ICYmXFxuXFxcbiAgICAgICAgdl90ZXh0dXJlQ29vcmRpbmF0ZXMueSA+IHVfdHJhbnNsdWNlbmN5UmVjdGFuZ2xlLnkgJiZcXG5cXFxuICAgICAgICB2X3RleHR1cmVDb29yZGluYXRlcy55IDwgdV90cmFuc2x1Y2VuY3lSZWN0YW5nbGUudztcXG5cXFxufVxcblxcXG4jZW5kaWZcXG5cXFxuXFxuXFxcbnZlYzQgc2FtcGxlQW5kQmxlbmQoXFxuXFxcbiAgICB2ZWM0IHByZXZpb3VzQ29sb3IsXFxuXFxcbiAgICBzYW1wbGVyMkQgdGV4dHVyZVRvU2FtcGxlLFxcblxcXG4gICAgdmVjMiB0aWxlVGV4dHVyZUNvb3JkaW5hdGVzLFxcblxcXG4gICAgdmVjNCB0ZXh0dXJlQ29vcmRpbmF0ZVJlY3RhbmdsZSxcXG5cXFxuICAgIHZlYzQgdGV4dHVyZUNvb3JkaW5hdGVUcmFuc2xhdGlvbkFuZFNjYWxlLFxcblxcXG4gICAgZmxvYXQgdGV4dHVyZUFscGhhLFxcblxcXG4gICAgZmxvYXQgdGV4dHVyZU5pZ2h0QWxwaGEsXFxuXFxcbiAgICBmbG9hdCB0ZXh0dXJlRGF5QWxwaGEsXFxuXFxcbiAgICBmbG9hdCB0ZXh0dXJlQnJpZ2h0bmVzcyxcXG5cXFxuICAgIGZsb2F0IHRleHR1cmVDb250cmFzdCxcXG5cXFxuICAgIGZsb2F0IHRleHR1cmVIdWUsXFxuXFxcbiAgICBmbG9hdCB0ZXh0dXJlU2F0dXJhdGlvbixcXG5cXFxuICAgIGZsb2F0IHRleHR1cmVPbmVPdmVyR2FtbWEsXFxuXFxcbiAgICBmbG9hdCBzcGxpdCxcXG5cXFxuICAgIHZlYzQgY29sb3JUb0FscGhhLFxcblxcXG4gICAgZmxvYXQgbmlnaHRCbGVuZClcXG5cXFxue1xcblxcXG4gICAgLy8gVGhpcyBjcmF6eSBzdGVwIHN0dWZmIHNldHMgdGhlIGFscGhhIHRvIDAuMCBpZiB0aGlzIGZvbGxvd2luZyBjb25kaXRpb24gaXMgdHJ1ZTpcXG5cXFxuICAgIC8vICAgIHRpbGVUZXh0dXJlQ29vcmRpbmF0ZXMucyA8IHRleHR1cmVDb29yZGluYXRlUmVjdGFuZ2xlLnMgfHxcXG5cXFxuICAgIC8vICAgIHRpbGVUZXh0dXJlQ29vcmRpbmF0ZXMucyA+IHRleHR1cmVDb29yZGluYXRlUmVjdGFuZ2xlLnAgfHxcXG5cXFxuICAgIC8vICAgIHRpbGVUZXh0dXJlQ29vcmRpbmF0ZXMudCA8IHRleHR1cmVDb29yZGluYXRlUmVjdGFuZ2xlLnQgfHxcXG5cXFxuICAgIC8vICAgIHRpbGVUZXh0dXJlQ29vcmRpbmF0ZXMudCA+IHRleHR1cmVDb29yZGluYXRlUmVjdGFuZ2xlLnFcXG5cXFxuICAgIC8vIEluIG90aGVyIHdvcmRzLCB0aGUgYWxwaGEgaXMgemVybyBpZiB0aGUgZnJhZ21lbnQgaXMgb3V0c2lkZSB0aGUgcmVjdGFuZ2xlXFxuXFxcbiAgICAvLyBjb3ZlcmVkIGJ5IHRoaXMgdGV4dHVyZS4gIFdvdWxkIGFuIGFjdHVhbCAnaWYnIHlpZWxkIGJldHRlciBwZXJmb3JtYW5jZT9cXG5cXFxuICAgIHZlYzIgYWxwaGFNdWx0aXBsaWVyID0gc3RlcCh0ZXh0dXJlQ29vcmRpbmF0ZVJlY3RhbmdsZS5zdCwgdGlsZVRleHR1cmVDb29yZGluYXRlcyk7XFxuXFxcbiAgICB0ZXh0dXJlQWxwaGEgPSB0ZXh0dXJlQWxwaGEgKiBhbHBoYU11bHRpcGxpZXIueCAqIGFscGhhTXVsdGlwbGllci55O1xcblxcXG5cXG5cXFxuICAgIGFscGhhTXVsdGlwbGllciA9IHN0ZXAodmVjMigwLjApLCB0ZXh0dXJlQ29vcmRpbmF0ZVJlY3RhbmdsZS5wcSAtIHRpbGVUZXh0dXJlQ29vcmRpbmF0ZXMpO1xcblxcXG4gICAgdGV4dHVyZUFscGhhID0gdGV4dHVyZUFscGhhICogYWxwaGFNdWx0aXBsaWVyLnggKiBhbHBoYU11bHRpcGxpZXIueTtcXG5cXFxuXFxuXFxcbiNpZiBkZWZpbmVkKEFQUExZX0RBWV9OSUdIVF9BTFBIQSkgJiYgZGVmaW5lZChFTkFCTEVfREFZTklHSFRfU0hBRElORylcXG5cXFxuICAgIHRleHR1cmVBbHBoYSAqPSBtaXgodGV4dHVyZURheUFscGhhLCB0ZXh0dXJlTmlnaHRBbHBoYSwgbmlnaHRCbGVuZCk7XFxuXFxcbiNlbmRpZlxcblxcXG5cXG5cXFxuICAgIHZlYzIgdHJhbnNsYXRpb24gPSB0ZXh0dXJlQ29vcmRpbmF0ZVRyYW5zbGF0aW9uQW5kU2NhbGUueHk7XFxuXFxcbiAgICB2ZWMyIHNjYWxlID0gdGV4dHVyZUNvb3JkaW5hdGVUcmFuc2xhdGlvbkFuZFNjYWxlLnp3O1xcblxcXG4gICAgdmVjMiB0ZXh0dXJlQ29vcmRpbmF0ZXMgPSB0aWxlVGV4dHVyZUNvb3JkaW5hdGVzICogc2NhbGUgKyB0cmFuc2xhdGlvbjtcXG5cXFxuICAgIHZlYzQgdmFsdWUgPSB0ZXh0dXJlMkQodGV4dHVyZVRvU2FtcGxlLCB0ZXh0dXJlQ29vcmRpbmF0ZXMpO1xcblxcXG4gICAgdmVjMyBjb2xvciA9IHZhbHVlLnJnYjtcXG5cXFxuICAgIGZsb2F0IGFscGhhID0gdmFsdWUuYTtcXG5cXFxuXFxuXFxcbiNpZmRlZiBBUFBMWV9DT0xPUl9UT19BTFBIQVxcblxcXG4gICAgdmVjMyBjb2xvckRpZmYgPSBhYnMoY29sb3IucmdiIC0gY29sb3JUb0FscGhhLnJnYik7XFxuXFxcbiAgICBjb2xvckRpZmYuciA9IG1heChtYXgoY29sb3JEaWZmLnIsIGNvbG9yRGlmZi5nKSwgY29sb3JEaWZmLmIpO1xcblxcXG4gICAgYWxwaGEgPSBjem1fYnJhbmNoRnJlZVRlcm5hcnkoY29sb3JEaWZmLnIgPCBjb2xvclRvQWxwaGEuYSwgMC4wLCBhbHBoYSk7XFxuXFxcbiNlbmRpZlxcblxcXG5cXG5cXFxuI2lmICFkZWZpbmVkKEFQUExZX0dBTU1BKVxcblxcXG4gICAgdmVjNCB0ZW1wQ29sb3IgPSBjem1fZ2FtbWFDb3JyZWN0KHZlYzQoY29sb3IsIGFscGhhKSk7XFxuXFxcbiAgICBjb2xvciA9IHRlbXBDb2xvci5yZ2I7XFxuXFxcbiAgICBhbHBoYSA9IHRlbXBDb2xvci5hO1xcblxcXG4jZWxzZVxcblxcXG4gICAgY29sb3IgPSBwb3coY29sb3IsIHZlYzModGV4dHVyZU9uZU92ZXJHYW1tYSkpO1xcblxcXG4jZW5kaWZcXG5cXFxuXFxuXFxcbiNpZmRlZiBBUFBMWV9TUExJVFxcblxcXG4gICAgZmxvYXQgc3BsaXRQb3NpdGlvbiA9IGN6bV9pbWFnZXJ5U3BsaXRQb3NpdGlvbjtcXG5cXFxuICAgIC8vIFNwbGl0IHRvIHRoZSBsZWZ0XFxuXFxcbiAgICBpZiAoc3BsaXQgPCAwLjAgJiYgZ2xfRnJhZ0Nvb3JkLnggPiBzcGxpdFBvc2l0aW9uKSB7XFxuXFxcbiAgICAgICBhbHBoYSA9IDAuMDtcXG5cXFxuICAgIH1cXG5cXFxuICAgIC8vIFNwbGl0IHRvIHRoZSByaWdodFxcblxcXG4gICAgZWxzZSBpZiAoc3BsaXQgPiAwLjAgJiYgZ2xfRnJhZ0Nvb3JkLnggPCBzcGxpdFBvc2l0aW9uKSB7XFxuXFxcbiAgICAgICBhbHBoYSA9IDAuMDtcXG5cXFxuICAgIH1cXG5cXFxuI2VuZGlmXFxuXFxcblxcblxcXG4jaWZkZWYgQVBQTFlfQlJJR0hUTkVTU1xcblxcXG4gICAgY29sb3IgPSBtaXgodmVjMygwLjApLCBjb2xvciwgdGV4dHVyZUJyaWdodG5lc3MpO1xcblxcXG4jZW5kaWZcXG5cXFxuXFxuXFxcbiNpZmRlZiBBUFBMWV9DT05UUkFTVFxcblxcXG4gICAgY29sb3IgPSBtaXgodmVjMygwLjUpLCBjb2xvciwgdGV4dHVyZUNvbnRyYXN0KTtcXG5cXFxuI2VuZGlmXFxuXFxcblxcblxcXG4jaWZkZWYgQVBQTFlfSFVFXFxuXFxcbiAgICBjb2xvciA9IGN6bV9odWUoY29sb3IsIHRleHR1cmVIdWUpO1xcblxcXG4jZW5kaWZcXG5cXFxuXFxuXFxcbiNpZmRlZiBBUFBMWV9TQVRVUkFUSU9OXFxuXFxcbiAgICBjb2xvciA9IGN6bV9zYXR1cmF0aW9uKGNvbG9yLCB0ZXh0dXJlU2F0dXJhdGlvbik7XFxuXFxcbiNlbmRpZlxcblxcXG5cXG5cXFxuICAgIGZsb2F0IHNvdXJjZUFscGhhID0gYWxwaGEgKiB0ZXh0dXJlQWxwaGE7XFxuXFxcbiAgICBmbG9hdCBvdXRBbHBoYSA9IG1peChwcmV2aW91c0NvbG9yLmEsIDEuMCwgc291cmNlQWxwaGEpO1xcblxcXG4gICAgb3V0QWxwaGEgKz0gc2lnbihvdXRBbHBoYSkgLSAxLjA7XFxuXFxcblxcblxcXG4gICAgdmVjMyBvdXRDb2xvciA9IG1peChwcmV2aW91c0NvbG9yLnJnYiAqIHByZXZpb3VzQ29sb3IuYSwgY29sb3IsIHNvdXJjZUFscGhhKSAvIG91dEFscGhhO1xcblxcXG5cXG5cXFxuICAgIC8vIFdoZW4gcmVuZGVyaW5nIGltYWdlcnkgZm9yIGEgdGlsZSBpbiBtdWx0aXBsZSBwYXNzZXMsXFxuXFxcbiAgICAvLyBzb21lIEdQVS9XZWJHTCBpbXBsZW1lbnRhdGlvbiBjb21iaW5hdGlvbnMgd2lsbCBub3QgYmxlbmQgZnJhZ21lbnRzIGluXFxuXFxcbiAgICAvLyBhZGRpdGlvbmFsIHBhc3NlcyBjb3JyZWN0bHkgaWYgdGhlaXIgY29tcHV0YXRpb24gaW5jbHVkZXMgYW4gdW5tYXNrZWRcXG5cXFxuICAgIC8vIGRpdmlkZS1ieS16ZXJvIG9wZXJhdGlvbixcXG5cXFxuICAgIC8vIGV2ZW4gaWYgaXQncyBub3QgaW4gdGhlIG91dHB1dCBvciBpZiB0aGUgb3V0cHV0IGhhcyBhbHBoYSB6ZXJvLlxcblxcXG4gICAgLy9cXG5cXFxuICAgIC8vIEZvciBleGFtcGxlLCB3aXRob3V0IHNhbml0aXphdGlvbiBmb3Igb3V0QWxwaGEsXFxuXFxcbiAgICAvLyB0aGlzIHJlbmRlcnMgd2l0aG91dCBhcnRpZmFjdHM6XFxuXFxcbiAgICAvLyAgIGlmIChvdXRBbHBoYSA9PSAwLjApIHsgb3V0Q29sb3IgPSB2ZWMzKDAuMCk7IH1cXG5cXFxuICAgIC8vXFxuXFxcbiAgICAvLyBidXQgdXNpbmcgY3ptX2JyYW5jaEZyZWVUZXJuYXJ5IHdpbGwgY2F1c2UgcG9ydGlvbnMgb2YgdGhlIHRpbGUgdGhhdCBhcmVcXG5cXFxuICAgIC8vIGFscGhhLXplcm8gaW4gdGhlIGFkZGl0aW9uYWwgcGFzcyB0byByZW5kZXIgYXMgYmxhY2sgaW5zdGVhZCBvZiBibGVuZGluZ1xcblxcXG4gICAgLy8gd2l0aCB0aGUgcHJldmlvdXMgcGFzczpcXG5cXFxuICAgIC8vICAgb3V0Q29sb3IgPSBjem1fYnJhbmNoRnJlZVRlcm5hcnkob3V0QWxwaGEgPT0gMC4wLCB2ZWMzKDAuMCksIG91dENvbG9yKTtcXG5cXFxuICAgIC8vXFxuXFxcbiAgICAvLyBTbyBpbnN0ZWFkLCBzYW5pdGl6ZSBhZ2FpbnN0IGRpdmlkZS1ieS16ZXJvLFxcblxcXG4gICAgLy8gc3RvcmUgdGhpcyBzdGF0ZSBvbiB0aGUgc2lnbiBvZiBvdXRBbHBoYSwgYW5kIGNvcnJlY3Qgb24gcmV0dXJuLlxcblxcXG5cXG5cXFxuICAgIHJldHVybiB2ZWM0KG91dENvbG9yLCBtYXgob3V0QWxwaGEsIDAuMCkpO1xcblxcXG59XFxuXFxcblxcblxcXG52ZWMzIGNvbG9yQ29ycmVjdCh2ZWMzIHJnYikge1xcblxcXG4jaWZkZWYgQ09MT1JfQ09SUkVDVFxcblxcXG4gICAgLy8gQ29udmVydCByZ2IgY29sb3IgdG8gaHNiXFxuXFxcbiAgICB2ZWMzIGhzYiA9IGN6bV9SR0JUb0hTQihyZ2IpO1xcblxcXG4gICAgLy8gUGVyZm9ybSBoc2Igc2hpZnRcXG5cXFxuICAgIGhzYi54ICs9IHVfaHNiU2hpZnQueDsgLy8gaHVlXFxuXFxcbiAgICBoc2IueSA9IGNsYW1wKGhzYi55ICsgdV9oc2JTaGlmdC55LCAwLjAsIDEuMCk7IC8vIHNhdHVyYXRpb25cXG5cXFxuICAgIGhzYi56ID0gaHNiLnogPiBjem1fZXBzaWxvbjcgPyBoc2IueiArIHVfaHNiU2hpZnQueiA6IDAuMDsgLy8gYnJpZ2h0bmVzc1xcblxcXG4gICAgLy8gQ29udmVydCBzaGlmdGVkIGhzYiBiYWNrIHRvIHJnYlxcblxcXG4gICAgcmdiID0gY3ptX0hTQlRvUkdCKGhzYik7XFxuXFxcbiNlbmRpZlxcblxcXG4gICAgcmV0dXJuIHJnYjtcXG5cXFxufVxcblxcXG5cXG5cXFxudmVjNCBjb21wdXRlRGF5Q29sb3IodmVjNCBpbml0aWFsQ29sb3IsIHZlYzMgdGV4dHVyZUNvb3JkaW5hdGVzLCBmbG9hdCBuaWdodEJsZW5kKTtcXG5cXFxudmVjNCBjb21wdXRlV2F0ZXJDb2xvcih2ZWMzIHBvc2l0aW9uRXllQ29vcmRpbmF0ZXMsIHZlYzIgdGV4dHVyZUNvb3JkaW5hdGVzLCBtYXQzIGVudVRvRXllLCB2ZWM0IGltYWdlcnlDb2xvciwgZmxvYXQgc3BlY3VsYXJNYXBWYWx1ZSwgZmxvYXQgZmFkZSk7XFxuXFxcblxcblxcXG4jaWZkZWYgR1JPVU5EX0FUTU9TUEhFUkVcXG5cXFxudmVjMyBjb21wdXRlR3JvdW5kQXRtb3NwaGVyZUNvbG9yKHZlYzMgZm9nQ29sb3IsIHZlYzQgZmluYWxDb2xvciwgdmVjMyBhdG1vc3BoZXJlTGlnaHREaXJlY3Rpb24sIGZsb2F0IGNhbWVyYURpc3QpO1xcblxcXG4jZW5kaWZcXG5cXFxuXFxuXFxcbmNvbnN0IGZsb2F0IGZFeHBvc3VyZSA9IDIuMDtcXG5cXFxuXFxuXFxcbnZvaWQgbWFpbigpXFxuXFxcbntcXG5cXFxuI2lmZGVmIFRJTEVfTElNSVRfUkVDVEFOR0xFXFxuXFxcbiAgICBpZiAodl90ZXh0dXJlQ29vcmRpbmF0ZXMueCA8IHVfY2FydG9ncmFwaGljTGltaXRSZWN0YW5nbGUueCB8fCB1X2NhcnRvZ3JhcGhpY0xpbWl0UmVjdGFuZ2xlLnogPCB2X3RleHR1cmVDb29yZGluYXRlcy54IHx8XFxuXFxcbiAgICAgICAgdl90ZXh0dXJlQ29vcmRpbmF0ZXMueSA8IHVfY2FydG9ncmFwaGljTGltaXRSZWN0YW5nbGUueSB8fCB1X2NhcnRvZ3JhcGhpY0xpbWl0UmVjdGFuZ2xlLncgPCB2X3RleHR1cmVDb29yZGluYXRlcy55KVxcblxcXG4gICAgICAgIHtcXG5cXFxuICAgICAgICAgICAgZGlzY2FyZDtcXG5cXFxuICAgICAgICB9XFxuXFxcbiNlbmRpZlxcblxcXG5cXG5cXFxuI2lmZGVmIEVOQUJMRV9DTElQUElOR19QTEFORVNcXG5cXFxuICAgIGZsb2F0IGNsaXBEaXN0YW5jZSA9IGNsaXAoZ2xfRnJhZ0Nvb3JkLCB1X2NsaXBwaW5nUGxhbmVzLCB1X2NsaXBwaW5nUGxhbmVzTWF0cml4KTtcXG5cXFxuI2VuZGlmXFxuXFxcblxcblxcXG4jaWYgZGVmaW5lZChTSE9XX1JFRkxFQ1RJVkVfT0NFQU4pIHx8IGRlZmluZWQoRU5BQkxFX0RBWU5JR0hUX1NIQURJTkcpIHx8IGRlZmluZWQoSERSKVxcblxcXG4gICAgdmVjMyBub3JtYWxNQyA9IGN6bV9nZW9kZXRpY1N1cmZhY2VOb3JtYWwodl9wb3NpdGlvbk1DLCB2ZWMzKDAuMCksIHZlYzMoMS4wKSk7ICAgLy8gbm9ybWFsaXplZCBzdXJmYWNlIG5vcm1hbCBpbiBtb2RlbCBjb29yZGluYXRlc1xcblxcXG4gICAgdmVjMyBub3JtYWxFQyA9IGN6bV9ub3JtYWwzRCAqIG5vcm1hbE1DOyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gbm9ybWFsaXplZCBzdXJmYWNlIG5vcm1hbCBpbiBleWUgY29vcmRpYW50ZXNcXG5cXFxuI2VuZGlmXFxuXFxcblxcblxcXG4jaWYgZGVmaW5lZChBUFBMWV9EQVlfTklHSFRfQUxQSEEpICYmIGRlZmluZWQoRU5BQkxFX0RBWU5JR0hUX1NIQURJTkcpXFxuXFxcbiAgICBmbG9hdCBuaWdodEJsZW5kID0gMS4wIC0gY2xhbXAoY3ptX2dldExhbWJlcnREaWZmdXNlKGN6bV9saWdodERpcmVjdGlvbkVDLCBub3JtYWxFQykgKiA1LjAsIDAuMCwgMS4wKTtcXG5cXFxuI2Vsc2VcXG5cXFxuICAgIGZsb2F0IG5pZ2h0QmxlbmQgPSAwLjA7XFxuXFxcbiNlbmRpZlxcblxcXG5cXG5cXFxuICAgIC8vIFRoZSBjbGFtcCBiZWxvdyB3b3JrcyBhcm91bmQgYW4gYXBwYXJlbnQgYnVnIGluIENocm9tZSBDYW5hcnkgdjIzLjAuMTI0MS4wXFxuXFxcbiAgICAvLyB3aGVyZSB0aGUgZnJhZ21lbnQgc2hhZGVyIHNlZXMgdGV4dHVyZXMgY29vcmRpbmF0ZXMgPCAwLjAgYW5kID4gMS4wIGZvciB0aGVcXG5cXFxuICAgIC8vIGZyYWdtZW50cyBvbiB0aGUgZWRnZXMgb2YgdGlsZXMgZXZlbiB0aG91Z2ggdGhlIHZlcnRleCBzaGFkZXIgaXMgb3V0cHV0dGluZ1xcblxcXG4gICAgLy8gY29vcmRpbmF0ZXMgc3RyaWN0bHkgaW4gdGhlIDAtMSByYW5nZS5cXG5cXFxuICAgIHZlYzQgY29sb3IgPSBjb21wdXRlRGF5Q29sb3IodV9pbml0aWFsQ29sb3IsIGNsYW1wKHZfdGV4dHVyZUNvb3JkaW5hdGVzLCAwLjAsIDEuMCksIG5pZ2h0QmxlbmQpO1xcblxcXG5cXG5cXFxuI2lmZGVmIFNIT1dfVElMRV9CT1VOREFSSUVTXFxuXFxcbiAgICBpZiAodl90ZXh0dXJlQ29vcmRpbmF0ZXMueCA8ICgxLjAvMjU2LjApIHx8IHZfdGV4dHVyZUNvb3JkaW5hdGVzLnggPiAoMjU1LjAvMjU2LjApIHx8XFxuXFxcbiAgICAgICAgdl90ZXh0dXJlQ29vcmRpbmF0ZXMueSA8ICgxLjAvMjU2LjApIHx8IHZfdGV4dHVyZUNvb3JkaW5hdGVzLnkgPiAoMjU1LjAvMjU2LjApKVxcblxcXG4gICAge1xcblxcXG4gICAgICAgIGNvbG9yID0gdmVjNCgxLjAsIDAuMCwgMC4wLCAxLjApO1xcblxcXG4gICAgfVxcblxcXG4jZW5kaWZcXG5cXFxuXFxuXFxcbiNpZiBkZWZpbmVkKEVOQUJMRV9EQVlOSUdIVF9TSEFESU5HKSB8fCBkZWZpbmVkKEdST1VORF9BVE1PU1BIRVJFKVxcblxcXG4gICAgZmxvYXQgY2FtZXJhRGlzdDtcXG5cXFxuICAgIGlmIChjem1fc2NlbmVNb2RlID09IGN6bV9zY2VuZU1vZGUyRClcXG5cXFxuICAgIHtcXG5cXFxuICAgICAgICBjYW1lcmFEaXN0ID0gbWF4KGN6bV9mcnVzdHVtUGxhbmVzLnggLSBjem1fZnJ1c3R1bVBsYW5lcy55LCBjem1fZnJ1c3R1bVBsYW5lcy53IC0gY3ptX2ZydXN0dW1QbGFuZXMueikgKiAwLjU7XFxuXFxcbiAgICB9XFxuXFxcbiAgICBlbHNlIGlmIChjem1fc2NlbmVNb2RlID09IGN6bV9zY2VuZU1vZGVDb2x1bWJ1c1ZpZXcpXFxuXFxcbiAgICB7XFxuXFxcbiAgICAgICAgY2FtZXJhRGlzdCA9IC1jem1fdmlld1szXS56O1xcblxcXG4gICAgfVxcblxcXG4gICAgZWxzZVxcblxcXG4gICAge1xcblxcXG4gICAgICAgIGNhbWVyYURpc3QgPSBsZW5ndGgoY3ptX3ZpZXdbM10pO1xcblxcXG4gICAgfVxcblxcXG4gICAgZmxvYXQgZmFkZU91dERpc3QgPSB1X2xpZ2h0aW5nRmFkZURpc3RhbmNlLng7XFxuXFxcbiAgICBmbG9hdCBmYWRlSW5EaXN0ID0gdV9saWdodGluZ0ZhZGVEaXN0YW5jZS55O1xcblxcXG4gICAgaWYgKGN6bV9zY2VuZU1vZGUgIT0gY3ptX3NjZW5lTW9kZTNEKSB7XFxuXFxcbiAgICAgICAgdmVjMyByYWRpaSA9IGN6bV9lbGxpcHNvaWRSYWRpaTtcXG5cXFxuICAgICAgICBmbG9hdCBtYXhSYWRpaSA9IG1heChyYWRpaS54LCBtYXgocmFkaWkueSwgcmFkaWkueikpO1xcblxcXG4gICAgICAgIGZhZGVPdXREaXN0IC09IG1heFJhZGlpO1xcblxcXG4gICAgICAgIGZhZGVJbkRpc3QgLT0gbWF4UmFkaWk7XFxuXFxcbiAgICB9XFxuXFxcbiAgICBmbG9hdCBmYWRlID0gY2xhbXAoKGNhbWVyYURpc3QgLSBmYWRlT3V0RGlzdCkgLyAoZmFkZUluRGlzdCAtIGZhZGVPdXREaXN0KSwgMC4wLCAxLjApO1xcblxcXG4jZWxzZVxcblxcXG4gICAgZmxvYXQgZmFkZSA9IDAuMDtcXG5cXFxuI2VuZGlmXFxuXFxcblxcblxcXG4jaWZkZWYgU0hPV19SRUZMRUNUSVZFX09DRUFOXFxuXFxcbiAgICB2ZWMyIHdhdGVyTWFza1RyYW5zbGF0aW9uID0gdV93YXRlck1hc2tUcmFuc2xhdGlvbkFuZFNjYWxlLnh5O1xcblxcXG4gICAgdmVjMiB3YXRlck1hc2tTY2FsZSA9IHVfd2F0ZXJNYXNrVHJhbnNsYXRpb25BbmRTY2FsZS56dztcXG5cXFxuICAgIHZlYzIgd2F0ZXJNYXNrVGV4dHVyZUNvb3JkaW5hdGVzID0gdl90ZXh0dXJlQ29vcmRpbmF0ZXMueHkgKiB3YXRlck1hc2tTY2FsZSArIHdhdGVyTWFza1RyYW5zbGF0aW9uO1xcblxcXG4gICAgd2F0ZXJNYXNrVGV4dHVyZUNvb3JkaW5hdGVzLnkgPSAxLjAgLSB3YXRlck1hc2tUZXh0dXJlQ29vcmRpbmF0ZXMueTtcXG5cXFxuXFxuXFxcbiAgICBmbG9hdCBtYXNrID0gdGV4dHVyZTJEKHVfd2F0ZXJNYXNrLCB3YXRlck1hc2tUZXh0dXJlQ29vcmRpbmF0ZXMpLnI7XFxuXFxcblxcblxcXG4gICAgaWYgKG1hc2sgPiAwLjApXFxuXFxcbiAgICB7XFxuXFxcbiAgICAgICAgbWF0MyBlbnVUb0V5ZSA9IGN6bV9lYXN0Tm9ydGhVcFRvRXllQ29vcmRpbmF0ZXModl9wb3NpdGlvbk1DLCBub3JtYWxFQyk7XFxuXFxcblxcblxcXG4gICAgICAgIHZlYzIgZWxsaXBzb2lkVGV4dHVyZUNvb3JkaW5hdGVzID0gY3ptX2VsbGlwc29pZFdnczg0VGV4dHVyZUNvb3JkaW5hdGVzKG5vcm1hbE1DKTtcXG5cXFxuICAgICAgICB2ZWMyIGVsbGlwc29pZEZsaXBwZWRUZXh0dXJlQ29vcmRpbmF0ZXMgPSBjem1fZWxsaXBzb2lkV2dzODRUZXh0dXJlQ29vcmRpbmF0ZXMobm9ybWFsTUMuenl4KTtcXG5cXFxuXFxuXFxcbiAgICAgICAgdmVjMiB0ZXh0dXJlQ29vcmRpbmF0ZXMgPSBtaXgoZWxsaXBzb2lkVGV4dHVyZUNvb3JkaW5hdGVzLCBlbGxpcHNvaWRGbGlwcGVkVGV4dHVyZUNvb3JkaW5hdGVzLCBjem1fbW9ycGhUaW1lICogc21vb3Roc3RlcCgwLjksIDAuOTUsIG5vcm1hbE1DLnopKTtcXG5cXFxuXFxuXFxcbiAgICAgICAgY29sb3IgPSBjb21wdXRlV2F0ZXJDb2xvcih2X3Bvc2l0aW9uRUMsIHRleHR1cmVDb29yZGluYXRlcywgZW51VG9FeWUsIGNvbG9yLCBtYXNrLCBmYWRlKTtcXG5cXFxuICAgIH1cXG5cXFxuI2VuZGlmXFxuXFxcblxcblxcXG4jaWZkZWYgQVBQTFlfTUFURVJJQUxcXG5cXFxuICAgIGN6bV9tYXRlcmlhbElucHV0IG1hdGVyaWFsSW5wdXQ7XFxuXFxcbiAgICBtYXRlcmlhbElucHV0LnN0ID0gdl90ZXh0dXJlQ29vcmRpbmF0ZXMuc3Q7XFxuXFxcbiAgICBtYXRlcmlhbElucHV0Lm5vcm1hbEVDID0gbm9ybWFsaXplKHZfbm9ybWFsRUMpO1xcblxcXG4gICAgbWF0ZXJpYWxJbnB1dC5wb3NpdGlvblRvRXllRUMgPSAtdl9wb3NpdGlvbkVDO1xcblxcXG4gICAgbWF0ZXJpYWxJbnB1dC50YW5nZW50VG9FeWVNYXRyaXggPSBjem1fZWFzdE5vcnRoVXBUb0V5ZUNvb3JkaW5hdGVzKHZfcG9zaXRpb25NQywgbm9ybWFsaXplKHZfbm9ybWFsRUMpKTsgICAgIFxcblxcXG4gICAgbWF0ZXJpYWxJbnB1dC5zbG9wZSA9IHZfc2xvcGU7XFxuXFxcbiAgICBtYXRlcmlhbElucHV0LmhlaWdodCA9IHZfaGVpZ2h0O1xcblxcXG4gICAgbWF0ZXJpYWxJbnB1dC5hc3BlY3QgPSB2X2FzcGVjdDtcXG5cXFxuICAgIGN6bV9tYXRlcmlhbCBtYXRlcmlhbCA9IGN6bV9nZXRNYXRlcmlhbChtYXRlcmlhbElucHV0KTtcXG5cXFxuICAgIHZlYzQgbWF0ZXJpYWxDb2xvciA9IHZlYzQobWF0ZXJpYWwuZGlmZnVzZSwgbWF0ZXJpYWwuYWxwaGEpO1xcblxcXG4gICAgY29sb3IgPSBhbHBoYUJsZW5kKG1hdGVyaWFsQ29sb3IsIGNvbG9yKTtcXG5cXFxuI2VuZGlmXFxuXFxcblxcblxcXG4jaWZkZWYgRU5BQkxFX1ZFUlRFWF9MSUdIVElOR1xcblxcXG4gICAgZmxvYXQgZGlmZnVzZUludGVuc2l0eSA9IGNsYW1wKGN6bV9nZXRMYW1iZXJ0RGlmZnVzZShjem1fbGlnaHREaXJlY3Rpb25FQywgbm9ybWFsaXplKHZfbm9ybWFsRUMpKSAqIDAuOSArIDAuMywgMC4wLCAxLjApO1xcblxcXG4gICAgdmVjNCBmaW5hbENvbG9yID0gdmVjNChjb2xvci5yZ2IgKiBjem1fbGlnaHRDb2xvciAqIGRpZmZ1c2VJbnRlbnNpdHksIGNvbG9yLmEpO1xcblxcXG4jZWxpZiBkZWZpbmVkKEVOQUJMRV9EQVlOSUdIVF9TSEFESU5HKVxcblxcXG4gICAgZmxvYXQgZGlmZnVzZUludGVuc2l0eSA9IGNsYW1wKGN6bV9nZXRMYW1iZXJ0RGlmZnVzZShjem1fbGlnaHREaXJlY3Rpb25FQywgbm9ybWFsRUMpICogNS4wICsgMC4zLCAwLjAsIDEuMCk7XFxuXFxcbiAgICBkaWZmdXNlSW50ZW5zaXR5ID0gbWl4KDEuMCwgZGlmZnVzZUludGVuc2l0eSwgZmFkZSk7XFxuXFxcbiAgICB2ZWM0IGZpbmFsQ29sb3IgPSB2ZWM0KGNvbG9yLnJnYiAqIGN6bV9saWdodENvbG9yICogZGlmZnVzZUludGVuc2l0eSwgY29sb3IuYSk7XFxuXFxcbiNlbHNlXFxuXFxcbiAgICB2ZWM0IGZpbmFsQ29sb3IgPSBjb2xvcjtcXG5cXFxuI2VuZGlmXFxuXFxcblxcblxcXG4jaWZkZWYgRU5BQkxFX0NMSVBQSU5HX1BMQU5FU1xcblxcXG4gICAgdmVjNCBjbGlwcGluZ1BsYW5lc0VkZ2VDb2xvciA9IHZlYzQoMS4wKTtcXG5cXFxuICAgIGNsaXBwaW5nUGxhbmVzRWRnZUNvbG9yLnJnYiA9IHVfY2xpcHBpbmdQbGFuZXNFZGdlU3R5bGUucmdiO1xcblxcXG4gICAgZmxvYXQgY2xpcHBpbmdQbGFuZXNFZGdlV2lkdGggPSB1X2NsaXBwaW5nUGxhbmVzRWRnZVN0eWxlLmE7XFxuXFxcblxcblxcXG4gICAgaWYgKGNsaXBEaXN0YW5jZSA8IGNsaXBwaW5nUGxhbmVzRWRnZVdpZHRoKVxcblxcXG4gICAge1xcblxcXG4gICAgICAgIGZpbmFsQ29sb3IgPSBjbGlwcGluZ1BsYW5lc0VkZ2VDb2xvcjtcXG5cXFxuICAgIH1cXG5cXFxuI2VuZGlmXFxuXFxcblxcblxcXG4jaWZkZWYgSElHSExJR0hUX0ZJTExfVElMRVxcblxcXG4gICAgZmluYWxDb2xvciA9IHZlYzQobWl4KGZpbmFsQ29sb3IucmdiLCB1X2ZpbGxIaWdobGlnaHRDb2xvci5yZ2IsIHVfZmlsbEhpZ2hsaWdodENvbG9yLmEpLCBmaW5hbENvbG9yLmEpO1xcblxcXG4jZW5kaWZcXG5cXFxuXFxuXFxcbiNpZiBkZWZpbmVkKEZPRykgfHwgZGVmaW5lZChHUk9VTkRfQVRNT1NQSEVSRSlcXG5cXFxuICAgIHZlYzMgZm9nQ29sb3IgPSBjb2xvckNvcnJlY3Qodl9mb2dNaWVDb2xvcikgKyBmaW5hbENvbG9yLnJnYiAqIGNvbG9yQ29ycmVjdCh2X2ZvZ1JheWxlaWdoQ29sb3IpO1xcblxcXG4jaWZuZGVmIEhEUlxcblxcXG4gICAgZm9nQ29sb3IgPSB2ZWMzKDEuMCkgLSBleHAoLWZFeHBvc3VyZSAqIGZvZ0NvbG9yKTtcXG5cXFxuI2VuZGlmXFxuXFxcbiNlbmRpZlxcblxcXG5cXG5cXFxuI2lmIGRlZmluZWQoRFlOQU1JQ19BVE1PU1BIRVJFX0xJR0hUSU5HX0ZST01fU1VOKVxcblxcXG4gICAgdmVjMyBhdG1vc3BoZXJlTGlnaHREaXJlY3Rpb24gPSBjem1fc3VuRGlyZWN0aW9uV0M7XFxuXFxcbiNlbHNlXFxuXFxcbiAgICB2ZWMzIGF0bW9zcGhlcmVMaWdodERpcmVjdGlvbiA9IGN6bV9saWdodERpcmVjdGlvbldDO1xcblxcXG4jZW5kaWZcXG5cXFxuXFxuXFxcbiNpZmRlZiBGT0dcXG5cXFxuI2lmIGRlZmluZWQoRFlOQU1JQ19BVE1PU1BIRVJFX0xJR0hUSU5HKSAmJiAoZGVmaW5lZChFTkFCTEVfVkVSVEVYX0xJR0hUSU5HKSB8fCBkZWZpbmVkKEVOQUJMRV9EQVlOSUdIVF9TSEFESU5HKSlcXG5cXFxuICAgIGZsb2F0IGRhcmtlbiA9IGNsYW1wKGRvdChub3JtYWxpemUoY3ptX3ZpZXdlclBvc2l0aW9uV0MpLCBhdG1vc3BoZXJlTGlnaHREaXJlY3Rpb24pLCB1X21pbmltdW1CcmlnaHRuZXNzLCAxLjApO1xcblxcXG4gICAgZm9nQ29sb3IgKj0gZGFya2VuO1xcblxcXG4jZW5kaWZcXG5cXFxuXFxuXFxcbiNpZmRlZiBIRFJcXG5cXFxuICAgIGNvbnN0IGZsb2F0IG1vZGlmaWVyID0gMC4xNTtcXG5cXFxuICAgIGZpbmFsQ29sb3IgPSB2ZWM0KGN6bV9mb2codl9kaXN0YW5jZSwgZmluYWxDb2xvci5yZ2IsIGZvZ0NvbG9yLCBtb2RpZmllciksIGZpbmFsQ29sb3IuYSk7XFxuXFxcbiNlbHNlXFxuXFxcbiAgICBmaW5hbENvbG9yID0gdmVjNChjem1fZm9nKHZfZGlzdGFuY2UsIGZpbmFsQ29sb3IucmdiLCBmb2dDb2xvciksIGZpbmFsQ29sb3IuYSk7XFxuXFxcbiNlbmRpZlxcblxcXG4jZW5kaWZcXG5cXFxuXFxuXFxcbiNpZmRlZiBHUk9VTkRfQVRNT1NQSEVSRVxcblxcXG4gICAgaWYgKCFjem1fYmFja0ZhY2luZygpKVxcblxcXG4gICAge1xcblxcXG4gICAgICAgIHZlYzMgZ3JvdW5kQXRtb3NwaGVyZUNvbG9yID0gY29tcHV0ZUdyb3VuZEF0bW9zcGhlcmVDb2xvcihmb2dDb2xvciwgZmluYWxDb2xvciwgYXRtb3NwaGVyZUxpZ2h0RGlyZWN0aW9uLCBjYW1lcmFEaXN0KTtcXG5cXFxuICAgICAgICBmaW5hbENvbG9yID0gdmVjNChtaXgoZmluYWxDb2xvci5yZ2IsIGdyb3VuZEF0bW9zcGhlcmVDb2xvciwgZmFkZSksIGZpbmFsQ29sb3IuYSk7XFxuXFxcbiAgICB9XFxuXFxcbiNlbmRpZlxcblxcXG5cXG5cXFxuI2lmZGVmIFVOREVSR1JPVU5EX0NPTE9SXFxuXFxcbiAgICBpZiAoY3ptX2JhY2tGYWNpbmcoKSlcXG5cXFxuICAgIHtcXG5cXFxuICAgICAgICBmbG9hdCBkaXN0YW5jZUZyb21FbGxpcHNvaWQgPSBtYXgoY3ptX2V5ZUhlaWdodCwgMC4wKTtcXG5cXFxuICAgICAgICBmbG9hdCBkaXN0YW5jZSA9IG1heCh2X2Rpc3RhbmNlIC0gZGlzdGFuY2VGcm9tRWxsaXBzb2lkLCAwLjApO1xcblxcXG4gICAgICAgIGZsb2F0IGJsZW5kQW1vdW50ID0gaW50ZXJwb2xhdGVCeURpc3RhbmNlKHVfdW5kZXJncm91bmRDb2xvckFscGhhQnlEaXN0YW5jZSwgZGlzdGFuY2UpO1xcblxcXG4gICAgICAgIHZlYzQgdW5kZXJncm91bmRDb2xvciA9IHZlYzQodV91bmRlcmdyb3VuZENvbG9yLnJnYiwgdV91bmRlcmdyb3VuZENvbG9yLmEgKiBibGVuZEFtb3VudCk7XFxuXFxcbiAgICAgICAgZmluYWxDb2xvciA9IGFscGhhQmxlbmQodW5kZXJncm91bmRDb2xvciwgZmluYWxDb2xvcik7XFxuXFxcbiAgICB9XFxuXFxcbiNlbmRpZlxcblxcXG5cXG5cXFxuI2lmZGVmIFRSQU5TTFVDRU5UXFxuXFxcbiAgICBpZiAoaW5UcmFuc2x1Y2VuY3lSZWN0YW5nbGUoKSlcXG5cXFxuICAgIHtcXG5cXFxuICAgICAgdmVjNCBhbHBoYUJ5RGlzdGFuY2UgPSBnbF9Gcm9udEZhY2luZyA/IHVfZnJvbnRGYWNlQWxwaGFCeURpc3RhbmNlIDogdV9iYWNrRmFjZUFscGhhQnlEaXN0YW5jZTtcXG5cXFxuICAgICAgZmluYWxDb2xvci5hICo9IGludGVycG9sYXRlQnlEaXN0YW5jZShhbHBoYUJ5RGlzdGFuY2UsIHZfZGlzdGFuY2UpO1xcblxcXG4gICAgfVxcblxcXG4jZW5kaWZcXG5cXFxuXFxuXFxcbiAgICBnbF9GcmFnQ29sb3IgPSBmaW5hbENvbG9yO1xcblxcXG59XFxuXFxcblxcblxcXG4jaWZkZWYgR1JPVU5EX0FUTU9TUEhFUkVcXG5cXFxudmVjMyBjb21wdXRlR3JvdW5kQXRtb3NwaGVyZUNvbG9yKHZlYzMgZm9nQ29sb3IsIHZlYzQgZmluYWxDb2xvciwgdmVjMyBhdG1vc3BoZXJlTGlnaHREaXJlY3Rpb24sIGZsb2F0IGNhbWVyYURpc3QpXFxuXFxcbntcXG5cXFxuI2lmIGRlZmluZWQoUEVSX0ZSQUdNRU5UX0dST1VORF9BVE1PU1BIRVJFKSAmJiBkZWZpbmVkKERZTkFNSUNfQVRNT1NQSEVSRV9MSUdIVElORykgJiYgKGRlZmluZWQoRU5BQkxFX0RBWU5JR0hUX1NIQURJTkcpIHx8IGRlZmluZWQoRU5BQkxFX1ZFUlRFWF9MSUdIVElORykpXFxuXFxcbiAgICBmbG9hdCBtcHAgPSBjem1fbWV0ZXJzUGVyUGl4ZWwodmVjNCgwLjAsIDAuMCwgLWN6bV9jdXJyZW50RnJ1c3R1bS54LCAxLjApLCAxLjApO1xcblxcXG4gICAgdmVjMiB4eSA9IGdsX0ZyYWdDb29yZC54eSAvIGN6bV92aWV3cG9ydC56dyAqIDIuMCAtIHZlYzIoMS4wKTtcXG5cXFxuICAgIHh5ICo9IGN6bV92aWV3cG9ydC56dyAqIG1wcCAqIDAuNTtcXG5cXFxuXFxuXFxcbiAgICB2ZWMzIGRpcmVjdGlvbiA9IG5vcm1hbGl6ZSh2ZWMzKHh5LCAtY3ptX2N1cnJlbnRGcnVzdHVtLngpKTtcXG5cXFxuICAgIGN6bV9yYXkgcmF5ID0gY3ptX3JheSh2ZWMzKDAuMCksIGRpcmVjdGlvbik7XFxuXFxcblxcblxcXG4gICAgdmVjMyBlbGxpcHNvaWRfY2VudGVyID0gY3ptX3ZpZXdbM10ueHl6O1xcblxcXG5cXG5cXFxuICAgIGN6bV9yYXlTZWdtZW50IGludGVyc2VjdGlvbiA9IGN6bV9yYXlFbGxpcHNvaWRJbnRlcnNlY3Rpb25JbnRlcnZhbChyYXksIGVsbGlwc29pZF9jZW50ZXIsIGN6bV9lbGxpcHNvaWRJbnZlcnNlUmFkaWkpO1xcblxcXG5cXG5cXFxuICAgIHZlYzMgZWxsaXBzb2lkUG9zaXRpb24gPSBjem1fcG9pbnRBbG9uZ1JheShyYXksIGludGVyc2VjdGlvbi5zdGFydCk7XFxuXFxcbiAgICBlbGxpcHNvaWRQb3NpdGlvbiA9IChjem1faW52ZXJzZVZpZXcgKiB2ZWM0KGVsbGlwc29pZFBvc2l0aW9uLCAxLjApKS54eXo7XFxuXFxcbiAgICBBdG1vc3BoZXJlQ29sb3IgYXRtb3NDb2xvciA9IGNvbXB1dGVHcm91bmRBdG1vc3BoZXJlRnJvbVNwYWNlKGVsbGlwc29pZFBvc2l0aW9uLCB0cnVlLCBhdG1vc3BoZXJlTGlnaHREaXJlY3Rpb24pO1xcblxcXG5cXG5cXFxuICAgIHZlYzMgZ3JvdW5kQXRtb3NwaGVyZUNvbG9yID0gY29sb3JDb3JyZWN0KGF0bW9zQ29sb3IubWllKSArIGZpbmFsQ29sb3IucmdiICogY29sb3JDb3JyZWN0KGF0bW9zQ29sb3IucmF5bGVpZ2gpO1xcblxcXG4jaWZuZGVmIEhEUlxcblxcXG4gICAgZ3JvdW5kQXRtb3NwaGVyZUNvbG9yID0gdmVjMygxLjApIC0gZXhwKC1mRXhwb3N1cmUgKiBncm91bmRBdG1vc3BoZXJlQ29sb3IpO1xcblxcXG4jZW5kaWZcXG5cXFxuXFxuXFxcbiAgICBmbG9hdCBmYWRlSW5EaXN0ID0gdV9uaWdodEZhZGVEaXN0YW5jZS54O1xcblxcXG4gICAgZmxvYXQgZmFkZU91dERpc3QgPSB1X25pZ2h0RmFkZURpc3RhbmNlLnk7XFxuXFxcblxcblxcXG4gICAgZmxvYXQgc3VubGl0QXRtb3NwaGVyZUludGVuc2l0eSA9IGNsYW1wKChjYW1lcmFEaXN0IC0gZmFkZU91dERpc3QpIC8gKGZhZGVJbkRpc3QgLSBmYWRlT3V0RGlzdCksIDAuMCwgMS4wKTtcXG5cXFxuXFxuXFxcbiNpZmRlZiBIRFJcXG5cXFxuICAgIC8vIFNvbWUgdHdlYWtpbmcgdG8gbWFrZSBIRFIgbG9vayBiZXR0ZXJcXG5cXFxuICAgIHN1bmxpdEF0bW9zcGhlcmVJbnRlbnNpdHkgPSBtYXgoc3VubGl0QXRtb3NwaGVyZUludGVuc2l0eSAqIHN1bmxpdEF0bW9zcGhlcmVJbnRlbnNpdHksIDAuMDMpO1xcblxcXG4jZW5kaWZcXG5cXFxuXFxuXFxcbiAgICBncm91bmRBdG1vc3BoZXJlQ29sb3IgPSBtaXgoZ3JvdW5kQXRtb3NwaGVyZUNvbG9yLCBmb2dDb2xvciwgc3VubGl0QXRtb3NwaGVyZUludGVuc2l0eSk7XFxuXFxcbiNlbHNlXFxuXFxcbiAgICB2ZWMzIGdyb3VuZEF0bW9zcGhlcmVDb2xvciA9IGZvZ0NvbG9yO1xcblxcXG4jZW5kaWZcXG5cXFxuXFxuXFxcbiNpZmRlZiBIRFJcXG5cXFxuICAgIC8vIFNvbWUgdHdlYWtpbmcgdG8gbWFrZSBIRFIgbG9vayBiZXR0ZXJcXG5cXFxuICAgIGdyb3VuZEF0bW9zcGhlcmVDb2xvciA9IGN6bV9zYXR1cmF0aW9uKGdyb3VuZEF0bW9zcGhlcmVDb2xvciwgMS42KTtcXG5cXFxuI2VuZGlmXFxuXFxcblxcblxcXG4gICAgcmV0dXJuIGdyb3VuZEF0bW9zcGhlcmVDb2xvcjtcXG5cXFxufVxcblxcXG4jZW5kaWZcXG5cXFxuXFxuXFxcbiNpZmRlZiBTSE9XX1JFRkxFQ1RJVkVfT0NFQU5cXG5cXFxuXFxuXFxcbmZsb2F0IHdhdmVGYWRlKGZsb2F0IGVkZ2UwLCBmbG9hdCBlZGdlMSwgZmxvYXQgeClcXG5cXFxue1xcblxcXG4gICAgZmxvYXQgeSA9IGNsYW1wKCh4IC0gZWRnZTApIC8gKGVkZ2UxIC0gZWRnZTApLCAwLjAsIDEuMCk7XFxuXFxcbiAgICByZXR1cm4gcG93KDEuMCAtIHksIDUuMCk7XFxuXFxcbn1cXG5cXFxuXFxuXFxcbmZsb2F0IGxpbmVhckZhZGUoZmxvYXQgZWRnZTAsIGZsb2F0IGVkZ2UxLCBmbG9hdCB4KVxcblxcXG57XFxuXFxcbiAgICByZXR1cm4gY2xhbXAoKHggLSBlZGdlMCkgLyAoZWRnZTEgLSBlZGdlMCksIDAuMCwgMS4wKTtcXG5cXFxufVxcblxcXG5cXG5cXFxuLy8gQmFzZWQgb24gd2F0ZXIgcmVuZGVyaW5nIGJ5IEpvbmFzIFdhZ25lcjpcXG5cXFxuLy8gaHR0cDovLzI5YS5jaC8yMDEyLzcvMTkvd2ViZ2wtdGVycmFpbi1yZW5kZXJpbmctd2F0ZXItZm9nXFxuXFxcblxcblxcXG4vLyBsb3cgYWx0aXR1ZGUgd2F2ZSBzZXR0aW5nc1xcblxcXG5jb25zdCBmbG9hdCBvY2VhbkZyZXF1ZW5jeUxvd0FsdGl0dWRlID0gODI1MDAwLjA7XFxuXFxcbmNvbnN0IGZsb2F0IG9jZWFuQW5pbWF0aW9uU3BlZWRMb3dBbHRpdHVkZSA9IDAuMDA0O1xcblxcXG5jb25zdCBmbG9hdCBvY2Vhbk9uZU92ZXJBbXBsaXR1ZGVMb3dBbHRpdHVkZSA9IDEuMCAvIDIuMDtcXG5cXFxuY29uc3QgZmxvYXQgb2NlYW5TcGVjdWxhckludGVuc2l0eSA9IDAuNTtcXG5cXFxuXFxuXFxcbi8vIGhpZ2ggYWx0aXR1ZGUgd2F2ZSBzZXR0aW5nc1xcblxcXG5jb25zdCBmbG9hdCBvY2VhbkZyZXF1ZW5jeUhpZ2hBbHRpdHVkZSA9IDEyNTAwMC4wO1xcblxcXG5jb25zdCBmbG9hdCBvY2VhbkFuaW1hdGlvblNwZWVkSGlnaEFsdGl0dWRlID0gMC4wMDg7XFxuXFxcbmNvbnN0IGZsb2F0IG9jZWFuT25lT3ZlckFtcGxpdHVkZUhpZ2hBbHRpdHVkZSA9IDEuMCAvIDIuMDtcXG5cXFxuXFxuXFxcbnZlYzQgY29tcHV0ZVdhdGVyQ29sb3IodmVjMyBwb3NpdGlvbkV5ZUNvb3JkaW5hdGVzLCB2ZWMyIHRleHR1cmVDb29yZGluYXRlcywgbWF0MyBlbnVUb0V5ZSwgdmVjNCBpbWFnZXJ5Q29sb3IsIGZsb2F0IG1hc2tWYWx1ZSwgZmxvYXQgZmFkZSlcXG5cXFxue1xcblxcXG4gICAgdmVjMyBwb3NpdGlvblRvRXllRUMgPSAtcG9zaXRpb25FeWVDb29yZGluYXRlcztcXG5cXFxuICAgIGZsb2F0IHBvc2l0aW9uVG9FeWVFQ0xlbmd0aCA9IGxlbmd0aChwb3NpdGlvblRvRXllRUMpO1xcblxcXG5cXG5cXFxuICAgIC8vIFRoZSBkb3VibGUgbm9ybWFsaXplIGJlbG93IHdvcmtzIGFyb3VuZCBhIGJ1ZyBpbiBGaXJlZm94IG9uIEFuZHJvaWQgZGV2aWNlcy5cXG5cXFxuICAgIHZlYzMgbm9ybWFsaXplZFBvc2l0aW9uVG9FeWVFQyA9IG5vcm1hbGl6ZShub3JtYWxpemUocG9zaXRpb25Ub0V5ZUVDKSk7XFxuXFxcblxcblxcXG4gICAgLy8gRmFkZSBvdXQgdGhlIHdhdmVzIGFzIHRoZSBjYW1lcmEgbW92ZXMgZmFyIGZyb20gdGhlIHN1cmZhY2UuXFxuXFxcbiAgICBmbG9hdCB3YXZlSW50ZW5zaXR5ID0gd2F2ZUZhZGUoNzAwMDAuMCwgMTAwMDAwMC4wLCBwb3NpdGlvblRvRXllRUNMZW5ndGgpO1xcblxcXG5cXG5cXFxuI2lmZGVmIFNIT1dfT0NFQU5fV0FWRVNcXG5cXFxuICAgIC8vIGhpZ2ggYWx0aXR1ZGUgd2F2ZXNcXG5cXFxuICAgIGZsb2F0IHRpbWUgPSBjem1fZnJhbWVOdW1iZXIgKiBvY2VhbkFuaW1hdGlvblNwZWVkSGlnaEFsdGl0dWRlO1xcblxcXG4gICAgdmVjNCBub2lzZSA9IGN6bV9nZXRXYXRlck5vaXNlKHVfb2NlYW5Ob3JtYWxNYXAsIHRleHR1cmVDb29yZGluYXRlcyAqIG9jZWFuRnJlcXVlbmN5SGlnaEFsdGl0dWRlLCB0aW1lLCAwLjApO1xcblxcXG4gICAgdmVjMyBub3JtYWxUYW5nZW50U3BhY2VIaWdoQWx0aXR1ZGUgPSB2ZWMzKG5vaXNlLnh5LCBub2lzZS56ICogb2NlYW5PbmVPdmVyQW1wbGl0dWRlSGlnaEFsdGl0dWRlKTtcXG5cXFxuXFxuXFxcbiAgICAvLyBsb3cgYWx0aXR1ZGUgd2F2ZXNcXG5cXFxuICAgIHRpbWUgPSBjem1fZnJhbWVOdW1iZXIgKiBvY2VhbkFuaW1hdGlvblNwZWVkTG93QWx0aXR1ZGU7XFxuXFxcbiAgICBub2lzZSA9IGN6bV9nZXRXYXRlck5vaXNlKHVfb2NlYW5Ob3JtYWxNYXAsIHRleHR1cmVDb29yZGluYXRlcyAqIG9jZWFuRnJlcXVlbmN5TG93QWx0aXR1ZGUsIHRpbWUsIDAuMCk7XFxuXFxcbiAgICB2ZWMzIG5vcm1hbFRhbmdlbnRTcGFjZUxvd0FsdGl0dWRlID0gdmVjMyhub2lzZS54eSwgbm9pc2UueiAqIG9jZWFuT25lT3ZlckFtcGxpdHVkZUxvd0FsdGl0dWRlKTtcXG5cXFxuXFxuXFxcbiAgICAvLyBibGVuZCB0aGUgMiB3YXZlIGxheWVycyBiYXNlZCBvbiBkaXN0YW5jZSB0byBzdXJmYWNlXFxuXFxcbiAgICBmbG9hdCBoaWdoQWx0aXR1ZGVGYWRlID0gbGluZWFyRmFkZSgwLjAsIDYwMDAwLjAsIHBvc2l0aW9uVG9FeWVFQ0xlbmd0aCk7XFxuXFxcbiAgICBmbG9hdCBsb3dBbHRpdHVkZUZhZGUgPSAxLjAgLSBsaW5lYXJGYWRlKDIwMDAwLjAsIDYwMDAwLjAsIHBvc2l0aW9uVG9FeWVFQ0xlbmd0aCk7XFxuXFxcbiAgICB2ZWMzIG5vcm1hbFRhbmdlbnRTcGFjZSA9XFxuXFxcbiAgICAgICAgKGhpZ2hBbHRpdHVkZUZhZGUgKiBub3JtYWxUYW5nZW50U3BhY2VIaWdoQWx0aXR1ZGUpICtcXG5cXFxuICAgICAgICAobG93QWx0aXR1ZGVGYWRlICogbm9ybWFsVGFuZ2VudFNwYWNlTG93QWx0aXR1ZGUpO1xcblxcXG4gICAgbm9ybWFsVGFuZ2VudFNwYWNlID0gbm9ybWFsaXplKG5vcm1hbFRhbmdlbnRTcGFjZSk7XFxuXFxcblxcblxcXG4gICAgLy8gZmFkZSBvdXQgdGhlIG5vcm1hbCBwZXJ0dXJiYXRpb24gYXMgd2UgbW92ZSBmYXJ0aGVyIGZyb20gdGhlIHdhdGVyIHN1cmZhY2VcXG5cXFxuICAgIG5vcm1hbFRhbmdlbnRTcGFjZS54eSAqPSB3YXZlSW50ZW5zaXR5O1xcblxcXG4gICAgbm9ybWFsVGFuZ2VudFNwYWNlID0gbm9ybWFsaXplKG5vcm1hbFRhbmdlbnRTcGFjZSk7XFxuXFxcbiNlbHNlXFxuXFxcbiAgICB2ZWMzIG5vcm1hbFRhbmdlbnRTcGFjZSA9IHZlYzMoMC4wLCAwLjAsIDEuMCk7XFxuXFxcbiNlbmRpZlxcblxcXG5cXG5cXFxuICAgIHZlYzMgbm9ybWFsRUMgPSBlbnVUb0V5ZSAqIG5vcm1hbFRhbmdlbnRTcGFjZTtcXG5cXFxuXFxuXFxcbiAgICBjb25zdCB2ZWMzIHdhdmVIaWdobGlnaHRDb2xvciA9IHZlYzMoMC4zLCAwLjQ1LCAwLjYpO1xcblxcXG5cXG5cXFxuICAgIC8vIFVzZSBkaWZmdXNlIGxpZ2h0IHRvIGhpZ2hsaWdodCB0aGUgd2F2ZXNcXG5cXFxuICAgIGZsb2F0IGRpZmZ1c2VJbnRlbnNpdHkgPSBjem1fZ2V0TGFtYmVydERpZmZ1c2UoY3ptX2xpZ2h0RGlyZWN0aW9uRUMsIG5vcm1hbEVDKSAqIG1hc2tWYWx1ZTtcXG5cXFxuICAgIHZlYzMgZGlmZnVzZUhpZ2hsaWdodCA9IHdhdmVIaWdobGlnaHRDb2xvciAqIGRpZmZ1c2VJbnRlbnNpdHkgKiAoMS4wIC0gZmFkZSk7XFxuXFxcblxcblxcXG4jaWZkZWYgU0hPV19PQ0VBTl9XQVZFU1xcblxcXG4gICAgLy8gV2hlcmUgZGlmZnVzZSBsaWdodCBpcyBsb3cgb3Igbm9uLWV4aXN0ZW50LCB1c2Ugd2F2ZSBoaWdobGlnaHRzIGJhc2VkIHNvbGVseSBvblxcblxcXG4gICAgLy8gdGhlIHdhdmUgYnVtcGluZXNzIGFuZCBubyBwYXJ0aWN1bGFyIGxpZ2h0IGRpcmVjdGlvbi5cXG5cXFxuICAgIGZsb2F0IHRzUGVydHVyYmF0aW9uUmF0aW8gPSBub3JtYWxUYW5nZW50U3BhY2UuejtcXG5cXFxuICAgIHZlYzMgbm9uRGlmZnVzZUhpZ2hsaWdodCA9IG1peCh3YXZlSGlnaGxpZ2h0Q29sb3IgKiA1LjAgKiAoMS4wIC0gdHNQZXJ0dXJiYXRpb25SYXRpbyksIHZlYzMoMC4wKSwgZGlmZnVzZUludGVuc2l0eSk7XFxuXFxcbiNlbHNlXFxuXFxcbiAgICB2ZWMzIG5vbkRpZmZ1c2VIaWdobGlnaHQgPSB2ZWMzKDAuMCk7XFxuXFxcbiNlbmRpZlxcblxcXG5cXG5cXFxuICAgIC8vIEFkZCBzcGVjdWxhciBoaWdobGlnaHRzIGluIDNELCBhbmQgaW4gYWxsIG1vZGVzIHdoZW4gem9vbWVkIGluLlxcblxcXG4gICAgZmxvYXQgc3BlY3VsYXJJbnRlbnNpdHkgPSBjem1fZ2V0U3BlY3VsYXIoY3ptX2xpZ2h0RGlyZWN0aW9uRUMsIG5vcm1hbGl6ZWRQb3NpdGlvblRvRXllRUMsIG5vcm1hbEVDLCAxMC4wKTtcXG5cXFxuICAgIGZsb2F0IHN1cmZhY2VSZWZsZWN0YW5jZSA9IG1peCgwLjAsIG1peCh1X3pvb21lZE91dE9jZWFuU3BlY3VsYXJJbnRlbnNpdHksIG9jZWFuU3BlY3VsYXJJbnRlbnNpdHksIHdhdmVJbnRlbnNpdHkpLCBtYXNrVmFsdWUpO1xcblxcXG4gICAgZmxvYXQgc3BlY3VsYXIgPSBzcGVjdWxhckludGVuc2l0eSAqIHN1cmZhY2VSZWZsZWN0YW5jZTtcXG5cXFxuXFxuXFxcbiNpZmRlZiBIRFJcXG5cXFxuICAgIHNwZWN1bGFyICo9IDEuNDtcXG5cXFxuXFxuXFxcbiAgICBmbG9hdCBlID0gMC4yO1xcblxcXG4gICAgZmxvYXQgZCA9IDMuMztcXG5cXFxuICAgIGZsb2F0IGMgPSAxLjc7XFxuXFxcblxcblxcXG4gICAgdmVjMyBjb2xvciA9IGltYWdlcnlDb2xvci5yZ2IgKyAoYyAqICh2ZWMzKGUpICsgaW1hZ2VyeUNvbG9yLnJnYiAqIGQpICogKGRpZmZ1c2VIaWdobGlnaHQgKyBub25EaWZmdXNlSGlnaGxpZ2h0ICsgc3BlY3VsYXIpKTtcXG5cXFxuI2Vsc2VcXG5cXFxuICAgIHZlYzMgY29sb3IgPSBpbWFnZXJ5Q29sb3IucmdiICsgZGlmZnVzZUhpZ2hsaWdodCArIG5vbkRpZmZ1c2VIaWdobGlnaHQgKyBzcGVjdWxhcjtcXG5cXFxuI2VuZGlmXFxuXFxcblxcblxcXG4gICAgcmV0dXJuIHZlYzQoY29sb3IsIGltYWdlcnlDb2xvci5hKTtcXG5cXFxufVxcblxcXG5cXG5cXFxuI2VuZGlmIC8vICNpZmRlZiBTSE9XX1JFRkxFQ1RJVkVfT0NFQU5cXG5cXFxuXCI7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///20909\n')},15314:function(__unused_webpack___webpack_module__,__webpack_exports__){eval('//This file is automatically rebuilt by the Cesium build process.\n/* harmony default export */ __webpack_exports__["Z"] = ("#ifdef QUANTIZATION_BITS12\\n\\\nattribute vec4 compressed0;\\n\\\nattribute float compressed1;\\n\\\n#else\\n\\\nattribute vec4 position3DAndHeight;\\n\\\nattribute vec4 textureCoordAndEncodedNormals;\\n\\\n#endif\\n\\\n\\n\\\n#ifdef GEODETIC_SURFACE_NORMALS\\n\\\nattribute vec3 geodeticSurfaceNormal;\\n\\\n#endif\\n\\\n\\n\\\n#ifdef EXAGGERATION\\n\\\nuniform vec2 u_terrainExaggerationAndRelativeHeight;\\n\\\n#endif\\n\\\n\\n\\\nuniform vec3 u_center3D;\\n\\\nuniform mat4 u_modifiedModelView;\\n\\\nuniform mat4 u_modifiedModelViewProjection;\\n\\\nuniform vec4 u_tileRectangle;\\n\\\n\\n\\\n// Uniforms for 2D Mercator projection\\n\\\nuniform vec2 u_southAndNorthLatitude;\\n\\\nuniform vec2 u_southMercatorYAndOneOverHeight;\\n\\\n\\n\\\nvarying vec3 v_positionMC;\\n\\\nvarying vec3 v_positionEC;\\n\\\n\\n\\\nvarying vec3 v_textureCoordinates;\\n\\\nvarying vec3 v_normalMC;\\n\\\nvarying vec3 v_normalEC;\\n\\\n\\n\\\n#ifdef APPLY_MATERIAL\\n\\\nvarying float v_slope;\\n\\\nvarying float v_aspect;\\n\\\nvarying float v_height;\\n\\\n#endif\\n\\\n\\n\\\n#if defined(FOG) || defined(GROUND_ATMOSPHERE) || defined(UNDERGROUND_COLOR) || defined(TRANSLUCENT)\\n\\\nvarying float v_distance;\\n\\\n#endif\\n\\\n\\n\\\n#if defined(FOG) || defined(GROUND_ATMOSPHERE)\\n\\\nvarying vec3 v_fogMieColor;\\n\\\nvarying vec3 v_fogRayleighColor;\\n\\\n#endif\\n\\\n\\n\\\n// These functions are generated at runtime.\\n\\\nvec4 getPosition(vec3 position, float height, vec2 textureCoordinates);\\n\\\nfloat get2DYPositionFraction(vec2 textureCoordinates);\\n\\\n\\n\\\nvec4 getPosition3DMode(vec3 position, float height, vec2 textureCoordinates)\\n\\\n{\\n\\\n    return u_modifiedModelViewProjection * vec4(position, 1.0);\\n\\\n}\\n\\\n\\n\\\nfloat get2DMercatorYPositionFraction(vec2 textureCoordinates)\\n\\\n{\\n\\\n    // The width of a tile at level 11, in radians and assuming a single root tile, is\\n\\\n    //   2.0 * czm_pi / pow(2.0, 11.0)\\n\\\n    // We want to just linearly interpolate the 2D position from the texture coordinates\\n\\\n    // when we\'re at this level or higher.  The constant below is the expression\\n\\\n    // above evaluated and then rounded up at the 4th significant digit.\\n\\\n    const float maxTileWidth = 0.003068;\\n\\\n    float positionFraction = textureCoordinates.y;\\n\\\n    float southLatitude = u_southAndNorthLatitude.x;\\n\\\n    float northLatitude = u_southAndNorthLatitude.y;\\n\\\n    if (northLatitude - southLatitude > maxTileWidth)\\n\\\n    {\\n\\\n        float southMercatorY = u_southMercatorYAndOneOverHeight.x;\\n\\\n        float oneOverMercatorHeight = u_southMercatorYAndOneOverHeight.y;\\n\\\n\\n\\\n        float currentLatitude = mix(southLatitude, northLatitude, textureCoordinates.y);\\n\\\n        currentLatitude = clamp(currentLatitude, -czm_webMercatorMaxLatitude, czm_webMercatorMaxLatitude);\\n\\\n        positionFraction = czm_latitudeToWebMercatorFraction(currentLatitude, southMercatorY, oneOverMercatorHeight);\\n\\\n    }\\n\\\n    return positionFraction;\\n\\\n}\\n\\\n\\n\\\nfloat get2DGeographicYPositionFraction(vec2 textureCoordinates)\\n\\\n{\\n\\\n    return textureCoordinates.y;\\n\\\n}\\n\\\n\\n\\\nvec4 getPositionPlanarEarth(vec3 position, float height, vec2 textureCoordinates)\\n\\\n{\\n\\\n    float yPositionFraction = get2DYPositionFraction(textureCoordinates);\\n\\\n    vec4 rtcPosition2D = vec4(height, mix(u_tileRectangle.st, u_tileRectangle.pq, vec2(textureCoordinates.x, yPositionFraction)), 1.0);\\n\\\n    return u_modifiedModelViewProjection * rtcPosition2D;\\n\\\n}\\n\\\n\\n\\\nvec4 getPosition2DMode(vec3 position, float height, vec2 textureCoordinates)\\n\\\n{\\n\\\n    return getPositionPlanarEarth(position, 0.0, textureCoordinates);\\n\\\n}\\n\\\n\\n\\\nvec4 getPositionColumbusViewMode(vec3 position, float height, vec2 textureCoordinates)\\n\\\n{\\n\\\n    return getPositionPlanarEarth(position, height, textureCoordinates);\\n\\\n}\\n\\\n\\n\\\nvec4 getPositionMorphingMode(vec3 position, float height, vec2 textureCoordinates)\\n\\\n{\\n\\\n    // We do not do RTC while morphing, so there is potential for jitter.\\n\\\n    // This is unlikely to be noticeable, though.\\n\\\n    vec3 position3DWC = position + u_center3D;\\n\\\n    float yPositionFraction = get2DYPositionFraction(textureCoordinates);\\n\\\n    vec4 position2DWC = vec4(height, mix(u_tileRectangle.st, u_tileRectangle.pq, vec2(textureCoordinates.x, yPositionFraction)), 1.0);\\n\\\n    vec4 morphPosition = czm_columbusViewMorph(position2DWC, vec4(position3DWC, 1.0), czm_morphTime);\\n\\\n    return czm_modelViewProjection * morphPosition;\\n\\\n}\\n\\\n\\n\\\n#ifdef QUANTIZATION_BITS12\\n\\\nuniform vec2 u_minMaxHeight;\\n\\\nuniform mat4 u_scaleAndBias;\\n\\\n#endif\\n\\\n\\n\\\nvoid main()\\n\\\n{\\n\\\n#ifdef QUANTIZATION_BITS12\\n\\\n    vec2 xy = czm_decompressTextureCoordinates(compressed0.x);\\n\\\n    vec2 zh = czm_decompressTextureCoordinates(compressed0.y);\\n\\\n    vec3 position = vec3(xy, zh.x);\\n\\\n    float height = zh.y;\\n\\\n    vec2 textureCoordinates = czm_decompressTextureCoordinates(compressed0.z);\\n\\\n\\n\\\n    height = height * (u_minMaxHeight.y - u_minMaxHeight.x) + u_minMaxHeight.x;\\n\\\n    position = (u_scaleAndBias * vec4(position, 1.0)).xyz;\\n\\\n\\n\\\n#if (defined(ENABLE_VERTEX_LIGHTING) || defined(GENERATE_POSITION_AND_NORMAL)) && defined(INCLUDE_WEB_MERCATOR_Y)\\n\\\n    float webMercatorT = czm_decompressTextureCoordinates(compressed0.w).x;\\n\\\n    float encodedNormal = compressed1;\\n\\\n#elif defined(INCLUDE_WEB_MERCATOR_Y)\\n\\\n    float webMercatorT = czm_decompressTextureCoordinates(compressed0.w).x;\\n\\\n    float encodedNormal = 0.0;\\n\\\n#elif defined(ENABLE_VERTEX_LIGHTING) || defined(GENERATE_POSITION_AND_NORMAL)\\n\\\n    float webMercatorT = textureCoordinates.y;\\n\\\n    float encodedNormal = compressed0.w;\\n\\\n#else\\n\\\n    float webMercatorT = textureCoordinates.y;\\n\\\n    float encodedNormal = 0.0;\\n\\\n#endif\\n\\\n\\n\\\n#else\\n\\\n    // A single float per element\\n\\\n    vec3 position = position3DAndHeight.xyz;\\n\\\n    float height = position3DAndHeight.w;\\n\\\n    vec2 textureCoordinates = textureCoordAndEncodedNormals.xy;\\n\\\n\\n\\\n#if (defined(ENABLE_VERTEX_LIGHTING) || defined(GENERATE_POSITION_AND_NORMAL) || defined(APPLY_MATERIAL)) && defined(INCLUDE_WEB_MERCATOR_Y)\\n\\\n    float webMercatorT = textureCoordAndEncodedNormals.z;\\n\\\n    float encodedNormal = textureCoordAndEncodedNormals.w;\\n\\\n#elif defined(ENABLE_VERTEX_LIGHTING) || defined(GENERATE_POSITION_AND_NORMAL) || defined(APPLY_MATERIAL)\\n\\\n    float webMercatorT = textureCoordinates.y;\\n\\\n    float encodedNormal = textureCoordAndEncodedNormals.z;\\n\\\n#elif defined(INCLUDE_WEB_MERCATOR_Y)\\n\\\n    float webMercatorT = textureCoordAndEncodedNormals.z;\\n\\\n    float encodedNormal = 0.0;\\n\\\n#else\\n\\\n    float webMercatorT = textureCoordinates.y;\\n\\\n    float encodedNormal = 0.0;\\n\\\n#endif\\n\\\n\\n\\\n#endif\\n\\\n\\n\\\n    vec3 position3DWC = position + u_center3D;\\n\\\n\\n\\\n#ifdef GEODETIC_SURFACE_NORMALS\\n\\\n    vec3 ellipsoidNormal = geodeticSurfaceNormal;\\n\\\n#else\\n\\\n    vec3 ellipsoidNormal = normalize(position3DWC);\\n\\\n#endif\\n\\\n\\n\\\n#if defined(EXAGGERATION) && defined(GEODETIC_SURFACE_NORMALS)\\n\\\n    float exaggeration = u_terrainExaggerationAndRelativeHeight.x;\\n\\\n    float relativeHeight = u_terrainExaggerationAndRelativeHeight.y;\\n\\\n    float newHeight = (height - relativeHeight) * exaggeration + relativeHeight;\\n\\\n\\n\\\n    // stop from going through center of earth\\n\\\n    float minRadius = min(min(czm_ellipsoidRadii.x, czm_ellipsoidRadii.y), czm_ellipsoidRadii.z);\\n\\\n    newHeight = max(newHeight, -minRadius);\\n\\\n\\n\\\n    vec3 offset = ellipsoidNormal * (newHeight - height);\\n\\\n    position += offset;\\n\\\n    position3DWC += offset;\\n\\\n    height = newHeight;\\n\\\n#endif\\n\\\n\\n\\\n    gl_Position = getPosition(position, height, textureCoordinates);\\n\\\n\\n\\\n    v_textureCoordinates = vec3(textureCoordinates, webMercatorT);\\n\\\n\\n\\\n#if defined(ENABLE_VERTEX_LIGHTING) || defined(GENERATE_POSITION_AND_NORMAL) || defined(APPLY_MATERIAL)\\n\\\n    v_positionEC = (u_modifiedModelView * vec4(position, 1.0)).xyz;\\n\\\n    v_positionMC = position3DWC;  // position in model coordinates\\n\\\n    vec3 normalMC = czm_octDecode(encodedNormal);\\n\\\n\\n\\\n#if defined(EXAGGERATION) && defined(GEODETIC_SURFACE_NORMALS)\\n\\\n    vec3 projection = dot(normalMC, ellipsoidNormal) * ellipsoidNormal;\\n\\\n    vec3 rejection = normalMC - projection;\\n\\\n    normalMC = normalize(projection + rejection * exaggeration);\\n\\\n#endif\\n\\\n\\n\\\n    v_normalMC = normalMC;\\n\\\n    v_normalEC = czm_normal3D * v_normalMC;\\n\\\n#elif defined(SHOW_REFLECTIVE_OCEAN) || defined(ENABLE_DAYNIGHT_SHADING) || defined(GENERATE_POSITION) || defined(HDR)\\n\\\n    v_positionEC = (u_modifiedModelView * vec4(position, 1.0)).xyz;\\n\\\n    v_positionMC = position3DWC;  // position in model coordinates\\n\\\n#endif\\n\\\n\\n\\\n#if defined(FOG) || defined(GROUND_ATMOSPHERE)\\n\\\n    AtmosphereColor atmosFogColor = computeGroundAtmosphereFromSpace(position3DWC, false, vec3(0.0));\\n\\\n    v_fogMieColor = atmosFogColor.mie;\\n\\\n    v_fogRayleighColor = atmosFogColor.rayleigh;\\n\\\n#endif\\n\\\n\\n\\\n#if defined(FOG) || defined(GROUND_ATMOSPHERE) || defined(UNDERGROUND_COLOR) || defined(TRANSLUCENT)\\n\\\n    v_distance = length((czm_modelView3D * vec4(position3DWC, 1.0)).xyz);\\n\\\n#endif\\n\\\n\\n\\\n#ifdef APPLY_MATERIAL\\n\\\n    float northPoleZ = czm_ellipsoidRadii.z;\\n\\\n    vec3 northPolePositionMC = vec3(0.0, 0.0, northPoleZ);\\n\\\n    vec3 vectorEastMC = normalize(cross(northPolePositionMC - v_positionMC, ellipsoidNormal));\\n\\\n    float dotProd = abs(dot(ellipsoidNormal, v_normalMC));\\n\\\n    v_slope = acos(dotProd);\\n\\\n    vec3 normalRejected = ellipsoidNormal * dotProd;\\n\\\n    vec3 normalProjected = v_normalMC - normalRejected;\\n\\\n    vec3 aspectVector = normalize(normalProjected);\\n\\\n    v_aspect = acos(dot(aspectVector, vectorEastMC));\\n\\\n    float determ = dot(cross(vectorEastMC, aspectVector), ellipsoidNormal);\\n\\\n    v_aspect = czm_branchFreeTernary(determ < 0.0, 2.0 * czm_pi - v_aspect, v_aspect);\\n\\\n    v_height = height;\\n\\\n#endif\\n\\\n}\\n\\\n");\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTUzMTQuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQSx5REFBZTtBQUNmLDJCQUEyQjtBQUMzQiw0QkFBNEI7QUFDNUI7QUFDQSxtQ0FBbUM7QUFDbkMsNkNBQTZDO0FBQzdDO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQztBQUNyQztBQUNBO0FBQ0E7QUFDQSxvREFBb0Q7QUFDcEQ7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QixpQ0FBaUM7QUFDakMsMkNBQTJDO0FBQzNDLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0EscUNBQXFDO0FBQ3JDLDhDQUE4QztBQUM5QztBQUNBLDBCQUEwQjtBQUMxQiwwQkFBMEI7QUFDMUI7QUFDQSxrQ0FBa0M7QUFDbEMsd0JBQXdCO0FBQ3hCLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCLHVCQUF1QjtBQUN2Qix1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQixnQ0FBZ0M7QUFDaEM7QUFDQTtBQUNBO0FBQ0EsdUVBQXVFO0FBQ3ZFLHNEQUFzRDtBQUN0RDtBQUNBO0FBQ0EsQ0FBQztBQUNELCtEQUErRDtBQUMvRCxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDO0FBQ3hDLGtEQUFrRDtBQUNsRCxvREFBb0Q7QUFDcEQsb0RBQW9EO0FBQ3BEO0FBQ0EsS0FBSztBQUNMLGtFQUFrRTtBQUNsRSx5RUFBeUU7QUFDekU7QUFDQSx3RkFBd0Y7QUFDeEYsMEdBQTBHO0FBQzFHLHFIQUFxSDtBQUNySCxLQUFLO0FBQ0wsNEJBQTRCO0FBQzVCLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNELGdDQUFnQztBQUNoQyxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRCx5RUFBeUU7QUFDekUsdUlBQXVJO0FBQ3ZJLHlEQUF5RDtBQUN6RCxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRCxxRUFBcUU7QUFDckUsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Qsd0VBQXdFO0FBQ3hFLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSw4Q0FBOEM7QUFDOUMseUVBQXlFO0FBQ3pFLHNJQUFzSTtBQUN0SSxxR0FBcUc7QUFDckcsbURBQW1EO0FBQ25ELENBQUM7QUFDRDtBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCLDRCQUE0QjtBQUM1QjtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQSw4REFBOEQ7QUFDOUQsOERBQThEO0FBQzlELG1DQUFtQztBQUNuQyx3QkFBd0I7QUFDeEIsOEVBQThFO0FBQzlFO0FBQ0EsK0VBQStFO0FBQy9FLDBEQUEwRDtBQUMxRDtBQUNBO0FBQ0EsMkVBQTJFO0FBQzNFLHNDQUFzQztBQUN0QztBQUNBLDJFQUEyRTtBQUMzRSw4QkFBOEI7QUFDOUI7QUFDQSw4Q0FBOEM7QUFDOUMsd0NBQXdDO0FBQ3hDO0FBQ0EsOENBQThDO0FBQzlDLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QztBQUM1Qyx5Q0FBeUM7QUFDekMsK0RBQStEO0FBQy9EO0FBQ0E7QUFDQSx5REFBeUQ7QUFDekQsMERBQTBEO0FBQzFEO0FBQ0EsOENBQThDO0FBQzlDLDBEQUEwRDtBQUMxRDtBQUNBLHlEQUF5RDtBQUN6RCw4QkFBOEI7QUFDOUI7QUFDQSw4Q0FBOEM7QUFDOUMsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDO0FBQzlDO0FBQ0E7QUFDQSxpREFBaUQ7QUFDakQ7QUFDQSxtREFBbUQ7QUFDbkQ7QUFDQTtBQUNBO0FBQ0Esa0VBQWtFO0FBQ2xFLG9FQUFvRTtBQUNwRSxnRkFBZ0Y7QUFDaEY7QUFDQTtBQUNBLGlHQUFpRztBQUNqRywyQ0FBMkM7QUFDM0M7QUFDQSx5REFBeUQ7QUFDekQsdUJBQXVCO0FBQ3ZCLDJCQUEyQjtBQUMzQix1QkFBdUI7QUFDdkI7QUFDQTtBQUNBLG9FQUFvRTtBQUNwRTtBQUNBLGtFQUFrRTtBQUNsRTtBQUNBO0FBQ0EsbUVBQW1FO0FBQ25FLGtDQUFrQztBQUNsQyxpREFBaUQ7QUFDakQ7QUFDQTtBQUNBLHVFQUF1RTtBQUN2RSwyQ0FBMkM7QUFDM0MsZ0VBQWdFO0FBQ2hFO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUIsMkNBQTJDO0FBQzNDO0FBQ0EsbUVBQW1FO0FBQ25FLGtDQUFrQztBQUNsQztBQUNBO0FBQ0E7QUFDQSxxR0FBcUc7QUFDckcsc0NBQXNDO0FBQ3RDLGdEQUFnRDtBQUNoRDtBQUNBO0FBQ0E7QUFDQSx5RUFBeUU7QUFDekU7QUFDQTtBQUNBO0FBQ0EsNENBQTRDO0FBQzVDLDBEQUEwRDtBQUMxRCw4RkFBOEY7QUFDOUYsMERBQTBEO0FBQzFELDRCQUE0QjtBQUM1QixvREFBb0Q7QUFDcEQsdURBQXVEO0FBQ3ZELG1EQUFtRDtBQUNuRCxxREFBcUQ7QUFDckQsMkVBQTJFO0FBQzNFLHNGQUFzRjtBQUN0RixzQkFBc0I7QUFDdEI7QUFDQSxDQUFDO0FBQ0QsQ0FBQyxFQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdnVlMy13ZWJwYWNrNS8uL25vZGVfbW9kdWxlcy9jZXNpdW0vU291cmNlL1NoYWRlcnMvR2xvYmVWUy5qcz81NmMxIl0sInNvdXJjZXNDb250ZW50IjpbIi8vVGhpcyBmaWxlIGlzIGF1dG9tYXRpY2FsbHkgcmVidWlsdCBieSB0aGUgQ2VzaXVtIGJ1aWxkIHByb2Nlc3MuXG5leHBvcnQgZGVmYXVsdCBcIiNpZmRlZiBRVUFOVElaQVRJT05fQklUUzEyXFxuXFxcbmF0dHJpYnV0ZSB2ZWM0IGNvbXByZXNzZWQwO1xcblxcXG5hdHRyaWJ1dGUgZmxvYXQgY29tcHJlc3NlZDE7XFxuXFxcbiNlbHNlXFxuXFxcbmF0dHJpYnV0ZSB2ZWM0IHBvc2l0aW9uM0RBbmRIZWlnaHQ7XFxuXFxcbmF0dHJpYnV0ZSB2ZWM0IHRleHR1cmVDb29yZEFuZEVuY29kZWROb3JtYWxzO1xcblxcXG4jZW5kaWZcXG5cXFxuXFxuXFxcbiNpZmRlZiBHRU9ERVRJQ19TVVJGQUNFX05PUk1BTFNcXG5cXFxuYXR0cmlidXRlIHZlYzMgZ2VvZGV0aWNTdXJmYWNlTm9ybWFsO1xcblxcXG4jZW5kaWZcXG5cXFxuXFxuXFxcbiNpZmRlZiBFWEFHR0VSQVRJT05cXG5cXFxudW5pZm9ybSB2ZWMyIHVfdGVycmFpbkV4YWdnZXJhdGlvbkFuZFJlbGF0aXZlSGVpZ2h0O1xcblxcXG4jZW5kaWZcXG5cXFxuXFxuXFxcbnVuaWZvcm0gdmVjMyB1X2NlbnRlcjNEO1xcblxcXG51bmlmb3JtIG1hdDQgdV9tb2RpZmllZE1vZGVsVmlldztcXG5cXFxudW5pZm9ybSBtYXQ0IHVfbW9kaWZpZWRNb2RlbFZpZXdQcm9qZWN0aW9uO1xcblxcXG51bmlmb3JtIHZlYzQgdV90aWxlUmVjdGFuZ2xlO1xcblxcXG5cXG5cXFxuLy8gVW5pZm9ybXMgZm9yIDJEIE1lcmNhdG9yIHByb2plY3Rpb25cXG5cXFxudW5pZm9ybSB2ZWMyIHVfc291dGhBbmROb3J0aExhdGl0dWRlO1xcblxcXG51bmlmb3JtIHZlYzIgdV9zb3V0aE1lcmNhdG9yWUFuZE9uZU92ZXJIZWlnaHQ7XFxuXFxcblxcblxcXG52YXJ5aW5nIHZlYzMgdl9wb3NpdGlvbk1DO1xcblxcXG52YXJ5aW5nIHZlYzMgdl9wb3NpdGlvbkVDO1xcblxcXG5cXG5cXFxudmFyeWluZyB2ZWMzIHZfdGV4dHVyZUNvb3JkaW5hdGVzO1xcblxcXG52YXJ5aW5nIHZlYzMgdl9ub3JtYWxNQztcXG5cXFxudmFyeWluZyB2ZWMzIHZfbm9ybWFsRUM7XFxuXFxcblxcblxcXG4jaWZkZWYgQVBQTFlfTUFURVJJQUxcXG5cXFxudmFyeWluZyBmbG9hdCB2X3Nsb3BlO1xcblxcXG52YXJ5aW5nIGZsb2F0IHZfYXNwZWN0O1xcblxcXG52YXJ5aW5nIGZsb2F0IHZfaGVpZ2h0O1xcblxcXG4jZW5kaWZcXG5cXFxuXFxuXFxcbiNpZiBkZWZpbmVkKEZPRykgfHwgZGVmaW5lZChHUk9VTkRfQVRNT1NQSEVSRSkgfHwgZGVmaW5lZChVTkRFUkdST1VORF9DT0xPUikgfHwgZGVmaW5lZChUUkFOU0xVQ0VOVClcXG5cXFxudmFyeWluZyBmbG9hdCB2X2Rpc3RhbmNlO1xcblxcXG4jZW5kaWZcXG5cXFxuXFxuXFxcbiNpZiBkZWZpbmVkKEZPRykgfHwgZGVmaW5lZChHUk9VTkRfQVRNT1NQSEVSRSlcXG5cXFxudmFyeWluZyB2ZWMzIHZfZm9nTWllQ29sb3I7XFxuXFxcbnZhcnlpbmcgdmVjMyB2X2ZvZ1JheWxlaWdoQ29sb3I7XFxuXFxcbiNlbmRpZlxcblxcXG5cXG5cXFxuLy8gVGhlc2UgZnVuY3Rpb25zIGFyZSBnZW5lcmF0ZWQgYXQgcnVudGltZS5cXG5cXFxudmVjNCBnZXRQb3NpdGlvbih2ZWMzIHBvc2l0aW9uLCBmbG9hdCBoZWlnaHQsIHZlYzIgdGV4dHVyZUNvb3JkaW5hdGVzKTtcXG5cXFxuZmxvYXQgZ2V0MkRZUG9zaXRpb25GcmFjdGlvbih2ZWMyIHRleHR1cmVDb29yZGluYXRlcyk7XFxuXFxcblxcblxcXG52ZWM0IGdldFBvc2l0aW9uM0RNb2RlKHZlYzMgcG9zaXRpb24sIGZsb2F0IGhlaWdodCwgdmVjMiB0ZXh0dXJlQ29vcmRpbmF0ZXMpXFxuXFxcbntcXG5cXFxuICAgIHJldHVybiB1X21vZGlmaWVkTW9kZWxWaWV3UHJvamVjdGlvbiAqIHZlYzQocG9zaXRpb24sIDEuMCk7XFxuXFxcbn1cXG5cXFxuXFxuXFxcbmZsb2F0IGdldDJETWVyY2F0b3JZUG9zaXRpb25GcmFjdGlvbih2ZWMyIHRleHR1cmVDb29yZGluYXRlcylcXG5cXFxue1xcblxcXG4gICAgLy8gVGhlIHdpZHRoIG9mIGEgdGlsZSBhdCBsZXZlbCAxMSwgaW4gcmFkaWFucyBhbmQgYXNzdW1pbmcgYSBzaW5nbGUgcm9vdCB0aWxlLCBpc1xcblxcXG4gICAgLy8gICAyLjAgKiBjem1fcGkgLyBwb3coMi4wLCAxMS4wKVxcblxcXG4gICAgLy8gV2Ugd2FudCB0byBqdXN0IGxpbmVhcmx5IGludGVycG9sYXRlIHRoZSAyRCBwb3NpdGlvbiBmcm9tIHRoZSB0ZXh0dXJlIGNvb3JkaW5hdGVzXFxuXFxcbiAgICAvLyB3aGVuIHdlJ3JlIGF0IHRoaXMgbGV2ZWwgb3IgaGlnaGVyLiAgVGhlIGNvbnN0YW50IGJlbG93IGlzIHRoZSBleHByZXNzaW9uXFxuXFxcbiAgICAvLyBhYm92ZSBldmFsdWF0ZWQgYW5kIHRoZW4gcm91bmRlZCB1cCBhdCB0aGUgNHRoIHNpZ25pZmljYW50IGRpZ2l0LlxcblxcXG4gICAgY29uc3QgZmxvYXQgbWF4VGlsZVdpZHRoID0gMC4wMDMwNjg7XFxuXFxcbiAgICBmbG9hdCBwb3NpdGlvbkZyYWN0aW9uID0gdGV4dHVyZUNvb3JkaW5hdGVzLnk7XFxuXFxcbiAgICBmbG9hdCBzb3V0aExhdGl0dWRlID0gdV9zb3V0aEFuZE5vcnRoTGF0aXR1ZGUueDtcXG5cXFxuICAgIGZsb2F0IG5vcnRoTGF0aXR1ZGUgPSB1X3NvdXRoQW5kTm9ydGhMYXRpdHVkZS55O1xcblxcXG4gICAgaWYgKG5vcnRoTGF0aXR1ZGUgLSBzb3V0aExhdGl0dWRlID4gbWF4VGlsZVdpZHRoKVxcblxcXG4gICAge1xcblxcXG4gICAgICAgIGZsb2F0IHNvdXRoTWVyY2F0b3JZID0gdV9zb3V0aE1lcmNhdG9yWUFuZE9uZU92ZXJIZWlnaHQueDtcXG5cXFxuICAgICAgICBmbG9hdCBvbmVPdmVyTWVyY2F0b3JIZWlnaHQgPSB1X3NvdXRoTWVyY2F0b3JZQW5kT25lT3ZlckhlaWdodC55O1xcblxcXG5cXG5cXFxuICAgICAgICBmbG9hdCBjdXJyZW50TGF0aXR1ZGUgPSBtaXgoc291dGhMYXRpdHVkZSwgbm9ydGhMYXRpdHVkZSwgdGV4dHVyZUNvb3JkaW5hdGVzLnkpO1xcblxcXG4gICAgICAgIGN1cnJlbnRMYXRpdHVkZSA9IGNsYW1wKGN1cnJlbnRMYXRpdHVkZSwgLWN6bV93ZWJNZXJjYXRvck1heExhdGl0dWRlLCBjem1fd2ViTWVyY2F0b3JNYXhMYXRpdHVkZSk7XFxuXFxcbiAgICAgICAgcG9zaXRpb25GcmFjdGlvbiA9IGN6bV9sYXRpdHVkZVRvV2ViTWVyY2F0b3JGcmFjdGlvbihjdXJyZW50TGF0aXR1ZGUsIHNvdXRoTWVyY2F0b3JZLCBvbmVPdmVyTWVyY2F0b3JIZWlnaHQpO1xcblxcXG4gICAgfVxcblxcXG4gICAgcmV0dXJuIHBvc2l0aW9uRnJhY3Rpb247XFxuXFxcbn1cXG5cXFxuXFxuXFxcbmZsb2F0IGdldDJER2VvZ3JhcGhpY1lQb3NpdGlvbkZyYWN0aW9uKHZlYzIgdGV4dHVyZUNvb3JkaW5hdGVzKVxcblxcXG57XFxuXFxcbiAgICByZXR1cm4gdGV4dHVyZUNvb3JkaW5hdGVzLnk7XFxuXFxcbn1cXG5cXFxuXFxuXFxcbnZlYzQgZ2V0UG9zaXRpb25QbGFuYXJFYXJ0aCh2ZWMzIHBvc2l0aW9uLCBmbG9hdCBoZWlnaHQsIHZlYzIgdGV4dHVyZUNvb3JkaW5hdGVzKVxcblxcXG57XFxuXFxcbiAgICBmbG9hdCB5UG9zaXRpb25GcmFjdGlvbiA9IGdldDJEWVBvc2l0aW9uRnJhY3Rpb24odGV4dHVyZUNvb3JkaW5hdGVzKTtcXG5cXFxuICAgIHZlYzQgcnRjUG9zaXRpb24yRCA9IHZlYzQoaGVpZ2h0LCBtaXgodV90aWxlUmVjdGFuZ2xlLnN0LCB1X3RpbGVSZWN0YW5nbGUucHEsIHZlYzIodGV4dHVyZUNvb3JkaW5hdGVzLngsIHlQb3NpdGlvbkZyYWN0aW9uKSksIDEuMCk7XFxuXFxcbiAgICByZXR1cm4gdV9tb2RpZmllZE1vZGVsVmlld1Byb2plY3Rpb24gKiBydGNQb3NpdGlvbjJEO1xcblxcXG59XFxuXFxcblxcblxcXG52ZWM0IGdldFBvc2l0aW9uMkRNb2RlKHZlYzMgcG9zaXRpb24sIGZsb2F0IGhlaWdodCwgdmVjMiB0ZXh0dXJlQ29vcmRpbmF0ZXMpXFxuXFxcbntcXG5cXFxuICAgIHJldHVybiBnZXRQb3NpdGlvblBsYW5hckVhcnRoKHBvc2l0aW9uLCAwLjAsIHRleHR1cmVDb29yZGluYXRlcyk7XFxuXFxcbn1cXG5cXFxuXFxuXFxcbnZlYzQgZ2V0UG9zaXRpb25Db2x1bWJ1c1ZpZXdNb2RlKHZlYzMgcG9zaXRpb24sIGZsb2F0IGhlaWdodCwgdmVjMiB0ZXh0dXJlQ29vcmRpbmF0ZXMpXFxuXFxcbntcXG5cXFxuICAgIHJldHVybiBnZXRQb3NpdGlvblBsYW5hckVhcnRoKHBvc2l0aW9uLCBoZWlnaHQsIHRleHR1cmVDb29yZGluYXRlcyk7XFxuXFxcbn1cXG5cXFxuXFxuXFxcbnZlYzQgZ2V0UG9zaXRpb25Nb3JwaGluZ01vZGUodmVjMyBwb3NpdGlvbiwgZmxvYXQgaGVpZ2h0LCB2ZWMyIHRleHR1cmVDb29yZGluYXRlcylcXG5cXFxue1xcblxcXG4gICAgLy8gV2UgZG8gbm90IGRvIFJUQyB3aGlsZSBtb3JwaGluZywgc28gdGhlcmUgaXMgcG90ZW50aWFsIGZvciBqaXR0ZXIuXFxuXFxcbiAgICAvLyBUaGlzIGlzIHVubGlrZWx5IHRvIGJlIG5vdGljZWFibGUsIHRob3VnaC5cXG5cXFxuICAgIHZlYzMgcG9zaXRpb24zRFdDID0gcG9zaXRpb24gKyB1X2NlbnRlcjNEO1xcblxcXG4gICAgZmxvYXQgeVBvc2l0aW9uRnJhY3Rpb24gPSBnZXQyRFlQb3NpdGlvbkZyYWN0aW9uKHRleHR1cmVDb29yZGluYXRlcyk7XFxuXFxcbiAgICB2ZWM0IHBvc2l0aW9uMkRXQyA9IHZlYzQoaGVpZ2h0LCBtaXgodV90aWxlUmVjdGFuZ2xlLnN0LCB1X3RpbGVSZWN0YW5nbGUucHEsIHZlYzIodGV4dHVyZUNvb3JkaW5hdGVzLngsIHlQb3NpdGlvbkZyYWN0aW9uKSksIDEuMCk7XFxuXFxcbiAgICB2ZWM0IG1vcnBoUG9zaXRpb24gPSBjem1fY29sdW1idXNWaWV3TW9ycGgocG9zaXRpb24yRFdDLCB2ZWM0KHBvc2l0aW9uM0RXQywgMS4wKSwgY3ptX21vcnBoVGltZSk7XFxuXFxcbiAgICByZXR1cm4gY3ptX21vZGVsVmlld1Byb2plY3Rpb24gKiBtb3JwaFBvc2l0aW9uO1xcblxcXG59XFxuXFxcblxcblxcXG4jaWZkZWYgUVVBTlRJWkFUSU9OX0JJVFMxMlxcblxcXG51bmlmb3JtIHZlYzIgdV9taW5NYXhIZWlnaHQ7XFxuXFxcbnVuaWZvcm0gbWF0NCB1X3NjYWxlQW5kQmlhcztcXG5cXFxuI2VuZGlmXFxuXFxcblxcblxcXG52b2lkIG1haW4oKVxcblxcXG57XFxuXFxcbiNpZmRlZiBRVUFOVElaQVRJT05fQklUUzEyXFxuXFxcbiAgICB2ZWMyIHh5ID0gY3ptX2RlY29tcHJlc3NUZXh0dXJlQ29vcmRpbmF0ZXMoY29tcHJlc3NlZDAueCk7XFxuXFxcbiAgICB2ZWMyIHpoID0gY3ptX2RlY29tcHJlc3NUZXh0dXJlQ29vcmRpbmF0ZXMoY29tcHJlc3NlZDAueSk7XFxuXFxcbiAgICB2ZWMzIHBvc2l0aW9uID0gdmVjMyh4eSwgemgueCk7XFxuXFxcbiAgICBmbG9hdCBoZWlnaHQgPSB6aC55O1xcblxcXG4gICAgdmVjMiB0ZXh0dXJlQ29vcmRpbmF0ZXMgPSBjem1fZGVjb21wcmVzc1RleHR1cmVDb29yZGluYXRlcyhjb21wcmVzc2VkMC56KTtcXG5cXFxuXFxuXFxcbiAgICBoZWlnaHQgPSBoZWlnaHQgKiAodV9taW5NYXhIZWlnaHQueSAtIHVfbWluTWF4SGVpZ2h0LngpICsgdV9taW5NYXhIZWlnaHQueDtcXG5cXFxuICAgIHBvc2l0aW9uID0gKHVfc2NhbGVBbmRCaWFzICogdmVjNChwb3NpdGlvbiwgMS4wKSkueHl6O1xcblxcXG5cXG5cXFxuI2lmIChkZWZpbmVkKEVOQUJMRV9WRVJURVhfTElHSFRJTkcpIHx8IGRlZmluZWQoR0VORVJBVEVfUE9TSVRJT05fQU5EX05PUk1BTCkpICYmIGRlZmluZWQoSU5DTFVERV9XRUJfTUVSQ0FUT1JfWSlcXG5cXFxuICAgIGZsb2F0IHdlYk1lcmNhdG9yVCA9IGN6bV9kZWNvbXByZXNzVGV4dHVyZUNvb3JkaW5hdGVzKGNvbXByZXNzZWQwLncpLng7XFxuXFxcbiAgICBmbG9hdCBlbmNvZGVkTm9ybWFsID0gY29tcHJlc3NlZDE7XFxuXFxcbiNlbGlmIGRlZmluZWQoSU5DTFVERV9XRUJfTUVSQ0FUT1JfWSlcXG5cXFxuICAgIGZsb2F0IHdlYk1lcmNhdG9yVCA9IGN6bV9kZWNvbXByZXNzVGV4dHVyZUNvb3JkaW5hdGVzKGNvbXByZXNzZWQwLncpLng7XFxuXFxcbiAgICBmbG9hdCBlbmNvZGVkTm9ybWFsID0gMC4wO1xcblxcXG4jZWxpZiBkZWZpbmVkKEVOQUJMRV9WRVJURVhfTElHSFRJTkcpIHx8IGRlZmluZWQoR0VORVJBVEVfUE9TSVRJT05fQU5EX05PUk1BTClcXG5cXFxuICAgIGZsb2F0IHdlYk1lcmNhdG9yVCA9IHRleHR1cmVDb29yZGluYXRlcy55O1xcblxcXG4gICAgZmxvYXQgZW5jb2RlZE5vcm1hbCA9IGNvbXByZXNzZWQwLnc7XFxuXFxcbiNlbHNlXFxuXFxcbiAgICBmbG9hdCB3ZWJNZXJjYXRvclQgPSB0ZXh0dXJlQ29vcmRpbmF0ZXMueTtcXG5cXFxuICAgIGZsb2F0IGVuY29kZWROb3JtYWwgPSAwLjA7XFxuXFxcbiNlbmRpZlxcblxcXG5cXG5cXFxuI2Vsc2VcXG5cXFxuICAgIC8vIEEgc2luZ2xlIGZsb2F0IHBlciBlbGVtZW50XFxuXFxcbiAgICB2ZWMzIHBvc2l0aW9uID0gcG9zaXRpb24zREFuZEhlaWdodC54eXo7XFxuXFxcbiAgICBmbG9hdCBoZWlnaHQgPSBwb3NpdGlvbjNEQW5kSGVpZ2h0Lnc7XFxuXFxcbiAgICB2ZWMyIHRleHR1cmVDb29yZGluYXRlcyA9IHRleHR1cmVDb29yZEFuZEVuY29kZWROb3JtYWxzLnh5O1xcblxcXG5cXG5cXFxuI2lmIChkZWZpbmVkKEVOQUJMRV9WRVJURVhfTElHSFRJTkcpIHx8IGRlZmluZWQoR0VORVJBVEVfUE9TSVRJT05fQU5EX05PUk1BTCkgfHwgZGVmaW5lZChBUFBMWV9NQVRFUklBTCkpICYmIGRlZmluZWQoSU5DTFVERV9XRUJfTUVSQ0FUT1JfWSlcXG5cXFxuICAgIGZsb2F0IHdlYk1lcmNhdG9yVCA9IHRleHR1cmVDb29yZEFuZEVuY29kZWROb3JtYWxzLno7XFxuXFxcbiAgICBmbG9hdCBlbmNvZGVkTm9ybWFsID0gdGV4dHVyZUNvb3JkQW5kRW5jb2RlZE5vcm1hbHMudztcXG5cXFxuI2VsaWYgZGVmaW5lZChFTkFCTEVfVkVSVEVYX0xJR0hUSU5HKSB8fCBkZWZpbmVkKEdFTkVSQVRFX1BPU0lUSU9OX0FORF9OT1JNQUwpIHx8IGRlZmluZWQoQVBQTFlfTUFURVJJQUwpXFxuXFxcbiAgICBmbG9hdCB3ZWJNZXJjYXRvclQgPSB0ZXh0dXJlQ29vcmRpbmF0ZXMueTtcXG5cXFxuICAgIGZsb2F0IGVuY29kZWROb3JtYWwgPSB0ZXh0dXJlQ29vcmRBbmRFbmNvZGVkTm9ybWFscy56O1xcblxcXG4jZWxpZiBkZWZpbmVkKElOQ0xVREVfV0VCX01FUkNBVE9SX1kpXFxuXFxcbiAgICBmbG9hdCB3ZWJNZXJjYXRvclQgPSB0ZXh0dXJlQ29vcmRBbmRFbmNvZGVkTm9ybWFscy56O1xcblxcXG4gICAgZmxvYXQgZW5jb2RlZE5vcm1hbCA9IDAuMDtcXG5cXFxuI2Vsc2VcXG5cXFxuICAgIGZsb2F0IHdlYk1lcmNhdG9yVCA9IHRleHR1cmVDb29yZGluYXRlcy55O1xcblxcXG4gICAgZmxvYXQgZW5jb2RlZE5vcm1hbCA9IDAuMDtcXG5cXFxuI2VuZGlmXFxuXFxcblxcblxcXG4jZW5kaWZcXG5cXFxuXFxuXFxcbiAgICB2ZWMzIHBvc2l0aW9uM0RXQyA9IHBvc2l0aW9uICsgdV9jZW50ZXIzRDtcXG5cXFxuXFxuXFxcbiNpZmRlZiBHRU9ERVRJQ19TVVJGQUNFX05PUk1BTFNcXG5cXFxuICAgIHZlYzMgZWxsaXBzb2lkTm9ybWFsID0gZ2VvZGV0aWNTdXJmYWNlTm9ybWFsO1xcblxcXG4jZWxzZVxcblxcXG4gICAgdmVjMyBlbGxpcHNvaWROb3JtYWwgPSBub3JtYWxpemUocG9zaXRpb24zRFdDKTtcXG5cXFxuI2VuZGlmXFxuXFxcblxcblxcXG4jaWYgZGVmaW5lZChFWEFHR0VSQVRJT04pICYmIGRlZmluZWQoR0VPREVUSUNfU1VSRkFDRV9OT1JNQUxTKVxcblxcXG4gICAgZmxvYXQgZXhhZ2dlcmF0aW9uID0gdV90ZXJyYWluRXhhZ2dlcmF0aW9uQW5kUmVsYXRpdmVIZWlnaHQueDtcXG5cXFxuICAgIGZsb2F0IHJlbGF0aXZlSGVpZ2h0ID0gdV90ZXJyYWluRXhhZ2dlcmF0aW9uQW5kUmVsYXRpdmVIZWlnaHQueTtcXG5cXFxuICAgIGZsb2F0IG5ld0hlaWdodCA9IChoZWlnaHQgLSByZWxhdGl2ZUhlaWdodCkgKiBleGFnZ2VyYXRpb24gKyByZWxhdGl2ZUhlaWdodDtcXG5cXFxuXFxuXFxcbiAgICAvLyBzdG9wIGZyb20gZ29pbmcgdGhyb3VnaCBjZW50ZXIgb2YgZWFydGhcXG5cXFxuICAgIGZsb2F0IG1pblJhZGl1cyA9IG1pbihtaW4oY3ptX2VsbGlwc29pZFJhZGlpLngsIGN6bV9lbGxpcHNvaWRSYWRpaS55KSwgY3ptX2VsbGlwc29pZFJhZGlpLnopO1xcblxcXG4gICAgbmV3SGVpZ2h0ID0gbWF4KG5ld0hlaWdodCwgLW1pblJhZGl1cyk7XFxuXFxcblxcblxcXG4gICAgdmVjMyBvZmZzZXQgPSBlbGxpcHNvaWROb3JtYWwgKiAobmV3SGVpZ2h0IC0gaGVpZ2h0KTtcXG5cXFxuICAgIHBvc2l0aW9uICs9IG9mZnNldDtcXG5cXFxuICAgIHBvc2l0aW9uM0RXQyArPSBvZmZzZXQ7XFxuXFxcbiAgICBoZWlnaHQgPSBuZXdIZWlnaHQ7XFxuXFxcbiNlbmRpZlxcblxcXG5cXG5cXFxuICAgIGdsX1Bvc2l0aW9uID0gZ2V0UG9zaXRpb24ocG9zaXRpb24sIGhlaWdodCwgdGV4dHVyZUNvb3JkaW5hdGVzKTtcXG5cXFxuXFxuXFxcbiAgICB2X3RleHR1cmVDb29yZGluYXRlcyA9IHZlYzModGV4dHVyZUNvb3JkaW5hdGVzLCB3ZWJNZXJjYXRvclQpO1xcblxcXG5cXG5cXFxuI2lmIGRlZmluZWQoRU5BQkxFX1ZFUlRFWF9MSUdIVElORykgfHwgZGVmaW5lZChHRU5FUkFURV9QT1NJVElPTl9BTkRfTk9STUFMKSB8fCBkZWZpbmVkKEFQUExZX01BVEVSSUFMKVxcblxcXG4gICAgdl9wb3NpdGlvbkVDID0gKHVfbW9kaWZpZWRNb2RlbFZpZXcgKiB2ZWM0KHBvc2l0aW9uLCAxLjApKS54eXo7XFxuXFxcbiAgICB2X3Bvc2l0aW9uTUMgPSBwb3NpdGlvbjNEV0M7ICAvLyBwb3NpdGlvbiBpbiBtb2RlbCBjb29yZGluYXRlc1xcblxcXG4gICAgdmVjMyBub3JtYWxNQyA9IGN6bV9vY3REZWNvZGUoZW5jb2RlZE5vcm1hbCk7XFxuXFxcblxcblxcXG4jaWYgZGVmaW5lZChFWEFHR0VSQVRJT04pICYmIGRlZmluZWQoR0VPREVUSUNfU1VSRkFDRV9OT1JNQUxTKVxcblxcXG4gICAgdmVjMyBwcm9qZWN0aW9uID0gZG90KG5vcm1hbE1DLCBlbGxpcHNvaWROb3JtYWwpICogZWxsaXBzb2lkTm9ybWFsO1xcblxcXG4gICAgdmVjMyByZWplY3Rpb24gPSBub3JtYWxNQyAtIHByb2plY3Rpb247XFxuXFxcbiAgICBub3JtYWxNQyA9IG5vcm1hbGl6ZShwcm9qZWN0aW9uICsgcmVqZWN0aW9uICogZXhhZ2dlcmF0aW9uKTtcXG5cXFxuI2VuZGlmXFxuXFxcblxcblxcXG4gICAgdl9ub3JtYWxNQyA9IG5vcm1hbE1DO1xcblxcXG4gICAgdl9ub3JtYWxFQyA9IGN6bV9ub3JtYWwzRCAqIHZfbm9ybWFsTUM7XFxuXFxcbiNlbGlmIGRlZmluZWQoU0hPV19SRUZMRUNUSVZFX09DRUFOKSB8fCBkZWZpbmVkKEVOQUJMRV9EQVlOSUdIVF9TSEFESU5HKSB8fCBkZWZpbmVkKEdFTkVSQVRFX1BPU0lUSU9OKSB8fCBkZWZpbmVkKEhEUilcXG5cXFxuICAgIHZfcG9zaXRpb25FQyA9ICh1X21vZGlmaWVkTW9kZWxWaWV3ICogdmVjNChwb3NpdGlvbiwgMS4wKSkueHl6O1xcblxcXG4gICAgdl9wb3NpdGlvbk1DID0gcG9zaXRpb24zRFdDOyAgLy8gcG9zaXRpb24gaW4gbW9kZWwgY29vcmRpbmF0ZXNcXG5cXFxuI2VuZGlmXFxuXFxcblxcblxcXG4jaWYgZGVmaW5lZChGT0cpIHx8IGRlZmluZWQoR1JPVU5EX0FUTU9TUEhFUkUpXFxuXFxcbiAgICBBdG1vc3BoZXJlQ29sb3IgYXRtb3NGb2dDb2xvciA9IGNvbXB1dGVHcm91bmRBdG1vc3BoZXJlRnJvbVNwYWNlKHBvc2l0aW9uM0RXQywgZmFsc2UsIHZlYzMoMC4wKSk7XFxuXFxcbiAgICB2X2ZvZ01pZUNvbG9yID0gYXRtb3NGb2dDb2xvci5taWU7XFxuXFxcbiAgICB2X2ZvZ1JheWxlaWdoQ29sb3IgPSBhdG1vc0ZvZ0NvbG9yLnJheWxlaWdoO1xcblxcXG4jZW5kaWZcXG5cXFxuXFxuXFxcbiNpZiBkZWZpbmVkKEZPRykgfHwgZGVmaW5lZChHUk9VTkRfQVRNT1NQSEVSRSkgfHwgZGVmaW5lZChVTkRFUkdST1VORF9DT0xPUikgfHwgZGVmaW5lZChUUkFOU0xVQ0VOVClcXG5cXFxuICAgIHZfZGlzdGFuY2UgPSBsZW5ndGgoKGN6bV9tb2RlbFZpZXczRCAqIHZlYzQocG9zaXRpb24zRFdDLCAxLjApKS54eXopO1xcblxcXG4jZW5kaWZcXG5cXFxuXFxuXFxcbiNpZmRlZiBBUFBMWV9NQVRFUklBTFxcblxcXG4gICAgZmxvYXQgbm9ydGhQb2xlWiA9IGN6bV9lbGxpcHNvaWRSYWRpaS56O1xcblxcXG4gICAgdmVjMyBub3J0aFBvbGVQb3NpdGlvbk1DID0gdmVjMygwLjAsIDAuMCwgbm9ydGhQb2xlWik7XFxuXFxcbiAgICB2ZWMzIHZlY3RvckVhc3RNQyA9IG5vcm1hbGl6ZShjcm9zcyhub3J0aFBvbGVQb3NpdGlvbk1DIC0gdl9wb3NpdGlvbk1DLCBlbGxpcHNvaWROb3JtYWwpKTtcXG5cXFxuICAgIGZsb2F0IGRvdFByb2QgPSBhYnMoZG90KGVsbGlwc29pZE5vcm1hbCwgdl9ub3JtYWxNQykpO1xcblxcXG4gICAgdl9zbG9wZSA9IGFjb3MoZG90UHJvZCk7XFxuXFxcbiAgICB2ZWMzIG5vcm1hbFJlamVjdGVkID0gZWxsaXBzb2lkTm9ybWFsICogZG90UHJvZDtcXG5cXFxuICAgIHZlYzMgbm9ybWFsUHJvamVjdGVkID0gdl9ub3JtYWxNQyAtIG5vcm1hbFJlamVjdGVkO1xcblxcXG4gICAgdmVjMyBhc3BlY3RWZWN0b3IgPSBub3JtYWxpemUobm9ybWFsUHJvamVjdGVkKTtcXG5cXFxuICAgIHZfYXNwZWN0ID0gYWNvcyhkb3QoYXNwZWN0VmVjdG9yLCB2ZWN0b3JFYXN0TUMpKTtcXG5cXFxuICAgIGZsb2F0IGRldGVybSA9IGRvdChjcm9zcyh2ZWN0b3JFYXN0TUMsIGFzcGVjdFZlY3RvciksIGVsbGlwc29pZE5vcm1hbCk7XFxuXFxcbiAgICB2X2FzcGVjdCA9IGN6bV9icmFuY2hGcmVlVGVybmFyeShkZXRlcm0gPCAwLjAsIDIuMCAqIGN6bV9waSAtIHZfYXNwZWN0LCB2X2FzcGVjdCk7XFxuXFxcbiAgICB2X2hlaWdodCA9IGhlaWdodDtcXG5cXFxuI2VuZGlmXFxuXFxcbn1cXG5cXFxuXCI7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///15314\n')},62868:function(__unused_webpack___webpack_module__,__webpack_exports__){eval('//This file is automatically rebuilt by the Cesium build process.\n/* harmony default export */ __webpack_exports__["Z"] = ("/*!\\n\\\n * Atmosphere code:\\n\\\n *\\n\\\n * Copyright (c) 2000-2005, Sean O\'Neil (s_p_oneil@hotmail.com)\\n\\\n * All rights reserved.\\n\\\n *\\n\\\n * Redistribution and use in source and binary forms, with or without\\n\\\n * modification, are permitted provided that the following conditions\\n\\\n * are met:\\n\\\n *\\n\\\n * * Redistributions of source code must retain the above copyright notice,\\n\\\n *   this list of conditions and the following disclaimer.\\n\\\n * * Redistributions in binary form must reproduce the above copyright notice,\\n\\\n *   this list of conditions and the following disclaimer in the documentation\\n\\\n *   and/or other materials provided with the distribution.\\n\\\n * * Neither the name of the project nor the names of its contributors may be\\n\\\n *   used to endorse or promote products derived from this software without\\n\\\n *   specific prior written permission.\\n\\\n *\\n\\\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \\"AS IS\\"\\n\\\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\\n\\\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\\n\\\n * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE\\n\\\n * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\\n\\\n * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\\n\\\n * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER\\n\\\n * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\\n\\\n * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\\n\\\n * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\\n\\\n *\\n\\\n * Modifications made by Analytical Graphics, Inc.\\n\\\n */\\n\\\n\\n\\\n // Atmosphere:\\n\\\n //   Code:  http://sponeil.net/\\n\\\n //   GPU Gems 2 Article:  https://developer.nvidia.com/gpugems/GPUGems2/gpugems2_chapter16.html\\n\\\n\\n\\\nconst float Kr = 0.0025;\\n\\\nconst float Km = 0.0015;\\n\\\nconst float ESun = 15.0;\\n\\\n\\n\\\nconst float fKrESun = Kr * ESun;\\n\\\nconst float fKmESun = Km * ESun;\\n\\\nconst float fKr4PI = Kr * 4.0 * czm_pi;\\n\\\nconst float fKm4PI = Km * 4.0 * czm_pi;\\n\\\n\\n\\\n// Original: vec3(1.0 / pow(0.650, 4.0), 1.0 / pow(0.570, 4.0), 1.0 / pow(0.475, 4.0));\\n\\\nconst vec3 v3InvWavelength = vec3(5.60204474633241, 9.473284437923038, 19.64380261047721);\\n\\\n\\n\\\nconst float fScaleDepth = 0.25;\\n\\\n\\n\\\nstruct AtmosphereColor\\n\\\n{\\n\\\n    vec3 mie;\\n\\\n    vec3 rayleigh;\\n\\\n};\\n\\\n\\n\\\nconst int nSamples = 2;\\n\\\nconst float fSamples = 2.0;\\n\\\n\\n\\\nfloat scale(float fCos)\\n\\\n{\\n\\\n    float x = 1.0 - fCos;\\n\\\n    return fScaleDepth * exp(-0.00287 + x*(0.459 + x*(3.83 + x*(-6.80 + x*5.25))));\\n\\\n}\\n\\\n\\n\\\nAtmosphereColor computeGroundAtmosphereFromSpace(vec3 v3Pos, bool dynamicLighting, vec3 lightDirectionWC)\\n\\\n{\\n\\\n    float fInnerRadius = czm_ellipsoidRadii.x;\\n\\\n    float fOuterRadius = czm_ellipsoidRadii.x * 1.025;\\n\\\n    float fOuterRadius2 = fOuterRadius * fOuterRadius;\\n\\\n\\n\\\n    float fScale = 1.0 / (fOuterRadius - fInnerRadius);\\n\\\n    float fScaleOverScaleDepth = fScale / fScaleDepth;\\n\\\n\\n\\\n    // Get the ray from the camera to the vertex and its length (which is the far point of the ray passing through the atmosphere)\\n\\\n    vec3 v3Ray = v3Pos - czm_viewerPositionWC;\\n\\\n    float fFar = length(v3Ray);\\n\\\n    v3Ray /= fFar;\\n\\\n\\n\\\n    float fCameraHeight = length(czm_viewerPositionWC);\\n\\\n    float fCameraHeight2 = fCameraHeight * fCameraHeight;\\n\\\n\\n\\\n    // This next line is an ANGLE workaround. It is equivalent to B = 2.0 * dot(czm_viewerPositionWC, v3Ray),\\n\\\n    // which is what it should be, but there are problems at the poles.\\n\\\n    float B = 2.0 * length(czm_viewerPositionWC) * dot(normalize(czm_viewerPositionWC), v3Ray);\\n\\\n    float C = fCameraHeight2 - fOuterRadius2;\\n\\\n    float fDet = max(0.0, B*B - 4.0 * C);\\n\\\n    float fNear = 0.5 * (-B - sqrt(fDet));\\n\\\n\\n\\\n    // Calculate the ray\'s starting position, then calculate its scattering offset\\n\\\n    vec3 v3Start = czm_viewerPositionWC + v3Ray * fNear;\\n\\\n    fFar -= fNear;\\n\\\n    float fDepth = exp((fInnerRadius - fOuterRadius) / fScaleDepth);\\n\\\n\\n\\\n    // The light angle based on the scene\'s light source would be:\\n\\\n    //    dot(lightDirectionWC, v3Pos) / length(v3Pos);\\n\\\n    // When we want the atmosphere to be uniform over the globe so it is set to 1.0.\\n\\\n\\n\\\n    float fLightAngle = czm_branchFreeTernary(dynamicLighting, dot(lightDirectionWC, v3Pos) / length(v3Pos), 1.0);\\n\\\n    float fCameraAngle = dot(-v3Ray, v3Pos) / length(v3Pos);\\n\\\n    float fCameraScale = scale(fCameraAngle);\\n\\\n    float fLightScale = scale(fLightAngle);\\n\\\n    float fCameraOffset = fDepth*fCameraScale;\\n\\\n    float fTemp = (fLightScale + fCameraScale);\\n\\\n\\n\\\n    // Initialize the scattering loop variables\\n\\\n    float fSampleLength = fFar / fSamples;\\n\\\n    float fScaledLength = fSampleLength * fScale;\\n\\\n    vec3 v3SampleRay = v3Ray * fSampleLength;\\n\\\n    vec3 v3SamplePoint = v3Start + v3SampleRay * 0.5;\\n\\\n\\n\\\n    // Now loop through the sample rays\\n\\\n    vec3 v3FrontColor = vec3(0.0);\\n\\\n    vec3 v3Attenuate = vec3(0.0);\\n\\\n    for(int i=0; i<nSamples; i++)\\n\\\n    {\\n\\\n        float fHeight = length(v3SamplePoint);\\n\\\n        float fDepth = exp(fScaleOverScaleDepth * (fInnerRadius - fHeight));\\n\\\n        float fScatter = fDepth*fTemp - fCameraOffset;\\n\\\n        v3Attenuate = exp(-fScatter * (v3InvWavelength * fKr4PI + fKm4PI));\\n\\\n        v3FrontColor += v3Attenuate * (fDepth * fScaledLength);\\n\\\n        v3SamplePoint += v3SampleRay;\\n\\\n    }\\n\\\n\\n\\\n    AtmosphereColor color;\\n\\\n    color.mie = v3FrontColor * (v3InvWavelength * fKrESun + fKmESun);\\n\\\n    color.rayleigh = v3Attenuate; // Calculate the attenuation factor for the ground\\n\\\n\\n\\\n    return color;\\n\\\n}\\n\\\n\\n\\\n");\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNjI4NjguanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQSx5REFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsK0JBQStCO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEIsd0JBQXdCO0FBQ3hCLHdCQUF3QjtBQUN4QjtBQUNBLGdDQUFnQztBQUNoQyxnQ0FBZ0M7QUFDaEMsdUNBQXVDO0FBQ3ZDLHVDQUF1QztBQUN2QztBQUNBLHVGQUF1RjtBQUN2RiwwRkFBMEY7QUFDMUY7QUFDQSwrQkFBK0I7QUFDL0I7QUFDQTtBQUNBLENBQUM7QUFDRCxhQUFhO0FBQ2Isa0JBQWtCO0FBQ2xCLEVBQUU7QUFDRjtBQUNBLHVCQUF1QjtBQUN2QiwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBLENBQUM7QUFDRCx5QkFBeUI7QUFDekIsbUZBQW1GO0FBQ25GLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNELDhDQUE4QztBQUM5QyxzREFBc0Q7QUFDdEQsc0RBQXNEO0FBQ3REO0FBQ0EsdURBQXVEO0FBQ3ZELHNEQUFzRDtBQUN0RDtBQUNBO0FBQ0EsOENBQThDO0FBQzlDLCtCQUErQjtBQUMvQixrQkFBa0I7QUFDbEI7QUFDQSx1REFBdUQ7QUFDdkQseURBQXlEO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBLCtGQUErRjtBQUMvRiw2Q0FBNkM7QUFDN0MseUNBQXlDO0FBQ3pDLDBDQUEwQztBQUMxQztBQUNBO0FBQ0Esd0RBQXdEO0FBQ3hELGtCQUFrQjtBQUNsQixvRUFBb0U7QUFDcEU7QUFDQTtBQUNBLHVEQUF1RDtBQUN2RDtBQUNBO0FBQ0Esa0hBQWtIO0FBQ2xILDREQUE0RDtBQUM1RCw2Q0FBNkM7QUFDN0MsMkNBQTJDO0FBQzNDLDhDQUE4QztBQUM5QywrQ0FBK0M7QUFDL0M7QUFDQTtBQUNBLDBDQUEwQztBQUMxQyxpREFBaUQ7QUFDakQsNkNBQTZDO0FBQzdDLHFEQUFxRDtBQUNyRDtBQUNBO0FBQ0Esa0NBQWtDO0FBQ2xDLGlDQUFpQztBQUNqQyxpQkFBaUIsWUFBWTtBQUM3QixLQUFLO0FBQ0wsOENBQThDO0FBQzlDLDRFQUE0RTtBQUM1RSxzREFBc0Q7QUFDdEQsMkVBQTJFO0FBQzNFLCtEQUErRDtBQUMvRCxxQ0FBcUM7QUFDckMsS0FBSztBQUNMO0FBQ0EsMEJBQTBCO0FBQzFCLHFFQUFxRTtBQUNyRSxrQ0FBa0M7QUFDbEM7QUFDQSxpQkFBaUI7QUFDakIsQ0FBQztBQUNEO0FBQ0EsQ0FBQyxFQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdnVlMy13ZWJwYWNrNS8uL25vZGVfbW9kdWxlcy9jZXNpdW0vU291cmNlL1NoYWRlcnMvR3JvdW5kQXRtb3NwaGVyZS5qcz8wODlhIl0sInNvdXJjZXNDb250ZW50IjpbIi8vVGhpcyBmaWxlIGlzIGF1dG9tYXRpY2FsbHkgcmVidWlsdCBieSB0aGUgQ2VzaXVtIGJ1aWxkIHByb2Nlc3MuXG5leHBvcnQgZGVmYXVsdCBcIi8qIVxcblxcXG4gKiBBdG1vc3BoZXJlIGNvZGU6XFxuXFxcbiAqXFxuXFxcbiAqIENvcHlyaWdodCAoYykgMjAwMC0yMDA1LCBTZWFuIE8nTmVpbCAoc19wX29uZWlsQGhvdG1haWwuY29tKVxcblxcXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxcblxcXG4gKlxcblxcXG4gKiBSZWRpc3RyaWJ1dGlvbiBhbmQgdXNlIGluIHNvdXJjZSBhbmQgYmluYXJ5IGZvcm1zLCB3aXRoIG9yIHdpdGhvdXRcXG5cXFxuICogbW9kaWZpY2F0aW9uLCBhcmUgcGVybWl0dGVkIHByb3ZpZGVkIHRoYXQgdGhlIGZvbGxvd2luZyBjb25kaXRpb25zXFxuXFxcbiAqIGFyZSBtZXQ6XFxuXFxcbiAqXFxuXFxcbiAqICogUmVkaXN0cmlidXRpb25zIG9mIHNvdXJjZSBjb2RlIG11c3QgcmV0YWluIHRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlLFxcblxcXG4gKiAgIHRoaXMgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nIGRpc2NsYWltZXIuXFxuXFxcbiAqICogUmVkaXN0cmlidXRpb25zIGluIGJpbmFyeSBmb3JtIG11c3QgcmVwcm9kdWNlIHRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlLFxcblxcXG4gKiAgIHRoaXMgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nIGRpc2NsYWltZXIgaW4gdGhlIGRvY3VtZW50YXRpb25cXG5cXFxuICogICBhbmQvb3Igb3RoZXIgbWF0ZXJpYWxzIHByb3ZpZGVkIHdpdGggdGhlIGRpc3RyaWJ1dGlvbi5cXG5cXFxuICogKiBOZWl0aGVyIHRoZSBuYW1lIG9mIHRoZSBwcm9qZWN0IG5vciB0aGUgbmFtZXMgb2YgaXRzIGNvbnRyaWJ1dG9ycyBtYXkgYmVcXG5cXFxuICogICB1c2VkIHRvIGVuZG9yc2Ugb3IgcHJvbW90ZSBwcm9kdWN0cyBkZXJpdmVkIGZyb20gdGhpcyBzb2Z0d2FyZSB3aXRob3V0XFxuXFxcbiAqICAgc3BlY2lmaWMgcHJpb3Igd3JpdHRlbiBwZXJtaXNzaW9uLlxcblxcXG4gKlxcblxcXG4gKiBUSElTIFNPRlRXQVJFIElTIFBST1ZJREVEIEJZIFRIRSBDT1BZUklHSFQgSE9MREVSUyBBTkQgQ09OVFJJQlVUT1JTIFxcXCJBUyBJU1xcXCJcXG5cXFxuICogQU5EIEFOWSBFWFBSRVNTIE9SIElNUExJRUQgV0FSUkFOVElFUywgSU5DTFVESU5HLCBCVVQgTk9UIExJTUlURUQgVE8sIFRIRVxcblxcXG4gKiBJTVBMSUVEIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZIEFORCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBUkVcXG5cXFxuICogRElTQ0xBSU1FRC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIENPUFlSSUdIVCBPV05FUiBPUiBDT05UUklCVVRPUlMgQkUgTElBQkxFXFxuXFxcbiAqIEZPUiBBTlkgRElSRUNULCBJTkRJUkVDVCwgSU5DSURFTlRBTCwgU1BFQ0lBTCwgRVhFTVBMQVJZLCBPUiBDT05TRVFVRU5USUFMXFxuXFxcbiAqIERBTUFHRVMgKElOQ0xVRElORywgQlVUIE5PVCBMSU1JVEVEIFRPLCBQUk9DVVJFTUVOVCBPRiBTVUJTVElUVVRFIEdPT0RTIE9SXFxuXFxcbiAqIFNFUlZJQ0VTOyBMT1NTIE9GIFVTRSwgREFUQSwgT1IgUFJPRklUUzsgT1IgQlVTSU5FU1MgSU5URVJSVVBUSU9OKSBIT1dFVkVSXFxuXFxcbiAqIENBVVNFRCBBTkQgT04gQU5ZIFRIRU9SWSBPRiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQ09OVFJBQ1QsIFNUUklDVCBMSUFCSUxJVFksXFxuXFxcbiAqIE9SIFRPUlQgKElOQ0xVRElORyBORUdMSUdFTkNFIE9SIE9USEVSV0lTRSkgQVJJU0lORyBJTiBBTlkgV0FZIE9VVCBPRiBUSEUgVVNFXFxuXFxcbiAqIE9GIFRISVMgU09GVFdBUkUsIEVWRU4gSUYgQURWSVNFRCBPRiBUSEUgUE9TU0lCSUxJVFkgT0YgU1VDSCBEQU1BR0UuXFxuXFxcbiAqXFxuXFxcbiAqIE1vZGlmaWNhdGlvbnMgbWFkZSBieSBBbmFseXRpY2FsIEdyYXBoaWNzLCBJbmMuXFxuXFxcbiAqL1xcblxcXG5cXG5cXFxuIC8vIEF0bW9zcGhlcmU6XFxuXFxcbiAvLyAgIENvZGU6ICBodHRwOi8vc3BvbmVpbC5uZXQvXFxuXFxcbiAvLyAgIEdQVSBHZW1zIDIgQXJ0aWNsZTogIGh0dHBzOi8vZGV2ZWxvcGVyLm52aWRpYS5jb20vZ3B1Z2Vtcy9HUFVHZW1zMi9ncHVnZW1zMl9jaGFwdGVyMTYuaHRtbFxcblxcXG5cXG5cXFxuY29uc3QgZmxvYXQgS3IgPSAwLjAwMjU7XFxuXFxcbmNvbnN0IGZsb2F0IEttID0gMC4wMDE1O1xcblxcXG5jb25zdCBmbG9hdCBFU3VuID0gMTUuMDtcXG5cXFxuXFxuXFxcbmNvbnN0IGZsb2F0IGZLckVTdW4gPSBLciAqIEVTdW47XFxuXFxcbmNvbnN0IGZsb2F0IGZLbUVTdW4gPSBLbSAqIEVTdW47XFxuXFxcbmNvbnN0IGZsb2F0IGZLcjRQSSA9IEtyICogNC4wICogY3ptX3BpO1xcblxcXG5jb25zdCBmbG9hdCBmS200UEkgPSBLbSAqIDQuMCAqIGN6bV9waTtcXG5cXFxuXFxuXFxcbi8vIE9yaWdpbmFsOiB2ZWMzKDEuMCAvIHBvdygwLjY1MCwgNC4wKSwgMS4wIC8gcG93KDAuNTcwLCA0LjApLCAxLjAgLyBwb3coMC40NzUsIDQuMCkpO1xcblxcXG5jb25zdCB2ZWMzIHYzSW52V2F2ZWxlbmd0aCA9IHZlYzMoNS42MDIwNDQ3NDYzMzI0MSwgOS40NzMyODQ0Mzc5MjMwMzgsIDE5LjY0MzgwMjYxMDQ3NzIxKTtcXG5cXFxuXFxuXFxcbmNvbnN0IGZsb2F0IGZTY2FsZURlcHRoID0gMC4yNTtcXG5cXFxuXFxuXFxcbnN0cnVjdCBBdG1vc3BoZXJlQ29sb3JcXG5cXFxue1xcblxcXG4gICAgdmVjMyBtaWU7XFxuXFxcbiAgICB2ZWMzIHJheWxlaWdoO1xcblxcXG59O1xcblxcXG5cXG5cXFxuY29uc3QgaW50IG5TYW1wbGVzID0gMjtcXG5cXFxuY29uc3QgZmxvYXQgZlNhbXBsZXMgPSAyLjA7XFxuXFxcblxcblxcXG5mbG9hdCBzY2FsZShmbG9hdCBmQ29zKVxcblxcXG57XFxuXFxcbiAgICBmbG9hdCB4ID0gMS4wIC0gZkNvcztcXG5cXFxuICAgIHJldHVybiBmU2NhbGVEZXB0aCAqIGV4cCgtMC4wMDI4NyArIHgqKDAuNDU5ICsgeCooMy44MyArIHgqKC02LjgwICsgeCo1LjI1KSkpKTtcXG5cXFxufVxcblxcXG5cXG5cXFxuQXRtb3NwaGVyZUNvbG9yIGNvbXB1dGVHcm91bmRBdG1vc3BoZXJlRnJvbVNwYWNlKHZlYzMgdjNQb3MsIGJvb2wgZHluYW1pY0xpZ2h0aW5nLCB2ZWMzIGxpZ2h0RGlyZWN0aW9uV0MpXFxuXFxcbntcXG5cXFxuICAgIGZsb2F0IGZJbm5lclJhZGl1cyA9IGN6bV9lbGxpcHNvaWRSYWRpaS54O1xcblxcXG4gICAgZmxvYXQgZk91dGVyUmFkaXVzID0gY3ptX2VsbGlwc29pZFJhZGlpLnggKiAxLjAyNTtcXG5cXFxuICAgIGZsb2F0IGZPdXRlclJhZGl1czIgPSBmT3V0ZXJSYWRpdXMgKiBmT3V0ZXJSYWRpdXM7XFxuXFxcblxcblxcXG4gICAgZmxvYXQgZlNjYWxlID0gMS4wIC8gKGZPdXRlclJhZGl1cyAtIGZJbm5lclJhZGl1cyk7XFxuXFxcbiAgICBmbG9hdCBmU2NhbGVPdmVyU2NhbGVEZXB0aCA9IGZTY2FsZSAvIGZTY2FsZURlcHRoO1xcblxcXG5cXG5cXFxuICAgIC8vIEdldCB0aGUgcmF5IGZyb20gdGhlIGNhbWVyYSB0byB0aGUgdmVydGV4IGFuZCBpdHMgbGVuZ3RoICh3aGljaCBpcyB0aGUgZmFyIHBvaW50IG9mIHRoZSByYXkgcGFzc2luZyB0aHJvdWdoIHRoZSBhdG1vc3BoZXJlKVxcblxcXG4gICAgdmVjMyB2M1JheSA9IHYzUG9zIC0gY3ptX3ZpZXdlclBvc2l0aW9uV0M7XFxuXFxcbiAgICBmbG9hdCBmRmFyID0gbGVuZ3RoKHYzUmF5KTtcXG5cXFxuICAgIHYzUmF5IC89IGZGYXI7XFxuXFxcblxcblxcXG4gICAgZmxvYXQgZkNhbWVyYUhlaWdodCA9IGxlbmd0aChjem1fdmlld2VyUG9zaXRpb25XQyk7XFxuXFxcbiAgICBmbG9hdCBmQ2FtZXJhSGVpZ2h0MiA9IGZDYW1lcmFIZWlnaHQgKiBmQ2FtZXJhSGVpZ2h0O1xcblxcXG5cXG5cXFxuICAgIC8vIFRoaXMgbmV4dCBsaW5lIGlzIGFuIEFOR0xFIHdvcmthcm91bmQuIEl0IGlzIGVxdWl2YWxlbnQgdG8gQiA9IDIuMCAqIGRvdChjem1fdmlld2VyUG9zaXRpb25XQywgdjNSYXkpLFxcblxcXG4gICAgLy8gd2hpY2ggaXMgd2hhdCBpdCBzaG91bGQgYmUsIGJ1dCB0aGVyZSBhcmUgcHJvYmxlbXMgYXQgdGhlIHBvbGVzLlxcblxcXG4gICAgZmxvYXQgQiA9IDIuMCAqIGxlbmd0aChjem1fdmlld2VyUG9zaXRpb25XQykgKiBkb3Qobm9ybWFsaXplKGN6bV92aWV3ZXJQb3NpdGlvbldDKSwgdjNSYXkpO1xcblxcXG4gICAgZmxvYXQgQyA9IGZDYW1lcmFIZWlnaHQyIC0gZk91dGVyUmFkaXVzMjtcXG5cXFxuICAgIGZsb2F0IGZEZXQgPSBtYXgoMC4wLCBCKkIgLSA0LjAgKiBDKTtcXG5cXFxuICAgIGZsb2F0IGZOZWFyID0gMC41ICogKC1CIC0gc3FydChmRGV0KSk7XFxuXFxcblxcblxcXG4gICAgLy8gQ2FsY3VsYXRlIHRoZSByYXkncyBzdGFydGluZyBwb3NpdGlvbiwgdGhlbiBjYWxjdWxhdGUgaXRzIHNjYXR0ZXJpbmcgb2Zmc2V0XFxuXFxcbiAgICB2ZWMzIHYzU3RhcnQgPSBjem1fdmlld2VyUG9zaXRpb25XQyArIHYzUmF5ICogZk5lYXI7XFxuXFxcbiAgICBmRmFyIC09IGZOZWFyO1xcblxcXG4gICAgZmxvYXQgZkRlcHRoID0gZXhwKChmSW5uZXJSYWRpdXMgLSBmT3V0ZXJSYWRpdXMpIC8gZlNjYWxlRGVwdGgpO1xcblxcXG5cXG5cXFxuICAgIC8vIFRoZSBsaWdodCBhbmdsZSBiYXNlZCBvbiB0aGUgc2NlbmUncyBsaWdodCBzb3VyY2Ugd291bGQgYmU6XFxuXFxcbiAgICAvLyAgICBkb3QobGlnaHREaXJlY3Rpb25XQywgdjNQb3MpIC8gbGVuZ3RoKHYzUG9zKTtcXG5cXFxuICAgIC8vIFdoZW4gd2Ugd2FudCB0aGUgYXRtb3NwaGVyZSB0byBiZSB1bmlmb3JtIG92ZXIgdGhlIGdsb2JlIHNvIGl0IGlzIHNldCB0byAxLjAuXFxuXFxcblxcblxcXG4gICAgZmxvYXQgZkxpZ2h0QW5nbGUgPSBjem1fYnJhbmNoRnJlZVRlcm5hcnkoZHluYW1pY0xpZ2h0aW5nLCBkb3QobGlnaHREaXJlY3Rpb25XQywgdjNQb3MpIC8gbGVuZ3RoKHYzUG9zKSwgMS4wKTtcXG5cXFxuICAgIGZsb2F0IGZDYW1lcmFBbmdsZSA9IGRvdCgtdjNSYXksIHYzUG9zKSAvIGxlbmd0aCh2M1Bvcyk7XFxuXFxcbiAgICBmbG9hdCBmQ2FtZXJhU2NhbGUgPSBzY2FsZShmQ2FtZXJhQW5nbGUpO1xcblxcXG4gICAgZmxvYXQgZkxpZ2h0U2NhbGUgPSBzY2FsZShmTGlnaHRBbmdsZSk7XFxuXFxcbiAgICBmbG9hdCBmQ2FtZXJhT2Zmc2V0ID0gZkRlcHRoKmZDYW1lcmFTY2FsZTtcXG5cXFxuICAgIGZsb2F0IGZUZW1wID0gKGZMaWdodFNjYWxlICsgZkNhbWVyYVNjYWxlKTtcXG5cXFxuXFxuXFxcbiAgICAvLyBJbml0aWFsaXplIHRoZSBzY2F0dGVyaW5nIGxvb3AgdmFyaWFibGVzXFxuXFxcbiAgICBmbG9hdCBmU2FtcGxlTGVuZ3RoID0gZkZhciAvIGZTYW1wbGVzO1xcblxcXG4gICAgZmxvYXQgZlNjYWxlZExlbmd0aCA9IGZTYW1wbGVMZW5ndGggKiBmU2NhbGU7XFxuXFxcbiAgICB2ZWMzIHYzU2FtcGxlUmF5ID0gdjNSYXkgKiBmU2FtcGxlTGVuZ3RoO1xcblxcXG4gICAgdmVjMyB2M1NhbXBsZVBvaW50ID0gdjNTdGFydCArIHYzU2FtcGxlUmF5ICogMC41O1xcblxcXG5cXG5cXFxuICAgIC8vIE5vdyBsb29wIHRocm91Z2ggdGhlIHNhbXBsZSByYXlzXFxuXFxcbiAgICB2ZWMzIHYzRnJvbnRDb2xvciA9IHZlYzMoMC4wKTtcXG5cXFxuICAgIHZlYzMgdjNBdHRlbnVhdGUgPSB2ZWMzKDAuMCk7XFxuXFxcbiAgICBmb3IoaW50IGk9MDsgaTxuU2FtcGxlczsgaSsrKVxcblxcXG4gICAge1xcblxcXG4gICAgICAgIGZsb2F0IGZIZWlnaHQgPSBsZW5ndGgodjNTYW1wbGVQb2ludCk7XFxuXFxcbiAgICAgICAgZmxvYXQgZkRlcHRoID0gZXhwKGZTY2FsZU92ZXJTY2FsZURlcHRoICogKGZJbm5lclJhZGl1cyAtIGZIZWlnaHQpKTtcXG5cXFxuICAgICAgICBmbG9hdCBmU2NhdHRlciA9IGZEZXB0aCpmVGVtcCAtIGZDYW1lcmFPZmZzZXQ7XFxuXFxcbiAgICAgICAgdjNBdHRlbnVhdGUgPSBleHAoLWZTY2F0dGVyICogKHYzSW52V2F2ZWxlbmd0aCAqIGZLcjRQSSArIGZLbTRQSSkpO1xcblxcXG4gICAgICAgIHYzRnJvbnRDb2xvciArPSB2M0F0dGVudWF0ZSAqIChmRGVwdGggKiBmU2NhbGVkTGVuZ3RoKTtcXG5cXFxuICAgICAgICB2M1NhbXBsZVBvaW50ICs9IHYzU2FtcGxlUmF5O1xcblxcXG4gICAgfVxcblxcXG5cXG5cXFxuICAgIEF0bW9zcGhlcmVDb2xvciBjb2xvcjtcXG5cXFxuICAgIGNvbG9yLm1pZSA9IHYzRnJvbnRDb2xvciAqICh2M0ludldhdmVsZW5ndGggKiBmS3JFU3VuICsgZkttRVN1bik7XFxuXFxcbiAgICBjb2xvci5yYXlsZWlnaCA9IHYzQXR0ZW51YXRlOyAvLyBDYWxjdWxhdGUgdGhlIGF0dGVudWF0aW9uIGZhY3RvciBmb3IgdGhlIGdyb3VuZFxcblxcXG5cXG5cXFxuICAgIHJldHVybiBjb2xvcjtcXG5cXFxufVxcblxcXG5cXG5cXFxuXCI7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///62868\n')},4635:function(__unused_webpack___webpack_module__,__webpack_exports__){eval('//This file is automatically rebuilt by the Cesium build process.\n/* harmony default export */ __webpack_exports__["Z"] = ("uniform sampler2D image;\\n\\\n\\n\\\nczm_material czm_getMaterial(czm_materialInput materialInput)\\n\\\n{\\n\\\n    czm_material material = czm_getDefaultMaterial(materialInput);\\n\\\n    vec4 rampColor = texture2D(image, vec2(materialInput.aspect / (2.0 * czm_pi), 0.5));\\n\\\n    rampColor = czm_gammaCorrect(rampColor);\\n\\\n    material.diffuse = rampColor.rgb;\\n\\\n    material.alpha = rampColor.a;\\n\\\n    return material;\\n\\\n}\\n\\\n");\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNDYzNS5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBLHlEQUFlLHlCQUF5QjtBQUN4QztBQUNBO0FBQ0EsQ0FBQztBQUNELGtFQUFrRTtBQUNsRSx3RkFBd0Y7QUFDeEYsNENBQTRDO0FBQzVDLHFDQUFxQztBQUNyQyxpQ0FBaUM7QUFDakMsb0JBQW9CO0FBQ3BCLENBQUM7QUFDRCxDQUFDLEVBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly92dWUzLXdlYnBhY2s1Ly4vbm9kZV9tb2R1bGVzL2Nlc2l1bS9Tb3VyY2UvU2hhZGVycy9NYXRlcmlhbHMvQXNwZWN0UmFtcE1hdGVyaWFsLmpzPzY0ODciXSwic291cmNlc0NvbnRlbnQiOlsiLy9UaGlzIGZpbGUgaXMgYXV0b21hdGljYWxseSByZWJ1aWx0IGJ5IHRoZSBDZXNpdW0gYnVpbGQgcHJvY2Vzcy5cbmV4cG9ydCBkZWZhdWx0IFwidW5pZm9ybSBzYW1wbGVyMkQgaW1hZ2U7XFxuXFxcblxcblxcXG5jem1fbWF0ZXJpYWwgY3ptX2dldE1hdGVyaWFsKGN6bV9tYXRlcmlhbElucHV0IG1hdGVyaWFsSW5wdXQpXFxuXFxcbntcXG5cXFxuICAgIGN6bV9tYXRlcmlhbCBtYXRlcmlhbCA9IGN6bV9nZXREZWZhdWx0TWF0ZXJpYWwobWF0ZXJpYWxJbnB1dCk7XFxuXFxcbiAgICB2ZWM0IHJhbXBDb2xvciA9IHRleHR1cmUyRChpbWFnZSwgdmVjMihtYXRlcmlhbElucHV0LmFzcGVjdCAvICgyLjAgKiBjem1fcGkpLCAwLjUpKTtcXG5cXFxuICAgIHJhbXBDb2xvciA9IGN6bV9nYW1tYUNvcnJlY3QocmFtcENvbG9yKTtcXG5cXFxuICAgIG1hdGVyaWFsLmRpZmZ1c2UgPSByYW1wQ29sb3IucmdiO1xcblxcXG4gICAgbWF0ZXJpYWwuYWxwaGEgPSByYW1wQ29sb3IuYTtcXG5cXFxuICAgIHJldHVybiBtYXRlcmlhbDtcXG5cXFxufVxcblxcXG5cIjtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///4635\n')},32824:function(__unused_webpack___webpack_module__,__webpack_exports__){eval('//This file is automatically rebuilt by the Cesium build process.\n/* harmony default export */ __webpack_exports__["Z"] = ("uniform sampler2D image;\\n\\\nuniform float strength;\\n\\\nuniform vec2 repeat;\\n\\\n\\n\\\nczm_material czm_getMaterial(czm_materialInput materialInput)\\n\\\n{\\n\\\n    czm_material material = czm_getDefaultMaterial(materialInput);\\n\\\n\\n\\\n    vec2 st = materialInput.st;\\n\\\n\\n\\\n    vec2 centerPixel = fract(repeat * st);\\n\\\n    float centerBump = texture2D(image, centerPixel).channel;\\n\\\n\\n\\\n    float imageWidth = float(imageDimensions.x);\\n\\\n    vec2 rightPixel = fract(repeat * (st + vec2(1.0 / imageWidth, 0.0)));\\n\\\n    float rightBump = texture2D(image, rightPixel).channel;\\n\\\n\\n\\\n    float imageHeight = float(imageDimensions.y);\\n\\\n    vec2 leftPixel = fract(repeat * (st + vec2(0.0, 1.0 / imageHeight)));\\n\\\n    float topBump = texture2D(image, leftPixel).channel;\\n\\\n\\n\\\n    vec3 normalTangentSpace = normalize(vec3(centerBump - rightBump, centerBump - topBump, clamp(1.0 - strength, 0.1, 1.0)));\\n\\\n    vec3 normalEC = materialInput.tangentToEyeMatrix * normalTangentSpace;\\n\\\n\\n\\\n    material.normal = normalEC;\\n\\\n    material.diffuse = vec3(0.01);\\n\\\n\\n\\\n    return material;\\n\\\n}\\n\\\n");\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMzI4MjQuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQSx5REFBZSx5QkFBeUI7QUFDeEMsdUJBQXVCO0FBQ3ZCLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0EsQ0FBQztBQUNELGtFQUFrRTtBQUNsRTtBQUNBLCtCQUErQjtBQUMvQjtBQUNBLDBDQUEwQztBQUMxQyw2REFBNkQ7QUFDN0Q7QUFDQSxnREFBZ0Q7QUFDaEQseUVBQXlFO0FBQ3pFLDJEQUEyRDtBQUMzRDtBQUNBLGlEQUFpRDtBQUNqRCx5RUFBeUU7QUFDekUsd0RBQXdEO0FBQ3hEO0FBQ0EsNkhBQTZIO0FBQzdILDBFQUEwRTtBQUMxRTtBQUNBLCtCQUErQjtBQUMvQixrQ0FBa0M7QUFDbEM7QUFDQSxvQkFBb0I7QUFDcEIsQ0FBQztBQUNELENBQUMsRUFBQyIsInNvdXJjZXMiOlsid2VicGFjazovL3Z1ZTMtd2VicGFjazUvLi9ub2RlX21vZHVsZXMvY2VzaXVtL1NvdXJjZS9TaGFkZXJzL01hdGVyaWFscy9CdW1wTWFwTWF0ZXJpYWwuanM/NmU5YSJdLCJzb3VyY2VzQ29udGVudCI6WyIvL1RoaXMgZmlsZSBpcyBhdXRvbWF0aWNhbGx5IHJlYnVpbHQgYnkgdGhlIENlc2l1bSBidWlsZCBwcm9jZXNzLlxuZXhwb3J0IGRlZmF1bHQgXCJ1bmlmb3JtIHNhbXBsZXIyRCBpbWFnZTtcXG5cXFxudW5pZm9ybSBmbG9hdCBzdHJlbmd0aDtcXG5cXFxudW5pZm9ybSB2ZWMyIHJlcGVhdDtcXG5cXFxuXFxuXFxcbmN6bV9tYXRlcmlhbCBjem1fZ2V0TWF0ZXJpYWwoY3ptX21hdGVyaWFsSW5wdXQgbWF0ZXJpYWxJbnB1dClcXG5cXFxue1xcblxcXG4gICAgY3ptX21hdGVyaWFsIG1hdGVyaWFsID0gY3ptX2dldERlZmF1bHRNYXRlcmlhbChtYXRlcmlhbElucHV0KTtcXG5cXFxuXFxuXFxcbiAgICB2ZWMyIHN0ID0gbWF0ZXJpYWxJbnB1dC5zdDtcXG5cXFxuXFxuXFxcbiAgICB2ZWMyIGNlbnRlclBpeGVsID0gZnJhY3QocmVwZWF0ICogc3QpO1xcblxcXG4gICAgZmxvYXQgY2VudGVyQnVtcCA9IHRleHR1cmUyRChpbWFnZSwgY2VudGVyUGl4ZWwpLmNoYW5uZWw7XFxuXFxcblxcblxcXG4gICAgZmxvYXQgaW1hZ2VXaWR0aCA9IGZsb2F0KGltYWdlRGltZW5zaW9ucy54KTtcXG5cXFxuICAgIHZlYzIgcmlnaHRQaXhlbCA9IGZyYWN0KHJlcGVhdCAqIChzdCArIHZlYzIoMS4wIC8gaW1hZ2VXaWR0aCwgMC4wKSkpO1xcblxcXG4gICAgZmxvYXQgcmlnaHRCdW1wID0gdGV4dHVyZTJEKGltYWdlLCByaWdodFBpeGVsKS5jaGFubmVsO1xcblxcXG5cXG5cXFxuICAgIGZsb2F0IGltYWdlSGVpZ2h0ID0gZmxvYXQoaW1hZ2VEaW1lbnNpb25zLnkpO1xcblxcXG4gICAgdmVjMiBsZWZ0UGl4ZWwgPSBmcmFjdChyZXBlYXQgKiAoc3QgKyB2ZWMyKDAuMCwgMS4wIC8gaW1hZ2VIZWlnaHQpKSk7XFxuXFxcbiAgICBmbG9hdCB0b3BCdW1wID0gdGV4dHVyZTJEKGltYWdlLCBsZWZ0UGl4ZWwpLmNoYW5uZWw7XFxuXFxcblxcblxcXG4gICAgdmVjMyBub3JtYWxUYW5nZW50U3BhY2UgPSBub3JtYWxpemUodmVjMyhjZW50ZXJCdW1wIC0gcmlnaHRCdW1wLCBjZW50ZXJCdW1wIC0gdG9wQnVtcCwgY2xhbXAoMS4wIC0gc3RyZW5ndGgsIDAuMSwgMS4wKSkpO1xcblxcXG4gICAgdmVjMyBub3JtYWxFQyA9IG1hdGVyaWFsSW5wdXQudGFuZ2VudFRvRXllTWF0cml4ICogbm9ybWFsVGFuZ2VudFNwYWNlO1xcblxcXG5cXG5cXFxuICAgIG1hdGVyaWFsLm5vcm1hbCA9IG5vcm1hbEVDO1xcblxcXG4gICAgbWF0ZXJpYWwuZGlmZnVzZSA9IHZlYzMoMC4wMSk7XFxuXFxcblxcblxcXG4gICAgcmV0dXJuIG1hdGVyaWFsO1xcblxcXG59XFxuXFxcblwiO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///32824\n')},12748:function(__unused_webpack___webpack_module__,__webpack_exports__){eval('//This file is automatically rebuilt by the Cesium build process.\n/* harmony default export */ __webpack_exports__["Z"] = ("uniform vec4 lightColor;\\n\\\nuniform vec4 darkColor;\\n\\\nuniform vec2 repeat;\\n\\\n\\n\\\nczm_material czm_getMaterial(czm_materialInput materialInput)\\n\\\n{\\n\\\n    czm_material material = czm_getDefaultMaterial(materialInput);\\n\\\n\\n\\\n    vec2 st = materialInput.st;\\n\\\n\\n\\\n    // From Stefan Gustavson\'s Procedural Textures in GLSL in OpenGL Insights\\n\\\n    float b = mod(floor(repeat.s * st.s) + floor(repeat.t * st.t), 2.0);  // 0.0 or 1.0\\n\\\n\\n\\\n    // Find the distance from the closest separator (region between two colors)\\n\\\n    float scaledWidth = fract(repeat.s * st.s);\\n\\\n    scaledWidth = abs(scaledWidth - floor(scaledWidth + 0.5));\\n\\\n    float scaledHeight = fract(repeat.t * st.t);\\n\\\n    scaledHeight = abs(scaledHeight - floor(scaledHeight + 0.5));\\n\\\n    float value = min(scaledWidth, scaledHeight);\\n\\\n\\n\\\n    vec4 currentColor = mix(lightColor, darkColor, b);\\n\\\n    vec4 color = czm_antialias(lightColor, darkColor, currentColor, value, 0.03);\\n\\\n\\n\\\n    color = czm_gammaCorrect(color);\\n\\\n    material.diffuse = color.rgb;\\n\\\n    material.alpha = color.a;\\n\\\n\\n\\\n    return material;\\n\\\n}\\n\\\n");\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTI3NDguanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQSx5REFBZSx5QkFBeUI7QUFDeEMsdUJBQXVCO0FBQ3ZCLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0EsQ0FBQztBQUNELGtFQUFrRTtBQUNsRTtBQUNBLCtCQUErQjtBQUMvQjtBQUNBO0FBQ0EsMEVBQTBFO0FBQzFFO0FBQ0E7QUFDQSwrQ0FBK0M7QUFDL0MsOERBQThEO0FBQzlELGdEQUFnRDtBQUNoRCxpRUFBaUU7QUFDakUsaURBQWlEO0FBQ2pEO0FBQ0Esc0RBQXNEO0FBQ3RELGlGQUFpRjtBQUNqRjtBQUNBLG9DQUFvQztBQUNwQyxpQ0FBaUM7QUFDakMsNkJBQTZCO0FBQzdCO0FBQ0Esb0JBQW9CO0FBQ3BCLENBQUM7QUFDRCxDQUFDLEVBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly92dWUzLXdlYnBhY2s1Ly4vbm9kZV9tb2R1bGVzL2Nlc2l1bS9Tb3VyY2UvU2hhZGVycy9NYXRlcmlhbHMvQ2hlY2tlcmJvYXJkTWF0ZXJpYWwuanM/N2MyZSJdLCJzb3VyY2VzQ29udGVudCI6WyIvL1RoaXMgZmlsZSBpcyBhdXRvbWF0aWNhbGx5IHJlYnVpbHQgYnkgdGhlIENlc2l1bSBidWlsZCBwcm9jZXNzLlxuZXhwb3J0IGRlZmF1bHQgXCJ1bmlmb3JtIHZlYzQgbGlnaHRDb2xvcjtcXG5cXFxudW5pZm9ybSB2ZWM0IGRhcmtDb2xvcjtcXG5cXFxudW5pZm9ybSB2ZWMyIHJlcGVhdDtcXG5cXFxuXFxuXFxcbmN6bV9tYXRlcmlhbCBjem1fZ2V0TWF0ZXJpYWwoY3ptX21hdGVyaWFsSW5wdXQgbWF0ZXJpYWxJbnB1dClcXG5cXFxue1xcblxcXG4gICAgY3ptX21hdGVyaWFsIG1hdGVyaWFsID0gY3ptX2dldERlZmF1bHRNYXRlcmlhbChtYXRlcmlhbElucHV0KTtcXG5cXFxuXFxuXFxcbiAgICB2ZWMyIHN0ID0gbWF0ZXJpYWxJbnB1dC5zdDtcXG5cXFxuXFxuXFxcbiAgICAvLyBGcm9tIFN0ZWZhbiBHdXN0YXZzb24ncyBQcm9jZWR1cmFsIFRleHR1cmVzIGluIEdMU0wgaW4gT3BlbkdMIEluc2lnaHRzXFxuXFxcbiAgICBmbG9hdCBiID0gbW9kKGZsb29yKHJlcGVhdC5zICogc3QucykgKyBmbG9vcihyZXBlYXQudCAqIHN0LnQpLCAyLjApOyAgLy8gMC4wIG9yIDEuMFxcblxcXG5cXG5cXFxuICAgIC8vIEZpbmQgdGhlIGRpc3RhbmNlIGZyb20gdGhlIGNsb3Nlc3Qgc2VwYXJhdG9yIChyZWdpb24gYmV0d2VlbiB0d28gY29sb3JzKVxcblxcXG4gICAgZmxvYXQgc2NhbGVkV2lkdGggPSBmcmFjdChyZXBlYXQucyAqIHN0LnMpO1xcblxcXG4gICAgc2NhbGVkV2lkdGggPSBhYnMoc2NhbGVkV2lkdGggLSBmbG9vcihzY2FsZWRXaWR0aCArIDAuNSkpO1xcblxcXG4gICAgZmxvYXQgc2NhbGVkSGVpZ2h0ID0gZnJhY3QocmVwZWF0LnQgKiBzdC50KTtcXG5cXFxuICAgIHNjYWxlZEhlaWdodCA9IGFicyhzY2FsZWRIZWlnaHQgLSBmbG9vcihzY2FsZWRIZWlnaHQgKyAwLjUpKTtcXG5cXFxuICAgIGZsb2F0IHZhbHVlID0gbWluKHNjYWxlZFdpZHRoLCBzY2FsZWRIZWlnaHQpO1xcblxcXG5cXG5cXFxuICAgIHZlYzQgY3VycmVudENvbG9yID0gbWl4KGxpZ2h0Q29sb3IsIGRhcmtDb2xvciwgYik7XFxuXFxcbiAgICB2ZWM0IGNvbG9yID0gY3ptX2FudGlhbGlhcyhsaWdodENvbG9yLCBkYXJrQ29sb3IsIGN1cnJlbnRDb2xvciwgdmFsdWUsIDAuMDMpO1xcblxcXG5cXG5cXFxuICAgIGNvbG9yID0gY3ptX2dhbW1hQ29ycmVjdChjb2xvcik7XFxuXFxcbiAgICBtYXRlcmlhbC5kaWZmdXNlID0gY29sb3IucmdiO1xcblxcXG4gICAgbWF0ZXJpYWwuYWxwaGEgPSBjb2xvci5hO1xcblxcXG5cXG5cXFxuICAgIHJldHVybiBtYXRlcmlhbDtcXG5cXFxufVxcblxcXG5cIjtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///12748\n')},85805:function(__unused_webpack___webpack_module__,__webpack_exports__){eval('//This file is automatically rebuilt by the Cesium build process.\n/* harmony default export */ __webpack_exports__["Z"] = ("uniform vec4 lightColor;\\n\\\nuniform vec4 darkColor;\\n\\\nuniform vec2 repeat;\\n\\\n\\n\\\nczm_material czm_getMaterial(czm_materialInput materialInput)\\n\\\n{\\n\\\n    czm_material material = czm_getDefaultMaterial(materialInput);\\n\\\n\\n\\\n    // From Stefan Gustavson\'s Procedural Textures in GLSL in OpenGL Insights\\n\\\n    float b = smoothstep(0.3, 0.32, length(fract(repeat * materialInput.st) - 0.5));  // 0.0 or 1.0\\n\\\n\\n\\\n    vec4 color = mix(lightColor, darkColor, b);\\n\\\n    color = czm_gammaCorrect(color);\\n\\\n    material.diffuse = color.rgb;\\n\\\n    material.alpha = color.a;\\n\\\n\\n\\\n    return material;\\n\\\n}\\n\\\n");\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiODU4MDUuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQSx5REFBZSx5QkFBeUI7QUFDeEMsdUJBQXVCO0FBQ3ZCLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0EsQ0FBQztBQUNELGtFQUFrRTtBQUNsRTtBQUNBO0FBQ0Esc0ZBQXNGO0FBQ3RGO0FBQ0EsK0NBQStDO0FBQy9DLG9DQUFvQztBQUNwQyxpQ0FBaUM7QUFDakMsNkJBQTZCO0FBQzdCO0FBQ0Esb0JBQW9CO0FBQ3BCLENBQUM7QUFDRCxDQUFDLEVBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly92dWUzLXdlYnBhY2s1Ly4vbm9kZV9tb2R1bGVzL2Nlc2l1bS9Tb3VyY2UvU2hhZGVycy9NYXRlcmlhbHMvRG90TWF0ZXJpYWwuanM/YzNjYSJdLCJzb3VyY2VzQ29udGVudCI6WyIvL1RoaXMgZmlsZSBpcyBhdXRvbWF0aWNhbGx5IHJlYnVpbHQgYnkgdGhlIENlc2l1bSBidWlsZCBwcm9jZXNzLlxuZXhwb3J0IGRlZmF1bHQgXCJ1bmlmb3JtIHZlYzQgbGlnaHRDb2xvcjtcXG5cXFxudW5pZm9ybSB2ZWM0IGRhcmtDb2xvcjtcXG5cXFxudW5pZm9ybSB2ZWMyIHJlcGVhdDtcXG5cXFxuXFxuXFxcbmN6bV9tYXRlcmlhbCBjem1fZ2V0TWF0ZXJpYWwoY3ptX21hdGVyaWFsSW5wdXQgbWF0ZXJpYWxJbnB1dClcXG5cXFxue1xcblxcXG4gICAgY3ptX21hdGVyaWFsIG1hdGVyaWFsID0gY3ptX2dldERlZmF1bHRNYXRlcmlhbChtYXRlcmlhbElucHV0KTtcXG5cXFxuXFxuXFxcbiAgICAvLyBGcm9tIFN0ZWZhbiBHdXN0YXZzb24ncyBQcm9jZWR1cmFsIFRleHR1cmVzIGluIEdMU0wgaW4gT3BlbkdMIEluc2lnaHRzXFxuXFxcbiAgICBmbG9hdCBiID0gc21vb3Roc3RlcCgwLjMsIDAuMzIsIGxlbmd0aChmcmFjdChyZXBlYXQgKiBtYXRlcmlhbElucHV0LnN0KSAtIDAuNSkpOyAgLy8gMC4wIG9yIDEuMFxcblxcXG5cXG5cXFxuICAgIHZlYzQgY29sb3IgPSBtaXgobGlnaHRDb2xvciwgZGFya0NvbG9yLCBiKTtcXG5cXFxuICAgIGNvbG9yID0gY3ptX2dhbW1hQ29ycmVjdChjb2xvcik7XFxuXFxcbiAgICBtYXRlcmlhbC5kaWZmdXNlID0gY29sb3IucmdiO1xcblxcXG4gICAgbWF0ZXJpYWwuYWxwaGEgPSBjb2xvci5hO1xcblxcXG5cXG5cXFxuICAgIHJldHVybiBtYXRlcmlhbDtcXG5cXFxufVxcblxcXG5cIjtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///85805\n')},43659:function(__unused_webpack___webpack_module__,__webpack_exports__){eval('//This file is automatically rebuilt by the Cesium build process.\n/* harmony default export */ __webpack_exports__["Z"] = ("uniform sampler2D heights;\\n\\\nuniform sampler2D colors;\\n\\\n\\n\\\n// This material expects heights to be sorted from lowest to highest.\\n\\\n\\n\\\nfloat getHeight(int idx, float invTexSize)\\n\\\n{\\n\\\n    vec2 uv = vec2((float(idx) + 0.5) * invTexSize, 0.5);\\n\\\n#ifdef OES_texture_float\\n\\\n    return texture2D(heights, uv).x;\\n\\\n#else\\n\\\n    return czm_unpackFloat(texture2D(heights, uv));\\n\\\n#endif\\n\\\n}\\n\\\n\\n\\\nczm_material czm_getMaterial(czm_materialInput materialInput)\\n\\\n{\\n\\\n    czm_material material = czm_getDefaultMaterial(materialInput);\\n\\\n\\n\\\n    float height = materialInput.height;\\n\\\n    float invTexSize = 1.0 / float(heightsDimensions.x);\\n\\\n\\n\\\n    float minHeight = getHeight(0, invTexSize);\\n\\\n    float maxHeight = getHeight(heightsDimensions.x - 1, invTexSize);\\n\\\n\\n\\\n    // early-out when outside the height range\\n\\\n    if (height < minHeight || height > maxHeight) {\\n\\\n        material.diffuse = vec3(0.0);\\n\\\n        material.alpha = 0.0;\\n\\\n        return material;\\n\\\n    }\\n\\\n\\n\\\n    // Binary search to find heights above and below.\\n\\\n    int idxBelow = 0;\\n\\\n    int idxAbove = heightsDimensions.x;\\n\\\n    float heightBelow = minHeight;\\n\\\n    float heightAbove = maxHeight;\\n\\\n\\n\\\n    // while loop not allowed, so use for loop with max iterations.\\n\\\n    // maxIterations of 16 supports a texture size up to 65536 (2^16).\\n\\\n    const int maxIterations = 16;\\n\\\n    for (int i = 0; i < maxIterations; i++) {\\n\\\n        if (idxBelow >= idxAbove - 1) {\\n\\\n            break;\\n\\\n        }\\n\\\n\\n\\\n        int idxMid = (idxBelow + idxAbove) / 2;\\n\\\n        float heightTex = getHeight(idxMid, invTexSize);\\n\\\n\\n\\\n        if (height > heightTex) {\\n\\\n            idxBelow = idxMid;\\n\\\n            heightBelow = heightTex;\\n\\\n        } else {\\n\\\n            idxAbove = idxMid;\\n\\\n            heightAbove = heightTex;\\n\\\n        }\\n\\\n    }\\n\\\n\\n\\\n    float lerper = heightBelow == heightAbove ? 1.0 : (height - heightBelow) / (heightAbove - heightBelow);\\n\\\n    vec2 colorUv = vec2(invTexSize * (float(idxBelow) + 0.5 + lerper), 0.5);\\n\\\n    vec4 color = texture2D(colors, colorUv);\\n\\\n\\n\\\n    // undo preumultiplied alpha\\n\\\n    if (color.a > 0.0) \\n\\\n    {\\n\\\n        color.rgb /= color.a;\\n\\\n    }\\n\\\n    \\n\\\n    color.rgb = czm_gammaCorrect(color.rgb);\\n\\\n\\n\\\n    material.diffuse = color.rgb;\\n\\\n    material.alpha = color.a;\\n\\\n    return material;\\n\\\n}\\n\\\n");\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNDM2NTkuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQSx5REFBZSwyQkFBMkI7QUFDMUMseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNELHlEQUF5RDtBQUN6RDtBQUNBLG9DQUFvQztBQUNwQztBQUNBLG1EQUFtRDtBQUNuRDtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNELGtFQUFrRTtBQUNsRTtBQUNBLHdDQUF3QztBQUN4Qyx3REFBd0Q7QUFDeEQ7QUFDQSwrQ0FBK0M7QUFDL0MscUVBQXFFO0FBQ3JFO0FBQ0E7QUFDQSxtREFBbUQ7QUFDbkQscUNBQXFDO0FBQ3JDLDZCQUE2QjtBQUM3Qix3QkFBd0I7QUFDeEIsS0FBSztBQUNMO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckIsdUNBQXVDO0FBQ3ZDLGtDQUFrQztBQUNsQyxrQ0FBa0M7QUFDbEM7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDO0FBQ2pDLG9CQUFvQixtQkFBbUIsTUFBTTtBQUM3Qyx1Q0FBdUM7QUFDdkMsa0JBQWtCO0FBQ2xCLFNBQVM7QUFDVDtBQUNBLCtDQUErQztBQUMvQyx3REFBd0Q7QUFDeEQ7QUFDQSxpQ0FBaUM7QUFDakMsOEJBQThCO0FBQzlCLG9DQUFvQztBQUNwQyxVQUFVLE1BQU07QUFDaEIsOEJBQThCO0FBQzlCLG9DQUFvQztBQUNwQyxTQUFTO0FBQ1QsS0FBSztBQUNMO0FBQ0EsMkdBQTJHO0FBQzNHLDRFQUE0RTtBQUM1RSw0Q0FBNEM7QUFDNUM7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLDZCQUE2QjtBQUM3QixLQUFLO0FBQ0w7QUFDQSw0Q0FBNEM7QUFDNUM7QUFDQSxpQ0FBaUM7QUFDakMsNkJBQTZCO0FBQzdCLG9CQUFvQjtBQUNwQixDQUFDO0FBQ0QsQ0FBQyxFQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdnVlMy13ZWJwYWNrNS8uL25vZGVfbW9kdWxlcy9jZXNpdW0vU291cmNlL1NoYWRlcnMvTWF0ZXJpYWxzL0VsZXZhdGlvbkJhbmRNYXRlcmlhbC5qcz82NmQ4Il0sInNvdXJjZXNDb250ZW50IjpbIi8vVGhpcyBmaWxlIGlzIGF1dG9tYXRpY2FsbHkgcmVidWlsdCBieSB0aGUgQ2VzaXVtIGJ1aWxkIHByb2Nlc3MuXG5leHBvcnQgZGVmYXVsdCBcInVuaWZvcm0gc2FtcGxlcjJEIGhlaWdodHM7XFxuXFxcbnVuaWZvcm0gc2FtcGxlcjJEIGNvbG9ycztcXG5cXFxuXFxuXFxcbi8vIFRoaXMgbWF0ZXJpYWwgZXhwZWN0cyBoZWlnaHRzIHRvIGJlIHNvcnRlZCBmcm9tIGxvd2VzdCB0byBoaWdoZXN0LlxcblxcXG5cXG5cXFxuZmxvYXQgZ2V0SGVpZ2h0KGludCBpZHgsIGZsb2F0IGludlRleFNpemUpXFxuXFxcbntcXG5cXFxuICAgIHZlYzIgdXYgPSB2ZWMyKChmbG9hdChpZHgpICsgMC41KSAqIGludlRleFNpemUsIDAuNSk7XFxuXFxcbiNpZmRlZiBPRVNfdGV4dHVyZV9mbG9hdFxcblxcXG4gICAgcmV0dXJuIHRleHR1cmUyRChoZWlnaHRzLCB1dikueDtcXG5cXFxuI2Vsc2VcXG5cXFxuICAgIHJldHVybiBjem1fdW5wYWNrRmxvYXQodGV4dHVyZTJEKGhlaWdodHMsIHV2KSk7XFxuXFxcbiNlbmRpZlxcblxcXG59XFxuXFxcblxcblxcXG5jem1fbWF0ZXJpYWwgY3ptX2dldE1hdGVyaWFsKGN6bV9tYXRlcmlhbElucHV0IG1hdGVyaWFsSW5wdXQpXFxuXFxcbntcXG5cXFxuICAgIGN6bV9tYXRlcmlhbCBtYXRlcmlhbCA9IGN6bV9nZXREZWZhdWx0TWF0ZXJpYWwobWF0ZXJpYWxJbnB1dCk7XFxuXFxcblxcblxcXG4gICAgZmxvYXQgaGVpZ2h0ID0gbWF0ZXJpYWxJbnB1dC5oZWlnaHQ7XFxuXFxcbiAgICBmbG9hdCBpbnZUZXhTaXplID0gMS4wIC8gZmxvYXQoaGVpZ2h0c0RpbWVuc2lvbnMueCk7XFxuXFxcblxcblxcXG4gICAgZmxvYXQgbWluSGVpZ2h0ID0gZ2V0SGVpZ2h0KDAsIGludlRleFNpemUpO1xcblxcXG4gICAgZmxvYXQgbWF4SGVpZ2h0ID0gZ2V0SGVpZ2h0KGhlaWdodHNEaW1lbnNpb25zLnggLSAxLCBpbnZUZXhTaXplKTtcXG5cXFxuXFxuXFxcbiAgICAvLyBlYXJseS1vdXQgd2hlbiBvdXRzaWRlIHRoZSBoZWlnaHQgcmFuZ2VcXG5cXFxuICAgIGlmIChoZWlnaHQgPCBtaW5IZWlnaHQgfHwgaGVpZ2h0ID4gbWF4SGVpZ2h0KSB7XFxuXFxcbiAgICAgICAgbWF0ZXJpYWwuZGlmZnVzZSA9IHZlYzMoMC4wKTtcXG5cXFxuICAgICAgICBtYXRlcmlhbC5hbHBoYSA9IDAuMDtcXG5cXFxuICAgICAgICByZXR1cm4gbWF0ZXJpYWw7XFxuXFxcbiAgICB9XFxuXFxcblxcblxcXG4gICAgLy8gQmluYXJ5IHNlYXJjaCB0byBmaW5kIGhlaWdodHMgYWJvdmUgYW5kIGJlbG93LlxcblxcXG4gICAgaW50IGlkeEJlbG93ID0gMDtcXG5cXFxuICAgIGludCBpZHhBYm92ZSA9IGhlaWdodHNEaW1lbnNpb25zLng7XFxuXFxcbiAgICBmbG9hdCBoZWlnaHRCZWxvdyA9IG1pbkhlaWdodDtcXG5cXFxuICAgIGZsb2F0IGhlaWdodEFib3ZlID0gbWF4SGVpZ2h0O1xcblxcXG5cXG5cXFxuICAgIC8vIHdoaWxlIGxvb3Agbm90IGFsbG93ZWQsIHNvIHVzZSBmb3IgbG9vcCB3aXRoIG1heCBpdGVyYXRpb25zLlxcblxcXG4gICAgLy8gbWF4SXRlcmF0aW9ucyBvZiAxNiBzdXBwb3J0cyBhIHRleHR1cmUgc2l6ZSB1cCB0byA2NTUzNiAoMl4xNikuXFxuXFxcbiAgICBjb25zdCBpbnQgbWF4SXRlcmF0aW9ucyA9IDE2O1xcblxcXG4gICAgZm9yIChpbnQgaSA9IDA7IGkgPCBtYXhJdGVyYXRpb25zOyBpKyspIHtcXG5cXFxuICAgICAgICBpZiAoaWR4QmVsb3cgPj0gaWR4QWJvdmUgLSAxKSB7XFxuXFxcbiAgICAgICAgICAgIGJyZWFrO1xcblxcXG4gICAgICAgIH1cXG5cXFxuXFxuXFxcbiAgICAgICAgaW50IGlkeE1pZCA9IChpZHhCZWxvdyArIGlkeEFib3ZlKSAvIDI7XFxuXFxcbiAgICAgICAgZmxvYXQgaGVpZ2h0VGV4ID0gZ2V0SGVpZ2h0KGlkeE1pZCwgaW52VGV4U2l6ZSk7XFxuXFxcblxcblxcXG4gICAgICAgIGlmIChoZWlnaHQgPiBoZWlnaHRUZXgpIHtcXG5cXFxuICAgICAgICAgICAgaWR4QmVsb3cgPSBpZHhNaWQ7XFxuXFxcbiAgICAgICAgICAgIGhlaWdodEJlbG93ID0gaGVpZ2h0VGV4O1xcblxcXG4gICAgICAgIH0gZWxzZSB7XFxuXFxcbiAgICAgICAgICAgIGlkeEFib3ZlID0gaWR4TWlkO1xcblxcXG4gICAgICAgICAgICBoZWlnaHRBYm92ZSA9IGhlaWdodFRleDtcXG5cXFxuICAgICAgICB9XFxuXFxcbiAgICB9XFxuXFxcblxcblxcXG4gICAgZmxvYXQgbGVycGVyID0gaGVpZ2h0QmVsb3cgPT0gaGVpZ2h0QWJvdmUgPyAxLjAgOiAoaGVpZ2h0IC0gaGVpZ2h0QmVsb3cpIC8gKGhlaWdodEFib3ZlIC0gaGVpZ2h0QmVsb3cpO1xcblxcXG4gICAgdmVjMiBjb2xvclV2ID0gdmVjMihpbnZUZXhTaXplICogKGZsb2F0KGlkeEJlbG93KSArIDAuNSArIGxlcnBlciksIDAuNSk7XFxuXFxcbiAgICB2ZWM0IGNvbG9yID0gdGV4dHVyZTJEKGNvbG9ycywgY29sb3JVdik7XFxuXFxcblxcblxcXG4gICAgLy8gdW5kbyBwcmV1bXVsdGlwbGllZCBhbHBoYVxcblxcXG4gICAgaWYgKGNvbG9yLmEgPiAwLjApIFxcblxcXG4gICAge1xcblxcXG4gICAgICAgIGNvbG9yLnJnYiAvPSBjb2xvci5hO1xcblxcXG4gICAgfVxcblxcXG4gICAgXFxuXFxcbiAgICBjb2xvci5yZ2IgPSBjem1fZ2FtbWFDb3JyZWN0KGNvbG9yLnJnYik7XFxuXFxcblxcblxcXG4gICAgbWF0ZXJpYWwuZGlmZnVzZSA9IGNvbG9yLnJnYjtcXG5cXFxuICAgIG1hdGVyaWFsLmFscGhhID0gY29sb3IuYTtcXG5cXFxuICAgIHJldHVybiBtYXRlcmlhbDtcXG5cXFxufVxcblxcXG5cIjtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///43659\n')},94678:function(__unused_webpack___webpack_module__,__webpack_exports__){eval('//This file is automatically rebuilt by the Cesium build process.\n/* harmony default export */ __webpack_exports__["Z"] = ("#ifdef GL_OES_standard_derivatives\\n\\\n    #extension GL_OES_standard_derivatives : enable\\n\\\n#endif\\n\\\n\\n\\\nuniform vec4 color;\\n\\\nuniform float spacing;\\n\\\nuniform float width;\\n\\\n\\n\\\nczm_material czm_getMaterial(czm_materialInput materialInput)\\n\\\n{\\n\\\n    czm_material material = czm_getDefaultMaterial(materialInput);\\n\\\n\\n\\\n    float distanceToContour = mod(materialInput.height, spacing);\\n\\\n\\n\\\n#ifdef GL_OES_standard_derivatives\\n\\\n    float dxc = abs(dFdx(materialInput.height));\\n\\\n    float dyc = abs(dFdy(materialInput.height));\\n\\\n    float dF = max(dxc, dyc) * czm_pixelRatio * width;\\n\\\n    float alpha = (distanceToContour < dF) ? 1.0 : 0.0;\\n\\\n#else\\n\\\n    float alpha = (distanceToContour < (czm_pixelRatio * width)) ? 1.0 : 0.0;\\n\\\n#endif\\n\\\n\\n\\\n    vec4 outColor = czm_gammaCorrect(vec4(color.rgb, alpha * color.a));\\n\\\n    material.diffuse = outColor.rgb;\\n\\\n    material.alpha = outColor.a;\\n\\\n\\n\\\n    return material;\\n\\\n}\\n\\\n");\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiOTQ2NzguanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQSx5REFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQixzQkFBc0I7QUFDdEIsb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQSxDQUFDO0FBQ0Qsa0VBQWtFO0FBQ2xFO0FBQ0EsaUVBQWlFO0FBQ2pFO0FBQ0E7QUFDQSxnREFBZ0Q7QUFDaEQsZ0RBQWdEO0FBQ2hELHNEQUFzRDtBQUN0RCx1REFBdUQ7QUFDdkQ7QUFDQSw2RUFBNkU7QUFDN0U7QUFDQTtBQUNBLHVFQUF1RTtBQUN2RSxvQ0FBb0M7QUFDcEMsZ0NBQWdDO0FBQ2hDO0FBQ0Esb0JBQW9CO0FBQ3BCLENBQUM7QUFDRCxDQUFDLEVBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly92dWUzLXdlYnBhY2s1Ly4vbm9kZV9tb2R1bGVzL2Nlc2l1bS9Tb3VyY2UvU2hhZGVycy9NYXRlcmlhbHMvRWxldmF0aW9uQ29udG91ck1hdGVyaWFsLmpzP2U5ZTYiXSwic291cmNlc0NvbnRlbnQiOlsiLy9UaGlzIGZpbGUgaXMgYXV0b21hdGljYWxseSByZWJ1aWx0IGJ5IHRoZSBDZXNpdW0gYnVpbGQgcHJvY2Vzcy5cbmV4cG9ydCBkZWZhdWx0IFwiI2lmZGVmIEdMX09FU19zdGFuZGFyZF9kZXJpdmF0aXZlc1xcblxcXG4gICAgI2V4dGVuc2lvbiBHTF9PRVNfc3RhbmRhcmRfZGVyaXZhdGl2ZXMgOiBlbmFibGVcXG5cXFxuI2VuZGlmXFxuXFxcblxcblxcXG51bmlmb3JtIHZlYzQgY29sb3I7XFxuXFxcbnVuaWZvcm0gZmxvYXQgc3BhY2luZztcXG5cXFxudW5pZm9ybSBmbG9hdCB3aWR0aDtcXG5cXFxuXFxuXFxcbmN6bV9tYXRlcmlhbCBjem1fZ2V0TWF0ZXJpYWwoY3ptX21hdGVyaWFsSW5wdXQgbWF0ZXJpYWxJbnB1dClcXG5cXFxue1xcblxcXG4gICAgY3ptX21hdGVyaWFsIG1hdGVyaWFsID0gY3ptX2dldERlZmF1bHRNYXRlcmlhbChtYXRlcmlhbElucHV0KTtcXG5cXFxuXFxuXFxcbiAgICBmbG9hdCBkaXN0YW5jZVRvQ29udG91ciA9IG1vZChtYXRlcmlhbElucHV0LmhlaWdodCwgc3BhY2luZyk7XFxuXFxcblxcblxcXG4jaWZkZWYgR0xfT0VTX3N0YW5kYXJkX2Rlcml2YXRpdmVzXFxuXFxcbiAgICBmbG9hdCBkeGMgPSBhYnMoZEZkeChtYXRlcmlhbElucHV0LmhlaWdodCkpO1xcblxcXG4gICAgZmxvYXQgZHljID0gYWJzKGRGZHkobWF0ZXJpYWxJbnB1dC5oZWlnaHQpKTtcXG5cXFxuICAgIGZsb2F0IGRGID0gbWF4KGR4YywgZHljKSAqIGN6bV9waXhlbFJhdGlvICogd2lkdGg7XFxuXFxcbiAgICBmbG9hdCBhbHBoYSA9IChkaXN0YW5jZVRvQ29udG91ciA8IGRGKSA/IDEuMCA6IDAuMDtcXG5cXFxuI2Vsc2VcXG5cXFxuICAgIGZsb2F0IGFscGhhID0gKGRpc3RhbmNlVG9Db250b3VyIDwgKGN6bV9waXhlbFJhdGlvICogd2lkdGgpKSA/IDEuMCA6IDAuMDtcXG5cXFxuI2VuZGlmXFxuXFxcblxcblxcXG4gICAgdmVjNCBvdXRDb2xvciA9IGN6bV9nYW1tYUNvcnJlY3QodmVjNChjb2xvci5yZ2IsIGFscGhhICogY29sb3IuYSkpO1xcblxcXG4gICAgbWF0ZXJpYWwuZGlmZnVzZSA9IG91dENvbG9yLnJnYjtcXG5cXFxuICAgIG1hdGVyaWFsLmFscGhhID0gb3V0Q29sb3IuYTtcXG5cXFxuXFxuXFxcbiAgICByZXR1cm4gbWF0ZXJpYWw7XFxuXFxcbn1cXG5cXFxuXCI7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///94678\n')},44452:function(__unused_webpack___webpack_module__,__webpack_exports__){eval('//This file is automatically rebuilt by the Cesium build process.\n/* harmony default export */ __webpack_exports__["Z"] = ("uniform sampler2D image;\\n\\\nuniform float minimumHeight;\\n\\\nuniform float maximumHeight;\\n\\\n\\n\\\nczm_material czm_getMaterial(czm_materialInput materialInput)\\n\\\n{\\n\\\n    czm_material material = czm_getDefaultMaterial(materialInput);\\n\\\n    float scaledHeight = clamp((materialInput.height - minimumHeight) / (maximumHeight - minimumHeight), 0.0, 1.0);\\n\\\n    vec4 rampColor = texture2D(image, vec2(scaledHeight, 0.5));\\n\\\n    rampColor = czm_gammaCorrect(rampColor);\\n\\\n    material.diffuse = rampColor.rgb;\\n\\\n    material.alpha = rampColor.a;\\n\\\n    return material;\\n\\\n}\\n\\\n");\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNDQ0NTIuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQSx5REFBZSx5QkFBeUI7QUFDeEMsNEJBQTRCO0FBQzVCLDRCQUE0QjtBQUM1QjtBQUNBO0FBQ0EsQ0FBQztBQUNELGtFQUFrRTtBQUNsRSxtSEFBbUg7QUFDbkgsK0RBQStEO0FBQy9ELDRDQUE0QztBQUM1QyxxQ0FBcUM7QUFDckMsaUNBQWlDO0FBQ2pDLG9CQUFvQjtBQUNwQixDQUFDO0FBQ0QsQ0FBQyxFQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdnVlMy13ZWJwYWNrNS8uL25vZGVfbW9kdWxlcy9jZXNpdW0vU291cmNlL1NoYWRlcnMvTWF0ZXJpYWxzL0VsZXZhdGlvblJhbXBNYXRlcmlhbC5qcz9kOTY2Il0sInNvdXJjZXNDb250ZW50IjpbIi8vVGhpcyBmaWxlIGlzIGF1dG9tYXRpY2FsbHkgcmVidWlsdCBieSB0aGUgQ2VzaXVtIGJ1aWxkIHByb2Nlc3MuXG5leHBvcnQgZGVmYXVsdCBcInVuaWZvcm0gc2FtcGxlcjJEIGltYWdlO1xcblxcXG51bmlmb3JtIGZsb2F0IG1pbmltdW1IZWlnaHQ7XFxuXFxcbnVuaWZvcm0gZmxvYXQgbWF4aW11bUhlaWdodDtcXG5cXFxuXFxuXFxcbmN6bV9tYXRlcmlhbCBjem1fZ2V0TWF0ZXJpYWwoY3ptX21hdGVyaWFsSW5wdXQgbWF0ZXJpYWxJbnB1dClcXG5cXFxue1xcblxcXG4gICAgY3ptX21hdGVyaWFsIG1hdGVyaWFsID0gY3ptX2dldERlZmF1bHRNYXRlcmlhbChtYXRlcmlhbElucHV0KTtcXG5cXFxuICAgIGZsb2F0IHNjYWxlZEhlaWdodCA9IGNsYW1wKChtYXRlcmlhbElucHV0LmhlaWdodCAtIG1pbmltdW1IZWlnaHQpIC8gKG1heGltdW1IZWlnaHQgLSBtaW5pbXVtSGVpZ2h0KSwgMC4wLCAxLjApO1xcblxcXG4gICAgdmVjNCByYW1wQ29sb3IgPSB0ZXh0dXJlMkQoaW1hZ2UsIHZlYzIoc2NhbGVkSGVpZ2h0LCAwLjUpKTtcXG5cXFxuICAgIHJhbXBDb2xvciA9IGN6bV9nYW1tYUNvcnJlY3QocmFtcENvbG9yKTtcXG5cXFxuICAgIG1hdGVyaWFsLmRpZmZ1c2UgPSByYW1wQ29sb3IucmdiO1xcblxcXG4gICAgbWF0ZXJpYWwuYWxwaGEgPSByYW1wQ29sb3IuYTtcXG5cXFxuICAgIHJldHVybiBtYXRlcmlhbDtcXG5cXFxufVxcblxcXG5cIjtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///44452\n')},65082:function(__unused_webpack___webpack_module__,__webpack_exports__){eval('//This file is automatically rebuilt by the Cesium build process.\n/* harmony default export */ __webpack_exports__["Z"] = ("uniform vec4 fadeInColor;\\n\\\nuniform vec4 fadeOutColor;\\n\\\nuniform float maximumDistance;\\n\\\nuniform bool repeat;\\n\\\nuniform vec2 fadeDirection;\\n\\\nuniform vec2 time;\\n\\\n\\n\\\nfloat getTime(float t, float coord)\\n\\\n{\\n\\\n    float scalar = 1.0 / maximumDistance;\\n\\\n    float q  = distance(t, coord) * scalar;\\n\\\n    if (repeat)\\n\\\n    {\\n\\\n        float r = distance(t, coord + 1.0) * scalar;\\n\\\n        float s = distance(t, coord - 1.0) * scalar;\\n\\\n        q = min(min(r, s), q);\\n\\\n    }\\n\\\n    return clamp(q, 0.0, 1.0);\\n\\\n}\\n\\\n\\n\\\nczm_material czm_getMaterial(czm_materialInput materialInput)\\n\\\n{\\n\\\n    czm_material material = czm_getDefaultMaterial(materialInput);\\n\\\n\\n\\\n    vec2 st = materialInput.st;\\n\\\n    float s = getTime(time.x, st.s) * fadeDirection.s;\\n\\\n    float t = getTime(time.y, st.t) * fadeDirection.t;\\n\\\n\\n\\\n    float u = length(vec2(s, t));\\n\\\n    vec4 color = mix(fadeInColor, fadeOutColor, u);\\n\\\n\\n\\\n    color = czm_gammaCorrect(color);\\n\\\n    material.emission = color.rgb;\\n\\\n    material.alpha = color.a;\\n\\\n\\n\\\n    return material;\\n\\\n}\\n\\\n");\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNjUwODIuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQSx5REFBZSwwQkFBMEI7QUFDekMsMEJBQTBCO0FBQzFCLDhCQUE4QjtBQUM5QixvQkFBb0I7QUFDcEIsMkJBQTJCO0FBQzNCLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0EsQ0FBQztBQUNELHlDQUF5QztBQUN6QywyQ0FBMkM7QUFDM0M7QUFDQSxLQUFLO0FBQ0wsb0RBQW9EO0FBQ3BELG9EQUFvRDtBQUNwRCw4QkFBOEI7QUFDOUIsS0FBSztBQUNMLDhCQUE4QjtBQUM5QixDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRCxrRUFBa0U7QUFDbEU7QUFDQSwrQkFBK0I7QUFDL0Isc0RBQXNEO0FBQ3RELHNEQUFzRDtBQUN0RDtBQUNBLGlDQUFpQztBQUNqQyxtREFBbUQ7QUFDbkQ7QUFDQSxvQ0FBb0M7QUFDcEMsa0NBQWtDO0FBQ2xDLDZCQUE2QjtBQUM3QjtBQUNBLG9CQUFvQjtBQUNwQixDQUFDO0FBQ0QsQ0FBQyxFQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdnVlMy13ZWJwYWNrNS8uL25vZGVfbW9kdWxlcy9jZXNpdW0vU291cmNlL1NoYWRlcnMvTWF0ZXJpYWxzL0ZhZGVNYXRlcmlhbC5qcz9mZWI5Il0sInNvdXJjZXNDb250ZW50IjpbIi8vVGhpcyBmaWxlIGlzIGF1dG9tYXRpY2FsbHkgcmVidWlsdCBieSB0aGUgQ2VzaXVtIGJ1aWxkIHByb2Nlc3MuXG5leHBvcnQgZGVmYXVsdCBcInVuaWZvcm0gdmVjNCBmYWRlSW5Db2xvcjtcXG5cXFxudW5pZm9ybSB2ZWM0IGZhZGVPdXRDb2xvcjtcXG5cXFxudW5pZm9ybSBmbG9hdCBtYXhpbXVtRGlzdGFuY2U7XFxuXFxcbnVuaWZvcm0gYm9vbCByZXBlYXQ7XFxuXFxcbnVuaWZvcm0gdmVjMiBmYWRlRGlyZWN0aW9uO1xcblxcXG51bmlmb3JtIHZlYzIgdGltZTtcXG5cXFxuXFxuXFxcbmZsb2F0IGdldFRpbWUoZmxvYXQgdCwgZmxvYXQgY29vcmQpXFxuXFxcbntcXG5cXFxuICAgIGZsb2F0IHNjYWxhciA9IDEuMCAvIG1heGltdW1EaXN0YW5jZTtcXG5cXFxuICAgIGZsb2F0IHEgID0gZGlzdGFuY2UodCwgY29vcmQpICogc2NhbGFyO1xcblxcXG4gICAgaWYgKHJlcGVhdClcXG5cXFxuICAgIHtcXG5cXFxuICAgICAgICBmbG9hdCByID0gZGlzdGFuY2UodCwgY29vcmQgKyAxLjApICogc2NhbGFyO1xcblxcXG4gICAgICAgIGZsb2F0IHMgPSBkaXN0YW5jZSh0LCBjb29yZCAtIDEuMCkgKiBzY2FsYXI7XFxuXFxcbiAgICAgICAgcSA9IG1pbihtaW4ociwgcyksIHEpO1xcblxcXG4gICAgfVxcblxcXG4gICAgcmV0dXJuIGNsYW1wKHEsIDAuMCwgMS4wKTtcXG5cXFxufVxcblxcXG5cXG5cXFxuY3ptX21hdGVyaWFsIGN6bV9nZXRNYXRlcmlhbChjem1fbWF0ZXJpYWxJbnB1dCBtYXRlcmlhbElucHV0KVxcblxcXG57XFxuXFxcbiAgICBjem1fbWF0ZXJpYWwgbWF0ZXJpYWwgPSBjem1fZ2V0RGVmYXVsdE1hdGVyaWFsKG1hdGVyaWFsSW5wdXQpO1xcblxcXG5cXG5cXFxuICAgIHZlYzIgc3QgPSBtYXRlcmlhbElucHV0LnN0O1xcblxcXG4gICAgZmxvYXQgcyA9IGdldFRpbWUodGltZS54LCBzdC5zKSAqIGZhZGVEaXJlY3Rpb24ucztcXG5cXFxuICAgIGZsb2F0IHQgPSBnZXRUaW1lKHRpbWUueSwgc3QudCkgKiBmYWRlRGlyZWN0aW9uLnQ7XFxuXFxcblxcblxcXG4gICAgZmxvYXQgdSA9IGxlbmd0aCh2ZWMyKHMsIHQpKTtcXG5cXFxuICAgIHZlYzQgY29sb3IgPSBtaXgoZmFkZUluQ29sb3IsIGZhZGVPdXRDb2xvciwgdSk7XFxuXFxcblxcblxcXG4gICAgY29sb3IgPSBjem1fZ2FtbWFDb3JyZWN0KGNvbG9yKTtcXG5cXFxuICAgIG1hdGVyaWFsLmVtaXNzaW9uID0gY29sb3IucmdiO1xcblxcXG4gICAgbWF0ZXJpYWwuYWxwaGEgPSBjb2xvci5hO1xcblxcXG5cXG5cXFxuICAgIHJldHVybiBtYXRlcmlhbDtcXG5cXFxufVxcblxcXG5cIjtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///65082\n')},18595:function(__unused_webpack___webpack_module__,__webpack_exports__){eval('//This file is automatically rebuilt by the Cesium build process.\n/* harmony default export */ __webpack_exports__["Z"] = ("#ifdef GL_OES_standard_derivatives\\n\\\n    #extension GL_OES_standard_derivatives : enable\\n\\\n#endif\\n\\\n\\n\\\nuniform vec4 color;\\n\\\nuniform float cellAlpha;\\n\\\nuniform vec2 lineCount;\\n\\\nuniform vec2 lineThickness;\\n\\\nuniform vec2 lineOffset;\\n\\\n\\n\\\nczm_material czm_getMaterial(czm_materialInput materialInput)\\n\\\n{\\n\\\n    czm_material material = czm_getDefaultMaterial(materialInput);\\n\\\n\\n\\\n    vec2 st = materialInput.st;\\n\\\n\\n\\\n    float scaledWidth = fract(lineCount.s * st.s - lineOffset.s);\\n\\\n    scaledWidth = abs(scaledWidth - floor(scaledWidth + 0.5));\\n\\\n    float scaledHeight = fract(lineCount.t * st.t - lineOffset.t);\\n\\\n    scaledHeight = abs(scaledHeight - floor(scaledHeight + 0.5));\\n\\\n\\n\\\n    float value;\\n\\\n#ifdef GL_OES_standard_derivatives\\n\\\n    // Fuzz Factor - Controls blurriness of lines\\n\\\n    const float fuzz = 1.2;\\n\\\n    vec2 thickness = (lineThickness * czm_pixelRatio) - 1.0;\\n\\\n\\n\\\n    // From \\"3D Engine Design for Virtual Globes\\" by Cozzi and Ring, Listing 4.13.\\n\\\n    vec2 dx = abs(dFdx(st));\\n\\\n    vec2 dy = abs(dFdy(st));\\n\\\n    vec2 dF = vec2(max(dx.s, dy.s), max(dx.t, dy.t)) * lineCount;\\n\\\n    value = min(\\n\\\n        smoothstep(dF.s * thickness.s, dF.s * (fuzz + thickness.s), scaledWidth),\\n\\\n        smoothstep(dF.t * thickness.t, dF.t * (fuzz + thickness.t), scaledHeight));\\n\\\n#else\\n\\\n    // Fuzz Factor - Controls blurriness of lines\\n\\\n    const float fuzz = 0.05;\\n\\\n\\n\\\n    vec2 range = 0.5 - (lineThickness * 0.05);\\n\\\n    value = min(\\n\\\n        1.0 - smoothstep(range.s, range.s + fuzz, scaledWidth),\\n\\\n        1.0 - smoothstep(range.t, range.t + fuzz, scaledHeight));\\n\\\n#endif\\n\\\n\\n\\\n    // Edges taken from RimLightingMaterial.glsl\\n\\\n    // See http://www.fundza.com/rman_shaders/surface/fake_rim/fake_rim1.html\\n\\\n    float dRim = 1.0 - abs(dot(materialInput.normalEC, normalize(materialInput.positionToEyeEC)));\\n\\\n    float sRim = smoothstep(0.8, 1.0, dRim);\\n\\\n    value *= (1.0 - sRim);\\n\\\n\\n\\\n    vec4 halfColor;\\n\\\n    halfColor.rgb = color.rgb * 0.5;\\n\\\n    halfColor.a = color.a * (1.0 - ((1.0 - cellAlpha) * value));\\n\\\n    halfColor = czm_gammaCorrect(halfColor);\\n\\\n    material.diffuse = halfColor.rgb;\\n\\\n    material.emission = halfColor.rgb;\\n\\\n    material.alpha = halfColor.a;\\n\\\n\\n\\\n    return material;\\n\\\n}\\n\\\n");\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTg1OTUuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQSx5REFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQix3QkFBd0I7QUFDeEIsdUJBQXVCO0FBQ3ZCLDJCQUEyQjtBQUMzQix3QkFBd0I7QUFDeEI7QUFDQTtBQUNBLENBQUM7QUFDRCxrRUFBa0U7QUFDbEU7QUFDQSwrQkFBK0I7QUFDL0I7QUFDQSxpRUFBaUU7QUFDakUsOERBQThEO0FBQzlELGtFQUFrRTtBQUNsRSxpRUFBaUU7QUFDakU7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQiw0REFBNEQ7QUFDNUQ7QUFDQTtBQUNBLDRCQUE0QjtBQUM1Qiw0QkFBNEI7QUFDNUIsaUVBQWlFO0FBQ2pFO0FBQ0E7QUFDQSxtRkFBbUY7QUFDbkY7QUFDQTtBQUNBLDRCQUE0QjtBQUM1QjtBQUNBLDhDQUE4QztBQUM5QztBQUNBO0FBQ0EsaUVBQWlFO0FBQ2pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0dBQWtHO0FBQ2xHLDRDQUE0QztBQUM1QywwQkFBMEI7QUFDMUI7QUFDQSxtQkFBbUI7QUFDbkIsb0NBQW9DO0FBQ3BDLGdFQUFnRTtBQUNoRSw0Q0FBNEM7QUFDNUMscUNBQXFDO0FBQ3JDLHNDQUFzQztBQUN0QyxpQ0FBaUM7QUFDakM7QUFDQSxvQkFBb0I7QUFDcEIsQ0FBQztBQUNELENBQUMsRUFBQyIsInNvdXJjZXMiOlsid2VicGFjazovL3Z1ZTMtd2VicGFjazUvLi9ub2RlX21vZHVsZXMvY2VzaXVtL1NvdXJjZS9TaGFkZXJzL01hdGVyaWFscy9HcmlkTWF0ZXJpYWwuanM/NTdjZiJdLCJzb3VyY2VzQ29udGVudCI6WyIvL1RoaXMgZmlsZSBpcyBhdXRvbWF0aWNhbGx5IHJlYnVpbHQgYnkgdGhlIENlc2l1bSBidWlsZCBwcm9jZXNzLlxuZXhwb3J0IGRlZmF1bHQgXCIjaWZkZWYgR0xfT0VTX3N0YW5kYXJkX2Rlcml2YXRpdmVzXFxuXFxcbiAgICAjZXh0ZW5zaW9uIEdMX09FU19zdGFuZGFyZF9kZXJpdmF0aXZlcyA6IGVuYWJsZVxcblxcXG4jZW5kaWZcXG5cXFxuXFxuXFxcbnVuaWZvcm0gdmVjNCBjb2xvcjtcXG5cXFxudW5pZm9ybSBmbG9hdCBjZWxsQWxwaGE7XFxuXFxcbnVuaWZvcm0gdmVjMiBsaW5lQ291bnQ7XFxuXFxcbnVuaWZvcm0gdmVjMiBsaW5lVGhpY2tuZXNzO1xcblxcXG51bmlmb3JtIHZlYzIgbGluZU9mZnNldDtcXG5cXFxuXFxuXFxcbmN6bV9tYXRlcmlhbCBjem1fZ2V0TWF0ZXJpYWwoY3ptX21hdGVyaWFsSW5wdXQgbWF0ZXJpYWxJbnB1dClcXG5cXFxue1xcblxcXG4gICAgY3ptX21hdGVyaWFsIG1hdGVyaWFsID0gY3ptX2dldERlZmF1bHRNYXRlcmlhbChtYXRlcmlhbElucHV0KTtcXG5cXFxuXFxuXFxcbiAgICB2ZWMyIHN0ID0gbWF0ZXJpYWxJbnB1dC5zdDtcXG5cXFxuXFxuXFxcbiAgICBmbG9hdCBzY2FsZWRXaWR0aCA9IGZyYWN0KGxpbmVDb3VudC5zICogc3QucyAtIGxpbmVPZmZzZXQucyk7XFxuXFxcbiAgICBzY2FsZWRXaWR0aCA9IGFicyhzY2FsZWRXaWR0aCAtIGZsb29yKHNjYWxlZFdpZHRoICsgMC41KSk7XFxuXFxcbiAgICBmbG9hdCBzY2FsZWRIZWlnaHQgPSBmcmFjdChsaW5lQ291bnQudCAqIHN0LnQgLSBsaW5lT2Zmc2V0LnQpO1xcblxcXG4gICAgc2NhbGVkSGVpZ2h0ID0gYWJzKHNjYWxlZEhlaWdodCAtIGZsb29yKHNjYWxlZEhlaWdodCArIDAuNSkpO1xcblxcXG5cXG5cXFxuICAgIGZsb2F0IHZhbHVlO1xcblxcXG4jaWZkZWYgR0xfT0VTX3N0YW5kYXJkX2Rlcml2YXRpdmVzXFxuXFxcbiAgICAvLyBGdXp6IEZhY3RvciAtIENvbnRyb2xzIGJsdXJyaW5lc3Mgb2YgbGluZXNcXG5cXFxuICAgIGNvbnN0IGZsb2F0IGZ1enogPSAxLjI7XFxuXFxcbiAgICB2ZWMyIHRoaWNrbmVzcyA9IChsaW5lVGhpY2tuZXNzICogY3ptX3BpeGVsUmF0aW8pIC0gMS4wO1xcblxcXG5cXG5cXFxuICAgIC8vIEZyb20gXFxcIjNEIEVuZ2luZSBEZXNpZ24gZm9yIFZpcnR1YWwgR2xvYmVzXFxcIiBieSBDb3p6aSBhbmQgUmluZywgTGlzdGluZyA0LjEzLlxcblxcXG4gICAgdmVjMiBkeCA9IGFicyhkRmR4KHN0KSk7XFxuXFxcbiAgICB2ZWMyIGR5ID0gYWJzKGRGZHkoc3QpKTtcXG5cXFxuICAgIHZlYzIgZEYgPSB2ZWMyKG1heChkeC5zLCBkeS5zKSwgbWF4KGR4LnQsIGR5LnQpKSAqIGxpbmVDb3VudDtcXG5cXFxuICAgIHZhbHVlID0gbWluKFxcblxcXG4gICAgICAgIHNtb290aHN0ZXAoZEYucyAqIHRoaWNrbmVzcy5zLCBkRi5zICogKGZ1enogKyB0aGlja25lc3MucyksIHNjYWxlZFdpZHRoKSxcXG5cXFxuICAgICAgICBzbW9vdGhzdGVwKGRGLnQgKiB0aGlja25lc3MudCwgZEYudCAqIChmdXp6ICsgdGhpY2tuZXNzLnQpLCBzY2FsZWRIZWlnaHQpKTtcXG5cXFxuI2Vsc2VcXG5cXFxuICAgIC8vIEZ1enogRmFjdG9yIC0gQ29udHJvbHMgYmx1cnJpbmVzcyBvZiBsaW5lc1xcblxcXG4gICAgY29uc3QgZmxvYXQgZnV6eiA9IDAuMDU7XFxuXFxcblxcblxcXG4gICAgdmVjMiByYW5nZSA9IDAuNSAtIChsaW5lVGhpY2tuZXNzICogMC4wNSk7XFxuXFxcbiAgICB2YWx1ZSA9IG1pbihcXG5cXFxuICAgICAgICAxLjAgLSBzbW9vdGhzdGVwKHJhbmdlLnMsIHJhbmdlLnMgKyBmdXp6LCBzY2FsZWRXaWR0aCksXFxuXFxcbiAgICAgICAgMS4wIC0gc21vb3Roc3RlcChyYW5nZS50LCByYW5nZS50ICsgZnV6eiwgc2NhbGVkSGVpZ2h0KSk7XFxuXFxcbiNlbmRpZlxcblxcXG5cXG5cXFxuICAgIC8vIEVkZ2VzIHRha2VuIGZyb20gUmltTGlnaHRpbmdNYXRlcmlhbC5nbHNsXFxuXFxcbiAgICAvLyBTZWUgaHR0cDovL3d3dy5mdW5kemEuY29tL3JtYW5fc2hhZGVycy9zdXJmYWNlL2Zha2VfcmltL2Zha2VfcmltMS5odG1sXFxuXFxcbiAgICBmbG9hdCBkUmltID0gMS4wIC0gYWJzKGRvdChtYXRlcmlhbElucHV0Lm5vcm1hbEVDLCBub3JtYWxpemUobWF0ZXJpYWxJbnB1dC5wb3NpdGlvblRvRXllRUMpKSk7XFxuXFxcbiAgICBmbG9hdCBzUmltID0gc21vb3Roc3RlcCgwLjgsIDEuMCwgZFJpbSk7XFxuXFxcbiAgICB2YWx1ZSAqPSAoMS4wIC0gc1JpbSk7XFxuXFxcblxcblxcXG4gICAgdmVjNCBoYWxmQ29sb3I7XFxuXFxcbiAgICBoYWxmQ29sb3IucmdiID0gY29sb3IucmdiICogMC41O1xcblxcXG4gICAgaGFsZkNvbG9yLmEgPSBjb2xvci5hICogKDEuMCAtICgoMS4wIC0gY2VsbEFscGhhKSAqIHZhbHVlKSk7XFxuXFxcbiAgICBoYWxmQ29sb3IgPSBjem1fZ2FtbWFDb3JyZWN0KGhhbGZDb2xvcik7XFxuXFxcbiAgICBtYXRlcmlhbC5kaWZmdXNlID0gaGFsZkNvbG9yLnJnYjtcXG5cXFxuICAgIG1hdGVyaWFsLmVtaXNzaW9uID0gaGFsZkNvbG9yLnJnYjtcXG5cXFxuICAgIG1hdGVyaWFsLmFscGhhID0gaGFsZkNvbG9yLmE7XFxuXFxcblxcblxcXG4gICAgcmV0dXJuIG1hdGVyaWFsO1xcblxcXG59XFxuXFxcblwiO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///18595\n')},19431:function(__unused_webpack___webpack_module__,__webpack_exports__){eval('//This file is automatically rebuilt by the Cesium build process.\n/* harmony default export */ __webpack_exports__["Z"] = ("uniform sampler2D image;\\n\\\nuniform float strength;\\n\\\nuniform vec2 repeat;\\n\\\n\\n\\\nczm_material czm_getMaterial(czm_materialInput materialInput)\\n\\\n{\\n\\\n    czm_material material = czm_getDefaultMaterial(materialInput);\\n\\\n    \\n\\\n    vec4 textureValue = texture2D(image, fract(repeat * materialInput.st));\\n\\\n    vec3 normalTangentSpace = textureValue.channels;\\n\\\n    normalTangentSpace.xy = normalTangentSpace.xy * 2.0 - 1.0;\\n\\\n    normalTangentSpace.z = clamp(1.0 - strength, 0.1, 1.0);\\n\\\n    normalTangentSpace = normalize(normalTangentSpace);\\n\\\n    vec3 normalEC = materialInput.tangentToEyeMatrix * normalTangentSpace;\\n\\\n    \\n\\\n    material.normal = normalEC;\\n\\\n    \\n\\\n    return material;\\n\\\n}\\n\\\n");\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTk0MzEuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQSx5REFBZSx5QkFBeUI7QUFDeEMsdUJBQXVCO0FBQ3ZCLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0EsQ0FBQztBQUNELGtFQUFrRTtBQUNsRTtBQUNBLDJFQUEyRTtBQUMzRSxvREFBb0Q7QUFDcEQsOERBQThEO0FBQzlELDJEQUEyRDtBQUMzRCx1REFBdUQ7QUFDdkQsMEVBQTBFO0FBQzFFO0FBQ0EsK0JBQStCO0FBQy9CO0FBQ0Esb0JBQW9CO0FBQ3BCLENBQUM7QUFDRCxDQUFDLEVBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly92dWUzLXdlYnBhY2s1Ly4vbm9kZV9tb2R1bGVzL2Nlc2l1bS9Tb3VyY2UvU2hhZGVycy9NYXRlcmlhbHMvTm9ybWFsTWFwTWF0ZXJpYWwuanM/MzBjOCJdLCJzb3VyY2VzQ29udGVudCI6WyIvL1RoaXMgZmlsZSBpcyBhdXRvbWF0aWNhbGx5IHJlYnVpbHQgYnkgdGhlIENlc2l1bSBidWlsZCBwcm9jZXNzLlxuZXhwb3J0IGRlZmF1bHQgXCJ1bmlmb3JtIHNhbXBsZXIyRCBpbWFnZTtcXG5cXFxudW5pZm9ybSBmbG9hdCBzdHJlbmd0aDtcXG5cXFxudW5pZm9ybSB2ZWMyIHJlcGVhdDtcXG5cXFxuXFxuXFxcbmN6bV9tYXRlcmlhbCBjem1fZ2V0TWF0ZXJpYWwoY3ptX21hdGVyaWFsSW5wdXQgbWF0ZXJpYWxJbnB1dClcXG5cXFxue1xcblxcXG4gICAgY3ptX21hdGVyaWFsIG1hdGVyaWFsID0gY3ptX2dldERlZmF1bHRNYXRlcmlhbChtYXRlcmlhbElucHV0KTtcXG5cXFxuICAgIFxcblxcXG4gICAgdmVjNCB0ZXh0dXJlVmFsdWUgPSB0ZXh0dXJlMkQoaW1hZ2UsIGZyYWN0KHJlcGVhdCAqIG1hdGVyaWFsSW5wdXQuc3QpKTtcXG5cXFxuICAgIHZlYzMgbm9ybWFsVGFuZ2VudFNwYWNlID0gdGV4dHVyZVZhbHVlLmNoYW5uZWxzO1xcblxcXG4gICAgbm9ybWFsVGFuZ2VudFNwYWNlLnh5ID0gbm9ybWFsVGFuZ2VudFNwYWNlLnh5ICogMi4wIC0gMS4wO1xcblxcXG4gICAgbm9ybWFsVGFuZ2VudFNwYWNlLnogPSBjbGFtcCgxLjAgLSBzdHJlbmd0aCwgMC4xLCAxLjApO1xcblxcXG4gICAgbm9ybWFsVGFuZ2VudFNwYWNlID0gbm9ybWFsaXplKG5vcm1hbFRhbmdlbnRTcGFjZSk7XFxuXFxcbiAgICB2ZWMzIG5vcm1hbEVDID0gbWF0ZXJpYWxJbnB1dC50YW5nZW50VG9FeWVNYXRyaXggKiBub3JtYWxUYW5nZW50U3BhY2U7XFxuXFxcbiAgICBcXG5cXFxuICAgIG1hdGVyaWFsLm5vcm1hbCA9IG5vcm1hbEVDO1xcblxcXG4gICAgXFxuXFxcbiAgICByZXR1cm4gbWF0ZXJpYWw7XFxuXFxcbn1cXG5cXFxuXCI7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///19431\n')},81699:function(__unused_webpack___webpack_module__,__webpack_exports__){eval('//This file is automatically rebuilt by the Cesium build process.\n/* harmony default export */ __webpack_exports__["Z"] = ("#ifdef GL_OES_standard_derivatives\\n\\\n#extension GL_OES_standard_derivatives : enable\\n\\\n#endif\\n\\\n\\n\\\nuniform vec4 color;\\n\\\n\\n\\\nfloat getPointOnLine(vec2 p0, vec2 p1, float x)\\n\\\n{\\n\\\n    float slope = (p0.y - p1.y) / (p0.x - p1.x);\\n\\\n    return slope * (x - p0.x) + p0.y;\\n\\\n}\\n\\\n\\n\\\nczm_material czm_getMaterial(czm_materialInput materialInput)\\n\\\n{\\n\\\n    czm_material material = czm_getDefaultMaterial(materialInput);\\n\\\n\\n\\\n    vec2 st = materialInput.st;\\n\\\n\\n\\\n#ifdef GL_OES_standard_derivatives\\n\\\n    float base = 1.0 - abs(fwidth(st.s)) * 10.0 * czm_pixelRatio;\\n\\\n#else\\n\\\n    float base = 0.975; // 2.5% of the line will be the arrow head\\n\\\n#endif\\n\\\n\\n\\\n    vec2 center = vec2(1.0, 0.5);\\n\\\n    float ptOnUpperLine = getPointOnLine(vec2(base, 1.0), center, st.s);\\n\\\n    float ptOnLowerLine = getPointOnLine(vec2(base, 0.0), center, st.s);\\n\\\n\\n\\\n    float halfWidth = 0.15;\\n\\\n    float s = step(0.5 - halfWidth, st.t);\\n\\\n    s *= 1.0 - step(0.5 + halfWidth, st.t);\\n\\\n    s *= 1.0 - step(base, st.s);\\n\\\n\\n\\\n    float t = step(base, materialInput.st.s);\\n\\\n    t *= 1.0 - step(ptOnUpperLine, st.t);\\n\\\n    t *= step(ptOnLowerLine, st.t);\\n\\\n\\n\\\n    // Find the distance from the closest separator (region between two colors)\\n\\\n    float dist;\\n\\\n    if (st.s < base)\\n\\\n    {\\n\\\n        float d1 = abs(st.t - (0.5 - halfWidth));\\n\\\n        float d2 = abs(st.t - (0.5 + halfWidth));\\n\\\n        dist = min(d1, d2);\\n\\\n    }\\n\\\n    else\\n\\\n    {\\n\\\n        float d1 = czm_infinity;\\n\\\n        if (st.t < 0.5 - halfWidth && st.t > 0.5 + halfWidth)\\n\\\n        {\\n\\\n            d1 = abs(st.s - base);\\n\\\n        }\\n\\\n        float d2 = abs(st.t - ptOnUpperLine);\\n\\\n        float d3 = abs(st.t - ptOnLowerLine);\\n\\\n        dist = min(min(d1, d2), d3);\\n\\\n    }\\n\\\n\\n\\\n    vec4 outsideColor = vec4(0.0);\\n\\\n    vec4 currentColor = mix(outsideColor, color, clamp(s + t, 0.0, 1.0));\\n\\\n    vec4 outColor = czm_antialias(outsideColor, color, currentColor, dist);\\n\\\n\\n\\\n    outColor = czm_gammaCorrect(outColor);\\n\\\n    material.diffuse = outColor.rgb;\\n\\\n    material.alpha = outColor.a;\\n\\\n    return material;\\n\\\n}\\n\\\n");\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiODE2OTkuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQSx5REFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0EsQ0FBQztBQUNELGdEQUFnRDtBQUNoRCxxQ0FBcUM7QUFDckMsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Qsa0VBQWtFO0FBQ2xFO0FBQ0EsK0JBQStCO0FBQy9CO0FBQ0E7QUFDQSxpRUFBaUU7QUFDakU7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBLGlDQUFpQztBQUNqQyx3RUFBd0U7QUFDeEUsd0VBQXdFO0FBQ3hFO0FBQ0EsMkJBQTJCO0FBQzNCLDBDQUEwQztBQUMxQywyQ0FBMkM7QUFDM0MsZ0NBQWdDO0FBQ2hDO0FBQ0EsNkNBQTZDO0FBQzdDLHlDQUF5QztBQUN6QyxtQ0FBbUM7QUFDbkM7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBLEtBQUs7QUFDTCxpREFBaUQ7QUFDakQsaURBQWlEO0FBQ2pELDJCQUEyQjtBQUMzQixLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0wsZ0NBQWdDO0FBQ2hDO0FBQ0EsU0FBUztBQUNULGtDQUFrQztBQUNsQyxTQUFTO0FBQ1QsNkNBQTZDO0FBQzdDLDZDQUE2QztBQUM3QyxvQ0FBb0M7QUFDcEMsS0FBSztBQUNMO0FBQ0Esa0NBQWtDO0FBQ2xDLHlFQUF5RTtBQUN6RSwyRUFBMkU7QUFDM0U7QUFDQSwwQ0FBMEM7QUFDMUMsb0NBQW9DO0FBQ3BDLGdDQUFnQztBQUNoQyxvQkFBb0I7QUFDcEIsQ0FBQztBQUNELENBQUMsRUFBQyIsInNvdXJjZXMiOlsid2VicGFjazovL3Z1ZTMtd2VicGFjazUvLi9ub2RlX21vZHVsZXMvY2VzaXVtL1NvdXJjZS9TaGFkZXJzL01hdGVyaWFscy9Qb2x5bGluZUFycm93TWF0ZXJpYWwuanM/YzhlYSJdLCJzb3VyY2VzQ29udGVudCI6WyIvL1RoaXMgZmlsZSBpcyBhdXRvbWF0aWNhbGx5IHJlYnVpbHQgYnkgdGhlIENlc2l1bSBidWlsZCBwcm9jZXNzLlxuZXhwb3J0IGRlZmF1bHQgXCIjaWZkZWYgR0xfT0VTX3N0YW5kYXJkX2Rlcml2YXRpdmVzXFxuXFxcbiNleHRlbnNpb24gR0xfT0VTX3N0YW5kYXJkX2Rlcml2YXRpdmVzIDogZW5hYmxlXFxuXFxcbiNlbmRpZlxcblxcXG5cXG5cXFxudW5pZm9ybSB2ZWM0IGNvbG9yO1xcblxcXG5cXG5cXFxuZmxvYXQgZ2V0UG9pbnRPbkxpbmUodmVjMiBwMCwgdmVjMiBwMSwgZmxvYXQgeClcXG5cXFxue1xcblxcXG4gICAgZmxvYXQgc2xvcGUgPSAocDAueSAtIHAxLnkpIC8gKHAwLnggLSBwMS54KTtcXG5cXFxuICAgIHJldHVybiBzbG9wZSAqICh4IC0gcDAueCkgKyBwMC55O1xcblxcXG59XFxuXFxcblxcblxcXG5jem1fbWF0ZXJpYWwgY3ptX2dldE1hdGVyaWFsKGN6bV9tYXRlcmlhbElucHV0IG1hdGVyaWFsSW5wdXQpXFxuXFxcbntcXG5cXFxuICAgIGN6bV9tYXRlcmlhbCBtYXRlcmlhbCA9IGN6bV9nZXREZWZhdWx0TWF0ZXJpYWwobWF0ZXJpYWxJbnB1dCk7XFxuXFxcblxcblxcXG4gICAgdmVjMiBzdCA9IG1hdGVyaWFsSW5wdXQuc3Q7XFxuXFxcblxcblxcXG4jaWZkZWYgR0xfT0VTX3N0YW5kYXJkX2Rlcml2YXRpdmVzXFxuXFxcbiAgICBmbG9hdCBiYXNlID0gMS4wIC0gYWJzKGZ3aWR0aChzdC5zKSkgKiAxMC4wICogY3ptX3BpeGVsUmF0aW87XFxuXFxcbiNlbHNlXFxuXFxcbiAgICBmbG9hdCBiYXNlID0gMC45NzU7IC8vIDIuNSUgb2YgdGhlIGxpbmUgd2lsbCBiZSB0aGUgYXJyb3cgaGVhZFxcblxcXG4jZW5kaWZcXG5cXFxuXFxuXFxcbiAgICB2ZWMyIGNlbnRlciA9IHZlYzIoMS4wLCAwLjUpO1xcblxcXG4gICAgZmxvYXQgcHRPblVwcGVyTGluZSA9IGdldFBvaW50T25MaW5lKHZlYzIoYmFzZSwgMS4wKSwgY2VudGVyLCBzdC5zKTtcXG5cXFxuICAgIGZsb2F0IHB0T25Mb3dlckxpbmUgPSBnZXRQb2ludE9uTGluZSh2ZWMyKGJhc2UsIDAuMCksIGNlbnRlciwgc3Qucyk7XFxuXFxcblxcblxcXG4gICAgZmxvYXQgaGFsZldpZHRoID0gMC4xNTtcXG5cXFxuICAgIGZsb2F0IHMgPSBzdGVwKDAuNSAtIGhhbGZXaWR0aCwgc3QudCk7XFxuXFxcbiAgICBzICo9IDEuMCAtIHN0ZXAoMC41ICsgaGFsZldpZHRoLCBzdC50KTtcXG5cXFxuICAgIHMgKj0gMS4wIC0gc3RlcChiYXNlLCBzdC5zKTtcXG5cXFxuXFxuXFxcbiAgICBmbG9hdCB0ID0gc3RlcChiYXNlLCBtYXRlcmlhbElucHV0LnN0LnMpO1xcblxcXG4gICAgdCAqPSAxLjAgLSBzdGVwKHB0T25VcHBlckxpbmUsIHN0LnQpO1xcblxcXG4gICAgdCAqPSBzdGVwKHB0T25Mb3dlckxpbmUsIHN0LnQpO1xcblxcXG5cXG5cXFxuICAgIC8vIEZpbmQgdGhlIGRpc3RhbmNlIGZyb20gdGhlIGNsb3Nlc3Qgc2VwYXJhdG9yIChyZWdpb24gYmV0d2VlbiB0d28gY29sb3JzKVxcblxcXG4gICAgZmxvYXQgZGlzdDtcXG5cXFxuICAgIGlmIChzdC5zIDwgYmFzZSlcXG5cXFxuICAgIHtcXG5cXFxuICAgICAgICBmbG9hdCBkMSA9IGFicyhzdC50IC0gKDAuNSAtIGhhbGZXaWR0aCkpO1xcblxcXG4gICAgICAgIGZsb2F0IGQyID0gYWJzKHN0LnQgLSAoMC41ICsgaGFsZldpZHRoKSk7XFxuXFxcbiAgICAgICAgZGlzdCA9IG1pbihkMSwgZDIpO1xcblxcXG4gICAgfVxcblxcXG4gICAgZWxzZVxcblxcXG4gICAge1xcblxcXG4gICAgICAgIGZsb2F0IGQxID0gY3ptX2luZmluaXR5O1xcblxcXG4gICAgICAgIGlmIChzdC50IDwgMC41IC0gaGFsZldpZHRoICYmIHN0LnQgPiAwLjUgKyBoYWxmV2lkdGgpXFxuXFxcbiAgICAgICAge1xcblxcXG4gICAgICAgICAgICBkMSA9IGFicyhzdC5zIC0gYmFzZSk7XFxuXFxcbiAgICAgICAgfVxcblxcXG4gICAgICAgIGZsb2F0IGQyID0gYWJzKHN0LnQgLSBwdE9uVXBwZXJMaW5lKTtcXG5cXFxuICAgICAgICBmbG9hdCBkMyA9IGFicyhzdC50IC0gcHRPbkxvd2VyTGluZSk7XFxuXFxcbiAgICAgICAgZGlzdCA9IG1pbihtaW4oZDEsIGQyKSwgZDMpO1xcblxcXG4gICAgfVxcblxcXG5cXG5cXFxuICAgIHZlYzQgb3V0c2lkZUNvbG9yID0gdmVjNCgwLjApO1xcblxcXG4gICAgdmVjNCBjdXJyZW50Q29sb3IgPSBtaXgob3V0c2lkZUNvbG9yLCBjb2xvciwgY2xhbXAocyArIHQsIDAuMCwgMS4wKSk7XFxuXFxcbiAgICB2ZWM0IG91dENvbG9yID0gY3ptX2FudGlhbGlhcyhvdXRzaWRlQ29sb3IsIGNvbG9yLCBjdXJyZW50Q29sb3IsIGRpc3QpO1xcblxcXG5cXG5cXFxuICAgIG91dENvbG9yID0gY3ptX2dhbW1hQ29ycmVjdChvdXRDb2xvcik7XFxuXFxcbiAgICBtYXRlcmlhbC5kaWZmdXNlID0gb3V0Q29sb3IucmdiO1xcblxcXG4gICAgbWF0ZXJpYWwuYWxwaGEgPSBvdXRDb2xvci5hO1xcblxcXG4gICAgcmV0dXJuIG1hdGVyaWFsO1xcblxcXG59XFxuXFxcblwiO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///81699\n')},24291:function(__unused_webpack___webpack_module__,__webpack_exports__){eval('//This file is automatically rebuilt by the Cesium build process.\n/* harmony default export */ __webpack_exports__["Z"] = ("uniform vec4 color;\\n\\\nuniform vec4 gapColor;\\n\\\nuniform float dashLength;\\n\\\nuniform float dashPattern;\\n\\\nvarying float v_polylineAngle;\\n\\\n\\n\\\nconst float maskLength = 16.0;\\n\\\n\\n\\\nmat2 rotate(float rad) {\\n\\\n    float c = cos(rad);\\n\\\n    float s = sin(rad);\\n\\\n    return mat2(\\n\\\n        c, s,\\n\\\n        -s, c\\n\\\n    );\\n\\\n}\\n\\\n\\n\\\nczm_material czm_getMaterial(czm_materialInput materialInput)\\n\\\n{\\n\\\n    czm_material material = czm_getDefaultMaterial(materialInput);\\n\\\n\\n\\\n    vec2 pos = rotate(v_polylineAngle) * gl_FragCoord.xy;\\n\\\n\\n\\\n    // Get the relative position within the dash from 0 to 1\\n\\\n    float dashPosition = fract(pos.x / (dashLength * czm_pixelRatio));\\n\\\n    // Figure out the mask index.\\n\\\n    float maskIndex = floor(dashPosition * maskLength);\\n\\\n    // Test the bit mask.\\n\\\n    float maskTest = floor(dashPattern / pow(2.0, maskIndex));\\n\\\n    vec4 fragColor = (mod(maskTest, 2.0) < 1.0) ? gapColor : color;\\n\\\n    if (fragColor.a < 0.005) {   // matches 0/255 and 1/255\\n\\\n        discard;\\n\\\n    }\\n\\\n\\n\\\n    fragColor = czm_gammaCorrect(fragColor);\\n\\\n    material.emission = fragColor.rgb;\\n\\\n    material.alpha = fragColor.a;\\n\\\n    return material;\\n\\\n}\\n\\\n");\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjQyOTEuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQSx5REFBZSxvQkFBb0I7QUFDbkMsc0JBQXNCO0FBQ3RCLHlCQUF5QjtBQUN6QiwwQkFBMEI7QUFDMUIsOEJBQThCO0FBQzlCO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0Esd0JBQXdCO0FBQ3hCLHVCQUF1QjtBQUN2Qix1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNELGtFQUFrRTtBQUNsRTtBQUNBLHlEQUF5RDtBQUN6RDtBQUNBO0FBQ0Esc0VBQXNFO0FBQ3RFO0FBQ0EsdURBQXVEO0FBQ3ZEO0FBQ0EsOERBQThEO0FBQzlELG1FQUFtRTtBQUNuRSxpQ0FBaUM7QUFDakMsZ0JBQWdCO0FBQ2hCLEtBQUs7QUFDTDtBQUNBLDRDQUE0QztBQUM1QyxzQ0FBc0M7QUFDdEMsaUNBQWlDO0FBQ2pDLG9CQUFvQjtBQUNwQixDQUFDO0FBQ0QsQ0FBQyxFQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdnVlMy13ZWJwYWNrNS8uL25vZGVfbW9kdWxlcy9jZXNpdW0vU291cmNlL1NoYWRlcnMvTWF0ZXJpYWxzL1BvbHlsaW5lRGFzaE1hdGVyaWFsLmpzP2UzMjEiXSwic291cmNlc0NvbnRlbnQiOlsiLy9UaGlzIGZpbGUgaXMgYXV0b21hdGljYWxseSByZWJ1aWx0IGJ5IHRoZSBDZXNpdW0gYnVpbGQgcHJvY2Vzcy5cbmV4cG9ydCBkZWZhdWx0IFwidW5pZm9ybSB2ZWM0IGNvbG9yO1xcblxcXG51bmlmb3JtIHZlYzQgZ2FwQ29sb3I7XFxuXFxcbnVuaWZvcm0gZmxvYXQgZGFzaExlbmd0aDtcXG5cXFxudW5pZm9ybSBmbG9hdCBkYXNoUGF0dGVybjtcXG5cXFxudmFyeWluZyBmbG9hdCB2X3BvbHlsaW5lQW5nbGU7XFxuXFxcblxcblxcXG5jb25zdCBmbG9hdCBtYXNrTGVuZ3RoID0gMTYuMDtcXG5cXFxuXFxuXFxcbm1hdDIgcm90YXRlKGZsb2F0IHJhZCkge1xcblxcXG4gICAgZmxvYXQgYyA9IGNvcyhyYWQpO1xcblxcXG4gICAgZmxvYXQgcyA9IHNpbihyYWQpO1xcblxcXG4gICAgcmV0dXJuIG1hdDIoXFxuXFxcbiAgICAgICAgYywgcyxcXG5cXFxuICAgICAgICAtcywgY1xcblxcXG4gICAgKTtcXG5cXFxufVxcblxcXG5cXG5cXFxuY3ptX21hdGVyaWFsIGN6bV9nZXRNYXRlcmlhbChjem1fbWF0ZXJpYWxJbnB1dCBtYXRlcmlhbElucHV0KVxcblxcXG57XFxuXFxcbiAgICBjem1fbWF0ZXJpYWwgbWF0ZXJpYWwgPSBjem1fZ2V0RGVmYXVsdE1hdGVyaWFsKG1hdGVyaWFsSW5wdXQpO1xcblxcXG5cXG5cXFxuICAgIHZlYzIgcG9zID0gcm90YXRlKHZfcG9seWxpbmVBbmdsZSkgKiBnbF9GcmFnQ29vcmQueHk7XFxuXFxcblxcblxcXG4gICAgLy8gR2V0IHRoZSByZWxhdGl2ZSBwb3NpdGlvbiB3aXRoaW4gdGhlIGRhc2ggZnJvbSAwIHRvIDFcXG5cXFxuICAgIGZsb2F0IGRhc2hQb3NpdGlvbiA9IGZyYWN0KHBvcy54IC8gKGRhc2hMZW5ndGggKiBjem1fcGl4ZWxSYXRpbykpO1xcblxcXG4gICAgLy8gRmlndXJlIG91dCB0aGUgbWFzayBpbmRleC5cXG5cXFxuICAgIGZsb2F0IG1hc2tJbmRleCA9IGZsb29yKGRhc2hQb3NpdGlvbiAqIG1hc2tMZW5ndGgpO1xcblxcXG4gICAgLy8gVGVzdCB0aGUgYml0IG1hc2suXFxuXFxcbiAgICBmbG9hdCBtYXNrVGVzdCA9IGZsb29yKGRhc2hQYXR0ZXJuIC8gcG93KDIuMCwgbWFza0luZGV4KSk7XFxuXFxcbiAgICB2ZWM0IGZyYWdDb2xvciA9IChtb2QobWFza1Rlc3QsIDIuMCkgPCAxLjApID8gZ2FwQ29sb3IgOiBjb2xvcjtcXG5cXFxuICAgIGlmIChmcmFnQ29sb3IuYSA8IDAuMDA1KSB7ICAgLy8gbWF0Y2hlcyAwLzI1NSBhbmQgMS8yNTVcXG5cXFxuICAgICAgICBkaXNjYXJkO1xcblxcXG4gICAgfVxcblxcXG5cXG5cXFxuICAgIGZyYWdDb2xvciA9IGN6bV9nYW1tYUNvcnJlY3QoZnJhZ0NvbG9yKTtcXG5cXFxuICAgIG1hdGVyaWFsLmVtaXNzaW9uID0gZnJhZ0NvbG9yLnJnYjtcXG5cXFxuICAgIG1hdGVyaWFsLmFscGhhID0gZnJhZ0NvbG9yLmE7XFxuXFxcbiAgICByZXR1cm4gbWF0ZXJpYWw7XFxuXFxcbn1cXG5cXFxuXCI7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///24291\n')},20126:function(__unused_webpack___webpack_module__,__webpack_exports__){eval('//This file is automatically rebuilt by the Cesium build process.\n/* harmony default export */ __webpack_exports__["Z"] = ("uniform vec4 color;\\n\\\nuniform float glowPower;\\n\\\nuniform float taperPower;\\n\\\n\\n\\\nczm_material czm_getMaterial(czm_materialInput materialInput)\\n\\\n{\\n\\\n    czm_material material = czm_getDefaultMaterial(materialInput);\\n\\\n\\n\\\n    vec2 st = materialInput.st;\\n\\\n    float glow = glowPower / abs(st.t - 0.5) - (glowPower / 0.5);\\n\\\n\\n\\\n    if (taperPower <= 0.99999) {\\n\\\n        glow *= min(1.0, taperPower / (0.5 - st.s * 0.5) - (taperPower / 0.5));\\n\\\n    }\\n\\\n\\n\\\n    vec4 fragColor;\\n\\\n    fragColor.rgb = max(vec3(glow - 1.0 + color.rgb), color.rgb);\\n\\\n    fragColor.a = clamp(0.0, 1.0, glow) * color.a;\\n\\\n    fragColor = czm_gammaCorrect(fragColor);\\n\\\n\\n\\\n    material.emission = fragColor.rgb;\\n\\\n    material.alpha = fragColor.a;\\n\\\n\\n\\\n    return material;\\n\\\n}\\n\\\n");\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjAxMjYuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQSx5REFBZSxvQkFBb0I7QUFDbkMsd0JBQXdCO0FBQ3hCLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0EsQ0FBQztBQUNELGtFQUFrRTtBQUNsRTtBQUNBLCtCQUErQjtBQUMvQixpRUFBaUU7QUFDakU7QUFDQSxnQ0FBZ0M7QUFDaEMsK0VBQStFO0FBQy9FLEtBQUs7QUFDTDtBQUNBLG1CQUFtQjtBQUNuQixpRUFBaUU7QUFDakUsa0RBQWtEO0FBQ2xELDRDQUE0QztBQUM1QztBQUNBLHNDQUFzQztBQUN0QyxpQ0FBaUM7QUFDakM7QUFDQSxvQkFBb0I7QUFDcEIsQ0FBQztBQUNELENBQUMsRUFBQyIsInNvdXJjZXMiOlsid2VicGFjazovL3Z1ZTMtd2VicGFjazUvLi9ub2RlX21vZHVsZXMvY2VzaXVtL1NvdXJjZS9TaGFkZXJzL01hdGVyaWFscy9Qb2x5bGluZUdsb3dNYXRlcmlhbC5qcz81MTY5Il0sInNvdXJjZXNDb250ZW50IjpbIi8vVGhpcyBmaWxlIGlzIGF1dG9tYXRpY2FsbHkgcmVidWlsdCBieSB0aGUgQ2VzaXVtIGJ1aWxkIHByb2Nlc3MuXG5leHBvcnQgZGVmYXVsdCBcInVuaWZvcm0gdmVjNCBjb2xvcjtcXG5cXFxudW5pZm9ybSBmbG9hdCBnbG93UG93ZXI7XFxuXFxcbnVuaWZvcm0gZmxvYXQgdGFwZXJQb3dlcjtcXG5cXFxuXFxuXFxcbmN6bV9tYXRlcmlhbCBjem1fZ2V0TWF0ZXJpYWwoY3ptX21hdGVyaWFsSW5wdXQgbWF0ZXJpYWxJbnB1dClcXG5cXFxue1xcblxcXG4gICAgY3ptX21hdGVyaWFsIG1hdGVyaWFsID0gY3ptX2dldERlZmF1bHRNYXRlcmlhbChtYXRlcmlhbElucHV0KTtcXG5cXFxuXFxuXFxcbiAgICB2ZWMyIHN0ID0gbWF0ZXJpYWxJbnB1dC5zdDtcXG5cXFxuICAgIGZsb2F0IGdsb3cgPSBnbG93UG93ZXIgLyBhYnMoc3QudCAtIDAuNSkgLSAoZ2xvd1Bvd2VyIC8gMC41KTtcXG5cXFxuXFxuXFxcbiAgICBpZiAodGFwZXJQb3dlciA8PSAwLjk5OTk5KSB7XFxuXFxcbiAgICAgICAgZ2xvdyAqPSBtaW4oMS4wLCB0YXBlclBvd2VyIC8gKDAuNSAtIHN0LnMgKiAwLjUpIC0gKHRhcGVyUG93ZXIgLyAwLjUpKTtcXG5cXFxuICAgIH1cXG5cXFxuXFxuXFxcbiAgICB2ZWM0IGZyYWdDb2xvcjtcXG5cXFxuICAgIGZyYWdDb2xvci5yZ2IgPSBtYXgodmVjMyhnbG93IC0gMS4wICsgY29sb3IucmdiKSwgY29sb3IucmdiKTtcXG5cXFxuICAgIGZyYWdDb2xvci5hID0gY2xhbXAoMC4wLCAxLjAsIGdsb3cpICogY29sb3IuYTtcXG5cXFxuICAgIGZyYWdDb2xvciA9IGN6bV9nYW1tYUNvcnJlY3QoZnJhZ0NvbG9yKTtcXG5cXFxuXFxuXFxcbiAgICBtYXRlcmlhbC5lbWlzc2lvbiA9IGZyYWdDb2xvci5yZ2I7XFxuXFxcbiAgICBtYXRlcmlhbC5hbHBoYSA9IGZyYWdDb2xvci5hO1xcblxcXG5cXG5cXFxuICAgIHJldHVybiBtYXRlcmlhbDtcXG5cXFxufVxcblxcXG5cIjtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///20126\n')},51650:function(__unused_webpack___webpack_module__,__webpack_exports__){eval('//This file is automatically rebuilt by the Cesium build process.\n/* harmony default export */ __webpack_exports__["Z"] = ("uniform vec4 color;\\n\\\nuniform vec4 outlineColor;\\n\\\nuniform float outlineWidth;\\n\\\n\\n\\\nvarying float v_width;\\n\\\n\\n\\\nczm_material czm_getMaterial(czm_materialInput materialInput)\\n\\\n{\\n\\\n    czm_material material = czm_getDefaultMaterial(materialInput);\\n\\\n\\n\\\n    vec2 st = materialInput.st;\\n\\\n    float halfInteriorWidth =  0.5 * (v_width - outlineWidth) / v_width;\\n\\\n    float b = step(0.5 - halfInteriorWidth, st.t);\\n\\\n    b *= 1.0 - step(0.5 + halfInteriorWidth, st.t);\\n\\\n\\n\\\n    // Find the distance from the closest separator (region between two colors)\\n\\\n    float d1 = abs(st.t - (0.5 - halfInteriorWidth));\\n\\\n    float d2 = abs(st.t - (0.5 + halfInteriorWidth));\\n\\\n    float dist = min(d1, d2);\\n\\\n\\n\\\n    vec4 currentColor = mix(outlineColor, color, b);\\n\\\n    vec4 outColor = czm_antialias(outlineColor, color, currentColor, dist);\\n\\\n    outColor = czm_gammaCorrect(outColor);\\n\\\n\\n\\\n    material.diffuse = outColor.rgb;\\n\\\n    material.alpha = outColor.a;\\n\\\n\\n\\\n    return material;\\n\\\n}\\n\\\n");\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNTE2NTAuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQSx5REFBZSxvQkFBb0I7QUFDbkMsMEJBQTBCO0FBQzFCLDJCQUEyQjtBQUMzQjtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0EsQ0FBQztBQUNELGtFQUFrRTtBQUNsRTtBQUNBLCtCQUErQjtBQUMvQix3RUFBd0U7QUFDeEUsa0RBQWtEO0FBQ2xELG1EQUFtRDtBQUNuRDtBQUNBO0FBQ0EscURBQXFEO0FBQ3JELHFEQUFxRDtBQUNyRCw2QkFBNkI7QUFDN0I7QUFDQSxvREFBb0Q7QUFDcEQsMkVBQTJFO0FBQzNFLDBDQUEwQztBQUMxQztBQUNBLG9DQUFvQztBQUNwQyxnQ0FBZ0M7QUFDaEM7QUFDQSxvQkFBb0I7QUFDcEIsQ0FBQztBQUNELENBQUMsRUFBQyIsInNvdXJjZXMiOlsid2VicGFjazovL3Z1ZTMtd2VicGFjazUvLi9ub2RlX21vZHVsZXMvY2VzaXVtL1NvdXJjZS9TaGFkZXJzL01hdGVyaWFscy9Qb2x5bGluZU91dGxpbmVNYXRlcmlhbC5qcz9hMzQyIl0sInNvdXJjZXNDb250ZW50IjpbIi8vVGhpcyBmaWxlIGlzIGF1dG9tYXRpY2FsbHkgcmVidWlsdCBieSB0aGUgQ2VzaXVtIGJ1aWxkIHByb2Nlc3MuXG5leHBvcnQgZGVmYXVsdCBcInVuaWZvcm0gdmVjNCBjb2xvcjtcXG5cXFxudW5pZm9ybSB2ZWM0IG91dGxpbmVDb2xvcjtcXG5cXFxudW5pZm9ybSBmbG9hdCBvdXRsaW5lV2lkdGg7XFxuXFxcblxcblxcXG52YXJ5aW5nIGZsb2F0IHZfd2lkdGg7XFxuXFxcblxcblxcXG5jem1fbWF0ZXJpYWwgY3ptX2dldE1hdGVyaWFsKGN6bV9tYXRlcmlhbElucHV0IG1hdGVyaWFsSW5wdXQpXFxuXFxcbntcXG5cXFxuICAgIGN6bV9tYXRlcmlhbCBtYXRlcmlhbCA9IGN6bV9nZXREZWZhdWx0TWF0ZXJpYWwobWF0ZXJpYWxJbnB1dCk7XFxuXFxcblxcblxcXG4gICAgdmVjMiBzdCA9IG1hdGVyaWFsSW5wdXQuc3Q7XFxuXFxcbiAgICBmbG9hdCBoYWxmSW50ZXJpb3JXaWR0aCA9ICAwLjUgKiAodl93aWR0aCAtIG91dGxpbmVXaWR0aCkgLyB2X3dpZHRoO1xcblxcXG4gICAgZmxvYXQgYiA9IHN0ZXAoMC41IC0gaGFsZkludGVyaW9yV2lkdGgsIHN0LnQpO1xcblxcXG4gICAgYiAqPSAxLjAgLSBzdGVwKDAuNSArIGhhbGZJbnRlcmlvcldpZHRoLCBzdC50KTtcXG5cXFxuXFxuXFxcbiAgICAvLyBGaW5kIHRoZSBkaXN0YW5jZSBmcm9tIHRoZSBjbG9zZXN0IHNlcGFyYXRvciAocmVnaW9uIGJldHdlZW4gdHdvIGNvbG9ycylcXG5cXFxuICAgIGZsb2F0IGQxID0gYWJzKHN0LnQgLSAoMC41IC0gaGFsZkludGVyaW9yV2lkdGgpKTtcXG5cXFxuICAgIGZsb2F0IGQyID0gYWJzKHN0LnQgLSAoMC41ICsgaGFsZkludGVyaW9yV2lkdGgpKTtcXG5cXFxuICAgIGZsb2F0IGRpc3QgPSBtaW4oZDEsIGQyKTtcXG5cXFxuXFxuXFxcbiAgICB2ZWM0IGN1cnJlbnRDb2xvciA9IG1peChvdXRsaW5lQ29sb3IsIGNvbG9yLCBiKTtcXG5cXFxuICAgIHZlYzQgb3V0Q29sb3IgPSBjem1fYW50aWFsaWFzKG91dGxpbmVDb2xvciwgY29sb3IsIGN1cnJlbnRDb2xvciwgZGlzdCk7XFxuXFxcbiAgICBvdXRDb2xvciA9IGN6bV9nYW1tYUNvcnJlY3Qob3V0Q29sb3IpO1xcblxcXG5cXG5cXFxuICAgIG1hdGVyaWFsLmRpZmZ1c2UgPSBvdXRDb2xvci5yZ2I7XFxuXFxcbiAgICBtYXRlcmlhbC5hbHBoYSA9IG91dENvbG9yLmE7XFxuXFxcblxcblxcXG4gICAgcmV0dXJuIG1hdGVyaWFsO1xcblxcXG59XFxuXFxcblwiO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///51650\n')},4164:function(__unused_webpack___webpack_module__,__webpack_exports__){eval('//This file is automatically rebuilt by the Cesium build process.\n/* harmony default export */ __webpack_exports__["Z"] = ("uniform vec4 color;\\n\\\nuniform vec4 rimColor;\\n\\\nuniform float width;\\n\\\n\\n\\\nczm_material czm_getMaterial(czm_materialInput materialInput)\\n\\\n{\\n\\\n    czm_material material = czm_getDefaultMaterial(materialInput);\\n\\\n\\n\\\n    // See http://www.fundza.com/rman_shaders/surface/fake_rim/fake_rim1.html\\n\\\n    float d = 1.0 - dot(materialInput.normalEC, normalize(materialInput.positionToEyeEC));\\n\\\n    float s = smoothstep(1.0 - width, 1.0, d);\\n\\\n\\n\\\n    vec4 outColor = czm_gammaCorrect(color);\\n\\\n    vec4 outRimColor = czm_gammaCorrect(rimColor);\\n\\\n\\n\\\n    material.diffuse = outColor.rgb;\\n\\\n    material.emission = outRimColor.rgb * s;\\n\\\n    material.alpha = mix(outColor.a, outRimColor.a, s);\\n\\\n\\n\\\n    return material;\\n\\\n}\\n\\\n");\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNDE2NC5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBLHlEQUFlLG9CQUFvQjtBQUNuQyxzQkFBc0I7QUFDdEIsb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQSxDQUFDO0FBQ0Qsa0VBQWtFO0FBQ2xFO0FBQ0E7QUFDQSwwRkFBMEY7QUFDMUYsOENBQThDO0FBQzlDO0FBQ0EsNENBQTRDO0FBQzVDLGtEQUFrRDtBQUNsRDtBQUNBLG9DQUFvQztBQUNwQyw0Q0FBNEM7QUFDNUMsdURBQXVEO0FBQ3ZEO0FBQ0Esb0JBQW9CO0FBQ3BCLENBQUM7QUFDRCxDQUFDLEVBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly92dWUzLXdlYnBhY2s1Ly4vbm9kZV9tb2R1bGVzL2Nlc2l1bS9Tb3VyY2UvU2hhZGVycy9NYXRlcmlhbHMvUmltTGlnaHRpbmdNYXRlcmlhbC5qcz9mOTM4Il0sInNvdXJjZXNDb250ZW50IjpbIi8vVGhpcyBmaWxlIGlzIGF1dG9tYXRpY2FsbHkgcmVidWlsdCBieSB0aGUgQ2VzaXVtIGJ1aWxkIHByb2Nlc3MuXG5leHBvcnQgZGVmYXVsdCBcInVuaWZvcm0gdmVjNCBjb2xvcjtcXG5cXFxudW5pZm9ybSB2ZWM0IHJpbUNvbG9yO1xcblxcXG51bmlmb3JtIGZsb2F0IHdpZHRoO1xcblxcXG5cXG5cXFxuY3ptX21hdGVyaWFsIGN6bV9nZXRNYXRlcmlhbChjem1fbWF0ZXJpYWxJbnB1dCBtYXRlcmlhbElucHV0KVxcblxcXG57XFxuXFxcbiAgICBjem1fbWF0ZXJpYWwgbWF0ZXJpYWwgPSBjem1fZ2V0RGVmYXVsdE1hdGVyaWFsKG1hdGVyaWFsSW5wdXQpO1xcblxcXG5cXG5cXFxuICAgIC8vIFNlZSBodHRwOi8vd3d3LmZ1bmR6YS5jb20vcm1hbl9zaGFkZXJzL3N1cmZhY2UvZmFrZV9yaW0vZmFrZV9yaW0xLmh0bWxcXG5cXFxuICAgIGZsb2F0IGQgPSAxLjAgLSBkb3QobWF0ZXJpYWxJbnB1dC5ub3JtYWxFQywgbm9ybWFsaXplKG1hdGVyaWFsSW5wdXQucG9zaXRpb25Ub0V5ZUVDKSk7XFxuXFxcbiAgICBmbG9hdCBzID0gc21vb3Roc3RlcCgxLjAgLSB3aWR0aCwgMS4wLCBkKTtcXG5cXFxuXFxuXFxcbiAgICB2ZWM0IG91dENvbG9yID0gY3ptX2dhbW1hQ29ycmVjdChjb2xvcik7XFxuXFxcbiAgICB2ZWM0IG91dFJpbUNvbG9yID0gY3ptX2dhbW1hQ29ycmVjdChyaW1Db2xvcik7XFxuXFxcblxcblxcXG4gICAgbWF0ZXJpYWwuZGlmZnVzZSA9IG91dENvbG9yLnJnYjtcXG5cXFxuICAgIG1hdGVyaWFsLmVtaXNzaW9uID0gb3V0UmltQ29sb3IucmdiICogcztcXG5cXFxuICAgIG1hdGVyaWFsLmFscGhhID0gbWl4KG91dENvbG9yLmEsIG91dFJpbUNvbG9yLmEsIHMpO1xcblxcXG5cXG5cXFxuICAgIHJldHVybiBtYXRlcmlhbDtcXG5cXFxufVxcblxcXG5cIjtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///4164\n')},70778:function(__unused_webpack___webpack_module__,__webpack_exports__){eval('//This file is automatically rebuilt by the Cesium build process.\n/* harmony default export */ __webpack_exports__["Z"] = ("uniform sampler2D image;\\n\\\n\\n\\\nczm_material czm_getMaterial(czm_materialInput materialInput)\\n\\\n{\\n\\\n    czm_material material = czm_getDefaultMaterial(materialInput);\\n\\\n    vec4 rampColor = texture2D(image, vec2(materialInput.slope / (czm_pi / 2.0), 0.5));\\n\\\n    rampColor = czm_gammaCorrect(rampColor);\\n\\\n    material.diffuse = rampColor.rgb;\\n\\\n    material.alpha = rampColor.a;\\n\\\n    return material;\\n\\\n}\\n\\\n");\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNzA3NzguanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQSx5REFBZSx5QkFBeUI7QUFDeEM7QUFDQTtBQUNBLENBQUM7QUFDRCxrRUFBa0U7QUFDbEUsdUZBQXVGO0FBQ3ZGLDRDQUE0QztBQUM1QyxxQ0FBcUM7QUFDckMsaUNBQWlDO0FBQ2pDLG9CQUFvQjtBQUNwQixDQUFDO0FBQ0QsQ0FBQyxFQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdnVlMy13ZWJwYWNrNS8uL25vZGVfbW9kdWxlcy9jZXNpdW0vU291cmNlL1NoYWRlcnMvTWF0ZXJpYWxzL1Nsb3BlUmFtcE1hdGVyaWFsLmpzPzM3MTkiXSwic291cmNlc0NvbnRlbnQiOlsiLy9UaGlzIGZpbGUgaXMgYXV0b21hdGljYWxseSByZWJ1aWx0IGJ5IHRoZSBDZXNpdW0gYnVpbGQgcHJvY2Vzcy5cbmV4cG9ydCBkZWZhdWx0IFwidW5pZm9ybSBzYW1wbGVyMkQgaW1hZ2U7XFxuXFxcblxcblxcXG5jem1fbWF0ZXJpYWwgY3ptX2dldE1hdGVyaWFsKGN6bV9tYXRlcmlhbElucHV0IG1hdGVyaWFsSW5wdXQpXFxuXFxcbntcXG5cXFxuICAgIGN6bV9tYXRlcmlhbCBtYXRlcmlhbCA9IGN6bV9nZXREZWZhdWx0TWF0ZXJpYWwobWF0ZXJpYWxJbnB1dCk7XFxuXFxcbiAgICB2ZWM0IHJhbXBDb2xvciA9IHRleHR1cmUyRChpbWFnZSwgdmVjMihtYXRlcmlhbElucHV0LnNsb3BlIC8gKGN6bV9waSAvIDIuMCksIDAuNSkpO1xcblxcXG4gICAgcmFtcENvbG9yID0gY3ptX2dhbW1hQ29ycmVjdChyYW1wQ29sb3IpO1xcblxcXG4gICAgbWF0ZXJpYWwuZGlmZnVzZSA9IHJhbXBDb2xvci5yZ2I7XFxuXFxcbiAgICBtYXRlcmlhbC5hbHBoYSA9IHJhbXBDb2xvci5hO1xcblxcXG4gICAgcmV0dXJuIG1hdGVyaWFsO1xcblxcXG59XFxuXFxcblwiO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///70778\n')},33931:function(__unused_webpack___webpack_module__,__webpack_exports__){eval('//This file is automatically rebuilt by the Cesium build process.\n/* harmony default export */ __webpack_exports__["Z"] = ("uniform vec4 evenColor;\\n\\\nuniform vec4 oddColor;\\n\\\nuniform float offset;\\n\\\nuniform float repeat;\\n\\\nuniform bool horizontal;\\n\\\n\\n\\\nczm_material czm_getMaterial(czm_materialInput materialInput)\\n\\\n{\\n\\\n    czm_material material = czm_getDefaultMaterial(materialInput);\\n\\\n\\n\\\n    // Based on the Stripes Fragment Shader in the Orange Book (11.1.2)\\n\\\n    float coord = mix(materialInput.st.s, materialInput.st.t, float(horizontal));\\n\\\n    float value = fract((coord - offset) * (repeat * 0.5));\\n\\\n    float dist = min(value, min(abs(value - 0.5), 1.0 - value));\\n\\\n\\n\\\n    vec4 currentColor = mix(evenColor, oddColor, step(0.5, value));\\n\\\n    vec4 color = czm_antialias(evenColor, oddColor, currentColor, dist);\\n\\\n    color = czm_gammaCorrect(color);\\n\\\n\\n\\\n    material.diffuse = color.rgb;\\n\\\n    material.alpha = color.a;\\n\\\n\\n\\\n    return material;\\n\\\n}\\n\\\n");\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMzM5MzEuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQSx5REFBZSx3QkFBd0I7QUFDdkMsc0JBQXNCO0FBQ3RCLHFCQUFxQjtBQUNyQixxQkFBcUI7QUFDckIsd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQSxDQUFDO0FBQ0Qsa0VBQWtFO0FBQ2xFO0FBQ0E7QUFDQSxpRkFBaUY7QUFDakYsMkRBQTJEO0FBQzNELGdFQUFnRTtBQUNoRTtBQUNBLG1FQUFtRTtBQUNuRSx3RUFBd0U7QUFDeEUsb0NBQW9DO0FBQ3BDO0FBQ0EsaUNBQWlDO0FBQ2pDLDZCQUE2QjtBQUM3QjtBQUNBLG9CQUFvQjtBQUNwQixDQUFDO0FBQ0QsQ0FBQyxFQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdnVlMy13ZWJwYWNrNS8uL25vZGVfbW9kdWxlcy9jZXNpdW0vU291cmNlL1NoYWRlcnMvTWF0ZXJpYWxzL1N0cmlwZU1hdGVyaWFsLmpzP2VkMDkiXSwic291cmNlc0NvbnRlbnQiOlsiLy9UaGlzIGZpbGUgaXMgYXV0b21hdGljYWxseSByZWJ1aWx0IGJ5IHRoZSBDZXNpdW0gYnVpbGQgcHJvY2Vzcy5cbmV4cG9ydCBkZWZhdWx0IFwidW5pZm9ybSB2ZWM0IGV2ZW5Db2xvcjtcXG5cXFxudW5pZm9ybSB2ZWM0IG9kZENvbG9yO1xcblxcXG51bmlmb3JtIGZsb2F0IG9mZnNldDtcXG5cXFxudW5pZm9ybSBmbG9hdCByZXBlYXQ7XFxuXFxcbnVuaWZvcm0gYm9vbCBob3Jpem9udGFsO1xcblxcXG5cXG5cXFxuY3ptX21hdGVyaWFsIGN6bV9nZXRNYXRlcmlhbChjem1fbWF0ZXJpYWxJbnB1dCBtYXRlcmlhbElucHV0KVxcblxcXG57XFxuXFxcbiAgICBjem1fbWF0ZXJpYWwgbWF0ZXJpYWwgPSBjem1fZ2V0RGVmYXVsdE1hdGVyaWFsKG1hdGVyaWFsSW5wdXQpO1xcblxcXG5cXG5cXFxuICAgIC8vIEJhc2VkIG9uIHRoZSBTdHJpcGVzIEZyYWdtZW50IFNoYWRlciBpbiB0aGUgT3JhbmdlIEJvb2sgKDExLjEuMilcXG5cXFxuICAgIGZsb2F0IGNvb3JkID0gbWl4KG1hdGVyaWFsSW5wdXQuc3QucywgbWF0ZXJpYWxJbnB1dC5zdC50LCBmbG9hdChob3Jpem9udGFsKSk7XFxuXFxcbiAgICBmbG9hdCB2YWx1ZSA9IGZyYWN0KChjb29yZCAtIG9mZnNldCkgKiAocmVwZWF0ICogMC41KSk7XFxuXFxcbiAgICBmbG9hdCBkaXN0ID0gbWluKHZhbHVlLCBtaW4oYWJzKHZhbHVlIC0gMC41KSwgMS4wIC0gdmFsdWUpKTtcXG5cXFxuXFxuXFxcbiAgICB2ZWM0IGN1cnJlbnRDb2xvciA9IG1peChldmVuQ29sb3IsIG9kZENvbG9yLCBzdGVwKDAuNSwgdmFsdWUpKTtcXG5cXFxuICAgIHZlYzQgY29sb3IgPSBjem1fYW50aWFsaWFzKGV2ZW5Db2xvciwgb2RkQ29sb3IsIGN1cnJlbnRDb2xvciwgZGlzdCk7XFxuXFxcbiAgICBjb2xvciA9IGN6bV9nYW1tYUNvcnJlY3QoY29sb3IpO1xcblxcXG5cXG5cXFxuICAgIG1hdGVyaWFsLmRpZmZ1c2UgPSBjb2xvci5yZ2I7XFxuXFxcbiAgICBtYXRlcmlhbC5hbHBoYSA9IGNvbG9yLmE7XFxuXFxcblxcblxcXG4gICAgcmV0dXJuIG1hdGVyaWFsO1xcblxcXG59XFxuXFxcblwiO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///33931\n')},72866:function(__unused_webpack___webpack_module__,__webpack_exports__){eval('//This file is automatically rebuilt by the Cesium build process.\n/* harmony default export */ __webpack_exports__["Z"] = ("// Thanks for the contribution Jonas\\n\\\n// http://29a.ch/2012/7/19/webgl-terrain-rendering-water-fog\\n\\\n\\n\\\nuniform sampler2D specularMap;\\n\\\nuniform sampler2D normalMap;\\n\\\nuniform vec4 baseWaterColor;\\n\\\nuniform vec4 blendColor;\\n\\\nuniform float frequency;\\n\\\nuniform float animationSpeed;\\n\\\nuniform float amplitude;\\n\\\nuniform float specularIntensity;\\n\\\nuniform float fadeFactor;\\n\\\n\\n\\\nczm_material czm_getMaterial(czm_materialInput materialInput)\\n\\\n{\\n\\\n    czm_material material = czm_getDefaultMaterial(materialInput);\\n\\\n\\n\\\n    float time = czm_frameNumber * animationSpeed;\\n\\\n\\n\\\n    // fade is a function of the distance from the fragment and the frequency of the waves\\n\\\n    float fade = max(1.0, (length(materialInput.positionToEyeEC) / 10000000000.0) * frequency * fadeFactor);\\n\\\n\\n\\\n    float specularMapValue = texture2D(specularMap, materialInput.st).r;\\n\\\n\\n\\\n    // note: not using directional motion at this time, just set the angle to 0.0;\\n\\\n    vec4 noise = czm_getWaterNoise(normalMap, materialInput.st * frequency, time, 0.0);\\n\\\n    vec3 normalTangentSpace = noise.xyz * vec3(1.0, 1.0, (1.0 / amplitude));\\n\\\n\\n\\\n    // fade out the normal perturbation as we move further from the water surface\\n\\\n    normalTangentSpace.xy /= fade;\\n\\\n\\n\\\n    // attempt to fade out the normal perturbation as we approach non water areas (low specular map value)\\n\\\n    normalTangentSpace = mix(vec3(0.0, 0.0, 50.0), normalTangentSpace, specularMapValue);\\n\\\n\\n\\\n    normalTangentSpace = normalize(normalTangentSpace);\\n\\\n\\n\\\n    // get ratios for alignment of the new normal vector with a vector perpendicular to the tangent plane\\n\\\n    float tsPerturbationRatio = clamp(dot(normalTangentSpace, vec3(0.0, 0.0, 1.0)), 0.0, 1.0);\\n\\\n\\n\\\n    // fade out water effect as specular map value decreases\\n\\\n    material.alpha = mix(blendColor.a, baseWaterColor.a, specularMapValue) * specularMapValue;\\n\\\n\\n\\\n    // base color is a blend of the water and non-water color based on the value from the specular map\\n\\\n    // may need a uniform blend factor to better control this\\n\\\n    material.diffuse = mix(blendColor.rgb, baseWaterColor.rgb, specularMapValue);\\n\\\n\\n\\\n    // diffuse highlights are based on how perturbed the normal is\\n\\\n    material.diffuse += (0.1 * tsPerturbationRatio);\\n\\\n\\n\\\n    material.diffuse = material.diffuse;\\n\\\n\\n\\\n    material.normal = normalize(materialInput.tangentToEyeMatrix * normalTangentSpace);\\n\\\n\\n\\\n    material.specular = specularIntensity;\\n\\\n    material.shininess = 10.0;\\n\\\n\\n\\\n    return material;\\n\\\n}\\n\\\n");\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNzI4NjYuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQSx5REFBZTtBQUNmO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUIsNEJBQTRCO0FBQzVCLDRCQUE0QjtBQUM1Qix3QkFBd0I7QUFDeEIsd0JBQXdCO0FBQ3hCLDZCQUE2QjtBQUM3Qix3QkFBd0I7QUFDeEIsZ0NBQWdDO0FBQ2hDLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0EsQ0FBQztBQUNELGtFQUFrRTtBQUNsRTtBQUNBLGtEQUFrRDtBQUNsRDtBQUNBO0FBQ0EsNEdBQTRHO0FBQzVHO0FBQ0Esd0VBQXdFO0FBQ3hFO0FBQ0Esa0ZBQWtGO0FBQ2xGLHVGQUF1RjtBQUN2Riw0RUFBNEU7QUFDNUU7QUFDQTtBQUNBLGtDQUFrQztBQUNsQztBQUNBO0FBQ0EseUZBQXlGO0FBQ3pGO0FBQ0EsdURBQXVEO0FBQ3ZEO0FBQ0E7QUFDQSw4RkFBOEY7QUFDOUY7QUFDQTtBQUNBLDhGQUE4RjtBQUM5RjtBQUNBO0FBQ0E7QUFDQSxpRkFBaUY7QUFDakY7QUFDQTtBQUNBLG9EQUFvRDtBQUNwRDtBQUNBLHdDQUF3QztBQUN4QztBQUNBLHVGQUF1RjtBQUN2RjtBQUNBLDBDQUEwQztBQUMxQyw4QkFBOEI7QUFDOUI7QUFDQSxvQkFBb0I7QUFDcEIsQ0FBQztBQUNELENBQUMsRUFBQyIsInNvdXJjZXMiOlsid2VicGFjazovL3Z1ZTMtd2VicGFjazUvLi9ub2RlX21vZHVsZXMvY2VzaXVtL1NvdXJjZS9TaGFkZXJzL01hdGVyaWFscy9XYXRlci5qcz82OGQzIl0sInNvdXJjZXNDb250ZW50IjpbIi8vVGhpcyBmaWxlIGlzIGF1dG9tYXRpY2FsbHkgcmVidWlsdCBieSB0aGUgQ2VzaXVtIGJ1aWxkIHByb2Nlc3MuXG5leHBvcnQgZGVmYXVsdCBcIi8vIFRoYW5rcyBmb3IgdGhlIGNvbnRyaWJ1dGlvbiBKb25hc1xcblxcXG4vLyBodHRwOi8vMjlhLmNoLzIwMTIvNy8xOS93ZWJnbC10ZXJyYWluLXJlbmRlcmluZy13YXRlci1mb2dcXG5cXFxuXFxuXFxcbnVuaWZvcm0gc2FtcGxlcjJEIHNwZWN1bGFyTWFwO1xcblxcXG51bmlmb3JtIHNhbXBsZXIyRCBub3JtYWxNYXA7XFxuXFxcbnVuaWZvcm0gdmVjNCBiYXNlV2F0ZXJDb2xvcjtcXG5cXFxudW5pZm9ybSB2ZWM0IGJsZW5kQ29sb3I7XFxuXFxcbnVuaWZvcm0gZmxvYXQgZnJlcXVlbmN5O1xcblxcXG51bmlmb3JtIGZsb2F0IGFuaW1hdGlvblNwZWVkO1xcblxcXG51bmlmb3JtIGZsb2F0IGFtcGxpdHVkZTtcXG5cXFxudW5pZm9ybSBmbG9hdCBzcGVjdWxhckludGVuc2l0eTtcXG5cXFxudW5pZm9ybSBmbG9hdCBmYWRlRmFjdG9yO1xcblxcXG5cXG5cXFxuY3ptX21hdGVyaWFsIGN6bV9nZXRNYXRlcmlhbChjem1fbWF0ZXJpYWxJbnB1dCBtYXRlcmlhbElucHV0KVxcblxcXG57XFxuXFxcbiAgICBjem1fbWF0ZXJpYWwgbWF0ZXJpYWwgPSBjem1fZ2V0RGVmYXVsdE1hdGVyaWFsKG1hdGVyaWFsSW5wdXQpO1xcblxcXG5cXG5cXFxuICAgIGZsb2F0IHRpbWUgPSBjem1fZnJhbWVOdW1iZXIgKiBhbmltYXRpb25TcGVlZDtcXG5cXFxuXFxuXFxcbiAgICAvLyBmYWRlIGlzIGEgZnVuY3Rpb24gb2YgdGhlIGRpc3RhbmNlIGZyb20gdGhlIGZyYWdtZW50IGFuZCB0aGUgZnJlcXVlbmN5IG9mIHRoZSB3YXZlc1xcblxcXG4gICAgZmxvYXQgZmFkZSA9IG1heCgxLjAsIChsZW5ndGgobWF0ZXJpYWxJbnB1dC5wb3NpdGlvblRvRXllRUMpIC8gMTAwMDAwMDAwMDAuMCkgKiBmcmVxdWVuY3kgKiBmYWRlRmFjdG9yKTtcXG5cXFxuXFxuXFxcbiAgICBmbG9hdCBzcGVjdWxhck1hcFZhbHVlID0gdGV4dHVyZTJEKHNwZWN1bGFyTWFwLCBtYXRlcmlhbElucHV0LnN0KS5yO1xcblxcXG5cXG5cXFxuICAgIC8vIG5vdGU6IG5vdCB1c2luZyBkaXJlY3Rpb25hbCBtb3Rpb24gYXQgdGhpcyB0aW1lLCBqdXN0IHNldCB0aGUgYW5nbGUgdG8gMC4wO1xcblxcXG4gICAgdmVjNCBub2lzZSA9IGN6bV9nZXRXYXRlck5vaXNlKG5vcm1hbE1hcCwgbWF0ZXJpYWxJbnB1dC5zdCAqIGZyZXF1ZW5jeSwgdGltZSwgMC4wKTtcXG5cXFxuICAgIHZlYzMgbm9ybWFsVGFuZ2VudFNwYWNlID0gbm9pc2UueHl6ICogdmVjMygxLjAsIDEuMCwgKDEuMCAvIGFtcGxpdHVkZSkpO1xcblxcXG5cXG5cXFxuICAgIC8vIGZhZGUgb3V0IHRoZSBub3JtYWwgcGVydHVyYmF0aW9uIGFzIHdlIG1vdmUgZnVydGhlciBmcm9tIHRoZSB3YXRlciBzdXJmYWNlXFxuXFxcbiAgICBub3JtYWxUYW5nZW50U3BhY2UueHkgLz0gZmFkZTtcXG5cXFxuXFxuXFxcbiAgICAvLyBhdHRlbXB0IHRvIGZhZGUgb3V0IHRoZSBub3JtYWwgcGVydHVyYmF0aW9uIGFzIHdlIGFwcHJvYWNoIG5vbiB3YXRlciBhcmVhcyAobG93IHNwZWN1bGFyIG1hcCB2YWx1ZSlcXG5cXFxuICAgIG5vcm1hbFRhbmdlbnRTcGFjZSA9IG1peCh2ZWMzKDAuMCwgMC4wLCA1MC4wKSwgbm9ybWFsVGFuZ2VudFNwYWNlLCBzcGVjdWxhck1hcFZhbHVlKTtcXG5cXFxuXFxuXFxcbiAgICBub3JtYWxUYW5nZW50U3BhY2UgPSBub3JtYWxpemUobm9ybWFsVGFuZ2VudFNwYWNlKTtcXG5cXFxuXFxuXFxcbiAgICAvLyBnZXQgcmF0aW9zIGZvciBhbGlnbm1lbnQgb2YgdGhlIG5ldyBub3JtYWwgdmVjdG9yIHdpdGggYSB2ZWN0b3IgcGVycGVuZGljdWxhciB0byB0aGUgdGFuZ2VudCBwbGFuZVxcblxcXG4gICAgZmxvYXQgdHNQZXJ0dXJiYXRpb25SYXRpbyA9IGNsYW1wKGRvdChub3JtYWxUYW5nZW50U3BhY2UsIHZlYzMoMC4wLCAwLjAsIDEuMCkpLCAwLjAsIDEuMCk7XFxuXFxcblxcblxcXG4gICAgLy8gZmFkZSBvdXQgd2F0ZXIgZWZmZWN0IGFzIHNwZWN1bGFyIG1hcCB2YWx1ZSBkZWNyZWFzZXNcXG5cXFxuICAgIG1hdGVyaWFsLmFscGhhID0gbWl4KGJsZW5kQ29sb3IuYSwgYmFzZVdhdGVyQ29sb3IuYSwgc3BlY3VsYXJNYXBWYWx1ZSkgKiBzcGVjdWxhck1hcFZhbHVlO1xcblxcXG5cXG5cXFxuICAgIC8vIGJhc2UgY29sb3IgaXMgYSBibGVuZCBvZiB0aGUgd2F0ZXIgYW5kIG5vbi13YXRlciBjb2xvciBiYXNlZCBvbiB0aGUgdmFsdWUgZnJvbSB0aGUgc3BlY3VsYXIgbWFwXFxuXFxcbiAgICAvLyBtYXkgbmVlZCBhIHVuaWZvcm0gYmxlbmQgZmFjdG9yIHRvIGJldHRlciBjb250cm9sIHRoaXNcXG5cXFxuICAgIG1hdGVyaWFsLmRpZmZ1c2UgPSBtaXgoYmxlbmRDb2xvci5yZ2IsIGJhc2VXYXRlckNvbG9yLnJnYiwgc3BlY3VsYXJNYXBWYWx1ZSk7XFxuXFxcblxcblxcXG4gICAgLy8gZGlmZnVzZSBoaWdobGlnaHRzIGFyZSBiYXNlZCBvbiBob3cgcGVydHVyYmVkIHRoZSBub3JtYWwgaXNcXG5cXFxuICAgIG1hdGVyaWFsLmRpZmZ1c2UgKz0gKDAuMSAqIHRzUGVydHVyYmF0aW9uUmF0aW8pO1xcblxcXG5cXG5cXFxuICAgIG1hdGVyaWFsLmRpZmZ1c2UgPSBtYXRlcmlhbC5kaWZmdXNlO1xcblxcXG5cXG5cXFxuICAgIG1hdGVyaWFsLm5vcm1hbCA9IG5vcm1hbGl6ZShtYXRlcmlhbElucHV0LnRhbmdlbnRUb0V5ZU1hdHJpeCAqIG5vcm1hbFRhbmdlbnRTcGFjZSk7XFxuXFxcblxcblxcXG4gICAgbWF0ZXJpYWwuc3BlY3VsYXIgPSBzcGVjdWxhckludGVuc2l0eTtcXG5cXFxuICAgIG1hdGVyaWFsLnNoaW5pbmVzcyA9IDEwLjA7XFxuXFxcblxcblxcXG4gICAgcmV0dXJuIG1hdGVyaWFsO1xcblxcXG59XFxuXFxcblwiO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///72866\n')},94077:function(__unused_webpack___webpack_module__,__webpack_exports__){eval('//This file is automatically rebuilt by the Cesium build process.\n/* harmony default export */ __webpack_exports__["Z"] = ("czm_modelMaterial customShaderStage(czm_modelMaterial inputMaterial) \\n\\\n{\\n\\\n  #ifdef HAS_CUSTOM_FRAGMENT_SHADER\\n\\\n  // FragmentInput and initializeInputStruct() are dynamically generated in JS, \\n\\\n  // see CustomShaderStage.js\\n\\\n  FragmentInput fsInput;\\n\\\n  initializeInputStruct(fsInput);\\n\\\n  czm_modelMaterial outputMaterial = inputMaterial;\\n\\\n  fragmentMain(fsInput, outputMaterial);\\n\\\n  return outputMaterial;\\n\\\n  #else\\n\\\n  return inputMaterial;\\n\\\n  #endif\\n\\\n}\\n\\\n");\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiOTQwNzcuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQSx5REFBZTtBQUNmLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEIsaUNBQWlDO0FBQ2pDLG1EQUFtRDtBQUNuRCx3Q0FBd0M7QUFDeEMsd0JBQXdCO0FBQ3hCO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0EsQ0FBQztBQUNELENBQUMsRUFBQyIsInNvdXJjZXMiOlsid2VicGFjazovL3Z1ZTMtd2VicGFjazUvLi9ub2RlX21vZHVsZXMvY2VzaXVtL1NvdXJjZS9TaGFkZXJzL01vZGVsRXhwZXJpbWVudGFsL0N1c3RvbVNoYWRlclN0YWdlRlMuanM/NWUxNiJdLCJzb3VyY2VzQ29udGVudCI6WyIvL1RoaXMgZmlsZSBpcyBhdXRvbWF0aWNhbGx5IHJlYnVpbHQgYnkgdGhlIENlc2l1bSBidWlsZCBwcm9jZXNzLlxuZXhwb3J0IGRlZmF1bHQgXCJjem1fbW9kZWxNYXRlcmlhbCBjdXN0b21TaGFkZXJTdGFnZShjem1fbW9kZWxNYXRlcmlhbCBpbnB1dE1hdGVyaWFsKSBcXG5cXFxue1xcblxcXG4gICNpZmRlZiBIQVNfQ1VTVE9NX0ZSQUdNRU5UX1NIQURFUlxcblxcXG4gIC8vIEZyYWdtZW50SW5wdXQgYW5kIGluaXRpYWxpemVJbnB1dFN0cnVjdCgpIGFyZSBkeW5hbWljYWxseSBnZW5lcmF0ZWQgaW4gSlMsIFxcblxcXG4gIC8vIHNlZSBDdXN0b21TaGFkZXJTdGFnZS5qc1xcblxcXG4gIEZyYWdtZW50SW5wdXQgZnNJbnB1dDtcXG5cXFxuICBpbml0aWFsaXplSW5wdXRTdHJ1Y3QoZnNJbnB1dCk7XFxuXFxcbiAgY3ptX21vZGVsTWF0ZXJpYWwgb3V0cHV0TWF0ZXJpYWwgPSBpbnB1dE1hdGVyaWFsO1xcblxcXG4gIGZyYWdtZW50TWFpbihmc0lucHV0LCBvdXRwdXRNYXRlcmlhbCk7XFxuXFxcbiAgcmV0dXJuIG91dHB1dE1hdGVyaWFsO1xcblxcXG4gICNlbHNlXFxuXFxcbiAgcmV0dXJuIGlucHV0TWF0ZXJpYWw7XFxuXFxcbiAgI2VuZGlmXFxuXFxcbn1cXG5cXFxuXCI7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///94077\n')},87932:function(__unused_webpack___webpack_module__,__webpack_exports__){eval('//This file is automatically rebuilt by the Cesium build process.\n/* harmony default export */ __webpack_exports__["Z"] = ("vec3 customShaderStage(vec3 position) {\\n\\\n  #ifdef COMPUTE_POSITION_WC\\n\\\n  // needed so the fragment shader can set fsInput.positionWC\\n\\\n  // Note that this is a 32-bit position which may result in jitter on small\\n\\\n  // scales.\\n\\\n  v_positionWC = (czm_model * vec4(position, 1.0)).xyz;\\n\\\n  #endif\\n\\\n\\n\\\n  #ifdef HAS_CUSTOM_VERTEX_SHADER  \\n\\\n  // VertexInput and initializeInputStruct() are dynamically generated in JS, \\n\\\n  // see CustomShaderStage.js\\n\\\n  VertexInput vsInput;\\n\\\n  initializeInputStruct(vsInput);\\n\\\n  vertexMain(vsInput, position);\\n\\\n  #endif\\n\\\n\\n\\\n  return position;\\n\\\n}\\n\\\n");\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiODc5MzIuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQSx5REFBZSx3Q0FBd0M7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1REFBdUQ7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QixpQ0FBaUM7QUFDakMsZ0NBQWdDO0FBQ2hDO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEIsQ0FBQztBQUNELENBQUMsRUFBQyIsInNvdXJjZXMiOlsid2VicGFjazovL3Z1ZTMtd2VicGFjazUvLi9ub2RlX21vZHVsZXMvY2VzaXVtL1NvdXJjZS9TaGFkZXJzL01vZGVsRXhwZXJpbWVudGFsL0N1c3RvbVNoYWRlclN0YWdlVlMuanM/YTNhYiJdLCJzb3VyY2VzQ29udGVudCI6WyIvL1RoaXMgZmlsZSBpcyBhdXRvbWF0aWNhbGx5IHJlYnVpbHQgYnkgdGhlIENlc2l1bSBidWlsZCBwcm9jZXNzLlxuZXhwb3J0IGRlZmF1bHQgXCJ2ZWMzIGN1c3RvbVNoYWRlclN0YWdlKHZlYzMgcG9zaXRpb24pIHtcXG5cXFxuICAjaWZkZWYgQ09NUFVURV9QT1NJVElPTl9XQ1xcblxcXG4gIC8vIG5lZWRlZCBzbyB0aGUgZnJhZ21lbnQgc2hhZGVyIGNhbiBzZXQgZnNJbnB1dC5wb3NpdGlvbldDXFxuXFxcbiAgLy8gTm90ZSB0aGF0IHRoaXMgaXMgYSAzMi1iaXQgcG9zaXRpb24gd2hpY2ggbWF5IHJlc3VsdCBpbiBqaXR0ZXIgb24gc21hbGxcXG5cXFxuICAvLyBzY2FsZXMuXFxuXFxcbiAgdl9wb3NpdGlvbldDID0gKGN6bV9tb2RlbCAqIHZlYzQocG9zaXRpb24sIDEuMCkpLnh5ejtcXG5cXFxuICAjZW5kaWZcXG5cXFxuXFxuXFxcbiAgI2lmZGVmIEhBU19DVVNUT01fVkVSVEVYX1NIQURFUiAgXFxuXFxcbiAgLy8gVmVydGV4SW5wdXQgYW5kIGluaXRpYWxpemVJbnB1dFN0cnVjdCgpIGFyZSBkeW5hbWljYWxseSBnZW5lcmF0ZWQgaW4gSlMsIFxcblxcXG4gIC8vIHNlZSBDdXN0b21TaGFkZXJTdGFnZS5qc1xcblxcXG4gIFZlcnRleElucHV0IHZzSW5wdXQ7XFxuXFxcbiAgaW5pdGlhbGl6ZUlucHV0U3RydWN0KHZzSW5wdXQpO1xcblxcXG4gIHZlcnRleE1haW4odnNJbnB1dCwgcG9zaXRpb24pO1xcblxcXG4gICNlbmRpZlxcblxcXG5cXG5cXFxuICByZXR1cm4gcG9zaXRpb247XFxuXFxcbn1cXG5cXFxuXCI7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///87932\n')},20885:function(__unused_webpack___webpack_module__,__webpack_exports__){eval('//This file is automatically rebuilt by the Cesium build process.\n/* harmony default export */ __webpack_exports__["Z"] = ("void processPoints()\\n\\\n{\\n\\\n    gl_PointSize = 4.0;\\n\\\n}\\n\\\n\\n\\\nvec3 processGeometry(vec3 position) \\n\\\n{  \\n\\\n    position = a_position;\\n\\\n    v_position = position;\\n\\\n    v_positionEC = (czm_modelView * vec4(position, 1.0)).xyz;\\n\\\n\\n\\\n    #ifdef HAS_NORMALS\\n\\\n    v_normal = czm_normal * a_normal;\\n\\\n    #endif\\n\\\n\\n\\\n    #ifdef HAS_TANGENTS\\n\\\n    v_tangent.xyz = czm_normal * a_tangent.xyz;\\n\\\n    v_tangent.w = a_tangent.w;\\n\\\n    #endif\\n\\\n\\n\\\n    // This function is defined in GeometryPipelineStage\\n\\\n    #ifdef HAS_SET_INDEXED_ATTRIBUTES\\n\\\n    initializeSetIndexedAttributes();\\n\\\n    #endif\\n\\\n\\n\\\n    // This function is defined in GeometryPipelineStage\\n\\\n    #ifdef HAS_CUSTOM_ATTRIBUTES\\n\\\n    initializeCustomAttributes();\\n\\\n    #endif\\n\\\n\\n\\\n    return position;\\n\\\n}\\n\\\n");\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjA4ODUuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQSx5REFBZTtBQUNmLENBQUM7QUFDRCx1QkFBdUI7QUFDdkIsQ0FBQztBQUNEO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsMEJBQTBCO0FBQzFCLDBCQUEwQjtBQUMxQiw2REFBNkQ7QUFDN0Q7QUFDQTtBQUNBLHFDQUFxQztBQUNyQztBQUNBO0FBQ0E7QUFDQSwrQ0FBK0M7QUFDL0MsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDO0FBQ2pDO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEIsQ0FBQztBQUNELENBQUMsRUFBQyIsInNvdXJjZXMiOlsid2VicGFjazovL3Z1ZTMtd2VicGFjazUvLi9ub2RlX21vZHVsZXMvY2VzaXVtL1NvdXJjZS9TaGFkZXJzL01vZGVsRXhwZXJpbWVudGFsL0dlb21ldHJ5U3RhZ2VWUy5qcz81MTM0Il0sInNvdXJjZXNDb250ZW50IjpbIi8vVGhpcyBmaWxlIGlzIGF1dG9tYXRpY2FsbHkgcmVidWlsdCBieSB0aGUgQ2VzaXVtIGJ1aWxkIHByb2Nlc3MuXG5leHBvcnQgZGVmYXVsdCBcInZvaWQgcHJvY2Vzc1BvaW50cygpXFxuXFxcbntcXG5cXFxuICAgIGdsX1BvaW50U2l6ZSA9IDQuMDtcXG5cXFxufVxcblxcXG5cXG5cXFxudmVjMyBwcm9jZXNzR2VvbWV0cnkodmVjMyBwb3NpdGlvbikgXFxuXFxcbnsgIFxcblxcXG4gICAgcG9zaXRpb24gPSBhX3Bvc2l0aW9uO1xcblxcXG4gICAgdl9wb3NpdGlvbiA9IHBvc2l0aW9uO1xcblxcXG4gICAgdl9wb3NpdGlvbkVDID0gKGN6bV9tb2RlbFZpZXcgKiB2ZWM0KHBvc2l0aW9uLCAxLjApKS54eXo7XFxuXFxcblxcblxcXG4gICAgI2lmZGVmIEhBU19OT1JNQUxTXFxuXFxcbiAgICB2X25vcm1hbCA9IGN6bV9ub3JtYWwgKiBhX25vcm1hbDtcXG5cXFxuICAgICNlbmRpZlxcblxcXG5cXG5cXFxuICAgICNpZmRlZiBIQVNfVEFOR0VOVFNcXG5cXFxuICAgIHZfdGFuZ2VudC54eXogPSBjem1fbm9ybWFsICogYV90YW5nZW50Lnh5ejtcXG5cXFxuICAgIHZfdGFuZ2VudC53ID0gYV90YW5nZW50Lnc7XFxuXFxcbiAgICAjZW5kaWZcXG5cXFxuXFxuXFxcbiAgICAvLyBUaGlzIGZ1bmN0aW9uIGlzIGRlZmluZWQgaW4gR2VvbWV0cnlQaXBlbGluZVN0YWdlXFxuXFxcbiAgICAjaWZkZWYgSEFTX1NFVF9JTkRFWEVEX0FUVFJJQlVURVNcXG5cXFxuICAgIGluaXRpYWxpemVTZXRJbmRleGVkQXR0cmlidXRlcygpO1xcblxcXG4gICAgI2VuZGlmXFxuXFxcblxcblxcXG4gICAgLy8gVGhpcyBmdW5jdGlvbiBpcyBkZWZpbmVkIGluIEdlb21ldHJ5UGlwZWxpbmVTdGFnZVxcblxcXG4gICAgI2lmZGVmIEhBU19DVVNUT01fQVRUUklCVVRFU1xcblxcXG4gICAgaW5pdGlhbGl6ZUN1c3RvbUF0dHJpYnV0ZXMoKTtcXG5cXFxuICAgICNlbmRpZlxcblxcXG5cXG5cXFxuICAgIHJldHVybiBwb3NpdGlvbjtcXG5cXFxufVxcblxcXG5cIjtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///20885\n')},70903:function(__unused_webpack___webpack_module__,__webpack_exports__){eval('//This file is automatically rebuilt by the Cesium build process.\n/* harmony default export */ __webpack_exports__["Z"] = ("vec3 instancingStage(vec3 position) \\n\\\n{\\n\\\n    mat4 instancingTransform;\\n\\\n\\n\\\n    #ifdef HAS_INSTANCE_MATRICES\\n\\\n    instancingTransform = mat4(\\n\\\n        a_instancingTransformRow0.x, a_instancingTransformRow1.x, a_instancingTransformRow2.x, 0.0, // Column 1\\n\\\n        a_instancingTransformRow0.y, a_instancingTransformRow1.y, a_instancingTransformRow2.y, 0.0, // Column 2\\n\\\n        a_instancingTransformRow0.z, a_instancingTransformRow1.z, a_instancingTransformRow2.z, 0.0, // Column 3\\n\\\n        a_instancingTransformRow0.w, a_instancingTransformRow1.w, a_instancingTransformRow2.w, 1.0  // Column 4\\n\\\n    );\\n\\\n    #else\\n\\\n    vec3 translation = vec3(0.0, 0.0, 0.0);\\n\\\n    vec3 scale = vec3(1.0, 1.0, 1.0);\\n\\\n    \\n\\\n        #ifdef HAS_INSTANCE_TRANSLATION\\n\\\n        translation = a_instanceTranslation;\\n\\\n        #endif\\n\\\n        #ifdef HAS_INSTANCE_SCALE\\n\\\n        scale = a_instanceScale;\\n\\\n        #endif\\n\\\n\\n\\\n    instancingTransform = mat4(\\n\\\n        scale.x, 0.0, 0.0, 0.0,\\n\\\n        0.0, scale.y, 0.0, 0.0,\\n\\\n        0.0, 0.0, scale.z, 0.0,\\n\\\n        translation.x, translation.y, translation.z, 1.0\\n\\\n    ); \\n\\\n    #endif\\n\\\n\\n\\\n    return (instancingTransform * vec4(position, 1.0)).xyz;\\n\\\n}\\n\\\n");\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNzA5MDMuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQSx5REFBZTtBQUNmLENBQUM7QUFDRCw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSwyQ0FBMkM7QUFDM0MscUNBQXFDO0FBQ3JDO0FBQ0E7QUFDQSw0Q0FBNEM7QUFDNUM7QUFDQTtBQUNBLGdDQUFnQztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsMkRBQTJEO0FBQzNELENBQUM7QUFDRCxDQUFDLEVBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly92dWUzLXdlYnBhY2s1Ly4vbm9kZV9tb2R1bGVzL2Nlc2l1bS9Tb3VyY2UvU2hhZGVycy9Nb2RlbEV4cGVyaW1lbnRhbC9JbnN0YW5jaW5nU3RhZ2VWUy5qcz81Y2EwIl0sInNvdXJjZXNDb250ZW50IjpbIi8vVGhpcyBmaWxlIGlzIGF1dG9tYXRpY2FsbHkgcmVidWlsdCBieSB0aGUgQ2VzaXVtIGJ1aWxkIHByb2Nlc3MuXG5leHBvcnQgZGVmYXVsdCBcInZlYzMgaW5zdGFuY2luZ1N0YWdlKHZlYzMgcG9zaXRpb24pIFxcblxcXG57XFxuXFxcbiAgICBtYXQ0IGluc3RhbmNpbmdUcmFuc2Zvcm07XFxuXFxcblxcblxcXG4gICAgI2lmZGVmIEhBU19JTlNUQU5DRV9NQVRSSUNFU1xcblxcXG4gICAgaW5zdGFuY2luZ1RyYW5zZm9ybSA9IG1hdDQoXFxuXFxcbiAgICAgICAgYV9pbnN0YW5jaW5nVHJhbnNmb3JtUm93MC54LCBhX2luc3RhbmNpbmdUcmFuc2Zvcm1Sb3cxLngsIGFfaW5zdGFuY2luZ1RyYW5zZm9ybVJvdzIueCwgMC4wLCAvLyBDb2x1bW4gMVxcblxcXG4gICAgICAgIGFfaW5zdGFuY2luZ1RyYW5zZm9ybVJvdzAueSwgYV9pbnN0YW5jaW5nVHJhbnNmb3JtUm93MS55LCBhX2luc3RhbmNpbmdUcmFuc2Zvcm1Sb3cyLnksIDAuMCwgLy8gQ29sdW1uIDJcXG5cXFxuICAgICAgICBhX2luc3RhbmNpbmdUcmFuc2Zvcm1Sb3cwLnosIGFfaW5zdGFuY2luZ1RyYW5zZm9ybVJvdzEueiwgYV9pbnN0YW5jaW5nVHJhbnNmb3JtUm93Mi56LCAwLjAsIC8vIENvbHVtbiAzXFxuXFxcbiAgICAgICAgYV9pbnN0YW5jaW5nVHJhbnNmb3JtUm93MC53LCBhX2luc3RhbmNpbmdUcmFuc2Zvcm1Sb3cxLncsIGFfaW5zdGFuY2luZ1RyYW5zZm9ybVJvdzIudywgMS4wICAvLyBDb2x1bW4gNFxcblxcXG4gICAgKTtcXG5cXFxuICAgICNlbHNlXFxuXFxcbiAgICB2ZWMzIHRyYW5zbGF0aW9uID0gdmVjMygwLjAsIDAuMCwgMC4wKTtcXG5cXFxuICAgIHZlYzMgc2NhbGUgPSB2ZWMzKDEuMCwgMS4wLCAxLjApO1xcblxcXG4gICAgXFxuXFxcbiAgICAgICAgI2lmZGVmIEhBU19JTlNUQU5DRV9UUkFOU0xBVElPTlxcblxcXG4gICAgICAgIHRyYW5zbGF0aW9uID0gYV9pbnN0YW5jZVRyYW5zbGF0aW9uO1xcblxcXG4gICAgICAgICNlbmRpZlxcblxcXG4gICAgICAgICNpZmRlZiBIQVNfSU5TVEFOQ0VfU0NBTEVcXG5cXFxuICAgICAgICBzY2FsZSA9IGFfaW5zdGFuY2VTY2FsZTtcXG5cXFxuICAgICAgICAjZW5kaWZcXG5cXFxuXFxuXFxcbiAgICBpbnN0YW5jaW5nVHJhbnNmb3JtID0gbWF0NChcXG5cXFxuICAgICAgICBzY2FsZS54LCAwLjAsIDAuMCwgMC4wLFxcblxcXG4gICAgICAgIDAuMCwgc2NhbGUueSwgMC4wLCAwLjAsXFxuXFxcbiAgICAgICAgMC4wLCAwLjAsIHNjYWxlLnosIDAuMCxcXG5cXFxuICAgICAgICB0cmFuc2xhdGlvbi54LCB0cmFuc2xhdGlvbi55LCB0cmFuc2xhdGlvbi56LCAxLjBcXG5cXFxuICAgICk7IFxcblxcXG4gICAgI2VuZGlmXFxuXFxcblxcblxcXG4gICAgcmV0dXJuIChpbnN0YW5jaW5nVHJhbnNmb3JtICogdmVjNChwb3NpdGlvbiwgMS4wKSkueHl6O1xcblxcXG59XFxuXFxcblwiO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///70903\n')},36564:function(__unused_webpack___webpack_module__,__webpack_exports__){eval('//This file is automatically rebuilt by the Cesium build process.\n/* harmony default export */ __webpack_exports__["Z"] = ("vec3 LINEARtoSRGB(vec3 linearIn) \\n\\\n{\\n\\\n    #ifndef HDR \\n\\\n    return pow(linearIn, vec3(1.0/2.2));\\n\\\n    #else \\n\\\n    return linearIn;\\n\\\n    #endif \\n\\\n}\\n\\\n\\n\\\n#ifdef LIGHTING_PBR\\n\\\nvec3 applyTonemapping(vec3 linearIn) \\n\\\n{\\n\\\n    #ifndef HDR \\n\\\n    return czm_acesTonemapping(linearIn);\\n\\\n    #else \\n\\\n    return linearIn;\\n\\\n    #endif \\n\\\n}\\n\\\n\\n\\\nvec3 computePbrLighting(czm_modelMaterial inputMaterial)\\n\\\n{\\n\\\n    czm_pbrParameters pbrParameters;\\n\\\n    pbrParameters.diffuseColor = inputMaterial.diffuse;\\n\\\n    pbrParameters.f0 = inputMaterial.specular;\\n\\\n    pbrParameters.roughness = inputMaterial.roughness;\\n\\\n    \\n\\\n    vec3 lightColorHdr = czm_lightColorHdr;\\n\\\n\\n\\\n    vec3 color = inputMaterial.diffuse;\\n\\\n    #ifdef HAS_NORMALS\\n\\\n    color = czm_pbrLighting(\\n\\\n        v_positionEC,\\n\\\n        inputMaterial.normal,\\n\\\n        czm_lightDirectionEC,\\n\\\n        lightColorHdr,\\n\\\n        pbrParameters\\n\\\n    );\\n\\\n    #endif\\n\\\n\\n\\\n    color *= inputMaterial.occlusion;\\n\\\n    color += inputMaterial.emissive;\\n\\\n\\n\\\n    // Convert high-dynamic range to low-dynamic range in HDR mode\\n\\\n    color = applyTonemapping(color);\\n\\\n    return color;\\n\\\n}\\n\\\n#endif\\n\\\n\\n\\\n\\n\\\nczm_modelMaterial lightingStage(czm_modelMaterial inputMaterial)\\n\\\n{\\n\\\n    // Even though the lighting will only set the diffuse color,\\n\\\n    // pass all other properties too so further stages have access to them.\\n\\\n    czm_modelMaterial outputMaterial = inputMaterial;\\n\\\n    vec3 color = vec3(0.0);\\n\\\n\\n\\\n    #ifdef LIGHTING_PBR\\n\\\n    color = computePbrLighting(inputMaterial);\\n\\\n    #else // unlit\\n\\\n    color = inputMaterial.diffuse;\\n\\\n    #endif\\n\\\n\\n\\\n    color = LINEARtoSRGB(color);\\n\\\n\\n\\\n    outputMaterial.diffuse = color;\\n\\\n    return outputMaterial;\\n\\\n}\\n\\\n");\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMzY1NjQuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQSx5REFBZTtBQUNmLENBQUM7QUFDRDtBQUNBLHdDQUF3QztBQUN4QztBQUNBLG9CQUFvQjtBQUNwQjtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQSx5Q0FBeUM7QUFDekM7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRCxvQ0FBb0M7QUFDcEMsdURBQXVEO0FBQ3ZELDhDQUE4QztBQUM5QyxzREFBc0Q7QUFDdEQ7QUFDQSwyQ0FBMkM7QUFDM0M7QUFDQSx1Q0FBdUM7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLHFDQUFxQztBQUNyQyxvQ0FBb0M7QUFDcEM7QUFDQTtBQUNBLG9DQUFvQztBQUNwQyxpQkFBaUI7QUFDakIsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxxREFBcUQ7QUFDckQsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQSw4Q0FBOEM7QUFDOUM7QUFDQSxrQ0FBa0M7QUFDbEM7QUFDQTtBQUNBLGdDQUFnQztBQUNoQztBQUNBLG1DQUFtQztBQUNuQywwQkFBMEI7QUFDMUIsQ0FBQztBQUNELENBQUMsRUFBQyIsInNvdXJjZXMiOlsid2VicGFjazovL3Z1ZTMtd2VicGFjazUvLi9ub2RlX21vZHVsZXMvY2VzaXVtL1NvdXJjZS9TaGFkZXJzL01vZGVsRXhwZXJpbWVudGFsL0xpZ2h0aW5nU3RhZ2VGUy5qcz81NmI4Il0sInNvdXJjZXNDb250ZW50IjpbIi8vVGhpcyBmaWxlIGlzIGF1dG9tYXRpY2FsbHkgcmVidWlsdCBieSB0aGUgQ2VzaXVtIGJ1aWxkIHByb2Nlc3MuXG5leHBvcnQgZGVmYXVsdCBcInZlYzMgTElORUFSdG9TUkdCKHZlYzMgbGluZWFySW4pIFxcblxcXG57XFxuXFxcbiAgICAjaWZuZGVmIEhEUiBcXG5cXFxuICAgIHJldHVybiBwb3cobGluZWFySW4sIHZlYzMoMS4wLzIuMikpO1xcblxcXG4gICAgI2Vsc2UgXFxuXFxcbiAgICByZXR1cm4gbGluZWFySW47XFxuXFxcbiAgICAjZW5kaWYgXFxuXFxcbn1cXG5cXFxuXFxuXFxcbiNpZmRlZiBMSUdIVElOR19QQlJcXG5cXFxudmVjMyBhcHBseVRvbmVtYXBwaW5nKHZlYzMgbGluZWFySW4pIFxcblxcXG57XFxuXFxcbiAgICAjaWZuZGVmIEhEUiBcXG5cXFxuICAgIHJldHVybiBjem1fYWNlc1RvbmVtYXBwaW5nKGxpbmVhckluKTtcXG5cXFxuICAgICNlbHNlIFxcblxcXG4gICAgcmV0dXJuIGxpbmVhckluO1xcblxcXG4gICAgI2VuZGlmIFxcblxcXG59XFxuXFxcblxcblxcXG52ZWMzIGNvbXB1dGVQYnJMaWdodGluZyhjem1fbW9kZWxNYXRlcmlhbCBpbnB1dE1hdGVyaWFsKVxcblxcXG57XFxuXFxcbiAgICBjem1fcGJyUGFyYW1ldGVycyBwYnJQYXJhbWV0ZXJzO1xcblxcXG4gICAgcGJyUGFyYW1ldGVycy5kaWZmdXNlQ29sb3IgPSBpbnB1dE1hdGVyaWFsLmRpZmZ1c2U7XFxuXFxcbiAgICBwYnJQYXJhbWV0ZXJzLmYwID0gaW5wdXRNYXRlcmlhbC5zcGVjdWxhcjtcXG5cXFxuICAgIHBiclBhcmFtZXRlcnMucm91Z2huZXNzID0gaW5wdXRNYXRlcmlhbC5yb3VnaG5lc3M7XFxuXFxcbiAgICBcXG5cXFxuICAgIHZlYzMgbGlnaHRDb2xvckhkciA9IGN6bV9saWdodENvbG9ySGRyO1xcblxcXG5cXG5cXFxuICAgIHZlYzMgY29sb3IgPSBpbnB1dE1hdGVyaWFsLmRpZmZ1c2U7XFxuXFxcbiAgICAjaWZkZWYgSEFTX05PUk1BTFNcXG5cXFxuICAgIGNvbG9yID0gY3ptX3BickxpZ2h0aW5nKFxcblxcXG4gICAgICAgIHZfcG9zaXRpb25FQyxcXG5cXFxuICAgICAgICBpbnB1dE1hdGVyaWFsLm5vcm1hbCxcXG5cXFxuICAgICAgICBjem1fbGlnaHREaXJlY3Rpb25FQyxcXG5cXFxuICAgICAgICBsaWdodENvbG9ySGRyLFxcblxcXG4gICAgICAgIHBiclBhcmFtZXRlcnNcXG5cXFxuICAgICk7XFxuXFxcbiAgICAjZW5kaWZcXG5cXFxuXFxuXFxcbiAgICBjb2xvciAqPSBpbnB1dE1hdGVyaWFsLm9jY2x1c2lvbjtcXG5cXFxuICAgIGNvbG9yICs9IGlucHV0TWF0ZXJpYWwuZW1pc3NpdmU7XFxuXFxcblxcblxcXG4gICAgLy8gQ29udmVydCBoaWdoLWR5bmFtaWMgcmFuZ2UgdG8gbG93LWR5bmFtaWMgcmFuZ2UgaW4gSERSIG1vZGVcXG5cXFxuICAgIGNvbG9yID0gYXBwbHlUb25lbWFwcGluZyhjb2xvcik7XFxuXFxcbiAgICByZXR1cm4gY29sb3I7XFxuXFxcbn1cXG5cXFxuI2VuZGlmXFxuXFxcblxcblxcXG5cXG5cXFxuY3ptX21vZGVsTWF0ZXJpYWwgbGlnaHRpbmdTdGFnZShjem1fbW9kZWxNYXRlcmlhbCBpbnB1dE1hdGVyaWFsKVxcblxcXG57XFxuXFxcbiAgICAvLyBFdmVuIHRob3VnaCB0aGUgbGlnaHRpbmcgd2lsbCBvbmx5IHNldCB0aGUgZGlmZnVzZSBjb2xvcixcXG5cXFxuICAgIC8vIHBhc3MgYWxsIG90aGVyIHByb3BlcnRpZXMgdG9vIHNvIGZ1cnRoZXIgc3RhZ2VzIGhhdmUgYWNjZXNzIHRvIHRoZW0uXFxuXFxcbiAgICBjem1fbW9kZWxNYXRlcmlhbCBvdXRwdXRNYXRlcmlhbCA9IGlucHV0TWF0ZXJpYWw7XFxuXFxcbiAgICB2ZWMzIGNvbG9yID0gdmVjMygwLjApO1xcblxcXG5cXG5cXFxuICAgICNpZmRlZiBMSUdIVElOR19QQlJcXG5cXFxuICAgIGNvbG9yID0gY29tcHV0ZVBickxpZ2h0aW5nKGlucHV0TWF0ZXJpYWwpO1xcblxcXG4gICAgI2Vsc2UgLy8gdW5saXRcXG5cXFxuICAgIGNvbG9yID0gaW5wdXRNYXRlcmlhbC5kaWZmdXNlO1xcblxcXG4gICAgI2VuZGlmXFxuXFxcblxcblxcXG4gICAgY29sb3IgPSBMSU5FQVJ0b1NSR0IoY29sb3IpO1xcblxcXG5cXG5cXFxuICAgIG91dHB1dE1hdGVyaWFsLmRpZmZ1c2UgPSBjb2xvcjtcXG5cXFxuICAgIHJldHVybiBvdXRwdXRNYXRlcmlhbDtcXG5cXFxufVxcblxcXG5cIjtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///36564\n')},92667:function(__unused_webpack___webpack_module__,__webpack_exports__){eval('//This file is automatically rebuilt by the Cesium build process.\n/* harmony default export */ __webpack_exports__["Z"] = ("vec3 SRGBtoLINEAR3(vec3 srgbIn) \\n\\\n{\\n\\\n    return pow(srgbIn, vec3(2.2));\\n\\\n}\\n\\\n\\n\\\nvec4 SRGBtoLINEAR4(vec4 srgbIn) \\n\\\n{\\n\\\n    vec3 linearOut = pow(srgbIn.rgb, vec3(2.2));\\n\\\n    return vec4(linearOut, srgbIn.a);\\n\\\n}\\n\\\n\\n\\\nvec2 computeTextureTransform(vec2 texCoord, mat3 textureTransform)\\n\\\n{\\n\\\n    return vec2(textureTransform * vec3(texCoord, 1.0));\\n\\\n}\\n\\\n\\n\\\n#ifdef HAS_NORMALS\\n\\\nvec3 computeNormal()\\n\\\n{\\n\\\n    vec3 ng = normalize(v_normal);\\n\\\n\\n\\\n    vec3 normal = ng;\\n\\\n    #ifdef HAS_NORMAL_TEXTURE\\n\\\n    vec2 normalTexCoords = TEXCOORD_NORMAL;\\n\\\n        #ifdef HAS_NORMAL_TEXTURE_TRANSFORM\\n\\\n        normalTexCoords = computeTextureTransform(normalTexCoords, u_normalTextureTransform);\\n\\\n        #endif\\n\\\n\\n\\\n        #ifdef HAS_TANGENTS\\n\\\n        // read tangents from varying\\n\\\n        vec3 t = normalize(v_tangent.xyz);\\n\\\n        vec3 b = normalize(cross(ng, t) * v_tangent.w);\\n\\\n        mat3 tbn = mat3(t, b, ng);\\n\\\n        vec3 n = texture2D(u_normalTexture, normalTexCoords).rgb;\\n\\\n        normal = normalize(tbn * (2.0 * n - 1.0));\\n\\\n        #elif defined(GL_OES_standard_derivatives)\\n\\\n        // Compute tangents\\n\\\n        vec3 pos_dx = dFdx(v_positionEC);\\n\\\n        vec3 pos_dy = dFdy(v_positionEC);\\n\\\n        vec3 tex_dx = dFdx(vec3(normalTexCoords,0.0));\\n\\\n        vec3 tex_dy = dFdy(vec3(normalTexCoords,0.0));\\n\\\n        vec3 t = (tex_dy.t * pos_dx - tex_dx.t * pos_dy) / (tex_dx.s * tex_dy.t - tex_dy.s * tex_dx.t);\\n\\\n        t = normalize(t - ng * dot(ng, t));\\n\\\n        vec3 b = normalize(cross(ng, t));\\n\\\n        mat3 tbn = mat3(t, b, ng);\\n\\\n        vec3 n = texture2D(u_normalTexture, normalTexCoords).rgb;\\n\\\n        normal = normalize(tbn * (2.0 * n - 1.0));\\n\\\n        #endif\\n\\\n    #endif\\n\\\n\\n\\\n    return normal;\\n\\\n}\\n\\\n#endif\\n\\\n\\n\\\nczm_modelMaterial materialStage(czm_modelMaterial inputMaterial)\\n\\\n{\\n\\\n    czm_modelMaterial material = inputMaterial;\\n\\\n\\n\\\n    #ifdef HAS_NORMALS\\n\\\n    material.normal = computeNormal();\\n\\\n    #endif\\n\\\n\\n\\\n    vec4 baseColorWithAlpha = vec4(1.0);\\n\\\n    // Regardless of whether we use PBR, set a base color\\n\\\n    #ifdef HAS_BASE_COLOR_TEXTURE\\n\\\n    vec2 baseColorTexCoords = TEXCOORD_BASE_COLOR;\\n\\\n\\n\\\n        #ifdef HAS_BASE_COLOR_TEXTURE_TRANSFORM\\n\\\n        baseColorTexCoords = computeTextureTransform(baseColorTexCoords, u_baseColorTextureTransform);\\n\\\n        #endif\\n\\\n\\n\\\n    baseColorWithAlpha = SRGBtoLINEAR4(texture2D(u_baseColorTexture, baseColorTexCoords));\\n\\\n\\n\\\n        #ifdef HAS_BASE_COLOR_FACTOR\\n\\\n        baseColorWithAlpha *= u_baseColorFactor;\\n\\\n        #endif\\n\\\n    #elif defined(HAS_BASE_COLOR_FACTOR)\\n\\\n    baseColorWithAlpha = u_baseColorFactor;\\n\\\n    #endif\\n\\\n\\n\\\n    #ifdef HAS_COLOR_0\\n\\\n    baseColorWithAlpha *= v_color_0;\\n\\\n    #endif\\n\\\n\\n\\\n    material.diffuse = baseColorWithAlpha.rgb;\\n\\\n    material.alpha = baseColorWithAlpha.a;\\n\\\n\\n\\\n    #ifdef HAS_OCCLUSION_TEXTURE\\n\\\n    vec2 occlusionTexCoords = TEXCOORD_OCCLUSION;\\n\\\n        #ifdef HAS_OCCLUSION_TEXTURE_TRANSFORM\\n\\\n        occlusionTexCoords = computeTextureTransform(occlusionTexCoords, u_occlusionTextureTransform);\\n\\\n        #endif\\n\\\n    material.occlusion = texture2D(u_occlusionTexture, occlusionTexCoords).r;\\n\\\n    #endif\\n\\\n\\n\\\n    #ifdef HAS_EMISSIVE_TEXTURE\\n\\\n    vec2 emissiveTexCoords = TEXCOORD_EMISSIVE;\\n\\\n        #ifdef HAS_EMISSIVE_TEXTURE_TRANSFORM\\n\\\n        emissiveTexCoords = computeTextureTransform(emissiveTexCoords, u_emissiveTextureTransform);\\n\\\n        #endif\\n\\\n\\n\\\n    vec3 emissive = SRGBtoLINEAR3(texture2D(u_emissiveTexture, emissiveTexCoords).rgb);\\n\\\n        #ifdef HAS_EMISSIVE_FACTOR\\n\\\n        emissive *= u_emissiveFactor;\\n\\\n        #endif\\n\\\n    material.emissive = emissive;\\n\\\n    #elif defined(HAS_EMISSIVE_FACTOR)\\n\\\n    material.emissive = u_emissiveFactor;\\n\\\n    #endif\\n\\\n\\n\\\n    #if defined(LIGHTING_PBR) && defined(USE_SPECULAR_GLOSSINESS)\\n\\\n        #ifdef HAS_SPECULAR_GLOSSINESS_TEXTURE\\n\\\n        vec2 specularGlossinessTexCoords = TEXCOORD_SPECULAR_GLOSSINESS;\\n\\\n          #ifdef HAS_SPECULAR_GLOSSINESS_TEXTURE_TRANSFORM\\n\\\n          specularGlossinessTexCoords = computeTextureTransform(specularGlossinessTexCoords, u_specularGlossinessTextureTransform);\\n\\\n          #endif\\n\\\n\\n\\\n        vec4 specularGlossiness = SRGBtoLINEAR4(texture2D(u_specularGlossinessTexture, specularGlossinessTexCoords));\\n\\\n        vec3 specular = specularGlossiness.rgb;\\n\\\n        float glossiness = specularGlossiness.a;\\n\\\n            #ifdef HAS_SPECULAR_FACTOR\\n\\\n            specular *= u_specularFactor;\\n\\\n            #endif\\n\\\n\\n\\\n            #ifdef HAS_GLOSSINESS_FACTOR\\n\\\n            glossiness *= u_glossinessFactor;\\n\\\n            #endif\\n\\\n        #else\\n\\\n            #ifdef HAS_SPECULAR_FACTOR\\n\\\n            vec3 specular = clamp(u_specularFactor, vec3(0.0), vec3(1.0));\\n\\\n            #else\\n\\\n            vec3 specular = vec3(1.0);\\n\\\n            #endif\\n\\\n\\n\\\n            #ifdef HAS_GLOSSINESS_FACTOR\\n\\\n            float glossiness = clamp(u_glossinessFactor, 0.0, 1.0);\\n\\\n            #else\\n\\\n            float glossiness = 1.0;\\n\\\n            #endif\\n\\\n        #endif\\n\\\n\\n\\\n        #ifdef HAS_DIFFUSE_TEXTURE\\n\\\n        vec2 diffuseTexCoords = TEXCOORD_DIFFUSE;\\n\\\n            #ifdef HAS_DIFFUSE_TEXTURE_TRANSFORM\\n\\\n            diffuseTexCoords = computeTextureTransform(diffuseTexCoords, u_diffuseTextureTransform);\\n\\\n            #endif\\n\\\n\\n\\\n        vec4 diffuse = SRGBtoLINEAR4(texture2D(u_diffuseTexture, diffuseTexCoords));\\n\\\n            #ifdef HAS_DIFFUSE_FACTOR\\n\\\n            diffuse *= u_diffuseFactor;\\n\\\n            #endif\\n\\\n        #elif defined(HAS_DIFFUSE_FACTOR)\\n\\\n        vec4 diffuse = clamp(u_diffuseFactor, vec4(0.0), vec4(1.0));\\n\\\n        #else\\n\\\n        vec4 diffuse = vec4(1.0);\\n\\\n        #endif\\n\\\n    czm_pbrParameters parameters = czm_pbrSpecularGlossinessMaterial(\\n\\\n      diffuse.rgb,\\n\\\n      specular,\\n\\\n      glossiness\\n\\\n    );\\n\\\n    material.diffuse = parameters.diffuseColor;\\n\\\n    material.specular = parameters.f0;\\n\\\n    material.roughness = parameters.roughness;\\n\\\n    #elif defined(LIGHTING_PBR)\\n\\\n        #ifdef HAS_METALLIC_ROUGHNESS_TEXTURE\\n\\\n        vec2 metallicRoughnessTexCoords = TEXCOORD_METALLIC_ROUGHNESS;\\n\\\n            #ifdef HAS_METALLIC_ROUGHNESS_TEXTURE_TRANSFORM\\n\\\n            metallicRoughnessTexCoords = computeTextureTransform(metallicRoughnessTexCoords, u_metallicRoughnessTextureTransform);\\n\\\n            #endif\\n\\\n\\n\\\n        vec3 metallicRoughness = texture2D(u_metallicRoughnessTexture, metallicRoughnessTexCoords).rgb;\\n\\\n        float metalness = clamp(metallicRoughness.b, 0.0, 1.0);\\n\\\n        float roughness = clamp(metallicRoughness.g, 0.04, 1.0);\\n\\\n            #ifdef HAS_METALLIC_FACTOR\\n\\\n            metalness *= u_metallicFactor;\\n\\\n            #endif\\n\\\n\\n\\\n            #ifdef HAS_ROUGHNESS_FACTOR\\n\\\n            roughness *= u_roughnessFactor;\\n\\\n            #endif\\n\\\n        #else\\n\\\n            #ifdef HAS_METALLIC_FACTOR\\n\\\n            float metalness = clamp(u_metallicFactor, 0.0, 1.0);\\n\\\n            #else\\n\\\n            float metalness = 1.0;\\n\\\n            #endif\\n\\\n\\n\\\n            #ifdef HAS_ROUGHNESS_FACTOR\\n\\\n            float roughness = clamp(u_roughnessFactor, 0.04, 1.0);\\n\\\n            #else\\n\\\n            float roughness = 1.0;\\n\\\n            #endif\\n\\\n        #endif\\n\\\n    czm_pbrParameters parameters = czm_pbrMetallicRoughnessMaterial(\\n\\\n      material.diffuse,\\n\\\n      metalness,\\n\\\n      roughness\\n\\\n    );\\n\\\n    material.diffuse = parameters.diffuseColor;\\n\\\n    material.specular = parameters.f0;\\n\\\n    material.roughness = parameters.roughness;\\n\\\n    #endif\\n\\\n\\n\\\n    return material;\\n\\\n}");\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiOTI2NjcuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQSx5REFBZTtBQUNmLENBQUM7QUFDRCxrQ0FBa0M7QUFDbEMsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0QsZ0RBQWdEO0FBQ2hELHFDQUFxQztBQUNyQyxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRCx3REFBd0Q7QUFDeEQsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRCxrQ0FBa0M7QUFDbEM7QUFDQSxxQkFBcUI7QUFDckI7QUFDQSwyQ0FBMkM7QUFDM0M7QUFDQSw2RkFBNkY7QUFDN0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEM7QUFDMUMsdURBQXVEO0FBQ3ZELGtDQUFrQztBQUNsQyxpRUFBaUU7QUFDakUsa0RBQWtEO0FBQ2xEO0FBQ0E7QUFDQSx5Q0FBeUM7QUFDekMseUNBQXlDO0FBQ3pDLHNEQUFzRDtBQUN0RCxzREFBc0Q7QUFDdEQsdUdBQXVHO0FBQ3ZHLDJDQUEyQztBQUMzQyx5Q0FBeUM7QUFDekMsa0NBQWtDO0FBQ2xDLGlFQUFpRTtBQUNqRSxrREFBa0Q7QUFDbEQ7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0QsK0NBQStDO0FBQy9DO0FBQ0E7QUFDQSxzQ0FBc0M7QUFDdEM7QUFDQTtBQUNBLHdDQUF3QztBQUN4QztBQUNBO0FBQ0Esa0RBQWtEO0FBQ2xEO0FBQ0E7QUFDQSxzR0FBc0c7QUFDdEc7QUFDQTtBQUNBLDBGQUEwRjtBQUMxRjtBQUNBO0FBQ0EsZ0RBQWdEO0FBQ2hEO0FBQ0E7QUFDQSwyQ0FBMkM7QUFDM0M7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DO0FBQ3BDO0FBQ0E7QUFDQSw4Q0FBOEM7QUFDOUMsMENBQTBDO0FBQzFDO0FBQ0E7QUFDQSxpREFBaUQ7QUFDakQ7QUFDQSxzR0FBc0c7QUFDdEc7QUFDQSw2RUFBNkU7QUFDN0U7QUFDQTtBQUNBO0FBQ0EsK0NBQStDO0FBQy9DO0FBQ0EsbUdBQW1HO0FBQ25HO0FBQ0E7QUFDQSx1RkFBdUY7QUFDdkY7QUFDQSxxQ0FBcUM7QUFDckM7QUFDQSxpQ0FBaUM7QUFDakM7QUFDQSx5Q0FBeUM7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3RUFBd0U7QUFDeEU7QUFDQSxtSUFBbUk7QUFDbkk7QUFDQTtBQUNBLHFIQUFxSDtBQUNySCwrQ0FBK0M7QUFDL0MsZ0RBQWdEO0FBQ2hEO0FBQ0EseUNBQXlDO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QztBQUM3QztBQUNBO0FBQ0E7QUFDQSwwRUFBMEU7QUFDMUU7QUFDQSxzQ0FBc0M7QUFDdEM7QUFDQTtBQUNBO0FBQ0EsbUVBQW1FO0FBQ25FO0FBQ0EsbUNBQW1DO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWlEO0FBQ2pEO0FBQ0Esb0dBQW9HO0FBQ3BHO0FBQ0E7QUFDQSxvRkFBb0Y7QUFDcEY7QUFDQSx1Q0FBdUM7QUFDdkM7QUFDQTtBQUNBLG9FQUFvRTtBQUNwRTtBQUNBLGlDQUFpQztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOLCtDQUErQztBQUMvQyxzQ0FBc0M7QUFDdEMsOENBQThDO0FBQzlDO0FBQ0E7QUFDQSxzRUFBc0U7QUFDdEU7QUFDQSxrSUFBa0k7QUFDbEk7QUFDQTtBQUNBLHVHQUF1RztBQUN2RywrREFBK0Q7QUFDL0QsZ0VBQWdFO0FBQ2hFO0FBQ0EsMENBQTBDO0FBQzFDO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQztBQUMzQztBQUNBO0FBQ0E7QUFDQSxnRUFBZ0U7QUFDaEU7QUFDQSxrQ0FBa0M7QUFDbEM7QUFDQTtBQUNBO0FBQ0Esa0VBQWtFO0FBQ2xFO0FBQ0Esa0NBQWtDO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTiwrQ0FBK0M7QUFDL0Msc0NBQXNDO0FBQ3RDLDhDQUE4QztBQUM5QztBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCLENBQUMsQ0FBQyxFQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdnVlMy13ZWJwYWNrNS8uL25vZGVfbW9kdWxlcy9jZXNpdW0vU291cmNlL1NoYWRlcnMvTW9kZWxFeHBlcmltZW50YWwvTWF0ZXJpYWxTdGFnZUZTLmpzP2Q5M2IiXSwic291cmNlc0NvbnRlbnQiOlsiLy9UaGlzIGZpbGUgaXMgYXV0b21hdGljYWxseSByZWJ1aWx0IGJ5IHRoZSBDZXNpdW0gYnVpbGQgcHJvY2Vzcy5cbmV4cG9ydCBkZWZhdWx0IFwidmVjMyBTUkdCdG9MSU5FQVIzKHZlYzMgc3JnYkluKSBcXG5cXFxue1xcblxcXG4gICAgcmV0dXJuIHBvdyhzcmdiSW4sIHZlYzMoMi4yKSk7XFxuXFxcbn1cXG5cXFxuXFxuXFxcbnZlYzQgU1JHQnRvTElORUFSNCh2ZWM0IHNyZ2JJbikgXFxuXFxcbntcXG5cXFxuICAgIHZlYzMgbGluZWFyT3V0ID0gcG93KHNyZ2JJbi5yZ2IsIHZlYzMoMi4yKSk7XFxuXFxcbiAgICByZXR1cm4gdmVjNChsaW5lYXJPdXQsIHNyZ2JJbi5hKTtcXG5cXFxufVxcblxcXG5cXG5cXFxudmVjMiBjb21wdXRlVGV4dHVyZVRyYW5zZm9ybSh2ZWMyIHRleENvb3JkLCBtYXQzIHRleHR1cmVUcmFuc2Zvcm0pXFxuXFxcbntcXG5cXFxuICAgIHJldHVybiB2ZWMyKHRleHR1cmVUcmFuc2Zvcm0gKiB2ZWMzKHRleENvb3JkLCAxLjApKTtcXG5cXFxufVxcblxcXG5cXG5cXFxuI2lmZGVmIEhBU19OT1JNQUxTXFxuXFxcbnZlYzMgY29tcHV0ZU5vcm1hbCgpXFxuXFxcbntcXG5cXFxuICAgIHZlYzMgbmcgPSBub3JtYWxpemUodl9ub3JtYWwpO1xcblxcXG5cXG5cXFxuICAgIHZlYzMgbm9ybWFsID0gbmc7XFxuXFxcbiAgICAjaWZkZWYgSEFTX05PUk1BTF9URVhUVVJFXFxuXFxcbiAgICB2ZWMyIG5vcm1hbFRleENvb3JkcyA9IFRFWENPT1JEX05PUk1BTDtcXG5cXFxuICAgICAgICAjaWZkZWYgSEFTX05PUk1BTF9URVhUVVJFX1RSQU5TRk9STVxcblxcXG4gICAgICAgIG5vcm1hbFRleENvb3JkcyA9IGNvbXB1dGVUZXh0dXJlVHJhbnNmb3JtKG5vcm1hbFRleENvb3JkcywgdV9ub3JtYWxUZXh0dXJlVHJhbnNmb3JtKTtcXG5cXFxuICAgICAgICAjZW5kaWZcXG5cXFxuXFxuXFxcbiAgICAgICAgI2lmZGVmIEhBU19UQU5HRU5UU1xcblxcXG4gICAgICAgIC8vIHJlYWQgdGFuZ2VudHMgZnJvbSB2YXJ5aW5nXFxuXFxcbiAgICAgICAgdmVjMyB0ID0gbm9ybWFsaXplKHZfdGFuZ2VudC54eXopO1xcblxcXG4gICAgICAgIHZlYzMgYiA9IG5vcm1hbGl6ZShjcm9zcyhuZywgdCkgKiB2X3RhbmdlbnQudyk7XFxuXFxcbiAgICAgICAgbWF0MyB0Ym4gPSBtYXQzKHQsIGIsIG5nKTtcXG5cXFxuICAgICAgICB2ZWMzIG4gPSB0ZXh0dXJlMkQodV9ub3JtYWxUZXh0dXJlLCBub3JtYWxUZXhDb29yZHMpLnJnYjtcXG5cXFxuICAgICAgICBub3JtYWwgPSBub3JtYWxpemUodGJuICogKDIuMCAqIG4gLSAxLjApKTtcXG5cXFxuICAgICAgICAjZWxpZiBkZWZpbmVkKEdMX09FU19zdGFuZGFyZF9kZXJpdmF0aXZlcylcXG5cXFxuICAgICAgICAvLyBDb21wdXRlIHRhbmdlbnRzXFxuXFxcbiAgICAgICAgdmVjMyBwb3NfZHggPSBkRmR4KHZfcG9zaXRpb25FQyk7XFxuXFxcbiAgICAgICAgdmVjMyBwb3NfZHkgPSBkRmR5KHZfcG9zaXRpb25FQyk7XFxuXFxcbiAgICAgICAgdmVjMyB0ZXhfZHggPSBkRmR4KHZlYzMobm9ybWFsVGV4Q29vcmRzLDAuMCkpO1xcblxcXG4gICAgICAgIHZlYzMgdGV4X2R5ID0gZEZkeSh2ZWMzKG5vcm1hbFRleENvb3JkcywwLjApKTtcXG5cXFxuICAgICAgICB2ZWMzIHQgPSAodGV4X2R5LnQgKiBwb3NfZHggLSB0ZXhfZHgudCAqIHBvc19keSkgLyAodGV4X2R4LnMgKiB0ZXhfZHkudCAtIHRleF9keS5zICogdGV4X2R4LnQpO1xcblxcXG4gICAgICAgIHQgPSBub3JtYWxpemUodCAtIG5nICogZG90KG5nLCB0KSk7XFxuXFxcbiAgICAgICAgdmVjMyBiID0gbm9ybWFsaXplKGNyb3NzKG5nLCB0KSk7XFxuXFxcbiAgICAgICAgbWF0MyB0Ym4gPSBtYXQzKHQsIGIsIG5nKTtcXG5cXFxuICAgICAgICB2ZWMzIG4gPSB0ZXh0dXJlMkQodV9ub3JtYWxUZXh0dXJlLCBub3JtYWxUZXhDb29yZHMpLnJnYjtcXG5cXFxuICAgICAgICBub3JtYWwgPSBub3JtYWxpemUodGJuICogKDIuMCAqIG4gLSAxLjApKTtcXG5cXFxuICAgICAgICAjZW5kaWZcXG5cXFxuICAgICNlbmRpZlxcblxcXG5cXG5cXFxuICAgIHJldHVybiBub3JtYWw7XFxuXFxcbn1cXG5cXFxuI2VuZGlmXFxuXFxcblxcblxcXG5jem1fbW9kZWxNYXRlcmlhbCBtYXRlcmlhbFN0YWdlKGN6bV9tb2RlbE1hdGVyaWFsIGlucHV0TWF0ZXJpYWwpXFxuXFxcbntcXG5cXFxuICAgIGN6bV9tb2RlbE1hdGVyaWFsIG1hdGVyaWFsID0gaW5wdXRNYXRlcmlhbDtcXG5cXFxuXFxuXFxcbiAgICAjaWZkZWYgSEFTX05PUk1BTFNcXG5cXFxuICAgIG1hdGVyaWFsLm5vcm1hbCA9IGNvbXB1dGVOb3JtYWwoKTtcXG5cXFxuICAgICNlbmRpZlxcblxcXG5cXG5cXFxuICAgIHZlYzQgYmFzZUNvbG9yV2l0aEFscGhhID0gdmVjNCgxLjApO1xcblxcXG4gICAgLy8gUmVnYXJkbGVzcyBvZiB3aGV0aGVyIHdlIHVzZSBQQlIsIHNldCBhIGJhc2UgY29sb3JcXG5cXFxuICAgICNpZmRlZiBIQVNfQkFTRV9DT0xPUl9URVhUVVJFXFxuXFxcbiAgICB2ZWMyIGJhc2VDb2xvclRleENvb3JkcyA9IFRFWENPT1JEX0JBU0VfQ09MT1I7XFxuXFxcblxcblxcXG4gICAgICAgICNpZmRlZiBIQVNfQkFTRV9DT0xPUl9URVhUVVJFX1RSQU5TRk9STVxcblxcXG4gICAgICAgIGJhc2VDb2xvclRleENvb3JkcyA9IGNvbXB1dGVUZXh0dXJlVHJhbnNmb3JtKGJhc2VDb2xvclRleENvb3JkcywgdV9iYXNlQ29sb3JUZXh0dXJlVHJhbnNmb3JtKTtcXG5cXFxuICAgICAgICAjZW5kaWZcXG5cXFxuXFxuXFxcbiAgICBiYXNlQ29sb3JXaXRoQWxwaGEgPSBTUkdCdG9MSU5FQVI0KHRleHR1cmUyRCh1X2Jhc2VDb2xvclRleHR1cmUsIGJhc2VDb2xvclRleENvb3JkcykpO1xcblxcXG5cXG5cXFxuICAgICAgICAjaWZkZWYgSEFTX0JBU0VfQ09MT1JfRkFDVE9SXFxuXFxcbiAgICAgICAgYmFzZUNvbG9yV2l0aEFscGhhICo9IHVfYmFzZUNvbG9yRmFjdG9yO1xcblxcXG4gICAgICAgICNlbmRpZlxcblxcXG4gICAgI2VsaWYgZGVmaW5lZChIQVNfQkFTRV9DT0xPUl9GQUNUT1IpXFxuXFxcbiAgICBiYXNlQ29sb3JXaXRoQWxwaGEgPSB1X2Jhc2VDb2xvckZhY3RvcjtcXG5cXFxuICAgICNlbmRpZlxcblxcXG5cXG5cXFxuICAgICNpZmRlZiBIQVNfQ09MT1JfMFxcblxcXG4gICAgYmFzZUNvbG9yV2l0aEFscGhhICo9IHZfY29sb3JfMDtcXG5cXFxuICAgICNlbmRpZlxcblxcXG5cXG5cXFxuICAgIG1hdGVyaWFsLmRpZmZ1c2UgPSBiYXNlQ29sb3JXaXRoQWxwaGEucmdiO1xcblxcXG4gICAgbWF0ZXJpYWwuYWxwaGEgPSBiYXNlQ29sb3JXaXRoQWxwaGEuYTtcXG5cXFxuXFxuXFxcbiAgICAjaWZkZWYgSEFTX09DQ0xVU0lPTl9URVhUVVJFXFxuXFxcbiAgICB2ZWMyIG9jY2x1c2lvblRleENvb3JkcyA9IFRFWENPT1JEX09DQ0xVU0lPTjtcXG5cXFxuICAgICAgICAjaWZkZWYgSEFTX09DQ0xVU0lPTl9URVhUVVJFX1RSQU5TRk9STVxcblxcXG4gICAgICAgIG9jY2x1c2lvblRleENvb3JkcyA9IGNvbXB1dGVUZXh0dXJlVHJhbnNmb3JtKG9jY2x1c2lvblRleENvb3JkcywgdV9vY2NsdXNpb25UZXh0dXJlVHJhbnNmb3JtKTtcXG5cXFxuICAgICAgICAjZW5kaWZcXG5cXFxuICAgIG1hdGVyaWFsLm9jY2x1c2lvbiA9IHRleHR1cmUyRCh1X29jY2x1c2lvblRleHR1cmUsIG9jY2x1c2lvblRleENvb3JkcykucjtcXG5cXFxuICAgICNlbmRpZlxcblxcXG5cXG5cXFxuICAgICNpZmRlZiBIQVNfRU1JU1NJVkVfVEVYVFVSRVxcblxcXG4gICAgdmVjMiBlbWlzc2l2ZVRleENvb3JkcyA9IFRFWENPT1JEX0VNSVNTSVZFO1xcblxcXG4gICAgICAgICNpZmRlZiBIQVNfRU1JU1NJVkVfVEVYVFVSRV9UUkFOU0ZPUk1cXG5cXFxuICAgICAgICBlbWlzc2l2ZVRleENvb3JkcyA9IGNvbXB1dGVUZXh0dXJlVHJhbnNmb3JtKGVtaXNzaXZlVGV4Q29vcmRzLCB1X2VtaXNzaXZlVGV4dHVyZVRyYW5zZm9ybSk7XFxuXFxcbiAgICAgICAgI2VuZGlmXFxuXFxcblxcblxcXG4gICAgdmVjMyBlbWlzc2l2ZSA9IFNSR0J0b0xJTkVBUjModGV4dHVyZTJEKHVfZW1pc3NpdmVUZXh0dXJlLCBlbWlzc2l2ZVRleENvb3JkcykucmdiKTtcXG5cXFxuICAgICAgICAjaWZkZWYgSEFTX0VNSVNTSVZFX0ZBQ1RPUlxcblxcXG4gICAgICAgIGVtaXNzaXZlICo9IHVfZW1pc3NpdmVGYWN0b3I7XFxuXFxcbiAgICAgICAgI2VuZGlmXFxuXFxcbiAgICBtYXRlcmlhbC5lbWlzc2l2ZSA9IGVtaXNzaXZlO1xcblxcXG4gICAgI2VsaWYgZGVmaW5lZChIQVNfRU1JU1NJVkVfRkFDVE9SKVxcblxcXG4gICAgbWF0ZXJpYWwuZW1pc3NpdmUgPSB1X2VtaXNzaXZlRmFjdG9yO1xcblxcXG4gICAgI2VuZGlmXFxuXFxcblxcblxcXG4gICAgI2lmIGRlZmluZWQoTElHSFRJTkdfUEJSKSAmJiBkZWZpbmVkKFVTRV9TUEVDVUxBUl9HTE9TU0lORVNTKVxcblxcXG4gICAgICAgICNpZmRlZiBIQVNfU1BFQ1VMQVJfR0xPU1NJTkVTU19URVhUVVJFXFxuXFxcbiAgICAgICAgdmVjMiBzcGVjdWxhckdsb3NzaW5lc3NUZXhDb29yZHMgPSBURVhDT09SRF9TUEVDVUxBUl9HTE9TU0lORVNTO1xcblxcXG4gICAgICAgICAgI2lmZGVmIEhBU19TUEVDVUxBUl9HTE9TU0lORVNTX1RFWFRVUkVfVFJBTlNGT1JNXFxuXFxcbiAgICAgICAgICBzcGVjdWxhckdsb3NzaW5lc3NUZXhDb29yZHMgPSBjb21wdXRlVGV4dHVyZVRyYW5zZm9ybShzcGVjdWxhckdsb3NzaW5lc3NUZXhDb29yZHMsIHVfc3BlY3VsYXJHbG9zc2luZXNzVGV4dHVyZVRyYW5zZm9ybSk7XFxuXFxcbiAgICAgICAgICAjZW5kaWZcXG5cXFxuXFxuXFxcbiAgICAgICAgdmVjNCBzcGVjdWxhckdsb3NzaW5lc3MgPSBTUkdCdG9MSU5FQVI0KHRleHR1cmUyRCh1X3NwZWN1bGFyR2xvc3NpbmVzc1RleHR1cmUsIHNwZWN1bGFyR2xvc3NpbmVzc1RleENvb3JkcykpO1xcblxcXG4gICAgICAgIHZlYzMgc3BlY3VsYXIgPSBzcGVjdWxhckdsb3NzaW5lc3MucmdiO1xcblxcXG4gICAgICAgIGZsb2F0IGdsb3NzaW5lc3MgPSBzcGVjdWxhckdsb3NzaW5lc3MuYTtcXG5cXFxuICAgICAgICAgICAgI2lmZGVmIEhBU19TUEVDVUxBUl9GQUNUT1JcXG5cXFxuICAgICAgICAgICAgc3BlY3VsYXIgKj0gdV9zcGVjdWxhckZhY3RvcjtcXG5cXFxuICAgICAgICAgICAgI2VuZGlmXFxuXFxcblxcblxcXG4gICAgICAgICAgICAjaWZkZWYgSEFTX0dMT1NTSU5FU1NfRkFDVE9SXFxuXFxcbiAgICAgICAgICAgIGdsb3NzaW5lc3MgKj0gdV9nbG9zc2luZXNzRmFjdG9yO1xcblxcXG4gICAgICAgICAgICAjZW5kaWZcXG5cXFxuICAgICAgICAjZWxzZVxcblxcXG4gICAgICAgICAgICAjaWZkZWYgSEFTX1NQRUNVTEFSX0ZBQ1RPUlxcblxcXG4gICAgICAgICAgICB2ZWMzIHNwZWN1bGFyID0gY2xhbXAodV9zcGVjdWxhckZhY3RvciwgdmVjMygwLjApLCB2ZWMzKDEuMCkpO1xcblxcXG4gICAgICAgICAgICAjZWxzZVxcblxcXG4gICAgICAgICAgICB2ZWMzIHNwZWN1bGFyID0gdmVjMygxLjApO1xcblxcXG4gICAgICAgICAgICAjZW5kaWZcXG5cXFxuXFxuXFxcbiAgICAgICAgICAgICNpZmRlZiBIQVNfR0xPU1NJTkVTU19GQUNUT1JcXG5cXFxuICAgICAgICAgICAgZmxvYXQgZ2xvc3NpbmVzcyA9IGNsYW1wKHVfZ2xvc3NpbmVzc0ZhY3RvciwgMC4wLCAxLjApO1xcblxcXG4gICAgICAgICAgICAjZWxzZVxcblxcXG4gICAgICAgICAgICBmbG9hdCBnbG9zc2luZXNzID0gMS4wO1xcblxcXG4gICAgICAgICAgICAjZW5kaWZcXG5cXFxuICAgICAgICAjZW5kaWZcXG5cXFxuXFxuXFxcbiAgICAgICAgI2lmZGVmIEhBU19ESUZGVVNFX1RFWFRVUkVcXG5cXFxuICAgICAgICB2ZWMyIGRpZmZ1c2VUZXhDb29yZHMgPSBURVhDT09SRF9ESUZGVVNFO1xcblxcXG4gICAgICAgICAgICAjaWZkZWYgSEFTX0RJRkZVU0VfVEVYVFVSRV9UUkFOU0ZPUk1cXG5cXFxuICAgICAgICAgICAgZGlmZnVzZVRleENvb3JkcyA9IGNvbXB1dGVUZXh0dXJlVHJhbnNmb3JtKGRpZmZ1c2VUZXhDb29yZHMsIHVfZGlmZnVzZVRleHR1cmVUcmFuc2Zvcm0pO1xcblxcXG4gICAgICAgICAgICAjZW5kaWZcXG5cXFxuXFxuXFxcbiAgICAgICAgdmVjNCBkaWZmdXNlID0gU1JHQnRvTElORUFSNCh0ZXh0dXJlMkQodV9kaWZmdXNlVGV4dHVyZSwgZGlmZnVzZVRleENvb3JkcykpO1xcblxcXG4gICAgICAgICAgICAjaWZkZWYgSEFTX0RJRkZVU0VfRkFDVE9SXFxuXFxcbiAgICAgICAgICAgIGRpZmZ1c2UgKj0gdV9kaWZmdXNlRmFjdG9yO1xcblxcXG4gICAgICAgICAgICAjZW5kaWZcXG5cXFxuICAgICAgICAjZWxpZiBkZWZpbmVkKEhBU19ESUZGVVNFX0ZBQ1RPUilcXG5cXFxuICAgICAgICB2ZWM0IGRpZmZ1c2UgPSBjbGFtcCh1X2RpZmZ1c2VGYWN0b3IsIHZlYzQoMC4wKSwgdmVjNCgxLjApKTtcXG5cXFxuICAgICAgICAjZWxzZVxcblxcXG4gICAgICAgIHZlYzQgZGlmZnVzZSA9IHZlYzQoMS4wKTtcXG5cXFxuICAgICAgICAjZW5kaWZcXG5cXFxuICAgIGN6bV9wYnJQYXJhbWV0ZXJzIHBhcmFtZXRlcnMgPSBjem1fcGJyU3BlY3VsYXJHbG9zc2luZXNzTWF0ZXJpYWwoXFxuXFxcbiAgICAgIGRpZmZ1c2UucmdiLFxcblxcXG4gICAgICBzcGVjdWxhcixcXG5cXFxuICAgICAgZ2xvc3NpbmVzc1xcblxcXG4gICAgKTtcXG5cXFxuICAgIG1hdGVyaWFsLmRpZmZ1c2UgPSBwYXJhbWV0ZXJzLmRpZmZ1c2VDb2xvcjtcXG5cXFxuICAgIG1hdGVyaWFsLnNwZWN1bGFyID0gcGFyYW1ldGVycy5mMDtcXG5cXFxuICAgIG1hdGVyaWFsLnJvdWdobmVzcyA9IHBhcmFtZXRlcnMucm91Z2huZXNzO1xcblxcXG4gICAgI2VsaWYgZGVmaW5lZChMSUdIVElOR19QQlIpXFxuXFxcbiAgICAgICAgI2lmZGVmIEhBU19NRVRBTExJQ19ST1VHSE5FU1NfVEVYVFVSRVxcblxcXG4gICAgICAgIHZlYzIgbWV0YWxsaWNSb3VnaG5lc3NUZXhDb29yZHMgPSBURVhDT09SRF9NRVRBTExJQ19ST1VHSE5FU1M7XFxuXFxcbiAgICAgICAgICAgICNpZmRlZiBIQVNfTUVUQUxMSUNfUk9VR0hORVNTX1RFWFRVUkVfVFJBTlNGT1JNXFxuXFxcbiAgICAgICAgICAgIG1ldGFsbGljUm91Z2huZXNzVGV4Q29vcmRzID0gY29tcHV0ZVRleHR1cmVUcmFuc2Zvcm0obWV0YWxsaWNSb3VnaG5lc3NUZXhDb29yZHMsIHVfbWV0YWxsaWNSb3VnaG5lc3NUZXh0dXJlVHJhbnNmb3JtKTtcXG5cXFxuICAgICAgICAgICAgI2VuZGlmXFxuXFxcblxcblxcXG4gICAgICAgIHZlYzMgbWV0YWxsaWNSb3VnaG5lc3MgPSB0ZXh0dXJlMkQodV9tZXRhbGxpY1JvdWdobmVzc1RleHR1cmUsIG1ldGFsbGljUm91Z2huZXNzVGV4Q29vcmRzKS5yZ2I7XFxuXFxcbiAgICAgICAgZmxvYXQgbWV0YWxuZXNzID0gY2xhbXAobWV0YWxsaWNSb3VnaG5lc3MuYiwgMC4wLCAxLjApO1xcblxcXG4gICAgICAgIGZsb2F0IHJvdWdobmVzcyA9IGNsYW1wKG1ldGFsbGljUm91Z2huZXNzLmcsIDAuMDQsIDEuMCk7XFxuXFxcbiAgICAgICAgICAgICNpZmRlZiBIQVNfTUVUQUxMSUNfRkFDVE9SXFxuXFxcbiAgICAgICAgICAgIG1ldGFsbmVzcyAqPSB1X21ldGFsbGljRmFjdG9yO1xcblxcXG4gICAgICAgICAgICAjZW5kaWZcXG5cXFxuXFxuXFxcbiAgICAgICAgICAgICNpZmRlZiBIQVNfUk9VR0hORVNTX0ZBQ1RPUlxcblxcXG4gICAgICAgICAgICByb3VnaG5lc3MgKj0gdV9yb3VnaG5lc3NGYWN0b3I7XFxuXFxcbiAgICAgICAgICAgICNlbmRpZlxcblxcXG4gICAgICAgICNlbHNlXFxuXFxcbiAgICAgICAgICAgICNpZmRlZiBIQVNfTUVUQUxMSUNfRkFDVE9SXFxuXFxcbiAgICAgICAgICAgIGZsb2F0IG1ldGFsbmVzcyA9IGNsYW1wKHVfbWV0YWxsaWNGYWN0b3IsIDAuMCwgMS4wKTtcXG5cXFxuICAgICAgICAgICAgI2Vsc2VcXG5cXFxuICAgICAgICAgICAgZmxvYXQgbWV0YWxuZXNzID0gMS4wO1xcblxcXG4gICAgICAgICAgICAjZW5kaWZcXG5cXFxuXFxuXFxcbiAgICAgICAgICAgICNpZmRlZiBIQVNfUk9VR0hORVNTX0ZBQ1RPUlxcblxcXG4gICAgICAgICAgICBmbG9hdCByb3VnaG5lc3MgPSBjbGFtcCh1X3JvdWdobmVzc0ZhY3RvciwgMC4wNCwgMS4wKTtcXG5cXFxuICAgICAgICAgICAgI2Vsc2VcXG5cXFxuICAgICAgICAgICAgZmxvYXQgcm91Z2huZXNzID0gMS4wO1xcblxcXG4gICAgICAgICAgICAjZW5kaWZcXG5cXFxuICAgICAgICAjZW5kaWZcXG5cXFxuICAgIGN6bV9wYnJQYXJhbWV0ZXJzIHBhcmFtZXRlcnMgPSBjem1fcGJyTWV0YWxsaWNSb3VnaG5lc3NNYXRlcmlhbChcXG5cXFxuICAgICAgbWF0ZXJpYWwuZGlmZnVzZSxcXG5cXFxuICAgICAgbWV0YWxuZXNzLFxcblxcXG4gICAgICByb3VnaG5lc3NcXG5cXFxuICAgICk7XFxuXFxcbiAgICBtYXRlcmlhbC5kaWZmdXNlID0gcGFyYW1ldGVycy5kaWZmdXNlQ29sb3I7XFxuXFxcbiAgICBtYXRlcmlhbC5zcGVjdWxhciA9IHBhcmFtZXRlcnMuZjA7XFxuXFxcbiAgICBtYXRlcmlhbC5yb3VnaG5lc3MgPSBwYXJhbWV0ZXJzLnJvdWdobmVzcztcXG5cXFxuICAgICNlbmRpZlxcblxcXG5cXG5cXFxuICAgIHJldHVybiBtYXRlcmlhbDtcXG5cXFxufVwiO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///92667\n')},3166:function(__unused_webpack___webpack_module__,__webpack_exports__){eval('//This file is automatically rebuilt by the Cesium build process.\n/* harmony default export */ __webpack_exports__["Z"] = ("#if defined(HAS_NORMALS) && !defined(HAS_TANGENTS) && !defined(LIGHTING_UNLIT)\\n\\\n    #ifdef GL_OES_standard_derivatives\\n\\\n    #extension GL_OES_standard_derivatives : enable\\n\\\n    #endif\\n\\\n#endif\\n\\\n\\n\\\nczm_modelMaterial defaultModelMaterial()\\n\\\n{\\n\\\n    czm_modelMaterial material;\\n\\\n    material.diffuse = vec3(1.0);\\n\\\n    material.specular = vec3(0.04); // dielectric (non-metal)\\n\\\n    material.roughness = 0.0;\\n\\\n    material.occlusion = 1.0;\\n\\\n    material.normal = vec3(0.0, 0.0, 1.0);\\n\\\n    material.emissive = vec3(0.0);\\n\\\n    material.alpha = 1.0;\\n\\\n    return material;\\n\\\n}\\n\\\n\\n\\\nvec4 handleAlpha(vec3 color, float alpha)\\n\\\n{\\n\\\n    #ifdef ALPHA_MODE_MASK\\n\\\n    if (alpha < u_alphaCutoff) {\\n\\\n        discard;\\n\\\n    }\\n\\\n    return vec4(color, 1.0);\\n\\\n    #elif defined(ALPHA_MODE_BLEND)\\n\\\n    return vec4(color, alpha);\\n\\\n    #else // OPAQUE\\n\\\n    return vec4(color, 1.0);\\n\\\n    #endif\\n\\\n}\\n\\\n\\n\\\nvoid main() \\n\\\n{\\n\\\n    czm_modelMaterial material = defaultModelMaterial();\\n\\\n\\n\\\n    #ifndef CUSTOM_SHADER_REPLACE_MATERIAL\\n\\\n    material = materialStage(material);\\n\\\n    #endif\\n\\\n\\n\\\n    #if defined(CUSTOM_SHADER_MODIFY_MATERIAL) || defined(CUSTOM_SHADER_REPLACE_MATERIAL) \\n\\\n    material = customShaderStage(material);\\n\\\n    #endif\\n\\\n\\n\\\n    material = lightingStage(material);\\n\\\n\\n\\\n    vec4 color = handleAlpha(material.diffuse, material.alpha);\\n\\\n    gl_FragColor = color;\\n\\\n}\\n\\\n");\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMzE2Ni5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBLHlEQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNELCtCQUErQjtBQUMvQixpQ0FBaUM7QUFDakMsb0NBQW9DO0FBQ3BDLDZCQUE2QjtBQUM3Qiw2QkFBNkI7QUFDN0IsMENBQTBDO0FBQzFDLGtDQUFrQztBQUNsQyx5QkFBeUI7QUFDekIsb0JBQW9CO0FBQ3BCLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0EsZ0NBQWdDO0FBQ2hDLGdCQUFnQjtBQUNoQixLQUFLO0FBQ0wsNEJBQTRCO0FBQzVCO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Qsd0RBQXdEO0FBQ3hEO0FBQ0E7QUFDQSx1Q0FBdUM7QUFDdkM7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDO0FBQzNDO0FBQ0E7QUFDQSx1Q0FBdUM7QUFDdkM7QUFDQSwrREFBK0Q7QUFDL0QseUJBQXlCO0FBQ3pCLENBQUM7QUFDRCxDQUFDLEVBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly92dWUzLXdlYnBhY2s1Ly4vbm9kZV9tb2R1bGVzL2Nlc2l1bS9Tb3VyY2UvU2hhZGVycy9Nb2RlbEV4cGVyaW1lbnRhbC9Nb2RlbEV4cGVyaW1lbnRhbEZTLmpzPzJlN2QiXSwic291cmNlc0NvbnRlbnQiOlsiLy9UaGlzIGZpbGUgaXMgYXV0b21hdGljYWxseSByZWJ1aWx0IGJ5IHRoZSBDZXNpdW0gYnVpbGQgcHJvY2Vzcy5cbmV4cG9ydCBkZWZhdWx0IFwiI2lmIGRlZmluZWQoSEFTX05PUk1BTFMpICYmICFkZWZpbmVkKEhBU19UQU5HRU5UUykgJiYgIWRlZmluZWQoTElHSFRJTkdfVU5MSVQpXFxuXFxcbiAgICAjaWZkZWYgR0xfT0VTX3N0YW5kYXJkX2Rlcml2YXRpdmVzXFxuXFxcbiAgICAjZXh0ZW5zaW9uIEdMX09FU19zdGFuZGFyZF9kZXJpdmF0aXZlcyA6IGVuYWJsZVxcblxcXG4gICAgI2VuZGlmXFxuXFxcbiNlbmRpZlxcblxcXG5cXG5cXFxuY3ptX21vZGVsTWF0ZXJpYWwgZGVmYXVsdE1vZGVsTWF0ZXJpYWwoKVxcblxcXG57XFxuXFxcbiAgICBjem1fbW9kZWxNYXRlcmlhbCBtYXRlcmlhbDtcXG5cXFxuICAgIG1hdGVyaWFsLmRpZmZ1c2UgPSB2ZWMzKDEuMCk7XFxuXFxcbiAgICBtYXRlcmlhbC5zcGVjdWxhciA9IHZlYzMoMC4wNCk7IC8vIGRpZWxlY3RyaWMgKG5vbi1tZXRhbClcXG5cXFxuICAgIG1hdGVyaWFsLnJvdWdobmVzcyA9IDAuMDtcXG5cXFxuICAgIG1hdGVyaWFsLm9jY2x1c2lvbiA9IDEuMDtcXG5cXFxuICAgIG1hdGVyaWFsLm5vcm1hbCA9IHZlYzMoMC4wLCAwLjAsIDEuMCk7XFxuXFxcbiAgICBtYXRlcmlhbC5lbWlzc2l2ZSA9IHZlYzMoMC4wKTtcXG5cXFxuICAgIG1hdGVyaWFsLmFscGhhID0gMS4wO1xcblxcXG4gICAgcmV0dXJuIG1hdGVyaWFsO1xcblxcXG59XFxuXFxcblxcblxcXG52ZWM0IGhhbmRsZUFscGhhKHZlYzMgY29sb3IsIGZsb2F0IGFscGhhKVxcblxcXG57XFxuXFxcbiAgICAjaWZkZWYgQUxQSEFfTU9ERV9NQVNLXFxuXFxcbiAgICBpZiAoYWxwaGEgPCB1X2FscGhhQ3V0b2ZmKSB7XFxuXFxcbiAgICAgICAgZGlzY2FyZDtcXG5cXFxuICAgIH1cXG5cXFxuICAgIHJldHVybiB2ZWM0KGNvbG9yLCAxLjApO1xcblxcXG4gICAgI2VsaWYgZGVmaW5lZChBTFBIQV9NT0RFX0JMRU5EKVxcblxcXG4gICAgcmV0dXJuIHZlYzQoY29sb3IsIGFscGhhKTtcXG5cXFxuICAgICNlbHNlIC8vIE9QQVFVRVxcblxcXG4gICAgcmV0dXJuIHZlYzQoY29sb3IsIDEuMCk7XFxuXFxcbiAgICAjZW5kaWZcXG5cXFxufVxcblxcXG5cXG5cXFxudm9pZCBtYWluKCkgXFxuXFxcbntcXG5cXFxuICAgIGN6bV9tb2RlbE1hdGVyaWFsIG1hdGVyaWFsID0gZGVmYXVsdE1vZGVsTWF0ZXJpYWwoKTtcXG5cXFxuXFxuXFxcbiAgICAjaWZuZGVmIENVU1RPTV9TSEFERVJfUkVQTEFDRV9NQVRFUklBTFxcblxcXG4gICAgbWF0ZXJpYWwgPSBtYXRlcmlhbFN0YWdlKG1hdGVyaWFsKTtcXG5cXFxuICAgICNlbmRpZlxcblxcXG5cXG5cXFxuICAgICNpZiBkZWZpbmVkKENVU1RPTV9TSEFERVJfTU9ESUZZX01BVEVSSUFMKSB8fCBkZWZpbmVkKENVU1RPTV9TSEFERVJfUkVQTEFDRV9NQVRFUklBTCkgXFxuXFxcbiAgICBtYXRlcmlhbCA9IGN1c3RvbVNoYWRlclN0YWdlKG1hdGVyaWFsKTtcXG5cXFxuICAgICNlbmRpZlxcblxcXG5cXG5cXFxuICAgIG1hdGVyaWFsID0gbGlnaHRpbmdTdGFnZShtYXRlcmlhbCk7XFxuXFxcblxcblxcXG4gICAgdmVjNCBjb2xvciA9IGhhbmRsZUFscGhhKG1hdGVyaWFsLmRpZmZ1c2UsIG1hdGVyaWFsLmFscGhhKTtcXG5cXFxuICAgIGdsX0ZyYWdDb2xvciA9IGNvbG9yO1xcblxcXG59XFxuXFxcblwiO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///3166\n')},73373:function(__unused_webpack___webpack_module__,__webpack_exports__){eval('//This file is automatically rebuilt by the Cesium build process.\n/* harmony default export */ __webpack_exports__["Z"] = ("precision highp float;\\n\\\n\\n\\\nvoid main() \\n\\\n{\\n\\\n    vec3 position = vec3(0.0);  \\n\\\n\\n\\\n    position = processGeometry(position);\\n\\\n\\n\\\n    #ifdef HAS_INSTANCING\\n\\\n    position = instancingStage(position);\\n\\\n        #ifdef USE_PICKING\\n\\\n        v_pickColor = a_pickColor;\\n\\\n        #endif\\n\\\n    #endif\\n\\\n\\n\\\n    #ifdef USE_CUSTOM_SHADER\\n\\\n    position = customShaderStage(position);\\n\\\n    #endif\\n\\\n\\n\\\n    gl_Position = czm_modelViewProjection * vec4(position, 1.0);\\n\\\n\\n\\\n    #ifdef PRIMITIVE_TYPE_POINTS\\n\\\n    processPoints();\\n\\\n    #endif\\n\\\n}");\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNzMzNzMuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQSx5REFBZSx1QkFBdUI7QUFDdEM7QUFDQTtBQUNBLENBQUM7QUFDRCxnQ0FBZ0M7QUFDaEM7QUFDQSx5Q0FBeUM7QUFDekM7QUFDQTtBQUNBLHlDQUF5QztBQUN6QztBQUNBLGtDQUFrQztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQztBQUMzQztBQUNBO0FBQ0EsZ0VBQWdFO0FBQ2hFO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQSxDQUFDLENBQUMsRUFBQyIsInNvdXJjZXMiOlsid2VicGFjazovL3Z1ZTMtd2VicGFjazUvLi9ub2RlX21vZHVsZXMvY2VzaXVtL1NvdXJjZS9TaGFkZXJzL01vZGVsRXhwZXJpbWVudGFsL01vZGVsRXhwZXJpbWVudGFsVlMuanM/OGFmYyJdLCJzb3VyY2VzQ29udGVudCI6WyIvL1RoaXMgZmlsZSBpcyBhdXRvbWF0aWNhbGx5IHJlYnVpbHQgYnkgdGhlIENlc2l1bSBidWlsZCBwcm9jZXNzLlxuZXhwb3J0IGRlZmF1bHQgXCJwcmVjaXNpb24gaGlnaHAgZmxvYXQ7XFxuXFxcblxcblxcXG52b2lkIG1haW4oKSBcXG5cXFxue1xcblxcXG4gICAgdmVjMyBwb3NpdGlvbiA9IHZlYzMoMC4wKTsgIFxcblxcXG5cXG5cXFxuICAgIHBvc2l0aW9uID0gcHJvY2Vzc0dlb21ldHJ5KHBvc2l0aW9uKTtcXG5cXFxuXFxuXFxcbiAgICAjaWZkZWYgSEFTX0lOU1RBTkNJTkdcXG5cXFxuICAgIHBvc2l0aW9uID0gaW5zdGFuY2luZ1N0YWdlKHBvc2l0aW9uKTtcXG5cXFxuICAgICAgICAjaWZkZWYgVVNFX1BJQ0tJTkdcXG5cXFxuICAgICAgICB2X3BpY2tDb2xvciA9IGFfcGlja0NvbG9yO1xcblxcXG4gICAgICAgICNlbmRpZlxcblxcXG4gICAgI2VuZGlmXFxuXFxcblxcblxcXG4gICAgI2lmZGVmIFVTRV9DVVNUT01fU0hBREVSXFxuXFxcbiAgICBwb3NpdGlvbiA9IGN1c3RvbVNoYWRlclN0YWdlKHBvc2l0aW9uKTtcXG5cXFxuICAgICNlbmRpZlxcblxcXG5cXG5cXFxuICAgIGdsX1Bvc2l0aW9uID0gY3ptX21vZGVsVmlld1Byb2plY3Rpb24gKiB2ZWM0KHBvc2l0aW9uLCAxLjApO1xcblxcXG5cXG5cXFxuICAgICNpZmRlZiBQUklNSVRJVkVfVFlQRV9QT0lOVFNcXG5cXFxuICAgIHByb2Nlc3NQb2ludHMoKTtcXG5cXFxuICAgICNlbmRpZlxcblxcXG59XCI7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///73373\n')},60120:function(__unused_webpack___webpack_module__,__webpack_exports__){eval('//This file is automatically rebuilt by the Cesium build process.\n/* harmony default export */ __webpack_exports__["Z"] = ("varying vec2 v_textureCoordinates;\\n\\\n\\n\\\nuniform float originalSize;\\n\\\nuniform sampler2D texture0;\\n\\\nuniform sampler2D texture1;\\n\\\nuniform sampler2D texture2;\\n\\\nuniform sampler2D texture3;\\n\\\nuniform sampler2D texture4;\\n\\\nuniform sampler2D texture5;\\n\\\n\\n\\\nconst float yMipLevel1 = 1.0 - (1.0 / pow(2.0, 1.0));\\n\\\nconst float yMipLevel2 = 1.0 - (1.0 / pow(2.0, 2.0));\\n\\\nconst float yMipLevel3 = 1.0 - (1.0 / pow(2.0, 3.0));\\n\\\nconst float yMipLevel4 = 1.0 - (1.0 / pow(2.0, 4.0));\\n\\\n\\n\\\nvoid main()\\n\\\n{\\n\\\n    vec2 uv = v_textureCoordinates;\\n\\\n    vec2 textureSize = vec2(originalSize * 1.5 + 2.0, originalSize);\\n\\\n    vec2 pixel = 1.0 / textureSize;\\n\\\n\\n\\\n    float mipLevel = 0.0;\\n\\\n\\n\\\n    if (uv.x - pixel.x > (textureSize.y / textureSize.x))\\n\\\n    {\\n\\\n        mipLevel = 1.0;\\n\\\n        if (uv.y - pixel.y > yMipLevel1)\\n\\\n        {\\n\\\n            mipLevel = 2.0;\\n\\\n            if (uv.y - pixel.y * 3.0 > yMipLevel2)\\n\\\n            {\\n\\\n                mipLevel = 3.0;\\n\\\n                if (uv.y - pixel.y * 5.0 > yMipLevel3)\\n\\\n                {\\n\\\n                    mipLevel = 4.0;\\n\\\n                    if (uv.y - pixel.y * 7.0 > yMipLevel4)\\n\\\n                    {\\n\\\n                        mipLevel = 5.0;\\n\\\n                    }\\n\\\n                }\\n\\\n            }\\n\\\n        }\\n\\\n    }\\n\\\n\\n\\\n    if (mipLevel > 0.0)\\n\\\n    {\\n\\\n        float scale = pow(2.0, mipLevel);\\n\\\n\\n\\\n        uv.y -= (pixel.y * (mipLevel - 1.0) * 2.0);\\n\\\n        uv.x *= ((textureSize.x - 2.0) / textureSize.y);\\n\\\n\\n\\\n        uv.x -= 1.0 + pixel.x;\\n\\\n        uv.y -= (1.0 - (1.0 / pow(2.0, mipLevel - 1.0)));\\n\\\n        uv *= scale;\\n\\\n    }\\n\\\n    else\\n\\\n    {\\n\\\n        uv.x *= (textureSize.x / textureSize.y);\\n\\\n    }\\n\\\n\\n\\\n    if(mipLevel == 0.0)\\n\\\n    {\\n\\\n        gl_FragColor = texture2D(texture0, uv);\\n\\\n    }\\n\\\n    else if(mipLevel == 1.0)\\n\\\n    {\\n\\\n        gl_FragColor = texture2D(texture1, uv);\\n\\\n    }\\n\\\n    else if(mipLevel == 2.0)\\n\\\n    {\\n\\\n        gl_FragColor = texture2D(texture2, uv);\\n\\\n    }\\n\\\n    else if(mipLevel == 3.0)\\n\\\n    {\\n\\\n        gl_FragColor = texture2D(texture3, uv);\\n\\\n    }\\n\\\n    else if(mipLevel == 4.0)\\n\\\n    {\\n\\\n        gl_FragColor = texture2D(texture4, uv);\\n\\\n    }\\n\\\n    else if(mipLevel == 5.0)\\n\\\n    {\\n\\\n        gl_FragColor = texture2D(texture5, uv);\\n\\\n    }\\n\\\n    else\\n\\\n    {\\n\\\n        gl_FragColor = vec4(0.0);\\n\\\n    }\\n\\\n}\\n\\\n");\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNjAxMjAuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQSx5REFBZSxtQ0FBbUM7QUFDbEQ7QUFDQSwyQkFBMkI7QUFDM0IsMkJBQTJCO0FBQzNCLDJCQUEyQjtBQUMzQiwyQkFBMkI7QUFDM0IsMkJBQTJCO0FBQzNCLDJCQUEyQjtBQUMzQiwyQkFBMkI7QUFDM0I7QUFDQSxxREFBcUQ7QUFDckQscURBQXFEO0FBQ3JELHFEQUFxRDtBQUNyRCxxREFBcUQ7QUFDckQ7QUFDQTtBQUNBLENBQUM7QUFDRCxtQ0FBbUM7QUFDbkMsb0VBQW9FO0FBQ3BFLG1DQUFtQztBQUNuQztBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0EsS0FBSztBQUNMLHVCQUF1QjtBQUN2QjtBQUNBLFNBQVM7QUFDVCwyQkFBMkI7QUFDM0I7QUFDQSxhQUFhO0FBQ2IsK0JBQStCO0FBQy9CO0FBQ0EsaUJBQWlCO0FBQ2pCLG1DQUFtQztBQUNuQztBQUNBLHFCQUFxQjtBQUNyQix1Q0FBdUM7QUFDdkMscUJBQXFCO0FBQ3JCLGlCQUFpQjtBQUNqQixhQUFhO0FBQ2IsU0FBUztBQUNULEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMLHlDQUF5QztBQUN6QztBQUNBLG1EQUFtRDtBQUNuRCx3REFBd0Q7QUFDeEQ7QUFDQSw4QkFBOEI7QUFDOUIseURBQXlEO0FBQ3pELG9CQUFvQjtBQUNwQixLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0wsZ0RBQWdEO0FBQ2hELEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMLCtDQUErQztBQUMvQyxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0wsK0NBQStDO0FBQy9DLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTCwrQ0FBK0M7QUFDL0MsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMLCtDQUErQztBQUMvQyxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0wsK0NBQStDO0FBQy9DLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTCwrQ0FBK0M7QUFDL0MsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMLGlDQUFpQztBQUNqQyxLQUFLO0FBQ0wsQ0FBQztBQUNELENBQUMsRUFBQyIsInNvdXJjZXMiOlsid2VicGFjazovL3Z1ZTMtd2VicGFjazUvLi9ub2RlX21vZHVsZXMvY2VzaXVtL1NvdXJjZS9TaGFkZXJzL09jdGFoZWRyYWxQcm9qZWN0aW9uQXRsYXNGUy5qcz81ZGU0Il0sInNvdXJjZXNDb250ZW50IjpbIi8vVGhpcyBmaWxlIGlzIGF1dG9tYXRpY2FsbHkgcmVidWlsdCBieSB0aGUgQ2VzaXVtIGJ1aWxkIHByb2Nlc3MuXG5leHBvcnQgZGVmYXVsdCBcInZhcnlpbmcgdmVjMiB2X3RleHR1cmVDb29yZGluYXRlcztcXG5cXFxuXFxuXFxcbnVuaWZvcm0gZmxvYXQgb3JpZ2luYWxTaXplO1xcblxcXG51bmlmb3JtIHNhbXBsZXIyRCB0ZXh0dXJlMDtcXG5cXFxudW5pZm9ybSBzYW1wbGVyMkQgdGV4dHVyZTE7XFxuXFxcbnVuaWZvcm0gc2FtcGxlcjJEIHRleHR1cmUyO1xcblxcXG51bmlmb3JtIHNhbXBsZXIyRCB0ZXh0dXJlMztcXG5cXFxudW5pZm9ybSBzYW1wbGVyMkQgdGV4dHVyZTQ7XFxuXFxcbnVuaWZvcm0gc2FtcGxlcjJEIHRleHR1cmU1O1xcblxcXG5cXG5cXFxuY29uc3QgZmxvYXQgeU1pcExldmVsMSA9IDEuMCAtICgxLjAgLyBwb3coMi4wLCAxLjApKTtcXG5cXFxuY29uc3QgZmxvYXQgeU1pcExldmVsMiA9IDEuMCAtICgxLjAgLyBwb3coMi4wLCAyLjApKTtcXG5cXFxuY29uc3QgZmxvYXQgeU1pcExldmVsMyA9IDEuMCAtICgxLjAgLyBwb3coMi4wLCAzLjApKTtcXG5cXFxuY29uc3QgZmxvYXQgeU1pcExldmVsNCA9IDEuMCAtICgxLjAgLyBwb3coMi4wLCA0LjApKTtcXG5cXFxuXFxuXFxcbnZvaWQgbWFpbigpXFxuXFxcbntcXG5cXFxuICAgIHZlYzIgdXYgPSB2X3RleHR1cmVDb29yZGluYXRlcztcXG5cXFxuICAgIHZlYzIgdGV4dHVyZVNpemUgPSB2ZWMyKG9yaWdpbmFsU2l6ZSAqIDEuNSArIDIuMCwgb3JpZ2luYWxTaXplKTtcXG5cXFxuICAgIHZlYzIgcGl4ZWwgPSAxLjAgLyB0ZXh0dXJlU2l6ZTtcXG5cXFxuXFxuXFxcbiAgICBmbG9hdCBtaXBMZXZlbCA9IDAuMDtcXG5cXFxuXFxuXFxcbiAgICBpZiAodXYueCAtIHBpeGVsLnggPiAodGV4dHVyZVNpemUueSAvIHRleHR1cmVTaXplLngpKVxcblxcXG4gICAge1xcblxcXG4gICAgICAgIG1pcExldmVsID0gMS4wO1xcblxcXG4gICAgICAgIGlmICh1di55IC0gcGl4ZWwueSA+IHlNaXBMZXZlbDEpXFxuXFxcbiAgICAgICAge1xcblxcXG4gICAgICAgICAgICBtaXBMZXZlbCA9IDIuMDtcXG5cXFxuICAgICAgICAgICAgaWYgKHV2LnkgLSBwaXhlbC55ICogMy4wID4geU1pcExldmVsMilcXG5cXFxuICAgICAgICAgICAge1xcblxcXG4gICAgICAgICAgICAgICAgbWlwTGV2ZWwgPSAzLjA7XFxuXFxcbiAgICAgICAgICAgICAgICBpZiAodXYueSAtIHBpeGVsLnkgKiA1LjAgPiB5TWlwTGV2ZWwzKVxcblxcXG4gICAgICAgICAgICAgICAge1xcblxcXG4gICAgICAgICAgICAgICAgICAgIG1pcExldmVsID0gNC4wO1xcblxcXG4gICAgICAgICAgICAgICAgICAgIGlmICh1di55IC0gcGl4ZWwueSAqIDcuMCA+IHlNaXBMZXZlbDQpXFxuXFxcbiAgICAgICAgICAgICAgICAgICAge1xcblxcXG4gICAgICAgICAgICAgICAgICAgICAgICBtaXBMZXZlbCA9IDUuMDtcXG5cXFxuICAgICAgICAgICAgICAgICAgICB9XFxuXFxcbiAgICAgICAgICAgICAgICB9XFxuXFxcbiAgICAgICAgICAgIH1cXG5cXFxuICAgICAgICB9XFxuXFxcbiAgICB9XFxuXFxcblxcblxcXG4gICAgaWYgKG1pcExldmVsID4gMC4wKVxcblxcXG4gICAge1xcblxcXG4gICAgICAgIGZsb2F0IHNjYWxlID0gcG93KDIuMCwgbWlwTGV2ZWwpO1xcblxcXG5cXG5cXFxuICAgICAgICB1di55IC09IChwaXhlbC55ICogKG1pcExldmVsIC0gMS4wKSAqIDIuMCk7XFxuXFxcbiAgICAgICAgdXYueCAqPSAoKHRleHR1cmVTaXplLnggLSAyLjApIC8gdGV4dHVyZVNpemUueSk7XFxuXFxcblxcblxcXG4gICAgICAgIHV2LnggLT0gMS4wICsgcGl4ZWwueDtcXG5cXFxuICAgICAgICB1di55IC09ICgxLjAgLSAoMS4wIC8gcG93KDIuMCwgbWlwTGV2ZWwgLSAxLjApKSk7XFxuXFxcbiAgICAgICAgdXYgKj0gc2NhbGU7XFxuXFxcbiAgICB9XFxuXFxcbiAgICBlbHNlXFxuXFxcbiAgICB7XFxuXFxcbiAgICAgICAgdXYueCAqPSAodGV4dHVyZVNpemUueCAvIHRleHR1cmVTaXplLnkpO1xcblxcXG4gICAgfVxcblxcXG5cXG5cXFxuICAgIGlmKG1pcExldmVsID09IDAuMClcXG5cXFxuICAgIHtcXG5cXFxuICAgICAgICBnbF9GcmFnQ29sb3IgPSB0ZXh0dXJlMkQodGV4dHVyZTAsIHV2KTtcXG5cXFxuICAgIH1cXG5cXFxuICAgIGVsc2UgaWYobWlwTGV2ZWwgPT0gMS4wKVxcblxcXG4gICAge1xcblxcXG4gICAgICAgIGdsX0ZyYWdDb2xvciA9IHRleHR1cmUyRCh0ZXh0dXJlMSwgdXYpO1xcblxcXG4gICAgfVxcblxcXG4gICAgZWxzZSBpZihtaXBMZXZlbCA9PSAyLjApXFxuXFxcbiAgICB7XFxuXFxcbiAgICAgICAgZ2xfRnJhZ0NvbG9yID0gdGV4dHVyZTJEKHRleHR1cmUyLCB1dik7XFxuXFxcbiAgICB9XFxuXFxcbiAgICBlbHNlIGlmKG1pcExldmVsID09IDMuMClcXG5cXFxuICAgIHtcXG5cXFxuICAgICAgICBnbF9GcmFnQ29sb3IgPSB0ZXh0dXJlMkQodGV4dHVyZTMsIHV2KTtcXG5cXFxuICAgIH1cXG5cXFxuICAgIGVsc2UgaWYobWlwTGV2ZWwgPT0gNC4wKVxcblxcXG4gICAge1xcblxcXG4gICAgICAgIGdsX0ZyYWdDb2xvciA9IHRleHR1cmUyRCh0ZXh0dXJlNCwgdXYpO1xcblxcXG4gICAgfVxcblxcXG4gICAgZWxzZSBpZihtaXBMZXZlbCA9PSA1LjApXFxuXFxcbiAgICB7XFxuXFxcbiAgICAgICAgZ2xfRnJhZ0NvbG9yID0gdGV4dHVyZTJEKHRleHR1cmU1LCB1dik7XFxuXFxcbiAgICB9XFxuXFxcbiAgICBlbHNlXFxuXFxcbiAgICB7XFxuXFxcbiAgICAgICAgZ2xfRnJhZ0NvbG9yID0gdmVjNCgwLjApO1xcblxcXG4gICAgfVxcblxcXG59XFxuXFxcblwiO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///60120\n')},362:function(__unused_webpack___webpack_module__,__webpack_exports__){eval('//This file is automatically rebuilt by the Cesium build process.\n/* harmony default export */ __webpack_exports__["Z"] = ("varying vec3 v_cubeMapCoordinates;\\n\\\nuniform samplerCube cubeMap;\\n\\\n\\n\\\nvoid main()\\n\\\n{\\n\\\n    vec4 rgba = textureCube(cubeMap, v_cubeMapCoordinates);\\n\\\n    #ifdef RGBA_NORMALIZED\\n\\\n        gl_FragColor = vec4(rgba.rgb, 1.0);\\n\\\n    #else\\n\\\n        float m = rgba.a * 16.0;\\n\\\n        vec3 r = rgba.rgb * m;\\n\\\n        gl_FragColor = vec4(r * r, 1.0);\\n\\\n    #endif\\n\\\n}\\n\\\n");\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMzYyLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0EseURBQWUsbUNBQW1DO0FBQ2xELDRCQUE0QjtBQUM1QjtBQUNBO0FBQ0EsQ0FBQztBQUNELDJEQUEyRDtBQUMzRDtBQUNBLDJDQUEyQztBQUMzQztBQUNBLGdDQUFnQztBQUNoQyw4QkFBOEI7QUFDOUIsd0NBQXdDO0FBQ3hDO0FBQ0EsQ0FBQztBQUNELENBQUMsRUFBQyIsInNvdXJjZXMiOlsid2VicGFjazovL3Z1ZTMtd2VicGFjazUvLi9ub2RlX21vZHVsZXMvY2VzaXVtL1NvdXJjZS9TaGFkZXJzL09jdGFoZWRyYWxQcm9qZWN0aW9uRlMuanM/ODcwZSJdLCJzb3VyY2VzQ29udGVudCI6WyIvL1RoaXMgZmlsZSBpcyBhdXRvbWF0aWNhbGx5IHJlYnVpbHQgYnkgdGhlIENlc2l1bSBidWlsZCBwcm9jZXNzLlxuZXhwb3J0IGRlZmF1bHQgXCJ2YXJ5aW5nIHZlYzMgdl9jdWJlTWFwQ29vcmRpbmF0ZXM7XFxuXFxcbnVuaWZvcm0gc2FtcGxlckN1YmUgY3ViZU1hcDtcXG5cXFxuXFxuXFxcbnZvaWQgbWFpbigpXFxuXFxcbntcXG5cXFxuICAgIHZlYzQgcmdiYSA9IHRleHR1cmVDdWJlKGN1YmVNYXAsIHZfY3ViZU1hcENvb3JkaW5hdGVzKTtcXG5cXFxuICAgICNpZmRlZiBSR0JBX05PUk1BTElaRURcXG5cXFxuICAgICAgICBnbF9GcmFnQ29sb3IgPSB2ZWM0KHJnYmEucmdiLCAxLjApO1xcblxcXG4gICAgI2Vsc2VcXG5cXFxuICAgICAgICBmbG9hdCBtID0gcmdiYS5hICogMTYuMDtcXG5cXFxuICAgICAgICB2ZWMzIHIgPSByZ2JhLnJnYiAqIG07XFxuXFxcbiAgICAgICAgZ2xfRnJhZ0NvbG9yID0gdmVjNChyICogciwgMS4wKTtcXG5cXFxuICAgICNlbmRpZlxcblxcXG59XFxuXFxcblwiO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///362\n')},7736:function(__unused_webpack___webpack_module__,__webpack_exports__){eval('//This file is automatically rebuilt by the Cesium build process.\n/* harmony default export */ __webpack_exports__["Z"] = ("attribute vec4 position;\\n\\\nattribute vec3 cubeMapCoordinates;\\n\\\n\\n\\\nvarying vec3 v_cubeMapCoordinates;\\n\\\n\\n\\\nvoid main()\\n\\\n{\\n\\\n    gl_Position = position;\\n\\\n    v_cubeMapCoordinates = cubeMapCoordinates;\\n\\\n}\\n\\\n");\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNzczNi5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBLHlEQUFlLHlCQUF5QjtBQUN4QyxrQ0FBa0M7QUFDbEM7QUFDQSxrQ0FBa0M7QUFDbEM7QUFDQTtBQUNBLENBQUM7QUFDRCwyQkFBMkI7QUFDM0IsOENBQThDO0FBQzlDLENBQUM7QUFDRCxDQUFDLEVBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly92dWUzLXdlYnBhY2s1Ly4vbm9kZV9tb2R1bGVzL2Nlc2l1bS9Tb3VyY2UvU2hhZGVycy9PY3RhaGVkcmFsUHJvamVjdGlvblZTLmpzPzA0NjciXSwic291cmNlc0NvbnRlbnQiOlsiLy9UaGlzIGZpbGUgaXMgYXV0b21hdGljYWxseSByZWJ1aWx0IGJ5IHRoZSBDZXNpdW0gYnVpbGQgcHJvY2Vzcy5cbmV4cG9ydCBkZWZhdWx0IFwiYXR0cmlidXRlIHZlYzQgcG9zaXRpb247XFxuXFxcbmF0dHJpYnV0ZSB2ZWMzIGN1YmVNYXBDb29yZGluYXRlcztcXG5cXFxuXFxuXFxcbnZhcnlpbmcgdmVjMyB2X2N1YmVNYXBDb29yZGluYXRlcztcXG5cXFxuXFxuXFxcbnZvaWQgbWFpbigpXFxuXFxcbntcXG5cXFxuICAgIGdsX1Bvc2l0aW9uID0gcG9zaXRpb247XFxuXFxcbiAgICB2X2N1YmVNYXBDb29yZGluYXRlcyA9IGN1YmVNYXBDb29yZGluYXRlcztcXG5cXFxufVxcblxcXG5cIjtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///7736\n')},12049:function(__unused_webpack___webpack_module__,__webpack_exports__){eval('//This file is automatically rebuilt by the Cesium build process.\n/* harmony default export */ __webpack_exports__["Z"] = ("varying vec4 v_color;\\n\\\nvarying vec4 v_outlineColor;\\n\\\nvarying float v_innerPercent;\\n\\\nvarying float v_pixelDistance;\\n\\\nvarying vec4 v_pickColor;\\n\\\n\\n\\\nvoid main()\\n\\\n{\\n\\\n    // The distance in UV space from this fragment to the center of the point, at most 0.5.\\n\\\n    float distanceToCenter = length(gl_PointCoord - vec2(0.5));\\n\\\n    // The max distance stops one pixel shy of the edge to leave space for anti-aliasing.\\n\\\n    float maxDistance = max(0.0, 0.5 - v_pixelDistance);\\n\\\n    float wholeAlpha = 1.0 - smoothstep(maxDistance, 0.5, distanceToCenter);\\n\\\n    float innerAlpha = 1.0 - smoothstep(maxDistance * v_innerPercent, 0.5 * v_innerPercent, distanceToCenter);\\n\\\n\\n\\\n    vec4 color = mix(v_outlineColor, v_color, innerAlpha);\\n\\\n    color.a *= wholeAlpha;\\n\\\n\\n\\\n// Fully transparent parts of the billboard are not pickable.\\n\\\n#if !defined(OPAQUE) && !defined(TRANSLUCENT)\\n\\\n    if (color.a < 0.005)   // matches 0/255 and 1/255\\n\\\n    {\\n\\\n        discard;\\n\\\n    }\\n\\\n#else\\n\\\n// The billboard is rendered twice. The opaque pass discards translucent fragments\\n\\\n// and the translucent pass discards opaque fragments.\\n\\\n#ifdef OPAQUE\\n\\\n    if (color.a < 0.995)   // matches < 254/255\\n\\\n    {\\n\\\n        discard;\\n\\\n    }\\n\\\n#else\\n\\\n    if (color.a >= 0.995)  // matches 254/255 and 255/255\\n\\\n    {\\n\\\n        discard;\\n\\\n    }\\n\\\n#endif\\n\\\n#endif\\n\\\n\\n\\\n    gl_FragColor = czm_gammaCorrect(color);\\n\\\n    czm_writeLogDepth();\\n\\\n}\\n\\\n");\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTIwNDkuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQSx5REFBZSxzQkFBc0I7QUFDckMsNEJBQTRCO0FBQzVCLDZCQUE2QjtBQUM3Qiw4QkFBOEI7QUFDOUIseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQSwrREFBK0Q7QUFDL0Q7QUFDQSx3REFBd0Q7QUFDeEQsNEVBQTRFO0FBQzVFLDhHQUE4RztBQUM5RztBQUNBLDBEQUEwRDtBQUMxRCwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsZ0JBQWdCO0FBQ2hCLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLGdCQUFnQjtBQUNoQixLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTCxnQkFBZ0I7QUFDaEIsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQztBQUMzQyx3QkFBd0I7QUFDeEIsQ0FBQztBQUNELENBQUMsRUFBQyIsInNvdXJjZXMiOlsid2VicGFjazovL3Z1ZTMtd2VicGFjazUvLi9ub2RlX21vZHVsZXMvY2VzaXVtL1NvdXJjZS9TaGFkZXJzL1BvaW50UHJpbWl0aXZlQ29sbGVjdGlvbkZTLmpzPzcyZTIiXSwic291cmNlc0NvbnRlbnQiOlsiLy9UaGlzIGZpbGUgaXMgYXV0b21hdGljYWxseSByZWJ1aWx0IGJ5IHRoZSBDZXNpdW0gYnVpbGQgcHJvY2Vzcy5cbmV4cG9ydCBkZWZhdWx0IFwidmFyeWluZyB2ZWM0IHZfY29sb3I7XFxuXFxcbnZhcnlpbmcgdmVjNCB2X291dGxpbmVDb2xvcjtcXG5cXFxudmFyeWluZyBmbG9hdCB2X2lubmVyUGVyY2VudDtcXG5cXFxudmFyeWluZyBmbG9hdCB2X3BpeGVsRGlzdGFuY2U7XFxuXFxcbnZhcnlpbmcgdmVjNCB2X3BpY2tDb2xvcjtcXG5cXFxuXFxuXFxcbnZvaWQgbWFpbigpXFxuXFxcbntcXG5cXFxuICAgIC8vIFRoZSBkaXN0YW5jZSBpbiBVViBzcGFjZSBmcm9tIHRoaXMgZnJhZ21lbnQgdG8gdGhlIGNlbnRlciBvZiB0aGUgcG9pbnQsIGF0IG1vc3QgMC41LlxcblxcXG4gICAgZmxvYXQgZGlzdGFuY2VUb0NlbnRlciA9IGxlbmd0aChnbF9Qb2ludENvb3JkIC0gdmVjMigwLjUpKTtcXG5cXFxuICAgIC8vIFRoZSBtYXggZGlzdGFuY2Ugc3RvcHMgb25lIHBpeGVsIHNoeSBvZiB0aGUgZWRnZSB0byBsZWF2ZSBzcGFjZSBmb3IgYW50aS1hbGlhc2luZy5cXG5cXFxuICAgIGZsb2F0IG1heERpc3RhbmNlID0gbWF4KDAuMCwgMC41IC0gdl9waXhlbERpc3RhbmNlKTtcXG5cXFxuICAgIGZsb2F0IHdob2xlQWxwaGEgPSAxLjAgLSBzbW9vdGhzdGVwKG1heERpc3RhbmNlLCAwLjUsIGRpc3RhbmNlVG9DZW50ZXIpO1xcblxcXG4gICAgZmxvYXQgaW5uZXJBbHBoYSA9IDEuMCAtIHNtb290aHN0ZXAobWF4RGlzdGFuY2UgKiB2X2lubmVyUGVyY2VudCwgMC41ICogdl9pbm5lclBlcmNlbnQsIGRpc3RhbmNlVG9DZW50ZXIpO1xcblxcXG5cXG5cXFxuICAgIHZlYzQgY29sb3IgPSBtaXgodl9vdXRsaW5lQ29sb3IsIHZfY29sb3IsIGlubmVyQWxwaGEpO1xcblxcXG4gICAgY29sb3IuYSAqPSB3aG9sZUFscGhhO1xcblxcXG5cXG5cXFxuLy8gRnVsbHkgdHJhbnNwYXJlbnQgcGFydHMgb2YgdGhlIGJpbGxib2FyZCBhcmUgbm90IHBpY2thYmxlLlxcblxcXG4jaWYgIWRlZmluZWQoT1BBUVVFKSAmJiAhZGVmaW5lZChUUkFOU0xVQ0VOVClcXG5cXFxuICAgIGlmIChjb2xvci5hIDwgMC4wMDUpICAgLy8gbWF0Y2hlcyAwLzI1NSBhbmQgMS8yNTVcXG5cXFxuICAgIHtcXG5cXFxuICAgICAgICBkaXNjYXJkO1xcblxcXG4gICAgfVxcblxcXG4jZWxzZVxcblxcXG4vLyBUaGUgYmlsbGJvYXJkIGlzIHJlbmRlcmVkIHR3aWNlLiBUaGUgb3BhcXVlIHBhc3MgZGlzY2FyZHMgdHJhbnNsdWNlbnQgZnJhZ21lbnRzXFxuXFxcbi8vIGFuZCB0aGUgdHJhbnNsdWNlbnQgcGFzcyBkaXNjYXJkcyBvcGFxdWUgZnJhZ21lbnRzLlxcblxcXG4jaWZkZWYgT1BBUVVFXFxuXFxcbiAgICBpZiAoY29sb3IuYSA8IDAuOTk1KSAgIC8vIG1hdGNoZXMgPCAyNTQvMjU1XFxuXFxcbiAgICB7XFxuXFxcbiAgICAgICAgZGlzY2FyZDtcXG5cXFxuICAgIH1cXG5cXFxuI2Vsc2VcXG5cXFxuICAgIGlmIChjb2xvci5hID49IDAuOTk1KSAgLy8gbWF0Y2hlcyAyNTQvMjU1IGFuZCAyNTUvMjU1XFxuXFxcbiAgICB7XFxuXFxcbiAgICAgICAgZGlzY2FyZDtcXG5cXFxuICAgIH1cXG5cXFxuI2VuZGlmXFxuXFxcbiNlbmRpZlxcblxcXG5cXG5cXFxuICAgIGdsX0ZyYWdDb2xvciA9IGN6bV9nYW1tYUNvcnJlY3QoY29sb3IpO1xcblxcXG4gICAgY3ptX3dyaXRlTG9nRGVwdGgoKTtcXG5cXFxufVxcblxcXG5cIjtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///12049\n')},16586:function(__unused_webpack___webpack_module__,__webpack_exports__){eval('//This file is automatically rebuilt by the Cesium build process.\n/* harmony default export */ __webpack_exports__["Z"] = ("uniform float u_maxTotalPointSize;\\n\\\n\\n\\\nattribute vec4 positionHighAndSize;\\n\\\nattribute vec4 positionLowAndOutline;\\n\\\nattribute vec4 compressedAttribute0;                       // color, outlineColor, pick color\\n\\\nattribute vec4 compressedAttribute1;                       // show, translucency by distance, some free space\\n\\\nattribute vec4 scaleByDistance;                            // near, nearScale, far, farScale\\n\\\nattribute vec3 distanceDisplayConditionAndDisableDepth;    // near, far, disableDepthTestDistance\\n\\\n\\n\\\nvarying vec4 v_color;\\n\\\nvarying vec4 v_outlineColor;\\n\\\nvarying float v_innerPercent;\\n\\\nvarying float v_pixelDistance;\\n\\\nvarying vec4 v_pickColor;\\n\\\n\\n\\\nconst float SHIFT_LEFT8 = 256.0;\\n\\\nconst float SHIFT_RIGHT8 = 1.0 / 256.0;\\n\\\n\\n\\\nvoid main()\\n\\\n{\\n\\\n    // Modifying this shader may also require modifications to PointPrimitive._computeScreenSpacePosition\\n\\\n\\n\\\n    // unpack attributes\\n\\\n    vec3 positionHigh = positionHighAndSize.xyz;\\n\\\n    vec3 positionLow = positionLowAndOutline.xyz;\\n\\\n    float outlineWidthBothSides = 2.0 * positionLowAndOutline.w;\\n\\\n    float totalSize = positionHighAndSize.w + outlineWidthBothSides;\\n\\\n    float outlinePercent = outlineWidthBothSides / totalSize;\\n\\\n    // Scale in response to browser-zoom.\\n\\\n    totalSize *= czm_pixelRatio;\\n\\\n    // Add padding for anti-aliasing on both sides.\\n\\\n    totalSize += 3.0;\\n\\\n\\n\\\n    float temp = compressedAttribute1.x * SHIFT_RIGHT8;\\n\\\n    float show = floor(temp);\\n\\\n\\n\\\n#ifdef EYE_DISTANCE_TRANSLUCENCY\\n\\\n    vec4 translucencyByDistance;\\n\\\n    translucencyByDistance.x = compressedAttribute1.z;\\n\\\n    translucencyByDistance.z = compressedAttribute1.w;\\n\\\n\\n\\\n    translucencyByDistance.y = ((temp - floor(temp)) * SHIFT_LEFT8) / 255.0;\\n\\\n\\n\\\n    temp = compressedAttribute1.y * SHIFT_RIGHT8;\\n\\\n    translucencyByDistance.w = ((temp - floor(temp)) * SHIFT_LEFT8) / 255.0;\\n\\\n#endif\\n\\\n\\n\\\n    ///////////////////////////////////////////////////////////////////////////\\n\\\n\\n\\\n    vec4 color;\\n\\\n    vec4 outlineColor;\\n\\\n    vec4 pickColor;\\n\\\n\\n\\\n    // compressedAttribute0.z => pickColor.rgb\\n\\\n\\n\\\n    temp = compressedAttribute0.z * SHIFT_RIGHT8;\\n\\\n    pickColor.b = (temp - floor(temp)) * SHIFT_LEFT8;\\n\\\n    temp = floor(temp) * SHIFT_RIGHT8;\\n\\\n    pickColor.g = (temp - floor(temp)) * SHIFT_LEFT8;\\n\\\n    pickColor.r = floor(temp);\\n\\\n\\n\\\n    // compressedAttribute0.x => color.rgb\\n\\\n\\n\\\n    temp = compressedAttribute0.x * SHIFT_RIGHT8;\\n\\\n    color.b = (temp - floor(temp)) * SHIFT_LEFT8;\\n\\\n    temp = floor(temp) * SHIFT_RIGHT8;\\n\\\n    color.g = (temp - floor(temp)) * SHIFT_LEFT8;\\n\\\n    color.r = floor(temp);\\n\\\n\\n\\\n    // compressedAttribute0.y => outlineColor.rgb\\n\\\n\\n\\\n    temp = compressedAttribute0.y * SHIFT_RIGHT8;\\n\\\n    outlineColor.b = (temp - floor(temp)) * SHIFT_LEFT8;\\n\\\n    temp = floor(temp) * SHIFT_RIGHT8;\\n\\\n    outlineColor.g = (temp - floor(temp)) * SHIFT_LEFT8;\\n\\\n    outlineColor.r = floor(temp);\\n\\\n\\n\\\n    // compressedAttribute0.w => color.a, outlineColor.a, pickColor.a\\n\\\n\\n\\\n    temp = compressedAttribute0.w * SHIFT_RIGHT8;\\n\\\n    pickColor.a = (temp - floor(temp)) * SHIFT_LEFT8;\\n\\\n    pickColor = pickColor / 255.0;\\n\\\n\\n\\\n    temp = floor(temp) * SHIFT_RIGHT8;\\n\\\n    outlineColor.a = (temp - floor(temp)) * SHIFT_LEFT8;\\n\\\n    outlineColor /= 255.0;\\n\\\n    color.a = floor(temp);\\n\\\n    color /= 255.0;\\n\\\n\\n\\\n    ///////////////////////////////////////////////////////////////////////////\\n\\\n\\n\\\n    vec4 p = czm_translateRelativeToEye(positionHigh, positionLow);\\n\\\n    vec4 positionEC = czm_modelViewRelativeToEye * p;\\n\\\n\\n\\\n    ///////////////////////////////////////////////////////////////////////////\\n\\\n\\n\\\n#if defined(EYE_DISTANCE_SCALING) || defined(EYE_DISTANCE_TRANSLUCENCY) || defined(DISTANCE_DISPLAY_CONDITION) || defined(DISABLE_DEPTH_DISTANCE)\\n\\\n    float lengthSq;\\n\\\n    if (czm_sceneMode == czm_sceneMode2D)\\n\\\n    {\\n\\\n        // 2D camera distance is a special case\\n\\\n        // treat all billboards as flattened to the z=0.0 plane\\n\\\n        lengthSq = czm_eyeHeight2D.y;\\n\\\n    }\\n\\\n    else\\n\\\n    {\\n\\\n        lengthSq = dot(positionEC.xyz, positionEC.xyz);\\n\\\n    }\\n\\\n#endif\\n\\\n\\n\\\n#ifdef EYE_DISTANCE_SCALING\\n\\\n    totalSize *= czm_nearFarScalar(scaleByDistance, lengthSq);\\n\\\n#endif\\n\\\n    // Clamp to max point size.\\n\\\n    totalSize = min(totalSize, u_maxTotalPointSize);\\n\\\n    // If size is too small, push vertex behind near plane for clipping.\\n\\\n    // Note that context.minimumAliasedPointSize \\"will be at most 1.0\\".\\n\\\n    if (totalSize < 1.0)\\n\\\n    {\\n\\\n        positionEC.xyz = vec3(0.0);\\n\\\n        totalSize = 1.0;\\n\\\n    }\\n\\\n\\n\\\n    float translucency = 1.0;\\n\\\n#ifdef EYE_DISTANCE_TRANSLUCENCY\\n\\\n    translucency = czm_nearFarScalar(translucencyByDistance, lengthSq);\\n\\\n    // push vertex behind near plane for clipping\\n\\\n    if (translucency < 0.004)\\n\\\n    {\\n\\\n        positionEC.xyz = vec3(0.0);\\n\\\n    }\\n\\\n#endif\\n\\\n\\n\\\n#ifdef DISTANCE_DISPLAY_CONDITION\\n\\\n    float nearSq = distanceDisplayConditionAndDisableDepth.x;\\n\\\n    float farSq = distanceDisplayConditionAndDisableDepth.y;\\n\\\n    if (lengthSq < nearSq || lengthSq > farSq) {\\n\\\n        // push vertex behind camera to force it to be clipped\\n\\\n        positionEC.xyz = vec3(0.0, 0.0, 1.0);\\n\\\n    }\\n\\\n#endif\\n\\\n\\n\\\n    gl_Position = czm_projection * positionEC;\\n\\\n    czm_vertexLogDepth();\\n\\\n\\n\\\n#ifdef DISABLE_DEPTH_DISTANCE\\n\\\n    float disableDepthTestDistance = distanceDisplayConditionAndDisableDepth.z;\\n\\\n    if (disableDepthTestDistance == 0.0 && czm_minimumDisableDepthTestDistance != 0.0)\\n\\\n    {\\n\\\n        disableDepthTestDistance = czm_minimumDisableDepthTestDistance;\\n\\\n    }\\n\\\n\\n\\\n    if (disableDepthTestDistance != 0.0)\\n\\\n    {\\n\\\n        // Don\'t try to \\"multiply both sides\\" by w.  Greater/less-than comparisons won\'t work for negative values of w.\\n\\\n        float zclip = gl_Position.z / gl_Position.w;\\n\\\n        bool clipped = (zclip < -1.0 || zclip > 1.0);\\n\\\n        if (!clipped && (disableDepthTestDistance < 0.0 || (lengthSq > 0.0 && lengthSq < disableDepthTestDistance)))\\n\\\n        {\\n\\\n            // Position z on the near plane.\\n\\\n            gl_Position.z = -gl_Position.w;\\n\\\n#ifdef LOG_DEPTH\\n\\\n            czm_vertexLogDepth(vec4(czm_currentFrustum.x));\\n\\\n#endif\\n\\\n        }\\n\\\n    }\\n\\\n#endif\\n\\\n\\n\\\n    v_color = color;\\n\\\n    v_color.a *= translucency * show;\\n\\\n    v_outlineColor = outlineColor;\\n\\\n    v_outlineColor.a *= translucency * show;\\n\\\n\\n\\\n    v_innerPercent = 1.0 - outlinePercent;\\n\\\n    v_pixelDistance = 2.0 / totalSize;\\n\\\n    gl_PointSize = totalSize * show;\\n\\\n    gl_Position *= show;\\n\\\n\\n\\\n    v_pickColor = pickColor;\\n\\\n}\\n\\\n");\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTY1ODYuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQSx5REFBZSxtQ0FBbUM7QUFDbEQ7QUFDQSxtQ0FBbUM7QUFDbkMscUNBQXFDO0FBQ3JDLDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRDtBQUNBLHFCQUFxQjtBQUNyQiw0QkFBNEI7QUFDNUIsNkJBQTZCO0FBQzdCLDhCQUE4QjtBQUM5Qix5QkFBeUI7QUFDekI7QUFDQSxnQ0FBZ0M7QUFDaEMsdUNBQXVDO0FBQ3ZDO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdEO0FBQ2hELGlEQUFpRDtBQUNqRCxnRUFBZ0U7QUFDaEUsb0VBQW9FO0FBQ3BFLDZEQUE2RDtBQUM3RDtBQUNBLGdDQUFnQztBQUNoQztBQUNBLHFCQUFxQjtBQUNyQjtBQUNBLHVEQUF1RDtBQUN2RCw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBLGdDQUFnQztBQUNoQyxzREFBc0Q7QUFDdEQsc0RBQXNEO0FBQ3REO0FBQ0EsNEVBQTRFO0FBQzVFO0FBQ0EsaURBQWlEO0FBQ2pELDRFQUE0RTtBQUM1RTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZixzQkFBc0I7QUFDdEIsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRDtBQUNqRCxxREFBcUQ7QUFDckQsc0NBQXNDO0FBQ3RDLHFEQUFxRDtBQUNyRCw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0EsaURBQWlEO0FBQ2pELGlEQUFpRDtBQUNqRCxzQ0FBc0M7QUFDdEMsaURBQWlEO0FBQ2pELDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQSxpREFBaUQ7QUFDakQsd0RBQXdEO0FBQ3hELHNDQUFzQztBQUN0Qyx3REFBd0Q7QUFDeEQsaUNBQWlDO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRDtBQUNqRCxxREFBcUQ7QUFDckQsa0NBQWtDO0FBQ2xDO0FBQ0Esc0NBQXNDO0FBQ3RDLHdEQUF3RDtBQUN4RCwwQkFBMEI7QUFDMUIsMEJBQTBCO0FBQzFCLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQSxtRUFBbUU7QUFDbkUscURBQXFEO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxxQ0FBcUM7QUFDckMsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMLHVEQUF1RDtBQUN2RCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsOERBQThEO0FBQzlEO0FBQ0E7QUFDQSxvREFBb0Q7QUFDcEQ7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLG1DQUFtQztBQUNuQyx3QkFBd0I7QUFDeEIsS0FBSztBQUNMO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0EsdUVBQXVFO0FBQ3ZFO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsbUNBQW1DO0FBQ25DLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSw2REFBNkQ7QUFDN0QsNERBQTREO0FBQzVELGdEQUFnRDtBQUNoRDtBQUNBLDZDQUE2QztBQUM3QyxLQUFLO0FBQ0w7QUFDQTtBQUNBLDhDQUE4QztBQUM5Qyx5QkFBeUI7QUFDekI7QUFDQTtBQUNBLCtFQUErRTtBQUMvRTtBQUNBLEtBQUs7QUFDTCx1RUFBdUU7QUFDdkUsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxvREFBb0Q7QUFDcEQscURBQXFEO0FBQ3JEO0FBQ0EsU0FBUztBQUNUO0FBQ0EsMkNBQTJDO0FBQzNDO0FBQ0EsMkRBQTJEO0FBQzNEO0FBQ0EsU0FBUztBQUNULEtBQUs7QUFDTDtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCLHFDQUFxQztBQUNyQyxrQ0FBa0M7QUFDbEMsNENBQTRDO0FBQzVDO0FBQ0EsMENBQTBDO0FBQzFDLHNDQUFzQztBQUN0QyxvQ0FBb0M7QUFDcEMsd0JBQXdCO0FBQ3hCO0FBQ0EsNEJBQTRCO0FBQzVCLENBQUM7QUFDRCxDQUFDLEVBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly92dWUzLXdlYnBhY2s1Ly4vbm9kZV9tb2R1bGVzL2Nlc2l1bS9Tb3VyY2UvU2hhZGVycy9Qb2ludFByaW1pdGl2ZUNvbGxlY3Rpb25WUy5qcz82MjViIl0sInNvdXJjZXNDb250ZW50IjpbIi8vVGhpcyBmaWxlIGlzIGF1dG9tYXRpY2FsbHkgcmVidWlsdCBieSB0aGUgQ2VzaXVtIGJ1aWxkIHByb2Nlc3MuXG5leHBvcnQgZGVmYXVsdCBcInVuaWZvcm0gZmxvYXQgdV9tYXhUb3RhbFBvaW50U2l6ZTtcXG5cXFxuXFxuXFxcbmF0dHJpYnV0ZSB2ZWM0IHBvc2l0aW9uSGlnaEFuZFNpemU7XFxuXFxcbmF0dHJpYnV0ZSB2ZWM0IHBvc2l0aW9uTG93QW5kT3V0bGluZTtcXG5cXFxuYXR0cmlidXRlIHZlYzQgY29tcHJlc3NlZEF0dHJpYnV0ZTA7ICAgICAgICAgICAgICAgICAgICAgICAvLyBjb2xvciwgb3V0bGluZUNvbG9yLCBwaWNrIGNvbG9yXFxuXFxcbmF0dHJpYnV0ZSB2ZWM0IGNvbXByZXNzZWRBdHRyaWJ1dGUxOyAgICAgICAgICAgICAgICAgICAgICAgLy8gc2hvdywgdHJhbnNsdWNlbmN5IGJ5IGRpc3RhbmNlLCBzb21lIGZyZWUgc3BhY2VcXG5cXFxuYXR0cmlidXRlIHZlYzQgc2NhbGVCeURpc3RhbmNlOyAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBuZWFyLCBuZWFyU2NhbGUsIGZhciwgZmFyU2NhbGVcXG5cXFxuYXR0cmlidXRlIHZlYzMgZGlzdGFuY2VEaXNwbGF5Q29uZGl0aW9uQW5kRGlzYWJsZURlcHRoOyAgICAvLyBuZWFyLCBmYXIsIGRpc2FibGVEZXB0aFRlc3REaXN0YW5jZVxcblxcXG5cXG5cXFxudmFyeWluZyB2ZWM0IHZfY29sb3I7XFxuXFxcbnZhcnlpbmcgdmVjNCB2X291dGxpbmVDb2xvcjtcXG5cXFxudmFyeWluZyBmbG9hdCB2X2lubmVyUGVyY2VudDtcXG5cXFxudmFyeWluZyBmbG9hdCB2X3BpeGVsRGlzdGFuY2U7XFxuXFxcbnZhcnlpbmcgdmVjNCB2X3BpY2tDb2xvcjtcXG5cXFxuXFxuXFxcbmNvbnN0IGZsb2F0IFNISUZUX0xFRlQ4ID0gMjU2LjA7XFxuXFxcbmNvbnN0IGZsb2F0IFNISUZUX1JJR0hUOCA9IDEuMCAvIDI1Ni4wO1xcblxcXG5cXG5cXFxudm9pZCBtYWluKClcXG5cXFxue1xcblxcXG4gICAgLy8gTW9kaWZ5aW5nIHRoaXMgc2hhZGVyIG1heSBhbHNvIHJlcXVpcmUgbW9kaWZpY2F0aW9ucyB0byBQb2ludFByaW1pdGl2ZS5fY29tcHV0ZVNjcmVlblNwYWNlUG9zaXRpb25cXG5cXFxuXFxuXFxcbiAgICAvLyB1bnBhY2sgYXR0cmlidXRlc1xcblxcXG4gICAgdmVjMyBwb3NpdGlvbkhpZ2ggPSBwb3NpdGlvbkhpZ2hBbmRTaXplLnh5ejtcXG5cXFxuICAgIHZlYzMgcG9zaXRpb25Mb3cgPSBwb3NpdGlvbkxvd0FuZE91dGxpbmUueHl6O1xcblxcXG4gICAgZmxvYXQgb3V0bGluZVdpZHRoQm90aFNpZGVzID0gMi4wICogcG9zaXRpb25Mb3dBbmRPdXRsaW5lLnc7XFxuXFxcbiAgICBmbG9hdCB0b3RhbFNpemUgPSBwb3NpdGlvbkhpZ2hBbmRTaXplLncgKyBvdXRsaW5lV2lkdGhCb3RoU2lkZXM7XFxuXFxcbiAgICBmbG9hdCBvdXRsaW5lUGVyY2VudCA9IG91dGxpbmVXaWR0aEJvdGhTaWRlcyAvIHRvdGFsU2l6ZTtcXG5cXFxuICAgIC8vIFNjYWxlIGluIHJlc3BvbnNlIHRvIGJyb3dzZXItem9vbS5cXG5cXFxuICAgIHRvdGFsU2l6ZSAqPSBjem1fcGl4ZWxSYXRpbztcXG5cXFxuICAgIC8vIEFkZCBwYWRkaW5nIGZvciBhbnRpLWFsaWFzaW5nIG9uIGJvdGggc2lkZXMuXFxuXFxcbiAgICB0b3RhbFNpemUgKz0gMy4wO1xcblxcXG5cXG5cXFxuICAgIGZsb2F0IHRlbXAgPSBjb21wcmVzc2VkQXR0cmlidXRlMS54ICogU0hJRlRfUklHSFQ4O1xcblxcXG4gICAgZmxvYXQgc2hvdyA9IGZsb29yKHRlbXApO1xcblxcXG5cXG5cXFxuI2lmZGVmIEVZRV9ESVNUQU5DRV9UUkFOU0xVQ0VOQ1lcXG5cXFxuICAgIHZlYzQgdHJhbnNsdWNlbmN5QnlEaXN0YW5jZTtcXG5cXFxuICAgIHRyYW5zbHVjZW5jeUJ5RGlzdGFuY2UueCA9IGNvbXByZXNzZWRBdHRyaWJ1dGUxLno7XFxuXFxcbiAgICB0cmFuc2x1Y2VuY3lCeURpc3RhbmNlLnogPSBjb21wcmVzc2VkQXR0cmlidXRlMS53O1xcblxcXG5cXG5cXFxuICAgIHRyYW5zbHVjZW5jeUJ5RGlzdGFuY2UueSA9ICgodGVtcCAtIGZsb29yKHRlbXApKSAqIFNISUZUX0xFRlQ4KSAvIDI1NS4wO1xcblxcXG5cXG5cXFxuICAgIHRlbXAgPSBjb21wcmVzc2VkQXR0cmlidXRlMS55ICogU0hJRlRfUklHSFQ4O1xcblxcXG4gICAgdHJhbnNsdWNlbmN5QnlEaXN0YW5jZS53ID0gKCh0ZW1wIC0gZmxvb3IodGVtcCkpICogU0hJRlRfTEVGVDgpIC8gMjU1LjA7XFxuXFxcbiNlbmRpZlxcblxcXG5cXG5cXFxuICAgIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xcblxcXG5cXG5cXFxuICAgIHZlYzQgY29sb3I7XFxuXFxcbiAgICB2ZWM0IG91dGxpbmVDb2xvcjtcXG5cXFxuICAgIHZlYzQgcGlja0NvbG9yO1xcblxcXG5cXG5cXFxuICAgIC8vIGNvbXByZXNzZWRBdHRyaWJ1dGUwLnogPT4gcGlja0NvbG9yLnJnYlxcblxcXG5cXG5cXFxuICAgIHRlbXAgPSBjb21wcmVzc2VkQXR0cmlidXRlMC56ICogU0hJRlRfUklHSFQ4O1xcblxcXG4gICAgcGlja0NvbG9yLmIgPSAodGVtcCAtIGZsb29yKHRlbXApKSAqIFNISUZUX0xFRlQ4O1xcblxcXG4gICAgdGVtcCA9IGZsb29yKHRlbXApICogU0hJRlRfUklHSFQ4O1xcblxcXG4gICAgcGlja0NvbG9yLmcgPSAodGVtcCAtIGZsb29yKHRlbXApKSAqIFNISUZUX0xFRlQ4O1xcblxcXG4gICAgcGlja0NvbG9yLnIgPSBmbG9vcih0ZW1wKTtcXG5cXFxuXFxuXFxcbiAgICAvLyBjb21wcmVzc2VkQXR0cmlidXRlMC54ID0+IGNvbG9yLnJnYlxcblxcXG5cXG5cXFxuICAgIHRlbXAgPSBjb21wcmVzc2VkQXR0cmlidXRlMC54ICogU0hJRlRfUklHSFQ4O1xcblxcXG4gICAgY29sb3IuYiA9ICh0ZW1wIC0gZmxvb3IodGVtcCkpICogU0hJRlRfTEVGVDg7XFxuXFxcbiAgICB0ZW1wID0gZmxvb3IodGVtcCkgKiBTSElGVF9SSUdIVDg7XFxuXFxcbiAgICBjb2xvci5nID0gKHRlbXAgLSBmbG9vcih0ZW1wKSkgKiBTSElGVF9MRUZUODtcXG5cXFxuICAgIGNvbG9yLnIgPSBmbG9vcih0ZW1wKTtcXG5cXFxuXFxuXFxcbiAgICAvLyBjb21wcmVzc2VkQXR0cmlidXRlMC55ID0+IG91dGxpbmVDb2xvci5yZ2JcXG5cXFxuXFxuXFxcbiAgICB0ZW1wID0gY29tcHJlc3NlZEF0dHJpYnV0ZTAueSAqIFNISUZUX1JJR0hUODtcXG5cXFxuICAgIG91dGxpbmVDb2xvci5iID0gKHRlbXAgLSBmbG9vcih0ZW1wKSkgKiBTSElGVF9MRUZUODtcXG5cXFxuICAgIHRlbXAgPSBmbG9vcih0ZW1wKSAqIFNISUZUX1JJR0hUODtcXG5cXFxuICAgIG91dGxpbmVDb2xvci5nID0gKHRlbXAgLSBmbG9vcih0ZW1wKSkgKiBTSElGVF9MRUZUODtcXG5cXFxuICAgIG91dGxpbmVDb2xvci5yID0gZmxvb3IodGVtcCk7XFxuXFxcblxcblxcXG4gICAgLy8gY29tcHJlc3NlZEF0dHJpYnV0ZTAudyA9PiBjb2xvci5hLCBvdXRsaW5lQ29sb3IuYSwgcGlja0NvbG9yLmFcXG5cXFxuXFxuXFxcbiAgICB0ZW1wID0gY29tcHJlc3NlZEF0dHJpYnV0ZTAudyAqIFNISUZUX1JJR0hUODtcXG5cXFxuICAgIHBpY2tDb2xvci5hID0gKHRlbXAgLSBmbG9vcih0ZW1wKSkgKiBTSElGVF9MRUZUODtcXG5cXFxuICAgIHBpY2tDb2xvciA9IHBpY2tDb2xvciAvIDI1NS4wO1xcblxcXG5cXG5cXFxuICAgIHRlbXAgPSBmbG9vcih0ZW1wKSAqIFNISUZUX1JJR0hUODtcXG5cXFxuICAgIG91dGxpbmVDb2xvci5hID0gKHRlbXAgLSBmbG9vcih0ZW1wKSkgKiBTSElGVF9MRUZUODtcXG5cXFxuICAgIG91dGxpbmVDb2xvciAvPSAyNTUuMDtcXG5cXFxuICAgIGNvbG9yLmEgPSBmbG9vcih0ZW1wKTtcXG5cXFxuICAgIGNvbG9yIC89IDI1NS4wO1xcblxcXG5cXG5cXFxuICAgIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xcblxcXG5cXG5cXFxuICAgIHZlYzQgcCA9IGN6bV90cmFuc2xhdGVSZWxhdGl2ZVRvRXllKHBvc2l0aW9uSGlnaCwgcG9zaXRpb25Mb3cpO1xcblxcXG4gICAgdmVjNCBwb3NpdGlvbkVDID0gY3ptX21vZGVsVmlld1JlbGF0aXZlVG9FeWUgKiBwO1xcblxcXG5cXG5cXFxuICAgIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xcblxcXG5cXG5cXFxuI2lmIGRlZmluZWQoRVlFX0RJU1RBTkNFX1NDQUxJTkcpIHx8IGRlZmluZWQoRVlFX0RJU1RBTkNFX1RSQU5TTFVDRU5DWSkgfHwgZGVmaW5lZChESVNUQU5DRV9ESVNQTEFZX0NPTkRJVElPTikgfHwgZGVmaW5lZChESVNBQkxFX0RFUFRIX0RJU1RBTkNFKVxcblxcXG4gICAgZmxvYXQgbGVuZ3RoU3E7XFxuXFxcbiAgICBpZiAoY3ptX3NjZW5lTW9kZSA9PSBjem1fc2NlbmVNb2RlMkQpXFxuXFxcbiAgICB7XFxuXFxcbiAgICAgICAgLy8gMkQgY2FtZXJhIGRpc3RhbmNlIGlzIGEgc3BlY2lhbCBjYXNlXFxuXFxcbiAgICAgICAgLy8gdHJlYXQgYWxsIGJpbGxib2FyZHMgYXMgZmxhdHRlbmVkIHRvIHRoZSB6PTAuMCBwbGFuZVxcblxcXG4gICAgICAgIGxlbmd0aFNxID0gY3ptX2V5ZUhlaWdodDJELnk7XFxuXFxcbiAgICB9XFxuXFxcbiAgICBlbHNlXFxuXFxcbiAgICB7XFxuXFxcbiAgICAgICAgbGVuZ3RoU3EgPSBkb3QocG9zaXRpb25FQy54eXosIHBvc2l0aW9uRUMueHl6KTtcXG5cXFxuICAgIH1cXG5cXFxuI2VuZGlmXFxuXFxcblxcblxcXG4jaWZkZWYgRVlFX0RJU1RBTkNFX1NDQUxJTkdcXG5cXFxuICAgIHRvdGFsU2l6ZSAqPSBjem1fbmVhckZhclNjYWxhcihzY2FsZUJ5RGlzdGFuY2UsIGxlbmd0aFNxKTtcXG5cXFxuI2VuZGlmXFxuXFxcbiAgICAvLyBDbGFtcCB0byBtYXggcG9pbnQgc2l6ZS5cXG5cXFxuICAgIHRvdGFsU2l6ZSA9IG1pbih0b3RhbFNpemUsIHVfbWF4VG90YWxQb2ludFNpemUpO1xcblxcXG4gICAgLy8gSWYgc2l6ZSBpcyB0b28gc21hbGwsIHB1c2ggdmVydGV4IGJlaGluZCBuZWFyIHBsYW5lIGZvciBjbGlwcGluZy5cXG5cXFxuICAgIC8vIE5vdGUgdGhhdCBjb250ZXh0Lm1pbmltdW1BbGlhc2VkUG9pbnRTaXplIFxcXCJ3aWxsIGJlIGF0IG1vc3QgMS4wXFxcIi5cXG5cXFxuICAgIGlmICh0b3RhbFNpemUgPCAxLjApXFxuXFxcbiAgICB7XFxuXFxcbiAgICAgICAgcG9zaXRpb25FQy54eXogPSB2ZWMzKDAuMCk7XFxuXFxcbiAgICAgICAgdG90YWxTaXplID0gMS4wO1xcblxcXG4gICAgfVxcblxcXG5cXG5cXFxuICAgIGZsb2F0IHRyYW5zbHVjZW5jeSA9IDEuMDtcXG5cXFxuI2lmZGVmIEVZRV9ESVNUQU5DRV9UUkFOU0xVQ0VOQ1lcXG5cXFxuICAgIHRyYW5zbHVjZW5jeSA9IGN6bV9uZWFyRmFyU2NhbGFyKHRyYW5zbHVjZW5jeUJ5RGlzdGFuY2UsIGxlbmd0aFNxKTtcXG5cXFxuICAgIC8vIHB1c2ggdmVydGV4IGJlaGluZCBuZWFyIHBsYW5lIGZvciBjbGlwcGluZ1xcblxcXG4gICAgaWYgKHRyYW5zbHVjZW5jeSA8IDAuMDA0KVxcblxcXG4gICAge1xcblxcXG4gICAgICAgIHBvc2l0aW9uRUMueHl6ID0gdmVjMygwLjApO1xcblxcXG4gICAgfVxcblxcXG4jZW5kaWZcXG5cXFxuXFxuXFxcbiNpZmRlZiBESVNUQU5DRV9ESVNQTEFZX0NPTkRJVElPTlxcblxcXG4gICAgZmxvYXQgbmVhclNxID0gZGlzdGFuY2VEaXNwbGF5Q29uZGl0aW9uQW5kRGlzYWJsZURlcHRoLng7XFxuXFxcbiAgICBmbG9hdCBmYXJTcSA9IGRpc3RhbmNlRGlzcGxheUNvbmRpdGlvbkFuZERpc2FibGVEZXB0aC55O1xcblxcXG4gICAgaWYgKGxlbmd0aFNxIDwgbmVhclNxIHx8IGxlbmd0aFNxID4gZmFyU3EpIHtcXG5cXFxuICAgICAgICAvLyBwdXNoIHZlcnRleCBiZWhpbmQgY2FtZXJhIHRvIGZvcmNlIGl0IHRvIGJlIGNsaXBwZWRcXG5cXFxuICAgICAgICBwb3NpdGlvbkVDLnh5eiA9IHZlYzMoMC4wLCAwLjAsIDEuMCk7XFxuXFxcbiAgICB9XFxuXFxcbiNlbmRpZlxcblxcXG5cXG5cXFxuICAgIGdsX1Bvc2l0aW9uID0gY3ptX3Byb2plY3Rpb24gKiBwb3NpdGlvbkVDO1xcblxcXG4gICAgY3ptX3ZlcnRleExvZ0RlcHRoKCk7XFxuXFxcblxcblxcXG4jaWZkZWYgRElTQUJMRV9ERVBUSF9ESVNUQU5DRVxcblxcXG4gICAgZmxvYXQgZGlzYWJsZURlcHRoVGVzdERpc3RhbmNlID0gZGlzdGFuY2VEaXNwbGF5Q29uZGl0aW9uQW5kRGlzYWJsZURlcHRoLno7XFxuXFxcbiAgICBpZiAoZGlzYWJsZURlcHRoVGVzdERpc3RhbmNlID09IDAuMCAmJiBjem1fbWluaW11bURpc2FibGVEZXB0aFRlc3REaXN0YW5jZSAhPSAwLjApXFxuXFxcbiAgICB7XFxuXFxcbiAgICAgICAgZGlzYWJsZURlcHRoVGVzdERpc3RhbmNlID0gY3ptX21pbmltdW1EaXNhYmxlRGVwdGhUZXN0RGlzdGFuY2U7XFxuXFxcbiAgICB9XFxuXFxcblxcblxcXG4gICAgaWYgKGRpc2FibGVEZXB0aFRlc3REaXN0YW5jZSAhPSAwLjApXFxuXFxcbiAgICB7XFxuXFxcbiAgICAgICAgLy8gRG9uJ3QgdHJ5IHRvIFxcXCJtdWx0aXBseSBib3RoIHNpZGVzXFxcIiBieSB3LiAgR3JlYXRlci9sZXNzLXRoYW4gY29tcGFyaXNvbnMgd29uJ3Qgd29yayBmb3IgbmVnYXRpdmUgdmFsdWVzIG9mIHcuXFxuXFxcbiAgICAgICAgZmxvYXQgemNsaXAgPSBnbF9Qb3NpdGlvbi56IC8gZ2xfUG9zaXRpb24udztcXG5cXFxuICAgICAgICBib29sIGNsaXBwZWQgPSAoemNsaXAgPCAtMS4wIHx8IHpjbGlwID4gMS4wKTtcXG5cXFxuICAgICAgICBpZiAoIWNsaXBwZWQgJiYgKGRpc2FibGVEZXB0aFRlc3REaXN0YW5jZSA8IDAuMCB8fCAobGVuZ3RoU3EgPiAwLjAgJiYgbGVuZ3RoU3EgPCBkaXNhYmxlRGVwdGhUZXN0RGlzdGFuY2UpKSlcXG5cXFxuICAgICAgICB7XFxuXFxcbiAgICAgICAgICAgIC8vIFBvc2l0aW9uIHogb24gdGhlIG5lYXIgcGxhbmUuXFxuXFxcbiAgICAgICAgICAgIGdsX1Bvc2l0aW9uLnogPSAtZ2xfUG9zaXRpb24udztcXG5cXFxuI2lmZGVmIExPR19ERVBUSFxcblxcXG4gICAgICAgICAgICBjem1fdmVydGV4TG9nRGVwdGgodmVjNChjem1fY3VycmVudEZydXN0dW0ueCkpO1xcblxcXG4jZW5kaWZcXG5cXFxuICAgICAgICB9XFxuXFxcbiAgICB9XFxuXFxcbiNlbmRpZlxcblxcXG5cXG5cXFxuICAgIHZfY29sb3IgPSBjb2xvcjtcXG5cXFxuICAgIHZfY29sb3IuYSAqPSB0cmFuc2x1Y2VuY3kgKiBzaG93O1xcblxcXG4gICAgdl9vdXRsaW5lQ29sb3IgPSBvdXRsaW5lQ29sb3I7XFxuXFxcbiAgICB2X291dGxpbmVDb2xvci5hICo9IHRyYW5zbHVjZW5jeSAqIHNob3c7XFxuXFxcblxcblxcXG4gICAgdl9pbm5lclBlcmNlbnQgPSAxLjAgLSBvdXRsaW5lUGVyY2VudDtcXG5cXFxuICAgIHZfcGl4ZWxEaXN0YW5jZSA9IDIuMCAvIHRvdGFsU2l6ZTtcXG5cXFxuICAgIGdsX1BvaW50U2l6ZSA9IHRvdGFsU2l6ZSAqIHNob3c7XFxuXFxcbiAgICBnbF9Qb3NpdGlvbiAqPSBzaG93O1xcblxcXG5cXG5cXFxuICAgIHZfcGlja0NvbG9yID0gcGlja0NvbG9yO1xcblxcXG59XFxuXFxcblwiO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///16586\n')},94373:function(__unused_webpack___webpack_module__,__webpack_exports__){eval('//This file is automatically rebuilt by the Cesium build process.\n/* harmony default export */ __webpack_exports__["Z"] = ("void clipLineSegmentToNearPlane(\\n\\\n    vec3 p0,\\n\\\n    vec3 p1,\\n\\\n    out vec4 positionWC,\\n\\\n    out bool clipped,\\n\\\n    out bool culledByNearPlane,\\n\\\n    out vec4 clippedPositionEC)\\n\\\n{\\n\\\n    culledByNearPlane = false;\\n\\\n    clipped = false;\\n\\\n\\n\\\n    vec3 p0ToP1 = p1 - p0;\\n\\\n    float magnitude = length(p0ToP1);\\n\\\n    vec3 direction = normalize(p0ToP1);\\n\\\n\\n\\\n    // Distance that p0 is behind the near plane. Negative means p0 is\\n\\\n    // in front of the near plane.\\n\\\n    float endPoint0Distance =  czm_currentFrustum.x + p0.z;\\n\\\n\\n\\\n    // Camera looks down -Z.\\n\\\n    // When moving a point along +Z: LESS VISIBLE\\n\\\n    //   * Points in front of the camera move closer to the camera.\\n\\\n    //   * Points behind the camrea move farther away from the camera.\\n\\\n    // When moving a point along -Z: MORE VISIBLE\\n\\\n    //   * Points in front of the camera move farther away from the camera.\\n\\\n    //   * Points behind the camera move closer to the camera.\\n\\\n\\n\\\n    // Positive denominator: -Z, becoming more visible\\n\\\n    // Negative denominator: +Z, becoming less visible\\n\\\n    // Nearly zero: parallel to near plane\\n\\\n    float denominator = -direction.z;\\n\\\n\\n\\\n    if (endPoint0Distance > 0.0 && abs(denominator) < czm_epsilon7)\\n\\\n    {\\n\\\n        // p0 is behind the near plane and the line to p1 is nearly parallel to\\n\\\n        // the near plane, so cull the segment completely.\\n\\\n        culledByNearPlane = true;\\n\\\n    }\\n\\\n    else if (endPoint0Distance > 0.0)\\n\\\n    {\\n\\\n        // p0 is behind the near plane, and the line to p1 is moving distinctly\\n\\\n        // toward or away from it.\\n\\\n\\n\\\n        // t = (-plane distance - dot(plane normal, ray origin)) / dot(plane normal, ray direction)\\n\\\n        float t = endPoint0Distance / denominator;\\n\\\n        if (t < 0.0 || t > magnitude)\\n\\\n        {\\n\\\n            // Near plane intersection is not between the two points.\\n\\\n            // We already confirmed p0 is behind the naer plane, so now\\n\\\n            // we know the entire segment is behind it.\\n\\\n            culledByNearPlane = true;\\n\\\n        }\\n\\\n        else\\n\\\n        {\\n\\\n            // Segment crosses the near plane, update p0 to lie exactly on it.\\n\\\n            p0 = p0 + t * direction;\\n\\\n\\n\\\n            // Numerical noise might put us a bit on the wrong side of the near plane.\\n\\\n            // Don\'t let that happen.\\n\\\n            p0.z = min(p0.z, -czm_currentFrustum.x);\\n\\\n\\n\\\n            clipped = true;\\n\\\n        }\\n\\\n    }\\n\\\n\\n\\\n    clippedPositionEC = vec4(p0, 1.0);\\n\\\n    positionWC = czm_eyeToWindowCoordinates(clippedPositionEC);\\n\\\n}\\n\\\n\\n\\\nvec4 getPolylineWindowCoordinatesEC(vec4 positionEC, vec4 prevEC, vec4 nextEC, float expandDirection, float width, bool usePrevious, out float angle)\\n\\\n{\\n\\\n    // expandDirection +1 is to the _left_ when looking from positionEC toward nextEC.\\n\\\n\\n\\\n#ifdef POLYLINE_DASH\\n\\\n    // Compute the window coordinates of the points.\\n\\\n    vec4 positionWindow = czm_eyeToWindowCoordinates(positionEC);\\n\\\n    vec4 previousWindow = czm_eyeToWindowCoordinates(prevEC);\\n\\\n    vec4 nextWindow = czm_eyeToWindowCoordinates(nextEC);\\n\\\n\\n\\\n    // Determine the relative screen space direction of the line.\\n\\\n    vec2 lineDir;\\n\\\n    if (usePrevious) {\\n\\\n        lineDir = normalize(positionWindow.xy - previousWindow.xy);\\n\\\n    }\\n\\\n    else {\\n\\\n        lineDir = normalize(nextWindow.xy - positionWindow.xy);\\n\\\n    }\\n\\\n    angle = atan(lineDir.x, lineDir.y) - 1.570796327; // precomputed atan(1,0)\\n\\\n\\n\\\n    // Quantize the angle so it doesn\'t change rapidly between segments.\\n\\\n    angle = floor(angle / czm_piOverFour + 0.5) * czm_piOverFour;\\n\\\n#endif\\n\\\n\\n\\\n    vec4 clippedPrevWC, clippedPrevEC;\\n\\\n    bool prevSegmentClipped, prevSegmentCulled;\\n\\\n    clipLineSegmentToNearPlane(prevEC.xyz, positionEC.xyz, clippedPrevWC, prevSegmentClipped, prevSegmentCulled, clippedPrevEC);\\n\\\n\\n\\\n    vec4 clippedNextWC, clippedNextEC;\\n\\\n    bool nextSegmentClipped, nextSegmentCulled;\\n\\\n    clipLineSegmentToNearPlane(nextEC.xyz, positionEC.xyz, clippedNextWC, nextSegmentClipped, nextSegmentCulled, clippedNextEC);\\n\\\n\\n\\\n    bool segmentClipped, segmentCulled;\\n\\\n    vec4 clippedPositionWC, clippedPositionEC;\\n\\\n    clipLineSegmentToNearPlane(positionEC.xyz, usePrevious ? prevEC.xyz : nextEC.xyz, clippedPositionWC, segmentClipped, segmentCulled, clippedPositionEC);\\n\\\n\\n\\\n    if (segmentCulled)\\n\\\n    {\\n\\\n        return vec4(0.0, 0.0, 0.0, 1.0);\\n\\\n    }\\n\\\n\\n\\\n    vec2 directionToPrevWC = normalize(clippedPrevWC.xy - clippedPositionWC.xy);\\n\\\n    vec2 directionToNextWC = normalize(clippedNextWC.xy - clippedPositionWC.xy);\\n\\\n\\n\\\n    // If a segment was culled, we can\'t use the corresponding direction\\n\\\n    // computed above. We should never see both of these be true without\\n\\\n    // `segmentCulled` above also being true.\\n\\\n    if (prevSegmentCulled)\\n\\\n    {\\n\\\n        directionToPrevWC = -directionToNextWC;\\n\\\n    }\\n\\\n    else if (nextSegmentCulled)\\n\\\n    {\\n\\\n        directionToNextWC = -directionToPrevWC;\\n\\\n    }\\n\\\n\\n\\\n    vec2 thisSegmentForwardWC, otherSegmentForwardWC;\\n\\\n    if (usePrevious)\\n\\\n    {\\n\\\n        thisSegmentForwardWC = -directionToPrevWC;\\n\\\n        otherSegmentForwardWC = directionToNextWC;\\n\\\n    }\\n\\\n    else\\n\\\n    {\\n\\\n        thisSegmentForwardWC = directionToNextWC;\\n\\\n        otherSegmentForwardWC =  -directionToPrevWC;\\n\\\n    }\\n\\\n\\n\\\n    vec2 thisSegmentLeftWC = vec2(-thisSegmentForwardWC.y, thisSegmentForwardWC.x);\\n\\\n\\n\\\n    vec2 leftWC = thisSegmentLeftWC;\\n\\\n    float expandWidth = width * 0.5;\\n\\\n\\n\\\n    // When lines are split at the anti-meridian, the position may be at the\\n\\\n    // same location as the next or previous position, and we need to handle\\n\\\n    // that to avoid producing NaNs.\\n\\\n    if (!czm_equalsEpsilon(prevEC.xyz - positionEC.xyz, vec3(0.0), czm_epsilon1) && !czm_equalsEpsilon(nextEC.xyz - positionEC.xyz, vec3(0.0), czm_epsilon1))\\n\\\n    {\\n\\\n        vec2 otherSegmentLeftWC = vec2(-otherSegmentForwardWC.y, otherSegmentForwardWC.x);\\n\\\n\\n\\\n        vec2 leftSumWC = thisSegmentLeftWC + otherSegmentLeftWC;\\n\\\n        float leftSumLength = length(leftSumWC);\\n\\\n        leftWC = leftSumLength < czm_epsilon6 ? thisSegmentLeftWC : (leftSumWC / leftSumLength);\\n\\\n\\n\\\n        // The sine of the angle between the two vectors is given by the formula\\n\\\n        //         |a x b| = |a||b|sin(theta)\\n\\\n        // which is\\n\\\n        //     float sinAngle = length(cross(vec3(leftWC, 0.0), vec3(-thisSegmentForwardWC, 0.0)));\\n\\\n        // Because the z components of both vectors are zero, the x and y coordinate will be zero.\\n\\\n        // Therefore, the sine of the angle is just the z component of the cross product.\\n\\\n        vec2 u = -thisSegmentForwardWC;\\n\\\n        vec2 v = leftWC;\\n\\\n        float sinAngle = abs(u.x * v.y - u.y * v.x);\\n\\\n        expandWidth = clamp(expandWidth / sinAngle, 0.0, width * 2.0);\\n\\\n    }\\n\\\n\\n\\\n    vec2 offset = leftWC * expandDirection * expandWidth * czm_pixelRatio;\\n\\\n    return vec4(clippedPositionWC.xy + offset, -clippedPositionWC.z, 1.0) * (czm_projection * clippedPositionEC).w;\\n\\\n}\\n\\\n\\n\\\nvec4 getPolylineWindowCoordinates(vec4 position, vec4 previous, vec4 next, float expandDirection, float width, bool usePrevious, out float angle)\\n\\\n{\\n\\\n    vec4 positionEC = czm_modelViewRelativeToEye * position;\\n\\\n    vec4 prevEC = czm_modelViewRelativeToEye * previous;\\n\\\n    vec4 nextEC = czm_modelViewRelativeToEye * next;\\n\\\n    return getPolylineWindowCoordinatesEC(positionEC, prevEC, nextEC, expandDirection, width, usePrevious, angle);\\n\\\n}\\n\\\n");\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiOTQzNzMuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQSx5REFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRCw4QkFBOEI7QUFDOUIsb0JBQW9CO0FBQ3BCO0FBQ0EsMEJBQTBCO0FBQzFCLHFDQUFxQztBQUNyQyx1Q0FBdUM7QUFDdkM7QUFDQTtBQUNBO0FBQ0EsMkRBQTJEO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQztBQUNyQztBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxpQ0FBaUM7QUFDakMsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0RBQWtEO0FBQ2xEO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQztBQUNyQyxTQUFTO0FBQ1Q7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxvQ0FBb0M7QUFDcEM7QUFDQTtBQUNBO0FBQ0Esb0RBQW9EO0FBQ3BEO0FBQ0EsMkJBQTJCO0FBQzNCLFNBQVM7QUFDVCxLQUFLO0FBQ0w7QUFDQSxzQ0FBc0M7QUFDdEMsK0RBQStEO0FBQy9ELENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUVBQWlFO0FBQ2pFLDZEQUE2RDtBQUM3RCx5REFBeUQ7QUFDekQ7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixzQkFBc0I7QUFDdEIsbUVBQW1FO0FBQ25FLEtBQUs7QUFDTCxVQUFVO0FBQ1YsK0RBQStEO0FBQy9ELEtBQUs7QUFDTCxzREFBc0Q7QUFDdEQ7QUFDQTtBQUNBLGlFQUFpRTtBQUNqRTtBQUNBO0FBQ0Esc0NBQXNDO0FBQ3RDLCtDQUErQztBQUMvQyxnSUFBZ0k7QUFDaEk7QUFDQSxzQ0FBc0M7QUFDdEMsK0NBQStDO0FBQy9DLGdJQUFnSTtBQUNoSTtBQUNBLHVDQUF1QztBQUN2Qyw4Q0FBOEM7QUFDOUMsMkpBQTJKO0FBQzNKO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsd0NBQXdDO0FBQ3hDLEtBQUs7QUFDTDtBQUNBLGdGQUFnRjtBQUNoRixnRkFBZ0Y7QUFDaEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCwrQ0FBK0M7QUFDL0MsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMLCtDQUErQztBQUMvQyxLQUFLO0FBQ0w7QUFDQSxxREFBcUQ7QUFDckQ7QUFDQSxLQUFLO0FBQ0wsa0RBQWtEO0FBQ2xELGtEQUFrRDtBQUNsRCxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0wsaURBQWlEO0FBQ2pELG9EQUFvRDtBQUNwRCxLQUFLO0FBQ0w7QUFDQSxtRkFBbUY7QUFDbkY7QUFDQSxvQ0FBb0M7QUFDcEMsb0NBQW9DO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsMEZBQTBGO0FBQzFGO0FBQ0EsZ0VBQWdFO0FBQ2hFLGdEQUFnRDtBQUNoRCxnR0FBZ0c7QUFDaEc7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtR0FBbUc7QUFDbkc7QUFDQTtBQUNBLHVDQUF1QztBQUN2Qyx3QkFBd0I7QUFDeEIsb0RBQW9EO0FBQ3BELHNFQUFzRTtBQUN0RSxLQUFLO0FBQ0w7QUFDQSwwRUFBMEU7QUFDMUUsbUhBQW1IO0FBQ25ILENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNELDREQUE0RDtBQUM1RCx3REFBd0Q7QUFDeEQsb0RBQW9EO0FBQ3BELGtIQUFrSDtBQUNsSCxDQUFDO0FBQ0QsQ0FBQyxFQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdnVlMy13ZWJwYWNrNS8uL25vZGVfbW9kdWxlcy9jZXNpdW0vU291cmNlL1NoYWRlcnMvUG9seWxpbmVDb21tb24uanM/ZjYxMCJdLCJzb3VyY2VzQ29udGVudCI6WyIvL1RoaXMgZmlsZSBpcyBhdXRvbWF0aWNhbGx5IHJlYnVpbHQgYnkgdGhlIENlc2l1bSBidWlsZCBwcm9jZXNzLlxuZXhwb3J0IGRlZmF1bHQgXCJ2b2lkIGNsaXBMaW5lU2VnbWVudFRvTmVhclBsYW5lKFxcblxcXG4gICAgdmVjMyBwMCxcXG5cXFxuICAgIHZlYzMgcDEsXFxuXFxcbiAgICBvdXQgdmVjNCBwb3NpdGlvbldDLFxcblxcXG4gICAgb3V0IGJvb2wgY2xpcHBlZCxcXG5cXFxuICAgIG91dCBib29sIGN1bGxlZEJ5TmVhclBsYW5lLFxcblxcXG4gICAgb3V0IHZlYzQgY2xpcHBlZFBvc2l0aW9uRUMpXFxuXFxcbntcXG5cXFxuICAgIGN1bGxlZEJ5TmVhclBsYW5lID0gZmFsc2U7XFxuXFxcbiAgICBjbGlwcGVkID0gZmFsc2U7XFxuXFxcblxcblxcXG4gICAgdmVjMyBwMFRvUDEgPSBwMSAtIHAwO1xcblxcXG4gICAgZmxvYXQgbWFnbml0dWRlID0gbGVuZ3RoKHAwVG9QMSk7XFxuXFxcbiAgICB2ZWMzIGRpcmVjdGlvbiA9IG5vcm1hbGl6ZShwMFRvUDEpO1xcblxcXG5cXG5cXFxuICAgIC8vIERpc3RhbmNlIHRoYXQgcDAgaXMgYmVoaW5kIHRoZSBuZWFyIHBsYW5lLiBOZWdhdGl2ZSBtZWFucyBwMCBpc1xcblxcXG4gICAgLy8gaW4gZnJvbnQgb2YgdGhlIG5lYXIgcGxhbmUuXFxuXFxcbiAgICBmbG9hdCBlbmRQb2ludDBEaXN0YW5jZSA9ICBjem1fY3VycmVudEZydXN0dW0ueCArIHAwLno7XFxuXFxcblxcblxcXG4gICAgLy8gQ2FtZXJhIGxvb2tzIGRvd24gLVouXFxuXFxcbiAgICAvLyBXaGVuIG1vdmluZyBhIHBvaW50IGFsb25nICtaOiBMRVNTIFZJU0lCTEVcXG5cXFxuICAgIC8vICAgKiBQb2ludHMgaW4gZnJvbnQgb2YgdGhlIGNhbWVyYSBtb3ZlIGNsb3NlciB0byB0aGUgY2FtZXJhLlxcblxcXG4gICAgLy8gICAqIFBvaW50cyBiZWhpbmQgdGhlIGNhbXJlYSBtb3ZlIGZhcnRoZXIgYXdheSBmcm9tIHRoZSBjYW1lcmEuXFxuXFxcbiAgICAvLyBXaGVuIG1vdmluZyBhIHBvaW50IGFsb25nIC1aOiBNT1JFIFZJU0lCTEVcXG5cXFxuICAgIC8vICAgKiBQb2ludHMgaW4gZnJvbnQgb2YgdGhlIGNhbWVyYSBtb3ZlIGZhcnRoZXIgYXdheSBmcm9tIHRoZSBjYW1lcmEuXFxuXFxcbiAgICAvLyAgICogUG9pbnRzIGJlaGluZCB0aGUgY2FtZXJhIG1vdmUgY2xvc2VyIHRvIHRoZSBjYW1lcmEuXFxuXFxcblxcblxcXG4gICAgLy8gUG9zaXRpdmUgZGVub21pbmF0b3I6IC1aLCBiZWNvbWluZyBtb3JlIHZpc2libGVcXG5cXFxuICAgIC8vIE5lZ2F0aXZlIGRlbm9taW5hdG9yOiArWiwgYmVjb21pbmcgbGVzcyB2aXNpYmxlXFxuXFxcbiAgICAvLyBOZWFybHkgemVybzogcGFyYWxsZWwgdG8gbmVhciBwbGFuZVxcblxcXG4gICAgZmxvYXQgZGVub21pbmF0b3IgPSAtZGlyZWN0aW9uLno7XFxuXFxcblxcblxcXG4gICAgaWYgKGVuZFBvaW50MERpc3RhbmNlID4gMC4wICYmIGFicyhkZW5vbWluYXRvcikgPCBjem1fZXBzaWxvbjcpXFxuXFxcbiAgICB7XFxuXFxcbiAgICAgICAgLy8gcDAgaXMgYmVoaW5kIHRoZSBuZWFyIHBsYW5lIGFuZCB0aGUgbGluZSB0byBwMSBpcyBuZWFybHkgcGFyYWxsZWwgdG9cXG5cXFxuICAgICAgICAvLyB0aGUgbmVhciBwbGFuZSwgc28gY3VsbCB0aGUgc2VnbWVudCBjb21wbGV0ZWx5LlxcblxcXG4gICAgICAgIGN1bGxlZEJ5TmVhclBsYW5lID0gdHJ1ZTtcXG5cXFxuICAgIH1cXG5cXFxuICAgIGVsc2UgaWYgKGVuZFBvaW50MERpc3RhbmNlID4gMC4wKVxcblxcXG4gICAge1xcblxcXG4gICAgICAgIC8vIHAwIGlzIGJlaGluZCB0aGUgbmVhciBwbGFuZSwgYW5kIHRoZSBsaW5lIHRvIHAxIGlzIG1vdmluZyBkaXN0aW5jdGx5XFxuXFxcbiAgICAgICAgLy8gdG93YXJkIG9yIGF3YXkgZnJvbSBpdC5cXG5cXFxuXFxuXFxcbiAgICAgICAgLy8gdCA9ICgtcGxhbmUgZGlzdGFuY2UgLSBkb3QocGxhbmUgbm9ybWFsLCByYXkgb3JpZ2luKSkgLyBkb3QocGxhbmUgbm9ybWFsLCByYXkgZGlyZWN0aW9uKVxcblxcXG4gICAgICAgIGZsb2F0IHQgPSBlbmRQb2ludDBEaXN0YW5jZSAvIGRlbm9taW5hdG9yO1xcblxcXG4gICAgICAgIGlmICh0IDwgMC4wIHx8IHQgPiBtYWduaXR1ZGUpXFxuXFxcbiAgICAgICAge1xcblxcXG4gICAgICAgICAgICAvLyBOZWFyIHBsYW5lIGludGVyc2VjdGlvbiBpcyBub3QgYmV0d2VlbiB0aGUgdHdvIHBvaW50cy5cXG5cXFxuICAgICAgICAgICAgLy8gV2UgYWxyZWFkeSBjb25maXJtZWQgcDAgaXMgYmVoaW5kIHRoZSBuYWVyIHBsYW5lLCBzbyBub3dcXG5cXFxuICAgICAgICAgICAgLy8gd2Uga25vdyB0aGUgZW50aXJlIHNlZ21lbnQgaXMgYmVoaW5kIGl0LlxcblxcXG4gICAgICAgICAgICBjdWxsZWRCeU5lYXJQbGFuZSA9IHRydWU7XFxuXFxcbiAgICAgICAgfVxcblxcXG4gICAgICAgIGVsc2VcXG5cXFxuICAgICAgICB7XFxuXFxcbiAgICAgICAgICAgIC8vIFNlZ21lbnQgY3Jvc3NlcyB0aGUgbmVhciBwbGFuZSwgdXBkYXRlIHAwIHRvIGxpZSBleGFjdGx5IG9uIGl0LlxcblxcXG4gICAgICAgICAgICBwMCA9IHAwICsgdCAqIGRpcmVjdGlvbjtcXG5cXFxuXFxuXFxcbiAgICAgICAgICAgIC8vIE51bWVyaWNhbCBub2lzZSBtaWdodCBwdXQgdXMgYSBiaXQgb24gdGhlIHdyb25nIHNpZGUgb2YgdGhlIG5lYXIgcGxhbmUuXFxuXFxcbiAgICAgICAgICAgIC8vIERvbid0IGxldCB0aGF0IGhhcHBlbi5cXG5cXFxuICAgICAgICAgICAgcDAueiA9IG1pbihwMC56LCAtY3ptX2N1cnJlbnRGcnVzdHVtLngpO1xcblxcXG5cXG5cXFxuICAgICAgICAgICAgY2xpcHBlZCA9IHRydWU7XFxuXFxcbiAgICAgICAgfVxcblxcXG4gICAgfVxcblxcXG5cXG5cXFxuICAgIGNsaXBwZWRQb3NpdGlvbkVDID0gdmVjNChwMCwgMS4wKTtcXG5cXFxuICAgIHBvc2l0aW9uV0MgPSBjem1fZXllVG9XaW5kb3dDb29yZGluYXRlcyhjbGlwcGVkUG9zaXRpb25FQyk7XFxuXFxcbn1cXG5cXFxuXFxuXFxcbnZlYzQgZ2V0UG9seWxpbmVXaW5kb3dDb29yZGluYXRlc0VDKHZlYzQgcG9zaXRpb25FQywgdmVjNCBwcmV2RUMsIHZlYzQgbmV4dEVDLCBmbG9hdCBleHBhbmREaXJlY3Rpb24sIGZsb2F0IHdpZHRoLCBib29sIHVzZVByZXZpb3VzLCBvdXQgZmxvYXQgYW5nbGUpXFxuXFxcbntcXG5cXFxuICAgIC8vIGV4cGFuZERpcmVjdGlvbiArMSBpcyB0byB0aGUgX2xlZnRfIHdoZW4gbG9va2luZyBmcm9tIHBvc2l0aW9uRUMgdG93YXJkIG5leHRFQy5cXG5cXFxuXFxuXFxcbiNpZmRlZiBQT0xZTElORV9EQVNIXFxuXFxcbiAgICAvLyBDb21wdXRlIHRoZSB3aW5kb3cgY29vcmRpbmF0ZXMgb2YgdGhlIHBvaW50cy5cXG5cXFxuICAgIHZlYzQgcG9zaXRpb25XaW5kb3cgPSBjem1fZXllVG9XaW5kb3dDb29yZGluYXRlcyhwb3NpdGlvbkVDKTtcXG5cXFxuICAgIHZlYzQgcHJldmlvdXNXaW5kb3cgPSBjem1fZXllVG9XaW5kb3dDb29yZGluYXRlcyhwcmV2RUMpO1xcblxcXG4gICAgdmVjNCBuZXh0V2luZG93ID0gY3ptX2V5ZVRvV2luZG93Q29vcmRpbmF0ZXMobmV4dEVDKTtcXG5cXFxuXFxuXFxcbiAgICAvLyBEZXRlcm1pbmUgdGhlIHJlbGF0aXZlIHNjcmVlbiBzcGFjZSBkaXJlY3Rpb24gb2YgdGhlIGxpbmUuXFxuXFxcbiAgICB2ZWMyIGxpbmVEaXI7XFxuXFxcbiAgICBpZiAodXNlUHJldmlvdXMpIHtcXG5cXFxuICAgICAgICBsaW5lRGlyID0gbm9ybWFsaXplKHBvc2l0aW9uV2luZG93Lnh5IC0gcHJldmlvdXNXaW5kb3cueHkpO1xcblxcXG4gICAgfVxcblxcXG4gICAgZWxzZSB7XFxuXFxcbiAgICAgICAgbGluZURpciA9IG5vcm1hbGl6ZShuZXh0V2luZG93Lnh5IC0gcG9zaXRpb25XaW5kb3cueHkpO1xcblxcXG4gICAgfVxcblxcXG4gICAgYW5nbGUgPSBhdGFuKGxpbmVEaXIueCwgbGluZURpci55KSAtIDEuNTcwNzk2MzI3OyAvLyBwcmVjb21wdXRlZCBhdGFuKDEsMClcXG5cXFxuXFxuXFxcbiAgICAvLyBRdWFudGl6ZSB0aGUgYW5nbGUgc28gaXQgZG9lc24ndCBjaGFuZ2UgcmFwaWRseSBiZXR3ZWVuIHNlZ21lbnRzLlxcblxcXG4gICAgYW5nbGUgPSBmbG9vcihhbmdsZSAvIGN6bV9waU92ZXJGb3VyICsgMC41KSAqIGN6bV9waU92ZXJGb3VyO1xcblxcXG4jZW5kaWZcXG5cXFxuXFxuXFxcbiAgICB2ZWM0IGNsaXBwZWRQcmV2V0MsIGNsaXBwZWRQcmV2RUM7XFxuXFxcbiAgICBib29sIHByZXZTZWdtZW50Q2xpcHBlZCwgcHJldlNlZ21lbnRDdWxsZWQ7XFxuXFxcbiAgICBjbGlwTGluZVNlZ21lbnRUb05lYXJQbGFuZShwcmV2RUMueHl6LCBwb3NpdGlvbkVDLnh5eiwgY2xpcHBlZFByZXZXQywgcHJldlNlZ21lbnRDbGlwcGVkLCBwcmV2U2VnbWVudEN1bGxlZCwgY2xpcHBlZFByZXZFQyk7XFxuXFxcblxcblxcXG4gICAgdmVjNCBjbGlwcGVkTmV4dFdDLCBjbGlwcGVkTmV4dEVDO1xcblxcXG4gICAgYm9vbCBuZXh0U2VnbWVudENsaXBwZWQsIG5leHRTZWdtZW50Q3VsbGVkO1xcblxcXG4gICAgY2xpcExpbmVTZWdtZW50VG9OZWFyUGxhbmUobmV4dEVDLnh5eiwgcG9zaXRpb25FQy54eXosIGNsaXBwZWROZXh0V0MsIG5leHRTZWdtZW50Q2xpcHBlZCwgbmV4dFNlZ21lbnRDdWxsZWQsIGNsaXBwZWROZXh0RUMpO1xcblxcXG5cXG5cXFxuICAgIGJvb2wgc2VnbWVudENsaXBwZWQsIHNlZ21lbnRDdWxsZWQ7XFxuXFxcbiAgICB2ZWM0IGNsaXBwZWRQb3NpdGlvbldDLCBjbGlwcGVkUG9zaXRpb25FQztcXG5cXFxuICAgIGNsaXBMaW5lU2VnbWVudFRvTmVhclBsYW5lKHBvc2l0aW9uRUMueHl6LCB1c2VQcmV2aW91cyA/IHByZXZFQy54eXogOiBuZXh0RUMueHl6LCBjbGlwcGVkUG9zaXRpb25XQywgc2VnbWVudENsaXBwZWQsIHNlZ21lbnRDdWxsZWQsIGNsaXBwZWRQb3NpdGlvbkVDKTtcXG5cXFxuXFxuXFxcbiAgICBpZiAoc2VnbWVudEN1bGxlZClcXG5cXFxuICAgIHtcXG5cXFxuICAgICAgICByZXR1cm4gdmVjNCgwLjAsIDAuMCwgMC4wLCAxLjApO1xcblxcXG4gICAgfVxcblxcXG5cXG5cXFxuICAgIHZlYzIgZGlyZWN0aW9uVG9QcmV2V0MgPSBub3JtYWxpemUoY2xpcHBlZFByZXZXQy54eSAtIGNsaXBwZWRQb3NpdGlvbldDLnh5KTtcXG5cXFxuICAgIHZlYzIgZGlyZWN0aW9uVG9OZXh0V0MgPSBub3JtYWxpemUoY2xpcHBlZE5leHRXQy54eSAtIGNsaXBwZWRQb3NpdGlvbldDLnh5KTtcXG5cXFxuXFxuXFxcbiAgICAvLyBJZiBhIHNlZ21lbnQgd2FzIGN1bGxlZCwgd2UgY2FuJ3QgdXNlIHRoZSBjb3JyZXNwb25kaW5nIGRpcmVjdGlvblxcblxcXG4gICAgLy8gY29tcHV0ZWQgYWJvdmUuIFdlIHNob3VsZCBuZXZlciBzZWUgYm90aCBvZiB0aGVzZSBiZSB0cnVlIHdpdGhvdXRcXG5cXFxuICAgIC8vIGBzZWdtZW50Q3VsbGVkYCBhYm92ZSBhbHNvIGJlaW5nIHRydWUuXFxuXFxcbiAgICBpZiAocHJldlNlZ21lbnRDdWxsZWQpXFxuXFxcbiAgICB7XFxuXFxcbiAgICAgICAgZGlyZWN0aW9uVG9QcmV2V0MgPSAtZGlyZWN0aW9uVG9OZXh0V0M7XFxuXFxcbiAgICB9XFxuXFxcbiAgICBlbHNlIGlmIChuZXh0U2VnbWVudEN1bGxlZClcXG5cXFxuICAgIHtcXG5cXFxuICAgICAgICBkaXJlY3Rpb25Ub05leHRXQyA9IC1kaXJlY3Rpb25Ub1ByZXZXQztcXG5cXFxuICAgIH1cXG5cXFxuXFxuXFxcbiAgICB2ZWMyIHRoaXNTZWdtZW50Rm9yd2FyZFdDLCBvdGhlclNlZ21lbnRGb3J3YXJkV0M7XFxuXFxcbiAgICBpZiAodXNlUHJldmlvdXMpXFxuXFxcbiAgICB7XFxuXFxcbiAgICAgICAgdGhpc1NlZ21lbnRGb3J3YXJkV0MgPSAtZGlyZWN0aW9uVG9QcmV2V0M7XFxuXFxcbiAgICAgICAgb3RoZXJTZWdtZW50Rm9yd2FyZFdDID0gZGlyZWN0aW9uVG9OZXh0V0M7XFxuXFxcbiAgICB9XFxuXFxcbiAgICBlbHNlXFxuXFxcbiAgICB7XFxuXFxcbiAgICAgICAgdGhpc1NlZ21lbnRGb3J3YXJkV0MgPSBkaXJlY3Rpb25Ub05leHRXQztcXG5cXFxuICAgICAgICBvdGhlclNlZ21lbnRGb3J3YXJkV0MgPSAgLWRpcmVjdGlvblRvUHJldldDO1xcblxcXG4gICAgfVxcblxcXG5cXG5cXFxuICAgIHZlYzIgdGhpc1NlZ21lbnRMZWZ0V0MgPSB2ZWMyKC10aGlzU2VnbWVudEZvcndhcmRXQy55LCB0aGlzU2VnbWVudEZvcndhcmRXQy54KTtcXG5cXFxuXFxuXFxcbiAgICB2ZWMyIGxlZnRXQyA9IHRoaXNTZWdtZW50TGVmdFdDO1xcblxcXG4gICAgZmxvYXQgZXhwYW5kV2lkdGggPSB3aWR0aCAqIDAuNTtcXG5cXFxuXFxuXFxcbiAgICAvLyBXaGVuIGxpbmVzIGFyZSBzcGxpdCBhdCB0aGUgYW50aS1tZXJpZGlhbiwgdGhlIHBvc2l0aW9uIG1heSBiZSBhdCB0aGVcXG5cXFxuICAgIC8vIHNhbWUgbG9jYXRpb24gYXMgdGhlIG5leHQgb3IgcHJldmlvdXMgcG9zaXRpb24sIGFuZCB3ZSBuZWVkIHRvIGhhbmRsZVxcblxcXG4gICAgLy8gdGhhdCB0byBhdm9pZCBwcm9kdWNpbmcgTmFOcy5cXG5cXFxuICAgIGlmICghY3ptX2VxdWFsc0Vwc2lsb24ocHJldkVDLnh5eiAtIHBvc2l0aW9uRUMueHl6LCB2ZWMzKDAuMCksIGN6bV9lcHNpbG9uMSkgJiYgIWN6bV9lcXVhbHNFcHNpbG9uKG5leHRFQy54eXogLSBwb3NpdGlvbkVDLnh5eiwgdmVjMygwLjApLCBjem1fZXBzaWxvbjEpKVxcblxcXG4gICAge1xcblxcXG4gICAgICAgIHZlYzIgb3RoZXJTZWdtZW50TGVmdFdDID0gdmVjMigtb3RoZXJTZWdtZW50Rm9yd2FyZFdDLnksIG90aGVyU2VnbWVudEZvcndhcmRXQy54KTtcXG5cXFxuXFxuXFxcbiAgICAgICAgdmVjMiBsZWZ0U3VtV0MgPSB0aGlzU2VnbWVudExlZnRXQyArIG90aGVyU2VnbWVudExlZnRXQztcXG5cXFxuICAgICAgICBmbG9hdCBsZWZ0U3VtTGVuZ3RoID0gbGVuZ3RoKGxlZnRTdW1XQyk7XFxuXFxcbiAgICAgICAgbGVmdFdDID0gbGVmdFN1bUxlbmd0aCA8IGN6bV9lcHNpbG9uNiA/IHRoaXNTZWdtZW50TGVmdFdDIDogKGxlZnRTdW1XQyAvIGxlZnRTdW1MZW5ndGgpO1xcblxcXG5cXG5cXFxuICAgICAgICAvLyBUaGUgc2luZSBvZiB0aGUgYW5nbGUgYmV0d2VlbiB0aGUgdHdvIHZlY3RvcnMgaXMgZ2l2ZW4gYnkgdGhlIGZvcm11bGFcXG5cXFxuICAgICAgICAvLyAgICAgICAgIHxhIHggYnwgPSB8YXx8YnxzaW4odGhldGEpXFxuXFxcbiAgICAgICAgLy8gd2hpY2ggaXNcXG5cXFxuICAgICAgICAvLyAgICAgZmxvYXQgc2luQW5nbGUgPSBsZW5ndGgoY3Jvc3ModmVjMyhsZWZ0V0MsIDAuMCksIHZlYzMoLXRoaXNTZWdtZW50Rm9yd2FyZFdDLCAwLjApKSk7XFxuXFxcbiAgICAgICAgLy8gQmVjYXVzZSB0aGUgeiBjb21wb25lbnRzIG9mIGJvdGggdmVjdG9ycyBhcmUgemVybywgdGhlIHggYW5kIHkgY29vcmRpbmF0ZSB3aWxsIGJlIHplcm8uXFxuXFxcbiAgICAgICAgLy8gVGhlcmVmb3JlLCB0aGUgc2luZSBvZiB0aGUgYW5nbGUgaXMganVzdCB0aGUgeiBjb21wb25lbnQgb2YgdGhlIGNyb3NzIHByb2R1Y3QuXFxuXFxcbiAgICAgICAgdmVjMiB1ID0gLXRoaXNTZWdtZW50Rm9yd2FyZFdDO1xcblxcXG4gICAgICAgIHZlYzIgdiA9IGxlZnRXQztcXG5cXFxuICAgICAgICBmbG9hdCBzaW5BbmdsZSA9IGFicyh1LnggKiB2LnkgLSB1LnkgKiB2LngpO1xcblxcXG4gICAgICAgIGV4cGFuZFdpZHRoID0gY2xhbXAoZXhwYW5kV2lkdGggLyBzaW5BbmdsZSwgMC4wLCB3aWR0aCAqIDIuMCk7XFxuXFxcbiAgICB9XFxuXFxcblxcblxcXG4gICAgdmVjMiBvZmZzZXQgPSBsZWZ0V0MgKiBleHBhbmREaXJlY3Rpb24gKiBleHBhbmRXaWR0aCAqIGN6bV9waXhlbFJhdGlvO1xcblxcXG4gICAgcmV0dXJuIHZlYzQoY2xpcHBlZFBvc2l0aW9uV0MueHkgKyBvZmZzZXQsIC1jbGlwcGVkUG9zaXRpb25XQy56LCAxLjApICogKGN6bV9wcm9qZWN0aW9uICogY2xpcHBlZFBvc2l0aW9uRUMpLnc7XFxuXFxcbn1cXG5cXFxuXFxuXFxcbnZlYzQgZ2V0UG9seWxpbmVXaW5kb3dDb29yZGluYXRlcyh2ZWM0IHBvc2l0aW9uLCB2ZWM0IHByZXZpb3VzLCB2ZWM0IG5leHQsIGZsb2F0IGV4cGFuZERpcmVjdGlvbiwgZmxvYXQgd2lkdGgsIGJvb2wgdXNlUHJldmlvdXMsIG91dCBmbG9hdCBhbmdsZSlcXG5cXFxue1xcblxcXG4gICAgdmVjNCBwb3NpdGlvbkVDID0gY3ptX21vZGVsVmlld1JlbGF0aXZlVG9FeWUgKiBwb3NpdGlvbjtcXG5cXFxuICAgIHZlYzQgcHJldkVDID0gY3ptX21vZGVsVmlld1JlbGF0aXZlVG9FeWUgKiBwcmV2aW91cztcXG5cXFxuICAgIHZlYzQgbmV4dEVDID0gY3ptX21vZGVsVmlld1JlbGF0aXZlVG9FeWUgKiBuZXh0O1xcblxcXG4gICAgcmV0dXJuIGdldFBvbHlsaW5lV2luZG93Q29vcmRpbmF0ZXNFQyhwb3NpdGlvbkVDLCBwcmV2RUMsIG5leHRFQywgZXhwYW5kRGlyZWN0aW9uLCB3aWR0aCwgdXNlUHJldmlvdXMsIGFuZ2xlKTtcXG5cXFxufVxcblxcXG5cIjtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///94373\n')},36449:function(__unused_webpack___webpack_module__,__webpack_exports__){eval('//This file is automatically rebuilt by the Cesium build process.\n/* harmony default export */ __webpack_exports__["Z"] = ("#ifdef VECTOR_TILE\\n\\\nuniform vec4 u_highlightColor;\\n\\\n#endif\\n\\\n\\n\\\nvarying vec2 v_st;\\n\\\n\\n\\\nvoid main()\\n\\\n{\\n\\\n    czm_materialInput materialInput;\\n\\\n\\n\\\n    vec2 st = v_st;\\n\\\n    st.t = czm_readNonPerspective(st.t, gl_FragCoord.w);\\n\\\n\\n\\\n    materialInput.s = st.s;\\n\\\n    materialInput.st = st;\\n\\\n    materialInput.str = vec3(st, 0.0);\\n\\\n\\n\\\n    czm_material material = czm_getMaterial(materialInput);\\n\\\n    gl_FragColor = vec4(material.diffuse + material.emission, material.alpha);\\n\\\n#ifdef VECTOR_TILE\\n\\\n    gl_FragColor *= u_highlightColor;\\n\\\n#endif\\n\\\n\\n\\\n    czm_writeLogDepth();\\n\\\n}\\n\\\n");\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMzY0NDkuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQSx5REFBZTtBQUNmLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQSxDQUFDO0FBQ0Qsb0NBQW9DO0FBQ3BDO0FBQ0EsbUJBQW1CO0FBQ25CLHdEQUF3RDtBQUN4RDtBQUNBLDJCQUEyQjtBQUMzQiwwQkFBMEI7QUFDMUIsc0NBQXNDO0FBQ3RDO0FBQ0EsMkRBQTJEO0FBQzNELDhFQUE4RTtBQUM5RTtBQUNBLHFDQUFxQztBQUNyQztBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCLENBQUM7QUFDRCxDQUFDLEVBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly92dWUzLXdlYnBhY2s1Ly4vbm9kZV9tb2R1bGVzL2Nlc2l1bS9Tb3VyY2UvU2hhZGVycy9Qb2x5bGluZUZTLmpzPzQ1MDEiXSwic291cmNlc0NvbnRlbnQiOlsiLy9UaGlzIGZpbGUgaXMgYXV0b21hdGljYWxseSByZWJ1aWx0IGJ5IHRoZSBDZXNpdW0gYnVpbGQgcHJvY2Vzcy5cbmV4cG9ydCBkZWZhdWx0IFwiI2lmZGVmIFZFQ1RPUl9USUxFXFxuXFxcbnVuaWZvcm0gdmVjNCB1X2hpZ2hsaWdodENvbG9yO1xcblxcXG4jZW5kaWZcXG5cXFxuXFxuXFxcbnZhcnlpbmcgdmVjMiB2X3N0O1xcblxcXG5cXG5cXFxudm9pZCBtYWluKClcXG5cXFxue1xcblxcXG4gICAgY3ptX21hdGVyaWFsSW5wdXQgbWF0ZXJpYWxJbnB1dDtcXG5cXFxuXFxuXFxcbiAgICB2ZWMyIHN0ID0gdl9zdDtcXG5cXFxuICAgIHN0LnQgPSBjem1fcmVhZE5vblBlcnNwZWN0aXZlKHN0LnQsIGdsX0ZyYWdDb29yZC53KTtcXG5cXFxuXFxuXFxcbiAgICBtYXRlcmlhbElucHV0LnMgPSBzdC5zO1xcblxcXG4gICAgbWF0ZXJpYWxJbnB1dC5zdCA9IHN0O1xcblxcXG4gICAgbWF0ZXJpYWxJbnB1dC5zdHIgPSB2ZWMzKHN0LCAwLjApO1xcblxcXG5cXG5cXFxuICAgIGN6bV9tYXRlcmlhbCBtYXRlcmlhbCA9IGN6bV9nZXRNYXRlcmlhbChtYXRlcmlhbElucHV0KTtcXG5cXFxuICAgIGdsX0ZyYWdDb2xvciA9IHZlYzQobWF0ZXJpYWwuZGlmZnVzZSArIG1hdGVyaWFsLmVtaXNzaW9uLCBtYXRlcmlhbC5hbHBoYSk7XFxuXFxcbiNpZmRlZiBWRUNUT1JfVElMRVxcblxcXG4gICAgZ2xfRnJhZ0NvbG9yICo9IHVfaGlnaGxpZ2h0Q29sb3I7XFxuXFxcbiNlbmRpZlxcblxcXG5cXG5cXFxuICAgIGN6bV93cml0ZUxvZ0RlcHRoKCk7XFxuXFxcbn1cXG5cXFxuXCI7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///36449\n')},145:function(__unused_webpack___webpack_module__,__webpack_exports__){eval('//This file is automatically rebuilt by the Cesium build process.\n/* harmony default export */ __webpack_exports__["Z"] = ("#ifdef GL_EXT_frag_depth\\n\\\n#extension GL_EXT_frag_depth : enable\\n\\\n#endif\\n\\\n\\n\\\nvarying vec4 v_startPlaneNormalEcAndHalfWidth;\\n\\\nvarying vec4 v_endPlaneNormalEcAndBatchId;\\n\\\nvarying vec4 v_rightPlaneEC; // Technically can compute distance for this here\\n\\\nvarying vec4 v_endEcAndStartEcX;\\n\\\nvarying vec4 v_texcoordNormalizationAndStartEcYZ;\\n\\\n\\n\\\n#ifdef PER_INSTANCE_COLOR\\n\\\nvarying vec4 v_color;\\n\\\n#endif\\n\\\n\\n\\\nvoid main(void)\\n\\\n{\\n\\\n    float logDepthOrDepth = czm_branchFreeTernary(czm_sceneMode == czm_sceneMode2D, gl_FragCoord.z, czm_unpackDepth(texture2D(czm_globeDepthTexture, gl_FragCoord.xy / czm_viewport.zw)));\\n\\\n    vec3 ecStart = vec3(v_endEcAndStartEcX.w, v_texcoordNormalizationAndStartEcYZ.zw);\\n\\\n\\n\\\n    // Discard for sky\\n\\\n    if (logDepthOrDepth == 0.0) {\\n\\\n#ifdef DEBUG_SHOW_VOLUME\\n\\\n        gl_FragColor = vec4(1.0, 0.0, 0.0, 0.5);\\n\\\n        return;\\n\\\n#else // DEBUG_SHOW_VOLUME\\n\\\n        discard;\\n\\\n#endif // DEBUG_SHOW_VOLUME\\n\\\n    }\\n\\\n\\n\\\n    vec4 eyeCoordinate = czm_windowToEyeCoordinates(gl_FragCoord.xy, logDepthOrDepth);\\n\\\n    eyeCoordinate /= eyeCoordinate.w;\\n\\\n\\n\\\n    float halfMaxWidth = v_startPlaneNormalEcAndHalfWidth.w * czm_metersPerPixel(eyeCoordinate);\\n\\\n    // Check distance of the eye coordinate against the right-facing plane\\n\\\n    float widthwiseDistance = czm_planeDistance(v_rightPlaneEC, eyeCoordinate.xyz);\\n\\\n\\n\\\n    // Check eye coordinate against the mitering planes\\n\\\n    float distanceFromStart = czm_planeDistance(v_startPlaneNormalEcAndHalfWidth.xyz, -dot(ecStart, v_startPlaneNormalEcAndHalfWidth.xyz), eyeCoordinate.xyz);\\n\\\n    float distanceFromEnd = czm_planeDistance(v_endPlaneNormalEcAndBatchId.xyz, -dot(v_endEcAndStartEcX.xyz, v_endPlaneNormalEcAndBatchId.xyz), eyeCoordinate.xyz);\\n\\\n\\n\\\n    if (abs(widthwiseDistance) > halfMaxWidth || distanceFromStart < 0.0 || distanceFromEnd < 0.0) {\\n\\\n#ifdef DEBUG_SHOW_VOLUME\\n\\\n        gl_FragColor = vec4(1.0, 0.0, 0.0, 0.5);\\n\\\n        return;\\n\\\n#else // DEBUG_SHOW_VOLUME\\n\\\n        discard;\\n\\\n#endif // DEBUG_SHOW_VOLUME\\n\\\n    }\\n\\\n\\n\\\n    // Check distance of the eye coordinate against start and end planes with normals in the right plane.\\n\\\n    // For computing unskewed lengthwise texture coordinate.\\n\\\n    // Can also be used for clipping extremely pointy miters, but in practice unnecessary because of miter breaking.\\n\\\n\\n\\\n    // aligned plane: cross the right plane normal with miter plane normal, then cross the result with right again to point it more \\"forward\\"\\n\\\n    vec3 alignedPlaneNormal;\\n\\\n\\n\\\n    // start aligned plane\\n\\\n    alignedPlaneNormal = cross(v_rightPlaneEC.xyz, v_startPlaneNormalEcAndHalfWidth.xyz);\\n\\\n    alignedPlaneNormal = normalize(cross(alignedPlaneNormal, v_rightPlaneEC.xyz));\\n\\\n    distanceFromStart = czm_planeDistance(alignedPlaneNormal, -dot(alignedPlaneNormal, ecStart), eyeCoordinate.xyz);\\n\\\n\\n\\\n    // end aligned plane\\n\\\n    alignedPlaneNormal = cross(v_rightPlaneEC.xyz, v_endPlaneNormalEcAndBatchId.xyz);\\n\\\n    alignedPlaneNormal = normalize(cross(alignedPlaneNormal, v_rightPlaneEC.xyz));\\n\\\n    distanceFromEnd = czm_planeDistance(alignedPlaneNormal, -dot(alignedPlaneNormal, v_endEcAndStartEcX.xyz), eyeCoordinate.xyz);\\n\\\n\\n\\\n#ifdef PER_INSTANCE_COLOR\\n\\\n    gl_FragColor = czm_gammaCorrect(v_color);\\n\\\n#else // PER_INSTANCE_COLOR\\n\\\n    // Clamp - distance to aligned planes may be negative due to mitering,\\n\\\n    // so fragment texture coordinate might be out-of-bounds.\\n\\\n    float s = clamp(distanceFromStart / (distanceFromStart + distanceFromEnd), 0.0, 1.0);\\n\\\n    s = (s * v_texcoordNormalizationAndStartEcYZ.x) + v_texcoordNormalizationAndStartEcYZ.y;\\n\\\n    float t = (widthwiseDistance + halfMaxWidth) / (2.0 * halfMaxWidth);\\n\\\n\\n\\\n    czm_materialInput materialInput;\\n\\\n\\n\\\n    materialInput.s = s;\\n\\\n    materialInput.st = vec2(s, t);\\n\\\n    materialInput.str = vec3(s, t, 0.0);\\n\\\n\\n\\\n    czm_material material = czm_getMaterial(materialInput);\\n\\\n    gl_FragColor = vec4(material.diffuse + material.emission, material.alpha);\\n\\\n#endif // PER_INSTANCE_COLOR\\n\\\n\\n\\\n    // Premultiply alpha. Required for classification primitives on translucent globe.\\n\\\n    gl_FragColor.rgb *= gl_FragColor.a;\\n\\\n\\n\\\n    czm_writeDepthClamp();\\n\\\n}\\n\\\n");\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTQ1LmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0EseURBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEM7QUFDOUMsMENBQTBDO0FBQzFDLDZCQUE2QjtBQUM3QixnQ0FBZ0M7QUFDaEMsaURBQWlEO0FBQ2pEO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNELDBMQUEwTDtBQUMxTCxzRkFBc0Y7QUFDdEY7QUFDQTtBQUNBLGlDQUFpQztBQUNqQztBQUNBLGdEQUFnRDtBQUNoRCxlQUFlO0FBQ2Y7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQSxLQUFLO0FBQ0w7QUFDQSxzRkFBc0Y7QUFDdEYscUNBQXFDO0FBQ3JDO0FBQ0EsZ0dBQWdHO0FBQ2hHO0FBQ0EsbUZBQW1GO0FBQ25GO0FBQ0E7QUFDQSw4SkFBOEo7QUFDOUosbUtBQW1LO0FBQ25LO0FBQ0Esb0dBQW9HO0FBQ3BHO0FBQ0EsZ0RBQWdEO0FBQ2hELGVBQWU7QUFDZjtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBLHlGQUF5RjtBQUN6RixrRkFBa0Y7QUFDbEYsb0hBQW9IO0FBQ3BIO0FBQ0E7QUFDQSxxRkFBcUY7QUFDckYsa0ZBQWtGO0FBQ2xGLGlJQUFpSTtBQUNqSTtBQUNBO0FBQ0EsNkNBQTZDO0FBQzdDO0FBQ0E7QUFDQTtBQUNBLHlGQUF5RjtBQUN6Riw0RkFBNEY7QUFDNUYsd0VBQXdFO0FBQ3hFO0FBQ0Esb0NBQW9DO0FBQ3BDO0FBQ0Esd0JBQXdCO0FBQ3hCLGtDQUFrQztBQUNsQyx3Q0FBd0M7QUFDeEM7QUFDQSwyREFBMkQ7QUFDM0QsOEVBQThFO0FBQzlFO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QztBQUN2QztBQUNBLDBCQUEwQjtBQUMxQixDQUFDO0FBQ0QsQ0FBQyxFQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdnVlMy13ZWJwYWNrNS8uL25vZGVfbW9kdWxlcy9jZXNpdW0vU291cmNlL1NoYWRlcnMvUG9seWxpbmVTaGFkb3dWb2x1bWVGUy5qcz80OTNiIl0sInNvdXJjZXNDb250ZW50IjpbIi8vVGhpcyBmaWxlIGlzIGF1dG9tYXRpY2FsbHkgcmVidWlsdCBieSB0aGUgQ2VzaXVtIGJ1aWxkIHByb2Nlc3MuXG5leHBvcnQgZGVmYXVsdCBcIiNpZmRlZiBHTF9FWFRfZnJhZ19kZXB0aFxcblxcXG4jZXh0ZW5zaW9uIEdMX0VYVF9mcmFnX2RlcHRoIDogZW5hYmxlXFxuXFxcbiNlbmRpZlxcblxcXG5cXG5cXFxudmFyeWluZyB2ZWM0IHZfc3RhcnRQbGFuZU5vcm1hbEVjQW5kSGFsZldpZHRoO1xcblxcXG52YXJ5aW5nIHZlYzQgdl9lbmRQbGFuZU5vcm1hbEVjQW5kQmF0Y2hJZDtcXG5cXFxudmFyeWluZyB2ZWM0IHZfcmlnaHRQbGFuZUVDOyAvLyBUZWNobmljYWxseSBjYW4gY29tcHV0ZSBkaXN0YW5jZSBmb3IgdGhpcyBoZXJlXFxuXFxcbnZhcnlpbmcgdmVjNCB2X2VuZEVjQW5kU3RhcnRFY1g7XFxuXFxcbnZhcnlpbmcgdmVjNCB2X3RleGNvb3JkTm9ybWFsaXphdGlvbkFuZFN0YXJ0RWNZWjtcXG5cXFxuXFxuXFxcbiNpZmRlZiBQRVJfSU5TVEFOQ0VfQ09MT1JcXG5cXFxudmFyeWluZyB2ZWM0IHZfY29sb3I7XFxuXFxcbiNlbmRpZlxcblxcXG5cXG5cXFxudm9pZCBtYWluKHZvaWQpXFxuXFxcbntcXG5cXFxuICAgIGZsb2F0IGxvZ0RlcHRoT3JEZXB0aCA9IGN6bV9icmFuY2hGcmVlVGVybmFyeShjem1fc2NlbmVNb2RlID09IGN6bV9zY2VuZU1vZGUyRCwgZ2xfRnJhZ0Nvb3JkLnosIGN6bV91bnBhY2tEZXB0aCh0ZXh0dXJlMkQoY3ptX2dsb2JlRGVwdGhUZXh0dXJlLCBnbF9GcmFnQ29vcmQueHkgLyBjem1fdmlld3BvcnQuencpKSk7XFxuXFxcbiAgICB2ZWMzIGVjU3RhcnQgPSB2ZWMzKHZfZW5kRWNBbmRTdGFydEVjWC53LCB2X3RleGNvb3JkTm9ybWFsaXphdGlvbkFuZFN0YXJ0RWNZWi56dyk7XFxuXFxcblxcblxcXG4gICAgLy8gRGlzY2FyZCBmb3Igc2t5XFxuXFxcbiAgICBpZiAobG9nRGVwdGhPckRlcHRoID09IDAuMCkge1xcblxcXG4jaWZkZWYgREVCVUdfU0hPV19WT0xVTUVcXG5cXFxuICAgICAgICBnbF9GcmFnQ29sb3IgPSB2ZWM0KDEuMCwgMC4wLCAwLjAsIDAuNSk7XFxuXFxcbiAgICAgICAgcmV0dXJuO1xcblxcXG4jZWxzZSAvLyBERUJVR19TSE9XX1ZPTFVNRVxcblxcXG4gICAgICAgIGRpc2NhcmQ7XFxuXFxcbiNlbmRpZiAvLyBERUJVR19TSE9XX1ZPTFVNRVxcblxcXG4gICAgfVxcblxcXG5cXG5cXFxuICAgIHZlYzQgZXllQ29vcmRpbmF0ZSA9IGN6bV93aW5kb3dUb0V5ZUNvb3JkaW5hdGVzKGdsX0ZyYWdDb29yZC54eSwgbG9nRGVwdGhPckRlcHRoKTtcXG5cXFxuICAgIGV5ZUNvb3JkaW5hdGUgLz0gZXllQ29vcmRpbmF0ZS53O1xcblxcXG5cXG5cXFxuICAgIGZsb2F0IGhhbGZNYXhXaWR0aCA9IHZfc3RhcnRQbGFuZU5vcm1hbEVjQW5kSGFsZldpZHRoLncgKiBjem1fbWV0ZXJzUGVyUGl4ZWwoZXllQ29vcmRpbmF0ZSk7XFxuXFxcbiAgICAvLyBDaGVjayBkaXN0YW5jZSBvZiB0aGUgZXllIGNvb3JkaW5hdGUgYWdhaW5zdCB0aGUgcmlnaHQtZmFjaW5nIHBsYW5lXFxuXFxcbiAgICBmbG9hdCB3aWR0aHdpc2VEaXN0YW5jZSA9IGN6bV9wbGFuZURpc3RhbmNlKHZfcmlnaHRQbGFuZUVDLCBleWVDb29yZGluYXRlLnh5eik7XFxuXFxcblxcblxcXG4gICAgLy8gQ2hlY2sgZXllIGNvb3JkaW5hdGUgYWdhaW5zdCB0aGUgbWl0ZXJpbmcgcGxhbmVzXFxuXFxcbiAgICBmbG9hdCBkaXN0YW5jZUZyb21TdGFydCA9IGN6bV9wbGFuZURpc3RhbmNlKHZfc3RhcnRQbGFuZU5vcm1hbEVjQW5kSGFsZldpZHRoLnh5eiwgLWRvdChlY1N0YXJ0LCB2X3N0YXJ0UGxhbmVOb3JtYWxFY0FuZEhhbGZXaWR0aC54eXopLCBleWVDb29yZGluYXRlLnh5eik7XFxuXFxcbiAgICBmbG9hdCBkaXN0YW5jZUZyb21FbmQgPSBjem1fcGxhbmVEaXN0YW5jZSh2X2VuZFBsYW5lTm9ybWFsRWNBbmRCYXRjaElkLnh5eiwgLWRvdCh2X2VuZEVjQW5kU3RhcnRFY1gueHl6LCB2X2VuZFBsYW5lTm9ybWFsRWNBbmRCYXRjaElkLnh5eiksIGV5ZUNvb3JkaW5hdGUueHl6KTtcXG5cXFxuXFxuXFxcbiAgICBpZiAoYWJzKHdpZHRod2lzZURpc3RhbmNlKSA+IGhhbGZNYXhXaWR0aCB8fCBkaXN0YW5jZUZyb21TdGFydCA8IDAuMCB8fCBkaXN0YW5jZUZyb21FbmQgPCAwLjApIHtcXG5cXFxuI2lmZGVmIERFQlVHX1NIT1dfVk9MVU1FXFxuXFxcbiAgICAgICAgZ2xfRnJhZ0NvbG9yID0gdmVjNCgxLjAsIDAuMCwgMC4wLCAwLjUpO1xcblxcXG4gICAgICAgIHJldHVybjtcXG5cXFxuI2Vsc2UgLy8gREVCVUdfU0hPV19WT0xVTUVcXG5cXFxuICAgICAgICBkaXNjYXJkO1xcblxcXG4jZW5kaWYgLy8gREVCVUdfU0hPV19WT0xVTUVcXG5cXFxuICAgIH1cXG5cXFxuXFxuXFxcbiAgICAvLyBDaGVjayBkaXN0YW5jZSBvZiB0aGUgZXllIGNvb3JkaW5hdGUgYWdhaW5zdCBzdGFydCBhbmQgZW5kIHBsYW5lcyB3aXRoIG5vcm1hbHMgaW4gdGhlIHJpZ2h0IHBsYW5lLlxcblxcXG4gICAgLy8gRm9yIGNvbXB1dGluZyB1bnNrZXdlZCBsZW5ndGh3aXNlIHRleHR1cmUgY29vcmRpbmF0ZS5cXG5cXFxuICAgIC8vIENhbiBhbHNvIGJlIHVzZWQgZm9yIGNsaXBwaW5nIGV4dHJlbWVseSBwb2ludHkgbWl0ZXJzLCBidXQgaW4gcHJhY3RpY2UgdW5uZWNlc3NhcnkgYmVjYXVzZSBvZiBtaXRlciBicmVha2luZy5cXG5cXFxuXFxuXFxcbiAgICAvLyBhbGlnbmVkIHBsYW5lOiBjcm9zcyB0aGUgcmlnaHQgcGxhbmUgbm9ybWFsIHdpdGggbWl0ZXIgcGxhbmUgbm9ybWFsLCB0aGVuIGNyb3NzIHRoZSByZXN1bHQgd2l0aCByaWdodCBhZ2FpbiB0byBwb2ludCBpdCBtb3JlIFxcXCJmb3J3YXJkXFxcIlxcblxcXG4gICAgdmVjMyBhbGlnbmVkUGxhbmVOb3JtYWw7XFxuXFxcblxcblxcXG4gICAgLy8gc3RhcnQgYWxpZ25lZCBwbGFuZVxcblxcXG4gICAgYWxpZ25lZFBsYW5lTm9ybWFsID0gY3Jvc3Modl9yaWdodFBsYW5lRUMueHl6LCB2X3N0YXJ0UGxhbmVOb3JtYWxFY0FuZEhhbGZXaWR0aC54eXopO1xcblxcXG4gICAgYWxpZ25lZFBsYW5lTm9ybWFsID0gbm9ybWFsaXplKGNyb3NzKGFsaWduZWRQbGFuZU5vcm1hbCwgdl9yaWdodFBsYW5lRUMueHl6KSk7XFxuXFxcbiAgICBkaXN0YW5jZUZyb21TdGFydCA9IGN6bV9wbGFuZURpc3RhbmNlKGFsaWduZWRQbGFuZU5vcm1hbCwgLWRvdChhbGlnbmVkUGxhbmVOb3JtYWwsIGVjU3RhcnQpLCBleWVDb29yZGluYXRlLnh5eik7XFxuXFxcblxcblxcXG4gICAgLy8gZW5kIGFsaWduZWQgcGxhbmVcXG5cXFxuICAgIGFsaWduZWRQbGFuZU5vcm1hbCA9IGNyb3NzKHZfcmlnaHRQbGFuZUVDLnh5eiwgdl9lbmRQbGFuZU5vcm1hbEVjQW5kQmF0Y2hJZC54eXopO1xcblxcXG4gICAgYWxpZ25lZFBsYW5lTm9ybWFsID0gbm9ybWFsaXplKGNyb3NzKGFsaWduZWRQbGFuZU5vcm1hbCwgdl9yaWdodFBsYW5lRUMueHl6KSk7XFxuXFxcbiAgICBkaXN0YW5jZUZyb21FbmQgPSBjem1fcGxhbmVEaXN0YW5jZShhbGlnbmVkUGxhbmVOb3JtYWwsIC1kb3QoYWxpZ25lZFBsYW5lTm9ybWFsLCB2X2VuZEVjQW5kU3RhcnRFY1gueHl6KSwgZXllQ29vcmRpbmF0ZS54eXopO1xcblxcXG5cXG5cXFxuI2lmZGVmIFBFUl9JTlNUQU5DRV9DT0xPUlxcblxcXG4gICAgZ2xfRnJhZ0NvbG9yID0gY3ptX2dhbW1hQ29ycmVjdCh2X2NvbG9yKTtcXG5cXFxuI2Vsc2UgLy8gUEVSX0lOU1RBTkNFX0NPTE9SXFxuXFxcbiAgICAvLyBDbGFtcCAtIGRpc3RhbmNlIHRvIGFsaWduZWQgcGxhbmVzIG1heSBiZSBuZWdhdGl2ZSBkdWUgdG8gbWl0ZXJpbmcsXFxuXFxcbiAgICAvLyBzbyBmcmFnbWVudCB0ZXh0dXJlIGNvb3JkaW5hdGUgbWlnaHQgYmUgb3V0LW9mLWJvdW5kcy5cXG5cXFxuICAgIGZsb2F0IHMgPSBjbGFtcChkaXN0YW5jZUZyb21TdGFydCAvIChkaXN0YW5jZUZyb21TdGFydCArIGRpc3RhbmNlRnJvbUVuZCksIDAuMCwgMS4wKTtcXG5cXFxuICAgIHMgPSAocyAqIHZfdGV4Y29vcmROb3JtYWxpemF0aW9uQW5kU3RhcnRFY1laLngpICsgdl90ZXhjb29yZE5vcm1hbGl6YXRpb25BbmRTdGFydEVjWVoueTtcXG5cXFxuICAgIGZsb2F0IHQgPSAod2lkdGh3aXNlRGlzdGFuY2UgKyBoYWxmTWF4V2lkdGgpIC8gKDIuMCAqIGhhbGZNYXhXaWR0aCk7XFxuXFxcblxcblxcXG4gICAgY3ptX21hdGVyaWFsSW5wdXQgbWF0ZXJpYWxJbnB1dDtcXG5cXFxuXFxuXFxcbiAgICBtYXRlcmlhbElucHV0LnMgPSBzO1xcblxcXG4gICAgbWF0ZXJpYWxJbnB1dC5zdCA9IHZlYzIocywgdCk7XFxuXFxcbiAgICBtYXRlcmlhbElucHV0LnN0ciA9IHZlYzMocywgdCwgMC4wKTtcXG5cXFxuXFxuXFxcbiAgICBjem1fbWF0ZXJpYWwgbWF0ZXJpYWwgPSBjem1fZ2V0TWF0ZXJpYWwobWF0ZXJpYWxJbnB1dCk7XFxuXFxcbiAgICBnbF9GcmFnQ29sb3IgPSB2ZWM0KG1hdGVyaWFsLmRpZmZ1c2UgKyBtYXRlcmlhbC5lbWlzc2lvbiwgbWF0ZXJpYWwuYWxwaGEpO1xcblxcXG4jZW5kaWYgLy8gUEVSX0lOU1RBTkNFX0NPTE9SXFxuXFxcblxcblxcXG4gICAgLy8gUHJlbXVsdGlwbHkgYWxwaGEuIFJlcXVpcmVkIGZvciBjbGFzc2lmaWNhdGlvbiBwcmltaXRpdmVzIG9uIHRyYW5zbHVjZW50IGdsb2JlLlxcblxcXG4gICAgZ2xfRnJhZ0NvbG9yLnJnYiAqPSBnbF9GcmFnQ29sb3IuYTtcXG5cXFxuXFxuXFxcbiAgICBjem1fd3JpdGVEZXB0aENsYW1wKCk7XFxuXFxcbn1cXG5cXFxuXCI7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///145\n')},27610:function(__unused_webpack___webpack_module__,__webpack_exports__){eval('//This file is automatically rebuilt by the Cesium build process.\n/* harmony default export */ __webpack_exports__["Z"] = ("varying vec3 v_forwardDirectionEC;\\n\\\nvarying vec3 v_texcoordNormalizationAndHalfWidth;\\n\\\nvarying float v_batchId;\\n\\\n\\n\\\n#ifdef PER_INSTANCE_COLOR\\n\\\nvarying vec4 v_color;\\n\\\n#else\\n\\\nvarying vec2 v_alignedPlaneDistances;\\n\\\nvarying float v_texcoordT;\\n\\\n#endif\\n\\\n\\n\\\nfloat rayPlaneDistanceUnsafe(vec3 origin, vec3 direction, vec3 planeNormal, float planeDistance) {\\n\\\n    // We don\'t expect the ray to ever be parallel to the plane\\n\\\n    return (-planeDistance - dot(planeNormal, origin)) / dot(planeNormal, direction);\\n\\\n}\\n\\\n\\n\\\nvoid main(void)\\n\\\n{\\n\\\n    vec4 eyeCoordinate = gl_FragCoord;\\n\\\n    eyeCoordinate /= eyeCoordinate.w;\\n\\\n\\n\\\n#ifdef PER_INSTANCE_COLOR\\n\\\n    gl_FragColor = czm_gammaCorrect(v_color);\\n\\\n#else // PER_INSTANCE_COLOR\\n\\\n    // Use distances for planes aligned with segment to prevent skew in dashing\\n\\\n    float distanceFromStart = rayPlaneDistanceUnsafe(eyeCoordinate.xyz, -v_forwardDirectionEC, v_forwardDirectionEC.xyz, v_alignedPlaneDistances.x);\\n\\\n    float distanceFromEnd = rayPlaneDistanceUnsafe(eyeCoordinate.xyz, v_forwardDirectionEC, -v_forwardDirectionEC.xyz, v_alignedPlaneDistances.y);\\n\\\n\\n\\\n    // Clamp - distance to aligned planes may be negative due to mitering\\n\\\n    distanceFromStart = max(0.0, distanceFromStart);\\n\\\n    distanceFromEnd = max(0.0, distanceFromEnd);\\n\\\n\\n\\\n    float s = distanceFromStart / (distanceFromStart + distanceFromEnd);\\n\\\n    s = (s * v_texcoordNormalizationAndHalfWidth.x) + v_texcoordNormalizationAndHalfWidth.y;\\n\\\n\\n\\\n    czm_materialInput materialInput;\\n\\\n\\n\\\n    materialInput.s = s;\\n\\\n    materialInput.st = vec2(s, v_texcoordT);\\n\\\n    materialInput.str = vec3(s, v_texcoordT, 0.0);\\n\\\n\\n\\\n    czm_material material = czm_getMaterial(materialInput);\\n\\\n    gl_FragColor = vec4(material.diffuse + material.emission, material.alpha);\\n\\\n#endif // PER_INSTANCE_COLOR\\n\\\n}\\n\\\n");\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjc2MTAuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQSx5REFBZSxtQ0FBbUM7QUFDbEQsaURBQWlEO0FBQ2pELHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0EscUNBQXFDO0FBQ3JDLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0Esa0dBQWtHO0FBQ2xHO0FBQ0EscUZBQXFGO0FBQ3JGLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNELHNDQUFzQztBQUN0QyxxQ0FBcUM7QUFDckM7QUFDQTtBQUNBLDZDQUE2QztBQUM3QztBQUNBO0FBQ0Esb0pBQW9KO0FBQ3BKLGtKQUFrSjtBQUNsSjtBQUNBO0FBQ0Esb0RBQW9EO0FBQ3BELGdEQUFnRDtBQUNoRDtBQUNBLHdFQUF3RTtBQUN4RSw0RkFBNEY7QUFDNUY7QUFDQSxvQ0FBb0M7QUFDcEM7QUFDQSx3QkFBd0I7QUFDeEIsNENBQTRDO0FBQzVDLGtEQUFrRDtBQUNsRDtBQUNBLDJEQUEyRDtBQUMzRCw4RUFBOEU7QUFDOUU7QUFDQSxDQUFDO0FBQ0QsQ0FBQyxFQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdnVlMy13ZWJwYWNrNS8uL25vZGVfbW9kdWxlcy9jZXNpdW0vU291cmNlL1NoYWRlcnMvUG9seWxpbmVTaGFkb3dWb2x1bWVNb3JwaEZTLmpzPzhjNDMiXSwic291cmNlc0NvbnRlbnQiOlsiLy9UaGlzIGZpbGUgaXMgYXV0b21hdGljYWxseSByZWJ1aWx0IGJ5IHRoZSBDZXNpdW0gYnVpbGQgcHJvY2Vzcy5cbmV4cG9ydCBkZWZhdWx0IFwidmFyeWluZyB2ZWMzIHZfZm9yd2FyZERpcmVjdGlvbkVDO1xcblxcXG52YXJ5aW5nIHZlYzMgdl90ZXhjb29yZE5vcm1hbGl6YXRpb25BbmRIYWxmV2lkdGg7XFxuXFxcbnZhcnlpbmcgZmxvYXQgdl9iYXRjaElkO1xcblxcXG5cXG5cXFxuI2lmZGVmIFBFUl9JTlNUQU5DRV9DT0xPUlxcblxcXG52YXJ5aW5nIHZlYzQgdl9jb2xvcjtcXG5cXFxuI2Vsc2VcXG5cXFxudmFyeWluZyB2ZWMyIHZfYWxpZ25lZFBsYW5lRGlzdGFuY2VzO1xcblxcXG52YXJ5aW5nIGZsb2F0IHZfdGV4Y29vcmRUO1xcblxcXG4jZW5kaWZcXG5cXFxuXFxuXFxcbmZsb2F0IHJheVBsYW5lRGlzdGFuY2VVbnNhZmUodmVjMyBvcmlnaW4sIHZlYzMgZGlyZWN0aW9uLCB2ZWMzIHBsYW5lTm9ybWFsLCBmbG9hdCBwbGFuZURpc3RhbmNlKSB7XFxuXFxcbiAgICAvLyBXZSBkb24ndCBleHBlY3QgdGhlIHJheSB0byBldmVyIGJlIHBhcmFsbGVsIHRvIHRoZSBwbGFuZVxcblxcXG4gICAgcmV0dXJuICgtcGxhbmVEaXN0YW5jZSAtIGRvdChwbGFuZU5vcm1hbCwgb3JpZ2luKSkgLyBkb3QocGxhbmVOb3JtYWwsIGRpcmVjdGlvbik7XFxuXFxcbn1cXG5cXFxuXFxuXFxcbnZvaWQgbWFpbih2b2lkKVxcblxcXG57XFxuXFxcbiAgICB2ZWM0IGV5ZUNvb3JkaW5hdGUgPSBnbF9GcmFnQ29vcmQ7XFxuXFxcbiAgICBleWVDb29yZGluYXRlIC89IGV5ZUNvb3JkaW5hdGUudztcXG5cXFxuXFxuXFxcbiNpZmRlZiBQRVJfSU5TVEFOQ0VfQ09MT1JcXG5cXFxuICAgIGdsX0ZyYWdDb2xvciA9IGN6bV9nYW1tYUNvcnJlY3Qodl9jb2xvcik7XFxuXFxcbiNlbHNlIC8vIFBFUl9JTlNUQU5DRV9DT0xPUlxcblxcXG4gICAgLy8gVXNlIGRpc3RhbmNlcyBmb3IgcGxhbmVzIGFsaWduZWQgd2l0aCBzZWdtZW50IHRvIHByZXZlbnQgc2tldyBpbiBkYXNoaW5nXFxuXFxcbiAgICBmbG9hdCBkaXN0YW5jZUZyb21TdGFydCA9IHJheVBsYW5lRGlzdGFuY2VVbnNhZmUoZXllQ29vcmRpbmF0ZS54eXosIC12X2ZvcndhcmREaXJlY3Rpb25FQywgdl9mb3J3YXJkRGlyZWN0aW9uRUMueHl6LCB2X2FsaWduZWRQbGFuZURpc3RhbmNlcy54KTtcXG5cXFxuICAgIGZsb2F0IGRpc3RhbmNlRnJvbUVuZCA9IHJheVBsYW5lRGlzdGFuY2VVbnNhZmUoZXllQ29vcmRpbmF0ZS54eXosIHZfZm9yd2FyZERpcmVjdGlvbkVDLCAtdl9mb3J3YXJkRGlyZWN0aW9uRUMueHl6LCB2X2FsaWduZWRQbGFuZURpc3RhbmNlcy55KTtcXG5cXFxuXFxuXFxcbiAgICAvLyBDbGFtcCAtIGRpc3RhbmNlIHRvIGFsaWduZWQgcGxhbmVzIG1heSBiZSBuZWdhdGl2ZSBkdWUgdG8gbWl0ZXJpbmdcXG5cXFxuICAgIGRpc3RhbmNlRnJvbVN0YXJ0ID0gbWF4KDAuMCwgZGlzdGFuY2VGcm9tU3RhcnQpO1xcblxcXG4gICAgZGlzdGFuY2VGcm9tRW5kID0gbWF4KDAuMCwgZGlzdGFuY2VGcm9tRW5kKTtcXG5cXFxuXFxuXFxcbiAgICBmbG9hdCBzID0gZGlzdGFuY2VGcm9tU3RhcnQgLyAoZGlzdGFuY2VGcm9tU3RhcnQgKyBkaXN0YW5jZUZyb21FbmQpO1xcblxcXG4gICAgcyA9IChzICogdl90ZXhjb29yZE5vcm1hbGl6YXRpb25BbmRIYWxmV2lkdGgueCkgKyB2X3RleGNvb3JkTm9ybWFsaXphdGlvbkFuZEhhbGZXaWR0aC55O1xcblxcXG5cXG5cXFxuICAgIGN6bV9tYXRlcmlhbElucHV0IG1hdGVyaWFsSW5wdXQ7XFxuXFxcblxcblxcXG4gICAgbWF0ZXJpYWxJbnB1dC5zID0gcztcXG5cXFxuICAgIG1hdGVyaWFsSW5wdXQuc3QgPSB2ZWMyKHMsIHZfdGV4Y29vcmRUKTtcXG5cXFxuICAgIG1hdGVyaWFsSW5wdXQuc3RyID0gdmVjMyhzLCB2X3RleGNvb3JkVCwgMC4wKTtcXG5cXFxuXFxuXFxcbiAgICBjem1fbWF0ZXJpYWwgbWF0ZXJpYWwgPSBjem1fZ2V0TWF0ZXJpYWwobWF0ZXJpYWxJbnB1dCk7XFxuXFxcbiAgICBnbF9GcmFnQ29sb3IgPSB2ZWM0KG1hdGVyaWFsLmRpZmZ1c2UgKyBtYXRlcmlhbC5lbWlzc2lvbiwgbWF0ZXJpYWwuYWxwaGEpO1xcblxcXG4jZW5kaWYgLy8gUEVSX0lOU1RBTkNFX0NPTE9SXFxuXFxcbn1cXG5cXFxuXCI7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///27610\n')},38632:function(__unused_webpack___webpack_module__,__webpack_exports__){eval('//This file is automatically rebuilt by the Cesium build process.\n/* harmony default export */ __webpack_exports__["Z"] = ("attribute vec3 position3DHigh;\\n\\\nattribute vec3 position3DLow;\\n\\\n\\n\\\nattribute vec4 startHiAndForwardOffsetX;\\n\\\nattribute vec4 startLoAndForwardOffsetY;\\n\\\nattribute vec4 startNormalAndForwardOffsetZ;\\n\\\nattribute vec4 endNormalAndTextureCoordinateNormalizationX;\\n\\\nattribute vec4 rightNormalAndTextureCoordinateNormalizationY;\\n\\\nattribute vec4 startHiLo2D;\\n\\\nattribute vec4 offsetAndRight2D;\\n\\\nattribute vec4 startEndNormals2D;\\n\\\nattribute vec2 texcoordNormalization2D;\\n\\\n\\n\\\nattribute float batchId;\\n\\\n\\n\\\nvarying vec3 v_forwardDirectionEC;\\n\\\nvarying vec3 v_texcoordNormalizationAndHalfWidth;\\n\\\nvarying float v_batchId;\\n\\\n\\n\\\n// For materials\\n\\\n#ifdef WIDTH_VARYING\\n\\\nvarying float v_width;\\n\\\n#endif\\n\\\n#ifdef ANGLE_VARYING\\n\\\nvarying float v_polylineAngle;\\n\\\n#endif\\n\\\n\\n\\\n#ifdef PER_INSTANCE_COLOR\\n\\\nvarying vec4 v_color;\\n\\\n#else\\n\\\nvarying vec2 v_alignedPlaneDistances;\\n\\\nvarying float v_texcoordT;\\n\\\n#endif\\n\\\n\\n\\\n// Morphing planes using SLERP or NLERP doesn\'t seem to work, so instead draw the material directly on the shadow volume.\\n\\\n// Morph views are from very far away and aren\'t meant to be used precisely, so this should be sufficient.\\n\\\nvoid main()\\n\\\n{\\n\\\n    v_batchId = batchId;\\n\\\n\\n\\\n    // Start position\\n\\\n    vec4 posRelativeToEye2D = czm_translateRelativeToEye(vec3(0.0, startHiLo2D.xy), vec3(0.0, startHiLo2D.zw));\\n\\\n    vec4 posRelativeToEye3D = czm_translateRelativeToEye(startHiAndForwardOffsetX.xyz, startLoAndForwardOffsetY.xyz);\\n\\\n    vec4 posRelativeToEye = czm_columbusViewMorph(posRelativeToEye2D, posRelativeToEye3D, czm_morphTime);\\n\\\n    vec3 posEc2D = (czm_modelViewRelativeToEye * posRelativeToEye2D).xyz;\\n\\\n    vec3 posEc3D = (czm_modelViewRelativeToEye * posRelativeToEye3D).xyz;\\n\\\n    vec3 startEC = (czm_modelViewRelativeToEye * posRelativeToEye).xyz;\\n\\\n\\n\\\n    // Start plane\\n\\\n    vec4 startPlane2D;\\n\\\n    vec4 startPlane3D;\\n\\\n    startPlane2D.xyz = czm_normal * vec3(0.0, startEndNormals2D.xy);\\n\\\n    startPlane3D.xyz = czm_normal * startNormalAndForwardOffsetZ.xyz;\\n\\\n    startPlane2D.w = -dot(startPlane2D.xyz, posEc2D);\\n\\\n    startPlane3D.w = -dot(startPlane3D.xyz, posEc3D);\\n\\\n\\n\\\n    // Right plane\\n\\\n    vec4 rightPlane2D;\\n\\\n    vec4 rightPlane3D;\\n\\\n    rightPlane2D.xyz = czm_normal * vec3(0.0, offsetAndRight2D.zw);\\n\\\n    rightPlane3D.xyz = czm_normal * rightNormalAndTextureCoordinateNormalizationY.xyz;\\n\\\n    rightPlane2D.w = -dot(rightPlane2D.xyz, posEc2D);\\n\\\n    rightPlane3D.w = -dot(rightPlane3D.xyz, posEc3D);\\n\\\n\\n\\\n    // End position\\n\\\n    posRelativeToEye2D = posRelativeToEye2D + vec4(0.0, offsetAndRight2D.xy, 0.0);\\n\\\n    posRelativeToEye3D = posRelativeToEye3D + vec4(startHiAndForwardOffsetX.w, startLoAndForwardOffsetY.w, startNormalAndForwardOffsetZ.w, 0.0);\\n\\\n    posRelativeToEye = czm_columbusViewMorph(posRelativeToEye2D, posRelativeToEye3D, czm_morphTime);\\n\\\n    posEc2D = (czm_modelViewRelativeToEye * posRelativeToEye2D).xyz;\\n\\\n    posEc3D = (czm_modelViewRelativeToEye * posRelativeToEye3D).xyz;\\n\\\n    vec3 endEC = (czm_modelViewRelativeToEye * posRelativeToEye).xyz;\\n\\\n    vec3 forwardEc3D = czm_normal * normalize(vec3(startHiAndForwardOffsetX.w, startLoAndForwardOffsetY.w, startNormalAndForwardOffsetZ.w));\\n\\\n    vec3 forwardEc2D = czm_normal * normalize(vec3(0.0, offsetAndRight2D.xy));\\n\\\n\\n\\\n    // End plane\\n\\\n    vec4 endPlane2D;\\n\\\n    vec4 endPlane3D;\\n\\\n    endPlane2D.xyz = czm_normal * vec3(0.0, startEndNormals2D.zw);\\n\\\n    endPlane3D.xyz = czm_normal * endNormalAndTextureCoordinateNormalizationX.xyz;\\n\\\n    endPlane2D.w = -dot(endPlane2D.xyz, posEc2D);\\n\\\n    endPlane3D.w = -dot(endPlane3D.xyz, posEc3D);\\n\\\n\\n\\\n    // Forward direction\\n\\\n    v_forwardDirectionEC = normalize(endEC - startEC);\\n\\\n\\n\\\n    vec2 cleanTexcoordNormalization2D;\\n\\\n    cleanTexcoordNormalization2D.x = abs(texcoordNormalization2D.x);\\n\\\n    cleanTexcoordNormalization2D.y = czm_branchFreeTernary(texcoordNormalization2D.y > 1.0, 0.0, abs(texcoordNormalization2D.y));\\n\\\n    vec2 cleanTexcoordNormalization3D;\\n\\\n    cleanTexcoordNormalization3D.x = abs(endNormalAndTextureCoordinateNormalizationX.w);\\n\\\n    cleanTexcoordNormalization3D.y = rightNormalAndTextureCoordinateNormalizationY.w;\\n\\\n    cleanTexcoordNormalization3D.y = czm_branchFreeTernary(cleanTexcoordNormalization3D.y > 1.0, 0.0, abs(cleanTexcoordNormalization3D.y));\\n\\\n\\n\\\n    v_texcoordNormalizationAndHalfWidth.xy = mix(cleanTexcoordNormalization2D, cleanTexcoordNormalization3D, czm_morphTime);\\n\\\n\\n\\\n#ifdef PER_INSTANCE_COLOR\\n\\\n    v_color = czm_batchTable_color(batchId);\\n\\\n#else // PER_INSTANCE_COLOR\\n\\\n    // For computing texture coordinates\\n\\\n\\n\\\n    v_alignedPlaneDistances.x = -dot(v_forwardDirectionEC, startEC);\\n\\\n    v_alignedPlaneDistances.y = -dot(-v_forwardDirectionEC, endEC);\\n\\\n#endif // PER_INSTANCE_COLOR\\n\\\n\\n\\\n#ifdef WIDTH_VARYING\\n\\\n    float width = czm_batchTable_width(batchId);\\n\\\n    float halfWidth = width * 0.5;\\n\\\n    v_width = width;\\n\\\n    v_texcoordNormalizationAndHalfWidth.z = halfWidth;\\n\\\n#else\\n\\\n    float halfWidth = 0.5 * czm_batchTable_width(batchId);\\n\\\n    v_texcoordNormalizationAndHalfWidth.z = halfWidth;\\n\\\n#endif\\n\\\n\\n\\\n    // Compute a normal along which to \\"push\\" the position out, extending the miter depending on view distance.\\n\\\n    // Position has already been \\"pushed\\" by unit length along miter normal, and miter normals are encoded in the planes.\\n\\\n    // Decode the normal to use at this specific vertex, push the position back, and then push to where it needs to be.\\n\\\n    // Since this is morphing, compute both 3D and 2D positions and then blend.\\n\\\n\\n\\\n    // ****** 3D ******\\n\\\n    // Check distance to the end plane and start plane, pick the plane that is closer\\n\\\n    vec4 positionEc3D = czm_modelViewRelativeToEye * czm_translateRelativeToEye(position3DHigh, position3DLow); // w = 1.0, see czm_computePosition\\n\\\n    float absStartPlaneDistance = abs(czm_planeDistance(startPlane3D, positionEc3D.xyz));\\n\\\n    float absEndPlaneDistance = abs(czm_planeDistance(endPlane3D, positionEc3D.xyz));\\n\\\n    vec3 planeDirection = czm_branchFreeTernary(absStartPlaneDistance < absEndPlaneDistance, startPlane3D.xyz, endPlane3D.xyz);\\n\\\n    vec3 upOrDown = normalize(cross(rightPlane3D.xyz, planeDirection)); // Points \\"up\\" for start plane, \\"down\\" at end plane.\\n\\\n    vec3 normalEC = normalize(cross(planeDirection, upOrDown));         // In practice, the opposite seems to work too.\\n\\\n\\n\\\n    // Nudge the top vertex upwards to prevent flickering\\n\\\n    vec3 geodeticSurfaceNormal = normalize(cross(normalEC, forwardEc3D));\\n\\\n    geodeticSurfaceNormal *= float(0.0 <= rightNormalAndTextureCoordinateNormalizationY.w && rightNormalAndTextureCoordinateNormalizationY.w <= 1.0);\\n\\\n    geodeticSurfaceNormal *= MAX_TERRAIN_HEIGHT;\\n\\\n    positionEc3D.xyz += geodeticSurfaceNormal;\\n\\\n\\n\\\n    // Determine if this vertex is on the \\"left\\" or \\"right\\"\\n\\\n    normalEC *= sign(endNormalAndTextureCoordinateNormalizationX.w);\\n\\\n\\n\\\n    // A \\"perfect\\" implementation would push along normals according to the angle against forward.\\n\\\n    // In practice, just pushing the normal out by halfWidth is sufficient for morph views.\\n\\\n    positionEc3D.xyz += halfWidth * max(0.0, czm_metersPerPixel(positionEc3D)) * normalEC; // prevent artifacts when czm_metersPerPixel is negative (behind camera)\\n\\\n\\n\\\n    // ****** 2D ******\\n\\\n    // Check distance to the end plane and start plane, pick the plane that is closer\\n\\\n    vec4 positionEc2D = czm_modelViewRelativeToEye * czm_translateRelativeToEye(position2DHigh.zxy, position2DLow.zxy); // w = 1.0, see czm_computePosition\\n\\\n    absStartPlaneDistance = abs(czm_planeDistance(startPlane2D, positionEc2D.xyz));\\n\\\n    absEndPlaneDistance = abs(czm_planeDistance(endPlane2D, positionEc2D.xyz));\\n\\\n    planeDirection = czm_branchFreeTernary(absStartPlaneDistance < absEndPlaneDistance, startPlane2D.xyz, endPlane2D.xyz);\\n\\\n    upOrDown = normalize(cross(rightPlane2D.xyz, planeDirection)); // Points \\"up\\" for start plane, \\"down\\" at end plane.\\n\\\n    normalEC = normalize(cross(planeDirection, upOrDown));         // In practice, the opposite seems to work too.\\n\\\n\\n\\\n    // Nudge the top vertex upwards to prevent flickering\\n\\\n    geodeticSurfaceNormal = normalize(cross(normalEC, forwardEc2D));\\n\\\n    geodeticSurfaceNormal *= float(0.0 <= texcoordNormalization2D.y && texcoordNormalization2D.y <= 1.0);\\n\\\n    geodeticSurfaceNormal *= MAX_TERRAIN_HEIGHT;\\n\\\n    positionEc2D.xyz += geodeticSurfaceNormal;\\n\\\n\\n\\\n    // Determine if this vertex is on the \\"left\\" or \\"right\\"\\n\\\n    normalEC *= sign(texcoordNormalization2D.x);\\n\\\n#ifndef PER_INSTANCE_COLOR\\n\\\n    // Use vertex\'s sidedness to compute its texture coordinate.\\n\\\n    v_texcoordT = clamp(sign(texcoordNormalization2D.x), 0.0, 1.0);\\n\\\n#endif\\n\\\n\\n\\\n    // A \\"perfect\\" implementation would push along normals according to the angle against forward.\\n\\\n    // In practice, just pushing the normal out by halfWidth is sufficient for morph views.\\n\\\n    positionEc2D.xyz += halfWidth * max(0.0, czm_metersPerPixel(positionEc2D)) * normalEC; // prevent artifacts when czm_metersPerPixel is negative (behind camera)\\n\\\n\\n\\\n    // Blend for actual position\\n\\\n    gl_Position = czm_projection * mix(positionEc2D, positionEc3D, czm_morphTime);\\n\\\n\\n\\\n#ifdef ANGLE_VARYING\\n\\\n    // Approximate relative screen space direction of the line.\\n\\\n    vec2 approxLineDirection = normalize(vec2(v_forwardDirectionEC.x, -v_forwardDirectionEC.y));\\n\\\n    approxLineDirection.y = czm_branchFreeTernary(approxLineDirection.x == 0.0 && approxLineDirection.y == 0.0, -1.0, approxLineDirection.y);\\n\\\n    v_polylineAngle = czm_fastApproximateAtan(approxLineDirection.x, approxLineDirection.y);\\n\\\n#endif\\n\\\n}\\n\\\n");\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMzg2MzIuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQSx5REFBZSwrQkFBK0I7QUFDOUMsNkJBQTZCO0FBQzdCO0FBQ0Esd0NBQXdDO0FBQ3hDLHdDQUF3QztBQUN4Qyw0Q0FBNEM7QUFDNUMsMkRBQTJEO0FBQzNELDZEQUE2RDtBQUM3RCwyQkFBMkI7QUFDM0IsZ0NBQWdDO0FBQ2hDLGlDQUFpQztBQUNqQyx1Q0FBdUM7QUFDdkM7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQSxrQ0FBa0M7QUFDbEMsaURBQWlEO0FBQ2pELHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQSxxQ0FBcUM7QUFDckMsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Qsd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQSwrR0FBK0c7QUFDL0cscUhBQXFIO0FBQ3JILHlHQUF5RztBQUN6Ryx5RUFBeUU7QUFDekUseUVBQXlFO0FBQ3pFLHVFQUF1RTtBQUN2RTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCLHNCQUFzQjtBQUN0QixvRUFBb0U7QUFDcEUscUVBQXFFO0FBQ3JFLHFEQUFxRDtBQUNyRCxxREFBcUQ7QUFDckQ7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QixzQkFBc0I7QUFDdEIsbUVBQW1FO0FBQ25FLHNGQUFzRjtBQUN0RixxREFBcUQ7QUFDckQscURBQXFEO0FBQ3JEO0FBQ0E7QUFDQSxrRkFBa0Y7QUFDbEYsZ0pBQWdKO0FBQ2hKLG9HQUFvRztBQUNwRyxvRUFBb0U7QUFDcEUsb0VBQW9FO0FBQ3BFLHFFQUFxRTtBQUNyRSw0SUFBNEk7QUFDNUksOEVBQThFO0FBQzlFO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEIsb0JBQW9CO0FBQ3BCLGtFQUFrRTtBQUNsRSxrRkFBa0Y7QUFDbEYsaURBQWlEO0FBQ2pELGlEQUFpRDtBQUNqRDtBQUNBO0FBQ0Esc0RBQXNEO0FBQ3REO0FBQ0Esc0NBQXNDO0FBQ3RDLG9FQUFvRTtBQUNwRSxpSUFBaUk7QUFDakksc0NBQXNDO0FBQ3RDLHdGQUF3RjtBQUN4RixxRkFBcUY7QUFDckYsMklBQTJJO0FBQzNJO0FBQ0EsNEhBQTRIO0FBQzVIO0FBQ0E7QUFDQSw0Q0FBNEM7QUFDNUM7QUFDQTtBQUNBO0FBQ0Esb0VBQW9FO0FBQ3BFLG1FQUFtRTtBQUNuRTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0Q7QUFDaEQsa0NBQWtDO0FBQ2xDLG9CQUFvQjtBQUNwQixzREFBc0Q7QUFDdEQ7QUFDQSwwREFBMEQ7QUFDMUQsc0RBQXNEO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdIQUFnSDtBQUNoSCx5RkFBeUY7QUFDekYscUZBQXFGO0FBQ3JGLCtIQUErSDtBQUMvSCx3RUFBd0U7QUFDeEUsd0VBQXdFO0FBQ3hFO0FBQ0E7QUFDQSx5RUFBeUU7QUFDekUscUpBQXFKO0FBQ3JKLGdEQUFnRDtBQUNoRCw4Q0FBOEM7QUFDOUM7QUFDQTtBQUNBLG9FQUFvRTtBQUNwRTtBQUNBO0FBQ0E7QUFDQSwyRkFBMkY7QUFDM0Y7QUFDQTtBQUNBO0FBQ0Esd0hBQXdIO0FBQ3hILG1GQUFtRjtBQUNuRiwrRUFBK0U7QUFDL0UsMEhBQTBIO0FBQzFILG1FQUFtRTtBQUNuRSxtRUFBbUU7QUFDbkU7QUFDQTtBQUNBLG9FQUFvRTtBQUNwRSx5R0FBeUc7QUFDekcsZ0RBQWdEO0FBQ2hELDhDQUE4QztBQUM5QztBQUNBO0FBQ0EsZ0RBQWdEO0FBQ2hEO0FBQ0E7QUFDQSxtRUFBbUU7QUFDbkU7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyRkFBMkY7QUFDM0Y7QUFDQTtBQUNBLGtGQUFrRjtBQUNsRjtBQUNBO0FBQ0E7QUFDQSxnR0FBZ0c7QUFDaEcsNklBQTZJO0FBQzdJLDRGQUE0RjtBQUM1RjtBQUNBLENBQUM7QUFDRCxDQUFDLEVBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly92dWUzLXdlYnBhY2s1Ly4vbm9kZV9tb2R1bGVzL2Nlc2l1bS9Tb3VyY2UvU2hhZGVycy9Qb2x5bGluZVNoYWRvd1ZvbHVtZU1vcnBoVlMuanM/MTUyOCJdLCJzb3VyY2VzQ29udGVudCI6WyIvL1RoaXMgZmlsZSBpcyBhdXRvbWF0aWNhbGx5IHJlYnVpbHQgYnkgdGhlIENlc2l1bSBidWlsZCBwcm9jZXNzLlxuZXhwb3J0IGRlZmF1bHQgXCJhdHRyaWJ1dGUgdmVjMyBwb3NpdGlvbjNESGlnaDtcXG5cXFxuYXR0cmlidXRlIHZlYzMgcG9zaXRpb24zRExvdztcXG5cXFxuXFxuXFxcbmF0dHJpYnV0ZSB2ZWM0IHN0YXJ0SGlBbmRGb3J3YXJkT2Zmc2V0WDtcXG5cXFxuYXR0cmlidXRlIHZlYzQgc3RhcnRMb0FuZEZvcndhcmRPZmZzZXRZO1xcblxcXG5hdHRyaWJ1dGUgdmVjNCBzdGFydE5vcm1hbEFuZEZvcndhcmRPZmZzZXRaO1xcblxcXG5hdHRyaWJ1dGUgdmVjNCBlbmROb3JtYWxBbmRUZXh0dXJlQ29vcmRpbmF0ZU5vcm1hbGl6YXRpb25YO1xcblxcXG5hdHRyaWJ1dGUgdmVjNCByaWdodE5vcm1hbEFuZFRleHR1cmVDb29yZGluYXRlTm9ybWFsaXphdGlvblk7XFxuXFxcbmF0dHJpYnV0ZSB2ZWM0IHN0YXJ0SGlMbzJEO1xcblxcXG5hdHRyaWJ1dGUgdmVjNCBvZmZzZXRBbmRSaWdodDJEO1xcblxcXG5hdHRyaWJ1dGUgdmVjNCBzdGFydEVuZE5vcm1hbHMyRDtcXG5cXFxuYXR0cmlidXRlIHZlYzIgdGV4Y29vcmROb3JtYWxpemF0aW9uMkQ7XFxuXFxcblxcblxcXG5hdHRyaWJ1dGUgZmxvYXQgYmF0Y2hJZDtcXG5cXFxuXFxuXFxcbnZhcnlpbmcgdmVjMyB2X2ZvcndhcmREaXJlY3Rpb25FQztcXG5cXFxudmFyeWluZyB2ZWMzIHZfdGV4Y29vcmROb3JtYWxpemF0aW9uQW5kSGFsZldpZHRoO1xcblxcXG52YXJ5aW5nIGZsb2F0IHZfYmF0Y2hJZDtcXG5cXFxuXFxuXFxcbi8vIEZvciBtYXRlcmlhbHNcXG5cXFxuI2lmZGVmIFdJRFRIX1ZBUllJTkdcXG5cXFxudmFyeWluZyBmbG9hdCB2X3dpZHRoO1xcblxcXG4jZW5kaWZcXG5cXFxuI2lmZGVmIEFOR0xFX1ZBUllJTkdcXG5cXFxudmFyeWluZyBmbG9hdCB2X3BvbHlsaW5lQW5nbGU7XFxuXFxcbiNlbmRpZlxcblxcXG5cXG5cXFxuI2lmZGVmIFBFUl9JTlNUQU5DRV9DT0xPUlxcblxcXG52YXJ5aW5nIHZlYzQgdl9jb2xvcjtcXG5cXFxuI2Vsc2VcXG5cXFxudmFyeWluZyB2ZWMyIHZfYWxpZ25lZFBsYW5lRGlzdGFuY2VzO1xcblxcXG52YXJ5aW5nIGZsb2F0IHZfdGV4Y29vcmRUO1xcblxcXG4jZW5kaWZcXG5cXFxuXFxuXFxcbi8vIE1vcnBoaW5nIHBsYW5lcyB1c2luZyBTTEVSUCBvciBOTEVSUCBkb2Vzbid0IHNlZW0gdG8gd29yaywgc28gaW5zdGVhZCBkcmF3IHRoZSBtYXRlcmlhbCBkaXJlY3RseSBvbiB0aGUgc2hhZG93IHZvbHVtZS5cXG5cXFxuLy8gTW9ycGggdmlld3MgYXJlIGZyb20gdmVyeSBmYXIgYXdheSBhbmQgYXJlbid0IG1lYW50IHRvIGJlIHVzZWQgcHJlY2lzZWx5LCBzbyB0aGlzIHNob3VsZCBiZSBzdWZmaWNpZW50LlxcblxcXG52b2lkIG1haW4oKVxcblxcXG57XFxuXFxcbiAgICB2X2JhdGNoSWQgPSBiYXRjaElkO1xcblxcXG5cXG5cXFxuICAgIC8vIFN0YXJ0IHBvc2l0aW9uXFxuXFxcbiAgICB2ZWM0IHBvc1JlbGF0aXZlVG9FeWUyRCA9IGN6bV90cmFuc2xhdGVSZWxhdGl2ZVRvRXllKHZlYzMoMC4wLCBzdGFydEhpTG8yRC54eSksIHZlYzMoMC4wLCBzdGFydEhpTG8yRC56dykpO1xcblxcXG4gICAgdmVjNCBwb3NSZWxhdGl2ZVRvRXllM0QgPSBjem1fdHJhbnNsYXRlUmVsYXRpdmVUb0V5ZShzdGFydEhpQW5kRm9yd2FyZE9mZnNldFgueHl6LCBzdGFydExvQW5kRm9yd2FyZE9mZnNldFkueHl6KTtcXG5cXFxuICAgIHZlYzQgcG9zUmVsYXRpdmVUb0V5ZSA9IGN6bV9jb2x1bWJ1c1ZpZXdNb3JwaChwb3NSZWxhdGl2ZVRvRXllMkQsIHBvc1JlbGF0aXZlVG9FeWUzRCwgY3ptX21vcnBoVGltZSk7XFxuXFxcbiAgICB2ZWMzIHBvc0VjMkQgPSAoY3ptX21vZGVsVmlld1JlbGF0aXZlVG9FeWUgKiBwb3NSZWxhdGl2ZVRvRXllMkQpLnh5ejtcXG5cXFxuICAgIHZlYzMgcG9zRWMzRCA9IChjem1fbW9kZWxWaWV3UmVsYXRpdmVUb0V5ZSAqIHBvc1JlbGF0aXZlVG9FeWUzRCkueHl6O1xcblxcXG4gICAgdmVjMyBzdGFydEVDID0gKGN6bV9tb2RlbFZpZXdSZWxhdGl2ZVRvRXllICogcG9zUmVsYXRpdmVUb0V5ZSkueHl6O1xcblxcXG5cXG5cXFxuICAgIC8vIFN0YXJ0IHBsYW5lXFxuXFxcbiAgICB2ZWM0IHN0YXJ0UGxhbmUyRDtcXG5cXFxuICAgIHZlYzQgc3RhcnRQbGFuZTNEO1xcblxcXG4gICAgc3RhcnRQbGFuZTJELnh5eiA9IGN6bV9ub3JtYWwgKiB2ZWMzKDAuMCwgc3RhcnRFbmROb3JtYWxzMkQueHkpO1xcblxcXG4gICAgc3RhcnRQbGFuZTNELnh5eiA9IGN6bV9ub3JtYWwgKiBzdGFydE5vcm1hbEFuZEZvcndhcmRPZmZzZXRaLnh5ejtcXG5cXFxuICAgIHN0YXJ0UGxhbmUyRC53ID0gLWRvdChzdGFydFBsYW5lMkQueHl6LCBwb3NFYzJEKTtcXG5cXFxuICAgIHN0YXJ0UGxhbmUzRC53ID0gLWRvdChzdGFydFBsYW5lM0QueHl6LCBwb3NFYzNEKTtcXG5cXFxuXFxuXFxcbiAgICAvLyBSaWdodCBwbGFuZVxcblxcXG4gICAgdmVjNCByaWdodFBsYW5lMkQ7XFxuXFxcbiAgICB2ZWM0IHJpZ2h0UGxhbmUzRDtcXG5cXFxuICAgIHJpZ2h0UGxhbmUyRC54eXogPSBjem1fbm9ybWFsICogdmVjMygwLjAsIG9mZnNldEFuZFJpZ2h0MkQuencpO1xcblxcXG4gICAgcmlnaHRQbGFuZTNELnh5eiA9IGN6bV9ub3JtYWwgKiByaWdodE5vcm1hbEFuZFRleHR1cmVDb29yZGluYXRlTm9ybWFsaXphdGlvblkueHl6O1xcblxcXG4gICAgcmlnaHRQbGFuZTJELncgPSAtZG90KHJpZ2h0UGxhbmUyRC54eXosIHBvc0VjMkQpO1xcblxcXG4gICAgcmlnaHRQbGFuZTNELncgPSAtZG90KHJpZ2h0UGxhbmUzRC54eXosIHBvc0VjM0QpO1xcblxcXG5cXG5cXFxuICAgIC8vIEVuZCBwb3NpdGlvblxcblxcXG4gICAgcG9zUmVsYXRpdmVUb0V5ZTJEID0gcG9zUmVsYXRpdmVUb0V5ZTJEICsgdmVjNCgwLjAsIG9mZnNldEFuZFJpZ2h0MkQueHksIDAuMCk7XFxuXFxcbiAgICBwb3NSZWxhdGl2ZVRvRXllM0QgPSBwb3NSZWxhdGl2ZVRvRXllM0QgKyB2ZWM0KHN0YXJ0SGlBbmRGb3J3YXJkT2Zmc2V0WC53LCBzdGFydExvQW5kRm9yd2FyZE9mZnNldFkudywgc3RhcnROb3JtYWxBbmRGb3J3YXJkT2Zmc2V0Wi53LCAwLjApO1xcblxcXG4gICAgcG9zUmVsYXRpdmVUb0V5ZSA9IGN6bV9jb2x1bWJ1c1ZpZXdNb3JwaChwb3NSZWxhdGl2ZVRvRXllMkQsIHBvc1JlbGF0aXZlVG9FeWUzRCwgY3ptX21vcnBoVGltZSk7XFxuXFxcbiAgICBwb3NFYzJEID0gKGN6bV9tb2RlbFZpZXdSZWxhdGl2ZVRvRXllICogcG9zUmVsYXRpdmVUb0V5ZTJEKS54eXo7XFxuXFxcbiAgICBwb3NFYzNEID0gKGN6bV9tb2RlbFZpZXdSZWxhdGl2ZVRvRXllICogcG9zUmVsYXRpdmVUb0V5ZTNEKS54eXo7XFxuXFxcbiAgICB2ZWMzIGVuZEVDID0gKGN6bV9tb2RlbFZpZXdSZWxhdGl2ZVRvRXllICogcG9zUmVsYXRpdmVUb0V5ZSkueHl6O1xcblxcXG4gICAgdmVjMyBmb3J3YXJkRWMzRCA9IGN6bV9ub3JtYWwgKiBub3JtYWxpemUodmVjMyhzdGFydEhpQW5kRm9yd2FyZE9mZnNldFgudywgc3RhcnRMb0FuZEZvcndhcmRPZmZzZXRZLncsIHN0YXJ0Tm9ybWFsQW5kRm9yd2FyZE9mZnNldFoudykpO1xcblxcXG4gICAgdmVjMyBmb3J3YXJkRWMyRCA9IGN6bV9ub3JtYWwgKiBub3JtYWxpemUodmVjMygwLjAsIG9mZnNldEFuZFJpZ2h0MkQueHkpKTtcXG5cXFxuXFxuXFxcbiAgICAvLyBFbmQgcGxhbmVcXG5cXFxuICAgIHZlYzQgZW5kUGxhbmUyRDtcXG5cXFxuICAgIHZlYzQgZW5kUGxhbmUzRDtcXG5cXFxuICAgIGVuZFBsYW5lMkQueHl6ID0gY3ptX25vcm1hbCAqIHZlYzMoMC4wLCBzdGFydEVuZE5vcm1hbHMyRC56dyk7XFxuXFxcbiAgICBlbmRQbGFuZTNELnh5eiA9IGN6bV9ub3JtYWwgKiBlbmROb3JtYWxBbmRUZXh0dXJlQ29vcmRpbmF0ZU5vcm1hbGl6YXRpb25YLnh5ejtcXG5cXFxuICAgIGVuZFBsYW5lMkQudyA9IC1kb3QoZW5kUGxhbmUyRC54eXosIHBvc0VjMkQpO1xcblxcXG4gICAgZW5kUGxhbmUzRC53ID0gLWRvdChlbmRQbGFuZTNELnh5eiwgcG9zRWMzRCk7XFxuXFxcblxcblxcXG4gICAgLy8gRm9yd2FyZCBkaXJlY3Rpb25cXG5cXFxuICAgIHZfZm9yd2FyZERpcmVjdGlvbkVDID0gbm9ybWFsaXplKGVuZEVDIC0gc3RhcnRFQyk7XFxuXFxcblxcblxcXG4gICAgdmVjMiBjbGVhblRleGNvb3JkTm9ybWFsaXphdGlvbjJEO1xcblxcXG4gICAgY2xlYW5UZXhjb29yZE5vcm1hbGl6YXRpb24yRC54ID0gYWJzKHRleGNvb3JkTm9ybWFsaXphdGlvbjJELngpO1xcblxcXG4gICAgY2xlYW5UZXhjb29yZE5vcm1hbGl6YXRpb24yRC55ID0gY3ptX2JyYW5jaEZyZWVUZXJuYXJ5KHRleGNvb3JkTm9ybWFsaXphdGlvbjJELnkgPiAxLjAsIDAuMCwgYWJzKHRleGNvb3JkTm9ybWFsaXphdGlvbjJELnkpKTtcXG5cXFxuICAgIHZlYzIgY2xlYW5UZXhjb29yZE5vcm1hbGl6YXRpb24zRDtcXG5cXFxuICAgIGNsZWFuVGV4Y29vcmROb3JtYWxpemF0aW9uM0QueCA9IGFicyhlbmROb3JtYWxBbmRUZXh0dXJlQ29vcmRpbmF0ZU5vcm1hbGl6YXRpb25YLncpO1xcblxcXG4gICAgY2xlYW5UZXhjb29yZE5vcm1hbGl6YXRpb24zRC55ID0gcmlnaHROb3JtYWxBbmRUZXh0dXJlQ29vcmRpbmF0ZU5vcm1hbGl6YXRpb25ZLnc7XFxuXFxcbiAgICBjbGVhblRleGNvb3JkTm9ybWFsaXphdGlvbjNELnkgPSBjem1fYnJhbmNoRnJlZVRlcm5hcnkoY2xlYW5UZXhjb29yZE5vcm1hbGl6YXRpb24zRC55ID4gMS4wLCAwLjAsIGFicyhjbGVhblRleGNvb3JkTm9ybWFsaXphdGlvbjNELnkpKTtcXG5cXFxuXFxuXFxcbiAgICB2X3RleGNvb3JkTm9ybWFsaXphdGlvbkFuZEhhbGZXaWR0aC54eSA9IG1peChjbGVhblRleGNvb3JkTm9ybWFsaXphdGlvbjJELCBjbGVhblRleGNvb3JkTm9ybWFsaXphdGlvbjNELCBjem1fbW9ycGhUaW1lKTtcXG5cXFxuXFxuXFxcbiNpZmRlZiBQRVJfSU5TVEFOQ0VfQ09MT1JcXG5cXFxuICAgIHZfY29sb3IgPSBjem1fYmF0Y2hUYWJsZV9jb2xvcihiYXRjaElkKTtcXG5cXFxuI2Vsc2UgLy8gUEVSX0lOU1RBTkNFX0NPTE9SXFxuXFxcbiAgICAvLyBGb3IgY29tcHV0aW5nIHRleHR1cmUgY29vcmRpbmF0ZXNcXG5cXFxuXFxuXFxcbiAgICB2X2FsaWduZWRQbGFuZURpc3RhbmNlcy54ID0gLWRvdCh2X2ZvcndhcmREaXJlY3Rpb25FQywgc3RhcnRFQyk7XFxuXFxcbiAgICB2X2FsaWduZWRQbGFuZURpc3RhbmNlcy55ID0gLWRvdCgtdl9mb3J3YXJkRGlyZWN0aW9uRUMsIGVuZEVDKTtcXG5cXFxuI2VuZGlmIC8vIFBFUl9JTlNUQU5DRV9DT0xPUlxcblxcXG5cXG5cXFxuI2lmZGVmIFdJRFRIX1ZBUllJTkdcXG5cXFxuICAgIGZsb2F0IHdpZHRoID0gY3ptX2JhdGNoVGFibGVfd2lkdGgoYmF0Y2hJZCk7XFxuXFxcbiAgICBmbG9hdCBoYWxmV2lkdGggPSB3aWR0aCAqIDAuNTtcXG5cXFxuICAgIHZfd2lkdGggPSB3aWR0aDtcXG5cXFxuICAgIHZfdGV4Y29vcmROb3JtYWxpemF0aW9uQW5kSGFsZldpZHRoLnogPSBoYWxmV2lkdGg7XFxuXFxcbiNlbHNlXFxuXFxcbiAgICBmbG9hdCBoYWxmV2lkdGggPSAwLjUgKiBjem1fYmF0Y2hUYWJsZV93aWR0aChiYXRjaElkKTtcXG5cXFxuICAgIHZfdGV4Y29vcmROb3JtYWxpemF0aW9uQW5kSGFsZldpZHRoLnogPSBoYWxmV2lkdGg7XFxuXFxcbiNlbmRpZlxcblxcXG5cXG5cXFxuICAgIC8vIENvbXB1dGUgYSBub3JtYWwgYWxvbmcgd2hpY2ggdG8gXFxcInB1c2hcXFwiIHRoZSBwb3NpdGlvbiBvdXQsIGV4dGVuZGluZyB0aGUgbWl0ZXIgZGVwZW5kaW5nIG9uIHZpZXcgZGlzdGFuY2UuXFxuXFxcbiAgICAvLyBQb3NpdGlvbiBoYXMgYWxyZWFkeSBiZWVuIFxcXCJwdXNoZWRcXFwiIGJ5IHVuaXQgbGVuZ3RoIGFsb25nIG1pdGVyIG5vcm1hbCwgYW5kIG1pdGVyIG5vcm1hbHMgYXJlIGVuY29kZWQgaW4gdGhlIHBsYW5lcy5cXG5cXFxuICAgIC8vIERlY29kZSB0aGUgbm9ybWFsIHRvIHVzZSBhdCB0aGlzIHNwZWNpZmljIHZlcnRleCwgcHVzaCB0aGUgcG9zaXRpb24gYmFjaywgYW5kIHRoZW4gcHVzaCB0byB3aGVyZSBpdCBuZWVkcyB0byBiZS5cXG5cXFxuICAgIC8vIFNpbmNlIHRoaXMgaXMgbW9ycGhpbmcsIGNvbXB1dGUgYm90aCAzRCBhbmQgMkQgcG9zaXRpb25zIGFuZCB0aGVuIGJsZW5kLlxcblxcXG5cXG5cXFxuICAgIC8vICoqKioqKiAzRCAqKioqKipcXG5cXFxuICAgIC8vIENoZWNrIGRpc3RhbmNlIHRvIHRoZSBlbmQgcGxhbmUgYW5kIHN0YXJ0IHBsYW5lLCBwaWNrIHRoZSBwbGFuZSB0aGF0IGlzIGNsb3NlclxcblxcXG4gICAgdmVjNCBwb3NpdGlvbkVjM0QgPSBjem1fbW9kZWxWaWV3UmVsYXRpdmVUb0V5ZSAqIGN6bV90cmFuc2xhdGVSZWxhdGl2ZVRvRXllKHBvc2l0aW9uM0RIaWdoLCBwb3NpdGlvbjNETG93KTsgLy8gdyA9IDEuMCwgc2VlIGN6bV9jb21wdXRlUG9zaXRpb25cXG5cXFxuICAgIGZsb2F0IGFic1N0YXJ0UGxhbmVEaXN0YW5jZSA9IGFicyhjem1fcGxhbmVEaXN0YW5jZShzdGFydFBsYW5lM0QsIHBvc2l0aW9uRWMzRC54eXopKTtcXG5cXFxuICAgIGZsb2F0IGFic0VuZFBsYW5lRGlzdGFuY2UgPSBhYnMoY3ptX3BsYW5lRGlzdGFuY2UoZW5kUGxhbmUzRCwgcG9zaXRpb25FYzNELnh5eikpO1xcblxcXG4gICAgdmVjMyBwbGFuZURpcmVjdGlvbiA9IGN6bV9icmFuY2hGcmVlVGVybmFyeShhYnNTdGFydFBsYW5lRGlzdGFuY2UgPCBhYnNFbmRQbGFuZURpc3RhbmNlLCBzdGFydFBsYW5lM0QueHl6LCBlbmRQbGFuZTNELnh5eik7XFxuXFxcbiAgICB2ZWMzIHVwT3JEb3duID0gbm9ybWFsaXplKGNyb3NzKHJpZ2h0UGxhbmUzRC54eXosIHBsYW5lRGlyZWN0aW9uKSk7IC8vIFBvaW50cyBcXFwidXBcXFwiIGZvciBzdGFydCBwbGFuZSwgXFxcImRvd25cXFwiIGF0IGVuZCBwbGFuZS5cXG5cXFxuICAgIHZlYzMgbm9ybWFsRUMgPSBub3JtYWxpemUoY3Jvc3MocGxhbmVEaXJlY3Rpb24sIHVwT3JEb3duKSk7ICAgICAgICAgLy8gSW4gcHJhY3RpY2UsIHRoZSBvcHBvc2l0ZSBzZWVtcyB0byB3b3JrIHRvby5cXG5cXFxuXFxuXFxcbiAgICAvLyBOdWRnZSB0aGUgdG9wIHZlcnRleCB1cHdhcmRzIHRvIHByZXZlbnQgZmxpY2tlcmluZ1xcblxcXG4gICAgdmVjMyBnZW9kZXRpY1N1cmZhY2VOb3JtYWwgPSBub3JtYWxpemUoY3Jvc3Mobm9ybWFsRUMsIGZvcndhcmRFYzNEKSk7XFxuXFxcbiAgICBnZW9kZXRpY1N1cmZhY2VOb3JtYWwgKj0gZmxvYXQoMC4wIDw9IHJpZ2h0Tm9ybWFsQW5kVGV4dHVyZUNvb3JkaW5hdGVOb3JtYWxpemF0aW9uWS53ICYmIHJpZ2h0Tm9ybWFsQW5kVGV4dHVyZUNvb3JkaW5hdGVOb3JtYWxpemF0aW9uWS53IDw9IDEuMCk7XFxuXFxcbiAgICBnZW9kZXRpY1N1cmZhY2VOb3JtYWwgKj0gTUFYX1RFUlJBSU5fSEVJR0hUO1xcblxcXG4gICAgcG9zaXRpb25FYzNELnh5eiArPSBnZW9kZXRpY1N1cmZhY2VOb3JtYWw7XFxuXFxcblxcblxcXG4gICAgLy8gRGV0ZXJtaW5lIGlmIHRoaXMgdmVydGV4IGlzIG9uIHRoZSBcXFwibGVmdFxcXCIgb3IgXFxcInJpZ2h0XFxcIlxcblxcXG4gICAgbm9ybWFsRUMgKj0gc2lnbihlbmROb3JtYWxBbmRUZXh0dXJlQ29vcmRpbmF0ZU5vcm1hbGl6YXRpb25YLncpO1xcblxcXG5cXG5cXFxuICAgIC8vIEEgXFxcInBlcmZlY3RcXFwiIGltcGxlbWVudGF0aW9uIHdvdWxkIHB1c2ggYWxvbmcgbm9ybWFscyBhY2NvcmRpbmcgdG8gdGhlIGFuZ2xlIGFnYWluc3QgZm9yd2FyZC5cXG5cXFxuICAgIC8vIEluIHByYWN0aWNlLCBqdXN0IHB1c2hpbmcgdGhlIG5vcm1hbCBvdXQgYnkgaGFsZldpZHRoIGlzIHN1ZmZpY2llbnQgZm9yIG1vcnBoIHZpZXdzLlxcblxcXG4gICAgcG9zaXRpb25FYzNELnh5eiArPSBoYWxmV2lkdGggKiBtYXgoMC4wLCBjem1fbWV0ZXJzUGVyUGl4ZWwocG9zaXRpb25FYzNEKSkgKiBub3JtYWxFQzsgLy8gcHJldmVudCBhcnRpZmFjdHMgd2hlbiBjem1fbWV0ZXJzUGVyUGl4ZWwgaXMgbmVnYXRpdmUgKGJlaGluZCBjYW1lcmEpXFxuXFxcblxcblxcXG4gICAgLy8gKioqKioqIDJEICoqKioqKlxcblxcXG4gICAgLy8gQ2hlY2sgZGlzdGFuY2UgdG8gdGhlIGVuZCBwbGFuZSBhbmQgc3RhcnQgcGxhbmUsIHBpY2sgdGhlIHBsYW5lIHRoYXQgaXMgY2xvc2VyXFxuXFxcbiAgICB2ZWM0IHBvc2l0aW9uRWMyRCA9IGN6bV9tb2RlbFZpZXdSZWxhdGl2ZVRvRXllICogY3ptX3RyYW5zbGF0ZVJlbGF0aXZlVG9FeWUocG9zaXRpb24yREhpZ2guenh5LCBwb3NpdGlvbjJETG93Lnp4eSk7IC8vIHcgPSAxLjAsIHNlZSBjem1fY29tcHV0ZVBvc2l0aW9uXFxuXFxcbiAgICBhYnNTdGFydFBsYW5lRGlzdGFuY2UgPSBhYnMoY3ptX3BsYW5lRGlzdGFuY2Uoc3RhcnRQbGFuZTJELCBwb3NpdGlvbkVjMkQueHl6KSk7XFxuXFxcbiAgICBhYnNFbmRQbGFuZURpc3RhbmNlID0gYWJzKGN6bV9wbGFuZURpc3RhbmNlKGVuZFBsYW5lMkQsIHBvc2l0aW9uRWMyRC54eXopKTtcXG5cXFxuICAgIHBsYW5lRGlyZWN0aW9uID0gY3ptX2JyYW5jaEZyZWVUZXJuYXJ5KGFic1N0YXJ0UGxhbmVEaXN0YW5jZSA8IGFic0VuZFBsYW5lRGlzdGFuY2UsIHN0YXJ0UGxhbmUyRC54eXosIGVuZFBsYW5lMkQueHl6KTtcXG5cXFxuICAgIHVwT3JEb3duID0gbm9ybWFsaXplKGNyb3NzKHJpZ2h0UGxhbmUyRC54eXosIHBsYW5lRGlyZWN0aW9uKSk7IC8vIFBvaW50cyBcXFwidXBcXFwiIGZvciBzdGFydCBwbGFuZSwgXFxcImRvd25cXFwiIGF0IGVuZCBwbGFuZS5cXG5cXFxuICAgIG5vcm1hbEVDID0gbm9ybWFsaXplKGNyb3NzKHBsYW5lRGlyZWN0aW9uLCB1cE9yRG93bikpOyAgICAgICAgIC8vIEluIHByYWN0aWNlLCB0aGUgb3Bwb3NpdGUgc2VlbXMgdG8gd29yayB0b28uXFxuXFxcblxcblxcXG4gICAgLy8gTnVkZ2UgdGhlIHRvcCB2ZXJ0ZXggdXB3YXJkcyB0byBwcmV2ZW50IGZsaWNrZXJpbmdcXG5cXFxuICAgIGdlb2RldGljU3VyZmFjZU5vcm1hbCA9IG5vcm1hbGl6ZShjcm9zcyhub3JtYWxFQywgZm9yd2FyZEVjMkQpKTtcXG5cXFxuICAgIGdlb2RldGljU3VyZmFjZU5vcm1hbCAqPSBmbG9hdCgwLjAgPD0gdGV4Y29vcmROb3JtYWxpemF0aW9uMkQueSAmJiB0ZXhjb29yZE5vcm1hbGl6YXRpb24yRC55IDw9IDEuMCk7XFxuXFxcbiAgICBnZW9kZXRpY1N1cmZhY2VOb3JtYWwgKj0gTUFYX1RFUlJBSU5fSEVJR0hUO1xcblxcXG4gICAgcG9zaXRpb25FYzJELnh5eiArPSBnZW9kZXRpY1N1cmZhY2VOb3JtYWw7XFxuXFxcblxcblxcXG4gICAgLy8gRGV0ZXJtaW5lIGlmIHRoaXMgdmVydGV4IGlzIG9uIHRoZSBcXFwibGVmdFxcXCIgb3IgXFxcInJpZ2h0XFxcIlxcblxcXG4gICAgbm9ybWFsRUMgKj0gc2lnbih0ZXhjb29yZE5vcm1hbGl6YXRpb24yRC54KTtcXG5cXFxuI2lmbmRlZiBQRVJfSU5TVEFOQ0VfQ09MT1JcXG5cXFxuICAgIC8vIFVzZSB2ZXJ0ZXgncyBzaWRlZG5lc3MgdG8gY29tcHV0ZSBpdHMgdGV4dHVyZSBjb29yZGluYXRlLlxcblxcXG4gICAgdl90ZXhjb29yZFQgPSBjbGFtcChzaWduKHRleGNvb3JkTm9ybWFsaXphdGlvbjJELngpLCAwLjAsIDEuMCk7XFxuXFxcbiNlbmRpZlxcblxcXG5cXG5cXFxuICAgIC8vIEEgXFxcInBlcmZlY3RcXFwiIGltcGxlbWVudGF0aW9uIHdvdWxkIHB1c2ggYWxvbmcgbm9ybWFscyBhY2NvcmRpbmcgdG8gdGhlIGFuZ2xlIGFnYWluc3QgZm9yd2FyZC5cXG5cXFxuICAgIC8vIEluIHByYWN0aWNlLCBqdXN0IHB1c2hpbmcgdGhlIG5vcm1hbCBvdXQgYnkgaGFsZldpZHRoIGlzIHN1ZmZpY2llbnQgZm9yIG1vcnBoIHZpZXdzLlxcblxcXG4gICAgcG9zaXRpb25FYzJELnh5eiArPSBoYWxmV2lkdGggKiBtYXgoMC4wLCBjem1fbWV0ZXJzUGVyUGl4ZWwocG9zaXRpb25FYzJEKSkgKiBub3JtYWxFQzsgLy8gcHJldmVudCBhcnRpZmFjdHMgd2hlbiBjem1fbWV0ZXJzUGVyUGl4ZWwgaXMgbmVnYXRpdmUgKGJlaGluZCBjYW1lcmEpXFxuXFxcblxcblxcXG4gICAgLy8gQmxlbmQgZm9yIGFjdHVhbCBwb3NpdGlvblxcblxcXG4gICAgZ2xfUG9zaXRpb24gPSBjem1fcHJvamVjdGlvbiAqIG1peChwb3NpdGlvbkVjMkQsIHBvc2l0aW9uRWMzRCwgY3ptX21vcnBoVGltZSk7XFxuXFxcblxcblxcXG4jaWZkZWYgQU5HTEVfVkFSWUlOR1xcblxcXG4gICAgLy8gQXBwcm94aW1hdGUgcmVsYXRpdmUgc2NyZWVuIHNwYWNlIGRpcmVjdGlvbiBvZiB0aGUgbGluZS5cXG5cXFxuICAgIHZlYzIgYXBwcm94TGluZURpcmVjdGlvbiA9IG5vcm1hbGl6ZSh2ZWMyKHZfZm9yd2FyZERpcmVjdGlvbkVDLngsIC12X2ZvcndhcmREaXJlY3Rpb25FQy55KSk7XFxuXFxcbiAgICBhcHByb3hMaW5lRGlyZWN0aW9uLnkgPSBjem1fYnJhbmNoRnJlZVRlcm5hcnkoYXBwcm94TGluZURpcmVjdGlvbi54ID09IDAuMCAmJiBhcHByb3hMaW5lRGlyZWN0aW9uLnkgPT0gMC4wLCAtMS4wLCBhcHByb3hMaW5lRGlyZWN0aW9uLnkpO1xcblxcXG4gICAgdl9wb2x5bGluZUFuZ2xlID0gY3ptX2Zhc3RBcHByb3hpbWF0ZUF0YW4oYXBwcm94TGluZURpcmVjdGlvbi54LCBhcHByb3hMaW5lRGlyZWN0aW9uLnkpO1xcblxcXG4jZW5kaWZcXG5cXFxufVxcblxcXG5cIjtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///38632\n')},73248:function(__unused_webpack___webpack_module__,__webpack_exports__){eval('//This file is automatically rebuilt by the Cesium build process.\n/* harmony default export */ __webpack_exports__["Z"] = ("attribute vec3 position3DHigh;\\n\\\nattribute vec3 position3DLow;\\n\\\n\\n\\\n// In 2D and in 3D, texture coordinate normalization component signs encodes:\\n\\\n// * X sign - sidedness relative to right plane\\n\\\n// * Y sign - is negative OR magnitude is greater than 1.0 if vertex is on bottom of volume\\n\\\n#ifndef COLUMBUS_VIEW_2D\\n\\\nattribute vec4 startHiAndForwardOffsetX;\\n\\\nattribute vec4 startLoAndForwardOffsetY;\\n\\\nattribute vec4 startNormalAndForwardOffsetZ;\\n\\\nattribute vec4 endNormalAndTextureCoordinateNormalizationX;\\n\\\nattribute vec4 rightNormalAndTextureCoordinateNormalizationY;\\n\\\n#else\\n\\\nattribute vec4 startHiLo2D;\\n\\\nattribute vec4 offsetAndRight2D;\\n\\\nattribute vec4 startEndNormals2D;\\n\\\nattribute vec2 texcoordNormalization2D;\\n\\\n#endif\\n\\\n\\n\\\nattribute float batchId;\\n\\\n\\n\\\nvarying vec4 v_startPlaneNormalEcAndHalfWidth;\\n\\\nvarying vec4 v_endPlaneNormalEcAndBatchId;\\n\\\nvarying vec4 v_rightPlaneEC;\\n\\\nvarying vec4 v_endEcAndStartEcX;\\n\\\nvarying vec4 v_texcoordNormalizationAndStartEcYZ;\\n\\\n\\n\\\n// For materials\\n\\\n#ifdef WIDTH_VARYING\\n\\\nvarying float v_width;\\n\\\n#endif\\n\\\n#ifdef ANGLE_VARYING\\n\\\nvarying float v_polylineAngle;\\n\\\n#endif\\n\\\n\\n\\\n#ifdef PER_INSTANCE_COLOR\\n\\\nvarying vec4 v_color;\\n\\\n#endif\\n\\\n\\n\\\nvoid main()\\n\\\n{\\n\\\n#ifdef COLUMBUS_VIEW_2D\\n\\\n    vec3 ecStart = (czm_modelViewRelativeToEye * czm_translateRelativeToEye(vec3(0.0, startHiLo2D.xy), vec3(0.0, startHiLo2D.zw))).xyz;\\n\\\n\\n\\\n    vec3 forwardDirectionEC = czm_normal * vec3(0.0, offsetAndRight2D.xy);\\n\\\n    vec3 ecEnd = forwardDirectionEC + ecStart;\\n\\\n    forwardDirectionEC = normalize(forwardDirectionEC);\\n\\\n\\n\\\n    // Right plane\\n\\\n    v_rightPlaneEC.xyz = czm_normal * vec3(0.0, offsetAndRight2D.zw);\\n\\\n    v_rightPlaneEC.w = -dot(v_rightPlaneEC.xyz, ecStart);\\n\\\n\\n\\\n    // start plane\\n\\\n    vec4 startPlaneEC;\\n\\\n    startPlaneEC.xyz =  czm_normal * vec3(0.0, startEndNormals2D.xy);\\n\\\n    startPlaneEC.w = -dot(startPlaneEC.xyz, ecStart);\\n\\\n\\n\\\n    // end plane\\n\\\n    vec4 endPlaneEC;\\n\\\n    endPlaneEC.xyz =  czm_normal * vec3(0.0, startEndNormals2D.zw);\\n\\\n    endPlaneEC.w = -dot(endPlaneEC.xyz, ecEnd);\\n\\\n\\n\\\n    v_texcoordNormalizationAndStartEcYZ.x = abs(texcoordNormalization2D.x);\\n\\\n    v_texcoordNormalizationAndStartEcYZ.y = texcoordNormalization2D.y;\\n\\\n\\n\\\n#else // COLUMBUS_VIEW_2D\\n\\\n    vec3 ecStart = (czm_modelViewRelativeToEye * czm_translateRelativeToEye(startHiAndForwardOffsetX.xyz, startLoAndForwardOffsetY.xyz)).xyz;\\n\\\n    vec3 offset = czm_normal * vec3(startHiAndForwardOffsetX.w, startLoAndForwardOffsetY.w, startNormalAndForwardOffsetZ.w);\\n\\\n    vec3 ecEnd = ecStart + offset;\\n\\\n\\n\\\n    vec3 forwardDirectionEC = normalize(offset);\\n\\\n\\n\\\n    // start plane\\n\\\n    vec4 startPlaneEC;\\n\\\n    startPlaneEC.xyz = czm_normal * startNormalAndForwardOffsetZ.xyz;\\n\\\n    startPlaneEC.w = -dot(startPlaneEC.xyz, ecStart);\\n\\\n\\n\\\n    // end plane\\n\\\n    vec4 endPlaneEC;\\n\\\n    endPlaneEC.xyz = czm_normal * endNormalAndTextureCoordinateNormalizationX.xyz;\\n\\\n    endPlaneEC.w = -dot(endPlaneEC.xyz, ecEnd);\\n\\\n\\n\\\n    // Right plane\\n\\\n    v_rightPlaneEC.xyz = czm_normal * rightNormalAndTextureCoordinateNormalizationY.xyz;\\n\\\n    v_rightPlaneEC.w = -dot(v_rightPlaneEC.xyz, ecStart);\\n\\\n\\n\\\n    v_texcoordNormalizationAndStartEcYZ.x = abs(endNormalAndTextureCoordinateNormalizationX.w);\\n\\\n    v_texcoordNormalizationAndStartEcYZ.y = rightNormalAndTextureCoordinateNormalizationY.w;\\n\\\n\\n\\\n#endif // COLUMBUS_VIEW_2D\\n\\\n\\n\\\n    v_endEcAndStartEcX.xyz = ecEnd;\\n\\\n    v_endEcAndStartEcX.w = ecStart.x;\\n\\\n    v_texcoordNormalizationAndStartEcYZ.zw = ecStart.yz;\\n\\\n\\n\\\n#ifdef PER_INSTANCE_COLOR\\n\\\n    v_color = czm_batchTable_color(batchId);\\n\\\n#endif // PER_INSTANCE_COLOR\\n\\\n\\n\\\n    // Compute a normal along which to \\"push\\" the position out, extending the miter depending on view distance.\\n\\\n    // Position has already been \\"pushed\\" by unit length along miter normal, and miter normals are encoded in the planes.\\n\\\n    // Decode the normal to use at this specific vertex, push the position back, and then push to where it needs to be.\\n\\\n    vec4 positionRelativeToEye = czm_computePosition();\\n\\\n\\n\\\n    // Check distance to the end plane and start plane, pick the plane that is closer\\n\\\n    vec4 positionEC = czm_modelViewRelativeToEye * positionRelativeToEye; // w = 1.0, see czm_computePosition\\n\\\n    float absStartPlaneDistance = abs(czm_planeDistance(startPlaneEC, positionEC.xyz));\\n\\\n    float absEndPlaneDistance = abs(czm_planeDistance(endPlaneEC, positionEC.xyz));\\n\\\n    vec3 planeDirection = czm_branchFreeTernary(absStartPlaneDistance < absEndPlaneDistance, startPlaneEC.xyz, endPlaneEC.xyz);\\n\\\n    vec3 upOrDown = normalize(cross(v_rightPlaneEC.xyz, planeDirection)); // Points \\"up\\" for start plane, \\"down\\" at end plane.\\n\\\n    vec3 normalEC = normalize(cross(planeDirection, upOrDown));           // In practice, the opposite seems to work too.\\n\\\n\\n\\\n    // Extrude bottom vertices downward for far view distances, like for GroundPrimitives\\n\\\n    upOrDown = cross(forwardDirectionEC, normalEC);\\n\\\n    upOrDown = float(czm_sceneMode == czm_sceneMode3D) * upOrDown;\\n\\\n    upOrDown = float(v_texcoordNormalizationAndStartEcYZ.y > 1.0 || v_texcoordNormalizationAndStartEcYZ.y < 0.0) * upOrDown;\\n\\\n    upOrDown = min(GLOBE_MINIMUM_ALTITUDE, czm_geometricToleranceOverMeter * length(positionRelativeToEye.xyz)) * upOrDown;\\n\\\n    positionEC.xyz += upOrDown;\\n\\\n\\n\\\n    v_texcoordNormalizationAndStartEcYZ.y = czm_branchFreeTernary(v_texcoordNormalizationAndStartEcYZ.y > 1.0, 0.0, abs(v_texcoordNormalizationAndStartEcYZ.y));\\n\\\n\\n\\\n    // Determine distance along normalEC to push for a volume of appropriate width.\\n\\\n    // Make volumes about double pixel width for a conservative fit - in practice the\\n\\\n    // extra cost here is minimal compared to the loose volume heights.\\n\\\n    //\\n\\\n    // N = normalEC (guaranteed \\"right-facing\\")\\n\\\n    // R = rightEC\\n\\\n    // p = angle between N and R\\n\\\n    // w = distance to push along R if R == N\\n\\\n    // d = distance to push along N\\n\\\n    //\\n\\\n    //   N   R\\n\\\n    //  { \\ p| }      * cos(p) = dot(N, R) = w / d\\n\\\n    //  d\\ \\ |  |w    * d = w / dot(N, R)\\n\\\n    //    { \\| }\\n\\\n    //       o---------- polyline segment ----\x3e\\n\\\n    //\\n\\\n    float width = czm_batchTable_width(batchId);\\n\\\n#ifdef WIDTH_VARYING\\n\\\n    v_width = width;\\n\\\n#endif\\n\\\n\\n\\\n    v_startPlaneNormalEcAndHalfWidth.xyz = startPlaneEC.xyz;\\n\\\n    v_startPlaneNormalEcAndHalfWidth.w = width * 0.5;\\n\\\n\\n\\\n    v_endPlaneNormalEcAndBatchId.xyz = endPlaneEC.xyz;\\n\\\n    v_endPlaneNormalEcAndBatchId.w = batchId;\\n\\\n\\n\\\n    width = width * max(0.0, czm_metersPerPixel(positionEC)); // width = distance to push along R\\n\\\n    width = width / dot(normalEC, v_rightPlaneEC.xyz); // width = distance to push along N\\n\\\n\\n\\\n    // Determine if this vertex is on the \\"left\\" or \\"right\\"\\n\\\n#ifdef COLUMBUS_VIEW_2D\\n\\\n        normalEC *= sign(texcoordNormalization2D.x);\\n\\\n#else\\n\\\n        normalEC *= sign(endNormalAndTextureCoordinateNormalizationX.w);\\n\\\n#endif\\n\\\n\\n\\\n    positionEC.xyz += width * normalEC;\\n\\\n    gl_Position = czm_depthClamp(czm_projection * positionEC);\\n\\\n\\n\\\n#ifdef ANGLE_VARYING\\n\\\n    // Approximate relative screen space direction of the line.\\n\\\n    vec2 approxLineDirection = normalize(vec2(forwardDirectionEC.x, -forwardDirectionEC.y));\\n\\\n    approxLineDirection.y = czm_branchFreeTernary(approxLineDirection.x == 0.0 && approxLineDirection.y == 0.0, -1.0, approxLineDirection.y);\\n\\\n    v_polylineAngle = czm_fastApproximateAtan(approxLineDirection.x, approxLineDirection.y);\\n\\\n#endif\\n\\\n}\\n\\\n");\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNzMyNDguanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQSx5REFBZSwrQkFBK0I7QUFDOUMsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0M7QUFDeEMsd0NBQXdDO0FBQ3hDLDRDQUE0QztBQUM1QywyREFBMkQ7QUFDM0QsNkRBQTZEO0FBQzdEO0FBQ0EsMkJBQTJCO0FBQzNCLGdDQUFnQztBQUNoQyxpQ0FBaUM7QUFDakMsdUNBQXVDO0FBQ3ZDO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQSw4Q0FBOEM7QUFDOUMsMENBQTBDO0FBQzFDLDRCQUE0QjtBQUM1QixnQ0FBZ0M7QUFDaEMsaURBQWlEO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQSx1SUFBdUk7QUFDdkk7QUFDQSwwRUFBMEU7QUFDMUUsOENBQThDO0FBQzlDLHVEQUF1RDtBQUN2RDtBQUNBO0FBQ0EscUVBQXFFO0FBQ3JFLHlEQUF5RDtBQUN6RDtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCLHFFQUFxRTtBQUNyRSxxREFBcUQ7QUFDckQ7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQixtRUFBbUU7QUFDbkUsK0NBQStDO0FBQy9DO0FBQ0EsMkVBQTJFO0FBQzNFLHNFQUFzRTtBQUN0RTtBQUNBO0FBQ0EsNklBQTZJO0FBQzdJLDRIQUE0SDtBQUM1SCxrQ0FBa0M7QUFDbEM7QUFDQSxnREFBZ0Q7QUFDaEQ7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QixxRUFBcUU7QUFDckUscURBQXFEO0FBQ3JEO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEIsa0ZBQWtGO0FBQ2xGLCtDQUErQztBQUMvQztBQUNBO0FBQ0Esd0ZBQXdGO0FBQ3hGLHlEQUF5RDtBQUN6RDtBQUNBLCtGQUErRjtBQUMvRiw0RkFBNEY7QUFDNUY7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DO0FBQ25DLHFDQUFxQztBQUNyQyx3REFBd0Q7QUFDeEQ7QUFDQTtBQUNBLDRDQUE0QztBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdURBQXVEO0FBQ3ZEO0FBQ0E7QUFDQSwwRUFBMEU7QUFDMUUsdUZBQXVGO0FBQ3ZGLG1GQUFtRjtBQUNuRiwrSEFBK0g7QUFDL0gsMEVBQTBFO0FBQzFFLDBFQUEwRTtBQUMxRTtBQUNBO0FBQ0EsbURBQW1EO0FBQ25ELGtFQUFrRTtBQUNsRSw0SEFBNEg7QUFDNUgsMkhBQTJIO0FBQzNILCtCQUErQjtBQUMvQjtBQUNBLGdLQUFnSztBQUNoSztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLFlBQVk7QUFDdEI7QUFDQSxZQUFZLElBQUk7QUFDaEI7QUFDQTtBQUNBLGdEQUFnRDtBQUNoRDtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0EsNERBQTREO0FBQzVELHFEQUFxRDtBQUNyRDtBQUNBLHNEQUFzRDtBQUN0RCw2Q0FBNkM7QUFDN0M7QUFDQSw4REFBOEQ7QUFDOUQsdURBQXVEO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRDtBQUNwRDtBQUNBLHdFQUF3RTtBQUN4RTtBQUNBO0FBQ0EsdUNBQXVDO0FBQ3ZDLDhEQUE4RDtBQUM5RDtBQUNBO0FBQ0E7QUFDQSw0RkFBNEY7QUFDNUYsNklBQTZJO0FBQzdJLDRGQUE0RjtBQUM1RjtBQUNBLENBQUM7QUFDRCxDQUFDLEVBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly92dWUzLXdlYnBhY2s1Ly4vbm9kZV9tb2R1bGVzL2Nlc2l1bS9Tb3VyY2UvU2hhZGVycy9Qb2x5bGluZVNoYWRvd1ZvbHVtZVZTLmpzP2EzZGQiXSwic291cmNlc0NvbnRlbnQiOlsiLy9UaGlzIGZpbGUgaXMgYXV0b21hdGljYWxseSByZWJ1aWx0IGJ5IHRoZSBDZXNpdW0gYnVpbGQgcHJvY2Vzcy5cbmV4cG9ydCBkZWZhdWx0IFwiYXR0cmlidXRlIHZlYzMgcG9zaXRpb24zREhpZ2g7XFxuXFxcbmF0dHJpYnV0ZSB2ZWMzIHBvc2l0aW9uM0RMb3c7XFxuXFxcblxcblxcXG4vLyBJbiAyRCBhbmQgaW4gM0QsIHRleHR1cmUgY29vcmRpbmF0ZSBub3JtYWxpemF0aW9uIGNvbXBvbmVudCBzaWducyBlbmNvZGVzOlxcblxcXG4vLyAqIFggc2lnbiAtIHNpZGVkbmVzcyByZWxhdGl2ZSB0byByaWdodCBwbGFuZVxcblxcXG4vLyAqIFkgc2lnbiAtIGlzIG5lZ2F0aXZlIE9SIG1hZ25pdHVkZSBpcyBncmVhdGVyIHRoYW4gMS4wIGlmIHZlcnRleCBpcyBvbiBib3R0b20gb2Ygdm9sdW1lXFxuXFxcbiNpZm5kZWYgQ09MVU1CVVNfVklFV18yRFxcblxcXG5hdHRyaWJ1dGUgdmVjNCBzdGFydEhpQW5kRm9yd2FyZE9mZnNldFg7XFxuXFxcbmF0dHJpYnV0ZSB2ZWM0IHN0YXJ0TG9BbmRGb3J3YXJkT2Zmc2V0WTtcXG5cXFxuYXR0cmlidXRlIHZlYzQgc3RhcnROb3JtYWxBbmRGb3J3YXJkT2Zmc2V0WjtcXG5cXFxuYXR0cmlidXRlIHZlYzQgZW5kTm9ybWFsQW5kVGV4dHVyZUNvb3JkaW5hdGVOb3JtYWxpemF0aW9uWDtcXG5cXFxuYXR0cmlidXRlIHZlYzQgcmlnaHROb3JtYWxBbmRUZXh0dXJlQ29vcmRpbmF0ZU5vcm1hbGl6YXRpb25ZO1xcblxcXG4jZWxzZVxcblxcXG5hdHRyaWJ1dGUgdmVjNCBzdGFydEhpTG8yRDtcXG5cXFxuYXR0cmlidXRlIHZlYzQgb2Zmc2V0QW5kUmlnaHQyRDtcXG5cXFxuYXR0cmlidXRlIHZlYzQgc3RhcnRFbmROb3JtYWxzMkQ7XFxuXFxcbmF0dHJpYnV0ZSB2ZWMyIHRleGNvb3JkTm9ybWFsaXphdGlvbjJEO1xcblxcXG4jZW5kaWZcXG5cXFxuXFxuXFxcbmF0dHJpYnV0ZSBmbG9hdCBiYXRjaElkO1xcblxcXG5cXG5cXFxudmFyeWluZyB2ZWM0IHZfc3RhcnRQbGFuZU5vcm1hbEVjQW5kSGFsZldpZHRoO1xcblxcXG52YXJ5aW5nIHZlYzQgdl9lbmRQbGFuZU5vcm1hbEVjQW5kQmF0Y2hJZDtcXG5cXFxudmFyeWluZyB2ZWM0IHZfcmlnaHRQbGFuZUVDO1xcblxcXG52YXJ5aW5nIHZlYzQgdl9lbmRFY0FuZFN0YXJ0RWNYO1xcblxcXG52YXJ5aW5nIHZlYzQgdl90ZXhjb29yZE5vcm1hbGl6YXRpb25BbmRTdGFydEVjWVo7XFxuXFxcblxcblxcXG4vLyBGb3IgbWF0ZXJpYWxzXFxuXFxcbiNpZmRlZiBXSURUSF9WQVJZSU5HXFxuXFxcbnZhcnlpbmcgZmxvYXQgdl93aWR0aDtcXG5cXFxuI2VuZGlmXFxuXFxcbiNpZmRlZiBBTkdMRV9WQVJZSU5HXFxuXFxcbnZhcnlpbmcgZmxvYXQgdl9wb2x5bGluZUFuZ2xlO1xcblxcXG4jZW5kaWZcXG5cXFxuXFxuXFxcbiNpZmRlZiBQRVJfSU5TVEFOQ0VfQ09MT1JcXG5cXFxudmFyeWluZyB2ZWM0IHZfY29sb3I7XFxuXFxcbiNlbmRpZlxcblxcXG5cXG5cXFxudm9pZCBtYWluKClcXG5cXFxue1xcblxcXG4jaWZkZWYgQ09MVU1CVVNfVklFV18yRFxcblxcXG4gICAgdmVjMyBlY1N0YXJ0ID0gKGN6bV9tb2RlbFZpZXdSZWxhdGl2ZVRvRXllICogY3ptX3RyYW5zbGF0ZVJlbGF0aXZlVG9FeWUodmVjMygwLjAsIHN0YXJ0SGlMbzJELnh5KSwgdmVjMygwLjAsIHN0YXJ0SGlMbzJELnp3KSkpLnh5ejtcXG5cXFxuXFxuXFxcbiAgICB2ZWMzIGZvcndhcmREaXJlY3Rpb25FQyA9IGN6bV9ub3JtYWwgKiB2ZWMzKDAuMCwgb2Zmc2V0QW5kUmlnaHQyRC54eSk7XFxuXFxcbiAgICB2ZWMzIGVjRW5kID0gZm9yd2FyZERpcmVjdGlvbkVDICsgZWNTdGFydDtcXG5cXFxuICAgIGZvcndhcmREaXJlY3Rpb25FQyA9IG5vcm1hbGl6ZShmb3J3YXJkRGlyZWN0aW9uRUMpO1xcblxcXG5cXG5cXFxuICAgIC8vIFJpZ2h0IHBsYW5lXFxuXFxcbiAgICB2X3JpZ2h0UGxhbmVFQy54eXogPSBjem1fbm9ybWFsICogdmVjMygwLjAsIG9mZnNldEFuZFJpZ2h0MkQuencpO1xcblxcXG4gICAgdl9yaWdodFBsYW5lRUMudyA9IC1kb3Qodl9yaWdodFBsYW5lRUMueHl6LCBlY1N0YXJ0KTtcXG5cXFxuXFxuXFxcbiAgICAvLyBzdGFydCBwbGFuZVxcblxcXG4gICAgdmVjNCBzdGFydFBsYW5lRUM7XFxuXFxcbiAgICBzdGFydFBsYW5lRUMueHl6ID0gIGN6bV9ub3JtYWwgKiB2ZWMzKDAuMCwgc3RhcnRFbmROb3JtYWxzMkQueHkpO1xcblxcXG4gICAgc3RhcnRQbGFuZUVDLncgPSAtZG90KHN0YXJ0UGxhbmVFQy54eXosIGVjU3RhcnQpO1xcblxcXG5cXG5cXFxuICAgIC8vIGVuZCBwbGFuZVxcblxcXG4gICAgdmVjNCBlbmRQbGFuZUVDO1xcblxcXG4gICAgZW5kUGxhbmVFQy54eXogPSAgY3ptX25vcm1hbCAqIHZlYzMoMC4wLCBzdGFydEVuZE5vcm1hbHMyRC56dyk7XFxuXFxcbiAgICBlbmRQbGFuZUVDLncgPSAtZG90KGVuZFBsYW5lRUMueHl6LCBlY0VuZCk7XFxuXFxcblxcblxcXG4gICAgdl90ZXhjb29yZE5vcm1hbGl6YXRpb25BbmRTdGFydEVjWVoueCA9IGFicyh0ZXhjb29yZE5vcm1hbGl6YXRpb24yRC54KTtcXG5cXFxuICAgIHZfdGV4Y29vcmROb3JtYWxpemF0aW9uQW5kU3RhcnRFY1laLnkgPSB0ZXhjb29yZE5vcm1hbGl6YXRpb24yRC55O1xcblxcXG5cXG5cXFxuI2Vsc2UgLy8gQ09MVU1CVVNfVklFV18yRFxcblxcXG4gICAgdmVjMyBlY1N0YXJ0ID0gKGN6bV9tb2RlbFZpZXdSZWxhdGl2ZVRvRXllICogY3ptX3RyYW5zbGF0ZVJlbGF0aXZlVG9FeWUoc3RhcnRIaUFuZEZvcndhcmRPZmZzZXRYLnh5eiwgc3RhcnRMb0FuZEZvcndhcmRPZmZzZXRZLnh5eikpLnh5ejtcXG5cXFxuICAgIHZlYzMgb2Zmc2V0ID0gY3ptX25vcm1hbCAqIHZlYzMoc3RhcnRIaUFuZEZvcndhcmRPZmZzZXRYLncsIHN0YXJ0TG9BbmRGb3J3YXJkT2Zmc2V0WS53LCBzdGFydE5vcm1hbEFuZEZvcndhcmRPZmZzZXRaLncpO1xcblxcXG4gICAgdmVjMyBlY0VuZCA9IGVjU3RhcnQgKyBvZmZzZXQ7XFxuXFxcblxcblxcXG4gICAgdmVjMyBmb3J3YXJkRGlyZWN0aW9uRUMgPSBub3JtYWxpemUob2Zmc2V0KTtcXG5cXFxuXFxuXFxcbiAgICAvLyBzdGFydCBwbGFuZVxcblxcXG4gICAgdmVjNCBzdGFydFBsYW5lRUM7XFxuXFxcbiAgICBzdGFydFBsYW5lRUMueHl6ID0gY3ptX25vcm1hbCAqIHN0YXJ0Tm9ybWFsQW5kRm9yd2FyZE9mZnNldFoueHl6O1xcblxcXG4gICAgc3RhcnRQbGFuZUVDLncgPSAtZG90KHN0YXJ0UGxhbmVFQy54eXosIGVjU3RhcnQpO1xcblxcXG5cXG5cXFxuICAgIC8vIGVuZCBwbGFuZVxcblxcXG4gICAgdmVjNCBlbmRQbGFuZUVDO1xcblxcXG4gICAgZW5kUGxhbmVFQy54eXogPSBjem1fbm9ybWFsICogZW5kTm9ybWFsQW5kVGV4dHVyZUNvb3JkaW5hdGVOb3JtYWxpemF0aW9uWC54eXo7XFxuXFxcbiAgICBlbmRQbGFuZUVDLncgPSAtZG90KGVuZFBsYW5lRUMueHl6LCBlY0VuZCk7XFxuXFxcblxcblxcXG4gICAgLy8gUmlnaHQgcGxhbmVcXG5cXFxuICAgIHZfcmlnaHRQbGFuZUVDLnh5eiA9IGN6bV9ub3JtYWwgKiByaWdodE5vcm1hbEFuZFRleHR1cmVDb29yZGluYXRlTm9ybWFsaXphdGlvblkueHl6O1xcblxcXG4gICAgdl9yaWdodFBsYW5lRUMudyA9IC1kb3Qodl9yaWdodFBsYW5lRUMueHl6LCBlY1N0YXJ0KTtcXG5cXFxuXFxuXFxcbiAgICB2X3RleGNvb3JkTm9ybWFsaXphdGlvbkFuZFN0YXJ0RWNZWi54ID0gYWJzKGVuZE5vcm1hbEFuZFRleHR1cmVDb29yZGluYXRlTm9ybWFsaXphdGlvblgudyk7XFxuXFxcbiAgICB2X3RleGNvb3JkTm9ybWFsaXphdGlvbkFuZFN0YXJ0RWNZWi55ID0gcmlnaHROb3JtYWxBbmRUZXh0dXJlQ29vcmRpbmF0ZU5vcm1hbGl6YXRpb25ZLnc7XFxuXFxcblxcblxcXG4jZW5kaWYgLy8gQ09MVU1CVVNfVklFV18yRFxcblxcXG5cXG5cXFxuICAgIHZfZW5kRWNBbmRTdGFydEVjWC54eXogPSBlY0VuZDtcXG5cXFxuICAgIHZfZW5kRWNBbmRTdGFydEVjWC53ID0gZWNTdGFydC54O1xcblxcXG4gICAgdl90ZXhjb29yZE5vcm1hbGl6YXRpb25BbmRTdGFydEVjWVouencgPSBlY1N0YXJ0Lnl6O1xcblxcXG5cXG5cXFxuI2lmZGVmIFBFUl9JTlNUQU5DRV9DT0xPUlxcblxcXG4gICAgdl9jb2xvciA9IGN6bV9iYXRjaFRhYmxlX2NvbG9yKGJhdGNoSWQpO1xcblxcXG4jZW5kaWYgLy8gUEVSX0lOU1RBTkNFX0NPTE9SXFxuXFxcblxcblxcXG4gICAgLy8gQ29tcHV0ZSBhIG5vcm1hbCBhbG9uZyB3aGljaCB0byBcXFwicHVzaFxcXCIgdGhlIHBvc2l0aW9uIG91dCwgZXh0ZW5kaW5nIHRoZSBtaXRlciBkZXBlbmRpbmcgb24gdmlldyBkaXN0YW5jZS5cXG5cXFxuICAgIC8vIFBvc2l0aW9uIGhhcyBhbHJlYWR5IGJlZW4gXFxcInB1c2hlZFxcXCIgYnkgdW5pdCBsZW5ndGggYWxvbmcgbWl0ZXIgbm9ybWFsLCBhbmQgbWl0ZXIgbm9ybWFscyBhcmUgZW5jb2RlZCBpbiB0aGUgcGxhbmVzLlxcblxcXG4gICAgLy8gRGVjb2RlIHRoZSBub3JtYWwgdG8gdXNlIGF0IHRoaXMgc3BlY2lmaWMgdmVydGV4LCBwdXNoIHRoZSBwb3NpdGlvbiBiYWNrLCBhbmQgdGhlbiBwdXNoIHRvIHdoZXJlIGl0IG5lZWRzIHRvIGJlLlxcblxcXG4gICAgdmVjNCBwb3NpdGlvblJlbGF0aXZlVG9FeWUgPSBjem1fY29tcHV0ZVBvc2l0aW9uKCk7XFxuXFxcblxcblxcXG4gICAgLy8gQ2hlY2sgZGlzdGFuY2UgdG8gdGhlIGVuZCBwbGFuZSBhbmQgc3RhcnQgcGxhbmUsIHBpY2sgdGhlIHBsYW5lIHRoYXQgaXMgY2xvc2VyXFxuXFxcbiAgICB2ZWM0IHBvc2l0aW9uRUMgPSBjem1fbW9kZWxWaWV3UmVsYXRpdmVUb0V5ZSAqIHBvc2l0aW9uUmVsYXRpdmVUb0V5ZTsgLy8gdyA9IDEuMCwgc2VlIGN6bV9jb21wdXRlUG9zaXRpb25cXG5cXFxuICAgIGZsb2F0IGFic1N0YXJ0UGxhbmVEaXN0YW5jZSA9IGFicyhjem1fcGxhbmVEaXN0YW5jZShzdGFydFBsYW5lRUMsIHBvc2l0aW9uRUMueHl6KSk7XFxuXFxcbiAgICBmbG9hdCBhYnNFbmRQbGFuZURpc3RhbmNlID0gYWJzKGN6bV9wbGFuZURpc3RhbmNlKGVuZFBsYW5lRUMsIHBvc2l0aW9uRUMueHl6KSk7XFxuXFxcbiAgICB2ZWMzIHBsYW5lRGlyZWN0aW9uID0gY3ptX2JyYW5jaEZyZWVUZXJuYXJ5KGFic1N0YXJ0UGxhbmVEaXN0YW5jZSA8IGFic0VuZFBsYW5lRGlzdGFuY2UsIHN0YXJ0UGxhbmVFQy54eXosIGVuZFBsYW5lRUMueHl6KTtcXG5cXFxuICAgIHZlYzMgdXBPckRvd24gPSBub3JtYWxpemUoY3Jvc3Modl9yaWdodFBsYW5lRUMueHl6LCBwbGFuZURpcmVjdGlvbikpOyAvLyBQb2ludHMgXFxcInVwXFxcIiBmb3Igc3RhcnQgcGxhbmUsIFxcXCJkb3duXFxcIiBhdCBlbmQgcGxhbmUuXFxuXFxcbiAgICB2ZWMzIG5vcm1hbEVDID0gbm9ybWFsaXplKGNyb3NzKHBsYW5lRGlyZWN0aW9uLCB1cE9yRG93bikpOyAgICAgICAgICAgLy8gSW4gcHJhY3RpY2UsIHRoZSBvcHBvc2l0ZSBzZWVtcyB0byB3b3JrIHRvby5cXG5cXFxuXFxuXFxcbiAgICAvLyBFeHRydWRlIGJvdHRvbSB2ZXJ0aWNlcyBkb3dud2FyZCBmb3IgZmFyIHZpZXcgZGlzdGFuY2VzLCBsaWtlIGZvciBHcm91bmRQcmltaXRpdmVzXFxuXFxcbiAgICB1cE9yRG93biA9IGNyb3NzKGZvcndhcmREaXJlY3Rpb25FQywgbm9ybWFsRUMpO1xcblxcXG4gICAgdXBPckRvd24gPSBmbG9hdChjem1fc2NlbmVNb2RlID09IGN6bV9zY2VuZU1vZGUzRCkgKiB1cE9yRG93bjtcXG5cXFxuICAgIHVwT3JEb3duID0gZmxvYXQodl90ZXhjb29yZE5vcm1hbGl6YXRpb25BbmRTdGFydEVjWVoueSA+IDEuMCB8fCB2X3RleGNvb3JkTm9ybWFsaXphdGlvbkFuZFN0YXJ0RWNZWi55IDwgMC4wKSAqIHVwT3JEb3duO1xcblxcXG4gICAgdXBPckRvd24gPSBtaW4oR0xPQkVfTUlOSU1VTV9BTFRJVFVERSwgY3ptX2dlb21ldHJpY1RvbGVyYW5jZU92ZXJNZXRlciAqIGxlbmd0aChwb3NpdGlvblJlbGF0aXZlVG9FeWUueHl6KSkgKiB1cE9yRG93bjtcXG5cXFxuICAgIHBvc2l0aW9uRUMueHl6ICs9IHVwT3JEb3duO1xcblxcXG5cXG5cXFxuICAgIHZfdGV4Y29vcmROb3JtYWxpemF0aW9uQW5kU3RhcnRFY1laLnkgPSBjem1fYnJhbmNoRnJlZVRlcm5hcnkodl90ZXhjb29yZE5vcm1hbGl6YXRpb25BbmRTdGFydEVjWVoueSA+IDEuMCwgMC4wLCBhYnModl90ZXhjb29yZE5vcm1hbGl6YXRpb25BbmRTdGFydEVjWVoueSkpO1xcblxcXG5cXG5cXFxuICAgIC8vIERldGVybWluZSBkaXN0YW5jZSBhbG9uZyBub3JtYWxFQyB0byBwdXNoIGZvciBhIHZvbHVtZSBvZiBhcHByb3ByaWF0ZSB3aWR0aC5cXG5cXFxuICAgIC8vIE1ha2Ugdm9sdW1lcyBhYm91dCBkb3VibGUgcGl4ZWwgd2lkdGggZm9yIGEgY29uc2VydmF0aXZlIGZpdCAtIGluIHByYWN0aWNlIHRoZVxcblxcXG4gICAgLy8gZXh0cmEgY29zdCBoZXJlIGlzIG1pbmltYWwgY29tcGFyZWQgdG8gdGhlIGxvb3NlIHZvbHVtZSBoZWlnaHRzLlxcblxcXG4gICAgLy9cXG5cXFxuICAgIC8vIE4gPSBub3JtYWxFQyAoZ3VhcmFudGVlZCBcXFwicmlnaHQtZmFjaW5nXFxcIilcXG5cXFxuICAgIC8vIFIgPSByaWdodEVDXFxuXFxcbiAgICAvLyBwID0gYW5nbGUgYmV0d2VlbiBOIGFuZCBSXFxuXFxcbiAgICAvLyB3ID0gZGlzdGFuY2UgdG8gcHVzaCBhbG9uZyBSIGlmIFIgPT0gTlxcblxcXG4gICAgLy8gZCA9IGRpc3RhbmNlIHRvIHB1c2ggYWxvbmcgTlxcblxcXG4gICAgLy9cXG5cXFxuICAgIC8vICAgTiAgIFJcXG5cXFxuICAgIC8vICB7IFxcIHB8IH0gICAgICAqIGNvcyhwKSA9IGRvdChOLCBSKSA9IHcgLyBkXFxuXFxcbiAgICAvLyAgZFxcIFxcIHwgIHx3ICAgICogZCA9IHcgLyBkb3QoTiwgUilcXG5cXFxuICAgIC8vICAgIHsgXFx8IH1cXG5cXFxuICAgIC8vICAgICAgIG8tLS0tLS0tLS0tIHBvbHlsaW5lIHNlZ21lbnQgLS0tLT5cXG5cXFxuICAgIC8vXFxuXFxcbiAgICBmbG9hdCB3aWR0aCA9IGN6bV9iYXRjaFRhYmxlX3dpZHRoKGJhdGNoSWQpO1xcblxcXG4jaWZkZWYgV0lEVEhfVkFSWUlOR1xcblxcXG4gICAgdl93aWR0aCA9IHdpZHRoO1xcblxcXG4jZW5kaWZcXG5cXFxuXFxuXFxcbiAgICB2X3N0YXJ0UGxhbmVOb3JtYWxFY0FuZEhhbGZXaWR0aC54eXogPSBzdGFydFBsYW5lRUMueHl6O1xcblxcXG4gICAgdl9zdGFydFBsYW5lTm9ybWFsRWNBbmRIYWxmV2lkdGgudyA9IHdpZHRoICogMC41O1xcblxcXG5cXG5cXFxuICAgIHZfZW5kUGxhbmVOb3JtYWxFY0FuZEJhdGNoSWQueHl6ID0gZW5kUGxhbmVFQy54eXo7XFxuXFxcbiAgICB2X2VuZFBsYW5lTm9ybWFsRWNBbmRCYXRjaElkLncgPSBiYXRjaElkO1xcblxcXG5cXG5cXFxuICAgIHdpZHRoID0gd2lkdGggKiBtYXgoMC4wLCBjem1fbWV0ZXJzUGVyUGl4ZWwocG9zaXRpb25FQykpOyAvLyB3aWR0aCA9IGRpc3RhbmNlIHRvIHB1c2ggYWxvbmcgUlxcblxcXG4gICAgd2lkdGggPSB3aWR0aCAvIGRvdChub3JtYWxFQywgdl9yaWdodFBsYW5lRUMueHl6KTsgLy8gd2lkdGggPSBkaXN0YW5jZSB0byBwdXNoIGFsb25nIE5cXG5cXFxuXFxuXFxcbiAgICAvLyBEZXRlcm1pbmUgaWYgdGhpcyB2ZXJ0ZXggaXMgb24gdGhlIFxcXCJsZWZ0XFxcIiBvciBcXFwicmlnaHRcXFwiXFxuXFxcbiNpZmRlZiBDT0xVTUJVU19WSUVXXzJEXFxuXFxcbiAgICAgICAgbm9ybWFsRUMgKj0gc2lnbih0ZXhjb29yZE5vcm1hbGl6YXRpb24yRC54KTtcXG5cXFxuI2Vsc2VcXG5cXFxuICAgICAgICBub3JtYWxFQyAqPSBzaWduKGVuZE5vcm1hbEFuZFRleHR1cmVDb29yZGluYXRlTm9ybWFsaXphdGlvblgudyk7XFxuXFxcbiNlbmRpZlxcblxcXG5cXG5cXFxuICAgIHBvc2l0aW9uRUMueHl6ICs9IHdpZHRoICogbm9ybWFsRUM7XFxuXFxcbiAgICBnbF9Qb3NpdGlvbiA9IGN6bV9kZXB0aENsYW1wKGN6bV9wcm9qZWN0aW9uICogcG9zaXRpb25FQyk7XFxuXFxcblxcblxcXG4jaWZkZWYgQU5HTEVfVkFSWUlOR1xcblxcXG4gICAgLy8gQXBwcm94aW1hdGUgcmVsYXRpdmUgc2NyZWVuIHNwYWNlIGRpcmVjdGlvbiBvZiB0aGUgbGluZS5cXG5cXFxuICAgIHZlYzIgYXBwcm94TGluZURpcmVjdGlvbiA9IG5vcm1hbGl6ZSh2ZWMyKGZvcndhcmREaXJlY3Rpb25FQy54LCAtZm9yd2FyZERpcmVjdGlvbkVDLnkpKTtcXG5cXFxuICAgIGFwcHJveExpbmVEaXJlY3Rpb24ueSA9IGN6bV9icmFuY2hGcmVlVGVybmFyeShhcHByb3hMaW5lRGlyZWN0aW9uLnggPT0gMC4wICYmIGFwcHJveExpbmVEaXJlY3Rpb24ueSA9PSAwLjAsIC0xLjAsIGFwcHJveExpbmVEaXJlY3Rpb24ueSk7XFxuXFxcbiAgICB2X3BvbHlsaW5lQW5nbGUgPSBjem1fZmFzdEFwcHJveGltYXRlQXRhbihhcHByb3hMaW5lRGlyZWN0aW9uLngsIGFwcHJveExpbmVEaXJlY3Rpb24ueSk7XFxuXFxcbiNlbmRpZlxcblxcXG59XFxuXFxcblwiO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///73248\n')},9067:function(__unused_webpack___webpack_module__,__webpack_exports__){eval('//This file is automatically rebuilt by the Cesium build process.\n/* harmony default export */ __webpack_exports__["Z"] = ("attribute vec3 position3DHigh;\\n\\\nattribute vec3 position3DLow;\\n\\\nattribute vec3 position2DHigh;\\n\\\nattribute vec3 position2DLow;\\n\\\nattribute vec3 prevPosition3DHigh;\\n\\\nattribute vec3 prevPosition3DLow;\\n\\\nattribute vec3 prevPosition2DHigh;\\n\\\nattribute vec3 prevPosition2DLow;\\n\\\nattribute vec3 nextPosition3DHigh;\\n\\\nattribute vec3 nextPosition3DLow;\\n\\\nattribute vec3 nextPosition2DHigh;\\n\\\nattribute vec3 nextPosition2DLow;\\n\\\nattribute vec4 texCoordExpandAndBatchIndex;\\n\\\n\\n\\\nvarying vec2  v_st;\\n\\\nvarying float v_width;\\n\\\nvarying vec4 v_pickColor;\\n\\\nvarying float v_polylineAngle;\\n\\\n\\n\\\nvoid main()\\n\\\n{\\n\\\n    float texCoord = texCoordExpandAndBatchIndex.x;\\n\\\n    float expandDir = texCoordExpandAndBatchIndex.y;\\n\\\n    bool usePrev = texCoordExpandAndBatchIndex.z < 0.0;\\n\\\n    float batchTableIndex = texCoordExpandAndBatchIndex.w;\\n\\\n\\n\\\n    vec2 widthAndShow = batchTable_getWidthAndShow(batchTableIndex);\\n\\\n    float width = widthAndShow.x + 0.5;\\n\\\n    float show = widthAndShow.y;\\n\\\n\\n\\\n    if (width < 1.0)\\n\\\n    {\\n\\\n        show = 0.0;\\n\\\n    }\\n\\\n\\n\\\n    vec4 pickColor = batchTable_getPickColor(batchTableIndex);\\n\\\n\\n\\\n    vec4 p, prev, next;\\n\\\n    if (czm_morphTime == 1.0)\\n\\\n    {\\n\\\n        p = czm_translateRelativeToEye(position3DHigh.xyz, position3DLow.xyz);\\n\\\n        prev = czm_translateRelativeToEye(prevPosition3DHigh.xyz, prevPosition3DLow.xyz);\\n\\\n        next = czm_translateRelativeToEye(nextPosition3DHigh.xyz, nextPosition3DLow.xyz);\\n\\\n    }\\n\\\n    else if (czm_morphTime == 0.0)\\n\\\n    {\\n\\\n        p = czm_translateRelativeToEye(position2DHigh.zxy, position2DLow.zxy);\\n\\\n        prev = czm_translateRelativeToEye(prevPosition2DHigh.zxy, prevPosition2DLow.zxy);\\n\\\n        next = czm_translateRelativeToEye(nextPosition2DHigh.zxy, nextPosition2DLow.zxy);\\n\\\n    }\\n\\\n    else\\n\\\n    {\\n\\\n        p = czm_columbusViewMorph(\\n\\\n                czm_translateRelativeToEye(position2DHigh.zxy, position2DLow.zxy),\\n\\\n                czm_translateRelativeToEye(position3DHigh.xyz, position3DLow.xyz),\\n\\\n                czm_morphTime);\\n\\\n        prev = czm_columbusViewMorph(\\n\\\n                czm_translateRelativeToEye(prevPosition2DHigh.zxy, prevPosition2DLow.zxy),\\n\\\n                czm_translateRelativeToEye(prevPosition3DHigh.xyz, prevPosition3DLow.xyz),\\n\\\n                czm_morphTime);\\n\\\n        next = czm_columbusViewMorph(\\n\\\n                czm_translateRelativeToEye(nextPosition2DHigh.zxy, nextPosition2DLow.zxy),\\n\\\n                czm_translateRelativeToEye(nextPosition3DHigh.xyz, nextPosition3DLow.xyz),\\n\\\n                czm_morphTime);\\n\\\n    }\\n\\\n\\n\\\n    #ifdef DISTANCE_DISPLAY_CONDITION\\n\\\n        vec3 centerHigh = batchTable_getCenterHigh(batchTableIndex);\\n\\\n        vec4 centerLowAndRadius = batchTable_getCenterLowAndRadius(batchTableIndex);\\n\\\n        vec3 centerLow = centerLowAndRadius.xyz;\\n\\\n        float radius = centerLowAndRadius.w;\\n\\\n        vec2 distanceDisplayCondition = batchTable_getDistanceDisplayCondition(batchTableIndex);\\n\\\n\\n\\\n        float lengthSq;\\n\\\n        if (czm_sceneMode == czm_sceneMode2D)\\n\\\n        {\\n\\\n            lengthSq = czm_eyeHeight2D.y;\\n\\\n        }\\n\\\n        else\\n\\\n        {\\n\\\n            vec4 center = czm_translateRelativeToEye(centerHigh.xyz, centerLow.xyz);\\n\\\n            lengthSq = max(0.0, dot(center.xyz, center.xyz) - radius * radius);\\n\\\n        }\\n\\\n\\n\\\n        float nearSq = distanceDisplayCondition.x * distanceDisplayCondition.x;\\n\\\n        float farSq = distanceDisplayCondition.y * distanceDisplayCondition.y;\\n\\\n        if (lengthSq < nearSq || lengthSq > farSq)\\n\\\n        {\\n\\\n            show = 0.0;\\n\\\n        }\\n\\\n    #endif\\n\\\n\\n\\\n    float polylineAngle;\\n\\\n    vec4 positionWC = getPolylineWindowCoordinates(p, prev, next, expandDir, width, usePrev, polylineAngle);\\n\\\n    gl_Position = czm_viewportOrthographic * positionWC * show;\\n\\\n\\n\\\n    v_st.s = texCoord;\\n\\\n    v_st.t = czm_writeNonPerspective(clamp(expandDir, 0.0, 1.0), gl_Position.w);\\n\\\n\\n\\\n    v_width = width;\\n\\\n    v_pickColor = pickColor;\\n\\\n    v_polylineAngle = polylineAngle;\\n\\\n}\\n\\\n");\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiOTA2Ny5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBLHlEQUFlLCtCQUErQjtBQUM5Qyw2QkFBNkI7QUFDN0IsOEJBQThCO0FBQzlCLDZCQUE2QjtBQUM3QixrQ0FBa0M7QUFDbEMsaUNBQWlDO0FBQ2pDLGtDQUFrQztBQUNsQyxpQ0FBaUM7QUFDakMsa0NBQWtDO0FBQ2xDLGlDQUFpQztBQUNqQyxrQ0FBa0M7QUFDbEMsaUNBQWlDO0FBQ2pDLDJDQUEyQztBQUMzQztBQUNBLG1CQUFtQjtBQUNuQixzQkFBc0I7QUFDdEIseUJBQXlCO0FBQ3pCLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0EsQ0FBQztBQUNELG1EQUFtRDtBQUNuRCxvREFBb0Q7QUFDcEQsdURBQXVEO0FBQ3ZELDBEQUEwRDtBQUMxRDtBQUNBLG9FQUFvRTtBQUNwRSx1Q0FBdUM7QUFDdkMsZ0NBQWdDO0FBQ2hDO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsbUJBQW1CO0FBQ25CLEtBQUs7QUFDTDtBQUNBLDhEQUE4RDtBQUM5RDtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBLEtBQUs7QUFDTCw4RUFBOEU7QUFDOUUseUZBQXlGO0FBQ3pGLHlGQUF5RjtBQUN6RixLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0wsOEVBQThFO0FBQzlFLHlGQUF5RjtBQUN6Rix5RkFBeUY7QUFDekYsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLCtCQUErQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQSwrQkFBK0I7QUFDL0I7QUFDQTtBQUNBO0FBQ0EsK0JBQStCO0FBQy9CLEtBQUs7QUFDTDtBQUNBO0FBQ0Esb0VBQW9FO0FBQ3BFLG9GQUFvRjtBQUNwRixnREFBZ0Q7QUFDaEQsNENBQTRDO0FBQzVDLGdHQUFnRztBQUNoRztBQUNBLHVCQUF1QjtBQUN2QjtBQUNBLFNBQVM7QUFDVCx5Q0FBeUM7QUFDekMsU0FBUztBQUNUO0FBQ0EsU0FBUztBQUNULG9GQUFvRjtBQUNwRiwrRUFBK0U7QUFDL0UsU0FBUztBQUNUO0FBQ0EsK0VBQStFO0FBQy9FLDhFQUE4RTtBQUM5RTtBQUNBLFNBQVM7QUFDVCx1QkFBdUI7QUFDdkIsU0FBUztBQUNUO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEIsNEdBQTRHO0FBQzVHLCtEQUErRDtBQUMvRDtBQUNBLHNCQUFzQjtBQUN0QixnRkFBZ0Y7QUFDaEY7QUFDQSxvQkFBb0I7QUFDcEIsNEJBQTRCO0FBQzVCLG9DQUFvQztBQUNwQyxDQUFDO0FBQ0QsQ0FBQyxFQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdnVlMy13ZWJwYWNrNS8uL25vZGVfbW9kdWxlcy9jZXNpdW0vU291cmNlL1NoYWRlcnMvUG9seWxpbmVWUy5qcz9iYzk5Il0sInNvdXJjZXNDb250ZW50IjpbIi8vVGhpcyBmaWxlIGlzIGF1dG9tYXRpY2FsbHkgcmVidWlsdCBieSB0aGUgQ2VzaXVtIGJ1aWxkIHByb2Nlc3MuXG5leHBvcnQgZGVmYXVsdCBcImF0dHJpYnV0ZSB2ZWMzIHBvc2l0aW9uM0RIaWdoO1xcblxcXG5hdHRyaWJ1dGUgdmVjMyBwb3NpdGlvbjNETG93O1xcblxcXG5hdHRyaWJ1dGUgdmVjMyBwb3NpdGlvbjJESGlnaDtcXG5cXFxuYXR0cmlidXRlIHZlYzMgcG9zaXRpb24yRExvdztcXG5cXFxuYXR0cmlidXRlIHZlYzMgcHJldlBvc2l0aW9uM0RIaWdoO1xcblxcXG5hdHRyaWJ1dGUgdmVjMyBwcmV2UG9zaXRpb24zRExvdztcXG5cXFxuYXR0cmlidXRlIHZlYzMgcHJldlBvc2l0aW9uMkRIaWdoO1xcblxcXG5hdHRyaWJ1dGUgdmVjMyBwcmV2UG9zaXRpb24yRExvdztcXG5cXFxuYXR0cmlidXRlIHZlYzMgbmV4dFBvc2l0aW9uM0RIaWdoO1xcblxcXG5hdHRyaWJ1dGUgdmVjMyBuZXh0UG9zaXRpb24zRExvdztcXG5cXFxuYXR0cmlidXRlIHZlYzMgbmV4dFBvc2l0aW9uMkRIaWdoO1xcblxcXG5hdHRyaWJ1dGUgdmVjMyBuZXh0UG9zaXRpb24yRExvdztcXG5cXFxuYXR0cmlidXRlIHZlYzQgdGV4Q29vcmRFeHBhbmRBbmRCYXRjaEluZGV4O1xcblxcXG5cXG5cXFxudmFyeWluZyB2ZWMyICB2X3N0O1xcblxcXG52YXJ5aW5nIGZsb2F0IHZfd2lkdGg7XFxuXFxcbnZhcnlpbmcgdmVjNCB2X3BpY2tDb2xvcjtcXG5cXFxudmFyeWluZyBmbG9hdCB2X3BvbHlsaW5lQW5nbGU7XFxuXFxcblxcblxcXG52b2lkIG1haW4oKVxcblxcXG57XFxuXFxcbiAgICBmbG9hdCB0ZXhDb29yZCA9IHRleENvb3JkRXhwYW5kQW5kQmF0Y2hJbmRleC54O1xcblxcXG4gICAgZmxvYXQgZXhwYW5kRGlyID0gdGV4Q29vcmRFeHBhbmRBbmRCYXRjaEluZGV4Lnk7XFxuXFxcbiAgICBib29sIHVzZVByZXYgPSB0ZXhDb29yZEV4cGFuZEFuZEJhdGNoSW5kZXgueiA8IDAuMDtcXG5cXFxuICAgIGZsb2F0IGJhdGNoVGFibGVJbmRleCA9IHRleENvb3JkRXhwYW5kQW5kQmF0Y2hJbmRleC53O1xcblxcXG5cXG5cXFxuICAgIHZlYzIgd2lkdGhBbmRTaG93ID0gYmF0Y2hUYWJsZV9nZXRXaWR0aEFuZFNob3coYmF0Y2hUYWJsZUluZGV4KTtcXG5cXFxuICAgIGZsb2F0IHdpZHRoID0gd2lkdGhBbmRTaG93LnggKyAwLjU7XFxuXFxcbiAgICBmbG9hdCBzaG93ID0gd2lkdGhBbmRTaG93Lnk7XFxuXFxcblxcblxcXG4gICAgaWYgKHdpZHRoIDwgMS4wKVxcblxcXG4gICAge1xcblxcXG4gICAgICAgIHNob3cgPSAwLjA7XFxuXFxcbiAgICB9XFxuXFxcblxcblxcXG4gICAgdmVjNCBwaWNrQ29sb3IgPSBiYXRjaFRhYmxlX2dldFBpY2tDb2xvcihiYXRjaFRhYmxlSW5kZXgpO1xcblxcXG5cXG5cXFxuICAgIHZlYzQgcCwgcHJldiwgbmV4dDtcXG5cXFxuICAgIGlmIChjem1fbW9ycGhUaW1lID09IDEuMClcXG5cXFxuICAgIHtcXG5cXFxuICAgICAgICBwID0gY3ptX3RyYW5zbGF0ZVJlbGF0aXZlVG9FeWUocG9zaXRpb24zREhpZ2gueHl6LCBwb3NpdGlvbjNETG93Lnh5eik7XFxuXFxcbiAgICAgICAgcHJldiA9IGN6bV90cmFuc2xhdGVSZWxhdGl2ZVRvRXllKHByZXZQb3NpdGlvbjNESGlnaC54eXosIHByZXZQb3NpdGlvbjNETG93Lnh5eik7XFxuXFxcbiAgICAgICAgbmV4dCA9IGN6bV90cmFuc2xhdGVSZWxhdGl2ZVRvRXllKG5leHRQb3NpdGlvbjNESGlnaC54eXosIG5leHRQb3NpdGlvbjNETG93Lnh5eik7XFxuXFxcbiAgICB9XFxuXFxcbiAgICBlbHNlIGlmIChjem1fbW9ycGhUaW1lID09IDAuMClcXG5cXFxuICAgIHtcXG5cXFxuICAgICAgICBwID0gY3ptX3RyYW5zbGF0ZVJlbGF0aXZlVG9FeWUocG9zaXRpb24yREhpZ2guenh5LCBwb3NpdGlvbjJETG93Lnp4eSk7XFxuXFxcbiAgICAgICAgcHJldiA9IGN6bV90cmFuc2xhdGVSZWxhdGl2ZVRvRXllKHByZXZQb3NpdGlvbjJESGlnaC56eHksIHByZXZQb3NpdGlvbjJETG93Lnp4eSk7XFxuXFxcbiAgICAgICAgbmV4dCA9IGN6bV90cmFuc2xhdGVSZWxhdGl2ZVRvRXllKG5leHRQb3NpdGlvbjJESGlnaC56eHksIG5leHRQb3NpdGlvbjJETG93Lnp4eSk7XFxuXFxcbiAgICB9XFxuXFxcbiAgICBlbHNlXFxuXFxcbiAgICB7XFxuXFxcbiAgICAgICAgcCA9IGN6bV9jb2x1bWJ1c1ZpZXdNb3JwaChcXG5cXFxuICAgICAgICAgICAgICAgIGN6bV90cmFuc2xhdGVSZWxhdGl2ZVRvRXllKHBvc2l0aW9uMkRIaWdoLnp4eSwgcG9zaXRpb24yRExvdy56eHkpLFxcblxcXG4gICAgICAgICAgICAgICAgY3ptX3RyYW5zbGF0ZVJlbGF0aXZlVG9FeWUocG9zaXRpb24zREhpZ2gueHl6LCBwb3NpdGlvbjNETG93Lnh5eiksXFxuXFxcbiAgICAgICAgICAgICAgICBjem1fbW9ycGhUaW1lKTtcXG5cXFxuICAgICAgICBwcmV2ID0gY3ptX2NvbHVtYnVzVmlld01vcnBoKFxcblxcXG4gICAgICAgICAgICAgICAgY3ptX3RyYW5zbGF0ZVJlbGF0aXZlVG9FeWUocHJldlBvc2l0aW9uMkRIaWdoLnp4eSwgcHJldlBvc2l0aW9uMkRMb3cuenh5KSxcXG5cXFxuICAgICAgICAgICAgICAgIGN6bV90cmFuc2xhdGVSZWxhdGl2ZVRvRXllKHByZXZQb3NpdGlvbjNESGlnaC54eXosIHByZXZQb3NpdGlvbjNETG93Lnh5eiksXFxuXFxcbiAgICAgICAgICAgICAgICBjem1fbW9ycGhUaW1lKTtcXG5cXFxuICAgICAgICBuZXh0ID0gY3ptX2NvbHVtYnVzVmlld01vcnBoKFxcblxcXG4gICAgICAgICAgICAgICAgY3ptX3RyYW5zbGF0ZVJlbGF0aXZlVG9FeWUobmV4dFBvc2l0aW9uMkRIaWdoLnp4eSwgbmV4dFBvc2l0aW9uMkRMb3cuenh5KSxcXG5cXFxuICAgICAgICAgICAgICAgIGN6bV90cmFuc2xhdGVSZWxhdGl2ZVRvRXllKG5leHRQb3NpdGlvbjNESGlnaC54eXosIG5leHRQb3NpdGlvbjNETG93Lnh5eiksXFxuXFxcbiAgICAgICAgICAgICAgICBjem1fbW9ycGhUaW1lKTtcXG5cXFxuICAgIH1cXG5cXFxuXFxuXFxcbiAgICAjaWZkZWYgRElTVEFOQ0VfRElTUExBWV9DT05ESVRJT05cXG5cXFxuICAgICAgICB2ZWMzIGNlbnRlckhpZ2ggPSBiYXRjaFRhYmxlX2dldENlbnRlckhpZ2goYmF0Y2hUYWJsZUluZGV4KTtcXG5cXFxuICAgICAgICB2ZWM0IGNlbnRlckxvd0FuZFJhZGl1cyA9IGJhdGNoVGFibGVfZ2V0Q2VudGVyTG93QW5kUmFkaXVzKGJhdGNoVGFibGVJbmRleCk7XFxuXFxcbiAgICAgICAgdmVjMyBjZW50ZXJMb3cgPSBjZW50ZXJMb3dBbmRSYWRpdXMueHl6O1xcblxcXG4gICAgICAgIGZsb2F0IHJhZGl1cyA9IGNlbnRlckxvd0FuZFJhZGl1cy53O1xcblxcXG4gICAgICAgIHZlYzIgZGlzdGFuY2VEaXNwbGF5Q29uZGl0aW9uID0gYmF0Y2hUYWJsZV9nZXREaXN0YW5jZURpc3BsYXlDb25kaXRpb24oYmF0Y2hUYWJsZUluZGV4KTtcXG5cXFxuXFxuXFxcbiAgICAgICAgZmxvYXQgbGVuZ3RoU3E7XFxuXFxcbiAgICAgICAgaWYgKGN6bV9zY2VuZU1vZGUgPT0gY3ptX3NjZW5lTW9kZTJEKVxcblxcXG4gICAgICAgIHtcXG5cXFxuICAgICAgICAgICAgbGVuZ3RoU3EgPSBjem1fZXllSGVpZ2h0MkQueTtcXG5cXFxuICAgICAgICB9XFxuXFxcbiAgICAgICAgZWxzZVxcblxcXG4gICAgICAgIHtcXG5cXFxuICAgICAgICAgICAgdmVjNCBjZW50ZXIgPSBjem1fdHJhbnNsYXRlUmVsYXRpdmVUb0V5ZShjZW50ZXJIaWdoLnh5eiwgY2VudGVyTG93Lnh5eik7XFxuXFxcbiAgICAgICAgICAgIGxlbmd0aFNxID0gbWF4KDAuMCwgZG90KGNlbnRlci54eXosIGNlbnRlci54eXopIC0gcmFkaXVzICogcmFkaXVzKTtcXG5cXFxuICAgICAgICB9XFxuXFxcblxcblxcXG4gICAgICAgIGZsb2F0IG5lYXJTcSA9IGRpc3RhbmNlRGlzcGxheUNvbmRpdGlvbi54ICogZGlzdGFuY2VEaXNwbGF5Q29uZGl0aW9uLng7XFxuXFxcbiAgICAgICAgZmxvYXQgZmFyU3EgPSBkaXN0YW5jZURpc3BsYXlDb25kaXRpb24ueSAqIGRpc3RhbmNlRGlzcGxheUNvbmRpdGlvbi55O1xcblxcXG4gICAgICAgIGlmIChsZW5ndGhTcSA8IG5lYXJTcSB8fCBsZW5ndGhTcSA+IGZhclNxKVxcblxcXG4gICAgICAgIHtcXG5cXFxuICAgICAgICAgICAgc2hvdyA9IDAuMDtcXG5cXFxuICAgICAgICB9XFxuXFxcbiAgICAjZW5kaWZcXG5cXFxuXFxuXFxcbiAgICBmbG9hdCBwb2x5bGluZUFuZ2xlO1xcblxcXG4gICAgdmVjNCBwb3NpdGlvbldDID0gZ2V0UG9seWxpbmVXaW5kb3dDb29yZGluYXRlcyhwLCBwcmV2LCBuZXh0LCBleHBhbmREaXIsIHdpZHRoLCB1c2VQcmV2LCBwb2x5bGluZUFuZ2xlKTtcXG5cXFxuICAgIGdsX1Bvc2l0aW9uID0gY3ptX3ZpZXdwb3J0T3J0aG9ncmFwaGljICogcG9zaXRpb25XQyAqIHNob3c7XFxuXFxcblxcblxcXG4gICAgdl9zdC5zID0gdGV4Q29vcmQ7XFxuXFxcbiAgICB2X3N0LnQgPSBjem1fd3JpdGVOb25QZXJzcGVjdGl2ZShjbGFtcChleHBhbmREaXIsIDAuMCwgMS4wKSwgZ2xfUG9zaXRpb24udyk7XFxuXFxcblxcblxcXG4gICAgdl93aWR0aCA9IHdpZHRoO1xcblxcXG4gICAgdl9waWNrQ29sb3IgPSBwaWNrQ29sb3I7XFxuXFxcbiAgICB2X3BvbHlsaW5lQW5nbGUgPSBwb2x5bGluZUFuZ2xlO1xcblxcXG59XFxuXFxcblwiO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///9067\n')},31659:function(__unused_webpack___webpack_module__,__webpack_exports__){eval('//This file is automatically rebuilt by the Cesium build process.\n/* harmony default export */ __webpack_exports__["Z"] = ("uniform sampler2D colorTexture;\\n\\\n\\n\\\nvarying vec2 v_textureCoordinates;\\n\\\n\\n\\\n#ifdef AUTO_EXPOSURE\\n\\\nuniform sampler2D autoExposure;\\n\\\n#endif\\n\\\n\\n\\\nvoid main()\\n\\\n{\\n\\\n    vec4 fragmentColor = texture2D(colorTexture, v_textureCoordinates);\\n\\\n    vec3 color = fragmentColor.rgb;\\n\\\n\\n\\\n#ifdef AUTO_EXPOSURE\\n\\\n    color /= texture2D(autoExposure, vec2(0.5)).r;\\n\\\n#endif\\n\\\n    color = czm_acesTonemapping(color);\\n\\\n    color = czm_inverseGamma(color);\\n\\\n\\n\\\n    gl_FragColor = vec4(color, fragmentColor.a);\\n\\\n}\\n\\\n");\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMzE2NTkuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQSx5REFBZSxnQ0FBZ0M7QUFDL0M7QUFDQSxrQ0FBa0M7QUFDbEM7QUFDQTtBQUNBLCtCQUErQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0QsdUVBQXVFO0FBQ3ZFLG1DQUFtQztBQUNuQztBQUNBO0FBQ0Esa0RBQWtEO0FBQ2xEO0FBQ0EsdUNBQXVDO0FBQ3ZDLG9DQUFvQztBQUNwQztBQUNBLGdEQUFnRDtBQUNoRCxDQUFDO0FBQ0QsQ0FBQyxFQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdnVlMy13ZWJwYWNrNS8uL25vZGVfbW9kdWxlcy9jZXNpdW0vU291cmNlL1NoYWRlcnMvUG9zdFByb2Nlc3NTdGFnZXMvQWNlc1RvbmVtYXBwaW5nU3RhZ2UuanM/OWRjZSJdLCJzb3VyY2VzQ29udGVudCI6WyIvL1RoaXMgZmlsZSBpcyBhdXRvbWF0aWNhbGx5IHJlYnVpbHQgYnkgdGhlIENlc2l1bSBidWlsZCBwcm9jZXNzLlxuZXhwb3J0IGRlZmF1bHQgXCJ1bmlmb3JtIHNhbXBsZXIyRCBjb2xvclRleHR1cmU7XFxuXFxcblxcblxcXG52YXJ5aW5nIHZlYzIgdl90ZXh0dXJlQ29vcmRpbmF0ZXM7XFxuXFxcblxcblxcXG4jaWZkZWYgQVVUT19FWFBPU1VSRVxcblxcXG51bmlmb3JtIHNhbXBsZXIyRCBhdXRvRXhwb3N1cmU7XFxuXFxcbiNlbmRpZlxcblxcXG5cXG5cXFxudm9pZCBtYWluKClcXG5cXFxue1xcblxcXG4gICAgdmVjNCBmcmFnbWVudENvbG9yID0gdGV4dHVyZTJEKGNvbG9yVGV4dHVyZSwgdl90ZXh0dXJlQ29vcmRpbmF0ZXMpO1xcblxcXG4gICAgdmVjMyBjb2xvciA9IGZyYWdtZW50Q29sb3IucmdiO1xcblxcXG5cXG5cXFxuI2lmZGVmIEFVVE9fRVhQT1NVUkVcXG5cXFxuICAgIGNvbG9yIC89IHRleHR1cmUyRChhdXRvRXhwb3N1cmUsIHZlYzIoMC41KSkucjtcXG5cXFxuI2VuZGlmXFxuXFxcbiAgICBjb2xvciA9IGN6bV9hY2VzVG9uZW1hcHBpbmcoY29sb3IpO1xcblxcXG4gICAgY29sb3IgPSBjem1faW52ZXJzZUdhbW1hKGNvbG9yKTtcXG5cXFxuXFxuXFxcbiAgICBnbF9GcmFnQ29sb3IgPSB2ZWM0KGNvbG9yLCBmcmFnbWVudENvbG9yLmEpO1xcblxcXG59XFxuXFxcblwiO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///31659\n')},40995:function(__unused_webpack___webpack_module__,__webpack_exports__){eval('//This file is automatically rebuilt by the Cesium build process.\n/* harmony default export */ __webpack_exports__["Z"] = ("uniform sampler2D colorTexture;\\n\\\nuniform sampler2D colorTexture2;\\n\\\n\\n\\\nuniform vec2 center;\\n\\\nuniform float radius;\\n\\\n\\n\\\nvarying vec2 v_textureCoordinates;\\n\\\n\\n\\\nvoid main()\\n\\\n{\\n\\\n    vec4 color0 = texture2D(colorTexture, v_textureCoordinates);\\n\\\n    vec4 color1 = texture2D(colorTexture2, v_textureCoordinates);\\n\\\n\\n\\\n    float x = length(gl_FragCoord.xy - center) / radius;\\n\\\n    float t = smoothstep(0.5, 0.8, x);\\n\\\n    gl_FragColor = mix(color0 + color1, color1, t);\\n\\\n}\\n\\\n");\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNDA5OTUuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQSx5REFBZSxnQ0FBZ0M7QUFDL0MsZ0NBQWdDO0FBQ2hDO0FBQ0Esb0JBQW9CO0FBQ3BCLHFCQUFxQjtBQUNyQjtBQUNBLGtDQUFrQztBQUNsQztBQUNBO0FBQ0EsQ0FBQztBQUNELGdFQUFnRTtBQUNoRSxpRUFBaUU7QUFDakU7QUFDQSx3REFBd0Q7QUFDeEQsc0NBQXNDO0FBQ3RDLG1EQUFtRDtBQUNuRCxDQUFDO0FBQ0QsQ0FBQyxFQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdnVlMy13ZWJwYWNrNS8uL25vZGVfbW9kdWxlcy9jZXNpdW0vU291cmNlL1NoYWRlcnMvUG9zdFByb2Nlc3NTdGFnZXMvQWRkaXRpdmVCbGVuZC5qcz8zYmQ1Il0sInNvdXJjZXNDb250ZW50IjpbIi8vVGhpcyBmaWxlIGlzIGF1dG9tYXRpY2FsbHkgcmVidWlsdCBieSB0aGUgQ2VzaXVtIGJ1aWxkIHByb2Nlc3MuXG5leHBvcnQgZGVmYXVsdCBcInVuaWZvcm0gc2FtcGxlcjJEIGNvbG9yVGV4dHVyZTtcXG5cXFxudW5pZm9ybSBzYW1wbGVyMkQgY29sb3JUZXh0dXJlMjtcXG5cXFxuXFxuXFxcbnVuaWZvcm0gdmVjMiBjZW50ZXI7XFxuXFxcbnVuaWZvcm0gZmxvYXQgcmFkaXVzO1xcblxcXG5cXG5cXFxudmFyeWluZyB2ZWMyIHZfdGV4dHVyZUNvb3JkaW5hdGVzO1xcblxcXG5cXG5cXFxudm9pZCBtYWluKClcXG5cXFxue1xcblxcXG4gICAgdmVjNCBjb2xvcjAgPSB0ZXh0dXJlMkQoY29sb3JUZXh0dXJlLCB2X3RleHR1cmVDb29yZGluYXRlcyk7XFxuXFxcbiAgICB2ZWM0IGNvbG9yMSA9IHRleHR1cmUyRChjb2xvclRleHR1cmUyLCB2X3RleHR1cmVDb29yZGluYXRlcyk7XFxuXFxcblxcblxcXG4gICAgZmxvYXQgeCA9IGxlbmd0aChnbF9GcmFnQ29vcmQueHkgLSBjZW50ZXIpIC8gcmFkaXVzO1xcblxcXG4gICAgZmxvYXQgdCA9IHNtb290aHN0ZXAoMC41LCAwLjgsIHgpO1xcblxcXG4gICAgZ2xfRnJhZ0NvbG9yID0gbWl4KGNvbG9yMCArIGNvbG9yMSwgY29sb3IxLCB0KTtcXG5cXFxufVxcblxcXG5cIjtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///40995\n')},11968:function(__unused_webpack___webpack_module__,__webpack_exports__){eval('//This file is automatically rebuilt by the Cesium build process.\n/* harmony default export */ __webpack_exports__["Z"] = ("uniform sampler2D randomTexture;\\n\\\nuniform sampler2D depthTexture;\\n\\\nuniform float intensity;\\n\\\nuniform float bias;\\n\\\nuniform float lengthCap;\\n\\\nuniform float stepSize;\\n\\\nuniform float frustumLength;\\n\\\n\\n\\\nvarying vec2 v_textureCoordinates;\\n\\\n\\n\\\nvec4 clipToEye(vec2 uv, float depth)\\n\\\n{\\n\\\n    vec2 xy = vec2((uv.x * 2.0 - 1.0), ((1.0 - uv.y) * 2.0 - 1.0));\\n\\\n    vec4 posEC = czm_inverseProjection * vec4(xy, depth, 1.0);\\n\\\n    posEC = posEC / posEC.w;\\n\\\n    return posEC;\\n\\\n}\\n\\\n\\n\\\n//Reconstruct Normal Without Edge Removation\\n\\\nvec3 getNormalXEdge(vec3 posInCamera, float depthU, float depthD, float depthL, float depthR, vec2 pixelSize)\\n\\\n{\\n\\\n    vec4 posInCameraUp = clipToEye(v_textureCoordinates - vec2(0.0, pixelSize.y), depthU);\\n\\\n    vec4 posInCameraDown = clipToEye(v_textureCoordinates + vec2(0.0, pixelSize.y), depthD);\\n\\\n    vec4 posInCameraLeft = clipToEye(v_textureCoordinates - vec2(pixelSize.x, 0.0), depthL);\\n\\\n    vec4 posInCameraRight = clipToEye(v_textureCoordinates + vec2(pixelSize.x, 0.0), depthR);\\n\\\n\\n\\\n    vec3 up = posInCamera.xyz - posInCameraUp.xyz;\\n\\\n    vec3 down = posInCameraDown.xyz - posInCamera.xyz;\\n\\\n    vec3 left = posInCamera.xyz - posInCameraLeft.xyz;\\n\\\n    vec3 right = posInCameraRight.xyz - posInCamera.xyz;\\n\\\n\\n\\\n    vec3 DX = length(left) < length(right) ? left : right;\\n\\\n    vec3 DY = length(up) < length(down) ? up : down;\\n\\\n\\n\\\n    return normalize(cross(DY, DX));\\n\\\n}\\n\\\n\\n\\\nvoid main(void)\\n\\\n{\\n\\\n    float depth = czm_readDepth(depthTexture, v_textureCoordinates);\\n\\\n    vec4 posInCamera = clipToEye(v_textureCoordinates, depth);\\n\\\n\\n\\\n    if (posInCamera.z > frustumLength)\\n\\\n    {\\n\\\n        gl_FragColor = vec4(1.0);\\n\\\n        return;\\n\\\n    }\\n\\\n\\n\\\n    vec2 pixelSize = czm_pixelRatio / czm_viewport.zw;\\n\\\n    float depthU = czm_readDepth(depthTexture, v_textureCoordinates - vec2(0.0, pixelSize.y));\\n\\\n    float depthD = czm_readDepth(depthTexture, v_textureCoordinates + vec2(0.0, pixelSize.y));\\n\\\n    float depthL = czm_readDepth(depthTexture, v_textureCoordinates - vec2(pixelSize.x, 0.0));\\n\\\n    float depthR = czm_readDepth(depthTexture, v_textureCoordinates + vec2(pixelSize.x, 0.0));\\n\\\n    vec3 normalInCamera = getNormalXEdge(posInCamera.xyz, depthU, depthD, depthL, depthR, pixelSize);\\n\\\n\\n\\\n    float ao = 0.0;\\n\\\n    vec2 sampleDirection = vec2(1.0, 0.0);\\n\\\n    float gapAngle = 90.0 * czm_radiansPerDegree;\\n\\\n\\n\\\n    // RandomNoise\\n\\\n    float randomVal = texture2D(randomTexture, v_textureCoordinates).x;\\n\\\n\\n\\\n    //Loop for each direction\\n\\\n    for (int i = 0; i < 4; i++)\\n\\\n    {\\n\\\n        float newGapAngle = gapAngle * (float(i) + randomVal);\\n\\\n        float cosVal = cos(newGapAngle);\\n\\\n        float sinVal = sin(newGapAngle);\\n\\\n\\n\\\n        //Rotate Sampling Direction\\n\\\n        vec2 rotatedSampleDirection = vec2(cosVal * sampleDirection.x - sinVal * sampleDirection.y, sinVal * sampleDirection.x + cosVal * sampleDirection.y);\\n\\\n        float localAO = 0.0;\\n\\\n        float localStepSize = stepSize;\\n\\\n\\n\\\n        //Loop for each step\\n\\\n        for (int j = 0; j < 6; j++)\\n\\\n        {\\n\\\n            vec2 newCoords = v_textureCoordinates + rotatedSampleDirection * localStepSize * pixelSize;\\n\\\n\\n\\\n            //Exception Handling\\n\\\n            if(newCoords.x > 1.0 || newCoords.y > 1.0 || newCoords.x < 0.0 || newCoords.y < 0.0)\\n\\\n            {\\n\\\n                break;\\n\\\n            }\\n\\\n\\n\\\n            float stepDepthInfo = czm_readDepth(depthTexture, newCoords);\\n\\\n            vec4 stepPosInCamera = clipToEye(newCoords, stepDepthInfo);\\n\\\n            vec3 diffVec = stepPosInCamera.xyz - posInCamera.xyz;\\n\\\n            float len = length(diffVec);\\n\\\n\\n\\\n            if (len > lengthCap)\\n\\\n            {\\n\\\n                break;\\n\\\n            }\\n\\\n\\n\\\n            float dotVal = clamp(dot(normalInCamera, normalize(diffVec)), 0.0, 1.0 );\\n\\\n            float weight = len / lengthCap;\\n\\\n            weight = 1.0 - weight * weight;\\n\\\n\\n\\\n            if (dotVal < bias)\\n\\\n            {\\n\\\n                dotVal = 0.0;\\n\\\n            }\\n\\\n\\n\\\n            localAO = max(localAO, dotVal * weight);\\n\\\n            localStepSize += stepSize;\\n\\\n        }\\n\\\n        ao += localAO;\\n\\\n    }\\n\\\n\\n\\\n    ao /= 4.0;\\n\\\n    ao = 1.0 - clamp(ao, 0.0, 1.0);\\n\\\n    ao = pow(ao, intensity);\\n\\\n    gl_FragColor = vec4(vec3(ao), 1.0);\\n\\\n}\\n\\\n");\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTE5NjguanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQSx5REFBZSxpQ0FBaUM7QUFDaEQsK0JBQStCO0FBQy9CLHdCQUF3QjtBQUN4QixtQkFBbUI7QUFDbkIsd0JBQXdCO0FBQ3hCLHVCQUF1QjtBQUN2Qiw0QkFBNEI7QUFDNUI7QUFDQSxrQ0FBa0M7QUFDbEM7QUFDQTtBQUNBLENBQUM7QUFDRCxtRUFBbUU7QUFDbkUsOERBQThEO0FBQzlELDRCQUE0QjtBQUM1QixpQkFBaUI7QUFDakIsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRCwwRkFBMEY7QUFDMUYsNEZBQTRGO0FBQzVGLDRGQUE0RjtBQUM1Riw2RkFBNkY7QUFDN0Y7QUFDQSxrREFBa0Q7QUFDbEQsc0RBQXNEO0FBQ3RELHNEQUFzRDtBQUN0RCx3REFBd0Q7QUFDeEQ7QUFDQSwwREFBMEQ7QUFDMUQsb0RBQW9EO0FBQ3BEO0FBQ0Esb0NBQW9DO0FBQ3BDLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNELG9FQUFvRTtBQUNwRSw4REFBOEQ7QUFDOUQ7QUFDQTtBQUNBLEtBQUs7QUFDTCxpQ0FBaUM7QUFDakMsZUFBZTtBQUNmLEtBQUs7QUFDTDtBQUNBLHNEQUFzRDtBQUN0RCw4RkFBOEY7QUFDOUYsOEZBQThGO0FBQzlGLDhGQUE4RjtBQUM5Riw4RkFBOEY7QUFDOUYscUdBQXFHO0FBQ3JHO0FBQ0EsbUJBQW1CO0FBQ25CLDBDQUEwQztBQUMxQyxpREFBaUQ7QUFDakQ7QUFDQTtBQUNBLHVFQUF1RTtBQUN2RTtBQUNBO0FBQ0Esb0JBQW9CLE9BQU87QUFDM0IsS0FBSztBQUNMLDhEQUE4RDtBQUM5RCx3Q0FBd0M7QUFDeEMsd0NBQXdDO0FBQ3hDO0FBQ0E7QUFDQSw2SkFBNko7QUFDN0osNEJBQTRCO0FBQzVCLHVDQUF1QztBQUN2QztBQUNBO0FBQ0Esd0JBQXdCLE9BQU87QUFDL0IsU0FBUztBQUNULHVHQUF1RztBQUN2RztBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2Isc0JBQXNCO0FBQ3RCLGFBQWE7QUFDYjtBQUNBLHlFQUF5RTtBQUN6RSx1RUFBdUU7QUFDdkUsaUVBQWlFO0FBQ2pFLHdDQUF3QztBQUN4QztBQUNBO0FBQ0EsYUFBYTtBQUNiLHNCQUFzQjtBQUN0QixhQUFhO0FBQ2I7QUFDQSxxRkFBcUY7QUFDckYsMkNBQTJDO0FBQzNDLDJDQUEyQztBQUMzQztBQUNBO0FBQ0EsYUFBYTtBQUNiLDZCQUE2QjtBQUM3QixhQUFhO0FBQ2I7QUFDQSxvREFBb0Q7QUFDcEQsc0NBQXNDO0FBQ3RDLFNBQVM7QUFDVCxzQkFBc0I7QUFDdEIsS0FBSztBQUNMO0FBQ0EsY0FBYztBQUNkLG1DQUFtQztBQUNuQyw0QkFBNEI7QUFDNUIsdUNBQXVDO0FBQ3ZDLENBQUM7QUFDRCxDQUFDLEVBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly92dWUzLXdlYnBhY2s1Ly4vbm9kZV9tb2R1bGVzL2Nlc2l1bS9Tb3VyY2UvU2hhZGVycy9Qb3N0UHJvY2Vzc1N0YWdlcy9BbWJpZW50T2NjbHVzaW9uR2VuZXJhdGUuanM/Mzc5NyJdLCJzb3VyY2VzQ29udGVudCI6WyIvL1RoaXMgZmlsZSBpcyBhdXRvbWF0aWNhbGx5IHJlYnVpbHQgYnkgdGhlIENlc2l1bSBidWlsZCBwcm9jZXNzLlxuZXhwb3J0IGRlZmF1bHQgXCJ1bmlmb3JtIHNhbXBsZXIyRCByYW5kb21UZXh0dXJlO1xcblxcXG51bmlmb3JtIHNhbXBsZXIyRCBkZXB0aFRleHR1cmU7XFxuXFxcbnVuaWZvcm0gZmxvYXQgaW50ZW5zaXR5O1xcblxcXG51bmlmb3JtIGZsb2F0IGJpYXM7XFxuXFxcbnVuaWZvcm0gZmxvYXQgbGVuZ3RoQ2FwO1xcblxcXG51bmlmb3JtIGZsb2F0IHN0ZXBTaXplO1xcblxcXG51bmlmb3JtIGZsb2F0IGZydXN0dW1MZW5ndGg7XFxuXFxcblxcblxcXG52YXJ5aW5nIHZlYzIgdl90ZXh0dXJlQ29vcmRpbmF0ZXM7XFxuXFxcblxcblxcXG52ZWM0IGNsaXBUb0V5ZSh2ZWMyIHV2LCBmbG9hdCBkZXB0aClcXG5cXFxue1xcblxcXG4gICAgdmVjMiB4eSA9IHZlYzIoKHV2LnggKiAyLjAgLSAxLjApLCAoKDEuMCAtIHV2LnkpICogMi4wIC0gMS4wKSk7XFxuXFxcbiAgICB2ZWM0IHBvc0VDID0gY3ptX2ludmVyc2VQcm9qZWN0aW9uICogdmVjNCh4eSwgZGVwdGgsIDEuMCk7XFxuXFxcbiAgICBwb3NFQyA9IHBvc0VDIC8gcG9zRUMudztcXG5cXFxuICAgIHJldHVybiBwb3NFQztcXG5cXFxufVxcblxcXG5cXG5cXFxuLy9SZWNvbnN0cnVjdCBOb3JtYWwgV2l0aG91dCBFZGdlIFJlbW92YXRpb25cXG5cXFxudmVjMyBnZXROb3JtYWxYRWRnZSh2ZWMzIHBvc0luQ2FtZXJhLCBmbG9hdCBkZXB0aFUsIGZsb2F0IGRlcHRoRCwgZmxvYXQgZGVwdGhMLCBmbG9hdCBkZXB0aFIsIHZlYzIgcGl4ZWxTaXplKVxcblxcXG57XFxuXFxcbiAgICB2ZWM0IHBvc0luQ2FtZXJhVXAgPSBjbGlwVG9FeWUodl90ZXh0dXJlQ29vcmRpbmF0ZXMgLSB2ZWMyKDAuMCwgcGl4ZWxTaXplLnkpLCBkZXB0aFUpO1xcblxcXG4gICAgdmVjNCBwb3NJbkNhbWVyYURvd24gPSBjbGlwVG9FeWUodl90ZXh0dXJlQ29vcmRpbmF0ZXMgKyB2ZWMyKDAuMCwgcGl4ZWxTaXplLnkpLCBkZXB0aEQpO1xcblxcXG4gICAgdmVjNCBwb3NJbkNhbWVyYUxlZnQgPSBjbGlwVG9FeWUodl90ZXh0dXJlQ29vcmRpbmF0ZXMgLSB2ZWMyKHBpeGVsU2l6ZS54LCAwLjApLCBkZXB0aEwpO1xcblxcXG4gICAgdmVjNCBwb3NJbkNhbWVyYVJpZ2h0ID0gY2xpcFRvRXllKHZfdGV4dHVyZUNvb3JkaW5hdGVzICsgdmVjMihwaXhlbFNpemUueCwgMC4wKSwgZGVwdGhSKTtcXG5cXFxuXFxuXFxcbiAgICB2ZWMzIHVwID0gcG9zSW5DYW1lcmEueHl6IC0gcG9zSW5DYW1lcmFVcC54eXo7XFxuXFxcbiAgICB2ZWMzIGRvd24gPSBwb3NJbkNhbWVyYURvd24ueHl6IC0gcG9zSW5DYW1lcmEueHl6O1xcblxcXG4gICAgdmVjMyBsZWZ0ID0gcG9zSW5DYW1lcmEueHl6IC0gcG9zSW5DYW1lcmFMZWZ0Lnh5ejtcXG5cXFxuICAgIHZlYzMgcmlnaHQgPSBwb3NJbkNhbWVyYVJpZ2h0Lnh5eiAtIHBvc0luQ2FtZXJhLnh5ejtcXG5cXFxuXFxuXFxcbiAgICB2ZWMzIERYID0gbGVuZ3RoKGxlZnQpIDwgbGVuZ3RoKHJpZ2h0KSA/IGxlZnQgOiByaWdodDtcXG5cXFxuICAgIHZlYzMgRFkgPSBsZW5ndGgodXApIDwgbGVuZ3RoKGRvd24pID8gdXAgOiBkb3duO1xcblxcXG5cXG5cXFxuICAgIHJldHVybiBub3JtYWxpemUoY3Jvc3MoRFksIERYKSk7XFxuXFxcbn1cXG5cXFxuXFxuXFxcbnZvaWQgbWFpbih2b2lkKVxcblxcXG57XFxuXFxcbiAgICBmbG9hdCBkZXB0aCA9IGN6bV9yZWFkRGVwdGgoZGVwdGhUZXh0dXJlLCB2X3RleHR1cmVDb29yZGluYXRlcyk7XFxuXFxcbiAgICB2ZWM0IHBvc0luQ2FtZXJhID0gY2xpcFRvRXllKHZfdGV4dHVyZUNvb3JkaW5hdGVzLCBkZXB0aCk7XFxuXFxcblxcblxcXG4gICAgaWYgKHBvc0luQ2FtZXJhLnogPiBmcnVzdHVtTGVuZ3RoKVxcblxcXG4gICAge1xcblxcXG4gICAgICAgIGdsX0ZyYWdDb2xvciA9IHZlYzQoMS4wKTtcXG5cXFxuICAgICAgICByZXR1cm47XFxuXFxcbiAgICB9XFxuXFxcblxcblxcXG4gICAgdmVjMiBwaXhlbFNpemUgPSBjem1fcGl4ZWxSYXRpbyAvIGN6bV92aWV3cG9ydC56dztcXG5cXFxuICAgIGZsb2F0IGRlcHRoVSA9IGN6bV9yZWFkRGVwdGgoZGVwdGhUZXh0dXJlLCB2X3RleHR1cmVDb29yZGluYXRlcyAtIHZlYzIoMC4wLCBwaXhlbFNpemUueSkpO1xcblxcXG4gICAgZmxvYXQgZGVwdGhEID0gY3ptX3JlYWREZXB0aChkZXB0aFRleHR1cmUsIHZfdGV4dHVyZUNvb3JkaW5hdGVzICsgdmVjMigwLjAsIHBpeGVsU2l6ZS55KSk7XFxuXFxcbiAgICBmbG9hdCBkZXB0aEwgPSBjem1fcmVhZERlcHRoKGRlcHRoVGV4dHVyZSwgdl90ZXh0dXJlQ29vcmRpbmF0ZXMgLSB2ZWMyKHBpeGVsU2l6ZS54LCAwLjApKTtcXG5cXFxuICAgIGZsb2F0IGRlcHRoUiA9IGN6bV9yZWFkRGVwdGgoZGVwdGhUZXh0dXJlLCB2X3RleHR1cmVDb29yZGluYXRlcyArIHZlYzIocGl4ZWxTaXplLngsIDAuMCkpO1xcblxcXG4gICAgdmVjMyBub3JtYWxJbkNhbWVyYSA9IGdldE5vcm1hbFhFZGdlKHBvc0luQ2FtZXJhLnh5eiwgZGVwdGhVLCBkZXB0aEQsIGRlcHRoTCwgZGVwdGhSLCBwaXhlbFNpemUpO1xcblxcXG5cXG5cXFxuICAgIGZsb2F0IGFvID0gMC4wO1xcblxcXG4gICAgdmVjMiBzYW1wbGVEaXJlY3Rpb24gPSB2ZWMyKDEuMCwgMC4wKTtcXG5cXFxuICAgIGZsb2F0IGdhcEFuZ2xlID0gOTAuMCAqIGN6bV9yYWRpYW5zUGVyRGVncmVlO1xcblxcXG5cXG5cXFxuICAgIC8vIFJhbmRvbU5vaXNlXFxuXFxcbiAgICBmbG9hdCByYW5kb21WYWwgPSB0ZXh0dXJlMkQocmFuZG9tVGV4dHVyZSwgdl90ZXh0dXJlQ29vcmRpbmF0ZXMpLng7XFxuXFxcblxcblxcXG4gICAgLy9Mb29wIGZvciBlYWNoIGRpcmVjdGlvblxcblxcXG4gICAgZm9yIChpbnQgaSA9IDA7IGkgPCA0OyBpKyspXFxuXFxcbiAgICB7XFxuXFxcbiAgICAgICAgZmxvYXQgbmV3R2FwQW5nbGUgPSBnYXBBbmdsZSAqIChmbG9hdChpKSArIHJhbmRvbVZhbCk7XFxuXFxcbiAgICAgICAgZmxvYXQgY29zVmFsID0gY29zKG5ld0dhcEFuZ2xlKTtcXG5cXFxuICAgICAgICBmbG9hdCBzaW5WYWwgPSBzaW4obmV3R2FwQW5nbGUpO1xcblxcXG5cXG5cXFxuICAgICAgICAvL1JvdGF0ZSBTYW1wbGluZyBEaXJlY3Rpb25cXG5cXFxuICAgICAgICB2ZWMyIHJvdGF0ZWRTYW1wbGVEaXJlY3Rpb24gPSB2ZWMyKGNvc1ZhbCAqIHNhbXBsZURpcmVjdGlvbi54IC0gc2luVmFsICogc2FtcGxlRGlyZWN0aW9uLnksIHNpblZhbCAqIHNhbXBsZURpcmVjdGlvbi54ICsgY29zVmFsICogc2FtcGxlRGlyZWN0aW9uLnkpO1xcblxcXG4gICAgICAgIGZsb2F0IGxvY2FsQU8gPSAwLjA7XFxuXFxcbiAgICAgICAgZmxvYXQgbG9jYWxTdGVwU2l6ZSA9IHN0ZXBTaXplO1xcblxcXG5cXG5cXFxuICAgICAgICAvL0xvb3AgZm9yIGVhY2ggc3RlcFxcblxcXG4gICAgICAgIGZvciAoaW50IGogPSAwOyBqIDwgNjsgaisrKVxcblxcXG4gICAgICAgIHtcXG5cXFxuICAgICAgICAgICAgdmVjMiBuZXdDb29yZHMgPSB2X3RleHR1cmVDb29yZGluYXRlcyArIHJvdGF0ZWRTYW1wbGVEaXJlY3Rpb24gKiBsb2NhbFN0ZXBTaXplICogcGl4ZWxTaXplO1xcblxcXG5cXG5cXFxuICAgICAgICAgICAgLy9FeGNlcHRpb24gSGFuZGxpbmdcXG5cXFxuICAgICAgICAgICAgaWYobmV3Q29vcmRzLnggPiAxLjAgfHwgbmV3Q29vcmRzLnkgPiAxLjAgfHwgbmV3Q29vcmRzLnggPCAwLjAgfHwgbmV3Q29vcmRzLnkgPCAwLjApXFxuXFxcbiAgICAgICAgICAgIHtcXG5cXFxuICAgICAgICAgICAgICAgIGJyZWFrO1xcblxcXG4gICAgICAgICAgICB9XFxuXFxcblxcblxcXG4gICAgICAgICAgICBmbG9hdCBzdGVwRGVwdGhJbmZvID0gY3ptX3JlYWREZXB0aChkZXB0aFRleHR1cmUsIG5ld0Nvb3Jkcyk7XFxuXFxcbiAgICAgICAgICAgIHZlYzQgc3RlcFBvc0luQ2FtZXJhID0gY2xpcFRvRXllKG5ld0Nvb3Jkcywgc3RlcERlcHRoSW5mbyk7XFxuXFxcbiAgICAgICAgICAgIHZlYzMgZGlmZlZlYyA9IHN0ZXBQb3NJbkNhbWVyYS54eXogLSBwb3NJbkNhbWVyYS54eXo7XFxuXFxcbiAgICAgICAgICAgIGZsb2F0IGxlbiA9IGxlbmd0aChkaWZmVmVjKTtcXG5cXFxuXFxuXFxcbiAgICAgICAgICAgIGlmIChsZW4gPiBsZW5ndGhDYXApXFxuXFxcbiAgICAgICAgICAgIHtcXG5cXFxuICAgICAgICAgICAgICAgIGJyZWFrO1xcblxcXG4gICAgICAgICAgICB9XFxuXFxcblxcblxcXG4gICAgICAgICAgICBmbG9hdCBkb3RWYWwgPSBjbGFtcChkb3Qobm9ybWFsSW5DYW1lcmEsIG5vcm1hbGl6ZShkaWZmVmVjKSksIDAuMCwgMS4wICk7XFxuXFxcbiAgICAgICAgICAgIGZsb2F0IHdlaWdodCA9IGxlbiAvIGxlbmd0aENhcDtcXG5cXFxuICAgICAgICAgICAgd2VpZ2h0ID0gMS4wIC0gd2VpZ2h0ICogd2VpZ2h0O1xcblxcXG5cXG5cXFxuICAgICAgICAgICAgaWYgKGRvdFZhbCA8IGJpYXMpXFxuXFxcbiAgICAgICAgICAgIHtcXG5cXFxuICAgICAgICAgICAgICAgIGRvdFZhbCA9IDAuMDtcXG5cXFxuICAgICAgICAgICAgfVxcblxcXG5cXG5cXFxuICAgICAgICAgICAgbG9jYWxBTyA9IG1heChsb2NhbEFPLCBkb3RWYWwgKiB3ZWlnaHQpO1xcblxcXG4gICAgICAgICAgICBsb2NhbFN0ZXBTaXplICs9IHN0ZXBTaXplO1xcblxcXG4gICAgICAgIH1cXG5cXFxuICAgICAgICBhbyArPSBsb2NhbEFPO1xcblxcXG4gICAgfVxcblxcXG5cXG5cXFxuICAgIGFvIC89IDQuMDtcXG5cXFxuICAgIGFvID0gMS4wIC0gY2xhbXAoYW8sIDAuMCwgMS4wKTtcXG5cXFxuICAgIGFvID0gcG93KGFvLCBpbnRlbnNpdHkpO1xcblxcXG4gICAgZ2xfRnJhZ0NvbG9yID0gdmVjNCh2ZWMzKGFvKSwgMS4wKTtcXG5cXFxufVxcblxcXG5cIjtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///11968\n')},36756:function(__unused_webpack___webpack_module__,__webpack_exports__){eval('//This file is automatically rebuilt by the Cesium build process.\n/* harmony default export */ __webpack_exports__["Z"] = ("uniform sampler2D colorTexture;\\n\\\nuniform sampler2D ambientOcclusionTexture;\\n\\\nuniform bool ambientOcclusionOnly;\\n\\\nvarying vec2 v_textureCoordinates;\\n\\\n\\n\\\nvoid main(void)\\n\\\n{\\n\\\n    vec3 color = texture2D(colorTexture, v_textureCoordinates).rgb;\\n\\\n    vec3 ao = texture2D(ambientOcclusionTexture, v_textureCoordinates).rgb;\\n\\\n    gl_FragColor.rgb = ambientOcclusionOnly ? ao : ao * color;\\n\\\n}\\n\\\n");\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMzY3NTYuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQSx5REFBZSxnQ0FBZ0M7QUFDL0MsMENBQTBDO0FBQzFDLGtDQUFrQztBQUNsQyxrQ0FBa0M7QUFDbEM7QUFDQTtBQUNBLENBQUM7QUFDRCxtRUFBbUU7QUFDbkUsMkVBQTJFO0FBQzNFLDhEQUE4RDtBQUM5RCxDQUFDO0FBQ0QsQ0FBQyxFQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdnVlMy13ZWJwYWNrNS8uL25vZGVfbW9kdWxlcy9jZXNpdW0vU291cmNlL1NoYWRlcnMvUG9zdFByb2Nlc3NTdGFnZXMvQW1iaWVudE9jY2x1c2lvbk1vZHVsYXRlLmpzPzhjNmQiXSwic291cmNlc0NvbnRlbnQiOlsiLy9UaGlzIGZpbGUgaXMgYXV0b21hdGljYWxseSByZWJ1aWx0IGJ5IHRoZSBDZXNpdW0gYnVpbGQgcHJvY2Vzcy5cbmV4cG9ydCBkZWZhdWx0IFwidW5pZm9ybSBzYW1wbGVyMkQgY29sb3JUZXh0dXJlO1xcblxcXG51bmlmb3JtIHNhbXBsZXIyRCBhbWJpZW50T2NjbHVzaW9uVGV4dHVyZTtcXG5cXFxudW5pZm9ybSBib29sIGFtYmllbnRPY2NsdXNpb25Pbmx5O1xcblxcXG52YXJ5aW5nIHZlYzIgdl90ZXh0dXJlQ29vcmRpbmF0ZXM7XFxuXFxcblxcblxcXG52b2lkIG1haW4odm9pZClcXG5cXFxue1xcblxcXG4gICAgdmVjMyBjb2xvciA9IHRleHR1cmUyRChjb2xvclRleHR1cmUsIHZfdGV4dHVyZUNvb3JkaW5hdGVzKS5yZ2I7XFxuXFxcbiAgICB2ZWMzIGFvID0gdGV4dHVyZTJEKGFtYmllbnRPY2NsdXNpb25UZXh0dXJlLCB2X3RleHR1cmVDb29yZGluYXRlcykucmdiO1xcblxcXG4gICAgZ2xfRnJhZ0NvbG9yLnJnYiA9IGFtYmllbnRPY2NsdXNpb25Pbmx5ID8gYW8gOiBhbyAqIGNvbG9yO1xcblxcXG59XFxuXFxcblwiO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///36756\n')},92812:function(__unused_webpack___webpack_module__,__webpack_exports__){eval('//This file is automatically rebuilt by the Cesium build process.\n/* harmony default export */ __webpack_exports__["Z"] = ("uniform sampler2D colorTexture;\\n\\\nuniform float gradations;\\n\\\n\\n\\\nvarying vec2 v_textureCoordinates;\\n\\\n\\n\\\nvoid main(void)\\n\\\n{\\n\\\n    vec3 rgb = texture2D(colorTexture, v_textureCoordinates).rgb;\\n\\\n#ifdef CZM_SELECTED_FEATURE\\n\\\n    if (czm_selected()) {\\n\\\n        gl_FragColor = vec4(rgb, 1.0);\\n\\\n        return;\\n\\\n    }\\n\\\n#endif\\n\\\n    float luminance = czm_luminance(rgb);\\n\\\n    float darkness = luminance * gradations;\\n\\\n    darkness = (darkness - fract(darkness)) / gradations;\\n\\\n    gl_FragColor = vec4(vec3(darkness), 1.0);\\n\\\n}\\n\\\n");\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiOTI4MTIuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQSx5REFBZSxnQ0FBZ0M7QUFDL0MseUJBQXlCO0FBQ3pCO0FBQ0Esa0NBQWtDO0FBQ2xDO0FBQ0E7QUFDQSxDQUFDO0FBQ0QsaUVBQWlFO0FBQ2pFO0FBQ0EseUJBQXlCO0FBQ3pCLHNDQUFzQztBQUN0QyxlQUFlO0FBQ2YsS0FBSztBQUNMO0FBQ0EseUNBQXlDO0FBQ3pDLDRDQUE0QztBQUM1Qyx5REFBeUQ7QUFDekQsNkNBQTZDO0FBQzdDLENBQUM7QUFDRCxDQUFDLEVBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly92dWUzLXdlYnBhY2s1Ly4vbm9kZV9tb2R1bGVzL2Nlc2l1bS9Tb3VyY2UvU2hhZGVycy9Qb3N0UHJvY2Vzc1N0YWdlcy9CbGFja0FuZFdoaXRlLmpzPzY4NTciXSwic291cmNlc0NvbnRlbnQiOlsiLy9UaGlzIGZpbGUgaXMgYXV0b21hdGljYWxseSByZWJ1aWx0IGJ5IHRoZSBDZXNpdW0gYnVpbGQgcHJvY2Vzcy5cbmV4cG9ydCBkZWZhdWx0IFwidW5pZm9ybSBzYW1wbGVyMkQgY29sb3JUZXh0dXJlO1xcblxcXG51bmlmb3JtIGZsb2F0IGdyYWRhdGlvbnM7XFxuXFxcblxcblxcXG52YXJ5aW5nIHZlYzIgdl90ZXh0dXJlQ29vcmRpbmF0ZXM7XFxuXFxcblxcblxcXG52b2lkIG1haW4odm9pZClcXG5cXFxue1xcblxcXG4gICAgdmVjMyByZ2IgPSB0ZXh0dXJlMkQoY29sb3JUZXh0dXJlLCB2X3RleHR1cmVDb29yZGluYXRlcykucmdiO1xcblxcXG4jaWZkZWYgQ1pNX1NFTEVDVEVEX0ZFQVRVUkVcXG5cXFxuICAgIGlmIChjem1fc2VsZWN0ZWQoKSkge1xcblxcXG4gICAgICAgIGdsX0ZyYWdDb2xvciA9IHZlYzQocmdiLCAxLjApO1xcblxcXG4gICAgICAgIHJldHVybjtcXG5cXFxuICAgIH1cXG5cXFxuI2VuZGlmXFxuXFxcbiAgICBmbG9hdCBsdW1pbmFuY2UgPSBjem1fbHVtaW5hbmNlKHJnYik7XFxuXFxcbiAgICBmbG9hdCBkYXJrbmVzcyA9IGx1bWluYW5jZSAqIGdyYWRhdGlvbnM7XFxuXFxcbiAgICBkYXJrbmVzcyA9IChkYXJrbmVzcyAtIGZyYWN0KGRhcmtuZXNzKSkgLyBncmFkYXRpb25zO1xcblxcXG4gICAgZ2xfRnJhZ0NvbG9yID0gdmVjNCh2ZWMzKGRhcmtuZXNzKSwgMS4wKTtcXG5cXFxufVxcblxcXG5cIjtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///92812\n')},37386:function(__unused_webpack___webpack_module__,__webpack_exports__){eval('//This file is automatically rebuilt by the Cesium build process.\n/* harmony default export */ __webpack_exports__["Z"] = ("uniform sampler2D colorTexture;\\n\\\nuniform sampler2D bloomTexture;\\n\\\nuniform bool glowOnly;\\n\\\n\\n\\\nvarying vec2 v_textureCoordinates;\\n\\\n\\n\\\nvoid main(void)\\n\\\n{\\n\\\n    vec4 color = texture2D(colorTexture, v_textureCoordinates);\\n\\\n\\n\\\n#ifdef CZM_SELECTED_FEATURE\\n\\\n    if (czm_selected()) {\\n\\\n        gl_FragColor = color;\\n\\\n        return;\\n\\\n    }\\n\\\n#endif\\n\\\n\\n\\\n    vec4 bloom = texture2D(bloomTexture, v_textureCoordinates);\\n\\\n    gl_FragColor = glowOnly ? bloom : bloom + color;\\n\\\n}\\n\\\n");\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMzczODYuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQSx5REFBZSxnQ0FBZ0M7QUFDL0MsK0JBQStCO0FBQy9CLHNCQUFzQjtBQUN0QjtBQUNBLGtDQUFrQztBQUNsQztBQUNBO0FBQ0EsQ0FBQztBQUNELCtEQUErRDtBQUMvRDtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCLDZCQUE2QjtBQUM3QixlQUFlO0FBQ2YsS0FBSztBQUNMO0FBQ0E7QUFDQSwrREFBK0Q7QUFDL0Qsb0RBQW9EO0FBQ3BELENBQUM7QUFDRCxDQUFDLEVBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly92dWUzLXdlYnBhY2s1Ly4vbm9kZV9tb2R1bGVzL2Nlc2l1bS9Tb3VyY2UvU2hhZGVycy9Qb3N0UHJvY2Vzc1N0YWdlcy9CbG9vbUNvbXBvc2l0ZS5qcz9mMjNmIl0sInNvdXJjZXNDb250ZW50IjpbIi8vVGhpcyBmaWxlIGlzIGF1dG9tYXRpY2FsbHkgcmVidWlsdCBieSB0aGUgQ2VzaXVtIGJ1aWxkIHByb2Nlc3MuXG5leHBvcnQgZGVmYXVsdCBcInVuaWZvcm0gc2FtcGxlcjJEIGNvbG9yVGV4dHVyZTtcXG5cXFxudW5pZm9ybSBzYW1wbGVyMkQgYmxvb21UZXh0dXJlO1xcblxcXG51bmlmb3JtIGJvb2wgZ2xvd09ubHk7XFxuXFxcblxcblxcXG52YXJ5aW5nIHZlYzIgdl90ZXh0dXJlQ29vcmRpbmF0ZXM7XFxuXFxcblxcblxcXG52b2lkIG1haW4odm9pZClcXG5cXFxue1xcblxcXG4gICAgdmVjNCBjb2xvciA9IHRleHR1cmUyRChjb2xvclRleHR1cmUsIHZfdGV4dHVyZUNvb3JkaW5hdGVzKTtcXG5cXFxuXFxuXFxcbiNpZmRlZiBDWk1fU0VMRUNURURfRkVBVFVSRVxcblxcXG4gICAgaWYgKGN6bV9zZWxlY3RlZCgpKSB7XFxuXFxcbiAgICAgICAgZ2xfRnJhZ0NvbG9yID0gY29sb3I7XFxuXFxcbiAgICAgICAgcmV0dXJuO1xcblxcXG4gICAgfVxcblxcXG4jZW5kaWZcXG5cXFxuXFxuXFxcbiAgICB2ZWM0IGJsb29tID0gdGV4dHVyZTJEKGJsb29tVGV4dHVyZSwgdl90ZXh0dXJlQ29vcmRpbmF0ZXMpO1xcblxcXG4gICAgZ2xfRnJhZ0NvbG9yID0gZ2xvd09ubHkgPyBibG9vbSA6IGJsb29tICsgY29sb3I7XFxuXFxcbn1cXG5cXFxuXCI7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///37386\n')},87641:function(__unused_webpack___webpack_module__,__webpack_exports__){eval('//This file is automatically rebuilt by the Cesium build process.\n/* harmony default export */ __webpack_exports__["Z"] = ("uniform sampler2D colorTexture;\\n\\\n\\n\\\nuniform float avgLuminance;\\n\\\nuniform float threshold;\\n\\\nuniform float offset;\\n\\\n\\n\\\nvarying vec2 v_textureCoordinates;\\n\\\n\\n\\\nfloat key(float avg)\\n\\\n{\\n\\\n    float guess = 1.5 - (1.5 / (avg * 0.1 + 1.0));\\n\\\n    return max(0.0, guess) + 0.1;\\n\\\n}\\n\\\n\\n\\\n// See section 9. \\"The bright-pass filter\\" of Realtime HDR Rendering\\n\\\n// http://www.cg.tuwien.ac.at/research/publications/2007/Luksch_2007_RHR/Luksch_2007_RHR-RealtimeHDR%20.pdf\\n\\\n\\n\\\nvoid main()\\n\\\n{\\n\\\n    vec4 color = texture2D(colorTexture, v_textureCoordinates);\\n\\\n    vec3 xyz = czm_RGBToXYZ(color.rgb);\\n\\\n    float luminance = xyz.r;\\n\\\n\\n\\\n    float scaledLum = key(avgLuminance) * luminance / avgLuminance;\\n\\\n    float brightLum = max(scaledLum - threshold, 0.0);\\n\\\n    float brightness = brightLum / (offset + brightLum);\\n\\\n\\n\\\n    xyz.r = brightness;\\n\\\n    gl_FragColor = vec4(czm_XYZToRGB(xyz), 1.0);\\n\\\n}\\n\\\n");\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiODc2NDEuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQSx5REFBZSxnQ0FBZ0M7QUFDL0M7QUFDQSwyQkFBMkI7QUFDM0Isd0JBQXdCO0FBQ3hCLHFCQUFxQjtBQUNyQjtBQUNBLGtDQUFrQztBQUNsQztBQUNBO0FBQ0EsQ0FBQztBQUNELGtEQUFrRDtBQUNsRCxpQ0FBaUM7QUFDakMsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0QsK0RBQStEO0FBQy9ELHVDQUF1QztBQUN2Qyw0QkFBNEI7QUFDNUI7QUFDQSxtRUFBbUU7QUFDbkUsc0RBQXNEO0FBQ3RELHdEQUF3RDtBQUN4RDtBQUNBLHVCQUF1QjtBQUN2QixnREFBZ0Q7QUFDaEQsQ0FBQztBQUNELENBQUMsRUFBQyIsInNvdXJjZXMiOlsid2VicGFjazovL3Z1ZTMtd2VicGFjazUvLi9ub2RlX21vZHVsZXMvY2VzaXVtL1NvdXJjZS9TaGFkZXJzL1Bvc3RQcm9jZXNzU3RhZ2VzL0JyaWdodFBhc3MuanM/NzIxZSJdLCJzb3VyY2VzQ29udGVudCI6WyIvL1RoaXMgZmlsZSBpcyBhdXRvbWF0aWNhbGx5IHJlYnVpbHQgYnkgdGhlIENlc2l1bSBidWlsZCBwcm9jZXNzLlxuZXhwb3J0IGRlZmF1bHQgXCJ1bmlmb3JtIHNhbXBsZXIyRCBjb2xvclRleHR1cmU7XFxuXFxcblxcblxcXG51bmlmb3JtIGZsb2F0IGF2Z0x1bWluYW5jZTtcXG5cXFxudW5pZm9ybSBmbG9hdCB0aHJlc2hvbGQ7XFxuXFxcbnVuaWZvcm0gZmxvYXQgb2Zmc2V0O1xcblxcXG5cXG5cXFxudmFyeWluZyB2ZWMyIHZfdGV4dHVyZUNvb3JkaW5hdGVzO1xcblxcXG5cXG5cXFxuZmxvYXQga2V5KGZsb2F0IGF2ZylcXG5cXFxue1xcblxcXG4gICAgZmxvYXQgZ3Vlc3MgPSAxLjUgLSAoMS41IC8gKGF2ZyAqIDAuMSArIDEuMCkpO1xcblxcXG4gICAgcmV0dXJuIG1heCgwLjAsIGd1ZXNzKSArIDAuMTtcXG5cXFxufVxcblxcXG5cXG5cXFxuLy8gU2VlIHNlY3Rpb24gOS4gXFxcIlRoZSBicmlnaHQtcGFzcyBmaWx0ZXJcXFwiIG9mIFJlYWx0aW1lIEhEUiBSZW5kZXJpbmdcXG5cXFxuLy8gaHR0cDovL3d3dy5jZy50dXdpZW4uYWMuYXQvcmVzZWFyY2gvcHVibGljYXRpb25zLzIwMDcvTHVrc2NoXzIwMDdfUkhSL0x1a3NjaF8yMDA3X1JIUi1SZWFsdGltZUhEUiUyMC5wZGZcXG5cXFxuXFxuXFxcbnZvaWQgbWFpbigpXFxuXFxcbntcXG5cXFxuICAgIHZlYzQgY29sb3IgPSB0ZXh0dXJlMkQoY29sb3JUZXh0dXJlLCB2X3RleHR1cmVDb29yZGluYXRlcyk7XFxuXFxcbiAgICB2ZWMzIHh5eiA9IGN6bV9SR0JUb1hZWihjb2xvci5yZ2IpO1xcblxcXG4gICAgZmxvYXQgbHVtaW5hbmNlID0geHl6LnI7XFxuXFxcblxcblxcXG4gICAgZmxvYXQgc2NhbGVkTHVtID0ga2V5KGF2Z0x1bWluYW5jZSkgKiBsdW1pbmFuY2UgLyBhdmdMdW1pbmFuY2U7XFxuXFxcbiAgICBmbG9hdCBicmlnaHRMdW0gPSBtYXgoc2NhbGVkTHVtIC0gdGhyZXNob2xkLCAwLjApO1xcblxcXG4gICAgZmxvYXQgYnJpZ2h0bmVzcyA9IGJyaWdodEx1bSAvIChvZmZzZXQgKyBicmlnaHRMdW0pO1xcblxcXG5cXG5cXFxuICAgIHh5ei5yID0gYnJpZ2h0bmVzcztcXG5cXFxuICAgIGdsX0ZyYWdDb2xvciA9IHZlYzQoY3ptX1hZWlRvUkdCKHh5eiksIDEuMCk7XFxuXFxcbn1cXG5cXFxuXCI7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///87641\n')},60593:function(__unused_webpack___webpack_module__,__webpack_exports__){eval('//This file is automatically rebuilt by the Cesium build process.\n/* harmony default export */ __webpack_exports__["Z"] = ("uniform sampler2D colorTexture;\\n\\\nuniform float brightness;\\n\\\n\\n\\\nvarying vec2 v_textureCoordinates;\\n\\\n\\n\\\nvoid main(void)\\n\\\n{\\n\\\n    vec3 rgb = texture2D(colorTexture, v_textureCoordinates).rgb;\\n\\\n    vec3 target = vec3(0.0);\\n\\\n    gl_FragColor = vec4(mix(target, rgb, brightness), 1.0);\\n\\\n}\\n\\\n");\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNjA1OTMuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQSx5REFBZSxnQ0FBZ0M7QUFDL0MseUJBQXlCO0FBQ3pCO0FBQ0Esa0NBQWtDO0FBQ2xDO0FBQ0E7QUFDQSxDQUFDO0FBQ0QsaUVBQWlFO0FBQ2pFLDRCQUE0QjtBQUM1QiwyREFBMkQ7QUFDM0QsQ0FBQztBQUNELENBQUMsRUFBQyIsInNvdXJjZXMiOlsid2VicGFjazovL3Z1ZTMtd2VicGFjazUvLi9ub2RlX21vZHVsZXMvY2VzaXVtL1NvdXJjZS9TaGFkZXJzL1Bvc3RQcm9jZXNzU3RhZ2VzL0JyaWdodG5lc3MuanM/MWQzMSJdLCJzb3VyY2VzQ29udGVudCI6WyIvL1RoaXMgZmlsZSBpcyBhdXRvbWF0aWNhbGx5IHJlYnVpbHQgYnkgdGhlIENlc2l1bSBidWlsZCBwcm9jZXNzLlxuZXhwb3J0IGRlZmF1bHQgXCJ1bmlmb3JtIHNhbXBsZXIyRCBjb2xvclRleHR1cmU7XFxuXFxcbnVuaWZvcm0gZmxvYXQgYnJpZ2h0bmVzcztcXG5cXFxuXFxuXFxcbnZhcnlpbmcgdmVjMiB2X3RleHR1cmVDb29yZGluYXRlcztcXG5cXFxuXFxuXFxcbnZvaWQgbWFpbih2b2lkKVxcblxcXG57XFxuXFxcbiAgICB2ZWMzIHJnYiA9IHRleHR1cmUyRChjb2xvclRleHR1cmUsIHZfdGV4dHVyZUNvb3JkaW5hdGVzKS5yZ2I7XFxuXFxcbiAgICB2ZWMzIHRhcmdldCA9IHZlYzMoMC4wKTtcXG5cXFxuICAgIGdsX0ZyYWdDb2xvciA9IHZlYzQobWl4KHRhcmdldCwgcmdiLCBicmlnaHRuZXNzKSwgMS4wKTtcXG5cXFxufVxcblxcXG5cIjtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///60593\n')},40643:function(__unused_webpack___webpack_module__,__webpack_exports__){eval('//This file is automatically rebuilt by the Cesium build process.\n/* harmony default export */ __webpack_exports__["Z"] = ("uniform sampler2D colorTexture;\\n\\\n\\n\\\n#ifdef DEBUG_SHOW_DEPTH\\n\\\nuniform sampler2D u_packedTranslucentDepth;\\n\\\n#endif\\n\\\n\\n\\\nvarying vec2 v_textureCoordinates;\\n\\\n\\n\\\nvoid main()\\n\\\n{\\n\\\n#ifdef DEBUG_SHOW_DEPTH\\n\\\n    if (v_textureCoordinates.x < 0.5)\\n\\\n    {\\n\\\n        gl_FragColor.rgb = vec3(czm_unpackDepth(texture2D(u_packedTranslucentDepth, v_textureCoordinates)));\\n\\\n        gl_FragColor.a = 1.0;\\n\\\n    }\\n\\\n#else\\n\\\n    vec4 color = texture2D(colorTexture, v_textureCoordinates);\\n\\\n\\n\\\n#ifdef PICK\\n\\\n    if (color == vec4(0.0))\\n\\\n    {\\n\\\n        discard;\\n\\\n    }\\n\\\n#else\\n\\\n    // Reverse premultiplication process to get the correct composited result of the classification primitives\\n\\\n    color.rgb /= color.a;\\n\\\n#endif\\n\\\n    gl_FragColor = color;\\n\\\n#endif\\n\\\n}\\n\\\n");\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNDA2NDMuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQSx5REFBZSxnQ0FBZ0M7QUFDL0M7QUFDQTtBQUNBLDJDQUEyQztBQUMzQztBQUNBO0FBQ0Esa0NBQWtDO0FBQ2xDO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLEtBQUs7QUFDTCw0R0FBNEc7QUFDNUcsNkJBQTZCO0FBQzdCLEtBQUs7QUFDTDtBQUNBLCtEQUErRDtBQUMvRDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsZ0JBQWdCO0FBQ2hCLEtBQUs7QUFDTDtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0EsQ0FBQztBQUNELENBQUMsRUFBQyIsInNvdXJjZXMiOlsid2VicGFjazovL3Z1ZTMtd2VicGFjazUvLi9ub2RlX21vZHVsZXMvY2VzaXVtL1NvdXJjZS9TaGFkZXJzL1Bvc3RQcm9jZXNzU3RhZ2VzL0NvbXBvc2l0ZVRyYW5zbHVjZW50Q2xhc3NpZmljYXRpb24uanM/Nzk3YyJdLCJzb3VyY2VzQ29udGVudCI6WyIvL1RoaXMgZmlsZSBpcyBhdXRvbWF0aWNhbGx5IHJlYnVpbHQgYnkgdGhlIENlc2l1bSBidWlsZCBwcm9jZXNzLlxuZXhwb3J0IGRlZmF1bHQgXCJ1bmlmb3JtIHNhbXBsZXIyRCBjb2xvclRleHR1cmU7XFxuXFxcblxcblxcXG4jaWZkZWYgREVCVUdfU0hPV19ERVBUSFxcblxcXG51bmlmb3JtIHNhbXBsZXIyRCB1X3BhY2tlZFRyYW5zbHVjZW50RGVwdGg7XFxuXFxcbiNlbmRpZlxcblxcXG5cXG5cXFxudmFyeWluZyB2ZWMyIHZfdGV4dHVyZUNvb3JkaW5hdGVzO1xcblxcXG5cXG5cXFxudm9pZCBtYWluKClcXG5cXFxue1xcblxcXG4jaWZkZWYgREVCVUdfU0hPV19ERVBUSFxcblxcXG4gICAgaWYgKHZfdGV4dHVyZUNvb3JkaW5hdGVzLnggPCAwLjUpXFxuXFxcbiAgICB7XFxuXFxcbiAgICAgICAgZ2xfRnJhZ0NvbG9yLnJnYiA9IHZlYzMoY3ptX3VucGFja0RlcHRoKHRleHR1cmUyRCh1X3BhY2tlZFRyYW5zbHVjZW50RGVwdGgsIHZfdGV4dHVyZUNvb3JkaW5hdGVzKSkpO1xcblxcXG4gICAgICAgIGdsX0ZyYWdDb2xvci5hID0gMS4wO1xcblxcXG4gICAgfVxcblxcXG4jZWxzZVxcblxcXG4gICAgdmVjNCBjb2xvciA9IHRleHR1cmUyRChjb2xvclRleHR1cmUsIHZfdGV4dHVyZUNvb3JkaW5hdGVzKTtcXG5cXFxuXFxuXFxcbiNpZmRlZiBQSUNLXFxuXFxcbiAgICBpZiAoY29sb3IgPT0gdmVjNCgwLjApKVxcblxcXG4gICAge1xcblxcXG4gICAgICAgIGRpc2NhcmQ7XFxuXFxcbiAgICB9XFxuXFxcbiNlbHNlXFxuXFxcbiAgICAvLyBSZXZlcnNlIHByZW11bHRpcGxpY2F0aW9uIHByb2Nlc3MgdG8gZ2V0IHRoZSBjb3JyZWN0IGNvbXBvc2l0ZWQgcmVzdWx0IG9mIHRoZSBjbGFzc2lmaWNhdGlvbiBwcmltaXRpdmVzXFxuXFxcbiAgICBjb2xvci5yZ2IgLz0gY29sb3IuYTtcXG5cXFxuI2VuZGlmXFxuXFxcbiAgICBnbF9GcmFnQ29sb3IgPSBjb2xvcjtcXG5cXFxuI2VuZGlmXFxuXFxcbn1cXG5cXFxuXCI7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///40643\n')},82445:function(__unused_webpack___webpack_module__,__webpack_exports__){eval('//This file is automatically rebuilt by the Cesium build process.\n/* harmony default export */ __webpack_exports__["Z"] = ("uniform sampler2D colorTexture;\\n\\\nuniform float contrast;\\n\\\nuniform float brightness;\\n\\\n\\n\\\nvarying vec2 v_textureCoordinates;\\n\\\n\\n\\\nvoid main(void)\\n\\\n{\\n\\\n    vec3 sceneColor = texture2D(colorTexture, v_textureCoordinates).xyz;\\n\\\n    sceneColor = czm_RGBToHSB(sceneColor);\\n\\\n    sceneColor.z += brightness;\\n\\\n    sceneColor = czm_HSBToRGB(sceneColor);\\n\\\n\\n\\\n    float factor = (259.0 * (contrast + 255.0)) / (255.0 * (259.0 - contrast));\\n\\\n    sceneColor = factor * (sceneColor - vec3(0.5)) + vec3(0.5);\\n\\\n    gl_FragColor = vec4(sceneColor, 1.0);\\n\\\n}\\n\\\n");\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiODI0NDUuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQSx5REFBZSxnQ0FBZ0M7QUFDL0MsdUJBQXVCO0FBQ3ZCLHlCQUF5QjtBQUN6QjtBQUNBLGtDQUFrQztBQUNsQztBQUNBO0FBQ0EsQ0FBQztBQUNELHdFQUF3RTtBQUN4RSwwQ0FBMEM7QUFDMUMsK0JBQStCO0FBQy9CLDBDQUEwQztBQUMxQztBQUNBLCtFQUErRTtBQUMvRSwrREFBK0Q7QUFDL0QseUNBQXlDO0FBQ3pDLENBQUM7QUFDRCxDQUFDLEVBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly92dWUzLXdlYnBhY2s1Ly4vbm9kZV9tb2R1bGVzL2Nlc2l1bS9Tb3VyY2UvU2hhZGVycy9Qb3N0UHJvY2Vzc1N0YWdlcy9Db250cmFzdEJpYXMuanM/ZTcwZSJdLCJzb3VyY2VzQ29udGVudCI6WyIvL1RoaXMgZmlsZSBpcyBhdXRvbWF0aWNhbGx5IHJlYnVpbHQgYnkgdGhlIENlc2l1bSBidWlsZCBwcm9jZXNzLlxuZXhwb3J0IGRlZmF1bHQgXCJ1bmlmb3JtIHNhbXBsZXIyRCBjb2xvclRleHR1cmU7XFxuXFxcbnVuaWZvcm0gZmxvYXQgY29udHJhc3Q7XFxuXFxcbnVuaWZvcm0gZmxvYXQgYnJpZ2h0bmVzcztcXG5cXFxuXFxuXFxcbnZhcnlpbmcgdmVjMiB2X3RleHR1cmVDb29yZGluYXRlcztcXG5cXFxuXFxuXFxcbnZvaWQgbWFpbih2b2lkKVxcblxcXG57XFxuXFxcbiAgICB2ZWMzIHNjZW5lQ29sb3IgPSB0ZXh0dXJlMkQoY29sb3JUZXh0dXJlLCB2X3RleHR1cmVDb29yZGluYXRlcykueHl6O1xcblxcXG4gICAgc2NlbmVDb2xvciA9IGN6bV9SR0JUb0hTQihzY2VuZUNvbG9yKTtcXG5cXFxuICAgIHNjZW5lQ29sb3IueiArPSBicmlnaHRuZXNzO1xcblxcXG4gICAgc2NlbmVDb2xvciA9IGN6bV9IU0JUb1JHQihzY2VuZUNvbG9yKTtcXG5cXFxuXFxuXFxcbiAgICBmbG9hdCBmYWN0b3IgPSAoMjU5LjAgKiAoY29udHJhc3QgKyAyNTUuMCkpIC8gKDI1NS4wICogKDI1OS4wIC0gY29udHJhc3QpKTtcXG5cXFxuICAgIHNjZW5lQ29sb3IgPSBmYWN0b3IgKiAoc2NlbmVDb2xvciAtIHZlYzMoMC41KSkgKyB2ZWMzKDAuNSk7XFxuXFxcbiAgICBnbF9GcmFnQ29sb3IgPSB2ZWM0KHNjZW5lQ29sb3IsIDEuMCk7XFxuXFxcbn1cXG5cXFxuXCI7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///82445\n')},83890:function(__unused_webpack___webpack_module__,__webpack_exports__){eval('//This file is automatically rebuilt by the Cesium build process.\n/* harmony default export */ __webpack_exports__["Z"] = ("uniform sampler2D colorTexture;\\n\\\nuniform sampler2D blurTexture;\\n\\\nuniform sampler2D depthTexture;\\n\\\nuniform float focalDistance;\\n\\\n\\n\\\nvarying vec2 v_textureCoordinates;\\n\\\n\\n\\\nvec4 toEye(vec2 uv, float depth)\\n\\\n{\\n\\\n   vec2 xy = vec2((uv.x * 2.0 - 1.0), ((1.0 - uv.y) * 2.0 - 1.0));\\n\\\n   vec4 posInCamera = czm_inverseProjection * vec4(xy, depth, 1.0);\\n\\\n   posInCamera = posInCamera / posInCamera.w;\\n\\\n   return posInCamera;\\n\\\n}\\n\\\n\\n\\\nfloat computeDepthBlur(float depth)\\n\\\n{\\n\\\n    float f;\\n\\\n    if (depth < focalDistance)\\n\\\n    {\\n\\\n        f = (focalDistance - depth) / (focalDistance - czm_currentFrustum.x);\\n\\\n    }\\n\\\n    else\\n\\\n    {\\n\\\n        f = (depth - focalDistance) / (czm_currentFrustum.y - focalDistance);\\n\\\n        f = pow(f, 0.1);\\n\\\n    }\\n\\\n    f *= f;\\n\\\n    f = clamp(f, 0.0, 1.0);\\n\\\n    return pow(f, 0.5);\\n\\\n}\\n\\\n\\n\\\nvoid main(void)\\n\\\n{\\n\\\n    float depth = czm_readDepth(depthTexture, v_textureCoordinates);\\n\\\n    vec4 posInCamera = toEye(v_textureCoordinates, depth);\\n\\\n    float d = computeDepthBlur(-posInCamera.z);\\n\\\n    gl_FragColor = mix(texture2D(colorTexture, v_textureCoordinates), texture2D(blurTexture, v_textureCoordinates), d);\\n\\\n}\\n\\\n");\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiODM4OTAuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQSx5REFBZSxnQ0FBZ0M7QUFDL0MsOEJBQThCO0FBQzlCLCtCQUErQjtBQUMvQiw0QkFBNEI7QUFDNUI7QUFDQSxrQ0FBa0M7QUFDbEM7QUFDQTtBQUNBLENBQUM7QUFDRCxrRUFBa0U7QUFDbEUsbUVBQW1FO0FBQ25FLDZDQUE2QztBQUM3QyxzQkFBc0I7QUFDdEIsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0QsWUFBWTtBQUNaO0FBQ0EsS0FBSztBQUNMLDZFQUE2RTtBQUM3RSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0wsNkVBQTZFO0FBQzdFLHdCQUF3QjtBQUN4QixLQUFLO0FBQ0wsV0FBVztBQUNYLDJCQUEyQjtBQUMzQix1QkFBdUI7QUFDdkIsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Qsb0VBQW9FO0FBQ3BFLDBEQUEwRDtBQUMxRCwrQ0FBK0M7QUFDL0MsdUhBQXVIO0FBQ3ZILENBQUM7QUFDRCxDQUFDLEVBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly92dWUzLXdlYnBhY2s1Ly4vbm9kZV9tb2R1bGVzL2Nlc2l1bS9Tb3VyY2UvU2hhZGVycy9Qb3N0UHJvY2Vzc1N0YWdlcy9EZXB0aE9mRmllbGQuanM/ZjQzNyJdLCJzb3VyY2VzQ29udGVudCI6WyIvL1RoaXMgZmlsZSBpcyBhdXRvbWF0aWNhbGx5IHJlYnVpbHQgYnkgdGhlIENlc2l1bSBidWlsZCBwcm9jZXNzLlxuZXhwb3J0IGRlZmF1bHQgXCJ1bmlmb3JtIHNhbXBsZXIyRCBjb2xvclRleHR1cmU7XFxuXFxcbnVuaWZvcm0gc2FtcGxlcjJEIGJsdXJUZXh0dXJlO1xcblxcXG51bmlmb3JtIHNhbXBsZXIyRCBkZXB0aFRleHR1cmU7XFxuXFxcbnVuaWZvcm0gZmxvYXQgZm9jYWxEaXN0YW5jZTtcXG5cXFxuXFxuXFxcbnZhcnlpbmcgdmVjMiB2X3RleHR1cmVDb29yZGluYXRlcztcXG5cXFxuXFxuXFxcbnZlYzQgdG9FeWUodmVjMiB1diwgZmxvYXQgZGVwdGgpXFxuXFxcbntcXG5cXFxuICAgdmVjMiB4eSA9IHZlYzIoKHV2LnggKiAyLjAgLSAxLjApLCAoKDEuMCAtIHV2LnkpICogMi4wIC0gMS4wKSk7XFxuXFxcbiAgIHZlYzQgcG9zSW5DYW1lcmEgPSBjem1faW52ZXJzZVByb2plY3Rpb24gKiB2ZWM0KHh5LCBkZXB0aCwgMS4wKTtcXG5cXFxuICAgcG9zSW5DYW1lcmEgPSBwb3NJbkNhbWVyYSAvIHBvc0luQ2FtZXJhLnc7XFxuXFxcbiAgIHJldHVybiBwb3NJbkNhbWVyYTtcXG5cXFxufVxcblxcXG5cXG5cXFxuZmxvYXQgY29tcHV0ZURlcHRoQmx1cihmbG9hdCBkZXB0aClcXG5cXFxue1xcblxcXG4gICAgZmxvYXQgZjtcXG5cXFxuICAgIGlmIChkZXB0aCA8IGZvY2FsRGlzdGFuY2UpXFxuXFxcbiAgICB7XFxuXFxcbiAgICAgICAgZiA9IChmb2NhbERpc3RhbmNlIC0gZGVwdGgpIC8gKGZvY2FsRGlzdGFuY2UgLSBjem1fY3VycmVudEZydXN0dW0ueCk7XFxuXFxcbiAgICB9XFxuXFxcbiAgICBlbHNlXFxuXFxcbiAgICB7XFxuXFxcbiAgICAgICAgZiA9IChkZXB0aCAtIGZvY2FsRGlzdGFuY2UpIC8gKGN6bV9jdXJyZW50RnJ1c3R1bS55IC0gZm9jYWxEaXN0YW5jZSk7XFxuXFxcbiAgICAgICAgZiA9IHBvdyhmLCAwLjEpO1xcblxcXG4gICAgfVxcblxcXG4gICAgZiAqPSBmO1xcblxcXG4gICAgZiA9IGNsYW1wKGYsIDAuMCwgMS4wKTtcXG5cXFxuICAgIHJldHVybiBwb3coZiwgMC41KTtcXG5cXFxufVxcblxcXG5cXG5cXFxudm9pZCBtYWluKHZvaWQpXFxuXFxcbntcXG5cXFxuICAgIGZsb2F0IGRlcHRoID0gY3ptX3JlYWREZXB0aChkZXB0aFRleHR1cmUsIHZfdGV4dHVyZUNvb3JkaW5hdGVzKTtcXG5cXFxuICAgIHZlYzQgcG9zSW5DYW1lcmEgPSB0b0V5ZSh2X3RleHR1cmVDb29yZGluYXRlcywgZGVwdGgpO1xcblxcXG4gICAgZmxvYXQgZCA9IGNvbXB1dGVEZXB0aEJsdXIoLXBvc0luQ2FtZXJhLnopO1xcblxcXG4gICAgZ2xfRnJhZ0NvbG9yID0gbWl4KHRleHR1cmUyRChjb2xvclRleHR1cmUsIHZfdGV4dHVyZUNvb3JkaW5hdGVzKSwgdGV4dHVyZTJEKGJsdXJUZXh0dXJlLCB2X3RleHR1cmVDb29yZGluYXRlcyksIGQpO1xcblxcXG59XFxuXFxcblwiO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///83890\n')},39592:function(__unused_webpack___webpack_module__,__webpack_exports__){eval('//This file is automatically rebuilt by the Cesium build process.\n/* harmony default export */ __webpack_exports__["Z"] = ("uniform sampler2D depthTexture;\\n\\\n\\n\\\nvarying vec2 v_textureCoordinates;\\n\\\n\\n\\\nvoid main(void)\\n\\\n{\\n\\\n    float depth = czm_readDepth(depthTexture, v_textureCoordinates);\\n\\\n    gl_FragColor = vec4(vec3(depth), 1.0);\\n\\\n}\\n\\\n");\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMzk1OTIuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQSx5REFBZSxnQ0FBZ0M7QUFDL0M7QUFDQSxrQ0FBa0M7QUFDbEM7QUFDQTtBQUNBLENBQUM7QUFDRCxvRUFBb0U7QUFDcEUsMENBQTBDO0FBQzFDLENBQUM7QUFDRCxDQUFDLEVBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly92dWUzLXdlYnBhY2s1Ly4vbm9kZV9tb2R1bGVzL2Nlc2l1bS9Tb3VyY2UvU2hhZGVycy9Qb3N0UHJvY2Vzc1N0YWdlcy9EZXB0aFZpZXcuanM/OWY2YyJdLCJzb3VyY2VzQ29udGVudCI6WyIvL1RoaXMgZmlsZSBpcyBhdXRvbWF0aWNhbGx5IHJlYnVpbHQgYnkgdGhlIENlc2l1bSBidWlsZCBwcm9jZXNzLlxuZXhwb3J0IGRlZmF1bHQgXCJ1bmlmb3JtIHNhbXBsZXIyRCBkZXB0aFRleHR1cmU7XFxuXFxcblxcblxcXG52YXJ5aW5nIHZlYzIgdl90ZXh0dXJlQ29vcmRpbmF0ZXM7XFxuXFxcblxcblxcXG52b2lkIG1haW4odm9pZClcXG5cXFxue1xcblxcXG4gICAgZmxvYXQgZGVwdGggPSBjem1fcmVhZERlcHRoKGRlcHRoVGV4dHVyZSwgdl90ZXh0dXJlQ29vcmRpbmF0ZXMpO1xcblxcXG4gICAgZ2xfRnJhZ0NvbG9yID0gdmVjNCh2ZWMzKGRlcHRoKSwgMS4wKTtcXG5cXFxufVxcblxcXG5cIjtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///39592\n')},10011:function(__unused_webpack___webpack_module__,__webpack_exports__){eval('//This file is automatically rebuilt by the Cesium build process.\n/* harmony default export */ __webpack_exports__["Z"] = ("uniform sampler2D depthTexture;\\n\\\nuniform float length;\\n\\\nuniform vec4 color;\\n\\\n\\n\\\nvarying vec2 v_textureCoordinates;\\n\\\n\\n\\\nvoid main(void)\\n\\\n{\\n\\\n    float directions[3];\\n\\\n    directions[0] = -1.0;\\n\\\n    directions[1] = 0.0;\\n\\\n    directions[2] = 1.0;\\n\\\n\\n\\\n    float scalars[3];\\n\\\n    scalars[0] = 3.0;\\n\\\n    scalars[1] = 10.0;\\n\\\n    scalars[2] = 3.0;\\n\\\n\\n\\\n    float padx = czm_pixelRatio / czm_viewport.z;\\n\\\n    float pady = czm_pixelRatio / czm_viewport.w;\\n\\\n\\n\\\n#ifdef CZM_SELECTED_FEATURE\\n\\\n    bool selected = false;\\n\\\n    for (int i = 0; i < 3; ++i)\\n\\\n    {\\n\\\n        float dir = directions[i];\\n\\\n        selected = selected || czm_selected(vec2(-padx, dir * pady));\\n\\\n        selected = selected || czm_selected(vec2(padx, dir * pady));\\n\\\n        selected = selected || czm_selected(vec2(dir * padx, -pady));\\n\\\n        selected = selected || czm_selected(vec2(dir * padx, pady));\\n\\\n        if (selected)\\n\\\n        {\\n\\\n            break;\\n\\\n        }\\n\\\n    }\\n\\\n    if (!selected)\\n\\\n    {\\n\\\n        gl_FragColor = vec4(color.rgb, 0.0);\\n\\\n        return;\\n\\\n    }\\n\\\n#endif\\n\\\n\\n\\\n    float horizEdge = 0.0;\\n\\\n    float vertEdge = 0.0;\\n\\\n\\n\\\n    for (int i = 0; i < 3; ++i)\\n\\\n    {\\n\\\n        float dir = directions[i];\\n\\\n        float scale = scalars[i];\\n\\\n\\n\\\n        horizEdge -= texture2D(depthTexture, v_textureCoordinates + vec2(-padx, dir * pady)).x * scale;\\n\\\n        horizEdge += texture2D(depthTexture, v_textureCoordinates + vec2(padx, dir * pady)).x * scale;\\n\\\n\\n\\\n        vertEdge -= texture2D(depthTexture, v_textureCoordinates + vec2(dir * padx, -pady)).x * scale;\\n\\\n        vertEdge += texture2D(depthTexture, v_textureCoordinates + vec2(dir * padx, pady)).x * scale;\\n\\\n    }\\n\\\n\\n\\\n    float len = sqrt(horizEdge * horizEdge + vertEdge * vertEdge);\\n\\\n    gl_FragColor = vec4(color.rgb, len > length ? color.a : 0.0);\\n\\\n}\\n\\\n");\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTAwMTEuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQSx5REFBZSxnQ0FBZ0M7QUFDL0MscUJBQXFCO0FBQ3JCLG1CQUFtQjtBQUNuQjtBQUNBLGtDQUFrQztBQUNsQztBQUNBO0FBQ0EsQ0FBQztBQUNELHdCQUF3QjtBQUN4Qix5QkFBeUI7QUFDekIsd0JBQXdCO0FBQ3hCLHdCQUF3QjtBQUN4QjtBQUNBLHFCQUFxQjtBQUNyQixxQkFBcUI7QUFDckIsc0JBQXNCO0FBQ3RCLHFCQUFxQjtBQUNyQjtBQUNBLGlEQUFpRDtBQUNqRCxpREFBaUQ7QUFDakQ7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQixvQkFBb0IsT0FBTztBQUMzQixLQUFLO0FBQ0wsa0NBQWtDO0FBQ2xDLHFFQUFxRTtBQUNyRSxvRUFBb0U7QUFDcEUscUVBQXFFO0FBQ3JFLG9FQUFvRTtBQUNwRTtBQUNBLFNBQVM7QUFDVCxrQkFBa0I7QUFDbEIsU0FBUztBQUNULEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTCw0Q0FBNEM7QUFDNUMsZUFBZTtBQUNmLEtBQUs7QUFDTDtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCLHlCQUF5QjtBQUN6QjtBQUNBLG9CQUFvQixPQUFPO0FBQzNCLEtBQUs7QUFDTCxrQ0FBa0M7QUFDbEMsaUNBQWlDO0FBQ2pDO0FBQ0EsdUdBQXVHO0FBQ3ZHLHNHQUFzRztBQUN0RztBQUNBLHNHQUFzRztBQUN0RyxxR0FBcUc7QUFDckcsS0FBSztBQUNMO0FBQ0Esa0VBQWtFO0FBQ2xFLGlFQUFpRTtBQUNqRSxDQUFDO0FBQ0QsQ0FBQyxFQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdnVlMy13ZWJwYWNrNS8uL25vZGVfbW9kdWxlcy9jZXNpdW0vU291cmNlL1NoYWRlcnMvUG9zdFByb2Nlc3NTdGFnZXMvRWRnZURldGVjdGlvbi5qcz83NTMwIl0sInNvdXJjZXNDb250ZW50IjpbIi8vVGhpcyBmaWxlIGlzIGF1dG9tYXRpY2FsbHkgcmVidWlsdCBieSB0aGUgQ2VzaXVtIGJ1aWxkIHByb2Nlc3MuXG5leHBvcnQgZGVmYXVsdCBcInVuaWZvcm0gc2FtcGxlcjJEIGRlcHRoVGV4dHVyZTtcXG5cXFxudW5pZm9ybSBmbG9hdCBsZW5ndGg7XFxuXFxcbnVuaWZvcm0gdmVjNCBjb2xvcjtcXG5cXFxuXFxuXFxcbnZhcnlpbmcgdmVjMiB2X3RleHR1cmVDb29yZGluYXRlcztcXG5cXFxuXFxuXFxcbnZvaWQgbWFpbih2b2lkKVxcblxcXG57XFxuXFxcbiAgICBmbG9hdCBkaXJlY3Rpb25zWzNdO1xcblxcXG4gICAgZGlyZWN0aW9uc1swXSA9IC0xLjA7XFxuXFxcbiAgICBkaXJlY3Rpb25zWzFdID0gMC4wO1xcblxcXG4gICAgZGlyZWN0aW9uc1syXSA9IDEuMDtcXG5cXFxuXFxuXFxcbiAgICBmbG9hdCBzY2FsYXJzWzNdO1xcblxcXG4gICAgc2NhbGFyc1swXSA9IDMuMDtcXG5cXFxuICAgIHNjYWxhcnNbMV0gPSAxMC4wO1xcblxcXG4gICAgc2NhbGFyc1syXSA9IDMuMDtcXG5cXFxuXFxuXFxcbiAgICBmbG9hdCBwYWR4ID0gY3ptX3BpeGVsUmF0aW8gLyBjem1fdmlld3BvcnQuejtcXG5cXFxuICAgIGZsb2F0IHBhZHkgPSBjem1fcGl4ZWxSYXRpbyAvIGN6bV92aWV3cG9ydC53O1xcblxcXG5cXG5cXFxuI2lmZGVmIENaTV9TRUxFQ1RFRF9GRUFUVVJFXFxuXFxcbiAgICBib29sIHNlbGVjdGVkID0gZmFsc2U7XFxuXFxcbiAgICBmb3IgKGludCBpID0gMDsgaSA8IDM7ICsraSlcXG5cXFxuICAgIHtcXG5cXFxuICAgICAgICBmbG9hdCBkaXIgPSBkaXJlY3Rpb25zW2ldO1xcblxcXG4gICAgICAgIHNlbGVjdGVkID0gc2VsZWN0ZWQgfHwgY3ptX3NlbGVjdGVkKHZlYzIoLXBhZHgsIGRpciAqIHBhZHkpKTtcXG5cXFxuICAgICAgICBzZWxlY3RlZCA9IHNlbGVjdGVkIHx8IGN6bV9zZWxlY3RlZCh2ZWMyKHBhZHgsIGRpciAqIHBhZHkpKTtcXG5cXFxuICAgICAgICBzZWxlY3RlZCA9IHNlbGVjdGVkIHx8IGN6bV9zZWxlY3RlZCh2ZWMyKGRpciAqIHBhZHgsIC1wYWR5KSk7XFxuXFxcbiAgICAgICAgc2VsZWN0ZWQgPSBzZWxlY3RlZCB8fCBjem1fc2VsZWN0ZWQodmVjMihkaXIgKiBwYWR4LCBwYWR5KSk7XFxuXFxcbiAgICAgICAgaWYgKHNlbGVjdGVkKVxcblxcXG4gICAgICAgIHtcXG5cXFxuICAgICAgICAgICAgYnJlYWs7XFxuXFxcbiAgICAgICAgfVxcblxcXG4gICAgfVxcblxcXG4gICAgaWYgKCFzZWxlY3RlZClcXG5cXFxuICAgIHtcXG5cXFxuICAgICAgICBnbF9GcmFnQ29sb3IgPSB2ZWM0KGNvbG9yLnJnYiwgMC4wKTtcXG5cXFxuICAgICAgICByZXR1cm47XFxuXFxcbiAgICB9XFxuXFxcbiNlbmRpZlxcblxcXG5cXG5cXFxuICAgIGZsb2F0IGhvcml6RWRnZSA9IDAuMDtcXG5cXFxuICAgIGZsb2F0IHZlcnRFZGdlID0gMC4wO1xcblxcXG5cXG5cXFxuICAgIGZvciAoaW50IGkgPSAwOyBpIDwgMzsgKytpKVxcblxcXG4gICAge1xcblxcXG4gICAgICAgIGZsb2F0IGRpciA9IGRpcmVjdGlvbnNbaV07XFxuXFxcbiAgICAgICAgZmxvYXQgc2NhbGUgPSBzY2FsYXJzW2ldO1xcblxcXG5cXG5cXFxuICAgICAgICBob3JpekVkZ2UgLT0gdGV4dHVyZTJEKGRlcHRoVGV4dHVyZSwgdl90ZXh0dXJlQ29vcmRpbmF0ZXMgKyB2ZWMyKC1wYWR4LCBkaXIgKiBwYWR5KSkueCAqIHNjYWxlO1xcblxcXG4gICAgICAgIGhvcml6RWRnZSArPSB0ZXh0dXJlMkQoZGVwdGhUZXh0dXJlLCB2X3RleHR1cmVDb29yZGluYXRlcyArIHZlYzIocGFkeCwgZGlyICogcGFkeSkpLnggKiBzY2FsZTtcXG5cXFxuXFxuXFxcbiAgICAgICAgdmVydEVkZ2UgLT0gdGV4dHVyZTJEKGRlcHRoVGV4dHVyZSwgdl90ZXh0dXJlQ29vcmRpbmF0ZXMgKyB2ZWMyKGRpciAqIHBhZHgsIC1wYWR5KSkueCAqIHNjYWxlO1xcblxcXG4gICAgICAgIHZlcnRFZGdlICs9IHRleHR1cmUyRChkZXB0aFRleHR1cmUsIHZfdGV4dHVyZUNvb3JkaW5hdGVzICsgdmVjMihkaXIgKiBwYWR4LCBwYWR5KSkueCAqIHNjYWxlO1xcblxcXG4gICAgfVxcblxcXG5cXG5cXFxuICAgIGZsb2F0IGxlbiA9IHNxcnQoaG9yaXpFZGdlICogaG9yaXpFZGdlICsgdmVydEVkZ2UgKiB2ZXJ0RWRnZSk7XFxuXFxcbiAgICBnbF9GcmFnQ29sb3IgPSB2ZWM0KGNvbG9yLnJnYiwgbGVuID4gbGVuZ3RoID8gY29sb3IuYSA6IDAuMCk7XFxuXFxcbn1cXG5cXFxuXCI7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///10011\n')},96273:function(__unused_webpack___webpack_module__,__webpack_exports__){eval('//This file is automatically rebuilt by the Cesium build process.\n/* harmony default export */ __webpack_exports__["Z"] = ("varying vec2 v_textureCoordinates;\\n\\\n\\n\\\nuniform sampler2D colorTexture;\\n\\\n\\n\\\nconst float fxaaQualitySubpix = 0.5;\\n\\\nconst float fxaaQualityEdgeThreshold = 0.125;\\n\\\nconst float fxaaQualityEdgeThresholdMin = 0.0833;\\n\\\n\\n\\\nvoid main()\\n\\\n{\\n\\\n    vec2 fxaaQualityRcpFrame = vec2(1.0) / czm_viewport.zw;\\n\\\n    vec4 color = FxaaPixelShader(\\n\\\n        v_textureCoordinates,\\n\\\n        colorTexture,\\n\\\n        fxaaQualityRcpFrame,\\n\\\n        fxaaQualitySubpix,\\n\\\n        fxaaQualityEdgeThreshold,\\n\\\n        fxaaQualityEdgeThresholdMin);\\n\\\n    float alpha = texture2D(colorTexture, v_textureCoordinates).a;\\n\\\n    gl_FragColor = vec4(color.rgb, alpha);\\n\\\n}\\n\\\n");\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiOTYyNzMuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQSx5REFBZSxtQ0FBbUM7QUFDbEQ7QUFDQSwrQkFBK0I7QUFDL0I7QUFDQSxvQ0FBb0M7QUFDcEMsNkNBQTZDO0FBQzdDLGlEQUFpRDtBQUNqRDtBQUNBO0FBQ0EsQ0FBQztBQUNELDJEQUEyRDtBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUM7QUFDckMsa0VBQWtFO0FBQ2xFLDBDQUEwQztBQUMxQyxDQUFDO0FBQ0QsQ0FBQyxFQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdnVlMy13ZWJwYWNrNS8uL25vZGVfbW9kdWxlcy9jZXNpdW0vU291cmNlL1NoYWRlcnMvUG9zdFByb2Nlc3NTdGFnZXMvRlhBQS5qcz82ZDRiIl0sInNvdXJjZXNDb250ZW50IjpbIi8vVGhpcyBmaWxlIGlzIGF1dG9tYXRpY2FsbHkgcmVidWlsdCBieSB0aGUgQ2VzaXVtIGJ1aWxkIHByb2Nlc3MuXG5leHBvcnQgZGVmYXVsdCBcInZhcnlpbmcgdmVjMiB2X3RleHR1cmVDb29yZGluYXRlcztcXG5cXFxuXFxuXFxcbnVuaWZvcm0gc2FtcGxlcjJEIGNvbG9yVGV4dHVyZTtcXG5cXFxuXFxuXFxcbmNvbnN0IGZsb2F0IGZ4YWFRdWFsaXR5U3VicGl4ID0gMC41O1xcblxcXG5jb25zdCBmbG9hdCBmeGFhUXVhbGl0eUVkZ2VUaHJlc2hvbGQgPSAwLjEyNTtcXG5cXFxuY29uc3QgZmxvYXQgZnhhYVF1YWxpdHlFZGdlVGhyZXNob2xkTWluID0gMC4wODMzO1xcblxcXG5cXG5cXFxudm9pZCBtYWluKClcXG5cXFxue1xcblxcXG4gICAgdmVjMiBmeGFhUXVhbGl0eVJjcEZyYW1lID0gdmVjMigxLjApIC8gY3ptX3ZpZXdwb3J0Lnp3O1xcblxcXG4gICAgdmVjNCBjb2xvciA9IEZ4YWFQaXhlbFNoYWRlcihcXG5cXFxuICAgICAgICB2X3RleHR1cmVDb29yZGluYXRlcyxcXG5cXFxuICAgICAgICBjb2xvclRleHR1cmUsXFxuXFxcbiAgICAgICAgZnhhYVF1YWxpdHlSY3BGcmFtZSxcXG5cXFxuICAgICAgICBmeGFhUXVhbGl0eVN1YnBpeCxcXG5cXFxuICAgICAgICBmeGFhUXVhbGl0eUVkZ2VUaHJlc2hvbGQsXFxuXFxcbiAgICAgICAgZnhhYVF1YWxpdHlFZGdlVGhyZXNob2xkTWluKTtcXG5cXFxuICAgIGZsb2F0IGFscGhhID0gdGV4dHVyZTJEKGNvbG9yVGV4dHVyZSwgdl90ZXh0dXJlQ29vcmRpbmF0ZXMpLmE7XFxuXFxcbiAgICBnbF9GcmFnQ29sb3IgPSB2ZWM0KGNvbG9yLnJnYiwgYWxwaGEpO1xcblxcXG59XFxuXFxcblwiO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///96273\n')},95848:function(__unused_webpack___webpack_module__,__webpack_exports__){eval('//This file is automatically rebuilt by the Cesium build process.\n/* harmony default export */ __webpack_exports__["Z"] = ("uniform sampler2D colorTexture;\\n\\\n\\n\\\nvarying vec2 v_textureCoordinates;\\n\\\n\\n\\\n#ifdef AUTO_EXPOSURE\\n\\\nuniform sampler2D autoExposure;\\n\\\n#endif\\n\\\n\\n\\\n// See slides 142 and 143:\\n\\\n//     http://www.gdcvault.com/play/1012459/Uncharted_2__HDR_Lighting\\n\\\n\\n\\\nvoid main()\\n\\\n{\\n\\\n    vec4 fragmentColor = texture2D(colorTexture, v_textureCoordinates);\\n\\\n    vec3 color = fragmentColor.rgb;\\n\\\n\\n\\\n#ifdef AUTO_EXPOSURE\\n\\\n    float exposure = texture2D(autoExposure, vec2(0.5)).r;\\n\\\n    color /= exposure;\\n\\\n#endif\\n\\\n\\n\\\n\tconst float A = 0.22; // shoulder strength\\n\\\n\tconst float B = 0.30; // linear strength\\n\\\n\tconst float C = 0.10; // linear angle\\n\\\n\tconst float D = 0.20; // toe strength\\n\\\n\tconst float E = 0.01; // toe numerator\\n\\\n\tconst float F = 0.30; // toe denominator\\n\\\n\\n\\\n\tconst float white = 11.2; // linear white point value\\n\\\n\\n\\\n\tvec3 c = ((color * (A * color + C * B) + D * E) / (color * ( A * color + B) + D * F)) - E / F;\\n\\\n\tfloat w = ((white * (A * white + C * B) + D * E) / (white * ( A * white + B) + D * F)) - E / F;\\n\\\n\\n\\\n\tc = czm_inverseGamma(c / w);\\n\\\n\tgl_FragColor = vec4(c, fragmentColor.a);\\n\\\n}\\n\\\n");\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiOTU4NDguanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQSx5REFBZSxnQ0FBZ0M7QUFDL0M7QUFDQSxrQ0FBa0M7QUFDbEM7QUFDQTtBQUNBLCtCQUErQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0QsdUVBQXVFO0FBQ3ZFLG1DQUFtQztBQUNuQztBQUNBO0FBQ0EsMERBQTBEO0FBQzFELHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCLHVCQUF1QjtBQUN2Qix1QkFBdUI7QUFDdkIsdUJBQXVCO0FBQ3ZCLHVCQUF1QjtBQUN2Qix1QkFBdUI7QUFDdkI7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQSwrRkFBK0Y7QUFDL0YsZ0dBQWdHO0FBQ2hHO0FBQ0EsNkJBQTZCO0FBQzdCLHlDQUF5QztBQUN6QyxDQUFDO0FBQ0QsQ0FBQyxFQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdnVlMy13ZWJwYWNrNS8uL25vZGVfbW9kdWxlcy9jZXNpdW0vU291cmNlL1NoYWRlcnMvUG9zdFByb2Nlc3NTdGFnZXMvRmlsbWljVG9uZW1hcHBpbmcuanM/NGJjYiJdLCJzb3VyY2VzQ29udGVudCI6WyIvL1RoaXMgZmlsZSBpcyBhdXRvbWF0aWNhbGx5IHJlYnVpbHQgYnkgdGhlIENlc2l1bSBidWlsZCBwcm9jZXNzLlxuZXhwb3J0IGRlZmF1bHQgXCJ1bmlmb3JtIHNhbXBsZXIyRCBjb2xvclRleHR1cmU7XFxuXFxcblxcblxcXG52YXJ5aW5nIHZlYzIgdl90ZXh0dXJlQ29vcmRpbmF0ZXM7XFxuXFxcblxcblxcXG4jaWZkZWYgQVVUT19FWFBPU1VSRVxcblxcXG51bmlmb3JtIHNhbXBsZXIyRCBhdXRvRXhwb3N1cmU7XFxuXFxcbiNlbmRpZlxcblxcXG5cXG5cXFxuLy8gU2VlIHNsaWRlcyAxNDIgYW5kIDE0MzpcXG5cXFxuLy8gICAgIGh0dHA6Ly93d3cuZ2RjdmF1bHQuY29tL3BsYXkvMTAxMjQ1OS9VbmNoYXJ0ZWRfMl9fSERSX0xpZ2h0aW5nXFxuXFxcblxcblxcXG52b2lkIG1haW4oKVxcblxcXG57XFxuXFxcbiAgICB2ZWM0IGZyYWdtZW50Q29sb3IgPSB0ZXh0dXJlMkQoY29sb3JUZXh0dXJlLCB2X3RleHR1cmVDb29yZGluYXRlcyk7XFxuXFxcbiAgICB2ZWMzIGNvbG9yID0gZnJhZ21lbnRDb2xvci5yZ2I7XFxuXFxcblxcblxcXG4jaWZkZWYgQVVUT19FWFBPU1VSRVxcblxcXG4gICAgZmxvYXQgZXhwb3N1cmUgPSB0ZXh0dXJlMkQoYXV0b0V4cG9zdXJlLCB2ZWMyKDAuNSkpLnI7XFxuXFxcbiAgICBjb2xvciAvPSBleHBvc3VyZTtcXG5cXFxuI2VuZGlmXFxuXFxcblxcblxcXG5cdGNvbnN0IGZsb2F0IEEgPSAwLjIyOyAvLyBzaG91bGRlciBzdHJlbmd0aFxcblxcXG5cdGNvbnN0IGZsb2F0IEIgPSAwLjMwOyAvLyBsaW5lYXIgc3RyZW5ndGhcXG5cXFxuXHRjb25zdCBmbG9hdCBDID0gMC4xMDsgLy8gbGluZWFyIGFuZ2xlXFxuXFxcblx0Y29uc3QgZmxvYXQgRCA9IDAuMjA7IC8vIHRvZSBzdHJlbmd0aFxcblxcXG5cdGNvbnN0IGZsb2F0IEUgPSAwLjAxOyAvLyB0b2UgbnVtZXJhdG9yXFxuXFxcblx0Y29uc3QgZmxvYXQgRiA9IDAuMzA7IC8vIHRvZSBkZW5vbWluYXRvclxcblxcXG5cXG5cXFxuXHRjb25zdCBmbG9hdCB3aGl0ZSA9IDExLjI7IC8vIGxpbmVhciB3aGl0ZSBwb2ludCB2YWx1ZVxcblxcXG5cXG5cXFxuXHR2ZWMzIGMgPSAoKGNvbG9yICogKEEgKiBjb2xvciArIEMgKiBCKSArIEQgKiBFKSAvIChjb2xvciAqICggQSAqIGNvbG9yICsgQikgKyBEICogRikpIC0gRSAvIEY7XFxuXFxcblx0ZmxvYXQgdyA9ICgod2hpdGUgKiAoQSAqIHdoaXRlICsgQyAqIEIpICsgRCAqIEUpIC8gKHdoaXRlICogKCBBICogd2hpdGUgKyBCKSArIEQgKiBGKSkgLSBFIC8gRjtcXG5cXFxuXFxuXFxcblx0YyA9IGN6bV9pbnZlcnNlR2FtbWEoYyAvIHcpO1xcblxcXG5cdGdsX0ZyYWdDb2xvciA9IHZlYzQoYywgZnJhZ21lbnRDb2xvci5hKTtcXG5cXFxufVxcblxcXG5cIjtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///95848\n')},23077:function(__unused_webpack___webpack_module__,__webpack_exports__){eval('//This file is automatically rebuilt by the Cesium build process.\n/* harmony default export */ __webpack_exports__["Z"] = ("#define SAMPLES 8\\n\\\n\\n\\\nuniform float delta;\\n\\\nuniform float sigma;\\n\\\nuniform float direction; // 0.0 for x direction, 1.0 for y direction\\n\\\n\\n\\\nuniform sampler2D colorTexture;\\n\\\n\\n\\\n#ifdef USE_STEP_SIZE\\n\\\nuniform float stepSize;\\n\\\n#else\\n\\\nuniform vec2 step;\\n\\\n#endif\\n\\\n\\n\\\nvarying vec2 v_textureCoordinates;\\n\\\n\\n\\\n//  Incremental Computation of the Gaussian:\\n\\\n//  https://developer.nvidia.com/gpugems/GPUGems3/gpugems3_ch40.html\\n\\\n\\n\\\nvoid main()\\n\\\n{\\n\\\n    vec2 st = v_textureCoordinates;\\n\\\n    vec2 dir = vec2(1.0 - direction, direction);\\n\\\n\\n\\\n#ifdef USE_STEP_SIZE\\n\\\n    vec2 step = vec2(stepSize * (czm_pixelRatio / czm_viewport.zw));\\n\\\n#else\\n\\\n    vec2 step = step;\\n\\\n#endif\\n\\\n\\n\\\n    vec3 g;\\n\\\n    g.x = 1.0 / (sqrt(czm_twoPi) * sigma);\\n\\\n    g.y = exp((-0.5 * delta * delta) / (sigma * sigma));\\n\\\n    g.z = g.y * g.y;\\n\\\n\\n\\\n    vec4 result = texture2D(colorTexture, st) * g.x;\\n\\\n    for (int i = 1; i < SAMPLES; ++i)\\n\\\n    {\\n\\\n        g.xy *= g.yz;\\n\\\n\\n\\\n        vec2 offset = float(i) * dir * step;\\n\\\n        result += texture2D(colorTexture, st - offset) * g.x;\\n\\\n        result += texture2D(colorTexture, st + offset) * g.x;\\n\\\n    }\\n\\\n\\n\\\n    gl_FragColor = result;\\n\\\n}\\n\\\n");\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjMwNzcuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQSx5REFBZTtBQUNmO0FBQ0Esb0JBQW9CO0FBQ3BCLG9CQUFvQjtBQUNwQix5QkFBeUI7QUFDekI7QUFDQSwrQkFBK0I7QUFDL0I7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0Esa0NBQWtDO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0QsbUNBQW1DO0FBQ25DLGdEQUFnRDtBQUNoRDtBQUNBO0FBQ0Esb0VBQW9FO0FBQ3BFO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsMENBQTBDO0FBQzFDLHdEQUF3RDtBQUN4RCxvQkFBb0I7QUFDcEI7QUFDQSxvREFBb0Q7QUFDcEQsb0JBQW9CLGFBQWE7QUFDakMsS0FBSztBQUNMLHFCQUFxQjtBQUNyQjtBQUNBLDRDQUE0QztBQUM1Qyw2REFBNkQ7QUFDN0QsNkRBQTZEO0FBQzdELEtBQUs7QUFDTDtBQUNBLDBCQUEwQjtBQUMxQixDQUFDO0FBQ0QsQ0FBQyxFQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdnVlMy13ZWJwYWNrNS8uL25vZGVfbW9kdWxlcy9jZXNpdW0vU291cmNlL1NoYWRlcnMvUG9zdFByb2Nlc3NTdGFnZXMvR2F1c3NpYW5CbHVyMUQuanM/YWY2NyJdLCJzb3VyY2VzQ29udGVudCI6WyIvL1RoaXMgZmlsZSBpcyBhdXRvbWF0aWNhbGx5IHJlYnVpbHQgYnkgdGhlIENlc2l1bSBidWlsZCBwcm9jZXNzLlxuZXhwb3J0IGRlZmF1bHQgXCIjZGVmaW5lIFNBTVBMRVMgOFxcblxcXG5cXG5cXFxudW5pZm9ybSBmbG9hdCBkZWx0YTtcXG5cXFxudW5pZm9ybSBmbG9hdCBzaWdtYTtcXG5cXFxudW5pZm9ybSBmbG9hdCBkaXJlY3Rpb247IC8vIDAuMCBmb3IgeCBkaXJlY3Rpb24sIDEuMCBmb3IgeSBkaXJlY3Rpb25cXG5cXFxuXFxuXFxcbnVuaWZvcm0gc2FtcGxlcjJEIGNvbG9yVGV4dHVyZTtcXG5cXFxuXFxuXFxcbiNpZmRlZiBVU0VfU1RFUF9TSVpFXFxuXFxcbnVuaWZvcm0gZmxvYXQgc3RlcFNpemU7XFxuXFxcbiNlbHNlXFxuXFxcbnVuaWZvcm0gdmVjMiBzdGVwO1xcblxcXG4jZW5kaWZcXG5cXFxuXFxuXFxcbnZhcnlpbmcgdmVjMiB2X3RleHR1cmVDb29yZGluYXRlcztcXG5cXFxuXFxuXFxcbi8vICBJbmNyZW1lbnRhbCBDb21wdXRhdGlvbiBvZiB0aGUgR2F1c3NpYW46XFxuXFxcbi8vICBodHRwczovL2RldmVsb3Blci5udmlkaWEuY29tL2dwdWdlbXMvR1BVR2VtczMvZ3B1Z2VtczNfY2g0MC5odG1sXFxuXFxcblxcblxcXG52b2lkIG1haW4oKVxcblxcXG57XFxuXFxcbiAgICB2ZWMyIHN0ID0gdl90ZXh0dXJlQ29vcmRpbmF0ZXM7XFxuXFxcbiAgICB2ZWMyIGRpciA9IHZlYzIoMS4wIC0gZGlyZWN0aW9uLCBkaXJlY3Rpb24pO1xcblxcXG5cXG5cXFxuI2lmZGVmIFVTRV9TVEVQX1NJWkVcXG5cXFxuICAgIHZlYzIgc3RlcCA9IHZlYzIoc3RlcFNpemUgKiAoY3ptX3BpeGVsUmF0aW8gLyBjem1fdmlld3BvcnQuencpKTtcXG5cXFxuI2Vsc2VcXG5cXFxuICAgIHZlYzIgc3RlcCA9IHN0ZXA7XFxuXFxcbiNlbmRpZlxcblxcXG5cXG5cXFxuICAgIHZlYzMgZztcXG5cXFxuICAgIGcueCA9IDEuMCAvIChzcXJ0KGN6bV90d29QaSkgKiBzaWdtYSk7XFxuXFxcbiAgICBnLnkgPSBleHAoKC0wLjUgKiBkZWx0YSAqIGRlbHRhKSAvIChzaWdtYSAqIHNpZ21hKSk7XFxuXFxcbiAgICBnLnogPSBnLnkgKiBnLnk7XFxuXFxcblxcblxcXG4gICAgdmVjNCByZXN1bHQgPSB0ZXh0dXJlMkQoY29sb3JUZXh0dXJlLCBzdCkgKiBnLng7XFxuXFxcbiAgICBmb3IgKGludCBpID0gMTsgaSA8IFNBTVBMRVM7ICsraSlcXG5cXFxuICAgIHtcXG5cXFxuICAgICAgICBnLnh5ICo9IGcueXo7XFxuXFxcblxcblxcXG4gICAgICAgIHZlYzIgb2Zmc2V0ID0gZmxvYXQoaSkgKiBkaXIgKiBzdGVwO1xcblxcXG4gICAgICAgIHJlc3VsdCArPSB0ZXh0dXJlMkQoY29sb3JUZXh0dXJlLCBzdCAtIG9mZnNldCkgKiBnLng7XFxuXFxcbiAgICAgICAgcmVzdWx0ICs9IHRleHR1cmUyRChjb2xvclRleHR1cmUsIHN0ICsgb2Zmc2V0KSAqIGcueDtcXG5cXFxuICAgIH1cXG5cXFxuXFxuXFxcbiAgICBnbF9GcmFnQ29sb3IgPSByZXN1bHQ7XFxuXFxcbn1cXG5cXFxuXCI7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///23077\n')},99182:function(__unused_webpack___webpack_module__,__webpack_exports__){eval('//This file is automatically rebuilt by the Cesium build process.\n/* harmony default export */ __webpack_exports__["Z"] = ("uniform sampler2D colorTexture;\\n\\\nuniform sampler2D dirtTexture;\\n\\\nuniform sampler2D starTexture;\\n\\\nuniform vec2 dirtTextureDimensions;\\n\\\nuniform float distortion;\\n\\\nuniform float ghostDispersal;\\n\\\nuniform float haloWidth;\\n\\\nuniform float dirtAmount;\\n\\\nuniform float earthRadius;\\n\\\nuniform float intensity;\\n\\\n\\n\\\nvarying vec2 v_textureCoordinates;\\n\\\n\\n\\\n// whether it is in space or not\\n\\\n// 6500000.0 is empirical value\\n\\\n#define DISTANCE_TO_SPACE 6500000.0\\n\\\n\\n\\\n// return ndc from world coordinate biased earthRadius\\n\\\nvec4 getNDCFromWC(vec3 WC, float earthRadius)\\n\\\n{\\n\\\n    vec4 positionEC = czm_view * vec4(WC, 1.0);\\n\\\n    positionEC = vec4(positionEC.x + earthRadius, positionEC.y, positionEC.z, 1.0);\\n\\\n    vec4 positionWC = czm_eyeToWindowCoordinates(positionEC);\\n\\\n    return czm_viewportOrthographic * vec4(positionWC.xy, -positionWC.z, 1.0);\\n\\\n}\\n\\\n\\n\\\n// Check if current pixel is included Earth\\n\\\n// if then mask it gradually\\n\\\nfloat isInEarth(vec2 texcoord, vec2 sceneSize)\\n\\\n{\\n\\\n    vec2 NDC = texcoord * 2.0 - 1.0;\\n\\\n    vec4 earthPosSC = getNDCFromWC(vec3(0.0), 0.0);\\n\\\n    vec4 earthPosSCEdge = getNDCFromWC(vec3(0.0), earthRadius * 1.5);\\n\\\n    NDC.xy -= earthPosSC.xy;\\n\\\n\\n\\\n    float X = abs(NDC.x) * sceneSize.x;\\n\\\n    float Y = abs(NDC.y) * sceneSize.y;\\n\\\n\\n\\\n    return clamp(0.0, 1.0, max(sqrt(X * X + Y * Y) / max(abs(earthPosSCEdge.x * sceneSize.x), 1.0) - 0.8 , 0.0));\\n\\\n}\\n\\\n\\n\\\n// For Chromatic effect\\n\\\nvec4 textureDistorted(sampler2D tex, vec2 texcoord, vec2 direction, vec3 distortion, bool isSpace)\\n\\\n{\\n\\\n    vec2 sceneSize = czm_viewport.zw;\\n\\\n    vec3 color;\\n\\\n    if(isSpace)\\n\\\n    {\\n\\\n        color.r = isInEarth(texcoord + direction * distortion.r, sceneSize) * texture2D(tex, texcoord + direction * distortion.r).r;\\n\\\n        color.g = isInEarth(texcoord + direction * distortion.g, sceneSize) * texture2D(tex, texcoord + direction * distortion.g).g;\\n\\\n        color.b = isInEarth(texcoord + direction * distortion.b, sceneSize) * texture2D(tex, texcoord + direction * distortion.b).b;\\n\\\n    }\\n\\\n    else\\n\\\n    {\\n\\\n        color.r = texture2D(tex, texcoord + direction * distortion.r).r;\\n\\\n        color.g = texture2D(tex, texcoord + direction * distortion.g).g;\\n\\\n        color.b = texture2D(tex, texcoord + direction * distortion.b).b;\\n\\\n    }\\n\\\n    return vec4(clamp(color, 0.0, 1.0), 0.0);\\n\\\n}\\n\\\n\\n\\\nvoid main(void)\\n\\\n{\\n\\\n    vec4 originalColor = texture2D(colorTexture, v_textureCoordinates);\\n\\\n    vec3 rgb = originalColor.rgb;\\n\\\n    bool isSpace = length(czm_viewerPositionWC.xyz) > DISTANCE_TO_SPACE;\\n\\\n\\n\\\n    // Sun position\\n\\\n    vec4 sunPos = czm_morphTime == 1.0 ? vec4(czm_sunPositionWC, 1.0) : vec4(czm_sunPositionColumbusView.zxy, 1.0);\\n\\\n    vec4 sunPositionEC = czm_view * sunPos;\\n\\\n    vec4 sunPositionWC = czm_eyeToWindowCoordinates(sunPositionEC);\\n\\\n    sunPos = czm_viewportOrthographic * vec4(sunPositionWC.xy, -sunPositionWC.z, 1.0);\\n\\\n\\n\\\n    // If sun is not in the screen space, use original color.\\n\\\n    if(!isSpace || !((sunPos.x >= -1.1 && sunPos.x <= 1.1) && (sunPos.y >= -1.1 && sunPos.y <= 1.1)))\\n\\\n    {\\n\\\n        // Lens flare is disabled when not in space until #5932 is fixed.\\n\\\n        //    https://github.com/CesiumGS/cesium/issues/5932\\n\\\n        gl_FragColor = originalColor;\\n\\\n        return;\\n\\\n    }\\n\\\n\\n\\\n    vec2 texcoord = vec2(1.0) - v_textureCoordinates;\\n\\\n    vec2 pixelSize = czm_pixelRatio / czm_viewport.zw;\\n\\\n    vec2 invPixelSize = 1.0 / pixelSize;\\n\\\n    vec3 distortionVec = pixelSize.x * vec3(-distortion, 0.0, distortion);\\n\\\n\\n\\\n    // ghost vector to image centre:\\n\\\n    vec2 ghostVec = (vec2(0.5) - texcoord) * ghostDispersal;\\n\\\n    vec3 direction = normalize(vec3(ghostVec, 0.0));\\n\\\n\\n\\\n    // sample ghosts:\\n\\\n    vec4 result = vec4(0.0);\\n\\\n    vec4 ghost = vec4(0.0);\\n\\\n    for (int i = 0; i < 4; ++i)\\n\\\n    {\\n\\\n        vec2 offset = fract(texcoord + ghostVec * float(i));\\n\\\n        // Only bright spots from the centre of the source image\\n\\\n        ghost += textureDistorted(colorTexture, offset, direction.xy, distortionVec, isSpace);\\n\\\n    }\\n\\\n    result += ghost;\\n\\\n\\n\\\n    // sample halo\\n\\\n    vec2 haloVec = normalize(ghostVec) * haloWidth;\\n\\\n    float weightForHalo = length(vec2(0.5) - fract(texcoord + haloVec)) / length(vec2(0.5));\\n\\\n    weightForHalo = pow(1.0 - weightForHalo, 5.0);\\n\\\n\\n\\\n    result += textureDistorted(colorTexture, texcoord + haloVec, direction.xy, distortionVec, isSpace) * weightForHalo * 1.5;\\n\\\n\\n\\\n    // dirt on lens\\n\\\n    vec2 dirtTexCoords = (v_textureCoordinates * invPixelSize) / dirtTextureDimensions;\\n\\\n    if (dirtTexCoords.x > 1.0)\\n\\\n    {\\n\\\n        dirtTexCoords.x = mod(floor(dirtTexCoords.x), 2.0) == 1.0 ? 1.0 - fract(dirtTexCoords.x) :  fract(dirtTexCoords.x);\\n\\\n    }\\n\\\n    if (dirtTexCoords.y > 1.0)\\n\\\n    {\\n\\\n        dirtTexCoords.y = mod(floor(dirtTexCoords.y), 2.0) == 1.0 ? 1.0 - fract(dirtTexCoords.y) :  fract(dirtTexCoords.y);\\n\\\n    }\\n\\\n    result += dirtAmount * texture2D(dirtTexture, dirtTexCoords);\\n\\\n\\n\\\n    // Rotating starburst texture\'s coordinate\\n\\\n    // dot(czm_view[0].xyz, vec3(0.0, 0.0, 1.0)) + dot(czm_view[1].xyz, vec3(0.0, 1.0, 0.0))\\n\\\n    float camrot = czm_view[0].z + czm_view[1].y;\\n\\\n    float cosValue = cos(camrot);\\n\\\n    float sinValue = sin(camrot);\\n\\\n    mat3 rotation = mat3(\\n\\\n        cosValue, -sinValue, 0.0,\\n\\\n        sinValue, cosValue, 0.0,\\n\\\n        0.0, 0.0, 1.0\\n\\\n    );\\n\\\n\\n\\\n    vec3 st1 = vec3(v_textureCoordinates * 2.0 - vec2(1.0), 1.0);\\n\\\n    vec3 st2 = vec3((rotation * st1).xy, 1.0);\\n\\\n    vec3 st3 = st2 * 0.5 + vec3(0.5);\\n\\\n    vec2 lensStarTexcoord = st3.xy;\\n\\\n    float weightForLensFlare = length(vec3(sunPos.xy, 0.0));\\n\\\n    float oneMinusWeightForLensFlare = max(1.0 - weightForLensFlare, 0.0);\\n\\\n\\n\\\n    if (!isSpace)\\n\\\n    {\\n\\\n        result *= oneMinusWeightForLensFlare * intensity * 0.2;\\n\\\n    }\\n\\\n    else\\n\\\n    {\\n\\\n        result *= oneMinusWeightForLensFlare * intensity;\\n\\\n        result *= texture2D(starTexture, lensStarTexcoord) * pow(weightForLensFlare, 1.0) * max((1.0 - length(vec3(st1.xy, 0.0))), 0.0) * 2.0;\\n\\\n    }\\n\\\n\\n\\\n    result += texture2D(colorTexture, v_textureCoordinates);\\n\\\n\\n\\\n    gl_FragColor = result;\\n\\\n}\\n\\\n");\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiOTkxODIuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQSx5REFBZSxnQ0FBZ0M7QUFDL0MsOEJBQThCO0FBQzlCLDhCQUE4QjtBQUM5QixtQ0FBbUM7QUFDbkMseUJBQXlCO0FBQ3pCLDZCQUE2QjtBQUM3Qix3QkFBd0I7QUFDeEIseUJBQXlCO0FBQ3pCLDBCQUEwQjtBQUMxQix3QkFBd0I7QUFDeEI7QUFDQSxrQ0FBa0M7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0QsK0NBQStDO0FBQy9DLG1GQUFtRjtBQUNuRiw2REFBNkQ7QUFDN0QsOEVBQThFO0FBQzlFLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRCxvQ0FBb0M7QUFDcEMsbURBQW1EO0FBQ25ELHFFQUFxRTtBQUNyRSw0QkFBNEI7QUFDNUI7QUFDQSx1Q0FBdUM7QUFDdkMsdUNBQXVDO0FBQ3ZDO0FBQ0EsaUhBQWlIO0FBQ2pILENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0QscUNBQXFDO0FBQ3JDLGVBQWU7QUFDZjtBQUNBLEtBQUs7QUFDTCxvSUFBb0k7QUFDcEksb0lBQW9JO0FBQ3BJLG9JQUFvSTtBQUNwSSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0wsd0VBQXdFO0FBQ3hFLHdFQUF3RTtBQUN4RSx3RUFBd0U7QUFDeEUsS0FBSztBQUNMLDZDQUE2QztBQUM3QyxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRCx1RUFBdUU7QUFDdkUsaUNBQWlDO0FBQ2pDLHdFQUF3RTtBQUN4RTtBQUNBO0FBQ0EsbUhBQW1IO0FBQ25ILDJDQUEyQztBQUMzQyxtRUFBbUU7QUFDbkUsc0ZBQXNGO0FBQ3RGO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EscUNBQXFDO0FBQ3JDLGVBQWU7QUFDZixLQUFLO0FBQ0w7QUFDQSxxREFBcUQ7QUFDckQsc0RBQXNEO0FBQ3RELHdDQUF3QztBQUN4QywwRUFBMEU7QUFDMUU7QUFDQTtBQUNBLDREQUE0RDtBQUM1RCxvREFBb0Q7QUFDcEQ7QUFDQTtBQUNBLDRCQUE0QjtBQUM1QiwyQkFBMkI7QUFDM0Isb0JBQW9CLE9BQU87QUFDM0IsS0FBSztBQUNMLDREQUE0RDtBQUM1RDtBQUNBLDhGQUE4RjtBQUM5RixLQUFLO0FBQ0wsb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQSxtREFBbUQ7QUFDbkQsNEZBQTRGO0FBQzVGLGtEQUFrRDtBQUNsRDtBQUNBLDZIQUE2SDtBQUM3SDtBQUNBO0FBQ0EsdUZBQXVGO0FBQ3ZGO0FBQ0EsS0FBSztBQUNMLDJIQUEySDtBQUMzSCxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0wsMkhBQTJIO0FBQzNILEtBQUs7QUFDTCxpRUFBaUU7QUFDakU7QUFDQTtBQUNBO0FBQ0EsaURBQWlEO0FBQ2pELGlDQUFpQztBQUNqQyxpQ0FBaUM7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxpRUFBaUU7QUFDakUsOENBQThDO0FBQzlDLHFDQUFxQztBQUNyQyxtQ0FBbUM7QUFDbkMsNERBQTREO0FBQzVELDBFQUEwRTtBQUMxRTtBQUNBO0FBQ0EsS0FBSztBQUNMLCtEQUErRDtBQUMvRCxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0wseURBQXlEO0FBQ3pELDhJQUE4STtBQUM5SSxLQUFLO0FBQ0w7QUFDQSw0REFBNEQ7QUFDNUQ7QUFDQSwwQkFBMEI7QUFDMUIsQ0FBQztBQUNELENBQUMsRUFBQyIsInNvdXJjZXMiOlsid2VicGFjazovL3Z1ZTMtd2VicGFjazUvLi9ub2RlX21vZHVsZXMvY2VzaXVtL1NvdXJjZS9TaGFkZXJzL1Bvc3RQcm9jZXNzU3RhZ2VzL0xlbnNGbGFyZS5qcz9mODE3Il0sInNvdXJjZXNDb250ZW50IjpbIi8vVGhpcyBmaWxlIGlzIGF1dG9tYXRpY2FsbHkgcmVidWlsdCBieSB0aGUgQ2VzaXVtIGJ1aWxkIHByb2Nlc3MuXG5leHBvcnQgZGVmYXVsdCBcInVuaWZvcm0gc2FtcGxlcjJEIGNvbG9yVGV4dHVyZTtcXG5cXFxudW5pZm9ybSBzYW1wbGVyMkQgZGlydFRleHR1cmU7XFxuXFxcbnVuaWZvcm0gc2FtcGxlcjJEIHN0YXJUZXh0dXJlO1xcblxcXG51bmlmb3JtIHZlYzIgZGlydFRleHR1cmVEaW1lbnNpb25zO1xcblxcXG51bmlmb3JtIGZsb2F0IGRpc3RvcnRpb247XFxuXFxcbnVuaWZvcm0gZmxvYXQgZ2hvc3REaXNwZXJzYWw7XFxuXFxcbnVuaWZvcm0gZmxvYXQgaGFsb1dpZHRoO1xcblxcXG51bmlmb3JtIGZsb2F0IGRpcnRBbW91bnQ7XFxuXFxcbnVuaWZvcm0gZmxvYXQgZWFydGhSYWRpdXM7XFxuXFxcbnVuaWZvcm0gZmxvYXQgaW50ZW5zaXR5O1xcblxcXG5cXG5cXFxudmFyeWluZyB2ZWMyIHZfdGV4dHVyZUNvb3JkaW5hdGVzO1xcblxcXG5cXG5cXFxuLy8gd2hldGhlciBpdCBpcyBpbiBzcGFjZSBvciBub3RcXG5cXFxuLy8gNjUwMDAwMC4wIGlzIGVtcGlyaWNhbCB2YWx1ZVxcblxcXG4jZGVmaW5lIERJU1RBTkNFX1RPX1NQQUNFIDY1MDAwMDAuMFxcblxcXG5cXG5cXFxuLy8gcmV0dXJuIG5kYyBmcm9tIHdvcmxkIGNvb3JkaW5hdGUgYmlhc2VkIGVhcnRoUmFkaXVzXFxuXFxcbnZlYzQgZ2V0TkRDRnJvbVdDKHZlYzMgV0MsIGZsb2F0IGVhcnRoUmFkaXVzKVxcblxcXG57XFxuXFxcbiAgICB2ZWM0IHBvc2l0aW9uRUMgPSBjem1fdmlldyAqIHZlYzQoV0MsIDEuMCk7XFxuXFxcbiAgICBwb3NpdGlvbkVDID0gdmVjNChwb3NpdGlvbkVDLnggKyBlYXJ0aFJhZGl1cywgcG9zaXRpb25FQy55LCBwb3NpdGlvbkVDLnosIDEuMCk7XFxuXFxcbiAgICB2ZWM0IHBvc2l0aW9uV0MgPSBjem1fZXllVG9XaW5kb3dDb29yZGluYXRlcyhwb3NpdGlvbkVDKTtcXG5cXFxuICAgIHJldHVybiBjem1fdmlld3BvcnRPcnRob2dyYXBoaWMgKiB2ZWM0KHBvc2l0aW9uV0MueHksIC1wb3NpdGlvbldDLnosIDEuMCk7XFxuXFxcbn1cXG5cXFxuXFxuXFxcbi8vIENoZWNrIGlmIGN1cnJlbnQgcGl4ZWwgaXMgaW5jbHVkZWQgRWFydGhcXG5cXFxuLy8gaWYgdGhlbiBtYXNrIGl0IGdyYWR1YWxseVxcblxcXG5mbG9hdCBpc0luRWFydGgodmVjMiB0ZXhjb29yZCwgdmVjMiBzY2VuZVNpemUpXFxuXFxcbntcXG5cXFxuICAgIHZlYzIgTkRDID0gdGV4Y29vcmQgKiAyLjAgLSAxLjA7XFxuXFxcbiAgICB2ZWM0IGVhcnRoUG9zU0MgPSBnZXRORENGcm9tV0ModmVjMygwLjApLCAwLjApO1xcblxcXG4gICAgdmVjNCBlYXJ0aFBvc1NDRWRnZSA9IGdldE5EQ0Zyb21XQyh2ZWMzKDAuMCksIGVhcnRoUmFkaXVzICogMS41KTtcXG5cXFxuICAgIE5EQy54eSAtPSBlYXJ0aFBvc1NDLnh5O1xcblxcXG5cXG5cXFxuICAgIGZsb2F0IFggPSBhYnMoTkRDLngpICogc2NlbmVTaXplLng7XFxuXFxcbiAgICBmbG9hdCBZID0gYWJzKE5EQy55KSAqIHNjZW5lU2l6ZS55O1xcblxcXG5cXG5cXFxuICAgIHJldHVybiBjbGFtcCgwLjAsIDEuMCwgbWF4KHNxcnQoWCAqIFggKyBZICogWSkgLyBtYXgoYWJzKGVhcnRoUG9zU0NFZGdlLnggKiBzY2VuZVNpemUueCksIDEuMCkgLSAwLjggLCAwLjApKTtcXG5cXFxufVxcblxcXG5cXG5cXFxuLy8gRm9yIENocm9tYXRpYyBlZmZlY3RcXG5cXFxudmVjNCB0ZXh0dXJlRGlzdG9ydGVkKHNhbXBsZXIyRCB0ZXgsIHZlYzIgdGV4Y29vcmQsIHZlYzIgZGlyZWN0aW9uLCB2ZWMzIGRpc3RvcnRpb24sIGJvb2wgaXNTcGFjZSlcXG5cXFxue1xcblxcXG4gICAgdmVjMiBzY2VuZVNpemUgPSBjem1fdmlld3BvcnQuenc7XFxuXFxcbiAgICB2ZWMzIGNvbG9yO1xcblxcXG4gICAgaWYoaXNTcGFjZSlcXG5cXFxuICAgIHtcXG5cXFxuICAgICAgICBjb2xvci5yID0gaXNJbkVhcnRoKHRleGNvb3JkICsgZGlyZWN0aW9uICogZGlzdG9ydGlvbi5yLCBzY2VuZVNpemUpICogdGV4dHVyZTJEKHRleCwgdGV4Y29vcmQgKyBkaXJlY3Rpb24gKiBkaXN0b3J0aW9uLnIpLnI7XFxuXFxcbiAgICAgICAgY29sb3IuZyA9IGlzSW5FYXJ0aCh0ZXhjb29yZCArIGRpcmVjdGlvbiAqIGRpc3RvcnRpb24uZywgc2NlbmVTaXplKSAqIHRleHR1cmUyRCh0ZXgsIHRleGNvb3JkICsgZGlyZWN0aW9uICogZGlzdG9ydGlvbi5nKS5nO1xcblxcXG4gICAgICAgIGNvbG9yLmIgPSBpc0luRWFydGgodGV4Y29vcmQgKyBkaXJlY3Rpb24gKiBkaXN0b3J0aW9uLmIsIHNjZW5lU2l6ZSkgKiB0ZXh0dXJlMkQodGV4LCB0ZXhjb29yZCArIGRpcmVjdGlvbiAqIGRpc3RvcnRpb24uYikuYjtcXG5cXFxuICAgIH1cXG5cXFxuICAgIGVsc2VcXG5cXFxuICAgIHtcXG5cXFxuICAgICAgICBjb2xvci5yID0gdGV4dHVyZTJEKHRleCwgdGV4Y29vcmQgKyBkaXJlY3Rpb24gKiBkaXN0b3J0aW9uLnIpLnI7XFxuXFxcbiAgICAgICAgY29sb3IuZyA9IHRleHR1cmUyRCh0ZXgsIHRleGNvb3JkICsgZGlyZWN0aW9uICogZGlzdG9ydGlvbi5nKS5nO1xcblxcXG4gICAgICAgIGNvbG9yLmIgPSB0ZXh0dXJlMkQodGV4LCB0ZXhjb29yZCArIGRpcmVjdGlvbiAqIGRpc3RvcnRpb24uYikuYjtcXG5cXFxuICAgIH1cXG5cXFxuICAgIHJldHVybiB2ZWM0KGNsYW1wKGNvbG9yLCAwLjAsIDEuMCksIDAuMCk7XFxuXFxcbn1cXG5cXFxuXFxuXFxcbnZvaWQgbWFpbih2b2lkKVxcblxcXG57XFxuXFxcbiAgICB2ZWM0IG9yaWdpbmFsQ29sb3IgPSB0ZXh0dXJlMkQoY29sb3JUZXh0dXJlLCB2X3RleHR1cmVDb29yZGluYXRlcyk7XFxuXFxcbiAgICB2ZWMzIHJnYiA9IG9yaWdpbmFsQ29sb3IucmdiO1xcblxcXG4gICAgYm9vbCBpc1NwYWNlID0gbGVuZ3RoKGN6bV92aWV3ZXJQb3NpdGlvbldDLnh5eikgPiBESVNUQU5DRV9UT19TUEFDRTtcXG5cXFxuXFxuXFxcbiAgICAvLyBTdW4gcG9zaXRpb25cXG5cXFxuICAgIHZlYzQgc3VuUG9zID0gY3ptX21vcnBoVGltZSA9PSAxLjAgPyB2ZWM0KGN6bV9zdW5Qb3NpdGlvbldDLCAxLjApIDogdmVjNChjem1fc3VuUG9zaXRpb25Db2x1bWJ1c1ZpZXcuenh5LCAxLjApO1xcblxcXG4gICAgdmVjNCBzdW5Qb3NpdGlvbkVDID0gY3ptX3ZpZXcgKiBzdW5Qb3M7XFxuXFxcbiAgICB2ZWM0IHN1blBvc2l0aW9uV0MgPSBjem1fZXllVG9XaW5kb3dDb29yZGluYXRlcyhzdW5Qb3NpdGlvbkVDKTtcXG5cXFxuICAgIHN1blBvcyA9IGN6bV92aWV3cG9ydE9ydGhvZ3JhcGhpYyAqIHZlYzQoc3VuUG9zaXRpb25XQy54eSwgLXN1blBvc2l0aW9uV0MueiwgMS4wKTtcXG5cXFxuXFxuXFxcbiAgICAvLyBJZiBzdW4gaXMgbm90IGluIHRoZSBzY3JlZW4gc3BhY2UsIHVzZSBvcmlnaW5hbCBjb2xvci5cXG5cXFxuICAgIGlmKCFpc1NwYWNlIHx8ICEoKHN1blBvcy54ID49IC0xLjEgJiYgc3VuUG9zLnggPD0gMS4xKSAmJiAoc3VuUG9zLnkgPj0gLTEuMSAmJiBzdW5Qb3MueSA8PSAxLjEpKSlcXG5cXFxuICAgIHtcXG5cXFxuICAgICAgICAvLyBMZW5zIGZsYXJlIGlzIGRpc2FibGVkIHdoZW4gbm90IGluIHNwYWNlIHVudGlsICM1OTMyIGlzIGZpeGVkLlxcblxcXG4gICAgICAgIC8vICAgIGh0dHBzOi8vZ2l0aHViLmNvbS9DZXNpdW1HUy9jZXNpdW0vaXNzdWVzLzU5MzJcXG5cXFxuICAgICAgICBnbF9GcmFnQ29sb3IgPSBvcmlnaW5hbENvbG9yO1xcblxcXG4gICAgICAgIHJldHVybjtcXG5cXFxuICAgIH1cXG5cXFxuXFxuXFxcbiAgICB2ZWMyIHRleGNvb3JkID0gdmVjMigxLjApIC0gdl90ZXh0dXJlQ29vcmRpbmF0ZXM7XFxuXFxcbiAgICB2ZWMyIHBpeGVsU2l6ZSA9IGN6bV9waXhlbFJhdGlvIC8gY3ptX3ZpZXdwb3J0Lnp3O1xcblxcXG4gICAgdmVjMiBpbnZQaXhlbFNpemUgPSAxLjAgLyBwaXhlbFNpemU7XFxuXFxcbiAgICB2ZWMzIGRpc3RvcnRpb25WZWMgPSBwaXhlbFNpemUueCAqIHZlYzMoLWRpc3RvcnRpb24sIDAuMCwgZGlzdG9ydGlvbik7XFxuXFxcblxcblxcXG4gICAgLy8gZ2hvc3QgdmVjdG9yIHRvIGltYWdlIGNlbnRyZTpcXG5cXFxuICAgIHZlYzIgZ2hvc3RWZWMgPSAodmVjMigwLjUpIC0gdGV4Y29vcmQpICogZ2hvc3REaXNwZXJzYWw7XFxuXFxcbiAgICB2ZWMzIGRpcmVjdGlvbiA9IG5vcm1hbGl6ZSh2ZWMzKGdob3N0VmVjLCAwLjApKTtcXG5cXFxuXFxuXFxcbiAgICAvLyBzYW1wbGUgZ2hvc3RzOlxcblxcXG4gICAgdmVjNCByZXN1bHQgPSB2ZWM0KDAuMCk7XFxuXFxcbiAgICB2ZWM0IGdob3N0ID0gdmVjNCgwLjApO1xcblxcXG4gICAgZm9yIChpbnQgaSA9IDA7IGkgPCA0OyArK2kpXFxuXFxcbiAgICB7XFxuXFxcbiAgICAgICAgdmVjMiBvZmZzZXQgPSBmcmFjdCh0ZXhjb29yZCArIGdob3N0VmVjICogZmxvYXQoaSkpO1xcblxcXG4gICAgICAgIC8vIE9ubHkgYnJpZ2h0IHNwb3RzIGZyb20gdGhlIGNlbnRyZSBvZiB0aGUgc291cmNlIGltYWdlXFxuXFxcbiAgICAgICAgZ2hvc3QgKz0gdGV4dHVyZURpc3RvcnRlZChjb2xvclRleHR1cmUsIG9mZnNldCwgZGlyZWN0aW9uLnh5LCBkaXN0b3J0aW9uVmVjLCBpc1NwYWNlKTtcXG5cXFxuICAgIH1cXG5cXFxuICAgIHJlc3VsdCArPSBnaG9zdDtcXG5cXFxuXFxuXFxcbiAgICAvLyBzYW1wbGUgaGFsb1xcblxcXG4gICAgdmVjMiBoYWxvVmVjID0gbm9ybWFsaXplKGdob3N0VmVjKSAqIGhhbG9XaWR0aDtcXG5cXFxuICAgIGZsb2F0IHdlaWdodEZvckhhbG8gPSBsZW5ndGgodmVjMigwLjUpIC0gZnJhY3QodGV4Y29vcmQgKyBoYWxvVmVjKSkgLyBsZW5ndGgodmVjMigwLjUpKTtcXG5cXFxuICAgIHdlaWdodEZvckhhbG8gPSBwb3coMS4wIC0gd2VpZ2h0Rm9ySGFsbywgNS4wKTtcXG5cXFxuXFxuXFxcbiAgICByZXN1bHQgKz0gdGV4dHVyZURpc3RvcnRlZChjb2xvclRleHR1cmUsIHRleGNvb3JkICsgaGFsb1ZlYywgZGlyZWN0aW9uLnh5LCBkaXN0b3J0aW9uVmVjLCBpc1NwYWNlKSAqIHdlaWdodEZvckhhbG8gKiAxLjU7XFxuXFxcblxcblxcXG4gICAgLy8gZGlydCBvbiBsZW5zXFxuXFxcbiAgICB2ZWMyIGRpcnRUZXhDb29yZHMgPSAodl90ZXh0dXJlQ29vcmRpbmF0ZXMgKiBpbnZQaXhlbFNpemUpIC8gZGlydFRleHR1cmVEaW1lbnNpb25zO1xcblxcXG4gICAgaWYgKGRpcnRUZXhDb29yZHMueCA+IDEuMClcXG5cXFxuICAgIHtcXG5cXFxuICAgICAgICBkaXJ0VGV4Q29vcmRzLnggPSBtb2QoZmxvb3IoZGlydFRleENvb3Jkcy54KSwgMi4wKSA9PSAxLjAgPyAxLjAgLSBmcmFjdChkaXJ0VGV4Q29vcmRzLngpIDogIGZyYWN0KGRpcnRUZXhDb29yZHMueCk7XFxuXFxcbiAgICB9XFxuXFxcbiAgICBpZiAoZGlydFRleENvb3Jkcy55ID4gMS4wKVxcblxcXG4gICAge1xcblxcXG4gICAgICAgIGRpcnRUZXhDb29yZHMueSA9IG1vZChmbG9vcihkaXJ0VGV4Q29vcmRzLnkpLCAyLjApID09IDEuMCA/IDEuMCAtIGZyYWN0KGRpcnRUZXhDb29yZHMueSkgOiAgZnJhY3QoZGlydFRleENvb3Jkcy55KTtcXG5cXFxuICAgIH1cXG5cXFxuICAgIHJlc3VsdCArPSBkaXJ0QW1vdW50ICogdGV4dHVyZTJEKGRpcnRUZXh0dXJlLCBkaXJ0VGV4Q29vcmRzKTtcXG5cXFxuXFxuXFxcbiAgICAvLyBSb3RhdGluZyBzdGFyYnVyc3QgdGV4dHVyZSdzIGNvb3JkaW5hdGVcXG5cXFxuICAgIC8vIGRvdChjem1fdmlld1swXS54eXosIHZlYzMoMC4wLCAwLjAsIDEuMCkpICsgZG90KGN6bV92aWV3WzFdLnh5eiwgdmVjMygwLjAsIDEuMCwgMC4wKSlcXG5cXFxuICAgIGZsb2F0IGNhbXJvdCA9IGN6bV92aWV3WzBdLnogKyBjem1fdmlld1sxXS55O1xcblxcXG4gICAgZmxvYXQgY29zVmFsdWUgPSBjb3MoY2Ftcm90KTtcXG5cXFxuICAgIGZsb2F0IHNpblZhbHVlID0gc2luKGNhbXJvdCk7XFxuXFxcbiAgICBtYXQzIHJvdGF0aW9uID0gbWF0MyhcXG5cXFxuICAgICAgICBjb3NWYWx1ZSwgLXNpblZhbHVlLCAwLjAsXFxuXFxcbiAgICAgICAgc2luVmFsdWUsIGNvc1ZhbHVlLCAwLjAsXFxuXFxcbiAgICAgICAgMC4wLCAwLjAsIDEuMFxcblxcXG4gICAgKTtcXG5cXFxuXFxuXFxcbiAgICB2ZWMzIHN0MSA9IHZlYzModl90ZXh0dXJlQ29vcmRpbmF0ZXMgKiAyLjAgLSB2ZWMyKDEuMCksIDEuMCk7XFxuXFxcbiAgICB2ZWMzIHN0MiA9IHZlYzMoKHJvdGF0aW9uICogc3QxKS54eSwgMS4wKTtcXG5cXFxuICAgIHZlYzMgc3QzID0gc3QyICogMC41ICsgdmVjMygwLjUpO1xcblxcXG4gICAgdmVjMiBsZW5zU3RhclRleGNvb3JkID0gc3QzLnh5O1xcblxcXG4gICAgZmxvYXQgd2VpZ2h0Rm9yTGVuc0ZsYXJlID0gbGVuZ3RoKHZlYzMoc3VuUG9zLnh5LCAwLjApKTtcXG5cXFxuICAgIGZsb2F0IG9uZU1pbnVzV2VpZ2h0Rm9yTGVuc0ZsYXJlID0gbWF4KDEuMCAtIHdlaWdodEZvckxlbnNGbGFyZSwgMC4wKTtcXG5cXFxuXFxuXFxcbiAgICBpZiAoIWlzU3BhY2UpXFxuXFxcbiAgICB7XFxuXFxcbiAgICAgICAgcmVzdWx0ICo9IG9uZU1pbnVzV2VpZ2h0Rm9yTGVuc0ZsYXJlICogaW50ZW5zaXR5ICogMC4yO1xcblxcXG4gICAgfVxcblxcXG4gICAgZWxzZVxcblxcXG4gICAge1xcblxcXG4gICAgICAgIHJlc3VsdCAqPSBvbmVNaW51c1dlaWdodEZvckxlbnNGbGFyZSAqIGludGVuc2l0eTtcXG5cXFxuICAgICAgICByZXN1bHQgKj0gdGV4dHVyZTJEKHN0YXJUZXh0dXJlLCBsZW5zU3RhclRleGNvb3JkKSAqIHBvdyh3ZWlnaHRGb3JMZW5zRmxhcmUsIDEuMCkgKiBtYXgoKDEuMCAtIGxlbmd0aCh2ZWMzKHN0MS54eSwgMC4wKSkpLCAwLjApICogMi4wO1xcblxcXG4gICAgfVxcblxcXG5cXG5cXFxuICAgIHJlc3VsdCArPSB0ZXh0dXJlMkQoY29sb3JUZXh0dXJlLCB2X3RleHR1cmVDb29yZGluYXRlcyk7XFxuXFxcblxcblxcXG4gICAgZ2xfRnJhZ0NvbG9yID0gcmVzdWx0O1xcblxcXG59XFxuXFxcblwiO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///99182\n')},47784:function(__unused_webpack___webpack_module__,__webpack_exports__){eval('//This file is automatically rebuilt by the Cesium build process.\n/* harmony default export */ __webpack_exports__["Z"] = ("uniform sampler2D colorTexture;\\n\\\nuniform vec3 white;\\n\\\n\\n\\\nvarying vec2 v_textureCoordinates;\\n\\\n\\n\\\n#ifdef AUTO_EXPOSURE\\n\\\nuniform sampler2D autoExposure;\\n\\\n#endif\\n\\\n\\n\\\n// See equation 4:\\n\\\n//    http://www.cs.utah.edu/~reinhard/cdrom/tonemap.pdf\\n\\\n\\n\\\nvoid main()\\n\\\n{\\n\\\n    vec4 fragmentColor = texture2D(colorTexture, v_textureCoordinates);\\n\\\n    vec3 color = fragmentColor.rgb;\\n\\\n#ifdef AUTO_EXPOSURE\\n\\\n    float exposure = texture2D(autoExposure, vec2(0.5)).r;\\n\\\n    color /= exposure;\\n\\\n#endif\\n\\\n    color = (color * (1.0 + color / white)) / (1.0 + color);\\n\\\n    color = czm_inverseGamma(color);\\n\\\n    gl_FragColor = vec4(color, fragmentColor.a);\\n\\\n}\\n\\\n");\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNDc3ODQuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQSx5REFBZSxnQ0FBZ0M7QUFDL0MsbUJBQW1CO0FBQ25CO0FBQ0Esa0NBQWtDO0FBQ2xDO0FBQ0E7QUFDQSwrQkFBK0I7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNELHVFQUF1RTtBQUN2RSxtQ0FBbUM7QUFDbkM7QUFDQSwwREFBMEQ7QUFDMUQsc0JBQXNCO0FBQ3RCO0FBQ0EsNERBQTREO0FBQzVELG9DQUFvQztBQUNwQyxnREFBZ0Q7QUFDaEQsQ0FBQztBQUNELENBQUMsRUFBQyIsInNvdXJjZXMiOlsid2VicGFjazovL3Z1ZTMtd2VicGFjazUvLi9ub2RlX21vZHVsZXMvY2VzaXVtL1NvdXJjZS9TaGFkZXJzL1Bvc3RQcm9jZXNzU3RhZ2VzL01vZGlmaWVkUmVpbmhhcmRUb25lbWFwcGluZy5qcz85NTgxIl0sInNvdXJjZXNDb250ZW50IjpbIi8vVGhpcyBmaWxlIGlzIGF1dG9tYXRpY2FsbHkgcmVidWlsdCBieSB0aGUgQ2VzaXVtIGJ1aWxkIHByb2Nlc3MuXG5leHBvcnQgZGVmYXVsdCBcInVuaWZvcm0gc2FtcGxlcjJEIGNvbG9yVGV4dHVyZTtcXG5cXFxudW5pZm9ybSB2ZWMzIHdoaXRlO1xcblxcXG5cXG5cXFxudmFyeWluZyB2ZWMyIHZfdGV4dHVyZUNvb3JkaW5hdGVzO1xcblxcXG5cXG5cXFxuI2lmZGVmIEFVVE9fRVhQT1NVUkVcXG5cXFxudW5pZm9ybSBzYW1wbGVyMkQgYXV0b0V4cG9zdXJlO1xcblxcXG4jZW5kaWZcXG5cXFxuXFxuXFxcbi8vIFNlZSBlcXVhdGlvbiA0OlxcblxcXG4vLyAgICBodHRwOi8vd3d3LmNzLnV0YWguZWR1L35yZWluaGFyZC9jZHJvbS90b25lbWFwLnBkZlxcblxcXG5cXG5cXFxudm9pZCBtYWluKClcXG5cXFxue1xcblxcXG4gICAgdmVjNCBmcmFnbWVudENvbG9yID0gdGV4dHVyZTJEKGNvbG9yVGV4dHVyZSwgdl90ZXh0dXJlQ29vcmRpbmF0ZXMpO1xcblxcXG4gICAgdmVjMyBjb2xvciA9IGZyYWdtZW50Q29sb3IucmdiO1xcblxcXG4jaWZkZWYgQVVUT19FWFBPU1VSRVxcblxcXG4gICAgZmxvYXQgZXhwb3N1cmUgPSB0ZXh0dXJlMkQoYXV0b0V4cG9zdXJlLCB2ZWMyKDAuNSkpLnI7XFxuXFxcbiAgICBjb2xvciAvPSBleHBvc3VyZTtcXG5cXFxuI2VuZGlmXFxuXFxcbiAgICBjb2xvciA9IChjb2xvciAqICgxLjAgKyBjb2xvciAvIHdoaXRlKSkgLyAoMS4wICsgY29sb3IpO1xcblxcXG4gICAgY29sb3IgPSBjem1faW52ZXJzZUdhbW1hKGNvbG9yKTtcXG5cXFxuICAgIGdsX0ZyYWdDb2xvciA9IHZlYzQoY29sb3IsIGZyYWdtZW50Q29sb3IuYSk7XFxuXFxcbn1cXG5cXFxuXCI7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///47784\n')},50920:function(__unused_webpack___webpack_module__,__webpack_exports__){eval('//This file is automatically rebuilt by the Cesium build process.\n/* harmony default export */ __webpack_exports__["Z"] = ("uniform sampler2D colorTexture;\\n\\\n\\n\\\nvarying vec2 v_textureCoordinates;\\n\\\n\\n\\\nfloat rand(vec2 co)\\n\\\n{\\n\\\n    return fract(sin(dot(co.xy ,vec2(12.9898, 78.233))) * 43758.5453);\\n\\\n}\\n\\\n\\n\\\nvoid main(void)\\n\\\n{\\n\\\n    float noiseValue = rand(v_textureCoordinates + sin(czm_frameNumber)) * 0.1;\\n\\\n    vec3 rgb = texture2D(colorTexture, v_textureCoordinates).rgb;\\n\\\n    vec3 green = vec3(0.0, 1.0, 0.0);\\n\\\n    gl_FragColor = vec4((noiseValue + rgb) * green, 1.0);\\n\\\n}\\n\\\n");\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNTA5MjAuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQSx5REFBZSxnQ0FBZ0M7QUFDL0M7QUFDQSxrQ0FBa0M7QUFDbEM7QUFDQTtBQUNBLENBQUM7QUFDRCxzRUFBc0U7QUFDdEUsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0QsK0VBQStFO0FBQy9FLGlFQUFpRTtBQUNqRSxxQ0FBcUM7QUFDckMseURBQXlEO0FBQ3pELENBQUM7QUFDRCxDQUFDLEVBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly92dWUzLXdlYnBhY2s1Ly4vbm9kZV9tb2R1bGVzL2Nlc2l1bS9Tb3VyY2UvU2hhZGVycy9Qb3N0UHJvY2Vzc1N0YWdlcy9OaWdodFZpc2lvbi5qcz9kMDE1Il0sInNvdXJjZXNDb250ZW50IjpbIi8vVGhpcyBmaWxlIGlzIGF1dG9tYXRpY2FsbHkgcmVidWlsdCBieSB0aGUgQ2VzaXVtIGJ1aWxkIHByb2Nlc3MuXG5leHBvcnQgZGVmYXVsdCBcInVuaWZvcm0gc2FtcGxlcjJEIGNvbG9yVGV4dHVyZTtcXG5cXFxuXFxuXFxcbnZhcnlpbmcgdmVjMiB2X3RleHR1cmVDb29yZGluYXRlcztcXG5cXFxuXFxuXFxcbmZsb2F0IHJhbmQodmVjMiBjbylcXG5cXFxue1xcblxcXG4gICAgcmV0dXJuIGZyYWN0KHNpbihkb3QoY28ueHkgLHZlYzIoMTIuOTg5OCwgNzguMjMzKSkpICogNDM3NTguNTQ1Myk7XFxuXFxcbn1cXG5cXFxuXFxuXFxcbnZvaWQgbWFpbih2b2lkKVxcblxcXG57XFxuXFxcbiAgICBmbG9hdCBub2lzZVZhbHVlID0gcmFuZCh2X3RleHR1cmVDb29yZGluYXRlcyArIHNpbihjem1fZnJhbWVOdW1iZXIpKSAqIDAuMTtcXG5cXFxuICAgIHZlYzMgcmdiID0gdGV4dHVyZTJEKGNvbG9yVGV4dHVyZSwgdl90ZXh0dXJlQ29vcmRpbmF0ZXMpLnJnYjtcXG5cXFxuICAgIHZlYzMgZ3JlZW4gPSB2ZWMzKDAuMCwgMS4wLCAwLjApO1xcblxcXG4gICAgZ2xfRnJhZ0NvbG9yID0gdmVjNCgobm9pc2VWYWx1ZSArIHJnYikgKiBncmVlbiwgMS4wKTtcXG5cXFxufVxcblxcXG5cIjtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///50920\n')},7571:function(__unused_webpack___webpack_module__,__webpack_exports__){eval('//This file is automatically rebuilt by the Cesium build process.\n/* harmony default export */ __webpack_exports__["Z"] = ("uniform sampler2D colorTexture;\\n\\\n\\n\\\nvarying vec2 v_textureCoordinates;\\n\\\n\\n\\\nvoid main()\\n\\\n{\\n\\\n    gl_FragColor = texture2D(colorTexture, v_textureCoordinates);\\n\\\n}\\n\\\n");\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNzU3MS5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBLHlEQUFlLGdDQUFnQztBQUMvQztBQUNBLGtDQUFrQztBQUNsQztBQUNBO0FBQ0EsQ0FBQztBQUNELGlFQUFpRTtBQUNqRSxDQUFDO0FBQ0QsQ0FBQyxFQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdnVlMy13ZWJwYWNrNS8uL25vZGVfbW9kdWxlcy9jZXNpdW0vU291cmNlL1NoYWRlcnMvUG9zdFByb2Nlc3NTdGFnZXMvUGFzc1Rocm91Z2guanM/NjBlZiJdLCJzb3VyY2VzQ29udGVudCI6WyIvL1RoaXMgZmlsZSBpcyBhdXRvbWF0aWNhbGx5IHJlYnVpbHQgYnkgdGhlIENlc2l1bSBidWlsZCBwcm9jZXNzLlxuZXhwb3J0IGRlZmF1bHQgXCJ1bmlmb3JtIHNhbXBsZXIyRCBjb2xvclRleHR1cmU7XFxuXFxcblxcblxcXG52YXJ5aW5nIHZlYzIgdl90ZXh0dXJlQ29vcmRpbmF0ZXM7XFxuXFxcblxcblxcXG52b2lkIG1haW4oKVxcblxcXG57XFxuXFxcbiAgICBnbF9GcmFnQ29sb3IgPSB0ZXh0dXJlMkQoY29sb3JUZXh0dXJlLCB2X3RleHR1cmVDb29yZGluYXRlcyk7XFxuXFxcbn1cXG5cXFxuXCI7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///7571\n')},82239:function(__unused_webpack___webpack_module__,__webpack_exports__){eval('//This file is automatically rebuilt by the Cesium build process.\n/* harmony default export */ __webpack_exports__["Z"] = ("uniform highp sampler2D u_depthTexture;\\n\\\n\\n\\\nvarying vec2 v_textureCoordinates;\\n\\\n\\n\\\nvoid main()\\n\\\n{\\n\\\n    gl_FragColor = czm_packDepth(texture2D(u_depthTexture, v_textureCoordinates).r);\\n\\\n}\\n\\\n");\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiODIyMzkuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQSx5REFBZSx3Q0FBd0M7QUFDdkQ7QUFDQSxrQ0FBa0M7QUFDbEM7QUFDQTtBQUNBLENBQUM7QUFDRCxvRkFBb0Y7QUFDcEYsQ0FBQztBQUNELENBQUMsRUFBQyIsInNvdXJjZXMiOlsid2VicGFjazovL3Z1ZTMtd2VicGFjazUvLi9ub2RlX21vZHVsZXMvY2VzaXVtL1NvdXJjZS9TaGFkZXJzL1Bvc3RQcm9jZXNzU3RhZ2VzL1Bhc3NUaHJvdWdoRGVwdGguanM/NTljYSJdLCJzb3VyY2VzQ29udGVudCI6WyIvL1RoaXMgZmlsZSBpcyBhdXRvbWF0aWNhbGx5IHJlYnVpbHQgYnkgdGhlIENlc2l1bSBidWlsZCBwcm9jZXNzLlxuZXhwb3J0IGRlZmF1bHQgXCJ1bmlmb3JtIGhpZ2hwIHNhbXBsZXIyRCB1X2RlcHRoVGV4dHVyZTtcXG5cXFxuXFxuXFxcbnZhcnlpbmcgdmVjMiB2X3RleHR1cmVDb29yZGluYXRlcztcXG5cXFxuXFxuXFxcbnZvaWQgbWFpbigpXFxuXFxcbntcXG5cXFxuICAgIGdsX0ZyYWdDb2xvciA9IGN6bV9wYWNrRGVwdGgodGV4dHVyZTJEKHVfZGVwdGhUZXh0dXJlLCB2X3RleHR1cmVDb29yZGluYXRlcykucik7XFxuXFxcbn1cXG5cXFxuXCI7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///82239\n')},43474:function(__unused_webpack___webpack_module__,__webpack_exports__){eval('//This file is automatically rebuilt by the Cesium build process.\n/* harmony default export */ __webpack_exports__["Z"] = ("#extension GL_EXT_frag_depth : enable\\n\\\n\\n\\\nuniform sampler2D u_pointCloud_colorGBuffer;\\n\\\nuniform sampler2D u_pointCloud_depthGBuffer;\\n\\\nuniform vec2 u_distanceAndEdlStrength;\\n\\\nvarying vec2 v_textureCoordinates;\\n\\\n\\n\\\nvec2 neighborContribution(float log2Depth, vec2 offset)\\n\\\n{\\n\\\n    float dist = u_distanceAndEdlStrength.x;\\n\\\n    vec2 texCoordOrig = v_textureCoordinates + offset * dist;\\n\\\n    vec2 texCoord0 = v_textureCoordinates + offset * floor(dist);\\n\\\n    vec2 texCoord1 = v_textureCoordinates + offset * ceil(dist);\\n\\\n\\n\\\n    float depthOrLogDepth0 = czm_unpackDepth(texture2D(u_pointCloud_depthGBuffer, texCoord0));\\n\\\n    float depthOrLogDepth1 = czm_unpackDepth(texture2D(u_pointCloud_depthGBuffer, texCoord1));\\n\\\n\\n\\\n    // ignore depth values that are the clear depth\\n\\\n    if (depthOrLogDepth0 == 0.0 || depthOrLogDepth1 == 0.0) {\\n\\\n        return vec2(0.0);\\n\\\n    }\\n\\\n\\n\\\n    // interpolate the two adjacent depth values\\n\\\n    float depthMix = mix(depthOrLogDepth0, depthOrLogDepth1, fract(dist));\\n\\\n    vec4 eyeCoordinate = czm_windowToEyeCoordinates(texCoordOrig, depthMix);\\n\\\n    return vec2(max(0.0, log2Depth - log2(-eyeCoordinate.z / eyeCoordinate.w)), 1.0);\\n\\\n}\\n\\\n\\n\\\nvoid main()\\n\\\n{\\n\\\n    float depthOrLogDepth = czm_unpackDepth(texture2D(u_pointCloud_depthGBuffer, v_textureCoordinates));\\n\\\n\\n\\\n    vec4 eyeCoordinate = czm_windowToEyeCoordinates(gl_FragCoord.xy, depthOrLogDepth);\\n\\\n    eyeCoordinate /= eyeCoordinate.w;\\n\\\n\\n\\\n    float log2Depth = log2(-eyeCoordinate.z);\\n\\\n\\n\\\n    if (depthOrLogDepth == 0.0) // 0.0 is the clear value for the gbuffer\\n\\\n    {\\n\\\n        discard;\\n\\\n    }\\n\\\n\\n\\\n    vec4 color = texture2D(u_pointCloud_colorGBuffer, v_textureCoordinates);\\n\\\n\\n\\\n    // sample from neighbors left, right, down, up\\n\\\n    vec2 texelSize = 1.0 / czm_viewport.zw;\\n\\\n\\n\\\n    vec2 responseAndCount = vec2(0.0);\\n\\\n\\n\\\n    responseAndCount += neighborContribution(log2Depth, vec2(-texelSize.x, 0.0));\\n\\\n    responseAndCount += neighborContribution(log2Depth, vec2(+texelSize.x, 0.0));\\n\\\n    responseAndCount += neighborContribution(log2Depth, vec2(0.0, -texelSize.y));\\n\\\n    responseAndCount += neighborContribution(log2Depth, vec2(0.0, +texelSize.y));\\n\\\n\\n\\\n    float response = responseAndCount.x / responseAndCount.y;\\n\\\n    float strength = u_distanceAndEdlStrength.y;\\n\\\n    float shade = exp(-response * 300.0 * strength);\\n\\\n    color.rgb *= shade;\\n\\\n    gl_FragColor = vec4(color);\\n\\\n\\n\\\n    // Input and output depth are the same.\\n\\\n    gl_FragDepthEXT = depthOrLogDepth;\\n\\\n}\\n\\\n");\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNDM0NzQuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQSx5REFBZTtBQUNmO0FBQ0EsNENBQTRDO0FBQzVDLDRDQUE0QztBQUM1QyxzQ0FBc0M7QUFDdEMsa0NBQWtDO0FBQ2xDO0FBQ0E7QUFDQSxDQUFDO0FBQ0QsNENBQTRDO0FBQzVDLDZEQUE2RDtBQUM3RCxpRUFBaUU7QUFDakUsZ0VBQWdFO0FBQ2hFO0FBQ0EsOEZBQThGO0FBQzlGLDhGQUE4RjtBQUM5RjtBQUNBO0FBQ0EsNkRBQTZEO0FBQzdELHlCQUF5QjtBQUN6QixLQUFLO0FBQ0w7QUFDQTtBQUNBLDBFQUEwRTtBQUMxRSw0RUFBNEU7QUFDNUUscUZBQXFGO0FBQ3JGLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNELHdHQUF3RztBQUN4RztBQUNBLHNGQUFzRjtBQUN0RixxQ0FBcUM7QUFDckM7QUFDQSw2Q0FBNkM7QUFDN0M7QUFDQTtBQUNBLEtBQUs7QUFDTCxnQkFBZ0I7QUFDaEIsS0FBSztBQUNMO0FBQ0EsNEVBQTRFO0FBQzVFO0FBQ0E7QUFDQSwyQ0FBMkM7QUFDM0M7QUFDQSxzQ0FBc0M7QUFDdEM7QUFDQSxpRkFBaUY7QUFDakYsaUZBQWlGO0FBQ2pGLGlGQUFpRjtBQUNqRixpRkFBaUY7QUFDakY7QUFDQSw2REFBNkQ7QUFDN0QsZ0RBQWdEO0FBQ2hELG9EQUFvRDtBQUNwRCx1QkFBdUI7QUFDdkIsK0JBQStCO0FBQy9CO0FBQ0E7QUFDQSxzQ0FBc0M7QUFDdEMsQ0FBQztBQUNELENBQUMsRUFBQyIsInNvdXJjZXMiOlsid2VicGFjazovL3Z1ZTMtd2VicGFjazUvLi9ub2RlX21vZHVsZXMvY2VzaXVtL1NvdXJjZS9TaGFkZXJzL1Bvc3RQcm9jZXNzU3RhZ2VzL1BvaW50Q2xvdWRFeWVEb21lTGlnaHRpbmcuanM/Mjk0NyJdLCJzb3VyY2VzQ29udGVudCI6WyIvL1RoaXMgZmlsZSBpcyBhdXRvbWF0aWNhbGx5IHJlYnVpbHQgYnkgdGhlIENlc2l1bSBidWlsZCBwcm9jZXNzLlxuZXhwb3J0IGRlZmF1bHQgXCIjZXh0ZW5zaW9uIEdMX0VYVF9mcmFnX2RlcHRoIDogZW5hYmxlXFxuXFxcblxcblxcXG51bmlmb3JtIHNhbXBsZXIyRCB1X3BvaW50Q2xvdWRfY29sb3JHQnVmZmVyO1xcblxcXG51bmlmb3JtIHNhbXBsZXIyRCB1X3BvaW50Q2xvdWRfZGVwdGhHQnVmZmVyO1xcblxcXG51bmlmb3JtIHZlYzIgdV9kaXN0YW5jZUFuZEVkbFN0cmVuZ3RoO1xcblxcXG52YXJ5aW5nIHZlYzIgdl90ZXh0dXJlQ29vcmRpbmF0ZXM7XFxuXFxcblxcblxcXG52ZWMyIG5laWdoYm9yQ29udHJpYnV0aW9uKGZsb2F0IGxvZzJEZXB0aCwgdmVjMiBvZmZzZXQpXFxuXFxcbntcXG5cXFxuICAgIGZsb2F0IGRpc3QgPSB1X2Rpc3RhbmNlQW5kRWRsU3RyZW5ndGgueDtcXG5cXFxuICAgIHZlYzIgdGV4Q29vcmRPcmlnID0gdl90ZXh0dXJlQ29vcmRpbmF0ZXMgKyBvZmZzZXQgKiBkaXN0O1xcblxcXG4gICAgdmVjMiB0ZXhDb29yZDAgPSB2X3RleHR1cmVDb29yZGluYXRlcyArIG9mZnNldCAqIGZsb29yKGRpc3QpO1xcblxcXG4gICAgdmVjMiB0ZXhDb29yZDEgPSB2X3RleHR1cmVDb29yZGluYXRlcyArIG9mZnNldCAqIGNlaWwoZGlzdCk7XFxuXFxcblxcblxcXG4gICAgZmxvYXQgZGVwdGhPckxvZ0RlcHRoMCA9IGN6bV91bnBhY2tEZXB0aCh0ZXh0dXJlMkQodV9wb2ludENsb3VkX2RlcHRoR0J1ZmZlciwgdGV4Q29vcmQwKSk7XFxuXFxcbiAgICBmbG9hdCBkZXB0aE9yTG9nRGVwdGgxID0gY3ptX3VucGFja0RlcHRoKHRleHR1cmUyRCh1X3BvaW50Q2xvdWRfZGVwdGhHQnVmZmVyLCB0ZXhDb29yZDEpKTtcXG5cXFxuXFxuXFxcbiAgICAvLyBpZ25vcmUgZGVwdGggdmFsdWVzIHRoYXQgYXJlIHRoZSBjbGVhciBkZXB0aFxcblxcXG4gICAgaWYgKGRlcHRoT3JMb2dEZXB0aDAgPT0gMC4wIHx8IGRlcHRoT3JMb2dEZXB0aDEgPT0gMC4wKSB7XFxuXFxcbiAgICAgICAgcmV0dXJuIHZlYzIoMC4wKTtcXG5cXFxuICAgIH1cXG5cXFxuXFxuXFxcbiAgICAvLyBpbnRlcnBvbGF0ZSB0aGUgdHdvIGFkamFjZW50IGRlcHRoIHZhbHVlc1xcblxcXG4gICAgZmxvYXQgZGVwdGhNaXggPSBtaXgoZGVwdGhPckxvZ0RlcHRoMCwgZGVwdGhPckxvZ0RlcHRoMSwgZnJhY3QoZGlzdCkpO1xcblxcXG4gICAgdmVjNCBleWVDb29yZGluYXRlID0gY3ptX3dpbmRvd1RvRXllQ29vcmRpbmF0ZXModGV4Q29vcmRPcmlnLCBkZXB0aE1peCk7XFxuXFxcbiAgICByZXR1cm4gdmVjMihtYXgoMC4wLCBsb2cyRGVwdGggLSBsb2cyKC1leWVDb29yZGluYXRlLnogLyBleWVDb29yZGluYXRlLncpKSwgMS4wKTtcXG5cXFxufVxcblxcXG5cXG5cXFxudm9pZCBtYWluKClcXG5cXFxue1xcblxcXG4gICAgZmxvYXQgZGVwdGhPckxvZ0RlcHRoID0gY3ptX3VucGFja0RlcHRoKHRleHR1cmUyRCh1X3BvaW50Q2xvdWRfZGVwdGhHQnVmZmVyLCB2X3RleHR1cmVDb29yZGluYXRlcykpO1xcblxcXG5cXG5cXFxuICAgIHZlYzQgZXllQ29vcmRpbmF0ZSA9IGN6bV93aW5kb3dUb0V5ZUNvb3JkaW5hdGVzKGdsX0ZyYWdDb29yZC54eSwgZGVwdGhPckxvZ0RlcHRoKTtcXG5cXFxuICAgIGV5ZUNvb3JkaW5hdGUgLz0gZXllQ29vcmRpbmF0ZS53O1xcblxcXG5cXG5cXFxuICAgIGZsb2F0IGxvZzJEZXB0aCA9IGxvZzIoLWV5ZUNvb3JkaW5hdGUueik7XFxuXFxcblxcblxcXG4gICAgaWYgKGRlcHRoT3JMb2dEZXB0aCA9PSAwLjApIC8vIDAuMCBpcyB0aGUgY2xlYXIgdmFsdWUgZm9yIHRoZSBnYnVmZmVyXFxuXFxcbiAgICB7XFxuXFxcbiAgICAgICAgZGlzY2FyZDtcXG5cXFxuICAgIH1cXG5cXFxuXFxuXFxcbiAgICB2ZWM0IGNvbG9yID0gdGV4dHVyZTJEKHVfcG9pbnRDbG91ZF9jb2xvckdCdWZmZXIsIHZfdGV4dHVyZUNvb3JkaW5hdGVzKTtcXG5cXFxuXFxuXFxcbiAgICAvLyBzYW1wbGUgZnJvbSBuZWlnaGJvcnMgbGVmdCwgcmlnaHQsIGRvd24sIHVwXFxuXFxcbiAgICB2ZWMyIHRleGVsU2l6ZSA9IDEuMCAvIGN6bV92aWV3cG9ydC56dztcXG5cXFxuXFxuXFxcbiAgICB2ZWMyIHJlc3BvbnNlQW5kQ291bnQgPSB2ZWMyKDAuMCk7XFxuXFxcblxcblxcXG4gICAgcmVzcG9uc2VBbmRDb3VudCArPSBuZWlnaGJvckNvbnRyaWJ1dGlvbihsb2cyRGVwdGgsIHZlYzIoLXRleGVsU2l6ZS54LCAwLjApKTtcXG5cXFxuICAgIHJlc3BvbnNlQW5kQ291bnQgKz0gbmVpZ2hib3JDb250cmlidXRpb24obG9nMkRlcHRoLCB2ZWMyKCt0ZXhlbFNpemUueCwgMC4wKSk7XFxuXFxcbiAgICByZXNwb25zZUFuZENvdW50ICs9IG5laWdoYm9yQ29udHJpYnV0aW9uKGxvZzJEZXB0aCwgdmVjMigwLjAsIC10ZXhlbFNpemUueSkpO1xcblxcXG4gICAgcmVzcG9uc2VBbmRDb3VudCArPSBuZWlnaGJvckNvbnRyaWJ1dGlvbihsb2cyRGVwdGgsIHZlYzIoMC4wLCArdGV4ZWxTaXplLnkpKTtcXG5cXFxuXFxuXFxcbiAgICBmbG9hdCByZXNwb25zZSA9IHJlc3BvbnNlQW5kQ291bnQueCAvIHJlc3BvbnNlQW5kQ291bnQueTtcXG5cXFxuICAgIGZsb2F0IHN0cmVuZ3RoID0gdV9kaXN0YW5jZUFuZEVkbFN0cmVuZ3RoLnk7XFxuXFxcbiAgICBmbG9hdCBzaGFkZSA9IGV4cCgtcmVzcG9uc2UgKiAzMDAuMCAqIHN0cmVuZ3RoKTtcXG5cXFxuICAgIGNvbG9yLnJnYiAqPSBzaGFkZTtcXG5cXFxuICAgIGdsX0ZyYWdDb2xvciA9IHZlYzQoY29sb3IpO1xcblxcXG5cXG5cXFxuICAgIC8vIElucHV0IGFuZCBvdXRwdXQgZGVwdGggYXJlIHRoZSBzYW1lLlxcblxcXG4gICAgZ2xfRnJhZ0RlcHRoRVhUID0gZGVwdGhPckxvZ0RlcHRoO1xcblxcXG59XFxuXFxcblwiO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///43474\n')},51552:function(__unused_webpack___webpack_module__,__webpack_exports__){eval('//This file is automatically rebuilt by the Cesium build process.\n/* harmony default export */ __webpack_exports__["Z"] = ("uniform sampler2D colorTexture;\\n\\\n\\n\\\nvarying vec2 v_textureCoordinates;\\n\\\n\\n\\\n#ifdef AUTO_EXPOSURE\\n\\\nuniform sampler2D autoExposure;\\n\\\n#endif\\n\\\n\\n\\\n// See equation 3:\\n\\\n//    http://www.cs.utah.edu/~reinhard/cdrom/tonemap.pdf\\n\\\n\\n\\\nvoid main()\\n\\\n{\\n\\\n    vec4 fragmentColor = texture2D(colorTexture, v_textureCoordinates);\\n\\\n    vec3 color = fragmentColor.rgb;\\n\\\n#ifdef AUTO_EXPOSURE\\n\\\n    float exposure = texture2D(autoExposure, vec2(0.5)).r;\\n\\\n    color /= exposure;\\n\\\n#endif\\n\\\n    color = color / (1.0 + color);\\n\\\n    color = czm_inverseGamma(color);\\n\\\n    gl_FragColor = vec4(color, fragmentColor.a);\\n\\\n}\\n\\\n");\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNTE1NTIuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQSx5REFBZSxnQ0FBZ0M7QUFDL0M7QUFDQSxrQ0FBa0M7QUFDbEM7QUFDQTtBQUNBLCtCQUErQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0QsdUVBQXVFO0FBQ3ZFLG1DQUFtQztBQUNuQztBQUNBLDBEQUEwRDtBQUMxRCxzQkFBc0I7QUFDdEI7QUFDQSxrQ0FBa0M7QUFDbEMsb0NBQW9DO0FBQ3BDLGdEQUFnRDtBQUNoRCxDQUFDO0FBQ0QsQ0FBQyxFQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdnVlMy13ZWJwYWNrNS8uL25vZGVfbW9kdWxlcy9jZXNpdW0vU291cmNlL1NoYWRlcnMvUG9zdFByb2Nlc3NTdGFnZXMvUmVpbmhhcmRUb25lbWFwcGluZy5qcz8wYTdkIl0sInNvdXJjZXNDb250ZW50IjpbIi8vVGhpcyBmaWxlIGlzIGF1dG9tYXRpY2FsbHkgcmVidWlsdCBieSB0aGUgQ2VzaXVtIGJ1aWxkIHByb2Nlc3MuXG5leHBvcnQgZGVmYXVsdCBcInVuaWZvcm0gc2FtcGxlcjJEIGNvbG9yVGV4dHVyZTtcXG5cXFxuXFxuXFxcbnZhcnlpbmcgdmVjMiB2X3RleHR1cmVDb29yZGluYXRlcztcXG5cXFxuXFxuXFxcbiNpZmRlZiBBVVRPX0VYUE9TVVJFXFxuXFxcbnVuaWZvcm0gc2FtcGxlcjJEIGF1dG9FeHBvc3VyZTtcXG5cXFxuI2VuZGlmXFxuXFxcblxcblxcXG4vLyBTZWUgZXF1YXRpb24gMzpcXG5cXFxuLy8gICAgaHR0cDovL3d3dy5jcy51dGFoLmVkdS9+cmVpbmhhcmQvY2Ryb20vdG9uZW1hcC5wZGZcXG5cXFxuXFxuXFxcbnZvaWQgbWFpbigpXFxuXFxcbntcXG5cXFxuICAgIHZlYzQgZnJhZ21lbnRDb2xvciA9IHRleHR1cmUyRChjb2xvclRleHR1cmUsIHZfdGV4dHVyZUNvb3JkaW5hdGVzKTtcXG5cXFxuICAgIHZlYzMgY29sb3IgPSBmcmFnbWVudENvbG9yLnJnYjtcXG5cXFxuI2lmZGVmIEFVVE9fRVhQT1NVUkVcXG5cXFxuICAgIGZsb2F0IGV4cG9zdXJlID0gdGV4dHVyZTJEKGF1dG9FeHBvc3VyZSwgdmVjMigwLjUpKS5yO1xcblxcXG4gICAgY29sb3IgLz0gZXhwb3N1cmU7XFxuXFxcbiNlbmRpZlxcblxcXG4gICAgY29sb3IgPSBjb2xvciAvICgxLjAgKyBjb2xvcik7XFxuXFxcbiAgICBjb2xvciA9IGN6bV9pbnZlcnNlR2FtbWEoY29sb3IpO1xcblxcXG4gICAgZ2xfRnJhZ0NvbG9yID0gdmVjNChjb2xvciwgZnJhZ21lbnRDb2xvci5hKTtcXG5cXFxufVxcblxcXG5cIjtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///51552\n')},3026:function(__unused_webpack___webpack_module__,__webpack_exports__){eval('//This file is automatically rebuilt by the Cesium build process.\n/* harmony default export */ __webpack_exports__["Z"] = ("uniform sampler2D colorTexture;\\n\\\nuniform sampler2D silhouetteTexture;\\n\\\n\\n\\\nvarying vec2 v_textureCoordinates;\\n\\\n\\n\\\nvoid main(void)\\n\\\n{\\n\\\n    vec4 silhouetteColor = texture2D(silhouetteTexture, v_textureCoordinates);\\n\\\n    vec4 color = texture2D(colorTexture, v_textureCoordinates);\\n\\\n    gl_FragColor = mix(color, silhouetteColor, silhouetteColor.a);\\n\\\n}\\n\\\n");\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMzAyNi5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBLHlEQUFlLGdDQUFnQztBQUMvQyxvQ0FBb0M7QUFDcEM7QUFDQSxrQ0FBa0M7QUFDbEM7QUFDQTtBQUNBLENBQUM7QUFDRCw4RUFBOEU7QUFDOUUsK0RBQStEO0FBQy9ELGtFQUFrRTtBQUNsRSxDQUFDO0FBQ0QsQ0FBQyxFQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdnVlMy13ZWJwYWNrNS8uL25vZGVfbW9kdWxlcy9jZXNpdW0vU291cmNlL1NoYWRlcnMvUG9zdFByb2Nlc3NTdGFnZXMvU2lsaG91ZXR0ZS5qcz9lZGVjIl0sInNvdXJjZXNDb250ZW50IjpbIi8vVGhpcyBmaWxlIGlzIGF1dG9tYXRpY2FsbHkgcmVidWlsdCBieSB0aGUgQ2VzaXVtIGJ1aWxkIHByb2Nlc3MuXG5leHBvcnQgZGVmYXVsdCBcInVuaWZvcm0gc2FtcGxlcjJEIGNvbG9yVGV4dHVyZTtcXG5cXFxudW5pZm9ybSBzYW1wbGVyMkQgc2lsaG91ZXR0ZVRleHR1cmU7XFxuXFxcblxcblxcXG52YXJ5aW5nIHZlYzIgdl90ZXh0dXJlQ29vcmRpbmF0ZXM7XFxuXFxcblxcblxcXG52b2lkIG1haW4odm9pZClcXG5cXFxue1xcblxcXG4gICAgdmVjNCBzaWxob3VldHRlQ29sb3IgPSB0ZXh0dXJlMkQoc2lsaG91ZXR0ZVRleHR1cmUsIHZfdGV4dHVyZUNvb3JkaW5hdGVzKTtcXG5cXFxuICAgIHZlYzQgY29sb3IgPSB0ZXh0dXJlMkQoY29sb3JUZXh0dXJlLCB2X3RleHR1cmVDb29yZGluYXRlcyk7XFxuXFxcbiAgICBnbF9GcmFnQ29sb3IgPSBtaXgoY29sb3IsIHNpbGhvdWV0dGVDb2xvciwgc2lsaG91ZXR0ZUNvbG9yLmEpO1xcblxcXG59XFxuXFxcblwiO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///3026\n')},4443:function(__unused_webpack___webpack_module__,__webpack_exports__){eval('//This file is automatically rebuilt by the Cesium build process.\n/* harmony default export */ __webpack_exports__["Z"] = ("uniform sampler2D u_texture;\\n\\\n\\n\\\nvarying vec2 v_textureCoordinates;\\n\\\n\\n\\\nvoid main()\\n\\\n{\\n\\\n    gl_FragColor = texture2D(u_texture, v_textureCoordinates);\\n\\\n}\\n\\\n");\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNDQ0My5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBLHlEQUFlLDZCQUE2QjtBQUM1QztBQUNBLGtDQUFrQztBQUNsQztBQUNBO0FBQ0EsQ0FBQztBQUNELDhEQUE4RDtBQUM5RCxDQUFDO0FBQ0QsQ0FBQyxFQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdnVlMy13ZWJwYWNrNS8uL25vZGVfbW9kdWxlcy9jZXNpdW0vU291cmNlL1NoYWRlcnMvUmVwcm9qZWN0V2ViTWVyY2F0b3JGUy5qcz80N2VlIl0sInNvdXJjZXNDb250ZW50IjpbIi8vVGhpcyBmaWxlIGlzIGF1dG9tYXRpY2FsbHkgcmVidWlsdCBieSB0aGUgQ2VzaXVtIGJ1aWxkIHByb2Nlc3MuXG5leHBvcnQgZGVmYXVsdCBcInVuaWZvcm0gc2FtcGxlcjJEIHVfdGV4dHVyZTtcXG5cXFxuXFxuXFxcbnZhcnlpbmcgdmVjMiB2X3RleHR1cmVDb29yZGluYXRlcztcXG5cXFxuXFxuXFxcbnZvaWQgbWFpbigpXFxuXFxcbntcXG5cXFxuICAgIGdsX0ZyYWdDb2xvciA9IHRleHR1cmUyRCh1X3RleHR1cmUsIHZfdGV4dHVyZUNvb3JkaW5hdGVzKTtcXG5cXFxufVxcblxcXG5cIjtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///4443\n')},29560:function(__unused_webpack___webpack_module__,__webpack_exports__){eval('//This file is automatically rebuilt by the Cesium build process.\n/* harmony default export */ __webpack_exports__["Z"] = ("attribute vec4 position;\\n\\\nattribute float webMercatorT;\\n\\\n\\n\\\nuniform vec2 u_textureDimensions;\\n\\\n\\n\\\nvarying vec2 v_textureCoordinates;\\n\\\n\\n\\\nvoid main()\\n\\\n{\\n\\\n    v_textureCoordinates = vec2(position.x, webMercatorT);\\n\\\n    gl_Position = czm_viewportOrthographic * (position * vec4(u_textureDimensions, 1.0, 1.0));\\n\\\n}\\n\\\n");\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjk1NjAuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQSx5REFBZSx5QkFBeUI7QUFDeEMsNkJBQTZCO0FBQzdCO0FBQ0EsaUNBQWlDO0FBQ2pDO0FBQ0Esa0NBQWtDO0FBQ2xDO0FBQ0E7QUFDQSxDQUFDO0FBQ0QsMERBQTBEO0FBQzFELDhGQUE4RjtBQUM5RixDQUFDO0FBQ0QsQ0FBQyxFQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdnVlMy13ZWJwYWNrNS8uL25vZGVfbW9kdWxlcy9jZXNpdW0vU291cmNlL1NoYWRlcnMvUmVwcm9qZWN0V2ViTWVyY2F0b3JWUy5qcz8xMjk2Il0sInNvdXJjZXNDb250ZW50IjpbIi8vVGhpcyBmaWxlIGlzIGF1dG9tYXRpY2FsbHkgcmVidWlsdCBieSB0aGUgQ2VzaXVtIGJ1aWxkIHByb2Nlc3MuXG5leHBvcnQgZGVmYXVsdCBcImF0dHJpYnV0ZSB2ZWM0IHBvc2l0aW9uO1xcblxcXG5hdHRyaWJ1dGUgZmxvYXQgd2ViTWVyY2F0b3JUO1xcblxcXG5cXG5cXFxudW5pZm9ybSB2ZWMyIHVfdGV4dHVyZURpbWVuc2lvbnM7XFxuXFxcblxcblxcXG52YXJ5aW5nIHZlYzIgdl90ZXh0dXJlQ29vcmRpbmF0ZXM7XFxuXFxcblxcblxcXG52b2lkIG1haW4oKVxcblxcXG57XFxuXFxcbiAgICB2X3RleHR1cmVDb29yZGluYXRlcyA9IHZlYzIocG9zaXRpb24ueCwgd2ViTWVyY2F0b3JUKTtcXG5cXFxuICAgIGdsX1Bvc2l0aW9uID0gY3ptX3ZpZXdwb3J0T3J0aG9ncmFwaGljICogKHBvc2l0aW9uICogdmVjNCh1X3RleHR1cmVEaW1lbnNpb25zLCAxLjAsIDEuMCkpO1xcblxcXG59XFxuXFxcblwiO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///29560\n')},52965:function(__unused_webpack___webpack_module__,__webpack_exports__){eval('//This file is automatically rebuilt by the Cesium build process.\n/* harmony default export */ __webpack_exports__["Z"] = ("#ifdef GL_EXT_frag_depth\\n\\\n#extension GL_EXT_frag_depth : enable\\n\\\n#endif\\n\\\n\\n\\\n#ifdef TEXTURE_COORDINATES\\n\\\n#ifdef SPHERICAL\\n\\\nvarying vec4 v_sphericalExtents;\\n\\\n#else // SPHERICAL\\n\\\nvarying vec2 v_inversePlaneExtents;\\n\\\nvarying vec4 v_westPlane;\\n\\\nvarying vec4 v_southPlane;\\n\\\n#endif // SPHERICAL\\n\\\nvarying vec3 v_uvMinAndSphericalLongitudeRotation;\\n\\\nvarying vec3 v_uMaxAndInverseDistance;\\n\\\nvarying vec3 v_vMaxAndInverseDistance;\\n\\\n#endif // TEXTURE_COORDINATES\\n\\\n\\n\\\n#ifdef PER_INSTANCE_COLOR\\n\\\nvarying vec4 v_color;\\n\\\n#endif\\n\\\n\\n\\\n#ifdef NORMAL_EC\\n\\\nvec3 getEyeCoordinate3FromWindowCoordinate(vec2 fragCoord, float logDepthOrDepth) {\\n\\\n    vec4 eyeCoordinate = czm_windowToEyeCoordinates(fragCoord, logDepthOrDepth);\\n\\\n    return eyeCoordinate.xyz / eyeCoordinate.w;\\n\\\n}\\n\\\n\\n\\\nvec3 vectorFromOffset(vec4 eyeCoordinate, vec2 positiveOffset) {\\n\\\n    vec2 glFragCoordXY = gl_FragCoord.xy;\\n\\\n    // Sample depths at both offset and negative offset\\n\\\n    float upOrRightLogDepth = czm_unpackDepth(texture2D(czm_globeDepthTexture, (glFragCoordXY + positiveOffset) / czm_viewport.zw));\\n\\\n    float downOrLeftLogDepth = czm_unpackDepth(texture2D(czm_globeDepthTexture, (glFragCoordXY - positiveOffset) / czm_viewport.zw));\\n\\\n    // Explicitly evaluate both paths\\n\\\n    // Necessary for multifrustum and for edges of the screen\\n\\\n    bvec2 upOrRightInBounds = lessThan(glFragCoordXY + positiveOffset, czm_viewport.zw);\\n\\\n    float useUpOrRight = float(upOrRightLogDepth > 0.0 && upOrRightInBounds.x && upOrRightInBounds.y);\\n\\\n    float useDownOrLeft = float(useUpOrRight == 0.0);\\n\\\n    vec3 upOrRightEC = getEyeCoordinate3FromWindowCoordinate(glFragCoordXY + positiveOffset, upOrRightLogDepth);\\n\\\n    vec3 downOrLeftEC = getEyeCoordinate3FromWindowCoordinate(glFragCoordXY - positiveOffset, downOrLeftLogDepth);\\n\\\n    return (upOrRightEC - (eyeCoordinate.xyz / eyeCoordinate.w)) * useUpOrRight + ((eyeCoordinate.xyz / eyeCoordinate.w) - downOrLeftEC) * useDownOrLeft;\\n\\\n}\\n\\\n#endif // NORMAL_EC\\n\\\n\\n\\\nvoid main(void)\\n\\\n{\\n\\\n#ifdef REQUIRES_EC\\n\\\n    float logDepthOrDepth = czm_unpackDepth(texture2D(czm_globeDepthTexture, gl_FragCoord.xy / czm_viewport.zw));\\n\\\n    vec4 eyeCoordinate = czm_windowToEyeCoordinates(gl_FragCoord.xy, logDepthOrDepth);\\n\\\n#endif\\n\\\n\\n\\\n#ifdef REQUIRES_WC\\n\\\n    vec4 worldCoordinate4 = czm_inverseView * eyeCoordinate;\\n\\\n    vec3 worldCoordinate = worldCoordinate4.xyz / worldCoordinate4.w;\\n\\\n#endif\\n\\\n\\n\\\n#ifdef TEXTURE_COORDINATES\\n\\\n    vec2 uv;\\n\\\n#ifdef SPHERICAL\\n\\\n    // Treat world coords as a sphere normal for spherical coordinates\\n\\\n    vec2 sphericalLatLong = czm_approximateSphericalCoordinates(worldCoordinate);\\n\\\n    sphericalLatLong.y += v_uvMinAndSphericalLongitudeRotation.z;\\n\\\n    sphericalLatLong.y = czm_branchFreeTernary(sphericalLatLong.y < czm_pi, sphericalLatLong.y, sphericalLatLong.y - czm_twoPi);\\n\\\n    uv.x = (sphericalLatLong.y - v_sphericalExtents.y) * v_sphericalExtents.w;\\n\\\n    uv.y = (sphericalLatLong.x - v_sphericalExtents.x) * v_sphericalExtents.z;\\n\\\n#else // SPHERICAL\\n\\\n    // Unpack planes and transform to eye space\\n\\\n    uv.x = czm_planeDistance(v_westPlane, eyeCoordinate.xyz / eyeCoordinate.w) * v_inversePlaneExtents.x;\\n\\\n    uv.y = czm_planeDistance(v_southPlane, eyeCoordinate.xyz / eyeCoordinate.w) * v_inversePlaneExtents.y;\\n\\\n#endif // SPHERICAL\\n\\\n#endif // TEXTURE_COORDINATES\\n\\\n\\n\\\n#ifdef PICK\\n\\\n#ifdef CULL_FRAGMENTS\\n\\\n    // When classifying translucent geometry, logDepthOrDepth == 0.0\\n\\\n    // indicates a region that should not be classified, possibly due to there\\n\\\n    // being opaque pixels there in another buffer.\\n\\\n    // Check for logDepthOrDepth != 0.0 to make sure this should be classified.\\n\\\n    if (0.0 <= uv.x && uv.x <= 1.0 && 0.0 <= uv.y && uv.y <= 1.0 || logDepthOrDepth != 0.0) {\\n\\\n        gl_FragColor.a = 1.0; // 0.0 alpha leads to discard from ShaderSource.createPickFragmentShaderSource\\n\\\n        czm_writeDepthClamp();\\n\\\n    }\\n\\\n#else // CULL_FRAGMENTS\\n\\\n        gl_FragColor.a = 1.0;\\n\\\n#endif // CULL_FRAGMENTS\\n\\\n#else // PICK\\n\\\n\\n\\\n#ifdef CULL_FRAGMENTS\\n\\\n    // When classifying translucent geometry, logDepthOrDepth == 0.0\\n\\\n    // indicates a region that should not be classified, possibly due to there\\n\\\n    // being opaque pixels there in another buffer.\\n\\\n    if (uv.x <= 0.0 || 1.0 <= uv.x || uv.y <= 0.0 || 1.0 <= uv.y || logDepthOrDepth == 0.0) {\\n\\\n        discard;\\n\\\n    }\\n\\\n#endif\\n\\\n\\n\\\n#ifdef NORMAL_EC\\n\\\n    // Compute normal by sampling adjacent pixels in 2x2 block in screen space\\n\\\n    vec3 downUp = vectorFromOffset(eyeCoordinate, vec2(0.0, 1.0));\\n\\\n    vec3 leftRight = vectorFromOffset(eyeCoordinate, vec2(1.0, 0.0));\\n\\\n    vec3 normalEC = normalize(cross(leftRight, downUp));\\n\\\n#endif\\n\\\n\\n\\\n\\n\\\n#ifdef PER_INSTANCE_COLOR\\n\\\n\\n\\\n    vec4 color = czm_gammaCorrect(v_color);\\n\\\n#ifdef FLAT\\n\\\n    gl_FragColor = color;\\n\\\n#else // FLAT\\n\\\n    czm_materialInput materialInput;\\n\\\n    materialInput.normalEC = normalEC;\\n\\\n    materialInput.positionToEyeEC = -eyeCoordinate.xyz;\\n\\\n    czm_material material = czm_getDefaultMaterial(materialInput);\\n\\\n    material.diffuse = color.rgb;\\n\\\n    material.alpha = color.a;\\n\\\n\\n\\\n    gl_FragColor = czm_phong(normalize(-eyeCoordinate.xyz), material, czm_lightDirectionEC);\\n\\\n#endif // FLAT\\n\\\n\\n\\\n    // Premultiply alpha. Required for classification primitives on translucent globe.\\n\\\n    gl_FragColor.rgb *= gl_FragColor.a;\\n\\\n\\n\\\n#else // PER_INSTANCE_COLOR\\n\\\n\\n\\\n    // Material support.\\n\\\n    // USES_ is distinct from REQUIRES_, because some things are dependencies of each other or\\n\\\n    // dependencies for culling but might not actually be used by the material.\\n\\\n\\n\\\n    czm_materialInput materialInput;\\n\\\n\\n\\\n#ifdef USES_NORMAL_EC\\n\\\n    materialInput.normalEC = normalEC;\\n\\\n#endif\\n\\\n\\n\\\n#ifdef USES_POSITION_TO_EYE_EC\\n\\\n    materialInput.positionToEyeEC = -eyeCoordinate.xyz;\\n\\\n#endif\\n\\\n\\n\\\n#ifdef USES_TANGENT_TO_EYE\\n\\\n    materialInput.tangentToEyeMatrix = czm_eastNorthUpToEyeCoordinates(worldCoordinate, normalEC);\\n\\\n#endif\\n\\\n\\n\\\n#ifdef USES_ST\\n\\\n    // Remap texture coordinates from computed (approximately aligned with cartographic space) to the desired\\n\\\n    // texture coordinate system, which typically forms a tight oriented bounding box around the geometry.\\n\\\n    // Shader is provided a set of reference points for remapping.\\n\\\n    materialInput.st.x = czm_lineDistance(v_uvMinAndSphericalLongitudeRotation.xy, v_uMaxAndInverseDistance.xy, uv) * v_uMaxAndInverseDistance.z;\\n\\\n    materialInput.st.y = czm_lineDistance(v_uvMinAndSphericalLongitudeRotation.xy, v_vMaxAndInverseDistance.xy, uv) * v_vMaxAndInverseDistance.z;\\n\\\n#endif\\n\\\n\\n\\\n    czm_material material = czm_getMaterial(materialInput);\\n\\\n\\n\\\n#ifdef FLAT\\n\\\n    gl_FragColor = vec4(material.diffuse + material.emission, material.alpha);\\n\\\n#else // FLAT\\n\\\n    gl_FragColor = czm_phong(normalize(-eyeCoordinate.xyz), material, czm_lightDirectionEC);\\n\\\n#endif // FLAT\\n\\\n\\n\\\n    // Premultiply alpha. Required for classification primitives on translucent globe.\\n\\\n    gl_FragColor.rgb *= gl_FragColor.a;\\n\\\n\\n\\\n#endif // PER_INSTANCE_COLOR\\n\\\n    czm_writeDepthClamp();\\n\\\n#endif // PICK\\n\\\n}\\n\\\n");\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNTI5NjUuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQSx5REFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0M7QUFDaEM7QUFDQSxtQ0FBbUM7QUFDbkMseUJBQXlCO0FBQ3pCLDBCQUEwQjtBQUMxQjtBQUNBLGtEQUFrRDtBQUNsRCxzQ0FBc0M7QUFDdEMsc0NBQXNDO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQSxtRkFBbUY7QUFDbkYsZ0ZBQWdGO0FBQ2hGLCtDQUErQztBQUMvQyxDQUFDO0FBQ0Q7QUFDQSxnRUFBZ0U7QUFDaEUseUNBQXlDO0FBQ3pDO0FBQ0Esb0lBQW9JO0FBQ3BJLHFJQUFxSTtBQUNySTtBQUNBO0FBQ0Esd0ZBQXdGO0FBQ3hGLHNHQUFzRztBQUN0RyxxREFBcUQ7QUFDckQsZ0hBQWdIO0FBQ2hILGtIQUFrSDtBQUNsSCx5SkFBeUo7QUFDekosQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBLGlIQUFpSDtBQUNqSCxzRkFBc0Y7QUFDdEY7QUFDQTtBQUNBO0FBQ0EsNERBQTREO0FBQzVELHFFQUFxRTtBQUNyRTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBLGlGQUFpRjtBQUNqRixpRUFBaUU7QUFDakUsZ0lBQWdJO0FBQ2hJLDhFQUE4RTtBQUM5RSw4RUFBOEU7QUFDOUU7QUFDQTtBQUNBLHlHQUF5RztBQUN6RywwR0FBMEc7QUFDMUc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkZBQTZGO0FBQzdGLDhCQUE4QjtBQUM5Qiw4QkFBOEI7QUFDOUIsS0FBSztBQUNMO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkZBQTZGO0FBQzdGLGdCQUFnQjtBQUNoQixLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrRUFBa0U7QUFDbEUscUVBQXFFO0FBQ3JFLHdEQUF3RDtBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDO0FBQzNDO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0Esb0NBQW9DO0FBQ3BDLHNDQUFzQztBQUN0Qyx1REFBdUQ7QUFDdkQsa0VBQWtFO0FBQ2xFLGlDQUFpQztBQUNqQyw2QkFBNkI7QUFDN0I7QUFDQSw0RkFBNEY7QUFDNUY7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DO0FBQ3BDO0FBQ0E7QUFDQSxzQ0FBc0M7QUFDdEM7QUFDQTtBQUNBO0FBQ0EsdURBQXVEO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBLGtHQUFrRztBQUNsRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpSkFBaUo7QUFDakosaUpBQWlKO0FBQ2pKO0FBQ0E7QUFDQSwyREFBMkQ7QUFDM0Q7QUFDQTtBQUNBLDhFQUE4RTtBQUM5RTtBQUNBLDRGQUE0RjtBQUM1RjtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUM7QUFDdkM7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBLENBQUM7QUFDRCxDQUFDLEVBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly92dWUzLXdlYnBhY2s1Ly4vbm9kZV9tb2R1bGVzL2Nlc2l1bS9Tb3VyY2UvU2hhZGVycy9TaGFkb3dWb2x1bWVBcHBlYXJhbmNlRlMuanM/Y2U3YyJdLCJzb3VyY2VzQ29udGVudCI6WyIvL1RoaXMgZmlsZSBpcyBhdXRvbWF0aWNhbGx5IHJlYnVpbHQgYnkgdGhlIENlc2l1bSBidWlsZCBwcm9jZXNzLlxuZXhwb3J0IGRlZmF1bHQgXCIjaWZkZWYgR0xfRVhUX2ZyYWdfZGVwdGhcXG5cXFxuI2V4dGVuc2lvbiBHTF9FWFRfZnJhZ19kZXB0aCA6IGVuYWJsZVxcblxcXG4jZW5kaWZcXG5cXFxuXFxuXFxcbiNpZmRlZiBURVhUVVJFX0NPT1JESU5BVEVTXFxuXFxcbiNpZmRlZiBTUEhFUklDQUxcXG5cXFxudmFyeWluZyB2ZWM0IHZfc3BoZXJpY2FsRXh0ZW50cztcXG5cXFxuI2Vsc2UgLy8gU1BIRVJJQ0FMXFxuXFxcbnZhcnlpbmcgdmVjMiB2X2ludmVyc2VQbGFuZUV4dGVudHM7XFxuXFxcbnZhcnlpbmcgdmVjNCB2X3dlc3RQbGFuZTtcXG5cXFxudmFyeWluZyB2ZWM0IHZfc291dGhQbGFuZTtcXG5cXFxuI2VuZGlmIC8vIFNQSEVSSUNBTFxcblxcXG52YXJ5aW5nIHZlYzMgdl91dk1pbkFuZFNwaGVyaWNhbExvbmdpdHVkZVJvdGF0aW9uO1xcblxcXG52YXJ5aW5nIHZlYzMgdl91TWF4QW5kSW52ZXJzZURpc3RhbmNlO1xcblxcXG52YXJ5aW5nIHZlYzMgdl92TWF4QW5kSW52ZXJzZURpc3RhbmNlO1xcblxcXG4jZW5kaWYgLy8gVEVYVFVSRV9DT09SRElOQVRFU1xcblxcXG5cXG5cXFxuI2lmZGVmIFBFUl9JTlNUQU5DRV9DT0xPUlxcblxcXG52YXJ5aW5nIHZlYzQgdl9jb2xvcjtcXG5cXFxuI2VuZGlmXFxuXFxcblxcblxcXG4jaWZkZWYgTk9STUFMX0VDXFxuXFxcbnZlYzMgZ2V0RXllQ29vcmRpbmF0ZTNGcm9tV2luZG93Q29vcmRpbmF0ZSh2ZWMyIGZyYWdDb29yZCwgZmxvYXQgbG9nRGVwdGhPckRlcHRoKSB7XFxuXFxcbiAgICB2ZWM0IGV5ZUNvb3JkaW5hdGUgPSBjem1fd2luZG93VG9FeWVDb29yZGluYXRlcyhmcmFnQ29vcmQsIGxvZ0RlcHRoT3JEZXB0aCk7XFxuXFxcbiAgICByZXR1cm4gZXllQ29vcmRpbmF0ZS54eXogLyBleWVDb29yZGluYXRlLnc7XFxuXFxcbn1cXG5cXFxuXFxuXFxcbnZlYzMgdmVjdG9yRnJvbU9mZnNldCh2ZWM0IGV5ZUNvb3JkaW5hdGUsIHZlYzIgcG9zaXRpdmVPZmZzZXQpIHtcXG5cXFxuICAgIHZlYzIgZ2xGcmFnQ29vcmRYWSA9IGdsX0ZyYWdDb29yZC54eTtcXG5cXFxuICAgIC8vIFNhbXBsZSBkZXB0aHMgYXQgYm90aCBvZmZzZXQgYW5kIG5lZ2F0aXZlIG9mZnNldFxcblxcXG4gICAgZmxvYXQgdXBPclJpZ2h0TG9nRGVwdGggPSBjem1fdW5wYWNrRGVwdGgodGV4dHVyZTJEKGN6bV9nbG9iZURlcHRoVGV4dHVyZSwgKGdsRnJhZ0Nvb3JkWFkgKyBwb3NpdGl2ZU9mZnNldCkgLyBjem1fdmlld3BvcnQuencpKTtcXG5cXFxuICAgIGZsb2F0IGRvd25PckxlZnRMb2dEZXB0aCA9IGN6bV91bnBhY2tEZXB0aCh0ZXh0dXJlMkQoY3ptX2dsb2JlRGVwdGhUZXh0dXJlLCAoZ2xGcmFnQ29vcmRYWSAtIHBvc2l0aXZlT2Zmc2V0KSAvIGN6bV92aWV3cG9ydC56dykpO1xcblxcXG4gICAgLy8gRXhwbGljaXRseSBldmFsdWF0ZSBib3RoIHBhdGhzXFxuXFxcbiAgICAvLyBOZWNlc3NhcnkgZm9yIG11bHRpZnJ1c3R1bSBhbmQgZm9yIGVkZ2VzIG9mIHRoZSBzY3JlZW5cXG5cXFxuICAgIGJ2ZWMyIHVwT3JSaWdodEluQm91bmRzID0gbGVzc1RoYW4oZ2xGcmFnQ29vcmRYWSArIHBvc2l0aXZlT2Zmc2V0LCBjem1fdmlld3BvcnQuencpO1xcblxcXG4gICAgZmxvYXQgdXNlVXBPclJpZ2h0ID0gZmxvYXQodXBPclJpZ2h0TG9nRGVwdGggPiAwLjAgJiYgdXBPclJpZ2h0SW5Cb3VuZHMueCAmJiB1cE9yUmlnaHRJbkJvdW5kcy55KTtcXG5cXFxuICAgIGZsb2F0IHVzZURvd25PckxlZnQgPSBmbG9hdCh1c2VVcE9yUmlnaHQgPT0gMC4wKTtcXG5cXFxuICAgIHZlYzMgdXBPclJpZ2h0RUMgPSBnZXRFeWVDb29yZGluYXRlM0Zyb21XaW5kb3dDb29yZGluYXRlKGdsRnJhZ0Nvb3JkWFkgKyBwb3NpdGl2ZU9mZnNldCwgdXBPclJpZ2h0TG9nRGVwdGgpO1xcblxcXG4gICAgdmVjMyBkb3duT3JMZWZ0RUMgPSBnZXRFeWVDb29yZGluYXRlM0Zyb21XaW5kb3dDb29yZGluYXRlKGdsRnJhZ0Nvb3JkWFkgLSBwb3NpdGl2ZU9mZnNldCwgZG93bk9yTGVmdExvZ0RlcHRoKTtcXG5cXFxuICAgIHJldHVybiAodXBPclJpZ2h0RUMgLSAoZXllQ29vcmRpbmF0ZS54eXogLyBleWVDb29yZGluYXRlLncpKSAqIHVzZVVwT3JSaWdodCArICgoZXllQ29vcmRpbmF0ZS54eXogLyBleWVDb29yZGluYXRlLncpIC0gZG93bk9yTGVmdEVDKSAqIHVzZURvd25PckxlZnQ7XFxuXFxcbn1cXG5cXFxuI2VuZGlmIC8vIE5PUk1BTF9FQ1xcblxcXG5cXG5cXFxudm9pZCBtYWluKHZvaWQpXFxuXFxcbntcXG5cXFxuI2lmZGVmIFJFUVVJUkVTX0VDXFxuXFxcbiAgICBmbG9hdCBsb2dEZXB0aE9yRGVwdGggPSBjem1fdW5wYWNrRGVwdGgodGV4dHVyZTJEKGN6bV9nbG9iZURlcHRoVGV4dHVyZSwgZ2xfRnJhZ0Nvb3JkLnh5IC8gY3ptX3ZpZXdwb3J0Lnp3KSk7XFxuXFxcbiAgICB2ZWM0IGV5ZUNvb3JkaW5hdGUgPSBjem1fd2luZG93VG9FeWVDb29yZGluYXRlcyhnbF9GcmFnQ29vcmQueHksIGxvZ0RlcHRoT3JEZXB0aCk7XFxuXFxcbiNlbmRpZlxcblxcXG5cXG5cXFxuI2lmZGVmIFJFUVVJUkVTX1dDXFxuXFxcbiAgICB2ZWM0IHdvcmxkQ29vcmRpbmF0ZTQgPSBjem1faW52ZXJzZVZpZXcgKiBleWVDb29yZGluYXRlO1xcblxcXG4gICAgdmVjMyB3b3JsZENvb3JkaW5hdGUgPSB3b3JsZENvb3JkaW5hdGU0Lnh5eiAvIHdvcmxkQ29vcmRpbmF0ZTQudztcXG5cXFxuI2VuZGlmXFxuXFxcblxcblxcXG4jaWZkZWYgVEVYVFVSRV9DT09SRElOQVRFU1xcblxcXG4gICAgdmVjMiB1djtcXG5cXFxuI2lmZGVmIFNQSEVSSUNBTFxcblxcXG4gICAgLy8gVHJlYXQgd29ybGQgY29vcmRzIGFzIGEgc3BoZXJlIG5vcm1hbCBmb3Igc3BoZXJpY2FsIGNvb3JkaW5hdGVzXFxuXFxcbiAgICB2ZWMyIHNwaGVyaWNhbExhdExvbmcgPSBjem1fYXBwcm94aW1hdGVTcGhlcmljYWxDb29yZGluYXRlcyh3b3JsZENvb3JkaW5hdGUpO1xcblxcXG4gICAgc3BoZXJpY2FsTGF0TG9uZy55ICs9IHZfdXZNaW5BbmRTcGhlcmljYWxMb25naXR1ZGVSb3RhdGlvbi56O1xcblxcXG4gICAgc3BoZXJpY2FsTGF0TG9uZy55ID0gY3ptX2JyYW5jaEZyZWVUZXJuYXJ5KHNwaGVyaWNhbExhdExvbmcueSA8IGN6bV9waSwgc3BoZXJpY2FsTGF0TG9uZy55LCBzcGhlcmljYWxMYXRMb25nLnkgLSBjem1fdHdvUGkpO1xcblxcXG4gICAgdXYueCA9IChzcGhlcmljYWxMYXRMb25nLnkgLSB2X3NwaGVyaWNhbEV4dGVudHMueSkgKiB2X3NwaGVyaWNhbEV4dGVudHMudztcXG5cXFxuICAgIHV2LnkgPSAoc3BoZXJpY2FsTGF0TG9uZy54IC0gdl9zcGhlcmljYWxFeHRlbnRzLngpICogdl9zcGhlcmljYWxFeHRlbnRzLno7XFxuXFxcbiNlbHNlIC8vIFNQSEVSSUNBTFxcblxcXG4gICAgLy8gVW5wYWNrIHBsYW5lcyBhbmQgdHJhbnNmb3JtIHRvIGV5ZSBzcGFjZVxcblxcXG4gICAgdXYueCA9IGN6bV9wbGFuZURpc3RhbmNlKHZfd2VzdFBsYW5lLCBleWVDb29yZGluYXRlLnh5eiAvIGV5ZUNvb3JkaW5hdGUudykgKiB2X2ludmVyc2VQbGFuZUV4dGVudHMueDtcXG5cXFxuICAgIHV2LnkgPSBjem1fcGxhbmVEaXN0YW5jZSh2X3NvdXRoUGxhbmUsIGV5ZUNvb3JkaW5hdGUueHl6IC8gZXllQ29vcmRpbmF0ZS53KSAqIHZfaW52ZXJzZVBsYW5lRXh0ZW50cy55O1xcblxcXG4jZW5kaWYgLy8gU1BIRVJJQ0FMXFxuXFxcbiNlbmRpZiAvLyBURVhUVVJFX0NPT1JESU5BVEVTXFxuXFxcblxcblxcXG4jaWZkZWYgUElDS1xcblxcXG4jaWZkZWYgQ1VMTF9GUkFHTUVOVFNcXG5cXFxuICAgIC8vIFdoZW4gY2xhc3NpZnlpbmcgdHJhbnNsdWNlbnQgZ2VvbWV0cnksIGxvZ0RlcHRoT3JEZXB0aCA9PSAwLjBcXG5cXFxuICAgIC8vIGluZGljYXRlcyBhIHJlZ2lvbiB0aGF0IHNob3VsZCBub3QgYmUgY2xhc3NpZmllZCwgcG9zc2libHkgZHVlIHRvIHRoZXJlXFxuXFxcbiAgICAvLyBiZWluZyBvcGFxdWUgcGl4ZWxzIHRoZXJlIGluIGFub3RoZXIgYnVmZmVyLlxcblxcXG4gICAgLy8gQ2hlY2sgZm9yIGxvZ0RlcHRoT3JEZXB0aCAhPSAwLjAgdG8gbWFrZSBzdXJlIHRoaXMgc2hvdWxkIGJlIGNsYXNzaWZpZWQuXFxuXFxcbiAgICBpZiAoMC4wIDw9IHV2LnggJiYgdXYueCA8PSAxLjAgJiYgMC4wIDw9IHV2LnkgJiYgdXYueSA8PSAxLjAgfHwgbG9nRGVwdGhPckRlcHRoICE9IDAuMCkge1xcblxcXG4gICAgICAgIGdsX0ZyYWdDb2xvci5hID0gMS4wOyAvLyAwLjAgYWxwaGEgbGVhZHMgdG8gZGlzY2FyZCBmcm9tIFNoYWRlclNvdXJjZS5jcmVhdGVQaWNrRnJhZ21lbnRTaGFkZXJTb3VyY2VcXG5cXFxuICAgICAgICBjem1fd3JpdGVEZXB0aENsYW1wKCk7XFxuXFxcbiAgICB9XFxuXFxcbiNlbHNlIC8vIENVTExfRlJBR01FTlRTXFxuXFxcbiAgICAgICAgZ2xfRnJhZ0NvbG9yLmEgPSAxLjA7XFxuXFxcbiNlbmRpZiAvLyBDVUxMX0ZSQUdNRU5UU1xcblxcXG4jZWxzZSAvLyBQSUNLXFxuXFxcblxcblxcXG4jaWZkZWYgQ1VMTF9GUkFHTUVOVFNcXG5cXFxuICAgIC8vIFdoZW4gY2xhc3NpZnlpbmcgdHJhbnNsdWNlbnQgZ2VvbWV0cnksIGxvZ0RlcHRoT3JEZXB0aCA9PSAwLjBcXG5cXFxuICAgIC8vIGluZGljYXRlcyBhIHJlZ2lvbiB0aGF0IHNob3VsZCBub3QgYmUgY2xhc3NpZmllZCwgcG9zc2libHkgZHVlIHRvIHRoZXJlXFxuXFxcbiAgICAvLyBiZWluZyBvcGFxdWUgcGl4ZWxzIHRoZXJlIGluIGFub3RoZXIgYnVmZmVyLlxcblxcXG4gICAgaWYgKHV2LnggPD0gMC4wIHx8IDEuMCA8PSB1di54IHx8IHV2LnkgPD0gMC4wIHx8IDEuMCA8PSB1di55IHx8IGxvZ0RlcHRoT3JEZXB0aCA9PSAwLjApIHtcXG5cXFxuICAgICAgICBkaXNjYXJkO1xcblxcXG4gICAgfVxcblxcXG4jZW5kaWZcXG5cXFxuXFxuXFxcbiNpZmRlZiBOT1JNQUxfRUNcXG5cXFxuICAgIC8vIENvbXB1dGUgbm9ybWFsIGJ5IHNhbXBsaW5nIGFkamFjZW50IHBpeGVscyBpbiAyeDIgYmxvY2sgaW4gc2NyZWVuIHNwYWNlXFxuXFxcbiAgICB2ZWMzIGRvd25VcCA9IHZlY3RvckZyb21PZmZzZXQoZXllQ29vcmRpbmF0ZSwgdmVjMigwLjAsIDEuMCkpO1xcblxcXG4gICAgdmVjMyBsZWZ0UmlnaHQgPSB2ZWN0b3JGcm9tT2Zmc2V0KGV5ZUNvb3JkaW5hdGUsIHZlYzIoMS4wLCAwLjApKTtcXG5cXFxuICAgIHZlYzMgbm9ybWFsRUMgPSBub3JtYWxpemUoY3Jvc3MobGVmdFJpZ2h0LCBkb3duVXApKTtcXG5cXFxuI2VuZGlmXFxuXFxcblxcblxcXG5cXG5cXFxuI2lmZGVmIFBFUl9JTlNUQU5DRV9DT0xPUlxcblxcXG5cXG5cXFxuICAgIHZlYzQgY29sb3IgPSBjem1fZ2FtbWFDb3JyZWN0KHZfY29sb3IpO1xcblxcXG4jaWZkZWYgRkxBVFxcblxcXG4gICAgZ2xfRnJhZ0NvbG9yID0gY29sb3I7XFxuXFxcbiNlbHNlIC8vIEZMQVRcXG5cXFxuICAgIGN6bV9tYXRlcmlhbElucHV0IG1hdGVyaWFsSW5wdXQ7XFxuXFxcbiAgICBtYXRlcmlhbElucHV0Lm5vcm1hbEVDID0gbm9ybWFsRUM7XFxuXFxcbiAgICBtYXRlcmlhbElucHV0LnBvc2l0aW9uVG9FeWVFQyA9IC1leWVDb29yZGluYXRlLnh5ejtcXG5cXFxuICAgIGN6bV9tYXRlcmlhbCBtYXRlcmlhbCA9IGN6bV9nZXREZWZhdWx0TWF0ZXJpYWwobWF0ZXJpYWxJbnB1dCk7XFxuXFxcbiAgICBtYXRlcmlhbC5kaWZmdXNlID0gY29sb3IucmdiO1xcblxcXG4gICAgbWF0ZXJpYWwuYWxwaGEgPSBjb2xvci5hO1xcblxcXG5cXG5cXFxuICAgIGdsX0ZyYWdDb2xvciA9IGN6bV9waG9uZyhub3JtYWxpemUoLWV5ZUNvb3JkaW5hdGUueHl6KSwgbWF0ZXJpYWwsIGN6bV9saWdodERpcmVjdGlvbkVDKTtcXG5cXFxuI2VuZGlmIC8vIEZMQVRcXG5cXFxuXFxuXFxcbiAgICAvLyBQcmVtdWx0aXBseSBhbHBoYS4gUmVxdWlyZWQgZm9yIGNsYXNzaWZpY2F0aW9uIHByaW1pdGl2ZXMgb24gdHJhbnNsdWNlbnQgZ2xvYmUuXFxuXFxcbiAgICBnbF9GcmFnQ29sb3IucmdiICo9IGdsX0ZyYWdDb2xvci5hO1xcblxcXG5cXG5cXFxuI2Vsc2UgLy8gUEVSX0lOU1RBTkNFX0NPTE9SXFxuXFxcblxcblxcXG4gICAgLy8gTWF0ZXJpYWwgc3VwcG9ydC5cXG5cXFxuICAgIC8vIFVTRVNfIGlzIGRpc3RpbmN0IGZyb20gUkVRVUlSRVNfLCBiZWNhdXNlIHNvbWUgdGhpbmdzIGFyZSBkZXBlbmRlbmNpZXMgb2YgZWFjaCBvdGhlciBvclxcblxcXG4gICAgLy8gZGVwZW5kZW5jaWVzIGZvciBjdWxsaW5nIGJ1dCBtaWdodCBub3QgYWN0dWFsbHkgYmUgdXNlZCBieSB0aGUgbWF0ZXJpYWwuXFxuXFxcblxcblxcXG4gICAgY3ptX21hdGVyaWFsSW5wdXQgbWF0ZXJpYWxJbnB1dDtcXG5cXFxuXFxuXFxcbiNpZmRlZiBVU0VTX05PUk1BTF9FQ1xcblxcXG4gICAgbWF0ZXJpYWxJbnB1dC5ub3JtYWxFQyA9IG5vcm1hbEVDO1xcblxcXG4jZW5kaWZcXG5cXFxuXFxuXFxcbiNpZmRlZiBVU0VTX1BPU0lUSU9OX1RPX0VZRV9FQ1xcblxcXG4gICAgbWF0ZXJpYWxJbnB1dC5wb3NpdGlvblRvRXllRUMgPSAtZXllQ29vcmRpbmF0ZS54eXo7XFxuXFxcbiNlbmRpZlxcblxcXG5cXG5cXFxuI2lmZGVmIFVTRVNfVEFOR0VOVF9UT19FWUVcXG5cXFxuICAgIG1hdGVyaWFsSW5wdXQudGFuZ2VudFRvRXllTWF0cml4ID0gY3ptX2Vhc3ROb3J0aFVwVG9FeWVDb29yZGluYXRlcyh3b3JsZENvb3JkaW5hdGUsIG5vcm1hbEVDKTtcXG5cXFxuI2VuZGlmXFxuXFxcblxcblxcXG4jaWZkZWYgVVNFU19TVFxcblxcXG4gICAgLy8gUmVtYXAgdGV4dHVyZSBjb29yZGluYXRlcyBmcm9tIGNvbXB1dGVkIChhcHByb3hpbWF0ZWx5IGFsaWduZWQgd2l0aCBjYXJ0b2dyYXBoaWMgc3BhY2UpIHRvIHRoZSBkZXNpcmVkXFxuXFxcbiAgICAvLyB0ZXh0dXJlIGNvb3JkaW5hdGUgc3lzdGVtLCB3aGljaCB0eXBpY2FsbHkgZm9ybXMgYSB0aWdodCBvcmllbnRlZCBib3VuZGluZyBib3ggYXJvdW5kIHRoZSBnZW9tZXRyeS5cXG5cXFxuICAgIC8vIFNoYWRlciBpcyBwcm92aWRlZCBhIHNldCBvZiByZWZlcmVuY2UgcG9pbnRzIGZvciByZW1hcHBpbmcuXFxuXFxcbiAgICBtYXRlcmlhbElucHV0LnN0LnggPSBjem1fbGluZURpc3RhbmNlKHZfdXZNaW5BbmRTcGhlcmljYWxMb25naXR1ZGVSb3RhdGlvbi54eSwgdl91TWF4QW5kSW52ZXJzZURpc3RhbmNlLnh5LCB1dikgKiB2X3VNYXhBbmRJbnZlcnNlRGlzdGFuY2UuejtcXG5cXFxuICAgIG1hdGVyaWFsSW5wdXQuc3QueSA9IGN6bV9saW5lRGlzdGFuY2Uodl91dk1pbkFuZFNwaGVyaWNhbExvbmdpdHVkZVJvdGF0aW9uLnh5LCB2X3ZNYXhBbmRJbnZlcnNlRGlzdGFuY2UueHksIHV2KSAqIHZfdk1heEFuZEludmVyc2VEaXN0YW5jZS56O1xcblxcXG4jZW5kaWZcXG5cXFxuXFxuXFxcbiAgICBjem1fbWF0ZXJpYWwgbWF0ZXJpYWwgPSBjem1fZ2V0TWF0ZXJpYWwobWF0ZXJpYWxJbnB1dCk7XFxuXFxcblxcblxcXG4jaWZkZWYgRkxBVFxcblxcXG4gICAgZ2xfRnJhZ0NvbG9yID0gdmVjNChtYXRlcmlhbC5kaWZmdXNlICsgbWF0ZXJpYWwuZW1pc3Npb24sIG1hdGVyaWFsLmFscGhhKTtcXG5cXFxuI2Vsc2UgLy8gRkxBVFxcblxcXG4gICAgZ2xfRnJhZ0NvbG9yID0gY3ptX3Bob25nKG5vcm1hbGl6ZSgtZXllQ29vcmRpbmF0ZS54eXopLCBtYXRlcmlhbCwgY3ptX2xpZ2h0RGlyZWN0aW9uRUMpO1xcblxcXG4jZW5kaWYgLy8gRkxBVFxcblxcXG5cXG5cXFxuICAgIC8vIFByZW11bHRpcGx5IGFscGhhLiBSZXF1aXJlZCBmb3IgY2xhc3NpZmljYXRpb24gcHJpbWl0aXZlcyBvbiB0cmFuc2x1Y2VudCBnbG9iZS5cXG5cXFxuICAgIGdsX0ZyYWdDb2xvci5yZ2IgKj0gZ2xfRnJhZ0NvbG9yLmE7XFxuXFxcblxcblxcXG4jZW5kaWYgLy8gUEVSX0lOU1RBTkNFX0NPTE9SXFxuXFxcbiAgICBjem1fd3JpdGVEZXB0aENsYW1wKCk7XFxuXFxcbiNlbmRpZiAvLyBQSUNLXFxuXFxcbn1cXG5cXFxuXCI7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///52965\n')},73257:function(__unused_webpack___webpack_module__,__webpack_exports__){eval('//This file is automatically rebuilt by the Cesium build process.\n/* harmony default export */ __webpack_exports__["Z"] = ("attribute vec3 position3DHigh;\\n\\\nattribute vec3 position3DLow;\\n\\\nattribute float batchId;\\n\\\n\\n\\\n#ifdef EXTRUDED_GEOMETRY\\n\\\nattribute vec3 extrudeDirection;\\n\\\n\\n\\\nuniform float u_globeMinimumAltitude;\\n\\\n#endif // EXTRUDED_GEOMETRY\\n\\\n\\n\\\n#ifdef PER_INSTANCE_COLOR\\n\\\nvarying vec4 v_color;\\n\\\n#endif // PER_INSTANCE_COLOR\\n\\\n\\n\\\n#ifdef TEXTURE_COORDINATES\\n\\\n#ifdef SPHERICAL\\n\\\nvarying vec4 v_sphericalExtents;\\n\\\n#else // SPHERICAL\\n\\\nvarying vec2 v_inversePlaneExtents;\\n\\\nvarying vec4 v_westPlane;\\n\\\nvarying vec4 v_southPlane;\\n\\\n#endif // SPHERICAL\\n\\\nvarying vec3 v_uvMinAndSphericalLongitudeRotation;\\n\\\nvarying vec3 v_uMaxAndInverseDistance;\\n\\\nvarying vec3 v_vMaxAndInverseDistance;\\n\\\n#endif // TEXTURE_COORDINATES\\n\\\n\\n\\\nvoid main()\\n\\\n{\\n\\\n    vec4 position = czm_computePosition();\\n\\\n\\n\\\n#ifdef EXTRUDED_GEOMETRY\\n\\\n    float delta = min(u_globeMinimumAltitude, czm_geometricToleranceOverMeter * length(position.xyz));\\n\\\n    delta *= czm_sceneMode == czm_sceneMode3D ? 1.0 : 0.0;\\n\\\n\\n\\\n    //extrudeDirection is zero for the top layer\\n\\\n    position = position + vec4(extrudeDirection * delta, 0.0);\\n\\\n#endif\\n\\\n\\n\\\n#ifdef TEXTURE_COORDINATES\\n\\\n#ifdef SPHERICAL\\n\\\n    v_sphericalExtents = czm_batchTable_sphericalExtents(batchId);\\n\\\n    v_uvMinAndSphericalLongitudeRotation.z = czm_batchTable_longitudeRotation(batchId);\\n\\\n#else // SPHERICAL\\n\\\n#ifdef COLUMBUS_VIEW_2D\\n\\\n    vec4 planes2D_high = czm_batchTable_planes2D_HIGH(batchId);\\n\\\n    vec4 planes2D_low = czm_batchTable_planes2D_LOW(batchId);\\n\\\n\\n\\\n    // If the primitive is split across the IDL (planes2D_high.x > planes2D_high.w):\\n\\\n    // - If this vertex is on the east side of the IDL (position3DLow.y > 0.0, comparison with position3DHigh may produce artifacts)\\n\\\n    // - existing \\"east\\" is on the wrong side of the world, far away (planes2D_high/low.w)\\n\\\n    // - so set \\"east\\" as beyond the eastmost extent of the projection (idlSplitNewPlaneHiLow)\\n\\\n    vec2 idlSplitNewPlaneHiLow = vec2(EAST_MOST_X_HIGH - (WEST_MOST_X_HIGH - planes2D_high.w), EAST_MOST_X_LOW - (WEST_MOST_X_LOW - planes2D_low.w));\\n\\\n    bool idlSplit = planes2D_high.x > planes2D_high.w && position3DLow.y > 0.0;\\n\\\n    planes2D_high.w = czm_branchFreeTernary(idlSplit, idlSplitNewPlaneHiLow.x, planes2D_high.w);\\n\\\n    planes2D_low.w = czm_branchFreeTernary(idlSplit, idlSplitNewPlaneHiLow.y, planes2D_low.w);\\n\\\n\\n\\\n    // - else, if this vertex is on the west side of the IDL (position3DLow.y < 0.0)\\n\\\n    // - existing \\"west\\" is on the wrong side of the world, far away (planes2D_high/low.x)\\n\\\n    // - so set \\"west\\" as beyond the westmost extent of the projection (idlSplitNewPlaneHiLow)\\n\\\n    idlSplit = planes2D_high.x > planes2D_high.w && position3DLow.y < 0.0;\\n\\\n    idlSplitNewPlaneHiLow = vec2(WEST_MOST_X_HIGH - (EAST_MOST_X_HIGH - planes2D_high.x), WEST_MOST_X_LOW - (EAST_MOST_X_LOW - planes2D_low.x));\\n\\\n    planes2D_high.x = czm_branchFreeTernary(idlSplit, idlSplitNewPlaneHiLow.x, planes2D_high.x);\\n\\\n    planes2D_low.x = czm_branchFreeTernary(idlSplit, idlSplitNewPlaneHiLow.y, planes2D_low.x);\\n\\\n\\n\\\n    vec3 southWestCorner = (czm_modelViewRelativeToEye * czm_translateRelativeToEye(vec3(0.0, planes2D_high.xy), vec3(0.0, planes2D_low.xy))).xyz;\\n\\\n    vec3 northWestCorner = (czm_modelViewRelativeToEye * czm_translateRelativeToEye(vec3(0.0, planes2D_high.x, planes2D_high.z), vec3(0.0, planes2D_low.x, planes2D_low.z))).xyz;\\n\\\n    vec3 southEastCorner = (czm_modelViewRelativeToEye * czm_translateRelativeToEye(vec3(0.0, planes2D_high.w, planes2D_high.y), vec3(0.0, planes2D_low.w, planes2D_low.y))).xyz;\\n\\\n#else // COLUMBUS_VIEW_2D\\n\\\n    // 3D case has smaller \\"plane extents,\\" so planes encoded as a 64 bit position and 2 vec3s for distances/direction\\n\\\n    vec3 southWestCorner = (czm_modelViewRelativeToEye * czm_translateRelativeToEye(czm_batchTable_southWest_HIGH(batchId), czm_batchTable_southWest_LOW(batchId))).xyz;\\n\\\n    vec3 northWestCorner = czm_normal * czm_batchTable_northward(batchId) + southWestCorner;\\n\\\n    vec3 southEastCorner = czm_normal * czm_batchTable_eastward(batchId) + southWestCorner;\\n\\\n#endif // COLUMBUS_VIEW_2D\\n\\\n\\n\\\n    vec3 eastWard = southEastCorner - southWestCorner;\\n\\\n    float eastExtent = length(eastWard);\\n\\\n    eastWard /= eastExtent;\\n\\\n\\n\\\n    vec3 northWard = northWestCorner - southWestCorner;\\n\\\n    float northExtent = length(northWard);\\n\\\n    northWard /= northExtent;\\n\\\n\\n\\\n    v_westPlane = vec4(eastWard, -dot(eastWard, southWestCorner));\\n\\\n    v_southPlane = vec4(northWard, -dot(northWard, southWestCorner));\\n\\\n    v_inversePlaneExtents = vec2(1.0 / eastExtent, 1.0 / northExtent);\\n\\\n#endif // SPHERICAL\\n\\\n    vec4 uvMinAndExtents = czm_batchTable_uvMinAndExtents(batchId);\\n\\\n    vec4 uMaxVmax = czm_batchTable_uMaxVmax(batchId);\\n\\\n\\n\\\n    v_uMaxAndInverseDistance = vec3(uMaxVmax.xy, uvMinAndExtents.z);\\n\\\n    v_vMaxAndInverseDistance = vec3(uMaxVmax.zw, uvMinAndExtents.w);\\n\\\n    v_uvMinAndSphericalLongitudeRotation.xy = uvMinAndExtents.xy;\\n\\\n#endif // TEXTURE_COORDINATES\\n\\\n\\n\\\n#ifdef PER_INSTANCE_COLOR\\n\\\n    v_color = czm_batchTable_color(batchId);\\n\\\n#endif\\n\\\n\\n\\\n    gl_Position = czm_depthClamp(czm_modelViewProjectionRelativeToEye * position);\\n\\\n}\\n\\\n");\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNzMyNTcuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQSx5REFBZSwrQkFBK0I7QUFDOUMsNkJBQTZCO0FBQzdCLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0EsZ0NBQWdDO0FBQ2hDO0FBQ0EscUNBQXFDO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQztBQUNoQztBQUNBLG1DQUFtQztBQUNuQyx5QkFBeUI7QUFDekIsMEJBQTBCO0FBQzFCO0FBQ0Esa0RBQWtEO0FBQ2xELHNDQUFzQztBQUN0QyxzQ0FBc0M7QUFDdEM7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNELDBDQUEwQztBQUMxQztBQUNBO0FBQ0Esc0dBQXNHO0FBQ3RHLDBEQUEwRDtBQUMxRDtBQUNBO0FBQ0EsOERBQThEO0FBQzlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0VBQWtFO0FBQ2xFLHVGQUF1RjtBQUN2RjtBQUNBO0FBQ0EsK0RBQStEO0FBQy9ELDZEQUE2RDtBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUpBQXFKO0FBQ3JKLCtFQUErRTtBQUMvRSxnR0FBZ0c7QUFDaEcsOEZBQThGO0FBQzlGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEVBQTBFO0FBQzFFLGdKQUFnSjtBQUNoSixnR0FBZ0c7QUFDaEcsOEZBQThGO0FBQzlGO0FBQ0Esa0pBQWtKO0FBQ2xKLGlMQUFpTDtBQUNqTCxpTEFBaUw7QUFDakw7QUFDQTtBQUNBLHdLQUF3SztBQUN4Syw0RkFBNEY7QUFDNUYsMkZBQTJGO0FBQzNGO0FBQ0E7QUFDQSxzREFBc0Q7QUFDdEQsd0NBQXdDO0FBQ3hDLDJCQUEyQjtBQUMzQjtBQUNBLHVEQUF1RDtBQUN2RCwwQ0FBMEM7QUFDMUMsNkJBQTZCO0FBQzdCO0FBQ0Esa0VBQWtFO0FBQ2xFLHFFQUFxRTtBQUNyRSxzRUFBc0U7QUFDdEU7QUFDQSxtRUFBbUU7QUFDbkUscURBQXFEO0FBQ3JEO0FBQ0Esb0VBQW9FO0FBQ3BFLG9FQUFvRTtBQUNwRSxpRUFBaUU7QUFDakU7QUFDQTtBQUNBO0FBQ0EsNENBQTRDO0FBQzVDO0FBQ0E7QUFDQSxrRkFBa0Y7QUFDbEYsQ0FBQztBQUNELENBQUMsRUFBQyIsInNvdXJjZXMiOlsid2VicGFjazovL3Z1ZTMtd2VicGFjazUvLi9ub2RlX21vZHVsZXMvY2VzaXVtL1NvdXJjZS9TaGFkZXJzL1NoYWRvd1ZvbHVtZUFwcGVhcmFuY2VWUy5qcz82NzVkIl0sInNvdXJjZXNDb250ZW50IjpbIi8vVGhpcyBmaWxlIGlzIGF1dG9tYXRpY2FsbHkgcmVidWlsdCBieSB0aGUgQ2VzaXVtIGJ1aWxkIHByb2Nlc3MuXG5leHBvcnQgZGVmYXVsdCBcImF0dHJpYnV0ZSB2ZWMzIHBvc2l0aW9uM0RIaWdoO1xcblxcXG5hdHRyaWJ1dGUgdmVjMyBwb3NpdGlvbjNETG93O1xcblxcXG5hdHRyaWJ1dGUgZmxvYXQgYmF0Y2hJZDtcXG5cXFxuXFxuXFxcbiNpZmRlZiBFWFRSVURFRF9HRU9NRVRSWVxcblxcXG5hdHRyaWJ1dGUgdmVjMyBleHRydWRlRGlyZWN0aW9uO1xcblxcXG5cXG5cXFxudW5pZm9ybSBmbG9hdCB1X2dsb2JlTWluaW11bUFsdGl0dWRlO1xcblxcXG4jZW5kaWYgLy8gRVhUUlVERURfR0VPTUVUUllcXG5cXFxuXFxuXFxcbiNpZmRlZiBQRVJfSU5TVEFOQ0VfQ09MT1JcXG5cXFxudmFyeWluZyB2ZWM0IHZfY29sb3I7XFxuXFxcbiNlbmRpZiAvLyBQRVJfSU5TVEFOQ0VfQ09MT1JcXG5cXFxuXFxuXFxcbiNpZmRlZiBURVhUVVJFX0NPT1JESU5BVEVTXFxuXFxcbiNpZmRlZiBTUEhFUklDQUxcXG5cXFxudmFyeWluZyB2ZWM0IHZfc3BoZXJpY2FsRXh0ZW50cztcXG5cXFxuI2Vsc2UgLy8gU1BIRVJJQ0FMXFxuXFxcbnZhcnlpbmcgdmVjMiB2X2ludmVyc2VQbGFuZUV4dGVudHM7XFxuXFxcbnZhcnlpbmcgdmVjNCB2X3dlc3RQbGFuZTtcXG5cXFxudmFyeWluZyB2ZWM0IHZfc291dGhQbGFuZTtcXG5cXFxuI2VuZGlmIC8vIFNQSEVSSUNBTFxcblxcXG52YXJ5aW5nIHZlYzMgdl91dk1pbkFuZFNwaGVyaWNhbExvbmdpdHVkZVJvdGF0aW9uO1xcblxcXG52YXJ5aW5nIHZlYzMgdl91TWF4QW5kSW52ZXJzZURpc3RhbmNlO1xcblxcXG52YXJ5aW5nIHZlYzMgdl92TWF4QW5kSW52ZXJzZURpc3RhbmNlO1xcblxcXG4jZW5kaWYgLy8gVEVYVFVSRV9DT09SRElOQVRFU1xcblxcXG5cXG5cXFxudm9pZCBtYWluKClcXG5cXFxue1xcblxcXG4gICAgdmVjNCBwb3NpdGlvbiA9IGN6bV9jb21wdXRlUG9zaXRpb24oKTtcXG5cXFxuXFxuXFxcbiNpZmRlZiBFWFRSVURFRF9HRU9NRVRSWVxcblxcXG4gICAgZmxvYXQgZGVsdGEgPSBtaW4odV9nbG9iZU1pbmltdW1BbHRpdHVkZSwgY3ptX2dlb21ldHJpY1RvbGVyYW5jZU92ZXJNZXRlciAqIGxlbmd0aChwb3NpdGlvbi54eXopKTtcXG5cXFxuICAgIGRlbHRhICo9IGN6bV9zY2VuZU1vZGUgPT0gY3ptX3NjZW5lTW9kZTNEID8gMS4wIDogMC4wO1xcblxcXG5cXG5cXFxuICAgIC8vZXh0cnVkZURpcmVjdGlvbiBpcyB6ZXJvIGZvciB0aGUgdG9wIGxheWVyXFxuXFxcbiAgICBwb3NpdGlvbiA9IHBvc2l0aW9uICsgdmVjNChleHRydWRlRGlyZWN0aW9uICogZGVsdGEsIDAuMCk7XFxuXFxcbiNlbmRpZlxcblxcXG5cXG5cXFxuI2lmZGVmIFRFWFRVUkVfQ09PUkRJTkFURVNcXG5cXFxuI2lmZGVmIFNQSEVSSUNBTFxcblxcXG4gICAgdl9zcGhlcmljYWxFeHRlbnRzID0gY3ptX2JhdGNoVGFibGVfc3BoZXJpY2FsRXh0ZW50cyhiYXRjaElkKTtcXG5cXFxuICAgIHZfdXZNaW5BbmRTcGhlcmljYWxMb25naXR1ZGVSb3RhdGlvbi56ID0gY3ptX2JhdGNoVGFibGVfbG9uZ2l0dWRlUm90YXRpb24oYmF0Y2hJZCk7XFxuXFxcbiNlbHNlIC8vIFNQSEVSSUNBTFxcblxcXG4jaWZkZWYgQ09MVU1CVVNfVklFV18yRFxcblxcXG4gICAgdmVjNCBwbGFuZXMyRF9oaWdoID0gY3ptX2JhdGNoVGFibGVfcGxhbmVzMkRfSElHSChiYXRjaElkKTtcXG5cXFxuICAgIHZlYzQgcGxhbmVzMkRfbG93ID0gY3ptX2JhdGNoVGFibGVfcGxhbmVzMkRfTE9XKGJhdGNoSWQpO1xcblxcXG5cXG5cXFxuICAgIC8vIElmIHRoZSBwcmltaXRpdmUgaXMgc3BsaXQgYWNyb3NzIHRoZSBJREwgKHBsYW5lczJEX2hpZ2gueCA+IHBsYW5lczJEX2hpZ2gudyk6XFxuXFxcbiAgICAvLyAtIElmIHRoaXMgdmVydGV4IGlzIG9uIHRoZSBlYXN0IHNpZGUgb2YgdGhlIElETCAocG9zaXRpb24zRExvdy55ID4gMC4wLCBjb21wYXJpc29uIHdpdGggcG9zaXRpb24zREhpZ2ggbWF5IHByb2R1Y2UgYXJ0aWZhY3RzKVxcblxcXG4gICAgLy8gLSBleGlzdGluZyBcXFwiZWFzdFxcXCIgaXMgb24gdGhlIHdyb25nIHNpZGUgb2YgdGhlIHdvcmxkLCBmYXIgYXdheSAocGxhbmVzMkRfaGlnaC9sb3cudylcXG5cXFxuICAgIC8vIC0gc28gc2V0IFxcXCJlYXN0XFxcIiBhcyBiZXlvbmQgdGhlIGVhc3Rtb3N0IGV4dGVudCBvZiB0aGUgcHJvamVjdGlvbiAoaWRsU3BsaXROZXdQbGFuZUhpTG93KVxcblxcXG4gICAgdmVjMiBpZGxTcGxpdE5ld1BsYW5lSGlMb3cgPSB2ZWMyKEVBU1RfTU9TVF9YX0hJR0ggLSAoV0VTVF9NT1NUX1hfSElHSCAtIHBsYW5lczJEX2hpZ2gudyksIEVBU1RfTU9TVF9YX0xPVyAtIChXRVNUX01PU1RfWF9MT1cgLSBwbGFuZXMyRF9sb3cudykpO1xcblxcXG4gICAgYm9vbCBpZGxTcGxpdCA9IHBsYW5lczJEX2hpZ2gueCA+IHBsYW5lczJEX2hpZ2gudyAmJiBwb3NpdGlvbjNETG93LnkgPiAwLjA7XFxuXFxcbiAgICBwbGFuZXMyRF9oaWdoLncgPSBjem1fYnJhbmNoRnJlZVRlcm5hcnkoaWRsU3BsaXQsIGlkbFNwbGl0TmV3UGxhbmVIaUxvdy54LCBwbGFuZXMyRF9oaWdoLncpO1xcblxcXG4gICAgcGxhbmVzMkRfbG93LncgPSBjem1fYnJhbmNoRnJlZVRlcm5hcnkoaWRsU3BsaXQsIGlkbFNwbGl0TmV3UGxhbmVIaUxvdy55LCBwbGFuZXMyRF9sb3cudyk7XFxuXFxcblxcblxcXG4gICAgLy8gLSBlbHNlLCBpZiB0aGlzIHZlcnRleCBpcyBvbiB0aGUgd2VzdCBzaWRlIG9mIHRoZSBJREwgKHBvc2l0aW9uM0RMb3cueSA8IDAuMClcXG5cXFxuICAgIC8vIC0gZXhpc3RpbmcgXFxcIndlc3RcXFwiIGlzIG9uIHRoZSB3cm9uZyBzaWRlIG9mIHRoZSB3b3JsZCwgZmFyIGF3YXkgKHBsYW5lczJEX2hpZ2gvbG93LngpXFxuXFxcbiAgICAvLyAtIHNvIHNldCBcXFwid2VzdFxcXCIgYXMgYmV5b25kIHRoZSB3ZXN0bW9zdCBleHRlbnQgb2YgdGhlIHByb2plY3Rpb24gKGlkbFNwbGl0TmV3UGxhbmVIaUxvdylcXG5cXFxuICAgIGlkbFNwbGl0ID0gcGxhbmVzMkRfaGlnaC54ID4gcGxhbmVzMkRfaGlnaC53ICYmIHBvc2l0aW9uM0RMb3cueSA8IDAuMDtcXG5cXFxuICAgIGlkbFNwbGl0TmV3UGxhbmVIaUxvdyA9IHZlYzIoV0VTVF9NT1NUX1hfSElHSCAtIChFQVNUX01PU1RfWF9ISUdIIC0gcGxhbmVzMkRfaGlnaC54KSwgV0VTVF9NT1NUX1hfTE9XIC0gKEVBU1RfTU9TVF9YX0xPVyAtIHBsYW5lczJEX2xvdy54KSk7XFxuXFxcbiAgICBwbGFuZXMyRF9oaWdoLnggPSBjem1fYnJhbmNoRnJlZVRlcm5hcnkoaWRsU3BsaXQsIGlkbFNwbGl0TmV3UGxhbmVIaUxvdy54LCBwbGFuZXMyRF9oaWdoLngpO1xcblxcXG4gICAgcGxhbmVzMkRfbG93LnggPSBjem1fYnJhbmNoRnJlZVRlcm5hcnkoaWRsU3BsaXQsIGlkbFNwbGl0TmV3UGxhbmVIaUxvdy55LCBwbGFuZXMyRF9sb3cueCk7XFxuXFxcblxcblxcXG4gICAgdmVjMyBzb3V0aFdlc3RDb3JuZXIgPSAoY3ptX21vZGVsVmlld1JlbGF0aXZlVG9FeWUgKiBjem1fdHJhbnNsYXRlUmVsYXRpdmVUb0V5ZSh2ZWMzKDAuMCwgcGxhbmVzMkRfaGlnaC54eSksIHZlYzMoMC4wLCBwbGFuZXMyRF9sb3cueHkpKSkueHl6O1xcblxcXG4gICAgdmVjMyBub3J0aFdlc3RDb3JuZXIgPSAoY3ptX21vZGVsVmlld1JlbGF0aXZlVG9FeWUgKiBjem1fdHJhbnNsYXRlUmVsYXRpdmVUb0V5ZSh2ZWMzKDAuMCwgcGxhbmVzMkRfaGlnaC54LCBwbGFuZXMyRF9oaWdoLnopLCB2ZWMzKDAuMCwgcGxhbmVzMkRfbG93LngsIHBsYW5lczJEX2xvdy56KSkpLnh5ejtcXG5cXFxuICAgIHZlYzMgc291dGhFYXN0Q29ybmVyID0gKGN6bV9tb2RlbFZpZXdSZWxhdGl2ZVRvRXllICogY3ptX3RyYW5zbGF0ZVJlbGF0aXZlVG9FeWUodmVjMygwLjAsIHBsYW5lczJEX2hpZ2gudywgcGxhbmVzMkRfaGlnaC55KSwgdmVjMygwLjAsIHBsYW5lczJEX2xvdy53LCBwbGFuZXMyRF9sb3cueSkpKS54eXo7XFxuXFxcbiNlbHNlIC8vIENPTFVNQlVTX1ZJRVdfMkRcXG5cXFxuICAgIC8vIDNEIGNhc2UgaGFzIHNtYWxsZXIgXFxcInBsYW5lIGV4dGVudHMsXFxcIiBzbyBwbGFuZXMgZW5jb2RlZCBhcyBhIDY0IGJpdCBwb3NpdGlvbiBhbmQgMiB2ZWMzcyBmb3IgZGlzdGFuY2VzL2RpcmVjdGlvblxcblxcXG4gICAgdmVjMyBzb3V0aFdlc3RDb3JuZXIgPSAoY3ptX21vZGVsVmlld1JlbGF0aXZlVG9FeWUgKiBjem1fdHJhbnNsYXRlUmVsYXRpdmVUb0V5ZShjem1fYmF0Y2hUYWJsZV9zb3V0aFdlc3RfSElHSChiYXRjaElkKSwgY3ptX2JhdGNoVGFibGVfc291dGhXZXN0X0xPVyhiYXRjaElkKSkpLnh5ejtcXG5cXFxuICAgIHZlYzMgbm9ydGhXZXN0Q29ybmVyID0gY3ptX25vcm1hbCAqIGN6bV9iYXRjaFRhYmxlX25vcnRod2FyZChiYXRjaElkKSArIHNvdXRoV2VzdENvcm5lcjtcXG5cXFxuICAgIHZlYzMgc291dGhFYXN0Q29ybmVyID0gY3ptX25vcm1hbCAqIGN6bV9iYXRjaFRhYmxlX2Vhc3R3YXJkKGJhdGNoSWQpICsgc291dGhXZXN0Q29ybmVyO1xcblxcXG4jZW5kaWYgLy8gQ09MVU1CVVNfVklFV18yRFxcblxcXG5cXG5cXFxuICAgIHZlYzMgZWFzdFdhcmQgPSBzb3V0aEVhc3RDb3JuZXIgLSBzb3V0aFdlc3RDb3JuZXI7XFxuXFxcbiAgICBmbG9hdCBlYXN0RXh0ZW50ID0gbGVuZ3RoKGVhc3RXYXJkKTtcXG5cXFxuICAgIGVhc3RXYXJkIC89IGVhc3RFeHRlbnQ7XFxuXFxcblxcblxcXG4gICAgdmVjMyBub3J0aFdhcmQgPSBub3J0aFdlc3RDb3JuZXIgLSBzb3V0aFdlc3RDb3JuZXI7XFxuXFxcbiAgICBmbG9hdCBub3J0aEV4dGVudCA9IGxlbmd0aChub3J0aFdhcmQpO1xcblxcXG4gICAgbm9ydGhXYXJkIC89IG5vcnRoRXh0ZW50O1xcblxcXG5cXG5cXFxuICAgIHZfd2VzdFBsYW5lID0gdmVjNChlYXN0V2FyZCwgLWRvdChlYXN0V2FyZCwgc291dGhXZXN0Q29ybmVyKSk7XFxuXFxcbiAgICB2X3NvdXRoUGxhbmUgPSB2ZWM0KG5vcnRoV2FyZCwgLWRvdChub3J0aFdhcmQsIHNvdXRoV2VzdENvcm5lcikpO1xcblxcXG4gICAgdl9pbnZlcnNlUGxhbmVFeHRlbnRzID0gdmVjMigxLjAgLyBlYXN0RXh0ZW50LCAxLjAgLyBub3J0aEV4dGVudCk7XFxuXFxcbiNlbmRpZiAvLyBTUEhFUklDQUxcXG5cXFxuICAgIHZlYzQgdXZNaW5BbmRFeHRlbnRzID0gY3ptX2JhdGNoVGFibGVfdXZNaW5BbmRFeHRlbnRzKGJhdGNoSWQpO1xcblxcXG4gICAgdmVjNCB1TWF4Vm1heCA9IGN6bV9iYXRjaFRhYmxlX3VNYXhWbWF4KGJhdGNoSWQpO1xcblxcXG5cXG5cXFxuICAgIHZfdU1heEFuZEludmVyc2VEaXN0YW5jZSA9IHZlYzModU1heFZtYXgueHksIHV2TWluQW5kRXh0ZW50cy56KTtcXG5cXFxuICAgIHZfdk1heEFuZEludmVyc2VEaXN0YW5jZSA9IHZlYzModU1heFZtYXguencsIHV2TWluQW5kRXh0ZW50cy53KTtcXG5cXFxuICAgIHZfdXZNaW5BbmRTcGhlcmljYWxMb25naXR1ZGVSb3RhdGlvbi54eSA9IHV2TWluQW5kRXh0ZW50cy54eTtcXG5cXFxuI2VuZGlmIC8vIFRFWFRVUkVfQ09PUkRJTkFURVNcXG5cXFxuXFxuXFxcbiNpZmRlZiBQRVJfSU5TVEFOQ0VfQ09MT1JcXG5cXFxuICAgIHZfY29sb3IgPSBjem1fYmF0Y2hUYWJsZV9jb2xvcihiYXRjaElkKTtcXG5cXFxuI2VuZGlmXFxuXFxcblxcblxcXG4gICAgZ2xfUG9zaXRpb24gPSBjem1fZGVwdGhDbGFtcChjem1fbW9kZWxWaWV3UHJvamVjdGlvblJlbGF0aXZlVG9FeWUgKiBwb3NpdGlvbik7XFxuXFxcbn1cXG5cXFxuXCI7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///73257\n')},79863:function(__unused_webpack___webpack_module__,__webpack_exports__){eval('//This file is automatically rebuilt by the Cesium build process.\n/* harmony default export */ __webpack_exports__["Z"] = ("#ifdef GL_EXT_frag_depth\\n\\\n#extension GL_EXT_frag_depth : enable\\n\\\n#endif\\n\\\n\\n\\\n#ifdef VECTOR_TILE\\n\\\nuniform vec4 u_highlightColor;\\n\\\n#endif\\n\\\n\\n\\\nvoid main(void)\\n\\\n{\\n\\\n#ifdef VECTOR_TILE\\n\\\n    gl_FragColor = czm_gammaCorrect(u_highlightColor);\\n\\\n#else\\n\\\n    gl_FragColor = vec4(1.0);\\n\\\n#endif\\n\\\n    czm_writeDepthClamp();\\n\\\n}\\n\\\n");\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNzk4NjMuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQSx5REFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBLHNEQUFzRDtBQUN0RDtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBLDBCQUEwQjtBQUMxQixDQUFDO0FBQ0QsQ0FBQyxFQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdnVlMy13ZWJwYWNrNS8uL25vZGVfbW9kdWxlcy9jZXNpdW0vU291cmNlL1NoYWRlcnMvU2hhZG93Vm9sdW1lRlMuanM/ZWQ1NiJdLCJzb3VyY2VzQ29udGVudCI6WyIvL1RoaXMgZmlsZSBpcyBhdXRvbWF0aWNhbGx5IHJlYnVpbHQgYnkgdGhlIENlc2l1bSBidWlsZCBwcm9jZXNzLlxuZXhwb3J0IGRlZmF1bHQgXCIjaWZkZWYgR0xfRVhUX2ZyYWdfZGVwdGhcXG5cXFxuI2V4dGVuc2lvbiBHTF9FWFRfZnJhZ19kZXB0aCA6IGVuYWJsZVxcblxcXG4jZW5kaWZcXG5cXFxuXFxuXFxcbiNpZmRlZiBWRUNUT1JfVElMRVxcblxcXG51bmlmb3JtIHZlYzQgdV9oaWdobGlnaHRDb2xvcjtcXG5cXFxuI2VuZGlmXFxuXFxcblxcblxcXG52b2lkIG1haW4odm9pZClcXG5cXFxue1xcblxcXG4jaWZkZWYgVkVDVE9SX1RJTEVcXG5cXFxuICAgIGdsX0ZyYWdDb2xvciA9IGN6bV9nYW1tYUNvcnJlY3QodV9oaWdobGlnaHRDb2xvcik7XFxuXFxcbiNlbHNlXFxuXFxcbiAgICBnbF9GcmFnQ29sb3IgPSB2ZWM0KDEuMCk7XFxuXFxcbiNlbmRpZlxcblxcXG4gICAgY3ptX3dyaXRlRGVwdGhDbGFtcCgpO1xcblxcXG59XFxuXFxcblwiO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///79863\n')},66629:function(__unused_webpack___webpack_module__,__webpack_exports__){eval('/**\n * @license\n * Copyright (c) 2000-2005, Sean O\'Neil (s_p_oneil@hotmail.com)\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n *\n * * Redistributions of source code must retain the above copyright notice,\n *   this list of conditions and the following disclaimer.\n * * Redistributions in binary form must reproduce the above copyright notice,\n *   this list of conditions and the following disclaimer in the documentation\n *   and/or other materials provided with the distribution.\n * * Neither the name of the project nor the names of its contributors may be\n *   used to endorse or promote products derived from this software without\n *   specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE\n * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\n * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER\n * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n *\n * Modifications made by Cesium GS, Inc.\n */\n//This file is automatically rebuilt by the Cesium build process.\n/* harmony default export */ __webpack_exports__["Z"] = ("/**\\n\\\n * @license\\n\\\n * Copyright (c) 2000-2005, Sean O\'Neil (s_p_oneil@hotmail.com)\\n\\\n * All rights reserved.\\n\\\n *\\n\\\n * Redistribution and use in source and binary forms, with or without\\n\\\n * modification, are permitted provided that the following conditions\\n\\\n * are met:\\n\\\n *\\n\\\n * * Redistributions of source code must retain the above copyright notice,\\n\\\n *   this list of conditions and the following disclaimer.\\n\\\n * * Redistributions in binary form must reproduce the above copyright notice,\\n\\\n *   this list of conditions and the following disclaimer in the documentation\\n\\\n *   and/or other materials provided with the distribution.\\n\\\n * * Neither the name of the project nor the names of its contributors may be\\n\\\n *   used to endorse or promote products derived from this software without\\n\\\n *   specific prior written permission.\\n\\\n *\\n\\\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \\"AS IS\\"\\n\\\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\\n\\\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\\n\\\n * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE\\n\\\n * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\\n\\\n * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\\n\\\n * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER\\n\\\n * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\\n\\\n * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\\n\\\n * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\\n\\\n *\\n\\\n * Modifications made by Cesium GS, Inc.\\n\\\n */\\n\\\n\\n\\\n // Code:  http://sponeil.net/\\n\\\n // GPU Gems 2 Article:  https://developer.nvidia.com/gpugems/GPUGems2/gpugems2_chapter16.html\\n\\\n\\n\\\nconst float Kr = 0.0025;\\n\\\nconst float Kr4PI = Kr * 4.0 * czm_pi;\\n\\\nconst float Km = 0.0015;\\n\\\nconst float Km4PI = Km * 4.0 * czm_pi;\\n\\\nconst float ESun = 15.0;\\n\\\nconst float KmESun = Km * ESun;\\n\\\nconst float KrESun = Kr * ESun;\\n\\\nconst vec3 InvWavelength = vec3(\\n\\\n    5.60204474633241,  // Red = 1.0 / Math.pow(0.650, 4.0)\\n\\\n    9.473284437923038, // Green = 1.0 / Math.pow(0.570, 4.0)\\n\\\n    19.643802610477206); // Blue = 1.0 / Math.pow(0.475, 4.0)\\n\\\nconst float rayleighScaleDepth = 0.25;\\n\\\n\\n\\\nconst int nSamples = 2;\\n\\\nconst float fSamples = 2.0;\\n\\\n\\n\\\nconst float g = -0.95;\\n\\\nconst float g2 = g * g;\\n\\\n\\n\\\n#ifdef COLOR_CORRECT\\n\\\nuniform vec3 u_hsbShift; // Hue, saturation, brightness\\n\\\n#endif\\n\\\n\\n\\\nuniform vec3 u_radiiAndDynamicAtmosphereColor; // outer radius, inner radius, dynamic atmosphere color flag\\n\\\n\\n\\\nfloat scale(float cosAngle)\\n\\\n{\\n\\\n    float x = 1.0 - cosAngle;\\n\\\n    return rayleighScaleDepth  * exp(-0.00287 + x*(0.459 + x*(3.83 + x*(-6.80 + x*5.25))));\\n\\\n}\\n\\\n\\n\\\nvec3 getLightDirection(vec3 positionWC)\\n\\\n{\\n\\\n    float lightEnum = u_radiiAndDynamicAtmosphereColor.z;\\n\\\n    vec3 lightDirection =\\n\\\n        positionWC * float(lightEnum == 0.0) +\\n\\\n        czm_lightDirectionWC * float(lightEnum == 1.0) +\\n\\\n        czm_sunDirectionWC * float(lightEnum == 2.0);\\n\\\n    return normalize(lightDirection);\\n\\\n}\\n\\\n\\n\\\nvoid calculateRayScatteringFromSpace(in vec3 positionWC, in vec3 ray, in float innerRadius, in float outerRadius, inout float far, out vec3 start, out float startOffset)\\n\\\n{\\n\\\n    // Calculate the closest intersection of the ray with the outer atmosphere (which is the near point of the ray passing through the atmosphere)\\n\\\n    float cameraHeight = length(positionWC);\\n\\\n    float B = 2.0 * dot(positionWC, ray);\\n\\\n    float C = cameraHeight * cameraHeight - outerRadius * outerRadius;\\n\\\n    float det = max(0.0, B * B - 4.0 * C);\\n\\\n    float near = 0.5 * (-B - sqrt(det));\\n\\\n\\n\\\n    // Calculate the ray\'s starting position, then calculate its scattering offset\\n\\\n    start = positionWC + ray * near;\\n\\\n    far -= near;\\n\\\n    float startAngle = dot(ray, start) / outerRadius;\\n\\\n    float startDepth = exp(-1.0 / rayleighScaleDepth);\\n\\\n    startOffset = startDepth * scale(startAngle);\\n\\\n}\\n\\\n\\n\\\nvoid calculateRayScatteringFromGround(in vec3 positionWC, in vec3 ray, in float atmosphereScale, in float innerRadius, out vec3 start, out float startOffset)\\n\\\n{\\n\\\n    // Calculate the ray\'s starting position, then calculate its scattering offset\\n\\\n    float cameraHeight = length(positionWC);\\n\\\n    start = positionWC;\\n\\\n    float height = length(start);\\n\\\n    float depth = exp((atmosphereScale / rayleighScaleDepth ) * (innerRadius - cameraHeight));\\n\\\n    float startAngle = dot(ray, start) / height;\\n\\\n    startOffset = depth*scale(startAngle);\\n\\\n}\\n\\\n\\n\\\nczm_raySegment rayEllipsoidIntersection(czm_ray ray, vec3 inverseRadii)\\n\\\n{\\n\\\n    vec3 o = inverseRadii * (czm_inverseView * vec4(ray.origin, 1.0)).xyz;\\n\\\n    vec3 d = inverseRadii * (czm_inverseView * vec4(ray.direction, 0.0)).xyz;\\n\\\n\\n\\\n    float a = dot(d, d);\\n\\\n    float b = dot(d, o);\\n\\\n    float c = dot(o, o) - 1.0;\\n\\\n    float discriminant = b * b - a * c;\\n\\\n    if (discriminant < 0.0)\\n\\\n    {\\n\\\n        return czm_emptyRaySegment;\\n\\\n    }\\n\\\n    discriminant = sqrt(discriminant);\\n\\\n    float t1 = (-b - discriminant) / a;\\n\\\n    float t2 = (-b + discriminant) / a;\\n\\\n\\n\\\n    if (t1 < 0.0 && t2 < 0.0)\\n\\\n    {\\n\\\n        return czm_emptyRaySegment;\\n\\\n    }\\n\\\n\\n\\\n    if (t1 < 0.0 && t2 >= 0.0)\\n\\\n    {\\n\\\n        t1 = 0.0;\\n\\\n    }\\n\\\n\\n\\\n    return czm_raySegment(t1, t2);\\n\\\n}\\n\\\n\\n\\\nvec3 getAdjustedPosition(vec3 positionWC, float innerRadius)\\n\\\n{\\n\\\n  // Adjust the camera position so that atmosphere color looks the same wherever the eye height is the same\\n\\\n  float cameraHeight = czm_eyeHeight + innerRadius;\\n\\\n  return normalize(positionWC) * cameraHeight;\\n\\\n}\\n\\\n\\n\\\nvec3 getTranslucentPosition(vec3 positionWC, vec3 outerPositionWC, float innerRadius, out bool intersectsEllipsoid)\\n\\\n{\\n\\\n    vec3 directionWC = normalize(outerPositionWC - positionWC);\\n\\\n    vec3 directionEC = czm_viewRotation * directionWC;\\n\\\n    czm_ray viewRay = czm_ray(vec3(0.0), directionEC);\\n\\\n    czm_raySegment raySegment = rayEllipsoidIntersection(viewRay, czm_ellipsoidInverseRadii);\\n\\\n    intersectsEllipsoid = raySegment.start >= 0.0;\\n\\\n\\n\\\n    if (intersectsEllipsoid)\\n\\\n    {\\n\\\n        return positionWC + raySegment.stop * directionWC;\\n\\\n    }\\n\\\n\\n\\\n    return getAdjustedPosition(positionWC, innerRadius);\\n\\\n}\\n\\\n\\n\\\nvoid calculateMieColorAndRayleighColor(vec3 outerPositionWC, out vec3 mieColor, out vec3 rayleighColor)\\n\\\n{\\n\\\n    // Unpack attributes\\n\\\n    float outerRadius = u_radiiAndDynamicAtmosphereColor.x;\\n\\\n    float innerRadius = u_radiiAndDynamicAtmosphereColor.y;\\n\\\n\\n\\\n#ifdef GLOBE_TRANSLUCENT\\n\\\n    bool intersectsEllipsoid = false;\\n\\\n    vec3 startPositionWC = getTranslucentPosition(czm_viewerPositionWC, outerPositionWC, innerRadius, intersectsEllipsoid);\\n\\\n#else\\n\\\n    vec3 startPositionWC = getAdjustedPosition(czm_viewerPositionWC, innerRadius);\\n\\\n#endif\\n\\\n\\n\\\n    vec3 lightDirection = getLightDirection(startPositionWC);\\n\\\n\\n\\\n    // Get the ray from the start position to the outer position and its length (which is the far point of the ray passing through the atmosphere)\\n\\\n    vec3 ray = outerPositionWC - startPositionWC;\\n\\\n    float far = length(ray);\\n\\\n    ray /= far;\\n\\\n\\n\\\n    float atmosphereScale = 1.0 / (outerRadius - innerRadius);\\n\\\n\\n\\\n    vec3 start;\\n\\\n    float startOffset;\\n\\\n\\n\\\n#ifdef SKY_FROM_SPACE\\n\\\n#ifdef GLOBE_TRANSLUCENT\\n\\\n    if (intersectsEllipsoid)\\n\\\n    {\\n\\\n        calculateRayScatteringFromGround(startPositionWC, ray, atmosphereScale, innerRadius, start, startOffset);\\n\\\n    }\\n\\\n    else\\n\\\n    {\\n\\\n        calculateRayScatteringFromSpace(startPositionWC, ray, innerRadius, outerRadius, far, start, startOffset);\\n\\\n    }\\n\\\n#else\\n\\\n    calculateRayScatteringFromSpace(startPositionWC, ray, innerRadius, outerRadius, far, start, startOffset);\\n\\\n#endif\\n\\\n#else\\n\\\n    calculateRayScatteringFromGround(startPositionWC, ray, atmosphereScale, innerRadius, start, startOffset);\\n\\\n#endif\\n\\\n\\n\\\n    // Initialize the scattering loop variables\\n\\\n    float sampleLength = far / fSamples;\\n\\\n    float scaledLength = sampleLength * atmosphereScale;\\n\\\n    vec3 sampleRay = ray * sampleLength;\\n\\\n    vec3 samplePoint = start + sampleRay * 0.5;\\n\\\n\\n\\\n    // Now loop through the sample rays\\n\\\n    vec3 frontColor = vec3(0.0, 0.0, 0.0);\\n\\\n\\n\\\n    for (int i = 0; i<nSamples; i++)\\n\\\n    {\\n\\\n        float height = length(samplePoint);\\n\\\n        float depth = exp((atmosphereScale / rayleighScaleDepth ) * (innerRadius - height));\\n\\\n        float fLightAngle = dot(lightDirection, samplePoint) / height;\\n\\\n        float fCameraAngle = dot(ray, samplePoint) / height;\\n\\\n        float fScatter = (startOffset + depth*(scale(fLightAngle) - scale(fCameraAngle)));\\n\\\n        vec3 attenuate = exp(-fScatter * (InvWavelength * Kr4PI + Km4PI));\\n\\\n        frontColor += attenuate * (depth * scaledLength);\\n\\\n        samplePoint += sampleRay;\\n\\\n    }\\n\\\n\\n\\\n    // Finally, scale the Mie and Rayleigh colors and set up the varying variables for the pixel shader\\n\\\n    mieColor = frontColor * KmESun;\\n\\\n    rayleighColor = frontColor * (InvWavelength * KrESun);\\n\\\n\\n\\\n    // Cap mie and rayleigh colors to prevent NaNs when vertex interpolation happens\\n\\\n    mieColor = min(mieColor, vec3(10000000.0));\\n\\\n    rayleighColor = min(rayleighColor, vec3(10000000.0));\\n\\\n}\\n\\\n\\n\\\nvec4 calculateFinalColor(vec3 positionWC, vec3 toCamera, vec3 lightDirection, vec3 mieColor, vec3 rayleighColor)\\n\\\n{\\n\\\n    // Extra normalize added for Android\\n\\\n    float cosAngle = dot(lightDirection, normalize(toCamera)) / length(toCamera);\\n\\\n    float rayleighPhase = 0.75 * (1.0 + cosAngle * cosAngle);\\n\\\n    float miePhase = 1.5 * ((1.0 - g2) / (2.0 + g2)) * (1.0 + cosAngle * cosAngle) / pow(1.0 + g2 - 2.0 * g * cosAngle, 1.5);\\n\\\n\\n\\\n    vec3 rgb = rayleighPhase * rayleighColor + miePhase * mieColor;\\n\\\n\\n\\\n    const float exposure = 2.0;\\n\\\n    vec3 rgbExposure = vec3(1.0) - exp(-exposure * rgb);\\n\\\n\\n\\\n#ifndef HDR\\n\\\n    rgb = rgbExposure;\\n\\\n#endif\\n\\\n\\n\\\n#ifdef COLOR_CORRECT\\n\\\n    // Convert rgb color to hsb\\n\\\n    vec3 hsb = czm_RGBToHSB(rgb);\\n\\\n    // Perform hsb shift\\n\\\n    hsb.x += u_hsbShift.x; // hue\\n\\\n    hsb.y = clamp(hsb.y + u_hsbShift.y, 0.0, 1.0); // saturation\\n\\\n    hsb.z = hsb.z > czm_epsilon7 ? hsb.z + u_hsbShift.z : 0.0; // brightness\\n\\\n    // Convert shifted hsb back to rgb\\n\\\n    rgb = czm_HSBToRGB(hsb);\\n\\\n#endif\\n\\\n\\n\\\n    float outerRadius = u_radiiAndDynamicAtmosphereColor.x;\\n\\\n    float innerRadius = u_radiiAndDynamicAtmosphereColor.y;\\n\\\n    float lightEnum = u_radiiAndDynamicAtmosphereColor.z;\\n\\\n\\n\\\n    float cameraHeight = czm_eyeHeight + innerRadius;\\n\\\n\\n\\\n    // Alter alpha based on how close the viewer is to the ground (1.0 = on ground, 0.0 = at edge of atmosphere)\\n\\\n    float atmosphereAlpha = clamp((outerRadius - cameraHeight) / (outerRadius - innerRadius), 0.0, 1.0);\\n\\\n\\n\\\n    // Alter alpha based on time of day (0.0 = night , 1.0 = day)\\n\\\n    float nightAlpha = (lightEnum != 0.0) ? clamp(dot(normalize(positionWC), lightDirection), 0.0, 1.0) : 1.0;\\n\\\n    atmosphereAlpha *= pow(nightAlpha, 0.5);\\n\\\n\\n\\\n    vec4 finalColor = vec4(rgb, mix(clamp(rgbExposure.b, 0.0, 1.0), 1.0, atmosphereAlpha) * smoothstep(0.0, 1.0, czm_morphTime));\\n\\\n\\n\\\n    if (mieColor.b > 1.0)\\n\\\n    {\\n\\\n        // Fade atmosphere below the ellipsoid. As the camera zooms further away from the ellipsoid draw\\n\\\n        // a larger atmosphere ring to cover empty space of lower LOD globe tiles.\\n\\\n        float strength = mieColor.b;\\n\\\n        float minDistance = outerRadius;\\n\\\n        float maxDistance = outerRadius * 3.0;\\n\\\n        float maxStrengthLerp = 1.0 - clamp((maxDistance - cameraHeight) / (maxDistance - minDistance), 0.0, 1.0);\\n\\\n        float maxStrength = mix(100.0, 10000.0, maxStrengthLerp);\\n\\\n        strength = min(strength, maxStrength);\\n\\\n        float alpha = 1.0 - (strength / maxStrength);\\n\\\n        finalColor.a = alpha;\\n\\\n    }\\n\\\n\\n\\\n    return finalColor;\\n\\\n}\\n\\\n");\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNjY2MjkuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSwrQkFBK0I7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5REFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLCtCQUErQjtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QixzQ0FBc0M7QUFDdEMsd0JBQXdCO0FBQ3hCLHNDQUFzQztBQUN0Qyx3QkFBd0I7QUFDeEIsK0JBQStCO0FBQy9CLCtCQUErQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekIsc0NBQXNDO0FBQ3RDO0FBQ0EsdUJBQXVCO0FBQ3ZCLDJCQUEyQjtBQUMzQjtBQUNBLHNCQUFzQjtBQUN0Qix1QkFBdUI7QUFDdkI7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0EsK0NBQStDO0FBQy9DO0FBQ0E7QUFDQSxDQUFDO0FBQ0QsNkJBQTZCO0FBQzdCLDJGQUEyRjtBQUMzRixDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRCx5REFBeUQ7QUFDekQ7QUFDQTtBQUNBO0FBQ0EscURBQXFEO0FBQ3JELHFDQUFxQztBQUNyQyxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBLDRDQUE0QztBQUM1Qyx5Q0FBeUM7QUFDekMsc0VBQXNFO0FBQ3RFLDBDQUEwQztBQUMxQyx3Q0FBd0M7QUFDeEM7QUFDQTtBQUNBLG9DQUFvQztBQUNwQyxnQkFBZ0I7QUFDaEIscURBQXFEO0FBQ3JELHNEQUFzRDtBQUN0RCxpREFBaUQ7QUFDakQsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQSw0Q0FBNEM7QUFDNUMsdUJBQXVCO0FBQ3ZCLGlDQUFpQztBQUNqQyw4RkFBOEY7QUFDOUYsZ0RBQWdEO0FBQ2hELDBDQUEwQztBQUMxQyxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRCwwRUFBMEU7QUFDMUUsNkVBQTZFO0FBQzdFO0FBQ0Esd0JBQXdCO0FBQ3hCLHdCQUF3QjtBQUN4Qiw4QkFBOEI7QUFDOUIsdUNBQXVDO0FBQ3ZDO0FBQ0EsS0FBSztBQUNMLG1DQUFtQztBQUNuQyxLQUFLO0FBQ0wsc0NBQXNDO0FBQ3RDLHVDQUF1QztBQUN2Qyx1Q0FBdUM7QUFDdkM7QUFDQTtBQUNBLEtBQUs7QUFDTCxtQ0FBbUM7QUFDbkMsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsaUJBQWlCO0FBQ2pCLEtBQUs7QUFDTDtBQUNBLGtDQUFrQztBQUNsQyxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBLG1EQUFtRDtBQUNuRCw4Q0FBOEM7QUFDOUMsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0QsK0RBQStEO0FBQy9ELHNEQUFzRDtBQUN0RCxzREFBc0Q7QUFDdEQsNkZBQTZGO0FBQzdGLGtEQUFrRDtBQUNsRDtBQUNBO0FBQ0EsS0FBSztBQUNMLDBEQUEwRDtBQUMxRCxLQUFLO0FBQ0w7QUFDQSx3REFBd0Q7QUFDeEQsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQSwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNEO0FBQ0E7QUFDQSxxQ0FBcUM7QUFDckMsMkhBQTJIO0FBQzNIO0FBQ0Esa0ZBQWtGO0FBQ2xGO0FBQ0E7QUFDQSw2REFBNkQ7QUFDN0Q7QUFDQTtBQUNBLGlEQUFpRDtBQUNqRCw0QkFBNEI7QUFDNUIsZUFBZTtBQUNmO0FBQ0EsOERBQThEO0FBQzlEO0FBQ0EsZUFBZTtBQUNmLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxpSEFBaUg7QUFDakgsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMLGlIQUFpSDtBQUNqSCxLQUFLO0FBQ0w7QUFDQSw2R0FBNkc7QUFDN0c7QUFDQTtBQUNBLDZHQUE2RztBQUM3RztBQUNBO0FBQ0E7QUFDQSx3Q0FBd0M7QUFDeEMsd0RBQXdEO0FBQ3hELHdDQUF3QztBQUN4QywrQ0FBK0M7QUFDL0M7QUFDQTtBQUNBLDBDQUEwQztBQUMxQztBQUNBLG9CQUFvQixZQUFZO0FBQ2hDLEtBQUs7QUFDTCwyQ0FBMkM7QUFDM0MsNEZBQTRGO0FBQzVGLHNFQUFzRTtBQUN0RSw0REFBNEQ7QUFDNUQsMEZBQTBGO0FBQzFGLDBFQUEwRTtBQUMxRSx5REFBeUQ7QUFDekQsaUNBQWlDO0FBQ2pDLEtBQUs7QUFDTDtBQUNBO0FBQ0EsbUNBQW1DO0FBQ25DLDBEQUEwRDtBQUMxRDtBQUNBO0FBQ0EsK0NBQStDO0FBQy9DLHlEQUF5RDtBQUN6RCxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBLGlGQUFpRjtBQUNqRiw2REFBNkQ7QUFDN0QsNkhBQTZIO0FBQzdIO0FBQ0EsbUVBQW1FO0FBQ25FO0FBQ0EsK0JBQStCO0FBQy9CLHdEQUF3RDtBQUN4RDtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDO0FBQ2pDO0FBQ0EsMkJBQTJCO0FBQzNCLG1EQUFtRDtBQUNuRCwrREFBK0Q7QUFDL0Q7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBLDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QseURBQXlEO0FBQ3pEO0FBQ0EscURBQXFEO0FBQ3JEO0FBQ0E7QUFDQSx3R0FBd0c7QUFDeEc7QUFDQTtBQUNBLDhHQUE4RztBQUM5Ryw0Q0FBNEM7QUFDNUM7QUFDQSxpSUFBaUk7QUFDakk7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0Esb0NBQW9DO0FBQ3BDLHdDQUF3QztBQUN4Qyw4Q0FBOEM7QUFDOUMsa0hBQWtIO0FBQ2xILGlFQUFpRTtBQUNqRSw4Q0FBOEM7QUFDOUMscURBQXFEO0FBQ3JELDZCQUE2QjtBQUM3QixLQUFLO0FBQ0w7QUFDQSxzQkFBc0I7QUFDdEIsQ0FBQztBQUNELENBQUMsRUFBQyIsInNvdXJjZXMiOlsid2VicGFjazovL3Z1ZTMtd2VicGFjazUvLi9ub2RlX21vZHVsZXMvY2VzaXVtL1NvdXJjZS9TaGFkZXJzL1NreUF0bW9zcGhlcmVDb21tb24uanM/YTNmZCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgKGMpIDIwMDAtMjAwNSwgU2VhbiBPJ05laWwgKHNfcF9vbmVpbEBob3RtYWlsLmNvbSlcbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogUmVkaXN0cmlidXRpb24gYW5kIHVzZSBpbiBzb3VyY2UgYW5kIGJpbmFyeSBmb3Jtcywgd2l0aCBvciB3aXRob3V0XG4gKiBtb2RpZmljYXRpb24sIGFyZSBwZXJtaXR0ZWQgcHJvdmlkZWQgdGhhdCB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnNcbiAqIGFyZSBtZXQ6XG4gKlxuICogKiBSZWRpc3RyaWJ1dGlvbnMgb2Ygc291cmNlIGNvZGUgbXVzdCByZXRhaW4gdGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UsXG4gKiAgIHRoaXMgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nIGRpc2NsYWltZXIuXG4gKiAqIFJlZGlzdHJpYnV0aW9ucyBpbiBiaW5hcnkgZm9ybSBtdXN0IHJlcHJvZHVjZSB0aGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSxcbiAqICAgdGhpcyBsaXN0IG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmcgZGlzY2xhaW1lciBpbiB0aGUgZG9jdW1lbnRhdGlvblxuICogICBhbmQvb3Igb3RoZXIgbWF0ZXJpYWxzIHByb3ZpZGVkIHdpdGggdGhlIGRpc3RyaWJ1dGlvbi5cbiAqICogTmVpdGhlciB0aGUgbmFtZSBvZiB0aGUgcHJvamVjdCBub3IgdGhlIG5hbWVzIG9mIGl0cyBjb250cmlidXRvcnMgbWF5IGJlXG4gKiAgIHVzZWQgdG8gZW5kb3JzZSBvciBwcm9tb3RlIHByb2R1Y3RzIGRlcml2ZWQgZnJvbSB0aGlzIHNvZnR3YXJlIHdpdGhvdXRcbiAqICAgc3BlY2lmaWMgcHJpb3Igd3JpdHRlbiBwZXJtaXNzaW9uLlxuICpcbiAqIFRISVMgU09GVFdBUkUgSVMgUFJPVklERUQgQlkgVEhFIENPUFlSSUdIVCBIT0xERVJTIEFORCBDT05UUklCVVRPUlMgXCJBUyBJU1wiXG4gKiBBTkQgQU5ZIEVYUFJFU1MgT1IgSU1QTElFRCBXQVJSQU5USUVTLCBJTkNMVURJTkcsIEJVVCBOT1QgTElNSVRFRCBUTywgVEhFXG4gKiBJTVBMSUVEIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZIEFORCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBUkVcbiAqIERJU0NMQUlNRUQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBDT1BZUklHSFQgT1dORVIgT1IgQ09OVFJJQlVUT1JTIEJFIExJQUJMRVxuICogRk9SIEFOWSBESVJFQ1QsIElORElSRUNULCBJTkNJREVOVEFMLCBTUEVDSUFMLCBFWEVNUExBUlksIE9SIENPTlNFUVVFTlRJQUxcbiAqIERBTUFHRVMgKElOQ0xVRElORywgQlVUIE5PVCBMSU1JVEVEIFRPLCBQUk9DVVJFTUVOVCBPRiBTVUJTVElUVVRFIEdPT0RTIE9SXG4gKiBTRVJWSUNFUzsgTE9TUyBPRiBVU0UsIERBVEEsIE9SIFBST0ZJVFM7IE9SIEJVU0lORVNTIElOVEVSUlVQVElPTikgSE9XRVZFUlxuICogQ0FVU0VEIEFORCBPTiBBTlkgVEhFT1JZIE9GIExJQUJJTElUWSwgV0hFVEhFUiBJTiBDT05UUkFDVCwgU1RSSUNUIExJQUJJTElUWSxcbiAqIE9SIFRPUlQgKElOQ0xVRElORyBORUdMSUdFTkNFIE9SIE9USEVSV0lTRSkgQVJJU0lORyBJTiBBTlkgV0FZIE9VVCBPRiBUSEUgVVNFXG4gKiBPRiBUSElTIFNPRlRXQVJFLCBFVkVOIElGIEFEVklTRUQgT0YgVEhFIFBPU1NJQklMSVRZIE9GIFNVQ0ggREFNQUdFLlxuICpcbiAqIE1vZGlmaWNhdGlvbnMgbWFkZSBieSBDZXNpdW0gR1MsIEluYy5cbiAqL1xuLy9UaGlzIGZpbGUgaXMgYXV0b21hdGljYWxseSByZWJ1aWx0IGJ5IHRoZSBDZXNpdW0gYnVpbGQgcHJvY2Vzcy5cbmV4cG9ydCBkZWZhdWx0IFwiLyoqXFxuXFxcbiAqIEBsaWNlbnNlXFxuXFxcbiAqIENvcHlyaWdodCAoYykgMjAwMC0yMDA1LCBTZWFuIE8nTmVpbCAoc19wX29uZWlsQGhvdG1haWwuY29tKVxcblxcXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxcblxcXG4gKlxcblxcXG4gKiBSZWRpc3RyaWJ1dGlvbiBhbmQgdXNlIGluIHNvdXJjZSBhbmQgYmluYXJ5IGZvcm1zLCB3aXRoIG9yIHdpdGhvdXRcXG5cXFxuICogbW9kaWZpY2F0aW9uLCBhcmUgcGVybWl0dGVkIHByb3ZpZGVkIHRoYXQgdGhlIGZvbGxvd2luZyBjb25kaXRpb25zXFxuXFxcbiAqIGFyZSBtZXQ6XFxuXFxcbiAqXFxuXFxcbiAqICogUmVkaXN0cmlidXRpb25zIG9mIHNvdXJjZSBjb2RlIG11c3QgcmV0YWluIHRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlLFxcblxcXG4gKiAgIHRoaXMgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nIGRpc2NsYWltZXIuXFxuXFxcbiAqICogUmVkaXN0cmlidXRpb25zIGluIGJpbmFyeSBmb3JtIG11c3QgcmVwcm9kdWNlIHRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlLFxcblxcXG4gKiAgIHRoaXMgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nIGRpc2NsYWltZXIgaW4gdGhlIGRvY3VtZW50YXRpb25cXG5cXFxuICogICBhbmQvb3Igb3RoZXIgbWF0ZXJpYWxzIHByb3ZpZGVkIHdpdGggdGhlIGRpc3RyaWJ1dGlvbi5cXG5cXFxuICogKiBOZWl0aGVyIHRoZSBuYW1lIG9mIHRoZSBwcm9qZWN0IG5vciB0aGUgbmFtZXMgb2YgaXRzIGNvbnRyaWJ1dG9ycyBtYXkgYmVcXG5cXFxuICogICB1c2VkIHRvIGVuZG9yc2Ugb3IgcHJvbW90ZSBwcm9kdWN0cyBkZXJpdmVkIGZyb20gdGhpcyBzb2Z0d2FyZSB3aXRob3V0XFxuXFxcbiAqICAgc3BlY2lmaWMgcHJpb3Igd3JpdHRlbiBwZXJtaXNzaW9uLlxcblxcXG4gKlxcblxcXG4gKiBUSElTIFNPRlRXQVJFIElTIFBST1ZJREVEIEJZIFRIRSBDT1BZUklHSFQgSE9MREVSUyBBTkQgQ09OVFJJQlVUT1JTIFxcXCJBUyBJU1xcXCJcXG5cXFxuICogQU5EIEFOWSBFWFBSRVNTIE9SIElNUExJRUQgV0FSUkFOVElFUywgSU5DTFVESU5HLCBCVVQgTk9UIExJTUlURUQgVE8sIFRIRVxcblxcXG4gKiBJTVBMSUVEIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZIEFORCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBUkVcXG5cXFxuICogRElTQ0xBSU1FRC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIENPUFlSSUdIVCBPV05FUiBPUiBDT05UUklCVVRPUlMgQkUgTElBQkxFXFxuXFxcbiAqIEZPUiBBTlkgRElSRUNULCBJTkRJUkVDVCwgSU5DSURFTlRBTCwgU1BFQ0lBTCwgRVhFTVBMQVJZLCBPUiBDT05TRVFVRU5USUFMXFxuXFxcbiAqIERBTUFHRVMgKElOQ0xVRElORywgQlVUIE5PVCBMSU1JVEVEIFRPLCBQUk9DVVJFTUVOVCBPRiBTVUJTVElUVVRFIEdPT0RTIE9SXFxuXFxcbiAqIFNFUlZJQ0VTOyBMT1NTIE9GIFVTRSwgREFUQSwgT1IgUFJPRklUUzsgT1IgQlVTSU5FU1MgSU5URVJSVVBUSU9OKSBIT1dFVkVSXFxuXFxcbiAqIENBVVNFRCBBTkQgT04gQU5ZIFRIRU9SWSBPRiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQ09OVFJBQ1QsIFNUUklDVCBMSUFCSUxJVFksXFxuXFxcbiAqIE9SIFRPUlQgKElOQ0xVRElORyBORUdMSUdFTkNFIE9SIE9USEVSV0lTRSkgQVJJU0lORyBJTiBBTlkgV0FZIE9VVCBPRiBUSEUgVVNFXFxuXFxcbiAqIE9GIFRISVMgU09GVFdBUkUsIEVWRU4gSUYgQURWSVNFRCBPRiBUSEUgUE9TU0lCSUxJVFkgT0YgU1VDSCBEQU1BR0UuXFxuXFxcbiAqXFxuXFxcbiAqIE1vZGlmaWNhdGlvbnMgbWFkZSBieSBDZXNpdW0gR1MsIEluYy5cXG5cXFxuICovXFxuXFxcblxcblxcXG4gLy8gQ29kZTogIGh0dHA6Ly9zcG9uZWlsLm5ldC9cXG5cXFxuIC8vIEdQVSBHZW1zIDIgQXJ0aWNsZTogIGh0dHBzOi8vZGV2ZWxvcGVyLm52aWRpYS5jb20vZ3B1Z2Vtcy9HUFVHZW1zMi9ncHVnZW1zMl9jaGFwdGVyMTYuaHRtbFxcblxcXG5cXG5cXFxuY29uc3QgZmxvYXQgS3IgPSAwLjAwMjU7XFxuXFxcbmNvbnN0IGZsb2F0IEtyNFBJID0gS3IgKiA0LjAgKiBjem1fcGk7XFxuXFxcbmNvbnN0IGZsb2F0IEttID0gMC4wMDE1O1xcblxcXG5jb25zdCBmbG9hdCBLbTRQSSA9IEttICogNC4wICogY3ptX3BpO1xcblxcXG5jb25zdCBmbG9hdCBFU3VuID0gMTUuMDtcXG5cXFxuY29uc3QgZmxvYXQgS21FU3VuID0gS20gKiBFU3VuO1xcblxcXG5jb25zdCBmbG9hdCBLckVTdW4gPSBLciAqIEVTdW47XFxuXFxcbmNvbnN0IHZlYzMgSW52V2F2ZWxlbmd0aCA9IHZlYzMoXFxuXFxcbiAgICA1LjYwMjA0NDc0NjMzMjQxLCAgLy8gUmVkID0gMS4wIC8gTWF0aC5wb3coMC42NTAsIDQuMClcXG5cXFxuICAgIDkuNDczMjg0NDM3OTIzMDM4LCAvLyBHcmVlbiA9IDEuMCAvIE1hdGgucG93KDAuNTcwLCA0LjApXFxuXFxcbiAgICAxOS42NDM4MDI2MTA0NzcyMDYpOyAvLyBCbHVlID0gMS4wIC8gTWF0aC5wb3coMC40NzUsIDQuMClcXG5cXFxuY29uc3QgZmxvYXQgcmF5bGVpZ2hTY2FsZURlcHRoID0gMC4yNTtcXG5cXFxuXFxuXFxcbmNvbnN0IGludCBuU2FtcGxlcyA9IDI7XFxuXFxcbmNvbnN0IGZsb2F0IGZTYW1wbGVzID0gMi4wO1xcblxcXG5cXG5cXFxuY29uc3QgZmxvYXQgZyA9IC0wLjk1O1xcblxcXG5jb25zdCBmbG9hdCBnMiA9IGcgKiBnO1xcblxcXG5cXG5cXFxuI2lmZGVmIENPTE9SX0NPUlJFQ1RcXG5cXFxudW5pZm9ybSB2ZWMzIHVfaHNiU2hpZnQ7IC8vIEh1ZSwgc2F0dXJhdGlvbiwgYnJpZ2h0bmVzc1xcblxcXG4jZW5kaWZcXG5cXFxuXFxuXFxcbnVuaWZvcm0gdmVjMyB1X3JhZGlpQW5kRHluYW1pY0F0bW9zcGhlcmVDb2xvcjsgLy8gb3V0ZXIgcmFkaXVzLCBpbm5lciByYWRpdXMsIGR5bmFtaWMgYXRtb3NwaGVyZSBjb2xvciBmbGFnXFxuXFxcblxcblxcXG5mbG9hdCBzY2FsZShmbG9hdCBjb3NBbmdsZSlcXG5cXFxue1xcblxcXG4gICAgZmxvYXQgeCA9IDEuMCAtIGNvc0FuZ2xlO1xcblxcXG4gICAgcmV0dXJuIHJheWxlaWdoU2NhbGVEZXB0aCAgKiBleHAoLTAuMDAyODcgKyB4KigwLjQ1OSArIHgqKDMuODMgKyB4KigtNi44MCArIHgqNS4yNSkpKSk7XFxuXFxcbn1cXG5cXFxuXFxuXFxcbnZlYzMgZ2V0TGlnaHREaXJlY3Rpb24odmVjMyBwb3NpdGlvbldDKVxcblxcXG57XFxuXFxcbiAgICBmbG9hdCBsaWdodEVudW0gPSB1X3JhZGlpQW5kRHluYW1pY0F0bW9zcGhlcmVDb2xvci56O1xcblxcXG4gICAgdmVjMyBsaWdodERpcmVjdGlvbiA9XFxuXFxcbiAgICAgICAgcG9zaXRpb25XQyAqIGZsb2F0KGxpZ2h0RW51bSA9PSAwLjApICtcXG5cXFxuICAgICAgICBjem1fbGlnaHREaXJlY3Rpb25XQyAqIGZsb2F0KGxpZ2h0RW51bSA9PSAxLjApICtcXG5cXFxuICAgICAgICBjem1fc3VuRGlyZWN0aW9uV0MgKiBmbG9hdChsaWdodEVudW0gPT0gMi4wKTtcXG5cXFxuICAgIHJldHVybiBub3JtYWxpemUobGlnaHREaXJlY3Rpb24pO1xcblxcXG59XFxuXFxcblxcblxcXG52b2lkIGNhbGN1bGF0ZVJheVNjYXR0ZXJpbmdGcm9tU3BhY2UoaW4gdmVjMyBwb3NpdGlvbldDLCBpbiB2ZWMzIHJheSwgaW4gZmxvYXQgaW5uZXJSYWRpdXMsIGluIGZsb2F0IG91dGVyUmFkaXVzLCBpbm91dCBmbG9hdCBmYXIsIG91dCB2ZWMzIHN0YXJ0LCBvdXQgZmxvYXQgc3RhcnRPZmZzZXQpXFxuXFxcbntcXG5cXFxuICAgIC8vIENhbGN1bGF0ZSB0aGUgY2xvc2VzdCBpbnRlcnNlY3Rpb24gb2YgdGhlIHJheSB3aXRoIHRoZSBvdXRlciBhdG1vc3BoZXJlICh3aGljaCBpcyB0aGUgbmVhciBwb2ludCBvZiB0aGUgcmF5IHBhc3NpbmcgdGhyb3VnaCB0aGUgYXRtb3NwaGVyZSlcXG5cXFxuICAgIGZsb2F0IGNhbWVyYUhlaWdodCA9IGxlbmd0aChwb3NpdGlvbldDKTtcXG5cXFxuICAgIGZsb2F0IEIgPSAyLjAgKiBkb3QocG9zaXRpb25XQywgcmF5KTtcXG5cXFxuICAgIGZsb2F0IEMgPSBjYW1lcmFIZWlnaHQgKiBjYW1lcmFIZWlnaHQgLSBvdXRlclJhZGl1cyAqIG91dGVyUmFkaXVzO1xcblxcXG4gICAgZmxvYXQgZGV0ID0gbWF4KDAuMCwgQiAqIEIgLSA0LjAgKiBDKTtcXG5cXFxuICAgIGZsb2F0IG5lYXIgPSAwLjUgKiAoLUIgLSBzcXJ0KGRldCkpO1xcblxcXG5cXG5cXFxuICAgIC8vIENhbGN1bGF0ZSB0aGUgcmF5J3Mgc3RhcnRpbmcgcG9zaXRpb24sIHRoZW4gY2FsY3VsYXRlIGl0cyBzY2F0dGVyaW5nIG9mZnNldFxcblxcXG4gICAgc3RhcnQgPSBwb3NpdGlvbldDICsgcmF5ICogbmVhcjtcXG5cXFxuICAgIGZhciAtPSBuZWFyO1xcblxcXG4gICAgZmxvYXQgc3RhcnRBbmdsZSA9IGRvdChyYXksIHN0YXJ0KSAvIG91dGVyUmFkaXVzO1xcblxcXG4gICAgZmxvYXQgc3RhcnREZXB0aCA9IGV4cCgtMS4wIC8gcmF5bGVpZ2hTY2FsZURlcHRoKTtcXG5cXFxuICAgIHN0YXJ0T2Zmc2V0ID0gc3RhcnREZXB0aCAqIHNjYWxlKHN0YXJ0QW5nbGUpO1xcblxcXG59XFxuXFxcblxcblxcXG52b2lkIGNhbGN1bGF0ZVJheVNjYXR0ZXJpbmdGcm9tR3JvdW5kKGluIHZlYzMgcG9zaXRpb25XQywgaW4gdmVjMyByYXksIGluIGZsb2F0IGF0bW9zcGhlcmVTY2FsZSwgaW4gZmxvYXQgaW5uZXJSYWRpdXMsIG91dCB2ZWMzIHN0YXJ0LCBvdXQgZmxvYXQgc3RhcnRPZmZzZXQpXFxuXFxcbntcXG5cXFxuICAgIC8vIENhbGN1bGF0ZSB0aGUgcmF5J3Mgc3RhcnRpbmcgcG9zaXRpb24sIHRoZW4gY2FsY3VsYXRlIGl0cyBzY2F0dGVyaW5nIG9mZnNldFxcblxcXG4gICAgZmxvYXQgY2FtZXJhSGVpZ2h0ID0gbGVuZ3RoKHBvc2l0aW9uV0MpO1xcblxcXG4gICAgc3RhcnQgPSBwb3NpdGlvbldDO1xcblxcXG4gICAgZmxvYXQgaGVpZ2h0ID0gbGVuZ3RoKHN0YXJ0KTtcXG5cXFxuICAgIGZsb2F0IGRlcHRoID0gZXhwKChhdG1vc3BoZXJlU2NhbGUgLyByYXlsZWlnaFNjYWxlRGVwdGggKSAqIChpbm5lclJhZGl1cyAtIGNhbWVyYUhlaWdodCkpO1xcblxcXG4gICAgZmxvYXQgc3RhcnRBbmdsZSA9IGRvdChyYXksIHN0YXJ0KSAvIGhlaWdodDtcXG5cXFxuICAgIHN0YXJ0T2Zmc2V0ID0gZGVwdGgqc2NhbGUoc3RhcnRBbmdsZSk7XFxuXFxcbn1cXG5cXFxuXFxuXFxcbmN6bV9yYXlTZWdtZW50IHJheUVsbGlwc29pZEludGVyc2VjdGlvbihjem1fcmF5IHJheSwgdmVjMyBpbnZlcnNlUmFkaWkpXFxuXFxcbntcXG5cXFxuICAgIHZlYzMgbyA9IGludmVyc2VSYWRpaSAqIChjem1faW52ZXJzZVZpZXcgKiB2ZWM0KHJheS5vcmlnaW4sIDEuMCkpLnh5ejtcXG5cXFxuICAgIHZlYzMgZCA9IGludmVyc2VSYWRpaSAqIChjem1faW52ZXJzZVZpZXcgKiB2ZWM0KHJheS5kaXJlY3Rpb24sIDAuMCkpLnh5ejtcXG5cXFxuXFxuXFxcbiAgICBmbG9hdCBhID0gZG90KGQsIGQpO1xcblxcXG4gICAgZmxvYXQgYiA9IGRvdChkLCBvKTtcXG5cXFxuICAgIGZsb2F0IGMgPSBkb3QobywgbykgLSAxLjA7XFxuXFxcbiAgICBmbG9hdCBkaXNjcmltaW5hbnQgPSBiICogYiAtIGEgKiBjO1xcblxcXG4gICAgaWYgKGRpc2NyaW1pbmFudCA8IDAuMClcXG5cXFxuICAgIHtcXG5cXFxuICAgICAgICByZXR1cm4gY3ptX2VtcHR5UmF5U2VnbWVudDtcXG5cXFxuICAgIH1cXG5cXFxuICAgIGRpc2NyaW1pbmFudCA9IHNxcnQoZGlzY3JpbWluYW50KTtcXG5cXFxuICAgIGZsb2F0IHQxID0gKC1iIC0gZGlzY3JpbWluYW50KSAvIGE7XFxuXFxcbiAgICBmbG9hdCB0MiA9ICgtYiArIGRpc2NyaW1pbmFudCkgLyBhO1xcblxcXG5cXG5cXFxuICAgIGlmICh0MSA8IDAuMCAmJiB0MiA8IDAuMClcXG5cXFxuICAgIHtcXG5cXFxuICAgICAgICByZXR1cm4gY3ptX2VtcHR5UmF5U2VnbWVudDtcXG5cXFxuICAgIH1cXG5cXFxuXFxuXFxcbiAgICBpZiAodDEgPCAwLjAgJiYgdDIgPj0gMC4wKVxcblxcXG4gICAge1xcblxcXG4gICAgICAgIHQxID0gMC4wO1xcblxcXG4gICAgfVxcblxcXG5cXG5cXFxuICAgIHJldHVybiBjem1fcmF5U2VnbWVudCh0MSwgdDIpO1xcblxcXG59XFxuXFxcblxcblxcXG52ZWMzIGdldEFkanVzdGVkUG9zaXRpb24odmVjMyBwb3NpdGlvbldDLCBmbG9hdCBpbm5lclJhZGl1cylcXG5cXFxue1xcblxcXG4gIC8vIEFkanVzdCB0aGUgY2FtZXJhIHBvc2l0aW9uIHNvIHRoYXQgYXRtb3NwaGVyZSBjb2xvciBsb29rcyB0aGUgc2FtZSB3aGVyZXZlciB0aGUgZXllIGhlaWdodCBpcyB0aGUgc2FtZVxcblxcXG4gIGZsb2F0IGNhbWVyYUhlaWdodCA9IGN6bV9leWVIZWlnaHQgKyBpbm5lclJhZGl1cztcXG5cXFxuICByZXR1cm4gbm9ybWFsaXplKHBvc2l0aW9uV0MpICogY2FtZXJhSGVpZ2h0O1xcblxcXG59XFxuXFxcblxcblxcXG52ZWMzIGdldFRyYW5zbHVjZW50UG9zaXRpb24odmVjMyBwb3NpdGlvbldDLCB2ZWMzIG91dGVyUG9zaXRpb25XQywgZmxvYXQgaW5uZXJSYWRpdXMsIG91dCBib29sIGludGVyc2VjdHNFbGxpcHNvaWQpXFxuXFxcbntcXG5cXFxuICAgIHZlYzMgZGlyZWN0aW9uV0MgPSBub3JtYWxpemUob3V0ZXJQb3NpdGlvbldDIC0gcG9zaXRpb25XQyk7XFxuXFxcbiAgICB2ZWMzIGRpcmVjdGlvbkVDID0gY3ptX3ZpZXdSb3RhdGlvbiAqIGRpcmVjdGlvbldDO1xcblxcXG4gICAgY3ptX3JheSB2aWV3UmF5ID0gY3ptX3JheSh2ZWMzKDAuMCksIGRpcmVjdGlvbkVDKTtcXG5cXFxuICAgIGN6bV9yYXlTZWdtZW50IHJheVNlZ21lbnQgPSByYXlFbGxpcHNvaWRJbnRlcnNlY3Rpb24odmlld1JheSwgY3ptX2VsbGlwc29pZEludmVyc2VSYWRpaSk7XFxuXFxcbiAgICBpbnRlcnNlY3RzRWxsaXBzb2lkID0gcmF5U2VnbWVudC5zdGFydCA+PSAwLjA7XFxuXFxcblxcblxcXG4gICAgaWYgKGludGVyc2VjdHNFbGxpcHNvaWQpXFxuXFxcbiAgICB7XFxuXFxcbiAgICAgICAgcmV0dXJuIHBvc2l0aW9uV0MgKyByYXlTZWdtZW50LnN0b3AgKiBkaXJlY3Rpb25XQztcXG5cXFxuICAgIH1cXG5cXFxuXFxuXFxcbiAgICByZXR1cm4gZ2V0QWRqdXN0ZWRQb3NpdGlvbihwb3NpdGlvbldDLCBpbm5lclJhZGl1cyk7XFxuXFxcbn1cXG5cXFxuXFxuXFxcbnZvaWQgY2FsY3VsYXRlTWllQ29sb3JBbmRSYXlsZWlnaENvbG9yKHZlYzMgb3V0ZXJQb3NpdGlvbldDLCBvdXQgdmVjMyBtaWVDb2xvciwgb3V0IHZlYzMgcmF5bGVpZ2hDb2xvcilcXG5cXFxue1xcblxcXG4gICAgLy8gVW5wYWNrIGF0dHJpYnV0ZXNcXG5cXFxuICAgIGZsb2F0IG91dGVyUmFkaXVzID0gdV9yYWRpaUFuZER5bmFtaWNBdG1vc3BoZXJlQ29sb3IueDtcXG5cXFxuICAgIGZsb2F0IGlubmVyUmFkaXVzID0gdV9yYWRpaUFuZER5bmFtaWNBdG1vc3BoZXJlQ29sb3IueTtcXG5cXFxuXFxuXFxcbiNpZmRlZiBHTE9CRV9UUkFOU0xVQ0VOVFxcblxcXG4gICAgYm9vbCBpbnRlcnNlY3RzRWxsaXBzb2lkID0gZmFsc2U7XFxuXFxcbiAgICB2ZWMzIHN0YXJ0UG9zaXRpb25XQyA9IGdldFRyYW5zbHVjZW50UG9zaXRpb24oY3ptX3ZpZXdlclBvc2l0aW9uV0MsIG91dGVyUG9zaXRpb25XQywgaW5uZXJSYWRpdXMsIGludGVyc2VjdHNFbGxpcHNvaWQpO1xcblxcXG4jZWxzZVxcblxcXG4gICAgdmVjMyBzdGFydFBvc2l0aW9uV0MgPSBnZXRBZGp1c3RlZFBvc2l0aW9uKGN6bV92aWV3ZXJQb3NpdGlvbldDLCBpbm5lclJhZGl1cyk7XFxuXFxcbiNlbmRpZlxcblxcXG5cXG5cXFxuICAgIHZlYzMgbGlnaHREaXJlY3Rpb24gPSBnZXRMaWdodERpcmVjdGlvbihzdGFydFBvc2l0aW9uV0MpO1xcblxcXG5cXG5cXFxuICAgIC8vIEdldCB0aGUgcmF5IGZyb20gdGhlIHN0YXJ0IHBvc2l0aW9uIHRvIHRoZSBvdXRlciBwb3NpdGlvbiBhbmQgaXRzIGxlbmd0aCAod2hpY2ggaXMgdGhlIGZhciBwb2ludCBvZiB0aGUgcmF5IHBhc3NpbmcgdGhyb3VnaCB0aGUgYXRtb3NwaGVyZSlcXG5cXFxuICAgIHZlYzMgcmF5ID0gb3V0ZXJQb3NpdGlvbldDIC0gc3RhcnRQb3NpdGlvbldDO1xcblxcXG4gICAgZmxvYXQgZmFyID0gbGVuZ3RoKHJheSk7XFxuXFxcbiAgICByYXkgLz0gZmFyO1xcblxcXG5cXG5cXFxuICAgIGZsb2F0IGF0bW9zcGhlcmVTY2FsZSA9IDEuMCAvIChvdXRlclJhZGl1cyAtIGlubmVyUmFkaXVzKTtcXG5cXFxuXFxuXFxcbiAgICB2ZWMzIHN0YXJ0O1xcblxcXG4gICAgZmxvYXQgc3RhcnRPZmZzZXQ7XFxuXFxcblxcblxcXG4jaWZkZWYgU0tZX0ZST01fU1BBQ0VcXG5cXFxuI2lmZGVmIEdMT0JFX1RSQU5TTFVDRU5UXFxuXFxcbiAgICBpZiAoaW50ZXJzZWN0c0VsbGlwc29pZClcXG5cXFxuICAgIHtcXG5cXFxuICAgICAgICBjYWxjdWxhdGVSYXlTY2F0dGVyaW5nRnJvbUdyb3VuZChzdGFydFBvc2l0aW9uV0MsIHJheSwgYXRtb3NwaGVyZVNjYWxlLCBpbm5lclJhZGl1cywgc3RhcnQsIHN0YXJ0T2Zmc2V0KTtcXG5cXFxuICAgIH1cXG5cXFxuICAgIGVsc2VcXG5cXFxuICAgIHtcXG5cXFxuICAgICAgICBjYWxjdWxhdGVSYXlTY2F0dGVyaW5nRnJvbVNwYWNlKHN0YXJ0UG9zaXRpb25XQywgcmF5LCBpbm5lclJhZGl1cywgb3V0ZXJSYWRpdXMsIGZhciwgc3RhcnQsIHN0YXJ0T2Zmc2V0KTtcXG5cXFxuICAgIH1cXG5cXFxuI2Vsc2VcXG5cXFxuICAgIGNhbGN1bGF0ZVJheVNjYXR0ZXJpbmdGcm9tU3BhY2Uoc3RhcnRQb3NpdGlvbldDLCByYXksIGlubmVyUmFkaXVzLCBvdXRlclJhZGl1cywgZmFyLCBzdGFydCwgc3RhcnRPZmZzZXQpO1xcblxcXG4jZW5kaWZcXG5cXFxuI2Vsc2VcXG5cXFxuICAgIGNhbGN1bGF0ZVJheVNjYXR0ZXJpbmdGcm9tR3JvdW5kKHN0YXJ0UG9zaXRpb25XQywgcmF5LCBhdG1vc3BoZXJlU2NhbGUsIGlubmVyUmFkaXVzLCBzdGFydCwgc3RhcnRPZmZzZXQpO1xcblxcXG4jZW5kaWZcXG5cXFxuXFxuXFxcbiAgICAvLyBJbml0aWFsaXplIHRoZSBzY2F0dGVyaW5nIGxvb3AgdmFyaWFibGVzXFxuXFxcbiAgICBmbG9hdCBzYW1wbGVMZW5ndGggPSBmYXIgLyBmU2FtcGxlcztcXG5cXFxuICAgIGZsb2F0IHNjYWxlZExlbmd0aCA9IHNhbXBsZUxlbmd0aCAqIGF0bW9zcGhlcmVTY2FsZTtcXG5cXFxuICAgIHZlYzMgc2FtcGxlUmF5ID0gcmF5ICogc2FtcGxlTGVuZ3RoO1xcblxcXG4gICAgdmVjMyBzYW1wbGVQb2ludCA9IHN0YXJ0ICsgc2FtcGxlUmF5ICogMC41O1xcblxcXG5cXG5cXFxuICAgIC8vIE5vdyBsb29wIHRocm91Z2ggdGhlIHNhbXBsZSByYXlzXFxuXFxcbiAgICB2ZWMzIGZyb250Q29sb3IgPSB2ZWMzKDAuMCwgMC4wLCAwLjApO1xcblxcXG5cXG5cXFxuICAgIGZvciAoaW50IGkgPSAwOyBpPG5TYW1wbGVzOyBpKyspXFxuXFxcbiAgICB7XFxuXFxcbiAgICAgICAgZmxvYXQgaGVpZ2h0ID0gbGVuZ3RoKHNhbXBsZVBvaW50KTtcXG5cXFxuICAgICAgICBmbG9hdCBkZXB0aCA9IGV4cCgoYXRtb3NwaGVyZVNjYWxlIC8gcmF5bGVpZ2hTY2FsZURlcHRoICkgKiAoaW5uZXJSYWRpdXMgLSBoZWlnaHQpKTtcXG5cXFxuICAgICAgICBmbG9hdCBmTGlnaHRBbmdsZSA9IGRvdChsaWdodERpcmVjdGlvbiwgc2FtcGxlUG9pbnQpIC8gaGVpZ2h0O1xcblxcXG4gICAgICAgIGZsb2F0IGZDYW1lcmFBbmdsZSA9IGRvdChyYXksIHNhbXBsZVBvaW50KSAvIGhlaWdodDtcXG5cXFxuICAgICAgICBmbG9hdCBmU2NhdHRlciA9IChzdGFydE9mZnNldCArIGRlcHRoKihzY2FsZShmTGlnaHRBbmdsZSkgLSBzY2FsZShmQ2FtZXJhQW5nbGUpKSk7XFxuXFxcbiAgICAgICAgdmVjMyBhdHRlbnVhdGUgPSBleHAoLWZTY2F0dGVyICogKEludldhdmVsZW5ndGggKiBLcjRQSSArIEttNFBJKSk7XFxuXFxcbiAgICAgICAgZnJvbnRDb2xvciArPSBhdHRlbnVhdGUgKiAoZGVwdGggKiBzY2FsZWRMZW5ndGgpO1xcblxcXG4gICAgICAgIHNhbXBsZVBvaW50ICs9IHNhbXBsZVJheTtcXG5cXFxuICAgIH1cXG5cXFxuXFxuXFxcbiAgICAvLyBGaW5hbGx5LCBzY2FsZSB0aGUgTWllIGFuZCBSYXlsZWlnaCBjb2xvcnMgYW5kIHNldCB1cCB0aGUgdmFyeWluZyB2YXJpYWJsZXMgZm9yIHRoZSBwaXhlbCBzaGFkZXJcXG5cXFxuICAgIG1pZUNvbG9yID0gZnJvbnRDb2xvciAqIEttRVN1bjtcXG5cXFxuICAgIHJheWxlaWdoQ29sb3IgPSBmcm9udENvbG9yICogKEludldhdmVsZW5ndGggKiBLckVTdW4pO1xcblxcXG5cXG5cXFxuICAgIC8vIENhcCBtaWUgYW5kIHJheWxlaWdoIGNvbG9ycyB0byBwcmV2ZW50IE5hTnMgd2hlbiB2ZXJ0ZXggaW50ZXJwb2xhdGlvbiBoYXBwZW5zXFxuXFxcbiAgICBtaWVDb2xvciA9IG1pbihtaWVDb2xvciwgdmVjMygxMDAwMDAwMC4wKSk7XFxuXFxcbiAgICByYXlsZWlnaENvbG9yID0gbWluKHJheWxlaWdoQ29sb3IsIHZlYzMoMTAwMDAwMDAuMCkpO1xcblxcXG59XFxuXFxcblxcblxcXG52ZWM0IGNhbGN1bGF0ZUZpbmFsQ29sb3IodmVjMyBwb3NpdGlvbldDLCB2ZWMzIHRvQ2FtZXJhLCB2ZWMzIGxpZ2h0RGlyZWN0aW9uLCB2ZWMzIG1pZUNvbG9yLCB2ZWMzIHJheWxlaWdoQ29sb3IpXFxuXFxcbntcXG5cXFxuICAgIC8vIEV4dHJhIG5vcm1hbGl6ZSBhZGRlZCBmb3IgQW5kcm9pZFxcblxcXG4gICAgZmxvYXQgY29zQW5nbGUgPSBkb3QobGlnaHREaXJlY3Rpb24sIG5vcm1hbGl6ZSh0b0NhbWVyYSkpIC8gbGVuZ3RoKHRvQ2FtZXJhKTtcXG5cXFxuICAgIGZsb2F0IHJheWxlaWdoUGhhc2UgPSAwLjc1ICogKDEuMCArIGNvc0FuZ2xlICogY29zQW5nbGUpO1xcblxcXG4gICAgZmxvYXQgbWllUGhhc2UgPSAxLjUgKiAoKDEuMCAtIGcyKSAvICgyLjAgKyBnMikpICogKDEuMCArIGNvc0FuZ2xlICogY29zQW5nbGUpIC8gcG93KDEuMCArIGcyIC0gMi4wICogZyAqIGNvc0FuZ2xlLCAxLjUpO1xcblxcXG5cXG5cXFxuICAgIHZlYzMgcmdiID0gcmF5bGVpZ2hQaGFzZSAqIHJheWxlaWdoQ29sb3IgKyBtaWVQaGFzZSAqIG1pZUNvbG9yO1xcblxcXG5cXG5cXFxuICAgIGNvbnN0IGZsb2F0IGV4cG9zdXJlID0gMi4wO1xcblxcXG4gICAgdmVjMyByZ2JFeHBvc3VyZSA9IHZlYzMoMS4wKSAtIGV4cCgtZXhwb3N1cmUgKiByZ2IpO1xcblxcXG5cXG5cXFxuI2lmbmRlZiBIRFJcXG5cXFxuICAgIHJnYiA9IHJnYkV4cG9zdXJlO1xcblxcXG4jZW5kaWZcXG5cXFxuXFxuXFxcbiNpZmRlZiBDT0xPUl9DT1JSRUNUXFxuXFxcbiAgICAvLyBDb252ZXJ0IHJnYiBjb2xvciB0byBoc2JcXG5cXFxuICAgIHZlYzMgaHNiID0gY3ptX1JHQlRvSFNCKHJnYik7XFxuXFxcbiAgICAvLyBQZXJmb3JtIGhzYiBzaGlmdFxcblxcXG4gICAgaHNiLnggKz0gdV9oc2JTaGlmdC54OyAvLyBodWVcXG5cXFxuICAgIGhzYi55ID0gY2xhbXAoaHNiLnkgKyB1X2hzYlNoaWZ0LnksIDAuMCwgMS4wKTsgLy8gc2F0dXJhdGlvblxcblxcXG4gICAgaHNiLnogPSBoc2IueiA+IGN6bV9lcHNpbG9uNyA/IGhzYi56ICsgdV9oc2JTaGlmdC56IDogMC4wOyAvLyBicmlnaHRuZXNzXFxuXFxcbiAgICAvLyBDb252ZXJ0IHNoaWZ0ZWQgaHNiIGJhY2sgdG8gcmdiXFxuXFxcbiAgICByZ2IgPSBjem1fSFNCVG9SR0IoaHNiKTtcXG5cXFxuI2VuZGlmXFxuXFxcblxcblxcXG4gICAgZmxvYXQgb3V0ZXJSYWRpdXMgPSB1X3JhZGlpQW5kRHluYW1pY0F0bW9zcGhlcmVDb2xvci54O1xcblxcXG4gICAgZmxvYXQgaW5uZXJSYWRpdXMgPSB1X3JhZGlpQW5kRHluYW1pY0F0bW9zcGhlcmVDb2xvci55O1xcblxcXG4gICAgZmxvYXQgbGlnaHRFbnVtID0gdV9yYWRpaUFuZER5bmFtaWNBdG1vc3BoZXJlQ29sb3IuejtcXG5cXFxuXFxuXFxcbiAgICBmbG9hdCBjYW1lcmFIZWlnaHQgPSBjem1fZXllSGVpZ2h0ICsgaW5uZXJSYWRpdXM7XFxuXFxcblxcblxcXG4gICAgLy8gQWx0ZXIgYWxwaGEgYmFzZWQgb24gaG93IGNsb3NlIHRoZSB2aWV3ZXIgaXMgdG8gdGhlIGdyb3VuZCAoMS4wID0gb24gZ3JvdW5kLCAwLjAgPSBhdCBlZGdlIG9mIGF0bW9zcGhlcmUpXFxuXFxcbiAgICBmbG9hdCBhdG1vc3BoZXJlQWxwaGEgPSBjbGFtcCgob3V0ZXJSYWRpdXMgLSBjYW1lcmFIZWlnaHQpIC8gKG91dGVyUmFkaXVzIC0gaW5uZXJSYWRpdXMpLCAwLjAsIDEuMCk7XFxuXFxcblxcblxcXG4gICAgLy8gQWx0ZXIgYWxwaGEgYmFzZWQgb24gdGltZSBvZiBkYXkgKDAuMCA9IG5pZ2h0ICwgMS4wID0gZGF5KVxcblxcXG4gICAgZmxvYXQgbmlnaHRBbHBoYSA9IChsaWdodEVudW0gIT0gMC4wKSA/IGNsYW1wKGRvdChub3JtYWxpemUocG9zaXRpb25XQyksIGxpZ2h0RGlyZWN0aW9uKSwgMC4wLCAxLjApIDogMS4wO1xcblxcXG4gICAgYXRtb3NwaGVyZUFscGhhICo9IHBvdyhuaWdodEFscGhhLCAwLjUpO1xcblxcXG5cXG5cXFxuICAgIHZlYzQgZmluYWxDb2xvciA9IHZlYzQocmdiLCBtaXgoY2xhbXAocmdiRXhwb3N1cmUuYiwgMC4wLCAxLjApLCAxLjAsIGF0bW9zcGhlcmVBbHBoYSkgKiBzbW9vdGhzdGVwKDAuMCwgMS4wLCBjem1fbW9ycGhUaW1lKSk7XFxuXFxcblxcblxcXG4gICAgaWYgKG1pZUNvbG9yLmIgPiAxLjApXFxuXFxcbiAgICB7XFxuXFxcbiAgICAgICAgLy8gRmFkZSBhdG1vc3BoZXJlIGJlbG93IHRoZSBlbGxpcHNvaWQuIEFzIHRoZSBjYW1lcmEgem9vbXMgZnVydGhlciBhd2F5IGZyb20gdGhlIGVsbGlwc29pZCBkcmF3XFxuXFxcbiAgICAgICAgLy8gYSBsYXJnZXIgYXRtb3NwaGVyZSByaW5nIHRvIGNvdmVyIGVtcHR5IHNwYWNlIG9mIGxvd2VyIExPRCBnbG9iZSB0aWxlcy5cXG5cXFxuICAgICAgICBmbG9hdCBzdHJlbmd0aCA9IG1pZUNvbG9yLmI7XFxuXFxcbiAgICAgICAgZmxvYXQgbWluRGlzdGFuY2UgPSBvdXRlclJhZGl1cztcXG5cXFxuICAgICAgICBmbG9hdCBtYXhEaXN0YW5jZSA9IG91dGVyUmFkaXVzICogMy4wO1xcblxcXG4gICAgICAgIGZsb2F0IG1heFN0cmVuZ3RoTGVycCA9IDEuMCAtIGNsYW1wKChtYXhEaXN0YW5jZSAtIGNhbWVyYUhlaWdodCkgLyAobWF4RGlzdGFuY2UgLSBtaW5EaXN0YW5jZSksIDAuMCwgMS4wKTtcXG5cXFxuICAgICAgICBmbG9hdCBtYXhTdHJlbmd0aCA9IG1peCgxMDAuMCwgMTAwMDAuMCwgbWF4U3RyZW5ndGhMZXJwKTtcXG5cXFxuICAgICAgICBzdHJlbmd0aCA9IG1pbihzdHJlbmd0aCwgbWF4U3RyZW5ndGgpO1xcblxcXG4gICAgICAgIGZsb2F0IGFscGhhID0gMS4wIC0gKHN0cmVuZ3RoIC8gbWF4U3RyZW5ndGgpO1xcblxcXG4gICAgICAgIGZpbmFsQ29sb3IuYSA9IGFscGhhO1xcblxcXG4gICAgfVxcblxcXG5cXG5cXFxuICAgIHJldHVybiBmaW5hbENvbG9yO1xcblxcXG59XFxuXFxcblwiO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///66629\n')},79908:function(__unused_webpack___webpack_module__,__webpack_exports__){eval('//This file is automatically rebuilt by the Cesium build process.\n/* harmony default export */ __webpack_exports__["Z"] = ("varying vec3 v_outerPositionWC;\\n\\\n\\n\\\n#ifndef PER_FRAGMENT_ATMOSPHERE\\n\\\nvarying vec3 v_mieColor;\\n\\\nvarying vec3 v_rayleighColor;\\n\\\n#endif\\n\\\n\\n\\\nvoid main (void)\\n\\\n{\\n\\\n    vec3 toCamera = czm_viewerPositionWC - v_outerPositionWC;\\n\\\n    vec3 lightDirection = getLightDirection(czm_viewerPositionWC);\\n\\\n    vec3 mieColor;\\n\\\n    vec3 rayleighColor;\\n\\\n\\n\\\n#ifdef PER_FRAGMENT_ATMOSPHERE\\n\\\n    calculateMieColorAndRayleighColor(v_outerPositionWC, mieColor, rayleighColor);\\n\\\n#else\\n\\\n    mieColor = v_mieColor;\\n\\\n    rayleighColor = v_rayleighColor;\\n\\\n#endif\\n\\\n\\n\\\n    gl_FragColor = calculateFinalColor(czm_viewerPositionWC, toCamera, lightDirection, mieColor, rayleighColor);\\n\\\n}\\n\\\n");\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNzk5MDguanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQSx5REFBZSxnQ0FBZ0M7QUFDL0M7QUFDQTtBQUNBLHdCQUF3QjtBQUN4Qiw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNELDZEQUE2RDtBQUM3RCxrRUFBa0U7QUFDbEUsa0JBQWtCO0FBQ2xCLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0Esa0ZBQWtGO0FBQ2xGO0FBQ0EsMEJBQTBCO0FBQzFCLG9DQUFvQztBQUNwQztBQUNBO0FBQ0EsZ0hBQWdIO0FBQ2hILENBQUM7QUFDRCxDQUFDLEVBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly92dWUzLXdlYnBhY2s1Ly4vbm9kZV9tb2R1bGVzL2Nlc2l1bS9Tb3VyY2UvU2hhZGVycy9Ta3lBdG1vc3BoZXJlRlMuanM/ZmU1NSJdLCJzb3VyY2VzQ29udGVudCI6WyIvL1RoaXMgZmlsZSBpcyBhdXRvbWF0aWNhbGx5IHJlYnVpbHQgYnkgdGhlIENlc2l1bSBidWlsZCBwcm9jZXNzLlxuZXhwb3J0IGRlZmF1bHQgXCJ2YXJ5aW5nIHZlYzMgdl9vdXRlclBvc2l0aW9uV0M7XFxuXFxcblxcblxcXG4jaWZuZGVmIFBFUl9GUkFHTUVOVF9BVE1PU1BIRVJFXFxuXFxcbnZhcnlpbmcgdmVjMyB2X21pZUNvbG9yO1xcblxcXG52YXJ5aW5nIHZlYzMgdl9yYXlsZWlnaENvbG9yO1xcblxcXG4jZW5kaWZcXG5cXFxuXFxuXFxcbnZvaWQgbWFpbiAodm9pZClcXG5cXFxue1xcblxcXG4gICAgdmVjMyB0b0NhbWVyYSA9IGN6bV92aWV3ZXJQb3NpdGlvbldDIC0gdl9vdXRlclBvc2l0aW9uV0M7XFxuXFxcbiAgICB2ZWMzIGxpZ2h0RGlyZWN0aW9uID0gZ2V0TGlnaHREaXJlY3Rpb24oY3ptX3ZpZXdlclBvc2l0aW9uV0MpO1xcblxcXG4gICAgdmVjMyBtaWVDb2xvcjtcXG5cXFxuICAgIHZlYzMgcmF5bGVpZ2hDb2xvcjtcXG5cXFxuXFxuXFxcbiNpZmRlZiBQRVJfRlJBR01FTlRfQVRNT1NQSEVSRVxcblxcXG4gICAgY2FsY3VsYXRlTWllQ29sb3JBbmRSYXlsZWlnaENvbG9yKHZfb3V0ZXJQb3NpdGlvbldDLCBtaWVDb2xvciwgcmF5bGVpZ2hDb2xvcik7XFxuXFxcbiNlbHNlXFxuXFxcbiAgICBtaWVDb2xvciA9IHZfbWllQ29sb3I7XFxuXFxcbiAgICByYXlsZWlnaENvbG9yID0gdl9yYXlsZWlnaENvbG9yO1xcblxcXG4jZW5kaWZcXG5cXFxuXFxuXFxcbiAgICBnbF9GcmFnQ29sb3IgPSBjYWxjdWxhdGVGaW5hbENvbG9yKGN6bV92aWV3ZXJQb3NpdGlvbldDLCB0b0NhbWVyYSwgbGlnaHREaXJlY3Rpb24sIG1pZUNvbG9yLCByYXlsZWlnaENvbG9yKTtcXG5cXFxufVxcblxcXG5cIjtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///79908\n')},4399:function(__unused_webpack___webpack_module__,__webpack_exports__){eval('//This file is automatically rebuilt by the Cesium build process.\n/* harmony default export */ __webpack_exports__["Z"] = ("attribute vec4 position;\\n\\\n\\n\\\nvarying vec3 v_outerPositionWC;\\n\\\n\\n\\\n#ifndef PER_FRAGMENT_ATMOSPHERE\\n\\\nvarying vec3 v_mieColor;\\n\\\nvarying vec3 v_rayleighColor;\\n\\\n#endif\\n\\\n\\n\\\nvoid main(void)\\n\\\n{\\n\\\n    vec4 positionWC = czm_model * position;\\n\\\n\\n\\\n#ifndef PER_FRAGMENT_ATMOSPHERE\\n\\\n    calculateMieColorAndRayleighColor(positionWC.xyz, v_mieColor, v_rayleighColor);\\n\\\n#endif\\n\\\n    v_outerPositionWC = positionWC.xyz;\\n\\\n    gl_Position = czm_modelViewProjection * position;\\n\\\n}\\n\\\n");\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNDM5OS5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBLHlEQUFlLHlCQUF5QjtBQUN4QztBQUNBLCtCQUErQjtBQUMvQjtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0QsMkNBQTJDO0FBQzNDO0FBQ0E7QUFDQSxtRkFBbUY7QUFDbkY7QUFDQSx1Q0FBdUM7QUFDdkMscURBQXFEO0FBQ3JELENBQUM7QUFDRCxDQUFDLEVBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly92dWUzLXdlYnBhY2s1Ly4vbm9kZV9tb2R1bGVzL2Nlc2l1bS9Tb3VyY2UvU2hhZGVycy9Ta3lBdG1vc3BoZXJlVlMuanM/NDkyYSJdLCJzb3VyY2VzQ29udGVudCI6WyIvL1RoaXMgZmlsZSBpcyBhdXRvbWF0aWNhbGx5IHJlYnVpbHQgYnkgdGhlIENlc2l1bSBidWlsZCBwcm9jZXNzLlxuZXhwb3J0IGRlZmF1bHQgXCJhdHRyaWJ1dGUgdmVjNCBwb3NpdGlvbjtcXG5cXFxuXFxuXFxcbnZhcnlpbmcgdmVjMyB2X291dGVyUG9zaXRpb25XQztcXG5cXFxuXFxuXFxcbiNpZm5kZWYgUEVSX0ZSQUdNRU5UX0FUTU9TUEhFUkVcXG5cXFxudmFyeWluZyB2ZWMzIHZfbWllQ29sb3I7XFxuXFxcbnZhcnlpbmcgdmVjMyB2X3JheWxlaWdoQ29sb3I7XFxuXFxcbiNlbmRpZlxcblxcXG5cXG5cXFxudm9pZCBtYWluKHZvaWQpXFxuXFxcbntcXG5cXFxuICAgIHZlYzQgcG9zaXRpb25XQyA9IGN6bV9tb2RlbCAqIHBvc2l0aW9uO1xcblxcXG5cXG5cXFxuI2lmbmRlZiBQRVJfRlJBR01FTlRfQVRNT1NQSEVSRVxcblxcXG4gICAgY2FsY3VsYXRlTWllQ29sb3JBbmRSYXlsZWlnaENvbG9yKHBvc2l0aW9uV0MueHl6LCB2X21pZUNvbG9yLCB2X3JheWxlaWdoQ29sb3IpO1xcblxcXG4jZW5kaWZcXG5cXFxuICAgIHZfb3V0ZXJQb3NpdGlvbldDID0gcG9zaXRpb25XQy54eXo7XFxuXFxcbiAgICBnbF9Qb3NpdGlvbiA9IGN6bV9tb2RlbFZpZXdQcm9qZWN0aW9uICogcG9zaXRpb247XFxuXFxcbn1cXG5cXFxuXCI7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///4399\n')},81277:function(__unused_webpack___webpack_module__,__webpack_exports__){eval('//This file is automatically rebuilt by the Cesium build process.\n/* harmony default export */ __webpack_exports__["Z"] = ("uniform samplerCube u_cubeMap;\\n\\\n\\n\\\nvarying vec3 v_texCoord;\\n\\\n\\n\\\nvoid main()\\n\\\n{\\n\\\n    vec4 color = textureCube(u_cubeMap, normalize(v_texCoord));\\n\\\n    gl_FragColor = vec4(czm_gammaCorrect(color).rgb, czm_morphTime);\\n\\\n}\\n\\\n");\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiODEyNzcuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQSx5REFBZSwrQkFBK0I7QUFDOUM7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBLENBQUM7QUFDRCwrREFBK0Q7QUFDL0Qsb0VBQW9FO0FBQ3BFLENBQUM7QUFDRCxDQUFDLEVBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly92dWUzLXdlYnBhY2s1Ly4vbm9kZV9tb2R1bGVzL2Nlc2l1bS9Tb3VyY2UvU2hhZGVycy9Ta3lCb3hGUy5qcz9iMWQ0Il0sInNvdXJjZXNDb250ZW50IjpbIi8vVGhpcyBmaWxlIGlzIGF1dG9tYXRpY2FsbHkgcmVidWlsdCBieSB0aGUgQ2VzaXVtIGJ1aWxkIHByb2Nlc3MuXG5leHBvcnQgZGVmYXVsdCBcInVuaWZvcm0gc2FtcGxlckN1YmUgdV9jdWJlTWFwO1xcblxcXG5cXG5cXFxudmFyeWluZyB2ZWMzIHZfdGV4Q29vcmQ7XFxuXFxcblxcblxcXG52b2lkIG1haW4oKVxcblxcXG57XFxuXFxcbiAgICB2ZWM0IGNvbG9yID0gdGV4dHVyZUN1YmUodV9jdWJlTWFwLCBub3JtYWxpemUodl90ZXhDb29yZCkpO1xcblxcXG4gICAgZ2xfRnJhZ0NvbG9yID0gdmVjNChjem1fZ2FtbWFDb3JyZWN0KGNvbG9yKS5yZ2IsIGN6bV9tb3JwaFRpbWUpO1xcblxcXG59XFxuXFxcblwiO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///81277\n')},8910:function(__unused_webpack___webpack_module__,__webpack_exports__){eval('//This file is automatically rebuilt by the Cesium build process.\n/* harmony default export */ __webpack_exports__["Z"] = ("attribute vec3 position;\\n\\\n\\n\\\nvarying vec3 v_texCoord;\\n\\\n\\n\\\nvoid main()\\n\\\n{\\n\\\n    vec3 p = czm_viewRotation * (czm_temeToPseudoFixed * (czm_entireFrustum.y * position));\\n\\\n    gl_Position = czm_projection * vec4(p, 1.0);\\n\\\n    v_texCoord = position.xyz;\\n\\\n}\\n\\\n");\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiODkxMC5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBLHlEQUFlLHlCQUF5QjtBQUN4QztBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0EsQ0FBQztBQUNELDJGQUEyRjtBQUMzRixnREFBZ0Q7QUFDaEQsOEJBQThCO0FBQzlCLENBQUM7QUFDRCxDQUFDLEVBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly92dWUzLXdlYnBhY2s1Ly4vbm9kZV9tb2R1bGVzL2Nlc2l1bS9Tb3VyY2UvU2hhZGVycy9Ta3lCb3hWUy5qcz84YmUzIl0sInNvdXJjZXNDb250ZW50IjpbIi8vVGhpcyBmaWxlIGlzIGF1dG9tYXRpY2FsbHkgcmVidWlsdCBieSB0aGUgQ2VzaXVtIGJ1aWxkIHByb2Nlc3MuXG5leHBvcnQgZGVmYXVsdCBcImF0dHJpYnV0ZSB2ZWMzIHBvc2l0aW9uO1xcblxcXG5cXG5cXFxudmFyeWluZyB2ZWMzIHZfdGV4Q29vcmQ7XFxuXFxcblxcblxcXG52b2lkIG1haW4oKVxcblxcXG57XFxuXFxcbiAgICB2ZWMzIHAgPSBjem1fdmlld1JvdGF0aW9uICogKGN6bV90ZW1lVG9Qc2V1ZG9GaXhlZCAqIChjem1fZW50aXJlRnJ1c3R1bS55ICogcG9zaXRpb24pKTtcXG5cXFxuICAgIGdsX1Bvc2l0aW9uID0gY3ptX3Byb2plY3Rpb24gKiB2ZWM0KHAsIDEuMCk7XFxuXFxcbiAgICB2X3RleENvb3JkID0gcG9zaXRpb24ueHl6O1xcblxcXG59XFxuXFxcblwiO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///8910\n')},26103:function(__unused_webpack___webpack_module__,__webpack_exports__){eval('//This file is automatically rebuilt by the Cesium build process.\n/* harmony default export */ __webpack_exports__["Z"] = ("uniform sampler2D u_texture;\\n\\\n\\n\\\nvarying vec2 v_textureCoordinates;\\n\\\n\\n\\\nvoid main()\\n\\\n{\\n\\\n    vec4 color = texture2D(u_texture, v_textureCoordinates);\\n\\\n    gl_FragColor = czm_gammaCorrect(color);\\n\\\n}\\n\\\n");\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjYxMDMuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQSx5REFBZSw2QkFBNkI7QUFDNUM7QUFDQSxrQ0FBa0M7QUFDbEM7QUFDQTtBQUNBLENBQUM7QUFDRCw0REFBNEQ7QUFDNUQsMkNBQTJDO0FBQzNDLENBQUM7QUFDRCxDQUFDLEVBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly92dWUzLXdlYnBhY2s1Ly4vbm9kZV9tb2R1bGVzL2Nlc2l1bS9Tb3VyY2UvU2hhZGVycy9TdW5GUy5qcz8xNGFkIl0sInNvdXJjZXNDb250ZW50IjpbIi8vVGhpcyBmaWxlIGlzIGF1dG9tYXRpY2FsbHkgcmVidWlsdCBieSB0aGUgQ2VzaXVtIGJ1aWxkIHByb2Nlc3MuXG5leHBvcnQgZGVmYXVsdCBcInVuaWZvcm0gc2FtcGxlcjJEIHVfdGV4dHVyZTtcXG5cXFxuXFxuXFxcbnZhcnlpbmcgdmVjMiB2X3RleHR1cmVDb29yZGluYXRlcztcXG5cXFxuXFxuXFxcbnZvaWQgbWFpbigpXFxuXFxcbntcXG5cXFxuICAgIHZlYzQgY29sb3IgPSB0ZXh0dXJlMkQodV90ZXh0dXJlLCB2X3RleHR1cmVDb29yZGluYXRlcyk7XFxuXFxcbiAgICBnbF9GcmFnQ29sb3IgPSBjem1fZ2FtbWFDb3JyZWN0KGNvbG9yKTtcXG5cXFxufVxcblxcXG5cIjtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///26103\n')},44242:function(__unused_webpack___webpack_module__,__webpack_exports__){eval('//This file is automatically rebuilt by the Cesium build process.\n/* harmony default export */ __webpack_exports__["Z"] = ("uniform float u_radiusTS;\\n\\\n\\n\\\nvarying vec2 v_textureCoordinates;\\n\\\n\\n\\\nvec2 rotate(vec2 p, vec2 direction)\\n\\\n{\\n\\\n    return vec2(p.x * direction.x - p.y * direction.y, p.x * direction.y + p.y * direction.x);\\n\\\n}\\n\\\n\\n\\\nvec4 addBurst(vec2 position, vec2 direction, float lengthScalar)\\n\\\n{\\n\\\n    vec2 rotatedPosition = rotate(position, direction) * vec2(25.0, 0.75);\\n\\\n    float radius = length(rotatedPosition) * lengthScalar;\\n\\\n    float burst = 1.0 - smoothstep(0.0, 0.55, radius);\\n\\\n    return vec4(burst);\\n\\\n}\\n\\\n\\n\\\nvoid main()\\n\\\n{\\n\\\n    float lengthScalar = 2.0 / sqrt(2.0);\\n\\\n    vec2 position = v_textureCoordinates - vec2(0.5);\\n\\\n    float radius = length(position) * lengthScalar;\\n\\\n    float surface = step(radius, u_radiusTS);\\n\\\n    vec4 color = vec4(vec2(1.0), surface + 0.2, surface);\\n\\\n\\n\\\n    float glow = 1.0 - smoothstep(0.0, 0.55, radius);\\n\\\n    color.ba += mix(vec2(0.0), vec2(1.0), glow) * 0.75;\\n\\\n\\n\\\n    vec4 burst = vec4(0.0);\\n\\\n\\n\\\n    // The following loop has been manually unrolled for speed, to\\n\\\n    // avoid sin() and cos().\\n\\\n    //\\n\\\n    //for (float i = 0.4; i < 3.2; i += 1.047) {\\n\\\n    //    vec2 direction = vec2(sin(i), cos(i));\\n\\\n    //    burst += 0.4 * addBurst(position, direction, lengthScalar);\\n\\\n    //\\n\\\n    //    direction = vec2(sin(i - 0.08), cos(i - 0.08));\\n\\\n    //    burst += 0.3 * addBurst(position, direction, lengthScalar);\\n\\\n    //}\\n\\\n\\n\\\n    burst += 0.4 * addBurst(position, vec2(0.38942,  0.92106), lengthScalar);  // angle == 0.4\\n\\\n    burst += 0.4 * addBurst(position, vec2(0.99235,  0.12348), lengthScalar);  // angle == 0.4 + 1.047\\n\\\n    burst += 0.4 * addBurst(position, vec2(0.60327, -0.79754), lengthScalar);  // angle == 0.4 + 1.047 * 2.0\\n\\\n\\n\\\n    burst += 0.3 * addBurst(position, vec2(0.31457,  0.94924), lengthScalar);  // angle == 0.4 - 0.08\\n\\\n    burst += 0.3 * addBurst(position, vec2(0.97931,  0.20239), lengthScalar);  // angle == 0.4 + 1.047 - 0.08\\n\\\n    burst += 0.3 * addBurst(position, vec2(0.66507, -0.74678), lengthScalar);  // angle == 0.4 + 1.047 * 2.0 - 0.08\\n\\\n\\n\\\n    // End of manual loop unrolling.\\n\\\n\\n\\\n    color += clamp(burst, vec4(0.0), vec4(1.0)) * 0.15;\\n\\\n\\n\\\n    gl_FragColor = clamp(color, vec4(0.0), vec4(1.0));\\n\\\n}\\n\\\n");\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNDQyNDIuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQSx5REFBZSwwQkFBMEI7QUFDekM7QUFDQSxrQ0FBa0M7QUFDbEM7QUFDQTtBQUNBLENBQUM7QUFDRCw4RkFBOEY7QUFDOUYsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0QsMEVBQTBFO0FBQzFFLDBEQUEwRDtBQUMxRCxzREFBc0Q7QUFDdEQsdUJBQXVCO0FBQ3ZCLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNELHlDQUF5QztBQUN6QyxxREFBcUQ7QUFDckQsbURBQW1EO0FBQ25ELDZDQUE2QztBQUM3Qyx5REFBeUQ7QUFDekQ7QUFDQSxxREFBcUQ7QUFDckQsdURBQXVEO0FBQ3ZEO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLFNBQVMsYUFBYTtBQUNoRCxnREFBZ0Q7QUFDaEQscUVBQXFFO0FBQ3JFO0FBQ0EseURBQXlEO0FBQ3pELHFFQUFxRTtBQUNyRSxPQUFPO0FBQ1A7QUFDQSwrRUFBK0U7QUFDL0UsK0VBQStFO0FBQy9FLCtFQUErRTtBQUMvRTtBQUNBLCtFQUErRTtBQUMvRSwrRUFBK0U7QUFDL0UsK0VBQStFO0FBQy9FO0FBQ0E7QUFDQTtBQUNBLHVEQUF1RDtBQUN2RDtBQUNBLHNEQUFzRDtBQUN0RCxDQUFDO0FBQ0QsQ0FBQyxFQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdnVlMy13ZWJwYWNrNS8uL25vZGVfbW9kdWxlcy9jZXNpdW0vU291cmNlL1NoYWRlcnMvU3VuVGV4dHVyZUZTLmpzPzYwNzMiXSwic291cmNlc0NvbnRlbnQiOlsiLy9UaGlzIGZpbGUgaXMgYXV0b21hdGljYWxseSByZWJ1aWx0IGJ5IHRoZSBDZXNpdW0gYnVpbGQgcHJvY2Vzcy5cbmV4cG9ydCBkZWZhdWx0IFwidW5pZm9ybSBmbG9hdCB1X3JhZGl1c1RTO1xcblxcXG5cXG5cXFxudmFyeWluZyB2ZWMyIHZfdGV4dHVyZUNvb3JkaW5hdGVzO1xcblxcXG5cXG5cXFxudmVjMiByb3RhdGUodmVjMiBwLCB2ZWMyIGRpcmVjdGlvbilcXG5cXFxue1xcblxcXG4gICAgcmV0dXJuIHZlYzIocC54ICogZGlyZWN0aW9uLnggLSBwLnkgKiBkaXJlY3Rpb24ueSwgcC54ICogZGlyZWN0aW9uLnkgKyBwLnkgKiBkaXJlY3Rpb24ueCk7XFxuXFxcbn1cXG5cXFxuXFxuXFxcbnZlYzQgYWRkQnVyc3QodmVjMiBwb3NpdGlvbiwgdmVjMiBkaXJlY3Rpb24sIGZsb2F0IGxlbmd0aFNjYWxhcilcXG5cXFxue1xcblxcXG4gICAgdmVjMiByb3RhdGVkUG9zaXRpb24gPSByb3RhdGUocG9zaXRpb24sIGRpcmVjdGlvbikgKiB2ZWMyKDI1LjAsIDAuNzUpO1xcblxcXG4gICAgZmxvYXQgcmFkaXVzID0gbGVuZ3RoKHJvdGF0ZWRQb3NpdGlvbikgKiBsZW5ndGhTY2FsYXI7XFxuXFxcbiAgICBmbG9hdCBidXJzdCA9IDEuMCAtIHNtb290aHN0ZXAoMC4wLCAwLjU1LCByYWRpdXMpO1xcblxcXG4gICAgcmV0dXJuIHZlYzQoYnVyc3QpO1xcblxcXG59XFxuXFxcblxcblxcXG52b2lkIG1haW4oKVxcblxcXG57XFxuXFxcbiAgICBmbG9hdCBsZW5ndGhTY2FsYXIgPSAyLjAgLyBzcXJ0KDIuMCk7XFxuXFxcbiAgICB2ZWMyIHBvc2l0aW9uID0gdl90ZXh0dXJlQ29vcmRpbmF0ZXMgLSB2ZWMyKDAuNSk7XFxuXFxcbiAgICBmbG9hdCByYWRpdXMgPSBsZW5ndGgocG9zaXRpb24pICogbGVuZ3RoU2NhbGFyO1xcblxcXG4gICAgZmxvYXQgc3VyZmFjZSA9IHN0ZXAocmFkaXVzLCB1X3JhZGl1c1RTKTtcXG5cXFxuICAgIHZlYzQgY29sb3IgPSB2ZWM0KHZlYzIoMS4wKSwgc3VyZmFjZSArIDAuMiwgc3VyZmFjZSk7XFxuXFxcblxcblxcXG4gICAgZmxvYXQgZ2xvdyA9IDEuMCAtIHNtb290aHN0ZXAoMC4wLCAwLjU1LCByYWRpdXMpO1xcblxcXG4gICAgY29sb3IuYmEgKz0gbWl4KHZlYzIoMC4wKSwgdmVjMigxLjApLCBnbG93KSAqIDAuNzU7XFxuXFxcblxcblxcXG4gICAgdmVjNCBidXJzdCA9IHZlYzQoMC4wKTtcXG5cXFxuXFxuXFxcbiAgICAvLyBUaGUgZm9sbG93aW5nIGxvb3AgaGFzIGJlZW4gbWFudWFsbHkgdW5yb2xsZWQgZm9yIHNwZWVkLCB0b1xcblxcXG4gICAgLy8gYXZvaWQgc2luKCkgYW5kIGNvcygpLlxcblxcXG4gICAgLy9cXG5cXFxuICAgIC8vZm9yIChmbG9hdCBpID0gMC40OyBpIDwgMy4yOyBpICs9IDEuMDQ3KSB7XFxuXFxcbiAgICAvLyAgICB2ZWMyIGRpcmVjdGlvbiA9IHZlYzIoc2luKGkpLCBjb3MoaSkpO1xcblxcXG4gICAgLy8gICAgYnVyc3QgKz0gMC40ICogYWRkQnVyc3QocG9zaXRpb24sIGRpcmVjdGlvbiwgbGVuZ3RoU2NhbGFyKTtcXG5cXFxuICAgIC8vXFxuXFxcbiAgICAvLyAgICBkaXJlY3Rpb24gPSB2ZWMyKHNpbihpIC0gMC4wOCksIGNvcyhpIC0gMC4wOCkpO1xcblxcXG4gICAgLy8gICAgYnVyc3QgKz0gMC4zICogYWRkQnVyc3QocG9zaXRpb24sIGRpcmVjdGlvbiwgbGVuZ3RoU2NhbGFyKTtcXG5cXFxuICAgIC8vfVxcblxcXG5cXG5cXFxuICAgIGJ1cnN0ICs9IDAuNCAqIGFkZEJ1cnN0KHBvc2l0aW9uLCB2ZWMyKDAuMzg5NDIsICAwLjkyMTA2KSwgbGVuZ3RoU2NhbGFyKTsgIC8vIGFuZ2xlID09IDAuNFxcblxcXG4gICAgYnVyc3QgKz0gMC40ICogYWRkQnVyc3QocG9zaXRpb24sIHZlYzIoMC45OTIzNSwgIDAuMTIzNDgpLCBsZW5ndGhTY2FsYXIpOyAgLy8gYW5nbGUgPT0gMC40ICsgMS4wNDdcXG5cXFxuICAgIGJ1cnN0ICs9IDAuNCAqIGFkZEJ1cnN0KHBvc2l0aW9uLCB2ZWMyKDAuNjAzMjcsIC0wLjc5NzU0KSwgbGVuZ3RoU2NhbGFyKTsgIC8vIGFuZ2xlID09IDAuNCArIDEuMDQ3ICogMi4wXFxuXFxcblxcblxcXG4gICAgYnVyc3QgKz0gMC4zICogYWRkQnVyc3QocG9zaXRpb24sIHZlYzIoMC4zMTQ1NywgIDAuOTQ5MjQpLCBsZW5ndGhTY2FsYXIpOyAgLy8gYW5nbGUgPT0gMC40IC0gMC4wOFxcblxcXG4gICAgYnVyc3QgKz0gMC4zICogYWRkQnVyc3QocG9zaXRpb24sIHZlYzIoMC45NzkzMSwgIDAuMjAyMzkpLCBsZW5ndGhTY2FsYXIpOyAgLy8gYW5nbGUgPT0gMC40ICsgMS4wNDcgLSAwLjA4XFxuXFxcbiAgICBidXJzdCArPSAwLjMgKiBhZGRCdXJzdChwb3NpdGlvbiwgdmVjMigwLjY2NTA3LCAtMC43NDY3OCksIGxlbmd0aFNjYWxhcik7ICAvLyBhbmdsZSA9PSAwLjQgKyAxLjA0NyAqIDIuMCAtIDAuMDhcXG5cXFxuXFxuXFxcbiAgICAvLyBFbmQgb2YgbWFudWFsIGxvb3AgdW5yb2xsaW5nLlxcblxcXG5cXG5cXFxuICAgIGNvbG9yICs9IGNsYW1wKGJ1cnN0LCB2ZWM0KDAuMCksIHZlYzQoMS4wKSkgKiAwLjE1O1xcblxcXG5cXG5cXFxuICAgIGdsX0ZyYWdDb2xvciA9IGNsYW1wKGNvbG9yLCB2ZWM0KDAuMCksIHZlYzQoMS4wKSk7XFxuXFxcbn1cXG5cXFxuXCI7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///44242\n')},54830:function(__unused_webpack___webpack_module__,__webpack_exports__){eval('//This file is automatically rebuilt by the Cesium build process.\n/* harmony default export */ __webpack_exports__["Z"] = ("attribute vec2 direction;\\n\\\n\\n\\\nuniform float u_size;\\n\\\n\\n\\\nvarying vec2 v_textureCoordinates;\\n\\\n\\n\\\nvoid main() \\n\\\n{\\n\\\n    vec4 position;\\n\\\n    if (czm_morphTime == 1.0)\\n\\\n    {\\n\\\n        position = vec4(czm_sunPositionWC, 1.0);\\n\\\n    }\\n\\\n    else\\n\\\n    {\\n\\\n        position = vec4(czm_sunPositionColumbusView.zxy, 1.0);\\n\\\n    }\\n\\\n    \\n\\\n    vec4 positionEC = czm_view * position;\\n\\\n    vec4 positionWC = czm_eyeToWindowCoordinates(positionEC);\\n\\\n    \\n\\\n    vec2 halfSize = vec2(u_size * 0.5);\\n\\\n    halfSize *= ((direction * 2.0) - 1.0);\\n\\\n    \\n\\\n    gl_Position = czm_viewportOrthographic * vec4(positionWC.xy + halfSize, -positionWC.z, 1.0);\\n\\\n    \\n\\\n    v_textureCoordinates = direction;\\n\\\n}\\n\\\n");\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNTQ4MzAuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQSx5REFBZSwwQkFBMEI7QUFDekM7QUFDQSxxQkFBcUI7QUFDckI7QUFDQSxrQ0FBa0M7QUFDbEM7QUFDQTtBQUNBLENBQUM7QUFDRCxrQkFBa0I7QUFDbEI7QUFDQSxLQUFLO0FBQ0wsZ0RBQWdEO0FBQ2hELEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTCw4REFBOEQ7QUFDOUQsS0FBSztBQUNMO0FBQ0EsMENBQTBDO0FBQzFDLDZEQUE2RDtBQUM3RDtBQUNBLHVDQUF1QztBQUN2QywwQ0FBMEM7QUFDMUM7QUFDQSxnR0FBZ0c7QUFDaEc7QUFDQSxxQ0FBcUM7QUFDckMsQ0FBQztBQUNELENBQUMsRUFBQyIsInNvdXJjZXMiOlsid2VicGFjazovL3Z1ZTMtd2VicGFjazUvLi9ub2RlX21vZHVsZXMvY2VzaXVtL1NvdXJjZS9TaGFkZXJzL1N1blZTLmpzPzY1MDIiXSwic291cmNlc0NvbnRlbnQiOlsiLy9UaGlzIGZpbGUgaXMgYXV0b21hdGljYWxseSByZWJ1aWx0IGJ5IHRoZSBDZXNpdW0gYnVpbGQgcHJvY2Vzcy5cbmV4cG9ydCBkZWZhdWx0IFwiYXR0cmlidXRlIHZlYzIgZGlyZWN0aW9uO1xcblxcXG5cXG5cXFxudW5pZm9ybSBmbG9hdCB1X3NpemU7XFxuXFxcblxcblxcXG52YXJ5aW5nIHZlYzIgdl90ZXh0dXJlQ29vcmRpbmF0ZXM7XFxuXFxcblxcblxcXG52b2lkIG1haW4oKSBcXG5cXFxue1xcblxcXG4gICAgdmVjNCBwb3NpdGlvbjtcXG5cXFxuICAgIGlmIChjem1fbW9ycGhUaW1lID09IDEuMClcXG5cXFxuICAgIHtcXG5cXFxuICAgICAgICBwb3NpdGlvbiA9IHZlYzQoY3ptX3N1blBvc2l0aW9uV0MsIDEuMCk7XFxuXFxcbiAgICB9XFxuXFxcbiAgICBlbHNlXFxuXFxcbiAgICB7XFxuXFxcbiAgICAgICAgcG9zaXRpb24gPSB2ZWM0KGN6bV9zdW5Qb3NpdGlvbkNvbHVtYnVzVmlldy56eHksIDEuMCk7XFxuXFxcbiAgICB9XFxuXFxcbiAgICBcXG5cXFxuICAgIHZlYzQgcG9zaXRpb25FQyA9IGN6bV92aWV3ICogcG9zaXRpb247XFxuXFxcbiAgICB2ZWM0IHBvc2l0aW9uV0MgPSBjem1fZXllVG9XaW5kb3dDb29yZGluYXRlcyhwb3NpdGlvbkVDKTtcXG5cXFxuICAgIFxcblxcXG4gICAgdmVjMiBoYWxmU2l6ZSA9IHZlYzIodV9zaXplICogMC41KTtcXG5cXFxuICAgIGhhbGZTaXplICo9ICgoZGlyZWN0aW9uICogMi4wKSAtIDEuMCk7XFxuXFxcbiAgICBcXG5cXFxuICAgIGdsX1Bvc2l0aW9uID0gY3ptX3ZpZXdwb3J0T3J0aG9ncmFwaGljICogdmVjNChwb3NpdGlvbldDLnh5ICsgaGFsZlNpemUsIC1wb3NpdGlvbldDLnosIDEuMCk7XFxuXFxcbiAgICBcXG5cXFxuICAgIHZfdGV4dHVyZUNvb3JkaW5hdGVzID0gZGlyZWN0aW9uO1xcblxcXG59XFxuXFxcblwiO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///54830\n')},74532:function(__unused_webpack___webpack_module__,__webpack_exports__){eval('//This file is automatically rebuilt by the Cesium build process.\n/* harmony default export */ __webpack_exports__["Z"] = ("#ifdef GL_EXT_frag_depth\\n\\\n#extension GL_EXT_frag_depth : enable\\n\\\n#endif\\n\\\n\\n\\\nvarying vec4 v_startPlaneEC;\\n\\\nvarying vec4 v_endPlaneEC;\\n\\\nvarying vec4 v_rightPlaneEC;\\n\\\nvarying float v_halfWidth;\\n\\\nvarying vec3 v_volumeUpEC;\\n\\\n\\n\\\nuniform vec4 u_highlightColor;\\n\\\nvoid main()\\n\\\n{\\n\\\n    float logDepthOrDepth = czm_branchFreeTernary(czm_sceneMode == czm_sceneMode2D, gl_FragCoord.z, czm_unpackDepth(texture2D(czm_globeDepthTexture, gl_FragCoord.xy / czm_viewport.zw)));\\n\\\n\\n\\\n    // Discard for sky\\n\\\n    if (logDepthOrDepth == 0.0) {\\n\\\n#ifdef DEBUG_SHOW_VOLUME\\n\\\n        gl_FragColor = vec4(0.0, 0.0, 1.0, 0.5);\\n\\\n        return;\\n\\\n#else // DEBUG_SHOW_VOLUME\\n\\\n        discard;\\n\\\n#endif // DEBUG_SHOW_VOLUME\\n\\\n    }\\n\\\n\\n\\\n    vec4 eyeCoordinate = czm_windowToEyeCoordinates(gl_FragCoord.xy, logDepthOrDepth);\\n\\\n    eyeCoordinate /= eyeCoordinate.w;\\n\\\n\\n\\\n    float halfMaxWidth = v_halfWidth * czm_metersPerPixel(eyeCoordinate);\\n\\\n\\n\\\n    // Expand halfMaxWidth if direction to camera is almost perpendicular with the volume\'s up direction\\n\\\n    halfMaxWidth += halfMaxWidth * (1.0 - dot(-normalize(eyeCoordinate.xyz), v_volumeUpEC));\\n\\\n\\n\\\n    // Check distance of the eye coordinate against the right-facing plane\\n\\\n    float widthwiseDistance = czm_planeDistance(v_rightPlaneEC, eyeCoordinate.xyz);\\n\\\n\\n\\\n    // Check eye coordinate against the mitering planes\\n\\\n    float distanceFromStart = czm_planeDistance(v_startPlaneEC, eyeCoordinate.xyz);\\n\\\n    float distanceFromEnd = czm_planeDistance(v_endPlaneEC, eyeCoordinate.xyz);\\n\\\n\\n\\\n    if (abs(widthwiseDistance) > halfMaxWidth || distanceFromStart < 0.0 || distanceFromEnd < 0.0) {\\n\\\n#ifdef DEBUG_SHOW_VOLUME\\n\\\n        gl_FragColor = vec4(logDepthOrDepth, 0.0, 0.0, 0.5);\\n\\\n        return;\\n\\\n#else // DEBUG_SHOW_VOLUME\\n\\\n        discard;\\n\\\n#endif // DEBUG_SHOW_VOLUME\\n\\\n    }\\n\\\n    gl_FragColor = u_highlightColor;\\n\\\n\\n\\\n    czm_writeDepthClamp();\\n\\\n}\\n\\\n");\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNzQ1MzIuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQSx5REFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QjtBQUM1QiwwQkFBMEI7QUFDMUIsNEJBQTRCO0FBQzVCLDBCQUEwQjtBQUMxQiwwQkFBMEI7QUFDMUI7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQSxDQUFDO0FBQ0QsMExBQTBMO0FBQzFMO0FBQ0E7QUFDQSxpQ0FBaUM7QUFDakM7QUFDQSxnREFBZ0Q7QUFDaEQsZUFBZTtBQUNmO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0EsS0FBSztBQUNMO0FBQ0Esc0ZBQXNGO0FBQ3RGLHFDQUFxQztBQUNyQztBQUNBLHlFQUF5RTtBQUN6RTtBQUNBO0FBQ0EsNEZBQTRGO0FBQzVGO0FBQ0E7QUFDQSxtRkFBbUY7QUFDbkY7QUFDQTtBQUNBLG1GQUFtRjtBQUNuRiwrRUFBK0U7QUFDL0U7QUFDQSxvR0FBb0c7QUFDcEc7QUFDQSw0REFBNEQ7QUFDNUQsZUFBZTtBQUNmO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0EsS0FBSztBQUNMLG9DQUFvQztBQUNwQztBQUNBLDBCQUEwQjtBQUMxQixDQUFDO0FBQ0QsQ0FBQyxFQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdnVlMy13ZWJwYWNrNS8uL25vZGVfbW9kdWxlcy9jZXNpdW0vU291cmNlL1NoYWRlcnMvVmVjdG9yM0RUaWxlQ2xhbXBlZFBvbHlsaW5lc0ZTLmpzP2Q4ZGEiXSwic291cmNlc0NvbnRlbnQiOlsiLy9UaGlzIGZpbGUgaXMgYXV0b21hdGljYWxseSByZWJ1aWx0IGJ5IHRoZSBDZXNpdW0gYnVpbGQgcHJvY2Vzcy5cbmV4cG9ydCBkZWZhdWx0IFwiI2lmZGVmIEdMX0VYVF9mcmFnX2RlcHRoXFxuXFxcbiNleHRlbnNpb24gR0xfRVhUX2ZyYWdfZGVwdGggOiBlbmFibGVcXG5cXFxuI2VuZGlmXFxuXFxcblxcblxcXG52YXJ5aW5nIHZlYzQgdl9zdGFydFBsYW5lRUM7XFxuXFxcbnZhcnlpbmcgdmVjNCB2X2VuZFBsYW5lRUM7XFxuXFxcbnZhcnlpbmcgdmVjNCB2X3JpZ2h0UGxhbmVFQztcXG5cXFxudmFyeWluZyBmbG9hdCB2X2hhbGZXaWR0aDtcXG5cXFxudmFyeWluZyB2ZWMzIHZfdm9sdW1lVXBFQztcXG5cXFxuXFxuXFxcbnVuaWZvcm0gdmVjNCB1X2hpZ2hsaWdodENvbG9yO1xcblxcXG52b2lkIG1haW4oKVxcblxcXG57XFxuXFxcbiAgICBmbG9hdCBsb2dEZXB0aE9yRGVwdGggPSBjem1fYnJhbmNoRnJlZVRlcm5hcnkoY3ptX3NjZW5lTW9kZSA9PSBjem1fc2NlbmVNb2RlMkQsIGdsX0ZyYWdDb29yZC56LCBjem1fdW5wYWNrRGVwdGgodGV4dHVyZTJEKGN6bV9nbG9iZURlcHRoVGV4dHVyZSwgZ2xfRnJhZ0Nvb3JkLnh5IC8gY3ptX3ZpZXdwb3J0Lnp3KSkpO1xcblxcXG5cXG5cXFxuICAgIC8vIERpc2NhcmQgZm9yIHNreVxcblxcXG4gICAgaWYgKGxvZ0RlcHRoT3JEZXB0aCA9PSAwLjApIHtcXG5cXFxuI2lmZGVmIERFQlVHX1NIT1dfVk9MVU1FXFxuXFxcbiAgICAgICAgZ2xfRnJhZ0NvbG9yID0gdmVjNCgwLjAsIDAuMCwgMS4wLCAwLjUpO1xcblxcXG4gICAgICAgIHJldHVybjtcXG5cXFxuI2Vsc2UgLy8gREVCVUdfU0hPV19WT0xVTUVcXG5cXFxuICAgICAgICBkaXNjYXJkO1xcblxcXG4jZW5kaWYgLy8gREVCVUdfU0hPV19WT0xVTUVcXG5cXFxuICAgIH1cXG5cXFxuXFxuXFxcbiAgICB2ZWM0IGV5ZUNvb3JkaW5hdGUgPSBjem1fd2luZG93VG9FeWVDb29yZGluYXRlcyhnbF9GcmFnQ29vcmQueHksIGxvZ0RlcHRoT3JEZXB0aCk7XFxuXFxcbiAgICBleWVDb29yZGluYXRlIC89IGV5ZUNvb3JkaW5hdGUudztcXG5cXFxuXFxuXFxcbiAgICBmbG9hdCBoYWxmTWF4V2lkdGggPSB2X2hhbGZXaWR0aCAqIGN6bV9tZXRlcnNQZXJQaXhlbChleWVDb29yZGluYXRlKTtcXG5cXFxuXFxuXFxcbiAgICAvLyBFeHBhbmQgaGFsZk1heFdpZHRoIGlmIGRpcmVjdGlvbiB0byBjYW1lcmEgaXMgYWxtb3N0IHBlcnBlbmRpY3VsYXIgd2l0aCB0aGUgdm9sdW1lJ3MgdXAgZGlyZWN0aW9uXFxuXFxcbiAgICBoYWxmTWF4V2lkdGggKz0gaGFsZk1heFdpZHRoICogKDEuMCAtIGRvdCgtbm9ybWFsaXplKGV5ZUNvb3JkaW5hdGUueHl6KSwgdl92b2x1bWVVcEVDKSk7XFxuXFxcblxcblxcXG4gICAgLy8gQ2hlY2sgZGlzdGFuY2Ugb2YgdGhlIGV5ZSBjb29yZGluYXRlIGFnYWluc3QgdGhlIHJpZ2h0LWZhY2luZyBwbGFuZVxcblxcXG4gICAgZmxvYXQgd2lkdGh3aXNlRGlzdGFuY2UgPSBjem1fcGxhbmVEaXN0YW5jZSh2X3JpZ2h0UGxhbmVFQywgZXllQ29vcmRpbmF0ZS54eXopO1xcblxcXG5cXG5cXFxuICAgIC8vIENoZWNrIGV5ZSBjb29yZGluYXRlIGFnYWluc3QgdGhlIG1pdGVyaW5nIHBsYW5lc1xcblxcXG4gICAgZmxvYXQgZGlzdGFuY2VGcm9tU3RhcnQgPSBjem1fcGxhbmVEaXN0YW5jZSh2X3N0YXJ0UGxhbmVFQywgZXllQ29vcmRpbmF0ZS54eXopO1xcblxcXG4gICAgZmxvYXQgZGlzdGFuY2VGcm9tRW5kID0gY3ptX3BsYW5lRGlzdGFuY2Uodl9lbmRQbGFuZUVDLCBleWVDb29yZGluYXRlLnh5eik7XFxuXFxcblxcblxcXG4gICAgaWYgKGFicyh3aWR0aHdpc2VEaXN0YW5jZSkgPiBoYWxmTWF4V2lkdGggfHwgZGlzdGFuY2VGcm9tU3RhcnQgPCAwLjAgfHwgZGlzdGFuY2VGcm9tRW5kIDwgMC4wKSB7XFxuXFxcbiNpZmRlZiBERUJVR19TSE9XX1ZPTFVNRVxcblxcXG4gICAgICAgIGdsX0ZyYWdDb2xvciA9IHZlYzQobG9nRGVwdGhPckRlcHRoLCAwLjAsIDAuMCwgMC41KTtcXG5cXFxuICAgICAgICByZXR1cm47XFxuXFxcbiNlbHNlIC8vIERFQlVHX1NIT1dfVk9MVU1FXFxuXFxcbiAgICAgICAgZGlzY2FyZDtcXG5cXFxuI2VuZGlmIC8vIERFQlVHX1NIT1dfVk9MVU1FXFxuXFxcbiAgICB9XFxuXFxcbiAgICBnbF9GcmFnQ29sb3IgPSB1X2hpZ2hsaWdodENvbG9yO1xcblxcXG5cXG5cXFxuICAgIGN6bV93cml0ZURlcHRoQ2xhbXAoKTtcXG5cXFxufVxcblxcXG5cIjtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///74532\n')},65493:function(__unused_webpack___webpack_module__,__webpack_exports__){eval('//This file is automatically rebuilt by the Cesium build process.\n/* harmony default export */ __webpack_exports__["Z"] = ("attribute vec3 startEllipsoidNormal;\\n\\\nattribute vec3 endEllipsoidNormal;\\n\\\nattribute vec4 startPositionAndHeight;\\n\\\nattribute vec4 endPositionAndHeight;\\n\\\nattribute vec4 startFaceNormalAndVertexCorner;\\n\\\nattribute vec4 endFaceNormalAndHalfWidth;\\n\\\nattribute float a_batchId;\\n\\\n\\n\\\nuniform mat4 u_modifiedModelView;\\n\\\nuniform vec2 u_minimumMaximumVectorHeights;\\n\\\n\\n\\\nvarying vec4 v_startPlaneEC;\\n\\\nvarying vec4 v_endPlaneEC;\\n\\\nvarying vec4 v_rightPlaneEC;\\n\\\nvarying float v_halfWidth;\\n\\\nvarying vec3 v_volumeUpEC;\\n\\\n\\n\\\nvoid main()\\n\\\n{\\n\\\n    // vertex corner IDs\\n\\\n    //          3-----------7\\n\\\n    //         /|   left   /|\\n\\\n    //        / | 1       / |\\n\\\n    //       2-----------6  5  end\\n\\\n    //       | /         | /\\n\\\n    // start |/  right   |/\\n\\\n    //       0-----------4\\n\\\n    //\\n\\\n    float isEnd = floor(startFaceNormalAndVertexCorner.w * 0.251); // 0 for front, 1 for end\\n\\\n    float isTop = floor(startFaceNormalAndVertexCorner.w * mix(0.51, 0.19, isEnd)); // 0 for bottom, 1 for top\\n\\\n\\n\\\n    vec3 forward = endPositionAndHeight.xyz - startPositionAndHeight.xyz;\\n\\\n    vec3 right = normalize(cross(forward, startEllipsoidNormal));\\n\\\n\\n\\\n    vec4 position = vec4(startPositionAndHeight.xyz, 1.0);\\n\\\n    position.xyz += forward * isEnd;\\n\\\n\\n\\\n    v_volumeUpEC = czm_normal * normalize(cross(right, forward));\\n\\\n\\n\\\n    // Push for volume height\\n\\\n    float offset;\\n\\\n    vec3 ellipsoidNormal = mix(startEllipsoidNormal, endEllipsoidNormal, isEnd);\\n\\\n\\n\\\n    // offset height to create volume\\n\\\n    offset = mix(startPositionAndHeight.w, endPositionAndHeight.w, isEnd);\\n\\\n    offset = mix(u_minimumMaximumVectorHeights.y, u_minimumMaximumVectorHeights.x, isTop) - offset;\\n\\\n    position.xyz += offset * ellipsoidNormal;\\n\\\n\\n\\\n    // move from RTC to EC\\n\\\n    position = u_modifiedModelView * position;\\n\\\n    right = czm_normal * right;\\n\\\n\\n\\\n    // Push for width in a direction that is in the start or end plane and in a plane with right\\n\\\n    // N = normalEC (\\"right-facing\\" direction for push)\\n\\\n    // R = right\\n\\\n    // p = angle between N and R\\n\\\n    // w = distance to push along R if R == N\\n\\\n    // d = distance to push along N\\n\\\n    //\\n\\\n    //   N   R\\n\\\n    //  { \\ p| }      * cos(p) = dot(N, R) = w / d\\n\\\n    //  d\\ \\ |  |w    * d = w / dot(N, R)\\n\\\n    //    { \\| }\\n\\\n    //       o---------- polyline segment ----\x3e\\n\\\n    //\\n\\\n    vec3 scratchNormal = mix(-startFaceNormalAndVertexCorner.xyz, endFaceNormalAndHalfWidth.xyz, isEnd);\\n\\\n    scratchNormal = cross(scratchNormal, mix(startEllipsoidNormal, endEllipsoidNormal, isEnd));\\n\\\n    vec3 miterPushNormal = czm_normal * normalize(scratchNormal);\\n\\\n\\n\\\n    offset = 2.0 * endFaceNormalAndHalfWidth.w * max(0.0, czm_metersPerPixel(position)); // offset = widthEC\\n\\\n    offset = offset / dot(miterPushNormal, right);\\n\\\n    position.xyz += miterPushNormal * (offset * sign(0.5 - mod(startFaceNormalAndVertexCorner.w, 2.0)));\\n\\\n\\n\\\n    gl_Position = czm_depthClamp(czm_projection * position);\\n\\\n\\n\\\n    position = u_modifiedModelView * vec4(startPositionAndHeight.xyz, 1.0);\\n\\\n    vec3 startNormalEC = czm_normal * startFaceNormalAndVertexCorner.xyz;\\n\\\n    v_startPlaneEC = vec4(startNormalEC, -dot(startNormalEC, position.xyz));\\n\\\n    v_rightPlaneEC = vec4(right, -dot(right, position.xyz));\\n\\\n\\n\\\n    position = u_modifiedModelView * vec4(endPositionAndHeight.xyz, 1.0);\\n\\\n    vec3 endNormalEC = czm_normal * endFaceNormalAndHalfWidth.xyz;\\n\\\n    v_endPlaneEC = vec4(endNormalEC, -dot(endNormalEC, position.xyz));\\n\\\n    v_halfWidth = endFaceNormalAndHalfWidth.w;\\n\\\n}\\n\\\n");\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNjU0OTMuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQSx5REFBZSxxQ0FBcUM7QUFDcEQsa0NBQWtDO0FBQ2xDLHNDQUFzQztBQUN0QyxvQ0FBb0M7QUFDcEMsOENBQThDO0FBQzlDLHlDQUF5QztBQUN6QywwQkFBMEI7QUFDMUI7QUFDQSxpQ0FBaUM7QUFDakMsMkNBQTJDO0FBQzNDO0FBQ0EsNEJBQTRCO0FBQzVCLDBCQUEwQjtBQUMxQiw0QkFBNEI7QUFDNUIsMEJBQTBCO0FBQzFCLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1FQUFtRTtBQUNuRSxvRkFBb0Y7QUFDcEY7QUFDQSx5RUFBeUU7QUFDekUsaUVBQWlFO0FBQ2pFO0FBQ0EsMERBQTBEO0FBQzFELG9DQUFvQztBQUNwQztBQUNBLGlFQUFpRTtBQUNqRTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCLGdGQUFnRjtBQUNoRjtBQUNBO0FBQ0EsMEVBQTBFO0FBQzFFLG1HQUFtRztBQUNuRyw2Q0FBNkM7QUFDN0M7QUFDQTtBQUNBLDhDQUE4QztBQUM5QywrQkFBK0I7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSxZQUFZO0FBQ3RCO0FBQ0EsWUFBWSxJQUFJO0FBQ2hCO0FBQ0E7QUFDQSx3R0FBd0c7QUFDeEcsK0ZBQStGO0FBQy9GLGlFQUFpRTtBQUNqRTtBQUNBLHlGQUF5RjtBQUN6RixrREFBa0Q7QUFDbEQsd0dBQXdHO0FBQ3hHO0FBQ0EsNERBQTREO0FBQzVEO0FBQ0EsMkVBQTJFO0FBQzNFLHlFQUF5RTtBQUN6RSw0RUFBNEU7QUFDNUUsNERBQTREO0FBQzVEO0FBQ0EseUVBQXlFO0FBQ3pFLGtFQUFrRTtBQUNsRSxzRUFBc0U7QUFDdEUsOENBQThDO0FBQzlDLENBQUM7QUFDRCxDQUFDLEVBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly92dWUzLXdlYnBhY2s1Ly4vbm9kZV9tb2R1bGVzL2Nlc2l1bS9Tb3VyY2UvU2hhZGVycy9WZWN0b3IzRFRpbGVDbGFtcGVkUG9seWxpbmVzVlMuanM/ZDE1MiJdLCJzb3VyY2VzQ29udGVudCI6WyIvL1RoaXMgZmlsZSBpcyBhdXRvbWF0aWNhbGx5IHJlYnVpbHQgYnkgdGhlIENlc2l1bSBidWlsZCBwcm9jZXNzLlxuZXhwb3J0IGRlZmF1bHQgXCJhdHRyaWJ1dGUgdmVjMyBzdGFydEVsbGlwc29pZE5vcm1hbDtcXG5cXFxuYXR0cmlidXRlIHZlYzMgZW5kRWxsaXBzb2lkTm9ybWFsO1xcblxcXG5hdHRyaWJ1dGUgdmVjNCBzdGFydFBvc2l0aW9uQW5kSGVpZ2h0O1xcblxcXG5hdHRyaWJ1dGUgdmVjNCBlbmRQb3NpdGlvbkFuZEhlaWdodDtcXG5cXFxuYXR0cmlidXRlIHZlYzQgc3RhcnRGYWNlTm9ybWFsQW5kVmVydGV4Q29ybmVyO1xcblxcXG5hdHRyaWJ1dGUgdmVjNCBlbmRGYWNlTm9ybWFsQW5kSGFsZldpZHRoO1xcblxcXG5hdHRyaWJ1dGUgZmxvYXQgYV9iYXRjaElkO1xcblxcXG5cXG5cXFxudW5pZm9ybSBtYXQ0IHVfbW9kaWZpZWRNb2RlbFZpZXc7XFxuXFxcbnVuaWZvcm0gdmVjMiB1X21pbmltdW1NYXhpbXVtVmVjdG9ySGVpZ2h0cztcXG5cXFxuXFxuXFxcbnZhcnlpbmcgdmVjNCB2X3N0YXJ0UGxhbmVFQztcXG5cXFxudmFyeWluZyB2ZWM0IHZfZW5kUGxhbmVFQztcXG5cXFxudmFyeWluZyB2ZWM0IHZfcmlnaHRQbGFuZUVDO1xcblxcXG52YXJ5aW5nIGZsb2F0IHZfaGFsZldpZHRoO1xcblxcXG52YXJ5aW5nIHZlYzMgdl92b2x1bWVVcEVDO1xcblxcXG5cXG5cXFxudm9pZCBtYWluKClcXG5cXFxue1xcblxcXG4gICAgLy8gdmVydGV4IGNvcm5lciBJRHNcXG5cXFxuICAgIC8vICAgICAgICAgIDMtLS0tLS0tLS0tLTdcXG5cXFxuICAgIC8vICAgICAgICAgL3wgICBsZWZ0ICAgL3xcXG5cXFxuICAgIC8vICAgICAgICAvIHwgMSAgICAgICAvIHxcXG5cXFxuICAgIC8vICAgICAgIDItLS0tLS0tLS0tLTYgIDUgIGVuZFxcblxcXG4gICAgLy8gICAgICAgfCAvICAgICAgICAgfCAvXFxuXFxcbiAgICAvLyBzdGFydCB8LyAgcmlnaHQgICB8L1xcblxcXG4gICAgLy8gICAgICAgMC0tLS0tLS0tLS0tNFxcblxcXG4gICAgLy9cXG5cXFxuICAgIGZsb2F0IGlzRW5kID0gZmxvb3Ioc3RhcnRGYWNlTm9ybWFsQW5kVmVydGV4Q29ybmVyLncgKiAwLjI1MSk7IC8vIDAgZm9yIGZyb250LCAxIGZvciBlbmRcXG5cXFxuICAgIGZsb2F0IGlzVG9wID0gZmxvb3Ioc3RhcnRGYWNlTm9ybWFsQW5kVmVydGV4Q29ybmVyLncgKiBtaXgoMC41MSwgMC4xOSwgaXNFbmQpKTsgLy8gMCBmb3IgYm90dG9tLCAxIGZvciB0b3BcXG5cXFxuXFxuXFxcbiAgICB2ZWMzIGZvcndhcmQgPSBlbmRQb3NpdGlvbkFuZEhlaWdodC54eXogLSBzdGFydFBvc2l0aW9uQW5kSGVpZ2h0Lnh5ejtcXG5cXFxuICAgIHZlYzMgcmlnaHQgPSBub3JtYWxpemUoY3Jvc3MoZm9yd2FyZCwgc3RhcnRFbGxpcHNvaWROb3JtYWwpKTtcXG5cXFxuXFxuXFxcbiAgICB2ZWM0IHBvc2l0aW9uID0gdmVjNChzdGFydFBvc2l0aW9uQW5kSGVpZ2h0Lnh5eiwgMS4wKTtcXG5cXFxuICAgIHBvc2l0aW9uLnh5eiArPSBmb3J3YXJkICogaXNFbmQ7XFxuXFxcblxcblxcXG4gICAgdl92b2x1bWVVcEVDID0gY3ptX25vcm1hbCAqIG5vcm1hbGl6ZShjcm9zcyhyaWdodCwgZm9yd2FyZCkpO1xcblxcXG5cXG5cXFxuICAgIC8vIFB1c2ggZm9yIHZvbHVtZSBoZWlnaHRcXG5cXFxuICAgIGZsb2F0IG9mZnNldDtcXG5cXFxuICAgIHZlYzMgZWxsaXBzb2lkTm9ybWFsID0gbWl4KHN0YXJ0RWxsaXBzb2lkTm9ybWFsLCBlbmRFbGxpcHNvaWROb3JtYWwsIGlzRW5kKTtcXG5cXFxuXFxuXFxcbiAgICAvLyBvZmZzZXQgaGVpZ2h0IHRvIGNyZWF0ZSB2b2x1bWVcXG5cXFxuICAgIG9mZnNldCA9IG1peChzdGFydFBvc2l0aW9uQW5kSGVpZ2h0LncsIGVuZFBvc2l0aW9uQW5kSGVpZ2h0LncsIGlzRW5kKTtcXG5cXFxuICAgIG9mZnNldCA9IG1peCh1X21pbmltdW1NYXhpbXVtVmVjdG9ySGVpZ2h0cy55LCB1X21pbmltdW1NYXhpbXVtVmVjdG9ySGVpZ2h0cy54LCBpc1RvcCkgLSBvZmZzZXQ7XFxuXFxcbiAgICBwb3NpdGlvbi54eXogKz0gb2Zmc2V0ICogZWxsaXBzb2lkTm9ybWFsO1xcblxcXG5cXG5cXFxuICAgIC8vIG1vdmUgZnJvbSBSVEMgdG8gRUNcXG5cXFxuICAgIHBvc2l0aW9uID0gdV9tb2RpZmllZE1vZGVsVmlldyAqIHBvc2l0aW9uO1xcblxcXG4gICAgcmlnaHQgPSBjem1fbm9ybWFsICogcmlnaHQ7XFxuXFxcblxcblxcXG4gICAgLy8gUHVzaCBmb3Igd2lkdGggaW4gYSBkaXJlY3Rpb24gdGhhdCBpcyBpbiB0aGUgc3RhcnQgb3IgZW5kIHBsYW5lIGFuZCBpbiBhIHBsYW5lIHdpdGggcmlnaHRcXG5cXFxuICAgIC8vIE4gPSBub3JtYWxFQyAoXFxcInJpZ2h0LWZhY2luZ1xcXCIgZGlyZWN0aW9uIGZvciBwdXNoKVxcblxcXG4gICAgLy8gUiA9IHJpZ2h0XFxuXFxcbiAgICAvLyBwID0gYW5nbGUgYmV0d2VlbiBOIGFuZCBSXFxuXFxcbiAgICAvLyB3ID0gZGlzdGFuY2UgdG8gcHVzaCBhbG9uZyBSIGlmIFIgPT0gTlxcblxcXG4gICAgLy8gZCA9IGRpc3RhbmNlIHRvIHB1c2ggYWxvbmcgTlxcblxcXG4gICAgLy9cXG5cXFxuICAgIC8vICAgTiAgIFJcXG5cXFxuICAgIC8vICB7IFxcIHB8IH0gICAgICAqIGNvcyhwKSA9IGRvdChOLCBSKSA9IHcgLyBkXFxuXFxcbiAgICAvLyAgZFxcIFxcIHwgIHx3ICAgICogZCA9IHcgLyBkb3QoTiwgUilcXG5cXFxuICAgIC8vICAgIHsgXFx8IH1cXG5cXFxuICAgIC8vICAgICAgIG8tLS0tLS0tLS0tIHBvbHlsaW5lIHNlZ21lbnQgLS0tLT5cXG5cXFxuICAgIC8vXFxuXFxcbiAgICB2ZWMzIHNjcmF0Y2hOb3JtYWwgPSBtaXgoLXN0YXJ0RmFjZU5vcm1hbEFuZFZlcnRleENvcm5lci54eXosIGVuZEZhY2VOb3JtYWxBbmRIYWxmV2lkdGgueHl6LCBpc0VuZCk7XFxuXFxcbiAgICBzY3JhdGNoTm9ybWFsID0gY3Jvc3Moc2NyYXRjaE5vcm1hbCwgbWl4KHN0YXJ0RWxsaXBzb2lkTm9ybWFsLCBlbmRFbGxpcHNvaWROb3JtYWwsIGlzRW5kKSk7XFxuXFxcbiAgICB2ZWMzIG1pdGVyUHVzaE5vcm1hbCA9IGN6bV9ub3JtYWwgKiBub3JtYWxpemUoc2NyYXRjaE5vcm1hbCk7XFxuXFxcblxcblxcXG4gICAgb2Zmc2V0ID0gMi4wICogZW5kRmFjZU5vcm1hbEFuZEhhbGZXaWR0aC53ICogbWF4KDAuMCwgY3ptX21ldGVyc1BlclBpeGVsKHBvc2l0aW9uKSk7IC8vIG9mZnNldCA9IHdpZHRoRUNcXG5cXFxuICAgIG9mZnNldCA9IG9mZnNldCAvIGRvdChtaXRlclB1c2hOb3JtYWwsIHJpZ2h0KTtcXG5cXFxuICAgIHBvc2l0aW9uLnh5eiArPSBtaXRlclB1c2hOb3JtYWwgKiAob2Zmc2V0ICogc2lnbigwLjUgLSBtb2Qoc3RhcnRGYWNlTm9ybWFsQW5kVmVydGV4Q29ybmVyLncsIDIuMCkpKTtcXG5cXFxuXFxuXFxcbiAgICBnbF9Qb3NpdGlvbiA9IGN6bV9kZXB0aENsYW1wKGN6bV9wcm9qZWN0aW9uICogcG9zaXRpb24pO1xcblxcXG5cXG5cXFxuICAgIHBvc2l0aW9uID0gdV9tb2RpZmllZE1vZGVsVmlldyAqIHZlYzQoc3RhcnRQb3NpdGlvbkFuZEhlaWdodC54eXosIDEuMCk7XFxuXFxcbiAgICB2ZWMzIHN0YXJ0Tm9ybWFsRUMgPSBjem1fbm9ybWFsICogc3RhcnRGYWNlTm9ybWFsQW5kVmVydGV4Q29ybmVyLnh5ejtcXG5cXFxuICAgIHZfc3RhcnRQbGFuZUVDID0gdmVjNChzdGFydE5vcm1hbEVDLCAtZG90KHN0YXJ0Tm9ybWFsRUMsIHBvc2l0aW9uLnh5eikpO1xcblxcXG4gICAgdl9yaWdodFBsYW5lRUMgPSB2ZWM0KHJpZ2h0LCAtZG90KHJpZ2h0LCBwb3NpdGlvbi54eXopKTtcXG5cXFxuXFxuXFxcbiAgICBwb3NpdGlvbiA9IHVfbW9kaWZpZWRNb2RlbFZpZXcgKiB2ZWM0KGVuZFBvc2l0aW9uQW5kSGVpZ2h0Lnh5eiwgMS4wKTtcXG5cXFxuICAgIHZlYzMgZW5kTm9ybWFsRUMgPSBjem1fbm9ybWFsICogZW5kRmFjZU5vcm1hbEFuZEhhbGZXaWR0aC54eXo7XFxuXFxcbiAgICB2X2VuZFBsYW5lRUMgPSB2ZWM0KGVuZE5vcm1hbEVDLCAtZG90KGVuZE5vcm1hbEVDLCBwb3NpdGlvbi54eXopKTtcXG5cXFxuICAgIHZfaGFsZldpZHRoID0gZW5kRmFjZU5vcm1hbEFuZEhhbGZXaWR0aC53O1xcblxcXG59XFxuXFxcblwiO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///65493\n')},58678:function(__unused_webpack___webpack_module__,__webpack_exports__){eval('//This file is automatically rebuilt by the Cesium build process.\n/* harmony default export */ __webpack_exports__["Z"] = ("attribute vec4 currentPosition;\\n\\\nattribute vec4 previousPosition;\\n\\\nattribute vec4 nextPosition;\\n\\\nattribute vec2 expandAndWidth;\\n\\\nattribute float a_batchId;\\n\\\n\\n\\\nuniform mat4 u_modifiedModelView;\\n\\\n\\n\\\nvoid main()\\n\\\n{\\n\\\n    float expandDir = expandAndWidth.x;\\n\\\n    float width = abs(expandAndWidth.y) + 0.5;\\n\\\n    bool usePrev = expandAndWidth.y < 0.0;\\n\\\n\\n\\\n    vec4 p = u_modifiedModelView * currentPosition;\\n\\\n    vec4 prev = u_modifiedModelView * previousPosition;\\n\\\n    vec4 next = u_modifiedModelView * nextPosition;\\n\\\n\\n\\\n    float angle;\\n\\\n    vec4 positionWC = getPolylineWindowCoordinatesEC(p, prev, next, expandDir, width, usePrev, angle);\\n\\\n    gl_Position = czm_viewportOrthographic * positionWC;\\n\\\n}\\n\\\n");\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNTg2NzguanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQSx5REFBZSxnQ0FBZ0M7QUFDL0MsZ0NBQWdDO0FBQ2hDLDRCQUE0QjtBQUM1Qiw4QkFBOEI7QUFDOUIsMEJBQTBCO0FBQzFCO0FBQ0EsaUNBQWlDO0FBQ2pDO0FBQ0E7QUFDQSxDQUFDO0FBQ0QsdUNBQXVDO0FBQ3ZDLDhDQUE4QztBQUM5QywwQ0FBMEM7QUFDMUM7QUFDQSxtREFBbUQ7QUFDbkQsdURBQXVEO0FBQ3ZELG1EQUFtRDtBQUNuRDtBQUNBLGdCQUFnQjtBQUNoQixzR0FBc0c7QUFDdEcsd0RBQXdEO0FBQ3hELENBQUM7QUFDRCxDQUFDLEVBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly92dWUzLXdlYnBhY2s1Ly4vbm9kZV9tb2R1bGVzL2Nlc2l1bS9Tb3VyY2UvU2hhZGVycy9WZWN0b3IzRFRpbGVQb2x5bGluZXNWUy5qcz81MjI4Il0sInNvdXJjZXNDb250ZW50IjpbIi8vVGhpcyBmaWxlIGlzIGF1dG9tYXRpY2FsbHkgcmVidWlsdCBieSB0aGUgQ2VzaXVtIGJ1aWxkIHByb2Nlc3MuXG5leHBvcnQgZGVmYXVsdCBcImF0dHJpYnV0ZSB2ZWM0IGN1cnJlbnRQb3NpdGlvbjtcXG5cXFxuYXR0cmlidXRlIHZlYzQgcHJldmlvdXNQb3NpdGlvbjtcXG5cXFxuYXR0cmlidXRlIHZlYzQgbmV4dFBvc2l0aW9uO1xcblxcXG5hdHRyaWJ1dGUgdmVjMiBleHBhbmRBbmRXaWR0aDtcXG5cXFxuYXR0cmlidXRlIGZsb2F0IGFfYmF0Y2hJZDtcXG5cXFxuXFxuXFxcbnVuaWZvcm0gbWF0NCB1X21vZGlmaWVkTW9kZWxWaWV3O1xcblxcXG5cXG5cXFxudm9pZCBtYWluKClcXG5cXFxue1xcblxcXG4gICAgZmxvYXQgZXhwYW5kRGlyID0gZXhwYW5kQW5kV2lkdGgueDtcXG5cXFxuICAgIGZsb2F0IHdpZHRoID0gYWJzKGV4cGFuZEFuZFdpZHRoLnkpICsgMC41O1xcblxcXG4gICAgYm9vbCB1c2VQcmV2ID0gZXhwYW5kQW5kV2lkdGgueSA8IDAuMDtcXG5cXFxuXFxuXFxcbiAgICB2ZWM0IHAgPSB1X21vZGlmaWVkTW9kZWxWaWV3ICogY3VycmVudFBvc2l0aW9uO1xcblxcXG4gICAgdmVjNCBwcmV2ID0gdV9tb2RpZmllZE1vZGVsVmlldyAqIHByZXZpb3VzUG9zaXRpb247XFxuXFxcbiAgICB2ZWM0IG5leHQgPSB1X21vZGlmaWVkTW9kZWxWaWV3ICogbmV4dFBvc2l0aW9uO1xcblxcXG5cXG5cXFxuICAgIGZsb2F0IGFuZ2xlO1xcblxcXG4gICAgdmVjNCBwb3NpdGlvbldDID0gZ2V0UG9seWxpbmVXaW5kb3dDb29yZGluYXRlc0VDKHAsIHByZXYsIG5leHQsIGV4cGFuZERpciwgd2lkdGgsIHVzZVByZXYsIGFuZ2xlKTtcXG5cXFxuICAgIGdsX1Bvc2l0aW9uID0gY3ptX3ZpZXdwb3J0T3J0aG9ncmFwaGljICogcG9zaXRpb25XQztcXG5cXFxufVxcblxcXG5cIjtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///58678\n')},54867:function(__unused_webpack___webpack_module__,__webpack_exports__){eval('//This file is automatically rebuilt by the Cesium build process.\n/* harmony default export */ __webpack_exports__["Z"] = ("attribute vec3 position;\\n\\\nattribute float a_batchId;\\n\\\n\\n\\\nuniform mat4 u_modifiedModelViewProjection;\\n\\\n\\n\\\nvoid main()\\n\\\n{\\n\\\n    gl_Position = czm_depthClamp(u_modifiedModelViewProjection * vec4(position, 1.0));\\n\\\n}\\n\\\n");\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNTQ4NjcuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQSx5REFBZSx5QkFBeUI7QUFDeEMsMEJBQTBCO0FBQzFCO0FBQ0EsMkNBQTJDO0FBQzNDO0FBQ0E7QUFDQSxDQUFDO0FBQ0Qsc0ZBQXNGO0FBQ3RGLENBQUM7QUFDRCxDQUFDLEVBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly92dWUzLXdlYnBhY2s1Ly4vbm9kZV9tb2R1bGVzL2Nlc2l1bS9Tb3VyY2UvU2hhZGVycy9WZWN0b3JUaWxlVlMuanM/MjFkMiJdLCJzb3VyY2VzQ29udGVudCI6WyIvL1RoaXMgZmlsZSBpcyBhdXRvbWF0aWNhbGx5IHJlYnVpbHQgYnkgdGhlIENlc2l1bSBidWlsZCBwcm9jZXNzLlxuZXhwb3J0IGRlZmF1bHQgXCJhdHRyaWJ1dGUgdmVjMyBwb3NpdGlvbjtcXG5cXFxuYXR0cmlidXRlIGZsb2F0IGFfYmF0Y2hJZDtcXG5cXFxuXFxuXFxcbnVuaWZvcm0gbWF0NCB1X21vZGlmaWVkTW9kZWxWaWV3UHJvamVjdGlvbjtcXG5cXFxuXFxuXFxcbnZvaWQgbWFpbigpXFxuXFxcbntcXG5cXFxuICAgIGdsX1Bvc2l0aW9uID0gY3ptX2RlcHRoQ2xhbXAodV9tb2RpZmllZE1vZGVsVmlld1Byb2plY3Rpb24gKiB2ZWM0KHBvc2l0aW9uLCAxLjApKTtcXG5cXFxufVxcblxcXG5cIjtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///54867\n')},5821:function(__unused_webpack___webpack_module__,__webpack_exports__){eval('//This file is automatically rebuilt by the Cesium build process.\n/* harmony default export */ __webpack_exports__["Z"] = ("\\n\\\nvarying vec2 v_textureCoordinates;\\n\\\n\\n\\\nvoid main()\\n\\\n{\\n\\\n    czm_materialInput materialInput;\\n\\\n    \\n\\\n    materialInput.s = v_textureCoordinates.s;\\n\\\n    materialInput.st = v_textureCoordinates;\\n\\\n    materialInput.str = vec3(v_textureCoordinates, 0.0);\\n\\\n    materialInput.normalEC = vec3(0.0, 0.0, -1.0);\\n\\\n    \\n\\\n    czm_material material = czm_getMaterial(materialInput);\\n\\\n\\n\\\n    gl_FragColor = vec4(material.diffuse + material.emission, material.alpha);\\n\\\n}\\n\\\n");\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNTgyMS5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBLHlEQUFlO0FBQ2Ysa0NBQWtDO0FBQ2xDO0FBQ0E7QUFDQSxDQUFDO0FBQ0Qsb0NBQW9DO0FBQ3BDO0FBQ0EsNkNBQTZDO0FBQzdDLDRDQUE0QztBQUM1Qyx3REFBd0Q7QUFDeEQsa0RBQWtEO0FBQ2xEO0FBQ0EsMkRBQTJEO0FBQzNEO0FBQ0EsOEVBQThFO0FBQzlFLENBQUM7QUFDRCxDQUFDLEVBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly92dWUzLXdlYnBhY2s1Ly4vbm9kZV9tb2R1bGVzL2Nlc2l1bS9Tb3VyY2UvU2hhZGVycy9WaWV3cG9ydFF1YWRGUy5qcz82NDEzIl0sInNvdXJjZXNDb250ZW50IjpbIi8vVGhpcyBmaWxlIGlzIGF1dG9tYXRpY2FsbHkgcmVidWlsdCBieSB0aGUgQ2VzaXVtIGJ1aWxkIHByb2Nlc3MuXG5leHBvcnQgZGVmYXVsdCBcIlxcblxcXG52YXJ5aW5nIHZlYzIgdl90ZXh0dXJlQ29vcmRpbmF0ZXM7XFxuXFxcblxcblxcXG52b2lkIG1haW4oKVxcblxcXG57XFxuXFxcbiAgICBjem1fbWF0ZXJpYWxJbnB1dCBtYXRlcmlhbElucHV0O1xcblxcXG4gICAgXFxuXFxcbiAgICBtYXRlcmlhbElucHV0LnMgPSB2X3RleHR1cmVDb29yZGluYXRlcy5zO1xcblxcXG4gICAgbWF0ZXJpYWxJbnB1dC5zdCA9IHZfdGV4dHVyZUNvb3JkaW5hdGVzO1xcblxcXG4gICAgbWF0ZXJpYWxJbnB1dC5zdHIgPSB2ZWMzKHZfdGV4dHVyZUNvb3JkaW5hdGVzLCAwLjApO1xcblxcXG4gICAgbWF0ZXJpYWxJbnB1dC5ub3JtYWxFQyA9IHZlYzMoMC4wLCAwLjAsIC0xLjApO1xcblxcXG4gICAgXFxuXFxcbiAgICBjem1fbWF0ZXJpYWwgbWF0ZXJpYWwgPSBjem1fZ2V0TWF0ZXJpYWwobWF0ZXJpYWxJbnB1dCk7XFxuXFxcblxcblxcXG4gICAgZ2xfRnJhZ0NvbG9yID0gdmVjNChtYXRlcmlhbC5kaWZmdXNlICsgbWF0ZXJpYWwuZW1pc3Npb24sIG1hdGVyaWFsLmFscGhhKTtcXG5cXFxufVxcblxcXG5cIjtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///5821\n')},59629:function(__unused_webpack___webpack_module__,__webpack_exports__){eval('//This file is automatically rebuilt by the Cesium build process.\n/* harmony default export */ __webpack_exports__["Z"] = ("attribute vec4 position;\\n\\\nattribute vec2 textureCoordinates;\\n\\\n\\n\\\nvarying vec2 v_textureCoordinates;\\n\\\n\\n\\\nvoid main() \\n\\\n{\\n\\\n    gl_Position = position;\\n\\\n    v_textureCoordinates = textureCoordinates;\\n\\\n}\\n\\\n");\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNTk2MjkuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQSx5REFBZSx5QkFBeUI7QUFDeEMsa0NBQWtDO0FBQ2xDO0FBQ0Esa0NBQWtDO0FBQ2xDO0FBQ0E7QUFDQSxDQUFDO0FBQ0QsMkJBQTJCO0FBQzNCLDhDQUE4QztBQUM5QyxDQUFDO0FBQ0QsQ0FBQyxFQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdnVlMy13ZWJwYWNrNS8uL25vZGVfbW9kdWxlcy9jZXNpdW0vU291cmNlL1NoYWRlcnMvVmlld3BvcnRRdWFkVlMuanM/ZmNhMiJdLCJzb3VyY2VzQ29udGVudCI6WyIvL1RoaXMgZmlsZSBpcyBhdXRvbWF0aWNhbGx5IHJlYnVpbHQgYnkgdGhlIENlc2l1bSBidWlsZCBwcm9jZXNzLlxuZXhwb3J0IGRlZmF1bHQgXCJhdHRyaWJ1dGUgdmVjNCBwb3NpdGlvbjtcXG5cXFxuYXR0cmlidXRlIHZlYzIgdGV4dHVyZUNvb3JkaW5hdGVzO1xcblxcXG5cXG5cXFxudmFyeWluZyB2ZWMyIHZfdGV4dHVyZUNvb3JkaW5hdGVzO1xcblxcXG5cXG5cXFxudm9pZCBtYWluKCkgXFxuXFxcbntcXG5cXFxuICAgIGdsX1Bvc2l0aW9uID0gcG9zaXRpb247XFxuXFxcbiAgICB2X3RleHR1cmVDb29yZGluYXRlcyA9IHRleHR1cmVDb29yZGluYXRlcztcXG5cXFxufVxcblxcXG5cIjtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///59629\n')}}]);