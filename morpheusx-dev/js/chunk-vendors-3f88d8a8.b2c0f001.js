"use strict";(self["webpackChunkvue3_webpack5"]=self["webpackChunkvue3_webpack5"]||[]).push([[7476],{6357:function(__unused_webpack_module,__webpack_exports__,__webpack_require__){eval('/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "Z": function() { return /* binding */ MathArray; }\n/* harmony export */ });\n/* harmony import */ var _lib_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(14034);\nfunction _extendableBuiltin(cls) {\n  function ExtendableBuiltin() {\n    var instance = Reflect.construct(cls, Array.from(arguments));\n    Object.setPrototypeOf(instance, Object.getPrototypeOf(this));\n    return instance;\n  }\n\n  ExtendableBuiltin.prototype = Object.create(cls.prototype, {\n    constructor: {\n      value: cls,\n      enumerable: false,\n      writable: true,\n      configurable: true\n    }\n  });\n\n  if (Object.setPrototypeOf) {\n    Object.setPrototypeOf(ExtendableBuiltin, cls);\n  } else {\n    ExtendableBuiltin.__proto__ = cls;\n  }\n\n  return ExtendableBuiltin;\n}\n\n\nclass MathArray extends _extendableBuiltin(Array) {\n  clone() {\n    return new this.constructor().copy(this);\n  }\n\n  fromArray(array, offset = 0) {\n    for (let i = 0; i < this.ELEMENTS; ++i) {\n      this[i] = array[i + offset];\n    }\n\n    return this.check();\n  }\n\n  toArray(targetArray = [], offset = 0) {\n    for (let i = 0; i < this.ELEMENTS; ++i) {\n      targetArray[offset + i] = this[i];\n    }\n\n    return targetArray;\n  }\n\n  from(arrayOrObject) {\n    return Array.isArray(arrayOrObject) ? this.copy(arrayOrObject) : this.fromObject(arrayOrObject);\n  }\n\n  to(arrayOrObject) {\n    if (arrayOrObject === this) {\n      return this;\n    }\n\n    return (0,_lib_common__WEBPACK_IMPORTED_MODULE_0__/* .isArray */ .kJ)(arrayOrObject) ? this.toArray(arrayOrObject) : this.toObject(arrayOrObject);\n  }\n\n  toTarget(target) {\n    return target ? this.to(target) : this;\n  }\n\n  toFloat32Array() {\n    return new Float32Array(this);\n  }\n\n  toString() {\n    return this.formatString(_lib_common__WEBPACK_IMPORTED_MODULE_0__/* .config */ .vc);\n  }\n\n  formatString(opts) {\n    let string = \'\';\n\n    for (let i = 0; i < this.ELEMENTS; ++i) {\n      string += (i > 0 ? \', \' : \'\') + (0,_lib_common__WEBPACK_IMPORTED_MODULE_0__/* .formatValue */ .Bw)(this[i], opts);\n    }\n\n    return "".concat(opts.printTypes ? this.constructor.name : \'\', "[").concat(string, "]");\n  }\n\n  equals(array) {\n    if (!array || this.length !== array.length) {\n      return false;\n    }\n\n    for (let i = 0; i < this.ELEMENTS; ++i) {\n      if (!(0,_lib_common__WEBPACK_IMPORTED_MODULE_0__/* .equals */ .fS)(this[i], array[i])) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  exactEquals(array) {\n    if (!array || this.length !== array.length) {\n      return false;\n    }\n\n    for (let i = 0; i < this.ELEMENTS; ++i) {\n      if (this[i] !== array[i]) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  negate() {\n    for (let i = 0; i < this.ELEMENTS; ++i) {\n      this[i] = -this[i];\n    }\n\n    return this.check();\n  }\n\n  lerp(a, b, t) {\n    if (t === undefined) {\n      return this.lerp(this, a, b);\n    }\n\n    for (let i = 0; i < this.ELEMENTS; ++i) {\n      const ai = a[i];\n      this[i] = ai + t * (b[i] - ai);\n    }\n\n    return this.check();\n  }\n\n  min(vector) {\n    for (let i = 0; i < this.ELEMENTS; ++i) {\n      this[i] = Math.min(vector[i], this[i]);\n    }\n\n    return this.check();\n  }\n\n  max(vector) {\n    for (let i = 0; i < this.ELEMENTS; ++i) {\n      this[i] = Math.max(vector[i], this[i]);\n    }\n\n    return this.check();\n  }\n\n  clamp(minVector, maxVector) {\n    for (let i = 0; i < this.ELEMENTS; ++i) {\n      this[i] = Math.min(Math.max(this[i], minVector[i]), maxVector[i]);\n    }\n\n    return this.check();\n  }\n\n  add(...vectors) {\n    for (const vector of vectors) {\n      for (let i = 0; i < this.ELEMENTS; ++i) {\n        this[i] += vector[i];\n      }\n    }\n\n    return this.check();\n  }\n\n  subtract(...vectors) {\n    for (const vector of vectors) {\n      for (let i = 0; i < this.ELEMENTS; ++i) {\n        this[i] -= vector[i];\n      }\n    }\n\n    return this.check();\n  }\n\n  scale(scale) {\n    if (typeof scale === \'number\') {\n      for (let i = 0; i < this.ELEMENTS; ++i) {\n        this[i] *= scale;\n      }\n    } else {\n      for (let i = 0; i < this.ELEMENTS && i < scale.length; ++i) {\n        this[i] *= scale[i];\n      }\n    }\n\n    return this.check();\n  }\n\n  multiplyByScalar(scalar) {\n    for (let i = 0; i < this.ELEMENTS; ++i) {\n      this[i] *= scalar;\n    }\n\n    return this.check();\n  }\n\n  check() {\n    if (_lib_common__WEBPACK_IMPORTED_MODULE_0__/* .config.debug */ .vc.debug && !this.validate()) {\n      throw new Error("math.gl: ".concat(this.constructor.name, " some fields set to invalid numbers\'"));\n    }\n\n    return this;\n  }\n\n  validate() {\n    let valid = this.length === this.ELEMENTS;\n\n    for (let i = 0; i < this.ELEMENTS; ++i) {\n      valid = valid && Number.isFinite(this[i]);\n    }\n\n    return valid;\n  }\n\n  sub(a) {\n    return this.subtract(a);\n  }\n\n  setScalar(a) {\n    for (let i = 0; i < this.ELEMENTS; ++i) {\n      this[i] = a;\n    }\n\n    return this.check();\n  }\n\n  addScalar(a) {\n    for (let i = 0; i < this.ELEMENTS; ++i) {\n      this[i] += a;\n    }\n\n    return this.check();\n  }\n\n  subScalar(a) {\n    return this.addScalar(-a);\n  }\n\n  multiplyScalar(scalar) {\n    for (let i = 0; i < this.ELEMENTS; ++i) {\n      this[i] *= scalar;\n    }\n\n    return this.check();\n  }\n\n  divideScalar(a) {\n    return this.multiplyByScalar(1 / a);\n  }\n\n  clampScalar(min, max) {\n    for (let i = 0; i < this.ELEMENTS; ++i) {\n      this[i] = Math.min(Math.max(this[i], min), max);\n    }\n\n    return this.check();\n  }\n\n  get elements() {\n    return this;\n  }\n\n}\n//# sourceMappingURL=math-array.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNjM1Ny5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTs7QUFFd0U7QUFDekQ7QUFDZjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxvQkFBb0IsbUJBQW1CO0FBQ3ZDO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLG9CQUFvQixtQkFBbUI7QUFDdkM7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxXQUFXLDhEQUFPO0FBQ2xCOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw2QkFBNkIseURBQU07QUFDbkM7O0FBRUE7QUFDQTs7QUFFQSxvQkFBb0IsbUJBQW1CO0FBQ3ZDLHNDQUFzQyxrRUFBVztBQUNqRDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG9CQUFvQixtQkFBbUI7QUFDdkMsV0FBVyw2REFBTTtBQUNqQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxvQkFBb0IsbUJBQW1CO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxvQkFBb0IsbUJBQW1CO0FBQ3ZDO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxvQkFBb0IsbUJBQW1CO0FBQ3ZDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0Esb0JBQW9CLG1CQUFtQjtBQUN2QztBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxvQkFBb0IsbUJBQW1CO0FBQ3ZDO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLG9CQUFvQixtQkFBbUI7QUFDdkM7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxzQkFBc0IsbUJBQW1CO0FBQ3pDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxzQkFBc0IsbUJBQW1CO0FBQ3pDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxzQkFBc0IsbUJBQW1CO0FBQ3pDO0FBQ0E7QUFDQSxNQUFNO0FBQ04sc0JBQXNCLHVDQUF1QztBQUM3RDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLG9CQUFvQixtQkFBbUI7QUFDdkM7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsUUFBUSxxRUFBWTtBQUNwQjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxvQkFBb0IsbUJBQW1CO0FBQ3ZDO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxvQkFBb0IsbUJBQW1CO0FBQ3ZDO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLG9CQUFvQixtQkFBbUI7QUFDdkM7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG9CQUFvQixtQkFBbUI7QUFDdkM7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG9CQUFvQixtQkFBbUI7QUFDdkM7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdnVlMy13ZWJwYWNrNS8uL25vZGVfbW9kdWxlcy9AbWF0aC5nbC9jb3JlL2Rpc3QvZXNtL2NsYXNzZXMvYmFzZS9tYXRoLWFycmF5LmpzPzIxZWEiXSwic291cmNlc0NvbnRlbnQiOlsiZnVuY3Rpb24gX2V4dGVuZGFibGVCdWlsdGluKGNscykge1xuICBmdW5jdGlvbiBFeHRlbmRhYmxlQnVpbHRpbigpIHtcbiAgICB2YXIgaW5zdGFuY2UgPSBSZWZsZWN0LmNvbnN0cnVjdChjbHMsIEFycmF5LmZyb20oYXJndW1lbnRzKSk7XG4gICAgT2JqZWN0LnNldFByb3RvdHlwZU9mKGluc3RhbmNlLCBPYmplY3QuZ2V0UHJvdG90eXBlT2YodGhpcykpO1xuICAgIHJldHVybiBpbnN0YW5jZTtcbiAgfVxuXG4gIEV4dGVuZGFibGVCdWlsdGluLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoY2xzLnByb3RvdHlwZSwge1xuICAgIGNvbnN0cnVjdG9yOiB7XG4gICAgICB2YWx1ZTogY2xzLFxuICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH1cbiAgfSk7XG5cbiAgaWYgKE9iamVjdC5zZXRQcm90b3R5cGVPZikge1xuICAgIE9iamVjdC5zZXRQcm90b3R5cGVPZihFeHRlbmRhYmxlQnVpbHRpbiwgY2xzKTtcbiAgfSBlbHNlIHtcbiAgICBFeHRlbmRhYmxlQnVpbHRpbi5fX3Byb3RvX18gPSBjbHM7XG4gIH1cblxuICByZXR1cm4gRXh0ZW5kYWJsZUJ1aWx0aW47XG59XG5cbmltcG9ydCB7IGNvbmZpZywgZm9ybWF0VmFsdWUsIGVxdWFscywgaXNBcnJheSB9IGZyb20gJy4uLy4uL2xpYi9jb21tb24nO1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgTWF0aEFycmF5IGV4dGVuZHMgX2V4dGVuZGFibGVCdWlsdGluKEFycmF5KSB7XG4gIGNsb25lKCkge1xuICAgIHJldHVybiBuZXcgdGhpcy5jb25zdHJ1Y3RvcigpLmNvcHkodGhpcyk7XG4gIH1cblxuICBmcm9tQXJyYXkoYXJyYXksIG9mZnNldCA9IDApIHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuRUxFTUVOVFM7ICsraSkge1xuICAgICAgdGhpc1tpXSA9IGFycmF5W2kgKyBvZmZzZXRdO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLmNoZWNrKCk7XG4gIH1cblxuICB0b0FycmF5KHRhcmdldEFycmF5ID0gW10sIG9mZnNldCA9IDApIHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuRUxFTUVOVFM7ICsraSkge1xuICAgICAgdGFyZ2V0QXJyYXlbb2Zmc2V0ICsgaV0gPSB0aGlzW2ldO1xuICAgIH1cblxuICAgIHJldHVybiB0YXJnZXRBcnJheTtcbiAgfVxuXG4gIGZyb20oYXJyYXlPck9iamVjdCkge1xuICAgIHJldHVybiBBcnJheS5pc0FycmF5KGFycmF5T3JPYmplY3QpID8gdGhpcy5jb3B5KGFycmF5T3JPYmplY3QpIDogdGhpcy5mcm9tT2JqZWN0KGFycmF5T3JPYmplY3QpO1xuICB9XG5cbiAgdG8oYXJyYXlPck9iamVjdCkge1xuICAgIGlmIChhcnJheU9yT2JqZWN0ID09PSB0aGlzKSB7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICByZXR1cm4gaXNBcnJheShhcnJheU9yT2JqZWN0KSA/IHRoaXMudG9BcnJheShhcnJheU9yT2JqZWN0KSA6IHRoaXMudG9PYmplY3QoYXJyYXlPck9iamVjdCk7XG4gIH1cblxuICB0b1RhcmdldCh0YXJnZXQpIHtcbiAgICByZXR1cm4gdGFyZ2V0ID8gdGhpcy50byh0YXJnZXQpIDogdGhpcztcbiAgfVxuXG4gIHRvRmxvYXQzMkFycmF5KCkge1xuICAgIHJldHVybiBuZXcgRmxvYXQzMkFycmF5KHRoaXMpO1xuICB9XG5cbiAgdG9TdHJpbmcoKSB7XG4gICAgcmV0dXJuIHRoaXMuZm9ybWF0U3RyaW5nKGNvbmZpZyk7XG4gIH1cblxuICBmb3JtYXRTdHJpbmcob3B0cykge1xuICAgIGxldCBzdHJpbmcgPSAnJztcblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5FTEVNRU5UUzsgKytpKSB7XG4gICAgICBzdHJpbmcgKz0gKGkgPiAwID8gJywgJyA6ICcnKSArIGZvcm1hdFZhbHVlKHRoaXNbaV0sIG9wdHMpO1xuICAgIH1cblxuICAgIHJldHVybiBcIlwiLmNvbmNhdChvcHRzLnByaW50VHlwZXMgPyB0aGlzLmNvbnN0cnVjdG9yLm5hbWUgOiAnJywgXCJbXCIpLmNvbmNhdChzdHJpbmcsIFwiXVwiKTtcbiAgfVxuXG4gIGVxdWFscyhhcnJheSkge1xuICAgIGlmICghYXJyYXkgfHwgdGhpcy5sZW5ndGggIT09IGFycmF5Lmxlbmd0aCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5FTEVNRU5UUzsgKytpKSB7XG4gICAgICBpZiAoIWVxdWFscyh0aGlzW2ldLCBhcnJheVtpXSkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgZXhhY3RFcXVhbHMoYXJyYXkpIHtcbiAgICBpZiAoIWFycmF5IHx8IHRoaXMubGVuZ3RoICE9PSBhcnJheS5sZW5ndGgpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuRUxFTUVOVFM7ICsraSkge1xuICAgICAgaWYgKHRoaXNbaV0gIT09IGFycmF5W2ldKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIG5lZ2F0ZSgpIHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuRUxFTUVOVFM7ICsraSkge1xuICAgICAgdGhpc1tpXSA9IC10aGlzW2ldO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLmNoZWNrKCk7XG4gIH1cblxuICBsZXJwKGEsIGIsIHQpIHtcbiAgICBpZiAodCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gdGhpcy5sZXJwKHRoaXMsIGEsIGIpO1xuICAgIH1cblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5FTEVNRU5UUzsgKytpKSB7XG4gICAgICBjb25zdCBhaSA9IGFbaV07XG4gICAgICB0aGlzW2ldID0gYWkgKyB0ICogKGJbaV0gLSBhaSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuY2hlY2soKTtcbiAgfVxuXG4gIG1pbih2ZWN0b3IpIHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuRUxFTUVOVFM7ICsraSkge1xuICAgICAgdGhpc1tpXSA9IE1hdGgubWluKHZlY3RvcltpXSwgdGhpc1tpXSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuY2hlY2soKTtcbiAgfVxuXG4gIG1heCh2ZWN0b3IpIHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuRUxFTUVOVFM7ICsraSkge1xuICAgICAgdGhpc1tpXSA9IE1hdGgubWF4KHZlY3RvcltpXSwgdGhpc1tpXSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuY2hlY2soKTtcbiAgfVxuXG4gIGNsYW1wKG1pblZlY3RvciwgbWF4VmVjdG9yKSB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLkVMRU1FTlRTOyArK2kpIHtcbiAgICAgIHRoaXNbaV0gPSBNYXRoLm1pbihNYXRoLm1heCh0aGlzW2ldLCBtaW5WZWN0b3JbaV0pLCBtYXhWZWN0b3JbaV0pO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLmNoZWNrKCk7XG4gIH1cblxuICBhZGQoLi4udmVjdG9ycykge1xuICAgIGZvciAoY29uc3QgdmVjdG9yIG9mIHZlY3RvcnMpIHtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5FTEVNRU5UUzsgKytpKSB7XG4gICAgICAgIHRoaXNbaV0gKz0gdmVjdG9yW2ldO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0aGlzLmNoZWNrKCk7XG4gIH1cblxuICBzdWJ0cmFjdCguLi52ZWN0b3JzKSB7XG4gICAgZm9yIChjb25zdCB2ZWN0b3Igb2YgdmVjdG9ycykge1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLkVMRU1FTlRTOyArK2kpIHtcbiAgICAgICAgdGhpc1tpXSAtPSB2ZWN0b3JbaV07XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuY2hlY2soKTtcbiAgfVxuXG4gIHNjYWxlKHNjYWxlKSB7XG4gICAgaWYgKHR5cGVvZiBzY2FsZSA9PT0gJ251bWJlcicpIHtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5FTEVNRU5UUzsgKytpKSB7XG4gICAgICAgIHRoaXNbaV0gKj0gc2NhbGU7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5FTEVNRU5UUyAmJiBpIDwgc2NhbGUubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgdGhpc1tpXSAqPSBzY2FsZVtpXTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5jaGVjaygpO1xuICB9XG5cbiAgbXVsdGlwbHlCeVNjYWxhcihzY2FsYXIpIHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuRUxFTUVOVFM7ICsraSkge1xuICAgICAgdGhpc1tpXSAqPSBzY2FsYXI7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuY2hlY2soKTtcbiAgfVxuXG4gIGNoZWNrKCkge1xuICAgIGlmIChjb25maWcuZGVidWcgJiYgIXRoaXMudmFsaWRhdGUoKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwibWF0aC5nbDogXCIuY29uY2F0KHRoaXMuY29uc3RydWN0b3IubmFtZSwgXCIgc29tZSBmaWVsZHMgc2V0IHRvIGludmFsaWQgbnVtYmVycydcIikpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgdmFsaWRhdGUoKSB7XG4gICAgbGV0IHZhbGlkID0gdGhpcy5sZW5ndGggPT09IHRoaXMuRUxFTUVOVFM7XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuRUxFTUVOVFM7ICsraSkge1xuICAgICAgdmFsaWQgPSB2YWxpZCAmJiBOdW1iZXIuaXNGaW5pdGUodGhpc1tpXSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHZhbGlkO1xuICB9XG5cbiAgc3ViKGEpIHtcbiAgICByZXR1cm4gdGhpcy5zdWJ0cmFjdChhKTtcbiAgfVxuXG4gIHNldFNjYWxhcihhKSB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLkVMRU1FTlRTOyArK2kpIHtcbiAgICAgIHRoaXNbaV0gPSBhO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLmNoZWNrKCk7XG4gIH1cblxuICBhZGRTY2FsYXIoYSkge1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5FTEVNRU5UUzsgKytpKSB7XG4gICAgICB0aGlzW2ldICs9IGE7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuY2hlY2soKTtcbiAgfVxuXG4gIHN1YlNjYWxhcihhKSB7XG4gICAgcmV0dXJuIHRoaXMuYWRkU2NhbGFyKC1hKTtcbiAgfVxuXG4gIG11bHRpcGx5U2NhbGFyKHNjYWxhcikge1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5FTEVNRU5UUzsgKytpKSB7XG4gICAgICB0aGlzW2ldICo9IHNjYWxhcjtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5jaGVjaygpO1xuICB9XG5cbiAgZGl2aWRlU2NhbGFyKGEpIHtcbiAgICByZXR1cm4gdGhpcy5tdWx0aXBseUJ5U2NhbGFyKDEgLyBhKTtcbiAgfVxuXG4gIGNsYW1wU2NhbGFyKG1pbiwgbWF4KSB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLkVMRU1FTlRTOyArK2kpIHtcbiAgICAgIHRoaXNbaV0gPSBNYXRoLm1pbihNYXRoLm1heCh0aGlzW2ldLCBtaW4pLCBtYXgpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLmNoZWNrKCk7XG4gIH1cblxuICBnZXQgZWxlbWVudHMoKSB7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bWF0aC1hcnJheS5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///6357\n')},61e3:function(__unused_webpack_module,__webpack_exports__,__webpack_require__){eval("/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Z\": function() { return /* binding */ Matrix; }\n/* harmony export */ });\n/* harmony import */ var _math_array__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(6357);\n/* harmony import */ var _lib_validators__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(86281);\n/* harmony import */ var _lib_common__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(14034);\n\n\n\nclass Matrix extends _math_array__WEBPACK_IMPORTED_MODULE_0__/* [\"default\"] */ .Z {\n  toString() {\n    let string = '[';\n\n    if (_lib_common__WEBPACK_IMPORTED_MODULE_1__/* .config.printRowMajor */ .vc.printRowMajor) {\n      string += 'row-major:';\n\n      for (let row = 0; row < this.RANK; ++row) {\n        for (let col = 0; col < this.RANK; ++col) {\n          string += \" \".concat(this[col * this.RANK + row]);\n        }\n      }\n    } else {\n      string += 'column-major:';\n\n      for (let i = 0; i < this.ELEMENTS; ++i) {\n        string += \" \".concat(this[i]);\n      }\n    }\n\n    string += ']';\n    return string;\n  }\n\n  getElementIndex(row, col) {\n    return col * this.RANK + row;\n  }\n\n  getElement(row, col) {\n    return this[col * this.RANK + row];\n  }\n\n  setElement(row, col, value) {\n    this[col * this.RANK + row] = (0,_lib_validators__WEBPACK_IMPORTED_MODULE_2__/* .checkNumber */ .u5)(value);\n    return this;\n  }\n\n  getColumn(columnIndex, result = new Array(this.RANK).fill(-0)) {\n    const firstIndex = columnIndex * this.RANK;\n\n    for (let i = 0; i < this.RANK; ++i) {\n      result[i] = this[firstIndex + i];\n    }\n\n    return result;\n  }\n\n  setColumn(columnIndex, columnVector) {\n    const firstIndex = columnIndex * this.RANK;\n\n    for (let i = 0; i < this.RANK; ++i) {\n      this[firstIndex + i] = columnVector[i];\n    }\n\n    return this;\n  }\n\n}\n//# sourceMappingURL=matrix.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNjEwMDAuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQXFDO0FBQ2M7QUFDVDtBQUMzQixxQkFBcUIsNERBQVM7QUFDN0M7QUFDQTs7QUFFQSxRQUFRLHFGQUFvQjtBQUM1Qjs7QUFFQSx3QkFBd0IsaUJBQWlCO0FBQ3pDLDBCQUEwQixpQkFBaUI7QUFDM0M7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOOztBQUVBLHNCQUFzQixtQkFBbUI7QUFDekM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0Esa0NBQWtDLHNFQUFXO0FBQzdDO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxvQkFBb0IsZUFBZTtBQUNuQztBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxvQkFBb0IsZUFBZTtBQUNuQztBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3Z1ZTMtd2VicGFjazUvLi9ub2RlX21vZHVsZXMvQG1hdGguZ2wvY29yZS9kaXN0L2VzbS9jbGFzc2VzL2Jhc2UvbWF0cml4LmpzPzJiZTYiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IE1hdGhBcnJheSBmcm9tICcuL21hdGgtYXJyYXknO1xuaW1wb3J0IHsgY2hlY2tOdW1iZXIgfSBmcm9tICcuLi8uLi9saWIvdmFsaWRhdG9ycyc7XG5pbXBvcnQgeyBjb25maWcgfSBmcm9tICcuLi8uLi9saWIvY29tbW9uJztcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIE1hdHJpeCBleHRlbmRzIE1hdGhBcnJheSB7XG4gIHRvU3RyaW5nKCkge1xuICAgIGxldCBzdHJpbmcgPSAnWyc7XG5cbiAgICBpZiAoY29uZmlnLnByaW50Um93TWFqb3IpIHtcbiAgICAgIHN0cmluZyArPSAncm93LW1ham9yOic7XG5cbiAgICAgIGZvciAobGV0IHJvdyA9IDA7IHJvdyA8IHRoaXMuUkFOSzsgKytyb3cpIHtcbiAgICAgICAgZm9yIChsZXQgY29sID0gMDsgY29sIDwgdGhpcy5SQU5LOyArK2NvbCkge1xuICAgICAgICAgIHN0cmluZyArPSBcIiBcIi5jb25jYXQodGhpc1tjb2wgKiB0aGlzLlJBTksgKyByb3ddKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBzdHJpbmcgKz0gJ2NvbHVtbi1tYWpvcjonO1xuXG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuRUxFTUVOVFM7ICsraSkge1xuICAgICAgICBzdHJpbmcgKz0gXCIgXCIuY29uY2F0KHRoaXNbaV0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIHN0cmluZyArPSAnXSc7XG4gICAgcmV0dXJuIHN0cmluZztcbiAgfVxuXG4gIGdldEVsZW1lbnRJbmRleChyb3csIGNvbCkge1xuICAgIHJldHVybiBjb2wgKiB0aGlzLlJBTksgKyByb3c7XG4gIH1cblxuICBnZXRFbGVtZW50KHJvdywgY29sKSB7XG4gICAgcmV0dXJuIHRoaXNbY29sICogdGhpcy5SQU5LICsgcm93XTtcbiAgfVxuXG4gIHNldEVsZW1lbnQocm93LCBjb2wsIHZhbHVlKSB7XG4gICAgdGhpc1tjb2wgKiB0aGlzLlJBTksgKyByb3ddID0gY2hlY2tOdW1iZXIodmFsdWUpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgZ2V0Q29sdW1uKGNvbHVtbkluZGV4LCByZXN1bHQgPSBuZXcgQXJyYXkodGhpcy5SQU5LKS5maWxsKC0wKSkge1xuICAgIGNvbnN0IGZpcnN0SW5kZXggPSBjb2x1bW5JbmRleCAqIHRoaXMuUkFOSztcblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5SQU5LOyArK2kpIHtcbiAgICAgIHJlc3VsdFtpXSA9IHRoaXNbZmlyc3RJbmRleCArIGldO1xuICAgIH1cblxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICBzZXRDb2x1bW4oY29sdW1uSW5kZXgsIGNvbHVtblZlY3Rvcikge1xuICAgIGNvbnN0IGZpcnN0SW5kZXggPSBjb2x1bW5JbmRleCAqIHRoaXMuUkFOSztcblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5SQU5LOyArK2kpIHtcbiAgICAgIHRoaXNbZmlyc3RJbmRleCArIGldID0gY29sdW1uVmVjdG9yW2ldO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW1hdHJpeC5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///61000\n")},89521:function(__unused_webpack_module,__webpack_exports__,__webpack_require__){eval('/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "Z": function() { return /* binding */ Vector; }\n/* harmony export */ });\n/* harmony import */ var _math_array__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(6357);\n/* harmony import */ var _lib_validators__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(86281);\n/* harmony import */ var _lib_assert__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(50394);\n\n\n\nclass Vector extends _math_array__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .Z {\n  get x() {\n    return this[0];\n  }\n\n  set x(value) {\n    this[0] = (0,_lib_validators__WEBPACK_IMPORTED_MODULE_1__/* .checkNumber */ .u5)(value);\n  }\n\n  get y() {\n    return this[1];\n  }\n\n  set y(value) {\n    this[1] = (0,_lib_validators__WEBPACK_IMPORTED_MODULE_1__/* .checkNumber */ .u5)(value);\n  }\n\n  len() {\n    return Math.sqrt(this.lengthSquared());\n  }\n\n  magnitude() {\n    return this.len();\n  }\n\n  lengthSquared() {\n    let length = 0;\n\n    for (let i = 0; i < this.ELEMENTS; ++i) {\n      length += this[i] * this[i];\n    }\n\n    return length;\n  }\n\n  magnitudeSquared() {\n    return this.lengthSquared();\n  }\n\n  distance(mathArray) {\n    return Math.sqrt(this.distanceSquared(mathArray));\n  }\n\n  distanceSquared(mathArray) {\n    let length = 0;\n\n    for (let i = 0; i < this.ELEMENTS; ++i) {\n      const dist = this[i] - mathArray[i];\n      length += dist * dist;\n    }\n\n    return (0,_lib_validators__WEBPACK_IMPORTED_MODULE_1__/* .checkNumber */ .u5)(length);\n  }\n\n  dot(mathArray) {\n    let product = 0;\n\n    for (let i = 0; i < this.ELEMENTS; ++i) {\n      product += this[i] * mathArray[i];\n    }\n\n    return (0,_lib_validators__WEBPACK_IMPORTED_MODULE_1__/* .checkNumber */ .u5)(product);\n  }\n\n  normalize() {\n    const length = this.magnitude();\n\n    if (length !== 0) {\n      for (let i = 0; i < this.ELEMENTS; ++i) {\n        this[i] /= length;\n      }\n    }\n\n    return this.check();\n  }\n\n  multiply(...vectors) {\n    for (const vector of vectors) {\n      for (let i = 0; i < this.ELEMENTS; ++i) {\n        this[i] *= vector[i];\n      }\n    }\n\n    return this.check();\n  }\n\n  divide(...vectors) {\n    for (const vector of vectors) {\n      for (let i = 0; i < this.ELEMENTS; ++i) {\n        this[i] /= vector[i];\n      }\n    }\n\n    return this.check();\n  }\n\n  lengthSq() {\n    return this.lengthSquared();\n  }\n\n  distanceTo(vector) {\n    return this.distance(vector);\n  }\n\n  distanceToSquared(vector) {\n    return this.distanceSquared(vector);\n  }\n\n  getComponent(i) {\n    (0,_lib_assert__WEBPACK_IMPORTED_MODULE_2__/* ["default"] */ .Z)(i >= 0 && i < this.ELEMENTS, \'index is out of range\');\n    return (0,_lib_validators__WEBPACK_IMPORTED_MODULE_1__/* .checkNumber */ .u5)(this[i]);\n  }\n\n  setComponent(i, value) {\n    (0,_lib_assert__WEBPACK_IMPORTED_MODULE_2__/* ["default"] */ .Z)(i >= 0 && i < this.ELEMENTS, \'index is out of range\');\n    this[i] = value;\n    return this.check();\n  }\n\n  addVectors(a, b) {\n    return this.copy(a).add(b);\n  }\n\n  subVectors(a, b) {\n    return this.copy(a).subtract(b);\n  }\n\n  multiplyVectors(a, b) {\n    return this.copy(a).multiply(b);\n  }\n\n  addScaledVector(a, b) {\n    return this.add(new this.constructor(a).multiplyScalar(b));\n  }\n\n}\n//# sourceMappingURL=vector.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiODk1MjEuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQXFDO0FBQ2M7QUFDYjtBQUN2QixxQkFBcUIsNERBQVM7QUFDN0M7QUFDQTtBQUNBOztBQUVBO0FBQ0EsY0FBYyxzRUFBVztBQUN6Qjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxjQUFjLHNFQUFXO0FBQ3pCOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxvQkFBb0IsbUJBQW1CO0FBQ3ZDO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsb0JBQW9CLG1CQUFtQjtBQUN2QztBQUNBO0FBQ0E7O0FBRUEsV0FBVyxzRUFBVztBQUN0Qjs7QUFFQTtBQUNBOztBQUVBLG9CQUFvQixtQkFBbUI7QUFDdkM7QUFDQTs7QUFFQSxXQUFXLHNFQUFXO0FBQ3RCOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxzQkFBc0IsbUJBQW1CO0FBQ3pDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxzQkFBc0IsbUJBQW1CO0FBQ3pDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxzQkFBc0IsbUJBQW1CO0FBQ3pDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsSUFBSSxnRUFBTTtBQUNWLFdBQVcsc0VBQVc7QUFDdEI7O0FBRUE7QUFDQSxJQUFJLGdFQUFNO0FBQ1Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdnVlMy13ZWJwYWNrNS8uL25vZGVfbW9kdWxlcy9AbWF0aC5nbC9jb3JlL2Rpc3QvZXNtL2NsYXNzZXMvYmFzZS92ZWN0b3IuanM/MTQxNCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgTWF0aEFycmF5IGZyb20gJy4vbWF0aC1hcnJheSc7XG5pbXBvcnQgeyBjaGVja051bWJlciB9IGZyb20gJy4uLy4uL2xpYi92YWxpZGF0b3JzJztcbmltcG9ydCBhc3NlcnQgZnJvbSAnLi4vLi4vbGliL2Fzc2VydCc7XG5leHBvcnQgZGVmYXVsdCBjbGFzcyBWZWN0b3IgZXh0ZW5kcyBNYXRoQXJyYXkge1xuICBnZXQgeCgpIHtcbiAgICByZXR1cm4gdGhpc1swXTtcbiAgfVxuXG4gIHNldCB4KHZhbHVlKSB7XG4gICAgdGhpc1swXSA9IGNoZWNrTnVtYmVyKHZhbHVlKTtcbiAgfVxuXG4gIGdldCB5KCkge1xuICAgIHJldHVybiB0aGlzWzFdO1xuICB9XG5cbiAgc2V0IHkodmFsdWUpIHtcbiAgICB0aGlzWzFdID0gY2hlY2tOdW1iZXIodmFsdWUpO1xuICB9XG5cbiAgbGVuKCkge1xuICAgIHJldHVybiBNYXRoLnNxcnQodGhpcy5sZW5ndGhTcXVhcmVkKCkpO1xuICB9XG5cbiAgbWFnbml0dWRlKCkge1xuICAgIHJldHVybiB0aGlzLmxlbigpO1xuICB9XG5cbiAgbGVuZ3RoU3F1YXJlZCgpIHtcbiAgICBsZXQgbGVuZ3RoID0gMDtcblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5FTEVNRU5UUzsgKytpKSB7XG4gICAgICBsZW5ndGggKz0gdGhpc1tpXSAqIHRoaXNbaV07XG4gICAgfVxuXG4gICAgcmV0dXJuIGxlbmd0aDtcbiAgfVxuXG4gIG1hZ25pdHVkZVNxdWFyZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMubGVuZ3RoU3F1YXJlZCgpO1xuICB9XG5cbiAgZGlzdGFuY2UobWF0aEFycmF5KSB7XG4gICAgcmV0dXJuIE1hdGguc3FydCh0aGlzLmRpc3RhbmNlU3F1YXJlZChtYXRoQXJyYXkpKTtcbiAgfVxuXG4gIGRpc3RhbmNlU3F1YXJlZChtYXRoQXJyYXkpIHtcbiAgICBsZXQgbGVuZ3RoID0gMDtcblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5FTEVNRU5UUzsgKytpKSB7XG4gICAgICBjb25zdCBkaXN0ID0gdGhpc1tpXSAtIG1hdGhBcnJheVtpXTtcbiAgICAgIGxlbmd0aCArPSBkaXN0ICogZGlzdDtcbiAgICB9XG5cbiAgICByZXR1cm4gY2hlY2tOdW1iZXIobGVuZ3RoKTtcbiAgfVxuXG4gIGRvdChtYXRoQXJyYXkpIHtcbiAgICBsZXQgcHJvZHVjdCA9IDA7XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuRUxFTUVOVFM7ICsraSkge1xuICAgICAgcHJvZHVjdCArPSB0aGlzW2ldICogbWF0aEFycmF5W2ldO1xuICAgIH1cblxuICAgIHJldHVybiBjaGVja051bWJlcihwcm9kdWN0KTtcbiAgfVxuXG4gIG5vcm1hbGl6ZSgpIHtcbiAgICBjb25zdCBsZW5ndGggPSB0aGlzLm1hZ25pdHVkZSgpO1xuXG4gICAgaWYgKGxlbmd0aCAhPT0gMCkge1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLkVMRU1FTlRTOyArK2kpIHtcbiAgICAgICAgdGhpc1tpXSAvPSBsZW5ndGg7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuY2hlY2soKTtcbiAgfVxuXG4gIG11bHRpcGx5KC4uLnZlY3RvcnMpIHtcbiAgICBmb3IgKGNvbnN0IHZlY3RvciBvZiB2ZWN0b3JzKSB7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuRUxFTUVOVFM7ICsraSkge1xuICAgICAgICB0aGlzW2ldICo9IHZlY3RvcltpXTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5jaGVjaygpO1xuICB9XG5cbiAgZGl2aWRlKC4uLnZlY3RvcnMpIHtcbiAgICBmb3IgKGNvbnN0IHZlY3RvciBvZiB2ZWN0b3JzKSB7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuRUxFTUVOVFM7ICsraSkge1xuICAgICAgICB0aGlzW2ldIC89IHZlY3RvcltpXTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5jaGVjaygpO1xuICB9XG5cbiAgbGVuZ3RoU3EoKSB7XG4gICAgcmV0dXJuIHRoaXMubGVuZ3RoU3F1YXJlZCgpO1xuICB9XG5cbiAgZGlzdGFuY2VUbyh2ZWN0b3IpIHtcbiAgICByZXR1cm4gdGhpcy5kaXN0YW5jZSh2ZWN0b3IpO1xuICB9XG5cbiAgZGlzdGFuY2VUb1NxdWFyZWQodmVjdG9yKSB7XG4gICAgcmV0dXJuIHRoaXMuZGlzdGFuY2VTcXVhcmVkKHZlY3Rvcik7XG4gIH1cblxuICBnZXRDb21wb25lbnQoaSkge1xuICAgIGFzc2VydChpID49IDAgJiYgaSA8IHRoaXMuRUxFTUVOVFMsICdpbmRleCBpcyBvdXQgb2YgcmFuZ2UnKTtcbiAgICByZXR1cm4gY2hlY2tOdW1iZXIodGhpc1tpXSk7XG4gIH1cblxuICBzZXRDb21wb25lbnQoaSwgdmFsdWUpIHtcbiAgICBhc3NlcnQoaSA+PSAwICYmIGkgPCB0aGlzLkVMRU1FTlRTLCAnaW5kZXggaXMgb3V0IG9mIHJhbmdlJyk7XG4gICAgdGhpc1tpXSA9IHZhbHVlO1xuICAgIHJldHVybiB0aGlzLmNoZWNrKCk7XG4gIH1cblxuICBhZGRWZWN0b3JzKGEsIGIpIHtcbiAgICByZXR1cm4gdGhpcy5jb3B5KGEpLmFkZChiKTtcbiAgfVxuXG4gIHN1YlZlY3RvcnMoYSwgYikge1xuICAgIHJldHVybiB0aGlzLmNvcHkoYSkuc3VidHJhY3QoYik7XG4gIH1cblxuICBtdWx0aXBseVZlY3RvcnMoYSwgYikge1xuICAgIHJldHVybiB0aGlzLmNvcHkoYSkubXVsdGlwbHkoYik7XG4gIH1cblxuICBhZGRTY2FsZWRWZWN0b3IoYSwgYikge1xuICAgIHJldHVybiB0aGlzLmFkZChuZXcgdGhpcy5jb25zdHJ1Y3RvcihhKS5tdWx0aXBseVNjYWxhcihiKSk7XG4gIH1cblxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dmVjdG9yLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///89521\n')},80540:function(__unused_webpack_module,__webpack_exports__,__webpack_require__){eval('/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "Z": function() { return /* binding */ Matrix3; }\n/* harmony export */ });\n/* harmony import */ var _base_matrix__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(61000);\n/* harmony import */ var _lib_validators__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(86281);\n/* harmony import */ var _lib_gl_matrix_extras__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(1031);\n/* harmony import */ var gl_matrix_mat3__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(35600);\n/* harmony import */ var gl_matrix_vec2__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(31437);\n/* harmony import */ var gl_matrix_vec3__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(77160);\n\n\n\n\n\n\nvar INDICES;\n\n(function (INDICES) {\n  INDICES[INDICES["COL0ROW0"] = 0] = "COL0ROW0";\n  INDICES[INDICES["COL0ROW1"] = 1] = "COL0ROW1";\n  INDICES[INDICES["COL0ROW2"] = 2] = "COL0ROW2";\n  INDICES[INDICES["COL1ROW0"] = 3] = "COL1ROW0";\n  INDICES[INDICES["COL1ROW1"] = 4] = "COL1ROW1";\n  INDICES[INDICES["COL1ROW2"] = 5] = "COL1ROW2";\n  INDICES[INDICES["COL2ROW0"] = 6] = "COL2ROW0";\n  INDICES[INDICES["COL2ROW1"] = 7] = "COL2ROW1";\n  INDICES[INDICES["COL2ROW2"] = 8] = "COL2ROW2";\n})(INDICES || (INDICES = {}));\n\nconst IDENTITY_MATRIX = Object.freeze([1, 0, 0, 0, 1, 0, 0, 0, 1]);\nclass Matrix3 extends _base_matrix__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .Z {\n  static get IDENTITY() {\n    return getIdentityMatrix();\n  }\n\n  static get ZERO() {\n    return getZeroMatrix();\n  }\n\n  get ELEMENTS() {\n    return 9;\n  }\n\n  get RANK() {\n    return 3;\n  }\n\n  get INDICES() {\n    return INDICES;\n  }\n\n  constructor(array, ...args) {\n    super(-0, -0, -0, -0, -0, -0, -0, -0, -0);\n\n    if (arguments.length === 1 && Array.isArray(array)) {\n      this.copy(array);\n    } else if (args.length > 0) {\n      this.copy([array, ...args]);\n    } else {\n      this.identity();\n    }\n  }\n\n  copy(array) {\n    this[0] = array[0];\n    this[1] = array[1];\n    this[2] = array[2];\n    this[3] = array[3];\n    this[4] = array[4];\n    this[5] = array[5];\n    this[6] = array[6];\n    this[7] = array[7];\n    this[8] = array[8];\n    return this.check();\n  }\n\n  identity() {\n    return this.copy(IDENTITY_MATRIX);\n  }\n\n  fromObject(object) {\n    return this.check();\n  }\n\n  fromQuaternion(q) {\n    gl_matrix_mat3__WEBPACK_IMPORTED_MODULE_1__/* .fromQuat */ .en(this, q);\n    return this.check();\n  }\n\n  set(m00, m10, m20, m01, m11, m21, m02, m12, m22) {\n    this[0] = m00;\n    this[1] = m10;\n    this[2] = m20;\n    this[3] = m01;\n    this[4] = m11;\n    this[5] = m21;\n    this[6] = m02;\n    this[7] = m12;\n    this[8] = m22;\n    return this.check();\n  }\n\n  setRowMajor(m00, m01, m02, m10, m11, m12, m20, m21, m22) {\n    this[0] = m00;\n    this[1] = m10;\n    this[2] = m20;\n    this[3] = m01;\n    this[4] = m11;\n    this[5] = m21;\n    this[6] = m02;\n    this[7] = m12;\n    this[8] = m22;\n    return this.check();\n  }\n\n  determinant() {\n    return gl_matrix_mat3__WEBPACK_IMPORTED_MODULE_1__/* .determinant */ .GH(this);\n  }\n\n  transpose() {\n    gl_matrix_mat3__WEBPACK_IMPORTED_MODULE_1__/* .transpose */ .p4(this, this);\n    return this.check();\n  }\n\n  invert() {\n    gl_matrix_mat3__WEBPACK_IMPORTED_MODULE_1__/* .invert */ .U_(this, this);\n    return this.check();\n  }\n\n  multiplyLeft(a) {\n    gl_matrix_mat3__WEBPACK_IMPORTED_MODULE_1__/* .multiply */ .Jp(this, a, this);\n    return this.check();\n  }\n\n  multiplyRight(a) {\n    gl_matrix_mat3__WEBPACK_IMPORTED_MODULE_1__/* .multiply */ .Jp(this, this, a);\n    return this.check();\n  }\n\n  rotate(radians) {\n    gl_matrix_mat3__WEBPACK_IMPORTED_MODULE_1__/* .rotate */ .U1(this, this, radians);\n    return this.check();\n  }\n\n  scale(factor) {\n    if (Array.isArray(factor)) {\n      gl_matrix_mat3__WEBPACK_IMPORTED_MODULE_1__/* .scale */ .bA(this, this, factor);\n    } else {\n      gl_matrix_mat3__WEBPACK_IMPORTED_MODULE_1__/* .scale */ .bA(this, this, [factor, factor]);\n    }\n\n    return this.check();\n  }\n\n  translate(vec) {\n    gl_matrix_mat3__WEBPACK_IMPORTED_MODULE_1__/* .translate */ .Iu(this, this, vec);\n    return this.check();\n  }\n\n  transform(vector, result) {\n    let out;\n\n    switch (vector.length) {\n      case 2:\n        out = gl_matrix_vec2__WEBPACK_IMPORTED_MODULE_2__/* .transformMat3 */ .kK(result || [-0, -0], vector, this);\n        break;\n\n      case 3:\n        out = gl_matrix_vec3__WEBPACK_IMPORTED_MODULE_3__/* .transformMat3 */ .kK(result || [-0, -0, -0], vector, this);\n        break;\n\n      case 4:\n        out = (0,_lib_gl_matrix_extras__WEBPACK_IMPORTED_MODULE_4__/* .vec4_transformMat3 */ ._x)(result || [-0, -0, -0, -0], vector, this);\n        break;\n\n      default:\n        throw new Error(\'Illegal vector\');\n    }\n\n    (0,_lib_validators__WEBPACK_IMPORTED_MODULE_5__/* .checkVector */ .IL)(out, vector.length);\n    return out;\n  }\n\n  transformVector(vector, result) {\n    return this.transform(vector, result);\n  }\n\n  transformVector2(vector, result) {\n    return this.transform(vector, result);\n  }\n\n  transformVector3(vector, result) {\n    return this.transform(vector, result);\n  }\n\n}\nlet ZERO_MATRIX3;\nlet IDENTITY_MATRIX3;\n\nfunction getZeroMatrix() {\n  if (!ZERO_MATRIX3) {\n    ZERO_MATRIX3 = new Matrix3([0, 0, 0, 0, 0, 0, 0, 0, 0]);\n    Object.freeze(ZERO_MATRIX3);\n  }\n\n  return ZERO_MATRIX3;\n}\n\nfunction getIdentityMatrix() {\n  if (!IDENTITY_MATRIX3) {\n    IDENTITY_MATRIX3 = new Matrix3();\n    Object.freeze(IDENTITY_MATRIX3);\n  }\n\n  return IDENTITY_MATRIX3;\n}\n//# sourceMappingURL=matrix3.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiODA1NDAuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBQW1DO0FBQ2E7QUFDYTtBQUN0QjtBQUNBO0FBQ0E7QUFDdkM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLDBCQUEwQjs7QUFFM0I7QUFDZSxzQkFBc0IsNkRBQU07QUFDM0M7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsSUFBSSw4REFBYTtBQUNqQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxXQUFXLGlFQUFnQjtBQUMzQjs7QUFFQTtBQUNBLElBQUksK0RBQWM7QUFDbEI7QUFDQTs7QUFFQTtBQUNBLElBQUksNERBQVc7QUFDZjtBQUNBOztBQUVBO0FBQ0EsSUFBSSw4REFBYTtBQUNqQjtBQUNBOztBQUVBO0FBQ0EsSUFBSSw4REFBYTtBQUNqQjtBQUNBOztBQUVBO0FBQ0EsSUFBSSw0REFBVztBQUNmO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU0sMkRBQVU7QUFDaEIsTUFBTTtBQUNOLE1BQU0sMkRBQVU7QUFDaEI7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLElBQUksK0RBQWM7QUFDbEI7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxjQUFjLG1FQUFrQjtBQUNoQzs7QUFFQTtBQUNBLGNBQWMsbUVBQWtCO0FBQ2hDOztBQUVBO0FBQ0EsY0FBYyxtRkFBa0I7QUFDaEM7O0FBRUE7QUFDQTtBQUNBOztBQUVBLElBQUksc0VBQVc7QUFDZjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly92dWUzLXdlYnBhY2s1Ly4vbm9kZV9tb2R1bGVzL0BtYXRoLmdsL2NvcmUvZGlzdC9lc20vY2xhc3Nlcy9tYXRyaXgzLmpzPzdmNGQiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IE1hdHJpeCBmcm9tICcuL2Jhc2UvbWF0cml4JztcbmltcG9ydCB7IGNoZWNrVmVjdG9yIH0gZnJvbSAnLi4vbGliL3ZhbGlkYXRvcnMnO1xuaW1wb3J0IHsgdmVjNF90cmFuc2Zvcm1NYXQzIH0gZnJvbSAnLi4vbGliL2dsLW1hdHJpeC1leHRyYXMnO1xuaW1wb3J0ICogYXMgbWF0MyBmcm9tICdnbC1tYXRyaXgvbWF0Myc7XG5pbXBvcnQgKiBhcyB2ZWMyIGZyb20gJ2dsLW1hdHJpeC92ZWMyJztcbmltcG9ydCAqIGFzIHZlYzMgZnJvbSAnZ2wtbWF0cml4L3ZlYzMnO1xudmFyIElORElDRVM7XG5cbihmdW5jdGlvbiAoSU5ESUNFUykge1xuICBJTkRJQ0VTW0lORElDRVNbXCJDT0wwUk9XMFwiXSA9IDBdID0gXCJDT0wwUk9XMFwiO1xuICBJTkRJQ0VTW0lORElDRVNbXCJDT0wwUk9XMVwiXSA9IDFdID0gXCJDT0wwUk9XMVwiO1xuICBJTkRJQ0VTW0lORElDRVNbXCJDT0wwUk9XMlwiXSA9IDJdID0gXCJDT0wwUk9XMlwiO1xuICBJTkRJQ0VTW0lORElDRVNbXCJDT0wxUk9XMFwiXSA9IDNdID0gXCJDT0wxUk9XMFwiO1xuICBJTkRJQ0VTW0lORElDRVNbXCJDT0wxUk9XMVwiXSA9IDRdID0gXCJDT0wxUk9XMVwiO1xuICBJTkRJQ0VTW0lORElDRVNbXCJDT0wxUk9XMlwiXSA9IDVdID0gXCJDT0wxUk9XMlwiO1xuICBJTkRJQ0VTW0lORElDRVNbXCJDT0wyUk9XMFwiXSA9IDZdID0gXCJDT0wyUk9XMFwiO1xuICBJTkRJQ0VTW0lORElDRVNbXCJDT0wyUk9XMVwiXSA9IDddID0gXCJDT0wyUk9XMVwiO1xuICBJTkRJQ0VTW0lORElDRVNbXCJDT0wyUk9XMlwiXSA9IDhdID0gXCJDT0wyUk9XMlwiO1xufSkoSU5ESUNFUyB8fCAoSU5ESUNFUyA9IHt9KSk7XG5cbmNvbnN0IElERU5USVRZX01BVFJJWCA9IE9iamVjdC5mcmVlemUoWzEsIDAsIDAsIDAsIDEsIDAsIDAsIDAsIDFdKTtcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIE1hdHJpeDMgZXh0ZW5kcyBNYXRyaXgge1xuICBzdGF0aWMgZ2V0IElERU5USVRZKCkge1xuICAgIHJldHVybiBnZXRJZGVudGl0eU1hdHJpeCgpO1xuICB9XG5cbiAgc3RhdGljIGdldCBaRVJPKCkge1xuICAgIHJldHVybiBnZXRaZXJvTWF0cml4KCk7XG4gIH1cblxuICBnZXQgRUxFTUVOVFMoKSB7XG4gICAgcmV0dXJuIDk7XG4gIH1cblxuICBnZXQgUkFOSygpIHtcbiAgICByZXR1cm4gMztcbiAgfVxuXG4gIGdldCBJTkRJQ0VTKCkge1xuICAgIHJldHVybiBJTkRJQ0VTO1xuICB9XG5cbiAgY29uc3RydWN0b3IoYXJyYXksIC4uLmFyZ3MpIHtcbiAgICBzdXBlcigtMCwgLTAsIC0wLCAtMCwgLTAsIC0wLCAtMCwgLTAsIC0wKTtcblxuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxICYmIEFycmF5LmlzQXJyYXkoYXJyYXkpKSB7XG4gICAgICB0aGlzLmNvcHkoYXJyYXkpO1xuICAgIH0gZWxzZSBpZiAoYXJncy5sZW5ndGggPiAwKSB7XG4gICAgICB0aGlzLmNvcHkoW2FycmF5LCAuLi5hcmdzXSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuaWRlbnRpdHkoKTtcbiAgICB9XG4gIH1cblxuICBjb3B5KGFycmF5KSB7XG4gICAgdGhpc1swXSA9IGFycmF5WzBdO1xuICAgIHRoaXNbMV0gPSBhcnJheVsxXTtcbiAgICB0aGlzWzJdID0gYXJyYXlbMl07XG4gICAgdGhpc1szXSA9IGFycmF5WzNdO1xuICAgIHRoaXNbNF0gPSBhcnJheVs0XTtcbiAgICB0aGlzWzVdID0gYXJyYXlbNV07XG4gICAgdGhpc1s2XSA9IGFycmF5WzZdO1xuICAgIHRoaXNbN10gPSBhcnJheVs3XTtcbiAgICB0aGlzWzhdID0gYXJyYXlbOF07XG4gICAgcmV0dXJuIHRoaXMuY2hlY2soKTtcbiAgfVxuXG4gIGlkZW50aXR5KCkge1xuICAgIHJldHVybiB0aGlzLmNvcHkoSURFTlRJVFlfTUFUUklYKTtcbiAgfVxuXG4gIGZyb21PYmplY3Qob2JqZWN0KSB7XG4gICAgcmV0dXJuIHRoaXMuY2hlY2soKTtcbiAgfVxuXG4gIGZyb21RdWF0ZXJuaW9uKHEpIHtcbiAgICBtYXQzLmZyb21RdWF0KHRoaXMsIHEpO1xuICAgIHJldHVybiB0aGlzLmNoZWNrKCk7XG4gIH1cblxuICBzZXQobTAwLCBtMTAsIG0yMCwgbTAxLCBtMTEsIG0yMSwgbTAyLCBtMTIsIG0yMikge1xuICAgIHRoaXNbMF0gPSBtMDA7XG4gICAgdGhpc1sxXSA9IG0xMDtcbiAgICB0aGlzWzJdID0gbTIwO1xuICAgIHRoaXNbM10gPSBtMDE7XG4gICAgdGhpc1s0XSA9IG0xMTtcbiAgICB0aGlzWzVdID0gbTIxO1xuICAgIHRoaXNbNl0gPSBtMDI7XG4gICAgdGhpc1s3XSA9IG0xMjtcbiAgICB0aGlzWzhdID0gbTIyO1xuICAgIHJldHVybiB0aGlzLmNoZWNrKCk7XG4gIH1cblxuICBzZXRSb3dNYWpvcihtMDAsIG0wMSwgbTAyLCBtMTAsIG0xMSwgbTEyLCBtMjAsIG0yMSwgbTIyKSB7XG4gICAgdGhpc1swXSA9IG0wMDtcbiAgICB0aGlzWzFdID0gbTEwO1xuICAgIHRoaXNbMl0gPSBtMjA7XG4gICAgdGhpc1szXSA9IG0wMTtcbiAgICB0aGlzWzRdID0gbTExO1xuICAgIHRoaXNbNV0gPSBtMjE7XG4gICAgdGhpc1s2XSA9IG0wMjtcbiAgICB0aGlzWzddID0gbTEyO1xuICAgIHRoaXNbOF0gPSBtMjI7XG4gICAgcmV0dXJuIHRoaXMuY2hlY2soKTtcbiAgfVxuXG4gIGRldGVybWluYW50KCkge1xuICAgIHJldHVybiBtYXQzLmRldGVybWluYW50KHRoaXMpO1xuICB9XG5cbiAgdHJhbnNwb3NlKCkge1xuICAgIG1hdDMudHJhbnNwb3NlKHRoaXMsIHRoaXMpO1xuICAgIHJldHVybiB0aGlzLmNoZWNrKCk7XG4gIH1cblxuICBpbnZlcnQoKSB7XG4gICAgbWF0My5pbnZlcnQodGhpcywgdGhpcyk7XG4gICAgcmV0dXJuIHRoaXMuY2hlY2soKTtcbiAgfVxuXG4gIG11bHRpcGx5TGVmdChhKSB7XG4gICAgbWF0My5tdWx0aXBseSh0aGlzLCBhLCB0aGlzKTtcbiAgICByZXR1cm4gdGhpcy5jaGVjaygpO1xuICB9XG5cbiAgbXVsdGlwbHlSaWdodChhKSB7XG4gICAgbWF0My5tdWx0aXBseSh0aGlzLCB0aGlzLCBhKTtcbiAgICByZXR1cm4gdGhpcy5jaGVjaygpO1xuICB9XG5cbiAgcm90YXRlKHJhZGlhbnMpIHtcbiAgICBtYXQzLnJvdGF0ZSh0aGlzLCB0aGlzLCByYWRpYW5zKTtcbiAgICByZXR1cm4gdGhpcy5jaGVjaygpO1xuICB9XG5cbiAgc2NhbGUoZmFjdG9yKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoZmFjdG9yKSkge1xuICAgICAgbWF0My5zY2FsZSh0aGlzLCB0aGlzLCBmYWN0b3IpO1xuICAgIH0gZWxzZSB7XG4gICAgICBtYXQzLnNjYWxlKHRoaXMsIHRoaXMsIFtmYWN0b3IsIGZhY3Rvcl0pO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLmNoZWNrKCk7XG4gIH1cblxuICB0cmFuc2xhdGUodmVjKSB7XG4gICAgbWF0My50cmFuc2xhdGUodGhpcywgdGhpcywgdmVjKTtcbiAgICByZXR1cm4gdGhpcy5jaGVjaygpO1xuICB9XG5cbiAgdHJhbnNmb3JtKHZlY3RvciwgcmVzdWx0KSB7XG4gICAgbGV0IG91dDtcblxuICAgIHN3aXRjaCAodmVjdG9yLmxlbmd0aCkge1xuICAgICAgY2FzZSAyOlxuICAgICAgICBvdXQgPSB2ZWMyLnRyYW5zZm9ybU1hdDMocmVzdWx0IHx8IFstMCwgLTBdLCB2ZWN0b3IsIHRoaXMpO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSAzOlxuICAgICAgICBvdXQgPSB2ZWMzLnRyYW5zZm9ybU1hdDMocmVzdWx0IHx8IFstMCwgLTAsIC0wXSwgdmVjdG9yLCB0aGlzKTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgNDpcbiAgICAgICAgb3V0ID0gdmVjNF90cmFuc2Zvcm1NYXQzKHJlc3VsdCB8fCBbLTAsIC0wLCAtMCwgLTBdLCB2ZWN0b3IsIHRoaXMpO1xuICAgICAgICBicmVhaztcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbGxlZ2FsIHZlY3RvcicpO1xuICAgIH1cblxuICAgIGNoZWNrVmVjdG9yKG91dCwgdmVjdG9yLmxlbmd0aCk7XG4gICAgcmV0dXJuIG91dDtcbiAgfVxuXG4gIHRyYW5zZm9ybVZlY3Rvcih2ZWN0b3IsIHJlc3VsdCkge1xuICAgIHJldHVybiB0aGlzLnRyYW5zZm9ybSh2ZWN0b3IsIHJlc3VsdCk7XG4gIH1cblxuICB0cmFuc2Zvcm1WZWN0b3IyKHZlY3RvciwgcmVzdWx0KSB7XG4gICAgcmV0dXJuIHRoaXMudHJhbnNmb3JtKHZlY3RvciwgcmVzdWx0KTtcbiAgfVxuXG4gIHRyYW5zZm9ybVZlY3RvcjModmVjdG9yLCByZXN1bHQpIHtcbiAgICByZXR1cm4gdGhpcy50cmFuc2Zvcm0odmVjdG9yLCByZXN1bHQpO1xuICB9XG5cbn1cbmxldCBaRVJPX01BVFJJWDM7XG5sZXQgSURFTlRJVFlfTUFUUklYMztcblxuZnVuY3Rpb24gZ2V0WmVyb01hdHJpeCgpIHtcbiAgaWYgKCFaRVJPX01BVFJJWDMpIHtcbiAgICBaRVJPX01BVFJJWDMgPSBuZXcgTWF0cml4MyhbMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMF0pO1xuICAgIE9iamVjdC5mcmVlemUoWkVST19NQVRSSVgzKTtcbiAgfVxuXG4gIHJldHVybiBaRVJPX01BVFJJWDM7XG59XG5cbmZ1bmN0aW9uIGdldElkZW50aXR5TWF0cml4KCkge1xuICBpZiAoIUlERU5USVRZX01BVFJJWDMpIHtcbiAgICBJREVOVElUWV9NQVRSSVgzID0gbmV3IE1hdHJpeDMoKTtcbiAgICBPYmplY3QuZnJlZXplKElERU5USVRZX01BVFJJWDMpO1xuICB9XG5cbiAgcmV0dXJuIElERU5USVRZX01BVFJJWDM7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1tYXRyaXgzLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///80540\n')},85451:function(__unused_webpack_module,__webpack_exports__,__webpack_require__){eval('/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "Z": function() { return /* binding */ Matrix4; }\n/* harmony export */ });\n/* harmony import */ var _base_matrix__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(61000);\n/* harmony import */ var _lib_validators__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(86281);\n/* harmony import */ var _lib_gl_matrix_extras__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(1031);\n/* harmony import */ var gl_matrix_mat4__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(85975);\n/* harmony import */ var gl_matrix_vec2__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(31437);\n/* harmony import */ var gl_matrix_vec3__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(77160);\n/* harmony import */ var gl_matrix_vec4__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(98333);\n\n\n\n\n\n\n\nvar INDICES;\n\n(function (INDICES) {\n  INDICES[INDICES["COL0ROW0"] = 0] = "COL0ROW0";\n  INDICES[INDICES["COL0ROW1"] = 1] = "COL0ROW1";\n  INDICES[INDICES["COL0ROW2"] = 2] = "COL0ROW2";\n  INDICES[INDICES["COL0ROW3"] = 3] = "COL0ROW3";\n  INDICES[INDICES["COL1ROW0"] = 4] = "COL1ROW0";\n  INDICES[INDICES["COL1ROW1"] = 5] = "COL1ROW1";\n  INDICES[INDICES["COL1ROW2"] = 6] = "COL1ROW2";\n  INDICES[INDICES["COL1ROW3"] = 7] = "COL1ROW3";\n  INDICES[INDICES["COL2ROW0"] = 8] = "COL2ROW0";\n  INDICES[INDICES["COL2ROW1"] = 9] = "COL2ROW1";\n  INDICES[INDICES["COL2ROW2"] = 10] = "COL2ROW2";\n  INDICES[INDICES["COL2ROW3"] = 11] = "COL2ROW3";\n  INDICES[INDICES["COL3ROW0"] = 12] = "COL3ROW0";\n  INDICES[INDICES["COL3ROW1"] = 13] = "COL3ROW1";\n  INDICES[INDICES["COL3ROW2"] = 14] = "COL3ROW2";\n  INDICES[INDICES["COL3ROW3"] = 15] = "COL3ROW3";\n})(INDICES || (INDICES = {}));\n\nconst DEFAULT_FOVY = 45 * Math.PI / 180;\nconst DEFAULT_ASPECT = 1;\nconst DEFAULT_NEAR = 0.1;\nconst DEFAULT_FAR = 500;\nconst IDENTITY_MATRIX = Object.freeze([1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]);\nclass Matrix4 extends _base_matrix__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .Z {\n  static get IDENTITY() {\n    return getIdentityMatrix();\n  }\n\n  static get ZERO() {\n    return getZeroMatrix();\n  }\n\n  get ELEMENTS() {\n    return 16;\n  }\n\n  get RANK() {\n    return 4;\n  }\n\n  get INDICES() {\n    return INDICES;\n  }\n\n  constructor(array) {\n    super(-0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0);\n\n    if (arguments.length === 1 && Array.isArray(array)) {\n      this.copy(array);\n    } else {\n      this.identity();\n    }\n  }\n\n  copy(array) {\n    this[0] = array[0];\n    this[1] = array[1];\n    this[2] = array[2];\n    this[3] = array[3];\n    this[4] = array[4];\n    this[5] = array[5];\n    this[6] = array[6];\n    this[7] = array[7];\n    this[8] = array[8];\n    this[9] = array[9];\n    this[10] = array[10];\n    this[11] = array[11];\n    this[12] = array[12];\n    this[13] = array[13];\n    this[14] = array[14];\n    this[15] = array[15];\n    return this.check();\n  }\n\n  set(m00, m10, m20, m30, m01, m11, m21, m31, m02, m12, m22, m32, m03, m13, m23, m33) {\n    this[0] = m00;\n    this[1] = m10;\n    this[2] = m20;\n    this[3] = m30;\n    this[4] = m01;\n    this[5] = m11;\n    this[6] = m21;\n    this[7] = m31;\n    this[8] = m02;\n    this[9] = m12;\n    this[10] = m22;\n    this[11] = m32;\n    this[12] = m03;\n    this[13] = m13;\n    this[14] = m23;\n    this[15] = m33;\n    return this.check();\n  }\n\n  setRowMajor(m00, m01, m02, m03, m10, m11, m12, m13, m20, m21, m22, m23, m30, m31, m32, m33) {\n    this[0] = m00;\n    this[1] = m10;\n    this[2] = m20;\n    this[3] = m30;\n    this[4] = m01;\n    this[5] = m11;\n    this[6] = m21;\n    this[7] = m31;\n    this[8] = m02;\n    this[9] = m12;\n    this[10] = m22;\n    this[11] = m32;\n    this[12] = m03;\n    this[13] = m13;\n    this[14] = m23;\n    this[15] = m33;\n    return this.check();\n  }\n\n  toRowMajor(result) {\n    result[0] = this[0];\n    result[1] = this[4];\n    result[2] = this[8];\n    result[3] = this[12];\n    result[4] = this[1];\n    result[5] = this[5];\n    result[6] = this[9];\n    result[7] = this[13];\n    result[8] = this[2];\n    result[9] = this[6];\n    result[10] = this[10];\n    result[11] = this[14];\n    result[12] = this[3];\n    result[13] = this[7];\n    result[14] = this[11];\n    result[15] = this[15];\n    return result;\n  }\n\n  identity() {\n    return this.copy(IDENTITY_MATRIX);\n  }\n\n  fromObject(object) {\n    return this.check();\n  }\n\n  fromQuaternion(quaternion) {\n    gl_matrix_mat4__WEBPACK_IMPORTED_MODULE_1__/* .fromQuat */ .en(this, quaternion);\n    return this.check();\n  }\n\n  frustum(view) {\n    const {\n      left,\n      right,\n      bottom,\n      top,\n      near = DEFAULT_NEAR,\n      far = DEFAULT_FAR\n    } = view;\n\n    if (far === Infinity) {\n      computeInfinitePerspectiveOffCenter(this, left, right, bottom, top, near);\n    } else {\n      gl_matrix_mat4__WEBPACK_IMPORTED_MODULE_1__/* .frustum */ .oy(this, left, right, bottom, top, near, far);\n    }\n\n    return this.check();\n  }\n\n  lookAt(view) {\n    const {\n      eye,\n      center = [0, 0, 0],\n      up = [0, 1, 0]\n    } = view;\n    gl_matrix_mat4__WEBPACK_IMPORTED_MODULE_1__/* .lookAt */ .zB(this, eye, center, up);\n    return this.check();\n  }\n\n  ortho(view) {\n    const {\n      left,\n      right,\n      bottom,\n      top,\n      near = DEFAULT_NEAR,\n      far = DEFAULT_FAR\n    } = view;\n    gl_matrix_mat4__WEBPACK_IMPORTED_MODULE_1__/* .ortho */ .M5(this, left, right, bottom, top, near, far);\n    return this.check();\n  }\n\n  orthographic(view) {\n    const {\n      fovy = DEFAULT_FOVY,\n      aspect = DEFAULT_ASPECT,\n      focalDistance = 1,\n      near = DEFAULT_NEAR,\n      far = DEFAULT_FAR\n    } = view;\n    checkRadians(fovy);\n    const halfY = fovy / 2;\n    const top = focalDistance * Math.tan(halfY);\n    const right = top * aspect;\n    return this.ortho({\n      left: -right,\n      right,\n      bottom: -top,\n      top,\n      near,\n      far\n    });\n  }\n\n  perspective(view) {\n    const {\n      fovy = 45 * Math.PI / 180,\n      aspect = 1,\n      near = 0.1,\n      far = 500\n    } = view;\n    checkRadians(fovy);\n    gl_matrix_mat4__WEBPACK_IMPORTED_MODULE_1__/* .perspective */ .G3(this, fovy, aspect, near, far);\n    return this.check();\n  }\n\n  determinant() {\n    return gl_matrix_mat4__WEBPACK_IMPORTED_MODULE_1__/* .determinant */ .GH(this);\n  }\n\n  getScale(result = [-0, -0, -0]) {\n    result[0] = Math.sqrt(this[0] * this[0] + this[1] * this[1] + this[2] * this[2]);\n    result[1] = Math.sqrt(this[4] * this[4] + this[5] * this[5] + this[6] * this[6]);\n    result[2] = Math.sqrt(this[8] * this[8] + this[9] * this[9] + this[10] * this[10]);\n    return result;\n  }\n\n  getTranslation(result = [-0, -0, -0]) {\n    result[0] = this[12];\n    result[1] = this[13];\n    result[2] = this[14];\n    return result;\n  }\n\n  getRotation(result, scaleResult) {\n    result = result || [-0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0];\n    scaleResult = scaleResult || [-0, -0, -0];\n    const scale = this.getScale(scaleResult);\n    const inverseScale0 = 1 / scale[0];\n    const inverseScale1 = 1 / scale[1];\n    const inverseScale2 = 1 / scale[2];\n    result[0] = this[0] * inverseScale0;\n    result[1] = this[1] * inverseScale1;\n    result[2] = this[2] * inverseScale2;\n    result[3] = 0;\n    result[4] = this[4] * inverseScale0;\n    result[5] = this[5] * inverseScale1;\n    result[6] = this[6] * inverseScale2;\n    result[7] = 0;\n    result[8] = this[8] * inverseScale0;\n    result[9] = this[9] * inverseScale1;\n    result[10] = this[10] * inverseScale2;\n    result[11] = 0;\n    result[12] = 0;\n    result[13] = 0;\n    result[14] = 0;\n    result[15] = 1;\n    return result;\n  }\n\n  getRotationMatrix3(result, scaleResult) {\n    result = result || [-0, -0, -0, -0, -0, -0, -0, -0, -0];\n    scaleResult = scaleResult || [-0, -0, -0];\n    const scale = this.getScale(scaleResult);\n    const inverseScale0 = 1 / scale[0];\n    const inverseScale1 = 1 / scale[1];\n    const inverseScale2 = 1 / scale[2];\n    result[0] = this[0] * inverseScale0;\n    result[1] = this[1] * inverseScale1;\n    result[2] = this[2] * inverseScale2;\n    result[3] = this[4] * inverseScale0;\n    result[4] = this[5] * inverseScale1;\n    result[5] = this[6] * inverseScale2;\n    result[6] = this[8] * inverseScale0;\n    result[7] = this[9] * inverseScale1;\n    result[8] = this[10] * inverseScale2;\n    return result;\n  }\n\n  transpose() {\n    gl_matrix_mat4__WEBPACK_IMPORTED_MODULE_1__/* .transpose */ .p4(this, this);\n    return this.check();\n  }\n\n  invert() {\n    gl_matrix_mat4__WEBPACK_IMPORTED_MODULE_1__/* .invert */ .U_(this, this);\n    return this.check();\n  }\n\n  multiplyLeft(a) {\n    gl_matrix_mat4__WEBPACK_IMPORTED_MODULE_1__/* .multiply */ .Jp(this, a, this);\n    return this.check();\n  }\n\n  multiplyRight(a) {\n    gl_matrix_mat4__WEBPACK_IMPORTED_MODULE_1__/* .multiply */ .Jp(this, this, a);\n    return this.check();\n  }\n\n  rotateX(radians) {\n    gl_matrix_mat4__WEBPACK_IMPORTED_MODULE_1__/* .rotateX */ .lM(this, this, radians);\n    return this.check();\n  }\n\n  rotateY(radians) {\n    gl_matrix_mat4__WEBPACK_IMPORTED_MODULE_1__/* .rotateY */ .uD(this, this, radians);\n    return this.check();\n  }\n\n  rotateZ(radians) {\n    gl_matrix_mat4__WEBPACK_IMPORTED_MODULE_1__/* .rotateZ */ .jI(this, this, radians);\n    return this.check();\n  }\n\n  rotateXYZ(angleXYZ) {\n    return this.rotateX(angleXYZ[0]).rotateY(angleXYZ[1]).rotateZ(angleXYZ[2]);\n  }\n\n  rotateAxis(radians, axis) {\n    gl_matrix_mat4__WEBPACK_IMPORTED_MODULE_1__/* .rotate */ .U1(this, this, radians, axis);\n    return this.check();\n  }\n\n  scale(factor) {\n    gl_matrix_mat4__WEBPACK_IMPORTED_MODULE_1__/* .scale */ .bA(this, this, Array.isArray(factor) ? factor : [factor, factor, factor]);\n    return this.check();\n  }\n\n  translate(vector) {\n    gl_matrix_mat4__WEBPACK_IMPORTED_MODULE_1__/* .translate */ .Iu(this, this, vector);\n    return this.check();\n  }\n\n  transform(vector, result) {\n    if (vector.length === 4) {\n      result = gl_matrix_vec4__WEBPACK_IMPORTED_MODULE_2__/* .transformMat4 */ .fF(result || [-0, -0, -0, -0], vector, this);\n      (0,_lib_validators__WEBPACK_IMPORTED_MODULE_3__/* .checkVector */ .IL)(result, 4);\n      return result;\n    }\n\n    return this.transformAsPoint(vector, result);\n  }\n\n  transformAsPoint(vector, result) {\n    const {\n      length\n    } = vector;\n    let out;\n\n    switch (length) {\n      case 2:\n        out = gl_matrix_vec2__WEBPACK_IMPORTED_MODULE_4__/* .transformMat4 */ .fF(result || [-0, -0], vector, this);\n        break;\n\n      case 3:\n        out = gl_matrix_vec3__WEBPACK_IMPORTED_MODULE_5__/* .transformMat4 */ .fF(result || [-0, -0, -0], vector, this);\n        break;\n\n      default:\n        throw new Error(\'Illegal vector\');\n    }\n\n    (0,_lib_validators__WEBPACK_IMPORTED_MODULE_3__/* .checkVector */ .IL)(out, vector.length);\n    return out;\n  }\n\n  transformAsVector(vector, result) {\n    let out;\n\n    switch (vector.length) {\n      case 2:\n        out = (0,_lib_gl_matrix_extras__WEBPACK_IMPORTED_MODULE_6__/* .vec2_transformMat4AsVector */ .pb)(result || [-0, -0], vector, this);\n        break;\n\n      case 3:\n        out = (0,_lib_gl_matrix_extras__WEBPACK_IMPORTED_MODULE_6__/* .vec3_transformMat4AsVector */ .pL)(result || [-0, -0, -0], vector, this);\n        break;\n\n      default:\n        throw new Error(\'Illegal vector\');\n    }\n\n    (0,_lib_validators__WEBPACK_IMPORTED_MODULE_3__/* .checkVector */ .IL)(out, vector.length);\n    return out;\n  }\n\n  transformPoint(vector, result) {\n    return this.transformAsPoint(vector, result);\n  }\n\n  transformVector(vector, result) {\n    return this.transformAsPoint(vector, result);\n  }\n\n  transformDirection(vector, result) {\n    return this.transformAsVector(vector, result);\n  }\n\n  makeRotationX(radians) {\n    return this.identity().rotateX(radians);\n  }\n\n  makeTranslation(x, y, z) {\n    return this.identity().translate([x, y, z]);\n  }\n\n}\nlet ZERO;\nlet IDENTITY;\n\nfunction getZeroMatrix() {\n  if (!ZERO) {\n    ZERO = new Matrix4([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]);\n    Object.freeze(ZERO);\n  }\n\n  return ZERO;\n}\n\nfunction getIdentityMatrix() {\n  if (!IDENTITY) {\n    IDENTITY = new Matrix4();\n    Object.freeze(IDENTITY);\n  }\n\n  return IDENTITY;\n}\n\nfunction checkRadians(possiblyDegrees) {\n  if (possiblyDegrees > Math.PI * 2) {\n    throw Error(\'expected radians\');\n  }\n}\n\nfunction computeInfinitePerspectiveOffCenter(result, left, right, bottom, top, near) {\n  const column0Row0 = 2 * near / (right - left);\n  const column1Row1 = 2 * near / (top - bottom);\n  const column2Row0 = (right + left) / (right - left);\n  const column2Row1 = (top + bottom) / (top - bottom);\n  const column2Row2 = -1;\n  const column2Row3 = -1;\n  const column3Row2 = -2 * near;\n  result[0] = column0Row0;\n  result[1] = 0;\n  result[2] = 0;\n  result[3] = 0;\n  result[4] = 0;\n  result[5] = column1Row1;\n  result[6] = 0;\n  result[7] = 0;\n  result[8] = column2Row0;\n  result[9] = column2Row1;\n  result[10] = column2Row2;\n  result[11] = column2Row3;\n  result[12] = 0;\n  result[13] = 0;\n  result[14] = column3Row2;\n  result[15] = 0;\n  return result;\n}\n//# sourceMappingURL=matrix4.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QUNBO0FBQ0E7O0FBRUE7QUFDQSxJQUFJLDREQUFXO0FBQ2Y7QUFDQTs7QUFFQTtBQUNBLElBQUksMkRBQVU7QUFDZDtBQUNBOztBQUVBO0FBQ0EsSUFBSSwrREFBYztBQUNsQjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFlLG1FQUFrQjtBQUNqQyxNQUFNLHNFQUFXO0FBQ2pCO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047O0FBRUE7QUFDQTtBQUNBLGNBQWMsbUVBQWtCO0FBQ2hDOztBQUVBO0FBQ0EsY0FBYyxtRUFBa0I7QUFDaEM7O0FBRUE7QUFDQTtBQUNBOztBQUVBLElBQUksc0VBQVc7QUFDZjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGNBQWMsMkZBQTBCO0FBQ3hDOztBQUVBO0FBQ0EsY0FBYywyRkFBMEI7QUFDeEM7O0FBRUE7QUFDQTtBQUNBOztBQUVBLElBQUksc0VBQVc7QUFDZjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly92dWUzLXdlYnBhY2s1Ly4vbm9kZV9tb2R1bGVzL0BtYXRoLmdsL2NvcmUvZGlzdC9lc20vY2xhc3Nlcy9tYXRyaXg0LmpzPzk5NjUiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IE1hdHJpeCBmcm9tICcuL2Jhc2UvbWF0cml4JztcbmltcG9ydCB7IGNoZWNrVmVjdG9yIH0gZnJvbSAnLi4vbGliL3ZhbGlkYXRvcnMnO1xuaW1wb3J0IHsgdmVjMl90cmFuc2Zvcm1NYXQ0QXNWZWN0b3IsIHZlYzNfdHJhbnNmb3JtTWF0NEFzVmVjdG9yIH0gZnJvbSAnLi4vbGliL2dsLW1hdHJpeC1leHRyYXMnO1xuaW1wb3J0ICogYXMgbWF0NCBmcm9tICdnbC1tYXRyaXgvbWF0NCc7XG5pbXBvcnQgKiBhcyB2ZWMyIGZyb20gJ2dsLW1hdHJpeC92ZWMyJztcbmltcG9ydCAqIGFzIHZlYzMgZnJvbSAnZ2wtbWF0cml4L3ZlYzMnO1xuaW1wb3J0ICogYXMgdmVjNCBmcm9tICdnbC1tYXRyaXgvdmVjNCc7XG52YXIgSU5ESUNFUztcblxuKGZ1bmN0aW9uIChJTkRJQ0VTKSB7XG4gIElORElDRVNbSU5ESUNFU1tcIkNPTDBST1cwXCJdID0gMF0gPSBcIkNPTDBST1cwXCI7XG4gIElORElDRVNbSU5ESUNFU1tcIkNPTDBST1cxXCJdID0gMV0gPSBcIkNPTDBST1cxXCI7XG4gIElORElDRVNbSU5ESUNFU1tcIkNPTDBST1cyXCJdID0gMl0gPSBcIkNPTDBST1cyXCI7XG4gIElORElDRVNbSU5ESUNFU1tcIkNPTDBST1czXCJdID0gM10gPSBcIkNPTDBST1czXCI7XG4gIElORElDRVNbSU5ESUNFU1tcIkNPTDFST1cwXCJdID0gNF0gPSBcIkNPTDFST1cwXCI7XG4gIElORElDRVNbSU5ESUNFU1tcIkNPTDFST1cxXCJdID0gNV0gPSBcIkNPTDFST1cxXCI7XG4gIElORElDRVNbSU5ESUNFU1tcIkNPTDFST1cyXCJdID0gNl0gPSBcIkNPTDFST1cyXCI7XG4gIElORElDRVNbSU5ESUNFU1tcIkNPTDFST1czXCJdID0gN10gPSBcIkNPTDFST1czXCI7XG4gIElORElDRVNbSU5ESUNFU1tcIkNPTDJST1cwXCJdID0gOF0gPSBcIkNPTDJST1cwXCI7XG4gIElORElDRVNbSU5ESUNFU1tcIkNPTDJST1cxXCJdID0gOV0gPSBcIkNPTDJST1cxXCI7XG4gIElORElDRVNbSU5ESUNFU1tcIkNPTDJST1cyXCJdID0gMTBdID0gXCJDT0wyUk9XMlwiO1xuICBJTkRJQ0VTW0lORElDRVNbXCJDT0wyUk9XM1wiXSA9IDExXSA9IFwiQ09MMlJPVzNcIjtcbiAgSU5ESUNFU1tJTkRJQ0VTW1wiQ09MM1JPVzBcIl0gPSAxMl0gPSBcIkNPTDNST1cwXCI7XG4gIElORElDRVNbSU5ESUNFU1tcIkNPTDNST1cxXCJdID0gMTNdID0gXCJDT0wzUk9XMVwiO1xuICBJTkRJQ0VTW0lORElDRVNbXCJDT0wzUk9XMlwiXSA9IDE0XSA9IFwiQ09MM1JPVzJcIjtcbiAgSU5ESUNFU1tJTkRJQ0VTW1wiQ09MM1JPVzNcIl0gPSAxNV0gPSBcIkNPTDNST1czXCI7XG59KShJTkRJQ0VTIHx8IChJTkRJQ0VTID0ge30pKTtcblxuY29uc3QgREVGQVVMVF9GT1ZZID0gNDUgKiBNYXRoLlBJIC8gMTgwO1xuY29uc3QgREVGQVVMVF9BU1BFQ1QgPSAxO1xuY29uc3QgREVGQVVMVF9ORUFSID0gMC4xO1xuY29uc3QgREVGQVVMVF9GQVIgPSA1MDA7XG5jb25zdCBJREVOVElUWV9NQVRSSVggPSBPYmplY3QuZnJlZXplKFsxLCAwLCAwLCAwLCAwLCAxLCAwLCAwLCAwLCAwLCAxLCAwLCAwLCAwLCAwLCAxXSk7XG5leHBvcnQgZGVmYXVsdCBjbGFzcyBNYXRyaXg0IGV4dGVuZHMgTWF0cml4IHtcbiAgc3RhdGljIGdldCBJREVOVElUWSgpIHtcbiAgICByZXR1cm4gZ2V0SWRlbnRpdHlNYXRyaXgoKTtcbiAgfVxuXG4gIHN0YXRpYyBnZXQgWkVSTygpIHtcbiAgICByZXR1cm4gZ2V0WmVyb01hdHJpeCgpO1xuICB9XG5cbiAgZ2V0IEVMRU1FTlRTKCkge1xuICAgIHJldHVybiAxNjtcbiAgfVxuXG4gIGdldCBSQU5LKCkge1xuICAgIHJldHVybiA0O1xuICB9XG5cbiAgZ2V0IElORElDRVMoKSB7XG4gICAgcmV0dXJuIElORElDRVM7XG4gIH1cblxuICBjb25zdHJ1Y3RvcihhcnJheSkge1xuICAgIHN1cGVyKC0wLCAtMCwgLTAsIC0wLCAtMCwgLTAsIC0wLCAtMCwgLTAsIC0wLCAtMCwgLTAsIC0wLCAtMCwgLTAsIC0wKTtcblxuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxICYmIEFycmF5LmlzQXJyYXkoYXJyYXkpKSB7XG4gICAgICB0aGlzLmNvcHkoYXJyYXkpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmlkZW50aXR5KCk7XG4gICAgfVxuICB9XG5cbiAgY29weShhcnJheSkge1xuICAgIHRoaXNbMF0gPSBhcnJheVswXTtcbiAgICB0aGlzWzFdID0gYXJyYXlbMV07XG4gICAgdGhpc1syXSA9IGFycmF5WzJdO1xuICAgIHRoaXNbM10gPSBhcnJheVszXTtcbiAgICB0aGlzWzRdID0gYXJyYXlbNF07XG4gICAgdGhpc1s1XSA9IGFycmF5WzVdO1xuICAgIHRoaXNbNl0gPSBhcnJheVs2XTtcbiAgICB0aGlzWzddID0gYXJyYXlbN107XG4gICAgdGhpc1s4XSA9IGFycmF5WzhdO1xuICAgIHRoaXNbOV0gPSBhcnJheVs5XTtcbiAgICB0aGlzWzEwXSA9IGFycmF5WzEwXTtcbiAgICB0aGlzWzExXSA9IGFycmF5WzExXTtcbiAgICB0aGlzWzEyXSA9IGFycmF5WzEyXTtcbiAgICB0aGlzWzEzXSA9IGFycmF5WzEzXTtcbiAgICB0aGlzWzE0XSA9IGFycmF5WzE0XTtcbiAgICB0aGlzWzE1XSA9IGFycmF5WzE1XTtcbiAgICByZXR1cm4gdGhpcy5jaGVjaygpO1xuICB9XG5cbiAgc2V0KG0wMCwgbTEwLCBtMjAsIG0zMCwgbTAxLCBtMTEsIG0yMSwgbTMxLCBtMDIsIG0xMiwgbTIyLCBtMzIsIG0wMywgbTEzLCBtMjMsIG0zMykge1xuICAgIHRoaXNbMF0gPSBtMDA7XG4gICAgdGhpc1sxXSA9IG0xMDtcbiAgICB0aGlzWzJdID0gbTIwO1xuICAgIHRoaXNbM10gPSBtMzA7XG4gICAgdGhpc1s0XSA9IG0wMTtcbiAgICB0aGlzWzVdID0gbTExO1xuICAgIHRoaXNbNl0gPSBtMjE7XG4gICAgdGhpc1s3XSA9IG0zMTtcbiAgICB0aGlzWzhdID0gbTAyO1xuICAgIHRoaXNbOV0gPSBtMTI7XG4gICAgdGhpc1sxMF0gPSBtMjI7XG4gICAgdGhpc1sxMV0gPSBtMzI7XG4gICAgdGhpc1sxMl0gPSBtMDM7XG4gICAgdGhpc1sxM10gPSBtMTM7XG4gICAgdGhpc1sxNF0gPSBtMjM7XG4gICAgdGhpc1sxNV0gPSBtMzM7XG4gICAgcmV0dXJuIHRoaXMuY2hlY2soKTtcbiAgfVxuXG4gIHNldFJvd01ham9yKG0wMCwgbTAxLCBtMDIsIG0wMywgbTEwLCBtMTEsIG0xMiwgbTEzLCBtMjAsIG0yMSwgbTIyLCBtMjMsIG0zMCwgbTMxLCBtMzIsIG0zMykge1xuICAgIHRoaXNbMF0gPSBtMDA7XG4gICAgdGhpc1sxXSA9IG0xMDtcbiAgICB0aGlzWzJdID0gbTIwO1xuICAgIHRoaXNbM10gPSBtMzA7XG4gICAgdGhpc1s0XSA9IG0wMTtcbiAgICB0aGlzWzVdID0gbTExO1xuICAgIHRoaXNbNl0gPSBtMjE7XG4gICAgdGhpc1s3XSA9IG0zMTtcbiAgICB0aGlzWzhdID0gbTAyO1xuICAgIHRoaXNbOV0gPSBtMTI7XG4gICAgdGhpc1sxMF0gPSBtMjI7XG4gICAgdGhpc1sxMV0gPSBtMzI7XG4gICAgdGhpc1sxMl0gPSBtMDM7XG4gICAgdGhpc1sxM10gPSBtMTM7XG4gICAgdGhpc1sxNF0gPSBtMjM7XG4gICAgdGhpc1sxNV0gPSBtMzM7XG4gICAgcmV0dXJuIHRoaXMuY2hlY2soKTtcbiAgfVxuXG4gIHRvUm93TWFqb3IocmVzdWx0KSB7XG4gICAgcmVzdWx0WzBdID0gdGhpc1swXTtcbiAgICByZXN1bHRbMV0gPSB0aGlzWzRdO1xuICAgIHJlc3VsdFsyXSA9IHRoaXNbOF07XG4gICAgcmVzdWx0WzNdID0gdGhpc1sxMl07XG4gICAgcmVzdWx0WzRdID0gdGhpc1sxXTtcbiAgICByZXN1bHRbNV0gPSB0aGlzWzVdO1xuICAgIHJlc3VsdFs2XSA9IHRoaXNbOV07XG4gICAgcmVzdWx0WzddID0gdGhpc1sxM107XG4gICAgcmVzdWx0WzhdID0gdGhpc1syXTtcbiAgICByZXN1bHRbOV0gPSB0aGlzWzZdO1xuICAgIHJlc3VsdFsxMF0gPSB0aGlzWzEwXTtcbiAgICByZXN1bHRbMTFdID0gdGhpc1sxNF07XG4gICAgcmVzdWx0WzEyXSA9IHRoaXNbM107XG4gICAgcmVzdWx0WzEzXSA9IHRoaXNbN107XG4gICAgcmVzdWx0WzE0XSA9IHRoaXNbMTFdO1xuICAgIHJlc3VsdFsxNV0gPSB0aGlzWzE1XTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgaWRlbnRpdHkoKSB7XG4gICAgcmV0dXJuIHRoaXMuY29weShJREVOVElUWV9NQVRSSVgpO1xuICB9XG5cbiAgZnJvbU9iamVjdChvYmplY3QpIHtcbiAgICByZXR1cm4gdGhpcy5jaGVjaygpO1xuICB9XG5cbiAgZnJvbVF1YXRlcm5pb24ocXVhdGVybmlvbikge1xuICAgIG1hdDQuZnJvbVF1YXQodGhpcywgcXVhdGVybmlvbik7XG4gICAgcmV0dXJuIHRoaXMuY2hlY2soKTtcbiAgfVxuXG4gIGZydXN0dW0odmlldykge1xuICAgIGNvbnN0IHtcbiAgICAgIGxlZnQsXG4gICAgICByaWdodCxcbiAgICAgIGJvdHRvbSxcbiAgICAgIHRvcCxcbiAgICAgIG5lYXIgPSBERUZBVUxUX05FQVIsXG4gICAgICBmYXIgPSBERUZBVUxUX0ZBUlxuICAgIH0gPSB2aWV3O1xuXG4gICAgaWYgKGZhciA9PT0gSW5maW5pdHkpIHtcbiAgICAgIGNvbXB1dGVJbmZpbml0ZVBlcnNwZWN0aXZlT2ZmQ2VudGVyKHRoaXMsIGxlZnQsIHJpZ2h0LCBib3R0b20sIHRvcCwgbmVhcik7XG4gICAgfSBlbHNlIHtcbiAgICAgIG1hdDQuZnJ1c3R1bSh0aGlzLCBsZWZ0LCByaWdodCwgYm90dG9tLCB0b3AsIG5lYXIsIGZhcik7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuY2hlY2soKTtcbiAgfVxuXG4gIGxvb2tBdCh2aWV3KSB7XG4gICAgY29uc3Qge1xuICAgICAgZXllLFxuICAgICAgY2VudGVyID0gWzAsIDAsIDBdLFxuICAgICAgdXAgPSBbMCwgMSwgMF1cbiAgICB9ID0gdmlldztcbiAgICBtYXQ0Lmxvb2tBdCh0aGlzLCBleWUsIGNlbnRlciwgdXApO1xuICAgIHJldHVybiB0aGlzLmNoZWNrKCk7XG4gIH1cblxuICBvcnRobyh2aWV3KSB7XG4gICAgY29uc3Qge1xuICAgICAgbGVmdCxcbiAgICAgIHJpZ2h0LFxuICAgICAgYm90dG9tLFxuICAgICAgdG9wLFxuICAgICAgbmVhciA9IERFRkFVTFRfTkVBUixcbiAgICAgIGZhciA9IERFRkFVTFRfRkFSXG4gICAgfSA9IHZpZXc7XG4gICAgbWF0NC5vcnRobyh0aGlzLCBsZWZ0LCByaWdodCwgYm90dG9tLCB0b3AsIG5lYXIsIGZhcik7XG4gICAgcmV0dXJuIHRoaXMuY2hlY2soKTtcbiAgfVxuXG4gIG9ydGhvZ3JhcGhpYyh2aWV3KSB7XG4gICAgY29uc3Qge1xuICAgICAgZm92eSA9IERFRkFVTFRfRk9WWSxcbiAgICAgIGFzcGVjdCA9IERFRkFVTFRfQVNQRUNULFxuICAgICAgZm9jYWxEaXN0YW5jZSA9IDEsXG4gICAgICBuZWFyID0gREVGQVVMVF9ORUFSLFxuICAgICAgZmFyID0gREVGQVVMVF9GQVJcbiAgICB9ID0gdmlldztcbiAgICBjaGVja1JhZGlhbnMoZm92eSk7XG4gICAgY29uc3QgaGFsZlkgPSBmb3Z5IC8gMjtcbiAgICBjb25zdCB0b3AgPSBmb2NhbERpc3RhbmNlICogTWF0aC50YW4oaGFsZlkpO1xuICAgIGNvbnN0IHJpZ2h0ID0gdG9wICogYXNwZWN0O1xuICAgIHJldHVybiB0aGlzLm9ydGhvKHtcbiAgICAgIGxlZnQ6IC1yaWdodCxcbiAgICAgIHJpZ2h0LFxuICAgICAgYm90dG9tOiAtdG9wLFxuICAgICAgdG9wLFxuICAgICAgbmVhcixcbiAgICAgIGZhclxuICAgIH0pO1xuICB9XG5cbiAgcGVyc3BlY3RpdmUodmlldykge1xuICAgIGNvbnN0IHtcbiAgICAgIGZvdnkgPSA0NSAqIE1hdGguUEkgLyAxODAsXG4gICAgICBhc3BlY3QgPSAxLFxuICAgICAgbmVhciA9IDAuMSxcbiAgICAgIGZhciA9IDUwMFxuICAgIH0gPSB2aWV3O1xuICAgIGNoZWNrUmFkaWFucyhmb3Z5KTtcbiAgICBtYXQ0LnBlcnNwZWN0aXZlKHRoaXMsIGZvdnksIGFzcGVjdCwgbmVhciwgZmFyKTtcbiAgICByZXR1cm4gdGhpcy5jaGVjaygpO1xuICB9XG5cbiAgZGV0ZXJtaW5hbnQoKSB7XG4gICAgcmV0dXJuIG1hdDQuZGV0ZXJtaW5hbnQodGhpcyk7XG4gIH1cblxuICBnZXRTY2FsZShyZXN1bHQgPSBbLTAsIC0wLCAtMF0pIHtcbiAgICByZXN1bHRbMF0gPSBNYXRoLnNxcnQodGhpc1swXSAqIHRoaXNbMF0gKyB0aGlzWzFdICogdGhpc1sxXSArIHRoaXNbMl0gKiB0aGlzWzJdKTtcbiAgICByZXN1bHRbMV0gPSBNYXRoLnNxcnQodGhpc1s0XSAqIHRoaXNbNF0gKyB0aGlzWzVdICogdGhpc1s1XSArIHRoaXNbNl0gKiB0aGlzWzZdKTtcbiAgICByZXN1bHRbMl0gPSBNYXRoLnNxcnQodGhpc1s4XSAqIHRoaXNbOF0gKyB0aGlzWzldICogdGhpc1s5XSArIHRoaXNbMTBdICogdGhpc1sxMF0pO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICBnZXRUcmFuc2xhdGlvbihyZXN1bHQgPSBbLTAsIC0wLCAtMF0pIHtcbiAgICByZXN1bHRbMF0gPSB0aGlzWzEyXTtcbiAgICByZXN1bHRbMV0gPSB0aGlzWzEzXTtcbiAgICByZXN1bHRbMl0gPSB0aGlzWzE0XTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgZ2V0Um90YXRpb24ocmVzdWx0LCBzY2FsZVJlc3VsdCkge1xuICAgIHJlc3VsdCA9IHJlc3VsdCB8fCBbLTAsIC0wLCAtMCwgLTAsIC0wLCAtMCwgLTAsIC0wLCAtMCwgLTAsIC0wLCAtMCwgLTAsIC0wLCAtMCwgLTBdO1xuICAgIHNjYWxlUmVzdWx0ID0gc2NhbGVSZXN1bHQgfHwgWy0wLCAtMCwgLTBdO1xuICAgIGNvbnN0IHNjYWxlID0gdGhpcy5nZXRTY2FsZShzY2FsZVJlc3VsdCk7XG4gICAgY29uc3QgaW52ZXJzZVNjYWxlMCA9IDEgLyBzY2FsZVswXTtcbiAgICBjb25zdCBpbnZlcnNlU2NhbGUxID0gMSAvIHNjYWxlWzFdO1xuICAgIGNvbnN0IGludmVyc2VTY2FsZTIgPSAxIC8gc2NhbGVbMl07XG4gICAgcmVzdWx0WzBdID0gdGhpc1swXSAqIGludmVyc2VTY2FsZTA7XG4gICAgcmVzdWx0WzFdID0gdGhpc1sxXSAqIGludmVyc2VTY2FsZTE7XG4gICAgcmVzdWx0WzJdID0gdGhpc1syXSAqIGludmVyc2VTY2FsZTI7XG4gICAgcmVzdWx0WzNdID0gMDtcbiAgICByZXN1bHRbNF0gPSB0aGlzWzRdICogaW52ZXJzZVNjYWxlMDtcbiAgICByZXN1bHRbNV0gPSB0aGlzWzVdICogaW52ZXJzZVNjYWxlMTtcbiAgICByZXN1bHRbNl0gPSB0aGlzWzZdICogaW52ZXJzZVNjYWxlMjtcbiAgICByZXN1bHRbN10gPSAwO1xuICAgIHJlc3VsdFs4XSA9IHRoaXNbOF0gKiBpbnZlcnNlU2NhbGUwO1xuICAgIHJlc3VsdFs5XSA9IHRoaXNbOV0gKiBpbnZlcnNlU2NhbGUxO1xuICAgIHJlc3VsdFsxMF0gPSB0aGlzWzEwXSAqIGludmVyc2VTY2FsZTI7XG4gICAgcmVzdWx0WzExXSA9IDA7XG4gICAgcmVzdWx0WzEyXSA9IDA7XG4gICAgcmVzdWx0WzEzXSA9IDA7XG4gICAgcmVzdWx0WzE0XSA9IDA7XG4gICAgcmVzdWx0WzE1XSA9IDE7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIGdldFJvdGF0aW9uTWF0cml4MyhyZXN1bHQsIHNjYWxlUmVzdWx0KSB7XG4gICAgcmVzdWx0ID0gcmVzdWx0IHx8IFstMCwgLTAsIC0wLCAtMCwgLTAsIC0wLCAtMCwgLTAsIC0wXTtcbiAgICBzY2FsZVJlc3VsdCA9IHNjYWxlUmVzdWx0IHx8IFstMCwgLTAsIC0wXTtcbiAgICBjb25zdCBzY2FsZSA9IHRoaXMuZ2V0U2NhbGUoc2NhbGVSZXN1bHQpO1xuICAgIGNvbnN0IGludmVyc2VTY2FsZTAgPSAxIC8gc2NhbGVbMF07XG4gICAgY29uc3QgaW52ZXJzZVNjYWxlMSA9IDEgLyBzY2FsZVsxXTtcbiAgICBjb25zdCBpbnZlcnNlU2NhbGUyID0gMSAvIHNjYWxlWzJdO1xuICAgIHJlc3VsdFswXSA9IHRoaXNbMF0gKiBpbnZlcnNlU2NhbGUwO1xuICAgIHJlc3VsdFsxXSA9IHRoaXNbMV0gKiBpbnZlcnNlU2NhbGUxO1xuICAgIHJlc3VsdFsyXSA9IHRoaXNbMl0gKiBpbnZlcnNlU2NhbGUyO1xuICAgIHJlc3VsdFszXSA9IHRoaXNbNF0gKiBpbnZlcnNlU2NhbGUwO1xuICAgIHJlc3VsdFs0XSA9IHRoaXNbNV0gKiBpbnZlcnNlU2NhbGUxO1xuICAgIHJlc3VsdFs1XSA9IHRoaXNbNl0gKiBpbnZlcnNlU2NhbGUyO1xuICAgIHJlc3VsdFs2XSA9IHRoaXNbOF0gKiBpbnZlcnNlU2NhbGUwO1xuICAgIHJlc3VsdFs3XSA9IHRoaXNbOV0gKiBpbnZlcnNlU2NhbGUxO1xuICAgIHJlc3VsdFs4XSA9IHRoaXNbMTBdICogaW52ZXJzZVNjYWxlMjtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgdHJhbnNwb3NlKCkge1xuICAgIG1hdDQudHJhbnNwb3NlKHRoaXMsIHRoaXMpO1xuICAgIHJldHVybiB0aGlzLmNoZWNrKCk7XG4gIH1cblxuICBpbnZlcnQoKSB7XG4gICAgbWF0NC5pbnZlcnQodGhpcywgdGhpcyk7XG4gICAgcmV0dXJuIHRoaXMuY2hlY2soKTtcbiAgfVxuXG4gIG11bHRpcGx5TGVmdChhKSB7XG4gICAgbWF0NC5tdWx0aXBseSh0aGlzLCBhLCB0aGlzKTtcbiAgICByZXR1cm4gdGhpcy5jaGVjaygpO1xuICB9XG5cbiAgbXVsdGlwbHlSaWdodChhKSB7XG4gICAgbWF0NC5tdWx0aXBseSh0aGlzLCB0aGlzLCBhKTtcbiAgICByZXR1cm4gdGhpcy5jaGVjaygpO1xuICB9XG5cbiAgcm90YXRlWChyYWRpYW5zKSB7XG4gICAgbWF0NC5yb3RhdGVYKHRoaXMsIHRoaXMsIHJhZGlhbnMpO1xuICAgIHJldHVybiB0aGlzLmNoZWNrKCk7XG4gIH1cblxuICByb3RhdGVZKHJhZGlhbnMpIHtcbiAgICBtYXQ0LnJvdGF0ZVkodGhpcywgdGhpcywgcmFkaWFucyk7XG4gICAgcmV0dXJuIHRoaXMuY2hlY2soKTtcbiAgfVxuXG4gIHJvdGF0ZVoocmFkaWFucykge1xuICAgIG1hdDQucm90YXRlWih0aGlzLCB0aGlzLCByYWRpYW5zKTtcbiAgICByZXR1cm4gdGhpcy5jaGVjaygpO1xuICB9XG5cbiAgcm90YXRlWFlaKGFuZ2xlWFlaKSB7XG4gICAgcmV0dXJuIHRoaXMucm90YXRlWChhbmdsZVhZWlswXSkucm90YXRlWShhbmdsZVhZWlsxXSkucm90YXRlWihhbmdsZVhZWlsyXSk7XG4gIH1cblxuICByb3RhdGVBeGlzKHJhZGlhbnMsIGF4aXMpIHtcbiAgICBtYXQ0LnJvdGF0ZSh0aGlzLCB0aGlzLCByYWRpYW5zLCBheGlzKTtcbiAgICByZXR1cm4gdGhpcy5jaGVjaygpO1xuICB9XG5cbiAgc2NhbGUoZmFjdG9yKSB7XG4gICAgbWF0NC5zY2FsZSh0aGlzLCB0aGlzLCBBcnJheS5pc0FycmF5KGZhY3RvcikgPyBmYWN0b3IgOiBbZmFjdG9yLCBmYWN0b3IsIGZhY3Rvcl0pO1xuICAgIHJldHVybiB0aGlzLmNoZWNrKCk7XG4gIH1cblxuICB0cmFuc2xhdGUodmVjdG9yKSB7XG4gICAgbWF0NC50cmFuc2xhdGUodGhpcywgdGhpcywgdmVjdG9yKTtcbiAgICByZXR1cm4gdGhpcy5jaGVjaygpO1xuICB9XG5cbiAgdHJhbnNmb3JtKHZlY3RvciwgcmVzdWx0KSB7XG4gICAgaWYgKHZlY3Rvci5sZW5ndGggPT09IDQpIHtcbiAgICAgIHJlc3VsdCA9IHZlYzQudHJhbnNmb3JtTWF0NChyZXN1bHQgfHwgWy0wLCAtMCwgLTAsIC0wXSwgdmVjdG9yLCB0aGlzKTtcbiAgICAgIGNoZWNrVmVjdG9yKHJlc3VsdCwgNCk7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLnRyYW5zZm9ybUFzUG9pbnQodmVjdG9yLCByZXN1bHQpO1xuICB9XG5cbiAgdHJhbnNmb3JtQXNQb2ludCh2ZWN0b3IsIHJlc3VsdCkge1xuICAgIGNvbnN0IHtcbiAgICAgIGxlbmd0aFxuICAgIH0gPSB2ZWN0b3I7XG4gICAgbGV0IG91dDtcblxuICAgIHN3aXRjaCAobGVuZ3RoKSB7XG4gICAgICBjYXNlIDI6XG4gICAgICAgIG91dCA9IHZlYzIudHJhbnNmb3JtTWF0NChyZXN1bHQgfHwgWy0wLCAtMF0sIHZlY3RvciwgdGhpcyk7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlIDM6XG4gICAgICAgIG91dCA9IHZlYzMudHJhbnNmb3JtTWF0NChyZXN1bHQgfHwgWy0wLCAtMCwgLTBdLCB2ZWN0b3IsIHRoaXMpO1xuICAgICAgICBicmVhaztcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbGxlZ2FsIHZlY3RvcicpO1xuICAgIH1cblxuICAgIGNoZWNrVmVjdG9yKG91dCwgdmVjdG9yLmxlbmd0aCk7XG4gICAgcmV0dXJuIG91dDtcbiAgfVxuXG4gIHRyYW5zZm9ybUFzVmVjdG9yKHZlY3RvciwgcmVzdWx0KSB7XG4gICAgbGV0IG91dDtcblxuICAgIHN3aXRjaCAodmVjdG9yLmxlbmd0aCkge1xuICAgICAgY2FzZSAyOlxuICAgICAgICBvdXQgPSB2ZWMyX3RyYW5zZm9ybU1hdDRBc1ZlY3RvcihyZXN1bHQgfHwgWy0wLCAtMF0sIHZlY3RvciwgdGhpcyk7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlIDM6XG4gICAgICAgIG91dCA9IHZlYzNfdHJhbnNmb3JtTWF0NEFzVmVjdG9yKHJlc3VsdCB8fCBbLTAsIC0wLCAtMF0sIHZlY3RvciwgdGhpcyk7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0lsbGVnYWwgdmVjdG9yJyk7XG4gICAgfVxuXG4gICAgY2hlY2tWZWN0b3Iob3V0LCB2ZWN0b3IubGVuZ3RoKTtcbiAgICByZXR1cm4gb3V0O1xuICB9XG5cbiAgdHJhbnNmb3JtUG9pbnQodmVjdG9yLCByZXN1bHQpIHtcbiAgICByZXR1cm4gdGhpcy50cmFuc2Zvcm1Bc1BvaW50KHZlY3RvciwgcmVzdWx0KTtcbiAgfVxuXG4gIHRyYW5zZm9ybVZlY3Rvcih2ZWN0b3IsIHJlc3VsdCkge1xuICAgIHJldHVybiB0aGlzLnRyYW5zZm9ybUFzUG9pbnQodmVjdG9yLCByZXN1bHQpO1xuICB9XG5cbiAgdHJhbnNmb3JtRGlyZWN0aW9uKHZlY3RvciwgcmVzdWx0KSB7XG4gICAgcmV0dXJuIHRoaXMudHJhbnNmb3JtQXNWZWN0b3IodmVjdG9yLCByZXN1bHQpO1xuICB9XG5cbiAgbWFrZVJvdGF0aW9uWChyYWRpYW5zKSB7XG4gICAgcmV0dXJuIHRoaXMuaWRlbnRpdHkoKS5yb3RhdGVYKHJhZGlhbnMpO1xuICB9XG5cbiAgbWFrZVRyYW5zbGF0aW9uKHgsIHksIHopIHtcbiAgICByZXR1cm4gdGhpcy5pZGVudGl0eSgpLnRyYW5zbGF0ZShbeCwgeSwgel0pO1xuICB9XG5cbn1cbmxldCBaRVJPO1xubGV0IElERU5USVRZO1xuXG5mdW5jdGlvbiBnZXRaZXJvTWF0cml4KCkge1xuICBpZiAoIVpFUk8pIHtcbiAgICBaRVJPID0gbmV3IE1hdHJpeDQoWzAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDBdKTtcbiAgICBPYmplY3QuZnJlZXplKFpFUk8pO1xuICB9XG5cbiAgcmV0dXJuIFpFUk87XG59XG5cbmZ1bmN0aW9uIGdldElkZW50aXR5TWF0cml4KCkge1xuICBpZiAoIUlERU5USVRZKSB7XG4gICAgSURFTlRJVFkgPSBuZXcgTWF0cml4NCgpO1xuICAgIE9iamVjdC5mcmVlemUoSURFTlRJVFkpO1xuICB9XG5cbiAgcmV0dXJuIElERU5USVRZO1xufVxuXG5mdW5jdGlvbiBjaGVja1JhZGlhbnMocG9zc2libHlEZWdyZWVzKSB7XG4gIGlmIChwb3NzaWJseURlZ3JlZXMgPiBNYXRoLlBJICogMikge1xuICAgIHRocm93IEVycm9yKCdleHBlY3RlZCByYWRpYW5zJyk7XG4gIH1cbn1cblxuZnVuY3Rpb24gY29tcHV0ZUluZmluaXRlUGVyc3BlY3RpdmVPZmZDZW50ZXIocmVzdWx0LCBsZWZ0LCByaWdodCwgYm90dG9tLCB0b3AsIG5lYXIpIHtcbiAgY29uc3QgY29sdW1uMFJvdzAgPSAyICogbmVhciAvIChyaWdodCAtIGxlZnQpO1xuICBjb25zdCBjb2x1bW4xUm93MSA9IDIgKiBuZWFyIC8gKHRvcCAtIGJvdHRvbSk7XG4gIGNvbnN0IGNvbHVtbjJSb3cwID0gKHJpZ2h0ICsgbGVmdCkgLyAocmlnaHQgLSBsZWZ0KTtcbiAgY29uc3QgY29sdW1uMlJvdzEgPSAodG9wICsgYm90dG9tKSAvICh0b3AgLSBib3R0b20pO1xuICBjb25zdCBjb2x1bW4yUm93MiA9IC0xO1xuICBjb25zdCBjb2x1bW4yUm93MyA9IC0xO1xuICBjb25zdCBjb2x1bW4zUm93MiA9IC0yICogbmVhcjtcbiAgcmVzdWx0WzBdID0gY29sdW1uMFJvdzA7XG4gIHJlc3VsdFsxXSA9IDA7XG4gIHJlc3VsdFsyXSA9IDA7XG4gIHJlc3VsdFszXSA9IDA7XG4gIHJlc3VsdFs0XSA9IDA7XG4gIHJlc3VsdFs1XSA9IGNvbHVtbjFSb3cxO1xuICByZXN1bHRbNl0gPSAwO1xuICByZXN1bHRbN10gPSAwO1xuICByZXN1bHRbOF0gPSBjb2x1bW4yUm93MDtcbiAgcmVzdWx0WzldID0gY29sdW1uMlJvdzE7XG4gIHJlc3VsdFsxMF0gPSBjb2x1bW4yUm93MjtcbiAgcmVzdWx0WzExXSA9IGNvbHVtbjJSb3czO1xuICByZXN1bHRbMTJdID0gMDtcbiAgcmVzdWx0WzEzXSA9IDA7XG4gIHJlc3VsdFsxNF0gPSBjb2x1bW4zUm93MjtcbiAgcmVzdWx0WzE1XSA9IDA7XG4gIHJldHVybiByZXN1bHQ7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1tYXRyaXg0LmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///85451\n')},43897:function(__unused_webpack_module,__webpack_exports__,__webpack_require__){eval('\n// EXPORTS\n__webpack_require__.d(__webpack_exports__, {\n  "Z": function() { return /* binding */ Quaternion; }\n});\n\n// EXTERNAL MODULE: ./node_modules/@math.gl/core/dist/esm/classes/base/math-array.js\nvar math_array = __webpack_require__(6357);\n// EXTERNAL MODULE: ./node_modules/@math.gl/core/dist/esm/lib/validators.js\nvar validators = __webpack_require__(86281);\n// EXTERNAL MODULE: ./node_modules/@math.gl/core/dist/esm/classes/base/vector.js\nvar vector = __webpack_require__(89521);\n// EXTERNAL MODULE: ./node_modules/@math.gl/core/dist/esm/lib/common.js\nvar common = __webpack_require__(14034);\n// EXTERNAL MODULE: ./node_modules/gl-matrix/esm/vec3.js\nvar vec3 = __webpack_require__(77160);\n// EXTERNAL MODULE: ./node_modules/@math.gl/core/dist/esm/lib/gl-matrix-extras.js\nvar gl_matrix_extras = __webpack_require__(1031);\n;// CONCATENATED MODULE: ./node_modules/@math.gl/core/dist/esm/classes/vector4.js\n\n\n\n\n\nlet ZERO;\nclass Vector4 extends vector/* default */.Z {\n  static get ZERO() {\n    if (!ZERO) {\n      ZERO = new Vector4(0, 0, 0, 0);\n      Object.freeze(ZERO);\n    }\n\n    return ZERO;\n  }\n\n  constructor(x = 0, y = 0, z = 0, w = 0) {\n    super(-0, -0, -0, -0);\n\n    if ((0,common/* isArray */.kJ)(x) && arguments.length === 1) {\n      this.copy(x);\n    } else {\n      if (common/* config.debug */.vc.debug) {\n        (0,validators/* checkNumber */.u5)(x);\n        (0,validators/* checkNumber */.u5)(y);\n        (0,validators/* checkNumber */.u5)(z);\n        (0,validators/* checkNumber */.u5)(w);\n      }\n\n      this[0] = x;\n      this[1] = y;\n      this[2] = z;\n      this[3] = w;\n    }\n  }\n\n  set(x, y, z, w) {\n    this[0] = x;\n    this[1] = y;\n    this[2] = z;\n    this[3] = w;\n    return this.check();\n  }\n\n  copy(array) {\n    this[0] = array[0];\n    this[1] = array[1];\n    this[2] = array[2];\n    this[3] = array[3];\n    return this.check();\n  }\n\n  fromObject(object) {\n    if (common/* config.debug */.vc.debug) {\n      (0,validators/* checkNumber */.u5)(object.x);\n      (0,validators/* checkNumber */.u5)(object.y);\n      (0,validators/* checkNumber */.u5)(object.z);\n      (0,validators/* checkNumber */.u5)(object.w);\n    }\n\n    this[0] = object.x;\n    this[1] = object.y;\n    this[2] = object.z;\n    this[3] = object.w;\n    return this;\n  }\n\n  toObject(object) {\n    object.x = this[0];\n    object.y = this[1];\n    object.z = this[2];\n    object.w = this[3];\n    return object;\n  }\n\n  get ELEMENTS() {\n    return 4;\n  }\n\n  get z() {\n    return this[2];\n  }\n\n  set z(value) {\n    this[2] = (0,validators/* checkNumber */.u5)(value);\n  }\n\n  get w() {\n    return this[3];\n  }\n\n  set w(value) {\n    this[3] = (0,validators/* checkNumber */.u5)(value);\n  }\n\n  transform(matrix4) {\n    vec3/* transformMat4 */.fF(this, this, matrix4);\n    return this.check();\n  }\n\n  transformByMatrix3(matrix3) {\n    (0,gl_matrix_extras/* vec4_transformMat3 */._x)(this, this, matrix3);\n    return this.check();\n  }\n\n  transformByMatrix2(matrix2) {\n    (0,gl_matrix_extras/* vec4_transformMat2 */.G7)(this, this, matrix2);\n    return this.check();\n  }\n\n  transformByQuaternion(quaternion) {\n    vec3/* transformQuat */.VC(this, this, quaternion);\n    return this.check();\n  }\n\n  applyMatrix4(m) {\n    m.transform(this, this);\n    return this;\n  }\n\n}\n//# sourceMappingURL=vector4.js.map\n// EXTERNAL MODULE: ./node_modules/gl-matrix/esm/quat.js\nvar quat = __webpack_require__(32945);\n// EXTERNAL MODULE: ./node_modules/gl-matrix/esm/vec4.js\nvar vec4 = __webpack_require__(98333);\n;// CONCATENATED MODULE: ./node_modules/@math.gl/core/dist/esm/classes/quaternion.js\n\n\n\n\n\nconst IDENTITY_QUATERNION = [0, 0, 0, 1];\nclass Quaternion extends math_array/* default */.Z {\n  constructor(x = 0, y = 0, z = 0, w = 1) {\n    super(-0, -0, -0, -0);\n\n    if (Array.isArray(x) && arguments.length === 1) {\n      this.copy(x);\n    } else {\n      this.set(x, y, z, w);\n    }\n  }\n\n  copy(array) {\n    this[0] = array[0];\n    this[1] = array[1];\n    this[2] = array[2];\n    this[3] = array[3];\n    return this.check();\n  }\n\n  set(x, y, z, w) {\n    this[0] = x;\n    this[1] = y;\n    this[2] = z;\n    this[3] = w;\n    return this.check();\n  }\n\n  fromObject(object) {\n    this[0] = object.x;\n    this[1] = object.y;\n    this[2] = object.z;\n    this[3] = object.w;\n    return this.check();\n  }\n\n  fromMatrix3(m) {\n    quat/* fromMat3 */.bz(this, m);\n    return this.check();\n  }\n\n  fromAxisRotation(axis, rad) {\n    quat/* setAxisAngle */.yY(this, axis, rad);\n    return this.check();\n  }\n\n  identity() {\n    quat/* identity */.yR(this);\n    return this.check();\n  }\n\n  setAxisAngle(axis, rad) {\n    return this.fromAxisRotation(axis, rad);\n  }\n\n  get ELEMENTS() {\n    return 4;\n  }\n\n  get x() {\n    return this[0];\n  }\n\n  set x(value) {\n    this[0] = (0,validators/* checkNumber */.u5)(value);\n  }\n\n  get y() {\n    return this[1];\n  }\n\n  set y(value) {\n    this[1] = (0,validators/* checkNumber */.u5)(value);\n  }\n\n  get z() {\n    return this[2];\n  }\n\n  set z(value) {\n    this[2] = (0,validators/* checkNumber */.u5)(value);\n  }\n\n  get w() {\n    return this[3];\n  }\n\n  set w(value) {\n    this[3] = (0,validators/* checkNumber */.u5)(value);\n  }\n\n  len() {\n    return quat/* length */.kE(this);\n  }\n\n  lengthSquared() {\n    return quat/* squaredLength */.we(this);\n  }\n\n  dot(a) {\n    return quat/* dot */.AK(this, a);\n  }\n\n  rotationTo(vectorA, vectorB) {\n    quat/* rotationTo */.b0(this, vectorA, vectorB);\n    return this.check();\n  }\n\n  add(a) {\n    quat/* add */.IH(this, this, a);\n    return this.check();\n  }\n\n  calculateW() {\n    quat/* calculateW */.ZY(this, this);\n    return this.check();\n  }\n\n  conjugate() {\n    quat/* conjugate */.Kx(this, this);\n    return this.check();\n  }\n\n  invert() {\n    quat/* invert */.U_(this, this);\n    return this.check();\n  }\n\n  lerp(a, b, t) {\n    if (t === undefined) {\n      return this.lerp(this, a, b);\n    }\n\n    quat/* lerp */.t7(this, a, b, t);\n    return this.check();\n  }\n\n  multiplyRight(a) {\n    quat/* multiply */.Jp(this, this, a);\n    return this.check();\n  }\n\n  multiplyLeft(a) {\n    quat/* multiply */.Jp(this, a, this);\n    return this.check();\n  }\n\n  normalize() {\n    const length = this.len();\n    const l = length > 0 ? 1 / length : 0;\n    this[0] = this[0] * l;\n    this[1] = this[1] * l;\n    this[2] = this[2] * l;\n    this[3] = this[3] * l;\n\n    if (length === 0) {\n      this[3] = 1;\n    }\n\n    return this.check();\n  }\n\n  rotateX(rad) {\n    quat/* rotateX */.lM(this, this, rad);\n    return this.check();\n  }\n\n  rotateY(rad) {\n    quat/* rotateY */.uD(this, this, rad);\n    return this.check();\n  }\n\n  rotateZ(rad) {\n    quat/* rotateZ */.jI(this, this, rad);\n    return this.check();\n  }\n\n  scale(b) {\n    quat/* scale */.bA(this, this, b);\n    return this.check();\n  }\n\n  slerp(arg0, arg1, arg2) {\n    let start;\n    let target;\n    let ratio;\n\n    switch (arguments.length) {\n      case 1:\n        ({\n          start = IDENTITY_QUATERNION,\n          target,\n          ratio\n        } = arg0);\n        break;\n\n      case 2:\n        start = this;\n        target = arg0;\n        ratio = arg1;\n        break;\n\n      default:\n        start = arg0;\n        target = arg1;\n        ratio = arg2;\n    }\n\n    quat/* slerp */.ZA(this, start, target, ratio);\n    return this.check();\n  }\n\n  transformVector4(vector, result = new Vector4()) {\n    vec4/* transformQuat */.VC(result, vector, this);\n    return (0,validators/* checkVector */.IL)(result, 4);\n  }\n\n  lengthSq() {\n    return this.lengthSquared();\n  }\n\n  setFromAxisAngle(axis, rad) {\n    return this.setAxisAngle(axis, rad);\n  }\n\n  premultiply(a) {\n    return this.multiplyLeft(a);\n  }\n\n  multiply(a) {\n    return this.multiplyRight(a);\n  }\n\n}\n//# sourceMappingURL=quaternion.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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Q0E7O0FBRUE7QUFDQSxJQUFJLG9CQUFZO0FBQ2hCO0FBQ0E7O0FBRUE7QUFDQSxJQUFJLG9CQUFZO0FBQ2hCO0FBQ0E7O0FBRUE7QUFDQSxJQUFJLGtCQUFVO0FBQ2Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLElBQUksa0JBQVU7QUFDZDtBQUNBOztBQUVBLHdDQUF3QyxPQUFPO0FBQy9DLElBQUksMEJBQWtCO0FBQ3RCLFdBQVcsa0NBQVc7QUFDdEI7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly92dWUzLXdlYnBhY2s1Ly4vbm9kZV9tb2R1bGVzL0BtYXRoLmdsL2NvcmUvZGlzdC9lc20vY2xhc3Nlcy92ZWN0b3I0LmpzPzBiY2IiLCJ3ZWJwYWNrOi8vdnVlMy13ZWJwYWNrNS8uL25vZGVfbW9kdWxlcy9AbWF0aC5nbC9jb3JlL2Rpc3QvZXNtL2NsYXNzZXMvcXVhdGVybmlvbi5qcz82Mzc5Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBWZWN0b3IgZnJvbSAnLi9iYXNlL3ZlY3Rvcic7XG5pbXBvcnQgeyBjb25maWcsIGlzQXJyYXkgfSBmcm9tICcuLi9saWIvY29tbW9uJztcbmltcG9ydCB7IGNoZWNrTnVtYmVyIH0gZnJvbSAnLi4vbGliL3ZhbGlkYXRvcnMnO1xuaW1wb3J0ICogYXMgdmVjNCBmcm9tICdnbC1tYXRyaXgvdmVjMyc7XG5pbXBvcnQgeyB2ZWM0X3RyYW5zZm9ybU1hdDIsIHZlYzRfdHJhbnNmb3JtTWF0MyB9IGZyb20gJy4uL2xpYi9nbC1tYXRyaXgtZXh0cmFzJztcbmxldCBaRVJPO1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgVmVjdG9yNCBleHRlbmRzIFZlY3RvciB7XG4gIHN0YXRpYyBnZXQgWkVSTygpIHtcbiAgICBpZiAoIVpFUk8pIHtcbiAgICAgIFpFUk8gPSBuZXcgVmVjdG9yNCgwLCAwLCAwLCAwKTtcbiAgICAgIE9iamVjdC5mcmVlemUoWkVSTyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIFpFUk87XG4gIH1cblxuICBjb25zdHJ1Y3Rvcih4ID0gMCwgeSA9IDAsIHogPSAwLCB3ID0gMCkge1xuICAgIHN1cGVyKC0wLCAtMCwgLTAsIC0wKTtcblxuICAgIGlmIChpc0FycmF5KHgpICYmIGFyZ3VtZW50cy5sZW5ndGggPT09IDEpIHtcbiAgICAgIHRoaXMuY29weSh4KTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKGNvbmZpZy5kZWJ1Zykge1xuICAgICAgICBjaGVja051bWJlcih4KTtcbiAgICAgICAgY2hlY2tOdW1iZXIoeSk7XG4gICAgICAgIGNoZWNrTnVtYmVyKHopO1xuICAgICAgICBjaGVja051bWJlcih3KTtcbiAgICAgIH1cblxuICAgICAgdGhpc1swXSA9IHg7XG4gICAgICB0aGlzWzFdID0geTtcbiAgICAgIHRoaXNbMl0gPSB6O1xuICAgICAgdGhpc1szXSA9IHc7XG4gICAgfVxuICB9XG5cbiAgc2V0KHgsIHksIHosIHcpIHtcbiAgICB0aGlzWzBdID0geDtcbiAgICB0aGlzWzFdID0geTtcbiAgICB0aGlzWzJdID0gejtcbiAgICB0aGlzWzNdID0gdztcbiAgICByZXR1cm4gdGhpcy5jaGVjaygpO1xuICB9XG5cbiAgY29weShhcnJheSkge1xuICAgIHRoaXNbMF0gPSBhcnJheVswXTtcbiAgICB0aGlzWzFdID0gYXJyYXlbMV07XG4gICAgdGhpc1syXSA9IGFycmF5WzJdO1xuICAgIHRoaXNbM10gPSBhcnJheVszXTtcbiAgICByZXR1cm4gdGhpcy5jaGVjaygpO1xuICB9XG5cbiAgZnJvbU9iamVjdChvYmplY3QpIHtcbiAgICBpZiAoY29uZmlnLmRlYnVnKSB7XG4gICAgICBjaGVja051bWJlcihvYmplY3QueCk7XG4gICAgICBjaGVja051bWJlcihvYmplY3QueSk7XG4gICAgICBjaGVja051bWJlcihvYmplY3Queik7XG4gICAgICBjaGVja051bWJlcihvYmplY3Qudyk7XG4gICAgfVxuXG4gICAgdGhpc1swXSA9IG9iamVjdC54O1xuICAgIHRoaXNbMV0gPSBvYmplY3QueTtcbiAgICB0aGlzWzJdID0gb2JqZWN0Lno7XG4gICAgdGhpc1szXSA9IG9iamVjdC53O1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgdG9PYmplY3Qob2JqZWN0KSB7XG4gICAgb2JqZWN0LnggPSB0aGlzWzBdO1xuICAgIG9iamVjdC55ID0gdGhpc1sxXTtcbiAgICBvYmplY3QueiA9IHRoaXNbMl07XG4gICAgb2JqZWN0LncgPSB0aGlzWzNdO1xuICAgIHJldHVybiBvYmplY3Q7XG4gIH1cblxuICBnZXQgRUxFTUVOVFMoKSB7XG4gICAgcmV0dXJuIDQ7XG4gIH1cblxuICBnZXQgeigpIHtcbiAgICByZXR1cm4gdGhpc1syXTtcbiAgfVxuXG4gIHNldCB6KHZhbHVlKSB7XG4gICAgdGhpc1syXSA9IGNoZWNrTnVtYmVyKHZhbHVlKTtcbiAgfVxuXG4gIGdldCB3KCkge1xuICAgIHJldHVybiB0aGlzWzNdO1xuICB9XG5cbiAgc2V0IHcodmFsdWUpIHtcbiAgICB0aGlzWzNdID0gY2hlY2tOdW1iZXIodmFsdWUpO1xuICB9XG5cbiAgdHJhbnNmb3JtKG1hdHJpeDQpIHtcbiAgICB2ZWM0LnRyYW5zZm9ybU1hdDQodGhpcywgdGhpcywgbWF0cml4NCk7XG4gICAgcmV0dXJuIHRoaXMuY2hlY2soKTtcbiAgfVxuXG4gIHRyYW5zZm9ybUJ5TWF0cml4MyhtYXRyaXgzKSB7XG4gICAgdmVjNF90cmFuc2Zvcm1NYXQzKHRoaXMsIHRoaXMsIG1hdHJpeDMpO1xuICAgIHJldHVybiB0aGlzLmNoZWNrKCk7XG4gIH1cblxuICB0cmFuc2Zvcm1CeU1hdHJpeDIobWF0cml4Mikge1xuICAgIHZlYzRfdHJhbnNmb3JtTWF0Mih0aGlzLCB0aGlzLCBtYXRyaXgyKTtcbiAgICByZXR1cm4gdGhpcy5jaGVjaygpO1xuICB9XG5cbiAgdHJhbnNmb3JtQnlRdWF0ZXJuaW9uKHF1YXRlcm5pb24pIHtcbiAgICB2ZWM0LnRyYW5zZm9ybVF1YXQodGhpcywgdGhpcywgcXVhdGVybmlvbik7XG4gICAgcmV0dXJuIHRoaXMuY2hlY2soKTtcbiAgfVxuXG4gIGFwcGx5TWF0cml4NChtKSB7XG4gICAgbS50cmFuc2Zvcm0odGhpcywgdGhpcyk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dmVjdG9yNC5qcy5tYXAiLCJpbXBvcnQgTWF0aEFycmF5IGZyb20gJy4vYmFzZS9tYXRoLWFycmF5JztcbmltcG9ydCB7IGNoZWNrTnVtYmVyLCBjaGVja1ZlY3RvciB9IGZyb20gJy4uL2xpYi92YWxpZGF0b3JzJztcbmltcG9ydCBWZWN0b3I0IGZyb20gJy4vdmVjdG9yNCc7XG5pbXBvcnQgKiBhcyBxdWF0IGZyb20gJ2dsLW1hdHJpeC9xdWF0JztcbmltcG9ydCAqIGFzIHZlYzQgZnJvbSAnZ2wtbWF0cml4L3ZlYzQnO1xuY29uc3QgSURFTlRJVFlfUVVBVEVSTklPTiA9IFswLCAwLCAwLCAxXTtcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFF1YXRlcm5pb24gZXh0ZW5kcyBNYXRoQXJyYXkge1xuICBjb25zdHJ1Y3Rvcih4ID0gMCwgeSA9IDAsIHogPSAwLCB3ID0gMSkge1xuICAgIHN1cGVyKC0wLCAtMCwgLTAsIC0wKTtcblxuICAgIGlmIChBcnJheS5pc0FycmF5KHgpICYmIGFyZ3VtZW50cy5sZW5ndGggPT09IDEpIHtcbiAgICAgIHRoaXMuY29weSh4KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5zZXQoeCwgeSwgeiwgdyk7XG4gICAgfVxuICB9XG5cbiAgY29weShhcnJheSkge1xuICAgIHRoaXNbMF0gPSBhcnJheVswXTtcbiAgICB0aGlzWzFdID0gYXJyYXlbMV07XG4gICAgdGhpc1syXSA9IGFycmF5WzJdO1xuICAgIHRoaXNbM10gPSBhcnJheVszXTtcbiAgICByZXR1cm4gdGhpcy5jaGVjaygpO1xuICB9XG5cbiAgc2V0KHgsIHksIHosIHcpIHtcbiAgICB0aGlzWzBdID0geDtcbiAgICB0aGlzWzFdID0geTtcbiAgICB0aGlzWzJdID0gejtcbiAgICB0aGlzWzNdID0gdztcbiAgICByZXR1cm4gdGhpcy5jaGVjaygpO1xuICB9XG5cbiAgZnJvbU9iamVjdChvYmplY3QpIHtcbiAgICB0aGlzWzBdID0gb2JqZWN0Lng7XG4gICAgdGhpc1sxXSA9IG9iamVjdC55O1xuICAgIHRoaXNbMl0gPSBvYmplY3QuejtcbiAgICB0aGlzWzNdID0gb2JqZWN0Lnc7XG4gICAgcmV0dXJuIHRoaXMuY2hlY2soKTtcbiAgfVxuXG4gIGZyb21NYXRyaXgzKG0pIHtcbiAgICBxdWF0LmZyb21NYXQzKHRoaXMsIG0pO1xuICAgIHJldHVybiB0aGlzLmNoZWNrKCk7XG4gIH1cblxuICBmcm9tQXhpc1JvdGF0aW9uKGF4aXMsIHJhZCkge1xuICAgIHF1YXQuc2V0QXhpc0FuZ2xlKHRoaXMsIGF4aXMsIHJhZCk7XG4gICAgcmV0dXJuIHRoaXMuY2hlY2soKTtcbiAgfVxuXG4gIGlkZW50aXR5KCkge1xuICAgIHF1YXQuaWRlbnRpdHkodGhpcyk7XG4gICAgcmV0dXJuIHRoaXMuY2hlY2soKTtcbiAgfVxuXG4gIHNldEF4aXNBbmdsZShheGlzLCByYWQpIHtcbiAgICByZXR1cm4gdGhpcy5mcm9tQXhpc1JvdGF0aW9uKGF4aXMsIHJhZCk7XG4gIH1cblxuICBnZXQgRUxFTUVOVFMoKSB7XG4gICAgcmV0dXJuIDQ7XG4gIH1cblxuICBnZXQgeCgpIHtcbiAgICByZXR1cm4gdGhpc1swXTtcbiAgfVxuXG4gIHNldCB4KHZhbHVlKSB7XG4gICAgdGhpc1swXSA9IGNoZWNrTnVtYmVyKHZhbHVlKTtcbiAgfVxuXG4gIGdldCB5KCkge1xuICAgIHJldHVybiB0aGlzWzFdO1xuICB9XG5cbiAgc2V0IHkodmFsdWUpIHtcbiAgICB0aGlzWzFdID0gY2hlY2tOdW1iZXIodmFsdWUpO1xuICB9XG5cbiAgZ2V0IHooKSB7XG4gICAgcmV0dXJuIHRoaXNbMl07XG4gIH1cblxuICBzZXQgeih2YWx1ZSkge1xuICAgIHRoaXNbMl0gPSBjaGVja051bWJlcih2YWx1ZSk7XG4gIH1cblxuICBnZXQgdygpIHtcbiAgICByZXR1cm4gdGhpc1szXTtcbiAgfVxuXG4gIHNldCB3KHZhbHVlKSB7XG4gICAgdGhpc1szXSA9IGNoZWNrTnVtYmVyKHZhbHVlKTtcbiAgfVxuXG4gIGxlbigpIHtcbiAgICByZXR1cm4gcXVhdC5sZW5ndGgodGhpcyk7XG4gIH1cblxuICBsZW5ndGhTcXVhcmVkKCkge1xuICAgIHJldHVybiBxdWF0LnNxdWFyZWRMZW5ndGgodGhpcyk7XG4gIH1cblxuICBkb3QoYSkge1xuICAgIHJldHVybiBxdWF0LmRvdCh0aGlzLCBhKTtcbiAgfVxuXG4gIHJvdGF0aW9uVG8odmVjdG9yQSwgdmVjdG9yQikge1xuICAgIHF1YXQucm90YXRpb25Ubyh0aGlzLCB2ZWN0b3JBLCB2ZWN0b3JCKTtcbiAgICByZXR1cm4gdGhpcy5jaGVjaygpO1xuICB9XG5cbiAgYWRkKGEpIHtcbiAgICBxdWF0LmFkZCh0aGlzLCB0aGlzLCBhKTtcbiAgICByZXR1cm4gdGhpcy5jaGVjaygpO1xuICB9XG5cbiAgY2FsY3VsYXRlVygpIHtcbiAgICBxdWF0LmNhbGN1bGF0ZVcodGhpcywgdGhpcyk7XG4gICAgcmV0dXJuIHRoaXMuY2hlY2soKTtcbiAgfVxuXG4gIGNvbmp1Z2F0ZSgpIHtcbiAgICBxdWF0LmNvbmp1Z2F0ZSh0aGlzLCB0aGlzKTtcbiAgICByZXR1cm4gdGhpcy5jaGVjaygpO1xuICB9XG5cbiAgaW52ZXJ0KCkge1xuICAgIHF1YXQuaW52ZXJ0KHRoaXMsIHRoaXMpO1xuICAgIHJldHVybiB0aGlzLmNoZWNrKCk7XG4gIH1cblxuICBsZXJwKGEsIGIsIHQpIHtcbiAgICBpZiAodCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gdGhpcy5sZXJwKHRoaXMsIGEsIGIpO1xuICAgIH1cblxuICAgIHF1YXQubGVycCh0aGlzLCBhLCBiLCB0KTtcbiAgICByZXR1cm4gdGhpcy5jaGVjaygpO1xuICB9XG5cbiAgbXVsdGlwbHlSaWdodChhKSB7XG4gICAgcXVhdC5tdWx0aXBseSh0aGlzLCB0aGlzLCBhKTtcbiAgICByZXR1cm4gdGhpcy5jaGVjaygpO1xuICB9XG5cbiAgbXVsdGlwbHlMZWZ0KGEpIHtcbiAgICBxdWF0Lm11bHRpcGx5KHRoaXMsIGEsIHRoaXMpO1xuICAgIHJldHVybiB0aGlzLmNoZWNrKCk7XG4gIH1cblxuICBub3JtYWxpemUoKSB7XG4gICAgY29uc3QgbGVuZ3RoID0gdGhpcy5sZW4oKTtcbiAgICBjb25zdCBsID0gbGVuZ3RoID4gMCA/IDEgLyBsZW5ndGggOiAwO1xuICAgIHRoaXNbMF0gPSB0aGlzWzBdICogbDtcbiAgICB0aGlzWzFdID0gdGhpc1sxXSAqIGw7XG4gICAgdGhpc1syXSA9IHRoaXNbMl0gKiBsO1xuICAgIHRoaXNbM10gPSB0aGlzWzNdICogbDtcblxuICAgIGlmIChsZW5ndGggPT09IDApIHtcbiAgICAgIHRoaXNbM10gPSAxO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLmNoZWNrKCk7XG4gIH1cblxuICByb3RhdGVYKHJhZCkge1xuICAgIHF1YXQucm90YXRlWCh0aGlzLCB0aGlzLCByYWQpO1xuICAgIHJldHVybiB0aGlzLmNoZWNrKCk7XG4gIH1cblxuICByb3RhdGVZKHJhZCkge1xuICAgIHF1YXQucm90YXRlWSh0aGlzLCB0aGlzLCByYWQpO1xuICAgIHJldHVybiB0aGlzLmNoZWNrKCk7XG4gIH1cblxuICByb3RhdGVaKHJhZCkge1xuICAgIHF1YXQucm90YXRlWih0aGlzLCB0aGlzLCByYWQpO1xuICAgIHJldHVybiB0aGlzLmNoZWNrKCk7XG4gIH1cblxuICBzY2FsZShiKSB7XG4gICAgcXVhdC5zY2FsZSh0aGlzLCB0aGlzLCBiKTtcbiAgICByZXR1cm4gdGhpcy5jaGVjaygpO1xuICB9XG5cbiAgc2xlcnAoYXJnMCwgYXJnMSwgYXJnMikge1xuICAgIGxldCBzdGFydDtcbiAgICBsZXQgdGFyZ2V0O1xuICAgIGxldCByYXRpbztcblxuICAgIHN3aXRjaCAoYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgY2FzZSAxOlxuICAgICAgICAoe1xuICAgICAgICAgIHN0YXJ0ID0gSURFTlRJVFlfUVVBVEVSTklPTixcbiAgICAgICAgICB0YXJnZXQsXG4gICAgICAgICAgcmF0aW9cbiAgICAgICAgfSA9IGFyZzApO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSAyOlxuICAgICAgICBzdGFydCA9IHRoaXM7XG4gICAgICAgIHRhcmdldCA9IGFyZzA7XG4gICAgICAgIHJhdGlvID0gYXJnMTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHN0YXJ0ID0gYXJnMDtcbiAgICAgICAgdGFyZ2V0ID0gYXJnMTtcbiAgICAgICAgcmF0aW8gPSBhcmcyO1xuICAgIH1cblxuICAgIHF1YXQuc2xlcnAodGhpcywgc3RhcnQsIHRhcmdldCwgcmF0aW8pO1xuICAgIHJldHVybiB0aGlzLmNoZWNrKCk7XG4gIH1cblxuICB0cmFuc2Zvcm1WZWN0b3I0KHZlY3RvciwgcmVzdWx0ID0gbmV3IFZlY3RvcjQoKSkge1xuICAgIHZlYzQudHJhbnNmb3JtUXVhdChyZXN1bHQsIHZlY3RvciwgdGhpcyk7XG4gICAgcmV0dXJuIGNoZWNrVmVjdG9yKHJlc3VsdCwgNCk7XG4gIH1cblxuICBsZW5ndGhTcSgpIHtcbiAgICByZXR1cm4gdGhpcy5sZW5ndGhTcXVhcmVkKCk7XG4gIH1cblxuICBzZXRGcm9tQXhpc0FuZ2xlKGF4aXMsIHJhZCkge1xuICAgIHJldHVybiB0aGlzLnNldEF4aXNBbmdsZShheGlzLCByYWQpO1xuICB9XG5cbiAgcHJlbXVsdGlwbHkoYSkge1xuICAgIHJldHVybiB0aGlzLm11bHRpcGx5TGVmdChhKTtcbiAgfVxuXG4gIG11bHRpcGx5KGEpIHtcbiAgICByZXR1cm4gdGhpcy5tdWx0aXBseVJpZ2h0KGEpO1xuICB9XG5cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXF1YXRlcm5pb24uanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///43897\n')},43855:function(__unused_webpack_module,__webpack_exports__,__webpack_require__){eval('/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "Z": function() { return /* binding */ Vector3; }\n/* harmony export */ });\n/* harmony import */ var _base_vector__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(89521);\n/* harmony import */ var _lib_common__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(14034);\n/* harmony import */ var _lib_validators__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(86281);\n/* harmony import */ var gl_matrix_vec3__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(77160);\n/* harmony import */ var _lib_gl_matrix_extras__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(1031);\n\n\n\n\n\nconst ORIGIN = [0, 0, 0];\nlet ZERO;\nclass Vector3 extends _base_vector__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .Z {\n  static get ZERO() {\n    if (!ZERO) {\n      ZERO = new Vector3(0, 0, 0);\n      Object.freeze(ZERO);\n    }\n\n    return ZERO;\n  }\n\n  constructor(x = 0, y = 0, z = 0) {\n    super(-0, -0, -0);\n\n    if (arguments.length === 1 && (0,_lib_common__WEBPACK_IMPORTED_MODULE_1__/* .isArray */ .kJ)(x)) {\n      this.copy(x);\n    } else {\n      if (_lib_common__WEBPACK_IMPORTED_MODULE_1__/* .config.debug */ .vc.debug) {\n        (0,_lib_validators__WEBPACK_IMPORTED_MODULE_2__/* .checkNumber */ .u5)(x);\n        (0,_lib_validators__WEBPACK_IMPORTED_MODULE_2__/* .checkNumber */ .u5)(y);\n        (0,_lib_validators__WEBPACK_IMPORTED_MODULE_2__/* .checkNumber */ .u5)(z);\n      }\n\n      this[0] = x;\n      this[1] = y;\n      this[2] = z;\n    }\n  }\n\n  set(x, y, z) {\n    this[0] = x;\n    this[1] = y;\n    this[2] = z;\n    return this.check();\n  }\n\n  copy(array) {\n    this[0] = array[0];\n    this[1] = array[1];\n    this[2] = array[2];\n    return this.check();\n  }\n\n  fromObject(object) {\n    if (_lib_common__WEBPACK_IMPORTED_MODULE_1__/* .config.debug */ .vc.debug) {\n      (0,_lib_validators__WEBPACK_IMPORTED_MODULE_2__/* .checkNumber */ .u5)(object.x);\n      (0,_lib_validators__WEBPACK_IMPORTED_MODULE_2__/* .checkNumber */ .u5)(object.y);\n      (0,_lib_validators__WEBPACK_IMPORTED_MODULE_2__/* .checkNumber */ .u5)(object.z);\n    }\n\n    this[0] = object.x;\n    this[1] = object.y;\n    this[2] = object.z;\n    return this.check();\n  }\n\n  toObject(object) {\n    object.x = this[0];\n    object.y = this[1];\n    object.z = this[2];\n    return object;\n  }\n\n  get ELEMENTS() {\n    return 3;\n  }\n\n  get z() {\n    return this[2];\n  }\n\n  set z(value) {\n    this[2] = (0,_lib_validators__WEBPACK_IMPORTED_MODULE_2__/* .checkNumber */ .u5)(value);\n  }\n\n  angle(vector) {\n    return gl_matrix_vec3__WEBPACK_IMPORTED_MODULE_3__/* .angle */ .EU(this, vector);\n  }\n\n  cross(vector) {\n    gl_matrix_vec3__WEBPACK_IMPORTED_MODULE_3__/* .cross */ .kC(this, this, vector);\n    return this.check();\n  }\n\n  rotateX({\n    radians,\n    origin = ORIGIN\n  }) {\n    gl_matrix_vec3__WEBPACK_IMPORTED_MODULE_3__/* .rotateX */ .lM(this, this, origin, radians);\n    return this.check();\n  }\n\n  rotateY({\n    radians,\n    origin = ORIGIN\n  }) {\n    gl_matrix_vec3__WEBPACK_IMPORTED_MODULE_3__/* .rotateY */ .uD(this, this, origin, radians);\n    return this.check();\n  }\n\n  rotateZ({\n    radians,\n    origin = ORIGIN\n  }) {\n    gl_matrix_vec3__WEBPACK_IMPORTED_MODULE_3__/* .rotateZ */ .jI(this, this, origin, radians);\n    return this.check();\n  }\n\n  transform(matrix4) {\n    return this.transformAsPoint(matrix4);\n  }\n\n  transformAsPoint(matrix4) {\n    gl_matrix_vec3__WEBPACK_IMPORTED_MODULE_3__/* .transformMat4 */ .fF(this, this, matrix4);\n    return this.check();\n  }\n\n  transformAsVector(matrix4) {\n    (0,_lib_gl_matrix_extras__WEBPACK_IMPORTED_MODULE_4__/* .vec3_transformMat4AsVector */ .pL)(this, this, matrix4);\n    return this.check();\n  }\n\n  transformByMatrix3(matrix3) {\n    gl_matrix_vec3__WEBPACK_IMPORTED_MODULE_3__/* .transformMat3 */ .kK(this, this, matrix3);\n    return this.check();\n  }\n\n  transformByMatrix2(matrix2) {\n    (0,_lib_gl_matrix_extras__WEBPACK_IMPORTED_MODULE_4__/* .vec3_transformMat2 */ .eQ)(this, this, matrix2);\n    return this.check();\n  }\n\n  transformByQuaternion(quaternion) {\n    gl_matrix_vec3__WEBPACK_IMPORTED_MODULE_3__/* .transformQuat */ .VC(this, this, quaternion);\n    return this.check();\n  }\n\n}\n//# sourceMappingURL=vector3.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNDM4NTUuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFBbUM7QUFDYTtBQUNBO0FBQ1Q7QUFDa0Q7QUFDekY7QUFDQTtBQUNlLHNCQUFzQiw2REFBTTtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxrQ0FBa0MsOERBQU87QUFDekM7QUFDQSxNQUFNO0FBQ04sVUFBVSxxRUFBWTtBQUN0QixRQUFRLHNFQUFXO0FBQ25CLFFBQVEsc0VBQVc7QUFDbkIsUUFBUSxzRUFBVztBQUNuQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxRQUFRLHFFQUFZO0FBQ3BCLE1BQU0sc0VBQVc7QUFDakIsTUFBTSxzRUFBVztBQUNqQixNQUFNLHNFQUFXO0FBQ2pCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxjQUFjLHNFQUFXO0FBQ3pCOztBQUVBO0FBQ0EsV0FBVywyREFBVTtBQUNyQjs7QUFFQTtBQUNBLElBQUksMkRBQVU7QUFDZDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxJQUFJLDZEQUFZO0FBQ2hCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILElBQUksNkRBQVk7QUFDaEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsSUFBSSw2REFBWTtBQUNoQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLElBQUksbUVBQWtCO0FBQ3RCO0FBQ0E7O0FBRUE7QUFDQSxJQUFJLDJGQUEwQjtBQUM5QjtBQUNBOztBQUVBO0FBQ0EsSUFBSSxtRUFBa0I7QUFDdEI7QUFDQTs7QUFFQTtBQUNBLElBQUksbUZBQWtCO0FBQ3RCO0FBQ0E7O0FBRUE7QUFDQSxJQUFJLG1FQUFrQjtBQUN0QjtBQUNBOztBQUVBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly92dWUzLXdlYnBhY2s1Ly4vbm9kZV9tb2R1bGVzL0BtYXRoLmdsL2NvcmUvZGlzdC9lc20vY2xhc3Nlcy92ZWN0b3IzLmpzP2Q0ZmQiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IFZlY3RvciBmcm9tICcuL2Jhc2UvdmVjdG9yJztcbmltcG9ydCB7IGNvbmZpZywgaXNBcnJheSB9IGZyb20gJy4uL2xpYi9jb21tb24nO1xuaW1wb3J0IHsgY2hlY2tOdW1iZXIgfSBmcm9tICcuLi9saWIvdmFsaWRhdG9ycyc7XG5pbXBvcnQgKiBhcyB2ZWMzIGZyb20gJ2dsLW1hdHJpeC92ZWMzJztcbmltcG9ydCB7IHZlYzNfdHJhbnNmb3JtTWF0MiwgdmVjM190cmFuc2Zvcm1NYXQ0QXNWZWN0b3IgfSBmcm9tICcuLi9saWIvZ2wtbWF0cml4LWV4dHJhcyc7XG5jb25zdCBPUklHSU4gPSBbMCwgMCwgMF07XG5sZXQgWkVSTztcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFZlY3RvcjMgZXh0ZW5kcyBWZWN0b3Ige1xuICBzdGF0aWMgZ2V0IFpFUk8oKSB7XG4gICAgaWYgKCFaRVJPKSB7XG4gICAgICBaRVJPID0gbmV3IFZlY3RvcjMoMCwgMCwgMCk7XG4gICAgICBPYmplY3QuZnJlZXplKFpFUk8pO1xuICAgIH1cblxuICAgIHJldHVybiBaRVJPO1xuICB9XG5cbiAgY29uc3RydWN0b3IoeCA9IDAsIHkgPSAwLCB6ID0gMCkge1xuICAgIHN1cGVyKC0wLCAtMCwgLTApO1xuXG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEgJiYgaXNBcnJheSh4KSkge1xuICAgICAgdGhpcy5jb3B5KHgpO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoY29uZmlnLmRlYnVnKSB7XG4gICAgICAgIGNoZWNrTnVtYmVyKHgpO1xuICAgICAgICBjaGVja051bWJlcih5KTtcbiAgICAgICAgY2hlY2tOdW1iZXIoeik7XG4gICAgICB9XG5cbiAgICAgIHRoaXNbMF0gPSB4O1xuICAgICAgdGhpc1sxXSA9IHk7XG4gICAgICB0aGlzWzJdID0gejtcbiAgICB9XG4gIH1cblxuICBzZXQoeCwgeSwgeikge1xuICAgIHRoaXNbMF0gPSB4O1xuICAgIHRoaXNbMV0gPSB5O1xuICAgIHRoaXNbMl0gPSB6O1xuICAgIHJldHVybiB0aGlzLmNoZWNrKCk7XG4gIH1cblxuICBjb3B5KGFycmF5KSB7XG4gICAgdGhpc1swXSA9IGFycmF5WzBdO1xuICAgIHRoaXNbMV0gPSBhcnJheVsxXTtcbiAgICB0aGlzWzJdID0gYXJyYXlbMl07XG4gICAgcmV0dXJuIHRoaXMuY2hlY2soKTtcbiAgfVxuXG4gIGZyb21PYmplY3Qob2JqZWN0KSB7XG4gICAgaWYgKGNvbmZpZy5kZWJ1Zykge1xuICAgICAgY2hlY2tOdW1iZXIob2JqZWN0LngpO1xuICAgICAgY2hlY2tOdW1iZXIob2JqZWN0LnkpO1xuICAgICAgY2hlY2tOdW1iZXIob2JqZWN0LnopO1xuICAgIH1cblxuICAgIHRoaXNbMF0gPSBvYmplY3QueDtcbiAgICB0aGlzWzFdID0gb2JqZWN0Lnk7XG4gICAgdGhpc1syXSA9IG9iamVjdC56O1xuICAgIHJldHVybiB0aGlzLmNoZWNrKCk7XG4gIH1cblxuICB0b09iamVjdChvYmplY3QpIHtcbiAgICBvYmplY3QueCA9IHRoaXNbMF07XG4gICAgb2JqZWN0LnkgPSB0aGlzWzFdO1xuICAgIG9iamVjdC56ID0gdGhpc1syXTtcbiAgICByZXR1cm4gb2JqZWN0O1xuICB9XG5cbiAgZ2V0IEVMRU1FTlRTKCkge1xuICAgIHJldHVybiAzO1xuICB9XG5cbiAgZ2V0IHooKSB7XG4gICAgcmV0dXJuIHRoaXNbMl07XG4gIH1cblxuICBzZXQgeih2YWx1ZSkge1xuICAgIHRoaXNbMl0gPSBjaGVja051bWJlcih2YWx1ZSk7XG4gIH1cblxuICBhbmdsZSh2ZWN0b3IpIHtcbiAgICByZXR1cm4gdmVjMy5hbmdsZSh0aGlzLCB2ZWN0b3IpO1xuICB9XG5cbiAgY3Jvc3ModmVjdG9yKSB7XG4gICAgdmVjMy5jcm9zcyh0aGlzLCB0aGlzLCB2ZWN0b3IpO1xuICAgIHJldHVybiB0aGlzLmNoZWNrKCk7XG4gIH1cblxuICByb3RhdGVYKHtcbiAgICByYWRpYW5zLFxuICAgIG9yaWdpbiA9IE9SSUdJTlxuICB9KSB7XG4gICAgdmVjMy5yb3RhdGVYKHRoaXMsIHRoaXMsIG9yaWdpbiwgcmFkaWFucyk7XG4gICAgcmV0dXJuIHRoaXMuY2hlY2soKTtcbiAgfVxuXG4gIHJvdGF0ZVkoe1xuICAgIHJhZGlhbnMsXG4gICAgb3JpZ2luID0gT1JJR0lOXG4gIH0pIHtcbiAgICB2ZWMzLnJvdGF0ZVkodGhpcywgdGhpcywgb3JpZ2luLCByYWRpYW5zKTtcbiAgICByZXR1cm4gdGhpcy5jaGVjaygpO1xuICB9XG5cbiAgcm90YXRlWih7XG4gICAgcmFkaWFucyxcbiAgICBvcmlnaW4gPSBPUklHSU5cbiAgfSkge1xuICAgIHZlYzMucm90YXRlWih0aGlzLCB0aGlzLCBvcmlnaW4sIHJhZGlhbnMpO1xuICAgIHJldHVybiB0aGlzLmNoZWNrKCk7XG4gIH1cblxuICB0cmFuc2Zvcm0obWF0cml4NCkge1xuICAgIHJldHVybiB0aGlzLnRyYW5zZm9ybUFzUG9pbnQobWF0cml4NCk7XG4gIH1cblxuICB0cmFuc2Zvcm1Bc1BvaW50KG1hdHJpeDQpIHtcbiAgICB2ZWMzLnRyYW5zZm9ybU1hdDQodGhpcywgdGhpcywgbWF0cml4NCk7XG4gICAgcmV0dXJuIHRoaXMuY2hlY2soKTtcbiAgfVxuXG4gIHRyYW5zZm9ybUFzVmVjdG9yKG1hdHJpeDQpIHtcbiAgICB2ZWMzX3RyYW5zZm9ybU1hdDRBc1ZlY3Rvcih0aGlzLCB0aGlzLCBtYXRyaXg0KTtcbiAgICByZXR1cm4gdGhpcy5jaGVjaygpO1xuICB9XG5cbiAgdHJhbnNmb3JtQnlNYXRyaXgzKG1hdHJpeDMpIHtcbiAgICB2ZWMzLnRyYW5zZm9ybU1hdDModGhpcywgdGhpcywgbWF0cml4Myk7XG4gICAgcmV0dXJuIHRoaXMuY2hlY2soKTtcbiAgfVxuXG4gIHRyYW5zZm9ybUJ5TWF0cml4MihtYXRyaXgyKSB7XG4gICAgdmVjM190cmFuc2Zvcm1NYXQyKHRoaXMsIHRoaXMsIG1hdHJpeDIpO1xuICAgIHJldHVybiB0aGlzLmNoZWNrKCk7XG4gIH1cblxuICB0cmFuc2Zvcm1CeVF1YXRlcm5pb24ocXVhdGVybmlvbikge1xuICAgIHZlYzMudHJhbnNmb3JtUXVhdCh0aGlzLCB0aGlzLCBxdWF0ZXJuaW9uKTtcbiAgICByZXR1cm4gdGhpcy5jaGVjaygpO1xuICB9XG5cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXZlY3RvcjMuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///43855\n')},50394:function(__unused_webpack_module,__webpack_exports__,__webpack_require__){eval('/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "Z": function() { return /* binding */ assert; }\n/* harmony export */ });\nfunction assert(condition, message) {\n  if (!condition) {\n    throw new Error("math.gl assertion ".concat(message));\n  }\n}\n//# sourceMappingURL=assert.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNTAzOTQuanMiLCJtYXBwaW5ncyI6Ijs7O0FBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdnVlMy13ZWJwYWNrNS8uL25vZGVfbW9kdWxlcy9AbWF0aC5nbC9jb3JlL2Rpc3QvZXNtL2xpYi9hc3NlcnQuanM/NGU3OSJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBhc3NlcnQoY29uZGl0aW9uLCBtZXNzYWdlKSB7XG4gIGlmICghY29uZGl0aW9uKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwibWF0aC5nbCBhc3NlcnRpb24gXCIuY29uY2F0KG1lc3NhZ2UpKTtcbiAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YXNzZXJ0LmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///50394\n')},14034:function(__unused_webpack_module,__webpack_exports__,__webpack_require__){eval('/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "Bw": function() { return /* binding */ formatValue; },\n/* harmony export */   "fS": function() { return /* binding */ equals; },\n/* harmony export */   "kJ": function() { return /* binding */ isArray; },\n/* harmony export */   "t7": function() { return /* binding */ lerp; },\n/* harmony export */   "uZ": function() { return /* binding */ clamp; },\n/* harmony export */   "vc": function() { return /* binding */ config; }\n/* harmony export */ });\n/* unused harmony exports configure, clone, toRadians, toDegrees, radians, degrees, sin, cos, tan, asin, acos, atan, exactEquals, withEpsilon */\n\nconst RADIANS_TO_DEGREES = 1 / Math.PI * 180;\nconst DEGREES_TO_RADIANS = 1 / 180 * Math.PI;\nconst config = {\n  EPSILON: 1e-12,\n  debug: false,\n  precision: 4,\n  printTypes: false,\n  printDegrees: false,\n  printRowMajor: true\n};\nfunction configure(options) {\n  for (const key in options) {\n    assert(key in config);\n    config[key] = options[key];\n  }\n\n  return config;\n}\nfunction formatValue(value, {\n  precision = config.precision\n} = {}) {\n  value = round(value);\n  return "".concat(parseFloat(value.toPrecision(precision)));\n}\nfunction isArray(value) {\n  return Array.isArray(value) || ArrayBuffer.isView(value) && !(value instanceof DataView);\n}\nfunction clone(array) {\n  return \'clone\' in array ? array.clone() : array.slice();\n}\nfunction toRadians(degrees) {\n  return radians(degrees);\n}\nfunction toDegrees(radians) {\n  return degrees(radians);\n}\nfunction radians(degrees, result) {\n  return map(degrees, degrees => degrees * DEGREES_TO_RADIANS, result);\n}\nfunction degrees(radians, result) {\n  return map(radians, radians => radians * RADIANS_TO_DEGREES, result);\n}\nfunction sin(radians, result) {\n  return map(radians, angle => Math.sin(angle), result);\n}\nfunction cos(radians, result) {\n  return map(radians, angle => Math.cos(angle), result);\n}\nfunction tan(radians, result) {\n  return map(radians, angle => Math.tan(angle), result);\n}\nfunction asin(radians, result) {\n  return map(radians, angle => Math.asin(angle), result);\n}\nfunction acos(radians, result) {\n  return map(radians, angle => Math.acos(angle), result);\n}\nfunction atan(radians, result) {\n  return map(radians, angle => Math.atan(angle), result);\n}\nfunction clamp(value, min, max) {\n  return map(value, value => Math.max(min, Math.min(max, value)));\n}\nfunction lerp(a, b, t) {\n  if (isArray(a)) {\n    return a.map((ai, i) => lerp(ai, b[i], t));\n  }\n\n  return t * b + (1 - t) * a;\n}\nfunction equals(a, b, epsilon) {\n  const oldEpsilon = config.EPSILON;\n\n  if (epsilon) {\n    config.EPSILON = epsilon;\n  }\n\n  try {\n    if (a === b) {\n      return true;\n    }\n\n    if (isArray(a) && isArray(b)) {\n      if (a.length !== b.length) {\n        return false;\n      }\n\n      for (let i = 0; i < a.length; ++i) {\n        if (!equals(a[i], b[i])) {\n          return false;\n        }\n      }\n\n      return true;\n    }\n\n    if (a && a.equals) {\n      return a.equals(b);\n    }\n\n    if (b && b.equals) {\n      return b.equals(a);\n    }\n\n    if (typeof a === \'number\' && typeof b === \'number\') {\n      return Math.abs(a - b) <= config.EPSILON * Math.max(1, Math.abs(a), Math.abs(b));\n    }\n\n    return false;\n  } finally {\n    config.EPSILON = oldEpsilon;\n  }\n}\nfunction exactEquals(a, b) {\n  if (a === b) {\n    return true;\n  }\n\n  if (a && typeof a === \'object\' && b && typeof b === \'object\') {\n    if (a.constructor !== b.constructor) {\n      return false;\n    }\n\n    if (a.exactEquals) {\n      return a.exactEquals(b);\n    }\n  }\n\n  if (isArray(a) && isArray(b)) {\n    if (a.length !== b.length) {\n      return false;\n    }\n\n    for (let i = 0; i < a.length; ++i) {\n      if (!exactEquals(a[i], b[i])) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  return false;\n}\nfunction withEpsilon(epsilon, func) {\n  const oldPrecision = config.EPSILON;\n  config.EPSILON = epsilon;\n  let value;\n\n  try {\n    value = func();\n  } finally {\n    config.EPSILON = oldPrecision;\n  }\n\n  return value;\n}\n\nfunction round(value) {\n  return Math.round(value / config.EPSILON) * config.EPSILON;\n}\n\nfunction duplicateArray(array) {\n  return array.clone ? array.clone() : new Array(array.length);\n}\n\nfunction map(value, func, result) {\n  if (isArray(value)) {\n    const array = value;\n    result = result || duplicateArray(array);\n\n    for (let i = 0; i < result.length && i < array.length; ++i) {\n      result[i] = func(value[i], i, result);\n    }\n\n    return result;\n  }\n\n  return func(value);\n}\n//# sourceMappingURL=common.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTQwMzQuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBQThCO0FBQzlCO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ087QUFDUDtBQUNBLEVBQUUsSUFBSTtBQUNOO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDTztBQUNQOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxzQkFBc0IsY0FBYztBQUNwQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG9CQUFvQixjQUFjO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsb0JBQW9CLHVDQUF1QztBQUMzRDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdnVlMy13ZWJwYWNrNS8uL25vZGVfbW9kdWxlcy9AbWF0aC5nbC9jb3JlL2Rpc3QvZXNtL2xpYi9jb21tb24uanM/ZDQ2YiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgYXNzZXJ0IGZyb20gJy4vYXNzZXJ0JztcbmNvbnN0IFJBRElBTlNfVE9fREVHUkVFUyA9IDEgLyBNYXRoLlBJICogMTgwO1xuY29uc3QgREVHUkVFU19UT19SQURJQU5TID0gMSAvIDE4MCAqIE1hdGguUEk7XG5leHBvcnQgY29uc3QgY29uZmlnID0ge1xuICBFUFNJTE9OOiAxZS0xMixcbiAgZGVidWc6IGZhbHNlLFxuICBwcmVjaXNpb246IDQsXG4gIHByaW50VHlwZXM6IGZhbHNlLFxuICBwcmludERlZ3JlZXM6IGZhbHNlLFxuICBwcmludFJvd01ham9yOiB0cnVlXG59O1xuZXhwb3J0IGZ1bmN0aW9uIGNvbmZpZ3VyZShvcHRpb25zKSB7XG4gIGZvciAoY29uc3Qga2V5IGluIG9wdGlvbnMpIHtcbiAgICBhc3NlcnQoa2V5IGluIGNvbmZpZyk7XG4gICAgY29uZmlnW2tleV0gPSBvcHRpb25zW2tleV07XG4gIH1cblxuICByZXR1cm4gY29uZmlnO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGZvcm1hdFZhbHVlKHZhbHVlLCB7XG4gIHByZWNpc2lvbiA9IGNvbmZpZy5wcmVjaXNpb25cbn0gPSB7fSkge1xuICB2YWx1ZSA9IHJvdW5kKHZhbHVlKTtcbiAgcmV0dXJuIFwiXCIuY29uY2F0KHBhcnNlRmxvYXQodmFsdWUudG9QcmVjaXNpb24ocHJlY2lzaW9uKSkpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGlzQXJyYXkodmFsdWUpIHtcbiAgcmV0dXJuIEFycmF5LmlzQXJyYXkodmFsdWUpIHx8IEFycmF5QnVmZmVyLmlzVmlldyh2YWx1ZSkgJiYgISh2YWx1ZSBpbnN0YW5jZW9mIERhdGFWaWV3KTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBjbG9uZShhcnJheSkge1xuICByZXR1cm4gJ2Nsb25lJyBpbiBhcnJheSA/IGFycmF5LmNsb25lKCkgOiBhcnJheS5zbGljZSgpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIHRvUmFkaWFucyhkZWdyZWVzKSB7XG4gIHJldHVybiByYWRpYW5zKGRlZ3JlZXMpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIHRvRGVncmVlcyhyYWRpYW5zKSB7XG4gIHJldHVybiBkZWdyZWVzKHJhZGlhbnMpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIHJhZGlhbnMoZGVncmVlcywgcmVzdWx0KSB7XG4gIHJldHVybiBtYXAoZGVncmVlcywgZGVncmVlcyA9PiBkZWdyZWVzICogREVHUkVFU19UT19SQURJQU5TLCByZXN1bHQpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGRlZ3JlZXMocmFkaWFucywgcmVzdWx0KSB7XG4gIHJldHVybiBtYXAocmFkaWFucywgcmFkaWFucyA9PiByYWRpYW5zICogUkFESUFOU19UT19ERUdSRUVTLCByZXN1bHQpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIHNpbihyYWRpYW5zLCByZXN1bHQpIHtcbiAgcmV0dXJuIG1hcChyYWRpYW5zLCBhbmdsZSA9PiBNYXRoLnNpbihhbmdsZSksIHJlc3VsdCk7XG59XG5leHBvcnQgZnVuY3Rpb24gY29zKHJhZGlhbnMsIHJlc3VsdCkge1xuICByZXR1cm4gbWFwKHJhZGlhbnMsIGFuZ2xlID0+IE1hdGguY29zKGFuZ2xlKSwgcmVzdWx0KTtcbn1cbmV4cG9ydCBmdW5jdGlvbiB0YW4ocmFkaWFucywgcmVzdWx0KSB7XG4gIHJldHVybiBtYXAocmFkaWFucywgYW5nbGUgPT4gTWF0aC50YW4oYW5nbGUpLCByZXN1bHQpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGFzaW4ocmFkaWFucywgcmVzdWx0KSB7XG4gIHJldHVybiBtYXAocmFkaWFucywgYW5nbGUgPT4gTWF0aC5hc2luKGFuZ2xlKSwgcmVzdWx0KTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBhY29zKHJhZGlhbnMsIHJlc3VsdCkge1xuICByZXR1cm4gbWFwKHJhZGlhbnMsIGFuZ2xlID0+IE1hdGguYWNvcyhhbmdsZSksIHJlc3VsdCk7XG59XG5leHBvcnQgZnVuY3Rpb24gYXRhbihyYWRpYW5zLCByZXN1bHQpIHtcbiAgcmV0dXJuIG1hcChyYWRpYW5zLCBhbmdsZSA9PiBNYXRoLmF0YW4oYW5nbGUpLCByZXN1bHQpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGNsYW1wKHZhbHVlLCBtaW4sIG1heCkge1xuICByZXR1cm4gbWFwKHZhbHVlLCB2YWx1ZSA9PiBNYXRoLm1heChtaW4sIE1hdGgubWluKG1heCwgdmFsdWUpKSk7XG59XG5leHBvcnQgZnVuY3Rpb24gbGVycChhLCBiLCB0KSB7XG4gIGlmIChpc0FycmF5KGEpKSB7XG4gICAgcmV0dXJuIGEubWFwKChhaSwgaSkgPT4gbGVycChhaSwgYltpXSwgdCkpO1xuICB9XG5cbiAgcmV0dXJuIHQgKiBiICsgKDEgLSB0KSAqIGE7XG59XG5leHBvcnQgZnVuY3Rpb24gZXF1YWxzKGEsIGIsIGVwc2lsb24pIHtcbiAgY29uc3Qgb2xkRXBzaWxvbiA9IGNvbmZpZy5FUFNJTE9OO1xuXG4gIGlmIChlcHNpbG9uKSB7XG4gICAgY29uZmlnLkVQU0lMT04gPSBlcHNpbG9uO1xuICB9XG5cbiAgdHJ5IHtcbiAgICBpZiAoYSA9PT0gYikge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgaWYgKGlzQXJyYXkoYSkgJiYgaXNBcnJheShiKSkge1xuICAgICAgaWYgKGEubGVuZ3RoICE9PSBiLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYS5sZW5ndGg7ICsraSkge1xuICAgICAgICBpZiAoIWVxdWFscyhhW2ldLCBiW2ldKSkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICBpZiAoYSAmJiBhLmVxdWFscykge1xuICAgICAgcmV0dXJuIGEuZXF1YWxzKGIpO1xuICAgIH1cblxuICAgIGlmIChiICYmIGIuZXF1YWxzKSB7XG4gICAgICByZXR1cm4gYi5lcXVhbHMoYSk7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBhID09PSAnbnVtYmVyJyAmJiB0eXBlb2YgYiA9PT0gJ251bWJlcicpIHtcbiAgICAgIHJldHVybiBNYXRoLmFicyhhIC0gYikgPD0gY29uZmlnLkVQU0lMT04gKiBNYXRoLm1heCgxLCBNYXRoLmFicyhhKSwgTWF0aC5hYnMoYikpO1xuICAgIH1cblxuICAgIHJldHVybiBmYWxzZTtcbiAgfSBmaW5hbGx5IHtcbiAgICBjb25maWcuRVBTSUxPTiA9IG9sZEVwc2lsb247XG4gIH1cbn1cbmV4cG9ydCBmdW5jdGlvbiBleGFjdEVxdWFscyhhLCBiKSB7XG4gIGlmIChhID09PSBiKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICBpZiAoYSAmJiB0eXBlb2YgYSA9PT0gJ29iamVjdCcgJiYgYiAmJiB0eXBlb2YgYiA9PT0gJ29iamVjdCcpIHtcbiAgICBpZiAoYS5jb25zdHJ1Y3RvciAhPT0gYi5jb25zdHJ1Y3Rvcikge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGlmIChhLmV4YWN0RXF1YWxzKSB7XG4gICAgICByZXR1cm4gYS5leGFjdEVxdWFscyhiKTtcbiAgICB9XG4gIH1cblxuICBpZiAoaXNBcnJheShhKSAmJiBpc0FycmF5KGIpKSB7XG4gICAgaWYgKGEubGVuZ3RoICE9PSBiLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYS5sZW5ndGg7ICsraSkge1xuICAgICAgaWYgKCFleGFjdEVxdWFscyhhW2ldLCBiW2ldKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5leHBvcnQgZnVuY3Rpb24gd2l0aEVwc2lsb24oZXBzaWxvbiwgZnVuYykge1xuICBjb25zdCBvbGRQcmVjaXNpb24gPSBjb25maWcuRVBTSUxPTjtcbiAgY29uZmlnLkVQU0lMT04gPSBlcHNpbG9uO1xuICBsZXQgdmFsdWU7XG5cbiAgdHJ5IHtcbiAgICB2YWx1ZSA9IGZ1bmMoKTtcbiAgfSBmaW5hbGx5IHtcbiAgICBjb25maWcuRVBTSUxPTiA9IG9sZFByZWNpc2lvbjtcbiAgfVxuXG4gIHJldHVybiB2YWx1ZTtcbn1cblxuZnVuY3Rpb24gcm91bmQodmFsdWUpIHtcbiAgcmV0dXJuIE1hdGgucm91bmQodmFsdWUgLyBjb25maWcuRVBTSUxPTikgKiBjb25maWcuRVBTSUxPTjtcbn1cblxuZnVuY3Rpb24gZHVwbGljYXRlQXJyYXkoYXJyYXkpIHtcbiAgcmV0dXJuIGFycmF5LmNsb25lID8gYXJyYXkuY2xvbmUoKSA6IG5ldyBBcnJheShhcnJheS5sZW5ndGgpO1xufVxuXG5mdW5jdGlvbiBtYXAodmFsdWUsIGZ1bmMsIHJlc3VsdCkge1xuICBpZiAoaXNBcnJheSh2YWx1ZSkpIHtcbiAgICBjb25zdCBhcnJheSA9IHZhbHVlO1xuICAgIHJlc3VsdCA9IHJlc3VsdCB8fCBkdXBsaWNhdGVBcnJheShhcnJheSk7XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHJlc3VsdC5sZW5ndGggJiYgaSA8IGFycmF5Lmxlbmd0aDsgKytpKSB7XG4gICAgICByZXN1bHRbaV0gPSBmdW5jKHZhbHVlW2ldLCBpLCByZXN1bHQpO1xuICAgIH1cblxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICByZXR1cm4gZnVuYyh2YWx1ZSk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jb21tb24uanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///14034\n')},1031:function(__unused_webpack_module,__webpack_exports__,__webpack_require__){eval('/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "G7": function() { return /* binding */ vec4_transformMat2; },\n/* harmony export */   "_x": function() { return /* binding */ vec4_transformMat3; },\n/* harmony export */   "eQ": function() { return /* binding */ vec3_transformMat2; },\n/* harmony export */   "pL": function() { return /* binding */ vec3_transformMat4AsVector; },\n/* harmony export */   "pb": function() { return /* binding */ vec2_transformMat4AsVector; }\n/* harmony export */ });\nfunction vec2_transformMat4AsVector(out, a, m) {\n  const x = a[0];\n  const y = a[1];\n  const w = m[3] * x + m[7] * y || 1.0;\n  out[0] = (m[0] * x + m[4] * y) / w;\n  out[1] = (m[1] * x + m[5] * y) / w;\n  return out;\n}\nfunction vec3_transformMat4AsVector(out, a, m) {\n  const x = a[0];\n  const y = a[1];\n  const z = a[2];\n  const w = m[3] * x + m[7] * y + m[11] * z || 1.0;\n  out[0] = (m[0] * x + m[4] * y + m[8] * z) / w;\n  out[1] = (m[1] * x + m[5] * y + m[9] * z) / w;\n  out[2] = (m[2] * x + m[6] * y + m[10] * z) / w;\n  return out;\n}\nfunction vec3_transformMat2(out, a, m) {\n  const x = a[0];\n  const y = a[1];\n  out[0] = m[0] * x + m[2] * y;\n  out[1] = m[1] * x + m[3] * y;\n  out[2] = a[2];\n  return out;\n}\nfunction vec4_transformMat2(out, a, m) {\n  const x = a[0];\n  const y = a[1];\n  out[0] = m[0] * x + m[2] * y;\n  out[1] = m[1] * x + m[3] * y;\n  out[2] = a[2];\n  out[3] = a[3];\n  return out;\n}\nfunction vec4_transformMat3(out, a, m) {\n  const x = a[0];\n  const y = a[1];\n  const z = a[2];\n  out[0] = m[0] * x + m[3] * y + m[6] * z;\n  out[1] = m[1] * x + m[4] * y + m[7] * z;\n  out[2] = m[2] * x + m[5] * y + m[8] * z;\n  out[3] = a[3];\n  return out;\n}\n//# sourceMappingURL=gl-matrix-extras.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTAzMS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly92dWUzLXdlYnBhY2s1Ly4vbm9kZV9tb2R1bGVzL0BtYXRoLmdsL2NvcmUvZGlzdC9lc20vbGliL2dsLW1hdHJpeC1leHRyYXMuanM/NzlkMCJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgZnVuY3Rpb24gdmVjMl90cmFuc2Zvcm1NYXQ0QXNWZWN0b3Iob3V0LCBhLCBtKSB7XG4gIGNvbnN0IHggPSBhWzBdO1xuICBjb25zdCB5ID0gYVsxXTtcbiAgY29uc3QgdyA9IG1bM10gKiB4ICsgbVs3XSAqIHkgfHwgMS4wO1xuICBvdXRbMF0gPSAobVswXSAqIHggKyBtWzRdICogeSkgLyB3O1xuICBvdXRbMV0gPSAobVsxXSAqIHggKyBtWzVdICogeSkgLyB3O1xuICByZXR1cm4gb3V0O1xufVxuZXhwb3J0IGZ1bmN0aW9uIHZlYzNfdHJhbnNmb3JtTWF0NEFzVmVjdG9yKG91dCwgYSwgbSkge1xuICBjb25zdCB4ID0gYVswXTtcbiAgY29uc3QgeSA9IGFbMV07XG4gIGNvbnN0IHogPSBhWzJdO1xuICBjb25zdCB3ID0gbVszXSAqIHggKyBtWzddICogeSArIG1bMTFdICogeiB8fCAxLjA7XG4gIG91dFswXSA9IChtWzBdICogeCArIG1bNF0gKiB5ICsgbVs4XSAqIHopIC8gdztcbiAgb3V0WzFdID0gKG1bMV0gKiB4ICsgbVs1XSAqIHkgKyBtWzldICogeikgLyB3O1xuICBvdXRbMl0gPSAobVsyXSAqIHggKyBtWzZdICogeSArIG1bMTBdICogeikgLyB3O1xuICByZXR1cm4gb3V0O1xufVxuZXhwb3J0IGZ1bmN0aW9uIHZlYzNfdHJhbnNmb3JtTWF0MihvdXQsIGEsIG0pIHtcbiAgY29uc3QgeCA9IGFbMF07XG4gIGNvbnN0IHkgPSBhWzFdO1xuICBvdXRbMF0gPSBtWzBdICogeCArIG1bMl0gKiB5O1xuICBvdXRbMV0gPSBtWzFdICogeCArIG1bM10gKiB5O1xuICBvdXRbMl0gPSBhWzJdO1xuICByZXR1cm4gb3V0O1xufVxuZXhwb3J0IGZ1bmN0aW9uIHZlYzRfdHJhbnNmb3JtTWF0MihvdXQsIGEsIG0pIHtcbiAgY29uc3QgeCA9IGFbMF07XG4gIGNvbnN0IHkgPSBhWzFdO1xuICBvdXRbMF0gPSBtWzBdICogeCArIG1bMl0gKiB5O1xuICBvdXRbMV0gPSBtWzFdICogeCArIG1bM10gKiB5O1xuICBvdXRbMl0gPSBhWzJdO1xuICBvdXRbM10gPSBhWzNdO1xuICByZXR1cm4gb3V0O1xufVxuZXhwb3J0IGZ1bmN0aW9uIHZlYzRfdHJhbnNmb3JtTWF0MyhvdXQsIGEsIG0pIHtcbiAgY29uc3QgeCA9IGFbMF07XG4gIGNvbnN0IHkgPSBhWzFdO1xuICBjb25zdCB6ID0gYVsyXTtcbiAgb3V0WzBdID0gbVswXSAqIHggKyBtWzNdICogeSArIG1bNl0gKiB6O1xuICBvdXRbMV0gPSBtWzFdICogeCArIG1bNF0gKiB5ICsgbVs3XSAqIHo7XG4gIG91dFsyXSA9IG1bMl0gKiB4ICsgbVs1XSAqIHkgKyBtWzhdICogejtcbiAgb3V0WzNdID0gYVszXTtcbiAgcmV0dXJuIG91dDtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWdsLW1hdHJpeC1leHRyYXMuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///1031\n')},86281:function(__unused_webpack_module,__webpack_exports__,__webpack_require__){eval('/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "IL": function() { return /* binding */ checkVector; },\n/* harmony export */   "u5": function() { return /* binding */ checkNumber; }\n/* harmony export */ });\n/* unused harmony exports validateVector, deprecated */\n/* harmony import */ var _common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(14034);\n\nfunction validateVector(v, length) {\n  if (v.length !== length) {\n    return false;\n  }\n\n  for (let i = 0; i < v.length; ++i) {\n    if (!Number.isFinite(v[i])) {\n      return false;\n    }\n  }\n\n  return true;\n}\nfunction checkNumber(value) {\n  if (!Number.isFinite(value)) {\n    throw new Error("Invalid number ".concat(value));\n  }\n\n  return value;\n}\nfunction checkVector(v, length, callerName = \'\') {\n  if (_common__WEBPACK_IMPORTED_MODULE_0__/* .config.debug */ .vc.debug && !validateVector(v, length)) {\n    throw new Error("math.gl: ".concat(callerName, " some fields set to invalid numbers\'"));\n  }\n\n  return v;\n}\nconst map = {};\nfunction deprecated(method, version) {\n  if (!map[method]) {\n    map[method] = true;\n    console.warn("".concat(method, " has been removed in version ").concat(version, ", see upgrade guide for more information"));\n  }\n}\n//# sourceMappingURL=validators.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiODYyODEuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQWtDO0FBQzNCO0FBQ1A7QUFDQTtBQUNBOztBQUVBLGtCQUFrQixjQUFjO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ087QUFDUCxNQUFNLGlFQUFZO0FBQ2xCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly92dWUzLXdlYnBhY2s1Ly4vbm9kZV9tb2R1bGVzL0BtYXRoLmdsL2NvcmUvZGlzdC9lc20vbGliL3ZhbGlkYXRvcnMuanM/MjEwNiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBjb25maWcgfSBmcm9tICcuL2NvbW1vbic7XG5leHBvcnQgZnVuY3Rpb24gdmFsaWRhdGVWZWN0b3IodiwgbGVuZ3RoKSB7XG4gIGlmICh2Lmxlbmd0aCAhPT0gbGVuZ3RoKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCB2Lmxlbmd0aDsgKytpKSB7XG4gICAgaWYgKCFOdW1iZXIuaXNGaW5pdGUodltpXSkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBjaGVja051bWJlcih2YWx1ZSkge1xuICBpZiAoIU51bWJlci5pc0Zpbml0ZSh2YWx1ZSkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIG51bWJlciBcIi5jb25jYXQodmFsdWUpKTtcbiAgfVxuXG4gIHJldHVybiB2YWx1ZTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBjaGVja1ZlY3Rvcih2LCBsZW5ndGgsIGNhbGxlck5hbWUgPSAnJykge1xuICBpZiAoY29uZmlnLmRlYnVnICYmICF2YWxpZGF0ZVZlY3Rvcih2LCBsZW5ndGgpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwibWF0aC5nbDogXCIuY29uY2F0KGNhbGxlck5hbWUsIFwiIHNvbWUgZmllbGRzIHNldCB0byBpbnZhbGlkIG51bWJlcnMnXCIpKTtcbiAgfVxuXG4gIHJldHVybiB2O1xufVxuY29uc3QgbWFwID0ge307XG5leHBvcnQgZnVuY3Rpb24gZGVwcmVjYXRlZChtZXRob2QsIHZlcnNpb24pIHtcbiAgaWYgKCFtYXBbbWV0aG9kXSkge1xuICAgIG1hcFttZXRob2RdID0gdHJ1ZTtcbiAgICBjb25zb2xlLndhcm4oXCJcIi5jb25jYXQobWV0aG9kLCBcIiBoYXMgYmVlbiByZW1vdmVkIGluIHZlcnNpb24gXCIpLmNvbmNhdCh2ZXJzaW9uLCBcIiwgc2VlIHVwZ3JhZGUgZ3VpZGUgZm9yIG1vcmUgaW5mb3JtYXRpb25cIikpO1xuICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD12YWxpZGF0b3JzLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///86281\n')},36772:function(__unused_webpack_module,__webpack_exports__,__webpack_require__){eval('\n// EXPORTS\n__webpack_require__.d(__webpack_exports__, {\n  "Xx": function() { return /* reexport */ axis_aligned_bounding_box_AxisAlignedBoundingBox; },\n  "Mh": function() { return /* reexport */ culling_volume_CullingVolume; },\n  "JO": function() { return /* reexport */ plane_Plane; },\n  "du": function() { return /* reexport */ makeOrientedBoundingBoxFromPoints; }\n});\n\n// UNUSED EXPORTS: BoundingSphere, INTERSECTION, OrientedBoundingBox, _PerspectiveFrustum, _PerspectiveOffCenterFrustum, computeEigenDecomposition, makeAxisAlignedBoundingBoxFromPoints, makeBoundingSphereFromPoints\n\n;// CONCATENATED MODULE: ./node_modules/@math.gl/culling/dist/esm/constants.js\nconst INTERSECTION = {\n  OUTSIDE: -1,\n  INTERSECTING: 0,\n  INSIDE: 1\n};\n//# sourceMappingURL=constants.js.map\n// EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/esm/defineProperty.js\nvar defineProperty = __webpack_require__(82482);\n// EXTERNAL MODULE: ./node_modules/@math.gl/core/dist/esm/classes/vector3.js\nvar vector3 = __webpack_require__(43855);\n;// CONCATENATED MODULE: ./node_modules/@math.gl/culling/dist/esm/lib/bounding-volumes/axis-aligned-bounding-box.js\n\n\n\nconst scratchVector = new vector3/* default */.Z();\nconst scratchNormal = new vector3/* default */.Z();\nclass axis_aligned_bounding_box_AxisAlignedBoundingBox {\n  constructor(minimum = [0, 0, 0], maximum = [0, 0, 0], center) {\n    (0,defineProperty/* default */.Z)(this, "center", void 0);\n\n    (0,defineProperty/* default */.Z)(this, "halfDiagonal", void 0);\n\n    (0,defineProperty/* default */.Z)(this, "minimum", void 0);\n\n    (0,defineProperty/* default */.Z)(this, "maximum", void 0);\n\n    center = center || scratchVector.copy(minimum).add(maximum).scale(0.5);\n    this.center = new vector3/* default */.Z(center);\n    this.halfDiagonal = new vector3/* default */.Z(maximum).subtract(this.center);\n    this.minimum = new vector3/* default */.Z(minimum);\n    this.maximum = new vector3/* default */.Z(maximum);\n  }\n\n  clone() {\n    return new axis_aligned_bounding_box_AxisAlignedBoundingBox(this.minimum, this.maximum, this.center);\n  }\n\n  equals(right) {\n    return this === right || Boolean(right) && this.minimum.equals(right.minimum) && this.maximum.equals(right.maximum);\n  }\n\n  transform(transform) {\n    this.center.transformAsPoint(transform);\n    this.halfDiagonal.transform(transform);\n    this.minimum.transform(transform);\n    this.maximum.transform(transform);\n    return this;\n  }\n\n  intersectPlane(plane) {\n    const {\n      halfDiagonal\n    } = this;\n    const normal = scratchNormal.from(plane.normal);\n    const e = halfDiagonal.x * Math.abs(normal.x) + halfDiagonal.y * Math.abs(normal.y) + halfDiagonal.z * Math.abs(normal.z);\n    const s = this.center.dot(normal) + plane.distance;\n\n    if (s - e > 0) {\n      return INTERSECTION.INSIDE;\n    }\n\n    if (s + e < 0) {\n      return INTERSECTION.OUTSIDE;\n    }\n\n    return INTERSECTION.INTERSECTING;\n  }\n\n  distanceTo(point) {\n    return Math.sqrt(this.distanceSquaredTo(point));\n  }\n\n  distanceSquaredTo(point) {\n    const offset = scratchVector.from(point).subtract(this.center);\n    const {\n      halfDiagonal\n    } = this;\n    let distanceSquared = 0.0;\n    let d;\n    d = Math.abs(offset.x) - halfDiagonal.x;\n\n    if (d > 0) {\n      distanceSquared += d * d;\n    }\n\n    d = Math.abs(offset.y) - halfDiagonal.y;\n\n    if (d > 0) {\n      distanceSquared += d * d;\n    }\n\n    d = Math.abs(offset.z) - halfDiagonal.z;\n\n    if (d > 0) {\n      distanceSquared += d * d;\n    }\n\n    return distanceSquared;\n  }\n\n}\n//# sourceMappingURL=axis-aligned-bounding-box.js.map\n// EXTERNAL MODULE: ./node_modules/gl-matrix/esm/mat4.js\nvar mat4 = __webpack_require__(85975);\n;// CONCATENATED MODULE: ./node_modules/@math.gl/culling/dist/esm/lib/bounding-volumes/bounding-sphere.js\n\n\n\n\nconst bounding_sphere_scratchVector = new vector3/* default */.Z();\nconst scratchVector2 = new vector3/* default */.Z();\nclass bounding_sphere_BoundingSphere {\n  constructor(center = [0, 0, 0], radius = 0.0) {\n    (0,defineProperty/* default */.Z)(this, "center", void 0);\n\n    (0,defineProperty/* default */.Z)(this, "radius", void 0);\n\n    this.radius = -0;\n    this.center = new vector3/* default */.Z();\n    this.fromCenterRadius(center, radius);\n  }\n\n  fromCenterRadius(center, radius) {\n    this.center.from(center);\n    this.radius = radius;\n    return this;\n  }\n\n  fromCornerPoints(corner, oppositeCorner) {\n    oppositeCorner = bounding_sphere_scratchVector.from(oppositeCorner);\n    this.center = new vector3/* default */.Z().from(corner).add(oppositeCorner).scale(0.5);\n    this.radius = this.center.distance(oppositeCorner);\n    return this;\n  }\n\n  equals(right) {\n    return this === right || Boolean(right) && this.center.equals(right.center) && this.radius === right.radius;\n  }\n\n  clone() {\n    return new bounding_sphere_BoundingSphere(this.center, this.radius);\n  }\n\n  union(boundingSphere) {\n    const leftCenter = this.center;\n    const leftRadius = this.radius;\n    const rightCenter = boundingSphere.center;\n    const rightRadius = boundingSphere.radius;\n    const toRightCenter = bounding_sphere_scratchVector.copy(rightCenter).subtract(leftCenter);\n    const centerSeparation = toRightCenter.magnitude();\n\n    if (leftRadius >= centerSeparation + rightRadius) {\n      return this.clone();\n    }\n\n    if (rightRadius >= centerSeparation + leftRadius) {\n      return boundingSphere.clone();\n    }\n\n    const halfDistanceBetweenTangentPoints = (leftRadius + centerSeparation + rightRadius) * 0.5;\n    scratchVector2.copy(toRightCenter).scale((-leftRadius + halfDistanceBetweenTangentPoints) / centerSeparation).add(leftCenter);\n    this.center.copy(scratchVector2);\n    this.radius = halfDistanceBetweenTangentPoints;\n    return this;\n  }\n\n  expand(point) {\n    const scratchPoint = bounding_sphere_scratchVector.from(point);\n    const radius = scratchPoint.subtract(this.center).magnitude();\n\n    if (radius > this.radius) {\n      this.radius = radius;\n    }\n\n    return this;\n  }\n\n  transform(transform) {\n    this.center.transform(transform);\n    const scale = mat4/* getScaling */.Q$(bounding_sphere_scratchVector, transform);\n    this.radius = Math.max(scale[0], Math.max(scale[1], scale[2])) * this.radius;\n    return this;\n  }\n\n  distanceSquaredTo(point) {\n    const d = this.distanceTo(point);\n    return d * d;\n  }\n\n  distanceTo(point) {\n    const scratchPoint = bounding_sphere_scratchVector.from(point);\n    const delta = scratchPoint.subtract(this.center);\n    return Math.max(0, delta.len() - this.radius);\n  }\n\n  intersectPlane(plane) {\n    const center = this.center;\n    const radius = this.radius;\n    const normal = plane.normal;\n    const distanceToPlane = normal.dot(center) + plane.distance;\n\n    if (distanceToPlane < -radius) {\n      return INTERSECTION.OUTSIDE;\n    }\n\n    if (distanceToPlane < radius) {\n      return INTERSECTION.INTERSECTING;\n    }\n\n    return INTERSECTION.INSIDE;\n  }\n\n}\n//# sourceMappingURL=bounding-sphere.js.map\n// EXTERNAL MODULE: ./node_modules/@math.gl/core/dist/esm/classes/matrix3.js\nvar matrix3 = __webpack_require__(80540);\n// EXTERNAL MODULE: ./node_modules/@math.gl/core/dist/esm/classes/quaternion.js + 1 modules\nvar classes_quaternion = __webpack_require__(43897);\n;// CONCATENATED MODULE: ./node_modules/@math.gl/culling/dist/esm/lib/bounding-volumes/oriented-bounding-box.js\n\n\n\n\nconst scratchVector3 = new vector3/* default */.Z();\nconst scratchOffset = new vector3/* default */.Z();\nconst scratchVectorU = new vector3/* default */.Z();\nconst scratchVectorV = new vector3/* default */.Z();\nconst scratchVectorW = new vector3/* default */.Z();\nconst scratchCorner = new vector3/* default */.Z();\nconst scratchToCenter = new vector3/* default */.Z();\nconst MATRIX3 = {\n  COLUMN0ROW0: 0,\n  COLUMN0ROW1: 1,\n  COLUMN0ROW2: 2,\n  COLUMN1ROW0: 3,\n  COLUMN1ROW1: 4,\n  COLUMN1ROW2: 5,\n  COLUMN2ROW0: 6,\n  COLUMN2ROW1: 7,\n  COLUMN2ROW2: 8\n};\nclass OrientedBoundingBox {\n  constructor(center = [0, 0, 0], halfAxes = [0, 0, 0, 0, 0, 0, 0, 0, 0]) {\n    (0,defineProperty/* default */.Z)(this, "center", void 0);\n\n    (0,defineProperty/* default */.Z)(this, "halfAxes", void 0);\n\n    this.center = new vector3/* default */.Z().from(center);\n    this.halfAxes = new matrix3/* default */.Z(halfAxes);\n  }\n\n  get halfSize() {\n    const xAxis = this.halfAxes.getColumn(0);\n    const yAxis = this.halfAxes.getColumn(1);\n    const zAxis = this.halfAxes.getColumn(2);\n    return [new vector3/* default */.Z(xAxis).len(), new vector3/* default */.Z(yAxis).len(), new vector3/* default */.Z(zAxis).len()];\n  }\n\n  get quaternion() {\n    const xAxis = this.halfAxes.getColumn(0);\n    const yAxis = this.halfAxes.getColumn(1);\n    const zAxis = this.halfAxes.getColumn(2);\n    const normXAxis = new vector3/* default */.Z(xAxis).normalize();\n    const normYAxis = new vector3/* default */.Z(yAxis).normalize();\n    const normZAxis = new vector3/* default */.Z(zAxis).normalize();\n    return new classes_quaternion/* default */.Z().fromMatrix3(new matrix3/* default */.Z([...normXAxis, ...normYAxis, ...normZAxis]));\n  }\n\n  fromCenterHalfSizeQuaternion(center, halfSize, quaternion) {\n    const quaternionObject = new classes_quaternion/* default */.Z(quaternion);\n    const directionsMatrix = new matrix3/* default */.Z().fromQuaternion(quaternionObject);\n    directionsMatrix[0] = directionsMatrix[0] * halfSize[0];\n    directionsMatrix[1] = directionsMatrix[1] * halfSize[0];\n    directionsMatrix[2] = directionsMatrix[2] * halfSize[0];\n    directionsMatrix[3] = directionsMatrix[3] * halfSize[1];\n    directionsMatrix[4] = directionsMatrix[4] * halfSize[1];\n    directionsMatrix[5] = directionsMatrix[5] * halfSize[1];\n    directionsMatrix[6] = directionsMatrix[6] * halfSize[2];\n    directionsMatrix[7] = directionsMatrix[7] * halfSize[2];\n    directionsMatrix[8] = directionsMatrix[8] * halfSize[2];\n    this.center = new vector3/* default */.Z().from(center);\n    this.halfAxes = directionsMatrix;\n    return this;\n  }\n\n  clone() {\n    return new OrientedBoundingBox(this.center, this.halfAxes);\n  }\n\n  equals(right) {\n    return this === right || Boolean(right) && this.center.equals(right.center) && this.halfAxes.equals(right.halfAxes);\n  }\n\n  getBoundingSphere(result = new bounding_sphere_BoundingSphere()) {\n    const halfAxes = this.halfAxes;\n    const u = halfAxes.getColumn(0, scratchVectorU);\n    const v = halfAxes.getColumn(1, scratchVectorV);\n    const w = halfAxes.getColumn(2, scratchVectorW);\n    const cornerVector = scratchVector3.copy(u).add(v).add(w);\n    result.center.copy(this.center);\n    result.radius = cornerVector.magnitude();\n    return result;\n  }\n\n  intersectPlane(plane) {\n    const center = this.center;\n    const normal = plane.normal;\n    const halfAxes = this.halfAxes;\n    const normalX = normal.x;\n    const normalY = normal.y;\n    const normalZ = normal.z;\n    const radEffective = Math.abs(normalX * halfAxes[MATRIX3.COLUMN0ROW0] + normalY * halfAxes[MATRIX3.COLUMN0ROW1] + normalZ * halfAxes[MATRIX3.COLUMN0ROW2]) + Math.abs(normalX * halfAxes[MATRIX3.COLUMN1ROW0] + normalY * halfAxes[MATRIX3.COLUMN1ROW1] + normalZ * halfAxes[MATRIX3.COLUMN1ROW2]) + Math.abs(normalX * halfAxes[MATRIX3.COLUMN2ROW0] + normalY * halfAxes[MATRIX3.COLUMN2ROW1] + normalZ * halfAxes[MATRIX3.COLUMN2ROW2]);\n    const distanceToPlane = normal.dot(center) + plane.distance;\n\n    if (distanceToPlane <= -radEffective) {\n      return INTERSECTION.OUTSIDE;\n    } else if (distanceToPlane >= radEffective) {\n      return INTERSECTION.INSIDE;\n    }\n\n    return INTERSECTION.INTERSECTING;\n  }\n\n  distanceTo(point) {\n    return Math.sqrt(this.distanceSquaredTo(point));\n  }\n\n  distanceSquaredTo(point) {\n    const offset = scratchOffset.from(point).subtract(this.center);\n    const halfAxes = this.halfAxes;\n    const u = halfAxes.getColumn(0, scratchVectorU);\n    const v = halfAxes.getColumn(1, scratchVectorV);\n    const w = halfAxes.getColumn(2, scratchVectorW);\n    const uHalf = u.magnitude();\n    const vHalf = v.magnitude();\n    const wHalf = w.magnitude();\n    u.normalize();\n    v.normalize();\n    w.normalize();\n    let distanceSquared = 0.0;\n    let d;\n    d = Math.abs(offset.dot(u)) - uHalf;\n\n    if (d > 0) {\n      distanceSquared += d * d;\n    }\n\n    d = Math.abs(offset.dot(v)) - vHalf;\n\n    if (d > 0) {\n      distanceSquared += d * d;\n    }\n\n    d = Math.abs(offset.dot(w)) - wHalf;\n\n    if (d > 0) {\n      distanceSquared += d * d;\n    }\n\n    return distanceSquared;\n  }\n\n  computePlaneDistances(position, direction, result = [-0, -0]) {\n    let minDist = Number.POSITIVE_INFINITY;\n    let maxDist = Number.NEGATIVE_INFINITY;\n    const center = this.center;\n    const halfAxes = this.halfAxes;\n    const u = halfAxes.getColumn(0, scratchVectorU);\n    const v = halfAxes.getColumn(1, scratchVectorV);\n    const w = halfAxes.getColumn(2, scratchVectorW);\n    const corner = scratchCorner.copy(u).add(v).add(w).add(center);\n    const toCenter = scratchToCenter.copy(corner).subtract(position);\n    let mag = direction.dot(toCenter);\n    minDist = Math.min(mag, minDist);\n    maxDist = Math.max(mag, maxDist);\n    corner.copy(center).add(u).add(v).subtract(w);\n    toCenter.copy(corner).subtract(position);\n    mag = direction.dot(toCenter);\n    minDist = Math.min(mag, minDist);\n    maxDist = Math.max(mag, maxDist);\n    corner.copy(center).add(u).subtract(v).add(w);\n    toCenter.copy(corner).subtract(position);\n    mag = direction.dot(toCenter);\n    minDist = Math.min(mag, minDist);\n    maxDist = Math.max(mag, maxDist);\n    corner.copy(center).add(u).subtract(v).subtract(w);\n    toCenter.copy(corner).subtract(position);\n    mag = direction.dot(toCenter);\n    minDist = Math.min(mag, minDist);\n    maxDist = Math.max(mag, maxDist);\n    center.copy(corner).subtract(u).add(v).add(w);\n    toCenter.copy(corner).subtract(position);\n    mag = direction.dot(toCenter);\n    minDist = Math.min(mag, minDist);\n    maxDist = Math.max(mag, maxDist);\n    center.copy(corner).subtract(u).add(v).subtract(w);\n    toCenter.copy(corner).subtract(position);\n    mag = direction.dot(toCenter);\n    minDist = Math.min(mag, minDist);\n    maxDist = Math.max(mag, maxDist);\n    center.copy(corner).subtract(u).subtract(v).add(w);\n    toCenter.copy(corner).subtract(position);\n    mag = direction.dot(toCenter);\n    minDist = Math.min(mag, minDist);\n    maxDist = Math.max(mag, maxDist);\n    center.copy(corner).subtract(u).subtract(v).subtract(w);\n    toCenter.copy(corner).subtract(position);\n    mag = direction.dot(toCenter);\n    minDist = Math.min(mag, minDist);\n    maxDist = Math.max(mag, maxDist);\n    result[0] = minDist;\n    result[1] = maxDist;\n    return result;\n  }\n\n  transform(transformation) {\n    this.center.transformAsPoint(transformation);\n    const xAxis = this.halfAxes.getColumn(0, scratchVectorU);\n    xAxis.transformAsPoint(transformation);\n    const yAxis = this.halfAxes.getColumn(1, scratchVectorV);\n    yAxis.transformAsPoint(transformation);\n    const zAxis = this.halfAxes.getColumn(2, scratchVectorW);\n    zAxis.transformAsPoint(transformation);\n    this.halfAxes = new matrix3/* default */.Z([...xAxis, ...yAxis, ...zAxis]);\n    return this;\n  }\n\n  getTransform() {\n    throw new Error(\'not implemented\');\n  }\n\n}\n//# sourceMappingURL=oriented-bounding-box.js.map\n// EXTERNAL MODULE: ./node_modules/@math.gl/core/dist/esm/lib/assert.js\nvar lib_assert = __webpack_require__(50394);\n// EXTERNAL MODULE: ./node_modules/@math.gl/core/dist/esm/lib/common.js\nvar common = __webpack_require__(14034);\n;// CONCATENATED MODULE: ./node_modules/@math.gl/culling/dist/esm/lib/plane.js\n\n\nconst scratchPosition = new vector3/* default */.Z();\nconst plane_scratchNormal = new vector3/* default */.Z();\nclass plane_Plane {\n  constructor(normal = [0, 0, 1], distance = 0) {\n    (0,defineProperty/* default */.Z)(this, "normal", void 0);\n\n    (0,defineProperty/* default */.Z)(this, "distance", void 0);\n\n    this.normal = new vector3/* default */.Z();\n    this.distance = -0;\n    this.fromNormalDistance(normal, distance);\n  }\n\n  fromNormalDistance(normal, distance) {\n    (0,lib_assert/* default */.Z)(Number.isFinite(distance));\n    this.normal.from(normal).normalize();\n    this.distance = distance;\n    return this;\n  }\n\n  fromPointNormal(point, normal) {\n    point = scratchPosition.from(point);\n    this.normal.from(normal).normalize();\n    const distance = -this.normal.dot(point);\n    this.distance = distance;\n    return this;\n  }\n\n  fromCoefficients(a, b, c, d) {\n    this.normal.set(a, b, c);\n    (0,lib_assert/* default */.Z)((0,common/* equals */.fS)(this.normal.len(), 1));\n    this.distance = d;\n    return this;\n  }\n\n  clone() {\n    return new plane_Plane(this.normal, this.distance);\n  }\n\n  equals(right) {\n    return (0,common/* equals */.fS)(this.distance, right.distance) && (0,common/* equals */.fS)(this.normal, right.normal);\n  }\n\n  getPointDistance(point) {\n    return this.normal.dot(point) + this.distance;\n  }\n\n  transform(matrix4) {\n    const normal = plane_scratchNormal.copy(this.normal).transformAsVector(matrix4).normalize();\n    const point = this.normal.scale(-this.distance).transform(matrix4);\n    return this.fromPointNormal(point, normal);\n  }\n\n  projectPointOntoPlane(point, result = [0, 0, 0]) {\n    point = scratchPosition.from(point);\n    const pointDistance = this.getPointDistance(point);\n    const scaledNormal = plane_scratchNormal.copy(this.normal).scale(pointDistance);\n    return point.subtract(scaledNormal).to(result);\n  }\n\n}\n//# sourceMappingURL=plane.js.map\n;// CONCATENATED MODULE: ./node_modules/@math.gl/culling/dist/esm/lib/culling-volume.js\n\n\n\n\nconst faces = [new vector3/* default */.Z([1, 0, 0]), new vector3/* default */.Z([0, 1, 0]), new vector3/* default */.Z([0, 0, 1])];\nconst scratchPlaneCenter = new vector3/* default */.Z();\nconst scratchPlaneNormal = new vector3/* default */.Z();\nconst scratchPlane = new plane_Plane(new vector3/* default */.Z(1.0, 0.0, 0.0), 0.0);\nclass culling_volume_CullingVolume {\n  constructor(planes = []) {\n    (0,defineProperty/* default */.Z)(this, "planes", void 0);\n\n    this.planes = planes;\n  }\n\n  fromBoundingSphere(boundingSphere) {\n    this.planes.length = 2 * faces.length;\n    const center = boundingSphere.center;\n    const radius = boundingSphere.radius;\n    let planeIndex = 0;\n\n    for (const faceNormal of faces) {\n      let plane0 = this.planes[planeIndex];\n      let plane1 = this.planes[planeIndex + 1];\n\n      if (!plane0) {\n        plane0 = this.planes[planeIndex] = new plane_Plane();\n      }\n\n      if (!plane1) {\n        plane1 = this.planes[planeIndex + 1] = new plane_Plane();\n      }\n\n      const plane0Center = scratchPlaneCenter.copy(faceNormal).scale(-radius).add(center);\n      const plane0Distance = -faceNormal.dot(plane0Center);\n      plane0.fromPointNormal(plane0Center, faceNormal);\n      const plane1Center = scratchPlaneCenter.copy(faceNormal).scale(radius).add(center);\n      const negatedFaceNormal = scratchPlaneNormal.copy(faceNormal).negate();\n      const plane1Distance = -negatedFaceNormal.dot(plane1Center);\n      plane1.fromPointNormal(plane1Center, negatedFaceNormal);\n      planeIndex += 2;\n    }\n\n    return this;\n  }\n\n  computeVisibility(boundingVolume) {\n    let intersect = INTERSECTION.INSIDE;\n\n    for (const plane of this.planes) {\n      const result = boundingVolume.intersectPlane(plane);\n\n      switch (result) {\n        case INTERSECTION.OUTSIDE:\n          return INTERSECTION.OUTSIDE;\n\n        case INTERSECTION.INTERSECTING:\n          intersect = INTERSECTION.INTERSECTING;\n          break;\n\n        default:\n      }\n    }\n\n    return intersect;\n  }\n\n  computeVisibilityWithPlaneMask(boundingVolume, parentPlaneMask) {\n    (0,lib_assert/* default */.Z)(Number.isFinite(parentPlaneMask), \'parentPlaneMask is required.\');\n\n    if (parentPlaneMask === culling_volume_CullingVolume.MASK_OUTSIDE || parentPlaneMask === culling_volume_CullingVolume.MASK_INSIDE) {\n      return parentPlaneMask;\n    }\n\n    let mask = culling_volume_CullingVolume.MASK_INSIDE;\n    const planes = this.planes;\n\n    for (let k = 0; k < this.planes.length; ++k) {\n      const flag = k < 31 ? 1 << k : 0;\n\n      if (k < 31 && (parentPlaneMask & flag) === 0) {\n        continue;\n      }\n\n      const plane = planes[k];\n      const result = boundingVolume.intersectPlane(plane);\n\n      if (result === INTERSECTION.OUTSIDE) {\n        return culling_volume_CullingVolume.MASK_OUTSIDE;\n      } else if (result === INTERSECTION.INTERSECTING) {\n        mask |= flag;\n      }\n    }\n\n    return mask;\n  }\n\n}\n\n(0,defineProperty/* default */.Z)(culling_volume_CullingVolume, "MASK_OUTSIDE", 0xffffffff);\n\n(0,defineProperty/* default */.Z)(culling_volume_CullingVolume, "MASK_INSIDE", 0x00000000);\n\n(0,defineProperty/* default */.Z)(culling_volume_CullingVolume, "MASK_INDETERMINATE", 0x7fffffff);\n//# sourceMappingURL=culling-volume.js.map\n;// CONCATENATED MODULE: ./node_modules/@math.gl/culling/dist/esm/lib/perspective-off-center-frustum.js\n\n\n\n\nconst scratchPlaneUpVector = new vector3/* default */.Z();\nconst scratchPlaneRightVector = new vector3/* default */.Z();\nconst scratchPlaneNearCenter = new vector3/* default */.Z();\nconst scratchPlaneFarCenter = new vector3/* default */.Z();\nconst perspective_off_center_frustum_scratchPlaneNormal = new vector3/* default */.Z();\nclass perspective_off_center_frustum_PerspectiveOffCenterFrustum {\n  constructor(options = {}) {\n    _defineProperty(this, "left", void 0);\n\n    _defineProperty(this, "_left", void 0);\n\n    _defineProperty(this, "right", void 0);\n\n    _defineProperty(this, "_right", void 0);\n\n    _defineProperty(this, "top", void 0);\n\n    _defineProperty(this, "_top", void 0);\n\n    _defineProperty(this, "bottom", void 0);\n\n    _defineProperty(this, "_bottom", void 0);\n\n    _defineProperty(this, "near", void 0);\n\n    _defineProperty(this, "_near", void 0);\n\n    _defineProperty(this, "far", void 0);\n\n    _defineProperty(this, "_far", void 0);\n\n    _defineProperty(this, "_cullingVolume", new CullingVolume([new Plane(), new Plane(), new Plane(), new Plane(), new Plane(), new Plane()]));\n\n    _defineProperty(this, "_perspectiveMatrix", new Matrix4());\n\n    _defineProperty(this, "_infinitePerspective", new Matrix4());\n\n    const {\n      near = 1.0,\n      far = 500000000.0\n    } = options;\n    this.left = options.left;\n    this._left = undefined;\n    this.right = options.right;\n    this._right = undefined;\n    this.top = options.top;\n    this._top = undefined;\n    this.bottom = options.bottom;\n    this._bottom = undefined;\n    this.near = near;\n    this._near = near;\n    this.far = far;\n    this._far = far;\n  }\n\n  clone() {\n    return new perspective_off_center_frustum_PerspectiveOffCenterFrustum({\n      right: this.right,\n      left: this.left,\n      top: this.top,\n      bottom: this.bottom,\n      near: this.near,\n      far: this.far\n    });\n  }\n\n  equals(other) {\n    return other && other instanceof perspective_off_center_frustum_PerspectiveOffCenterFrustum && this.right === other.right && this.left === other.left && this.top === other.top && this.bottom === other.bottom && this.near === other.near && this.far === other.far;\n  }\n\n  get projectionMatrix() {\n    this._update();\n\n    return this._perspectiveMatrix;\n  }\n\n  get infiniteProjectionMatrix() {\n    this._update();\n\n    return this._infinitePerspective;\n  }\n\n  computeCullingVolume(position, direction, up) {\n    assert(position, \'position is required.\');\n    assert(direction, \'direction is required.\');\n    assert(up, \'up is required.\');\n    const planes = this._cullingVolume.planes;\n    up = scratchPlaneUpVector.copy(up).normalize();\n    const right = scratchPlaneRightVector.copy(direction).cross(up).normalize();\n    const nearCenter = scratchPlaneNearCenter.copy(direction).multiplyByScalar(this.near).add(position);\n    const farCenter = scratchPlaneFarCenter.copy(direction).multiplyByScalar(this.far).add(position);\n    let normal = perspective_off_center_frustum_scratchPlaneNormal;\n    normal.copy(right).multiplyByScalar(this.left).add(nearCenter).subtract(position).cross(up);\n    planes[0].fromPointNormal(position, normal);\n    normal.copy(right).multiplyByScalar(this.right).add(nearCenter).subtract(position).cross(up).negate();\n    planes[1].fromPointNormal(position, normal);\n    normal.copy(up).multiplyByScalar(this.bottom).add(nearCenter).subtract(position).cross(right).negate();\n    planes[2].fromPointNormal(position, normal);\n    normal.copy(up).multiplyByScalar(this.top).add(nearCenter).subtract(position).cross(right);\n    planes[3].fromPointNormal(position, normal);\n    normal = new Vector3().copy(direction);\n    planes[4].fromPointNormal(nearCenter, normal);\n    normal.negate();\n    planes[5].fromPointNormal(farCenter, normal);\n    return this._cullingVolume;\n  }\n\n  getPixelDimensions(drawingBufferWidth, drawingBufferHeight, distance, result) {\n    this._update();\n\n    assert(Number.isFinite(drawingBufferWidth) && Number.isFinite(drawingBufferHeight));\n    assert(drawingBufferWidth > 0);\n    assert(drawingBufferHeight > 0);\n    assert(distance > 0);\n    assert(result);\n    const inverseNear = 1.0 / this.near;\n    let tanTheta = this.top * inverseNear;\n    const pixelHeight = 2.0 * distance * tanTheta / drawingBufferHeight;\n    tanTheta = this.right * inverseNear;\n    const pixelWidth = 2.0 * distance * tanTheta / drawingBufferWidth;\n    result.x = pixelWidth;\n    result.y = pixelHeight;\n    return result;\n  }\n\n  _update() {\n    assert(Number.isFinite(this.right) && Number.isFinite(this.left) && Number.isFinite(this.top) && Number.isFinite(this.bottom) && Number.isFinite(this.near) && Number.isFinite(this.far));\n    const {\n      top,\n      bottom,\n      right,\n      left,\n      near,\n      far\n    } = this;\n\n    if (top !== this._top || bottom !== this._bottom || left !== this._left || right !== this._right || near !== this._near || far !== this._far) {\n      assert(this.near > 0 && this.near < this.far, \'near must be greater than zero and less than far.\');\n      this._left = left;\n      this._right = right;\n      this._top = top;\n      this._bottom = bottom;\n      this._near = near;\n      this._far = far;\n      this._perspectiveMatrix = new Matrix4().frustum({\n        left,\n        right,\n        bottom,\n        top,\n        near,\n        far\n      });\n      this._infinitePerspective = new Matrix4().frustum({\n        left,\n        right,\n        bottom,\n        top,\n        near,\n        far: Infinity\n      });\n    }\n  }\n\n}\n//# sourceMappingURL=perspective-off-center-frustum.js.map\n;// CONCATENATED MODULE: ./node_modules/@math.gl/culling/dist/esm/lib/perspective-frustum.js\n\n\n\n\nconst defined = val => val !== null && typeof val !== \'undefined\';\n\nclass PerspectiveFrustum {\n  constructor(options = {}) {\n    _defineProperty(this, "_offCenterFrustum", new PerspectiveOffCenterFrustum());\n\n    _defineProperty(this, "fov", void 0);\n\n    _defineProperty(this, "_fov", void 0);\n\n    _defineProperty(this, "_fovy", void 0);\n\n    _defineProperty(this, "_sseDenominator", void 0);\n\n    _defineProperty(this, "aspectRatio", void 0);\n\n    _defineProperty(this, "_aspectRatio", void 0);\n\n    _defineProperty(this, "near", void 0);\n\n    _defineProperty(this, "_near", void 0);\n\n    _defineProperty(this, "far", void 0);\n\n    _defineProperty(this, "_far", void 0);\n\n    _defineProperty(this, "xOffset", void 0);\n\n    _defineProperty(this, "_xOffset", void 0);\n\n    _defineProperty(this, "yOffset", void 0);\n\n    _defineProperty(this, "_yOffset", void 0);\n\n    const {\n      fov,\n      aspectRatio,\n      near = 1.0,\n      far = 500000000.0,\n      xOffset = 0.0,\n      yOffset = 0.0\n    } = options;\n    this.fov = fov;\n    this.aspectRatio = aspectRatio;\n    this.near = near;\n    this.far = far;\n    this.xOffset = xOffset;\n    this.yOffset = yOffset;\n  }\n\n  clone() {\n    return new PerspectiveFrustum({\n      aspectRatio: this.aspectRatio,\n      fov: this.fov,\n      near: this.near,\n      far: this.far\n    });\n  }\n\n  equals(other) {\n    if (!defined(other) || !(other instanceof PerspectiveFrustum)) {\n      return false;\n    }\n\n    this._update();\n\n    other._update();\n\n    return this.fov === other.fov && this.aspectRatio === other.aspectRatio && this.near === other.near && this.far === other.far && this._offCenterFrustum.equals(other._offCenterFrustum);\n  }\n\n  get projectionMatrix() {\n    this._update();\n\n    return this._offCenterFrustum.projectionMatrix;\n  }\n\n  get infiniteProjectionMatrix() {\n    this._update();\n\n    return this._offCenterFrustum.infiniteProjectionMatrix;\n  }\n\n  get fovy() {\n    this._update();\n\n    return this._fovy;\n  }\n\n  get sseDenominator() {\n    this._update();\n\n    return this._sseDenominator;\n  }\n\n  computeCullingVolume(position, direction, up) {\n    this._update();\n\n    return this._offCenterFrustum.computeCullingVolume(position, direction, up);\n  }\n\n  getPixelDimensions(drawingBufferWidth, drawingBufferHeight, distance, result) {\n    this._update();\n\n    return this._offCenterFrustum.getPixelDimensions(drawingBufferWidth, drawingBufferHeight, distance, result || new Vector2());\n  }\n\n  _update() {\n    assert(Number.isFinite(this.fov) && Number.isFinite(this.aspectRatio) && Number.isFinite(this.near) && Number.isFinite(this.far));\n    const f = this._offCenterFrustum;\n\n    if (this.fov !== this._fov || this.aspectRatio !== this._aspectRatio || this.near !== this._near || this.far !== this._far || this.xOffset !== this._xOffset || this.yOffset !== this._yOffset) {\n      assert(this.fov >= 0 && this.fov < Math.PI);\n      assert(this.aspectRatio > 0);\n      assert(this.near >= 0 && this.near < this.far);\n      this._aspectRatio = this.aspectRatio;\n      this._fov = this.fov;\n      this._fovy = this.aspectRatio <= 1 ? this.fov : Math.atan(Math.tan(this.fov * 0.5) / this.aspectRatio) * 2.0;\n      this._near = this.near;\n      this._far = this.far;\n      this._sseDenominator = 2.0 * Math.tan(0.5 * this._fovy);\n      this._xOffset = this.xOffset;\n      this._yOffset = this.yOffset;\n      f.top = this.near * Math.tan(0.5 * this._fovy);\n      f.bottom = -f.top;\n      f.right = this.aspectRatio * f.top;\n      f.left = -f.right;\n      f.near = this.near;\n      f.far = this.far;\n      f.right += this.xOffset;\n      f.left += this.xOffset;\n      f.top += this.yOffset;\n      f.bottom += this.yOffset;\n    }\n  }\n\n}\n//# sourceMappingURL=perspective-frustum.js.map\n;// CONCATENATED MODULE: ./node_modules/@math.gl/culling/dist/esm/lib/algorithms/bounding-sphere-from-points.js\n\n\nconst fromPointsXMin = new vector3/* default */.Z();\nconst fromPointsYMin = new vector3/* default */.Z();\nconst fromPointsZMin = new vector3/* default */.Z();\nconst fromPointsXMax = new vector3/* default */.Z();\nconst fromPointsYMax = new vector3/* default */.Z();\nconst fromPointsZMax = new vector3/* default */.Z();\nconst fromPointsCurrentPos = new vector3/* default */.Z();\nconst fromPointsScratch = new vector3/* default */.Z();\nconst fromPointsRitterCenter = new vector3/* default */.Z();\nconst fromPointsMinBoxPt = new vector3/* default */.Z();\nconst fromPointsMaxBoxPt = new vector3/* default */.Z();\nconst fromPointsNaiveCenterScratch = new vector3/* default */.Z();\nconst volumeConstant = 4.0 / 3.0 * Math.PI;\nfunction makeBoundingSphereFromPoints(positions, result = new BoundingSphere()) {\n  if (!positions || positions.length === 0) {\n    return result.fromCenterRadius([0, 0, 0], 0);\n  }\n\n  const currentPos = fromPointsCurrentPos.copy(positions[0]);\n  const xMin = fromPointsXMin.copy(currentPos);\n  const yMin = fromPointsYMin.copy(currentPos);\n  const zMin = fromPointsZMin.copy(currentPos);\n  const xMax = fromPointsXMax.copy(currentPos);\n  const yMax = fromPointsYMax.copy(currentPos);\n  const zMax = fromPointsZMax.copy(currentPos);\n\n  for (const position of positions) {\n    currentPos.copy(position);\n    const x = currentPos.x;\n    const y = currentPos.y;\n    const z = currentPos.z;\n\n    if (x < xMin.x) {\n      xMin.copy(currentPos);\n    }\n\n    if (x > xMax.x) {\n      xMax.copy(currentPos);\n    }\n\n    if (y < yMin.y) {\n      yMin.copy(currentPos);\n    }\n\n    if (y > yMax.y) {\n      yMax.copy(currentPos);\n    }\n\n    if (z < zMin.z) {\n      zMin.copy(currentPos);\n    }\n\n    if (z > zMax.z) {\n      zMax.copy(currentPos);\n    }\n  }\n\n  const xSpan = fromPointsScratch.copy(xMax).subtract(xMin).magnitudeSquared();\n  const ySpan = fromPointsScratch.copy(yMax).subtract(yMin).magnitudeSquared();\n  const zSpan = fromPointsScratch.copy(zMax).subtract(zMin).magnitudeSquared();\n  let diameter1 = xMin;\n  let diameter2 = xMax;\n  let maxSpan = xSpan;\n\n  if (ySpan > maxSpan) {\n    maxSpan = ySpan;\n    diameter1 = yMin;\n    diameter2 = yMax;\n  }\n\n  if (zSpan > maxSpan) {\n    maxSpan = zSpan;\n    diameter1 = zMin;\n    diameter2 = zMax;\n  }\n\n  const ritterCenter = fromPointsRitterCenter;\n  ritterCenter.x = (diameter1.x + diameter2.x) * 0.5;\n  ritterCenter.y = (diameter1.y + diameter2.y) * 0.5;\n  ritterCenter.z = (diameter1.z + diameter2.z) * 0.5;\n  let radiusSquared = fromPointsScratch.copy(diameter2).subtract(ritterCenter).magnitudeSquared();\n  let ritterRadius = Math.sqrt(radiusSquared);\n  const minBoxPt = fromPointsMinBoxPt;\n  minBoxPt.x = xMin.x;\n  minBoxPt.y = yMin.y;\n  minBoxPt.z = zMin.z;\n  const maxBoxPt = fromPointsMaxBoxPt;\n  maxBoxPt.x = xMax.x;\n  maxBoxPt.y = yMax.y;\n  maxBoxPt.z = zMax.z;\n  const naiveCenter = fromPointsNaiveCenterScratch.copy(minBoxPt).add(maxBoxPt).multiplyByScalar(0.5);\n  let naiveRadius = 0;\n\n  for (const position of positions) {\n    currentPos.copy(position);\n    const r = fromPointsScratch.copy(currentPos).subtract(naiveCenter).magnitude();\n\n    if (r > naiveRadius) {\n      naiveRadius = r;\n    }\n\n    const oldCenterToPointSquared = fromPointsScratch.copy(currentPos).subtract(ritterCenter).magnitudeSquared();\n\n    if (oldCenterToPointSquared > radiusSquared) {\n      const oldCenterToPoint = Math.sqrt(oldCenterToPointSquared);\n      ritterRadius = (ritterRadius + oldCenterToPoint) * 0.5;\n      radiusSquared = ritterRadius * ritterRadius;\n      const oldToNew = oldCenterToPoint - ritterRadius;\n      ritterCenter.x = (ritterRadius * ritterCenter.x + oldToNew * currentPos.x) / oldCenterToPoint;\n      ritterCenter.y = (ritterRadius * ritterCenter.y + oldToNew * currentPos.y) / oldCenterToPoint;\n      ritterCenter.z = (ritterRadius * ritterCenter.z + oldToNew * currentPos.z) / oldCenterToPoint;\n    }\n  }\n\n  if (ritterRadius < naiveRadius) {\n    ritterCenter.to(result.center);\n    result.radius = ritterRadius;\n  } else {\n    naiveCenter.to(result.center);\n    result.radius = naiveRadius;\n  }\n\n  return result;\n}\n//# sourceMappingURL=bounding-sphere-from-points.js.map\n;// CONCATENATED MODULE: ./node_modules/@math.gl/core/dist/esm/lib/math-utils.js\n/* harmony default export */ var math_utils = ({\n  EPSILON1: 1e-1,\n  EPSILON2: 1e-2,\n  EPSILON3: 1e-3,\n  EPSILON4: 1e-4,\n  EPSILON5: 1e-5,\n  EPSILON6: 1e-6,\n  EPSILON7: 1e-7,\n  EPSILON8: 1e-8,\n  EPSILON9: 1e-9,\n  EPSILON10: 1e-10,\n  EPSILON11: 1e-11,\n  EPSILON12: 1e-12,\n  EPSILON13: 1e-13,\n  EPSILON14: 1e-14,\n  EPSILON15: 1e-15,\n  EPSILON16: 1e-16,\n  EPSILON17: 1e-17,\n  EPSILON18: 1e-18,\n  EPSILON19: 1e-19,\n  EPSILON20: 1e-20,\n  PI_OVER_TWO: Math.PI / 2,\n  PI_OVER_FOUR: Math.PI / 4,\n  PI_OVER_SIX: Math.PI / 6,\n  TWO_PI: Math.PI * 2\n});\n//# sourceMappingURL=math-utils.js.map\n;// CONCATENATED MODULE: ./node_modules/@math.gl/culling/dist/esm/lib/algorithms/compute-eigen-decomposition.js\n\nconst scratchMatrix = new matrix3/* default */.Z();\nconst scratchUnitary = new matrix3/* default */.Z();\nconst scratchDiagonal = new matrix3/* default */.Z();\nconst jMatrix = new matrix3/* default */.Z();\nconst jMatrixTranspose = new matrix3/* default */.Z();\nfunction computeEigenDecomposition(matrix, result = {}) {\n  const EIGEN_TOLERANCE = math_utils.EPSILON20;\n  const EIGEN_MAX_SWEEPS = 10;\n  let count = 0;\n  let sweep = 0;\n  const unitaryMatrix = scratchUnitary;\n  const diagonalMatrix = scratchDiagonal;\n  unitaryMatrix.identity();\n  diagonalMatrix.copy(matrix);\n  const epsilon = EIGEN_TOLERANCE * computeFrobeniusNorm(diagonalMatrix);\n\n  while (sweep < EIGEN_MAX_SWEEPS && offDiagonalFrobeniusNorm(diagonalMatrix) > epsilon) {\n    shurDecomposition(diagonalMatrix, jMatrix);\n    jMatrixTranspose.copy(jMatrix).transpose();\n    diagonalMatrix.multiplyRight(jMatrix);\n    diagonalMatrix.multiplyLeft(jMatrixTranspose);\n    unitaryMatrix.multiplyRight(jMatrix);\n\n    if (++count > 2) {\n      ++sweep;\n      count = 0;\n    }\n  }\n\n  result.unitary = unitaryMatrix.toTarget(result.unitary);\n  result.diagonal = diagonalMatrix.toTarget(result.diagonal);\n  return result;\n}\n\nfunction computeFrobeniusNorm(matrix) {\n  let norm = 0.0;\n\n  for (let i = 0; i < 9; ++i) {\n    const temp = matrix[i];\n    norm += temp * temp;\n  }\n\n  return Math.sqrt(norm);\n}\n\nconst rowVal = [1, 0, 0];\nconst colVal = [2, 2, 1];\n\nfunction offDiagonalFrobeniusNorm(matrix) {\n  let norm = 0.0;\n\n  for (let i = 0; i < 3; ++i) {\n    const temp = matrix[scratchMatrix.getElementIndex(colVal[i], rowVal[i])];\n    norm += 2.0 * temp * temp;\n  }\n\n  return Math.sqrt(norm);\n}\n\nfunction shurDecomposition(matrix, result) {\n  const tolerance = math_utils.EPSILON15;\n  let maxDiagonal = 0.0;\n  let rotAxis = 1;\n\n  for (let i = 0; i < 3; ++i) {\n    const temp = Math.abs(matrix[scratchMatrix.getElementIndex(colVal[i], rowVal[i])]);\n\n    if (temp > maxDiagonal) {\n      rotAxis = i;\n      maxDiagonal = temp;\n    }\n  }\n\n  const p = rowVal[rotAxis];\n  const q = colVal[rotAxis];\n  let c = 1.0;\n  let s = 0.0;\n\n  if (Math.abs(matrix[scratchMatrix.getElementIndex(q, p)]) > tolerance) {\n    const qq = matrix[scratchMatrix.getElementIndex(q, q)];\n    const pp = matrix[scratchMatrix.getElementIndex(p, p)];\n    const qp = matrix[scratchMatrix.getElementIndex(q, p)];\n    const tau = (qq - pp) / 2.0 / qp;\n    let t;\n\n    if (tau < 0.0) {\n      t = -1.0 / (-tau + Math.sqrt(1.0 + tau * tau));\n    } else {\n      t = 1.0 / (tau + Math.sqrt(1.0 + tau * tau));\n    }\n\n    c = 1.0 / Math.sqrt(1.0 + t * t);\n    s = t * c;\n  }\n\n  matrix3/* default.IDENTITY.to */.Z.IDENTITY.to(result);\n  result[scratchMatrix.getElementIndex(p, p)] = result[scratchMatrix.getElementIndex(q, q)] = c;\n  result[scratchMatrix.getElementIndex(q, p)] = s;\n  result[scratchMatrix.getElementIndex(p, q)] = -s;\n  return result;\n}\n//# sourceMappingURL=compute-eigen-decomposition.js.map\n;// CONCATENATED MODULE: ./node_modules/@math.gl/culling/dist/esm/lib/algorithms/bounding-box-from-points.js\n\n\n\n\nconst bounding_box_from_points_scratchVector2 = new vector3/* default */.Z();\nconst bounding_box_from_points_scratchVector3 = new vector3/* default */.Z();\nconst scratchVector4 = new vector3/* default */.Z();\nconst scratchVector5 = new vector3/* default */.Z();\nconst scratchVector6 = new vector3/* default */.Z();\nconst scratchCovarianceResult = new matrix3/* default */.Z();\nconst scratchEigenResult = {\n  diagonal: new matrix3/* default */.Z(),\n  unitary: new matrix3/* default */.Z()\n};\nfunction makeOrientedBoundingBoxFromPoints(positions, result = new OrientedBoundingBox()) {\n  if (!positions || positions.length === 0) {\n    result.halfAxes = new matrix3/* default */.Z([0, 0, 0, 0, 0, 0, 0, 0, 0]);\n    result.center = new vector3/* default */.Z();\n    return result;\n  }\n\n  const length = positions.length;\n  const meanPoint = new vector3/* default */.Z(0, 0, 0);\n\n  for (const position of positions) {\n    meanPoint.add(position);\n  }\n\n  const invLength = 1.0 / length;\n  meanPoint.multiplyByScalar(invLength);\n  let exx = 0.0;\n  let exy = 0.0;\n  let exz = 0.0;\n  let eyy = 0.0;\n  let eyz = 0.0;\n  let ezz = 0.0;\n\n  for (const position of positions) {\n    const p = bounding_box_from_points_scratchVector2.copy(position).subtract(meanPoint);\n    exx += p.x * p.x;\n    exy += p.x * p.y;\n    exz += p.x * p.z;\n    eyy += p.y * p.y;\n    eyz += p.y * p.z;\n    ezz += p.z * p.z;\n  }\n\n  exx *= invLength;\n  exy *= invLength;\n  exz *= invLength;\n  eyy *= invLength;\n  eyz *= invLength;\n  ezz *= invLength;\n  const covarianceMatrix = scratchCovarianceResult;\n  covarianceMatrix[0] = exx;\n  covarianceMatrix[1] = exy;\n  covarianceMatrix[2] = exz;\n  covarianceMatrix[3] = exy;\n  covarianceMatrix[4] = eyy;\n  covarianceMatrix[5] = eyz;\n  covarianceMatrix[6] = exz;\n  covarianceMatrix[7] = eyz;\n  covarianceMatrix[8] = ezz;\n  const {\n    unitary\n  } = computeEigenDecomposition(covarianceMatrix, scratchEigenResult);\n  const rotation = result.halfAxes.copy(unitary);\n  let v1 = rotation.getColumn(0, scratchVector4);\n  let v2 = rotation.getColumn(1, scratchVector5);\n  let v3 = rotation.getColumn(2, scratchVector6);\n  let u1 = -Number.MAX_VALUE;\n  let u2 = -Number.MAX_VALUE;\n  let u3 = -Number.MAX_VALUE;\n  let l1 = Number.MAX_VALUE;\n  let l2 = Number.MAX_VALUE;\n  let l3 = Number.MAX_VALUE;\n\n  for (const position of positions) {\n    bounding_box_from_points_scratchVector2.copy(position);\n    u1 = Math.max(bounding_box_from_points_scratchVector2.dot(v1), u1);\n    u2 = Math.max(bounding_box_from_points_scratchVector2.dot(v2), u2);\n    u3 = Math.max(bounding_box_from_points_scratchVector2.dot(v3), u3);\n    l1 = Math.min(bounding_box_from_points_scratchVector2.dot(v1), l1);\n    l2 = Math.min(bounding_box_from_points_scratchVector2.dot(v2), l2);\n    l3 = Math.min(bounding_box_from_points_scratchVector2.dot(v3), l3);\n  }\n\n  v1 = v1.multiplyByScalar(0.5 * (l1 + u1));\n  v2 = v2.multiplyByScalar(0.5 * (l2 + u2));\n  v3 = v3.multiplyByScalar(0.5 * (l3 + u3));\n  result.center.copy(v1).add(v2).add(v3);\n  const scale = bounding_box_from_points_scratchVector3.set(u1 - l1, u2 - l2, u3 - l3).multiplyByScalar(0.5);\n  const scaleMatrix = new matrix3/* default */.Z([scale[0], 0, 0, 0, scale[1], 0, 0, 0, scale[2]]);\n  result.halfAxes.multiplyRight(scaleMatrix);\n  return result;\n}\nfunction makeAxisAlignedBoundingBoxFromPoints(positions, result = new AxisAlignedBoundingBox()) {\n  if (!positions || positions.length === 0) {\n    result.minimum.set(0, 0, 0);\n    result.maximum.set(0, 0, 0);\n    result.center.set(0, 0, 0);\n    result.halfDiagonal.set(0, 0, 0);\n    return result;\n  }\n\n  let minimumX = positions[0][0];\n  let minimumY = positions[0][1];\n  let minimumZ = positions[0][2];\n  let maximumX = positions[0][0];\n  let maximumY = positions[0][1];\n  let maximumZ = positions[0][2];\n\n  for (const p of positions) {\n    const x = p[0];\n    const y = p[1];\n    const z = p[2];\n    minimumX = Math.min(x, minimumX);\n    maximumX = Math.max(x, maximumX);\n    minimumY = Math.min(y, minimumY);\n    maximumY = Math.max(y, maximumY);\n    minimumZ = Math.min(z, minimumZ);\n    maximumZ = Math.max(z, maximumZ);\n  }\n\n  result.minimum.set(minimumX, minimumY, minimumZ);\n  result.maximum.set(maximumX, maximumY, maximumZ);\n  result.center.copy(result.minimum).add(result.maximum).scale(0.5);\n  result.halfDiagonal.copy(result.maximum).subtract(result.center);\n  return result;\n}\n//# sourceMappingURL=bounding-box-from-points.js.map\n;// CONCATENATED MODULE: ./node_modules/@math.gl/culling/dist/esm/index.js\n\n\n\n\n\n\n\n\n\n\n\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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YWNrOi8vdnVlMy13ZWJwYWNrNS8uL25vZGVfbW9kdWxlcy9AbWF0aC5nbC9jdWxsaW5nL2Rpc3QvZXNtL2NvbnN0YW50cy5qcz9mZTdhIiwid2VicGFjazovL3Z1ZTMtd2VicGFjazUvLi9ub2RlX21vZHVsZXMvQG1hdGguZ2wvY3VsbGluZy9kaXN0L2VzbS9saWIvYm91bmRpbmctdm9sdW1lcy9heGlzLWFsaWduZWQtYm91bmRpbmctYm94LmpzPzk1NGIiLCJ3ZWJwYWNrOi8vdnVlMy13ZWJwYWNrNS8uL25vZGVfbW9kdWxlcy9AbWF0aC5nbC9jdWxsaW5nL2Rpc3QvZXNtL2xpYi9ib3VuZGluZy12b2x1bWVzL2JvdW5kaW5nLXNwaGVyZS5qcz83MDU1Iiwid2VicGFjazovL3Z1ZTMtd2VicGFjazUvLi9ub2RlX21vZHVsZXMvQG1hdGguZ2wvY3VsbGluZy9kaXN0L2VzbS9saWIvYm91bmRpbmctdm9sdW1lcy9vcmllbnRlZC1ib3VuZGluZy1ib3guanM/MzI2MSIsIndlYnBhY2s6Ly92dWUzLXdlYnBhY2s1Ly4vbm9kZV9tb2R1bGVzL0BtYXRoLmdsL2N1bGxpbmcvZGlzdC9lc20vbGliL3BsYW5lLmpzPzg1YzYiLCJ3ZWJwYWNrOi8vdnVlMy13ZWJwYWNrNS8uL25vZGVfbW9kdWxlcy9AbWF0aC5nbC9jdWxsaW5nL2Rpc3QvZXNtL2xpYi9jdWxsaW5nLXZvbHVtZS5qcz83MTVkIiwid2VicGFjazovL3Z1ZTMtd2VicGFjazUvLi9ub2RlX21vZHVsZXMvQG1hdGguZ2wvY3VsbGluZy9kaXN0L2VzbS9saWIvcGVyc3BlY3RpdmUtb2ZmLWNlbnRlci1mcnVzdHVtLmpzPzliMjMiLCJ3ZWJwYWNrOi8vdnVlMy13ZWJwYWNrNS8uL25vZGVfbW9kdWxlcy9AbWF0aC5nbC9jdWxsaW5nL2Rpc3QvZXNtL2xpYi9wZXJzcGVjdGl2ZS1mcnVzdHVtLmpzPzgwYWUiLCJ3ZWJwYWNrOi8vdnVlMy13ZWJwYWNrNS8uL25vZGVfbW9kdWxlcy9AbWF0aC5nbC9jdWxsaW5nL2Rpc3QvZXNtL2xpYi9hbGdvcml0aG1zL2JvdW5kaW5nLXNwaGVyZS1mcm9tLXBvaW50cy5qcz84Y2M5Iiwid2VicGFjazovL3Z1ZTMtd2VicGFjazUvLi9ub2RlX21vZHVsZXMvQG1hdGguZ2wvY29yZS9kaXN0L2VzbS9saWIvbWF0aC11dGlscy5qcz8zZTIxIiwid2VicGFjazovL3Z1ZTMtd2VicGFjazUvLi9ub2RlX21vZHVsZXMvQG1hdGguZ2wvY3VsbGluZy9kaXN0L2VzbS9saWIvYWxnb3JpdGhtcy9jb21wdXRlLWVpZ2VuLWRlY29tcG9zaXRpb24uanM/MTQxYyIsIndlYnBhY2s6Ly92dWUzLXdlYnBhY2s1Ly4vbm9kZV9tb2R1bGVzL0BtYXRoLmdsL2N1bGxpbmcvZGlzdC9lc20vbGliL2FsZ29yaXRobXMvYm91bmRpbmctYm94LWZyb20tcG9pbnRzLmpzP2MyNzkiLCJ3ZWJwYWNrOi8vdnVlMy13ZWJwYWNrNS8uL25vZGVfbW9kdWxlcy9AbWF0aC5nbC9jdWxsaW5nL2Rpc3QvZXNtL2luZGV4LmpzPzVlY2UiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IGNvbnN0IElOVEVSU0VDVElPTiA9IHtcbiAgT1VUU0lERTogLTEsXG4gIElOVEVSU0VDVElORzogMCxcbiAgSU5TSURFOiAxXG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y29uc3RhbnRzLmpzLm1hcCIsImltcG9ydCBfZGVmaW5lUHJvcGVydHkgZnJvbSBcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL2RlZmluZVByb3BlcnR5XCI7XG5pbXBvcnQgeyBWZWN0b3IzIH0gZnJvbSAnQG1hdGguZ2wvY29yZSc7XG5pbXBvcnQgeyBJTlRFUlNFQ1RJT04gfSBmcm9tICcuLi8uLi9jb25zdGFudHMnO1xuY29uc3Qgc2NyYXRjaFZlY3RvciA9IG5ldyBWZWN0b3IzKCk7XG5jb25zdCBzY3JhdGNoTm9ybWFsID0gbmV3IFZlY3RvcjMoKTtcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEF4aXNBbGlnbmVkQm91bmRpbmdCb3gge1xuICBjb25zdHJ1Y3RvcihtaW5pbXVtID0gWzAsIDAsIDBdLCBtYXhpbXVtID0gWzAsIDAsIDBdLCBjZW50ZXIpIHtcbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJjZW50ZXJcIiwgdm9pZCAwKTtcblxuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImhhbGZEaWFnb25hbFwiLCB2b2lkIDApO1xuXG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwibWluaW11bVwiLCB2b2lkIDApO1xuXG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwibWF4aW11bVwiLCB2b2lkIDApO1xuXG4gICAgY2VudGVyID0gY2VudGVyIHx8IHNjcmF0Y2hWZWN0b3IuY29weShtaW5pbXVtKS5hZGQobWF4aW11bSkuc2NhbGUoMC41KTtcbiAgICB0aGlzLmNlbnRlciA9IG5ldyBWZWN0b3IzKGNlbnRlcik7XG4gICAgdGhpcy5oYWxmRGlhZ29uYWwgPSBuZXcgVmVjdG9yMyhtYXhpbXVtKS5zdWJ0cmFjdCh0aGlzLmNlbnRlcik7XG4gICAgdGhpcy5taW5pbXVtID0gbmV3IFZlY3RvcjMobWluaW11bSk7XG4gICAgdGhpcy5tYXhpbXVtID0gbmV3IFZlY3RvcjMobWF4aW11bSk7XG4gIH1cblxuICBjbG9uZSgpIHtcbiAgICByZXR1cm4gbmV3IEF4aXNBbGlnbmVkQm91bmRpbmdCb3godGhpcy5taW5pbXVtLCB0aGlzLm1heGltdW0sIHRoaXMuY2VudGVyKTtcbiAgfVxuXG4gIGVxdWFscyhyaWdodCkge1xuICAgIHJldHVybiB0aGlzID09PSByaWdodCB8fCBCb29sZWFuKHJpZ2h0KSAmJiB0aGlzLm1pbmltdW0uZXF1YWxzKHJpZ2h0Lm1pbmltdW0pICYmIHRoaXMubWF4aW11bS5lcXVhbHMocmlnaHQubWF4aW11bSk7XG4gIH1cblxuICB0cmFuc2Zvcm0odHJhbnNmb3JtKSB7XG4gICAgdGhpcy5jZW50ZXIudHJhbnNmb3JtQXNQb2ludCh0cmFuc2Zvcm0pO1xuICAgIHRoaXMuaGFsZkRpYWdvbmFsLnRyYW5zZm9ybSh0cmFuc2Zvcm0pO1xuICAgIHRoaXMubWluaW11bS50cmFuc2Zvcm0odHJhbnNmb3JtKTtcbiAgICB0aGlzLm1heGltdW0udHJhbnNmb3JtKHRyYW5zZm9ybSk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICBpbnRlcnNlY3RQbGFuZShwbGFuZSkge1xuICAgIGNvbnN0IHtcbiAgICAgIGhhbGZEaWFnb25hbFxuICAgIH0gPSB0aGlzO1xuICAgIGNvbnN0IG5vcm1hbCA9IHNjcmF0Y2hOb3JtYWwuZnJvbShwbGFuZS5ub3JtYWwpO1xuICAgIGNvbnN0IGUgPSBoYWxmRGlhZ29uYWwueCAqIE1hdGguYWJzKG5vcm1hbC54KSArIGhhbGZEaWFnb25hbC55ICogTWF0aC5hYnMobm9ybWFsLnkpICsgaGFsZkRpYWdvbmFsLnogKiBNYXRoLmFicyhub3JtYWwueik7XG4gICAgY29uc3QgcyA9IHRoaXMuY2VudGVyLmRvdChub3JtYWwpICsgcGxhbmUuZGlzdGFuY2U7XG5cbiAgICBpZiAocyAtIGUgPiAwKSB7XG4gICAgICByZXR1cm4gSU5URVJTRUNUSU9OLklOU0lERTtcbiAgICB9XG5cbiAgICBpZiAocyArIGUgPCAwKSB7XG4gICAgICByZXR1cm4gSU5URVJTRUNUSU9OLk9VVFNJREU7XG4gICAgfVxuXG4gICAgcmV0dXJuIElOVEVSU0VDVElPTi5JTlRFUlNFQ1RJTkc7XG4gIH1cblxuICBkaXN0YW5jZVRvKHBvaW50KSB7XG4gICAgcmV0dXJuIE1hdGguc3FydCh0aGlzLmRpc3RhbmNlU3F1YXJlZFRvKHBvaW50KSk7XG4gIH1cblxuICBkaXN0YW5jZVNxdWFyZWRUbyhwb2ludCkge1xuICAgIGNvbnN0IG9mZnNldCA9IHNjcmF0Y2hWZWN0b3IuZnJvbShwb2ludCkuc3VidHJhY3QodGhpcy5jZW50ZXIpO1xuICAgIGNvbnN0IHtcbiAgICAgIGhhbGZEaWFnb25hbFxuICAgIH0gPSB0aGlzO1xuICAgIGxldCBkaXN0YW5jZVNxdWFyZWQgPSAwLjA7XG4gICAgbGV0IGQ7XG4gICAgZCA9IE1hdGguYWJzKG9mZnNldC54KSAtIGhhbGZEaWFnb25hbC54O1xuXG4gICAgaWYgKGQgPiAwKSB7XG4gICAgICBkaXN0YW5jZVNxdWFyZWQgKz0gZCAqIGQ7XG4gICAgfVxuXG4gICAgZCA9IE1hdGguYWJzKG9mZnNldC55KSAtIGhhbGZEaWFnb25hbC55O1xuXG4gICAgaWYgKGQgPiAwKSB7XG4gICAgICBkaXN0YW5jZVNxdWFyZWQgKz0gZCAqIGQ7XG4gICAgfVxuXG4gICAgZCA9IE1hdGguYWJzKG9mZnNldC56KSAtIGhhbGZEaWFnb25hbC56O1xuXG4gICAgaWYgKGQgPiAwKSB7XG4gICAgICBkaXN0YW5jZVNxdWFyZWQgKz0gZCAqIGQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIGRpc3RhbmNlU3F1YXJlZDtcbiAgfVxuXG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1heGlzLWFsaWduZWQtYm91bmRpbmctYm94LmpzLm1hcCIsImltcG9ydCBfZGVmaW5lUHJvcGVydHkgZnJvbSBcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL2RlZmluZVByb3BlcnR5XCI7XG5pbXBvcnQgeyBWZWN0b3IzIH0gZnJvbSAnQG1hdGguZ2wvY29yZSc7XG5pbXBvcnQgKiBhcyBtYXQ0IGZyb20gJ2dsLW1hdHJpeC9tYXQ0JztcbmltcG9ydCB7IElOVEVSU0VDVElPTiB9IGZyb20gJy4uLy4uL2NvbnN0YW50cyc7XG5jb25zdCBzY3JhdGNoVmVjdG9yID0gbmV3IFZlY3RvcjMoKTtcbmNvbnN0IHNjcmF0Y2hWZWN0b3IyID0gbmV3IFZlY3RvcjMoKTtcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEJvdW5kaW5nU3BoZXJlIHtcbiAgY29uc3RydWN0b3IoY2VudGVyID0gWzAsIDAsIDBdLCByYWRpdXMgPSAwLjApIHtcbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJjZW50ZXJcIiwgdm9pZCAwKTtcblxuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInJhZGl1c1wiLCB2b2lkIDApO1xuXG4gICAgdGhpcy5yYWRpdXMgPSAtMDtcbiAgICB0aGlzLmNlbnRlciA9IG5ldyBWZWN0b3IzKCk7XG4gICAgdGhpcy5mcm9tQ2VudGVyUmFkaXVzKGNlbnRlciwgcmFkaXVzKTtcbiAgfVxuXG4gIGZyb21DZW50ZXJSYWRpdXMoY2VudGVyLCByYWRpdXMpIHtcbiAgICB0aGlzLmNlbnRlci5mcm9tKGNlbnRlcik7XG4gICAgdGhpcy5yYWRpdXMgPSByYWRpdXM7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICBmcm9tQ29ybmVyUG9pbnRzKGNvcm5lciwgb3Bwb3NpdGVDb3JuZXIpIHtcbiAgICBvcHBvc2l0ZUNvcm5lciA9IHNjcmF0Y2hWZWN0b3IuZnJvbShvcHBvc2l0ZUNvcm5lcik7XG4gICAgdGhpcy5jZW50ZXIgPSBuZXcgVmVjdG9yMygpLmZyb20oY29ybmVyKS5hZGQob3Bwb3NpdGVDb3JuZXIpLnNjYWxlKDAuNSk7XG4gICAgdGhpcy5yYWRpdXMgPSB0aGlzLmNlbnRlci5kaXN0YW5jZShvcHBvc2l0ZUNvcm5lcik7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICBlcXVhbHMocmlnaHQpIHtcbiAgICByZXR1cm4gdGhpcyA9PT0gcmlnaHQgfHwgQm9vbGVhbihyaWdodCkgJiYgdGhpcy5jZW50ZXIuZXF1YWxzKHJpZ2h0LmNlbnRlcikgJiYgdGhpcy5yYWRpdXMgPT09IHJpZ2h0LnJhZGl1cztcbiAgfVxuXG4gIGNsb25lKCkge1xuICAgIHJldHVybiBuZXcgQm91bmRpbmdTcGhlcmUodGhpcy5jZW50ZXIsIHRoaXMucmFkaXVzKTtcbiAgfVxuXG4gIHVuaW9uKGJvdW5kaW5nU3BoZXJlKSB7XG4gICAgY29uc3QgbGVmdENlbnRlciA9IHRoaXMuY2VudGVyO1xuICAgIGNvbnN0IGxlZnRSYWRpdXMgPSB0aGlzLnJhZGl1cztcbiAgICBjb25zdCByaWdodENlbnRlciA9IGJvdW5kaW5nU3BoZXJlLmNlbnRlcjtcbiAgICBjb25zdCByaWdodFJhZGl1cyA9IGJvdW5kaW5nU3BoZXJlLnJhZGl1cztcbiAgICBjb25zdCB0b1JpZ2h0Q2VudGVyID0gc2NyYXRjaFZlY3Rvci5jb3B5KHJpZ2h0Q2VudGVyKS5zdWJ0cmFjdChsZWZ0Q2VudGVyKTtcbiAgICBjb25zdCBjZW50ZXJTZXBhcmF0aW9uID0gdG9SaWdodENlbnRlci5tYWduaXR1ZGUoKTtcblxuICAgIGlmIChsZWZ0UmFkaXVzID49IGNlbnRlclNlcGFyYXRpb24gKyByaWdodFJhZGl1cykge1xuICAgICAgcmV0dXJuIHRoaXMuY2xvbmUoKTtcbiAgICB9XG5cbiAgICBpZiAocmlnaHRSYWRpdXMgPj0gY2VudGVyU2VwYXJhdGlvbiArIGxlZnRSYWRpdXMpIHtcbiAgICAgIHJldHVybiBib3VuZGluZ1NwaGVyZS5jbG9uZSgpO1xuICAgIH1cblxuICAgIGNvbnN0IGhhbGZEaXN0YW5jZUJldHdlZW5UYW5nZW50UG9pbnRzID0gKGxlZnRSYWRpdXMgKyBjZW50ZXJTZXBhcmF0aW9uICsgcmlnaHRSYWRpdXMpICogMC41O1xuICAgIHNjcmF0Y2hWZWN0b3IyLmNvcHkodG9SaWdodENlbnRlcikuc2NhbGUoKC1sZWZ0UmFkaXVzICsgaGFsZkRpc3RhbmNlQmV0d2VlblRhbmdlbnRQb2ludHMpIC8gY2VudGVyU2VwYXJhdGlvbikuYWRkKGxlZnRDZW50ZXIpO1xuICAgIHRoaXMuY2VudGVyLmNvcHkoc2NyYXRjaFZlY3RvcjIpO1xuICAgIHRoaXMucmFkaXVzID0gaGFsZkRpc3RhbmNlQmV0d2VlblRhbmdlbnRQb2ludHM7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICBleHBhbmQocG9pbnQpIHtcbiAgICBjb25zdCBzY3JhdGNoUG9pbnQgPSBzY3JhdGNoVmVjdG9yLmZyb20ocG9pbnQpO1xuICAgIGNvbnN0IHJhZGl1cyA9IHNjcmF0Y2hQb2ludC5zdWJ0cmFjdCh0aGlzLmNlbnRlcikubWFnbml0dWRlKCk7XG5cbiAgICBpZiAocmFkaXVzID4gdGhpcy5yYWRpdXMpIHtcbiAgICAgIHRoaXMucmFkaXVzID0gcmFkaXVzO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgdHJhbnNmb3JtKHRyYW5zZm9ybSkge1xuICAgIHRoaXMuY2VudGVyLnRyYW5zZm9ybSh0cmFuc2Zvcm0pO1xuICAgIGNvbnN0IHNjYWxlID0gbWF0NC5nZXRTY2FsaW5nKHNjcmF0Y2hWZWN0b3IsIHRyYW5zZm9ybSk7XG4gICAgdGhpcy5yYWRpdXMgPSBNYXRoLm1heChzY2FsZVswXSwgTWF0aC5tYXgoc2NhbGVbMV0sIHNjYWxlWzJdKSkgKiB0aGlzLnJhZGl1cztcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIGRpc3RhbmNlU3F1YXJlZFRvKHBvaW50KSB7XG4gICAgY29uc3QgZCA9IHRoaXMuZGlzdGFuY2VUbyhwb2ludCk7XG4gICAgcmV0dXJuIGQgKiBkO1xuICB9XG5cbiAgZGlzdGFuY2VUbyhwb2ludCkge1xuICAgIGNvbnN0IHNjcmF0Y2hQb2ludCA9IHNjcmF0Y2hWZWN0b3IuZnJvbShwb2ludCk7XG4gICAgY29uc3QgZGVsdGEgPSBzY3JhdGNoUG9pbnQuc3VidHJhY3QodGhpcy5jZW50ZXIpO1xuICAgIHJldHVybiBNYXRoLm1heCgwLCBkZWx0YS5sZW4oKSAtIHRoaXMucmFkaXVzKTtcbiAgfVxuXG4gIGludGVyc2VjdFBsYW5lKHBsYW5lKSB7XG4gICAgY29uc3QgY2VudGVyID0gdGhpcy5jZW50ZXI7XG4gICAgY29uc3QgcmFkaXVzID0gdGhpcy5yYWRpdXM7XG4gICAgY29uc3Qgbm9ybWFsID0gcGxhbmUubm9ybWFsO1xuICAgIGNvbnN0IGRpc3RhbmNlVG9QbGFuZSA9IG5vcm1hbC5kb3QoY2VudGVyKSArIHBsYW5lLmRpc3RhbmNlO1xuXG4gICAgaWYgKGRpc3RhbmNlVG9QbGFuZSA8IC1yYWRpdXMpIHtcbiAgICAgIHJldHVybiBJTlRFUlNFQ1RJT04uT1VUU0lERTtcbiAgICB9XG5cbiAgICBpZiAoZGlzdGFuY2VUb1BsYW5lIDwgcmFkaXVzKSB7XG4gICAgICByZXR1cm4gSU5URVJTRUNUSU9OLklOVEVSU0VDVElORztcbiAgICB9XG5cbiAgICByZXR1cm4gSU5URVJTRUNUSU9OLklOU0lERTtcbiAgfVxuXG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1ib3VuZGluZy1zcGhlcmUuanMubWFwIiwiaW1wb3J0IF9kZWZpbmVQcm9wZXJ0eSBmcm9tIFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vZGVmaW5lUHJvcGVydHlcIjtcbmltcG9ydCB7IFZlY3RvcjMsIE1hdHJpeDMsIFF1YXRlcm5pb24gfSBmcm9tICdAbWF0aC5nbC9jb3JlJztcbmltcG9ydCBCb3VuZGluZ1NwaGVyZSBmcm9tICcuL2JvdW5kaW5nLXNwaGVyZSc7XG5pbXBvcnQgeyBJTlRFUlNFQ1RJT04gfSBmcm9tICcuLi8uLi9jb25zdGFudHMnO1xuY29uc3Qgc2NyYXRjaFZlY3RvcjMgPSBuZXcgVmVjdG9yMygpO1xuY29uc3Qgc2NyYXRjaE9mZnNldCA9IG5ldyBWZWN0b3IzKCk7XG5jb25zdCBzY3JhdGNoVmVjdG9yVSA9IG5ldyBWZWN0b3IzKCk7XG5jb25zdCBzY3JhdGNoVmVjdG9yViA9IG5ldyBWZWN0b3IzKCk7XG5jb25zdCBzY3JhdGNoVmVjdG9yVyA9IG5ldyBWZWN0b3IzKCk7XG5jb25zdCBzY3JhdGNoQ29ybmVyID0gbmV3IFZlY3RvcjMoKTtcbmNvbnN0IHNjcmF0Y2hUb0NlbnRlciA9IG5ldyBWZWN0b3IzKCk7XG5jb25zdCBNQVRSSVgzID0ge1xuICBDT0xVTU4wUk9XMDogMCxcbiAgQ09MVU1OMFJPVzE6IDEsXG4gIENPTFVNTjBST1cyOiAyLFxuICBDT0xVTU4xUk9XMDogMyxcbiAgQ09MVU1OMVJPVzE6IDQsXG4gIENPTFVNTjFST1cyOiA1LFxuICBDT0xVTU4yUk9XMDogNixcbiAgQ09MVU1OMlJPVzE6IDcsXG4gIENPTFVNTjJST1cyOiA4XG59O1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgT3JpZW50ZWRCb3VuZGluZ0JveCB7XG4gIGNvbnN0cnVjdG9yKGNlbnRlciA9IFswLCAwLCAwXSwgaGFsZkF4ZXMgPSBbMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMF0pIHtcbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJjZW50ZXJcIiwgdm9pZCAwKTtcblxuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImhhbGZBeGVzXCIsIHZvaWQgMCk7XG5cbiAgICB0aGlzLmNlbnRlciA9IG5ldyBWZWN0b3IzKCkuZnJvbShjZW50ZXIpO1xuICAgIHRoaXMuaGFsZkF4ZXMgPSBuZXcgTWF0cml4MyhoYWxmQXhlcyk7XG4gIH1cblxuICBnZXQgaGFsZlNpemUoKSB7XG4gICAgY29uc3QgeEF4aXMgPSB0aGlzLmhhbGZBeGVzLmdldENvbHVtbigwKTtcbiAgICBjb25zdCB5QXhpcyA9IHRoaXMuaGFsZkF4ZXMuZ2V0Q29sdW1uKDEpO1xuICAgIGNvbnN0IHpBeGlzID0gdGhpcy5oYWxmQXhlcy5nZXRDb2x1bW4oMik7XG4gICAgcmV0dXJuIFtuZXcgVmVjdG9yMyh4QXhpcykubGVuKCksIG5ldyBWZWN0b3IzKHlBeGlzKS5sZW4oKSwgbmV3IFZlY3RvcjMoekF4aXMpLmxlbigpXTtcbiAgfVxuXG4gIGdldCBxdWF0ZXJuaW9uKCkge1xuICAgIGNvbnN0IHhBeGlzID0gdGhpcy5oYWxmQXhlcy5nZXRDb2x1bW4oMCk7XG4gICAgY29uc3QgeUF4aXMgPSB0aGlzLmhhbGZBeGVzLmdldENvbHVtbigxKTtcbiAgICBjb25zdCB6QXhpcyA9IHRoaXMuaGFsZkF4ZXMuZ2V0Q29sdW1uKDIpO1xuICAgIGNvbnN0IG5vcm1YQXhpcyA9IG5ldyBWZWN0b3IzKHhBeGlzKS5ub3JtYWxpemUoKTtcbiAgICBjb25zdCBub3JtWUF4aXMgPSBuZXcgVmVjdG9yMyh5QXhpcykubm9ybWFsaXplKCk7XG4gICAgY29uc3Qgbm9ybVpBeGlzID0gbmV3IFZlY3RvcjMoekF4aXMpLm5vcm1hbGl6ZSgpO1xuICAgIHJldHVybiBuZXcgUXVhdGVybmlvbigpLmZyb21NYXRyaXgzKG5ldyBNYXRyaXgzKFsuLi5ub3JtWEF4aXMsIC4uLm5vcm1ZQXhpcywgLi4ubm9ybVpBeGlzXSkpO1xuICB9XG5cbiAgZnJvbUNlbnRlckhhbGZTaXplUXVhdGVybmlvbihjZW50ZXIsIGhhbGZTaXplLCBxdWF0ZXJuaW9uKSB7XG4gICAgY29uc3QgcXVhdGVybmlvbk9iamVjdCA9IG5ldyBRdWF0ZXJuaW9uKHF1YXRlcm5pb24pO1xuICAgIGNvbnN0IGRpcmVjdGlvbnNNYXRyaXggPSBuZXcgTWF0cml4MygpLmZyb21RdWF0ZXJuaW9uKHF1YXRlcm5pb25PYmplY3QpO1xuICAgIGRpcmVjdGlvbnNNYXRyaXhbMF0gPSBkaXJlY3Rpb25zTWF0cml4WzBdICogaGFsZlNpemVbMF07XG4gICAgZGlyZWN0aW9uc01hdHJpeFsxXSA9IGRpcmVjdGlvbnNNYXRyaXhbMV0gKiBoYWxmU2l6ZVswXTtcbiAgICBkaXJlY3Rpb25zTWF0cml4WzJdID0gZGlyZWN0aW9uc01hdHJpeFsyXSAqIGhhbGZTaXplWzBdO1xuICAgIGRpcmVjdGlvbnNNYXRyaXhbM10gPSBkaXJlY3Rpb25zTWF0cml4WzNdICogaGFsZlNpemVbMV07XG4gICAgZGlyZWN0aW9uc01hdHJpeFs0XSA9IGRpcmVjdGlvbnNNYXRyaXhbNF0gKiBoYWxmU2l6ZVsxXTtcbiAgICBkaXJlY3Rpb25zTWF0cml4WzVdID0gZGlyZWN0aW9uc01hdHJpeFs1XSAqIGhhbGZTaXplWzFdO1xuICAgIGRpcmVjdGlvbnNNYXRyaXhbNl0gPSBkaXJlY3Rpb25zTWF0cml4WzZdICogaGFsZlNpemVbMl07XG4gICAgZGlyZWN0aW9uc01hdHJpeFs3XSA9IGRpcmVjdGlvbnNNYXRyaXhbN10gKiBoYWxmU2l6ZVsyXTtcbiAgICBkaXJlY3Rpb25zTWF0cml4WzhdID0gZGlyZWN0aW9uc01hdHJpeFs4XSAqIGhhbGZTaXplWzJdO1xuICAgIHRoaXMuY2VudGVyID0gbmV3IFZlY3RvcjMoKS5mcm9tKGNlbnRlcik7XG4gICAgdGhpcy5oYWxmQXhlcyA9IGRpcmVjdGlvbnNNYXRyaXg7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICBjbG9uZSgpIHtcbiAgICByZXR1cm4gbmV3IE9yaWVudGVkQm91bmRpbmdCb3godGhpcy5jZW50ZXIsIHRoaXMuaGFsZkF4ZXMpO1xuICB9XG5cbiAgZXF1YWxzKHJpZ2h0KSB7XG4gICAgcmV0dXJuIHRoaXMgPT09IHJpZ2h0IHx8IEJvb2xlYW4ocmlnaHQpICYmIHRoaXMuY2VudGVyLmVxdWFscyhyaWdodC5jZW50ZXIpICYmIHRoaXMuaGFsZkF4ZXMuZXF1YWxzKHJpZ2h0LmhhbGZBeGVzKTtcbiAgfVxuXG4gIGdldEJvdW5kaW5nU3BoZXJlKHJlc3VsdCA9IG5ldyBCb3VuZGluZ1NwaGVyZSgpKSB7XG4gICAgY29uc3QgaGFsZkF4ZXMgPSB0aGlzLmhhbGZBeGVzO1xuICAgIGNvbnN0IHUgPSBoYWxmQXhlcy5nZXRDb2x1bW4oMCwgc2NyYXRjaFZlY3RvclUpO1xuICAgIGNvbnN0IHYgPSBoYWxmQXhlcy5nZXRDb2x1bW4oMSwgc2NyYXRjaFZlY3RvclYpO1xuICAgIGNvbnN0IHcgPSBoYWxmQXhlcy5nZXRDb2x1bW4oMiwgc2NyYXRjaFZlY3RvclcpO1xuICAgIGNvbnN0IGNvcm5lclZlY3RvciA9IHNjcmF0Y2hWZWN0b3IzLmNvcHkodSkuYWRkKHYpLmFkZCh3KTtcbiAgICByZXN1bHQuY2VudGVyLmNvcHkodGhpcy5jZW50ZXIpO1xuICAgIHJlc3VsdC5yYWRpdXMgPSBjb3JuZXJWZWN0b3IubWFnbml0dWRlKCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIGludGVyc2VjdFBsYW5lKHBsYW5lKSB7XG4gICAgY29uc3QgY2VudGVyID0gdGhpcy5jZW50ZXI7XG4gICAgY29uc3Qgbm9ybWFsID0gcGxhbmUubm9ybWFsO1xuICAgIGNvbnN0IGhhbGZBeGVzID0gdGhpcy5oYWxmQXhlcztcbiAgICBjb25zdCBub3JtYWxYID0gbm9ybWFsLng7XG4gICAgY29uc3Qgbm9ybWFsWSA9IG5vcm1hbC55O1xuICAgIGNvbnN0IG5vcm1hbFogPSBub3JtYWwuejtcbiAgICBjb25zdCByYWRFZmZlY3RpdmUgPSBNYXRoLmFicyhub3JtYWxYICogaGFsZkF4ZXNbTUFUUklYMy5DT0xVTU4wUk9XMF0gKyBub3JtYWxZICogaGFsZkF4ZXNbTUFUUklYMy5DT0xVTU4wUk9XMV0gKyBub3JtYWxaICogaGFsZkF4ZXNbTUFUUklYMy5DT0xVTU4wUk9XMl0pICsgTWF0aC5hYnMobm9ybWFsWCAqIGhhbGZBeGVzW01BVFJJWDMuQ09MVU1OMVJPVzBdICsgbm9ybWFsWSAqIGhhbGZBeGVzW01BVFJJWDMuQ09MVU1OMVJPVzFdICsgbm9ybWFsWiAqIGhhbGZBeGVzW01BVFJJWDMuQ09MVU1OMVJPVzJdKSArIE1hdGguYWJzKG5vcm1hbFggKiBoYWxmQXhlc1tNQVRSSVgzLkNPTFVNTjJST1cwXSArIG5vcm1hbFkgKiBoYWxmQXhlc1tNQVRSSVgzLkNPTFVNTjJST1cxXSArIG5vcm1hbFogKiBoYWxmQXhlc1tNQVRSSVgzLkNPTFVNTjJST1cyXSk7XG4gICAgY29uc3QgZGlzdGFuY2VUb1BsYW5lID0gbm9ybWFsLmRvdChjZW50ZXIpICsgcGxhbmUuZGlzdGFuY2U7XG5cbiAgICBpZiAoZGlzdGFuY2VUb1BsYW5lIDw9IC1yYWRFZmZlY3RpdmUpIHtcbiAgICAgIHJldHVybiBJTlRFUlNFQ1RJT04uT1VUU0lERTtcbiAgICB9IGVsc2UgaWYgKGRpc3RhbmNlVG9QbGFuZSA+PSByYWRFZmZlY3RpdmUpIHtcbiAgICAgIHJldHVybiBJTlRFUlNFQ1RJT04uSU5TSURFO1xuICAgIH1cblxuICAgIHJldHVybiBJTlRFUlNFQ1RJT04uSU5URVJTRUNUSU5HO1xuICB9XG5cbiAgZGlzdGFuY2VUbyhwb2ludCkge1xuICAgIHJldHVybiBNYXRoLnNxcnQodGhpcy5kaXN0YW5jZVNxdWFyZWRUbyhwb2ludCkpO1xuICB9XG5cbiAgZGlzdGFuY2VTcXVhcmVkVG8ocG9pbnQpIHtcbiAgICBjb25zdCBvZmZzZXQgPSBzY3JhdGNoT2Zmc2V0LmZyb20ocG9pbnQpLnN1YnRyYWN0KHRoaXMuY2VudGVyKTtcbiAgICBjb25zdCBoYWxmQXhlcyA9IHRoaXMuaGFsZkF4ZXM7XG4gICAgY29uc3QgdSA9IGhhbGZBeGVzLmdldENvbHVtbigwLCBzY3JhdGNoVmVjdG9yVSk7XG4gICAgY29uc3QgdiA9IGhhbGZBeGVzLmdldENvbHVtbigxLCBzY3JhdGNoVmVjdG9yVik7XG4gICAgY29uc3QgdyA9IGhhbGZBeGVzLmdldENvbHVtbigyLCBzY3JhdGNoVmVjdG9yVyk7XG4gICAgY29uc3QgdUhhbGYgPSB1Lm1hZ25pdHVkZSgpO1xuICAgIGNvbnN0IHZIYWxmID0gdi5tYWduaXR1ZGUoKTtcbiAgICBjb25zdCB3SGFsZiA9IHcubWFnbml0dWRlKCk7XG4gICAgdS5ub3JtYWxpemUoKTtcbiAgICB2Lm5vcm1hbGl6ZSgpO1xuICAgIHcubm9ybWFsaXplKCk7XG4gICAgbGV0IGRpc3RhbmNlU3F1YXJlZCA9IDAuMDtcbiAgICBsZXQgZDtcbiAgICBkID0gTWF0aC5hYnMob2Zmc2V0LmRvdCh1KSkgLSB1SGFsZjtcblxuICAgIGlmIChkID4gMCkge1xuICAgICAgZGlzdGFuY2VTcXVhcmVkICs9IGQgKiBkO1xuICAgIH1cblxuICAgIGQgPSBNYXRoLmFicyhvZmZzZXQuZG90KHYpKSAtIHZIYWxmO1xuXG4gICAgaWYgKGQgPiAwKSB7XG4gICAgICBkaXN0YW5jZVNxdWFyZWQgKz0gZCAqIGQ7XG4gICAgfVxuXG4gICAgZCA9IE1hdGguYWJzKG9mZnNldC5kb3QodykpIC0gd0hhbGY7XG5cbiAgICBpZiAoZCA+IDApIHtcbiAgICAgIGRpc3RhbmNlU3F1YXJlZCArPSBkICogZDtcbiAgICB9XG5cbiAgICByZXR1cm4gZGlzdGFuY2VTcXVhcmVkO1xuICB9XG5cbiAgY29tcHV0ZVBsYW5lRGlzdGFuY2VzKHBvc2l0aW9uLCBkaXJlY3Rpb24sIHJlc3VsdCA9IFstMCwgLTBdKSB7XG4gICAgbGV0IG1pbkRpc3QgPSBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFk7XG4gICAgbGV0IG1heERpc3QgPSBOdW1iZXIuTkVHQVRJVkVfSU5GSU5JVFk7XG4gICAgY29uc3QgY2VudGVyID0gdGhpcy5jZW50ZXI7XG4gICAgY29uc3QgaGFsZkF4ZXMgPSB0aGlzLmhhbGZBeGVzO1xuICAgIGNvbnN0IHUgPSBoYWxmQXhlcy5nZXRDb2x1bW4oMCwgc2NyYXRjaFZlY3RvclUpO1xuICAgIGNvbnN0IHYgPSBoYWxmQXhlcy5nZXRDb2x1bW4oMSwgc2NyYXRjaFZlY3RvclYpO1xuICAgIGNvbnN0IHcgPSBoYWxmQXhlcy5nZXRDb2x1bW4oMiwgc2NyYXRjaFZlY3RvclcpO1xuICAgIGNvbnN0IGNvcm5lciA9IHNjcmF0Y2hDb3JuZXIuY29weSh1KS5hZGQodikuYWRkKHcpLmFkZChjZW50ZXIpO1xuICAgIGNvbnN0IHRvQ2VudGVyID0gc2NyYXRjaFRvQ2VudGVyLmNvcHkoY29ybmVyKS5zdWJ0cmFjdChwb3NpdGlvbik7XG4gICAgbGV0IG1hZyA9IGRpcmVjdGlvbi5kb3QodG9DZW50ZXIpO1xuICAgIG1pbkRpc3QgPSBNYXRoLm1pbihtYWcsIG1pbkRpc3QpO1xuICAgIG1heERpc3QgPSBNYXRoLm1heChtYWcsIG1heERpc3QpO1xuICAgIGNvcm5lci5jb3B5KGNlbnRlcikuYWRkKHUpLmFkZCh2KS5zdWJ0cmFjdCh3KTtcbiAgICB0b0NlbnRlci5jb3B5KGNvcm5lcikuc3VidHJhY3QocG9zaXRpb24pO1xuICAgIG1hZyA9IGRpcmVjdGlvbi5kb3QodG9DZW50ZXIpO1xuICAgIG1pbkRpc3QgPSBNYXRoLm1pbihtYWcsIG1pbkRpc3QpO1xuICAgIG1heERpc3QgPSBNYXRoLm1heChtYWcsIG1heERpc3QpO1xuICAgIGNvcm5lci5jb3B5KGNlbnRlcikuYWRkKHUpLnN1YnRyYWN0KHYpLmFkZCh3KTtcbiAgICB0b0NlbnRlci5jb3B5KGNvcm5lcikuc3VidHJhY3QocG9zaXRpb24pO1xuICAgIG1hZyA9IGRpcmVjdGlvbi5kb3QodG9DZW50ZXIpO1xuICAgIG1pbkRpc3QgPSBNYXRoLm1pbihtYWcsIG1pbkRpc3QpO1xuICAgIG1heERpc3QgPSBNYXRoLm1heChtYWcsIG1heERpc3QpO1xuICAgIGNvcm5lci5jb3B5KGNlbnRlcikuYWRkKHUpLnN1YnRyYWN0KHYpLnN1YnRyYWN0KHcpO1xuICAgIHRvQ2VudGVyLmNvcHkoY29ybmVyKS5zdWJ0cmFjdChwb3NpdGlvbik7XG4gICAgbWFnID0gZGlyZWN0aW9uLmRvdCh0b0NlbnRlcik7XG4gICAgbWluRGlzdCA9IE1hdGgubWluKG1hZywgbWluRGlzdCk7XG4gICAgbWF4RGlzdCA9IE1hdGgubWF4KG1hZywgbWF4RGlzdCk7XG4gICAgY2VudGVyLmNvcHkoY29ybmVyKS5zdWJ0cmFjdCh1KS5hZGQodikuYWRkKHcpO1xuICAgIHRvQ2VudGVyLmNvcHkoY29ybmVyKS5zdWJ0cmFjdChwb3NpdGlvbik7XG4gICAgbWFnID0gZGlyZWN0aW9uLmRvdCh0b0NlbnRlcik7XG4gICAgbWluRGlzdCA9IE1hdGgubWluKG1hZywgbWluRGlzdCk7XG4gICAgbWF4RGlzdCA9IE1hdGgubWF4KG1hZywgbWF4RGlzdCk7XG4gICAgY2VudGVyLmNvcHkoY29ybmVyKS5zdWJ0cmFjdCh1KS5hZGQodikuc3VidHJhY3Qodyk7XG4gICAgdG9DZW50ZXIuY29weShjb3JuZXIpLnN1YnRyYWN0KHBvc2l0aW9uKTtcbiAgICBtYWcgPSBkaXJlY3Rpb24uZG90KHRvQ2VudGVyKTtcbiAgICBtaW5EaXN0ID0gTWF0aC5taW4obWFnLCBtaW5EaXN0KTtcbiAgICBtYXhEaXN0ID0gTWF0aC5tYXgobWFnLCBtYXhEaXN0KTtcbiAgICBjZW50ZXIuY29weShjb3JuZXIpLnN1YnRyYWN0KHUpLnN1YnRyYWN0KHYpLmFkZCh3KTtcbiAgICB0b0NlbnRlci5jb3B5KGNvcm5lcikuc3VidHJhY3QocG9zaXRpb24pO1xuICAgIG1hZyA9IGRpcmVjdGlvbi5kb3QodG9DZW50ZXIpO1xuICAgIG1pbkRpc3QgPSBNYXRoLm1pbihtYWcsIG1pbkRpc3QpO1xuICAgIG1heERpc3QgPSBNYXRoLm1heChtYWcsIG1heERpc3QpO1xuICAgIGNlbnRlci5jb3B5KGNvcm5lcikuc3VidHJhY3QodSkuc3VidHJhY3Qodikuc3VidHJhY3Qodyk7XG4gICAgdG9DZW50ZXIuY29weShjb3JuZXIpLnN1YnRyYWN0KHBvc2l0aW9uKTtcbiAgICBtYWcgPSBkaXJlY3Rpb24uZG90KHRvQ2VudGVyKTtcbiAgICBtaW5EaXN0ID0gTWF0aC5taW4obWFnLCBtaW5EaXN0KTtcbiAgICBtYXhEaXN0ID0gTWF0aC5tYXgobWFnLCBtYXhEaXN0KTtcbiAgICByZXN1bHRbMF0gPSBtaW5EaXN0O1xuICAgIHJlc3VsdFsxXSA9IG1heERpc3Q7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIHRyYW5zZm9ybSh0cmFuc2Zvcm1hdGlvbikge1xuICAgIHRoaXMuY2VudGVyLnRyYW5zZm9ybUFzUG9pbnQodHJhbnNmb3JtYXRpb24pO1xuICAgIGNvbnN0IHhBeGlzID0gdGhpcy5oYWxmQXhlcy5nZXRDb2x1bW4oMCwgc2NyYXRjaFZlY3RvclUpO1xuICAgIHhBeGlzLnRyYW5zZm9ybUFzUG9pbnQodHJhbnNmb3JtYXRpb24pO1xuICAgIGNvbnN0IHlBeGlzID0gdGhpcy5oYWxmQXhlcy5nZXRDb2x1bW4oMSwgc2NyYXRjaFZlY3RvclYpO1xuICAgIHlBeGlzLnRyYW5zZm9ybUFzUG9pbnQodHJhbnNmb3JtYXRpb24pO1xuICAgIGNvbnN0IHpBeGlzID0gdGhpcy5oYWxmQXhlcy5nZXRDb2x1bW4oMiwgc2NyYXRjaFZlY3RvclcpO1xuICAgIHpBeGlzLnRyYW5zZm9ybUFzUG9pbnQodHJhbnNmb3JtYXRpb24pO1xuICAgIHRoaXMuaGFsZkF4ZXMgPSBuZXcgTWF0cml4MyhbLi4ueEF4aXMsIC4uLnlBeGlzLCAuLi56QXhpc10pO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgZ2V0VHJhbnNmb3JtKCkge1xuICAgIHRocm93IG5ldyBFcnJvcignbm90IGltcGxlbWVudGVkJyk7XG4gIH1cblxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9b3JpZW50ZWQtYm91bmRpbmctYm94LmpzLm1hcCIsImltcG9ydCBfZGVmaW5lUHJvcGVydHkgZnJvbSBcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL2RlZmluZVByb3BlcnR5XCI7XG5pbXBvcnQgeyBWZWN0b3IzLCBlcXVhbHMsIGFzc2VydCB9IGZyb20gJ0BtYXRoLmdsL2NvcmUnO1xuY29uc3Qgc2NyYXRjaFBvc2l0aW9uID0gbmV3IFZlY3RvcjMoKTtcbmNvbnN0IHNjcmF0Y2hOb3JtYWwgPSBuZXcgVmVjdG9yMygpO1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgUGxhbmUge1xuICBjb25zdHJ1Y3Rvcihub3JtYWwgPSBbMCwgMCwgMV0sIGRpc3RhbmNlID0gMCkge1xuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIm5vcm1hbFwiLCB2b2lkIDApO1xuXG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwiZGlzdGFuY2VcIiwgdm9pZCAwKTtcblxuICAgIHRoaXMubm9ybWFsID0gbmV3IFZlY3RvcjMoKTtcbiAgICB0aGlzLmRpc3RhbmNlID0gLTA7XG4gICAgdGhpcy5mcm9tTm9ybWFsRGlzdGFuY2Uobm9ybWFsLCBkaXN0YW5jZSk7XG4gIH1cblxuICBmcm9tTm9ybWFsRGlzdGFuY2Uobm9ybWFsLCBkaXN0YW5jZSkge1xuICAgIGFzc2VydChOdW1iZXIuaXNGaW5pdGUoZGlzdGFuY2UpKTtcbiAgICB0aGlzLm5vcm1hbC5mcm9tKG5vcm1hbCkubm9ybWFsaXplKCk7XG4gICAgdGhpcy5kaXN0YW5jZSA9IGRpc3RhbmNlO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgZnJvbVBvaW50Tm9ybWFsKHBvaW50LCBub3JtYWwpIHtcbiAgICBwb2ludCA9IHNjcmF0Y2hQb3NpdGlvbi5mcm9tKHBvaW50KTtcbiAgICB0aGlzLm5vcm1hbC5mcm9tKG5vcm1hbCkubm9ybWFsaXplKCk7XG4gICAgY29uc3QgZGlzdGFuY2UgPSAtdGhpcy5ub3JtYWwuZG90KHBvaW50KTtcbiAgICB0aGlzLmRpc3RhbmNlID0gZGlzdGFuY2U7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICBmcm9tQ29lZmZpY2llbnRzKGEsIGIsIGMsIGQpIHtcbiAgICB0aGlzLm5vcm1hbC5zZXQoYSwgYiwgYyk7XG4gICAgYXNzZXJ0KGVxdWFscyh0aGlzLm5vcm1hbC5sZW4oKSwgMSkpO1xuICAgIHRoaXMuZGlzdGFuY2UgPSBkO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgY2xvbmUoKSB7XG4gICAgcmV0dXJuIG5ldyBQbGFuZSh0aGlzLm5vcm1hbCwgdGhpcy5kaXN0YW5jZSk7XG4gIH1cblxuICBlcXVhbHMocmlnaHQpIHtcbiAgICByZXR1cm4gZXF1YWxzKHRoaXMuZGlzdGFuY2UsIHJpZ2h0LmRpc3RhbmNlKSAmJiBlcXVhbHModGhpcy5ub3JtYWwsIHJpZ2h0Lm5vcm1hbCk7XG4gIH1cblxuICBnZXRQb2ludERpc3RhbmNlKHBvaW50KSB7XG4gICAgcmV0dXJuIHRoaXMubm9ybWFsLmRvdChwb2ludCkgKyB0aGlzLmRpc3RhbmNlO1xuICB9XG5cbiAgdHJhbnNmb3JtKG1hdHJpeDQpIHtcbiAgICBjb25zdCBub3JtYWwgPSBzY3JhdGNoTm9ybWFsLmNvcHkodGhpcy5ub3JtYWwpLnRyYW5zZm9ybUFzVmVjdG9yKG1hdHJpeDQpLm5vcm1hbGl6ZSgpO1xuICAgIGNvbnN0IHBvaW50ID0gdGhpcy5ub3JtYWwuc2NhbGUoLXRoaXMuZGlzdGFuY2UpLnRyYW5zZm9ybShtYXRyaXg0KTtcbiAgICByZXR1cm4gdGhpcy5mcm9tUG9pbnROb3JtYWwocG9pbnQsIG5vcm1hbCk7XG4gIH1cblxuICBwcm9qZWN0UG9pbnRPbnRvUGxhbmUocG9pbnQsIHJlc3VsdCA9IFswLCAwLCAwXSkge1xuICAgIHBvaW50ID0gc2NyYXRjaFBvc2l0aW9uLmZyb20ocG9pbnQpO1xuICAgIGNvbnN0IHBvaW50RGlzdGFuY2UgPSB0aGlzLmdldFBvaW50RGlzdGFuY2UocG9pbnQpO1xuICAgIGNvbnN0IHNjYWxlZE5vcm1hbCA9IHNjcmF0Y2hOb3JtYWwuY29weSh0aGlzLm5vcm1hbCkuc2NhbGUocG9pbnREaXN0YW5jZSk7XG4gICAgcmV0dXJuIHBvaW50LnN1YnRyYWN0KHNjYWxlZE5vcm1hbCkudG8ocmVzdWx0KTtcbiAgfVxuXG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1wbGFuZS5qcy5tYXAiLCJpbXBvcnQgX2RlZmluZVByb3BlcnR5IGZyb20gXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9kZWZpbmVQcm9wZXJ0eVwiO1xuaW1wb3J0IHsgVmVjdG9yMywgYXNzZXJ0IH0gZnJvbSAnQG1hdGguZ2wvY29yZSc7XG5pbXBvcnQgeyBJTlRFUlNFQ1RJT04gfSBmcm9tICcuLi9jb25zdGFudHMnO1xuaW1wb3J0IFBsYW5lIGZyb20gJy4vcGxhbmUnO1xuY29uc3QgZmFjZXMgPSBbbmV3IFZlY3RvcjMoWzEsIDAsIDBdKSwgbmV3IFZlY3RvcjMoWzAsIDEsIDBdKSwgbmV3IFZlY3RvcjMoWzAsIDAsIDFdKV07XG5jb25zdCBzY3JhdGNoUGxhbmVDZW50ZXIgPSBuZXcgVmVjdG9yMygpO1xuY29uc3Qgc2NyYXRjaFBsYW5lTm9ybWFsID0gbmV3IFZlY3RvcjMoKTtcbmNvbnN0IHNjcmF0Y2hQbGFuZSA9IG5ldyBQbGFuZShuZXcgVmVjdG9yMygxLjAsIDAuMCwgMC4wKSwgMC4wKTtcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEN1bGxpbmdWb2x1bWUge1xuICBjb25zdHJ1Y3RvcihwbGFuZXMgPSBbXSkge1xuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInBsYW5lc1wiLCB2b2lkIDApO1xuXG4gICAgdGhpcy5wbGFuZXMgPSBwbGFuZXM7XG4gIH1cblxuICBmcm9tQm91bmRpbmdTcGhlcmUoYm91bmRpbmdTcGhlcmUpIHtcbiAgICB0aGlzLnBsYW5lcy5sZW5ndGggPSAyICogZmFjZXMubGVuZ3RoO1xuICAgIGNvbnN0IGNlbnRlciA9IGJvdW5kaW5nU3BoZXJlLmNlbnRlcjtcbiAgICBjb25zdCByYWRpdXMgPSBib3VuZGluZ1NwaGVyZS5yYWRpdXM7XG4gICAgbGV0IHBsYW5lSW5kZXggPSAwO1xuXG4gICAgZm9yIChjb25zdCBmYWNlTm9ybWFsIG9mIGZhY2VzKSB7XG4gICAgICBsZXQgcGxhbmUwID0gdGhpcy5wbGFuZXNbcGxhbmVJbmRleF07XG4gICAgICBsZXQgcGxhbmUxID0gdGhpcy5wbGFuZXNbcGxhbmVJbmRleCArIDFdO1xuXG4gICAgICBpZiAoIXBsYW5lMCkge1xuICAgICAgICBwbGFuZTAgPSB0aGlzLnBsYW5lc1twbGFuZUluZGV4XSA9IG5ldyBQbGFuZSgpO1xuICAgICAgfVxuXG4gICAgICBpZiAoIXBsYW5lMSkge1xuICAgICAgICBwbGFuZTEgPSB0aGlzLnBsYW5lc1twbGFuZUluZGV4ICsgMV0gPSBuZXcgUGxhbmUoKTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgcGxhbmUwQ2VudGVyID0gc2NyYXRjaFBsYW5lQ2VudGVyLmNvcHkoZmFjZU5vcm1hbCkuc2NhbGUoLXJhZGl1cykuYWRkKGNlbnRlcik7XG4gICAgICBjb25zdCBwbGFuZTBEaXN0YW5jZSA9IC1mYWNlTm9ybWFsLmRvdChwbGFuZTBDZW50ZXIpO1xuICAgICAgcGxhbmUwLmZyb21Qb2ludE5vcm1hbChwbGFuZTBDZW50ZXIsIGZhY2VOb3JtYWwpO1xuICAgICAgY29uc3QgcGxhbmUxQ2VudGVyID0gc2NyYXRjaFBsYW5lQ2VudGVyLmNvcHkoZmFjZU5vcm1hbCkuc2NhbGUocmFkaXVzKS5hZGQoY2VudGVyKTtcbiAgICAgIGNvbnN0IG5lZ2F0ZWRGYWNlTm9ybWFsID0gc2NyYXRjaFBsYW5lTm9ybWFsLmNvcHkoZmFjZU5vcm1hbCkubmVnYXRlKCk7XG4gICAgICBjb25zdCBwbGFuZTFEaXN0YW5jZSA9IC1uZWdhdGVkRmFjZU5vcm1hbC5kb3QocGxhbmUxQ2VudGVyKTtcbiAgICAgIHBsYW5lMS5mcm9tUG9pbnROb3JtYWwocGxhbmUxQ2VudGVyLCBuZWdhdGVkRmFjZU5vcm1hbCk7XG4gICAgICBwbGFuZUluZGV4ICs9IDI7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICBjb21wdXRlVmlzaWJpbGl0eShib3VuZGluZ1ZvbHVtZSkge1xuICAgIGxldCBpbnRlcnNlY3QgPSBJTlRFUlNFQ1RJT04uSU5TSURFO1xuXG4gICAgZm9yIChjb25zdCBwbGFuZSBvZiB0aGlzLnBsYW5lcykge1xuICAgICAgY29uc3QgcmVzdWx0ID0gYm91bmRpbmdWb2x1bWUuaW50ZXJzZWN0UGxhbmUocGxhbmUpO1xuXG4gICAgICBzd2l0Y2ggKHJlc3VsdCkge1xuICAgICAgICBjYXNlIElOVEVSU0VDVElPTi5PVVRTSURFOlxuICAgICAgICAgIHJldHVybiBJTlRFUlNFQ1RJT04uT1VUU0lERTtcblxuICAgICAgICBjYXNlIElOVEVSU0VDVElPTi5JTlRFUlNFQ1RJTkc6XG4gICAgICAgICAgaW50ZXJzZWN0ID0gSU5URVJTRUNUSU9OLklOVEVSU0VDVElORztcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBkZWZhdWx0OlxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBpbnRlcnNlY3Q7XG4gIH1cblxuICBjb21wdXRlVmlzaWJpbGl0eVdpdGhQbGFuZU1hc2soYm91bmRpbmdWb2x1bWUsIHBhcmVudFBsYW5lTWFzaykge1xuICAgIGFzc2VydChOdW1iZXIuaXNGaW5pdGUocGFyZW50UGxhbmVNYXNrKSwgJ3BhcmVudFBsYW5lTWFzayBpcyByZXF1aXJlZC4nKTtcblxuICAgIGlmIChwYXJlbnRQbGFuZU1hc2sgPT09IEN1bGxpbmdWb2x1bWUuTUFTS19PVVRTSURFIHx8IHBhcmVudFBsYW5lTWFzayA9PT0gQ3VsbGluZ1ZvbHVtZS5NQVNLX0lOU0lERSkge1xuICAgICAgcmV0dXJuIHBhcmVudFBsYW5lTWFzaztcbiAgICB9XG5cbiAgICBsZXQgbWFzayA9IEN1bGxpbmdWb2x1bWUuTUFTS19JTlNJREU7XG4gICAgY29uc3QgcGxhbmVzID0gdGhpcy5wbGFuZXM7XG5cbiAgICBmb3IgKGxldCBrID0gMDsgayA8IHRoaXMucGxhbmVzLmxlbmd0aDsgKytrKSB7XG4gICAgICBjb25zdCBmbGFnID0gayA8IDMxID8gMSA8PCBrIDogMDtcblxuICAgICAgaWYgKGsgPCAzMSAmJiAocGFyZW50UGxhbmVNYXNrICYgZmxhZykgPT09IDApIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHBsYW5lID0gcGxhbmVzW2tdO1xuICAgICAgY29uc3QgcmVzdWx0ID0gYm91bmRpbmdWb2x1bWUuaW50ZXJzZWN0UGxhbmUocGxhbmUpO1xuXG4gICAgICBpZiAocmVzdWx0ID09PSBJTlRFUlNFQ1RJT04uT1VUU0lERSkge1xuICAgICAgICByZXR1cm4gQ3VsbGluZ1ZvbHVtZS5NQVNLX09VVFNJREU7XG4gICAgICB9IGVsc2UgaWYgKHJlc3VsdCA9PT0gSU5URVJTRUNUSU9OLklOVEVSU0VDVElORykge1xuICAgICAgICBtYXNrIHw9IGZsYWc7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIG1hc2s7XG4gIH1cblxufVxuXG5fZGVmaW5lUHJvcGVydHkoQ3VsbGluZ1ZvbHVtZSwgXCJNQVNLX09VVFNJREVcIiwgMHhmZmZmZmZmZik7XG5cbl9kZWZpbmVQcm9wZXJ0eShDdWxsaW5nVm9sdW1lLCBcIk1BU0tfSU5TSURFXCIsIDB4MDAwMDAwMDApO1xuXG5fZGVmaW5lUHJvcGVydHkoQ3VsbGluZ1ZvbHVtZSwgXCJNQVNLX0lOREVURVJNSU5BVEVcIiwgMHg3ZmZmZmZmZik7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jdWxsaW5nLXZvbHVtZS5qcy5tYXAiLCJpbXBvcnQgX2RlZmluZVByb3BlcnR5IGZyb20gXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9kZWZpbmVQcm9wZXJ0eVwiO1xuaW1wb3J0IHsgVmVjdG9yMywgTWF0cml4NCwgYXNzZXJ0IH0gZnJvbSAnQG1hdGguZ2wvY29yZSc7XG5pbXBvcnQgQ3VsbGluZ1ZvbHVtZSBmcm9tICcuL2N1bGxpbmctdm9sdW1lJztcbmltcG9ydCBQbGFuZSBmcm9tICcuL3BsYW5lJztcbmNvbnN0IHNjcmF0Y2hQbGFuZVVwVmVjdG9yID0gbmV3IFZlY3RvcjMoKTtcbmNvbnN0IHNjcmF0Y2hQbGFuZVJpZ2h0VmVjdG9yID0gbmV3IFZlY3RvcjMoKTtcbmNvbnN0IHNjcmF0Y2hQbGFuZU5lYXJDZW50ZXIgPSBuZXcgVmVjdG9yMygpO1xuY29uc3Qgc2NyYXRjaFBsYW5lRmFyQ2VudGVyID0gbmV3IFZlY3RvcjMoKTtcbmNvbnN0IHNjcmF0Y2hQbGFuZU5vcm1hbCA9IG5ldyBWZWN0b3IzKCk7XG5leHBvcnQgZGVmYXVsdCBjbGFzcyBQZXJzcGVjdGl2ZU9mZkNlbnRlckZydXN0dW0ge1xuICBjb25zdHJ1Y3RvcihvcHRpb25zID0ge30pIHtcbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJsZWZ0XCIsIHZvaWQgMCk7XG5cbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJfbGVmdFwiLCB2b2lkIDApO1xuXG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwicmlnaHRcIiwgdm9pZCAwKTtcblxuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIl9yaWdodFwiLCB2b2lkIDApO1xuXG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwidG9wXCIsIHZvaWQgMCk7XG5cbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJfdG9wXCIsIHZvaWQgMCk7XG5cbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJib3R0b21cIiwgdm9pZCAwKTtcblxuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIl9ib3R0b21cIiwgdm9pZCAwKTtcblxuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIm5lYXJcIiwgdm9pZCAwKTtcblxuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIl9uZWFyXCIsIHZvaWQgMCk7XG5cbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJmYXJcIiwgdm9pZCAwKTtcblxuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIl9mYXJcIiwgdm9pZCAwKTtcblxuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIl9jdWxsaW5nVm9sdW1lXCIsIG5ldyBDdWxsaW5nVm9sdW1lKFtuZXcgUGxhbmUoKSwgbmV3IFBsYW5lKCksIG5ldyBQbGFuZSgpLCBuZXcgUGxhbmUoKSwgbmV3IFBsYW5lKCksIG5ldyBQbGFuZSgpXSkpO1xuXG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwiX3BlcnNwZWN0aXZlTWF0cml4XCIsIG5ldyBNYXRyaXg0KCkpO1xuXG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwiX2luZmluaXRlUGVyc3BlY3RpdmVcIiwgbmV3IE1hdHJpeDQoKSk7XG5cbiAgICBjb25zdCB7XG4gICAgICBuZWFyID0gMS4wLFxuICAgICAgZmFyID0gNTAwMDAwMDAwLjBcbiAgICB9ID0gb3B0aW9ucztcbiAgICB0aGlzLmxlZnQgPSBvcHRpb25zLmxlZnQ7XG4gICAgdGhpcy5fbGVmdCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLnJpZ2h0ID0gb3B0aW9ucy5yaWdodDtcbiAgICB0aGlzLl9yaWdodCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLnRvcCA9IG9wdGlvbnMudG9wO1xuICAgIHRoaXMuX3RvcCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLmJvdHRvbSA9IG9wdGlvbnMuYm90dG9tO1xuICAgIHRoaXMuX2JvdHRvbSA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLm5lYXIgPSBuZWFyO1xuICAgIHRoaXMuX25lYXIgPSBuZWFyO1xuICAgIHRoaXMuZmFyID0gZmFyO1xuICAgIHRoaXMuX2ZhciA9IGZhcjtcbiAgfVxuXG4gIGNsb25lKCkge1xuICAgIHJldHVybiBuZXcgUGVyc3BlY3RpdmVPZmZDZW50ZXJGcnVzdHVtKHtcbiAgICAgIHJpZ2h0OiB0aGlzLnJpZ2h0LFxuICAgICAgbGVmdDogdGhpcy5sZWZ0LFxuICAgICAgdG9wOiB0aGlzLnRvcCxcbiAgICAgIGJvdHRvbTogdGhpcy5ib3R0b20sXG4gICAgICBuZWFyOiB0aGlzLm5lYXIsXG4gICAgICBmYXI6IHRoaXMuZmFyXG4gICAgfSk7XG4gIH1cblxuICBlcXVhbHMob3RoZXIpIHtcbiAgICByZXR1cm4gb3RoZXIgJiYgb3RoZXIgaW5zdGFuY2VvZiBQZXJzcGVjdGl2ZU9mZkNlbnRlckZydXN0dW0gJiYgdGhpcy5yaWdodCA9PT0gb3RoZXIucmlnaHQgJiYgdGhpcy5sZWZ0ID09PSBvdGhlci5sZWZ0ICYmIHRoaXMudG9wID09PSBvdGhlci50b3AgJiYgdGhpcy5ib3R0b20gPT09IG90aGVyLmJvdHRvbSAmJiB0aGlzLm5lYXIgPT09IG90aGVyLm5lYXIgJiYgdGhpcy5mYXIgPT09IG90aGVyLmZhcjtcbiAgfVxuXG4gIGdldCBwcm9qZWN0aW9uTWF0cml4KCkge1xuICAgIHRoaXMuX3VwZGF0ZSgpO1xuXG4gICAgcmV0dXJuIHRoaXMuX3BlcnNwZWN0aXZlTWF0cml4O1xuICB9XG5cbiAgZ2V0IGluZmluaXRlUHJvamVjdGlvbk1hdHJpeCgpIHtcbiAgICB0aGlzLl91cGRhdGUoKTtcblxuICAgIHJldHVybiB0aGlzLl9pbmZpbml0ZVBlcnNwZWN0aXZlO1xuICB9XG5cbiAgY29tcHV0ZUN1bGxpbmdWb2x1bWUocG9zaXRpb24sIGRpcmVjdGlvbiwgdXApIHtcbiAgICBhc3NlcnQocG9zaXRpb24sICdwb3NpdGlvbiBpcyByZXF1aXJlZC4nKTtcbiAgICBhc3NlcnQoZGlyZWN0aW9uLCAnZGlyZWN0aW9uIGlzIHJlcXVpcmVkLicpO1xuICAgIGFzc2VydCh1cCwgJ3VwIGlzIHJlcXVpcmVkLicpO1xuICAgIGNvbnN0IHBsYW5lcyA9IHRoaXMuX2N1bGxpbmdWb2x1bWUucGxhbmVzO1xuICAgIHVwID0gc2NyYXRjaFBsYW5lVXBWZWN0b3IuY29weSh1cCkubm9ybWFsaXplKCk7XG4gICAgY29uc3QgcmlnaHQgPSBzY3JhdGNoUGxhbmVSaWdodFZlY3Rvci5jb3B5KGRpcmVjdGlvbikuY3Jvc3ModXApLm5vcm1hbGl6ZSgpO1xuICAgIGNvbnN0IG5lYXJDZW50ZXIgPSBzY3JhdGNoUGxhbmVOZWFyQ2VudGVyLmNvcHkoZGlyZWN0aW9uKS5tdWx0aXBseUJ5U2NhbGFyKHRoaXMubmVhcikuYWRkKHBvc2l0aW9uKTtcbiAgICBjb25zdCBmYXJDZW50ZXIgPSBzY3JhdGNoUGxhbmVGYXJDZW50ZXIuY29weShkaXJlY3Rpb24pLm11bHRpcGx5QnlTY2FsYXIodGhpcy5mYXIpLmFkZChwb3NpdGlvbik7XG4gICAgbGV0IG5vcm1hbCA9IHNjcmF0Y2hQbGFuZU5vcm1hbDtcbiAgICBub3JtYWwuY29weShyaWdodCkubXVsdGlwbHlCeVNjYWxhcih0aGlzLmxlZnQpLmFkZChuZWFyQ2VudGVyKS5zdWJ0cmFjdChwb3NpdGlvbikuY3Jvc3ModXApO1xuICAgIHBsYW5lc1swXS5mcm9tUG9pbnROb3JtYWwocG9zaXRpb24sIG5vcm1hbCk7XG4gICAgbm9ybWFsLmNvcHkocmlnaHQpLm11bHRpcGx5QnlTY2FsYXIodGhpcy5yaWdodCkuYWRkKG5lYXJDZW50ZXIpLnN1YnRyYWN0KHBvc2l0aW9uKS5jcm9zcyh1cCkubmVnYXRlKCk7XG4gICAgcGxhbmVzWzFdLmZyb21Qb2ludE5vcm1hbChwb3NpdGlvbiwgbm9ybWFsKTtcbiAgICBub3JtYWwuY29weSh1cCkubXVsdGlwbHlCeVNjYWxhcih0aGlzLmJvdHRvbSkuYWRkKG5lYXJDZW50ZXIpLnN1YnRyYWN0KHBvc2l0aW9uKS5jcm9zcyhyaWdodCkubmVnYXRlKCk7XG4gICAgcGxhbmVzWzJdLmZyb21Qb2ludE5vcm1hbChwb3NpdGlvbiwgbm9ybWFsKTtcbiAgICBub3JtYWwuY29weSh1cCkubXVsdGlwbHlCeVNjYWxhcih0aGlzLnRvcCkuYWRkKG5lYXJDZW50ZXIpLnN1YnRyYWN0KHBvc2l0aW9uKS5jcm9zcyhyaWdodCk7XG4gICAgcGxhbmVzWzNdLmZyb21Qb2ludE5vcm1hbChwb3NpdGlvbiwgbm9ybWFsKTtcbiAgICBub3JtYWwgPSBuZXcgVmVjdG9yMygpLmNvcHkoZGlyZWN0aW9uKTtcbiAgICBwbGFuZXNbNF0uZnJvbVBvaW50Tm9ybWFsKG5lYXJDZW50ZXIsIG5vcm1hbCk7XG4gICAgbm9ybWFsLm5lZ2F0ZSgpO1xuICAgIHBsYW5lc1s1XS5mcm9tUG9pbnROb3JtYWwoZmFyQ2VudGVyLCBub3JtYWwpO1xuICAgIHJldHVybiB0aGlzLl9jdWxsaW5nVm9sdW1lO1xuICB9XG5cbiAgZ2V0UGl4ZWxEaW1lbnNpb25zKGRyYXdpbmdCdWZmZXJXaWR0aCwgZHJhd2luZ0J1ZmZlckhlaWdodCwgZGlzdGFuY2UsIHJlc3VsdCkge1xuICAgIHRoaXMuX3VwZGF0ZSgpO1xuXG4gICAgYXNzZXJ0KE51bWJlci5pc0Zpbml0ZShkcmF3aW5nQnVmZmVyV2lkdGgpICYmIE51bWJlci5pc0Zpbml0ZShkcmF3aW5nQnVmZmVySGVpZ2h0KSk7XG4gICAgYXNzZXJ0KGRyYXdpbmdCdWZmZXJXaWR0aCA+IDApO1xuICAgIGFzc2VydChkcmF3aW5nQnVmZmVySGVpZ2h0ID4gMCk7XG4gICAgYXNzZXJ0KGRpc3RhbmNlID4gMCk7XG4gICAgYXNzZXJ0KHJlc3VsdCk7XG4gICAgY29uc3QgaW52ZXJzZU5lYXIgPSAxLjAgLyB0aGlzLm5lYXI7XG4gICAgbGV0IHRhblRoZXRhID0gdGhpcy50b3AgKiBpbnZlcnNlTmVhcjtcbiAgICBjb25zdCBwaXhlbEhlaWdodCA9IDIuMCAqIGRpc3RhbmNlICogdGFuVGhldGEgLyBkcmF3aW5nQnVmZmVySGVpZ2h0O1xuICAgIHRhblRoZXRhID0gdGhpcy5yaWdodCAqIGludmVyc2VOZWFyO1xuICAgIGNvbnN0IHBpeGVsV2lkdGggPSAyLjAgKiBkaXN0YW5jZSAqIHRhblRoZXRhIC8gZHJhd2luZ0J1ZmZlcldpZHRoO1xuICAgIHJlc3VsdC54ID0gcGl4ZWxXaWR0aDtcbiAgICByZXN1bHQueSA9IHBpeGVsSGVpZ2h0O1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICBfdXBkYXRlKCkge1xuICAgIGFzc2VydChOdW1iZXIuaXNGaW5pdGUodGhpcy5yaWdodCkgJiYgTnVtYmVyLmlzRmluaXRlKHRoaXMubGVmdCkgJiYgTnVtYmVyLmlzRmluaXRlKHRoaXMudG9wKSAmJiBOdW1iZXIuaXNGaW5pdGUodGhpcy5ib3R0b20pICYmIE51bWJlci5pc0Zpbml0ZSh0aGlzLm5lYXIpICYmIE51bWJlci5pc0Zpbml0ZSh0aGlzLmZhcikpO1xuICAgIGNvbnN0IHtcbiAgICAgIHRvcCxcbiAgICAgIGJvdHRvbSxcbiAgICAgIHJpZ2h0LFxuICAgICAgbGVmdCxcbiAgICAgIG5lYXIsXG4gICAgICBmYXJcbiAgICB9ID0gdGhpcztcblxuICAgIGlmICh0b3AgIT09IHRoaXMuX3RvcCB8fCBib3R0b20gIT09IHRoaXMuX2JvdHRvbSB8fCBsZWZ0ICE9PSB0aGlzLl9sZWZ0IHx8IHJpZ2h0ICE9PSB0aGlzLl9yaWdodCB8fCBuZWFyICE9PSB0aGlzLl9uZWFyIHx8IGZhciAhPT0gdGhpcy5fZmFyKSB7XG4gICAgICBhc3NlcnQodGhpcy5uZWFyID4gMCAmJiB0aGlzLm5lYXIgPCB0aGlzLmZhciwgJ25lYXIgbXVzdCBiZSBncmVhdGVyIHRoYW4gemVybyBhbmQgbGVzcyB0aGFuIGZhci4nKTtcbiAgICAgIHRoaXMuX2xlZnQgPSBsZWZ0O1xuICAgICAgdGhpcy5fcmlnaHQgPSByaWdodDtcbiAgICAgIHRoaXMuX3RvcCA9IHRvcDtcbiAgICAgIHRoaXMuX2JvdHRvbSA9IGJvdHRvbTtcbiAgICAgIHRoaXMuX25lYXIgPSBuZWFyO1xuICAgICAgdGhpcy5fZmFyID0gZmFyO1xuICAgICAgdGhpcy5fcGVyc3BlY3RpdmVNYXRyaXggPSBuZXcgTWF0cml4NCgpLmZydXN0dW0oe1xuICAgICAgICBsZWZ0LFxuICAgICAgICByaWdodCxcbiAgICAgICAgYm90dG9tLFxuICAgICAgICB0b3AsXG4gICAgICAgIG5lYXIsXG4gICAgICAgIGZhclxuICAgICAgfSk7XG4gICAgICB0aGlzLl9pbmZpbml0ZVBlcnNwZWN0aXZlID0gbmV3IE1hdHJpeDQoKS5mcnVzdHVtKHtcbiAgICAgICAgbGVmdCxcbiAgICAgICAgcmlnaHQsXG4gICAgICAgIGJvdHRvbSxcbiAgICAgICAgdG9wLFxuICAgICAgICBuZWFyLFxuICAgICAgICBmYXI6IEluZmluaXR5XG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cGVyc3BlY3RpdmUtb2ZmLWNlbnRlci1mcnVzdHVtLmpzLm1hcCIsImltcG9ydCBfZGVmaW5lUHJvcGVydHkgZnJvbSBcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL2RlZmluZVByb3BlcnR5XCI7XG5pbXBvcnQgeyBhc3NlcnQsIFZlY3RvcjIgfSBmcm9tICdAbWF0aC5nbC9jb3JlJztcbmltcG9ydCBQZXJzcGVjdGl2ZU9mZkNlbnRlckZydXN0dW0gZnJvbSAnLi9wZXJzcGVjdGl2ZS1vZmYtY2VudGVyLWZydXN0dW0nO1xuXG5jb25zdCBkZWZpbmVkID0gdmFsID0+IHZhbCAhPT0gbnVsbCAmJiB0eXBlb2YgdmFsICE9PSAndW5kZWZpbmVkJztcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgUGVyc3BlY3RpdmVGcnVzdHVtIHtcbiAgY29uc3RydWN0b3Iob3B0aW9ucyA9IHt9KSB7XG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwiX29mZkNlbnRlckZydXN0dW1cIiwgbmV3IFBlcnNwZWN0aXZlT2ZmQ2VudGVyRnJ1c3R1bSgpKTtcblxuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImZvdlwiLCB2b2lkIDApO1xuXG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwiX2ZvdlwiLCB2b2lkIDApO1xuXG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwiX2ZvdnlcIiwgdm9pZCAwKTtcblxuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIl9zc2VEZW5vbWluYXRvclwiLCB2b2lkIDApO1xuXG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwiYXNwZWN0UmF0aW9cIiwgdm9pZCAwKTtcblxuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIl9hc3BlY3RSYXRpb1wiLCB2b2lkIDApO1xuXG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwibmVhclwiLCB2b2lkIDApO1xuXG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwiX25lYXJcIiwgdm9pZCAwKTtcblxuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImZhclwiLCB2b2lkIDApO1xuXG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwiX2ZhclwiLCB2b2lkIDApO1xuXG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwieE9mZnNldFwiLCB2b2lkIDApO1xuXG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwiX3hPZmZzZXRcIiwgdm9pZCAwKTtcblxuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInlPZmZzZXRcIiwgdm9pZCAwKTtcblxuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIl95T2Zmc2V0XCIsIHZvaWQgMCk7XG5cbiAgICBjb25zdCB7XG4gICAgICBmb3YsXG4gICAgICBhc3BlY3RSYXRpbyxcbiAgICAgIG5lYXIgPSAxLjAsXG4gICAgICBmYXIgPSA1MDAwMDAwMDAuMCxcbiAgICAgIHhPZmZzZXQgPSAwLjAsXG4gICAgICB5T2Zmc2V0ID0gMC4wXG4gICAgfSA9IG9wdGlvbnM7XG4gICAgdGhpcy5mb3YgPSBmb3Y7XG4gICAgdGhpcy5hc3BlY3RSYXRpbyA9IGFzcGVjdFJhdGlvO1xuICAgIHRoaXMubmVhciA9IG5lYXI7XG4gICAgdGhpcy5mYXIgPSBmYXI7XG4gICAgdGhpcy54T2Zmc2V0ID0geE9mZnNldDtcbiAgICB0aGlzLnlPZmZzZXQgPSB5T2Zmc2V0O1xuICB9XG5cbiAgY2xvbmUoKSB7XG4gICAgcmV0dXJuIG5ldyBQZXJzcGVjdGl2ZUZydXN0dW0oe1xuICAgICAgYXNwZWN0UmF0aW86IHRoaXMuYXNwZWN0UmF0aW8sXG4gICAgICBmb3Y6IHRoaXMuZm92LFxuICAgICAgbmVhcjogdGhpcy5uZWFyLFxuICAgICAgZmFyOiB0aGlzLmZhclxuICAgIH0pO1xuICB9XG5cbiAgZXF1YWxzKG90aGVyKSB7XG4gICAgaWYgKCFkZWZpbmVkKG90aGVyKSB8fCAhKG90aGVyIGluc3RhbmNlb2YgUGVyc3BlY3RpdmVGcnVzdHVtKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHRoaXMuX3VwZGF0ZSgpO1xuXG4gICAgb3RoZXIuX3VwZGF0ZSgpO1xuXG4gICAgcmV0dXJuIHRoaXMuZm92ID09PSBvdGhlci5mb3YgJiYgdGhpcy5hc3BlY3RSYXRpbyA9PT0gb3RoZXIuYXNwZWN0UmF0aW8gJiYgdGhpcy5uZWFyID09PSBvdGhlci5uZWFyICYmIHRoaXMuZmFyID09PSBvdGhlci5mYXIgJiYgdGhpcy5fb2ZmQ2VudGVyRnJ1c3R1bS5lcXVhbHMob3RoZXIuX29mZkNlbnRlckZydXN0dW0pO1xuICB9XG5cbiAgZ2V0IHByb2plY3Rpb25NYXRyaXgoKSB7XG4gICAgdGhpcy5fdXBkYXRlKCk7XG5cbiAgICByZXR1cm4gdGhpcy5fb2ZmQ2VudGVyRnJ1c3R1bS5wcm9qZWN0aW9uTWF0cml4O1xuICB9XG5cbiAgZ2V0IGluZmluaXRlUHJvamVjdGlvbk1hdHJpeCgpIHtcbiAgICB0aGlzLl91cGRhdGUoKTtcblxuICAgIHJldHVybiB0aGlzLl9vZmZDZW50ZXJGcnVzdHVtLmluZmluaXRlUHJvamVjdGlvbk1hdHJpeDtcbiAgfVxuXG4gIGdldCBmb3Z5KCkge1xuICAgIHRoaXMuX3VwZGF0ZSgpO1xuXG4gICAgcmV0dXJuIHRoaXMuX2Zvdnk7XG4gIH1cblxuICBnZXQgc3NlRGVub21pbmF0b3IoKSB7XG4gICAgdGhpcy5fdXBkYXRlKCk7XG5cbiAgICByZXR1cm4gdGhpcy5fc3NlRGVub21pbmF0b3I7XG4gIH1cblxuICBjb21wdXRlQ3VsbGluZ1ZvbHVtZShwb3NpdGlvbiwgZGlyZWN0aW9uLCB1cCkge1xuICAgIHRoaXMuX3VwZGF0ZSgpO1xuXG4gICAgcmV0dXJuIHRoaXMuX29mZkNlbnRlckZydXN0dW0uY29tcHV0ZUN1bGxpbmdWb2x1bWUocG9zaXRpb24sIGRpcmVjdGlvbiwgdXApO1xuICB9XG5cbiAgZ2V0UGl4ZWxEaW1lbnNpb25zKGRyYXdpbmdCdWZmZXJXaWR0aCwgZHJhd2luZ0J1ZmZlckhlaWdodCwgZGlzdGFuY2UsIHJlc3VsdCkge1xuICAgIHRoaXMuX3VwZGF0ZSgpO1xuXG4gICAgcmV0dXJuIHRoaXMuX29mZkNlbnRlckZydXN0dW0uZ2V0UGl4ZWxEaW1lbnNpb25zKGRyYXdpbmdCdWZmZXJXaWR0aCwgZHJhd2luZ0J1ZmZlckhlaWdodCwgZGlzdGFuY2UsIHJlc3VsdCB8fCBuZXcgVmVjdG9yMigpKTtcbiAgfVxuXG4gIF91cGRhdGUoKSB7XG4gICAgYXNzZXJ0KE51bWJlci5pc0Zpbml0ZSh0aGlzLmZvdikgJiYgTnVtYmVyLmlzRmluaXRlKHRoaXMuYXNwZWN0UmF0aW8pICYmIE51bWJlci5pc0Zpbml0ZSh0aGlzLm5lYXIpICYmIE51bWJlci5pc0Zpbml0ZSh0aGlzLmZhcikpO1xuICAgIGNvbnN0IGYgPSB0aGlzLl9vZmZDZW50ZXJGcnVzdHVtO1xuXG4gICAgaWYgKHRoaXMuZm92ICE9PSB0aGlzLl9mb3YgfHwgdGhpcy5hc3BlY3RSYXRpbyAhPT0gdGhpcy5fYXNwZWN0UmF0aW8gfHwgdGhpcy5uZWFyICE9PSB0aGlzLl9uZWFyIHx8IHRoaXMuZmFyICE9PSB0aGlzLl9mYXIgfHwgdGhpcy54T2Zmc2V0ICE9PSB0aGlzLl94T2Zmc2V0IHx8IHRoaXMueU9mZnNldCAhPT0gdGhpcy5feU9mZnNldCkge1xuICAgICAgYXNzZXJ0KHRoaXMuZm92ID49IDAgJiYgdGhpcy5mb3YgPCBNYXRoLlBJKTtcbiAgICAgIGFzc2VydCh0aGlzLmFzcGVjdFJhdGlvID4gMCk7XG4gICAgICBhc3NlcnQodGhpcy5uZWFyID49IDAgJiYgdGhpcy5uZWFyIDwgdGhpcy5mYXIpO1xuICAgICAgdGhpcy5fYXNwZWN0UmF0aW8gPSB0aGlzLmFzcGVjdFJhdGlvO1xuICAgICAgdGhpcy5fZm92ID0gdGhpcy5mb3Y7XG4gICAgICB0aGlzLl9mb3Z5ID0gdGhpcy5hc3BlY3RSYXRpbyA8PSAxID8gdGhpcy5mb3YgOiBNYXRoLmF0YW4oTWF0aC50YW4odGhpcy5mb3YgKiAwLjUpIC8gdGhpcy5hc3BlY3RSYXRpbykgKiAyLjA7XG4gICAgICB0aGlzLl9uZWFyID0gdGhpcy5uZWFyO1xuICAgICAgdGhpcy5fZmFyID0gdGhpcy5mYXI7XG4gICAgICB0aGlzLl9zc2VEZW5vbWluYXRvciA9IDIuMCAqIE1hdGgudGFuKDAuNSAqIHRoaXMuX2ZvdnkpO1xuICAgICAgdGhpcy5feE9mZnNldCA9IHRoaXMueE9mZnNldDtcbiAgICAgIHRoaXMuX3lPZmZzZXQgPSB0aGlzLnlPZmZzZXQ7XG4gICAgICBmLnRvcCA9IHRoaXMubmVhciAqIE1hdGgudGFuKDAuNSAqIHRoaXMuX2ZvdnkpO1xuICAgICAgZi5ib3R0b20gPSAtZi50b3A7XG4gICAgICBmLnJpZ2h0ID0gdGhpcy5hc3BlY3RSYXRpbyAqIGYudG9wO1xuICAgICAgZi5sZWZ0ID0gLWYucmlnaHQ7XG4gICAgICBmLm5lYXIgPSB0aGlzLm5lYXI7XG4gICAgICBmLmZhciA9IHRoaXMuZmFyO1xuICAgICAgZi5yaWdodCArPSB0aGlzLnhPZmZzZXQ7XG4gICAgICBmLmxlZnQgKz0gdGhpcy54T2Zmc2V0O1xuICAgICAgZi50b3AgKz0gdGhpcy55T2Zmc2V0O1xuICAgICAgZi5ib3R0b20gKz0gdGhpcy55T2Zmc2V0O1xuICAgIH1cbiAgfVxuXG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1wZXJzcGVjdGl2ZS1mcnVzdHVtLmpzLm1hcCIsImltcG9ydCB7IFZlY3RvcjMgfSBmcm9tICdAbWF0aC5nbC9jb3JlJztcbmltcG9ydCBCb3VuZGluZ1NwaGVyZSBmcm9tICcuLi9ib3VuZGluZy12b2x1bWVzL2JvdW5kaW5nLXNwaGVyZSc7XG5jb25zdCBmcm9tUG9pbnRzWE1pbiA9IG5ldyBWZWN0b3IzKCk7XG5jb25zdCBmcm9tUG9pbnRzWU1pbiA9IG5ldyBWZWN0b3IzKCk7XG5jb25zdCBmcm9tUG9pbnRzWk1pbiA9IG5ldyBWZWN0b3IzKCk7XG5jb25zdCBmcm9tUG9pbnRzWE1heCA9IG5ldyBWZWN0b3IzKCk7XG5jb25zdCBmcm9tUG9pbnRzWU1heCA9IG5ldyBWZWN0b3IzKCk7XG5jb25zdCBmcm9tUG9pbnRzWk1heCA9IG5ldyBWZWN0b3IzKCk7XG5jb25zdCBmcm9tUG9pbnRzQ3VycmVudFBvcyA9IG5ldyBWZWN0b3IzKCk7XG5jb25zdCBmcm9tUG9pbnRzU2NyYXRjaCA9IG5ldyBWZWN0b3IzKCk7XG5jb25zdCBmcm9tUG9pbnRzUml0dGVyQ2VudGVyID0gbmV3IFZlY3RvcjMoKTtcbmNvbnN0IGZyb21Qb2ludHNNaW5Cb3hQdCA9IG5ldyBWZWN0b3IzKCk7XG5jb25zdCBmcm9tUG9pbnRzTWF4Qm94UHQgPSBuZXcgVmVjdG9yMygpO1xuY29uc3QgZnJvbVBvaW50c05haXZlQ2VudGVyU2NyYXRjaCA9IG5ldyBWZWN0b3IzKCk7XG5jb25zdCB2b2x1bWVDb25zdGFudCA9IDQuMCAvIDMuMCAqIE1hdGguUEk7XG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBtYWtlQm91bmRpbmdTcGhlcmVGcm9tUG9pbnRzKHBvc2l0aW9ucywgcmVzdWx0ID0gbmV3IEJvdW5kaW5nU3BoZXJlKCkpIHtcbiAgaWYgKCFwb3NpdGlvbnMgfHwgcG9zaXRpb25zLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiByZXN1bHQuZnJvbUNlbnRlclJhZGl1cyhbMCwgMCwgMF0sIDApO1xuICB9XG5cbiAgY29uc3QgY3VycmVudFBvcyA9IGZyb21Qb2ludHNDdXJyZW50UG9zLmNvcHkocG9zaXRpb25zWzBdKTtcbiAgY29uc3QgeE1pbiA9IGZyb21Qb2ludHNYTWluLmNvcHkoY3VycmVudFBvcyk7XG4gIGNvbnN0IHlNaW4gPSBmcm9tUG9pbnRzWU1pbi5jb3B5KGN1cnJlbnRQb3MpO1xuICBjb25zdCB6TWluID0gZnJvbVBvaW50c1pNaW4uY29weShjdXJyZW50UG9zKTtcbiAgY29uc3QgeE1heCA9IGZyb21Qb2ludHNYTWF4LmNvcHkoY3VycmVudFBvcyk7XG4gIGNvbnN0IHlNYXggPSBmcm9tUG9pbnRzWU1heC5jb3B5KGN1cnJlbnRQb3MpO1xuICBjb25zdCB6TWF4ID0gZnJvbVBvaW50c1pNYXguY29weShjdXJyZW50UG9zKTtcblxuICBmb3IgKGNvbnN0IHBvc2l0aW9uIG9mIHBvc2l0aW9ucykge1xuICAgIGN1cnJlbnRQb3MuY29weShwb3NpdGlvbik7XG4gICAgY29uc3QgeCA9IGN1cnJlbnRQb3MueDtcbiAgICBjb25zdCB5ID0gY3VycmVudFBvcy55O1xuICAgIGNvbnN0IHogPSBjdXJyZW50UG9zLno7XG5cbiAgICBpZiAoeCA8IHhNaW4ueCkge1xuICAgICAgeE1pbi5jb3B5KGN1cnJlbnRQb3MpO1xuICAgIH1cblxuICAgIGlmICh4ID4geE1heC54KSB7XG4gICAgICB4TWF4LmNvcHkoY3VycmVudFBvcyk7XG4gICAgfVxuXG4gICAgaWYgKHkgPCB5TWluLnkpIHtcbiAgICAgIHlNaW4uY29weShjdXJyZW50UG9zKTtcbiAgICB9XG5cbiAgICBpZiAoeSA+IHlNYXgueSkge1xuICAgICAgeU1heC5jb3B5KGN1cnJlbnRQb3MpO1xuICAgIH1cblxuICAgIGlmICh6IDwgek1pbi56KSB7XG4gICAgICB6TWluLmNvcHkoY3VycmVudFBvcyk7XG4gICAgfVxuXG4gICAgaWYgKHogPiB6TWF4LnopIHtcbiAgICAgIHpNYXguY29weShjdXJyZW50UG9zKTtcbiAgICB9XG4gIH1cblxuICBjb25zdCB4U3BhbiA9IGZyb21Qb2ludHNTY3JhdGNoLmNvcHkoeE1heCkuc3VidHJhY3QoeE1pbikubWFnbml0dWRlU3F1YXJlZCgpO1xuICBjb25zdCB5U3BhbiA9IGZyb21Qb2ludHNTY3JhdGNoLmNvcHkoeU1heCkuc3VidHJhY3QoeU1pbikubWFnbml0dWRlU3F1YXJlZCgpO1xuICBjb25zdCB6U3BhbiA9IGZyb21Qb2ludHNTY3JhdGNoLmNvcHkoek1heCkuc3VidHJhY3Qoek1pbikubWFnbml0dWRlU3F1YXJlZCgpO1xuICBsZXQgZGlhbWV0ZXIxID0geE1pbjtcbiAgbGV0IGRpYW1ldGVyMiA9IHhNYXg7XG4gIGxldCBtYXhTcGFuID0geFNwYW47XG5cbiAgaWYgKHlTcGFuID4gbWF4U3Bhbikge1xuICAgIG1heFNwYW4gPSB5U3BhbjtcbiAgICBkaWFtZXRlcjEgPSB5TWluO1xuICAgIGRpYW1ldGVyMiA9IHlNYXg7XG4gIH1cblxuICBpZiAoelNwYW4gPiBtYXhTcGFuKSB7XG4gICAgbWF4U3BhbiA9IHpTcGFuO1xuICAgIGRpYW1ldGVyMSA9IHpNaW47XG4gICAgZGlhbWV0ZXIyID0gek1heDtcbiAgfVxuXG4gIGNvbnN0IHJpdHRlckNlbnRlciA9IGZyb21Qb2ludHNSaXR0ZXJDZW50ZXI7XG4gIHJpdHRlckNlbnRlci54ID0gKGRpYW1ldGVyMS54ICsgZGlhbWV0ZXIyLngpICogMC41O1xuICByaXR0ZXJDZW50ZXIueSA9IChkaWFtZXRlcjEueSArIGRpYW1ldGVyMi55KSAqIDAuNTtcbiAgcml0dGVyQ2VudGVyLnogPSAoZGlhbWV0ZXIxLnogKyBkaWFtZXRlcjIueikgKiAwLjU7XG4gIGxldCByYWRpdXNTcXVhcmVkID0gZnJvbVBvaW50c1NjcmF0Y2guY29weShkaWFtZXRlcjIpLnN1YnRyYWN0KHJpdHRlckNlbnRlcikubWFnbml0dWRlU3F1YXJlZCgpO1xuICBsZXQgcml0dGVyUmFkaXVzID0gTWF0aC5zcXJ0KHJhZGl1c1NxdWFyZWQpO1xuICBjb25zdCBtaW5Cb3hQdCA9IGZyb21Qb2ludHNNaW5Cb3hQdDtcbiAgbWluQm94UHQueCA9IHhNaW4ueDtcbiAgbWluQm94UHQueSA9IHlNaW4ueTtcbiAgbWluQm94UHQueiA9IHpNaW4uejtcbiAgY29uc3QgbWF4Qm94UHQgPSBmcm9tUG9pbnRzTWF4Qm94UHQ7XG4gIG1heEJveFB0LnggPSB4TWF4Lng7XG4gIG1heEJveFB0LnkgPSB5TWF4Lnk7XG4gIG1heEJveFB0LnogPSB6TWF4Lno7XG4gIGNvbnN0IG5haXZlQ2VudGVyID0gZnJvbVBvaW50c05haXZlQ2VudGVyU2NyYXRjaC5jb3B5KG1pbkJveFB0KS5hZGQobWF4Qm94UHQpLm11bHRpcGx5QnlTY2FsYXIoMC41KTtcbiAgbGV0IG5haXZlUmFkaXVzID0gMDtcblxuICBmb3IgKGNvbnN0IHBvc2l0aW9uIG9mIHBvc2l0aW9ucykge1xuICAgIGN1cnJlbnRQb3MuY29weShwb3NpdGlvbik7XG4gICAgY29uc3QgciA9IGZyb21Qb2ludHNTY3JhdGNoLmNvcHkoY3VycmVudFBvcykuc3VidHJhY3QobmFpdmVDZW50ZXIpLm1hZ25pdHVkZSgpO1xuXG4gICAgaWYgKHIgPiBuYWl2ZVJhZGl1cykge1xuICAgICAgbmFpdmVSYWRpdXMgPSByO1xuICAgIH1cblxuICAgIGNvbnN0IG9sZENlbnRlclRvUG9pbnRTcXVhcmVkID0gZnJvbVBvaW50c1NjcmF0Y2guY29weShjdXJyZW50UG9zKS5zdWJ0cmFjdChyaXR0ZXJDZW50ZXIpLm1hZ25pdHVkZVNxdWFyZWQoKTtcblxuICAgIGlmIChvbGRDZW50ZXJUb1BvaW50U3F1YXJlZCA+IHJhZGl1c1NxdWFyZWQpIHtcbiAgICAgIGNvbnN0IG9sZENlbnRlclRvUG9pbnQgPSBNYXRoLnNxcnQob2xkQ2VudGVyVG9Qb2ludFNxdWFyZWQpO1xuICAgICAgcml0dGVyUmFkaXVzID0gKHJpdHRlclJhZGl1cyArIG9sZENlbnRlclRvUG9pbnQpICogMC41O1xuICAgICAgcmFkaXVzU3F1YXJlZCA9IHJpdHRlclJhZGl1cyAqIHJpdHRlclJhZGl1cztcbiAgICAgIGNvbnN0IG9sZFRvTmV3ID0gb2xkQ2VudGVyVG9Qb2ludCAtIHJpdHRlclJhZGl1cztcbiAgICAgIHJpdHRlckNlbnRlci54ID0gKHJpdHRlclJhZGl1cyAqIHJpdHRlckNlbnRlci54ICsgb2xkVG9OZXcgKiBjdXJyZW50UG9zLngpIC8gb2xkQ2VudGVyVG9Qb2ludDtcbiAgICAgIHJpdHRlckNlbnRlci55ID0gKHJpdHRlclJhZGl1cyAqIHJpdHRlckNlbnRlci55ICsgb2xkVG9OZXcgKiBjdXJyZW50UG9zLnkpIC8gb2xkQ2VudGVyVG9Qb2ludDtcbiAgICAgIHJpdHRlckNlbnRlci56ID0gKHJpdHRlclJhZGl1cyAqIHJpdHRlckNlbnRlci56ICsgb2xkVG9OZXcgKiBjdXJyZW50UG9zLnopIC8gb2xkQ2VudGVyVG9Qb2ludDtcbiAgICB9XG4gIH1cblxuICBpZiAocml0dGVyUmFkaXVzIDwgbmFpdmVSYWRpdXMpIHtcbiAgICByaXR0ZXJDZW50ZXIudG8ocmVzdWx0LmNlbnRlcik7XG4gICAgcmVzdWx0LnJhZGl1cyA9IHJpdHRlclJhZGl1cztcbiAgfSBlbHNlIHtcbiAgICBuYWl2ZUNlbnRlci50byhyZXN1bHQuY2VudGVyKTtcbiAgICByZXN1bHQucmFkaXVzID0gbmFpdmVSYWRpdXM7XG4gIH1cblxuICByZXR1cm4gcmVzdWx0O1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Ym91bmRpbmctc3BoZXJlLWZyb20tcG9pbnRzLmpzLm1hcCIsImV4cG9ydCBkZWZhdWx0IHtcbiAgRVBTSUxPTjE6IDFlLTEsXG4gIEVQU0lMT04yOiAxZS0yLFxuICBFUFNJTE9OMzogMWUtMyxcbiAgRVBTSUxPTjQ6IDFlLTQsXG4gIEVQU0lMT041OiAxZS01LFxuICBFUFNJTE9ONjogMWUtNixcbiAgRVBTSUxPTjc6IDFlLTcsXG4gIEVQU0lMT044OiAxZS04LFxuICBFUFNJTE9OOTogMWUtOSxcbiAgRVBTSUxPTjEwOiAxZS0xMCxcbiAgRVBTSUxPTjExOiAxZS0xMSxcbiAgRVBTSUxPTjEyOiAxZS0xMixcbiAgRVBTSUxPTjEzOiAxZS0xMyxcbiAgRVBTSUxPTjE0OiAxZS0xNCxcbiAgRVBTSUxPTjE1OiAxZS0xNSxcbiAgRVBTSUxPTjE2OiAxZS0xNixcbiAgRVBTSUxPTjE3OiAxZS0xNyxcbiAgRVBTSUxPTjE4OiAxZS0xOCxcbiAgRVBTSUxPTjE5OiAxZS0xOSxcbiAgRVBTSUxPTjIwOiAxZS0yMCxcbiAgUElfT1ZFUl9UV086IE1hdGguUEkgLyAyLFxuICBQSV9PVkVSX0ZPVVI6IE1hdGguUEkgLyA0LFxuICBQSV9PVkVSX1NJWDogTWF0aC5QSSAvIDYsXG4gIFRXT19QSTogTWF0aC5QSSAqIDJcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1tYXRoLXV0aWxzLmpzLm1hcCIsImltcG9ydCB7IE1hdHJpeDMsIF9NYXRoVXRpbHMgfSBmcm9tICdAbWF0aC5nbC9jb3JlJztcbmNvbnN0IHNjcmF0Y2hNYXRyaXggPSBuZXcgTWF0cml4MygpO1xuY29uc3Qgc2NyYXRjaFVuaXRhcnkgPSBuZXcgTWF0cml4MygpO1xuY29uc3Qgc2NyYXRjaERpYWdvbmFsID0gbmV3IE1hdHJpeDMoKTtcbmNvbnN0IGpNYXRyaXggPSBuZXcgTWF0cml4MygpO1xuY29uc3Qgak1hdHJpeFRyYW5zcG9zZSA9IG5ldyBNYXRyaXgzKCk7XG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBjb21wdXRlRWlnZW5EZWNvbXBvc2l0aW9uKG1hdHJpeCwgcmVzdWx0ID0ge30pIHtcbiAgY29uc3QgRUlHRU5fVE9MRVJBTkNFID0gX01hdGhVdGlscy5FUFNJTE9OMjA7XG4gIGNvbnN0IEVJR0VOX01BWF9TV0VFUFMgPSAxMDtcbiAgbGV0IGNvdW50ID0gMDtcbiAgbGV0IHN3ZWVwID0gMDtcbiAgY29uc3QgdW5pdGFyeU1hdHJpeCA9IHNjcmF0Y2hVbml0YXJ5O1xuICBjb25zdCBkaWFnb25hbE1hdHJpeCA9IHNjcmF0Y2hEaWFnb25hbDtcbiAgdW5pdGFyeU1hdHJpeC5pZGVudGl0eSgpO1xuICBkaWFnb25hbE1hdHJpeC5jb3B5KG1hdHJpeCk7XG4gIGNvbnN0IGVwc2lsb24gPSBFSUdFTl9UT0xFUkFOQ0UgKiBjb21wdXRlRnJvYmVuaXVzTm9ybShkaWFnb25hbE1hdHJpeCk7XG5cbiAgd2hpbGUgKHN3ZWVwIDwgRUlHRU5fTUFYX1NXRUVQUyAmJiBvZmZEaWFnb25hbEZyb2Jlbml1c05vcm0oZGlhZ29uYWxNYXRyaXgpID4gZXBzaWxvbikge1xuICAgIHNodXJEZWNvbXBvc2l0aW9uKGRpYWdvbmFsTWF0cml4LCBqTWF0cml4KTtcbiAgICBqTWF0cml4VHJhbnNwb3NlLmNvcHkoak1hdHJpeCkudHJhbnNwb3NlKCk7XG4gICAgZGlhZ29uYWxNYXRyaXgubXVsdGlwbHlSaWdodChqTWF0cml4KTtcbiAgICBkaWFnb25hbE1hdHJpeC5tdWx0aXBseUxlZnQoak1hdHJpeFRyYW5zcG9zZSk7XG4gICAgdW5pdGFyeU1hdHJpeC5tdWx0aXBseVJpZ2h0KGpNYXRyaXgpO1xuXG4gICAgaWYgKCsrY291bnQgPiAyKSB7XG4gICAgICArK3N3ZWVwO1xuICAgICAgY291bnQgPSAwO1xuICAgIH1cbiAgfVxuXG4gIHJlc3VsdC51bml0YXJ5ID0gdW5pdGFyeU1hdHJpeC50b1RhcmdldChyZXN1bHQudW5pdGFyeSk7XG4gIHJlc3VsdC5kaWFnb25hbCA9IGRpYWdvbmFsTWF0cml4LnRvVGFyZ2V0KHJlc3VsdC5kaWFnb25hbCk7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbmZ1bmN0aW9uIGNvbXB1dGVGcm9iZW5pdXNOb3JtKG1hdHJpeCkge1xuICBsZXQgbm9ybSA9IDAuMDtcblxuICBmb3IgKGxldCBpID0gMDsgaSA8IDk7ICsraSkge1xuICAgIGNvbnN0IHRlbXAgPSBtYXRyaXhbaV07XG4gICAgbm9ybSArPSB0ZW1wICogdGVtcDtcbiAgfVxuXG4gIHJldHVybiBNYXRoLnNxcnQobm9ybSk7XG59XG5cbmNvbnN0IHJvd1ZhbCA9IFsxLCAwLCAwXTtcbmNvbnN0IGNvbFZhbCA9IFsyLCAyLCAxXTtcblxuZnVuY3Rpb24gb2ZmRGlhZ29uYWxGcm9iZW5pdXNOb3JtKG1hdHJpeCkge1xuICBsZXQgbm9ybSA9IDAuMDtcblxuICBmb3IgKGxldCBpID0gMDsgaSA8IDM7ICsraSkge1xuICAgIGNvbnN0IHRlbXAgPSBtYXRyaXhbc2NyYXRjaE1hdHJpeC5nZXRFbGVtZW50SW5kZXgoY29sVmFsW2ldLCByb3dWYWxbaV0pXTtcbiAgICBub3JtICs9IDIuMCAqIHRlbXAgKiB0ZW1wO1xuICB9XG5cbiAgcmV0dXJuIE1hdGguc3FydChub3JtKTtcbn1cblxuZnVuY3Rpb24gc2h1ckRlY29tcG9zaXRpb24obWF0cml4LCByZXN1bHQpIHtcbiAgY29uc3QgdG9sZXJhbmNlID0gX01hdGhVdGlscy5FUFNJTE9OMTU7XG4gIGxldCBtYXhEaWFnb25hbCA9IDAuMDtcbiAgbGV0IHJvdEF4aXMgPSAxO1xuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgMzsgKytpKSB7XG4gICAgY29uc3QgdGVtcCA9IE1hdGguYWJzKG1hdHJpeFtzY3JhdGNoTWF0cml4LmdldEVsZW1lbnRJbmRleChjb2xWYWxbaV0sIHJvd1ZhbFtpXSldKTtcblxuICAgIGlmICh0ZW1wID4gbWF4RGlhZ29uYWwpIHtcbiAgICAgIHJvdEF4aXMgPSBpO1xuICAgICAgbWF4RGlhZ29uYWwgPSB0ZW1wO1xuICAgIH1cbiAgfVxuXG4gIGNvbnN0IHAgPSByb3dWYWxbcm90QXhpc107XG4gIGNvbnN0IHEgPSBjb2xWYWxbcm90QXhpc107XG4gIGxldCBjID0gMS4wO1xuICBsZXQgcyA9IDAuMDtcblxuICBpZiAoTWF0aC5hYnMobWF0cml4W3NjcmF0Y2hNYXRyaXguZ2V0RWxlbWVudEluZGV4KHEsIHApXSkgPiB0b2xlcmFuY2UpIHtcbiAgICBjb25zdCBxcSA9IG1hdHJpeFtzY3JhdGNoTWF0cml4LmdldEVsZW1lbnRJbmRleChxLCBxKV07XG4gICAgY29uc3QgcHAgPSBtYXRyaXhbc2NyYXRjaE1hdHJpeC5nZXRFbGVtZW50SW5kZXgocCwgcCldO1xuICAgIGNvbnN0IHFwID0gbWF0cml4W3NjcmF0Y2hNYXRyaXguZ2V0RWxlbWVudEluZGV4KHEsIHApXTtcbiAgICBjb25zdCB0YXUgPSAocXEgLSBwcCkgLyAyLjAgLyBxcDtcbiAgICBsZXQgdDtcblxuICAgIGlmICh0YXUgPCAwLjApIHtcbiAgICAgIHQgPSAtMS4wIC8gKC10YXUgKyBNYXRoLnNxcnQoMS4wICsgdGF1ICogdGF1KSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHQgPSAxLjAgLyAodGF1ICsgTWF0aC5zcXJ0KDEuMCArIHRhdSAqIHRhdSkpO1xuICAgIH1cblxuICAgIGMgPSAxLjAgLyBNYXRoLnNxcnQoMS4wICsgdCAqIHQpO1xuICAgIHMgPSB0ICogYztcbiAgfVxuXG4gIE1hdHJpeDMuSURFTlRJVFkudG8ocmVzdWx0KTtcbiAgcmVzdWx0W3NjcmF0Y2hNYXRyaXguZ2V0RWxlbWVudEluZGV4KHAsIHApXSA9IHJlc3VsdFtzY3JhdGNoTWF0cml4LmdldEVsZW1lbnRJbmRleChxLCBxKV0gPSBjO1xuICByZXN1bHRbc2NyYXRjaE1hdHJpeC5nZXRFbGVtZW50SW5kZXgocSwgcCldID0gcztcbiAgcmVzdWx0W3NjcmF0Y2hNYXRyaXguZ2V0RWxlbWVudEluZGV4KHAsIHEpXSA9IC1zO1xuICByZXR1cm4gcmVzdWx0O1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y29tcHV0ZS1laWdlbi1kZWNvbXBvc2l0aW9uLmpzLm1hcCIsImltcG9ydCB7IFZlY3RvcjMsIE1hdHJpeDMgfSBmcm9tICdAbWF0aC5nbC9jb3JlJztcbmltcG9ydCBjb21wdXRlRWlnZW5EZWNvbXBvc2l0aW9uIGZyb20gJy4vY29tcHV0ZS1laWdlbi1kZWNvbXBvc2l0aW9uJztcbmltcG9ydCBPcmllbnRlZEJvdW5kaW5nQm94IGZyb20gJy4uL2JvdW5kaW5nLXZvbHVtZXMvb3JpZW50ZWQtYm91bmRpbmctYm94JztcbmltcG9ydCBBeGlzQWxpZ25lZEJvdW5kaW5nQm94IGZyb20gJy4uL2JvdW5kaW5nLXZvbHVtZXMvYXhpcy1hbGlnbmVkLWJvdW5kaW5nLWJveCc7XG5jb25zdCBzY3JhdGNoVmVjdG9yMiA9IG5ldyBWZWN0b3IzKCk7XG5jb25zdCBzY3JhdGNoVmVjdG9yMyA9IG5ldyBWZWN0b3IzKCk7XG5jb25zdCBzY3JhdGNoVmVjdG9yNCA9IG5ldyBWZWN0b3IzKCk7XG5jb25zdCBzY3JhdGNoVmVjdG9yNSA9IG5ldyBWZWN0b3IzKCk7XG5jb25zdCBzY3JhdGNoVmVjdG9yNiA9IG5ldyBWZWN0b3IzKCk7XG5jb25zdCBzY3JhdGNoQ292YXJpYW5jZVJlc3VsdCA9IG5ldyBNYXRyaXgzKCk7XG5jb25zdCBzY3JhdGNoRWlnZW5SZXN1bHQgPSB7XG4gIGRpYWdvbmFsOiBuZXcgTWF0cml4MygpLFxuICB1bml0YXJ5OiBuZXcgTWF0cml4MygpXG59O1xuZXhwb3J0IGZ1bmN0aW9uIG1ha2VPcmllbnRlZEJvdW5kaW5nQm94RnJvbVBvaW50cyhwb3NpdGlvbnMsIHJlc3VsdCA9IG5ldyBPcmllbnRlZEJvdW5kaW5nQm94KCkpIHtcbiAgaWYgKCFwb3NpdGlvbnMgfHwgcG9zaXRpb25zLmxlbmd0aCA9PT0gMCkge1xuICAgIHJlc3VsdC5oYWxmQXhlcyA9IG5ldyBNYXRyaXgzKFswLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwXSk7XG4gICAgcmVzdWx0LmNlbnRlciA9IG5ldyBWZWN0b3IzKCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIGNvbnN0IGxlbmd0aCA9IHBvc2l0aW9ucy5sZW5ndGg7XG4gIGNvbnN0IG1lYW5Qb2ludCA9IG5ldyBWZWN0b3IzKDAsIDAsIDApO1xuXG4gIGZvciAoY29uc3QgcG9zaXRpb24gb2YgcG9zaXRpb25zKSB7XG4gICAgbWVhblBvaW50LmFkZChwb3NpdGlvbik7XG4gIH1cblxuICBjb25zdCBpbnZMZW5ndGggPSAxLjAgLyBsZW5ndGg7XG4gIG1lYW5Qb2ludC5tdWx0aXBseUJ5U2NhbGFyKGludkxlbmd0aCk7XG4gIGxldCBleHggPSAwLjA7XG4gIGxldCBleHkgPSAwLjA7XG4gIGxldCBleHogPSAwLjA7XG4gIGxldCBleXkgPSAwLjA7XG4gIGxldCBleXogPSAwLjA7XG4gIGxldCBlenogPSAwLjA7XG5cbiAgZm9yIChjb25zdCBwb3NpdGlvbiBvZiBwb3NpdGlvbnMpIHtcbiAgICBjb25zdCBwID0gc2NyYXRjaFZlY3RvcjIuY29weShwb3NpdGlvbikuc3VidHJhY3QobWVhblBvaW50KTtcbiAgICBleHggKz0gcC54ICogcC54O1xuICAgIGV4eSArPSBwLnggKiBwLnk7XG4gICAgZXh6ICs9IHAueCAqIHAuejtcbiAgICBleXkgKz0gcC55ICogcC55O1xuICAgIGV5eiArPSBwLnkgKiBwLno7XG4gICAgZXp6ICs9IHAueiAqIHAuejtcbiAgfVxuXG4gIGV4eCAqPSBpbnZMZW5ndGg7XG4gIGV4eSAqPSBpbnZMZW5ndGg7XG4gIGV4eiAqPSBpbnZMZW5ndGg7XG4gIGV5eSAqPSBpbnZMZW5ndGg7XG4gIGV5eiAqPSBpbnZMZW5ndGg7XG4gIGV6eiAqPSBpbnZMZW5ndGg7XG4gIGNvbnN0IGNvdmFyaWFuY2VNYXRyaXggPSBzY3JhdGNoQ292YXJpYW5jZVJlc3VsdDtcbiAgY292YXJpYW5jZU1hdHJpeFswXSA9IGV4eDtcbiAgY292YXJpYW5jZU1hdHJpeFsxXSA9IGV4eTtcbiAgY292YXJpYW5jZU1hdHJpeFsyXSA9IGV4ejtcbiAgY292YXJpYW5jZU1hdHJpeFszXSA9IGV4eTtcbiAgY292YXJpYW5jZU1hdHJpeFs0XSA9IGV5eTtcbiAgY292YXJpYW5jZU1hdHJpeFs1XSA9IGV5ejtcbiAgY292YXJpYW5jZU1hdHJpeFs2XSA9IGV4ejtcbiAgY292YXJpYW5jZU1hdHJpeFs3XSA9IGV5ejtcbiAgY292YXJpYW5jZU1hdHJpeFs4XSA9IGV6ejtcbiAgY29uc3Qge1xuICAgIHVuaXRhcnlcbiAgfSA9IGNvbXB1dGVFaWdlbkRlY29tcG9zaXRpb24oY292YXJpYW5jZU1hdHJpeCwgc2NyYXRjaEVpZ2VuUmVzdWx0KTtcbiAgY29uc3Qgcm90YXRpb24gPSByZXN1bHQuaGFsZkF4ZXMuY29weSh1bml0YXJ5KTtcbiAgbGV0IHYxID0gcm90YXRpb24uZ2V0Q29sdW1uKDAsIHNjcmF0Y2hWZWN0b3I0KTtcbiAgbGV0IHYyID0gcm90YXRpb24uZ2V0Q29sdW1uKDEsIHNjcmF0Y2hWZWN0b3I1KTtcbiAgbGV0IHYzID0gcm90YXRpb24uZ2V0Q29sdW1uKDIsIHNjcmF0Y2hWZWN0b3I2KTtcbiAgbGV0IHUxID0gLU51bWJlci5NQVhfVkFMVUU7XG4gIGxldCB1MiA9IC1OdW1iZXIuTUFYX1ZBTFVFO1xuICBsZXQgdTMgPSAtTnVtYmVyLk1BWF9WQUxVRTtcbiAgbGV0IGwxID0gTnVtYmVyLk1BWF9WQUxVRTtcbiAgbGV0IGwyID0gTnVtYmVyLk1BWF9WQUxVRTtcbiAgbGV0IGwzID0gTnVtYmVyLk1BWF9WQUxVRTtcblxuICBmb3IgKGNvbnN0IHBvc2l0aW9uIG9mIHBvc2l0aW9ucykge1xuICAgIHNjcmF0Y2hWZWN0b3IyLmNvcHkocG9zaXRpb24pO1xuICAgIHUxID0gTWF0aC5tYXgoc2NyYXRjaFZlY3RvcjIuZG90KHYxKSwgdTEpO1xuICAgIHUyID0gTWF0aC5tYXgoc2NyYXRjaFZlY3RvcjIuZG90KHYyKSwgdTIpO1xuICAgIHUzID0gTWF0aC5tYXgoc2NyYXRjaFZlY3RvcjIuZG90KHYzKSwgdTMpO1xuICAgIGwxID0gTWF0aC5taW4oc2NyYXRjaFZlY3RvcjIuZG90KHYxKSwgbDEpO1xuICAgIGwyID0gTWF0aC5taW4oc2NyYXRjaFZlY3RvcjIuZG90KHYyKSwgbDIpO1xuICAgIGwzID0gTWF0aC5taW4oc2NyYXRjaFZlY3RvcjIuZG90KHYzKSwgbDMpO1xuICB9XG5cbiAgdjEgPSB2MS5tdWx0aXBseUJ5U2NhbGFyKDAuNSAqIChsMSArIHUxKSk7XG4gIHYyID0gdjIubXVsdGlwbHlCeVNjYWxhcigwLjUgKiAobDIgKyB1MikpO1xuICB2MyA9IHYzLm11bHRpcGx5QnlTY2FsYXIoMC41ICogKGwzICsgdTMpKTtcbiAgcmVzdWx0LmNlbnRlci5jb3B5KHYxKS5hZGQodjIpLmFkZCh2Myk7XG4gIGNvbnN0IHNjYWxlID0gc2NyYXRjaFZlY3RvcjMuc2V0KHUxIC0gbDEsIHUyIC0gbDIsIHUzIC0gbDMpLm11bHRpcGx5QnlTY2FsYXIoMC41KTtcbiAgY29uc3Qgc2NhbGVNYXRyaXggPSBuZXcgTWF0cml4Myhbc2NhbGVbMF0sIDAsIDAsIDAsIHNjYWxlWzFdLCAwLCAwLCAwLCBzY2FsZVsyXV0pO1xuICByZXN1bHQuaGFsZkF4ZXMubXVsdGlwbHlSaWdodChzY2FsZU1hdHJpeCk7XG4gIHJldHVybiByZXN1bHQ7XG59XG5leHBvcnQgZnVuY3Rpb24gbWFrZUF4aXNBbGlnbmVkQm91bmRpbmdCb3hGcm9tUG9pbnRzKHBvc2l0aW9ucywgcmVzdWx0ID0gbmV3IEF4aXNBbGlnbmVkQm91bmRpbmdCb3goKSkge1xuICBpZiAoIXBvc2l0aW9ucyB8fCBwb3NpdGlvbnMubGVuZ3RoID09PSAwKSB7XG4gICAgcmVzdWx0Lm1pbmltdW0uc2V0KDAsIDAsIDApO1xuICAgIHJlc3VsdC5tYXhpbXVtLnNldCgwLCAwLCAwKTtcbiAgICByZXN1bHQuY2VudGVyLnNldCgwLCAwLCAwKTtcbiAgICByZXN1bHQuaGFsZkRpYWdvbmFsLnNldCgwLCAwLCAwKTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgbGV0IG1pbmltdW1YID0gcG9zaXRpb25zWzBdWzBdO1xuICBsZXQgbWluaW11bVkgPSBwb3NpdGlvbnNbMF1bMV07XG4gIGxldCBtaW5pbXVtWiA9IHBvc2l0aW9uc1swXVsyXTtcbiAgbGV0IG1heGltdW1YID0gcG9zaXRpb25zWzBdWzBdO1xuICBsZXQgbWF4aW11bVkgPSBwb3NpdGlvbnNbMF1bMV07XG4gIGxldCBtYXhpbXVtWiA9IHBvc2l0aW9uc1swXVsyXTtcblxuICBmb3IgKGNvbnN0IHAgb2YgcG9zaXRpb25zKSB7XG4gICAgY29uc3QgeCA9IHBbMF07XG4gICAgY29uc3QgeSA9IHBbMV07XG4gICAgY29uc3QgeiA9IHBbMl07XG4gICAgbWluaW11bVggPSBNYXRoLm1pbih4LCBtaW5pbXVtWCk7XG4gICAgbWF4aW11bVggPSBNYXRoLm1heCh4LCBtYXhpbXVtWCk7XG4gICAgbWluaW11bVkgPSBNYXRoLm1pbih5LCBtaW5pbXVtWSk7XG4gICAgbWF4aW11bVkgPSBNYXRoLm1heCh5LCBtYXhpbXVtWSk7XG4gICAgbWluaW11bVogPSBNYXRoLm1pbih6LCBtaW5pbXVtWik7XG4gICAgbWF4aW11bVogPSBNYXRoLm1heCh6LCBtYXhpbXVtWik7XG4gIH1cblxuICByZXN1bHQubWluaW11bS5zZXQobWluaW11bVgsIG1pbmltdW1ZLCBtaW5pbXVtWik7XG4gIHJlc3VsdC5tYXhpbXVtLnNldChtYXhpbXVtWCwgbWF4aW11bVksIG1heGltdW1aKTtcbiAgcmVzdWx0LmNlbnRlci5jb3B5KHJlc3VsdC5taW5pbXVtKS5hZGQocmVzdWx0Lm1heGltdW0pLnNjYWxlKDAuNSk7XG4gIHJlc3VsdC5oYWxmRGlhZ29uYWwuY29weShyZXN1bHQubWF4aW11bSkuc3VidHJhY3QocmVzdWx0LmNlbnRlcik7XG4gIHJldHVybiByZXN1bHQ7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1ib3VuZGluZy1ib3gtZnJvbS1wb2ludHMuanMubWFwIiwiZXhwb3J0IHsgSU5URVJTRUNUSU9OIH0gZnJvbSAnLi9jb25zdGFudHMnO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBBeGlzQWxpZ25lZEJvdW5kaW5nQm94IH0gZnJvbSAnLi9saWIvYm91bmRpbmctdm9sdW1lcy9heGlzLWFsaWduZWQtYm91bmRpbmctYm94JztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgQm91bmRpbmdTcGhlcmUgfSBmcm9tICcuL2xpYi9ib3VuZGluZy12b2x1bWVzL2JvdW5kaW5nLXNwaGVyZSc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIE9yaWVudGVkQm91bmRpbmdCb3ggfSBmcm9tICcuL2xpYi9ib3VuZGluZy12b2x1bWVzL29yaWVudGVkLWJvdW5kaW5nLWJveCc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIEN1bGxpbmdWb2x1bWUgfSBmcm9tICcuL2xpYi9jdWxsaW5nLXZvbHVtZSc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIFBsYW5lIH0gZnJvbSAnLi9saWIvcGxhbmUnO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBfUGVyc3BlY3RpdmVPZmZDZW50ZXJGcnVzdHVtIH0gZnJvbSAnLi9saWIvcGVyc3BlY3RpdmUtb2ZmLWNlbnRlci1mcnVzdHVtJztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgX1BlcnNwZWN0aXZlRnJ1c3R1bSB9IGZyb20gJy4vbGliL3BlcnNwZWN0aXZlLWZydXN0dW0nO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBtYWtlQm91bmRpbmdTcGhlcmVGcm9tUG9pbnRzIH0gZnJvbSAnLi9saWIvYWxnb3JpdGhtcy9ib3VuZGluZy1zcGhlcmUtZnJvbS1wb2ludHMnO1xuZXhwb3J0IHsgbWFrZUF4aXNBbGlnbmVkQm91bmRpbmdCb3hGcm9tUG9pbnRzLCBtYWtlT3JpZW50ZWRCb3VuZGluZ0JveEZyb21Qb2ludHMgfSBmcm9tICcuL2xpYi9hbGdvcml0aG1zL2JvdW5kaW5nLWJveC1mcm9tLXBvaW50cyc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIGNvbXB1dGVFaWdlbkRlY29tcG9zaXRpb24gfSBmcm9tICcuL2xpYi9hbGdvcml0aG1zL2NvbXB1dGUtZWlnZW4tZGVjb21wb3NpdGlvbic7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///36772\n')},89513:function(__unused_webpack_module,__webpack_exports__,__webpack_require__){eval('\n// EXPORTS\n__webpack_require__.d(__webpack_exports__, {\n  "wG": function() { return /* reexport */ WINDING; },\n  "WZ": function() { return /* reexport */ cutPolygonByGrid; },\n  "GU": function() { return /* reexport */ cutPolygonByMercatorBounds; },\n  "dj": function() { return /* reexport */ cutPolylineByGrid; },\n  "ct": function() { return /* reexport */ cutPolylineByMercatorBounds; },\n  "Ny": function() { return /* reexport */ polygon_utils_modifyPolygonWindingDirection; }\n});\n\n// UNUSED EXPORTS: Polygon, _Polygon, clipPolygon, clipPolyline, earcut, forEachSegmentInPolygon, getPolygonSignedArea, getPolygonWindingDirection\n\n;// CONCATENATED MODULE: ./node_modules/@math.gl/polygon/dist/esm/polygon-utils.js\n\nconst WINDING = {\n  CLOCKWISE: 1,\n  COUNTER_CLOCKWISE: -1\n};\nfunction polygon_utils_modifyPolygonWindingDirection(points, direction, options = {}) {\n  const windingDirection = getPolygonWindingDirection(points, options);\n\n  if (windingDirection !== direction) {\n    reversePolygon(points, options);\n    return true;\n  }\n\n  return false;\n}\nfunction getPolygonWindingDirection(points, options = {}) {\n  return Math.sign(polygon_utils_getPolygonSignedArea(points, options));\n}\nfunction polygon_utils_getPolygonSignedArea(points, options = {}) {\n  const {\n    start = 0,\n    end = points.length\n  } = options;\n  const dim = options.size || 2;\n  let area = 0;\n\n  for (let i = start, j = end - dim; i < end; i += dim) {\n    area += (points[i] - points[j]) * (points[i + 1] + points[j + 1]);\n    j = i;\n  }\n\n  return area / 2;\n}\nfunction polygon_utils_forEachSegmentInPolygon(points, visitor, options = {}) {\n  const {\n    start = 0,\n    end = points.length,\n    size = 2,\n    isClosed\n  } = options;\n  const numPoints = (end - start) / size;\n\n  for (let i = 0; i < numPoints - 1; ++i) {\n    visitor(points[start + i * size], points[start + i * size + 1], points[start + (i + 1) * size], points[start + (i + 1) * size + 1], i, i + 1);\n  }\n\n  const endPointIndex = start + (numPoints - 1) * size;\n  const isClosedEx = isClosed || equals(points[start], points[endPointIndex]) && equals(points[start + 1], points[endPointIndex + 1]);\n\n  if (!isClosedEx) {\n    visitor(points[endPointIndex], points[endPointIndex + 1], points[start], points[start + 1], numPoints - 1, 0);\n  }\n}\n\nfunction reversePolygon(points, options) {\n  const {\n    start = 0,\n    end = points.length,\n    size = 2\n  } = options;\n  const numPoints = (end - start) / size;\n  const numSwaps = Math.floor(numPoints / 2);\n\n  for (let i = 0; i < numSwaps; ++i) {\n    const b1 = start + i * size;\n    const b2 = start + (numPoints - 1 - i) * size;\n\n    for (let j = 0; j < size; ++j) {\n      const tmp = points[b1 + j];\n      points[b1 + j] = points[b2 + j];\n      points[b2 + j] = tmp;\n    }\n  }\n}\n\nfunction polygon_utils_modifyPolygonWindingDirectionPoints(points, direction, options = {}) {\n  const currentDirection = getPolygonWindingDirectionPoints(points, options);\n\n  if (currentDirection !== direction) {\n    points.reverse();\n    return true;\n  }\n\n  return false;\n}\nfunction getPolygonWindingDirectionPoints(points, options = {}) {\n  return Math.sign(polygon_utils_getPolygonSignedAreaPoints(points, options));\n}\nfunction polygon_utils_getPolygonSignedAreaPoints(points, options = {}) {\n  const {\n    start = 0,\n    end = points.length\n  } = options;\n  let area = 0;\n\n  for (let i = start, j = end - 1; i < end; ++i) {\n    area += (points[i][0] - points[j][0]) * (points[i][1] + points[j][1]);\n    j = i;\n  }\n\n  return area / 2;\n}\nfunction polygon_utils_forEachSegmentInPolygonPoints(points, visitor, options = {}) {\n  const {\n    start = 0,\n    end = points.length,\n    isClosed\n  } = options;\n\n  for (let i = start; i < end - 1; ++i) {\n    visitor(points[i], points[i + 1], i, i + 1);\n  }\n\n  const isClosedEx = isClosed || equals(points[end - 1], points[0]);\n\n  if (!isClosedEx) {\n    visitor(points[end - 1], points[0], end - 1, 0);\n  }\n}\n//# sourceMappingURL=polygon-utils.js.map\n;// CONCATENATED MODULE: ./node_modules/@math.gl/polygon/dist/esm/polygon.js\n\n\n\nclass Polygon {\n  constructor(points, options = {}) {\n    _defineProperty(this, "points", void 0);\n\n    _defineProperty(this, "isFlatArray", void 0);\n\n    _defineProperty(this, "options", void 0);\n\n    this.points = points;\n    this.isFlatArray = !isArray(points[0]);\n    this.options = {\n      start: options.start || 0,\n      end: options.end || points.length,\n      size: options.size || 2,\n      isClosed: options.isClosed\n    };\n    Object.freeze(this);\n  }\n\n  getSignedArea() {\n    if (this.isFlatArray) return getPolygonSignedArea(this.points, this.options);\n    return getPolygonSignedAreaPoints(this.points, this.options);\n  }\n\n  getArea() {\n    return Math.abs(this.getSignedArea());\n  }\n\n  getWindingDirection() {\n    return Math.sign(this.getSignedArea());\n  }\n\n  forEachSegment(visitor) {\n    if (this.isFlatArray) {\n      forEachSegmentInPolygon(this.points, (x1, y1, x2, y2, i1, i2) => {\n        visitor([x1, y1], [x2, y2], i1, i2);\n      }, this.options);\n    } else {\n      forEachSegmentInPolygonPoints(this.points, visitor, this.options);\n    }\n  }\n\n  modifyWindingDirection(direction) {\n    if (this.isFlatArray) {\n      return modifyPolygonWindingDirection(this.points, direction, this.options);\n    }\n\n    return modifyPolygonWindingDirectionPoints(this.points, direction, this.options);\n  }\n\n}\n//# sourceMappingURL=polygon.js.map\n;// CONCATENATED MODULE: ./node_modules/@math.gl/polygon/dist/esm/earcut.js\n\nfunction earcut(positions, holeIndices, dim = 2, areas) {\n  const hasHoles = holeIndices && holeIndices.length;\n  const outerLen = hasHoles ? holeIndices[0] * dim : positions.length;\n  let outerNode = linkedList(positions, 0, outerLen, dim, true, areas && areas[0]);\n  const triangles = [];\n  if (!outerNode || outerNode.next === outerNode.prev) return triangles;\n  let invSize;\n  let maxX;\n  let maxY;\n  let minX;\n  let minY;\n  let x;\n  let y;\n  if (hasHoles) outerNode = eliminateHoles(positions, holeIndices, outerNode, dim, areas);\n\n  if (positions.length > 80 * dim) {\n    minX = maxX = positions[0];\n    minY = maxY = positions[1];\n\n    for (let i = dim; i < outerLen; i += dim) {\n      x = positions[i];\n      y = positions[i + 1];\n      if (x < minX) minX = x;\n      if (y < minY) minY = y;\n      if (x > maxX) maxX = x;\n      if (y > maxY) maxY = y;\n    }\n\n    invSize = Math.max(maxX - minX, maxY - minY);\n    invSize = invSize !== 0 ? 1 / invSize : 0;\n  }\n\n  earcutLinked(outerNode, triangles, dim, minX, minY, invSize);\n  return triangles;\n}\n\nfunction linkedList(data, start, end, dim, clockwise, area) {\n  let i;\n  let last;\n\n  if (area === undefined) {\n    area = getPolygonSignedArea(data, {\n      start,\n      end,\n      size: dim\n    });\n  }\n\n  if (clockwise === area < 0) {\n    for (i = start; i < end; i += dim) last = insertNode(i, data[i], data[i + 1], last);\n  } else {\n    for (i = end - dim; i >= start; i -= dim) last = insertNode(i, data[i], data[i + 1], last);\n  }\n\n  if (last && earcut_equals(last, last.next)) {\n    removeNode(last);\n    last = last.next;\n  }\n\n  return last;\n}\n\nfunction filterPoints(start, end) {\n  if (!start) return start;\n  if (!end) end = start;\n  let p = start;\n  let again;\n\n  do {\n    again = false;\n\n    if (!p.steiner && (earcut_equals(p, p.next) || earcut_area(p.prev, p, p.next) === 0)) {\n      removeNode(p);\n      p = end = p.prev;\n      if (p === p.next) break;\n      again = true;\n    } else {\n      p = p.next;\n    }\n  } while (again || p !== end);\n\n  return end;\n}\n\nfunction earcutLinked(ear, triangles, dim, minX, minY, invSize, pass) {\n  if (!ear) return;\n  if (!pass && invSize) indexCurve(ear, minX, minY, invSize);\n  let stop = ear;\n  let prev;\n  let next;\n\n  while (ear.prev !== ear.next) {\n    prev = ear.prev;\n    next = ear.next;\n\n    if (invSize ? isEarHashed(ear, minX, minY, invSize) : isEar(ear)) {\n      triangles.push(prev.i / dim);\n      triangles.push(ear.i / dim);\n      triangles.push(next.i / dim);\n      removeNode(ear);\n      ear = next.next;\n      stop = next.next;\n      continue;\n    }\n\n    ear = next;\n\n    if (ear === stop) {\n      if (!pass) {\n        earcutLinked(filterPoints(ear), triangles, dim, minX, minY, invSize, 1);\n      } else if (pass === 1) {\n        ear = cureLocalIntersections(filterPoints(ear), triangles, dim);\n        earcutLinked(ear, triangles, dim, minX, minY, invSize, 2);\n      } else if (pass === 2) {\n        splitEarcut(ear, triangles, dim, minX, minY, invSize);\n      }\n\n      break;\n    }\n  }\n}\n\nfunction isEar(ear) {\n  const a = ear.prev;\n  const b = ear;\n  const c = ear.next;\n  if (earcut_area(a, b, c) >= 0) return false;\n  let p = ear.next.next;\n\n  while (p !== ear.prev) {\n    if (pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) && earcut_area(p.prev, p, p.next) >= 0) return false;\n    p = p.next;\n  }\n\n  return true;\n}\n\nfunction isEarHashed(ear, minX, minY, invSize) {\n  const a = ear.prev;\n  const b = ear;\n  const c = ear.next;\n  if (earcut_area(a, b, c) >= 0) return false;\n  const minTX = a.x < b.x ? a.x < c.x ? a.x : c.x : b.x < c.x ? b.x : c.x;\n  const minTY = a.y < b.y ? a.y < c.y ? a.y : c.y : b.y < c.y ? b.y : c.y;\n  const maxTX = a.x > b.x ? a.x > c.x ? a.x : c.x : b.x > c.x ? b.x : c.x;\n  const maxTY = a.y > b.y ? a.y > c.y ? a.y : c.y : b.y > c.y ? b.y : c.y;\n  const minZ = zOrder(minTX, minTY, minX, minY, invSize);\n  const maxZ = zOrder(maxTX, maxTY, minX, minY, invSize);\n  let p = ear.prevZ;\n  let n = ear.nextZ;\n\n  while (p && p.z >= minZ && n && n.z <= maxZ) {\n    if (p !== ear.prev && p !== ear.next && pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) && earcut_area(p.prev, p, p.next) >= 0) return false;\n    p = p.prevZ;\n    if (n !== ear.prev && n !== ear.next && pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, n.x, n.y) && earcut_area(n.prev, n, n.next) >= 0) return false;\n    n = n.nextZ;\n  }\n\n  while (p && p.z >= minZ) {\n    if (p !== ear.prev && p !== ear.next && pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) && earcut_area(p.prev, p, p.next) >= 0) return false;\n    p = p.prevZ;\n  }\n\n  while (n && n.z <= maxZ) {\n    if (n !== ear.prev && n !== ear.next && pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, n.x, n.y) && earcut_area(n.prev, n, n.next) >= 0) return false;\n    n = n.nextZ;\n  }\n\n  return true;\n}\n\nfunction cureLocalIntersections(start, triangles, dim) {\n  let p = start;\n\n  do {\n    const a = p.prev;\n    const b = p.next.next;\n\n    if (!earcut_equals(a, b) && intersects(a, p, p.next, b) && locallyInside(a, b) && locallyInside(b, a)) {\n      triangles.push(a.i / dim);\n      triangles.push(p.i / dim);\n      triangles.push(b.i / dim);\n      removeNode(p);\n      removeNode(p.next);\n      p = start = b;\n    }\n\n    p = p.next;\n  } while (p !== start);\n\n  return filterPoints(p);\n}\n\nfunction splitEarcut(start, triangles, dim, minX, minY, invSize) {\n  let a = start;\n\n  do {\n    let b = a.next.next;\n\n    while (b !== a.prev) {\n      if (a.i !== b.i && isValidDiagonal(a, b)) {\n        let c = splitPolygon(a, b);\n        a = filterPoints(a, a.next);\n        c = filterPoints(c, c.next);\n        earcutLinked(a, triangles, dim, minX, minY, invSize);\n        earcutLinked(c, triangles, dim, minX, minY, invSize);\n        return;\n      }\n\n      b = b.next;\n    }\n\n    a = a.next;\n  } while (a !== start);\n}\n\nfunction eliminateHoles(data, holeIndices, outerNode, dim, areas) {\n  const queue = [];\n  let i;\n  let len;\n  let start;\n  let end;\n  let list;\n\n  for (i = 0, len = holeIndices.length; i < len; i++) {\n    start = holeIndices[i] * dim;\n    end = i < len - 1 ? holeIndices[i + 1] * dim : data.length;\n    list = linkedList(data, start, end, dim, false, areas && areas[i + 1]);\n    if (list === list.next) list.steiner = true;\n    queue.push(getLeftmost(list));\n  }\n\n  queue.sort(compareX);\n\n  for (i = 0; i < queue.length; i++) {\n    eliminateHole(queue[i], outerNode);\n    outerNode = filterPoints(outerNode, outerNode.next);\n  }\n\n  return outerNode;\n}\n\nfunction compareX(a, b) {\n  return a.x - b.x;\n}\n\nfunction eliminateHole(hole, outerNode) {\n  outerNode = findHoleBridge(hole, outerNode);\n\n  if (outerNode) {\n    const b = splitPolygon(outerNode, hole);\n    filterPoints(outerNode, outerNode.next);\n    filterPoints(b, b.next);\n  }\n}\n\nfunction findHoleBridge(hole, outerNode) {\n  let p = outerNode;\n  const hx = hole.x;\n  const hy = hole.y;\n  let qx = -Infinity;\n  let m;\n\n  do {\n    if (hy <= p.y && hy >= p.next.y && p.next.y !== p.y) {\n      const x = p.x + (hy - p.y) * (p.next.x - p.x) / (p.next.y - p.y);\n\n      if (x <= hx && x > qx) {\n        qx = x;\n\n        if (x === hx) {\n          if (hy === p.y) return p;\n          if (hy === p.next.y) return p.next;\n        }\n\n        m = p.x < p.next.x ? p : p.next;\n      }\n    }\n\n    p = p.next;\n  } while (p !== outerNode);\n\n  if (!m) return null;\n  if (hx === qx) return m;\n  const stop = m;\n  const mx = m.x;\n  const my = m.y;\n  let tanMin = Infinity;\n  let tan;\n  p = m;\n\n  do {\n    if (hx >= p.x && p.x >= mx && hx !== p.x && pointInTriangle(hy < my ? hx : qx, hy, mx, my, hy < my ? qx : hx, hy, p.x, p.y)) {\n      tan = Math.abs(hy - p.y) / (hx - p.x);\n\n      if (locallyInside(p, hole) && (tan < tanMin || tan === tanMin && (p.x > m.x || p.x === m.x && sectorContainsSector(m, p)))) {\n        m = p;\n        tanMin = tan;\n      }\n    }\n\n    p = p.next;\n  } while (p !== stop);\n\n  return m;\n}\n\nfunction sectorContainsSector(m, p) {\n  return earcut_area(m.prev, m, p.prev) < 0 && earcut_area(p.next, m, m.next) < 0;\n}\n\nfunction indexCurve(start, minX, minY, invSize) {\n  let p = start;\n\n  do {\n    if (p.z === null) p.z = zOrder(p.x, p.y, minX, minY, invSize);\n    p.prevZ = p.prev;\n    p.nextZ = p.next;\n    p = p.next;\n  } while (p !== start);\n\n  p.prevZ.nextZ = null;\n  p.prevZ = null;\n  sortLinked(p);\n}\n\nfunction sortLinked(list) {\n  let e;\n  let i;\n  let inSize = 1;\n  let numMerges;\n  let p;\n  let pSize;\n  let q;\n  let qSize;\n  let tail;\n\n  do {\n    p = list;\n    list = null;\n    tail = null;\n    numMerges = 0;\n\n    while (p) {\n      numMerges++;\n      q = p;\n      pSize = 0;\n\n      for (i = 0; i < inSize; i++) {\n        pSize++;\n        q = q.nextZ;\n        if (!q) break;\n      }\n\n      qSize = inSize;\n\n      while (pSize > 0 || qSize > 0 && q) {\n        if (pSize !== 0 && (qSize === 0 || !q || p.z <= q.z)) {\n          e = p;\n          p = p.nextZ;\n          pSize--;\n        } else {\n          e = q;\n          q = q.nextZ;\n          qSize--;\n        }\n\n        if (tail) tail.nextZ = e;else list = e;\n        e.prevZ = tail;\n        tail = e;\n      }\n\n      p = q;\n    }\n\n    tail.nextZ = null;\n    inSize *= 2;\n  } while (numMerges > 1);\n\n  return list;\n}\n\nfunction zOrder(x, y, minX, minY, invSize) {\n  x = 32767 * (x - minX) * invSize;\n  y = 32767 * (y - minY) * invSize;\n  x = (x | x << 8) & 0x00ff00ff;\n  x = (x | x << 4) & 0x0f0f0f0f;\n  x = (x | x << 2) & 0x33333333;\n  x = (x | x << 1) & 0x55555555;\n  y = (y | y << 8) & 0x00ff00ff;\n  y = (y | y << 4) & 0x0f0f0f0f;\n  y = (y | y << 2) & 0x33333333;\n  y = (y | y << 1) & 0x55555555;\n  return x | y << 1;\n}\n\nfunction getLeftmost(start) {\n  let p = start;\n  let leftmost = start;\n\n  do {\n    if (p.x < leftmost.x || p.x === leftmost.x && p.y < leftmost.y) leftmost = p;\n    p = p.next;\n  } while (p !== start);\n\n  return leftmost;\n}\n\nfunction pointInTriangle(ax, ay, bx, by, cx, cy, px, py) {\n  return (cx - px) * (ay - py) - (ax - px) * (cy - py) >= 0 && (ax - px) * (by - py) - (bx - px) * (ay - py) >= 0 && (bx - px) * (cy - py) - (cx - px) * (by - py) >= 0;\n}\n\nfunction isValidDiagonal(a, b) {\n  return a.next.i !== b.i && a.prev.i !== b.i && !intersectsPolygon(a, b) && (locallyInside(a, b) && locallyInside(b, a) && middleInside(a, b) && (earcut_area(a.prev, a, b.prev) || earcut_area(a, b.prev, b)) || earcut_equals(a, b) && earcut_area(a.prev, a, a.next) > 0 && earcut_area(b.prev, b, b.next) > 0);\n}\n\nfunction earcut_area(p, q, r) {\n  return (q.y - p.y) * (r.x - q.x) - (q.x - p.x) * (r.y - q.y);\n}\n\nfunction earcut_equals(p1, p2) {\n  return p1.x === p2.x && p1.y === p2.y;\n}\n\nfunction intersects(p1, q1, p2, q2) {\n  const o1 = sign(earcut_area(p1, q1, p2));\n  const o2 = sign(earcut_area(p1, q1, q2));\n  const o3 = sign(earcut_area(p2, q2, p1));\n  const o4 = sign(earcut_area(p2, q2, q1));\n  if (o1 !== o2 && o3 !== o4) return true;\n  if (o1 === 0 && onSegment(p1, p2, q1)) return true;\n  if (o2 === 0 && onSegment(p1, q2, q1)) return true;\n  if (o3 === 0 && onSegment(p2, p1, q2)) return true;\n  if (o4 === 0 && onSegment(p2, q1, q2)) return true;\n  return false;\n}\n\nfunction onSegment(p, q, r) {\n  return q.x <= Math.max(p.x, r.x) && q.x >= Math.min(p.x, r.x) && q.y <= Math.max(p.y, r.y) && q.y >= Math.min(p.y, r.y);\n}\n\nfunction sign(num) {\n  return num > 0 ? 1 : num < 0 ? -1 : 0;\n}\n\nfunction intersectsPolygon(a, b) {\n  let p = a;\n\n  do {\n    if (p.i !== a.i && p.next.i !== a.i && p.i !== b.i && p.next.i !== b.i && intersects(p, p.next, a, b)) return true;\n    p = p.next;\n  } while (p !== a);\n\n  return false;\n}\n\nfunction locallyInside(a, b) {\n  return earcut_area(a.prev, a, a.next) < 0 ? earcut_area(a, b, a.next) >= 0 && earcut_area(a, a.prev, b) >= 0 : earcut_area(a, b, a.prev) < 0 || earcut_area(a, a.next, b) < 0;\n}\n\nfunction middleInside(a, b) {\n  let p = a;\n  let inside = false;\n  const px = (a.x + b.x) / 2;\n  const py = (a.y + b.y) / 2;\n\n  do {\n    if (p.y > py !== p.next.y > py && p.next.y !== p.y && px < (p.next.x - p.x) * (py - p.y) / (p.next.y - p.y) + p.x) inside = !inside;\n    p = p.next;\n  } while (p !== a);\n\n  return inside;\n}\n\nfunction splitPolygon(a, b) {\n  const a2 = new Node(a.i, a.x, a.y);\n  const b2 = new Node(b.i, b.x, b.y);\n  const an = a.next;\n  const bp = b.prev;\n  a.next = b;\n  b.prev = a;\n  a2.next = an;\n  an.prev = a2;\n  b2.next = a2;\n  a2.prev = b2;\n  bp.next = b2;\n  b2.prev = bp;\n  return b2;\n}\n\nfunction insertNode(i, x, y, last) {\n  const p = new Node(i, x, y);\n\n  if (!last) {\n    p.prev = p;\n    p.next = p;\n  } else {\n    p.next = last.next;\n    p.prev = last;\n    last.next.prev = p;\n    last.next = p;\n  }\n\n  return p;\n}\n\nfunction removeNode(p) {\n  p.next.prev = p.prev;\n  p.prev.next = p.next;\n  if (p.prevZ) p.prevZ.nextZ = p.nextZ;\n  if (p.nextZ) p.nextZ.prevZ = p.prevZ;\n}\n\nfunction Node(i, x, y) {\n  this.i = i;\n  this.x = x;\n  this.y = y;\n  this.prev = null;\n  this.next = null;\n  this.z = null;\n  this.prevZ = null;\n  this.nextZ = null;\n  this.steiner = false;\n}\n//# sourceMappingURL=earcut.js.map\n;// CONCATENATED MODULE: ./node_modules/@math.gl/polygon/dist/esm/lineclip.js\n\nfunction clipPolyline(positions, bbox, options) {\n  const {\n    size = 2,\n    startIndex = 0,\n    endIndex = positions.length\n  } = options || {};\n  const numPoints = (endIndex - startIndex) / size;\n  const result = [];\n  let part = [];\n  let a;\n  let b;\n  let codeA = -1;\n  let codeB;\n  let lastCode;\n\n  for (let i = 1; i < numPoints; i++) {\n    a = getPointAtIndex(positions, i - 1, size, startIndex, a);\n    b = getPointAtIndex(positions, i, size, startIndex, b);\n\n    if (codeA < 0) {\n      codeA = bitCode(a, bbox);\n    }\n\n    codeB = lastCode = bitCode(b, bbox);\n\n    while (true) {\n      if (!(codeA | codeB)) {\n        push(part, a);\n\n        if (codeB !== lastCode) {\n          push(part, b);\n\n          if (i < numPoints - 1) {\n            result.push(part);\n            part = [];\n          }\n        } else if (i === numPoints - 1) {\n          push(part, b);\n        }\n\n        break;\n      } else if (codeA & codeB) {\n        break;\n      } else if (codeA) {\n        intersect(a, b, codeA, bbox, a);\n        codeA = bitCode(a, bbox);\n      } else {\n        intersect(a, b, codeB, bbox, b);\n        codeB = bitCode(b, bbox);\n      }\n    }\n\n    codeA = lastCode;\n  }\n\n  if (part.length) result.push(part);\n  return result;\n}\nfunction clipPolygon(positions, bbox, options) {\n  const {\n    size = 2,\n    endIndex = positions.length\n  } = options || {};\n  let {\n    startIndex = 0\n  } = options || {};\n  let numPoints = (endIndex - startIndex) / size;\n  let result;\n  let p;\n  let prev;\n  let inside;\n  let prevInside;\n\n  for (let edge = 1; edge <= 8; edge *= 2) {\n    result = [];\n    prev = getPointAtIndex(positions, numPoints - 1, size, startIndex, prev);\n    prevInside = !(bitCode(prev, bbox) & edge);\n\n    for (let i = 0; i < numPoints; i++) {\n      p = getPointAtIndex(positions, i, size, startIndex, p);\n      inside = !(bitCode(p, bbox) & edge);\n      if (inside !== prevInside) push(result, intersect(prev, p, edge, bbox));\n      if (inside) push(result, p);\n      copy(prev, p);\n      prevInside = inside;\n    }\n\n    positions = result;\n    startIndex = 0;\n    numPoints = result.length / size;\n    if (!numPoints) break;\n  }\n\n  return result;\n}\nfunction intersect(a, b, edge, bbox, out = []) {\n  let t;\n  let snap;\n\n  if (edge & 8) {\n    t = (bbox[3] - a[1]) / (b[1] - a[1]);\n    snap = 3;\n  } else if (edge & 4) {\n    t = (bbox[1] - a[1]) / (b[1] - a[1]);\n    snap = 1;\n  } else if (edge & 2) {\n    t = (bbox[2] - a[0]) / (b[0] - a[0]);\n    snap = 2;\n  } else if (edge & 1) {\n    t = (bbox[0] - a[0]) / (b[0] - a[0]);\n    snap = 0;\n  } else {\n    return null;\n  }\n\n  for (let i = 0; i < a.length; i++) {\n    out[i] = (snap & 1) === i ? bbox[snap] : t * (b[i] - a[i]) + a[i];\n  }\n\n  return out;\n}\nfunction bitCode(p, bbox) {\n  let code = 0;\n  if (p[0] < bbox[0]) code |= 1;else if (p[0] > bbox[2]) code |= 2;\n  if (p[1] < bbox[1]) code |= 4;else if (p[1] > bbox[3]) code |= 8;\n  return code;\n}\n//# sourceMappingURL=lineclip.js.map\n;// CONCATENATED MODULE: ./node_modules/@math.gl/polygon/dist/esm/utils.js\nfunction utils_push(target, source) {\n  const size = source.length;\n  const startIndex = target.length;\n\n  if (startIndex > 0) {\n    let isDuplicate = true;\n\n    for (let i = 0; i < size; i++) {\n      if (target[startIndex - size + i] !== source[i]) {\n        isDuplicate = false;\n        break;\n      }\n    }\n\n    if (isDuplicate) {\n      return false;\n    }\n  }\n\n  for (let i = 0; i < size; i++) {\n    target[startIndex + i] = source[i];\n  }\n\n  return true;\n}\nfunction utils_copy(target, source) {\n  const size = source.length;\n\n  for (let i = 0; i < size; i++) {\n    target[i] = source[i];\n  }\n}\nfunction utils_getPointAtIndex(positions, index, size, offset, out = []) {\n  const startI = offset + index * size;\n\n  for (let i = 0; i < size; i++) {\n    out[i] = positions[startI + i];\n  }\n\n  return out;\n}\n//# sourceMappingURL=utils.js.map\n;// CONCATENATED MODULE: ./node_modules/@math.gl/polygon/dist/esm/cut-by-grid.js\n\n\nfunction cutPolylineByGrid(positions, options) {\n  const {\n    size = 2,\n    broken = false,\n    gridResolution = 10,\n    gridOffset = [0, 0],\n    startIndex = 0,\n    endIndex = positions.length\n  } = options || {};\n  const numPoints = (endIndex - startIndex) / size;\n  let part = [];\n  const result = [part];\n  const a = utils_getPointAtIndex(positions, 0, size, startIndex);\n  let b;\n  let codeB;\n  const cell = getGridCell(a, gridResolution, gridOffset, []);\n  const scratchPoint = [];\n  utils_push(part, a);\n\n  for (let i = 1; i < numPoints; i++) {\n    b = utils_getPointAtIndex(positions, i, size, startIndex, b);\n    codeB = bitCode(b, cell);\n\n    while (codeB) {\n      intersect(a, b, codeB, cell, scratchPoint);\n      const codeAlt = bitCode(scratchPoint, cell);\n\n      if (codeAlt) {\n        intersect(a, scratchPoint, codeAlt, cell, scratchPoint);\n        codeB = codeAlt;\n      }\n\n      utils_push(part, scratchPoint);\n      utils_copy(a, scratchPoint);\n      moveToNeighborCell(cell, gridResolution, codeB);\n\n      if (broken && part.length > size) {\n        part = [];\n        result.push(part);\n        utils_push(part, a);\n      }\n\n      codeB = bitCode(b, cell);\n    }\n\n    utils_push(part, b);\n    utils_copy(a, b);\n  }\n\n  return broken ? result : result[0];\n}\nconst TYPE_INSIDE = 0;\nconst TYPE_BORDER = 1;\n\nfunction concatInPlace(arr1, arr2) {\n  for (let i = 0; i < arr2.length; i++) {\n    arr1.push(arr2[i]);\n  }\n\n  return arr1;\n}\n\nfunction cutPolygonByGrid(positions, holeIndices = null, options) {\n  if (!positions.length) {\n    return [];\n  }\n\n  const {\n    size = 2,\n    gridResolution = 10,\n    gridOffset = [0, 0],\n    edgeTypes = false\n  } = options || {};\n  const result = [];\n  const queue = [{\n    pos: positions,\n    types: edgeTypes ? new Array(positions.length / size).fill(TYPE_BORDER) : null,\n    holes: holeIndices || []\n  }];\n  const bbox = [[], []];\n  let cell = [];\n\n  while (queue.length) {\n    const {\n      pos,\n      types,\n      holes\n    } = queue.shift();\n    getBoundingBox(pos, size, holes[0] || pos.length, bbox);\n    cell = getGridCell(bbox[0], gridResolution, gridOffset, cell);\n    const code = bitCode(bbox[1], cell);\n\n    if (code) {\n      let parts = bisectPolygon(pos, types, size, 0, holes[0] || pos.length, cell, code);\n      const polygonLow = {\n        pos: parts[0].pos,\n        types: parts[0].types,\n        holes: []\n      };\n      const polygonHigh = {\n        pos: parts[1].pos,\n        types: parts[1].types,\n        holes: []\n      };\n      queue.push(polygonLow, polygonHigh);\n\n      for (let i = 0; i < holes.length; i++) {\n        parts = bisectPolygon(pos, types, size, holes[i], holes[i + 1] || pos.length, cell, code);\n\n        if (parts[0]) {\n          polygonLow.holes.push(polygonLow.pos.length);\n          polygonLow.pos = concatInPlace(polygonLow.pos, parts[0].pos);\n\n          if (edgeTypes) {\n            polygonLow.types = concatInPlace(polygonLow.types, parts[0].types);\n          }\n        }\n\n        if (parts[1]) {\n          polygonHigh.holes.push(polygonHigh.pos.length);\n          polygonHigh.pos = concatInPlace(polygonHigh.pos, parts[1].pos);\n\n          if (edgeTypes) {\n            polygonHigh.types = concatInPlace(polygonHigh.types, parts[1].types);\n          }\n        }\n      }\n    } else {\n      const polygon = {\n        positions: pos\n      };\n\n      if (edgeTypes) {\n        polygon.edgeTypes = types;\n      }\n\n      if (holes.length) {\n        polygon.holeIndices = holes;\n      }\n\n      result.push(polygon);\n    }\n  }\n\n  return result;\n}\n\nfunction bisectPolygon(positions, edgeTypes, size, startIndex, endIndex, bbox, edge) {\n  const numPoints = (endIndex - startIndex) / size;\n  const resultLow = [];\n  const resultHigh = [];\n  const typesLow = [];\n  const typesHigh = [];\n  const scratchPoint = [];\n  let p;\n  let side;\n  let type;\n  const prev = utils_getPointAtIndex(positions, numPoints - 1, size, startIndex);\n  let prevSide = Math.sign(edge & 8 ? prev[1] - bbox[3] : prev[0] - bbox[2]);\n  let prevType = edgeTypes && edgeTypes[numPoints - 1];\n  let lowPointCount = 0;\n  let highPointCount = 0;\n\n  for (let i = 0; i < numPoints; i++) {\n    p = utils_getPointAtIndex(positions, i, size, startIndex, p);\n    side = Math.sign(edge & 8 ? p[1] - bbox[3] : p[0] - bbox[2]);\n    type = edgeTypes && edgeTypes[startIndex / size + i];\n\n    if (side && prevSide && prevSide !== side) {\n      intersect(prev, p, edge, bbox, scratchPoint);\n      utils_push(resultLow, scratchPoint) && typesLow.push(prevType);\n      utils_push(resultHigh, scratchPoint) && typesHigh.push(prevType);\n    }\n\n    if (side <= 0) {\n      utils_push(resultLow, p) && typesLow.push(type);\n      lowPointCount -= side;\n    } else if (typesLow.length) {\n      typesLow[typesLow.length - 1] = TYPE_INSIDE;\n    }\n\n    if (side >= 0) {\n      utils_push(resultHigh, p) && typesHigh.push(type);\n      highPointCount += side;\n    } else if (typesHigh.length) {\n      typesHigh[typesHigh.length - 1] = TYPE_INSIDE;\n    }\n\n    utils_copy(prev, p);\n    prevSide = side;\n    prevType = type;\n  }\n\n  return [lowPointCount ? {\n    pos: resultLow,\n    types: edgeTypes && typesLow\n  } : null, highPointCount ? {\n    pos: resultHigh,\n    types: edgeTypes && typesHigh\n  } : null];\n}\n\nfunction getGridCell(p, gridResolution, gridOffset, out) {\n  const left = Math.floor((p[0] - gridOffset[0]) / gridResolution) * gridResolution + gridOffset[0];\n  const bottom = Math.floor((p[1] - gridOffset[1]) / gridResolution) * gridResolution + gridOffset[1];\n  out[0] = left;\n  out[1] = bottom;\n  out[2] = left + gridResolution;\n  out[3] = bottom + gridResolution;\n  return out;\n}\n\nfunction moveToNeighborCell(cell, gridResolution, edge) {\n  if (edge & 8) {\n    cell[1] += gridResolution;\n    cell[3] += gridResolution;\n  } else if (edge & 4) {\n    cell[1] -= gridResolution;\n    cell[3] -= gridResolution;\n  } else if (edge & 2) {\n    cell[0] += gridResolution;\n    cell[2] += gridResolution;\n  } else if (edge & 1) {\n    cell[0] -= gridResolution;\n    cell[2] -= gridResolution;\n  }\n}\n\nfunction getBoundingBox(positions, size, endIndex, out) {\n  let minX = Infinity;\n  let maxX = -Infinity;\n  let minY = Infinity;\n  let maxY = -Infinity;\n\n  for (let i = 0; i < endIndex; i += size) {\n    const x = positions[i];\n    const y = positions[i + 1];\n    minX = x < minX ? x : minX;\n    maxX = x > maxX ? x : maxX;\n    minY = y < minY ? y : minY;\n    maxY = y > maxY ? y : maxY;\n  }\n\n  out[0][0] = minX;\n  out[0][1] = minY;\n  out[1][0] = maxX;\n  out[1][1] = maxY;\n  return out;\n}\n//# sourceMappingURL=cut-by-grid.js.map\n;// CONCATENATED MODULE: ./node_modules/@math.gl/polygon/dist/esm/cut-by-mercator-bounds.js\n\n\nconst DEFAULT_MAX_LATITUDE = 85.051129;\nfunction cutPolylineByMercatorBounds(positions, options) {\n  const {\n    size = 2,\n    startIndex = 0,\n    endIndex = positions.length,\n    normalize = true\n  } = options || {};\n  const newPositions = positions.slice(startIndex, endIndex);\n  wrapLongitudesForShortestPath(newPositions, size, 0, endIndex - startIndex);\n  const parts = cutPolylineByGrid(newPositions, {\n    size,\n    broken: true,\n    gridResolution: 360,\n    gridOffset: [-180, -180]\n  });\n\n  if (normalize) {\n    for (const part of parts) {\n      shiftLongitudesIntoRange(part, size);\n    }\n  }\n\n  return parts;\n}\nfunction cutPolygonByMercatorBounds(positions, holeIndices = null, options) {\n  const {\n    size = 2,\n    normalize = true,\n    edgeTypes = false\n  } = options || {};\n  holeIndices = holeIndices || [];\n  const newPositions = [];\n  const newHoleIndices = [];\n  let srcStartIndex = 0;\n  let targetIndex = 0;\n\n  for (let ringIndex = 0; ringIndex <= holeIndices.length; ringIndex++) {\n    const srcEndIndex = holeIndices[ringIndex] || positions.length;\n    const targetStartIndex = targetIndex;\n    const splitIndex = findSplitIndex(positions, size, srcStartIndex, srcEndIndex);\n\n    for (let i = splitIndex; i < srcEndIndex; i++) {\n      newPositions[targetIndex++] = positions[i];\n    }\n\n    for (let i = srcStartIndex; i < splitIndex; i++) {\n      newPositions[targetIndex++] = positions[i];\n    }\n\n    wrapLongitudesForShortestPath(newPositions, size, targetStartIndex, targetIndex);\n    insertPoleVertices(newPositions, size, targetStartIndex, targetIndex, options === null || options === void 0 ? void 0 : options.maxLatitude);\n    srcStartIndex = srcEndIndex;\n    newHoleIndices[ringIndex] = targetIndex;\n  }\n\n  newHoleIndices.pop();\n  const parts = cutPolygonByGrid(newPositions, newHoleIndices, {\n    size,\n    gridResolution: 360,\n    gridOffset: [-180, -180],\n    edgeTypes\n  });\n\n  if (normalize) {\n    for (const part of parts) {\n      shiftLongitudesIntoRange(part.positions, size);\n    }\n  }\n\n  return parts;\n}\n\nfunction findSplitIndex(positions, size, startIndex, endIndex) {\n  let maxLat = -1;\n  let pointIndex = -1;\n\n  for (let i = startIndex + 1; i < endIndex; i += size) {\n    const lat = Math.abs(positions[i]);\n\n    if (lat > maxLat) {\n      maxLat = lat;\n      pointIndex = i - 1;\n    }\n  }\n\n  return pointIndex;\n}\n\nfunction insertPoleVertices(positions, size, startIndex, endIndex, maxLatitude = DEFAULT_MAX_LATITUDE) {\n  const firstLng = positions[startIndex];\n  const lastLng = positions[endIndex - size];\n\n  if (Math.abs(firstLng - lastLng) > 180) {\n    const p = utils_getPointAtIndex(positions, 0, size, startIndex);\n    p[0] += Math.round((lastLng - firstLng) / 360) * 360;\n    utils_push(positions, p);\n    p[1] = Math.sign(p[1]) * maxLatitude;\n    utils_push(positions, p);\n    p[0] = firstLng;\n    utils_push(positions, p);\n  }\n}\n\nfunction wrapLongitudesForShortestPath(positions, size, startIndex, endIndex) {\n  let prevLng = positions[0];\n  let lng;\n\n  for (let i = startIndex; i < endIndex; i += size) {\n    lng = positions[i];\n    const delta = lng - prevLng;\n\n    if (delta > 180 || delta < -180) {\n      lng -= Math.round(delta / 360) * 360;\n    }\n\n    positions[i] = prevLng = lng;\n  }\n}\n\nfunction shiftLongitudesIntoRange(positions, size) {\n  let refLng;\n  const pointCount = positions.length / size;\n\n  for (let i = 0; i < pointCount; i++) {\n    refLng = positions[i * size];\n\n    if ((refLng + 180) % 360 !== 0) {\n      break;\n    }\n  }\n\n  const delta = -Math.round(refLng / 360) * 360;\n\n  if (delta === 0) {\n    return;\n  }\n\n  for (let i = 0; i < pointCount; i++) {\n    positions[i * size] += delta;\n  }\n}\n//# sourceMappingURL=cut-by-mercator-bounds.js.map\n;// CONCATENATED MODULE: ./node_modules/@math.gl/polygon/dist/esm/index.js\n\n\n\n\n\n\n\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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aEorQztBQUNxRztBQUNsSDtBQUNxQjtBQUNhO0FBQytCO0FBQ25EO0FBQ2hEIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdnVlMy13ZWJwYWNrNS8uL25vZGVfbW9kdWxlcy9AbWF0aC5nbC9wb2x5Z29uL2Rpc3QvZXNtL3BvbHlnb24tdXRpbHMuanM/ODcwOCIsIndlYnBhY2s6Ly92dWUzLXdlYnBhY2s1Ly4vbm9kZV9tb2R1bGVzL0BtYXRoLmdsL3BvbHlnb24vZGlzdC9lc20vcG9seWdvbi5qcz9mOWVlIiwid2VicGFjazovL3Z1ZTMtd2VicGFjazUvLi9ub2RlX21vZHVsZXMvQG1hdGguZ2wvcG9seWdvbi9kaXN0L2VzbS9lYXJjdXQuanM/N2QwYSIsIndlYnBhY2s6Ly92dWUzLXdlYnBhY2s1Ly4vbm9kZV9tb2R1bGVzL0BtYXRoLmdsL3BvbHlnb24vZGlzdC9lc20vbGluZWNsaXAuanM/ODgyMCIsIndlYnBhY2s6Ly92dWUzLXdlYnBhY2s1Ly4vbm9kZV9tb2R1bGVzL0BtYXRoLmdsL3BvbHlnb24vZGlzdC9lc20vdXRpbHMuanM/NWJlNSIsIndlYnBhY2s6Ly92dWUzLXdlYnBhY2s1Ly4vbm9kZV9tb2R1bGVzL0BtYXRoLmdsL3BvbHlnb24vZGlzdC9lc20vY3V0LWJ5LWdyaWQuanM/YzZlMCIsIndlYnBhY2s6Ly92dWUzLXdlYnBhY2s1Ly4vbm9kZV9tb2R1bGVzL0BtYXRoLmdsL3BvbHlnb24vZGlzdC9lc20vY3V0LWJ5LW1lcmNhdG9yLWJvdW5kcy5qcz8xOGFmIiwid2VicGFjazovL3Z1ZTMtd2VicGFjazUvLi9ub2RlX21vZHVsZXMvQG1hdGguZ2wvcG9seWdvbi9kaXN0L2VzbS9pbmRleC5qcz82Yzk2Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGVxdWFscyB9IGZyb20gJ0BtYXRoLmdsL2NvcmUnO1xuZXhwb3J0IGNvbnN0IFdJTkRJTkcgPSB7XG4gIENMT0NLV0lTRTogMSxcbiAgQ09VTlRFUl9DTE9DS1dJU0U6IC0xXG59O1xuZXhwb3J0IGZ1bmN0aW9uIG1vZGlmeVBvbHlnb25XaW5kaW5nRGlyZWN0aW9uKHBvaW50cywgZGlyZWN0aW9uLCBvcHRpb25zID0ge30pIHtcbiAgY29uc3Qgd2luZGluZ0RpcmVjdGlvbiA9IGdldFBvbHlnb25XaW5kaW5nRGlyZWN0aW9uKHBvaW50cywgb3B0aW9ucyk7XG5cbiAgaWYgKHdpbmRpbmdEaXJlY3Rpb24gIT09IGRpcmVjdGlvbikge1xuICAgIHJldmVyc2VQb2x5Z29uKHBvaW50cywgb3B0aW9ucyk7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5leHBvcnQgZnVuY3Rpb24gZ2V0UG9seWdvbldpbmRpbmdEaXJlY3Rpb24ocG9pbnRzLCBvcHRpb25zID0ge30pIHtcbiAgcmV0dXJuIE1hdGguc2lnbihnZXRQb2x5Z29uU2lnbmVkQXJlYShwb2ludHMsIG9wdGlvbnMpKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBnZXRQb2x5Z29uU2lnbmVkQXJlYShwb2ludHMsIG9wdGlvbnMgPSB7fSkge1xuICBjb25zdCB7XG4gICAgc3RhcnQgPSAwLFxuICAgIGVuZCA9IHBvaW50cy5sZW5ndGhcbiAgfSA9IG9wdGlvbnM7XG4gIGNvbnN0IGRpbSA9IG9wdGlvbnMuc2l6ZSB8fCAyO1xuICBsZXQgYXJlYSA9IDA7XG5cbiAgZm9yIChsZXQgaSA9IHN0YXJ0LCBqID0gZW5kIC0gZGltOyBpIDwgZW5kOyBpICs9IGRpbSkge1xuICAgIGFyZWEgKz0gKHBvaW50c1tpXSAtIHBvaW50c1tqXSkgKiAocG9pbnRzW2kgKyAxXSArIHBvaW50c1tqICsgMV0pO1xuICAgIGogPSBpO1xuICB9XG5cbiAgcmV0dXJuIGFyZWEgLyAyO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGZvckVhY2hTZWdtZW50SW5Qb2x5Z29uKHBvaW50cywgdmlzaXRvciwgb3B0aW9ucyA9IHt9KSB7XG4gIGNvbnN0IHtcbiAgICBzdGFydCA9IDAsXG4gICAgZW5kID0gcG9pbnRzLmxlbmd0aCxcbiAgICBzaXplID0gMixcbiAgICBpc0Nsb3NlZFxuICB9ID0gb3B0aW9ucztcbiAgY29uc3QgbnVtUG9pbnRzID0gKGVuZCAtIHN0YXJ0KSAvIHNpemU7XG5cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBudW1Qb2ludHMgLSAxOyArK2kpIHtcbiAgICB2aXNpdG9yKHBvaW50c1tzdGFydCArIGkgKiBzaXplXSwgcG9pbnRzW3N0YXJ0ICsgaSAqIHNpemUgKyAxXSwgcG9pbnRzW3N0YXJ0ICsgKGkgKyAxKSAqIHNpemVdLCBwb2ludHNbc3RhcnQgKyAoaSArIDEpICogc2l6ZSArIDFdLCBpLCBpICsgMSk7XG4gIH1cblxuICBjb25zdCBlbmRQb2ludEluZGV4ID0gc3RhcnQgKyAobnVtUG9pbnRzIC0gMSkgKiBzaXplO1xuICBjb25zdCBpc0Nsb3NlZEV4ID0gaXNDbG9zZWQgfHwgZXF1YWxzKHBvaW50c1tzdGFydF0sIHBvaW50c1tlbmRQb2ludEluZGV4XSkgJiYgZXF1YWxzKHBvaW50c1tzdGFydCArIDFdLCBwb2ludHNbZW5kUG9pbnRJbmRleCArIDFdKTtcblxuICBpZiAoIWlzQ2xvc2VkRXgpIHtcbiAgICB2aXNpdG9yKHBvaW50c1tlbmRQb2ludEluZGV4XSwgcG9pbnRzW2VuZFBvaW50SW5kZXggKyAxXSwgcG9pbnRzW3N0YXJ0XSwgcG9pbnRzW3N0YXJ0ICsgMV0sIG51bVBvaW50cyAtIDEsIDApO1xuICB9XG59XG5cbmZ1bmN0aW9uIHJldmVyc2VQb2x5Z29uKHBvaW50cywgb3B0aW9ucykge1xuICBjb25zdCB7XG4gICAgc3RhcnQgPSAwLFxuICAgIGVuZCA9IHBvaW50cy5sZW5ndGgsXG4gICAgc2l6ZSA9IDJcbiAgfSA9IG9wdGlvbnM7XG4gIGNvbnN0IG51bVBvaW50cyA9IChlbmQgLSBzdGFydCkgLyBzaXplO1xuICBjb25zdCBudW1Td2FwcyA9IE1hdGguZmxvb3IobnVtUG9pbnRzIC8gMik7XG5cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBudW1Td2FwczsgKytpKSB7XG4gICAgY29uc3QgYjEgPSBzdGFydCArIGkgKiBzaXplO1xuICAgIGNvbnN0IGIyID0gc3RhcnQgKyAobnVtUG9pbnRzIC0gMSAtIGkpICogc2l6ZTtcblxuICAgIGZvciAobGV0IGogPSAwOyBqIDwgc2l6ZTsgKytqKSB7XG4gICAgICBjb25zdCB0bXAgPSBwb2ludHNbYjEgKyBqXTtcbiAgICAgIHBvaW50c1tiMSArIGpdID0gcG9pbnRzW2IyICsgal07XG4gICAgICBwb2ludHNbYjIgKyBqXSA9IHRtcDtcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIG1vZGlmeVBvbHlnb25XaW5kaW5nRGlyZWN0aW9uUG9pbnRzKHBvaW50cywgZGlyZWN0aW9uLCBvcHRpb25zID0ge30pIHtcbiAgY29uc3QgY3VycmVudERpcmVjdGlvbiA9IGdldFBvbHlnb25XaW5kaW5nRGlyZWN0aW9uUG9pbnRzKHBvaW50cywgb3B0aW9ucyk7XG5cbiAgaWYgKGN1cnJlbnREaXJlY3Rpb24gIT09IGRpcmVjdGlvbikge1xuICAgIHBvaW50cy5yZXZlcnNlKCk7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5leHBvcnQgZnVuY3Rpb24gZ2V0UG9seWdvbldpbmRpbmdEaXJlY3Rpb25Qb2ludHMocG9pbnRzLCBvcHRpb25zID0ge30pIHtcbiAgcmV0dXJuIE1hdGguc2lnbihnZXRQb2x5Z29uU2lnbmVkQXJlYVBvaW50cyhwb2ludHMsIG9wdGlvbnMpKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBnZXRQb2x5Z29uU2lnbmVkQXJlYVBvaW50cyhwb2ludHMsIG9wdGlvbnMgPSB7fSkge1xuICBjb25zdCB7XG4gICAgc3RhcnQgPSAwLFxuICAgIGVuZCA9IHBvaW50cy5sZW5ndGhcbiAgfSA9IG9wdGlvbnM7XG4gIGxldCBhcmVhID0gMDtcblxuICBmb3IgKGxldCBpID0gc3RhcnQsIGogPSBlbmQgLSAxOyBpIDwgZW5kOyArK2kpIHtcbiAgICBhcmVhICs9IChwb2ludHNbaV1bMF0gLSBwb2ludHNbal1bMF0pICogKHBvaW50c1tpXVsxXSArIHBvaW50c1tqXVsxXSk7XG4gICAgaiA9IGk7XG4gIH1cblxuICByZXR1cm4gYXJlYSAvIDI7XG59XG5leHBvcnQgZnVuY3Rpb24gZm9yRWFjaFNlZ21lbnRJblBvbHlnb25Qb2ludHMocG9pbnRzLCB2aXNpdG9yLCBvcHRpb25zID0ge30pIHtcbiAgY29uc3Qge1xuICAgIHN0YXJ0ID0gMCxcbiAgICBlbmQgPSBwb2ludHMubGVuZ3RoLFxuICAgIGlzQ2xvc2VkXG4gIH0gPSBvcHRpb25zO1xuXG4gIGZvciAobGV0IGkgPSBzdGFydDsgaSA8IGVuZCAtIDE7ICsraSkge1xuICAgIHZpc2l0b3IocG9pbnRzW2ldLCBwb2ludHNbaSArIDFdLCBpLCBpICsgMSk7XG4gIH1cblxuICBjb25zdCBpc0Nsb3NlZEV4ID0gaXNDbG9zZWQgfHwgZXF1YWxzKHBvaW50c1tlbmQgLSAxXSwgcG9pbnRzWzBdKTtcblxuICBpZiAoIWlzQ2xvc2VkRXgpIHtcbiAgICB2aXNpdG9yKHBvaW50c1tlbmQgLSAxXSwgcG9pbnRzWzBdLCBlbmQgLSAxLCAwKTtcbiAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cG9seWdvbi11dGlscy5qcy5tYXAiLCJpbXBvcnQgX2RlZmluZVByb3BlcnR5IGZyb20gXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9kZWZpbmVQcm9wZXJ0eVwiO1xuaW1wb3J0IHsgaXNBcnJheSB9IGZyb20gJ0BtYXRoLmdsL2NvcmUnO1xuaW1wb3J0IHsgZ2V0UG9seWdvblNpZ25lZEFyZWEsIGZvckVhY2hTZWdtZW50SW5Qb2x5Z29uLCBtb2RpZnlQb2x5Z29uV2luZGluZ0RpcmVjdGlvbiwgZ2V0UG9seWdvblNpZ25lZEFyZWFQb2ludHMsIGZvckVhY2hTZWdtZW50SW5Qb2x5Z29uUG9pbnRzLCBtb2RpZnlQb2x5Z29uV2luZGluZ0RpcmVjdGlvblBvaW50cyB9IGZyb20gJy4vcG9seWdvbi11dGlscyc7XG5leHBvcnQgZGVmYXVsdCBjbGFzcyBQb2x5Z29uIHtcbiAgY29uc3RydWN0b3IocG9pbnRzLCBvcHRpb25zID0ge30pIHtcbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJwb2ludHNcIiwgdm9pZCAwKTtcblxuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImlzRmxhdEFycmF5XCIsIHZvaWQgMCk7XG5cbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJvcHRpb25zXCIsIHZvaWQgMCk7XG5cbiAgICB0aGlzLnBvaW50cyA9IHBvaW50cztcbiAgICB0aGlzLmlzRmxhdEFycmF5ID0gIWlzQXJyYXkocG9pbnRzWzBdKTtcbiAgICB0aGlzLm9wdGlvbnMgPSB7XG4gICAgICBzdGFydDogb3B0aW9ucy5zdGFydCB8fCAwLFxuICAgICAgZW5kOiBvcHRpb25zLmVuZCB8fCBwb2ludHMubGVuZ3RoLFxuICAgICAgc2l6ZTogb3B0aW9ucy5zaXplIHx8IDIsXG4gICAgICBpc0Nsb3NlZDogb3B0aW9ucy5pc0Nsb3NlZFxuICAgIH07XG4gICAgT2JqZWN0LmZyZWV6ZSh0aGlzKTtcbiAgfVxuXG4gIGdldFNpZ25lZEFyZWEoKSB7XG4gICAgaWYgKHRoaXMuaXNGbGF0QXJyYXkpIHJldHVybiBnZXRQb2x5Z29uU2lnbmVkQXJlYSh0aGlzLnBvaW50cywgdGhpcy5vcHRpb25zKTtcbiAgICByZXR1cm4gZ2V0UG9seWdvblNpZ25lZEFyZWFQb2ludHModGhpcy5wb2ludHMsIHRoaXMub3B0aW9ucyk7XG4gIH1cblxuICBnZXRBcmVhKCkge1xuICAgIHJldHVybiBNYXRoLmFicyh0aGlzLmdldFNpZ25lZEFyZWEoKSk7XG4gIH1cblxuICBnZXRXaW5kaW5nRGlyZWN0aW9uKCkge1xuICAgIHJldHVybiBNYXRoLnNpZ24odGhpcy5nZXRTaWduZWRBcmVhKCkpO1xuICB9XG5cbiAgZm9yRWFjaFNlZ21lbnQodmlzaXRvcikge1xuICAgIGlmICh0aGlzLmlzRmxhdEFycmF5KSB7XG4gICAgICBmb3JFYWNoU2VnbWVudEluUG9seWdvbih0aGlzLnBvaW50cywgKHgxLCB5MSwgeDIsIHkyLCBpMSwgaTIpID0+IHtcbiAgICAgICAgdmlzaXRvcihbeDEsIHkxXSwgW3gyLCB5Ml0sIGkxLCBpMik7XG4gICAgICB9LCB0aGlzLm9wdGlvbnMpO1xuICAgIH0gZWxzZSB7XG4gICAgICBmb3JFYWNoU2VnbWVudEluUG9seWdvblBvaW50cyh0aGlzLnBvaW50cywgdmlzaXRvciwgdGhpcy5vcHRpb25zKTtcbiAgICB9XG4gIH1cblxuICBtb2RpZnlXaW5kaW5nRGlyZWN0aW9uKGRpcmVjdGlvbikge1xuICAgIGlmICh0aGlzLmlzRmxhdEFycmF5KSB7XG4gICAgICByZXR1cm4gbW9kaWZ5UG9seWdvbldpbmRpbmdEaXJlY3Rpb24odGhpcy5wb2ludHMsIGRpcmVjdGlvbiwgdGhpcy5vcHRpb25zKTtcbiAgICB9XG5cbiAgICByZXR1cm4gbW9kaWZ5UG9seWdvbldpbmRpbmdEaXJlY3Rpb25Qb2ludHModGhpcy5wb2ludHMsIGRpcmVjdGlvbiwgdGhpcy5vcHRpb25zKTtcbiAgfVxuXG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1wb2x5Z29uLmpzLm1hcCIsImltcG9ydCB7IGdldFBvbHlnb25TaWduZWRBcmVhIH0gZnJvbSAnLi9wb2x5Z29uLXV0aWxzJztcbmV4cG9ydCBmdW5jdGlvbiBlYXJjdXQocG9zaXRpb25zLCBob2xlSW5kaWNlcywgZGltID0gMiwgYXJlYXMpIHtcbiAgY29uc3QgaGFzSG9sZXMgPSBob2xlSW5kaWNlcyAmJiBob2xlSW5kaWNlcy5sZW5ndGg7XG4gIGNvbnN0IG91dGVyTGVuID0gaGFzSG9sZXMgPyBob2xlSW5kaWNlc1swXSAqIGRpbSA6IHBvc2l0aW9ucy5sZW5ndGg7XG4gIGxldCBvdXRlck5vZGUgPSBsaW5rZWRMaXN0KHBvc2l0aW9ucywgMCwgb3V0ZXJMZW4sIGRpbSwgdHJ1ZSwgYXJlYXMgJiYgYXJlYXNbMF0pO1xuICBjb25zdCB0cmlhbmdsZXMgPSBbXTtcbiAgaWYgKCFvdXRlck5vZGUgfHwgb3V0ZXJOb2RlLm5leHQgPT09IG91dGVyTm9kZS5wcmV2KSByZXR1cm4gdHJpYW5nbGVzO1xuICBsZXQgaW52U2l6ZTtcbiAgbGV0IG1heFg7XG4gIGxldCBtYXhZO1xuICBsZXQgbWluWDtcbiAgbGV0IG1pblk7XG4gIGxldCB4O1xuICBsZXQgeTtcbiAgaWYgKGhhc0hvbGVzKSBvdXRlck5vZGUgPSBlbGltaW5hdGVIb2xlcyhwb3NpdGlvbnMsIGhvbGVJbmRpY2VzLCBvdXRlck5vZGUsIGRpbSwgYXJlYXMpO1xuXG4gIGlmIChwb3NpdGlvbnMubGVuZ3RoID4gODAgKiBkaW0pIHtcbiAgICBtaW5YID0gbWF4WCA9IHBvc2l0aW9uc1swXTtcbiAgICBtaW5ZID0gbWF4WSA9IHBvc2l0aW9uc1sxXTtcblxuICAgIGZvciAobGV0IGkgPSBkaW07IGkgPCBvdXRlckxlbjsgaSArPSBkaW0pIHtcbiAgICAgIHggPSBwb3NpdGlvbnNbaV07XG4gICAgICB5ID0gcG9zaXRpb25zW2kgKyAxXTtcbiAgICAgIGlmICh4IDwgbWluWCkgbWluWCA9IHg7XG4gICAgICBpZiAoeSA8IG1pblkpIG1pblkgPSB5O1xuICAgICAgaWYgKHggPiBtYXhYKSBtYXhYID0geDtcbiAgICAgIGlmICh5ID4gbWF4WSkgbWF4WSA9IHk7XG4gICAgfVxuXG4gICAgaW52U2l6ZSA9IE1hdGgubWF4KG1heFggLSBtaW5YLCBtYXhZIC0gbWluWSk7XG4gICAgaW52U2l6ZSA9IGludlNpemUgIT09IDAgPyAxIC8gaW52U2l6ZSA6IDA7XG4gIH1cblxuICBlYXJjdXRMaW5rZWQob3V0ZXJOb2RlLCB0cmlhbmdsZXMsIGRpbSwgbWluWCwgbWluWSwgaW52U2l6ZSk7XG4gIHJldHVybiB0cmlhbmdsZXM7XG59XG5cbmZ1bmN0aW9uIGxpbmtlZExpc3QoZGF0YSwgc3RhcnQsIGVuZCwgZGltLCBjbG9ja3dpc2UsIGFyZWEpIHtcbiAgbGV0IGk7XG4gIGxldCBsYXN0O1xuXG4gIGlmIChhcmVhID09PSB1bmRlZmluZWQpIHtcbiAgICBhcmVhID0gZ2V0UG9seWdvblNpZ25lZEFyZWEoZGF0YSwge1xuICAgICAgc3RhcnQsXG4gICAgICBlbmQsXG4gICAgICBzaXplOiBkaW1cbiAgICB9KTtcbiAgfVxuXG4gIGlmIChjbG9ja3dpc2UgPT09IGFyZWEgPCAwKSB7XG4gICAgZm9yIChpID0gc3RhcnQ7IGkgPCBlbmQ7IGkgKz0gZGltKSBsYXN0ID0gaW5zZXJ0Tm9kZShpLCBkYXRhW2ldLCBkYXRhW2kgKyAxXSwgbGFzdCk7XG4gIH0gZWxzZSB7XG4gICAgZm9yIChpID0gZW5kIC0gZGltOyBpID49IHN0YXJ0OyBpIC09IGRpbSkgbGFzdCA9IGluc2VydE5vZGUoaSwgZGF0YVtpXSwgZGF0YVtpICsgMV0sIGxhc3QpO1xuICB9XG5cbiAgaWYgKGxhc3QgJiYgZXF1YWxzKGxhc3QsIGxhc3QubmV4dCkpIHtcbiAgICByZW1vdmVOb2RlKGxhc3QpO1xuICAgIGxhc3QgPSBsYXN0Lm5leHQ7XG4gIH1cblxuICByZXR1cm4gbGFzdDtcbn1cblxuZnVuY3Rpb24gZmlsdGVyUG9pbnRzKHN0YXJ0LCBlbmQpIHtcbiAgaWYgKCFzdGFydCkgcmV0dXJuIHN0YXJ0O1xuICBpZiAoIWVuZCkgZW5kID0gc3RhcnQ7XG4gIGxldCBwID0gc3RhcnQ7XG4gIGxldCBhZ2FpbjtcblxuICBkbyB7XG4gICAgYWdhaW4gPSBmYWxzZTtcblxuICAgIGlmICghcC5zdGVpbmVyICYmIChlcXVhbHMocCwgcC5uZXh0KSB8fCBhcmVhKHAucHJldiwgcCwgcC5uZXh0KSA9PT0gMCkpIHtcbiAgICAgIHJlbW92ZU5vZGUocCk7XG4gICAgICBwID0gZW5kID0gcC5wcmV2O1xuICAgICAgaWYgKHAgPT09IHAubmV4dCkgYnJlYWs7XG4gICAgICBhZ2FpbiA9IHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHAgPSBwLm5leHQ7XG4gICAgfVxuICB9IHdoaWxlIChhZ2FpbiB8fCBwICE9PSBlbmQpO1xuXG4gIHJldHVybiBlbmQ7XG59XG5cbmZ1bmN0aW9uIGVhcmN1dExpbmtlZChlYXIsIHRyaWFuZ2xlcywgZGltLCBtaW5YLCBtaW5ZLCBpbnZTaXplLCBwYXNzKSB7XG4gIGlmICghZWFyKSByZXR1cm47XG4gIGlmICghcGFzcyAmJiBpbnZTaXplKSBpbmRleEN1cnZlKGVhciwgbWluWCwgbWluWSwgaW52U2l6ZSk7XG4gIGxldCBzdG9wID0gZWFyO1xuICBsZXQgcHJldjtcbiAgbGV0IG5leHQ7XG5cbiAgd2hpbGUgKGVhci5wcmV2ICE9PSBlYXIubmV4dCkge1xuICAgIHByZXYgPSBlYXIucHJldjtcbiAgICBuZXh0ID0gZWFyLm5leHQ7XG5cbiAgICBpZiAoaW52U2l6ZSA/IGlzRWFySGFzaGVkKGVhciwgbWluWCwgbWluWSwgaW52U2l6ZSkgOiBpc0VhcihlYXIpKSB7XG4gICAgICB0cmlhbmdsZXMucHVzaChwcmV2LmkgLyBkaW0pO1xuICAgICAgdHJpYW5nbGVzLnB1c2goZWFyLmkgLyBkaW0pO1xuICAgICAgdHJpYW5nbGVzLnB1c2gobmV4dC5pIC8gZGltKTtcbiAgICAgIHJlbW92ZU5vZGUoZWFyKTtcbiAgICAgIGVhciA9IG5leHQubmV4dDtcbiAgICAgIHN0b3AgPSBuZXh0Lm5leHQ7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICBlYXIgPSBuZXh0O1xuXG4gICAgaWYgKGVhciA9PT0gc3RvcCkge1xuICAgICAgaWYgKCFwYXNzKSB7XG4gICAgICAgIGVhcmN1dExpbmtlZChmaWx0ZXJQb2ludHMoZWFyKSwgdHJpYW5nbGVzLCBkaW0sIG1pblgsIG1pblksIGludlNpemUsIDEpO1xuICAgICAgfSBlbHNlIGlmIChwYXNzID09PSAxKSB7XG4gICAgICAgIGVhciA9IGN1cmVMb2NhbEludGVyc2VjdGlvbnMoZmlsdGVyUG9pbnRzKGVhciksIHRyaWFuZ2xlcywgZGltKTtcbiAgICAgICAgZWFyY3V0TGlua2VkKGVhciwgdHJpYW5nbGVzLCBkaW0sIG1pblgsIG1pblksIGludlNpemUsIDIpO1xuICAgICAgfSBlbHNlIGlmIChwYXNzID09PSAyKSB7XG4gICAgICAgIHNwbGl0RWFyY3V0KGVhciwgdHJpYW5nbGVzLCBkaW0sIG1pblgsIG1pblksIGludlNpemUpO1xuICAgICAgfVxuXG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gaXNFYXIoZWFyKSB7XG4gIGNvbnN0IGEgPSBlYXIucHJldjtcbiAgY29uc3QgYiA9IGVhcjtcbiAgY29uc3QgYyA9IGVhci5uZXh0O1xuICBpZiAoYXJlYShhLCBiLCBjKSA+PSAwKSByZXR1cm4gZmFsc2U7XG4gIGxldCBwID0gZWFyLm5leHQubmV4dDtcblxuICB3aGlsZSAocCAhPT0gZWFyLnByZXYpIHtcbiAgICBpZiAocG9pbnRJblRyaWFuZ2xlKGEueCwgYS55LCBiLngsIGIueSwgYy54LCBjLnksIHAueCwgcC55KSAmJiBhcmVhKHAucHJldiwgcCwgcC5uZXh0KSA+PSAwKSByZXR1cm4gZmFsc2U7XG4gICAgcCA9IHAubmV4dDtcbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufVxuXG5mdW5jdGlvbiBpc0Vhckhhc2hlZChlYXIsIG1pblgsIG1pblksIGludlNpemUpIHtcbiAgY29uc3QgYSA9IGVhci5wcmV2O1xuICBjb25zdCBiID0gZWFyO1xuICBjb25zdCBjID0gZWFyLm5leHQ7XG4gIGlmIChhcmVhKGEsIGIsIGMpID49IDApIHJldHVybiBmYWxzZTtcbiAgY29uc3QgbWluVFggPSBhLnggPCBiLnggPyBhLnggPCBjLnggPyBhLnggOiBjLnggOiBiLnggPCBjLnggPyBiLnggOiBjLng7XG4gIGNvbnN0IG1pblRZID0gYS55IDwgYi55ID8gYS55IDwgYy55ID8gYS55IDogYy55IDogYi55IDwgYy55ID8gYi55IDogYy55O1xuICBjb25zdCBtYXhUWCA9IGEueCA+IGIueCA/IGEueCA+IGMueCA/IGEueCA6IGMueCA6IGIueCA+IGMueCA/IGIueCA6IGMueDtcbiAgY29uc3QgbWF4VFkgPSBhLnkgPiBiLnkgPyBhLnkgPiBjLnkgPyBhLnkgOiBjLnkgOiBiLnkgPiBjLnkgPyBiLnkgOiBjLnk7XG4gIGNvbnN0IG1pblogPSB6T3JkZXIobWluVFgsIG1pblRZLCBtaW5YLCBtaW5ZLCBpbnZTaXplKTtcbiAgY29uc3QgbWF4WiA9IHpPcmRlcihtYXhUWCwgbWF4VFksIG1pblgsIG1pblksIGludlNpemUpO1xuICBsZXQgcCA9IGVhci5wcmV2WjtcbiAgbGV0IG4gPSBlYXIubmV4dFo7XG5cbiAgd2hpbGUgKHAgJiYgcC56ID49IG1pblogJiYgbiAmJiBuLnogPD0gbWF4Wikge1xuICAgIGlmIChwICE9PSBlYXIucHJldiAmJiBwICE9PSBlYXIubmV4dCAmJiBwb2ludEluVHJpYW5nbGUoYS54LCBhLnksIGIueCwgYi55LCBjLngsIGMueSwgcC54LCBwLnkpICYmIGFyZWEocC5wcmV2LCBwLCBwLm5leHQpID49IDApIHJldHVybiBmYWxzZTtcbiAgICBwID0gcC5wcmV2WjtcbiAgICBpZiAobiAhPT0gZWFyLnByZXYgJiYgbiAhPT0gZWFyLm5leHQgJiYgcG9pbnRJblRyaWFuZ2xlKGEueCwgYS55LCBiLngsIGIueSwgYy54LCBjLnksIG4ueCwgbi55KSAmJiBhcmVhKG4ucHJldiwgbiwgbi5uZXh0KSA+PSAwKSByZXR1cm4gZmFsc2U7XG4gICAgbiA9IG4ubmV4dFo7XG4gIH1cblxuICB3aGlsZSAocCAmJiBwLnogPj0gbWluWikge1xuICAgIGlmIChwICE9PSBlYXIucHJldiAmJiBwICE9PSBlYXIubmV4dCAmJiBwb2ludEluVHJpYW5nbGUoYS54LCBhLnksIGIueCwgYi55LCBjLngsIGMueSwgcC54LCBwLnkpICYmIGFyZWEocC5wcmV2LCBwLCBwLm5leHQpID49IDApIHJldHVybiBmYWxzZTtcbiAgICBwID0gcC5wcmV2WjtcbiAgfVxuXG4gIHdoaWxlIChuICYmIG4ueiA8PSBtYXhaKSB7XG4gICAgaWYgKG4gIT09IGVhci5wcmV2ICYmIG4gIT09IGVhci5uZXh0ICYmIHBvaW50SW5UcmlhbmdsZShhLngsIGEueSwgYi54LCBiLnksIGMueCwgYy55LCBuLngsIG4ueSkgJiYgYXJlYShuLnByZXYsIG4sIG4ubmV4dCkgPj0gMCkgcmV0dXJuIGZhbHNlO1xuICAgIG4gPSBuLm5leHRaO1xuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59XG5cbmZ1bmN0aW9uIGN1cmVMb2NhbEludGVyc2VjdGlvbnMoc3RhcnQsIHRyaWFuZ2xlcywgZGltKSB7XG4gIGxldCBwID0gc3RhcnQ7XG5cbiAgZG8ge1xuICAgIGNvbnN0IGEgPSBwLnByZXY7XG4gICAgY29uc3QgYiA9IHAubmV4dC5uZXh0O1xuXG4gICAgaWYgKCFlcXVhbHMoYSwgYikgJiYgaW50ZXJzZWN0cyhhLCBwLCBwLm5leHQsIGIpICYmIGxvY2FsbHlJbnNpZGUoYSwgYikgJiYgbG9jYWxseUluc2lkZShiLCBhKSkge1xuICAgICAgdHJpYW5nbGVzLnB1c2goYS5pIC8gZGltKTtcbiAgICAgIHRyaWFuZ2xlcy5wdXNoKHAuaSAvIGRpbSk7XG4gICAgICB0cmlhbmdsZXMucHVzaChiLmkgLyBkaW0pO1xuICAgICAgcmVtb3ZlTm9kZShwKTtcbiAgICAgIHJlbW92ZU5vZGUocC5uZXh0KTtcbiAgICAgIHAgPSBzdGFydCA9IGI7XG4gICAgfVxuXG4gICAgcCA9IHAubmV4dDtcbiAgfSB3aGlsZSAocCAhPT0gc3RhcnQpO1xuXG4gIHJldHVybiBmaWx0ZXJQb2ludHMocCk7XG59XG5cbmZ1bmN0aW9uIHNwbGl0RWFyY3V0KHN0YXJ0LCB0cmlhbmdsZXMsIGRpbSwgbWluWCwgbWluWSwgaW52U2l6ZSkge1xuICBsZXQgYSA9IHN0YXJ0O1xuXG4gIGRvIHtcbiAgICBsZXQgYiA9IGEubmV4dC5uZXh0O1xuXG4gICAgd2hpbGUgKGIgIT09IGEucHJldikge1xuICAgICAgaWYgKGEuaSAhPT0gYi5pICYmIGlzVmFsaWREaWFnb25hbChhLCBiKSkge1xuICAgICAgICBsZXQgYyA9IHNwbGl0UG9seWdvbihhLCBiKTtcbiAgICAgICAgYSA9IGZpbHRlclBvaW50cyhhLCBhLm5leHQpO1xuICAgICAgICBjID0gZmlsdGVyUG9pbnRzKGMsIGMubmV4dCk7XG4gICAgICAgIGVhcmN1dExpbmtlZChhLCB0cmlhbmdsZXMsIGRpbSwgbWluWCwgbWluWSwgaW52U2l6ZSk7XG4gICAgICAgIGVhcmN1dExpbmtlZChjLCB0cmlhbmdsZXMsIGRpbSwgbWluWCwgbWluWSwgaW52U2l6ZSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgYiA9IGIubmV4dDtcbiAgICB9XG5cbiAgICBhID0gYS5uZXh0O1xuICB9IHdoaWxlIChhICE9PSBzdGFydCk7XG59XG5cbmZ1bmN0aW9uIGVsaW1pbmF0ZUhvbGVzKGRhdGEsIGhvbGVJbmRpY2VzLCBvdXRlck5vZGUsIGRpbSwgYXJlYXMpIHtcbiAgY29uc3QgcXVldWUgPSBbXTtcbiAgbGV0IGk7XG4gIGxldCBsZW47XG4gIGxldCBzdGFydDtcbiAgbGV0IGVuZDtcbiAgbGV0IGxpc3Q7XG5cbiAgZm9yIChpID0gMCwgbGVuID0gaG9sZUluZGljZXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICBzdGFydCA9IGhvbGVJbmRpY2VzW2ldICogZGltO1xuICAgIGVuZCA9IGkgPCBsZW4gLSAxID8gaG9sZUluZGljZXNbaSArIDFdICogZGltIDogZGF0YS5sZW5ndGg7XG4gICAgbGlzdCA9IGxpbmtlZExpc3QoZGF0YSwgc3RhcnQsIGVuZCwgZGltLCBmYWxzZSwgYXJlYXMgJiYgYXJlYXNbaSArIDFdKTtcbiAgICBpZiAobGlzdCA9PT0gbGlzdC5uZXh0KSBsaXN0LnN0ZWluZXIgPSB0cnVlO1xuICAgIHF1ZXVlLnB1c2goZ2V0TGVmdG1vc3QobGlzdCkpO1xuICB9XG5cbiAgcXVldWUuc29ydChjb21wYXJlWCk7XG5cbiAgZm9yIChpID0gMDsgaSA8IHF1ZXVlLmxlbmd0aDsgaSsrKSB7XG4gICAgZWxpbWluYXRlSG9sZShxdWV1ZVtpXSwgb3V0ZXJOb2RlKTtcbiAgICBvdXRlck5vZGUgPSBmaWx0ZXJQb2ludHMob3V0ZXJOb2RlLCBvdXRlck5vZGUubmV4dCk7XG4gIH1cblxuICByZXR1cm4gb3V0ZXJOb2RlO1xufVxuXG5mdW5jdGlvbiBjb21wYXJlWChhLCBiKSB7XG4gIHJldHVybiBhLnggLSBiLng7XG59XG5cbmZ1bmN0aW9uIGVsaW1pbmF0ZUhvbGUoaG9sZSwgb3V0ZXJOb2RlKSB7XG4gIG91dGVyTm9kZSA9IGZpbmRIb2xlQnJpZGdlKGhvbGUsIG91dGVyTm9kZSk7XG5cbiAgaWYgKG91dGVyTm9kZSkge1xuICAgIGNvbnN0IGIgPSBzcGxpdFBvbHlnb24ob3V0ZXJOb2RlLCBob2xlKTtcbiAgICBmaWx0ZXJQb2ludHMob3V0ZXJOb2RlLCBvdXRlck5vZGUubmV4dCk7XG4gICAgZmlsdGVyUG9pbnRzKGIsIGIubmV4dCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gZmluZEhvbGVCcmlkZ2UoaG9sZSwgb3V0ZXJOb2RlKSB7XG4gIGxldCBwID0gb3V0ZXJOb2RlO1xuICBjb25zdCBoeCA9IGhvbGUueDtcbiAgY29uc3QgaHkgPSBob2xlLnk7XG4gIGxldCBxeCA9IC1JbmZpbml0eTtcbiAgbGV0IG07XG5cbiAgZG8ge1xuICAgIGlmIChoeSA8PSBwLnkgJiYgaHkgPj0gcC5uZXh0LnkgJiYgcC5uZXh0LnkgIT09IHAueSkge1xuICAgICAgY29uc3QgeCA9IHAueCArIChoeSAtIHAueSkgKiAocC5uZXh0LnggLSBwLngpIC8gKHAubmV4dC55IC0gcC55KTtcblxuICAgICAgaWYgKHggPD0gaHggJiYgeCA+IHF4KSB7XG4gICAgICAgIHF4ID0geDtcblxuICAgICAgICBpZiAoeCA9PT0gaHgpIHtcbiAgICAgICAgICBpZiAoaHkgPT09IHAueSkgcmV0dXJuIHA7XG4gICAgICAgICAgaWYgKGh5ID09PSBwLm5leHQueSkgcmV0dXJuIHAubmV4dDtcbiAgICAgICAgfVxuXG4gICAgICAgIG0gPSBwLnggPCBwLm5leHQueCA/IHAgOiBwLm5leHQ7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcCA9IHAubmV4dDtcbiAgfSB3aGlsZSAocCAhPT0gb3V0ZXJOb2RlKTtcblxuICBpZiAoIW0pIHJldHVybiBudWxsO1xuICBpZiAoaHggPT09IHF4KSByZXR1cm4gbTtcbiAgY29uc3Qgc3RvcCA9IG07XG4gIGNvbnN0IG14ID0gbS54O1xuICBjb25zdCBteSA9IG0ueTtcbiAgbGV0IHRhbk1pbiA9IEluZmluaXR5O1xuICBsZXQgdGFuO1xuICBwID0gbTtcblxuICBkbyB7XG4gICAgaWYgKGh4ID49IHAueCAmJiBwLnggPj0gbXggJiYgaHggIT09IHAueCAmJiBwb2ludEluVHJpYW5nbGUoaHkgPCBteSA/IGh4IDogcXgsIGh5LCBteCwgbXksIGh5IDwgbXkgPyBxeCA6IGh4LCBoeSwgcC54LCBwLnkpKSB7XG4gICAgICB0YW4gPSBNYXRoLmFicyhoeSAtIHAueSkgLyAoaHggLSBwLngpO1xuXG4gICAgICBpZiAobG9jYWxseUluc2lkZShwLCBob2xlKSAmJiAodGFuIDwgdGFuTWluIHx8IHRhbiA9PT0gdGFuTWluICYmIChwLnggPiBtLnggfHwgcC54ID09PSBtLnggJiYgc2VjdG9yQ29udGFpbnNTZWN0b3IobSwgcCkpKSkge1xuICAgICAgICBtID0gcDtcbiAgICAgICAgdGFuTWluID0gdGFuO1xuICAgICAgfVxuICAgIH1cblxuICAgIHAgPSBwLm5leHQ7XG4gIH0gd2hpbGUgKHAgIT09IHN0b3ApO1xuXG4gIHJldHVybiBtO1xufVxuXG5mdW5jdGlvbiBzZWN0b3JDb250YWluc1NlY3RvcihtLCBwKSB7XG4gIHJldHVybiBhcmVhKG0ucHJldiwgbSwgcC5wcmV2KSA8IDAgJiYgYXJlYShwLm5leHQsIG0sIG0ubmV4dCkgPCAwO1xufVxuXG5mdW5jdGlvbiBpbmRleEN1cnZlKHN0YXJ0LCBtaW5YLCBtaW5ZLCBpbnZTaXplKSB7XG4gIGxldCBwID0gc3RhcnQ7XG5cbiAgZG8ge1xuICAgIGlmIChwLnogPT09IG51bGwpIHAueiA9IHpPcmRlcihwLngsIHAueSwgbWluWCwgbWluWSwgaW52U2l6ZSk7XG4gICAgcC5wcmV2WiA9IHAucHJldjtcbiAgICBwLm5leHRaID0gcC5uZXh0O1xuICAgIHAgPSBwLm5leHQ7XG4gIH0gd2hpbGUgKHAgIT09IHN0YXJ0KTtcblxuICBwLnByZXZaLm5leHRaID0gbnVsbDtcbiAgcC5wcmV2WiA9IG51bGw7XG4gIHNvcnRMaW5rZWQocCk7XG59XG5cbmZ1bmN0aW9uIHNvcnRMaW5rZWQobGlzdCkge1xuICBsZXQgZTtcbiAgbGV0IGk7XG4gIGxldCBpblNpemUgPSAxO1xuICBsZXQgbnVtTWVyZ2VzO1xuICBsZXQgcDtcbiAgbGV0IHBTaXplO1xuICBsZXQgcTtcbiAgbGV0IHFTaXplO1xuICBsZXQgdGFpbDtcblxuICBkbyB7XG4gICAgcCA9IGxpc3Q7XG4gICAgbGlzdCA9IG51bGw7XG4gICAgdGFpbCA9IG51bGw7XG4gICAgbnVtTWVyZ2VzID0gMDtcblxuICAgIHdoaWxlIChwKSB7XG4gICAgICBudW1NZXJnZXMrKztcbiAgICAgIHEgPSBwO1xuICAgICAgcFNpemUgPSAwO1xuXG4gICAgICBmb3IgKGkgPSAwOyBpIDwgaW5TaXplOyBpKyspIHtcbiAgICAgICAgcFNpemUrKztcbiAgICAgICAgcSA9IHEubmV4dFo7XG4gICAgICAgIGlmICghcSkgYnJlYWs7XG4gICAgICB9XG5cbiAgICAgIHFTaXplID0gaW5TaXplO1xuXG4gICAgICB3aGlsZSAocFNpemUgPiAwIHx8IHFTaXplID4gMCAmJiBxKSB7XG4gICAgICAgIGlmIChwU2l6ZSAhPT0gMCAmJiAocVNpemUgPT09IDAgfHwgIXEgfHwgcC56IDw9IHEueikpIHtcbiAgICAgICAgICBlID0gcDtcbiAgICAgICAgICBwID0gcC5uZXh0WjtcbiAgICAgICAgICBwU2l6ZS0tO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGUgPSBxO1xuICAgICAgICAgIHEgPSBxLm5leHRaO1xuICAgICAgICAgIHFTaXplLS07XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGFpbCkgdGFpbC5uZXh0WiA9IGU7ZWxzZSBsaXN0ID0gZTtcbiAgICAgICAgZS5wcmV2WiA9IHRhaWw7XG4gICAgICAgIHRhaWwgPSBlO1xuICAgICAgfVxuXG4gICAgICBwID0gcTtcbiAgICB9XG5cbiAgICB0YWlsLm5leHRaID0gbnVsbDtcbiAgICBpblNpemUgKj0gMjtcbiAgfSB3aGlsZSAobnVtTWVyZ2VzID4gMSk7XG5cbiAgcmV0dXJuIGxpc3Q7XG59XG5cbmZ1bmN0aW9uIHpPcmRlcih4LCB5LCBtaW5YLCBtaW5ZLCBpbnZTaXplKSB7XG4gIHggPSAzMjc2NyAqICh4IC0gbWluWCkgKiBpbnZTaXplO1xuICB5ID0gMzI3NjcgKiAoeSAtIG1pblkpICogaW52U2l6ZTtcbiAgeCA9ICh4IHwgeCA8PCA4KSAmIDB4MDBmZjAwZmY7XG4gIHggPSAoeCB8IHggPDwgNCkgJiAweDBmMGYwZjBmO1xuICB4ID0gKHggfCB4IDw8IDIpICYgMHgzMzMzMzMzMztcbiAgeCA9ICh4IHwgeCA8PCAxKSAmIDB4NTU1NTU1NTU7XG4gIHkgPSAoeSB8IHkgPDwgOCkgJiAweDAwZmYwMGZmO1xuICB5ID0gKHkgfCB5IDw8IDQpICYgMHgwZjBmMGYwZjtcbiAgeSA9ICh5IHwgeSA8PCAyKSAmIDB4MzMzMzMzMzM7XG4gIHkgPSAoeSB8IHkgPDwgMSkgJiAweDU1NTU1NTU1O1xuICByZXR1cm4geCB8IHkgPDwgMTtcbn1cblxuZnVuY3Rpb24gZ2V0TGVmdG1vc3Qoc3RhcnQpIHtcbiAgbGV0IHAgPSBzdGFydDtcbiAgbGV0IGxlZnRtb3N0ID0gc3RhcnQ7XG5cbiAgZG8ge1xuICAgIGlmIChwLnggPCBsZWZ0bW9zdC54IHx8IHAueCA9PT0gbGVmdG1vc3QueCAmJiBwLnkgPCBsZWZ0bW9zdC55KSBsZWZ0bW9zdCA9IHA7XG4gICAgcCA9IHAubmV4dDtcbiAgfSB3aGlsZSAocCAhPT0gc3RhcnQpO1xuXG4gIHJldHVybiBsZWZ0bW9zdDtcbn1cblxuZnVuY3Rpb24gcG9pbnRJblRyaWFuZ2xlKGF4LCBheSwgYngsIGJ5LCBjeCwgY3ksIHB4LCBweSkge1xuICByZXR1cm4gKGN4IC0gcHgpICogKGF5IC0gcHkpIC0gKGF4IC0gcHgpICogKGN5IC0gcHkpID49IDAgJiYgKGF4IC0gcHgpICogKGJ5IC0gcHkpIC0gKGJ4IC0gcHgpICogKGF5IC0gcHkpID49IDAgJiYgKGJ4IC0gcHgpICogKGN5IC0gcHkpIC0gKGN4IC0gcHgpICogKGJ5IC0gcHkpID49IDA7XG59XG5cbmZ1bmN0aW9uIGlzVmFsaWREaWFnb25hbChhLCBiKSB7XG4gIHJldHVybiBhLm5leHQuaSAhPT0gYi5pICYmIGEucHJldi5pICE9PSBiLmkgJiYgIWludGVyc2VjdHNQb2x5Z29uKGEsIGIpICYmIChsb2NhbGx5SW5zaWRlKGEsIGIpICYmIGxvY2FsbHlJbnNpZGUoYiwgYSkgJiYgbWlkZGxlSW5zaWRlKGEsIGIpICYmIChhcmVhKGEucHJldiwgYSwgYi5wcmV2KSB8fCBhcmVhKGEsIGIucHJldiwgYikpIHx8IGVxdWFscyhhLCBiKSAmJiBhcmVhKGEucHJldiwgYSwgYS5uZXh0KSA+IDAgJiYgYXJlYShiLnByZXYsIGIsIGIubmV4dCkgPiAwKTtcbn1cblxuZnVuY3Rpb24gYXJlYShwLCBxLCByKSB7XG4gIHJldHVybiAocS55IC0gcC55KSAqIChyLnggLSBxLngpIC0gKHEueCAtIHAueCkgKiAoci55IC0gcS55KTtcbn1cblxuZnVuY3Rpb24gZXF1YWxzKHAxLCBwMikge1xuICByZXR1cm4gcDEueCA9PT0gcDIueCAmJiBwMS55ID09PSBwMi55O1xufVxuXG5mdW5jdGlvbiBpbnRlcnNlY3RzKHAxLCBxMSwgcDIsIHEyKSB7XG4gIGNvbnN0IG8xID0gc2lnbihhcmVhKHAxLCBxMSwgcDIpKTtcbiAgY29uc3QgbzIgPSBzaWduKGFyZWEocDEsIHExLCBxMikpO1xuICBjb25zdCBvMyA9IHNpZ24oYXJlYShwMiwgcTIsIHAxKSk7XG4gIGNvbnN0IG80ID0gc2lnbihhcmVhKHAyLCBxMiwgcTEpKTtcbiAgaWYgKG8xICE9PSBvMiAmJiBvMyAhPT0gbzQpIHJldHVybiB0cnVlO1xuICBpZiAobzEgPT09IDAgJiYgb25TZWdtZW50KHAxLCBwMiwgcTEpKSByZXR1cm4gdHJ1ZTtcbiAgaWYgKG8yID09PSAwICYmIG9uU2VnbWVudChwMSwgcTIsIHExKSkgcmV0dXJuIHRydWU7XG4gIGlmIChvMyA9PT0gMCAmJiBvblNlZ21lbnQocDIsIHAxLCBxMikpIHJldHVybiB0cnVlO1xuICBpZiAobzQgPT09IDAgJiYgb25TZWdtZW50KHAyLCBxMSwgcTIpKSByZXR1cm4gdHJ1ZTtcbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBvblNlZ21lbnQocCwgcSwgcikge1xuICByZXR1cm4gcS54IDw9IE1hdGgubWF4KHAueCwgci54KSAmJiBxLnggPj0gTWF0aC5taW4ocC54LCByLngpICYmIHEueSA8PSBNYXRoLm1heChwLnksIHIueSkgJiYgcS55ID49IE1hdGgubWluKHAueSwgci55KTtcbn1cblxuZnVuY3Rpb24gc2lnbihudW0pIHtcbiAgcmV0dXJuIG51bSA+IDAgPyAxIDogbnVtIDwgMCA/IC0xIDogMDtcbn1cblxuZnVuY3Rpb24gaW50ZXJzZWN0c1BvbHlnb24oYSwgYikge1xuICBsZXQgcCA9IGE7XG5cbiAgZG8ge1xuICAgIGlmIChwLmkgIT09IGEuaSAmJiBwLm5leHQuaSAhPT0gYS5pICYmIHAuaSAhPT0gYi5pICYmIHAubmV4dC5pICE9PSBiLmkgJiYgaW50ZXJzZWN0cyhwLCBwLm5leHQsIGEsIGIpKSByZXR1cm4gdHJ1ZTtcbiAgICBwID0gcC5uZXh0O1xuICB9IHdoaWxlIChwICE9PSBhKTtcblxuICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGxvY2FsbHlJbnNpZGUoYSwgYikge1xuICByZXR1cm4gYXJlYShhLnByZXYsIGEsIGEubmV4dCkgPCAwID8gYXJlYShhLCBiLCBhLm5leHQpID49IDAgJiYgYXJlYShhLCBhLnByZXYsIGIpID49IDAgOiBhcmVhKGEsIGIsIGEucHJldikgPCAwIHx8IGFyZWEoYSwgYS5uZXh0LCBiKSA8IDA7XG59XG5cbmZ1bmN0aW9uIG1pZGRsZUluc2lkZShhLCBiKSB7XG4gIGxldCBwID0gYTtcbiAgbGV0IGluc2lkZSA9IGZhbHNlO1xuICBjb25zdCBweCA9IChhLnggKyBiLngpIC8gMjtcbiAgY29uc3QgcHkgPSAoYS55ICsgYi55KSAvIDI7XG5cbiAgZG8ge1xuICAgIGlmIChwLnkgPiBweSAhPT0gcC5uZXh0LnkgPiBweSAmJiBwLm5leHQueSAhPT0gcC55ICYmIHB4IDwgKHAubmV4dC54IC0gcC54KSAqIChweSAtIHAueSkgLyAocC5uZXh0LnkgLSBwLnkpICsgcC54KSBpbnNpZGUgPSAhaW5zaWRlO1xuICAgIHAgPSBwLm5leHQ7XG4gIH0gd2hpbGUgKHAgIT09IGEpO1xuXG4gIHJldHVybiBpbnNpZGU7XG59XG5cbmZ1bmN0aW9uIHNwbGl0UG9seWdvbihhLCBiKSB7XG4gIGNvbnN0IGEyID0gbmV3IE5vZGUoYS5pLCBhLngsIGEueSk7XG4gIGNvbnN0IGIyID0gbmV3IE5vZGUoYi5pLCBiLngsIGIueSk7XG4gIGNvbnN0IGFuID0gYS5uZXh0O1xuICBjb25zdCBicCA9IGIucHJldjtcbiAgYS5uZXh0ID0gYjtcbiAgYi5wcmV2ID0gYTtcbiAgYTIubmV4dCA9IGFuO1xuICBhbi5wcmV2ID0gYTI7XG4gIGIyLm5leHQgPSBhMjtcbiAgYTIucHJldiA9IGIyO1xuICBicC5uZXh0ID0gYjI7XG4gIGIyLnByZXYgPSBicDtcbiAgcmV0dXJuIGIyO1xufVxuXG5mdW5jdGlvbiBpbnNlcnROb2RlKGksIHgsIHksIGxhc3QpIHtcbiAgY29uc3QgcCA9IG5ldyBOb2RlKGksIHgsIHkpO1xuXG4gIGlmICghbGFzdCkge1xuICAgIHAucHJldiA9IHA7XG4gICAgcC5uZXh0ID0gcDtcbiAgfSBlbHNlIHtcbiAgICBwLm5leHQgPSBsYXN0Lm5leHQ7XG4gICAgcC5wcmV2ID0gbGFzdDtcbiAgICBsYXN0Lm5leHQucHJldiA9IHA7XG4gICAgbGFzdC5uZXh0ID0gcDtcbiAgfVxuXG4gIHJldHVybiBwO1xufVxuXG5mdW5jdGlvbiByZW1vdmVOb2RlKHApIHtcbiAgcC5uZXh0LnByZXYgPSBwLnByZXY7XG4gIHAucHJldi5uZXh0ID0gcC5uZXh0O1xuICBpZiAocC5wcmV2WikgcC5wcmV2Wi5uZXh0WiA9IHAubmV4dFo7XG4gIGlmIChwLm5leHRaKSBwLm5leHRaLnByZXZaID0gcC5wcmV2Wjtcbn1cblxuZnVuY3Rpb24gTm9kZShpLCB4LCB5KSB7XG4gIHRoaXMuaSA9IGk7XG4gIHRoaXMueCA9IHg7XG4gIHRoaXMueSA9IHk7XG4gIHRoaXMucHJldiA9IG51bGw7XG4gIHRoaXMubmV4dCA9IG51bGw7XG4gIHRoaXMueiA9IG51bGw7XG4gIHRoaXMucHJldlogPSBudWxsO1xuICB0aGlzLm5leHRaID0gbnVsbDtcbiAgdGhpcy5zdGVpbmVyID0gZmFsc2U7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1lYXJjdXQuanMubWFwIiwiaW1wb3J0IHsgcHVzaCwgY29weSwgZ2V0UG9pbnRBdEluZGV4IH0gZnJvbSAnLi91dGlscyc7XG5leHBvcnQgZnVuY3Rpb24gY2xpcFBvbHlsaW5lKHBvc2l0aW9ucywgYmJveCwgb3B0aW9ucykge1xuICBjb25zdCB7XG4gICAgc2l6ZSA9IDIsXG4gICAgc3RhcnRJbmRleCA9IDAsXG4gICAgZW5kSW5kZXggPSBwb3NpdGlvbnMubGVuZ3RoXG4gIH0gPSBvcHRpb25zIHx8IHt9O1xuICBjb25zdCBudW1Qb2ludHMgPSAoZW5kSW5kZXggLSBzdGFydEluZGV4KSAvIHNpemU7XG4gIGNvbnN0IHJlc3VsdCA9IFtdO1xuICBsZXQgcGFydCA9IFtdO1xuICBsZXQgYTtcbiAgbGV0IGI7XG4gIGxldCBjb2RlQSA9IC0xO1xuICBsZXQgY29kZUI7XG4gIGxldCBsYXN0Q29kZTtcblxuICBmb3IgKGxldCBpID0gMTsgaSA8IG51bVBvaW50czsgaSsrKSB7XG4gICAgYSA9IGdldFBvaW50QXRJbmRleChwb3NpdGlvbnMsIGkgLSAxLCBzaXplLCBzdGFydEluZGV4LCBhKTtcbiAgICBiID0gZ2V0UG9pbnRBdEluZGV4KHBvc2l0aW9ucywgaSwgc2l6ZSwgc3RhcnRJbmRleCwgYik7XG5cbiAgICBpZiAoY29kZUEgPCAwKSB7XG4gICAgICBjb2RlQSA9IGJpdENvZGUoYSwgYmJveCk7XG4gICAgfVxuXG4gICAgY29kZUIgPSBsYXN0Q29kZSA9IGJpdENvZGUoYiwgYmJveCk7XG5cbiAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgaWYgKCEoY29kZUEgfCBjb2RlQikpIHtcbiAgICAgICAgcHVzaChwYXJ0LCBhKTtcblxuICAgICAgICBpZiAoY29kZUIgIT09IGxhc3RDb2RlKSB7XG4gICAgICAgICAgcHVzaChwYXJ0LCBiKTtcblxuICAgICAgICAgIGlmIChpIDwgbnVtUG9pbnRzIC0gMSkge1xuICAgICAgICAgICAgcmVzdWx0LnB1c2gocGFydCk7XG4gICAgICAgICAgICBwYXJ0ID0gW107XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKGkgPT09IG51bVBvaW50cyAtIDEpIHtcbiAgICAgICAgICBwdXNoKHBhcnQsIGIpO1xuICAgICAgICB9XG5cbiAgICAgICAgYnJlYWs7XG4gICAgICB9IGVsc2UgaWYgKGNvZGVBICYgY29kZUIpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9IGVsc2UgaWYgKGNvZGVBKSB7XG4gICAgICAgIGludGVyc2VjdChhLCBiLCBjb2RlQSwgYmJveCwgYSk7XG4gICAgICAgIGNvZGVBID0gYml0Q29kZShhLCBiYm94KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGludGVyc2VjdChhLCBiLCBjb2RlQiwgYmJveCwgYik7XG4gICAgICAgIGNvZGVCID0gYml0Q29kZShiLCBiYm94KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBjb2RlQSA9IGxhc3RDb2RlO1xuICB9XG5cbiAgaWYgKHBhcnQubGVuZ3RoKSByZXN1bHQucHVzaChwYXJ0KTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cbmV4cG9ydCBmdW5jdGlvbiBjbGlwUG9seWdvbihwb3NpdGlvbnMsIGJib3gsIG9wdGlvbnMpIHtcbiAgY29uc3Qge1xuICAgIHNpemUgPSAyLFxuICAgIGVuZEluZGV4ID0gcG9zaXRpb25zLmxlbmd0aFxuICB9ID0gb3B0aW9ucyB8fCB7fTtcbiAgbGV0IHtcbiAgICBzdGFydEluZGV4ID0gMFxuICB9ID0gb3B0aW9ucyB8fCB7fTtcbiAgbGV0IG51bVBvaW50cyA9IChlbmRJbmRleCAtIHN0YXJ0SW5kZXgpIC8gc2l6ZTtcbiAgbGV0IHJlc3VsdDtcbiAgbGV0IHA7XG4gIGxldCBwcmV2O1xuICBsZXQgaW5zaWRlO1xuICBsZXQgcHJldkluc2lkZTtcblxuICBmb3IgKGxldCBlZGdlID0gMTsgZWRnZSA8PSA4OyBlZGdlICo9IDIpIHtcbiAgICByZXN1bHQgPSBbXTtcbiAgICBwcmV2ID0gZ2V0UG9pbnRBdEluZGV4KHBvc2l0aW9ucywgbnVtUG9pbnRzIC0gMSwgc2l6ZSwgc3RhcnRJbmRleCwgcHJldik7XG4gICAgcHJldkluc2lkZSA9ICEoYml0Q29kZShwcmV2LCBiYm94KSAmIGVkZ2UpO1xuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBudW1Qb2ludHM7IGkrKykge1xuICAgICAgcCA9IGdldFBvaW50QXRJbmRleChwb3NpdGlvbnMsIGksIHNpemUsIHN0YXJ0SW5kZXgsIHApO1xuICAgICAgaW5zaWRlID0gIShiaXRDb2RlKHAsIGJib3gpICYgZWRnZSk7XG4gICAgICBpZiAoaW5zaWRlICE9PSBwcmV2SW5zaWRlKSBwdXNoKHJlc3VsdCwgaW50ZXJzZWN0KHByZXYsIHAsIGVkZ2UsIGJib3gpKTtcbiAgICAgIGlmIChpbnNpZGUpIHB1c2gocmVzdWx0LCBwKTtcbiAgICAgIGNvcHkocHJldiwgcCk7XG4gICAgICBwcmV2SW5zaWRlID0gaW5zaWRlO1xuICAgIH1cblxuICAgIHBvc2l0aW9ucyA9IHJlc3VsdDtcbiAgICBzdGFydEluZGV4ID0gMDtcbiAgICBudW1Qb2ludHMgPSByZXN1bHQubGVuZ3RoIC8gc2l6ZTtcbiAgICBpZiAoIW51bVBvaW50cykgYnJlYWs7XG4gIH1cblxuICByZXR1cm4gcmVzdWx0O1xufVxuZXhwb3J0IGZ1bmN0aW9uIGludGVyc2VjdChhLCBiLCBlZGdlLCBiYm94LCBvdXQgPSBbXSkge1xuICBsZXQgdDtcbiAgbGV0IHNuYXA7XG5cbiAgaWYgKGVkZ2UgJiA4KSB7XG4gICAgdCA9IChiYm94WzNdIC0gYVsxXSkgLyAoYlsxXSAtIGFbMV0pO1xuICAgIHNuYXAgPSAzO1xuICB9IGVsc2UgaWYgKGVkZ2UgJiA0KSB7XG4gICAgdCA9IChiYm94WzFdIC0gYVsxXSkgLyAoYlsxXSAtIGFbMV0pO1xuICAgIHNuYXAgPSAxO1xuICB9IGVsc2UgaWYgKGVkZ2UgJiAyKSB7XG4gICAgdCA9IChiYm94WzJdIC0gYVswXSkgLyAoYlswXSAtIGFbMF0pO1xuICAgIHNuYXAgPSAyO1xuICB9IGVsc2UgaWYgKGVkZ2UgJiAxKSB7XG4gICAgdCA9IChiYm94WzBdIC0gYVswXSkgLyAoYlswXSAtIGFbMF0pO1xuICAgIHNuYXAgPSAwO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBhLmxlbmd0aDsgaSsrKSB7XG4gICAgb3V0W2ldID0gKHNuYXAgJiAxKSA9PT0gaSA/IGJib3hbc25hcF0gOiB0ICogKGJbaV0gLSBhW2ldKSArIGFbaV07XG4gIH1cblxuICByZXR1cm4gb3V0O1xufVxuZXhwb3J0IGZ1bmN0aW9uIGJpdENvZGUocCwgYmJveCkge1xuICBsZXQgY29kZSA9IDA7XG4gIGlmIChwWzBdIDwgYmJveFswXSkgY29kZSB8PSAxO2Vsc2UgaWYgKHBbMF0gPiBiYm94WzJdKSBjb2RlIHw9IDI7XG4gIGlmIChwWzFdIDwgYmJveFsxXSkgY29kZSB8PSA0O2Vsc2UgaWYgKHBbMV0gPiBiYm94WzNdKSBjb2RlIHw9IDg7XG4gIHJldHVybiBjb2RlO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bGluZWNsaXAuanMubWFwIiwiZXhwb3J0IGZ1bmN0aW9uIHB1c2godGFyZ2V0LCBzb3VyY2UpIHtcbiAgY29uc3Qgc2l6ZSA9IHNvdXJjZS5sZW5ndGg7XG4gIGNvbnN0IHN0YXJ0SW5kZXggPSB0YXJnZXQubGVuZ3RoO1xuXG4gIGlmIChzdGFydEluZGV4ID4gMCkge1xuICAgIGxldCBpc0R1cGxpY2F0ZSA9IHRydWU7XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNpemU7IGkrKykge1xuICAgICAgaWYgKHRhcmdldFtzdGFydEluZGV4IC0gc2l6ZSArIGldICE9PSBzb3VyY2VbaV0pIHtcbiAgICAgICAgaXNEdXBsaWNhdGUgPSBmYWxzZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGlzRHVwbGljYXRlKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBzaXplOyBpKyspIHtcbiAgICB0YXJnZXRbc3RhcnRJbmRleCArIGldID0gc291cmNlW2ldO1xuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59XG5leHBvcnQgZnVuY3Rpb24gY29weSh0YXJnZXQsIHNvdXJjZSkge1xuICBjb25zdCBzaXplID0gc291cmNlLmxlbmd0aDtcblxuICBmb3IgKGxldCBpID0gMDsgaSA8IHNpemU7IGkrKykge1xuICAgIHRhcmdldFtpXSA9IHNvdXJjZVtpXTtcbiAgfVxufVxuZXhwb3J0IGZ1bmN0aW9uIGdldFBvaW50QXRJbmRleChwb3NpdGlvbnMsIGluZGV4LCBzaXplLCBvZmZzZXQsIG91dCA9IFtdKSB7XG4gIGNvbnN0IHN0YXJ0SSA9IG9mZnNldCArIGluZGV4ICogc2l6ZTtcblxuICBmb3IgKGxldCBpID0gMDsgaSA8IHNpemU7IGkrKykge1xuICAgIG91dFtpXSA9IHBvc2l0aW9uc1tzdGFydEkgKyBpXTtcbiAgfVxuXG4gIHJldHVybiBvdXQ7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD11dGlscy5qcy5tYXAiLCJpbXBvcnQgeyBiaXRDb2RlLCBpbnRlcnNlY3QgfSBmcm9tICcuL2xpbmVjbGlwJztcbmltcG9ydCB7IGdldFBvaW50QXRJbmRleCwgY29weSwgcHVzaCB9IGZyb20gJy4vdXRpbHMnO1xuZXhwb3J0IGZ1bmN0aW9uIGN1dFBvbHlsaW5lQnlHcmlkKHBvc2l0aW9ucywgb3B0aW9ucykge1xuICBjb25zdCB7XG4gICAgc2l6ZSA9IDIsXG4gICAgYnJva2VuID0gZmFsc2UsXG4gICAgZ3JpZFJlc29sdXRpb24gPSAxMCxcbiAgICBncmlkT2Zmc2V0ID0gWzAsIDBdLFxuICAgIHN0YXJ0SW5kZXggPSAwLFxuICAgIGVuZEluZGV4ID0gcG9zaXRpb25zLmxlbmd0aFxuICB9ID0gb3B0aW9ucyB8fCB7fTtcbiAgY29uc3QgbnVtUG9pbnRzID0gKGVuZEluZGV4IC0gc3RhcnRJbmRleCkgLyBzaXplO1xuICBsZXQgcGFydCA9IFtdO1xuICBjb25zdCByZXN1bHQgPSBbcGFydF07XG4gIGNvbnN0IGEgPSBnZXRQb2ludEF0SW5kZXgocG9zaXRpb25zLCAwLCBzaXplLCBzdGFydEluZGV4KTtcbiAgbGV0IGI7XG4gIGxldCBjb2RlQjtcbiAgY29uc3QgY2VsbCA9IGdldEdyaWRDZWxsKGEsIGdyaWRSZXNvbHV0aW9uLCBncmlkT2Zmc2V0LCBbXSk7XG4gIGNvbnN0IHNjcmF0Y2hQb2ludCA9IFtdO1xuICBwdXNoKHBhcnQsIGEpO1xuXG4gIGZvciAobGV0IGkgPSAxOyBpIDwgbnVtUG9pbnRzOyBpKyspIHtcbiAgICBiID0gZ2V0UG9pbnRBdEluZGV4KHBvc2l0aW9ucywgaSwgc2l6ZSwgc3RhcnRJbmRleCwgYik7XG4gICAgY29kZUIgPSBiaXRDb2RlKGIsIGNlbGwpO1xuXG4gICAgd2hpbGUgKGNvZGVCKSB7XG4gICAgICBpbnRlcnNlY3QoYSwgYiwgY29kZUIsIGNlbGwsIHNjcmF0Y2hQb2ludCk7XG4gICAgICBjb25zdCBjb2RlQWx0ID0gYml0Q29kZShzY3JhdGNoUG9pbnQsIGNlbGwpO1xuXG4gICAgICBpZiAoY29kZUFsdCkge1xuICAgICAgICBpbnRlcnNlY3QoYSwgc2NyYXRjaFBvaW50LCBjb2RlQWx0LCBjZWxsLCBzY3JhdGNoUG9pbnQpO1xuICAgICAgICBjb2RlQiA9IGNvZGVBbHQ7XG4gICAgICB9XG5cbiAgICAgIHB1c2gocGFydCwgc2NyYXRjaFBvaW50KTtcbiAgICAgIGNvcHkoYSwgc2NyYXRjaFBvaW50KTtcbiAgICAgIG1vdmVUb05laWdoYm9yQ2VsbChjZWxsLCBncmlkUmVzb2x1dGlvbiwgY29kZUIpO1xuXG4gICAgICBpZiAoYnJva2VuICYmIHBhcnQubGVuZ3RoID4gc2l6ZSkge1xuICAgICAgICBwYXJ0ID0gW107XG4gICAgICAgIHJlc3VsdC5wdXNoKHBhcnQpO1xuICAgICAgICBwdXNoKHBhcnQsIGEpO1xuICAgICAgfVxuXG4gICAgICBjb2RlQiA9IGJpdENvZGUoYiwgY2VsbCk7XG4gICAgfVxuXG4gICAgcHVzaChwYXJ0LCBiKTtcbiAgICBjb3B5KGEsIGIpO1xuICB9XG5cbiAgcmV0dXJuIGJyb2tlbiA/IHJlc3VsdCA6IHJlc3VsdFswXTtcbn1cbmNvbnN0IFRZUEVfSU5TSURFID0gMDtcbmNvbnN0IFRZUEVfQk9SREVSID0gMTtcblxuZnVuY3Rpb24gY29uY2F0SW5QbGFjZShhcnIxLCBhcnIyKSB7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgYXJyMi5sZW5ndGg7IGkrKykge1xuICAgIGFycjEucHVzaChhcnIyW2ldKTtcbiAgfVxuXG4gIHJldHVybiBhcnIxO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gY3V0UG9seWdvbkJ5R3JpZChwb3NpdGlvbnMsIGhvbGVJbmRpY2VzID0gbnVsbCwgb3B0aW9ucykge1xuICBpZiAoIXBvc2l0aW9ucy5sZW5ndGgpIHtcbiAgICByZXR1cm4gW107XG4gIH1cblxuICBjb25zdCB7XG4gICAgc2l6ZSA9IDIsXG4gICAgZ3JpZFJlc29sdXRpb24gPSAxMCxcbiAgICBncmlkT2Zmc2V0ID0gWzAsIDBdLFxuICAgIGVkZ2VUeXBlcyA9IGZhbHNlXG4gIH0gPSBvcHRpb25zIHx8IHt9O1xuICBjb25zdCByZXN1bHQgPSBbXTtcbiAgY29uc3QgcXVldWUgPSBbe1xuICAgIHBvczogcG9zaXRpb25zLFxuICAgIHR5cGVzOiBlZGdlVHlwZXMgPyBuZXcgQXJyYXkocG9zaXRpb25zLmxlbmd0aCAvIHNpemUpLmZpbGwoVFlQRV9CT1JERVIpIDogbnVsbCxcbiAgICBob2xlczogaG9sZUluZGljZXMgfHwgW11cbiAgfV07XG4gIGNvbnN0IGJib3ggPSBbW10sIFtdXTtcbiAgbGV0IGNlbGwgPSBbXTtcblxuICB3aGlsZSAocXVldWUubGVuZ3RoKSB7XG4gICAgY29uc3Qge1xuICAgICAgcG9zLFxuICAgICAgdHlwZXMsXG4gICAgICBob2xlc1xuICAgIH0gPSBxdWV1ZS5zaGlmdCgpO1xuICAgIGdldEJvdW5kaW5nQm94KHBvcywgc2l6ZSwgaG9sZXNbMF0gfHwgcG9zLmxlbmd0aCwgYmJveCk7XG4gICAgY2VsbCA9IGdldEdyaWRDZWxsKGJib3hbMF0sIGdyaWRSZXNvbHV0aW9uLCBncmlkT2Zmc2V0LCBjZWxsKTtcbiAgICBjb25zdCBjb2RlID0gYml0Q29kZShiYm94WzFdLCBjZWxsKTtcblxuICAgIGlmIChjb2RlKSB7XG4gICAgICBsZXQgcGFydHMgPSBiaXNlY3RQb2x5Z29uKHBvcywgdHlwZXMsIHNpemUsIDAsIGhvbGVzWzBdIHx8IHBvcy5sZW5ndGgsIGNlbGwsIGNvZGUpO1xuICAgICAgY29uc3QgcG9seWdvbkxvdyA9IHtcbiAgICAgICAgcG9zOiBwYXJ0c1swXS5wb3MsXG4gICAgICAgIHR5cGVzOiBwYXJ0c1swXS50eXBlcyxcbiAgICAgICAgaG9sZXM6IFtdXG4gICAgICB9O1xuICAgICAgY29uc3QgcG9seWdvbkhpZ2ggPSB7XG4gICAgICAgIHBvczogcGFydHNbMV0ucG9zLFxuICAgICAgICB0eXBlczogcGFydHNbMV0udHlwZXMsXG4gICAgICAgIGhvbGVzOiBbXVxuICAgICAgfTtcbiAgICAgIHF1ZXVlLnB1c2gocG9seWdvbkxvdywgcG9seWdvbkhpZ2gpO1xuXG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGhvbGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHBhcnRzID0gYmlzZWN0UG9seWdvbihwb3MsIHR5cGVzLCBzaXplLCBob2xlc1tpXSwgaG9sZXNbaSArIDFdIHx8IHBvcy5sZW5ndGgsIGNlbGwsIGNvZGUpO1xuXG4gICAgICAgIGlmIChwYXJ0c1swXSkge1xuICAgICAgICAgIHBvbHlnb25Mb3cuaG9sZXMucHVzaChwb2x5Z29uTG93LnBvcy5sZW5ndGgpO1xuICAgICAgICAgIHBvbHlnb25Mb3cucG9zID0gY29uY2F0SW5QbGFjZShwb2x5Z29uTG93LnBvcywgcGFydHNbMF0ucG9zKTtcblxuICAgICAgICAgIGlmIChlZGdlVHlwZXMpIHtcbiAgICAgICAgICAgIHBvbHlnb25Mb3cudHlwZXMgPSBjb25jYXRJblBsYWNlKHBvbHlnb25Mb3cudHlwZXMsIHBhcnRzWzBdLnR5cGVzKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocGFydHNbMV0pIHtcbiAgICAgICAgICBwb2x5Z29uSGlnaC5ob2xlcy5wdXNoKHBvbHlnb25IaWdoLnBvcy5sZW5ndGgpO1xuICAgICAgICAgIHBvbHlnb25IaWdoLnBvcyA9IGNvbmNhdEluUGxhY2UocG9seWdvbkhpZ2gucG9zLCBwYXJ0c1sxXS5wb3MpO1xuXG4gICAgICAgICAgaWYgKGVkZ2VUeXBlcykge1xuICAgICAgICAgICAgcG9seWdvbkhpZ2gudHlwZXMgPSBjb25jYXRJblBsYWNlKHBvbHlnb25IaWdoLnR5cGVzLCBwYXJ0c1sxXS50eXBlcyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IHBvbHlnb24gPSB7XG4gICAgICAgIHBvc2l0aW9uczogcG9zXG4gICAgICB9O1xuXG4gICAgICBpZiAoZWRnZVR5cGVzKSB7XG4gICAgICAgIHBvbHlnb24uZWRnZVR5cGVzID0gdHlwZXM7XG4gICAgICB9XG5cbiAgICAgIGlmIChob2xlcy5sZW5ndGgpIHtcbiAgICAgICAgcG9seWdvbi5ob2xlSW5kaWNlcyA9IGhvbGVzO1xuICAgICAgfVxuXG4gICAgICByZXN1bHQucHVzaChwb2x5Z29uKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5mdW5jdGlvbiBiaXNlY3RQb2x5Z29uKHBvc2l0aW9ucywgZWRnZVR5cGVzLCBzaXplLCBzdGFydEluZGV4LCBlbmRJbmRleCwgYmJveCwgZWRnZSkge1xuICBjb25zdCBudW1Qb2ludHMgPSAoZW5kSW5kZXggLSBzdGFydEluZGV4KSAvIHNpemU7XG4gIGNvbnN0IHJlc3VsdExvdyA9IFtdO1xuICBjb25zdCByZXN1bHRIaWdoID0gW107XG4gIGNvbnN0IHR5cGVzTG93ID0gW107XG4gIGNvbnN0IHR5cGVzSGlnaCA9IFtdO1xuICBjb25zdCBzY3JhdGNoUG9pbnQgPSBbXTtcbiAgbGV0IHA7XG4gIGxldCBzaWRlO1xuICBsZXQgdHlwZTtcbiAgY29uc3QgcHJldiA9IGdldFBvaW50QXRJbmRleChwb3NpdGlvbnMsIG51bVBvaW50cyAtIDEsIHNpemUsIHN0YXJ0SW5kZXgpO1xuICBsZXQgcHJldlNpZGUgPSBNYXRoLnNpZ24oZWRnZSAmIDggPyBwcmV2WzFdIC0gYmJveFszXSA6IHByZXZbMF0gLSBiYm94WzJdKTtcbiAgbGV0IHByZXZUeXBlID0gZWRnZVR5cGVzICYmIGVkZ2VUeXBlc1tudW1Qb2ludHMgLSAxXTtcbiAgbGV0IGxvd1BvaW50Q291bnQgPSAwO1xuICBsZXQgaGlnaFBvaW50Q291bnQgPSAwO1xuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbnVtUG9pbnRzOyBpKyspIHtcbiAgICBwID0gZ2V0UG9pbnRBdEluZGV4KHBvc2l0aW9ucywgaSwgc2l6ZSwgc3RhcnRJbmRleCwgcCk7XG4gICAgc2lkZSA9IE1hdGguc2lnbihlZGdlICYgOCA/IHBbMV0gLSBiYm94WzNdIDogcFswXSAtIGJib3hbMl0pO1xuICAgIHR5cGUgPSBlZGdlVHlwZXMgJiYgZWRnZVR5cGVzW3N0YXJ0SW5kZXggLyBzaXplICsgaV07XG5cbiAgICBpZiAoc2lkZSAmJiBwcmV2U2lkZSAmJiBwcmV2U2lkZSAhPT0gc2lkZSkge1xuICAgICAgaW50ZXJzZWN0KHByZXYsIHAsIGVkZ2UsIGJib3gsIHNjcmF0Y2hQb2ludCk7XG4gICAgICBwdXNoKHJlc3VsdExvdywgc2NyYXRjaFBvaW50KSAmJiB0eXBlc0xvdy5wdXNoKHByZXZUeXBlKTtcbiAgICAgIHB1c2gocmVzdWx0SGlnaCwgc2NyYXRjaFBvaW50KSAmJiB0eXBlc0hpZ2gucHVzaChwcmV2VHlwZSk7XG4gICAgfVxuXG4gICAgaWYgKHNpZGUgPD0gMCkge1xuICAgICAgcHVzaChyZXN1bHRMb3csIHApICYmIHR5cGVzTG93LnB1c2godHlwZSk7XG4gICAgICBsb3dQb2ludENvdW50IC09IHNpZGU7XG4gICAgfSBlbHNlIGlmICh0eXBlc0xvdy5sZW5ndGgpIHtcbiAgICAgIHR5cGVzTG93W3R5cGVzTG93Lmxlbmd0aCAtIDFdID0gVFlQRV9JTlNJREU7XG4gICAgfVxuXG4gICAgaWYgKHNpZGUgPj0gMCkge1xuICAgICAgcHVzaChyZXN1bHRIaWdoLCBwKSAmJiB0eXBlc0hpZ2gucHVzaCh0eXBlKTtcbiAgICAgIGhpZ2hQb2ludENvdW50ICs9IHNpZGU7XG4gICAgfSBlbHNlIGlmICh0eXBlc0hpZ2gubGVuZ3RoKSB7XG4gICAgICB0eXBlc0hpZ2hbdHlwZXNIaWdoLmxlbmd0aCAtIDFdID0gVFlQRV9JTlNJREU7XG4gICAgfVxuXG4gICAgY29weShwcmV2LCBwKTtcbiAgICBwcmV2U2lkZSA9IHNpZGU7XG4gICAgcHJldlR5cGUgPSB0eXBlO1xuICB9XG5cbiAgcmV0dXJuIFtsb3dQb2ludENvdW50ID8ge1xuICAgIHBvczogcmVzdWx0TG93LFxuICAgIHR5cGVzOiBlZGdlVHlwZXMgJiYgdHlwZXNMb3dcbiAgfSA6IG51bGwsIGhpZ2hQb2ludENvdW50ID8ge1xuICAgIHBvczogcmVzdWx0SGlnaCxcbiAgICB0eXBlczogZWRnZVR5cGVzICYmIHR5cGVzSGlnaFxuICB9IDogbnVsbF07XG59XG5cbmZ1bmN0aW9uIGdldEdyaWRDZWxsKHAsIGdyaWRSZXNvbHV0aW9uLCBncmlkT2Zmc2V0LCBvdXQpIHtcbiAgY29uc3QgbGVmdCA9IE1hdGguZmxvb3IoKHBbMF0gLSBncmlkT2Zmc2V0WzBdKSAvIGdyaWRSZXNvbHV0aW9uKSAqIGdyaWRSZXNvbHV0aW9uICsgZ3JpZE9mZnNldFswXTtcbiAgY29uc3QgYm90dG9tID0gTWF0aC5mbG9vcigocFsxXSAtIGdyaWRPZmZzZXRbMV0pIC8gZ3JpZFJlc29sdXRpb24pICogZ3JpZFJlc29sdXRpb24gKyBncmlkT2Zmc2V0WzFdO1xuICBvdXRbMF0gPSBsZWZ0O1xuICBvdXRbMV0gPSBib3R0b207XG4gIG91dFsyXSA9IGxlZnQgKyBncmlkUmVzb2x1dGlvbjtcbiAgb3V0WzNdID0gYm90dG9tICsgZ3JpZFJlc29sdXRpb247XG4gIHJldHVybiBvdXQ7XG59XG5cbmZ1bmN0aW9uIG1vdmVUb05laWdoYm9yQ2VsbChjZWxsLCBncmlkUmVzb2x1dGlvbiwgZWRnZSkge1xuICBpZiAoZWRnZSAmIDgpIHtcbiAgICBjZWxsWzFdICs9IGdyaWRSZXNvbHV0aW9uO1xuICAgIGNlbGxbM10gKz0gZ3JpZFJlc29sdXRpb247XG4gIH0gZWxzZSBpZiAoZWRnZSAmIDQpIHtcbiAgICBjZWxsWzFdIC09IGdyaWRSZXNvbHV0aW9uO1xuICAgIGNlbGxbM10gLT0gZ3JpZFJlc29sdXRpb247XG4gIH0gZWxzZSBpZiAoZWRnZSAmIDIpIHtcbiAgICBjZWxsWzBdICs9IGdyaWRSZXNvbHV0aW9uO1xuICAgIGNlbGxbMl0gKz0gZ3JpZFJlc29sdXRpb247XG4gIH0gZWxzZSBpZiAoZWRnZSAmIDEpIHtcbiAgICBjZWxsWzBdIC09IGdyaWRSZXNvbHV0aW9uO1xuICAgIGNlbGxbMl0gLT0gZ3JpZFJlc29sdXRpb247XG4gIH1cbn1cblxuZnVuY3Rpb24gZ2V0Qm91bmRpbmdCb3gocG9zaXRpb25zLCBzaXplLCBlbmRJbmRleCwgb3V0KSB7XG4gIGxldCBtaW5YID0gSW5maW5pdHk7XG4gIGxldCBtYXhYID0gLUluZmluaXR5O1xuICBsZXQgbWluWSA9IEluZmluaXR5O1xuICBsZXQgbWF4WSA9IC1JbmZpbml0eTtcblxuICBmb3IgKGxldCBpID0gMDsgaSA8IGVuZEluZGV4OyBpICs9IHNpemUpIHtcbiAgICBjb25zdCB4ID0gcG9zaXRpb25zW2ldO1xuICAgIGNvbnN0IHkgPSBwb3NpdGlvbnNbaSArIDFdO1xuICAgIG1pblggPSB4IDwgbWluWCA/IHggOiBtaW5YO1xuICAgIG1heFggPSB4ID4gbWF4WCA/IHggOiBtYXhYO1xuICAgIG1pblkgPSB5IDwgbWluWSA/IHkgOiBtaW5ZO1xuICAgIG1heFkgPSB5ID4gbWF4WSA/IHkgOiBtYXhZO1xuICB9XG5cbiAgb3V0WzBdWzBdID0gbWluWDtcbiAgb3V0WzBdWzFdID0gbWluWTtcbiAgb3V0WzFdWzBdID0gbWF4WDtcbiAgb3V0WzFdWzFdID0gbWF4WTtcbiAgcmV0dXJuIG91dDtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWN1dC1ieS1ncmlkLmpzLm1hcCIsImltcG9ydCB7IGN1dFBvbHlsaW5lQnlHcmlkLCBjdXRQb2x5Z29uQnlHcmlkIH0gZnJvbSAnLi9jdXQtYnktZ3JpZCc7XG5pbXBvcnQgeyBnZXRQb2ludEF0SW5kZXgsIHB1c2ggfSBmcm9tICcuL3V0aWxzJztcbmNvbnN0IERFRkFVTFRfTUFYX0xBVElUVURFID0gODUuMDUxMTI5O1xuZXhwb3J0IGZ1bmN0aW9uIGN1dFBvbHlsaW5lQnlNZXJjYXRvckJvdW5kcyhwb3NpdGlvbnMsIG9wdGlvbnMpIHtcbiAgY29uc3Qge1xuICAgIHNpemUgPSAyLFxuICAgIHN0YXJ0SW5kZXggPSAwLFxuICAgIGVuZEluZGV4ID0gcG9zaXRpb25zLmxlbmd0aCxcbiAgICBub3JtYWxpemUgPSB0cnVlXG4gIH0gPSBvcHRpb25zIHx8IHt9O1xuICBjb25zdCBuZXdQb3NpdGlvbnMgPSBwb3NpdGlvbnMuc2xpY2Uoc3RhcnRJbmRleCwgZW5kSW5kZXgpO1xuICB3cmFwTG9uZ2l0dWRlc0ZvclNob3J0ZXN0UGF0aChuZXdQb3NpdGlvbnMsIHNpemUsIDAsIGVuZEluZGV4IC0gc3RhcnRJbmRleCk7XG4gIGNvbnN0IHBhcnRzID0gY3V0UG9seWxpbmVCeUdyaWQobmV3UG9zaXRpb25zLCB7XG4gICAgc2l6ZSxcbiAgICBicm9rZW46IHRydWUsXG4gICAgZ3JpZFJlc29sdXRpb246IDM2MCxcbiAgICBncmlkT2Zmc2V0OiBbLTE4MCwgLTE4MF1cbiAgfSk7XG5cbiAgaWYgKG5vcm1hbGl6ZSkge1xuICAgIGZvciAoY29uc3QgcGFydCBvZiBwYXJ0cykge1xuICAgICAgc2hpZnRMb25naXR1ZGVzSW50b1JhbmdlKHBhcnQsIHNpemUpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBwYXJ0cztcbn1cbmV4cG9ydCBmdW5jdGlvbiBjdXRQb2x5Z29uQnlNZXJjYXRvckJvdW5kcyhwb3NpdGlvbnMsIGhvbGVJbmRpY2VzID0gbnVsbCwgb3B0aW9ucykge1xuICBjb25zdCB7XG4gICAgc2l6ZSA9IDIsXG4gICAgbm9ybWFsaXplID0gdHJ1ZSxcbiAgICBlZGdlVHlwZXMgPSBmYWxzZVxuICB9ID0gb3B0aW9ucyB8fCB7fTtcbiAgaG9sZUluZGljZXMgPSBob2xlSW5kaWNlcyB8fCBbXTtcbiAgY29uc3QgbmV3UG9zaXRpb25zID0gW107XG4gIGNvbnN0IG5ld0hvbGVJbmRpY2VzID0gW107XG4gIGxldCBzcmNTdGFydEluZGV4ID0gMDtcbiAgbGV0IHRhcmdldEluZGV4ID0gMDtcblxuICBmb3IgKGxldCByaW5nSW5kZXggPSAwOyByaW5nSW5kZXggPD0gaG9sZUluZGljZXMubGVuZ3RoOyByaW5nSW5kZXgrKykge1xuICAgIGNvbnN0IHNyY0VuZEluZGV4ID0gaG9sZUluZGljZXNbcmluZ0luZGV4XSB8fCBwb3NpdGlvbnMubGVuZ3RoO1xuICAgIGNvbnN0IHRhcmdldFN0YXJ0SW5kZXggPSB0YXJnZXRJbmRleDtcbiAgICBjb25zdCBzcGxpdEluZGV4ID0gZmluZFNwbGl0SW5kZXgocG9zaXRpb25zLCBzaXplLCBzcmNTdGFydEluZGV4LCBzcmNFbmRJbmRleCk7XG5cbiAgICBmb3IgKGxldCBpID0gc3BsaXRJbmRleDsgaSA8IHNyY0VuZEluZGV4OyBpKyspIHtcbiAgICAgIG5ld1Bvc2l0aW9uc1t0YXJnZXRJbmRleCsrXSA9IHBvc2l0aW9uc1tpXTtcbiAgICB9XG5cbiAgICBmb3IgKGxldCBpID0gc3JjU3RhcnRJbmRleDsgaSA8IHNwbGl0SW5kZXg7IGkrKykge1xuICAgICAgbmV3UG9zaXRpb25zW3RhcmdldEluZGV4KytdID0gcG9zaXRpb25zW2ldO1xuICAgIH1cblxuICAgIHdyYXBMb25naXR1ZGVzRm9yU2hvcnRlc3RQYXRoKG5ld1Bvc2l0aW9ucywgc2l6ZSwgdGFyZ2V0U3RhcnRJbmRleCwgdGFyZ2V0SW5kZXgpO1xuICAgIGluc2VydFBvbGVWZXJ0aWNlcyhuZXdQb3NpdGlvbnMsIHNpemUsIHRhcmdldFN0YXJ0SW5kZXgsIHRhcmdldEluZGV4LCBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMubWF4TGF0aXR1ZGUpO1xuICAgIHNyY1N0YXJ0SW5kZXggPSBzcmNFbmRJbmRleDtcbiAgICBuZXdIb2xlSW5kaWNlc1tyaW5nSW5kZXhdID0gdGFyZ2V0SW5kZXg7XG4gIH1cblxuICBuZXdIb2xlSW5kaWNlcy5wb3AoKTtcbiAgY29uc3QgcGFydHMgPSBjdXRQb2x5Z29uQnlHcmlkKG5ld1Bvc2l0aW9ucywgbmV3SG9sZUluZGljZXMsIHtcbiAgICBzaXplLFxuICAgIGdyaWRSZXNvbHV0aW9uOiAzNjAsXG4gICAgZ3JpZE9mZnNldDogWy0xODAsIC0xODBdLFxuICAgIGVkZ2VUeXBlc1xuICB9KTtcblxuICBpZiAobm9ybWFsaXplKSB7XG4gICAgZm9yIChjb25zdCBwYXJ0IG9mIHBhcnRzKSB7XG4gICAgICBzaGlmdExvbmdpdHVkZXNJbnRvUmFuZ2UocGFydC5wb3NpdGlvbnMsIHNpemUpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBwYXJ0cztcbn1cblxuZnVuY3Rpb24gZmluZFNwbGl0SW5kZXgocG9zaXRpb25zLCBzaXplLCBzdGFydEluZGV4LCBlbmRJbmRleCkge1xuICBsZXQgbWF4TGF0ID0gLTE7XG4gIGxldCBwb2ludEluZGV4ID0gLTE7XG5cbiAgZm9yIChsZXQgaSA9IHN0YXJ0SW5kZXggKyAxOyBpIDwgZW5kSW5kZXg7IGkgKz0gc2l6ZSkge1xuICAgIGNvbnN0IGxhdCA9IE1hdGguYWJzKHBvc2l0aW9uc1tpXSk7XG5cbiAgICBpZiAobGF0ID4gbWF4TGF0KSB7XG4gICAgICBtYXhMYXQgPSBsYXQ7XG4gICAgICBwb2ludEluZGV4ID0gaSAtIDE7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHBvaW50SW5kZXg7XG59XG5cbmZ1bmN0aW9uIGluc2VydFBvbGVWZXJ0aWNlcyhwb3NpdGlvbnMsIHNpemUsIHN0YXJ0SW5kZXgsIGVuZEluZGV4LCBtYXhMYXRpdHVkZSA9IERFRkFVTFRfTUFYX0xBVElUVURFKSB7XG4gIGNvbnN0IGZpcnN0TG5nID0gcG9zaXRpb25zW3N0YXJ0SW5kZXhdO1xuICBjb25zdCBsYXN0TG5nID0gcG9zaXRpb25zW2VuZEluZGV4IC0gc2l6ZV07XG5cbiAgaWYgKE1hdGguYWJzKGZpcnN0TG5nIC0gbGFzdExuZykgPiAxODApIHtcbiAgICBjb25zdCBwID0gZ2V0UG9pbnRBdEluZGV4KHBvc2l0aW9ucywgMCwgc2l6ZSwgc3RhcnRJbmRleCk7XG4gICAgcFswXSArPSBNYXRoLnJvdW5kKChsYXN0TG5nIC0gZmlyc3RMbmcpIC8gMzYwKSAqIDM2MDtcbiAgICBwdXNoKHBvc2l0aW9ucywgcCk7XG4gICAgcFsxXSA9IE1hdGguc2lnbihwWzFdKSAqIG1heExhdGl0dWRlO1xuICAgIHB1c2gocG9zaXRpb25zLCBwKTtcbiAgICBwWzBdID0gZmlyc3RMbmc7XG4gICAgcHVzaChwb3NpdGlvbnMsIHApO1xuICB9XG59XG5cbmZ1bmN0aW9uIHdyYXBMb25naXR1ZGVzRm9yU2hvcnRlc3RQYXRoKHBvc2l0aW9ucywgc2l6ZSwgc3RhcnRJbmRleCwgZW5kSW5kZXgpIHtcbiAgbGV0IHByZXZMbmcgPSBwb3NpdGlvbnNbMF07XG4gIGxldCBsbmc7XG5cbiAgZm9yIChsZXQgaSA9IHN0YXJ0SW5kZXg7IGkgPCBlbmRJbmRleDsgaSArPSBzaXplKSB7XG4gICAgbG5nID0gcG9zaXRpb25zW2ldO1xuICAgIGNvbnN0IGRlbHRhID0gbG5nIC0gcHJldkxuZztcblxuICAgIGlmIChkZWx0YSA+IDE4MCB8fCBkZWx0YSA8IC0xODApIHtcbiAgICAgIGxuZyAtPSBNYXRoLnJvdW5kKGRlbHRhIC8gMzYwKSAqIDM2MDtcbiAgICB9XG5cbiAgICBwb3NpdGlvbnNbaV0gPSBwcmV2TG5nID0gbG5nO1xuICB9XG59XG5cbmZ1bmN0aW9uIHNoaWZ0TG9uZ2l0dWRlc0ludG9SYW5nZShwb3NpdGlvbnMsIHNpemUpIHtcbiAgbGV0IHJlZkxuZztcbiAgY29uc3QgcG9pbnRDb3VudCA9IHBvc2l0aW9ucy5sZW5ndGggLyBzaXplO1xuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgcG9pbnRDb3VudDsgaSsrKSB7XG4gICAgcmVmTG5nID0gcG9zaXRpb25zW2kgKiBzaXplXTtcblxuICAgIGlmICgocmVmTG5nICsgMTgwKSAlIDM2MCAhPT0gMCkge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG5cbiAgY29uc3QgZGVsdGEgPSAtTWF0aC5yb3VuZChyZWZMbmcgLyAzNjApICogMzYwO1xuXG4gIGlmIChkZWx0YSA9PT0gMCkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgcG9pbnRDb3VudDsgaSsrKSB7XG4gICAgcG9zaXRpb25zW2kgKiBzaXplXSArPSBkZWx0YTtcbiAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y3V0LWJ5LW1lcmNhdG9yLWJvdW5kcy5qcy5tYXAiLCJleHBvcnQgeyBkZWZhdWx0IGFzIFBvbHlnb24gfSBmcm9tICcuL3BvbHlnb24nO1xuZXhwb3J0IHsgZ2V0UG9seWdvblNpZ25lZEFyZWEsIGdldFBvbHlnb25XaW5kaW5nRGlyZWN0aW9uLCBmb3JFYWNoU2VnbWVudEluUG9seWdvbiwgbW9kaWZ5UG9seWdvbldpbmRpbmdEaXJlY3Rpb24sIFdJTkRJTkcgfSBmcm9tICcuL3BvbHlnb24tdXRpbHMnO1xuZXhwb3J0IHsgZWFyY3V0IH0gZnJvbSAnLi9lYXJjdXQnO1xuZXhwb3J0IHsgY2xpcFBvbHlnb24sIGNsaXBQb2x5bGluZSB9IGZyb20gJy4vbGluZWNsaXAnO1xuZXhwb3J0IHsgY3V0UG9seWdvbkJ5R3JpZCwgY3V0UG9seWxpbmVCeUdyaWQgfSBmcm9tICcuL2N1dC1ieS1ncmlkJztcbmV4cG9ydCB7IGN1dFBvbHlsaW5lQnlNZXJjYXRvckJvdW5kcywgY3V0UG9seWdvbkJ5TWVyY2F0b3JCb3VuZHMgfSBmcm9tICcuL2N1dC1ieS1tZXJjYXRvci1ib3VuZHMnO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBfUG9seWdvbiB9IGZyb20gJy4vcG9seWdvbic7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///89513\n')},78866:function(__unused_webpack_module,__webpack_exports__,__webpack_require__){eval('\n// EXPORTS\n__webpack_require__.d(__webpack_exports__, {\n  "eG": function() { return /* reexport */ addMetersToLngLat; },\n  "Lu": function() { return /* reexport */ web_mercator_utils_altitudeToFovy; },\n  "Xg": function() { return /* reexport */ fit_bounds_fitBounds; },\n  "sj": function() { return /* reexport */ web_mercator_utils_fovyToAltitude; },\n  "zX": function() { return /* reexport */ get_bounds_getBounds; },\n  "ro": function() { return /* reexport */ web_mercator_utils_getDistanceScales; },\n  "Bf": function() { return /* reexport */ getMeterZoom; },\n  "wl": function() { return /* reexport */ getProjectionParameters; },\n  "lf": function() { return /* reexport */ web_mercator_utils_getViewMatrix; },\n  "w5": function() { return /* reexport */ web_mercator_utils_lngLatToWorld; },\n  "QA": function() { return /* reexport */ normalizeViewportProps; },\n  "CT": function() { return /* reexport */ web_mercator_utils_pixelsToWorld; },\n  "NC": function() { return /* reexport */ unitsPerMeter; },\n  "es": function() { return /* reexport */ web_mercator_utils_worldToLngLat; },\n  "aW": function() { return /* reexport */ web_mercator_utils_worldToPixels; }\n});\n\n// UNUSED EXPORTS: MAX_LATITUDE, WebMercatorViewport, default, flyToViewport, getFlyToDuration, getProjectionMatrix, scaleToZoom, zoomToScale\n\n// EXTERNAL MODULE: ./node_modules/gl-matrix/esm/vec4.js\nvar vec4 = __webpack_require__(98333);\n;// CONCATENATED MODULE: ./node_modules/@math.gl/web-mercator/dist/esm/math-utils.js\n\nfunction math_utils_createMat4() {\n  return [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];\n}\nfunction transformVector(matrix, vector) {\n  const result = (0,vec4/* transformMat4 */.fF)([], vector, matrix);\n  (0,vec4/* scale */.bA)(result, result, 1 / result[3]);\n  return result;\n}\nfunction mod(value, divisor) {\n  const modulus = value % divisor;\n  return modulus < 0 ? divisor + modulus : modulus;\n}\nfunction math_utils_lerp(start, end, step) {\n  return step * end + (1 - step) * start;\n}\nfunction clamp(x, min, max) {\n  return x < min ? min : x > max ? max : x;\n}\n\nfunction ieLog2(x) {\n  return Math.log(x) * Math.LOG2E;\n}\n\nconst log2 = Math.log2 || ieLog2;\n//# sourceMappingURL=math-utils.js.map\n// EXTERNAL MODULE: ./node_modules/gl-matrix/esm/mat4.js\nvar esm_mat4 = __webpack_require__(85975);\n// EXTERNAL MODULE: ./node_modules/gl-matrix/esm/vec2.js\nvar esm_vec2 = __webpack_require__(31437);\n// EXTERNAL MODULE: ./node_modules/gl-matrix/esm/vec3.js\nvar esm_vec3 = __webpack_require__(77160);\n;// CONCATENATED MODULE: ./node_modules/@math.gl/web-mercator/dist/esm/assert.js\nfunction assert(condition, message) {\n  if (!condition) {\n    throw new Error(message || \'@math.gl/web-mercator: assertion failed.\');\n  }\n}\n//# sourceMappingURL=assert.js.map\n;// CONCATENATED MODULE: ./node_modules/@math.gl/web-mercator/dist/esm/web-mercator-utils.js\n\n\n\n\n\nconst PI = Math.PI;\nconst PI_4 = PI / 4;\nconst DEGREES_TO_RADIANS = PI / 180;\nconst RADIANS_TO_DEGREES = 180 / PI;\nconst TILE_SIZE = 512;\nconst EARTH_CIRCUMFERENCE = 40.03e6;\nconst MAX_LATITUDE = 85.051129;\nconst web_mercator_utils_DEFAULT_ALTITUDE = 1.5;\nfunction web_mercator_utils_zoomToScale(zoom) {\n  return Math.pow(2, zoom);\n}\nfunction web_mercator_utils_scaleToZoom(scale) {\n  return log2(scale);\n}\nfunction web_mercator_utils_lngLatToWorld(lngLat) {\n  const [lng, lat] = lngLat;\n  assert(Number.isFinite(lng));\n  assert(Number.isFinite(lat) && lat >= -90 && lat <= 90, \'invalid latitude\');\n  const lambda2 = lng * DEGREES_TO_RADIANS;\n  const phi2 = lat * DEGREES_TO_RADIANS;\n  const x = TILE_SIZE * (lambda2 + PI) / (2 * PI);\n  const y = TILE_SIZE * (PI + Math.log(Math.tan(PI_4 + phi2 * 0.5))) / (2 * PI);\n  return [x, y];\n}\nfunction web_mercator_utils_worldToLngLat(xy) {\n  const [x, y] = xy;\n  const lambda2 = x / TILE_SIZE * (2 * PI) - PI;\n  const phi2 = 2 * (Math.atan(Math.exp(y / TILE_SIZE * (2 * PI) - PI)) - PI_4);\n  return [lambda2 * RADIANS_TO_DEGREES, phi2 * RADIANS_TO_DEGREES];\n}\nfunction getMeterZoom(options) {\n  const {\n    latitude\n  } = options;\n  assert(Number.isFinite(latitude));\n  const latCosine = Math.cos(latitude * DEGREES_TO_RADIANS);\n  return web_mercator_utils_scaleToZoom(EARTH_CIRCUMFERENCE * latCosine) - 9;\n}\nfunction unitsPerMeter(latitude) {\n  const latCosine = Math.cos(latitude * DEGREES_TO_RADIANS);\n  return TILE_SIZE / EARTH_CIRCUMFERENCE / latCosine;\n}\nfunction web_mercator_utils_getDistanceScales(options) {\n  const {\n    latitude,\n    longitude,\n    highPrecision = false\n  } = options;\n  assert(Number.isFinite(latitude) && Number.isFinite(longitude));\n  const worldSize = TILE_SIZE;\n  const latCosine = Math.cos(latitude * DEGREES_TO_RADIANS);\n  const unitsPerDegreeX = worldSize / 360;\n  const unitsPerDegreeY = unitsPerDegreeX / latCosine;\n  const altUnitsPerMeter = worldSize / EARTH_CIRCUMFERENCE / latCosine;\n  const result = {\n    unitsPerMeter: [altUnitsPerMeter, altUnitsPerMeter, altUnitsPerMeter],\n    metersPerUnit: [1 / altUnitsPerMeter, 1 / altUnitsPerMeter, 1 / altUnitsPerMeter],\n    unitsPerDegree: [unitsPerDegreeX, unitsPerDegreeY, altUnitsPerMeter],\n    degreesPerUnit: [1 / unitsPerDegreeX, 1 / unitsPerDegreeY, 1 / altUnitsPerMeter]\n  };\n\n  if (highPrecision) {\n    const latCosine2 = DEGREES_TO_RADIANS * Math.tan(latitude * DEGREES_TO_RADIANS) / latCosine;\n    const unitsPerDegreeY2 = unitsPerDegreeX * latCosine2 / 2;\n    const altUnitsPerDegree2 = worldSize / EARTH_CIRCUMFERENCE * latCosine2;\n    const altUnitsPerMeter2 = altUnitsPerDegree2 / unitsPerDegreeY * altUnitsPerMeter;\n    result.unitsPerDegree2 = [0, unitsPerDegreeY2, altUnitsPerDegree2];\n    result.unitsPerMeter2 = [altUnitsPerMeter2, 0, altUnitsPerMeter2];\n  }\n\n  return result;\n}\nfunction addMetersToLngLat(lngLatZ, xyz) {\n  const [longitude, latitude, z0] = lngLatZ;\n  const [x, y, z] = xyz;\n  const {\n    unitsPerMeter,\n    unitsPerMeter2\n  } = web_mercator_utils_getDistanceScales({\n    longitude,\n    latitude,\n    highPrecision: true\n  });\n  const worldspace = web_mercator_utils_lngLatToWorld(lngLatZ);\n  worldspace[0] += x * (unitsPerMeter[0] + unitsPerMeter2[0] * y);\n  worldspace[1] += y * (unitsPerMeter[1] + unitsPerMeter2[1] * y);\n  const newLngLat = web_mercator_utils_worldToLngLat(worldspace);\n  const newZ = (z0 || 0) + (z || 0);\n  return Number.isFinite(z0) || Number.isFinite(z) ? [newLngLat[0], newLngLat[1], newZ] : newLngLat;\n}\nfunction web_mercator_utils_getViewMatrix(options) {\n  const {\n    height,\n    pitch,\n    bearing,\n    altitude,\n    scale,\n    center\n  } = options;\n  const vm = math_utils_createMat4();\n  esm_mat4/* translate */.Iu(vm, vm, [0, 0, -altitude]);\n  esm_mat4/* rotateX */.lM(vm, vm, -pitch * DEGREES_TO_RADIANS);\n  esm_mat4/* rotateZ */.jI(vm, vm, bearing * DEGREES_TO_RADIANS);\n  const relativeScale = scale / height;\n  esm_mat4/* scale */.bA(vm, vm, [relativeScale, relativeScale, relativeScale]);\n\n  if (center) {\n    esm_mat4/* translate */.Iu(vm, vm, esm_vec3/* negate */.tk([], center));\n  }\n\n  return vm;\n}\nfunction getProjectionParameters(options) {\n  const {\n    width,\n    height,\n    altitude,\n    pitch = 0,\n    offset,\n    center,\n    scale,\n    nearZMultiplier = 1,\n    farZMultiplier = 1\n  } = options;\n  let {\n    fovy = web_mercator_utils_altitudeToFovy(web_mercator_utils_DEFAULT_ALTITUDE)\n  } = options;\n\n  if (altitude !== undefined) {\n    fovy = web_mercator_utils_altitudeToFovy(altitude);\n  }\n\n  const fovRadians = fovy * DEGREES_TO_RADIANS;\n  const pitchRadians = pitch * DEGREES_TO_RADIANS;\n  const focalDistance = web_mercator_utils_fovyToAltitude(fovy);\n  let cameraToSeaLevelDistance = focalDistance;\n\n  if (center) {\n    cameraToSeaLevelDistance += center[2] * scale / Math.cos(pitchRadians) / height;\n  }\n\n  const fovAboveCenter = fovRadians * (0.5 + (offset ? offset[1] : 0) / height);\n  const topHalfSurfaceDistance = Math.sin(fovAboveCenter) * cameraToSeaLevelDistance / Math.sin(clamp(Math.PI / 2 - pitchRadians - fovAboveCenter, 0.01, Math.PI - 0.01));\n  const furthestDistance = Math.sin(pitchRadians) * topHalfSurfaceDistance + cameraToSeaLevelDistance;\n  const horizonDistance = cameraToSeaLevelDistance * 10;\n  const farZ = Math.min(furthestDistance * farZMultiplier, horizonDistance);\n  return {\n    fov: fovRadians,\n    aspect: width / height,\n    focalDistance,\n    near: nearZMultiplier,\n    far: farZ\n  };\n}\nfunction web_mercator_utils_getProjectionMatrix(options) {\n  const {\n    fov,\n    aspect,\n    near,\n    far\n  } = getProjectionParameters(options);\n  const projectionMatrix = mat4.perspective([], fov, aspect, near, far);\n  return projectionMatrix;\n}\nfunction web_mercator_utils_altitudeToFovy(altitude) {\n  return 2 * Math.atan(0.5 / altitude) * RADIANS_TO_DEGREES;\n}\nfunction web_mercator_utils_fovyToAltitude(fovy) {\n  return 0.5 / Math.tan(0.5 * fovy * DEGREES_TO_RADIANS);\n}\nfunction web_mercator_utils_worldToPixels(xyz, pixelProjectionMatrix) {\n  const [x, y, z = 0] = xyz;\n  assert(Number.isFinite(x) && Number.isFinite(y) && Number.isFinite(z));\n  return transformVector(pixelProjectionMatrix, [x, y, z, 1]);\n}\nfunction web_mercator_utils_pixelsToWorld(xyz, pixelUnprojectionMatrix, targetZ = 0) {\n  const [x, y, z] = xyz;\n  assert(Number.isFinite(x) && Number.isFinite(y), \'invalid pixel coordinate\');\n\n  if (Number.isFinite(z)) {\n    const coord = transformVector(pixelUnprojectionMatrix, [x, y, z, 1]);\n    return coord;\n  }\n\n  const coord0 = transformVector(pixelUnprojectionMatrix, [x, y, 0, 1]);\n  const coord1 = transformVector(pixelUnprojectionMatrix, [x, y, 1, 1]);\n  const z0 = coord0[2];\n  const z1 = coord1[2];\n  const t = z0 === z1 ? 0 : ((targetZ || 0) - z0) / (z1 - z0);\n  return esm_vec2/* lerp */.t7([], coord0, coord1, t);\n}\n//# sourceMappingURL=web-mercator-utils.js.map\n;// CONCATENATED MODULE: ./node_modules/@math.gl/web-mercator/dist/esm/fit-bounds.js\n\n\n\nfunction fit_bounds_fitBounds(options) {\n  const {\n    width,\n    height,\n    bounds,\n    minExtent = 0,\n    maxZoom = 24,\n    offset = [0, 0]\n  } = options;\n  const [[west, south], [east, north]] = bounds;\n  const padding = getPaddingObject(options.padding);\n  const nw = web_mercator_utils_lngLatToWorld([west, clamp(north, -MAX_LATITUDE, MAX_LATITUDE)]);\n  const se = web_mercator_utils_lngLatToWorld([east, clamp(south, -MAX_LATITUDE, MAX_LATITUDE)]);\n  const size = [Math.max(Math.abs(se[0] - nw[0]), minExtent), Math.max(Math.abs(se[1] - nw[1]), minExtent)];\n  const targetSize = [width - padding.left - padding.right - Math.abs(offset[0]) * 2, height - padding.top - padding.bottom - Math.abs(offset[1]) * 2];\n  assert(targetSize[0] > 0 && targetSize[1] > 0);\n  const scaleX = targetSize[0] / size[0];\n  const scaleY = targetSize[1] / size[1];\n  const offsetX = (padding.right - padding.left) / 2 / scaleX;\n  const offsetY = (padding.top - padding.bottom) / 2 / scaleY;\n  const center = [(se[0] + nw[0]) / 2 + offsetX, (se[1] + nw[1]) / 2 + offsetY];\n  const centerLngLat = web_mercator_utils_worldToLngLat(center);\n  const zoom = Math.min(maxZoom, log2(Math.abs(Math.min(scaleX, scaleY))));\n  assert(Number.isFinite(zoom));\n  return {\n    longitude: centerLngLat[0],\n    latitude: centerLngLat[1],\n    zoom\n  };\n}\n\nfunction getPaddingObject(padding = 0) {\n  if (typeof padding === \'number\') {\n    return {\n      top: padding,\n      bottom: padding,\n      left: padding,\n      right: padding\n    };\n  }\n\n  assert(Number.isFinite(padding.top) && Number.isFinite(padding.bottom) && Number.isFinite(padding.left) && Number.isFinite(padding.right));\n  return padding;\n}\n//# sourceMappingURL=fit-bounds.js.map\n;// CONCATENATED MODULE: ./node_modules/@math.gl/web-mercator/dist/esm/get-bounds.js\n\n\n\nconst get_bounds_DEGREES_TO_RADIANS = Math.PI / 180;\nfunction get_bounds_getBounds(viewport, z = 0) {\n  const {\n    width,\n    height,\n    unproject\n  } = viewport;\n  const unprojectOps = {\n    targetZ: z\n  };\n  const bottomLeft = unproject([0, height], unprojectOps);\n  const bottomRight = unproject([width, height], unprojectOps);\n  let topLeft;\n  let topRight;\n  const halfFov = viewport.fovy ? 0.5 * viewport.fovy * get_bounds_DEGREES_TO_RADIANS : Math.atan(0.5 / viewport.altitude);\n  const angleToGround = (90 - viewport.pitch) * get_bounds_DEGREES_TO_RADIANS;\n\n  if (halfFov > angleToGround - 0.01) {\n    topLeft = unprojectOnFarPlane(viewport, 0, z);\n    topRight = unprojectOnFarPlane(viewport, width, z);\n  } else {\n    topLeft = unproject([0, 0], unprojectOps);\n    topRight = unproject([width, 0], unprojectOps);\n  }\n\n  return [bottomLeft, bottomRight, topRight, topLeft];\n}\n\nfunction unprojectOnFarPlane(viewport, x, targetZ) {\n  const {\n    pixelUnprojectionMatrix\n  } = viewport;\n  const coord0 = transformVector(pixelUnprojectionMatrix, [x, 0, 1, 1]);\n  const coord1 = transformVector(pixelUnprojectionMatrix, [x, viewport.height, 1, 1]);\n  const z = targetZ * viewport.distanceScales.unitsPerMeter[2];\n  const t = (z - coord0[2]) / (coord1[2] - coord0[2]);\n  const coord = esm_vec2/* lerp */.t7([], coord0, coord1, t);\n  const result = web_mercator_utils_worldToLngLat(coord);\n  result.push(targetZ);\n  return result;\n}\n//# sourceMappingURL=get-bounds.js.map\n;// CONCATENATED MODULE: ./node_modules/@math.gl/web-mercator/dist/esm/web-mercator-viewport.js\n\n\n\n\n\n\n\n\nclass WebMercatorViewport {\n  constructor(props = {\n    width: 1,\n    height: 1\n  }) {\n    _defineProperty(this, "latitude", void 0);\n\n    _defineProperty(this, "longitude", void 0);\n\n    _defineProperty(this, "zoom", void 0);\n\n    _defineProperty(this, "pitch", void 0);\n\n    _defineProperty(this, "bearing", void 0);\n\n    _defineProperty(this, "altitude", void 0);\n\n    _defineProperty(this, "fovy", void 0);\n\n    _defineProperty(this, "meterOffset", void 0);\n\n    _defineProperty(this, "center", void 0);\n\n    _defineProperty(this, "width", void 0);\n\n    _defineProperty(this, "height", void 0);\n\n    _defineProperty(this, "scale", void 0);\n\n    _defineProperty(this, "distanceScales", void 0);\n\n    _defineProperty(this, "viewMatrix", void 0);\n\n    _defineProperty(this, "projectionMatrix", void 0);\n\n    _defineProperty(this, "viewProjectionMatrix", void 0);\n\n    _defineProperty(this, "pixelProjectionMatrix", void 0);\n\n    _defineProperty(this, "pixelUnprojectionMatrix", void 0);\n\n    _defineProperty(this, "equals", viewport => {\n      if (!(viewport instanceof WebMercatorViewport)) {\n        return false;\n      }\n\n      return viewport.width === this.width && viewport.height === this.height && mat4.equals(viewport.projectionMatrix, this.projectionMatrix) && mat4.equals(viewport.viewMatrix, this.viewMatrix);\n    });\n\n    _defineProperty(this, "project", (lngLatZ, options = {}) => {\n      const {\n        topLeft = true\n      } = options;\n      const worldPosition = this.projectPosition(lngLatZ);\n      const coord = worldToPixels(worldPosition, this.pixelProjectionMatrix);\n      const [x, y] = coord;\n      const y2 = topLeft ? y : this.height - y;\n      return lngLatZ.length === 2 ? [x, y2] : [x, y2, coord[2]];\n    });\n\n    _defineProperty(this, "unproject", (xyz, options = {}) => {\n      const {\n        topLeft = true,\n        targetZ = undefined\n      } = options;\n      const [x, y, z] = xyz;\n      const y2 = topLeft ? y : this.height - y;\n      const targetZWorld = targetZ && targetZ * this.distanceScales.unitsPerMeter[2];\n      const coord = pixelsToWorld([x, y2, z], this.pixelUnprojectionMatrix, targetZWorld);\n      const [X, Y, Z] = this.unprojectPosition(coord);\n\n      if (Number.isFinite(z)) {\n        return [X, Y, Z];\n      }\n\n      return Number.isFinite(targetZ) ? [X, Y, targetZ] : [X, Y];\n    });\n\n    _defineProperty(this, "projectPosition", xyz => {\n      const [X, Y] = lngLatToWorld(xyz);\n      const Z = (xyz[2] || 0) * this.distanceScales.unitsPerMeter[2];\n      return [X, Y, Z];\n    });\n\n    _defineProperty(this, "unprojectPosition", xyz => {\n      const [X, Y] = worldToLngLat(xyz);\n      const Z = (xyz[2] || 0) * this.distanceScales.metersPerUnit[2];\n      return [X, Y, Z];\n    });\n\n    let {\n      width,\n      height,\n      altitude = null,\n      fovy = null\n    } = props;\n    const {\n      latitude = 0,\n      longitude = 0,\n      zoom = 0,\n      pitch = 0,\n      bearing = 0,\n      position = null,\n      nearZMultiplier = 0.02,\n      farZMultiplier = 1.01\n    } = props;\n    width = width || 1;\n    height = height || 1;\n\n    if (fovy === null && altitude === null) {\n      altitude = DEFAULT_ALTITUDE;\n      fovy = altitudeToFovy(altitude);\n    } else if (fovy === null) {\n      fovy = altitudeToFovy(altitude);\n    } else if (altitude === null) {\n      altitude = fovyToAltitude(fovy);\n    }\n\n    const scale = zoomToScale(zoom);\n    altitude = Math.max(0.75, altitude);\n    const distanceScales = getDistanceScales({\n      longitude,\n      latitude\n    });\n    const center = lngLatToWorld([longitude, latitude]);\n    center.push(0);\n\n    if (position) {\n      vec3.add(center, center, vec3.mul([], position, distanceScales.unitsPerMeter));\n    }\n\n    this.projectionMatrix = getProjectionMatrix({\n      width,\n      height,\n      scale,\n      center,\n      pitch,\n      fovy,\n      nearZMultiplier,\n      farZMultiplier\n    });\n    this.viewMatrix = getViewMatrix({\n      height,\n      scale,\n      center,\n      pitch,\n      bearing,\n      altitude\n    });\n    this.width = width;\n    this.height = height;\n    this.scale = scale;\n    this.latitude = latitude;\n    this.longitude = longitude;\n    this.zoom = zoom;\n    this.pitch = pitch;\n    this.bearing = bearing;\n    this.altitude = altitude;\n    this.fovy = fovy;\n    this.center = center;\n    this.meterOffset = position || [0, 0, 0];\n    this.distanceScales = distanceScales;\n\n    this._initMatrices();\n\n    Object.freeze(this);\n  }\n\n  _initMatrices() {\n    const {\n      width,\n      height,\n      projectionMatrix,\n      viewMatrix\n    } = this;\n    const vpm = createMat4();\n    mat4.multiply(vpm, vpm, projectionMatrix);\n    mat4.multiply(vpm, vpm, viewMatrix);\n    this.viewProjectionMatrix = vpm;\n    const m = createMat4();\n    mat4.scale(m, m, [width / 2, -height / 2, 1]);\n    mat4.translate(m, m, [1, -1, 0]);\n    mat4.multiply(m, m, vpm);\n    const mInverse = mat4.invert(createMat4(), m);\n\n    if (!mInverse) {\n      throw new Error(\'Pixel project matrix not invertible\');\n    }\n\n    this.pixelProjectionMatrix = m;\n    this.pixelUnprojectionMatrix = mInverse;\n  }\n\n  projectFlat(lngLat) {\n    return lngLatToWorld(lngLat);\n  }\n\n  unprojectFlat(xy) {\n    return worldToLngLat(xy);\n  }\n\n  getMapCenterByLngLatPosition({\n    lngLat,\n    pos\n  }) {\n    const fromLocation = pixelsToWorld(pos, this.pixelUnprojectionMatrix);\n    const toLocation = lngLatToWorld(lngLat);\n    const translate = vec2.add([], toLocation, vec2.negate([], fromLocation));\n    const newCenter = vec2.add([], this.center, translate);\n    return worldToLngLat(newCenter);\n  }\n\n  fitBounds(bounds, options = {}) {\n    const {\n      width,\n      height\n    } = this;\n    const {\n      longitude,\n      latitude,\n      zoom\n    } = fitBounds(Object.assign({\n      width,\n      height,\n      bounds\n    }, options));\n    return new WebMercatorViewport({\n      width,\n      height,\n      longitude,\n      latitude,\n      zoom\n    });\n  }\n\n  getBounds(options) {\n    const corners = this.getBoundingRegion(options);\n    const west = Math.min(...corners.map(p => p[0]));\n    const east = Math.max(...corners.map(p => p[0]));\n    const south = Math.min(...corners.map(p => p[1]));\n    const north = Math.max(...corners.map(p => p[1]));\n    return [[west, south], [east, north]];\n  }\n\n  getBoundingRegion(options = {}) {\n    return getBounds(this, options.z || 0);\n  }\n\n  getLocationAtPoint({\n    lngLat,\n    pos\n  }) {\n    return this.getMapCenterByLngLatPosition({\n      lngLat,\n      pos\n    });\n  }\n\n}\n//# sourceMappingURL=web-mercator-viewport.js.map\n;// CONCATENATED MODULE: ./node_modules/@math.gl/web-mercator/dist/esm/normalize-viewport-props.js\n\n\nconst normalize_viewport_props_TILE_SIZE = 512;\nfunction normalizeViewportProps(props) {\n  const {\n    width,\n    height,\n    pitch = 0\n  } = props;\n  let {\n    longitude,\n    latitude,\n    zoom,\n    bearing = 0\n  } = props;\n\n  if (longitude < -180 || longitude > 180) {\n    longitude = mod(longitude + 180, 360) - 180;\n  }\n\n  if (bearing < -180 || bearing > 180) {\n    bearing = mod(bearing + 180, 360) - 180;\n  }\n\n  const minZoom = log2(height / normalize_viewport_props_TILE_SIZE);\n\n  if (zoom <= minZoom) {\n    zoom = minZoom;\n    latitude = 0;\n  } else {\n    const halfHeightPixels = height / 2 / Math.pow(2, zoom);\n    const minLatitude = web_mercator_utils_worldToLngLat([0, halfHeightPixels])[1];\n\n    if (latitude < minLatitude) {\n      latitude = minLatitude;\n    } else {\n      const maxLatitude = web_mercator_utils_worldToLngLat([0, normalize_viewport_props_TILE_SIZE - halfHeightPixels])[1];\n\n      if (latitude > maxLatitude) {\n        latitude = maxLatitude;\n      }\n    }\n  }\n\n  return {\n    width,\n    height,\n    longitude,\n    latitude,\n    zoom,\n    pitch,\n    bearing\n  };\n}\n//# sourceMappingURL=normalize-viewport-props.js.map\n;// CONCATENATED MODULE: ./node_modules/@math.gl/web-mercator/dist/esm/fly-to-viewport.js\n\n\n\nconst EPSILON = 0.01;\nconst VIEWPORT_TRANSITION_PROPS = (/* unused pure expression or super */ null && ([\'longitude\', \'latitude\', \'zoom\']));\nconst DEFAULT_OPTS = {\n  curve: 1.414,\n  speed: 1.2\n};\nfunction flyToViewport(startProps, endProps, t, options) {\n  const {\n    startZoom,\n    startCenterXY,\n    uDelta,\n    w0,\n    u1,\n    S,\n    rho,\n    rho2,\n    r0\n  } = getFlyToTransitionParams(startProps, endProps, options);\n\n  if (u1 < EPSILON) {\n    const viewport = {};\n\n    for (const key of VIEWPORT_TRANSITION_PROPS) {\n      const startValue = startProps[key];\n      const endValue = endProps[key];\n      viewport[key] = lerp(startValue, endValue, t);\n    }\n\n    return viewport;\n  }\n\n  const s = t * S;\n  const w = Math.cosh(r0) / Math.cosh(r0 + rho * s);\n  const u = w0 * ((Math.cosh(r0) * Math.tanh(r0 + rho * s) - Math.sinh(r0)) / rho2) / u1;\n  const scaleIncrement = 1 / w;\n  const newZoom = startZoom + scaleToZoom(scaleIncrement);\n  const newCenterWorld = vec2.scale([], uDelta, u);\n  vec2.add(newCenterWorld, newCenterWorld, startCenterXY);\n  const newCenter = worldToLngLat(newCenterWorld);\n  return {\n    longitude: newCenter[0],\n    latitude: newCenter[1],\n    zoom: newZoom\n  };\n}\nfunction getFlyToDuration(startProps, endProps, options) {\n  const opts = { ...DEFAULT_OPTS,\n    ...options\n  };\n  const {\n    screenSpeed,\n    speed,\n    maxDuration\n  } = opts;\n  const {\n    S,\n    rho\n  } = getFlyToTransitionParams(startProps, endProps, opts);\n  const length = 1000 * S;\n  let duration;\n\n  if (Number.isFinite(screenSpeed)) {\n    duration = length / (screenSpeed / rho);\n  } else {\n    duration = length / speed;\n  }\n\n  return Number.isFinite(maxDuration) && duration > maxDuration ? 0 : duration;\n}\n\nfunction getFlyToTransitionParams(startProps, endProps, opts) {\n  opts = Object.assign({}, DEFAULT_OPTS, opts);\n  const rho = opts.curve;\n  const startZoom = startProps.zoom;\n  const startCenter = [startProps.longitude, startProps.latitude];\n  const startScale = zoomToScale(startZoom);\n  const endZoom = endProps.zoom;\n  const endCenter = [endProps.longitude, endProps.latitude];\n  const scale = zoomToScale(endZoom - startZoom);\n  const startCenterXY = lngLatToWorld(startCenter);\n  const endCenterXY = lngLatToWorld(endCenter);\n  const uDelta = vec2.sub([], endCenterXY, startCenterXY);\n  const w0 = Math.max(startProps.width, startProps.height);\n  const w1 = w0 / scale;\n  const u1 = vec2.length(uDelta) * startScale;\n\n  const _u1 = Math.max(u1, EPSILON);\n\n  const rho2 = rho * rho;\n  const b0 = (w1 * w1 - w0 * w0 + rho2 * rho2 * _u1 * _u1) / (2 * w0 * rho2 * _u1);\n  const b1 = (w1 * w1 - w0 * w0 - rho2 * rho2 * _u1 * _u1) / (2 * w1 * rho2 * _u1);\n  const r0 = Math.log(Math.sqrt(b0 * b0 + 1) - b0);\n  const r1 = Math.log(Math.sqrt(b1 * b1 + 1) - b1);\n  const S = (r1 - r0) / rho;\n  return {\n    startZoom,\n    startCenterXY,\n    uDelta,\n    w0,\n    u1,\n    S,\n    rho,\n    rho2,\n    r0,\n    r1\n  };\n}\n//# sourceMappingURL=fly-to-viewport.js.map\n;// CONCATENATED MODULE: ./node_modules/@math.gl/web-mercator/dist/esm/index.js\n\n\n\n\n\n\n\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNzg4NjYuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFzRDtBQUMvQyxTQUFTLHFCQUFVO0FBQzFCO0FBQ0E7QUFDTztBQUNQLGlCQUFpQiw4QkFBYTtBQUM5QixFQUFFLHNCQUFLO0FBQ1A7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ08sU0FBUyxlQUFJO0FBQ3BCO0FBQ0E7QUFDTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVPO0FBQ1Asc0M7Ozs7Ozs7O0FDekJlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQzs7QUNMd0U7QUFDakM7QUFDQTtBQUNBO0FBQ1Q7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDQSxNQUFNLG1DQUFnQjtBQUN0QixTQUFTLDhCQUFXO0FBQzNCO0FBQ0E7QUFDTyxTQUFTLDhCQUFXO0FBQzNCLFNBQVMsSUFBSTtBQUNiO0FBQ08sU0FBUyxnQ0FBYTtBQUM3QjtBQUNBLEVBQUUsTUFBTTtBQUNSLEVBQUUsTUFBTTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPLFNBQVMsZ0NBQWE7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBLElBQUk7QUFDSixFQUFFLE1BQU07QUFDUjtBQUNBLFNBQVMsOEJBQVc7QUFDcEI7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNPLFNBQVMsb0NBQWlCO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKLEVBQUUsTUFBTTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSxFQUFFLG9DQUFpQjtBQUN2QjtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gscUJBQXFCLGdDQUFhO0FBQ2xDO0FBQ0E7QUFDQSxvQkFBb0IsZ0NBQWE7QUFDakM7QUFDQTtBQUNBO0FBQ08sU0FBUyxnQ0FBYTtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSixhQUFhLHFCQUFVO0FBQ3ZCLEVBQUUsMEJBQWM7QUFDaEIsRUFBRSx3QkFBWTtBQUNkLEVBQUUsd0JBQVk7QUFDZDtBQUNBLEVBQUUsc0JBQVU7O0FBRVo7QUFDQSxJQUFJLDBCQUFjLFNBQVMsdUJBQVc7QUFDdEM7O0FBRUE7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxXQUFXLGlDQUFjLENBQUMsbUNBQWdCO0FBQzFDLElBQUk7O0FBRUo7QUFDQSxXQUFXLGlDQUFjO0FBQ3pCOztBQUVBO0FBQ0E7QUFDQSx3QkFBd0IsaUNBQWM7QUFDdEM7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZ0dBQWdHLEtBQUs7QUFDckc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPLFNBQVMsc0NBQW1CO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ08sU0FBUyxpQ0FBYztBQUM5QjtBQUNBO0FBQ08sU0FBUyxpQ0FBYztBQUM5QjtBQUNBO0FBQ08sU0FBUyxnQ0FBYTtBQUM3QjtBQUNBLEVBQUUsTUFBTTtBQUNSLFNBQVMsZUFBZTtBQUN4QjtBQUNPLFNBQVMsZ0NBQWE7QUFDN0I7QUFDQSxFQUFFLE1BQU07O0FBRVI7QUFDQSxrQkFBa0IsZUFBZTtBQUNqQztBQUNBOztBQUVBLGlCQUFpQixlQUFlO0FBQ2hDLGlCQUFpQixlQUFlO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBLFNBQVMscUJBQVM7QUFDbEI7QUFDQSw4Qzs7QUNwTThCO0FBQ2E7QUFDdUM7QUFDbkUsU0FBUyxvQkFBUztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsYUFBYSxnQ0FBYSxRQUFRLEtBQUssU0FBUyxZQUFZLEVBQUUsWUFBWTtBQUMxRSxhQUFhLGdDQUFhLFFBQVEsS0FBSyxTQUFTLFlBQVksRUFBRSxZQUFZO0FBQzFFO0FBQ0E7QUFDQSxFQUFFLE1BQU07QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLGdDQUFhO0FBQ3BDLGlDQUFpQyxJQUFJO0FBQ3JDLEVBQUUsTUFBTTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsRUFBRSxNQUFNO0FBQ1I7QUFDQTtBQUNBLHNDOztBQy9DcUQ7QUFDZDtBQUNRO0FBQy9DLE1BQU0sNkJBQWtCO0FBQ1QsU0FBUyxvQkFBUztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdEQUF3RCw2QkFBa0I7QUFDMUUsZ0RBQWdELDZCQUFrQjs7QUFFbEU7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSixpQkFBaUIsZUFBZTtBQUNoQyxpQkFBaUIsZUFBZTtBQUNoQztBQUNBO0FBQ0EsZ0JBQWdCLHFCQUFTO0FBQ3pCLGlCQUFpQixnQ0FBYTtBQUM5QjtBQUNBO0FBQ0E7QUFDQSxzQzs7QUM1Q3dFO0FBQzlCO0FBQzhLO0FBQ25MO0FBQ0E7QUFDRTtBQUNBO0FBQ0E7QUFDeEI7QUFDZjtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMLDJEQUEyRDtBQUMzRDtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMLHlEQUF5RDtBQUN6RDtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsZ0NBQWdDO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsZ0NBQWdDO0FBQ2hDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBLGlEOztBQzNRcUQ7QUFDWjtBQUN6QyxNQUFNLGtDQUFTO0FBQ0E7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBLGdCQUFnQixHQUFHO0FBQ25COztBQUVBO0FBQ0EsY0FBYyxHQUFHO0FBQ2pCOztBQUVBLGtCQUFrQixJQUFJLFVBQVUsa0NBQVM7O0FBRXpDO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLHdCQUF3QixnQ0FBYTs7QUFFckM7QUFDQTtBQUNBLE1BQU07QUFDTiwwQkFBMEIsZ0NBQWEsS0FBSyxrQ0FBUzs7QUFFckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9EOztBQ3REb0M7QUFDMEQ7QUFDdkQ7QUFDdkM7QUFDQSxrQ0FBa0MsaUZBQWlDO0FBQ25FO0FBQ0E7QUFDQTtBQUNBO0FBQ2U7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1AsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDOztBQzlHa0Q7QUFDdUI7QUFDckI7QUFDQTtBQUMyQjtBQUNBO0FBQzJOO0FBQzFTIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdnVlMy13ZWJwYWNrNS8uL25vZGVfbW9kdWxlcy9AbWF0aC5nbC93ZWItbWVyY2F0b3IvZGlzdC9lc20vbWF0aC11dGlscy5qcz82M2Q4Iiwid2VicGFjazovL3Z1ZTMtd2VicGFjazUvLi9ub2RlX21vZHVsZXMvQG1hdGguZ2wvd2ViLW1lcmNhdG9yL2Rpc3QvZXNtL2Fzc2VydC5qcz9hOWU5Iiwid2VicGFjazovL3Z1ZTMtd2VicGFjazUvLi9ub2RlX21vZHVsZXMvQG1hdGguZ2wvd2ViLW1lcmNhdG9yL2Rpc3QvZXNtL3dlYi1tZXJjYXRvci11dGlscy5qcz84N2VmIiwid2VicGFjazovL3Z1ZTMtd2VicGFjazUvLi9ub2RlX21vZHVsZXMvQG1hdGguZ2wvd2ViLW1lcmNhdG9yL2Rpc3QvZXNtL2ZpdC1ib3VuZHMuanM/ZDFmZiIsIndlYnBhY2s6Ly92dWUzLXdlYnBhY2s1Ly4vbm9kZV9tb2R1bGVzL0BtYXRoLmdsL3dlYi1tZXJjYXRvci9kaXN0L2VzbS9nZXQtYm91bmRzLmpzPzljMDciLCJ3ZWJwYWNrOi8vdnVlMy13ZWJwYWNrNS8uL25vZGVfbW9kdWxlcy9AbWF0aC5nbC93ZWItbWVyY2F0b3IvZGlzdC9lc20vd2ViLW1lcmNhdG9yLXZpZXdwb3J0LmpzPzUyYzIiLCJ3ZWJwYWNrOi8vdnVlMy13ZWJwYWNrNS8uL25vZGVfbW9kdWxlcy9AbWF0aC5nbC93ZWItbWVyY2F0b3IvZGlzdC9lc20vbm9ybWFsaXplLXZpZXdwb3J0LXByb3BzLmpzPzMwNDEiLCJ3ZWJwYWNrOi8vdnVlMy13ZWJwYWNrNS8uL25vZGVfbW9kdWxlcy9AbWF0aC5nbC93ZWItbWVyY2F0b3IvZGlzdC9lc20vZmx5LXRvLXZpZXdwb3J0LmpzP2JlOTEiLCJ3ZWJwYWNrOi8vdnVlMy13ZWJwYWNrNS8uL25vZGVfbW9kdWxlcy9AbWF0aC5nbC93ZWItbWVyY2F0b3IvZGlzdC9lc20vaW5kZXguanM/YmIxNiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyB0cmFuc2Zvcm1NYXQ0LCBzY2FsZSB9IGZyb20gJ2dsLW1hdHJpeC92ZWM0JztcbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVNYXQ0KCkge1xuICByZXR1cm4gWzEsIDAsIDAsIDAsIDAsIDEsIDAsIDAsIDAsIDAsIDEsIDAsIDAsIDAsIDAsIDFdO1xufVxuZXhwb3J0IGZ1bmN0aW9uIHRyYW5zZm9ybVZlY3RvcihtYXRyaXgsIHZlY3Rvcikge1xuICBjb25zdCByZXN1bHQgPSB0cmFuc2Zvcm1NYXQ0KFtdLCB2ZWN0b3IsIG1hdHJpeCk7XG4gIHNjYWxlKHJlc3VsdCwgcmVzdWx0LCAxIC8gcmVzdWx0WzNdKTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cbmV4cG9ydCBmdW5jdGlvbiBtb2QodmFsdWUsIGRpdmlzb3IpIHtcbiAgY29uc3QgbW9kdWx1cyA9IHZhbHVlICUgZGl2aXNvcjtcbiAgcmV0dXJuIG1vZHVsdXMgPCAwID8gZGl2aXNvciArIG1vZHVsdXMgOiBtb2R1bHVzO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGxlcnAoc3RhcnQsIGVuZCwgc3RlcCkge1xuICByZXR1cm4gc3RlcCAqIGVuZCArICgxIC0gc3RlcCkgKiBzdGFydDtcbn1cbmV4cG9ydCBmdW5jdGlvbiBjbGFtcCh4LCBtaW4sIG1heCkge1xuICByZXR1cm4geCA8IG1pbiA/IG1pbiA6IHggPiBtYXggPyBtYXggOiB4O1xufVxuXG5mdW5jdGlvbiBpZUxvZzIoeCkge1xuICByZXR1cm4gTWF0aC5sb2coeCkgKiBNYXRoLkxPRzJFO1xufVxuXG5leHBvcnQgY29uc3QgbG9nMiA9IE1hdGgubG9nMiB8fCBpZUxvZzI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1tYXRoLXV0aWxzLmpzLm1hcCIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGFzc2VydChjb25kaXRpb24sIG1lc3NhZ2UpIHtcbiAgaWYgKCFjb25kaXRpb24pIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IobWVzc2FnZSB8fCAnQG1hdGguZ2wvd2ViLW1lcmNhdG9yOiBhc3NlcnRpb24gZmFpbGVkLicpO1xuICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1hc3NlcnQuanMubWFwIiwiaW1wb3J0IHsgY3JlYXRlTWF0NCwgdHJhbnNmb3JtVmVjdG9yLCBjbGFtcCwgbG9nMiB9IGZyb20gJy4vbWF0aC11dGlscyc7XG5pbXBvcnQgKiBhcyBtYXQ0IGZyb20gJ2dsLW1hdHJpeC9tYXQ0JztcbmltcG9ydCAqIGFzIHZlYzIgZnJvbSAnZ2wtbWF0cml4L3ZlYzInO1xuaW1wb3J0ICogYXMgdmVjMyBmcm9tICdnbC1tYXRyaXgvdmVjMyc7XG5pbXBvcnQgYXNzZXJ0IGZyb20gJy4vYXNzZXJ0JztcbmNvbnN0IFBJID0gTWF0aC5QSTtcbmNvbnN0IFBJXzQgPSBQSSAvIDQ7XG5jb25zdCBERUdSRUVTX1RPX1JBRElBTlMgPSBQSSAvIDE4MDtcbmNvbnN0IFJBRElBTlNfVE9fREVHUkVFUyA9IDE4MCAvIFBJO1xuY29uc3QgVElMRV9TSVpFID0gNTEyO1xuY29uc3QgRUFSVEhfQ0lSQ1VNRkVSRU5DRSA9IDQwLjAzZTY7XG5leHBvcnQgY29uc3QgTUFYX0xBVElUVURFID0gODUuMDUxMTI5O1xuZXhwb3J0IGNvbnN0IERFRkFVTFRfQUxUSVRVREUgPSAxLjU7XG5leHBvcnQgZnVuY3Rpb24gem9vbVRvU2NhbGUoem9vbSkge1xuICByZXR1cm4gTWF0aC5wb3coMiwgem9vbSk7XG59XG5leHBvcnQgZnVuY3Rpb24gc2NhbGVUb1pvb20oc2NhbGUpIHtcbiAgcmV0dXJuIGxvZzIoc2NhbGUpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGxuZ0xhdFRvV29ybGQobG5nTGF0KSB7XG4gIGNvbnN0IFtsbmcsIGxhdF0gPSBsbmdMYXQ7XG4gIGFzc2VydChOdW1iZXIuaXNGaW5pdGUobG5nKSk7XG4gIGFzc2VydChOdW1iZXIuaXNGaW5pdGUobGF0KSAmJiBsYXQgPj0gLTkwICYmIGxhdCA8PSA5MCwgJ2ludmFsaWQgbGF0aXR1ZGUnKTtcbiAgY29uc3QgbGFtYmRhMiA9IGxuZyAqIERFR1JFRVNfVE9fUkFESUFOUztcbiAgY29uc3QgcGhpMiA9IGxhdCAqIERFR1JFRVNfVE9fUkFESUFOUztcbiAgY29uc3QgeCA9IFRJTEVfU0laRSAqIChsYW1iZGEyICsgUEkpIC8gKDIgKiBQSSk7XG4gIGNvbnN0IHkgPSBUSUxFX1NJWkUgKiAoUEkgKyBNYXRoLmxvZyhNYXRoLnRhbihQSV80ICsgcGhpMiAqIDAuNSkpKSAvICgyICogUEkpO1xuICByZXR1cm4gW3gsIHldO1xufVxuZXhwb3J0IGZ1bmN0aW9uIHdvcmxkVG9MbmdMYXQoeHkpIHtcbiAgY29uc3QgW3gsIHldID0geHk7XG4gIGNvbnN0IGxhbWJkYTIgPSB4IC8gVElMRV9TSVpFICogKDIgKiBQSSkgLSBQSTtcbiAgY29uc3QgcGhpMiA9IDIgKiAoTWF0aC5hdGFuKE1hdGguZXhwKHkgLyBUSUxFX1NJWkUgKiAoMiAqIFBJKSAtIFBJKSkgLSBQSV80KTtcbiAgcmV0dXJuIFtsYW1iZGEyICogUkFESUFOU19UT19ERUdSRUVTLCBwaGkyICogUkFESUFOU19UT19ERUdSRUVTXTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBnZXRNZXRlclpvb20ob3B0aW9ucykge1xuICBjb25zdCB7XG4gICAgbGF0aXR1ZGVcbiAgfSA9IG9wdGlvbnM7XG4gIGFzc2VydChOdW1iZXIuaXNGaW5pdGUobGF0aXR1ZGUpKTtcbiAgY29uc3QgbGF0Q29zaW5lID0gTWF0aC5jb3MobGF0aXR1ZGUgKiBERUdSRUVTX1RPX1JBRElBTlMpO1xuICByZXR1cm4gc2NhbGVUb1pvb20oRUFSVEhfQ0lSQ1VNRkVSRU5DRSAqIGxhdENvc2luZSkgLSA5O1xufVxuZXhwb3J0IGZ1bmN0aW9uIHVuaXRzUGVyTWV0ZXIobGF0aXR1ZGUpIHtcbiAgY29uc3QgbGF0Q29zaW5lID0gTWF0aC5jb3MobGF0aXR1ZGUgKiBERUdSRUVTX1RPX1JBRElBTlMpO1xuICByZXR1cm4gVElMRV9TSVpFIC8gRUFSVEhfQ0lSQ1VNRkVSRU5DRSAvIGxhdENvc2luZTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBnZXREaXN0YW5jZVNjYWxlcyhvcHRpb25zKSB7XG4gIGNvbnN0IHtcbiAgICBsYXRpdHVkZSxcbiAgICBsb25naXR1ZGUsXG4gICAgaGlnaFByZWNpc2lvbiA9IGZhbHNlXG4gIH0gPSBvcHRpb25zO1xuICBhc3NlcnQoTnVtYmVyLmlzRmluaXRlKGxhdGl0dWRlKSAmJiBOdW1iZXIuaXNGaW5pdGUobG9uZ2l0dWRlKSk7XG4gIGNvbnN0IHdvcmxkU2l6ZSA9IFRJTEVfU0laRTtcbiAgY29uc3QgbGF0Q29zaW5lID0gTWF0aC5jb3MobGF0aXR1ZGUgKiBERUdSRUVTX1RPX1JBRElBTlMpO1xuICBjb25zdCB1bml0c1BlckRlZ3JlZVggPSB3b3JsZFNpemUgLyAzNjA7XG4gIGNvbnN0IHVuaXRzUGVyRGVncmVlWSA9IHVuaXRzUGVyRGVncmVlWCAvIGxhdENvc2luZTtcbiAgY29uc3QgYWx0VW5pdHNQZXJNZXRlciA9IHdvcmxkU2l6ZSAvIEVBUlRIX0NJUkNVTUZFUkVOQ0UgLyBsYXRDb3NpbmU7XG4gIGNvbnN0IHJlc3VsdCA9IHtcbiAgICB1bml0c1Blck1ldGVyOiBbYWx0VW5pdHNQZXJNZXRlciwgYWx0VW5pdHNQZXJNZXRlciwgYWx0VW5pdHNQZXJNZXRlcl0sXG4gICAgbWV0ZXJzUGVyVW5pdDogWzEgLyBhbHRVbml0c1Blck1ldGVyLCAxIC8gYWx0VW5pdHNQZXJNZXRlciwgMSAvIGFsdFVuaXRzUGVyTWV0ZXJdLFxuICAgIHVuaXRzUGVyRGVncmVlOiBbdW5pdHNQZXJEZWdyZWVYLCB1bml0c1BlckRlZ3JlZVksIGFsdFVuaXRzUGVyTWV0ZXJdLFxuICAgIGRlZ3JlZXNQZXJVbml0OiBbMSAvIHVuaXRzUGVyRGVncmVlWCwgMSAvIHVuaXRzUGVyRGVncmVlWSwgMSAvIGFsdFVuaXRzUGVyTWV0ZXJdXG4gIH07XG5cbiAgaWYgKGhpZ2hQcmVjaXNpb24pIHtcbiAgICBjb25zdCBsYXRDb3NpbmUyID0gREVHUkVFU19UT19SQURJQU5TICogTWF0aC50YW4obGF0aXR1ZGUgKiBERUdSRUVTX1RPX1JBRElBTlMpIC8gbGF0Q29zaW5lO1xuICAgIGNvbnN0IHVuaXRzUGVyRGVncmVlWTIgPSB1bml0c1BlckRlZ3JlZVggKiBsYXRDb3NpbmUyIC8gMjtcbiAgICBjb25zdCBhbHRVbml0c1BlckRlZ3JlZTIgPSB3b3JsZFNpemUgLyBFQVJUSF9DSVJDVU1GRVJFTkNFICogbGF0Q29zaW5lMjtcbiAgICBjb25zdCBhbHRVbml0c1Blck1ldGVyMiA9IGFsdFVuaXRzUGVyRGVncmVlMiAvIHVuaXRzUGVyRGVncmVlWSAqIGFsdFVuaXRzUGVyTWV0ZXI7XG4gICAgcmVzdWx0LnVuaXRzUGVyRGVncmVlMiA9IFswLCB1bml0c1BlckRlZ3JlZVkyLCBhbHRVbml0c1BlckRlZ3JlZTJdO1xuICAgIHJlc3VsdC51bml0c1Blck1ldGVyMiA9IFthbHRVbml0c1Blck1ldGVyMiwgMCwgYWx0VW5pdHNQZXJNZXRlcjJdO1xuICB9XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn1cbmV4cG9ydCBmdW5jdGlvbiBhZGRNZXRlcnNUb0xuZ0xhdChsbmdMYXRaLCB4eXopIHtcbiAgY29uc3QgW2xvbmdpdHVkZSwgbGF0aXR1ZGUsIHowXSA9IGxuZ0xhdFo7XG4gIGNvbnN0IFt4LCB5LCB6XSA9IHh5ejtcbiAgY29uc3Qge1xuICAgIHVuaXRzUGVyTWV0ZXIsXG4gICAgdW5pdHNQZXJNZXRlcjJcbiAgfSA9IGdldERpc3RhbmNlU2NhbGVzKHtcbiAgICBsb25naXR1ZGUsXG4gICAgbGF0aXR1ZGUsXG4gICAgaGlnaFByZWNpc2lvbjogdHJ1ZVxuICB9KTtcbiAgY29uc3Qgd29ybGRzcGFjZSA9IGxuZ0xhdFRvV29ybGQobG5nTGF0Wik7XG4gIHdvcmxkc3BhY2VbMF0gKz0geCAqICh1bml0c1Blck1ldGVyWzBdICsgdW5pdHNQZXJNZXRlcjJbMF0gKiB5KTtcbiAgd29ybGRzcGFjZVsxXSArPSB5ICogKHVuaXRzUGVyTWV0ZXJbMV0gKyB1bml0c1Blck1ldGVyMlsxXSAqIHkpO1xuICBjb25zdCBuZXdMbmdMYXQgPSB3b3JsZFRvTG5nTGF0KHdvcmxkc3BhY2UpO1xuICBjb25zdCBuZXdaID0gKHowIHx8IDApICsgKHogfHwgMCk7XG4gIHJldHVybiBOdW1iZXIuaXNGaW5pdGUoejApIHx8IE51bWJlci5pc0Zpbml0ZSh6KSA/IFtuZXdMbmdMYXRbMF0sIG5ld0xuZ0xhdFsxXSwgbmV3Wl0gOiBuZXdMbmdMYXQ7XG59XG5leHBvcnQgZnVuY3Rpb24gZ2V0Vmlld01hdHJpeChvcHRpb25zKSB7XG4gIGNvbnN0IHtcbiAgICBoZWlnaHQsXG4gICAgcGl0Y2gsXG4gICAgYmVhcmluZyxcbiAgICBhbHRpdHVkZSxcbiAgICBzY2FsZSxcbiAgICBjZW50ZXJcbiAgfSA9IG9wdGlvbnM7XG4gIGNvbnN0IHZtID0gY3JlYXRlTWF0NCgpO1xuICBtYXQ0LnRyYW5zbGF0ZSh2bSwgdm0sIFswLCAwLCAtYWx0aXR1ZGVdKTtcbiAgbWF0NC5yb3RhdGVYKHZtLCB2bSwgLXBpdGNoICogREVHUkVFU19UT19SQURJQU5TKTtcbiAgbWF0NC5yb3RhdGVaKHZtLCB2bSwgYmVhcmluZyAqIERFR1JFRVNfVE9fUkFESUFOUyk7XG4gIGNvbnN0IHJlbGF0aXZlU2NhbGUgPSBzY2FsZSAvIGhlaWdodDtcbiAgbWF0NC5zY2FsZSh2bSwgdm0sIFtyZWxhdGl2ZVNjYWxlLCByZWxhdGl2ZVNjYWxlLCByZWxhdGl2ZVNjYWxlXSk7XG5cbiAgaWYgKGNlbnRlcikge1xuICAgIG1hdDQudHJhbnNsYXRlKHZtLCB2bSwgdmVjMy5uZWdhdGUoW10sIGNlbnRlcikpO1xuICB9XG5cbiAgcmV0dXJuIHZtO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGdldFByb2plY3Rpb25QYXJhbWV0ZXJzKG9wdGlvbnMpIHtcbiAgY29uc3Qge1xuICAgIHdpZHRoLFxuICAgIGhlaWdodCxcbiAgICBhbHRpdHVkZSxcbiAgICBwaXRjaCA9IDAsXG4gICAgb2Zmc2V0LFxuICAgIGNlbnRlcixcbiAgICBzY2FsZSxcbiAgICBuZWFyWk11bHRpcGxpZXIgPSAxLFxuICAgIGZhclpNdWx0aXBsaWVyID0gMVxuICB9ID0gb3B0aW9ucztcbiAgbGV0IHtcbiAgICBmb3Z5ID0gYWx0aXR1ZGVUb0ZvdnkoREVGQVVMVF9BTFRJVFVERSlcbiAgfSA9IG9wdGlvbnM7XG5cbiAgaWYgKGFsdGl0dWRlICE9PSB1bmRlZmluZWQpIHtcbiAgICBmb3Z5ID0gYWx0aXR1ZGVUb0ZvdnkoYWx0aXR1ZGUpO1xuICB9XG5cbiAgY29uc3QgZm92UmFkaWFucyA9IGZvdnkgKiBERUdSRUVTX1RPX1JBRElBTlM7XG4gIGNvbnN0IHBpdGNoUmFkaWFucyA9IHBpdGNoICogREVHUkVFU19UT19SQURJQU5TO1xuICBjb25zdCBmb2NhbERpc3RhbmNlID0gZm92eVRvQWx0aXR1ZGUoZm92eSk7XG4gIGxldCBjYW1lcmFUb1NlYUxldmVsRGlzdGFuY2UgPSBmb2NhbERpc3RhbmNlO1xuXG4gIGlmIChjZW50ZXIpIHtcbiAgICBjYW1lcmFUb1NlYUxldmVsRGlzdGFuY2UgKz0gY2VudGVyWzJdICogc2NhbGUgLyBNYXRoLmNvcyhwaXRjaFJhZGlhbnMpIC8gaGVpZ2h0O1xuICB9XG5cbiAgY29uc3QgZm92QWJvdmVDZW50ZXIgPSBmb3ZSYWRpYW5zICogKDAuNSArIChvZmZzZXQgPyBvZmZzZXRbMV0gOiAwKSAvIGhlaWdodCk7XG4gIGNvbnN0IHRvcEhhbGZTdXJmYWNlRGlzdGFuY2UgPSBNYXRoLnNpbihmb3ZBYm92ZUNlbnRlcikgKiBjYW1lcmFUb1NlYUxldmVsRGlzdGFuY2UgLyBNYXRoLnNpbihjbGFtcChNYXRoLlBJIC8gMiAtIHBpdGNoUmFkaWFucyAtIGZvdkFib3ZlQ2VudGVyLCAwLjAxLCBNYXRoLlBJIC0gMC4wMSkpO1xuICBjb25zdCBmdXJ0aGVzdERpc3RhbmNlID0gTWF0aC5zaW4ocGl0Y2hSYWRpYW5zKSAqIHRvcEhhbGZTdXJmYWNlRGlzdGFuY2UgKyBjYW1lcmFUb1NlYUxldmVsRGlzdGFuY2U7XG4gIGNvbnN0IGhvcml6b25EaXN0YW5jZSA9IGNhbWVyYVRvU2VhTGV2ZWxEaXN0YW5jZSAqIDEwO1xuICBjb25zdCBmYXJaID0gTWF0aC5taW4oZnVydGhlc3REaXN0YW5jZSAqIGZhclpNdWx0aXBsaWVyLCBob3Jpem9uRGlzdGFuY2UpO1xuICByZXR1cm4ge1xuICAgIGZvdjogZm92UmFkaWFucyxcbiAgICBhc3BlY3Q6IHdpZHRoIC8gaGVpZ2h0LFxuICAgIGZvY2FsRGlzdGFuY2UsXG4gICAgbmVhcjogbmVhclpNdWx0aXBsaWVyLFxuICAgIGZhcjogZmFyWlxuICB9O1xufVxuZXhwb3J0IGZ1bmN0aW9uIGdldFByb2plY3Rpb25NYXRyaXgob3B0aW9ucykge1xuICBjb25zdCB7XG4gICAgZm92LFxuICAgIGFzcGVjdCxcbiAgICBuZWFyLFxuICAgIGZhclxuICB9ID0gZ2V0UHJvamVjdGlvblBhcmFtZXRlcnMob3B0aW9ucyk7XG4gIGNvbnN0IHByb2plY3Rpb25NYXRyaXggPSBtYXQ0LnBlcnNwZWN0aXZlKFtdLCBmb3YsIGFzcGVjdCwgbmVhciwgZmFyKTtcbiAgcmV0dXJuIHByb2plY3Rpb25NYXRyaXg7XG59XG5leHBvcnQgZnVuY3Rpb24gYWx0aXR1ZGVUb0ZvdnkoYWx0aXR1ZGUpIHtcbiAgcmV0dXJuIDIgKiBNYXRoLmF0YW4oMC41IC8gYWx0aXR1ZGUpICogUkFESUFOU19UT19ERUdSRUVTO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGZvdnlUb0FsdGl0dWRlKGZvdnkpIHtcbiAgcmV0dXJuIDAuNSAvIE1hdGgudGFuKDAuNSAqIGZvdnkgKiBERUdSRUVTX1RPX1JBRElBTlMpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIHdvcmxkVG9QaXhlbHMoeHl6LCBwaXhlbFByb2plY3Rpb25NYXRyaXgpIHtcbiAgY29uc3QgW3gsIHksIHogPSAwXSA9IHh5ejtcbiAgYXNzZXJ0KE51bWJlci5pc0Zpbml0ZSh4KSAmJiBOdW1iZXIuaXNGaW5pdGUoeSkgJiYgTnVtYmVyLmlzRmluaXRlKHopKTtcbiAgcmV0dXJuIHRyYW5zZm9ybVZlY3RvcihwaXhlbFByb2plY3Rpb25NYXRyaXgsIFt4LCB5LCB6LCAxXSk7XG59XG5leHBvcnQgZnVuY3Rpb24gcGl4ZWxzVG9Xb3JsZCh4eXosIHBpeGVsVW5wcm9qZWN0aW9uTWF0cml4LCB0YXJnZXRaID0gMCkge1xuICBjb25zdCBbeCwgeSwgel0gPSB4eXo7XG4gIGFzc2VydChOdW1iZXIuaXNGaW5pdGUoeCkgJiYgTnVtYmVyLmlzRmluaXRlKHkpLCAnaW52YWxpZCBwaXhlbCBjb29yZGluYXRlJyk7XG5cbiAgaWYgKE51bWJlci5pc0Zpbml0ZSh6KSkge1xuICAgIGNvbnN0IGNvb3JkID0gdHJhbnNmb3JtVmVjdG9yKHBpeGVsVW5wcm9qZWN0aW9uTWF0cml4LCBbeCwgeSwgeiwgMV0pO1xuICAgIHJldHVybiBjb29yZDtcbiAgfVxuXG4gIGNvbnN0IGNvb3JkMCA9IHRyYW5zZm9ybVZlY3RvcihwaXhlbFVucHJvamVjdGlvbk1hdHJpeCwgW3gsIHksIDAsIDFdKTtcbiAgY29uc3QgY29vcmQxID0gdHJhbnNmb3JtVmVjdG9yKHBpeGVsVW5wcm9qZWN0aW9uTWF0cml4LCBbeCwgeSwgMSwgMV0pO1xuICBjb25zdCB6MCA9IGNvb3JkMFsyXTtcbiAgY29uc3QgejEgPSBjb29yZDFbMl07XG4gIGNvbnN0IHQgPSB6MCA9PT0gejEgPyAwIDogKCh0YXJnZXRaIHx8IDApIC0gejApIC8gKHoxIC0gejApO1xuICByZXR1cm4gdmVjMi5sZXJwKFtdLCBjb29yZDAsIGNvb3JkMSwgdCk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD13ZWItbWVyY2F0b3ItdXRpbHMuanMubWFwIiwiaW1wb3J0IGFzc2VydCBmcm9tICcuL2Fzc2VydCc7XG5pbXBvcnQgeyBsb2cyLCBjbGFtcCB9IGZyb20gJy4vbWF0aC11dGlscyc7XG5pbXBvcnQgeyBNQVhfTEFUSVRVREUsIGxuZ0xhdFRvV29ybGQsIHdvcmxkVG9MbmdMYXQgfSBmcm9tICcuL3dlYi1tZXJjYXRvci11dGlscyc7XG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBmaXRCb3VuZHMob3B0aW9ucykge1xuICBjb25zdCB7XG4gICAgd2lkdGgsXG4gICAgaGVpZ2h0LFxuICAgIGJvdW5kcyxcbiAgICBtaW5FeHRlbnQgPSAwLFxuICAgIG1heFpvb20gPSAyNCxcbiAgICBvZmZzZXQgPSBbMCwgMF1cbiAgfSA9IG9wdGlvbnM7XG4gIGNvbnN0IFtbd2VzdCwgc291dGhdLCBbZWFzdCwgbm9ydGhdXSA9IGJvdW5kcztcbiAgY29uc3QgcGFkZGluZyA9IGdldFBhZGRpbmdPYmplY3Qob3B0aW9ucy5wYWRkaW5nKTtcbiAgY29uc3QgbncgPSBsbmdMYXRUb1dvcmxkKFt3ZXN0LCBjbGFtcChub3J0aCwgLU1BWF9MQVRJVFVERSwgTUFYX0xBVElUVURFKV0pO1xuICBjb25zdCBzZSA9IGxuZ0xhdFRvV29ybGQoW2Vhc3QsIGNsYW1wKHNvdXRoLCAtTUFYX0xBVElUVURFLCBNQVhfTEFUSVRVREUpXSk7XG4gIGNvbnN0IHNpemUgPSBbTWF0aC5tYXgoTWF0aC5hYnMoc2VbMF0gLSBud1swXSksIG1pbkV4dGVudCksIE1hdGgubWF4KE1hdGguYWJzKHNlWzFdIC0gbndbMV0pLCBtaW5FeHRlbnQpXTtcbiAgY29uc3QgdGFyZ2V0U2l6ZSA9IFt3aWR0aCAtIHBhZGRpbmcubGVmdCAtIHBhZGRpbmcucmlnaHQgLSBNYXRoLmFicyhvZmZzZXRbMF0pICogMiwgaGVpZ2h0IC0gcGFkZGluZy50b3AgLSBwYWRkaW5nLmJvdHRvbSAtIE1hdGguYWJzKG9mZnNldFsxXSkgKiAyXTtcbiAgYXNzZXJ0KHRhcmdldFNpemVbMF0gPiAwICYmIHRhcmdldFNpemVbMV0gPiAwKTtcbiAgY29uc3Qgc2NhbGVYID0gdGFyZ2V0U2l6ZVswXSAvIHNpemVbMF07XG4gIGNvbnN0IHNjYWxlWSA9IHRhcmdldFNpemVbMV0gLyBzaXplWzFdO1xuICBjb25zdCBvZmZzZXRYID0gKHBhZGRpbmcucmlnaHQgLSBwYWRkaW5nLmxlZnQpIC8gMiAvIHNjYWxlWDtcbiAgY29uc3Qgb2Zmc2V0WSA9IChwYWRkaW5nLnRvcCAtIHBhZGRpbmcuYm90dG9tKSAvIDIgLyBzY2FsZVk7XG4gIGNvbnN0IGNlbnRlciA9IFsoc2VbMF0gKyBud1swXSkgLyAyICsgb2Zmc2V0WCwgKHNlWzFdICsgbndbMV0pIC8gMiArIG9mZnNldFldO1xuICBjb25zdCBjZW50ZXJMbmdMYXQgPSB3b3JsZFRvTG5nTGF0KGNlbnRlcik7XG4gIGNvbnN0IHpvb20gPSBNYXRoLm1pbihtYXhab29tLCBsb2cyKE1hdGguYWJzKE1hdGgubWluKHNjYWxlWCwgc2NhbGVZKSkpKTtcbiAgYXNzZXJ0KE51bWJlci5pc0Zpbml0ZSh6b29tKSk7XG4gIHJldHVybiB7XG4gICAgbG9uZ2l0dWRlOiBjZW50ZXJMbmdMYXRbMF0sXG4gICAgbGF0aXR1ZGU6IGNlbnRlckxuZ0xhdFsxXSxcbiAgICB6b29tXG4gIH07XG59XG5cbmZ1bmN0aW9uIGdldFBhZGRpbmdPYmplY3QocGFkZGluZyA9IDApIHtcbiAgaWYgKHR5cGVvZiBwYWRkaW5nID09PSAnbnVtYmVyJykge1xuICAgIHJldHVybiB7XG4gICAgICB0b3A6IHBhZGRpbmcsXG4gICAgICBib3R0b206IHBhZGRpbmcsXG4gICAgICBsZWZ0OiBwYWRkaW5nLFxuICAgICAgcmlnaHQ6IHBhZGRpbmdcbiAgICB9O1xuICB9XG5cbiAgYXNzZXJ0KE51bWJlci5pc0Zpbml0ZShwYWRkaW5nLnRvcCkgJiYgTnVtYmVyLmlzRmluaXRlKHBhZGRpbmcuYm90dG9tKSAmJiBOdW1iZXIuaXNGaW5pdGUocGFkZGluZy5sZWZ0KSAmJiBOdW1iZXIuaXNGaW5pdGUocGFkZGluZy5yaWdodCkpO1xuICByZXR1cm4gcGFkZGluZztcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWZpdC1ib3VuZHMuanMubWFwIiwiaW1wb3J0IHsgd29ybGRUb0xuZ0xhdCB9IGZyb20gJy4vd2ViLW1lcmNhdG9yLXV0aWxzJztcbmltcG9ydCAqIGFzIHZlYzIgZnJvbSAnZ2wtbWF0cml4L3ZlYzInO1xuaW1wb3J0IHsgdHJhbnNmb3JtVmVjdG9yIH0gZnJvbSAnLi9tYXRoLXV0aWxzJztcbmNvbnN0IERFR1JFRVNfVE9fUkFESUFOUyA9IE1hdGguUEkgLyAxODA7XG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBnZXRCb3VuZHModmlld3BvcnQsIHogPSAwKSB7XG4gIGNvbnN0IHtcbiAgICB3aWR0aCxcbiAgICBoZWlnaHQsXG4gICAgdW5wcm9qZWN0XG4gIH0gPSB2aWV3cG9ydDtcbiAgY29uc3QgdW5wcm9qZWN0T3BzID0ge1xuICAgIHRhcmdldFo6IHpcbiAgfTtcbiAgY29uc3QgYm90dG9tTGVmdCA9IHVucHJvamVjdChbMCwgaGVpZ2h0XSwgdW5wcm9qZWN0T3BzKTtcbiAgY29uc3QgYm90dG9tUmlnaHQgPSB1bnByb2plY3QoW3dpZHRoLCBoZWlnaHRdLCB1bnByb2plY3RPcHMpO1xuICBsZXQgdG9wTGVmdDtcbiAgbGV0IHRvcFJpZ2h0O1xuICBjb25zdCBoYWxmRm92ID0gdmlld3BvcnQuZm92eSA/IDAuNSAqIHZpZXdwb3J0LmZvdnkgKiBERUdSRUVTX1RPX1JBRElBTlMgOiBNYXRoLmF0YW4oMC41IC8gdmlld3BvcnQuYWx0aXR1ZGUpO1xuICBjb25zdCBhbmdsZVRvR3JvdW5kID0gKDkwIC0gdmlld3BvcnQucGl0Y2gpICogREVHUkVFU19UT19SQURJQU5TO1xuXG4gIGlmIChoYWxmRm92ID4gYW5nbGVUb0dyb3VuZCAtIDAuMDEpIHtcbiAgICB0b3BMZWZ0ID0gdW5wcm9qZWN0T25GYXJQbGFuZSh2aWV3cG9ydCwgMCwgeik7XG4gICAgdG9wUmlnaHQgPSB1bnByb2plY3RPbkZhclBsYW5lKHZpZXdwb3J0LCB3aWR0aCwgeik7XG4gIH0gZWxzZSB7XG4gICAgdG9wTGVmdCA9IHVucHJvamVjdChbMCwgMF0sIHVucHJvamVjdE9wcyk7XG4gICAgdG9wUmlnaHQgPSB1bnByb2plY3QoW3dpZHRoLCAwXSwgdW5wcm9qZWN0T3BzKTtcbiAgfVxuXG4gIHJldHVybiBbYm90dG9tTGVmdCwgYm90dG9tUmlnaHQsIHRvcFJpZ2h0LCB0b3BMZWZ0XTtcbn1cblxuZnVuY3Rpb24gdW5wcm9qZWN0T25GYXJQbGFuZSh2aWV3cG9ydCwgeCwgdGFyZ2V0Wikge1xuICBjb25zdCB7XG4gICAgcGl4ZWxVbnByb2plY3Rpb25NYXRyaXhcbiAgfSA9IHZpZXdwb3J0O1xuICBjb25zdCBjb29yZDAgPSB0cmFuc2Zvcm1WZWN0b3IocGl4ZWxVbnByb2plY3Rpb25NYXRyaXgsIFt4LCAwLCAxLCAxXSk7XG4gIGNvbnN0IGNvb3JkMSA9IHRyYW5zZm9ybVZlY3RvcihwaXhlbFVucHJvamVjdGlvbk1hdHJpeCwgW3gsIHZpZXdwb3J0LmhlaWdodCwgMSwgMV0pO1xuICBjb25zdCB6ID0gdGFyZ2V0WiAqIHZpZXdwb3J0LmRpc3RhbmNlU2NhbGVzLnVuaXRzUGVyTWV0ZXJbMl07XG4gIGNvbnN0IHQgPSAoeiAtIGNvb3JkMFsyXSkgLyAoY29vcmQxWzJdIC0gY29vcmQwWzJdKTtcbiAgY29uc3QgY29vcmQgPSB2ZWMyLmxlcnAoW10sIGNvb3JkMCwgY29vcmQxLCB0KTtcbiAgY29uc3QgcmVzdWx0ID0gd29ybGRUb0xuZ0xhdChjb29yZCk7XG4gIHJlc3VsdC5wdXNoKHRhcmdldFopO1xuICByZXR1cm4gcmVzdWx0O1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Z2V0LWJvdW5kcy5qcy5tYXAiLCJpbXBvcnQgX2RlZmluZVByb3BlcnR5IGZyb20gXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9kZWZpbmVQcm9wZXJ0eVwiO1xuaW1wb3J0IHsgY3JlYXRlTWF0NCB9IGZyb20gJy4vbWF0aC11dGlscyc7XG5pbXBvcnQgeyB6b29tVG9TY2FsZSwgcGl4ZWxzVG9Xb3JsZCwgbG5nTGF0VG9Xb3JsZCwgd29ybGRUb0xuZ0xhdCwgd29ybGRUb1BpeGVscywgYWx0aXR1ZGVUb0ZvdnksIGZvdnlUb0FsdGl0dWRlLCBERUZBVUxUX0FMVElUVURFLCBnZXRQcm9qZWN0aW9uTWF0cml4LCBnZXREaXN0YW5jZVNjYWxlcywgZ2V0Vmlld01hdHJpeCB9IGZyb20gJy4vd2ViLW1lcmNhdG9yLXV0aWxzJztcbmltcG9ydCBmaXRCb3VuZHMgZnJvbSAnLi9maXQtYm91bmRzJztcbmltcG9ydCBnZXRCb3VuZHMgZnJvbSAnLi9nZXQtYm91bmRzJztcbmltcG9ydCAqIGFzIG1hdDQgZnJvbSAnZ2wtbWF0cml4L21hdDQnO1xuaW1wb3J0ICogYXMgdmVjMiBmcm9tICdnbC1tYXRyaXgvdmVjMic7XG5pbXBvcnQgKiBhcyB2ZWMzIGZyb20gJ2dsLW1hdHJpeC92ZWMzJztcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFdlYk1lcmNhdG9yVmlld3BvcnQge1xuICBjb25zdHJ1Y3Rvcihwcm9wcyA9IHtcbiAgICB3aWR0aDogMSxcbiAgICBoZWlnaHQ6IDFcbiAgfSkge1xuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImxhdGl0dWRlXCIsIHZvaWQgMCk7XG5cbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJsb25naXR1ZGVcIiwgdm9pZCAwKTtcblxuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInpvb21cIiwgdm9pZCAwKTtcblxuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInBpdGNoXCIsIHZvaWQgMCk7XG5cbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJiZWFyaW5nXCIsIHZvaWQgMCk7XG5cbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJhbHRpdHVkZVwiLCB2b2lkIDApO1xuXG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwiZm92eVwiLCB2b2lkIDApO1xuXG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwibWV0ZXJPZmZzZXRcIiwgdm9pZCAwKTtcblxuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImNlbnRlclwiLCB2b2lkIDApO1xuXG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwid2lkdGhcIiwgdm9pZCAwKTtcblxuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImhlaWdodFwiLCB2b2lkIDApO1xuXG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwic2NhbGVcIiwgdm9pZCAwKTtcblxuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImRpc3RhbmNlU2NhbGVzXCIsIHZvaWQgMCk7XG5cbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJ2aWV3TWF0cml4XCIsIHZvaWQgMCk7XG5cbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJwcm9qZWN0aW9uTWF0cml4XCIsIHZvaWQgMCk7XG5cbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJ2aWV3UHJvamVjdGlvbk1hdHJpeFwiLCB2b2lkIDApO1xuXG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwicGl4ZWxQcm9qZWN0aW9uTWF0cml4XCIsIHZvaWQgMCk7XG5cbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJwaXhlbFVucHJvamVjdGlvbk1hdHJpeFwiLCB2b2lkIDApO1xuXG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwiZXF1YWxzXCIsIHZpZXdwb3J0ID0+IHtcbiAgICAgIGlmICghKHZpZXdwb3J0IGluc3RhbmNlb2YgV2ViTWVyY2F0b3JWaWV3cG9ydCkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdmlld3BvcnQud2lkdGggPT09IHRoaXMud2lkdGggJiYgdmlld3BvcnQuaGVpZ2h0ID09PSB0aGlzLmhlaWdodCAmJiBtYXQ0LmVxdWFscyh2aWV3cG9ydC5wcm9qZWN0aW9uTWF0cml4LCB0aGlzLnByb2plY3Rpb25NYXRyaXgpICYmIG1hdDQuZXF1YWxzKHZpZXdwb3J0LnZpZXdNYXRyaXgsIHRoaXMudmlld01hdHJpeCk7XG4gICAgfSk7XG5cbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJwcm9qZWN0XCIsIChsbmdMYXRaLCBvcHRpb25zID0ge30pID0+IHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgdG9wTGVmdCA9IHRydWVcbiAgICAgIH0gPSBvcHRpb25zO1xuICAgICAgY29uc3Qgd29ybGRQb3NpdGlvbiA9IHRoaXMucHJvamVjdFBvc2l0aW9uKGxuZ0xhdFopO1xuICAgICAgY29uc3QgY29vcmQgPSB3b3JsZFRvUGl4ZWxzKHdvcmxkUG9zaXRpb24sIHRoaXMucGl4ZWxQcm9qZWN0aW9uTWF0cml4KTtcbiAgICAgIGNvbnN0IFt4LCB5XSA9IGNvb3JkO1xuICAgICAgY29uc3QgeTIgPSB0b3BMZWZ0ID8geSA6IHRoaXMuaGVpZ2h0IC0geTtcbiAgICAgIHJldHVybiBsbmdMYXRaLmxlbmd0aCA9PT0gMiA/IFt4LCB5Ml0gOiBbeCwgeTIsIGNvb3JkWzJdXTtcbiAgICB9KTtcblxuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInVucHJvamVjdFwiLCAoeHl6LCBvcHRpb25zID0ge30pID0+IHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgdG9wTGVmdCA9IHRydWUsXG4gICAgICAgIHRhcmdldFogPSB1bmRlZmluZWRcbiAgICAgIH0gPSBvcHRpb25zO1xuICAgICAgY29uc3QgW3gsIHksIHpdID0geHl6O1xuICAgICAgY29uc3QgeTIgPSB0b3BMZWZ0ID8geSA6IHRoaXMuaGVpZ2h0IC0geTtcbiAgICAgIGNvbnN0IHRhcmdldFpXb3JsZCA9IHRhcmdldFogJiYgdGFyZ2V0WiAqIHRoaXMuZGlzdGFuY2VTY2FsZXMudW5pdHNQZXJNZXRlclsyXTtcbiAgICAgIGNvbnN0IGNvb3JkID0gcGl4ZWxzVG9Xb3JsZChbeCwgeTIsIHpdLCB0aGlzLnBpeGVsVW5wcm9qZWN0aW9uTWF0cml4LCB0YXJnZXRaV29ybGQpO1xuICAgICAgY29uc3QgW1gsIFksIFpdID0gdGhpcy51bnByb2plY3RQb3NpdGlvbihjb29yZCk7XG5cbiAgICAgIGlmIChOdW1iZXIuaXNGaW5pdGUoeikpIHtcbiAgICAgICAgcmV0dXJuIFtYLCBZLCBaXTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIE51bWJlci5pc0Zpbml0ZSh0YXJnZXRaKSA/IFtYLCBZLCB0YXJnZXRaXSA6IFtYLCBZXTtcbiAgICB9KTtcblxuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInByb2plY3RQb3NpdGlvblwiLCB4eXogPT4ge1xuICAgICAgY29uc3QgW1gsIFldID0gbG5nTGF0VG9Xb3JsZCh4eXopO1xuICAgICAgY29uc3QgWiA9ICh4eXpbMl0gfHwgMCkgKiB0aGlzLmRpc3RhbmNlU2NhbGVzLnVuaXRzUGVyTWV0ZXJbMl07XG4gICAgICByZXR1cm4gW1gsIFksIFpdO1xuICAgIH0pO1xuXG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwidW5wcm9qZWN0UG9zaXRpb25cIiwgeHl6ID0+IHtcbiAgICAgIGNvbnN0IFtYLCBZXSA9IHdvcmxkVG9MbmdMYXQoeHl6KTtcbiAgICAgIGNvbnN0IFogPSAoeHl6WzJdIHx8IDApICogdGhpcy5kaXN0YW5jZVNjYWxlcy5tZXRlcnNQZXJVbml0WzJdO1xuICAgICAgcmV0dXJuIFtYLCBZLCBaXTtcbiAgICB9KTtcblxuICAgIGxldCB7XG4gICAgICB3aWR0aCxcbiAgICAgIGhlaWdodCxcbiAgICAgIGFsdGl0dWRlID0gbnVsbCxcbiAgICAgIGZvdnkgPSBudWxsXG4gICAgfSA9IHByb3BzO1xuICAgIGNvbnN0IHtcbiAgICAgIGxhdGl0dWRlID0gMCxcbiAgICAgIGxvbmdpdHVkZSA9IDAsXG4gICAgICB6b29tID0gMCxcbiAgICAgIHBpdGNoID0gMCxcbiAgICAgIGJlYXJpbmcgPSAwLFxuICAgICAgcG9zaXRpb24gPSBudWxsLFxuICAgICAgbmVhclpNdWx0aXBsaWVyID0gMC4wMixcbiAgICAgIGZhclpNdWx0aXBsaWVyID0gMS4wMVxuICAgIH0gPSBwcm9wcztcbiAgICB3aWR0aCA9IHdpZHRoIHx8IDE7XG4gICAgaGVpZ2h0ID0gaGVpZ2h0IHx8IDE7XG5cbiAgICBpZiAoZm92eSA9PT0gbnVsbCAmJiBhbHRpdHVkZSA9PT0gbnVsbCkge1xuICAgICAgYWx0aXR1ZGUgPSBERUZBVUxUX0FMVElUVURFO1xuICAgICAgZm92eSA9IGFsdGl0dWRlVG9Gb3Z5KGFsdGl0dWRlKTtcbiAgICB9IGVsc2UgaWYgKGZvdnkgPT09IG51bGwpIHtcbiAgICAgIGZvdnkgPSBhbHRpdHVkZVRvRm92eShhbHRpdHVkZSk7XG4gICAgfSBlbHNlIGlmIChhbHRpdHVkZSA9PT0gbnVsbCkge1xuICAgICAgYWx0aXR1ZGUgPSBmb3Z5VG9BbHRpdHVkZShmb3Z5KTtcbiAgICB9XG5cbiAgICBjb25zdCBzY2FsZSA9IHpvb21Ub1NjYWxlKHpvb20pO1xuICAgIGFsdGl0dWRlID0gTWF0aC5tYXgoMC43NSwgYWx0aXR1ZGUpO1xuICAgIGNvbnN0IGRpc3RhbmNlU2NhbGVzID0gZ2V0RGlzdGFuY2VTY2FsZXMoe1xuICAgICAgbG9uZ2l0dWRlLFxuICAgICAgbGF0aXR1ZGVcbiAgICB9KTtcbiAgICBjb25zdCBjZW50ZXIgPSBsbmdMYXRUb1dvcmxkKFtsb25naXR1ZGUsIGxhdGl0dWRlXSk7XG4gICAgY2VudGVyLnB1c2goMCk7XG5cbiAgICBpZiAocG9zaXRpb24pIHtcbiAgICAgIHZlYzMuYWRkKGNlbnRlciwgY2VudGVyLCB2ZWMzLm11bChbXSwgcG9zaXRpb24sIGRpc3RhbmNlU2NhbGVzLnVuaXRzUGVyTWV0ZXIpKTtcbiAgICB9XG5cbiAgICB0aGlzLnByb2plY3Rpb25NYXRyaXggPSBnZXRQcm9qZWN0aW9uTWF0cml4KHtcbiAgICAgIHdpZHRoLFxuICAgICAgaGVpZ2h0LFxuICAgICAgc2NhbGUsXG4gICAgICBjZW50ZXIsXG4gICAgICBwaXRjaCxcbiAgICAgIGZvdnksXG4gICAgICBuZWFyWk11bHRpcGxpZXIsXG4gICAgICBmYXJaTXVsdGlwbGllclxuICAgIH0pO1xuICAgIHRoaXMudmlld01hdHJpeCA9IGdldFZpZXdNYXRyaXgoe1xuICAgICAgaGVpZ2h0LFxuICAgICAgc2NhbGUsXG4gICAgICBjZW50ZXIsXG4gICAgICBwaXRjaCxcbiAgICAgIGJlYXJpbmcsXG4gICAgICBhbHRpdHVkZVxuICAgIH0pO1xuICAgIHRoaXMud2lkdGggPSB3aWR0aDtcbiAgICB0aGlzLmhlaWdodCA9IGhlaWdodDtcbiAgICB0aGlzLnNjYWxlID0gc2NhbGU7XG4gICAgdGhpcy5sYXRpdHVkZSA9IGxhdGl0dWRlO1xuICAgIHRoaXMubG9uZ2l0dWRlID0gbG9uZ2l0dWRlO1xuICAgIHRoaXMuem9vbSA9IHpvb207XG4gICAgdGhpcy5waXRjaCA9IHBpdGNoO1xuICAgIHRoaXMuYmVhcmluZyA9IGJlYXJpbmc7XG4gICAgdGhpcy5hbHRpdHVkZSA9IGFsdGl0dWRlO1xuICAgIHRoaXMuZm92eSA9IGZvdnk7XG4gICAgdGhpcy5jZW50ZXIgPSBjZW50ZXI7XG4gICAgdGhpcy5tZXRlck9mZnNldCA9IHBvc2l0aW9uIHx8IFswLCAwLCAwXTtcbiAgICB0aGlzLmRpc3RhbmNlU2NhbGVzID0gZGlzdGFuY2VTY2FsZXM7XG5cbiAgICB0aGlzLl9pbml0TWF0cmljZXMoKTtcblxuICAgIE9iamVjdC5mcmVlemUodGhpcyk7XG4gIH1cblxuICBfaW5pdE1hdHJpY2VzKCkge1xuICAgIGNvbnN0IHtcbiAgICAgIHdpZHRoLFxuICAgICAgaGVpZ2h0LFxuICAgICAgcHJvamVjdGlvbk1hdHJpeCxcbiAgICAgIHZpZXdNYXRyaXhcbiAgICB9ID0gdGhpcztcbiAgICBjb25zdCB2cG0gPSBjcmVhdGVNYXQ0KCk7XG4gICAgbWF0NC5tdWx0aXBseSh2cG0sIHZwbSwgcHJvamVjdGlvbk1hdHJpeCk7XG4gICAgbWF0NC5tdWx0aXBseSh2cG0sIHZwbSwgdmlld01hdHJpeCk7XG4gICAgdGhpcy52aWV3UHJvamVjdGlvbk1hdHJpeCA9IHZwbTtcbiAgICBjb25zdCBtID0gY3JlYXRlTWF0NCgpO1xuICAgIG1hdDQuc2NhbGUobSwgbSwgW3dpZHRoIC8gMiwgLWhlaWdodCAvIDIsIDFdKTtcbiAgICBtYXQ0LnRyYW5zbGF0ZShtLCBtLCBbMSwgLTEsIDBdKTtcbiAgICBtYXQ0Lm11bHRpcGx5KG0sIG0sIHZwbSk7XG4gICAgY29uc3QgbUludmVyc2UgPSBtYXQ0LmludmVydChjcmVhdGVNYXQ0KCksIG0pO1xuXG4gICAgaWYgKCFtSW52ZXJzZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdQaXhlbCBwcm9qZWN0IG1hdHJpeCBub3QgaW52ZXJ0aWJsZScpO1xuICAgIH1cblxuICAgIHRoaXMucGl4ZWxQcm9qZWN0aW9uTWF0cml4ID0gbTtcbiAgICB0aGlzLnBpeGVsVW5wcm9qZWN0aW9uTWF0cml4ID0gbUludmVyc2U7XG4gIH1cblxuICBwcm9qZWN0RmxhdChsbmdMYXQpIHtcbiAgICByZXR1cm4gbG5nTGF0VG9Xb3JsZChsbmdMYXQpO1xuICB9XG5cbiAgdW5wcm9qZWN0RmxhdCh4eSkge1xuICAgIHJldHVybiB3b3JsZFRvTG5nTGF0KHh5KTtcbiAgfVxuXG4gIGdldE1hcENlbnRlckJ5TG5nTGF0UG9zaXRpb24oe1xuICAgIGxuZ0xhdCxcbiAgICBwb3NcbiAgfSkge1xuICAgIGNvbnN0IGZyb21Mb2NhdGlvbiA9IHBpeGVsc1RvV29ybGQocG9zLCB0aGlzLnBpeGVsVW5wcm9qZWN0aW9uTWF0cml4KTtcbiAgICBjb25zdCB0b0xvY2F0aW9uID0gbG5nTGF0VG9Xb3JsZChsbmdMYXQpO1xuICAgIGNvbnN0IHRyYW5zbGF0ZSA9IHZlYzIuYWRkKFtdLCB0b0xvY2F0aW9uLCB2ZWMyLm5lZ2F0ZShbXSwgZnJvbUxvY2F0aW9uKSk7XG4gICAgY29uc3QgbmV3Q2VudGVyID0gdmVjMi5hZGQoW10sIHRoaXMuY2VudGVyLCB0cmFuc2xhdGUpO1xuICAgIHJldHVybiB3b3JsZFRvTG5nTGF0KG5ld0NlbnRlcik7XG4gIH1cblxuICBmaXRCb3VuZHMoYm91bmRzLCBvcHRpb25zID0ge30pIHtcbiAgICBjb25zdCB7XG4gICAgICB3aWR0aCxcbiAgICAgIGhlaWdodFxuICAgIH0gPSB0aGlzO1xuICAgIGNvbnN0IHtcbiAgICAgIGxvbmdpdHVkZSxcbiAgICAgIGxhdGl0dWRlLFxuICAgICAgem9vbVxuICAgIH0gPSBmaXRCb3VuZHMoT2JqZWN0LmFzc2lnbih7XG4gICAgICB3aWR0aCxcbiAgICAgIGhlaWdodCxcbiAgICAgIGJvdW5kc1xuICAgIH0sIG9wdGlvbnMpKTtcbiAgICByZXR1cm4gbmV3IFdlYk1lcmNhdG9yVmlld3BvcnQoe1xuICAgICAgd2lkdGgsXG4gICAgICBoZWlnaHQsXG4gICAgICBsb25naXR1ZGUsXG4gICAgICBsYXRpdHVkZSxcbiAgICAgIHpvb21cbiAgICB9KTtcbiAgfVxuXG4gIGdldEJvdW5kcyhvcHRpb25zKSB7XG4gICAgY29uc3QgY29ybmVycyA9IHRoaXMuZ2V0Qm91bmRpbmdSZWdpb24ob3B0aW9ucyk7XG4gICAgY29uc3Qgd2VzdCA9IE1hdGgubWluKC4uLmNvcm5lcnMubWFwKHAgPT4gcFswXSkpO1xuICAgIGNvbnN0IGVhc3QgPSBNYXRoLm1heCguLi5jb3JuZXJzLm1hcChwID0+IHBbMF0pKTtcbiAgICBjb25zdCBzb3V0aCA9IE1hdGgubWluKC4uLmNvcm5lcnMubWFwKHAgPT4gcFsxXSkpO1xuICAgIGNvbnN0IG5vcnRoID0gTWF0aC5tYXgoLi4uY29ybmVycy5tYXAocCA9PiBwWzFdKSk7XG4gICAgcmV0dXJuIFtbd2VzdCwgc291dGhdLCBbZWFzdCwgbm9ydGhdXTtcbiAgfVxuXG4gIGdldEJvdW5kaW5nUmVnaW9uKG9wdGlvbnMgPSB7fSkge1xuICAgIHJldHVybiBnZXRCb3VuZHModGhpcywgb3B0aW9ucy56IHx8IDApO1xuICB9XG5cbiAgZ2V0TG9jYXRpb25BdFBvaW50KHtcbiAgICBsbmdMYXQsXG4gICAgcG9zXG4gIH0pIHtcbiAgICByZXR1cm4gdGhpcy5nZXRNYXBDZW50ZXJCeUxuZ0xhdFBvc2l0aW9uKHtcbiAgICAgIGxuZ0xhdCxcbiAgICAgIHBvc1xuICAgIH0pO1xuICB9XG5cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXdlYi1tZXJjYXRvci12aWV3cG9ydC5qcy5tYXAiLCJpbXBvcnQgeyB3b3JsZFRvTG5nTGF0IH0gZnJvbSAnLi93ZWItbWVyY2F0b3ItdXRpbHMnO1xuaW1wb3J0IHsgbW9kLCBsb2cyIH0gZnJvbSAnLi9tYXRoLXV0aWxzJztcbmNvbnN0IFRJTEVfU0laRSA9IDUxMjtcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIG5vcm1hbGl6ZVZpZXdwb3J0UHJvcHMocHJvcHMpIHtcbiAgY29uc3Qge1xuICAgIHdpZHRoLFxuICAgIGhlaWdodCxcbiAgICBwaXRjaCA9IDBcbiAgfSA9IHByb3BzO1xuICBsZXQge1xuICAgIGxvbmdpdHVkZSxcbiAgICBsYXRpdHVkZSxcbiAgICB6b29tLFxuICAgIGJlYXJpbmcgPSAwXG4gIH0gPSBwcm9wcztcblxuICBpZiAobG9uZ2l0dWRlIDwgLTE4MCB8fCBsb25naXR1ZGUgPiAxODApIHtcbiAgICBsb25naXR1ZGUgPSBtb2QobG9uZ2l0dWRlICsgMTgwLCAzNjApIC0gMTgwO1xuICB9XG5cbiAgaWYgKGJlYXJpbmcgPCAtMTgwIHx8IGJlYXJpbmcgPiAxODApIHtcbiAgICBiZWFyaW5nID0gbW9kKGJlYXJpbmcgKyAxODAsIDM2MCkgLSAxODA7XG4gIH1cblxuICBjb25zdCBtaW5ab29tID0gbG9nMihoZWlnaHQgLyBUSUxFX1NJWkUpO1xuXG4gIGlmICh6b29tIDw9IG1pblpvb20pIHtcbiAgICB6b29tID0gbWluWm9vbTtcbiAgICBsYXRpdHVkZSA9IDA7XG4gIH0gZWxzZSB7XG4gICAgY29uc3QgaGFsZkhlaWdodFBpeGVscyA9IGhlaWdodCAvIDIgLyBNYXRoLnBvdygyLCB6b29tKTtcbiAgICBjb25zdCBtaW5MYXRpdHVkZSA9IHdvcmxkVG9MbmdMYXQoWzAsIGhhbGZIZWlnaHRQaXhlbHNdKVsxXTtcblxuICAgIGlmIChsYXRpdHVkZSA8IG1pbkxhdGl0dWRlKSB7XG4gICAgICBsYXRpdHVkZSA9IG1pbkxhdGl0dWRlO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBtYXhMYXRpdHVkZSA9IHdvcmxkVG9MbmdMYXQoWzAsIFRJTEVfU0laRSAtIGhhbGZIZWlnaHRQaXhlbHNdKVsxXTtcblxuICAgICAgaWYgKGxhdGl0dWRlID4gbWF4TGF0aXR1ZGUpIHtcbiAgICAgICAgbGF0aXR1ZGUgPSBtYXhMYXRpdHVkZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4ge1xuICAgIHdpZHRoLFxuICAgIGhlaWdodCxcbiAgICBsb25naXR1ZGUsXG4gICAgbGF0aXR1ZGUsXG4gICAgem9vbSxcbiAgICBwaXRjaCxcbiAgICBiZWFyaW5nXG4gIH07XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1ub3JtYWxpemUtdmlld3BvcnQtcHJvcHMuanMubWFwIiwiaW1wb3J0IHsgbGVycCB9IGZyb20gJy4vbWF0aC11dGlscyc7XG5pbXBvcnQgeyBzY2FsZVRvWm9vbSwgem9vbVRvU2NhbGUsIGxuZ0xhdFRvV29ybGQsIHdvcmxkVG9MbmdMYXQgfSBmcm9tICcuL3dlYi1tZXJjYXRvci11dGlscyc7XG5pbXBvcnQgKiBhcyB2ZWMyIGZyb20gJ2dsLW1hdHJpeC92ZWMyJztcbmNvbnN0IEVQU0lMT04gPSAwLjAxO1xuY29uc3QgVklFV1BPUlRfVFJBTlNJVElPTl9QUk9QUyA9IFsnbG9uZ2l0dWRlJywgJ2xhdGl0dWRlJywgJ3pvb20nXTtcbmNvbnN0IERFRkFVTFRfT1BUUyA9IHtcbiAgY3VydmU6IDEuNDE0LFxuICBzcGVlZDogMS4yXG59O1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZmx5VG9WaWV3cG9ydChzdGFydFByb3BzLCBlbmRQcm9wcywgdCwgb3B0aW9ucykge1xuICBjb25zdCB7XG4gICAgc3RhcnRab29tLFxuICAgIHN0YXJ0Q2VudGVyWFksXG4gICAgdURlbHRhLFxuICAgIHcwLFxuICAgIHUxLFxuICAgIFMsXG4gICAgcmhvLFxuICAgIHJobzIsXG4gICAgcjBcbiAgfSA9IGdldEZseVRvVHJhbnNpdGlvblBhcmFtcyhzdGFydFByb3BzLCBlbmRQcm9wcywgb3B0aW9ucyk7XG5cbiAgaWYgKHUxIDwgRVBTSUxPTikge1xuICAgIGNvbnN0IHZpZXdwb3J0ID0ge307XG5cbiAgICBmb3IgKGNvbnN0IGtleSBvZiBWSUVXUE9SVF9UUkFOU0lUSU9OX1BST1BTKSB7XG4gICAgICBjb25zdCBzdGFydFZhbHVlID0gc3RhcnRQcm9wc1trZXldO1xuICAgICAgY29uc3QgZW5kVmFsdWUgPSBlbmRQcm9wc1trZXldO1xuICAgICAgdmlld3BvcnRba2V5XSA9IGxlcnAoc3RhcnRWYWx1ZSwgZW5kVmFsdWUsIHQpO1xuICAgIH1cblxuICAgIHJldHVybiB2aWV3cG9ydDtcbiAgfVxuXG4gIGNvbnN0IHMgPSB0ICogUztcbiAgY29uc3QgdyA9IE1hdGguY29zaChyMCkgLyBNYXRoLmNvc2gocjAgKyByaG8gKiBzKTtcbiAgY29uc3QgdSA9IHcwICogKChNYXRoLmNvc2gocjApICogTWF0aC50YW5oKHIwICsgcmhvICogcykgLSBNYXRoLnNpbmgocjApKSAvIHJobzIpIC8gdTE7XG4gIGNvbnN0IHNjYWxlSW5jcmVtZW50ID0gMSAvIHc7XG4gIGNvbnN0IG5ld1pvb20gPSBzdGFydFpvb20gKyBzY2FsZVRvWm9vbShzY2FsZUluY3JlbWVudCk7XG4gIGNvbnN0IG5ld0NlbnRlcldvcmxkID0gdmVjMi5zY2FsZShbXSwgdURlbHRhLCB1KTtcbiAgdmVjMi5hZGQobmV3Q2VudGVyV29ybGQsIG5ld0NlbnRlcldvcmxkLCBzdGFydENlbnRlclhZKTtcbiAgY29uc3QgbmV3Q2VudGVyID0gd29ybGRUb0xuZ0xhdChuZXdDZW50ZXJXb3JsZCk7XG4gIHJldHVybiB7XG4gICAgbG9uZ2l0dWRlOiBuZXdDZW50ZXJbMF0sXG4gICAgbGF0aXR1ZGU6IG5ld0NlbnRlclsxXSxcbiAgICB6b29tOiBuZXdab29tXG4gIH07XG59XG5leHBvcnQgZnVuY3Rpb24gZ2V0Rmx5VG9EdXJhdGlvbihzdGFydFByb3BzLCBlbmRQcm9wcywgb3B0aW9ucykge1xuICBjb25zdCBvcHRzID0geyAuLi5ERUZBVUxUX09QVFMsXG4gICAgLi4ub3B0aW9uc1xuICB9O1xuICBjb25zdCB7XG4gICAgc2NyZWVuU3BlZWQsXG4gICAgc3BlZWQsXG4gICAgbWF4RHVyYXRpb25cbiAgfSA9IG9wdHM7XG4gIGNvbnN0IHtcbiAgICBTLFxuICAgIHJob1xuICB9ID0gZ2V0Rmx5VG9UcmFuc2l0aW9uUGFyYW1zKHN0YXJ0UHJvcHMsIGVuZFByb3BzLCBvcHRzKTtcbiAgY29uc3QgbGVuZ3RoID0gMTAwMCAqIFM7XG4gIGxldCBkdXJhdGlvbjtcblxuICBpZiAoTnVtYmVyLmlzRmluaXRlKHNjcmVlblNwZWVkKSkge1xuICAgIGR1cmF0aW9uID0gbGVuZ3RoIC8gKHNjcmVlblNwZWVkIC8gcmhvKTtcbiAgfSBlbHNlIHtcbiAgICBkdXJhdGlvbiA9IGxlbmd0aCAvIHNwZWVkO1xuICB9XG5cbiAgcmV0dXJuIE51bWJlci5pc0Zpbml0ZShtYXhEdXJhdGlvbikgJiYgZHVyYXRpb24gPiBtYXhEdXJhdGlvbiA/IDAgOiBkdXJhdGlvbjtcbn1cblxuZnVuY3Rpb24gZ2V0Rmx5VG9UcmFuc2l0aW9uUGFyYW1zKHN0YXJ0UHJvcHMsIGVuZFByb3BzLCBvcHRzKSB7XG4gIG9wdHMgPSBPYmplY3QuYXNzaWduKHt9LCBERUZBVUxUX09QVFMsIG9wdHMpO1xuICBjb25zdCByaG8gPSBvcHRzLmN1cnZlO1xuICBjb25zdCBzdGFydFpvb20gPSBzdGFydFByb3BzLnpvb207XG4gIGNvbnN0IHN0YXJ0Q2VudGVyID0gW3N0YXJ0UHJvcHMubG9uZ2l0dWRlLCBzdGFydFByb3BzLmxhdGl0dWRlXTtcbiAgY29uc3Qgc3RhcnRTY2FsZSA9IHpvb21Ub1NjYWxlKHN0YXJ0Wm9vbSk7XG4gIGNvbnN0IGVuZFpvb20gPSBlbmRQcm9wcy56b29tO1xuICBjb25zdCBlbmRDZW50ZXIgPSBbZW5kUHJvcHMubG9uZ2l0dWRlLCBlbmRQcm9wcy5sYXRpdHVkZV07XG4gIGNvbnN0IHNjYWxlID0gem9vbVRvU2NhbGUoZW5kWm9vbSAtIHN0YXJ0Wm9vbSk7XG4gIGNvbnN0IHN0YXJ0Q2VudGVyWFkgPSBsbmdMYXRUb1dvcmxkKHN0YXJ0Q2VudGVyKTtcbiAgY29uc3QgZW5kQ2VudGVyWFkgPSBsbmdMYXRUb1dvcmxkKGVuZENlbnRlcik7XG4gIGNvbnN0IHVEZWx0YSA9IHZlYzIuc3ViKFtdLCBlbmRDZW50ZXJYWSwgc3RhcnRDZW50ZXJYWSk7XG4gIGNvbnN0IHcwID0gTWF0aC5tYXgoc3RhcnRQcm9wcy53aWR0aCwgc3RhcnRQcm9wcy5oZWlnaHQpO1xuICBjb25zdCB3MSA9IHcwIC8gc2NhbGU7XG4gIGNvbnN0IHUxID0gdmVjMi5sZW5ndGgodURlbHRhKSAqIHN0YXJ0U2NhbGU7XG5cbiAgY29uc3QgX3UxID0gTWF0aC5tYXgodTEsIEVQU0lMT04pO1xuXG4gIGNvbnN0IHJobzIgPSByaG8gKiByaG87XG4gIGNvbnN0IGIwID0gKHcxICogdzEgLSB3MCAqIHcwICsgcmhvMiAqIHJobzIgKiBfdTEgKiBfdTEpIC8gKDIgKiB3MCAqIHJobzIgKiBfdTEpO1xuICBjb25zdCBiMSA9ICh3MSAqIHcxIC0gdzAgKiB3MCAtIHJobzIgKiByaG8yICogX3UxICogX3UxKSAvICgyICogdzEgKiByaG8yICogX3UxKTtcbiAgY29uc3QgcjAgPSBNYXRoLmxvZyhNYXRoLnNxcnQoYjAgKiBiMCArIDEpIC0gYjApO1xuICBjb25zdCByMSA9IE1hdGgubG9nKE1hdGguc3FydChiMSAqIGIxICsgMSkgLSBiMSk7XG4gIGNvbnN0IFMgPSAocjEgLSByMCkgLyByaG87XG4gIHJldHVybiB7XG4gICAgc3RhcnRab29tLFxuICAgIHN0YXJ0Q2VudGVyWFksXG4gICAgdURlbHRhLFxuICAgIHcwLFxuICAgIHUxLFxuICAgIFMsXG4gICAgcmhvLFxuICAgIHJobzIsXG4gICAgcjAsXG4gICAgcjFcbiAgfTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWZseS10by12aWV3cG9ydC5qcy5tYXAiLCJleHBvcnQgeyBkZWZhdWx0IH0gZnJvbSAnLi93ZWItbWVyY2F0b3Itdmlld3BvcnQnO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBXZWJNZXJjYXRvclZpZXdwb3J0IH0gZnJvbSAnLi93ZWItbWVyY2F0b3Itdmlld3BvcnQnO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBnZXRCb3VuZHMgfSBmcm9tICcuL2dldC1ib3VuZHMnO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBmaXRCb3VuZHMgfSBmcm9tICcuL2ZpdC1ib3VuZHMnO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBub3JtYWxpemVWaWV3cG9ydFByb3BzIH0gZnJvbSAnLi9ub3JtYWxpemUtdmlld3BvcnQtcHJvcHMnO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBmbHlUb1ZpZXdwb3J0LCBnZXRGbHlUb0R1cmF0aW9uIH0gZnJvbSAnLi9mbHktdG8tdmlld3BvcnQnO1xuZXhwb3J0IHsgTUFYX0xBVElUVURFLCBsbmdMYXRUb1dvcmxkLCB3b3JsZFRvTG5nTGF0LCB3b3JsZFRvUGl4ZWxzLCBwaXhlbHNUb1dvcmxkLCB6b29tVG9TY2FsZSwgc2NhbGVUb1pvb20sIGFsdGl0dWRlVG9Gb3Z5LCBmb3Z5VG9BbHRpdHVkZSwgZ2V0TWV0ZXJab29tLCB1bml0c1Blck1ldGVyLCBnZXREaXN0YW5jZVNjYWxlcywgYWRkTWV0ZXJzVG9MbmdMYXQsIGdldFZpZXdNYXRyaXgsIGdldFByb2plY3Rpb25NYXRyaXgsIGdldFByb2plY3Rpb25QYXJhbWV0ZXJzIH0gZnJvbSAnLi93ZWItbWVyY2F0b3ItdXRpbHMnO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///78866\n')},59391:function(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__){eval('/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "Z": function() { return /* export default binding */ __WEBPACK_DEFAULT_EXPORT__; }\n/* harmony export */ });\n/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(n){return{all:n=n||new Map,on:function(t,e){var i=n.get(t);i?i.push(e):n.set(t,[e])},off:function(t,e){var i=n.get(t);i&&(e?i.splice(i.indexOf(e)>>>0,1):n.set(t,[]))},emit:function(t,e){var i=n.get(t);i&&i.slice().map(function(n){n(e)}),(i=n.get("*"))&&i.slice().map(function(n){n(t,e)})}}}\n//# sourceMappingURL=mitt.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNTkzOTEuanMiLCJtYXBwaW5ncyI6Ijs7O0FBQUEsNkJBQWUsb0NBQVMsR0FBRyxPQUFPLGtDQUFrQyxlQUFlLHlCQUF5QixtQkFBbUIsZUFBZSxnREFBZ0Qsb0JBQW9CLGVBQWUsNkJBQTZCLEtBQUssNENBQTRDLE9BQU87QUFDdFQiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly92dWUzLXdlYnBhY2s1Ly4vbm9kZV9tb2R1bGVzL21pdHQvZGlzdC9taXR0Lm1qcz8zN2M4Il0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKG4pe3JldHVybnthbGw6bj1ufHxuZXcgTWFwLG9uOmZ1bmN0aW9uKHQsZSl7dmFyIGk9bi5nZXQodCk7aT9pLnB1c2goZSk6bi5zZXQodCxbZV0pfSxvZmY6ZnVuY3Rpb24odCxlKXt2YXIgaT1uLmdldCh0KTtpJiYoZT9pLnNwbGljZShpLmluZGV4T2YoZSk+Pj4wLDEpOm4uc2V0KHQsW10pKX0sZW1pdDpmdW5jdGlvbih0LGUpe3ZhciBpPW4uZ2V0KHQpO2kmJmkuc2xpY2UoKS5tYXAoZnVuY3Rpb24obil7bihlKX0pLChpPW4uZ2V0KFwiKlwiKSkmJmkuc2xpY2UoKS5tYXAoZnVuY3Rpb24obil7bih0LGUpfSl9fX1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW1pdHQubWpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///59391\n')}}]);