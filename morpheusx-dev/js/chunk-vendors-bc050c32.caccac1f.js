"use strict";(self["webpackChunkvue3_webpack5"]=self["webpackChunkvue3_webpack5"]||[]).push([[2757],{9187:function(module){eval("\n\nmodule.exports = earcut;\nmodule.exports[\"default\"] = earcut;\n\nfunction earcut(data, holeIndices, dim) {\n\n    dim = dim || 2;\n\n    var hasHoles = holeIndices && holeIndices.length,\n        outerLen = hasHoles ? holeIndices[0] * dim : data.length,\n        outerNode = linkedList(data, 0, outerLen, dim, true),\n        triangles = [];\n\n    if (!outerNode || outerNode.next === outerNode.prev) return triangles;\n\n    var minX, minY, maxX, maxY, x, y, invSize;\n\n    if (hasHoles) outerNode = eliminateHoles(data, holeIndices, outerNode, dim);\n\n    // if the shape is not too simple, we'll use z-order curve hash later; calculate polygon bbox\n    if (data.length > 80 * dim) {\n        minX = maxX = data[0];\n        minY = maxY = data[1];\n\n        for (var i = dim; i < outerLen; i += dim) {\n            x = data[i];\n            y = data[i + 1];\n            if (x < minX) minX = x;\n            if (y < minY) minY = y;\n            if (x > maxX) maxX = x;\n            if (y > maxY) maxY = y;\n        }\n\n        // minX, minY and invSize are later used to transform coords into integers for z-order calculation\n        invSize = Math.max(maxX - minX, maxY - minY);\n        invSize = invSize !== 0 ? 32767 / invSize : 0;\n    }\n\n    earcutLinked(outerNode, triangles, dim, minX, minY, invSize, 0);\n\n    return triangles;\n}\n\n// create a circular doubly linked list from polygon points in the specified winding order\nfunction linkedList(data, start, end, dim, clockwise) {\n    var i, last;\n\n    if (clockwise === (signedArea(data, start, end, dim) > 0)) {\n        for (i = start; i < end; i += dim) last = insertNode(i, data[i], data[i + 1], last);\n    } else {\n        for (i = end - dim; i >= start; i -= dim) last = insertNode(i, data[i], data[i + 1], last);\n    }\n\n    if (last && equals(last, last.next)) {\n        removeNode(last);\n        last = last.next;\n    }\n\n    return last;\n}\n\n// eliminate colinear or duplicate points\nfunction filterPoints(start, end) {\n    if (!start) return start;\n    if (!end) end = start;\n\n    var p = start,\n        again;\n    do {\n        again = false;\n\n        if (!p.steiner && (equals(p, p.next) || area(p.prev, p, p.next) === 0)) {\n            removeNode(p);\n            p = end = p.prev;\n            if (p === p.next) break;\n            again = true;\n\n        } else {\n            p = p.next;\n        }\n    } while (again || p !== end);\n\n    return end;\n}\n\n// main ear slicing loop which triangulates a polygon (given as a linked list)\nfunction earcutLinked(ear, triangles, dim, minX, minY, invSize, pass) {\n    if (!ear) return;\n\n    // interlink polygon nodes in z-order\n    if (!pass && invSize) indexCurve(ear, minX, minY, invSize);\n\n    var stop = ear,\n        prev, next;\n\n    // iterate through ears, slicing them one by one\n    while (ear.prev !== ear.next) {\n        prev = ear.prev;\n        next = ear.next;\n\n        if (invSize ? isEarHashed(ear, minX, minY, invSize) : isEar(ear)) {\n            // cut off the triangle\n            triangles.push(prev.i / dim | 0);\n            triangles.push(ear.i / dim | 0);\n            triangles.push(next.i / dim | 0);\n\n            removeNode(ear);\n\n            // skipping the next vertex leads to less sliver triangles\n            ear = next.next;\n            stop = next.next;\n\n            continue;\n        }\n\n        ear = next;\n\n        // if we looped through the whole remaining polygon and can't find any more ears\n        if (ear === stop) {\n            // try filtering points and slicing again\n            if (!pass) {\n                earcutLinked(filterPoints(ear), triangles, dim, minX, minY, invSize, 1);\n\n            // if this didn't work, try curing all small self-intersections locally\n            } else if (pass === 1) {\n                ear = cureLocalIntersections(filterPoints(ear), triangles, dim);\n                earcutLinked(ear, triangles, dim, minX, minY, invSize, 2);\n\n            // as a last resort, try splitting the remaining polygon into two\n            } else if (pass === 2) {\n                splitEarcut(ear, triangles, dim, minX, minY, invSize);\n            }\n\n            break;\n        }\n    }\n}\n\n// check whether a polygon node forms a valid ear with adjacent nodes\nfunction isEar(ear) {\n    var a = ear.prev,\n        b = ear,\n        c = ear.next;\n\n    if (area(a, b, c) >= 0) return false; // reflex, can't be an ear\n\n    // now make sure we don't have other points inside the potential ear\n    var ax = a.x, bx = b.x, cx = c.x, ay = a.y, by = b.y, cy = c.y;\n\n    // triangle bbox; min & max are calculated like this for speed\n    var x0 = ax < bx ? (ax < cx ? ax : cx) : (bx < cx ? bx : cx),\n        y0 = ay < by ? (ay < cy ? ay : cy) : (by < cy ? by : cy),\n        x1 = ax > bx ? (ax > cx ? ax : cx) : (bx > cx ? bx : cx),\n        y1 = ay > by ? (ay > cy ? ay : cy) : (by > cy ? by : cy);\n\n    var p = c.next;\n    while (p !== a) {\n        if (p.x >= x0 && p.x <= x1 && p.y >= y0 && p.y <= y1 &&\n            pointInTriangle(ax, ay, bx, by, cx, cy, p.x, p.y) &&\n            area(p.prev, p, p.next) >= 0) return false;\n        p = p.next;\n    }\n\n    return true;\n}\n\nfunction isEarHashed(ear, minX, minY, invSize) {\n    var a = ear.prev,\n        b = ear,\n        c = ear.next;\n\n    if (area(a, b, c) >= 0) return false; // reflex, can't be an ear\n\n    var ax = a.x, bx = b.x, cx = c.x, ay = a.y, by = b.y, cy = c.y;\n\n    // triangle bbox; min & max are calculated like this for speed\n    var x0 = ax < bx ? (ax < cx ? ax : cx) : (bx < cx ? bx : cx),\n        y0 = ay < by ? (ay < cy ? ay : cy) : (by < cy ? by : cy),\n        x1 = ax > bx ? (ax > cx ? ax : cx) : (bx > cx ? bx : cx),\n        y1 = ay > by ? (ay > cy ? ay : cy) : (by > cy ? by : cy);\n\n    // z-order range for the current triangle bbox;\n    var minZ = zOrder(x0, y0, minX, minY, invSize),\n        maxZ = zOrder(x1, y1, minX, minY, invSize);\n\n    var p = ear.prevZ,\n        n = ear.nextZ;\n\n    // look for points inside the triangle in both directions\n    while (p && p.z >= minZ && n && n.z <= maxZ) {\n        if (p.x >= x0 && p.x <= x1 && p.y >= y0 && p.y <= y1 && p !== a && p !== c &&\n            pointInTriangle(ax, ay, bx, by, cx, cy, p.x, p.y) && area(p.prev, p, p.next) >= 0) return false;\n        p = p.prevZ;\n\n        if (n.x >= x0 && n.x <= x1 && n.y >= y0 && n.y <= y1 && n !== a && n !== c &&\n            pointInTriangle(ax, ay, bx, by, cx, cy, n.x, n.y) && area(n.prev, n, n.next) >= 0) return false;\n        n = n.nextZ;\n    }\n\n    // look for remaining points in decreasing z-order\n    while (p && p.z >= minZ) {\n        if (p.x >= x0 && p.x <= x1 && p.y >= y0 && p.y <= y1 && p !== a && p !== c &&\n            pointInTriangle(ax, ay, bx, by, cx, cy, p.x, p.y) && area(p.prev, p, p.next) >= 0) return false;\n        p = p.prevZ;\n    }\n\n    // look for remaining points in increasing z-order\n    while (n && n.z <= maxZ) {\n        if (n.x >= x0 && n.x <= x1 && n.y >= y0 && n.y <= y1 && n !== a && n !== c &&\n            pointInTriangle(ax, ay, bx, by, cx, cy, n.x, n.y) && area(n.prev, n, n.next) >= 0) return false;\n        n = n.nextZ;\n    }\n\n    return true;\n}\n\n// go through all polygon nodes and cure small local self-intersections\nfunction cureLocalIntersections(start, triangles, dim) {\n    var p = start;\n    do {\n        var a = p.prev,\n            b = p.next.next;\n\n        if (!equals(a, b) && intersects(a, p, p.next, b) && locallyInside(a, b) && locallyInside(b, a)) {\n\n            triangles.push(a.i / dim | 0);\n            triangles.push(p.i / dim | 0);\n            triangles.push(b.i / dim | 0);\n\n            // remove two nodes involved\n            removeNode(p);\n            removeNode(p.next);\n\n            p = start = b;\n        }\n        p = p.next;\n    } while (p !== start);\n\n    return filterPoints(p);\n}\n\n// try splitting polygon into two and triangulate them independently\nfunction splitEarcut(start, triangles, dim, minX, minY, invSize) {\n    // look for a valid diagonal that divides the polygon into two\n    var a = start;\n    do {\n        var b = a.next.next;\n        while (b !== a.prev) {\n            if (a.i !== b.i && isValidDiagonal(a, b)) {\n                // split the polygon in two by the diagonal\n                var c = splitPolygon(a, b);\n\n                // filter colinear points around the cuts\n                a = filterPoints(a, a.next);\n                c = filterPoints(c, c.next);\n\n                // run earcut on each half\n                earcutLinked(a, triangles, dim, minX, minY, invSize, 0);\n                earcutLinked(c, triangles, dim, minX, minY, invSize, 0);\n                return;\n            }\n            b = b.next;\n        }\n        a = a.next;\n    } while (a !== start);\n}\n\n// link every hole into the outer loop, producing a single-ring polygon without holes\nfunction eliminateHoles(data, holeIndices, outerNode, dim) {\n    var queue = [],\n        i, len, start, end, list;\n\n    for (i = 0, len = holeIndices.length; i < len; i++) {\n        start = holeIndices[i] * dim;\n        end = i < len - 1 ? holeIndices[i + 1] * dim : data.length;\n        list = linkedList(data, start, end, dim, false);\n        if (list === list.next) list.steiner = true;\n        queue.push(getLeftmost(list));\n    }\n\n    queue.sort(compareX);\n\n    // process holes from left to right\n    for (i = 0; i < queue.length; i++) {\n        outerNode = eliminateHole(queue[i], outerNode);\n    }\n\n    return outerNode;\n}\n\nfunction compareX(a, b) {\n    return a.x - b.x;\n}\n\n// find a bridge between vertices that connects hole with an outer ring and and link it\nfunction eliminateHole(hole, outerNode) {\n    var bridge = findHoleBridge(hole, outerNode);\n    if (!bridge) {\n        return outerNode;\n    }\n\n    var bridgeReverse = splitPolygon(bridge, hole);\n\n    // filter collinear points around the cuts\n    filterPoints(bridgeReverse, bridgeReverse.next);\n    return filterPoints(bridge, bridge.next);\n}\n\n// David Eberly's algorithm for finding a bridge between hole and outer polygon\nfunction findHoleBridge(hole, outerNode) {\n    var p = outerNode,\n        hx = hole.x,\n        hy = hole.y,\n        qx = -Infinity,\n        m;\n\n    // find a segment intersected by a ray from the hole's leftmost point to the left;\n    // segment's endpoint with lesser x will be potential connection point\n    do {\n        if (hy <= p.y && hy >= p.next.y && p.next.y !== p.y) {\n            var x = p.x + (hy - p.y) * (p.next.x - p.x) / (p.next.y - p.y);\n            if (x <= hx && x > qx) {\n                qx = x;\n                m = p.x < p.next.x ? p : p.next;\n                if (x === hx) return m; // hole touches outer segment; pick leftmost endpoint\n            }\n        }\n        p = p.next;\n    } while (p !== outerNode);\n\n    if (!m) return null;\n\n    // look for points inside the triangle of hole point, segment intersection and endpoint;\n    // if there are no points found, we have a valid connection;\n    // otherwise choose the point of the minimum angle with the ray as connection point\n\n    var stop = m,\n        mx = m.x,\n        my = m.y,\n        tanMin = Infinity,\n        tan;\n\n    p = m;\n\n    do {\n        if (hx >= p.x && p.x >= mx && hx !== p.x &&\n                pointInTriangle(hy < my ? hx : qx, hy, mx, my, hy < my ? qx : hx, hy, p.x, p.y)) {\n\n            tan = Math.abs(hy - p.y) / (hx - p.x); // tangential\n\n            if (locallyInside(p, hole) &&\n                (tan < tanMin || (tan === tanMin && (p.x > m.x || (p.x === m.x && sectorContainsSector(m, p)))))) {\n                m = p;\n                tanMin = tan;\n            }\n        }\n\n        p = p.next;\n    } while (p !== stop);\n\n    return m;\n}\n\n// whether sector in vertex m contains sector in vertex p in the same coordinates\nfunction sectorContainsSector(m, p) {\n    return area(m.prev, m, p.prev) < 0 && area(p.next, m, m.next) < 0;\n}\n\n// interlink polygon nodes in z-order\nfunction indexCurve(start, minX, minY, invSize) {\n    var p = start;\n    do {\n        if (p.z === 0) p.z = zOrder(p.x, p.y, minX, minY, invSize);\n        p.prevZ = p.prev;\n        p.nextZ = p.next;\n        p = p.next;\n    } while (p !== start);\n\n    p.prevZ.nextZ = null;\n    p.prevZ = null;\n\n    sortLinked(p);\n}\n\n// Simon Tatham's linked list merge sort algorithm\n// http://www.chiark.greenend.org.uk/~sgtatham/algorithms/listsort.html\nfunction sortLinked(list) {\n    var i, p, q, e, tail, numMerges, pSize, qSize,\n        inSize = 1;\n\n    do {\n        p = list;\n        list = null;\n        tail = null;\n        numMerges = 0;\n\n        while (p) {\n            numMerges++;\n            q = p;\n            pSize = 0;\n            for (i = 0; i < inSize; i++) {\n                pSize++;\n                q = q.nextZ;\n                if (!q) break;\n            }\n            qSize = inSize;\n\n            while (pSize > 0 || (qSize > 0 && q)) {\n\n                if (pSize !== 0 && (qSize === 0 || !q || p.z <= q.z)) {\n                    e = p;\n                    p = p.nextZ;\n                    pSize--;\n                } else {\n                    e = q;\n                    q = q.nextZ;\n                    qSize--;\n                }\n\n                if (tail) tail.nextZ = e;\n                else list = e;\n\n                e.prevZ = tail;\n                tail = e;\n            }\n\n            p = q;\n        }\n\n        tail.nextZ = null;\n        inSize *= 2;\n\n    } while (numMerges > 1);\n\n    return list;\n}\n\n// z-order of a point given coords and inverse of the longer side of data bbox\nfunction zOrder(x, y, minX, minY, invSize) {\n    // coords are transformed into non-negative 15-bit integer range\n    x = (x - minX) * invSize | 0;\n    y = (y - minY) * invSize | 0;\n\n    x = (x | (x << 8)) & 0x00FF00FF;\n    x = (x | (x << 4)) & 0x0F0F0F0F;\n    x = (x | (x << 2)) & 0x33333333;\n    x = (x | (x << 1)) & 0x55555555;\n\n    y = (y | (y << 8)) & 0x00FF00FF;\n    y = (y | (y << 4)) & 0x0F0F0F0F;\n    y = (y | (y << 2)) & 0x33333333;\n    y = (y | (y << 1)) & 0x55555555;\n\n    return x | (y << 1);\n}\n\n// find the leftmost node of a polygon ring\nfunction getLeftmost(start) {\n    var p = start,\n        leftmost = start;\n    do {\n        if (p.x < leftmost.x || (p.x === leftmost.x && p.y < leftmost.y)) leftmost = p;\n        p = p.next;\n    } while (p !== start);\n\n    return leftmost;\n}\n\n// check if a point lies within a convex triangle\nfunction pointInTriangle(ax, ay, bx, by, cx, cy, px, py) {\n    return (cx - px) * (ay - py) >= (ax - px) * (cy - py) &&\n           (ax - px) * (by - py) >= (bx - px) * (ay - py) &&\n           (bx - px) * (cy - py) >= (cx - px) * (by - py);\n}\n\n// check if a diagonal between two polygon nodes is valid (lies in polygon interior)\nfunction isValidDiagonal(a, b) {\n    return a.next.i !== b.i && a.prev.i !== b.i && !intersectsPolygon(a, b) && // dones't intersect other edges\n           (locallyInside(a, b) && locallyInside(b, a) && middleInside(a, b) && // locally visible\n            (area(a.prev, a, b.prev) || area(a, b.prev, b)) || // does not create opposite-facing sectors\n            equals(a, b) && area(a.prev, a, a.next) > 0 && area(b.prev, b, b.next) > 0); // special zero-length case\n}\n\n// signed area of a triangle\nfunction area(p, q, r) {\n    return (q.y - p.y) * (r.x - q.x) - (q.x - p.x) * (r.y - q.y);\n}\n\n// check if two points are equal\nfunction equals(p1, p2) {\n    return p1.x === p2.x && p1.y === p2.y;\n}\n\n// check if two segments intersect\nfunction intersects(p1, q1, p2, q2) {\n    var o1 = sign(area(p1, q1, p2));\n    var o2 = sign(area(p1, q1, q2));\n    var o3 = sign(area(p2, q2, p1));\n    var o4 = sign(area(p2, q2, q1));\n\n    if (o1 !== o2 && o3 !== o4) return true; // general case\n\n    if (o1 === 0 && onSegment(p1, p2, q1)) return true; // p1, q1 and p2 are collinear and p2 lies on p1q1\n    if (o2 === 0 && onSegment(p1, q2, q1)) return true; // p1, q1 and q2 are collinear and q2 lies on p1q1\n    if (o3 === 0 && onSegment(p2, p1, q2)) return true; // p2, q2 and p1 are collinear and p1 lies on p2q2\n    if (o4 === 0 && onSegment(p2, q1, q2)) return true; // p2, q2 and q1 are collinear and q1 lies on p2q2\n\n    return false;\n}\n\n// for collinear points p, q, r, check if point q lies on segment pr\nfunction onSegment(p, q, r) {\n    return q.x <= Math.max(p.x, r.x) && q.x >= Math.min(p.x, r.x) && q.y <= Math.max(p.y, r.y) && q.y >= Math.min(p.y, r.y);\n}\n\nfunction sign(num) {\n    return num > 0 ? 1 : num < 0 ? -1 : 0;\n}\n\n// check if a polygon diagonal intersects any polygon segments\nfunction intersectsPolygon(a, b) {\n    var p = a;\n    do {\n        if (p.i !== a.i && p.next.i !== a.i && p.i !== b.i && p.next.i !== b.i &&\n                intersects(p, p.next, a, b)) return true;\n        p = p.next;\n    } while (p !== a);\n\n    return false;\n}\n\n// check if a polygon diagonal is locally inside the polygon\nfunction locallyInside(a, b) {\n    return area(a.prev, a, a.next) < 0 ?\n        area(a, b, a.next) >= 0 && area(a, a.prev, b) >= 0 :\n        area(a, b, a.prev) < 0 || area(a, a.next, b) < 0;\n}\n\n// check if the middle point of a polygon diagonal is inside the polygon\nfunction middleInside(a, b) {\n    var p = a,\n        inside = false,\n        px = (a.x + b.x) / 2,\n        py = (a.y + b.y) / 2;\n    do {\n        if (((p.y > py) !== (p.next.y > py)) && p.next.y !== p.y &&\n                (px < (p.next.x - p.x) * (py - p.y) / (p.next.y - p.y) + p.x))\n            inside = !inside;\n        p = p.next;\n    } while (p !== a);\n\n    return inside;\n}\n\n// link two polygon vertices with a bridge; if the vertices belong to the same ring, it splits polygon into two;\n// if one belongs to the outer ring and another to a hole, it merges it into a single ring\nfunction splitPolygon(a, b) {\n    var a2 = new Node(a.i, a.x, a.y),\n        b2 = new Node(b.i, b.x, b.y),\n        an = a.next,\n        bp = b.prev;\n\n    a.next = b;\n    b.prev = a;\n\n    a2.next = an;\n    an.prev = a2;\n\n    b2.next = a2;\n    a2.prev = b2;\n\n    bp.next = b2;\n    b2.prev = bp;\n\n    return b2;\n}\n\n// create a node and optionally link it with previous one (in a circular doubly linked list)\nfunction insertNode(i, x, y, last) {\n    var p = new Node(i, x, y);\n\n    if (!last) {\n        p.prev = p;\n        p.next = p;\n\n    } else {\n        p.next = last.next;\n        p.prev = last;\n        last.next.prev = p;\n        last.next = p;\n    }\n    return p;\n}\n\nfunction removeNode(p) {\n    p.next.prev = p.prev;\n    p.prev.next = p.next;\n\n    if (p.prevZ) p.prevZ.nextZ = p.nextZ;\n    if (p.nextZ) p.nextZ.prevZ = p.prevZ;\n}\n\nfunction Node(i, x, y) {\n    // vertex index in coordinates array\n    this.i = i;\n\n    // vertex coordinates\n    this.x = x;\n    this.y = y;\n\n    // previous and next vertex nodes in a polygon ring\n    this.prev = null;\n    this.next = null;\n\n    // z-order curve value\n    this.z = 0;\n\n    // previous and next nodes in z-order\n    this.prevZ = null;\n    this.nextZ = null;\n\n    // indicates whether this is a steiner point\n    this.steiner = false;\n}\n\n// return a percentage difference between the polygon area and its triangulation area;\n// used to verify correctness of triangulation\nearcut.deviation = function (data, holeIndices, dim, triangles) {\n    var hasHoles = holeIndices && holeIndices.length;\n    var outerLen = hasHoles ? holeIndices[0] * dim : data.length;\n\n    var polygonArea = Math.abs(signedArea(data, 0, outerLen, dim));\n    if (hasHoles) {\n        for (var i = 0, len = holeIndices.length; i < len; i++) {\n            var start = holeIndices[i] * dim;\n            var end = i < len - 1 ? holeIndices[i + 1] * dim : data.length;\n            polygonArea -= Math.abs(signedArea(data, start, end, dim));\n        }\n    }\n\n    var trianglesArea = 0;\n    for (i = 0; i < triangles.length; i += 3) {\n        var a = triangles[i] * dim;\n        var b = triangles[i + 1] * dim;\n        var c = triangles[i + 2] * dim;\n        trianglesArea += Math.abs(\n            (data[a] - data[c]) * (data[b + 1] - data[a + 1]) -\n            (data[a] - data[b]) * (data[c + 1] - data[a + 1]));\n    }\n\n    return polygonArea === 0 && trianglesArea === 0 ? 0 :\n        Math.abs((trianglesArea - polygonArea) / polygonArea);\n};\n\nfunction signedArea(data, start, end, dim) {\n    var sum = 0;\n    for (var i = start, j = end - dim; i < end; i += dim) {\n        sum += (data[j] - data[i]) * (data[i + 1] + data[j + 1]);\n        j = i;\n    }\n    return sum;\n}\n\n// turn a polygon in a multi-dimensional array form (e.g. as in GeoJSON) into a form Earcut accepts\nearcut.flatten = function (data) {\n    var dim = data[0][0].length,\n        result = {vertices: [], holes: [], dimensions: dim},\n        holeIndex = 0;\n\n    for (var i = 0; i < data.length; i++) {\n        for (var j = 0; j < data[i].length; j++) {\n            for (var d = 0; d < dim; d++) result.vertices.push(data[i][j][d]);\n        }\n        if (i > 0) {\n            holeIndex += data[i - 1].length;\n            result.holes.push(holeIndex);\n        }\n    }\n    return result;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiOTE4Ny5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYjtBQUNBLHlCQUFzQjs7QUFFdEI7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsMkVBQTJFO0FBQzNFO0FBQ0E7QUFDQTs7QUFFQSwwQkFBMEIsY0FBYztBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHdCQUF3QixTQUFTO0FBQ2pDLE1BQU07QUFDTiw0QkFBNEIsWUFBWTtBQUN4Qzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsVUFBVTtBQUNWO0FBQ0E7QUFDQSxNQUFNOztBQUVOO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxjQUFjO0FBQ2Q7QUFDQTs7QUFFQTtBQUNBLGNBQWM7QUFDZDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsMENBQTBDOztBQUUxQztBQUNBOztBQUVBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDBDQUEwQzs7QUFFMUM7O0FBRUEsc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07O0FBRU47QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSwwQ0FBMEMsU0FBUztBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxnQkFBZ0Isa0JBQWtCO0FBQ2xDO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MsK0JBQStCO0FBQ3ZFO0FBQ0E7QUFDQTtBQUNBLE1BQU07O0FBRU47O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBLG1EQUFtRDs7QUFFbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsTUFBTTs7QUFFTjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNOztBQUVOO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsWUFBWTtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxNQUFNOztBQUVOO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTs7QUFFTjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUZBQXlGO0FBQ3pGOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSw2Q0FBNkM7O0FBRTdDLHdEQUF3RDtBQUN4RCx3REFBd0Q7QUFDeEQsd0RBQXdEO0FBQ3hELHdEQUF3RDs7QUFFeEQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNOztBQUVOO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNOztBQUVOO0FBQ0E7O0FBRUEsNENBQTRDO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esa0RBQWtELFNBQVM7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGdCQUFnQixzQkFBc0I7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx1Q0FBdUMsU0FBUztBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQix5Q0FBeUM7QUFDM0Q7O0FBRUEsb0JBQW9CLGlCQUFpQjtBQUNyQyx3QkFBd0Isb0JBQW9CO0FBQzVDLDRCQUE0QixTQUFTO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly92dWUzLXdlYnBhY2s1Ly4vbm9kZV9tb2R1bGVzL2VhcmN1dC9zcmMvZWFyY3V0LmpzPzczM2QiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGVhcmN1dDtcbm1vZHVsZS5leHBvcnRzLmRlZmF1bHQgPSBlYXJjdXQ7XG5cbmZ1bmN0aW9uIGVhcmN1dChkYXRhLCBob2xlSW5kaWNlcywgZGltKSB7XG5cbiAgICBkaW0gPSBkaW0gfHwgMjtcblxuICAgIHZhciBoYXNIb2xlcyA9IGhvbGVJbmRpY2VzICYmIGhvbGVJbmRpY2VzLmxlbmd0aCxcbiAgICAgICAgb3V0ZXJMZW4gPSBoYXNIb2xlcyA/IGhvbGVJbmRpY2VzWzBdICogZGltIDogZGF0YS5sZW5ndGgsXG4gICAgICAgIG91dGVyTm9kZSA9IGxpbmtlZExpc3QoZGF0YSwgMCwgb3V0ZXJMZW4sIGRpbSwgdHJ1ZSksXG4gICAgICAgIHRyaWFuZ2xlcyA9IFtdO1xuXG4gICAgaWYgKCFvdXRlck5vZGUgfHwgb3V0ZXJOb2RlLm5leHQgPT09IG91dGVyTm9kZS5wcmV2KSByZXR1cm4gdHJpYW5nbGVzO1xuXG4gICAgdmFyIG1pblgsIG1pblksIG1heFgsIG1heFksIHgsIHksIGludlNpemU7XG5cbiAgICBpZiAoaGFzSG9sZXMpIG91dGVyTm9kZSA9IGVsaW1pbmF0ZUhvbGVzKGRhdGEsIGhvbGVJbmRpY2VzLCBvdXRlck5vZGUsIGRpbSk7XG5cbiAgICAvLyBpZiB0aGUgc2hhcGUgaXMgbm90IHRvbyBzaW1wbGUsIHdlJ2xsIHVzZSB6LW9yZGVyIGN1cnZlIGhhc2ggbGF0ZXI7IGNhbGN1bGF0ZSBwb2x5Z29uIGJib3hcbiAgICBpZiAoZGF0YS5sZW5ndGggPiA4MCAqIGRpbSkge1xuICAgICAgICBtaW5YID0gbWF4WCA9IGRhdGFbMF07XG4gICAgICAgIG1pblkgPSBtYXhZID0gZGF0YVsxXTtcblxuICAgICAgICBmb3IgKHZhciBpID0gZGltOyBpIDwgb3V0ZXJMZW47IGkgKz0gZGltKSB7XG4gICAgICAgICAgICB4ID0gZGF0YVtpXTtcbiAgICAgICAgICAgIHkgPSBkYXRhW2kgKyAxXTtcbiAgICAgICAgICAgIGlmICh4IDwgbWluWCkgbWluWCA9IHg7XG4gICAgICAgICAgICBpZiAoeSA8IG1pblkpIG1pblkgPSB5O1xuICAgICAgICAgICAgaWYgKHggPiBtYXhYKSBtYXhYID0geDtcbiAgICAgICAgICAgIGlmICh5ID4gbWF4WSkgbWF4WSA9IHk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBtaW5YLCBtaW5ZIGFuZCBpbnZTaXplIGFyZSBsYXRlciB1c2VkIHRvIHRyYW5zZm9ybSBjb29yZHMgaW50byBpbnRlZ2VycyBmb3Igei1vcmRlciBjYWxjdWxhdGlvblxuICAgICAgICBpbnZTaXplID0gTWF0aC5tYXgobWF4WCAtIG1pblgsIG1heFkgLSBtaW5ZKTtcbiAgICAgICAgaW52U2l6ZSA9IGludlNpemUgIT09IDAgPyAzMjc2NyAvIGludlNpemUgOiAwO1xuICAgIH1cblxuICAgIGVhcmN1dExpbmtlZChvdXRlck5vZGUsIHRyaWFuZ2xlcywgZGltLCBtaW5YLCBtaW5ZLCBpbnZTaXplLCAwKTtcblxuICAgIHJldHVybiB0cmlhbmdsZXM7XG59XG5cbi8vIGNyZWF0ZSBhIGNpcmN1bGFyIGRvdWJseSBsaW5rZWQgbGlzdCBmcm9tIHBvbHlnb24gcG9pbnRzIGluIHRoZSBzcGVjaWZpZWQgd2luZGluZyBvcmRlclxuZnVuY3Rpb24gbGlua2VkTGlzdChkYXRhLCBzdGFydCwgZW5kLCBkaW0sIGNsb2Nrd2lzZSkge1xuICAgIHZhciBpLCBsYXN0O1xuXG4gICAgaWYgKGNsb2Nrd2lzZSA9PT0gKHNpZ25lZEFyZWEoZGF0YSwgc3RhcnQsIGVuZCwgZGltKSA+IDApKSB7XG4gICAgICAgIGZvciAoaSA9IHN0YXJ0OyBpIDwgZW5kOyBpICs9IGRpbSkgbGFzdCA9IGluc2VydE5vZGUoaSwgZGF0YVtpXSwgZGF0YVtpICsgMV0sIGxhc3QpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGZvciAoaSA9IGVuZCAtIGRpbTsgaSA+PSBzdGFydDsgaSAtPSBkaW0pIGxhc3QgPSBpbnNlcnROb2RlKGksIGRhdGFbaV0sIGRhdGFbaSArIDFdLCBsYXN0KTtcbiAgICB9XG5cbiAgICBpZiAobGFzdCAmJiBlcXVhbHMobGFzdCwgbGFzdC5uZXh0KSkge1xuICAgICAgICByZW1vdmVOb2RlKGxhc3QpO1xuICAgICAgICBsYXN0ID0gbGFzdC5uZXh0O1xuICAgIH1cblxuICAgIHJldHVybiBsYXN0O1xufVxuXG4vLyBlbGltaW5hdGUgY29saW5lYXIgb3IgZHVwbGljYXRlIHBvaW50c1xuZnVuY3Rpb24gZmlsdGVyUG9pbnRzKHN0YXJ0LCBlbmQpIHtcbiAgICBpZiAoIXN0YXJ0KSByZXR1cm4gc3RhcnQ7XG4gICAgaWYgKCFlbmQpIGVuZCA9IHN0YXJ0O1xuXG4gICAgdmFyIHAgPSBzdGFydCxcbiAgICAgICAgYWdhaW47XG4gICAgZG8ge1xuICAgICAgICBhZ2FpbiA9IGZhbHNlO1xuXG4gICAgICAgIGlmICghcC5zdGVpbmVyICYmIChlcXVhbHMocCwgcC5uZXh0KSB8fCBhcmVhKHAucHJldiwgcCwgcC5uZXh0KSA9PT0gMCkpIHtcbiAgICAgICAgICAgIHJlbW92ZU5vZGUocCk7XG4gICAgICAgICAgICBwID0gZW5kID0gcC5wcmV2O1xuICAgICAgICAgICAgaWYgKHAgPT09IHAubmV4dCkgYnJlYWs7XG4gICAgICAgICAgICBhZ2FpbiA9IHRydWU7XG5cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHAgPSBwLm5leHQ7XG4gICAgICAgIH1cbiAgICB9IHdoaWxlIChhZ2FpbiB8fCBwICE9PSBlbmQpO1xuXG4gICAgcmV0dXJuIGVuZDtcbn1cblxuLy8gbWFpbiBlYXIgc2xpY2luZyBsb29wIHdoaWNoIHRyaWFuZ3VsYXRlcyBhIHBvbHlnb24gKGdpdmVuIGFzIGEgbGlua2VkIGxpc3QpXG5mdW5jdGlvbiBlYXJjdXRMaW5rZWQoZWFyLCB0cmlhbmdsZXMsIGRpbSwgbWluWCwgbWluWSwgaW52U2l6ZSwgcGFzcykge1xuICAgIGlmICghZWFyKSByZXR1cm47XG5cbiAgICAvLyBpbnRlcmxpbmsgcG9seWdvbiBub2RlcyBpbiB6LW9yZGVyXG4gICAgaWYgKCFwYXNzICYmIGludlNpemUpIGluZGV4Q3VydmUoZWFyLCBtaW5YLCBtaW5ZLCBpbnZTaXplKTtcblxuICAgIHZhciBzdG9wID0gZWFyLFxuICAgICAgICBwcmV2LCBuZXh0O1xuXG4gICAgLy8gaXRlcmF0ZSB0aHJvdWdoIGVhcnMsIHNsaWNpbmcgdGhlbSBvbmUgYnkgb25lXG4gICAgd2hpbGUgKGVhci5wcmV2ICE9PSBlYXIubmV4dCkge1xuICAgICAgICBwcmV2ID0gZWFyLnByZXY7XG4gICAgICAgIG5leHQgPSBlYXIubmV4dDtcblxuICAgICAgICBpZiAoaW52U2l6ZSA/IGlzRWFySGFzaGVkKGVhciwgbWluWCwgbWluWSwgaW52U2l6ZSkgOiBpc0VhcihlYXIpKSB7XG4gICAgICAgICAgICAvLyBjdXQgb2ZmIHRoZSB0cmlhbmdsZVxuICAgICAgICAgICAgdHJpYW5nbGVzLnB1c2gocHJldi5pIC8gZGltIHwgMCk7XG4gICAgICAgICAgICB0cmlhbmdsZXMucHVzaChlYXIuaSAvIGRpbSB8IDApO1xuICAgICAgICAgICAgdHJpYW5nbGVzLnB1c2gobmV4dC5pIC8gZGltIHwgMCk7XG5cbiAgICAgICAgICAgIHJlbW92ZU5vZGUoZWFyKTtcblxuICAgICAgICAgICAgLy8gc2tpcHBpbmcgdGhlIG5leHQgdmVydGV4IGxlYWRzIHRvIGxlc3Mgc2xpdmVyIHRyaWFuZ2xlc1xuICAgICAgICAgICAgZWFyID0gbmV4dC5uZXh0O1xuICAgICAgICAgICAgc3RvcCA9IG5leHQubmV4dDtcblxuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICBlYXIgPSBuZXh0O1xuXG4gICAgICAgIC8vIGlmIHdlIGxvb3BlZCB0aHJvdWdoIHRoZSB3aG9sZSByZW1haW5pbmcgcG9seWdvbiBhbmQgY2FuJ3QgZmluZCBhbnkgbW9yZSBlYXJzXG4gICAgICAgIGlmIChlYXIgPT09IHN0b3ApIHtcbiAgICAgICAgICAgIC8vIHRyeSBmaWx0ZXJpbmcgcG9pbnRzIGFuZCBzbGljaW5nIGFnYWluXG4gICAgICAgICAgICBpZiAoIXBhc3MpIHtcbiAgICAgICAgICAgICAgICBlYXJjdXRMaW5rZWQoZmlsdGVyUG9pbnRzKGVhciksIHRyaWFuZ2xlcywgZGltLCBtaW5YLCBtaW5ZLCBpbnZTaXplLCAxKTtcblxuICAgICAgICAgICAgLy8gaWYgdGhpcyBkaWRuJ3Qgd29yaywgdHJ5IGN1cmluZyBhbGwgc21hbGwgc2VsZi1pbnRlcnNlY3Rpb25zIGxvY2FsbHlcbiAgICAgICAgICAgIH0gZWxzZSBpZiAocGFzcyA9PT0gMSkge1xuICAgICAgICAgICAgICAgIGVhciA9IGN1cmVMb2NhbEludGVyc2VjdGlvbnMoZmlsdGVyUG9pbnRzKGVhciksIHRyaWFuZ2xlcywgZGltKTtcbiAgICAgICAgICAgICAgICBlYXJjdXRMaW5rZWQoZWFyLCB0cmlhbmdsZXMsIGRpbSwgbWluWCwgbWluWSwgaW52U2l6ZSwgMik7XG5cbiAgICAgICAgICAgIC8vIGFzIGEgbGFzdCByZXNvcnQsIHRyeSBzcGxpdHRpbmcgdGhlIHJlbWFpbmluZyBwb2x5Z29uIGludG8gdHdvXG4gICAgICAgICAgICB9IGVsc2UgaWYgKHBhc3MgPT09IDIpIHtcbiAgICAgICAgICAgICAgICBzcGxpdEVhcmN1dChlYXIsIHRyaWFuZ2xlcywgZGltLCBtaW5YLCBtaW5ZLCBpbnZTaXplKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbi8vIGNoZWNrIHdoZXRoZXIgYSBwb2x5Z29uIG5vZGUgZm9ybXMgYSB2YWxpZCBlYXIgd2l0aCBhZGphY2VudCBub2Rlc1xuZnVuY3Rpb24gaXNFYXIoZWFyKSB7XG4gICAgdmFyIGEgPSBlYXIucHJldixcbiAgICAgICAgYiA9IGVhcixcbiAgICAgICAgYyA9IGVhci5uZXh0O1xuXG4gICAgaWYgKGFyZWEoYSwgYiwgYykgPj0gMCkgcmV0dXJuIGZhbHNlOyAvLyByZWZsZXgsIGNhbid0IGJlIGFuIGVhclxuXG4gICAgLy8gbm93IG1ha2Ugc3VyZSB3ZSBkb24ndCBoYXZlIG90aGVyIHBvaW50cyBpbnNpZGUgdGhlIHBvdGVudGlhbCBlYXJcbiAgICB2YXIgYXggPSBhLngsIGJ4ID0gYi54LCBjeCA9IGMueCwgYXkgPSBhLnksIGJ5ID0gYi55LCBjeSA9IGMueTtcblxuICAgIC8vIHRyaWFuZ2xlIGJib3g7IG1pbiAmIG1heCBhcmUgY2FsY3VsYXRlZCBsaWtlIHRoaXMgZm9yIHNwZWVkXG4gICAgdmFyIHgwID0gYXggPCBieCA/IChheCA8IGN4ID8gYXggOiBjeCkgOiAoYnggPCBjeCA/IGJ4IDogY3gpLFxuICAgICAgICB5MCA9IGF5IDwgYnkgPyAoYXkgPCBjeSA/IGF5IDogY3kpIDogKGJ5IDwgY3kgPyBieSA6IGN5KSxcbiAgICAgICAgeDEgPSBheCA+IGJ4ID8gKGF4ID4gY3ggPyBheCA6IGN4KSA6IChieCA+IGN4ID8gYnggOiBjeCksXG4gICAgICAgIHkxID0gYXkgPiBieSA/IChheSA+IGN5ID8gYXkgOiBjeSkgOiAoYnkgPiBjeSA/IGJ5IDogY3kpO1xuXG4gICAgdmFyIHAgPSBjLm5leHQ7XG4gICAgd2hpbGUgKHAgIT09IGEpIHtcbiAgICAgICAgaWYgKHAueCA+PSB4MCAmJiBwLnggPD0geDEgJiYgcC55ID49IHkwICYmIHAueSA8PSB5MSAmJlxuICAgICAgICAgICAgcG9pbnRJblRyaWFuZ2xlKGF4LCBheSwgYngsIGJ5LCBjeCwgY3ksIHAueCwgcC55KSAmJlxuICAgICAgICAgICAgYXJlYShwLnByZXYsIHAsIHAubmV4dCkgPj0gMCkgcmV0dXJuIGZhbHNlO1xuICAgICAgICBwID0gcC5uZXh0O1xuICAgIH1cblxuICAgIHJldHVybiB0cnVlO1xufVxuXG5mdW5jdGlvbiBpc0Vhckhhc2hlZChlYXIsIG1pblgsIG1pblksIGludlNpemUpIHtcbiAgICB2YXIgYSA9IGVhci5wcmV2LFxuICAgICAgICBiID0gZWFyLFxuICAgICAgICBjID0gZWFyLm5leHQ7XG5cbiAgICBpZiAoYXJlYShhLCBiLCBjKSA+PSAwKSByZXR1cm4gZmFsc2U7IC8vIHJlZmxleCwgY2FuJ3QgYmUgYW4gZWFyXG5cbiAgICB2YXIgYXggPSBhLngsIGJ4ID0gYi54LCBjeCA9IGMueCwgYXkgPSBhLnksIGJ5ID0gYi55LCBjeSA9IGMueTtcblxuICAgIC8vIHRyaWFuZ2xlIGJib3g7IG1pbiAmIG1heCBhcmUgY2FsY3VsYXRlZCBsaWtlIHRoaXMgZm9yIHNwZWVkXG4gICAgdmFyIHgwID0gYXggPCBieCA/IChheCA8IGN4ID8gYXggOiBjeCkgOiAoYnggPCBjeCA/IGJ4IDogY3gpLFxuICAgICAgICB5MCA9IGF5IDwgYnkgPyAoYXkgPCBjeSA/IGF5IDogY3kpIDogKGJ5IDwgY3kgPyBieSA6IGN5KSxcbiAgICAgICAgeDEgPSBheCA+IGJ4ID8gKGF4ID4gY3ggPyBheCA6IGN4KSA6IChieCA+IGN4ID8gYnggOiBjeCksXG4gICAgICAgIHkxID0gYXkgPiBieSA/IChheSA+IGN5ID8gYXkgOiBjeSkgOiAoYnkgPiBjeSA/IGJ5IDogY3kpO1xuXG4gICAgLy8gei1vcmRlciByYW5nZSBmb3IgdGhlIGN1cnJlbnQgdHJpYW5nbGUgYmJveDtcbiAgICB2YXIgbWluWiA9IHpPcmRlcih4MCwgeTAsIG1pblgsIG1pblksIGludlNpemUpLFxuICAgICAgICBtYXhaID0gek9yZGVyKHgxLCB5MSwgbWluWCwgbWluWSwgaW52U2l6ZSk7XG5cbiAgICB2YXIgcCA9IGVhci5wcmV2WixcbiAgICAgICAgbiA9IGVhci5uZXh0WjtcblxuICAgIC8vIGxvb2sgZm9yIHBvaW50cyBpbnNpZGUgdGhlIHRyaWFuZ2xlIGluIGJvdGggZGlyZWN0aW9uc1xuICAgIHdoaWxlIChwICYmIHAueiA+PSBtaW5aICYmIG4gJiYgbi56IDw9IG1heFopIHtcbiAgICAgICAgaWYgKHAueCA+PSB4MCAmJiBwLnggPD0geDEgJiYgcC55ID49IHkwICYmIHAueSA8PSB5MSAmJiBwICE9PSBhICYmIHAgIT09IGMgJiZcbiAgICAgICAgICAgIHBvaW50SW5UcmlhbmdsZShheCwgYXksIGJ4LCBieSwgY3gsIGN5LCBwLngsIHAueSkgJiYgYXJlYShwLnByZXYsIHAsIHAubmV4dCkgPj0gMCkgcmV0dXJuIGZhbHNlO1xuICAgICAgICBwID0gcC5wcmV2WjtcblxuICAgICAgICBpZiAobi54ID49IHgwICYmIG4ueCA8PSB4MSAmJiBuLnkgPj0geTAgJiYgbi55IDw9IHkxICYmIG4gIT09IGEgJiYgbiAhPT0gYyAmJlxuICAgICAgICAgICAgcG9pbnRJblRyaWFuZ2xlKGF4LCBheSwgYngsIGJ5LCBjeCwgY3ksIG4ueCwgbi55KSAmJiBhcmVhKG4ucHJldiwgbiwgbi5uZXh0KSA+PSAwKSByZXR1cm4gZmFsc2U7XG4gICAgICAgIG4gPSBuLm5leHRaO1xuICAgIH1cblxuICAgIC8vIGxvb2sgZm9yIHJlbWFpbmluZyBwb2ludHMgaW4gZGVjcmVhc2luZyB6LW9yZGVyXG4gICAgd2hpbGUgKHAgJiYgcC56ID49IG1pblopIHtcbiAgICAgICAgaWYgKHAueCA+PSB4MCAmJiBwLnggPD0geDEgJiYgcC55ID49IHkwICYmIHAueSA8PSB5MSAmJiBwICE9PSBhICYmIHAgIT09IGMgJiZcbiAgICAgICAgICAgIHBvaW50SW5UcmlhbmdsZShheCwgYXksIGJ4LCBieSwgY3gsIGN5LCBwLngsIHAueSkgJiYgYXJlYShwLnByZXYsIHAsIHAubmV4dCkgPj0gMCkgcmV0dXJuIGZhbHNlO1xuICAgICAgICBwID0gcC5wcmV2WjtcbiAgICB9XG5cbiAgICAvLyBsb29rIGZvciByZW1haW5pbmcgcG9pbnRzIGluIGluY3JlYXNpbmcgei1vcmRlclxuICAgIHdoaWxlIChuICYmIG4ueiA8PSBtYXhaKSB7XG4gICAgICAgIGlmIChuLnggPj0geDAgJiYgbi54IDw9IHgxICYmIG4ueSA+PSB5MCAmJiBuLnkgPD0geTEgJiYgbiAhPT0gYSAmJiBuICE9PSBjICYmXG4gICAgICAgICAgICBwb2ludEluVHJpYW5nbGUoYXgsIGF5LCBieCwgYnksIGN4LCBjeSwgbi54LCBuLnkpICYmIGFyZWEobi5wcmV2LCBuLCBuLm5leHQpID49IDApIHJldHVybiBmYWxzZTtcbiAgICAgICAgbiA9IG4ubmV4dFo7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRydWU7XG59XG5cbi8vIGdvIHRocm91Z2ggYWxsIHBvbHlnb24gbm9kZXMgYW5kIGN1cmUgc21hbGwgbG9jYWwgc2VsZi1pbnRlcnNlY3Rpb25zXG5mdW5jdGlvbiBjdXJlTG9jYWxJbnRlcnNlY3Rpb25zKHN0YXJ0LCB0cmlhbmdsZXMsIGRpbSkge1xuICAgIHZhciBwID0gc3RhcnQ7XG4gICAgZG8ge1xuICAgICAgICB2YXIgYSA9IHAucHJldixcbiAgICAgICAgICAgIGIgPSBwLm5leHQubmV4dDtcblxuICAgICAgICBpZiAoIWVxdWFscyhhLCBiKSAmJiBpbnRlcnNlY3RzKGEsIHAsIHAubmV4dCwgYikgJiYgbG9jYWxseUluc2lkZShhLCBiKSAmJiBsb2NhbGx5SW5zaWRlKGIsIGEpKSB7XG5cbiAgICAgICAgICAgIHRyaWFuZ2xlcy5wdXNoKGEuaSAvIGRpbSB8IDApO1xuICAgICAgICAgICAgdHJpYW5nbGVzLnB1c2gocC5pIC8gZGltIHwgMCk7XG4gICAgICAgICAgICB0cmlhbmdsZXMucHVzaChiLmkgLyBkaW0gfCAwKTtcblxuICAgICAgICAgICAgLy8gcmVtb3ZlIHR3byBub2RlcyBpbnZvbHZlZFxuICAgICAgICAgICAgcmVtb3ZlTm9kZShwKTtcbiAgICAgICAgICAgIHJlbW92ZU5vZGUocC5uZXh0KTtcblxuICAgICAgICAgICAgcCA9IHN0YXJ0ID0gYjtcbiAgICAgICAgfVxuICAgICAgICBwID0gcC5uZXh0O1xuICAgIH0gd2hpbGUgKHAgIT09IHN0YXJ0KTtcblxuICAgIHJldHVybiBmaWx0ZXJQb2ludHMocCk7XG59XG5cbi8vIHRyeSBzcGxpdHRpbmcgcG9seWdvbiBpbnRvIHR3byBhbmQgdHJpYW5ndWxhdGUgdGhlbSBpbmRlcGVuZGVudGx5XG5mdW5jdGlvbiBzcGxpdEVhcmN1dChzdGFydCwgdHJpYW5nbGVzLCBkaW0sIG1pblgsIG1pblksIGludlNpemUpIHtcbiAgICAvLyBsb29rIGZvciBhIHZhbGlkIGRpYWdvbmFsIHRoYXQgZGl2aWRlcyB0aGUgcG9seWdvbiBpbnRvIHR3b1xuICAgIHZhciBhID0gc3RhcnQ7XG4gICAgZG8ge1xuICAgICAgICB2YXIgYiA9IGEubmV4dC5uZXh0O1xuICAgICAgICB3aGlsZSAoYiAhPT0gYS5wcmV2KSB7XG4gICAgICAgICAgICBpZiAoYS5pICE9PSBiLmkgJiYgaXNWYWxpZERpYWdvbmFsKGEsIGIpKSB7XG4gICAgICAgICAgICAgICAgLy8gc3BsaXQgdGhlIHBvbHlnb24gaW4gdHdvIGJ5IHRoZSBkaWFnb25hbFxuICAgICAgICAgICAgICAgIHZhciBjID0gc3BsaXRQb2x5Z29uKGEsIGIpO1xuXG4gICAgICAgICAgICAgICAgLy8gZmlsdGVyIGNvbGluZWFyIHBvaW50cyBhcm91bmQgdGhlIGN1dHNcbiAgICAgICAgICAgICAgICBhID0gZmlsdGVyUG9pbnRzKGEsIGEubmV4dCk7XG4gICAgICAgICAgICAgICAgYyA9IGZpbHRlclBvaW50cyhjLCBjLm5leHQpO1xuXG4gICAgICAgICAgICAgICAgLy8gcnVuIGVhcmN1dCBvbiBlYWNoIGhhbGZcbiAgICAgICAgICAgICAgICBlYXJjdXRMaW5rZWQoYSwgdHJpYW5nbGVzLCBkaW0sIG1pblgsIG1pblksIGludlNpemUsIDApO1xuICAgICAgICAgICAgICAgIGVhcmN1dExpbmtlZChjLCB0cmlhbmdsZXMsIGRpbSwgbWluWCwgbWluWSwgaW52U2l6ZSwgMCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYiA9IGIubmV4dDtcbiAgICAgICAgfVxuICAgICAgICBhID0gYS5uZXh0O1xuICAgIH0gd2hpbGUgKGEgIT09IHN0YXJ0KTtcbn1cblxuLy8gbGluayBldmVyeSBob2xlIGludG8gdGhlIG91dGVyIGxvb3AsIHByb2R1Y2luZyBhIHNpbmdsZS1yaW5nIHBvbHlnb24gd2l0aG91dCBob2xlc1xuZnVuY3Rpb24gZWxpbWluYXRlSG9sZXMoZGF0YSwgaG9sZUluZGljZXMsIG91dGVyTm9kZSwgZGltKSB7XG4gICAgdmFyIHF1ZXVlID0gW10sXG4gICAgICAgIGksIGxlbiwgc3RhcnQsIGVuZCwgbGlzdDtcblxuICAgIGZvciAoaSA9IDAsIGxlbiA9IGhvbGVJbmRpY2VzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIHN0YXJ0ID0gaG9sZUluZGljZXNbaV0gKiBkaW07XG4gICAgICAgIGVuZCA9IGkgPCBsZW4gLSAxID8gaG9sZUluZGljZXNbaSArIDFdICogZGltIDogZGF0YS5sZW5ndGg7XG4gICAgICAgIGxpc3QgPSBsaW5rZWRMaXN0KGRhdGEsIHN0YXJ0LCBlbmQsIGRpbSwgZmFsc2UpO1xuICAgICAgICBpZiAobGlzdCA9PT0gbGlzdC5uZXh0KSBsaXN0LnN0ZWluZXIgPSB0cnVlO1xuICAgICAgICBxdWV1ZS5wdXNoKGdldExlZnRtb3N0KGxpc3QpKTtcbiAgICB9XG5cbiAgICBxdWV1ZS5zb3J0KGNvbXBhcmVYKTtcblxuICAgIC8vIHByb2Nlc3MgaG9sZXMgZnJvbSBsZWZ0IHRvIHJpZ2h0XG4gICAgZm9yIChpID0gMDsgaSA8IHF1ZXVlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIG91dGVyTm9kZSA9IGVsaW1pbmF0ZUhvbGUocXVldWVbaV0sIG91dGVyTm9kZSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG91dGVyTm9kZTtcbn1cblxuZnVuY3Rpb24gY29tcGFyZVgoYSwgYikge1xuICAgIHJldHVybiBhLnggLSBiLng7XG59XG5cbi8vIGZpbmQgYSBicmlkZ2UgYmV0d2VlbiB2ZXJ0aWNlcyB0aGF0IGNvbm5lY3RzIGhvbGUgd2l0aCBhbiBvdXRlciByaW5nIGFuZCBhbmQgbGluayBpdFxuZnVuY3Rpb24gZWxpbWluYXRlSG9sZShob2xlLCBvdXRlck5vZGUpIHtcbiAgICB2YXIgYnJpZGdlID0gZmluZEhvbGVCcmlkZ2UoaG9sZSwgb3V0ZXJOb2RlKTtcbiAgICBpZiAoIWJyaWRnZSkge1xuICAgICAgICByZXR1cm4gb3V0ZXJOb2RlO1xuICAgIH1cblxuICAgIHZhciBicmlkZ2VSZXZlcnNlID0gc3BsaXRQb2x5Z29uKGJyaWRnZSwgaG9sZSk7XG5cbiAgICAvLyBmaWx0ZXIgY29sbGluZWFyIHBvaW50cyBhcm91bmQgdGhlIGN1dHNcbiAgICBmaWx0ZXJQb2ludHMoYnJpZGdlUmV2ZXJzZSwgYnJpZGdlUmV2ZXJzZS5uZXh0KTtcbiAgICByZXR1cm4gZmlsdGVyUG9pbnRzKGJyaWRnZSwgYnJpZGdlLm5leHQpO1xufVxuXG4vLyBEYXZpZCBFYmVybHkncyBhbGdvcml0aG0gZm9yIGZpbmRpbmcgYSBicmlkZ2UgYmV0d2VlbiBob2xlIGFuZCBvdXRlciBwb2x5Z29uXG5mdW5jdGlvbiBmaW5kSG9sZUJyaWRnZShob2xlLCBvdXRlck5vZGUpIHtcbiAgICB2YXIgcCA9IG91dGVyTm9kZSxcbiAgICAgICAgaHggPSBob2xlLngsXG4gICAgICAgIGh5ID0gaG9sZS55LFxuICAgICAgICBxeCA9IC1JbmZpbml0eSxcbiAgICAgICAgbTtcblxuICAgIC8vIGZpbmQgYSBzZWdtZW50IGludGVyc2VjdGVkIGJ5IGEgcmF5IGZyb20gdGhlIGhvbGUncyBsZWZ0bW9zdCBwb2ludCB0byB0aGUgbGVmdDtcbiAgICAvLyBzZWdtZW50J3MgZW5kcG9pbnQgd2l0aCBsZXNzZXIgeCB3aWxsIGJlIHBvdGVudGlhbCBjb25uZWN0aW9uIHBvaW50XG4gICAgZG8ge1xuICAgICAgICBpZiAoaHkgPD0gcC55ICYmIGh5ID49IHAubmV4dC55ICYmIHAubmV4dC55ICE9PSBwLnkpIHtcbiAgICAgICAgICAgIHZhciB4ID0gcC54ICsgKGh5IC0gcC55KSAqIChwLm5leHQueCAtIHAueCkgLyAocC5uZXh0LnkgLSBwLnkpO1xuICAgICAgICAgICAgaWYgKHggPD0gaHggJiYgeCA+IHF4KSB7XG4gICAgICAgICAgICAgICAgcXggPSB4O1xuICAgICAgICAgICAgICAgIG0gPSBwLnggPCBwLm5leHQueCA/IHAgOiBwLm5leHQ7XG4gICAgICAgICAgICAgICAgaWYgKHggPT09IGh4KSByZXR1cm4gbTsgLy8gaG9sZSB0b3VjaGVzIG91dGVyIHNlZ21lbnQ7IHBpY2sgbGVmdG1vc3QgZW5kcG9pbnRcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBwID0gcC5uZXh0O1xuICAgIH0gd2hpbGUgKHAgIT09IG91dGVyTm9kZSk7XG5cbiAgICBpZiAoIW0pIHJldHVybiBudWxsO1xuXG4gICAgLy8gbG9vayBmb3IgcG9pbnRzIGluc2lkZSB0aGUgdHJpYW5nbGUgb2YgaG9sZSBwb2ludCwgc2VnbWVudCBpbnRlcnNlY3Rpb24gYW5kIGVuZHBvaW50O1xuICAgIC8vIGlmIHRoZXJlIGFyZSBubyBwb2ludHMgZm91bmQsIHdlIGhhdmUgYSB2YWxpZCBjb25uZWN0aW9uO1xuICAgIC8vIG90aGVyd2lzZSBjaG9vc2UgdGhlIHBvaW50IG9mIHRoZSBtaW5pbXVtIGFuZ2xlIHdpdGggdGhlIHJheSBhcyBjb25uZWN0aW9uIHBvaW50XG5cbiAgICB2YXIgc3RvcCA9IG0sXG4gICAgICAgIG14ID0gbS54LFxuICAgICAgICBteSA9IG0ueSxcbiAgICAgICAgdGFuTWluID0gSW5maW5pdHksXG4gICAgICAgIHRhbjtcblxuICAgIHAgPSBtO1xuXG4gICAgZG8ge1xuICAgICAgICBpZiAoaHggPj0gcC54ICYmIHAueCA+PSBteCAmJiBoeCAhPT0gcC54ICYmXG4gICAgICAgICAgICAgICAgcG9pbnRJblRyaWFuZ2xlKGh5IDwgbXkgPyBoeCA6IHF4LCBoeSwgbXgsIG15LCBoeSA8IG15ID8gcXggOiBoeCwgaHksIHAueCwgcC55KSkge1xuXG4gICAgICAgICAgICB0YW4gPSBNYXRoLmFicyhoeSAtIHAueSkgLyAoaHggLSBwLngpOyAvLyB0YW5nZW50aWFsXG5cbiAgICAgICAgICAgIGlmIChsb2NhbGx5SW5zaWRlKHAsIGhvbGUpICYmXG4gICAgICAgICAgICAgICAgKHRhbiA8IHRhbk1pbiB8fCAodGFuID09PSB0YW5NaW4gJiYgKHAueCA+IG0ueCB8fCAocC54ID09PSBtLnggJiYgc2VjdG9yQ29udGFpbnNTZWN0b3IobSwgcCkpKSkpKSB7XG4gICAgICAgICAgICAgICAgbSA9IHA7XG4gICAgICAgICAgICAgICAgdGFuTWluID0gdGFuO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcCA9IHAubmV4dDtcbiAgICB9IHdoaWxlIChwICE9PSBzdG9wKTtcblxuICAgIHJldHVybiBtO1xufVxuXG4vLyB3aGV0aGVyIHNlY3RvciBpbiB2ZXJ0ZXggbSBjb250YWlucyBzZWN0b3IgaW4gdmVydGV4IHAgaW4gdGhlIHNhbWUgY29vcmRpbmF0ZXNcbmZ1bmN0aW9uIHNlY3RvckNvbnRhaW5zU2VjdG9yKG0sIHApIHtcbiAgICByZXR1cm4gYXJlYShtLnByZXYsIG0sIHAucHJldikgPCAwICYmIGFyZWEocC5uZXh0LCBtLCBtLm5leHQpIDwgMDtcbn1cblxuLy8gaW50ZXJsaW5rIHBvbHlnb24gbm9kZXMgaW4gei1vcmRlclxuZnVuY3Rpb24gaW5kZXhDdXJ2ZShzdGFydCwgbWluWCwgbWluWSwgaW52U2l6ZSkge1xuICAgIHZhciBwID0gc3RhcnQ7XG4gICAgZG8ge1xuICAgICAgICBpZiAocC56ID09PSAwKSBwLnogPSB6T3JkZXIocC54LCBwLnksIG1pblgsIG1pblksIGludlNpemUpO1xuICAgICAgICBwLnByZXZaID0gcC5wcmV2O1xuICAgICAgICBwLm5leHRaID0gcC5uZXh0O1xuICAgICAgICBwID0gcC5uZXh0O1xuICAgIH0gd2hpbGUgKHAgIT09IHN0YXJ0KTtcblxuICAgIHAucHJldloubmV4dFogPSBudWxsO1xuICAgIHAucHJldlogPSBudWxsO1xuXG4gICAgc29ydExpbmtlZChwKTtcbn1cblxuLy8gU2ltb24gVGF0aGFtJ3MgbGlua2VkIGxpc3QgbWVyZ2Ugc29ydCBhbGdvcml0aG1cbi8vIGh0dHA6Ly93d3cuY2hpYXJrLmdyZWVuZW5kLm9yZy51ay9+c2d0YXRoYW0vYWxnb3JpdGhtcy9saXN0c29ydC5odG1sXG5mdW5jdGlvbiBzb3J0TGlua2VkKGxpc3QpIHtcbiAgICB2YXIgaSwgcCwgcSwgZSwgdGFpbCwgbnVtTWVyZ2VzLCBwU2l6ZSwgcVNpemUsXG4gICAgICAgIGluU2l6ZSA9IDE7XG5cbiAgICBkbyB7XG4gICAgICAgIHAgPSBsaXN0O1xuICAgICAgICBsaXN0ID0gbnVsbDtcbiAgICAgICAgdGFpbCA9IG51bGw7XG4gICAgICAgIG51bU1lcmdlcyA9IDA7XG5cbiAgICAgICAgd2hpbGUgKHApIHtcbiAgICAgICAgICAgIG51bU1lcmdlcysrO1xuICAgICAgICAgICAgcSA9IHA7XG4gICAgICAgICAgICBwU2l6ZSA9IDA7XG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgaW5TaXplOyBpKyspIHtcbiAgICAgICAgICAgICAgICBwU2l6ZSsrO1xuICAgICAgICAgICAgICAgIHEgPSBxLm5leHRaO1xuICAgICAgICAgICAgICAgIGlmICghcSkgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBxU2l6ZSA9IGluU2l6ZTtcblxuICAgICAgICAgICAgd2hpbGUgKHBTaXplID4gMCB8fCAocVNpemUgPiAwICYmIHEpKSB7XG5cbiAgICAgICAgICAgICAgICBpZiAocFNpemUgIT09IDAgJiYgKHFTaXplID09PSAwIHx8ICFxIHx8IHAueiA8PSBxLnopKSB7XG4gICAgICAgICAgICAgICAgICAgIGUgPSBwO1xuICAgICAgICAgICAgICAgICAgICBwID0gcC5uZXh0WjtcbiAgICAgICAgICAgICAgICAgICAgcFNpemUtLTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBlID0gcTtcbiAgICAgICAgICAgICAgICAgICAgcSA9IHEubmV4dFo7XG4gICAgICAgICAgICAgICAgICAgIHFTaXplLS07XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKHRhaWwpIHRhaWwubmV4dFogPSBlO1xuICAgICAgICAgICAgICAgIGVsc2UgbGlzdCA9IGU7XG5cbiAgICAgICAgICAgICAgICBlLnByZXZaID0gdGFpbDtcbiAgICAgICAgICAgICAgICB0YWlsID0gZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcCA9IHE7XG4gICAgICAgIH1cblxuICAgICAgICB0YWlsLm5leHRaID0gbnVsbDtcbiAgICAgICAgaW5TaXplICo9IDI7XG5cbiAgICB9IHdoaWxlIChudW1NZXJnZXMgPiAxKTtcblxuICAgIHJldHVybiBsaXN0O1xufVxuXG4vLyB6LW9yZGVyIG9mIGEgcG9pbnQgZ2l2ZW4gY29vcmRzIGFuZCBpbnZlcnNlIG9mIHRoZSBsb25nZXIgc2lkZSBvZiBkYXRhIGJib3hcbmZ1bmN0aW9uIHpPcmRlcih4LCB5LCBtaW5YLCBtaW5ZLCBpbnZTaXplKSB7XG4gICAgLy8gY29vcmRzIGFyZSB0cmFuc2Zvcm1lZCBpbnRvIG5vbi1uZWdhdGl2ZSAxNS1iaXQgaW50ZWdlciByYW5nZVxuICAgIHggPSAoeCAtIG1pblgpICogaW52U2l6ZSB8IDA7XG4gICAgeSA9ICh5IC0gbWluWSkgKiBpbnZTaXplIHwgMDtcblxuICAgIHggPSAoeCB8ICh4IDw8IDgpKSAmIDB4MDBGRjAwRkY7XG4gICAgeCA9ICh4IHwgKHggPDwgNCkpICYgMHgwRjBGMEYwRjtcbiAgICB4ID0gKHggfCAoeCA8PCAyKSkgJiAweDMzMzMzMzMzO1xuICAgIHggPSAoeCB8ICh4IDw8IDEpKSAmIDB4NTU1NTU1NTU7XG5cbiAgICB5ID0gKHkgfCAoeSA8PCA4KSkgJiAweDAwRkYwMEZGO1xuICAgIHkgPSAoeSB8ICh5IDw8IDQpKSAmIDB4MEYwRjBGMEY7XG4gICAgeSA9ICh5IHwgKHkgPDwgMikpICYgMHgzMzMzMzMzMztcbiAgICB5ID0gKHkgfCAoeSA8PCAxKSkgJiAweDU1NTU1NTU1O1xuXG4gICAgcmV0dXJuIHggfCAoeSA8PCAxKTtcbn1cblxuLy8gZmluZCB0aGUgbGVmdG1vc3Qgbm9kZSBvZiBhIHBvbHlnb24gcmluZ1xuZnVuY3Rpb24gZ2V0TGVmdG1vc3Qoc3RhcnQpIHtcbiAgICB2YXIgcCA9IHN0YXJ0LFxuICAgICAgICBsZWZ0bW9zdCA9IHN0YXJ0O1xuICAgIGRvIHtcbiAgICAgICAgaWYgKHAueCA8IGxlZnRtb3N0LnggfHwgKHAueCA9PT0gbGVmdG1vc3QueCAmJiBwLnkgPCBsZWZ0bW9zdC55KSkgbGVmdG1vc3QgPSBwO1xuICAgICAgICBwID0gcC5uZXh0O1xuICAgIH0gd2hpbGUgKHAgIT09IHN0YXJ0KTtcblxuICAgIHJldHVybiBsZWZ0bW9zdDtcbn1cblxuLy8gY2hlY2sgaWYgYSBwb2ludCBsaWVzIHdpdGhpbiBhIGNvbnZleCB0cmlhbmdsZVxuZnVuY3Rpb24gcG9pbnRJblRyaWFuZ2xlKGF4LCBheSwgYngsIGJ5LCBjeCwgY3ksIHB4LCBweSkge1xuICAgIHJldHVybiAoY3ggLSBweCkgKiAoYXkgLSBweSkgPj0gKGF4IC0gcHgpICogKGN5IC0gcHkpICYmXG4gICAgICAgICAgIChheCAtIHB4KSAqIChieSAtIHB5KSA+PSAoYnggLSBweCkgKiAoYXkgLSBweSkgJiZcbiAgICAgICAgICAgKGJ4IC0gcHgpICogKGN5IC0gcHkpID49IChjeCAtIHB4KSAqIChieSAtIHB5KTtcbn1cblxuLy8gY2hlY2sgaWYgYSBkaWFnb25hbCBiZXR3ZWVuIHR3byBwb2x5Z29uIG5vZGVzIGlzIHZhbGlkIChsaWVzIGluIHBvbHlnb24gaW50ZXJpb3IpXG5mdW5jdGlvbiBpc1ZhbGlkRGlhZ29uYWwoYSwgYikge1xuICAgIHJldHVybiBhLm5leHQuaSAhPT0gYi5pICYmIGEucHJldi5pICE9PSBiLmkgJiYgIWludGVyc2VjdHNQb2x5Z29uKGEsIGIpICYmIC8vIGRvbmVzJ3QgaW50ZXJzZWN0IG90aGVyIGVkZ2VzXG4gICAgICAgICAgIChsb2NhbGx5SW5zaWRlKGEsIGIpICYmIGxvY2FsbHlJbnNpZGUoYiwgYSkgJiYgbWlkZGxlSW5zaWRlKGEsIGIpICYmIC8vIGxvY2FsbHkgdmlzaWJsZVxuICAgICAgICAgICAgKGFyZWEoYS5wcmV2LCBhLCBiLnByZXYpIHx8IGFyZWEoYSwgYi5wcmV2LCBiKSkgfHwgLy8gZG9lcyBub3QgY3JlYXRlIG9wcG9zaXRlLWZhY2luZyBzZWN0b3JzXG4gICAgICAgICAgICBlcXVhbHMoYSwgYikgJiYgYXJlYShhLnByZXYsIGEsIGEubmV4dCkgPiAwICYmIGFyZWEoYi5wcmV2LCBiLCBiLm5leHQpID4gMCk7IC8vIHNwZWNpYWwgemVyby1sZW5ndGggY2FzZVxufVxuXG4vLyBzaWduZWQgYXJlYSBvZiBhIHRyaWFuZ2xlXG5mdW5jdGlvbiBhcmVhKHAsIHEsIHIpIHtcbiAgICByZXR1cm4gKHEueSAtIHAueSkgKiAoci54IC0gcS54KSAtIChxLnggLSBwLngpICogKHIueSAtIHEueSk7XG59XG5cbi8vIGNoZWNrIGlmIHR3byBwb2ludHMgYXJlIGVxdWFsXG5mdW5jdGlvbiBlcXVhbHMocDEsIHAyKSB7XG4gICAgcmV0dXJuIHAxLnggPT09IHAyLnggJiYgcDEueSA9PT0gcDIueTtcbn1cblxuLy8gY2hlY2sgaWYgdHdvIHNlZ21lbnRzIGludGVyc2VjdFxuZnVuY3Rpb24gaW50ZXJzZWN0cyhwMSwgcTEsIHAyLCBxMikge1xuICAgIHZhciBvMSA9IHNpZ24oYXJlYShwMSwgcTEsIHAyKSk7XG4gICAgdmFyIG8yID0gc2lnbihhcmVhKHAxLCBxMSwgcTIpKTtcbiAgICB2YXIgbzMgPSBzaWduKGFyZWEocDIsIHEyLCBwMSkpO1xuICAgIHZhciBvNCA9IHNpZ24oYXJlYShwMiwgcTIsIHExKSk7XG5cbiAgICBpZiAobzEgIT09IG8yICYmIG8zICE9PSBvNCkgcmV0dXJuIHRydWU7IC8vIGdlbmVyYWwgY2FzZVxuXG4gICAgaWYgKG8xID09PSAwICYmIG9uU2VnbWVudChwMSwgcDIsIHExKSkgcmV0dXJuIHRydWU7IC8vIHAxLCBxMSBhbmQgcDIgYXJlIGNvbGxpbmVhciBhbmQgcDIgbGllcyBvbiBwMXExXG4gICAgaWYgKG8yID09PSAwICYmIG9uU2VnbWVudChwMSwgcTIsIHExKSkgcmV0dXJuIHRydWU7IC8vIHAxLCBxMSBhbmQgcTIgYXJlIGNvbGxpbmVhciBhbmQgcTIgbGllcyBvbiBwMXExXG4gICAgaWYgKG8zID09PSAwICYmIG9uU2VnbWVudChwMiwgcDEsIHEyKSkgcmV0dXJuIHRydWU7IC8vIHAyLCBxMiBhbmQgcDEgYXJlIGNvbGxpbmVhciBhbmQgcDEgbGllcyBvbiBwMnEyXG4gICAgaWYgKG80ID09PSAwICYmIG9uU2VnbWVudChwMiwgcTEsIHEyKSkgcmV0dXJuIHRydWU7IC8vIHAyLCBxMiBhbmQgcTEgYXJlIGNvbGxpbmVhciBhbmQgcTEgbGllcyBvbiBwMnEyXG5cbiAgICByZXR1cm4gZmFsc2U7XG59XG5cbi8vIGZvciBjb2xsaW5lYXIgcG9pbnRzIHAsIHEsIHIsIGNoZWNrIGlmIHBvaW50IHEgbGllcyBvbiBzZWdtZW50IHByXG5mdW5jdGlvbiBvblNlZ21lbnQocCwgcSwgcikge1xuICAgIHJldHVybiBxLnggPD0gTWF0aC5tYXgocC54LCByLngpICYmIHEueCA+PSBNYXRoLm1pbihwLngsIHIueCkgJiYgcS55IDw9IE1hdGgubWF4KHAueSwgci55KSAmJiBxLnkgPj0gTWF0aC5taW4ocC55LCByLnkpO1xufVxuXG5mdW5jdGlvbiBzaWduKG51bSkge1xuICAgIHJldHVybiBudW0gPiAwID8gMSA6IG51bSA8IDAgPyAtMSA6IDA7XG59XG5cbi8vIGNoZWNrIGlmIGEgcG9seWdvbiBkaWFnb25hbCBpbnRlcnNlY3RzIGFueSBwb2x5Z29uIHNlZ21lbnRzXG5mdW5jdGlvbiBpbnRlcnNlY3RzUG9seWdvbihhLCBiKSB7XG4gICAgdmFyIHAgPSBhO1xuICAgIGRvIHtcbiAgICAgICAgaWYgKHAuaSAhPT0gYS5pICYmIHAubmV4dC5pICE9PSBhLmkgJiYgcC5pICE9PSBiLmkgJiYgcC5uZXh0LmkgIT09IGIuaSAmJlxuICAgICAgICAgICAgICAgIGludGVyc2VjdHMocCwgcC5uZXh0LCBhLCBiKSkgcmV0dXJuIHRydWU7XG4gICAgICAgIHAgPSBwLm5leHQ7XG4gICAgfSB3aGlsZSAocCAhPT0gYSk7XG5cbiAgICByZXR1cm4gZmFsc2U7XG59XG5cbi8vIGNoZWNrIGlmIGEgcG9seWdvbiBkaWFnb25hbCBpcyBsb2NhbGx5IGluc2lkZSB0aGUgcG9seWdvblxuZnVuY3Rpb24gbG9jYWxseUluc2lkZShhLCBiKSB7XG4gICAgcmV0dXJuIGFyZWEoYS5wcmV2LCBhLCBhLm5leHQpIDwgMCA/XG4gICAgICAgIGFyZWEoYSwgYiwgYS5uZXh0KSA+PSAwICYmIGFyZWEoYSwgYS5wcmV2LCBiKSA+PSAwIDpcbiAgICAgICAgYXJlYShhLCBiLCBhLnByZXYpIDwgMCB8fCBhcmVhKGEsIGEubmV4dCwgYikgPCAwO1xufVxuXG4vLyBjaGVjayBpZiB0aGUgbWlkZGxlIHBvaW50IG9mIGEgcG9seWdvbiBkaWFnb25hbCBpcyBpbnNpZGUgdGhlIHBvbHlnb25cbmZ1bmN0aW9uIG1pZGRsZUluc2lkZShhLCBiKSB7XG4gICAgdmFyIHAgPSBhLFxuICAgICAgICBpbnNpZGUgPSBmYWxzZSxcbiAgICAgICAgcHggPSAoYS54ICsgYi54KSAvIDIsXG4gICAgICAgIHB5ID0gKGEueSArIGIueSkgLyAyO1xuICAgIGRvIHtcbiAgICAgICAgaWYgKCgocC55ID4gcHkpICE9PSAocC5uZXh0LnkgPiBweSkpICYmIHAubmV4dC55ICE9PSBwLnkgJiZcbiAgICAgICAgICAgICAgICAocHggPCAocC5uZXh0LnggLSBwLngpICogKHB5IC0gcC55KSAvIChwLm5leHQueSAtIHAueSkgKyBwLngpKVxuICAgICAgICAgICAgaW5zaWRlID0gIWluc2lkZTtcbiAgICAgICAgcCA9IHAubmV4dDtcbiAgICB9IHdoaWxlIChwICE9PSBhKTtcblxuICAgIHJldHVybiBpbnNpZGU7XG59XG5cbi8vIGxpbmsgdHdvIHBvbHlnb24gdmVydGljZXMgd2l0aCBhIGJyaWRnZTsgaWYgdGhlIHZlcnRpY2VzIGJlbG9uZyB0byB0aGUgc2FtZSByaW5nLCBpdCBzcGxpdHMgcG9seWdvbiBpbnRvIHR3bztcbi8vIGlmIG9uZSBiZWxvbmdzIHRvIHRoZSBvdXRlciByaW5nIGFuZCBhbm90aGVyIHRvIGEgaG9sZSwgaXQgbWVyZ2VzIGl0IGludG8gYSBzaW5nbGUgcmluZ1xuZnVuY3Rpb24gc3BsaXRQb2x5Z29uKGEsIGIpIHtcbiAgICB2YXIgYTIgPSBuZXcgTm9kZShhLmksIGEueCwgYS55KSxcbiAgICAgICAgYjIgPSBuZXcgTm9kZShiLmksIGIueCwgYi55KSxcbiAgICAgICAgYW4gPSBhLm5leHQsXG4gICAgICAgIGJwID0gYi5wcmV2O1xuXG4gICAgYS5uZXh0ID0gYjtcbiAgICBiLnByZXYgPSBhO1xuXG4gICAgYTIubmV4dCA9IGFuO1xuICAgIGFuLnByZXYgPSBhMjtcblxuICAgIGIyLm5leHQgPSBhMjtcbiAgICBhMi5wcmV2ID0gYjI7XG5cbiAgICBicC5uZXh0ID0gYjI7XG4gICAgYjIucHJldiA9IGJwO1xuXG4gICAgcmV0dXJuIGIyO1xufVxuXG4vLyBjcmVhdGUgYSBub2RlIGFuZCBvcHRpb25hbGx5IGxpbmsgaXQgd2l0aCBwcmV2aW91cyBvbmUgKGluIGEgY2lyY3VsYXIgZG91Ymx5IGxpbmtlZCBsaXN0KVxuZnVuY3Rpb24gaW5zZXJ0Tm9kZShpLCB4LCB5LCBsYXN0KSB7XG4gICAgdmFyIHAgPSBuZXcgTm9kZShpLCB4LCB5KTtcblxuICAgIGlmICghbGFzdCkge1xuICAgICAgICBwLnByZXYgPSBwO1xuICAgICAgICBwLm5leHQgPSBwO1xuXG4gICAgfSBlbHNlIHtcbiAgICAgICAgcC5uZXh0ID0gbGFzdC5uZXh0O1xuICAgICAgICBwLnByZXYgPSBsYXN0O1xuICAgICAgICBsYXN0Lm5leHQucHJldiA9IHA7XG4gICAgICAgIGxhc3QubmV4dCA9IHA7XG4gICAgfVxuICAgIHJldHVybiBwO1xufVxuXG5mdW5jdGlvbiByZW1vdmVOb2RlKHApIHtcbiAgICBwLm5leHQucHJldiA9IHAucHJldjtcbiAgICBwLnByZXYubmV4dCA9IHAubmV4dDtcblxuICAgIGlmIChwLnByZXZaKSBwLnByZXZaLm5leHRaID0gcC5uZXh0WjtcbiAgICBpZiAocC5uZXh0WikgcC5uZXh0Wi5wcmV2WiA9IHAucHJldlo7XG59XG5cbmZ1bmN0aW9uIE5vZGUoaSwgeCwgeSkge1xuICAgIC8vIHZlcnRleCBpbmRleCBpbiBjb29yZGluYXRlcyBhcnJheVxuICAgIHRoaXMuaSA9IGk7XG5cbiAgICAvLyB2ZXJ0ZXggY29vcmRpbmF0ZXNcbiAgICB0aGlzLnggPSB4O1xuICAgIHRoaXMueSA9IHk7XG5cbiAgICAvLyBwcmV2aW91cyBhbmQgbmV4dCB2ZXJ0ZXggbm9kZXMgaW4gYSBwb2x5Z29uIHJpbmdcbiAgICB0aGlzLnByZXYgPSBudWxsO1xuICAgIHRoaXMubmV4dCA9IG51bGw7XG5cbiAgICAvLyB6LW9yZGVyIGN1cnZlIHZhbHVlXG4gICAgdGhpcy56ID0gMDtcblxuICAgIC8vIHByZXZpb3VzIGFuZCBuZXh0IG5vZGVzIGluIHotb3JkZXJcbiAgICB0aGlzLnByZXZaID0gbnVsbDtcbiAgICB0aGlzLm5leHRaID0gbnVsbDtcblxuICAgIC8vIGluZGljYXRlcyB3aGV0aGVyIHRoaXMgaXMgYSBzdGVpbmVyIHBvaW50XG4gICAgdGhpcy5zdGVpbmVyID0gZmFsc2U7XG59XG5cbi8vIHJldHVybiBhIHBlcmNlbnRhZ2UgZGlmZmVyZW5jZSBiZXR3ZWVuIHRoZSBwb2x5Z29uIGFyZWEgYW5kIGl0cyB0cmlhbmd1bGF0aW9uIGFyZWE7XG4vLyB1c2VkIHRvIHZlcmlmeSBjb3JyZWN0bmVzcyBvZiB0cmlhbmd1bGF0aW9uXG5lYXJjdXQuZGV2aWF0aW9uID0gZnVuY3Rpb24gKGRhdGEsIGhvbGVJbmRpY2VzLCBkaW0sIHRyaWFuZ2xlcykge1xuICAgIHZhciBoYXNIb2xlcyA9IGhvbGVJbmRpY2VzICYmIGhvbGVJbmRpY2VzLmxlbmd0aDtcbiAgICB2YXIgb3V0ZXJMZW4gPSBoYXNIb2xlcyA/IGhvbGVJbmRpY2VzWzBdICogZGltIDogZGF0YS5sZW5ndGg7XG5cbiAgICB2YXIgcG9seWdvbkFyZWEgPSBNYXRoLmFicyhzaWduZWRBcmVhKGRhdGEsIDAsIG91dGVyTGVuLCBkaW0pKTtcbiAgICBpZiAoaGFzSG9sZXMpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGhvbGVJbmRpY2VzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgc3RhcnQgPSBob2xlSW5kaWNlc1tpXSAqIGRpbTtcbiAgICAgICAgICAgIHZhciBlbmQgPSBpIDwgbGVuIC0gMSA/IGhvbGVJbmRpY2VzW2kgKyAxXSAqIGRpbSA6IGRhdGEubGVuZ3RoO1xuICAgICAgICAgICAgcG9seWdvbkFyZWEgLT0gTWF0aC5hYnMoc2lnbmVkQXJlYShkYXRhLCBzdGFydCwgZW5kLCBkaW0pKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHZhciB0cmlhbmdsZXNBcmVhID0gMDtcbiAgICBmb3IgKGkgPSAwOyBpIDwgdHJpYW5nbGVzLmxlbmd0aDsgaSArPSAzKSB7XG4gICAgICAgIHZhciBhID0gdHJpYW5nbGVzW2ldICogZGltO1xuICAgICAgICB2YXIgYiA9IHRyaWFuZ2xlc1tpICsgMV0gKiBkaW07XG4gICAgICAgIHZhciBjID0gdHJpYW5nbGVzW2kgKyAyXSAqIGRpbTtcbiAgICAgICAgdHJpYW5nbGVzQXJlYSArPSBNYXRoLmFicyhcbiAgICAgICAgICAgIChkYXRhW2FdIC0gZGF0YVtjXSkgKiAoZGF0YVtiICsgMV0gLSBkYXRhW2EgKyAxXSkgLVxuICAgICAgICAgICAgKGRhdGFbYV0gLSBkYXRhW2JdKSAqIChkYXRhW2MgKyAxXSAtIGRhdGFbYSArIDFdKSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHBvbHlnb25BcmVhID09PSAwICYmIHRyaWFuZ2xlc0FyZWEgPT09IDAgPyAwIDpcbiAgICAgICAgTWF0aC5hYnMoKHRyaWFuZ2xlc0FyZWEgLSBwb2x5Z29uQXJlYSkgLyBwb2x5Z29uQXJlYSk7XG59O1xuXG5mdW5jdGlvbiBzaWduZWRBcmVhKGRhdGEsIHN0YXJ0LCBlbmQsIGRpbSkge1xuICAgIHZhciBzdW0gPSAwO1xuICAgIGZvciAodmFyIGkgPSBzdGFydCwgaiA9IGVuZCAtIGRpbTsgaSA8IGVuZDsgaSArPSBkaW0pIHtcbiAgICAgICAgc3VtICs9IChkYXRhW2pdIC0gZGF0YVtpXSkgKiAoZGF0YVtpICsgMV0gKyBkYXRhW2ogKyAxXSk7XG4gICAgICAgIGogPSBpO1xuICAgIH1cbiAgICByZXR1cm4gc3VtO1xufVxuXG4vLyB0dXJuIGEgcG9seWdvbiBpbiBhIG11bHRpLWRpbWVuc2lvbmFsIGFycmF5IGZvcm0gKGUuZy4gYXMgaW4gR2VvSlNPTikgaW50byBhIGZvcm0gRWFyY3V0IGFjY2VwdHNcbmVhcmN1dC5mbGF0dGVuID0gZnVuY3Rpb24gKGRhdGEpIHtcbiAgICB2YXIgZGltID0gZGF0YVswXVswXS5sZW5ndGgsXG4gICAgICAgIHJlc3VsdCA9IHt2ZXJ0aWNlczogW10sIGhvbGVzOiBbXSwgZGltZW5zaW9uczogZGltfSxcbiAgICAgICAgaG9sZUluZGV4ID0gMDtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZGF0YS5sZW5ndGg7IGkrKykge1xuICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGRhdGFbaV0ubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgIGZvciAodmFyIGQgPSAwOyBkIDwgZGltOyBkKyspIHJlc3VsdC52ZXJ0aWNlcy5wdXNoKGRhdGFbaV1bal1bZF0pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpID4gMCkge1xuICAgICAgICAgICAgaG9sZUluZGV4ICs9IGRhdGFbaSAtIDFdLmxlbmd0aDtcbiAgICAgICAgICAgIHJlc3VsdC5ob2xlcy5wdXNoKGhvbGVJbmRleCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///9187\n")},52944:function(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__){eval("\n// EXPORTS\n__webpack_require__.d(__webpack_exports__, {\n  \"Qc\": function() { return /* reexport */ parse; },\n  \"Pz\": function() { return /* reexport */ stringify; }\n});\n\n// UNUSED EXPORTS: uneval, unflatten\n\n;// CONCATENATED MODULE: ./node_modules/devalue/src/utils.js\n/** @type {Record<string, string>} */\nconst utils_escaped = {\n\t'<': '\\\\u003C',\n\t'>': '\\\\u003E',\n\t'/': '\\\\u002F',\n\t'\\\\': '\\\\\\\\',\n\t'\\b': '\\\\b',\n\t'\\f': '\\\\f',\n\t'\\n': '\\\\n',\n\t'\\r': '\\\\r',\n\t'\\t': '\\\\t',\n\t'\\0': '\\\\u0000',\n\t'\\u2028': '\\\\u2028',\n\t'\\u2029': '\\\\u2029'\n};\n\nclass utils_DevalueError extends Error {\n\t/**\n\t * @param {string} message\n\t * @param {string[]} keys\n\t */\n\tconstructor(message, keys) {\n\t\tsuper(message);\n\t\tthis.name = 'DevalueError';\n\t\tthis.path = keys.join('');\n\t}\n}\n\n/** @param {any} thing */\nfunction utils_is_primitive(thing) {\n\treturn Object(thing) !== thing;\n}\n\nconst object_proto_names = Object.getOwnPropertyNames(Object.prototype)\n\t.sort()\n\t.join('\\0');\n\n/** @param {any} thing */\nfunction utils_is_plain_object(thing) {\n\tconst proto = Object.getPrototypeOf(thing);\n\n\treturn (\n\t\tproto === Object.prototype ||\n\t\tproto === null ||\n\t\tObject.getOwnPropertyNames(proto).sort().join('\\0') === object_proto_names\n\t);\n}\n\n/** @param {any} thing */\nfunction utils_get_type(thing) {\n\treturn Object.prototype.toString.call(thing).slice(8, -1);\n}\n\n/** @param {string} str */\nfunction utils_stringify_string(str) {\n\tlet result = '\"';\n\n\tfor (let i = 0; i < str.length; i += 1) {\n\t\tconst char = str.charAt(i);\n\t\tconst code = char.charCodeAt(0);\n\n\t\tif (char === '\"') {\n\t\t\tresult += '\\\\\"';\n\t\t} else if (char in utils_escaped) {\n\t\t\tresult += utils_escaped[char];\n\t\t} else if (code <= 0x001F) {\n\t\t\tresult += `\\\\u${code.toString(16).toUpperCase().padStart(4, \"0\")}`\n\t\t} else if (code >= 0xd800 && code <= 0xdfff) {\n\t\t\tconst next = str.charCodeAt(i + 1);\n\n\t\t\t// If this is the beginning of a [high, low] surrogate pair,\n\t\t\t// add the next two characters, otherwise escape\n\t\t\tif (code <= 0xdbff && next >= 0xdc00 && next <= 0xdfff) {\n\t\t\t\tresult += char + str[++i];\n\t\t\t} else {\n\t\t\t\tresult += `\\\\u${code.toString(16).toUpperCase()}`;\n\t\t\t}\n\t\t} else {\n\t\t\tresult += char;\n\t\t}\n\t}\n\n\tresult += '\"';\n\treturn result;\n}\n\n;// CONCATENATED MODULE: ./node_modules/devalue/src/uneval.js\n\n\nconst chars = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ_$';\nconst unsafe_chars = /[<>\\b\\f\\n\\r\\t\\0\\u2028\\u2029]/g;\nconst reserved =\n\t/^(?:do|if|in|for|int|let|new|try|var|byte|case|char|else|enum|goto|long|this|void|with|await|break|catch|class|const|final|float|short|super|throw|while|yield|delete|double|export|import|native|return|switch|throws|typeof|boolean|default|extends|finally|package|private|abstract|continue|debugger|function|volatile|interface|protected|transient|implements|instanceof|synchronized)$/;\n\n/**\n * Turn a value into the JavaScript that creates an equivalent value\n * @param {any} value\n * @param {(value: any) => string | void} [replacer]\n */\nfunction uneval(value, replacer) {\n\tconst counts = new Map();\n\n\t/** @type {string[]} */\n\tconst keys = [];\n\n\tconst custom = new Map();\n\n\t/** @param {any} thing */\n\tfunction walk(thing) {\n\t\tif (typeof thing === 'function') {\n\t\t\tthrow new DevalueError(`Cannot stringify a function`, keys);\n\t\t}\n\n\t\tif (!is_primitive(thing)) {\n\t\t\tif (counts.has(thing)) {\n\t\t\t\tcounts.set(thing, counts.get(thing) + 1);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tcounts.set(thing, 1);\n\n\t\t\tif (replacer) {\n\t\t\t\tconst str = replacer(thing);\n\n\t\t\t\tif (typeof str === 'string') {\n\t\t\t\t\tcustom.set(thing, str);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tconst type = get_type(thing);\n\n\t\t\tswitch (type) {\n\t\t\t\tcase 'Number':\n\t\t\t\tcase 'BigInt':\n\t\t\t\tcase 'String':\n\t\t\t\tcase 'Boolean':\n\t\t\t\tcase 'Date':\n\t\t\t\tcase 'RegExp':\n\t\t\t\t\treturn;\n\n\t\t\t\tcase 'Array':\n\t\t\t\t\t/** @type {any[]} */ (thing).forEach((value, i) => {\n\t\t\t\t\t\tkeys.push(`[${i}]`);\n\t\t\t\t\t\twalk(value);\n\t\t\t\t\t\tkeys.pop();\n\t\t\t\t\t});\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'Set':\n\t\t\t\t\tArray.from(thing).forEach(walk);\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'Map':\n\t\t\t\t\tfor (const [key, value] of thing) {\n\t\t\t\t\t\tkeys.push(\n\t\t\t\t\t\t\t`.get(${is_primitive(key) ? stringify_primitive(key) : '...'})`\n\t\t\t\t\t\t);\n\t\t\t\t\t\twalk(value);\n\t\t\t\t\t\tkeys.pop();\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault:\n\t\t\t\t\tif (!is_plain_object(thing)) {\n\t\t\t\t\t\tthrow new DevalueError(\n\t\t\t\t\t\t\t`Cannot stringify arbitrary non-POJOs`,\n\t\t\t\t\t\t\tkeys\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (Object.getOwnPropertySymbols(thing).length > 0) {\n\t\t\t\t\t\tthrow new DevalueError(\n\t\t\t\t\t\t\t`Cannot stringify POJOs with symbolic keys`,\n\t\t\t\t\t\t\tkeys\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\n\t\t\t\t\tfor (const key in thing) {\n\t\t\t\t\t\tkeys.push(`.${key}`);\n\t\t\t\t\t\twalk(thing[key]);\n\t\t\t\t\t\tkeys.pop();\n\t\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\twalk(value);\n\n\tconst names = new Map();\n\n\tArray.from(counts)\n\t\t.filter((entry) => entry[1] > 1)\n\t\t.sort((a, b) => b[1] - a[1])\n\t\t.forEach((entry, i) => {\n\t\t\tnames.set(entry[0], get_name(i));\n\t\t});\n\n\t/**\n\t * @param {any} thing\n\t * @returns {string}\n\t */\n\tfunction stringify(thing) {\n\t\tif (names.has(thing)) {\n\t\t\treturn names.get(thing);\n\t\t}\n\n\t\tif (is_primitive(thing)) {\n\t\t\treturn stringify_primitive(thing);\n\t\t}\n\n\t\tif (custom.has(thing)) {\n\t\t\treturn custom.get(thing);\n\t\t}\n\n\t\tconst type = get_type(thing);\n\n\t\tswitch (type) {\n\t\t\tcase 'Number':\n\t\t\tcase 'String':\n\t\t\tcase 'Boolean':\n\t\t\t\treturn `Object(${stringify(thing.valueOf())})`;\n\n\t\t\tcase 'RegExp':\n\t\t\t\treturn `new RegExp(${stringify_string(thing.source)}, \"${\n\t\t\t\t\tthing.flags\n\t\t\t\t}\")`;\n\n\t\t\tcase 'Date':\n\t\t\t\treturn `new Date(${thing.getTime()})`;\n\n\t\t\tcase 'Array':\n\t\t\t\tconst members = /** @type {any[]} */ (thing).map((v, i) =>\n\t\t\t\t\ti in thing ? stringify(v) : ''\n\t\t\t\t);\n\t\t\t\tconst tail = thing.length === 0 || thing.length - 1 in thing ? '' : ',';\n\t\t\t\treturn `[${members.join(',')}${tail}]`;\n\n\t\t\tcase 'Set':\n\t\t\tcase 'Map':\n\t\t\t\treturn `new ${type}([${Array.from(thing).map(stringify).join(',')}])`;\n\n\t\t\tdefault:\n\t\t\t\tconst obj = `{${Object.keys(thing)\n\t\t\t\t\t.map((key) => `${safe_key(key)}:${stringify(thing[key])}`)\n\t\t\t\t\t.join(',')}}`;\n\t\t\t\tconst proto = Object.getPrototypeOf(thing);\n\t\t\t\tif (proto === null) {\n\t\t\t\t\treturn Object.keys(thing).length > 0\n\t\t\t\t\t\t? `Object.assign(Object.create(null),${obj})`\n\t\t\t\t\t\t: `Object.create(null)`;\n\t\t\t\t}\n\n\t\t\t\treturn obj;\n\t\t}\n\t}\n\n\tconst str = stringify(value);\n\n\tif (names.size) {\n\t\t/** @type {string[]} */\n\t\tconst params = [];\n\n\t\t/** @type {string[]} */\n\t\tconst statements = [];\n\n\t\t/** @type {string[]} */\n\t\tconst values = [];\n\n\t\tnames.forEach((name, thing) => {\n\t\t\tparams.push(name);\n\n\t\t\tif (custom.has(thing)) {\n\t\t\t\tvalues.push(/** @type {string} */ (custom.get(thing)));\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (is_primitive(thing)) {\n\t\t\t\tvalues.push(stringify_primitive(thing));\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tconst type = get_type(thing);\n\n\t\t\tswitch (type) {\n\t\t\t\tcase 'Number':\n\t\t\t\tcase 'String':\n\t\t\t\tcase 'Boolean':\n\t\t\t\t\tvalues.push(`Object(${stringify(thing.valueOf())})`);\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'RegExp':\n\t\t\t\t\tvalues.push(thing.toString());\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'Date':\n\t\t\t\t\tvalues.push(`new Date(${thing.getTime()})`);\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'Array':\n\t\t\t\t\tvalues.push(`Array(${thing.length})`);\n\t\t\t\t\t/** @type {any[]} */ (thing).forEach((v, i) => {\n\t\t\t\t\t\tstatements.push(`${name}[${i}]=${stringify(v)}`);\n\t\t\t\t\t});\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'Set':\n\t\t\t\t\tvalues.push(`new Set`);\n\t\t\t\t\tstatements.push(\n\t\t\t\t\t\t`${name}.${Array.from(thing)\n\t\t\t\t\t\t\t.map((v) => `add(${stringify(v)})`)\n\t\t\t\t\t\t\t.join('.')}`\n\t\t\t\t\t);\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'Map':\n\t\t\t\t\tvalues.push(`new Map`);\n\t\t\t\t\tstatements.push(\n\t\t\t\t\t\t`${name}.${Array.from(thing)\n\t\t\t\t\t\t\t.map(([k, v]) => `set(${stringify(k)}, ${stringify(v)})`)\n\t\t\t\t\t\t\t.join('.')}`\n\t\t\t\t\t);\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault:\n\t\t\t\t\tvalues.push(\n\t\t\t\t\t\tObject.getPrototypeOf(thing) === null ? 'Object.create(null)' : '{}'\n\t\t\t\t\t);\n\t\t\t\t\tObject.keys(thing).forEach((key) => {\n\t\t\t\t\t\tstatements.push(\n\t\t\t\t\t\t\t`${name}${safe_prop(key)}=${stringify(thing[key])}`\n\t\t\t\t\t\t);\n\t\t\t\t\t});\n\t\t\t}\n\t\t});\n\n\t\tstatements.push(`return ${str}`);\n\n\t\treturn `(function(${params.join(',')}){${statements.join(\n\t\t\t';'\n\t\t)}}(${values.join(',')}))`;\n\t} else {\n\t\treturn str;\n\t}\n}\n\n/** @param {number} num */\nfunction get_name(num) {\n\tlet name = '';\n\n\tdo {\n\t\tname = chars[num % chars.length] + name;\n\t\tnum = ~~(num / chars.length) - 1;\n\t} while (num >= 0);\n\n\treturn reserved.test(name) ? `${name}0` : name;\n}\n\n/** @param {string} c */\nfunction escape_unsafe_char(c) {\n\treturn escaped[c] || c;\n}\n\n/** @param {string} str */\nfunction escape_unsafe_chars(str) {\n\treturn str.replace(unsafe_chars, escape_unsafe_char);\n}\n\n/** @param {string} key */\nfunction safe_key(key) {\n\treturn /^[_$a-zA-Z][_$a-zA-Z0-9]*$/.test(key)\n\t\t? key\n\t\t: escape_unsafe_chars(JSON.stringify(key));\n}\n\n/** @param {string} key */\nfunction safe_prop(key) {\n\treturn /^[_$a-zA-Z][_$a-zA-Z0-9]*$/.test(key)\n\t\t? `.${key}`\n\t\t: `[${escape_unsafe_chars(JSON.stringify(key))}]`;\n}\n\n/** @param {any} thing */\nfunction stringify_primitive(thing) {\n\tif (typeof thing === 'string') return stringify_string(thing);\n\tif (thing === void 0) return 'void 0';\n\tif (thing === 0 && 1 / thing < 0) return '-0';\n\tconst str = String(thing);\n\tif (typeof thing === 'number') return str.replace(/^(-)?0\\./, '$1.');\n\tif (typeof thing === 'bigint') return thing + 'n';\n\treturn str;\n}\n\n;// CONCATENATED MODULE: ./node_modules/devalue/src/constants.js\nconst UNDEFINED = -1;\nconst HOLE = -2;\nconst NAN = -3;\nconst POSITIVE_INFINITY = -4;\nconst NEGATIVE_INFINITY = -5;\nconst NEGATIVE_ZERO = -6;\n\n;// CONCATENATED MODULE: ./node_modules/devalue/src/parse.js\n\n\n/**\n * Revive a value serialized with `devalue.stringify`\n * @param {string} serialized\n * @param {Record<string, (value: any) => any>} [revivers]\n */\nfunction parse(serialized, revivers) {\n\treturn unflatten(JSON.parse(serialized), revivers);\n}\n\n/**\n * Revive a value flattened with `devalue.stringify`\n * @param {number | any[]} parsed\n * @param {Record<string, (value: any) => any>} [revivers]\n */\nfunction unflatten(parsed, revivers) {\n\tif (typeof parsed === 'number') return hydrate(parsed, true);\n\n\tif (!Array.isArray(parsed) || parsed.length === 0) {\n\t\tthrow new Error('Invalid input');\n\t}\n\n\tconst values = /** @type {any[]} */ (parsed);\n\n\tconst hydrated = Array(values.length);\n\n\t/**\n\t * @param {number} index\n\t * @returns {any}\n\t */\n\tfunction hydrate(index, standalone = false) {\n\t\tif (index === UNDEFINED) return undefined;\n\t\tif (index === NAN) return NaN;\n\t\tif (index === POSITIVE_INFINITY) return Infinity;\n\t\tif (index === NEGATIVE_INFINITY) return -Infinity;\n\t\tif (index === NEGATIVE_ZERO) return -0;\n\n\t\tif (standalone) throw new Error(`Invalid input`);\n\n\t\tif (index in hydrated) return hydrated[index];\n\n\t\tconst value = values[index];\n\n\t\tif (!value || typeof value !== 'object') {\n\t\t\thydrated[index] = value;\n\t\t} else if (Array.isArray(value)) {\n\t\t\tif (typeof value[0] === 'string') {\n\t\t\t\tconst type = value[0];\n\n\t\t\t\tconst reviver = revivers?.[type];\n\t\t\t\tif (reviver) {\n\t\t\t\t\treturn (hydrated[index] = reviver(hydrate(value[1])));\n\t\t\t\t}\n\n\t\t\t\tswitch (type) {\n\t\t\t\t\tcase 'Date':\n\t\t\t\t\t\thydrated[index] = new Date(value[1]);\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'Set':\n\t\t\t\t\t\tconst set = new Set();\n\t\t\t\t\t\thydrated[index] = set;\n\t\t\t\t\t\tfor (let i = 1; i < value.length; i += 1) {\n\t\t\t\t\t\t\tset.add(hydrate(value[i]));\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'Map':\n\t\t\t\t\t\tconst map = new Map();\n\t\t\t\t\t\thydrated[index] = map;\n\t\t\t\t\t\tfor (let i = 1; i < value.length; i += 2) {\n\t\t\t\t\t\t\tmap.set(hydrate(value[i]), hydrate(value[i + 1]));\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'RegExp':\n\t\t\t\t\t\thydrated[index] = new RegExp(value[1], value[2]);\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'Object':\n\t\t\t\t\t\thydrated[index] = Object(value[1]);\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'BigInt':\n\t\t\t\t\t\thydrated[index] = BigInt(value[1]);\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'null':\n\t\t\t\t\t\tconst obj = Object.create(null);\n\t\t\t\t\t\thydrated[index] = obj;\n\t\t\t\t\t\tfor (let i = 1; i < value.length; i += 2) {\n\t\t\t\t\t\t\tobj[value[i]] = hydrate(value[i + 1]);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tthrow new Error(`Unknown type ${type}`);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tconst array = new Array(value.length);\n\t\t\t\thydrated[index] = array;\n\n\t\t\t\tfor (let i = 0; i < value.length; i += 1) {\n\t\t\t\t\tconst n = value[i];\n\t\t\t\t\tif (n === HOLE) continue;\n\n\t\t\t\t\tarray[i] = hydrate(n);\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\t/** @type {Record<string, any>} */\n\t\t\tconst object = {};\n\t\t\thydrated[index] = object;\n\n\t\t\tfor (const key in value) {\n\t\t\t\tconst n = value[key];\n\t\t\t\tobject[key] = hydrate(n);\n\t\t\t}\n\t\t}\n\n\t\treturn hydrated[index];\n\t}\n\n\treturn hydrate(0);\n}\n\n;// CONCATENATED MODULE: ./node_modules/devalue/src/stringify.js\n\n\n\n/**\n * Turn a value into a JSON string that can be parsed with `devalue.parse`\n * @param {any} value\n * @param {Record<string, (value: any) => any>} [reducers]\n */\nfunction stringify(value, reducers) {\n\t/** @type {any[]} */\n\tconst stringified = [];\n\n\t/** @type {Map<any, number>} */\n\tconst indexes = new Map();\n\n\t/** @type {Array<{ key: string, fn: (value: any) => any }>} */\n\tconst custom = [];\n\tfor (const key in reducers) {\n\t\tcustom.push({ key, fn: reducers[key] });\n\t}\n\n\t/** @type {string[]} */\n\tconst keys = [];\n\n\tlet p = 0;\n\n\t/** @param {any} thing */\n\tfunction flatten(thing) {\n\t\tif (typeof thing === 'function') {\n\t\t\tthrow new utils_DevalueError(`Cannot stringify a function`, keys);\n\t\t}\n\n\t\tif (indexes.has(thing)) return indexes.get(thing);\n\n\t\tif (thing === undefined) return UNDEFINED;\n\t\tif (Number.isNaN(thing)) return NAN;\n\t\tif (thing === Infinity) return POSITIVE_INFINITY;\n\t\tif (thing === -Infinity) return NEGATIVE_INFINITY;\n\t\tif (thing === 0 && 1 / thing < 0) return NEGATIVE_ZERO;\n\n\t\tconst index = p++;\n\t\tindexes.set(thing, index);\n\n\t\tfor (const { key, fn } of custom) {\n\t\t\tconst value = fn(thing);\n\t\t\tif (value) {\n\t\t\t\tstringified[index] = `[\"${key}\",${flatten(value)}]`;\n\t\t\t\treturn index;\n\t\t\t}\n\t\t}\n\n\t\tlet str = '';\n\n\t\tif (utils_is_primitive(thing)) {\n\t\t\tstr = stringify_stringify_primitive(thing);\n\t\t} else {\n\t\t\tconst type = utils_get_type(thing);\n\n\t\t\tswitch (type) {\n\t\t\t\tcase 'Number':\n\t\t\t\tcase 'String':\n\t\t\t\tcase 'Boolean':\n\t\t\t\t\tstr = `[\"Object\",${stringify_stringify_primitive(thing)}]`;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'BigInt':\n\t\t\t\t\tstr = `[\"BigInt\",${thing}]`;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'Date':\n\t\t\t\t\tstr = `[\"Date\",\"${thing.toISOString()}\"]`;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'RegExp':\n\t\t\t\t\tconst { source, flags } = thing;\n\t\t\t\t\tstr = flags\n\t\t\t\t\t\t? `[\"RegExp\",${utils_stringify_string(source)},\"${flags}\"]`\n\t\t\t\t\t\t: `[\"RegExp\",${utils_stringify_string(source)}]`;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'Array':\n\t\t\t\t\tstr = '[';\n\n\t\t\t\t\tfor (let i = 0; i < thing.length; i += 1) {\n\t\t\t\t\t\tif (i > 0) str += ',';\n\n\t\t\t\t\t\tif (i in thing) {\n\t\t\t\t\t\t\tkeys.push(`[${i}]`);\n\t\t\t\t\t\t\tstr += flatten(thing[i]);\n\t\t\t\t\t\t\tkeys.pop();\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tstr += HOLE;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tstr += ']';\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'Set':\n\t\t\t\t\tstr = '[\"Set\"';\n\n\t\t\t\t\tfor (const value of thing) {\n\t\t\t\t\t\tstr += `,${flatten(value)}`;\n\t\t\t\t\t}\n\n\t\t\t\t\tstr += ']';\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'Map':\n\t\t\t\t\tstr = '[\"Map\"';\n\n\t\t\t\t\tfor (const [key, value] of thing) {\n\t\t\t\t\t\tkeys.push(\n\t\t\t\t\t\t\t`.get(${utils_is_primitive(key) ? stringify_stringify_primitive(key) : '...'})`\n\t\t\t\t\t\t);\n\t\t\t\t\t\tstr += `,${flatten(key)},${flatten(value)}`;\n\t\t\t\t\t}\n\n\t\t\t\t\tstr += ']';\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault:\n\t\t\t\t\tif (!utils_is_plain_object(thing)) {\n\t\t\t\t\t\tthrow new utils_DevalueError(\n\t\t\t\t\t\t\t`Cannot stringify arbitrary non-POJOs`,\n\t\t\t\t\t\t\tkeys\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (Object.getOwnPropertySymbols(thing).length > 0) {\n\t\t\t\t\t\tthrow new utils_DevalueError(\n\t\t\t\t\t\t\t`Cannot stringify POJOs with symbolic keys`,\n\t\t\t\t\t\t\tkeys\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (Object.getPrototypeOf(thing) === null) {\n\t\t\t\t\t\tstr = '[\"null\"';\n\t\t\t\t\t\tfor (const key in thing) {\n\t\t\t\t\t\t\tkeys.push(`.${key}`);\n\t\t\t\t\t\t\tstr += `,${utils_stringify_string(key)},${flatten(thing[key])}`;\n\t\t\t\t\t\t\tkeys.pop();\n\t\t\t\t\t\t}\n\t\t\t\t\t\tstr += ']';\n\t\t\t\t\t} else {\n\t\t\t\t\t\tstr = '{';\n\t\t\t\t\t\tlet started = false;\n\t\t\t\t\t\tfor (const key in thing) {\n\t\t\t\t\t\t\tif (started) str += ',';\n\t\t\t\t\t\t\tstarted = true;\n\t\t\t\t\t\t\tkeys.push(`.${key}`);\n\t\t\t\t\t\t\tstr += `${utils_stringify_string(key)}:${flatten(thing[key])}`;\n\t\t\t\t\t\t\tkeys.pop();\n\t\t\t\t\t\t}\n\t\t\t\t\t\tstr += '}';\n\t\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tstringified[index] = str;\n\t\treturn index;\n\t}\n\n\tconst index = flatten(value);\n\n\t// special case value is represented as a negative index\n\tif (index < 0) return `${index}`;\n\n\treturn `[${stringified.join(',')}]`;\n}\n\n/**\n * @param {any} thing\n * @returns {string}\n */\nfunction stringify_stringify_primitive(thing) {\n\tconst type = typeof thing;\n\tif (type === 'string') return utils_stringify_string(thing);\n\tif (thing instanceof String) return utils_stringify_string(thing.toString());\n\tif (thing === void 0) return UNDEFINED.toString();\n\tif (thing === 0 && 1 / thing < 0) return NEGATIVE_ZERO.toString();\n\tif (type === 'bigint') return `[\"BigInt\",\"${thing}\"]`;\n\treturn String(thing);\n}\n\n;// CONCATENATED MODULE: ./node_modules/devalue/index.js\n\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QSxpQkFBaUIsYUFBYSxHQUFHLGVBQWU7QUFDaEQ7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLFVBQVUscUJBQWU7QUFDekIsZ0JBQWdCLGtCQUFZO0FBQzVCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZ0JBQWdCLGtCQUFZO0FBQzVCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixJQUFJO0FBQ3pCLGtCQUFrQixzQkFBZ0IsTUFBTSxHQUFHLG9CQUFvQjtBQUMvRDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLElBQUk7QUFDekIsaUJBQWlCLHNCQUFnQixNQUFNLEdBQUcsb0JBQW9CO0FBQzlEO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLDBCQUEwQixNQUFNOztBQUVoQyxZQUFZLHNCQUFzQjtBQUNsQzs7QUFFQTtBQUNBLFdBQVcsS0FBSztBQUNoQixhQUFhO0FBQ2I7QUFDQSxTQUFTLDZCQUFtQjtBQUM1QjtBQUNBLCtCQUErQixzQkFBZ0I7QUFDL0MscUNBQXFDLHNCQUFnQjtBQUNyRCw4QkFBOEIsa0JBQWtCO0FBQ2hELDBDQUEwQyxzQkFBc0I7QUFDaEUsNkNBQTZDLE1BQU07QUFDbkQ7QUFDQTs7O0FDck15QztBQUNTO0FBQ0giLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly92dWUzLXdlYnBhY2s1Ly4vbm9kZV9tb2R1bGVzL2RldmFsdWUvc3JjL3V0aWxzLmpzPzU3ODUiLCJ3ZWJwYWNrOi8vdnVlMy13ZWJwYWNrNS8uL25vZGVfbW9kdWxlcy9kZXZhbHVlL3NyYy91bmV2YWwuanM/OTkxNiIsIndlYnBhY2s6Ly92dWUzLXdlYnBhY2s1Ly4vbm9kZV9tb2R1bGVzL2RldmFsdWUvc3JjL2NvbnN0YW50cy5qcz9lOTUwIiwid2VicGFjazovL3Z1ZTMtd2VicGFjazUvLi9ub2RlX21vZHVsZXMvZGV2YWx1ZS9zcmMvcGFyc2UuanM/ZGRlYSIsIndlYnBhY2s6Ly92dWUzLXdlYnBhY2s1Ly4vbm9kZV9tb2R1bGVzL2RldmFsdWUvc3JjL3N0cmluZ2lmeS5qcz84MjJlIiwid2VicGFjazovL3Z1ZTMtd2VicGFjazUvLi9ub2RlX21vZHVsZXMvZGV2YWx1ZS9pbmRleC5qcz80YThhIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKiBAdHlwZSB7UmVjb3JkPHN0cmluZywgc3RyaW5nPn0gKi9cbmV4cG9ydCBjb25zdCBlc2NhcGVkID0ge1xuXHQnPCc6ICdcXFxcdTAwM0MnLFxuXHQnPic6ICdcXFxcdTAwM0UnLFxuXHQnLyc6ICdcXFxcdTAwMkYnLFxuXHQnXFxcXCc6ICdcXFxcXFxcXCcsXG5cdCdcXGInOiAnXFxcXGInLFxuXHQnXFxmJzogJ1xcXFxmJyxcblx0J1xcbic6ICdcXFxcbicsXG5cdCdcXHInOiAnXFxcXHInLFxuXHQnXFx0JzogJ1xcXFx0Jyxcblx0J1xcMCc6ICdcXFxcdTAwMDAnLFxuXHQnXFx1MjAyOCc6ICdcXFxcdTIwMjgnLFxuXHQnXFx1MjAyOSc6ICdcXFxcdTIwMjknXG59O1xuXG5leHBvcnQgY2xhc3MgRGV2YWx1ZUVycm9yIGV4dGVuZHMgRXJyb3Ige1xuXHQvKipcblx0ICogQHBhcmFtIHtzdHJpbmd9IG1lc3NhZ2Vcblx0ICogQHBhcmFtIHtzdHJpbmdbXX0ga2V5c1xuXHQgKi9cblx0Y29uc3RydWN0b3IobWVzc2FnZSwga2V5cykge1xuXHRcdHN1cGVyKG1lc3NhZ2UpO1xuXHRcdHRoaXMubmFtZSA9ICdEZXZhbHVlRXJyb3InO1xuXHRcdHRoaXMucGF0aCA9IGtleXMuam9pbignJyk7XG5cdH1cbn1cblxuLyoqIEBwYXJhbSB7YW55fSB0aGluZyAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzX3ByaW1pdGl2ZSh0aGluZykge1xuXHRyZXR1cm4gT2JqZWN0KHRoaW5nKSAhPT0gdGhpbmc7XG59XG5cbmNvbnN0IG9iamVjdF9wcm90b19uYW1lcyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKE9iamVjdC5wcm90b3R5cGUpXG5cdC5zb3J0KClcblx0LmpvaW4oJ1xcMCcpO1xuXG4vKiogQHBhcmFtIHthbnl9IHRoaW5nICovXG5leHBvcnQgZnVuY3Rpb24gaXNfcGxhaW5fb2JqZWN0KHRoaW5nKSB7XG5cdGNvbnN0IHByb3RvID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKHRoaW5nKTtcblxuXHRyZXR1cm4gKFxuXHRcdHByb3RvID09PSBPYmplY3QucHJvdG90eXBlIHx8XG5cdFx0cHJvdG8gPT09IG51bGwgfHxcblx0XHRPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhwcm90bykuc29ydCgpLmpvaW4oJ1xcMCcpID09PSBvYmplY3RfcHJvdG9fbmFtZXNcblx0KTtcbn1cblxuLyoqIEBwYXJhbSB7YW55fSB0aGluZyAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldF90eXBlKHRoaW5nKSB7XG5cdHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodGhpbmcpLnNsaWNlKDgsIC0xKTtcbn1cblxuLyoqIEBwYXJhbSB7c3RyaW5nfSBzdHIgKi9cbmV4cG9ydCBmdW5jdGlvbiBzdHJpbmdpZnlfc3RyaW5nKHN0cikge1xuXHRsZXQgcmVzdWx0ID0gJ1wiJztcblxuXHRmb3IgKGxldCBpID0gMDsgaSA8IHN0ci5sZW5ndGg7IGkgKz0gMSkge1xuXHRcdGNvbnN0IGNoYXIgPSBzdHIuY2hhckF0KGkpO1xuXHRcdGNvbnN0IGNvZGUgPSBjaGFyLmNoYXJDb2RlQXQoMCk7XG5cblx0XHRpZiAoY2hhciA9PT0gJ1wiJykge1xuXHRcdFx0cmVzdWx0ICs9ICdcXFxcXCInO1xuXHRcdH0gZWxzZSBpZiAoY2hhciBpbiBlc2NhcGVkKSB7XG5cdFx0XHRyZXN1bHQgKz0gZXNjYXBlZFtjaGFyXTtcblx0XHR9IGVsc2UgaWYgKGNvZGUgPD0gMHgwMDFGKSB7XG5cdFx0XHRyZXN1bHQgKz0gYFxcXFx1JHtjb2RlLnRvU3RyaW5nKDE2KS50b1VwcGVyQ2FzZSgpLnBhZFN0YXJ0KDQsIFwiMFwiKX1gXG5cdFx0fSBlbHNlIGlmIChjb2RlID49IDB4ZDgwMCAmJiBjb2RlIDw9IDB4ZGZmZikge1xuXHRcdFx0Y29uc3QgbmV4dCA9IHN0ci5jaGFyQ29kZUF0KGkgKyAxKTtcblxuXHRcdFx0Ly8gSWYgdGhpcyBpcyB0aGUgYmVnaW5uaW5nIG9mIGEgW2hpZ2gsIGxvd10gc3Vycm9nYXRlIHBhaXIsXG5cdFx0XHQvLyBhZGQgdGhlIG5leHQgdHdvIGNoYXJhY3RlcnMsIG90aGVyd2lzZSBlc2NhcGVcblx0XHRcdGlmIChjb2RlIDw9IDB4ZGJmZiAmJiBuZXh0ID49IDB4ZGMwMCAmJiBuZXh0IDw9IDB4ZGZmZikge1xuXHRcdFx0XHRyZXN1bHQgKz0gY2hhciArIHN0clsrK2ldO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0cmVzdWx0ICs9IGBcXFxcdSR7Y29kZS50b1N0cmluZygxNikudG9VcHBlckNhc2UoKX1gO1xuXHRcdFx0fVxuXHRcdH0gZWxzZSB7XG5cdFx0XHRyZXN1bHQgKz0gY2hhcjtcblx0XHR9XG5cdH1cblxuXHRyZXN1bHQgKz0gJ1wiJztcblx0cmV0dXJuIHJlc3VsdDtcbn1cbiIsImltcG9ydCB7XG5cdERldmFsdWVFcnJvcixcblx0ZXNjYXBlZCxcblx0Z2V0X3R5cGUsXG5cdGlzX3BsYWluX29iamVjdCxcblx0aXNfcHJpbWl0aXZlLFxuXHRzdHJpbmdpZnlfc3RyaW5nXG59IGZyb20gJy4vdXRpbHMuanMnO1xuXG5jb25zdCBjaGFycyA9ICdhYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ekFCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaXyQnO1xuY29uc3QgdW5zYWZlX2NoYXJzID0gL1s8PlxcYlxcZlxcblxcclxcdFxcMFxcdTIwMjhcXHUyMDI5XS9nO1xuY29uc3QgcmVzZXJ2ZWQgPVxuXHQvXig/OmRvfGlmfGlufGZvcnxpbnR8bGV0fG5ld3x0cnl8dmFyfGJ5dGV8Y2FzZXxjaGFyfGVsc2V8ZW51bXxnb3RvfGxvbmd8dGhpc3x2b2lkfHdpdGh8YXdhaXR8YnJlYWt8Y2F0Y2h8Y2xhc3N8Y29uc3R8ZmluYWx8ZmxvYXR8c2hvcnR8c3VwZXJ8dGhyb3d8d2hpbGV8eWllbGR8ZGVsZXRlfGRvdWJsZXxleHBvcnR8aW1wb3J0fG5hdGl2ZXxyZXR1cm58c3dpdGNofHRocm93c3x0eXBlb2Z8Ym9vbGVhbnxkZWZhdWx0fGV4dGVuZHN8ZmluYWxseXxwYWNrYWdlfHByaXZhdGV8YWJzdHJhY3R8Y29udGludWV8ZGVidWdnZXJ8ZnVuY3Rpb258dm9sYXRpbGV8aW50ZXJmYWNlfHByb3RlY3RlZHx0cmFuc2llbnR8aW1wbGVtZW50c3xpbnN0YW5jZW9mfHN5bmNocm9uaXplZCkkLztcblxuLyoqXG4gKiBUdXJuIGEgdmFsdWUgaW50byB0aGUgSmF2YVNjcmlwdCB0aGF0IGNyZWF0ZXMgYW4gZXF1aXZhbGVudCB2YWx1ZVxuICogQHBhcmFtIHthbnl9IHZhbHVlXG4gKiBAcGFyYW0geyh2YWx1ZTogYW55KSA9PiBzdHJpbmcgfCB2b2lkfSBbcmVwbGFjZXJdXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1bmV2YWwodmFsdWUsIHJlcGxhY2VyKSB7XG5cdGNvbnN0IGNvdW50cyA9IG5ldyBNYXAoKTtcblxuXHQvKiogQHR5cGUge3N0cmluZ1tdfSAqL1xuXHRjb25zdCBrZXlzID0gW107XG5cblx0Y29uc3QgY3VzdG9tID0gbmV3IE1hcCgpO1xuXG5cdC8qKiBAcGFyYW0ge2FueX0gdGhpbmcgKi9cblx0ZnVuY3Rpb24gd2Fsayh0aGluZykge1xuXHRcdGlmICh0eXBlb2YgdGhpbmcgPT09ICdmdW5jdGlvbicpIHtcblx0XHRcdHRocm93IG5ldyBEZXZhbHVlRXJyb3IoYENhbm5vdCBzdHJpbmdpZnkgYSBmdW5jdGlvbmAsIGtleXMpO1xuXHRcdH1cblxuXHRcdGlmICghaXNfcHJpbWl0aXZlKHRoaW5nKSkge1xuXHRcdFx0aWYgKGNvdW50cy5oYXModGhpbmcpKSB7XG5cdFx0XHRcdGNvdW50cy5zZXQodGhpbmcsIGNvdW50cy5nZXQodGhpbmcpICsgMSk7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblxuXHRcdFx0Y291bnRzLnNldCh0aGluZywgMSk7XG5cblx0XHRcdGlmIChyZXBsYWNlcikge1xuXHRcdFx0XHRjb25zdCBzdHIgPSByZXBsYWNlcih0aGluZyk7XG5cblx0XHRcdFx0aWYgKHR5cGVvZiBzdHIgPT09ICdzdHJpbmcnKSB7XG5cdFx0XHRcdFx0Y3VzdG9tLnNldCh0aGluZywgc3RyKTtcblx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Y29uc3QgdHlwZSA9IGdldF90eXBlKHRoaW5nKTtcblxuXHRcdFx0c3dpdGNoICh0eXBlKSB7XG5cdFx0XHRcdGNhc2UgJ051bWJlcic6XG5cdFx0XHRcdGNhc2UgJ0JpZ0ludCc6XG5cdFx0XHRcdGNhc2UgJ1N0cmluZyc6XG5cdFx0XHRcdGNhc2UgJ0Jvb2xlYW4nOlxuXHRcdFx0XHRjYXNlICdEYXRlJzpcblx0XHRcdFx0Y2FzZSAnUmVnRXhwJzpcblx0XHRcdFx0XHRyZXR1cm47XG5cblx0XHRcdFx0Y2FzZSAnQXJyYXknOlxuXHRcdFx0XHRcdC8qKiBAdHlwZSB7YW55W119ICovICh0aGluZykuZm9yRWFjaCgodmFsdWUsIGkpID0+IHtcblx0XHRcdFx0XHRcdGtleXMucHVzaChgWyR7aX1dYCk7XG5cdFx0XHRcdFx0XHR3YWxrKHZhbHVlKTtcblx0XHRcdFx0XHRcdGtleXMucG9wKCk7XG5cdFx0XHRcdFx0fSk7XG5cdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0Y2FzZSAnU2V0Jzpcblx0XHRcdFx0XHRBcnJheS5mcm9tKHRoaW5nKS5mb3JFYWNoKHdhbGspO1xuXHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdGNhc2UgJ01hcCc6XG5cdFx0XHRcdFx0Zm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgdGhpbmcpIHtcblx0XHRcdFx0XHRcdGtleXMucHVzaChcblx0XHRcdFx0XHRcdFx0YC5nZXQoJHtpc19wcmltaXRpdmUoa2V5KSA/IHN0cmluZ2lmeV9wcmltaXRpdmUoa2V5KSA6ICcuLi4nfSlgXG5cdFx0XHRcdFx0XHQpO1xuXHRcdFx0XHRcdFx0d2Fsayh2YWx1ZSk7XG5cdFx0XHRcdFx0XHRrZXlzLnBvcCgpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRkZWZhdWx0OlxuXHRcdFx0XHRcdGlmICghaXNfcGxhaW5fb2JqZWN0KHRoaW5nKSkge1xuXHRcdFx0XHRcdFx0dGhyb3cgbmV3IERldmFsdWVFcnJvcihcblx0XHRcdFx0XHRcdFx0YENhbm5vdCBzdHJpbmdpZnkgYXJiaXRyYXJ5IG5vbi1QT0pPc2AsXG5cdFx0XHRcdFx0XHRcdGtleXNcblx0XHRcdFx0XHRcdCk7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0aWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHModGhpbmcpLmxlbmd0aCA+IDApIHtcblx0XHRcdFx0XHRcdHRocm93IG5ldyBEZXZhbHVlRXJyb3IoXG5cdFx0XHRcdFx0XHRcdGBDYW5ub3Qgc3RyaW5naWZ5IFBPSk9zIHdpdGggc3ltYm9saWMga2V5c2AsXG5cdFx0XHRcdFx0XHRcdGtleXNcblx0XHRcdFx0XHRcdCk7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Zm9yIChjb25zdCBrZXkgaW4gdGhpbmcpIHtcblx0XHRcdFx0XHRcdGtleXMucHVzaChgLiR7a2V5fWApO1xuXHRcdFx0XHRcdFx0d2Fsayh0aGluZ1trZXldKTtcblx0XHRcdFx0XHRcdGtleXMucG9wKCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdHdhbGsodmFsdWUpO1xuXG5cdGNvbnN0IG5hbWVzID0gbmV3IE1hcCgpO1xuXG5cdEFycmF5LmZyb20oY291bnRzKVxuXHRcdC5maWx0ZXIoKGVudHJ5KSA9PiBlbnRyeVsxXSA+IDEpXG5cdFx0LnNvcnQoKGEsIGIpID0+IGJbMV0gLSBhWzFdKVxuXHRcdC5mb3JFYWNoKChlbnRyeSwgaSkgPT4ge1xuXHRcdFx0bmFtZXMuc2V0KGVudHJ5WzBdLCBnZXRfbmFtZShpKSk7XG5cdFx0fSk7XG5cblx0LyoqXG5cdCAqIEBwYXJhbSB7YW55fSB0aGluZ1xuXHQgKiBAcmV0dXJucyB7c3RyaW5nfVxuXHQgKi9cblx0ZnVuY3Rpb24gc3RyaW5naWZ5KHRoaW5nKSB7XG5cdFx0aWYgKG5hbWVzLmhhcyh0aGluZykpIHtcblx0XHRcdHJldHVybiBuYW1lcy5nZXQodGhpbmcpO1xuXHRcdH1cblxuXHRcdGlmIChpc19wcmltaXRpdmUodGhpbmcpKSB7XG5cdFx0XHRyZXR1cm4gc3RyaW5naWZ5X3ByaW1pdGl2ZSh0aGluZyk7XG5cdFx0fVxuXG5cdFx0aWYgKGN1c3RvbS5oYXModGhpbmcpKSB7XG5cdFx0XHRyZXR1cm4gY3VzdG9tLmdldCh0aGluZyk7XG5cdFx0fVxuXG5cdFx0Y29uc3QgdHlwZSA9IGdldF90eXBlKHRoaW5nKTtcblxuXHRcdHN3aXRjaCAodHlwZSkge1xuXHRcdFx0Y2FzZSAnTnVtYmVyJzpcblx0XHRcdGNhc2UgJ1N0cmluZyc6XG5cdFx0XHRjYXNlICdCb29sZWFuJzpcblx0XHRcdFx0cmV0dXJuIGBPYmplY3QoJHtzdHJpbmdpZnkodGhpbmcudmFsdWVPZigpKX0pYDtcblxuXHRcdFx0Y2FzZSAnUmVnRXhwJzpcblx0XHRcdFx0cmV0dXJuIGBuZXcgUmVnRXhwKCR7c3RyaW5naWZ5X3N0cmluZyh0aGluZy5zb3VyY2UpfSwgXCIke1xuXHRcdFx0XHRcdHRoaW5nLmZsYWdzXG5cdFx0XHRcdH1cIilgO1xuXG5cdFx0XHRjYXNlICdEYXRlJzpcblx0XHRcdFx0cmV0dXJuIGBuZXcgRGF0ZSgke3RoaW5nLmdldFRpbWUoKX0pYDtcblxuXHRcdFx0Y2FzZSAnQXJyYXknOlxuXHRcdFx0XHRjb25zdCBtZW1iZXJzID0gLyoqIEB0eXBlIHthbnlbXX0gKi8gKHRoaW5nKS5tYXAoKHYsIGkpID0+XG5cdFx0XHRcdFx0aSBpbiB0aGluZyA/IHN0cmluZ2lmeSh2KSA6ICcnXG5cdFx0XHRcdCk7XG5cdFx0XHRcdGNvbnN0IHRhaWwgPSB0aGluZy5sZW5ndGggPT09IDAgfHwgdGhpbmcubGVuZ3RoIC0gMSBpbiB0aGluZyA/ICcnIDogJywnO1xuXHRcdFx0XHRyZXR1cm4gYFske21lbWJlcnMuam9pbignLCcpfSR7dGFpbH1dYDtcblxuXHRcdFx0Y2FzZSAnU2V0Jzpcblx0XHRcdGNhc2UgJ01hcCc6XG5cdFx0XHRcdHJldHVybiBgbmV3ICR7dHlwZX0oWyR7QXJyYXkuZnJvbSh0aGluZykubWFwKHN0cmluZ2lmeSkuam9pbignLCcpfV0pYDtcblxuXHRcdFx0ZGVmYXVsdDpcblx0XHRcdFx0Y29uc3Qgb2JqID0gYHske09iamVjdC5rZXlzKHRoaW5nKVxuXHRcdFx0XHRcdC5tYXAoKGtleSkgPT4gYCR7c2FmZV9rZXkoa2V5KX06JHtzdHJpbmdpZnkodGhpbmdba2V5XSl9YClcblx0XHRcdFx0XHQuam9pbignLCcpfX1gO1xuXHRcdFx0XHRjb25zdCBwcm90byA9IE9iamVjdC5nZXRQcm90b3R5cGVPZih0aGluZyk7XG5cdFx0XHRcdGlmIChwcm90byA9PT0gbnVsbCkge1xuXHRcdFx0XHRcdHJldHVybiBPYmplY3Qua2V5cyh0aGluZykubGVuZ3RoID4gMFxuXHRcdFx0XHRcdFx0PyBgT2JqZWN0LmFzc2lnbihPYmplY3QuY3JlYXRlKG51bGwpLCR7b2JqfSlgXG5cdFx0XHRcdFx0XHQ6IGBPYmplY3QuY3JlYXRlKG51bGwpYDtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHJldHVybiBvYmo7XG5cdFx0fVxuXHR9XG5cblx0Y29uc3Qgc3RyID0gc3RyaW5naWZ5KHZhbHVlKTtcblxuXHRpZiAobmFtZXMuc2l6ZSkge1xuXHRcdC8qKiBAdHlwZSB7c3RyaW5nW119ICovXG5cdFx0Y29uc3QgcGFyYW1zID0gW107XG5cblx0XHQvKiogQHR5cGUge3N0cmluZ1tdfSAqL1xuXHRcdGNvbnN0IHN0YXRlbWVudHMgPSBbXTtcblxuXHRcdC8qKiBAdHlwZSB7c3RyaW5nW119ICovXG5cdFx0Y29uc3QgdmFsdWVzID0gW107XG5cblx0XHRuYW1lcy5mb3JFYWNoKChuYW1lLCB0aGluZykgPT4ge1xuXHRcdFx0cGFyYW1zLnB1c2gobmFtZSk7XG5cblx0XHRcdGlmIChjdXN0b20uaGFzKHRoaW5nKSkge1xuXHRcdFx0XHR2YWx1ZXMucHVzaCgvKiogQHR5cGUge3N0cmluZ30gKi8gKGN1c3RvbS5nZXQodGhpbmcpKSk7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblxuXHRcdFx0aWYgKGlzX3ByaW1pdGl2ZSh0aGluZykpIHtcblx0XHRcdFx0dmFsdWVzLnB1c2goc3RyaW5naWZ5X3ByaW1pdGl2ZSh0aGluZykpO1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdGNvbnN0IHR5cGUgPSBnZXRfdHlwZSh0aGluZyk7XG5cblx0XHRcdHN3aXRjaCAodHlwZSkge1xuXHRcdFx0XHRjYXNlICdOdW1iZXInOlxuXHRcdFx0XHRjYXNlICdTdHJpbmcnOlxuXHRcdFx0XHRjYXNlICdCb29sZWFuJzpcblx0XHRcdFx0XHR2YWx1ZXMucHVzaChgT2JqZWN0KCR7c3RyaW5naWZ5KHRoaW5nLnZhbHVlT2YoKSl9KWApO1xuXHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdGNhc2UgJ1JlZ0V4cCc6XG5cdFx0XHRcdFx0dmFsdWVzLnB1c2godGhpbmcudG9TdHJpbmcoKSk7XG5cdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0Y2FzZSAnRGF0ZSc6XG5cdFx0XHRcdFx0dmFsdWVzLnB1c2goYG5ldyBEYXRlKCR7dGhpbmcuZ2V0VGltZSgpfSlgKTtcblx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRjYXNlICdBcnJheSc6XG5cdFx0XHRcdFx0dmFsdWVzLnB1c2goYEFycmF5KCR7dGhpbmcubGVuZ3RofSlgKTtcblx0XHRcdFx0XHQvKiogQHR5cGUge2FueVtdfSAqLyAodGhpbmcpLmZvckVhY2goKHYsIGkpID0+IHtcblx0XHRcdFx0XHRcdHN0YXRlbWVudHMucHVzaChgJHtuYW1lfVske2l9XT0ke3N0cmluZ2lmeSh2KX1gKTtcblx0XHRcdFx0XHR9KTtcblx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRjYXNlICdTZXQnOlxuXHRcdFx0XHRcdHZhbHVlcy5wdXNoKGBuZXcgU2V0YCk7XG5cdFx0XHRcdFx0c3RhdGVtZW50cy5wdXNoKFxuXHRcdFx0XHRcdFx0YCR7bmFtZX0uJHtBcnJheS5mcm9tKHRoaW5nKVxuXHRcdFx0XHRcdFx0XHQubWFwKCh2KSA9PiBgYWRkKCR7c3RyaW5naWZ5KHYpfSlgKVxuXHRcdFx0XHRcdFx0XHQuam9pbignLicpfWBcblx0XHRcdFx0XHQpO1xuXHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdGNhc2UgJ01hcCc6XG5cdFx0XHRcdFx0dmFsdWVzLnB1c2goYG5ldyBNYXBgKTtcblx0XHRcdFx0XHRzdGF0ZW1lbnRzLnB1c2goXG5cdFx0XHRcdFx0XHRgJHtuYW1lfS4ke0FycmF5LmZyb20odGhpbmcpXG5cdFx0XHRcdFx0XHRcdC5tYXAoKFtrLCB2XSkgPT4gYHNldCgke3N0cmluZ2lmeShrKX0sICR7c3RyaW5naWZ5KHYpfSlgKVxuXHRcdFx0XHRcdFx0XHQuam9pbignLicpfWBcblx0XHRcdFx0XHQpO1xuXHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdGRlZmF1bHQ6XG5cdFx0XHRcdFx0dmFsdWVzLnB1c2goXG5cdFx0XHRcdFx0XHRPYmplY3QuZ2V0UHJvdG90eXBlT2YodGhpbmcpID09PSBudWxsID8gJ09iamVjdC5jcmVhdGUobnVsbCknIDogJ3t9J1xuXHRcdFx0XHRcdCk7XG5cdFx0XHRcdFx0T2JqZWN0LmtleXModGhpbmcpLmZvckVhY2goKGtleSkgPT4ge1xuXHRcdFx0XHRcdFx0c3RhdGVtZW50cy5wdXNoKFxuXHRcdFx0XHRcdFx0XHRgJHtuYW1lfSR7c2FmZV9wcm9wKGtleSl9PSR7c3RyaW5naWZ5KHRoaW5nW2tleV0pfWBcblx0XHRcdFx0XHRcdCk7XG5cdFx0XHRcdFx0fSk7XG5cdFx0XHR9XG5cdFx0fSk7XG5cblx0XHRzdGF0ZW1lbnRzLnB1c2goYHJldHVybiAke3N0cn1gKTtcblxuXHRcdHJldHVybiBgKGZ1bmN0aW9uKCR7cGFyYW1zLmpvaW4oJywnKX0peyR7c3RhdGVtZW50cy5qb2luKFxuXHRcdFx0JzsnXG5cdFx0KX19KCR7dmFsdWVzLmpvaW4oJywnKX0pKWA7XG5cdH0gZWxzZSB7XG5cdFx0cmV0dXJuIHN0cjtcblx0fVxufVxuXG4vKiogQHBhcmFtIHtudW1iZXJ9IG51bSAqL1xuZnVuY3Rpb24gZ2V0X25hbWUobnVtKSB7XG5cdGxldCBuYW1lID0gJyc7XG5cblx0ZG8ge1xuXHRcdG5hbWUgPSBjaGFyc1tudW0gJSBjaGFycy5sZW5ndGhdICsgbmFtZTtcblx0XHRudW0gPSB+fihudW0gLyBjaGFycy5sZW5ndGgpIC0gMTtcblx0fSB3aGlsZSAobnVtID49IDApO1xuXG5cdHJldHVybiByZXNlcnZlZC50ZXN0KG5hbWUpID8gYCR7bmFtZX0wYCA6IG5hbWU7XG59XG5cbi8qKiBAcGFyYW0ge3N0cmluZ30gYyAqL1xuZnVuY3Rpb24gZXNjYXBlX3Vuc2FmZV9jaGFyKGMpIHtcblx0cmV0dXJuIGVzY2FwZWRbY10gfHwgYztcbn1cblxuLyoqIEBwYXJhbSB7c3RyaW5nfSBzdHIgKi9cbmZ1bmN0aW9uIGVzY2FwZV91bnNhZmVfY2hhcnMoc3RyKSB7XG5cdHJldHVybiBzdHIucmVwbGFjZSh1bnNhZmVfY2hhcnMsIGVzY2FwZV91bnNhZmVfY2hhcik7XG59XG5cbi8qKiBAcGFyYW0ge3N0cmluZ30ga2V5ICovXG5mdW5jdGlvbiBzYWZlX2tleShrZXkpIHtcblx0cmV0dXJuIC9eW18kYS16QS1aXVtfJGEtekEtWjAtOV0qJC8udGVzdChrZXkpXG5cdFx0PyBrZXlcblx0XHQ6IGVzY2FwZV91bnNhZmVfY2hhcnMoSlNPTi5zdHJpbmdpZnkoa2V5KSk7XG59XG5cbi8qKiBAcGFyYW0ge3N0cmluZ30ga2V5ICovXG5mdW5jdGlvbiBzYWZlX3Byb3Aoa2V5KSB7XG5cdHJldHVybiAvXltfJGEtekEtWl1bXyRhLXpBLVowLTldKiQvLnRlc3Qoa2V5KVxuXHRcdD8gYC4ke2tleX1gXG5cdFx0OiBgWyR7ZXNjYXBlX3Vuc2FmZV9jaGFycyhKU09OLnN0cmluZ2lmeShrZXkpKX1dYDtcbn1cblxuLyoqIEBwYXJhbSB7YW55fSB0aGluZyAqL1xuZnVuY3Rpb24gc3RyaW5naWZ5X3ByaW1pdGl2ZSh0aGluZykge1xuXHRpZiAodHlwZW9mIHRoaW5nID09PSAnc3RyaW5nJykgcmV0dXJuIHN0cmluZ2lmeV9zdHJpbmcodGhpbmcpO1xuXHRpZiAodGhpbmcgPT09IHZvaWQgMCkgcmV0dXJuICd2b2lkIDAnO1xuXHRpZiAodGhpbmcgPT09IDAgJiYgMSAvIHRoaW5nIDwgMCkgcmV0dXJuICctMCc7XG5cdGNvbnN0IHN0ciA9IFN0cmluZyh0aGluZyk7XG5cdGlmICh0eXBlb2YgdGhpbmcgPT09ICdudW1iZXInKSByZXR1cm4gc3RyLnJlcGxhY2UoL14oLSk/MFxcLi8sICckMS4nKTtcblx0aWYgKHR5cGVvZiB0aGluZyA9PT0gJ2JpZ2ludCcpIHJldHVybiB0aGluZyArICduJztcblx0cmV0dXJuIHN0cjtcbn1cbiIsImV4cG9ydCBjb25zdCBVTkRFRklORUQgPSAtMTtcbmV4cG9ydCBjb25zdCBIT0xFID0gLTI7XG5leHBvcnQgY29uc3QgTkFOID0gLTM7XG5leHBvcnQgY29uc3QgUE9TSVRJVkVfSU5GSU5JVFkgPSAtNDtcbmV4cG9ydCBjb25zdCBORUdBVElWRV9JTkZJTklUWSA9IC01O1xuZXhwb3J0IGNvbnN0IE5FR0FUSVZFX1pFUk8gPSAtNjtcbiIsImltcG9ydCB7XG5cdEhPTEUsXG5cdE5BTixcblx0TkVHQVRJVkVfSU5GSU5JVFksXG5cdE5FR0FUSVZFX1pFUk8sXG5cdFBPU0lUSVZFX0lORklOSVRZLFxuXHRVTkRFRklORURcbn0gZnJvbSAnLi9jb25zdGFudHMuanMnO1xuXG4vKipcbiAqIFJldml2ZSBhIHZhbHVlIHNlcmlhbGl6ZWQgd2l0aCBgZGV2YWx1ZS5zdHJpbmdpZnlgXG4gKiBAcGFyYW0ge3N0cmluZ30gc2VyaWFsaXplZFxuICogQHBhcmFtIHtSZWNvcmQ8c3RyaW5nLCAodmFsdWU6IGFueSkgPT4gYW55Pn0gW3Jldml2ZXJzXVxuICovXG5leHBvcnQgZnVuY3Rpb24gcGFyc2Uoc2VyaWFsaXplZCwgcmV2aXZlcnMpIHtcblx0cmV0dXJuIHVuZmxhdHRlbihKU09OLnBhcnNlKHNlcmlhbGl6ZWQpLCByZXZpdmVycyk7XG59XG5cbi8qKlxuICogUmV2aXZlIGEgdmFsdWUgZmxhdHRlbmVkIHdpdGggYGRldmFsdWUuc3RyaW5naWZ5YFxuICogQHBhcmFtIHtudW1iZXIgfCBhbnlbXX0gcGFyc2VkXG4gKiBAcGFyYW0ge1JlY29yZDxzdHJpbmcsICh2YWx1ZTogYW55KSA9PiBhbnk+fSBbcmV2aXZlcnNdXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1bmZsYXR0ZW4ocGFyc2VkLCByZXZpdmVycykge1xuXHRpZiAodHlwZW9mIHBhcnNlZCA9PT0gJ251bWJlcicpIHJldHVybiBoeWRyYXRlKHBhcnNlZCwgdHJ1ZSk7XG5cblx0aWYgKCFBcnJheS5pc0FycmF5KHBhcnNlZCkgfHwgcGFyc2VkLmxlbmd0aCA9PT0gMCkge1xuXHRcdHRocm93IG5ldyBFcnJvcignSW52YWxpZCBpbnB1dCcpO1xuXHR9XG5cblx0Y29uc3QgdmFsdWVzID0gLyoqIEB0eXBlIHthbnlbXX0gKi8gKHBhcnNlZCk7XG5cblx0Y29uc3QgaHlkcmF0ZWQgPSBBcnJheSh2YWx1ZXMubGVuZ3RoKTtcblxuXHQvKipcblx0ICogQHBhcmFtIHtudW1iZXJ9IGluZGV4XG5cdCAqIEByZXR1cm5zIHthbnl9XG5cdCAqL1xuXHRmdW5jdGlvbiBoeWRyYXRlKGluZGV4LCBzdGFuZGFsb25lID0gZmFsc2UpIHtcblx0XHRpZiAoaW5kZXggPT09IFVOREVGSU5FRCkgcmV0dXJuIHVuZGVmaW5lZDtcblx0XHRpZiAoaW5kZXggPT09IE5BTikgcmV0dXJuIE5hTjtcblx0XHRpZiAoaW5kZXggPT09IFBPU0lUSVZFX0lORklOSVRZKSByZXR1cm4gSW5maW5pdHk7XG5cdFx0aWYgKGluZGV4ID09PSBORUdBVElWRV9JTkZJTklUWSkgcmV0dXJuIC1JbmZpbml0eTtcblx0XHRpZiAoaW5kZXggPT09IE5FR0FUSVZFX1pFUk8pIHJldHVybiAtMDtcblxuXHRcdGlmIChzdGFuZGFsb25lKSB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgaW5wdXRgKTtcblxuXHRcdGlmIChpbmRleCBpbiBoeWRyYXRlZCkgcmV0dXJuIGh5ZHJhdGVkW2luZGV4XTtcblxuXHRcdGNvbnN0IHZhbHVlID0gdmFsdWVzW2luZGV4XTtcblxuXHRcdGlmICghdmFsdWUgfHwgdHlwZW9mIHZhbHVlICE9PSAnb2JqZWN0Jykge1xuXHRcdFx0aHlkcmF0ZWRbaW5kZXhdID0gdmFsdWU7XG5cdFx0fSBlbHNlIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuXHRcdFx0aWYgKHR5cGVvZiB2YWx1ZVswXSA9PT0gJ3N0cmluZycpIHtcblx0XHRcdFx0Y29uc3QgdHlwZSA9IHZhbHVlWzBdO1xuXG5cdFx0XHRcdGNvbnN0IHJldml2ZXIgPSByZXZpdmVycz8uW3R5cGVdO1xuXHRcdFx0XHRpZiAocmV2aXZlcikge1xuXHRcdFx0XHRcdHJldHVybiAoaHlkcmF0ZWRbaW5kZXhdID0gcmV2aXZlcihoeWRyYXRlKHZhbHVlWzFdKSkpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0c3dpdGNoICh0eXBlKSB7XG5cdFx0XHRcdFx0Y2FzZSAnRGF0ZSc6XG5cdFx0XHRcdFx0XHRoeWRyYXRlZFtpbmRleF0gPSBuZXcgRGF0ZSh2YWx1ZVsxXSk7XG5cdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdGNhc2UgJ1NldCc6XG5cdFx0XHRcdFx0XHRjb25zdCBzZXQgPSBuZXcgU2V0KCk7XG5cdFx0XHRcdFx0XHRoeWRyYXRlZFtpbmRleF0gPSBzZXQ7XG5cdFx0XHRcdFx0XHRmb3IgKGxldCBpID0gMTsgaSA8IHZhbHVlLmxlbmd0aDsgaSArPSAxKSB7XG5cdFx0XHRcdFx0XHRcdHNldC5hZGQoaHlkcmF0ZSh2YWx1ZVtpXSkpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0XHRjYXNlICdNYXAnOlxuXHRcdFx0XHRcdFx0Y29uc3QgbWFwID0gbmV3IE1hcCgpO1xuXHRcdFx0XHRcdFx0aHlkcmF0ZWRbaW5kZXhdID0gbWFwO1xuXHRcdFx0XHRcdFx0Zm9yIChsZXQgaSA9IDE7IGkgPCB2YWx1ZS5sZW5ndGg7IGkgKz0gMikge1xuXHRcdFx0XHRcdFx0XHRtYXAuc2V0KGh5ZHJhdGUodmFsdWVbaV0pLCBoeWRyYXRlKHZhbHVlW2kgKyAxXSkpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0XHRjYXNlICdSZWdFeHAnOlxuXHRcdFx0XHRcdFx0aHlkcmF0ZWRbaW5kZXhdID0gbmV3IFJlZ0V4cCh2YWx1ZVsxXSwgdmFsdWVbMl0pO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0XHRjYXNlICdPYmplY3QnOlxuXHRcdFx0XHRcdFx0aHlkcmF0ZWRbaW5kZXhdID0gT2JqZWN0KHZhbHVlWzFdKTtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0Y2FzZSAnQmlnSW50Jzpcblx0XHRcdFx0XHRcdGh5ZHJhdGVkW2luZGV4XSA9IEJpZ0ludCh2YWx1ZVsxXSk7XG5cdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdGNhc2UgJ251bGwnOlxuXHRcdFx0XHRcdFx0Y29uc3Qgb2JqID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcblx0XHRcdFx0XHRcdGh5ZHJhdGVkW2luZGV4XSA9IG9iajtcblx0XHRcdFx0XHRcdGZvciAobGV0IGkgPSAxOyBpIDwgdmFsdWUubGVuZ3RoOyBpICs9IDIpIHtcblx0XHRcdFx0XHRcdFx0b2JqW3ZhbHVlW2ldXSA9IGh5ZHJhdGUodmFsdWVbaSArIDFdKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0ZGVmYXVsdDpcblx0XHRcdFx0XHRcdHRocm93IG5ldyBFcnJvcihgVW5rbm93biB0eXBlICR7dHlwZX1gKTtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Y29uc3QgYXJyYXkgPSBuZXcgQXJyYXkodmFsdWUubGVuZ3RoKTtcblx0XHRcdFx0aHlkcmF0ZWRbaW5kZXhdID0gYXJyYXk7XG5cblx0XHRcdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCB2YWx1ZS5sZW5ndGg7IGkgKz0gMSkge1xuXHRcdFx0XHRcdGNvbnN0IG4gPSB2YWx1ZVtpXTtcblx0XHRcdFx0XHRpZiAobiA9PT0gSE9MRSkgY29udGludWU7XG5cblx0XHRcdFx0XHRhcnJheVtpXSA9IGh5ZHJhdGUobik7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9IGVsc2Uge1xuXHRcdFx0LyoqIEB0eXBlIHtSZWNvcmQ8c3RyaW5nLCBhbnk+fSAqL1xuXHRcdFx0Y29uc3Qgb2JqZWN0ID0ge307XG5cdFx0XHRoeWRyYXRlZFtpbmRleF0gPSBvYmplY3Q7XG5cblx0XHRcdGZvciAoY29uc3Qga2V5IGluIHZhbHVlKSB7XG5cdFx0XHRcdGNvbnN0IG4gPSB2YWx1ZVtrZXldO1xuXHRcdFx0XHRvYmplY3Rba2V5XSA9IGh5ZHJhdGUobik7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGh5ZHJhdGVkW2luZGV4XTtcblx0fVxuXG5cdHJldHVybiBoeWRyYXRlKDApO1xufVxuIiwiaW1wb3J0IHtcblx0RGV2YWx1ZUVycm9yLFxuXHRnZXRfdHlwZSxcblx0aXNfcGxhaW5fb2JqZWN0LFxuXHRpc19wcmltaXRpdmUsXG5cdHN0cmluZ2lmeV9zdHJpbmdcbn0gZnJvbSAnLi91dGlscy5qcyc7XG5pbXBvcnQge1xuXHRIT0xFLFxuXHROQU4sXG5cdE5FR0FUSVZFX0lORklOSVRZLFxuXHRORUdBVElWRV9aRVJPLFxuXHRQT1NJVElWRV9JTkZJTklUWSxcblx0VU5ERUZJTkVEXG59IGZyb20gJy4vY29uc3RhbnRzLmpzJztcblxuLyoqXG4gKiBUdXJuIGEgdmFsdWUgaW50byBhIEpTT04gc3RyaW5nIHRoYXQgY2FuIGJlIHBhcnNlZCB3aXRoIGBkZXZhbHVlLnBhcnNlYFxuICogQHBhcmFtIHthbnl9IHZhbHVlXG4gKiBAcGFyYW0ge1JlY29yZDxzdHJpbmcsICh2YWx1ZTogYW55KSA9PiBhbnk+fSBbcmVkdWNlcnNdXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzdHJpbmdpZnkodmFsdWUsIHJlZHVjZXJzKSB7XG5cdC8qKiBAdHlwZSB7YW55W119ICovXG5cdGNvbnN0IHN0cmluZ2lmaWVkID0gW107XG5cblx0LyoqIEB0eXBlIHtNYXA8YW55LCBudW1iZXI+fSAqL1xuXHRjb25zdCBpbmRleGVzID0gbmV3IE1hcCgpO1xuXG5cdC8qKiBAdHlwZSB7QXJyYXk8eyBrZXk6IHN0cmluZywgZm46ICh2YWx1ZTogYW55KSA9PiBhbnkgfT59ICovXG5cdGNvbnN0IGN1c3RvbSA9IFtdO1xuXHRmb3IgKGNvbnN0IGtleSBpbiByZWR1Y2Vycykge1xuXHRcdGN1c3RvbS5wdXNoKHsga2V5LCBmbjogcmVkdWNlcnNba2V5XSB9KTtcblx0fVxuXG5cdC8qKiBAdHlwZSB7c3RyaW5nW119ICovXG5cdGNvbnN0IGtleXMgPSBbXTtcblxuXHRsZXQgcCA9IDA7XG5cblx0LyoqIEBwYXJhbSB7YW55fSB0aGluZyAqL1xuXHRmdW5jdGlvbiBmbGF0dGVuKHRoaW5nKSB7XG5cdFx0aWYgKHR5cGVvZiB0aGluZyA9PT0gJ2Z1bmN0aW9uJykge1xuXHRcdFx0dGhyb3cgbmV3IERldmFsdWVFcnJvcihgQ2Fubm90IHN0cmluZ2lmeSBhIGZ1bmN0aW9uYCwga2V5cyk7XG5cdFx0fVxuXG5cdFx0aWYgKGluZGV4ZXMuaGFzKHRoaW5nKSkgcmV0dXJuIGluZGV4ZXMuZ2V0KHRoaW5nKTtcblxuXHRcdGlmICh0aGluZyA9PT0gdW5kZWZpbmVkKSByZXR1cm4gVU5ERUZJTkVEO1xuXHRcdGlmIChOdW1iZXIuaXNOYU4odGhpbmcpKSByZXR1cm4gTkFOO1xuXHRcdGlmICh0aGluZyA9PT0gSW5maW5pdHkpIHJldHVybiBQT1NJVElWRV9JTkZJTklUWTtcblx0XHRpZiAodGhpbmcgPT09IC1JbmZpbml0eSkgcmV0dXJuIE5FR0FUSVZFX0lORklOSVRZO1xuXHRcdGlmICh0aGluZyA9PT0gMCAmJiAxIC8gdGhpbmcgPCAwKSByZXR1cm4gTkVHQVRJVkVfWkVSTztcblxuXHRcdGNvbnN0IGluZGV4ID0gcCsrO1xuXHRcdGluZGV4ZXMuc2V0KHRoaW5nLCBpbmRleCk7XG5cblx0XHRmb3IgKGNvbnN0IHsga2V5LCBmbiB9IG9mIGN1c3RvbSkge1xuXHRcdFx0Y29uc3QgdmFsdWUgPSBmbih0aGluZyk7XG5cdFx0XHRpZiAodmFsdWUpIHtcblx0XHRcdFx0c3RyaW5naWZpZWRbaW5kZXhdID0gYFtcIiR7a2V5fVwiLCR7ZmxhdHRlbih2YWx1ZSl9XWA7XG5cdFx0XHRcdHJldHVybiBpbmRleDtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRsZXQgc3RyID0gJyc7XG5cblx0XHRpZiAoaXNfcHJpbWl0aXZlKHRoaW5nKSkge1xuXHRcdFx0c3RyID0gc3RyaW5naWZ5X3ByaW1pdGl2ZSh0aGluZyk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGNvbnN0IHR5cGUgPSBnZXRfdHlwZSh0aGluZyk7XG5cblx0XHRcdHN3aXRjaCAodHlwZSkge1xuXHRcdFx0XHRjYXNlICdOdW1iZXInOlxuXHRcdFx0XHRjYXNlICdTdHJpbmcnOlxuXHRcdFx0XHRjYXNlICdCb29sZWFuJzpcblx0XHRcdFx0XHRzdHIgPSBgW1wiT2JqZWN0XCIsJHtzdHJpbmdpZnlfcHJpbWl0aXZlKHRoaW5nKX1dYDtcblx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRjYXNlICdCaWdJbnQnOlxuXHRcdFx0XHRcdHN0ciA9IGBbXCJCaWdJbnRcIiwke3RoaW5nfV1gO1xuXHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdGNhc2UgJ0RhdGUnOlxuXHRcdFx0XHRcdHN0ciA9IGBbXCJEYXRlXCIsXCIke3RoaW5nLnRvSVNPU3RyaW5nKCl9XCJdYDtcblx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRjYXNlICdSZWdFeHAnOlxuXHRcdFx0XHRcdGNvbnN0IHsgc291cmNlLCBmbGFncyB9ID0gdGhpbmc7XG5cdFx0XHRcdFx0c3RyID0gZmxhZ3Ncblx0XHRcdFx0XHRcdD8gYFtcIlJlZ0V4cFwiLCR7c3RyaW5naWZ5X3N0cmluZyhzb3VyY2UpfSxcIiR7ZmxhZ3N9XCJdYFxuXHRcdFx0XHRcdFx0OiBgW1wiUmVnRXhwXCIsJHtzdHJpbmdpZnlfc3RyaW5nKHNvdXJjZSl9XWA7XG5cdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0Y2FzZSAnQXJyYXknOlxuXHRcdFx0XHRcdHN0ciA9ICdbJztcblxuXHRcdFx0XHRcdGZvciAobGV0IGkgPSAwOyBpIDwgdGhpbmcubGVuZ3RoOyBpICs9IDEpIHtcblx0XHRcdFx0XHRcdGlmIChpID4gMCkgc3RyICs9ICcsJztcblxuXHRcdFx0XHRcdFx0aWYgKGkgaW4gdGhpbmcpIHtcblx0XHRcdFx0XHRcdFx0a2V5cy5wdXNoKGBbJHtpfV1gKTtcblx0XHRcdFx0XHRcdFx0c3RyICs9IGZsYXR0ZW4odGhpbmdbaV0pO1xuXHRcdFx0XHRcdFx0XHRrZXlzLnBvcCgpO1xuXHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0c3RyICs9IEhPTEU7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0c3RyICs9ICddJztcblxuXHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdGNhc2UgJ1NldCc6XG5cdFx0XHRcdFx0c3RyID0gJ1tcIlNldFwiJztcblxuXHRcdFx0XHRcdGZvciAoY29uc3QgdmFsdWUgb2YgdGhpbmcpIHtcblx0XHRcdFx0XHRcdHN0ciArPSBgLCR7ZmxhdHRlbih2YWx1ZSl9YDtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRzdHIgKz0gJ10nO1xuXHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdGNhc2UgJ01hcCc6XG5cdFx0XHRcdFx0c3RyID0gJ1tcIk1hcFwiJztcblxuXHRcdFx0XHRcdGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIHRoaW5nKSB7XG5cdFx0XHRcdFx0XHRrZXlzLnB1c2goXG5cdFx0XHRcdFx0XHRcdGAuZ2V0KCR7aXNfcHJpbWl0aXZlKGtleSkgPyBzdHJpbmdpZnlfcHJpbWl0aXZlKGtleSkgOiAnLi4uJ30pYFxuXHRcdFx0XHRcdFx0KTtcblx0XHRcdFx0XHRcdHN0ciArPSBgLCR7ZmxhdHRlbihrZXkpfSwke2ZsYXR0ZW4odmFsdWUpfWA7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0c3RyICs9ICddJztcblx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRkZWZhdWx0OlxuXHRcdFx0XHRcdGlmICghaXNfcGxhaW5fb2JqZWN0KHRoaW5nKSkge1xuXHRcdFx0XHRcdFx0dGhyb3cgbmV3IERldmFsdWVFcnJvcihcblx0XHRcdFx0XHRcdFx0YENhbm5vdCBzdHJpbmdpZnkgYXJiaXRyYXJ5IG5vbi1QT0pPc2AsXG5cdFx0XHRcdFx0XHRcdGtleXNcblx0XHRcdFx0XHRcdCk7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0aWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHModGhpbmcpLmxlbmd0aCA+IDApIHtcblx0XHRcdFx0XHRcdHRocm93IG5ldyBEZXZhbHVlRXJyb3IoXG5cdFx0XHRcdFx0XHRcdGBDYW5ub3Qgc3RyaW5naWZ5IFBPSk9zIHdpdGggc3ltYm9saWMga2V5c2AsXG5cdFx0XHRcdFx0XHRcdGtleXNcblx0XHRcdFx0XHRcdCk7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0aWYgKE9iamVjdC5nZXRQcm90b3R5cGVPZih0aGluZykgPT09IG51bGwpIHtcblx0XHRcdFx0XHRcdHN0ciA9ICdbXCJudWxsXCInO1xuXHRcdFx0XHRcdFx0Zm9yIChjb25zdCBrZXkgaW4gdGhpbmcpIHtcblx0XHRcdFx0XHRcdFx0a2V5cy5wdXNoKGAuJHtrZXl9YCk7XG5cdFx0XHRcdFx0XHRcdHN0ciArPSBgLCR7c3RyaW5naWZ5X3N0cmluZyhrZXkpfSwke2ZsYXR0ZW4odGhpbmdba2V5XSl9YDtcblx0XHRcdFx0XHRcdFx0a2V5cy5wb3AoKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdHN0ciArPSAnXSc7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdHN0ciA9ICd7Jztcblx0XHRcdFx0XHRcdGxldCBzdGFydGVkID0gZmFsc2U7XG5cdFx0XHRcdFx0XHRmb3IgKGNvbnN0IGtleSBpbiB0aGluZykge1xuXHRcdFx0XHRcdFx0XHRpZiAoc3RhcnRlZCkgc3RyICs9ICcsJztcblx0XHRcdFx0XHRcdFx0c3RhcnRlZCA9IHRydWU7XG5cdFx0XHRcdFx0XHRcdGtleXMucHVzaChgLiR7a2V5fWApO1xuXHRcdFx0XHRcdFx0XHRzdHIgKz0gYCR7c3RyaW5naWZ5X3N0cmluZyhrZXkpfToke2ZsYXR0ZW4odGhpbmdba2V5XSl9YDtcblx0XHRcdFx0XHRcdFx0a2V5cy5wb3AoKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdHN0ciArPSAnfSc7XG5cdFx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHN0cmluZ2lmaWVkW2luZGV4XSA9IHN0cjtcblx0XHRyZXR1cm4gaW5kZXg7XG5cdH1cblxuXHRjb25zdCBpbmRleCA9IGZsYXR0ZW4odmFsdWUpO1xuXG5cdC8vIHNwZWNpYWwgY2FzZSDigJTCoHZhbHVlIGlzIHJlcHJlc2VudGVkIGFzIGEgbmVnYXRpdmUgaW5kZXhcblx0aWYgKGluZGV4IDwgMCkgcmV0dXJuIGAke2luZGV4fWA7XG5cblx0cmV0dXJuIGBbJHtzdHJpbmdpZmllZC5qb2luKCcsJyl9XWA7XG59XG5cbi8qKlxuICogQHBhcmFtIHthbnl9IHRoaW5nXG4gKiBAcmV0dXJucyB7c3RyaW5nfVxuICovXG5mdW5jdGlvbiBzdHJpbmdpZnlfcHJpbWl0aXZlKHRoaW5nKSB7XG5cdGNvbnN0IHR5cGUgPSB0eXBlb2YgdGhpbmc7XG5cdGlmICh0eXBlID09PSAnc3RyaW5nJykgcmV0dXJuIHN0cmluZ2lmeV9zdHJpbmcodGhpbmcpO1xuXHRpZiAodGhpbmcgaW5zdGFuY2VvZiBTdHJpbmcpIHJldHVybiBzdHJpbmdpZnlfc3RyaW5nKHRoaW5nLnRvU3RyaW5nKCkpO1xuXHRpZiAodGhpbmcgPT09IHZvaWQgMCkgcmV0dXJuIFVOREVGSU5FRC50b1N0cmluZygpO1xuXHRpZiAodGhpbmcgPT09IDAgJiYgMSAvIHRoaW5nIDwgMCkgcmV0dXJuIE5FR0FUSVZFX1pFUk8udG9TdHJpbmcoKTtcblx0aWYgKHR5cGUgPT09ICdiaWdpbnQnKSByZXR1cm4gYFtcIkJpZ0ludFwiLFwiJHt0aGluZ31cIl1gO1xuXHRyZXR1cm4gU3RyaW5nKHRoaW5nKTtcbn1cbiIsImV4cG9ydCB7IHVuZXZhbCB9IGZyb20gJy4vc3JjL3VuZXZhbC5qcyc7XG5leHBvcnQgeyBwYXJzZSwgdW5mbGF0dGVuIH0gZnJvbSAnLi9zcmMvcGFyc2UuanMnO1xuZXhwb3J0IHsgc3RyaW5naWZ5IH0gZnJvbSAnLi9zcmMvc3RyaW5naWZ5LmpzJztcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///52944\n")}}]);