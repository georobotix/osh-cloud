"use strict";(self["webpackChunkvue3_webpack5"]=self["webpackChunkvue3_webpack5"]||[]).push([[6452],{46131:function(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__){eval('/* harmony import */ var _asserts_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(99515);\n/**\n * @module ol/structs/LRUCache\n */\n\n\n\n/**\n * @typedef {Object} Entry\n * @property {string} key_ Key.\n * @property {Object} newer Newer.\n * @property {Object} older Older.\n * @property {*} value_ Value.\n */\n\n/**\n * @classdesc\n * Implements a Least-Recently-Used cache where the keys do not conflict with\n * Object\'s properties (e.g. \'hasOwnProperty\' is not allowed as a key). Expiring\n * items from the cache is the responsibility of the user.\n *\n * @fires import("../events/Event.js").default\n * @template T\n */\nclass LRUCache {\n  /**\n   * @param {number} [highWaterMark] High water mark.\n   */\n  constructor(highWaterMark) {\n    /**\n     * Desired max cache size after expireCache(). If set to 0, no cache entries\n     * will be pruned at all.\n     * @type {number}\n     */\n    this.highWaterMark = highWaterMark !== undefined ? highWaterMark : 2048;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.count_ = 0;\n\n    /**\n     * @private\n     * @type {!Object<string, Entry>}\n     */\n    this.entries_ = {};\n\n    /**\n     * @private\n     * @type {?Entry}\n     */\n    this.oldest_ = null;\n\n    /**\n     * @private\n     * @type {?Entry}\n     */\n    this.newest_ = null;\n  }\n\n  /**\n   * @return {boolean} Can expire cache.\n   */\n  canExpireCache() {\n    return this.highWaterMark > 0 && this.getCount() > this.highWaterMark;\n  }\n\n  /**\n   * Expire the cache.\n   * @param {!Object<string, boolean>} [keep] Keys to keep. To be implemented by subclasses.\n   */\n  expireCache(keep) {\n    while (this.canExpireCache()) {\n      this.pop();\n    }\n  }\n\n  /**\n   * FIXME empty description for jsdoc\n   */\n  clear() {\n    this.count_ = 0;\n    this.entries_ = {};\n    this.oldest_ = null;\n    this.newest_ = null;\n  }\n\n  /**\n   * @param {string} key Key.\n   * @return {boolean} Contains key.\n   */\n  containsKey(key) {\n    return this.entries_.hasOwnProperty(key);\n  }\n\n  /**\n   * @param {function(T, string, LRUCache<T>): ?} f The function\n   *     to call for every entry from the oldest to the newer. This function takes\n   *     3 arguments (the entry value, the entry key and the LRUCache object).\n   *     The return value is ignored.\n   */\n  forEach(f) {\n    let entry = this.oldest_;\n    while (entry) {\n      f(entry.value_, entry.key_, this);\n      entry = entry.newer;\n    }\n  }\n\n  /**\n   * @param {string} key Key.\n   * @param {*} [options] Options (reserved for subclasses).\n   * @return {T} Value.\n   */\n  get(key, options) {\n    const entry = this.entries_[key];\n    (0,_asserts_js__WEBPACK_IMPORTED_MODULE_0__/* .assert */ .h)(entry !== undefined, 15); // Tried to get a value for a key that does not exist in the cache\n    if (entry === this.newest_) {\n      return entry.value_;\n    } else if (entry === this.oldest_) {\n      this.oldest_ = /** @type {Entry} */ (this.oldest_.newer);\n      this.oldest_.older = null;\n    } else {\n      entry.newer.older = entry.older;\n      entry.older.newer = entry.newer;\n    }\n    entry.newer = null;\n    entry.older = this.newest_;\n    this.newest_.newer = entry;\n    this.newest_ = entry;\n    return entry.value_;\n  }\n\n  /**\n   * Remove an entry from the cache.\n   * @param {string} key The entry key.\n   * @return {T} The removed entry.\n   */\n  remove(key) {\n    const entry = this.entries_[key];\n    (0,_asserts_js__WEBPACK_IMPORTED_MODULE_0__/* .assert */ .h)(entry !== undefined, 15); // Tried to get a value for a key that does not exist in the cache\n    if (entry === this.newest_) {\n      this.newest_ = /** @type {Entry} */ (entry.older);\n      if (this.newest_) {\n        this.newest_.newer = null;\n      }\n    } else if (entry === this.oldest_) {\n      this.oldest_ = /** @type {Entry} */ (entry.newer);\n      if (this.oldest_) {\n        this.oldest_.older = null;\n      }\n    } else {\n      entry.newer.older = entry.older;\n      entry.older.newer = entry.newer;\n    }\n    delete this.entries_[key];\n    --this.count_;\n    return entry.value_;\n  }\n\n  /**\n   * @return {number} Count.\n   */\n  getCount() {\n    return this.count_;\n  }\n\n  /**\n   * @return {Array<string>} Keys.\n   */\n  getKeys() {\n    const keys = new Array(this.count_);\n    let i = 0;\n    let entry;\n    for (entry = this.newest_; entry; entry = entry.older) {\n      keys[i++] = entry.key_;\n    }\n    return keys;\n  }\n\n  /**\n   * @return {Array<T>} Values.\n   */\n  getValues() {\n    const values = new Array(this.count_);\n    let i = 0;\n    let entry;\n    for (entry = this.newest_; entry; entry = entry.older) {\n      values[i++] = entry.value_;\n    }\n    return values;\n  }\n\n  /**\n   * @return {T} Last value.\n   */\n  peekLast() {\n    return this.oldest_.value_;\n  }\n\n  /**\n   * @return {string} Last key.\n   */\n  peekLastKey() {\n    return this.oldest_.key_;\n  }\n\n  /**\n   * Get the key of the newest item in the cache.  Throws if the cache is empty.\n   * @return {string} The newest key.\n   */\n  peekFirstKey() {\n    return this.newest_.key_;\n  }\n\n  /**\n   * Return an entry without updating least recently used time.\n   * @param {string} key Key.\n   * @return {T} Value.\n   */\n  peek(key) {\n    if (!this.containsKey(key)) {\n      return undefined;\n    }\n    return this.entries_[key].value_;\n  }\n\n  /**\n   * @return {T} value Value.\n   */\n  pop() {\n    const entry = this.oldest_;\n    delete this.entries_[entry.key_];\n    if (entry.newer) {\n      entry.newer.older = null;\n    }\n    this.oldest_ = /** @type {Entry} */ (entry.newer);\n    if (!this.oldest_) {\n      this.newest_ = null;\n    }\n    --this.count_;\n    return entry.value_;\n  }\n\n  /**\n   * @param {string} key Key.\n   * @param {T} value Value.\n   */\n  replace(key, value) {\n    this.get(key); // update `newest_`\n    this.entries_[key].value_ = value;\n  }\n\n  /**\n   * @param {string} key Key.\n   * @param {T} value Value.\n   */\n  set(key, value) {\n    (0,_asserts_js__WEBPACK_IMPORTED_MODULE_0__/* .assert */ .h)(!(key in this.entries_), 16); // Tried to set a value for a key that is used already\n    const entry = {\n      key_: key,\n      newer: null,\n      older: this.newest_,\n      value_: value,\n    };\n    if (!this.newest_) {\n      this.oldest_ = entry;\n    } else {\n      this.newest_.newer = entry;\n    }\n    this.newest_ = entry;\n    this.entries_[key] = entry;\n    ++this.count_;\n  }\n\n  /**\n   * Set a maximum number of entries for the cache.\n   * @param {number} size Cache size.\n   * @api\n   */\n  setSize(size) {\n    this.highWaterMark = size;\n  }\n}\n\n/* harmony default export */ __webpack_exports__["Z"] = (LRUCache);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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LE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEseURBQWUsUUFBUSxFQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdnVlMy13ZWJwYWNrNS8uL25vZGVfbW9kdWxlcy9vbC9zdHJ1Y3RzL0xSVUNhY2hlLmpzPzIxYTUiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAbW9kdWxlIG9sL3N0cnVjdHMvTFJVQ2FjaGVcbiAqL1xuXG5pbXBvcnQge2Fzc2VydH0gZnJvbSAnLi4vYXNzZXJ0cy5qcyc7XG5cbi8qKlxuICogQHR5cGVkZWYge09iamVjdH0gRW50cnlcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBrZXlfIEtleS5cbiAqIEBwcm9wZXJ0eSB7T2JqZWN0fSBuZXdlciBOZXdlci5cbiAqIEBwcm9wZXJ0eSB7T2JqZWN0fSBvbGRlciBPbGRlci5cbiAqIEBwcm9wZXJ0eSB7Kn0gdmFsdWVfIFZhbHVlLlxuICovXG5cbi8qKlxuICogQGNsYXNzZGVzY1xuICogSW1wbGVtZW50cyBhIExlYXN0LVJlY2VudGx5LVVzZWQgY2FjaGUgd2hlcmUgdGhlIGtleXMgZG8gbm90IGNvbmZsaWN0IHdpdGhcbiAqIE9iamVjdCdzIHByb3BlcnRpZXMgKGUuZy4gJ2hhc093blByb3BlcnR5JyBpcyBub3QgYWxsb3dlZCBhcyBhIGtleSkuIEV4cGlyaW5nXG4gKiBpdGVtcyBmcm9tIHRoZSBjYWNoZSBpcyB0aGUgcmVzcG9uc2liaWxpdHkgb2YgdGhlIHVzZXIuXG4gKlxuICogQGZpcmVzIGltcG9ydChcIi4uL2V2ZW50cy9FdmVudC5qc1wiKS5kZWZhdWx0XG4gKiBAdGVtcGxhdGUgVFxuICovXG5jbGFzcyBMUlVDYWNoZSB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge251bWJlcn0gW2hpZ2hXYXRlck1hcmtdIEhpZ2ggd2F0ZXIgbWFyay5cbiAgICovXG4gIGNvbnN0cnVjdG9yKGhpZ2hXYXRlck1hcmspIHtcbiAgICAvKipcbiAgICAgKiBEZXNpcmVkIG1heCBjYWNoZSBzaXplIGFmdGVyIGV4cGlyZUNhY2hlKCkuIElmIHNldCB0byAwLCBubyBjYWNoZSBlbnRyaWVzXG4gICAgICogd2lsbCBiZSBwcnVuZWQgYXQgYWxsLlxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5oaWdoV2F0ZXJNYXJrID0gaGlnaFdhdGVyTWFyayAhPT0gdW5kZWZpbmVkID8gaGlnaFdhdGVyTWFyayA6IDIwNDg7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5jb3VudF8gPSAwO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7IU9iamVjdDxzdHJpbmcsIEVudHJ5Pn1cbiAgICAgKi9cbiAgICB0aGlzLmVudHJpZXNfID0ge307XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHs/RW50cnl9XG4gICAgICovXG4gICAgdGhpcy5vbGRlc3RfID0gbnVsbDtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUgez9FbnRyeX1cbiAgICAgKi9cbiAgICB0aGlzLm5ld2VzdF8gPSBudWxsO1xuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IENhbiBleHBpcmUgY2FjaGUuXG4gICAqL1xuICBjYW5FeHBpcmVDYWNoZSgpIHtcbiAgICByZXR1cm4gdGhpcy5oaWdoV2F0ZXJNYXJrID4gMCAmJiB0aGlzLmdldENvdW50KCkgPiB0aGlzLmhpZ2hXYXRlck1hcms7XG4gIH1cblxuICAvKipcbiAgICogRXhwaXJlIHRoZSBjYWNoZS5cbiAgICogQHBhcmFtIHshT2JqZWN0PHN0cmluZywgYm9vbGVhbj59IFtrZWVwXSBLZXlzIHRvIGtlZXAuIFRvIGJlIGltcGxlbWVudGVkIGJ5IHN1YmNsYXNzZXMuXG4gICAqL1xuICBleHBpcmVDYWNoZShrZWVwKSB7XG4gICAgd2hpbGUgKHRoaXMuY2FuRXhwaXJlQ2FjaGUoKSkge1xuICAgICAgdGhpcy5wb3AoKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogRklYTUUgZW1wdHkgZGVzY3JpcHRpb24gZm9yIGpzZG9jXG4gICAqL1xuICBjbGVhcigpIHtcbiAgICB0aGlzLmNvdW50XyA9IDA7XG4gICAgdGhpcy5lbnRyaWVzXyA9IHt9O1xuICAgIHRoaXMub2xkZXN0XyA9IG51bGw7XG4gICAgdGhpcy5uZXdlc3RfID0gbnVsbDtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IEtleS5cbiAgICogQHJldHVybiB7Ym9vbGVhbn0gQ29udGFpbnMga2V5LlxuICAgKi9cbiAgY29udGFpbnNLZXkoa2V5KSB7XG4gICAgcmV0dXJuIHRoaXMuZW50cmllc18uaGFzT3duUHJvcGVydHkoa2V5KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge2Z1bmN0aW9uKFQsIHN0cmluZywgTFJVQ2FjaGU8VD4pOiA/fSBmIFRoZSBmdW5jdGlvblxuICAgKiAgICAgdG8gY2FsbCBmb3IgZXZlcnkgZW50cnkgZnJvbSB0aGUgb2xkZXN0IHRvIHRoZSBuZXdlci4gVGhpcyBmdW5jdGlvbiB0YWtlc1xuICAgKiAgICAgMyBhcmd1bWVudHMgKHRoZSBlbnRyeSB2YWx1ZSwgdGhlIGVudHJ5IGtleSBhbmQgdGhlIExSVUNhY2hlIG9iamVjdCkuXG4gICAqICAgICBUaGUgcmV0dXJuIHZhbHVlIGlzIGlnbm9yZWQuXG4gICAqL1xuICBmb3JFYWNoKGYpIHtcbiAgICBsZXQgZW50cnkgPSB0aGlzLm9sZGVzdF87XG4gICAgd2hpbGUgKGVudHJ5KSB7XG4gICAgICBmKGVudHJ5LnZhbHVlXywgZW50cnkua2V5XywgdGhpcyk7XG4gICAgICBlbnRyeSA9IGVudHJ5Lm5ld2VyO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IEtleS5cbiAgICogQHBhcmFtIHsqfSBbb3B0aW9uc10gT3B0aW9ucyAocmVzZXJ2ZWQgZm9yIHN1YmNsYXNzZXMpLlxuICAgKiBAcmV0dXJuIHtUfSBWYWx1ZS5cbiAgICovXG4gIGdldChrZXksIG9wdGlvbnMpIHtcbiAgICBjb25zdCBlbnRyeSA9IHRoaXMuZW50cmllc19ba2V5XTtcbiAgICBhc3NlcnQoZW50cnkgIT09IHVuZGVmaW5lZCwgMTUpOyAvLyBUcmllZCB0byBnZXQgYSB2YWx1ZSBmb3IgYSBrZXkgdGhhdCBkb2VzIG5vdCBleGlzdCBpbiB0aGUgY2FjaGVcbiAgICBpZiAoZW50cnkgPT09IHRoaXMubmV3ZXN0Xykge1xuICAgICAgcmV0dXJuIGVudHJ5LnZhbHVlXztcbiAgICB9IGVsc2UgaWYgKGVudHJ5ID09PSB0aGlzLm9sZGVzdF8pIHtcbiAgICAgIHRoaXMub2xkZXN0XyA9IC8qKiBAdHlwZSB7RW50cnl9ICovICh0aGlzLm9sZGVzdF8ubmV3ZXIpO1xuICAgICAgdGhpcy5vbGRlc3RfLm9sZGVyID0gbnVsbDtcbiAgICB9IGVsc2Uge1xuICAgICAgZW50cnkubmV3ZXIub2xkZXIgPSBlbnRyeS5vbGRlcjtcbiAgICAgIGVudHJ5Lm9sZGVyLm5ld2VyID0gZW50cnkubmV3ZXI7XG4gICAgfVxuICAgIGVudHJ5Lm5ld2VyID0gbnVsbDtcbiAgICBlbnRyeS5vbGRlciA9IHRoaXMubmV3ZXN0XztcbiAgICB0aGlzLm5ld2VzdF8ubmV3ZXIgPSBlbnRyeTtcbiAgICB0aGlzLm5ld2VzdF8gPSBlbnRyeTtcbiAgICByZXR1cm4gZW50cnkudmFsdWVfO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlbW92ZSBhbiBlbnRyeSBmcm9tIHRoZSBjYWNoZS5cbiAgICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUgZW50cnkga2V5LlxuICAgKiBAcmV0dXJuIHtUfSBUaGUgcmVtb3ZlZCBlbnRyeS5cbiAgICovXG4gIHJlbW92ZShrZXkpIHtcbiAgICBjb25zdCBlbnRyeSA9IHRoaXMuZW50cmllc19ba2V5XTtcbiAgICBhc3NlcnQoZW50cnkgIT09IHVuZGVmaW5lZCwgMTUpOyAvLyBUcmllZCB0byBnZXQgYSB2YWx1ZSBmb3IgYSBrZXkgdGhhdCBkb2VzIG5vdCBleGlzdCBpbiB0aGUgY2FjaGVcbiAgICBpZiAoZW50cnkgPT09IHRoaXMubmV3ZXN0Xykge1xuICAgICAgdGhpcy5uZXdlc3RfID0gLyoqIEB0eXBlIHtFbnRyeX0gKi8gKGVudHJ5Lm9sZGVyKTtcbiAgICAgIGlmICh0aGlzLm5ld2VzdF8pIHtcbiAgICAgICAgdGhpcy5uZXdlc3RfLm5ld2VyID0gbnVsbDtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGVudHJ5ID09PSB0aGlzLm9sZGVzdF8pIHtcbiAgICAgIHRoaXMub2xkZXN0XyA9IC8qKiBAdHlwZSB7RW50cnl9ICovIChlbnRyeS5uZXdlcik7XG4gICAgICBpZiAodGhpcy5vbGRlc3RfKSB7XG4gICAgICAgIHRoaXMub2xkZXN0Xy5vbGRlciA9IG51bGw7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGVudHJ5Lm5ld2VyLm9sZGVyID0gZW50cnkub2xkZXI7XG4gICAgICBlbnRyeS5vbGRlci5uZXdlciA9IGVudHJ5Lm5ld2VyO1xuICAgIH1cbiAgICBkZWxldGUgdGhpcy5lbnRyaWVzX1trZXldO1xuICAgIC0tdGhpcy5jb3VudF87XG4gICAgcmV0dXJuIGVudHJ5LnZhbHVlXztcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtudW1iZXJ9IENvdW50LlxuICAgKi9cbiAgZ2V0Q291bnQoKSB7XG4gICAgcmV0dXJuIHRoaXMuY291bnRfO1xuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge0FycmF5PHN0cmluZz59IEtleXMuXG4gICAqL1xuICBnZXRLZXlzKCkge1xuICAgIGNvbnN0IGtleXMgPSBuZXcgQXJyYXkodGhpcy5jb3VudF8pO1xuICAgIGxldCBpID0gMDtcbiAgICBsZXQgZW50cnk7XG4gICAgZm9yIChlbnRyeSA9IHRoaXMubmV3ZXN0XzsgZW50cnk7IGVudHJ5ID0gZW50cnkub2xkZXIpIHtcbiAgICAgIGtleXNbaSsrXSA9IGVudHJ5LmtleV87XG4gICAgfVxuICAgIHJldHVybiBrZXlzO1xuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge0FycmF5PFQ+fSBWYWx1ZXMuXG4gICAqL1xuICBnZXRWYWx1ZXMoKSB7XG4gICAgY29uc3QgdmFsdWVzID0gbmV3IEFycmF5KHRoaXMuY291bnRfKTtcbiAgICBsZXQgaSA9IDA7XG4gICAgbGV0IGVudHJ5O1xuICAgIGZvciAoZW50cnkgPSB0aGlzLm5ld2VzdF87IGVudHJ5OyBlbnRyeSA9IGVudHJ5Lm9sZGVyKSB7XG4gICAgICB2YWx1ZXNbaSsrXSA9IGVudHJ5LnZhbHVlXztcbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlcztcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtUfSBMYXN0IHZhbHVlLlxuICAgKi9cbiAgcGVla0xhc3QoKSB7XG4gICAgcmV0dXJuIHRoaXMub2xkZXN0Xy52YWx1ZV87XG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7c3RyaW5nfSBMYXN0IGtleS5cbiAgICovXG4gIHBlZWtMYXN0S2V5KCkge1xuICAgIHJldHVybiB0aGlzLm9sZGVzdF8ua2V5XztcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIGtleSBvZiB0aGUgbmV3ZXN0IGl0ZW0gaW4gdGhlIGNhY2hlLiAgVGhyb3dzIGlmIHRoZSBjYWNoZSBpcyBlbXB0eS5cbiAgICogQHJldHVybiB7c3RyaW5nfSBUaGUgbmV3ZXN0IGtleS5cbiAgICovXG4gIHBlZWtGaXJzdEtleSgpIHtcbiAgICByZXR1cm4gdGhpcy5uZXdlc3RfLmtleV87XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJuIGFuIGVudHJ5IHdpdGhvdXQgdXBkYXRpbmcgbGVhc3QgcmVjZW50bHkgdXNlZCB0aW1lLlxuICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IEtleS5cbiAgICogQHJldHVybiB7VH0gVmFsdWUuXG4gICAqL1xuICBwZWVrKGtleSkge1xuICAgIGlmICghdGhpcy5jb250YWluc0tleShrZXkpKSB7XG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5lbnRyaWVzX1trZXldLnZhbHVlXztcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtUfSB2YWx1ZSBWYWx1ZS5cbiAgICovXG4gIHBvcCgpIHtcbiAgICBjb25zdCBlbnRyeSA9IHRoaXMub2xkZXN0XztcbiAgICBkZWxldGUgdGhpcy5lbnRyaWVzX1tlbnRyeS5rZXlfXTtcbiAgICBpZiAoZW50cnkubmV3ZXIpIHtcbiAgICAgIGVudHJ5Lm5ld2VyLm9sZGVyID0gbnVsbDtcbiAgICB9XG4gICAgdGhpcy5vbGRlc3RfID0gLyoqIEB0eXBlIHtFbnRyeX0gKi8gKGVudHJ5Lm5ld2VyKTtcbiAgICBpZiAoIXRoaXMub2xkZXN0Xykge1xuICAgICAgdGhpcy5uZXdlc3RfID0gbnVsbDtcbiAgICB9XG4gICAgLS10aGlzLmNvdW50XztcbiAgICByZXR1cm4gZW50cnkudmFsdWVfO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgS2V5LlxuICAgKiBAcGFyYW0ge1R9IHZhbHVlIFZhbHVlLlxuICAgKi9cbiAgcmVwbGFjZShrZXksIHZhbHVlKSB7XG4gICAgdGhpcy5nZXQoa2V5KTsgLy8gdXBkYXRlIGBuZXdlc3RfYFxuICAgIHRoaXMuZW50cmllc19ba2V5XS52YWx1ZV8gPSB2YWx1ZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IEtleS5cbiAgICogQHBhcmFtIHtUfSB2YWx1ZSBWYWx1ZS5cbiAgICovXG4gIHNldChrZXksIHZhbHVlKSB7XG4gICAgYXNzZXJ0KCEoa2V5IGluIHRoaXMuZW50cmllc18pLCAxNik7IC8vIFRyaWVkIHRvIHNldCBhIHZhbHVlIGZvciBhIGtleSB0aGF0IGlzIHVzZWQgYWxyZWFkeVxuICAgIGNvbnN0IGVudHJ5ID0ge1xuICAgICAga2V5Xzoga2V5LFxuICAgICAgbmV3ZXI6IG51bGwsXG4gICAgICBvbGRlcjogdGhpcy5uZXdlc3RfLFxuICAgICAgdmFsdWVfOiB2YWx1ZSxcbiAgICB9O1xuICAgIGlmICghdGhpcy5uZXdlc3RfKSB7XG4gICAgICB0aGlzLm9sZGVzdF8gPSBlbnRyeTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5uZXdlc3RfLm5ld2VyID0gZW50cnk7XG4gICAgfVxuICAgIHRoaXMubmV3ZXN0XyA9IGVudHJ5O1xuICAgIHRoaXMuZW50cmllc19ba2V5XSA9IGVudHJ5O1xuICAgICsrdGhpcy5jb3VudF87XG4gIH1cblxuICAvKipcbiAgICogU2V0IGEgbWF4aW11bSBudW1iZXIgb2YgZW50cmllcyBmb3IgdGhlIGNhY2hlLlxuICAgKiBAcGFyYW0ge251bWJlcn0gc2l6ZSBDYWNoZSBzaXplLlxuICAgKiBAYXBpXG4gICAqL1xuICBzZXRTaXplKHNpemUpIHtcbiAgICB0aGlzLmhpZ2hXYXRlck1hcmsgPSBzaXplO1xuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IExSVUNhY2hlO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///46131\n')},22729:function(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__){eval('/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "r": function() { return /* binding */ DROP; }\n/* harmony export */ });\n/* harmony import */ var _asserts_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(99515);\n/* harmony import */ var _obj_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(69374);\n/**\n * @module ol/structs/PriorityQueue\n */\n\n\n\n/**\n * @type {number}\n */\nconst DROP = Infinity;\n\n/**\n * @classdesc\n * Priority queue.\n *\n * The implementation is inspired from the Closure Library\'s Heap class and\n * Python\'s heapq module.\n *\n * See https://github.com/google/closure-library/blob/master/closure/goog/structs/heap.js\n * and https://hg.python.org/cpython/file/2.7/Lib/heapq.py.\n *\n * @template T\n */\nclass PriorityQueue {\n  /**\n   * @param {function(T): number} priorityFunction Priority function.\n   * @param {function(T): string} keyFunction Key function.\n   */\n  constructor(priorityFunction, keyFunction) {\n    /**\n     * @type {function(T): number}\n     * @private\n     */\n    this.priorityFunction_ = priorityFunction;\n\n    /**\n     * @type {function(T): string}\n     * @private\n     */\n    this.keyFunction_ = keyFunction;\n\n    /**\n     * @type {Array<T>}\n     * @private\n     */\n    this.elements_ = [];\n\n    /**\n     * @type {Array<number>}\n     * @private\n     */\n    this.priorities_ = [];\n\n    /**\n     * @type {!Object<string, boolean>}\n     * @private\n     */\n    this.queuedElements_ = {};\n  }\n\n  /**\n   * FIXME empty description for jsdoc\n   */\n  clear() {\n    this.elements_.length = 0;\n    this.priorities_.length = 0;\n    (0,_obj_js__WEBPACK_IMPORTED_MODULE_0__/* .clear */ .Z)(this.queuedElements_);\n  }\n\n  /**\n   * Remove and return the highest-priority element. O(log N).\n   * @return {T} Element.\n   */\n  dequeue() {\n    const elements = this.elements_;\n    const priorities = this.priorities_;\n    const element = elements[0];\n    if (elements.length == 1) {\n      elements.length = 0;\n      priorities.length = 0;\n    } else {\n      elements[0] = elements.pop();\n      priorities[0] = priorities.pop();\n      this.siftUp_(0);\n    }\n    const elementKey = this.keyFunction_(element);\n    delete this.queuedElements_[elementKey];\n    return element;\n  }\n\n  /**\n   * Enqueue an element. O(log N).\n   * @param {T} element Element.\n   * @return {boolean} The element was added to the queue.\n   */\n  enqueue(element) {\n    (0,_asserts_js__WEBPACK_IMPORTED_MODULE_1__/* .assert */ .h)(!(this.keyFunction_(element) in this.queuedElements_), 31); // Tried to enqueue an `element` that was already added to the queue\n    const priority = this.priorityFunction_(element);\n    if (priority != DROP) {\n      this.elements_.push(element);\n      this.priorities_.push(priority);\n      this.queuedElements_[this.keyFunction_(element)] = true;\n      this.siftDown_(0, this.elements_.length - 1);\n      return true;\n    }\n    return false;\n  }\n\n  /**\n   * @return {number} Count.\n   */\n  getCount() {\n    return this.elements_.length;\n  }\n\n  /**\n   * Gets the index of the left child of the node at the given index.\n   * @param {number} index The index of the node to get the left child for.\n   * @return {number} The index of the left child.\n   * @private\n   */\n  getLeftChildIndex_(index) {\n    return index * 2 + 1;\n  }\n\n  /**\n   * Gets the index of the right child of the node at the given index.\n   * @param {number} index The index of the node to get the right child for.\n   * @return {number} The index of the right child.\n   * @private\n   */\n  getRightChildIndex_(index) {\n    return index * 2 + 2;\n  }\n\n  /**\n   * Gets the index of the parent of the node at the given index.\n   * @param {number} index The index of the node to get the parent for.\n   * @return {number} The index of the parent.\n   * @private\n   */\n  getParentIndex_(index) {\n    return (index - 1) >> 1;\n  }\n\n  /**\n   * Make this a heap. O(N).\n   * @private\n   */\n  heapify_() {\n    let i;\n    for (i = (this.elements_.length >> 1) - 1; i >= 0; i--) {\n      this.siftUp_(i);\n    }\n  }\n\n  /**\n   * @return {boolean} Is empty.\n   */\n  isEmpty() {\n    return this.elements_.length === 0;\n  }\n\n  /**\n   * @param {string} key Key.\n   * @return {boolean} Is key queued.\n   */\n  isKeyQueued(key) {\n    return key in this.queuedElements_;\n  }\n\n  /**\n   * @param {T} element Element.\n   * @return {boolean} Is queued.\n   */\n  isQueued(element) {\n    return this.isKeyQueued(this.keyFunction_(element));\n  }\n\n  /**\n   * @param {number} index The index of the node to move down.\n   * @private\n   */\n  siftUp_(index) {\n    const elements = this.elements_;\n    const priorities = this.priorities_;\n    const count = elements.length;\n    const element = elements[index];\n    const priority = priorities[index];\n    const startIndex = index;\n\n    while (index < count >> 1) {\n      const lIndex = this.getLeftChildIndex_(index);\n      const rIndex = this.getRightChildIndex_(index);\n\n      const smallerChildIndex =\n        rIndex < count && priorities[rIndex] < priorities[lIndex]\n          ? rIndex\n          : lIndex;\n\n      elements[index] = elements[smallerChildIndex];\n      priorities[index] = priorities[smallerChildIndex];\n      index = smallerChildIndex;\n    }\n\n    elements[index] = element;\n    priorities[index] = priority;\n    this.siftDown_(startIndex, index);\n  }\n\n  /**\n   * @param {number} startIndex The index of the root.\n   * @param {number} index The index of the node to move up.\n   * @private\n   */\n  siftDown_(startIndex, index) {\n    const elements = this.elements_;\n    const priorities = this.priorities_;\n    const element = elements[index];\n    const priority = priorities[index];\n\n    while (index > startIndex) {\n      const parentIndex = this.getParentIndex_(index);\n      if (priorities[parentIndex] > priority) {\n        elements[index] = elements[parentIndex];\n        priorities[index] = priorities[parentIndex];\n        index = parentIndex;\n      } else {\n        break;\n      }\n    }\n    elements[index] = element;\n    priorities[index] = priority;\n  }\n\n  /**\n   * FIXME empty description for jsdoc\n   */\n  reprioritize() {\n    const priorityFunction = this.priorityFunction_;\n    const elements = this.elements_;\n    const priorities = this.priorities_;\n    let index = 0;\n    const n = elements.length;\n    let element, i, priority;\n    for (i = 0; i < n; ++i) {\n      element = elements[i];\n      priority = priorityFunction(element);\n      if (priority == DROP) {\n        delete this.queuedElements_[this.keyFunction_(element)];\n      } else {\n        priorities[index] = priority;\n        elements[index++] = element;\n      }\n    }\n    elements.length = index;\n    priorities.length = index;\n    this.heapify_();\n  }\n}\n\n/* harmony default export */ __webpack_exports__["Z"] = (PriorityQueue);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjI3MjkuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDcUM7QUFDTDs7QUFFaEM7QUFDQSxVQUFVO0FBQ1Y7QUFDTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxxQkFBcUI7QUFDbEMsYUFBYSxxQkFBcUI7QUFDbEM7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBOztBQUVBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLHVEQUFLO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBLGNBQWMsR0FBRztBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGFBQWEsR0FBRztBQUNoQixjQUFjLFNBQVM7QUFDdkI7QUFDQTtBQUNBLElBQUksNERBQU0sNkRBQTZEO0FBQ3ZFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsY0FBYyxRQUFRO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckIsY0FBYyxRQUFRO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixjQUFjLFFBQVE7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGNBQWMsUUFBUTtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQyxRQUFRO0FBQ3ZEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGNBQWMsU0FBUztBQUN2QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixjQUFjLFNBQVM7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxhQUFhLEdBQUc7QUFDaEIsY0FBYyxTQUFTO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxhQUFhLFFBQVE7QUFDckIsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsT0FBTztBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEseURBQWUsYUFBYSxFQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdnVlMy13ZWJwYWNrNS8uL25vZGVfbW9kdWxlcy9vbC9zdHJ1Y3RzL1ByaW9yaXR5UXVldWUuanM/MzgxNyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBtb2R1bGUgb2wvc3RydWN0cy9Qcmlvcml0eVF1ZXVlXG4gKi9cbmltcG9ydCB7YXNzZXJ0fSBmcm9tICcuLi9hc3NlcnRzLmpzJztcbmltcG9ydCB7Y2xlYXJ9IGZyb20gJy4uL29iai5qcyc7XG5cbi8qKlxuICogQHR5cGUge251bWJlcn1cbiAqL1xuZXhwb3J0IGNvbnN0IERST1AgPSBJbmZpbml0eTtcblxuLyoqXG4gKiBAY2xhc3NkZXNjXG4gKiBQcmlvcml0eSBxdWV1ZS5cbiAqXG4gKiBUaGUgaW1wbGVtZW50YXRpb24gaXMgaW5zcGlyZWQgZnJvbSB0aGUgQ2xvc3VyZSBMaWJyYXJ5J3MgSGVhcCBjbGFzcyBhbmRcbiAqIFB5dGhvbidzIGhlYXBxIG1vZHVsZS5cbiAqXG4gKiBTZWUgaHR0cHM6Ly9naXRodWIuY29tL2dvb2dsZS9jbG9zdXJlLWxpYnJhcnkvYmxvYi9tYXN0ZXIvY2xvc3VyZS9nb29nL3N0cnVjdHMvaGVhcC5qc1xuICogYW5kIGh0dHBzOi8vaGcucHl0aG9uLm9yZy9jcHl0aG9uL2ZpbGUvMi43L0xpYi9oZWFwcS5weS5cbiAqXG4gKiBAdGVtcGxhdGUgVFxuICovXG5jbGFzcyBQcmlvcml0eVF1ZXVlIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb24oVCk6IG51bWJlcn0gcHJpb3JpdHlGdW5jdGlvbiBQcmlvcml0eSBmdW5jdGlvbi5cbiAgICogQHBhcmFtIHtmdW5jdGlvbihUKTogc3RyaW5nfSBrZXlGdW5jdGlvbiBLZXkgZnVuY3Rpb24uXG4gICAqL1xuICBjb25zdHJ1Y3Rvcihwcmlvcml0eUZ1bmN0aW9uLCBrZXlGdW5jdGlvbikge1xuICAgIC8qKlxuICAgICAqIEB0eXBlIHtmdW5jdGlvbihUKTogbnVtYmVyfVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5wcmlvcml0eUZ1bmN0aW9uXyA9IHByaW9yaXR5RnVuY3Rpb247XG5cbiAgICAvKipcbiAgICAgKiBAdHlwZSB7ZnVuY3Rpb24oVCk6IHN0cmluZ31cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMua2V5RnVuY3Rpb25fID0ga2V5RnVuY3Rpb247XG5cbiAgICAvKipcbiAgICAgKiBAdHlwZSB7QXJyYXk8VD59XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLmVsZW1lbnRzXyA9IFtdO1xuXG4gICAgLyoqXG4gICAgICogQHR5cGUge0FycmF5PG51bWJlcj59XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLnByaW9yaXRpZXNfID0gW107XG5cbiAgICAvKipcbiAgICAgKiBAdHlwZSB7IU9iamVjdDxzdHJpbmcsIGJvb2xlYW4+fVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5xdWV1ZWRFbGVtZW50c18gPSB7fTtcbiAgfVxuXG4gIC8qKlxuICAgKiBGSVhNRSBlbXB0eSBkZXNjcmlwdGlvbiBmb3IganNkb2NcbiAgICovXG4gIGNsZWFyKCkge1xuICAgIHRoaXMuZWxlbWVudHNfLmxlbmd0aCA9IDA7XG4gICAgdGhpcy5wcmlvcml0aWVzXy5sZW5ndGggPSAwO1xuICAgIGNsZWFyKHRoaXMucXVldWVkRWxlbWVudHNfKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZW1vdmUgYW5kIHJldHVybiB0aGUgaGlnaGVzdC1wcmlvcml0eSBlbGVtZW50LiBPKGxvZyBOKS5cbiAgICogQHJldHVybiB7VH0gRWxlbWVudC5cbiAgICovXG4gIGRlcXVldWUoKSB7XG4gICAgY29uc3QgZWxlbWVudHMgPSB0aGlzLmVsZW1lbnRzXztcbiAgICBjb25zdCBwcmlvcml0aWVzID0gdGhpcy5wcmlvcml0aWVzXztcbiAgICBjb25zdCBlbGVtZW50ID0gZWxlbWVudHNbMF07XG4gICAgaWYgKGVsZW1lbnRzLmxlbmd0aCA9PSAxKSB7XG4gICAgICBlbGVtZW50cy5sZW5ndGggPSAwO1xuICAgICAgcHJpb3JpdGllcy5sZW5ndGggPSAwO1xuICAgIH0gZWxzZSB7XG4gICAgICBlbGVtZW50c1swXSA9IGVsZW1lbnRzLnBvcCgpO1xuICAgICAgcHJpb3JpdGllc1swXSA9IHByaW9yaXRpZXMucG9wKCk7XG4gICAgICB0aGlzLnNpZnRVcF8oMCk7XG4gICAgfVxuICAgIGNvbnN0IGVsZW1lbnRLZXkgPSB0aGlzLmtleUZ1bmN0aW9uXyhlbGVtZW50KTtcbiAgICBkZWxldGUgdGhpcy5xdWV1ZWRFbGVtZW50c19bZWxlbWVudEtleV07XG4gICAgcmV0dXJuIGVsZW1lbnQ7XG4gIH1cblxuICAvKipcbiAgICogRW5xdWV1ZSBhbiBlbGVtZW50LiBPKGxvZyBOKS5cbiAgICogQHBhcmFtIHtUfSBlbGVtZW50IEVsZW1lbnQuXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IFRoZSBlbGVtZW50IHdhcyBhZGRlZCB0byB0aGUgcXVldWUuXG4gICAqL1xuICBlbnF1ZXVlKGVsZW1lbnQpIHtcbiAgICBhc3NlcnQoISh0aGlzLmtleUZ1bmN0aW9uXyhlbGVtZW50KSBpbiB0aGlzLnF1ZXVlZEVsZW1lbnRzXyksIDMxKTsgLy8gVHJpZWQgdG8gZW5xdWV1ZSBhbiBgZWxlbWVudGAgdGhhdCB3YXMgYWxyZWFkeSBhZGRlZCB0byB0aGUgcXVldWVcbiAgICBjb25zdCBwcmlvcml0eSA9IHRoaXMucHJpb3JpdHlGdW5jdGlvbl8oZWxlbWVudCk7XG4gICAgaWYgKHByaW9yaXR5ICE9IERST1ApIHtcbiAgICAgIHRoaXMuZWxlbWVudHNfLnB1c2goZWxlbWVudCk7XG4gICAgICB0aGlzLnByaW9yaXRpZXNfLnB1c2gocHJpb3JpdHkpO1xuICAgICAgdGhpcy5xdWV1ZWRFbGVtZW50c19bdGhpcy5rZXlGdW5jdGlvbl8oZWxlbWVudCldID0gdHJ1ZTtcbiAgICAgIHRoaXMuc2lmdERvd25fKDAsIHRoaXMuZWxlbWVudHNfLmxlbmd0aCAtIDEpO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtudW1iZXJ9IENvdW50LlxuICAgKi9cbiAgZ2V0Q291bnQoKSB7XG4gICAgcmV0dXJuIHRoaXMuZWxlbWVudHNfLmxlbmd0aDtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIHRoZSBpbmRleCBvZiB0aGUgbGVmdCBjaGlsZCBvZiB0aGUgbm9kZSBhdCB0aGUgZ2l2ZW4gaW5kZXguXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleCBUaGUgaW5kZXggb2YgdGhlIG5vZGUgdG8gZ2V0IHRoZSBsZWZ0IGNoaWxkIGZvci5cbiAgICogQHJldHVybiB7bnVtYmVyfSBUaGUgaW5kZXggb2YgdGhlIGxlZnQgY2hpbGQuXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBnZXRMZWZ0Q2hpbGRJbmRleF8oaW5kZXgpIHtcbiAgICByZXR1cm4gaW5kZXggKiAyICsgMTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIHRoZSBpbmRleCBvZiB0aGUgcmlnaHQgY2hpbGQgb2YgdGhlIG5vZGUgYXQgdGhlIGdpdmVuIGluZGV4LlxuICAgKiBAcGFyYW0ge251bWJlcn0gaW5kZXggVGhlIGluZGV4IG9mIHRoZSBub2RlIHRvIGdldCB0aGUgcmlnaHQgY2hpbGQgZm9yLlxuICAgKiBAcmV0dXJuIHtudW1iZXJ9IFRoZSBpbmRleCBvZiB0aGUgcmlnaHQgY2hpbGQuXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBnZXRSaWdodENoaWxkSW5kZXhfKGluZGV4KSB7XG4gICAgcmV0dXJuIGluZGV4ICogMiArIDI7XG4gIH1cblxuICAvKipcbiAgICogR2V0cyB0aGUgaW5kZXggb2YgdGhlIHBhcmVudCBvZiB0aGUgbm9kZSBhdCB0aGUgZ2l2ZW4gaW5kZXguXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleCBUaGUgaW5kZXggb2YgdGhlIG5vZGUgdG8gZ2V0IHRoZSBwYXJlbnQgZm9yLlxuICAgKiBAcmV0dXJuIHtudW1iZXJ9IFRoZSBpbmRleCBvZiB0aGUgcGFyZW50LlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZ2V0UGFyZW50SW5kZXhfKGluZGV4KSB7XG4gICAgcmV0dXJuIChpbmRleCAtIDEpID4+IDE7XG4gIH1cblxuICAvKipcbiAgICogTWFrZSB0aGlzIGEgaGVhcC4gTyhOKS5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIGhlYXBpZnlfKCkge1xuICAgIGxldCBpO1xuICAgIGZvciAoaSA9ICh0aGlzLmVsZW1lbnRzXy5sZW5ndGggPj4gMSkgLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgdGhpcy5zaWZ0VXBfKGkpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtib29sZWFufSBJcyBlbXB0eS5cbiAgICovXG4gIGlzRW1wdHkoKSB7XG4gICAgcmV0dXJuIHRoaXMuZWxlbWVudHNfLmxlbmd0aCA9PT0gMDtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IEtleS5cbiAgICogQHJldHVybiB7Ym9vbGVhbn0gSXMga2V5IHF1ZXVlZC5cbiAgICovXG4gIGlzS2V5UXVldWVkKGtleSkge1xuICAgIHJldHVybiBrZXkgaW4gdGhpcy5xdWV1ZWRFbGVtZW50c187XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtUfSBlbGVtZW50IEVsZW1lbnQuXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IElzIHF1ZXVlZC5cbiAgICovXG4gIGlzUXVldWVkKGVsZW1lbnQpIHtcbiAgICByZXR1cm4gdGhpcy5pc0tleVF1ZXVlZCh0aGlzLmtleUZ1bmN0aW9uXyhlbGVtZW50KSk7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtudW1iZXJ9IGluZGV4IFRoZSBpbmRleCBvZiB0aGUgbm9kZSB0byBtb3ZlIGRvd24uXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBzaWZ0VXBfKGluZGV4KSB7XG4gICAgY29uc3QgZWxlbWVudHMgPSB0aGlzLmVsZW1lbnRzXztcbiAgICBjb25zdCBwcmlvcml0aWVzID0gdGhpcy5wcmlvcml0aWVzXztcbiAgICBjb25zdCBjb3VudCA9IGVsZW1lbnRzLmxlbmd0aDtcbiAgICBjb25zdCBlbGVtZW50ID0gZWxlbWVudHNbaW5kZXhdO1xuICAgIGNvbnN0IHByaW9yaXR5ID0gcHJpb3JpdGllc1tpbmRleF07XG4gICAgY29uc3Qgc3RhcnRJbmRleCA9IGluZGV4O1xuXG4gICAgd2hpbGUgKGluZGV4IDwgY291bnQgPj4gMSkge1xuICAgICAgY29uc3QgbEluZGV4ID0gdGhpcy5nZXRMZWZ0Q2hpbGRJbmRleF8oaW5kZXgpO1xuICAgICAgY29uc3QgckluZGV4ID0gdGhpcy5nZXRSaWdodENoaWxkSW5kZXhfKGluZGV4KTtcblxuICAgICAgY29uc3Qgc21hbGxlckNoaWxkSW5kZXggPVxuICAgICAgICBySW5kZXggPCBjb3VudCAmJiBwcmlvcml0aWVzW3JJbmRleF0gPCBwcmlvcml0aWVzW2xJbmRleF1cbiAgICAgICAgICA/IHJJbmRleFxuICAgICAgICAgIDogbEluZGV4O1xuXG4gICAgICBlbGVtZW50c1tpbmRleF0gPSBlbGVtZW50c1tzbWFsbGVyQ2hpbGRJbmRleF07XG4gICAgICBwcmlvcml0aWVzW2luZGV4XSA9IHByaW9yaXRpZXNbc21hbGxlckNoaWxkSW5kZXhdO1xuICAgICAgaW5kZXggPSBzbWFsbGVyQ2hpbGRJbmRleDtcbiAgICB9XG5cbiAgICBlbGVtZW50c1tpbmRleF0gPSBlbGVtZW50O1xuICAgIHByaW9yaXRpZXNbaW5kZXhdID0gcHJpb3JpdHk7XG4gICAgdGhpcy5zaWZ0RG93bl8oc3RhcnRJbmRleCwgaW5kZXgpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBzdGFydEluZGV4IFRoZSBpbmRleCBvZiB0aGUgcm9vdC5cbiAgICogQHBhcmFtIHtudW1iZXJ9IGluZGV4IFRoZSBpbmRleCBvZiB0aGUgbm9kZSB0byBtb3ZlIHVwLlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgc2lmdERvd25fKHN0YXJ0SW5kZXgsIGluZGV4KSB7XG4gICAgY29uc3QgZWxlbWVudHMgPSB0aGlzLmVsZW1lbnRzXztcbiAgICBjb25zdCBwcmlvcml0aWVzID0gdGhpcy5wcmlvcml0aWVzXztcbiAgICBjb25zdCBlbGVtZW50ID0gZWxlbWVudHNbaW5kZXhdO1xuICAgIGNvbnN0IHByaW9yaXR5ID0gcHJpb3JpdGllc1tpbmRleF07XG5cbiAgICB3aGlsZSAoaW5kZXggPiBzdGFydEluZGV4KSB7XG4gICAgICBjb25zdCBwYXJlbnRJbmRleCA9IHRoaXMuZ2V0UGFyZW50SW5kZXhfKGluZGV4KTtcbiAgICAgIGlmIChwcmlvcml0aWVzW3BhcmVudEluZGV4XSA+IHByaW9yaXR5KSB7XG4gICAgICAgIGVsZW1lbnRzW2luZGV4XSA9IGVsZW1lbnRzW3BhcmVudEluZGV4XTtcbiAgICAgICAgcHJpb3JpdGllc1tpbmRleF0gPSBwcmlvcml0aWVzW3BhcmVudEluZGV4XTtcbiAgICAgICAgaW5kZXggPSBwYXJlbnRJbmRleDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICBlbGVtZW50c1tpbmRleF0gPSBlbGVtZW50O1xuICAgIHByaW9yaXRpZXNbaW5kZXhdID0gcHJpb3JpdHk7XG4gIH1cblxuICAvKipcbiAgICogRklYTUUgZW1wdHkgZGVzY3JpcHRpb24gZm9yIGpzZG9jXG4gICAqL1xuICByZXByaW9yaXRpemUoKSB7XG4gICAgY29uc3QgcHJpb3JpdHlGdW5jdGlvbiA9IHRoaXMucHJpb3JpdHlGdW5jdGlvbl87XG4gICAgY29uc3QgZWxlbWVudHMgPSB0aGlzLmVsZW1lbnRzXztcbiAgICBjb25zdCBwcmlvcml0aWVzID0gdGhpcy5wcmlvcml0aWVzXztcbiAgICBsZXQgaW5kZXggPSAwO1xuICAgIGNvbnN0IG4gPSBlbGVtZW50cy5sZW5ndGg7XG4gICAgbGV0IGVsZW1lbnQsIGksIHByaW9yaXR5O1xuICAgIGZvciAoaSA9IDA7IGkgPCBuOyArK2kpIHtcbiAgICAgIGVsZW1lbnQgPSBlbGVtZW50c1tpXTtcbiAgICAgIHByaW9yaXR5ID0gcHJpb3JpdHlGdW5jdGlvbihlbGVtZW50KTtcbiAgICAgIGlmIChwcmlvcml0eSA9PSBEUk9QKSB7XG4gICAgICAgIGRlbGV0ZSB0aGlzLnF1ZXVlZEVsZW1lbnRzX1t0aGlzLmtleUZ1bmN0aW9uXyhlbGVtZW50KV07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwcmlvcml0aWVzW2luZGV4XSA9IHByaW9yaXR5O1xuICAgICAgICBlbGVtZW50c1tpbmRleCsrXSA9IGVsZW1lbnQ7XG4gICAgICB9XG4gICAgfVxuICAgIGVsZW1lbnRzLmxlbmd0aCA9IGluZGV4O1xuICAgIHByaW9yaXRpZXMubGVuZ3RoID0gaW5kZXg7XG4gICAgdGhpcy5oZWFwaWZ5XygpO1xuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IFByaW9yaXR5UXVldWU7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///22729\n')},39781:function(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__){eval('/* harmony import */ var rbush__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(82582);\n/* harmony import */ var _extent_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(28641);\n/* harmony import */ var _util_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(74187);\n/* harmony import */ var _obj_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(69374);\n/**\n * @module ol/structs/RBush\n */\n\n\n\n\n\n/**\n * @typedef {Object} Entry\n * @property {number} minX MinX.\n * @property {number} minY MinY.\n * @property {number} maxX MaxX.\n * @property {number} maxY MaxY.\n * @property {Object} [value] Value.\n */\n\n/**\n * @classdesc\n * Wrapper around the RBush by Vladimir Agafonkin.\n * See https://github.com/mourner/rbush.\n *\n * @template T\n */\nclass RBush {\n  /**\n   * @param {number} [maxEntries] Max entries.\n   */\n  constructor(maxEntries) {\n    /**\n     * @private\n     */\n    this.rbush_ = new rbush__WEBPACK_IMPORTED_MODULE_0__(maxEntries);\n\n    /**\n     * A mapping between the objects added to this rbush wrapper\n     * and the objects that are actually added to the internal rbush.\n     * @private\n     * @type {Object<string, Entry>}\n     */\n    this.items_ = {};\n  }\n\n  /**\n   * Insert a value into the RBush.\n   * @param {import("../extent.js").Extent} extent Extent.\n   * @param {T} value Value.\n   */\n  insert(extent, value) {\n    /** @type {Entry} */\n    const item = {\n      minX: extent[0],\n      minY: extent[1],\n      maxX: extent[2],\n      maxY: extent[3],\n      value: value,\n    };\n\n    this.rbush_.insert(item);\n    this.items_[(0,_util_js__WEBPACK_IMPORTED_MODULE_1__/* .getUid */ .sq)(value)] = item;\n  }\n\n  /**\n   * Bulk-insert values into the RBush.\n   * @param {Array<import("../extent.js").Extent>} extents Extents.\n   * @param {Array<T>} values Values.\n   */\n  load(extents, values) {\n    const items = new Array(values.length);\n    for (let i = 0, l = values.length; i < l; i++) {\n      const extent = extents[i];\n      const value = values[i];\n\n      /** @type {Entry} */\n      const item = {\n        minX: extent[0],\n        minY: extent[1],\n        maxX: extent[2],\n        maxY: extent[3],\n        value: value,\n      };\n      items[i] = item;\n      this.items_[(0,_util_js__WEBPACK_IMPORTED_MODULE_1__/* .getUid */ .sq)(value)] = item;\n    }\n    this.rbush_.load(items);\n  }\n\n  /**\n   * Remove a value from the RBush.\n   * @param {T} value Value.\n   * @return {boolean} Removed.\n   */\n  remove(value) {\n    const uid = (0,_util_js__WEBPACK_IMPORTED_MODULE_1__/* .getUid */ .sq)(value);\n\n    // get the object in which the value was wrapped when adding to the\n    // internal rbush. then use that object to do the removal.\n    const item = this.items_[uid];\n    delete this.items_[uid];\n    return this.rbush_.remove(item) !== null;\n  }\n\n  /**\n   * Update the extent of a value in the RBush.\n   * @param {import("../extent.js").Extent} extent Extent.\n   * @param {T} value Value.\n   */\n  update(extent, value) {\n    const item = this.items_[(0,_util_js__WEBPACK_IMPORTED_MODULE_1__/* .getUid */ .sq)(value)];\n    const bbox = [item.minX, item.minY, item.maxX, item.maxY];\n    if (!(0,_extent_js__WEBPACK_IMPORTED_MODULE_2__/* .equals */ .fS)(bbox, extent)) {\n      this.remove(value);\n      this.insert(extent, value);\n    }\n  }\n\n  /**\n   * Return all values in the RBush.\n   * @return {Array<T>} All.\n   */\n  getAll() {\n    const items = this.rbush_.all();\n    return items.map(function (item) {\n      return item.value;\n    });\n  }\n\n  /**\n   * Return all values in the given extent.\n   * @param {import("../extent.js").Extent} extent Extent.\n   * @return {Array<T>} All in extent.\n   */\n  getInExtent(extent) {\n    /** @type {Entry} */\n    const bbox = {\n      minX: extent[0],\n      minY: extent[1],\n      maxX: extent[2],\n      maxY: extent[3],\n    };\n    const items = this.rbush_.search(bbox);\n    return items.map(function (item) {\n      return item.value;\n    });\n  }\n\n  /**\n   * Calls a callback function with each value in the tree.\n   * If the callback returns a truthy value, this value is returned without\n   * checking the rest of the tree.\n   * @param {function(T): *} callback Callback.\n   * @return {*} Callback return value.\n   */\n  forEach(callback) {\n    return this.forEach_(this.getAll(), callback);\n  }\n\n  /**\n   * Calls a callback function with each value in the provided extent.\n   * @param {import("../extent.js").Extent} extent Extent.\n   * @param {function(T): *} callback Callback.\n   * @return {*} Callback return value.\n   */\n  forEachInExtent(extent, callback) {\n    return this.forEach_(this.getInExtent(extent), callback);\n  }\n\n  /**\n   * @param {Array<T>} values Values.\n   * @param {function(T): *} callback Callback.\n   * @private\n   * @return {*} Callback return value.\n   */\n  forEach_(values, callback) {\n    let result;\n    for (let i = 0, l = values.length; i < l; i++) {\n      result = callback(values[i]);\n      if (result) {\n        return result;\n      }\n    }\n    return result;\n  }\n\n  /**\n   * @return {boolean} Is empty.\n   */\n  isEmpty() {\n    return (0,_obj_js__WEBPACK_IMPORTED_MODULE_3__/* .isEmpty */ .x)(this.items_);\n  }\n\n  /**\n   * Remove all values from the RBush.\n   */\n  clear() {\n    this.rbush_.clear();\n    this.items_ = {};\n  }\n\n  /**\n   * @param {import("../extent.js").Extent} [extent] Extent.\n   * @return {import("../extent.js").Extent} Extent.\n   */\n  getExtent(extent) {\n    const data = this.rbush_.toJSON();\n    return (0,_extent_js__WEBPACK_IMPORTED_MODULE_2__/* .createOrUpdate */ .T9)(data.minX, data.minY, data.maxX, data.maxY, extent);\n  }\n\n  /**\n   * @param {RBush} rbush R-Tree.\n   */\n  concat(rbush) {\n    this.rbush_.load(rbush.rbush_.all());\n    for (const i in rbush.items_) {\n      this.items_[i] = rbush.items_[i];\n    }\n  }\n}\n\n/* harmony default export */ __webpack_exports__["Z"] = (RBush);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMzk3ODEuanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFBO0FBQ0E7QUFDQTtBQUMyQjtBQUN5QjtBQUNsQjtBQUNBOztBQUVsQztBQUNBLGFBQWEsUUFBUTtBQUNyQixjQUFjLFFBQVE7QUFDdEIsY0FBYyxRQUFRO0FBQ3RCLGNBQWMsUUFBUTtBQUN0QixjQUFjLFFBQVE7QUFDdEIsY0FBYyxRQUFRO0FBQ3RCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLGtDQUFNOztBQUU1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGFBQWEsK0JBQStCO0FBQzVDLGFBQWEsR0FBRztBQUNoQjtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZ0JBQWdCLDBEQUFNO0FBQ3RCOztBQUVBO0FBQ0E7QUFDQSxhQUFhLHNDQUFzQztBQUNuRCxhQUFhLFVBQVU7QUFDdkI7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLE9BQU87QUFDOUM7QUFDQTs7QUFFQSxpQkFBaUIsT0FBTztBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLDBEQUFNO0FBQ3hCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsYUFBYSxHQUFHO0FBQ2hCLGNBQWMsU0FBUztBQUN2QjtBQUNBO0FBQ0EsZ0JBQWdCLDBEQUFNOztBQUV0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGFBQWEsK0JBQStCO0FBQzVDLGFBQWEsR0FBRztBQUNoQjtBQUNBO0FBQ0EsNkJBQTZCLDBEQUFNO0FBQ25DO0FBQ0EsU0FBUyw0REFBTTtBQUNmO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxjQUFjLFVBQVU7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0EsYUFBYSwrQkFBK0I7QUFDNUMsY0FBYyxVQUFVO0FBQ3hCO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxnQkFBZ0I7QUFDN0IsY0FBYyxHQUFHO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxhQUFhLCtCQUErQjtBQUM1QyxhQUFhLGdCQUFnQjtBQUM3QixjQUFjLEdBQUc7QUFDakI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxhQUFhLFVBQVU7QUFDdkIsYUFBYSxnQkFBZ0I7QUFDN0I7QUFDQSxjQUFjLEdBQUc7QUFDakI7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLE9BQU87QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxjQUFjLFNBQVM7QUFDdkI7QUFDQTtBQUNBLFdBQVcseURBQU87QUFDbEI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxhQUFhLCtCQUErQjtBQUM1QyxjQUFjLCtCQUErQjtBQUM3QztBQUNBO0FBQ0E7QUFDQSxXQUFXLG9FQUFjO0FBQ3pCOztBQUVBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEseURBQWUsS0FBSyxFQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdnVlMy13ZWJwYWNrNS8uL25vZGVfbW9kdWxlcy9vbC9zdHJ1Y3RzL1JCdXNoLmpzP2NhZDIiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAbW9kdWxlIG9sL3N0cnVjdHMvUkJ1c2hcbiAqL1xuaW1wb3J0IFJCdXNoXyBmcm9tICdyYnVzaCc7XG5pbXBvcnQge2NyZWF0ZU9yVXBkYXRlLCBlcXVhbHN9IGZyb20gJy4uL2V4dGVudC5qcyc7XG5pbXBvcnQge2dldFVpZH0gZnJvbSAnLi4vdXRpbC5qcyc7XG5pbXBvcnQge2lzRW1wdHl9IGZyb20gJy4uL29iai5qcyc7XG5cbi8qKlxuICogQHR5cGVkZWYge09iamVjdH0gRW50cnlcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBtaW5YIE1pblguXG4gKiBAcHJvcGVydHkge251bWJlcn0gbWluWSBNaW5ZLlxuICogQHByb3BlcnR5IHtudW1iZXJ9IG1heFggTWF4WC5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBtYXhZIE1heFkuXG4gKiBAcHJvcGVydHkge09iamVjdH0gW3ZhbHVlXSBWYWx1ZS5cbiAqL1xuXG4vKipcbiAqIEBjbGFzc2Rlc2NcbiAqIFdyYXBwZXIgYXJvdW5kIHRoZSBSQnVzaCBieSBWbGFkaW1pciBBZ2Fmb25raW4uXG4gKiBTZWUgaHR0cHM6Ly9naXRodWIuY29tL21vdXJuZXIvcmJ1c2guXG4gKlxuICogQHRlbXBsYXRlIFRcbiAqL1xuY2xhc3MgUkJ1c2gge1xuICAvKipcbiAgICogQHBhcmFtIHtudW1iZXJ9IFttYXhFbnRyaWVzXSBNYXggZW50cmllcy5cbiAgICovXG4gIGNvbnN0cnVjdG9yKG1heEVudHJpZXMpIHtcbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMucmJ1c2hfID0gbmV3IFJCdXNoXyhtYXhFbnRyaWVzKTtcblxuICAgIC8qKlxuICAgICAqIEEgbWFwcGluZyBiZXR3ZWVuIHRoZSBvYmplY3RzIGFkZGVkIHRvIHRoaXMgcmJ1c2ggd3JhcHBlclxuICAgICAqIGFuZCB0aGUgb2JqZWN0cyB0aGF0IGFyZSBhY3R1YWxseSBhZGRlZCB0byB0aGUgaW50ZXJuYWwgcmJ1c2guXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7T2JqZWN0PHN0cmluZywgRW50cnk+fVxuICAgICAqL1xuICAgIHRoaXMuaXRlbXNfID0ge307XG4gIH1cblxuICAvKipcbiAgICogSW5zZXJ0IGEgdmFsdWUgaW50byB0aGUgUkJ1c2guXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vZXh0ZW50LmpzXCIpLkV4dGVudH0gZXh0ZW50IEV4dGVudC5cbiAgICogQHBhcmFtIHtUfSB2YWx1ZSBWYWx1ZS5cbiAgICovXG4gIGluc2VydChleHRlbnQsIHZhbHVlKSB7XG4gICAgLyoqIEB0eXBlIHtFbnRyeX0gKi9cbiAgICBjb25zdCBpdGVtID0ge1xuICAgICAgbWluWDogZXh0ZW50WzBdLFxuICAgICAgbWluWTogZXh0ZW50WzFdLFxuICAgICAgbWF4WDogZXh0ZW50WzJdLFxuICAgICAgbWF4WTogZXh0ZW50WzNdLFxuICAgICAgdmFsdWU6IHZhbHVlLFxuICAgIH07XG5cbiAgICB0aGlzLnJidXNoXy5pbnNlcnQoaXRlbSk7XG4gICAgdGhpcy5pdGVtc19bZ2V0VWlkKHZhbHVlKV0gPSBpdGVtO1xuICB9XG5cbiAgLyoqXG4gICAqIEJ1bGstaW5zZXJ0IHZhbHVlcyBpbnRvIHRoZSBSQnVzaC5cbiAgICogQHBhcmFtIHtBcnJheTxpbXBvcnQoXCIuLi9leHRlbnQuanNcIikuRXh0ZW50Pn0gZXh0ZW50cyBFeHRlbnRzLlxuICAgKiBAcGFyYW0ge0FycmF5PFQ+fSB2YWx1ZXMgVmFsdWVzLlxuICAgKi9cbiAgbG9hZChleHRlbnRzLCB2YWx1ZXMpIHtcbiAgICBjb25zdCBpdGVtcyA9IG5ldyBBcnJheSh2YWx1ZXMubGVuZ3RoKTtcbiAgICBmb3IgKGxldCBpID0gMCwgbCA9IHZhbHVlcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIGNvbnN0IGV4dGVudCA9IGV4dGVudHNbaV07XG4gICAgICBjb25zdCB2YWx1ZSA9IHZhbHVlc1tpXTtcblxuICAgICAgLyoqIEB0eXBlIHtFbnRyeX0gKi9cbiAgICAgIGNvbnN0IGl0ZW0gPSB7XG4gICAgICAgIG1pblg6IGV4dGVudFswXSxcbiAgICAgICAgbWluWTogZXh0ZW50WzFdLFxuICAgICAgICBtYXhYOiBleHRlbnRbMl0sXG4gICAgICAgIG1heFk6IGV4dGVudFszXSxcbiAgICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgfTtcbiAgICAgIGl0ZW1zW2ldID0gaXRlbTtcbiAgICAgIHRoaXMuaXRlbXNfW2dldFVpZCh2YWx1ZSldID0gaXRlbTtcbiAgICB9XG4gICAgdGhpcy5yYnVzaF8ubG9hZChpdGVtcyk7XG4gIH1cblxuICAvKipcbiAgICogUmVtb3ZlIGEgdmFsdWUgZnJvbSB0aGUgUkJ1c2guXG4gICAqIEBwYXJhbSB7VH0gdmFsdWUgVmFsdWUuXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IFJlbW92ZWQuXG4gICAqL1xuICByZW1vdmUodmFsdWUpIHtcbiAgICBjb25zdCB1aWQgPSBnZXRVaWQodmFsdWUpO1xuXG4gICAgLy8gZ2V0IHRoZSBvYmplY3QgaW4gd2hpY2ggdGhlIHZhbHVlIHdhcyB3cmFwcGVkIHdoZW4gYWRkaW5nIHRvIHRoZVxuICAgIC8vIGludGVybmFsIHJidXNoLiB0aGVuIHVzZSB0aGF0IG9iamVjdCB0byBkbyB0aGUgcmVtb3ZhbC5cbiAgICBjb25zdCBpdGVtID0gdGhpcy5pdGVtc19bdWlkXTtcbiAgICBkZWxldGUgdGhpcy5pdGVtc19bdWlkXTtcbiAgICByZXR1cm4gdGhpcy5yYnVzaF8ucmVtb3ZlKGl0ZW0pICE9PSBudWxsO1xuICB9XG5cbiAgLyoqXG4gICAqIFVwZGF0ZSB0aGUgZXh0ZW50IG9mIGEgdmFsdWUgaW4gdGhlIFJCdXNoLlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL2V4dGVudC5qc1wiKS5FeHRlbnR9IGV4dGVudCBFeHRlbnQuXG4gICAqIEBwYXJhbSB7VH0gdmFsdWUgVmFsdWUuXG4gICAqL1xuICB1cGRhdGUoZXh0ZW50LCB2YWx1ZSkge1xuICAgIGNvbnN0IGl0ZW0gPSB0aGlzLml0ZW1zX1tnZXRVaWQodmFsdWUpXTtcbiAgICBjb25zdCBiYm94ID0gW2l0ZW0ubWluWCwgaXRlbS5taW5ZLCBpdGVtLm1heFgsIGl0ZW0ubWF4WV07XG4gICAgaWYgKCFlcXVhbHMoYmJveCwgZXh0ZW50KSkge1xuICAgICAgdGhpcy5yZW1vdmUodmFsdWUpO1xuICAgICAgdGhpcy5pbnNlcnQoZXh0ZW50LCB2YWx1ZSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybiBhbGwgdmFsdWVzIGluIHRoZSBSQnVzaC5cbiAgICogQHJldHVybiB7QXJyYXk8VD59IEFsbC5cbiAgICovXG4gIGdldEFsbCgpIHtcbiAgICBjb25zdCBpdGVtcyA9IHRoaXMucmJ1c2hfLmFsbCgpO1xuICAgIHJldHVybiBpdGVtcy5tYXAoZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgIHJldHVybiBpdGVtLnZhbHVlO1xuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybiBhbGwgdmFsdWVzIGluIHRoZSBnaXZlbiBleHRlbnQuXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vZXh0ZW50LmpzXCIpLkV4dGVudH0gZXh0ZW50IEV4dGVudC5cbiAgICogQHJldHVybiB7QXJyYXk8VD59IEFsbCBpbiBleHRlbnQuXG4gICAqL1xuICBnZXRJbkV4dGVudChleHRlbnQpIHtcbiAgICAvKiogQHR5cGUge0VudHJ5fSAqL1xuICAgIGNvbnN0IGJib3ggPSB7XG4gICAgICBtaW5YOiBleHRlbnRbMF0sXG4gICAgICBtaW5ZOiBleHRlbnRbMV0sXG4gICAgICBtYXhYOiBleHRlbnRbMl0sXG4gICAgICBtYXhZOiBleHRlbnRbM10sXG4gICAgfTtcbiAgICBjb25zdCBpdGVtcyA9IHRoaXMucmJ1c2hfLnNlYXJjaChiYm94KTtcbiAgICByZXR1cm4gaXRlbXMubWFwKGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICByZXR1cm4gaXRlbS52YWx1ZTtcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDYWxscyBhIGNhbGxiYWNrIGZ1bmN0aW9uIHdpdGggZWFjaCB2YWx1ZSBpbiB0aGUgdHJlZS5cbiAgICogSWYgdGhlIGNhbGxiYWNrIHJldHVybnMgYSB0cnV0aHkgdmFsdWUsIHRoaXMgdmFsdWUgaXMgcmV0dXJuZWQgd2l0aG91dFxuICAgKiBjaGVja2luZyB0aGUgcmVzdCBvZiB0aGUgdHJlZS5cbiAgICogQHBhcmFtIHtmdW5jdGlvbihUKTogKn0gY2FsbGJhY2sgQ2FsbGJhY2suXG4gICAqIEByZXR1cm4geyp9IENhbGxiYWNrIHJldHVybiB2YWx1ZS5cbiAgICovXG4gIGZvckVhY2goY2FsbGJhY2spIHtcbiAgICByZXR1cm4gdGhpcy5mb3JFYWNoXyh0aGlzLmdldEFsbCgpLCBjYWxsYmFjayk7XG4gIH1cblxuICAvKipcbiAgICogQ2FsbHMgYSBjYWxsYmFjayBmdW5jdGlvbiB3aXRoIGVhY2ggdmFsdWUgaW4gdGhlIHByb3ZpZGVkIGV4dGVudC5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9leHRlbnQuanNcIikuRXh0ZW50fSBleHRlbnQgRXh0ZW50LlxuICAgKiBAcGFyYW0ge2Z1bmN0aW9uKFQpOiAqfSBjYWxsYmFjayBDYWxsYmFjay5cbiAgICogQHJldHVybiB7Kn0gQ2FsbGJhY2sgcmV0dXJuIHZhbHVlLlxuICAgKi9cbiAgZm9yRWFjaEluRXh0ZW50KGV4dGVudCwgY2FsbGJhY2spIHtcbiAgICByZXR1cm4gdGhpcy5mb3JFYWNoXyh0aGlzLmdldEluRXh0ZW50KGV4dGVudCksIGNhbGxiYWNrKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge0FycmF5PFQ+fSB2YWx1ZXMgVmFsdWVzLlxuICAgKiBAcGFyYW0ge2Z1bmN0aW9uKFQpOiAqfSBjYWxsYmFjayBDYWxsYmFjay5cbiAgICogQHByaXZhdGVcbiAgICogQHJldHVybiB7Kn0gQ2FsbGJhY2sgcmV0dXJuIHZhbHVlLlxuICAgKi9cbiAgZm9yRWFjaF8odmFsdWVzLCBjYWxsYmFjaykge1xuICAgIGxldCByZXN1bHQ7XG4gICAgZm9yIChsZXQgaSA9IDAsIGwgPSB2YWx1ZXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICByZXN1bHQgPSBjYWxsYmFjayh2YWx1ZXNbaV0pO1xuICAgICAgaWYgKHJlc3VsdCkge1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IElzIGVtcHR5LlxuICAgKi9cbiAgaXNFbXB0eSgpIHtcbiAgICByZXR1cm4gaXNFbXB0eSh0aGlzLml0ZW1zXyk7XG4gIH1cblxuICAvKipcbiAgICogUmVtb3ZlIGFsbCB2YWx1ZXMgZnJvbSB0aGUgUkJ1c2guXG4gICAqL1xuICBjbGVhcigpIHtcbiAgICB0aGlzLnJidXNoXy5jbGVhcigpO1xuICAgIHRoaXMuaXRlbXNfID0ge307XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9leHRlbnQuanNcIikuRXh0ZW50fSBbZXh0ZW50XSBFeHRlbnQuXG4gICAqIEByZXR1cm4ge2ltcG9ydChcIi4uL2V4dGVudC5qc1wiKS5FeHRlbnR9IEV4dGVudC5cbiAgICovXG4gIGdldEV4dGVudChleHRlbnQpIHtcbiAgICBjb25zdCBkYXRhID0gdGhpcy5yYnVzaF8udG9KU09OKCk7XG4gICAgcmV0dXJuIGNyZWF0ZU9yVXBkYXRlKGRhdGEubWluWCwgZGF0YS5taW5ZLCBkYXRhLm1heFgsIGRhdGEubWF4WSwgZXh0ZW50KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge1JCdXNofSByYnVzaCBSLVRyZWUuXG4gICAqL1xuICBjb25jYXQocmJ1c2gpIHtcbiAgICB0aGlzLnJidXNoXy5sb2FkKHJidXNoLnJidXNoXy5hbGwoKSk7XG4gICAgZm9yIChjb25zdCBpIGluIHJidXNoLml0ZW1zXykge1xuICAgICAgdGhpcy5pdGVtc19baV0gPSByYnVzaC5pdGVtc19baV07XG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IFJCdXNoO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///39781\n')},30283:function(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__){eval('/* harmony import */ var _RegularShape_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(35393);\n/**\n * @module ol/style/Circle\n */\n\n\n\n/**\n * @typedef {Object} Options\n * @property {import("./Fill.js").default} [fill] Fill style.\n * @property {number} radius Circle radius.\n * @property {import("./Stroke.js").default} [stroke] Stroke style.\n * @property {Array<number>} [displacement=[0,0]] displacement\n * @property {number|import("../size.js").Size} [scale=1] Scale. A two dimensional scale will produce an ellipse.\n * Unless two dimensional scaling is required a better result may be obtained with an appropriate setting for `radius`.\n * @property {number} [rotation=0] Rotation in radians\n * (positive rotation clockwise, meaningful only when used in conjunction with a two dimensional scale).\n * @property {boolean} [rotateWithView=false] Whether to rotate the shape with the view\n * (meaningful only when used in conjunction with a two dimensional scale).\n * @property {"declutter"|"obstacle"|"none"|undefined} [declutterMode] Declutter mode\n */\n\n/**\n * @classdesc\n * Set circle style for vector features.\n * @api\n */\nclass CircleStyle extends _RegularShape_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .Z {\n  /**\n   * @param {Options} [options] Options.\n   */\n  constructor(options) {\n    options = options ? options : {radius: 5};\n\n    super({\n      points: Infinity,\n      fill: options.fill,\n      radius: options.radius,\n      stroke: options.stroke,\n      scale: options.scale !== undefined ? options.scale : 1,\n      rotation: options.rotation !== undefined ? options.rotation : 0,\n      rotateWithView:\n        options.rotateWithView !== undefined ? options.rotateWithView : false,\n      displacement:\n        options.displacement !== undefined ? options.displacement : [0, 0],\n      declutterMode: options.declutterMode,\n    });\n  }\n\n  /**\n   * Clones the style.\n   * @return {CircleStyle} The cloned style.\n   * @api\n   */\n  clone() {\n    const scale = this.getScale();\n    const style = new CircleStyle({\n      fill: this.getFill() ? this.getFill().clone() : undefined,\n      stroke: this.getStroke() ? this.getStroke().clone() : undefined,\n      radius: this.getRadius(),\n      scale: Array.isArray(scale) ? scale.slice() : scale,\n      rotation: this.getRotation(),\n      rotateWithView: this.getRotateWithView(),\n      displacement: this.getDisplacement().slice(),\n      declutterMode: this.getDeclutterMode(),\n    });\n    style.setOpacity(this.getOpacity());\n    return style;\n  }\n\n  /**\n   * Set the circle radius.\n   *\n   * @param {number} radius Circle radius.\n   * @api\n   */\n  setRadius(radius) {\n    this.radius_ = radius;\n    this.render();\n  }\n}\n\n/* harmony default export */ __webpack_exports__["Z"] = (CircleStyle);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMzAyODMuanMiLCJtYXBwaW5ncyI6IjtBQUFBO0FBQ0E7QUFDQTs7QUFFNkM7O0FBRTdDO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGNBQWMsNkJBQTZCO0FBQzNDLGNBQWMsUUFBUTtBQUN0QixjQUFjLCtCQUErQjtBQUM3QyxjQUFjLGVBQWU7QUFDN0IsY0FBYyxrQ0FBa0M7QUFDaEQ7QUFDQSxjQUFjLFFBQVE7QUFDdEI7QUFDQSxjQUFjLFNBQVM7QUFDdkI7QUFDQSxjQUFjLHlDQUF5QztBQUN2RDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLGlFQUFZO0FBQ3RDO0FBQ0EsYUFBYSxTQUFTO0FBQ3RCO0FBQ0E7QUFDQSxtQ0FBbUM7O0FBRW5DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0EsY0FBYyxhQUFhO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEseURBQWUsV0FBVyxFQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdnVlMy13ZWJwYWNrNS8uL25vZGVfbW9kdWxlcy9vbC9zdHlsZS9DaXJjbGUuanM/ZTJkZSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBtb2R1bGUgb2wvc3R5bGUvQ2lyY2xlXG4gKi9cblxuaW1wb3J0IFJlZ3VsYXJTaGFwZSBmcm9tICcuL1JlZ3VsYXJTaGFwZS5qcyc7XG5cbi8qKlxuICogQHR5cGVkZWYge09iamVjdH0gT3B0aW9uc1xuICogQHByb3BlcnR5IHtpbXBvcnQoXCIuL0ZpbGwuanNcIikuZGVmYXVsdH0gW2ZpbGxdIEZpbGwgc3R5bGUuXG4gKiBAcHJvcGVydHkge251bWJlcn0gcmFkaXVzIENpcmNsZSByYWRpdXMuXG4gKiBAcHJvcGVydHkge2ltcG9ydChcIi4vU3Ryb2tlLmpzXCIpLmRlZmF1bHR9IFtzdHJva2VdIFN0cm9rZSBzdHlsZS5cbiAqIEBwcm9wZXJ0eSB7QXJyYXk8bnVtYmVyPn0gW2Rpc3BsYWNlbWVudD1bMCwwXV0gZGlzcGxhY2VtZW50XG4gKiBAcHJvcGVydHkge251bWJlcnxpbXBvcnQoXCIuLi9zaXplLmpzXCIpLlNpemV9IFtzY2FsZT0xXSBTY2FsZS4gQSB0d28gZGltZW5zaW9uYWwgc2NhbGUgd2lsbCBwcm9kdWNlIGFuIGVsbGlwc2UuXG4gKiBVbmxlc3MgdHdvIGRpbWVuc2lvbmFsIHNjYWxpbmcgaXMgcmVxdWlyZWQgYSBiZXR0ZXIgcmVzdWx0IG1heSBiZSBvYnRhaW5lZCB3aXRoIGFuIGFwcHJvcHJpYXRlIHNldHRpbmcgZm9yIGByYWRpdXNgLlxuICogQHByb3BlcnR5IHtudW1iZXJ9IFtyb3RhdGlvbj0wXSBSb3RhdGlvbiBpbiByYWRpYW5zXG4gKiAocG9zaXRpdmUgcm90YXRpb24gY2xvY2t3aXNlLCBtZWFuaW5nZnVsIG9ubHkgd2hlbiB1c2VkIGluIGNvbmp1bmN0aW9uIHdpdGggYSB0d28gZGltZW5zaW9uYWwgc2NhbGUpLlxuICogQHByb3BlcnR5IHtib29sZWFufSBbcm90YXRlV2l0aFZpZXc9ZmFsc2VdIFdoZXRoZXIgdG8gcm90YXRlIHRoZSBzaGFwZSB3aXRoIHRoZSB2aWV3XG4gKiAobWVhbmluZ2Z1bCBvbmx5IHdoZW4gdXNlZCBpbiBjb25qdW5jdGlvbiB3aXRoIGEgdHdvIGRpbWVuc2lvbmFsIHNjYWxlKS5cbiAqIEBwcm9wZXJ0eSB7XCJkZWNsdXR0ZXJcInxcIm9ic3RhY2xlXCJ8XCJub25lXCJ8dW5kZWZpbmVkfSBbZGVjbHV0dGVyTW9kZV0gRGVjbHV0dGVyIG1vZGVcbiAqL1xuXG4vKipcbiAqIEBjbGFzc2Rlc2NcbiAqIFNldCBjaXJjbGUgc3R5bGUgZm9yIHZlY3RvciBmZWF0dXJlcy5cbiAqIEBhcGlcbiAqL1xuY2xhc3MgQ2lyY2xlU3R5bGUgZXh0ZW5kcyBSZWd1bGFyU2hhcGUge1xuICAvKipcbiAgICogQHBhcmFtIHtPcHRpb25zfSBbb3B0aW9uc10gT3B0aW9ucy5cbiAgICovXG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0gb3B0aW9ucyA/IG9wdGlvbnMgOiB7cmFkaXVzOiA1fTtcblxuICAgIHN1cGVyKHtcbiAgICAgIHBvaW50czogSW5maW5pdHksXG4gICAgICBmaWxsOiBvcHRpb25zLmZpbGwsXG4gICAgICByYWRpdXM6IG9wdGlvbnMucmFkaXVzLFxuICAgICAgc3Ryb2tlOiBvcHRpb25zLnN0cm9rZSxcbiAgICAgIHNjYWxlOiBvcHRpb25zLnNjYWxlICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLnNjYWxlIDogMSxcbiAgICAgIHJvdGF0aW9uOiBvcHRpb25zLnJvdGF0aW9uICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLnJvdGF0aW9uIDogMCxcbiAgICAgIHJvdGF0ZVdpdGhWaWV3OlxuICAgICAgICBvcHRpb25zLnJvdGF0ZVdpdGhWaWV3ICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLnJvdGF0ZVdpdGhWaWV3IDogZmFsc2UsXG4gICAgICBkaXNwbGFjZW1lbnQ6XG4gICAgICAgIG9wdGlvbnMuZGlzcGxhY2VtZW50ICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLmRpc3BsYWNlbWVudCA6IFswLCAwXSxcbiAgICAgIGRlY2x1dHRlck1vZGU6IG9wdGlvbnMuZGVjbHV0dGVyTW9kZSxcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDbG9uZXMgdGhlIHN0eWxlLlxuICAgKiBAcmV0dXJuIHtDaXJjbGVTdHlsZX0gVGhlIGNsb25lZCBzdHlsZS5cbiAgICogQGFwaVxuICAgKi9cbiAgY2xvbmUoKSB7XG4gICAgY29uc3Qgc2NhbGUgPSB0aGlzLmdldFNjYWxlKCk7XG4gICAgY29uc3Qgc3R5bGUgPSBuZXcgQ2lyY2xlU3R5bGUoe1xuICAgICAgZmlsbDogdGhpcy5nZXRGaWxsKCkgPyB0aGlzLmdldEZpbGwoKS5jbG9uZSgpIDogdW5kZWZpbmVkLFxuICAgICAgc3Ryb2tlOiB0aGlzLmdldFN0cm9rZSgpID8gdGhpcy5nZXRTdHJva2UoKS5jbG9uZSgpIDogdW5kZWZpbmVkLFxuICAgICAgcmFkaXVzOiB0aGlzLmdldFJhZGl1cygpLFxuICAgICAgc2NhbGU6IEFycmF5LmlzQXJyYXkoc2NhbGUpID8gc2NhbGUuc2xpY2UoKSA6IHNjYWxlLFxuICAgICAgcm90YXRpb246IHRoaXMuZ2V0Um90YXRpb24oKSxcbiAgICAgIHJvdGF0ZVdpdGhWaWV3OiB0aGlzLmdldFJvdGF0ZVdpdGhWaWV3KCksXG4gICAgICBkaXNwbGFjZW1lbnQ6IHRoaXMuZ2V0RGlzcGxhY2VtZW50KCkuc2xpY2UoKSxcbiAgICAgIGRlY2x1dHRlck1vZGU6IHRoaXMuZ2V0RGVjbHV0dGVyTW9kZSgpLFxuICAgIH0pO1xuICAgIHN0eWxlLnNldE9wYWNpdHkodGhpcy5nZXRPcGFjaXR5KCkpO1xuICAgIHJldHVybiBzdHlsZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXQgdGhlIGNpcmNsZSByYWRpdXMuXG4gICAqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSByYWRpdXMgQ2lyY2xlIHJhZGl1cy5cbiAgICogQGFwaVxuICAgKi9cbiAgc2V0UmFkaXVzKHJhZGl1cykge1xuICAgIHRoaXMucmFkaXVzXyA9IHJhZGl1cztcbiAgICB0aGlzLnJlbmRlcigpO1xuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IENpcmNsZVN0eWxlO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///30283\n')},51345:function(__unused_webpack___webpack_module__,__webpack_exports__){eval('/**\n * @module ol/style/Fill\n */\n\n/**\n * @typedef {Object} Options\n * @property {import("../color.js").Color|import("../colorlike.js").ColorLike|null} [color=null] A color, gradient or pattern.\n * See {@link module:ol/color~Color} and {@link module:ol/colorlike~ColorLike} for possible formats.\n * Default null; if null, the Canvas/renderer default black will be used.\n */\n\n/**\n * @classdesc\n * Set fill style for vector features.\n * @api\n */\nclass Fill {\n  /**\n   * @param {Options} [options] Options.\n   */\n  constructor(options) {\n    options = options || {};\n\n    /**\n     * @private\n     * @type {import("../color.js").Color|import("../colorlike.js").ColorLike|null}\n     */\n    this.color_ = options.color !== undefined ? options.color : null;\n  }\n\n  /**\n   * Clones the style. The color is not cloned if it is an {@link module:ol/colorlike~ColorLike}.\n   * @return {Fill} The cloned style.\n   * @api\n   */\n  clone() {\n    const color = this.getColor();\n    return new Fill({\n      color: Array.isArray(color) ? color.slice() : color || undefined,\n    });\n  }\n\n  /**\n   * Get the fill color.\n   * @return {import("../color.js").Color|import("../colorlike.js").ColorLike|null} Color.\n   * @api\n   */\n  getColor() {\n    return this.color_;\n  }\n\n  /**\n   * Set the color.\n   *\n   * @param {import("../color.js").Color|import("../colorlike.js").ColorLike|null} color Color.\n   * @api\n   */\n  setColor(color) {\n    this.color_ = color;\n  }\n}\n\n/* harmony default export */ __webpack_exports__["Z"] = (Fill);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNTEzNDUuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGNBQWMsc0VBQXNFO0FBQ3BGLFFBQVEsNkJBQTZCLEtBQUsscUNBQXFDO0FBQy9FLGlCQUFpQjtBQUNqQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsU0FBUztBQUN0QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw0REFBNEQsb0NBQW9DO0FBQ2hHLGNBQWMsTUFBTTtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBLGNBQWMsc0VBQXNFO0FBQ3BGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYSxzRUFBc0U7QUFDbkY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHlEQUFlLElBQUksRUFBQyIsInNvdXJjZXMiOlsid2VicGFjazovL3Z1ZTMtd2VicGFjazUvLi9ub2RlX21vZHVsZXMvb2wvc3R5bGUvRmlsbC5qcz9iZDFhIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQG1vZHVsZSBvbC9zdHlsZS9GaWxsXG4gKi9cblxuLyoqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBPcHRpb25zXG4gKiBAcHJvcGVydHkge2ltcG9ydChcIi4uL2NvbG9yLmpzXCIpLkNvbG9yfGltcG9ydChcIi4uL2NvbG9ybGlrZS5qc1wiKS5Db2xvckxpa2V8bnVsbH0gW2NvbG9yPW51bGxdIEEgY29sb3IsIGdyYWRpZW50IG9yIHBhdHRlcm4uXG4gKiBTZWUge0BsaW5rIG1vZHVsZTpvbC9jb2xvcn5Db2xvcn0gYW5kIHtAbGluayBtb2R1bGU6b2wvY29sb3JsaWtlfkNvbG9yTGlrZX0gZm9yIHBvc3NpYmxlIGZvcm1hdHMuXG4gKiBEZWZhdWx0IG51bGw7IGlmIG51bGwsIHRoZSBDYW52YXMvcmVuZGVyZXIgZGVmYXVsdCBibGFjayB3aWxsIGJlIHVzZWQuXG4gKi9cblxuLyoqXG4gKiBAY2xhc3NkZXNjXG4gKiBTZXQgZmlsbCBzdHlsZSBmb3IgdmVjdG9yIGZlYXR1cmVzLlxuICogQGFwaVxuICovXG5jbGFzcyBGaWxsIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7T3B0aW9uc30gW29wdGlvbnNdIE9wdGlvbnMuXG4gICAqL1xuICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtpbXBvcnQoXCIuLi9jb2xvci5qc1wiKS5Db2xvcnxpbXBvcnQoXCIuLi9jb2xvcmxpa2UuanNcIikuQ29sb3JMaWtlfG51bGx9XG4gICAgICovXG4gICAgdGhpcy5jb2xvcl8gPSBvcHRpb25zLmNvbG9yICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLmNvbG9yIDogbnVsbDtcbiAgfVxuXG4gIC8qKlxuICAgKiBDbG9uZXMgdGhlIHN0eWxlLiBUaGUgY29sb3IgaXMgbm90IGNsb25lZCBpZiBpdCBpcyBhbiB7QGxpbmsgbW9kdWxlOm9sL2NvbG9ybGlrZX5Db2xvckxpa2V9LlxuICAgKiBAcmV0dXJuIHtGaWxsfSBUaGUgY2xvbmVkIHN0eWxlLlxuICAgKiBAYXBpXG4gICAqL1xuICBjbG9uZSgpIHtcbiAgICBjb25zdCBjb2xvciA9IHRoaXMuZ2V0Q29sb3IoKTtcbiAgICByZXR1cm4gbmV3IEZpbGwoe1xuICAgICAgY29sb3I6IEFycmF5LmlzQXJyYXkoY29sb3IpID8gY29sb3Iuc2xpY2UoKSA6IGNvbG9yIHx8IHVuZGVmaW5lZCxcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIGZpbGwgY29sb3IuXG4gICAqIEByZXR1cm4ge2ltcG9ydChcIi4uL2NvbG9yLmpzXCIpLkNvbG9yfGltcG9ydChcIi4uL2NvbG9ybGlrZS5qc1wiKS5Db2xvckxpa2V8bnVsbH0gQ29sb3IuXG4gICAqIEBhcGlcbiAgICovXG4gIGdldENvbG9yKCkge1xuICAgIHJldHVybiB0aGlzLmNvbG9yXztcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXQgdGhlIGNvbG9yLlxuICAgKlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL2NvbG9yLmpzXCIpLkNvbG9yfGltcG9ydChcIi4uL2NvbG9ybGlrZS5qc1wiKS5Db2xvckxpa2V8bnVsbH0gY29sb3IgQ29sb3IuXG4gICAqIEBhcGlcbiAgICovXG4gIHNldENvbG9yKGNvbG9yKSB7XG4gICAgdGhpcy5jb2xvcl8gPSBjb2xvcjtcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBGaWxsO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///51345\n')},81332:function(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__){eval("\n// EXPORTS\n__webpack_require__.d(__webpack_exports__, {\n  \"Z\": function() { return /* binding */ style_Icon; }\n});\n\n// EXTERNAL MODULE: ./node_modules/ol/events/EventType.js\nvar EventType = __webpack_require__(85487);\n// EXTERNAL MODULE: ./node_modules/ol/ImageState.js\nvar ImageState = __webpack_require__(70553);\n// EXTERNAL MODULE: ./node_modules/ol/style/Image.js\nvar style_Image = __webpack_require__(28443);\n// EXTERNAL MODULE: ./node_modules/ol/color.js\nvar color = __webpack_require__(79706);\n// EXTERNAL MODULE: ./node_modules/ol/asserts.js\nvar asserts = __webpack_require__(99515);\n// EXTERNAL MODULE: ./node_modules/ol/events/Target.js\nvar Target = __webpack_require__(208);\n// EXTERNAL MODULE: ./node_modules/ol/dom.js\nvar dom = __webpack_require__(68326);\n// EXTERNAL MODULE: ./node_modules/ol/style/IconImageCache.js\nvar IconImageCache = __webpack_require__(92710);\n// EXTERNAL MODULE: ./node_modules/ol/Image.js\nvar ol_Image = __webpack_require__(18096);\n;// CONCATENATED MODULE: ./node_modules/ol/style/IconImage.js\n/**\n * @module ol/style/IconImage\n */\n\n\n\n\n\n\n\n\n\n/**\n * @type {CanvasRenderingContext2D}\n */\nlet taintedTestContext = null;\n\nclass IconImage extends Target/* default */.Z {\n  /**\n   * @param {HTMLImageElement|HTMLCanvasElement} image Image.\n   * @param {string|undefined} src Src.\n   * @param {import(\"../size.js\").Size} size Size.\n   * @param {?string} crossOrigin Cross origin.\n   * @param {import(\"../ImageState.js\").default} imageState Image state.\n   * @param {import(\"../color.js\").Color} color Color.\n   */\n  constructor(image, src, size, crossOrigin, imageState, color) {\n    super();\n\n    /**\n     * @private\n     * @type {HTMLImageElement|HTMLCanvasElement}\n     */\n    this.hitDetectionImage_ = null;\n\n    /**\n     * @private\n     * @type {HTMLImageElement|HTMLCanvasElement}\n     */\n    this.image_ = image;\n\n    /**\n     * @private\n     * @type {string|null}\n     */\n    this.crossOrigin_ = crossOrigin;\n\n    /**\n     * @private\n     * @type {Object<number, HTMLCanvasElement>}\n     */\n    this.canvas_ = {};\n\n    /**\n     * @private\n     * @type {import(\"../color.js\").Color}\n     */\n    this.color_ = color;\n\n    /**\n     * @private\n     * @type {?function():void}\n     */\n    this.unlisten_ = null;\n\n    /**\n     * @private\n     * @type {import(\"../ImageState.js\").default}\n     */\n    this.imageState_ = imageState;\n\n    /**\n     * @private\n     * @type {import(\"../size.js\").Size}\n     */\n    this.size_ = size;\n\n    /**\n     * @private\n     * @type {string|undefined}\n     */\n    this.src_ = src;\n\n    /**\n     * @private\n     */\n    this.tainted_;\n  }\n\n  /**\n   * @private\n   */\n  initializeImage_() {\n    this.image_ = new Image();\n    if (this.crossOrigin_ !== null) {\n      this.image_.crossOrigin = this.crossOrigin_;\n    }\n  }\n\n  /**\n   * @private\n   * @return {boolean} The image canvas is tainted.\n   */\n  isTainted_() {\n    if (this.tainted_ === undefined && this.imageState_ === ImageState/* default.LOADED */.Z.LOADED) {\n      if (!taintedTestContext) {\n        taintedTestContext = (0,dom/* createCanvasContext2D */.E4)(1, 1, undefined, {\n          willReadFrequently: true,\n        });\n      }\n      taintedTestContext.drawImage(this.image_, 0, 0);\n      try {\n        taintedTestContext.getImageData(0, 0, 1, 1);\n        this.tainted_ = false;\n      } catch (e) {\n        taintedTestContext = null;\n        this.tainted_ = true;\n      }\n    }\n    return this.tainted_ === true;\n  }\n\n  /**\n   * @private\n   */\n  dispatchChangeEvent_() {\n    this.dispatchEvent(EventType/* default.CHANGE */.Z.CHANGE);\n  }\n\n  /**\n   * @private\n   */\n  handleImageError_() {\n    this.imageState_ = ImageState/* default.ERROR */.Z.ERROR;\n    this.unlistenImage_();\n    this.dispatchChangeEvent_();\n  }\n\n  /**\n   * @private\n   */\n  handleImageLoad_() {\n    this.imageState_ = ImageState/* default.LOADED */.Z.LOADED;\n    if (this.size_) {\n      this.image_.width = this.size_[0];\n      this.image_.height = this.size_[1];\n    } else {\n      this.size_ = [this.image_.width, this.image_.height];\n    }\n    this.unlistenImage_();\n    this.dispatchChangeEvent_();\n  }\n\n  /**\n   * @param {number} pixelRatio Pixel ratio.\n   * @return {HTMLImageElement|HTMLCanvasElement} Image or Canvas element.\n   */\n  getImage(pixelRatio) {\n    if (!this.image_) {\n      this.initializeImage_();\n    }\n    this.replaceColor_(pixelRatio);\n    return this.canvas_[pixelRatio] ? this.canvas_[pixelRatio] : this.image_;\n  }\n\n  /**\n   * @param {number} pixelRatio Pixel ratio.\n   * @return {number} Image or Canvas element.\n   */\n  getPixelRatio(pixelRatio) {\n    this.replaceColor_(pixelRatio);\n    return this.canvas_[pixelRatio] ? pixelRatio : 1;\n  }\n\n  /**\n   * @return {import(\"../ImageState.js\").default} Image state.\n   */\n  getImageState() {\n    return this.imageState_;\n  }\n\n  /**\n   * @return {HTMLImageElement|HTMLCanvasElement} Image element.\n   */\n  getHitDetectionImage() {\n    if (!this.image_) {\n      this.initializeImage_();\n    }\n    if (!this.hitDetectionImage_) {\n      if (this.isTainted_()) {\n        const width = this.size_[0];\n        const height = this.size_[1];\n        const context = (0,dom/* createCanvasContext2D */.E4)(width, height);\n        context.fillRect(0, 0, width, height);\n        this.hitDetectionImage_ = context.canvas;\n      } else {\n        this.hitDetectionImage_ = this.image_;\n      }\n    }\n    return this.hitDetectionImage_;\n  }\n\n  /**\n   * Get the size of the icon (in pixels).\n   * @return {import(\"../size.js\").Size} Image size.\n   */\n  getSize() {\n    return this.size_;\n  }\n\n  /**\n   * @return {string|undefined} Image src.\n   */\n  getSrc() {\n    return this.src_;\n  }\n\n  /**\n   * Load not yet loaded URI.\n   */\n  load() {\n    if (this.imageState_ !== ImageState/* default.IDLE */.Z.IDLE) {\n      return;\n    }\n    if (!this.image_) {\n      this.initializeImage_();\n    }\n\n    this.imageState_ = ImageState/* default.LOADING */.Z.LOADING;\n    try {\n      /** @type {HTMLImageElement} */ (this.image_).src = this.src_;\n    } catch (e) {\n      this.handleImageError_();\n    }\n    this.unlisten_ = (0,ol_Image/* listenImage */.K)(\n      this.image_,\n      this.handleImageLoad_.bind(this),\n      this.handleImageError_.bind(this)\n    );\n  }\n\n  /**\n   * @param {number} pixelRatio Pixel ratio.\n   * @private\n   */\n  replaceColor_(pixelRatio) {\n    if (\n      !this.color_ ||\n      this.canvas_[pixelRatio] ||\n      this.imageState_ !== ImageState/* default.LOADED */.Z.LOADED\n    ) {\n      return;\n    }\n\n    const image = this.image_;\n    const canvas = document.createElement('canvas');\n    canvas.width = Math.ceil(image.width * pixelRatio);\n    canvas.height = Math.ceil(image.height * pixelRatio);\n\n    const ctx = canvas.getContext('2d');\n    ctx.scale(pixelRatio, pixelRatio);\n    ctx.drawImage(image, 0, 0);\n\n    ctx.globalCompositeOperation = 'multiply';\n    ctx.fillStyle = (0,color/* asString */.XC)(this.color_);\n    ctx.fillRect(0, 0, canvas.width / pixelRatio, canvas.height / pixelRatio);\n\n    ctx.globalCompositeOperation = 'destination-in';\n    ctx.drawImage(image, 0, 0);\n\n    this.canvas_[pixelRatio] = canvas;\n  }\n\n  /**\n   * Discards event handlers which listen for load completion or errors.\n   *\n   * @private\n   */\n  unlistenImage_() {\n    if (this.unlisten_) {\n      this.unlisten_();\n      this.unlisten_ = null;\n    }\n  }\n}\n\n/**\n * @param {HTMLImageElement|HTMLCanvasElement} image Image.\n * @param {string} src Src.\n * @param {import(\"../size.js\").Size} size Size.\n * @param {?string} crossOrigin Cross origin.\n * @param {import(\"../ImageState.js\").default} imageState Image state.\n * @param {import(\"../color.js\").Color} color Color.\n * @return {IconImage} Icon image.\n */\nfunction get(image, src, size, crossOrigin, imageState, color) {\n  let iconImage = IconImageCache/* shared.get */.c.get(src, crossOrigin, color);\n  if (!iconImage) {\n    iconImage = new IconImage(image, src, size, crossOrigin, imageState, color);\n    IconImageCache/* shared.set */.c.set(src, crossOrigin, color, iconImage);\n  }\n  return iconImage;\n}\n\n/* harmony default export */ var style_IconImage = ((/* unused pure expression or super */ null && (IconImage)));\n\n// EXTERNAL MODULE: ./node_modules/ol/util.js\nvar util = __webpack_require__(74187);\n;// CONCATENATED MODULE: ./node_modules/ol/style/Icon.js\n/**\n * @module ol/style/Icon\n */\n\n\n\n\n\n\n\n\n/**\n * @typedef {'fraction' | 'pixels'} IconAnchorUnits\n * Anchor unit can be either a fraction of the icon size or in pixels.\n */\n\n/**\n * @typedef {'bottom-left' | 'bottom-right' | 'top-left' | 'top-right'} IconOrigin\n * Icon origin. One of 'bottom-left', 'bottom-right', 'top-left', 'top-right'.\n */\n\n/**\n * @typedef {Object} Options\n * @property {Array<number>} [anchor=[0.5, 0.5]] Anchor. Default value is the icon center.\n * @property {IconOrigin} [anchorOrigin='top-left'] Origin of the anchor: `bottom-left`, `bottom-right`,\n * `top-left` or `top-right`.\n * @property {IconAnchorUnits} [anchorXUnits='fraction'] Units in which the anchor x value is\n * specified. A value of `'fraction'` indicates the x value is a fraction of the icon. A value of `'pixels'` indicates\n * the x value in pixels.\n * @property {IconAnchorUnits} [anchorYUnits='fraction'] Units in which the anchor y value is\n * specified. A value of `'fraction'` indicates the y value is a fraction of the icon. A value of `'pixels'` indicates\n * the y value in pixels.\n * @property {import(\"../color.js\").Color|string} [color] Color to tint the icon. If not specified,\n * the icon will be left as is.\n * @property {null|string} [crossOrigin] The `crossOrigin` attribute for loaded images. Note that you must provide a\n * `crossOrigin` value if you want to access pixel data with the Canvas renderer.\n * See https://developer.mozilla.org/en-US/docs/Web/HTML/CORS_enabled_image for more detail.\n * @property {HTMLImageElement|HTMLCanvasElement} [img] Image object for the icon. If the `src` option is not provided then the\n * provided image must already be loaded. And in that case, it is required\n * to provide the size of the image, with the `imgSize` option.\n * @property {import(\"../size.js\").Size} [imgSize] Image size in pixels. Only required if `img` is set and `src` is not.\n * The provided `imgSize` needs to match the actual size of the image.\n * @property {Array<number>} [displacement=[0, 0]] Displacement of the icon in pixels.\n * Positive values will shift the icon right and up.\n * @property {number} [opacity=1] Opacity of the icon.\n * @property {number} [width] The width of the icon in pixels. This can't be used together with `scale`.\n * @property {number} [height] The height of the icon in pixels. This can't be used together with `scale`.\n * @property {number|import(\"../size.js\").Size} [scale=1] Scale.\n * @property {boolean} [rotateWithView=false] Whether to rotate the icon with the view.\n * @property {number} [rotation=0] Rotation in radians (positive rotation clockwise).\n * @property {Array<number>} [offset=[0, 0]] Offset which, together with `size` and `offsetOrigin`, defines the\n * sub-rectangle to use from the original (sprite) image.\n * @property {IconOrigin} [offsetOrigin='top-left'] Origin of the offset: `bottom-left`, `bottom-right`,\n * `top-left` or `top-right`.\n * @property {import(\"../size.js\").Size} [size] Icon size in pixels. Used together with `offset` to define the\n * sub-rectangle to use from the original (sprite) image.\n * @property {string} [src] Image source URI.\n * @property {\"declutter\"|\"obstacle\"|\"none\"|undefined} [declutterMode] Declutter mode.\n */\n\n/**\n * @classdesc\n * Set icon style for vector features.\n * @api\n */\nclass Icon extends style_Image/* default */.Z {\n  /**\n   * @param {Options} [options] Options.\n   */\n  constructor(options) {\n    options = options || {};\n\n    /**\n     * @type {number}\n     */\n    const opacity = options.opacity !== undefined ? options.opacity : 1;\n\n    /**\n     * @type {number}\n     */\n    const rotation = options.rotation !== undefined ? options.rotation : 0;\n\n    /**\n     * @type {number|import(\"../size.js\").Size}\n     */\n    const scale = options.scale !== undefined ? options.scale : 1;\n\n    /**\n     * @type {boolean}\n     */\n    const rotateWithView =\n      options.rotateWithView !== undefined ? options.rotateWithView : false;\n\n    super({\n      opacity: opacity,\n      rotation: rotation,\n      scale: scale,\n      displacement:\n        options.displacement !== undefined ? options.displacement : [0, 0],\n      rotateWithView: rotateWithView,\n      declutterMode: options.declutterMode,\n    });\n\n    /**\n     * @private\n     * @type {Array<number>}\n     */\n    this.anchor_ = options.anchor !== undefined ? options.anchor : [0.5, 0.5];\n\n    /**\n     * @private\n     * @type {Array<number>}\n     */\n    this.normalizedAnchor_ = null;\n\n    /**\n     * @private\n     * @type {IconOrigin}\n     */\n    this.anchorOrigin_ =\n      options.anchorOrigin !== undefined ? options.anchorOrigin : 'top-left';\n\n    /**\n     * @private\n     * @type {IconAnchorUnits}\n     */\n    this.anchorXUnits_ =\n      options.anchorXUnits !== undefined ? options.anchorXUnits : 'fraction';\n\n    /**\n     * @private\n     * @type {IconAnchorUnits}\n     */\n    this.anchorYUnits_ =\n      options.anchorYUnits !== undefined ? options.anchorYUnits : 'fraction';\n\n    /**\n     * @private\n     * @type {?string}\n     */\n    this.crossOrigin_ =\n      options.crossOrigin !== undefined ? options.crossOrigin : null;\n\n    /**\n     * @type {HTMLImageElement|HTMLCanvasElement}\n     */\n    const image = options.img !== undefined ? options.img : null;\n\n    /**\n     * @private\n     * @type {import(\"../size.js\").Size|undefined}\n     */\n    this.imgSize_ = options.imgSize;\n\n    /**\n     * @type {string|undefined}\n     */\n    let src = options.src;\n\n    (0,asserts/* assert */.h)(!(src !== undefined && image), 4); // `image` and `src` cannot be provided at the same time\n    (0,asserts/* assert */.h)(!image || (image && this.imgSize_), 5); // `imgSize` must be set when `image` is provided\n\n    if ((src === undefined || src.length === 0) && image) {\n      src = /** @type {HTMLImageElement} */ (image).src || (0,util/* getUid */.sq)(image);\n    }\n    (0,asserts/* assert */.h)(src !== undefined && src.length > 0, 6); // A defined and non-empty `src` or `image` must be provided\n\n    // `width` or `height` cannot be provided together with `scale`\n    (0,asserts/* assert */.h)(\n      !(\n        (options.width !== undefined || options.height !== undefined) &&\n        options.scale !== undefined\n      ),\n      69\n    );\n\n    /**\n     * @type {import(\"../ImageState.js\").default}\n     */\n    const imageState =\n      options.src !== undefined ? ImageState/* default.IDLE */.Z.IDLE : ImageState/* default.LOADED */.Z.LOADED;\n\n    /**\n     * @private\n     * @type {import(\"../color.js\").Color}\n     */\n    this.color_ = options.color !== undefined ? (0,color/* asArray */._2)(options.color) : null;\n\n    /**\n     * @private\n     * @type {import(\"./IconImage.js\").default}\n     */\n    this.iconImage_ = get(\n      image,\n      /** @type {string} */ (src),\n      this.imgSize_ !== undefined ? this.imgSize_ : null,\n      this.crossOrigin_,\n      imageState,\n      this.color_\n    );\n\n    /**\n     * @private\n     * @type {Array<number>}\n     */\n    this.offset_ = options.offset !== undefined ? options.offset : [0, 0];\n    /**\n     * @private\n     * @type {IconOrigin}\n     */\n    this.offsetOrigin_ =\n      options.offsetOrigin !== undefined ? options.offsetOrigin : 'top-left';\n\n    /**\n     * @private\n     * @type {Array<number>}\n     */\n    this.origin_ = null;\n\n    /**\n     * @private\n     * @type {import(\"../size.js\").Size}\n     */\n    this.size_ = options.size !== undefined ? options.size : null;\n\n    /**\n     * @type {number|undefined}\n     */\n    this.width_ = options.width;\n\n    /**\n     * @type {number|undefined}\n     */\n    this.height_ = options.height;\n\n    /**\n     * Recalculate the scale if width or height were given.\n     */\n    if (this.width_ !== undefined || this.height_ !== undefined) {\n      const image = this.getImage(1);\n      const setScale = () => {\n        this.updateScaleFromWidthAndHeight(this.width_, this.height_);\n      };\n      if (image.width > 0) {\n        this.updateScaleFromWidthAndHeight(this.width_, this.height_);\n      } else {\n        image.addEventListener('load', setScale);\n      }\n    }\n  }\n\n  /**\n   * Clones the style. The underlying Image/HTMLCanvasElement is not cloned.\n   * @return {Icon} The cloned style.\n   * @api\n   */\n  clone() {\n    let scale = this.getScale();\n    scale = Array.isArray(scale) ? scale.slice() : scale;\n    // if either width or height are defined, do not pass scale.\n    if (this.width_ !== undefined || this.height_ !== undefined) {\n      scale = undefined;\n    }\n    return new Icon({\n      anchor: this.anchor_.slice(),\n      anchorOrigin: this.anchorOrigin_,\n      anchorXUnits: this.anchorXUnits_,\n      anchorYUnits: this.anchorYUnits_,\n      color:\n        this.color_ && this.color_.slice\n          ? this.color_.slice()\n          : this.color_ || undefined,\n      crossOrigin: this.crossOrigin_,\n      imgSize: this.imgSize_,\n      offset: this.offset_.slice(),\n      offsetOrigin: this.offsetOrigin_,\n      opacity: this.getOpacity(),\n      rotateWithView: this.getRotateWithView(),\n      rotation: this.getRotation(),\n      scale: scale,\n      size: this.size_ !== null ? this.size_.slice() : undefined,\n      src: this.getSrc(),\n      displacement: this.getDisplacement().slice(),\n      declutterMode: this.getDeclutterMode(),\n      width: this.width_,\n      height: this.height_,\n    });\n  }\n\n  /**\n   * Set the scale of the Icon by calculating it from given width and height and the\n   * width and height of the image.\n   *\n   * @private\n   * @param {number} width The width.\n   * @param {number} height The height.\n   */\n  updateScaleFromWidthAndHeight(width, height) {\n    const image = this.getImage(1);\n    if (width !== undefined && height !== undefined) {\n      super.setScale([width / image.width, height / image.height]);\n    } else if (width !== undefined) {\n      super.setScale([width / image.width, width / image.width]);\n    } else if (height !== undefined) {\n      super.setScale([height / image.height, height / image.height]);\n    } else {\n      super.setScale([1, 1]);\n    }\n  }\n\n  /**\n   * Get the anchor point in pixels. The anchor determines the center point for the\n   * symbolizer.\n   * @return {Array<number>} Anchor.\n   * @api\n   */\n  getAnchor() {\n    let anchor = this.normalizedAnchor_;\n    if (!anchor) {\n      anchor = this.anchor_;\n      const size = this.getSize();\n      if (\n        this.anchorXUnits_ == 'fraction' ||\n        this.anchorYUnits_ == 'fraction'\n      ) {\n        if (!size) {\n          return null;\n        }\n        anchor = this.anchor_.slice();\n        if (this.anchorXUnits_ == 'fraction') {\n          anchor[0] *= size[0];\n        }\n        if (this.anchorYUnits_ == 'fraction') {\n          anchor[1] *= size[1];\n        }\n      }\n\n      if (this.anchorOrigin_ != 'top-left') {\n        if (!size) {\n          return null;\n        }\n        if (anchor === this.anchor_) {\n          anchor = this.anchor_.slice();\n        }\n        if (\n          this.anchorOrigin_ == 'top-right' ||\n          this.anchorOrigin_ == 'bottom-right'\n        ) {\n          anchor[0] = -anchor[0] + size[0];\n        }\n        if (\n          this.anchorOrigin_ == 'bottom-left' ||\n          this.anchorOrigin_ == 'bottom-right'\n        ) {\n          anchor[1] = -anchor[1] + size[1];\n        }\n      }\n      this.normalizedAnchor_ = anchor;\n    }\n    const displacement = this.getDisplacement();\n    const scale = this.getScaleArray();\n    // anchor is scaled by renderer but displacement should not be scaled\n    // so divide by scale here\n    return [\n      anchor[0] - displacement[0] / scale[0],\n      anchor[1] + displacement[1] / scale[1],\n    ];\n  }\n\n  /**\n   * Set the anchor point. The anchor determines the center point for the\n   * symbolizer.\n   *\n   * @param {Array<number>} anchor Anchor.\n   * @api\n   */\n  setAnchor(anchor) {\n    this.anchor_ = anchor;\n    this.normalizedAnchor_ = null;\n  }\n\n  /**\n   * Get the icon color.\n   * @return {import(\"../color.js\").Color} Color.\n   * @api\n   */\n  getColor() {\n    return this.color_;\n  }\n\n  /**\n   * Get the image icon.\n   * @param {number} pixelRatio Pixel ratio.\n   * @return {HTMLImageElement|HTMLCanvasElement} Image or Canvas element.\n   * @api\n   */\n  getImage(pixelRatio) {\n    return this.iconImage_.getImage(pixelRatio);\n  }\n\n  /**\n   * Get the pixel ratio.\n   * @param {number} pixelRatio Pixel ratio.\n   * @return {number} The pixel ratio of the image.\n   * @api\n   */\n  getPixelRatio(pixelRatio) {\n    return this.iconImage_.getPixelRatio(pixelRatio);\n  }\n\n  /**\n   * @return {import(\"../size.js\").Size} Image size.\n   */\n  getImageSize() {\n    return this.iconImage_.getSize();\n  }\n\n  /**\n   * @return {import(\"../ImageState.js\").default} Image state.\n   */\n  getImageState() {\n    return this.iconImage_.getImageState();\n  }\n\n  /**\n   * @return {HTMLImageElement|HTMLCanvasElement} Image element.\n   */\n  getHitDetectionImage() {\n    return this.iconImage_.getHitDetectionImage();\n  }\n\n  /**\n   * Get the origin of the symbolizer.\n   * @return {Array<number>} Origin.\n   * @api\n   */\n  getOrigin() {\n    if (this.origin_) {\n      return this.origin_;\n    }\n    let offset = this.offset_;\n\n    if (this.offsetOrigin_ != 'top-left') {\n      const size = this.getSize();\n      const iconImageSize = this.iconImage_.getSize();\n      if (!size || !iconImageSize) {\n        return null;\n      }\n      offset = offset.slice();\n      if (\n        this.offsetOrigin_ == 'top-right' ||\n        this.offsetOrigin_ == 'bottom-right'\n      ) {\n        offset[0] = iconImageSize[0] - size[0] - offset[0];\n      }\n      if (\n        this.offsetOrigin_ == 'bottom-left' ||\n        this.offsetOrigin_ == 'bottom-right'\n      ) {\n        offset[1] = iconImageSize[1] - size[1] - offset[1];\n      }\n    }\n    this.origin_ = offset;\n    return this.origin_;\n  }\n\n  /**\n   * Get the image URL.\n   * @return {string|undefined} Image src.\n   * @api\n   */\n  getSrc() {\n    return this.iconImage_.getSrc();\n  }\n\n  /**\n   * Get the size of the icon (in pixels).\n   * @return {import(\"../size.js\").Size} Image size.\n   * @api\n   */\n  getSize() {\n    return !this.size_ ? this.iconImage_.getSize() : this.size_;\n  }\n\n  /**\n   * Get the width of the icon (in pixels).\n   * @return {number} Icon width (in pixels).\n   * @api\n   */\n  getWidth() {\n    return this.width_;\n  }\n\n  /**\n   * Get the height of the icon (in pixels).\n   * @return {number} Icon height (in pixels).\n   * @api\n   */\n  getHeight() {\n    return this.height_;\n  }\n\n  /**\n   * Set the width of the icon in pixels.\n   *\n   * @param {number} width The width to set.\n   */\n  setWidth(width) {\n    this.width_ = width;\n    this.updateScaleFromWidthAndHeight(width, this.height_);\n  }\n\n  /**\n   * Set the height of the icon in pixels.\n   *\n   * @param {number} height The height to set.\n   */\n  setHeight(height) {\n    this.height_ = height;\n    this.updateScaleFromWidthAndHeight(this.width_, height);\n  }\n\n  /**\n   * Set the scale and updates the width and height correspondingly.\n   *\n   * @param {number|import(\"../size.js\").Size} scale Scale.\n   * @override\n   * @api\n   */\n  setScale(scale) {\n    super.setScale(scale);\n    const image = this.getImage(1);\n    if (image) {\n      const widthScale = Array.isArray(scale) ? scale[0] : scale;\n      if (widthScale !== undefined) {\n        this.width_ = widthScale * image.width;\n      }\n      const heightScale = Array.isArray(scale) ? scale[1] : scale;\n      if (heightScale !== undefined) {\n        this.height_ = heightScale * image.height;\n      }\n    }\n  }\n\n  /**\n   * @param {function(import(\"../events/Event.js\").default): void} listener Listener function.\n   */\n  listenImageChange(listener) {\n    this.iconImage_.addEventListener(EventType/* default.CHANGE */.Z.CHANGE, listener);\n  }\n\n  /**\n   * Load not yet loaded URI.\n   * When rendering a feature with an icon style, the vector renderer will\n   * automatically call this method. However, you might want to call this\n   * method yourself for preloading or other purposes.\n   * @api\n   */\n  load() {\n    this.iconImage_.load();\n  }\n\n  /**\n   * @param {function(import(\"../events/Event.js\").default): void} listener Listener function.\n   */\n  unlistenImageChange(listener) {\n    this.iconImage_.removeEventListener(EventType/* default.CHANGE */.Z.CHANGE, listener);\n  }\n}\n\n/* harmony default export */ var style_Icon = (Icon);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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Q0E7O0FBRUE7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBOztBQUVBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7O0FBRUE7QUFDQSxjQUFjO0FBQ2Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsY0FBYyxNQUFNO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsY0FBYyxlQUFlO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxlQUFlO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsY0FBYyw2QkFBNkI7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGNBQWMsb0NBQW9DO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixjQUFjLFFBQVE7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGNBQWMsMkJBQTJCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsY0FBYyxvQ0FBb0M7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxjQUFjLG9DQUFvQztBQUNsRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsY0FBYyxlQUFlO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGNBQWMsa0JBQWtCO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGNBQWMsMkJBQTJCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGNBQWMsUUFBUTtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxjQUFjLFFBQVE7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLGtDQUFrQztBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsYUFBYSxzREFBc0Q7QUFDbkU7QUFDQTtBQUNBLHFDQUFxQyxzQ0FBZ0I7QUFDckQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxhQUFhLHNEQUFzRDtBQUNuRTtBQUNBO0FBQ0Esd0NBQXdDLHNDQUFnQjtBQUN4RDtBQUNBOztBQUVBLCtDQUFlLElBQUksRUFBQyIsInNvdXJjZXMiOlsid2VicGFjazovL3Z1ZTMtd2VicGFjazUvLi9ub2RlX21vZHVsZXMvb2wvc3R5bGUvSWNvbkltYWdlLmpzP2FhNjMiLCJ3ZWJwYWNrOi8vdnVlMy13ZWJwYWNrNS8uL25vZGVfbW9kdWxlcy9vbC9zdHlsZS9JY29uLmpzPzc2YjYiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAbW9kdWxlIG9sL3N0eWxlL0ljb25JbWFnZVxuICovXG5cbmltcG9ydCBFdmVudFRhcmdldCBmcm9tICcuLi9ldmVudHMvVGFyZ2V0LmpzJztcbmltcG9ydCBFdmVudFR5cGUgZnJvbSAnLi4vZXZlbnRzL0V2ZW50VHlwZS5qcyc7XG5pbXBvcnQgSW1hZ2VTdGF0ZSBmcm9tICcuLi9JbWFnZVN0YXRlLmpzJztcbmltcG9ydCB7YXNTdHJpbmd9IGZyb20gJy4uL2NvbG9yLmpzJztcbmltcG9ydCB7Y3JlYXRlQ2FudmFzQ29udGV4dDJEfSBmcm9tICcuLi9kb20uanMnO1xuaW1wb3J0IHtzaGFyZWQgYXMgaWNvbkltYWdlQ2FjaGV9IGZyb20gJy4vSWNvbkltYWdlQ2FjaGUuanMnO1xuaW1wb3J0IHtsaXN0ZW5JbWFnZX0gZnJvbSAnLi4vSW1hZ2UuanMnO1xuXG4vKipcbiAqIEB0eXBlIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9XG4gKi9cbmxldCB0YWludGVkVGVzdENvbnRleHQgPSBudWxsO1xuXG5jbGFzcyBJY29uSW1hZ2UgZXh0ZW5kcyBFdmVudFRhcmdldCB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge0hUTUxJbWFnZUVsZW1lbnR8SFRNTENhbnZhc0VsZW1lbnR9IGltYWdlIEltYWdlLlxuICAgKiBAcGFyYW0ge3N0cmluZ3x1bmRlZmluZWR9IHNyYyBTcmMuXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vc2l6ZS5qc1wiKS5TaXplfSBzaXplIFNpemUuXG4gICAqIEBwYXJhbSB7P3N0cmluZ30gY3Jvc3NPcmlnaW4gQ3Jvc3Mgb3JpZ2luLlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL0ltYWdlU3RhdGUuanNcIikuZGVmYXVsdH0gaW1hZ2VTdGF0ZSBJbWFnZSBzdGF0ZS5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9jb2xvci5qc1wiKS5Db2xvcn0gY29sb3IgQ29sb3IuXG4gICAqL1xuICBjb25zdHJ1Y3RvcihpbWFnZSwgc3JjLCBzaXplLCBjcm9zc09yaWdpbiwgaW1hZ2VTdGF0ZSwgY29sb3IpIHtcbiAgICBzdXBlcigpO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7SFRNTEltYWdlRWxlbWVudHxIVE1MQ2FudmFzRWxlbWVudH1cbiAgICAgKi9cbiAgICB0aGlzLmhpdERldGVjdGlvbkltYWdlXyA9IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtIVE1MSW1hZ2VFbGVtZW50fEhUTUxDYW52YXNFbGVtZW50fVxuICAgICAqL1xuICAgIHRoaXMuaW1hZ2VfID0gaW1hZ2U7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtzdHJpbmd8bnVsbH1cbiAgICAgKi9cbiAgICB0aGlzLmNyb3NzT3JpZ2luXyA9IGNyb3NzT3JpZ2luO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7T2JqZWN0PG51bWJlciwgSFRNTENhbnZhc0VsZW1lbnQ+fVxuICAgICAqL1xuICAgIHRoaXMuY2FudmFzXyA9IHt9O1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7aW1wb3J0KFwiLi4vY29sb3IuanNcIikuQ29sb3J9XG4gICAgICovXG4gICAgdGhpcy5jb2xvcl8gPSBjb2xvcjtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUgez9mdW5jdGlvbigpOnZvaWR9XG4gICAgICovXG4gICAgdGhpcy51bmxpc3Rlbl8gPSBudWxsO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7aW1wb3J0KFwiLi4vSW1hZ2VTdGF0ZS5qc1wiKS5kZWZhdWx0fVxuICAgICAqL1xuICAgIHRoaXMuaW1hZ2VTdGF0ZV8gPSBpbWFnZVN0YXRlO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7aW1wb3J0KFwiLi4vc2l6ZS5qc1wiKS5TaXplfVxuICAgICAqL1xuICAgIHRoaXMuc2l6ZV8gPSBzaXplO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7c3RyaW5nfHVuZGVmaW5lZH1cbiAgICAgKi9cbiAgICB0aGlzLnNyY18gPSBzcmM7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMudGFpbnRlZF87XG4gIH1cblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGluaXRpYWxpemVJbWFnZV8oKSB7XG4gICAgdGhpcy5pbWFnZV8gPSBuZXcgSW1hZ2UoKTtcbiAgICBpZiAodGhpcy5jcm9zc09yaWdpbl8gIT09IG51bGwpIHtcbiAgICAgIHRoaXMuaW1hZ2VfLmNyb3NzT3JpZ2luID0gdGhpcy5jcm9zc09yaWdpbl87XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IFRoZSBpbWFnZSBjYW52YXMgaXMgdGFpbnRlZC5cbiAgICovXG4gIGlzVGFpbnRlZF8oKSB7XG4gICAgaWYgKHRoaXMudGFpbnRlZF8gPT09IHVuZGVmaW5lZCAmJiB0aGlzLmltYWdlU3RhdGVfID09PSBJbWFnZVN0YXRlLkxPQURFRCkge1xuICAgICAgaWYgKCF0YWludGVkVGVzdENvbnRleHQpIHtcbiAgICAgICAgdGFpbnRlZFRlc3RDb250ZXh0ID0gY3JlYXRlQ2FudmFzQ29udGV4dDJEKDEsIDEsIHVuZGVmaW5lZCwge1xuICAgICAgICAgIHdpbGxSZWFkRnJlcXVlbnRseTogdHJ1ZSxcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICB0YWludGVkVGVzdENvbnRleHQuZHJhd0ltYWdlKHRoaXMuaW1hZ2VfLCAwLCAwKTtcbiAgICAgIHRyeSB7XG4gICAgICAgIHRhaW50ZWRUZXN0Q29udGV4dC5nZXRJbWFnZURhdGEoMCwgMCwgMSwgMSk7XG4gICAgICAgIHRoaXMudGFpbnRlZF8gPSBmYWxzZTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgdGFpbnRlZFRlc3RDb250ZXh0ID0gbnVsbDtcbiAgICAgICAgdGhpcy50YWludGVkXyA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0aGlzLnRhaW50ZWRfID09PSB0cnVlO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBkaXNwYXRjaENoYW5nZUV2ZW50XygpIHtcbiAgICB0aGlzLmRpc3BhdGNoRXZlbnQoRXZlbnRUeXBlLkNIQU5HRSk7XG4gIH1cblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGhhbmRsZUltYWdlRXJyb3JfKCkge1xuICAgIHRoaXMuaW1hZ2VTdGF0ZV8gPSBJbWFnZVN0YXRlLkVSUk9SO1xuICAgIHRoaXMudW5saXN0ZW5JbWFnZV8oKTtcbiAgICB0aGlzLmRpc3BhdGNoQ2hhbmdlRXZlbnRfKCk7XG4gIH1cblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGhhbmRsZUltYWdlTG9hZF8oKSB7XG4gICAgdGhpcy5pbWFnZVN0YXRlXyA9IEltYWdlU3RhdGUuTE9BREVEO1xuICAgIGlmICh0aGlzLnNpemVfKSB7XG4gICAgICB0aGlzLmltYWdlXy53aWR0aCA9IHRoaXMuc2l6ZV9bMF07XG4gICAgICB0aGlzLmltYWdlXy5oZWlnaHQgPSB0aGlzLnNpemVfWzFdO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnNpemVfID0gW3RoaXMuaW1hZ2VfLndpZHRoLCB0aGlzLmltYWdlXy5oZWlnaHRdO1xuICAgIH1cbiAgICB0aGlzLnVubGlzdGVuSW1hZ2VfKCk7XG4gICAgdGhpcy5kaXNwYXRjaENoYW5nZUV2ZW50XygpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBwaXhlbFJhdGlvIFBpeGVsIHJhdGlvLlxuICAgKiBAcmV0dXJuIHtIVE1MSW1hZ2VFbGVtZW50fEhUTUxDYW52YXNFbGVtZW50fSBJbWFnZSBvciBDYW52YXMgZWxlbWVudC5cbiAgICovXG4gIGdldEltYWdlKHBpeGVsUmF0aW8pIHtcbiAgICBpZiAoIXRoaXMuaW1hZ2VfKSB7XG4gICAgICB0aGlzLmluaXRpYWxpemVJbWFnZV8oKTtcbiAgICB9XG4gICAgdGhpcy5yZXBsYWNlQ29sb3JfKHBpeGVsUmF0aW8pO1xuICAgIHJldHVybiB0aGlzLmNhbnZhc19bcGl4ZWxSYXRpb10gPyB0aGlzLmNhbnZhc19bcGl4ZWxSYXRpb10gOiB0aGlzLmltYWdlXztcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge251bWJlcn0gcGl4ZWxSYXRpbyBQaXhlbCByYXRpby5cbiAgICogQHJldHVybiB7bnVtYmVyfSBJbWFnZSBvciBDYW52YXMgZWxlbWVudC5cbiAgICovXG4gIGdldFBpeGVsUmF0aW8ocGl4ZWxSYXRpbykge1xuICAgIHRoaXMucmVwbGFjZUNvbG9yXyhwaXhlbFJhdGlvKTtcbiAgICByZXR1cm4gdGhpcy5jYW52YXNfW3BpeGVsUmF0aW9dID8gcGl4ZWxSYXRpbyA6IDE7XG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7aW1wb3J0KFwiLi4vSW1hZ2VTdGF0ZS5qc1wiKS5kZWZhdWx0fSBJbWFnZSBzdGF0ZS5cbiAgICovXG4gIGdldEltYWdlU3RhdGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuaW1hZ2VTdGF0ZV87XG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7SFRNTEltYWdlRWxlbWVudHxIVE1MQ2FudmFzRWxlbWVudH0gSW1hZ2UgZWxlbWVudC5cbiAgICovXG4gIGdldEhpdERldGVjdGlvbkltYWdlKCkge1xuICAgIGlmICghdGhpcy5pbWFnZV8pIHtcbiAgICAgIHRoaXMuaW5pdGlhbGl6ZUltYWdlXygpO1xuICAgIH1cbiAgICBpZiAoIXRoaXMuaGl0RGV0ZWN0aW9uSW1hZ2VfKSB7XG4gICAgICBpZiAodGhpcy5pc1RhaW50ZWRfKCkpIHtcbiAgICAgICAgY29uc3Qgd2lkdGggPSB0aGlzLnNpemVfWzBdO1xuICAgICAgICBjb25zdCBoZWlnaHQgPSB0aGlzLnNpemVfWzFdO1xuICAgICAgICBjb25zdCBjb250ZXh0ID0gY3JlYXRlQ2FudmFzQ29udGV4dDJEKHdpZHRoLCBoZWlnaHQpO1xuICAgICAgICBjb250ZXh0LmZpbGxSZWN0KDAsIDAsIHdpZHRoLCBoZWlnaHQpO1xuICAgICAgICB0aGlzLmhpdERldGVjdGlvbkltYWdlXyA9IGNvbnRleHQuY2FudmFzO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5oaXREZXRlY3Rpb25JbWFnZV8gPSB0aGlzLmltYWdlXztcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuaGl0RGV0ZWN0aW9uSW1hZ2VfO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgc2l6ZSBvZiB0aGUgaWNvbiAoaW4gcGl4ZWxzKS5cbiAgICogQHJldHVybiB7aW1wb3J0KFwiLi4vc2l6ZS5qc1wiKS5TaXplfSBJbWFnZSBzaXplLlxuICAgKi9cbiAgZ2V0U2l6ZSgpIHtcbiAgICByZXR1cm4gdGhpcy5zaXplXztcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtzdHJpbmd8dW5kZWZpbmVkfSBJbWFnZSBzcmMuXG4gICAqL1xuICBnZXRTcmMoKSB7XG4gICAgcmV0dXJuIHRoaXMuc3JjXztcbiAgfVxuXG4gIC8qKlxuICAgKiBMb2FkIG5vdCB5ZXQgbG9hZGVkIFVSSS5cbiAgICovXG4gIGxvYWQoKSB7XG4gICAgaWYgKHRoaXMuaW1hZ2VTdGF0ZV8gIT09IEltYWdlU3RhdGUuSURMRSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoIXRoaXMuaW1hZ2VfKSB7XG4gICAgICB0aGlzLmluaXRpYWxpemVJbWFnZV8oKTtcbiAgICB9XG5cbiAgICB0aGlzLmltYWdlU3RhdGVfID0gSW1hZ2VTdGF0ZS5MT0FESU5HO1xuICAgIHRyeSB7XG4gICAgICAvKiogQHR5cGUge0hUTUxJbWFnZUVsZW1lbnR9ICovICh0aGlzLmltYWdlXykuc3JjID0gdGhpcy5zcmNfO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHRoaXMuaGFuZGxlSW1hZ2VFcnJvcl8oKTtcbiAgICB9XG4gICAgdGhpcy51bmxpc3Rlbl8gPSBsaXN0ZW5JbWFnZShcbiAgICAgIHRoaXMuaW1hZ2VfLFxuICAgICAgdGhpcy5oYW5kbGVJbWFnZUxvYWRfLmJpbmQodGhpcyksXG4gICAgICB0aGlzLmhhbmRsZUltYWdlRXJyb3JfLmJpbmQodGhpcylcbiAgICApO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBwaXhlbFJhdGlvIFBpeGVsIHJhdGlvLlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgcmVwbGFjZUNvbG9yXyhwaXhlbFJhdGlvKSB7XG4gICAgaWYgKFxuICAgICAgIXRoaXMuY29sb3JfIHx8XG4gICAgICB0aGlzLmNhbnZhc19bcGl4ZWxSYXRpb10gfHxcbiAgICAgIHRoaXMuaW1hZ2VTdGF0ZV8gIT09IEltYWdlU3RhdGUuTE9BREVEXG4gICAgKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3QgaW1hZ2UgPSB0aGlzLmltYWdlXztcbiAgICBjb25zdCBjYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKTtcbiAgICBjYW52YXMud2lkdGggPSBNYXRoLmNlaWwoaW1hZ2Uud2lkdGggKiBwaXhlbFJhdGlvKTtcbiAgICBjYW52YXMuaGVpZ2h0ID0gTWF0aC5jZWlsKGltYWdlLmhlaWdodCAqIHBpeGVsUmF0aW8pO1xuXG4gICAgY29uc3QgY3R4ID0gY2FudmFzLmdldENvbnRleHQoJzJkJyk7XG4gICAgY3R4LnNjYWxlKHBpeGVsUmF0aW8sIHBpeGVsUmF0aW8pO1xuICAgIGN0eC5kcmF3SW1hZ2UoaW1hZ2UsIDAsIDApO1xuXG4gICAgY3R4Lmdsb2JhbENvbXBvc2l0ZU9wZXJhdGlvbiA9ICdtdWx0aXBseSc7XG4gICAgY3R4LmZpbGxTdHlsZSA9IGFzU3RyaW5nKHRoaXMuY29sb3JfKTtcbiAgICBjdHguZmlsbFJlY3QoMCwgMCwgY2FudmFzLndpZHRoIC8gcGl4ZWxSYXRpbywgY2FudmFzLmhlaWdodCAvIHBpeGVsUmF0aW8pO1xuXG4gICAgY3R4Lmdsb2JhbENvbXBvc2l0ZU9wZXJhdGlvbiA9ICdkZXN0aW5hdGlvbi1pbic7XG4gICAgY3R4LmRyYXdJbWFnZShpbWFnZSwgMCwgMCk7XG5cbiAgICB0aGlzLmNhbnZhc19bcGl4ZWxSYXRpb10gPSBjYW52YXM7XG4gIH1cblxuICAvKipcbiAgICogRGlzY2FyZHMgZXZlbnQgaGFuZGxlcnMgd2hpY2ggbGlzdGVuIGZvciBsb2FkIGNvbXBsZXRpb24gb3IgZXJyb3JzLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgdW5saXN0ZW5JbWFnZV8oKSB7XG4gICAgaWYgKHRoaXMudW5saXN0ZW5fKSB7XG4gICAgICB0aGlzLnVubGlzdGVuXygpO1xuICAgICAgdGhpcy51bmxpc3Rlbl8gPSBudWxsO1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIEBwYXJhbSB7SFRNTEltYWdlRWxlbWVudHxIVE1MQ2FudmFzRWxlbWVudH0gaW1hZ2UgSW1hZ2UuXG4gKiBAcGFyYW0ge3N0cmluZ30gc3JjIFNyYy5cbiAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vc2l6ZS5qc1wiKS5TaXplfSBzaXplIFNpemUuXG4gKiBAcGFyYW0gez9zdHJpbmd9IGNyb3NzT3JpZ2luIENyb3NzIG9yaWdpbi5cbiAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vSW1hZ2VTdGF0ZS5qc1wiKS5kZWZhdWx0fSBpbWFnZVN0YXRlIEltYWdlIHN0YXRlLlxuICogQHBhcmFtIHtpbXBvcnQoXCIuLi9jb2xvci5qc1wiKS5Db2xvcn0gY29sb3IgQ29sb3IuXG4gKiBAcmV0dXJuIHtJY29uSW1hZ2V9IEljb24gaW1hZ2UuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXQoaW1hZ2UsIHNyYywgc2l6ZSwgY3Jvc3NPcmlnaW4sIGltYWdlU3RhdGUsIGNvbG9yKSB7XG4gIGxldCBpY29uSW1hZ2UgPSBpY29uSW1hZ2VDYWNoZS5nZXQoc3JjLCBjcm9zc09yaWdpbiwgY29sb3IpO1xuICBpZiAoIWljb25JbWFnZSkge1xuICAgIGljb25JbWFnZSA9IG5ldyBJY29uSW1hZ2UoaW1hZ2UsIHNyYywgc2l6ZSwgY3Jvc3NPcmlnaW4sIGltYWdlU3RhdGUsIGNvbG9yKTtcbiAgICBpY29uSW1hZ2VDYWNoZS5zZXQoc3JjLCBjcm9zc09yaWdpbiwgY29sb3IsIGljb25JbWFnZSk7XG4gIH1cbiAgcmV0dXJuIGljb25JbWFnZTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgSWNvbkltYWdlO1xuIiwiLyoqXG4gKiBAbW9kdWxlIG9sL3N0eWxlL0ljb25cbiAqL1xuaW1wb3J0IEV2ZW50VHlwZSBmcm9tICcuLi9ldmVudHMvRXZlbnRUeXBlLmpzJztcbmltcG9ydCBJbWFnZVN0YXRlIGZyb20gJy4uL0ltYWdlU3RhdGUuanMnO1xuaW1wb3J0IEltYWdlU3R5bGUgZnJvbSAnLi9JbWFnZS5qcyc7XG5pbXBvcnQge2FzQXJyYXl9IGZyb20gJy4uL2NvbG9yLmpzJztcbmltcG9ydCB7YXNzZXJ0fSBmcm9tICcuLi9hc3NlcnRzLmpzJztcbmltcG9ydCB7Z2V0IGFzIGdldEljb25JbWFnZX0gZnJvbSAnLi9JY29uSW1hZ2UuanMnO1xuaW1wb3J0IHtnZXRVaWR9IGZyb20gJy4uL3V0aWwuanMnO1xuXG4vKipcbiAqIEB0eXBlZGVmIHsnZnJhY3Rpb24nIHwgJ3BpeGVscyd9IEljb25BbmNob3JVbml0c1xuICogQW5jaG9yIHVuaXQgY2FuIGJlIGVpdGhlciBhIGZyYWN0aW9uIG9mIHRoZSBpY29uIHNpemUgb3IgaW4gcGl4ZWxzLlxuICovXG5cbi8qKlxuICogQHR5cGVkZWYgeydib3R0b20tbGVmdCcgfCAnYm90dG9tLXJpZ2h0JyB8ICd0b3AtbGVmdCcgfCAndG9wLXJpZ2h0J30gSWNvbk9yaWdpblxuICogSWNvbiBvcmlnaW4uIE9uZSBvZiAnYm90dG9tLWxlZnQnLCAnYm90dG9tLXJpZ2h0JywgJ3RvcC1sZWZ0JywgJ3RvcC1yaWdodCcuXG4gKi9cblxuLyoqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBPcHRpb25zXG4gKiBAcHJvcGVydHkge0FycmF5PG51bWJlcj59IFthbmNob3I9WzAuNSwgMC41XV0gQW5jaG9yLiBEZWZhdWx0IHZhbHVlIGlzIHRoZSBpY29uIGNlbnRlci5cbiAqIEBwcm9wZXJ0eSB7SWNvbk9yaWdpbn0gW2FuY2hvck9yaWdpbj0ndG9wLWxlZnQnXSBPcmlnaW4gb2YgdGhlIGFuY2hvcjogYGJvdHRvbS1sZWZ0YCwgYGJvdHRvbS1yaWdodGAsXG4gKiBgdG9wLWxlZnRgIG9yIGB0b3AtcmlnaHRgLlxuICogQHByb3BlcnR5IHtJY29uQW5jaG9yVW5pdHN9IFthbmNob3JYVW5pdHM9J2ZyYWN0aW9uJ10gVW5pdHMgaW4gd2hpY2ggdGhlIGFuY2hvciB4IHZhbHVlIGlzXG4gKiBzcGVjaWZpZWQuIEEgdmFsdWUgb2YgYCdmcmFjdGlvbidgIGluZGljYXRlcyB0aGUgeCB2YWx1ZSBpcyBhIGZyYWN0aW9uIG9mIHRoZSBpY29uLiBBIHZhbHVlIG9mIGAncGl4ZWxzJ2AgaW5kaWNhdGVzXG4gKiB0aGUgeCB2YWx1ZSBpbiBwaXhlbHMuXG4gKiBAcHJvcGVydHkge0ljb25BbmNob3JVbml0c30gW2FuY2hvcllVbml0cz0nZnJhY3Rpb24nXSBVbml0cyBpbiB3aGljaCB0aGUgYW5jaG9yIHkgdmFsdWUgaXNcbiAqIHNwZWNpZmllZC4gQSB2YWx1ZSBvZiBgJ2ZyYWN0aW9uJ2AgaW5kaWNhdGVzIHRoZSB5IHZhbHVlIGlzIGEgZnJhY3Rpb24gb2YgdGhlIGljb24uIEEgdmFsdWUgb2YgYCdwaXhlbHMnYCBpbmRpY2F0ZXNcbiAqIHRoZSB5IHZhbHVlIGluIHBpeGVscy5cbiAqIEBwcm9wZXJ0eSB7aW1wb3J0KFwiLi4vY29sb3IuanNcIikuQ29sb3J8c3RyaW5nfSBbY29sb3JdIENvbG9yIHRvIHRpbnQgdGhlIGljb24uIElmIG5vdCBzcGVjaWZpZWQsXG4gKiB0aGUgaWNvbiB3aWxsIGJlIGxlZnQgYXMgaXMuXG4gKiBAcHJvcGVydHkge251bGx8c3RyaW5nfSBbY3Jvc3NPcmlnaW5dIFRoZSBgY3Jvc3NPcmlnaW5gIGF0dHJpYnV0ZSBmb3IgbG9hZGVkIGltYWdlcy4gTm90ZSB0aGF0IHlvdSBtdXN0IHByb3ZpZGUgYVxuICogYGNyb3NzT3JpZ2luYCB2YWx1ZSBpZiB5b3Ugd2FudCB0byBhY2Nlc3MgcGl4ZWwgZGF0YSB3aXRoIHRoZSBDYW52YXMgcmVuZGVyZXIuXG4gKiBTZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSFRNTC9DT1JTX2VuYWJsZWRfaW1hZ2UgZm9yIG1vcmUgZGV0YWlsLlxuICogQHByb3BlcnR5IHtIVE1MSW1hZ2VFbGVtZW50fEhUTUxDYW52YXNFbGVtZW50fSBbaW1nXSBJbWFnZSBvYmplY3QgZm9yIHRoZSBpY29uLiBJZiB0aGUgYHNyY2Agb3B0aW9uIGlzIG5vdCBwcm92aWRlZCB0aGVuIHRoZVxuICogcHJvdmlkZWQgaW1hZ2UgbXVzdCBhbHJlYWR5IGJlIGxvYWRlZC4gQW5kIGluIHRoYXQgY2FzZSwgaXQgaXMgcmVxdWlyZWRcbiAqIHRvIHByb3ZpZGUgdGhlIHNpemUgb2YgdGhlIGltYWdlLCB3aXRoIHRoZSBgaW1nU2l6ZWAgb3B0aW9uLlxuICogQHByb3BlcnR5IHtpbXBvcnQoXCIuLi9zaXplLmpzXCIpLlNpemV9IFtpbWdTaXplXSBJbWFnZSBzaXplIGluIHBpeGVscy4gT25seSByZXF1aXJlZCBpZiBgaW1nYCBpcyBzZXQgYW5kIGBzcmNgIGlzIG5vdC5cbiAqIFRoZSBwcm92aWRlZCBgaW1nU2l6ZWAgbmVlZHMgdG8gbWF0Y2ggdGhlIGFjdHVhbCBzaXplIG9mIHRoZSBpbWFnZS5cbiAqIEBwcm9wZXJ0eSB7QXJyYXk8bnVtYmVyPn0gW2Rpc3BsYWNlbWVudD1bMCwgMF1dIERpc3BsYWNlbWVudCBvZiB0aGUgaWNvbiBpbiBwaXhlbHMuXG4gKiBQb3NpdGl2ZSB2YWx1ZXMgd2lsbCBzaGlmdCB0aGUgaWNvbiByaWdodCBhbmQgdXAuXG4gKiBAcHJvcGVydHkge251bWJlcn0gW29wYWNpdHk9MV0gT3BhY2l0eSBvZiB0aGUgaWNvbi5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbd2lkdGhdIFRoZSB3aWR0aCBvZiB0aGUgaWNvbiBpbiBwaXhlbHMuIFRoaXMgY2FuJ3QgYmUgdXNlZCB0b2dldGhlciB3aXRoIGBzY2FsZWAuXG4gKiBAcHJvcGVydHkge251bWJlcn0gW2hlaWdodF0gVGhlIGhlaWdodCBvZiB0aGUgaWNvbiBpbiBwaXhlbHMuIFRoaXMgY2FuJ3QgYmUgdXNlZCB0b2dldGhlciB3aXRoIGBzY2FsZWAuXG4gKiBAcHJvcGVydHkge251bWJlcnxpbXBvcnQoXCIuLi9zaXplLmpzXCIpLlNpemV9IFtzY2FsZT0xXSBTY2FsZS5cbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW3JvdGF0ZVdpdGhWaWV3PWZhbHNlXSBXaGV0aGVyIHRvIHJvdGF0ZSB0aGUgaWNvbiB3aXRoIHRoZSB2aWV3LlxuICogQHByb3BlcnR5IHtudW1iZXJ9IFtyb3RhdGlvbj0wXSBSb3RhdGlvbiBpbiByYWRpYW5zIChwb3NpdGl2ZSByb3RhdGlvbiBjbG9ja3dpc2UpLlxuICogQHByb3BlcnR5IHtBcnJheTxudW1iZXI+fSBbb2Zmc2V0PVswLCAwXV0gT2Zmc2V0IHdoaWNoLCB0b2dldGhlciB3aXRoIGBzaXplYCBhbmQgYG9mZnNldE9yaWdpbmAsIGRlZmluZXMgdGhlXG4gKiBzdWItcmVjdGFuZ2xlIHRvIHVzZSBmcm9tIHRoZSBvcmlnaW5hbCAoc3ByaXRlKSBpbWFnZS5cbiAqIEBwcm9wZXJ0eSB7SWNvbk9yaWdpbn0gW29mZnNldE9yaWdpbj0ndG9wLWxlZnQnXSBPcmlnaW4gb2YgdGhlIG9mZnNldDogYGJvdHRvbS1sZWZ0YCwgYGJvdHRvbS1yaWdodGAsXG4gKiBgdG9wLWxlZnRgIG9yIGB0b3AtcmlnaHRgLlxuICogQHByb3BlcnR5IHtpbXBvcnQoXCIuLi9zaXplLmpzXCIpLlNpemV9IFtzaXplXSBJY29uIHNpemUgaW4gcGl4ZWxzLiBVc2VkIHRvZ2V0aGVyIHdpdGggYG9mZnNldGAgdG8gZGVmaW5lIHRoZVxuICogc3ViLXJlY3RhbmdsZSB0byB1c2UgZnJvbSB0aGUgb3JpZ2luYWwgKHNwcml0ZSkgaW1hZ2UuXG4gKiBAcHJvcGVydHkge3N0cmluZ30gW3NyY10gSW1hZ2Ugc291cmNlIFVSSS5cbiAqIEBwcm9wZXJ0eSB7XCJkZWNsdXR0ZXJcInxcIm9ic3RhY2xlXCJ8XCJub25lXCJ8dW5kZWZpbmVkfSBbZGVjbHV0dGVyTW9kZV0gRGVjbHV0dGVyIG1vZGUuXG4gKi9cblxuLyoqXG4gKiBAY2xhc3NkZXNjXG4gKiBTZXQgaWNvbiBzdHlsZSBmb3IgdmVjdG9yIGZlYXR1cmVzLlxuICogQGFwaVxuICovXG5jbGFzcyBJY29uIGV4dGVuZHMgSW1hZ2VTdHlsZSB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge09wdGlvbnN9IFtvcHRpb25zXSBPcHRpb25zLlxuICAgKi9cbiAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gICAgLyoqXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICBjb25zdCBvcGFjaXR5ID0gb3B0aW9ucy5vcGFjaXR5ICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLm9wYWNpdHkgOiAxO1xuXG4gICAgLyoqXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICBjb25zdCByb3RhdGlvbiA9IG9wdGlvbnMucm90YXRpb24gIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMucm90YXRpb24gOiAwO1xuXG4gICAgLyoqXG4gICAgICogQHR5cGUge251bWJlcnxpbXBvcnQoXCIuLi9zaXplLmpzXCIpLlNpemV9XG4gICAgICovXG4gICAgY29uc3Qgc2NhbGUgPSBvcHRpb25zLnNjYWxlICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLnNjYWxlIDogMTtcblxuICAgIC8qKlxuICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAqL1xuICAgIGNvbnN0IHJvdGF0ZVdpdGhWaWV3ID1cbiAgICAgIG9wdGlvbnMucm90YXRlV2l0aFZpZXcgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMucm90YXRlV2l0aFZpZXcgOiBmYWxzZTtcblxuICAgIHN1cGVyKHtcbiAgICAgIG9wYWNpdHk6IG9wYWNpdHksXG4gICAgICByb3RhdGlvbjogcm90YXRpb24sXG4gICAgICBzY2FsZTogc2NhbGUsXG4gICAgICBkaXNwbGFjZW1lbnQ6XG4gICAgICAgIG9wdGlvbnMuZGlzcGxhY2VtZW50ICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLmRpc3BsYWNlbWVudCA6IFswLCAwXSxcbiAgICAgIHJvdGF0ZVdpdGhWaWV3OiByb3RhdGVXaXRoVmlldyxcbiAgICAgIGRlY2x1dHRlck1vZGU6IG9wdGlvbnMuZGVjbHV0dGVyTW9kZSxcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge0FycmF5PG51bWJlcj59XG4gICAgICovXG4gICAgdGhpcy5hbmNob3JfID0gb3B0aW9ucy5hbmNob3IgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMuYW5jaG9yIDogWzAuNSwgMC41XTtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge0FycmF5PG51bWJlcj59XG4gICAgICovXG4gICAgdGhpcy5ub3JtYWxpemVkQW5jaG9yXyA9IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtJY29uT3JpZ2lufVxuICAgICAqL1xuICAgIHRoaXMuYW5jaG9yT3JpZ2luXyA9XG4gICAgICBvcHRpb25zLmFuY2hvck9yaWdpbiAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5hbmNob3JPcmlnaW4gOiAndG9wLWxlZnQnO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7SWNvbkFuY2hvclVuaXRzfVxuICAgICAqL1xuICAgIHRoaXMuYW5jaG9yWFVuaXRzXyA9XG4gICAgICBvcHRpb25zLmFuY2hvclhVbml0cyAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5hbmNob3JYVW5pdHMgOiAnZnJhY3Rpb24nO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7SWNvbkFuY2hvclVuaXRzfVxuICAgICAqL1xuICAgIHRoaXMuYW5jaG9yWVVuaXRzXyA9XG4gICAgICBvcHRpb25zLmFuY2hvcllVbml0cyAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5hbmNob3JZVW5pdHMgOiAnZnJhY3Rpb24nO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7P3N0cmluZ31cbiAgICAgKi9cbiAgICB0aGlzLmNyb3NzT3JpZ2luXyA9XG4gICAgICBvcHRpb25zLmNyb3NzT3JpZ2luICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLmNyb3NzT3JpZ2luIDogbnVsbDtcblxuICAgIC8qKlxuICAgICAqIEB0eXBlIHtIVE1MSW1hZ2VFbGVtZW50fEhUTUxDYW52YXNFbGVtZW50fVxuICAgICAqL1xuICAgIGNvbnN0IGltYWdlID0gb3B0aW9ucy5pbWcgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMuaW1nIDogbnVsbDtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge2ltcG9ydChcIi4uL3NpemUuanNcIikuU2l6ZXx1bmRlZmluZWR9XG4gICAgICovXG4gICAgdGhpcy5pbWdTaXplXyA9IG9wdGlvbnMuaW1nU2l6ZTtcblxuICAgIC8qKlxuICAgICAqIEB0eXBlIHtzdHJpbmd8dW5kZWZpbmVkfVxuICAgICAqL1xuICAgIGxldCBzcmMgPSBvcHRpb25zLnNyYztcblxuICAgIGFzc2VydCghKHNyYyAhPT0gdW5kZWZpbmVkICYmIGltYWdlKSwgNCk7IC8vIGBpbWFnZWAgYW5kIGBzcmNgIGNhbm5vdCBiZSBwcm92aWRlZCBhdCB0aGUgc2FtZSB0aW1lXG4gICAgYXNzZXJ0KCFpbWFnZSB8fCAoaW1hZ2UgJiYgdGhpcy5pbWdTaXplXyksIDUpOyAvLyBgaW1nU2l6ZWAgbXVzdCBiZSBzZXQgd2hlbiBgaW1hZ2VgIGlzIHByb3ZpZGVkXG5cbiAgICBpZiAoKHNyYyA9PT0gdW5kZWZpbmVkIHx8IHNyYy5sZW5ndGggPT09IDApICYmIGltYWdlKSB7XG4gICAgICBzcmMgPSAvKiogQHR5cGUge0hUTUxJbWFnZUVsZW1lbnR9ICovIChpbWFnZSkuc3JjIHx8IGdldFVpZChpbWFnZSk7XG4gICAgfVxuICAgIGFzc2VydChzcmMgIT09IHVuZGVmaW5lZCAmJiBzcmMubGVuZ3RoID4gMCwgNik7IC8vIEEgZGVmaW5lZCBhbmQgbm9uLWVtcHR5IGBzcmNgIG9yIGBpbWFnZWAgbXVzdCBiZSBwcm92aWRlZFxuXG4gICAgLy8gYHdpZHRoYCBvciBgaGVpZ2h0YCBjYW5ub3QgYmUgcHJvdmlkZWQgdG9nZXRoZXIgd2l0aCBgc2NhbGVgXG4gICAgYXNzZXJ0KFxuICAgICAgIShcbiAgICAgICAgKG9wdGlvbnMud2lkdGggIT09IHVuZGVmaW5lZCB8fCBvcHRpb25zLmhlaWdodCAhPT0gdW5kZWZpbmVkKSAmJlxuICAgICAgICBvcHRpb25zLnNjYWxlICE9PSB1bmRlZmluZWRcbiAgICAgICksXG4gICAgICA2OVxuICAgICk7XG5cbiAgICAvKipcbiAgICAgKiBAdHlwZSB7aW1wb3J0KFwiLi4vSW1hZ2VTdGF0ZS5qc1wiKS5kZWZhdWx0fVxuICAgICAqL1xuICAgIGNvbnN0IGltYWdlU3RhdGUgPVxuICAgICAgb3B0aW9ucy5zcmMgIT09IHVuZGVmaW5lZCA/IEltYWdlU3RhdGUuSURMRSA6IEltYWdlU3RhdGUuTE9BREVEO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7aW1wb3J0KFwiLi4vY29sb3IuanNcIikuQ29sb3J9XG4gICAgICovXG4gICAgdGhpcy5jb2xvcl8gPSBvcHRpb25zLmNvbG9yICE9PSB1bmRlZmluZWQgPyBhc0FycmF5KG9wdGlvbnMuY29sb3IpIDogbnVsbDtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge2ltcG9ydChcIi4vSWNvbkltYWdlLmpzXCIpLmRlZmF1bHR9XG4gICAgICovXG4gICAgdGhpcy5pY29uSW1hZ2VfID0gZ2V0SWNvbkltYWdlKFxuICAgICAgaW1hZ2UsXG4gICAgICAvKiogQHR5cGUge3N0cmluZ30gKi8gKHNyYyksXG4gICAgICB0aGlzLmltZ1NpemVfICE9PSB1bmRlZmluZWQgPyB0aGlzLmltZ1NpemVfIDogbnVsbCxcbiAgICAgIHRoaXMuY3Jvc3NPcmlnaW5fLFxuICAgICAgaW1hZ2VTdGF0ZSxcbiAgICAgIHRoaXMuY29sb3JfXG4gICAgKTtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge0FycmF5PG51bWJlcj59XG4gICAgICovXG4gICAgdGhpcy5vZmZzZXRfID0gb3B0aW9ucy5vZmZzZXQgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMub2Zmc2V0IDogWzAsIDBdO1xuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge0ljb25PcmlnaW59XG4gICAgICovXG4gICAgdGhpcy5vZmZzZXRPcmlnaW5fID1cbiAgICAgIG9wdGlvbnMub2Zmc2V0T3JpZ2luICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLm9mZnNldE9yaWdpbiA6ICd0b3AtbGVmdCc7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtBcnJheTxudW1iZXI+fVxuICAgICAqL1xuICAgIHRoaXMub3JpZ2luXyA9IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtpbXBvcnQoXCIuLi9zaXplLmpzXCIpLlNpemV9XG4gICAgICovXG4gICAgdGhpcy5zaXplXyA9IG9wdGlvbnMuc2l6ZSAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5zaXplIDogbnVsbDtcblxuICAgIC8qKlxuICAgICAqIEB0eXBlIHtudW1iZXJ8dW5kZWZpbmVkfVxuICAgICAqL1xuICAgIHRoaXMud2lkdGhfID0gb3B0aW9ucy53aWR0aDtcblxuICAgIC8qKlxuICAgICAqIEB0eXBlIHtudW1iZXJ8dW5kZWZpbmVkfVxuICAgICAqL1xuICAgIHRoaXMuaGVpZ2h0XyA9IG9wdGlvbnMuaGVpZ2h0O1xuXG4gICAgLyoqXG4gICAgICogUmVjYWxjdWxhdGUgdGhlIHNjYWxlIGlmIHdpZHRoIG9yIGhlaWdodCB3ZXJlIGdpdmVuLlxuICAgICAqL1xuICAgIGlmICh0aGlzLndpZHRoXyAhPT0gdW5kZWZpbmVkIHx8IHRoaXMuaGVpZ2h0XyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBjb25zdCBpbWFnZSA9IHRoaXMuZ2V0SW1hZ2UoMSk7XG4gICAgICBjb25zdCBzZXRTY2FsZSA9ICgpID0+IHtcbiAgICAgICAgdGhpcy51cGRhdGVTY2FsZUZyb21XaWR0aEFuZEhlaWdodCh0aGlzLndpZHRoXywgdGhpcy5oZWlnaHRfKTtcbiAgICAgIH07XG4gICAgICBpZiAoaW1hZ2Uud2lkdGggPiAwKSB7XG4gICAgICAgIHRoaXMudXBkYXRlU2NhbGVGcm9tV2lkdGhBbmRIZWlnaHQodGhpcy53aWR0aF8sIHRoaXMuaGVpZ2h0Xyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpbWFnZS5hZGRFdmVudExpc3RlbmVyKCdsb2FkJywgc2V0U2NhbGUpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBDbG9uZXMgdGhlIHN0eWxlLiBUaGUgdW5kZXJseWluZyBJbWFnZS9IVE1MQ2FudmFzRWxlbWVudCBpcyBub3QgY2xvbmVkLlxuICAgKiBAcmV0dXJuIHtJY29ufSBUaGUgY2xvbmVkIHN0eWxlLlxuICAgKiBAYXBpXG4gICAqL1xuICBjbG9uZSgpIHtcbiAgICBsZXQgc2NhbGUgPSB0aGlzLmdldFNjYWxlKCk7XG4gICAgc2NhbGUgPSBBcnJheS5pc0FycmF5KHNjYWxlKSA/IHNjYWxlLnNsaWNlKCkgOiBzY2FsZTtcbiAgICAvLyBpZiBlaXRoZXIgd2lkdGggb3IgaGVpZ2h0IGFyZSBkZWZpbmVkLCBkbyBub3QgcGFzcyBzY2FsZS5cbiAgICBpZiAodGhpcy53aWR0aF8gIT09IHVuZGVmaW5lZCB8fCB0aGlzLmhlaWdodF8gIT09IHVuZGVmaW5lZCkge1xuICAgICAgc2NhbGUgPSB1bmRlZmluZWQ7XG4gICAgfVxuICAgIHJldHVybiBuZXcgSWNvbih7XG4gICAgICBhbmNob3I6IHRoaXMuYW5jaG9yXy5zbGljZSgpLFxuICAgICAgYW5jaG9yT3JpZ2luOiB0aGlzLmFuY2hvck9yaWdpbl8sXG4gICAgICBhbmNob3JYVW5pdHM6IHRoaXMuYW5jaG9yWFVuaXRzXyxcbiAgICAgIGFuY2hvcllVbml0czogdGhpcy5hbmNob3JZVW5pdHNfLFxuICAgICAgY29sb3I6XG4gICAgICAgIHRoaXMuY29sb3JfICYmIHRoaXMuY29sb3JfLnNsaWNlXG4gICAgICAgICAgPyB0aGlzLmNvbG9yXy5zbGljZSgpXG4gICAgICAgICAgOiB0aGlzLmNvbG9yXyB8fCB1bmRlZmluZWQsXG4gICAgICBjcm9zc09yaWdpbjogdGhpcy5jcm9zc09yaWdpbl8sXG4gICAgICBpbWdTaXplOiB0aGlzLmltZ1NpemVfLFxuICAgICAgb2Zmc2V0OiB0aGlzLm9mZnNldF8uc2xpY2UoKSxcbiAgICAgIG9mZnNldE9yaWdpbjogdGhpcy5vZmZzZXRPcmlnaW5fLFxuICAgICAgb3BhY2l0eTogdGhpcy5nZXRPcGFjaXR5KCksXG4gICAgICByb3RhdGVXaXRoVmlldzogdGhpcy5nZXRSb3RhdGVXaXRoVmlldygpLFxuICAgICAgcm90YXRpb246IHRoaXMuZ2V0Um90YXRpb24oKSxcbiAgICAgIHNjYWxlOiBzY2FsZSxcbiAgICAgIHNpemU6IHRoaXMuc2l6ZV8gIT09IG51bGwgPyB0aGlzLnNpemVfLnNsaWNlKCkgOiB1bmRlZmluZWQsXG4gICAgICBzcmM6IHRoaXMuZ2V0U3JjKCksXG4gICAgICBkaXNwbGFjZW1lbnQ6IHRoaXMuZ2V0RGlzcGxhY2VtZW50KCkuc2xpY2UoKSxcbiAgICAgIGRlY2x1dHRlck1vZGU6IHRoaXMuZ2V0RGVjbHV0dGVyTW9kZSgpLFxuICAgICAgd2lkdGg6IHRoaXMud2lkdGhfLFxuICAgICAgaGVpZ2h0OiB0aGlzLmhlaWdodF8sXG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogU2V0IHRoZSBzY2FsZSBvZiB0aGUgSWNvbiBieSBjYWxjdWxhdGluZyBpdCBmcm9tIGdpdmVuIHdpZHRoIGFuZCBoZWlnaHQgYW5kIHRoZVxuICAgKiB3aWR0aCBhbmQgaGVpZ2h0IG9mIHRoZSBpbWFnZS5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtudW1iZXJ9IHdpZHRoIFRoZSB3aWR0aC5cbiAgICogQHBhcmFtIHtudW1iZXJ9IGhlaWdodCBUaGUgaGVpZ2h0LlxuICAgKi9cbiAgdXBkYXRlU2NhbGVGcm9tV2lkdGhBbmRIZWlnaHQod2lkdGgsIGhlaWdodCkge1xuICAgIGNvbnN0IGltYWdlID0gdGhpcy5nZXRJbWFnZSgxKTtcbiAgICBpZiAod2lkdGggIT09IHVuZGVmaW5lZCAmJiBoZWlnaHQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgc3VwZXIuc2V0U2NhbGUoW3dpZHRoIC8gaW1hZ2Uud2lkdGgsIGhlaWdodCAvIGltYWdlLmhlaWdodF0pO1xuICAgIH0gZWxzZSBpZiAod2lkdGggIT09IHVuZGVmaW5lZCkge1xuICAgICAgc3VwZXIuc2V0U2NhbGUoW3dpZHRoIC8gaW1hZ2Uud2lkdGgsIHdpZHRoIC8gaW1hZ2Uud2lkdGhdKTtcbiAgICB9IGVsc2UgaWYgKGhlaWdodCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBzdXBlci5zZXRTY2FsZShbaGVpZ2h0IC8gaW1hZ2UuaGVpZ2h0LCBoZWlnaHQgLyBpbWFnZS5oZWlnaHRdKTtcbiAgICB9IGVsc2Uge1xuICAgICAgc3VwZXIuc2V0U2NhbGUoWzEsIDFdKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBhbmNob3IgcG9pbnQgaW4gcGl4ZWxzLiBUaGUgYW5jaG9yIGRldGVybWluZXMgdGhlIGNlbnRlciBwb2ludCBmb3IgdGhlXG4gICAqIHN5bWJvbGl6ZXIuXG4gICAqIEByZXR1cm4ge0FycmF5PG51bWJlcj59IEFuY2hvci5cbiAgICogQGFwaVxuICAgKi9cbiAgZ2V0QW5jaG9yKCkge1xuICAgIGxldCBhbmNob3IgPSB0aGlzLm5vcm1hbGl6ZWRBbmNob3JfO1xuICAgIGlmICghYW5jaG9yKSB7XG4gICAgICBhbmNob3IgPSB0aGlzLmFuY2hvcl87XG4gICAgICBjb25zdCBzaXplID0gdGhpcy5nZXRTaXplKCk7XG4gICAgICBpZiAoXG4gICAgICAgIHRoaXMuYW5jaG9yWFVuaXRzXyA9PSAnZnJhY3Rpb24nIHx8XG4gICAgICAgIHRoaXMuYW5jaG9yWVVuaXRzXyA9PSAnZnJhY3Rpb24nXG4gICAgICApIHtcbiAgICAgICAgaWYgKCFzaXplKSB7XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgYW5jaG9yID0gdGhpcy5hbmNob3JfLnNsaWNlKCk7XG4gICAgICAgIGlmICh0aGlzLmFuY2hvclhVbml0c18gPT0gJ2ZyYWN0aW9uJykge1xuICAgICAgICAgIGFuY2hvclswXSAqPSBzaXplWzBdO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmFuY2hvcllVbml0c18gPT0gJ2ZyYWN0aW9uJykge1xuICAgICAgICAgIGFuY2hvclsxXSAqPSBzaXplWzFdO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLmFuY2hvck9yaWdpbl8gIT0gJ3RvcC1sZWZ0Jykge1xuICAgICAgICBpZiAoIXNpemUpIHtcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYW5jaG9yID09PSB0aGlzLmFuY2hvcl8pIHtcbiAgICAgICAgICBhbmNob3IgPSB0aGlzLmFuY2hvcl8uc2xpY2UoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoXG4gICAgICAgICAgdGhpcy5hbmNob3JPcmlnaW5fID09ICd0b3AtcmlnaHQnIHx8XG4gICAgICAgICAgdGhpcy5hbmNob3JPcmlnaW5fID09ICdib3R0b20tcmlnaHQnXG4gICAgICAgICkge1xuICAgICAgICAgIGFuY2hvclswXSA9IC1hbmNob3JbMF0gKyBzaXplWzBdO1xuICAgICAgICB9XG4gICAgICAgIGlmIChcbiAgICAgICAgICB0aGlzLmFuY2hvck9yaWdpbl8gPT0gJ2JvdHRvbS1sZWZ0JyB8fFxuICAgICAgICAgIHRoaXMuYW5jaG9yT3JpZ2luXyA9PSAnYm90dG9tLXJpZ2h0J1xuICAgICAgICApIHtcbiAgICAgICAgICBhbmNob3JbMV0gPSAtYW5jaG9yWzFdICsgc2l6ZVsxXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdGhpcy5ub3JtYWxpemVkQW5jaG9yXyA9IGFuY2hvcjtcbiAgICB9XG4gICAgY29uc3QgZGlzcGxhY2VtZW50ID0gdGhpcy5nZXREaXNwbGFjZW1lbnQoKTtcbiAgICBjb25zdCBzY2FsZSA9IHRoaXMuZ2V0U2NhbGVBcnJheSgpO1xuICAgIC8vIGFuY2hvciBpcyBzY2FsZWQgYnkgcmVuZGVyZXIgYnV0IGRpc3BsYWNlbWVudCBzaG91bGQgbm90IGJlIHNjYWxlZFxuICAgIC8vIHNvIGRpdmlkZSBieSBzY2FsZSBoZXJlXG4gICAgcmV0dXJuIFtcbiAgICAgIGFuY2hvclswXSAtIGRpc3BsYWNlbWVudFswXSAvIHNjYWxlWzBdLFxuICAgICAgYW5jaG9yWzFdICsgZGlzcGxhY2VtZW50WzFdIC8gc2NhbGVbMV0sXG4gICAgXTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXQgdGhlIGFuY2hvciBwb2ludC4gVGhlIGFuY2hvciBkZXRlcm1pbmVzIHRoZSBjZW50ZXIgcG9pbnQgZm9yIHRoZVxuICAgKiBzeW1ib2xpemVyLlxuICAgKlxuICAgKiBAcGFyYW0ge0FycmF5PG51bWJlcj59IGFuY2hvciBBbmNob3IuXG4gICAqIEBhcGlcbiAgICovXG4gIHNldEFuY2hvcihhbmNob3IpIHtcbiAgICB0aGlzLmFuY2hvcl8gPSBhbmNob3I7XG4gICAgdGhpcy5ub3JtYWxpemVkQW5jaG9yXyA9IG51bGw7XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBpY29uIGNvbG9yLlxuICAgKiBAcmV0dXJuIHtpbXBvcnQoXCIuLi9jb2xvci5qc1wiKS5Db2xvcn0gQ29sb3IuXG4gICAqIEBhcGlcbiAgICovXG4gIGdldENvbG9yKCkge1xuICAgIHJldHVybiB0aGlzLmNvbG9yXztcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIGltYWdlIGljb24uXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBwaXhlbFJhdGlvIFBpeGVsIHJhdGlvLlxuICAgKiBAcmV0dXJuIHtIVE1MSW1hZ2VFbGVtZW50fEhUTUxDYW52YXNFbGVtZW50fSBJbWFnZSBvciBDYW52YXMgZWxlbWVudC5cbiAgICogQGFwaVxuICAgKi9cbiAgZ2V0SW1hZ2UocGl4ZWxSYXRpbykge1xuICAgIHJldHVybiB0aGlzLmljb25JbWFnZV8uZ2V0SW1hZ2UocGl4ZWxSYXRpbyk7XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBwaXhlbCByYXRpby5cbiAgICogQHBhcmFtIHtudW1iZXJ9IHBpeGVsUmF0aW8gUGl4ZWwgcmF0aW8uXG4gICAqIEByZXR1cm4ge251bWJlcn0gVGhlIHBpeGVsIHJhdGlvIG9mIHRoZSBpbWFnZS5cbiAgICogQGFwaVxuICAgKi9cbiAgZ2V0UGl4ZWxSYXRpbyhwaXhlbFJhdGlvKSB7XG4gICAgcmV0dXJuIHRoaXMuaWNvbkltYWdlXy5nZXRQaXhlbFJhdGlvKHBpeGVsUmF0aW8pO1xuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge2ltcG9ydChcIi4uL3NpemUuanNcIikuU2l6ZX0gSW1hZ2Ugc2l6ZS5cbiAgICovXG4gIGdldEltYWdlU2l6ZSgpIHtcbiAgICByZXR1cm4gdGhpcy5pY29uSW1hZ2VfLmdldFNpemUoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtpbXBvcnQoXCIuLi9JbWFnZVN0YXRlLmpzXCIpLmRlZmF1bHR9IEltYWdlIHN0YXRlLlxuICAgKi9cbiAgZ2V0SW1hZ2VTdGF0ZSgpIHtcbiAgICByZXR1cm4gdGhpcy5pY29uSW1hZ2VfLmdldEltYWdlU3RhdGUoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtIVE1MSW1hZ2VFbGVtZW50fEhUTUxDYW52YXNFbGVtZW50fSBJbWFnZSBlbGVtZW50LlxuICAgKi9cbiAgZ2V0SGl0RGV0ZWN0aW9uSW1hZ2UoKSB7XG4gICAgcmV0dXJuIHRoaXMuaWNvbkltYWdlXy5nZXRIaXREZXRlY3Rpb25JbWFnZSgpO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgb3JpZ2luIG9mIHRoZSBzeW1ib2xpemVyLlxuICAgKiBAcmV0dXJuIHtBcnJheTxudW1iZXI+fSBPcmlnaW4uXG4gICAqIEBhcGlcbiAgICovXG4gIGdldE9yaWdpbigpIHtcbiAgICBpZiAodGhpcy5vcmlnaW5fKSB7XG4gICAgICByZXR1cm4gdGhpcy5vcmlnaW5fO1xuICAgIH1cbiAgICBsZXQgb2Zmc2V0ID0gdGhpcy5vZmZzZXRfO1xuXG4gICAgaWYgKHRoaXMub2Zmc2V0T3JpZ2luXyAhPSAndG9wLWxlZnQnKSB7XG4gICAgICBjb25zdCBzaXplID0gdGhpcy5nZXRTaXplKCk7XG4gICAgICBjb25zdCBpY29uSW1hZ2VTaXplID0gdGhpcy5pY29uSW1hZ2VfLmdldFNpemUoKTtcbiAgICAgIGlmICghc2l6ZSB8fCAhaWNvbkltYWdlU2l6ZSkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICAgIG9mZnNldCA9IG9mZnNldC5zbGljZSgpO1xuICAgICAgaWYgKFxuICAgICAgICB0aGlzLm9mZnNldE9yaWdpbl8gPT0gJ3RvcC1yaWdodCcgfHxcbiAgICAgICAgdGhpcy5vZmZzZXRPcmlnaW5fID09ICdib3R0b20tcmlnaHQnXG4gICAgICApIHtcbiAgICAgICAgb2Zmc2V0WzBdID0gaWNvbkltYWdlU2l6ZVswXSAtIHNpemVbMF0gLSBvZmZzZXRbMF07XG4gICAgICB9XG4gICAgICBpZiAoXG4gICAgICAgIHRoaXMub2Zmc2V0T3JpZ2luXyA9PSAnYm90dG9tLWxlZnQnIHx8XG4gICAgICAgIHRoaXMub2Zmc2V0T3JpZ2luXyA9PSAnYm90dG9tLXJpZ2h0J1xuICAgICAgKSB7XG4gICAgICAgIG9mZnNldFsxXSA9IGljb25JbWFnZVNpemVbMV0gLSBzaXplWzFdIC0gb2Zmc2V0WzFdO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLm9yaWdpbl8gPSBvZmZzZXQ7XG4gICAgcmV0dXJuIHRoaXMub3JpZ2luXztcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIGltYWdlIFVSTC5cbiAgICogQHJldHVybiB7c3RyaW5nfHVuZGVmaW5lZH0gSW1hZ2Ugc3JjLlxuICAgKiBAYXBpXG4gICAqL1xuICBnZXRTcmMoKSB7XG4gICAgcmV0dXJuIHRoaXMuaWNvbkltYWdlXy5nZXRTcmMoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIHNpemUgb2YgdGhlIGljb24gKGluIHBpeGVscykuXG4gICAqIEByZXR1cm4ge2ltcG9ydChcIi4uL3NpemUuanNcIikuU2l6ZX0gSW1hZ2Ugc2l6ZS5cbiAgICogQGFwaVxuICAgKi9cbiAgZ2V0U2l6ZSgpIHtcbiAgICByZXR1cm4gIXRoaXMuc2l6ZV8gPyB0aGlzLmljb25JbWFnZV8uZ2V0U2l6ZSgpIDogdGhpcy5zaXplXztcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIHdpZHRoIG9mIHRoZSBpY29uIChpbiBwaXhlbHMpLlxuICAgKiBAcmV0dXJuIHtudW1iZXJ9IEljb24gd2lkdGggKGluIHBpeGVscykuXG4gICAqIEBhcGlcbiAgICovXG4gIGdldFdpZHRoKCkge1xuICAgIHJldHVybiB0aGlzLndpZHRoXztcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIGhlaWdodCBvZiB0aGUgaWNvbiAoaW4gcGl4ZWxzKS5cbiAgICogQHJldHVybiB7bnVtYmVyfSBJY29uIGhlaWdodCAoaW4gcGl4ZWxzKS5cbiAgICogQGFwaVxuICAgKi9cbiAgZ2V0SGVpZ2h0KCkge1xuICAgIHJldHVybiB0aGlzLmhlaWdodF87XG4gIH1cblxuICAvKipcbiAgICogU2V0IHRoZSB3aWR0aCBvZiB0aGUgaWNvbiBpbiBwaXhlbHMuXG4gICAqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB3aWR0aCBUaGUgd2lkdGggdG8gc2V0LlxuICAgKi9cbiAgc2V0V2lkdGgod2lkdGgpIHtcbiAgICB0aGlzLndpZHRoXyA9IHdpZHRoO1xuICAgIHRoaXMudXBkYXRlU2NhbGVGcm9tV2lkdGhBbmRIZWlnaHQod2lkdGgsIHRoaXMuaGVpZ2h0Xyk7XG4gIH1cblxuICAvKipcbiAgICogU2V0IHRoZSBoZWlnaHQgb2YgdGhlIGljb24gaW4gcGl4ZWxzLlxuICAgKlxuICAgKiBAcGFyYW0ge251bWJlcn0gaGVpZ2h0IFRoZSBoZWlnaHQgdG8gc2V0LlxuICAgKi9cbiAgc2V0SGVpZ2h0KGhlaWdodCkge1xuICAgIHRoaXMuaGVpZ2h0XyA9IGhlaWdodDtcbiAgICB0aGlzLnVwZGF0ZVNjYWxlRnJvbVdpZHRoQW5kSGVpZ2h0KHRoaXMud2lkdGhfLCBoZWlnaHQpO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldCB0aGUgc2NhbGUgYW5kIHVwZGF0ZXMgdGhlIHdpZHRoIGFuZCBoZWlnaHQgY29ycmVzcG9uZGluZ2x5LlxuICAgKlxuICAgKiBAcGFyYW0ge251bWJlcnxpbXBvcnQoXCIuLi9zaXplLmpzXCIpLlNpemV9IHNjYWxlIFNjYWxlLlxuICAgKiBAb3ZlcnJpZGVcbiAgICogQGFwaVxuICAgKi9cbiAgc2V0U2NhbGUoc2NhbGUpIHtcbiAgICBzdXBlci5zZXRTY2FsZShzY2FsZSk7XG4gICAgY29uc3QgaW1hZ2UgPSB0aGlzLmdldEltYWdlKDEpO1xuICAgIGlmIChpbWFnZSkge1xuICAgICAgY29uc3Qgd2lkdGhTY2FsZSA9IEFycmF5LmlzQXJyYXkoc2NhbGUpID8gc2NhbGVbMF0gOiBzY2FsZTtcbiAgICAgIGlmICh3aWR0aFNjYWxlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhpcy53aWR0aF8gPSB3aWR0aFNjYWxlICogaW1hZ2Uud2lkdGg7XG4gICAgICB9XG4gICAgICBjb25zdCBoZWlnaHRTY2FsZSA9IEFycmF5LmlzQXJyYXkoc2NhbGUpID8gc2NhbGVbMV0gOiBzY2FsZTtcbiAgICAgIGlmIChoZWlnaHRTY2FsZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRoaXMuaGVpZ2h0XyA9IGhlaWdodFNjYWxlICogaW1hZ2UuaGVpZ2h0O1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge2Z1bmN0aW9uKGltcG9ydChcIi4uL2V2ZW50cy9FdmVudC5qc1wiKS5kZWZhdWx0KTogdm9pZH0gbGlzdGVuZXIgTGlzdGVuZXIgZnVuY3Rpb24uXG4gICAqL1xuICBsaXN0ZW5JbWFnZUNoYW5nZShsaXN0ZW5lcikge1xuICAgIHRoaXMuaWNvbkltYWdlXy5hZGRFdmVudExpc3RlbmVyKEV2ZW50VHlwZS5DSEFOR0UsIGxpc3RlbmVyKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBMb2FkIG5vdCB5ZXQgbG9hZGVkIFVSSS5cbiAgICogV2hlbiByZW5kZXJpbmcgYSBmZWF0dXJlIHdpdGggYW4gaWNvbiBzdHlsZSwgdGhlIHZlY3RvciByZW5kZXJlciB3aWxsXG4gICAqIGF1dG9tYXRpY2FsbHkgY2FsbCB0aGlzIG1ldGhvZC4gSG93ZXZlciwgeW91IG1pZ2h0IHdhbnQgdG8gY2FsbCB0aGlzXG4gICAqIG1ldGhvZCB5b3Vyc2VsZiBmb3IgcHJlbG9hZGluZyBvciBvdGhlciBwdXJwb3Nlcy5cbiAgICogQGFwaVxuICAgKi9cbiAgbG9hZCgpIHtcbiAgICB0aGlzLmljb25JbWFnZV8ubG9hZCgpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb24oaW1wb3J0KFwiLi4vZXZlbnRzL0V2ZW50LmpzXCIpLmRlZmF1bHQpOiB2b2lkfSBsaXN0ZW5lciBMaXN0ZW5lciBmdW5jdGlvbi5cbiAgICovXG4gIHVubGlzdGVuSW1hZ2VDaGFuZ2UobGlzdGVuZXIpIHtcbiAgICB0aGlzLmljb25JbWFnZV8ucmVtb3ZlRXZlbnRMaXN0ZW5lcihFdmVudFR5cGUuQ0hBTkdFLCBsaXN0ZW5lcik7XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgSWNvbjtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///81332\n")},92710:function(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__){eval('/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "c": function() { return /* binding */ shared; }\n/* harmony export */ });\n/* harmony import */ var _color_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(79706);\n/**\n * @module ol/style/IconImageCache\n */\n\n\n/**\n * @classdesc\n * Singleton class. Available through {@link module:ol/style/IconImageCache.shared}.\n */\nclass IconImageCache {\n  constructor() {\n    /**\n     * @type {!Object<string, import("./IconImage.js").default>}\n     * @private\n     */\n    this.cache_ = {};\n\n    /**\n     * @type {number}\n     * @private\n     */\n    this.cacheSize_ = 0;\n\n    /**\n     * @type {number}\n     * @private\n     */\n    this.maxCacheSize_ = 32;\n  }\n\n  /**\n   * FIXME empty description for jsdoc\n   */\n  clear() {\n    this.cache_ = {};\n    this.cacheSize_ = 0;\n  }\n\n  /**\n   * @return {boolean} Can expire cache.\n   */\n  canExpireCache() {\n    return this.cacheSize_ > this.maxCacheSize_;\n  }\n\n  /**\n   * FIXME empty description for jsdoc\n   */\n  expire() {\n    if (this.canExpireCache()) {\n      let i = 0;\n      for (const key in this.cache_) {\n        const iconImage = this.cache_[key];\n        if ((i++ & 3) === 0 && !iconImage.hasListener()) {\n          delete this.cache_[key];\n          --this.cacheSize_;\n        }\n      }\n    }\n  }\n\n  /**\n   * @param {string} src Src.\n   * @param {?string} crossOrigin Cross origin.\n   * @param {import("../color.js").Color} color Color.\n   * @return {import("./IconImage.js").default} Icon image.\n   */\n  get(src, crossOrigin, color) {\n    const key = getKey(src, crossOrigin, color);\n    return key in this.cache_ ? this.cache_[key] : null;\n  }\n\n  /**\n   * @param {string} src Src.\n   * @param {?string} crossOrigin Cross origin.\n   * @param {import("../color.js").Color} color Color.\n   * @param {import("./IconImage.js").default} iconImage Icon image.\n   */\n  set(src, crossOrigin, color, iconImage) {\n    const key = getKey(src, crossOrigin, color);\n    this.cache_[key] = iconImage;\n    ++this.cacheSize_;\n  }\n\n  /**\n   * Set the cache size of the icon cache. Default is `32`. Change this value when\n   * your map uses more than 32 different icon images and you are not caching icon\n   * styles on the application level.\n   * @param {number} maxCacheSize Cache max size.\n   * @api\n   */\n  setSize(maxCacheSize) {\n    this.maxCacheSize_ = maxCacheSize;\n    this.expire();\n  }\n}\n\n/**\n * @param {string} src Src.\n * @param {?string} crossOrigin Cross origin.\n * @param {import("../color.js").Color} color Color.\n * @return {string} Cache key.\n */\nfunction getKey(src, crossOrigin, color) {\n  const colorString = color ? (0,_color_js__WEBPACK_IMPORTED_MODULE_0__/* .asString */ .XC)(color) : \'null\';\n  return crossOrigin + \':\' + src + \':\' + colorString;\n}\n\n/* unused harmony default export */ var __WEBPACK_DEFAULT_EXPORT__ = ((/* unused pure expression or super */ null && (IconImageCache)));\n\n/**\n * The {@link module:ol/style/IconImageCache~IconImageCache} for\n * {@link module:ol/style/Icon~Icon} images.\n * @api\n */\nconst shared = new IconImageCache();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiOTI3MTAuanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFBO0FBQ0E7QUFDQTtBQUNxQzs7QUFFckM7QUFDQTtBQUNBLHVDQUF1Qyw0Q0FBNEM7QUFDbkY7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBOztBQUVBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGNBQWMsU0FBUztBQUN2QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxhQUFhLFFBQVE7QUFDckIsYUFBYSxTQUFTO0FBQ3RCLGFBQWEsNkJBQTZCO0FBQzFDLGNBQWMsa0NBQWtDO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxhQUFhLFFBQVE7QUFDckIsYUFBYSxTQUFTO0FBQ3RCLGFBQWEsNkJBQTZCO0FBQzFDLGFBQWEsa0NBQWtDO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFNBQVM7QUFDcEIsV0FBVyw2QkFBNkI7QUFDeEMsWUFBWSxRQUFRO0FBQ3BCO0FBQ0E7QUFDQSw4QkFBOEIsNkRBQVE7QUFDdEM7QUFDQTs7QUFFQSxzRUFBZSw4REFBYyxJQUFDOztBQUU5QjtBQUNBLFFBQVEscURBQXFEO0FBQzdELElBQUksaUNBQWlDO0FBQ3JDO0FBQ0E7QUFDTyIsInNvdXJjZXMiOlsid2VicGFjazovL3Z1ZTMtd2VicGFjazUvLi9ub2RlX21vZHVsZXMvb2wvc3R5bGUvSWNvbkltYWdlQ2FjaGUuanM/MWMzMiJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBtb2R1bGUgb2wvc3R5bGUvSWNvbkltYWdlQ2FjaGVcbiAqL1xuaW1wb3J0IHthc1N0cmluZ30gZnJvbSAnLi4vY29sb3IuanMnO1xuXG4vKipcbiAqIEBjbGFzc2Rlc2NcbiAqIFNpbmdsZXRvbiBjbGFzcy4gQXZhaWxhYmxlIHRocm91Z2gge0BsaW5rIG1vZHVsZTpvbC9zdHlsZS9JY29uSW1hZ2VDYWNoZS5zaGFyZWR9LlxuICovXG5jbGFzcyBJY29uSW1hZ2VDYWNoZSB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIC8qKlxuICAgICAqIEB0eXBlIHshT2JqZWN0PHN0cmluZywgaW1wb3J0KFwiLi9JY29uSW1hZ2UuanNcIikuZGVmYXVsdD59XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLmNhY2hlXyA9IHt9O1xuXG4gICAgLyoqXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMuY2FjaGVTaXplXyA9IDA7XG5cbiAgICAvKipcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5tYXhDYWNoZVNpemVfID0gMzI7XG4gIH1cblxuICAvKipcbiAgICogRklYTUUgZW1wdHkgZGVzY3JpcHRpb24gZm9yIGpzZG9jXG4gICAqL1xuICBjbGVhcigpIHtcbiAgICB0aGlzLmNhY2hlXyA9IHt9O1xuICAgIHRoaXMuY2FjaGVTaXplXyA9IDA7XG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7Ym9vbGVhbn0gQ2FuIGV4cGlyZSBjYWNoZS5cbiAgICovXG4gIGNhbkV4cGlyZUNhY2hlKCkge1xuICAgIHJldHVybiB0aGlzLmNhY2hlU2l6ZV8gPiB0aGlzLm1heENhY2hlU2l6ZV87XG4gIH1cblxuICAvKipcbiAgICogRklYTUUgZW1wdHkgZGVzY3JpcHRpb24gZm9yIGpzZG9jXG4gICAqL1xuICBleHBpcmUoKSB7XG4gICAgaWYgKHRoaXMuY2FuRXhwaXJlQ2FjaGUoKSkge1xuICAgICAgbGV0IGkgPSAwO1xuICAgICAgZm9yIChjb25zdCBrZXkgaW4gdGhpcy5jYWNoZV8pIHtcbiAgICAgICAgY29uc3QgaWNvbkltYWdlID0gdGhpcy5jYWNoZV9ba2V5XTtcbiAgICAgICAgaWYgKChpKysgJiAzKSA9PT0gMCAmJiAhaWNvbkltYWdlLmhhc0xpc3RlbmVyKCkpIHtcbiAgICAgICAgICBkZWxldGUgdGhpcy5jYWNoZV9ba2V5XTtcbiAgICAgICAgICAtLXRoaXMuY2FjaGVTaXplXztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gc3JjIFNyYy5cbiAgICogQHBhcmFtIHs/c3RyaW5nfSBjcm9zc09yaWdpbiBDcm9zcyBvcmlnaW4uXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vY29sb3IuanNcIikuQ29sb3J9IGNvbG9yIENvbG9yLlxuICAgKiBAcmV0dXJuIHtpbXBvcnQoXCIuL0ljb25JbWFnZS5qc1wiKS5kZWZhdWx0fSBJY29uIGltYWdlLlxuICAgKi9cbiAgZ2V0KHNyYywgY3Jvc3NPcmlnaW4sIGNvbG9yKSB7XG4gICAgY29uc3Qga2V5ID0gZ2V0S2V5KHNyYywgY3Jvc3NPcmlnaW4sIGNvbG9yKTtcbiAgICByZXR1cm4ga2V5IGluIHRoaXMuY2FjaGVfID8gdGhpcy5jYWNoZV9ba2V5XSA6IG51bGw7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtzdHJpbmd9IHNyYyBTcmMuXG4gICAqIEBwYXJhbSB7P3N0cmluZ30gY3Jvc3NPcmlnaW4gQ3Jvc3Mgb3JpZ2luLlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL2NvbG9yLmpzXCIpLkNvbG9yfSBjb2xvciBDb2xvci5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuL0ljb25JbWFnZS5qc1wiKS5kZWZhdWx0fSBpY29uSW1hZ2UgSWNvbiBpbWFnZS5cbiAgICovXG4gIHNldChzcmMsIGNyb3NzT3JpZ2luLCBjb2xvciwgaWNvbkltYWdlKSB7XG4gICAgY29uc3Qga2V5ID0gZ2V0S2V5KHNyYywgY3Jvc3NPcmlnaW4sIGNvbG9yKTtcbiAgICB0aGlzLmNhY2hlX1trZXldID0gaWNvbkltYWdlO1xuICAgICsrdGhpcy5jYWNoZVNpemVfO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldCB0aGUgY2FjaGUgc2l6ZSBvZiB0aGUgaWNvbiBjYWNoZS4gRGVmYXVsdCBpcyBgMzJgLiBDaGFuZ2UgdGhpcyB2YWx1ZSB3aGVuXG4gICAqIHlvdXIgbWFwIHVzZXMgbW9yZSB0aGFuIDMyIGRpZmZlcmVudCBpY29uIGltYWdlcyBhbmQgeW91IGFyZSBub3QgY2FjaGluZyBpY29uXG4gICAqIHN0eWxlcyBvbiB0aGUgYXBwbGljYXRpb24gbGV2ZWwuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBtYXhDYWNoZVNpemUgQ2FjaGUgbWF4IHNpemUuXG4gICAqIEBhcGlcbiAgICovXG4gIHNldFNpemUobWF4Q2FjaGVTaXplKSB7XG4gICAgdGhpcy5tYXhDYWNoZVNpemVfID0gbWF4Q2FjaGVTaXplO1xuICAgIHRoaXMuZXhwaXJlKCk7XG4gIH1cbn1cblxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30gc3JjIFNyYy5cbiAqIEBwYXJhbSB7P3N0cmluZ30gY3Jvc3NPcmlnaW4gQ3Jvc3Mgb3JpZ2luLlxuICogQHBhcmFtIHtpbXBvcnQoXCIuLi9jb2xvci5qc1wiKS5Db2xvcn0gY29sb3IgQ29sb3IuXG4gKiBAcmV0dXJuIHtzdHJpbmd9IENhY2hlIGtleS5cbiAqL1xuZnVuY3Rpb24gZ2V0S2V5KHNyYywgY3Jvc3NPcmlnaW4sIGNvbG9yKSB7XG4gIGNvbnN0IGNvbG9yU3RyaW5nID0gY29sb3IgPyBhc1N0cmluZyhjb2xvcikgOiAnbnVsbCc7XG4gIHJldHVybiBjcm9zc09yaWdpbiArICc6JyArIHNyYyArICc6JyArIGNvbG9yU3RyaW5nO1xufVxuXG5leHBvcnQgZGVmYXVsdCBJY29uSW1hZ2VDYWNoZTtcblxuLyoqXG4gKiBUaGUge0BsaW5rIG1vZHVsZTpvbC9zdHlsZS9JY29uSW1hZ2VDYWNoZX5JY29uSW1hZ2VDYWNoZX0gZm9yXG4gKiB7QGxpbmsgbW9kdWxlOm9sL3N0eWxlL0ljb25+SWNvbn0gaW1hZ2VzLlxuICogQGFwaVxuICovXG5leHBvcnQgY29uc3Qgc2hhcmVkID0gbmV3IEljb25JbWFnZUNhY2hlKCk7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///92710\n')},28443:function(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__){eval('/* harmony import */ var _util_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(74187);\n/* harmony import */ var _size_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(4307);\n/**\n * @module ol/style/Image\n */\n\n\n\n/**\n * @typedef {Object} Options\n * @property {number} opacity Opacity.\n * @property {boolean} rotateWithView If the image should get rotated with the view.\n * @property {number} rotation Rotation.\n * @property {number|import("../size.js").Size} scale Scale.\n * @property {Array<number>} displacement Displacement.\n * @property {"declutter"|"obstacle"|"none"|undefined} declutterMode Declutter mode: `declutter`, `obstacle`, \'none */\n\n/**\n * @classdesc\n * A base class used for creating subclasses and not instantiated in\n * apps. Base class for {@link module:ol/style/Icon~Icon}, {@link module:ol/style/Circle~CircleStyle} and\n * {@link module:ol/style/RegularShape~RegularShape}.\n * @abstract\n * @api\n */\nclass ImageStyle {\n  /**\n   * @param {Options} options Options.\n   */\n  constructor(options) {\n    /**\n     * @private\n     * @type {number}\n     */\n    this.opacity_ = options.opacity;\n\n    /**\n     * @private\n     * @type {boolean}\n     */\n    this.rotateWithView_ = options.rotateWithView;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.rotation_ = options.rotation;\n\n    /**\n     * @private\n     * @type {number|import("../size.js").Size}\n     */\n    this.scale_ = options.scale;\n\n    /**\n     * @private\n     * @type {import("../size.js").Size}\n     */\n    this.scaleArray_ = (0,_size_js__WEBPACK_IMPORTED_MODULE_0__/* .toSize */ .Pq)(options.scale);\n\n    /**\n     * @private\n     * @type {Array<number>}\n     */\n    this.displacement_ = options.displacement;\n\n    /**\n     * @private\n     * @type {"declutter"|"obstacle"|"none"|undefined}\n     */\n    this.declutterMode_ = options.declutterMode;\n  }\n\n  /**\n   * Clones the style.\n   * @return {ImageStyle} The cloned style.\n   * @api\n   */\n  clone() {\n    const scale = this.getScale();\n    return new ImageStyle({\n      opacity: this.getOpacity(),\n      scale: Array.isArray(scale) ? scale.slice() : scale,\n      rotation: this.getRotation(),\n      rotateWithView: this.getRotateWithView(),\n      displacement: this.getDisplacement().slice(),\n      declutterMode: this.getDeclutterMode(),\n    });\n  }\n\n  /**\n   * Get the symbolizer opacity.\n   * @return {number} Opacity.\n   * @api\n   */\n  getOpacity() {\n    return this.opacity_;\n  }\n\n  /**\n   * Determine whether the symbolizer rotates with the map.\n   * @return {boolean} Rotate with map.\n   * @api\n   */\n  getRotateWithView() {\n    return this.rotateWithView_;\n  }\n\n  /**\n   * Get the symoblizer rotation.\n   * @return {number} Rotation.\n   * @api\n   */\n  getRotation() {\n    return this.rotation_;\n  }\n\n  /**\n   * Get the symbolizer scale.\n   * @return {number|import("../size.js").Size} Scale.\n   * @api\n   */\n  getScale() {\n    return this.scale_;\n  }\n\n  /**\n   * Get the symbolizer scale array.\n   * @return {import("../size.js").Size} Scale array.\n   */\n  getScaleArray() {\n    return this.scaleArray_;\n  }\n\n  /**\n   * Get the displacement of the shape\n   * @return {Array<number>} Shape\'s center displacement\n   * @api\n   */\n  getDisplacement() {\n    return this.displacement_;\n  }\n\n  /**\n   * Get the declutter mode of the shape\n   * @return {"declutter"|"obstacle"|"none"|undefined} Shape\'s declutter mode\n   * @api\n   */\n  getDeclutterMode() {\n    return this.declutterMode_;\n  }\n\n  /**\n   * Get the anchor point in pixels. The anchor determines the center point for the\n   * symbolizer.\n   * @abstract\n   * @return {Array<number>} Anchor.\n   */\n  getAnchor() {\n    return (0,_util_js__WEBPACK_IMPORTED_MODULE_1__/* .abstract */ .O3)();\n  }\n\n  /**\n   * Get the image element for the symbolizer.\n   * @abstract\n   * @param {number} pixelRatio Pixel ratio.\n   * @return {HTMLCanvasElement|HTMLVideoElement|HTMLImageElement} Image element.\n   */\n  getImage(pixelRatio) {\n    return (0,_util_js__WEBPACK_IMPORTED_MODULE_1__/* .abstract */ .O3)();\n  }\n\n  /**\n   * @abstract\n   * @return {HTMLCanvasElement|HTMLVideoElement|HTMLImageElement} Image element.\n   */\n  getHitDetectionImage() {\n    return (0,_util_js__WEBPACK_IMPORTED_MODULE_1__/* .abstract */ .O3)();\n  }\n\n  /**\n   * Get the image pixel ratio.\n   * @param {number} pixelRatio Pixel ratio.\n   * @return {number} Pixel ratio.\n   */\n  getPixelRatio(pixelRatio) {\n    return 1;\n  }\n\n  /**\n   * @abstract\n   * @return {import("../ImageState.js").default} Image state.\n   */\n  getImageState() {\n    return (0,_util_js__WEBPACK_IMPORTED_MODULE_1__/* .abstract */ .O3)();\n  }\n\n  /**\n   * @abstract\n   * @return {import("../size.js").Size} Image size.\n   */\n  getImageSize() {\n    return (0,_util_js__WEBPACK_IMPORTED_MODULE_1__/* .abstract */ .O3)();\n  }\n\n  /**\n   * Get the origin of the symbolizer.\n   * @abstract\n   * @return {Array<number>} Origin.\n   */\n  getOrigin() {\n    return (0,_util_js__WEBPACK_IMPORTED_MODULE_1__/* .abstract */ .O3)();\n  }\n\n  /**\n   * Get the size of the symbolizer (in pixels).\n   * @abstract\n   * @return {import("../size.js").Size} Size.\n   */\n  getSize() {\n    return (0,_util_js__WEBPACK_IMPORTED_MODULE_1__/* .abstract */ .O3)();\n  }\n\n  /**\n   * Set the displacement.\n   *\n   * @param {Array<number>} displacement Displacement.\n   * @api\n   */\n  setDisplacement(displacement) {\n    this.displacement_ = displacement;\n  }\n\n  /**\n   * Set the opacity.\n   *\n   * @param {number} opacity Opacity.\n   * @api\n   */\n  setOpacity(opacity) {\n    this.opacity_ = opacity;\n  }\n\n  /**\n   * Set whether to rotate the style with the view.\n   *\n   * @param {boolean} rotateWithView Rotate with map.\n   * @api\n   */\n  setRotateWithView(rotateWithView) {\n    this.rotateWithView_ = rotateWithView;\n  }\n\n  /**\n   * Set the rotation.\n   *\n   * @param {number} rotation Rotation.\n   * @api\n   */\n  setRotation(rotation) {\n    this.rotation_ = rotation;\n  }\n\n  /**\n   * Set the scale.\n   *\n   * @param {number|import("../size.js").Size} scale Scale.\n   * @api\n   */\n  setScale(scale) {\n    this.scale_ = scale;\n    this.scaleArray_ = (0,_size_js__WEBPACK_IMPORTED_MODULE_0__/* .toSize */ .Pq)(scale);\n  }\n\n  /**\n   * @abstract\n   * @param {function(import("../events/Event.js").default): void} listener Listener function.\n   */\n  listenImageChange(listener) {\n    (0,_util_js__WEBPACK_IMPORTED_MODULE_1__/* .abstract */ .O3)();\n  }\n\n  /**\n   * Load not yet loaded URI.\n   * @abstract\n   */\n  load() {\n    (0,_util_js__WEBPACK_IMPORTED_MODULE_1__/* .abstract */ .O3)();\n  }\n\n  /**\n   * @abstract\n   * @param {function(import("../events/Event.js").default): void} listener Listener function.\n   */\n  unlistenImageChange(listener) {\n    (0,_util_js__WEBPACK_IMPORTED_MODULE_1__/* .abstract */ .O3)();\n  }\n}\n\n/* harmony default export */ __webpack_exports__["Z"] = (ImageStyle);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QztBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QiwwREFBTTtBQUM3Qjs7QUFFQTtBQUNBO0FBQ0EsYUFBYSxzREFBc0Q7QUFDbkU7QUFDQTtBQUNBLElBQUksNERBQVE7QUFDWjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSw0REFBUTtBQUNaOztBQUVBO0FBQ0E7QUFDQSxhQUFhLHNEQUFzRDtBQUNuRTtBQUNBO0FBQ0EsSUFBSSw0REFBUTtBQUNaO0FBQ0E7O0FBRUEseURBQWUsVUFBVSxFQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdnVlMy13ZWJwYWNrNS8uL25vZGVfbW9kdWxlcy9vbC9zdHlsZS9JbWFnZS5qcz9lYTgyIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQG1vZHVsZSBvbC9zdHlsZS9JbWFnZVxuICovXG5pbXBvcnQge2Fic3RyYWN0fSBmcm9tICcuLi91dGlsLmpzJztcbmltcG9ydCB7dG9TaXplfSBmcm9tICcuLi9zaXplLmpzJztcblxuLyoqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBPcHRpb25zXG4gKiBAcHJvcGVydHkge251bWJlcn0gb3BhY2l0eSBPcGFjaXR5LlxuICogQHByb3BlcnR5IHtib29sZWFufSByb3RhdGVXaXRoVmlldyBJZiB0aGUgaW1hZ2Ugc2hvdWxkIGdldCByb3RhdGVkIHdpdGggdGhlIHZpZXcuXG4gKiBAcHJvcGVydHkge251bWJlcn0gcm90YXRpb24gUm90YXRpb24uXG4gKiBAcHJvcGVydHkge251bWJlcnxpbXBvcnQoXCIuLi9zaXplLmpzXCIpLlNpemV9IHNjYWxlIFNjYWxlLlxuICogQHByb3BlcnR5IHtBcnJheTxudW1iZXI+fSBkaXNwbGFjZW1lbnQgRGlzcGxhY2VtZW50LlxuICogQHByb3BlcnR5IHtcImRlY2x1dHRlclwifFwib2JzdGFjbGVcInxcIm5vbmVcInx1bmRlZmluZWR9IGRlY2x1dHRlck1vZGUgRGVjbHV0dGVyIG1vZGU6IGBkZWNsdXR0ZXJgLCBgb2JzdGFjbGVgLCAnbm9uZSAqL1xuXG4vKipcbiAqIEBjbGFzc2Rlc2NcbiAqIEEgYmFzZSBjbGFzcyB1c2VkIGZvciBjcmVhdGluZyBzdWJjbGFzc2VzIGFuZCBub3QgaW5zdGFudGlhdGVkIGluXG4gKiBhcHBzLiBCYXNlIGNsYXNzIGZvciB7QGxpbmsgbW9kdWxlOm9sL3N0eWxlL0ljb25+SWNvbn0sIHtAbGluayBtb2R1bGU6b2wvc3R5bGUvQ2lyY2xlfkNpcmNsZVN0eWxlfSBhbmRcbiAqIHtAbGluayBtb2R1bGU6b2wvc3R5bGUvUmVndWxhclNoYXBlflJlZ3VsYXJTaGFwZX0uXG4gKiBAYWJzdHJhY3RcbiAqIEBhcGlcbiAqL1xuY2xhc3MgSW1hZ2VTdHlsZSB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge09wdGlvbnN9IG9wdGlvbnMgT3B0aW9ucy5cbiAgICovXG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5vcGFjaXR5XyA9IG9wdGlvbnMub3BhY2l0eTtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICovXG4gICAgdGhpcy5yb3RhdGVXaXRoVmlld18gPSBvcHRpb25zLnJvdGF0ZVdpdGhWaWV3O1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMucm90YXRpb25fID0gb3B0aW9ucy5yb3RhdGlvbjtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge251bWJlcnxpbXBvcnQoXCIuLi9zaXplLmpzXCIpLlNpemV9XG4gICAgICovXG4gICAgdGhpcy5zY2FsZV8gPSBvcHRpb25zLnNjYWxlO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7aW1wb3J0KFwiLi4vc2l6ZS5qc1wiKS5TaXplfVxuICAgICAqL1xuICAgIHRoaXMuc2NhbGVBcnJheV8gPSB0b1NpemUob3B0aW9ucy5zY2FsZSk7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtBcnJheTxudW1iZXI+fVxuICAgICAqL1xuICAgIHRoaXMuZGlzcGxhY2VtZW50XyA9IG9wdGlvbnMuZGlzcGxhY2VtZW50O1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7XCJkZWNsdXR0ZXJcInxcIm9ic3RhY2xlXCJ8XCJub25lXCJ8dW5kZWZpbmVkfVxuICAgICAqL1xuICAgIHRoaXMuZGVjbHV0dGVyTW9kZV8gPSBvcHRpb25zLmRlY2x1dHRlck1vZGU7XG4gIH1cblxuICAvKipcbiAgICogQ2xvbmVzIHRoZSBzdHlsZS5cbiAgICogQHJldHVybiB7SW1hZ2VTdHlsZX0gVGhlIGNsb25lZCBzdHlsZS5cbiAgICogQGFwaVxuICAgKi9cbiAgY2xvbmUoKSB7XG4gICAgY29uc3Qgc2NhbGUgPSB0aGlzLmdldFNjYWxlKCk7XG4gICAgcmV0dXJuIG5ldyBJbWFnZVN0eWxlKHtcbiAgICAgIG9wYWNpdHk6IHRoaXMuZ2V0T3BhY2l0eSgpLFxuICAgICAgc2NhbGU6IEFycmF5LmlzQXJyYXkoc2NhbGUpID8gc2NhbGUuc2xpY2UoKSA6IHNjYWxlLFxuICAgICAgcm90YXRpb246IHRoaXMuZ2V0Um90YXRpb24oKSxcbiAgICAgIHJvdGF0ZVdpdGhWaWV3OiB0aGlzLmdldFJvdGF0ZVdpdGhWaWV3KCksXG4gICAgICBkaXNwbGFjZW1lbnQ6IHRoaXMuZ2V0RGlzcGxhY2VtZW50KCkuc2xpY2UoKSxcbiAgICAgIGRlY2x1dHRlck1vZGU6IHRoaXMuZ2V0RGVjbHV0dGVyTW9kZSgpLFxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgc3ltYm9saXplciBvcGFjaXR5LlxuICAgKiBAcmV0dXJuIHtudW1iZXJ9IE9wYWNpdHkuXG4gICAqIEBhcGlcbiAgICovXG4gIGdldE9wYWNpdHkoKSB7XG4gICAgcmV0dXJuIHRoaXMub3BhY2l0eV87XG4gIH1cblxuICAvKipcbiAgICogRGV0ZXJtaW5lIHdoZXRoZXIgdGhlIHN5bWJvbGl6ZXIgcm90YXRlcyB3aXRoIHRoZSBtYXAuXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IFJvdGF0ZSB3aXRoIG1hcC5cbiAgICogQGFwaVxuICAgKi9cbiAgZ2V0Um90YXRlV2l0aFZpZXcoKSB7XG4gICAgcmV0dXJuIHRoaXMucm90YXRlV2l0aFZpZXdfO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgc3ltb2JsaXplciByb3RhdGlvbi5cbiAgICogQHJldHVybiB7bnVtYmVyfSBSb3RhdGlvbi5cbiAgICogQGFwaVxuICAgKi9cbiAgZ2V0Um90YXRpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMucm90YXRpb25fO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgc3ltYm9saXplciBzY2FsZS5cbiAgICogQHJldHVybiB7bnVtYmVyfGltcG9ydChcIi4uL3NpemUuanNcIikuU2l6ZX0gU2NhbGUuXG4gICAqIEBhcGlcbiAgICovXG4gIGdldFNjYWxlKCkge1xuICAgIHJldHVybiB0aGlzLnNjYWxlXztcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIHN5bWJvbGl6ZXIgc2NhbGUgYXJyYXkuXG4gICAqIEByZXR1cm4ge2ltcG9ydChcIi4uL3NpemUuanNcIikuU2l6ZX0gU2NhbGUgYXJyYXkuXG4gICAqL1xuICBnZXRTY2FsZUFycmF5KCkge1xuICAgIHJldHVybiB0aGlzLnNjYWxlQXJyYXlfO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgZGlzcGxhY2VtZW50IG9mIHRoZSBzaGFwZVxuICAgKiBAcmV0dXJuIHtBcnJheTxudW1iZXI+fSBTaGFwZSdzIGNlbnRlciBkaXNwbGFjZW1lbnRcbiAgICogQGFwaVxuICAgKi9cbiAgZ2V0RGlzcGxhY2VtZW50KCkge1xuICAgIHJldHVybiB0aGlzLmRpc3BsYWNlbWVudF87XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBkZWNsdXR0ZXIgbW9kZSBvZiB0aGUgc2hhcGVcbiAgICogQHJldHVybiB7XCJkZWNsdXR0ZXJcInxcIm9ic3RhY2xlXCJ8XCJub25lXCJ8dW5kZWZpbmVkfSBTaGFwZSdzIGRlY2x1dHRlciBtb2RlXG4gICAqIEBhcGlcbiAgICovXG4gIGdldERlY2x1dHRlck1vZGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuZGVjbHV0dGVyTW9kZV87XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBhbmNob3IgcG9pbnQgaW4gcGl4ZWxzLiBUaGUgYW5jaG9yIGRldGVybWluZXMgdGhlIGNlbnRlciBwb2ludCBmb3IgdGhlXG4gICAqIHN5bWJvbGl6ZXIuXG4gICAqIEBhYnN0cmFjdFxuICAgKiBAcmV0dXJuIHtBcnJheTxudW1iZXI+fSBBbmNob3IuXG4gICAqL1xuICBnZXRBbmNob3IoKSB7XG4gICAgcmV0dXJuIGFic3RyYWN0KCk7XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBpbWFnZSBlbGVtZW50IGZvciB0aGUgc3ltYm9saXplci5cbiAgICogQGFic3RyYWN0XG4gICAqIEBwYXJhbSB7bnVtYmVyfSBwaXhlbFJhdGlvIFBpeGVsIHJhdGlvLlxuICAgKiBAcmV0dXJuIHtIVE1MQ2FudmFzRWxlbWVudHxIVE1MVmlkZW9FbGVtZW50fEhUTUxJbWFnZUVsZW1lbnR9IEltYWdlIGVsZW1lbnQuXG4gICAqL1xuICBnZXRJbWFnZShwaXhlbFJhdGlvKSB7XG4gICAgcmV0dXJuIGFic3RyYWN0KCk7XG4gIH1cblxuICAvKipcbiAgICogQGFic3RyYWN0XG4gICAqIEByZXR1cm4ge0hUTUxDYW52YXNFbGVtZW50fEhUTUxWaWRlb0VsZW1lbnR8SFRNTEltYWdlRWxlbWVudH0gSW1hZ2UgZWxlbWVudC5cbiAgICovXG4gIGdldEhpdERldGVjdGlvbkltYWdlKCkge1xuICAgIHJldHVybiBhYnN0cmFjdCgpO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgaW1hZ2UgcGl4ZWwgcmF0aW8uXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBwaXhlbFJhdGlvIFBpeGVsIHJhdGlvLlxuICAgKiBAcmV0dXJuIHtudW1iZXJ9IFBpeGVsIHJhdGlvLlxuICAgKi9cbiAgZ2V0UGl4ZWxSYXRpbyhwaXhlbFJhdGlvKSB7XG4gICAgcmV0dXJuIDE7XG4gIH1cblxuICAvKipcbiAgICogQGFic3RyYWN0XG4gICAqIEByZXR1cm4ge2ltcG9ydChcIi4uL0ltYWdlU3RhdGUuanNcIikuZGVmYXVsdH0gSW1hZ2Ugc3RhdGUuXG4gICAqL1xuICBnZXRJbWFnZVN0YXRlKCkge1xuICAgIHJldHVybiBhYnN0cmFjdCgpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBhYnN0cmFjdFxuICAgKiBAcmV0dXJuIHtpbXBvcnQoXCIuLi9zaXplLmpzXCIpLlNpemV9IEltYWdlIHNpemUuXG4gICAqL1xuICBnZXRJbWFnZVNpemUoKSB7XG4gICAgcmV0dXJuIGFic3RyYWN0KCk7XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBvcmlnaW4gb2YgdGhlIHN5bWJvbGl6ZXIuXG4gICAqIEBhYnN0cmFjdFxuICAgKiBAcmV0dXJuIHtBcnJheTxudW1iZXI+fSBPcmlnaW4uXG4gICAqL1xuICBnZXRPcmlnaW4oKSB7XG4gICAgcmV0dXJuIGFic3RyYWN0KCk7XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBzaXplIG9mIHRoZSBzeW1ib2xpemVyIChpbiBwaXhlbHMpLlxuICAgKiBAYWJzdHJhY3RcbiAgICogQHJldHVybiB7aW1wb3J0KFwiLi4vc2l6ZS5qc1wiKS5TaXplfSBTaXplLlxuICAgKi9cbiAgZ2V0U2l6ZSgpIHtcbiAgICByZXR1cm4gYWJzdHJhY3QoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXQgdGhlIGRpc3BsYWNlbWVudC5cbiAgICpcbiAgICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSBkaXNwbGFjZW1lbnQgRGlzcGxhY2VtZW50LlxuICAgKiBAYXBpXG4gICAqL1xuICBzZXREaXNwbGFjZW1lbnQoZGlzcGxhY2VtZW50KSB7XG4gICAgdGhpcy5kaXNwbGFjZW1lbnRfID0gZGlzcGxhY2VtZW50O1xuICB9XG5cbiAgLyoqXG4gICAqIFNldCB0aGUgb3BhY2l0eS5cbiAgICpcbiAgICogQHBhcmFtIHtudW1iZXJ9IG9wYWNpdHkgT3BhY2l0eS5cbiAgICogQGFwaVxuICAgKi9cbiAgc2V0T3BhY2l0eShvcGFjaXR5KSB7XG4gICAgdGhpcy5vcGFjaXR5XyA9IG9wYWNpdHk7XG4gIH1cblxuICAvKipcbiAgICogU2V0IHdoZXRoZXIgdG8gcm90YXRlIHRoZSBzdHlsZSB3aXRoIHRoZSB2aWV3LlxuICAgKlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IHJvdGF0ZVdpdGhWaWV3IFJvdGF0ZSB3aXRoIG1hcC5cbiAgICogQGFwaVxuICAgKi9cbiAgc2V0Um90YXRlV2l0aFZpZXcocm90YXRlV2l0aFZpZXcpIHtcbiAgICB0aGlzLnJvdGF0ZVdpdGhWaWV3XyA9IHJvdGF0ZVdpdGhWaWV3O1xuICB9XG5cbiAgLyoqXG4gICAqIFNldCB0aGUgcm90YXRpb24uXG4gICAqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSByb3RhdGlvbiBSb3RhdGlvbi5cbiAgICogQGFwaVxuICAgKi9cbiAgc2V0Um90YXRpb24ocm90YXRpb24pIHtcbiAgICB0aGlzLnJvdGF0aW9uXyA9IHJvdGF0aW9uO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldCB0aGUgc2NhbGUuXG4gICAqXG4gICAqIEBwYXJhbSB7bnVtYmVyfGltcG9ydChcIi4uL3NpemUuanNcIikuU2l6ZX0gc2NhbGUgU2NhbGUuXG4gICAqIEBhcGlcbiAgICovXG4gIHNldFNjYWxlKHNjYWxlKSB7XG4gICAgdGhpcy5zY2FsZV8gPSBzY2FsZTtcbiAgICB0aGlzLnNjYWxlQXJyYXlfID0gdG9TaXplKHNjYWxlKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAYWJzdHJhY3RcbiAgICogQHBhcmFtIHtmdW5jdGlvbihpbXBvcnQoXCIuLi9ldmVudHMvRXZlbnQuanNcIikuZGVmYXVsdCk6IHZvaWR9IGxpc3RlbmVyIExpc3RlbmVyIGZ1bmN0aW9uLlxuICAgKi9cbiAgbGlzdGVuSW1hZ2VDaGFuZ2UobGlzdGVuZXIpIHtcbiAgICBhYnN0cmFjdCgpO1xuICB9XG5cbiAgLyoqXG4gICAqIExvYWQgbm90IHlldCBsb2FkZWQgVVJJLlxuICAgKiBAYWJzdHJhY3RcbiAgICovXG4gIGxvYWQoKSB7XG4gICAgYWJzdHJhY3QoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAYWJzdHJhY3RcbiAgICogQHBhcmFtIHtmdW5jdGlvbihpbXBvcnQoXCIuLi9ldmVudHMvRXZlbnQuanNcIikuZGVmYXVsdCk6IHZvaWR9IGxpc3RlbmVyIExpc3RlbmVyIGZ1bmN0aW9uLlxuICAgKi9cbiAgdW5saXN0ZW5JbWFnZUNoYW5nZShsaXN0ZW5lcikge1xuICAgIGFic3RyYWN0KCk7XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgSW1hZ2VTdHlsZTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///28443\n')},35393:function(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__){eval('/* harmony import */ var _ImageState_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(70553);\n/* harmony import */ var _Image_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(28443);\n/* harmony import */ var _color_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(79706);\n/* harmony import */ var _colorlike_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(96620);\n/* harmony import */ var _dom_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(68326);\n/* harmony import */ var _render_canvas_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(50147);\n/**\n * @module ol/style/RegularShape\n */\n\n\n\n\n\n\n\n\n/**\n * Specify radius for regular polygons, or radius1 and radius2 for stars.\n * @typedef {Object} Options\n * @property {import("./Fill.js").default} [fill] Fill style.\n * @property {number} points Number of points for stars and regular polygons. In case of a polygon, the number of points\n * is the number of sides.\n * @property {number} [radius] Radius of a regular polygon.\n * @property {number} [radius1] First radius of a star. Ignored if radius is set.\n * @property {number} [radius2] Second radius of a star.\n * @property {number} [angle=0] Shape\'s angle in radians. A value of 0 will have one of the shape\'s points facing up.\n * @property {Array<number>} [displacement=[0, 0]] Displacement of the shape in pixels.\n * Positive values will shift the shape right and up.\n * @property {import("./Stroke.js").default} [stroke] Stroke style.\n * @property {number} [rotation=0] Rotation in radians (positive rotation clockwise).\n * @property {boolean} [rotateWithView=false] Whether to rotate the shape with the view.\n * @property {number|import("../size.js").Size} [scale=1] Scale. Unless two dimensional scaling is required a better\n * result may be obtained with appropriate settings for `radius`, `radius1` and `radius2`.\n * @property {"declutter"|"obstacle"|"none"|undefined} [declutterMode] Declutter mode.\n */\n\n/**\n * @typedef {Object} RenderOptions\n * @property {import("../colorlike.js").ColorLike} [strokeStyle] StrokeStyle.\n * @property {number} strokeWidth StrokeWidth.\n * @property {number} size Size.\n * @property {Array<number>|null} lineDash LineDash.\n * @property {number} lineDashOffset LineDashOffset.\n * @property {CanvasLineJoin} lineJoin LineJoin.\n * @property {number} miterLimit MiterLimit.\n */\n\n/**\n * @classdesc\n * Set regular shape style for vector features. The resulting shape will be\n * a regular polygon when `radius` is provided, or a star when `radius1` and\n * `radius2` are provided.\n * @api\n */\nclass RegularShape extends _Image_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .Z {\n  /**\n   * @param {Options} options Options.\n   */\n  constructor(options) {\n    /**\n     * @type {boolean}\n     */\n    const rotateWithView =\n      options.rotateWithView !== undefined ? options.rotateWithView : false;\n\n    super({\n      opacity: 1,\n      rotateWithView: rotateWithView,\n      rotation: options.rotation !== undefined ? options.rotation : 0,\n      scale: options.scale !== undefined ? options.scale : 1,\n      displacement:\n        options.displacement !== undefined ? options.displacement : [0, 0],\n      declutterMode: options.declutterMode,\n    });\n\n    /**\n     * @private\n     * @type {Object<number, HTMLCanvasElement>}\n     */\n    this.canvas_ = undefined;\n\n    /**\n     * @private\n     * @type {HTMLCanvasElement}\n     */\n    this.hitDetectionCanvas_ = null;\n\n    /**\n     * @private\n     * @type {import("./Fill.js").default}\n     */\n    this.fill_ = options.fill !== undefined ? options.fill : null;\n\n    /**\n     * @private\n     * @type {Array<number>}\n     */\n    this.origin_ = [0, 0];\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.points_ = options.points;\n\n    /**\n     * @protected\n     * @type {number}\n     */\n    this.radius_ =\n      options.radius !== undefined ? options.radius : options.radius1;\n\n    /**\n     * @private\n     * @type {number|undefined}\n     */\n    this.radius2_ = options.radius2;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.angle_ = options.angle !== undefined ? options.angle : 0;\n\n    /**\n     * @private\n     * @type {import("./Stroke.js").default}\n     */\n    this.stroke_ = options.stroke !== undefined ? options.stroke : null;\n\n    /**\n     * @private\n     * @type {import("../size.js").Size}\n     */\n    this.size_ = null;\n\n    /**\n     * @private\n     * @type {RenderOptions}\n     */\n    this.renderOptions_ = null;\n\n    this.render();\n  }\n\n  /**\n   * Clones the style.\n   * @return {RegularShape} The cloned style.\n   * @api\n   */\n  clone() {\n    const scale = this.getScale();\n    const style = new RegularShape({\n      fill: this.getFill() ? this.getFill().clone() : undefined,\n      points: this.getPoints(),\n      radius: this.getRadius(),\n      radius2: this.getRadius2(),\n      angle: this.getAngle(),\n      stroke: this.getStroke() ? this.getStroke().clone() : undefined,\n      rotation: this.getRotation(),\n      rotateWithView: this.getRotateWithView(),\n      scale: Array.isArray(scale) ? scale.slice() : scale,\n      displacement: this.getDisplacement().slice(),\n      declutterMode: this.getDeclutterMode(),\n    });\n    style.setOpacity(this.getOpacity());\n    return style;\n  }\n\n  /**\n   * Get the anchor point in pixels. The anchor determines the center point for the\n   * symbolizer.\n   * @return {Array<number>} Anchor.\n   * @api\n   */\n  getAnchor() {\n    const size = this.size_;\n    if (!size) {\n      return null;\n    }\n    const displacement = this.getDisplacement();\n    const scale = this.getScaleArray();\n    // anchor is scaled by renderer but displacement should not be scaled\n    // so divide by scale here\n    return [\n      size[0] / 2 - displacement[0] / scale[0],\n      size[1] / 2 + displacement[1] / scale[1],\n    ];\n  }\n\n  /**\n   * Get the angle used in generating the shape.\n   * @return {number} Shape\'s rotation in radians.\n   * @api\n   */\n  getAngle() {\n    return this.angle_;\n  }\n\n  /**\n   * Get the fill style for the shape.\n   * @return {import("./Fill.js").default} Fill style.\n   * @api\n   */\n  getFill() {\n    return this.fill_;\n  }\n\n  /**\n   * Set the fill style.\n   * @param {import("./Fill.js").default} fill Fill style.\n   * @api\n   */\n  setFill(fill) {\n    this.fill_ = fill;\n    this.render();\n  }\n\n  /**\n   * @return {HTMLCanvasElement} Image element.\n   */\n  getHitDetectionImage() {\n    if (!this.hitDetectionCanvas_) {\n      this.createHitDetectionCanvas_(this.renderOptions_);\n    }\n    return this.hitDetectionCanvas_;\n  }\n\n  /**\n   * Get the image icon.\n   * @param {number} pixelRatio Pixel ratio.\n   * @return {HTMLCanvasElement} Image or Canvas element.\n   * @api\n   */\n  getImage(pixelRatio) {\n    let image = this.canvas_[pixelRatio];\n    if (!image) {\n      const renderOptions = this.renderOptions_;\n      const context = (0,_dom_js__WEBPACK_IMPORTED_MODULE_1__/* .createCanvasContext2D */ .E4)(\n        renderOptions.size * pixelRatio,\n        renderOptions.size * pixelRatio\n      );\n      this.draw_(renderOptions, context, pixelRatio);\n\n      image = context.canvas;\n      this.canvas_[pixelRatio] = image;\n    }\n    return image;\n  }\n\n  /**\n   * Get the image pixel ratio.\n   * @param {number} pixelRatio Pixel ratio.\n   * @return {number} Pixel ratio.\n   */\n  getPixelRatio(pixelRatio) {\n    return pixelRatio;\n  }\n\n  /**\n   * @return {import("../size.js").Size} Image size.\n   */\n  getImageSize() {\n    return this.size_;\n  }\n\n  /**\n   * @return {import("../ImageState.js").default} Image state.\n   */\n  getImageState() {\n    return _ImageState_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"].LOADED */ .Z.LOADED;\n  }\n\n  /**\n   * Get the origin of the symbolizer.\n   * @return {Array<number>} Origin.\n   * @api\n   */\n  getOrigin() {\n    return this.origin_;\n  }\n\n  /**\n   * Get the number of points for generating the shape.\n   * @return {number} Number of points for stars and regular polygons.\n   * @api\n   */\n  getPoints() {\n    return this.points_;\n  }\n\n  /**\n   * Get the (primary) radius for the shape.\n   * @return {number} Radius.\n   * @api\n   */\n  getRadius() {\n    return this.radius_;\n  }\n\n  /**\n   * Get the secondary radius for the shape.\n   * @return {number|undefined} Radius2.\n   * @api\n   */\n  getRadius2() {\n    return this.radius2_;\n  }\n\n  /**\n   * Get the size of the symbolizer (in pixels).\n   * @return {import("../size.js").Size} Size.\n   * @api\n   */\n  getSize() {\n    return this.size_;\n  }\n\n  /**\n   * Get the stroke style for the shape.\n   * @return {import("./Stroke.js").default} Stroke style.\n   * @api\n   */\n  getStroke() {\n    return this.stroke_;\n  }\n\n  /**\n   * Set the stroke style.\n   * @param {import("./Stroke.js").default} stroke Stroke style.\n   * @api\n   */\n  setStroke(stroke) {\n    this.stroke_ = stroke;\n    this.render();\n  }\n\n  /**\n   * @param {function(import("../events/Event.js").default): void} listener Listener function.\n   */\n  listenImageChange(listener) {}\n\n  /**\n   * Load not yet loaded URI.\n   */\n  load() {}\n\n  /**\n   * @param {function(import("../events/Event.js").default): void} listener Listener function.\n   */\n  unlistenImageChange(listener) {}\n\n  /**\n   * Calculate additional canvas size needed for the miter.\n   * @param {string} lineJoin Line join\n   * @param {number} strokeWidth Stroke width\n   * @param {number} miterLimit Miter limit\n   * @return {number} Additional canvas size needed\n   * @private\n   */\n  calculateLineJoinSize_(lineJoin, strokeWidth, miterLimit) {\n    if (\n      strokeWidth === 0 ||\n      this.points_ === Infinity ||\n      (lineJoin !== \'bevel\' && lineJoin !== \'miter\')\n    ) {\n      return strokeWidth;\n    }\n    // m  | ^\n    // i  | |\\                  .\n    // t >|  #\\\n    // e  | |\\ \\              .\n    // r      \\s\\\n    //      |  \\t\\          .                 .\n    //          \\r\\                      .   .\n    //      |    \\o\\      .          .  . . .\n    //          e \\k\\            .  .    . .\n    //      |      \\e\\  .    .  .       . .\n    //       d      \\ \\  .  .          . .\n    //      | _ _a_ _\\#  .            . .\n    //   r1          / `             . .\n    //      |                       . .\n    //       b     /               . .\n    //      |                     . .\n    //           / r2            . .\n    //      |                        .   .\n    //         /                           .   .\n    //      |α                                   .   .\n    //       /                                         .   .\n    //      ° center\n    let r1 = this.radius_;\n    let r2 = this.radius2_ === undefined ? r1 : this.radius2_;\n    if (r1 < r2) {\n      const tmp = r1;\n      r1 = r2;\n      r2 = tmp;\n    }\n    const points =\n      this.radius2_ === undefined ? this.points_ : this.points_ * 2;\n    const alpha = (2 * Math.PI) / points;\n    const a = r2 * Math.sin(alpha);\n    const b = Math.sqrt(r2 * r2 - a * a);\n    const d = r1 - b;\n    const e = Math.sqrt(a * a + d * d);\n    const miterRatio = e / a;\n    if (lineJoin === \'miter\' && miterRatio <= miterLimit) {\n      return miterRatio * strokeWidth;\n    }\n    // Calculate the distnce from center to the stroke corner where\n    // it was cut short because of the miter limit.\n    //              l\n    //        ----+---- <= distance from center to here is maxr\n    //       /####|k ##\\\n    //      /#####^#####\\\n    //     /#### /+\\# s #\\\n    //    /### h/+++\\# t #\\\n    //   /### t/+++++\\# r #\\\n    //  /### a/+++++++\\# o #\\\n    // /### p/++ fill +\\# k #\\\n    ///#### /+++++^+++++\\# e #\\\n    //#####/+++++/+\\+++++\\#####\\\n    const k = strokeWidth / 2 / miterRatio;\n    const l = (strokeWidth / 2) * (d / e);\n    const maxr = Math.sqrt((r1 + k) * (r1 + k) + l * l);\n    const bevelAdd = maxr - r1;\n    if (this.radius2_ === undefined || lineJoin === \'bevel\') {\n      return bevelAdd * 2;\n    }\n    // If outer miter is over the miter limit the inner miter may reach through the\n    // center and be longer than the bevel, same calculation as above but swap r1 / r2.\n    const aa = r1 * Math.sin(alpha);\n    const bb = Math.sqrt(r1 * r1 - aa * aa);\n    const dd = r2 - bb;\n    const ee = Math.sqrt(aa * aa + dd * dd);\n    const innerMiterRatio = ee / aa;\n    if (innerMiterRatio <= miterLimit) {\n      const innerLength = (innerMiterRatio * strokeWidth) / 2 - r2 - r1;\n      return 2 * Math.max(bevelAdd, innerLength);\n    }\n    return bevelAdd * 2;\n  }\n\n  /**\n   * @return {RenderOptions}  The render options\n   * @protected\n   */\n  createRenderOptions() {\n    let lineJoin = _render_canvas_js__WEBPACK_IMPORTED_MODULE_3__/* .defaultLineJoin */ .rc;\n    let miterLimit = 0;\n    let lineDash = null;\n    let lineDashOffset = 0;\n    let strokeStyle;\n    let strokeWidth = 0;\n\n    if (this.stroke_) {\n      strokeStyle = this.stroke_.getColor();\n      if (strokeStyle === null) {\n        strokeStyle = _render_canvas_js__WEBPACK_IMPORTED_MODULE_3__/* .defaultStrokeStyle */ .Tx;\n      }\n      strokeStyle = (0,_colorlike_js__WEBPACK_IMPORTED_MODULE_4__/* .asColorLike */ .y)(strokeStyle);\n      strokeWidth = this.stroke_.getWidth();\n      if (strokeWidth === undefined) {\n        strokeWidth = _render_canvas_js__WEBPACK_IMPORTED_MODULE_3__/* .defaultLineWidth */ .yC;\n      }\n      lineDash = this.stroke_.getLineDash();\n      lineDashOffset = this.stroke_.getLineDashOffset();\n      lineJoin = this.stroke_.getLineJoin();\n      if (lineJoin === undefined) {\n        lineJoin = _render_canvas_js__WEBPACK_IMPORTED_MODULE_3__/* .defaultLineJoin */ .rc;\n      }\n      miterLimit = this.stroke_.getMiterLimit();\n      if (miterLimit === undefined) {\n        miterLimit = _render_canvas_js__WEBPACK_IMPORTED_MODULE_3__/* .defaultMiterLimit */ .V4;\n      }\n    }\n\n    const add = this.calculateLineJoinSize_(lineJoin, strokeWidth, miterLimit);\n    const maxRadius = Math.max(this.radius_, this.radius2_ || 0);\n    const size = Math.ceil(2 * maxRadius + add);\n\n    return {\n      strokeStyle: strokeStyle,\n      strokeWidth: strokeWidth,\n      size: size,\n      lineDash: lineDash,\n      lineDashOffset: lineDashOffset,\n      lineJoin: lineJoin,\n      miterLimit: miterLimit,\n    };\n  }\n\n  /**\n   * @protected\n   */\n  render() {\n    this.renderOptions_ = this.createRenderOptions();\n    const size = this.renderOptions_.size;\n    this.canvas_ = {};\n    this.size_ = [size, size];\n  }\n\n  /**\n   * @private\n   * @param {RenderOptions} renderOptions Render options.\n   * @param {CanvasRenderingContext2D} context The rendering context.\n   * @param {number} pixelRatio The pixel ratio.\n   */\n  draw_(renderOptions, context, pixelRatio) {\n    context.scale(pixelRatio, pixelRatio);\n    // set origin to canvas center\n    context.translate(renderOptions.size / 2, renderOptions.size / 2);\n\n    this.createPath_(context);\n\n    if (this.fill_) {\n      let color = this.fill_.getColor();\n      if (color === null) {\n        color = _render_canvas_js__WEBPACK_IMPORTED_MODULE_3__/* .defaultFillStyle */ .bL;\n      }\n      context.fillStyle = (0,_colorlike_js__WEBPACK_IMPORTED_MODULE_4__/* .asColorLike */ .y)(color);\n      context.fill();\n    }\n    if (this.stroke_) {\n      context.strokeStyle = renderOptions.strokeStyle;\n      context.lineWidth = renderOptions.strokeWidth;\n      if (renderOptions.lineDash) {\n        context.setLineDash(renderOptions.lineDash);\n        context.lineDashOffset = renderOptions.lineDashOffset;\n      }\n      context.lineJoin = renderOptions.lineJoin;\n      context.miterLimit = renderOptions.miterLimit;\n      context.stroke();\n    }\n  }\n\n  /**\n   * @private\n   * @param {RenderOptions} renderOptions Render options.\n   */\n  createHitDetectionCanvas_(renderOptions) {\n    if (this.fill_) {\n      let color = this.fill_.getColor();\n\n      // determine if fill is transparent (or pattern or gradient)\n      let opacity = 0;\n      if (typeof color === \'string\') {\n        color = (0,_color_js__WEBPACK_IMPORTED_MODULE_5__/* .asArray */ ._2)(color);\n      }\n      if (color === null) {\n        opacity = 1;\n      } else if (Array.isArray(color)) {\n        opacity = color.length === 4 ? color[3] : 1;\n      }\n      if (opacity === 0) {\n        // if a transparent fill style is set, create an extra hit-detection image\n        // with a default fill style\n        const context = (0,_dom_js__WEBPACK_IMPORTED_MODULE_1__/* .createCanvasContext2D */ .E4)(\n          renderOptions.size,\n          renderOptions.size\n        );\n        this.hitDetectionCanvas_ = context.canvas;\n\n        this.drawHitDetectionCanvas_(renderOptions, context);\n      }\n    }\n    if (!this.hitDetectionCanvas_) {\n      this.hitDetectionCanvas_ = this.getImage(1);\n    }\n  }\n\n  /**\n   * @private\n   * @param {CanvasRenderingContext2D} context The context to draw in.\n   */\n  createPath_(context) {\n    let points = this.points_;\n    const radius = this.radius_;\n    if (points === Infinity) {\n      context.arc(0, 0, radius, 0, 2 * Math.PI);\n    } else {\n      const radius2 = this.radius2_ === undefined ? radius : this.radius2_;\n      if (this.radius2_ !== undefined) {\n        points *= 2;\n      }\n      const startAngle = this.angle_ - Math.PI / 2;\n      const step = (2 * Math.PI) / points;\n      for (let i = 0; i < points; i++) {\n        const angle0 = startAngle + i * step;\n        const radiusC = i % 2 === 0 ? radius : radius2;\n        context.lineTo(radiusC * Math.cos(angle0), radiusC * Math.sin(angle0));\n      }\n      context.closePath();\n    }\n  }\n\n  /**\n   * @private\n   * @param {RenderOptions} renderOptions Render options.\n   * @param {CanvasRenderingContext2D} context The context.\n   */\n  drawHitDetectionCanvas_(renderOptions, context) {\n    // set origin to canvas center\n    context.translate(renderOptions.size / 2, renderOptions.size / 2);\n\n    this.createPath_(context);\n\n    context.fillStyle = _render_canvas_js__WEBPACK_IMPORTED_MODULE_3__/* .defaultFillStyle */ .bL;\n    context.fill();\n    if (this.stroke_) {\n      context.strokeStyle = renderOptions.strokeStyle;\n      context.lineWidth = renderOptions.strokeWidth;\n      if (renderOptions.lineDash) {\n        context.setLineDash(renderOptions.lineDash);\n        context.lineDashOffset = renderOptions.lineDashOffset;\n      }\n      context.lineJoin = renderOptions.lineJoin;\n      context.miterLimit = renderOptions.miterLimit;\n      context.stroke();\n    }\n  }\n}\n\n/* harmony default export */ __webpack_exports__["Z"] = (RegularShape);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixZQUFZO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxhQUFhLGVBQWU7QUFDNUIsYUFBYSwwQkFBMEI7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsd0JBQXdCLHlFQUFnQjtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHlEQUFlLFlBQVksRUFBQyIsInNvdXJjZXMiOlsid2VicGFjazovL3Z1ZTMtd2VicGFjazUvLi9ub2RlX21vZHVsZXMvb2wvc3R5bGUvUmVndWxhclNoYXBlLmpzPzU0MjgiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAbW9kdWxlIG9sL3N0eWxlL1JlZ3VsYXJTaGFwZVxuICovXG5cbmltcG9ydCBJbWFnZVN0YXRlIGZyb20gJy4uL0ltYWdlU3RhdGUuanMnO1xuaW1wb3J0IEltYWdlU3R5bGUgZnJvbSAnLi9JbWFnZS5qcyc7XG5pbXBvcnQge2FzQXJyYXl9IGZyb20gJy4uL2NvbG9yLmpzJztcbmltcG9ydCB7YXNDb2xvckxpa2V9IGZyb20gJy4uL2NvbG9ybGlrZS5qcyc7XG5pbXBvcnQge2NyZWF0ZUNhbnZhc0NvbnRleHQyRH0gZnJvbSAnLi4vZG9tLmpzJztcbmltcG9ydCB7XG4gIGRlZmF1bHRGaWxsU3R5bGUsXG4gIGRlZmF1bHRMaW5lSm9pbixcbiAgZGVmYXVsdExpbmVXaWR0aCxcbiAgZGVmYXVsdE1pdGVyTGltaXQsXG4gIGRlZmF1bHRTdHJva2VTdHlsZSxcbn0gZnJvbSAnLi4vcmVuZGVyL2NhbnZhcy5qcyc7XG5cbi8qKlxuICogU3BlY2lmeSByYWRpdXMgZm9yIHJlZ3VsYXIgcG9seWdvbnMsIG9yIHJhZGl1czEgYW5kIHJhZGl1czIgZm9yIHN0YXJzLlxuICogQHR5cGVkZWYge09iamVjdH0gT3B0aW9uc1xuICogQHByb3BlcnR5IHtpbXBvcnQoXCIuL0ZpbGwuanNcIikuZGVmYXVsdH0gW2ZpbGxdIEZpbGwgc3R5bGUuXG4gKiBAcHJvcGVydHkge251bWJlcn0gcG9pbnRzIE51bWJlciBvZiBwb2ludHMgZm9yIHN0YXJzIGFuZCByZWd1bGFyIHBvbHlnb25zLiBJbiBjYXNlIG9mIGEgcG9seWdvbiwgdGhlIG51bWJlciBvZiBwb2ludHNcbiAqIGlzIHRoZSBudW1iZXIgb2Ygc2lkZXMuXG4gKiBAcHJvcGVydHkge251bWJlcn0gW3JhZGl1c10gUmFkaXVzIG9mIGEgcmVndWxhciBwb2x5Z29uLlxuICogQHByb3BlcnR5IHtudW1iZXJ9IFtyYWRpdXMxXSBGaXJzdCByYWRpdXMgb2YgYSBzdGFyLiBJZ25vcmVkIGlmIHJhZGl1cyBpcyBzZXQuXG4gKiBAcHJvcGVydHkge251bWJlcn0gW3JhZGl1czJdIFNlY29uZCByYWRpdXMgb2YgYSBzdGFyLlxuICogQHByb3BlcnR5IHtudW1iZXJ9IFthbmdsZT0wXSBTaGFwZSdzIGFuZ2xlIGluIHJhZGlhbnMuIEEgdmFsdWUgb2YgMCB3aWxsIGhhdmUgb25lIG9mIHRoZSBzaGFwZSdzIHBvaW50cyBmYWNpbmcgdXAuXG4gKiBAcHJvcGVydHkge0FycmF5PG51bWJlcj59IFtkaXNwbGFjZW1lbnQ9WzAsIDBdXSBEaXNwbGFjZW1lbnQgb2YgdGhlIHNoYXBlIGluIHBpeGVscy5cbiAqIFBvc2l0aXZlIHZhbHVlcyB3aWxsIHNoaWZ0IHRoZSBzaGFwZSByaWdodCBhbmQgdXAuXG4gKiBAcHJvcGVydHkge2ltcG9ydChcIi4vU3Ryb2tlLmpzXCIpLmRlZmF1bHR9IFtzdHJva2VdIFN0cm9rZSBzdHlsZS5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbcm90YXRpb249MF0gUm90YXRpb24gaW4gcmFkaWFucyAocG9zaXRpdmUgcm90YXRpb24gY2xvY2t3aXNlKS5cbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW3JvdGF0ZVdpdGhWaWV3PWZhbHNlXSBXaGV0aGVyIHRvIHJvdGF0ZSB0aGUgc2hhcGUgd2l0aCB0aGUgdmlldy5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfGltcG9ydChcIi4uL3NpemUuanNcIikuU2l6ZX0gW3NjYWxlPTFdIFNjYWxlLiBVbmxlc3MgdHdvIGRpbWVuc2lvbmFsIHNjYWxpbmcgaXMgcmVxdWlyZWQgYSBiZXR0ZXJcbiAqIHJlc3VsdCBtYXkgYmUgb2J0YWluZWQgd2l0aCBhcHByb3ByaWF0ZSBzZXR0aW5ncyBmb3IgYHJhZGl1c2AsIGByYWRpdXMxYCBhbmQgYHJhZGl1czJgLlxuICogQHByb3BlcnR5IHtcImRlY2x1dHRlclwifFwib2JzdGFjbGVcInxcIm5vbmVcInx1bmRlZmluZWR9IFtkZWNsdXR0ZXJNb2RlXSBEZWNsdXR0ZXIgbW9kZS5cbiAqL1xuXG4vKipcbiAqIEB0eXBlZGVmIHtPYmplY3R9IFJlbmRlck9wdGlvbnNcbiAqIEBwcm9wZXJ0eSB7aW1wb3J0KFwiLi4vY29sb3JsaWtlLmpzXCIpLkNvbG9yTGlrZX0gW3N0cm9rZVN0eWxlXSBTdHJva2VTdHlsZS5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBzdHJva2VXaWR0aCBTdHJva2VXaWR0aC5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBzaXplIFNpemUuXG4gKiBAcHJvcGVydHkge0FycmF5PG51bWJlcj58bnVsbH0gbGluZURhc2ggTGluZURhc2guXG4gKiBAcHJvcGVydHkge251bWJlcn0gbGluZURhc2hPZmZzZXQgTGluZURhc2hPZmZzZXQuXG4gKiBAcHJvcGVydHkge0NhbnZhc0xpbmVKb2lufSBsaW5lSm9pbiBMaW5lSm9pbi5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBtaXRlckxpbWl0IE1pdGVyTGltaXQuXG4gKi9cblxuLyoqXG4gKiBAY2xhc3NkZXNjXG4gKiBTZXQgcmVndWxhciBzaGFwZSBzdHlsZSBmb3IgdmVjdG9yIGZlYXR1cmVzLiBUaGUgcmVzdWx0aW5nIHNoYXBlIHdpbGwgYmVcbiAqIGEgcmVndWxhciBwb2x5Z29uIHdoZW4gYHJhZGl1c2AgaXMgcHJvdmlkZWQsIG9yIGEgc3RhciB3aGVuIGByYWRpdXMxYCBhbmRcbiAqIGByYWRpdXMyYCBhcmUgcHJvdmlkZWQuXG4gKiBAYXBpXG4gKi9cbmNsYXNzIFJlZ3VsYXJTaGFwZSBleHRlbmRzIEltYWdlU3R5bGUge1xuICAvKipcbiAgICogQHBhcmFtIHtPcHRpb25zfSBvcHRpb25zIE9wdGlvbnMuXG4gICAqL1xuICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgLyoqXG4gICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICovXG4gICAgY29uc3Qgcm90YXRlV2l0aFZpZXcgPVxuICAgICAgb3B0aW9ucy5yb3RhdGVXaXRoVmlldyAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5yb3RhdGVXaXRoVmlldyA6IGZhbHNlO1xuXG4gICAgc3VwZXIoe1xuICAgICAgb3BhY2l0eTogMSxcbiAgICAgIHJvdGF0ZVdpdGhWaWV3OiByb3RhdGVXaXRoVmlldyxcbiAgICAgIHJvdGF0aW9uOiBvcHRpb25zLnJvdGF0aW9uICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLnJvdGF0aW9uIDogMCxcbiAgICAgIHNjYWxlOiBvcHRpb25zLnNjYWxlICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLnNjYWxlIDogMSxcbiAgICAgIGRpc3BsYWNlbWVudDpcbiAgICAgICAgb3B0aW9ucy5kaXNwbGFjZW1lbnQgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMuZGlzcGxhY2VtZW50IDogWzAsIDBdLFxuICAgICAgZGVjbHV0dGVyTW9kZTogb3B0aW9ucy5kZWNsdXR0ZXJNb2RlLFxuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7T2JqZWN0PG51bWJlciwgSFRNTENhbnZhc0VsZW1lbnQ+fVxuICAgICAqL1xuICAgIHRoaXMuY2FudmFzXyA9IHVuZGVmaW5lZDtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge0hUTUxDYW52YXNFbGVtZW50fVxuICAgICAqL1xuICAgIHRoaXMuaGl0RGV0ZWN0aW9uQ2FudmFzXyA9IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtpbXBvcnQoXCIuL0ZpbGwuanNcIikuZGVmYXVsdH1cbiAgICAgKi9cbiAgICB0aGlzLmZpbGxfID0gb3B0aW9ucy5maWxsICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLmZpbGwgOiBudWxsO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7QXJyYXk8bnVtYmVyPn1cbiAgICAgKi9cbiAgICB0aGlzLm9yaWdpbl8gPSBbMCwgMF07XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5wb2ludHNfID0gb3B0aW9ucy5wb2ludHM7XG5cbiAgICAvKipcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLnJhZGl1c18gPVxuICAgICAgb3B0aW9ucy5yYWRpdXMgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMucmFkaXVzIDogb3B0aW9ucy5yYWRpdXMxO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7bnVtYmVyfHVuZGVmaW5lZH1cbiAgICAgKi9cbiAgICB0aGlzLnJhZGl1czJfID0gb3B0aW9ucy5yYWRpdXMyO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMuYW5nbGVfID0gb3B0aW9ucy5hbmdsZSAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5hbmdsZSA6IDA7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtpbXBvcnQoXCIuL1N0cm9rZS5qc1wiKS5kZWZhdWx0fVxuICAgICAqL1xuICAgIHRoaXMuc3Ryb2tlXyA9IG9wdGlvbnMuc3Ryb2tlICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLnN0cm9rZSA6IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtpbXBvcnQoXCIuLi9zaXplLmpzXCIpLlNpemV9XG4gICAgICovXG4gICAgdGhpcy5zaXplXyA9IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtSZW5kZXJPcHRpb25zfVxuICAgICAqL1xuICAgIHRoaXMucmVuZGVyT3B0aW9uc18gPSBudWxsO1xuXG4gICAgdGhpcy5yZW5kZXIoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDbG9uZXMgdGhlIHN0eWxlLlxuICAgKiBAcmV0dXJuIHtSZWd1bGFyU2hhcGV9IFRoZSBjbG9uZWQgc3R5bGUuXG4gICAqIEBhcGlcbiAgICovXG4gIGNsb25lKCkge1xuICAgIGNvbnN0IHNjYWxlID0gdGhpcy5nZXRTY2FsZSgpO1xuICAgIGNvbnN0IHN0eWxlID0gbmV3IFJlZ3VsYXJTaGFwZSh7XG4gICAgICBmaWxsOiB0aGlzLmdldEZpbGwoKSA/IHRoaXMuZ2V0RmlsbCgpLmNsb25lKCkgOiB1bmRlZmluZWQsXG4gICAgICBwb2ludHM6IHRoaXMuZ2V0UG9pbnRzKCksXG4gICAgICByYWRpdXM6IHRoaXMuZ2V0UmFkaXVzKCksXG4gICAgICByYWRpdXMyOiB0aGlzLmdldFJhZGl1czIoKSxcbiAgICAgIGFuZ2xlOiB0aGlzLmdldEFuZ2xlKCksXG4gICAgICBzdHJva2U6IHRoaXMuZ2V0U3Ryb2tlKCkgPyB0aGlzLmdldFN0cm9rZSgpLmNsb25lKCkgOiB1bmRlZmluZWQsXG4gICAgICByb3RhdGlvbjogdGhpcy5nZXRSb3RhdGlvbigpLFxuICAgICAgcm90YXRlV2l0aFZpZXc6IHRoaXMuZ2V0Um90YXRlV2l0aFZpZXcoKSxcbiAgICAgIHNjYWxlOiBBcnJheS5pc0FycmF5KHNjYWxlKSA/IHNjYWxlLnNsaWNlKCkgOiBzY2FsZSxcbiAgICAgIGRpc3BsYWNlbWVudDogdGhpcy5nZXREaXNwbGFjZW1lbnQoKS5zbGljZSgpLFxuICAgICAgZGVjbHV0dGVyTW9kZTogdGhpcy5nZXREZWNsdXR0ZXJNb2RlKCksXG4gICAgfSk7XG4gICAgc3R5bGUuc2V0T3BhY2l0eSh0aGlzLmdldE9wYWNpdHkoKSk7XG4gICAgcmV0dXJuIHN0eWxlO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgYW5jaG9yIHBvaW50IGluIHBpeGVscy4gVGhlIGFuY2hvciBkZXRlcm1pbmVzIHRoZSBjZW50ZXIgcG9pbnQgZm9yIHRoZVxuICAgKiBzeW1ib2xpemVyLlxuICAgKiBAcmV0dXJuIHtBcnJheTxudW1iZXI+fSBBbmNob3IuXG4gICAqIEBhcGlcbiAgICovXG4gIGdldEFuY2hvcigpIHtcbiAgICBjb25zdCBzaXplID0gdGhpcy5zaXplXztcbiAgICBpZiAoIXNpemUpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBjb25zdCBkaXNwbGFjZW1lbnQgPSB0aGlzLmdldERpc3BsYWNlbWVudCgpO1xuICAgIGNvbnN0IHNjYWxlID0gdGhpcy5nZXRTY2FsZUFycmF5KCk7XG4gICAgLy8gYW5jaG9yIGlzIHNjYWxlZCBieSByZW5kZXJlciBidXQgZGlzcGxhY2VtZW50IHNob3VsZCBub3QgYmUgc2NhbGVkXG4gICAgLy8gc28gZGl2aWRlIGJ5IHNjYWxlIGhlcmVcbiAgICByZXR1cm4gW1xuICAgICAgc2l6ZVswXSAvIDIgLSBkaXNwbGFjZW1lbnRbMF0gLyBzY2FsZVswXSxcbiAgICAgIHNpemVbMV0gLyAyICsgZGlzcGxhY2VtZW50WzFdIC8gc2NhbGVbMV0sXG4gICAgXTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIGFuZ2xlIHVzZWQgaW4gZ2VuZXJhdGluZyB0aGUgc2hhcGUuXG4gICAqIEByZXR1cm4ge251bWJlcn0gU2hhcGUncyByb3RhdGlvbiBpbiByYWRpYW5zLlxuICAgKiBAYXBpXG4gICAqL1xuICBnZXRBbmdsZSgpIHtcbiAgICByZXR1cm4gdGhpcy5hbmdsZV87XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBmaWxsIHN0eWxlIGZvciB0aGUgc2hhcGUuXG4gICAqIEByZXR1cm4ge2ltcG9ydChcIi4vRmlsbC5qc1wiKS5kZWZhdWx0fSBGaWxsIHN0eWxlLlxuICAgKiBAYXBpXG4gICAqL1xuICBnZXRGaWxsKCkge1xuICAgIHJldHVybiB0aGlzLmZpbGxfO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldCB0aGUgZmlsbCBzdHlsZS5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuL0ZpbGwuanNcIikuZGVmYXVsdH0gZmlsbCBGaWxsIHN0eWxlLlxuICAgKiBAYXBpXG4gICAqL1xuICBzZXRGaWxsKGZpbGwpIHtcbiAgICB0aGlzLmZpbGxfID0gZmlsbDtcbiAgICB0aGlzLnJlbmRlcigpO1xuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge0hUTUxDYW52YXNFbGVtZW50fSBJbWFnZSBlbGVtZW50LlxuICAgKi9cbiAgZ2V0SGl0RGV0ZWN0aW9uSW1hZ2UoKSB7XG4gICAgaWYgKCF0aGlzLmhpdERldGVjdGlvbkNhbnZhc18pIHtcbiAgICAgIHRoaXMuY3JlYXRlSGl0RGV0ZWN0aW9uQ2FudmFzXyh0aGlzLnJlbmRlck9wdGlvbnNfKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuaGl0RGV0ZWN0aW9uQ2FudmFzXztcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIGltYWdlIGljb24uXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBwaXhlbFJhdGlvIFBpeGVsIHJhdGlvLlxuICAgKiBAcmV0dXJuIHtIVE1MQ2FudmFzRWxlbWVudH0gSW1hZ2Ugb3IgQ2FudmFzIGVsZW1lbnQuXG4gICAqIEBhcGlcbiAgICovXG4gIGdldEltYWdlKHBpeGVsUmF0aW8pIHtcbiAgICBsZXQgaW1hZ2UgPSB0aGlzLmNhbnZhc19bcGl4ZWxSYXRpb107XG4gICAgaWYgKCFpbWFnZSkge1xuICAgICAgY29uc3QgcmVuZGVyT3B0aW9ucyA9IHRoaXMucmVuZGVyT3B0aW9uc187XG4gICAgICBjb25zdCBjb250ZXh0ID0gY3JlYXRlQ2FudmFzQ29udGV4dDJEKFxuICAgICAgICByZW5kZXJPcHRpb25zLnNpemUgKiBwaXhlbFJhdGlvLFxuICAgICAgICByZW5kZXJPcHRpb25zLnNpemUgKiBwaXhlbFJhdGlvXG4gICAgICApO1xuICAgICAgdGhpcy5kcmF3XyhyZW5kZXJPcHRpb25zLCBjb250ZXh0LCBwaXhlbFJhdGlvKTtcblxuICAgICAgaW1hZ2UgPSBjb250ZXh0LmNhbnZhcztcbiAgICAgIHRoaXMuY2FudmFzX1twaXhlbFJhdGlvXSA9IGltYWdlO1xuICAgIH1cbiAgICByZXR1cm4gaW1hZ2U7XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBpbWFnZSBwaXhlbCByYXRpby5cbiAgICogQHBhcmFtIHtudW1iZXJ9IHBpeGVsUmF0aW8gUGl4ZWwgcmF0aW8uXG4gICAqIEByZXR1cm4ge251bWJlcn0gUGl4ZWwgcmF0aW8uXG4gICAqL1xuICBnZXRQaXhlbFJhdGlvKHBpeGVsUmF0aW8pIHtcbiAgICByZXR1cm4gcGl4ZWxSYXRpbztcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtpbXBvcnQoXCIuLi9zaXplLmpzXCIpLlNpemV9IEltYWdlIHNpemUuXG4gICAqL1xuICBnZXRJbWFnZVNpemUoKSB7XG4gICAgcmV0dXJuIHRoaXMuc2l6ZV87XG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7aW1wb3J0KFwiLi4vSW1hZ2VTdGF0ZS5qc1wiKS5kZWZhdWx0fSBJbWFnZSBzdGF0ZS5cbiAgICovXG4gIGdldEltYWdlU3RhdGUoKSB7XG4gICAgcmV0dXJuIEltYWdlU3RhdGUuTE9BREVEO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgb3JpZ2luIG9mIHRoZSBzeW1ib2xpemVyLlxuICAgKiBAcmV0dXJuIHtBcnJheTxudW1iZXI+fSBPcmlnaW4uXG4gICAqIEBhcGlcbiAgICovXG4gIGdldE9yaWdpbigpIHtcbiAgICByZXR1cm4gdGhpcy5vcmlnaW5fO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgbnVtYmVyIG9mIHBvaW50cyBmb3IgZ2VuZXJhdGluZyB0aGUgc2hhcGUuXG4gICAqIEByZXR1cm4ge251bWJlcn0gTnVtYmVyIG9mIHBvaW50cyBmb3Igc3RhcnMgYW5kIHJlZ3VsYXIgcG9seWdvbnMuXG4gICAqIEBhcGlcbiAgICovXG4gIGdldFBvaW50cygpIHtcbiAgICByZXR1cm4gdGhpcy5wb2ludHNfO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgKHByaW1hcnkpIHJhZGl1cyBmb3IgdGhlIHNoYXBlLlxuICAgKiBAcmV0dXJuIHtudW1iZXJ9IFJhZGl1cy5cbiAgICogQGFwaVxuICAgKi9cbiAgZ2V0UmFkaXVzKCkge1xuICAgIHJldHVybiB0aGlzLnJhZGl1c187XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBzZWNvbmRhcnkgcmFkaXVzIGZvciB0aGUgc2hhcGUuXG4gICAqIEByZXR1cm4ge251bWJlcnx1bmRlZmluZWR9IFJhZGl1czIuXG4gICAqIEBhcGlcbiAgICovXG4gIGdldFJhZGl1czIoKSB7XG4gICAgcmV0dXJuIHRoaXMucmFkaXVzMl87XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBzaXplIG9mIHRoZSBzeW1ib2xpemVyIChpbiBwaXhlbHMpLlxuICAgKiBAcmV0dXJuIHtpbXBvcnQoXCIuLi9zaXplLmpzXCIpLlNpemV9IFNpemUuXG4gICAqIEBhcGlcbiAgICovXG4gIGdldFNpemUoKSB7XG4gICAgcmV0dXJuIHRoaXMuc2l6ZV87XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBzdHJva2Ugc3R5bGUgZm9yIHRoZSBzaGFwZS5cbiAgICogQHJldHVybiB7aW1wb3J0KFwiLi9TdHJva2UuanNcIikuZGVmYXVsdH0gU3Ryb2tlIHN0eWxlLlxuICAgKiBAYXBpXG4gICAqL1xuICBnZXRTdHJva2UoKSB7XG4gICAgcmV0dXJuIHRoaXMuc3Ryb2tlXztcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXQgdGhlIHN0cm9rZSBzdHlsZS5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuL1N0cm9rZS5qc1wiKS5kZWZhdWx0fSBzdHJva2UgU3Ryb2tlIHN0eWxlLlxuICAgKiBAYXBpXG4gICAqL1xuICBzZXRTdHJva2Uoc3Ryb2tlKSB7XG4gICAgdGhpcy5zdHJva2VfID0gc3Ryb2tlO1xuICAgIHRoaXMucmVuZGVyKCk7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtmdW5jdGlvbihpbXBvcnQoXCIuLi9ldmVudHMvRXZlbnQuanNcIikuZGVmYXVsdCk6IHZvaWR9IGxpc3RlbmVyIExpc3RlbmVyIGZ1bmN0aW9uLlxuICAgKi9cbiAgbGlzdGVuSW1hZ2VDaGFuZ2UobGlzdGVuZXIpIHt9XG5cbiAgLyoqXG4gICAqIExvYWQgbm90IHlldCBsb2FkZWQgVVJJLlxuICAgKi9cbiAgbG9hZCgpIHt9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb24oaW1wb3J0KFwiLi4vZXZlbnRzL0V2ZW50LmpzXCIpLmRlZmF1bHQpOiB2b2lkfSBsaXN0ZW5lciBMaXN0ZW5lciBmdW5jdGlvbi5cbiAgICovXG4gIHVubGlzdGVuSW1hZ2VDaGFuZ2UobGlzdGVuZXIpIHt9XG5cbiAgLyoqXG4gICAqIENhbGN1bGF0ZSBhZGRpdGlvbmFsIGNhbnZhcyBzaXplIG5lZWRlZCBmb3IgdGhlIG1pdGVyLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gbGluZUpvaW4gTGluZSBqb2luXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBzdHJva2VXaWR0aCBTdHJva2Ugd2lkdGhcbiAgICogQHBhcmFtIHtudW1iZXJ9IG1pdGVyTGltaXQgTWl0ZXIgbGltaXRcbiAgICogQHJldHVybiB7bnVtYmVyfSBBZGRpdGlvbmFsIGNhbnZhcyBzaXplIG5lZWRlZFxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgY2FsY3VsYXRlTGluZUpvaW5TaXplXyhsaW5lSm9pbiwgc3Ryb2tlV2lkdGgsIG1pdGVyTGltaXQpIHtcbiAgICBpZiAoXG4gICAgICBzdHJva2VXaWR0aCA9PT0gMCB8fFxuICAgICAgdGhpcy5wb2ludHNfID09PSBJbmZpbml0eSB8fFxuICAgICAgKGxpbmVKb2luICE9PSAnYmV2ZWwnICYmIGxpbmVKb2luICE9PSAnbWl0ZXInKVxuICAgICkge1xuICAgICAgcmV0dXJuIHN0cm9rZVdpZHRoO1xuICAgIH1cbiAgICAvLyBtICB8IF5cbiAgICAvLyBpICB8IHxcXCAgICAgICAgICAgICAgICAgIC5cbiAgICAvLyB0ID58ICAjXFxcbiAgICAvLyBlICB8IHxcXCBcXCAgICAgICAgICAgICAgLlxuICAgIC8vIHIgICAgICBcXHNcXFxuICAgIC8vICAgICAgfCAgXFx0XFwgICAgICAgICAgLiAgICAgICAgICAgICAgICAgLlxuICAgIC8vICAgICAgICAgIFxcclxcICAgICAgICAgICAgICAgICAgICAgIC4gICAuXG4gICAgLy8gICAgICB8ICAgIFxcb1xcICAgICAgLiAgICAgICAgICAuICAuIC4gLlxuICAgIC8vICAgICAgICAgIGUgXFxrXFwgICAgICAgICAgICAuICAuICAgIC4gLlxuICAgIC8vICAgICAgfCAgICAgIFxcZVxcICAuICAgIC4gIC4gICAgICAgLiAuXG4gICAgLy8gICAgICAgZCAgICAgIFxcIFxcICAuICAuICAgICAgICAgIC4gLlxuICAgIC8vICAgICAgfCBfIF9hXyBfXFwjICAuICAgICAgICAgICAgLiAuXG4gICAgLy8gICByMSAgICAgICAgICAvIGAgICAgICAgICAgICAgLiAuXG4gICAgLy8gICAgICB8ICAgICAgICAgICAgICAgICAgICAgICAuIC5cbiAgICAvLyAgICAgICBiICAgICAvICAgICAgICAgICAgICAgLiAuXG4gICAgLy8gICAgICB8ICAgICAgICAgICAgICAgICAgICAgLiAuXG4gICAgLy8gICAgICAgICAgIC8gcjIgICAgICAgICAgICAuIC5cbiAgICAvLyAgICAgIHwgICAgICAgICAgICAgICAgICAgICAgICAuICAgLlxuICAgIC8vICAgICAgICAgLyAgICAgICAgICAgICAgICAgICAgICAgICAgIC4gICAuXG4gICAgLy8gICAgICB8zrEgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC4gICAuXG4gICAgLy8gICAgICAgLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLiAgIC5cbiAgICAvLyAgICAgIMKwIGNlbnRlclxuICAgIGxldCByMSA9IHRoaXMucmFkaXVzXztcbiAgICBsZXQgcjIgPSB0aGlzLnJhZGl1czJfID09PSB1bmRlZmluZWQgPyByMSA6IHRoaXMucmFkaXVzMl87XG4gICAgaWYgKHIxIDwgcjIpIHtcbiAgICAgIGNvbnN0IHRtcCA9IHIxO1xuICAgICAgcjEgPSByMjtcbiAgICAgIHIyID0gdG1wO1xuICAgIH1cbiAgICBjb25zdCBwb2ludHMgPVxuICAgICAgdGhpcy5yYWRpdXMyXyA9PT0gdW5kZWZpbmVkID8gdGhpcy5wb2ludHNfIDogdGhpcy5wb2ludHNfICogMjtcbiAgICBjb25zdCBhbHBoYSA9ICgyICogTWF0aC5QSSkgLyBwb2ludHM7XG4gICAgY29uc3QgYSA9IHIyICogTWF0aC5zaW4oYWxwaGEpO1xuICAgIGNvbnN0IGIgPSBNYXRoLnNxcnQocjIgKiByMiAtIGEgKiBhKTtcbiAgICBjb25zdCBkID0gcjEgLSBiO1xuICAgIGNvbnN0IGUgPSBNYXRoLnNxcnQoYSAqIGEgKyBkICogZCk7XG4gICAgY29uc3QgbWl0ZXJSYXRpbyA9IGUgLyBhO1xuICAgIGlmIChsaW5lSm9pbiA9PT0gJ21pdGVyJyAmJiBtaXRlclJhdGlvIDw9IG1pdGVyTGltaXQpIHtcbiAgICAgIHJldHVybiBtaXRlclJhdGlvICogc3Ryb2tlV2lkdGg7XG4gICAgfVxuICAgIC8vIENhbGN1bGF0ZSB0aGUgZGlzdG5jZSBmcm9tIGNlbnRlciB0byB0aGUgc3Ryb2tlIGNvcm5lciB3aGVyZVxuICAgIC8vIGl0IHdhcyBjdXQgc2hvcnQgYmVjYXVzZSBvZiB0aGUgbWl0ZXIgbGltaXQuXG4gICAgLy8gICAgICAgICAgICAgIGxcbiAgICAvLyAgICAgICAgLS0tLSstLS0tIDw9IGRpc3RhbmNlIGZyb20gY2VudGVyIHRvIGhlcmUgaXMgbWF4clxuICAgIC8vICAgICAgIC8jIyMjfGsgIyNcXFxuICAgIC8vICAgICAgLyMjIyMjXiMjIyMjXFxcbiAgICAvLyAgICAgLyMjIyMgLytcXCMgcyAjXFxcbiAgICAvLyAgICAvIyMjIGgvKysrXFwjIHQgI1xcXG4gICAgLy8gICAvIyMjIHQvKysrKytcXCMgciAjXFxcbiAgICAvLyAgLyMjIyBhLysrKysrKytcXCMgbyAjXFxcbiAgICAvLyAvIyMjIHAvKysgZmlsbCArXFwjIGsgI1xcXG4gICAgLy8vIyMjIyAvKysrKyteKysrKytcXCMgZSAjXFxcbiAgICAvLyMjIyMjLysrKysrLytcXCsrKysrXFwjIyMjI1xcXG4gICAgY29uc3QgayA9IHN0cm9rZVdpZHRoIC8gMiAvIG1pdGVyUmF0aW87XG4gICAgY29uc3QgbCA9IChzdHJva2VXaWR0aCAvIDIpICogKGQgLyBlKTtcbiAgICBjb25zdCBtYXhyID0gTWF0aC5zcXJ0KChyMSArIGspICogKHIxICsgaykgKyBsICogbCk7XG4gICAgY29uc3QgYmV2ZWxBZGQgPSBtYXhyIC0gcjE7XG4gICAgaWYgKHRoaXMucmFkaXVzMl8gPT09IHVuZGVmaW5lZCB8fCBsaW5lSm9pbiA9PT0gJ2JldmVsJykge1xuICAgICAgcmV0dXJuIGJldmVsQWRkICogMjtcbiAgICB9XG4gICAgLy8gSWYgb3V0ZXIgbWl0ZXIgaXMgb3ZlciB0aGUgbWl0ZXIgbGltaXQgdGhlIGlubmVyIG1pdGVyIG1heSByZWFjaCB0aHJvdWdoIHRoZVxuICAgIC8vIGNlbnRlciBhbmQgYmUgbG9uZ2VyIHRoYW4gdGhlIGJldmVsLCBzYW1lIGNhbGN1bGF0aW9uIGFzIGFib3ZlIGJ1dCBzd2FwIHIxIC8gcjIuXG4gICAgY29uc3QgYWEgPSByMSAqIE1hdGguc2luKGFscGhhKTtcbiAgICBjb25zdCBiYiA9IE1hdGguc3FydChyMSAqIHIxIC0gYWEgKiBhYSk7XG4gICAgY29uc3QgZGQgPSByMiAtIGJiO1xuICAgIGNvbnN0IGVlID0gTWF0aC5zcXJ0KGFhICogYWEgKyBkZCAqIGRkKTtcbiAgICBjb25zdCBpbm5lck1pdGVyUmF0aW8gPSBlZSAvIGFhO1xuICAgIGlmIChpbm5lck1pdGVyUmF0aW8gPD0gbWl0ZXJMaW1pdCkge1xuICAgICAgY29uc3QgaW5uZXJMZW5ndGggPSAoaW5uZXJNaXRlclJhdGlvICogc3Ryb2tlV2lkdGgpIC8gMiAtIHIyIC0gcjE7XG4gICAgICByZXR1cm4gMiAqIE1hdGgubWF4KGJldmVsQWRkLCBpbm5lckxlbmd0aCk7XG4gICAgfVxuICAgIHJldHVybiBiZXZlbEFkZCAqIDI7XG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7UmVuZGVyT3B0aW9uc30gIFRoZSByZW5kZXIgb3B0aW9uc1xuICAgKiBAcHJvdGVjdGVkXG4gICAqL1xuICBjcmVhdGVSZW5kZXJPcHRpb25zKCkge1xuICAgIGxldCBsaW5lSm9pbiA9IGRlZmF1bHRMaW5lSm9pbjtcbiAgICBsZXQgbWl0ZXJMaW1pdCA9IDA7XG4gICAgbGV0IGxpbmVEYXNoID0gbnVsbDtcbiAgICBsZXQgbGluZURhc2hPZmZzZXQgPSAwO1xuICAgIGxldCBzdHJva2VTdHlsZTtcbiAgICBsZXQgc3Ryb2tlV2lkdGggPSAwO1xuXG4gICAgaWYgKHRoaXMuc3Ryb2tlXykge1xuICAgICAgc3Ryb2tlU3R5bGUgPSB0aGlzLnN0cm9rZV8uZ2V0Q29sb3IoKTtcbiAgICAgIGlmIChzdHJva2VTdHlsZSA9PT0gbnVsbCkge1xuICAgICAgICBzdHJva2VTdHlsZSA9IGRlZmF1bHRTdHJva2VTdHlsZTtcbiAgICAgIH1cbiAgICAgIHN0cm9rZVN0eWxlID0gYXNDb2xvckxpa2Uoc3Ryb2tlU3R5bGUpO1xuICAgICAgc3Ryb2tlV2lkdGggPSB0aGlzLnN0cm9rZV8uZ2V0V2lkdGgoKTtcbiAgICAgIGlmIChzdHJva2VXaWR0aCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHN0cm9rZVdpZHRoID0gZGVmYXVsdExpbmVXaWR0aDtcbiAgICAgIH1cbiAgICAgIGxpbmVEYXNoID0gdGhpcy5zdHJva2VfLmdldExpbmVEYXNoKCk7XG4gICAgICBsaW5lRGFzaE9mZnNldCA9IHRoaXMuc3Ryb2tlXy5nZXRMaW5lRGFzaE9mZnNldCgpO1xuICAgICAgbGluZUpvaW4gPSB0aGlzLnN0cm9rZV8uZ2V0TGluZUpvaW4oKTtcbiAgICAgIGlmIChsaW5lSm9pbiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGxpbmVKb2luID0gZGVmYXVsdExpbmVKb2luO1xuICAgICAgfVxuICAgICAgbWl0ZXJMaW1pdCA9IHRoaXMuc3Ryb2tlXy5nZXRNaXRlckxpbWl0KCk7XG4gICAgICBpZiAobWl0ZXJMaW1pdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIG1pdGVyTGltaXQgPSBkZWZhdWx0TWl0ZXJMaW1pdDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBjb25zdCBhZGQgPSB0aGlzLmNhbGN1bGF0ZUxpbmVKb2luU2l6ZV8obGluZUpvaW4sIHN0cm9rZVdpZHRoLCBtaXRlckxpbWl0KTtcbiAgICBjb25zdCBtYXhSYWRpdXMgPSBNYXRoLm1heCh0aGlzLnJhZGl1c18sIHRoaXMucmFkaXVzMl8gfHwgMCk7XG4gICAgY29uc3Qgc2l6ZSA9IE1hdGguY2VpbCgyICogbWF4UmFkaXVzICsgYWRkKTtcblxuICAgIHJldHVybiB7XG4gICAgICBzdHJva2VTdHlsZTogc3Ryb2tlU3R5bGUsXG4gICAgICBzdHJva2VXaWR0aDogc3Ryb2tlV2lkdGgsXG4gICAgICBzaXplOiBzaXplLFxuICAgICAgbGluZURhc2g6IGxpbmVEYXNoLFxuICAgICAgbGluZURhc2hPZmZzZXQ6IGxpbmVEYXNoT2Zmc2V0LFxuICAgICAgbGluZUpvaW46IGxpbmVKb2luLFxuICAgICAgbWl0ZXJMaW1pdDogbWl0ZXJMaW1pdCxcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIEBwcm90ZWN0ZWRcbiAgICovXG4gIHJlbmRlcigpIHtcbiAgICB0aGlzLnJlbmRlck9wdGlvbnNfID0gdGhpcy5jcmVhdGVSZW5kZXJPcHRpb25zKCk7XG4gICAgY29uc3Qgc2l6ZSA9IHRoaXMucmVuZGVyT3B0aW9uc18uc2l6ZTtcbiAgICB0aGlzLmNhbnZhc18gPSB7fTtcbiAgICB0aGlzLnNpemVfID0gW3NpemUsIHNpemVdO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7UmVuZGVyT3B0aW9uc30gcmVuZGVyT3B0aW9ucyBSZW5kZXIgb3B0aW9ucy5cbiAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGNvbnRleHQgVGhlIHJlbmRlcmluZyBjb250ZXh0LlxuICAgKiBAcGFyYW0ge251bWJlcn0gcGl4ZWxSYXRpbyBUaGUgcGl4ZWwgcmF0aW8uXG4gICAqL1xuICBkcmF3XyhyZW5kZXJPcHRpb25zLCBjb250ZXh0LCBwaXhlbFJhdGlvKSB7XG4gICAgY29udGV4dC5zY2FsZShwaXhlbFJhdGlvLCBwaXhlbFJhdGlvKTtcbiAgICAvLyBzZXQgb3JpZ2luIHRvIGNhbnZhcyBjZW50ZXJcbiAgICBjb250ZXh0LnRyYW5zbGF0ZShyZW5kZXJPcHRpb25zLnNpemUgLyAyLCByZW5kZXJPcHRpb25zLnNpemUgLyAyKTtcblxuICAgIHRoaXMuY3JlYXRlUGF0aF8oY29udGV4dCk7XG5cbiAgICBpZiAodGhpcy5maWxsXykge1xuICAgICAgbGV0IGNvbG9yID0gdGhpcy5maWxsXy5nZXRDb2xvcigpO1xuICAgICAgaWYgKGNvbG9yID09PSBudWxsKSB7XG4gICAgICAgIGNvbG9yID0gZGVmYXVsdEZpbGxTdHlsZTtcbiAgICAgIH1cbiAgICAgIGNvbnRleHQuZmlsbFN0eWxlID0gYXNDb2xvckxpa2UoY29sb3IpO1xuICAgICAgY29udGV4dC5maWxsKCk7XG4gICAgfVxuICAgIGlmICh0aGlzLnN0cm9rZV8pIHtcbiAgICAgIGNvbnRleHQuc3Ryb2tlU3R5bGUgPSByZW5kZXJPcHRpb25zLnN0cm9rZVN0eWxlO1xuICAgICAgY29udGV4dC5saW5lV2lkdGggPSByZW5kZXJPcHRpb25zLnN0cm9rZVdpZHRoO1xuICAgICAgaWYgKHJlbmRlck9wdGlvbnMubGluZURhc2gpIHtcbiAgICAgICAgY29udGV4dC5zZXRMaW5lRGFzaChyZW5kZXJPcHRpb25zLmxpbmVEYXNoKTtcbiAgICAgICAgY29udGV4dC5saW5lRGFzaE9mZnNldCA9IHJlbmRlck9wdGlvbnMubGluZURhc2hPZmZzZXQ7XG4gICAgICB9XG4gICAgICBjb250ZXh0LmxpbmVKb2luID0gcmVuZGVyT3B0aW9ucy5saW5lSm9pbjtcbiAgICAgIGNvbnRleHQubWl0ZXJMaW1pdCA9IHJlbmRlck9wdGlvbnMubWl0ZXJMaW1pdDtcbiAgICAgIGNvbnRleHQuc3Ryb2tlKCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7UmVuZGVyT3B0aW9uc30gcmVuZGVyT3B0aW9ucyBSZW5kZXIgb3B0aW9ucy5cbiAgICovXG4gIGNyZWF0ZUhpdERldGVjdGlvbkNhbnZhc18ocmVuZGVyT3B0aW9ucykge1xuICAgIGlmICh0aGlzLmZpbGxfKSB7XG4gICAgICBsZXQgY29sb3IgPSB0aGlzLmZpbGxfLmdldENvbG9yKCk7XG5cbiAgICAgIC8vIGRldGVybWluZSBpZiBmaWxsIGlzIHRyYW5zcGFyZW50IChvciBwYXR0ZXJuIG9yIGdyYWRpZW50KVxuICAgICAgbGV0IG9wYWNpdHkgPSAwO1xuICAgICAgaWYgKHR5cGVvZiBjb2xvciA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgY29sb3IgPSBhc0FycmF5KGNvbG9yKTtcbiAgICAgIH1cbiAgICAgIGlmIChjb2xvciA9PT0gbnVsbCkge1xuICAgICAgICBvcGFjaXR5ID0gMTtcbiAgICAgIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheShjb2xvcikpIHtcbiAgICAgICAgb3BhY2l0eSA9IGNvbG9yLmxlbmd0aCA9PT0gNCA/IGNvbG9yWzNdIDogMTtcbiAgICAgIH1cbiAgICAgIGlmIChvcGFjaXR5ID09PSAwKSB7XG4gICAgICAgIC8vIGlmIGEgdHJhbnNwYXJlbnQgZmlsbCBzdHlsZSBpcyBzZXQsIGNyZWF0ZSBhbiBleHRyYSBoaXQtZGV0ZWN0aW9uIGltYWdlXG4gICAgICAgIC8vIHdpdGggYSBkZWZhdWx0IGZpbGwgc3R5bGVcbiAgICAgICAgY29uc3QgY29udGV4dCA9IGNyZWF0ZUNhbnZhc0NvbnRleHQyRChcbiAgICAgICAgICByZW5kZXJPcHRpb25zLnNpemUsXG4gICAgICAgICAgcmVuZGVyT3B0aW9ucy5zaXplXG4gICAgICAgICk7XG4gICAgICAgIHRoaXMuaGl0RGV0ZWN0aW9uQ2FudmFzXyA9IGNvbnRleHQuY2FudmFzO1xuXG4gICAgICAgIHRoaXMuZHJhd0hpdERldGVjdGlvbkNhbnZhc18ocmVuZGVyT3B0aW9ucywgY29udGV4dCk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICghdGhpcy5oaXREZXRlY3Rpb25DYW52YXNfKSB7XG4gICAgICB0aGlzLmhpdERldGVjdGlvbkNhbnZhc18gPSB0aGlzLmdldEltYWdlKDEpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY29udGV4dCBUaGUgY29udGV4dCB0byBkcmF3IGluLlxuICAgKi9cbiAgY3JlYXRlUGF0aF8oY29udGV4dCkge1xuICAgIGxldCBwb2ludHMgPSB0aGlzLnBvaW50c187XG4gICAgY29uc3QgcmFkaXVzID0gdGhpcy5yYWRpdXNfO1xuICAgIGlmIChwb2ludHMgPT09IEluZmluaXR5KSB7XG4gICAgICBjb250ZXh0LmFyYygwLCAwLCByYWRpdXMsIDAsIDIgKiBNYXRoLlBJKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgcmFkaXVzMiA9IHRoaXMucmFkaXVzMl8gPT09IHVuZGVmaW5lZCA/IHJhZGl1cyA6IHRoaXMucmFkaXVzMl87XG4gICAgICBpZiAodGhpcy5yYWRpdXMyXyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHBvaW50cyAqPSAyO1xuICAgICAgfVxuICAgICAgY29uc3Qgc3RhcnRBbmdsZSA9IHRoaXMuYW5nbGVfIC0gTWF0aC5QSSAvIDI7XG4gICAgICBjb25zdCBzdGVwID0gKDIgKiBNYXRoLlBJKSAvIHBvaW50cztcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcG9pbnRzOyBpKyspIHtcbiAgICAgICAgY29uc3QgYW5nbGUwID0gc3RhcnRBbmdsZSArIGkgKiBzdGVwO1xuICAgICAgICBjb25zdCByYWRpdXNDID0gaSAlIDIgPT09IDAgPyByYWRpdXMgOiByYWRpdXMyO1xuICAgICAgICBjb250ZXh0LmxpbmVUbyhyYWRpdXNDICogTWF0aC5jb3MoYW5nbGUwKSwgcmFkaXVzQyAqIE1hdGguc2luKGFuZ2xlMCkpO1xuICAgICAgfVxuICAgICAgY29udGV4dC5jbG9zZVBhdGgoKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtSZW5kZXJPcHRpb25zfSByZW5kZXJPcHRpb25zIFJlbmRlciBvcHRpb25zLlxuICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY29udGV4dCBUaGUgY29udGV4dC5cbiAgICovXG4gIGRyYXdIaXREZXRlY3Rpb25DYW52YXNfKHJlbmRlck9wdGlvbnMsIGNvbnRleHQpIHtcbiAgICAvLyBzZXQgb3JpZ2luIHRvIGNhbnZhcyBjZW50ZXJcbiAgICBjb250ZXh0LnRyYW5zbGF0ZShyZW5kZXJPcHRpb25zLnNpemUgLyAyLCByZW5kZXJPcHRpb25zLnNpemUgLyAyKTtcblxuICAgIHRoaXMuY3JlYXRlUGF0aF8oY29udGV4dCk7XG5cbiAgICBjb250ZXh0LmZpbGxTdHlsZSA9IGRlZmF1bHRGaWxsU3R5bGU7XG4gICAgY29udGV4dC5maWxsKCk7XG4gICAgaWYgKHRoaXMuc3Ryb2tlXykge1xuICAgICAgY29udGV4dC5zdHJva2VTdHlsZSA9IHJlbmRlck9wdGlvbnMuc3Ryb2tlU3R5bGU7XG4gICAgICBjb250ZXh0LmxpbmVXaWR0aCA9IHJlbmRlck9wdGlvbnMuc3Ryb2tlV2lkdGg7XG4gICAgICBpZiAocmVuZGVyT3B0aW9ucy5saW5lRGFzaCkge1xuICAgICAgICBjb250ZXh0LnNldExpbmVEYXNoKHJlbmRlck9wdGlvbnMubGluZURhc2gpO1xuICAgICAgICBjb250ZXh0LmxpbmVEYXNoT2Zmc2V0ID0gcmVuZGVyT3B0aW9ucy5saW5lRGFzaE9mZnNldDtcbiAgICAgIH1cbiAgICAgIGNvbnRleHQubGluZUpvaW4gPSByZW5kZXJPcHRpb25zLmxpbmVKb2luO1xuICAgICAgY29udGV4dC5taXRlckxpbWl0ID0gcmVuZGVyT3B0aW9ucy5taXRlckxpbWl0O1xuICAgICAgY29udGV4dC5zdHJva2UoKTtcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgUmVndWxhclNoYXBlO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///35393\n')},58958:function(__unused_webpack___webpack_module__,__webpack_exports__){eval('/**\n * @module ol/style/Stroke\n */\n\n/**\n * @typedef {Object} Options\n * @property {import("../color.js").Color|import("../colorlike.js").ColorLike} [color] A color, gradient or pattern.\n * See {@link module:ol/color~Color} and {@link module:ol/colorlike~ColorLike} for possible formats.\n * Default null; if null, the Canvas/renderer default black will be used.\n * @property {CanvasLineCap} [lineCap=\'round\'] Line cap style: `butt`, `round`, or `square`.\n * @property {CanvasLineJoin} [lineJoin=\'round\'] Line join style: `bevel`, `round`, or `miter`.\n * @property {Array<number>} [lineDash] Line dash pattern. Default is `null` (no dash).\n * @property {number} [lineDashOffset=0] Line dash offset.\n * @property {number} [miterLimit=10] Miter limit.\n * @property {number} [width] Width.\n */\n\n/**\n * @classdesc\n * Set stroke style for vector features.\n * Note that the defaults given are the Canvas defaults, which will be used if\n * option is not defined. The `get` functions return whatever was entered in\n * the options; they will not return the default.\n * @api\n */\nclass Stroke {\n  /**\n   * @param {Options} [options] Options.\n   */\n  constructor(options) {\n    options = options || {};\n\n    /**\n     * @private\n     * @type {import("../color.js").Color|import("../colorlike.js").ColorLike}\n     */\n    this.color_ = options.color !== undefined ? options.color : null;\n\n    /**\n     * @private\n     * @type {CanvasLineCap|undefined}\n     */\n    this.lineCap_ = options.lineCap;\n\n    /**\n     * @private\n     * @type {Array<number>|null}\n     */\n    this.lineDash_ = options.lineDash !== undefined ? options.lineDash : null;\n\n    /**\n     * @private\n     * @type {number|undefined}\n     */\n    this.lineDashOffset_ = options.lineDashOffset;\n\n    /**\n     * @private\n     * @type {CanvasLineJoin|undefined}\n     */\n    this.lineJoin_ = options.lineJoin;\n\n    /**\n     * @private\n     * @type {number|undefined}\n     */\n    this.miterLimit_ = options.miterLimit;\n\n    /**\n     * @private\n     * @type {number|undefined}\n     */\n    this.width_ = options.width;\n  }\n\n  /**\n   * Clones the style.\n   * @return {Stroke} The cloned style.\n   * @api\n   */\n  clone() {\n    const color = this.getColor();\n    return new Stroke({\n      color: Array.isArray(color) ? color.slice() : color || undefined,\n      lineCap: this.getLineCap(),\n      lineDash: this.getLineDash() ? this.getLineDash().slice() : undefined,\n      lineDashOffset: this.getLineDashOffset(),\n      lineJoin: this.getLineJoin(),\n      miterLimit: this.getMiterLimit(),\n      width: this.getWidth(),\n    });\n  }\n\n  /**\n   * Get the stroke color.\n   * @return {import("../color.js").Color|import("../colorlike.js").ColorLike} Color.\n   * @api\n   */\n  getColor() {\n    return this.color_;\n  }\n\n  /**\n   * Get the line cap type for the stroke.\n   * @return {CanvasLineCap|undefined} Line cap.\n   * @api\n   */\n  getLineCap() {\n    return this.lineCap_;\n  }\n\n  /**\n   * Get the line dash style for the stroke.\n   * @return {Array<number>|null} Line dash.\n   * @api\n   */\n  getLineDash() {\n    return this.lineDash_;\n  }\n\n  /**\n   * Get the line dash offset for the stroke.\n   * @return {number|undefined} Line dash offset.\n   * @api\n   */\n  getLineDashOffset() {\n    return this.lineDashOffset_;\n  }\n\n  /**\n   * Get the line join type for the stroke.\n   * @return {CanvasLineJoin|undefined} Line join.\n   * @api\n   */\n  getLineJoin() {\n    return this.lineJoin_;\n  }\n\n  /**\n   * Get the miter limit for the stroke.\n   * @return {number|undefined} Miter limit.\n   * @api\n   */\n  getMiterLimit() {\n    return this.miterLimit_;\n  }\n\n  /**\n   * Get the stroke width.\n   * @return {number|undefined} Width.\n   * @api\n   */\n  getWidth() {\n    return this.width_;\n  }\n\n  /**\n   * Set the color.\n   *\n   * @param {import("../color.js").Color|import("../colorlike.js").ColorLike} color Color.\n   * @api\n   */\n  setColor(color) {\n    this.color_ = color;\n  }\n\n  /**\n   * Set the line cap.\n   *\n   * @param {CanvasLineCap|undefined} lineCap Line cap.\n   * @api\n   */\n  setLineCap(lineCap) {\n    this.lineCap_ = lineCap;\n  }\n\n  /**\n   * Set the line dash.\n   *\n   * @param {Array<number>|null} lineDash Line dash.\n   * @api\n   */\n  setLineDash(lineDash) {\n    this.lineDash_ = lineDash;\n  }\n\n  /**\n   * Set the line dash offset.\n   *\n   * @param {number|undefined} lineDashOffset Line dash offset.\n   * @api\n   */\n  setLineDashOffset(lineDashOffset) {\n    this.lineDashOffset_ = lineDashOffset;\n  }\n\n  /**\n   * Set the line join.\n   *\n   * @param {CanvasLineJoin|undefined} lineJoin Line join.\n   * @api\n   */\n  setLineJoin(lineJoin) {\n    this.lineJoin_ = lineJoin;\n  }\n\n  /**\n   * Set the miter limit.\n   *\n   * @param {number|undefined} miterLimit Miter limit.\n   * @api\n   */\n  setMiterLimit(miterLimit) {\n    this.miterLimit_ = miterLimit;\n  }\n\n  /**\n   * Set the width.\n   *\n   * @param {number|undefined} width Width.\n   * @api\n   */\n  setWidth(width) {\n    this.width_ = width;\n  }\n}\n\n/* harmony default export */ __webpack_exports__["Z"] = (Stroke);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNTg5NTguanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGNBQWMsaUVBQWlFO0FBQy9FLFFBQVEsNkJBQTZCLEtBQUsscUNBQXFDO0FBQy9FLGlCQUFpQjtBQUNqQixjQUFjLGVBQWU7QUFDN0IsY0FBYyxnQkFBZ0I7QUFDOUIsY0FBYyxlQUFlO0FBQzdCLGNBQWMsUUFBUTtBQUN0QixjQUFjLFFBQVE7QUFDdEIsY0FBYyxRQUFRO0FBQ3RCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFNBQVM7QUFDdEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxjQUFjLFFBQVE7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQSxjQUFjLGlFQUFpRTtBQUMvRTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxjQUFjLHlCQUF5QjtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxjQUFjLG9CQUFvQjtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxjQUFjLGtCQUFrQjtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxjQUFjLDBCQUEwQjtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxjQUFjLGtCQUFrQjtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxjQUFjLGtCQUFrQjtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsaUVBQWlFO0FBQzlFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYSx5QkFBeUI7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLG9CQUFvQjtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsa0JBQWtCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYSwwQkFBMEI7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLGtCQUFrQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsa0JBQWtCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx5REFBZSxNQUFNLEVBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly92dWUzLXdlYnBhY2s1Ly4vbm9kZV9tb2R1bGVzL29sL3N0eWxlL1N0cm9rZS5qcz81NzhjIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQG1vZHVsZSBvbC9zdHlsZS9TdHJva2VcbiAqL1xuXG4vKipcbiAqIEB0eXBlZGVmIHtPYmplY3R9IE9wdGlvbnNcbiAqIEBwcm9wZXJ0eSB7aW1wb3J0KFwiLi4vY29sb3IuanNcIikuQ29sb3J8aW1wb3J0KFwiLi4vY29sb3JsaWtlLmpzXCIpLkNvbG9yTGlrZX0gW2NvbG9yXSBBIGNvbG9yLCBncmFkaWVudCBvciBwYXR0ZXJuLlxuICogU2VlIHtAbGluayBtb2R1bGU6b2wvY29sb3J+Q29sb3J9IGFuZCB7QGxpbmsgbW9kdWxlOm9sL2NvbG9ybGlrZX5Db2xvckxpa2V9IGZvciBwb3NzaWJsZSBmb3JtYXRzLlxuICogRGVmYXVsdCBudWxsOyBpZiBudWxsLCB0aGUgQ2FudmFzL3JlbmRlcmVyIGRlZmF1bHQgYmxhY2sgd2lsbCBiZSB1c2VkLlxuICogQHByb3BlcnR5IHtDYW52YXNMaW5lQ2FwfSBbbGluZUNhcD0ncm91bmQnXSBMaW5lIGNhcCBzdHlsZTogYGJ1dHRgLCBgcm91bmRgLCBvciBgc3F1YXJlYC5cbiAqIEBwcm9wZXJ0eSB7Q2FudmFzTGluZUpvaW59IFtsaW5lSm9pbj0ncm91bmQnXSBMaW5lIGpvaW4gc3R5bGU6IGBiZXZlbGAsIGByb3VuZGAsIG9yIGBtaXRlcmAuXG4gKiBAcHJvcGVydHkge0FycmF5PG51bWJlcj59IFtsaW5lRGFzaF0gTGluZSBkYXNoIHBhdHRlcm4uIERlZmF1bHQgaXMgYG51bGxgIChubyBkYXNoKS5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbbGluZURhc2hPZmZzZXQ9MF0gTGluZSBkYXNoIG9mZnNldC5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbbWl0ZXJMaW1pdD0xMF0gTWl0ZXIgbGltaXQuXG4gKiBAcHJvcGVydHkge251bWJlcn0gW3dpZHRoXSBXaWR0aC5cbiAqL1xuXG4vKipcbiAqIEBjbGFzc2Rlc2NcbiAqIFNldCBzdHJva2Ugc3R5bGUgZm9yIHZlY3RvciBmZWF0dXJlcy5cbiAqIE5vdGUgdGhhdCB0aGUgZGVmYXVsdHMgZ2l2ZW4gYXJlIHRoZSBDYW52YXMgZGVmYXVsdHMsIHdoaWNoIHdpbGwgYmUgdXNlZCBpZlxuICogb3B0aW9uIGlzIG5vdCBkZWZpbmVkLiBUaGUgYGdldGAgZnVuY3Rpb25zIHJldHVybiB3aGF0ZXZlciB3YXMgZW50ZXJlZCBpblxuICogdGhlIG9wdGlvbnM7IHRoZXkgd2lsbCBub3QgcmV0dXJuIHRoZSBkZWZhdWx0LlxuICogQGFwaVxuICovXG5jbGFzcyBTdHJva2Uge1xuICAvKipcbiAgICogQHBhcmFtIHtPcHRpb25zfSBbb3B0aW9uc10gT3B0aW9ucy5cbiAgICovXG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge2ltcG9ydChcIi4uL2NvbG9yLmpzXCIpLkNvbG9yfGltcG9ydChcIi4uL2NvbG9ybGlrZS5qc1wiKS5Db2xvckxpa2V9XG4gICAgICovXG4gICAgdGhpcy5jb2xvcl8gPSBvcHRpb25zLmNvbG9yICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLmNvbG9yIDogbnVsbDtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge0NhbnZhc0xpbmVDYXB8dW5kZWZpbmVkfVxuICAgICAqL1xuICAgIHRoaXMubGluZUNhcF8gPSBvcHRpb25zLmxpbmVDYXA7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtBcnJheTxudW1iZXI+fG51bGx9XG4gICAgICovXG4gICAgdGhpcy5saW5lRGFzaF8gPSBvcHRpb25zLmxpbmVEYXNoICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLmxpbmVEYXNoIDogbnVsbDtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge251bWJlcnx1bmRlZmluZWR9XG4gICAgICovXG4gICAgdGhpcy5saW5lRGFzaE9mZnNldF8gPSBvcHRpb25zLmxpbmVEYXNoT2Zmc2V0O1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7Q2FudmFzTGluZUpvaW58dW5kZWZpbmVkfVxuICAgICAqL1xuICAgIHRoaXMubGluZUpvaW5fID0gb3B0aW9ucy5saW5lSm9pbjtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge251bWJlcnx1bmRlZmluZWR9XG4gICAgICovXG4gICAgdGhpcy5taXRlckxpbWl0XyA9IG9wdGlvbnMubWl0ZXJMaW1pdDtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge251bWJlcnx1bmRlZmluZWR9XG4gICAgICovXG4gICAgdGhpcy53aWR0aF8gPSBvcHRpb25zLndpZHRoO1xuICB9XG5cbiAgLyoqXG4gICAqIENsb25lcyB0aGUgc3R5bGUuXG4gICAqIEByZXR1cm4ge1N0cm9rZX0gVGhlIGNsb25lZCBzdHlsZS5cbiAgICogQGFwaVxuICAgKi9cbiAgY2xvbmUoKSB7XG4gICAgY29uc3QgY29sb3IgPSB0aGlzLmdldENvbG9yKCk7XG4gICAgcmV0dXJuIG5ldyBTdHJva2Uoe1xuICAgICAgY29sb3I6IEFycmF5LmlzQXJyYXkoY29sb3IpID8gY29sb3Iuc2xpY2UoKSA6IGNvbG9yIHx8IHVuZGVmaW5lZCxcbiAgICAgIGxpbmVDYXA6IHRoaXMuZ2V0TGluZUNhcCgpLFxuICAgICAgbGluZURhc2g6IHRoaXMuZ2V0TGluZURhc2goKSA/IHRoaXMuZ2V0TGluZURhc2goKS5zbGljZSgpIDogdW5kZWZpbmVkLFxuICAgICAgbGluZURhc2hPZmZzZXQ6IHRoaXMuZ2V0TGluZURhc2hPZmZzZXQoKSxcbiAgICAgIGxpbmVKb2luOiB0aGlzLmdldExpbmVKb2luKCksXG4gICAgICBtaXRlckxpbWl0OiB0aGlzLmdldE1pdGVyTGltaXQoKSxcbiAgICAgIHdpZHRoOiB0aGlzLmdldFdpZHRoKCksXG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBzdHJva2UgY29sb3IuXG4gICAqIEByZXR1cm4ge2ltcG9ydChcIi4uL2NvbG9yLmpzXCIpLkNvbG9yfGltcG9ydChcIi4uL2NvbG9ybGlrZS5qc1wiKS5Db2xvckxpa2V9IENvbG9yLlxuICAgKiBAYXBpXG4gICAqL1xuICBnZXRDb2xvcigpIHtcbiAgICByZXR1cm4gdGhpcy5jb2xvcl87XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBsaW5lIGNhcCB0eXBlIGZvciB0aGUgc3Ryb2tlLlxuICAgKiBAcmV0dXJuIHtDYW52YXNMaW5lQ2FwfHVuZGVmaW5lZH0gTGluZSBjYXAuXG4gICAqIEBhcGlcbiAgICovXG4gIGdldExpbmVDYXAoKSB7XG4gICAgcmV0dXJuIHRoaXMubGluZUNhcF87XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBsaW5lIGRhc2ggc3R5bGUgZm9yIHRoZSBzdHJva2UuXG4gICAqIEByZXR1cm4ge0FycmF5PG51bWJlcj58bnVsbH0gTGluZSBkYXNoLlxuICAgKiBAYXBpXG4gICAqL1xuICBnZXRMaW5lRGFzaCgpIHtcbiAgICByZXR1cm4gdGhpcy5saW5lRGFzaF87XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBsaW5lIGRhc2ggb2Zmc2V0IGZvciB0aGUgc3Ryb2tlLlxuICAgKiBAcmV0dXJuIHtudW1iZXJ8dW5kZWZpbmVkfSBMaW5lIGRhc2ggb2Zmc2V0LlxuICAgKiBAYXBpXG4gICAqL1xuICBnZXRMaW5lRGFzaE9mZnNldCgpIHtcbiAgICByZXR1cm4gdGhpcy5saW5lRGFzaE9mZnNldF87XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBsaW5lIGpvaW4gdHlwZSBmb3IgdGhlIHN0cm9rZS5cbiAgICogQHJldHVybiB7Q2FudmFzTGluZUpvaW58dW5kZWZpbmVkfSBMaW5lIGpvaW4uXG4gICAqIEBhcGlcbiAgICovXG4gIGdldExpbmVKb2luKCkge1xuICAgIHJldHVybiB0aGlzLmxpbmVKb2luXztcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIG1pdGVyIGxpbWl0IGZvciB0aGUgc3Ryb2tlLlxuICAgKiBAcmV0dXJuIHtudW1iZXJ8dW5kZWZpbmVkfSBNaXRlciBsaW1pdC5cbiAgICogQGFwaVxuICAgKi9cbiAgZ2V0TWl0ZXJMaW1pdCgpIHtcbiAgICByZXR1cm4gdGhpcy5taXRlckxpbWl0XztcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIHN0cm9rZSB3aWR0aC5cbiAgICogQHJldHVybiB7bnVtYmVyfHVuZGVmaW5lZH0gV2lkdGguXG4gICAqIEBhcGlcbiAgICovXG4gIGdldFdpZHRoKCkge1xuICAgIHJldHVybiB0aGlzLndpZHRoXztcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXQgdGhlIGNvbG9yLlxuICAgKlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL2NvbG9yLmpzXCIpLkNvbG9yfGltcG9ydChcIi4uL2NvbG9ybGlrZS5qc1wiKS5Db2xvckxpa2V9IGNvbG9yIENvbG9yLlxuICAgKiBAYXBpXG4gICAqL1xuICBzZXRDb2xvcihjb2xvcikge1xuICAgIHRoaXMuY29sb3JfID0gY29sb3I7XG4gIH1cblxuICAvKipcbiAgICogU2V0IHRoZSBsaW5lIGNhcC5cbiAgICpcbiAgICogQHBhcmFtIHtDYW52YXNMaW5lQ2FwfHVuZGVmaW5lZH0gbGluZUNhcCBMaW5lIGNhcC5cbiAgICogQGFwaVxuICAgKi9cbiAgc2V0TGluZUNhcChsaW5lQ2FwKSB7XG4gICAgdGhpcy5saW5lQ2FwXyA9IGxpbmVDYXA7XG4gIH1cblxuICAvKipcbiAgICogU2V0IHRoZSBsaW5lIGRhc2guXG4gICAqXG4gICAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPnxudWxsfSBsaW5lRGFzaCBMaW5lIGRhc2guXG4gICAqIEBhcGlcbiAgICovXG4gIHNldExpbmVEYXNoKGxpbmVEYXNoKSB7XG4gICAgdGhpcy5saW5lRGFzaF8gPSBsaW5lRGFzaDtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXQgdGhlIGxpbmUgZGFzaCBvZmZzZXQuXG4gICAqXG4gICAqIEBwYXJhbSB7bnVtYmVyfHVuZGVmaW5lZH0gbGluZURhc2hPZmZzZXQgTGluZSBkYXNoIG9mZnNldC5cbiAgICogQGFwaVxuICAgKi9cbiAgc2V0TGluZURhc2hPZmZzZXQobGluZURhc2hPZmZzZXQpIHtcbiAgICB0aGlzLmxpbmVEYXNoT2Zmc2V0XyA9IGxpbmVEYXNoT2Zmc2V0O1xuICB9XG5cbiAgLyoqXG4gICAqIFNldCB0aGUgbGluZSBqb2luLlxuICAgKlxuICAgKiBAcGFyYW0ge0NhbnZhc0xpbmVKb2lufHVuZGVmaW5lZH0gbGluZUpvaW4gTGluZSBqb2luLlxuICAgKiBAYXBpXG4gICAqL1xuICBzZXRMaW5lSm9pbihsaW5lSm9pbikge1xuICAgIHRoaXMubGluZUpvaW5fID0gbGluZUpvaW47XG4gIH1cblxuICAvKipcbiAgICogU2V0IHRoZSBtaXRlciBsaW1pdC5cbiAgICpcbiAgICogQHBhcmFtIHtudW1iZXJ8dW5kZWZpbmVkfSBtaXRlckxpbWl0IE1pdGVyIGxpbWl0LlxuICAgKiBAYXBpXG4gICAqL1xuICBzZXRNaXRlckxpbWl0KG1pdGVyTGltaXQpIHtcbiAgICB0aGlzLm1pdGVyTGltaXRfID0gbWl0ZXJMaW1pdDtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXQgdGhlIHdpZHRoLlxuICAgKlxuICAgKiBAcGFyYW0ge251bWJlcnx1bmRlZmluZWR9IHdpZHRoIFdpZHRoLlxuICAgKiBAYXBpXG4gICAqL1xuICBzZXRXaWR0aCh3aWR0aCkge1xuICAgIHRoaXMud2lkdGhfID0gd2lkdGg7XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgU3Ryb2tlO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///58958\n')},47539:function(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__){eval('/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "J$": function() { return /* binding */ toFunction; },\n/* harmony export */   "Ly": function() { return /* binding */ createEditingStyle; },\n/* harmony export */   "yF": function() { return /* binding */ createDefaultStyle; }\n/* harmony export */ });\n/* harmony import */ var _Circle_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(30283);\n/* harmony import */ var _Fill_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(51345);\n/* harmony import */ var _Stroke_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(58958);\n/* harmony import */ var _asserts_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(99515);\n/**\n * @module ol/style/Style\n */\n\n\n\n\n\n\n/**\n * A function that takes an {@link module:ol/Feature~Feature} and a `{number}`\n * representing the view\'s resolution. The function should return a\n * {@link module:ol/style/Style~Style} or an array of them. This way e.g. a\n * vector layer can be styled. If the function returns `undefined`, the\n * feature will not be rendered.\n *\n * @typedef {function(import("../Feature.js").FeatureLike, number):(Style|Array<Style>|void)} StyleFunction\n */\n\n/**\n * A {@link Style}, an array of {@link Style}, or a {@link StyleFunction}.\n * @typedef {Style|Array<Style>|StyleFunction} StyleLike\n */\n\n/**\n * A function that takes an {@link module:ol/Feature~Feature} as argument and returns an\n * {@link module:ol/geom/Geometry~Geometry} that will be rendered and styled for the feature.\n *\n * @typedef {function(import("../Feature.js").FeatureLike):\n *     (import("../geom/Geometry.js").default|import("../render/Feature.js").default|undefined)} GeometryFunction\n */\n\n/**\n * Custom renderer function. Takes two arguments:\n *\n * 1. The pixel coordinates of the geometry in GeoJSON notation.\n * 2. The {@link module:ol/render~State} of the layer renderer.\n *\n * @typedef {function((import("../coordinate.js").Coordinate|Array<import("../coordinate.js").Coordinate>|Array<Array<import("../coordinate.js").Coordinate>>),import("../render.js").State): void} RenderFunction\n */\n\n/**\n * @typedef {Object} Options\n * @property {string|import("../geom/Geometry.js").default|GeometryFunction} [geometry] Feature property or geometry\n * or function returning a geometry to render for this style.\n * @property {import("./Fill.js").default} [fill] Fill style.\n * @property {import("./Image.js").default} [image] Image style.\n * @property {RenderFunction} [renderer] Custom renderer. When configured, `fill`, `stroke` and `image` will be\n * ignored, and the provided function will be called with each render frame for each geometry.\n * @property {RenderFunction} [hitDetectionRenderer] Custom renderer for hit detection. If provided will be used\n * in hit detection rendering.\n * @property {import("./Stroke.js").default} [stroke] Stroke style.\n * @property {import("./Text.js").default} [text] Text style.\n * @property {number} [zIndex] Z index.\n */\n\n/**\n * @classdesc\n * Container for vector feature rendering styles. Any changes made to the style\n * or its children through `set*()` methods will not take effect until the\n * feature or layer that uses the style is re-rendered.\n *\n * ## Feature styles\n *\n * If no style is defined, the following default style is used:\n * ```js\n *  import {Circle, Fill, Stroke, Style} from \'ol/style.js\';\n *\n *  const fill = new Fill({\n *    color: \'rgba(255,255,255,0.4)\',\n *  });\n *  const stroke = new Stroke({\n *    color: \'#3399CC\',\n *    width: 1.25,\n *  });\n *  const styles = [\n *    new Style({\n *      image: new Circle({\n *        fill: fill,\n *        stroke: stroke,\n *        radius: 5,\n *      }),\n *      fill: fill,\n *      stroke: stroke,\n *    }),\n *  ];\n * ```\n *\n * A separate editing style has the following defaults:\n * ```js\n *  import {Circle, Fill, Stroke, Style} from \'ol/style.js\';\n *\n *  const styles = {};\n *  const white = [255, 255, 255, 1];\n *  const blue = [0, 153, 255, 1];\n *  const width = 3;\n *  styles[\'Polygon\'] = [\n *    new Style({\n *      fill: new Fill({\n *        color: [255, 255, 255, 0.5],\n *      }),\n *    }),\n *  ];\n *  styles[\'MultiPolygon\'] =\n *      styles[\'Polygon\'];\n *  styles[\'LineString\'] = [\n *    new Style({\n *      stroke: new Stroke({\n *        color: white,\n *        width: width + 2,\n *      }),\n *    }),\n *    new Style({\n *      stroke: new Stroke({\n *        color: blue,\n *        width: width,\n *      }),\n *    }),\n *  ];\n *  styles[\'MultiLineString\'] = styles[\'LineString\'];\n *\n *  styles[\'Circle\'] = styles[\'Polygon\'].concat(\n *    styles[\'LineString\']\n *  );\n *\n *  styles[\'Point\'] = [\n *    new Style({\n *      image: new Circle({\n *        radius: width * 2,\n *        fill: new Fill({\n *          color: blue,\n *        }),\n *        stroke: new Stroke({\n *          color: white,\n *          width: width / 2,\n *        }),\n *      }),\n *      zIndex: Infinity,\n *    }),\n *  ];\n *  styles[\'MultiPoint\'] =\n *      styles[\'Point\'];\n *  styles[\'GeometryCollection\'] =\n *      styles[\'Polygon\'].concat(\n *          styles[\'LineString\'],\n *          styles[\'Point\']\n *      );\n * ```\n *\n * @api\n */\nclass Style {\n  /**\n   * @param {Options} [options] Style options.\n   */\n  constructor(options) {\n    options = options || {};\n\n    /**\n     * @private\n     * @type {string|import("../geom/Geometry.js").default|GeometryFunction}\n     */\n    this.geometry_ = null;\n\n    /**\n     * @private\n     * @type {!GeometryFunction}\n     */\n    this.geometryFunction_ = defaultGeometryFunction;\n\n    if (options.geometry !== undefined) {\n      this.setGeometry(options.geometry);\n    }\n\n    /**\n     * @private\n     * @type {import("./Fill.js").default}\n     */\n    this.fill_ = options.fill !== undefined ? options.fill : null;\n\n    /**\n     * @private\n     * @type {import("./Image.js").default}\n     */\n    this.image_ = options.image !== undefined ? options.image : null;\n\n    /**\n     * @private\n     * @type {RenderFunction|null}\n     */\n    this.renderer_ = options.renderer !== undefined ? options.renderer : null;\n\n    /**\n     * @private\n     * @type {RenderFunction|null}\n     */\n    this.hitDetectionRenderer_ =\n      options.hitDetectionRenderer !== undefined\n        ? options.hitDetectionRenderer\n        : null;\n\n    /**\n     * @private\n     * @type {import("./Stroke.js").default}\n     */\n    this.stroke_ = options.stroke !== undefined ? options.stroke : null;\n\n    /**\n     * @private\n     * @type {import("./Text.js").default}\n     */\n    this.text_ = options.text !== undefined ? options.text : null;\n\n    /**\n     * @private\n     * @type {number|undefined}\n     */\n    this.zIndex_ = options.zIndex;\n  }\n\n  /**\n   * Clones the style.\n   * @return {Style} The cloned style.\n   * @api\n   */\n  clone() {\n    let geometry = this.getGeometry();\n    if (geometry && typeof geometry === \'object\') {\n      geometry = /** @type {import("../geom/Geometry.js").default} */ (\n        geometry\n      ).clone();\n    }\n    return new Style({\n      geometry: geometry,\n      fill: this.getFill() ? this.getFill().clone() : undefined,\n      image: this.getImage() ? this.getImage().clone() : undefined,\n      renderer: this.getRenderer(),\n      stroke: this.getStroke() ? this.getStroke().clone() : undefined,\n      text: this.getText() ? this.getText().clone() : undefined,\n      zIndex: this.getZIndex(),\n    });\n  }\n\n  /**\n   * Get the custom renderer function that was configured with\n   * {@link #setRenderer} or the `renderer` constructor option.\n   * @return {RenderFunction|null} Custom renderer function.\n   * @api\n   */\n  getRenderer() {\n    return this.renderer_;\n  }\n\n  /**\n   * Sets a custom renderer function for this style. When set, `fill`, `stroke`\n   * and `image` options of the style will be ignored.\n   * @param {RenderFunction|null} renderer Custom renderer function.\n   * @api\n   */\n  setRenderer(renderer) {\n    this.renderer_ = renderer;\n  }\n\n  /**\n   * Sets a custom renderer function for this style used\n   * in hit detection.\n   * @param {RenderFunction|null} renderer Custom renderer function.\n   * @api\n   */\n  setHitDetectionRenderer(renderer) {\n    this.hitDetectionRenderer_ = renderer;\n  }\n\n  /**\n   * Get the custom renderer function that was configured with\n   * {@link #setHitDetectionRenderer} or the `hitDetectionRenderer` constructor option.\n   * @return {RenderFunction|null} Custom renderer function.\n   * @api\n   */\n  getHitDetectionRenderer() {\n    return this.hitDetectionRenderer_;\n  }\n\n  /**\n   * Get the geometry to be rendered.\n   * @return {string|import("../geom/Geometry.js").default|GeometryFunction}\n   * Feature property or geometry or function that returns the geometry that will\n   * be rendered with this style.\n   * @api\n   */\n  getGeometry() {\n    return this.geometry_;\n  }\n\n  /**\n   * Get the function used to generate a geometry for rendering.\n   * @return {!GeometryFunction} Function that is called with a feature\n   * and returns the geometry to render instead of the feature\'s geometry.\n   * @api\n   */\n  getGeometryFunction() {\n    return this.geometryFunction_;\n  }\n\n  /**\n   * Get the fill style.\n   * @return {import("./Fill.js").default} Fill style.\n   * @api\n   */\n  getFill() {\n    return this.fill_;\n  }\n\n  /**\n   * Set the fill style.\n   * @param {import("./Fill.js").default} fill Fill style.\n   * @api\n   */\n  setFill(fill) {\n    this.fill_ = fill;\n  }\n\n  /**\n   * Get the image style.\n   * @return {import("./Image.js").default} Image style.\n   * @api\n   */\n  getImage() {\n    return this.image_;\n  }\n\n  /**\n   * Set the image style.\n   * @param {import("./Image.js").default} image Image style.\n   * @api\n   */\n  setImage(image) {\n    this.image_ = image;\n  }\n\n  /**\n   * Get the stroke style.\n   * @return {import("./Stroke.js").default} Stroke style.\n   * @api\n   */\n  getStroke() {\n    return this.stroke_;\n  }\n\n  /**\n   * Set the stroke style.\n   * @param {import("./Stroke.js").default} stroke Stroke style.\n   * @api\n   */\n  setStroke(stroke) {\n    this.stroke_ = stroke;\n  }\n\n  /**\n   * Get the text style.\n   * @return {import("./Text.js").default} Text style.\n   * @api\n   */\n  getText() {\n    return this.text_;\n  }\n\n  /**\n   * Set the text style.\n   * @param {import("./Text.js").default} text Text style.\n   * @api\n   */\n  setText(text) {\n    this.text_ = text;\n  }\n\n  /**\n   * Get the z-index for the style.\n   * @return {number|undefined} ZIndex.\n   * @api\n   */\n  getZIndex() {\n    return this.zIndex_;\n  }\n\n  /**\n   * Set a geometry that is rendered instead of the feature\'s geometry.\n   *\n   * @param {string|import("../geom/Geometry.js").default|GeometryFunction} geometry\n   *     Feature property or geometry or function returning a geometry to render\n   *     for this style.\n   * @api\n   */\n  setGeometry(geometry) {\n    if (typeof geometry === \'function\') {\n      this.geometryFunction_ = geometry;\n    } else if (typeof geometry === \'string\') {\n      this.geometryFunction_ = function (feature) {\n        return /** @type {import("../geom/Geometry.js").default} */ (\n          feature.get(geometry)\n        );\n      };\n    } else if (!geometry) {\n      this.geometryFunction_ = defaultGeometryFunction;\n    } else if (geometry !== undefined) {\n      this.geometryFunction_ = function () {\n        return /** @type {import("../geom/Geometry.js").default} */ (geometry);\n      };\n    }\n    this.geometry_ = geometry;\n  }\n\n  /**\n   * Set the z-index.\n   *\n   * @param {number|undefined} zIndex ZIndex.\n   * @api\n   */\n  setZIndex(zIndex) {\n    this.zIndex_ = zIndex;\n  }\n}\n\n/**\n * Convert the provided object into a style function.  Functions passed through\n * unchanged.  Arrays of Style or single style objects wrapped in a\n * new style function.\n * @param {StyleFunction|Array<Style>|Style} obj\n *     A style function, a single style, or an array of styles.\n * @return {StyleFunction} A style function.\n */\nfunction toFunction(obj) {\n  let styleFunction;\n\n  if (typeof obj === \'function\') {\n    styleFunction = obj;\n  } else {\n    /**\n     * @type {Array<Style>}\n     */\n    let styles;\n    if (Array.isArray(obj)) {\n      styles = obj;\n    } else {\n      (0,_asserts_js__WEBPACK_IMPORTED_MODULE_0__/* .assert */ .h)(typeof (/** @type {?} */ (obj).getZIndex) === \'function\', 41); // Expected an `Style` or an array of `Style`\n      const style = /** @type {Style} */ (obj);\n      styles = [style];\n    }\n    styleFunction = function () {\n      return styles;\n    };\n  }\n  return styleFunction;\n}\n\n/**\n * @type {Array<Style>|null}\n */\nlet defaultStyles = null;\n\n/**\n * @param {import("../Feature.js").FeatureLike} feature Feature.\n * @param {number} resolution Resolution.\n * @return {Array<Style>} Style.\n */\nfunction createDefaultStyle(feature, resolution) {\n  // We don\'t use an immediately-invoked function\n  // and a closure so we don\'t get an error at script evaluation time in\n  // browsers that do not support Canvas. (import("./Circle.js").CircleStyle does\n  // canvas.getContext(\'2d\') at construction time, which will cause an.error\n  // in such browsers.)\n  if (!defaultStyles) {\n    const fill = new _Fill_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .Z({\n      color: \'rgba(255,255,255,0.4)\',\n    });\n    const stroke = new _Stroke_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"] */ .Z({\n      color: \'#3399CC\',\n      width: 1.25,\n    });\n    defaultStyles = [\n      new Style({\n        image: new _Circle_js__WEBPACK_IMPORTED_MODULE_3__/* ["default"] */ .Z({\n          fill: fill,\n          stroke: stroke,\n          radius: 5,\n        }),\n        fill: fill,\n        stroke: stroke,\n      }),\n    ];\n  }\n  return defaultStyles;\n}\n\n/**\n * Default styles for editing features.\n * @return {Object<import("../geom/Geometry.js").Type, Array<Style>>} Styles\n */\nfunction createEditingStyle() {\n  /** @type {Object<import("../geom/Geometry.js").Type, Array<Style>>} */\n  const styles = {};\n  const white = [255, 255, 255, 1];\n  const blue = [0, 153, 255, 1];\n  const width = 3;\n  styles[\'Polygon\'] = [\n    new Style({\n      fill: new _Fill_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .Z({\n        color: [255, 255, 255, 0.5],\n      }),\n    }),\n  ];\n  styles[\'MultiPolygon\'] = styles[\'Polygon\'];\n\n  styles[\'LineString\'] = [\n    new Style({\n      stroke: new _Stroke_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"] */ .Z({\n        color: white,\n        width: width + 2,\n      }),\n    }),\n    new Style({\n      stroke: new _Stroke_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"] */ .Z({\n        color: blue,\n        width: width,\n      }),\n    }),\n  ];\n  styles[\'MultiLineString\'] = styles[\'LineString\'];\n\n  styles[\'Circle\'] = styles[\'Polygon\'].concat(styles[\'LineString\']);\n\n  styles[\'Point\'] = [\n    new Style({\n      image: new _Circle_js__WEBPACK_IMPORTED_MODULE_3__/* ["default"] */ .Z({\n        radius: width * 2,\n        fill: new _Fill_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .Z({\n          color: blue,\n        }),\n        stroke: new _Stroke_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"] */ .Z({\n          color: white,\n          width: width / 2,\n        }),\n      }),\n      zIndex: Infinity,\n    }),\n  ];\n  styles[\'MultiPoint\'] = styles[\'Point\'];\n\n  styles[\'GeometryCollection\'] = styles[\'Polygon\'].concat(\n    styles[\'LineString\'],\n    styles[\'Point\']\n  );\n\n  return styles;\n}\n\n/**\n * Function that is called with a feature and returns its default geometry.\n * @param {import("../Feature.js").FeatureLike} feature Feature to get the geometry for.\n * @return {import("../geom/Geometry.js").default|import("../render/Feature.js").default|undefined} Geometry to render.\n */\nfunction defaultGeometryFunction(feature) {\n  return feature.getGeometry();\n}\n\n/* harmony default export */ __webpack_exports__["ZP"] = (Style);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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Q0Esa0JBQWtCLHlEQUFJO0FBQ3RCO0FBQ0EsU0FBUztBQUNULG9CQUFvQiwyREFBTTtBQUMxQjtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVcscUNBQXFDO0FBQ2hELFlBQVksd0ZBQXdGO0FBQ3BHO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDBEQUFlLEtBQUssRUFBQyIsInNvdXJjZXMiOlsid2VicGFjazovL3Z1ZTMtd2VicGFjazUvLi9ub2RlX21vZHVsZXMvb2wvc3R5bGUvU3R5bGUuanM/NjE1NyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBtb2R1bGUgb2wvc3R5bGUvU3R5bGVcbiAqL1xuXG5pbXBvcnQgQ2lyY2xlU3R5bGUgZnJvbSAnLi9DaXJjbGUuanMnO1xuaW1wb3J0IEZpbGwgZnJvbSAnLi9GaWxsLmpzJztcbmltcG9ydCBTdHJva2UgZnJvbSAnLi9TdHJva2UuanMnO1xuaW1wb3J0IHthc3NlcnR9IGZyb20gJy4uL2Fzc2VydHMuanMnO1xuXG4vKipcbiAqIEEgZnVuY3Rpb24gdGhhdCB0YWtlcyBhbiB7QGxpbmsgbW9kdWxlOm9sL0ZlYXR1cmV+RmVhdHVyZX0gYW5kIGEgYHtudW1iZXJ9YFxuICogcmVwcmVzZW50aW5nIHRoZSB2aWV3J3MgcmVzb2x1dGlvbi4gVGhlIGZ1bmN0aW9uIHNob3VsZCByZXR1cm4gYVxuICoge0BsaW5rIG1vZHVsZTpvbC9zdHlsZS9TdHlsZX5TdHlsZX0gb3IgYW4gYXJyYXkgb2YgdGhlbS4gVGhpcyB3YXkgZS5nLiBhXG4gKiB2ZWN0b3IgbGF5ZXIgY2FuIGJlIHN0eWxlZC4gSWYgdGhlIGZ1bmN0aW9uIHJldHVybnMgYHVuZGVmaW5lZGAsIHRoZVxuICogZmVhdHVyZSB3aWxsIG5vdCBiZSByZW5kZXJlZC5cbiAqXG4gKiBAdHlwZWRlZiB7ZnVuY3Rpb24oaW1wb3J0KFwiLi4vRmVhdHVyZS5qc1wiKS5GZWF0dXJlTGlrZSwgbnVtYmVyKTooU3R5bGV8QXJyYXk8U3R5bGU+fHZvaWQpfSBTdHlsZUZ1bmN0aW9uXG4gKi9cblxuLyoqXG4gKiBBIHtAbGluayBTdHlsZX0sIGFuIGFycmF5IG9mIHtAbGluayBTdHlsZX0sIG9yIGEge0BsaW5rIFN0eWxlRnVuY3Rpb259LlxuICogQHR5cGVkZWYge1N0eWxlfEFycmF5PFN0eWxlPnxTdHlsZUZ1bmN0aW9ufSBTdHlsZUxpa2VcbiAqL1xuXG4vKipcbiAqIEEgZnVuY3Rpb24gdGhhdCB0YWtlcyBhbiB7QGxpbmsgbW9kdWxlOm9sL0ZlYXR1cmV+RmVhdHVyZX0gYXMgYXJndW1lbnQgYW5kIHJldHVybnMgYW5cbiAqIHtAbGluayBtb2R1bGU6b2wvZ2VvbS9HZW9tZXRyeX5HZW9tZXRyeX0gdGhhdCB3aWxsIGJlIHJlbmRlcmVkIGFuZCBzdHlsZWQgZm9yIHRoZSBmZWF0dXJlLlxuICpcbiAqIEB0eXBlZGVmIHtmdW5jdGlvbihpbXBvcnQoXCIuLi9GZWF0dXJlLmpzXCIpLkZlYXR1cmVMaWtlKTpcbiAqICAgICAoaW1wb3J0KFwiLi4vZ2VvbS9HZW9tZXRyeS5qc1wiKS5kZWZhdWx0fGltcG9ydChcIi4uL3JlbmRlci9GZWF0dXJlLmpzXCIpLmRlZmF1bHR8dW5kZWZpbmVkKX0gR2VvbWV0cnlGdW5jdGlvblxuICovXG5cbi8qKlxuICogQ3VzdG9tIHJlbmRlcmVyIGZ1bmN0aW9uLiBUYWtlcyB0d28gYXJndW1lbnRzOlxuICpcbiAqIDEuIFRoZSBwaXhlbCBjb29yZGluYXRlcyBvZiB0aGUgZ2VvbWV0cnkgaW4gR2VvSlNPTiBub3RhdGlvbi5cbiAqIDIuIFRoZSB7QGxpbmsgbW9kdWxlOm9sL3JlbmRlcn5TdGF0ZX0gb2YgdGhlIGxheWVyIHJlbmRlcmVyLlxuICpcbiAqIEB0eXBlZGVmIHtmdW5jdGlvbigoaW1wb3J0KFwiLi4vY29vcmRpbmF0ZS5qc1wiKS5Db29yZGluYXRlfEFycmF5PGltcG9ydChcIi4uL2Nvb3JkaW5hdGUuanNcIikuQ29vcmRpbmF0ZT58QXJyYXk8QXJyYXk8aW1wb3J0KFwiLi4vY29vcmRpbmF0ZS5qc1wiKS5Db29yZGluYXRlPj4pLGltcG9ydChcIi4uL3JlbmRlci5qc1wiKS5TdGF0ZSk6IHZvaWR9IFJlbmRlckZ1bmN0aW9uXG4gKi9cblxuLyoqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBPcHRpb25zXG4gKiBAcHJvcGVydHkge3N0cmluZ3xpbXBvcnQoXCIuLi9nZW9tL0dlb21ldHJ5LmpzXCIpLmRlZmF1bHR8R2VvbWV0cnlGdW5jdGlvbn0gW2dlb21ldHJ5XSBGZWF0dXJlIHByb3BlcnR5IG9yIGdlb21ldHJ5XG4gKiBvciBmdW5jdGlvbiByZXR1cm5pbmcgYSBnZW9tZXRyeSB0byByZW5kZXIgZm9yIHRoaXMgc3R5bGUuXG4gKiBAcHJvcGVydHkge2ltcG9ydChcIi4vRmlsbC5qc1wiKS5kZWZhdWx0fSBbZmlsbF0gRmlsbCBzdHlsZS5cbiAqIEBwcm9wZXJ0eSB7aW1wb3J0KFwiLi9JbWFnZS5qc1wiKS5kZWZhdWx0fSBbaW1hZ2VdIEltYWdlIHN0eWxlLlxuICogQHByb3BlcnR5IHtSZW5kZXJGdW5jdGlvbn0gW3JlbmRlcmVyXSBDdXN0b20gcmVuZGVyZXIuIFdoZW4gY29uZmlndXJlZCwgYGZpbGxgLCBgc3Ryb2tlYCBhbmQgYGltYWdlYCB3aWxsIGJlXG4gKiBpZ25vcmVkLCBhbmQgdGhlIHByb3ZpZGVkIGZ1bmN0aW9uIHdpbGwgYmUgY2FsbGVkIHdpdGggZWFjaCByZW5kZXIgZnJhbWUgZm9yIGVhY2ggZ2VvbWV0cnkuXG4gKiBAcHJvcGVydHkge1JlbmRlckZ1bmN0aW9ufSBbaGl0RGV0ZWN0aW9uUmVuZGVyZXJdIEN1c3RvbSByZW5kZXJlciBmb3IgaGl0IGRldGVjdGlvbi4gSWYgcHJvdmlkZWQgd2lsbCBiZSB1c2VkXG4gKiBpbiBoaXQgZGV0ZWN0aW9uIHJlbmRlcmluZy5cbiAqIEBwcm9wZXJ0eSB7aW1wb3J0KFwiLi9TdHJva2UuanNcIikuZGVmYXVsdH0gW3N0cm9rZV0gU3Ryb2tlIHN0eWxlLlxuICogQHByb3BlcnR5IHtpbXBvcnQoXCIuL1RleHQuanNcIikuZGVmYXVsdH0gW3RleHRdIFRleHQgc3R5bGUuXG4gKiBAcHJvcGVydHkge251bWJlcn0gW3pJbmRleF0gWiBpbmRleC5cbiAqL1xuXG4vKipcbiAqIEBjbGFzc2Rlc2NcbiAqIENvbnRhaW5lciBmb3IgdmVjdG9yIGZlYXR1cmUgcmVuZGVyaW5nIHN0eWxlcy4gQW55IGNoYW5nZXMgbWFkZSB0byB0aGUgc3R5bGVcbiAqIG9yIGl0cyBjaGlsZHJlbiB0aHJvdWdoIGBzZXQqKClgIG1ldGhvZHMgd2lsbCBub3QgdGFrZSBlZmZlY3QgdW50aWwgdGhlXG4gKiBmZWF0dXJlIG9yIGxheWVyIHRoYXQgdXNlcyB0aGUgc3R5bGUgaXMgcmUtcmVuZGVyZWQuXG4gKlxuICogIyMgRmVhdHVyZSBzdHlsZXNcbiAqXG4gKiBJZiBubyBzdHlsZSBpcyBkZWZpbmVkLCB0aGUgZm9sbG93aW5nIGRlZmF1bHQgc3R5bGUgaXMgdXNlZDpcbiAqIGBgYGpzXG4gKiAgaW1wb3J0IHtDaXJjbGUsIEZpbGwsIFN0cm9rZSwgU3R5bGV9IGZyb20gJ29sL3N0eWxlLmpzJztcbiAqXG4gKiAgY29uc3QgZmlsbCA9IG5ldyBGaWxsKHtcbiAqICAgIGNvbG9yOiAncmdiYSgyNTUsMjU1LDI1NSwwLjQpJyxcbiAqICB9KTtcbiAqICBjb25zdCBzdHJva2UgPSBuZXcgU3Ryb2tlKHtcbiAqICAgIGNvbG9yOiAnIzMzOTlDQycsXG4gKiAgICB3aWR0aDogMS4yNSxcbiAqICB9KTtcbiAqICBjb25zdCBzdHlsZXMgPSBbXG4gKiAgICBuZXcgU3R5bGUoe1xuICogICAgICBpbWFnZTogbmV3IENpcmNsZSh7XG4gKiAgICAgICAgZmlsbDogZmlsbCxcbiAqICAgICAgICBzdHJva2U6IHN0cm9rZSxcbiAqICAgICAgICByYWRpdXM6IDUsXG4gKiAgICAgIH0pLFxuICogICAgICBmaWxsOiBmaWxsLFxuICogICAgICBzdHJva2U6IHN0cm9rZSxcbiAqICAgIH0pLFxuICogIF07XG4gKiBgYGBcbiAqXG4gKiBBIHNlcGFyYXRlIGVkaXRpbmcgc3R5bGUgaGFzIHRoZSBmb2xsb3dpbmcgZGVmYXVsdHM6XG4gKiBgYGBqc1xuICogIGltcG9ydCB7Q2lyY2xlLCBGaWxsLCBTdHJva2UsIFN0eWxlfSBmcm9tICdvbC9zdHlsZS5qcyc7XG4gKlxuICogIGNvbnN0IHN0eWxlcyA9IHt9O1xuICogIGNvbnN0IHdoaXRlID0gWzI1NSwgMjU1LCAyNTUsIDFdO1xuICogIGNvbnN0IGJsdWUgPSBbMCwgMTUzLCAyNTUsIDFdO1xuICogIGNvbnN0IHdpZHRoID0gMztcbiAqICBzdHlsZXNbJ1BvbHlnb24nXSA9IFtcbiAqICAgIG5ldyBTdHlsZSh7XG4gKiAgICAgIGZpbGw6IG5ldyBGaWxsKHtcbiAqICAgICAgICBjb2xvcjogWzI1NSwgMjU1LCAyNTUsIDAuNV0sXG4gKiAgICAgIH0pLFxuICogICAgfSksXG4gKiAgXTtcbiAqICBzdHlsZXNbJ011bHRpUG9seWdvbiddID1cbiAqICAgICAgc3R5bGVzWydQb2x5Z29uJ107XG4gKiAgc3R5bGVzWydMaW5lU3RyaW5nJ10gPSBbXG4gKiAgICBuZXcgU3R5bGUoe1xuICogICAgICBzdHJva2U6IG5ldyBTdHJva2Uoe1xuICogICAgICAgIGNvbG9yOiB3aGl0ZSxcbiAqICAgICAgICB3aWR0aDogd2lkdGggKyAyLFxuICogICAgICB9KSxcbiAqICAgIH0pLFxuICogICAgbmV3IFN0eWxlKHtcbiAqICAgICAgc3Ryb2tlOiBuZXcgU3Ryb2tlKHtcbiAqICAgICAgICBjb2xvcjogYmx1ZSxcbiAqICAgICAgICB3aWR0aDogd2lkdGgsXG4gKiAgICAgIH0pLFxuICogICAgfSksXG4gKiAgXTtcbiAqICBzdHlsZXNbJ011bHRpTGluZVN0cmluZyddID0gc3R5bGVzWydMaW5lU3RyaW5nJ107XG4gKlxuICogIHN0eWxlc1snQ2lyY2xlJ10gPSBzdHlsZXNbJ1BvbHlnb24nXS5jb25jYXQoXG4gKiAgICBzdHlsZXNbJ0xpbmVTdHJpbmcnXVxuICogICk7XG4gKlxuICogIHN0eWxlc1snUG9pbnQnXSA9IFtcbiAqICAgIG5ldyBTdHlsZSh7XG4gKiAgICAgIGltYWdlOiBuZXcgQ2lyY2xlKHtcbiAqICAgICAgICByYWRpdXM6IHdpZHRoICogMixcbiAqICAgICAgICBmaWxsOiBuZXcgRmlsbCh7XG4gKiAgICAgICAgICBjb2xvcjogYmx1ZSxcbiAqICAgICAgICB9KSxcbiAqICAgICAgICBzdHJva2U6IG5ldyBTdHJva2Uoe1xuICogICAgICAgICAgY29sb3I6IHdoaXRlLFxuICogICAgICAgICAgd2lkdGg6IHdpZHRoIC8gMixcbiAqICAgICAgICB9KSxcbiAqICAgICAgfSksXG4gKiAgICAgIHpJbmRleDogSW5maW5pdHksXG4gKiAgICB9KSxcbiAqICBdO1xuICogIHN0eWxlc1snTXVsdGlQb2ludCddID1cbiAqICAgICAgc3R5bGVzWydQb2ludCddO1xuICogIHN0eWxlc1snR2VvbWV0cnlDb2xsZWN0aW9uJ10gPVxuICogICAgICBzdHlsZXNbJ1BvbHlnb24nXS5jb25jYXQoXG4gKiAgICAgICAgICBzdHlsZXNbJ0xpbmVTdHJpbmcnXSxcbiAqICAgICAgICAgIHN0eWxlc1snUG9pbnQnXVxuICogICAgICApO1xuICogYGBgXG4gKlxuICogQGFwaVxuICovXG5jbGFzcyBTdHlsZSB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge09wdGlvbnN9IFtvcHRpb25zXSBTdHlsZSBvcHRpb25zLlxuICAgKi9cbiAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7c3RyaW5nfGltcG9ydChcIi4uL2dlb20vR2VvbWV0cnkuanNcIikuZGVmYXVsdHxHZW9tZXRyeUZ1bmN0aW9ufVxuICAgICAqL1xuICAgIHRoaXMuZ2VvbWV0cnlfID0gbnVsbDtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUgeyFHZW9tZXRyeUZ1bmN0aW9ufVxuICAgICAqL1xuICAgIHRoaXMuZ2VvbWV0cnlGdW5jdGlvbl8gPSBkZWZhdWx0R2VvbWV0cnlGdW5jdGlvbjtcblxuICAgIGlmIChvcHRpb25zLmdlb21ldHJ5ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHRoaXMuc2V0R2VvbWV0cnkob3B0aW9ucy5nZW9tZXRyeSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7aW1wb3J0KFwiLi9GaWxsLmpzXCIpLmRlZmF1bHR9XG4gICAgICovXG4gICAgdGhpcy5maWxsXyA9IG9wdGlvbnMuZmlsbCAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5maWxsIDogbnVsbDtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge2ltcG9ydChcIi4vSW1hZ2UuanNcIikuZGVmYXVsdH1cbiAgICAgKi9cbiAgICB0aGlzLmltYWdlXyA9IG9wdGlvbnMuaW1hZ2UgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMuaW1hZ2UgOiBudWxsO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7UmVuZGVyRnVuY3Rpb258bnVsbH1cbiAgICAgKi9cbiAgICB0aGlzLnJlbmRlcmVyXyA9IG9wdGlvbnMucmVuZGVyZXIgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMucmVuZGVyZXIgOiBudWxsO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7UmVuZGVyRnVuY3Rpb258bnVsbH1cbiAgICAgKi9cbiAgICB0aGlzLmhpdERldGVjdGlvblJlbmRlcmVyXyA9XG4gICAgICBvcHRpb25zLmhpdERldGVjdGlvblJlbmRlcmVyICE9PSB1bmRlZmluZWRcbiAgICAgICAgPyBvcHRpb25zLmhpdERldGVjdGlvblJlbmRlcmVyXG4gICAgICAgIDogbnVsbDtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge2ltcG9ydChcIi4vU3Ryb2tlLmpzXCIpLmRlZmF1bHR9XG4gICAgICovXG4gICAgdGhpcy5zdHJva2VfID0gb3B0aW9ucy5zdHJva2UgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMuc3Ryb2tlIDogbnVsbDtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge2ltcG9ydChcIi4vVGV4dC5qc1wiKS5kZWZhdWx0fVxuICAgICAqL1xuICAgIHRoaXMudGV4dF8gPSBvcHRpb25zLnRleHQgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMudGV4dCA6IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtudW1iZXJ8dW5kZWZpbmVkfVxuICAgICAqL1xuICAgIHRoaXMuekluZGV4XyA9IG9wdGlvbnMuekluZGV4O1xuICB9XG5cbiAgLyoqXG4gICAqIENsb25lcyB0aGUgc3R5bGUuXG4gICAqIEByZXR1cm4ge1N0eWxlfSBUaGUgY2xvbmVkIHN0eWxlLlxuICAgKiBAYXBpXG4gICAqL1xuICBjbG9uZSgpIHtcbiAgICBsZXQgZ2VvbWV0cnkgPSB0aGlzLmdldEdlb21ldHJ5KCk7XG4gICAgaWYgKGdlb21ldHJ5ICYmIHR5cGVvZiBnZW9tZXRyeSA9PT0gJ29iamVjdCcpIHtcbiAgICAgIGdlb21ldHJ5ID0gLyoqIEB0eXBlIHtpbXBvcnQoXCIuLi9nZW9tL0dlb21ldHJ5LmpzXCIpLmRlZmF1bHR9ICovIChcbiAgICAgICAgZ2VvbWV0cnlcbiAgICAgICkuY2xvbmUoKTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBTdHlsZSh7XG4gICAgICBnZW9tZXRyeTogZ2VvbWV0cnksXG4gICAgICBmaWxsOiB0aGlzLmdldEZpbGwoKSA/IHRoaXMuZ2V0RmlsbCgpLmNsb25lKCkgOiB1bmRlZmluZWQsXG4gICAgICBpbWFnZTogdGhpcy5nZXRJbWFnZSgpID8gdGhpcy5nZXRJbWFnZSgpLmNsb25lKCkgOiB1bmRlZmluZWQsXG4gICAgICByZW5kZXJlcjogdGhpcy5nZXRSZW5kZXJlcigpLFxuICAgICAgc3Ryb2tlOiB0aGlzLmdldFN0cm9rZSgpID8gdGhpcy5nZXRTdHJva2UoKS5jbG9uZSgpIDogdW5kZWZpbmVkLFxuICAgICAgdGV4dDogdGhpcy5nZXRUZXh0KCkgPyB0aGlzLmdldFRleHQoKS5jbG9uZSgpIDogdW5kZWZpbmVkLFxuICAgICAgekluZGV4OiB0aGlzLmdldFpJbmRleCgpLFxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgY3VzdG9tIHJlbmRlcmVyIGZ1bmN0aW9uIHRoYXQgd2FzIGNvbmZpZ3VyZWQgd2l0aFxuICAgKiB7QGxpbmsgI3NldFJlbmRlcmVyfSBvciB0aGUgYHJlbmRlcmVyYCBjb25zdHJ1Y3RvciBvcHRpb24uXG4gICAqIEByZXR1cm4ge1JlbmRlckZ1bmN0aW9ufG51bGx9IEN1c3RvbSByZW5kZXJlciBmdW5jdGlvbi5cbiAgICogQGFwaVxuICAgKi9cbiAgZ2V0UmVuZGVyZXIoKSB7XG4gICAgcmV0dXJuIHRoaXMucmVuZGVyZXJfO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldHMgYSBjdXN0b20gcmVuZGVyZXIgZnVuY3Rpb24gZm9yIHRoaXMgc3R5bGUuIFdoZW4gc2V0LCBgZmlsbGAsIGBzdHJva2VgXG4gICAqIGFuZCBgaW1hZ2VgIG9wdGlvbnMgb2YgdGhlIHN0eWxlIHdpbGwgYmUgaWdub3JlZC5cbiAgICogQHBhcmFtIHtSZW5kZXJGdW5jdGlvbnxudWxsfSByZW5kZXJlciBDdXN0b20gcmVuZGVyZXIgZnVuY3Rpb24uXG4gICAqIEBhcGlcbiAgICovXG4gIHNldFJlbmRlcmVyKHJlbmRlcmVyKSB7XG4gICAgdGhpcy5yZW5kZXJlcl8gPSByZW5kZXJlcjtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXRzIGEgY3VzdG9tIHJlbmRlcmVyIGZ1bmN0aW9uIGZvciB0aGlzIHN0eWxlIHVzZWRcbiAgICogaW4gaGl0IGRldGVjdGlvbi5cbiAgICogQHBhcmFtIHtSZW5kZXJGdW5jdGlvbnxudWxsfSByZW5kZXJlciBDdXN0b20gcmVuZGVyZXIgZnVuY3Rpb24uXG4gICAqIEBhcGlcbiAgICovXG4gIHNldEhpdERldGVjdGlvblJlbmRlcmVyKHJlbmRlcmVyKSB7XG4gICAgdGhpcy5oaXREZXRlY3Rpb25SZW5kZXJlcl8gPSByZW5kZXJlcjtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIGN1c3RvbSByZW5kZXJlciBmdW5jdGlvbiB0aGF0IHdhcyBjb25maWd1cmVkIHdpdGhcbiAgICoge0BsaW5rICNzZXRIaXREZXRlY3Rpb25SZW5kZXJlcn0gb3IgdGhlIGBoaXREZXRlY3Rpb25SZW5kZXJlcmAgY29uc3RydWN0b3Igb3B0aW9uLlxuICAgKiBAcmV0dXJuIHtSZW5kZXJGdW5jdGlvbnxudWxsfSBDdXN0b20gcmVuZGVyZXIgZnVuY3Rpb24uXG4gICAqIEBhcGlcbiAgICovXG4gIGdldEhpdERldGVjdGlvblJlbmRlcmVyKCkge1xuICAgIHJldHVybiB0aGlzLmhpdERldGVjdGlvblJlbmRlcmVyXztcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIGdlb21ldHJ5IHRvIGJlIHJlbmRlcmVkLlxuICAgKiBAcmV0dXJuIHtzdHJpbmd8aW1wb3J0KFwiLi4vZ2VvbS9HZW9tZXRyeS5qc1wiKS5kZWZhdWx0fEdlb21ldHJ5RnVuY3Rpb259XG4gICAqIEZlYXR1cmUgcHJvcGVydHkgb3IgZ2VvbWV0cnkgb3IgZnVuY3Rpb24gdGhhdCByZXR1cm5zIHRoZSBnZW9tZXRyeSB0aGF0IHdpbGxcbiAgICogYmUgcmVuZGVyZWQgd2l0aCB0aGlzIHN0eWxlLlxuICAgKiBAYXBpXG4gICAqL1xuICBnZXRHZW9tZXRyeSgpIHtcbiAgICByZXR1cm4gdGhpcy5nZW9tZXRyeV87XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBmdW5jdGlvbiB1c2VkIHRvIGdlbmVyYXRlIGEgZ2VvbWV0cnkgZm9yIHJlbmRlcmluZy5cbiAgICogQHJldHVybiB7IUdlb21ldHJ5RnVuY3Rpb259IEZ1bmN0aW9uIHRoYXQgaXMgY2FsbGVkIHdpdGggYSBmZWF0dXJlXG4gICAqIGFuZCByZXR1cm5zIHRoZSBnZW9tZXRyeSB0byByZW5kZXIgaW5zdGVhZCBvZiB0aGUgZmVhdHVyZSdzIGdlb21ldHJ5LlxuICAgKiBAYXBpXG4gICAqL1xuICBnZXRHZW9tZXRyeUZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLmdlb21ldHJ5RnVuY3Rpb25fO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgZmlsbCBzdHlsZS5cbiAgICogQHJldHVybiB7aW1wb3J0KFwiLi9GaWxsLmpzXCIpLmRlZmF1bHR9IEZpbGwgc3R5bGUuXG4gICAqIEBhcGlcbiAgICovXG4gIGdldEZpbGwoKSB7XG4gICAgcmV0dXJuIHRoaXMuZmlsbF87XG4gIH1cblxuICAvKipcbiAgICogU2V0IHRoZSBmaWxsIHN0eWxlLlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4vRmlsbC5qc1wiKS5kZWZhdWx0fSBmaWxsIEZpbGwgc3R5bGUuXG4gICAqIEBhcGlcbiAgICovXG4gIHNldEZpbGwoZmlsbCkge1xuICAgIHRoaXMuZmlsbF8gPSBmaWxsO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgaW1hZ2Ugc3R5bGUuXG4gICAqIEByZXR1cm4ge2ltcG9ydChcIi4vSW1hZ2UuanNcIikuZGVmYXVsdH0gSW1hZ2Ugc3R5bGUuXG4gICAqIEBhcGlcbiAgICovXG4gIGdldEltYWdlKCkge1xuICAgIHJldHVybiB0aGlzLmltYWdlXztcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXQgdGhlIGltYWdlIHN0eWxlLlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4vSW1hZ2UuanNcIikuZGVmYXVsdH0gaW1hZ2UgSW1hZ2Ugc3R5bGUuXG4gICAqIEBhcGlcbiAgICovXG4gIHNldEltYWdlKGltYWdlKSB7XG4gICAgdGhpcy5pbWFnZV8gPSBpbWFnZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIHN0cm9rZSBzdHlsZS5cbiAgICogQHJldHVybiB7aW1wb3J0KFwiLi9TdHJva2UuanNcIikuZGVmYXVsdH0gU3Ryb2tlIHN0eWxlLlxuICAgKiBAYXBpXG4gICAqL1xuICBnZXRTdHJva2UoKSB7XG4gICAgcmV0dXJuIHRoaXMuc3Ryb2tlXztcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXQgdGhlIHN0cm9rZSBzdHlsZS5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuL1N0cm9rZS5qc1wiKS5kZWZhdWx0fSBzdHJva2UgU3Ryb2tlIHN0eWxlLlxuICAgKiBAYXBpXG4gICAqL1xuICBzZXRTdHJva2Uoc3Ryb2tlKSB7XG4gICAgdGhpcy5zdHJva2VfID0gc3Ryb2tlO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgdGV4dCBzdHlsZS5cbiAgICogQHJldHVybiB7aW1wb3J0KFwiLi9UZXh0LmpzXCIpLmRlZmF1bHR9IFRleHQgc3R5bGUuXG4gICAqIEBhcGlcbiAgICovXG4gIGdldFRleHQoKSB7XG4gICAgcmV0dXJuIHRoaXMudGV4dF87XG4gIH1cblxuICAvKipcbiAgICogU2V0IHRoZSB0ZXh0IHN0eWxlLlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4vVGV4dC5qc1wiKS5kZWZhdWx0fSB0ZXh0IFRleHQgc3R5bGUuXG4gICAqIEBhcGlcbiAgICovXG4gIHNldFRleHQodGV4dCkge1xuICAgIHRoaXMudGV4dF8gPSB0ZXh0O1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgei1pbmRleCBmb3IgdGhlIHN0eWxlLlxuICAgKiBAcmV0dXJuIHtudW1iZXJ8dW5kZWZpbmVkfSBaSW5kZXguXG4gICAqIEBhcGlcbiAgICovXG4gIGdldFpJbmRleCgpIHtcbiAgICByZXR1cm4gdGhpcy56SW5kZXhfO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldCBhIGdlb21ldHJ5IHRoYXQgaXMgcmVuZGVyZWQgaW5zdGVhZCBvZiB0aGUgZmVhdHVyZSdzIGdlb21ldHJ5LlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ3xpbXBvcnQoXCIuLi9nZW9tL0dlb21ldHJ5LmpzXCIpLmRlZmF1bHR8R2VvbWV0cnlGdW5jdGlvbn0gZ2VvbWV0cnlcbiAgICogICAgIEZlYXR1cmUgcHJvcGVydHkgb3IgZ2VvbWV0cnkgb3IgZnVuY3Rpb24gcmV0dXJuaW5nIGEgZ2VvbWV0cnkgdG8gcmVuZGVyXG4gICAqICAgICBmb3IgdGhpcyBzdHlsZS5cbiAgICogQGFwaVxuICAgKi9cbiAgc2V0R2VvbWV0cnkoZ2VvbWV0cnkpIHtcbiAgICBpZiAodHlwZW9mIGdlb21ldHJ5ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICB0aGlzLmdlb21ldHJ5RnVuY3Rpb25fID0gZ2VvbWV0cnk7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgZ2VvbWV0cnkgPT09ICdzdHJpbmcnKSB7XG4gICAgICB0aGlzLmdlb21ldHJ5RnVuY3Rpb25fID0gZnVuY3Rpb24gKGZlYXR1cmUpIHtcbiAgICAgICAgcmV0dXJuIC8qKiBAdHlwZSB7aW1wb3J0KFwiLi4vZ2VvbS9HZW9tZXRyeS5qc1wiKS5kZWZhdWx0fSAqLyAoXG4gICAgICAgICAgZmVhdHVyZS5nZXQoZ2VvbWV0cnkpXG4gICAgICAgICk7XG4gICAgICB9O1xuICAgIH0gZWxzZSBpZiAoIWdlb21ldHJ5KSB7XG4gICAgICB0aGlzLmdlb21ldHJ5RnVuY3Rpb25fID0gZGVmYXVsdEdlb21ldHJ5RnVuY3Rpb247XG4gICAgfSBlbHNlIGlmIChnZW9tZXRyeSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aGlzLmdlb21ldHJ5RnVuY3Rpb25fID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gLyoqIEB0eXBlIHtpbXBvcnQoXCIuLi9nZW9tL0dlb21ldHJ5LmpzXCIpLmRlZmF1bHR9ICovIChnZW9tZXRyeSk7XG4gICAgICB9O1xuICAgIH1cbiAgICB0aGlzLmdlb21ldHJ5XyA9IGdlb21ldHJ5O1xuICB9XG5cbiAgLyoqXG4gICAqIFNldCB0aGUgei1pbmRleC5cbiAgICpcbiAgICogQHBhcmFtIHtudW1iZXJ8dW5kZWZpbmVkfSB6SW5kZXggWkluZGV4LlxuICAgKiBAYXBpXG4gICAqL1xuICBzZXRaSW5kZXgoekluZGV4KSB7XG4gICAgdGhpcy56SW5kZXhfID0gekluZGV4O1xuICB9XG59XG5cbi8qKlxuICogQ29udmVydCB0aGUgcHJvdmlkZWQgb2JqZWN0IGludG8gYSBzdHlsZSBmdW5jdGlvbi4gIEZ1bmN0aW9ucyBwYXNzZWQgdGhyb3VnaFxuICogdW5jaGFuZ2VkLiAgQXJyYXlzIG9mIFN0eWxlIG9yIHNpbmdsZSBzdHlsZSBvYmplY3RzIHdyYXBwZWQgaW4gYVxuICogbmV3IHN0eWxlIGZ1bmN0aW9uLlxuICogQHBhcmFtIHtTdHlsZUZ1bmN0aW9ufEFycmF5PFN0eWxlPnxTdHlsZX0gb2JqXG4gKiAgICAgQSBzdHlsZSBmdW5jdGlvbiwgYSBzaW5nbGUgc3R5bGUsIG9yIGFuIGFycmF5IG9mIHN0eWxlcy5cbiAqIEByZXR1cm4ge1N0eWxlRnVuY3Rpb259IEEgc3R5bGUgZnVuY3Rpb24uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0b0Z1bmN0aW9uKG9iaikge1xuICBsZXQgc3R5bGVGdW5jdGlvbjtcblxuICBpZiAodHlwZW9mIG9iaiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHN0eWxlRnVuY3Rpb24gPSBvYmo7XG4gIH0gZWxzZSB7XG4gICAgLyoqXG4gICAgICogQHR5cGUge0FycmF5PFN0eWxlPn1cbiAgICAgKi9cbiAgICBsZXQgc3R5bGVzO1xuICAgIGlmIChBcnJheS5pc0FycmF5KG9iaikpIHtcbiAgICAgIHN0eWxlcyA9IG9iajtcbiAgICB9IGVsc2Uge1xuICAgICAgYXNzZXJ0KHR5cGVvZiAoLyoqIEB0eXBlIHs/fSAqLyAob2JqKS5nZXRaSW5kZXgpID09PSAnZnVuY3Rpb24nLCA0MSk7IC8vIEV4cGVjdGVkIGFuIGBTdHlsZWAgb3IgYW4gYXJyYXkgb2YgYFN0eWxlYFxuICAgICAgY29uc3Qgc3R5bGUgPSAvKiogQHR5cGUge1N0eWxlfSAqLyAob2JqKTtcbiAgICAgIHN0eWxlcyA9IFtzdHlsZV07XG4gICAgfVxuICAgIHN0eWxlRnVuY3Rpb24gPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gc3R5bGVzO1xuICAgIH07XG4gIH1cbiAgcmV0dXJuIHN0eWxlRnVuY3Rpb247XG59XG5cbi8qKlxuICogQHR5cGUge0FycmF5PFN0eWxlPnxudWxsfVxuICovXG5sZXQgZGVmYXVsdFN0eWxlcyA9IG51bGw7XG5cbi8qKlxuICogQHBhcmFtIHtpbXBvcnQoXCIuLi9GZWF0dXJlLmpzXCIpLkZlYXR1cmVMaWtlfSBmZWF0dXJlIEZlYXR1cmUuXG4gKiBAcGFyYW0ge251bWJlcn0gcmVzb2x1dGlvbiBSZXNvbHV0aW9uLlxuICogQHJldHVybiB7QXJyYXk8U3R5bGU+fSBTdHlsZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZURlZmF1bHRTdHlsZShmZWF0dXJlLCByZXNvbHV0aW9uKSB7XG4gIC8vIFdlIGRvbid0IHVzZSBhbiBpbW1lZGlhdGVseS1pbnZva2VkIGZ1bmN0aW9uXG4gIC8vIGFuZCBhIGNsb3N1cmUgc28gd2UgZG9uJ3QgZ2V0IGFuIGVycm9yIGF0IHNjcmlwdCBldmFsdWF0aW9uIHRpbWUgaW5cbiAgLy8gYnJvd3NlcnMgdGhhdCBkbyBub3Qgc3VwcG9ydCBDYW52YXMuIChpbXBvcnQoXCIuL0NpcmNsZS5qc1wiKS5DaXJjbGVTdHlsZSBkb2VzXG4gIC8vIGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpIGF0IGNvbnN0cnVjdGlvbiB0aW1lLCB3aGljaCB3aWxsIGNhdXNlIGFuLmVycm9yXG4gIC8vIGluIHN1Y2ggYnJvd3NlcnMuKVxuICBpZiAoIWRlZmF1bHRTdHlsZXMpIHtcbiAgICBjb25zdCBmaWxsID0gbmV3IEZpbGwoe1xuICAgICAgY29sb3I6ICdyZ2JhKDI1NSwyNTUsMjU1LDAuNCknLFxuICAgIH0pO1xuICAgIGNvbnN0IHN0cm9rZSA9IG5ldyBTdHJva2Uoe1xuICAgICAgY29sb3I6ICcjMzM5OUNDJyxcbiAgICAgIHdpZHRoOiAxLjI1LFxuICAgIH0pO1xuICAgIGRlZmF1bHRTdHlsZXMgPSBbXG4gICAgICBuZXcgU3R5bGUoe1xuICAgICAgICBpbWFnZTogbmV3IENpcmNsZVN0eWxlKHtcbiAgICAgICAgICBmaWxsOiBmaWxsLFxuICAgICAgICAgIHN0cm9rZTogc3Ryb2tlLFxuICAgICAgICAgIHJhZGl1czogNSxcbiAgICAgICAgfSksXG4gICAgICAgIGZpbGw6IGZpbGwsXG4gICAgICAgIHN0cm9rZTogc3Ryb2tlLFxuICAgICAgfSksXG4gICAgXTtcbiAgfVxuICByZXR1cm4gZGVmYXVsdFN0eWxlcztcbn1cblxuLyoqXG4gKiBEZWZhdWx0IHN0eWxlcyBmb3IgZWRpdGluZyBmZWF0dXJlcy5cbiAqIEByZXR1cm4ge09iamVjdDxpbXBvcnQoXCIuLi9nZW9tL0dlb21ldHJ5LmpzXCIpLlR5cGUsIEFycmF5PFN0eWxlPj59IFN0eWxlc1xuICovXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlRWRpdGluZ1N0eWxlKCkge1xuICAvKiogQHR5cGUge09iamVjdDxpbXBvcnQoXCIuLi9nZW9tL0dlb21ldHJ5LmpzXCIpLlR5cGUsIEFycmF5PFN0eWxlPj59ICovXG4gIGNvbnN0IHN0eWxlcyA9IHt9O1xuICBjb25zdCB3aGl0ZSA9IFsyNTUsIDI1NSwgMjU1LCAxXTtcbiAgY29uc3QgYmx1ZSA9IFswLCAxNTMsIDI1NSwgMV07XG4gIGNvbnN0IHdpZHRoID0gMztcbiAgc3R5bGVzWydQb2x5Z29uJ10gPSBbXG4gICAgbmV3IFN0eWxlKHtcbiAgICAgIGZpbGw6IG5ldyBGaWxsKHtcbiAgICAgICAgY29sb3I6IFsyNTUsIDI1NSwgMjU1LCAwLjVdLFxuICAgICAgfSksXG4gICAgfSksXG4gIF07XG4gIHN0eWxlc1snTXVsdGlQb2x5Z29uJ10gPSBzdHlsZXNbJ1BvbHlnb24nXTtcblxuICBzdHlsZXNbJ0xpbmVTdHJpbmcnXSA9IFtcbiAgICBuZXcgU3R5bGUoe1xuICAgICAgc3Ryb2tlOiBuZXcgU3Ryb2tlKHtcbiAgICAgICAgY29sb3I6IHdoaXRlLFxuICAgICAgICB3aWR0aDogd2lkdGggKyAyLFxuICAgICAgfSksXG4gICAgfSksXG4gICAgbmV3IFN0eWxlKHtcbiAgICAgIHN0cm9rZTogbmV3IFN0cm9rZSh7XG4gICAgICAgIGNvbG9yOiBibHVlLFxuICAgICAgICB3aWR0aDogd2lkdGgsXG4gICAgICB9KSxcbiAgICB9KSxcbiAgXTtcbiAgc3R5bGVzWydNdWx0aUxpbmVTdHJpbmcnXSA9IHN0eWxlc1snTGluZVN0cmluZyddO1xuXG4gIHN0eWxlc1snQ2lyY2xlJ10gPSBzdHlsZXNbJ1BvbHlnb24nXS5jb25jYXQoc3R5bGVzWydMaW5lU3RyaW5nJ10pO1xuXG4gIHN0eWxlc1snUG9pbnQnXSA9IFtcbiAgICBuZXcgU3R5bGUoe1xuICAgICAgaW1hZ2U6IG5ldyBDaXJjbGVTdHlsZSh7XG4gICAgICAgIHJhZGl1czogd2lkdGggKiAyLFxuICAgICAgICBmaWxsOiBuZXcgRmlsbCh7XG4gICAgICAgICAgY29sb3I6IGJsdWUsXG4gICAgICAgIH0pLFxuICAgICAgICBzdHJva2U6IG5ldyBTdHJva2Uoe1xuICAgICAgICAgIGNvbG9yOiB3aGl0ZSxcbiAgICAgICAgICB3aWR0aDogd2lkdGggLyAyLFxuICAgICAgICB9KSxcbiAgICAgIH0pLFxuICAgICAgekluZGV4OiBJbmZpbml0eSxcbiAgICB9KSxcbiAgXTtcbiAgc3R5bGVzWydNdWx0aVBvaW50J10gPSBzdHlsZXNbJ1BvaW50J107XG5cbiAgc3R5bGVzWydHZW9tZXRyeUNvbGxlY3Rpb24nXSA9IHN0eWxlc1snUG9seWdvbiddLmNvbmNhdChcbiAgICBzdHlsZXNbJ0xpbmVTdHJpbmcnXSxcbiAgICBzdHlsZXNbJ1BvaW50J11cbiAgKTtcblxuICByZXR1cm4gc3R5bGVzO1xufVxuXG4vKipcbiAqIEZ1bmN0aW9uIHRoYXQgaXMgY2FsbGVkIHdpdGggYSBmZWF0dXJlIGFuZCByZXR1cm5zIGl0cyBkZWZhdWx0IGdlb21ldHJ5LlxuICogQHBhcmFtIHtpbXBvcnQoXCIuLi9GZWF0dXJlLmpzXCIpLkZlYXR1cmVMaWtlfSBmZWF0dXJlIEZlYXR1cmUgdG8gZ2V0IHRoZSBnZW9tZXRyeSBmb3IuXG4gKiBAcmV0dXJuIHtpbXBvcnQoXCIuLi9nZW9tL0dlb21ldHJ5LmpzXCIpLmRlZmF1bHR8aW1wb3J0KFwiLi4vcmVuZGVyL0ZlYXR1cmUuanNcIikuZGVmYXVsdHx1bmRlZmluZWR9IEdlb21ldHJ5IHRvIHJlbmRlci5cbiAqL1xuZnVuY3Rpb24gZGVmYXVsdEdlb21ldHJ5RnVuY3Rpb24oZmVhdHVyZSkge1xuICByZXR1cm4gZmVhdHVyZS5nZXRHZW9tZXRyeSgpO1xufVxuXG5leHBvcnQgZGVmYXVsdCBTdHlsZTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///47539\n')},21280:function(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__){eval("/* harmony import */ var _Fill_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(51345);\n/* harmony import */ var _size_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(4307);\n/**\n * @module ol/style/Text\n */\n\n\n\n/**\n * @typedef {'point' | 'line'} TextPlacement\n * Default text placement is `'point'`. Note that\n * `'line'` requires the underlying geometry to be a {@link module:ol/geom/LineString~LineString},\n * {@link module:ol/geom/Polygon~Polygon}, {@link module:ol/geom/MultiLineString~MultiLineString} or\n * {@link module:ol/geom/MultiPolygon~MultiPolygon}.\n */\n\n/**\n * @typedef {'left' | 'center' | 'right'} TextJustify\n */\n\n/**\n * The default fill color to use if no fill was set at construction time; a\n * blackish `#333`.\n *\n * @const {string}\n */\nconst DEFAULT_FILL_COLOR = '#333';\n\n/**\n * @typedef {Object} Options\n * @property {string} [font] Font style as CSS `font` value, see:\n * https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/font. Default is `'10px sans-serif'`\n * @property {number} [maxAngle=Math.PI/4] When `placement` is set to `'line'`, allow a maximum angle between adjacent characters.\n * The expected value is in radians, and the default is 45° (`Math.PI / 4`).\n * @property {number} [offsetX=0] Horizontal text offset in pixels. A positive will shift the text right.\n * @property {number} [offsetY=0] Vertical text offset in pixels. A positive will shift the text down.\n * @property {boolean} [overflow=false] For polygon labels or when `placement` is set to `'line'`, allow text to exceed\n * the width of the polygon at the label position or the length of the path that it follows.\n * @property {TextPlacement} [placement='point'] Text placement.\n * @property {number} [repeat] Repeat interval in pixels. When set, the text will be repeated at this interval. Only available\n * when `placement` is set to `'line'`. Overrides 'textAlign'.\n * @property {number|import(\"../size.js\").Size} [scale] Scale.\n * @property {boolean} [rotateWithView=false] Whether to rotate the text with the view.\n * @property {number} [rotation=0] Rotation in radians (positive rotation clockwise).\n * @property {string|Array<string>} [text] Text content or rich text content. For plain text provide a string, which can\n * contain line breaks (`\\n`). For rich text provide an array of text/font tuples. A tuple consists of the text to\n * render and the font to use (or `''` to use the text style's font). A line break has to be a separate tuple (i.e. `'\\n', ''`).\n * **Example:** `['foo', 'bold 10px sans-serif', ' bar', 'italic 10px sans-serif', ' baz', '']` will yield \"**foo** *bar* baz\".\n * **Note:** Rich text is not supported for the immediate rendering API.\n * @property {CanvasTextAlign} [textAlign] Text alignment. Possible values: `'left'`, `'right'`, `'center'`, `'end'` or `'start'`.\n * Default is `'center'` for `placement: 'point'`. For `placement: 'line'`, the default is to let the renderer choose a\n * placement where `maxAngle` is not exceeded.\n * @property {TextJustify} [justify] Text justification within the text box.\n * If not set, text is justified towards the `textAlign` anchor.\n * Otherwise, use options `'left'`, `'center'`, or `'right'` to justify the text within the text box.\n * **Note:** `justify` is ignored for immediate rendering and also for `placement: 'line'`.\n * @property {CanvasTextBaseline} [textBaseline='middle'] Text base line. Possible values: `'bottom'`, `'top'`, `'middle'`, `'alphabetic'`,\n * `'hanging'`, `'ideographic'`.\n * @property {import(\"./Fill.js\").default} [fill] Fill style. If none is provided, we'll use a dark fill-style (#333).\n * @property {import(\"./Stroke.js\").default} [stroke] Stroke style.\n * @property {import(\"./Fill.js\").default} [backgroundFill] Fill style for the text background when `placement` is\n * `'point'`. Default is no fill.\n * @property {import(\"./Stroke.js\").default} [backgroundStroke] Stroke style for the text background  when `placement`\n * is `'point'`. Default is no stroke.\n * @property {Array<number>} [padding=[0, 0, 0, 0]] Padding in pixels around the text for decluttering and background. The order of\n * values in the array is `[top, right, bottom, left]`.\n */\n\n/**\n * @classdesc\n * Set text style for vector features.\n * @api\n */\nclass Text {\n  /**\n   * @param {Options} [options] Options.\n   */\n  constructor(options) {\n    options = options || {};\n\n    /**\n     * @private\n     * @type {string|undefined}\n     */\n    this.font_ = options.font;\n\n    /**\n     * @private\n     * @type {number|undefined}\n     */\n    this.rotation_ = options.rotation;\n\n    /**\n     * @private\n     * @type {boolean|undefined}\n     */\n    this.rotateWithView_ = options.rotateWithView;\n\n    /**\n     * @private\n     * @type {number|import(\"../size.js\").Size|undefined}\n     */\n    this.scale_ = options.scale;\n\n    /**\n     * @private\n     * @type {import(\"../size.js\").Size}\n     */\n    this.scaleArray_ = (0,_size_js__WEBPACK_IMPORTED_MODULE_0__/* .toSize */ .Pq)(options.scale !== undefined ? options.scale : 1);\n\n    /**\n     * @private\n     * @type {string|Array<string>|undefined}\n     */\n    this.text_ = options.text;\n\n    /**\n     * @private\n     * @type {CanvasTextAlign|undefined}\n     */\n    this.textAlign_ = options.textAlign;\n\n    /**\n     * @private\n     * @type {TextJustify|undefined}\n     */\n    this.justify_ = options.justify;\n\n    /**\n     * @private\n     * @type {number|undefined}\n     */\n    this.repeat_ = options.repeat;\n\n    /**\n     * @private\n     * @type {CanvasTextBaseline|undefined}\n     */\n    this.textBaseline_ = options.textBaseline;\n\n    /**\n     * @private\n     * @type {import(\"./Fill.js\").default}\n     */\n    this.fill_ =\n      options.fill !== undefined\n        ? options.fill\n        : new _Fill_js__WEBPACK_IMPORTED_MODULE_1__/* [\"default\"] */ .Z({color: DEFAULT_FILL_COLOR});\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.maxAngle_ =\n      options.maxAngle !== undefined ? options.maxAngle : Math.PI / 4;\n\n    /**\n     * @private\n     * @type {TextPlacement}\n     */\n    this.placement_ =\n      options.placement !== undefined ? options.placement : 'point';\n\n    /**\n     * @private\n     * @type {boolean}\n     */\n    this.overflow_ = !!options.overflow;\n\n    /**\n     * @private\n     * @type {import(\"./Stroke.js\").default}\n     */\n    this.stroke_ = options.stroke !== undefined ? options.stroke : null;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.offsetX_ = options.offsetX !== undefined ? options.offsetX : 0;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.offsetY_ = options.offsetY !== undefined ? options.offsetY : 0;\n\n    /**\n     * @private\n     * @type {import(\"./Fill.js\").default}\n     */\n    this.backgroundFill_ = options.backgroundFill\n      ? options.backgroundFill\n      : null;\n\n    /**\n     * @private\n     * @type {import(\"./Stroke.js\").default}\n     */\n    this.backgroundStroke_ = options.backgroundStroke\n      ? options.backgroundStroke\n      : null;\n\n    /**\n     * @private\n     * @type {Array<number>|null}\n     */\n    this.padding_ = options.padding === undefined ? null : options.padding;\n  }\n\n  /**\n   * Clones the style.\n   * @return {Text} The cloned style.\n   * @api\n   */\n  clone() {\n    const scale = this.getScale();\n    return new Text({\n      font: this.getFont(),\n      placement: this.getPlacement(),\n      repeat: this.getRepeat(),\n      maxAngle: this.getMaxAngle(),\n      overflow: this.getOverflow(),\n      rotation: this.getRotation(),\n      rotateWithView: this.getRotateWithView(),\n      scale: Array.isArray(scale) ? scale.slice() : scale,\n      text: this.getText(),\n      textAlign: this.getTextAlign(),\n      justify: this.getJustify(),\n      textBaseline: this.getTextBaseline(),\n      fill: this.getFill() ? this.getFill().clone() : undefined,\n      stroke: this.getStroke() ? this.getStroke().clone() : undefined,\n      offsetX: this.getOffsetX(),\n      offsetY: this.getOffsetY(),\n      backgroundFill: this.getBackgroundFill()\n        ? this.getBackgroundFill().clone()\n        : undefined,\n      backgroundStroke: this.getBackgroundStroke()\n        ? this.getBackgroundStroke().clone()\n        : undefined,\n      padding: this.getPadding() || undefined,\n    });\n  }\n\n  /**\n   * Get the `overflow` configuration.\n   * @return {boolean} Let text overflow the length of the path they follow.\n   * @api\n   */\n  getOverflow() {\n    return this.overflow_;\n  }\n\n  /**\n   * Get the font name.\n   * @return {string|undefined} Font.\n   * @api\n   */\n  getFont() {\n    return this.font_;\n  }\n\n  /**\n   * Get the maximum angle between adjacent characters.\n   * @return {number} Angle in radians.\n   * @api\n   */\n  getMaxAngle() {\n    return this.maxAngle_;\n  }\n\n  /**\n   * Get the label placement.\n   * @return {TextPlacement} Text placement.\n   * @api\n   */\n  getPlacement() {\n    return this.placement_;\n  }\n\n  /**\n   * Get the repeat interval of the text.\n   * @return {number|undefined} Repeat interval in pixels.\n   * @api\n   */\n  getRepeat() {\n    return this.repeat_;\n  }\n\n  /**\n   * Get the x-offset for the text.\n   * @return {number} Horizontal text offset.\n   * @api\n   */\n  getOffsetX() {\n    return this.offsetX_;\n  }\n\n  /**\n   * Get the y-offset for the text.\n   * @return {number} Vertical text offset.\n   * @api\n   */\n  getOffsetY() {\n    return this.offsetY_;\n  }\n\n  /**\n   * Get the fill style for the text.\n   * @return {import(\"./Fill.js\").default} Fill style.\n   * @api\n   */\n  getFill() {\n    return this.fill_;\n  }\n\n  /**\n   * Determine whether the text rotates with the map.\n   * @return {boolean|undefined} Rotate with map.\n   * @api\n   */\n  getRotateWithView() {\n    return this.rotateWithView_;\n  }\n\n  /**\n   * Get the text rotation.\n   * @return {number|undefined} Rotation.\n   * @api\n   */\n  getRotation() {\n    return this.rotation_;\n  }\n\n  /**\n   * Get the text scale.\n   * @return {number|import(\"../size.js\").Size|undefined} Scale.\n   * @api\n   */\n  getScale() {\n    return this.scale_;\n  }\n\n  /**\n   * Get the symbolizer scale array.\n   * @return {import(\"../size.js\").Size} Scale array.\n   */\n  getScaleArray() {\n    return this.scaleArray_;\n  }\n\n  /**\n   * Get the stroke style for the text.\n   * @return {import(\"./Stroke.js\").default} Stroke style.\n   * @api\n   */\n  getStroke() {\n    return this.stroke_;\n  }\n\n  /**\n   * Get the text to be rendered.\n   * @return {string|Array<string>|undefined} Text.\n   * @api\n   */\n  getText() {\n    return this.text_;\n  }\n\n  /**\n   * Get the text alignment.\n   * @return {CanvasTextAlign|undefined} Text align.\n   * @api\n   */\n  getTextAlign() {\n    return this.textAlign_;\n  }\n\n  /**\n   * Get the justification.\n   * @return {TextJustify|undefined} Justification.\n   * @api\n   */\n  getJustify() {\n    return this.justify_;\n  }\n\n  /**\n   * Get the text baseline.\n   * @return {CanvasTextBaseline|undefined} Text baseline.\n   * @api\n   */\n  getTextBaseline() {\n    return this.textBaseline_;\n  }\n\n  /**\n   * Get the background fill style for the text.\n   * @return {import(\"./Fill.js\").default} Fill style.\n   * @api\n   */\n  getBackgroundFill() {\n    return this.backgroundFill_;\n  }\n\n  /**\n   * Get the background stroke style for the text.\n   * @return {import(\"./Stroke.js\").default} Stroke style.\n   * @api\n   */\n  getBackgroundStroke() {\n    return this.backgroundStroke_;\n  }\n\n  /**\n   * Get the padding for the text.\n   * @return {Array<number>|null} Padding.\n   * @api\n   */\n  getPadding() {\n    return this.padding_;\n  }\n\n  /**\n   * Set the `overflow` property.\n   *\n   * @param {boolean} overflow Let text overflow the path that it follows.\n   * @api\n   */\n  setOverflow(overflow) {\n    this.overflow_ = overflow;\n  }\n\n  /**\n   * Set the font.\n   *\n   * @param {string|undefined} font Font.\n   * @api\n   */\n  setFont(font) {\n    this.font_ = font;\n  }\n\n  /**\n   * Set the maximum angle between adjacent characters.\n   *\n   * @param {number} maxAngle Angle in radians.\n   * @api\n   */\n  setMaxAngle(maxAngle) {\n    this.maxAngle_ = maxAngle;\n  }\n\n  /**\n   * Set the x offset.\n   *\n   * @param {number} offsetX Horizontal text offset.\n   * @api\n   */\n  setOffsetX(offsetX) {\n    this.offsetX_ = offsetX;\n  }\n\n  /**\n   * Set the y offset.\n   *\n   * @param {number} offsetY Vertical text offset.\n   * @api\n   */\n  setOffsetY(offsetY) {\n    this.offsetY_ = offsetY;\n  }\n\n  /**\n   * Set the text placement.\n   *\n   * @param {TextPlacement} placement Placement.\n   * @api\n   */\n  setPlacement(placement) {\n    this.placement_ = placement;\n  }\n\n  /**\n   * Set the repeat interval of the text.\n   * @param {number|undefined} [repeat] Repeat interval in pixels.\n   * @api\n   */\n  setRepeat(repeat) {\n    this.repeat_ = repeat;\n  }\n\n  /**\n   * Set whether to rotate the text with the view.\n   *\n   * @param {boolean} rotateWithView Rotate with map.\n   * @api\n   */\n  setRotateWithView(rotateWithView) {\n    this.rotateWithView_ = rotateWithView;\n  }\n\n  /**\n   * Set the fill.\n   *\n   * @param {import(\"./Fill.js\").default} fill Fill style.\n   * @api\n   */\n  setFill(fill) {\n    this.fill_ = fill;\n  }\n\n  /**\n   * Set the rotation.\n   *\n   * @param {number|undefined} rotation Rotation.\n   * @api\n   */\n  setRotation(rotation) {\n    this.rotation_ = rotation;\n  }\n\n  /**\n   * Set the scale.\n   *\n   * @param {number|import(\"../size.js\").Size|undefined} scale Scale.\n   * @api\n   */\n  setScale(scale) {\n    this.scale_ = scale;\n    this.scaleArray_ = (0,_size_js__WEBPACK_IMPORTED_MODULE_0__/* .toSize */ .Pq)(scale !== undefined ? scale : 1);\n  }\n\n  /**\n   * Set the stroke.\n   *\n   * @param {import(\"./Stroke.js\").default} stroke Stroke style.\n   * @api\n   */\n  setStroke(stroke) {\n    this.stroke_ = stroke;\n  }\n\n  /**\n   * Set the text.\n   *\n   * @param {string|Array<string>|undefined} text Text.\n   * @api\n   */\n  setText(text) {\n    this.text_ = text;\n  }\n\n  /**\n   * Set the text alignment.\n   *\n   * @param {CanvasTextAlign|undefined} textAlign Text align.\n   * @api\n   */\n  setTextAlign(textAlign) {\n    this.textAlign_ = textAlign;\n  }\n\n  /**\n   * Set the justification.\n   *\n   * @param {TextJustify|undefined} justify Justification.\n   * @api\n   */\n  setJustify(justify) {\n    this.justify_ = justify;\n  }\n\n  /**\n   * Set the text baseline.\n   *\n   * @param {CanvasTextBaseline|undefined} textBaseline Text baseline.\n   * @api\n   */\n  setTextBaseline(textBaseline) {\n    this.textBaseline_ = textBaseline;\n  }\n\n  /**\n   * Set the background fill.\n   *\n   * @param {import(\"./Fill.js\").default} fill Fill style.\n   * @api\n   */\n  setBackgroundFill(fill) {\n    this.backgroundFill_ = fill;\n  }\n\n  /**\n   * Set the background stroke.\n   *\n   * @param {import(\"./Stroke.js\").default} stroke Stroke style.\n   * @api\n   */\n  setBackgroundStroke(stroke) {\n    this.backgroundStroke_ = stroke;\n  }\n\n  /**\n   * Set the padding (`[top, right, bottom, left]`).\n   *\n   * @param {Array<number>|null} padding Padding.\n   * @api\n   */\n  setPadding(padding) {\n    this.padding_ = padding;\n  }\n}\n\n/* harmony default export */ __webpack_exports__[\"Z\"] = (Text);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QUNBO0FBQ0E7QUFDQSxhQUFhLDhCQUE4QjtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsNkJBQTZCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYSwrQkFBK0I7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLG9CQUFvQjtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEseURBQWUsSUFBSSxFQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdnVlMy13ZWJwYWNrNS8uL25vZGVfbW9kdWxlcy9vbC9zdHlsZS9UZXh0LmpzPzdiZmMiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAbW9kdWxlIG9sL3N0eWxlL1RleHRcbiAqL1xuaW1wb3J0IEZpbGwgZnJvbSAnLi9GaWxsLmpzJztcbmltcG9ydCB7dG9TaXplfSBmcm9tICcuLi9zaXplLmpzJztcblxuLyoqXG4gKiBAdHlwZWRlZiB7J3BvaW50JyB8ICdsaW5lJ30gVGV4dFBsYWNlbWVudFxuICogRGVmYXVsdCB0ZXh0IHBsYWNlbWVudCBpcyBgJ3BvaW50J2AuIE5vdGUgdGhhdFxuICogYCdsaW5lJ2AgcmVxdWlyZXMgdGhlIHVuZGVybHlpbmcgZ2VvbWV0cnkgdG8gYmUgYSB7QGxpbmsgbW9kdWxlOm9sL2dlb20vTGluZVN0cmluZ35MaW5lU3RyaW5nfSxcbiAqIHtAbGluayBtb2R1bGU6b2wvZ2VvbS9Qb2x5Z29uflBvbHlnb259LCB7QGxpbmsgbW9kdWxlOm9sL2dlb20vTXVsdGlMaW5lU3RyaW5nfk11bHRpTGluZVN0cmluZ30gb3JcbiAqIHtAbGluayBtb2R1bGU6b2wvZ2VvbS9NdWx0aVBvbHlnb25+TXVsdGlQb2x5Z29ufS5cbiAqL1xuXG4vKipcbiAqIEB0eXBlZGVmIHsnbGVmdCcgfCAnY2VudGVyJyB8ICdyaWdodCd9IFRleHRKdXN0aWZ5XG4gKi9cblxuLyoqXG4gKiBUaGUgZGVmYXVsdCBmaWxsIGNvbG9yIHRvIHVzZSBpZiBubyBmaWxsIHdhcyBzZXQgYXQgY29uc3RydWN0aW9uIHRpbWU7IGFcbiAqIGJsYWNraXNoIGAjMzMzYC5cbiAqXG4gKiBAY29uc3Qge3N0cmluZ31cbiAqL1xuY29uc3QgREVGQVVMVF9GSUxMX0NPTE9SID0gJyMzMzMnO1xuXG4vKipcbiAqIEB0eXBlZGVmIHtPYmplY3R9IE9wdGlvbnNcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbZm9udF0gRm9udCBzdHlsZSBhcyBDU1MgYGZvbnRgIHZhbHVlLCBzZWU6XG4gKiBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJEL2ZvbnQuIERlZmF1bHQgaXMgYCcxMHB4IHNhbnMtc2VyaWYnYFxuICogQHByb3BlcnR5IHtudW1iZXJ9IFttYXhBbmdsZT1NYXRoLlBJLzRdIFdoZW4gYHBsYWNlbWVudGAgaXMgc2V0IHRvIGAnbGluZSdgLCBhbGxvdyBhIG1heGltdW0gYW5nbGUgYmV0d2VlbiBhZGphY2VudCBjaGFyYWN0ZXJzLlxuICogVGhlIGV4cGVjdGVkIHZhbHVlIGlzIGluIHJhZGlhbnMsIGFuZCB0aGUgZGVmYXVsdCBpcyA0NcKwIChgTWF0aC5QSSAvIDRgKS5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbb2Zmc2V0WD0wXSBIb3Jpem9udGFsIHRleHQgb2Zmc2V0IGluIHBpeGVscy4gQSBwb3NpdGl2ZSB3aWxsIHNoaWZ0IHRoZSB0ZXh0IHJpZ2h0LlxuICogQHByb3BlcnR5IHtudW1iZXJ9IFtvZmZzZXRZPTBdIFZlcnRpY2FsIHRleHQgb2Zmc2V0IGluIHBpeGVscy4gQSBwb3NpdGl2ZSB3aWxsIHNoaWZ0IHRoZSB0ZXh0IGRvd24uXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IFtvdmVyZmxvdz1mYWxzZV0gRm9yIHBvbHlnb24gbGFiZWxzIG9yIHdoZW4gYHBsYWNlbWVudGAgaXMgc2V0IHRvIGAnbGluZSdgLCBhbGxvdyB0ZXh0IHRvIGV4Y2VlZFxuICogdGhlIHdpZHRoIG9mIHRoZSBwb2x5Z29uIGF0IHRoZSBsYWJlbCBwb3NpdGlvbiBvciB0aGUgbGVuZ3RoIG9mIHRoZSBwYXRoIHRoYXQgaXQgZm9sbG93cy5cbiAqIEBwcm9wZXJ0eSB7VGV4dFBsYWNlbWVudH0gW3BsYWNlbWVudD0ncG9pbnQnXSBUZXh0IHBsYWNlbWVudC5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbcmVwZWF0XSBSZXBlYXQgaW50ZXJ2YWwgaW4gcGl4ZWxzLiBXaGVuIHNldCwgdGhlIHRleHQgd2lsbCBiZSByZXBlYXRlZCBhdCB0aGlzIGludGVydmFsLiBPbmx5IGF2YWlsYWJsZVxuICogd2hlbiBgcGxhY2VtZW50YCBpcyBzZXQgdG8gYCdsaW5lJ2AuIE92ZXJyaWRlcyAndGV4dEFsaWduJy5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfGltcG9ydChcIi4uL3NpemUuanNcIikuU2l6ZX0gW3NjYWxlXSBTY2FsZS5cbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW3JvdGF0ZVdpdGhWaWV3PWZhbHNlXSBXaGV0aGVyIHRvIHJvdGF0ZSB0aGUgdGV4dCB3aXRoIHRoZSB2aWV3LlxuICogQHByb3BlcnR5IHtudW1iZXJ9IFtyb3RhdGlvbj0wXSBSb3RhdGlvbiBpbiByYWRpYW5zIChwb3NpdGl2ZSByb3RhdGlvbiBjbG9ja3dpc2UpLlxuICogQHByb3BlcnR5IHtzdHJpbmd8QXJyYXk8c3RyaW5nPn0gW3RleHRdIFRleHQgY29udGVudCBvciByaWNoIHRleHQgY29udGVudC4gRm9yIHBsYWluIHRleHQgcHJvdmlkZSBhIHN0cmluZywgd2hpY2ggY2FuXG4gKiBjb250YWluIGxpbmUgYnJlYWtzIChgXFxuYCkuIEZvciByaWNoIHRleHQgcHJvdmlkZSBhbiBhcnJheSBvZiB0ZXh0L2ZvbnQgdHVwbGVzLiBBIHR1cGxlIGNvbnNpc3RzIG9mIHRoZSB0ZXh0IHRvXG4gKiByZW5kZXIgYW5kIHRoZSBmb250IHRvIHVzZSAob3IgYCcnYCB0byB1c2UgdGhlIHRleHQgc3R5bGUncyBmb250KS4gQSBsaW5lIGJyZWFrIGhhcyB0byBiZSBhIHNlcGFyYXRlIHR1cGxlIChpLmUuIGAnXFxuJywgJydgKS5cbiAqICoqRXhhbXBsZToqKiBgWydmb28nLCAnYm9sZCAxMHB4IHNhbnMtc2VyaWYnLCAnIGJhcicsICdpdGFsaWMgMTBweCBzYW5zLXNlcmlmJywgJyBiYXonLCAnJ11gIHdpbGwgeWllbGQgXCIqKmZvbyoqICpiYXIqIGJhelwiLlxuICogKipOb3RlOioqIFJpY2ggdGV4dCBpcyBub3Qgc3VwcG9ydGVkIGZvciB0aGUgaW1tZWRpYXRlIHJlbmRlcmluZyBBUEkuXG4gKiBAcHJvcGVydHkge0NhbnZhc1RleHRBbGlnbn0gW3RleHRBbGlnbl0gVGV4dCBhbGlnbm1lbnQuIFBvc3NpYmxlIHZhbHVlczogYCdsZWZ0J2AsIGAncmlnaHQnYCwgYCdjZW50ZXInYCwgYCdlbmQnYCBvciBgJ3N0YXJ0J2AuXG4gKiBEZWZhdWx0IGlzIGAnY2VudGVyJ2AgZm9yIGBwbGFjZW1lbnQ6ICdwb2ludCdgLiBGb3IgYHBsYWNlbWVudDogJ2xpbmUnYCwgdGhlIGRlZmF1bHQgaXMgdG8gbGV0IHRoZSByZW5kZXJlciBjaG9vc2UgYVxuICogcGxhY2VtZW50IHdoZXJlIGBtYXhBbmdsZWAgaXMgbm90IGV4Y2VlZGVkLlxuICogQHByb3BlcnR5IHtUZXh0SnVzdGlmeX0gW2p1c3RpZnldIFRleHQganVzdGlmaWNhdGlvbiB3aXRoaW4gdGhlIHRleHQgYm94LlxuICogSWYgbm90IHNldCwgdGV4dCBpcyBqdXN0aWZpZWQgdG93YXJkcyB0aGUgYHRleHRBbGlnbmAgYW5jaG9yLlxuICogT3RoZXJ3aXNlLCB1c2Ugb3B0aW9ucyBgJ2xlZnQnYCwgYCdjZW50ZXInYCwgb3IgYCdyaWdodCdgIHRvIGp1c3RpZnkgdGhlIHRleHQgd2l0aGluIHRoZSB0ZXh0IGJveC5cbiAqICoqTm90ZToqKiBganVzdGlmeWAgaXMgaWdub3JlZCBmb3IgaW1tZWRpYXRlIHJlbmRlcmluZyBhbmQgYWxzbyBmb3IgYHBsYWNlbWVudDogJ2xpbmUnYC5cbiAqIEBwcm9wZXJ0eSB7Q2FudmFzVGV4dEJhc2VsaW5lfSBbdGV4dEJhc2VsaW5lPSdtaWRkbGUnXSBUZXh0IGJhc2UgbGluZS4gUG9zc2libGUgdmFsdWVzOiBgJ2JvdHRvbSdgLCBgJ3RvcCdgLCBgJ21pZGRsZSdgLCBgJ2FscGhhYmV0aWMnYCxcbiAqIGAnaGFuZ2luZydgLCBgJ2lkZW9ncmFwaGljJ2AuXG4gKiBAcHJvcGVydHkge2ltcG9ydChcIi4vRmlsbC5qc1wiKS5kZWZhdWx0fSBbZmlsbF0gRmlsbCBzdHlsZS4gSWYgbm9uZSBpcyBwcm92aWRlZCwgd2UnbGwgdXNlIGEgZGFyayBmaWxsLXN0eWxlICgjMzMzKS5cbiAqIEBwcm9wZXJ0eSB7aW1wb3J0KFwiLi9TdHJva2UuanNcIikuZGVmYXVsdH0gW3N0cm9rZV0gU3Ryb2tlIHN0eWxlLlxuICogQHByb3BlcnR5IHtpbXBvcnQoXCIuL0ZpbGwuanNcIikuZGVmYXVsdH0gW2JhY2tncm91bmRGaWxsXSBGaWxsIHN0eWxlIGZvciB0aGUgdGV4dCBiYWNrZ3JvdW5kIHdoZW4gYHBsYWNlbWVudGAgaXNcbiAqIGAncG9pbnQnYC4gRGVmYXVsdCBpcyBubyBmaWxsLlxuICogQHByb3BlcnR5IHtpbXBvcnQoXCIuL1N0cm9rZS5qc1wiKS5kZWZhdWx0fSBbYmFja2dyb3VuZFN0cm9rZV0gU3Ryb2tlIHN0eWxlIGZvciB0aGUgdGV4dCBiYWNrZ3JvdW5kICB3aGVuIGBwbGFjZW1lbnRgXG4gKiBpcyBgJ3BvaW50J2AuIERlZmF1bHQgaXMgbm8gc3Ryb2tlLlxuICogQHByb3BlcnR5IHtBcnJheTxudW1iZXI+fSBbcGFkZGluZz1bMCwgMCwgMCwgMF1dIFBhZGRpbmcgaW4gcGl4ZWxzIGFyb3VuZCB0aGUgdGV4dCBmb3IgZGVjbHV0dGVyaW5nIGFuZCBiYWNrZ3JvdW5kLiBUaGUgb3JkZXIgb2ZcbiAqIHZhbHVlcyBpbiB0aGUgYXJyYXkgaXMgYFt0b3AsIHJpZ2h0LCBib3R0b20sIGxlZnRdYC5cbiAqL1xuXG4vKipcbiAqIEBjbGFzc2Rlc2NcbiAqIFNldCB0ZXh0IHN0eWxlIGZvciB2ZWN0b3IgZmVhdHVyZXMuXG4gKiBAYXBpXG4gKi9cbmNsYXNzIFRleHQge1xuICAvKipcbiAgICogQHBhcmFtIHtPcHRpb25zfSBbb3B0aW9uc10gT3B0aW9ucy5cbiAgICovXG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge3N0cmluZ3x1bmRlZmluZWR9XG4gICAgICovXG4gICAgdGhpcy5mb250XyA9IG9wdGlvbnMuZm9udDtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge251bWJlcnx1bmRlZmluZWR9XG4gICAgICovXG4gICAgdGhpcy5yb3RhdGlvbl8gPSBvcHRpb25zLnJvdGF0aW9uO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7Ym9vbGVhbnx1bmRlZmluZWR9XG4gICAgICovXG4gICAgdGhpcy5yb3RhdGVXaXRoVmlld18gPSBvcHRpb25zLnJvdGF0ZVdpdGhWaWV3O1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7bnVtYmVyfGltcG9ydChcIi4uL3NpemUuanNcIikuU2l6ZXx1bmRlZmluZWR9XG4gICAgICovXG4gICAgdGhpcy5zY2FsZV8gPSBvcHRpb25zLnNjYWxlO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7aW1wb3J0KFwiLi4vc2l6ZS5qc1wiKS5TaXplfVxuICAgICAqL1xuICAgIHRoaXMuc2NhbGVBcnJheV8gPSB0b1NpemUob3B0aW9ucy5zY2FsZSAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5zY2FsZSA6IDEpO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7c3RyaW5nfEFycmF5PHN0cmluZz58dW5kZWZpbmVkfVxuICAgICAqL1xuICAgIHRoaXMudGV4dF8gPSBvcHRpb25zLnRleHQ7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtDYW52YXNUZXh0QWxpZ258dW5kZWZpbmVkfVxuICAgICAqL1xuICAgIHRoaXMudGV4dEFsaWduXyA9IG9wdGlvbnMudGV4dEFsaWduO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7VGV4dEp1c3RpZnl8dW5kZWZpbmVkfVxuICAgICAqL1xuICAgIHRoaXMuanVzdGlmeV8gPSBvcHRpb25zLmp1c3RpZnk7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtudW1iZXJ8dW5kZWZpbmVkfVxuICAgICAqL1xuICAgIHRoaXMucmVwZWF0XyA9IG9wdGlvbnMucmVwZWF0O1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7Q2FudmFzVGV4dEJhc2VsaW5lfHVuZGVmaW5lZH1cbiAgICAgKi9cbiAgICB0aGlzLnRleHRCYXNlbGluZV8gPSBvcHRpb25zLnRleHRCYXNlbGluZTtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge2ltcG9ydChcIi4vRmlsbC5qc1wiKS5kZWZhdWx0fVxuICAgICAqL1xuICAgIHRoaXMuZmlsbF8gPVxuICAgICAgb3B0aW9ucy5maWxsICE9PSB1bmRlZmluZWRcbiAgICAgICAgPyBvcHRpb25zLmZpbGxcbiAgICAgICAgOiBuZXcgRmlsbCh7Y29sb3I6IERFRkFVTFRfRklMTF9DT0xPUn0pO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMubWF4QW5nbGVfID1cbiAgICAgIG9wdGlvbnMubWF4QW5nbGUgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMubWF4QW5nbGUgOiBNYXRoLlBJIC8gNDtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge1RleHRQbGFjZW1lbnR9XG4gICAgICovXG4gICAgdGhpcy5wbGFjZW1lbnRfID1cbiAgICAgIG9wdGlvbnMucGxhY2VtZW50ICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLnBsYWNlbWVudCA6ICdwb2ludCc7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAqL1xuICAgIHRoaXMub3ZlcmZsb3dfID0gISFvcHRpb25zLm92ZXJmbG93O1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7aW1wb3J0KFwiLi9TdHJva2UuanNcIikuZGVmYXVsdH1cbiAgICAgKi9cbiAgICB0aGlzLnN0cm9rZV8gPSBvcHRpb25zLnN0cm9rZSAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5zdHJva2UgOiBudWxsO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMub2Zmc2V0WF8gPSBvcHRpb25zLm9mZnNldFggIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMub2Zmc2V0WCA6IDA7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5vZmZzZXRZXyA9IG9wdGlvbnMub2Zmc2V0WSAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5vZmZzZXRZIDogMDtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge2ltcG9ydChcIi4vRmlsbC5qc1wiKS5kZWZhdWx0fVxuICAgICAqL1xuICAgIHRoaXMuYmFja2dyb3VuZEZpbGxfID0gb3B0aW9ucy5iYWNrZ3JvdW5kRmlsbFxuICAgICAgPyBvcHRpb25zLmJhY2tncm91bmRGaWxsXG4gICAgICA6IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtpbXBvcnQoXCIuL1N0cm9rZS5qc1wiKS5kZWZhdWx0fVxuICAgICAqL1xuICAgIHRoaXMuYmFja2dyb3VuZFN0cm9rZV8gPSBvcHRpb25zLmJhY2tncm91bmRTdHJva2VcbiAgICAgID8gb3B0aW9ucy5iYWNrZ3JvdW5kU3Ryb2tlXG4gICAgICA6IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtBcnJheTxudW1iZXI+fG51bGx9XG4gICAgICovXG4gICAgdGhpcy5wYWRkaW5nXyA9IG9wdGlvbnMucGFkZGluZyA9PT0gdW5kZWZpbmVkID8gbnVsbCA6IG9wdGlvbnMucGFkZGluZztcbiAgfVxuXG4gIC8qKlxuICAgKiBDbG9uZXMgdGhlIHN0eWxlLlxuICAgKiBAcmV0dXJuIHtUZXh0fSBUaGUgY2xvbmVkIHN0eWxlLlxuICAgKiBAYXBpXG4gICAqL1xuICBjbG9uZSgpIHtcbiAgICBjb25zdCBzY2FsZSA9IHRoaXMuZ2V0U2NhbGUoKTtcbiAgICByZXR1cm4gbmV3IFRleHQoe1xuICAgICAgZm9udDogdGhpcy5nZXRGb250KCksXG4gICAgICBwbGFjZW1lbnQ6IHRoaXMuZ2V0UGxhY2VtZW50KCksXG4gICAgICByZXBlYXQ6IHRoaXMuZ2V0UmVwZWF0KCksXG4gICAgICBtYXhBbmdsZTogdGhpcy5nZXRNYXhBbmdsZSgpLFxuICAgICAgb3ZlcmZsb3c6IHRoaXMuZ2V0T3ZlcmZsb3coKSxcbiAgICAgIHJvdGF0aW9uOiB0aGlzLmdldFJvdGF0aW9uKCksXG4gICAgICByb3RhdGVXaXRoVmlldzogdGhpcy5nZXRSb3RhdGVXaXRoVmlldygpLFxuICAgICAgc2NhbGU6IEFycmF5LmlzQXJyYXkoc2NhbGUpID8gc2NhbGUuc2xpY2UoKSA6IHNjYWxlLFxuICAgICAgdGV4dDogdGhpcy5nZXRUZXh0KCksXG4gICAgICB0ZXh0QWxpZ246IHRoaXMuZ2V0VGV4dEFsaWduKCksXG4gICAgICBqdXN0aWZ5OiB0aGlzLmdldEp1c3RpZnkoKSxcbiAgICAgIHRleHRCYXNlbGluZTogdGhpcy5nZXRUZXh0QmFzZWxpbmUoKSxcbiAgICAgIGZpbGw6IHRoaXMuZ2V0RmlsbCgpID8gdGhpcy5nZXRGaWxsKCkuY2xvbmUoKSA6IHVuZGVmaW5lZCxcbiAgICAgIHN0cm9rZTogdGhpcy5nZXRTdHJva2UoKSA/IHRoaXMuZ2V0U3Ryb2tlKCkuY2xvbmUoKSA6IHVuZGVmaW5lZCxcbiAgICAgIG9mZnNldFg6IHRoaXMuZ2V0T2Zmc2V0WCgpLFxuICAgICAgb2Zmc2V0WTogdGhpcy5nZXRPZmZzZXRZKCksXG4gICAgICBiYWNrZ3JvdW5kRmlsbDogdGhpcy5nZXRCYWNrZ3JvdW5kRmlsbCgpXG4gICAgICAgID8gdGhpcy5nZXRCYWNrZ3JvdW5kRmlsbCgpLmNsb25lKClcbiAgICAgICAgOiB1bmRlZmluZWQsXG4gICAgICBiYWNrZ3JvdW5kU3Ryb2tlOiB0aGlzLmdldEJhY2tncm91bmRTdHJva2UoKVxuICAgICAgICA/IHRoaXMuZ2V0QmFja2dyb3VuZFN0cm9rZSgpLmNsb25lKClcbiAgICAgICAgOiB1bmRlZmluZWQsXG4gICAgICBwYWRkaW5nOiB0aGlzLmdldFBhZGRpbmcoKSB8fCB1bmRlZmluZWQsXG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBgb3ZlcmZsb3dgIGNvbmZpZ3VyYXRpb24uXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IExldCB0ZXh0IG92ZXJmbG93IHRoZSBsZW5ndGggb2YgdGhlIHBhdGggdGhleSBmb2xsb3cuXG4gICAqIEBhcGlcbiAgICovXG4gIGdldE92ZXJmbG93KCkge1xuICAgIHJldHVybiB0aGlzLm92ZXJmbG93XztcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIGZvbnQgbmFtZS5cbiAgICogQHJldHVybiB7c3RyaW5nfHVuZGVmaW5lZH0gRm9udC5cbiAgICogQGFwaVxuICAgKi9cbiAgZ2V0Rm9udCgpIHtcbiAgICByZXR1cm4gdGhpcy5mb250XztcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIG1heGltdW0gYW5nbGUgYmV0d2VlbiBhZGphY2VudCBjaGFyYWN0ZXJzLlxuICAgKiBAcmV0dXJuIHtudW1iZXJ9IEFuZ2xlIGluIHJhZGlhbnMuXG4gICAqIEBhcGlcbiAgICovXG4gIGdldE1heEFuZ2xlKCkge1xuICAgIHJldHVybiB0aGlzLm1heEFuZ2xlXztcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIGxhYmVsIHBsYWNlbWVudC5cbiAgICogQHJldHVybiB7VGV4dFBsYWNlbWVudH0gVGV4dCBwbGFjZW1lbnQuXG4gICAqIEBhcGlcbiAgICovXG4gIGdldFBsYWNlbWVudCgpIHtcbiAgICByZXR1cm4gdGhpcy5wbGFjZW1lbnRfO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgcmVwZWF0IGludGVydmFsIG9mIHRoZSB0ZXh0LlxuICAgKiBAcmV0dXJuIHtudW1iZXJ8dW5kZWZpbmVkfSBSZXBlYXQgaW50ZXJ2YWwgaW4gcGl4ZWxzLlxuICAgKiBAYXBpXG4gICAqL1xuICBnZXRSZXBlYXQoKSB7XG4gICAgcmV0dXJuIHRoaXMucmVwZWF0XztcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIHgtb2Zmc2V0IGZvciB0aGUgdGV4dC5cbiAgICogQHJldHVybiB7bnVtYmVyfSBIb3Jpem9udGFsIHRleHQgb2Zmc2V0LlxuICAgKiBAYXBpXG4gICAqL1xuICBnZXRPZmZzZXRYKCkge1xuICAgIHJldHVybiB0aGlzLm9mZnNldFhfO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgeS1vZmZzZXQgZm9yIHRoZSB0ZXh0LlxuICAgKiBAcmV0dXJuIHtudW1iZXJ9IFZlcnRpY2FsIHRleHQgb2Zmc2V0LlxuICAgKiBAYXBpXG4gICAqL1xuICBnZXRPZmZzZXRZKCkge1xuICAgIHJldHVybiB0aGlzLm9mZnNldFlfO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgZmlsbCBzdHlsZSBmb3IgdGhlIHRleHQuXG4gICAqIEByZXR1cm4ge2ltcG9ydChcIi4vRmlsbC5qc1wiKS5kZWZhdWx0fSBGaWxsIHN0eWxlLlxuICAgKiBAYXBpXG4gICAqL1xuICBnZXRGaWxsKCkge1xuICAgIHJldHVybiB0aGlzLmZpbGxfO1xuICB9XG5cbiAgLyoqXG4gICAqIERldGVybWluZSB3aGV0aGVyIHRoZSB0ZXh0IHJvdGF0ZXMgd2l0aCB0aGUgbWFwLlxuICAgKiBAcmV0dXJuIHtib29sZWFufHVuZGVmaW5lZH0gUm90YXRlIHdpdGggbWFwLlxuICAgKiBAYXBpXG4gICAqL1xuICBnZXRSb3RhdGVXaXRoVmlldygpIHtcbiAgICByZXR1cm4gdGhpcy5yb3RhdGVXaXRoVmlld187XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSB0ZXh0IHJvdGF0aW9uLlxuICAgKiBAcmV0dXJuIHtudW1iZXJ8dW5kZWZpbmVkfSBSb3RhdGlvbi5cbiAgICogQGFwaVxuICAgKi9cbiAgZ2V0Um90YXRpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMucm90YXRpb25fO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgdGV4dCBzY2FsZS5cbiAgICogQHJldHVybiB7bnVtYmVyfGltcG9ydChcIi4uL3NpemUuanNcIikuU2l6ZXx1bmRlZmluZWR9IFNjYWxlLlxuICAgKiBAYXBpXG4gICAqL1xuICBnZXRTY2FsZSgpIHtcbiAgICByZXR1cm4gdGhpcy5zY2FsZV87XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBzeW1ib2xpemVyIHNjYWxlIGFycmF5LlxuICAgKiBAcmV0dXJuIHtpbXBvcnQoXCIuLi9zaXplLmpzXCIpLlNpemV9IFNjYWxlIGFycmF5LlxuICAgKi9cbiAgZ2V0U2NhbGVBcnJheSgpIHtcbiAgICByZXR1cm4gdGhpcy5zY2FsZUFycmF5XztcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIHN0cm9rZSBzdHlsZSBmb3IgdGhlIHRleHQuXG4gICAqIEByZXR1cm4ge2ltcG9ydChcIi4vU3Ryb2tlLmpzXCIpLmRlZmF1bHR9IFN0cm9rZSBzdHlsZS5cbiAgICogQGFwaVxuICAgKi9cbiAgZ2V0U3Ryb2tlKCkge1xuICAgIHJldHVybiB0aGlzLnN0cm9rZV87XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSB0ZXh0IHRvIGJlIHJlbmRlcmVkLlxuICAgKiBAcmV0dXJuIHtzdHJpbmd8QXJyYXk8c3RyaW5nPnx1bmRlZmluZWR9IFRleHQuXG4gICAqIEBhcGlcbiAgICovXG4gIGdldFRleHQoKSB7XG4gICAgcmV0dXJuIHRoaXMudGV4dF87XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSB0ZXh0IGFsaWdubWVudC5cbiAgICogQHJldHVybiB7Q2FudmFzVGV4dEFsaWdufHVuZGVmaW5lZH0gVGV4dCBhbGlnbi5cbiAgICogQGFwaVxuICAgKi9cbiAgZ2V0VGV4dEFsaWduKCkge1xuICAgIHJldHVybiB0aGlzLnRleHRBbGlnbl87XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBqdXN0aWZpY2F0aW9uLlxuICAgKiBAcmV0dXJuIHtUZXh0SnVzdGlmeXx1bmRlZmluZWR9IEp1c3RpZmljYXRpb24uXG4gICAqIEBhcGlcbiAgICovXG4gIGdldEp1c3RpZnkoKSB7XG4gICAgcmV0dXJuIHRoaXMuanVzdGlmeV87XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSB0ZXh0IGJhc2VsaW5lLlxuICAgKiBAcmV0dXJuIHtDYW52YXNUZXh0QmFzZWxpbmV8dW5kZWZpbmVkfSBUZXh0IGJhc2VsaW5lLlxuICAgKiBAYXBpXG4gICAqL1xuICBnZXRUZXh0QmFzZWxpbmUoKSB7XG4gICAgcmV0dXJuIHRoaXMudGV4dEJhc2VsaW5lXztcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIGJhY2tncm91bmQgZmlsbCBzdHlsZSBmb3IgdGhlIHRleHQuXG4gICAqIEByZXR1cm4ge2ltcG9ydChcIi4vRmlsbC5qc1wiKS5kZWZhdWx0fSBGaWxsIHN0eWxlLlxuICAgKiBAYXBpXG4gICAqL1xuICBnZXRCYWNrZ3JvdW5kRmlsbCgpIHtcbiAgICByZXR1cm4gdGhpcy5iYWNrZ3JvdW5kRmlsbF87XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBiYWNrZ3JvdW5kIHN0cm9rZSBzdHlsZSBmb3IgdGhlIHRleHQuXG4gICAqIEByZXR1cm4ge2ltcG9ydChcIi4vU3Ryb2tlLmpzXCIpLmRlZmF1bHR9IFN0cm9rZSBzdHlsZS5cbiAgICogQGFwaVxuICAgKi9cbiAgZ2V0QmFja2dyb3VuZFN0cm9rZSgpIHtcbiAgICByZXR1cm4gdGhpcy5iYWNrZ3JvdW5kU3Ryb2tlXztcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIHBhZGRpbmcgZm9yIHRoZSB0ZXh0LlxuICAgKiBAcmV0dXJuIHtBcnJheTxudW1iZXI+fG51bGx9IFBhZGRpbmcuXG4gICAqIEBhcGlcbiAgICovXG4gIGdldFBhZGRpbmcoKSB7XG4gICAgcmV0dXJuIHRoaXMucGFkZGluZ187XG4gIH1cblxuICAvKipcbiAgICogU2V0IHRoZSBgb3ZlcmZsb3dgIHByb3BlcnR5LlxuICAgKlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IG92ZXJmbG93IExldCB0ZXh0IG92ZXJmbG93IHRoZSBwYXRoIHRoYXQgaXQgZm9sbG93cy5cbiAgICogQGFwaVxuICAgKi9cbiAgc2V0T3ZlcmZsb3cob3ZlcmZsb3cpIHtcbiAgICB0aGlzLm92ZXJmbG93XyA9IG92ZXJmbG93O1xuICB9XG5cbiAgLyoqXG4gICAqIFNldCB0aGUgZm9udC5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd8dW5kZWZpbmVkfSBmb250IEZvbnQuXG4gICAqIEBhcGlcbiAgICovXG4gIHNldEZvbnQoZm9udCkge1xuICAgIHRoaXMuZm9udF8gPSBmb250O1xuICB9XG5cbiAgLyoqXG4gICAqIFNldCB0aGUgbWF4aW11bSBhbmdsZSBiZXR3ZWVuIGFkamFjZW50IGNoYXJhY3RlcnMuXG4gICAqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBtYXhBbmdsZSBBbmdsZSBpbiByYWRpYW5zLlxuICAgKiBAYXBpXG4gICAqL1xuICBzZXRNYXhBbmdsZShtYXhBbmdsZSkge1xuICAgIHRoaXMubWF4QW5nbGVfID0gbWF4QW5nbGU7XG4gIH1cblxuICAvKipcbiAgICogU2V0IHRoZSB4IG9mZnNldC5cbiAgICpcbiAgICogQHBhcmFtIHtudW1iZXJ9IG9mZnNldFggSG9yaXpvbnRhbCB0ZXh0IG9mZnNldC5cbiAgICogQGFwaVxuICAgKi9cbiAgc2V0T2Zmc2V0WChvZmZzZXRYKSB7XG4gICAgdGhpcy5vZmZzZXRYXyA9IG9mZnNldFg7XG4gIH1cblxuICAvKipcbiAgICogU2V0IHRoZSB5IG9mZnNldC5cbiAgICpcbiAgICogQHBhcmFtIHtudW1iZXJ9IG9mZnNldFkgVmVydGljYWwgdGV4dCBvZmZzZXQuXG4gICAqIEBhcGlcbiAgICovXG4gIHNldE9mZnNldFkob2Zmc2V0WSkge1xuICAgIHRoaXMub2Zmc2V0WV8gPSBvZmZzZXRZO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldCB0aGUgdGV4dCBwbGFjZW1lbnQuXG4gICAqXG4gICAqIEBwYXJhbSB7VGV4dFBsYWNlbWVudH0gcGxhY2VtZW50IFBsYWNlbWVudC5cbiAgICogQGFwaVxuICAgKi9cbiAgc2V0UGxhY2VtZW50KHBsYWNlbWVudCkge1xuICAgIHRoaXMucGxhY2VtZW50XyA9IHBsYWNlbWVudDtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXQgdGhlIHJlcGVhdCBpbnRlcnZhbCBvZiB0aGUgdGV4dC5cbiAgICogQHBhcmFtIHtudW1iZXJ8dW5kZWZpbmVkfSBbcmVwZWF0XSBSZXBlYXQgaW50ZXJ2YWwgaW4gcGl4ZWxzLlxuICAgKiBAYXBpXG4gICAqL1xuICBzZXRSZXBlYXQocmVwZWF0KSB7XG4gICAgdGhpcy5yZXBlYXRfID0gcmVwZWF0O1xuICB9XG5cbiAgLyoqXG4gICAqIFNldCB3aGV0aGVyIHRvIHJvdGF0ZSB0aGUgdGV4dCB3aXRoIHRoZSB2aWV3LlxuICAgKlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IHJvdGF0ZVdpdGhWaWV3IFJvdGF0ZSB3aXRoIG1hcC5cbiAgICogQGFwaVxuICAgKi9cbiAgc2V0Um90YXRlV2l0aFZpZXcocm90YXRlV2l0aFZpZXcpIHtcbiAgICB0aGlzLnJvdGF0ZVdpdGhWaWV3XyA9IHJvdGF0ZVdpdGhWaWV3O1xuICB9XG5cbiAgLyoqXG4gICAqIFNldCB0aGUgZmlsbC5cbiAgICpcbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuL0ZpbGwuanNcIikuZGVmYXVsdH0gZmlsbCBGaWxsIHN0eWxlLlxuICAgKiBAYXBpXG4gICAqL1xuICBzZXRGaWxsKGZpbGwpIHtcbiAgICB0aGlzLmZpbGxfID0gZmlsbDtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXQgdGhlIHJvdGF0aW9uLlxuICAgKlxuICAgKiBAcGFyYW0ge251bWJlcnx1bmRlZmluZWR9IHJvdGF0aW9uIFJvdGF0aW9uLlxuICAgKiBAYXBpXG4gICAqL1xuICBzZXRSb3RhdGlvbihyb3RhdGlvbikge1xuICAgIHRoaXMucm90YXRpb25fID0gcm90YXRpb247XG4gIH1cblxuICAvKipcbiAgICogU2V0IHRoZSBzY2FsZS5cbiAgICpcbiAgICogQHBhcmFtIHtudW1iZXJ8aW1wb3J0KFwiLi4vc2l6ZS5qc1wiKS5TaXplfHVuZGVmaW5lZH0gc2NhbGUgU2NhbGUuXG4gICAqIEBhcGlcbiAgICovXG4gIHNldFNjYWxlKHNjYWxlKSB7XG4gICAgdGhpcy5zY2FsZV8gPSBzY2FsZTtcbiAgICB0aGlzLnNjYWxlQXJyYXlfID0gdG9TaXplKHNjYWxlICE9PSB1bmRlZmluZWQgPyBzY2FsZSA6IDEpO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldCB0aGUgc3Ryb2tlLlxuICAgKlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4vU3Ryb2tlLmpzXCIpLmRlZmF1bHR9IHN0cm9rZSBTdHJva2Ugc3R5bGUuXG4gICAqIEBhcGlcbiAgICovXG4gIHNldFN0cm9rZShzdHJva2UpIHtcbiAgICB0aGlzLnN0cm9rZV8gPSBzdHJva2U7XG4gIH1cblxuICAvKipcbiAgICogU2V0IHRoZSB0ZXh0LlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ3xBcnJheTxzdHJpbmc+fHVuZGVmaW5lZH0gdGV4dCBUZXh0LlxuICAgKiBAYXBpXG4gICAqL1xuICBzZXRUZXh0KHRleHQpIHtcbiAgICB0aGlzLnRleHRfID0gdGV4dDtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXQgdGhlIHRleHQgYWxpZ25tZW50LlxuICAgKlxuICAgKiBAcGFyYW0ge0NhbnZhc1RleHRBbGlnbnx1bmRlZmluZWR9IHRleHRBbGlnbiBUZXh0IGFsaWduLlxuICAgKiBAYXBpXG4gICAqL1xuICBzZXRUZXh0QWxpZ24odGV4dEFsaWduKSB7XG4gICAgdGhpcy50ZXh0QWxpZ25fID0gdGV4dEFsaWduO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldCB0aGUganVzdGlmaWNhdGlvbi5cbiAgICpcbiAgICogQHBhcmFtIHtUZXh0SnVzdGlmeXx1bmRlZmluZWR9IGp1c3RpZnkgSnVzdGlmaWNhdGlvbi5cbiAgICogQGFwaVxuICAgKi9cbiAgc2V0SnVzdGlmeShqdXN0aWZ5KSB7XG4gICAgdGhpcy5qdXN0aWZ5XyA9IGp1c3RpZnk7XG4gIH1cblxuICAvKipcbiAgICogU2V0IHRoZSB0ZXh0IGJhc2VsaW5lLlxuICAgKlxuICAgKiBAcGFyYW0ge0NhbnZhc1RleHRCYXNlbGluZXx1bmRlZmluZWR9IHRleHRCYXNlbGluZSBUZXh0IGJhc2VsaW5lLlxuICAgKiBAYXBpXG4gICAqL1xuICBzZXRUZXh0QmFzZWxpbmUodGV4dEJhc2VsaW5lKSB7XG4gICAgdGhpcy50ZXh0QmFzZWxpbmVfID0gdGV4dEJhc2VsaW5lO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldCB0aGUgYmFja2dyb3VuZCBmaWxsLlxuICAgKlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4vRmlsbC5qc1wiKS5kZWZhdWx0fSBmaWxsIEZpbGwgc3R5bGUuXG4gICAqIEBhcGlcbiAgICovXG4gIHNldEJhY2tncm91bmRGaWxsKGZpbGwpIHtcbiAgICB0aGlzLmJhY2tncm91bmRGaWxsXyA9IGZpbGw7XG4gIH1cblxuICAvKipcbiAgICogU2V0IHRoZSBiYWNrZ3JvdW5kIHN0cm9rZS5cbiAgICpcbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuL1N0cm9rZS5qc1wiKS5kZWZhdWx0fSBzdHJva2UgU3Ryb2tlIHN0eWxlLlxuICAgKiBAYXBpXG4gICAqL1xuICBzZXRCYWNrZ3JvdW5kU3Ryb2tlKHN0cm9rZSkge1xuICAgIHRoaXMuYmFja2dyb3VuZFN0cm9rZV8gPSBzdHJva2U7XG4gIH1cblxuICAvKipcbiAgICogU2V0IHRoZSBwYWRkaW5nIChgW3RvcCwgcmlnaHQsIGJvdHRvbSwgbGVmdF1gKS5cbiAgICpcbiAgICogQHBhcmFtIHtBcnJheTxudW1iZXI+fG51bGx9IHBhZGRpbmcgUGFkZGluZy5cbiAgICogQGFwaVxuICAgKi9cbiAgc2V0UGFkZGluZyhwYWRkaW5nKSB7XG4gICAgdGhpcy5wYWRkaW5nXyA9IHBhZGRpbmc7XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgVGV4dDtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///21280\n")},83654:function(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__){eval("/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"M\": function() { return /* binding */ toStyle; }\n/* harmony export */ });\n/* harmony import */ var _style_Circle_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(30283);\n/* harmony import */ var _Fill_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(51345);\n/* harmony import */ var _Icon_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(81332);\n/* harmony import */ var _RegularShape_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(35393);\n/* harmony import */ var _Stroke_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(58958);\n/* harmony import */ var _Style_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(47539);\n/* harmony import */ var _Text_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(21280);\n/**\n * @module ol/style/flat\n */\n\n\n\n\n\n\n\n\n\n/**\n * For static styling, the [layer.setStyle()]{@link module:ol/layer/Vector~VectorLayer#setStyle} method\n * can be called with an object literal that has fill, stroke, text, icon, regular shape, and/or circle properties.\n * @api\n *\n * @typedef {FlatFill & FlatStroke & FlatText & FlatIcon & FlatShape & FlatCircle} FlatStyle\n */\n\n/**\n * A flat style literal or an array of the same.\n *\n * @typedef {FlatStyle|Array<FlatStyle>} FlatStyleLike\n */\n\n/**\n * Fill style properties applied to polygon features.\n *\n * @typedef {Object} FlatFill\n * @property {import(\"../color.js\").Color|import(\"../colorlike.js\").ColorLike} [fill-color] The fill color.\n */\n\n/**\n * Stroke style properties applied to line strings and polygon boundaries.  To apply a stroke, at least one of\n * `stroke-color` or `stroke-width` must be provided.\n *\n * @typedef {Object} FlatStroke\n * @property {import(\"../color.js\").Color|import(\"../colorlike.js\").ColorLike} [stroke-color] The stroke color.\n * @property {number} [stroke-width] Stroke pixel width.\n * @property {CanvasLineCap} [stroke-line-cap='round'] Line cap style: `butt`, `round`, or `square`.\n * @property {CanvasLineJoin} [stroke-line-join='round'] Line join style: `bevel`, `round`, or `miter`.\n * @property {Array<number>} [stroke-line-dash] Line dash pattern.\n * @property {number} [stroke-line-dash-offset=0] Line dash offset.\n * @property {number} [stroke-miter-limit=10] Miter limit.\n */\n\n/**\n * Label style properties applied to all features.  At a minimum, a `text-value` must be provided.\n *\n * @typedef {Object} FlatText\n * @property {string|Array<string>} [text-value] Text content or rich text content. For plain text provide a string, which can\n * contain line breaks (`\\n`). For rich text provide an array of text/font tuples. A tuple consists of the text to\n * render and the font to use (or `''` to use the text style's font). A line break has to be a separate tuple (i.e. `'\\n', ''`).\n * **Example:** `['foo', 'bold 10px sans-serif', ' bar', 'italic 10px sans-serif', ' baz', '']` will yield \"**foo** *bar* baz\".\n * **Note:** Rich text is not supported for the immediate rendering API.\n * @property {string} [text-font] Font style as CSS `font` value, see:\n * https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/font. Default is `'10px sans-serif'`\n * @property {number} [text-max-angle=Math.PI/4] When `text-placement` is set to `'line'`, allow a maximum angle between adjacent characters.\n * The expected value is in radians, and the default is 45° (`Math.PI / 4`).\n * @property {number} [text-offset-x=0] Horizontal text offset in pixels. A positive will shift the text right.\n * @property {number} [text-offset-y=0] Vertical text offset in pixels. A positive will shift the text down.\n * @property {boolean} [text-overflow=false] For polygon labels or when `placement` is set to `'line'`, allow text to exceed\n * the width of the polygon at the label position or the length of the path that it follows.\n * @property {import(\"./Text.js\").TextPlacement} [text-placement='point'] Text placement.\n * @property {number} [text-repeat] Repeat interval in pixels. When set, the text will be repeated at this interval. Only available when\n * `text-placement` is set to `'line'`. Overrides `text-align`.\n * @property {number|import(\"../size.js\").Size} [text-scale] Scale.\n * @property {boolean} [text-rotate-with-view=false] Whether to rotate the text with the view.\n * @property {number} [text-rotation=0] Rotation in radians (positive rotation clockwise).\n * @property {CanvasTextAlign} [text-align] Text alignment. Possible values: `'left'`, `'right'`, `'center'`, `'end'` or `'start'`.\n * Default is `'center'` for `text-placement: 'point'`. For `text-placement: 'line'`, the default is to let the renderer choose a\n * placement where `text-max-angle` is not exceeded.\n * @property {import('./Text.js').TextJustify} [text-justify] Text justification within the text box.\n * If not set, text is justified towards the `textAlign` anchor.\n * Otherwise, use options `'left'`, `'center'`, or `'right'` to justify the text within the text box.\n * **Note:** `text-justify` is ignored for immediate rendering and also for `text-placement: 'line'`.\n * @property {CanvasTextBaseline} [text-baseline='middle'] Text base line. Possible values: `'bottom'`, `'top'`, `'middle'`, `'alphabetic'`,\n * `'hanging'`, `'ideographic'`.\n * @property {Array<number>} [text-padding=[0, 0, 0, 0]] Padding in pixels around the text for decluttering and background. The order of\n * values in the array is `[top, right, bottom, left]`.\n * @property {import(\"../color.js\").Color|import(\"../colorlike.js\").ColorLike} [text-fill-color] The fill color.\n * @property {import(\"../color.js\").Color|import(\"../colorlike.js\").ColorLike} [text-background-fill-color] The fill color.\n * @property {import(\"../color.js\").Color|import(\"../colorlike.js\").ColorLike} [text-stroke-color] The stroke color.\n * @property {CanvasLineCap} [text-stroke-line-cap='round'] Line cap style: `butt`, `round`, or `square`.\n * @property {CanvasLineJoin} [text-stroke-line-join='round'] Line join style: `bevel`, `round`, or `miter`.\n * @property {Array<number>} [text-stroke-line-dash] Line dash pattern.\n * @property {number} [text-stroke-line-dash-offset=0] Line dash offset.\n * @property {number} [text-stroke-miter-limit=10] Miter limit.\n * @property {number} [text-stroke-width] Stroke pixel width.\n * @property {import(\"../color.js\").Color|import(\"../colorlike.js\").ColorLike} [text-background-stroke-color] The stroke color.\n * @property {CanvasLineCap} [text-background-stroke-line-cap='round'] Line cap style: `butt`, `round`, or `square`.\n * @property {CanvasLineJoin} [text-background-stroke-line-join='round'] Line join style: `bevel`, `round`, or `miter`.\n * @property {Array<number>} [text-background-stroke-line-dash] Line dash pattern.\n * @property {number} [text-background-stroke-line-dash-offset=0] Line dash offset.\n * @property {number} [text-background-stroke-miter-limit=10] Miter limit.\n * @property {number} [text-background-stroke-width] Stroke pixel width.\n */\n\n/**\n * Icon style properties applied to point features.  One of `icon-src` or `icon-img` must be provided to render\n * points with an icon.\n *\n * @typedef {Object} FlatIcon\n * @property {string} [icon-src] Image source URI.\n * @property {HTMLImageElement|HTMLCanvasElement} [icon-img] Image object for the icon. If the `icon-src` option is not provided then the\n * provided image must already be loaded. And in that case, it is required\n * to provide the size of the image, with the `icon-img-size` option.\n * @property {import(\"../size.js\").Size} [icon-img-size] Image size in pixels. Only required if `icon-img` is set and `icon-src` is not.\n * The provided size needs to match the actual size of the image.\n * @property {Array<number>} [icon-anchor=[0.5, 0.5]] Anchor. Default value is the icon center.\n * @property {import(\"./Icon.js\").IconOrigin} [icon-anchor-origin='top-left'] Origin of the anchor: `bottom-left`, `bottom-right`,\n * `top-left` or `top-right`.\n * @property {import(\"./Icon.js\").IconAnchorUnits} [icon-anchor-x-units='fraction'] Units in which the anchor x value is\n * specified. A value of `'fraction'` indicates the x value is a fraction of the icon. A value of `'pixels'` indicates\n * the x value in pixels.\n * @property {import(\"./Icon.js\").IconAnchorUnits} [icon-anchor-y-units='fraction'] Units in which the anchor y value is\n * specified. A value of `'fraction'` indicates the y value is a fraction of the icon. A value of `'pixels'` indicates\n * the y value in pixels.\n * @property {import(\"../color.js\").Color|string} [icon-color] Color to tint the icon. If not specified,\n * the icon will be left as is.\n * @property {null|string} [icon-cross-origin] The `crossOrigin` attribute for loaded images. Note that you must provide a\n * `icon-cross-origin` value if you want to access pixel data with the Canvas renderer.\n * See https://developer.mozilla.org/en-US/docs/Web/HTML/CORS_enabled_image for more detail.\n * @property {Array<number>} [icon-offset=[0, 0]] Offset, which, together with the size and the offset origin, define the\n * sub-rectangle to use from the original icon image.\n * @property {Array<number>} [icon-displacement=[0,0]] Displacement of the icon.\n * @property {import(\"./Icon.js\").IconOrigin} [icon-offset-origin='top-left'] Origin of the offset: `bottom-left`, `bottom-right`,\n * `top-left` or `top-right`.\n * @property {number} [icon-opacity=1] Opacity of the icon.\n * @property {number|import(\"../size.js\").Size} [icon-scale=1] Scale.\n * @property {number} [icon-rotation=0] Rotation in radians (positive rotation clockwise).\n * @property {boolean} [icon-rotate-with-view=false] Whether to rotate the icon with the view.\n * @property {import(\"../size.js\").Size} [icon-size] Icon size in pixel. Can be used together with `icon-offset` to define the\n * sub-rectangle to use from the origin (sprite) icon image.\n * @property {\"declutter\"|\"obstacle\"|\"none\"|undefined} [icon-declutter-mode] Declutter mode\n */\n\n/**\n * Regular shape style properties for rendering point features.  At least `shape-points` must be provided.\n *\n * @typedef {Object} FlatShape\n * @property {number} [shape-points] Number of points for stars and regular polygons. In case of a polygon, the number of points\n * is the number of sides.\n * @property {import(\"../color.js\").Color|import(\"../colorlike.js\").ColorLike} [shape-fill-color] The fill color.\n * @property {import(\"../color.js\").Color|import(\"../colorlike.js\").ColorLike} [shape-stroke-color] The stroke color.\n * @property {number} [shape-stroke-width] Stroke pixel width.\n * @property {CanvasLineCap} [shape-stroke-line-cap='round'] Line cap style: `butt`, `round`, or `square`.\n * @property {CanvasLineJoin} [shape-stroke-line-join='round'] Line join style: `bevel`, `round`, or `miter`.\n * @property {Array<number>} [shape-stroke-line-dash] Line dash pattern.\n * @property {number} [shape-stroke-line-dash-offset=0] Line dash offset.\n * @property {number} [shape-stroke-miter-limit=10] Miter limit.\n * @property {number} [shape-radius] Radius of a regular polygon.\n * @property {number} [shape-radius1] First radius of a star. Ignored if radius is set.\n * @property {number} [shape-radius2] Second radius of a star.\n * @property {number} [shape-angle=0] Shape's angle in radians. A value of 0 will have one of the shape's point facing up.\n * @property {Array<number>} [shape-displacement=[0,0]] Displacement of the shape\n * @property {number} [shape-rotation=0] Rotation in radians (positive rotation clockwise).\n * @property {boolean} [shape-rotate-with-view=false] Whether to rotate the shape with the view.\n * @property {number|import(\"../size.js\").Size} [shape-scale=1] Scale. Unless two dimensional scaling is required a better\n * result may be obtained with appropriate settings for `shape-radius`, `shape-radius1` and `shape-radius2`.\n * @property {\"declutter\"|\"obstacle\"|\"none\"|undefined} [shape-declutter-mode] Declutter mode.\n */\n\n/**\n * Circle style properties for rendering point features.  At least `circle-radius` must be provided.\n *\n * @typedef {Object} FlatCircle\n * @property {number} [circle-radius] Circle radius.\n * @property {import(\"../color.js\").Color|import(\"../colorlike.js\").ColorLike} [circle-fill-color] The fill color.\n * @property {import(\"../color.js\").Color|import(\"../colorlike.js\").ColorLike} [circle-stroke-color] The stroke color.\n * @property {number} [circle-stroke-width] Stroke pixel width.\n * @property {CanvasLineCap} [circle-stroke-line-cap='round'] Line cap style: `butt`, `round`, or `square`.\n * @property {CanvasLineJoin} [circle-stroke-line-join='round'] Line join style: `bevel`, `round`, or `miter`.\n * @property {Array<number>} [circle-stroke-line-dash] Line dash pattern.\n * @property {number} [circle-stroke-line-dash-offset=0] Line dash offset.\n * @property {number} [circle-stroke-miter-limit=10] Miter limit.\n * @property {Array<number>} [circle-displacement=[0,0]] displacement\n * @property {number|import(\"../size.js\").Size} [circle-scale=1] Scale. A two dimensional scale will produce an ellipse.\n * Unless two dimensional scaling is required a better result may be obtained with an appropriate setting for `circle-radius`.\n * @property {number} [circle-rotation=0] Rotation in radians\n * (positive rotation clockwise, meaningful only when used in conjunction with a two dimensional scale).\n * @property {boolean} [circle-rotate-with-view=false] Whether to rotate the shape with the view\n * (meaningful only when used in conjunction with a two dimensional scale).\n * @property {\"declutter\"|\"obstacle\"|\"none\"|undefined} [circle-declutter-mode] Declutter mode\n */\n\n/**\n * @param {FlatStyle} flatStyle A flat style literal.\n * @return {import(\"./Style.js\").default} A style instance.\n */\nfunction toStyle(flatStyle) {\n  const style = new _Style_js__WEBPACK_IMPORTED_MODULE_0__/* [\"default\"] */ .ZP({\n    fill: getFill(flatStyle, ''),\n    stroke: getStroke(flatStyle, ''),\n    text: getText(flatStyle),\n    image: getImage(flatStyle),\n  });\n\n  return style;\n}\n\n/**\n * @param {FlatStyle} flatStyle The flat style.\n * @param {string} prefix The property prefix.\n * @return {Fill|undefined} The fill (if any).\n */\nfunction getFill(flatStyle, prefix) {\n  const color = flatStyle[prefix + 'fill-color'];\n  if (!color) {\n    return;\n  }\n\n  return new _Fill_js__WEBPACK_IMPORTED_MODULE_1__/* [\"default\"] */ .Z({color: color});\n}\n\n/**\n * @param {FlatStyle} flatStyle The flat style.\n * @param {string} prefix The property prefix.\n * @return {Stroke|undefined} The stroke (if any).\n */\nfunction getStroke(flatStyle, prefix) {\n  const width = flatStyle[prefix + 'stroke-width'];\n  const color = flatStyle[prefix + 'stroke-color'];\n  if (!width && !color) {\n    return;\n  }\n\n  return new _Stroke_js__WEBPACK_IMPORTED_MODULE_2__/* [\"default\"] */ .Z({\n    width: width,\n    color: color,\n    lineCap: flatStyle[prefix + 'stroke-line-cap'],\n    lineJoin: flatStyle[prefix + 'stroke-line-join'],\n    lineDash: flatStyle[prefix + 'stroke-line-dash'],\n    lineDashOffset: flatStyle[prefix + 'stroke-line-dash-offset'],\n    miterLimit: flatStyle[prefix + 'stroke-miter-limit'],\n  });\n}\n\n/**\n * @param {FlatStyle} flatStyle The flat style.\n * @return {Text|undefined} The text (if any).\n */\nfunction getText(flatStyle) {\n  const value = flatStyle['text-value'];\n  if (!value) {\n    return;\n  }\n\n  const text = new _Text_js__WEBPACK_IMPORTED_MODULE_3__/* [\"default\"] */ .Z({\n    text: value,\n    font: flatStyle['text-font'],\n    maxAngle: flatStyle['text-max-angle'],\n    offsetX: flatStyle['text-offset-x'],\n    offsetY: flatStyle['text-offset-y'],\n    overflow: flatStyle['text-overflow'],\n    placement: flatStyle['text-placement'],\n    repeat: flatStyle['text-repeat'],\n    scale: flatStyle['text-scale'],\n    rotateWithView: flatStyle['text-rotate-with-view'],\n    rotation: flatStyle['text-rotation'],\n    textAlign: flatStyle['text-align'],\n    justify: flatStyle['text-justify'],\n    textBaseline: flatStyle['text-baseline'],\n    padding: flatStyle['text-padding'],\n    fill: getFill(flatStyle, 'text-'),\n    backgroundFill: getFill(flatStyle, 'text-background-'),\n    stroke: getStroke(flatStyle, 'text-'),\n    backgroundStroke: getStroke(flatStyle, 'text-background-'),\n  });\n\n  return text;\n}\n\n/**\n * @param {FlatStyle} flatStyle The flat style.\n * @return {import(\"./Image.js\").default|undefined} The image (if any).\n */\nfunction getImage(flatStyle) {\n  const iconSrc = flatStyle['icon-src'];\n  const iconImg = flatStyle['icon-img'];\n  if (iconSrc || iconImg) {\n    const icon = new _Icon_js__WEBPACK_IMPORTED_MODULE_4__/* [\"default\"] */ .Z({\n      src: iconSrc,\n      img: iconImg,\n      imgSize: flatStyle['icon-img-size'],\n      anchor: flatStyle['icon-anchor'],\n      anchorOrigin: flatStyle['icon-anchor-origin'],\n      anchorXUnits: flatStyle['icon-anchor-x-units'],\n      anchorYUnits: flatStyle['icon-anchor-y-units'],\n      color: flatStyle['icon-color'],\n      crossOrigin: flatStyle['icon-cross-origin'],\n      offset: flatStyle['icon-offset'],\n      displacement: flatStyle['icon-displacement'],\n      opacity: flatStyle['icon-opacity'],\n      scale: flatStyle['icon-scale'],\n      rotation: flatStyle['icon-rotation'],\n      rotateWithView: flatStyle['icon-rotate-with-view'],\n      size: flatStyle['icon-size'],\n      declutterMode: flatStyle['icon-declutter-mode'],\n    });\n    return icon;\n  }\n\n  const shapePoints = flatStyle['shape-points'];\n  if (shapePoints) {\n    const prefix = 'shape-';\n    const shape = new _RegularShape_js__WEBPACK_IMPORTED_MODULE_5__/* [\"default\"] */ .Z({\n      points: shapePoints,\n      fill: getFill(flatStyle, prefix),\n      stroke: getStroke(flatStyle, prefix),\n      radius: flatStyle['shape-radius'],\n      radius1: flatStyle['shape-radius1'],\n      radius2: flatStyle['shape-radius2'],\n      angle: flatStyle['shape-angle'],\n      displacement: flatStyle['shape-displacement'],\n      rotation: flatStyle['shape-rotation'],\n      rotateWithView: flatStyle['shape-rotate-with-view'],\n      scale: flatStyle['shape-scale'],\n      declutterMode: flatStyle['shape-declutter-mode'],\n    });\n\n    return shape;\n  }\n\n  const circleRadius = flatStyle['circle-radius'];\n  if (circleRadius) {\n    const prefix = 'circle-';\n    const circle = new _style_Circle_js__WEBPACK_IMPORTED_MODULE_6__/* [\"default\"] */ .Z({\n      radius: circleRadius,\n      fill: getFill(flatStyle, prefix),\n      stroke: getStroke(flatStyle, prefix),\n      displacement: flatStyle['circle-displacement'],\n      scale: flatStyle['circle-scale'],\n      rotation: flatStyle['circle-rotation'],\n      rotateWithView: flatStyle['circle-rotate-with-view'],\n      declutterMode: flatStyle['circle-declutter-mode'],\n    });\n\n    return circle;\n  }\n\n  return;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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O0FBRUE7QUFDQSxXQUFXLFdBQVc7QUFDdEIsWUFBWSx3Q0FBd0M7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQix5REFBSTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLGlFQUFZO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsaUVBQU07QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTs7QUFFQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdnVlMy13ZWJwYWNrNS8uL25vZGVfbW9kdWxlcy9vbC9zdHlsZS9mbGF0LmpzPzY1ZDQiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAbW9kdWxlIG9sL3N0eWxlL2ZsYXRcbiAqL1xuXG5pbXBvcnQgQ2lyY2xlIGZyb20gJy4uL3N0eWxlL0NpcmNsZS5qcyc7XG5pbXBvcnQgRmlsbCBmcm9tICcuL0ZpbGwuanMnO1xuaW1wb3J0IEljb24gZnJvbSAnLi9JY29uLmpzJztcbmltcG9ydCBSZWd1bGFyU2hhcGUgZnJvbSAnLi9SZWd1bGFyU2hhcGUuanMnO1xuaW1wb3J0IFN0cm9rZSBmcm9tICcuL1N0cm9rZS5qcyc7XG5pbXBvcnQgU3R5bGUgZnJvbSAnLi9TdHlsZS5qcyc7XG5pbXBvcnQgVGV4dCBmcm9tICcuL1RleHQuanMnO1xuXG4vKipcbiAqIEZvciBzdGF0aWMgc3R5bGluZywgdGhlIFtsYXllci5zZXRTdHlsZSgpXXtAbGluayBtb2R1bGU6b2wvbGF5ZXIvVmVjdG9yflZlY3RvckxheWVyI3NldFN0eWxlfSBtZXRob2RcbiAqIGNhbiBiZSBjYWxsZWQgd2l0aCBhbiBvYmplY3QgbGl0ZXJhbCB0aGF0IGhhcyBmaWxsLCBzdHJva2UsIHRleHQsIGljb24sIHJlZ3VsYXIgc2hhcGUsIGFuZC9vciBjaXJjbGUgcHJvcGVydGllcy5cbiAqIEBhcGlcbiAqXG4gKiBAdHlwZWRlZiB7RmxhdEZpbGwgJiBGbGF0U3Ryb2tlICYgRmxhdFRleHQgJiBGbGF0SWNvbiAmIEZsYXRTaGFwZSAmIEZsYXRDaXJjbGV9IEZsYXRTdHlsZVxuICovXG5cbi8qKlxuICogQSBmbGF0IHN0eWxlIGxpdGVyYWwgb3IgYW4gYXJyYXkgb2YgdGhlIHNhbWUuXG4gKlxuICogQHR5cGVkZWYge0ZsYXRTdHlsZXxBcnJheTxGbGF0U3R5bGU+fSBGbGF0U3R5bGVMaWtlXG4gKi9cblxuLyoqXG4gKiBGaWxsIHN0eWxlIHByb3BlcnRpZXMgYXBwbGllZCB0byBwb2x5Z29uIGZlYXR1cmVzLlxuICpcbiAqIEB0eXBlZGVmIHtPYmplY3R9IEZsYXRGaWxsXG4gKiBAcHJvcGVydHkge2ltcG9ydChcIi4uL2NvbG9yLmpzXCIpLkNvbG9yfGltcG9ydChcIi4uL2NvbG9ybGlrZS5qc1wiKS5Db2xvckxpa2V9IFtmaWxsLWNvbG9yXSBUaGUgZmlsbCBjb2xvci5cbiAqL1xuXG4vKipcbiAqIFN0cm9rZSBzdHlsZSBwcm9wZXJ0aWVzIGFwcGxpZWQgdG8gbGluZSBzdHJpbmdzIGFuZCBwb2x5Z29uIGJvdW5kYXJpZXMuICBUbyBhcHBseSBhIHN0cm9rZSwgYXQgbGVhc3Qgb25lIG9mXG4gKiBgc3Ryb2tlLWNvbG9yYCBvciBgc3Ryb2tlLXdpZHRoYCBtdXN0IGJlIHByb3ZpZGVkLlxuICpcbiAqIEB0eXBlZGVmIHtPYmplY3R9IEZsYXRTdHJva2VcbiAqIEBwcm9wZXJ0eSB7aW1wb3J0KFwiLi4vY29sb3IuanNcIikuQ29sb3J8aW1wb3J0KFwiLi4vY29sb3JsaWtlLmpzXCIpLkNvbG9yTGlrZX0gW3N0cm9rZS1jb2xvcl0gVGhlIHN0cm9rZSBjb2xvci5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbc3Ryb2tlLXdpZHRoXSBTdHJva2UgcGl4ZWwgd2lkdGguXG4gKiBAcHJvcGVydHkge0NhbnZhc0xpbmVDYXB9IFtzdHJva2UtbGluZS1jYXA9J3JvdW5kJ10gTGluZSBjYXAgc3R5bGU6IGBidXR0YCwgYHJvdW5kYCwgb3IgYHNxdWFyZWAuXG4gKiBAcHJvcGVydHkge0NhbnZhc0xpbmVKb2lufSBbc3Ryb2tlLWxpbmUtam9pbj0ncm91bmQnXSBMaW5lIGpvaW4gc3R5bGU6IGBiZXZlbGAsIGByb3VuZGAsIG9yIGBtaXRlcmAuXG4gKiBAcHJvcGVydHkge0FycmF5PG51bWJlcj59IFtzdHJva2UtbGluZS1kYXNoXSBMaW5lIGRhc2ggcGF0dGVybi5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbc3Ryb2tlLWxpbmUtZGFzaC1vZmZzZXQ9MF0gTGluZSBkYXNoIG9mZnNldC5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbc3Ryb2tlLW1pdGVyLWxpbWl0PTEwXSBNaXRlciBsaW1pdC5cbiAqL1xuXG4vKipcbiAqIExhYmVsIHN0eWxlIHByb3BlcnRpZXMgYXBwbGllZCB0byBhbGwgZmVhdHVyZXMuICBBdCBhIG1pbmltdW0sIGEgYHRleHQtdmFsdWVgIG11c3QgYmUgcHJvdmlkZWQuXG4gKlxuICogQHR5cGVkZWYge09iamVjdH0gRmxhdFRleHRcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfEFycmF5PHN0cmluZz59IFt0ZXh0LXZhbHVlXSBUZXh0IGNvbnRlbnQgb3IgcmljaCB0ZXh0IGNvbnRlbnQuIEZvciBwbGFpbiB0ZXh0IHByb3ZpZGUgYSBzdHJpbmcsIHdoaWNoIGNhblxuICogY29udGFpbiBsaW5lIGJyZWFrcyAoYFxcbmApLiBGb3IgcmljaCB0ZXh0IHByb3ZpZGUgYW4gYXJyYXkgb2YgdGV4dC9mb250IHR1cGxlcy4gQSB0dXBsZSBjb25zaXN0cyBvZiB0aGUgdGV4dCB0b1xuICogcmVuZGVyIGFuZCB0aGUgZm9udCB0byB1c2UgKG9yIGAnJ2AgdG8gdXNlIHRoZSB0ZXh0IHN0eWxlJ3MgZm9udCkuIEEgbGluZSBicmVhayBoYXMgdG8gYmUgYSBzZXBhcmF0ZSB0dXBsZSAoaS5lLiBgJ1xcbicsICcnYCkuXG4gKiAqKkV4YW1wbGU6KiogYFsnZm9vJywgJ2JvbGQgMTBweCBzYW5zLXNlcmlmJywgJyBiYXInLCAnaXRhbGljIDEwcHggc2Fucy1zZXJpZicsICcgYmF6JywgJyddYCB3aWxsIHlpZWxkIFwiKipmb28qKiAqYmFyKiBiYXpcIi5cbiAqICoqTm90ZToqKiBSaWNoIHRleHQgaXMgbm90IHN1cHBvcnRlZCBmb3IgdGhlIGltbWVkaWF0ZSByZW5kZXJpbmcgQVBJLlxuICogQHByb3BlcnR5IHtzdHJpbmd9IFt0ZXh0LWZvbnRdIEZvbnQgc3R5bGUgYXMgQ1NTIGBmb250YCB2YWx1ZSwgc2VlOlxuICogaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRC9mb250LiBEZWZhdWx0IGlzIGAnMTBweCBzYW5zLXNlcmlmJ2BcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbdGV4dC1tYXgtYW5nbGU9TWF0aC5QSS80XSBXaGVuIGB0ZXh0LXBsYWNlbWVudGAgaXMgc2V0IHRvIGAnbGluZSdgLCBhbGxvdyBhIG1heGltdW0gYW5nbGUgYmV0d2VlbiBhZGphY2VudCBjaGFyYWN0ZXJzLlxuICogVGhlIGV4cGVjdGVkIHZhbHVlIGlzIGluIHJhZGlhbnMsIGFuZCB0aGUgZGVmYXVsdCBpcyA0NcKwIChgTWF0aC5QSSAvIDRgKS5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbdGV4dC1vZmZzZXQteD0wXSBIb3Jpem9udGFsIHRleHQgb2Zmc2V0IGluIHBpeGVscy4gQSBwb3NpdGl2ZSB3aWxsIHNoaWZ0IHRoZSB0ZXh0IHJpZ2h0LlxuICogQHByb3BlcnR5IHtudW1iZXJ9IFt0ZXh0LW9mZnNldC15PTBdIFZlcnRpY2FsIHRleHQgb2Zmc2V0IGluIHBpeGVscy4gQSBwb3NpdGl2ZSB3aWxsIHNoaWZ0IHRoZSB0ZXh0IGRvd24uXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IFt0ZXh0LW92ZXJmbG93PWZhbHNlXSBGb3IgcG9seWdvbiBsYWJlbHMgb3Igd2hlbiBgcGxhY2VtZW50YCBpcyBzZXQgdG8gYCdsaW5lJ2AsIGFsbG93IHRleHQgdG8gZXhjZWVkXG4gKiB0aGUgd2lkdGggb2YgdGhlIHBvbHlnb24gYXQgdGhlIGxhYmVsIHBvc2l0aW9uIG9yIHRoZSBsZW5ndGggb2YgdGhlIHBhdGggdGhhdCBpdCBmb2xsb3dzLlxuICogQHByb3BlcnR5IHtpbXBvcnQoXCIuL1RleHQuanNcIikuVGV4dFBsYWNlbWVudH0gW3RleHQtcGxhY2VtZW50PSdwb2ludCddIFRleHQgcGxhY2VtZW50LlxuICogQHByb3BlcnR5IHtudW1iZXJ9IFt0ZXh0LXJlcGVhdF0gUmVwZWF0IGludGVydmFsIGluIHBpeGVscy4gV2hlbiBzZXQsIHRoZSB0ZXh0IHdpbGwgYmUgcmVwZWF0ZWQgYXQgdGhpcyBpbnRlcnZhbC4gT25seSBhdmFpbGFibGUgd2hlblxuICogYHRleHQtcGxhY2VtZW50YCBpcyBzZXQgdG8gYCdsaW5lJ2AuIE92ZXJyaWRlcyBgdGV4dC1hbGlnbmAuXG4gKiBAcHJvcGVydHkge251bWJlcnxpbXBvcnQoXCIuLi9zaXplLmpzXCIpLlNpemV9IFt0ZXh0LXNjYWxlXSBTY2FsZS5cbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW3RleHQtcm90YXRlLXdpdGgtdmlldz1mYWxzZV0gV2hldGhlciB0byByb3RhdGUgdGhlIHRleHQgd2l0aCB0aGUgdmlldy5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbdGV4dC1yb3RhdGlvbj0wXSBSb3RhdGlvbiBpbiByYWRpYW5zIChwb3NpdGl2ZSByb3RhdGlvbiBjbG9ja3dpc2UpLlxuICogQHByb3BlcnR5IHtDYW52YXNUZXh0QWxpZ259IFt0ZXh0LWFsaWduXSBUZXh0IGFsaWdubWVudC4gUG9zc2libGUgdmFsdWVzOiBgJ2xlZnQnYCwgYCdyaWdodCdgLCBgJ2NlbnRlcidgLCBgJ2VuZCdgIG9yIGAnc3RhcnQnYC5cbiAqIERlZmF1bHQgaXMgYCdjZW50ZXInYCBmb3IgYHRleHQtcGxhY2VtZW50OiAncG9pbnQnYC4gRm9yIGB0ZXh0LXBsYWNlbWVudDogJ2xpbmUnYCwgdGhlIGRlZmF1bHQgaXMgdG8gbGV0IHRoZSByZW5kZXJlciBjaG9vc2UgYVxuICogcGxhY2VtZW50IHdoZXJlIGB0ZXh0LW1heC1hbmdsZWAgaXMgbm90IGV4Y2VlZGVkLlxuICogQHByb3BlcnR5IHtpbXBvcnQoJy4vVGV4dC5qcycpLlRleHRKdXN0aWZ5fSBbdGV4dC1qdXN0aWZ5XSBUZXh0IGp1c3RpZmljYXRpb24gd2l0aGluIHRoZSB0ZXh0IGJveC5cbiAqIElmIG5vdCBzZXQsIHRleHQgaXMganVzdGlmaWVkIHRvd2FyZHMgdGhlIGB0ZXh0QWxpZ25gIGFuY2hvci5cbiAqIE90aGVyd2lzZSwgdXNlIG9wdGlvbnMgYCdsZWZ0J2AsIGAnY2VudGVyJ2AsIG9yIGAncmlnaHQnYCB0byBqdXN0aWZ5IHRoZSB0ZXh0IHdpdGhpbiB0aGUgdGV4dCBib3guXG4gKiAqKk5vdGU6KiogYHRleHQtanVzdGlmeWAgaXMgaWdub3JlZCBmb3IgaW1tZWRpYXRlIHJlbmRlcmluZyBhbmQgYWxzbyBmb3IgYHRleHQtcGxhY2VtZW50OiAnbGluZSdgLlxuICogQHByb3BlcnR5IHtDYW52YXNUZXh0QmFzZWxpbmV9IFt0ZXh0LWJhc2VsaW5lPSdtaWRkbGUnXSBUZXh0IGJhc2UgbGluZS4gUG9zc2libGUgdmFsdWVzOiBgJ2JvdHRvbSdgLCBgJ3RvcCdgLCBgJ21pZGRsZSdgLCBgJ2FscGhhYmV0aWMnYCxcbiAqIGAnaGFuZ2luZydgLCBgJ2lkZW9ncmFwaGljJ2AuXG4gKiBAcHJvcGVydHkge0FycmF5PG51bWJlcj59IFt0ZXh0LXBhZGRpbmc9WzAsIDAsIDAsIDBdXSBQYWRkaW5nIGluIHBpeGVscyBhcm91bmQgdGhlIHRleHQgZm9yIGRlY2x1dHRlcmluZyBhbmQgYmFja2dyb3VuZC4gVGhlIG9yZGVyIG9mXG4gKiB2YWx1ZXMgaW4gdGhlIGFycmF5IGlzIGBbdG9wLCByaWdodCwgYm90dG9tLCBsZWZ0XWAuXG4gKiBAcHJvcGVydHkge2ltcG9ydChcIi4uL2NvbG9yLmpzXCIpLkNvbG9yfGltcG9ydChcIi4uL2NvbG9ybGlrZS5qc1wiKS5Db2xvckxpa2V9IFt0ZXh0LWZpbGwtY29sb3JdIFRoZSBmaWxsIGNvbG9yLlxuICogQHByb3BlcnR5IHtpbXBvcnQoXCIuLi9jb2xvci5qc1wiKS5Db2xvcnxpbXBvcnQoXCIuLi9jb2xvcmxpa2UuanNcIikuQ29sb3JMaWtlfSBbdGV4dC1iYWNrZ3JvdW5kLWZpbGwtY29sb3JdIFRoZSBmaWxsIGNvbG9yLlxuICogQHByb3BlcnR5IHtpbXBvcnQoXCIuLi9jb2xvci5qc1wiKS5Db2xvcnxpbXBvcnQoXCIuLi9jb2xvcmxpa2UuanNcIikuQ29sb3JMaWtlfSBbdGV4dC1zdHJva2UtY29sb3JdIFRoZSBzdHJva2UgY29sb3IuXG4gKiBAcHJvcGVydHkge0NhbnZhc0xpbmVDYXB9IFt0ZXh0LXN0cm9rZS1saW5lLWNhcD0ncm91bmQnXSBMaW5lIGNhcCBzdHlsZTogYGJ1dHRgLCBgcm91bmRgLCBvciBgc3F1YXJlYC5cbiAqIEBwcm9wZXJ0eSB7Q2FudmFzTGluZUpvaW59IFt0ZXh0LXN0cm9rZS1saW5lLWpvaW49J3JvdW5kJ10gTGluZSBqb2luIHN0eWxlOiBgYmV2ZWxgLCBgcm91bmRgLCBvciBgbWl0ZXJgLlxuICogQHByb3BlcnR5IHtBcnJheTxudW1iZXI+fSBbdGV4dC1zdHJva2UtbGluZS1kYXNoXSBMaW5lIGRhc2ggcGF0dGVybi5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbdGV4dC1zdHJva2UtbGluZS1kYXNoLW9mZnNldD0wXSBMaW5lIGRhc2ggb2Zmc2V0LlxuICogQHByb3BlcnR5IHtudW1iZXJ9IFt0ZXh0LXN0cm9rZS1taXRlci1saW1pdD0xMF0gTWl0ZXIgbGltaXQuXG4gKiBAcHJvcGVydHkge251bWJlcn0gW3RleHQtc3Ryb2tlLXdpZHRoXSBTdHJva2UgcGl4ZWwgd2lkdGguXG4gKiBAcHJvcGVydHkge2ltcG9ydChcIi4uL2NvbG9yLmpzXCIpLkNvbG9yfGltcG9ydChcIi4uL2NvbG9ybGlrZS5qc1wiKS5Db2xvckxpa2V9IFt0ZXh0LWJhY2tncm91bmQtc3Ryb2tlLWNvbG9yXSBUaGUgc3Ryb2tlIGNvbG9yLlxuICogQHByb3BlcnR5IHtDYW52YXNMaW5lQ2FwfSBbdGV4dC1iYWNrZ3JvdW5kLXN0cm9rZS1saW5lLWNhcD0ncm91bmQnXSBMaW5lIGNhcCBzdHlsZTogYGJ1dHRgLCBgcm91bmRgLCBvciBgc3F1YXJlYC5cbiAqIEBwcm9wZXJ0eSB7Q2FudmFzTGluZUpvaW59IFt0ZXh0LWJhY2tncm91bmQtc3Ryb2tlLWxpbmUtam9pbj0ncm91bmQnXSBMaW5lIGpvaW4gc3R5bGU6IGBiZXZlbGAsIGByb3VuZGAsIG9yIGBtaXRlcmAuXG4gKiBAcHJvcGVydHkge0FycmF5PG51bWJlcj59IFt0ZXh0LWJhY2tncm91bmQtc3Ryb2tlLWxpbmUtZGFzaF0gTGluZSBkYXNoIHBhdHRlcm4uXG4gKiBAcHJvcGVydHkge251bWJlcn0gW3RleHQtYmFja2dyb3VuZC1zdHJva2UtbGluZS1kYXNoLW9mZnNldD0wXSBMaW5lIGRhc2ggb2Zmc2V0LlxuICogQHByb3BlcnR5IHtudW1iZXJ9IFt0ZXh0LWJhY2tncm91bmQtc3Ryb2tlLW1pdGVyLWxpbWl0PTEwXSBNaXRlciBsaW1pdC5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbdGV4dC1iYWNrZ3JvdW5kLXN0cm9rZS13aWR0aF0gU3Ryb2tlIHBpeGVsIHdpZHRoLlxuICovXG5cbi8qKlxuICogSWNvbiBzdHlsZSBwcm9wZXJ0aWVzIGFwcGxpZWQgdG8gcG9pbnQgZmVhdHVyZXMuICBPbmUgb2YgYGljb24tc3JjYCBvciBgaWNvbi1pbWdgIG11c3QgYmUgcHJvdmlkZWQgdG8gcmVuZGVyXG4gKiBwb2ludHMgd2l0aCBhbiBpY29uLlxuICpcbiAqIEB0eXBlZGVmIHtPYmplY3R9IEZsYXRJY29uXG4gKiBAcHJvcGVydHkge3N0cmluZ30gW2ljb24tc3JjXSBJbWFnZSBzb3VyY2UgVVJJLlxuICogQHByb3BlcnR5IHtIVE1MSW1hZ2VFbGVtZW50fEhUTUxDYW52YXNFbGVtZW50fSBbaWNvbi1pbWddIEltYWdlIG9iamVjdCBmb3IgdGhlIGljb24uIElmIHRoZSBgaWNvbi1zcmNgIG9wdGlvbiBpcyBub3QgcHJvdmlkZWQgdGhlbiB0aGVcbiAqIHByb3ZpZGVkIGltYWdlIG11c3QgYWxyZWFkeSBiZSBsb2FkZWQuIEFuZCBpbiB0aGF0IGNhc2UsIGl0IGlzIHJlcXVpcmVkXG4gKiB0byBwcm92aWRlIHRoZSBzaXplIG9mIHRoZSBpbWFnZSwgd2l0aCB0aGUgYGljb24taW1nLXNpemVgIG9wdGlvbi5cbiAqIEBwcm9wZXJ0eSB7aW1wb3J0KFwiLi4vc2l6ZS5qc1wiKS5TaXplfSBbaWNvbi1pbWctc2l6ZV0gSW1hZ2Ugc2l6ZSBpbiBwaXhlbHMuIE9ubHkgcmVxdWlyZWQgaWYgYGljb24taW1nYCBpcyBzZXQgYW5kIGBpY29uLXNyY2AgaXMgbm90LlxuICogVGhlIHByb3ZpZGVkIHNpemUgbmVlZHMgdG8gbWF0Y2ggdGhlIGFjdHVhbCBzaXplIG9mIHRoZSBpbWFnZS5cbiAqIEBwcm9wZXJ0eSB7QXJyYXk8bnVtYmVyPn0gW2ljb24tYW5jaG9yPVswLjUsIDAuNV1dIEFuY2hvci4gRGVmYXVsdCB2YWx1ZSBpcyB0aGUgaWNvbiBjZW50ZXIuXG4gKiBAcHJvcGVydHkge2ltcG9ydChcIi4vSWNvbi5qc1wiKS5JY29uT3JpZ2lufSBbaWNvbi1hbmNob3Itb3JpZ2luPSd0b3AtbGVmdCddIE9yaWdpbiBvZiB0aGUgYW5jaG9yOiBgYm90dG9tLWxlZnRgLCBgYm90dG9tLXJpZ2h0YCxcbiAqIGB0b3AtbGVmdGAgb3IgYHRvcC1yaWdodGAuXG4gKiBAcHJvcGVydHkge2ltcG9ydChcIi4vSWNvbi5qc1wiKS5JY29uQW5jaG9yVW5pdHN9IFtpY29uLWFuY2hvci14LXVuaXRzPSdmcmFjdGlvbiddIFVuaXRzIGluIHdoaWNoIHRoZSBhbmNob3IgeCB2YWx1ZSBpc1xuICogc3BlY2lmaWVkLiBBIHZhbHVlIG9mIGAnZnJhY3Rpb24nYCBpbmRpY2F0ZXMgdGhlIHggdmFsdWUgaXMgYSBmcmFjdGlvbiBvZiB0aGUgaWNvbi4gQSB2YWx1ZSBvZiBgJ3BpeGVscydgIGluZGljYXRlc1xuICogdGhlIHggdmFsdWUgaW4gcGl4ZWxzLlxuICogQHByb3BlcnR5IHtpbXBvcnQoXCIuL0ljb24uanNcIikuSWNvbkFuY2hvclVuaXRzfSBbaWNvbi1hbmNob3IteS11bml0cz0nZnJhY3Rpb24nXSBVbml0cyBpbiB3aGljaCB0aGUgYW5jaG9yIHkgdmFsdWUgaXNcbiAqIHNwZWNpZmllZC4gQSB2YWx1ZSBvZiBgJ2ZyYWN0aW9uJ2AgaW5kaWNhdGVzIHRoZSB5IHZhbHVlIGlzIGEgZnJhY3Rpb24gb2YgdGhlIGljb24uIEEgdmFsdWUgb2YgYCdwaXhlbHMnYCBpbmRpY2F0ZXNcbiAqIHRoZSB5IHZhbHVlIGluIHBpeGVscy5cbiAqIEBwcm9wZXJ0eSB7aW1wb3J0KFwiLi4vY29sb3IuanNcIikuQ29sb3J8c3RyaW5nfSBbaWNvbi1jb2xvcl0gQ29sb3IgdG8gdGludCB0aGUgaWNvbi4gSWYgbm90IHNwZWNpZmllZCxcbiAqIHRoZSBpY29uIHdpbGwgYmUgbGVmdCBhcyBpcy5cbiAqIEBwcm9wZXJ0eSB7bnVsbHxzdHJpbmd9IFtpY29uLWNyb3NzLW9yaWdpbl0gVGhlIGBjcm9zc09yaWdpbmAgYXR0cmlidXRlIGZvciBsb2FkZWQgaW1hZ2VzLiBOb3RlIHRoYXQgeW91IG11c3QgcHJvdmlkZSBhXG4gKiBgaWNvbi1jcm9zcy1vcmlnaW5gIHZhbHVlIGlmIHlvdSB3YW50IHRvIGFjY2VzcyBwaXhlbCBkYXRhIHdpdGggdGhlIENhbnZhcyByZW5kZXJlci5cbiAqIFNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9IVE1ML0NPUlNfZW5hYmxlZF9pbWFnZSBmb3IgbW9yZSBkZXRhaWwuXG4gKiBAcHJvcGVydHkge0FycmF5PG51bWJlcj59IFtpY29uLW9mZnNldD1bMCwgMF1dIE9mZnNldCwgd2hpY2gsIHRvZ2V0aGVyIHdpdGggdGhlIHNpemUgYW5kIHRoZSBvZmZzZXQgb3JpZ2luLCBkZWZpbmUgdGhlXG4gKiBzdWItcmVjdGFuZ2xlIHRvIHVzZSBmcm9tIHRoZSBvcmlnaW5hbCBpY29uIGltYWdlLlxuICogQHByb3BlcnR5IHtBcnJheTxudW1iZXI+fSBbaWNvbi1kaXNwbGFjZW1lbnQ9WzAsMF1dIERpc3BsYWNlbWVudCBvZiB0aGUgaWNvbi5cbiAqIEBwcm9wZXJ0eSB7aW1wb3J0KFwiLi9JY29uLmpzXCIpLkljb25PcmlnaW59IFtpY29uLW9mZnNldC1vcmlnaW49J3RvcC1sZWZ0J10gT3JpZ2luIG9mIHRoZSBvZmZzZXQ6IGBib3R0b20tbGVmdGAsIGBib3R0b20tcmlnaHRgLFxuICogYHRvcC1sZWZ0YCBvciBgdG9wLXJpZ2h0YC5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbaWNvbi1vcGFjaXR5PTFdIE9wYWNpdHkgb2YgdGhlIGljb24uXG4gKiBAcHJvcGVydHkge251bWJlcnxpbXBvcnQoXCIuLi9zaXplLmpzXCIpLlNpemV9IFtpY29uLXNjYWxlPTFdIFNjYWxlLlxuICogQHByb3BlcnR5IHtudW1iZXJ9IFtpY29uLXJvdGF0aW9uPTBdIFJvdGF0aW9uIGluIHJhZGlhbnMgKHBvc2l0aXZlIHJvdGF0aW9uIGNsb2Nrd2lzZSkuXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IFtpY29uLXJvdGF0ZS13aXRoLXZpZXc9ZmFsc2VdIFdoZXRoZXIgdG8gcm90YXRlIHRoZSBpY29uIHdpdGggdGhlIHZpZXcuXG4gKiBAcHJvcGVydHkge2ltcG9ydChcIi4uL3NpemUuanNcIikuU2l6ZX0gW2ljb24tc2l6ZV0gSWNvbiBzaXplIGluIHBpeGVsLiBDYW4gYmUgdXNlZCB0b2dldGhlciB3aXRoIGBpY29uLW9mZnNldGAgdG8gZGVmaW5lIHRoZVxuICogc3ViLXJlY3RhbmdsZSB0byB1c2UgZnJvbSB0aGUgb3JpZ2luIChzcHJpdGUpIGljb24gaW1hZ2UuXG4gKiBAcHJvcGVydHkge1wiZGVjbHV0dGVyXCJ8XCJvYnN0YWNsZVwifFwibm9uZVwifHVuZGVmaW5lZH0gW2ljb24tZGVjbHV0dGVyLW1vZGVdIERlY2x1dHRlciBtb2RlXG4gKi9cblxuLyoqXG4gKiBSZWd1bGFyIHNoYXBlIHN0eWxlIHByb3BlcnRpZXMgZm9yIHJlbmRlcmluZyBwb2ludCBmZWF0dXJlcy4gIEF0IGxlYXN0IGBzaGFwZS1wb2ludHNgIG11c3QgYmUgcHJvdmlkZWQuXG4gKlxuICogQHR5cGVkZWYge09iamVjdH0gRmxhdFNoYXBlXG4gKiBAcHJvcGVydHkge251bWJlcn0gW3NoYXBlLXBvaW50c10gTnVtYmVyIG9mIHBvaW50cyBmb3Igc3RhcnMgYW5kIHJlZ3VsYXIgcG9seWdvbnMuIEluIGNhc2Ugb2YgYSBwb2x5Z29uLCB0aGUgbnVtYmVyIG9mIHBvaW50c1xuICogaXMgdGhlIG51bWJlciBvZiBzaWRlcy5cbiAqIEBwcm9wZXJ0eSB7aW1wb3J0KFwiLi4vY29sb3IuanNcIikuQ29sb3J8aW1wb3J0KFwiLi4vY29sb3JsaWtlLmpzXCIpLkNvbG9yTGlrZX0gW3NoYXBlLWZpbGwtY29sb3JdIFRoZSBmaWxsIGNvbG9yLlxuICogQHByb3BlcnR5IHtpbXBvcnQoXCIuLi9jb2xvci5qc1wiKS5Db2xvcnxpbXBvcnQoXCIuLi9jb2xvcmxpa2UuanNcIikuQ29sb3JMaWtlfSBbc2hhcGUtc3Ryb2tlLWNvbG9yXSBUaGUgc3Ryb2tlIGNvbG9yLlxuICogQHByb3BlcnR5IHtudW1iZXJ9IFtzaGFwZS1zdHJva2Utd2lkdGhdIFN0cm9rZSBwaXhlbCB3aWR0aC5cbiAqIEBwcm9wZXJ0eSB7Q2FudmFzTGluZUNhcH0gW3NoYXBlLXN0cm9rZS1saW5lLWNhcD0ncm91bmQnXSBMaW5lIGNhcCBzdHlsZTogYGJ1dHRgLCBgcm91bmRgLCBvciBgc3F1YXJlYC5cbiAqIEBwcm9wZXJ0eSB7Q2FudmFzTGluZUpvaW59IFtzaGFwZS1zdHJva2UtbGluZS1qb2luPSdyb3VuZCddIExpbmUgam9pbiBzdHlsZTogYGJldmVsYCwgYHJvdW5kYCwgb3IgYG1pdGVyYC5cbiAqIEBwcm9wZXJ0eSB7QXJyYXk8bnVtYmVyPn0gW3NoYXBlLXN0cm9rZS1saW5lLWRhc2hdIExpbmUgZGFzaCBwYXR0ZXJuLlxuICogQHByb3BlcnR5IHtudW1iZXJ9IFtzaGFwZS1zdHJva2UtbGluZS1kYXNoLW9mZnNldD0wXSBMaW5lIGRhc2ggb2Zmc2V0LlxuICogQHByb3BlcnR5IHtudW1iZXJ9IFtzaGFwZS1zdHJva2UtbWl0ZXItbGltaXQ9MTBdIE1pdGVyIGxpbWl0LlxuICogQHByb3BlcnR5IHtudW1iZXJ9IFtzaGFwZS1yYWRpdXNdIFJhZGl1cyBvZiBhIHJlZ3VsYXIgcG9seWdvbi5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbc2hhcGUtcmFkaXVzMV0gRmlyc3QgcmFkaXVzIG9mIGEgc3Rhci4gSWdub3JlZCBpZiByYWRpdXMgaXMgc2V0LlxuICogQHByb3BlcnR5IHtudW1iZXJ9IFtzaGFwZS1yYWRpdXMyXSBTZWNvbmQgcmFkaXVzIG9mIGEgc3Rhci5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbc2hhcGUtYW5nbGU9MF0gU2hhcGUncyBhbmdsZSBpbiByYWRpYW5zLiBBIHZhbHVlIG9mIDAgd2lsbCBoYXZlIG9uZSBvZiB0aGUgc2hhcGUncyBwb2ludCBmYWNpbmcgdXAuXG4gKiBAcHJvcGVydHkge0FycmF5PG51bWJlcj59IFtzaGFwZS1kaXNwbGFjZW1lbnQ9WzAsMF1dIERpc3BsYWNlbWVudCBvZiB0aGUgc2hhcGVcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbc2hhcGUtcm90YXRpb249MF0gUm90YXRpb24gaW4gcmFkaWFucyAocG9zaXRpdmUgcm90YXRpb24gY2xvY2t3aXNlKS5cbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW3NoYXBlLXJvdGF0ZS13aXRoLXZpZXc9ZmFsc2VdIFdoZXRoZXIgdG8gcm90YXRlIHRoZSBzaGFwZSB3aXRoIHRoZSB2aWV3LlxuICogQHByb3BlcnR5IHtudW1iZXJ8aW1wb3J0KFwiLi4vc2l6ZS5qc1wiKS5TaXplfSBbc2hhcGUtc2NhbGU9MV0gU2NhbGUuIFVubGVzcyB0d28gZGltZW5zaW9uYWwgc2NhbGluZyBpcyByZXF1aXJlZCBhIGJldHRlclxuICogcmVzdWx0IG1heSBiZSBvYnRhaW5lZCB3aXRoIGFwcHJvcHJpYXRlIHNldHRpbmdzIGZvciBgc2hhcGUtcmFkaXVzYCwgYHNoYXBlLXJhZGl1czFgIGFuZCBgc2hhcGUtcmFkaXVzMmAuXG4gKiBAcHJvcGVydHkge1wiZGVjbHV0dGVyXCJ8XCJvYnN0YWNsZVwifFwibm9uZVwifHVuZGVmaW5lZH0gW3NoYXBlLWRlY2x1dHRlci1tb2RlXSBEZWNsdXR0ZXIgbW9kZS5cbiAqL1xuXG4vKipcbiAqIENpcmNsZSBzdHlsZSBwcm9wZXJ0aWVzIGZvciByZW5kZXJpbmcgcG9pbnQgZmVhdHVyZXMuICBBdCBsZWFzdCBgY2lyY2xlLXJhZGl1c2AgbXVzdCBiZSBwcm92aWRlZC5cbiAqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBGbGF0Q2lyY2xlXG4gKiBAcHJvcGVydHkge251bWJlcn0gW2NpcmNsZS1yYWRpdXNdIENpcmNsZSByYWRpdXMuXG4gKiBAcHJvcGVydHkge2ltcG9ydChcIi4uL2NvbG9yLmpzXCIpLkNvbG9yfGltcG9ydChcIi4uL2NvbG9ybGlrZS5qc1wiKS5Db2xvckxpa2V9IFtjaXJjbGUtZmlsbC1jb2xvcl0gVGhlIGZpbGwgY29sb3IuXG4gKiBAcHJvcGVydHkge2ltcG9ydChcIi4uL2NvbG9yLmpzXCIpLkNvbG9yfGltcG9ydChcIi4uL2NvbG9ybGlrZS5qc1wiKS5Db2xvckxpa2V9IFtjaXJjbGUtc3Ryb2tlLWNvbG9yXSBUaGUgc3Ryb2tlIGNvbG9yLlxuICogQHByb3BlcnR5IHtudW1iZXJ9IFtjaXJjbGUtc3Ryb2tlLXdpZHRoXSBTdHJva2UgcGl4ZWwgd2lkdGguXG4gKiBAcHJvcGVydHkge0NhbnZhc0xpbmVDYXB9IFtjaXJjbGUtc3Ryb2tlLWxpbmUtY2FwPSdyb3VuZCddIExpbmUgY2FwIHN0eWxlOiBgYnV0dGAsIGByb3VuZGAsIG9yIGBzcXVhcmVgLlxuICogQHByb3BlcnR5IHtDYW52YXNMaW5lSm9pbn0gW2NpcmNsZS1zdHJva2UtbGluZS1qb2luPSdyb3VuZCddIExpbmUgam9pbiBzdHlsZTogYGJldmVsYCwgYHJvdW5kYCwgb3IgYG1pdGVyYC5cbiAqIEBwcm9wZXJ0eSB7QXJyYXk8bnVtYmVyPn0gW2NpcmNsZS1zdHJva2UtbGluZS1kYXNoXSBMaW5lIGRhc2ggcGF0dGVybi5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbY2lyY2xlLXN0cm9rZS1saW5lLWRhc2gtb2Zmc2V0PTBdIExpbmUgZGFzaCBvZmZzZXQuXG4gKiBAcHJvcGVydHkge251bWJlcn0gW2NpcmNsZS1zdHJva2UtbWl0ZXItbGltaXQ9MTBdIE1pdGVyIGxpbWl0LlxuICogQHByb3BlcnR5IHtBcnJheTxudW1iZXI+fSBbY2lyY2xlLWRpc3BsYWNlbWVudD1bMCwwXV0gZGlzcGxhY2VtZW50XG4gKiBAcHJvcGVydHkge251bWJlcnxpbXBvcnQoXCIuLi9zaXplLmpzXCIpLlNpemV9IFtjaXJjbGUtc2NhbGU9MV0gU2NhbGUuIEEgdHdvIGRpbWVuc2lvbmFsIHNjYWxlIHdpbGwgcHJvZHVjZSBhbiBlbGxpcHNlLlxuICogVW5sZXNzIHR3byBkaW1lbnNpb25hbCBzY2FsaW5nIGlzIHJlcXVpcmVkIGEgYmV0dGVyIHJlc3VsdCBtYXkgYmUgb2J0YWluZWQgd2l0aCBhbiBhcHByb3ByaWF0ZSBzZXR0aW5nIGZvciBgY2lyY2xlLXJhZGl1c2AuXG4gKiBAcHJvcGVydHkge251bWJlcn0gW2NpcmNsZS1yb3RhdGlvbj0wXSBSb3RhdGlvbiBpbiByYWRpYW5zXG4gKiAocG9zaXRpdmUgcm90YXRpb24gY2xvY2t3aXNlLCBtZWFuaW5nZnVsIG9ubHkgd2hlbiB1c2VkIGluIGNvbmp1bmN0aW9uIHdpdGggYSB0d28gZGltZW5zaW9uYWwgc2NhbGUpLlxuICogQHByb3BlcnR5IHtib29sZWFufSBbY2lyY2xlLXJvdGF0ZS13aXRoLXZpZXc9ZmFsc2VdIFdoZXRoZXIgdG8gcm90YXRlIHRoZSBzaGFwZSB3aXRoIHRoZSB2aWV3XG4gKiAobWVhbmluZ2Z1bCBvbmx5IHdoZW4gdXNlZCBpbiBjb25qdW5jdGlvbiB3aXRoIGEgdHdvIGRpbWVuc2lvbmFsIHNjYWxlKS5cbiAqIEBwcm9wZXJ0eSB7XCJkZWNsdXR0ZXJcInxcIm9ic3RhY2xlXCJ8XCJub25lXCJ8dW5kZWZpbmVkfSBbY2lyY2xlLWRlY2x1dHRlci1tb2RlXSBEZWNsdXR0ZXIgbW9kZVxuICovXG5cbi8qKlxuICogQHBhcmFtIHtGbGF0U3R5bGV9IGZsYXRTdHlsZSBBIGZsYXQgc3R5bGUgbGl0ZXJhbC5cbiAqIEByZXR1cm4ge2ltcG9ydChcIi4vU3R5bGUuanNcIikuZGVmYXVsdH0gQSBzdHlsZSBpbnN0YW5jZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRvU3R5bGUoZmxhdFN0eWxlKSB7XG4gIGNvbnN0IHN0eWxlID0gbmV3IFN0eWxlKHtcbiAgICBmaWxsOiBnZXRGaWxsKGZsYXRTdHlsZSwgJycpLFxuICAgIHN0cm9rZTogZ2V0U3Ryb2tlKGZsYXRTdHlsZSwgJycpLFxuICAgIHRleHQ6IGdldFRleHQoZmxhdFN0eWxlKSxcbiAgICBpbWFnZTogZ2V0SW1hZ2UoZmxhdFN0eWxlKSxcbiAgfSk7XG5cbiAgcmV0dXJuIHN0eWxlO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7RmxhdFN0eWxlfSBmbGF0U3R5bGUgVGhlIGZsYXQgc3R5bGUuXG4gKiBAcGFyYW0ge3N0cmluZ30gcHJlZml4IFRoZSBwcm9wZXJ0eSBwcmVmaXguXG4gKiBAcmV0dXJuIHtGaWxsfHVuZGVmaW5lZH0gVGhlIGZpbGwgKGlmIGFueSkuXG4gKi9cbmZ1bmN0aW9uIGdldEZpbGwoZmxhdFN0eWxlLCBwcmVmaXgpIHtcbiAgY29uc3QgY29sb3IgPSBmbGF0U3R5bGVbcHJlZml4ICsgJ2ZpbGwtY29sb3InXTtcbiAgaWYgKCFjb2xvcikge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHJldHVybiBuZXcgRmlsbCh7Y29sb3I6IGNvbG9yfSk7XG59XG5cbi8qKlxuICogQHBhcmFtIHtGbGF0U3R5bGV9IGZsYXRTdHlsZSBUaGUgZmxhdCBzdHlsZS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBwcmVmaXggVGhlIHByb3BlcnR5IHByZWZpeC5cbiAqIEByZXR1cm4ge1N0cm9rZXx1bmRlZmluZWR9IFRoZSBzdHJva2UgKGlmIGFueSkuXG4gKi9cbmZ1bmN0aW9uIGdldFN0cm9rZShmbGF0U3R5bGUsIHByZWZpeCkge1xuICBjb25zdCB3aWR0aCA9IGZsYXRTdHlsZVtwcmVmaXggKyAnc3Ryb2tlLXdpZHRoJ107XG4gIGNvbnN0IGNvbG9yID0gZmxhdFN0eWxlW3ByZWZpeCArICdzdHJva2UtY29sb3InXTtcbiAgaWYgKCF3aWR0aCAmJiAhY29sb3IpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICByZXR1cm4gbmV3IFN0cm9rZSh7XG4gICAgd2lkdGg6IHdpZHRoLFxuICAgIGNvbG9yOiBjb2xvcixcbiAgICBsaW5lQ2FwOiBmbGF0U3R5bGVbcHJlZml4ICsgJ3N0cm9rZS1saW5lLWNhcCddLFxuICAgIGxpbmVKb2luOiBmbGF0U3R5bGVbcHJlZml4ICsgJ3N0cm9rZS1saW5lLWpvaW4nXSxcbiAgICBsaW5lRGFzaDogZmxhdFN0eWxlW3ByZWZpeCArICdzdHJva2UtbGluZS1kYXNoJ10sXG4gICAgbGluZURhc2hPZmZzZXQ6IGZsYXRTdHlsZVtwcmVmaXggKyAnc3Ryb2tlLWxpbmUtZGFzaC1vZmZzZXQnXSxcbiAgICBtaXRlckxpbWl0OiBmbGF0U3R5bGVbcHJlZml4ICsgJ3N0cm9rZS1taXRlci1saW1pdCddLFxuICB9KTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge0ZsYXRTdHlsZX0gZmxhdFN0eWxlIFRoZSBmbGF0IHN0eWxlLlxuICogQHJldHVybiB7VGV4dHx1bmRlZmluZWR9IFRoZSB0ZXh0IChpZiBhbnkpLlxuICovXG5mdW5jdGlvbiBnZXRUZXh0KGZsYXRTdHlsZSkge1xuICBjb25zdCB2YWx1ZSA9IGZsYXRTdHlsZVsndGV4dC12YWx1ZSddO1xuICBpZiAoIXZhbHVlKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgY29uc3QgdGV4dCA9IG5ldyBUZXh0KHtcbiAgICB0ZXh0OiB2YWx1ZSxcbiAgICBmb250OiBmbGF0U3R5bGVbJ3RleHQtZm9udCddLFxuICAgIG1heEFuZ2xlOiBmbGF0U3R5bGVbJ3RleHQtbWF4LWFuZ2xlJ10sXG4gICAgb2Zmc2V0WDogZmxhdFN0eWxlWyd0ZXh0LW9mZnNldC14J10sXG4gICAgb2Zmc2V0WTogZmxhdFN0eWxlWyd0ZXh0LW9mZnNldC15J10sXG4gICAgb3ZlcmZsb3c6IGZsYXRTdHlsZVsndGV4dC1vdmVyZmxvdyddLFxuICAgIHBsYWNlbWVudDogZmxhdFN0eWxlWyd0ZXh0LXBsYWNlbWVudCddLFxuICAgIHJlcGVhdDogZmxhdFN0eWxlWyd0ZXh0LXJlcGVhdCddLFxuICAgIHNjYWxlOiBmbGF0U3R5bGVbJ3RleHQtc2NhbGUnXSxcbiAgICByb3RhdGVXaXRoVmlldzogZmxhdFN0eWxlWyd0ZXh0LXJvdGF0ZS13aXRoLXZpZXcnXSxcbiAgICByb3RhdGlvbjogZmxhdFN0eWxlWyd0ZXh0LXJvdGF0aW9uJ10sXG4gICAgdGV4dEFsaWduOiBmbGF0U3R5bGVbJ3RleHQtYWxpZ24nXSxcbiAgICBqdXN0aWZ5OiBmbGF0U3R5bGVbJ3RleHQtanVzdGlmeSddLFxuICAgIHRleHRCYXNlbGluZTogZmxhdFN0eWxlWyd0ZXh0LWJhc2VsaW5lJ10sXG4gICAgcGFkZGluZzogZmxhdFN0eWxlWyd0ZXh0LXBhZGRpbmcnXSxcbiAgICBmaWxsOiBnZXRGaWxsKGZsYXRTdHlsZSwgJ3RleHQtJyksXG4gICAgYmFja2dyb3VuZEZpbGw6IGdldEZpbGwoZmxhdFN0eWxlLCAndGV4dC1iYWNrZ3JvdW5kLScpLFxuICAgIHN0cm9rZTogZ2V0U3Ryb2tlKGZsYXRTdHlsZSwgJ3RleHQtJyksXG4gICAgYmFja2dyb3VuZFN0cm9rZTogZ2V0U3Ryb2tlKGZsYXRTdHlsZSwgJ3RleHQtYmFja2dyb3VuZC0nKSxcbiAgfSk7XG5cbiAgcmV0dXJuIHRleHQ7XG59XG5cbi8qKlxuICogQHBhcmFtIHtGbGF0U3R5bGV9IGZsYXRTdHlsZSBUaGUgZmxhdCBzdHlsZS5cbiAqIEByZXR1cm4ge2ltcG9ydChcIi4vSW1hZ2UuanNcIikuZGVmYXVsdHx1bmRlZmluZWR9IFRoZSBpbWFnZSAoaWYgYW55KS5cbiAqL1xuZnVuY3Rpb24gZ2V0SW1hZ2UoZmxhdFN0eWxlKSB7XG4gIGNvbnN0IGljb25TcmMgPSBmbGF0U3R5bGVbJ2ljb24tc3JjJ107XG4gIGNvbnN0IGljb25JbWcgPSBmbGF0U3R5bGVbJ2ljb24taW1nJ107XG4gIGlmIChpY29uU3JjIHx8IGljb25JbWcpIHtcbiAgICBjb25zdCBpY29uID0gbmV3IEljb24oe1xuICAgICAgc3JjOiBpY29uU3JjLFxuICAgICAgaW1nOiBpY29uSW1nLFxuICAgICAgaW1nU2l6ZTogZmxhdFN0eWxlWydpY29uLWltZy1zaXplJ10sXG4gICAgICBhbmNob3I6IGZsYXRTdHlsZVsnaWNvbi1hbmNob3InXSxcbiAgICAgIGFuY2hvck9yaWdpbjogZmxhdFN0eWxlWydpY29uLWFuY2hvci1vcmlnaW4nXSxcbiAgICAgIGFuY2hvclhVbml0czogZmxhdFN0eWxlWydpY29uLWFuY2hvci14LXVuaXRzJ10sXG4gICAgICBhbmNob3JZVW5pdHM6IGZsYXRTdHlsZVsnaWNvbi1hbmNob3IteS11bml0cyddLFxuICAgICAgY29sb3I6IGZsYXRTdHlsZVsnaWNvbi1jb2xvciddLFxuICAgICAgY3Jvc3NPcmlnaW46IGZsYXRTdHlsZVsnaWNvbi1jcm9zcy1vcmlnaW4nXSxcbiAgICAgIG9mZnNldDogZmxhdFN0eWxlWydpY29uLW9mZnNldCddLFxuICAgICAgZGlzcGxhY2VtZW50OiBmbGF0U3R5bGVbJ2ljb24tZGlzcGxhY2VtZW50J10sXG4gICAgICBvcGFjaXR5OiBmbGF0U3R5bGVbJ2ljb24tb3BhY2l0eSddLFxuICAgICAgc2NhbGU6IGZsYXRTdHlsZVsnaWNvbi1zY2FsZSddLFxuICAgICAgcm90YXRpb246IGZsYXRTdHlsZVsnaWNvbi1yb3RhdGlvbiddLFxuICAgICAgcm90YXRlV2l0aFZpZXc6IGZsYXRTdHlsZVsnaWNvbi1yb3RhdGUtd2l0aC12aWV3J10sXG4gICAgICBzaXplOiBmbGF0U3R5bGVbJ2ljb24tc2l6ZSddLFxuICAgICAgZGVjbHV0dGVyTW9kZTogZmxhdFN0eWxlWydpY29uLWRlY2x1dHRlci1tb2RlJ10sXG4gICAgfSk7XG4gICAgcmV0dXJuIGljb247XG4gIH1cblxuICBjb25zdCBzaGFwZVBvaW50cyA9IGZsYXRTdHlsZVsnc2hhcGUtcG9pbnRzJ107XG4gIGlmIChzaGFwZVBvaW50cykge1xuICAgIGNvbnN0IHByZWZpeCA9ICdzaGFwZS0nO1xuICAgIGNvbnN0IHNoYXBlID0gbmV3IFJlZ3VsYXJTaGFwZSh7XG4gICAgICBwb2ludHM6IHNoYXBlUG9pbnRzLFxuICAgICAgZmlsbDogZ2V0RmlsbChmbGF0U3R5bGUsIHByZWZpeCksXG4gICAgICBzdHJva2U6IGdldFN0cm9rZShmbGF0U3R5bGUsIHByZWZpeCksXG4gICAgICByYWRpdXM6IGZsYXRTdHlsZVsnc2hhcGUtcmFkaXVzJ10sXG4gICAgICByYWRpdXMxOiBmbGF0U3R5bGVbJ3NoYXBlLXJhZGl1czEnXSxcbiAgICAgIHJhZGl1czI6IGZsYXRTdHlsZVsnc2hhcGUtcmFkaXVzMiddLFxuICAgICAgYW5nbGU6IGZsYXRTdHlsZVsnc2hhcGUtYW5nbGUnXSxcbiAgICAgIGRpc3BsYWNlbWVudDogZmxhdFN0eWxlWydzaGFwZS1kaXNwbGFjZW1lbnQnXSxcbiAgICAgIHJvdGF0aW9uOiBmbGF0U3R5bGVbJ3NoYXBlLXJvdGF0aW9uJ10sXG4gICAgICByb3RhdGVXaXRoVmlldzogZmxhdFN0eWxlWydzaGFwZS1yb3RhdGUtd2l0aC12aWV3J10sXG4gICAgICBzY2FsZTogZmxhdFN0eWxlWydzaGFwZS1zY2FsZSddLFxuICAgICAgZGVjbHV0dGVyTW9kZTogZmxhdFN0eWxlWydzaGFwZS1kZWNsdXR0ZXItbW9kZSddLFxuICAgIH0pO1xuXG4gICAgcmV0dXJuIHNoYXBlO1xuICB9XG5cbiAgY29uc3QgY2lyY2xlUmFkaXVzID0gZmxhdFN0eWxlWydjaXJjbGUtcmFkaXVzJ107XG4gIGlmIChjaXJjbGVSYWRpdXMpIHtcbiAgICBjb25zdCBwcmVmaXggPSAnY2lyY2xlLSc7XG4gICAgY29uc3QgY2lyY2xlID0gbmV3IENpcmNsZSh7XG4gICAgICByYWRpdXM6IGNpcmNsZVJhZGl1cyxcbiAgICAgIGZpbGw6IGdldEZpbGwoZmxhdFN0eWxlLCBwcmVmaXgpLFxuICAgICAgc3Ryb2tlOiBnZXRTdHJva2UoZmxhdFN0eWxlLCBwcmVmaXgpLFxuICAgICAgZGlzcGxhY2VtZW50OiBmbGF0U3R5bGVbJ2NpcmNsZS1kaXNwbGFjZW1lbnQnXSxcbiAgICAgIHNjYWxlOiBmbGF0U3R5bGVbJ2NpcmNsZS1zY2FsZSddLFxuICAgICAgcm90YXRpb246IGZsYXRTdHlsZVsnY2lyY2xlLXJvdGF0aW9uJ10sXG4gICAgICByb3RhdGVXaXRoVmlldzogZmxhdFN0eWxlWydjaXJjbGUtcm90YXRlLXdpdGgtdmlldyddLFxuICAgICAgZGVjbHV0dGVyTW9kZTogZmxhdFN0eWxlWydjaXJjbGUtZGVjbHV0dGVyLW1vZGUnXSxcbiAgICB9KTtcblxuICAgIHJldHVybiBjaXJjbGU7XG4gIH1cblxuICByZXR1cm47XG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///83654\n")},98634:function(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__){eval('/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "T9": function() { return /* binding */ createOrUpdate; },\n/* harmony export */   "Ul": function() { return /* binding */ fromKey; },\n/* harmony export */   "km": function() { return /* binding */ getKey; },\n/* harmony export */   "lg": function() { return /* binding */ getKeyZXY; },\n/* harmony export */   "tE": function() { return /* binding */ withinExtentAndZ; },\n/* harmony export */   "vp": function() { return /* binding */ hash; }\n/* harmony export */ });\n/* unused harmony export getCacheKeyForTileKey */\n/**\n * @module ol/tilecoord\n */\n\n/**\n * An array of three numbers representing the location of a tile in a tile\n * grid. The order is `z` (zoom level), `x` (column), and `y` (row).\n * @typedef {Array<number>} TileCoord\n * @api\n */\n\n/**\n * @param {number} z Z.\n * @param {number} x X.\n * @param {number} y Y.\n * @param {TileCoord} [tileCoord] Tile coordinate.\n * @return {TileCoord} Tile coordinate.\n */\nfunction createOrUpdate(z, x, y, tileCoord) {\n  if (tileCoord !== undefined) {\n    tileCoord[0] = z;\n    tileCoord[1] = x;\n    tileCoord[2] = y;\n    return tileCoord;\n  }\n  return [z, x, y];\n}\n\n/**\n * @param {number} z Z.\n * @param {number} x X.\n * @param {number} y Y.\n * @return {string} Key.\n */\nfunction getKeyZXY(z, x, y) {\n  return z + \'/\' + x + \'/\' + y;\n}\n\n/**\n * Get the key for a tile coord.\n * @param {TileCoord} tileCoord The tile coord.\n * @return {string} Key.\n */\nfunction getKey(tileCoord) {\n  return getKeyZXY(tileCoord[0], tileCoord[1], tileCoord[2]);\n}\n\n/**\n * Get the tile cache key for a tile key obtained through `tile.getKey()`.\n * @param {string} tileKey The tile key.\n * @return {string} The cache key.\n */\nfunction getCacheKeyForTileKey(tileKey) {\n  const [z, x, y] = tileKey\n    .substring(tileKey.lastIndexOf(\'/\') + 1, tileKey.length)\n    .split(\',\')\n    .map(Number);\n  return getKeyZXY(z, x, y);\n}\n\n/**\n * Get a tile coord given a key.\n * @param {string} key The tile coord key.\n * @return {TileCoord} The tile coord.\n */\nfunction fromKey(key) {\n  return key.split(\'/\').map(Number);\n}\n\n/**\n * @param {TileCoord} tileCoord Tile coord.\n * @return {number} Hash.\n */\nfunction hash(tileCoord) {\n  return (tileCoord[1] << tileCoord[0]) + tileCoord[2];\n}\n\n/**\n * @param {TileCoord} tileCoord Tile coordinate.\n * @param {!import("./tilegrid/TileGrid.js").default} tileGrid Tile grid.\n * @return {boolean} Tile coordinate is within extent and zoom level range.\n */\nfunction withinExtentAndZ(tileCoord, tileGrid) {\n  const z = tileCoord[0];\n  const x = tileCoord[1];\n  const y = tileCoord[2];\n\n  if (tileGrid.getMinZoom() > z || z > tileGrid.getMaxZoom()) {\n    return false;\n  }\n  const tileRange = tileGrid.getFullTileRange(z);\n  if (!tileRange) {\n    return true;\n  }\n  return tileRange.containsXY(x, y);\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiOTg2MzQuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsZUFBZTtBQUM1QjtBQUNBOztBQUVBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxXQUFXO0FBQ3RCLFlBQVksV0FBVztBQUN2QjtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFlBQVksUUFBUTtBQUNwQjtBQUNPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxXQUFXO0FBQ3RCLFlBQVksUUFBUTtBQUNwQjtBQUNPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFlBQVksUUFBUTtBQUNwQjtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsWUFBWSxXQUFXO0FBQ3ZCO0FBQ087QUFDUDtBQUNBOztBQUVBO0FBQ0EsV0FBVyxXQUFXO0FBQ3RCLFlBQVksUUFBUTtBQUNwQjtBQUNPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBLFdBQVcsV0FBVztBQUN0QixXQUFXLDJDQUEyQztBQUN0RCxZQUFZLFNBQVM7QUFDckI7QUFDTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly92dWUzLXdlYnBhY2s1Ly4vbm9kZV9tb2R1bGVzL29sL3RpbGVjb29yZC5qcz85ODkxIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQG1vZHVsZSBvbC90aWxlY29vcmRcbiAqL1xuXG4vKipcbiAqIEFuIGFycmF5IG9mIHRocmVlIG51bWJlcnMgcmVwcmVzZW50aW5nIHRoZSBsb2NhdGlvbiBvZiBhIHRpbGUgaW4gYSB0aWxlXG4gKiBncmlkLiBUaGUgb3JkZXIgaXMgYHpgICh6b29tIGxldmVsKSwgYHhgIChjb2x1bW4pLCBhbmQgYHlgIChyb3cpLlxuICogQHR5cGVkZWYge0FycmF5PG51bWJlcj59IFRpbGVDb29yZFxuICogQGFwaVxuICovXG5cbi8qKlxuICogQHBhcmFtIHtudW1iZXJ9IHogWi5cbiAqIEBwYXJhbSB7bnVtYmVyfSB4IFguXG4gKiBAcGFyYW0ge251bWJlcn0geSBZLlxuICogQHBhcmFtIHtUaWxlQ29vcmR9IFt0aWxlQ29vcmRdIFRpbGUgY29vcmRpbmF0ZS5cbiAqIEByZXR1cm4ge1RpbGVDb29yZH0gVGlsZSBjb29yZGluYXRlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlT3JVcGRhdGUoeiwgeCwgeSwgdGlsZUNvb3JkKSB7XG4gIGlmICh0aWxlQ29vcmQgIT09IHVuZGVmaW5lZCkge1xuICAgIHRpbGVDb29yZFswXSA9IHo7XG4gICAgdGlsZUNvb3JkWzFdID0geDtcbiAgICB0aWxlQ29vcmRbMl0gPSB5O1xuICAgIHJldHVybiB0aWxlQ29vcmQ7XG4gIH1cbiAgcmV0dXJuIFt6LCB4LCB5XTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge251bWJlcn0geiBaLlxuICogQHBhcmFtIHtudW1iZXJ9IHggWC5cbiAqIEBwYXJhbSB7bnVtYmVyfSB5IFkuXG4gKiBAcmV0dXJuIHtzdHJpbmd9IEtleS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldEtleVpYWSh6LCB4LCB5KSB7XG4gIHJldHVybiB6ICsgJy8nICsgeCArICcvJyArIHk7XG59XG5cbi8qKlxuICogR2V0IHRoZSBrZXkgZm9yIGEgdGlsZSBjb29yZC5cbiAqIEBwYXJhbSB7VGlsZUNvb3JkfSB0aWxlQ29vcmQgVGhlIHRpbGUgY29vcmQuXG4gKiBAcmV0dXJuIHtzdHJpbmd9IEtleS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldEtleSh0aWxlQ29vcmQpIHtcbiAgcmV0dXJuIGdldEtleVpYWSh0aWxlQ29vcmRbMF0sIHRpbGVDb29yZFsxXSwgdGlsZUNvb3JkWzJdKTtcbn1cblxuLyoqXG4gKiBHZXQgdGhlIHRpbGUgY2FjaGUga2V5IGZvciBhIHRpbGUga2V5IG9idGFpbmVkIHRocm91Z2ggYHRpbGUuZ2V0S2V5KClgLlxuICogQHBhcmFtIHtzdHJpbmd9IHRpbGVLZXkgVGhlIHRpbGUga2V5LlxuICogQHJldHVybiB7c3RyaW5nfSBUaGUgY2FjaGUga2V5LlxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0Q2FjaGVLZXlGb3JUaWxlS2V5KHRpbGVLZXkpIHtcbiAgY29uc3QgW3osIHgsIHldID0gdGlsZUtleVxuICAgIC5zdWJzdHJpbmcodGlsZUtleS5sYXN0SW5kZXhPZignLycpICsgMSwgdGlsZUtleS5sZW5ndGgpXG4gICAgLnNwbGl0KCcsJylcbiAgICAubWFwKE51bWJlcik7XG4gIHJldHVybiBnZXRLZXlaWFkoeiwgeCwgeSk7XG59XG5cbi8qKlxuICogR2V0IGEgdGlsZSBjb29yZCBnaXZlbiBhIGtleS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIHRpbGUgY29vcmQga2V5LlxuICogQHJldHVybiB7VGlsZUNvb3JkfSBUaGUgdGlsZSBjb29yZC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGZyb21LZXkoa2V5KSB7XG4gIHJldHVybiBrZXkuc3BsaXQoJy8nKS5tYXAoTnVtYmVyKTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge1RpbGVDb29yZH0gdGlsZUNvb3JkIFRpbGUgY29vcmQuXG4gKiBAcmV0dXJuIHtudW1iZXJ9IEhhc2guXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBoYXNoKHRpbGVDb29yZCkge1xuICByZXR1cm4gKHRpbGVDb29yZFsxXSA8PCB0aWxlQ29vcmRbMF0pICsgdGlsZUNvb3JkWzJdO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7VGlsZUNvb3JkfSB0aWxlQ29vcmQgVGlsZSBjb29yZGluYXRlLlxuICogQHBhcmFtIHshaW1wb3J0KFwiLi90aWxlZ3JpZC9UaWxlR3JpZC5qc1wiKS5kZWZhdWx0fSB0aWxlR3JpZCBUaWxlIGdyaWQuXG4gKiBAcmV0dXJuIHtib29sZWFufSBUaWxlIGNvb3JkaW5hdGUgaXMgd2l0aGluIGV4dGVudCBhbmQgem9vbSBsZXZlbCByYW5nZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHdpdGhpbkV4dGVudEFuZFoodGlsZUNvb3JkLCB0aWxlR3JpZCkge1xuICBjb25zdCB6ID0gdGlsZUNvb3JkWzBdO1xuICBjb25zdCB4ID0gdGlsZUNvb3JkWzFdO1xuICBjb25zdCB5ID0gdGlsZUNvb3JkWzJdO1xuXG4gIGlmICh0aWxlR3JpZC5nZXRNaW5ab29tKCkgPiB6IHx8IHogPiB0aWxlR3JpZC5nZXRNYXhab29tKCkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgY29uc3QgdGlsZVJhbmdlID0gdGlsZUdyaWQuZ2V0RnVsbFRpbGVSYW5nZSh6KTtcbiAgaWYgKCF0aWxlUmFuZ2UpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICByZXR1cm4gdGlsZVJhbmdlLmNvbnRhaW5zWFkoeCwgeSk7XG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///98634\n')},66686:function(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__){eval('\n// EXPORTS\n__webpack_require__.d(__webpack_exports__, {\n  "dl": function() { return /* binding */ createXYZ; },\n  "Tl": function() { return /* binding */ extentFromProjection; },\n  "X$": function() { return /* binding */ getForProjection; },\n  "Cf": function() { return /* binding */ wrapX; }\n});\n\n// UNUSED EXPORTS: createForExtent, createForProjection\n\n// EXTERNAL MODULE: ./node_modules/ol/TileRange.js\nvar TileRange = __webpack_require__(2519);\n// EXTERNAL MODULE: ./node_modules/ol/tilegrid/common.js\nvar common = __webpack_require__(94768);\n// EXTERNAL MODULE: ./node_modules/ol/asserts.js\nvar asserts = __webpack_require__(99515);\n// EXTERNAL MODULE: ./node_modules/ol/math.js\nvar math = __webpack_require__(33983);\n// EXTERNAL MODULE: ./node_modules/ol/extent.js\nvar ol_extent = __webpack_require__(28641);\n// EXTERNAL MODULE: ./node_modules/ol/tilecoord.js\nvar tilecoord = __webpack_require__(98634);\n// EXTERNAL MODULE: ./node_modules/ol/geom/flat/intersectsextent.js\nvar intersectsextent = __webpack_require__(63746);\n// EXTERNAL MODULE: ./node_modules/ol/array.js\nvar array = __webpack_require__(65537);\n// EXTERNAL MODULE: ./node_modules/ol/size.js\nvar size = __webpack_require__(4307);\n;// CONCATENATED MODULE: ./node_modules/ol/tilegrid/TileGrid.js\n/**\n * @module ol/tilegrid/TileGrid\n */\n\n\n\n\n\n\n\n\n\n\n/**\n * @private\n * @type {import("../tilecoord.js").TileCoord}\n */\nconst tmpTileCoord = [0, 0, 0];\n\n/**\n * Number of decimal digits to consider in integer values when rounding.\n * @type {number}\n */\nconst DECIMALS = 5;\n\n/**\n * @typedef {Object} Options\n * @property {import("../extent.js").Extent} [extent] Extent for the tile grid. No tiles outside this\n * extent will be requested by {@link module:ol/source/Tile~TileSource} sources. When no `origin` or\n * `origins` are configured, the `origin` will be set to the top-left corner of the extent.\n * @property {number} [minZoom=0] Minimum zoom.\n * @property {import("../coordinate.js").Coordinate} [origin] The tile grid origin, i.e. where the `x`\n * and `y` axes meet (`[z, 0, 0]`). Tile coordinates increase left to right and downwards. If not\n * specified, `extent` or `origins` must be provided.\n * @property {Array<import("../coordinate.js").Coordinate>} [origins] Tile grid origins, i.e. where\n * the `x` and `y` axes meet (`[z, 0, 0]`), for each zoom level. If given, the array length\n * should match the length of the `resolutions` array, i.e. each resolution can have a different\n * origin. Tile coordinates increase left to right and downwards. If not specified, `extent` or\n * `origin` must be provided.\n * @property {!Array<number>} resolutions Resolutions. The array index of each resolution needs\n * to match the zoom level. This means that even if a `minZoom` is configured, the resolutions\n * array will have a length of `maxZoom + 1`.\n * @property {Array<import("../size.js").Size>} [sizes] Number of tile rows and columns\n * of the grid for each zoom level. If specified the values\n * define each zoom level\'s extent together with the `origin` or `origins`.\n * A grid `extent` can be configured in addition, and will further limit the extent\n * for which tile requests are made by sources. If the bottom-left corner of\n * an extent is used as `origin` or `origins`, then the `y` value must be\n * negative because OpenLayers tile coordinates use the top left as the origin.\n * @property {number|import("../size.js").Size} [tileSize] Tile size.\n * Default is `[256, 256]`.\n * @property {Array<number|import("../size.js").Size>} [tileSizes] Tile sizes. If given, the array length\n * should match the length of the `resolutions` array, i.e. each resolution can have a different\n * tile size.\n */\n\n/**\n * @classdesc\n * Base class for setting the grid pattern for sources accessing tiled-image\n * servers.\n * @api\n */\nclass TileGrid {\n  /**\n   * @param {Options} options Tile grid options.\n   */\n  constructor(options) {\n    /**\n     * @protected\n     * @type {number}\n     */\n    this.minZoom = options.minZoom !== undefined ? options.minZoom : 0;\n\n    /**\n     * @private\n     * @type {!Array<number>}\n     */\n    this.resolutions_ = options.resolutions;\n    (0,asserts/* assert */.h)(\n      (0,array/* isSorted */.pT)(\n        this.resolutions_,\n        function (a, b) {\n          return b - a;\n        },\n        true\n      ),\n      17\n    ); // `resolutions` must be sorted in descending order\n\n    // check if we\'ve got a consistent zoom factor and origin\n    let zoomFactor;\n    if (!options.origins) {\n      for (let i = 0, ii = this.resolutions_.length - 1; i < ii; ++i) {\n        if (!zoomFactor) {\n          zoomFactor = this.resolutions_[i] / this.resolutions_[i + 1];\n        } else {\n          if (this.resolutions_[i] / this.resolutions_[i + 1] !== zoomFactor) {\n            zoomFactor = undefined;\n            break;\n          }\n        }\n      }\n    }\n\n    /**\n     * @private\n     * @type {number|undefined}\n     */\n    this.zoomFactor_ = zoomFactor;\n\n    /**\n     * @protected\n     * @type {number}\n     */\n    this.maxZoom = this.resolutions_.length - 1;\n\n    /**\n     * @private\n     * @type {import("../coordinate.js").Coordinate|null}\n     */\n    this.origin_ = options.origin !== undefined ? options.origin : null;\n\n    /**\n     * @private\n     * @type {Array<import("../coordinate.js").Coordinate>}\n     */\n    this.origins_ = null;\n    if (options.origins !== undefined) {\n      this.origins_ = options.origins;\n      (0,asserts/* assert */.h)(this.origins_.length == this.resolutions_.length, 20); // Number of `origins` and `resolutions` must be equal\n    }\n\n    const extent = options.extent;\n\n    if (extent !== undefined && !this.origin_ && !this.origins_) {\n      this.origin_ = (0,ol_extent/* getTopLeft */.rL)(extent);\n    }\n\n    (0,asserts/* assert */.h)(\n      (!this.origin_ && this.origins_) || (this.origin_ && !this.origins_),\n      18\n    ); // Either `origin` or `origins` must be configured, never both\n\n    /**\n     * @private\n     * @type {Array<number|import("../size.js").Size>}\n     */\n    this.tileSizes_ = null;\n    if (options.tileSizes !== undefined) {\n      this.tileSizes_ = options.tileSizes;\n      (0,asserts/* assert */.h)(this.tileSizes_.length == this.resolutions_.length, 19); // Number of `tileSizes` and `resolutions` must be equal\n    }\n\n    /**\n     * @private\n     * @type {number|import("../size.js").Size}\n     */\n    this.tileSize_ =\n      options.tileSize !== undefined\n        ? options.tileSize\n        : !this.tileSizes_\n        ? common/* DEFAULT_TILE_SIZE */.S\n        : null;\n    (0,asserts/* assert */.h)(\n      (!this.tileSize_ && this.tileSizes_) ||\n        (this.tileSize_ && !this.tileSizes_),\n      22\n    ); // Either `tileSize` or `tileSizes` must be configured, never both\n\n    /**\n     * @private\n     * @type {import("../extent.js").Extent}\n     */\n    this.extent_ = extent !== undefined ? extent : null;\n\n    /**\n     * @private\n     * @type {Array<import("../TileRange.js").default>}\n     */\n    this.fullTileRanges_ = null;\n\n    /**\n     * @private\n     * @type {import("../size.js").Size}\n     */\n    this.tmpSize_ = [0, 0];\n\n    /**\n     * @private\n     * @type {import("../extent.js").Extent}\n     */\n    this.tmpExtent_ = [0, 0, 0, 0];\n\n    if (options.sizes !== undefined) {\n      this.fullTileRanges_ = options.sizes.map(function (size, z) {\n        const tileRange = new TileRange/* default */.Z(\n          Math.min(0, size[0]),\n          Math.max(size[0] - 1, -1),\n          Math.min(0, size[1]),\n          Math.max(size[1] - 1, -1)\n        );\n        if (extent) {\n          const restrictedTileRange = this.getTileRangeForExtentAndZ(extent, z);\n          tileRange.minX = Math.max(restrictedTileRange.minX, tileRange.minX);\n          tileRange.maxX = Math.min(restrictedTileRange.maxX, tileRange.maxX);\n          tileRange.minY = Math.max(restrictedTileRange.minY, tileRange.minY);\n          tileRange.maxY = Math.min(restrictedTileRange.maxY, tileRange.maxY);\n        }\n        return tileRange;\n      }, this);\n    } else if (extent) {\n      this.calculateTileRanges_(extent);\n    }\n  }\n\n  /**\n   * Call a function with each tile coordinate for a given extent and zoom level.\n   *\n   * @param {import("../extent.js").Extent} extent Extent.\n   * @param {number} zoom Integer zoom level.\n   * @param {function(import("../tilecoord.js").TileCoord): void} callback Function called with each tile coordinate.\n   * @api\n   */\n  forEachTileCoord(extent, zoom, callback) {\n    const tileRange = this.getTileRangeForExtentAndZ(extent, zoom);\n    for (let i = tileRange.minX, ii = tileRange.maxX; i <= ii; ++i) {\n      for (let j = tileRange.minY, jj = tileRange.maxY; j <= jj; ++j) {\n        callback([zoom, i, j]);\n      }\n    }\n  }\n\n  /**\n   * @param {import("../tilecoord.js").TileCoord} tileCoord Tile coordinate.\n   * @param {function(number, import("../TileRange.js").default): boolean} callback Callback.\n   * @param {import("../TileRange.js").default} [tempTileRange] Temporary import("../TileRange.js").default object.\n   * @param {import("../extent.js").Extent} [tempExtent] Temporary import("../extent.js").Extent object.\n   * @return {boolean} Callback succeeded.\n   */\n  forEachTileCoordParentTileRange(\n    tileCoord,\n    callback,\n    tempTileRange,\n    tempExtent\n  ) {\n    let tileRange, x, y;\n    let tileCoordExtent = null;\n    let z = tileCoord[0] - 1;\n    if (this.zoomFactor_ === 2) {\n      x = tileCoord[1];\n      y = tileCoord[2];\n    } else {\n      tileCoordExtent = this.getTileCoordExtent(tileCoord, tempExtent);\n    }\n    while (z >= this.minZoom) {\n      if (this.zoomFactor_ === 2) {\n        x = Math.floor(x / 2);\n        y = Math.floor(y / 2);\n        tileRange = (0,TileRange/* createOrUpdate */.T)(x, x, y, y, tempTileRange);\n      } else {\n        tileRange = this.getTileRangeForExtentAndZ(\n          tileCoordExtent,\n          z,\n          tempTileRange\n        );\n      }\n      if (callback(z, tileRange)) {\n        return true;\n      }\n      --z;\n    }\n    return false;\n  }\n\n  /**\n   * Get the extent for this tile grid, if it was configured.\n   * @return {import("../extent.js").Extent} Extent.\n   * @api\n   */\n  getExtent() {\n    return this.extent_;\n  }\n\n  /**\n   * Get the maximum zoom level for the grid.\n   * @return {number} Max zoom.\n   * @api\n   */\n  getMaxZoom() {\n    return this.maxZoom;\n  }\n\n  /**\n   * Get the minimum zoom level for the grid.\n   * @return {number} Min zoom.\n   * @api\n   */\n  getMinZoom() {\n    return this.minZoom;\n  }\n\n  /**\n   * Get the origin for the grid at the given zoom level.\n   * @param {number} z Integer zoom level.\n   * @return {import("../coordinate.js").Coordinate} Origin.\n   * @api\n   */\n  getOrigin(z) {\n    if (this.origin_) {\n      return this.origin_;\n    }\n    return this.origins_[z];\n  }\n\n  /**\n   * Get the resolution for the given zoom level.\n   * @param {number} z Integer zoom level.\n   * @return {number} Resolution.\n   * @api\n   */\n  getResolution(z) {\n    return this.resolutions_[z];\n  }\n\n  /**\n   * Get the list of resolutions for the tile grid.\n   * @return {Array<number>} Resolutions.\n   * @api\n   */\n  getResolutions() {\n    return this.resolutions_;\n  }\n\n  /**\n   * @param {import("../tilecoord.js").TileCoord} tileCoord Tile coordinate.\n   * @param {import("../TileRange.js").default} [tempTileRange] Temporary import("../TileRange.js").default object.\n   * @param {import("../extent.js").Extent} [tempExtent] Temporary import("../extent.js").Extent object.\n   * @return {import("../TileRange.js").default|null} Tile range.\n   */\n  getTileCoordChildTileRange(tileCoord, tempTileRange, tempExtent) {\n    if (tileCoord[0] < this.maxZoom) {\n      if (this.zoomFactor_ === 2) {\n        const minX = tileCoord[1] * 2;\n        const minY = tileCoord[2] * 2;\n        return (0,TileRange/* createOrUpdate */.T)(\n          minX,\n          minX + 1,\n          minY,\n          minY + 1,\n          tempTileRange\n        );\n      }\n      const tileCoordExtent = this.getTileCoordExtent(\n        tileCoord,\n        tempExtent || this.tmpExtent_\n      );\n      return this.getTileRangeForExtentAndZ(\n        tileCoordExtent,\n        tileCoord[0] + 1,\n        tempTileRange\n      );\n    }\n    return null;\n  }\n\n  /**\n   * @param {import("../tilecoord.js").TileCoord} tileCoord Tile coordinate.\n   * @param {number} z Integer zoom level.\n   * @param {import("../TileRange.js").default} [tempTileRange] Temporary import("../TileRange.js").default object.\n   * @return {import("../TileRange.js").default|null} Tile range.\n   */\n  getTileRangeForTileCoordAndZ(tileCoord, z, tempTileRange) {\n    if (z > this.maxZoom || z < this.minZoom) {\n      return null;\n    }\n\n    const tileCoordZ = tileCoord[0];\n    const tileCoordX = tileCoord[1];\n    const tileCoordY = tileCoord[2];\n\n    if (z === tileCoordZ) {\n      return (0,TileRange/* createOrUpdate */.T)(\n        tileCoordX,\n        tileCoordY,\n        tileCoordX,\n        tileCoordY,\n        tempTileRange\n      );\n    }\n\n    if (this.zoomFactor_) {\n      const factor = Math.pow(this.zoomFactor_, z - tileCoordZ);\n      const minX = Math.floor(tileCoordX * factor);\n      const minY = Math.floor(tileCoordY * factor);\n      if (z < tileCoordZ) {\n        return (0,TileRange/* createOrUpdate */.T)(minX, minX, minY, minY, tempTileRange);\n      }\n\n      const maxX = Math.floor(factor * (tileCoordX + 1)) - 1;\n      const maxY = Math.floor(factor * (tileCoordY + 1)) - 1;\n      return (0,TileRange/* createOrUpdate */.T)(minX, maxX, minY, maxY, tempTileRange);\n    }\n\n    const tileCoordExtent = this.getTileCoordExtent(tileCoord, this.tmpExtent_);\n    return this.getTileRangeForExtentAndZ(tileCoordExtent, z, tempTileRange);\n  }\n\n  /**\n   * Get the extent for a tile range.\n   * @param {number} z Integer zoom level.\n   * @param {import("../TileRange.js").default} tileRange Tile range.\n   * @param {import("../extent.js").Extent} [tempExtent] Temporary import("../extent.js").Extent object.\n   * @return {import("../extent.js").Extent} Extent.\n   */\n  getTileRangeExtent(z, tileRange, tempExtent) {\n    const origin = this.getOrigin(z);\n    const resolution = this.getResolution(z);\n    const tileSize = (0,size/* toSize */.Pq)(this.getTileSize(z), this.tmpSize_);\n    const minX = origin[0] + tileRange.minX * tileSize[0] * resolution;\n    const maxX = origin[0] + (tileRange.maxX + 1) * tileSize[0] * resolution;\n    const minY = origin[1] + tileRange.minY * tileSize[1] * resolution;\n    const maxY = origin[1] + (tileRange.maxY + 1) * tileSize[1] * resolution;\n    return (0,ol_extent/* createOrUpdate */.T9)(minX, minY, maxX, maxY, tempExtent);\n  }\n\n  /**\n   * Get a tile range for the given extent and integer zoom level.\n   * @param {import("../extent.js").Extent} extent Extent.\n   * @param {number} z Integer zoom level.\n   * @param {import("../TileRange.js").default} [tempTileRange] Temporary tile range object.\n   * @return {import("../TileRange.js").default} Tile range.\n   */\n  getTileRangeForExtentAndZ(extent, z, tempTileRange) {\n    this.getTileCoordForXYAndZ_(extent[0], extent[3], z, false, tmpTileCoord);\n    const minX = tmpTileCoord[1];\n    const minY = tmpTileCoord[2];\n    this.getTileCoordForXYAndZ_(extent[2], extent[1], z, true, tmpTileCoord);\n    const maxX = tmpTileCoord[1];\n    const maxY = tmpTileCoord[2];\n    return (0,TileRange/* createOrUpdate */.T)(minX, maxX, minY, maxY, tempTileRange);\n  }\n\n  /**\n   * @param {import("../tilecoord.js").TileCoord} tileCoord Tile coordinate.\n   * @return {import("../coordinate.js").Coordinate} Tile center.\n   */\n  getTileCoordCenter(tileCoord) {\n    const origin = this.getOrigin(tileCoord[0]);\n    const resolution = this.getResolution(tileCoord[0]);\n    const tileSize = (0,size/* toSize */.Pq)(this.getTileSize(tileCoord[0]), this.tmpSize_);\n    return [\n      origin[0] + (tileCoord[1] + 0.5) * tileSize[0] * resolution,\n      origin[1] - (tileCoord[2] + 0.5) * tileSize[1] * resolution,\n    ];\n  }\n\n  /**\n   * Get the extent of a tile coordinate.\n   *\n   * @param {import("../tilecoord.js").TileCoord} tileCoord Tile coordinate.\n   * @param {import("../extent.js").Extent} [tempExtent] Temporary extent object.\n   * @return {import("../extent.js").Extent} Extent.\n   * @api\n   */\n  getTileCoordExtent(tileCoord, tempExtent) {\n    const origin = this.getOrigin(tileCoord[0]);\n    const resolution = this.getResolution(tileCoord[0]);\n    const tileSize = (0,size/* toSize */.Pq)(this.getTileSize(tileCoord[0]), this.tmpSize_);\n    const minX = origin[0] + tileCoord[1] * tileSize[0] * resolution;\n    const minY = origin[1] - (tileCoord[2] + 1) * tileSize[1] * resolution;\n    const maxX = minX + tileSize[0] * resolution;\n    const maxY = minY + tileSize[1] * resolution;\n    return (0,ol_extent/* createOrUpdate */.T9)(minX, minY, maxX, maxY, tempExtent);\n  }\n\n  /**\n   * Get the tile coordinate for the given map coordinate and resolution.  This\n   * method considers that coordinates that intersect tile boundaries should be\n   * assigned the higher tile coordinate.\n   *\n   * @param {import("../coordinate.js").Coordinate} coordinate Coordinate.\n   * @param {number} resolution Resolution.\n   * @param {import("../tilecoord.js").TileCoord} [opt_tileCoord] Destination import("../tilecoord.js").TileCoord object.\n   * @return {import("../tilecoord.js").TileCoord} Tile coordinate.\n   * @api\n   */\n  getTileCoordForCoordAndResolution(coordinate, resolution, opt_tileCoord) {\n    return this.getTileCoordForXYAndResolution_(\n      coordinate[0],\n      coordinate[1],\n      resolution,\n      false,\n      opt_tileCoord\n    );\n  }\n\n  /**\n   * Note that this method should not be called for resolutions that correspond\n   * to an integer zoom level.  Instead call the `getTileCoordForXYAndZ_` method.\n   * @param {number} x X.\n   * @param {number} y Y.\n   * @param {number} resolution Resolution (for a non-integer zoom level).\n   * @param {boolean} reverseIntersectionPolicy Instead of letting edge\n   *     intersections go to the higher tile coordinate, let edge intersections\n   *     go to the lower tile coordinate.\n   * @param {import("../tilecoord.js").TileCoord} [opt_tileCoord] Temporary import("../tilecoord.js").TileCoord object.\n   * @return {import("../tilecoord.js").TileCoord} Tile coordinate.\n   * @private\n   */\n  getTileCoordForXYAndResolution_(\n    x,\n    y,\n    resolution,\n    reverseIntersectionPolicy,\n    opt_tileCoord\n  ) {\n    const z = this.getZForResolution(resolution);\n    const scale = resolution / this.getResolution(z);\n    const origin = this.getOrigin(z);\n    const tileSize = (0,size/* toSize */.Pq)(this.getTileSize(z), this.tmpSize_);\n\n    let tileCoordX = (scale * (x - origin[0])) / resolution / tileSize[0];\n    let tileCoordY = (scale * (origin[1] - y)) / resolution / tileSize[1];\n\n    if (reverseIntersectionPolicy) {\n      tileCoordX = (0,math/* ceil */.mD)(tileCoordX, DECIMALS) - 1;\n      tileCoordY = (0,math/* ceil */.mD)(tileCoordY, DECIMALS) - 1;\n    } else {\n      tileCoordX = (0,math/* floor */.GW)(tileCoordX, DECIMALS);\n      tileCoordY = (0,math/* floor */.GW)(tileCoordY, DECIMALS);\n    }\n\n    return (0,tilecoord/* createOrUpdate */.T9)(z, tileCoordX, tileCoordY, opt_tileCoord);\n  }\n\n  /**\n   * Although there is repetition between this method and `getTileCoordForXYAndResolution_`,\n   * they should have separate implementations.  This method is for integer zoom\n   * levels.  The other method should only be called for resolutions corresponding\n   * to non-integer zoom levels.\n   * @param {number} x Map x coordinate.\n   * @param {number} y Map y coordinate.\n   * @param {number} z Integer zoom level.\n   * @param {boolean} reverseIntersectionPolicy Instead of letting edge\n   *     intersections go to the higher tile coordinate, let edge intersections\n   *     go to the lower tile coordinate.\n   * @param {import("../tilecoord.js").TileCoord} [opt_tileCoord] Temporary import("../tilecoord.js").TileCoord object.\n   * @return {import("../tilecoord.js").TileCoord} Tile coordinate.\n   * @private\n   */\n  getTileCoordForXYAndZ_(x, y, z, reverseIntersectionPolicy, opt_tileCoord) {\n    const origin = this.getOrigin(z);\n    const resolution = this.getResolution(z);\n    const tileSize = (0,size/* toSize */.Pq)(this.getTileSize(z), this.tmpSize_);\n\n    let tileCoordX = (x - origin[0]) / resolution / tileSize[0];\n    let tileCoordY = (origin[1] - y) / resolution / tileSize[1];\n\n    if (reverseIntersectionPolicy) {\n      tileCoordX = (0,math/* ceil */.mD)(tileCoordX, DECIMALS) - 1;\n      tileCoordY = (0,math/* ceil */.mD)(tileCoordY, DECIMALS) - 1;\n    } else {\n      tileCoordX = (0,math/* floor */.GW)(tileCoordX, DECIMALS);\n      tileCoordY = (0,math/* floor */.GW)(tileCoordY, DECIMALS);\n    }\n\n    return (0,tilecoord/* createOrUpdate */.T9)(z, tileCoordX, tileCoordY, opt_tileCoord);\n  }\n\n  /**\n   * Get a tile coordinate given a map coordinate and zoom level.\n   * @param {import("../coordinate.js").Coordinate} coordinate Coordinate.\n   * @param {number} z Zoom level.\n   * @param {import("../tilecoord.js").TileCoord} [opt_tileCoord] Destination import("../tilecoord.js").TileCoord object.\n   * @return {import("../tilecoord.js").TileCoord} Tile coordinate.\n   * @api\n   */\n  getTileCoordForCoordAndZ(coordinate, z, opt_tileCoord) {\n    return this.getTileCoordForXYAndZ_(\n      coordinate[0],\n      coordinate[1],\n      z,\n      false,\n      opt_tileCoord\n    );\n  }\n\n  /**\n   * @param {import("../tilecoord.js").TileCoord} tileCoord Tile coordinate.\n   * @return {number} Tile resolution.\n   */\n  getTileCoordResolution(tileCoord) {\n    return this.resolutions_[tileCoord[0]];\n  }\n\n  /**\n   * Get the tile size for a zoom level. The type of the return value matches the\n   * `tileSize` or `tileSizes` that the tile grid was configured with. To always\n   * get an {@link import("../size.js").Size}, run the result through {@link module:ol/size.toSize}.\n   * @param {number} z Z.\n   * @return {number|import("../size.js").Size} Tile size.\n   * @api\n   */\n  getTileSize(z) {\n    if (this.tileSize_) {\n      return this.tileSize_;\n    }\n    return this.tileSizes_[z];\n  }\n\n  /**\n   * @param {number} z Zoom level.\n   * @return {import("../TileRange.js").default} Extent tile range for the specified zoom level.\n   */\n  getFullTileRange(z) {\n    if (!this.fullTileRanges_) {\n      return this.extent_\n        ? this.getTileRangeForExtentAndZ(this.extent_, z)\n        : null;\n    }\n    return this.fullTileRanges_[z];\n  }\n\n  /**\n   * @param {number} resolution Resolution.\n   * @param {number|import("../array.js").NearestDirectionFunction} [opt_direction]\n   *     If 0, the nearest resolution will be used.\n   *     If 1, the nearest higher resolution (lower Z) will be used. If -1, the\n   *     nearest lower resolution (higher Z) will be used. Default is 0.\n   *     Use a {@link module:ol/array~NearestDirectionFunction} for more precise control.\n   *\n   * For example to change tile Z at the midpoint of zoom levels\n   * ```js\n   * function(value, high, low) {\n   *   return value - low * Math.sqrt(high / low);\n   * }\n   * ```\n   * @return {number} Z.\n   * @api\n   */\n  getZForResolution(resolution, opt_direction) {\n    const z = (0,array/* linearFindNearest */.h7)(\n      this.resolutions_,\n      resolution,\n      opt_direction || 0\n    );\n    return (0,math/* clamp */.uZ)(z, this.minZoom, this.maxZoom);\n  }\n\n  /**\n   * The tile with the provided tile coordinate intersects the given viewport.\n   * @param {import(\'../tilecoord.js\').TileCoord} tileCoord Tile coordinate.\n   * @param {Array<number>} viewport Viewport as returned from {@link module:ol/extent.getRotatedViewport}.\n   * @return {boolean} The tile with the provided tile coordinate intersects the given viewport.\n   */\n  tileCoordIntersectsViewport(tileCoord, viewport) {\n    return (0,intersectsextent/* intersectsLinearRing */.mV)(\n      viewport,\n      0,\n      viewport.length,\n      2,\n      this.getTileCoordExtent(tileCoord)\n    );\n  }\n\n  /**\n   * @param {!import("../extent.js").Extent} extent Extent for this tile grid.\n   * @private\n   */\n  calculateTileRanges_(extent) {\n    const length = this.resolutions_.length;\n    const fullTileRanges = new Array(length);\n    for (let z = this.minZoom; z < length; ++z) {\n      fullTileRanges[z] = this.getTileRangeForExtentAndZ(extent, z);\n    }\n    this.fullTileRanges_ = fullTileRanges;\n  }\n}\n\n/* harmony default export */ var tilegrid_TileGrid = (TileGrid);\n\n// EXTERNAL MODULE: ./node_modules/ol/proj.js + 4 modules\nvar proj = __webpack_require__(24121);\n;// CONCATENATED MODULE: ./node_modules/ol/tilegrid.js\n/**\n * @module ol/tilegrid\n */\n\n\n\n\n\n\n/**\n * @param {import("./proj/Projection.js").default} projection Projection.\n * @return {!TileGrid} Default tile grid for the\n * passed projection.\n */\nfunction getForProjection(projection) {\n  let tileGrid = projection.getDefaultTileGrid();\n  if (!tileGrid) {\n    tileGrid = createForProjection(projection);\n    projection.setDefaultTileGrid(tileGrid);\n  }\n  return tileGrid;\n}\n\n/**\n * @param {TileGrid} tileGrid Tile grid.\n * @param {import("./tilecoord.js").TileCoord} tileCoord Tile coordinate.\n * @param {import("./proj/Projection.js").default} projection Projection.\n * @return {import("./tilecoord.js").TileCoord} Tile coordinate.\n */\nfunction wrapX(tileGrid, tileCoord, projection) {\n  const z = tileCoord[0];\n  const center = tileGrid.getTileCoordCenter(tileCoord);\n  const projectionExtent = extentFromProjection(projection);\n  if (!(0,ol_extent/* containsCoordinate */.b8)(projectionExtent, center)) {\n    const worldWidth = (0,ol_extent/* getWidth */.dz)(projectionExtent);\n    const worldsAway = Math.ceil(\n      (projectionExtent[0] - center[0]) / worldWidth\n    );\n    center[0] += worldWidth * worldsAway;\n    return tileGrid.getTileCoordForCoordAndZ(center, z);\n  }\n  return tileCoord;\n}\n\n/**\n * @param {import("./extent.js").Extent} extent Extent.\n * @param {number} [maxZoom] Maximum zoom level (default is\n *     DEFAULT_MAX_ZOOM).\n * @param {number|import("./size.js").Size} [tileSize] Tile size (default uses\n *     DEFAULT_TILE_SIZE).\n * @param {import("./extent.js").Corner} [corner] Extent corner (default is `\'top-left\'`).\n * @return {!TileGrid} TileGrid instance.\n */\nfunction createForExtent(extent, maxZoom, tileSize, corner) {\n  corner = corner !== undefined ? corner : \'top-left\';\n\n  const resolutions = resolutionsFromExtent(extent, maxZoom, tileSize);\n\n  return new tilegrid_TileGrid({\n    extent: extent,\n    origin: (0,ol_extent/* getCorner */.g0)(extent, corner),\n    resolutions: resolutions,\n    tileSize: tileSize,\n  });\n}\n\n/**\n * @typedef {Object} XYZOptions\n * @property {import("./extent.js").Extent} [extent] Extent for the tile grid. The origin for an XYZ tile grid is the\n * top-left corner of the extent. If `maxResolution` is not provided the zero level of the grid is defined by the resolution\n * at which one tile fits in the provided extent. If not provided, the extent of the EPSG:3857 projection is used.\n * @property {number} [maxResolution] Resolution at level zero.\n * @property {number} [maxZoom] Maximum zoom. The default is `42`. This determines the number of levels\n * in the grid set. For example, a `maxZoom` of 21 means there are 22 levels in the grid set.\n * @property {number} [minZoom=0] Minimum zoom.\n * @property {number|import("./size.js").Size} [tileSize=[256, 256]] Tile size in pixels.\n */\n\n/**\n * Creates a tile grid with a standard XYZ tiling scheme.\n * @param {XYZOptions} [options] Tile grid options.\n * @return {!TileGrid} Tile grid instance.\n * @api\n */\nfunction createXYZ(options) {\n  const xyzOptions = options || {};\n\n  const extent = xyzOptions.extent || (0,proj/* get */.U2)(\'EPSG:3857\').getExtent();\n\n  const gridOptions = {\n    extent: extent,\n    minZoom: xyzOptions.minZoom,\n    tileSize: xyzOptions.tileSize,\n    resolutions: resolutionsFromExtent(\n      extent,\n      xyzOptions.maxZoom,\n      xyzOptions.tileSize,\n      xyzOptions.maxResolution\n    ),\n  };\n  return new tilegrid_TileGrid(gridOptions);\n}\n\n/**\n * Create a resolutions array from an extent.  A zoom factor of 2 is assumed.\n * @param {import("./extent.js").Extent} extent Extent.\n * @param {number} [maxZoom] Maximum zoom level (default is\n *     DEFAULT_MAX_ZOOM).\n * @param {number|import("./size.js").Size} [tileSize] Tile size (default uses\n *     DEFAULT_TILE_SIZE).\n * @param {number} [maxResolution] Resolution at level zero.\n * @return {!Array<number>} Resolutions array.\n */\nfunction resolutionsFromExtent(extent, maxZoom, tileSize, maxResolution) {\n  maxZoom = maxZoom !== undefined ? maxZoom : common/* DEFAULT_MAX_ZOOM */.e;\n  tileSize = (0,size/* toSize */.Pq)(tileSize !== undefined ? tileSize : common/* DEFAULT_TILE_SIZE */.S);\n\n  const height = (0,ol_extent/* getHeight */.Cr)(extent);\n  const width = (0,ol_extent/* getWidth */.dz)(extent);\n\n  maxResolution =\n    maxResolution > 0\n      ? maxResolution\n      : Math.max(width / tileSize[0], height / tileSize[1]);\n\n  const length = maxZoom + 1;\n  const resolutions = new Array(length);\n  for (let z = 0; z < length; ++z) {\n    resolutions[z] = maxResolution / Math.pow(2, z);\n  }\n  return resolutions;\n}\n\n/**\n * @param {import("./proj.js").ProjectionLike} projection Projection.\n * @param {number} [maxZoom] Maximum zoom level (default is\n *     DEFAULT_MAX_ZOOM).\n * @param {number|import("./size.js").Size} [tileSize] Tile size (default uses\n *     DEFAULT_TILE_SIZE).\n * @param {import("./extent.js").Corner} [corner] Extent corner (default is `\'top-left\'`).\n * @return {!TileGrid} TileGrid instance.\n */\nfunction createForProjection(projection, maxZoom, tileSize, corner) {\n  const extent = extentFromProjection(projection);\n  return createForExtent(extent, maxZoom, tileSize, corner);\n}\n\n/**\n * Generate a tile grid extent from a projection.  If the projection has an\n * extent, it is used.  If not, a global extent is assumed.\n * @param {import("./proj.js").ProjectionLike} projection Projection.\n * @return {import("./extent.js").Extent} Extent.\n */\nfunction extentFromProjection(projection) {\n  projection = (0,proj/* get */.U2)(projection);\n  let extent = projection.getExtent();\n  if (!extent) {\n    const half =\n      (180 * proj/* METERS_PER_UNIT.degrees */.Wm.degrees) / projection.getMetersPerUnit();\n    extent = (0,ol_extent/* createOrUpdate */.T9)(-half, -half, half, half);\n  }\n  return extent;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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O0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3Z1ZTMtd2VicGFjazUvLi9ub2RlX21vZHVsZXMvb2wvdGlsZWdyaWQvVGlsZUdyaWQuanM/MGY2YSIsIndlYnBhY2s6Ly92dWUzLXdlYnBhY2s1Ly4vbm9kZV9tb2R1bGVzL29sL3RpbGVncmlkLmpzPzI2NWYiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAbW9kdWxlIG9sL3RpbGVncmlkL1RpbGVHcmlkXG4gKi9cbmltcG9ydCBUaWxlUmFuZ2UsIHtcbiAgY3JlYXRlT3JVcGRhdGUgYXMgY3JlYXRlT3JVcGRhdGVUaWxlUmFuZ2UsXG59IGZyb20gJy4uL1RpbGVSYW5nZS5qcyc7XG5pbXBvcnQge0RFRkFVTFRfVElMRV9TSVpFfSBmcm9tICcuL2NvbW1vbi5qcyc7XG5pbXBvcnQge2Fzc2VydH0gZnJvbSAnLi4vYXNzZXJ0cy5qcyc7XG5pbXBvcnQge2NlaWwsIGNsYW1wLCBmbG9vcn0gZnJvbSAnLi4vbWF0aC5qcyc7XG5pbXBvcnQge2NyZWF0ZU9yVXBkYXRlLCBnZXRUb3BMZWZ0fSBmcm9tICcuLi9leHRlbnQuanMnO1xuaW1wb3J0IHtjcmVhdGVPclVwZGF0ZSBhcyBjcmVhdGVPclVwZGF0ZVRpbGVDb29yZH0gZnJvbSAnLi4vdGlsZWNvb3JkLmpzJztcbmltcG9ydCB7aW50ZXJzZWN0c0xpbmVhclJpbmd9IGZyb20gJy4uL2dlb20vZmxhdC9pbnRlcnNlY3RzZXh0ZW50LmpzJztcbmltcG9ydCB7aXNTb3J0ZWQsIGxpbmVhckZpbmROZWFyZXN0fSBmcm9tICcuLi9hcnJheS5qcyc7XG5pbXBvcnQge3RvU2l6ZX0gZnJvbSAnLi4vc2l6ZS5qcyc7XG5cbi8qKlxuICogQHByaXZhdGVcbiAqIEB0eXBlIHtpbXBvcnQoXCIuLi90aWxlY29vcmQuanNcIikuVGlsZUNvb3JkfVxuICovXG5jb25zdCB0bXBUaWxlQ29vcmQgPSBbMCwgMCwgMF07XG5cbi8qKlxuICogTnVtYmVyIG9mIGRlY2ltYWwgZGlnaXRzIHRvIGNvbnNpZGVyIGluIGludGVnZXIgdmFsdWVzIHdoZW4gcm91bmRpbmcuXG4gKiBAdHlwZSB7bnVtYmVyfVxuICovXG5jb25zdCBERUNJTUFMUyA9IDU7XG5cbi8qKlxuICogQHR5cGVkZWYge09iamVjdH0gT3B0aW9uc1xuICogQHByb3BlcnR5IHtpbXBvcnQoXCIuLi9leHRlbnQuanNcIikuRXh0ZW50fSBbZXh0ZW50XSBFeHRlbnQgZm9yIHRoZSB0aWxlIGdyaWQuIE5vIHRpbGVzIG91dHNpZGUgdGhpc1xuICogZXh0ZW50IHdpbGwgYmUgcmVxdWVzdGVkIGJ5IHtAbGluayBtb2R1bGU6b2wvc291cmNlL1RpbGV+VGlsZVNvdXJjZX0gc291cmNlcy4gV2hlbiBubyBgb3JpZ2luYCBvclxuICogYG9yaWdpbnNgIGFyZSBjb25maWd1cmVkLCB0aGUgYG9yaWdpbmAgd2lsbCBiZSBzZXQgdG8gdGhlIHRvcC1sZWZ0IGNvcm5lciBvZiB0aGUgZXh0ZW50LlxuICogQHByb3BlcnR5IHtudW1iZXJ9IFttaW5ab29tPTBdIE1pbmltdW0gem9vbS5cbiAqIEBwcm9wZXJ0eSB7aW1wb3J0KFwiLi4vY29vcmRpbmF0ZS5qc1wiKS5Db29yZGluYXRlfSBbb3JpZ2luXSBUaGUgdGlsZSBncmlkIG9yaWdpbiwgaS5lLiB3aGVyZSB0aGUgYHhgXG4gKiBhbmQgYHlgIGF4ZXMgbWVldCAoYFt6LCAwLCAwXWApLiBUaWxlIGNvb3JkaW5hdGVzIGluY3JlYXNlIGxlZnQgdG8gcmlnaHQgYW5kIGRvd253YXJkcy4gSWYgbm90XG4gKiBzcGVjaWZpZWQsIGBleHRlbnRgIG9yIGBvcmlnaW5zYCBtdXN0IGJlIHByb3ZpZGVkLlxuICogQHByb3BlcnR5IHtBcnJheTxpbXBvcnQoXCIuLi9jb29yZGluYXRlLmpzXCIpLkNvb3JkaW5hdGU+fSBbb3JpZ2luc10gVGlsZSBncmlkIG9yaWdpbnMsIGkuZS4gd2hlcmVcbiAqIHRoZSBgeGAgYW5kIGB5YCBheGVzIG1lZXQgKGBbeiwgMCwgMF1gKSwgZm9yIGVhY2ggem9vbSBsZXZlbC4gSWYgZ2l2ZW4sIHRoZSBhcnJheSBsZW5ndGhcbiAqIHNob3VsZCBtYXRjaCB0aGUgbGVuZ3RoIG9mIHRoZSBgcmVzb2x1dGlvbnNgIGFycmF5LCBpLmUuIGVhY2ggcmVzb2x1dGlvbiBjYW4gaGF2ZSBhIGRpZmZlcmVudFxuICogb3JpZ2luLiBUaWxlIGNvb3JkaW5hdGVzIGluY3JlYXNlIGxlZnQgdG8gcmlnaHQgYW5kIGRvd253YXJkcy4gSWYgbm90IHNwZWNpZmllZCwgYGV4dGVudGAgb3JcbiAqIGBvcmlnaW5gIG11c3QgYmUgcHJvdmlkZWQuXG4gKiBAcHJvcGVydHkgeyFBcnJheTxudW1iZXI+fSByZXNvbHV0aW9ucyBSZXNvbHV0aW9ucy4gVGhlIGFycmF5IGluZGV4IG9mIGVhY2ggcmVzb2x1dGlvbiBuZWVkc1xuICogdG8gbWF0Y2ggdGhlIHpvb20gbGV2ZWwuIFRoaXMgbWVhbnMgdGhhdCBldmVuIGlmIGEgYG1pblpvb21gIGlzIGNvbmZpZ3VyZWQsIHRoZSByZXNvbHV0aW9uc1xuICogYXJyYXkgd2lsbCBoYXZlIGEgbGVuZ3RoIG9mIGBtYXhab29tICsgMWAuXG4gKiBAcHJvcGVydHkge0FycmF5PGltcG9ydChcIi4uL3NpemUuanNcIikuU2l6ZT59IFtzaXplc10gTnVtYmVyIG9mIHRpbGUgcm93cyBhbmQgY29sdW1uc1xuICogb2YgdGhlIGdyaWQgZm9yIGVhY2ggem9vbSBsZXZlbC4gSWYgc3BlY2lmaWVkIHRoZSB2YWx1ZXNcbiAqIGRlZmluZSBlYWNoIHpvb20gbGV2ZWwncyBleHRlbnQgdG9nZXRoZXIgd2l0aCB0aGUgYG9yaWdpbmAgb3IgYG9yaWdpbnNgLlxuICogQSBncmlkIGBleHRlbnRgIGNhbiBiZSBjb25maWd1cmVkIGluIGFkZGl0aW9uLCBhbmQgd2lsbCBmdXJ0aGVyIGxpbWl0IHRoZSBleHRlbnRcbiAqIGZvciB3aGljaCB0aWxlIHJlcXVlc3RzIGFyZSBtYWRlIGJ5IHNvdXJjZXMuIElmIHRoZSBib3R0b20tbGVmdCBjb3JuZXIgb2ZcbiAqIGFuIGV4dGVudCBpcyB1c2VkIGFzIGBvcmlnaW5gIG9yIGBvcmlnaW5zYCwgdGhlbiB0aGUgYHlgIHZhbHVlIG11c3QgYmVcbiAqIG5lZ2F0aXZlIGJlY2F1c2UgT3BlbkxheWVycyB0aWxlIGNvb3JkaW5hdGVzIHVzZSB0aGUgdG9wIGxlZnQgYXMgdGhlIG9yaWdpbi5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfGltcG9ydChcIi4uL3NpemUuanNcIikuU2l6ZX0gW3RpbGVTaXplXSBUaWxlIHNpemUuXG4gKiBEZWZhdWx0IGlzIGBbMjU2LCAyNTZdYC5cbiAqIEBwcm9wZXJ0eSB7QXJyYXk8bnVtYmVyfGltcG9ydChcIi4uL3NpemUuanNcIikuU2l6ZT59IFt0aWxlU2l6ZXNdIFRpbGUgc2l6ZXMuIElmIGdpdmVuLCB0aGUgYXJyYXkgbGVuZ3RoXG4gKiBzaG91bGQgbWF0Y2ggdGhlIGxlbmd0aCBvZiB0aGUgYHJlc29sdXRpb25zYCBhcnJheSwgaS5lLiBlYWNoIHJlc29sdXRpb24gY2FuIGhhdmUgYSBkaWZmZXJlbnRcbiAqIHRpbGUgc2l6ZS5cbiAqL1xuXG4vKipcbiAqIEBjbGFzc2Rlc2NcbiAqIEJhc2UgY2xhc3MgZm9yIHNldHRpbmcgdGhlIGdyaWQgcGF0dGVybiBmb3Igc291cmNlcyBhY2Nlc3NpbmcgdGlsZWQtaW1hZ2VcbiAqIHNlcnZlcnMuXG4gKiBAYXBpXG4gKi9cbmNsYXNzIFRpbGVHcmlkIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7T3B0aW9uc30gb3B0aW9ucyBUaWxlIGdyaWQgb3B0aW9ucy5cbiAgICovXG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcbiAgICAvKipcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLm1pblpvb20gPSBvcHRpb25zLm1pblpvb20gIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMubWluWm9vbSA6IDA7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHshQXJyYXk8bnVtYmVyPn1cbiAgICAgKi9cbiAgICB0aGlzLnJlc29sdXRpb25zXyA9IG9wdGlvbnMucmVzb2x1dGlvbnM7XG4gICAgYXNzZXJ0KFxuICAgICAgaXNTb3J0ZWQoXG4gICAgICAgIHRoaXMucmVzb2x1dGlvbnNfLFxuICAgICAgICBmdW5jdGlvbiAoYSwgYikge1xuICAgICAgICAgIHJldHVybiBiIC0gYTtcbiAgICAgICAgfSxcbiAgICAgICAgdHJ1ZVxuICAgICAgKSxcbiAgICAgIDE3XG4gICAgKTsgLy8gYHJlc29sdXRpb25zYCBtdXN0IGJlIHNvcnRlZCBpbiBkZXNjZW5kaW5nIG9yZGVyXG5cbiAgICAvLyBjaGVjayBpZiB3ZSd2ZSBnb3QgYSBjb25zaXN0ZW50IHpvb20gZmFjdG9yIGFuZCBvcmlnaW5cbiAgICBsZXQgem9vbUZhY3RvcjtcbiAgICBpZiAoIW9wdGlvbnMub3JpZ2lucykge1xuICAgICAgZm9yIChsZXQgaSA9IDAsIGlpID0gdGhpcy5yZXNvbHV0aW9uc18ubGVuZ3RoIC0gMTsgaSA8IGlpOyArK2kpIHtcbiAgICAgICAgaWYgKCF6b29tRmFjdG9yKSB7XG4gICAgICAgICAgem9vbUZhY3RvciA9IHRoaXMucmVzb2x1dGlvbnNfW2ldIC8gdGhpcy5yZXNvbHV0aW9uc19baSArIDFdO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmICh0aGlzLnJlc29sdXRpb25zX1tpXSAvIHRoaXMucmVzb2x1dGlvbnNfW2kgKyAxXSAhPT0gem9vbUZhY3Rvcikge1xuICAgICAgICAgICAgem9vbUZhY3RvciA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge251bWJlcnx1bmRlZmluZWR9XG4gICAgICovXG4gICAgdGhpcy56b29tRmFjdG9yXyA9IHpvb21GYWN0b3I7XG5cbiAgICAvKipcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLm1heFpvb20gPSB0aGlzLnJlc29sdXRpb25zXy5sZW5ndGggLSAxO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7aW1wb3J0KFwiLi4vY29vcmRpbmF0ZS5qc1wiKS5Db29yZGluYXRlfG51bGx9XG4gICAgICovXG4gICAgdGhpcy5vcmlnaW5fID0gb3B0aW9ucy5vcmlnaW4gIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMub3JpZ2luIDogbnVsbDtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge0FycmF5PGltcG9ydChcIi4uL2Nvb3JkaW5hdGUuanNcIikuQ29vcmRpbmF0ZT59XG4gICAgICovXG4gICAgdGhpcy5vcmlnaW5zXyA9IG51bGw7XG4gICAgaWYgKG9wdGlvbnMub3JpZ2lucyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aGlzLm9yaWdpbnNfID0gb3B0aW9ucy5vcmlnaW5zO1xuICAgICAgYXNzZXJ0KHRoaXMub3JpZ2luc18ubGVuZ3RoID09IHRoaXMucmVzb2x1dGlvbnNfLmxlbmd0aCwgMjApOyAvLyBOdW1iZXIgb2YgYG9yaWdpbnNgIGFuZCBgcmVzb2x1dGlvbnNgIG11c3QgYmUgZXF1YWxcbiAgICB9XG5cbiAgICBjb25zdCBleHRlbnQgPSBvcHRpb25zLmV4dGVudDtcblxuICAgIGlmIChleHRlbnQgIT09IHVuZGVmaW5lZCAmJiAhdGhpcy5vcmlnaW5fICYmICF0aGlzLm9yaWdpbnNfKSB7XG4gICAgICB0aGlzLm9yaWdpbl8gPSBnZXRUb3BMZWZ0KGV4dGVudCk7XG4gICAgfVxuXG4gICAgYXNzZXJ0KFxuICAgICAgKCF0aGlzLm9yaWdpbl8gJiYgdGhpcy5vcmlnaW5zXykgfHwgKHRoaXMub3JpZ2luXyAmJiAhdGhpcy5vcmlnaW5zXyksXG4gICAgICAxOFxuICAgICk7IC8vIEVpdGhlciBgb3JpZ2luYCBvciBgb3JpZ2luc2AgbXVzdCBiZSBjb25maWd1cmVkLCBuZXZlciBib3RoXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtBcnJheTxudW1iZXJ8aW1wb3J0KFwiLi4vc2l6ZS5qc1wiKS5TaXplPn1cbiAgICAgKi9cbiAgICB0aGlzLnRpbGVTaXplc18gPSBudWxsO1xuICAgIGlmIChvcHRpb25zLnRpbGVTaXplcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aGlzLnRpbGVTaXplc18gPSBvcHRpb25zLnRpbGVTaXplcztcbiAgICAgIGFzc2VydCh0aGlzLnRpbGVTaXplc18ubGVuZ3RoID09IHRoaXMucmVzb2x1dGlvbnNfLmxlbmd0aCwgMTkpOyAvLyBOdW1iZXIgb2YgYHRpbGVTaXplc2AgYW5kIGByZXNvbHV0aW9uc2AgbXVzdCBiZSBlcXVhbFxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge251bWJlcnxpbXBvcnQoXCIuLi9zaXplLmpzXCIpLlNpemV9XG4gICAgICovXG4gICAgdGhpcy50aWxlU2l6ZV8gPVxuICAgICAgb3B0aW9ucy50aWxlU2l6ZSAhPT0gdW5kZWZpbmVkXG4gICAgICAgID8gb3B0aW9ucy50aWxlU2l6ZVxuICAgICAgICA6ICF0aGlzLnRpbGVTaXplc19cbiAgICAgICAgPyBERUZBVUxUX1RJTEVfU0laRVxuICAgICAgICA6IG51bGw7XG4gICAgYXNzZXJ0KFxuICAgICAgKCF0aGlzLnRpbGVTaXplXyAmJiB0aGlzLnRpbGVTaXplc18pIHx8XG4gICAgICAgICh0aGlzLnRpbGVTaXplXyAmJiAhdGhpcy50aWxlU2l6ZXNfKSxcbiAgICAgIDIyXG4gICAgKTsgLy8gRWl0aGVyIGB0aWxlU2l6ZWAgb3IgYHRpbGVTaXplc2AgbXVzdCBiZSBjb25maWd1cmVkLCBuZXZlciBib3RoXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtpbXBvcnQoXCIuLi9leHRlbnQuanNcIikuRXh0ZW50fVxuICAgICAqL1xuICAgIHRoaXMuZXh0ZW50XyA9IGV4dGVudCAhPT0gdW5kZWZpbmVkID8gZXh0ZW50IDogbnVsbDtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge0FycmF5PGltcG9ydChcIi4uL1RpbGVSYW5nZS5qc1wiKS5kZWZhdWx0Pn1cbiAgICAgKi9cbiAgICB0aGlzLmZ1bGxUaWxlUmFuZ2VzXyA9IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtpbXBvcnQoXCIuLi9zaXplLmpzXCIpLlNpemV9XG4gICAgICovXG4gICAgdGhpcy50bXBTaXplXyA9IFswLCAwXTtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge2ltcG9ydChcIi4uL2V4dGVudC5qc1wiKS5FeHRlbnR9XG4gICAgICovXG4gICAgdGhpcy50bXBFeHRlbnRfID0gWzAsIDAsIDAsIDBdO1xuXG4gICAgaWYgKG9wdGlvbnMuc2l6ZXMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhpcy5mdWxsVGlsZVJhbmdlc18gPSBvcHRpb25zLnNpemVzLm1hcChmdW5jdGlvbiAoc2l6ZSwgeikge1xuICAgICAgICBjb25zdCB0aWxlUmFuZ2UgPSBuZXcgVGlsZVJhbmdlKFxuICAgICAgICAgIE1hdGgubWluKDAsIHNpemVbMF0pLFxuICAgICAgICAgIE1hdGgubWF4KHNpemVbMF0gLSAxLCAtMSksXG4gICAgICAgICAgTWF0aC5taW4oMCwgc2l6ZVsxXSksXG4gICAgICAgICAgTWF0aC5tYXgoc2l6ZVsxXSAtIDEsIC0xKVxuICAgICAgICApO1xuICAgICAgICBpZiAoZXh0ZW50KSB7XG4gICAgICAgICAgY29uc3QgcmVzdHJpY3RlZFRpbGVSYW5nZSA9IHRoaXMuZ2V0VGlsZVJhbmdlRm9yRXh0ZW50QW5kWihleHRlbnQsIHopO1xuICAgICAgICAgIHRpbGVSYW5nZS5taW5YID0gTWF0aC5tYXgocmVzdHJpY3RlZFRpbGVSYW5nZS5taW5YLCB0aWxlUmFuZ2UubWluWCk7XG4gICAgICAgICAgdGlsZVJhbmdlLm1heFggPSBNYXRoLm1pbihyZXN0cmljdGVkVGlsZVJhbmdlLm1heFgsIHRpbGVSYW5nZS5tYXhYKTtcbiAgICAgICAgICB0aWxlUmFuZ2UubWluWSA9IE1hdGgubWF4KHJlc3RyaWN0ZWRUaWxlUmFuZ2UubWluWSwgdGlsZVJhbmdlLm1pblkpO1xuICAgICAgICAgIHRpbGVSYW5nZS5tYXhZID0gTWF0aC5taW4ocmVzdHJpY3RlZFRpbGVSYW5nZS5tYXhZLCB0aWxlUmFuZ2UubWF4WSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRpbGVSYW5nZTtcbiAgICAgIH0sIHRoaXMpO1xuICAgIH0gZWxzZSBpZiAoZXh0ZW50KSB7XG4gICAgICB0aGlzLmNhbGN1bGF0ZVRpbGVSYW5nZXNfKGV4dGVudCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIENhbGwgYSBmdW5jdGlvbiB3aXRoIGVhY2ggdGlsZSBjb29yZGluYXRlIGZvciBhIGdpdmVuIGV4dGVudCBhbmQgem9vbSBsZXZlbC5cbiAgICpcbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9leHRlbnQuanNcIikuRXh0ZW50fSBleHRlbnQgRXh0ZW50LlxuICAgKiBAcGFyYW0ge251bWJlcn0gem9vbSBJbnRlZ2VyIHpvb20gbGV2ZWwuXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb24oaW1wb3J0KFwiLi4vdGlsZWNvb3JkLmpzXCIpLlRpbGVDb29yZCk6IHZvaWR9IGNhbGxiYWNrIEZ1bmN0aW9uIGNhbGxlZCB3aXRoIGVhY2ggdGlsZSBjb29yZGluYXRlLlxuICAgKiBAYXBpXG4gICAqL1xuICBmb3JFYWNoVGlsZUNvb3JkKGV4dGVudCwgem9vbSwgY2FsbGJhY2spIHtcbiAgICBjb25zdCB0aWxlUmFuZ2UgPSB0aGlzLmdldFRpbGVSYW5nZUZvckV4dGVudEFuZFooZXh0ZW50LCB6b29tKTtcbiAgICBmb3IgKGxldCBpID0gdGlsZVJhbmdlLm1pblgsIGlpID0gdGlsZVJhbmdlLm1heFg7IGkgPD0gaWk7ICsraSkge1xuICAgICAgZm9yIChsZXQgaiA9IHRpbGVSYW5nZS5taW5ZLCBqaiA9IHRpbGVSYW5nZS5tYXhZOyBqIDw9IGpqOyArK2opIHtcbiAgICAgICAgY2FsbGJhY2soW3pvb20sIGksIGpdKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi90aWxlY29vcmQuanNcIikuVGlsZUNvb3JkfSB0aWxlQ29vcmQgVGlsZSBjb29yZGluYXRlLlxuICAgKiBAcGFyYW0ge2Z1bmN0aW9uKG51bWJlciwgaW1wb3J0KFwiLi4vVGlsZVJhbmdlLmpzXCIpLmRlZmF1bHQpOiBib29sZWFufSBjYWxsYmFjayBDYWxsYmFjay5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9UaWxlUmFuZ2UuanNcIikuZGVmYXVsdH0gW3RlbXBUaWxlUmFuZ2VdIFRlbXBvcmFyeSBpbXBvcnQoXCIuLi9UaWxlUmFuZ2UuanNcIikuZGVmYXVsdCBvYmplY3QuXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vZXh0ZW50LmpzXCIpLkV4dGVudH0gW3RlbXBFeHRlbnRdIFRlbXBvcmFyeSBpbXBvcnQoXCIuLi9leHRlbnQuanNcIikuRXh0ZW50IG9iamVjdC5cbiAgICogQHJldHVybiB7Ym9vbGVhbn0gQ2FsbGJhY2sgc3VjY2VlZGVkLlxuICAgKi9cbiAgZm9yRWFjaFRpbGVDb29yZFBhcmVudFRpbGVSYW5nZShcbiAgICB0aWxlQ29vcmQsXG4gICAgY2FsbGJhY2ssXG4gICAgdGVtcFRpbGVSYW5nZSxcbiAgICB0ZW1wRXh0ZW50XG4gICkge1xuICAgIGxldCB0aWxlUmFuZ2UsIHgsIHk7XG4gICAgbGV0IHRpbGVDb29yZEV4dGVudCA9IG51bGw7XG4gICAgbGV0IHogPSB0aWxlQ29vcmRbMF0gLSAxO1xuICAgIGlmICh0aGlzLnpvb21GYWN0b3JfID09PSAyKSB7XG4gICAgICB4ID0gdGlsZUNvb3JkWzFdO1xuICAgICAgeSA9IHRpbGVDb29yZFsyXTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGlsZUNvb3JkRXh0ZW50ID0gdGhpcy5nZXRUaWxlQ29vcmRFeHRlbnQodGlsZUNvb3JkLCB0ZW1wRXh0ZW50KTtcbiAgICB9XG4gICAgd2hpbGUgKHogPj0gdGhpcy5taW5ab29tKSB7XG4gICAgICBpZiAodGhpcy56b29tRmFjdG9yXyA9PT0gMikge1xuICAgICAgICB4ID0gTWF0aC5mbG9vcih4IC8gMik7XG4gICAgICAgIHkgPSBNYXRoLmZsb29yKHkgLyAyKTtcbiAgICAgICAgdGlsZVJhbmdlID0gY3JlYXRlT3JVcGRhdGVUaWxlUmFuZ2UoeCwgeCwgeSwgeSwgdGVtcFRpbGVSYW5nZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aWxlUmFuZ2UgPSB0aGlzLmdldFRpbGVSYW5nZUZvckV4dGVudEFuZFooXG4gICAgICAgICAgdGlsZUNvb3JkRXh0ZW50LFxuICAgICAgICAgIHosXG4gICAgICAgICAgdGVtcFRpbGVSYW5nZVxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgaWYgKGNhbGxiYWNrKHosIHRpbGVSYW5nZSkpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgICAtLXo7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIGV4dGVudCBmb3IgdGhpcyB0aWxlIGdyaWQsIGlmIGl0IHdhcyBjb25maWd1cmVkLlxuICAgKiBAcmV0dXJuIHtpbXBvcnQoXCIuLi9leHRlbnQuanNcIikuRXh0ZW50fSBFeHRlbnQuXG4gICAqIEBhcGlcbiAgICovXG4gIGdldEV4dGVudCgpIHtcbiAgICByZXR1cm4gdGhpcy5leHRlbnRfO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgbWF4aW11bSB6b29tIGxldmVsIGZvciB0aGUgZ3JpZC5cbiAgICogQHJldHVybiB7bnVtYmVyfSBNYXggem9vbS5cbiAgICogQGFwaVxuICAgKi9cbiAgZ2V0TWF4Wm9vbSgpIHtcbiAgICByZXR1cm4gdGhpcy5tYXhab29tO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgbWluaW11bSB6b29tIGxldmVsIGZvciB0aGUgZ3JpZC5cbiAgICogQHJldHVybiB7bnVtYmVyfSBNaW4gem9vbS5cbiAgICogQGFwaVxuICAgKi9cbiAgZ2V0TWluWm9vbSgpIHtcbiAgICByZXR1cm4gdGhpcy5taW5ab29tO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgb3JpZ2luIGZvciB0aGUgZ3JpZCBhdCB0aGUgZ2l2ZW4gem9vbSBsZXZlbC5cbiAgICogQHBhcmFtIHtudW1iZXJ9IHogSW50ZWdlciB6b29tIGxldmVsLlxuICAgKiBAcmV0dXJuIHtpbXBvcnQoXCIuLi9jb29yZGluYXRlLmpzXCIpLkNvb3JkaW5hdGV9IE9yaWdpbi5cbiAgICogQGFwaVxuICAgKi9cbiAgZ2V0T3JpZ2luKHopIHtcbiAgICBpZiAodGhpcy5vcmlnaW5fKSB7XG4gICAgICByZXR1cm4gdGhpcy5vcmlnaW5fO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5vcmlnaW5zX1t6XTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIHJlc29sdXRpb24gZm9yIHRoZSBnaXZlbiB6b29tIGxldmVsLlxuICAgKiBAcGFyYW0ge251bWJlcn0geiBJbnRlZ2VyIHpvb20gbGV2ZWwuXG4gICAqIEByZXR1cm4ge251bWJlcn0gUmVzb2x1dGlvbi5cbiAgICogQGFwaVxuICAgKi9cbiAgZ2V0UmVzb2x1dGlvbih6KSB7XG4gICAgcmV0dXJuIHRoaXMucmVzb2x1dGlvbnNfW3pdO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgbGlzdCBvZiByZXNvbHV0aW9ucyBmb3IgdGhlIHRpbGUgZ3JpZC5cbiAgICogQHJldHVybiB7QXJyYXk8bnVtYmVyPn0gUmVzb2x1dGlvbnMuXG4gICAqIEBhcGlcbiAgICovXG4gIGdldFJlc29sdXRpb25zKCkge1xuICAgIHJldHVybiB0aGlzLnJlc29sdXRpb25zXztcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL3RpbGVjb29yZC5qc1wiKS5UaWxlQ29vcmR9IHRpbGVDb29yZCBUaWxlIGNvb3JkaW5hdGUuXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vVGlsZVJhbmdlLmpzXCIpLmRlZmF1bHR9IFt0ZW1wVGlsZVJhbmdlXSBUZW1wb3JhcnkgaW1wb3J0KFwiLi4vVGlsZVJhbmdlLmpzXCIpLmRlZmF1bHQgb2JqZWN0LlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL2V4dGVudC5qc1wiKS5FeHRlbnR9IFt0ZW1wRXh0ZW50XSBUZW1wb3JhcnkgaW1wb3J0KFwiLi4vZXh0ZW50LmpzXCIpLkV4dGVudCBvYmplY3QuXG4gICAqIEByZXR1cm4ge2ltcG9ydChcIi4uL1RpbGVSYW5nZS5qc1wiKS5kZWZhdWx0fG51bGx9IFRpbGUgcmFuZ2UuXG4gICAqL1xuICBnZXRUaWxlQ29vcmRDaGlsZFRpbGVSYW5nZSh0aWxlQ29vcmQsIHRlbXBUaWxlUmFuZ2UsIHRlbXBFeHRlbnQpIHtcbiAgICBpZiAodGlsZUNvb3JkWzBdIDwgdGhpcy5tYXhab29tKSB7XG4gICAgICBpZiAodGhpcy56b29tRmFjdG9yXyA9PT0gMikge1xuICAgICAgICBjb25zdCBtaW5YID0gdGlsZUNvb3JkWzFdICogMjtcbiAgICAgICAgY29uc3QgbWluWSA9IHRpbGVDb29yZFsyXSAqIDI7XG4gICAgICAgIHJldHVybiBjcmVhdGVPclVwZGF0ZVRpbGVSYW5nZShcbiAgICAgICAgICBtaW5YLFxuICAgICAgICAgIG1pblggKyAxLFxuICAgICAgICAgIG1pblksXG4gICAgICAgICAgbWluWSArIDEsXG4gICAgICAgICAgdGVtcFRpbGVSYW5nZVxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgY29uc3QgdGlsZUNvb3JkRXh0ZW50ID0gdGhpcy5nZXRUaWxlQ29vcmRFeHRlbnQoXG4gICAgICAgIHRpbGVDb29yZCxcbiAgICAgICAgdGVtcEV4dGVudCB8fCB0aGlzLnRtcEV4dGVudF9cbiAgICAgICk7XG4gICAgICByZXR1cm4gdGhpcy5nZXRUaWxlUmFuZ2VGb3JFeHRlbnRBbmRaKFxuICAgICAgICB0aWxlQ29vcmRFeHRlbnQsXG4gICAgICAgIHRpbGVDb29yZFswXSArIDEsXG4gICAgICAgIHRlbXBUaWxlUmFuZ2VcbiAgICAgICk7XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vdGlsZWNvb3JkLmpzXCIpLlRpbGVDb29yZH0gdGlsZUNvb3JkIFRpbGUgY29vcmRpbmF0ZS5cbiAgICogQHBhcmFtIHtudW1iZXJ9IHogSW50ZWdlciB6b29tIGxldmVsLlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL1RpbGVSYW5nZS5qc1wiKS5kZWZhdWx0fSBbdGVtcFRpbGVSYW5nZV0gVGVtcG9yYXJ5IGltcG9ydChcIi4uL1RpbGVSYW5nZS5qc1wiKS5kZWZhdWx0IG9iamVjdC5cbiAgICogQHJldHVybiB7aW1wb3J0KFwiLi4vVGlsZVJhbmdlLmpzXCIpLmRlZmF1bHR8bnVsbH0gVGlsZSByYW5nZS5cbiAgICovXG4gIGdldFRpbGVSYW5nZUZvclRpbGVDb29yZEFuZFoodGlsZUNvb3JkLCB6LCB0ZW1wVGlsZVJhbmdlKSB7XG4gICAgaWYgKHogPiB0aGlzLm1heFpvb20gfHwgeiA8IHRoaXMubWluWm9vbSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgY29uc3QgdGlsZUNvb3JkWiA9IHRpbGVDb29yZFswXTtcbiAgICBjb25zdCB0aWxlQ29vcmRYID0gdGlsZUNvb3JkWzFdO1xuICAgIGNvbnN0IHRpbGVDb29yZFkgPSB0aWxlQ29vcmRbMl07XG5cbiAgICBpZiAoeiA9PT0gdGlsZUNvb3JkWikge1xuICAgICAgcmV0dXJuIGNyZWF0ZU9yVXBkYXRlVGlsZVJhbmdlKFxuICAgICAgICB0aWxlQ29vcmRYLFxuICAgICAgICB0aWxlQ29vcmRZLFxuICAgICAgICB0aWxlQ29vcmRYLFxuICAgICAgICB0aWxlQ29vcmRZLFxuICAgICAgICB0ZW1wVGlsZVJhbmdlXG4gICAgICApO1xuICAgIH1cblxuICAgIGlmICh0aGlzLnpvb21GYWN0b3JfKSB7XG4gICAgICBjb25zdCBmYWN0b3IgPSBNYXRoLnBvdyh0aGlzLnpvb21GYWN0b3JfLCB6IC0gdGlsZUNvb3JkWik7XG4gICAgICBjb25zdCBtaW5YID0gTWF0aC5mbG9vcih0aWxlQ29vcmRYICogZmFjdG9yKTtcbiAgICAgIGNvbnN0IG1pblkgPSBNYXRoLmZsb29yKHRpbGVDb29yZFkgKiBmYWN0b3IpO1xuICAgICAgaWYgKHogPCB0aWxlQ29vcmRaKSB7XG4gICAgICAgIHJldHVybiBjcmVhdGVPclVwZGF0ZVRpbGVSYW5nZShtaW5YLCBtaW5YLCBtaW5ZLCBtaW5ZLCB0ZW1wVGlsZVJhbmdlKTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgbWF4WCA9IE1hdGguZmxvb3IoZmFjdG9yICogKHRpbGVDb29yZFggKyAxKSkgLSAxO1xuICAgICAgY29uc3QgbWF4WSA9IE1hdGguZmxvb3IoZmFjdG9yICogKHRpbGVDb29yZFkgKyAxKSkgLSAxO1xuICAgICAgcmV0dXJuIGNyZWF0ZU9yVXBkYXRlVGlsZVJhbmdlKG1pblgsIG1heFgsIG1pblksIG1heFksIHRlbXBUaWxlUmFuZ2UpO1xuICAgIH1cblxuICAgIGNvbnN0IHRpbGVDb29yZEV4dGVudCA9IHRoaXMuZ2V0VGlsZUNvb3JkRXh0ZW50KHRpbGVDb29yZCwgdGhpcy50bXBFeHRlbnRfKTtcbiAgICByZXR1cm4gdGhpcy5nZXRUaWxlUmFuZ2VGb3JFeHRlbnRBbmRaKHRpbGVDb29yZEV4dGVudCwgeiwgdGVtcFRpbGVSYW5nZSk7XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBleHRlbnQgZm9yIGEgdGlsZSByYW5nZS5cbiAgICogQHBhcmFtIHtudW1iZXJ9IHogSW50ZWdlciB6b29tIGxldmVsLlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL1RpbGVSYW5nZS5qc1wiKS5kZWZhdWx0fSB0aWxlUmFuZ2UgVGlsZSByYW5nZS5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9leHRlbnQuanNcIikuRXh0ZW50fSBbdGVtcEV4dGVudF0gVGVtcG9yYXJ5IGltcG9ydChcIi4uL2V4dGVudC5qc1wiKS5FeHRlbnQgb2JqZWN0LlxuICAgKiBAcmV0dXJuIHtpbXBvcnQoXCIuLi9leHRlbnQuanNcIikuRXh0ZW50fSBFeHRlbnQuXG4gICAqL1xuICBnZXRUaWxlUmFuZ2VFeHRlbnQoeiwgdGlsZVJhbmdlLCB0ZW1wRXh0ZW50KSB7XG4gICAgY29uc3Qgb3JpZ2luID0gdGhpcy5nZXRPcmlnaW4oeik7XG4gICAgY29uc3QgcmVzb2x1dGlvbiA9IHRoaXMuZ2V0UmVzb2x1dGlvbih6KTtcbiAgICBjb25zdCB0aWxlU2l6ZSA9IHRvU2l6ZSh0aGlzLmdldFRpbGVTaXplKHopLCB0aGlzLnRtcFNpemVfKTtcbiAgICBjb25zdCBtaW5YID0gb3JpZ2luWzBdICsgdGlsZVJhbmdlLm1pblggKiB0aWxlU2l6ZVswXSAqIHJlc29sdXRpb247XG4gICAgY29uc3QgbWF4WCA9IG9yaWdpblswXSArICh0aWxlUmFuZ2UubWF4WCArIDEpICogdGlsZVNpemVbMF0gKiByZXNvbHV0aW9uO1xuICAgIGNvbnN0IG1pblkgPSBvcmlnaW5bMV0gKyB0aWxlUmFuZ2UubWluWSAqIHRpbGVTaXplWzFdICogcmVzb2x1dGlvbjtcbiAgICBjb25zdCBtYXhZID0gb3JpZ2luWzFdICsgKHRpbGVSYW5nZS5tYXhZICsgMSkgKiB0aWxlU2l6ZVsxXSAqIHJlc29sdXRpb247XG4gICAgcmV0dXJuIGNyZWF0ZU9yVXBkYXRlKG1pblgsIG1pblksIG1heFgsIG1heFksIHRlbXBFeHRlbnQpO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCBhIHRpbGUgcmFuZ2UgZm9yIHRoZSBnaXZlbiBleHRlbnQgYW5kIGludGVnZXIgem9vbSBsZXZlbC5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9leHRlbnQuanNcIikuRXh0ZW50fSBleHRlbnQgRXh0ZW50LlxuICAgKiBAcGFyYW0ge251bWJlcn0geiBJbnRlZ2VyIHpvb20gbGV2ZWwuXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vVGlsZVJhbmdlLmpzXCIpLmRlZmF1bHR9IFt0ZW1wVGlsZVJhbmdlXSBUZW1wb3JhcnkgdGlsZSByYW5nZSBvYmplY3QuXG4gICAqIEByZXR1cm4ge2ltcG9ydChcIi4uL1RpbGVSYW5nZS5qc1wiKS5kZWZhdWx0fSBUaWxlIHJhbmdlLlxuICAgKi9cbiAgZ2V0VGlsZVJhbmdlRm9yRXh0ZW50QW5kWihleHRlbnQsIHosIHRlbXBUaWxlUmFuZ2UpIHtcbiAgICB0aGlzLmdldFRpbGVDb29yZEZvclhZQW5kWl8oZXh0ZW50WzBdLCBleHRlbnRbM10sIHosIGZhbHNlLCB0bXBUaWxlQ29vcmQpO1xuICAgIGNvbnN0IG1pblggPSB0bXBUaWxlQ29vcmRbMV07XG4gICAgY29uc3QgbWluWSA9IHRtcFRpbGVDb29yZFsyXTtcbiAgICB0aGlzLmdldFRpbGVDb29yZEZvclhZQW5kWl8oZXh0ZW50WzJdLCBleHRlbnRbMV0sIHosIHRydWUsIHRtcFRpbGVDb29yZCk7XG4gICAgY29uc3QgbWF4WCA9IHRtcFRpbGVDb29yZFsxXTtcbiAgICBjb25zdCBtYXhZID0gdG1wVGlsZUNvb3JkWzJdO1xuICAgIHJldHVybiBjcmVhdGVPclVwZGF0ZVRpbGVSYW5nZShtaW5YLCBtYXhYLCBtaW5ZLCBtYXhZLCB0ZW1wVGlsZVJhbmdlKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL3RpbGVjb29yZC5qc1wiKS5UaWxlQ29vcmR9IHRpbGVDb29yZCBUaWxlIGNvb3JkaW5hdGUuXG4gICAqIEByZXR1cm4ge2ltcG9ydChcIi4uL2Nvb3JkaW5hdGUuanNcIikuQ29vcmRpbmF0ZX0gVGlsZSBjZW50ZXIuXG4gICAqL1xuICBnZXRUaWxlQ29vcmRDZW50ZXIodGlsZUNvb3JkKSB7XG4gICAgY29uc3Qgb3JpZ2luID0gdGhpcy5nZXRPcmlnaW4odGlsZUNvb3JkWzBdKTtcbiAgICBjb25zdCByZXNvbHV0aW9uID0gdGhpcy5nZXRSZXNvbHV0aW9uKHRpbGVDb29yZFswXSk7XG4gICAgY29uc3QgdGlsZVNpemUgPSB0b1NpemUodGhpcy5nZXRUaWxlU2l6ZSh0aWxlQ29vcmRbMF0pLCB0aGlzLnRtcFNpemVfKTtcbiAgICByZXR1cm4gW1xuICAgICAgb3JpZ2luWzBdICsgKHRpbGVDb29yZFsxXSArIDAuNSkgKiB0aWxlU2l6ZVswXSAqIHJlc29sdXRpb24sXG4gICAgICBvcmlnaW5bMV0gLSAodGlsZUNvb3JkWzJdICsgMC41KSAqIHRpbGVTaXplWzFdICogcmVzb2x1dGlvbixcbiAgICBdO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgZXh0ZW50IG9mIGEgdGlsZSBjb29yZGluYXRlLlxuICAgKlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL3RpbGVjb29yZC5qc1wiKS5UaWxlQ29vcmR9IHRpbGVDb29yZCBUaWxlIGNvb3JkaW5hdGUuXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vZXh0ZW50LmpzXCIpLkV4dGVudH0gW3RlbXBFeHRlbnRdIFRlbXBvcmFyeSBleHRlbnQgb2JqZWN0LlxuICAgKiBAcmV0dXJuIHtpbXBvcnQoXCIuLi9leHRlbnQuanNcIikuRXh0ZW50fSBFeHRlbnQuXG4gICAqIEBhcGlcbiAgICovXG4gIGdldFRpbGVDb29yZEV4dGVudCh0aWxlQ29vcmQsIHRlbXBFeHRlbnQpIHtcbiAgICBjb25zdCBvcmlnaW4gPSB0aGlzLmdldE9yaWdpbih0aWxlQ29vcmRbMF0pO1xuICAgIGNvbnN0IHJlc29sdXRpb24gPSB0aGlzLmdldFJlc29sdXRpb24odGlsZUNvb3JkWzBdKTtcbiAgICBjb25zdCB0aWxlU2l6ZSA9IHRvU2l6ZSh0aGlzLmdldFRpbGVTaXplKHRpbGVDb29yZFswXSksIHRoaXMudG1wU2l6ZV8pO1xuICAgIGNvbnN0IG1pblggPSBvcmlnaW5bMF0gKyB0aWxlQ29vcmRbMV0gKiB0aWxlU2l6ZVswXSAqIHJlc29sdXRpb247XG4gICAgY29uc3QgbWluWSA9IG9yaWdpblsxXSAtICh0aWxlQ29vcmRbMl0gKyAxKSAqIHRpbGVTaXplWzFdICogcmVzb2x1dGlvbjtcbiAgICBjb25zdCBtYXhYID0gbWluWCArIHRpbGVTaXplWzBdICogcmVzb2x1dGlvbjtcbiAgICBjb25zdCBtYXhZID0gbWluWSArIHRpbGVTaXplWzFdICogcmVzb2x1dGlvbjtcbiAgICByZXR1cm4gY3JlYXRlT3JVcGRhdGUobWluWCwgbWluWSwgbWF4WCwgbWF4WSwgdGVtcEV4dGVudCk7XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSB0aWxlIGNvb3JkaW5hdGUgZm9yIHRoZSBnaXZlbiBtYXAgY29vcmRpbmF0ZSBhbmQgcmVzb2x1dGlvbi4gIFRoaXNcbiAgICogbWV0aG9kIGNvbnNpZGVycyB0aGF0IGNvb3JkaW5hdGVzIHRoYXQgaW50ZXJzZWN0IHRpbGUgYm91bmRhcmllcyBzaG91bGQgYmVcbiAgICogYXNzaWduZWQgdGhlIGhpZ2hlciB0aWxlIGNvb3JkaW5hdGUuXG4gICAqXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vY29vcmRpbmF0ZS5qc1wiKS5Db29yZGluYXRlfSBjb29yZGluYXRlIENvb3JkaW5hdGUuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSByZXNvbHV0aW9uIFJlc29sdXRpb24uXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vdGlsZWNvb3JkLmpzXCIpLlRpbGVDb29yZH0gW29wdF90aWxlQ29vcmRdIERlc3RpbmF0aW9uIGltcG9ydChcIi4uL3RpbGVjb29yZC5qc1wiKS5UaWxlQ29vcmQgb2JqZWN0LlxuICAgKiBAcmV0dXJuIHtpbXBvcnQoXCIuLi90aWxlY29vcmQuanNcIikuVGlsZUNvb3JkfSBUaWxlIGNvb3JkaW5hdGUuXG4gICAqIEBhcGlcbiAgICovXG4gIGdldFRpbGVDb29yZEZvckNvb3JkQW5kUmVzb2x1dGlvbihjb29yZGluYXRlLCByZXNvbHV0aW9uLCBvcHRfdGlsZUNvb3JkKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0VGlsZUNvb3JkRm9yWFlBbmRSZXNvbHV0aW9uXyhcbiAgICAgIGNvb3JkaW5hdGVbMF0sXG4gICAgICBjb29yZGluYXRlWzFdLFxuICAgICAgcmVzb2x1dGlvbixcbiAgICAgIGZhbHNlLFxuICAgICAgb3B0X3RpbGVDb29yZFxuICAgICk7XG4gIH1cblxuICAvKipcbiAgICogTm90ZSB0aGF0IHRoaXMgbWV0aG9kIHNob3VsZCBub3QgYmUgY2FsbGVkIGZvciByZXNvbHV0aW9ucyB0aGF0IGNvcnJlc3BvbmRcbiAgICogdG8gYW4gaW50ZWdlciB6b29tIGxldmVsLiAgSW5zdGVhZCBjYWxsIHRoZSBgZ2V0VGlsZUNvb3JkRm9yWFlBbmRaX2AgbWV0aG9kLlxuICAgKiBAcGFyYW0ge251bWJlcn0geCBYLlxuICAgKiBAcGFyYW0ge251bWJlcn0geSBZLlxuICAgKiBAcGFyYW0ge251bWJlcn0gcmVzb2x1dGlvbiBSZXNvbHV0aW9uIChmb3IgYSBub24taW50ZWdlciB6b29tIGxldmVsKS5cbiAgICogQHBhcmFtIHtib29sZWFufSByZXZlcnNlSW50ZXJzZWN0aW9uUG9saWN5IEluc3RlYWQgb2YgbGV0dGluZyBlZGdlXG4gICAqICAgICBpbnRlcnNlY3Rpb25zIGdvIHRvIHRoZSBoaWdoZXIgdGlsZSBjb29yZGluYXRlLCBsZXQgZWRnZSBpbnRlcnNlY3Rpb25zXG4gICAqICAgICBnbyB0byB0aGUgbG93ZXIgdGlsZSBjb29yZGluYXRlLlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL3RpbGVjb29yZC5qc1wiKS5UaWxlQ29vcmR9IFtvcHRfdGlsZUNvb3JkXSBUZW1wb3JhcnkgaW1wb3J0KFwiLi4vdGlsZWNvb3JkLmpzXCIpLlRpbGVDb29yZCBvYmplY3QuXG4gICAqIEByZXR1cm4ge2ltcG9ydChcIi4uL3RpbGVjb29yZC5qc1wiKS5UaWxlQ29vcmR9IFRpbGUgY29vcmRpbmF0ZS5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIGdldFRpbGVDb29yZEZvclhZQW5kUmVzb2x1dGlvbl8oXG4gICAgeCxcbiAgICB5LFxuICAgIHJlc29sdXRpb24sXG4gICAgcmV2ZXJzZUludGVyc2VjdGlvblBvbGljeSxcbiAgICBvcHRfdGlsZUNvb3JkXG4gICkge1xuICAgIGNvbnN0IHogPSB0aGlzLmdldFpGb3JSZXNvbHV0aW9uKHJlc29sdXRpb24pO1xuICAgIGNvbnN0IHNjYWxlID0gcmVzb2x1dGlvbiAvIHRoaXMuZ2V0UmVzb2x1dGlvbih6KTtcbiAgICBjb25zdCBvcmlnaW4gPSB0aGlzLmdldE9yaWdpbih6KTtcbiAgICBjb25zdCB0aWxlU2l6ZSA9IHRvU2l6ZSh0aGlzLmdldFRpbGVTaXplKHopLCB0aGlzLnRtcFNpemVfKTtcblxuICAgIGxldCB0aWxlQ29vcmRYID0gKHNjYWxlICogKHggLSBvcmlnaW5bMF0pKSAvIHJlc29sdXRpb24gLyB0aWxlU2l6ZVswXTtcbiAgICBsZXQgdGlsZUNvb3JkWSA9IChzY2FsZSAqIChvcmlnaW5bMV0gLSB5KSkgLyByZXNvbHV0aW9uIC8gdGlsZVNpemVbMV07XG5cbiAgICBpZiAocmV2ZXJzZUludGVyc2VjdGlvblBvbGljeSkge1xuICAgICAgdGlsZUNvb3JkWCA9IGNlaWwodGlsZUNvb3JkWCwgREVDSU1BTFMpIC0gMTtcbiAgICAgIHRpbGVDb29yZFkgPSBjZWlsKHRpbGVDb29yZFksIERFQ0lNQUxTKSAtIDE7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRpbGVDb29yZFggPSBmbG9vcih0aWxlQ29vcmRYLCBERUNJTUFMUyk7XG4gICAgICB0aWxlQ29vcmRZID0gZmxvb3IodGlsZUNvb3JkWSwgREVDSU1BTFMpO1xuICAgIH1cblxuICAgIHJldHVybiBjcmVhdGVPclVwZGF0ZVRpbGVDb29yZCh6LCB0aWxlQ29vcmRYLCB0aWxlQ29vcmRZLCBvcHRfdGlsZUNvb3JkKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBbHRob3VnaCB0aGVyZSBpcyByZXBldGl0aW9uIGJldHdlZW4gdGhpcyBtZXRob2QgYW5kIGBnZXRUaWxlQ29vcmRGb3JYWUFuZFJlc29sdXRpb25fYCxcbiAgICogdGhleSBzaG91bGQgaGF2ZSBzZXBhcmF0ZSBpbXBsZW1lbnRhdGlvbnMuICBUaGlzIG1ldGhvZCBpcyBmb3IgaW50ZWdlciB6b29tXG4gICAqIGxldmVscy4gIFRoZSBvdGhlciBtZXRob2Qgc2hvdWxkIG9ubHkgYmUgY2FsbGVkIGZvciByZXNvbHV0aW9ucyBjb3JyZXNwb25kaW5nXG4gICAqIHRvIG5vbi1pbnRlZ2VyIHpvb20gbGV2ZWxzLlxuICAgKiBAcGFyYW0ge251bWJlcn0geCBNYXAgeCBjb29yZGluYXRlLlxuICAgKiBAcGFyYW0ge251bWJlcn0geSBNYXAgeSBjb29yZGluYXRlLlxuICAgKiBAcGFyYW0ge251bWJlcn0geiBJbnRlZ2VyIHpvb20gbGV2ZWwuXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gcmV2ZXJzZUludGVyc2VjdGlvblBvbGljeSBJbnN0ZWFkIG9mIGxldHRpbmcgZWRnZVxuICAgKiAgICAgaW50ZXJzZWN0aW9ucyBnbyB0byB0aGUgaGlnaGVyIHRpbGUgY29vcmRpbmF0ZSwgbGV0IGVkZ2UgaW50ZXJzZWN0aW9uc1xuICAgKiAgICAgZ28gdG8gdGhlIGxvd2VyIHRpbGUgY29vcmRpbmF0ZS5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi90aWxlY29vcmQuanNcIikuVGlsZUNvb3JkfSBbb3B0X3RpbGVDb29yZF0gVGVtcG9yYXJ5IGltcG9ydChcIi4uL3RpbGVjb29yZC5qc1wiKS5UaWxlQ29vcmQgb2JqZWN0LlxuICAgKiBAcmV0dXJuIHtpbXBvcnQoXCIuLi90aWxlY29vcmQuanNcIikuVGlsZUNvb3JkfSBUaWxlIGNvb3JkaW5hdGUuXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBnZXRUaWxlQ29vcmRGb3JYWUFuZFpfKHgsIHksIHosIHJldmVyc2VJbnRlcnNlY3Rpb25Qb2xpY3ksIG9wdF90aWxlQ29vcmQpIHtcbiAgICBjb25zdCBvcmlnaW4gPSB0aGlzLmdldE9yaWdpbih6KTtcbiAgICBjb25zdCByZXNvbHV0aW9uID0gdGhpcy5nZXRSZXNvbHV0aW9uKHopO1xuICAgIGNvbnN0IHRpbGVTaXplID0gdG9TaXplKHRoaXMuZ2V0VGlsZVNpemUoeiksIHRoaXMudG1wU2l6ZV8pO1xuXG4gICAgbGV0IHRpbGVDb29yZFggPSAoeCAtIG9yaWdpblswXSkgLyByZXNvbHV0aW9uIC8gdGlsZVNpemVbMF07XG4gICAgbGV0IHRpbGVDb29yZFkgPSAob3JpZ2luWzFdIC0geSkgLyByZXNvbHV0aW9uIC8gdGlsZVNpemVbMV07XG5cbiAgICBpZiAocmV2ZXJzZUludGVyc2VjdGlvblBvbGljeSkge1xuICAgICAgdGlsZUNvb3JkWCA9IGNlaWwodGlsZUNvb3JkWCwgREVDSU1BTFMpIC0gMTtcbiAgICAgIHRpbGVDb29yZFkgPSBjZWlsKHRpbGVDb29yZFksIERFQ0lNQUxTKSAtIDE7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRpbGVDb29yZFggPSBmbG9vcih0aWxlQ29vcmRYLCBERUNJTUFMUyk7XG4gICAgICB0aWxlQ29vcmRZID0gZmxvb3IodGlsZUNvb3JkWSwgREVDSU1BTFMpO1xuICAgIH1cblxuICAgIHJldHVybiBjcmVhdGVPclVwZGF0ZVRpbGVDb29yZCh6LCB0aWxlQ29vcmRYLCB0aWxlQ29vcmRZLCBvcHRfdGlsZUNvb3JkKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgYSB0aWxlIGNvb3JkaW5hdGUgZ2l2ZW4gYSBtYXAgY29vcmRpbmF0ZSBhbmQgem9vbSBsZXZlbC5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9jb29yZGluYXRlLmpzXCIpLkNvb3JkaW5hdGV9IGNvb3JkaW5hdGUgQ29vcmRpbmF0ZS5cbiAgICogQHBhcmFtIHtudW1iZXJ9IHogWm9vbSBsZXZlbC5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi90aWxlY29vcmQuanNcIikuVGlsZUNvb3JkfSBbb3B0X3RpbGVDb29yZF0gRGVzdGluYXRpb24gaW1wb3J0KFwiLi4vdGlsZWNvb3JkLmpzXCIpLlRpbGVDb29yZCBvYmplY3QuXG4gICAqIEByZXR1cm4ge2ltcG9ydChcIi4uL3RpbGVjb29yZC5qc1wiKS5UaWxlQ29vcmR9IFRpbGUgY29vcmRpbmF0ZS5cbiAgICogQGFwaVxuICAgKi9cbiAgZ2V0VGlsZUNvb3JkRm9yQ29vcmRBbmRaKGNvb3JkaW5hdGUsIHosIG9wdF90aWxlQ29vcmQpIHtcbiAgICByZXR1cm4gdGhpcy5nZXRUaWxlQ29vcmRGb3JYWUFuZFpfKFxuICAgICAgY29vcmRpbmF0ZVswXSxcbiAgICAgIGNvb3JkaW5hdGVbMV0sXG4gICAgICB6LFxuICAgICAgZmFsc2UsXG4gICAgICBvcHRfdGlsZUNvb3JkXG4gICAgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL3RpbGVjb29yZC5qc1wiKS5UaWxlQ29vcmR9IHRpbGVDb29yZCBUaWxlIGNvb3JkaW5hdGUuXG4gICAqIEByZXR1cm4ge251bWJlcn0gVGlsZSByZXNvbHV0aW9uLlxuICAgKi9cbiAgZ2V0VGlsZUNvb3JkUmVzb2x1dGlvbih0aWxlQ29vcmQpIHtcbiAgICByZXR1cm4gdGhpcy5yZXNvbHV0aW9uc19bdGlsZUNvb3JkWzBdXTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIHRpbGUgc2l6ZSBmb3IgYSB6b29tIGxldmVsLiBUaGUgdHlwZSBvZiB0aGUgcmV0dXJuIHZhbHVlIG1hdGNoZXMgdGhlXG4gICAqIGB0aWxlU2l6ZWAgb3IgYHRpbGVTaXplc2AgdGhhdCB0aGUgdGlsZSBncmlkIHdhcyBjb25maWd1cmVkIHdpdGguIFRvIGFsd2F5c1xuICAgKiBnZXQgYW4ge0BsaW5rIGltcG9ydChcIi4uL3NpemUuanNcIikuU2l6ZX0sIHJ1biB0aGUgcmVzdWx0IHRocm91Z2gge0BsaW5rIG1vZHVsZTpvbC9zaXplLnRvU2l6ZX0uXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB6IFouXG4gICAqIEByZXR1cm4ge251bWJlcnxpbXBvcnQoXCIuLi9zaXplLmpzXCIpLlNpemV9IFRpbGUgc2l6ZS5cbiAgICogQGFwaVxuICAgKi9cbiAgZ2V0VGlsZVNpemUoeikge1xuICAgIGlmICh0aGlzLnRpbGVTaXplXykge1xuICAgICAgcmV0dXJuIHRoaXMudGlsZVNpemVfO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy50aWxlU2l6ZXNfW3pdO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB6IFpvb20gbGV2ZWwuXG4gICAqIEByZXR1cm4ge2ltcG9ydChcIi4uL1RpbGVSYW5nZS5qc1wiKS5kZWZhdWx0fSBFeHRlbnQgdGlsZSByYW5nZSBmb3IgdGhlIHNwZWNpZmllZCB6b29tIGxldmVsLlxuICAgKi9cbiAgZ2V0RnVsbFRpbGVSYW5nZSh6KSB7XG4gICAgaWYgKCF0aGlzLmZ1bGxUaWxlUmFuZ2VzXykge1xuICAgICAgcmV0dXJuIHRoaXMuZXh0ZW50X1xuICAgICAgICA/IHRoaXMuZ2V0VGlsZVJhbmdlRm9yRXh0ZW50QW5kWih0aGlzLmV4dGVudF8sIHopXG4gICAgICAgIDogbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuZnVsbFRpbGVSYW5nZXNfW3pdO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSByZXNvbHV0aW9uIFJlc29sdXRpb24uXG4gICAqIEBwYXJhbSB7bnVtYmVyfGltcG9ydChcIi4uL2FycmF5LmpzXCIpLk5lYXJlc3REaXJlY3Rpb25GdW5jdGlvbn0gW29wdF9kaXJlY3Rpb25dXG4gICAqICAgICBJZiAwLCB0aGUgbmVhcmVzdCByZXNvbHV0aW9uIHdpbGwgYmUgdXNlZC5cbiAgICogICAgIElmIDEsIHRoZSBuZWFyZXN0IGhpZ2hlciByZXNvbHV0aW9uIChsb3dlciBaKSB3aWxsIGJlIHVzZWQuIElmIC0xLCB0aGVcbiAgICogICAgIG5lYXJlc3QgbG93ZXIgcmVzb2x1dGlvbiAoaGlnaGVyIFopIHdpbGwgYmUgdXNlZC4gRGVmYXVsdCBpcyAwLlxuICAgKiAgICAgVXNlIGEge0BsaW5rIG1vZHVsZTpvbC9hcnJheX5OZWFyZXN0RGlyZWN0aW9uRnVuY3Rpb259IGZvciBtb3JlIHByZWNpc2UgY29udHJvbC5cbiAgICpcbiAgICogRm9yIGV4YW1wbGUgdG8gY2hhbmdlIHRpbGUgWiBhdCB0aGUgbWlkcG9pbnQgb2Ygem9vbSBsZXZlbHNcbiAgICogYGBganNcbiAgICogZnVuY3Rpb24odmFsdWUsIGhpZ2gsIGxvdykge1xuICAgKiAgIHJldHVybiB2YWx1ZSAtIGxvdyAqIE1hdGguc3FydChoaWdoIC8gbG93KTtcbiAgICogfVxuICAgKiBgYGBcbiAgICogQHJldHVybiB7bnVtYmVyfSBaLlxuICAgKiBAYXBpXG4gICAqL1xuICBnZXRaRm9yUmVzb2x1dGlvbihyZXNvbHV0aW9uLCBvcHRfZGlyZWN0aW9uKSB7XG4gICAgY29uc3QgeiA9IGxpbmVhckZpbmROZWFyZXN0KFxuICAgICAgdGhpcy5yZXNvbHV0aW9uc18sXG4gICAgICByZXNvbHV0aW9uLFxuICAgICAgb3B0X2RpcmVjdGlvbiB8fCAwXG4gICAgKTtcbiAgICByZXR1cm4gY2xhbXAoeiwgdGhpcy5taW5ab29tLCB0aGlzLm1heFpvb20pO1xuICB9XG5cbiAgLyoqXG4gICAqIFRoZSB0aWxlIHdpdGggdGhlIHByb3ZpZGVkIHRpbGUgY29vcmRpbmF0ZSBpbnRlcnNlY3RzIHRoZSBnaXZlbiB2aWV3cG9ydC5cbiAgICogQHBhcmFtIHtpbXBvcnQoJy4uL3RpbGVjb29yZC5qcycpLlRpbGVDb29yZH0gdGlsZUNvb3JkIFRpbGUgY29vcmRpbmF0ZS5cbiAgICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSB2aWV3cG9ydCBWaWV3cG9ydCBhcyByZXR1cm5lZCBmcm9tIHtAbGluayBtb2R1bGU6b2wvZXh0ZW50LmdldFJvdGF0ZWRWaWV3cG9ydH0uXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IFRoZSB0aWxlIHdpdGggdGhlIHByb3ZpZGVkIHRpbGUgY29vcmRpbmF0ZSBpbnRlcnNlY3RzIHRoZSBnaXZlbiB2aWV3cG9ydC5cbiAgICovXG4gIHRpbGVDb29yZEludGVyc2VjdHNWaWV3cG9ydCh0aWxlQ29vcmQsIHZpZXdwb3J0KSB7XG4gICAgcmV0dXJuIGludGVyc2VjdHNMaW5lYXJSaW5nKFxuICAgICAgdmlld3BvcnQsXG4gICAgICAwLFxuICAgICAgdmlld3BvcnQubGVuZ3RoLFxuICAgICAgMixcbiAgICAgIHRoaXMuZ2V0VGlsZUNvb3JkRXh0ZW50KHRpbGVDb29yZClcbiAgICApO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7IWltcG9ydChcIi4uL2V4dGVudC5qc1wiKS5FeHRlbnR9IGV4dGVudCBFeHRlbnQgZm9yIHRoaXMgdGlsZSBncmlkLlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgY2FsY3VsYXRlVGlsZVJhbmdlc18oZXh0ZW50KSB7XG4gICAgY29uc3QgbGVuZ3RoID0gdGhpcy5yZXNvbHV0aW9uc18ubGVuZ3RoO1xuICAgIGNvbnN0IGZ1bGxUaWxlUmFuZ2VzID0gbmV3IEFycmF5KGxlbmd0aCk7XG4gICAgZm9yIChsZXQgeiA9IHRoaXMubWluWm9vbTsgeiA8IGxlbmd0aDsgKyt6KSB7XG4gICAgICBmdWxsVGlsZVJhbmdlc1t6XSA9IHRoaXMuZ2V0VGlsZVJhbmdlRm9yRXh0ZW50QW5kWihleHRlbnQsIHopO1xuICAgIH1cbiAgICB0aGlzLmZ1bGxUaWxlUmFuZ2VzXyA9IGZ1bGxUaWxlUmFuZ2VzO1xuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IFRpbGVHcmlkO1xuIiwiLyoqXG4gKiBAbW9kdWxlIG9sL3RpbGVncmlkXG4gKi9cbmltcG9ydCBUaWxlR3JpZCBmcm9tICcuL3RpbGVncmlkL1RpbGVHcmlkLmpzJztcbmltcG9ydCB7REVGQVVMVF9NQVhfWk9PTSwgREVGQVVMVF9USUxFX1NJWkV9IGZyb20gJy4vdGlsZWdyaWQvY29tbW9uLmpzJztcbmltcG9ydCB7TUVURVJTX1BFUl9VTklULCBnZXQgYXMgZ2V0UHJvamVjdGlvbn0gZnJvbSAnLi9wcm9qLmpzJztcbmltcG9ydCB7XG4gIGNvbnRhaW5zQ29vcmRpbmF0ZSxcbiAgY3JlYXRlT3JVcGRhdGUsXG4gIGdldENvcm5lcixcbiAgZ2V0SGVpZ2h0LFxuICBnZXRXaWR0aCxcbn0gZnJvbSAnLi9leHRlbnQuanMnO1xuaW1wb3J0IHt0b1NpemV9IGZyb20gJy4vc2l6ZS5qcyc7XG5cbi8qKlxuICogQHBhcmFtIHtpbXBvcnQoXCIuL3Byb2ovUHJvamVjdGlvbi5qc1wiKS5kZWZhdWx0fSBwcm9qZWN0aW9uIFByb2plY3Rpb24uXG4gKiBAcmV0dXJuIHshVGlsZUdyaWR9IERlZmF1bHQgdGlsZSBncmlkIGZvciB0aGVcbiAqIHBhc3NlZCBwcm9qZWN0aW9uLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0Rm9yUHJvamVjdGlvbihwcm9qZWN0aW9uKSB7XG4gIGxldCB0aWxlR3JpZCA9IHByb2plY3Rpb24uZ2V0RGVmYXVsdFRpbGVHcmlkKCk7XG4gIGlmICghdGlsZUdyaWQpIHtcbiAgICB0aWxlR3JpZCA9IGNyZWF0ZUZvclByb2plY3Rpb24ocHJvamVjdGlvbik7XG4gICAgcHJvamVjdGlvbi5zZXREZWZhdWx0VGlsZUdyaWQodGlsZUdyaWQpO1xuICB9XG4gIHJldHVybiB0aWxlR3JpZDtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge1RpbGVHcmlkfSB0aWxlR3JpZCBUaWxlIGdyaWQuXG4gKiBAcGFyYW0ge2ltcG9ydChcIi4vdGlsZWNvb3JkLmpzXCIpLlRpbGVDb29yZH0gdGlsZUNvb3JkIFRpbGUgY29vcmRpbmF0ZS5cbiAqIEBwYXJhbSB7aW1wb3J0KFwiLi9wcm9qL1Byb2plY3Rpb24uanNcIikuZGVmYXVsdH0gcHJvamVjdGlvbiBQcm9qZWN0aW9uLlxuICogQHJldHVybiB7aW1wb3J0KFwiLi90aWxlY29vcmQuanNcIikuVGlsZUNvb3JkfSBUaWxlIGNvb3JkaW5hdGUuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB3cmFwWCh0aWxlR3JpZCwgdGlsZUNvb3JkLCBwcm9qZWN0aW9uKSB7XG4gIGNvbnN0IHogPSB0aWxlQ29vcmRbMF07XG4gIGNvbnN0IGNlbnRlciA9IHRpbGVHcmlkLmdldFRpbGVDb29yZENlbnRlcih0aWxlQ29vcmQpO1xuICBjb25zdCBwcm9qZWN0aW9uRXh0ZW50ID0gZXh0ZW50RnJvbVByb2plY3Rpb24ocHJvamVjdGlvbik7XG4gIGlmICghY29udGFpbnNDb29yZGluYXRlKHByb2plY3Rpb25FeHRlbnQsIGNlbnRlcikpIHtcbiAgICBjb25zdCB3b3JsZFdpZHRoID0gZ2V0V2lkdGgocHJvamVjdGlvbkV4dGVudCk7XG4gICAgY29uc3Qgd29ybGRzQXdheSA9IE1hdGguY2VpbChcbiAgICAgIChwcm9qZWN0aW9uRXh0ZW50WzBdIC0gY2VudGVyWzBdKSAvIHdvcmxkV2lkdGhcbiAgICApO1xuICAgIGNlbnRlclswXSArPSB3b3JsZFdpZHRoICogd29ybGRzQXdheTtcbiAgICByZXR1cm4gdGlsZUdyaWQuZ2V0VGlsZUNvb3JkRm9yQ29vcmRBbmRaKGNlbnRlciwgeik7XG4gIH1cbiAgcmV0dXJuIHRpbGVDb29yZDtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge2ltcG9ydChcIi4vZXh0ZW50LmpzXCIpLkV4dGVudH0gZXh0ZW50IEV4dGVudC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbbWF4Wm9vbV0gTWF4aW11bSB6b29tIGxldmVsIChkZWZhdWx0IGlzXG4gKiAgICAgREVGQVVMVF9NQVhfWk9PTSkuXG4gKiBAcGFyYW0ge251bWJlcnxpbXBvcnQoXCIuL3NpemUuanNcIikuU2l6ZX0gW3RpbGVTaXplXSBUaWxlIHNpemUgKGRlZmF1bHQgdXNlc1xuICogICAgIERFRkFVTFRfVElMRV9TSVpFKS5cbiAqIEBwYXJhbSB7aW1wb3J0KFwiLi9leHRlbnQuanNcIikuQ29ybmVyfSBbY29ybmVyXSBFeHRlbnQgY29ybmVyIChkZWZhdWx0IGlzIGAndG9wLWxlZnQnYCkuXG4gKiBAcmV0dXJuIHshVGlsZUdyaWR9IFRpbGVHcmlkIGluc3RhbmNlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlRm9yRXh0ZW50KGV4dGVudCwgbWF4Wm9vbSwgdGlsZVNpemUsIGNvcm5lcikge1xuICBjb3JuZXIgPSBjb3JuZXIgIT09IHVuZGVmaW5lZCA/IGNvcm5lciA6ICd0b3AtbGVmdCc7XG5cbiAgY29uc3QgcmVzb2x1dGlvbnMgPSByZXNvbHV0aW9uc0Zyb21FeHRlbnQoZXh0ZW50LCBtYXhab29tLCB0aWxlU2l6ZSk7XG5cbiAgcmV0dXJuIG5ldyBUaWxlR3JpZCh7XG4gICAgZXh0ZW50OiBleHRlbnQsXG4gICAgb3JpZ2luOiBnZXRDb3JuZXIoZXh0ZW50LCBjb3JuZXIpLFxuICAgIHJlc29sdXRpb25zOiByZXNvbHV0aW9ucyxcbiAgICB0aWxlU2l6ZTogdGlsZVNpemUsXG4gIH0pO1xufVxuXG4vKipcbiAqIEB0eXBlZGVmIHtPYmplY3R9IFhZWk9wdGlvbnNcbiAqIEBwcm9wZXJ0eSB7aW1wb3J0KFwiLi9leHRlbnQuanNcIikuRXh0ZW50fSBbZXh0ZW50XSBFeHRlbnQgZm9yIHRoZSB0aWxlIGdyaWQuIFRoZSBvcmlnaW4gZm9yIGFuIFhZWiB0aWxlIGdyaWQgaXMgdGhlXG4gKiB0b3AtbGVmdCBjb3JuZXIgb2YgdGhlIGV4dGVudC4gSWYgYG1heFJlc29sdXRpb25gIGlzIG5vdCBwcm92aWRlZCB0aGUgemVybyBsZXZlbCBvZiB0aGUgZ3JpZCBpcyBkZWZpbmVkIGJ5IHRoZSByZXNvbHV0aW9uXG4gKiBhdCB3aGljaCBvbmUgdGlsZSBmaXRzIGluIHRoZSBwcm92aWRlZCBleHRlbnQuIElmIG5vdCBwcm92aWRlZCwgdGhlIGV4dGVudCBvZiB0aGUgRVBTRzozODU3IHByb2plY3Rpb24gaXMgdXNlZC5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbbWF4UmVzb2x1dGlvbl0gUmVzb2x1dGlvbiBhdCBsZXZlbCB6ZXJvLlxuICogQHByb3BlcnR5IHtudW1iZXJ9IFttYXhab29tXSBNYXhpbXVtIHpvb20uIFRoZSBkZWZhdWx0IGlzIGA0MmAuIFRoaXMgZGV0ZXJtaW5lcyB0aGUgbnVtYmVyIG9mIGxldmVsc1xuICogaW4gdGhlIGdyaWQgc2V0LiBGb3IgZXhhbXBsZSwgYSBgbWF4Wm9vbWAgb2YgMjEgbWVhbnMgdGhlcmUgYXJlIDIyIGxldmVscyBpbiB0aGUgZ3JpZCBzZXQuXG4gKiBAcHJvcGVydHkge251bWJlcn0gW21pblpvb209MF0gTWluaW11bSB6b29tLlxuICogQHByb3BlcnR5IHtudW1iZXJ8aW1wb3J0KFwiLi9zaXplLmpzXCIpLlNpemV9IFt0aWxlU2l6ZT1bMjU2LCAyNTZdXSBUaWxlIHNpemUgaW4gcGl4ZWxzLlxuICovXG5cbi8qKlxuICogQ3JlYXRlcyBhIHRpbGUgZ3JpZCB3aXRoIGEgc3RhbmRhcmQgWFlaIHRpbGluZyBzY2hlbWUuXG4gKiBAcGFyYW0ge1hZWk9wdGlvbnN9IFtvcHRpb25zXSBUaWxlIGdyaWQgb3B0aW9ucy5cbiAqIEByZXR1cm4geyFUaWxlR3JpZH0gVGlsZSBncmlkIGluc3RhbmNlLlxuICogQGFwaVxuICovXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlWFlaKG9wdGlvbnMpIHtcbiAgY29uc3QgeHl6T3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgY29uc3QgZXh0ZW50ID0geHl6T3B0aW9ucy5leHRlbnQgfHwgZ2V0UHJvamVjdGlvbignRVBTRzozODU3JykuZ2V0RXh0ZW50KCk7XG5cbiAgY29uc3QgZ3JpZE9wdGlvbnMgPSB7XG4gICAgZXh0ZW50OiBleHRlbnQsXG4gICAgbWluWm9vbTogeHl6T3B0aW9ucy5taW5ab29tLFxuICAgIHRpbGVTaXplOiB4eXpPcHRpb25zLnRpbGVTaXplLFxuICAgIHJlc29sdXRpb25zOiByZXNvbHV0aW9uc0Zyb21FeHRlbnQoXG4gICAgICBleHRlbnQsXG4gICAgICB4eXpPcHRpb25zLm1heFpvb20sXG4gICAgICB4eXpPcHRpb25zLnRpbGVTaXplLFxuICAgICAgeHl6T3B0aW9ucy5tYXhSZXNvbHV0aW9uXG4gICAgKSxcbiAgfTtcbiAgcmV0dXJuIG5ldyBUaWxlR3JpZChncmlkT3B0aW9ucyk7XG59XG5cbi8qKlxuICogQ3JlYXRlIGEgcmVzb2x1dGlvbnMgYXJyYXkgZnJvbSBhbiBleHRlbnQuICBBIHpvb20gZmFjdG9yIG9mIDIgaXMgYXNzdW1lZC5cbiAqIEBwYXJhbSB7aW1wb3J0KFwiLi9leHRlbnQuanNcIikuRXh0ZW50fSBleHRlbnQgRXh0ZW50LlxuICogQHBhcmFtIHtudW1iZXJ9IFttYXhab29tXSBNYXhpbXVtIHpvb20gbGV2ZWwgKGRlZmF1bHQgaXNcbiAqICAgICBERUZBVUxUX01BWF9aT09NKS5cbiAqIEBwYXJhbSB7bnVtYmVyfGltcG9ydChcIi4vc2l6ZS5qc1wiKS5TaXplfSBbdGlsZVNpemVdIFRpbGUgc2l6ZSAoZGVmYXVsdCB1c2VzXG4gKiAgICAgREVGQVVMVF9USUxFX1NJWkUpLlxuICogQHBhcmFtIHtudW1iZXJ9IFttYXhSZXNvbHV0aW9uXSBSZXNvbHV0aW9uIGF0IGxldmVsIHplcm8uXG4gKiBAcmV0dXJuIHshQXJyYXk8bnVtYmVyPn0gUmVzb2x1dGlvbnMgYXJyYXkuXG4gKi9cbmZ1bmN0aW9uIHJlc29sdXRpb25zRnJvbUV4dGVudChleHRlbnQsIG1heFpvb20sIHRpbGVTaXplLCBtYXhSZXNvbHV0aW9uKSB7XG4gIG1heFpvb20gPSBtYXhab29tICE9PSB1bmRlZmluZWQgPyBtYXhab29tIDogREVGQVVMVF9NQVhfWk9PTTtcbiAgdGlsZVNpemUgPSB0b1NpemUodGlsZVNpemUgIT09IHVuZGVmaW5lZCA/IHRpbGVTaXplIDogREVGQVVMVF9USUxFX1NJWkUpO1xuXG4gIGNvbnN0IGhlaWdodCA9IGdldEhlaWdodChleHRlbnQpO1xuICBjb25zdCB3aWR0aCA9IGdldFdpZHRoKGV4dGVudCk7XG5cbiAgbWF4UmVzb2x1dGlvbiA9XG4gICAgbWF4UmVzb2x1dGlvbiA+IDBcbiAgICAgID8gbWF4UmVzb2x1dGlvblxuICAgICAgOiBNYXRoLm1heCh3aWR0aCAvIHRpbGVTaXplWzBdLCBoZWlnaHQgLyB0aWxlU2l6ZVsxXSk7XG5cbiAgY29uc3QgbGVuZ3RoID0gbWF4Wm9vbSArIDE7XG4gIGNvbnN0IHJlc29sdXRpb25zID0gbmV3IEFycmF5KGxlbmd0aCk7XG4gIGZvciAobGV0IHogPSAwOyB6IDwgbGVuZ3RoOyArK3opIHtcbiAgICByZXNvbHV0aW9uc1t6XSA9IG1heFJlc29sdXRpb24gLyBNYXRoLnBvdygyLCB6KTtcbiAgfVxuICByZXR1cm4gcmVzb2x1dGlvbnM7XG59XG5cbi8qKlxuICogQHBhcmFtIHtpbXBvcnQoXCIuL3Byb2ouanNcIikuUHJvamVjdGlvbkxpa2V9IHByb2plY3Rpb24gUHJvamVjdGlvbi5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbbWF4Wm9vbV0gTWF4aW11bSB6b29tIGxldmVsIChkZWZhdWx0IGlzXG4gKiAgICAgREVGQVVMVF9NQVhfWk9PTSkuXG4gKiBAcGFyYW0ge251bWJlcnxpbXBvcnQoXCIuL3NpemUuanNcIikuU2l6ZX0gW3RpbGVTaXplXSBUaWxlIHNpemUgKGRlZmF1bHQgdXNlc1xuICogICAgIERFRkFVTFRfVElMRV9TSVpFKS5cbiAqIEBwYXJhbSB7aW1wb3J0KFwiLi9leHRlbnQuanNcIikuQ29ybmVyfSBbY29ybmVyXSBFeHRlbnQgY29ybmVyIChkZWZhdWx0IGlzIGAndG9wLWxlZnQnYCkuXG4gKiBAcmV0dXJuIHshVGlsZUdyaWR9IFRpbGVHcmlkIGluc3RhbmNlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlRm9yUHJvamVjdGlvbihwcm9qZWN0aW9uLCBtYXhab29tLCB0aWxlU2l6ZSwgY29ybmVyKSB7XG4gIGNvbnN0IGV4dGVudCA9IGV4dGVudEZyb21Qcm9qZWN0aW9uKHByb2plY3Rpb24pO1xuICByZXR1cm4gY3JlYXRlRm9yRXh0ZW50KGV4dGVudCwgbWF4Wm9vbSwgdGlsZVNpemUsIGNvcm5lcik7XG59XG5cbi8qKlxuICogR2VuZXJhdGUgYSB0aWxlIGdyaWQgZXh0ZW50IGZyb20gYSBwcm9qZWN0aW9uLiAgSWYgdGhlIHByb2plY3Rpb24gaGFzIGFuXG4gKiBleHRlbnQsIGl0IGlzIHVzZWQuICBJZiBub3QsIGEgZ2xvYmFsIGV4dGVudCBpcyBhc3N1bWVkLlxuICogQHBhcmFtIHtpbXBvcnQoXCIuL3Byb2ouanNcIikuUHJvamVjdGlvbkxpa2V9IHByb2plY3Rpb24gUHJvamVjdGlvbi5cbiAqIEByZXR1cm4ge2ltcG9ydChcIi4vZXh0ZW50LmpzXCIpLkV4dGVudH0gRXh0ZW50LlxuICovXG5leHBvcnQgZnVuY3Rpb24gZXh0ZW50RnJvbVByb2plY3Rpb24ocHJvamVjdGlvbikge1xuICBwcm9qZWN0aW9uID0gZ2V0UHJvamVjdGlvbihwcm9qZWN0aW9uKTtcbiAgbGV0IGV4dGVudCA9IHByb2plY3Rpb24uZ2V0RXh0ZW50KCk7XG4gIGlmICghZXh0ZW50KSB7XG4gICAgY29uc3QgaGFsZiA9XG4gICAgICAoMTgwICogTUVURVJTX1BFUl9VTklULmRlZ3JlZXMpIC8gcHJvamVjdGlvbi5nZXRNZXRlcnNQZXJVbml0KCk7XG4gICAgZXh0ZW50ID0gY3JlYXRlT3JVcGRhdGUoLWhhbGYsIC1oYWxmLCBoYWxmLCBoYWxmKTtcbiAgfVxuICByZXR1cm4gZXh0ZW50O1xufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///66686\n')},94768:function(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__){eval('/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "S": function() { return /* binding */ DEFAULT_TILE_SIZE; },\n/* harmony export */   "e": function() { return /* binding */ DEFAULT_MAX_ZOOM; }\n/* harmony export */ });\n/**\n * @module ol/tilegrid/common\n */\n\n/**\n * Default maximum zoom for default tile grids.\n * @type {number}\n */\nconst DEFAULT_MAX_ZOOM = 42;\n\n/**\n * Default tile size.\n * @type {number}\n */\nconst DEFAULT_TILE_SIZE = 256;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiOTQ3NjguanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ087O0FBRVA7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNPIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdnVlMy13ZWJwYWNrNS8uL25vZGVfbW9kdWxlcy9vbC90aWxlZ3JpZC9jb21tb24uanM/YzgwNiJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBtb2R1bGUgb2wvdGlsZWdyaWQvY29tbW9uXG4gKi9cblxuLyoqXG4gKiBEZWZhdWx0IG1heGltdW0gem9vbSBmb3IgZGVmYXVsdCB0aWxlIGdyaWRzLlxuICogQHR5cGUge251bWJlcn1cbiAqL1xuZXhwb3J0IGNvbnN0IERFRkFVTFRfTUFYX1pPT00gPSA0MjtcblxuLyoqXG4gKiBEZWZhdWx0IHRpbGUgc2l6ZS5cbiAqIEB0eXBlIHtudW1iZXJ9XG4gKi9cbmV4cG9ydCBjb25zdCBERUZBVUxUX1RJTEVfU0laRSA9IDI1NjtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///94768\n')},67848:function(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__){eval('/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "Gk": function() { return /* binding */ expandUrl; },\n/* harmony export */   "uR": function() { return /* binding */ createFromTemplates; }\n/* harmony export */ });\n/* unused harmony exports createFromTemplate, createFromTileUrlFunctions, nullTileUrlFunction */\n/* harmony import */ var _asserts_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(99515);\n/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(33983);\n/* harmony import */ var _tilecoord_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(98634);\n/**\n * @module ol/tileurlfunction\n */\n\n\n\n\n/**\n * @param {string} template Template.\n * @param {import("./tilegrid/TileGrid.js").default} tileGrid Tile grid.\n * @return {import("./Tile.js").UrlFunction} Tile URL function.\n */\nfunction createFromTemplate(template, tileGrid) {\n  const zRegEx = /\\{z\\}/g;\n  const xRegEx = /\\{x\\}/g;\n  const yRegEx = /\\{y\\}/g;\n  const dashYRegEx = /\\{-y\\}/g;\n  return (\n    /**\n     * @param {import("./tilecoord.js").TileCoord} tileCoord Tile Coordinate.\n     * @param {number} pixelRatio Pixel ratio.\n     * @param {import("./proj/Projection.js").default} projection Projection.\n     * @return {string|undefined} Tile URL.\n     */\n    function (tileCoord, pixelRatio, projection) {\n      if (!tileCoord) {\n        return undefined;\n      }\n      return template\n        .replace(zRegEx, tileCoord[0].toString())\n        .replace(xRegEx, tileCoord[1].toString())\n        .replace(yRegEx, tileCoord[2].toString())\n        .replace(dashYRegEx, function () {\n          const z = tileCoord[0];\n          const range = tileGrid.getFullTileRange(z);\n          (0,_asserts_js__WEBPACK_IMPORTED_MODULE_0__/* .assert */ .h)(range, 55); // The {-y} placeholder requires a tile grid with extent\n          const y = range.getHeight() - tileCoord[2] - 1;\n          return y.toString();\n        });\n    }\n  );\n}\n\n/**\n * @param {Array<string>} templates Templates.\n * @param {import("./tilegrid/TileGrid.js").default} tileGrid Tile grid.\n * @return {import("./Tile.js").UrlFunction} Tile URL function.\n */\nfunction createFromTemplates(templates, tileGrid) {\n  const len = templates.length;\n  const tileUrlFunctions = new Array(len);\n  for (let i = 0; i < len; ++i) {\n    tileUrlFunctions[i] = createFromTemplate(templates[i], tileGrid);\n  }\n  return createFromTileUrlFunctions(tileUrlFunctions);\n}\n\n/**\n * @param {Array<import("./Tile.js").UrlFunction>} tileUrlFunctions Tile URL Functions.\n * @return {import("./Tile.js").UrlFunction} Tile URL function.\n */\nfunction createFromTileUrlFunctions(tileUrlFunctions) {\n  if (tileUrlFunctions.length === 1) {\n    return tileUrlFunctions[0];\n  }\n  return (\n    /**\n     * @param {import("./tilecoord.js").TileCoord} tileCoord Tile Coordinate.\n     * @param {number} pixelRatio Pixel ratio.\n     * @param {import("./proj/Projection.js").default} projection Projection.\n     * @return {string|undefined} Tile URL.\n     */\n    function (tileCoord, pixelRatio, projection) {\n      if (!tileCoord) {\n        return undefined;\n      }\n      const h = (0,_tilecoord_js__WEBPACK_IMPORTED_MODULE_1__/* .hash */ .vp)(tileCoord);\n      const index = (0,_math_js__WEBPACK_IMPORTED_MODULE_2__/* .modulo */ .$W)(h, tileUrlFunctions.length);\n      return tileUrlFunctions[index](tileCoord, pixelRatio, projection);\n    }\n  );\n}\n\n/**\n * @param {import("./tilecoord.js").TileCoord} tileCoord Tile coordinate.\n * @param {number} pixelRatio Pixel ratio.\n * @param {import("./proj/Projection.js").default} projection Projection.\n * @return {string|undefined} Tile URL.\n */\nfunction nullTileUrlFunction(tileCoord, pixelRatio, projection) {\n  return undefined;\n}\n\n/**\n * @param {string} url URL.\n * @return {Array<string>} Array of urls.\n */\nfunction expandUrl(url) {\n  const urls = [];\n  let match = /\\{([a-z])-([a-z])\\}/.exec(url);\n  if (match) {\n    // char range\n    const startCharCode = match[1].charCodeAt(0);\n    const stopCharCode = match[2].charCodeAt(0);\n    let charCode;\n    for (charCode = startCharCode; charCode <= stopCharCode; ++charCode) {\n      urls.push(url.replace(match[0], String.fromCharCode(charCode)));\n    }\n    return urls;\n  }\n  match = /\\{(\\d+)-(\\d+)\\}/.exec(url);\n  if (match) {\n    // number range\n    const stop = parseInt(match[2], 10);\n    for (let i = parseInt(match[1], 10); i <= stop; i++) {\n      urls.push(url.replace(match[0], i.toString()));\n    }\n    return urls;\n  }\n  urls.push(url);\n  return urls;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNjc4NDguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDb0M7QUFDSDtBQUNvQjs7QUFFckQ7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVywwQ0FBMEM7QUFDckQsWUFBWSxpQ0FBaUM7QUFDN0M7QUFDTztBQUNQLG9CQUFvQixHQUFHO0FBQ3ZCLG9CQUFvQixHQUFHO0FBQ3ZCLG9CQUFvQixHQUFHO0FBQ3ZCLHdCQUF3QixJQUFJO0FBQzVCO0FBQ0E7QUFDQSxlQUFlLG9DQUFvQztBQUNuRCxlQUFlLFFBQVE7QUFDdkIsZUFBZSx3Q0FBd0M7QUFDdkQsZ0JBQWdCLGtCQUFrQjtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLDREQUFNLGFBQWEsUUFBUSxJQUFJO0FBQ3pDO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBOztBQUVBO0FBQ0EsV0FBVyxlQUFlO0FBQzFCLFdBQVcsMENBQTBDO0FBQ3JELFlBQVksaUNBQWlDO0FBQzdDO0FBQ087QUFDUDtBQUNBO0FBQ0Esa0JBQWtCLFNBQVM7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxXQUFXLHdDQUF3QztBQUNuRCxZQUFZLGlDQUFpQztBQUM3QztBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsb0NBQW9DO0FBQ25ELGVBQWUsUUFBUTtBQUN2QixlQUFlLHdDQUF3QztBQUN2RCxnQkFBZ0Isa0JBQWtCO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsNkRBQWE7QUFDN0Isb0JBQW9CLDBEQUFNO0FBQzFCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsV0FBVyxvQ0FBb0M7QUFDL0MsV0FBVyxRQUFRO0FBQ25CLFdBQVcsd0NBQXdDO0FBQ25ELFlBQVksa0JBQWtCO0FBQzlCO0FBQ087QUFDUDtBQUNBOztBQUVBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFlBQVksZUFBZTtBQUMzQjtBQUNPO0FBQ1A7QUFDQSxpQkFBaUIsaUJBQWlCO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsMEJBQTBCO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxhQUFhO0FBQzFCO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QyxXQUFXO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdnVlMy13ZWJwYWNrNS8uL25vZGVfbW9kdWxlcy9vbC90aWxldXJsZnVuY3Rpb24uanM/ZDViMCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBtb2R1bGUgb2wvdGlsZXVybGZ1bmN0aW9uXG4gKi9cbmltcG9ydCB7YXNzZXJ0fSBmcm9tICcuL2Fzc2VydHMuanMnO1xuaW1wb3J0IHttb2R1bG99IGZyb20gJy4vbWF0aC5qcyc7XG5pbXBvcnQge2hhc2ggYXMgdGlsZUNvb3JkSGFzaH0gZnJvbSAnLi90aWxlY29vcmQuanMnO1xuXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSB0ZW1wbGF0ZSBUZW1wbGF0ZS5cbiAqIEBwYXJhbSB7aW1wb3J0KFwiLi90aWxlZ3JpZC9UaWxlR3JpZC5qc1wiKS5kZWZhdWx0fSB0aWxlR3JpZCBUaWxlIGdyaWQuXG4gKiBAcmV0dXJuIHtpbXBvcnQoXCIuL1RpbGUuanNcIikuVXJsRnVuY3Rpb259IFRpbGUgVVJMIGZ1bmN0aW9uLlxuICovXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlRnJvbVRlbXBsYXRlKHRlbXBsYXRlLCB0aWxlR3JpZCkge1xuICBjb25zdCB6UmVnRXggPSAvXFx7elxcfS9nO1xuICBjb25zdCB4UmVnRXggPSAvXFx7eFxcfS9nO1xuICBjb25zdCB5UmVnRXggPSAvXFx7eVxcfS9nO1xuICBjb25zdCBkYXNoWVJlZ0V4ID0gL1xcey15XFx9L2c7XG4gIHJldHVybiAoXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtpbXBvcnQoXCIuL3RpbGVjb29yZC5qc1wiKS5UaWxlQ29vcmR9IHRpbGVDb29yZCBUaWxlIENvb3JkaW5hdGUuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHBpeGVsUmF0aW8gUGl4ZWwgcmF0aW8uXG4gICAgICogQHBhcmFtIHtpbXBvcnQoXCIuL3Byb2ovUHJvamVjdGlvbi5qc1wiKS5kZWZhdWx0fSBwcm9qZWN0aW9uIFByb2plY3Rpb24uXG4gICAgICogQHJldHVybiB7c3RyaW5nfHVuZGVmaW5lZH0gVGlsZSBVUkwuXG4gICAgICovXG4gICAgZnVuY3Rpb24gKHRpbGVDb29yZCwgcGl4ZWxSYXRpbywgcHJvamVjdGlvbikge1xuICAgICAgaWYgKCF0aWxlQ29vcmQpIHtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0ZW1wbGF0ZVxuICAgICAgICAucmVwbGFjZSh6UmVnRXgsIHRpbGVDb29yZFswXS50b1N0cmluZygpKVxuICAgICAgICAucmVwbGFjZSh4UmVnRXgsIHRpbGVDb29yZFsxXS50b1N0cmluZygpKVxuICAgICAgICAucmVwbGFjZSh5UmVnRXgsIHRpbGVDb29yZFsyXS50b1N0cmluZygpKVxuICAgICAgICAucmVwbGFjZShkYXNoWVJlZ0V4LCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgY29uc3QgeiA9IHRpbGVDb29yZFswXTtcbiAgICAgICAgICBjb25zdCByYW5nZSA9IHRpbGVHcmlkLmdldEZ1bGxUaWxlUmFuZ2Uoeik7XG4gICAgICAgICAgYXNzZXJ0KHJhbmdlLCA1NSk7IC8vIFRoZSB7LXl9IHBsYWNlaG9sZGVyIHJlcXVpcmVzIGEgdGlsZSBncmlkIHdpdGggZXh0ZW50XG4gICAgICAgICAgY29uc3QgeSA9IHJhbmdlLmdldEhlaWdodCgpIC0gdGlsZUNvb3JkWzJdIC0gMTtcbiAgICAgICAgICByZXR1cm4geS50b1N0cmluZygpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICk7XG59XG5cbi8qKlxuICogQHBhcmFtIHtBcnJheTxzdHJpbmc+fSB0ZW1wbGF0ZXMgVGVtcGxhdGVzLlxuICogQHBhcmFtIHtpbXBvcnQoXCIuL3RpbGVncmlkL1RpbGVHcmlkLmpzXCIpLmRlZmF1bHR9IHRpbGVHcmlkIFRpbGUgZ3JpZC5cbiAqIEByZXR1cm4ge2ltcG9ydChcIi4vVGlsZS5qc1wiKS5VcmxGdW5jdGlvbn0gVGlsZSBVUkwgZnVuY3Rpb24uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVGcm9tVGVtcGxhdGVzKHRlbXBsYXRlcywgdGlsZUdyaWQpIHtcbiAgY29uc3QgbGVuID0gdGVtcGxhdGVzLmxlbmd0aDtcbiAgY29uc3QgdGlsZVVybEZ1bmN0aW9ucyA9IG5ldyBBcnJheShsZW4pO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbjsgKytpKSB7XG4gICAgdGlsZVVybEZ1bmN0aW9uc1tpXSA9IGNyZWF0ZUZyb21UZW1wbGF0ZSh0ZW1wbGF0ZXNbaV0sIHRpbGVHcmlkKTtcbiAgfVxuICByZXR1cm4gY3JlYXRlRnJvbVRpbGVVcmxGdW5jdGlvbnModGlsZVVybEZ1bmN0aW9ucyk7XG59XG5cbi8qKlxuICogQHBhcmFtIHtBcnJheTxpbXBvcnQoXCIuL1RpbGUuanNcIikuVXJsRnVuY3Rpb24+fSB0aWxlVXJsRnVuY3Rpb25zIFRpbGUgVVJMIEZ1bmN0aW9ucy5cbiAqIEByZXR1cm4ge2ltcG9ydChcIi4vVGlsZS5qc1wiKS5VcmxGdW5jdGlvbn0gVGlsZSBVUkwgZnVuY3Rpb24uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVGcm9tVGlsZVVybEZ1bmN0aW9ucyh0aWxlVXJsRnVuY3Rpb25zKSB7XG4gIGlmICh0aWxlVXJsRnVuY3Rpb25zLmxlbmd0aCA9PT0gMSkge1xuICAgIHJldHVybiB0aWxlVXJsRnVuY3Rpb25zWzBdO1xuICB9XG4gIHJldHVybiAoXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtpbXBvcnQoXCIuL3RpbGVjb29yZC5qc1wiKS5UaWxlQ29vcmR9IHRpbGVDb29yZCBUaWxlIENvb3JkaW5hdGUuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHBpeGVsUmF0aW8gUGl4ZWwgcmF0aW8uXG4gICAgICogQHBhcmFtIHtpbXBvcnQoXCIuL3Byb2ovUHJvamVjdGlvbi5qc1wiKS5kZWZhdWx0fSBwcm9qZWN0aW9uIFByb2plY3Rpb24uXG4gICAgICogQHJldHVybiB7c3RyaW5nfHVuZGVmaW5lZH0gVGlsZSBVUkwuXG4gICAgICovXG4gICAgZnVuY3Rpb24gKHRpbGVDb29yZCwgcGl4ZWxSYXRpbywgcHJvamVjdGlvbikge1xuICAgICAgaWYgKCF0aWxlQ29vcmQpIHtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGggPSB0aWxlQ29vcmRIYXNoKHRpbGVDb29yZCk7XG4gICAgICBjb25zdCBpbmRleCA9IG1vZHVsbyhoLCB0aWxlVXJsRnVuY3Rpb25zLmxlbmd0aCk7XG4gICAgICByZXR1cm4gdGlsZVVybEZ1bmN0aW9uc1tpbmRleF0odGlsZUNvb3JkLCBwaXhlbFJhdGlvLCBwcm9qZWN0aW9uKTtcbiAgICB9XG4gICk7XG59XG5cbi8qKlxuICogQHBhcmFtIHtpbXBvcnQoXCIuL3RpbGVjb29yZC5qc1wiKS5UaWxlQ29vcmR9IHRpbGVDb29yZCBUaWxlIGNvb3JkaW5hdGUuXG4gKiBAcGFyYW0ge251bWJlcn0gcGl4ZWxSYXRpbyBQaXhlbCByYXRpby5cbiAqIEBwYXJhbSB7aW1wb3J0KFwiLi9wcm9qL1Byb2plY3Rpb24uanNcIikuZGVmYXVsdH0gcHJvamVjdGlvbiBQcm9qZWN0aW9uLlxuICogQHJldHVybiB7c3RyaW5nfHVuZGVmaW5lZH0gVGlsZSBVUkwuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBudWxsVGlsZVVybEZ1bmN0aW9uKHRpbGVDb29yZCwgcGl4ZWxSYXRpbywgcHJvamVjdGlvbikge1xuICByZXR1cm4gdW5kZWZpbmVkO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSB1cmwgVVJMLlxuICogQHJldHVybiB7QXJyYXk8c3RyaW5nPn0gQXJyYXkgb2YgdXJscy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGV4cGFuZFVybCh1cmwpIHtcbiAgY29uc3QgdXJscyA9IFtdO1xuICBsZXQgbWF0Y2ggPSAvXFx7KFthLXpdKS0oW2Etel0pXFx9Ly5leGVjKHVybCk7XG4gIGlmIChtYXRjaCkge1xuICAgIC8vIGNoYXIgcmFuZ2VcbiAgICBjb25zdCBzdGFydENoYXJDb2RlID0gbWF0Y2hbMV0uY2hhckNvZGVBdCgwKTtcbiAgICBjb25zdCBzdG9wQ2hhckNvZGUgPSBtYXRjaFsyXS5jaGFyQ29kZUF0KDApO1xuICAgIGxldCBjaGFyQ29kZTtcbiAgICBmb3IgKGNoYXJDb2RlID0gc3RhcnRDaGFyQ29kZTsgY2hhckNvZGUgPD0gc3RvcENoYXJDb2RlOyArK2NoYXJDb2RlKSB7XG4gICAgICB1cmxzLnB1c2godXJsLnJlcGxhY2UobWF0Y2hbMF0sIFN0cmluZy5mcm9tQ2hhckNvZGUoY2hhckNvZGUpKSk7XG4gICAgfVxuICAgIHJldHVybiB1cmxzO1xuICB9XG4gIG1hdGNoID0gL1xceyhcXGQrKS0oXFxkKylcXH0vLmV4ZWModXJsKTtcbiAgaWYgKG1hdGNoKSB7XG4gICAgLy8gbnVtYmVyIHJhbmdlXG4gICAgY29uc3Qgc3RvcCA9IHBhcnNlSW50KG1hdGNoWzJdLCAxMCk7XG4gICAgZm9yIChsZXQgaSA9IHBhcnNlSW50KG1hdGNoWzFdLCAxMCk7IGkgPD0gc3RvcDsgaSsrKSB7XG4gICAgICB1cmxzLnB1c2godXJsLnJlcGxhY2UobWF0Y2hbMF0sIGkudG9TdHJpbmcoKSkpO1xuICAgIH1cbiAgICByZXR1cm4gdXJscztcbiAgfVxuICB1cmxzLnB1c2godXJsKTtcbiAgcmV0dXJuIHVybHM7XG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///67848\n')},6101:function(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__){eval('/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "BB": function() { return /* binding */ toString; },\n/* harmony export */   "Ue": function() { return /* binding */ create; },\n/* harmony export */   "lk": function() { return /* binding */ setFromArray; },\n/* harmony export */   "n3": function() { return /* binding */ makeScale; },\n/* harmony export */   "nb": function() { return /* binding */ makeInverse; },\n/* harmony export */   "nn": function() { return /* binding */ apply; },\n/* harmony export */   "qC": function() { return /* binding */ compose; }\n/* harmony export */ });\n/* unused harmony exports reset, multiply, set, rotate, scale, translate, composeCssTransform, invert, determinant */\n/* harmony import */ var _has_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(40177);\n/* harmony import */ var _asserts_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(99515);\n/**\n * @module ol/transform\n */\n\n\n\n/**\n * An array representing an affine 2d transformation for use with\n * {@link module:ol/transform} functions. The array has 6 elements.\n * @typedef {!Array<number>} Transform\n * @api\n */\n\n/**\n * Collection of affine 2d transformation functions. The functions work on an\n * array of 6 elements. The element order is compatible with the [SVGMatrix\n * interface](https://developer.mozilla.org/en-US/docs/Web/API/SVGMatrix) and is\n * a subset (elements a to f) of a 3×3 matrix:\n * ```\n * [ a c e ]\n * [ b d f ]\n * [ 0 0 1 ]\n * ```\n */\n\n/**\n * @private\n * @type {Transform}\n */\nconst tmp_ = new Array(6);\n\n/**\n * Create an identity transform.\n * @return {!Transform} Identity transform.\n */\nfunction create() {\n  return [1, 0, 0, 1, 0, 0];\n}\n\n/**\n * Resets the given transform to an identity transform.\n * @param {!Transform} transform Transform.\n * @return {!Transform} Transform.\n */\nfunction reset(transform) {\n  return set(transform, 1, 0, 0, 1, 0, 0);\n}\n\n/**\n * Multiply the underlying matrices of two transforms and return the result in\n * the first transform.\n * @param {!Transform} transform1 Transform parameters of matrix 1.\n * @param {!Transform} transform2 Transform parameters of matrix 2.\n * @return {!Transform} transform1 multiplied with transform2.\n */\nfunction multiply(transform1, transform2) {\n  const a1 = transform1[0];\n  const b1 = transform1[1];\n  const c1 = transform1[2];\n  const d1 = transform1[3];\n  const e1 = transform1[4];\n  const f1 = transform1[5];\n  const a2 = transform2[0];\n  const b2 = transform2[1];\n  const c2 = transform2[2];\n  const d2 = transform2[3];\n  const e2 = transform2[4];\n  const f2 = transform2[5];\n\n  transform1[0] = a1 * a2 + c1 * b2;\n  transform1[1] = b1 * a2 + d1 * b2;\n  transform1[2] = a1 * c2 + c1 * d2;\n  transform1[3] = b1 * c2 + d1 * d2;\n  transform1[4] = a1 * e2 + c1 * f2 + e1;\n  transform1[5] = b1 * e2 + d1 * f2 + f1;\n\n  return transform1;\n}\n\n/**\n * Set the transform components a-f on a given transform.\n * @param {!Transform} transform Transform.\n * @param {number} a The a component of the transform.\n * @param {number} b The b component of the transform.\n * @param {number} c The c component of the transform.\n * @param {number} d The d component of the transform.\n * @param {number} e The e component of the transform.\n * @param {number} f The f component of the transform.\n * @return {!Transform} Matrix with transform applied.\n */\nfunction set(transform, a, b, c, d, e, f) {\n  transform[0] = a;\n  transform[1] = b;\n  transform[2] = c;\n  transform[3] = d;\n  transform[4] = e;\n  transform[5] = f;\n  return transform;\n}\n\n/**\n * Set transform on one matrix from another matrix.\n * @param {!Transform} transform1 Matrix to set transform to.\n * @param {!Transform} transform2 Matrix to set transform from.\n * @return {!Transform} transform1 with transform from transform2 applied.\n */\nfunction setFromArray(transform1, transform2) {\n  transform1[0] = transform2[0];\n  transform1[1] = transform2[1];\n  transform1[2] = transform2[2];\n  transform1[3] = transform2[3];\n  transform1[4] = transform2[4];\n  transform1[5] = transform2[5];\n  return transform1;\n}\n\n/**\n * Transforms the given coordinate with the given transform returning the\n * resulting, transformed coordinate. The coordinate will be modified in-place.\n *\n * @param {Transform} transform The transformation.\n * @param {import("./coordinate.js").Coordinate|import("./pixel.js").Pixel} coordinate The coordinate to transform.\n * @return {import("./coordinate.js").Coordinate|import("./pixel.js").Pixel} return coordinate so that operations can be\n *     chained together.\n */\nfunction apply(transform, coordinate) {\n  const x = coordinate[0];\n  const y = coordinate[1];\n  coordinate[0] = transform[0] * x + transform[2] * y + transform[4];\n  coordinate[1] = transform[1] * x + transform[3] * y + transform[5];\n  return coordinate;\n}\n\n/**\n * Applies rotation to the given transform.\n * @param {!Transform} transform Transform.\n * @param {number} angle Angle in radians.\n * @return {!Transform} The rotated transform.\n */\nfunction rotate(transform, angle) {\n  const cos = Math.cos(angle);\n  const sin = Math.sin(angle);\n  return multiply(transform, set(tmp_, cos, sin, -sin, cos, 0, 0));\n}\n\n/**\n * Applies scale to a given transform.\n * @param {!Transform} transform Transform.\n * @param {number} x Scale factor x.\n * @param {number} y Scale factor y.\n * @return {!Transform} The scaled transform.\n */\nfunction scale(transform, x, y) {\n  return multiply(transform, set(tmp_, x, 0, 0, y, 0, 0));\n}\n\n/**\n * Creates a scale transform.\n * @param {!Transform} target Transform to overwrite.\n * @param {number} x Scale factor x.\n * @param {number} y Scale factor y.\n * @return {!Transform} The scale transform.\n */\nfunction makeScale(target, x, y) {\n  return set(target, x, 0, 0, y, 0, 0);\n}\n\n/**\n * Applies translation to the given transform.\n * @param {!Transform} transform Transform.\n * @param {number} dx Translation x.\n * @param {number} dy Translation y.\n * @return {!Transform} The translated transform.\n */\nfunction translate(transform, dx, dy) {\n  return multiply(transform, set(tmp_, 1, 0, 0, 1, dx, dy));\n}\n\n/**\n * Creates a composite transform given an initial translation, scale, rotation, and\n * final translation (in that order only, not commutative).\n * @param {!Transform} transform The transform (will be modified in place).\n * @param {number} dx1 Initial translation x.\n * @param {number} dy1 Initial translation y.\n * @param {number} sx Scale factor x.\n * @param {number} sy Scale factor y.\n * @param {number} angle Rotation (in counter-clockwise radians).\n * @param {number} dx2 Final translation x.\n * @param {number} dy2 Final translation y.\n * @return {!Transform} The composite transform.\n */\nfunction compose(transform, dx1, dy1, sx, sy, angle, dx2, dy2) {\n  const sin = Math.sin(angle);\n  const cos = Math.cos(angle);\n  transform[0] = sx * cos;\n  transform[1] = sy * sin;\n  transform[2] = -sx * sin;\n  transform[3] = sy * cos;\n  transform[4] = dx2 * sx * cos - dy2 * sx * sin + dx1;\n  transform[5] = dx2 * sy * sin + dy2 * sy * cos + dy1;\n  return transform;\n}\n\n/**\n * Creates a composite transform given an initial translation, scale, rotation, and\n * final translation (in that order only, not commutative). The resulting transform\n * string can be applied as `transform` property of an HTMLElement\'s style.\n * @param {number} dx1 Initial translation x.\n * @param {number} dy1 Initial translation y.\n * @param {number} sx Scale factor x.\n * @param {number} sy Scale factor y.\n * @param {number} angle Rotation (in counter-clockwise radians).\n * @param {number} dx2 Final translation x.\n * @param {number} dy2 Final translation y.\n * @return {string} The composite css transform.\n * @api\n */\nfunction composeCssTransform(dx1, dy1, sx, sy, angle, dx2, dy2) {\n  return toString(compose(create(), dx1, dy1, sx, sy, angle, dx2, dy2));\n}\n\n/**\n * Invert the given transform.\n * @param {!Transform} source The source transform to invert.\n * @return {!Transform} The inverted (source) transform.\n */\nfunction invert(source) {\n  return makeInverse(source, source);\n}\n\n/**\n * Invert the given transform.\n * @param {!Transform} target Transform to be set as the inverse of\n *     the source transform.\n * @param {!Transform} source The source transform to invert.\n * @return {!Transform} The inverted (target) transform.\n */\nfunction makeInverse(target, source) {\n  const det = determinant(source);\n  (0,_asserts_js__WEBPACK_IMPORTED_MODULE_0__/* .assert */ .h)(det !== 0, 32); // Transformation matrix cannot be inverted\n\n  const a = source[0];\n  const b = source[1];\n  const c = source[2];\n  const d = source[3];\n  const e = source[4];\n  const f = source[5];\n\n  target[0] = d / det;\n  target[1] = -b / det;\n  target[2] = -c / det;\n  target[3] = a / det;\n  target[4] = (c * f - d * e) / det;\n  target[5] = -(a * f - b * e) / det;\n\n  return target;\n}\n\n/**\n * Returns the determinant of the given matrix.\n * @param {!Transform} mat Matrix.\n * @return {number} Determinant.\n */\nfunction determinant(mat) {\n  return mat[0] * mat[3] - mat[1] * mat[2];\n}\n\n/**\n * @type {HTMLElement}\n * @private\n */\nlet transformStringDiv;\n\n/**\n * A rounded string version of the transform.  This can be used\n * for CSS transforms.\n * @param {!Transform} mat Matrix.\n * @return {string} The transform as a string.\n */\nfunction toString(mat) {\n  const transformString = \'matrix(\' + mat.join(\', \') + \')\';\n  if (_has_js__WEBPACK_IMPORTED_MODULE_1__/* .WORKER_OFFSCREEN_CANVAS */ .Id) {\n    return transformString;\n  }\n  const node =\n    transformStringDiv || (transformStringDiv = document.createElement(\'div\'));\n  node.style.transform = transformString;\n  return node.style.transform;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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WUFBWTtBQUN2QixZQUFZLFlBQVk7QUFDeEI7QUFDTztBQUNQO0FBQ0EsRUFBRSw0REFBTSxpQkFBaUI7O0FBRXpCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxZQUFZO0FBQ3ZCLFlBQVksUUFBUTtBQUNwQjtBQUNPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxZQUFZO0FBQ3ZCLFlBQVksUUFBUTtBQUNwQjtBQUNPO0FBQ1A7QUFDQSxNQUFNLHNFQUF1QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3Z1ZTMtd2VicGFjazUvLi9ub2RlX21vZHVsZXMvb2wvdHJhbnNmb3JtLmpzP2ZiMDkiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAbW9kdWxlIG9sL3RyYW5zZm9ybVxuICovXG5pbXBvcnQge1dPUktFUl9PRkZTQ1JFRU5fQ0FOVkFTfSBmcm9tICcuL2hhcy5qcyc7XG5pbXBvcnQge2Fzc2VydH0gZnJvbSAnLi9hc3NlcnRzLmpzJztcblxuLyoqXG4gKiBBbiBhcnJheSByZXByZXNlbnRpbmcgYW4gYWZmaW5lIDJkIHRyYW5zZm9ybWF0aW9uIGZvciB1c2Ugd2l0aFxuICoge0BsaW5rIG1vZHVsZTpvbC90cmFuc2Zvcm19IGZ1bmN0aW9ucy4gVGhlIGFycmF5IGhhcyA2IGVsZW1lbnRzLlxuICogQHR5cGVkZWYgeyFBcnJheTxudW1iZXI+fSBUcmFuc2Zvcm1cbiAqIEBhcGlcbiAqL1xuXG4vKipcbiAqIENvbGxlY3Rpb24gb2YgYWZmaW5lIDJkIHRyYW5zZm9ybWF0aW9uIGZ1bmN0aW9ucy4gVGhlIGZ1bmN0aW9ucyB3b3JrIG9uIGFuXG4gKiBhcnJheSBvZiA2IGVsZW1lbnRzLiBUaGUgZWxlbWVudCBvcmRlciBpcyBjb21wYXRpYmxlIHdpdGggdGhlIFtTVkdNYXRyaXhcbiAqIGludGVyZmFjZV0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL1NWR01hdHJpeCkgYW5kIGlzXG4gKiBhIHN1YnNldCAoZWxlbWVudHMgYSB0byBmKSBvZiBhIDPDlzMgbWF0cml4OlxuICogYGBgXG4gKiBbIGEgYyBlIF1cbiAqIFsgYiBkIGYgXVxuICogWyAwIDAgMSBdXG4gKiBgYGBcbiAqL1xuXG4vKipcbiAqIEBwcml2YXRlXG4gKiBAdHlwZSB7VHJhbnNmb3JtfVxuICovXG5jb25zdCB0bXBfID0gbmV3IEFycmF5KDYpO1xuXG4vKipcbiAqIENyZWF0ZSBhbiBpZGVudGl0eSB0cmFuc2Zvcm0uXG4gKiBAcmV0dXJuIHshVHJhbnNmb3JtfSBJZGVudGl0eSB0cmFuc2Zvcm0uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGUoKSB7XG4gIHJldHVybiBbMSwgMCwgMCwgMSwgMCwgMF07XG59XG5cbi8qKlxuICogUmVzZXRzIHRoZSBnaXZlbiB0cmFuc2Zvcm0gdG8gYW4gaWRlbnRpdHkgdHJhbnNmb3JtLlxuICogQHBhcmFtIHshVHJhbnNmb3JtfSB0cmFuc2Zvcm0gVHJhbnNmb3JtLlxuICogQHJldHVybiB7IVRyYW5zZm9ybX0gVHJhbnNmb3JtLlxuICovXG5leHBvcnQgZnVuY3Rpb24gcmVzZXQodHJhbnNmb3JtKSB7XG4gIHJldHVybiBzZXQodHJhbnNmb3JtLCAxLCAwLCAwLCAxLCAwLCAwKTtcbn1cblxuLyoqXG4gKiBNdWx0aXBseSB0aGUgdW5kZXJseWluZyBtYXRyaWNlcyBvZiB0d28gdHJhbnNmb3JtcyBhbmQgcmV0dXJuIHRoZSByZXN1bHQgaW5cbiAqIHRoZSBmaXJzdCB0cmFuc2Zvcm0uXG4gKiBAcGFyYW0geyFUcmFuc2Zvcm19IHRyYW5zZm9ybTEgVHJhbnNmb3JtIHBhcmFtZXRlcnMgb2YgbWF0cml4IDEuXG4gKiBAcGFyYW0geyFUcmFuc2Zvcm19IHRyYW5zZm9ybTIgVHJhbnNmb3JtIHBhcmFtZXRlcnMgb2YgbWF0cml4IDIuXG4gKiBAcmV0dXJuIHshVHJhbnNmb3JtfSB0cmFuc2Zvcm0xIG11bHRpcGxpZWQgd2l0aCB0cmFuc2Zvcm0yLlxuICovXG5leHBvcnQgZnVuY3Rpb24gbXVsdGlwbHkodHJhbnNmb3JtMSwgdHJhbnNmb3JtMikge1xuICBjb25zdCBhMSA9IHRyYW5zZm9ybTFbMF07XG4gIGNvbnN0IGIxID0gdHJhbnNmb3JtMVsxXTtcbiAgY29uc3QgYzEgPSB0cmFuc2Zvcm0xWzJdO1xuICBjb25zdCBkMSA9IHRyYW5zZm9ybTFbM107XG4gIGNvbnN0IGUxID0gdHJhbnNmb3JtMVs0XTtcbiAgY29uc3QgZjEgPSB0cmFuc2Zvcm0xWzVdO1xuICBjb25zdCBhMiA9IHRyYW5zZm9ybTJbMF07XG4gIGNvbnN0IGIyID0gdHJhbnNmb3JtMlsxXTtcbiAgY29uc3QgYzIgPSB0cmFuc2Zvcm0yWzJdO1xuICBjb25zdCBkMiA9IHRyYW5zZm9ybTJbM107XG4gIGNvbnN0IGUyID0gdHJhbnNmb3JtMls0XTtcbiAgY29uc3QgZjIgPSB0cmFuc2Zvcm0yWzVdO1xuXG4gIHRyYW5zZm9ybTFbMF0gPSBhMSAqIGEyICsgYzEgKiBiMjtcbiAgdHJhbnNmb3JtMVsxXSA9IGIxICogYTIgKyBkMSAqIGIyO1xuICB0cmFuc2Zvcm0xWzJdID0gYTEgKiBjMiArIGMxICogZDI7XG4gIHRyYW5zZm9ybTFbM10gPSBiMSAqIGMyICsgZDEgKiBkMjtcbiAgdHJhbnNmb3JtMVs0XSA9IGExICogZTIgKyBjMSAqIGYyICsgZTE7XG4gIHRyYW5zZm9ybTFbNV0gPSBiMSAqIGUyICsgZDEgKiBmMiArIGYxO1xuXG4gIHJldHVybiB0cmFuc2Zvcm0xO1xufVxuXG4vKipcbiAqIFNldCB0aGUgdHJhbnNmb3JtIGNvbXBvbmVudHMgYS1mIG9uIGEgZ2l2ZW4gdHJhbnNmb3JtLlxuICogQHBhcmFtIHshVHJhbnNmb3JtfSB0cmFuc2Zvcm0gVHJhbnNmb3JtLlxuICogQHBhcmFtIHtudW1iZXJ9IGEgVGhlIGEgY29tcG9uZW50IG9mIHRoZSB0cmFuc2Zvcm0uXG4gKiBAcGFyYW0ge251bWJlcn0gYiBUaGUgYiBjb21wb25lbnQgb2YgdGhlIHRyYW5zZm9ybS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBjIFRoZSBjIGNvbXBvbmVudCBvZiB0aGUgdHJhbnNmb3JtLlxuICogQHBhcmFtIHtudW1iZXJ9IGQgVGhlIGQgY29tcG9uZW50IG9mIHRoZSB0cmFuc2Zvcm0uXG4gKiBAcGFyYW0ge251bWJlcn0gZSBUaGUgZSBjb21wb25lbnQgb2YgdGhlIHRyYW5zZm9ybS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBmIFRoZSBmIGNvbXBvbmVudCBvZiB0aGUgdHJhbnNmb3JtLlxuICogQHJldHVybiB7IVRyYW5zZm9ybX0gTWF0cml4IHdpdGggdHJhbnNmb3JtIGFwcGxpZWQuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzZXQodHJhbnNmb3JtLCBhLCBiLCBjLCBkLCBlLCBmKSB7XG4gIHRyYW5zZm9ybVswXSA9IGE7XG4gIHRyYW5zZm9ybVsxXSA9IGI7XG4gIHRyYW5zZm9ybVsyXSA9IGM7XG4gIHRyYW5zZm9ybVszXSA9IGQ7XG4gIHRyYW5zZm9ybVs0XSA9IGU7XG4gIHRyYW5zZm9ybVs1XSA9IGY7XG4gIHJldHVybiB0cmFuc2Zvcm07XG59XG5cbi8qKlxuICogU2V0IHRyYW5zZm9ybSBvbiBvbmUgbWF0cml4IGZyb20gYW5vdGhlciBtYXRyaXguXG4gKiBAcGFyYW0geyFUcmFuc2Zvcm19IHRyYW5zZm9ybTEgTWF0cml4IHRvIHNldCB0cmFuc2Zvcm0gdG8uXG4gKiBAcGFyYW0geyFUcmFuc2Zvcm19IHRyYW5zZm9ybTIgTWF0cml4IHRvIHNldCB0cmFuc2Zvcm0gZnJvbS5cbiAqIEByZXR1cm4geyFUcmFuc2Zvcm19IHRyYW5zZm9ybTEgd2l0aCB0cmFuc2Zvcm0gZnJvbSB0cmFuc2Zvcm0yIGFwcGxpZWQuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzZXRGcm9tQXJyYXkodHJhbnNmb3JtMSwgdHJhbnNmb3JtMikge1xuICB0cmFuc2Zvcm0xWzBdID0gdHJhbnNmb3JtMlswXTtcbiAgdHJhbnNmb3JtMVsxXSA9IHRyYW5zZm9ybTJbMV07XG4gIHRyYW5zZm9ybTFbMl0gPSB0cmFuc2Zvcm0yWzJdO1xuICB0cmFuc2Zvcm0xWzNdID0gdHJhbnNmb3JtMlszXTtcbiAgdHJhbnNmb3JtMVs0XSA9IHRyYW5zZm9ybTJbNF07XG4gIHRyYW5zZm9ybTFbNV0gPSB0cmFuc2Zvcm0yWzVdO1xuICByZXR1cm4gdHJhbnNmb3JtMTtcbn1cblxuLyoqXG4gKiBUcmFuc2Zvcm1zIHRoZSBnaXZlbiBjb29yZGluYXRlIHdpdGggdGhlIGdpdmVuIHRyYW5zZm9ybSByZXR1cm5pbmcgdGhlXG4gKiByZXN1bHRpbmcsIHRyYW5zZm9ybWVkIGNvb3JkaW5hdGUuIFRoZSBjb29yZGluYXRlIHdpbGwgYmUgbW9kaWZpZWQgaW4tcGxhY2UuXG4gKlxuICogQHBhcmFtIHtUcmFuc2Zvcm19IHRyYW5zZm9ybSBUaGUgdHJhbnNmb3JtYXRpb24uXG4gKiBAcGFyYW0ge2ltcG9ydChcIi4vY29vcmRpbmF0ZS5qc1wiKS5Db29yZGluYXRlfGltcG9ydChcIi4vcGl4ZWwuanNcIikuUGl4ZWx9IGNvb3JkaW5hdGUgVGhlIGNvb3JkaW5hdGUgdG8gdHJhbnNmb3JtLlxuICogQHJldHVybiB7aW1wb3J0KFwiLi9jb29yZGluYXRlLmpzXCIpLkNvb3JkaW5hdGV8aW1wb3J0KFwiLi9waXhlbC5qc1wiKS5QaXhlbH0gcmV0dXJuIGNvb3JkaW5hdGUgc28gdGhhdCBvcGVyYXRpb25zIGNhbiBiZVxuICogICAgIGNoYWluZWQgdG9nZXRoZXIuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBhcHBseSh0cmFuc2Zvcm0sIGNvb3JkaW5hdGUpIHtcbiAgY29uc3QgeCA9IGNvb3JkaW5hdGVbMF07XG4gIGNvbnN0IHkgPSBjb29yZGluYXRlWzFdO1xuICBjb29yZGluYXRlWzBdID0gdHJhbnNmb3JtWzBdICogeCArIHRyYW5zZm9ybVsyXSAqIHkgKyB0cmFuc2Zvcm1bNF07XG4gIGNvb3JkaW5hdGVbMV0gPSB0cmFuc2Zvcm1bMV0gKiB4ICsgdHJhbnNmb3JtWzNdICogeSArIHRyYW5zZm9ybVs1XTtcbiAgcmV0dXJuIGNvb3JkaW5hdGU7XG59XG5cbi8qKlxuICogQXBwbGllcyByb3RhdGlvbiB0byB0aGUgZ2l2ZW4gdHJhbnNmb3JtLlxuICogQHBhcmFtIHshVHJhbnNmb3JtfSB0cmFuc2Zvcm0gVHJhbnNmb3JtLlxuICogQHBhcmFtIHtudW1iZXJ9IGFuZ2xlIEFuZ2xlIGluIHJhZGlhbnMuXG4gKiBAcmV0dXJuIHshVHJhbnNmb3JtfSBUaGUgcm90YXRlZCB0cmFuc2Zvcm0uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiByb3RhdGUodHJhbnNmb3JtLCBhbmdsZSkge1xuICBjb25zdCBjb3MgPSBNYXRoLmNvcyhhbmdsZSk7XG4gIGNvbnN0IHNpbiA9IE1hdGguc2luKGFuZ2xlKTtcbiAgcmV0dXJuIG11bHRpcGx5KHRyYW5zZm9ybSwgc2V0KHRtcF8sIGNvcywgc2luLCAtc2luLCBjb3MsIDAsIDApKTtcbn1cblxuLyoqXG4gKiBBcHBsaWVzIHNjYWxlIHRvIGEgZ2l2ZW4gdHJhbnNmb3JtLlxuICogQHBhcmFtIHshVHJhbnNmb3JtfSB0cmFuc2Zvcm0gVHJhbnNmb3JtLlxuICogQHBhcmFtIHtudW1iZXJ9IHggU2NhbGUgZmFjdG9yIHguXG4gKiBAcGFyYW0ge251bWJlcn0geSBTY2FsZSBmYWN0b3IgeS5cbiAqIEByZXR1cm4geyFUcmFuc2Zvcm19IFRoZSBzY2FsZWQgdHJhbnNmb3JtLlxuICovXG5leHBvcnQgZnVuY3Rpb24gc2NhbGUodHJhbnNmb3JtLCB4LCB5KSB7XG4gIHJldHVybiBtdWx0aXBseSh0cmFuc2Zvcm0sIHNldCh0bXBfLCB4LCAwLCAwLCB5LCAwLCAwKSk7XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIHNjYWxlIHRyYW5zZm9ybS5cbiAqIEBwYXJhbSB7IVRyYW5zZm9ybX0gdGFyZ2V0IFRyYW5zZm9ybSB0byBvdmVyd3JpdGUuXG4gKiBAcGFyYW0ge251bWJlcn0geCBTY2FsZSBmYWN0b3IgeC5cbiAqIEBwYXJhbSB7bnVtYmVyfSB5IFNjYWxlIGZhY3RvciB5LlxuICogQHJldHVybiB7IVRyYW5zZm9ybX0gVGhlIHNjYWxlIHRyYW5zZm9ybS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG1ha2VTY2FsZSh0YXJnZXQsIHgsIHkpIHtcbiAgcmV0dXJuIHNldCh0YXJnZXQsIHgsIDAsIDAsIHksIDAsIDApO1xufVxuXG4vKipcbiAqIEFwcGxpZXMgdHJhbnNsYXRpb24gdG8gdGhlIGdpdmVuIHRyYW5zZm9ybS5cbiAqIEBwYXJhbSB7IVRyYW5zZm9ybX0gdHJhbnNmb3JtIFRyYW5zZm9ybS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBkeCBUcmFuc2xhdGlvbiB4LlxuICogQHBhcmFtIHtudW1iZXJ9IGR5IFRyYW5zbGF0aW9uIHkuXG4gKiBAcmV0dXJuIHshVHJhbnNmb3JtfSBUaGUgdHJhbnNsYXRlZCB0cmFuc2Zvcm0uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0cmFuc2xhdGUodHJhbnNmb3JtLCBkeCwgZHkpIHtcbiAgcmV0dXJuIG11bHRpcGx5KHRyYW5zZm9ybSwgc2V0KHRtcF8sIDEsIDAsIDAsIDEsIGR4LCBkeSkpO1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYSBjb21wb3NpdGUgdHJhbnNmb3JtIGdpdmVuIGFuIGluaXRpYWwgdHJhbnNsYXRpb24sIHNjYWxlLCByb3RhdGlvbiwgYW5kXG4gKiBmaW5hbCB0cmFuc2xhdGlvbiAoaW4gdGhhdCBvcmRlciBvbmx5LCBub3QgY29tbXV0YXRpdmUpLlxuICogQHBhcmFtIHshVHJhbnNmb3JtfSB0cmFuc2Zvcm0gVGhlIHRyYW5zZm9ybSAod2lsbCBiZSBtb2RpZmllZCBpbiBwbGFjZSkuXG4gKiBAcGFyYW0ge251bWJlcn0gZHgxIEluaXRpYWwgdHJhbnNsYXRpb24geC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBkeTEgSW5pdGlhbCB0cmFuc2xhdGlvbiB5LlxuICogQHBhcmFtIHtudW1iZXJ9IHN4IFNjYWxlIGZhY3RvciB4LlxuICogQHBhcmFtIHtudW1iZXJ9IHN5IFNjYWxlIGZhY3RvciB5LlxuICogQHBhcmFtIHtudW1iZXJ9IGFuZ2xlIFJvdGF0aW9uIChpbiBjb3VudGVyLWNsb2Nrd2lzZSByYWRpYW5zKS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBkeDIgRmluYWwgdHJhbnNsYXRpb24geC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBkeTIgRmluYWwgdHJhbnNsYXRpb24geS5cbiAqIEByZXR1cm4geyFUcmFuc2Zvcm19IFRoZSBjb21wb3NpdGUgdHJhbnNmb3JtLlxuICovXG5leHBvcnQgZnVuY3Rpb24gY29tcG9zZSh0cmFuc2Zvcm0sIGR4MSwgZHkxLCBzeCwgc3ksIGFuZ2xlLCBkeDIsIGR5Mikge1xuICBjb25zdCBzaW4gPSBNYXRoLnNpbihhbmdsZSk7XG4gIGNvbnN0IGNvcyA9IE1hdGguY29zKGFuZ2xlKTtcbiAgdHJhbnNmb3JtWzBdID0gc3ggKiBjb3M7XG4gIHRyYW5zZm9ybVsxXSA9IHN5ICogc2luO1xuICB0cmFuc2Zvcm1bMl0gPSAtc3ggKiBzaW47XG4gIHRyYW5zZm9ybVszXSA9IHN5ICogY29zO1xuICB0cmFuc2Zvcm1bNF0gPSBkeDIgKiBzeCAqIGNvcyAtIGR5MiAqIHN4ICogc2luICsgZHgxO1xuICB0cmFuc2Zvcm1bNV0gPSBkeDIgKiBzeSAqIHNpbiArIGR5MiAqIHN5ICogY29zICsgZHkxO1xuICByZXR1cm4gdHJhbnNmb3JtO1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYSBjb21wb3NpdGUgdHJhbnNmb3JtIGdpdmVuIGFuIGluaXRpYWwgdHJhbnNsYXRpb24sIHNjYWxlLCByb3RhdGlvbiwgYW5kXG4gKiBmaW5hbCB0cmFuc2xhdGlvbiAoaW4gdGhhdCBvcmRlciBvbmx5LCBub3QgY29tbXV0YXRpdmUpLiBUaGUgcmVzdWx0aW5nIHRyYW5zZm9ybVxuICogc3RyaW5nIGNhbiBiZSBhcHBsaWVkIGFzIGB0cmFuc2Zvcm1gIHByb3BlcnR5IG9mIGFuIEhUTUxFbGVtZW50J3Mgc3R5bGUuXG4gKiBAcGFyYW0ge251bWJlcn0gZHgxIEluaXRpYWwgdHJhbnNsYXRpb24geC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBkeTEgSW5pdGlhbCB0cmFuc2xhdGlvbiB5LlxuICogQHBhcmFtIHtudW1iZXJ9IHN4IFNjYWxlIGZhY3RvciB4LlxuICogQHBhcmFtIHtudW1iZXJ9IHN5IFNjYWxlIGZhY3RvciB5LlxuICogQHBhcmFtIHtudW1iZXJ9IGFuZ2xlIFJvdGF0aW9uIChpbiBjb3VudGVyLWNsb2Nrd2lzZSByYWRpYW5zKS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBkeDIgRmluYWwgdHJhbnNsYXRpb24geC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBkeTIgRmluYWwgdHJhbnNsYXRpb24geS5cbiAqIEByZXR1cm4ge3N0cmluZ30gVGhlIGNvbXBvc2l0ZSBjc3MgdHJhbnNmb3JtLlxuICogQGFwaVxuICovXG5leHBvcnQgZnVuY3Rpb24gY29tcG9zZUNzc1RyYW5zZm9ybShkeDEsIGR5MSwgc3gsIHN5LCBhbmdsZSwgZHgyLCBkeTIpIHtcbiAgcmV0dXJuIHRvU3RyaW5nKGNvbXBvc2UoY3JlYXRlKCksIGR4MSwgZHkxLCBzeCwgc3ksIGFuZ2xlLCBkeDIsIGR5MikpO1xufVxuXG4vKipcbiAqIEludmVydCB0aGUgZ2l2ZW4gdHJhbnNmb3JtLlxuICogQHBhcmFtIHshVHJhbnNmb3JtfSBzb3VyY2UgVGhlIHNvdXJjZSB0cmFuc2Zvcm0gdG8gaW52ZXJ0LlxuICogQHJldHVybiB7IVRyYW5zZm9ybX0gVGhlIGludmVydGVkIChzb3VyY2UpIHRyYW5zZm9ybS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGludmVydChzb3VyY2UpIHtcbiAgcmV0dXJuIG1ha2VJbnZlcnNlKHNvdXJjZSwgc291cmNlKTtcbn1cblxuLyoqXG4gKiBJbnZlcnQgdGhlIGdpdmVuIHRyYW5zZm9ybS5cbiAqIEBwYXJhbSB7IVRyYW5zZm9ybX0gdGFyZ2V0IFRyYW5zZm9ybSB0byBiZSBzZXQgYXMgdGhlIGludmVyc2Ugb2ZcbiAqICAgICB0aGUgc291cmNlIHRyYW5zZm9ybS5cbiAqIEBwYXJhbSB7IVRyYW5zZm9ybX0gc291cmNlIFRoZSBzb3VyY2UgdHJhbnNmb3JtIHRvIGludmVydC5cbiAqIEByZXR1cm4geyFUcmFuc2Zvcm19IFRoZSBpbnZlcnRlZCAodGFyZ2V0KSB0cmFuc2Zvcm0uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBtYWtlSW52ZXJzZSh0YXJnZXQsIHNvdXJjZSkge1xuICBjb25zdCBkZXQgPSBkZXRlcm1pbmFudChzb3VyY2UpO1xuICBhc3NlcnQoZGV0ICE9PSAwLCAzMik7IC8vIFRyYW5zZm9ybWF0aW9uIG1hdHJpeCBjYW5ub3QgYmUgaW52ZXJ0ZWRcblxuICBjb25zdCBhID0gc291cmNlWzBdO1xuICBjb25zdCBiID0gc291cmNlWzFdO1xuICBjb25zdCBjID0gc291cmNlWzJdO1xuICBjb25zdCBkID0gc291cmNlWzNdO1xuICBjb25zdCBlID0gc291cmNlWzRdO1xuICBjb25zdCBmID0gc291cmNlWzVdO1xuXG4gIHRhcmdldFswXSA9IGQgLyBkZXQ7XG4gIHRhcmdldFsxXSA9IC1iIC8gZGV0O1xuICB0YXJnZXRbMl0gPSAtYyAvIGRldDtcbiAgdGFyZ2V0WzNdID0gYSAvIGRldDtcbiAgdGFyZ2V0WzRdID0gKGMgKiBmIC0gZCAqIGUpIC8gZGV0O1xuICB0YXJnZXRbNV0gPSAtKGEgKiBmIC0gYiAqIGUpIC8gZGV0O1xuXG4gIHJldHVybiB0YXJnZXQ7XG59XG5cbi8qKlxuICogUmV0dXJucyB0aGUgZGV0ZXJtaW5hbnQgb2YgdGhlIGdpdmVuIG1hdHJpeC5cbiAqIEBwYXJhbSB7IVRyYW5zZm9ybX0gbWF0IE1hdHJpeC5cbiAqIEByZXR1cm4ge251bWJlcn0gRGV0ZXJtaW5hbnQuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBkZXRlcm1pbmFudChtYXQpIHtcbiAgcmV0dXJuIG1hdFswXSAqIG1hdFszXSAtIG1hdFsxXSAqIG1hdFsyXTtcbn1cblxuLyoqXG4gKiBAdHlwZSB7SFRNTEVsZW1lbnR9XG4gKiBAcHJpdmF0ZVxuICovXG5sZXQgdHJhbnNmb3JtU3RyaW5nRGl2O1xuXG4vKipcbiAqIEEgcm91bmRlZCBzdHJpbmcgdmVyc2lvbiBvZiB0aGUgdHJhbnNmb3JtLiAgVGhpcyBjYW4gYmUgdXNlZFxuICogZm9yIENTUyB0cmFuc2Zvcm1zLlxuICogQHBhcmFtIHshVHJhbnNmb3JtfSBtYXQgTWF0cml4LlxuICogQHJldHVybiB7c3RyaW5nfSBUaGUgdHJhbnNmb3JtIGFzIGEgc3RyaW5nLlxuICovXG5leHBvcnQgZnVuY3Rpb24gdG9TdHJpbmcobWF0KSB7XG4gIGNvbnN0IHRyYW5zZm9ybVN0cmluZyA9ICdtYXRyaXgoJyArIG1hdC5qb2luKCcsICcpICsgJyknO1xuICBpZiAoV09SS0VSX09GRlNDUkVFTl9DQU5WQVMpIHtcbiAgICByZXR1cm4gdHJhbnNmb3JtU3RyaW5nO1xuICB9XG4gIGNvbnN0IG5vZGUgPVxuICAgIHRyYW5zZm9ybVN0cmluZ0RpdiB8fCAodHJhbnNmb3JtU3RyaW5nRGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2JykpO1xuICBub2RlLnN0eWxlLnRyYW5zZm9ybSA9IHRyYW5zZm9ybVN0cmluZztcbiAgcmV0dXJuIG5vZGUuc3R5bGUudHJhbnNmb3JtO1xufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///6101\n')},74187:function(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__){eval("/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"O3\": function() { return /* binding */ abstract; },\n/* harmony export */   \"sq\": function() { return /* binding */ getUid; }\n/* harmony export */ });\n/* unused harmony export VERSION */\n/**\n * @module ol/util\n */\n\n/**\n * @return {never} Any return.\n */\nfunction abstract() {\n  throw new Error('Unimplemented abstract method.');\n}\n\n/**\n * Counter for getUid.\n * @type {number}\n * @private\n */\nlet uidCounter_ = 0;\n\n/**\n * Gets a unique ID for an object. This mutates the object so that further calls\n * with the same object as a parameter returns the same value. Unique IDs are generated\n * as a strictly increasing sequence. Adapted from goog.getUid.\n *\n * @param {Object} obj The object to get the unique ID for.\n * @return {string} The unique ID for the object.\n * @api\n */\nfunction getUid(obj) {\n  return obj.ol_uid || (obj.ol_uid = String(++uidCounter_));\n}\n\n/**\n * OpenLayers version.\n * @type {string}\n */\nconst VERSION = '7.3.0';\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNzQxODcuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxZQUFZLE9BQU87QUFDbkI7QUFDTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixZQUFZLFFBQVE7QUFDcEI7QUFDQTtBQUNPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ08iLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly92dWUzLXdlYnBhY2s1Ly4vbm9kZV9tb2R1bGVzL29sL3V0aWwuanM/NDliZiJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBtb2R1bGUgb2wvdXRpbFxuICovXG5cbi8qKlxuICogQHJldHVybiB7bmV2ZXJ9IEFueSByZXR1cm4uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBhYnN0cmFjdCgpIHtcbiAgdGhyb3cgbmV3IEVycm9yKCdVbmltcGxlbWVudGVkIGFic3RyYWN0IG1ldGhvZC4nKTtcbn1cblxuLyoqXG4gKiBDb3VudGVyIGZvciBnZXRVaWQuXG4gKiBAdHlwZSB7bnVtYmVyfVxuICogQHByaXZhdGVcbiAqL1xubGV0IHVpZENvdW50ZXJfID0gMDtcblxuLyoqXG4gKiBHZXRzIGEgdW5pcXVlIElEIGZvciBhbiBvYmplY3QuIFRoaXMgbXV0YXRlcyB0aGUgb2JqZWN0IHNvIHRoYXQgZnVydGhlciBjYWxsc1xuICogd2l0aCB0aGUgc2FtZSBvYmplY3QgYXMgYSBwYXJhbWV0ZXIgcmV0dXJucyB0aGUgc2FtZSB2YWx1ZS4gVW5pcXVlIElEcyBhcmUgZ2VuZXJhdGVkXG4gKiBhcyBhIHN0cmljdGx5IGluY3JlYXNpbmcgc2VxdWVuY2UuIEFkYXB0ZWQgZnJvbSBnb29nLmdldFVpZC5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqIFRoZSBvYmplY3QgdG8gZ2V0IHRoZSB1bmlxdWUgSUQgZm9yLlxuICogQHJldHVybiB7c3RyaW5nfSBUaGUgdW5pcXVlIElEIGZvciB0aGUgb2JqZWN0LlxuICogQGFwaVxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0VWlkKG9iaikge1xuICByZXR1cm4gb2JqLm9sX3VpZCB8fCAob2JqLm9sX3VpZCA9IFN0cmluZygrK3VpZENvdW50ZXJfKSk7XG59XG5cbi8qKlxuICogT3BlbkxheWVycyB2ZXJzaW9uLlxuICogQHR5cGUge3N0cmluZ31cbiAqL1xuZXhwb3J0IGNvbnN0IFZFUlNJT04gPSAnNy4zLjAnO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///74187\n")}}]);