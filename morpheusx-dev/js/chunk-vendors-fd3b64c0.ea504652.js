"use strict";(self["webpackChunkvue3_webpack5"]=self["webpackChunkvue3_webpack5"]||[]).push([[1458],{520:function(__unused_webpack_module,__webpack_exports__,__webpack_require__){eval("\n// EXPORTS\n__webpack_require__.d(__webpack_exports__, {\n  \"Z\": function() { return /* binding */ ScenegraphLayer; }\n});\n\n// EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/esm/defineProperty.js\nvar defineProperty = __webpack_require__(82482);\n// EXTERNAL MODULE: ./node_modules/@deck.gl/core/dist/esm/lib/layer.js + 3 modules\nvar lib_layer = __webpack_require__(52447);\n// EXTERNAL MODULE: ./node_modules/@deck.gl/core/dist/esm/shaderlib/project32/project32.js\nvar project32 = __webpack_require__(93844);\n// EXTERNAL MODULE: ./node_modules/@deck.gl/core/dist/esm/shaderlib/picking/picking.js\nvar picking = __webpack_require__(43844);\n// EXTERNAL MODULE: ./node_modules/@deck.gl/core/dist/esm/utils/log.js\nvar log = __webpack_require__(80744);\n// EXTERNAL MODULE: ./node_modules/@luma.gl/gltools/dist/esm/index.js + 13 modules\nvar esm = __webpack_require__(1418);\n// EXTERNAL MODULE: ./node_modules/@luma.gl/shadertools/dist/esm/modules/pbr/pbr.js + 2 modules\nvar pbr = __webpack_require__(49764);\n// EXTERNAL MODULE: ./node_modules/@luma.gl/experimental/dist/esm/scenegraph/scenegraph-node.js\nvar scenegraph_node = __webpack_require__(44522);\n// EXTERNAL MODULE: ./node_modules/@luma.gl/experimental/dist/esm/gltf/create-gltf-objects.js + 6 modules\nvar create_gltf_objects = __webpack_require__(77910);\n// EXTERNAL MODULE: ./node_modules/@loaders.gl/gltf/dist/esm/gltf-loader.js + 50 modules\nvar gltf_loader = __webpack_require__(52462);\n;// CONCATENATED MODULE: ./node_modules/@deck.gl/mesh-layers/dist/esm/scenegraph-layer/gltf-utils.js\nasync function waitForGLTFAssets(gltfObjects) {\n  const remaining = [];\n  gltfObjects.scenes.forEach(scene => {\n    scene.traverse(model => {\n      Object.values(model.model.getUniforms()).forEach(uniform => {\n        if (uniform.loaded === false) {\n          remaining.push(uniform);\n        }\n      });\n    });\n  });\n  return await waitWhileCondition(() => remaining.some(uniform => !uniform.loaded));\n}\n\nasync function waitWhileCondition(condition) {\n  while (condition()) {\n    await new Promise(resolve => requestAnimationFrame(resolve));\n  }\n}\n//# sourceMappingURL=gltf-utils.js.map\n// EXTERNAL MODULE: ./node_modules/@deck.gl/core/dist/esm/utils/iterable-utils.js\nvar iterable_utils = __webpack_require__(38550);\n// EXTERNAL MODULE: ./node_modules/@deck.gl/core/dist/esm/lib/constants.js\nvar constants = __webpack_require__(24088);\n;// CONCATENATED MODULE: ./node_modules/@deck.gl/mesh-layers/dist/esm/utils/matrix.js\n\nconst RADIAN_PER_DEGREE = Math.PI / 180;\nconst modelMatrix = new Float32Array(16);\nconst valueArray = new Float32Array(12);\n\nfunction calculateTransformMatrix(targetMatrix, orientation, scale) {\n  const pitch = orientation[0] * RADIAN_PER_DEGREE;\n  const yaw = orientation[1] * RADIAN_PER_DEGREE;\n  const roll = orientation[2] * RADIAN_PER_DEGREE;\n  const sr = Math.sin(roll);\n  const sp = Math.sin(pitch);\n  const sw = Math.sin(yaw);\n  const cr = Math.cos(roll);\n  const cp = Math.cos(pitch);\n  const cw = Math.cos(yaw);\n  const scx = scale[0];\n  const scy = scale[1];\n  const scz = scale[2];\n  targetMatrix[0] = scx * cw * cp;\n  targetMatrix[1] = scx * sw * cp;\n  targetMatrix[2] = scx * -sp;\n  targetMatrix[3] = scy * (-sw * cr + cw * sp * sr);\n  targetMatrix[4] = scy * (cw * cr + sw * sp * sr);\n  targetMatrix[5] = scy * cp * sr;\n  targetMatrix[6] = scz * (sw * sr + cw * sp * cr);\n  targetMatrix[7] = scz * (-cw * sr + sw * sp * cr);\n  targetMatrix[8] = scz * cp * cr;\n}\n\nfunction getExtendedMat3FromMat4(mat4) {\n  mat4[0] = mat4[0];\n  mat4[1] = mat4[1];\n  mat4[2] = mat4[2];\n  mat4[3] = mat4[4];\n  mat4[4] = mat4[5];\n  mat4[5] = mat4[6];\n  mat4[6] = mat4[8];\n  mat4[7] = mat4[9];\n  mat4[8] = mat4[10];\n  mat4[9] = mat4[12];\n  mat4[10] = mat4[13];\n  mat4[11] = mat4[14];\n  return mat4.subarray(0, 12);\n}\n\nconst MATRIX_ATTRIBUTES = {\n  size: 12,\n  accessor: ['getOrientation', 'getScale', 'getTranslation', 'getTransformMatrix'],\n  shaderAttributes: {\n    instanceModelMatrix__LOCATION_0: {\n      size: 3,\n      elementOffset: 0\n    },\n    instanceModelMatrix__LOCATION_1: {\n      size: 3,\n      elementOffset: 3\n    },\n    instanceModelMatrix__LOCATION_2: {\n      size: 3,\n      elementOffset: 6\n    },\n    instanceTranslation: {\n      size: 3,\n      elementOffset: 9\n    }\n  },\n\n  update(attribute, {\n    startRow,\n    endRow\n  }) {\n    const {\n      data,\n      getOrientation,\n      getScale,\n      getTranslation,\n      getTransformMatrix\n    } = this.props;\n    const arrayMatrix = Array.isArray(getTransformMatrix);\n    const constantMatrix = arrayMatrix && getTransformMatrix.length === 16;\n    const constantScale = Array.isArray(getScale);\n    const constantOrientation = Array.isArray(getOrientation);\n    const constantTranslation = Array.isArray(getTranslation);\n    const hasMatrix = constantMatrix || !arrayMatrix && Boolean(getTransformMatrix(data[0]));\n\n    if (hasMatrix) {\n      attribute.constant = constantMatrix;\n    } else {\n      attribute.constant = constantOrientation && constantScale && constantTranslation;\n    }\n\n    const instanceModelMatrixData = attribute.value;\n\n    if (attribute.constant) {\n      let matrix;\n\n      if (hasMatrix) {\n        modelMatrix.set(getTransformMatrix);\n        matrix = getExtendedMat3FromMat4(modelMatrix);\n      } else {\n        matrix = valueArray;\n        const orientation = getOrientation;\n        const scale = getScale;\n        calculateTransformMatrix(matrix, orientation, scale);\n        matrix.set(getTranslation, 9);\n      }\n\n      attribute.value = new Float32Array(matrix);\n    } else {\n      let i = startRow * attribute.size;\n      const {\n        iterable,\n        objectInfo\n      } = (0,iterable_utils/* createIterable */.jB)(data, startRow, endRow);\n\n      for (const object of iterable) {\n        objectInfo.index++;\n        let matrix;\n\n        if (hasMatrix) {\n          modelMatrix.set(constantMatrix ? getTransformMatrix : getTransformMatrix(object, objectInfo));\n          matrix = getExtendedMat3FromMat4(modelMatrix);\n        } else {\n          matrix = valueArray;\n          const orientation = constantOrientation ? getOrientation : getOrientation(object, objectInfo);\n          const scale = constantScale ? getScale : getScale(object, objectInfo);\n          calculateTransformMatrix(matrix, orientation, scale);\n          matrix.set(constantTranslation ? getTranslation : getTranslation(object, objectInfo), 9);\n        }\n\n        instanceModelMatrixData[i++] = matrix[0];\n        instanceModelMatrixData[i++] = matrix[1];\n        instanceModelMatrixData[i++] = matrix[2];\n        instanceModelMatrixData[i++] = matrix[3];\n        instanceModelMatrixData[i++] = matrix[4];\n        instanceModelMatrixData[i++] = matrix[5];\n        instanceModelMatrixData[i++] = matrix[6];\n        instanceModelMatrixData[i++] = matrix[7];\n        instanceModelMatrixData[i++] = matrix[8];\n        instanceModelMatrixData[i++] = matrix[9];\n        instanceModelMatrixData[i++] = matrix[10];\n        instanceModelMatrixData[i++] = matrix[11];\n      }\n    }\n  }\n\n};\nfunction shouldComposeModelMatrix(viewport, coordinateSystem) {\n  return coordinateSystem === constants/* COORDINATE_SYSTEM.CARTESIAN */.Df.CARTESIAN || coordinateSystem === constants/* COORDINATE_SYSTEM.METER_OFFSETS */.Df.METER_OFFSETS || coordinateSystem === constants/* COORDINATE_SYSTEM.DEFAULT */.Df.DEFAULT && !viewport.isGeospatial;\n}\n//# sourceMappingURL=matrix.js.map\n;// CONCATENATED MODULE: ./node_modules/@deck.gl/mesh-layers/dist/esm/scenegraph-layer/scenegraph-layer-vertex.glsl.js\n/* harmony default export */ var scenegraph_layer_vertex_glsl = (\"#version 300 es\\nin vec3 instancePositions;\\nin vec3 instancePositions64Low;\\nin vec4 instanceColors;\\nin vec3 instancePickingColors;\\nin mat3 instanceModelMatrix;\\nin vec3 instanceTranslation;\\nuniform float sizeScale;\\nuniform float sizeMinPixels;\\nuniform float sizeMaxPixels;\\nuniform mat4 sceneModelMatrix;\\nuniform bool composeModelMatrix;\\nin vec4 POSITION;\\n\\n#ifdef HAS_UV\\n  in vec2 TEXCOORD_0;\\n#endif\\n\\n#ifdef MODULE_PBR\\n  #ifdef HAS_NORMALS\\n    in vec4 NORMAL;\\n  #endif\\n#endif\\nout vec4 vColor;\\n#ifndef MODULE_PBR\\n  #ifdef HAS_UV\\n    out vec2 vTEXCOORD_0;\\n  #endif\\n#endif\\nvoid main(void) {\\n  #if defined(HAS_UV) && !defined(MODULE_PBR)\\n    vTEXCOORD_0 = TEXCOORD_0;\\n    geometry.uv = vTEXCOORD_0;\\n  #endif\\n\\n  geometry.worldPosition = instancePositions;\\n  geometry.pickingColor = instancePickingColors;\\n\\n  vec3 normal = vec3(0.0, 0.0, 1.0);\\n  #ifdef MODULE_PBR\\n    #ifdef HAS_NORMALS\\n      normal = instanceModelMatrix * (sceneModelMatrix * vec4(NORMAL.xyz, 0.0)).xyz;\\n    #endif\\n  #endif\\n\\n  float originalSize = project_size_to_pixel(sizeScale);\\n  float clampedSize = clamp(originalSize, sizeMinPixels, sizeMaxPixels);\\n\\n  vec3 pos = (instanceModelMatrix * (sceneModelMatrix * POSITION).xyz) * sizeScale * (clampedSize / originalSize) + instanceTranslation;\\n  if(composeModelMatrix) {\\n    DECKGL_FILTER_SIZE(pos, geometry);\\n    geometry.normal = project_normal(normal);\\n    geometry.worldPosition += pos;\\n    gl_Position = project_position_to_clipspace(pos + instancePositions, instancePositions64Low, vec3(0.0), geometry.position);\\n  }\\n  else {\\n    pos = project_size(pos);\\n    DECKGL_FILTER_SIZE(pos, geometry);\\n    gl_Position = project_position_to_clipspace(instancePositions, instancePositions64Low, pos, geometry.position);\\n    geometry.normal = project_normal(normal);\\n  }\\n  DECKGL_FILTER_GL_POSITION(gl_Position, geometry);\\n\\n  #ifdef MODULE_PBR\\n    pbr_vPosition = geometry.position.xyz;\\n    #ifdef HAS_NORMALS\\n      pbr_vNormal = geometry.normal;\\n    #endif\\n\\n    #ifdef HAS_UV\\n      pbr_vUV = TEXCOORD_0;\\n    #else\\n      pbr_vUV = vec2(0., 0.);\\n    #endif\\n    geometry.uv = pbr_vUV;\\n  #endif\\n\\n  vColor = instanceColors;\\n  DECKGL_FILTER_COLOR(vColor, geometry);\\n}\\n\");\n//# sourceMappingURL=scenegraph-layer-vertex.glsl.js.map\n;// CONCATENATED MODULE: ./node_modules/@deck.gl/mesh-layers/dist/esm/scenegraph-layer/scenegraph-layer-fragment.glsl.js\n/* harmony default export */ var scenegraph_layer_fragment_glsl = (\"#version 300 es\\nuniform float opacity;\\nin vec4 vColor;\\n\\nout vec4 fragmentColor;\\n#ifndef MODULE_PBR\\n  #if defined(HAS_UV) && defined(HAS_BASECOLORMAP)\\n    in vec2 vTEXCOORD_0;\\n    uniform sampler2D u_BaseColorSampler;\\n  #endif\\n#endif\\n\\nvoid main(void) {\\n  #ifdef MODULE_PBR\\n    fragmentColor = vColor * pbr_filterColor(vec4(0));\\n    geometry.uv = pbr_vUV;\\n  #else\\n    #if defined(HAS_UV) && defined(HAS_BASECOLORMAP)\\n      fragmentColor = vColor * texture2D(u_BaseColorSampler, vTEXCOORD_0);\\n      geometry.uv = vTEXCOORD_0;\\n    #else\\n      fragmentColor = vColor;\\n    #endif\\n  #endif\\n\\n  fragmentColor.a *= opacity;\\n  DECKGL_FILTER_COLOR(fragmentColor, geometry);\\n}\\n\");\n//# sourceMappingURL=scenegraph-layer-fragment.glsl.js.map\n;// CONCATENATED MODULE: ./node_modules/@deck.gl/mesh-layers/dist/esm/scenegraph-layer/scenegraph-layer.js\n\n\n\n\n\n\n\n\n\n\nconst DEFAULT_COLOR = [255, 255, 255, 255];\nconst defaultProps = {\n  scenegraph: {\n    type: 'object',\n    value: null,\n    async: true\n  },\n  getScene: gltf => {\n    if (gltf && gltf.scenes) {\n      return typeof gltf.scene === 'object' ? gltf.scene : gltf.scenes[gltf.scene || 0];\n    }\n\n    return gltf;\n  },\n  getAnimator: scenegraph => scenegraph && scenegraph.animator,\n  _animations: null,\n  sizeScale: {\n    type: 'number',\n    value: 1,\n    min: 0\n  },\n  sizeMinPixels: {\n    type: 'number',\n    min: 0,\n    value: 0\n  },\n  sizeMaxPixels: {\n    type: 'number',\n    min: 0,\n    value: Number.MAX_SAFE_INTEGER\n  },\n  getPosition: {\n    type: 'accessor',\n    value: x => x.position\n  },\n  getColor: {\n    type: 'accessor',\n    value: DEFAULT_COLOR\n  },\n  _lighting: 'flat',\n  _imageBasedLightingEnvironment: null,\n  getOrientation: {\n    type: 'accessor',\n    value: [0, 0, 0]\n  },\n  getScale: {\n    type: 'accessor',\n    value: [1, 1, 1]\n  },\n  getTranslation: {\n    type: 'accessor',\n    value: [0, 0, 0]\n  },\n  getTransformMatrix: {\n    type: 'accessor',\n    value: []\n  },\n  loaders: [gltf_loader/* GLTFLoader */.E]\n};\nclass ScenegraphLayer extends lib_layer/* default */.Z {\n  constructor(...args) {\n    super(...args);\n\n    (0,defineProperty/* default */.Z)(this, \"state\", void 0);\n  }\n\n  getShaders() {\n    const modules = [project32/* default */.Z, picking/* default */.Z];\n\n    if (this.props._lighting === 'pbr') {\n      modules.push(pbr/* pbr */.b);\n    }\n\n    return {\n      vs: scenegraph_layer_vertex_glsl,\n      fs: scenegraph_layer_fragment_glsl,\n      modules\n    };\n  }\n\n  initializeState() {\n    const attributeManager = this.getAttributeManager();\n    attributeManager.addInstanced({\n      instancePositions: {\n        size: 3,\n        type: 5130,\n        fp64: this.use64bitPositions(),\n        accessor: 'getPosition',\n        transition: true\n      },\n      instanceColors: {\n        type: 5121,\n        size: this.props.colorFormat.length,\n        accessor: 'getColor',\n        normalized: true,\n        defaultValue: DEFAULT_COLOR,\n        transition: true\n      },\n      instanceModelMatrix: MATRIX_ATTRIBUTES\n    });\n  }\n\n  updateState(params) {\n    super.updateState(params);\n    const {\n      props,\n      oldProps\n    } = params;\n\n    if (props.scenegraph !== oldProps.scenegraph) {\n      this._updateScenegraph();\n    } else if (props._animations !== oldProps._animations) {\n      this._applyAnimationsProp(this.state.scenegraph, this.state.animator, props._animations);\n    }\n  }\n\n  finalizeState(context) {\n    super.finalizeState(context);\n\n    this._deleteScenegraph();\n  }\n\n  _updateScenegraph() {\n    const props = this.props;\n    const {\n      gl\n    } = this.context;\n    let scenegraphData = null;\n\n    if (props.scenegraph instanceof scenegraph_node/* default */.Z) {\n      scenegraphData = {\n        scenes: [props.scenegraph]\n      };\n    } else if (props.scenegraph && !props.scenegraph.gltf) {\n      const gltf = props.scenegraph;\n      const gltfObjects = (0,create_gltf_objects/* default */.Z)(gl, gltf, this._getModelOptions());\n      scenegraphData = {\n        gltf,\n        ...gltfObjects\n      };\n      waitForGLTFAssets(gltfObjects).then(() => this.setNeedsRedraw());\n    } else if (props.scenegraph) {\n      log/* default.deprecated */.Z.deprecated('ScenegraphLayer.props.scenegraph', 'Use GLTFLoader instead of GLTFScenegraphLoader')();\n      scenegraphData = props.scenegraph;\n    }\n\n    const options = {\n      layer: this,\n      gl\n    };\n    const scenegraph = props.getScene(scenegraphData, options);\n    const animator = props.getAnimator(scenegraphData, options);\n\n    if (scenegraph instanceof scenegraph_node/* default */.Z) {\n      this._deleteScenegraph();\n\n      this._applyAllAttributes(scenegraph);\n\n      this._applyAnimationsProp(scenegraph, animator, props._animations);\n\n      this.setState({\n        scenegraph,\n        animator\n      });\n    } else if (scenegraph !== null) {\n      log/* default.warn */.Z.warn('invalid scenegraph:', scenegraph)();\n    }\n  }\n\n  _applyAllAttributes(scenegraph) {\n    if (this.state.attributesAvailable) {\n      const allAttributes = this.getAttributeManager().getAttributes();\n      scenegraph.traverse(model => {\n        this._setModelAttributes(model.model, allAttributes);\n      });\n    }\n  }\n\n  _applyAnimationsProp(scenegraph, animator, animationsProp) {\n    if (!scenegraph || !animator || !animationsProp) {\n      return;\n    }\n\n    const animations = animator.getAnimations();\n    Object.keys(animationsProp).sort().forEach(key => {\n      const value = animationsProp[key];\n\n      if (key === '*') {\n        animations.forEach(animation => {\n          Object.assign(animation, value);\n        });\n      } else if (Number.isFinite(Number(key))) {\n        const number = Number(key);\n\n        if (number >= 0 && number < animations.length) {\n          Object.assign(animations[number], value);\n        } else {\n          log/* default.warn */.Z.warn(\"animation \".concat(key, \" not found\"))();\n        }\n      } else {\n        const findResult = animations.find(({\n          name\n        }) => name === key);\n\n        if (findResult) {\n          Object.assign(findResult, value);\n        } else {\n          log/* default.warn */.Z.warn(\"animation \".concat(key, \" not found\"))();\n        }\n      }\n    });\n  }\n\n  _deleteScenegraph() {\n    const {\n      scenegraph\n    } = this.state;\n\n    if (scenegraph instanceof scenegraph_node/* default */.Z) {\n      scenegraph.delete();\n    }\n  }\n\n  _getModelOptions() {\n    const {\n      _imageBasedLightingEnvironment\n    } = this.props;\n    let env = null;\n\n    if (_imageBasedLightingEnvironment) {\n      if (typeof _imageBasedLightingEnvironment === 'function') {\n        env = _imageBasedLightingEnvironment({\n          gl: this.context.gl,\n          layer: this\n        });\n      } else {\n        env = _imageBasedLightingEnvironment;\n      }\n    }\n\n    return {\n      gl: this.context.gl,\n      waitForFullLoad: true,\n      imageBasedLightingEnvironment: env,\n      modelOptions: {\n        isInstanced: true,\n        transpileToGLSL100: !(0,esm/* isWebGL2 */.D0)(this.context.gl),\n        ...this.getShaders()\n      },\n      useTangents: false\n    };\n  }\n\n  updateAttributes(changedAttributes) {\n    this.setState({\n      attributesAvailable: true\n    });\n    if (!this.state.scenegraph) return;\n    this.state.scenegraph.traverse(model => {\n      this._setModelAttributes(model.model, changedAttributes);\n    });\n  }\n\n  draw({\n    moduleParameters = null,\n    parameters = {},\n    context\n  }) {\n    if (!this.state.scenegraph) return;\n\n    if (this.props._animations && this.state.animator) {\n      this.state.animator.animate(context.timeline.getTime());\n      this.setNeedsRedraw();\n    }\n\n    const {\n      viewport\n    } = this.context;\n    const {\n      sizeScale,\n      sizeMinPixels,\n      sizeMaxPixels,\n      opacity,\n      coordinateSystem\n    } = this.props;\n    const numInstances = this.getNumInstances();\n    this.state.scenegraph.traverse((model, {\n      worldMatrix\n    }) => {\n      model.model.setInstanceCount(numInstances);\n      model.updateModuleSettings(moduleParameters);\n      model.draw({\n        parameters,\n        uniforms: {\n          sizeScale,\n          opacity,\n          sizeMinPixels,\n          sizeMaxPixels,\n          composeModelMatrix: shouldComposeModelMatrix(viewport, coordinateSystem),\n          sceneModelMatrix: worldMatrix,\n          u_Camera: model.model.getUniforms().project_uCameraPosition\n        }\n      });\n    });\n  }\n\n}\n\n(0,defineProperty/* default */.Z)(ScenegraphLayer, \"defaultProps\", defaultProps);\n\n(0,defineProperty/* default */.Z)(ScenegraphLayer, \"layerName\", 'ScenegraphLayer');\n//# sourceMappingURL=scenegraph-layer.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QTtBQUNBLFNBQVM7QUFDVCxRQUFRO0FBQ1I7O0FBRUE7QUFDQTtBQUNBLFVBQVU7QUFDVixVQUFVLDRCQUFRO0FBQ2xCO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQSxVQUFVO0FBQ1YsVUFBVSw0QkFBUTtBQUNsQjtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07O0FBRU4sOEJBQThCLDhCQUFjO0FBQzVDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxRQUFRO0FBQ1I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2Qix3QkFBUTtBQUNyQztBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsd0JBQXdCO0FBQ3REO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7O0FBRUE7O0FBRUEsaUNBQWU7O0FBRWYsaUNBQWU7QUFDZiIsInNvdXJjZXMiOlsid2VicGFjazovL3Z1ZTMtd2VicGFjazUvLi9ub2RlX21vZHVsZXMvQGRlY2suZ2wvbWVzaC1sYXllcnMvZGlzdC9lc20vc2NlbmVncmFwaC1sYXllci9nbHRmLXV0aWxzLmpzPzMxMmIiLCJ3ZWJwYWNrOi8vdnVlMy13ZWJwYWNrNS8uL25vZGVfbW9kdWxlcy9AZGVjay5nbC9tZXNoLWxheWVycy9kaXN0L2VzbS91dGlscy9tYXRyaXguanM/NDg5YSIsIndlYnBhY2s6Ly92dWUzLXdlYnBhY2s1Ly4vbm9kZV9tb2R1bGVzL0BkZWNrLmdsL21lc2gtbGF5ZXJzL2Rpc3QvZXNtL3NjZW5lZ3JhcGgtbGF5ZXIvc2NlbmVncmFwaC1sYXllci12ZXJ0ZXguZ2xzbC5qcz82M2Y4Iiwid2VicGFjazovL3Z1ZTMtd2VicGFjazUvLi9ub2RlX21vZHVsZXMvQGRlY2suZ2wvbWVzaC1sYXllcnMvZGlzdC9lc20vc2NlbmVncmFwaC1sYXllci9zY2VuZWdyYXBoLWxheWVyLWZyYWdtZW50Lmdsc2wuanM/OGVhNSIsIndlYnBhY2s6Ly92dWUzLXdlYnBhY2s1Ly4vbm9kZV9tb2R1bGVzL0BkZWNrLmdsL21lc2gtbGF5ZXJzL2Rpc3QvZXNtL3NjZW5lZ3JhcGgtbGF5ZXIvc2NlbmVncmFwaC1sYXllci5qcz8zNWM0Il0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCBhc3luYyBmdW5jdGlvbiB3YWl0Rm9yR0xURkFzc2V0cyhnbHRmT2JqZWN0cykge1xuICBjb25zdCByZW1haW5pbmcgPSBbXTtcbiAgZ2x0Zk9iamVjdHMuc2NlbmVzLmZvckVhY2goc2NlbmUgPT4ge1xuICAgIHNjZW5lLnRyYXZlcnNlKG1vZGVsID0+IHtcbiAgICAgIE9iamVjdC52YWx1ZXMobW9kZWwubW9kZWwuZ2V0VW5pZm9ybXMoKSkuZm9yRWFjaCh1bmlmb3JtID0+IHtcbiAgICAgICAgaWYgKHVuaWZvcm0ubG9hZGVkID09PSBmYWxzZSkge1xuICAgICAgICAgIHJlbWFpbmluZy5wdXNoKHVuaWZvcm0pO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfSk7XG4gIHJldHVybiBhd2FpdCB3YWl0V2hpbGVDb25kaXRpb24oKCkgPT4gcmVtYWluaW5nLnNvbWUodW5pZm9ybSA9PiAhdW5pZm9ybS5sb2FkZWQpKTtcbn1cblxuYXN5bmMgZnVuY3Rpb24gd2FpdFdoaWxlQ29uZGl0aW9uKGNvbmRpdGlvbikge1xuICB3aGlsZSAoY29uZGl0aW9uKCkpIHtcbiAgICBhd2FpdCBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHJlcXVlc3RBbmltYXRpb25GcmFtZShyZXNvbHZlKSk7XG4gIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWdsdGYtdXRpbHMuanMubWFwIiwiaW1wb3J0IHsgQ09PUkRJTkFURV9TWVNURU0sIGNyZWF0ZUl0ZXJhYmxlIH0gZnJvbSAnQGRlY2suZ2wvY29yZSc7XG5jb25zdCBSQURJQU5fUEVSX0RFR1JFRSA9IE1hdGguUEkgLyAxODA7XG5jb25zdCBtb2RlbE1hdHJpeCA9IG5ldyBGbG9hdDMyQXJyYXkoMTYpO1xuY29uc3QgdmFsdWVBcnJheSA9IG5ldyBGbG9hdDMyQXJyYXkoMTIpO1xuXG5mdW5jdGlvbiBjYWxjdWxhdGVUcmFuc2Zvcm1NYXRyaXgodGFyZ2V0TWF0cml4LCBvcmllbnRhdGlvbiwgc2NhbGUpIHtcbiAgY29uc3QgcGl0Y2ggPSBvcmllbnRhdGlvblswXSAqIFJBRElBTl9QRVJfREVHUkVFO1xuICBjb25zdCB5YXcgPSBvcmllbnRhdGlvblsxXSAqIFJBRElBTl9QRVJfREVHUkVFO1xuICBjb25zdCByb2xsID0gb3JpZW50YXRpb25bMl0gKiBSQURJQU5fUEVSX0RFR1JFRTtcbiAgY29uc3Qgc3IgPSBNYXRoLnNpbihyb2xsKTtcbiAgY29uc3Qgc3AgPSBNYXRoLnNpbihwaXRjaCk7XG4gIGNvbnN0IHN3ID0gTWF0aC5zaW4oeWF3KTtcbiAgY29uc3QgY3IgPSBNYXRoLmNvcyhyb2xsKTtcbiAgY29uc3QgY3AgPSBNYXRoLmNvcyhwaXRjaCk7XG4gIGNvbnN0IGN3ID0gTWF0aC5jb3MoeWF3KTtcbiAgY29uc3Qgc2N4ID0gc2NhbGVbMF07XG4gIGNvbnN0IHNjeSA9IHNjYWxlWzFdO1xuICBjb25zdCBzY3ogPSBzY2FsZVsyXTtcbiAgdGFyZ2V0TWF0cml4WzBdID0gc2N4ICogY3cgKiBjcDtcbiAgdGFyZ2V0TWF0cml4WzFdID0gc2N4ICogc3cgKiBjcDtcbiAgdGFyZ2V0TWF0cml4WzJdID0gc2N4ICogLXNwO1xuICB0YXJnZXRNYXRyaXhbM10gPSBzY3kgKiAoLXN3ICogY3IgKyBjdyAqIHNwICogc3IpO1xuICB0YXJnZXRNYXRyaXhbNF0gPSBzY3kgKiAoY3cgKiBjciArIHN3ICogc3AgKiBzcik7XG4gIHRhcmdldE1hdHJpeFs1XSA9IHNjeSAqIGNwICogc3I7XG4gIHRhcmdldE1hdHJpeFs2XSA9IHNjeiAqIChzdyAqIHNyICsgY3cgKiBzcCAqIGNyKTtcbiAgdGFyZ2V0TWF0cml4WzddID0gc2N6ICogKC1jdyAqIHNyICsgc3cgKiBzcCAqIGNyKTtcbiAgdGFyZ2V0TWF0cml4WzhdID0gc2N6ICogY3AgKiBjcjtcbn1cblxuZnVuY3Rpb24gZ2V0RXh0ZW5kZWRNYXQzRnJvbU1hdDQobWF0NCkge1xuICBtYXQ0WzBdID0gbWF0NFswXTtcbiAgbWF0NFsxXSA9IG1hdDRbMV07XG4gIG1hdDRbMl0gPSBtYXQ0WzJdO1xuICBtYXQ0WzNdID0gbWF0NFs0XTtcbiAgbWF0NFs0XSA9IG1hdDRbNV07XG4gIG1hdDRbNV0gPSBtYXQ0WzZdO1xuICBtYXQ0WzZdID0gbWF0NFs4XTtcbiAgbWF0NFs3XSA9IG1hdDRbOV07XG4gIG1hdDRbOF0gPSBtYXQ0WzEwXTtcbiAgbWF0NFs5XSA9IG1hdDRbMTJdO1xuICBtYXQ0WzEwXSA9IG1hdDRbMTNdO1xuICBtYXQ0WzExXSA9IG1hdDRbMTRdO1xuICByZXR1cm4gbWF0NC5zdWJhcnJheSgwLCAxMik7XG59XG5cbmV4cG9ydCBjb25zdCBNQVRSSVhfQVRUUklCVVRFUyA9IHtcbiAgc2l6ZTogMTIsXG4gIGFjY2Vzc29yOiBbJ2dldE9yaWVudGF0aW9uJywgJ2dldFNjYWxlJywgJ2dldFRyYW5zbGF0aW9uJywgJ2dldFRyYW5zZm9ybU1hdHJpeCddLFxuICBzaGFkZXJBdHRyaWJ1dGVzOiB7XG4gICAgaW5zdGFuY2VNb2RlbE1hdHJpeF9fTE9DQVRJT05fMDoge1xuICAgICAgc2l6ZTogMyxcbiAgICAgIGVsZW1lbnRPZmZzZXQ6IDBcbiAgICB9LFxuICAgIGluc3RhbmNlTW9kZWxNYXRyaXhfX0xPQ0FUSU9OXzE6IHtcbiAgICAgIHNpemU6IDMsXG4gICAgICBlbGVtZW50T2Zmc2V0OiAzXG4gICAgfSxcbiAgICBpbnN0YW5jZU1vZGVsTWF0cml4X19MT0NBVElPTl8yOiB7XG4gICAgICBzaXplOiAzLFxuICAgICAgZWxlbWVudE9mZnNldDogNlxuICAgIH0sXG4gICAgaW5zdGFuY2VUcmFuc2xhdGlvbjoge1xuICAgICAgc2l6ZTogMyxcbiAgICAgIGVsZW1lbnRPZmZzZXQ6IDlcbiAgICB9XG4gIH0sXG5cbiAgdXBkYXRlKGF0dHJpYnV0ZSwge1xuICAgIHN0YXJ0Um93LFxuICAgIGVuZFJvd1xuICB9KSB7XG4gICAgY29uc3Qge1xuICAgICAgZGF0YSxcbiAgICAgIGdldE9yaWVudGF0aW9uLFxuICAgICAgZ2V0U2NhbGUsXG4gICAgICBnZXRUcmFuc2xhdGlvbixcbiAgICAgIGdldFRyYW5zZm9ybU1hdHJpeFxuICAgIH0gPSB0aGlzLnByb3BzO1xuICAgIGNvbnN0IGFycmF5TWF0cml4ID0gQXJyYXkuaXNBcnJheShnZXRUcmFuc2Zvcm1NYXRyaXgpO1xuICAgIGNvbnN0IGNvbnN0YW50TWF0cml4ID0gYXJyYXlNYXRyaXggJiYgZ2V0VHJhbnNmb3JtTWF0cml4Lmxlbmd0aCA9PT0gMTY7XG4gICAgY29uc3QgY29uc3RhbnRTY2FsZSA9IEFycmF5LmlzQXJyYXkoZ2V0U2NhbGUpO1xuICAgIGNvbnN0IGNvbnN0YW50T3JpZW50YXRpb24gPSBBcnJheS5pc0FycmF5KGdldE9yaWVudGF0aW9uKTtcbiAgICBjb25zdCBjb25zdGFudFRyYW5zbGF0aW9uID0gQXJyYXkuaXNBcnJheShnZXRUcmFuc2xhdGlvbik7XG4gICAgY29uc3QgaGFzTWF0cml4ID0gY29uc3RhbnRNYXRyaXggfHwgIWFycmF5TWF0cml4ICYmIEJvb2xlYW4oZ2V0VHJhbnNmb3JtTWF0cml4KGRhdGFbMF0pKTtcblxuICAgIGlmIChoYXNNYXRyaXgpIHtcbiAgICAgIGF0dHJpYnV0ZS5jb25zdGFudCA9IGNvbnN0YW50TWF0cml4O1xuICAgIH0gZWxzZSB7XG4gICAgICBhdHRyaWJ1dGUuY29uc3RhbnQgPSBjb25zdGFudE9yaWVudGF0aW9uICYmIGNvbnN0YW50U2NhbGUgJiYgY29uc3RhbnRUcmFuc2xhdGlvbjtcbiAgICB9XG5cbiAgICBjb25zdCBpbnN0YW5jZU1vZGVsTWF0cml4RGF0YSA9IGF0dHJpYnV0ZS52YWx1ZTtcblxuICAgIGlmIChhdHRyaWJ1dGUuY29uc3RhbnQpIHtcbiAgICAgIGxldCBtYXRyaXg7XG5cbiAgICAgIGlmIChoYXNNYXRyaXgpIHtcbiAgICAgICAgbW9kZWxNYXRyaXguc2V0KGdldFRyYW5zZm9ybU1hdHJpeCk7XG4gICAgICAgIG1hdHJpeCA9IGdldEV4dGVuZGVkTWF0M0Zyb21NYXQ0KG1vZGVsTWF0cml4KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG1hdHJpeCA9IHZhbHVlQXJyYXk7XG4gICAgICAgIGNvbnN0IG9yaWVudGF0aW9uID0gZ2V0T3JpZW50YXRpb247XG4gICAgICAgIGNvbnN0IHNjYWxlID0gZ2V0U2NhbGU7XG4gICAgICAgIGNhbGN1bGF0ZVRyYW5zZm9ybU1hdHJpeChtYXRyaXgsIG9yaWVudGF0aW9uLCBzY2FsZSk7XG4gICAgICAgIG1hdHJpeC5zZXQoZ2V0VHJhbnNsYXRpb24sIDkpO1xuICAgICAgfVxuXG4gICAgICBhdHRyaWJ1dGUudmFsdWUgPSBuZXcgRmxvYXQzMkFycmF5KG1hdHJpeCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGxldCBpID0gc3RhcnRSb3cgKiBhdHRyaWJ1dGUuc2l6ZTtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgaXRlcmFibGUsXG4gICAgICAgIG9iamVjdEluZm9cbiAgICAgIH0gPSBjcmVhdGVJdGVyYWJsZShkYXRhLCBzdGFydFJvdywgZW5kUm93KTtcblxuICAgICAgZm9yIChjb25zdCBvYmplY3Qgb2YgaXRlcmFibGUpIHtcbiAgICAgICAgb2JqZWN0SW5mby5pbmRleCsrO1xuICAgICAgICBsZXQgbWF0cml4O1xuXG4gICAgICAgIGlmIChoYXNNYXRyaXgpIHtcbiAgICAgICAgICBtb2RlbE1hdHJpeC5zZXQoY29uc3RhbnRNYXRyaXggPyBnZXRUcmFuc2Zvcm1NYXRyaXggOiBnZXRUcmFuc2Zvcm1NYXRyaXgob2JqZWN0LCBvYmplY3RJbmZvKSk7XG4gICAgICAgICAgbWF0cml4ID0gZ2V0RXh0ZW5kZWRNYXQzRnJvbU1hdDQobW9kZWxNYXRyaXgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG1hdHJpeCA9IHZhbHVlQXJyYXk7XG4gICAgICAgICAgY29uc3Qgb3JpZW50YXRpb24gPSBjb25zdGFudE9yaWVudGF0aW9uID8gZ2V0T3JpZW50YXRpb24gOiBnZXRPcmllbnRhdGlvbihvYmplY3QsIG9iamVjdEluZm8pO1xuICAgICAgICAgIGNvbnN0IHNjYWxlID0gY29uc3RhbnRTY2FsZSA/IGdldFNjYWxlIDogZ2V0U2NhbGUob2JqZWN0LCBvYmplY3RJbmZvKTtcbiAgICAgICAgICBjYWxjdWxhdGVUcmFuc2Zvcm1NYXRyaXgobWF0cml4LCBvcmllbnRhdGlvbiwgc2NhbGUpO1xuICAgICAgICAgIG1hdHJpeC5zZXQoY29uc3RhbnRUcmFuc2xhdGlvbiA/IGdldFRyYW5zbGF0aW9uIDogZ2V0VHJhbnNsYXRpb24ob2JqZWN0LCBvYmplY3RJbmZvKSwgOSk7XG4gICAgICAgIH1cblxuICAgICAgICBpbnN0YW5jZU1vZGVsTWF0cml4RGF0YVtpKytdID0gbWF0cml4WzBdO1xuICAgICAgICBpbnN0YW5jZU1vZGVsTWF0cml4RGF0YVtpKytdID0gbWF0cml4WzFdO1xuICAgICAgICBpbnN0YW5jZU1vZGVsTWF0cml4RGF0YVtpKytdID0gbWF0cml4WzJdO1xuICAgICAgICBpbnN0YW5jZU1vZGVsTWF0cml4RGF0YVtpKytdID0gbWF0cml4WzNdO1xuICAgICAgICBpbnN0YW5jZU1vZGVsTWF0cml4RGF0YVtpKytdID0gbWF0cml4WzRdO1xuICAgICAgICBpbnN0YW5jZU1vZGVsTWF0cml4RGF0YVtpKytdID0gbWF0cml4WzVdO1xuICAgICAgICBpbnN0YW5jZU1vZGVsTWF0cml4RGF0YVtpKytdID0gbWF0cml4WzZdO1xuICAgICAgICBpbnN0YW5jZU1vZGVsTWF0cml4RGF0YVtpKytdID0gbWF0cml4WzddO1xuICAgICAgICBpbnN0YW5jZU1vZGVsTWF0cml4RGF0YVtpKytdID0gbWF0cml4WzhdO1xuICAgICAgICBpbnN0YW5jZU1vZGVsTWF0cml4RGF0YVtpKytdID0gbWF0cml4WzldO1xuICAgICAgICBpbnN0YW5jZU1vZGVsTWF0cml4RGF0YVtpKytdID0gbWF0cml4WzEwXTtcbiAgICAgICAgaW5zdGFuY2VNb2RlbE1hdHJpeERhdGFbaSsrXSA9IG1hdHJpeFsxMV07XG4gICAgICB9XG4gICAgfVxuICB9XG5cbn07XG5leHBvcnQgZnVuY3Rpb24gc2hvdWxkQ29tcG9zZU1vZGVsTWF0cml4KHZpZXdwb3J0LCBjb29yZGluYXRlU3lzdGVtKSB7XG4gIHJldHVybiBjb29yZGluYXRlU3lzdGVtID09PSBDT09SRElOQVRFX1NZU1RFTS5DQVJURVNJQU4gfHwgY29vcmRpbmF0ZVN5c3RlbSA9PT0gQ09PUkRJTkFURV9TWVNURU0uTUVURVJfT0ZGU0VUUyB8fCBjb29yZGluYXRlU3lzdGVtID09PSBDT09SRElOQVRFX1NZU1RFTS5ERUZBVUxUICYmICF2aWV3cG9ydC5pc0dlb3NwYXRpYWw7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1tYXRyaXguanMubWFwIiwiZXhwb3J0IGRlZmF1bHQgXCIjdmVyc2lvbiAzMDAgZXNcXG5pbiB2ZWMzIGluc3RhbmNlUG9zaXRpb25zO1xcbmluIHZlYzMgaW5zdGFuY2VQb3NpdGlvbnM2NExvdztcXG5pbiB2ZWM0IGluc3RhbmNlQ29sb3JzO1xcbmluIHZlYzMgaW5zdGFuY2VQaWNraW5nQ29sb3JzO1xcbmluIG1hdDMgaW5zdGFuY2VNb2RlbE1hdHJpeDtcXG5pbiB2ZWMzIGluc3RhbmNlVHJhbnNsYXRpb247XFxudW5pZm9ybSBmbG9hdCBzaXplU2NhbGU7XFxudW5pZm9ybSBmbG9hdCBzaXplTWluUGl4ZWxzO1xcbnVuaWZvcm0gZmxvYXQgc2l6ZU1heFBpeGVscztcXG51bmlmb3JtIG1hdDQgc2NlbmVNb2RlbE1hdHJpeDtcXG51bmlmb3JtIGJvb2wgY29tcG9zZU1vZGVsTWF0cml4O1xcbmluIHZlYzQgUE9TSVRJT047XFxuXFxuI2lmZGVmIEhBU19VVlxcbiAgaW4gdmVjMiBURVhDT09SRF8wO1xcbiNlbmRpZlxcblxcbiNpZmRlZiBNT0RVTEVfUEJSXFxuICAjaWZkZWYgSEFTX05PUk1BTFNcXG4gICAgaW4gdmVjNCBOT1JNQUw7XFxuICAjZW5kaWZcXG4jZW5kaWZcXG5vdXQgdmVjNCB2Q29sb3I7XFxuI2lmbmRlZiBNT0RVTEVfUEJSXFxuICAjaWZkZWYgSEFTX1VWXFxuICAgIG91dCB2ZWMyIHZURVhDT09SRF8wO1xcbiAgI2VuZGlmXFxuI2VuZGlmXFxudm9pZCBtYWluKHZvaWQpIHtcXG4gICNpZiBkZWZpbmVkKEhBU19VVikgJiYgIWRlZmluZWQoTU9EVUxFX1BCUilcXG4gICAgdlRFWENPT1JEXzAgPSBURVhDT09SRF8wO1xcbiAgICBnZW9tZXRyeS51diA9IHZURVhDT09SRF8wO1xcbiAgI2VuZGlmXFxuXFxuICBnZW9tZXRyeS53b3JsZFBvc2l0aW9uID0gaW5zdGFuY2VQb3NpdGlvbnM7XFxuICBnZW9tZXRyeS5waWNraW5nQ29sb3IgPSBpbnN0YW5jZVBpY2tpbmdDb2xvcnM7XFxuXFxuICB2ZWMzIG5vcm1hbCA9IHZlYzMoMC4wLCAwLjAsIDEuMCk7XFxuICAjaWZkZWYgTU9EVUxFX1BCUlxcbiAgICAjaWZkZWYgSEFTX05PUk1BTFNcXG4gICAgICBub3JtYWwgPSBpbnN0YW5jZU1vZGVsTWF0cml4ICogKHNjZW5lTW9kZWxNYXRyaXggKiB2ZWM0KE5PUk1BTC54eXosIDAuMCkpLnh5ejtcXG4gICAgI2VuZGlmXFxuICAjZW5kaWZcXG5cXG4gIGZsb2F0IG9yaWdpbmFsU2l6ZSA9IHByb2plY3Rfc2l6ZV90b19waXhlbChzaXplU2NhbGUpO1xcbiAgZmxvYXQgY2xhbXBlZFNpemUgPSBjbGFtcChvcmlnaW5hbFNpemUsIHNpemVNaW5QaXhlbHMsIHNpemVNYXhQaXhlbHMpO1xcblxcbiAgdmVjMyBwb3MgPSAoaW5zdGFuY2VNb2RlbE1hdHJpeCAqIChzY2VuZU1vZGVsTWF0cml4ICogUE9TSVRJT04pLnh5eikgKiBzaXplU2NhbGUgKiAoY2xhbXBlZFNpemUgLyBvcmlnaW5hbFNpemUpICsgaW5zdGFuY2VUcmFuc2xhdGlvbjtcXG4gIGlmKGNvbXBvc2VNb2RlbE1hdHJpeCkge1xcbiAgICBERUNLR0xfRklMVEVSX1NJWkUocG9zLCBnZW9tZXRyeSk7XFxuICAgIGdlb21ldHJ5Lm5vcm1hbCA9IHByb2plY3Rfbm9ybWFsKG5vcm1hbCk7XFxuICAgIGdlb21ldHJ5LndvcmxkUG9zaXRpb24gKz0gcG9zO1xcbiAgICBnbF9Qb3NpdGlvbiA9IHByb2plY3RfcG9zaXRpb25fdG9fY2xpcHNwYWNlKHBvcyArIGluc3RhbmNlUG9zaXRpb25zLCBpbnN0YW5jZVBvc2l0aW9uczY0TG93LCB2ZWMzKDAuMCksIGdlb21ldHJ5LnBvc2l0aW9uKTtcXG4gIH1cXG4gIGVsc2Uge1xcbiAgICBwb3MgPSBwcm9qZWN0X3NpemUocG9zKTtcXG4gICAgREVDS0dMX0ZJTFRFUl9TSVpFKHBvcywgZ2VvbWV0cnkpO1xcbiAgICBnbF9Qb3NpdGlvbiA9IHByb2plY3RfcG9zaXRpb25fdG9fY2xpcHNwYWNlKGluc3RhbmNlUG9zaXRpb25zLCBpbnN0YW5jZVBvc2l0aW9uczY0TG93LCBwb3MsIGdlb21ldHJ5LnBvc2l0aW9uKTtcXG4gICAgZ2VvbWV0cnkubm9ybWFsID0gcHJvamVjdF9ub3JtYWwobm9ybWFsKTtcXG4gIH1cXG4gIERFQ0tHTF9GSUxURVJfR0xfUE9TSVRJT04oZ2xfUG9zaXRpb24sIGdlb21ldHJ5KTtcXG5cXG4gICNpZmRlZiBNT0RVTEVfUEJSXFxuICAgIHBicl92UG9zaXRpb24gPSBnZW9tZXRyeS5wb3NpdGlvbi54eXo7XFxuICAgICNpZmRlZiBIQVNfTk9STUFMU1xcbiAgICAgIHBicl92Tm9ybWFsID0gZ2VvbWV0cnkubm9ybWFsO1xcbiAgICAjZW5kaWZcXG5cXG4gICAgI2lmZGVmIEhBU19VVlxcbiAgICAgIHBicl92VVYgPSBURVhDT09SRF8wO1xcbiAgICAjZWxzZVxcbiAgICAgIHBicl92VVYgPSB2ZWMyKDAuLCAwLik7XFxuICAgICNlbmRpZlxcbiAgICBnZW9tZXRyeS51diA9IHBicl92VVY7XFxuICAjZW5kaWZcXG5cXG4gIHZDb2xvciA9IGluc3RhbmNlQ29sb3JzO1xcbiAgREVDS0dMX0ZJTFRFUl9DT0xPUih2Q29sb3IsIGdlb21ldHJ5KTtcXG59XFxuXCI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zY2VuZWdyYXBoLWxheWVyLXZlcnRleC5nbHNsLmpzLm1hcCIsImV4cG9ydCBkZWZhdWx0IFwiI3ZlcnNpb24gMzAwIGVzXFxudW5pZm9ybSBmbG9hdCBvcGFjaXR5O1xcbmluIHZlYzQgdkNvbG9yO1xcblxcbm91dCB2ZWM0IGZyYWdtZW50Q29sb3I7XFxuI2lmbmRlZiBNT0RVTEVfUEJSXFxuICAjaWYgZGVmaW5lZChIQVNfVVYpICYmIGRlZmluZWQoSEFTX0JBU0VDT0xPUk1BUClcXG4gICAgaW4gdmVjMiB2VEVYQ09PUkRfMDtcXG4gICAgdW5pZm9ybSBzYW1wbGVyMkQgdV9CYXNlQ29sb3JTYW1wbGVyO1xcbiAgI2VuZGlmXFxuI2VuZGlmXFxuXFxudm9pZCBtYWluKHZvaWQpIHtcXG4gICNpZmRlZiBNT0RVTEVfUEJSXFxuICAgIGZyYWdtZW50Q29sb3IgPSB2Q29sb3IgKiBwYnJfZmlsdGVyQ29sb3IodmVjNCgwKSk7XFxuICAgIGdlb21ldHJ5LnV2ID0gcGJyX3ZVVjtcXG4gICNlbHNlXFxuICAgICNpZiBkZWZpbmVkKEhBU19VVikgJiYgZGVmaW5lZChIQVNfQkFTRUNPTE9STUFQKVxcbiAgICAgIGZyYWdtZW50Q29sb3IgPSB2Q29sb3IgKiB0ZXh0dXJlMkQodV9CYXNlQ29sb3JTYW1wbGVyLCB2VEVYQ09PUkRfMCk7XFxuICAgICAgZ2VvbWV0cnkudXYgPSB2VEVYQ09PUkRfMDtcXG4gICAgI2Vsc2VcXG4gICAgICBmcmFnbWVudENvbG9yID0gdkNvbG9yO1xcbiAgICAjZW5kaWZcXG4gICNlbmRpZlxcblxcbiAgZnJhZ21lbnRDb2xvci5hICo9IG9wYWNpdHk7XFxuICBERUNLR0xfRklMVEVSX0NPTE9SKGZyYWdtZW50Q29sb3IsIGdlb21ldHJ5KTtcXG59XFxuXCI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zY2VuZWdyYXBoLWxheWVyLWZyYWdtZW50Lmdsc2wuanMubWFwIiwiaW1wb3J0IF9kZWZpbmVQcm9wZXJ0eSBmcm9tIFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vZGVmaW5lUHJvcGVydHlcIjtcbmltcG9ydCB7IExheWVyLCBwcm9qZWN0MzIsIHBpY2tpbmcsIGxvZyB9IGZyb20gJ0BkZWNrLmdsL2NvcmUnO1xuaW1wb3J0IHsgaXNXZWJHTDIgfSBmcm9tICdAbHVtYS5nbC9jb3JlJztcbmltcG9ydCB7IHBiciB9IGZyb20gJ0BsdW1hLmdsL3NoYWRlcnRvb2xzJztcbmltcG9ydCB7IFNjZW5lZ3JhcGhOb2RlLCBjcmVhdGVHTFRGT2JqZWN0cyB9IGZyb20gJ0BsdW1hLmdsL2V4cGVyaW1lbnRhbCc7XG5pbXBvcnQgeyBHTFRGTG9hZGVyIH0gZnJvbSAnQGxvYWRlcnMuZ2wvZ2x0Zic7XG5pbXBvcnQgeyB3YWl0Rm9yR0xURkFzc2V0cyB9IGZyb20gJy4vZ2x0Zi11dGlscyc7XG5pbXBvcnQgeyBNQVRSSVhfQVRUUklCVVRFUywgc2hvdWxkQ29tcG9zZU1vZGVsTWF0cml4IH0gZnJvbSAnLi4vdXRpbHMvbWF0cml4JztcbmltcG9ydCB2cyBmcm9tICcuL3NjZW5lZ3JhcGgtbGF5ZXItdmVydGV4Lmdsc2wnO1xuaW1wb3J0IGZzIGZyb20gJy4vc2NlbmVncmFwaC1sYXllci1mcmFnbWVudC5nbHNsJztcbmNvbnN0IERFRkFVTFRfQ09MT1IgPSBbMjU1LCAyNTUsIDI1NSwgMjU1XTtcbmNvbnN0IGRlZmF1bHRQcm9wcyA9IHtcbiAgc2NlbmVncmFwaDoge1xuICAgIHR5cGU6ICdvYmplY3QnLFxuICAgIHZhbHVlOiBudWxsLFxuICAgIGFzeW5jOiB0cnVlXG4gIH0sXG4gIGdldFNjZW5lOiBnbHRmID0+IHtcbiAgICBpZiAoZ2x0ZiAmJiBnbHRmLnNjZW5lcykge1xuICAgICAgcmV0dXJuIHR5cGVvZiBnbHRmLnNjZW5lID09PSAnb2JqZWN0JyA/IGdsdGYuc2NlbmUgOiBnbHRmLnNjZW5lc1tnbHRmLnNjZW5lIHx8IDBdO1xuICAgIH1cblxuICAgIHJldHVybiBnbHRmO1xuICB9LFxuICBnZXRBbmltYXRvcjogc2NlbmVncmFwaCA9PiBzY2VuZWdyYXBoICYmIHNjZW5lZ3JhcGguYW5pbWF0b3IsXG4gIF9hbmltYXRpb25zOiBudWxsLFxuICBzaXplU2NhbGU6IHtcbiAgICB0eXBlOiAnbnVtYmVyJyxcbiAgICB2YWx1ZTogMSxcbiAgICBtaW46IDBcbiAgfSxcbiAgc2l6ZU1pblBpeGVsczoge1xuICAgIHR5cGU6ICdudW1iZXInLFxuICAgIG1pbjogMCxcbiAgICB2YWx1ZTogMFxuICB9LFxuICBzaXplTWF4UGl4ZWxzOiB7XG4gICAgdHlwZTogJ251bWJlcicsXG4gICAgbWluOiAwLFxuICAgIHZhbHVlOiBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUlxuICB9LFxuICBnZXRQb3NpdGlvbjoge1xuICAgIHR5cGU6ICdhY2Nlc3NvcicsXG4gICAgdmFsdWU6IHggPT4geC5wb3NpdGlvblxuICB9LFxuICBnZXRDb2xvcjoge1xuICAgIHR5cGU6ICdhY2Nlc3NvcicsXG4gICAgdmFsdWU6IERFRkFVTFRfQ09MT1JcbiAgfSxcbiAgX2xpZ2h0aW5nOiAnZmxhdCcsXG4gIF9pbWFnZUJhc2VkTGlnaHRpbmdFbnZpcm9ubWVudDogbnVsbCxcbiAgZ2V0T3JpZW50YXRpb246IHtcbiAgICB0eXBlOiAnYWNjZXNzb3InLFxuICAgIHZhbHVlOiBbMCwgMCwgMF1cbiAgfSxcbiAgZ2V0U2NhbGU6IHtcbiAgICB0eXBlOiAnYWNjZXNzb3InLFxuICAgIHZhbHVlOiBbMSwgMSwgMV1cbiAgfSxcbiAgZ2V0VHJhbnNsYXRpb246IHtcbiAgICB0eXBlOiAnYWNjZXNzb3InLFxuICAgIHZhbHVlOiBbMCwgMCwgMF1cbiAgfSxcbiAgZ2V0VHJhbnNmb3JtTWF0cml4OiB7XG4gICAgdHlwZTogJ2FjY2Vzc29yJyxcbiAgICB2YWx1ZTogW11cbiAgfSxcbiAgbG9hZGVyczogW0dMVEZMb2FkZXJdXG59O1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgU2NlbmVncmFwaExheWVyIGV4dGVuZHMgTGF5ZXIge1xuICBjb25zdHJ1Y3RvciguLi5hcmdzKSB7XG4gICAgc3VwZXIoLi4uYXJncyk7XG5cbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJzdGF0ZVwiLCB2b2lkIDApO1xuICB9XG5cbiAgZ2V0U2hhZGVycygpIHtcbiAgICBjb25zdCBtb2R1bGVzID0gW3Byb2plY3QzMiwgcGlja2luZ107XG5cbiAgICBpZiAodGhpcy5wcm9wcy5fbGlnaHRpbmcgPT09ICdwYnInKSB7XG4gICAgICBtb2R1bGVzLnB1c2gocGJyKTtcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgdnMsXG4gICAgICBmcyxcbiAgICAgIG1vZHVsZXNcbiAgICB9O1xuICB9XG5cbiAgaW5pdGlhbGl6ZVN0YXRlKCkge1xuICAgIGNvbnN0IGF0dHJpYnV0ZU1hbmFnZXIgPSB0aGlzLmdldEF0dHJpYnV0ZU1hbmFnZXIoKTtcbiAgICBhdHRyaWJ1dGVNYW5hZ2VyLmFkZEluc3RhbmNlZCh7XG4gICAgICBpbnN0YW5jZVBvc2l0aW9uczoge1xuICAgICAgICBzaXplOiAzLFxuICAgICAgICB0eXBlOiA1MTMwLFxuICAgICAgICBmcDY0OiB0aGlzLnVzZTY0Yml0UG9zaXRpb25zKCksXG4gICAgICAgIGFjY2Vzc29yOiAnZ2V0UG9zaXRpb24nLFxuICAgICAgICB0cmFuc2l0aW9uOiB0cnVlXG4gICAgICB9LFxuICAgICAgaW5zdGFuY2VDb2xvcnM6IHtcbiAgICAgICAgdHlwZTogNTEyMSxcbiAgICAgICAgc2l6ZTogdGhpcy5wcm9wcy5jb2xvckZvcm1hdC5sZW5ndGgsXG4gICAgICAgIGFjY2Vzc29yOiAnZ2V0Q29sb3InLFxuICAgICAgICBub3JtYWxpemVkOiB0cnVlLFxuICAgICAgICBkZWZhdWx0VmFsdWU6IERFRkFVTFRfQ09MT1IsXG4gICAgICAgIHRyYW5zaXRpb246IHRydWVcbiAgICAgIH0sXG4gICAgICBpbnN0YW5jZU1vZGVsTWF0cml4OiBNQVRSSVhfQVRUUklCVVRFU1xuICAgIH0pO1xuICB9XG5cbiAgdXBkYXRlU3RhdGUocGFyYW1zKSB7XG4gICAgc3VwZXIudXBkYXRlU3RhdGUocGFyYW1zKTtcbiAgICBjb25zdCB7XG4gICAgICBwcm9wcyxcbiAgICAgIG9sZFByb3BzXG4gICAgfSA9IHBhcmFtcztcblxuICAgIGlmIChwcm9wcy5zY2VuZWdyYXBoICE9PSBvbGRQcm9wcy5zY2VuZWdyYXBoKSB7XG4gICAgICB0aGlzLl91cGRhdGVTY2VuZWdyYXBoKCk7XG4gICAgfSBlbHNlIGlmIChwcm9wcy5fYW5pbWF0aW9ucyAhPT0gb2xkUHJvcHMuX2FuaW1hdGlvbnMpIHtcbiAgICAgIHRoaXMuX2FwcGx5QW5pbWF0aW9uc1Byb3AodGhpcy5zdGF0ZS5zY2VuZWdyYXBoLCB0aGlzLnN0YXRlLmFuaW1hdG9yLCBwcm9wcy5fYW5pbWF0aW9ucyk7XG4gICAgfVxuICB9XG5cbiAgZmluYWxpemVTdGF0ZShjb250ZXh0KSB7XG4gICAgc3VwZXIuZmluYWxpemVTdGF0ZShjb250ZXh0KTtcblxuICAgIHRoaXMuX2RlbGV0ZVNjZW5lZ3JhcGgoKTtcbiAgfVxuXG4gIF91cGRhdGVTY2VuZWdyYXBoKCkge1xuICAgIGNvbnN0IHByb3BzID0gdGhpcy5wcm9wcztcbiAgICBjb25zdCB7XG4gICAgICBnbFxuICAgIH0gPSB0aGlzLmNvbnRleHQ7XG4gICAgbGV0IHNjZW5lZ3JhcGhEYXRhID0gbnVsbDtcblxuICAgIGlmIChwcm9wcy5zY2VuZWdyYXBoIGluc3RhbmNlb2YgU2NlbmVncmFwaE5vZGUpIHtcbiAgICAgIHNjZW5lZ3JhcGhEYXRhID0ge1xuICAgICAgICBzY2VuZXM6IFtwcm9wcy5zY2VuZWdyYXBoXVxuICAgICAgfTtcbiAgICB9IGVsc2UgaWYgKHByb3BzLnNjZW5lZ3JhcGggJiYgIXByb3BzLnNjZW5lZ3JhcGguZ2x0Zikge1xuICAgICAgY29uc3QgZ2x0ZiA9IHByb3BzLnNjZW5lZ3JhcGg7XG4gICAgICBjb25zdCBnbHRmT2JqZWN0cyA9IGNyZWF0ZUdMVEZPYmplY3RzKGdsLCBnbHRmLCB0aGlzLl9nZXRNb2RlbE9wdGlvbnMoKSk7XG4gICAgICBzY2VuZWdyYXBoRGF0YSA9IHtcbiAgICAgICAgZ2x0ZixcbiAgICAgICAgLi4uZ2x0Zk9iamVjdHNcbiAgICAgIH07XG4gICAgICB3YWl0Rm9yR0xURkFzc2V0cyhnbHRmT2JqZWN0cykudGhlbigoKSA9PiB0aGlzLnNldE5lZWRzUmVkcmF3KCkpO1xuICAgIH0gZWxzZSBpZiAocHJvcHMuc2NlbmVncmFwaCkge1xuICAgICAgbG9nLmRlcHJlY2F0ZWQoJ1NjZW5lZ3JhcGhMYXllci5wcm9wcy5zY2VuZWdyYXBoJywgJ1VzZSBHTFRGTG9hZGVyIGluc3RlYWQgb2YgR0xURlNjZW5lZ3JhcGhMb2FkZXInKSgpO1xuICAgICAgc2NlbmVncmFwaERhdGEgPSBwcm9wcy5zY2VuZWdyYXBoO1xuICAgIH1cblxuICAgIGNvbnN0IG9wdGlvbnMgPSB7XG4gICAgICBsYXllcjogdGhpcyxcbiAgICAgIGdsXG4gICAgfTtcbiAgICBjb25zdCBzY2VuZWdyYXBoID0gcHJvcHMuZ2V0U2NlbmUoc2NlbmVncmFwaERhdGEsIG9wdGlvbnMpO1xuICAgIGNvbnN0IGFuaW1hdG9yID0gcHJvcHMuZ2V0QW5pbWF0b3Ioc2NlbmVncmFwaERhdGEsIG9wdGlvbnMpO1xuXG4gICAgaWYgKHNjZW5lZ3JhcGggaW5zdGFuY2VvZiBTY2VuZWdyYXBoTm9kZSkge1xuICAgICAgdGhpcy5fZGVsZXRlU2NlbmVncmFwaCgpO1xuXG4gICAgICB0aGlzLl9hcHBseUFsbEF0dHJpYnV0ZXMoc2NlbmVncmFwaCk7XG5cbiAgICAgIHRoaXMuX2FwcGx5QW5pbWF0aW9uc1Byb3Aoc2NlbmVncmFwaCwgYW5pbWF0b3IsIHByb3BzLl9hbmltYXRpb25zKTtcblxuICAgICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICAgIHNjZW5lZ3JhcGgsXG4gICAgICAgIGFuaW1hdG9yXG4gICAgICB9KTtcbiAgICB9IGVsc2UgaWYgKHNjZW5lZ3JhcGggIT09IG51bGwpIHtcbiAgICAgIGxvZy53YXJuKCdpbnZhbGlkIHNjZW5lZ3JhcGg6Jywgc2NlbmVncmFwaCkoKTtcbiAgICB9XG4gIH1cblxuICBfYXBwbHlBbGxBdHRyaWJ1dGVzKHNjZW5lZ3JhcGgpIHtcbiAgICBpZiAodGhpcy5zdGF0ZS5hdHRyaWJ1dGVzQXZhaWxhYmxlKSB7XG4gICAgICBjb25zdCBhbGxBdHRyaWJ1dGVzID0gdGhpcy5nZXRBdHRyaWJ1dGVNYW5hZ2VyKCkuZ2V0QXR0cmlidXRlcygpO1xuICAgICAgc2NlbmVncmFwaC50cmF2ZXJzZShtb2RlbCA9PiB7XG4gICAgICAgIHRoaXMuX3NldE1vZGVsQXR0cmlidXRlcyhtb2RlbC5tb2RlbCwgYWxsQXR0cmlidXRlcyk7XG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICBfYXBwbHlBbmltYXRpb25zUHJvcChzY2VuZWdyYXBoLCBhbmltYXRvciwgYW5pbWF0aW9uc1Byb3ApIHtcbiAgICBpZiAoIXNjZW5lZ3JhcGggfHwgIWFuaW1hdG9yIHx8ICFhbmltYXRpb25zUHJvcCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IGFuaW1hdGlvbnMgPSBhbmltYXRvci5nZXRBbmltYXRpb25zKCk7XG4gICAgT2JqZWN0LmtleXMoYW5pbWF0aW9uc1Byb3ApLnNvcnQoKS5mb3JFYWNoKGtleSA9PiB7XG4gICAgICBjb25zdCB2YWx1ZSA9IGFuaW1hdGlvbnNQcm9wW2tleV07XG5cbiAgICAgIGlmIChrZXkgPT09ICcqJykge1xuICAgICAgICBhbmltYXRpb25zLmZvckVhY2goYW5pbWF0aW9uID0+IHtcbiAgICAgICAgICBPYmplY3QuYXNzaWduKGFuaW1hdGlvbiwgdmFsdWUpO1xuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSBpZiAoTnVtYmVyLmlzRmluaXRlKE51bWJlcihrZXkpKSkge1xuICAgICAgICBjb25zdCBudW1iZXIgPSBOdW1iZXIoa2V5KTtcblxuICAgICAgICBpZiAobnVtYmVyID49IDAgJiYgbnVtYmVyIDwgYW5pbWF0aW9ucy5sZW5ndGgpIHtcbiAgICAgICAgICBPYmplY3QuYXNzaWduKGFuaW1hdGlvbnNbbnVtYmVyXSwgdmFsdWUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGxvZy53YXJuKFwiYW5pbWF0aW9uIFwiLmNvbmNhdChrZXksIFwiIG5vdCBmb3VuZFwiKSkoKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgZmluZFJlc3VsdCA9IGFuaW1hdGlvbnMuZmluZCgoe1xuICAgICAgICAgIG5hbWVcbiAgICAgICAgfSkgPT4gbmFtZSA9PT0ga2V5KTtcblxuICAgICAgICBpZiAoZmluZFJlc3VsdCkge1xuICAgICAgICAgIE9iamVjdC5hc3NpZ24oZmluZFJlc3VsdCwgdmFsdWUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGxvZy53YXJuKFwiYW5pbWF0aW9uIFwiLmNvbmNhdChrZXksIFwiIG5vdCBmb3VuZFwiKSkoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgX2RlbGV0ZVNjZW5lZ3JhcGgoKSB7XG4gICAgY29uc3Qge1xuICAgICAgc2NlbmVncmFwaFxuICAgIH0gPSB0aGlzLnN0YXRlO1xuXG4gICAgaWYgKHNjZW5lZ3JhcGggaW5zdGFuY2VvZiBTY2VuZWdyYXBoTm9kZSkge1xuICAgICAgc2NlbmVncmFwaC5kZWxldGUoKTtcbiAgICB9XG4gIH1cblxuICBfZ2V0TW9kZWxPcHRpb25zKCkge1xuICAgIGNvbnN0IHtcbiAgICAgIF9pbWFnZUJhc2VkTGlnaHRpbmdFbnZpcm9ubWVudFxuICAgIH0gPSB0aGlzLnByb3BzO1xuICAgIGxldCBlbnYgPSBudWxsO1xuXG4gICAgaWYgKF9pbWFnZUJhc2VkTGlnaHRpbmdFbnZpcm9ubWVudCkge1xuICAgICAgaWYgKHR5cGVvZiBfaW1hZ2VCYXNlZExpZ2h0aW5nRW52aXJvbm1lbnQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgZW52ID0gX2ltYWdlQmFzZWRMaWdodGluZ0Vudmlyb25tZW50KHtcbiAgICAgICAgICBnbDogdGhpcy5jb250ZXh0LmdsLFxuICAgICAgICAgIGxheWVyOiB0aGlzXG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZW52ID0gX2ltYWdlQmFzZWRMaWdodGluZ0Vudmlyb25tZW50O1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICBnbDogdGhpcy5jb250ZXh0LmdsLFxuICAgICAgd2FpdEZvckZ1bGxMb2FkOiB0cnVlLFxuICAgICAgaW1hZ2VCYXNlZExpZ2h0aW5nRW52aXJvbm1lbnQ6IGVudixcbiAgICAgIG1vZGVsT3B0aW9uczoge1xuICAgICAgICBpc0luc3RhbmNlZDogdHJ1ZSxcbiAgICAgICAgdHJhbnNwaWxlVG9HTFNMMTAwOiAhaXNXZWJHTDIodGhpcy5jb250ZXh0LmdsKSxcbiAgICAgICAgLi4udGhpcy5nZXRTaGFkZXJzKClcbiAgICAgIH0sXG4gICAgICB1c2VUYW5nZW50czogZmFsc2VcbiAgICB9O1xuICB9XG5cbiAgdXBkYXRlQXR0cmlidXRlcyhjaGFuZ2VkQXR0cmlidXRlcykge1xuICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgICAgYXR0cmlidXRlc0F2YWlsYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIGlmICghdGhpcy5zdGF0ZS5zY2VuZWdyYXBoKSByZXR1cm47XG4gICAgdGhpcy5zdGF0ZS5zY2VuZWdyYXBoLnRyYXZlcnNlKG1vZGVsID0+IHtcbiAgICAgIHRoaXMuX3NldE1vZGVsQXR0cmlidXRlcyhtb2RlbC5tb2RlbCwgY2hhbmdlZEF0dHJpYnV0ZXMpO1xuICAgIH0pO1xuICB9XG5cbiAgZHJhdyh7XG4gICAgbW9kdWxlUGFyYW1ldGVycyA9IG51bGwsXG4gICAgcGFyYW1ldGVycyA9IHt9LFxuICAgIGNvbnRleHRcbiAgfSkge1xuICAgIGlmICghdGhpcy5zdGF0ZS5zY2VuZWdyYXBoKSByZXR1cm47XG5cbiAgICBpZiAodGhpcy5wcm9wcy5fYW5pbWF0aW9ucyAmJiB0aGlzLnN0YXRlLmFuaW1hdG9yKSB7XG4gICAgICB0aGlzLnN0YXRlLmFuaW1hdG9yLmFuaW1hdGUoY29udGV4dC50aW1lbGluZS5nZXRUaW1lKCkpO1xuICAgICAgdGhpcy5zZXROZWVkc1JlZHJhdygpO1xuICAgIH1cblxuICAgIGNvbnN0IHtcbiAgICAgIHZpZXdwb3J0XG4gICAgfSA9IHRoaXMuY29udGV4dDtcbiAgICBjb25zdCB7XG4gICAgICBzaXplU2NhbGUsXG4gICAgICBzaXplTWluUGl4ZWxzLFxuICAgICAgc2l6ZU1heFBpeGVscyxcbiAgICAgIG9wYWNpdHksXG4gICAgICBjb29yZGluYXRlU3lzdGVtXG4gICAgfSA9IHRoaXMucHJvcHM7XG4gICAgY29uc3QgbnVtSW5zdGFuY2VzID0gdGhpcy5nZXROdW1JbnN0YW5jZXMoKTtcbiAgICB0aGlzLnN0YXRlLnNjZW5lZ3JhcGgudHJhdmVyc2UoKG1vZGVsLCB7XG4gICAgICB3b3JsZE1hdHJpeFxuICAgIH0pID0+IHtcbiAgICAgIG1vZGVsLm1vZGVsLnNldEluc3RhbmNlQ291bnQobnVtSW5zdGFuY2VzKTtcbiAgICAgIG1vZGVsLnVwZGF0ZU1vZHVsZVNldHRpbmdzKG1vZHVsZVBhcmFtZXRlcnMpO1xuICAgICAgbW9kZWwuZHJhdyh7XG4gICAgICAgIHBhcmFtZXRlcnMsXG4gICAgICAgIHVuaWZvcm1zOiB7XG4gICAgICAgICAgc2l6ZVNjYWxlLFxuICAgICAgICAgIG9wYWNpdHksXG4gICAgICAgICAgc2l6ZU1pblBpeGVscyxcbiAgICAgICAgICBzaXplTWF4UGl4ZWxzLFxuICAgICAgICAgIGNvbXBvc2VNb2RlbE1hdHJpeDogc2hvdWxkQ29tcG9zZU1vZGVsTWF0cml4KHZpZXdwb3J0LCBjb29yZGluYXRlU3lzdGVtKSxcbiAgICAgICAgICBzY2VuZU1vZGVsTWF0cml4OiB3b3JsZE1hdHJpeCxcbiAgICAgICAgICB1X0NhbWVyYTogbW9kZWwubW9kZWwuZ2V0VW5pZm9ybXMoKS5wcm9qZWN0X3VDYW1lcmFQb3NpdGlvblxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuXG59XG5cbl9kZWZpbmVQcm9wZXJ0eShTY2VuZWdyYXBoTGF5ZXIsIFwiZGVmYXVsdFByb3BzXCIsIGRlZmF1bHRQcm9wcyk7XG5cbl9kZWZpbmVQcm9wZXJ0eShTY2VuZWdyYXBoTGF5ZXIsIFwibGF5ZXJOYW1lXCIsICdTY2VuZWdyYXBoTGF5ZXInKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXNjZW5lZ3JhcGgtbGF5ZXIuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///520\n")}}]);