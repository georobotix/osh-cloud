"use strict";(self["webpackChunkvue3_webpack5"]=self["webpackChunkvue3_webpack5"]||[]).push([[3329],{68990:function(__unused_webpack_module,__webpack_exports__,__webpack_require__){eval("\n// EXPORTS\n__webpack_require__.d(__webpack_exports__, {\n  \"Z\": function() { return /* binding */ MapController; }\n});\n\n// UNUSED EXPORTS: MapState\n\n// EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/esm/defineProperty.js\nvar defineProperty = __webpack_require__(82482);\n// EXTERNAL MODULE: ./node_modules/@math.gl/core/dist/esm/lib/common.js\nvar common = __webpack_require__(14034);\n// EXTERNAL MODULE: ./node_modules/@deck.gl/core/dist/esm/transitions/transition.js\nvar transition = __webpack_require__(53630);\n;// CONCATENATED MODULE: ./node_modules/@deck.gl/core/dist/esm/controllers/transition-manager.js\n\n\n\nconst noop = () => {};\n\nconst TRANSITION_EVENTS = {\n  BREAK: 1,\n  SNAP_TO_END: 2,\n  IGNORE: 3\n};\n\nconst DEFAULT_EASING = t => t;\n\nconst DEFAULT_INTERRUPTION = TRANSITION_EVENTS.BREAK;\nclass TransitionManager {\n  constructor(opts) {\n    (0,defineProperty/* default */.Z)(this, \"getControllerState\", void 0);\n\n    (0,defineProperty/* default */.Z)(this, \"props\", void 0);\n\n    (0,defineProperty/* default */.Z)(this, \"propsInTransition\", void 0);\n\n    (0,defineProperty/* default */.Z)(this, \"transition\", void 0);\n\n    (0,defineProperty/* default */.Z)(this, \"onViewStateChange\", void 0);\n\n    (0,defineProperty/* default */.Z)(this, \"onStateChange\", void 0);\n\n    (0,defineProperty/* default */.Z)(this, \"_onTransitionUpdate\", transition => {\n      const {\n        time,\n        settings: {\n          interpolator,\n          startProps,\n          endProps,\n          duration,\n          easing\n        }\n      } = transition;\n      const t = easing(time / duration);\n      const viewport = interpolator.interpolateProps(startProps, endProps, t);\n      this.propsInTransition = this.getControllerState({ ...this.props,\n        ...viewport\n      }).getViewportProps();\n      this.onViewStateChange({\n        viewState: this.propsInTransition,\n        oldViewState: this.props\n      });\n    });\n\n    this.getControllerState = opts.getControllerState;\n    this.propsInTransition = null;\n    this.transition = new transition/* default */.Z(opts.timeline);\n    this.onViewStateChange = opts.onViewStateChange || noop;\n    this.onStateChange = opts.onStateChange || noop;\n  }\n\n  finalize() {\n    this.transition.cancel();\n  }\n\n  getViewportInTransition() {\n    return this.propsInTransition;\n  }\n\n  processViewStateChange(nextProps) {\n    let transitionTriggered = false;\n    const currentProps = this.props;\n    this.props = nextProps;\n\n    if (!currentProps || this._shouldIgnoreViewportChange(currentProps, nextProps)) {\n      return false;\n    }\n\n    if (this._isTransitionEnabled(nextProps)) {\n      let startProps = currentProps;\n\n      if (this.transition.inProgress) {\n        const {\n          interruption,\n          endProps\n        } = this.transition.settings;\n        startProps = { ...currentProps,\n          ...(interruption === TRANSITION_EVENTS.SNAP_TO_END ? endProps : this.propsInTransition || currentProps)\n        };\n      }\n\n      this._triggerTransition(startProps, nextProps);\n\n      transitionTriggered = true;\n    } else {\n      this.transition.cancel();\n    }\n\n    return transitionTriggered;\n  }\n\n  updateTransition() {\n    this.transition.update();\n  }\n\n  _isTransitionEnabled(props) {\n    const {\n      transitionDuration,\n      transitionInterpolator\n    } = props;\n    return (transitionDuration > 0 || transitionDuration === 'auto') && Boolean(transitionInterpolator);\n  }\n\n  _isUpdateDueToCurrentTransition(props) {\n    if (this.transition.inProgress && this.propsInTransition) {\n      return this.transition.settings.interpolator.arePropsEqual(props, this.propsInTransition);\n    }\n\n    return false;\n  }\n\n  _shouldIgnoreViewportChange(currentProps, nextProps) {\n    if (this.transition.inProgress) {\n      return this.transition.settings.interruption === TRANSITION_EVENTS.IGNORE || this._isUpdateDueToCurrentTransition(nextProps);\n    }\n\n    if (this._isTransitionEnabled(nextProps)) {\n      return nextProps.transitionInterpolator.arePropsEqual(currentProps, nextProps);\n    }\n\n    return true;\n  }\n\n  _triggerTransition(startProps, endProps) {\n    const startViewstate = this.getControllerState(startProps);\n    const endViewStateProps = this.getControllerState(endProps).shortestPathFrom(startViewstate);\n    const transitionInterpolator = endProps.transitionInterpolator;\n    const duration = transitionInterpolator.getDuration ? transitionInterpolator.getDuration(startProps, endProps) : endProps.transitionDuration;\n\n    if (duration === 0) {\n      return;\n    }\n\n    const initialProps = transitionInterpolator.initializeProps(startProps, endViewStateProps);\n    this.propsInTransition = {};\n    const transitionSettings = {\n      duration,\n      easing: endProps.transitionEasing || DEFAULT_EASING,\n      interpolator: transitionInterpolator,\n      interruption: endProps.transitionInterruption || DEFAULT_INTERRUPTION,\n      startProps: initialProps.start,\n      endProps: initialProps.end,\n      onStart: endProps.onTransitionStart,\n      onUpdate: this._onTransitionUpdate,\n      onInterrupt: this._onTransitionEnd(endProps.onTransitionInterrupt),\n      onEnd: this._onTransitionEnd(endProps.onTransitionEnd)\n    };\n    this.transition.start(transitionSettings);\n    this.onStateChange({\n      inTransition: true\n    });\n    this.updateTransition();\n  }\n\n  _onTransitionEnd(callback) {\n    return transition => {\n      this.propsInTransition = null;\n      this.onStateChange({\n        inTransition: false,\n        isZooming: false,\n        isPanning: false,\n        isRotating: false\n      });\n      callback === null || callback === void 0 ? void 0 : callback(transition);\n    };\n  }\n\n}\n//# sourceMappingURL=transition-manager.js.map\n// EXTERNAL MODULE: ./node_modules/@deck.gl/core/dist/esm/transitions/linear-interpolator.js + 1 modules\nvar linear_interpolator = __webpack_require__(71958);\n;// CONCATENATED MODULE: ./node_modules/@deck.gl/core/dist/esm/controllers/controller.js\n\n\n\nconst NO_TRANSITION_PROPS = {\n  transitionDuration: 0\n};\nconst DEFAULT_INERTIA = 300;\n\nconst INERTIA_EASING = t => 1 - (1 - t) * (1 - t);\n\nconst EVENT_TYPES = {\n  WHEEL: ['wheel'],\n  PAN: ['panstart', 'panmove', 'panend'],\n  PINCH: ['pinchstart', 'pinchmove', 'pinchend'],\n  TRIPLE_PAN: ['tripanstart', 'tripanmove', 'tripanend'],\n  DOUBLE_TAP: ['doubletap'],\n  KEYBOARD: ['keydown']\n};\nconst pinchEventWorkaround = {};\nclass Controller {\n  constructor(opts) {\n    (0,defineProperty/* default */.Z)(this, \"props\", void 0);\n\n    (0,defineProperty/* default */.Z)(this, \"state\", {});\n\n    (0,defineProperty/* default */.Z)(this, \"transitionManager\", void 0);\n\n    (0,defineProperty/* default */.Z)(this, \"eventManager\", void 0);\n\n    (0,defineProperty/* default */.Z)(this, \"onViewStateChange\", void 0);\n\n    (0,defineProperty/* default */.Z)(this, \"onStateChange\", void 0);\n\n    (0,defineProperty/* default */.Z)(this, \"makeViewport\", void 0);\n\n    (0,defineProperty/* default */.Z)(this, \"_controllerState\", void 0);\n\n    (0,defineProperty/* default */.Z)(this, \"_events\", {});\n\n    (0,defineProperty/* default */.Z)(this, \"_interactionState\", {\n      isDragging: false\n    });\n\n    (0,defineProperty/* default */.Z)(this, \"_customEvents\", []);\n\n    (0,defineProperty/* default */.Z)(this, \"_eventStartBlocked\", null);\n\n    (0,defineProperty/* default */.Z)(this, \"_panMove\", false);\n\n    (0,defineProperty/* default */.Z)(this, \"invertPan\", false);\n\n    (0,defineProperty/* default */.Z)(this, \"dragMode\", 'rotate');\n\n    (0,defineProperty/* default */.Z)(this, \"inertia\", 0);\n\n    (0,defineProperty/* default */.Z)(this, \"scrollZoom\", true);\n\n    (0,defineProperty/* default */.Z)(this, \"dragPan\", true);\n\n    (0,defineProperty/* default */.Z)(this, \"dragRotate\", true);\n\n    (0,defineProperty/* default */.Z)(this, \"doubleClickZoom\", true);\n\n    (0,defineProperty/* default */.Z)(this, \"touchZoom\", true);\n\n    (0,defineProperty/* default */.Z)(this, \"touchRotate\", false);\n\n    (0,defineProperty/* default */.Z)(this, \"keyboard\", true);\n\n    this.transitionManager = new TransitionManager({ ...opts,\n      getControllerState: props => new this.ControllerState(props),\n      onViewStateChange: this._onTransition.bind(this),\n      onStateChange: this._setInteractionState.bind(this)\n    });\n    this.handleEvent = this.handleEvent.bind(this);\n    this.eventManager = opts.eventManager;\n\n    this.onViewStateChange = opts.onViewStateChange || (() => {});\n\n    this.onStateChange = opts.onStateChange || (() => {});\n\n    this.makeViewport = opts.makeViewport;\n  }\n\n  set events(customEvents) {\n    this.toggleEvents(this._customEvents, false);\n    this.toggleEvents(customEvents, true);\n    this._customEvents = customEvents;\n\n    if (this.props) {\n      this.setProps(this.props);\n    }\n  }\n\n  finalize() {\n    for (const eventName in this._events) {\n      if (this._events[eventName]) {\n        var _this$eventManager;\n\n        (_this$eventManager = this.eventManager) === null || _this$eventManager === void 0 ? void 0 : _this$eventManager.off(eventName, this.handleEvent);\n      }\n    }\n\n    this.transitionManager.finalize();\n  }\n\n  handleEvent(event) {\n    this._controllerState = undefined;\n    const eventStartBlocked = this._eventStartBlocked;\n\n    switch (event.type) {\n      case 'panstart':\n        return eventStartBlocked ? false : this._onPanStart(event);\n\n      case 'panmove':\n        return this._onPan(event);\n\n      case 'panend':\n        return this._onPanEnd(event);\n\n      case 'pinchstart':\n        return eventStartBlocked ? false : this._onPinchStart(event);\n\n      case 'pinchmove':\n        return this._onPinch(event);\n\n      case 'pinchend':\n        return this._onPinchEnd(event);\n\n      case 'tripanstart':\n        return eventStartBlocked ? false : this._onTriplePanStart(event);\n\n      case 'tripanmove':\n        return this._onTriplePan(event);\n\n      case 'tripanend':\n        return this._onTriplePanEnd(event);\n\n      case 'doubletap':\n        return this._onDoubleTap(event);\n\n      case 'wheel':\n        return this._onWheel(event);\n\n      case 'keydown':\n        return this._onKeyDown(event);\n\n      default:\n        return false;\n    }\n  }\n\n  get controllerState() {\n    this._controllerState = this._controllerState || new this.ControllerState({\n      makeViewport: this.makeViewport,\n      ...this.props,\n      ...this.state\n    });\n    return this._controllerState;\n  }\n\n  getCenter(event) {\n    const {\n      x,\n      y\n    } = this.props;\n    const {\n      offsetCenter\n    } = event;\n    return [offsetCenter.x - x, offsetCenter.y - y];\n  }\n\n  isPointInBounds(pos, event) {\n    const {\n      width,\n      height\n    } = this.props;\n\n    if (event && event.handled) {\n      return false;\n    }\n\n    const inside = pos[0] >= 0 && pos[0] <= width && pos[1] >= 0 && pos[1] <= height;\n\n    if (inside && event) {\n      event.stopPropagation();\n    }\n\n    return inside;\n  }\n\n  isFunctionKeyPressed(event) {\n    const {\n      srcEvent\n    } = event;\n    return Boolean(srcEvent.metaKey || srcEvent.altKey || srcEvent.ctrlKey || srcEvent.shiftKey);\n  }\n\n  isDragging() {\n    return this._interactionState.isDragging || false;\n  }\n\n  blockEvents(timeout) {\n    const timer = setTimeout(() => {\n      if (this._eventStartBlocked === timer) {\n        this._eventStartBlocked = null;\n      }\n    }, timeout);\n    this._eventStartBlocked = timer;\n  }\n\n  setProps(props) {\n    if (props.dragMode) {\n      this.dragMode = props.dragMode;\n    }\n\n    this.props = props;\n\n    if (!('transitionInterpolator' in props)) {\n      props.transitionInterpolator = this._getTransitionProps().transitionInterpolator;\n    }\n\n    this.transitionManager.processViewStateChange(props);\n    const {\n      inertia\n    } = props;\n    this.inertia = Number.isFinite(inertia) ? inertia : inertia === true ? DEFAULT_INERTIA : 0;\n    const {\n      scrollZoom = true,\n      dragPan = true,\n      dragRotate = true,\n      doubleClickZoom = true,\n      touchZoom = true,\n      touchRotate = false,\n      keyboard = true\n    } = props;\n    const isInteractive = Boolean(this.onViewStateChange);\n    this.toggleEvents(EVENT_TYPES.WHEEL, isInteractive && scrollZoom);\n    this.toggleEvents(EVENT_TYPES.PAN, isInteractive && (dragPan || dragRotate));\n    this.toggleEvents(EVENT_TYPES.PINCH, isInteractive && (touchZoom || touchRotate));\n    this.toggleEvents(EVENT_TYPES.TRIPLE_PAN, isInteractive && touchRotate);\n    this.toggleEvents(EVENT_TYPES.DOUBLE_TAP, isInteractive && doubleClickZoom);\n    this.toggleEvents(EVENT_TYPES.KEYBOARD, isInteractive && keyboard);\n    this.scrollZoom = scrollZoom;\n    this.dragPan = dragPan;\n    this.dragRotate = dragRotate;\n    this.doubleClickZoom = doubleClickZoom;\n    this.touchZoom = touchZoom;\n    this.touchRotate = touchRotate;\n    this.keyboard = keyboard;\n  }\n\n  updateTransition() {\n    this.transitionManager.updateTransition();\n  }\n\n  toggleEvents(eventNames, enabled) {\n    if (this.eventManager) {\n      eventNames.forEach(eventName => {\n        if (this._events[eventName] !== enabled) {\n          this._events[eventName] = enabled;\n\n          if (enabled) {\n            this.eventManager.on(eventName, this.handleEvent);\n          } else {\n            this.eventManager.off(eventName, this.handleEvent);\n          }\n        }\n      });\n    }\n  }\n\n  updateViewport(newControllerState, extraProps = null, interactionState = {}) {\n    const viewState = { ...newControllerState.getViewportProps(),\n      ...extraProps\n    };\n    const changed = this.controllerState !== newControllerState;\n    this.state = newControllerState.getState();\n\n    this._setInteractionState(interactionState);\n\n    if (changed) {\n      const oldViewState = this.controllerState && this.controllerState.getViewportProps();\n\n      if (this.onViewStateChange) {\n        this.onViewStateChange({\n          viewState,\n          interactionState: this._interactionState,\n          oldViewState\n        });\n      }\n    }\n  }\n\n  _onTransition(params) {\n    this.onViewStateChange({ ...params,\n      interactionState: this._interactionState\n    });\n  }\n\n  _setInteractionState(newStates) {\n    Object.assign(this._interactionState, newStates);\n    this.onStateChange(this._interactionState);\n  }\n\n  _onPanStart(event) {\n    const pos = this.getCenter(event);\n\n    if (!this.isPointInBounds(pos, event)) {\n      return false;\n    }\n\n    let alternateMode = this.isFunctionKeyPressed(event) || event.rightButton || false;\n\n    if (this.invertPan || this.dragMode === 'pan') {\n      alternateMode = !alternateMode;\n    }\n\n    const newControllerState = this.controllerState[alternateMode ? 'panStart' : 'rotateStart']({\n      pos\n    });\n    this._panMove = alternateMode;\n    this.updateViewport(newControllerState, NO_TRANSITION_PROPS, {\n      isDragging: true\n    });\n    return true;\n  }\n\n  _onPan(event) {\n    if (!this.isDragging()) {\n      return false;\n    }\n\n    return this._panMove ? this._onPanMove(event) : this._onPanRotate(event);\n  }\n\n  _onPanEnd(event) {\n    if (!this.isDragging()) {\n      return false;\n    }\n\n    return this._panMove ? this._onPanMoveEnd(event) : this._onPanRotateEnd(event);\n  }\n\n  _onPanMove(event) {\n    if (!this.dragPan) {\n      return false;\n    }\n\n    const pos = this.getCenter(event);\n    const newControllerState = this.controllerState.pan({\n      pos\n    });\n    this.updateViewport(newControllerState, NO_TRANSITION_PROPS, {\n      isDragging: true,\n      isPanning: true\n    });\n    return true;\n  }\n\n  _onPanMoveEnd(event) {\n    const {\n      inertia\n    } = this;\n\n    if (this.dragPan && inertia && event.velocity) {\n      const pos = this.getCenter(event);\n      const endPos = [pos[0] + event.velocityX * inertia / 2, pos[1] + event.velocityY * inertia / 2];\n      const newControllerState = this.controllerState.pan({\n        pos: endPos\n      }).panEnd();\n      this.updateViewport(newControllerState, { ...this._getTransitionProps(),\n        transitionDuration: inertia,\n        transitionEasing: INERTIA_EASING\n      }, {\n        isDragging: false,\n        isPanning: true\n      });\n    } else {\n      const newControllerState = this.controllerState.panEnd();\n      this.updateViewport(newControllerState, null, {\n        isDragging: false,\n        isPanning: false\n      });\n    }\n\n    return true;\n  }\n\n  _onPanRotate(event) {\n    if (!this.dragRotate) {\n      return false;\n    }\n\n    const pos = this.getCenter(event);\n    const newControllerState = this.controllerState.rotate({\n      pos\n    });\n    this.updateViewport(newControllerState, NO_TRANSITION_PROPS, {\n      isDragging: true,\n      isRotating: true\n    });\n    return true;\n  }\n\n  _onPanRotateEnd(event) {\n    const {\n      inertia\n    } = this;\n\n    if (this.dragRotate && inertia && event.velocity) {\n      const pos = this.getCenter(event);\n      const endPos = [pos[0] + event.velocityX * inertia / 2, pos[1] + event.velocityY * inertia / 2];\n      const newControllerState = this.controllerState.rotate({\n        pos: endPos\n      }).rotateEnd();\n      this.updateViewport(newControllerState, { ...this._getTransitionProps(),\n        transitionDuration: inertia,\n        transitionEasing: INERTIA_EASING\n      }, {\n        isDragging: false,\n        isRotating: true\n      });\n    } else {\n      const newControllerState = this.controllerState.rotateEnd();\n      this.updateViewport(newControllerState, null, {\n        isDragging: false,\n        isRotating: false\n      });\n    }\n\n    return true;\n  }\n\n  _onWheel(event) {\n    if (!this.scrollZoom) {\n      return false;\n    }\n\n    event.srcEvent.preventDefault();\n    const pos = this.getCenter(event);\n\n    if (!this.isPointInBounds(pos, event)) {\n      return false;\n    }\n\n    const {\n      speed = 0.01,\n      smooth = false\n    } = this.scrollZoom === true ? {} : this.scrollZoom;\n    const {\n      delta\n    } = event;\n    let scale = 2 / (1 + Math.exp(-Math.abs(delta * speed)));\n\n    if (delta < 0 && scale !== 0) {\n      scale = 1 / scale;\n    }\n\n    const newControllerState = this.controllerState.zoom({\n      pos,\n      scale\n    });\n    this.updateViewport(newControllerState, { ...this._getTransitionProps({\n        around: pos\n      }),\n      transitionDuration: smooth ? 250 : 1\n    }, {\n      isZooming: true,\n      isPanning: true\n    });\n    return true;\n  }\n\n  _onTriplePanStart(event) {\n    const pos = this.getCenter(event);\n\n    if (!this.isPointInBounds(pos, event)) {\n      return false;\n    }\n\n    const newControllerState = this.controllerState.rotateStart({\n      pos\n    });\n    this.updateViewport(newControllerState, NO_TRANSITION_PROPS, {\n      isDragging: true\n    });\n    return true;\n  }\n\n  _onTriplePan(event) {\n    if (!this.touchRotate) {\n      return false;\n    }\n\n    if (!this.isDragging()) {\n      return false;\n    }\n\n    const pos = this.getCenter(event);\n    pos[0] -= event.deltaX;\n    const newControllerState = this.controllerState.rotate({\n      pos\n    });\n    this.updateViewport(newControllerState, NO_TRANSITION_PROPS, {\n      isDragging: true,\n      isRotating: true\n    });\n    return true;\n  }\n\n  _onTriplePanEnd(event) {\n    if (!this.isDragging()) {\n      return false;\n    }\n\n    const {\n      inertia\n    } = this;\n\n    if (this.touchRotate && inertia && event.velocityY) {\n      const pos = this.getCenter(event);\n      const endPos = [pos[0], pos[1] += event.velocityY * inertia / 2];\n      const newControllerState = this.controllerState.rotate({\n        pos: endPos\n      });\n      this.updateViewport(newControllerState, { ...this._getTransitionProps(),\n        transitionDuration: inertia,\n        transitionEasing: INERTIA_EASING\n      }, {\n        isDragging: false,\n        isRotating: true\n      });\n      this.blockEvents(inertia);\n    } else {\n      const newControllerState = this.controllerState.rotateEnd();\n      this.updateViewport(newControllerState, null, {\n        isDragging: false,\n        isRotating: false\n      });\n    }\n\n    return true;\n  }\n\n  _onPinchStart(event) {\n    const pos = this.getCenter(event);\n\n    if (!this.isPointInBounds(pos, event)) {\n      return false;\n    }\n\n    const newControllerState = this.controllerState.zoomStart({\n      pos\n    }).rotateStart({\n      pos\n    });\n    pinchEventWorkaround._startPinchRotation = event.rotation;\n    pinchEventWorkaround._lastPinchEvent = event;\n    this.updateViewport(newControllerState, NO_TRANSITION_PROPS, {\n      isDragging: true\n    });\n    return true;\n  }\n\n  _onPinch(event) {\n    if (!this.touchZoom && !this.touchRotate) {\n      return false;\n    }\n\n    if (!this.isDragging()) {\n      return false;\n    }\n\n    let newControllerState = this.controllerState;\n\n    if (this.touchZoom) {\n      const {\n        scale\n      } = event;\n      const pos = this.getCenter(event);\n      newControllerState = newControllerState.zoom({\n        pos,\n        scale\n      });\n    }\n\n    if (this.touchRotate) {\n      const {\n        rotation\n      } = event;\n      newControllerState = newControllerState.rotate({\n        deltaAngleX: pinchEventWorkaround._startPinchRotation - rotation\n      });\n    }\n\n    this.updateViewport(newControllerState, NO_TRANSITION_PROPS, {\n      isDragging: true,\n      isPanning: this.touchZoom,\n      isZooming: this.touchZoom,\n      isRotating: this.touchRotate\n    });\n    pinchEventWorkaround._lastPinchEvent = event;\n    return true;\n  }\n\n  _onPinchEnd(event) {\n    if (!this.isDragging()) {\n      return false;\n    }\n\n    const {\n      inertia\n    } = this;\n    const {\n      _lastPinchEvent\n    } = pinchEventWorkaround;\n\n    if (this.touchZoom && inertia && _lastPinchEvent && event.scale !== _lastPinchEvent.scale) {\n      const pos = this.getCenter(event);\n      let newControllerState = this.controllerState.rotateEnd();\n      const z = Math.log2(event.scale);\n\n      const velocityZ = (z - Math.log2(_lastPinchEvent.scale)) / (event.deltaTime - _lastPinchEvent.deltaTime);\n\n      const endScale = Math.pow(2, z + velocityZ * inertia / 2);\n      newControllerState = newControllerState.zoom({\n        pos,\n        scale: endScale\n      }).zoomEnd();\n      this.updateViewport(newControllerState, { ...this._getTransitionProps({\n          around: pos\n        }),\n        transitionDuration: inertia,\n        transitionEasing: INERTIA_EASING\n      }, {\n        isDragging: false,\n        isPanning: this.touchZoom,\n        isZooming: this.touchZoom,\n        isRotating: false\n      });\n      this.blockEvents(inertia);\n    } else {\n      const newControllerState = this.controllerState.zoomEnd().rotateEnd();\n      this.updateViewport(newControllerState, null, {\n        isDragging: false,\n        isPanning: false,\n        isZooming: false,\n        isRotating: false\n      });\n    }\n\n    pinchEventWorkaround._startPinchRotation = null;\n    pinchEventWorkaround._lastPinchEvent = null;\n    return true;\n  }\n\n  _onDoubleTap(event) {\n    if (!this.doubleClickZoom) {\n      return false;\n    }\n\n    const pos = this.getCenter(event);\n\n    if (!this.isPointInBounds(pos, event)) {\n      return false;\n    }\n\n    const isZoomOut = this.isFunctionKeyPressed(event);\n    const newControllerState = this.controllerState.zoom({\n      pos,\n      scale: isZoomOut ? 0.5 : 2\n    });\n    this.updateViewport(newControllerState, this._getTransitionProps({\n      around: pos\n    }), {\n      isZooming: true,\n      isPanning: true\n    });\n    this.blockEvents(100);\n    return true;\n  }\n\n  _onKeyDown(event) {\n    if (!this.keyboard) {\n      return false;\n    }\n\n    const funcKey = this.isFunctionKeyPressed(event);\n    const {\n      zoomSpeed,\n      moveSpeed,\n      rotateSpeedX,\n      rotateSpeedY\n    } = this.keyboard === true ? {} : this.keyboard;\n    const {\n      controllerState\n    } = this;\n    let newControllerState;\n    const interactionState = {};\n\n    switch (event.srcEvent.code) {\n      case 'Minus':\n        newControllerState = funcKey ? controllerState.zoomOut(zoomSpeed).zoomOut(zoomSpeed) : controllerState.zoomOut(zoomSpeed);\n        interactionState.isZooming = true;\n        break;\n\n      case 'Equal':\n        newControllerState = funcKey ? controllerState.zoomIn(zoomSpeed).zoomIn(zoomSpeed) : controllerState.zoomIn(zoomSpeed);\n        interactionState.isZooming = true;\n        break;\n\n      case 'ArrowLeft':\n        if (funcKey) {\n          newControllerState = controllerState.rotateLeft(rotateSpeedX);\n          interactionState.isRotating = true;\n        } else {\n          newControllerState = controllerState.moveLeft(moveSpeed);\n          interactionState.isPanning = true;\n        }\n\n        break;\n\n      case 'ArrowRight':\n        if (funcKey) {\n          newControllerState = controllerState.rotateRight(rotateSpeedX);\n          interactionState.isRotating = true;\n        } else {\n          newControllerState = controllerState.moveRight(moveSpeed);\n          interactionState.isPanning = true;\n        }\n\n        break;\n\n      case 'ArrowUp':\n        if (funcKey) {\n          newControllerState = controllerState.rotateUp(rotateSpeedY);\n          interactionState.isRotating = true;\n        } else {\n          newControllerState = controllerState.moveUp(moveSpeed);\n          interactionState.isPanning = true;\n        }\n\n        break;\n\n      case 'ArrowDown':\n        if (funcKey) {\n          newControllerState = controllerState.rotateDown(rotateSpeedY);\n          interactionState.isRotating = true;\n        } else {\n          newControllerState = controllerState.moveDown(moveSpeed);\n          interactionState.isPanning = true;\n        }\n\n        break;\n\n      default:\n        return false;\n    }\n\n    this.updateViewport(newControllerState, this._getTransitionProps(), interactionState);\n    return true;\n  }\n\n  _getTransitionProps(opts) {\n    const {\n      transition\n    } = this;\n\n    if (!transition || !transition.transitionInterpolator) {\n      return NO_TRANSITION_PROPS;\n    }\n\n    return opts ? { ...transition,\n      transitionInterpolator: new linear_interpolator/* default */.Z({ ...opts,\n        ...transition.transitionInterpolator.opts,\n        makeViewport: this.controllerState.makeViewport\n      })\n    } : transition;\n  }\n\n}\n//# sourceMappingURL=controller.js.map\n;// CONCATENATED MODULE: ./node_modules/@deck.gl/core/dist/esm/controllers/view-state.js\n\nclass ViewState {\n  constructor(props, state) {\n    (0,defineProperty/* default */.Z)(this, \"_viewportProps\", void 0);\n\n    (0,defineProperty/* default */.Z)(this, \"_state\", void 0);\n\n    this._viewportProps = this.applyConstraints(props);\n    this._state = state;\n  }\n\n  getViewportProps() {\n    return this._viewportProps;\n  }\n\n  getState() {\n    return this._state;\n  }\n\n}\n//# sourceMappingURL=view-state.js.map\n// EXTERNAL MODULE: ./node_modules/@math.gl/web-mercator/dist/esm/index.js + 8 modules\nvar esm = __webpack_require__(78866);\n// EXTERNAL MODULE: ./node_modules/@deck.gl/core/dist/esm/utils/assert.js\nvar assert = __webpack_require__(75304);\n;// CONCATENATED MODULE: ./node_modules/@deck.gl/core/dist/esm/controllers/map-controller.js\n\n\n\n\n\n\n\nconst PITCH_MOUSE_THRESHOLD = 5;\nconst PITCH_ACCEL = 1.2;\nclass MapState extends ViewState {\n  constructor(options) {\n    const {\n      width,\n      height,\n      latitude,\n      longitude,\n      zoom,\n      bearing = 0,\n      pitch = 0,\n      altitude = 1.5,\n      position = [0, 0, 0],\n      maxZoom = 20,\n      minZoom = 0,\n      maxPitch = 60,\n      minPitch = 0,\n      startPanLngLat,\n      startZoomLngLat,\n      startRotatePos,\n      startBearing,\n      startPitch,\n      startZoom,\n      normalize = true\n    } = options;\n    (0,assert/* default */.Z)(Number.isFinite(longitude));\n    (0,assert/* default */.Z)(Number.isFinite(latitude));\n    (0,assert/* default */.Z)(Number.isFinite(zoom));\n    super({\n      width,\n      height,\n      latitude,\n      longitude,\n      zoom,\n      bearing,\n      pitch,\n      altitude,\n      maxZoom,\n      minZoom,\n      maxPitch,\n      minPitch,\n      normalize,\n      position\n    }, {\n      startPanLngLat,\n      startZoomLngLat,\n      startRotatePos,\n      startBearing,\n      startPitch,\n      startZoom\n    });\n\n    (0,defineProperty/* default */.Z)(this, \"makeViewport\", void 0);\n\n    this.makeViewport = options.makeViewport;\n  }\n\n  panStart({\n    pos\n  }) {\n    return this._getUpdatedState({\n      startPanLngLat: this._unproject(pos)\n    });\n  }\n\n  pan({\n    pos,\n    startPos\n  }) {\n    const startPanLngLat = this.getState().startPanLngLat || this._unproject(startPos);\n\n    if (!startPanLngLat) {\n      return this;\n    }\n\n    const viewport = this.makeViewport(this.getViewportProps());\n    const newProps = viewport.panByPosition(startPanLngLat, pos);\n    return this._getUpdatedState(newProps);\n  }\n\n  panEnd() {\n    return this._getUpdatedState({\n      startPanLngLat: null\n    });\n  }\n\n  rotateStart({\n    pos\n  }) {\n    return this._getUpdatedState({\n      startRotatePos: pos,\n      startBearing: this.getViewportProps().bearing,\n      startPitch: this.getViewportProps().pitch\n    });\n  }\n\n  rotate({\n    pos,\n    deltaAngleX = 0,\n    deltaAngleY = 0\n  }) {\n    const {\n      startRotatePos,\n      startBearing,\n      startPitch\n    } = this.getState();\n\n    if (!startRotatePos || startBearing === undefined || startPitch === undefined) {\n      return this;\n    }\n\n    let newRotation;\n\n    if (pos) {\n      newRotation = this._getNewRotation(pos, startRotatePos, startPitch, startBearing);\n    } else {\n      newRotation = {\n        bearing: startBearing + deltaAngleX,\n        pitch: startPitch + deltaAngleY\n      };\n    }\n\n    return this._getUpdatedState(newRotation);\n  }\n\n  rotateEnd() {\n    return this._getUpdatedState({\n      startBearing: null,\n      startPitch: null\n    });\n  }\n\n  zoomStart({\n    pos\n  }) {\n    return this._getUpdatedState({\n      startZoomLngLat: this._unproject(pos),\n      startZoom: this.getViewportProps().zoom\n    });\n  }\n\n  zoom({\n    pos,\n    startPos,\n    scale\n  }) {\n    let {\n      startZoom,\n      startZoomLngLat\n    } = this.getState();\n\n    if (!startZoomLngLat) {\n      startZoom = this.getViewportProps().zoom;\n      startZoomLngLat = this._unproject(startPos) || this._unproject(pos);\n    }\n\n    if (!startZoomLngLat) {\n      return this;\n    }\n\n    const {\n      maxZoom,\n      minZoom\n    } = this.getViewportProps();\n    let zoom = startZoom + Math.log2(scale);\n    zoom = (0,common/* clamp */.uZ)(zoom, minZoom, maxZoom);\n    const zoomedViewport = this.makeViewport({ ...this.getViewportProps(),\n      zoom\n    });\n    return this._getUpdatedState({\n      zoom,\n      ...zoomedViewport.panByPosition(startZoomLngLat, pos)\n    });\n  }\n\n  zoomEnd() {\n    return this._getUpdatedState({\n      startZoomLngLat: null,\n      startZoom: null\n    });\n  }\n\n  zoomIn(speed = 2) {\n    return this._zoomFromCenter(speed);\n  }\n\n  zoomOut(speed = 2) {\n    return this._zoomFromCenter(1 / speed);\n  }\n\n  moveLeft(speed = 100) {\n    return this._panFromCenter([speed, 0]);\n  }\n\n  moveRight(speed = 100) {\n    return this._panFromCenter([-speed, 0]);\n  }\n\n  moveUp(speed = 100) {\n    return this._panFromCenter([0, speed]);\n  }\n\n  moveDown(speed = 100) {\n    return this._panFromCenter([0, -speed]);\n  }\n\n  rotateLeft(speed = 15) {\n    return this._getUpdatedState({\n      bearing: this.getViewportProps().bearing - speed\n    });\n  }\n\n  rotateRight(speed = 15) {\n    return this._getUpdatedState({\n      bearing: this.getViewportProps().bearing + speed\n    });\n  }\n\n  rotateUp(speed = 10) {\n    return this._getUpdatedState({\n      pitch: this.getViewportProps().pitch + speed\n    });\n  }\n\n  rotateDown(speed = 10) {\n    return this._getUpdatedState({\n      pitch: this.getViewportProps().pitch - speed\n    });\n  }\n\n  shortestPathFrom(viewState) {\n    const fromProps = viewState.getViewportProps();\n    const props = { ...this.getViewportProps()\n    };\n    const {\n      bearing,\n      longitude\n    } = props;\n\n    if (Math.abs(bearing - fromProps.bearing) > 180) {\n      props.bearing = bearing < 0 ? bearing + 360 : bearing - 360;\n    }\n\n    if (Math.abs(longitude - fromProps.longitude) > 180) {\n      props.longitude = longitude < 0 ? longitude + 360 : longitude - 360;\n    }\n\n    return props;\n  }\n\n  applyConstraints(props) {\n    const {\n      maxZoom,\n      minZoom,\n      zoom\n    } = props;\n    props.zoom = (0,common/* clamp */.uZ)(zoom, minZoom, maxZoom);\n    const {\n      maxPitch,\n      minPitch,\n      pitch\n    } = props;\n    props.pitch = (0,common/* clamp */.uZ)(pitch, minPitch, maxPitch);\n    const {\n      normalize = true\n    } = props;\n\n    if (normalize) {\n      Object.assign(props, (0,esm/* normalizeViewportProps */.QA)(props));\n    }\n\n    return props;\n  }\n\n  _zoomFromCenter(scale) {\n    const {\n      width,\n      height\n    } = this.getViewportProps();\n    return this.zoom({\n      pos: [width / 2, height / 2],\n      scale\n    });\n  }\n\n  _panFromCenter(offset) {\n    const {\n      width,\n      height\n    } = this.getViewportProps();\n    return this.pan({\n      startPos: [width / 2, height / 2],\n      pos: [width / 2 + offset[0], height / 2 + offset[1]]\n    });\n  }\n\n  _getUpdatedState(newProps) {\n    return new this.constructor({\n      makeViewport: this.makeViewport,\n      ...this.getViewportProps(),\n      ...this.getState(),\n      ...newProps\n    });\n  }\n\n  _unproject(pos) {\n    const viewport = this.makeViewport(this.getViewportProps());\n    return pos && viewport.unproject(pos);\n  }\n\n  _getNewRotation(pos, startPos, startPitch, startBearing) {\n    const deltaX = pos[0] - startPos[0];\n    const deltaY = pos[1] - startPos[1];\n    const centerY = pos[1];\n    const startY = startPos[1];\n    const {\n      width,\n      height\n    } = this.getViewportProps();\n    const deltaScaleX = deltaX / width;\n    let deltaScaleY = 0;\n\n    if (deltaY > 0) {\n      if (Math.abs(height - startY) > PITCH_MOUSE_THRESHOLD) {\n        deltaScaleY = deltaY / (startY - height) * PITCH_ACCEL;\n      }\n    } else if (deltaY < 0) {\n      if (startY > PITCH_MOUSE_THRESHOLD) {\n        deltaScaleY = 1 - centerY / startY;\n      }\n    }\n\n    deltaScaleY = (0,common/* clamp */.uZ)(deltaScaleY, -1, 1);\n    const {\n      minPitch,\n      maxPitch\n    } = this.getViewportProps();\n    const bearing = startBearing + 180 * deltaScaleX;\n    let pitch = startPitch;\n\n    if (deltaScaleY > 0) {\n      pitch = startPitch + deltaScaleY * (maxPitch - startPitch);\n    } else if (deltaScaleY < 0) {\n      pitch = startPitch - deltaScaleY * (minPitch - startPitch);\n    }\n\n    return {\n      pitch,\n      bearing\n    };\n  }\n\n}\nclass MapController extends Controller {\n  constructor(...args) {\n    super(...args);\n\n    (0,defineProperty/* default */.Z)(this, \"ControllerState\", MapState);\n\n    (0,defineProperty/* default */.Z)(this, \"transition\", {\n      transitionDuration: 300,\n      transitionInterpolator: new linear_interpolator/* default */.Z({\n        transitionProps: {\n          compare: ['longitude', 'latitude', 'zoom', 'bearing', 'pitch', 'position'],\n          required: ['longitude', 'latitude', 'zoom']\n        }\n      })\n    });\n\n    (0,defineProperty/* default */.Z)(this, \"dragMode\", 'pan');\n  }\n\n  setProps(props) {\n    props.position = props.position || [0, 0, 0];\n    const oldProps = this.props;\n    super.setProps(props);\n    const dimensionChanged = !oldProps || oldProps.height !== props.height;\n\n    if (dimensionChanged) {\n      this.updateViewport(new this.ControllerState({\n        makeViewport: this.makeViewport,\n        ...props,\n        ...this.state\n      }));\n    }\n  }\n\n}\n//# sourceMappingURL=map-controller.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNjg5OTAuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7O0FBQXdFO0FBQ3JCOztBQUVuRDs7QUFFTztBQUNQO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ2U7QUFDZjtBQUNBLElBQUksaUNBQWU7O0FBRW5CLElBQUksaUNBQWU7O0FBRW5CLElBQUksaUNBQWU7O0FBRW5CLElBQUksaUNBQWU7O0FBRW5CLElBQUksaUNBQWU7O0FBRW5CLElBQUksaUNBQWU7O0FBRW5CLElBQUksaUNBQWU7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSx5REFBeUQ7QUFDekQ7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7O0FBRUw7QUFDQTtBQUNBLDBCQUEwQix5QkFBVTtBQUNwQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVix1QkFBdUI7QUFDdkI7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDhDOzs7O0FDOUt3RTtBQUNuQjtBQUNlO0FBQ3BFO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNlO0FBQ2Y7QUFDQSxJQUFJLGlDQUFlOztBQUVuQixJQUFJLGlDQUFlLGtCQUFrQjs7QUFFckMsSUFBSSxpQ0FBZTs7QUFFbkIsSUFBSSxpQ0FBZTs7QUFFbkIsSUFBSSxpQ0FBZTs7QUFFbkIsSUFBSSxpQ0FBZTs7QUFFbkIsSUFBSSxpQ0FBZTs7QUFFbkIsSUFBSSxpQ0FBZTs7QUFFbkIsSUFBSSxpQ0FBZSxvQkFBb0I7O0FBRXZDLElBQUksaUNBQWU7QUFDbkI7QUFDQSxLQUFLOztBQUVMLElBQUksaUNBQWU7O0FBRW5CLElBQUksaUNBQWU7O0FBRW5CLElBQUksaUNBQWU7O0FBRW5CLElBQUksaUNBQWU7O0FBRW5CLElBQUksaUNBQWU7O0FBRW5CLElBQUksaUNBQWU7O0FBRW5CLElBQUksaUNBQWU7O0FBRW5CLElBQUksaUNBQWU7O0FBRW5CLElBQUksaUNBQWU7O0FBRW5CLElBQUksaUNBQWU7O0FBRW5CLElBQUksaUNBQWU7O0FBRW5CLElBQUksaUNBQWU7O0FBRW5CLElBQUksaUNBQWU7O0FBRW5CLGlDQUFpQyxpQkFBaUIsR0FBRztBQUNyRDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQSxnRUFBZ0U7O0FBRWhFLHdEQUF3RDs7QUFFeEQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTs7QUFFTjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQSw2RUFBNkU7QUFDN0Usd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNOztBQUVOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsZ0RBQWdEO0FBQ2hEO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUCxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTs7QUFFTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLGdEQUFnRDtBQUNoRDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTSxnQ0FBZ0M7QUFDdEM7QUFDQTtBQUNBLE1BQU07QUFDTjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLDhDQUE4QztBQUM5QztBQUNBLE9BQU87QUFDUDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNOztBQUVOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsZ0RBQWdEO0FBQ2hEO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLE1BQU07O0FBRU47QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsZ0RBQWdEO0FBQ2hEO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVB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QUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNlLDRCQUE0QixVQUFVO0FBQ3JEO0FBQ0E7O0FBRUEsSUFBSSxpQ0FBZTs7QUFFbkIsSUFBSSxpQ0FBZTtBQUNuQjtBQUNBLGtDQUFrQyxrQ0FBa0I7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSzs7QUFFTCxJQUFJLGlDQUFlO0FBQ25COztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly92dWUzLXdlYnBhY2s1Ly4vbm9kZV9tb2R1bGVzL0BkZWNrLmdsL2NvcmUvZGlzdC9lc20vY29udHJvbGxlcnMvdHJhbnNpdGlvbi1tYW5hZ2VyLmpzPzI0MjUiLCJ3ZWJwYWNrOi8vdnVlMy13ZWJwYWNrNS8uL25vZGVfbW9kdWxlcy9AZGVjay5nbC9jb3JlL2Rpc3QvZXNtL2NvbnRyb2xsZXJzL2NvbnRyb2xsZXIuanM/MWFlNyIsIndlYnBhY2s6Ly92dWUzLXdlYnBhY2s1Ly4vbm9kZV9tb2R1bGVzL0BkZWNrLmdsL2NvcmUvZGlzdC9lc20vY29udHJvbGxlcnMvdmlldy1zdGF0ZS5qcz8yYmQyIiwid2VicGFjazovL3Z1ZTMtd2VicGFjazUvLi9ub2RlX21vZHVsZXMvQGRlY2suZ2wvY29yZS9kaXN0L2VzbS9jb250cm9sbGVycy9tYXAtY29udHJvbGxlci5qcz9lM2NiIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBfZGVmaW5lUHJvcGVydHkgZnJvbSBcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL2RlZmluZVByb3BlcnR5XCI7XG5pbXBvcnQgVHJhbnNpdGlvbiBmcm9tICcuLi90cmFuc2l0aW9ucy90cmFuc2l0aW9uJztcblxuY29uc3Qgbm9vcCA9ICgpID0+IHt9O1xuXG5leHBvcnQgY29uc3QgVFJBTlNJVElPTl9FVkVOVFMgPSB7XG4gIEJSRUFLOiAxLFxuICBTTkFQX1RPX0VORDogMixcbiAgSUdOT1JFOiAzXG59O1xuXG5jb25zdCBERUZBVUxUX0VBU0lORyA9IHQgPT4gdDtcblxuY29uc3QgREVGQVVMVF9JTlRFUlJVUFRJT04gPSBUUkFOU0lUSU9OX0VWRU5UUy5CUkVBSztcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFRyYW5zaXRpb25NYW5hZ2VyIHtcbiAgY29uc3RydWN0b3Iob3B0cykge1xuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImdldENvbnRyb2xsZXJTdGF0ZVwiLCB2b2lkIDApO1xuXG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwicHJvcHNcIiwgdm9pZCAwKTtcblxuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInByb3BzSW5UcmFuc2l0aW9uXCIsIHZvaWQgMCk7XG5cbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJ0cmFuc2l0aW9uXCIsIHZvaWQgMCk7XG5cbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJvblZpZXdTdGF0ZUNoYW5nZVwiLCB2b2lkIDApO1xuXG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwib25TdGF0ZUNoYW5nZVwiLCB2b2lkIDApO1xuXG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwiX29uVHJhbnNpdGlvblVwZGF0ZVwiLCB0cmFuc2l0aW9uID0+IHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgdGltZSxcbiAgICAgICAgc2V0dGluZ3M6IHtcbiAgICAgICAgICBpbnRlcnBvbGF0b3IsXG4gICAgICAgICAgc3RhcnRQcm9wcyxcbiAgICAgICAgICBlbmRQcm9wcyxcbiAgICAgICAgICBkdXJhdGlvbixcbiAgICAgICAgICBlYXNpbmdcbiAgICAgICAgfVxuICAgICAgfSA9IHRyYW5zaXRpb247XG4gICAgICBjb25zdCB0ID0gZWFzaW5nKHRpbWUgLyBkdXJhdGlvbik7XG4gICAgICBjb25zdCB2aWV3cG9ydCA9IGludGVycG9sYXRvci5pbnRlcnBvbGF0ZVByb3BzKHN0YXJ0UHJvcHMsIGVuZFByb3BzLCB0KTtcbiAgICAgIHRoaXMucHJvcHNJblRyYW5zaXRpb24gPSB0aGlzLmdldENvbnRyb2xsZXJTdGF0ZSh7IC4uLnRoaXMucHJvcHMsXG4gICAgICAgIC4uLnZpZXdwb3J0XG4gICAgICB9KS5nZXRWaWV3cG9ydFByb3BzKCk7XG4gICAgICB0aGlzLm9uVmlld1N0YXRlQ2hhbmdlKHtcbiAgICAgICAgdmlld1N0YXRlOiB0aGlzLnByb3BzSW5UcmFuc2l0aW9uLFxuICAgICAgICBvbGRWaWV3U3RhdGU6IHRoaXMucHJvcHNcbiAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgdGhpcy5nZXRDb250cm9sbGVyU3RhdGUgPSBvcHRzLmdldENvbnRyb2xsZXJTdGF0ZTtcbiAgICB0aGlzLnByb3BzSW5UcmFuc2l0aW9uID0gbnVsbDtcbiAgICB0aGlzLnRyYW5zaXRpb24gPSBuZXcgVHJhbnNpdGlvbihvcHRzLnRpbWVsaW5lKTtcbiAgICB0aGlzLm9uVmlld1N0YXRlQ2hhbmdlID0gb3B0cy5vblZpZXdTdGF0ZUNoYW5nZSB8fCBub29wO1xuICAgIHRoaXMub25TdGF0ZUNoYW5nZSA9IG9wdHMub25TdGF0ZUNoYW5nZSB8fCBub29wO1xuICB9XG5cbiAgZmluYWxpemUoKSB7XG4gICAgdGhpcy50cmFuc2l0aW9uLmNhbmNlbCgpO1xuICB9XG5cbiAgZ2V0Vmlld3BvcnRJblRyYW5zaXRpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMucHJvcHNJblRyYW5zaXRpb247XG4gIH1cblxuICBwcm9jZXNzVmlld1N0YXRlQ2hhbmdlKG5leHRQcm9wcykge1xuICAgIGxldCB0cmFuc2l0aW9uVHJpZ2dlcmVkID0gZmFsc2U7XG4gICAgY29uc3QgY3VycmVudFByb3BzID0gdGhpcy5wcm9wcztcbiAgICB0aGlzLnByb3BzID0gbmV4dFByb3BzO1xuXG4gICAgaWYgKCFjdXJyZW50UHJvcHMgfHwgdGhpcy5fc2hvdWxkSWdub3JlVmlld3BvcnRDaGFuZ2UoY3VycmVudFByb3BzLCBuZXh0UHJvcHMpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX2lzVHJhbnNpdGlvbkVuYWJsZWQobmV4dFByb3BzKSkge1xuICAgICAgbGV0IHN0YXJ0UHJvcHMgPSBjdXJyZW50UHJvcHM7XG5cbiAgICAgIGlmICh0aGlzLnRyYW5zaXRpb24uaW5Qcm9ncmVzcykge1xuICAgICAgICBjb25zdCB7XG4gICAgICAgICAgaW50ZXJydXB0aW9uLFxuICAgICAgICAgIGVuZFByb3BzXG4gICAgICAgIH0gPSB0aGlzLnRyYW5zaXRpb24uc2V0dGluZ3M7XG4gICAgICAgIHN0YXJ0UHJvcHMgPSB7IC4uLmN1cnJlbnRQcm9wcyxcbiAgICAgICAgICAuLi4oaW50ZXJydXB0aW9uID09PSBUUkFOU0lUSU9OX0VWRU5UUy5TTkFQX1RPX0VORCA/IGVuZFByb3BzIDogdGhpcy5wcm9wc0luVHJhbnNpdGlvbiB8fCBjdXJyZW50UHJvcHMpXG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIHRoaXMuX3RyaWdnZXJUcmFuc2l0aW9uKHN0YXJ0UHJvcHMsIG5leHRQcm9wcyk7XG5cbiAgICAgIHRyYW5zaXRpb25UcmlnZ2VyZWQgPSB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnRyYW5zaXRpb24uY2FuY2VsKCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRyYW5zaXRpb25UcmlnZ2VyZWQ7XG4gIH1cblxuICB1cGRhdGVUcmFuc2l0aW9uKCkge1xuICAgIHRoaXMudHJhbnNpdGlvbi51cGRhdGUoKTtcbiAgfVxuXG4gIF9pc1RyYW5zaXRpb25FbmFibGVkKHByb3BzKSB7XG4gICAgY29uc3Qge1xuICAgICAgdHJhbnNpdGlvbkR1cmF0aW9uLFxuICAgICAgdHJhbnNpdGlvbkludGVycG9sYXRvclxuICAgIH0gPSBwcm9wcztcbiAgICByZXR1cm4gKHRyYW5zaXRpb25EdXJhdGlvbiA+IDAgfHwgdHJhbnNpdGlvbkR1cmF0aW9uID09PSAnYXV0bycpICYmIEJvb2xlYW4odHJhbnNpdGlvbkludGVycG9sYXRvcik7XG4gIH1cblxuICBfaXNVcGRhdGVEdWVUb0N1cnJlbnRUcmFuc2l0aW9uKHByb3BzKSB7XG4gICAgaWYgKHRoaXMudHJhbnNpdGlvbi5pblByb2dyZXNzICYmIHRoaXMucHJvcHNJblRyYW5zaXRpb24pIHtcbiAgICAgIHJldHVybiB0aGlzLnRyYW5zaXRpb24uc2V0dGluZ3MuaW50ZXJwb2xhdG9yLmFyZVByb3BzRXF1YWwocHJvcHMsIHRoaXMucHJvcHNJblRyYW5zaXRpb24pO1xuICAgIH1cblxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIF9zaG91bGRJZ25vcmVWaWV3cG9ydENoYW5nZShjdXJyZW50UHJvcHMsIG5leHRQcm9wcykge1xuICAgIGlmICh0aGlzLnRyYW5zaXRpb24uaW5Qcm9ncmVzcykge1xuICAgICAgcmV0dXJuIHRoaXMudHJhbnNpdGlvbi5zZXR0aW5ncy5pbnRlcnJ1cHRpb24gPT09IFRSQU5TSVRJT05fRVZFTlRTLklHTk9SRSB8fCB0aGlzLl9pc1VwZGF0ZUR1ZVRvQ3VycmVudFRyYW5zaXRpb24obmV4dFByb3BzKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5faXNUcmFuc2l0aW9uRW5hYmxlZChuZXh0UHJvcHMpKSB7XG4gICAgICByZXR1cm4gbmV4dFByb3BzLnRyYW5zaXRpb25JbnRlcnBvbGF0b3IuYXJlUHJvcHNFcXVhbChjdXJyZW50UHJvcHMsIG5leHRQcm9wcyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICBfdHJpZ2dlclRyYW5zaXRpb24oc3RhcnRQcm9wcywgZW5kUHJvcHMpIHtcbiAgICBjb25zdCBzdGFydFZpZXdzdGF0ZSA9IHRoaXMuZ2V0Q29udHJvbGxlclN0YXRlKHN0YXJ0UHJvcHMpO1xuICAgIGNvbnN0IGVuZFZpZXdTdGF0ZVByb3BzID0gdGhpcy5nZXRDb250cm9sbGVyU3RhdGUoZW5kUHJvcHMpLnNob3J0ZXN0UGF0aEZyb20oc3RhcnRWaWV3c3RhdGUpO1xuICAgIGNvbnN0IHRyYW5zaXRpb25JbnRlcnBvbGF0b3IgPSBlbmRQcm9wcy50cmFuc2l0aW9uSW50ZXJwb2xhdG9yO1xuICAgIGNvbnN0IGR1cmF0aW9uID0gdHJhbnNpdGlvbkludGVycG9sYXRvci5nZXREdXJhdGlvbiA/IHRyYW5zaXRpb25JbnRlcnBvbGF0b3IuZ2V0RHVyYXRpb24oc3RhcnRQcm9wcywgZW5kUHJvcHMpIDogZW5kUHJvcHMudHJhbnNpdGlvbkR1cmF0aW9uO1xuXG4gICAgaWYgKGR1cmF0aW9uID09PSAwKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3QgaW5pdGlhbFByb3BzID0gdHJhbnNpdGlvbkludGVycG9sYXRvci5pbml0aWFsaXplUHJvcHMoc3RhcnRQcm9wcywgZW5kVmlld1N0YXRlUHJvcHMpO1xuICAgIHRoaXMucHJvcHNJblRyYW5zaXRpb24gPSB7fTtcbiAgICBjb25zdCB0cmFuc2l0aW9uU2V0dGluZ3MgPSB7XG4gICAgICBkdXJhdGlvbixcbiAgICAgIGVhc2luZzogZW5kUHJvcHMudHJhbnNpdGlvbkVhc2luZyB8fCBERUZBVUxUX0VBU0lORyxcbiAgICAgIGludGVycG9sYXRvcjogdHJhbnNpdGlvbkludGVycG9sYXRvcixcbiAgICAgIGludGVycnVwdGlvbjogZW5kUHJvcHMudHJhbnNpdGlvbkludGVycnVwdGlvbiB8fCBERUZBVUxUX0lOVEVSUlVQVElPTixcbiAgICAgIHN0YXJ0UHJvcHM6IGluaXRpYWxQcm9wcy5zdGFydCxcbiAgICAgIGVuZFByb3BzOiBpbml0aWFsUHJvcHMuZW5kLFxuICAgICAgb25TdGFydDogZW5kUHJvcHMub25UcmFuc2l0aW9uU3RhcnQsXG4gICAgICBvblVwZGF0ZTogdGhpcy5fb25UcmFuc2l0aW9uVXBkYXRlLFxuICAgICAgb25JbnRlcnJ1cHQ6IHRoaXMuX29uVHJhbnNpdGlvbkVuZChlbmRQcm9wcy5vblRyYW5zaXRpb25JbnRlcnJ1cHQpLFxuICAgICAgb25FbmQ6IHRoaXMuX29uVHJhbnNpdGlvbkVuZChlbmRQcm9wcy5vblRyYW5zaXRpb25FbmQpXG4gICAgfTtcbiAgICB0aGlzLnRyYW5zaXRpb24uc3RhcnQodHJhbnNpdGlvblNldHRpbmdzKTtcbiAgICB0aGlzLm9uU3RhdGVDaGFuZ2Uoe1xuICAgICAgaW5UcmFuc2l0aW9uOiB0cnVlXG4gICAgfSk7XG4gICAgdGhpcy51cGRhdGVUcmFuc2l0aW9uKCk7XG4gIH1cblxuICBfb25UcmFuc2l0aW9uRW5kKGNhbGxiYWNrKSB7XG4gICAgcmV0dXJuIHRyYW5zaXRpb24gPT4ge1xuICAgICAgdGhpcy5wcm9wc0luVHJhbnNpdGlvbiA9IG51bGw7XG4gICAgICB0aGlzLm9uU3RhdGVDaGFuZ2Uoe1xuICAgICAgICBpblRyYW5zaXRpb246IGZhbHNlLFxuICAgICAgICBpc1pvb21pbmc6IGZhbHNlLFxuICAgICAgICBpc1Bhbm5pbmc6IGZhbHNlLFxuICAgICAgICBpc1JvdGF0aW5nOiBmYWxzZVxuICAgICAgfSk7XG4gICAgICBjYWxsYmFjayA9PT0gbnVsbCB8fCBjYWxsYmFjayA9PT0gdm9pZCAwID8gdm9pZCAwIDogY2FsbGJhY2sodHJhbnNpdGlvbik7XG4gICAgfTtcbiAgfVxuXG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD10cmFuc2l0aW9uLW1hbmFnZXIuanMubWFwIiwiaW1wb3J0IF9kZWZpbmVQcm9wZXJ0eSBmcm9tIFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vZGVmaW5lUHJvcGVydHlcIjtcbmltcG9ydCBUcmFuc2l0aW9uTWFuYWdlciBmcm9tICcuL3RyYW5zaXRpb24tbWFuYWdlcic7XG5pbXBvcnQgTGluZWFySW50ZXJwb2xhdG9yIGZyb20gJy4uL3RyYW5zaXRpb25zL2xpbmVhci1pbnRlcnBvbGF0b3InO1xuY29uc3QgTk9fVFJBTlNJVElPTl9QUk9QUyA9IHtcbiAgdHJhbnNpdGlvbkR1cmF0aW9uOiAwXG59O1xuY29uc3QgREVGQVVMVF9JTkVSVElBID0gMzAwO1xuXG5jb25zdCBJTkVSVElBX0VBU0lORyA9IHQgPT4gMSAtICgxIC0gdCkgKiAoMSAtIHQpO1xuXG5jb25zdCBFVkVOVF9UWVBFUyA9IHtcbiAgV0hFRUw6IFsnd2hlZWwnXSxcbiAgUEFOOiBbJ3BhbnN0YXJ0JywgJ3Bhbm1vdmUnLCAncGFuZW5kJ10sXG4gIFBJTkNIOiBbJ3BpbmNoc3RhcnQnLCAncGluY2htb3ZlJywgJ3BpbmNoZW5kJ10sXG4gIFRSSVBMRV9QQU46IFsndHJpcGFuc3RhcnQnLCAndHJpcGFubW92ZScsICd0cmlwYW5lbmQnXSxcbiAgRE9VQkxFX1RBUDogWydkb3VibGV0YXAnXSxcbiAgS0VZQk9BUkQ6IFsna2V5ZG93biddXG59O1xuY29uc3QgcGluY2hFdmVudFdvcmthcm91bmQgPSB7fTtcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIENvbnRyb2xsZXIge1xuICBjb25zdHJ1Y3RvcihvcHRzKSB7XG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwicHJvcHNcIiwgdm9pZCAwKTtcblxuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInN0YXRlXCIsIHt9KTtcblxuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInRyYW5zaXRpb25NYW5hZ2VyXCIsIHZvaWQgMCk7XG5cbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJldmVudE1hbmFnZXJcIiwgdm9pZCAwKTtcblxuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIm9uVmlld1N0YXRlQ2hhbmdlXCIsIHZvaWQgMCk7XG5cbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJvblN0YXRlQ2hhbmdlXCIsIHZvaWQgMCk7XG5cbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJtYWtlVmlld3BvcnRcIiwgdm9pZCAwKTtcblxuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIl9jb250cm9sbGVyU3RhdGVcIiwgdm9pZCAwKTtcblxuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIl9ldmVudHNcIiwge30pO1xuXG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwiX2ludGVyYWN0aW9uU3RhdGVcIiwge1xuICAgICAgaXNEcmFnZ2luZzogZmFsc2VcbiAgICB9KTtcblxuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIl9jdXN0b21FdmVudHNcIiwgW10pO1xuXG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwiX2V2ZW50U3RhcnRCbG9ja2VkXCIsIG51bGwpO1xuXG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwiX3Bhbk1vdmVcIiwgZmFsc2UpO1xuXG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwiaW52ZXJ0UGFuXCIsIGZhbHNlKTtcblxuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImRyYWdNb2RlXCIsICdyb3RhdGUnKTtcblxuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImluZXJ0aWFcIiwgMCk7XG5cbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJzY3JvbGxab29tXCIsIHRydWUpO1xuXG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwiZHJhZ1BhblwiLCB0cnVlKTtcblxuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImRyYWdSb3RhdGVcIiwgdHJ1ZSk7XG5cbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJkb3VibGVDbGlja1pvb21cIiwgdHJ1ZSk7XG5cbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJ0b3VjaFpvb21cIiwgdHJ1ZSk7XG5cbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJ0b3VjaFJvdGF0ZVwiLCBmYWxzZSk7XG5cbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJrZXlib2FyZFwiLCB0cnVlKTtcblxuICAgIHRoaXMudHJhbnNpdGlvbk1hbmFnZXIgPSBuZXcgVHJhbnNpdGlvbk1hbmFnZXIoeyAuLi5vcHRzLFxuICAgICAgZ2V0Q29udHJvbGxlclN0YXRlOiBwcm9wcyA9PiBuZXcgdGhpcy5Db250cm9sbGVyU3RhdGUocHJvcHMpLFxuICAgICAgb25WaWV3U3RhdGVDaGFuZ2U6IHRoaXMuX29uVHJhbnNpdGlvbi5iaW5kKHRoaXMpLFxuICAgICAgb25TdGF0ZUNoYW5nZTogdGhpcy5fc2V0SW50ZXJhY3Rpb25TdGF0ZS5iaW5kKHRoaXMpXG4gICAgfSk7XG4gICAgdGhpcy5oYW5kbGVFdmVudCA9IHRoaXMuaGFuZGxlRXZlbnQuYmluZCh0aGlzKTtcbiAgICB0aGlzLmV2ZW50TWFuYWdlciA9IG9wdHMuZXZlbnRNYW5hZ2VyO1xuXG4gICAgdGhpcy5vblZpZXdTdGF0ZUNoYW5nZSA9IG9wdHMub25WaWV3U3RhdGVDaGFuZ2UgfHwgKCgpID0+IHt9KTtcblxuICAgIHRoaXMub25TdGF0ZUNoYW5nZSA9IG9wdHMub25TdGF0ZUNoYW5nZSB8fCAoKCkgPT4ge30pO1xuXG4gICAgdGhpcy5tYWtlVmlld3BvcnQgPSBvcHRzLm1ha2VWaWV3cG9ydDtcbiAgfVxuXG4gIHNldCBldmVudHMoY3VzdG9tRXZlbnRzKSB7XG4gICAgdGhpcy50b2dnbGVFdmVudHModGhpcy5fY3VzdG9tRXZlbnRzLCBmYWxzZSk7XG4gICAgdGhpcy50b2dnbGVFdmVudHMoY3VzdG9tRXZlbnRzLCB0cnVlKTtcbiAgICB0aGlzLl9jdXN0b21FdmVudHMgPSBjdXN0b21FdmVudHM7XG5cbiAgICBpZiAodGhpcy5wcm9wcykge1xuICAgICAgdGhpcy5zZXRQcm9wcyh0aGlzLnByb3BzKTtcbiAgICB9XG4gIH1cblxuICBmaW5hbGl6ZSgpIHtcbiAgICBmb3IgKGNvbnN0IGV2ZW50TmFtZSBpbiB0aGlzLl9ldmVudHMpIHtcbiAgICAgIGlmICh0aGlzLl9ldmVudHNbZXZlbnROYW1lXSkge1xuICAgICAgICB2YXIgX3RoaXMkZXZlbnRNYW5hZ2VyO1xuXG4gICAgICAgIChfdGhpcyRldmVudE1hbmFnZXIgPSB0aGlzLmV2ZW50TWFuYWdlcikgPT09IG51bGwgfHwgX3RoaXMkZXZlbnRNYW5hZ2VyID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfdGhpcyRldmVudE1hbmFnZXIub2ZmKGV2ZW50TmFtZSwgdGhpcy5oYW5kbGVFdmVudCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy50cmFuc2l0aW9uTWFuYWdlci5maW5hbGl6ZSgpO1xuICB9XG5cbiAgaGFuZGxlRXZlbnQoZXZlbnQpIHtcbiAgICB0aGlzLl9jb250cm9sbGVyU3RhdGUgPSB1bmRlZmluZWQ7XG4gICAgY29uc3QgZXZlbnRTdGFydEJsb2NrZWQgPSB0aGlzLl9ldmVudFN0YXJ0QmxvY2tlZDtcblxuICAgIHN3aXRjaCAoZXZlbnQudHlwZSkge1xuICAgICAgY2FzZSAncGFuc3RhcnQnOlxuICAgICAgICByZXR1cm4gZXZlbnRTdGFydEJsb2NrZWQgPyBmYWxzZSA6IHRoaXMuX29uUGFuU3RhcnQoZXZlbnQpO1xuXG4gICAgICBjYXNlICdwYW5tb3ZlJzpcbiAgICAgICAgcmV0dXJuIHRoaXMuX29uUGFuKGV2ZW50KTtcblxuICAgICAgY2FzZSAncGFuZW5kJzpcbiAgICAgICAgcmV0dXJuIHRoaXMuX29uUGFuRW5kKGV2ZW50KTtcblxuICAgICAgY2FzZSAncGluY2hzdGFydCc6XG4gICAgICAgIHJldHVybiBldmVudFN0YXJ0QmxvY2tlZCA/IGZhbHNlIDogdGhpcy5fb25QaW5jaFN0YXJ0KGV2ZW50KTtcblxuICAgICAgY2FzZSAncGluY2htb3ZlJzpcbiAgICAgICAgcmV0dXJuIHRoaXMuX29uUGluY2goZXZlbnQpO1xuXG4gICAgICBjYXNlICdwaW5jaGVuZCc6XG4gICAgICAgIHJldHVybiB0aGlzLl9vblBpbmNoRW5kKGV2ZW50KTtcblxuICAgICAgY2FzZSAndHJpcGFuc3RhcnQnOlxuICAgICAgICByZXR1cm4gZXZlbnRTdGFydEJsb2NrZWQgPyBmYWxzZSA6IHRoaXMuX29uVHJpcGxlUGFuU3RhcnQoZXZlbnQpO1xuXG4gICAgICBjYXNlICd0cmlwYW5tb3ZlJzpcbiAgICAgICAgcmV0dXJuIHRoaXMuX29uVHJpcGxlUGFuKGV2ZW50KTtcblxuICAgICAgY2FzZSAndHJpcGFuZW5kJzpcbiAgICAgICAgcmV0dXJuIHRoaXMuX29uVHJpcGxlUGFuRW5kKGV2ZW50KTtcblxuICAgICAgY2FzZSAnZG91YmxldGFwJzpcbiAgICAgICAgcmV0dXJuIHRoaXMuX29uRG91YmxlVGFwKGV2ZW50KTtcblxuICAgICAgY2FzZSAnd2hlZWwnOlxuICAgICAgICByZXR1cm4gdGhpcy5fb25XaGVlbChldmVudCk7XG5cbiAgICAgIGNhc2UgJ2tleWRvd24nOlxuICAgICAgICByZXR1cm4gdGhpcy5fb25LZXlEb3duKGV2ZW50KTtcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIGdldCBjb250cm9sbGVyU3RhdGUoKSB7XG4gICAgdGhpcy5fY29udHJvbGxlclN0YXRlID0gdGhpcy5fY29udHJvbGxlclN0YXRlIHx8IG5ldyB0aGlzLkNvbnRyb2xsZXJTdGF0ZSh7XG4gICAgICBtYWtlVmlld3BvcnQ6IHRoaXMubWFrZVZpZXdwb3J0LFxuICAgICAgLi4udGhpcy5wcm9wcyxcbiAgICAgIC4uLnRoaXMuc3RhdGVcbiAgICB9KTtcbiAgICByZXR1cm4gdGhpcy5fY29udHJvbGxlclN0YXRlO1xuICB9XG5cbiAgZ2V0Q2VudGVyKGV2ZW50KSB7XG4gICAgY29uc3Qge1xuICAgICAgeCxcbiAgICAgIHlcbiAgICB9ID0gdGhpcy5wcm9wcztcbiAgICBjb25zdCB7XG4gICAgICBvZmZzZXRDZW50ZXJcbiAgICB9ID0gZXZlbnQ7XG4gICAgcmV0dXJuIFtvZmZzZXRDZW50ZXIueCAtIHgsIG9mZnNldENlbnRlci55IC0geV07XG4gIH1cblxuICBpc1BvaW50SW5Cb3VuZHMocG9zLCBldmVudCkge1xuICAgIGNvbnN0IHtcbiAgICAgIHdpZHRoLFxuICAgICAgaGVpZ2h0XG4gICAgfSA9IHRoaXMucHJvcHM7XG5cbiAgICBpZiAoZXZlbnQgJiYgZXZlbnQuaGFuZGxlZCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGNvbnN0IGluc2lkZSA9IHBvc1swXSA+PSAwICYmIHBvc1swXSA8PSB3aWR0aCAmJiBwb3NbMV0gPj0gMCAmJiBwb3NbMV0gPD0gaGVpZ2h0O1xuXG4gICAgaWYgKGluc2lkZSAmJiBldmVudCkge1xuICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGluc2lkZTtcbiAgfVxuXG4gIGlzRnVuY3Rpb25LZXlQcmVzc2VkKGV2ZW50KSB7XG4gICAgY29uc3Qge1xuICAgICAgc3JjRXZlbnRcbiAgICB9ID0gZXZlbnQ7XG4gICAgcmV0dXJuIEJvb2xlYW4oc3JjRXZlbnQubWV0YUtleSB8fCBzcmNFdmVudC5hbHRLZXkgfHwgc3JjRXZlbnQuY3RybEtleSB8fCBzcmNFdmVudC5zaGlmdEtleSk7XG4gIH1cblxuICBpc0RyYWdnaW5nKCkge1xuICAgIHJldHVybiB0aGlzLl9pbnRlcmFjdGlvblN0YXRlLmlzRHJhZ2dpbmcgfHwgZmFsc2U7XG4gIH1cblxuICBibG9ja0V2ZW50cyh0aW1lb3V0KSB7XG4gICAgY29uc3QgdGltZXIgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIGlmICh0aGlzLl9ldmVudFN0YXJ0QmxvY2tlZCA9PT0gdGltZXIpIHtcbiAgICAgICAgdGhpcy5fZXZlbnRTdGFydEJsb2NrZWQgPSBudWxsO1xuICAgICAgfVxuICAgIH0sIHRpbWVvdXQpO1xuICAgIHRoaXMuX2V2ZW50U3RhcnRCbG9ja2VkID0gdGltZXI7XG4gIH1cblxuICBzZXRQcm9wcyhwcm9wcykge1xuICAgIGlmIChwcm9wcy5kcmFnTW9kZSkge1xuICAgICAgdGhpcy5kcmFnTW9kZSA9IHByb3BzLmRyYWdNb2RlO1xuICAgIH1cblxuICAgIHRoaXMucHJvcHMgPSBwcm9wcztcblxuICAgIGlmICghKCd0cmFuc2l0aW9uSW50ZXJwb2xhdG9yJyBpbiBwcm9wcykpIHtcbiAgICAgIHByb3BzLnRyYW5zaXRpb25JbnRlcnBvbGF0b3IgPSB0aGlzLl9nZXRUcmFuc2l0aW9uUHJvcHMoKS50cmFuc2l0aW9uSW50ZXJwb2xhdG9yO1xuICAgIH1cblxuICAgIHRoaXMudHJhbnNpdGlvbk1hbmFnZXIucHJvY2Vzc1ZpZXdTdGF0ZUNoYW5nZShwcm9wcyk7XG4gICAgY29uc3Qge1xuICAgICAgaW5lcnRpYVxuICAgIH0gPSBwcm9wcztcbiAgICB0aGlzLmluZXJ0aWEgPSBOdW1iZXIuaXNGaW5pdGUoaW5lcnRpYSkgPyBpbmVydGlhIDogaW5lcnRpYSA9PT0gdHJ1ZSA/IERFRkFVTFRfSU5FUlRJQSA6IDA7XG4gICAgY29uc3Qge1xuICAgICAgc2Nyb2xsWm9vbSA9IHRydWUsXG4gICAgICBkcmFnUGFuID0gdHJ1ZSxcbiAgICAgIGRyYWdSb3RhdGUgPSB0cnVlLFxuICAgICAgZG91YmxlQ2xpY2tab29tID0gdHJ1ZSxcbiAgICAgIHRvdWNoWm9vbSA9IHRydWUsXG4gICAgICB0b3VjaFJvdGF0ZSA9IGZhbHNlLFxuICAgICAga2V5Ym9hcmQgPSB0cnVlXG4gICAgfSA9IHByb3BzO1xuICAgIGNvbnN0IGlzSW50ZXJhY3RpdmUgPSBCb29sZWFuKHRoaXMub25WaWV3U3RhdGVDaGFuZ2UpO1xuICAgIHRoaXMudG9nZ2xlRXZlbnRzKEVWRU5UX1RZUEVTLldIRUVMLCBpc0ludGVyYWN0aXZlICYmIHNjcm9sbFpvb20pO1xuICAgIHRoaXMudG9nZ2xlRXZlbnRzKEVWRU5UX1RZUEVTLlBBTiwgaXNJbnRlcmFjdGl2ZSAmJiAoZHJhZ1BhbiB8fCBkcmFnUm90YXRlKSk7XG4gICAgdGhpcy50b2dnbGVFdmVudHMoRVZFTlRfVFlQRVMuUElOQ0gsIGlzSW50ZXJhY3RpdmUgJiYgKHRvdWNoWm9vbSB8fCB0b3VjaFJvdGF0ZSkpO1xuICAgIHRoaXMudG9nZ2xlRXZlbnRzKEVWRU5UX1RZUEVTLlRSSVBMRV9QQU4sIGlzSW50ZXJhY3RpdmUgJiYgdG91Y2hSb3RhdGUpO1xuICAgIHRoaXMudG9nZ2xlRXZlbnRzKEVWRU5UX1RZUEVTLkRPVUJMRV9UQVAsIGlzSW50ZXJhY3RpdmUgJiYgZG91YmxlQ2xpY2tab29tKTtcbiAgICB0aGlzLnRvZ2dsZUV2ZW50cyhFVkVOVF9UWVBFUy5LRVlCT0FSRCwgaXNJbnRlcmFjdGl2ZSAmJiBrZXlib2FyZCk7XG4gICAgdGhpcy5zY3JvbGxab29tID0gc2Nyb2xsWm9vbTtcbiAgICB0aGlzLmRyYWdQYW4gPSBkcmFnUGFuO1xuICAgIHRoaXMuZHJhZ1JvdGF0ZSA9IGRyYWdSb3RhdGU7XG4gICAgdGhpcy5kb3VibGVDbGlja1pvb20gPSBkb3VibGVDbGlja1pvb207XG4gICAgdGhpcy50b3VjaFpvb20gPSB0b3VjaFpvb207XG4gICAgdGhpcy50b3VjaFJvdGF0ZSA9IHRvdWNoUm90YXRlO1xuICAgIHRoaXMua2V5Ym9hcmQgPSBrZXlib2FyZDtcbiAgfVxuXG4gIHVwZGF0ZVRyYW5zaXRpb24oKSB7XG4gICAgdGhpcy50cmFuc2l0aW9uTWFuYWdlci51cGRhdGVUcmFuc2l0aW9uKCk7XG4gIH1cblxuICB0b2dnbGVFdmVudHMoZXZlbnROYW1lcywgZW5hYmxlZCkge1xuICAgIGlmICh0aGlzLmV2ZW50TWFuYWdlcikge1xuICAgICAgZXZlbnROYW1lcy5mb3JFYWNoKGV2ZW50TmFtZSA9PiB7XG4gICAgICAgIGlmICh0aGlzLl9ldmVudHNbZXZlbnROYW1lXSAhPT0gZW5hYmxlZCkge1xuICAgICAgICAgIHRoaXMuX2V2ZW50c1tldmVudE5hbWVdID0gZW5hYmxlZDtcblxuICAgICAgICAgIGlmIChlbmFibGVkKSB7XG4gICAgICAgICAgICB0aGlzLmV2ZW50TWFuYWdlci5vbihldmVudE5hbWUsIHRoaXMuaGFuZGxlRXZlbnQpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmV2ZW50TWFuYWdlci5vZmYoZXZlbnROYW1lLCB0aGlzLmhhbmRsZUV2ZW50KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIHVwZGF0ZVZpZXdwb3J0KG5ld0NvbnRyb2xsZXJTdGF0ZSwgZXh0cmFQcm9wcyA9IG51bGwsIGludGVyYWN0aW9uU3RhdGUgPSB7fSkge1xuICAgIGNvbnN0IHZpZXdTdGF0ZSA9IHsgLi4ubmV3Q29udHJvbGxlclN0YXRlLmdldFZpZXdwb3J0UHJvcHMoKSxcbiAgICAgIC4uLmV4dHJhUHJvcHNcbiAgICB9O1xuICAgIGNvbnN0IGNoYW5nZWQgPSB0aGlzLmNvbnRyb2xsZXJTdGF0ZSAhPT0gbmV3Q29udHJvbGxlclN0YXRlO1xuICAgIHRoaXMuc3RhdGUgPSBuZXdDb250cm9sbGVyU3RhdGUuZ2V0U3RhdGUoKTtcblxuICAgIHRoaXMuX3NldEludGVyYWN0aW9uU3RhdGUoaW50ZXJhY3Rpb25TdGF0ZSk7XG5cbiAgICBpZiAoY2hhbmdlZCkge1xuICAgICAgY29uc3Qgb2xkVmlld1N0YXRlID0gdGhpcy5jb250cm9sbGVyU3RhdGUgJiYgdGhpcy5jb250cm9sbGVyU3RhdGUuZ2V0Vmlld3BvcnRQcm9wcygpO1xuXG4gICAgICBpZiAodGhpcy5vblZpZXdTdGF0ZUNoYW5nZSkge1xuICAgICAgICB0aGlzLm9uVmlld1N0YXRlQ2hhbmdlKHtcbiAgICAgICAgICB2aWV3U3RhdGUsXG4gICAgICAgICAgaW50ZXJhY3Rpb25TdGF0ZTogdGhpcy5faW50ZXJhY3Rpb25TdGF0ZSxcbiAgICAgICAgICBvbGRWaWV3U3RhdGVcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgX29uVHJhbnNpdGlvbihwYXJhbXMpIHtcbiAgICB0aGlzLm9uVmlld1N0YXRlQ2hhbmdlKHsgLi4ucGFyYW1zLFxuICAgICAgaW50ZXJhY3Rpb25TdGF0ZTogdGhpcy5faW50ZXJhY3Rpb25TdGF0ZVxuICAgIH0pO1xuICB9XG5cbiAgX3NldEludGVyYWN0aW9uU3RhdGUobmV3U3RhdGVzKSB7XG4gICAgT2JqZWN0LmFzc2lnbih0aGlzLl9pbnRlcmFjdGlvblN0YXRlLCBuZXdTdGF0ZXMpO1xuICAgIHRoaXMub25TdGF0ZUNoYW5nZSh0aGlzLl9pbnRlcmFjdGlvblN0YXRlKTtcbiAgfVxuXG4gIF9vblBhblN0YXJ0KGV2ZW50KSB7XG4gICAgY29uc3QgcG9zID0gdGhpcy5nZXRDZW50ZXIoZXZlbnQpO1xuXG4gICAgaWYgKCF0aGlzLmlzUG9pbnRJbkJvdW5kcyhwb3MsIGV2ZW50KSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGxldCBhbHRlcm5hdGVNb2RlID0gdGhpcy5pc0Z1bmN0aW9uS2V5UHJlc3NlZChldmVudCkgfHwgZXZlbnQucmlnaHRCdXR0b24gfHwgZmFsc2U7XG5cbiAgICBpZiAodGhpcy5pbnZlcnRQYW4gfHwgdGhpcy5kcmFnTW9kZSA9PT0gJ3BhbicpIHtcbiAgICAgIGFsdGVybmF0ZU1vZGUgPSAhYWx0ZXJuYXRlTW9kZTtcbiAgICB9XG5cbiAgICBjb25zdCBuZXdDb250cm9sbGVyU3RhdGUgPSB0aGlzLmNvbnRyb2xsZXJTdGF0ZVthbHRlcm5hdGVNb2RlID8gJ3BhblN0YXJ0JyA6ICdyb3RhdGVTdGFydCddKHtcbiAgICAgIHBvc1xuICAgIH0pO1xuICAgIHRoaXMuX3Bhbk1vdmUgPSBhbHRlcm5hdGVNb2RlO1xuICAgIHRoaXMudXBkYXRlVmlld3BvcnQobmV3Q29udHJvbGxlclN0YXRlLCBOT19UUkFOU0lUSU9OX1BST1BTLCB7XG4gICAgICBpc0RyYWdnaW5nOiB0cnVlXG4gICAgfSk7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICBfb25QYW4oZXZlbnQpIHtcbiAgICBpZiAoIXRoaXMuaXNEcmFnZ2luZygpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuX3Bhbk1vdmUgPyB0aGlzLl9vblBhbk1vdmUoZXZlbnQpIDogdGhpcy5fb25QYW5Sb3RhdGUoZXZlbnQpO1xuICB9XG5cbiAgX29uUGFuRW5kKGV2ZW50KSB7XG4gICAgaWYgKCF0aGlzLmlzRHJhZ2dpbmcoKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLl9wYW5Nb3ZlID8gdGhpcy5fb25QYW5Nb3ZlRW5kKGV2ZW50KSA6IHRoaXMuX29uUGFuUm90YXRlRW5kKGV2ZW50KTtcbiAgfVxuXG4gIF9vblBhbk1vdmUoZXZlbnQpIHtcbiAgICBpZiAoIXRoaXMuZHJhZ1Bhbikge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGNvbnN0IHBvcyA9IHRoaXMuZ2V0Q2VudGVyKGV2ZW50KTtcbiAgICBjb25zdCBuZXdDb250cm9sbGVyU3RhdGUgPSB0aGlzLmNvbnRyb2xsZXJTdGF0ZS5wYW4oe1xuICAgICAgcG9zXG4gICAgfSk7XG4gICAgdGhpcy51cGRhdGVWaWV3cG9ydChuZXdDb250cm9sbGVyU3RhdGUsIE5PX1RSQU5TSVRJT05fUFJPUFMsIHtcbiAgICAgIGlzRHJhZ2dpbmc6IHRydWUsXG4gICAgICBpc1Bhbm5pbmc6IHRydWVcbiAgICB9KTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIF9vblBhbk1vdmVFbmQoZXZlbnQpIHtcbiAgICBjb25zdCB7XG4gICAgICBpbmVydGlhXG4gICAgfSA9IHRoaXM7XG5cbiAgICBpZiAodGhpcy5kcmFnUGFuICYmIGluZXJ0aWEgJiYgZXZlbnQudmVsb2NpdHkpIHtcbiAgICAgIGNvbnN0IHBvcyA9IHRoaXMuZ2V0Q2VudGVyKGV2ZW50KTtcbiAgICAgIGNvbnN0IGVuZFBvcyA9IFtwb3NbMF0gKyBldmVudC52ZWxvY2l0eVggKiBpbmVydGlhIC8gMiwgcG9zWzFdICsgZXZlbnQudmVsb2NpdHlZICogaW5lcnRpYSAvIDJdO1xuICAgICAgY29uc3QgbmV3Q29udHJvbGxlclN0YXRlID0gdGhpcy5jb250cm9sbGVyU3RhdGUucGFuKHtcbiAgICAgICAgcG9zOiBlbmRQb3NcbiAgICAgIH0pLnBhbkVuZCgpO1xuICAgICAgdGhpcy51cGRhdGVWaWV3cG9ydChuZXdDb250cm9sbGVyU3RhdGUsIHsgLi4udGhpcy5fZ2V0VHJhbnNpdGlvblByb3BzKCksXG4gICAgICAgIHRyYW5zaXRpb25EdXJhdGlvbjogaW5lcnRpYSxcbiAgICAgICAgdHJhbnNpdGlvbkVhc2luZzogSU5FUlRJQV9FQVNJTkdcbiAgICAgIH0sIHtcbiAgICAgICAgaXNEcmFnZ2luZzogZmFsc2UsXG4gICAgICAgIGlzUGFubmluZzogdHJ1ZVxuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IG5ld0NvbnRyb2xsZXJTdGF0ZSA9IHRoaXMuY29udHJvbGxlclN0YXRlLnBhbkVuZCgpO1xuICAgICAgdGhpcy51cGRhdGVWaWV3cG9ydChuZXdDb250cm9sbGVyU3RhdGUsIG51bGwsIHtcbiAgICAgICAgaXNEcmFnZ2luZzogZmFsc2UsXG4gICAgICAgIGlzUGFubmluZzogZmFsc2VcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgX29uUGFuUm90YXRlKGV2ZW50KSB7XG4gICAgaWYgKCF0aGlzLmRyYWdSb3RhdGUpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBjb25zdCBwb3MgPSB0aGlzLmdldENlbnRlcihldmVudCk7XG4gICAgY29uc3QgbmV3Q29udHJvbGxlclN0YXRlID0gdGhpcy5jb250cm9sbGVyU3RhdGUucm90YXRlKHtcbiAgICAgIHBvc1xuICAgIH0pO1xuICAgIHRoaXMudXBkYXRlVmlld3BvcnQobmV3Q29udHJvbGxlclN0YXRlLCBOT19UUkFOU0lUSU9OX1BST1BTLCB7XG4gICAgICBpc0RyYWdnaW5nOiB0cnVlLFxuICAgICAgaXNSb3RhdGluZzogdHJ1ZVxuICAgIH0pO1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgX29uUGFuUm90YXRlRW5kKGV2ZW50KSB7XG4gICAgY29uc3Qge1xuICAgICAgaW5lcnRpYVxuICAgIH0gPSB0aGlzO1xuXG4gICAgaWYgKHRoaXMuZHJhZ1JvdGF0ZSAmJiBpbmVydGlhICYmIGV2ZW50LnZlbG9jaXR5KSB7XG4gICAgICBjb25zdCBwb3MgPSB0aGlzLmdldENlbnRlcihldmVudCk7XG4gICAgICBjb25zdCBlbmRQb3MgPSBbcG9zWzBdICsgZXZlbnQudmVsb2NpdHlYICogaW5lcnRpYSAvIDIsIHBvc1sxXSArIGV2ZW50LnZlbG9jaXR5WSAqIGluZXJ0aWEgLyAyXTtcbiAgICAgIGNvbnN0IG5ld0NvbnRyb2xsZXJTdGF0ZSA9IHRoaXMuY29udHJvbGxlclN0YXRlLnJvdGF0ZSh7XG4gICAgICAgIHBvczogZW5kUG9zXG4gICAgICB9KS5yb3RhdGVFbmQoKTtcbiAgICAgIHRoaXMudXBkYXRlVmlld3BvcnQobmV3Q29udHJvbGxlclN0YXRlLCB7IC4uLnRoaXMuX2dldFRyYW5zaXRpb25Qcm9wcygpLFxuICAgICAgICB0cmFuc2l0aW9uRHVyYXRpb246IGluZXJ0aWEsXG4gICAgICAgIHRyYW5zaXRpb25FYXNpbmc6IElORVJUSUFfRUFTSU5HXG4gICAgICB9LCB7XG4gICAgICAgIGlzRHJhZ2dpbmc6IGZhbHNlLFxuICAgICAgICBpc1JvdGF0aW5nOiB0cnVlXG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgbmV3Q29udHJvbGxlclN0YXRlID0gdGhpcy5jb250cm9sbGVyU3RhdGUucm90YXRlRW5kKCk7XG4gICAgICB0aGlzLnVwZGF0ZVZpZXdwb3J0KG5ld0NvbnRyb2xsZXJTdGF0ZSwgbnVsbCwge1xuICAgICAgICBpc0RyYWdnaW5nOiBmYWxzZSxcbiAgICAgICAgaXNSb3RhdGluZzogZmFsc2VcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgX29uV2hlZWwoZXZlbnQpIHtcbiAgICBpZiAoIXRoaXMuc2Nyb2xsWm9vbSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGV2ZW50LnNyY0V2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgY29uc3QgcG9zID0gdGhpcy5nZXRDZW50ZXIoZXZlbnQpO1xuXG4gICAgaWYgKCF0aGlzLmlzUG9pbnRJbkJvdW5kcyhwb3MsIGV2ZW50KSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGNvbnN0IHtcbiAgICAgIHNwZWVkID0gMC4wMSxcbiAgICAgIHNtb290aCA9IGZhbHNlXG4gICAgfSA9IHRoaXMuc2Nyb2xsWm9vbSA9PT0gdHJ1ZSA/IHt9IDogdGhpcy5zY3JvbGxab29tO1xuICAgIGNvbnN0IHtcbiAgICAgIGRlbHRhXG4gICAgfSA9IGV2ZW50O1xuICAgIGxldCBzY2FsZSA9IDIgLyAoMSArIE1hdGguZXhwKC1NYXRoLmFicyhkZWx0YSAqIHNwZWVkKSkpO1xuXG4gICAgaWYgKGRlbHRhIDwgMCAmJiBzY2FsZSAhPT0gMCkge1xuICAgICAgc2NhbGUgPSAxIC8gc2NhbGU7XG4gICAgfVxuXG4gICAgY29uc3QgbmV3Q29udHJvbGxlclN0YXRlID0gdGhpcy5jb250cm9sbGVyU3RhdGUuem9vbSh7XG4gICAgICBwb3MsXG4gICAgICBzY2FsZVxuICAgIH0pO1xuICAgIHRoaXMudXBkYXRlVmlld3BvcnQobmV3Q29udHJvbGxlclN0YXRlLCB7IC4uLnRoaXMuX2dldFRyYW5zaXRpb25Qcm9wcyh7XG4gICAgICAgIGFyb3VuZDogcG9zXG4gICAgICB9KSxcbiAgICAgIHRyYW5zaXRpb25EdXJhdGlvbjogc21vb3RoID8gMjUwIDogMVxuICAgIH0sIHtcbiAgICAgIGlzWm9vbWluZzogdHJ1ZSxcbiAgICAgIGlzUGFubmluZzogdHJ1ZVxuICAgIH0pO1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgX29uVHJpcGxlUGFuU3RhcnQoZXZlbnQpIHtcbiAgICBjb25zdCBwb3MgPSB0aGlzLmdldENlbnRlcihldmVudCk7XG5cbiAgICBpZiAoIXRoaXMuaXNQb2ludEluQm91bmRzKHBvcywgZXZlbnQpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgY29uc3QgbmV3Q29udHJvbGxlclN0YXRlID0gdGhpcy5jb250cm9sbGVyU3RhdGUucm90YXRlU3RhcnQoe1xuICAgICAgcG9zXG4gICAgfSk7XG4gICAgdGhpcy51cGRhdGVWaWV3cG9ydChuZXdDb250cm9sbGVyU3RhdGUsIE5PX1RSQU5TSVRJT05fUFJPUFMsIHtcbiAgICAgIGlzRHJhZ2dpbmc6IHRydWVcbiAgICB9KTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIF9vblRyaXBsZVBhbihldmVudCkge1xuICAgIGlmICghdGhpcy50b3VjaFJvdGF0ZSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGlmICghdGhpcy5pc0RyYWdnaW5nKCkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBjb25zdCBwb3MgPSB0aGlzLmdldENlbnRlcihldmVudCk7XG4gICAgcG9zWzBdIC09IGV2ZW50LmRlbHRhWDtcbiAgICBjb25zdCBuZXdDb250cm9sbGVyU3RhdGUgPSB0aGlzLmNvbnRyb2xsZXJTdGF0ZS5yb3RhdGUoe1xuICAgICAgcG9zXG4gICAgfSk7XG4gICAgdGhpcy51cGRhdGVWaWV3cG9ydChuZXdDb250cm9sbGVyU3RhdGUsIE5PX1RSQU5TSVRJT05fUFJPUFMsIHtcbiAgICAgIGlzRHJhZ2dpbmc6IHRydWUsXG4gICAgICBpc1JvdGF0aW5nOiB0cnVlXG4gICAgfSk7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICBfb25UcmlwbGVQYW5FbmQoZXZlbnQpIHtcbiAgICBpZiAoIXRoaXMuaXNEcmFnZ2luZygpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgY29uc3Qge1xuICAgICAgaW5lcnRpYVxuICAgIH0gPSB0aGlzO1xuXG4gICAgaWYgKHRoaXMudG91Y2hSb3RhdGUgJiYgaW5lcnRpYSAmJiBldmVudC52ZWxvY2l0eVkpIHtcbiAgICAgIGNvbnN0IHBvcyA9IHRoaXMuZ2V0Q2VudGVyKGV2ZW50KTtcbiAgICAgIGNvbnN0IGVuZFBvcyA9IFtwb3NbMF0sIHBvc1sxXSArPSBldmVudC52ZWxvY2l0eVkgKiBpbmVydGlhIC8gMl07XG4gICAgICBjb25zdCBuZXdDb250cm9sbGVyU3RhdGUgPSB0aGlzLmNvbnRyb2xsZXJTdGF0ZS5yb3RhdGUoe1xuICAgICAgICBwb3M6IGVuZFBvc1xuICAgICAgfSk7XG4gICAgICB0aGlzLnVwZGF0ZVZpZXdwb3J0KG5ld0NvbnRyb2xsZXJTdGF0ZSwgeyAuLi50aGlzLl9nZXRUcmFuc2l0aW9uUHJvcHMoKSxcbiAgICAgICAgdHJhbnNpdGlvbkR1cmF0aW9uOiBpbmVydGlhLFxuICAgICAgICB0cmFuc2l0aW9uRWFzaW5nOiBJTkVSVElBX0VBU0lOR1xuICAgICAgfSwge1xuICAgICAgICBpc0RyYWdnaW5nOiBmYWxzZSxcbiAgICAgICAgaXNSb3RhdGluZzogdHJ1ZVxuICAgICAgfSk7XG4gICAgICB0aGlzLmJsb2NrRXZlbnRzKGluZXJ0aWEpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBuZXdDb250cm9sbGVyU3RhdGUgPSB0aGlzLmNvbnRyb2xsZXJTdGF0ZS5yb3RhdGVFbmQoKTtcbiAgICAgIHRoaXMudXBkYXRlVmlld3BvcnQobmV3Q29udHJvbGxlclN0YXRlLCBudWxsLCB7XG4gICAgICAgIGlzRHJhZ2dpbmc6IGZhbHNlLFxuICAgICAgICBpc1JvdGF0aW5nOiBmYWxzZVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICBfb25QaW5jaFN0YXJ0KGV2ZW50KSB7XG4gICAgY29uc3QgcG9zID0gdGhpcy5nZXRDZW50ZXIoZXZlbnQpO1xuXG4gICAgaWYgKCF0aGlzLmlzUG9pbnRJbkJvdW5kcyhwb3MsIGV2ZW50KSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGNvbnN0IG5ld0NvbnRyb2xsZXJTdGF0ZSA9IHRoaXMuY29udHJvbGxlclN0YXRlLnpvb21TdGFydCh7XG4gICAgICBwb3NcbiAgICB9KS5yb3RhdGVTdGFydCh7XG4gICAgICBwb3NcbiAgICB9KTtcbiAgICBwaW5jaEV2ZW50V29ya2Fyb3VuZC5fc3RhcnRQaW5jaFJvdGF0aW9uID0gZXZlbnQucm90YXRpb247XG4gICAgcGluY2hFdmVudFdvcmthcm91bmQuX2xhc3RQaW5jaEV2ZW50ID0gZXZlbnQ7XG4gICAgdGhpcy51cGRhdGVWaWV3cG9ydChuZXdDb250cm9sbGVyU3RhdGUsIE5PX1RSQU5TSVRJT05fUFJPUFMsIHtcbiAgICAgIGlzRHJhZ2dpbmc6IHRydWVcbiAgICB9KTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIF9vblBpbmNoKGV2ZW50KSB7XG4gICAgaWYgKCF0aGlzLnRvdWNoWm9vbSAmJiAhdGhpcy50b3VjaFJvdGF0ZSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGlmICghdGhpcy5pc0RyYWdnaW5nKCkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBsZXQgbmV3Q29udHJvbGxlclN0YXRlID0gdGhpcy5jb250cm9sbGVyU3RhdGU7XG5cbiAgICBpZiAodGhpcy50b3VjaFpvb20pIHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgc2NhbGVcbiAgICAgIH0gPSBldmVudDtcbiAgICAgIGNvbnN0IHBvcyA9IHRoaXMuZ2V0Q2VudGVyKGV2ZW50KTtcbiAgICAgIG5ld0NvbnRyb2xsZXJTdGF0ZSA9IG5ld0NvbnRyb2xsZXJTdGF0ZS56b29tKHtcbiAgICAgICAgcG9zLFxuICAgICAgICBzY2FsZVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMudG91Y2hSb3RhdGUpIHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgcm90YXRpb25cbiAgICAgIH0gPSBldmVudDtcbiAgICAgIG5ld0NvbnRyb2xsZXJTdGF0ZSA9IG5ld0NvbnRyb2xsZXJTdGF0ZS5yb3RhdGUoe1xuICAgICAgICBkZWx0YUFuZ2xlWDogcGluY2hFdmVudFdvcmthcm91bmQuX3N0YXJ0UGluY2hSb3RhdGlvbiAtIHJvdGF0aW9uXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICB0aGlzLnVwZGF0ZVZpZXdwb3J0KG5ld0NvbnRyb2xsZXJTdGF0ZSwgTk9fVFJBTlNJVElPTl9QUk9QUywge1xuICAgICAgaXNEcmFnZ2luZzogdHJ1ZSxcbiAgICAgIGlzUGFubmluZzogdGhpcy50b3VjaFpvb20sXG4gICAgICBpc1pvb21pbmc6IHRoaXMudG91Y2hab29tLFxuICAgICAgaXNSb3RhdGluZzogdGhpcy50b3VjaFJvdGF0ZVxuICAgIH0pO1xuICAgIHBpbmNoRXZlbnRXb3JrYXJvdW5kLl9sYXN0UGluY2hFdmVudCA9IGV2ZW50O1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgX29uUGluY2hFbmQoZXZlbnQpIHtcbiAgICBpZiAoIXRoaXMuaXNEcmFnZ2luZygpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgY29uc3Qge1xuICAgICAgaW5lcnRpYVxuICAgIH0gPSB0aGlzO1xuICAgIGNvbnN0IHtcbiAgICAgIF9sYXN0UGluY2hFdmVudFxuICAgIH0gPSBwaW5jaEV2ZW50V29ya2Fyb3VuZDtcblxuICAgIGlmICh0aGlzLnRvdWNoWm9vbSAmJiBpbmVydGlhICYmIF9sYXN0UGluY2hFdmVudCAmJiBldmVudC5zY2FsZSAhPT0gX2xhc3RQaW5jaEV2ZW50LnNjYWxlKSB7XG4gICAgICBjb25zdCBwb3MgPSB0aGlzLmdldENlbnRlcihldmVudCk7XG4gICAgICBsZXQgbmV3Q29udHJvbGxlclN0YXRlID0gdGhpcy5jb250cm9sbGVyU3RhdGUucm90YXRlRW5kKCk7XG4gICAgICBjb25zdCB6ID0gTWF0aC5sb2cyKGV2ZW50LnNjYWxlKTtcblxuICAgICAgY29uc3QgdmVsb2NpdHlaID0gKHogLSBNYXRoLmxvZzIoX2xhc3RQaW5jaEV2ZW50LnNjYWxlKSkgLyAoZXZlbnQuZGVsdGFUaW1lIC0gX2xhc3RQaW5jaEV2ZW50LmRlbHRhVGltZSk7XG5cbiAgICAgIGNvbnN0IGVuZFNjYWxlID0gTWF0aC5wb3coMiwgeiArIHZlbG9jaXR5WiAqIGluZXJ0aWEgLyAyKTtcbiAgICAgIG5ld0NvbnRyb2xsZXJTdGF0ZSA9IG5ld0NvbnRyb2xsZXJTdGF0ZS56b29tKHtcbiAgICAgICAgcG9zLFxuICAgICAgICBzY2FsZTogZW5kU2NhbGVcbiAgICAgIH0pLnpvb21FbmQoKTtcbiAgICAgIHRoaXMudXBkYXRlVmlld3BvcnQobmV3Q29udHJvbGxlclN0YXRlLCB7IC4uLnRoaXMuX2dldFRyYW5zaXRpb25Qcm9wcyh7XG4gICAgICAgICAgYXJvdW5kOiBwb3NcbiAgICAgICAgfSksXG4gICAgICAgIHRyYW5zaXRpb25EdXJhdGlvbjogaW5lcnRpYSxcbiAgICAgICAgdHJhbnNpdGlvbkVhc2luZzogSU5FUlRJQV9FQVNJTkdcbiAgICAgIH0sIHtcbiAgICAgICAgaXNEcmFnZ2luZzogZmFsc2UsXG4gICAgICAgIGlzUGFubmluZzogdGhpcy50b3VjaFpvb20sXG4gICAgICAgIGlzWm9vbWluZzogdGhpcy50b3VjaFpvb20sXG4gICAgICAgIGlzUm90YXRpbmc6IGZhbHNlXG4gICAgICB9KTtcbiAgICAgIHRoaXMuYmxvY2tFdmVudHMoaW5lcnRpYSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IG5ld0NvbnRyb2xsZXJTdGF0ZSA9IHRoaXMuY29udHJvbGxlclN0YXRlLnpvb21FbmQoKS5yb3RhdGVFbmQoKTtcbiAgICAgIHRoaXMudXBkYXRlVmlld3BvcnQobmV3Q29udHJvbGxlclN0YXRlLCBudWxsLCB7XG4gICAgICAgIGlzRHJhZ2dpbmc6IGZhbHNlLFxuICAgICAgICBpc1Bhbm5pbmc6IGZhbHNlLFxuICAgICAgICBpc1pvb21pbmc6IGZhbHNlLFxuICAgICAgICBpc1JvdGF0aW5nOiBmYWxzZVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgcGluY2hFdmVudFdvcmthcm91bmQuX3N0YXJ0UGluY2hSb3RhdGlvbiA9IG51bGw7XG4gICAgcGluY2hFdmVudFdvcmthcm91bmQuX2xhc3RQaW5jaEV2ZW50ID0gbnVsbDtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIF9vbkRvdWJsZVRhcChldmVudCkge1xuICAgIGlmICghdGhpcy5kb3VibGVDbGlja1pvb20pIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBjb25zdCBwb3MgPSB0aGlzLmdldENlbnRlcihldmVudCk7XG5cbiAgICBpZiAoIXRoaXMuaXNQb2ludEluQm91bmRzKHBvcywgZXZlbnQpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgY29uc3QgaXNab29tT3V0ID0gdGhpcy5pc0Z1bmN0aW9uS2V5UHJlc3NlZChldmVudCk7XG4gICAgY29uc3QgbmV3Q29udHJvbGxlclN0YXRlID0gdGhpcy5jb250cm9sbGVyU3RhdGUuem9vbSh7XG4gICAgICBwb3MsXG4gICAgICBzY2FsZTogaXNab29tT3V0ID8gMC41IDogMlxuICAgIH0pO1xuICAgIHRoaXMudXBkYXRlVmlld3BvcnQobmV3Q29udHJvbGxlclN0YXRlLCB0aGlzLl9nZXRUcmFuc2l0aW9uUHJvcHMoe1xuICAgICAgYXJvdW5kOiBwb3NcbiAgICB9KSwge1xuICAgICAgaXNab29taW5nOiB0cnVlLFxuICAgICAgaXNQYW5uaW5nOiB0cnVlXG4gICAgfSk7XG4gICAgdGhpcy5ibG9ja0V2ZW50cygxMDApO1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgX29uS2V5RG93bihldmVudCkge1xuICAgIGlmICghdGhpcy5rZXlib2FyZCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGNvbnN0IGZ1bmNLZXkgPSB0aGlzLmlzRnVuY3Rpb25LZXlQcmVzc2VkKGV2ZW50KTtcbiAgICBjb25zdCB7XG4gICAgICB6b29tU3BlZWQsXG4gICAgICBtb3ZlU3BlZWQsXG4gICAgICByb3RhdGVTcGVlZFgsXG4gICAgICByb3RhdGVTcGVlZFlcbiAgICB9ID0gdGhpcy5rZXlib2FyZCA9PT0gdHJ1ZSA/IHt9IDogdGhpcy5rZXlib2FyZDtcbiAgICBjb25zdCB7XG4gICAgICBjb250cm9sbGVyU3RhdGVcbiAgICB9ID0gdGhpcztcbiAgICBsZXQgbmV3Q29udHJvbGxlclN0YXRlO1xuICAgIGNvbnN0IGludGVyYWN0aW9uU3RhdGUgPSB7fTtcblxuICAgIHN3aXRjaCAoZXZlbnQuc3JjRXZlbnQuY29kZSkge1xuICAgICAgY2FzZSAnTWludXMnOlxuICAgICAgICBuZXdDb250cm9sbGVyU3RhdGUgPSBmdW5jS2V5ID8gY29udHJvbGxlclN0YXRlLnpvb21PdXQoem9vbVNwZWVkKS56b29tT3V0KHpvb21TcGVlZCkgOiBjb250cm9sbGVyU3RhdGUuem9vbU91dCh6b29tU3BlZWQpO1xuICAgICAgICBpbnRlcmFjdGlvblN0YXRlLmlzWm9vbWluZyA9IHRydWU7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlICdFcXVhbCc6XG4gICAgICAgIG5ld0NvbnRyb2xsZXJTdGF0ZSA9IGZ1bmNLZXkgPyBjb250cm9sbGVyU3RhdGUuem9vbUluKHpvb21TcGVlZCkuem9vbUluKHpvb21TcGVlZCkgOiBjb250cm9sbGVyU3RhdGUuem9vbUluKHpvb21TcGVlZCk7XG4gICAgICAgIGludGVyYWN0aW9uU3RhdGUuaXNab29taW5nID0gdHJ1ZTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgJ0Fycm93TGVmdCc6XG4gICAgICAgIGlmIChmdW5jS2V5KSB7XG4gICAgICAgICAgbmV3Q29udHJvbGxlclN0YXRlID0gY29udHJvbGxlclN0YXRlLnJvdGF0ZUxlZnQocm90YXRlU3BlZWRYKTtcbiAgICAgICAgICBpbnRlcmFjdGlvblN0YXRlLmlzUm90YXRpbmcgPSB0cnVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG5ld0NvbnRyb2xsZXJTdGF0ZSA9IGNvbnRyb2xsZXJTdGF0ZS5tb3ZlTGVmdChtb3ZlU3BlZWQpO1xuICAgICAgICAgIGludGVyYWN0aW9uU3RhdGUuaXNQYW5uaW5nID0gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlICdBcnJvd1JpZ2h0JzpcbiAgICAgICAgaWYgKGZ1bmNLZXkpIHtcbiAgICAgICAgICBuZXdDb250cm9sbGVyU3RhdGUgPSBjb250cm9sbGVyU3RhdGUucm90YXRlUmlnaHQocm90YXRlU3BlZWRYKTtcbiAgICAgICAgICBpbnRlcmFjdGlvblN0YXRlLmlzUm90YXRpbmcgPSB0cnVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG5ld0NvbnRyb2xsZXJTdGF0ZSA9IGNvbnRyb2xsZXJTdGF0ZS5tb3ZlUmlnaHQobW92ZVNwZWVkKTtcbiAgICAgICAgICBpbnRlcmFjdGlvblN0YXRlLmlzUGFubmluZyA9IHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSAnQXJyb3dVcCc6XG4gICAgICAgIGlmIChmdW5jS2V5KSB7XG4gICAgICAgICAgbmV3Q29udHJvbGxlclN0YXRlID0gY29udHJvbGxlclN0YXRlLnJvdGF0ZVVwKHJvdGF0ZVNwZWVkWSk7XG4gICAgICAgICAgaW50ZXJhY3Rpb25TdGF0ZS5pc1JvdGF0aW5nID0gdHJ1ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBuZXdDb250cm9sbGVyU3RhdGUgPSBjb250cm9sbGVyU3RhdGUubW92ZVVwKG1vdmVTcGVlZCk7XG4gICAgICAgICAgaW50ZXJhY3Rpb25TdGF0ZS5pc1Bhbm5pbmcgPSB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgJ0Fycm93RG93bic6XG4gICAgICAgIGlmIChmdW5jS2V5KSB7XG4gICAgICAgICAgbmV3Q29udHJvbGxlclN0YXRlID0gY29udHJvbGxlclN0YXRlLnJvdGF0ZURvd24ocm90YXRlU3BlZWRZKTtcbiAgICAgICAgICBpbnRlcmFjdGlvblN0YXRlLmlzUm90YXRpbmcgPSB0cnVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG5ld0NvbnRyb2xsZXJTdGF0ZSA9IGNvbnRyb2xsZXJTdGF0ZS5tb3ZlRG93bihtb3ZlU3BlZWQpO1xuICAgICAgICAgIGludGVyYWN0aW9uU3RhdGUuaXNQYW5uaW5nID0gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgdGhpcy51cGRhdGVWaWV3cG9ydChuZXdDb250cm9sbGVyU3RhdGUsIHRoaXMuX2dldFRyYW5zaXRpb25Qcm9wcygpLCBpbnRlcmFjdGlvblN0YXRlKTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIF9nZXRUcmFuc2l0aW9uUHJvcHMob3B0cykge1xuICAgIGNvbnN0IHtcbiAgICAgIHRyYW5zaXRpb25cbiAgICB9ID0gdGhpcztcblxuICAgIGlmICghdHJhbnNpdGlvbiB8fCAhdHJhbnNpdGlvbi50cmFuc2l0aW9uSW50ZXJwb2xhdG9yKSB7XG4gICAgICByZXR1cm4gTk9fVFJBTlNJVElPTl9QUk9QUztcbiAgICB9XG5cbiAgICByZXR1cm4gb3B0cyA/IHsgLi4udHJhbnNpdGlvbixcbiAgICAgIHRyYW5zaXRpb25JbnRlcnBvbGF0b3I6IG5ldyBMaW5lYXJJbnRlcnBvbGF0b3IoeyAuLi5vcHRzLFxuICAgICAgICAuLi50cmFuc2l0aW9uLnRyYW5zaXRpb25JbnRlcnBvbGF0b3Iub3B0cyxcbiAgICAgICAgbWFrZVZpZXdwb3J0OiB0aGlzLmNvbnRyb2xsZXJTdGF0ZS5tYWtlVmlld3BvcnRcbiAgICAgIH0pXG4gICAgfSA6IHRyYW5zaXRpb247XG4gIH1cblxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y29udHJvbGxlci5qcy5tYXAiLCJpbXBvcnQgX2RlZmluZVByb3BlcnR5IGZyb20gXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9kZWZpbmVQcm9wZXJ0eVwiO1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgVmlld1N0YXRlIHtcbiAgY29uc3RydWN0b3IocHJvcHMsIHN0YXRlKSB7XG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwiX3ZpZXdwb3J0UHJvcHNcIiwgdm9pZCAwKTtcblxuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIl9zdGF0ZVwiLCB2b2lkIDApO1xuXG4gICAgdGhpcy5fdmlld3BvcnRQcm9wcyA9IHRoaXMuYXBwbHlDb25zdHJhaW50cyhwcm9wcyk7XG4gICAgdGhpcy5fc3RhdGUgPSBzdGF0ZTtcbiAgfVxuXG4gIGdldFZpZXdwb3J0UHJvcHMoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3ZpZXdwb3J0UHJvcHM7XG4gIH1cblxuICBnZXRTdGF0ZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fc3RhdGU7XG4gIH1cblxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dmlldy1zdGF0ZS5qcy5tYXAiLCJpbXBvcnQgX2RlZmluZVByb3BlcnR5IGZyb20gXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9kZWZpbmVQcm9wZXJ0eVwiO1xuaW1wb3J0IHsgY2xhbXAgfSBmcm9tICdAbWF0aC5nbC9jb3JlJztcbmltcG9ydCBDb250cm9sbGVyIGZyb20gJy4vY29udHJvbGxlcic7XG5pbXBvcnQgVmlld1N0YXRlIGZyb20gJy4vdmlldy1zdGF0ZSc7XG5pbXBvcnQgeyBub3JtYWxpemVWaWV3cG9ydFByb3BzIH0gZnJvbSAnQG1hdGguZ2wvd2ViLW1lcmNhdG9yJztcbmltcG9ydCBhc3NlcnQgZnJvbSAnLi4vdXRpbHMvYXNzZXJ0JztcbmltcG9ydCBMaW5lYXJJbnRlcnBvbGF0b3IgZnJvbSAnLi4vdHJhbnNpdGlvbnMvbGluZWFyLWludGVycG9sYXRvcic7XG5jb25zdCBQSVRDSF9NT1VTRV9USFJFU0hPTEQgPSA1O1xuY29uc3QgUElUQ0hfQUNDRUwgPSAxLjI7XG5leHBvcnQgY2xhc3MgTWFwU3RhdGUgZXh0ZW5kcyBWaWV3U3RhdGUge1xuICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgY29uc3Qge1xuICAgICAgd2lkdGgsXG4gICAgICBoZWlnaHQsXG4gICAgICBsYXRpdHVkZSxcbiAgICAgIGxvbmdpdHVkZSxcbiAgICAgIHpvb20sXG4gICAgICBiZWFyaW5nID0gMCxcbiAgICAgIHBpdGNoID0gMCxcbiAgICAgIGFsdGl0dWRlID0gMS41LFxuICAgICAgcG9zaXRpb24gPSBbMCwgMCwgMF0sXG4gICAgICBtYXhab29tID0gMjAsXG4gICAgICBtaW5ab29tID0gMCxcbiAgICAgIG1heFBpdGNoID0gNjAsXG4gICAgICBtaW5QaXRjaCA9IDAsXG4gICAgICBzdGFydFBhbkxuZ0xhdCxcbiAgICAgIHN0YXJ0Wm9vbUxuZ0xhdCxcbiAgICAgIHN0YXJ0Um90YXRlUG9zLFxuICAgICAgc3RhcnRCZWFyaW5nLFxuICAgICAgc3RhcnRQaXRjaCxcbiAgICAgIHN0YXJ0Wm9vbSxcbiAgICAgIG5vcm1hbGl6ZSA9IHRydWVcbiAgICB9ID0gb3B0aW9ucztcbiAgICBhc3NlcnQoTnVtYmVyLmlzRmluaXRlKGxvbmdpdHVkZSkpO1xuICAgIGFzc2VydChOdW1iZXIuaXNGaW5pdGUobGF0aXR1ZGUpKTtcbiAgICBhc3NlcnQoTnVtYmVyLmlzRmluaXRlKHpvb20pKTtcbiAgICBzdXBlcih7XG4gICAgICB3aWR0aCxcbiAgICAgIGhlaWdodCxcbiAgICAgIGxhdGl0dWRlLFxuICAgICAgbG9uZ2l0dWRlLFxuICAgICAgem9vbSxcbiAgICAgIGJlYXJpbmcsXG4gICAgICBwaXRjaCxcbiAgICAgIGFsdGl0dWRlLFxuICAgICAgbWF4Wm9vbSxcbiAgICAgIG1pblpvb20sXG4gICAgICBtYXhQaXRjaCxcbiAgICAgIG1pblBpdGNoLFxuICAgICAgbm9ybWFsaXplLFxuICAgICAgcG9zaXRpb25cbiAgICB9LCB7XG4gICAgICBzdGFydFBhbkxuZ0xhdCxcbiAgICAgIHN0YXJ0Wm9vbUxuZ0xhdCxcbiAgICAgIHN0YXJ0Um90YXRlUG9zLFxuICAgICAgc3RhcnRCZWFyaW5nLFxuICAgICAgc3RhcnRQaXRjaCxcbiAgICAgIHN0YXJ0Wm9vbVxuICAgIH0pO1xuXG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwibWFrZVZpZXdwb3J0XCIsIHZvaWQgMCk7XG5cbiAgICB0aGlzLm1ha2VWaWV3cG9ydCA9IG9wdGlvbnMubWFrZVZpZXdwb3J0O1xuICB9XG5cbiAgcGFuU3RhcnQoe1xuICAgIHBvc1xuICB9KSB7XG4gICAgcmV0dXJuIHRoaXMuX2dldFVwZGF0ZWRTdGF0ZSh7XG4gICAgICBzdGFydFBhbkxuZ0xhdDogdGhpcy5fdW5wcm9qZWN0KHBvcylcbiAgICB9KTtcbiAgfVxuXG4gIHBhbih7XG4gICAgcG9zLFxuICAgIHN0YXJ0UG9zXG4gIH0pIHtcbiAgICBjb25zdCBzdGFydFBhbkxuZ0xhdCA9IHRoaXMuZ2V0U3RhdGUoKS5zdGFydFBhbkxuZ0xhdCB8fCB0aGlzLl91bnByb2plY3Qoc3RhcnRQb3MpO1xuXG4gICAgaWYgKCFzdGFydFBhbkxuZ0xhdCkge1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgY29uc3Qgdmlld3BvcnQgPSB0aGlzLm1ha2VWaWV3cG9ydCh0aGlzLmdldFZpZXdwb3J0UHJvcHMoKSk7XG4gICAgY29uc3QgbmV3UHJvcHMgPSB2aWV3cG9ydC5wYW5CeVBvc2l0aW9uKHN0YXJ0UGFuTG5nTGF0LCBwb3MpO1xuICAgIHJldHVybiB0aGlzLl9nZXRVcGRhdGVkU3RhdGUobmV3UHJvcHMpO1xuICB9XG5cbiAgcGFuRW5kKCkge1xuICAgIHJldHVybiB0aGlzLl9nZXRVcGRhdGVkU3RhdGUoe1xuICAgICAgc3RhcnRQYW5MbmdMYXQ6IG51bGxcbiAgICB9KTtcbiAgfVxuXG4gIHJvdGF0ZVN0YXJ0KHtcbiAgICBwb3NcbiAgfSkge1xuICAgIHJldHVybiB0aGlzLl9nZXRVcGRhdGVkU3RhdGUoe1xuICAgICAgc3RhcnRSb3RhdGVQb3M6IHBvcyxcbiAgICAgIHN0YXJ0QmVhcmluZzogdGhpcy5nZXRWaWV3cG9ydFByb3BzKCkuYmVhcmluZyxcbiAgICAgIHN0YXJ0UGl0Y2g6IHRoaXMuZ2V0Vmlld3BvcnRQcm9wcygpLnBpdGNoXG4gICAgfSk7XG4gIH1cblxuICByb3RhdGUoe1xuICAgIHBvcyxcbiAgICBkZWx0YUFuZ2xlWCA9IDAsXG4gICAgZGVsdGFBbmdsZVkgPSAwXG4gIH0pIHtcbiAgICBjb25zdCB7XG4gICAgICBzdGFydFJvdGF0ZVBvcyxcbiAgICAgIHN0YXJ0QmVhcmluZyxcbiAgICAgIHN0YXJ0UGl0Y2hcbiAgICB9ID0gdGhpcy5nZXRTdGF0ZSgpO1xuXG4gICAgaWYgKCFzdGFydFJvdGF0ZVBvcyB8fCBzdGFydEJlYXJpbmcgPT09IHVuZGVmaW5lZCB8fCBzdGFydFBpdGNoID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIGxldCBuZXdSb3RhdGlvbjtcblxuICAgIGlmIChwb3MpIHtcbiAgICAgIG5ld1JvdGF0aW9uID0gdGhpcy5fZ2V0TmV3Um90YXRpb24ocG9zLCBzdGFydFJvdGF0ZVBvcywgc3RhcnRQaXRjaCwgc3RhcnRCZWFyaW5nKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbmV3Um90YXRpb24gPSB7XG4gICAgICAgIGJlYXJpbmc6IHN0YXJ0QmVhcmluZyArIGRlbHRhQW5nbGVYLFxuICAgICAgICBwaXRjaDogc3RhcnRQaXRjaCArIGRlbHRhQW5nbGVZXG4gICAgICB9O1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLl9nZXRVcGRhdGVkU3RhdGUobmV3Um90YXRpb24pO1xuICB9XG5cbiAgcm90YXRlRW5kKCkge1xuICAgIHJldHVybiB0aGlzLl9nZXRVcGRhdGVkU3RhdGUoe1xuICAgICAgc3RhcnRCZWFyaW5nOiBudWxsLFxuICAgICAgc3RhcnRQaXRjaDogbnVsbFxuICAgIH0pO1xuICB9XG5cbiAgem9vbVN0YXJ0KHtcbiAgICBwb3NcbiAgfSkge1xuICAgIHJldHVybiB0aGlzLl9nZXRVcGRhdGVkU3RhdGUoe1xuICAgICAgc3RhcnRab29tTG5nTGF0OiB0aGlzLl91bnByb2plY3QocG9zKSxcbiAgICAgIHN0YXJ0Wm9vbTogdGhpcy5nZXRWaWV3cG9ydFByb3BzKCkuem9vbVxuICAgIH0pO1xuICB9XG5cbiAgem9vbSh7XG4gICAgcG9zLFxuICAgIHN0YXJ0UG9zLFxuICAgIHNjYWxlXG4gIH0pIHtcbiAgICBsZXQge1xuICAgICAgc3RhcnRab29tLFxuICAgICAgc3RhcnRab29tTG5nTGF0XG4gICAgfSA9IHRoaXMuZ2V0U3RhdGUoKTtcblxuICAgIGlmICghc3RhcnRab29tTG5nTGF0KSB7XG4gICAgICBzdGFydFpvb20gPSB0aGlzLmdldFZpZXdwb3J0UHJvcHMoKS56b29tO1xuICAgICAgc3RhcnRab29tTG5nTGF0ID0gdGhpcy5fdW5wcm9qZWN0KHN0YXJ0UG9zKSB8fCB0aGlzLl91bnByb2plY3QocG9zKTtcbiAgICB9XG5cbiAgICBpZiAoIXN0YXJ0Wm9vbUxuZ0xhdCkge1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgY29uc3Qge1xuICAgICAgbWF4Wm9vbSxcbiAgICAgIG1pblpvb21cbiAgICB9ID0gdGhpcy5nZXRWaWV3cG9ydFByb3BzKCk7XG4gICAgbGV0IHpvb20gPSBzdGFydFpvb20gKyBNYXRoLmxvZzIoc2NhbGUpO1xuICAgIHpvb20gPSBjbGFtcCh6b29tLCBtaW5ab29tLCBtYXhab29tKTtcbiAgICBjb25zdCB6b29tZWRWaWV3cG9ydCA9IHRoaXMubWFrZVZpZXdwb3J0KHsgLi4udGhpcy5nZXRWaWV3cG9ydFByb3BzKCksXG4gICAgICB6b29tXG4gICAgfSk7XG4gICAgcmV0dXJuIHRoaXMuX2dldFVwZGF0ZWRTdGF0ZSh7XG4gICAgICB6b29tLFxuICAgICAgLi4uem9vbWVkVmlld3BvcnQucGFuQnlQb3NpdGlvbihzdGFydFpvb21MbmdMYXQsIHBvcylcbiAgICB9KTtcbiAgfVxuXG4gIHpvb21FbmQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2dldFVwZGF0ZWRTdGF0ZSh7XG4gICAgICBzdGFydFpvb21MbmdMYXQ6IG51bGwsXG4gICAgICBzdGFydFpvb206IG51bGxcbiAgICB9KTtcbiAgfVxuXG4gIHpvb21JbihzcGVlZCA9IDIpIHtcbiAgICByZXR1cm4gdGhpcy5fem9vbUZyb21DZW50ZXIoc3BlZWQpO1xuICB9XG5cbiAgem9vbU91dChzcGVlZCA9IDIpIHtcbiAgICByZXR1cm4gdGhpcy5fem9vbUZyb21DZW50ZXIoMSAvIHNwZWVkKTtcbiAgfVxuXG4gIG1vdmVMZWZ0KHNwZWVkID0gMTAwKSB7XG4gICAgcmV0dXJuIHRoaXMuX3BhbkZyb21DZW50ZXIoW3NwZWVkLCAwXSk7XG4gIH1cblxuICBtb3ZlUmlnaHQoc3BlZWQgPSAxMDApIHtcbiAgICByZXR1cm4gdGhpcy5fcGFuRnJvbUNlbnRlcihbLXNwZWVkLCAwXSk7XG4gIH1cblxuICBtb3ZlVXAoc3BlZWQgPSAxMDApIHtcbiAgICByZXR1cm4gdGhpcy5fcGFuRnJvbUNlbnRlcihbMCwgc3BlZWRdKTtcbiAgfVxuXG4gIG1vdmVEb3duKHNwZWVkID0gMTAwKSB7XG4gICAgcmV0dXJuIHRoaXMuX3BhbkZyb21DZW50ZXIoWzAsIC1zcGVlZF0pO1xuICB9XG5cbiAgcm90YXRlTGVmdChzcGVlZCA9IDE1KSB7XG4gICAgcmV0dXJuIHRoaXMuX2dldFVwZGF0ZWRTdGF0ZSh7XG4gICAgICBiZWFyaW5nOiB0aGlzLmdldFZpZXdwb3J0UHJvcHMoKS5iZWFyaW5nIC0gc3BlZWRcbiAgICB9KTtcbiAgfVxuXG4gIHJvdGF0ZVJpZ2h0KHNwZWVkID0gMTUpIHtcbiAgICByZXR1cm4gdGhpcy5fZ2V0VXBkYXRlZFN0YXRlKHtcbiAgICAgIGJlYXJpbmc6IHRoaXMuZ2V0Vmlld3BvcnRQcm9wcygpLmJlYXJpbmcgKyBzcGVlZFxuICAgIH0pO1xuICB9XG5cbiAgcm90YXRlVXAoc3BlZWQgPSAxMCkge1xuICAgIHJldHVybiB0aGlzLl9nZXRVcGRhdGVkU3RhdGUoe1xuICAgICAgcGl0Y2g6IHRoaXMuZ2V0Vmlld3BvcnRQcm9wcygpLnBpdGNoICsgc3BlZWRcbiAgICB9KTtcbiAgfVxuXG4gIHJvdGF0ZURvd24oc3BlZWQgPSAxMCkge1xuICAgIHJldHVybiB0aGlzLl9nZXRVcGRhdGVkU3RhdGUoe1xuICAgICAgcGl0Y2g6IHRoaXMuZ2V0Vmlld3BvcnRQcm9wcygpLnBpdGNoIC0gc3BlZWRcbiAgICB9KTtcbiAgfVxuXG4gIHNob3J0ZXN0UGF0aEZyb20odmlld1N0YXRlKSB7XG4gICAgY29uc3QgZnJvbVByb3BzID0gdmlld1N0YXRlLmdldFZpZXdwb3J0UHJvcHMoKTtcbiAgICBjb25zdCBwcm9wcyA9IHsgLi4udGhpcy5nZXRWaWV3cG9ydFByb3BzKClcbiAgICB9O1xuICAgIGNvbnN0IHtcbiAgICAgIGJlYXJpbmcsXG4gICAgICBsb25naXR1ZGVcbiAgICB9ID0gcHJvcHM7XG5cbiAgICBpZiAoTWF0aC5hYnMoYmVhcmluZyAtIGZyb21Qcm9wcy5iZWFyaW5nKSA+IDE4MCkge1xuICAgICAgcHJvcHMuYmVhcmluZyA9IGJlYXJpbmcgPCAwID8gYmVhcmluZyArIDM2MCA6IGJlYXJpbmcgLSAzNjA7XG4gICAgfVxuXG4gICAgaWYgKE1hdGguYWJzKGxvbmdpdHVkZSAtIGZyb21Qcm9wcy5sb25naXR1ZGUpID4gMTgwKSB7XG4gICAgICBwcm9wcy5sb25naXR1ZGUgPSBsb25naXR1ZGUgPCAwID8gbG9uZ2l0dWRlICsgMzYwIDogbG9uZ2l0dWRlIC0gMzYwO1xuICAgIH1cblxuICAgIHJldHVybiBwcm9wcztcbiAgfVxuXG4gIGFwcGx5Q29uc3RyYWludHMocHJvcHMpIHtcbiAgICBjb25zdCB7XG4gICAgICBtYXhab29tLFxuICAgICAgbWluWm9vbSxcbiAgICAgIHpvb21cbiAgICB9ID0gcHJvcHM7XG4gICAgcHJvcHMuem9vbSA9IGNsYW1wKHpvb20sIG1pblpvb20sIG1heFpvb20pO1xuICAgIGNvbnN0IHtcbiAgICAgIG1heFBpdGNoLFxuICAgICAgbWluUGl0Y2gsXG4gICAgICBwaXRjaFxuICAgIH0gPSBwcm9wcztcbiAgICBwcm9wcy5waXRjaCA9IGNsYW1wKHBpdGNoLCBtaW5QaXRjaCwgbWF4UGl0Y2gpO1xuICAgIGNvbnN0IHtcbiAgICAgIG5vcm1hbGl6ZSA9IHRydWVcbiAgICB9ID0gcHJvcHM7XG5cbiAgICBpZiAobm9ybWFsaXplKSB7XG4gICAgICBPYmplY3QuYXNzaWduKHByb3BzLCBub3JtYWxpemVWaWV3cG9ydFByb3BzKHByb3BzKSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHByb3BzO1xuICB9XG5cbiAgX3pvb21Gcm9tQ2VudGVyKHNjYWxlKSB7XG4gICAgY29uc3Qge1xuICAgICAgd2lkdGgsXG4gICAgICBoZWlnaHRcbiAgICB9ID0gdGhpcy5nZXRWaWV3cG9ydFByb3BzKCk7XG4gICAgcmV0dXJuIHRoaXMuem9vbSh7XG4gICAgICBwb3M6IFt3aWR0aCAvIDIsIGhlaWdodCAvIDJdLFxuICAgICAgc2NhbGVcbiAgICB9KTtcbiAgfVxuXG4gIF9wYW5Gcm9tQ2VudGVyKG9mZnNldCkge1xuICAgIGNvbnN0IHtcbiAgICAgIHdpZHRoLFxuICAgICAgaGVpZ2h0XG4gICAgfSA9IHRoaXMuZ2V0Vmlld3BvcnRQcm9wcygpO1xuICAgIHJldHVybiB0aGlzLnBhbih7XG4gICAgICBzdGFydFBvczogW3dpZHRoIC8gMiwgaGVpZ2h0IC8gMl0sXG4gICAgICBwb3M6IFt3aWR0aCAvIDIgKyBvZmZzZXRbMF0sIGhlaWdodCAvIDIgKyBvZmZzZXRbMV1dXG4gICAgfSk7XG4gIH1cblxuICBfZ2V0VXBkYXRlZFN0YXRlKG5ld1Byb3BzKSB7XG4gICAgcmV0dXJuIG5ldyB0aGlzLmNvbnN0cnVjdG9yKHtcbiAgICAgIG1ha2VWaWV3cG9ydDogdGhpcy5tYWtlVmlld3BvcnQsXG4gICAgICAuLi50aGlzLmdldFZpZXdwb3J0UHJvcHMoKSxcbiAgICAgIC4uLnRoaXMuZ2V0U3RhdGUoKSxcbiAgICAgIC4uLm5ld1Byb3BzXG4gICAgfSk7XG4gIH1cblxuICBfdW5wcm9qZWN0KHBvcykge1xuICAgIGNvbnN0IHZpZXdwb3J0ID0gdGhpcy5tYWtlVmlld3BvcnQodGhpcy5nZXRWaWV3cG9ydFByb3BzKCkpO1xuICAgIHJldHVybiBwb3MgJiYgdmlld3BvcnQudW5wcm9qZWN0KHBvcyk7XG4gIH1cblxuICBfZ2V0TmV3Um90YXRpb24ocG9zLCBzdGFydFBvcywgc3RhcnRQaXRjaCwgc3RhcnRCZWFyaW5nKSB7XG4gICAgY29uc3QgZGVsdGFYID0gcG9zWzBdIC0gc3RhcnRQb3NbMF07XG4gICAgY29uc3QgZGVsdGFZID0gcG9zWzFdIC0gc3RhcnRQb3NbMV07XG4gICAgY29uc3QgY2VudGVyWSA9IHBvc1sxXTtcbiAgICBjb25zdCBzdGFydFkgPSBzdGFydFBvc1sxXTtcbiAgICBjb25zdCB7XG4gICAgICB3aWR0aCxcbiAgICAgIGhlaWdodFxuICAgIH0gPSB0aGlzLmdldFZpZXdwb3J0UHJvcHMoKTtcbiAgICBjb25zdCBkZWx0YVNjYWxlWCA9IGRlbHRhWCAvIHdpZHRoO1xuICAgIGxldCBkZWx0YVNjYWxlWSA9IDA7XG5cbiAgICBpZiAoZGVsdGFZID4gMCkge1xuICAgICAgaWYgKE1hdGguYWJzKGhlaWdodCAtIHN0YXJ0WSkgPiBQSVRDSF9NT1VTRV9USFJFU0hPTEQpIHtcbiAgICAgICAgZGVsdGFTY2FsZVkgPSBkZWx0YVkgLyAoc3RhcnRZIC0gaGVpZ2h0KSAqIFBJVENIX0FDQ0VMO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoZGVsdGFZIDwgMCkge1xuICAgICAgaWYgKHN0YXJ0WSA+IFBJVENIX01PVVNFX1RIUkVTSE9MRCkge1xuICAgICAgICBkZWx0YVNjYWxlWSA9IDEgLSBjZW50ZXJZIC8gc3RhcnRZO1xuICAgICAgfVxuICAgIH1cblxuICAgIGRlbHRhU2NhbGVZID0gY2xhbXAoZGVsdGFTY2FsZVksIC0xLCAxKTtcbiAgICBjb25zdCB7XG4gICAgICBtaW5QaXRjaCxcbiAgICAgIG1heFBpdGNoXG4gICAgfSA9IHRoaXMuZ2V0Vmlld3BvcnRQcm9wcygpO1xuICAgIGNvbnN0IGJlYXJpbmcgPSBzdGFydEJlYXJpbmcgKyAxODAgKiBkZWx0YVNjYWxlWDtcbiAgICBsZXQgcGl0Y2ggPSBzdGFydFBpdGNoO1xuXG4gICAgaWYgKGRlbHRhU2NhbGVZID4gMCkge1xuICAgICAgcGl0Y2ggPSBzdGFydFBpdGNoICsgZGVsdGFTY2FsZVkgKiAobWF4UGl0Y2ggLSBzdGFydFBpdGNoKTtcbiAgICB9IGVsc2UgaWYgKGRlbHRhU2NhbGVZIDwgMCkge1xuICAgICAgcGl0Y2ggPSBzdGFydFBpdGNoIC0gZGVsdGFTY2FsZVkgKiAobWluUGl0Y2ggLSBzdGFydFBpdGNoKTtcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgcGl0Y2gsXG4gICAgICBiZWFyaW5nXG4gICAgfTtcbiAgfVxuXG59XG5leHBvcnQgZGVmYXVsdCBjbGFzcyBNYXBDb250cm9sbGVyIGV4dGVuZHMgQ29udHJvbGxlciB7XG4gIGNvbnN0cnVjdG9yKC4uLmFyZ3MpIHtcbiAgICBzdXBlciguLi5hcmdzKTtcblxuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIkNvbnRyb2xsZXJTdGF0ZVwiLCBNYXBTdGF0ZSk7XG5cbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJ0cmFuc2l0aW9uXCIsIHtcbiAgICAgIHRyYW5zaXRpb25EdXJhdGlvbjogMzAwLFxuICAgICAgdHJhbnNpdGlvbkludGVycG9sYXRvcjogbmV3IExpbmVhckludGVycG9sYXRvcih7XG4gICAgICAgIHRyYW5zaXRpb25Qcm9wczoge1xuICAgICAgICAgIGNvbXBhcmU6IFsnbG9uZ2l0dWRlJywgJ2xhdGl0dWRlJywgJ3pvb20nLCAnYmVhcmluZycsICdwaXRjaCcsICdwb3NpdGlvbiddLFxuICAgICAgICAgIHJlcXVpcmVkOiBbJ2xvbmdpdHVkZScsICdsYXRpdHVkZScsICd6b29tJ11cbiAgICAgICAgfVxuICAgICAgfSlcbiAgICB9KTtcblxuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImRyYWdNb2RlXCIsICdwYW4nKTtcbiAgfVxuXG4gIHNldFByb3BzKHByb3BzKSB7XG4gICAgcHJvcHMucG9zaXRpb24gPSBwcm9wcy5wb3NpdGlvbiB8fCBbMCwgMCwgMF07XG4gICAgY29uc3Qgb2xkUHJvcHMgPSB0aGlzLnByb3BzO1xuICAgIHN1cGVyLnNldFByb3BzKHByb3BzKTtcbiAgICBjb25zdCBkaW1lbnNpb25DaGFuZ2VkID0gIW9sZFByb3BzIHx8IG9sZFByb3BzLmhlaWdodCAhPT0gcHJvcHMuaGVpZ2h0O1xuXG4gICAgaWYgKGRpbWVuc2lvbkNoYW5nZWQpIHtcbiAgICAgIHRoaXMudXBkYXRlVmlld3BvcnQobmV3IHRoaXMuQ29udHJvbGxlclN0YXRlKHtcbiAgICAgICAgbWFrZVZpZXdwb3J0OiB0aGlzLm1ha2VWaWV3cG9ydCxcbiAgICAgICAgLi4ucHJvcHMsXG4gICAgICAgIC4uLnRoaXMuc3RhdGVcbiAgICAgIH0pKTtcbiAgICB9XG4gIH1cblxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bWFwLWNvbnRyb2xsZXIuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///68990\n")}}]);