"use strict";(self["webpackChunkvue3_webpack5"]=self["webpackChunkvue3_webpack5"]||[]).push([[7035],{44238:function(__unused_webpack___webpack_module__,__webpack_exports__){eval("/**\n * @module ol/pointer/EventType\n */\n\n/**\n * Constants for event names.\n * @enum {string}\n */\n/* harmony default export */ __webpack_exports__[\"Z\"] = ({\n  POINTERMOVE: 'pointermove',\n  POINTERDOWN: 'pointerdown',\n  POINTERUP: 'pointerup',\n  POINTEROVER: 'pointerover',\n  POINTEROUT: 'pointerout',\n  POINTERENTER: 'pointerenter',\n  POINTERLEAVE: 'pointerleave',\n  POINTERCANCEL: 'pointercancel',\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNDQyMzguanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQSx5REFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLEVBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly92dWUzLXdlYnBhY2s1Ly4vbm9kZV9tb2R1bGVzL29sL3BvaW50ZXIvRXZlbnRUeXBlLmpzP2E1NWMiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAbW9kdWxlIG9sL3BvaW50ZXIvRXZlbnRUeXBlXG4gKi9cblxuLyoqXG4gKiBDb25zdGFudHMgZm9yIGV2ZW50IG5hbWVzLlxuICogQGVudW0ge3N0cmluZ31cbiAqL1xuZXhwb3J0IGRlZmF1bHQge1xuICBQT0lOVEVSTU9WRTogJ3BvaW50ZXJtb3ZlJyxcbiAgUE9JTlRFUkRPV046ICdwb2ludGVyZG93bicsXG4gIFBPSU5URVJVUDogJ3BvaW50ZXJ1cCcsXG4gIFBPSU5URVJPVkVSOiAncG9pbnRlcm92ZXInLFxuICBQT0lOVEVST1VUOiAncG9pbnRlcm91dCcsXG4gIFBPSU5URVJFTlRFUjogJ3BvaW50ZXJlbnRlcicsXG4gIFBPSU5URVJMRUFWRTogJ3BvaW50ZXJsZWF2ZScsXG4gIFBPSU5URVJDQU5DRUw6ICdwb2ludGVyY2FuY2VsJyxcbn07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///44238\n")},24121:function(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__){eval('\n// EXPORTS\n__webpack_require__.d(__webpack_exports__, {\n  "Wm": function() { return /* reexport */ Units_METERS_PER_UNIT; },\n  "UQ": function() { return /* binding */ createProjection; },\n  "h_": function() { return /* binding */ disableCoordinateWarning; },\n  "OP": function() { return /* binding */ equivalent; },\n  "Vs": function() { return /* binding */ fromUserCoordinate; },\n  "dY": function() { return /* binding */ fromUserExtent; },\n  "U2": function() { return /* binding */ get; },\n  "_Q": function() { return /* binding */ getPointResolution; },\n  "Ck": function() { return /* binding */ getTransform; },\n  "WO": function() { return /* binding */ getTransformFromProjections; },\n  "Cs": function() { return /* binding */ getUserProjection; },\n  "lO": function() { return /* binding */ toUserCoordinate; },\n  "Fj": function() { return /* binding */ toUserExtent; },\n  "on": function() { return /* binding */ toUserResolution; },\n  "vs": function() { return /* binding */ transform; }\n});\n\n// UNUSED EXPORTS: Projection, addCommon, addCoordinateTransforms, addEquivalentProjections, addEquivalentTransforms, addProjection, addProjections, clearAllProjections, clearUserProjection, cloneTransform, createSafeCoordinateTransform, createTransformFromCoordinateTransform, fromLonLat, fromUserResolution, identityTransform, setUserProjection, toLonLat, transformExtent, transformWithProjections, useGeographic\n\n;// CONCATENATED MODULE: ./node_modules/ol/proj/Units.js\n/**\n * @module ol/proj/Units\n */\n\n/**\n * @typedef {\'radians\' | \'degrees\' | \'ft\' | \'m\' | \'pixels\' | \'tile-pixels\' | \'us-ft\'} Units\n * Projection units.\n */\n\n/**\n * See http://duff.ess.washington.edu/data/raster/drg/docs/geotiff.txt\n * @type {Object<number, Units>}\n */\nconst unitByCode = {\n  \'9001\': \'m\',\n  \'9002\': \'ft\',\n  \'9003\': \'us-ft\',\n  \'9101\': \'radians\',\n  \'9102\': \'degrees\',\n};\n\n/**\n * @param {number} code Unit code.\n * @return {Units} Units.\n */\nfunction fromCode(code) {\n  return unitByCode[code];\n}\n\n/**\n * @typedef {Object} MetersPerUnitLookup\n * @property {number} radians Radians\n * @property {number} degrees Degrees\n * @property {number} ft  Feet\n * @property {number} m Meters\n * @property {number} us-ft US feet\n */\n\n/**\n * Meters per unit lookup table.\n * @const\n * @type {MetersPerUnitLookup}\n * @api\n */\nconst Units_METERS_PER_UNIT = {\n  // use the radius of the Normal sphere\n  \'radians\': 6370997 / (2 * Math.PI),\n  \'degrees\': (2 * Math.PI * 6370997) / 360,\n  \'ft\': 0.3048,\n  \'m\': 1,\n  \'us-ft\': 1200 / 3937,\n};\n\n;// CONCATENATED MODULE: ./node_modules/ol/proj/Projection.js\n/**\n * @module ol/proj/Projection\n */\n\n\n/**\n * @typedef {Object} Options\n * @property {string} code The SRS identifier code, e.g. `EPSG:4326`.\n * @property {import("./Units.js").Units} [units] Units. Required unless a\n * proj4 projection is defined for `code`.\n * @property {import("../extent.js").Extent} [extent] The validity extent for the SRS.\n * @property {string} [axisOrientation=\'enu\'] The axis orientation as specified in Proj4.\n * @property {boolean} [global=false] Whether the projection is valid for the whole globe.\n * @property {number} [metersPerUnit] The meters per unit for the SRS.\n * If not provided, the `units` are used to get the meters per unit from the {@link METERS_PER_UNIT}\n * lookup table.\n * @property {import("../extent.js").Extent} [worldExtent] The world extent for the SRS.\n * @property {function(number, import("../coordinate.js").Coordinate):number} [getPointResolution]\n * Function to determine resolution at a point. The function is called with a\n * `number` view resolution and a {@link module:ol/coordinate~Coordinate} as arguments, and returns\n * the `number` resolution in projection units at the passed coordinate. If this is `undefined`,\n * the default {@link module:ol/proj.getPointResolution} function will be used.\n */\n\n/**\n * @classdesc\n * Projection definition class. One of these is created for each projection\n * supported in the application and stored in the {@link module:ol/proj} namespace.\n * You can use these in applications, but this is not required, as API params\n * and options use {@link module:ol/proj~ProjectionLike} which means the simple string\n * code will suffice.\n *\n * You can use {@link module:ol/proj.get} to retrieve the object for a particular\n * projection.\n *\n * The library includes definitions for `EPSG:4326` and `EPSG:3857`, together\n * with the following aliases:\n * * `EPSG:4326`: CRS:84, urn:ogc:def:crs:EPSG:6.6:4326,\n *     urn:ogc:def:crs:OGC:1.3:CRS84, urn:ogc:def:crs:OGC:2:84,\n *     http://www.opengis.net/gml/srs/epsg.xml#4326,\n *     urn:x-ogc:def:crs:EPSG:4326\n * * `EPSG:3857`: EPSG:102100, EPSG:102113, EPSG:900913,\n *     urn:ogc:def:crs:EPSG:6.18:3:3857,\n *     http://www.opengis.net/gml/srs/epsg.xml#3857\n *\n * If you use [proj4js](https://github.com/proj4js/proj4js), aliases can\n * be added using `proj4.defs()`. After all required projection definitions are\n * added, call the {@link module:ol/proj/proj4.register} function.\n *\n * @api\n */\nclass Projection {\n  /**\n   * @param {Options} options Projection options.\n   */\n  constructor(options) {\n    /**\n     * @private\n     * @type {string}\n     */\n    this.code_ = options.code;\n\n    /**\n     * Units of projected coordinates. When set to `TILE_PIXELS`, a\n     * `this.extent_` and `this.worldExtent_` must be configured properly for each\n     * tile.\n     * @private\n     * @type {import("./Units.js").Units}\n     */\n    this.units_ = /** @type {import("./Units.js").Units} */ (options.units);\n\n    /**\n     * Validity extent of the projection in projected coordinates. For projections\n     * with `TILE_PIXELS` units, this is the extent of the tile in\n     * tile pixel space.\n     * @private\n     * @type {import("../extent.js").Extent}\n     */\n    this.extent_ = options.extent !== undefined ? options.extent : null;\n\n    /**\n     * Extent of the world in EPSG:4326. For projections with\n     * `TILE_PIXELS` units, this is the extent of the tile in\n     * projected coordinate space.\n     * @private\n     * @type {import("../extent.js").Extent}\n     */\n    this.worldExtent_ =\n      options.worldExtent !== undefined ? options.worldExtent : null;\n\n    /**\n     * @private\n     * @type {string}\n     */\n    this.axisOrientation_ =\n      options.axisOrientation !== undefined ? options.axisOrientation : \'enu\';\n\n    /**\n     * @private\n     * @type {boolean}\n     */\n    this.global_ = options.global !== undefined ? options.global : false;\n\n    /**\n     * @private\n     * @type {boolean}\n     */\n    this.canWrapX_ = !!(this.global_ && this.extent_);\n\n    /**\n     * @private\n     * @type {function(number, import("../coordinate.js").Coordinate):number|undefined}\n     */\n    this.getPointResolutionFunc_ = options.getPointResolution;\n\n    /**\n     * @private\n     * @type {import("../tilegrid/TileGrid.js").default}\n     */\n    this.defaultTileGrid_ = null;\n\n    /**\n     * @private\n     * @type {number|undefined}\n     */\n    this.metersPerUnit_ = options.metersPerUnit;\n  }\n\n  /**\n   * @return {boolean} The projection is suitable for wrapping the x-axis\n   */\n  canWrapX() {\n    return this.canWrapX_;\n  }\n\n  /**\n   * Get the code for this projection, e.g. \'EPSG:4326\'.\n   * @return {string} Code.\n   * @api\n   */\n  getCode() {\n    return this.code_;\n  }\n\n  /**\n   * Get the validity extent for this projection.\n   * @return {import("../extent.js").Extent} Extent.\n   * @api\n   */\n  getExtent() {\n    return this.extent_;\n  }\n\n  /**\n   * Get the units of this projection.\n   * @return {import("./Units.js").Units} Units.\n   * @api\n   */\n  getUnits() {\n    return this.units_;\n  }\n\n  /**\n   * Get the amount of meters per unit of this projection.  If the projection is\n   * not configured with `metersPerUnit` or a units identifier, the return is\n   * `undefined`.\n   * @return {number|undefined} Meters.\n   * @api\n   */\n  getMetersPerUnit() {\n    return this.metersPerUnit_ || Units_METERS_PER_UNIT[this.units_];\n  }\n\n  /**\n   * Get the world extent for this projection.\n   * @return {import("../extent.js").Extent} Extent.\n   * @api\n   */\n  getWorldExtent() {\n    return this.worldExtent_;\n  }\n\n  /**\n   * Get the axis orientation of this projection.\n   * Example values are:\n   * enu - the default easting, northing, elevation.\n   * neu - northing, easting, up - useful for "lat/long" geographic coordinates,\n   *     or south orientated transverse mercator.\n   * wnu - westing, northing, up - some planetary coordinate systems have\n   *     "west positive" coordinate systems\n   * @return {string} Axis orientation.\n   * @api\n   */\n  getAxisOrientation() {\n    return this.axisOrientation_;\n  }\n\n  /**\n   * Is this projection a global projection which spans the whole world?\n   * @return {boolean} Whether the projection is global.\n   * @api\n   */\n  isGlobal() {\n    return this.global_;\n  }\n\n  /**\n   * Set if the projection is a global projection which spans the whole world\n   * @param {boolean} global Whether the projection is global.\n   * @api\n   */\n  setGlobal(global) {\n    this.global_ = global;\n    this.canWrapX_ = !!(global && this.extent_);\n  }\n\n  /**\n   * @return {import("../tilegrid/TileGrid.js").default} The default tile grid.\n   */\n  getDefaultTileGrid() {\n    return this.defaultTileGrid_;\n  }\n\n  /**\n   * @param {import("../tilegrid/TileGrid.js").default} tileGrid The default tile grid.\n   */\n  setDefaultTileGrid(tileGrid) {\n    this.defaultTileGrid_ = tileGrid;\n  }\n\n  /**\n   * Set the validity extent for this projection.\n   * @param {import("../extent.js").Extent} extent Extent.\n   * @api\n   */\n  setExtent(extent) {\n    this.extent_ = extent;\n    this.canWrapX_ = !!(this.global_ && extent);\n  }\n\n  /**\n   * Set the world extent for this projection.\n   * @param {import("../extent.js").Extent} worldExtent World extent\n   *     [minlon, minlat, maxlon, maxlat].\n   * @api\n   */\n  setWorldExtent(worldExtent) {\n    this.worldExtent_ = worldExtent;\n  }\n\n  /**\n   * Set the getPointResolution function (see {@link module:ol/proj.getPointResolution}\n   * for this projection.\n   * @param {function(number, import("../coordinate.js").Coordinate):number} func Function\n   * @api\n   */\n  setGetPointResolution(func) {\n    this.getPointResolutionFunc_ = func;\n  }\n\n  /**\n   * Get the custom point resolution function for this projection (if set).\n   * @return {function(number, import("../coordinate.js").Coordinate):number|undefined} The custom point\n   * resolution function (if set).\n   */\n  getPointResolutionFunc() {\n    return this.getPointResolutionFunc_;\n  }\n}\n\n/* harmony default export */ var proj_Projection = (Projection);\n\n;// CONCATENATED MODULE: ./node_modules/ol/proj/epsg3857.js\n/**\n * @module ol/proj/epsg3857\n */\n\n\n/**\n * Radius of WGS84 sphere\n *\n * @const\n * @type {number}\n */\nconst RADIUS = 6378137;\n\n/**\n * @const\n * @type {number}\n */\nconst HALF_SIZE = Math.PI * RADIUS;\n\n/**\n * @const\n * @type {import("../extent.js").Extent}\n */\nconst EXTENT = [-HALF_SIZE, -HALF_SIZE, HALF_SIZE, HALF_SIZE];\n\n/**\n * @const\n * @type {import("../extent.js").Extent}\n */\nconst WORLD_EXTENT = [-180, -85, 180, 85];\n\n/**\n * Maximum safe value in y direction\n * @const\n * @type {number}\n */\nconst MAX_SAFE_Y = RADIUS * Math.log(Math.tan(Math.PI / 2));\n\n/**\n * @classdesc\n * Projection object for web/spherical Mercator (EPSG:3857).\n */\nclass EPSG3857Projection extends proj_Projection {\n  /**\n   * @param {string} code Code.\n   */\n  constructor(code) {\n    super({\n      code: code,\n      units: \'m\',\n      extent: EXTENT,\n      global: true,\n      worldExtent: WORLD_EXTENT,\n      getPointResolution: function (resolution, point) {\n        return resolution / Math.cosh(point[1] / RADIUS);\n      },\n    });\n  }\n}\n\n/**\n * Projections equal to EPSG:3857.\n *\n * @const\n * @type {Array<import("./Projection.js").default>}\n */\nconst PROJECTIONS = [\n  new EPSG3857Projection(\'EPSG:3857\'),\n  new EPSG3857Projection(\'EPSG:102100\'),\n  new EPSG3857Projection(\'EPSG:102113\'),\n  new EPSG3857Projection(\'EPSG:900913\'),\n  new EPSG3857Projection(\'http://www.opengis.net/def/crs/EPSG/0/3857\'),\n  new EPSG3857Projection(\'http://www.opengis.net/gml/srs/epsg.xml#3857\'),\n];\n\n/**\n * Transformation from EPSG:4326 to EPSG:3857.\n *\n * @param {Array<number>} input Input array of coordinate values.\n * @param {Array<number>} [output] Output array of coordinate values.\n * @param {number} [dimension] Dimension (default is `2`).\n * @return {Array<number>} Output array of coordinate values.\n */\nfunction fromEPSG4326(input, output, dimension) {\n  const length = input.length;\n  dimension = dimension > 1 ? dimension : 2;\n  if (output === undefined) {\n    if (dimension > 2) {\n      // preserve values beyond second dimension\n      output = input.slice();\n    } else {\n      output = new Array(length);\n    }\n  }\n  for (let i = 0; i < length; i += dimension) {\n    output[i] = (HALF_SIZE * input[i]) / 180;\n    let y = RADIUS * Math.log(Math.tan((Math.PI * (+input[i + 1] + 90)) / 360));\n    if (y > MAX_SAFE_Y) {\n      y = MAX_SAFE_Y;\n    } else if (y < -MAX_SAFE_Y) {\n      y = -MAX_SAFE_Y;\n    }\n    output[i + 1] = y;\n  }\n  return output;\n}\n\n/**\n * Transformation from EPSG:3857 to EPSG:4326.\n *\n * @param {Array<number>} input Input array of coordinate values.\n * @param {Array<number>} [output] Output array of coordinate values.\n * @param {number} [dimension] Dimension (default is `2`).\n * @return {Array<number>} Output array of coordinate values.\n */\nfunction toEPSG4326(input, output, dimension) {\n  const length = input.length;\n  dimension = dimension > 1 ? dimension : 2;\n  if (output === undefined) {\n    if (dimension > 2) {\n      // preserve values beyond second dimension\n      output = input.slice();\n    } else {\n      output = new Array(length);\n    }\n  }\n  for (let i = 0; i < length; i += dimension) {\n    output[i] = (180 * input[i]) / HALF_SIZE;\n    output[i + 1] =\n      (360 * Math.atan(Math.exp(input[i + 1] / RADIUS))) / Math.PI - 90;\n  }\n  return output;\n}\n\n;// CONCATENATED MODULE: ./node_modules/ol/proj/epsg4326.js\n/**\n * @module ol/proj/epsg4326\n */\n\n\n/**\n * Semi-major radius of the WGS84 ellipsoid.\n *\n * @const\n * @type {number}\n */\nconst epsg4326_RADIUS = 6378137;\n\n/**\n * Extent of the EPSG:4326 projection which is the whole world.\n *\n * @const\n * @type {import("../extent.js").Extent}\n */\nconst epsg4326_EXTENT = [-180, -90, 180, 90];\n\n/**\n * @const\n * @type {number}\n */\nconst epsg4326_METERS_PER_UNIT = (Math.PI * epsg4326_RADIUS) / 180;\n\n/**\n * @classdesc\n * Projection object for WGS84 geographic coordinates (EPSG:4326).\n *\n * Note that OpenLayers does not strictly comply with the EPSG definition.\n * The EPSG registry defines 4326 as a CRS for Latitude,Longitude (y,x).\n * OpenLayers treats EPSG:4326 as a pseudo-projection, with x,y coordinates.\n */\nclass EPSG4326Projection extends proj_Projection {\n  /**\n   * @param {string} code Code.\n   * @param {string} [axisOrientation] Axis orientation.\n   */\n  constructor(code, axisOrientation) {\n    super({\n      code: code,\n      units: \'degrees\',\n      extent: epsg4326_EXTENT,\n      axisOrientation: axisOrientation,\n      global: true,\n      metersPerUnit: epsg4326_METERS_PER_UNIT,\n      worldExtent: epsg4326_EXTENT,\n    });\n  }\n}\n\n/**\n * Projections equal to EPSG:4326.\n *\n * @const\n * @type {Array<import("./Projection.js").default>}\n */\nconst epsg4326_PROJECTIONS = [\n  new EPSG4326Projection(\'CRS:84\'),\n  new EPSG4326Projection(\'EPSG:4326\', \'neu\'),\n  new EPSG4326Projection(\'urn:ogc:def:crs:OGC:1.3:CRS84\'),\n  new EPSG4326Projection(\'urn:ogc:def:crs:OGC:2:84\'),\n  new EPSG4326Projection(\'http://www.opengis.net/def/crs/OGC/1.3/CRS84\'),\n  new EPSG4326Projection(\'http://www.opengis.net/gml/srs/epsg.xml#4326\', \'neu\'),\n  new EPSG4326Projection(\'http://www.opengis.net/def/crs/EPSG/0/4326\', \'neu\'),\n];\n\n// EXTERNAL MODULE: ./node_modules/ol/proj/projections.js\nvar projections = __webpack_require__(88920);\n// EXTERNAL MODULE: ./node_modules/ol/proj/transforms.js\nvar transforms = __webpack_require__(49556);\n// EXTERNAL MODULE: ./node_modules/ol/extent.js\nvar ol_extent = __webpack_require__(28641);\n// EXTERNAL MODULE: ./node_modules/ol/coordinate.js\nvar ol_coordinate = __webpack_require__(91900);\n// EXTERNAL MODULE: ./node_modules/ol/sphere.js\nvar sphere = __webpack_require__(97580);\n// EXTERNAL MODULE: ./node_modules/ol/console.js\nvar console = __webpack_require__(70044);\n;// CONCATENATED MODULE: ./node_modules/ol/proj.js\n/**\n * @module ol/proj\n */\n\n/**\n * The ol/proj module stores:\n * * a list of {@link module:ol/proj/Projection~Projection}\n * objects, one for each projection supported by the application\n * * a list of transform functions needed to convert coordinates in one projection\n * into another.\n *\n * The static functions are the methods used to maintain these.\n * Each transform function can handle not only simple coordinate pairs, but also\n * large arrays of coordinates such as vector geometries.\n *\n * When loaded, the library adds projection objects for EPSG:4326 (WGS84\n * geographic coordinates) and EPSG:3857 (Web or Spherical Mercator, as used\n * for example by Bing Maps or OpenStreetMap), together with the relevant\n * transform functions.\n *\n * Additional transforms may be added by using the http://proj4js.org/\n * library (version 2.2 or later). You can use the full build supplied by\n * Proj4js, or create a custom build to support those projections you need; see\n * the Proj4js website for how to do this. You also need the Proj4js definitions\n * for the required projections. These definitions can be obtained from\n * https://epsg.io/, and are a JS function, so can be loaded in a script\n * tag (as in the examples) or pasted into your application.\n *\n * After all required projection definitions are added to proj4\'s registry (by\n * using `proj4.defs()`), simply call `register(proj4)` from the `ol/proj/proj4`\n * package. Existing transforms are not changed by this function. See\n * examples/wms-image-custom-proj for an example of this.\n *\n * Additional projection definitions can be registered with `proj4.defs()` any\n * time. Just make sure to call `register(proj4)` again; for example, with user-supplied data where you don\'t\n * know in advance what projections are needed, you can initially load minimal\n * support and then load whichever are requested.\n *\n * Note that Proj4js does not support projection extents. If you want to add\n * one for creating default tile grids, you can add it after the Projection\n * object has been created with `setExtent`, for example,\n * `get(\'EPSG:1234\').setExtent(extent)`.\n *\n * In addition to Proj4js support, any transform functions can be added with\n * {@link module:ol/proj.addCoordinateTransforms}. To use this, you must first create\n * a {@link module:ol/proj/Projection~Projection} object for the new projection and add it with\n * {@link module:ol/proj.addProjection}. You can then add the forward and inverse\n * functions with {@link module:ol/proj.addCoordinateTransforms}. See\n * examples/wms-custom-proj for an example of this.\n *\n * Note that if no transforms are needed and you only need to define the\n * projection, just add a {@link module:ol/proj/Projection~Projection} with\n * {@link module:ol/proj.addProjection}. See examples/wms-no-proj for an example of\n * this.\n */\n\n\n\n\n\n\n\n\n\n\n\n\n/**\n * A projection as {@link module:ol/proj/Projection~Projection}, SRS identifier\n * string or undefined.\n * @typedef {Projection|string|undefined} ProjectionLike\n * @api\n */\n\n/**\n * A transform function accepts an array of input coordinate values, an optional\n * output array, and an optional dimension (default should be 2).  The function\n * transforms the input coordinate values, populates the output array, and\n * returns the output array.\n *\n * @typedef {function(Array<number>, Array<number>=, number=): Array<number>} TransformFunction\n * @api\n */\n\n\n\n\n\nlet showCoordinateWarning = true;\n\n/**\n * @param {boolean} [disable = true] Disable console info about `useGeographic()`\n */\nfunction disableCoordinateWarning(disable) {\n  const hide = disable === undefined ? true : disable;\n  showCoordinateWarning = !hide;\n}\n\n/**\n * @param {Array<number>} input Input coordinate array.\n * @param {Array<number>} [output] Output array of coordinate values.\n * @return {Array<number>} Output coordinate array (new array, same coordinate\n *     values).\n */\nfunction cloneTransform(input, output) {\n  if (output !== undefined) {\n    for (let i = 0, ii = input.length; i < ii; ++i) {\n      output[i] = input[i];\n    }\n    output = output;\n  } else {\n    output = input.slice();\n  }\n  return output;\n}\n\n/**\n * @param {Array<number>} input Input coordinate array.\n * @param {Array<number>} [output] Output array of coordinate values.\n * @return {Array<number>} Input coordinate array (same array as input).\n */\nfunction identityTransform(input, output) {\n  if (output !== undefined && input !== output) {\n    for (let i = 0, ii = input.length; i < ii; ++i) {\n      output[i] = input[i];\n    }\n    input = output;\n  }\n  return input;\n}\n\n/**\n * Add a Projection object to the list of supported projections that can be\n * looked up by their code.\n *\n * @param {Projection} projection Projection instance.\n * @api\n */\nfunction addProjection(projection) {\n  (0,projections/* add */.IH)(projection.getCode(), projection);\n  (0,transforms/* add */.IH)(projection, projection, cloneTransform);\n}\n\n/**\n * @param {Array<Projection>} projections Projections.\n */\nfunction addProjections(projections) {\n  projections.forEach(addProjection);\n}\n\n/**\n * Fetches a Projection object for the code specified.\n *\n * @param {ProjectionLike} projectionLike Either a code string which is\n *     a combination of authority and identifier such as "EPSG:4326", or an\n *     existing projection object, or undefined.\n * @return {Projection|null} Projection object, or null if not in list.\n * @api\n */\nfunction get(projectionLike) {\n  return typeof projectionLike === \'string\'\n    ? (0,projections/* get */.U2)(/** @type {string} */ (projectionLike))\n    : /** @type {Projection} */ (projectionLike) || null;\n}\n\n/**\n * Get the resolution of the point in degrees or distance units.\n * For projections with degrees as the unit this will simply return the\n * provided resolution. For other projections the point resolution is\n * by default estimated by transforming the `point` pixel to EPSG:4326,\n * measuring its width and height on the normal sphere,\n * and taking the average of the width and height.\n * A custom function can be provided for a specific projection, either\n * by setting the `getPointResolution` option in the\n * {@link module:ol/proj/Projection~Projection} constructor or by using\n * {@link module:ol/proj/Projection~Projection#setGetPointResolution} to change an existing\n * projection object.\n * @param {ProjectionLike} projection The projection.\n * @param {number} resolution Nominal resolution in projection units.\n * @param {import("./coordinate.js").Coordinate} point Point to find adjusted resolution at.\n * @param {import("./proj/Units.js").Units} [units] Units to get the point resolution in.\n * Default is the projection\'s units.\n * @return {number} Point resolution.\n * @api\n */\nfunction getPointResolution(projection, resolution, point, units) {\n  projection = get(projection);\n  let pointResolution;\n  const getter = projection.getPointResolutionFunc();\n  if (getter) {\n    pointResolution = getter(resolution, point);\n    if (units && units !== projection.getUnits()) {\n      const metersPerUnit = projection.getMetersPerUnit();\n      if (metersPerUnit) {\n        pointResolution =\n          (pointResolution * metersPerUnit) / Units_METERS_PER_UNIT[units];\n      }\n    }\n  } else {\n    const projUnits = projection.getUnits();\n    if ((projUnits == \'degrees\' && !units) || units == \'degrees\') {\n      pointResolution = resolution;\n    } else {\n      // Estimate point resolution by transforming the center pixel to EPSG:4326,\n      // measuring its width and height on the normal sphere, and taking the\n      // average of the width and height.\n      const toEPSG4326 = getTransformFromProjections(\n        projection,\n        get(\'EPSG:4326\')\n      );\n      if (toEPSG4326 === identityTransform && projUnits !== \'degrees\') {\n        // no transform is available\n        pointResolution = resolution * projection.getMetersPerUnit();\n      } else {\n        let vertices = [\n          point[0] - resolution / 2,\n          point[1],\n          point[0] + resolution / 2,\n          point[1],\n          point[0],\n          point[1] - resolution / 2,\n          point[0],\n          point[1] + resolution / 2,\n        ];\n        vertices = toEPSG4326(vertices, vertices, 2);\n        const width = (0,sphere/* getDistance */.Sp)(vertices.slice(0, 2), vertices.slice(2, 4));\n        const height = (0,sphere/* getDistance */.Sp)(vertices.slice(4, 6), vertices.slice(6, 8));\n        pointResolution = (width + height) / 2;\n      }\n      const metersPerUnit = units\n        ? Units_METERS_PER_UNIT[units]\n        : projection.getMetersPerUnit();\n      if (metersPerUnit !== undefined) {\n        pointResolution /= metersPerUnit;\n      }\n    }\n  }\n  return pointResolution;\n}\n\n/**\n * Registers transformation functions that don\'t alter coordinates. Those allow\n * to transform between projections with equal meaning.\n *\n * @param {Array<Projection>} projections Projections.\n * @api\n */\nfunction addEquivalentProjections(projections) {\n  addProjections(projections);\n  projections.forEach(function (source) {\n    projections.forEach(function (destination) {\n      if (source !== destination) {\n        (0,transforms/* add */.IH)(source, destination, cloneTransform);\n      }\n    });\n  });\n}\n\n/**\n * Registers transformation functions to convert coordinates in any projection\n * in projection1 to any projection in projection2.\n *\n * @param {Array<Projection>} projections1 Projections with equal\n *     meaning.\n * @param {Array<Projection>} projections2 Projections with equal\n *     meaning.\n * @param {TransformFunction} forwardTransform Transformation from any\n *   projection in projection1 to any projection in projection2.\n * @param {TransformFunction} inverseTransform Transform from any projection\n *   in projection2 to any projection in projection1..\n */\nfunction addEquivalentTransforms(\n  projections1,\n  projections2,\n  forwardTransform,\n  inverseTransform\n) {\n  projections1.forEach(function (projection1) {\n    projections2.forEach(function (projection2) {\n      (0,transforms/* add */.IH)(projection1, projection2, forwardTransform);\n      (0,transforms/* add */.IH)(projection2, projection1, inverseTransform);\n    });\n  });\n}\n\n/**\n * Clear all cached projections and transforms.\n */\nfunction clearAllProjections() {\n  clearProj();\n  clearTransformFuncs();\n}\n\n/**\n * @param {Projection|string|undefined} projection Projection.\n * @param {string} defaultCode Default code.\n * @return {Projection} Projection.\n */\nfunction createProjection(projection, defaultCode) {\n  if (!projection) {\n    return get(defaultCode);\n  } else if (typeof projection === \'string\') {\n    return get(projection);\n  }\n  return /** @type {Projection} */ (projection);\n}\n\n/**\n * Creates a {@link module:ol/proj~TransformFunction} from a simple 2D coordinate transform\n * function.\n * @param {function(import("./coordinate.js").Coordinate): import("./coordinate.js").Coordinate} coordTransform Coordinate\n *     transform.\n * @return {TransformFunction} Transform function.\n */\nfunction createTransformFromCoordinateTransform(coordTransform) {\n  return (\n    /**\n     * @param {Array<number>} input Input.\n     * @param {Array<number>} [output] Output.\n     * @param {number} [dimension] Dimension.\n     * @return {Array<number>} Output.\n     */\n    function (input, output, dimension) {\n      const length = input.length;\n      dimension = dimension !== undefined ? dimension : 2;\n      output = output !== undefined ? output : new Array(length);\n      for (let i = 0; i < length; i += dimension) {\n        const point = coordTransform(input.slice(i, i + dimension));\n        const pointLength = point.length;\n        for (let j = 0, jj = dimension; j < jj; ++j) {\n          output[i + j] = j >= pointLength ? input[i + j] : point[j];\n        }\n      }\n      return output;\n    }\n  );\n}\n\n/**\n * Registers coordinate transform functions to convert coordinates between the\n * source projection and the destination projection.\n * The forward and inverse functions convert coordinate pairs; this function\n * converts these into the functions used internally which also handle\n * extents and coordinate arrays.\n *\n * @param {ProjectionLike} source Source projection.\n * @param {ProjectionLike} destination Destination projection.\n * @param {function(import("./coordinate.js").Coordinate): import("./coordinate.js").Coordinate} forward The forward transform\n *     function (that is, from the source projection to the destination\n *     projection) that takes a {@link module:ol/coordinate~Coordinate} as argument and returns\n *     the transformed {@link module:ol/coordinate~Coordinate}.\n * @param {function(import("./coordinate.js").Coordinate): import("./coordinate.js").Coordinate} inverse The inverse transform\n *     function (that is, from the destination projection to the source\n *     projection) that takes a {@link module:ol/coordinate~Coordinate} as argument and returns\n *     the transformed {@link module:ol/coordinate~Coordinate}. If the transform function can only\n *     transform less dimensions than the input coordinate, it is supposeed to return a coordinate\n *     with only the length it can transform. The other dimensions will be taken unchanged from the\n *     source.\n * @api\n */\nfunction addCoordinateTransforms(source, destination, forward, inverse) {\n  const sourceProj = get(source);\n  const destProj = get(destination);\n  addTransformFunc(\n    sourceProj,\n    destProj,\n    createTransformFromCoordinateTransform(forward)\n  );\n  addTransformFunc(\n    destProj,\n    sourceProj,\n    createTransformFromCoordinateTransform(inverse)\n  );\n}\n\n/**\n * Transforms a coordinate from longitude/latitude to a different projection.\n * @param {import("./coordinate.js").Coordinate} coordinate Coordinate as longitude and latitude, i.e.\n *     an array with longitude as 1st and latitude as 2nd element.\n * @param {ProjectionLike} [projection] Target projection. The\n *     default is Web Mercator, i.e. \'EPSG:3857\'.\n * @return {import("./coordinate.js").Coordinate} Coordinate projected to the target projection.\n * @api\n */\nfunction fromLonLat(coordinate, projection) {\n  disableCoordinateWarning();\n  return transform(\n    coordinate,\n    \'EPSG:4326\',\n    projection !== undefined ? projection : \'EPSG:3857\'\n  );\n}\n\n/**\n * Transforms a coordinate to longitude/latitude.\n * @param {import("./coordinate.js").Coordinate} coordinate Projected coordinate.\n * @param {ProjectionLike} [projection] Projection of the coordinate.\n *     The default is Web Mercator, i.e. \'EPSG:3857\'.\n * @return {import("./coordinate.js").Coordinate} Coordinate as longitude and latitude, i.e. an array\n *     with longitude as 1st and latitude as 2nd element.\n * @api\n */\nfunction toLonLat(coordinate, projection) {\n  const lonLat = transform(\n    coordinate,\n    projection !== undefined ? projection : \'EPSG:3857\',\n    \'EPSG:4326\'\n  );\n  const lon = lonLat[0];\n  if (lon < -180 || lon > 180) {\n    lonLat[0] = modulo(lon + 180, 360) - 180;\n  }\n  return lonLat;\n}\n\n/**\n * Checks if two projections are the same, that is every coordinate in one\n * projection does represent the same geographic point as the same coordinate in\n * the other projection.\n *\n * @param {Projection} projection1 Projection 1.\n * @param {Projection} projection2 Projection 2.\n * @return {boolean} Equivalent.\n * @api\n */\nfunction equivalent(projection1, projection2) {\n  if (projection1 === projection2) {\n    return true;\n  }\n  const equalUnits = projection1.getUnits() === projection2.getUnits();\n  if (projection1.getCode() === projection2.getCode()) {\n    return equalUnits;\n  }\n  const transformFunc = getTransformFromProjections(projection1, projection2);\n  return transformFunc === cloneTransform && equalUnits;\n}\n\n/**\n * Searches in the list of transform functions for the function for converting\n * coordinates from the source projection to the destination projection.\n *\n * @param {Projection} sourceProjection Source Projection object.\n * @param {Projection} destinationProjection Destination Projection\n *     object.\n * @return {TransformFunction} Transform function.\n */\nfunction getTransformFromProjections(\n  sourceProjection,\n  destinationProjection\n) {\n  const sourceCode = sourceProjection.getCode();\n  const destinationCode = destinationProjection.getCode();\n  let transformFunc = (0,transforms/* get */.U2)(sourceCode, destinationCode);\n  if (!transformFunc) {\n    transformFunc = identityTransform;\n  }\n  return transformFunc;\n}\n\n/**\n * Given the projection-like objects, searches for a transformation\n * function to convert a coordinates array from the source projection to the\n * destination projection.\n *\n * @param {ProjectionLike} source Source.\n * @param {ProjectionLike} destination Destination.\n * @return {TransformFunction} Transform function.\n * @api\n */\nfunction getTransform(source, destination) {\n  const sourceProjection = get(source);\n  const destinationProjection = get(destination);\n  return getTransformFromProjections(sourceProjection, destinationProjection);\n}\n\n/**\n * Transforms a coordinate from source projection to destination projection.\n * This returns a new coordinate (and does not modify the original).\n *\n * See {@link module:ol/proj.transformExtent} for extent transformation.\n * See the transform method of {@link module:ol/geom/Geometry~Geometry} and its\n * subclasses for geometry transforms.\n *\n * @param {import("./coordinate.js").Coordinate} coordinate Coordinate.\n * @param {ProjectionLike} source Source projection-like.\n * @param {ProjectionLike} destination Destination projection-like.\n * @return {import("./coordinate.js").Coordinate} Coordinate.\n * @api\n */\nfunction transform(coordinate, source, destination) {\n  const transformFunc = getTransform(source, destination);\n  return transformFunc(coordinate, undefined, coordinate.length);\n}\n\n/**\n * Transforms an extent from source projection to destination projection.  This\n * returns a new extent (and does not modify the original).\n *\n * @param {import("./extent.js").Extent} extent The extent to transform.\n * @param {ProjectionLike} source Source projection-like.\n * @param {ProjectionLike} destination Destination projection-like.\n * @param {number} [stops] Number of stops per side used for the transform.\n * By default only the corners are used.\n * @return {import("./extent.js").Extent} The transformed extent.\n * @api\n */\nfunction transformExtent(extent, source, destination, stops) {\n  const transformFunc = getTransform(source, destination);\n  return (0,ol_extent/* applyTransform */.Ne)(extent, transformFunc, undefined, stops);\n}\n\n/**\n * Transforms the given point to the destination projection.\n *\n * @param {import("./coordinate.js").Coordinate} point Point.\n * @param {Projection} sourceProjection Source projection.\n * @param {Projection} destinationProjection Destination projection.\n * @return {import("./coordinate.js").Coordinate} Point.\n */\nfunction transformWithProjections(\n  point,\n  sourceProjection,\n  destinationProjection\n) {\n  const transformFunc = getTransformFromProjections(\n    sourceProjection,\n    destinationProjection\n  );\n  return transformFunc(point);\n}\n\n/**\n * @type {Projection|null}\n */\nlet userProjection = null;\n\n/**\n * Set the projection for coordinates supplied from and returned by API methods.\n * This includes all API methods except for those interacting with tile grids.\n * @param {ProjectionLike} projection The user projection.\n * @api\n */\nfunction setUserProjection(projection) {\n  userProjection = get(projection);\n}\n\n/**\n * Clear the user projection if set.\n * @api\n */\nfunction clearUserProjection() {\n  userProjection = null;\n}\n\n/**\n * Get the projection for coordinates supplied from and returned by API methods.\n * Note that this method is not yet a part of the stable API.  Support for user\n * projections is not yet complete and should be considered experimental.\n * @return {Projection|null} The user projection (or null if not set).\n * @api\n */\nfunction getUserProjection() {\n  return userProjection;\n}\n\n/**\n * Use geographic coordinates (WGS-84 datum) in API methods.  This includes all API\n * methods except for those interacting with tile grids.\n * @api\n */\nfunction useGeographic() {\n  setUserProjection(\'EPSG:4326\');\n}\n\n/**\n * Return a coordinate transformed into the user projection.  If no user projection\n * is set, the original coordinate is returned.\n * @param {Array<number>} coordinate Input coordinate.\n * @param {ProjectionLike} sourceProjection The input coordinate projection.\n * @return {Array<number>} The input coordinate in the user projection.\n */\nfunction toUserCoordinate(coordinate, sourceProjection) {\n  if (!userProjection) {\n    return coordinate;\n  }\n  return transform(coordinate, sourceProjection, userProjection);\n}\n\n/**\n * Return a coordinate transformed from the user projection.  If no user projection\n * is set, the original coordinate is returned.\n * @param {Array<number>} coordinate Input coordinate.\n * @param {ProjectionLike} destProjection The destination projection.\n * @return {Array<number>} The input coordinate transformed.\n */\nfunction fromUserCoordinate(coordinate, destProjection) {\n  if (!userProjection) {\n    if (\n      showCoordinateWarning &&\n      !(0,ol_coordinate/* equals */.fS)(coordinate, [0, 0]) &&\n      coordinate[0] >= -180 &&\n      coordinate[0] <= 180 &&\n      coordinate[1] >= -90 &&\n      coordinate[1] <= 90\n    ) {\n      showCoordinateWarning = false;\n      (0,console/* warn */.ZK)(\n        \'Call useGeographic() from ol/proj once to work with [longitude, latitude] coordinates.\'\n      );\n    }\n    return coordinate;\n  }\n  return transform(coordinate, userProjection, destProjection);\n}\n\n/**\n * Return an extent transformed into the user projection.  If no user projection\n * is set, the original extent is returned.\n * @param {import("./extent.js").Extent} extent Input extent.\n * @param {ProjectionLike} sourceProjection The input extent projection.\n * @return {import("./extent.js").Extent} The input extent in the user projection.\n */\nfunction toUserExtent(extent, sourceProjection) {\n  if (!userProjection) {\n    return extent;\n  }\n  return transformExtent(extent, sourceProjection, userProjection);\n}\n\n/**\n * Return an extent transformed from the user projection.  If no user projection\n * is set, the original extent is returned.\n * @param {import("./extent.js").Extent} extent Input extent.\n * @param {ProjectionLike} destProjection The destination projection.\n * @return {import("./extent.js").Extent} The input extent transformed.\n */\nfunction fromUserExtent(extent, destProjection) {\n  if (!userProjection) {\n    return extent;\n  }\n  return transformExtent(extent, userProjection, destProjection);\n}\n\n/**\n * Return the resolution in user projection units per pixel. If no user projection\n * is set, or source or user projection are missing units, the original resolution\n * is returned.\n * @param {number} resolution Resolution in input projection units per pixel.\n * @param {ProjectionLike} sourceProjection The input projection.\n * @return {number} Resolution in user projection units per pixel.\n */\nfunction toUserResolution(resolution, sourceProjection) {\n  if (!userProjection) {\n    return resolution;\n  }\n  const sourceUnits = get(sourceProjection).getUnits();\n  const userUnits = userProjection.getUnits();\n  return sourceUnits && userUnits\n    ? (resolution * Units_METERS_PER_UNIT[sourceUnits]) / Units_METERS_PER_UNIT[userUnits]\n    : resolution;\n}\n\n/**\n * Return the resolution in user projection units per pixel. If no user projection\n * is set, or source or user projection are missing units, the original resolution\n * is returned.\n * @param {number} resolution Resolution in user projection units per pixel.\n * @param {ProjectionLike} destProjection The destination projection.\n * @return {number} Resolution in destination projection units per pixel.\n */\nfunction fromUserResolution(resolution, destProjection) {\n  if (!userProjection) {\n    return resolution;\n  }\n  const sourceUnits = get(destProjection).getUnits();\n  const userUnits = userProjection.getUnits();\n  return sourceUnits && userUnits\n    ? (resolution * METERS_PER_UNIT[userUnits]) / METERS_PER_UNIT[sourceUnits]\n    : resolution;\n}\n\n/**\n * Creates a safe coordinate transform function from a coordinate transform function.\n * "Safe" means that it can handle wrapping of x-coordinates for global projections,\n * and that coordinates exceeding the source projection validity extent\'s range will be\n * clamped to the validity range.\n * @param {Projection} sourceProj Source projection.\n * @param {Projection} destProj Destination projection.\n * @param {function(import("./coordinate.js").Coordinate): import("./coordinate.js").Coordinate} transform Transform function (source to destiation).\n * @return {function(import("./coordinate.js").Coordinate): import("./coordinate.js").Coordinate} Safe transform function (source to destiation).\n */\nfunction createSafeCoordinateTransform(sourceProj, destProj, transform) {\n  return function (coord) {\n    let transformed, worldsAway;\n    if (sourceProj.canWrapX()) {\n      const sourceExtent = sourceProj.getExtent();\n      const sourceExtentWidth = getWidth(sourceExtent);\n      coord = coord.slice(0);\n      worldsAway = getWorldsAway(coord, sourceProj, sourceExtentWidth);\n      if (worldsAway) {\n        // Move x to the real world\n        coord[0] = coord[0] - worldsAway * sourceExtentWidth;\n      }\n      coord[0] = clamp(coord[0], sourceExtent[0], sourceExtent[2]);\n      coord[1] = clamp(coord[1], sourceExtent[1], sourceExtent[3]);\n      transformed = transform(coord);\n    } else {\n      transformed = transform(coord);\n    }\n    if (worldsAway && destProj.canWrapX()) {\n      // Move transformed coordinate back to the offset world\n      transformed[0] += worldsAway * getWidth(destProj.getExtent());\n    }\n    return transformed;\n  };\n}\n\n/**\n * Add transforms to and from EPSG:4326 and EPSG:3857.  This function is called\n * by when this module is executed and should only need to be called again after\n * `clearAllProjections()` is called (e.g. in tests).\n */\nfunction addCommon() {\n  // Add transformations that don\'t alter coordinates to convert within set of\n  // projections with equal meaning.\n  addEquivalentProjections(PROJECTIONS);\n  addEquivalentProjections(epsg4326_PROJECTIONS);\n  // Add transformations to convert EPSG:4326 like coordinates to EPSG:3857 like\n  // coordinates and back.\n  addEquivalentTransforms(\n    epsg4326_PROJECTIONS,\n    PROJECTIONS,\n    fromEPSG4326,\n    toEPSG4326\n  );\n}\n\naddCommon();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLGdCQUFnQjtBQUMzQixZQUFZLFFBQVE7QUFDcEI7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixxQkFBZSxpQkFBaUIscUJBQWU7QUFDbkU7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLGdCQUFnQjtBQUMzQixZQUFZLFFBQVE7QUFDcEI7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxZQUFZO0FBQ3ZCLFdBQVcsWUFBWTtBQUN2QixXQUFXLHNGQUFzRjtBQUNqRyxZQUFZLHNGQUFzRjtBQUNsRztBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBLDJCQUEyQixXQUFvQjtBQUMvQywyQkFBMkIsb0JBQW9CO0FBQy9DO0FBQ0E7QUFDQTtBQUNBLElBQUksb0JBQW9CO0FBQ3hCLElBQUksV0FBb0I7QUFDeEIsSUFBSSxZQUFZO0FBQ2hCLElBQUksVUFBVTtBQUNkO0FBQ0E7O0FBRUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly92dWUzLXdlYnBhY2s1Ly4vbm9kZV9tb2R1bGVzL29sL3Byb2ovVW5pdHMuanM/ZGZmOCIsIndlYnBhY2s6Ly92dWUzLXdlYnBhY2s1Ly4vbm9kZV9tb2R1bGVzL29sL3Byb2ovUHJvamVjdGlvbi5qcz9jZmZkIiwid2VicGFjazovL3Z1ZTMtd2VicGFjazUvLi9ub2RlX21vZHVsZXMvb2wvcHJvai9lcHNnMzg1Ny5qcz85NGRmIiwid2VicGFjazovL3Z1ZTMtd2VicGFjazUvLi9ub2RlX21vZHVsZXMvb2wvcHJvai9lcHNnNDMyNi5qcz8yNThiIiwid2VicGFjazovL3Z1ZTMtd2VicGFjazUvLi9ub2RlX21vZHVsZXMvb2wvcHJvai5qcz84NmRjIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQG1vZHVsZSBvbC9wcm9qL1VuaXRzXG4gKi9cblxuLyoqXG4gKiBAdHlwZWRlZiB7J3JhZGlhbnMnIHwgJ2RlZ3JlZXMnIHwgJ2Z0JyB8ICdtJyB8ICdwaXhlbHMnIHwgJ3RpbGUtcGl4ZWxzJyB8ICd1cy1mdCd9IFVuaXRzXG4gKiBQcm9qZWN0aW9uIHVuaXRzLlxuICovXG5cbi8qKlxuICogU2VlIGh0dHA6Ly9kdWZmLmVzcy53YXNoaW5ndG9uLmVkdS9kYXRhL3Jhc3Rlci9kcmcvZG9jcy9nZW90aWZmLnR4dFxuICogQHR5cGUge09iamVjdDxudW1iZXIsIFVuaXRzPn1cbiAqL1xuY29uc3QgdW5pdEJ5Q29kZSA9IHtcbiAgJzkwMDEnOiAnbScsXG4gICc5MDAyJzogJ2Z0JyxcbiAgJzkwMDMnOiAndXMtZnQnLFxuICAnOTEwMSc6ICdyYWRpYW5zJyxcbiAgJzkxMDInOiAnZGVncmVlcycsXG59O1xuXG4vKipcbiAqIEBwYXJhbSB7bnVtYmVyfSBjb2RlIFVuaXQgY29kZS5cbiAqIEByZXR1cm4ge1VuaXRzfSBVbml0cy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGZyb21Db2RlKGNvZGUpIHtcbiAgcmV0dXJuIHVuaXRCeUNvZGVbY29kZV07XG59XG5cbi8qKlxuICogQHR5cGVkZWYge09iamVjdH0gTWV0ZXJzUGVyVW5pdExvb2t1cFxuICogQHByb3BlcnR5IHtudW1iZXJ9IHJhZGlhbnMgUmFkaWFuc1xuICogQHByb3BlcnR5IHtudW1iZXJ9IGRlZ3JlZXMgRGVncmVlc1xuICogQHByb3BlcnR5IHtudW1iZXJ9IGZ0ICBGZWV0XG4gKiBAcHJvcGVydHkge251bWJlcn0gbSBNZXRlcnNcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSB1cy1mdCBVUyBmZWV0XG4gKi9cblxuLyoqXG4gKiBNZXRlcnMgcGVyIHVuaXQgbG9va3VwIHRhYmxlLlxuICogQGNvbnN0XG4gKiBAdHlwZSB7TWV0ZXJzUGVyVW5pdExvb2t1cH1cbiAqIEBhcGlcbiAqL1xuZXhwb3J0IGNvbnN0IE1FVEVSU19QRVJfVU5JVCA9IHtcbiAgLy8gdXNlIHRoZSByYWRpdXMgb2YgdGhlIE5vcm1hbCBzcGhlcmVcbiAgJ3JhZGlhbnMnOiA2MzcwOTk3IC8gKDIgKiBNYXRoLlBJKSxcbiAgJ2RlZ3JlZXMnOiAoMiAqIE1hdGguUEkgKiA2MzcwOTk3KSAvIDM2MCxcbiAgJ2Z0JzogMC4zMDQ4LFxuICAnbSc6IDEsXG4gICd1cy1mdCc6IDEyMDAgLyAzOTM3LFxufTtcbiIsIi8qKlxuICogQG1vZHVsZSBvbC9wcm9qL1Byb2plY3Rpb25cbiAqL1xuaW1wb3J0IHtNRVRFUlNfUEVSX1VOSVR9IGZyb20gJy4vVW5pdHMuanMnO1xuXG4vKipcbiAqIEB0eXBlZGVmIHtPYmplY3R9IE9wdGlvbnNcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBjb2RlIFRoZSBTUlMgaWRlbnRpZmllciBjb2RlLCBlLmcuIGBFUFNHOjQzMjZgLlxuICogQHByb3BlcnR5IHtpbXBvcnQoXCIuL1VuaXRzLmpzXCIpLlVuaXRzfSBbdW5pdHNdIFVuaXRzLiBSZXF1aXJlZCB1bmxlc3MgYVxuICogcHJvajQgcHJvamVjdGlvbiBpcyBkZWZpbmVkIGZvciBgY29kZWAuXG4gKiBAcHJvcGVydHkge2ltcG9ydChcIi4uL2V4dGVudC5qc1wiKS5FeHRlbnR9IFtleHRlbnRdIFRoZSB2YWxpZGl0eSBleHRlbnQgZm9yIHRoZSBTUlMuXG4gKiBAcHJvcGVydHkge3N0cmluZ30gW2F4aXNPcmllbnRhdGlvbj0nZW51J10gVGhlIGF4aXMgb3JpZW50YXRpb24gYXMgc3BlY2lmaWVkIGluIFByb2o0LlxuICogQHByb3BlcnR5IHtib29sZWFufSBbZ2xvYmFsPWZhbHNlXSBXaGV0aGVyIHRoZSBwcm9qZWN0aW9uIGlzIHZhbGlkIGZvciB0aGUgd2hvbGUgZ2xvYmUuXG4gKiBAcHJvcGVydHkge251bWJlcn0gW21ldGVyc1BlclVuaXRdIFRoZSBtZXRlcnMgcGVyIHVuaXQgZm9yIHRoZSBTUlMuXG4gKiBJZiBub3QgcHJvdmlkZWQsIHRoZSBgdW5pdHNgIGFyZSB1c2VkIHRvIGdldCB0aGUgbWV0ZXJzIHBlciB1bml0IGZyb20gdGhlIHtAbGluayBNRVRFUlNfUEVSX1VOSVR9XG4gKiBsb29rdXAgdGFibGUuXG4gKiBAcHJvcGVydHkge2ltcG9ydChcIi4uL2V4dGVudC5qc1wiKS5FeHRlbnR9IFt3b3JsZEV4dGVudF0gVGhlIHdvcmxkIGV4dGVudCBmb3IgdGhlIFNSUy5cbiAqIEBwcm9wZXJ0eSB7ZnVuY3Rpb24obnVtYmVyLCBpbXBvcnQoXCIuLi9jb29yZGluYXRlLmpzXCIpLkNvb3JkaW5hdGUpOm51bWJlcn0gW2dldFBvaW50UmVzb2x1dGlvbl1cbiAqIEZ1bmN0aW9uIHRvIGRldGVybWluZSByZXNvbHV0aW9uIGF0IGEgcG9pbnQuIFRoZSBmdW5jdGlvbiBpcyBjYWxsZWQgd2l0aCBhXG4gKiBgbnVtYmVyYCB2aWV3IHJlc29sdXRpb24gYW5kIGEge0BsaW5rIG1vZHVsZTpvbC9jb29yZGluYXRlfkNvb3JkaW5hdGV9IGFzIGFyZ3VtZW50cywgYW5kIHJldHVybnNcbiAqIHRoZSBgbnVtYmVyYCByZXNvbHV0aW9uIGluIHByb2plY3Rpb24gdW5pdHMgYXQgdGhlIHBhc3NlZCBjb29yZGluYXRlLiBJZiB0aGlzIGlzIGB1bmRlZmluZWRgLFxuICogdGhlIGRlZmF1bHQge0BsaW5rIG1vZHVsZTpvbC9wcm9qLmdldFBvaW50UmVzb2x1dGlvbn0gZnVuY3Rpb24gd2lsbCBiZSB1c2VkLlxuICovXG5cbi8qKlxuICogQGNsYXNzZGVzY1xuICogUHJvamVjdGlvbiBkZWZpbml0aW9uIGNsYXNzLiBPbmUgb2YgdGhlc2UgaXMgY3JlYXRlZCBmb3IgZWFjaCBwcm9qZWN0aW9uXG4gKiBzdXBwb3J0ZWQgaW4gdGhlIGFwcGxpY2F0aW9uIGFuZCBzdG9yZWQgaW4gdGhlIHtAbGluayBtb2R1bGU6b2wvcHJvan0gbmFtZXNwYWNlLlxuICogWW91IGNhbiB1c2UgdGhlc2UgaW4gYXBwbGljYXRpb25zLCBidXQgdGhpcyBpcyBub3QgcmVxdWlyZWQsIGFzIEFQSSBwYXJhbXNcbiAqIGFuZCBvcHRpb25zIHVzZSB7QGxpbmsgbW9kdWxlOm9sL3Byb2p+UHJvamVjdGlvbkxpa2V9IHdoaWNoIG1lYW5zIHRoZSBzaW1wbGUgc3RyaW5nXG4gKiBjb2RlIHdpbGwgc3VmZmljZS5cbiAqXG4gKiBZb3UgY2FuIHVzZSB7QGxpbmsgbW9kdWxlOm9sL3Byb2ouZ2V0fSB0byByZXRyaWV2ZSB0aGUgb2JqZWN0IGZvciBhIHBhcnRpY3VsYXJcbiAqIHByb2plY3Rpb24uXG4gKlxuICogVGhlIGxpYnJhcnkgaW5jbHVkZXMgZGVmaW5pdGlvbnMgZm9yIGBFUFNHOjQzMjZgIGFuZCBgRVBTRzozODU3YCwgdG9nZXRoZXJcbiAqIHdpdGggdGhlIGZvbGxvd2luZyBhbGlhc2VzOlxuICogKiBgRVBTRzo0MzI2YDogQ1JTOjg0LCB1cm46b2djOmRlZjpjcnM6RVBTRzo2LjY6NDMyNixcbiAqICAgICB1cm46b2djOmRlZjpjcnM6T0dDOjEuMzpDUlM4NCwgdXJuOm9nYzpkZWY6Y3JzOk9HQzoyOjg0LFxuICogICAgIGh0dHA6Ly93d3cub3Blbmdpcy5uZXQvZ21sL3Nycy9lcHNnLnhtbCM0MzI2LFxuICogICAgIHVybjp4LW9nYzpkZWY6Y3JzOkVQU0c6NDMyNlxuICogKiBgRVBTRzozODU3YDogRVBTRzoxMDIxMDAsIEVQU0c6MTAyMTEzLCBFUFNHOjkwMDkxMyxcbiAqICAgICB1cm46b2djOmRlZjpjcnM6RVBTRzo2LjE4OjM6Mzg1NyxcbiAqICAgICBodHRwOi8vd3d3Lm9wZW5naXMubmV0L2dtbC9zcnMvZXBzZy54bWwjMzg1N1xuICpcbiAqIElmIHlvdSB1c2UgW3Byb2o0anNdKGh0dHBzOi8vZ2l0aHViLmNvbS9wcm9qNGpzL3Byb2o0anMpLCBhbGlhc2VzIGNhblxuICogYmUgYWRkZWQgdXNpbmcgYHByb2o0LmRlZnMoKWAuIEFmdGVyIGFsbCByZXF1aXJlZCBwcm9qZWN0aW9uIGRlZmluaXRpb25zIGFyZVxuICogYWRkZWQsIGNhbGwgdGhlIHtAbGluayBtb2R1bGU6b2wvcHJvai9wcm9qNC5yZWdpc3Rlcn0gZnVuY3Rpb24uXG4gKlxuICogQGFwaVxuICovXG5jbGFzcyBQcm9qZWN0aW9uIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7T3B0aW9uc30gb3B0aW9ucyBQcm9qZWN0aW9uIG9wdGlvbnMuXG4gICAqL1xuICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAqL1xuICAgIHRoaXMuY29kZV8gPSBvcHRpb25zLmNvZGU7XG5cbiAgICAvKipcbiAgICAgKiBVbml0cyBvZiBwcm9qZWN0ZWQgY29vcmRpbmF0ZXMuIFdoZW4gc2V0IHRvIGBUSUxFX1BJWEVMU2AsIGFcbiAgICAgKiBgdGhpcy5leHRlbnRfYCBhbmQgYHRoaXMud29ybGRFeHRlbnRfYCBtdXN0IGJlIGNvbmZpZ3VyZWQgcHJvcGVybHkgZm9yIGVhY2hcbiAgICAgKiB0aWxlLlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge2ltcG9ydChcIi4vVW5pdHMuanNcIikuVW5pdHN9XG4gICAgICovXG4gICAgdGhpcy51bml0c18gPSAvKiogQHR5cGUge2ltcG9ydChcIi4vVW5pdHMuanNcIikuVW5pdHN9ICovIChvcHRpb25zLnVuaXRzKTtcblxuICAgIC8qKlxuICAgICAqIFZhbGlkaXR5IGV4dGVudCBvZiB0aGUgcHJvamVjdGlvbiBpbiBwcm9qZWN0ZWQgY29vcmRpbmF0ZXMuIEZvciBwcm9qZWN0aW9uc1xuICAgICAqIHdpdGggYFRJTEVfUElYRUxTYCB1bml0cywgdGhpcyBpcyB0aGUgZXh0ZW50IG9mIHRoZSB0aWxlIGluXG4gICAgICogdGlsZSBwaXhlbCBzcGFjZS5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtpbXBvcnQoXCIuLi9leHRlbnQuanNcIikuRXh0ZW50fVxuICAgICAqL1xuICAgIHRoaXMuZXh0ZW50XyA9IG9wdGlvbnMuZXh0ZW50ICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLmV4dGVudCA6IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBFeHRlbnQgb2YgdGhlIHdvcmxkIGluIEVQU0c6NDMyNi4gRm9yIHByb2plY3Rpb25zIHdpdGhcbiAgICAgKiBgVElMRV9QSVhFTFNgIHVuaXRzLCB0aGlzIGlzIHRoZSBleHRlbnQgb2YgdGhlIHRpbGUgaW5cbiAgICAgKiBwcm9qZWN0ZWQgY29vcmRpbmF0ZSBzcGFjZS5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtpbXBvcnQoXCIuLi9leHRlbnQuanNcIikuRXh0ZW50fVxuICAgICAqL1xuICAgIHRoaXMud29ybGRFeHRlbnRfID1cbiAgICAgIG9wdGlvbnMud29ybGRFeHRlbnQgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMud29ybGRFeHRlbnQgOiBudWxsO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAqL1xuICAgIHRoaXMuYXhpc09yaWVudGF0aW9uXyA9XG4gICAgICBvcHRpb25zLmF4aXNPcmllbnRhdGlvbiAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5heGlzT3JpZW50YXRpb24gOiAnZW51JztcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICovXG4gICAgdGhpcy5nbG9iYWxfID0gb3B0aW9ucy5nbG9iYWwgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMuZ2xvYmFsIDogZmFsc2U7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAqL1xuICAgIHRoaXMuY2FuV3JhcFhfID0gISEodGhpcy5nbG9iYWxfICYmIHRoaXMuZXh0ZW50Xyk7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtmdW5jdGlvbihudW1iZXIsIGltcG9ydChcIi4uL2Nvb3JkaW5hdGUuanNcIikuQ29vcmRpbmF0ZSk6bnVtYmVyfHVuZGVmaW5lZH1cbiAgICAgKi9cbiAgICB0aGlzLmdldFBvaW50UmVzb2x1dGlvbkZ1bmNfID0gb3B0aW9ucy5nZXRQb2ludFJlc29sdXRpb247XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtpbXBvcnQoXCIuLi90aWxlZ3JpZC9UaWxlR3JpZC5qc1wiKS5kZWZhdWx0fVxuICAgICAqL1xuICAgIHRoaXMuZGVmYXVsdFRpbGVHcmlkXyA9IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtudW1iZXJ8dW5kZWZpbmVkfVxuICAgICAqL1xuICAgIHRoaXMubWV0ZXJzUGVyVW5pdF8gPSBvcHRpb25zLm1ldGVyc1BlclVuaXQ7XG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7Ym9vbGVhbn0gVGhlIHByb2plY3Rpb24gaXMgc3VpdGFibGUgZm9yIHdyYXBwaW5nIHRoZSB4LWF4aXNcbiAgICovXG4gIGNhbldyYXBYKCkge1xuICAgIHJldHVybiB0aGlzLmNhbldyYXBYXztcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIGNvZGUgZm9yIHRoaXMgcHJvamVjdGlvbiwgZS5nLiAnRVBTRzo0MzI2Jy5cbiAgICogQHJldHVybiB7c3RyaW5nfSBDb2RlLlxuICAgKiBAYXBpXG4gICAqL1xuICBnZXRDb2RlKCkge1xuICAgIHJldHVybiB0aGlzLmNvZGVfO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgdmFsaWRpdHkgZXh0ZW50IGZvciB0aGlzIHByb2plY3Rpb24uXG4gICAqIEByZXR1cm4ge2ltcG9ydChcIi4uL2V4dGVudC5qc1wiKS5FeHRlbnR9IEV4dGVudC5cbiAgICogQGFwaVxuICAgKi9cbiAgZ2V0RXh0ZW50KCkge1xuICAgIHJldHVybiB0aGlzLmV4dGVudF87XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSB1bml0cyBvZiB0aGlzIHByb2plY3Rpb24uXG4gICAqIEByZXR1cm4ge2ltcG9ydChcIi4vVW5pdHMuanNcIikuVW5pdHN9IFVuaXRzLlxuICAgKiBAYXBpXG4gICAqL1xuICBnZXRVbml0cygpIHtcbiAgICByZXR1cm4gdGhpcy51bml0c187XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBhbW91bnQgb2YgbWV0ZXJzIHBlciB1bml0IG9mIHRoaXMgcHJvamVjdGlvbi4gIElmIHRoZSBwcm9qZWN0aW9uIGlzXG4gICAqIG5vdCBjb25maWd1cmVkIHdpdGggYG1ldGVyc1BlclVuaXRgIG9yIGEgdW5pdHMgaWRlbnRpZmllciwgdGhlIHJldHVybiBpc1xuICAgKiBgdW5kZWZpbmVkYC5cbiAgICogQHJldHVybiB7bnVtYmVyfHVuZGVmaW5lZH0gTWV0ZXJzLlxuICAgKiBAYXBpXG4gICAqL1xuICBnZXRNZXRlcnNQZXJVbml0KCkge1xuICAgIHJldHVybiB0aGlzLm1ldGVyc1BlclVuaXRfIHx8IE1FVEVSU19QRVJfVU5JVFt0aGlzLnVuaXRzX107XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSB3b3JsZCBleHRlbnQgZm9yIHRoaXMgcHJvamVjdGlvbi5cbiAgICogQHJldHVybiB7aW1wb3J0KFwiLi4vZXh0ZW50LmpzXCIpLkV4dGVudH0gRXh0ZW50LlxuICAgKiBAYXBpXG4gICAqL1xuICBnZXRXb3JsZEV4dGVudCgpIHtcbiAgICByZXR1cm4gdGhpcy53b3JsZEV4dGVudF87XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBheGlzIG9yaWVudGF0aW9uIG9mIHRoaXMgcHJvamVjdGlvbi5cbiAgICogRXhhbXBsZSB2YWx1ZXMgYXJlOlxuICAgKiBlbnUgLSB0aGUgZGVmYXVsdCBlYXN0aW5nLCBub3J0aGluZywgZWxldmF0aW9uLlxuICAgKiBuZXUgLSBub3J0aGluZywgZWFzdGluZywgdXAgLSB1c2VmdWwgZm9yIFwibGF0L2xvbmdcIiBnZW9ncmFwaGljIGNvb3JkaW5hdGVzLFxuICAgKiAgICAgb3Igc291dGggb3JpZW50YXRlZCB0cmFuc3ZlcnNlIG1lcmNhdG9yLlxuICAgKiB3bnUgLSB3ZXN0aW5nLCBub3J0aGluZywgdXAgLSBzb21lIHBsYW5ldGFyeSBjb29yZGluYXRlIHN5c3RlbXMgaGF2ZVxuICAgKiAgICAgXCJ3ZXN0IHBvc2l0aXZlXCIgY29vcmRpbmF0ZSBzeXN0ZW1zXG4gICAqIEByZXR1cm4ge3N0cmluZ30gQXhpcyBvcmllbnRhdGlvbi5cbiAgICogQGFwaVxuICAgKi9cbiAgZ2V0QXhpc09yaWVudGF0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLmF4aXNPcmllbnRhdGlvbl87XG4gIH1cblxuICAvKipcbiAgICogSXMgdGhpcyBwcm9qZWN0aW9uIGEgZ2xvYmFsIHByb2plY3Rpb24gd2hpY2ggc3BhbnMgdGhlIHdob2xlIHdvcmxkP1xuICAgKiBAcmV0dXJuIHtib29sZWFufSBXaGV0aGVyIHRoZSBwcm9qZWN0aW9uIGlzIGdsb2JhbC5cbiAgICogQGFwaVxuICAgKi9cbiAgaXNHbG9iYWwoKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2xvYmFsXztcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXQgaWYgdGhlIHByb2plY3Rpb24gaXMgYSBnbG9iYWwgcHJvamVjdGlvbiB3aGljaCBzcGFucyB0aGUgd2hvbGUgd29ybGRcbiAgICogQHBhcmFtIHtib29sZWFufSBnbG9iYWwgV2hldGhlciB0aGUgcHJvamVjdGlvbiBpcyBnbG9iYWwuXG4gICAqIEBhcGlcbiAgICovXG4gIHNldEdsb2JhbChnbG9iYWwpIHtcbiAgICB0aGlzLmdsb2JhbF8gPSBnbG9iYWw7XG4gICAgdGhpcy5jYW5XcmFwWF8gPSAhIShnbG9iYWwgJiYgdGhpcy5leHRlbnRfKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtpbXBvcnQoXCIuLi90aWxlZ3JpZC9UaWxlR3JpZC5qc1wiKS5kZWZhdWx0fSBUaGUgZGVmYXVsdCB0aWxlIGdyaWQuXG4gICAqL1xuICBnZXREZWZhdWx0VGlsZUdyaWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuZGVmYXVsdFRpbGVHcmlkXztcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL3RpbGVncmlkL1RpbGVHcmlkLmpzXCIpLmRlZmF1bHR9IHRpbGVHcmlkIFRoZSBkZWZhdWx0IHRpbGUgZ3JpZC5cbiAgICovXG4gIHNldERlZmF1bHRUaWxlR3JpZCh0aWxlR3JpZCkge1xuICAgIHRoaXMuZGVmYXVsdFRpbGVHcmlkXyA9IHRpbGVHcmlkO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldCB0aGUgdmFsaWRpdHkgZXh0ZW50IGZvciB0aGlzIHByb2plY3Rpb24uXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vZXh0ZW50LmpzXCIpLkV4dGVudH0gZXh0ZW50IEV4dGVudC5cbiAgICogQGFwaVxuICAgKi9cbiAgc2V0RXh0ZW50KGV4dGVudCkge1xuICAgIHRoaXMuZXh0ZW50XyA9IGV4dGVudDtcbiAgICB0aGlzLmNhbldyYXBYXyA9ICEhKHRoaXMuZ2xvYmFsXyAmJiBleHRlbnQpO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldCB0aGUgd29ybGQgZXh0ZW50IGZvciB0aGlzIHByb2plY3Rpb24uXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vZXh0ZW50LmpzXCIpLkV4dGVudH0gd29ybGRFeHRlbnQgV29ybGQgZXh0ZW50XG4gICAqICAgICBbbWlubG9uLCBtaW5sYXQsIG1heGxvbiwgbWF4bGF0XS5cbiAgICogQGFwaVxuICAgKi9cbiAgc2V0V29ybGRFeHRlbnQod29ybGRFeHRlbnQpIHtcbiAgICB0aGlzLndvcmxkRXh0ZW50XyA9IHdvcmxkRXh0ZW50O1xuICB9XG5cbiAgLyoqXG4gICAqIFNldCB0aGUgZ2V0UG9pbnRSZXNvbHV0aW9uIGZ1bmN0aW9uIChzZWUge0BsaW5rIG1vZHVsZTpvbC9wcm9qLmdldFBvaW50UmVzb2x1dGlvbn1cbiAgICogZm9yIHRoaXMgcHJvamVjdGlvbi5cbiAgICogQHBhcmFtIHtmdW5jdGlvbihudW1iZXIsIGltcG9ydChcIi4uL2Nvb3JkaW5hdGUuanNcIikuQ29vcmRpbmF0ZSk6bnVtYmVyfSBmdW5jIEZ1bmN0aW9uXG4gICAqIEBhcGlcbiAgICovXG4gIHNldEdldFBvaW50UmVzb2x1dGlvbihmdW5jKSB7XG4gICAgdGhpcy5nZXRQb2ludFJlc29sdXRpb25GdW5jXyA9IGZ1bmM7XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBjdXN0b20gcG9pbnQgcmVzb2x1dGlvbiBmdW5jdGlvbiBmb3IgdGhpcyBwcm9qZWN0aW9uIChpZiBzZXQpLlxuICAgKiBAcmV0dXJuIHtmdW5jdGlvbihudW1iZXIsIGltcG9ydChcIi4uL2Nvb3JkaW5hdGUuanNcIikuQ29vcmRpbmF0ZSk6bnVtYmVyfHVuZGVmaW5lZH0gVGhlIGN1c3RvbSBwb2ludFxuICAgKiByZXNvbHV0aW9uIGZ1bmN0aW9uIChpZiBzZXQpLlxuICAgKi9cbiAgZ2V0UG9pbnRSZXNvbHV0aW9uRnVuYygpIHtcbiAgICByZXR1cm4gdGhpcy5nZXRQb2ludFJlc29sdXRpb25GdW5jXztcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBQcm9qZWN0aW9uO1xuIiwiLyoqXG4gKiBAbW9kdWxlIG9sL3Byb2ovZXBzZzM4NTdcbiAqL1xuaW1wb3J0IFByb2plY3Rpb24gZnJvbSAnLi9Qcm9qZWN0aW9uLmpzJztcblxuLyoqXG4gKiBSYWRpdXMgb2YgV0dTODQgc3BoZXJlXG4gKlxuICogQGNvbnN0XG4gKiBAdHlwZSB7bnVtYmVyfVxuICovXG5leHBvcnQgY29uc3QgUkFESVVTID0gNjM3ODEzNztcblxuLyoqXG4gKiBAY29uc3RcbiAqIEB0eXBlIHtudW1iZXJ9XG4gKi9cbmV4cG9ydCBjb25zdCBIQUxGX1NJWkUgPSBNYXRoLlBJICogUkFESVVTO1xuXG4vKipcbiAqIEBjb25zdFxuICogQHR5cGUge2ltcG9ydChcIi4uL2V4dGVudC5qc1wiKS5FeHRlbnR9XG4gKi9cbmV4cG9ydCBjb25zdCBFWFRFTlQgPSBbLUhBTEZfU0laRSwgLUhBTEZfU0laRSwgSEFMRl9TSVpFLCBIQUxGX1NJWkVdO1xuXG4vKipcbiAqIEBjb25zdFxuICogQHR5cGUge2ltcG9ydChcIi4uL2V4dGVudC5qc1wiKS5FeHRlbnR9XG4gKi9cbmV4cG9ydCBjb25zdCBXT1JMRF9FWFRFTlQgPSBbLTE4MCwgLTg1LCAxODAsIDg1XTtcblxuLyoqXG4gKiBNYXhpbXVtIHNhZmUgdmFsdWUgaW4geSBkaXJlY3Rpb25cbiAqIEBjb25zdFxuICogQHR5cGUge251bWJlcn1cbiAqL1xuZXhwb3J0IGNvbnN0IE1BWF9TQUZFX1kgPSBSQURJVVMgKiBNYXRoLmxvZyhNYXRoLnRhbihNYXRoLlBJIC8gMikpO1xuXG4vKipcbiAqIEBjbGFzc2Rlc2NcbiAqIFByb2plY3Rpb24gb2JqZWN0IGZvciB3ZWIvc3BoZXJpY2FsIE1lcmNhdG9yIChFUFNHOjM4NTcpLlxuICovXG5jbGFzcyBFUFNHMzg1N1Byb2plY3Rpb24gZXh0ZW5kcyBQcm9qZWN0aW9uIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBjb2RlIENvZGUuXG4gICAqL1xuICBjb25zdHJ1Y3Rvcihjb2RlKSB7XG4gICAgc3VwZXIoe1xuICAgICAgY29kZTogY29kZSxcbiAgICAgIHVuaXRzOiAnbScsXG4gICAgICBleHRlbnQ6IEVYVEVOVCxcbiAgICAgIGdsb2JhbDogdHJ1ZSxcbiAgICAgIHdvcmxkRXh0ZW50OiBXT1JMRF9FWFRFTlQsXG4gICAgICBnZXRQb2ludFJlc29sdXRpb246IGZ1bmN0aW9uIChyZXNvbHV0aW9uLCBwb2ludCkge1xuICAgICAgICByZXR1cm4gcmVzb2x1dGlvbiAvIE1hdGguY29zaChwb2ludFsxXSAvIFJBRElVUyk7XG4gICAgICB9LFxuICAgIH0pO1xuICB9XG59XG5cbi8qKlxuICogUHJvamVjdGlvbnMgZXF1YWwgdG8gRVBTRzozODU3LlxuICpcbiAqIEBjb25zdFxuICogQHR5cGUge0FycmF5PGltcG9ydChcIi4vUHJvamVjdGlvbi5qc1wiKS5kZWZhdWx0Pn1cbiAqL1xuZXhwb3J0IGNvbnN0IFBST0pFQ1RJT05TID0gW1xuICBuZXcgRVBTRzM4NTdQcm9qZWN0aW9uKCdFUFNHOjM4NTcnKSxcbiAgbmV3IEVQU0czODU3UHJvamVjdGlvbignRVBTRzoxMDIxMDAnKSxcbiAgbmV3IEVQU0czODU3UHJvamVjdGlvbignRVBTRzoxMDIxMTMnKSxcbiAgbmV3IEVQU0czODU3UHJvamVjdGlvbignRVBTRzo5MDA5MTMnKSxcbiAgbmV3IEVQU0czODU3UHJvamVjdGlvbignaHR0cDovL3d3dy5vcGVuZ2lzLm5ldC9kZWYvY3JzL0VQU0cvMC8zODU3JyksXG4gIG5ldyBFUFNHMzg1N1Byb2plY3Rpb24oJ2h0dHA6Ly93d3cub3Blbmdpcy5uZXQvZ21sL3Nycy9lcHNnLnhtbCMzODU3JyksXG5dO1xuXG4vKipcbiAqIFRyYW5zZm9ybWF0aW9uIGZyb20gRVBTRzo0MzI2IHRvIEVQU0c6Mzg1Ny5cbiAqXG4gKiBAcGFyYW0ge0FycmF5PG51bWJlcj59IGlucHV0IElucHV0IGFycmF5IG9mIGNvb3JkaW5hdGUgdmFsdWVzLlxuICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSBbb3V0cHV0XSBPdXRwdXQgYXJyYXkgb2YgY29vcmRpbmF0ZSB2YWx1ZXMuXG4gKiBAcGFyYW0ge251bWJlcn0gW2RpbWVuc2lvbl0gRGltZW5zaW9uIChkZWZhdWx0IGlzIGAyYCkuXG4gKiBAcmV0dXJuIHtBcnJheTxudW1iZXI+fSBPdXRwdXQgYXJyYXkgb2YgY29vcmRpbmF0ZSB2YWx1ZXMuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBmcm9tRVBTRzQzMjYoaW5wdXQsIG91dHB1dCwgZGltZW5zaW9uKSB7XG4gIGNvbnN0IGxlbmd0aCA9IGlucHV0Lmxlbmd0aDtcbiAgZGltZW5zaW9uID0gZGltZW5zaW9uID4gMSA/IGRpbWVuc2lvbiA6IDI7XG4gIGlmIChvdXRwdXQgPT09IHVuZGVmaW5lZCkge1xuICAgIGlmIChkaW1lbnNpb24gPiAyKSB7XG4gICAgICAvLyBwcmVzZXJ2ZSB2YWx1ZXMgYmV5b25kIHNlY29uZCBkaW1lbnNpb25cbiAgICAgIG91dHB1dCA9IGlucHV0LnNsaWNlKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG91dHB1dCA9IG5ldyBBcnJheShsZW5ndGgpO1xuICAgIH1cbiAgfVxuICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbmd0aDsgaSArPSBkaW1lbnNpb24pIHtcbiAgICBvdXRwdXRbaV0gPSAoSEFMRl9TSVpFICogaW5wdXRbaV0pIC8gMTgwO1xuICAgIGxldCB5ID0gUkFESVVTICogTWF0aC5sb2coTWF0aC50YW4oKE1hdGguUEkgKiAoK2lucHV0W2kgKyAxXSArIDkwKSkgLyAzNjApKTtcbiAgICBpZiAoeSA+IE1BWF9TQUZFX1kpIHtcbiAgICAgIHkgPSBNQVhfU0FGRV9ZO1xuICAgIH0gZWxzZSBpZiAoeSA8IC1NQVhfU0FGRV9ZKSB7XG4gICAgICB5ID0gLU1BWF9TQUZFX1k7XG4gICAgfVxuICAgIG91dHB1dFtpICsgMV0gPSB5O1xuICB9XG4gIHJldHVybiBvdXRwdXQ7XG59XG5cbi8qKlxuICogVHJhbnNmb3JtYXRpb24gZnJvbSBFUFNHOjM4NTcgdG8gRVBTRzo0MzI2LlxuICpcbiAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gaW5wdXQgSW5wdXQgYXJyYXkgb2YgY29vcmRpbmF0ZSB2YWx1ZXMuXG4gKiBAcGFyYW0ge0FycmF5PG51bWJlcj59IFtvdXRwdXRdIE91dHB1dCBhcnJheSBvZiBjb29yZGluYXRlIHZhbHVlcy5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbZGltZW5zaW9uXSBEaW1lbnNpb24gKGRlZmF1bHQgaXMgYDJgKS5cbiAqIEByZXR1cm4ge0FycmF5PG51bWJlcj59IE91dHB1dCBhcnJheSBvZiBjb29yZGluYXRlIHZhbHVlcy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRvRVBTRzQzMjYoaW5wdXQsIG91dHB1dCwgZGltZW5zaW9uKSB7XG4gIGNvbnN0IGxlbmd0aCA9IGlucHV0Lmxlbmd0aDtcbiAgZGltZW5zaW9uID0gZGltZW5zaW9uID4gMSA/IGRpbWVuc2lvbiA6IDI7XG4gIGlmIChvdXRwdXQgPT09IHVuZGVmaW5lZCkge1xuICAgIGlmIChkaW1lbnNpb24gPiAyKSB7XG4gICAgICAvLyBwcmVzZXJ2ZSB2YWx1ZXMgYmV5b25kIHNlY29uZCBkaW1lbnNpb25cbiAgICAgIG91dHB1dCA9IGlucHV0LnNsaWNlKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG91dHB1dCA9IG5ldyBBcnJheShsZW5ndGgpO1xuICAgIH1cbiAgfVxuICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbmd0aDsgaSArPSBkaW1lbnNpb24pIHtcbiAgICBvdXRwdXRbaV0gPSAoMTgwICogaW5wdXRbaV0pIC8gSEFMRl9TSVpFO1xuICAgIG91dHB1dFtpICsgMV0gPVxuICAgICAgKDM2MCAqIE1hdGguYXRhbihNYXRoLmV4cChpbnB1dFtpICsgMV0gLyBSQURJVVMpKSkgLyBNYXRoLlBJIC0gOTA7XG4gIH1cbiAgcmV0dXJuIG91dHB1dDtcbn1cbiIsIi8qKlxuICogQG1vZHVsZSBvbC9wcm9qL2Vwc2c0MzI2XG4gKi9cbmltcG9ydCBQcm9qZWN0aW9uIGZyb20gJy4vUHJvamVjdGlvbi5qcyc7XG5cbi8qKlxuICogU2VtaS1tYWpvciByYWRpdXMgb2YgdGhlIFdHUzg0IGVsbGlwc29pZC5cbiAqXG4gKiBAY29uc3RcbiAqIEB0eXBlIHtudW1iZXJ9XG4gKi9cbmV4cG9ydCBjb25zdCBSQURJVVMgPSA2Mzc4MTM3O1xuXG4vKipcbiAqIEV4dGVudCBvZiB0aGUgRVBTRzo0MzI2IHByb2plY3Rpb24gd2hpY2ggaXMgdGhlIHdob2xlIHdvcmxkLlxuICpcbiAqIEBjb25zdFxuICogQHR5cGUge2ltcG9ydChcIi4uL2V4dGVudC5qc1wiKS5FeHRlbnR9XG4gKi9cbmV4cG9ydCBjb25zdCBFWFRFTlQgPSBbLTE4MCwgLTkwLCAxODAsIDkwXTtcblxuLyoqXG4gKiBAY29uc3RcbiAqIEB0eXBlIHtudW1iZXJ9XG4gKi9cbmV4cG9ydCBjb25zdCBNRVRFUlNfUEVSX1VOSVQgPSAoTWF0aC5QSSAqIFJBRElVUykgLyAxODA7XG5cbi8qKlxuICogQGNsYXNzZGVzY1xuICogUHJvamVjdGlvbiBvYmplY3QgZm9yIFdHUzg0IGdlb2dyYXBoaWMgY29vcmRpbmF0ZXMgKEVQU0c6NDMyNikuXG4gKlxuICogTm90ZSB0aGF0IE9wZW5MYXllcnMgZG9lcyBub3Qgc3RyaWN0bHkgY29tcGx5IHdpdGggdGhlIEVQU0cgZGVmaW5pdGlvbi5cbiAqIFRoZSBFUFNHIHJlZ2lzdHJ5IGRlZmluZXMgNDMyNiBhcyBhIENSUyBmb3IgTGF0aXR1ZGUsTG9uZ2l0dWRlICh5LHgpLlxuICogT3BlbkxheWVycyB0cmVhdHMgRVBTRzo0MzI2IGFzIGEgcHNldWRvLXByb2plY3Rpb24sIHdpdGggeCx5IGNvb3JkaW5hdGVzLlxuICovXG5jbGFzcyBFUFNHNDMyNlByb2plY3Rpb24gZXh0ZW5kcyBQcm9qZWN0aW9uIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBjb2RlIENvZGUuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbYXhpc09yaWVudGF0aW9uXSBBeGlzIG9yaWVudGF0aW9uLlxuICAgKi9cbiAgY29uc3RydWN0b3IoY29kZSwgYXhpc09yaWVudGF0aW9uKSB7XG4gICAgc3VwZXIoe1xuICAgICAgY29kZTogY29kZSxcbiAgICAgIHVuaXRzOiAnZGVncmVlcycsXG4gICAgICBleHRlbnQ6IEVYVEVOVCxcbiAgICAgIGF4aXNPcmllbnRhdGlvbjogYXhpc09yaWVudGF0aW9uLFxuICAgICAgZ2xvYmFsOiB0cnVlLFxuICAgICAgbWV0ZXJzUGVyVW5pdDogTUVURVJTX1BFUl9VTklULFxuICAgICAgd29ybGRFeHRlbnQ6IEVYVEVOVCxcbiAgICB9KTtcbiAgfVxufVxuXG4vKipcbiAqIFByb2plY3Rpb25zIGVxdWFsIHRvIEVQU0c6NDMyNi5cbiAqXG4gKiBAY29uc3RcbiAqIEB0eXBlIHtBcnJheTxpbXBvcnQoXCIuL1Byb2plY3Rpb24uanNcIikuZGVmYXVsdD59XG4gKi9cbmV4cG9ydCBjb25zdCBQUk9KRUNUSU9OUyA9IFtcbiAgbmV3IEVQU0c0MzI2UHJvamVjdGlvbignQ1JTOjg0JyksXG4gIG5ldyBFUFNHNDMyNlByb2plY3Rpb24oJ0VQU0c6NDMyNicsICduZXUnKSxcbiAgbmV3IEVQU0c0MzI2UHJvamVjdGlvbigndXJuOm9nYzpkZWY6Y3JzOk9HQzoxLjM6Q1JTODQnKSxcbiAgbmV3IEVQU0c0MzI2UHJvamVjdGlvbigndXJuOm9nYzpkZWY6Y3JzOk9HQzoyOjg0JyksXG4gIG5ldyBFUFNHNDMyNlByb2plY3Rpb24oJ2h0dHA6Ly93d3cub3Blbmdpcy5uZXQvZGVmL2Nycy9PR0MvMS4zL0NSUzg0JyksXG4gIG5ldyBFUFNHNDMyNlByb2plY3Rpb24oJ2h0dHA6Ly93d3cub3Blbmdpcy5uZXQvZ21sL3Nycy9lcHNnLnhtbCM0MzI2JywgJ25ldScpLFxuICBuZXcgRVBTRzQzMjZQcm9qZWN0aW9uKCdodHRwOi8vd3d3Lm9wZW5naXMubmV0L2RlZi9jcnMvRVBTRy8wLzQzMjYnLCAnbmV1JyksXG5dO1xuIiwiLyoqXG4gKiBAbW9kdWxlIG9sL3Byb2pcbiAqL1xuXG4vKipcbiAqIFRoZSBvbC9wcm9qIG1vZHVsZSBzdG9yZXM6XG4gKiAqIGEgbGlzdCBvZiB7QGxpbmsgbW9kdWxlOm9sL3Byb2ovUHJvamVjdGlvbn5Qcm9qZWN0aW9ufVxuICogb2JqZWN0cywgb25lIGZvciBlYWNoIHByb2plY3Rpb24gc3VwcG9ydGVkIGJ5IHRoZSBhcHBsaWNhdGlvblxuICogKiBhIGxpc3Qgb2YgdHJhbnNmb3JtIGZ1bmN0aW9ucyBuZWVkZWQgdG8gY29udmVydCBjb29yZGluYXRlcyBpbiBvbmUgcHJvamVjdGlvblxuICogaW50byBhbm90aGVyLlxuICpcbiAqIFRoZSBzdGF0aWMgZnVuY3Rpb25zIGFyZSB0aGUgbWV0aG9kcyB1c2VkIHRvIG1haW50YWluIHRoZXNlLlxuICogRWFjaCB0cmFuc2Zvcm0gZnVuY3Rpb24gY2FuIGhhbmRsZSBub3Qgb25seSBzaW1wbGUgY29vcmRpbmF0ZSBwYWlycywgYnV0IGFsc29cbiAqIGxhcmdlIGFycmF5cyBvZiBjb29yZGluYXRlcyBzdWNoIGFzIHZlY3RvciBnZW9tZXRyaWVzLlxuICpcbiAqIFdoZW4gbG9hZGVkLCB0aGUgbGlicmFyeSBhZGRzIHByb2plY3Rpb24gb2JqZWN0cyBmb3IgRVBTRzo0MzI2IChXR1M4NFxuICogZ2VvZ3JhcGhpYyBjb29yZGluYXRlcykgYW5kIEVQU0c6Mzg1NyAoV2ViIG9yIFNwaGVyaWNhbCBNZXJjYXRvciwgYXMgdXNlZFxuICogZm9yIGV4YW1wbGUgYnkgQmluZyBNYXBzIG9yIE9wZW5TdHJlZXRNYXApLCB0b2dldGhlciB3aXRoIHRoZSByZWxldmFudFxuICogdHJhbnNmb3JtIGZ1bmN0aW9ucy5cbiAqXG4gKiBBZGRpdGlvbmFsIHRyYW5zZm9ybXMgbWF5IGJlIGFkZGVkIGJ5IHVzaW5nIHRoZSBodHRwOi8vcHJvajRqcy5vcmcvXG4gKiBsaWJyYXJ5ICh2ZXJzaW9uIDIuMiBvciBsYXRlcikuIFlvdSBjYW4gdXNlIHRoZSBmdWxsIGJ1aWxkIHN1cHBsaWVkIGJ5XG4gKiBQcm9qNGpzLCBvciBjcmVhdGUgYSBjdXN0b20gYnVpbGQgdG8gc3VwcG9ydCB0aG9zZSBwcm9qZWN0aW9ucyB5b3UgbmVlZDsgc2VlXG4gKiB0aGUgUHJvajRqcyB3ZWJzaXRlIGZvciBob3cgdG8gZG8gdGhpcy4gWW91IGFsc28gbmVlZCB0aGUgUHJvajRqcyBkZWZpbml0aW9uc1xuICogZm9yIHRoZSByZXF1aXJlZCBwcm9qZWN0aW9ucy4gVGhlc2UgZGVmaW5pdGlvbnMgY2FuIGJlIG9idGFpbmVkIGZyb21cbiAqIGh0dHBzOi8vZXBzZy5pby8sIGFuZCBhcmUgYSBKUyBmdW5jdGlvbiwgc28gY2FuIGJlIGxvYWRlZCBpbiBhIHNjcmlwdFxuICogdGFnIChhcyBpbiB0aGUgZXhhbXBsZXMpIG9yIHBhc3RlZCBpbnRvIHlvdXIgYXBwbGljYXRpb24uXG4gKlxuICogQWZ0ZXIgYWxsIHJlcXVpcmVkIHByb2plY3Rpb24gZGVmaW5pdGlvbnMgYXJlIGFkZGVkIHRvIHByb2o0J3MgcmVnaXN0cnkgKGJ5XG4gKiB1c2luZyBgcHJvajQuZGVmcygpYCksIHNpbXBseSBjYWxsIGByZWdpc3Rlcihwcm9qNClgIGZyb20gdGhlIGBvbC9wcm9qL3Byb2o0YFxuICogcGFja2FnZS4gRXhpc3RpbmcgdHJhbnNmb3JtcyBhcmUgbm90IGNoYW5nZWQgYnkgdGhpcyBmdW5jdGlvbi4gU2VlXG4gKiBleGFtcGxlcy93bXMtaW1hZ2UtY3VzdG9tLXByb2ogZm9yIGFuIGV4YW1wbGUgb2YgdGhpcy5cbiAqXG4gKiBBZGRpdGlvbmFsIHByb2plY3Rpb24gZGVmaW5pdGlvbnMgY2FuIGJlIHJlZ2lzdGVyZWQgd2l0aCBgcHJvajQuZGVmcygpYCBhbnlcbiAqIHRpbWUuIEp1c3QgbWFrZSBzdXJlIHRvIGNhbGwgYHJlZ2lzdGVyKHByb2o0KWAgYWdhaW47IGZvciBleGFtcGxlLCB3aXRoIHVzZXItc3VwcGxpZWQgZGF0YSB3aGVyZSB5b3UgZG9uJ3RcbiAqIGtub3cgaW4gYWR2YW5jZSB3aGF0IHByb2plY3Rpb25zIGFyZSBuZWVkZWQsIHlvdSBjYW4gaW5pdGlhbGx5IGxvYWQgbWluaW1hbFxuICogc3VwcG9ydCBhbmQgdGhlbiBsb2FkIHdoaWNoZXZlciBhcmUgcmVxdWVzdGVkLlxuICpcbiAqIE5vdGUgdGhhdCBQcm9qNGpzIGRvZXMgbm90IHN1cHBvcnQgcHJvamVjdGlvbiBleHRlbnRzLiBJZiB5b3Ugd2FudCB0byBhZGRcbiAqIG9uZSBmb3IgY3JlYXRpbmcgZGVmYXVsdCB0aWxlIGdyaWRzLCB5b3UgY2FuIGFkZCBpdCBhZnRlciB0aGUgUHJvamVjdGlvblxuICogb2JqZWN0IGhhcyBiZWVuIGNyZWF0ZWQgd2l0aCBgc2V0RXh0ZW50YCwgZm9yIGV4YW1wbGUsXG4gKiBgZ2V0KCdFUFNHOjEyMzQnKS5zZXRFeHRlbnQoZXh0ZW50KWAuXG4gKlxuICogSW4gYWRkaXRpb24gdG8gUHJvajRqcyBzdXBwb3J0LCBhbnkgdHJhbnNmb3JtIGZ1bmN0aW9ucyBjYW4gYmUgYWRkZWQgd2l0aFxuICoge0BsaW5rIG1vZHVsZTpvbC9wcm9qLmFkZENvb3JkaW5hdGVUcmFuc2Zvcm1zfS4gVG8gdXNlIHRoaXMsIHlvdSBtdXN0IGZpcnN0IGNyZWF0ZVxuICogYSB7QGxpbmsgbW9kdWxlOm9sL3Byb2ovUHJvamVjdGlvbn5Qcm9qZWN0aW9ufSBvYmplY3QgZm9yIHRoZSBuZXcgcHJvamVjdGlvbiBhbmQgYWRkIGl0IHdpdGhcbiAqIHtAbGluayBtb2R1bGU6b2wvcHJvai5hZGRQcm9qZWN0aW9ufS4gWW91IGNhbiB0aGVuIGFkZCB0aGUgZm9yd2FyZCBhbmQgaW52ZXJzZVxuICogZnVuY3Rpb25zIHdpdGgge0BsaW5rIG1vZHVsZTpvbC9wcm9qLmFkZENvb3JkaW5hdGVUcmFuc2Zvcm1zfS4gU2VlXG4gKiBleGFtcGxlcy93bXMtY3VzdG9tLXByb2ogZm9yIGFuIGV4YW1wbGUgb2YgdGhpcy5cbiAqXG4gKiBOb3RlIHRoYXQgaWYgbm8gdHJhbnNmb3JtcyBhcmUgbmVlZGVkIGFuZCB5b3Ugb25seSBuZWVkIHRvIGRlZmluZSB0aGVcbiAqIHByb2plY3Rpb24sIGp1c3QgYWRkIGEge0BsaW5rIG1vZHVsZTpvbC9wcm9qL1Byb2plY3Rpb25+UHJvamVjdGlvbn0gd2l0aFxuICoge0BsaW5rIG1vZHVsZTpvbC9wcm9qLmFkZFByb2plY3Rpb259LiBTZWUgZXhhbXBsZXMvd21zLW5vLXByb2ogZm9yIGFuIGV4YW1wbGUgb2ZcbiAqIHRoaXMuXG4gKi9cbmltcG9ydCBQcm9qZWN0aW9uIGZyb20gJy4vcHJvai9Qcm9qZWN0aW9uLmpzJztcbmltcG9ydCB7XG4gIFBST0pFQ1RJT05TIGFzIEVQU0czODU3X1BST0pFQ1RJT05TLFxuICBmcm9tRVBTRzQzMjYsXG4gIHRvRVBTRzQzMjYsXG59IGZyb20gJy4vcHJvai9lcHNnMzg1Ny5qcyc7XG5pbXBvcnQge1BST0pFQ1RJT05TIGFzIEVQU0c0MzI2X1BST0pFQ1RJT05TfSBmcm9tICcuL3Byb2ovZXBzZzQzMjYuanMnO1xuaW1wb3J0IHtNRVRFUlNfUEVSX1VOSVR9IGZyb20gJy4vcHJvai9Vbml0cy5qcyc7XG5pbXBvcnQge1xuICBhZGQgYXMgYWRkUHJvaixcbiAgY2xlYXIgYXMgY2xlYXJQcm9qLFxuICBnZXQgYXMgZ2V0UHJvaixcbn0gZnJvbSAnLi9wcm9qL3Byb2plY3Rpb25zLmpzJztcbmltcG9ydCB7XG4gIGFkZCBhcyBhZGRUcmFuc2Zvcm1GdW5jLFxuICBjbGVhciBhcyBjbGVhclRyYW5zZm9ybUZ1bmNzLFxuICBnZXQgYXMgZ2V0VHJhbnNmb3JtRnVuYyxcbn0gZnJvbSAnLi9wcm9qL3RyYW5zZm9ybXMuanMnO1xuaW1wb3J0IHthcHBseVRyYW5zZm9ybSwgZ2V0V2lkdGh9IGZyb20gJy4vZXh0ZW50LmpzJztcbmltcG9ydCB7Y2xhbXAsIG1vZHVsb30gZnJvbSAnLi9tYXRoLmpzJztcbmltcG9ydCB7ZXF1YWxzLCBnZXRXb3JsZHNBd2F5fSBmcm9tICcuL2Nvb3JkaW5hdGUuanMnO1xuaW1wb3J0IHtnZXREaXN0YW5jZX0gZnJvbSAnLi9zcGhlcmUuanMnO1xuaW1wb3J0IHt3YXJufSBmcm9tICcuL2NvbnNvbGUuanMnO1xuXG4vKipcbiAqIEEgcHJvamVjdGlvbiBhcyB7QGxpbmsgbW9kdWxlOm9sL3Byb2ovUHJvamVjdGlvbn5Qcm9qZWN0aW9ufSwgU1JTIGlkZW50aWZpZXJcbiAqIHN0cmluZyBvciB1bmRlZmluZWQuXG4gKiBAdHlwZWRlZiB7UHJvamVjdGlvbnxzdHJpbmd8dW5kZWZpbmVkfSBQcm9qZWN0aW9uTGlrZVxuICogQGFwaVxuICovXG5cbi8qKlxuICogQSB0cmFuc2Zvcm0gZnVuY3Rpb24gYWNjZXB0cyBhbiBhcnJheSBvZiBpbnB1dCBjb29yZGluYXRlIHZhbHVlcywgYW4gb3B0aW9uYWxcbiAqIG91dHB1dCBhcnJheSwgYW5kIGFuIG9wdGlvbmFsIGRpbWVuc2lvbiAoZGVmYXVsdCBzaG91bGQgYmUgMikuICBUaGUgZnVuY3Rpb25cbiAqIHRyYW5zZm9ybXMgdGhlIGlucHV0IGNvb3JkaW5hdGUgdmFsdWVzLCBwb3B1bGF0ZXMgdGhlIG91dHB1dCBhcnJheSwgYW5kXG4gKiByZXR1cm5zIHRoZSBvdXRwdXQgYXJyYXkuXG4gKlxuICogQHR5cGVkZWYge2Z1bmN0aW9uKEFycmF5PG51bWJlcj4sIEFycmF5PG51bWJlcj49LCBudW1iZXI9KTogQXJyYXk8bnVtYmVyPn0gVHJhbnNmb3JtRnVuY3Rpb25cbiAqIEBhcGlcbiAqL1xuXG5leHBvcnQge01FVEVSU19QRVJfVU5JVH07XG5cbmV4cG9ydCB7UHJvamVjdGlvbn07XG5cbmxldCBzaG93Q29vcmRpbmF0ZVdhcm5pbmcgPSB0cnVlO1xuXG4vKipcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW2Rpc2FibGUgPSB0cnVlXSBEaXNhYmxlIGNvbnNvbGUgaW5mbyBhYm91dCBgdXNlR2VvZ3JhcGhpYygpYFxuICovXG5leHBvcnQgZnVuY3Rpb24gZGlzYWJsZUNvb3JkaW5hdGVXYXJuaW5nKGRpc2FibGUpIHtcbiAgY29uc3QgaGlkZSA9IGRpc2FibGUgPT09IHVuZGVmaW5lZCA/IHRydWUgOiBkaXNhYmxlO1xuICBzaG93Q29vcmRpbmF0ZVdhcm5pbmcgPSAhaGlkZTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge0FycmF5PG51bWJlcj59IGlucHV0IElucHV0IGNvb3JkaW5hdGUgYXJyYXkuXG4gKiBAcGFyYW0ge0FycmF5PG51bWJlcj59IFtvdXRwdXRdIE91dHB1dCBhcnJheSBvZiBjb29yZGluYXRlIHZhbHVlcy5cbiAqIEByZXR1cm4ge0FycmF5PG51bWJlcj59IE91dHB1dCBjb29yZGluYXRlIGFycmF5IChuZXcgYXJyYXksIHNhbWUgY29vcmRpbmF0ZVxuICogICAgIHZhbHVlcykuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjbG9uZVRyYW5zZm9ybShpbnB1dCwgb3V0cHV0KSB7XG4gIGlmIChvdXRwdXQgIT09IHVuZGVmaW5lZCkge1xuICAgIGZvciAobGV0IGkgPSAwLCBpaSA9IGlucHV0Lmxlbmd0aDsgaSA8IGlpOyArK2kpIHtcbiAgICAgIG91dHB1dFtpXSA9IGlucHV0W2ldO1xuICAgIH1cbiAgICBvdXRwdXQgPSBvdXRwdXQ7XG4gIH0gZWxzZSB7XG4gICAgb3V0cHV0ID0gaW5wdXQuc2xpY2UoKTtcbiAgfVxuICByZXR1cm4gb3V0cHV0O1xufVxuXG4vKipcbiAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gaW5wdXQgSW5wdXQgY29vcmRpbmF0ZSBhcnJheS5cbiAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gW291dHB1dF0gT3V0cHV0IGFycmF5IG9mIGNvb3JkaW5hdGUgdmFsdWVzLlxuICogQHJldHVybiB7QXJyYXk8bnVtYmVyPn0gSW5wdXQgY29vcmRpbmF0ZSBhcnJheSAoc2FtZSBhcnJheSBhcyBpbnB1dCkuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpZGVudGl0eVRyYW5zZm9ybShpbnB1dCwgb3V0cHV0KSB7XG4gIGlmIChvdXRwdXQgIT09IHVuZGVmaW5lZCAmJiBpbnB1dCAhPT0gb3V0cHV0KSB7XG4gICAgZm9yIChsZXQgaSA9IDAsIGlpID0gaW5wdXQubGVuZ3RoOyBpIDwgaWk7ICsraSkge1xuICAgICAgb3V0cHV0W2ldID0gaW5wdXRbaV07XG4gICAgfVxuICAgIGlucHV0ID0gb3V0cHV0O1xuICB9XG4gIHJldHVybiBpbnB1dDtcbn1cblxuLyoqXG4gKiBBZGQgYSBQcm9qZWN0aW9uIG9iamVjdCB0byB0aGUgbGlzdCBvZiBzdXBwb3J0ZWQgcHJvamVjdGlvbnMgdGhhdCBjYW4gYmVcbiAqIGxvb2tlZCB1cCBieSB0aGVpciBjb2RlLlxuICpcbiAqIEBwYXJhbSB7UHJvamVjdGlvbn0gcHJvamVjdGlvbiBQcm9qZWN0aW9uIGluc3RhbmNlLlxuICogQGFwaVxuICovXG5leHBvcnQgZnVuY3Rpb24gYWRkUHJvamVjdGlvbihwcm9qZWN0aW9uKSB7XG4gIGFkZFByb2oocHJvamVjdGlvbi5nZXRDb2RlKCksIHByb2plY3Rpb24pO1xuICBhZGRUcmFuc2Zvcm1GdW5jKHByb2plY3Rpb24sIHByb2plY3Rpb24sIGNsb25lVHJhbnNmb3JtKTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge0FycmF5PFByb2plY3Rpb24+fSBwcm9qZWN0aW9ucyBQcm9qZWN0aW9ucy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGFkZFByb2plY3Rpb25zKHByb2plY3Rpb25zKSB7XG4gIHByb2plY3Rpb25zLmZvckVhY2goYWRkUHJvamVjdGlvbik7XG59XG5cbi8qKlxuICogRmV0Y2hlcyBhIFByb2plY3Rpb24gb2JqZWN0IGZvciB0aGUgY29kZSBzcGVjaWZpZWQuXG4gKlxuICogQHBhcmFtIHtQcm9qZWN0aW9uTGlrZX0gcHJvamVjdGlvbkxpa2UgRWl0aGVyIGEgY29kZSBzdHJpbmcgd2hpY2ggaXNcbiAqICAgICBhIGNvbWJpbmF0aW9uIG9mIGF1dGhvcml0eSBhbmQgaWRlbnRpZmllciBzdWNoIGFzIFwiRVBTRzo0MzI2XCIsIG9yIGFuXG4gKiAgICAgZXhpc3RpbmcgcHJvamVjdGlvbiBvYmplY3QsIG9yIHVuZGVmaW5lZC5cbiAqIEByZXR1cm4ge1Byb2plY3Rpb258bnVsbH0gUHJvamVjdGlvbiBvYmplY3QsIG9yIG51bGwgaWYgbm90IGluIGxpc3QuXG4gKiBAYXBpXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXQocHJvamVjdGlvbkxpa2UpIHtcbiAgcmV0dXJuIHR5cGVvZiBwcm9qZWN0aW9uTGlrZSA9PT0gJ3N0cmluZydcbiAgICA/IGdldFByb2ooLyoqIEB0eXBlIHtzdHJpbmd9ICovIChwcm9qZWN0aW9uTGlrZSkpXG4gICAgOiAvKiogQHR5cGUge1Byb2plY3Rpb259ICovIChwcm9qZWN0aW9uTGlrZSkgfHwgbnVsbDtcbn1cblxuLyoqXG4gKiBHZXQgdGhlIHJlc29sdXRpb24gb2YgdGhlIHBvaW50IGluIGRlZ3JlZXMgb3IgZGlzdGFuY2UgdW5pdHMuXG4gKiBGb3IgcHJvamVjdGlvbnMgd2l0aCBkZWdyZWVzIGFzIHRoZSB1bml0IHRoaXMgd2lsbCBzaW1wbHkgcmV0dXJuIHRoZVxuICogcHJvdmlkZWQgcmVzb2x1dGlvbi4gRm9yIG90aGVyIHByb2plY3Rpb25zIHRoZSBwb2ludCByZXNvbHV0aW9uIGlzXG4gKiBieSBkZWZhdWx0IGVzdGltYXRlZCBieSB0cmFuc2Zvcm1pbmcgdGhlIGBwb2ludGAgcGl4ZWwgdG8gRVBTRzo0MzI2LFxuICogbWVhc3VyaW5nIGl0cyB3aWR0aCBhbmQgaGVpZ2h0IG9uIHRoZSBub3JtYWwgc3BoZXJlLFxuICogYW5kIHRha2luZyB0aGUgYXZlcmFnZSBvZiB0aGUgd2lkdGggYW5kIGhlaWdodC5cbiAqIEEgY3VzdG9tIGZ1bmN0aW9uIGNhbiBiZSBwcm92aWRlZCBmb3IgYSBzcGVjaWZpYyBwcm9qZWN0aW9uLCBlaXRoZXJcbiAqIGJ5IHNldHRpbmcgdGhlIGBnZXRQb2ludFJlc29sdXRpb25gIG9wdGlvbiBpbiB0aGVcbiAqIHtAbGluayBtb2R1bGU6b2wvcHJvai9Qcm9qZWN0aW9uflByb2plY3Rpb259IGNvbnN0cnVjdG9yIG9yIGJ5IHVzaW5nXG4gKiB7QGxpbmsgbW9kdWxlOm9sL3Byb2ovUHJvamVjdGlvbn5Qcm9qZWN0aW9uI3NldEdldFBvaW50UmVzb2x1dGlvbn0gdG8gY2hhbmdlIGFuIGV4aXN0aW5nXG4gKiBwcm9qZWN0aW9uIG9iamVjdC5cbiAqIEBwYXJhbSB7UHJvamVjdGlvbkxpa2V9IHByb2plY3Rpb24gVGhlIHByb2plY3Rpb24uXG4gKiBAcGFyYW0ge251bWJlcn0gcmVzb2x1dGlvbiBOb21pbmFsIHJlc29sdXRpb24gaW4gcHJvamVjdGlvbiB1bml0cy5cbiAqIEBwYXJhbSB7aW1wb3J0KFwiLi9jb29yZGluYXRlLmpzXCIpLkNvb3JkaW5hdGV9IHBvaW50IFBvaW50IHRvIGZpbmQgYWRqdXN0ZWQgcmVzb2x1dGlvbiBhdC5cbiAqIEBwYXJhbSB7aW1wb3J0KFwiLi9wcm9qL1VuaXRzLmpzXCIpLlVuaXRzfSBbdW5pdHNdIFVuaXRzIHRvIGdldCB0aGUgcG9pbnQgcmVzb2x1dGlvbiBpbi5cbiAqIERlZmF1bHQgaXMgdGhlIHByb2plY3Rpb24ncyB1bml0cy5cbiAqIEByZXR1cm4ge251bWJlcn0gUG9pbnQgcmVzb2x1dGlvbi5cbiAqIEBhcGlcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldFBvaW50UmVzb2x1dGlvbihwcm9qZWN0aW9uLCByZXNvbHV0aW9uLCBwb2ludCwgdW5pdHMpIHtcbiAgcHJvamVjdGlvbiA9IGdldChwcm9qZWN0aW9uKTtcbiAgbGV0IHBvaW50UmVzb2x1dGlvbjtcbiAgY29uc3QgZ2V0dGVyID0gcHJvamVjdGlvbi5nZXRQb2ludFJlc29sdXRpb25GdW5jKCk7XG4gIGlmIChnZXR0ZXIpIHtcbiAgICBwb2ludFJlc29sdXRpb24gPSBnZXR0ZXIocmVzb2x1dGlvbiwgcG9pbnQpO1xuICAgIGlmICh1bml0cyAmJiB1bml0cyAhPT0gcHJvamVjdGlvbi5nZXRVbml0cygpKSB7XG4gICAgICBjb25zdCBtZXRlcnNQZXJVbml0ID0gcHJvamVjdGlvbi5nZXRNZXRlcnNQZXJVbml0KCk7XG4gICAgICBpZiAobWV0ZXJzUGVyVW5pdCkge1xuICAgICAgICBwb2ludFJlc29sdXRpb24gPVxuICAgICAgICAgIChwb2ludFJlc29sdXRpb24gKiBtZXRlcnNQZXJVbml0KSAvIE1FVEVSU19QRVJfVU5JVFt1bml0c107XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGNvbnN0IHByb2pVbml0cyA9IHByb2plY3Rpb24uZ2V0VW5pdHMoKTtcbiAgICBpZiAoKHByb2pVbml0cyA9PSAnZGVncmVlcycgJiYgIXVuaXRzKSB8fCB1bml0cyA9PSAnZGVncmVlcycpIHtcbiAgICAgIHBvaW50UmVzb2x1dGlvbiA9IHJlc29sdXRpb247XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIEVzdGltYXRlIHBvaW50IHJlc29sdXRpb24gYnkgdHJhbnNmb3JtaW5nIHRoZSBjZW50ZXIgcGl4ZWwgdG8gRVBTRzo0MzI2LFxuICAgICAgLy8gbWVhc3VyaW5nIGl0cyB3aWR0aCBhbmQgaGVpZ2h0IG9uIHRoZSBub3JtYWwgc3BoZXJlLCBhbmQgdGFraW5nIHRoZVxuICAgICAgLy8gYXZlcmFnZSBvZiB0aGUgd2lkdGggYW5kIGhlaWdodC5cbiAgICAgIGNvbnN0IHRvRVBTRzQzMjYgPSBnZXRUcmFuc2Zvcm1Gcm9tUHJvamVjdGlvbnMoXG4gICAgICAgIHByb2plY3Rpb24sXG4gICAgICAgIGdldCgnRVBTRzo0MzI2JylcbiAgICAgICk7XG4gICAgICBpZiAodG9FUFNHNDMyNiA9PT0gaWRlbnRpdHlUcmFuc2Zvcm0gJiYgcHJvalVuaXRzICE9PSAnZGVncmVlcycpIHtcbiAgICAgICAgLy8gbm8gdHJhbnNmb3JtIGlzIGF2YWlsYWJsZVxuICAgICAgICBwb2ludFJlc29sdXRpb24gPSByZXNvbHV0aW9uICogcHJvamVjdGlvbi5nZXRNZXRlcnNQZXJVbml0KCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsZXQgdmVydGljZXMgPSBbXG4gICAgICAgICAgcG9pbnRbMF0gLSByZXNvbHV0aW9uIC8gMixcbiAgICAgICAgICBwb2ludFsxXSxcbiAgICAgICAgICBwb2ludFswXSArIHJlc29sdXRpb24gLyAyLFxuICAgICAgICAgIHBvaW50WzFdLFxuICAgICAgICAgIHBvaW50WzBdLFxuICAgICAgICAgIHBvaW50WzFdIC0gcmVzb2x1dGlvbiAvIDIsXG4gICAgICAgICAgcG9pbnRbMF0sXG4gICAgICAgICAgcG9pbnRbMV0gKyByZXNvbHV0aW9uIC8gMixcbiAgICAgICAgXTtcbiAgICAgICAgdmVydGljZXMgPSB0b0VQU0c0MzI2KHZlcnRpY2VzLCB2ZXJ0aWNlcywgMik7XG4gICAgICAgIGNvbnN0IHdpZHRoID0gZ2V0RGlzdGFuY2UodmVydGljZXMuc2xpY2UoMCwgMiksIHZlcnRpY2VzLnNsaWNlKDIsIDQpKTtcbiAgICAgICAgY29uc3QgaGVpZ2h0ID0gZ2V0RGlzdGFuY2UodmVydGljZXMuc2xpY2UoNCwgNiksIHZlcnRpY2VzLnNsaWNlKDYsIDgpKTtcbiAgICAgICAgcG9pbnRSZXNvbHV0aW9uID0gKHdpZHRoICsgaGVpZ2h0KSAvIDI7XG4gICAgICB9XG4gICAgICBjb25zdCBtZXRlcnNQZXJVbml0ID0gdW5pdHNcbiAgICAgICAgPyBNRVRFUlNfUEVSX1VOSVRbdW5pdHNdXG4gICAgICAgIDogcHJvamVjdGlvbi5nZXRNZXRlcnNQZXJVbml0KCk7XG4gICAgICBpZiAobWV0ZXJzUGVyVW5pdCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHBvaW50UmVzb2x1dGlvbiAvPSBtZXRlcnNQZXJVbml0O1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gcG9pbnRSZXNvbHV0aW9uO1xufVxuXG4vKipcbiAqIFJlZ2lzdGVycyB0cmFuc2Zvcm1hdGlvbiBmdW5jdGlvbnMgdGhhdCBkb24ndCBhbHRlciBjb29yZGluYXRlcy4gVGhvc2UgYWxsb3dcbiAqIHRvIHRyYW5zZm9ybSBiZXR3ZWVuIHByb2plY3Rpb25zIHdpdGggZXF1YWwgbWVhbmluZy5cbiAqXG4gKiBAcGFyYW0ge0FycmF5PFByb2plY3Rpb24+fSBwcm9qZWN0aW9ucyBQcm9qZWN0aW9ucy5cbiAqIEBhcGlcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGFkZEVxdWl2YWxlbnRQcm9qZWN0aW9ucyhwcm9qZWN0aW9ucykge1xuICBhZGRQcm9qZWN0aW9ucyhwcm9qZWN0aW9ucyk7XG4gIHByb2plY3Rpb25zLmZvckVhY2goZnVuY3Rpb24gKHNvdXJjZSkge1xuICAgIHByb2plY3Rpb25zLmZvckVhY2goZnVuY3Rpb24gKGRlc3RpbmF0aW9uKSB7XG4gICAgICBpZiAoc291cmNlICE9PSBkZXN0aW5hdGlvbikge1xuICAgICAgICBhZGRUcmFuc2Zvcm1GdW5jKHNvdXJjZSwgZGVzdGluYXRpb24sIGNsb25lVHJhbnNmb3JtKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSk7XG59XG5cbi8qKlxuICogUmVnaXN0ZXJzIHRyYW5zZm9ybWF0aW9uIGZ1bmN0aW9ucyB0byBjb252ZXJ0IGNvb3JkaW5hdGVzIGluIGFueSBwcm9qZWN0aW9uXG4gKiBpbiBwcm9qZWN0aW9uMSB0byBhbnkgcHJvamVjdGlvbiBpbiBwcm9qZWN0aW9uMi5cbiAqXG4gKiBAcGFyYW0ge0FycmF5PFByb2plY3Rpb24+fSBwcm9qZWN0aW9uczEgUHJvamVjdGlvbnMgd2l0aCBlcXVhbFxuICogICAgIG1lYW5pbmcuXG4gKiBAcGFyYW0ge0FycmF5PFByb2plY3Rpb24+fSBwcm9qZWN0aW9uczIgUHJvamVjdGlvbnMgd2l0aCBlcXVhbFxuICogICAgIG1lYW5pbmcuXG4gKiBAcGFyYW0ge1RyYW5zZm9ybUZ1bmN0aW9ufSBmb3J3YXJkVHJhbnNmb3JtIFRyYW5zZm9ybWF0aW9uIGZyb20gYW55XG4gKiAgIHByb2plY3Rpb24gaW4gcHJvamVjdGlvbjEgdG8gYW55IHByb2plY3Rpb24gaW4gcHJvamVjdGlvbjIuXG4gKiBAcGFyYW0ge1RyYW5zZm9ybUZ1bmN0aW9ufSBpbnZlcnNlVHJhbnNmb3JtIFRyYW5zZm9ybSBmcm9tIGFueSBwcm9qZWN0aW9uXG4gKiAgIGluIHByb2plY3Rpb24yIHRvIGFueSBwcm9qZWN0aW9uIGluIHByb2plY3Rpb24xLi5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGFkZEVxdWl2YWxlbnRUcmFuc2Zvcm1zKFxuICBwcm9qZWN0aW9uczEsXG4gIHByb2plY3Rpb25zMixcbiAgZm9yd2FyZFRyYW5zZm9ybSxcbiAgaW52ZXJzZVRyYW5zZm9ybVxuKSB7XG4gIHByb2plY3Rpb25zMS5mb3JFYWNoKGZ1bmN0aW9uIChwcm9qZWN0aW9uMSkge1xuICAgIHByb2plY3Rpb25zMi5mb3JFYWNoKGZ1bmN0aW9uIChwcm9qZWN0aW9uMikge1xuICAgICAgYWRkVHJhbnNmb3JtRnVuYyhwcm9qZWN0aW9uMSwgcHJvamVjdGlvbjIsIGZvcndhcmRUcmFuc2Zvcm0pO1xuICAgICAgYWRkVHJhbnNmb3JtRnVuYyhwcm9qZWN0aW9uMiwgcHJvamVjdGlvbjEsIGludmVyc2VUcmFuc2Zvcm0pO1xuICAgIH0pO1xuICB9KTtcbn1cblxuLyoqXG4gKiBDbGVhciBhbGwgY2FjaGVkIHByb2plY3Rpb25zIGFuZCB0cmFuc2Zvcm1zLlxuICovXG5leHBvcnQgZnVuY3Rpb24gY2xlYXJBbGxQcm9qZWN0aW9ucygpIHtcbiAgY2xlYXJQcm9qKCk7XG4gIGNsZWFyVHJhbnNmb3JtRnVuY3MoKTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge1Byb2plY3Rpb258c3RyaW5nfHVuZGVmaW5lZH0gcHJvamVjdGlvbiBQcm9qZWN0aW9uLlxuICogQHBhcmFtIHtzdHJpbmd9IGRlZmF1bHRDb2RlIERlZmF1bHQgY29kZS5cbiAqIEByZXR1cm4ge1Byb2plY3Rpb259IFByb2plY3Rpb24uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVQcm9qZWN0aW9uKHByb2plY3Rpb24sIGRlZmF1bHRDb2RlKSB7XG4gIGlmICghcHJvamVjdGlvbikge1xuICAgIHJldHVybiBnZXQoZGVmYXVsdENvZGUpO1xuICB9IGVsc2UgaWYgKHR5cGVvZiBwcm9qZWN0aW9uID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiBnZXQocHJvamVjdGlvbik7XG4gIH1cbiAgcmV0dXJuIC8qKiBAdHlwZSB7UHJvamVjdGlvbn0gKi8gKHByb2plY3Rpb24pO1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYSB7QGxpbmsgbW9kdWxlOm9sL3Byb2p+VHJhbnNmb3JtRnVuY3Rpb259IGZyb20gYSBzaW1wbGUgMkQgY29vcmRpbmF0ZSB0cmFuc2Zvcm1cbiAqIGZ1bmN0aW9uLlxuICogQHBhcmFtIHtmdW5jdGlvbihpbXBvcnQoXCIuL2Nvb3JkaW5hdGUuanNcIikuQ29vcmRpbmF0ZSk6IGltcG9ydChcIi4vY29vcmRpbmF0ZS5qc1wiKS5Db29yZGluYXRlfSBjb29yZFRyYW5zZm9ybSBDb29yZGluYXRlXG4gKiAgICAgdHJhbnNmb3JtLlxuICogQHJldHVybiB7VHJhbnNmb3JtRnVuY3Rpb259IFRyYW5zZm9ybSBmdW5jdGlvbi5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZVRyYW5zZm9ybUZyb21Db29yZGluYXRlVHJhbnNmb3JtKGNvb3JkVHJhbnNmb3JtKSB7XG4gIHJldHVybiAoXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSBpbnB1dCBJbnB1dC5cbiAgICAgKiBAcGFyYW0ge0FycmF5PG51bWJlcj59IFtvdXRwdXRdIE91dHB1dC5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2RpbWVuc2lvbl0gRGltZW5zaW9uLlxuICAgICAqIEByZXR1cm4ge0FycmF5PG51bWJlcj59IE91dHB1dC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiAoaW5wdXQsIG91dHB1dCwgZGltZW5zaW9uKSB7XG4gICAgICBjb25zdCBsZW5ndGggPSBpbnB1dC5sZW5ndGg7XG4gICAgICBkaW1lbnNpb24gPSBkaW1lbnNpb24gIT09IHVuZGVmaW5lZCA/IGRpbWVuc2lvbiA6IDI7XG4gICAgICBvdXRwdXQgPSBvdXRwdXQgIT09IHVuZGVmaW5lZCA/IG91dHB1dCA6IG5ldyBBcnJheShsZW5ndGgpO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW5ndGg7IGkgKz0gZGltZW5zaW9uKSB7XG4gICAgICAgIGNvbnN0IHBvaW50ID0gY29vcmRUcmFuc2Zvcm0oaW5wdXQuc2xpY2UoaSwgaSArIGRpbWVuc2lvbikpO1xuICAgICAgICBjb25zdCBwb2ludExlbmd0aCA9IHBvaW50Lmxlbmd0aDtcbiAgICAgICAgZm9yIChsZXQgaiA9IDAsIGpqID0gZGltZW5zaW9uOyBqIDwgamo7ICsraikge1xuICAgICAgICAgIG91dHB1dFtpICsgal0gPSBqID49IHBvaW50TGVuZ3RoID8gaW5wdXRbaSArIGpdIDogcG9pbnRbal07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBvdXRwdXQ7XG4gICAgfVxuICApO1xufVxuXG4vKipcbiAqIFJlZ2lzdGVycyBjb29yZGluYXRlIHRyYW5zZm9ybSBmdW5jdGlvbnMgdG8gY29udmVydCBjb29yZGluYXRlcyBiZXR3ZWVuIHRoZVxuICogc291cmNlIHByb2plY3Rpb24gYW5kIHRoZSBkZXN0aW5hdGlvbiBwcm9qZWN0aW9uLlxuICogVGhlIGZvcndhcmQgYW5kIGludmVyc2UgZnVuY3Rpb25zIGNvbnZlcnQgY29vcmRpbmF0ZSBwYWlyczsgdGhpcyBmdW5jdGlvblxuICogY29udmVydHMgdGhlc2UgaW50byB0aGUgZnVuY3Rpb25zIHVzZWQgaW50ZXJuYWxseSB3aGljaCBhbHNvIGhhbmRsZVxuICogZXh0ZW50cyBhbmQgY29vcmRpbmF0ZSBhcnJheXMuXG4gKlxuICogQHBhcmFtIHtQcm9qZWN0aW9uTGlrZX0gc291cmNlIFNvdXJjZSBwcm9qZWN0aW9uLlxuICogQHBhcmFtIHtQcm9qZWN0aW9uTGlrZX0gZGVzdGluYXRpb24gRGVzdGluYXRpb24gcHJvamVjdGlvbi5cbiAqIEBwYXJhbSB7ZnVuY3Rpb24oaW1wb3J0KFwiLi9jb29yZGluYXRlLmpzXCIpLkNvb3JkaW5hdGUpOiBpbXBvcnQoXCIuL2Nvb3JkaW5hdGUuanNcIikuQ29vcmRpbmF0ZX0gZm9yd2FyZCBUaGUgZm9yd2FyZCB0cmFuc2Zvcm1cbiAqICAgICBmdW5jdGlvbiAodGhhdCBpcywgZnJvbSB0aGUgc291cmNlIHByb2plY3Rpb24gdG8gdGhlIGRlc3RpbmF0aW9uXG4gKiAgICAgcHJvamVjdGlvbikgdGhhdCB0YWtlcyBhIHtAbGluayBtb2R1bGU6b2wvY29vcmRpbmF0ZX5Db29yZGluYXRlfSBhcyBhcmd1bWVudCBhbmQgcmV0dXJuc1xuICogICAgIHRoZSB0cmFuc2Zvcm1lZCB7QGxpbmsgbW9kdWxlOm9sL2Nvb3JkaW5hdGV+Q29vcmRpbmF0ZX0uXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKGltcG9ydChcIi4vY29vcmRpbmF0ZS5qc1wiKS5Db29yZGluYXRlKTogaW1wb3J0KFwiLi9jb29yZGluYXRlLmpzXCIpLkNvb3JkaW5hdGV9IGludmVyc2UgVGhlIGludmVyc2UgdHJhbnNmb3JtXG4gKiAgICAgZnVuY3Rpb24gKHRoYXQgaXMsIGZyb20gdGhlIGRlc3RpbmF0aW9uIHByb2plY3Rpb24gdG8gdGhlIHNvdXJjZVxuICogICAgIHByb2plY3Rpb24pIHRoYXQgdGFrZXMgYSB7QGxpbmsgbW9kdWxlOm9sL2Nvb3JkaW5hdGV+Q29vcmRpbmF0ZX0gYXMgYXJndW1lbnQgYW5kIHJldHVybnNcbiAqICAgICB0aGUgdHJhbnNmb3JtZWQge0BsaW5rIG1vZHVsZTpvbC9jb29yZGluYXRlfkNvb3JkaW5hdGV9LiBJZiB0aGUgdHJhbnNmb3JtIGZ1bmN0aW9uIGNhbiBvbmx5XG4gKiAgICAgdHJhbnNmb3JtIGxlc3MgZGltZW5zaW9ucyB0aGFuIHRoZSBpbnB1dCBjb29yZGluYXRlLCBpdCBpcyBzdXBwb3NlZWQgdG8gcmV0dXJuIGEgY29vcmRpbmF0ZVxuICogICAgIHdpdGggb25seSB0aGUgbGVuZ3RoIGl0IGNhbiB0cmFuc2Zvcm0uIFRoZSBvdGhlciBkaW1lbnNpb25zIHdpbGwgYmUgdGFrZW4gdW5jaGFuZ2VkIGZyb20gdGhlXG4gKiAgICAgc291cmNlLlxuICogQGFwaVxuICovXG5leHBvcnQgZnVuY3Rpb24gYWRkQ29vcmRpbmF0ZVRyYW5zZm9ybXMoc291cmNlLCBkZXN0aW5hdGlvbiwgZm9yd2FyZCwgaW52ZXJzZSkge1xuICBjb25zdCBzb3VyY2VQcm9qID0gZ2V0KHNvdXJjZSk7XG4gIGNvbnN0IGRlc3RQcm9qID0gZ2V0KGRlc3RpbmF0aW9uKTtcbiAgYWRkVHJhbnNmb3JtRnVuYyhcbiAgICBzb3VyY2VQcm9qLFxuICAgIGRlc3RQcm9qLFxuICAgIGNyZWF0ZVRyYW5zZm9ybUZyb21Db29yZGluYXRlVHJhbnNmb3JtKGZvcndhcmQpXG4gICk7XG4gIGFkZFRyYW5zZm9ybUZ1bmMoXG4gICAgZGVzdFByb2osXG4gICAgc291cmNlUHJvaixcbiAgICBjcmVhdGVUcmFuc2Zvcm1Gcm9tQ29vcmRpbmF0ZVRyYW5zZm9ybShpbnZlcnNlKVxuICApO1xufVxuXG4vKipcbiAqIFRyYW5zZm9ybXMgYSBjb29yZGluYXRlIGZyb20gbG9uZ2l0dWRlL2xhdGl0dWRlIHRvIGEgZGlmZmVyZW50IHByb2plY3Rpb24uXG4gKiBAcGFyYW0ge2ltcG9ydChcIi4vY29vcmRpbmF0ZS5qc1wiKS5Db29yZGluYXRlfSBjb29yZGluYXRlIENvb3JkaW5hdGUgYXMgbG9uZ2l0dWRlIGFuZCBsYXRpdHVkZSwgaS5lLlxuICogICAgIGFuIGFycmF5IHdpdGggbG9uZ2l0dWRlIGFzIDFzdCBhbmQgbGF0aXR1ZGUgYXMgMm5kIGVsZW1lbnQuXG4gKiBAcGFyYW0ge1Byb2plY3Rpb25MaWtlfSBbcHJvamVjdGlvbl0gVGFyZ2V0IHByb2plY3Rpb24uIFRoZVxuICogICAgIGRlZmF1bHQgaXMgV2ViIE1lcmNhdG9yLCBpLmUuICdFUFNHOjM4NTcnLlxuICogQHJldHVybiB7aW1wb3J0KFwiLi9jb29yZGluYXRlLmpzXCIpLkNvb3JkaW5hdGV9IENvb3JkaW5hdGUgcHJvamVjdGVkIHRvIHRoZSB0YXJnZXQgcHJvamVjdGlvbi5cbiAqIEBhcGlcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGZyb21Mb25MYXQoY29vcmRpbmF0ZSwgcHJvamVjdGlvbikge1xuICBkaXNhYmxlQ29vcmRpbmF0ZVdhcm5pbmcoKTtcbiAgcmV0dXJuIHRyYW5zZm9ybShcbiAgICBjb29yZGluYXRlLFxuICAgICdFUFNHOjQzMjYnLFxuICAgIHByb2plY3Rpb24gIT09IHVuZGVmaW5lZCA/IHByb2plY3Rpb24gOiAnRVBTRzozODU3J1xuICApO1xufVxuXG4vKipcbiAqIFRyYW5zZm9ybXMgYSBjb29yZGluYXRlIHRvIGxvbmdpdHVkZS9sYXRpdHVkZS5cbiAqIEBwYXJhbSB7aW1wb3J0KFwiLi9jb29yZGluYXRlLmpzXCIpLkNvb3JkaW5hdGV9IGNvb3JkaW5hdGUgUHJvamVjdGVkIGNvb3JkaW5hdGUuXG4gKiBAcGFyYW0ge1Byb2plY3Rpb25MaWtlfSBbcHJvamVjdGlvbl0gUHJvamVjdGlvbiBvZiB0aGUgY29vcmRpbmF0ZS5cbiAqICAgICBUaGUgZGVmYXVsdCBpcyBXZWIgTWVyY2F0b3IsIGkuZS4gJ0VQU0c6Mzg1NycuXG4gKiBAcmV0dXJuIHtpbXBvcnQoXCIuL2Nvb3JkaW5hdGUuanNcIikuQ29vcmRpbmF0ZX0gQ29vcmRpbmF0ZSBhcyBsb25naXR1ZGUgYW5kIGxhdGl0dWRlLCBpLmUuIGFuIGFycmF5XG4gKiAgICAgd2l0aCBsb25naXR1ZGUgYXMgMXN0IGFuZCBsYXRpdHVkZSBhcyAybmQgZWxlbWVudC5cbiAqIEBhcGlcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRvTG9uTGF0KGNvb3JkaW5hdGUsIHByb2plY3Rpb24pIHtcbiAgY29uc3QgbG9uTGF0ID0gdHJhbnNmb3JtKFxuICAgIGNvb3JkaW5hdGUsXG4gICAgcHJvamVjdGlvbiAhPT0gdW5kZWZpbmVkID8gcHJvamVjdGlvbiA6ICdFUFNHOjM4NTcnLFxuICAgICdFUFNHOjQzMjYnXG4gICk7XG4gIGNvbnN0IGxvbiA9IGxvbkxhdFswXTtcbiAgaWYgKGxvbiA8IC0xODAgfHwgbG9uID4gMTgwKSB7XG4gICAgbG9uTGF0WzBdID0gbW9kdWxvKGxvbiArIDE4MCwgMzYwKSAtIDE4MDtcbiAgfVxuICByZXR1cm4gbG9uTGF0O1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiB0d28gcHJvamVjdGlvbnMgYXJlIHRoZSBzYW1lLCB0aGF0IGlzIGV2ZXJ5IGNvb3JkaW5hdGUgaW4gb25lXG4gKiBwcm9qZWN0aW9uIGRvZXMgcmVwcmVzZW50IHRoZSBzYW1lIGdlb2dyYXBoaWMgcG9pbnQgYXMgdGhlIHNhbWUgY29vcmRpbmF0ZSBpblxuICogdGhlIG90aGVyIHByb2plY3Rpb24uXG4gKlxuICogQHBhcmFtIHtQcm9qZWN0aW9ufSBwcm9qZWN0aW9uMSBQcm9qZWN0aW9uIDEuXG4gKiBAcGFyYW0ge1Byb2plY3Rpb259IHByb2plY3Rpb24yIFByb2plY3Rpb24gMi5cbiAqIEByZXR1cm4ge2Jvb2xlYW59IEVxdWl2YWxlbnQuXG4gKiBAYXBpXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBlcXVpdmFsZW50KHByb2plY3Rpb24xLCBwcm9qZWN0aW9uMikge1xuICBpZiAocHJvamVjdGlvbjEgPT09IHByb2plY3Rpb24yKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgY29uc3QgZXF1YWxVbml0cyA9IHByb2plY3Rpb24xLmdldFVuaXRzKCkgPT09IHByb2plY3Rpb24yLmdldFVuaXRzKCk7XG4gIGlmIChwcm9qZWN0aW9uMS5nZXRDb2RlKCkgPT09IHByb2plY3Rpb24yLmdldENvZGUoKSkge1xuICAgIHJldHVybiBlcXVhbFVuaXRzO1xuICB9XG4gIGNvbnN0IHRyYW5zZm9ybUZ1bmMgPSBnZXRUcmFuc2Zvcm1Gcm9tUHJvamVjdGlvbnMocHJvamVjdGlvbjEsIHByb2plY3Rpb24yKTtcbiAgcmV0dXJuIHRyYW5zZm9ybUZ1bmMgPT09IGNsb25lVHJhbnNmb3JtICYmIGVxdWFsVW5pdHM7XG59XG5cbi8qKlxuICogU2VhcmNoZXMgaW4gdGhlIGxpc3Qgb2YgdHJhbnNmb3JtIGZ1bmN0aW9ucyBmb3IgdGhlIGZ1bmN0aW9uIGZvciBjb252ZXJ0aW5nXG4gKiBjb29yZGluYXRlcyBmcm9tIHRoZSBzb3VyY2UgcHJvamVjdGlvbiB0byB0aGUgZGVzdGluYXRpb24gcHJvamVjdGlvbi5cbiAqXG4gKiBAcGFyYW0ge1Byb2plY3Rpb259IHNvdXJjZVByb2plY3Rpb24gU291cmNlIFByb2plY3Rpb24gb2JqZWN0LlxuICogQHBhcmFtIHtQcm9qZWN0aW9ufSBkZXN0aW5hdGlvblByb2plY3Rpb24gRGVzdGluYXRpb24gUHJvamVjdGlvblxuICogICAgIG9iamVjdC5cbiAqIEByZXR1cm4ge1RyYW5zZm9ybUZ1bmN0aW9ufSBUcmFuc2Zvcm0gZnVuY3Rpb24uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRUcmFuc2Zvcm1Gcm9tUHJvamVjdGlvbnMoXG4gIHNvdXJjZVByb2plY3Rpb24sXG4gIGRlc3RpbmF0aW9uUHJvamVjdGlvblxuKSB7XG4gIGNvbnN0IHNvdXJjZUNvZGUgPSBzb3VyY2VQcm9qZWN0aW9uLmdldENvZGUoKTtcbiAgY29uc3QgZGVzdGluYXRpb25Db2RlID0gZGVzdGluYXRpb25Qcm9qZWN0aW9uLmdldENvZGUoKTtcbiAgbGV0IHRyYW5zZm9ybUZ1bmMgPSBnZXRUcmFuc2Zvcm1GdW5jKHNvdXJjZUNvZGUsIGRlc3RpbmF0aW9uQ29kZSk7XG4gIGlmICghdHJhbnNmb3JtRnVuYykge1xuICAgIHRyYW5zZm9ybUZ1bmMgPSBpZGVudGl0eVRyYW5zZm9ybTtcbiAgfVxuICByZXR1cm4gdHJhbnNmb3JtRnVuYztcbn1cblxuLyoqXG4gKiBHaXZlbiB0aGUgcHJvamVjdGlvbi1saWtlIG9iamVjdHMsIHNlYXJjaGVzIGZvciBhIHRyYW5zZm9ybWF0aW9uXG4gKiBmdW5jdGlvbiB0byBjb252ZXJ0IGEgY29vcmRpbmF0ZXMgYXJyYXkgZnJvbSB0aGUgc291cmNlIHByb2plY3Rpb24gdG8gdGhlXG4gKiBkZXN0aW5hdGlvbiBwcm9qZWN0aW9uLlxuICpcbiAqIEBwYXJhbSB7UHJvamVjdGlvbkxpa2V9IHNvdXJjZSBTb3VyY2UuXG4gKiBAcGFyYW0ge1Byb2plY3Rpb25MaWtlfSBkZXN0aW5hdGlvbiBEZXN0aW5hdGlvbi5cbiAqIEByZXR1cm4ge1RyYW5zZm9ybUZ1bmN0aW9ufSBUcmFuc2Zvcm0gZnVuY3Rpb24uXG4gKiBAYXBpXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRUcmFuc2Zvcm0oc291cmNlLCBkZXN0aW5hdGlvbikge1xuICBjb25zdCBzb3VyY2VQcm9qZWN0aW9uID0gZ2V0KHNvdXJjZSk7XG4gIGNvbnN0IGRlc3RpbmF0aW9uUHJvamVjdGlvbiA9IGdldChkZXN0aW5hdGlvbik7XG4gIHJldHVybiBnZXRUcmFuc2Zvcm1Gcm9tUHJvamVjdGlvbnMoc291cmNlUHJvamVjdGlvbiwgZGVzdGluYXRpb25Qcm9qZWN0aW9uKTtcbn1cblxuLyoqXG4gKiBUcmFuc2Zvcm1zIGEgY29vcmRpbmF0ZSBmcm9tIHNvdXJjZSBwcm9qZWN0aW9uIHRvIGRlc3RpbmF0aW9uIHByb2plY3Rpb24uXG4gKiBUaGlzIHJldHVybnMgYSBuZXcgY29vcmRpbmF0ZSAoYW5kIGRvZXMgbm90IG1vZGlmeSB0aGUgb3JpZ2luYWwpLlxuICpcbiAqIFNlZSB7QGxpbmsgbW9kdWxlOm9sL3Byb2oudHJhbnNmb3JtRXh0ZW50fSBmb3IgZXh0ZW50IHRyYW5zZm9ybWF0aW9uLlxuICogU2VlIHRoZSB0cmFuc2Zvcm0gbWV0aG9kIG9mIHtAbGluayBtb2R1bGU6b2wvZ2VvbS9HZW9tZXRyeX5HZW9tZXRyeX0gYW5kIGl0c1xuICogc3ViY2xhc3NlcyBmb3IgZ2VvbWV0cnkgdHJhbnNmb3Jtcy5cbiAqXG4gKiBAcGFyYW0ge2ltcG9ydChcIi4vY29vcmRpbmF0ZS5qc1wiKS5Db29yZGluYXRlfSBjb29yZGluYXRlIENvb3JkaW5hdGUuXG4gKiBAcGFyYW0ge1Byb2plY3Rpb25MaWtlfSBzb3VyY2UgU291cmNlIHByb2plY3Rpb24tbGlrZS5cbiAqIEBwYXJhbSB7UHJvamVjdGlvbkxpa2V9IGRlc3RpbmF0aW9uIERlc3RpbmF0aW9uIHByb2plY3Rpb24tbGlrZS5cbiAqIEByZXR1cm4ge2ltcG9ydChcIi4vY29vcmRpbmF0ZS5qc1wiKS5Db29yZGluYXRlfSBDb29yZGluYXRlLlxuICogQGFwaVxuICovXG5leHBvcnQgZnVuY3Rpb24gdHJhbnNmb3JtKGNvb3JkaW5hdGUsIHNvdXJjZSwgZGVzdGluYXRpb24pIHtcbiAgY29uc3QgdHJhbnNmb3JtRnVuYyA9IGdldFRyYW5zZm9ybShzb3VyY2UsIGRlc3RpbmF0aW9uKTtcbiAgcmV0dXJuIHRyYW5zZm9ybUZ1bmMoY29vcmRpbmF0ZSwgdW5kZWZpbmVkLCBjb29yZGluYXRlLmxlbmd0aCk7XG59XG5cbi8qKlxuICogVHJhbnNmb3JtcyBhbiBleHRlbnQgZnJvbSBzb3VyY2UgcHJvamVjdGlvbiB0byBkZXN0aW5hdGlvbiBwcm9qZWN0aW9uLiAgVGhpc1xuICogcmV0dXJucyBhIG5ldyBleHRlbnQgKGFuZCBkb2VzIG5vdCBtb2RpZnkgdGhlIG9yaWdpbmFsKS5cbiAqXG4gKiBAcGFyYW0ge2ltcG9ydChcIi4vZXh0ZW50LmpzXCIpLkV4dGVudH0gZXh0ZW50IFRoZSBleHRlbnQgdG8gdHJhbnNmb3JtLlxuICogQHBhcmFtIHtQcm9qZWN0aW9uTGlrZX0gc291cmNlIFNvdXJjZSBwcm9qZWN0aW9uLWxpa2UuXG4gKiBAcGFyYW0ge1Byb2plY3Rpb25MaWtlfSBkZXN0aW5hdGlvbiBEZXN0aW5hdGlvbiBwcm9qZWN0aW9uLWxpa2UuXG4gKiBAcGFyYW0ge251bWJlcn0gW3N0b3BzXSBOdW1iZXIgb2Ygc3RvcHMgcGVyIHNpZGUgdXNlZCBmb3IgdGhlIHRyYW5zZm9ybS5cbiAqIEJ5IGRlZmF1bHQgb25seSB0aGUgY29ybmVycyBhcmUgdXNlZC5cbiAqIEByZXR1cm4ge2ltcG9ydChcIi4vZXh0ZW50LmpzXCIpLkV4dGVudH0gVGhlIHRyYW5zZm9ybWVkIGV4dGVudC5cbiAqIEBhcGlcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRyYW5zZm9ybUV4dGVudChleHRlbnQsIHNvdXJjZSwgZGVzdGluYXRpb24sIHN0b3BzKSB7XG4gIGNvbnN0IHRyYW5zZm9ybUZ1bmMgPSBnZXRUcmFuc2Zvcm0oc291cmNlLCBkZXN0aW5hdGlvbik7XG4gIHJldHVybiBhcHBseVRyYW5zZm9ybShleHRlbnQsIHRyYW5zZm9ybUZ1bmMsIHVuZGVmaW5lZCwgc3RvcHMpO1xufVxuXG4vKipcbiAqIFRyYW5zZm9ybXMgdGhlIGdpdmVuIHBvaW50IHRvIHRoZSBkZXN0aW5hdGlvbiBwcm9qZWN0aW9uLlxuICpcbiAqIEBwYXJhbSB7aW1wb3J0KFwiLi9jb29yZGluYXRlLmpzXCIpLkNvb3JkaW5hdGV9IHBvaW50IFBvaW50LlxuICogQHBhcmFtIHtQcm9qZWN0aW9ufSBzb3VyY2VQcm9qZWN0aW9uIFNvdXJjZSBwcm9qZWN0aW9uLlxuICogQHBhcmFtIHtQcm9qZWN0aW9ufSBkZXN0aW5hdGlvblByb2plY3Rpb24gRGVzdGluYXRpb24gcHJvamVjdGlvbi5cbiAqIEByZXR1cm4ge2ltcG9ydChcIi4vY29vcmRpbmF0ZS5qc1wiKS5Db29yZGluYXRlfSBQb2ludC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRyYW5zZm9ybVdpdGhQcm9qZWN0aW9ucyhcbiAgcG9pbnQsXG4gIHNvdXJjZVByb2plY3Rpb24sXG4gIGRlc3RpbmF0aW9uUHJvamVjdGlvblxuKSB7XG4gIGNvbnN0IHRyYW5zZm9ybUZ1bmMgPSBnZXRUcmFuc2Zvcm1Gcm9tUHJvamVjdGlvbnMoXG4gICAgc291cmNlUHJvamVjdGlvbixcbiAgICBkZXN0aW5hdGlvblByb2plY3Rpb25cbiAgKTtcbiAgcmV0dXJuIHRyYW5zZm9ybUZ1bmMocG9pbnQpO1xufVxuXG4vKipcbiAqIEB0eXBlIHtQcm9qZWN0aW9ufG51bGx9XG4gKi9cbmxldCB1c2VyUHJvamVjdGlvbiA9IG51bGw7XG5cbi8qKlxuICogU2V0IHRoZSBwcm9qZWN0aW9uIGZvciBjb29yZGluYXRlcyBzdXBwbGllZCBmcm9tIGFuZCByZXR1cm5lZCBieSBBUEkgbWV0aG9kcy5cbiAqIFRoaXMgaW5jbHVkZXMgYWxsIEFQSSBtZXRob2RzIGV4Y2VwdCBmb3IgdGhvc2UgaW50ZXJhY3Rpbmcgd2l0aCB0aWxlIGdyaWRzLlxuICogQHBhcmFtIHtQcm9qZWN0aW9uTGlrZX0gcHJvamVjdGlvbiBUaGUgdXNlciBwcm9qZWN0aW9uLlxuICogQGFwaVxuICovXG5leHBvcnQgZnVuY3Rpb24gc2V0VXNlclByb2plY3Rpb24ocHJvamVjdGlvbikge1xuICB1c2VyUHJvamVjdGlvbiA9IGdldChwcm9qZWN0aW9uKTtcbn1cblxuLyoqXG4gKiBDbGVhciB0aGUgdXNlciBwcm9qZWN0aW9uIGlmIHNldC5cbiAqIEBhcGlcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNsZWFyVXNlclByb2plY3Rpb24oKSB7XG4gIHVzZXJQcm9qZWN0aW9uID0gbnVsbDtcbn1cblxuLyoqXG4gKiBHZXQgdGhlIHByb2plY3Rpb24gZm9yIGNvb3JkaW5hdGVzIHN1cHBsaWVkIGZyb20gYW5kIHJldHVybmVkIGJ5IEFQSSBtZXRob2RzLlxuICogTm90ZSB0aGF0IHRoaXMgbWV0aG9kIGlzIG5vdCB5ZXQgYSBwYXJ0IG9mIHRoZSBzdGFibGUgQVBJLiAgU3VwcG9ydCBmb3IgdXNlclxuICogcHJvamVjdGlvbnMgaXMgbm90IHlldCBjb21wbGV0ZSBhbmQgc2hvdWxkIGJlIGNvbnNpZGVyZWQgZXhwZXJpbWVudGFsLlxuICogQHJldHVybiB7UHJvamVjdGlvbnxudWxsfSBUaGUgdXNlciBwcm9qZWN0aW9uIChvciBudWxsIGlmIG5vdCBzZXQpLlxuICogQGFwaVxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0VXNlclByb2plY3Rpb24oKSB7XG4gIHJldHVybiB1c2VyUHJvamVjdGlvbjtcbn1cblxuLyoqXG4gKiBVc2UgZ2VvZ3JhcGhpYyBjb29yZGluYXRlcyAoV0dTLTg0IGRhdHVtKSBpbiBBUEkgbWV0aG9kcy4gIFRoaXMgaW5jbHVkZXMgYWxsIEFQSVxuICogbWV0aG9kcyBleGNlcHQgZm9yIHRob3NlIGludGVyYWN0aW5nIHdpdGggdGlsZSBncmlkcy5cbiAqIEBhcGlcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHVzZUdlb2dyYXBoaWMoKSB7XG4gIHNldFVzZXJQcm9qZWN0aW9uKCdFUFNHOjQzMjYnKTtcbn1cblxuLyoqXG4gKiBSZXR1cm4gYSBjb29yZGluYXRlIHRyYW5zZm9ybWVkIGludG8gdGhlIHVzZXIgcHJvamVjdGlvbi4gIElmIG5vIHVzZXIgcHJvamVjdGlvblxuICogaXMgc2V0LCB0aGUgb3JpZ2luYWwgY29vcmRpbmF0ZSBpcyByZXR1cm5lZC5cbiAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gY29vcmRpbmF0ZSBJbnB1dCBjb29yZGluYXRlLlxuICogQHBhcmFtIHtQcm9qZWN0aW9uTGlrZX0gc291cmNlUHJvamVjdGlvbiBUaGUgaW5wdXQgY29vcmRpbmF0ZSBwcm9qZWN0aW9uLlxuICogQHJldHVybiB7QXJyYXk8bnVtYmVyPn0gVGhlIGlucHV0IGNvb3JkaW5hdGUgaW4gdGhlIHVzZXIgcHJvamVjdGlvbi5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRvVXNlckNvb3JkaW5hdGUoY29vcmRpbmF0ZSwgc291cmNlUHJvamVjdGlvbikge1xuICBpZiAoIXVzZXJQcm9qZWN0aW9uKSB7XG4gICAgcmV0dXJuIGNvb3JkaW5hdGU7XG4gIH1cbiAgcmV0dXJuIHRyYW5zZm9ybShjb29yZGluYXRlLCBzb3VyY2VQcm9qZWN0aW9uLCB1c2VyUHJvamVjdGlvbik7XG59XG5cbi8qKlxuICogUmV0dXJuIGEgY29vcmRpbmF0ZSB0cmFuc2Zvcm1lZCBmcm9tIHRoZSB1c2VyIHByb2plY3Rpb24uICBJZiBubyB1c2VyIHByb2plY3Rpb25cbiAqIGlzIHNldCwgdGhlIG9yaWdpbmFsIGNvb3JkaW5hdGUgaXMgcmV0dXJuZWQuXG4gKiBAcGFyYW0ge0FycmF5PG51bWJlcj59IGNvb3JkaW5hdGUgSW5wdXQgY29vcmRpbmF0ZS5cbiAqIEBwYXJhbSB7UHJvamVjdGlvbkxpa2V9IGRlc3RQcm9qZWN0aW9uIFRoZSBkZXN0aW5hdGlvbiBwcm9qZWN0aW9uLlxuICogQHJldHVybiB7QXJyYXk8bnVtYmVyPn0gVGhlIGlucHV0IGNvb3JkaW5hdGUgdHJhbnNmb3JtZWQuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBmcm9tVXNlckNvb3JkaW5hdGUoY29vcmRpbmF0ZSwgZGVzdFByb2plY3Rpb24pIHtcbiAgaWYgKCF1c2VyUHJvamVjdGlvbikge1xuICAgIGlmIChcbiAgICAgIHNob3dDb29yZGluYXRlV2FybmluZyAmJlxuICAgICAgIWVxdWFscyhjb29yZGluYXRlLCBbMCwgMF0pICYmXG4gICAgICBjb29yZGluYXRlWzBdID49IC0xODAgJiZcbiAgICAgIGNvb3JkaW5hdGVbMF0gPD0gMTgwICYmXG4gICAgICBjb29yZGluYXRlWzFdID49IC05MCAmJlxuICAgICAgY29vcmRpbmF0ZVsxXSA8PSA5MFxuICAgICkge1xuICAgICAgc2hvd0Nvb3JkaW5hdGVXYXJuaW5nID0gZmFsc2U7XG4gICAgICB3YXJuKFxuICAgICAgICAnQ2FsbCB1c2VHZW9ncmFwaGljKCkgZnJvbSBvbC9wcm9qIG9uY2UgdG8gd29yayB3aXRoIFtsb25naXR1ZGUsIGxhdGl0dWRlXSBjb29yZGluYXRlcy4nXG4gICAgICApO1xuICAgIH1cbiAgICByZXR1cm4gY29vcmRpbmF0ZTtcbiAgfVxuICByZXR1cm4gdHJhbnNmb3JtKGNvb3JkaW5hdGUsIHVzZXJQcm9qZWN0aW9uLCBkZXN0UHJvamVjdGlvbik7XG59XG5cbi8qKlxuICogUmV0dXJuIGFuIGV4dGVudCB0cmFuc2Zvcm1lZCBpbnRvIHRoZSB1c2VyIHByb2plY3Rpb24uICBJZiBubyB1c2VyIHByb2plY3Rpb25cbiAqIGlzIHNldCwgdGhlIG9yaWdpbmFsIGV4dGVudCBpcyByZXR1cm5lZC5cbiAqIEBwYXJhbSB7aW1wb3J0KFwiLi9leHRlbnQuanNcIikuRXh0ZW50fSBleHRlbnQgSW5wdXQgZXh0ZW50LlxuICogQHBhcmFtIHtQcm9qZWN0aW9uTGlrZX0gc291cmNlUHJvamVjdGlvbiBUaGUgaW5wdXQgZXh0ZW50IHByb2plY3Rpb24uXG4gKiBAcmV0dXJuIHtpbXBvcnQoXCIuL2V4dGVudC5qc1wiKS5FeHRlbnR9IFRoZSBpbnB1dCBleHRlbnQgaW4gdGhlIHVzZXIgcHJvamVjdGlvbi5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRvVXNlckV4dGVudChleHRlbnQsIHNvdXJjZVByb2plY3Rpb24pIHtcbiAgaWYgKCF1c2VyUHJvamVjdGlvbikge1xuICAgIHJldHVybiBleHRlbnQ7XG4gIH1cbiAgcmV0dXJuIHRyYW5zZm9ybUV4dGVudChleHRlbnQsIHNvdXJjZVByb2plY3Rpb24sIHVzZXJQcm9qZWN0aW9uKTtcbn1cblxuLyoqXG4gKiBSZXR1cm4gYW4gZXh0ZW50IHRyYW5zZm9ybWVkIGZyb20gdGhlIHVzZXIgcHJvamVjdGlvbi4gIElmIG5vIHVzZXIgcHJvamVjdGlvblxuICogaXMgc2V0LCB0aGUgb3JpZ2luYWwgZXh0ZW50IGlzIHJldHVybmVkLlxuICogQHBhcmFtIHtpbXBvcnQoXCIuL2V4dGVudC5qc1wiKS5FeHRlbnR9IGV4dGVudCBJbnB1dCBleHRlbnQuXG4gKiBAcGFyYW0ge1Byb2plY3Rpb25MaWtlfSBkZXN0UHJvamVjdGlvbiBUaGUgZGVzdGluYXRpb24gcHJvamVjdGlvbi5cbiAqIEByZXR1cm4ge2ltcG9ydChcIi4vZXh0ZW50LmpzXCIpLkV4dGVudH0gVGhlIGlucHV0IGV4dGVudCB0cmFuc2Zvcm1lZC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGZyb21Vc2VyRXh0ZW50KGV4dGVudCwgZGVzdFByb2plY3Rpb24pIHtcbiAgaWYgKCF1c2VyUHJvamVjdGlvbikge1xuICAgIHJldHVybiBleHRlbnQ7XG4gIH1cbiAgcmV0dXJuIHRyYW5zZm9ybUV4dGVudChleHRlbnQsIHVzZXJQcm9qZWN0aW9uLCBkZXN0UHJvamVjdGlvbik7XG59XG5cbi8qKlxuICogUmV0dXJuIHRoZSByZXNvbHV0aW9uIGluIHVzZXIgcHJvamVjdGlvbiB1bml0cyBwZXIgcGl4ZWwuIElmIG5vIHVzZXIgcHJvamVjdGlvblxuICogaXMgc2V0LCBvciBzb3VyY2Ugb3IgdXNlciBwcm9qZWN0aW9uIGFyZSBtaXNzaW5nIHVuaXRzLCB0aGUgb3JpZ2luYWwgcmVzb2x1dGlvblxuICogaXMgcmV0dXJuZWQuXG4gKiBAcGFyYW0ge251bWJlcn0gcmVzb2x1dGlvbiBSZXNvbHV0aW9uIGluIGlucHV0IHByb2plY3Rpb24gdW5pdHMgcGVyIHBpeGVsLlxuICogQHBhcmFtIHtQcm9qZWN0aW9uTGlrZX0gc291cmNlUHJvamVjdGlvbiBUaGUgaW5wdXQgcHJvamVjdGlvbi5cbiAqIEByZXR1cm4ge251bWJlcn0gUmVzb2x1dGlvbiBpbiB1c2VyIHByb2plY3Rpb24gdW5pdHMgcGVyIHBpeGVsLlxuICovXG5leHBvcnQgZnVuY3Rpb24gdG9Vc2VyUmVzb2x1dGlvbihyZXNvbHV0aW9uLCBzb3VyY2VQcm9qZWN0aW9uKSB7XG4gIGlmICghdXNlclByb2plY3Rpb24pIHtcbiAgICByZXR1cm4gcmVzb2x1dGlvbjtcbiAgfVxuICBjb25zdCBzb3VyY2VVbml0cyA9IGdldChzb3VyY2VQcm9qZWN0aW9uKS5nZXRVbml0cygpO1xuICBjb25zdCB1c2VyVW5pdHMgPSB1c2VyUHJvamVjdGlvbi5nZXRVbml0cygpO1xuICByZXR1cm4gc291cmNlVW5pdHMgJiYgdXNlclVuaXRzXG4gICAgPyAocmVzb2x1dGlvbiAqIE1FVEVSU19QRVJfVU5JVFtzb3VyY2VVbml0c10pIC8gTUVURVJTX1BFUl9VTklUW3VzZXJVbml0c11cbiAgICA6IHJlc29sdXRpb247XG59XG5cbi8qKlxuICogUmV0dXJuIHRoZSByZXNvbHV0aW9uIGluIHVzZXIgcHJvamVjdGlvbiB1bml0cyBwZXIgcGl4ZWwuIElmIG5vIHVzZXIgcHJvamVjdGlvblxuICogaXMgc2V0LCBvciBzb3VyY2Ugb3IgdXNlciBwcm9qZWN0aW9uIGFyZSBtaXNzaW5nIHVuaXRzLCB0aGUgb3JpZ2luYWwgcmVzb2x1dGlvblxuICogaXMgcmV0dXJuZWQuXG4gKiBAcGFyYW0ge251bWJlcn0gcmVzb2x1dGlvbiBSZXNvbHV0aW9uIGluIHVzZXIgcHJvamVjdGlvbiB1bml0cyBwZXIgcGl4ZWwuXG4gKiBAcGFyYW0ge1Byb2plY3Rpb25MaWtlfSBkZXN0UHJvamVjdGlvbiBUaGUgZGVzdGluYXRpb24gcHJvamVjdGlvbi5cbiAqIEByZXR1cm4ge251bWJlcn0gUmVzb2x1dGlvbiBpbiBkZXN0aW5hdGlvbiBwcm9qZWN0aW9uIHVuaXRzIHBlciBwaXhlbC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGZyb21Vc2VyUmVzb2x1dGlvbihyZXNvbHV0aW9uLCBkZXN0UHJvamVjdGlvbikge1xuICBpZiAoIXVzZXJQcm9qZWN0aW9uKSB7XG4gICAgcmV0dXJuIHJlc29sdXRpb247XG4gIH1cbiAgY29uc3Qgc291cmNlVW5pdHMgPSBnZXQoZGVzdFByb2plY3Rpb24pLmdldFVuaXRzKCk7XG4gIGNvbnN0IHVzZXJVbml0cyA9IHVzZXJQcm9qZWN0aW9uLmdldFVuaXRzKCk7XG4gIHJldHVybiBzb3VyY2VVbml0cyAmJiB1c2VyVW5pdHNcbiAgICA/IChyZXNvbHV0aW9uICogTUVURVJTX1BFUl9VTklUW3VzZXJVbml0c10pIC8gTUVURVJTX1BFUl9VTklUW3NvdXJjZVVuaXRzXVxuICAgIDogcmVzb2x1dGlvbjtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgc2FmZSBjb29yZGluYXRlIHRyYW5zZm9ybSBmdW5jdGlvbiBmcm9tIGEgY29vcmRpbmF0ZSB0cmFuc2Zvcm0gZnVuY3Rpb24uXG4gKiBcIlNhZmVcIiBtZWFucyB0aGF0IGl0IGNhbiBoYW5kbGUgd3JhcHBpbmcgb2YgeC1jb29yZGluYXRlcyBmb3IgZ2xvYmFsIHByb2plY3Rpb25zLFxuICogYW5kIHRoYXQgY29vcmRpbmF0ZXMgZXhjZWVkaW5nIHRoZSBzb3VyY2UgcHJvamVjdGlvbiB2YWxpZGl0eSBleHRlbnQncyByYW5nZSB3aWxsIGJlXG4gKiBjbGFtcGVkIHRvIHRoZSB2YWxpZGl0eSByYW5nZS5cbiAqIEBwYXJhbSB7UHJvamVjdGlvbn0gc291cmNlUHJvaiBTb3VyY2UgcHJvamVjdGlvbi5cbiAqIEBwYXJhbSB7UHJvamVjdGlvbn0gZGVzdFByb2ogRGVzdGluYXRpb24gcHJvamVjdGlvbi5cbiAqIEBwYXJhbSB7ZnVuY3Rpb24oaW1wb3J0KFwiLi9jb29yZGluYXRlLmpzXCIpLkNvb3JkaW5hdGUpOiBpbXBvcnQoXCIuL2Nvb3JkaW5hdGUuanNcIikuQ29vcmRpbmF0ZX0gdHJhbnNmb3JtIFRyYW5zZm9ybSBmdW5jdGlvbiAoc291cmNlIHRvIGRlc3RpYXRpb24pLlxuICogQHJldHVybiB7ZnVuY3Rpb24oaW1wb3J0KFwiLi9jb29yZGluYXRlLmpzXCIpLkNvb3JkaW5hdGUpOiBpbXBvcnQoXCIuL2Nvb3JkaW5hdGUuanNcIikuQ29vcmRpbmF0ZX0gU2FmZSB0cmFuc2Zvcm0gZnVuY3Rpb24gKHNvdXJjZSB0byBkZXN0aWF0aW9uKS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZVNhZmVDb29yZGluYXRlVHJhbnNmb3JtKHNvdXJjZVByb2osIGRlc3RQcm9qLCB0cmFuc2Zvcm0pIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIChjb29yZCkge1xuICAgIGxldCB0cmFuc2Zvcm1lZCwgd29ybGRzQXdheTtcbiAgICBpZiAoc291cmNlUHJvai5jYW5XcmFwWCgpKSB7XG4gICAgICBjb25zdCBzb3VyY2VFeHRlbnQgPSBzb3VyY2VQcm9qLmdldEV4dGVudCgpO1xuICAgICAgY29uc3Qgc291cmNlRXh0ZW50V2lkdGggPSBnZXRXaWR0aChzb3VyY2VFeHRlbnQpO1xuICAgICAgY29vcmQgPSBjb29yZC5zbGljZSgwKTtcbiAgICAgIHdvcmxkc0F3YXkgPSBnZXRXb3JsZHNBd2F5KGNvb3JkLCBzb3VyY2VQcm9qLCBzb3VyY2VFeHRlbnRXaWR0aCk7XG4gICAgICBpZiAod29ybGRzQXdheSkge1xuICAgICAgICAvLyBNb3ZlIHggdG8gdGhlIHJlYWwgd29ybGRcbiAgICAgICAgY29vcmRbMF0gPSBjb29yZFswXSAtIHdvcmxkc0F3YXkgKiBzb3VyY2VFeHRlbnRXaWR0aDtcbiAgICAgIH1cbiAgICAgIGNvb3JkWzBdID0gY2xhbXAoY29vcmRbMF0sIHNvdXJjZUV4dGVudFswXSwgc291cmNlRXh0ZW50WzJdKTtcbiAgICAgIGNvb3JkWzFdID0gY2xhbXAoY29vcmRbMV0sIHNvdXJjZUV4dGVudFsxXSwgc291cmNlRXh0ZW50WzNdKTtcbiAgICAgIHRyYW5zZm9ybWVkID0gdHJhbnNmb3JtKGNvb3JkKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdHJhbnNmb3JtZWQgPSB0cmFuc2Zvcm0oY29vcmQpO1xuICAgIH1cbiAgICBpZiAod29ybGRzQXdheSAmJiBkZXN0UHJvai5jYW5XcmFwWCgpKSB7XG4gICAgICAvLyBNb3ZlIHRyYW5zZm9ybWVkIGNvb3JkaW5hdGUgYmFjayB0byB0aGUgb2Zmc2V0IHdvcmxkXG4gICAgICB0cmFuc2Zvcm1lZFswXSArPSB3b3JsZHNBd2F5ICogZ2V0V2lkdGgoZGVzdFByb2ouZ2V0RXh0ZW50KCkpO1xuICAgIH1cbiAgICByZXR1cm4gdHJhbnNmb3JtZWQ7XG4gIH07XG59XG5cbi8qKlxuICogQWRkIHRyYW5zZm9ybXMgdG8gYW5kIGZyb20gRVBTRzo0MzI2IGFuZCBFUFNHOjM4NTcuICBUaGlzIGZ1bmN0aW9uIGlzIGNhbGxlZFxuICogYnkgd2hlbiB0aGlzIG1vZHVsZSBpcyBleGVjdXRlZCBhbmQgc2hvdWxkIG9ubHkgbmVlZCB0byBiZSBjYWxsZWQgYWdhaW4gYWZ0ZXJcbiAqIGBjbGVhckFsbFByb2plY3Rpb25zKClgIGlzIGNhbGxlZCAoZS5nLiBpbiB0ZXN0cykuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBhZGRDb21tb24oKSB7XG4gIC8vIEFkZCB0cmFuc2Zvcm1hdGlvbnMgdGhhdCBkb24ndCBhbHRlciBjb29yZGluYXRlcyB0byBjb252ZXJ0IHdpdGhpbiBzZXQgb2ZcbiAgLy8gcHJvamVjdGlvbnMgd2l0aCBlcXVhbCBtZWFuaW5nLlxuICBhZGRFcXVpdmFsZW50UHJvamVjdGlvbnMoRVBTRzM4NTdfUFJPSkVDVElPTlMpO1xuICBhZGRFcXVpdmFsZW50UHJvamVjdGlvbnMoRVBTRzQzMjZfUFJPSkVDVElPTlMpO1xuICAvLyBBZGQgdHJhbnNmb3JtYXRpb25zIHRvIGNvbnZlcnQgRVBTRzo0MzI2IGxpa2UgY29vcmRpbmF0ZXMgdG8gRVBTRzozODU3IGxpa2VcbiAgLy8gY29vcmRpbmF0ZXMgYW5kIGJhY2suXG4gIGFkZEVxdWl2YWxlbnRUcmFuc2Zvcm1zKFxuICAgIEVQU0c0MzI2X1BST0pFQ1RJT05TLFxuICAgIEVQU0czODU3X1BST0pFQ1RJT05TLFxuICAgIGZyb21FUFNHNDMyNixcbiAgICB0b0VQU0c0MzI2XG4gICk7XG59XG5cbmFkZENvbW1vbigpO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///24121\n')}}]);