"use strict";(self["webpackChunkvue3_webpack5"]=self["webpackChunkvue3_webpack5"]||[]).push([[7476],{6357:function(__unused_webpack_module,__webpack_exports__,__webpack_require__){eval('/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "Z": function() { return /* binding */ MathArray; }\n/* harmony export */ });\n/* harmony import */ var _lib_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(14034);\nfunction _extendableBuiltin(cls) {\n  function ExtendableBuiltin() {\n    var instance = Reflect.construct(cls, Array.from(arguments));\n    Object.setPrototypeOf(instance, Object.getPrototypeOf(this));\n    return instance;\n  }\n\n  ExtendableBuiltin.prototype = Object.create(cls.prototype, {\n    constructor: {\n      value: cls,\n      enumerable: false,\n      writable: true,\n      configurable: true\n    }\n  });\n\n  if (Object.setPrototypeOf) {\n    Object.setPrototypeOf(ExtendableBuiltin, cls);\n  } else {\n    ExtendableBuiltin.__proto__ = cls;\n  }\n\n  return ExtendableBuiltin;\n}\n\n\nclass MathArray extends _extendableBuiltin(Array) {\n  clone() {\n    return new this.constructor().copy(this);\n  }\n\n  fromArray(array, offset = 0) {\n    for (let i = 0; i < this.ELEMENTS; ++i) {\n      this[i] = array[i + offset];\n    }\n\n    return this.check();\n  }\n\n  toArray(targetArray = [], offset = 0) {\n    for (let i = 0; i < this.ELEMENTS; ++i) {\n      targetArray[offset + i] = this[i];\n    }\n\n    return targetArray;\n  }\n\n  from(arrayOrObject) {\n    return Array.isArray(arrayOrObject) ? this.copy(arrayOrObject) : this.fromObject(arrayOrObject);\n  }\n\n  to(arrayOrObject) {\n    if (arrayOrObject === this) {\n      return this;\n    }\n\n    return (0,_lib_common__WEBPACK_IMPORTED_MODULE_0__/* .isArray */ .kJ)(arrayOrObject) ? this.toArray(arrayOrObject) : this.toObject(arrayOrObject);\n  }\n\n  toTarget(target) {\n    return target ? this.to(target) : this;\n  }\n\n  toFloat32Array() {\n    return new Float32Array(this);\n  }\n\n  toString() {\n    return this.formatString(_lib_common__WEBPACK_IMPORTED_MODULE_0__/* .config */ .vc);\n  }\n\n  formatString(opts) {\n    let string = \'\';\n\n    for (let i = 0; i < this.ELEMENTS; ++i) {\n      string += (i > 0 ? \', \' : \'\') + (0,_lib_common__WEBPACK_IMPORTED_MODULE_0__/* .formatValue */ .Bw)(this[i], opts);\n    }\n\n    return "".concat(opts.printTypes ? this.constructor.name : \'\', "[").concat(string, "]");\n  }\n\n  equals(array) {\n    if (!array || this.length !== array.length) {\n      return false;\n    }\n\n    for (let i = 0; i < this.ELEMENTS; ++i) {\n      if (!(0,_lib_common__WEBPACK_IMPORTED_MODULE_0__/* .equals */ .fS)(this[i], array[i])) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  exactEquals(array) {\n    if (!array || this.length !== array.length) {\n      return false;\n    }\n\n    for (let i = 0; i < this.ELEMENTS; ++i) {\n      if (this[i] !== array[i]) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  negate() {\n    for (let i = 0; i < this.ELEMENTS; ++i) {\n      this[i] = -this[i];\n    }\n\n    return this.check();\n  }\n\n  lerp(a, b, t) {\n    if (t === undefined) {\n      return this.lerp(this, a, b);\n    }\n\n    for (let i = 0; i < this.ELEMENTS; ++i) {\n      const ai = a[i];\n      this[i] = ai + t * (b[i] - ai);\n    }\n\n    return this.check();\n  }\n\n  min(vector) {\n    for (let i = 0; i < this.ELEMENTS; ++i) {\n      this[i] = Math.min(vector[i], this[i]);\n    }\n\n    return this.check();\n  }\n\n  max(vector) {\n    for (let i = 0; i < this.ELEMENTS; ++i) {\n      this[i] = Math.max(vector[i], this[i]);\n    }\n\n    return this.check();\n  }\n\n  clamp(minVector, maxVector) {\n    for (let i = 0; i < this.ELEMENTS; ++i) {\n      this[i] = Math.min(Math.max(this[i], minVector[i]), maxVector[i]);\n    }\n\n    return this.check();\n  }\n\n  add(...vectors) {\n    for (const vector of vectors) {\n      for (let i = 0; i < this.ELEMENTS; ++i) {\n        this[i] += vector[i];\n      }\n    }\n\n    return this.check();\n  }\n\n  subtract(...vectors) {\n    for (const vector of vectors) {\n      for (let i = 0; i < this.ELEMENTS; ++i) {\n        this[i] -= vector[i];\n      }\n    }\n\n    return this.check();\n  }\n\n  scale(scale) {\n    if (typeof scale === \'number\') {\n      for (let i = 0; i < this.ELEMENTS; ++i) {\n        this[i] *= scale;\n      }\n    } else {\n      for (let i = 0; i < this.ELEMENTS && i < scale.length; ++i) {\n        this[i] *= scale[i];\n      }\n    }\n\n    return this.check();\n  }\n\n  multiplyByScalar(scalar) {\n    for (let i = 0; i < this.ELEMENTS; ++i) {\n      this[i] *= scalar;\n    }\n\n    return this.check();\n  }\n\n  check() {\n    if (_lib_common__WEBPACK_IMPORTED_MODULE_0__/* .config.debug */ .vc.debug && !this.validate()) {\n      throw new Error("math.gl: ".concat(this.constructor.name, " some fields set to invalid numbers\'"));\n    }\n\n    return this;\n  }\n\n  validate() {\n    let valid = this.length === this.ELEMENTS;\n\n    for (let i = 0; i < this.ELEMENTS; ++i) {\n      valid = valid && Number.isFinite(this[i]);\n    }\n\n    return valid;\n  }\n\n  sub(a) {\n    return this.subtract(a);\n  }\n\n  setScalar(a) {\n    for (let i = 0; i < this.ELEMENTS; ++i) {\n      this[i] = a;\n    }\n\n    return this.check();\n  }\n\n  addScalar(a) {\n    for (let i = 0; i < this.ELEMENTS; ++i) {\n      this[i] += a;\n    }\n\n    return this.check();\n  }\n\n  subScalar(a) {\n    return this.addScalar(-a);\n  }\n\n  multiplyScalar(scalar) {\n    for (let i = 0; i < this.ELEMENTS; ++i) {\n      this[i] *= scalar;\n    }\n\n    return this.check();\n  }\n\n  divideScalar(a) {\n    return this.multiplyByScalar(1 / a);\n  }\n\n  clampScalar(min, max) {\n    for (let i = 0; i < this.ELEMENTS; ++i) {\n      this[i] = Math.min(Math.max(this[i], min), max);\n    }\n\n    return this.check();\n  }\n\n  get elements() {\n    return this;\n  }\n\n}\n//# sourceMappingURL=math-array.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNjM1Ny5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTs7QUFFd0U7QUFDekQ7QUFDZjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxvQkFBb0IsbUJBQW1CO0FBQ3ZDO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLG9CQUFvQixtQkFBbUI7QUFDdkM7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxXQUFXLDhEQUFPO0FBQ2xCOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw2QkFBNkIseURBQU07QUFDbkM7O0FBRUE7QUFDQTs7QUFFQSxvQkFBb0IsbUJBQW1CO0FBQ3ZDLHNDQUFzQyxrRUFBVztBQUNqRDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG9CQUFvQixtQkFBbUI7QUFDdkMsV0FBVyw2REFBTTtBQUNqQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxvQkFBb0IsbUJBQW1CO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxvQkFBb0IsbUJBQW1CO0FBQ3ZDO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxvQkFBb0IsbUJBQW1CO0FBQ3ZDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0Esb0JBQW9CLG1CQUFtQjtBQUN2QztBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxvQkFBb0IsbUJBQW1CO0FBQ3ZDO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLG9CQUFvQixtQkFBbUI7QUFDdkM7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxzQkFBc0IsbUJBQW1CO0FBQ3pDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxzQkFBc0IsbUJBQW1CO0FBQ3pDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxzQkFBc0IsbUJBQW1CO0FBQ3pDO0FBQ0E7QUFDQSxNQUFNO0FBQ04sc0JBQXNCLHVDQUF1QztBQUM3RDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLG9CQUFvQixtQkFBbUI7QUFDdkM7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsUUFBUSxxRUFBWTtBQUNwQjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxvQkFBb0IsbUJBQW1CO0FBQ3ZDO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxvQkFBb0IsbUJBQW1CO0FBQ3ZDO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLG9CQUFvQixtQkFBbUI7QUFDdkM7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG9CQUFvQixtQkFBbUI7QUFDdkM7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG9CQUFvQixtQkFBbUI7QUFDdkM7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdnVlMy13ZWJwYWNrNS8uL25vZGVfbW9kdWxlcy9AbWF0aC5nbC9jb3JlL2Rpc3QvZXNtL2NsYXNzZXMvYmFzZS9tYXRoLWFycmF5LmpzPzIxZWEiXSwic291cmNlc0NvbnRlbnQiOlsiZnVuY3Rpb24gX2V4dGVuZGFibGVCdWlsdGluKGNscykge1xuICBmdW5jdGlvbiBFeHRlbmRhYmxlQnVpbHRpbigpIHtcbiAgICB2YXIgaW5zdGFuY2UgPSBSZWZsZWN0LmNvbnN0cnVjdChjbHMsIEFycmF5LmZyb20oYXJndW1lbnRzKSk7XG4gICAgT2JqZWN0LnNldFByb3RvdHlwZU9mKGluc3RhbmNlLCBPYmplY3QuZ2V0UHJvdG90eXBlT2YodGhpcykpO1xuICAgIHJldHVybiBpbnN0YW5jZTtcbiAgfVxuXG4gIEV4dGVuZGFibGVCdWlsdGluLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoY2xzLnByb3RvdHlwZSwge1xuICAgIGNvbnN0cnVjdG9yOiB7XG4gICAgICB2YWx1ZTogY2xzLFxuICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH1cbiAgfSk7XG5cbiAgaWYgKE9iamVjdC5zZXRQcm90b3R5cGVPZikge1xuICAgIE9iamVjdC5zZXRQcm90b3R5cGVPZihFeHRlbmRhYmxlQnVpbHRpbiwgY2xzKTtcbiAgfSBlbHNlIHtcbiAgICBFeHRlbmRhYmxlQnVpbHRpbi5fX3Byb3RvX18gPSBjbHM7XG4gIH1cblxuICByZXR1cm4gRXh0ZW5kYWJsZUJ1aWx0aW47XG59XG5cbmltcG9ydCB7IGNvbmZpZywgZm9ybWF0VmFsdWUsIGVxdWFscywgaXNBcnJheSB9IGZyb20gJy4uLy4uL2xpYi9jb21tb24nO1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgTWF0aEFycmF5IGV4dGVuZHMgX2V4dGVuZGFibGVCdWlsdGluKEFycmF5KSB7XG4gIGNsb25lKCkge1xuICAgIHJldHVybiBuZXcgdGhpcy5jb25zdHJ1Y3RvcigpLmNvcHkodGhpcyk7XG4gIH1cblxuICBmcm9tQXJyYXkoYXJyYXksIG9mZnNldCA9IDApIHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuRUxFTUVOVFM7ICsraSkge1xuICAgICAgdGhpc1tpXSA9IGFycmF5W2kgKyBvZmZzZXRdO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLmNoZWNrKCk7XG4gIH1cblxuICB0b0FycmF5KHRhcmdldEFycmF5ID0gW10sIG9mZnNldCA9IDApIHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuRUxFTUVOVFM7ICsraSkge1xuICAgICAgdGFyZ2V0QXJyYXlbb2Zmc2V0ICsgaV0gPSB0aGlzW2ldO1xuICAgIH1cblxuICAgIHJldHVybiB0YXJnZXRBcnJheTtcbiAgfVxuXG4gIGZyb20oYXJyYXlPck9iamVjdCkge1xuICAgIHJldHVybiBBcnJheS5pc0FycmF5KGFycmF5T3JPYmplY3QpID8gdGhpcy5jb3B5KGFycmF5T3JPYmplY3QpIDogdGhpcy5mcm9tT2JqZWN0KGFycmF5T3JPYmplY3QpO1xuICB9XG5cbiAgdG8oYXJyYXlPck9iamVjdCkge1xuICAgIGlmIChhcnJheU9yT2JqZWN0ID09PSB0aGlzKSB7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICByZXR1cm4gaXNBcnJheShhcnJheU9yT2JqZWN0KSA/IHRoaXMudG9BcnJheShhcnJheU9yT2JqZWN0KSA6IHRoaXMudG9PYmplY3QoYXJyYXlPck9iamVjdCk7XG4gIH1cblxuICB0b1RhcmdldCh0YXJnZXQpIHtcbiAgICByZXR1cm4gdGFyZ2V0ID8gdGhpcy50byh0YXJnZXQpIDogdGhpcztcbiAgfVxuXG4gIHRvRmxvYXQzMkFycmF5KCkge1xuICAgIHJldHVybiBuZXcgRmxvYXQzMkFycmF5KHRoaXMpO1xuICB9XG5cbiAgdG9TdHJpbmcoKSB7XG4gICAgcmV0dXJuIHRoaXMuZm9ybWF0U3RyaW5nKGNvbmZpZyk7XG4gIH1cblxuICBmb3JtYXRTdHJpbmcob3B0cykge1xuICAgIGxldCBzdHJpbmcgPSAnJztcblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5FTEVNRU5UUzsgKytpKSB7XG4gICAgICBzdHJpbmcgKz0gKGkgPiAwID8gJywgJyA6ICcnKSArIGZvcm1hdFZhbHVlKHRoaXNbaV0sIG9wdHMpO1xuICAgIH1cblxuICAgIHJldHVybiBcIlwiLmNvbmNhdChvcHRzLnByaW50VHlwZXMgPyB0aGlzLmNvbnN0cnVjdG9yLm5hbWUgOiAnJywgXCJbXCIpLmNvbmNhdChzdHJpbmcsIFwiXVwiKTtcbiAgfVxuXG4gIGVxdWFscyhhcnJheSkge1xuICAgIGlmICghYXJyYXkgfHwgdGhpcy5sZW5ndGggIT09IGFycmF5Lmxlbmd0aCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5FTEVNRU5UUzsgKytpKSB7XG4gICAgICBpZiAoIWVxdWFscyh0aGlzW2ldLCBhcnJheVtpXSkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgZXhhY3RFcXVhbHMoYXJyYXkpIHtcbiAgICBpZiAoIWFycmF5IHx8IHRoaXMubGVuZ3RoICE9PSBhcnJheS5sZW5ndGgpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuRUxFTUVOVFM7ICsraSkge1xuICAgICAgaWYgKHRoaXNbaV0gIT09IGFycmF5W2ldKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIG5lZ2F0ZSgpIHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuRUxFTUVOVFM7ICsraSkge1xuICAgICAgdGhpc1tpXSA9IC10aGlzW2ldO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLmNoZWNrKCk7XG4gIH1cblxuICBsZXJwKGEsIGIsIHQpIHtcbiAgICBpZiAodCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gdGhpcy5sZXJwKHRoaXMsIGEsIGIpO1xuICAgIH1cblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5FTEVNRU5UUzsgKytpKSB7XG4gICAgICBjb25zdCBhaSA9IGFbaV07XG4gICAgICB0aGlzW2ldID0gYWkgKyB0ICogKGJbaV0gLSBhaSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuY2hlY2soKTtcbiAgfVxuXG4gIG1pbih2ZWN0b3IpIHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuRUxFTUVOVFM7ICsraSkge1xuICAgICAgdGhpc1tpXSA9IE1hdGgubWluKHZlY3RvcltpXSwgdGhpc1tpXSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuY2hlY2soKTtcbiAgfVxuXG4gIG1heCh2ZWN0b3IpIHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuRUxFTUVOVFM7ICsraSkge1xuICAgICAgdGhpc1tpXSA9IE1hdGgubWF4KHZlY3RvcltpXSwgdGhpc1tpXSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuY2hlY2soKTtcbiAgfVxuXG4gIGNsYW1wKG1pblZlY3RvciwgbWF4VmVjdG9yKSB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLkVMRU1FTlRTOyArK2kpIHtcbiAgICAgIHRoaXNbaV0gPSBNYXRoLm1pbihNYXRoLm1heCh0aGlzW2ldLCBtaW5WZWN0b3JbaV0pLCBtYXhWZWN0b3JbaV0pO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLmNoZWNrKCk7XG4gIH1cblxuICBhZGQoLi4udmVjdG9ycykge1xuICAgIGZvciAoY29uc3QgdmVjdG9yIG9mIHZlY3RvcnMpIHtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5FTEVNRU5UUzsgKytpKSB7XG4gICAgICAgIHRoaXNbaV0gKz0gdmVjdG9yW2ldO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0aGlzLmNoZWNrKCk7XG4gIH1cblxuICBzdWJ0cmFjdCguLi52ZWN0b3JzKSB7XG4gICAgZm9yIChjb25zdCB2ZWN0b3Igb2YgdmVjdG9ycykge1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLkVMRU1FTlRTOyArK2kpIHtcbiAgICAgICAgdGhpc1tpXSAtPSB2ZWN0b3JbaV07XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuY2hlY2soKTtcbiAgfVxuXG4gIHNjYWxlKHNjYWxlKSB7XG4gICAgaWYgKHR5cGVvZiBzY2FsZSA9PT0gJ251bWJlcicpIHtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5FTEVNRU5UUzsgKytpKSB7XG4gICAgICAgIHRoaXNbaV0gKj0gc2NhbGU7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5FTEVNRU5UUyAmJiBpIDwgc2NhbGUubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgdGhpc1tpXSAqPSBzY2FsZVtpXTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5jaGVjaygpO1xuICB9XG5cbiAgbXVsdGlwbHlCeVNjYWxhcihzY2FsYXIpIHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuRUxFTUVOVFM7ICsraSkge1xuICAgICAgdGhpc1tpXSAqPSBzY2FsYXI7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuY2hlY2soKTtcbiAgfVxuXG4gIGNoZWNrKCkge1xuICAgIGlmIChjb25maWcuZGVidWcgJiYgIXRoaXMudmFsaWRhdGUoKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwibWF0aC5nbDogXCIuY29uY2F0KHRoaXMuY29uc3RydWN0b3IubmFtZSwgXCIgc29tZSBmaWVsZHMgc2V0IHRvIGludmFsaWQgbnVtYmVycydcIikpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgdmFsaWRhdGUoKSB7XG4gICAgbGV0IHZhbGlkID0gdGhpcy5sZW5ndGggPT09IHRoaXMuRUxFTUVOVFM7XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuRUxFTUVOVFM7ICsraSkge1xuICAgICAgdmFsaWQgPSB2YWxpZCAmJiBOdW1iZXIuaXNGaW5pdGUodGhpc1tpXSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHZhbGlkO1xuICB9XG5cbiAgc3ViKGEpIHtcbiAgICByZXR1cm4gdGhpcy5zdWJ0cmFjdChhKTtcbiAgfVxuXG4gIHNldFNjYWxhcihhKSB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLkVMRU1FTlRTOyArK2kpIHtcbiAgICAgIHRoaXNbaV0gPSBhO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLmNoZWNrKCk7XG4gIH1cblxuICBhZGRTY2FsYXIoYSkge1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5FTEVNRU5UUzsgKytpKSB7XG4gICAgICB0aGlzW2ldICs9IGE7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuY2hlY2soKTtcbiAgfVxuXG4gIHN1YlNjYWxhcihhKSB7XG4gICAgcmV0dXJuIHRoaXMuYWRkU2NhbGFyKC1hKTtcbiAgfVxuXG4gIG11bHRpcGx5U2NhbGFyKHNjYWxhcikge1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5FTEVNRU5UUzsgKytpKSB7XG4gICAgICB0aGlzW2ldICo9IHNjYWxhcjtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5jaGVjaygpO1xuICB9XG5cbiAgZGl2aWRlU2NhbGFyKGEpIHtcbiAgICByZXR1cm4gdGhpcy5tdWx0aXBseUJ5U2NhbGFyKDEgLyBhKTtcbiAgfVxuXG4gIGNsYW1wU2NhbGFyKG1pbiwgbWF4KSB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLkVMRU1FTlRTOyArK2kpIHtcbiAgICAgIHRoaXNbaV0gPSBNYXRoLm1pbihNYXRoLm1heCh0aGlzW2ldLCBtaW4pLCBtYXgpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLmNoZWNrKCk7XG4gIH1cblxuICBnZXQgZWxlbWVudHMoKSB7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bWF0aC1hcnJheS5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///6357\n')},61e3:function(__unused_webpack_module,__webpack_exports__,__webpack_require__){eval("/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Z\": function() { return /* binding */ Matrix; }\n/* harmony export */ });\n/* harmony import */ var _math_array__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(6357);\n/* harmony import */ var _lib_validators__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(86281);\n/* harmony import */ var _lib_common__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(14034);\n\n\n\nclass Matrix extends _math_array__WEBPACK_IMPORTED_MODULE_0__/* [\"default\"] */ .Z {\n  toString() {\n    let string = '[';\n\n    if (_lib_common__WEBPACK_IMPORTED_MODULE_1__/* .config.printRowMajor */ .vc.printRowMajor) {\n      string += 'row-major:';\n\n      for (let row = 0; row < this.RANK; ++row) {\n        for (let col = 0; col < this.RANK; ++col) {\n          string += \" \".concat(this[col * this.RANK + row]);\n        }\n      }\n    } else {\n      string += 'column-major:';\n\n      for (let i = 0; i < this.ELEMENTS; ++i) {\n        string += \" \".concat(this[i]);\n      }\n    }\n\n    string += ']';\n    return string;\n  }\n\n  getElementIndex(row, col) {\n    return col * this.RANK + row;\n  }\n\n  getElement(row, col) {\n    return this[col * this.RANK + row];\n  }\n\n  setElement(row, col, value) {\n    this[col * this.RANK + row] = (0,_lib_validators__WEBPACK_IMPORTED_MODULE_2__/* .checkNumber */ .u5)(value);\n    return this;\n  }\n\n  getColumn(columnIndex, result = new Array(this.RANK).fill(-0)) {\n    const firstIndex = columnIndex * this.RANK;\n\n    for (let i = 0; i < this.RANK; ++i) {\n      result[i] = this[firstIndex + i];\n    }\n\n    return result;\n  }\n\n  setColumn(columnIndex, columnVector) {\n    const firstIndex = columnIndex * this.RANK;\n\n    for (let i = 0; i < this.RANK; ++i) {\n      this[firstIndex + i] = columnVector[i];\n    }\n\n    return this;\n  }\n\n}\n//# sourceMappingURL=matrix.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNjEwMDAuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQXFDO0FBQ2M7QUFDVDtBQUMzQixxQkFBcUIsNERBQVM7QUFDN0M7QUFDQTs7QUFFQSxRQUFRLHFGQUFvQjtBQUM1Qjs7QUFFQSx3QkFBd0IsaUJBQWlCO0FBQ3pDLDBCQUEwQixpQkFBaUI7QUFDM0M7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOOztBQUVBLHNCQUFzQixtQkFBbUI7QUFDekM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0Esa0NBQWtDLHNFQUFXO0FBQzdDO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxvQkFBb0IsZUFBZTtBQUNuQztBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxvQkFBb0IsZUFBZTtBQUNuQztBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3Z1ZTMtd2VicGFjazUvLi9ub2RlX21vZHVsZXMvQG1hdGguZ2wvY29yZS9kaXN0L2VzbS9jbGFzc2VzL2Jhc2UvbWF0cml4LmpzPzJiZTYiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IE1hdGhBcnJheSBmcm9tICcuL21hdGgtYXJyYXknO1xuaW1wb3J0IHsgY2hlY2tOdW1iZXIgfSBmcm9tICcuLi8uLi9saWIvdmFsaWRhdG9ycyc7XG5pbXBvcnQgeyBjb25maWcgfSBmcm9tICcuLi8uLi9saWIvY29tbW9uJztcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIE1hdHJpeCBleHRlbmRzIE1hdGhBcnJheSB7XG4gIHRvU3RyaW5nKCkge1xuICAgIGxldCBzdHJpbmcgPSAnWyc7XG5cbiAgICBpZiAoY29uZmlnLnByaW50Um93TWFqb3IpIHtcbiAgICAgIHN0cmluZyArPSAncm93LW1ham9yOic7XG5cbiAgICAgIGZvciAobGV0IHJvdyA9IDA7IHJvdyA8IHRoaXMuUkFOSzsgKytyb3cpIHtcbiAgICAgICAgZm9yIChsZXQgY29sID0gMDsgY29sIDwgdGhpcy5SQU5LOyArK2NvbCkge1xuICAgICAgICAgIHN0cmluZyArPSBcIiBcIi5jb25jYXQodGhpc1tjb2wgKiB0aGlzLlJBTksgKyByb3ddKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBzdHJpbmcgKz0gJ2NvbHVtbi1tYWpvcjonO1xuXG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuRUxFTUVOVFM7ICsraSkge1xuICAgICAgICBzdHJpbmcgKz0gXCIgXCIuY29uY2F0KHRoaXNbaV0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIHN0cmluZyArPSAnXSc7XG4gICAgcmV0dXJuIHN0cmluZztcbiAgfVxuXG4gIGdldEVsZW1lbnRJbmRleChyb3csIGNvbCkge1xuICAgIHJldHVybiBjb2wgKiB0aGlzLlJBTksgKyByb3c7XG4gIH1cblxuICBnZXRFbGVtZW50KHJvdywgY29sKSB7XG4gICAgcmV0dXJuIHRoaXNbY29sICogdGhpcy5SQU5LICsgcm93XTtcbiAgfVxuXG4gIHNldEVsZW1lbnQocm93LCBjb2wsIHZhbHVlKSB7XG4gICAgdGhpc1tjb2wgKiB0aGlzLlJBTksgKyByb3ddID0gY2hlY2tOdW1iZXIodmFsdWUpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgZ2V0Q29sdW1uKGNvbHVtbkluZGV4LCByZXN1bHQgPSBuZXcgQXJyYXkodGhpcy5SQU5LKS5maWxsKC0wKSkge1xuICAgIGNvbnN0IGZpcnN0SW5kZXggPSBjb2x1bW5JbmRleCAqIHRoaXMuUkFOSztcblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5SQU5LOyArK2kpIHtcbiAgICAgIHJlc3VsdFtpXSA9IHRoaXNbZmlyc3RJbmRleCArIGldO1xuICAgIH1cblxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICBzZXRDb2x1bW4oY29sdW1uSW5kZXgsIGNvbHVtblZlY3Rvcikge1xuICAgIGNvbnN0IGZpcnN0SW5kZXggPSBjb2x1bW5JbmRleCAqIHRoaXMuUkFOSztcblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5SQU5LOyArK2kpIHtcbiAgICAgIHRoaXNbZmlyc3RJbmRleCArIGldID0gY29sdW1uVmVjdG9yW2ldO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW1hdHJpeC5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///61000\n")},89521:function(__unused_webpack_module,__webpack_exports__,__webpack_require__){eval('/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "Z": function() { return /* binding */ Vector; }\n/* harmony export */ });\n/* harmony import */ var _math_array__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(6357);\n/* harmony import */ var _lib_validators__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(86281);\n/* harmony import */ var _lib_assert__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(50394);\n\n\n\nclass Vector extends _math_array__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .Z {\n  get x() {\n    return this[0];\n  }\n\n  set x(value) {\n    this[0] = (0,_lib_validators__WEBPACK_IMPORTED_MODULE_1__/* .checkNumber */ .u5)(value);\n  }\n\n  get y() {\n    return this[1];\n  }\n\n  set y(value) {\n    this[1] = (0,_lib_validators__WEBPACK_IMPORTED_MODULE_1__/* .checkNumber */ .u5)(value);\n  }\n\n  len() {\n    return Math.sqrt(this.lengthSquared());\n  }\n\n  magnitude() {\n    return this.len();\n  }\n\n  lengthSquared() {\n    let length = 0;\n\n    for (let i = 0; i < this.ELEMENTS; ++i) {\n      length += this[i] * this[i];\n    }\n\n    return length;\n  }\n\n  magnitudeSquared() {\n    return this.lengthSquared();\n  }\n\n  distance(mathArray) {\n    return Math.sqrt(this.distanceSquared(mathArray));\n  }\n\n  distanceSquared(mathArray) {\n    let length = 0;\n\n    for (let i = 0; i < this.ELEMENTS; ++i) {\n      const dist = this[i] - mathArray[i];\n      length += dist * dist;\n    }\n\n    return (0,_lib_validators__WEBPACK_IMPORTED_MODULE_1__/* .checkNumber */ .u5)(length);\n  }\n\n  dot(mathArray) {\n    let product = 0;\n\n    for (let i = 0; i < this.ELEMENTS; ++i) {\n      product += this[i] * mathArray[i];\n    }\n\n    return (0,_lib_validators__WEBPACK_IMPORTED_MODULE_1__/* .checkNumber */ .u5)(product);\n  }\n\n  normalize() {\n    const length = this.magnitude();\n\n    if (length !== 0) {\n      for (let i = 0; i < this.ELEMENTS; ++i) {\n        this[i] /= length;\n      }\n    }\n\n    return this.check();\n  }\n\n  multiply(...vectors) {\n    for (const vector of vectors) {\n      for (let i = 0; i < this.ELEMENTS; ++i) {\n        this[i] *= vector[i];\n      }\n    }\n\n    return this.check();\n  }\n\n  divide(...vectors) {\n    for (const vector of vectors) {\n      for (let i = 0; i < this.ELEMENTS; ++i) {\n        this[i] /= vector[i];\n      }\n    }\n\n    return this.check();\n  }\n\n  lengthSq() {\n    return this.lengthSquared();\n  }\n\n  distanceTo(vector) {\n    return this.distance(vector);\n  }\n\n  distanceToSquared(vector) {\n    return this.distanceSquared(vector);\n  }\n\n  getComponent(i) {\n    (0,_lib_assert__WEBPACK_IMPORTED_MODULE_2__/* ["default"] */ .Z)(i >= 0 && i < this.ELEMENTS, \'index is out of range\');\n    return (0,_lib_validators__WEBPACK_IMPORTED_MODULE_1__/* .checkNumber */ .u5)(this[i]);\n  }\n\n  setComponent(i, value) {\n    (0,_lib_assert__WEBPACK_IMPORTED_MODULE_2__/* ["default"] */ .Z)(i >= 0 && i < this.ELEMENTS, \'index is out of range\');\n    this[i] = value;\n    return this.check();\n  }\n\n  addVectors(a, b) {\n    return this.copy(a).add(b);\n  }\n\n  subVectors(a, b) {\n    return this.copy(a).subtract(b);\n  }\n\n  multiplyVectors(a, b) {\n    return this.copy(a).multiply(b);\n  }\n\n  addScaledVector(a, b) {\n    return this.add(new this.constructor(a).multiplyScalar(b));\n  }\n\n}\n//# sourceMappingURL=vector.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiODk1MjEuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQXFDO0FBQ2M7QUFDYjtBQUN2QixxQkFBcUIsNERBQVM7QUFDN0M7QUFDQTtBQUNBOztBQUVBO0FBQ0EsY0FBYyxzRUFBVztBQUN6Qjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxjQUFjLHNFQUFXO0FBQ3pCOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxvQkFBb0IsbUJBQW1CO0FBQ3ZDO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsb0JBQW9CLG1CQUFtQjtBQUN2QztBQUNBO0FBQ0E7O0FBRUEsV0FBVyxzRUFBVztBQUN0Qjs7QUFFQTtBQUNBOztBQUVBLG9CQUFvQixtQkFBbUI7QUFDdkM7QUFDQTs7QUFFQSxXQUFXLHNFQUFXO0FBQ3RCOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxzQkFBc0IsbUJBQW1CO0FBQ3pDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxzQkFBc0IsbUJBQW1CO0FBQ3pDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxzQkFBc0IsbUJBQW1CO0FBQ3pDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsSUFBSSxnRUFBTTtBQUNWLFdBQVcsc0VBQVc7QUFDdEI7O0FBRUE7QUFDQSxJQUFJLGdFQUFNO0FBQ1Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdnVlMy13ZWJwYWNrNS8uL25vZGVfbW9kdWxlcy9AbWF0aC5nbC9jb3JlL2Rpc3QvZXNtL2NsYXNzZXMvYmFzZS92ZWN0b3IuanM/MTQxNCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgTWF0aEFycmF5IGZyb20gJy4vbWF0aC1hcnJheSc7XG5pbXBvcnQgeyBjaGVja051bWJlciB9IGZyb20gJy4uLy4uL2xpYi92YWxpZGF0b3JzJztcbmltcG9ydCBhc3NlcnQgZnJvbSAnLi4vLi4vbGliL2Fzc2VydCc7XG5leHBvcnQgZGVmYXVsdCBjbGFzcyBWZWN0b3IgZXh0ZW5kcyBNYXRoQXJyYXkge1xuICBnZXQgeCgpIHtcbiAgICByZXR1cm4gdGhpc1swXTtcbiAgfVxuXG4gIHNldCB4KHZhbHVlKSB7XG4gICAgdGhpc1swXSA9IGNoZWNrTnVtYmVyKHZhbHVlKTtcbiAgfVxuXG4gIGdldCB5KCkge1xuICAgIHJldHVybiB0aGlzWzFdO1xuICB9XG5cbiAgc2V0IHkodmFsdWUpIHtcbiAgICB0aGlzWzFdID0gY2hlY2tOdW1iZXIodmFsdWUpO1xuICB9XG5cbiAgbGVuKCkge1xuICAgIHJldHVybiBNYXRoLnNxcnQodGhpcy5sZW5ndGhTcXVhcmVkKCkpO1xuICB9XG5cbiAgbWFnbml0dWRlKCkge1xuICAgIHJldHVybiB0aGlzLmxlbigpO1xuICB9XG5cbiAgbGVuZ3RoU3F1YXJlZCgpIHtcbiAgICBsZXQgbGVuZ3RoID0gMDtcblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5FTEVNRU5UUzsgKytpKSB7XG4gICAgICBsZW5ndGggKz0gdGhpc1tpXSAqIHRoaXNbaV07XG4gICAgfVxuXG4gICAgcmV0dXJuIGxlbmd0aDtcbiAgfVxuXG4gIG1hZ25pdHVkZVNxdWFyZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMubGVuZ3RoU3F1YXJlZCgpO1xuICB9XG5cbiAgZGlzdGFuY2UobWF0aEFycmF5KSB7XG4gICAgcmV0dXJuIE1hdGguc3FydCh0aGlzLmRpc3RhbmNlU3F1YXJlZChtYXRoQXJyYXkpKTtcbiAgfVxuXG4gIGRpc3RhbmNlU3F1YXJlZChtYXRoQXJyYXkpIHtcbiAgICBsZXQgbGVuZ3RoID0gMDtcblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5FTEVNRU5UUzsgKytpKSB7XG4gICAgICBjb25zdCBkaXN0ID0gdGhpc1tpXSAtIG1hdGhBcnJheVtpXTtcbiAgICAgIGxlbmd0aCArPSBkaXN0ICogZGlzdDtcbiAgICB9XG5cbiAgICByZXR1cm4gY2hlY2tOdW1iZXIobGVuZ3RoKTtcbiAgfVxuXG4gIGRvdChtYXRoQXJyYXkpIHtcbiAgICBsZXQgcHJvZHVjdCA9IDA7XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuRUxFTUVOVFM7ICsraSkge1xuICAgICAgcHJvZHVjdCArPSB0aGlzW2ldICogbWF0aEFycmF5W2ldO1xuICAgIH1cblxuICAgIHJldHVybiBjaGVja051bWJlcihwcm9kdWN0KTtcbiAgfVxuXG4gIG5vcm1hbGl6ZSgpIHtcbiAgICBjb25zdCBsZW5ndGggPSB0aGlzLm1hZ25pdHVkZSgpO1xuXG4gICAgaWYgKGxlbmd0aCAhPT0gMCkge1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLkVMRU1FTlRTOyArK2kpIHtcbiAgICAgICAgdGhpc1tpXSAvPSBsZW5ndGg7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuY2hlY2soKTtcbiAgfVxuXG4gIG11bHRpcGx5KC4uLnZlY3RvcnMpIHtcbiAgICBmb3IgKGNvbnN0IHZlY3RvciBvZiB2ZWN0b3JzKSB7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuRUxFTUVOVFM7ICsraSkge1xuICAgICAgICB0aGlzW2ldICo9IHZlY3RvcltpXTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5jaGVjaygpO1xuICB9XG5cbiAgZGl2aWRlKC4uLnZlY3RvcnMpIHtcbiAgICBmb3IgKGNvbnN0IHZlY3RvciBvZiB2ZWN0b3JzKSB7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuRUxFTUVOVFM7ICsraSkge1xuICAgICAgICB0aGlzW2ldIC89IHZlY3RvcltpXTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5jaGVjaygpO1xuICB9XG5cbiAgbGVuZ3RoU3EoKSB7XG4gICAgcmV0dXJuIHRoaXMubGVuZ3RoU3F1YXJlZCgpO1xuICB9XG5cbiAgZGlzdGFuY2VUbyh2ZWN0b3IpIHtcbiAgICByZXR1cm4gdGhpcy5kaXN0YW5jZSh2ZWN0b3IpO1xuICB9XG5cbiAgZGlzdGFuY2VUb1NxdWFyZWQodmVjdG9yKSB7XG4gICAgcmV0dXJuIHRoaXMuZGlzdGFuY2VTcXVhcmVkKHZlY3Rvcik7XG4gIH1cblxuICBnZXRDb21wb25lbnQoaSkge1xuICAgIGFzc2VydChpID49IDAgJiYgaSA8IHRoaXMuRUxFTUVOVFMsICdpbmRleCBpcyBvdXQgb2YgcmFuZ2UnKTtcbiAgICByZXR1cm4gY2hlY2tOdW1iZXIodGhpc1tpXSk7XG4gIH1cblxuICBzZXRDb21wb25lbnQoaSwgdmFsdWUpIHtcbiAgICBhc3NlcnQoaSA+PSAwICYmIGkgPCB0aGlzLkVMRU1FTlRTLCAnaW5kZXggaXMgb3V0IG9mIHJhbmdlJyk7XG4gICAgdGhpc1tpXSA9IHZhbHVlO1xuICAgIHJldHVybiB0aGlzLmNoZWNrKCk7XG4gIH1cblxuICBhZGRWZWN0b3JzKGEsIGIpIHtcbiAgICByZXR1cm4gdGhpcy5jb3B5KGEpLmFkZChiKTtcbiAgfVxuXG4gIHN1YlZlY3RvcnMoYSwgYikge1xuICAgIHJldHVybiB0aGlzLmNvcHkoYSkuc3VidHJhY3QoYik7XG4gIH1cblxuICBtdWx0aXBseVZlY3RvcnMoYSwgYikge1xuICAgIHJldHVybiB0aGlzLmNvcHkoYSkubXVsdGlwbHkoYik7XG4gIH1cblxuICBhZGRTY2FsZWRWZWN0b3IoYSwgYikge1xuICAgIHJldHVybiB0aGlzLmFkZChuZXcgdGhpcy5jb25zdHJ1Y3RvcihhKS5tdWx0aXBseVNjYWxhcihiKSk7XG4gIH1cblxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dmVjdG9yLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///89521\n')},80540:function(__unused_webpack_module,__webpack_exports__,__webpack_require__){eval('/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "Z": function() { return /* binding */ Matrix3; }\n/* harmony export */ });\n/* harmony import */ var _base_matrix__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(61000);\n/* harmony import */ var _lib_validators__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(86281);\n/* harmony import */ var _lib_gl_matrix_extras__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(1031);\n/* harmony import */ var gl_matrix_mat3__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(35600);\n/* harmony import */ var gl_matrix_vec2__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(31437);\n/* harmony import */ var gl_matrix_vec3__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(77160);\n\n\n\n\n\n\nvar INDICES;\n\n(function (INDICES) {\n  INDICES[INDICES["COL0ROW0"] = 0] = "COL0ROW0";\n  INDICES[INDICES["COL0ROW1"] = 1] = "COL0ROW1";\n  INDICES[INDICES["COL0ROW2"] = 2] = "COL0ROW2";\n  INDICES[INDICES["COL1ROW0"] = 3] = "COL1ROW0";\n  INDICES[INDICES["COL1ROW1"] = 4] = "COL1ROW1";\n  INDICES[INDICES["COL1ROW2"] = 5] = "COL1ROW2";\n  INDICES[INDICES["COL2ROW0"] = 6] = "COL2ROW0";\n  INDICES[INDICES["COL2ROW1"] = 7] = "COL2ROW1";\n  INDICES[INDICES["COL2ROW2"] = 8] = "COL2ROW2";\n})(INDICES || (INDICES = {}));\n\nconst IDENTITY_MATRIX = Object.freeze([1, 0, 0, 0, 1, 0, 0, 0, 1]);\nclass Matrix3 extends _base_matrix__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .Z {\n  static get IDENTITY() {\n    return getIdentityMatrix();\n  }\n\n  static get ZERO() {\n    return getZeroMatrix();\n  }\n\n  get ELEMENTS() {\n    return 9;\n  }\n\n  get RANK() {\n    return 3;\n  }\n\n  get INDICES() {\n    return INDICES;\n  }\n\n  constructor(array, ...args) {\n    super(-0, -0, -0, -0, -0, -0, -0, -0, -0);\n\n    if (arguments.length === 1 && Array.isArray(array)) {\n      this.copy(array);\n    } else if (args.length > 0) {\n      this.copy([array, ...args]);\n    } else {\n      this.identity();\n    }\n  }\n\n  copy(array) {\n    this[0] = array[0];\n    this[1] = array[1];\n    this[2] = array[2];\n    this[3] = array[3];\n    this[4] = array[4];\n    this[5] = array[5];\n    this[6] = array[6];\n    this[7] = array[7];\n    this[8] = array[8];\n    return this.check();\n  }\n\n  identity() {\n    return this.copy(IDENTITY_MATRIX);\n  }\n\n  fromObject(object) {\n    return this.check();\n  }\n\n  fromQuaternion(q) {\n    gl_matrix_mat3__WEBPACK_IMPORTED_MODULE_1__/* .fromQuat */ .en(this, q);\n    return this.check();\n  }\n\n  set(m00, m10, m20, m01, m11, m21, m02, m12, m22) {\n    this[0] = m00;\n    this[1] = m10;\n    this[2] = m20;\n    this[3] = m01;\n    this[4] = m11;\n    this[5] = m21;\n    this[6] = m02;\n    this[7] = m12;\n    this[8] = m22;\n    return this.check();\n  }\n\n  setRowMajor(m00, m01, m02, m10, m11, m12, m20, m21, m22) {\n    this[0] = m00;\n    this[1] = m10;\n    this[2] = m20;\n    this[3] = m01;\n    this[4] = m11;\n    this[5] = m21;\n    this[6] = m02;\n    this[7] = m12;\n    this[8] = m22;\n    return this.check();\n  }\n\n  determinant() {\n    return gl_matrix_mat3__WEBPACK_IMPORTED_MODULE_1__/* .determinant */ .GH(this);\n  }\n\n  transpose() {\n    gl_matrix_mat3__WEBPACK_IMPORTED_MODULE_1__/* .transpose */ .p4(this, this);\n    return this.check();\n  }\n\n  invert() {\n    gl_matrix_mat3__WEBPACK_IMPORTED_MODULE_1__/* .invert */ .U_(this, this);\n    return this.check();\n  }\n\n  multiplyLeft(a) {\n    gl_matrix_mat3__WEBPACK_IMPORTED_MODULE_1__/* .multiply */ .Jp(this, a, this);\n    return this.check();\n  }\n\n  multiplyRight(a) {\n    gl_matrix_mat3__WEBPACK_IMPORTED_MODULE_1__/* .multiply */ .Jp(this, this, a);\n    return this.check();\n  }\n\n  rotate(radians) {\n    gl_matrix_mat3__WEBPACK_IMPORTED_MODULE_1__/* .rotate */ .U1(this, this, radians);\n    return this.check();\n  }\n\n  scale(factor) {\n    if (Array.isArray(factor)) {\n      gl_matrix_mat3__WEBPACK_IMPORTED_MODULE_1__/* .scale */ .bA(this, this, factor);\n    } else {\n      gl_matrix_mat3__WEBPACK_IMPORTED_MODULE_1__/* .scale */ .bA(this, this, [factor, factor]);\n    }\n\n    return this.check();\n  }\n\n  translate(vec) {\n    gl_matrix_mat3__WEBPACK_IMPORTED_MODULE_1__/* .translate */ .Iu(this, this, vec);\n    return this.check();\n  }\n\n  transform(vector, result) {\n    let out;\n\n    switch (vector.length) {\n      case 2:\n        out = gl_matrix_vec2__WEBPACK_IMPORTED_MODULE_2__/* .transformMat3 */ .kK(result || [-0, -0], vector, this);\n        break;\n\n      case 3:\n        out = gl_matrix_vec3__WEBPACK_IMPORTED_MODULE_3__/* .transformMat3 */ .kK(result || [-0, -0, -0], vector, this);\n        break;\n\n      case 4:\n        out = (0,_lib_gl_matrix_extras__WEBPACK_IMPORTED_MODULE_4__/* .vec4_transformMat3 */ ._x)(result || [-0, -0, -0, -0], vector, this);\n        break;\n\n      default:\n        throw new Error(\'Illegal vector\');\n    }\n\n    (0,_lib_validators__WEBPACK_IMPORTED_MODULE_5__/* .checkVector */ .IL)(out, vector.length);\n    return out;\n  }\n\n  transformVector(vector, result) {\n    return this.transform(vector, result);\n  }\n\n  transformVector2(vector, result) {\n    return this.transform(vector, result);\n  }\n\n  transformVector3(vector, result) {\n    return this.transform(vector, result);\n  }\n\n}\nlet ZERO_MATRIX3;\nlet IDENTITY_MATRIX3;\n\nfunction getZeroMatrix() {\n  if (!ZERO_MATRIX3) {\n    ZERO_MATRIX3 = new Matrix3([0, 0, 0, 0, 0, 0, 0, 0, 0]);\n    Object.freeze(ZERO_MATRIX3);\n  }\n\n  return ZERO_MATRIX3;\n}\n\nfunction getIdentityMatrix() {\n  if (!IDENTITY_MATRIX3) {\n    IDENTITY_MATRIX3 = new Matrix3();\n    Object.freeze(IDENTITY_MATRIX3);\n  }\n\n  return IDENTITY_MATRIX3;\n}\n//# sourceMappingURL=matrix3.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiODA1NDAuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBQW1DO0FBQ2E7QUFDYTtBQUN0QjtBQUNBO0FBQ0E7QUFDdkM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLDBCQUEwQjs7QUFFM0I7QUFDZSxzQkFBc0IsNkRBQU07QUFDM0M7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsSUFBSSw4REFBYTtBQUNqQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxXQUFXLGlFQUFnQjtBQUMzQjs7QUFFQTtBQUNBLElBQUksK0RBQWM7QUFDbEI7QUFDQTs7QUFFQTtBQUNBLElBQUksNERBQVc7QUFDZjtBQUNBOztBQUVBO0FBQ0EsSUFBSSw4REFBYTtBQUNqQjtBQUNBOztBQUVBO0FBQ0EsSUFBSSw4REFBYTtBQUNqQjtBQUNBOztBQUVBO0FBQ0EsSUFBSSw0REFBVztBQUNmO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU0sMkRBQVU7QUFDaEIsTUFBTTtBQUNOLE1BQU0sMkRBQVU7QUFDaEI7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLElBQUksK0RBQWM7QUFDbEI7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxjQUFjLG1FQUFrQjtBQUNoQzs7QUFFQTtBQUNBLGNBQWMsbUVBQWtCO0FBQ2hDOztBQUVBO0FBQ0EsY0FBYyxtRkFBa0I7QUFDaEM7O0FBRUE7QUFDQTtBQUNBOztBQUVBLElBQUksc0VBQVc7QUFDZjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly92dWUzLXdlYnBhY2s1Ly4vbm9kZV9tb2R1bGVzL0BtYXRoLmdsL2NvcmUvZGlzdC9lc20vY2xhc3Nlcy9tYXRyaXgzLmpzPzdmNGQiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IE1hdHJpeCBmcm9tICcuL2Jhc2UvbWF0cml4JztcbmltcG9ydCB7IGNoZWNrVmVjdG9yIH0gZnJvbSAnLi4vbGliL3ZhbGlkYXRvcnMnO1xuaW1wb3J0IHsgdmVjNF90cmFuc2Zvcm1NYXQzIH0gZnJvbSAnLi4vbGliL2dsLW1hdHJpeC1leHRyYXMnO1xuaW1wb3J0ICogYXMgbWF0MyBmcm9tICdnbC1tYXRyaXgvbWF0Myc7XG5pbXBvcnQgKiBhcyB2ZWMyIGZyb20gJ2dsLW1hdHJpeC92ZWMyJztcbmltcG9ydCAqIGFzIHZlYzMgZnJvbSAnZ2wtbWF0cml4L3ZlYzMnO1xudmFyIElORElDRVM7XG5cbihmdW5jdGlvbiAoSU5ESUNFUykge1xuICBJTkRJQ0VTW0lORElDRVNbXCJDT0wwUk9XMFwiXSA9IDBdID0gXCJDT0wwUk9XMFwiO1xuICBJTkRJQ0VTW0lORElDRVNbXCJDT0wwUk9XMVwiXSA9IDFdID0gXCJDT0wwUk9XMVwiO1xuICBJTkRJQ0VTW0lORElDRVNbXCJDT0wwUk9XMlwiXSA9IDJdID0gXCJDT0wwUk9XMlwiO1xuICBJTkRJQ0VTW0lORElDRVNbXCJDT0wxUk9XMFwiXSA9IDNdID0gXCJDT0wxUk9XMFwiO1xuICBJTkRJQ0VTW0lORElDRVNbXCJDT0wxUk9XMVwiXSA9IDRdID0gXCJDT0wxUk9XMVwiO1xuICBJTkRJQ0VTW0lORElDRVNbXCJDT0wxUk9XMlwiXSA9IDVdID0gXCJDT0wxUk9XMlwiO1xuICBJTkRJQ0VTW0lORElDRVNbXCJDT0wyUk9XMFwiXSA9IDZdID0gXCJDT0wyUk9XMFwiO1xuICBJTkRJQ0VTW0lORElDRVNbXCJDT0wyUk9XMVwiXSA9IDddID0gXCJDT0wyUk9XMVwiO1xuICBJTkRJQ0VTW0lORElDRVNbXCJDT0wyUk9XMlwiXSA9IDhdID0gXCJDT0wyUk9XMlwiO1xufSkoSU5ESUNFUyB8fCAoSU5ESUNFUyA9IHt9KSk7XG5cbmNvbnN0IElERU5USVRZX01BVFJJWCA9IE9iamVjdC5mcmVlemUoWzEsIDAsIDAsIDAsIDEsIDAsIDAsIDAsIDFdKTtcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIE1hdHJpeDMgZXh0ZW5kcyBNYXRyaXgge1xuICBzdGF0aWMgZ2V0IElERU5USVRZKCkge1xuICAgIHJldHVybiBnZXRJZGVudGl0eU1hdHJpeCgpO1xuICB9XG5cbiAgc3RhdGljIGdldCBaRVJPKCkge1xuICAgIHJldHVybiBnZXRaZXJvTWF0cml4KCk7XG4gIH1cblxuICBnZXQgRUxFTUVOVFMoKSB7XG4gICAgcmV0dXJuIDk7XG4gIH1cblxuICBnZXQgUkFOSygpIHtcbiAgICByZXR1cm4gMztcbiAgfVxuXG4gIGdldCBJTkRJQ0VTKCkge1xuICAgIHJldHVybiBJTkRJQ0VTO1xuICB9XG5cbiAgY29uc3RydWN0b3IoYXJyYXksIC4uLmFyZ3MpIHtcbiAgICBzdXBlcigtMCwgLTAsIC0wLCAtMCwgLTAsIC0wLCAtMCwgLTAsIC0wKTtcblxuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxICYmIEFycmF5LmlzQXJyYXkoYXJyYXkpKSB7XG4gICAgICB0aGlzLmNvcHkoYXJyYXkpO1xuICAgIH0gZWxzZSBpZiAoYXJncy5sZW5ndGggPiAwKSB7XG4gICAgICB0aGlzLmNvcHkoW2FycmF5LCAuLi5hcmdzXSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuaWRlbnRpdHkoKTtcbiAgICB9XG4gIH1cblxuICBjb3B5KGFycmF5KSB7XG4gICAgdGhpc1swXSA9IGFycmF5WzBdO1xuICAgIHRoaXNbMV0gPSBhcnJheVsxXTtcbiAgICB0aGlzWzJdID0gYXJyYXlbMl07XG4gICAgdGhpc1szXSA9IGFycmF5WzNdO1xuICAgIHRoaXNbNF0gPSBhcnJheVs0XTtcbiAgICB0aGlzWzVdID0gYXJyYXlbNV07XG4gICAgdGhpc1s2XSA9IGFycmF5WzZdO1xuICAgIHRoaXNbN10gPSBhcnJheVs3XTtcbiAgICB0aGlzWzhdID0gYXJyYXlbOF07XG4gICAgcmV0dXJuIHRoaXMuY2hlY2soKTtcbiAgfVxuXG4gIGlkZW50aXR5KCkge1xuICAgIHJldHVybiB0aGlzLmNvcHkoSURFTlRJVFlfTUFUUklYKTtcbiAgfVxuXG4gIGZyb21PYmplY3Qob2JqZWN0KSB7XG4gICAgcmV0dXJuIHRoaXMuY2hlY2soKTtcbiAgfVxuXG4gIGZyb21RdWF0ZXJuaW9uKHEpIHtcbiAgICBtYXQzLmZyb21RdWF0KHRoaXMsIHEpO1xuICAgIHJldHVybiB0aGlzLmNoZWNrKCk7XG4gIH1cblxuICBzZXQobTAwLCBtMTAsIG0yMCwgbTAxLCBtMTEsIG0yMSwgbTAyLCBtMTIsIG0yMikge1xuICAgIHRoaXNbMF0gPSBtMDA7XG4gICAgdGhpc1sxXSA9IG0xMDtcbiAgICB0aGlzWzJdID0gbTIwO1xuICAgIHRoaXNbM10gPSBtMDE7XG4gICAgdGhpc1s0XSA9IG0xMTtcbiAgICB0aGlzWzVdID0gbTIxO1xuICAgIHRoaXNbNl0gPSBtMDI7XG4gICAgdGhpc1s3XSA9IG0xMjtcbiAgICB0aGlzWzhdID0gbTIyO1xuICAgIHJldHVybiB0aGlzLmNoZWNrKCk7XG4gIH1cblxuICBzZXRSb3dNYWpvcihtMDAsIG0wMSwgbTAyLCBtMTAsIG0xMSwgbTEyLCBtMjAsIG0yMSwgbTIyKSB7XG4gICAgdGhpc1swXSA9IG0wMDtcbiAgICB0aGlzWzFdID0gbTEwO1xuICAgIHRoaXNbMl0gPSBtMjA7XG4gICAgdGhpc1szXSA9IG0wMTtcbiAgICB0aGlzWzRdID0gbTExO1xuICAgIHRoaXNbNV0gPSBtMjE7XG4gICAgdGhpc1s2XSA9IG0wMjtcbiAgICB0aGlzWzddID0gbTEyO1xuICAgIHRoaXNbOF0gPSBtMjI7XG4gICAgcmV0dXJuIHRoaXMuY2hlY2soKTtcbiAgfVxuXG4gIGRldGVybWluYW50KCkge1xuICAgIHJldHVybiBtYXQzLmRldGVybWluYW50KHRoaXMpO1xuICB9XG5cbiAgdHJhbnNwb3NlKCkge1xuICAgIG1hdDMudHJhbnNwb3NlKHRoaXMsIHRoaXMpO1xuICAgIHJldHVybiB0aGlzLmNoZWNrKCk7XG4gIH1cblxuICBpbnZlcnQoKSB7XG4gICAgbWF0My5pbnZlcnQodGhpcywgdGhpcyk7XG4gICAgcmV0dXJuIHRoaXMuY2hlY2soKTtcbiAgfVxuXG4gIG11bHRpcGx5TGVmdChhKSB7XG4gICAgbWF0My5tdWx0aXBseSh0aGlzLCBhLCB0aGlzKTtcbiAgICByZXR1cm4gdGhpcy5jaGVjaygpO1xuICB9XG5cbiAgbXVsdGlwbHlSaWdodChhKSB7XG4gICAgbWF0My5tdWx0aXBseSh0aGlzLCB0aGlzLCBhKTtcbiAgICByZXR1cm4gdGhpcy5jaGVjaygpO1xuICB9XG5cbiAgcm90YXRlKHJhZGlhbnMpIHtcbiAgICBtYXQzLnJvdGF0ZSh0aGlzLCB0aGlzLCByYWRpYW5zKTtcbiAgICByZXR1cm4gdGhpcy5jaGVjaygpO1xuICB9XG5cbiAgc2NhbGUoZmFjdG9yKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoZmFjdG9yKSkge1xuICAgICAgbWF0My5zY2FsZSh0aGlzLCB0aGlzLCBmYWN0b3IpO1xuICAgIH0gZWxzZSB7XG4gICAgICBtYXQzLnNjYWxlKHRoaXMsIHRoaXMsIFtmYWN0b3IsIGZhY3Rvcl0pO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLmNoZWNrKCk7XG4gIH1cblxuICB0cmFuc2xhdGUodmVjKSB7XG4gICAgbWF0My50cmFuc2xhdGUodGhpcywgdGhpcywgdmVjKTtcbiAgICByZXR1cm4gdGhpcy5jaGVjaygpO1xuICB9XG5cbiAgdHJhbnNmb3JtKHZlY3RvciwgcmVzdWx0KSB7XG4gICAgbGV0IG91dDtcblxuICAgIHN3aXRjaCAodmVjdG9yLmxlbmd0aCkge1xuICAgICAgY2FzZSAyOlxuICAgICAgICBvdXQgPSB2ZWMyLnRyYW5zZm9ybU1hdDMocmVzdWx0IHx8IFstMCwgLTBdLCB2ZWN0b3IsIHRoaXMpO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSAzOlxuICAgICAgICBvdXQgPSB2ZWMzLnRyYW5zZm9ybU1hdDMocmVzdWx0IHx8IFstMCwgLTAsIC0wXSwgdmVjdG9yLCB0aGlzKTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgNDpcbiAgICAgICAgb3V0ID0gdmVjNF90cmFuc2Zvcm1NYXQzKHJlc3VsdCB8fCBbLTAsIC0wLCAtMCwgLTBdLCB2ZWN0b3IsIHRoaXMpO1xuICAgICAgICBicmVhaztcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbGxlZ2FsIHZlY3RvcicpO1xuICAgIH1cblxuICAgIGNoZWNrVmVjdG9yKG91dCwgdmVjdG9yLmxlbmd0aCk7XG4gICAgcmV0dXJuIG91dDtcbiAgfVxuXG4gIHRyYW5zZm9ybVZlY3Rvcih2ZWN0b3IsIHJlc3VsdCkge1xuICAgIHJldHVybiB0aGlzLnRyYW5zZm9ybSh2ZWN0b3IsIHJlc3VsdCk7XG4gIH1cblxuICB0cmFuc2Zvcm1WZWN0b3IyKHZlY3RvciwgcmVzdWx0KSB7XG4gICAgcmV0dXJuIHRoaXMudHJhbnNmb3JtKHZlY3RvciwgcmVzdWx0KTtcbiAgfVxuXG4gIHRyYW5zZm9ybVZlY3RvcjModmVjdG9yLCByZXN1bHQpIHtcbiAgICByZXR1cm4gdGhpcy50cmFuc2Zvcm0odmVjdG9yLCByZXN1bHQpO1xuICB9XG5cbn1cbmxldCBaRVJPX01BVFJJWDM7XG5sZXQgSURFTlRJVFlfTUFUUklYMztcblxuZnVuY3Rpb24gZ2V0WmVyb01hdHJpeCgpIHtcbiAgaWYgKCFaRVJPX01BVFJJWDMpIHtcbiAgICBaRVJPX01BVFJJWDMgPSBuZXcgTWF0cml4MyhbMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMF0pO1xuICAgIE9iamVjdC5mcmVlemUoWkVST19NQVRSSVgzKTtcbiAgfVxuXG4gIHJldHVybiBaRVJPX01BVFJJWDM7XG59XG5cbmZ1bmN0aW9uIGdldElkZW50aXR5TWF0cml4KCkge1xuICBpZiAoIUlERU5USVRZX01BVFJJWDMpIHtcbiAgICBJREVOVElUWV9NQVRSSVgzID0gbmV3IE1hdHJpeDMoKTtcbiAgICBPYmplY3QuZnJlZXplKElERU5USVRZX01BVFJJWDMpO1xuICB9XG5cbiAgcmV0dXJuIElERU5USVRZX01BVFJJWDM7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1tYXRyaXgzLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///80540\n')},85451:function(__unused_webpack_module,__webpack_exports__,__webpack_require__){eval('/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "Z": function() { return /* binding */ Matrix4; }\n/* harmony export */ });\n/* harmony import */ var _base_matrix__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(61000);\n/* harmony import */ var _lib_validators__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(86281);\n/* harmony import */ var _lib_gl_matrix_extras__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(1031);\n/* harmony import */ var gl_matrix_mat4__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(85975);\n/* harmony import */ var gl_matrix_vec2__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(31437);\n/* harmony import */ var gl_matrix_vec3__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(77160);\n/* harmony import */ var gl_matrix_vec4__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(98333);\n\n\n\n\n\n\n\nvar INDICES;\n\n(function (INDICES) {\n  INDICES[INDICES["COL0ROW0"] = 0] = "COL0ROW0";\n  INDICES[INDICES["COL0ROW1"] = 1] = "COL0ROW1";\n  INDICES[INDICES["COL0ROW2"] = 2] = "COL0ROW2";\n  INDICES[INDICES["COL0ROW3"] = 3] = "COL0ROW3";\n  INDICES[INDICES["COL1ROW0"] = 4] = "COL1ROW0";\n  INDICES[INDICES["COL1ROW1"] = 5] = "COL1ROW1";\n  INDICES[INDICES["COL1ROW2"] = 6] = "COL1ROW2";\n  INDICES[INDICES["COL1ROW3"] = 7] = "COL1ROW3";\n  INDICES[INDICES["COL2ROW0"] = 8] = "COL2ROW0";\n  INDICES[INDICES["COL2ROW1"] = 9] = "COL2ROW1";\n  INDICES[INDICES["COL2ROW2"] = 10] = "COL2ROW2";\n  INDICES[INDICES["COL2ROW3"] = 11] = "COL2ROW3";\n  INDICES[INDICES["COL3ROW0"] = 12] = "COL3ROW0";\n  INDICES[INDICES["COL3ROW1"] = 13] = "COL3ROW1";\n  INDICES[INDICES["COL3ROW2"] = 14] = "COL3ROW2";\n  INDICES[INDICES["COL3ROW3"] = 15] = "COL3ROW3";\n})(INDICES || (INDICES = {}));\n\nconst DEFAULT_FOVY = 45 * Math.PI / 180;\nconst DEFAULT_ASPECT = 1;\nconst DEFAULT_NEAR = 0.1;\nconst DEFAULT_FAR = 500;\nconst IDENTITY_MATRIX = Object.freeze([1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]);\nclass Matrix4 extends _base_matrix__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .Z {\n  static get IDENTITY() {\n    return getIdentityMatrix();\n  }\n\n  static get ZERO() {\n    return getZeroMatrix();\n  }\n\n  get ELEMENTS() {\n    return 16;\n  }\n\n  get RANK() {\n    return 4;\n  }\n\n  get INDICES() {\n    return INDICES;\n  }\n\n  constructor(array) {\n    super(-0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0);\n\n    if (arguments.length === 1 && Array.isArray(array)) {\n      this.copy(array);\n    } else {\n      this.identity();\n    }\n  }\n\n  copy(array) {\n    this[0] = array[0];\n    this[1] = array[1];\n    this[2] = array[2];\n    this[3] = array[3];\n    this[4] = array[4];\n    this[5] = array[5];\n    this[6] = array[6];\n    this[7] = array[7];\n    this[8] = array[8];\n    this[9] = array[9];\n    this[10] = array[10];\n    this[11] = array[11];\n    this[12] = array[12];\n    this[13] = array[13];\n    this[14] = array[14];\n    this[15] = array[15];\n    return this.check();\n  }\n\n  set(m00, m10, m20, m30, m01, m11, m21, m31, m02, m12, m22, m32, m03, m13, m23, m33) {\n    this[0] = m00;\n    this[1] = m10;\n    this[2] = m20;\n    this[3] = m30;\n    this[4] = m01;\n    this[5] = m11;\n    this[6] = m21;\n    this[7] = m31;\n    this[8] = m02;\n    this[9] = m12;\n    this[10] = m22;\n    this[11] = m32;\n    this[12] = m03;\n    this[13] = m13;\n    this[14] = m23;\n    this[15] = m33;\n    return this.check();\n  }\n\n  setRowMajor(m00, m01, m02, m03, m10, m11, m12, m13, m20, m21, m22, m23, m30, m31, m32, m33) {\n    this[0] = m00;\n    this[1] = m10;\n    this[2] = m20;\n    this[3] = m30;\n    this[4] = m01;\n    this[5] = m11;\n    this[6] = m21;\n    this[7] = m31;\n    this[8] = m02;\n    this[9] = m12;\n    this[10] = m22;\n    this[11] = m32;\n    this[12] = m03;\n    this[13] = m13;\n    this[14] = m23;\n    this[15] = m33;\n    return this.check();\n  }\n\n  toRowMajor(result) {\n    result[0] = this[0];\n    result[1] = this[4];\n    result[2] = this[8];\n    result[3] = this[12];\n    result[4] = this[1];\n    result[5] = this[5];\n    result[6] = this[9];\n    result[7] = this[13];\n    result[8] = this[2];\n    result[9] = this[6];\n    result[10] = this[10];\n    result[11] = this[14];\n    result[12] = this[3];\n    result[13] = this[7];\n    result[14] = this[11];\n    result[15] = this[15];\n    return result;\n  }\n\n  identity() {\n    return this.copy(IDENTITY_MATRIX);\n  }\n\n  fromObject(object) {\n    return this.check();\n  }\n\n  fromQuaternion(quaternion) {\n    gl_matrix_mat4__WEBPACK_IMPORTED_MODULE_1__/* .fromQuat */ .en(this, quaternion);\n    return this.check();\n  }\n\n  frustum(view) {\n    const {\n      left,\n      right,\n      bottom,\n      top,\n      near = DEFAULT_NEAR,\n      far = DEFAULT_FAR\n    } = view;\n\n    if (far === Infinity) {\n      computeInfinitePerspectiveOffCenter(this, left, right, bottom, top, near);\n    } else {\n      gl_matrix_mat4__WEBPACK_IMPORTED_MODULE_1__/* .frustum */ .oy(this, left, right, bottom, top, near, far);\n    }\n\n    return this.check();\n  }\n\n  lookAt(view) {\n    const {\n      eye,\n      center = [0, 0, 0],\n      up = [0, 1, 0]\n    } = view;\n    gl_matrix_mat4__WEBPACK_IMPORTED_MODULE_1__/* .lookAt */ .zB(this, eye, center, up);\n    return this.check();\n  }\n\n  ortho(view) {\n    const {\n      left,\n      right,\n      bottom,\n      top,\n      near = DEFAULT_NEAR,\n      far = DEFAULT_FAR\n    } = view;\n    gl_matrix_mat4__WEBPACK_IMPORTED_MODULE_1__/* .ortho */ .M5(this, left, right, bottom, top, near, far);\n    return this.check();\n  }\n\n  orthographic(view) {\n    const {\n      fovy = DEFAULT_FOVY,\n      aspect = DEFAULT_ASPECT,\n      focalDistance = 1,\n      near = DEFAULT_NEAR,\n      far = DEFAULT_FAR\n    } = view;\n    checkRadians(fovy);\n    const halfY = fovy / 2;\n    const top = focalDistance * Math.tan(halfY);\n    const right = top * aspect;\n    return this.ortho({\n      left: -right,\n      right,\n      bottom: -top,\n      top,\n      near,\n      far\n    });\n  }\n\n  perspective(view) {\n    const {\n      fovy = 45 * Math.PI / 180,\n      aspect = 1,\n      near = 0.1,\n      far = 500\n    } = view;\n    checkRadians(fovy);\n    gl_matrix_mat4__WEBPACK_IMPORTED_MODULE_1__/* .perspective */ .G3(this, fovy, aspect, near, far);\n    return this.check();\n  }\n\n  determinant() {\n    return gl_matrix_mat4__WEBPACK_IMPORTED_MODULE_1__/* .determinant */ .GH(this);\n  }\n\n  getScale(result = [-0, -0, -0]) {\n    result[0] = Math.sqrt(this[0] * this[0] + this[1] * this[1] + this[2] * this[2]);\n    result[1] = Math.sqrt(this[4] * this[4] + this[5] * this[5] + this[6] * this[6]);\n    result[2] = Math.sqrt(this[8] * this[8] + this[9] * this[9] + this[10] * this[10]);\n    return result;\n  }\n\n  getTranslation(result = [-0, -0, -0]) {\n    result[0] = this[12];\n    result[1] = this[13];\n    result[2] = this[14];\n    return result;\n  }\n\n  getRotation(result, scaleResult) {\n    result = result || [-0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0];\n    scaleResult = scaleResult || [-0, -0, -0];\n    const scale = this.getScale(scaleResult);\n    const inverseScale0 = 1 / scale[0];\n    const inverseScale1 = 1 / scale[1];\n    const inverseScale2 = 1 / scale[2];\n    result[0] = this[0] * inverseScale0;\n    result[1] = this[1] * inverseScale1;\n    result[2] = this[2] * inverseScale2;\n    result[3] = 0;\n    result[4] = this[4] * inverseScale0;\n    result[5] = this[5] * inverseScale1;\n    result[6] = this[6] * inverseScale2;\n    result[7] = 0;\n    result[8] = this[8] * inverseScale0;\n    result[9] = this[9] * inverseScale1;\n    result[10] = this[10] * inverseScale2;\n    result[11] = 0;\n    result[12] = 0;\n    result[13] = 0;\n    result[14] = 0;\n    result[15] = 1;\n    return result;\n  }\n\n  getRotationMatrix3(result, scaleResult) {\n    result = result || [-0, -0, -0, -0, -0, -0, -0, -0, -0];\n    scaleResult = scaleResult || [-0, -0, -0];\n    const scale = this.getScale(scaleResult);\n    const inverseScale0 = 1 / scale[0];\n    const inverseScale1 = 1 / scale[1];\n    const inverseScale2 = 1 / scale[2];\n    result[0] = this[0] * inverseScale0;\n    result[1] = this[1] * inverseScale1;\n    result[2] = this[2] * inverseScale2;\n    result[3] = this[4] * inverseScale0;\n    result[4] = this[5] * inverseScale1;\n    result[5] = this[6] * inverseScale2;\n    result[6] = this[8] * inverseScale0;\n    result[7] = this[9] * inverseScale1;\n    result[8] = this[10] * inverseScale2;\n    return result;\n  }\n\n  transpose() {\n    gl_matrix_mat4__WEBPACK_IMPORTED_MODULE_1__/* .transpose */ .p4(this, this);\n    return this.check();\n  }\n\n  invert() {\n    gl_matrix_mat4__WEBPACK_IMPORTED_MODULE_1__/* .invert */ .U_(this, this);\n    return this.check();\n  }\n\n  multiplyLeft(a) {\n    gl_matrix_mat4__WEBPACK_IMPORTED_MODULE_1__/* .multiply */ .Jp(this, a, this);\n    return this.check();\n  }\n\n  multiplyRight(a) {\n    gl_matrix_mat4__WEBPACK_IMPORTED_MODULE_1__/* .multiply */ .Jp(this, this, a);\n    return this.check();\n  }\n\n  rotateX(radians) {\n    gl_matrix_mat4__WEBPACK_IMPORTED_MODULE_1__/* .rotateX */ .lM(this, this, radians);\n    return this.check();\n  }\n\n  rotateY(radians) {\n    gl_matrix_mat4__WEBPACK_IMPORTED_MODULE_1__/* .rotateY */ .uD(this, this, radians);\n    return this.check();\n  }\n\n  rotateZ(radians) {\n    gl_matrix_mat4__WEBPACK_IMPORTED_MODULE_1__/* .rotateZ */ .jI(this, this, radians);\n    return this.check();\n  }\n\n  rotateXYZ(angleXYZ) {\n    return this.rotateX(angleXYZ[0]).rotateY(angleXYZ[1]).rotateZ(angleXYZ[2]);\n  }\n\n  rotateAxis(radians, axis) {\n    gl_matrix_mat4__WEBPACK_IMPORTED_MODULE_1__/* .rotate */ .U1(this, this, radians, axis);\n    return this.check();\n  }\n\n  scale(factor) {\n    gl_matrix_mat4__WEBPACK_IMPORTED_MODULE_1__/* .scale */ .bA(this, this, Array.isArray(factor) ? factor : [factor, factor, factor]);\n    return this.check();\n  }\n\n  translate(vector) {\n    gl_matrix_mat4__WEBPACK_IMPORTED_MODULE_1__/* .translate */ .Iu(this, this, vector);\n    return this.check();\n  }\n\n  transform(vector, result) {\n    if (vector.length === 4) {\n      result = gl_matrix_vec4__WEBPACK_IMPORTED_MODULE_2__/* .transformMat4 */ .fF(result || [-0, -0, -0, -0], vector, this);\n      (0,_lib_validators__WEBPACK_IMPORTED_MODULE_3__/* .checkVector */ .IL)(result, 4);\n      return result;\n    }\n\n    return this.transformAsPoint(vector, result);\n  }\n\n  transformAsPoint(vector, result) {\n    const {\n      length\n    } = vector;\n    let out;\n\n    switch (length) {\n      case 2:\n        out = gl_matrix_vec2__WEBPACK_IMPORTED_MODULE_4__/* .transformMat4 */ .fF(result || [-0, -0], vector, this);\n        break;\n\n      case 3:\n        out = gl_matrix_vec3__WEBPACK_IMPORTED_MODULE_5__/* .transformMat4 */ .fF(result || [-0, -0, -0], vector, this);\n        break;\n\n      default:\n        throw new Error(\'Illegal vector\');\n    }\n\n    (0,_lib_validators__WEBPACK_IMPORTED_MODULE_3__/* .checkVector */ .IL)(out, vector.length);\n    return out;\n  }\n\n  transformAsVector(vector, result) {\n    let out;\n\n    switch (vector.length) {\n      case 2:\n        out = (0,_lib_gl_matrix_extras__WEBPACK_IMPORTED_MODULE_6__/* .vec2_transformMat4AsVector */ .pb)(result || [-0, -0], vector, this);\n        break;\n\n      case 3:\n        out = (0,_lib_gl_matrix_extras__WEBPACK_IMPORTED_MODULE_6__/* .vec3_transformMat4AsVector */ .pL)(result || [-0, -0, -0], vector, this);\n        break;\n\n      default:\n        throw new Error(\'Illegal vector\');\n    }\n\n    (0,_lib_validators__WEBPACK_IMPORTED_MODULE_3__/* .checkVector */ .IL)(out, vector.length);\n    return out;\n  }\n\n  transformPoint(vector, result) {\n    return this.transformAsPoint(vector, result);\n  }\n\n  transformVector(vector, result) {\n    return this.transformAsPoint(vector, result);\n  }\n\n  transformDirection(vector, result) {\n    return this.transformAsVector(vector, result);\n  }\n\n  makeRotationX(radians) {\n    return this.identity().rotateX(radians);\n  }\n\n  makeTranslation(x, y, z) {\n    return this.identity().translate([x, y, z]);\n  }\n\n}\nlet ZERO;\nlet IDENTITY;\n\nfunction getZeroMatrix() {\n  if (!ZERO) {\n    ZERO = new Matrix4([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]);\n    Object.freeze(ZERO);\n  }\n\n  return ZERO;\n}\n\nfunction getIdentityMatrix() {\n  if (!IDENTITY) {\n    IDENTITY = new Matrix4();\n    Object.freeze(IDENTITY);\n  }\n\n  return IDENTITY;\n}\n\nfunction checkRadians(possiblyDegrees) {\n  if (possiblyDegrees > Math.PI * 2) {\n    throw Error(\'expected radians\');\n  }\n}\n\nfunction computeInfinitePerspectiveOffCenter(result, left, right, bottom, top, near) {\n  const column0Row0 = 2 * near / (right - left);\n  const column1Row1 = 2 * near / (top - bottom);\n  const column2Row0 = (right + left) / (right - left);\n  const column2Row1 = (top + bottom) / (top - bottom);\n  const column2Row2 = -1;\n  const column2Row3 = -1;\n  const column3Row2 = -2 * near;\n  result[0] = column0Row0;\n  result[1] = 0;\n  result[2] = 0;\n  result[3] = 0;\n  result[4] = 0;\n  result[5] = column1Row1;\n  result[6] = 0;\n  result[7] = 0;\n  result[8] = column2Row0;\n  result[9] = column2Row1;\n  result[10] = column2Row2;\n  result[11] = column2Row3;\n  result[12] = 0;\n  result[13] = 0;\n  result[14] = column3Row2;\n  result[15] = 0;\n  return result;\n}\n//# sourceMappingURL=matrix4.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiODU0NTEuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7OztBQUFtQztBQUNhO0FBQ2lEO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ3ZDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLDBCQUEwQjs7QUFFM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNlLHNCQUFzQiw2REFBTTtBQUMzQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLElBQUksOERBQWE7QUFDakI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTs7QUFFTjtBQUNBO0FBQ0EsTUFBTTtBQUNOLE1BQU0sNkRBQVk7QUFDbEI7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOLElBQUksNERBQVc7QUFDZjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ04sSUFBSSwyREFBVTtBQUNkO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxJQUFJLGlFQUFnQjtBQUNwQjtBQUNBOztBQUVBO0FBQ0EsV0FBVyxpRUFBZ0I7QUFDM0I7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxJQUFJLCtEQUFjO0FBQ2xCO0FBQ0E7O0FBRUE7QUFDQSxJQUFJLDREQUFXO0FBQ2Y7QUFDQTs7QUFFQTtBQUNBLElBQUksOERBQWE7QUFDakI7QUFDQTs7QUFFQTtBQUNBLElBQUksOERBQWE7QUFDakI7QUFDQTs7QUFFQTtBQUNBLElBQUksNkRBQVk7QUFDaEI7QUFDQTs7QUFFQTtBQUNBLElBQUksNkRBQVk7QUFDaEI7QUFDQTs7QUFFQTtBQUNBLElBQUksNkRBQVk7QUFDaEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxJQUFJLDREQUFXO0FBQ2Y7QUFDQTs7QUFFQTtBQUNBLElBQUksMkRBQVU7QUFDZDtBQUNBOztBQUVBO0FBQ0EsSUFBSSwrREFBYztBQUNsQjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFlLG1FQUFrQjtBQUNqQyxNQUFNLHNFQUFXO0FBQ2pCO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047O0FBRUE7QUFDQTtBQUNBLGNBQWMsbUVBQWtCO0FBQ2hDOztBQUVBO0FBQ0EsY0FBYyxtRUFBa0I7QUFDaEM7O0FBRUE7QUFDQTtBQUNBOztBQUVBLElBQUksc0VBQVc7QUFDZjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGNBQWMsMkZBQTBCO0FBQ3hDOztBQUVBO0FBQ0EsY0FBYywyRkFBMEI7QUFDeEM7O0FBRUE7QUFDQTtBQUNBOztBQUVBLElBQUksc0VBQVc7QUFDZjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly92dWUzLXdlYnBhY2s1Ly4vbm9kZV9tb2R1bGVzL0BtYXRoLmdsL2NvcmUvZGlzdC9lc20vY2xhc3Nlcy9tYXRyaXg0LmpzPzk5NjUiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IE1hdHJpeCBmcm9tICcuL2Jhc2UvbWF0cml4JztcbmltcG9ydCB7IGNoZWNrVmVjdG9yIH0gZnJvbSAnLi4vbGliL3ZhbGlkYXRvcnMnO1xuaW1wb3J0IHsgdmVjMl90cmFuc2Zvcm1NYXQ0QXNWZWN0b3IsIHZlYzNfdHJhbnNmb3JtTWF0NEFzVmVjdG9yIH0gZnJvbSAnLi4vbGliL2dsLW1hdHJpeC1leHRyYXMnO1xuaW1wb3J0ICogYXMgbWF0NCBmcm9tICdnbC1tYXRyaXgvbWF0NCc7XG5pbXBvcnQgKiBhcyB2ZWMyIGZyb20gJ2dsLW1hdHJpeC92ZWMyJztcbmltcG9ydCAqIGFzIHZlYzMgZnJvbSAnZ2wtbWF0cml4L3ZlYzMnO1xuaW1wb3J0ICogYXMgdmVjNCBmcm9tICdnbC1tYXRyaXgvdmVjNCc7XG52YXIgSU5ESUNFUztcblxuKGZ1bmN0aW9uIChJTkRJQ0VTKSB7XG4gIElORElDRVNbSU5ESUNFU1tcIkNPTDBST1cwXCJdID0gMF0gPSBcIkNPTDBST1cwXCI7XG4gIElORElDRVNbSU5ESUNFU1tcIkNPTDBST1cxXCJdID0gMV0gPSBcIkNPTDBST1cxXCI7XG4gIElORElDRVNbSU5ESUNFU1tcIkNPTDBST1cyXCJdID0gMl0gPSBcIkNPTDBST1cyXCI7XG4gIElORElDRVNbSU5ESUNFU1tcIkNPTDBST1czXCJdID0gM10gPSBcIkNPTDBST1czXCI7XG4gIElORElDRVNbSU5ESUNFU1tcIkNPTDFST1cwXCJdID0gNF0gPSBcIkNPTDFST1cwXCI7XG4gIElORElDRVNbSU5ESUNFU1tcIkNPTDFST1cxXCJdID0gNV0gPSBcIkNPTDFST1cxXCI7XG4gIElORElDRVNbSU5ESUNFU1tcIkNPTDFST1cyXCJdID0gNl0gPSBcIkNPTDFST1cyXCI7XG4gIElORElDRVNbSU5ESUNFU1tcIkNPTDFST1czXCJdID0gN10gPSBcIkNPTDFST1czXCI7XG4gIElORElDRVNbSU5ESUNFU1tcIkNPTDJST1cwXCJdID0gOF0gPSBcIkNPTDJST1cwXCI7XG4gIElORElDRVNbSU5ESUNFU1tcIkNPTDJST1cxXCJdID0gOV0gPSBcIkNPTDJST1cxXCI7XG4gIElORElDRVNbSU5ESUNFU1tcIkNPTDJST1cyXCJdID0gMTBdID0gXCJDT0wyUk9XMlwiO1xuICBJTkRJQ0VTW0lORElDRVNbXCJDT0wyUk9XM1wiXSA9IDExXSA9IFwiQ09MMlJPVzNcIjtcbiAgSU5ESUNFU1tJTkRJQ0VTW1wiQ09MM1JPVzBcIl0gPSAxMl0gPSBcIkNPTDNST1cwXCI7XG4gIElORElDRVNbSU5ESUNFU1tcIkNPTDNST1cxXCJdID0gMTNdID0gXCJDT0wzUk9XMVwiO1xuICBJTkRJQ0VTW0lORElDRVNbXCJDT0wzUk9XMlwiXSA9IDE0XSA9IFwiQ09MM1JPVzJcIjtcbiAgSU5ESUNFU1tJTkRJQ0VTW1wiQ09MM1JPVzNcIl0gPSAxNV0gPSBcIkNPTDNST1czXCI7XG59KShJTkRJQ0VTIHx8IChJTkRJQ0VTID0ge30pKTtcblxuY29uc3QgREVGQVVMVF9GT1ZZID0gNDUgKiBNYXRoLlBJIC8gMTgwO1xuY29uc3QgREVGQVVMVF9BU1BFQ1QgPSAxO1xuY29uc3QgREVGQVVMVF9ORUFSID0gMC4xO1xuY29uc3QgREVGQVVMVF9GQVIgPSA1MDA7XG5jb25zdCBJREVOVElUWV9NQVRSSVggPSBPYmplY3QuZnJlZXplKFsxLCAwLCAwLCAwLCAwLCAxLCAwLCAwLCAwLCAwLCAxLCAwLCAwLCAwLCAwLCAxXSk7XG5leHBvcnQgZGVmYXVsdCBjbGFzcyBNYXRyaXg0IGV4dGVuZHMgTWF0cml4IHtcbiAgc3RhdGljIGdldCBJREVOVElUWSgpIHtcbiAgICByZXR1cm4gZ2V0SWRlbnRpdHlNYXRyaXgoKTtcbiAgfVxuXG4gIHN0YXRpYyBnZXQgWkVSTygpIHtcbiAgICByZXR1cm4gZ2V0WmVyb01hdHJpeCgpO1xuICB9XG5cbiAgZ2V0IEVMRU1FTlRTKCkge1xuICAgIHJldHVybiAxNjtcbiAgfVxuXG4gIGdldCBSQU5LKCkge1xuICAgIHJldHVybiA0O1xuICB9XG5cbiAgZ2V0IElORElDRVMoKSB7XG4gICAgcmV0dXJuIElORElDRVM7XG4gIH1cblxuICBjb25zdHJ1Y3RvcihhcnJheSkge1xuICAgIHN1cGVyKC0wLCAtMCwgLTAsIC0wLCAtMCwgLTAsIC0wLCAtMCwgLTAsIC0wLCAtMCwgLTAsIC0wLCAtMCwgLTAsIC0wKTtcblxuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxICYmIEFycmF5LmlzQXJyYXkoYXJyYXkpKSB7XG4gICAgICB0aGlzLmNvcHkoYXJyYXkpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmlkZW50aXR5KCk7XG4gICAgfVxuICB9XG5cbiAgY29weShhcnJheSkge1xuICAgIHRoaXNbMF0gPSBhcnJheVswXTtcbiAgICB0aGlzWzFdID0gYXJyYXlbMV07XG4gICAgdGhpc1syXSA9IGFycmF5WzJdO1xuICAgIHRoaXNbM10gPSBhcnJheVszXTtcbiAgICB0aGlzWzRdID0gYXJyYXlbNF07XG4gICAgdGhpc1s1XSA9IGFycmF5WzVdO1xuICAgIHRoaXNbNl0gPSBhcnJheVs2XTtcbiAgICB0aGlzWzddID0gYXJyYXlbN107XG4gICAgdGhpc1s4XSA9IGFycmF5WzhdO1xuICAgIHRoaXNbOV0gPSBhcnJheVs5XTtcbiAgICB0aGlzWzEwXSA9IGFycmF5WzEwXTtcbiAgICB0aGlzWzExXSA9IGFycmF5WzExXTtcbiAgICB0aGlzWzEyXSA9IGFycmF5WzEyXTtcbiAgICB0aGlzWzEzXSA9IGFycmF5WzEzXTtcbiAgICB0aGlzWzE0XSA9IGFycmF5WzE0XTtcbiAgICB0aGlzWzE1XSA9IGFycmF5WzE1XTtcbiAgICByZXR1cm4gdGhpcy5jaGVjaygpO1xuICB9XG5cbiAgc2V0KG0wMCwgbTEwLCBtMjAsIG0zMCwgbTAxLCBtMTEsIG0yMSwgbTMxLCBtMDIsIG0xMiwgbTIyLCBtMzIsIG0wMywgbTEzLCBtMjMsIG0zMykge1xuICAgIHRoaXNbMF0gPSBtMDA7XG4gICAgdGhpc1sxXSA9IG0xMDtcbiAgICB0aGlzWzJdID0gbTIwO1xuICAgIHRoaXNbM10gPSBtMzA7XG4gICAgdGhpc1s0XSA9IG0wMTtcbiAgICB0aGlzWzVdID0gbTExO1xuICAgIHRoaXNbNl0gPSBtMjE7XG4gICAgdGhpc1s3XSA9IG0zMTtcbiAgICB0aGlzWzhdID0gbTAyO1xuICAgIHRoaXNbOV0gPSBtMTI7XG4gICAgdGhpc1sxMF0gPSBtMjI7XG4gICAgdGhpc1sxMV0gPSBtMzI7XG4gICAgdGhpc1sxMl0gPSBtMDM7XG4gICAgdGhpc1sxM10gPSBtMTM7XG4gICAgdGhpc1sxNF0gPSBtMjM7XG4gICAgdGhpc1sxNV0gPSBtMzM7XG4gICAgcmV0dXJuIHRoaXMuY2hlY2soKTtcbiAgfVxuXG4gIHNldFJvd01ham9yKG0wMCwgbTAxLCBtMDIsIG0wMywgbTEwLCBtMTEsIG0xMiwgbTEzLCBtMjAsIG0yMSwgbTIyLCBtMjMsIG0zMCwgbTMxLCBtMzIsIG0zMykge1xuICAgIHRoaXNbMF0gPSBtMDA7XG4gICAgdGhpc1sxXSA9IG0xMDtcbiAgICB0aGlzWzJdID0gbTIwO1xuICAgIHRoaXNbM10gPSBtMzA7XG4gICAgdGhpc1s0XSA9IG0wMTtcbiAgICB0aGlzWzVdID0gbTExO1xuICAgIHRoaXNbNl0gPSBtMjE7XG4gICAgdGhpc1s3XSA9IG0zMTtcbiAgICB0aGlzWzhdID0gbTAyO1xuICAgIHRoaXNbOV0gPSBtMTI7XG4gICAgdGhpc1sxMF0gPSBtMjI7XG4gICAgdGhpc1sxMV0gPSBtMzI7XG4gICAgdGhpc1sxMl0gPSBtMDM7XG4gICAgdGhpc1sxM10gPSBtMTM7XG4gICAgdGhpc1sxNF0gPSBtMjM7XG4gICAgdGhpc1sxNV0gPSBtMzM7XG4gICAgcmV0dXJuIHRoaXMuY2hlY2soKTtcbiAgfVxuXG4gIHRvUm93TWFqb3IocmVzdWx0KSB7XG4gICAgcmVzdWx0WzBdID0gdGhpc1swXTtcbiAgICByZXN1bHRbMV0gPSB0aGlzWzRdO1xuICAgIHJlc3VsdFsyXSA9IHRoaXNbOF07XG4gICAgcmVzdWx0WzNdID0gdGhpc1sxMl07XG4gICAgcmVzdWx0WzRdID0gdGhpc1sxXTtcbiAgICByZXN1bHRbNV0gPSB0aGlzWzVdO1xuICAgIHJlc3VsdFs2XSA9IHRoaXNbOV07XG4gICAgcmVzdWx0WzddID0gdGhpc1sxM107XG4gICAgcmVzdWx0WzhdID0gdGhpc1syXTtcbiAgICByZXN1bHRbOV0gPSB0aGlzWzZdO1xuICAgIHJlc3VsdFsxMF0gPSB0aGlzWzEwXTtcbiAgICByZXN1bHRbMTFdID0gdGhpc1sxNF07XG4gICAgcmVzdWx0WzEyXSA9IHRoaXNbM107XG4gICAgcmVzdWx0WzEzXSA9IHRoaXNbN107XG4gICAgcmVzdWx0WzE0XSA9IHRoaXNbMTFdO1xuICAgIHJlc3VsdFsxNV0gPSB0aGlzWzE1XTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgaWRlbnRpdHkoKSB7XG4gICAgcmV0dXJuIHRoaXMuY29weShJREVOVElUWV9NQVRSSVgpO1xuICB9XG5cbiAgZnJvbU9iamVjdChvYmplY3QpIHtcbiAgICByZXR1cm4gdGhpcy5jaGVjaygpO1xuICB9XG5cbiAgZnJvbVF1YXRlcm5pb24ocXVhdGVybmlvbikge1xuICAgIG1hdDQuZnJvbVF1YXQodGhpcywgcXVhdGVybmlvbik7XG4gICAgcmV0dXJuIHRoaXMuY2hlY2soKTtcbiAgfVxuXG4gIGZydXN0dW0odmlldykge1xuICAgIGNvbnN0IHtcbiAgICAgIGxlZnQsXG4gICAgICByaWdodCxcbiAgICAgIGJvdHRvbSxcbiAgICAgIHRvcCxcbiAgICAgIG5lYXIgPSBERUZBVUxUX05FQVIsXG4gICAgICBmYXIgPSBERUZBVUxUX0ZBUlxuICAgIH0gPSB2aWV3O1xuXG4gICAgaWYgKGZhciA9PT0gSW5maW5pdHkpIHtcbiAgICAgIGNvbXB1dGVJbmZpbml0ZVBlcnNwZWN0aXZlT2ZmQ2VudGVyKHRoaXMsIGxlZnQsIHJpZ2h0LCBib3R0b20sIHRvcCwgbmVhcik7XG4gICAgfSBlbHNlIHtcbiAgICAgIG1hdDQuZnJ1c3R1bSh0aGlzLCBsZWZ0LCByaWdodCwgYm90dG9tLCB0b3AsIG5lYXIsIGZhcik7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuY2hlY2soKTtcbiAgfVxuXG4gIGxvb2tBdCh2aWV3KSB7XG4gICAgY29uc3Qge1xuICAgICAgZXllLFxuICAgICAgY2VudGVyID0gWzAsIDAsIDBdLFxuICAgICAgdXAgPSBbMCwgMSwgMF1cbiAgICB9ID0gdmlldztcbiAgICBtYXQ0Lmxvb2tBdCh0aGlzLCBleWUsIGNlbnRlciwgdXApO1xuICAgIHJldHVybiB0aGlzLmNoZWNrKCk7XG4gIH1cblxuICBvcnRobyh2aWV3KSB7XG4gICAgY29uc3Qge1xuICAgICAgbGVmdCxcbiAgICAgIHJpZ2h0LFxuICAgICAgYm90dG9tLFxuICAgICAgdG9wLFxuICAgICAgbmVhciA9IERFRkFVTFRfTkVBUixcbiAgICAgIGZhciA9IERFRkFVTFRfRkFSXG4gICAgfSA9IHZpZXc7XG4gICAgbWF0NC5vcnRobyh0aGlzLCBsZWZ0LCByaWdodCwgYm90dG9tLCB0b3AsIG5lYXIsIGZhcik7XG4gICAgcmV0dXJuIHRoaXMuY2hlY2soKTtcbiAgfVxuXG4gIG9ydGhvZ3JhcGhpYyh2aWV3KSB7XG4gICAgY29uc3Qge1xuICAgICAgZm92eSA9IERFRkFVTFRfRk9WWSxcbiAgICAgIGFzcGVjdCA9IERFRkFVTFRfQVNQRUNULFxuICAgICAgZm9jYWxEaXN0YW5jZSA9IDEsXG4gICAgICBuZWFyID0gREVGQVVMVF9ORUFSLFxuICAgICAgZmFyID0gREVGQVVMVF9GQVJcbiAgICB9ID0gdmlldztcbiAgICBjaGVja1JhZGlhbnMoZm92eSk7XG4gICAgY29uc3QgaGFsZlkgPSBmb3Z5IC8gMjtcbiAgICBjb25zdCB0b3AgPSBmb2NhbERpc3RhbmNlICogTWF0aC50YW4oaGFsZlkpO1xuICAgIGNvbnN0IHJpZ2h0ID0gdG9wICogYXNwZWN0O1xuICAgIHJldHVybiB0aGlzLm9ydGhvKHtcbiAgICAgIGxlZnQ6IC1yaWdodCxcbiAgICAgIHJpZ2h0LFxuICAgICAgYm90dG9tOiAtdG9wLFxuICAgICAgdG9wLFxuICAgICAgbmVhcixcbiAgICAgIGZhclxuICAgIH0pO1xuICB9XG5cbiAgcGVyc3BlY3RpdmUodmlldykge1xuICAgIGNvbnN0IHtcbiAgICAgIGZvdnkgPSA0NSAqIE1hdGguUEkgLyAxODAsXG4gICAgICBhc3BlY3QgPSAxLFxuICAgICAgbmVhciA9IDAuMSxcbiAgICAgIGZhciA9IDUwMFxuICAgIH0gPSB2aWV3O1xuICAgIGNoZWNrUmFkaWFucyhmb3Z5KTtcbiAgICBtYXQ0LnBlcnNwZWN0aXZlKHRoaXMsIGZvdnksIGFzcGVjdCwgbmVhciwgZmFyKTtcbiAgICByZXR1cm4gdGhpcy5jaGVjaygpO1xuICB9XG5cbiAgZGV0ZXJtaW5hbnQoKSB7XG4gICAgcmV0dXJuIG1hdDQuZGV0ZXJtaW5hbnQodGhpcyk7XG4gIH1cblxuICBnZXRTY2FsZShyZXN1bHQgPSBbLTAsIC0wLCAtMF0pIHtcbiAgICByZXN1bHRbMF0gPSBNYXRoLnNxcnQodGhpc1swXSAqIHRoaXNbMF0gKyB0aGlzWzFdICogdGhpc1sxXSArIHRoaXNbMl0gKiB0aGlzWzJdKTtcbiAgICByZXN1bHRbMV0gPSBNYXRoLnNxcnQodGhpc1s0XSAqIHRoaXNbNF0gKyB0aGlzWzVdICogdGhpc1s1XSArIHRoaXNbNl0gKiB0aGlzWzZdKTtcbiAgICByZXN1bHRbMl0gPSBNYXRoLnNxcnQodGhpc1s4XSAqIHRoaXNbOF0gKyB0aGlzWzldICogdGhpc1s5XSArIHRoaXNbMTBdICogdGhpc1sxMF0pO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICBnZXRUcmFuc2xhdGlvbihyZXN1bHQgPSBbLTAsIC0wLCAtMF0pIHtcbiAgICByZXN1bHRbMF0gPSB0aGlzWzEyXTtcbiAgICByZXN1bHRbMV0gPSB0aGlzWzEzXTtcbiAgICByZXN1bHRbMl0gPSB0aGlzWzE0XTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgZ2V0Um90YXRpb24ocmVzdWx0LCBzY2FsZVJlc3VsdCkge1xuICAgIHJlc3VsdCA9IHJlc3VsdCB8fCBbLTAsIC0wLCAtMCwgLTAsIC0wLCAtMCwgLTAsIC0wLCAtMCwgLTAsIC0wLCAtMCwgLTAsIC0wLCAtMCwgLTBdO1xuICAgIHNjYWxlUmVzdWx0ID0gc2NhbGVSZXN1bHQgfHwgWy0wLCAtMCwgLTBdO1xuICAgIGNvbnN0IHNjYWxlID0gdGhpcy5nZXRTY2FsZShzY2FsZVJlc3VsdCk7XG4gICAgY29uc3QgaW52ZXJzZVNjYWxlMCA9IDEgLyBzY2FsZVswXTtcbiAgICBjb25zdCBpbnZlcnNlU2NhbGUxID0gMSAvIHNjYWxlWzFdO1xuICAgIGNvbnN0IGludmVyc2VTY2FsZTIgPSAxIC8gc2NhbGVbMl07XG4gICAgcmVzdWx0WzBdID0gdGhpc1swXSAqIGludmVyc2VTY2FsZTA7XG4gICAgcmVzdWx0WzFdID0gdGhpc1sxXSAqIGludmVyc2VTY2FsZTE7XG4gICAgcmVzdWx0WzJdID0gdGhpc1syXSAqIGludmVyc2VTY2FsZTI7XG4gICAgcmVzdWx0WzNdID0gMDtcbiAgICByZXN1bHRbNF0gPSB0aGlzWzRdICogaW52ZXJzZVNjYWxlMDtcbiAgICByZXN1bHRbNV0gPSB0aGlzWzVdICogaW52ZXJzZVNjYWxlMTtcbiAgICByZXN1bHRbNl0gPSB0aGlzWzZdICogaW52ZXJzZVNjYWxlMjtcbiAgICByZXN1bHRbN10gPSAwO1xuICAgIHJlc3VsdFs4XSA9IHRoaXNbOF0gKiBpbnZlcnNlU2NhbGUwO1xuICAgIHJlc3VsdFs5XSA9IHRoaXNbOV0gKiBpbnZlcnNlU2NhbGUxO1xuICAgIHJlc3VsdFsxMF0gPSB0aGlzWzEwXSAqIGludmVyc2VTY2FsZTI7XG4gICAgcmVzdWx0WzExXSA9IDA7XG4gICAgcmVzdWx0WzEyXSA9IDA7XG4gICAgcmVzdWx0WzEzXSA9IDA7XG4gICAgcmVzdWx0WzE0XSA9IDA7XG4gICAgcmVzdWx0WzE1XSA9IDE7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIGdldFJvdGF0aW9uTWF0cml4MyhyZXN1bHQsIHNjYWxlUmVzdWx0KSB7XG4gICAgcmVzdWx0ID0gcmVzdWx0IHx8IFstMCwgLTAsIC0wLCAtMCwgLTAsIC0wLCAtMCwgLTAsIC0wXTtcbiAgICBzY2FsZVJlc3VsdCA9IHNjYWxlUmVzdWx0IHx8IFstMCwgLTAsIC0wXTtcbiAgICBjb25zdCBzY2FsZSA9IHRoaXMuZ2V0U2NhbGUoc2NhbGVSZXN1bHQpO1xuICAgIGNvbnN0IGludmVyc2VTY2FsZTAgPSAxIC8gc2NhbGVbMF07XG4gICAgY29uc3QgaW52ZXJzZVNjYWxlMSA9IDEgLyBzY2FsZVsxXTtcbiAgICBjb25zdCBpbnZlcnNlU2NhbGUyID0gMSAvIHNjYWxlWzJdO1xuICAgIHJlc3VsdFswXSA9IHRoaXNbMF0gKiBpbnZlcnNlU2NhbGUwO1xuICAgIHJlc3VsdFsxXSA9IHRoaXNbMV0gKiBpbnZlcnNlU2NhbGUxO1xuICAgIHJlc3VsdFsyXSA9IHRoaXNbMl0gKiBpbnZlcnNlU2NhbGUyO1xuICAgIHJlc3VsdFszXSA9IHRoaXNbNF0gKiBpbnZlcnNlU2NhbGUwO1xuICAgIHJlc3VsdFs0XSA9IHRoaXNbNV0gKiBpbnZlcnNlU2NhbGUxO1xuICAgIHJlc3VsdFs1XSA9IHRoaXNbNl0gKiBpbnZlcnNlU2NhbGUyO1xuICAgIHJlc3VsdFs2XSA9IHRoaXNbOF0gKiBpbnZlcnNlU2NhbGUwO1xuICAgIHJlc3VsdFs3XSA9IHRoaXNbOV0gKiBpbnZlcnNlU2NhbGUxO1xuICAgIHJlc3VsdFs4XSA9IHRoaXNbMTBdICogaW52ZXJzZVNjYWxlMjtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgdHJhbnNwb3NlKCkge1xuICAgIG1hdDQudHJhbnNwb3NlKHRoaXMsIHRoaXMpO1xuICAgIHJldHVybiB0aGlzLmNoZWNrKCk7XG4gIH1cblxuICBpbnZlcnQoKSB7XG4gICAgbWF0NC5pbnZlcnQodGhpcywgdGhpcyk7XG4gICAgcmV0dXJuIHRoaXMuY2hlY2soKTtcbiAgfVxuXG4gIG11bHRpcGx5TGVmdChhKSB7XG4gICAgbWF0NC5tdWx0aXBseSh0aGlzLCBhLCB0aGlzKTtcbiAgICByZXR1cm4gdGhpcy5jaGVjaygpO1xuICB9XG5cbiAgbXVsdGlwbHlSaWdodChhKSB7XG4gICAgbWF0NC5tdWx0aXBseSh0aGlzLCB0aGlzLCBhKTtcbiAgICByZXR1cm4gdGhpcy5jaGVjaygpO1xuICB9XG5cbiAgcm90YXRlWChyYWRpYW5zKSB7XG4gICAgbWF0NC5yb3RhdGVYKHRoaXMsIHRoaXMsIHJhZGlhbnMpO1xuICAgIHJldHVybiB0aGlzLmNoZWNrKCk7XG4gIH1cblxuICByb3RhdGVZKHJhZGlhbnMpIHtcbiAgICBtYXQ0LnJvdGF0ZVkodGhpcywgdGhpcywgcmFkaWFucyk7XG4gICAgcmV0dXJuIHRoaXMuY2hlY2soKTtcbiAgfVxuXG4gIHJvdGF0ZVoocmFkaWFucykge1xuICAgIG1hdDQucm90YXRlWih0aGlzLCB0aGlzLCByYWRpYW5zKTtcbiAgICByZXR1cm4gdGhpcy5jaGVjaygpO1xuICB9XG5cbiAgcm90YXRlWFlaKGFuZ2xlWFlaKSB7XG4gICAgcmV0dXJuIHRoaXMucm90YXRlWChhbmdsZVhZWlswXSkucm90YXRlWShhbmdsZVhZWlsxXSkucm90YXRlWihhbmdsZVhZWlsyXSk7XG4gIH1cblxuICByb3RhdGVBeGlzKHJhZGlhbnMsIGF4aXMpIHtcbiAgICBtYXQ0LnJvdGF0ZSh0aGlzLCB0aGlzLCByYWRpYW5zLCBheGlzKTtcbiAgICByZXR1cm4gdGhpcy5jaGVjaygpO1xuICB9XG5cbiAgc2NhbGUoZmFjdG9yKSB7XG4gICAgbWF0NC5zY2FsZSh0aGlzLCB0aGlzLCBBcnJheS5pc0FycmF5KGZhY3RvcikgPyBmYWN0b3IgOiBbZmFjdG9yLCBmYWN0b3IsIGZhY3Rvcl0pO1xuICAgIHJldHVybiB0aGlzLmNoZWNrKCk7XG4gIH1cblxuICB0cmFuc2xhdGUodmVjdG9yKSB7XG4gICAgbWF0NC50cmFuc2xhdGUodGhpcywgdGhpcywgdmVjdG9yKTtcbiAgICByZXR1cm4gdGhpcy5jaGVjaygpO1xuICB9XG5cbiAgdHJhbnNmb3JtKHZlY3RvciwgcmVzdWx0KSB7XG4gICAgaWYgKHZlY3Rvci5sZW5ndGggPT09IDQpIHtcbiAgICAgIHJlc3VsdCA9IHZlYzQudHJhbnNmb3JtTWF0NChyZXN1bHQgfHwgWy0wLCAtMCwgLTAsIC0wXSwgdmVjdG9yLCB0aGlzKTtcbiAgICAgIGNoZWNrVmVjdG9yKHJlc3VsdCwgNCk7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLnRyYW5zZm9ybUFzUG9pbnQodmVjdG9yLCByZXN1bHQpO1xuICB9XG5cbiAgdHJhbnNmb3JtQXNQb2ludCh2ZWN0b3IsIHJlc3VsdCkge1xuICAgIGNvbnN0IHtcbiAgICAgIGxlbmd0aFxuICAgIH0gPSB2ZWN0b3I7XG4gICAgbGV0IG91dDtcblxuICAgIHN3aXRjaCAobGVuZ3RoKSB7XG4gICAgICBjYXNlIDI6XG4gICAgICAgIG91dCA9IHZlYzIudHJhbnNmb3JtTWF0NChyZXN1bHQgfHwgWy0wLCAtMF0sIHZlY3RvciwgdGhpcyk7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlIDM6XG4gICAgICAgIG91dCA9IHZlYzMudHJhbnNmb3JtTWF0NChyZXN1bHQgfHwgWy0wLCAtMCwgLTBdLCB2ZWN0b3IsIHRoaXMpO1xuICAgICAgICBicmVhaztcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbGxlZ2FsIHZlY3RvcicpO1xuICAgIH1cblxuICAgIGNoZWNrVmVjdG9yKG91dCwgdmVjdG9yLmxlbmd0aCk7XG4gICAgcmV0dXJuIG91dDtcbiAgfVxuXG4gIHRyYW5zZm9ybUFzVmVjdG9yKHZlY3RvciwgcmVzdWx0KSB7XG4gICAgbGV0IG91dDtcblxuICAgIHN3aXRjaCAodmVjdG9yLmxlbmd0aCkge1xuICAgICAgY2FzZSAyOlxuICAgICAgICBvdXQgPSB2ZWMyX3RyYW5zZm9ybU1hdDRBc1ZlY3RvcihyZXN1bHQgfHwgWy0wLCAtMF0sIHZlY3RvciwgdGhpcyk7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlIDM6XG4gICAgICAgIG91dCA9IHZlYzNfdHJhbnNmb3JtTWF0NEFzVmVjdG9yKHJlc3VsdCB8fCBbLTAsIC0wLCAtMF0sIHZlY3RvciwgdGhpcyk7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0lsbGVnYWwgdmVjdG9yJyk7XG4gICAgfVxuXG4gICAgY2hlY2tWZWN0b3Iob3V0LCB2ZWN0b3IubGVuZ3RoKTtcbiAgICByZXR1cm4gb3V0O1xuICB9XG5cbiAgdHJhbnNmb3JtUG9pbnQodmVjdG9yLCByZXN1bHQpIHtcbiAgICByZXR1cm4gdGhpcy50cmFuc2Zvcm1Bc1BvaW50KHZlY3RvciwgcmVzdWx0KTtcbiAgfVxuXG4gIHRyYW5zZm9ybVZlY3Rvcih2ZWN0b3IsIHJlc3VsdCkge1xuICAgIHJldHVybiB0aGlzLnRyYW5zZm9ybUFzUG9pbnQodmVjdG9yLCByZXN1bHQpO1xuICB9XG5cbiAgdHJhbnNmb3JtRGlyZWN0aW9uKHZlY3RvciwgcmVzdWx0KSB7XG4gICAgcmV0dXJuIHRoaXMudHJhbnNmb3JtQXNWZWN0b3IodmVjdG9yLCByZXN1bHQpO1xuICB9XG5cbiAgbWFrZVJvdGF0aW9uWChyYWRpYW5zKSB7XG4gICAgcmV0dXJuIHRoaXMuaWRlbnRpdHkoKS5yb3RhdGVYKHJhZGlhbnMpO1xuICB9XG5cbiAgbWFrZVRyYW5zbGF0aW9uKHgsIHksIHopIHtcbiAgICByZXR1cm4gdGhpcy5pZGVudGl0eSgpLnRyYW5zbGF0ZShbeCwgeSwgel0pO1xuICB9XG5cbn1cbmxldCBaRVJPO1xubGV0IElERU5USVRZO1xuXG5mdW5jdGlvbiBnZXRaZXJvTWF0cml4KCkge1xuICBpZiAoIVpFUk8pIHtcbiAgICBaRVJPID0gbmV3IE1hdHJpeDQoWzAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDBdKTtcbiAgICBPYmplY3QuZnJlZXplKFpFUk8pO1xuICB9XG5cbiAgcmV0dXJuIFpFUk87XG59XG5cbmZ1bmN0aW9uIGdldElkZW50aXR5TWF0cml4KCkge1xuICBpZiAoIUlERU5USVRZKSB7XG4gICAgSURFTlRJVFkgPSBuZXcgTWF0cml4NCgpO1xuICAgIE9iamVjdC5mcmVlemUoSURFTlRJVFkpO1xuICB9XG5cbiAgcmV0dXJuIElERU5USVRZO1xufVxuXG5mdW5jdGlvbiBjaGVja1JhZGlhbnMocG9zc2libHlEZWdyZWVzKSB7XG4gIGlmIChwb3NzaWJseURlZ3JlZXMgPiBNYXRoLlBJICogMikge1xuICAgIHRocm93IEVycm9yKCdleHBlY3RlZCByYWRpYW5zJyk7XG4gIH1cbn1cblxuZnVuY3Rpb24gY29tcHV0ZUluZmluaXRlUGVyc3BlY3RpdmVPZmZDZW50ZXIocmVzdWx0LCBsZWZ0LCByaWdodCwgYm90dG9tLCB0b3AsIG5lYXIpIHtcbiAgY29uc3QgY29sdW1uMFJvdzAgPSAyICogbmVhciAvIChyaWdodCAtIGxlZnQpO1xuICBjb25zdCBjb2x1bW4xUm93MSA9IDIgKiBuZWFyIC8gKHRvcCAtIGJvdHRvbSk7XG4gIGNvbnN0IGNvbHVtbjJSb3cwID0gKHJpZ2h0ICsgbGVmdCkgLyAocmlnaHQgLSBsZWZ0KTtcbiAgY29uc3QgY29sdW1uMlJvdzEgPSAodG9wICsgYm90dG9tKSAvICh0b3AgLSBib3R0b20pO1xuICBjb25zdCBjb2x1bW4yUm93MiA9IC0xO1xuICBjb25zdCBjb2x1bW4yUm93MyA9IC0xO1xuICBjb25zdCBjb2x1bW4zUm93MiA9IC0yICogbmVhcjtcbiAgcmVzdWx0WzBdID0gY29sdW1uMFJvdzA7XG4gIHJlc3VsdFsxXSA9IDA7XG4gIHJlc3VsdFsyXSA9IDA7XG4gIHJlc3VsdFszXSA9IDA7XG4gIHJlc3VsdFs0XSA9IDA7XG4gIHJlc3VsdFs1XSA9IGNvbHVtbjFSb3cxO1xuICByZXN1bHRbNl0gPSAwO1xuICByZXN1bHRbN10gPSAwO1xuICByZXN1bHRbOF0gPSBjb2x1bW4yUm93MDtcbiAgcmVzdWx0WzldID0gY29sdW1uMlJvdzE7XG4gIHJlc3VsdFsxMF0gPSBjb2x1bW4yUm93MjtcbiAgcmVzdWx0WzExXSA9IGNvbHVtbjJSb3czO1xuICByZXN1bHRbMTJdID0gMDtcbiAgcmVzdWx0WzEzXSA9IDA7XG4gIHJlc3VsdFsxNF0gPSBjb2x1bW4zUm93MjtcbiAgcmVzdWx0WzE1XSA9IDA7XG4gIHJldHVybiByZXN1bHQ7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1tYXRyaXg0LmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///85451\n')},43897:function(__unused_webpack_module,__webpack_exports__,__webpack_require__){eval('\n// EXPORTS\n__webpack_require__.d(__webpack_exports__, {\n  "Z": function() { return /* binding */ Quaternion; }\n});\n\n// EXTERNAL MODULE: ./node_modules/@math.gl/core/dist/esm/classes/base/math-array.js\nvar math_array = __webpack_require__(6357);\n// EXTERNAL MODULE: ./node_modules/@math.gl/core/dist/esm/lib/validators.js\nvar validators = __webpack_require__(86281);\n// EXTERNAL MODULE: ./node_modules/@math.gl/core/dist/esm/classes/base/vector.js\nvar vector = __webpack_require__(89521);\n// EXTERNAL MODULE: ./node_modules/@math.gl/core/dist/esm/lib/common.js\nvar common = __webpack_require__(14034);\n// EXTERNAL MODULE: ./node_modules/gl-matrix/esm/vec3.js\nvar vec3 = __webpack_require__(77160);\n// EXTERNAL MODULE: ./node_modules/@math.gl/core/dist/esm/lib/gl-matrix-extras.js\nvar gl_matrix_extras = __webpack_require__(1031);\n;// CONCATENATED MODULE: ./node_modules/@math.gl/core/dist/esm/classes/vector4.js\n\n\n\n\n\nlet ZERO;\nclass Vector4 extends vector/* default */.Z {\n  static get ZERO() {\n    if (!ZERO) {\n      ZERO = new Vector4(0, 0, 0, 0);\n      Object.freeze(ZERO);\n    }\n\n    return ZERO;\n  }\n\n  constructor(x = 0, y = 0, z = 0, w = 0) {\n    super(-0, -0, -0, -0);\n\n    if ((0,common/* isArray */.kJ)(x) && arguments.length === 1) {\n      this.copy(x);\n    } else {\n      if (common/* config.debug */.vc.debug) {\n        (0,validators/* checkNumber */.u5)(x);\n        (0,validators/* checkNumber */.u5)(y);\n        (0,validators/* checkNumber */.u5)(z);\n        (0,validators/* checkNumber */.u5)(w);\n      }\n\n      this[0] = x;\n      this[1] = y;\n      this[2] = z;\n      this[3] = w;\n    }\n  }\n\n  set(x, y, z, w) {\n    this[0] = x;\n    this[1] = y;\n    this[2] = z;\n    this[3] = w;\n    return this.check();\n  }\n\n  copy(array) {\n    this[0] = array[0];\n    this[1] = array[1];\n    this[2] = array[2];\n    this[3] = array[3];\n    return this.check();\n  }\n\n  fromObject(object) {\n    if (common/* config.debug */.vc.debug) {\n      (0,validators/* checkNumber */.u5)(object.x);\n      (0,validators/* checkNumber */.u5)(object.y);\n      (0,validators/* checkNumber */.u5)(object.z);\n      (0,validators/* checkNumber */.u5)(object.w);\n    }\n\n    this[0] = object.x;\n    this[1] = object.y;\n    this[2] = object.z;\n    this[3] = object.w;\n    return this;\n  }\n\n  toObject(object) {\n    object.x = this[0];\n    object.y = this[1];\n    object.z = this[2];\n    object.w = this[3];\n    return object;\n  }\n\n  get ELEMENTS() {\n    return 4;\n  }\n\n  get z() {\n    return this[2];\n  }\n\n  set z(value) {\n    this[2] = (0,validators/* checkNumber */.u5)(value);\n  }\n\n  get w() {\n    return this[3];\n  }\n\n  set w(value) {\n    this[3] = (0,validators/* checkNumber */.u5)(value);\n  }\n\n  transform(matrix4) {\n    vec3/* transformMat4 */.fF(this, this, matrix4);\n    return this.check();\n  }\n\n  transformByMatrix3(matrix3) {\n    (0,gl_matrix_extras/* vec4_transformMat3 */._x)(this, this, matrix3);\n    return this.check();\n  }\n\n  transformByMatrix2(matrix2) {\n    (0,gl_matrix_extras/* vec4_transformMat2 */.G7)(this, this, matrix2);\n    return this.check();\n  }\n\n  transformByQuaternion(quaternion) {\n    vec3/* transformQuat */.VC(this, this, quaternion);\n    return this.check();\n  }\n\n  applyMatrix4(m) {\n    m.transform(this, this);\n    return this;\n  }\n\n}\n//# sourceMappingURL=vector4.js.map\n// EXTERNAL MODULE: ./node_modules/gl-matrix/esm/quat.js\nvar quat = __webpack_require__(32945);\n// EXTERNAL MODULE: ./node_modules/gl-matrix/esm/vec4.js\nvar vec4 = __webpack_require__(98333);\n;// CONCATENATED MODULE: ./node_modules/@math.gl/core/dist/esm/classes/quaternion.js\n\n\n\n\n\nconst IDENTITY_QUATERNION = [0, 0, 0, 1];\nclass Quaternion extends math_array/* default */.Z {\n  constructor(x = 0, y = 0, z = 0, w = 1) {\n    super(-0, -0, -0, -0);\n\n    if (Array.isArray(x) && arguments.length === 1) {\n      this.copy(x);\n    } else {\n      this.set(x, y, z, w);\n    }\n  }\n\n  copy(array) {\n    this[0] = array[0];\n    this[1] = array[1];\n    this[2] = array[2];\n    this[3] = array[3];\n    return this.check();\n  }\n\n  set(x, y, z, w) {\n    this[0] = x;\n    this[1] = y;\n    this[2] = z;\n    this[3] = w;\n    return this.check();\n  }\n\n  fromObject(object) {\n    this[0] = object.x;\n    this[1] = object.y;\n    this[2] = object.z;\n    this[3] = object.w;\n    return this.check();\n  }\n\n  fromMatrix3(m) {\n    quat/* fromMat3 */.bz(this, m);\n    return this.check();\n  }\n\n  fromAxisRotation(axis, rad) {\n    quat/* setAxisAngle */.yY(this, axis, rad);\n    return this.check();\n  }\n\n  identity() {\n    quat/* identity */.yR(this);\n    return this.check();\n  }\n\n  setAxisAngle(axis, rad) {\n    return this.fromAxisRotation(axis, rad);\n  }\n\n  get ELEMENTS() {\n    return 4;\n  }\n\n  get x() {\n    return this[0];\n  }\n\n  set x(value) {\n    this[0] = (0,validators/* checkNumber */.u5)(value);\n  }\n\n  get y() {\n    return this[1];\n  }\n\n  set y(value) {\n    this[1] = (0,validators/* checkNumber */.u5)(value);\n  }\n\n  get z() {\n    return this[2];\n  }\n\n  set z(value) {\n    this[2] = (0,validators/* checkNumber */.u5)(value);\n  }\n\n  get w() {\n    return this[3];\n  }\n\n  set w(value) {\n    this[3] = (0,validators/* checkNumber */.u5)(value);\n  }\n\n  len() {\n    return quat/* length */.kE(this);\n  }\n\n  lengthSquared() {\n    return quat/* squaredLength */.we(this);\n  }\n\n  dot(a) {\n    return quat/* dot */.AK(this, a);\n  }\n\n  rotationTo(vectorA, vectorB) {\n    quat/* rotationTo */.b0(this, vectorA, vectorB);\n    return this.check();\n  }\n\n  add(a) {\n    quat/* add */.IH(this, this, a);\n    return this.check();\n  }\n\n  calculateW() {\n    quat/* calculateW */.ZY(this, this);\n    return this.check();\n  }\n\n  conjugate() {\n    quat/* conjugate */.Kx(this, this);\n    return this.check();\n  }\n\n  invert() {\n    quat/* invert */.U_(this, this);\n    return this.check();\n  }\n\n  lerp(a, b, t) {\n    if (t === undefined) {\n      return this.lerp(this, a, b);\n    }\n\n    quat/* lerp */.t7(this, a, b, t);\n    return this.check();\n  }\n\n  multiplyRight(a) {\n    quat/* multiply */.Jp(this, this, a);\n    return this.check();\n  }\n\n  multiplyLeft(a) {\n    quat/* multiply */.Jp(this, a, this);\n    return this.check();\n  }\n\n  normalize() {\n    const length = this.len();\n    const l = length > 0 ? 1 / length : 0;\n    this[0] = this[0] * l;\n    this[1] = this[1] * l;\n    this[2] = this[2] * l;\n    this[3] = this[3] * l;\n\n    if (length === 0) {\n      this[3] = 1;\n    }\n\n    return this.check();\n  }\n\n  rotateX(rad) {\n    quat/* rotateX */.lM(this, this, rad);\n    return this.check();\n  }\n\n  rotateY(rad) {\n    quat/* rotateY */.uD(this, this, rad);\n    return this.check();\n  }\n\n  rotateZ(rad) {\n    quat/* rotateZ */.jI(this, this, rad);\n    return this.check();\n  }\n\n  scale(b) {\n    quat/* scale */.bA(this, this, b);\n    return this.check();\n  }\n\n  slerp(arg0, arg1, arg2) {\n    let start;\n    let target;\n    let ratio;\n\n    switch (arguments.length) {\n      case 1:\n        ({\n          start = IDENTITY_QUATERNION,\n          target,\n          ratio\n        } = arg0);\n        break;\n\n      case 2:\n        start = this;\n        target = arg0;\n        ratio = arg1;\n        break;\n\n      default:\n        start = arg0;\n        target = arg1;\n        ratio = arg2;\n    }\n\n    quat/* slerp */.ZA(this, start, target, ratio);\n    return this.check();\n  }\n\n  transformVector4(vector, result = new Vector4()) {\n    vec4/* transformQuat */.VC(result, vector, this);\n    return (0,validators/* checkVector */.IL)(result, 4);\n  }\n\n  lengthSq() {\n    return this.lengthSquared();\n  }\n\n  setFromAxisAngle(axis, rad) {\n    return this.setAxisAngle(axis, rad);\n  }\n\n  premultiply(a) {\n    return this.multiplyLeft(a);\n  }\n\n  multiply(a) {\n    return this.multiplyRight(a);\n  }\n\n}\n//# sourceMappingURL=quaternion.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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Q0E7O0FBRUE7QUFDQSxJQUFJLG9CQUFZO0FBQ2hCO0FBQ0E7O0FBRUE7QUFDQSxJQUFJLG9CQUFZO0FBQ2hCO0FBQ0E7O0FBRUE7QUFDQSxJQUFJLGtCQUFVO0FBQ2Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLElBQUksa0JBQVU7QUFDZDtBQUNBOztBQUVBLHdDQUF3QyxPQUFPO0FBQy9DLElBQUksMEJBQWtCO0FBQ3RCLFdBQVcsa0NBQVc7QUFDdEI7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly92dWUzLXdlYnBhY2s1Ly4vbm9kZV9tb2R1bGVzL0BtYXRoLmdsL2NvcmUvZGlzdC9lc20vY2xhc3Nlcy92ZWN0b3I0LmpzPzBiY2IiLCJ3ZWJwYWNrOi8vdnVlMy13ZWJwYWNrNS8uL25vZGVfbW9kdWxlcy9AbWF0aC5nbC9jb3JlL2Rpc3QvZXNtL2NsYXNzZXMvcXVhdGVybmlvbi5qcz82Mzc5Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBWZWN0b3IgZnJvbSAnLi9iYXNlL3ZlY3Rvcic7XG5pbXBvcnQgeyBjb25maWcsIGlzQXJyYXkgfSBmcm9tICcuLi9saWIvY29tbW9uJztcbmltcG9ydCB7IGNoZWNrTnVtYmVyIH0gZnJvbSAnLi4vbGliL3ZhbGlkYXRvcnMnO1xuaW1wb3J0ICogYXMgdmVjNCBmcm9tICdnbC1tYXRyaXgvdmVjMyc7XG5pbXBvcnQgeyB2ZWM0X3RyYW5zZm9ybU1hdDIsIHZlYzRfdHJhbnNmb3JtTWF0MyB9IGZyb20gJy4uL2xpYi9nbC1tYXRyaXgtZXh0cmFzJztcbmxldCBaRVJPO1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgVmVjdG9yNCBleHRlbmRzIFZlY3RvciB7XG4gIHN0YXRpYyBnZXQgWkVSTygpIHtcbiAgICBpZiAoIVpFUk8pIHtcbiAgICAgIFpFUk8gPSBuZXcgVmVjdG9yNCgwLCAwLCAwLCAwKTtcbiAgICAgIE9iamVjdC5mcmVlemUoWkVSTyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIFpFUk87XG4gIH1cblxuICBjb25zdHJ1Y3Rvcih4ID0gMCwgeSA9IDAsIHogPSAwLCB3ID0gMCkge1xuICAgIHN1cGVyKC0wLCAtMCwgLTAsIC0wKTtcblxuICAgIGlmIChpc0FycmF5KHgpICYmIGFyZ3VtZW50cy5sZW5ndGggPT09IDEpIHtcbiAgICAgIHRoaXMuY29weSh4KTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKGNvbmZpZy5kZWJ1Zykge1xuICAgICAgICBjaGVja051bWJlcih4KTtcbiAgICAgICAgY2hlY2tOdW1iZXIoeSk7XG4gICAgICAgIGNoZWNrTnVtYmVyKHopO1xuICAgICAgICBjaGVja051bWJlcih3KTtcbiAgICAgIH1cblxuICAgICAgdGhpc1swXSA9IHg7XG4gICAgICB0aGlzWzFdID0geTtcbiAgICAgIHRoaXNbMl0gPSB6O1xuICAgICAgdGhpc1szXSA9IHc7XG4gICAgfVxuICB9XG5cbiAgc2V0KHgsIHksIHosIHcpIHtcbiAgICB0aGlzWzBdID0geDtcbiAgICB0aGlzWzFdID0geTtcbiAgICB0aGlzWzJdID0gejtcbiAgICB0aGlzWzNdID0gdztcbiAgICByZXR1cm4gdGhpcy5jaGVjaygpO1xuICB9XG5cbiAgY29weShhcnJheSkge1xuICAgIHRoaXNbMF0gPSBhcnJheVswXTtcbiAgICB0aGlzWzFdID0gYXJyYXlbMV07XG4gICAgdGhpc1syXSA9IGFycmF5WzJdO1xuICAgIHRoaXNbM10gPSBhcnJheVszXTtcbiAgICByZXR1cm4gdGhpcy5jaGVjaygpO1xuICB9XG5cbiAgZnJvbU9iamVjdChvYmplY3QpIHtcbiAgICBpZiAoY29uZmlnLmRlYnVnKSB7XG4gICAgICBjaGVja051bWJlcihvYmplY3QueCk7XG4gICAgICBjaGVja051bWJlcihvYmplY3QueSk7XG4gICAgICBjaGVja051bWJlcihvYmplY3Queik7XG4gICAgICBjaGVja051bWJlcihvYmplY3Qudyk7XG4gICAgfVxuXG4gICAgdGhpc1swXSA9IG9iamVjdC54O1xuICAgIHRoaXNbMV0gPSBvYmplY3QueTtcbiAgICB0aGlzWzJdID0gb2JqZWN0Lno7XG4gICAgdGhpc1szXSA9IG9iamVjdC53O1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgdG9PYmplY3Qob2JqZWN0KSB7XG4gICAgb2JqZWN0LnggPSB0aGlzWzBdO1xuICAgIG9iamVjdC55ID0gdGhpc1sxXTtcbiAgICBvYmplY3QueiA9IHRoaXNbMl07XG4gICAgb2JqZWN0LncgPSB0aGlzWzNdO1xuICAgIHJldHVybiBvYmplY3Q7XG4gIH1cblxuICBnZXQgRUxFTUVOVFMoKSB7XG4gICAgcmV0dXJuIDQ7XG4gIH1cblxuICBnZXQgeigpIHtcbiAgICByZXR1cm4gdGhpc1syXTtcbiAgfVxuXG4gIHNldCB6KHZhbHVlKSB7XG4gICAgdGhpc1syXSA9IGNoZWNrTnVtYmVyKHZhbHVlKTtcbiAgfVxuXG4gIGdldCB3KCkge1xuICAgIHJldHVybiB0aGlzWzNdO1xuICB9XG5cbiAgc2V0IHcodmFsdWUpIHtcbiAgICB0aGlzWzNdID0gY2hlY2tOdW1iZXIodmFsdWUpO1xuICB9XG5cbiAgdHJhbnNmb3JtKG1hdHJpeDQpIHtcbiAgICB2ZWM0LnRyYW5zZm9ybU1hdDQodGhpcywgdGhpcywgbWF0cml4NCk7XG4gICAgcmV0dXJuIHRoaXMuY2hlY2soKTtcbiAgfVxuXG4gIHRyYW5zZm9ybUJ5TWF0cml4MyhtYXRyaXgzKSB7XG4gICAgdmVjNF90cmFuc2Zvcm1NYXQzKHRoaXMsIHRoaXMsIG1hdHJpeDMpO1xuICAgIHJldHVybiB0aGlzLmNoZWNrKCk7XG4gIH1cblxuICB0cmFuc2Zvcm1CeU1hdHJpeDIobWF0cml4Mikge1xuICAgIHZlYzRfdHJhbnNmb3JtTWF0Mih0aGlzLCB0aGlzLCBtYXRyaXgyKTtcbiAgICByZXR1cm4gdGhpcy5jaGVjaygpO1xuICB9XG5cbiAgdHJhbnNmb3JtQnlRdWF0ZXJuaW9uKHF1YXRlcm5pb24pIHtcbiAgICB2ZWM0LnRyYW5zZm9ybVF1YXQodGhpcywgdGhpcywgcXVhdGVybmlvbik7XG4gICAgcmV0dXJuIHRoaXMuY2hlY2soKTtcbiAgfVxuXG4gIGFwcGx5TWF0cml4NChtKSB7XG4gICAgbS50cmFuc2Zvcm0odGhpcywgdGhpcyk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dmVjdG9yNC5qcy5tYXAiLCJpbXBvcnQgTWF0aEFycmF5IGZyb20gJy4vYmFzZS9tYXRoLWFycmF5JztcbmltcG9ydCB7IGNoZWNrTnVtYmVyLCBjaGVja1ZlY3RvciB9IGZyb20gJy4uL2xpYi92YWxpZGF0b3JzJztcbmltcG9ydCBWZWN0b3I0IGZyb20gJy4vdmVjdG9yNCc7XG5pbXBvcnQgKiBhcyBxdWF0IGZyb20gJ2dsLW1hdHJpeC9xdWF0JztcbmltcG9ydCAqIGFzIHZlYzQgZnJvbSAnZ2wtbWF0cml4L3ZlYzQnO1xuY29uc3QgSURFTlRJVFlfUVVBVEVSTklPTiA9IFswLCAwLCAwLCAxXTtcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFF1YXRlcm5pb24gZXh0ZW5kcyBNYXRoQXJyYXkge1xuICBjb25zdHJ1Y3Rvcih4ID0gMCwgeSA9IDAsIHogPSAwLCB3ID0gMSkge1xuICAgIHN1cGVyKC0wLCAtMCwgLTAsIC0wKTtcblxuICAgIGlmIChBcnJheS5pc0FycmF5KHgpICYmIGFyZ3VtZW50cy5sZW5ndGggPT09IDEpIHtcbiAgICAgIHRoaXMuY29weSh4KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5zZXQoeCwgeSwgeiwgdyk7XG4gICAgfVxuICB9XG5cbiAgY29weShhcnJheSkge1xuICAgIHRoaXNbMF0gPSBhcnJheVswXTtcbiAgICB0aGlzWzFdID0gYXJyYXlbMV07XG4gICAgdGhpc1syXSA9IGFycmF5WzJdO1xuICAgIHRoaXNbM10gPSBhcnJheVszXTtcbiAgICByZXR1cm4gdGhpcy5jaGVjaygpO1xuICB9XG5cbiAgc2V0KHgsIHksIHosIHcpIHtcbiAgICB0aGlzWzBdID0geDtcbiAgICB0aGlzWzFdID0geTtcbiAgICB0aGlzWzJdID0gejtcbiAgICB0aGlzWzNdID0gdztcbiAgICByZXR1cm4gdGhpcy5jaGVjaygpO1xuICB9XG5cbiAgZnJvbU9iamVjdChvYmplY3QpIHtcbiAgICB0aGlzWzBdID0gb2JqZWN0Lng7XG4gICAgdGhpc1sxXSA9IG9iamVjdC55O1xuICAgIHRoaXNbMl0gPSBvYmplY3QuejtcbiAgICB0aGlzWzNdID0gb2JqZWN0Lnc7XG4gICAgcmV0dXJuIHRoaXMuY2hlY2soKTtcbiAgfVxuXG4gIGZyb21NYXRyaXgzKG0pIHtcbiAgICBxdWF0LmZyb21NYXQzKHRoaXMsIG0pO1xuICAgIHJldHVybiB0aGlzLmNoZWNrKCk7XG4gIH1cblxuICBmcm9tQXhpc1JvdGF0aW9uKGF4aXMsIHJhZCkge1xuICAgIHF1YXQuc2V0QXhpc0FuZ2xlKHRoaXMsIGF4aXMsIHJhZCk7XG4gICAgcmV0dXJuIHRoaXMuY2hlY2soKTtcbiAgfVxuXG4gIGlkZW50aXR5KCkge1xuICAgIHF1YXQuaWRlbnRpdHkodGhpcyk7XG4gICAgcmV0dXJuIHRoaXMuY2hlY2soKTtcbiAgfVxuXG4gIHNldEF4aXNBbmdsZShheGlzLCByYWQpIHtcbiAgICByZXR1cm4gdGhpcy5mcm9tQXhpc1JvdGF0aW9uKGF4aXMsIHJhZCk7XG4gIH1cblxuICBnZXQgRUxFTUVOVFMoKSB7XG4gICAgcmV0dXJuIDQ7XG4gIH1cblxuICBnZXQgeCgpIHtcbiAgICByZXR1cm4gdGhpc1swXTtcbiAgfVxuXG4gIHNldCB4KHZhbHVlKSB7XG4gICAgdGhpc1swXSA9IGNoZWNrTnVtYmVyKHZhbHVlKTtcbiAgfVxuXG4gIGdldCB5KCkge1xuICAgIHJldHVybiB0aGlzWzFdO1xuICB9XG5cbiAgc2V0IHkodmFsdWUpIHtcbiAgICB0aGlzWzFdID0gY2hlY2tOdW1iZXIodmFsdWUpO1xuICB9XG5cbiAgZ2V0IHooKSB7XG4gICAgcmV0dXJuIHRoaXNbMl07XG4gIH1cblxuICBzZXQgeih2YWx1ZSkge1xuICAgIHRoaXNbMl0gPSBjaGVja051bWJlcih2YWx1ZSk7XG4gIH1cblxuICBnZXQgdygpIHtcbiAgICByZXR1cm4gdGhpc1szXTtcbiAgfVxuXG4gIHNldCB3KHZhbHVlKSB7XG4gICAgdGhpc1szXSA9IGNoZWNrTnVtYmVyKHZhbHVlKTtcbiAgfVxuXG4gIGxlbigpIHtcbiAgICByZXR1cm4gcXVhdC5sZW5ndGgodGhpcyk7XG4gIH1cblxuICBsZW5ndGhTcXVhcmVkKCkge1xuICAgIHJldHVybiBxdWF0LnNxdWFyZWRMZW5ndGgodGhpcyk7XG4gIH1cblxuICBkb3QoYSkge1xuICAgIHJldHVybiBxdWF0LmRvdCh0aGlzLCBhKTtcbiAgfVxuXG4gIHJvdGF0aW9uVG8odmVjdG9yQSwgdmVjdG9yQikge1xuICAgIHF1YXQucm90YXRpb25Ubyh0aGlzLCB2ZWN0b3JBLCB2ZWN0b3JCKTtcbiAgICByZXR1cm4gdGhpcy5jaGVjaygpO1xuICB9XG5cbiAgYWRkKGEpIHtcbiAgICBxdWF0LmFkZCh0aGlzLCB0aGlzLCBhKTtcbiAgICByZXR1cm4gdGhpcy5jaGVjaygpO1xuICB9XG5cbiAgY2FsY3VsYXRlVygpIHtcbiAgICBxdWF0LmNhbGN1bGF0ZVcodGhpcywgdGhpcyk7XG4gICAgcmV0dXJuIHRoaXMuY2hlY2soKTtcbiAgfVxuXG4gIGNvbmp1Z2F0ZSgpIHtcbiAgICBxdWF0LmNvbmp1Z2F0ZSh0aGlzLCB0aGlzKTtcbiAgICByZXR1cm4gdGhpcy5jaGVjaygpO1xuICB9XG5cbiAgaW52ZXJ0KCkge1xuICAgIHF1YXQuaW52ZXJ0KHRoaXMsIHRoaXMpO1xuICAgIHJldHVybiB0aGlzLmNoZWNrKCk7XG4gIH1cblxuICBsZXJwKGEsIGIsIHQpIHtcbiAgICBpZiAodCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gdGhpcy5sZXJwKHRoaXMsIGEsIGIpO1xuICAgIH1cblxuICAgIHF1YXQubGVycCh0aGlzLCBhLCBiLCB0KTtcbiAgICByZXR1cm4gdGhpcy5jaGVjaygpO1xuICB9XG5cbiAgbXVsdGlwbHlSaWdodChhKSB7XG4gICAgcXVhdC5tdWx0aXBseSh0aGlzLCB0aGlzLCBhKTtcbiAgICByZXR1cm4gdGhpcy5jaGVjaygpO1xuICB9XG5cbiAgbXVsdGlwbHlMZWZ0KGEpIHtcbiAgICBxdWF0Lm11bHRpcGx5KHRoaXMsIGEsIHRoaXMpO1xuICAgIHJldHVybiB0aGlzLmNoZWNrKCk7XG4gIH1cblxuICBub3JtYWxpemUoKSB7XG4gICAgY29uc3QgbGVuZ3RoID0gdGhpcy5sZW4oKTtcbiAgICBjb25zdCBsID0gbGVuZ3RoID4gMCA/IDEgLyBsZW5ndGggOiAwO1xuICAgIHRoaXNbMF0gPSB0aGlzWzBdICogbDtcbiAgICB0aGlzWzFdID0gdGhpc1sxXSAqIGw7XG4gICAgdGhpc1syXSA9IHRoaXNbMl0gKiBsO1xuICAgIHRoaXNbM10gPSB0aGlzWzNdICogbDtcblxuICAgIGlmIChsZW5ndGggPT09IDApIHtcbiAgICAgIHRoaXNbM10gPSAxO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLmNoZWNrKCk7XG4gIH1cblxuICByb3RhdGVYKHJhZCkge1xuICAgIHF1YXQucm90YXRlWCh0aGlzLCB0aGlzLCByYWQpO1xuICAgIHJldHVybiB0aGlzLmNoZWNrKCk7XG4gIH1cblxuICByb3RhdGVZKHJhZCkge1xuICAgIHF1YXQucm90YXRlWSh0aGlzLCB0aGlzLCByYWQpO1xuICAgIHJldHVybiB0aGlzLmNoZWNrKCk7XG4gIH1cblxuICByb3RhdGVaKHJhZCkge1xuICAgIHF1YXQucm90YXRlWih0aGlzLCB0aGlzLCByYWQpO1xuICAgIHJldHVybiB0aGlzLmNoZWNrKCk7XG4gIH1cblxuICBzY2FsZShiKSB7XG4gICAgcXVhdC5zY2FsZSh0aGlzLCB0aGlzLCBiKTtcbiAgICByZXR1cm4gdGhpcy5jaGVjaygpO1xuICB9XG5cbiAgc2xlcnAoYXJnMCwgYXJnMSwgYXJnMikge1xuICAgIGxldCBzdGFydDtcbiAgICBsZXQgdGFyZ2V0O1xuICAgIGxldCByYXRpbztcblxuICAgIHN3aXRjaCAoYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgY2FzZSAxOlxuICAgICAgICAoe1xuICAgICAgICAgIHN0YXJ0ID0gSURFTlRJVFlfUVVBVEVSTklPTixcbiAgICAgICAgICB0YXJnZXQsXG4gICAgICAgICAgcmF0aW9cbiAgICAgICAgfSA9IGFyZzApO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSAyOlxuICAgICAgICBzdGFydCA9IHRoaXM7XG4gICAgICAgIHRhcmdldCA9IGFyZzA7XG4gICAgICAgIHJhdGlvID0gYXJnMTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHN0YXJ0ID0gYXJnMDtcbiAgICAgICAgdGFyZ2V0ID0gYXJnMTtcbiAgICAgICAgcmF0aW8gPSBhcmcyO1xuICAgIH1cblxuICAgIHF1YXQuc2xlcnAodGhpcywgc3RhcnQsIHRhcmdldCwgcmF0aW8pO1xuICAgIHJldHVybiB0aGlzLmNoZWNrKCk7XG4gIH1cblxuICB0cmFuc2Zvcm1WZWN0b3I0KHZlY3RvciwgcmVzdWx0ID0gbmV3IFZlY3RvcjQoKSkge1xuICAgIHZlYzQudHJhbnNmb3JtUXVhdChyZXN1bHQsIHZlY3RvciwgdGhpcyk7XG4gICAgcmV0dXJuIGNoZWNrVmVjdG9yKHJlc3VsdCwgNCk7XG4gIH1cblxuICBsZW5ndGhTcSgpIHtcbiAgICByZXR1cm4gdGhpcy5sZW5ndGhTcXVhcmVkKCk7XG4gIH1cblxuICBzZXRGcm9tQXhpc0FuZ2xlKGF4aXMsIHJhZCkge1xuICAgIHJldHVybiB0aGlzLnNldEF4aXNBbmdsZShheGlzLCByYWQpO1xuICB9XG5cbiAgcHJlbXVsdGlwbHkoYSkge1xuICAgIHJldHVybiB0aGlzLm11bHRpcGx5TGVmdChhKTtcbiAgfVxuXG4gIG11bHRpcGx5KGEpIHtcbiAgICByZXR1cm4gdGhpcy5tdWx0aXBseVJpZ2h0KGEpO1xuICB9XG5cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXF1YXRlcm5pb24uanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///43897\n')},43855:function(__unused_webpack_module,__webpack_exports__,__webpack_require__){eval('/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "Z": function() { return /* binding */ Vector3; }\n/* harmony export */ });\n/* harmony import */ var _base_vector__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(89521);\n/* harmony import */ var _lib_common__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(14034);\n/* harmony import */ var _lib_validators__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(86281);\n/* harmony import */ var gl_matrix_vec3__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(77160);\n/* harmony import */ var _lib_gl_matrix_extras__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(1031);\n\n\n\n\n\nconst ORIGIN = [0, 0, 0];\nlet ZERO;\nclass Vector3 extends _base_vector__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .Z {\n  static get ZERO() {\n    if (!ZERO) {\n      ZERO = new Vector3(0, 0, 0);\n      Object.freeze(ZERO);\n    }\n\n    return ZERO;\n  }\n\n  constructor(x = 0, y = 0, z = 0) {\n    super(-0, -0, -0);\n\n    if (arguments.length === 1 && (0,_lib_common__WEBPACK_IMPORTED_MODULE_1__/* .isArray */ .kJ)(x)) {\n      this.copy(x);\n    } else {\n      if (_lib_common__WEBPACK_IMPORTED_MODULE_1__/* .config.debug */ .vc.debug) {\n        (0,_lib_validators__WEBPACK_IMPORTED_MODULE_2__/* .checkNumber */ .u5)(x);\n        (0,_lib_validators__WEBPACK_IMPORTED_MODULE_2__/* .checkNumber */ .u5)(y);\n        (0,_lib_validators__WEBPACK_IMPORTED_MODULE_2__/* .checkNumber */ .u5)(z);\n      }\n\n      this[0] = x;\n      this[1] = y;\n      this[2] = z;\n    }\n  }\n\n  set(x, y, z) {\n    this[0] = x;\n    this[1] = y;\n    this[2] = z;\n    return this.check();\n  }\n\n  copy(array) {\n    this[0] = array[0];\n    this[1] = array[1];\n    this[2] = array[2];\n    return this.check();\n  }\n\n  fromObject(object) {\n    if (_lib_common__WEBPACK_IMPORTED_MODULE_1__/* .config.debug */ .vc.debug) {\n      (0,_lib_validators__WEBPACK_IMPORTED_MODULE_2__/* .checkNumber */ .u5)(object.x);\n      (0,_lib_validators__WEBPACK_IMPORTED_MODULE_2__/* .checkNumber */ .u5)(object.y);\n      (0,_lib_validators__WEBPACK_IMPORTED_MODULE_2__/* .checkNumber */ .u5)(object.z);\n    }\n\n    this[0] = object.x;\n    this[1] = object.y;\n    this[2] = object.z;\n    return this.check();\n  }\n\n  toObject(object) {\n    object.x = this[0];\n    object.y = this[1];\n    object.z = this[2];\n    return object;\n  }\n\n  get ELEMENTS() {\n    return 3;\n  }\n\n  get z() {\n    return this[2];\n  }\n\n  set z(value) {\n    this[2] = (0,_lib_validators__WEBPACK_IMPORTED_MODULE_2__/* .checkNumber */ .u5)(value);\n  }\n\n  angle(vector) {\n    return gl_matrix_vec3__WEBPACK_IMPORTED_MODULE_3__/* .angle */ .EU(this, vector);\n  }\n\n  cross(vector) {\n    gl_matrix_vec3__WEBPACK_IMPORTED_MODULE_3__/* .cross */ .kC(this, this, vector);\n    return this.check();\n  }\n\n  rotateX({\n    radians,\n    origin = ORIGIN\n  }) {\n    gl_matrix_vec3__WEBPACK_IMPORTED_MODULE_3__/* .rotateX */ .lM(this, this, origin, radians);\n    return this.check();\n  }\n\n  rotateY({\n    radians,\n    origin = ORIGIN\n  }) {\n    gl_matrix_vec3__WEBPACK_IMPORTED_MODULE_3__/* .rotateY */ .uD(this, this, origin, radians);\n    return this.check();\n  }\n\n  rotateZ({\n    radians,\n    origin = ORIGIN\n  }) {\n    gl_matrix_vec3__WEBPACK_IMPORTED_MODULE_3__/* .rotateZ */ .jI(this, this, origin, radians);\n    return this.check();\n  }\n\n  transform(matrix4) {\n    return this.transformAsPoint(matrix4);\n  }\n\n  transformAsPoint(matrix4) {\n    gl_matrix_vec3__WEBPACK_IMPORTED_MODULE_3__/* .transformMat4 */ .fF(this, this, matrix4);\n    return this.check();\n  }\n\n  transformAsVector(matrix4) {\n    (0,_lib_gl_matrix_extras__WEBPACK_IMPORTED_MODULE_4__/* .vec3_transformMat4AsVector */ .pL)(this, this, matrix4);\n    return this.check();\n  }\n\n  transformByMatrix3(matrix3) {\n    gl_matrix_vec3__WEBPACK_IMPORTED_MODULE_3__/* .transformMat3 */ .kK(this, this, matrix3);\n    return this.check();\n  }\n\n  transformByMatrix2(matrix2) {\n    (0,_lib_gl_matrix_extras__WEBPACK_IMPORTED_MODULE_4__/* .vec3_transformMat2 */ .eQ)(this, this, matrix2);\n    return this.check();\n  }\n\n  transformByQuaternion(quaternion) {\n    gl_matrix_vec3__WEBPACK_IMPORTED_MODULE_3__/* .transformQuat */ .VC(this, this, quaternion);\n    return this.check();\n  }\n\n}\n//# sourceMappingURL=vector3.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNDM4NTUuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFBbUM7QUFDYTtBQUNBO0FBQ1Q7QUFDa0Q7QUFDekY7QUFDQTtBQUNlLHNCQUFzQiw2REFBTTtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxrQ0FBa0MsOERBQU87QUFDekM7QUFDQSxNQUFNO0FBQ04sVUFBVSxxRUFBWTtBQUN0QixRQUFRLHNFQUFXO0FBQ25CLFFBQVEsc0VBQVc7QUFDbkIsUUFBUSxzRUFBVztBQUNuQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxRQUFRLHFFQUFZO0FBQ3BCLE1BQU0sc0VBQVc7QUFDakIsTUFBTSxzRUFBVztBQUNqQixNQUFNLHNFQUFXO0FBQ2pCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxjQUFjLHNFQUFXO0FBQ3pCOztBQUVBO0FBQ0EsV0FBVywyREFBVTtBQUNyQjs7QUFFQTtBQUNBLElBQUksMkRBQVU7QUFDZDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxJQUFJLDZEQUFZO0FBQ2hCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILElBQUksNkRBQVk7QUFDaEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsSUFBSSw2REFBWTtBQUNoQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLElBQUksbUVBQWtCO0FBQ3RCO0FBQ0E7O0FBRUE7QUFDQSxJQUFJLDJGQUEwQjtBQUM5QjtBQUNBOztBQUVBO0FBQ0EsSUFBSSxtRUFBa0I7QUFDdEI7QUFDQTs7QUFFQTtBQUNBLElBQUksbUZBQWtCO0FBQ3RCO0FBQ0E7O0FBRUE7QUFDQSxJQUFJLG1FQUFrQjtBQUN0QjtBQUNBOztBQUVBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly92dWUzLXdlYnBhY2s1Ly4vbm9kZV9tb2R1bGVzL0BtYXRoLmdsL2NvcmUvZGlzdC9lc20vY2xhc3Nlcy92ZWN0b3IzLmpzP2Q0ZmQiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IFZlY3RvciBmcm9tICcuL2Jhc2UvdmVjdG9yJztcbmltcG9ydCB7IGNvbmZpZywgaXNBcnJheSB9IGZyb20gJy4uL2xpYi9jb21tb24nO1xuaW1wb3J0IHsgY2hlY2tOdW1iZXIgfSBmcm9tICcuLi9saWIvdmFsaWRhdG9ycyc7XG5pbXBvcnQgKiBhcyB2ZWMzIGZyb20gJ2dsLW1hdHJpeC92ZWMzJztcbmltcG9ydCB7IHZlYzNfdHJhbnNmb3JtTWF0MiwgdmVjM190cmFuc2Zvcm1NYXQ0QXNWZWN0b3IgfSBmcm9tICcuLi9saWIvZ2wtbWF0cml4LWV4dHJhcyc7XG5jb25zdCBPUklHSU4gPSBbMCwgMCwgMF07XG5sZXQgWkVSTztcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFZlY3RvcjMgZXh0ZW5kcyBWZWN0b3Ige1xuICBzdGF0aWMgZ2V0IFpFUk8oKSB7XG4gICAgaWYgKCFaRVJPKSB7XG4gICAgICBaRVJPID0gbmV3IFZlY3RvcjMoMCwgMCwgMCk7XG4gICAgICBPYmplY3QuZnJlZXplKFpFUk8pO1xuICAgIH1cblxuICAgIHJldHVybiBaRVJPO1xuICB9XG5cbiAgY29uc3RydWN0b3IoeCA9IDAsIHkgPSAwLCB6ID0gMCkge1xuICAgIHN1cGVyKC0wLCAtMCwgLTApO1xuXG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEgJiYgaXNBcnJheSh4KSkge1xuICAgICAgdGhpcy5jb3B5KHgpO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoY29uZmlnLmRlYnVnKSB7XG4gICAgICAgIGNoZWNrTnVtYmVyKHgpO1xuICAgICAgICBjaGVja051bWJlcih5KTtcbiAgICAgICAgY2hlY2tOdW1iZXIoeik7XG4gICAgICB9XG5cbiAgICAgIHRoaXNbMF0gPSB4O1xuICAgICAgdGhpc1sxXSA9IHk7XG4gICAgICB0aGlzWzJdID0gejtcbiAgICB9XG4gIH1cblxuICBzZXQoeCwgeSwgeikge1xuICAgIHRoaXNbMF0gPSB4O1xuICAgIHRoaXNbMV0gPSB5O1xuICAgIHRoaXNbMl0gPSB6O1xuICAgIHJldHVybiB0aGlzLmNoZWNrKCk7XG4gIH1cblxuICBjb3B5KGFycmF5KSB7XG4gICAgdGhpc1swXSA9IGFycmF5WzBdO1xuICAgIHRoaXNbMV0gPSBhcnJheVsxXTtcbiAgICB0aGlzWzJdID0gYXJyYXlbMl07XG4gICAgcmV0dXJuIHRoaXMuY2hlY2soKTtcbiAgfVxuXG4gIGZyb21PYmplY3Qob2JqZWN0KSB7XG4gICAgaWYgKGNvbmZpZy5kZWJ1Zykge1xuICAgICAgY2hlY2tOdW1iZXIob2JqZWN0LngpO1xuICAgICAgY2hlY2tOdW1iZXIob2JqZWN0LnkpO1xuICAgICAgY2hlY2tOdW1iZXIob2JqZWN0LnopO1xuICAgIH1cblxuICAgIHRoaXNbMF0gPSBvYmplY3QueDtcbiAgICB0aGlzWzFdID0gb2JqZWN0Lnk7XG4gICAgdGhpc1syXSA9IG9iamVjdC56O1xuICAgIHJldHVybiB0aGlzLmNoZWNrKCk7XG4gIH1cblxuICB0b09iamVjdChvYmplY3QpIHtcbiAgICBvYmplY3QueCA9IHRoaXNbMF07XG4gICAgb2JqZWN0LnkgPSB0aGlzWzFdO1xuICAgIG9iamVjdC56ID0gdGhpc1syXTtcbiAgICByZXR1cm4gb2JqZWN0O1xuICB9XG5cbiAgZ2V0IEVMRU1FTlRTKCkge1xuICAgIHJldHVybiAzO1xuICB9XG5cbiAgZ2V0IHooKSB7XG4gICAgcmV0dXJuIHRoaXNbMl07XG4gIH1cblxuICBzZXQgeih2YWx1ZSkge1xuICAgIHRoaXNbMl0gPSBjaGVja051bWJlcih2YWx1ZSk7XG4gIH1cblxuICBhbmdsZSh2ZWN0b3IpIHtcbiAgICByZXR1cm4gdmVjMy5hbmdsZSh0aGlzLCB2ZWN0b3IpO1xuICB9XG5cbiAgY3Jvc3ModmVjdG9yKSB7XG4gICAgdmVjMy5jcm9zcyh0aGlzLCB0aGlzLCB2ZWN0b3IpO1xuICAgIHJldHVybiB0aGlzLmNoZWNrKCk7XG4gIH1cblxuICByb3RhdGVYKHtcbiAgICByYWRpYW5zLFxuICAgIG9yaWdpbiA9IE9SSUdJTlxuICB9KSB7XG4gICAgdmVjMy5yb3RhdGVYKHRoaXMsIHRoaXMsIG9yaWdpbiwgcmFkaWFucyk7XG4gICAgcmV0dXJuIHRoaXMuY2hlY2soKTtcbiAgfVxuXG4gIHJvdGF0ZVkoe1xuICAgIHJhZGlhbnMsXG4gICAgb3JpZ2luID0gT1JJR0lOXG4gIH0pIHtcbiAgICB2ZWMzLnJvdGF0ZVkodGhpcywgdGhpcywgb3JpZ2luLCByYWRpYW5zKTtcbiAgICByZXR1cm4gdGhpcy5jaGVjaygpO1xuICB9XG5cbiAgcm90YXRlWih7XG4gICAgcmFkaWFucyxcbiAgICBvcmlnaW4gPSBPUklHSU5cbiAgfSkge1xuICAgIHZlYzMucm90YXRlWih0aGlzLCB0aGlzLCBvcmlnaW4sIHJhZGlhbnMpO1xuICAgIHJldHVybiB0aGlzLmNoZWNrKCk7XG4gIH1cblxuICB0cmFuc2Zvcm0obWF0cml4NCkge1xuICAgIHJldHVybiB0aGlzLnRyYW5zZm9ybUFzUG9pbnQobWF0cml4NCk7XG4gIH1cblxuICB0cmFuc2Zvcm1Bc1BvaW50KG1hdHJpeDQpIHtcbiAgICB2ZWMzLnRyYW5zZm9ybU1hdDQodGhpcywgdGhpcywgbWF0cml4NCk7XG4gICAgcmV0dXJuIHRoaXMuY2hlY2soKTtcbiAgfVxuXG4gIHRyYW5zZm9ybUFzVmVjdG9yKG1hdHJpeDQpIHtcbiAgICB2ZWMzX3RyYW5zZm9ybU1hdDRBc1ZlY3Rvcih0aGlzLCB0aGlzLCBtYXRyaXg0KTtcbiAgICByZXR1cm4gdGhpcy5jaGVjaygpO1xuICB9XG5cbiAgdHJhbnNmb3JtQnlNYXRyaXgzKG1hdHJpeDMpIHtcbiAgICB2ZWMzLnRyYW5zZm9ybU1hdDModGhpcywgdGhpcywgbWF0cml4Myk7XG4gICAgcmV0dXJuIHRoaXMuY2hlY2soKTtcbiAgfVxuXG4gIHRyYW5zZm9ybUJ5TWF0cml4MihtYXRyaXgyKSB7XG4gICAgdmVjM190cmFuc2Zvcm1NYXQyKHRoaXMsIHRoaXMsIG1hdHJpeDIpO1xuICAgIHJldHVybiB0aGlzLmNoZWNrKCk7XG4gIH1cblxuICB0cmFuc2Zvcm1CeVF1YXRlcm5pb24ocXVhdGVybmlvbikge1xuICAgIHZlYzMudHJhbnNmb3JtUXVhdCh0aGlzLCB0aGlzLCBxdWF0ZXJuaW9uKTtcbiAgICByZXR1cm4gdGhpcy5jaGVjaygpO1xuICB9XG5cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXZlY3RvcjMuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///43855\n')},50394:function(__unused_webpack_module,__webpack_exports__,__webpack_require__){eval('/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "Z": function() { return /* binding */ assert; }\n/* harmony export */ });\nfunction assert(condition, message) {\n  if (!condition) {\n    throw new Error("math.gl assertion ".concat(message));\n  }\n}\n//# sourceMappingURL=assert.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNTAzOTQuanMiLCJtYXBwaW5ncyI6Ijs7O0FBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdnVlMy13ZWJwYWNrNS8uL25vZGVfbW9kdWxlcy9AbWF0aC5nbC9jb3JlL2Rpc3QvZXNtL2xpYi9hc3NlcnQuanM/NGU3OSJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBhc3NlcnQoY29uZGl0aW9uLCBtZXNzYWdlKSB7XG4gIGlmICghY29uZGl0aW9uKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwibWF0aC5nbCBhc3NlcnRpb24gXCIuY29uY2F0KG1lc3NhZ2UpKTtcbiAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YXNzZXJ0LmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///50394\n')},14034:function(__unused_webpack_module,__webpack_exports__,__webpack_require__){eval('/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "Bw": function() { return /* binding */ formatValue; },\n/* harmony export */   "fS": function() { return /* binding */ equals; },\n/* harmony export */   "kJ": function() { return /* binding */ isArray; },\n/* harmony export */   "t7": function() { return /* binding */ lerp; },\n/* harmony export */   "uZ": function() { return /* binding */ clamp; },\n/* harmony export */   "vc": function() { return /* binding */ config; }\n/* harmony export */ });\n/* unused harmony exports configure, clone, toRadians, toDegrees, radians, degrees, sin, cos, tan, asin, acos, atan, exactEquals, withEpsilon */\n\nconst RADIANS_TO_DEGREES = 1 / Math.PI * 180;\nconst DEGREES_TO_RADIANS = 1 / 180 * Math.PI;\nconst config = {\n  EPSILON: 1e-12,\n  debug: false,\n  precision: 4,\n  printTypes: false,\n  printDegrees: false,\n  printRowMajor: true\n};\nfunction configure(options) {\n  for (const key in options) {\n    assert(key in config);\n    config[key] = options[key];\n  }\n\n  return config;\n}\nfunction formatValue(value, {\n  precision = config.precision\n} = {}) {\n  value = round(value);\n  return "".concat(parseFloat(value.toPrecision(precision)));\n}\nfunction isArray(value) {\n  return Array.isArray(value) || ArrayBuffer.isView(value) && !(value instanceof DataView);\n}\nfunction clone(array) {\n  return \'clone\' in array ? array.clone() : array.slice();\n}\nfunction toRadians(degrees) {\n  return radians(degrees);\n}\nfunction toDegrees(radians) {\n  return degrees(radians);\n}\nfunction radians(degrees, result) {\n  return map(degrees, degrees => degrees * DEGREES_TO_RADIANS, result);\n}\nfunction degrees(radians, result) {\n  return map(radians, radians => radians * RADIANS_TO_DEGREES, result);\n}\nfunction sin(radians, result) {\n  return map(radians, angle => Math.sin(angle), result);\n}\nfunction cos(radians, result) {\n  return map(radians, angle => Math.cos(angle), result);\n}\nfunction tan(radians, result) {\n  return map(radians, angle => Math.tan(angle), result);\n}\nfunction asin(radians, result) {\n  return map(radians, angle => Math.asin(angle), result);\n}\nfunction acos(radians, result) {\n  return map(radians, angle => Math.acos(angle), result);\n}\nfunction atan(radians, result) {\n  return map(radians, angle => Math.atan(angle), result);\n}\nfunction clamp(value, min, max) {\n  return map(value, value => Math.max(min, Math.min(max, value)));\n}\nfunction lerp(a, b, t) {\n  if (isArray(a)) {\n    return a.map((ai, i) => lerp(ai, b[i], t));\n  }\n\n  return t * b + (1 - t) * a;\n}\nfunction equals(a, b, epsilon) {\n  const oldEpsilon = config.EPSILON;\n\n  if (epsilon) {\n    config.EPSILON = epsilon;\n  }\n\n  try {\n    if (a === b) {\n      return true;\n    }\n\n    if (isArray(a) && isArray(b)) {\n      if (a.length !== b.length) {\n        return false;\n      }\n\n      for (let i = 0; i < a.length; ++i) {\n        if (!equals(a[i], b[i])) {\n          return false;\n        }\n      }\n\n      return true;\n    }\n\n    if (a && a.equals) {\n      return a.equals(b);\n    }\n\n    if (b && b.equals) {\n      return b.equals(a);\n    }\n\n    if (typeof a === \'number\' && typeof b === \'number\') {\n      return Math.abs(a - b) <= config.EPSILON * Math.max(1, Math.abs(a), Math.abs(b));\n    }\n\n    return false;\n  } finally {\n    config.EPSILON = oldEpsilon;\n  }\n}\nfunction exactEquals(a, b) {\n  if (a === b) {\n    return true;\n  }\n\n  if (a && typeof a === \'object\' && b && typeof b === \'object\') {\n    if (a.constructor !== b.constructor) {\n      return false;\n    }\n\n    if (a.exactEquals) {\n      return a.exactEquals(b);\n    }\n  }\n\n  if (isArray(a) && isArray(b)) {\n    if (a.length !== b.length) {\n      return false;\n    }\n\n    for (let i = 0; i < a.length; ++i) {\n      if (!exactEquals(a[i], b[i])) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  return false;\n}\nfunction withEpsilon(epsilon, func) {\n  const oldPrecision = config.EPSILON;\n  config.EPSILON = epsilon;\n  let value;\n\n  try {\n    value = func();\n  } finally {\n    config.EPSILON = oldPrecision;\n  }\n\n  return value;\n}\n\nfunction round(value) {\n  return Math.round(value / config.EPSILON) * config.EPSILON;\n}\n\nfunction duplicateArray(array) {\n  return array.clone ? array.clone() : new Array(array.length);\n}\n\nfunction map(value, func, result) {\n  if (isArray(value)) {\n    const array = value;\n    result = result || duplicateArray(array);\n\n    for (let i = 0; i < result.length && i < array.length; ++i) {\n      result[i] = func(value[i], i, result);\n    }\n\n    return result;\n  }\n\n  return func(value);\n}\n//# sourceMappingURL=common.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTQwMzQuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBQThCO0FBQzlCO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ087QUFDUDtBQUNBLEVBQUUsSUFBSTtBQUNOO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDTztBQUNQOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxzQkFBc0IsY0FBYztBQUNwQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG9CQUFvQixjQUFjO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsb0JBQW9CLHVDQUF1QztBQUMzRDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdnVlMy13ZWJwYWNrNS8uL25vZGVfbW9kdWxlcy9AbWF0aC5nbC9jb3JlL2Rpc3QvZXNtL2xpYi9jb21tb24uanM/ZDQ2YiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgYXNzZXJ0IGZyb20gJy4vYXNzZXJ0JztcbmNvbnN0IFJBRElBTlNfVE9fREVHUkVFUyA9IDEgLyBNYXRoLlBJICogMTgwO1xuY29uc3QgREVHUkVFU19UT19SQURJQU5TID0gMSAvIDE4MCAqIE1hdGguUEk7XG5leHBvcnQgY29uc3QgY29uZmlnID0ge1xuICBFUFNJTE9OOiAxZS0xMixcbiAgZGVidWc6IGZhbHNlLFxuICBwcmVjaXNpb246IDQsXG4gIHByaW50VHlwZXM6IGZhbHNlLFxuICBwcmludERlZ3JlZXM6IGZhbHNlLFxuICBwcmludFJvd01ham9yOiB0cnVlXG59O1xuZXhwb3J0IGZ1bmN0aW9uIGNvbmZpZ3VyZShvcHRpb25zKSB7XG4gIGZvciAoY29uc3Qga2V5IGluIG9wdGlvbnMpIHtcbiAgICBhc3NlcnQoa2V5IGluIGNvbmZpZyk7XG4gICAgY29uZmlnW2tleV0gPSBvcHRpb25zW2tleV07XG4gIH1cblxuICByZXR1cm4gY29uZmlnO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGZvcm1hdFZhbHVlKHZhbHVlLCB7XG4gIHByZWNpc2lvbiA9IGNvbmZpZy5wcmVjaXNpb25cbn0gPSB7fSkge1xuICB2YWx1ZSA9IHJvdW5kKHZhbHVlKTtcbiAgcmV0dXJuIFwiXCIuY29uY2F0KHBhcnNlRmxvYXQodmFsdWUudG9QcmVjaXNpb24ocHJlY2lzaW9uKSkpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGlzQXJyYXkodmFsdWUpIHtcbiAgcmV0dXJuIEFycmF5LmlzQXJyYXkodmFsdWUpIHx8IEFycmF5QnVmZmVyLmlzVmlldyh2YWx1ZSkgJiYgISh2YWx1ZSBpbnN0YW5jZW9mIERhdGFWaWV3KTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBjbG9uZShhcnJheSkge1xuICByZXR1cm4gJ2Nsb25lJyBpbiBhcnJheSA/IGFycmF5LmNsb25lKCkgOiBhcnJheS5zbGljZSgpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIHRvUmFkaWFucyhkZWdyZWVzKSB7XG4gIHJldHVybiByYWRpYW5zKGRlZ3JlZXMpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIHRvRGVncmVlcyhyYWRpYW5zKSB7XG4gIHJldHVybiBkZWdyZWVzKHJhZGlhbnMpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIHJhZGlhbnMoZGVncmVlcywgcmVzdWx0KSB7XG4gIHJldHVybiBtYXAoZGVncmVlcywgZGVncmVlcyA9PiBkZWdyZWVzICogREVHUkVFU19UT19SQURJQU5TLCByZXN1bHQpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGRlZ3JlZXMocmFkaWFucywgcmVzdWx0KSB7XG4gIHJldHVybiBtYXAocmFkaWFucywgcmFkaWFucyA9PiByYWRpYW5zICogUkFESUFOU19UT19ERUdSRUVTLCByZXN1bHQpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIHNpbihyYWRpYW5zLCByZXN1bHQpIHtcbiAgcmV0dXJuIG1hcChyYWRpYW5zLCBhbmdsZSA9PiBNYXRoLnNpbihhbmdsZSksIHJlc3VsdCk7XG59XG5leHBvcnQgZnVuY3Rpb24gY29zKHJhZGlhbnMsIHJlc3VsdCkge1xuICByZXR1cm4gbWFwKHJhZGlhbnMsIGFuZ2xlID0+IE1hdGguY29zKGFuZ2xlKSwgcmVzdWx0KTtcbn1cbmV4cG9ydCBmdW5jdGlvbiB0YW4ocmFkaWFucywgcmVzdWx0KSB7XG4gIHJldHVybiBtYXAocmFkaWFucywgYW5nbGUgPT4gTWF0aC50YW4oYW5nbGUpLCByZXN1bHQpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGFzaW4ocmFkaWFucywgcmVzdWx0KSB7XG4gIHJldHVybiBtYXAocmFkaWFucywgYW5nbGUgPT4gTWF0aC5hc2luKGFuZ2xlKSwgcmVzdWx0KTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBhY29zKHJhZGlhbnMsIHJlc3VsdCkge1xuICByZXR1cm4gbWFwKHJhZGlhbnMsIGFuZ2xlID0+IE1hdGguYWNvcyhhbmdsZSksIHJlc3VsdCk7XG59XG5leHBvcnQgZnVuY3Rpb24gYXRhbihyYWRpYW5zLCByZXN1bHQpIHtcbiAgcmV0dXJuIG1hcChyYWRpYW5zLCBhbmdsZSA9PiBNYXRoLmF0YW4oYW5nbGUpLCByZXN1bHQpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGNsYW1wKHZhbHVlLCBtaW4sIG1heCkge1xuICByZXR1cm4gbWFwKHZhbHVlLCB2YWx1ZSA9PiBNYXRoLm1heChtaW4sIE1hdGgubWluKG1heCwgdmFsdWUpKSk7XG59XG5leHBvcnQgZnVuY3Rpb24gbGVycChhLCBiLCB0KSB7XG4gIGlmIChpc0FycmF5KGEpKSB7XG4gICAgcmV0dXJuIGEubWFwKChhaSwgaSkgPT4gbGVycChhaSwgYltpXSwgdCkpO1xuICB9XG5cbiAgcmV0dXJuIHQgKiBiICsgKDEgLSB0KSAqIGE7XG59XG5leHBvcnQgZnVuY3Rpb24gZXF1YWxzKGEsIGIsIGVwc2lsb24pIHtcbiAgY29uc3Qgb2xkRXBzaWxvbiA9IGNvbmZpZy5FUFNJTE9OO1xuXG4gIGlmIChlcHNpbG9uKSB7XG4gICAgY29uZmlnLkVQU0lMT04gPSBlcHNpbG9uO1xuICB9XG5cbiAgdHJ5IHtcbiAgICBpZiAoYSA9PT0gYikge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgaWYgKGlzQXJyYXkoYSkgJiYgaXNBcnJheShiKSkge1xuICAgICAgaWYgKGEubGVuZ3RoICE9PSBiLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYS5sZW5ndGg7ICsraSkge1xuICAgICAgICBpZiAoIWVxdWFscyhhW2ldLCBiW2ldKSkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICBpZiAoYSAmJiBhLmVxdWFscykge1xuICAgICAgcmV0dXJuIGEuZXF1YWxzKGIpO1xuICAgIH1cblxuICAgIGlmIChiICYmIGIuZXF1YWxzKSB7XG4gICAgICByZXR1cm4gYi5lcXVhbHMoYSk7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBhID09PSAnbnVtYmVyJyAmJiB0eXBlb2YgYiA9PT0gJ251bWJlcicpIHtcbiAgICAgIHJldHVybiBNYXRoLmFicyhhIC0gYikgPD0gY29uZmlnLkVQU0lMT04gKiBNYXRoLm1heCgxLCBNYXRoLmFicyhhKSwgTWF0aC5hYnMoYikpO1xuICAgIH1cblxuICAgIHJldHVybiBmYWxzZTtcbiAgfSBmaW5hbGx5IHtcbiAgICBjb25maWcuRVBTSUxPTiA9IG9sZEVwc2lsb247XG4gIH1cbn1cbmV4cG9ydCBmdW5jdGlvbiBleGFjdEVxdWFscyhhLCBiKSB7XG4gIGlmIChhID09PSBiKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICBpZiAoYSAmJiB0eXBlb2YgYSA9PT0gJ29iamVjdCcgJiYgYiAmJiB0eXBlb2YgYiA9PT0gJ29iamVjdCcpIHtcbiAgICBpZiAoYS5jb25zdHJ1Y3RvciAhPT0gYi5jb25zdHJ1Y3Rvcikge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGlmIChhLmV4YWN0RXF1YWxzKSB7XG4gICAgICByZXR1cm4gYS5leGFjdEVxdWFscyhiKTtcbiAgICB9XG4gIH1cblxuICBpZiAoaXNBcnJheShhKSAmJiBpc0FycmF5KGIpKSB7XG4gICAgaWYgKGEubGVuZ3RoICE9PSBiLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYS5sZW5ndGg7ICsraSkge1xuICAgICAgaWYgKCFleGFjdEVxdWFscyhhW2ldLCBiW2ldKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5leHBvcnQgZnVuY3Rpb24gd2l0aEVwc2lsb24oZXBzaWxvbiwgZnVuYykge1xuICBjb25zdCBvbGRQcmVjaXNpb24gPSBjb25maWcuRVBTSUxPTjtcbiAgY29uZmlnLkVQU0lMT04gPSBlcHNpbG9uO1xuICBsZXQgdmFsdWU7XG5cbiAgdHJ5IHtcbiAgICB2YWx1ZSA9IGZ1bmMoKTtcbiAgfSBmaW5hbGx5IHtcbiAgICBjb25maWcuRVBTSUxPTiA9IG9sZFByZWNpc2lvbjtcbiAgfVxuXG4gIHJldHVybiB2YWx1ZTtcbn1cblxuZnVuY3Rpb24gcm91bmQodmFsdWUpIHtcbiAgcmV0dXJuIE1hdGgucm91bmQodmFsdWUgLyBjb25maWcuRVBTSUxPTikgKiBjb25maWcuRVBTSUxPTjtcbn1cblxuZnVuY3Rpb24gZHVwbGljYXRlQXJyYXkoYXJyYXkpIHtcbiAgcmV0dXJuIGFycmF5LmNsb25lID8gYXJyYXkuY2xvbmUoKSA6IG5ldyBBcnJheShhcnJheS5sZW5ndGgpO1xufVxuXG5mdW5jdGlvbiBtYXAodmFsdWUsIGZ1bmMsIHJlc3VsdCkge1xuICBpZiAoaXNBcnJheSh2YWx1ZSkpIHtcbiAgICBjb25zdCBhcnJheSA9IHZhbHVlO1xuICAgIHJlc3VsdCA9IHJlc3VsdCB8fCBkdXBsaWNhdGVBcnJheShhcnJheSk7XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHJlc3VsdC5sZW5ndGggJiYgaSA8IGFycmF5Lmxlbmd0aDsgKytpKSB7XG4gICAgICByZXN1bHRbaV0gPSBmdW5jKHZhbHVlW2ldLCBpLCByZXN1bHQpO1xuICAgIH1cblxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICByZXR1cm4gZnVuYyh2YWx1ZSk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jb21tb24uanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///14034\n')},1031:function(__unused_webpack_module,__webpack_exports__,__webpack_require__){eval('/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "G7": function() { return /* binding */ vec4_transformMat2; },\n/* harmony export */   "_x": function() { return /* binding */ vec4_transformMat3; },\n/* harmony export */   "eQ": function() { return /* binding */ vec3_transformMat2; },\n/* harmony export */   "pL": function() { return /* binding */ vec3_transformMat4AsVector; },\n/* harmony export */   "pb": function() { return /* binding */ vec2_transformMat4AsVector; }\n/* harmony export */ });\nfunction vec2_transformMat4AsVector(out, a, m) {\n  const x = a[0];\n  const y = a[1];\n  const w = m[3] * x + m[7] * y || 1.0;\n  out[0] = (m[0] * x + m[4] * y) / w;\n  out[1] = (m[1] * x + m[5] * y) / w;\n  return out;\n}\nfunction vec3_transformMat4AsVector(out, a, m) {\n  const x = a[0];\n  const y = a[1];\n  const z = a[2];\n  const w = m[3] * x + m[7] * y + m[11] * z || 1.0;\n  out[0] = (m[0] * x + m[4] * y + m[8] * z) / w;\n  out[1] = (m[1] * x + m[5] * y + m[9] * z) / w;\n  out[2] = (m[2] * x + m[6] * y + m[10] * z) / w;\n  return out;\n}\nfunction vec3_transformMat2(out, a, m) {\n  const x = a[0];\n  const y = a[1];\n  out[0] = m[0] * x + m[2] * y;\n  out[1] = m[1] * x + m[3] * y;\n  out[2] = a[2];\n  return out;\n}\nfunction vec4_transformMat2(out, a, m) {\n  const x = a[0];\n  const y = a[1];\n  out[0] = m[0] * x + m[2] * y;\n  out[1] = m[1] * x + m[3] * y;\n  out[2] = a[2];\n  out[3] = a[3];\n  return out;\n}\nfunction vec4_transformMat3(out, a, m) {\n  const x = a[0];\n  const y = a[1];\n  const z = a[2];\n  out[0] = m[0] * x + m[3] * y + m[6] * z;\n  out[1] = m[1] * x + m[4] * y + m[7] * z;\n  out[2] = m[2] * x + m[5] * y + m[8] * z;\n  out[3] = a[3];\n  return out;\n}\n//# sourceMappingURL=gl-matrix-extras.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTAzMS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly92dWUzLXdlYnBhY2s1Ly4vbm9kZV9tb2R1bGVzL0BtYXRoLmdsL2NvcmUvZGlzdC9lc20vbGliL2dsLW1hdHJpeC1leHRyYXMuanM/NzlkMCJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgZnVuY3Rpb24gdmVjMl90cmFuc2Zvcm1NYXQ0QXNWZWN0b3Iob3V0LCBhLCBtKSB7XG4gIGNvbnN0IHggPSBhWzBdO1xuICBjb25zdCB5ID0gYVsxXTtcbiAgY29uc3QgdyA9IG1bM10gKiB4ICsgbVs3XSAqIHkgfHwgMS4wO1xuICBvdXRbMF0gPSAobVswXSAqIHggKyBtWzRdICogeSkgLyB3O1xuICBvdXRbMV0gPSAobVsxXSAqIHggKyBtWzVdICogeSkgLyB3O1xuICByZXR1cm4gb3V0O1xufVxuZXhwb3J0IGZ1bmN0aW9uIHZlYzNfdHJhbnNmb3JtTWF0NEFzVmVjdG9yKG91dCwgYSwgbSkge1xuICBjb25zdCB4ID0gYVswXTtcbiAgY29uc3QgeSA9IGFbMV07XG4gIGNvbnN0IHogPSBhWzJdO1xuICBjb25zdCB3ID0gbVszXSAqIHggKyBtWzddICogeSArIG1bMTFdICogeiB8fCAxLjA7XG4gIG91dFswXSA9IChtWzBdICogeCArIG1bNF0gKiB5ICsgbVs4XSAqIHopIC8gdztcbiAgb3V0WzFdID0gKG1bMV0gKiB4ICsgbVs1XSAqIHkgKyBtWzldICogeikgLyB3O1xuICBvdXRbMl0gPSAobVsyXSAqIHggKyBtWzZdICogeSArIG1bMTBdICogeikgLyB3O1xuICByZXR1cm4gb3V0O1xufVxuZXhwb3J0IGZ1bmN0aW9uIHZlYzNfdHJhbnNmb3JtTWF0MihvdXQsIGEsIG0pIHtcbiAgY29uc3QgeCA9IGFbMF07XG4gIGNvbnN0IHkgPSBhWzFdO1xuICBvdXRbMF0gPSBtWzBdICogeCArIG1bMl0gKiB5O1xuICBvdXRbMV0gPSBtWzFdICogeCArIG1bM10gKiB5O1xuICBvdXRbMl0gPSBhWzJdO1xuICByZXR1cm4gb3V0O1xufVxuZXhwb3J0IGZ1bmN0aW9uIHZlYzRfdHJhbnNmb3JtTWF0MihvdXQsIGEsIG0pIHtcbiAgY29uc3QgeCA9IGFbMF07XG4gIGNvbnN0IHkgPSBhWzFdO1xuICBvdXRbMF0gPSBtWzBdICogeCArIG1bMl0gKiB5O1xuICBvdXRbMV0gPSBtWzFdICogeCArIG1bM10gKiB5O1xuICBvdXRbMl0gPSBhWzJdO1xuICBvdXRbM10gPSBhWzNdO1xuICByZXR1cm4gb3V0O1xufVxuZXhwb3J0IGZ1bmN0aW9uIHZlYzRfdHJhbnNmb3JtTWF0MyhvdXQsIGEsIG0pIHtcbiAgY29uc3QgeCA9IGFbMF07XG4gIGNvbnN0IHkgPSBhWzFdO1xuICBjb25zdCB6ID0gYVsyXTtcbiAgb3V0WzBdID0gbVswXSAqIHggKyBtWzNdICogeSArIG1bNl0gKiB6O1xuICBvdXRbMV0gPSBtWzFdICogeCArIG1bNF0gKiB5ICsgbVs3XSAqIHo7XG4gIG91dFsyXSA9IG1bMl0gKiB4ICsgbVs1XSAqIHkgKyBtWzhdICogejtcbiAgb3V0WzNdID0gYVszXTtcbiAgcmV0dXJuIG91dDtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWdsLW1hdHJpeC1leHRyYXMuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///1031\n')},86281:function(__unused_webpack_module,__webpack_exports__,__webpack_require__){eval('/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "IL": function() { return /* binding */ checkVector; },\n/* harmony export */   "u5": function() { return /* binding */ checkNumber; }\n/* harmony export */ });\n/* unused harmony exports validateVector, deprecated */\n/* harmony import */ var _common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(14034);\n\nfunction validateVector(v, length) {\n  if (v.length !== length) {\n    return false;\n  }\n\n  for (let i = 0; i < v.length; ++i) {\n    if (!Number.isFinite(v[i])) {\n      return false;\n    }\n  }\n\n  return true;\n}\nfunction checkNumber(value) {\n  if (!Number.isFinite(value)) {\n    throw new Error("Invalid number ".concat(value));\n  }\n\n  return value;\n}\nfunction checkVector(v, length, callerName = \'\') {\n  if (_common__WEBPACK_IMPORTED_MODULE_0__/* .config.debug */ .vc.debug && !validateVector(v, length)) {\n    throw new Error("math.gl: ".concat(callerName, " some fields set to invalid numbers\'"));\n  }\n\n  return v;\n}\nconst map = {};\nfunction deprecated(method, version) {\n  if (!map[method]) {\n    map[method] = true;\n    console.warn("".concat(method, " has been removed in version ").concat(version, ", see upgrade guide for more information"));\n  }\n}\n//# sourceMappingURL=validators.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiODYyODEuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQWtDO0FBQzNCO0FBQ1A7QUFDQTtBQUNBOztBQUVBLGtCQUFrQixjQUFjO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ087QUFDUCxNQUFNLGlFQUFZO0FBQ2xCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly92dWUzLXdlYnBhY2s1Ly4vbm9kZV9tb2R1bGVzL0BtYXRoLmdsL2NvcmUvZGlzdC9lc20vbGliL3ZhbGlkYXRvcnMuanM/MjEwNiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBjb25maWcgfSBmcm9tICcuL2NvbW1vbic7XG5leHBvcnQgZnVuY3Rpb24gdmFsaWRhdGVWZWN0b3IodiwgbGVuZ3RoKSB7XG4gIGlmICh2Lmxlbmd0aCAhPT0gbGVuZ3RoKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCB2Lmxlbmd0aDsgKytpKSB7XG4gICAgaWYgKCFOdW1iZXIuaXNGaW5pdGUodltpXSkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBjaGVja051bWJlcih2YWx1ZSkge1xuICBpZiAoIU51bWJlci5pc0Zpbml0ZSh2YWx1ZSkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIG51bWJlciBcIi5jb25jYXQodmFsdWUpKTtcbiAgfVxuXG4gIHJldHVybiB2YWx1ZTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBjaGVja1ZlY3Rvcih2LCBsZW5ndGgsIGNhbGxlck5hbWUgPSAnJykge1xuICBpZiAoY29uZmlnLmRlYnVnICYmICF2YWxpZGF0ZVZlY3Rvcih2LCBsZW5ndGgpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwibWF0aC5nbDogXCIuY29uY2F0KGNhbGxlck5hbWUsIFwiIHNvbWUgZmllbGRzIHNldCB0byBpbnZhbGlkIG51bWJlcnMnXCIpKTtcbiAgfVxuXG4gIHJldHVybiB2O1xufVxuY29uc3QgbWFwID0ge307XG5leHBvcnQgZnVuY3Rpb24gZGVwcmVjYXRlZChtZXRob2QsIHZlcnNpb24pIHtcbiAgaWYgKCFtYXBbbWV0aG9kXSkge1xuICAgIG1hcFttZXRob2RdID0gdHJ1ZTtcbiAgICBjb25zb2xlLndhcm4oXCJcIi5jb25jYXQobWV0aG9kLCBcIiBoYXMgYmVlbiByZW1vdmVkIGluIHZlcnNpb24gXCIpLmNvbmNhdCh2ZXJzaW9uLCBcIiwgc2VlIHVwZ3JhZGUgZ3VpZGUgZm9yIG1vcmUgaW5mb3JtYXRpb25cIikpO1xuICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD12YWxpZGF0b3JzLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///86281\n')},36772:function(__unused_webpack_module,__webpack_exports__,__webpack_require__){eval('\n// EXPORTS\n__webpack_require__.d(__webpack_exports__, {\n  "Xx": function() { return /* reexport */ axis_aligned_bounding_box_AxisAlignedBoundingBox; },\n  "Mh": function() { return /* reexport */ culling_volume_CullingVolume; },\n  "JO": function() { return /* reexport */ plane_Plane; },\n  "du": function() { return /* reexport */ makeOrientedBoundingBoxFromPoints; }\n});\n\n// UNUSED EXPORTS: BoundingSphere, INTERSECTION, OrientedBoundingBox, _PerspectiveFrustum, _PerspectiveOffCenterFrustum, computeEigenDecomposition, makeAxisAlignedBoundingBoxFromPoints, makeBoundingSphereFromPoints\n\n;// CONCATENATED MODULE: ./node_modules/@math.gl/culling/dist/esm/constants.js\nconst INTERSECTION = {\n  OUTSIDE: -1,\n  INTERSECTING: 0,\n  INSIDE: 1\n};\n//# sourceMappingURL=constants.js.map\n// EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/esm/defineProperty.js\nvar defineProperty = __webpack_require__(82482);\n// EXTERNAL MODULE: ./node_modules/@math.gl/core/dist/esm/classes/vector3.js\nvar vector3 = __webpack_require__(43855);\n;// CONCATENATED MODULE: ./node_modules/@math.gl/culling/dist/esm/lib/bounding-volumes/axis-aligned-bounding-box.js\n\n\n\nconst scratchVector = new vector3/* default */.Z();\nconst scratchNormal = new vector3/* default */.Z();\nclass axis_aligned_bounding_box_AxisAlignedBoundingBox {\n  constructor(minimum = [0, 0, 0], maximum = [0, 0, 0], center) {\n    (0,defineProperty/* default */.Z)(this, "center", void 0);\n\n    (0,defineProperty/* default */.Z)(this, "halfDiagonal", void 0);\n\n    (0,defineProperty/* default */.Z)(this, "minimum", void 0);\n\n    (0,defineProperty/* default */.Z)(this, "maximum", void 0);\n\n    center = center || scratchVector.copy(minimum).add(maximum).scale(0.5);\n    this.center = new vector3/* default */.Z(center);\n    this.halfDiagonal = new vector3/* default */.Z(maximum).subtract(this.center);\n    this.minimum = new vector3/* default */.Z(minimum);\n    this.maximum = new vector3/* default */.Z(maximum);\n  }\n\n  clone() {\n    return new axis_aligned_bounding_box_AxisAlignedBoundingBox(this.minimum, this.maximum, this.center);\n  }\n\n  equals(right) {\n    return this === right || Boolean(right) && this.minimum.equals(right.minimum) && this.maximum.equals(right.maximum);\n  }\n\n  transform(transform) {\n    this.center.transformAsPoint(transform);\n    this.halfDiagonal.transform(transform);\n    this.minimum.transform(transform);\n    this.maximum.transform(transform);\n    return this;\n  }\n\n  intersectPlane(plane) {\n    const {\n      halfDiagonal\n    } = this;\n    const normal = scratchNormal.from(plane.normal);\n    const e = halfDiagonal.x * Math.abs(normal.x) + halfDiagonal.y * Math.abs(normal.y) + halfDiagonal.z * Math.abs(normal.z);\n    const s = this.center.dot(normal) + plane.distance;\n\n    if (s - e > 0) {\n      return INTERSECTION.INSIDE;\n    }\n\n    if (s + e < 0) {\n      return INTERSECTION.OUTSIDE;\n    }\n\n    return INTERSECTION.INTERSECTING;\n  }\n\n  distanceTo(point) {\n    return Math.sqrt(this.distanceSquaredTo(point));\n  }\n\n  distanceSquaredTo(point) {\n    const offset = scratchVector.from(point).subtract(this.center);\n    const {\n      halfDiagonal\n    } = this;\n    let distanceSquared = 0.0;\n    let d;\n    d = Math.abs(offset.x) - halfDiagonal.x;\n\n    if (d > 0) {\n      distanceSquared += d * d;\n    }\n\n    d = Math.abs(offset.y) - halfDiagonal.y;\n\n    if (d > 0) {\n      distanceSquared += d * d;\n    }\n\n    d = Math.abs(offset.z) - halfDiagonal.z;\n\n    if (d > 0) {\n      distanceSquared += d * d;\n    }\n\n    return distanceSquared;\n  }\n\n}\n//# sourceMappingURL=axis-aligned-bounding-box.js.map\n// EXTERNAL MODULE: ./node_modules/gl-matrix/esm/mat4.js\nvar mat4 = __webpack_require__(85975);\n;// CONCATENATED MODULE: ./node_modules/@math.gl/culling/dist/esm/lib/bounding-volumes/bounding-sphere.js\n\n\n\n\nconst bounding_sphere_scratchVector = new vector3/* default */.Z();\nconst scratchVector2 = new vector3/* default */.Z();\nclass bounding_sphere_BoundingSphere {\n  constructor(center = [0, 0, 0], radius = 0.0) {\n    (0,defineProperty/* default */.Z)(this, "center", void 0);\n\n    (0,defineProperty/* default */.Z)(this, "radius", void 0);\n\n    this.radius = -0;\n    this.center = new vector3/* default */.Z();\n    this.fromCenterRadius(center, radius);\n  }\n\n  fromCenterRadius(center, radius) {\n    this.center.from(center);\n    this.radius = radius;\n    return this;\n  }\n\n  fromCornerPoints(corner, oppositeCorner) {\n    oppositeCorner = bounding_sphere_scratchVector.from(oppositeCorner);\n    this.center = new vector3/* default */.Z().from(corner).add(oppositeCorner).scale(0.5);\n    this.radius = this.center.distance(oppositeCorner);\n    return this;\n  }\n\n  equals(right) {\n    return this === right || Boolean(right) && this.center.equals(right.center) && this.radius === right.radius;\n  }\n\n  clone() {\n    return new bounding_sphere_BoundingSphere(this.center, this.radius);\n  }\n\n  union(boundingSphere) {\n    const leftCenter = this.center;\n    const leftRadius = this.radius;\n    const rightCenter = boundingSphere.center;\n    const rightRadius = boundingSphere.radius;\n    const toRightCenter = bounding_sphere_scratchVector.copy(rightCenter).subtract(leftCenter);\n    const centerSeparation = toRightCenter.magnitude();\n\n    if (leftRadius >= centerSeparation + rightRadius) {\n      return this.clone();\n    }\n\n    if (rightRadius >= centerSeparation + leftRadius) {\n      return boundingSphere.clone();\n    }\n\n    const halfDistanceBetweenTangentPoints = (leftRadius + centerSeparation + rightRadius) * 0.5;\n    scratchVector2.copy(toRightCenter).scale((-leftRadius + halfDistanceBetweenTangentPoints) / centerSeparation).add(leftCenter);\n    this.center.copy(scratchVector2);\n    this.radius = halfDistanceBetweenTangentPoints;\n    return this;\n  }\n\n  expand(point) {\n    const scratchPoint = bounding_sphere_scratchVector.from(point);\n    const radius = scratchPoint.subtract(this.center).magnitude();\n\n    if (radius > this.radius) {\n      this.radius = radius;\n    }\n\n    return this;\n  }\n\n  transform(transform) {\n    this.center.transform(transform);\n    const scale = mat4/* getScaling */.Q$(bounding_sphere_scratchVector, transform);\n    this.radius = Math.max(scale[0], Math.max(scale[1], scale[2])) * this.radius;\n    return this;\n  }\n\n  distanceSquaredTo(point) {\n    const d = this.distanceTo(point);\n    return d * d;\n  }\n\n  distanceTo(point) {\n    const scratchPoint = bounding_sphere_scratchVector.from(point);\n    const delta = scratchPoint.subtract(this.center);\n    return Math.max(0, delta.len() - this.radius);\n  }\n\n  intersectPlane(plane) {\n    const center = this.center;\n    const radius = this.radius;\n    const normal = plane.normal;\n    const distanceToPlane = normal.dot(center) + plane.distance;\n\n    if (distanceToPlane < -radius) {\n      return INTERSECTION.OUTSIDE;\n    }\n\n    if (distanceToPlane < radius) {\n      return INTERSECTION.INTERSECTING;\n    }\n\n    return INTERSECTION.INSIDE;\n  }\n\n}\n//# sourceMappingURL=bounding-sphere.js.map\n// EXTERNAL MODULE: ./node_modules/@math.gl/core/dist/esm/classes/matrix3.js\nvar matrix3 = __webpack_require__(80540);\n// EXTERNAL MODULE: ./node_modules/@math.gl/core/dist/esm/classes/quaternion.js + 1 modules\nvar classes_quaternion = __webpack_require__(43897);\n;// CONCATENATED MODULE: ./node_modules/@math.gl/culling/dist/esm/lib/bounding-volumes/oriented-bounding-box.js\n\n\n\n\nconst scratchVector3 = new vector3/* default */.Z();\nconst scratchOffset = new vector3/* default */.Z();\nconst scratchVectorU = new vector3/* default */.Z();\nconst scratchVectorV = new vector3/* default */.Z();\nconst scratchVectorW = new vector3/* default */.Z();\nconst scratchCorner = new vector3/* default */.Z();\nconst scratchToCenter = new vector3/* default */.Z();\nconst MATRIX3 = {\n  COLUMN0ROW0: 0,\n  COLUMN0ROW1: 1,\n  COLUMN0ROW2: 2,\n  COLUMN1ROW0: 3,\n  COLUMN1ROW1: 4,\n  COLUMN1ROW2: 5,\n  COLUMN2ROW0: 6,\n  COLUMN2ROW1: 7,\n  COLUMN2ROW2: 8\n};\nclass OrientedBoundingBox {\n  constructor(center = [0, 0, 0], halfAxes = [0, 0, 0, 0, 0, 0, 0, 0, 0]) {\n    (0,defineProperty/* default */.Z)(this, "center", void 0);\n\n    (0,defineProperty/* default */.Z)(this, "halfAxes", void 0);\n\n    this.center = new vector3/* default */.Z().from(center);\n    this.halfAxes = new matrix3/* default */.Z(halfAxes);\n  }\n\n  get halfSize() {\n    const xAxis = this.halfAxes.getColumn(0);\n    const yAxis = this.halfAxes.getColumn(1);\n    const zAxis = this.halfAxes.getColumn(2);\n    return [new vector3/* default */.Z(xAxis).len(), new vector3/* default */.Z(yAxis).len(), new vector3/* default */.Z(zAxis).len()];\n  }\n\n  get quaternion() {\n    const xAxis = this.halfAxes.getColumn(0);\n    const yAxis = this.halfAxes.getColumn(1);\n    const zAxis = this.halfAxes.getColumn(2);\n    const normXAxis = new vector3/* default */.Z(xAxis).normalize();\n    const normYAxis = new vector3/* default */.Z(yAxis).normalize();\n    const normZAxis = new vector3/* default */.Z(zAxis).normalize();\n    return new classes_quaternion/* default */.Z().fromMatrix3(new matrix3/* default */.Z([...normXAxis, ...normYAxis, ...normZAxis]));\n  }\n\n  fromCenterHalfSizeQuaternion(center, halfSize, quaternion) {\n    const quaternionObject = new classes_quaternion/* default */.Z(quaternion);\n    const directionsMatrix = new matrix3/* default */.Z().fromQuaternion(quaternionObject);\n    directionsMatrix[0] = directionsMatrix[0] * halfSize[0];\n    directionsMatrix[1] = directionsMatrix[1] * halfSize[0];\n    directionsMatrix[2] = directionsMatrix[2] * halfSize[0];\n    directionsMatrix[3] = directionsMatrix[3] * halfSize[1];\n    directionsMatrix[4] = directionsMatrix[4] * halfSize[1];\n    directionsMatrix[5] = directionsMatrix[5] * halfSize[1];\n    directionsMatrix[6] = directionsMatrix[6] * halfSize[2];\n    directionsMatrix[7] = directionsMatrix[7] * halfSize[2];\n    directionsMatrix[8] = directionsMatrix[8] * halfSize[2];\n    this.center = new vector3/* default */.Z().from(center);\n    this.halfAxes = directionsMatrix;\n    return this;\n  }\n\n  clone() {\n    return new OrientedBoundingBox(this.center, this.halfAxes);\n  }\n\n  equals(right) {\n    return this === right || Boolean(right) && this.center.equals(right.center) && this.halfAxes.equals(right.halfAxes);\n  }\n\n  getBoundingSphere(result = new bounding_sphere_BoundingSphere()) {\n    const halfAxes = this.halfAxes;\n    const u = halfAxes.getColumn(0, scratchVectorU);\n    const v = halfAxes.getColumn(1, scratchVectorV);\n    const w = halfAxes.getColumn(2, scratchVectorW);\n    const cornerVector = scratchVector3.copy(u).add(v).add(w);\n    result.center.copy(this.center);\n    result.radius = cornerVector.magnitude();\n    return result;\n  }\n\n  intersectPlane(plane) {\n    const center = this.center;\n    const normal = plane.normal;\n    const halfAxes = this.halfAxes;\n    const normalX = normal.x;\n    const normalY = normal.y;\n    const normalZ = normal.z;\n    const radEffective = Math.abs(normalX * halfAxes[MATRIX3.COLUMN0ROW0] + normalY * halfAxes[MATRIX3.COLUMN0ROW1] + normalZ * halfAxes[MATRIX3.COLUMN0ROW2]) + Math.abs(normalX * halfAxes[MATRIX3.COLUMN1ROW0] + normalY * halfAxes[MATRIX3.COLUMN1ROW1] + normalZ * halfAxes[MATRIX3.COLUMN1ROW2]) + Math.abs(normalX * halfAxes[MATRIX3.COLUMN2ROW0] + normalY * halfAxes[MATRIX3.COLUMN2ROW1] + normalZ * halfAxes[MATRIX3.COLUMN2ROW2]);\n    const distanceToPlane = normal.dot(center) + plane.distance;\n\n    if (distanceToPlane <= -radEffective) {\n      return INTERSECTION.OUTSIDE;\n    } else if (distanceToPlane >= radEffective) {\n      return INTERSECTION.INSIDE;\n    }\n\n    return INTERSECTION.INTERSECTING;\n  }\n\n  distanceTo(point) {\n    return Math.sqrt(this.distanceSquaredTo(point));\n  }\n\n  distanceSquaredTo(point) {\n    const offset = scratchOffset.from(point).subtract(this.center);\n    const halfAxes = this.halfAxes;\n    const u = halfAxes.getColumn(0, scratchVectorU);\n    const v = halfAxes.getColumn(1, scratchVectorV);\n    const w = halfAxes.getColumn(2, scratchVectorW);\n    const uHalf = u.magnitude();\n    const vHalf = v.magnitude();\n    const wHalf = w.magnitude();\n    u.normalize();\n    v.normalize();\n    w.normalize();\n    let distanceSquared = 0.0;\n    let d;\n    d = Math.abs(offset.dot(u)) - uHalf;\n\n    if (d > 0) {\n      distanceSquared += d * d;\n    }\n\n    d = Math.abs(offset.dot(v)) - vHalf;\n\n    if (d > 0) {\n      distanceSquared += d * d;\n    }\n\n    d = Math.abs(offset.dot(w)) - wHalf;\n\n    if (d > 0) {\n      distanceSquared += d * d;\n    }\n\n    return distanceSquared;\n  }\n\n  computePlaneDistances(position, direction, result = [-0, -0]) {\n    let minDist = Number.POSITIVE_INFINITY;\n    let maxDist = Number.NEGATIVE_INFINITY;\n    const center = this.center;\n    const halfAxes = this.halfAxes;\n    const u = halfAxes.getColumn(0, scratchVectorU);\n    const v = halfAxes.getColumn(1, scratchVectorV);\n    const w = halfAxes.getColumn(2, scratchVectorW);\n    const corner = scratchCorner.copy(u).add(v).add(w).add(center);\n    const toCenter = scratchToCenter.copy(corner).subtract(position);\n    let mag = direction.dot(toCenter);\n    minDist = Math.min(mag, minDist);\n    maxDist = Math.max(mag, maxDist);\n    corner.copy(center).add(u).add(v).subtract(w);\n    toCenter.copy(corner).subtract(position);\n    mag = direction.dot(toCenter);\n    minDist = Math.min(mag, minDist);\n    maxDist = Math.max(mag, maxDist);\n    corner.copy(center).add(u).subtract(v).add(w);\n    toCenter.copy(corner).subtract(position);\n    mag = direction.dot(toCenter);\n    minDist = Math.min(mag, minDist);\n    maxDist = Math.max(mag, maxDist);\n    corner.copy(center).add(u).subtract(v).subtract(w);\n    toCenter.copy(corner).subtract(position);\n    mag = direction.dot(toCenter);\n    minDist = Math.min(mag, minDist);\n    maxDist = Math.max(mag, maxDist);\n    center.copy(corner).subtract(u).add(v).add(w);\n    toCenter.copy(corner).subtract(position);\n    mag = direction.dot(toCenter);\n    minDist = Math.min(mag, minDist);\n    maxDist = Math.max(mag, maxDist);\n    center.copy(corner).subtract(u).add(v).subtract(w);\n    toCenter.copy(corner).subtract(position);\n    mag = direction.dot(toCenter);\n    minDist = Math.min(mag, minDist);\n    maxDist = Math.max(mag, maxDist);\n    center.copy(corner).subtract(u).subtract(v).add(w);\n    toCenter.copy(corner).subtract(position);\n    mag = direction.dot(toCenter);\n    minDist = Math.min(mag, minDist);\n    maxDist = Math.max(mag, maxDist);\n    center.copy(corner).subtract(u).subtract(v).subtract(w);\n    toCenter.copy(corner).subtract(position);\n    mag = direction.dot(toCenter);\n    minDist = Math.min(mag, minDist);\n    maxDist = Math.max(mag, maxDist);\n    result[0] = minDist;\n    result[1] = maxDist;\n    return result;\n  }\n\n  transform(transformation) {\n    this.center.transformAsPoint(transformation);\n    const xAxis = this.halfAxes.getColumn(0, scratchVectorU);\n    xAxis.transformAsPoint(transformation);\n    const yAxis = this.halfAxes.getColumn(1, scratchVectorV);\n    yAxis.transformAsPoint(transformation);\n    const zAxis = this.halfAxes.getColumn(2, scratchVectorW);\n    zAxis.transformAsPoint(transformation);\n    this.halfAxes = new matrix3/* default */.Z([...xAxis, ...yAxis, ...zAxis]);\n    return this;\n  }\n\n  getTransform() {\n    throw new Error(\'not implemented\');\n  }\n\n}\n//# sourceMappingURL=oriented-bounding-box.js.map\n// EXTERNAL MODULE: ./node_modules/@math.gl/core/dist/esm/lib/assert.js\nvar lib_assert = __webpack_require__(50394);\n// EXTERNAL MODULE: ./node_modules/@math.gl/core/dist/esm/lib/common.js\nvar common = __webpack_require__(14034);\n;// CONCATENATED MODULE: ./node_modules/@math.gl/culling/dist/esm/lib/plane.js\n\n\nconst scratchPosition = new vector3/* default */.Z();\nconst plane_scratchNormal = new vector3/* default */.Z();\nclass plane_Plane {\n  constructor(normal = [0, 0, 1], distance = 0) {\n    (0,defineProperty/* default */.Z)(this, "normal", void 0);\n\n    (0,defineProperty/* default */.Z)(this, "distance", void 0);\n\n    this.normal = new vector3/* default */.Z();\n    this.distance = -0;\n    this.fromNormalDistance(normal, distance);\n  }\n\n  fromNormalDistance(normal, distance) {\n    (0,lib_assert/* default */.Z)(Number.isFinite(distance));\n    this.normal.from(normal).normalize();\n    this.distance = distance;\n    return this;\n  }\n\n  fromPointNormal(point, normal) {\n    point = scratchPosition.from(point);\n    this.normal.from(normal).normalize();\n    const distance = -this.normal.dot(point);\n    this.distance = distance;\n    return this;\n  }\n\n  fromCoefficients(a, b, c, d) {\n    this.normal.set(a, b, c);\n    (0,lib_assert/* default */.Z)((0,common/* equals */.fS)(this.normal.len(), 1));\n    this.distance = d;\n    return this;\n  }\n\n  clone() {\n    return new plane_Plane(this.normal, this.distance);\n  }\n\n  equals(right) {\n    return (0,common/* equals */.fS)(this.distance, right.distance) && (0,common/* equals */.fS)(this.normal, right.normal);\n  }\n\n  getPointDistance(point) {\n    return this.normal.dot(point) + this.distance;\n  }\n\n  transform(matrix4) {\n    const normal = plane_scratchNormal.copy(this.normal).transformAsVector(matrix4).normalize();\n    const point = this.normal.scale(-this.distance).transform(matrix4);\n    return this.fromPointNormal(point, normal);\n  }\n\n  projectPointOntoPlane(point, result = [0, 0, 0]) {\n    point = scratchPosition.from(point);\n    const pointDistance = this.getPointDistance(point);\n    const scaledNormal = plane_scratchNormal.copy(this.normal).scale(pointDistance);\n    return point.subtract(scaledNormal).to(result);\n  }\n\n}\n//# sourceMappingURL=plane.js.map\n;// CONCATENATED MODULE: ./node_modules/@math.gl/culling/dist/esm/lib/culling-volume.js\n\n\n\n\nconst faces = [new vector3/* default */.Z([1, 0, 0]), new vector3/* default */.Z([0, 1, 0]), new vector3/* default */.Z([0, 0, 1])];\nconst scratchPlaneCenter = new vector3/* default */.Z();\nconst scratchPlaneNormal = new vector3/* default */.Z();\nconst scratchPlane = new plane_Plane(new vector3/* default */.Z(1.0, 0.0, 0.0), 0.0);\nclass culling_volume_CullingVolume {\n  constructor(planes = []) {\n    (0,defineProperty/* default */.Z)(this, "planes", void 0);\n\n    this.planes = planes;\n  }\n\n  fromBoundingSphere(boundingSphere) {\n    this.planes.length = 2 * faces.length;\n    const center = boundingSphere.center;\n    const radius = boundingSphere.radius;\n    let planeIndex = 0;\n\n    for (const faceNormal of faces) {\n      let plane0 = this.planes[planeIndex];\n      let plane1 = this.planes[planeIndex + 1];\n\n      if (!plane0) {\n        plane0 = this.planes[planeIndex] = new plane_Plane();\n      }\n\n      if (!plane1) {\n        plane1 = this.planes[planeIndex + 1] = new plane_Plane();\n      }\n\n      const plane0Center = scratchPlaneCenter.copy(faceNormal).scale(-radius).add(center);\n      const plane0Distance = -faceNormal.dot(plane0Center);\n      plane0.fromPointNormal(plane0Center, faceNormal);\n      const plane1Center = scratchPlaneCenter.copy(faceNormal).scale(radius).add(center);\n      const negatedFaceNormal = scratchPlaneNormal.copy(faceNormal).negate();\n      const plane1Distance = -negatedFaceNormal.dot(plane1Center);\n      plane1.fromPointNormal(plane1Center, negatedFaceNormal);\n      planeIndex += 2;\n    }\n\n    return this;\n  }\n\n  computeVisibility(boundingVolume) {\n    let intersect = INTERSECTION.INSIDE;\n\n    for (const plane of this.planes) {\n      const result = boundingVolume.intersectPlane(plane);\n\n      switch (result) {\n        case INTERSECTION.OUTSIDE:\n          return INTERSECTION.OUTSIDE;\n\n        case INTERSECTION.INTERSECTING:\n          intersect = INTERSECTION.INTERSECTING;\n          break;\n\n        default:\n      }\n    }\n\n    return intersect;\n  }\n\n  computeVisibilityWithPlaneMask(boundingVolume, parentPlaneMask) {\n    (0,lib_assert/* default */.Z)(Number.isFinite(parentPlaneMask), \'parentPlaneMask is required.\');\n\n    if (parentPlaneMask === culling_volume_CullingVolume.MASK_OUTSIDE || parentPlaneMask === culling_volume_CullingVolume.MASK_INSIDE) {\n      return parentPlaneMask;\n    }\n\n    let mask = culling_volume_CullingVolume.MASK_INSIDE;\n    const planes = this.planes;\n\n    for (let k = 0; k < this.planes.length; ++k) {\n      const flag = k < 31 ? 1 << k : 0;\n\n      if (k < 31 && (parentPlaneMask & flag) === 0) {\n        continue;\n      }\n\n      const plane = planes[k];\n      const result = boundingVolume.intersectPlane(plane);\n\n      if (result === INTERSECTION.OUTSIDE) {\n        return culling_volume_CullingVolume.MASK_OUTSIDE;\n      } else if (result === INTERSECTION.INTERSECTING) {\n        mask |= flag;\n      }\n    }\n\n    return mask;\n  }\n\n}\n\n(0,defineProperty/* default */.Z)(culling_volume_CullingVolume, "MASK_OUTSIDE", 0xffffffff);\n\n(0,defineProperty/* default */.Z)(culling_volume_CullingVolume, "MASK_INSIDE", 0x00000000);\n\n(0,defineProperty/* default */.Z)(culling_volume_CullingVolume, "MASK_INDETERMINATE", 0x7fffffff);\n//# sourceMappingURL=culling-volume.js.map\n;// CONCATENATED MODULE: ./node_modules/@math.gl/culling/dist/esm/lib/perspective-off-center-frustum.js\n\n\n\n\nconst scratchPlaneUpVector = new vector3/* default */.Z();\nconst scratchPlaneRightVector = new vector3/* default */.Z();\nconst scratchPlaneNearCenter = new vector3/* default */.Z();\nconst scratchPlaneFarCenter = new vector3/* default */.Z();\nconst perspective_off_center_frustum_scratchPlaneNormal = new vector3/* default */.Z();\nclass perspective_off_center_frustum_PerspectiveOffCenterFrustum {\n  constructor(options = {}) {\n    _defineProperty(this, "left", void 0);\n\n    _defineProperty(this, "_left", void 0);\n\n    _defineProperty(this, "right", void 0);\n\n    _defineProperty(this, "_right", void 0);\n\n    _defineProperty(this, "top", void 0);\n\n    _defineProperty(this, "_top", void 0);\n\n    _defineProperty(this, "bottom", void 0);\n\n    _defineProperty(this, "_bottom", void 0);\n\n    _defineProperty(this, "near", void 0);\n\n    _defineProperty(this, "_near", void 0);\n\n    _defineProperty(this, "far", void 0);\n\n    _defineProperty(this, "_far", void 0);\n\n    _defineProperty(this, "_cullingVolume", new CullingVolume([new Plane(), new Plane(), new Plane(), new Plane(), new Plane(), new Plane()]));\n\n    _defineProperty(this, "_perspectiveMatrix", new Matrix4());\n\n    _defineProperty(this, "_infinitePerspective", new Matrix4());\n\n    const {\n      near = 1.0,\n      far = 500000000.0\n    } = options;\n    this.left = options.left;\n    this._left = undefined;\n    this.right = options.right;\n    this._right = undefined;\n    this.top = options.top;\n    this._top = undefined;\n    this.bottom = options.bottom;\n    this._bottom = undefined;\n    this.near = near;\n    this._near = near;\n    this.far = far;\n    this._far = far;\n  }\n\n  clone() {\n    return new perspective_off_center_frustum_PerspectiveOffCenterFrustum({\n      right: this.right,\n      left: this.left,\n      top: this.top,\n      bottom: this.bottom,\n      near: this.near,\n      far: this.far\n    });\n  }\n\n  equals(other) {\n    return other && other instanceof perspective_off_center_frustum_PerspectiveOffCenterFrustum && this.right === other.right && this.left === other.left && this.top === other.top && this.bottom === other.bottom && this.near === other.near && this.far === other.far;\n  }\n\n  get projectionMatrix() {\n    this._update();\n\n    return this._perspectiveMatrix;\n  }\n\n  get infiniteProjectionMatrix() {\n    this._update();\n\n    return this._infinitePerspective;\n  }\n\n  computeCullingVolume(position, direction, up) {\n    assert(position, \'position is required.\');\n    assert(direction, \'direction is required.\');\n    assert(up, \'up is required.\');\n    const planes = this._cullingVolume.planes;\n    up = scratchPlaneUpVector.copy(up).normalize();\n    const right = scratchPlaneRightVector.copy(direction).cross(up).normalize();\n    const nearCenter = scratchPlaneNearCenter.copy(direction).multiplyByScalar(this.near).add(position);\n    const farCenter = scratchPlaneFarCenter.copy(direction).multiplyByScalar(this.far).add(position);\n    let normal = perspective_off_center_frustum_scratchPlaneNormal;\n    normal.copy(right).multiplyByScalar(this.left).add(nearCenter).subtract(position).cross(up);\n    planes[0].fromPointNormal(position, normal);\n    normal.copy(right).multiplyByScalar(this.right).add(nearCenter).subtract(position).cross(up).negate();\n    planes[1].fromPointNormal(position, normal);\n    normal.copy(up).multiplyByScalar(this.bottom).add(nearCenter).subtract(position).cross(right).negate();\n    planes[2].fromPointNormal(position, normal);\n    normal.copy(up).multiplyByScalar(this.top).add(nearCenter).subtract(position).cross(right);\n    planes[3].fromPointNormal(position, normal);\n    normal = new Vector3().copy(direction);\n    planes[4].fromPointNormal(nearCenter, normal);\n    normal.negate();\n    planes[5].fromPointNormal(farCenter, normal);\n    return this._cullingVolume;\n  }\n\n  getPixelDimensions(drawingBufferWidth, drawingBufferHeight, distance, result) {\n    this._update();\n\n    assert(Number.isFinite(drawingBufferWidth) && Number.isFinite(drawingBufferHeight));\n    assert(drawingBufferWidth > 0);\n    assert(drawingBufferHeight > 0);\n    assert(distance > 0);\n    assert(result);\n    const inverseNear = 1.0 / this.near;\n    let tanTheta = this.top * inverseNear;\n    const pixelHeight = 2.0 * distance * tanTheta / drawingBufferHeight;\n    tanTheta = this.right * inverseNear;\n    const pixelWidth = 2.0 * distance * tanTheta / drawingBufferWidth;\n    result.x = pixelWidth;\n    result.y = pixelHeight;\n    return result;\n  }\n\n  _update() {\n    assert(Number.isFinite(this.right) && Number.isFinite(this.left) && Number.isFinite(this.top) && Number.isFinite(this.bottom) && Number.isFinite(this.near) && Number.isFinite(this.far));\n    const {\n      top,\n      bottom,\n      right,\n      left,\n      near,\n      far\n    } = this;\n\n    if (top !== this._top || bottom !== this._bottom || left !== this._left || right !== this._right || near !== this._near || far !== this._far) {\n      assert(this.near > 0 && this.near < this.far, \'near must be greater than zero and less than far.\');\n      this._left = left;\n      this._right = right;\n      this._top = top;\n      this._bottom = bottom;\n      this._near = near;\n      this._far = far;\n      this._perspectiveMatrix = new Matrix4().frustum({\n        left,\n        right,\n        bottom,\n        top,\n        near,\n        far\n      });\n      this._infinitePerspective = new Matrix4().frustum({\n        left,\n        right,\n        bottom,\n        top,\n        near,\n        far: Infinity\n      });\n    }\n  }\n\n}\n//# sourceMappingURL=perspective-off-center-frustum.js.map\n;// CONCATENATED MODULE: ./node_modules/@math.gl/culling/dist/esm/lib/perspective-frustum.js\n\n\n\n\nconst defined = val => val !== null && typeof val !== \'undefined\';\n\nclass PerspectiveFrustum {\n  constructor(options = {}) {\n    _defineProperty(this, "_offCenterFrustum", new PerspectiveOffCenterFrustum());\n\n    _defineProperty(this, "fov", void 0);\n\n    _defineProperty(this, "_fov", void 0);\n\n    _defineProperty(this, "_fovy", void 0);\n\n    _defineProperty(this, "_sseDenominator", void 0);\n\n    _defineProperty(this, "aspectRatio", void 0);\n\n    _defineProperty(this, "_aspectRatio", void 0);\n\n    _defineProperty(this, "near", void 0);\n\n    _defineProperty(this, "_near", void 0);\n\n    _defineProperty(this, "far", void 0);\n\n    _defineProperty(this, "_far", void 0);\n\n    _defineProperty(this, "xOffset", void 0);\n\n    _defineProperty(this, "_xOffset", void 0);\n\n    _defineProperty(this, "yOffset", void 0);\n\n    _defineProperty(this, "_yOffset", void 0);\n\n    const {\n      fov,\n      aspectRatio,\n      near = 1.0,\n      far = 500000000.0,\n      xOffset = 0.0,\n      yOffset = 0.0\n    } = options;\n    this.fov = fov;\n    this.aspectRatio = aspectRatio;\n    this.near = near;\n    this.far = far;\n    this.xOffset = xOffset;\n    this.yOffset = yOffset;\n  }\n\n  clone() {\n    return new PerspectiveFrustum({\n      aspectRatio: this.aspectRatio,\n      fov: this.fov,\n      near: this.near,\n      far: this.far\n    });\n  }\n\n  equals(other) {\n    if (!defined(other) || !(other instanceof PerspectiveFrustum)) {\n      return false;\n    }\n\n    this._update();\n\n    other._update();\n\n    return this.fov === other.fov && this.aspectRatio === other.aspectRatio && this.near === other.near && this.far === other.far && this._offCenterFrustum.equals(other._offCenterFrustum);\n  }\n\n  get projectionMatrix() {\n    this._update();\n\n    return this._offCenterFrustum.projectionMatrix;\n  }\n\n  get infiniteProjectionMatrix() {\n    this._update();\n\n    return this._offCenterFrustum.infiniteProjectionMatrix;\n  }\n\n  get fovy() {\n    this._update();\n\n    return this._fovy;\n  }\n\n  get sseDenominator() {\n    this._update();\n\n    return this._sseDenominator;\n  }\n\n  computeCullingVolume(position, direction, up) {\n    this._update();\n\n    return this._offCenterFrustum.computeCullingVolume(position, direction, up);\n  }\n\n  getPixelDimensions(drawingBufferWidth, drawingBufferHeight, distance, result) {\n    this._update();\n\n    return this._offCenterFrustum.getPixelDimensions(drawingBufferWidth, drawingBufferHeight, distance, result || new Vector2());\n  }\n\n  _update() {\n    assert(Number.isFinite(this.fov) && Number.isFinite(this.aspectRatio) && Number.isFinite(this.near) && Number.isFinite(this.far));\n    const f = this._offCenterFrustum;\n\n    if (this.fov !== this._fov || this.aspectRatio !== this._aspectRatio || this.near !== this._near || this.far !== this._far || this.xOffset !== this._xOffset || this.yOffset !== this._yOffset) {\n      assert(this.fov >= 0 && this.fov < Math.PI);\n      assert(this.aspectRatio > 0);\n      assert(this.near >= 0 && this.near < this.far);\n      this._aspectRatio = this.aspectRatio;\n      this._fov = this.fov;\n      this._fovy = this.aspectRatio <= 1 ? this.fov : Math.atan(Math.tan(this.fov * 0.5) / this.aspectRatio) * 2.0;\n      this._near = this.near;\n      this._far = this.far;\n      this._sseDenominator = 2.0 * Math.tan(0.5 * this._fovy);\n      this._xOffset = this.xOffset;\n      this._yOffset = this.yOffset;\n      f.top = this.near * Math.tan(0.5 * this._fovy);\n      f.bottom = -f.top;\n      f.right = this.aspectRatio * f.top;\n      f.left = -f.right;\n      f.near = this.near;\n      f.far = this.far;\n      f.right += this.xOffset;\n      f.left += this.xOffset;\n      f.top += this.yOffset;\n      f.bottom += this.yOffset;\n    }\n  }\n\n}\n//# sourceMappingURL=perspective-frustum.js.map\n;// CONCATENATED MODULE: ./node_modules/@math.gl/culling/dist/esm/lib/algorithms/bounding-sphere-from-points.js\n\n\nconst fromPointsXMin = new vector3/* default */.Z();\nconst fromPointsYMin = new vector3/* default */.Z();\nconst fromPointsZMin = new vector3/* default */.Z();\nconst fromPointsXMax = new vector3/* default */.Z();\nconst fromPointsYMax = new vector3/* default */.Z();\nconst fromPointsZMax = new vector3/* default */.Z();\nconst fromPointsCurrentPos = new vector3/* default */.Z();\nconst fromPointsScratch = new vector3/* default */.Z();\nconst fromPointsRitterCenter = new vector3/* default */.Z();\nconst fromPointsMinBoxPt = new vector3/* default */.Z();\nconst fromPointsMaxBoxPt = new vector3/* default */.Z();\nconst fromPointsNaiveCenterScratch = new vector3/* default */.Z();\nconst volumeConstant = 4.0 / 3.0 * Math.PI;\nfunction makeBoundingSphereFromPoints(positions, result = new BoundingSphere()) {\n  if (!positions || positions.length === 0) {\n    return result.fromCenterRadius([0, 0, 0], 0);\n  }\n\n  const currentPos = fromPointsCurrentPos.copy(positions[0]);\n  const xMin = fromPointsXMin.copy(currentPos);\n  const yMin = fromPointsYMin.copy(currentPos);\n  const zMin = fromPointsZMin.copy(currentPos);\n  const xMax = fromPointsXMax.copy(currentPos);\n  const yMax = fromPointsYMax.copy(currentPos);\n  const zMax = fromPointsZMax.copy(currentPos);\n\n  for (const position of positions) {\n    currentPos.copy(position);\n    const x = currentPos.x;\n    const y = currentPos.y;\n    const z = currentPos.z;\n\n    if (x < xMin.x) {\n      xMin.copy(currentPos);\n    }\n\n    if (x > xMax.x) {\n      xMax.copy(currentPos);\n    }\n\n    if (y < yMin.y) {\n      yMin.copy(currentPos);\n    }\n\n    if (y > yMax.y) {\n      yMax.copy(currentPos);\n    }\n\n    if (z < zMin.z) {\n      zMin.copy(currentPos);\n    }\n\n    if (z > zMax.z) {\n      zMax.copy(currentPos);\n    }\n  }\n\n  const xSpan = fromPointsScratch.copy(xMax).subtract(xMin).magnitudeSquared();\n  const ySpan = fromPointsScratch.copy(yMax).subtract(yMin).magnitudeSquared();\n  const zSpan = fromPointsScratch.copy(zMax).subtract(zMin).magnitudeSquared();\n  let diameter1 = xMin;\n  let diameter2 = xMax;\n  let maxSpan = xSpan;\n\n  if (ySpan > maxSpan) {\n    maxSpan = ySpan;\n    diameter1 = yMin;\n    diameter2 = yMax;\n  }\n\n  if (zSpan > maxSpan) {\n    maxSpan = zSpan;\n    diameter1 = zMin;\n    diameter2 = zMax;\n  }\n\n  const ritterCenter = fromPointsRitterCenter;\n  ritterCenter.x = (diameter1.x + diameter2.x) * 0.5;\n  ritterCenter.y = (diameter1.y + diameter2.y) * 0.5;\n  ritterCenter.z = (diameter1.z + diameter2.z) * 0.5;\n  let radiusSquared = fromPointsScratch.copy(diameter2).subtract(ritterCenter).magnitudeSquared();\n  let ritterRadius = Math.sqrt(radiusSquared);\n  const minBoxPt = fromPointsMinBoxPt;\n  minBoxPt.x = xMin.x;\n  minBoxPt.y = yMin.y;\n  minBoxPt.z = zMin.z;\n  const maxBoxPt = fromPointsMaxBoxPt;\n  maxBoxPt.x = xMax.x;\n  maxBoxPt.y = yMax.y;\n  maxBoxPt.z = zMax.z;\n  const naiveCenter = fromPointsNaiveCenterScratch.copy(minBoxPt).add(maxBoxPt).multiplyByScalar(0.5);\n  let naiveRadius = 0;\n\n  for (const position of positions) {\n    currentPos.copy(position);\n    const r = fromPointsScratch.copy(currentPos).subtract(naiveCenter).magnitude();\n\n    if (r > naiveRadius) {\n      naiveRadius = r;\n    }\n\n    const oldCenterToPointSquared = fromPointsScratch.copy(currentPos).subtract(ritterCenter).magnitudeSquared();\n\n    if (oldCenterToPointSquared > radiusSquared) {\n      const oldCenterToPoint = Math.sqrt(oldCenterToPointSquared);\n      ritterRadius = (ritterRadius + oldCenterToPoint) * 0.5;\n      radiusSquared = ritterRadius * ritterRadius;\n      const oldToNew = oldCenterToPoint - ritterRadius;\n      ritterCenter.x = (ritterRadius * ritterCenter.x + oldToNew * currentPos.x) / oldCenterToPoint;\n      ritterCenter.y = (ritterRadius * ritterCenter.y + oldToNew * currentPos.y) / oldCenterToPoint;\n      ritterCenter.z = (ritterRadius * ritterCenter.z + oldToNew * currentPos.z) / oldCenterToPoint;\n    }\n  }\n\n  if (ritterRadius < naiveRadius) {\n    ritterCenter.to(result.center);\n    result.radius = ritterRadius;\n  } else {\n    naiveCenter.to(result.center);\n    result.radius = naiveRadius;\n  }\n\n  return result;\n}\n//# sourceMappingURL=bounding-sphere-from-points.js.map\n;// CONCATENATED MODULE: ./node_modules/@math.gl/core/dist/esm/lib/math-utils.js\n/* harmony default export */ var math_utils = ({\n  EPSILON1: 1e-1,\n  EPSILON2: 1e-2,\n  EPSILON3: 1e-3,\n  EPSILON4: 1e-4,\n  EPSILON5: 1e-5,\n  EPSILON6: 1e-6,\n  EPSILON7: 1e-7,\n  EPSILON8: 1e-8,\n  EPSILON9: 1e-9,\n  EPSILON10: 1e-10,\n  EPSILON11: 1e-11,\n  EPSILON12: 1e-12,\n  EPSILON13: 1e-13,\n  EPSILON14: 1e-14,\n  EPSILON15: 1e-15,\n  EPSILON16: 1e-16,\n  EPSILON17: 1e-17,\n  EPSILON18: 1e-18,\n  EPSILON19: 1e-19,\n  EPSILON20: 1e-20,\n  PI_OVER_TWO: Math.PI / 2,\n  PI_OVER_FOUR: Math.PI / 4,\n  PI_OVER_SIX: Math.PI / 6,\n  TWO_PI: Math.PI * 2\n});\n//# sourceMappingURL=math-utils.js.map\n;// CONCATENATED MODULE: ./node_modules/@math.gl/culling/dist/esm/lib/algorithms/compute-eigen-decomposition.js\n\nconst scratchMatrix = new matrix3/* default */.Z();\nconst scratchUnitary = new matrix3/* default */.Z();\nconst scratchDiagonal = new matrix3/* default */.Z();\nconst jMatrix = new matrix3/* default */.Z();\nconst jMatrixTranspose = new matrix3/* default */.Z();\nfunction computeEigenDecomposition(matrix, result = {}) {\n  const EIGEN_TOLERANCE = math_utils.EPSILON20;\n  const EIGEN_MAX_SWEEPS = 10;\n  let count = 0;\n  let sweep = 0;\n  const unitaryMatrix = scratchUnitary;\n  const diagonalMatrix = scratchDiagonal;\n  unitaryMatrix.identity();\n  diagonalMatrix.copy(matrix);\n  const epsilon = EIGEN_TOLERANCE * computeFrobeniusNorm(diagonalMatrix);\n\n  while (sweep < EIGEN_MAX_SWEEPS && offDiagonalFrobeniusNorm(diagonalMatrix) > epsilon) {\n    shurDecomposition(diagonalMatrix, jMatrix);\n    jMatrixTranspose.copy(jMatrix).transpose();\n    diagonalMatrix.multiplyRight(jMatrix);\n    diagonalMatrix.multiplyLeft(jMatrixTranspose);\n    unitaryMatrix.multiplyRight(jMatrix);\n\n    if (++count > 2) {\n      ++sweep;\n      count = 0;\n    }\n  }\n\n  result.unitary = unitaryMatrix.toTarget(result.unitary);\n  result.diagonal = diagonalMatrix.toTarget(result.diagonal);\n  return result;\n}\n\nfunction computeFrobeniusNorm(matrix) {\n  let norm = 0.0;\n\n  for (let i = 0; i < 9; ++i) {\n    const temp = matrix[i];\n    norm += temp * temp;\n  }\n\n  return Math.sqrt(norm);\n}\n\nconst rowVal = [1, 0, 0];\nconst colVal = [2, 2, 1];\n\nfunction offDiagonalFrobeniusNorm(matrix) {\n  let norm = 0.0;\n\n  for (let i = 0; i < 3; ++i) {\n    const temp = matrix[scratchMatrix.getElementIndex(colVal[i], rowVal[i])];\n    norm += 2.0 * temp * temp;\n  }\n\n  return Math.sqrt(norm);\n}\n\nfunction shurDecomposition(matrix, result) {\n  const tolerance = math_utils.EPSILON15;\n  let maxDiagonal = 0.0;\n  let rotAxis = 1;\n\n  for (let i = 0; i < 3; ++i) {\n    const temp = Math.abs(matrix[scratchMatrix.getElementIndex(colVal[i], rowVal[i])]);\n\n    if (temp > maxDiagonal) {\n      rotAxis = i;\n      maxDiagonal = temp;\n    }\n  }\n\n  const p = rowVal[rotAxis];\n  const q = colVal[rotAxis];\n  let c = 1.0;\n  let s = 0.0;\n\n  if (Math.abs(matrix[scratchMatrix.getElementIndex(q, p)]) > tolerance) {\n    const qq = matrix[scratchMatrix.getElementIndex(q, q)];\n    const pp = matrix[scratchMatrix.getElementIndex(p, p)];\n    const qp = matrix[scratchMatrix.getElementIndex(q, p)];\n    const tau = (qq - pp) / 2.0 / qp;\n    let t;\n\n    if (tau < 0.0) {\n      t = -1.0 / (-tau + Math.sqrt(1.0 + tau * tau));\n    } else {\n      t = 1.0 / (tau + Math.sqrt(1.0 + tau * tau));\n    }\n\n    c = 1.0 / Math.sqrt(1.0 + t * t);\n    s = t * c;\n  }\n\n  matrix3/* default.IDENTITY.to */.Z.IDENTITY.to(result);\n  result[scratchMatrix.getElementIndex(p, p)] = result[scratchMatrix.getElementIndex(q, q)] = c;\n  result[scratchMatrix.getElementIndex(q, p)] = s;\n  result[scratchMatrix.getElementIndex(p, q)] = -s;\n  return result;\n}\n//# sourceMappingURL=compute-eigen-decomposition.js.map\n;// CONCATENATED MODULE: ./node_modules/@math.gl/culling/dist/esm/lib/algorithms/bounding-box-from-points.js\n\n\n\n\nconst bounding_box_from_points_scratchVector2 = new vector3/* default */.Z();\nconst bounding_box_from_points_scratchVector3 = new vector3/* default */.Z();\nconst scratchVector4 = new vector3/* default */.Z();\nconst scratchVector5 = new vector3/* default */.Z();\nconst scratchVector6 = new vector3/* default */.Z();\nconst scratchCovarianceResult = new matrix3/* default */.Z();\nconst scratchEigenResult = {\n  diagonal: new matrix3/* default */.Z(),\n  unitary: new matrix3/* default */.Z()\n};\nfunction makeOrientedBoundingBoxFromPoints(positions, result = new OrientedBoundingBox()) {\n  if (!positions || positions.length === 0) {\n    result.halfAxes = new matrix3/* default */.Z([0, 0, 0, 0, 0, 0, 0, 0, 0]);\n    result.center = new vector3/* default */.Z();\n    return result;\n  }\n\n  const length = positions.length;\n  const meanPoint = new vector3/* default */.Z(0, 0, 0);\n\n  for (const position of positions) {\n    meanPoint.add(position);\n  }\n\n  const invLength = 1.0 / length;\n  meanPoint.multiplyByScalar(invLength);\n  let exx = 0.0;\n  let exy = 0.0;\n  let exz = 0.0;\n  let eyy = 0.0;\n  let eyz = 0.0;\n  let ezz = 0.0;\n\n  for (const position of positions) {\n    const p = bounding_box_from_points_scratchVector2.copy(position).subtract(meanPoint);\n    exx += p.x * p.x;\n    exy += p.x * p.y;\n    exz += p.x * p.z;\n    eyy += p.y * p.y;\n    eyz += p.y * p.z;\n    ezz += p.z * p.z;\n  }\n\n  exx *= invLength;\n  exy *= invLength;\n  exz *= invLength;\n  eyy *= invLength;\n  eyz *= invLength;\n  ezz *= invLength;\n  const covarianceMatrix = scratchCovarianceResult;\n  covarianceMatrix[0] = exx;\n  covarianceMatrix[1] = exy;\n  covarianceMatrix[2] = exz;\n  covarianceMatrix[3] = exy;\n  covarianceMatrix[4] = eyy;\n  covarianceMatrix[5] = eyz;\n  covarianceMatrix[6] = exz;\n  covarianceMatrix[7] = eyz;\n  covarianceMatrix[8] = ezz;\n  const {\n    unitary\n  } = computeEigenDecomposition(covarianceMatrix, scratchEigenResult);\n  const rotation = result.halfAxes.copy(unitary);\n  let v1 = rotation.getColumn(0, scratchVector4);\n  let v2 = rotation.getColumn(1, scratchVector5);\n  let v3 = rotation.getColumn(2, scratchVector6);\n  let u1 = -Number.MAX_VALUE;\n  let u2 = -Number.MAX_VALUE;\n  let u3 = -Number.MAX_VALUE;\n  let l1 = Number.MAX_VALUE;\n  let l2 = Number.MAX_VALUE;\n  let l3 = Number.MAX_VALUE;\n\n  for (const position of positions) {\n    bounding_box_from_points_scratchVector2.copy(position);\n    u1 = Math.max(bounding_box_from_points_scratchVector2.dot(v1), u1);\n    u2 = Math.max(bounding_box_from_points_scratchVector2.dot(v2), u2);\n    u3 = Math.max(bounding_box_from_points_scratchVector2.dot(v3), u3);\n    l1 = Math.min(bounding_box_from_points_scratchVector2.dot(v1), l1);\n    l2 = Math.min(bounding_box_from_points_scratchVector2.dot(v2), l2);\n    l3 = Math.min(bounding_box_from_points_scratchVector2.dot(v3), l3);\n  }\n\n  v1 = v1.multiplyByScalar(0.5 * (l1 + u1));\n  v2 = v2.multiplyByScalar(0.5 * (l2 + u2));\n  v3 = v3.multiplyByScalar(0.5 * (l3 + u3));\n  result.center.copy(v1).add(v2).add(v3);\n  const scale = bounding_box_from_points_scratchVector3.set(u1 - l1, u2 - l2, u3 - l3).multiplyByScalar(0.5);\n  const scaleMatrix = new matrix3/* default */.Z([scale[0], 0, 0, 0, scale[1], 0, 0, 0, scale[2]]);\n  result.halfAxes.multiplyRight(scaleMatrix);\n  return result;\n}\nfunction makeAxisAlignedBoundingBoxFromPoints(positions, result = new AxisAlignedBoundingBox()) {\n  if (!positions || positions.length === 0) {\n    result.minimum.set(0, 0, 0);\n    result.maximum.set(0, 0, 0);\n    result.center.set(0, 0, 0);\n    result.halfDiagonal.set(0, 0, 0);\n    return result;\n  }\n\n  let minimumX = positions[0][0];\n  let minimumY = positions[0][1];\n  let minimumZ = positions[0][2];\n  let maximumX = positions[0][0];\n  let maximumY = positions[0][1];\n  let maximumZ = positions[0][2];\n\n  for (const p of positions) {\n    const x = p[0];\n    const y = p[1];\n    const z = p[2];\n    minimumX = Math.min(x, minimumX);\n    maximumX = Math.max(x, maximumX);\n    minimumY = Math.min(y, minimumY);\n    maximumY = Math.max(y, maximumY);\n    minimumZ = Math.min(z, minimumZ);\n    maximumZ = Math.max(z, maximumZ);\n  }\n\n  result.minimum.set(minimumX, minimumY, minimumZ);\n  result.maximum.set(maximumX, maximumY, maximumZ);\n  result.center.copy(result.minimum).add(result.maximum).scale(0.5);\n  result.halfDiagonal.copy(result.maximum).subtract(result.center);\n  return result;\n}\n//# sourceMappingURL=bounding-box-from-points.js.map\n;// CONCATENATED MODULE: ./node_modules/@math.gl/culling/dist/esm/index.js\n\n\n\n\n\n\n\n\n\n\n\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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YWNrOi8vdnVlMy13ZWJwYWNrNS8uL25vZGVfbW9kdWxlcy9AbWF0aC5nbC9jdWxsaW5nL2Rpc3QvZXNtL2NvbnN0YW50cy5qcz9mZTdhIiwid2VicGFjazovL3Z1ZTMtd2VicGFjazUvLi9ub2RlX21vZHVsZXMvQG1hdGguZ2wvY3VsbGluZy9kaXN0L2VzbS9saWIvYm91bmRpbmctdm9sdW1lcy9heGlzLWFsaWduZWQtYm91bmRpbmctYm94LmpzPzk1NGIiLCJ3ZWJwYWNrOi8vdnVlMy13ZWJwYWNrNS8uL25vZGVfbW9kdWxlcy9AbWF0aC5nbC9jdWxsaW5nL2Rpc3QvZXNtL2xpYi9ib3VuZGluZy12b2x1bWVzL2JvdW5kaW5nLXNwaGVyZS5qcz83MDU1Iiwid2VicGFjazovL3Z1ZTMtd2VicGFjazUvLi9ub2RlX21vZHVsZXMvQG1hdGguZ2wvY3VsbGluZy9kaXN0L2VzbS9saWIvYm91bmRpbmctdm9sdW1lcy9vcmllbnRlZC1ib3VuZGluZy1ib3guanM/MzI2MSIsIndlYnBhY2s6Ly92dWUzLXdlYnBhY2s1Ly4vbm9kZV9tb2R1bGVzL0BtYXRoLmdsL2N1bGxpbmcvZGlzdC9lc20vbGliL3BsYW5lLmpzPzg1YzYiLCJ3ZWJwYWNrOi8vdnVlMy13ZWJwYWNrNS8uL25vZGVfbW9kdWxlcy9AbWF0aC5nbC9jdWxsaW5nL2Rpc3QvZXNtL2xpYi9jdWxsaW5nLXZvbHVtZS5qcz83MTVkIiwid2VicGFjazovL3Z1ZTMtd2VicGFjazUvLi9ub2RlX21vZHVsZXMvQG1hdGguZ2wvY3VsbGluZy9kaXN0L2VzbS9saWIvcGVyc3BlY3RpdmUtb2ZmLWNlbnRlci1mcnVzdHVtLmpzPzliMjMiLCJ3ZWJwYWNrOi8vdnVlMy13ZWJwYWNrNS8uL25vZGVfbW9kdWxlcy9AbWF0aC5nbC9jdWxsaW5nL2Rpc3QvZXNtL2xpYi9wZXJzcGVjdGl2ZS1mcnVzdHVtLmpzPzgwYWUiLCJ3ZWJwYWNrOi8vdnVlMy13ZWJwYWNrNS8uL25vZGVfbW9kdWxlcy9AbWF0aC5nbC9jdWxsaW5nL2Rpc3QvZXNtL2xpYi9hbGdvcml0aG1zL2JvdW5kaW5nLXNwaGVyZS1mcm9tLXBvaW50cy5qcz84Y2M5Iiwid2VicGFjazovL3Z1ZTMtd2VicGFjazUvLi9ub2RlX21vZHVsZXMvQG1hdGguZ2wvY29yZS9kaXN0L2VzbS9saWIvbWF0aC11dGlscy5qcz8zZTIxIiwid2VicGFjazovL3Z1ZTMtd2VicGFjazUvLi9ub2RlX21vZHVsZXMvQG1hdGguZ2wvY3VsbGluZy9kaXN0L2VzbS9saWIvYWxnb3JpdGhtcy9jb21wdXRlLWVpZ2VuLWRlY29tcG9zaXRpb24uanM/MTQxYyIsIndlYnBhY2s6Ly92dWUzLXdlYnBhY2s1Ly4vbm9kZV9tb2R1bGVzL0BtYXRoLmdsL2N1bGxpbmcvZGlzdC9lc20vbGliL2FsZ29yaXRobXMvYm91bmRpbmctYm94LWZyb20tcG9pbnRzLmpzP2MyNzkiLCJ3ZWJwYWNrOi8vdnVlMy13ZWJwYWNrNS8uL25vZGVfbW9kdWxlcy9AbWF0aC5nbC9jdWxsaW5nL2Rpc3QvZXNtL2luZGV4LmpzPzVlY2UiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IGNvbnN0IElOVEVSU0VDVElPTiA9IHtcbiAgT1VUU0lERTogLTEsXG4gIElOVEVSU0VDVElORzogMCxcbiAgSU5TSURFOiAxXG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y29uc3RhbnRzLmpzLm1hcCIsImltcG9ydCBfZGVmaW5lUHJvcGVydHkgZnJvbSBcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL2RlZmluZVByb3BlcnR5XCI7XG5pbXBvcnQgeyBWZWN0b3IzIH0gZnJvbSAnQG1hdGguZ2wvY29yZSc7XG5pbXBvcnQgeyBJTlRFUlNFQ1RJT04gfSBmcm9tICcuLi8uLi9jb25zdGFudHMnO1xuY29uc3Qgc2NyYXRjaFZlY3RvciA9IG5ldyBWZWN0b3IzKCk7XG5jb25zdCBzY3JhdGNoTm9ybWFsID0gbmV3IFZlY3RvcjMoKTtcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEF4aXNBbGlnbmVkQm91bmRpbmdCb3gge1xuICBjb25zdHJ1Y3RvcihtaW5pbXVtID0gWzAsIDAsIDBdLCBtYXhpbXVtID0gWzAsIDAsIDBdLCBjZW50ZXIpIHtcbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJjZW50ZXJcIiwgdm9pZCAwKTtcblxuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImhhbGZEaWFnb25hbFwiLCB2b2lkIDApO1xuXG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwibWluaW11bVwiLCB2b2lkIDApO1xuXG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwibWF4aW11bVwiLCB2b2lkIDApO1xuXG4gICAgY2VudGVyID0gY2VudGVyIHx8IHNjcmF0Y2hWZWN0b3IuY29weShtaW5pbXVtKS5hZGQobWF4aW11bSkuc2NhbGUoMC41KTtcbiAgICB0aGlzLmNlbnRlciA9IG5ldyBWZWN0b3IzKGNlbnRlcik7XG4gICAgdGhpcy5oYWxmRGlhZ29uYWwgPSBuZXcgVmVjdG9yMyhtYXhpbXVtKS5zdWJ0cmFjdCh0aGlzLmNlbnRlcik7XG4gICAgdGhpcy5taW5pbXVtID0gbmV3IFZlY3RvcjMobWluaW11bSk7XG4gICAgdGhpcy5tYXhpbXVtID0gbmV3IFZlY3RvcjMobWF4aW11bSk7XG4gIH1cblxuICBjbG9uZSgpIHtcbiAgICByZXR1cm4gbmV3IEF4aXNBbGlnbmVkQm91bmRpbmdCb3godGhpcy5taW5pbXVtLCB0aGlzLm1heGltdW0sIHRoaXMuY2VudGVyKTtcbiAgfVxuXG4gIGVxdWFscyhyaWdodCkge1xuICAgIHJldHVybiB0aGlzID09PSByaWdodCB8fCBCb29sZWFuKHJpZ2h0KSAmJiB0aGlzLm1pbmltdW0uZXF1YWxzKHJpZ2h0Lm1pbmltdW0pICYmIHRoaXMubWF4aW11bS5lcXVhbHMocmlnaHQubWF4aW11bSk7XG4gIH1cblxuICB0cmFuc2Zvcm0odHJhbnNmb3JtKSB7XG4gICAgdGhpcy5jZW50ZXIudHJhbnNmb3JtQXNQb2ludCh0cmFuc2Zvcm0pO1xuICAgIHRoaXMuaGFsZkRpYWdvbmFsLnRyYW5zZm9ybSh0cmFuc2Zvcm0pO1xuICAgIHRoaXMubWluaW11bS50cmFuc2Zvcm0odHJhbnNmb3JtKTtcbiAgICB0aGlzLm1heGltdW0udHJhbnNmb3JtKHRyYW5zZm9ybSk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICBpbnRlcnNlY3RQbGFuZShwbGFuZSkge1xuICAgIGNvbnN0IHtcbiAgICAgIGhhbGZEaWFnb25hbFxuICAgIH0gPSB0aGlzO1xuICAgIGNvbnN0IG5vcm1hbCA9IHNjcmF0Y2hOb3JtYWwuZnJvbShwbGFuZS5ub3JtYWwpO1xuICAgIGNvbnN0IGUgPSBoYWxmRGlhZ29uYWwueCAqIE1hdGguYWJzKG5vcm1hbC54KSArIGhhbGZEaWFnb25hbC55ICogTWF0aC5hYnMobm9ybWFsLnkpICsgaGFsZkRpYWdvbmFsLnogKiBNYXRoLmFicyhub3JtYWwueik7XG4gICAgY29uc3QgcyA9IHRoaXMuY2VudGVyLmRvdChub3JtYWwpICsgcGxhbmUuZGlzdGFuY2U7XG5cbiAgICBpZiAocyAtIGUgPiAwKSB7XG4gICAgICByZXR1cm4gSU5URVJTRUNUSU9OLklOU0lERTtcbiAgICB9XG5cbiAgICBpZiAocyArIGUgPCAwKSB7XG4gICAgICByZXR1cm4gSU5URVJTRUNUSU9OLk9VVFNJREU7XG4gICAgfVxuXG4gICAgcmV0dXJuIElOVEVSU0VDVElPTi5JTlRFUlNFQ1RJTkc7XG4gIH1cblxuICBkaXN0YW5jZVRvKHBvaW50KSB7XG4gICAgcmV0dXJuIE1hdGguc3FydCh0aGlzLmRpc3RhbmNlU3F1YXJlZFRvKHBvaW50KSk7XG4gIH1cblxuICBkaXN0YW5jZVNxdWFyZWRUbyhwb2ludCkge1xuICAgIGNvbnN0IG9mZnNldCA9IHNjcmF0Y2hWZWN0b3IuZnJvbShwb2ludCkuc3VidHJhY3QodGhpcy5jZW50ZXIpO1xuICAgIGNvbnN0IHtcbiAgICAgIGhhbGZEaWFnb25hbFxuICAgIH0gPSB0aGlzO1xuICAgIGxldCBkaXN0YW5jZVNxdWFyZWQgPSAwLjA7XG4gICAgbGV0IGQ7XG4gICAgZCA9IE1hdGguYWJzKG9mZnNldC54KSAtIGhhbGZEaWFnb25hbC54O1xuXG4gICAgaWYgKGQgPiAwKSB7XG4gICAgICBkaXN0YW5jZVNxdWFyZWQgKz0gZCAqIGQ7XG4gICAgfVxuXG4gICAgZCA9IE1hdGguYWJzKG9mZnNldC55KSAtIGhhbGZEaWFnb25hbC55O1xuXG4gICAgaWYgKGQgPiAwKSB7XG4gICAgICBkaXN0YW5jZVNxdWFyZWQgKz0gZCAqIGQ7XG4gICAgfVxuXG4gICAgZCA9IE1hdGguYWJzKG9mZnNldC56KSAtIGhhbGZEaWFnb25hbC56O1xuXG4gICAgaWYgKGQgPiAwKSB7XG4gICAgICBkaXN0YW5jZVNxdWFyZWQgKz0gZCAqIGQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIGRpc3RhbmNlU3F1YXJlZDtcbiAgfVxuXG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1heGlzLWFsaWduZWQtYm91bmRpbmctYm94LmpzLm1hcCIsImltcG9ydCBfZGVmaW5lUHJvcGVydHkgZnJvbSBcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL2RlZmluZVByb3BlcnR5XCI7XG5pbXBvcnQgeyBWZWN0b3IzIH0gZnJvbSAnQG1hdGguZ2wvY29yZSc7XG5pbXBvcnQgKiBhcyBtYXQ0IGZyb20gJ2dsLW1hdHJpeC9tYXQ0JztcbmltcG9ydCB7IElOVEVSU0VDVElPTiB9IGZyb20gJy4uLy4uL2NvbnN0YW50cyc7XG5jb25zdCBzY3JhdGNoVmVjdG9yID0gbmV3IFZlY3RvcjMoKTtcbmNvbnN0IHNjcmF0Y2hWZWN0b3IyID0gbmV3IFZlY3RvcjMoKTtcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEJvdW5kaW5nU3BoZXJlIHtcbiAgY29uc3RydWN0b3IoY2VudGVyID0gWzAsIDAsIDBdLCByYWRpdXMgPSAwLjApIHtcbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJjZW50ZXJcIiwgdm9pZCAwKTtcblxuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInJhZGl1c1wiLCB2b2lkIDApO1xuXG4gICAgdGhpcy5yYWRpdXMgPSAtMDtcbiAgICB0aGlzLmNlbnRlciA9IG5ldyBWZWN0b3IzKCk7XG4gICAgdGhpcy5mcm9tQ2VudGVyUmFkaXVzKGNlbnRlciwgcmFkaXVzKTtcbiAgfVxuXG4gIGZyb21DZW50ZXJSYWRpdXMoY2VudGVyLCByYWRpdXMpIHtcbiAgICB0aGlzLmNlbnRlci5mcm9tKGNlbnRlcik7XG4gICAgdGhpcy5yYWRpdXMgPSByYWRpdXM7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICBmcm9tQ29ybmVyUG9pbnRzKGNvcm5lciwgb3Bwb3NpdGVDb3JuZXIpIHtcbiAgICBvcHBvc2l0ZUNvcm5lciA9IHNjcmF0Y2hWZWN0b3IuZnJvbShvcHBvc2l0ZUNvcm5lcik7XG4gICAgdGhpcy5jZW50ZXIgPSBuZXcgVmVjdG9yMygpLmZyb20oY29ybmVyKS5hZGQob3Bwb3NpdGVDb3JuZXIpLnNjYWxlKDAuNSk7XG4gICAgdGhpcy5yYWRpdXMgPSB0aGlzLmNlbnRlci5kaXN0YW5jZShvcHBvc2l0ZUNvcm5lcik7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICBlcXVhbHMocmlnaHQpIHtcbiAgICByZXR1cm4gdGhpcyA9PT0gcmlnaHQgfHwgQm9vbGVhbihyaWdodCkgJiYgdGhpcy5jZW50ZXIuZXF1YWxzKHJpZ2h0LmNlbnRlcikgJiYgdGhpcy5yYWRpdXMgPT09IHJpZ2h0LnJhZGl1cztcbiAgfVxuXG4gIGNsb25lKCkge1xuICAgIHJldHVybiBuZXcgQm91bmRpbmdTcGhlcmUodGhpcy5jZW50ZXIsIHRoaXMucmFkaXVzKTtcbiAgfVxuXG4gIHVuaW9uKGJvdW5kaW5nU3BoZXJlKSB7XG4gICAgY29uc3QgbGVmdENlbnRlciA9IHRoaXMuY2VudGVyO1xuICAgIGNvbnN0IGxlZnRSYWRpdXMgPSB0aGlzLnJhZGl1cztcbiAgICBjb25zdCByaWdodENlbnRlciA9IGJvdW5kaW5nU3BoZXJlLmNlbnRlcjtcbiAgICBjb25zdCByaWdodFJhZGl1cyA9IGJvdW5kaW5nU3BoZXJlLnJhZGl1cztcbiAgICBjb25zdCB0b1JpZ2h0Q2VudGVyID0gc2NyYXRjaFZlY3Rvci5jb3B5KHJpZ2h0Q2VudGVyKS5zdWJ0cmFjdChsZWZ0Q2VudGVyKTtcbiAgICBjb25zdCBjZW50ZXJTZXBhcmF0aW9uID0gdG9SaWdodENlbnRlci5tYWduaXR1ZGUoKTtcblxuICAgIGlmIChsZWZ0UmFkaXVzID49IGNlbnRlclNlcGFyYXRpb24gKyByaWdodFJhZGl1cykge1xuICAgICAgcmV0dXJuIHRoaXMuY2xvbmUoKTtcbiAgICB9XG5cbiAgICBpZiAocmlnaHRSYWRpdXMgPj0gY2VudGVyU2VwYXJhdGlvbiArIGxlZnRSYWRpdXMpIHtcbiAgICAgIHJldHVybiBib3VuZGluZ1NwaGVyZS5jbG9uZSgpO1xuICAgIH1cblxuICAgIGNvbnN0IGhhbGZEaXN0YW5jZUJldHdlZW5UYW5nZW50UG9pbnRzID0gKGxlZnRSYWRpdXMgKyBjZW50ZXJTZXBhcmF0aW9uICsgcmlnaHRSYWRpdXMpICogMC41O1xuICAgIHNjcmF0Y2hWZWN0b3IyLmNvcHkodG9SaWdodENlbnRlcikuc2NhbGUoKC1sZWZ0UmFkaXVzICsgaGFsZkRpc3RhbmNlQmV0d2VlblRhbmdlbnRQb2ludHMpIC8gY2VudGVyU2VwYXJhdGlvbikuYWRkKGxlZnRDZW50ZXIpO1xuICAgIHRoaXMuY2VudGVyLmNvcHkoc2NyYXRjaFZlY3RvcjIpO1xuICAgIHRoaXMucmFkaXVzID0gaGFsZkRpc3RhbmNlQmV0d2VlblRhbmdlbnRQb2ludHM7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICBleHBhbmQocG9pbnQpIHtcbiAgICBjb25zdCBzY3JhdGNoUG9pbnQgPSBzY3JhdGNoVmVjdG9yLmZyb20ocG9pbnQpO1xuICAgIGNvbnN0IHJhZGl1cyA9IHNjcmF0Y2hQb2ludC5zdWJ0cmFjdCh0aGlzLmNlbnRlcikubWFnbml0dWRlKCk7XG5cbiAgICBpZiAocmFkaXVzID4gdGhpcy5yYWRpdXMpIHtcbiAgICAgIHRoaXMucmFkaXVzID0gcmFkaXVzO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgdHJhbnNmb3JtKHRyYW5zZm9ybSkge1xuICAgIHRoaXMuY2VudGVyLnRyYW5zZm9ybSh0cmFuc2Zvcm0pO1xuICAgIGNvbnN0IHNjYWxlID0gbWF0NC5nZXRTY2FsaW5nKHNjcmF0Y2hWZWN0b3IsIHRyYW5zZm9ybSk7XG4gICAgdGhpcy5yYWRpdXMgPSBNYXRoLm1heChzY2FsZVswXSwgTWF0aC5tYXgoc2NhbGVbMV0sIHNjYWxlWzJdKSkgKiB0aGlzLnJhZGl1cztcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIGRpc3RhbmNlU3F1YXJlZFRvKHBvaW50KSB7XG4gICAgY29uc3QgZCA9IHRoaXMuZGlzdGFuY2VUbyhwb2ludCk7XG4gICAgcmV0dXJuIGQgKiBkO1xuICB9XG5cbiAgZGlzdGFuY2VUbyhwb2ludCkge1xuICAgIGNvbnN0IHNjcmF0Y2hQb2ludCA9IHNjcmF0Y2hWZWN0b3IuZnJvbShwb2ludCk7XG4gICAgY29uc3QgZGVsdGEgPSBzY3JhdGNoUG9pbnQuc3VidHJhY3QodGhpcy5jZW50ZXIpO1xuICAgIHJldHVybiBNYXRoLm1heCgwLCBkZWx0YS5sZW4oKSAtIHRoaXMucmFkaXVzKTtcbiAgfVxuXG4gIGludGVyc2VjdFBsYW5lKHBsYW5lKSB7XG4gICAgY29uc3QgY2VudGVyID0gdGhpcy5jZW50ZXI7XG4gICAgY29uc3QgcmFkaXVzID0gdGhpcy5yYWRpdXM7XG4gICAgY29uc3Qgbm9ybWFsID0gcGxhbmUubm9ybWFsO1xuICAgIGNvbnN0IGRpc3RhbmNlVG9QbGFuZSA9IG5vcm1hbC5kb3QoY2VudGVyKSArIHBsYW5lLmRpc3RhbmNlO1xuXG4gICAgaWYgKGRpc3RhbmNlVG9QbGFuZSA8IC1yYWRpdXMpIHtcbiAgICAgIHJldHVybiBJTlRFUlNFQ1RJT04uT1VUU0lERTtcbiAgICB9XG5cbiAgICBpZiAoZGlzdGFuY2VUb1BsYW5lIDwgcmFkaXVzKSB7XG4gICAgICByZXR1cm4gSU5URVJTRUNUSU9OLklOVEVSU0VDVElORztcbiAgICB9XG5cbiAgICByZXR1cm4gSU5URVJTRUNUSU9OLklOU0lERTtcbiAgfVxuXG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1ib3VuZGluZy1zcGhlcmUuanMubWFwIiwiaW1wb3J0IF9kZWZpbmVQcm9wZXJ0eSBmcm9tIFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vZGVmaW5lUHJvcGVydHlcIjtcbmltcG9ydCB7IFZlY3RvcjMsIE1hdHJpeDMsIFF1YXRlcm5pb24gfSBmcm9tICdAbWF0aC5nbC9jb3JlJztcbmltcG9ydCBCb3VuZGluZ1NwaGVyZSBmcm9tICcuL2JvdW5kaW5nLXNwaGVyZSc7XG5pbXBvcnQgeyBJTlRFUlNFQ1RJT04gfSBmcm9tICcuLi8uLi9jb25zdGFudHMnO1xuY29uc3Qgc2NyYXRjaFZlY3RvcjMgPSBuZXcgVmVjdG9yMygpO1xuY29uc3Qgc2NyYXRjaE9mZnNldCA9IG5ldyBWZWN0b3IzKCk7XG5jb25zdCBzY3JhdGNoVmVjdG9yVSA9IG5ldyBWZWN0b3IzKCk7XG5jb25zdCBzY3JhdGNoVmVjdG9yViA9IG5ldyBWZWN0b3IzKCk7XG5jb25zdCBzY3JhdGNoVmVjdG9yVyA9IG5ldyBWZWN0b3IzKCk7XG5jb25zdCBzY3JhdGNoQ29ybmVyID0gbmV3IFZlY3RvcjMoKTtcbmNvbnN0IHNjcmF0Y2hUb0NlbnRlciA9IG5ldyBWZWN0b3IzKCk7XG5jb25zdCBNQVRSSVgzID0ge1xuICBDT0xVTU4wUk9XMDogMCxcbiAgQ09MVU1OMFJPVzE6IDEsXG4gIENPTFVNTjBST1cyOiAyLFxuICBDT0xVTU4xUk9XMDogMyxcbiAgQ09MVU1OMVJPVzE6IDQsXG4gIENPTFVNTjFST1cyOiA1LFxuICBDT0xVTU4yUk9XMDogNixcbiAgQ09MVU1OMlJPVzE6IDcsXG4gIENPTFVNTjJST1cyOiA4XG59O1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgT3JpZW50ZWRCb3VuZGluZ0JveCB7XG4gIGNvbnN0cnVjdG9yKGNlbnRlciA9IFswLCAwLCAwXSwgaGFsZkF4ZXMgPSBbMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMF0pIHtcbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJjZW50ZXJcIiwgdm9pZCAwKTtcblxuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImhhbGZBeGVzXCIsIHZvaWQgMCk7XG5cbiAgICB0aGlzLmNlbnRlciA9IG5ldyBWZWN0b3IzKCkuZnJvbShjZW50ZXIpO1xuICAgIHRoaXMuaGFsZkF4ZXMgPSBuZXcgTWF0cml4MyhoYWxmQXhlcyk7XG4gIH1cblxuICBnZXQgaGFsZlNpemUoKSB7XG4gICAgY29uc3QgeEF4aXMgPSB0aGlzLmhhbGZBeGVzLmdldENvbHVtbigwKTtcbiAgICBjb25zdCB5QXhpcyA9IHRoaXMuaGFsZkF4ZXMuZ2V0Q29sdW1uKDEpO1xuICAgIGNvbnN0IHpBeGlzID0gdGhpcy5oYWxmQXhlcy5nZXRDb2x1bW4oMik7XG4gICAgcmV0dXJuIFtuZXcgVmVjdG9yMyh4QXhpcykubGVuKCksIG5ldyBWZWN0b3IzKHlBeGlzKS5sZW4oKSwgbmV3IFZlY3RvcjMoekF4aXMpLmxlbigpXTtcbiAgfVxuXG4gIGdldCBxdWF0ZXJuaW9uKCkge1xuICAgIGNvbnN0IHhBeGlzID0gdGhpcy5oYWxmQXhlcy5nZXRDb2x1bW4oMCk7XG4gICAgY29uc3QgeUF4aXMgPSB0aGlzLmhhbGZBeGVzLmdldENvbHVtbigxKTtcbiAgICBjb25zdCB6QXhpcyA9IHRoaXMuaGFsZkF4ZXMuZ2V0Q29sdW1uKDIpO1xuICAgIGNvbnN0IG5vcm1YQXhpcyA9IG5ldyBWZWN0b3IzKHhBeGlzKS5ub3JtYWxpemUoKTtcbiAgICBjb25zdCBub3JtWUF4aXMgPSBuZXcgVmVjdG9yMyh5QXhpcykubm9ybWFsaXplKCk7XG4gICAgY29uc3Qgbm9ybVpBeGlzID0gbmV3IFZlY3RvcjMoekF4aXMpLm5vcm1hbGl6ZSgpO1xuICAgIHJldHVybiBuZXcgUXVhdGVybmlvbigpLmZyb21NYXRyaXgzKG5ldyBNYXRyaXgzKFsuLi5ub3JtWEF4aXMsIC4uLm5vcm1ZQXhpcywgLi4ubm9ybVpBeGlzXSkpO1xuICB9XG5cbiAgZnJvbUNlbnRlckhhbGZTaXplUXVhdGVybmlvbihjZW50ZXIsIGhhbGZTaXplLCBxdWF0ZXJuaW9uKSB7XG4gICAgY29uc3QgcXVhdGVybmlvbk9iamVjdCA9IG5ldyBRdWF0ZXJuaW9uKHF1YXRlcm5pb24pO1xuICAgIGNvbnN0IGRpcmVjdGlvbnNNYXRyaXggPSBuZXcgTWF0cml4MygpLmZyb21RdWF0ZXJuaW9uKHF1YXRlcm5pb25PYmplY3QpO1xuICAgIGRpcmVjdGlvbnNNYXRyaXhbMF0gPSBkaXJlY3Rpb25zTWF0cml4WzBdICogaGFsZlNpemVbMF07XG4gICAgZGlyZWN0aW9uc01hdHJpeFsxXSA9IGRpcmVjdGlvbnNNYXRyaXhbMV0gKiBoYWxmU2l6ZVswXTtcbiAgICBkaXJlY3Rpb25zTWF0cml4WzJdID0gZGlyZWN0aW9uc01hdHJpeFsyXSAqIGhhbGZTaXplWzBdO1xuICAgIGRpcmVjdGlvbnNNYXRyaXhbM10gPSBkaXJlY3Rpb25zTWF0cml4WzNdICogaGFsZlNpemVbMV07XG4gICAgZGlyZWN0aW9uc01hdHJpeFs0XSA9IGRpcmVjdGlvbnNNYXRyaXhbNF0gKiBoYWxmU2l6ZVsxXTtcbiAgICBkaXJlY3Rpb25zTWF0cml4WzVdID0gZGlyZWN0aW9uc01hdHJpeFs1XSAqIGhhbGZTaXplWzFdO1xuICAgIGRpcmVjdGlvbnNNYXRyaXhbNl0gPSBkaXJlY3Rpb25zTWF0cml4WzZdICogaGFsZlNpemVbMl07XG4gICAgZGlyZWN0aW9uc01hdHJpeFs3XSA9IGRpcmVjdGlvbnNNYXRyaXhbN10gKiBoYWxmU2l6ZVsyXTtcbiAgICBkaXJlY3Rpb25zTWF0cml4WzhdID0gZGlyZWN0aW9uc01hdHJpeFs4XSAqIGhhbGZTaXplWzJdO1xuICAgIHRoaXMuY2VudGVyID0gbmV3IFZlY3RvcjMoKS5mcm9tKGNlbnRlcik7XG4gICAgdGhpcy5oYWxmQXhlcyA9IGRpcmVjdGlvbnNNYXRyaXg7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICBjbG9uZSgpIHtcbiAgICByZXR1cm4gbmV3IE9yaWVudGVkQm91bmRpbmdCb3godGhpcy5jZW50ZXIsIHRoaXMuaGFsZkF4ZXMpO1xuICB9XG5cbiAgZXF1YWxzKHJpZ2h0KSB7XG4gICAgcmV0dXJuIHRoaXMgPT09IHJpZ2h0IHx8IEJvb2xlYW4ocmlnaHQpICYmIHRoaXMuY2VudGVyLmVxdWFscyhyaWdodC5jZW50ZXIpICYmIHRoaXMuaGFsZkF4ZXMuZXF1YWxzKHJpZ2h0LmhhbGZBeGVzKTtcbiAgfVxuXG4gIGdldEJvdW5kaW5nU3BoZXJlKHJlc3VsdCA9IG5ldyBCb3VuZGluZ1NwaGVyZSgpKSB7XG4gICAgY29uc3QgaGFsZkF4ZXMgPSB0aGlzLmhhbGZBeGVzO1xuICAgIGNvbnN0IHUgPSBoYWxmQXhlcy5nZXRDb2x1bW4oMCwgc2NyYXRjaFZlY3RvclUpO1xuICAgIGNvbnN0IHYgPSBoYWxmQXhlcy5nZXRDb2x1bW4oMSwgc2NyYXRjaFZlY3RvclYpO1xuICAgIGNvbnN0IHcgPSBoYWxmQXhlcy5nZXRDb2x1bW4oMiwgc2NyYXRjaFZlY3RvclcpO1xuICAgIGNvbnN0IGNvcm5lclZlY3RvciA9IHNjcmF0Y2hWZWN0b3IzLmNvcHkodSkuYWRkKHYpLmFkZCh3KTtcbiAgICByZXN1bHQuY2VudGVyLmNvcHkodGhpcy5jZW50ZXIpO1xuICAgIHJlc3VsdC5yYWRpdXMgPSBjb3JuZXJWZWN0b3IubWFnbml0dWRlKCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIGludGVyc2VjdFBsYW5lKHBsYW5lKSB7XG4gICAgY29uc3QgY2VudGVyID0gdGhpcy5jZW50ZXI7XG4gICAgY29uc3Qgbm9ybWFsID0gcGxhbmUubm9ybWFsO1xuICAgIGNvbnN0IGhhbGZBeGVzID0gdGhpcy5oYWxmQXhlcztcbiAgICBjb25zdCBub3JtYWxYID0gbm9ybWFsLng7XG4gICAgY29uc3Qgbm9ybWFsWSA9IG5vcm1hbC55O1xuICAgIGNvbnN0IG5vcm1hbFogPSBub3JtYWwuejtcbiAgICBjb25zdCByYWRFZmZlY3RpdmUgPSBNYXRoLmFicyhub3JtYWxYICogaGFsZkF4ZXNbTUFUUklYMy5DT0xVTU4wUk9XMF0gKyBub3JtYWxZICogaGFsZkF4ZXNbTUFUUklYMy5DT0xVTU4wUk9XMV0gKyBub3JtYWxaICogaGFsZkF4ZXNbTUFUUklYMy5DT0xVTU4wUk9XMl0pICsgTWF0aC5hYnMobm9ybWFsWCAqIGhhbGZBeGVzW01BVFJJWDMuQ09MVU1OMVJPVzBdICsgbm9ybWFsWSAqIGhhbGZBeGVzW01BVFJJWDMuQ09MVU1OMVJPVzFdICsgbm9ybWFsWiAqIGhhbGZBeGVzW01BVFJJWDMuQ09MVU1OMVJPVzJdKSArIE1hdGguYWJzKG5vcm1hbFggKiBoYWxmQXhlc1tNQVRSSVgzLkNPTFVNTjJST1cwXSArIG5vcm1hbFkgKiBoYWxmQXhlc1tNQVRSSVgzLkNPTFVNTjJST1cxXSArIG5vcm1hbFogKiBoYWxmQXhlc1tNQVRSSVgzLkNPTFVNTjJST1cyXSk7XG4gICAgY29uc3QgZGlzdGFuY2VUb1BsYW5lID0gbm9ybWFsLmRvdChjZW50ZXIpICsgcGxhbmUuZGlzdGFuY2U7XG5cbiAgICBpZiAoZGlzdGFuY2VUb1BsYW5lIDw9IC1yYWRFZmZlY3RpdmUpIHtcbiAgICAgIHJldHVybiBJTlRFUlNFQ1RJT04uT1VUU0lERTtcbiAgICB9IGVsc2UgaWYgKGRpc3RhbmNlVG9QbGFuZSA+PSByYWRFZmZlY3RpdmUpIHtcbiAgICAgIHJldHVybiBJTlRFUlNFQ1RJT04uSU5TSURFO1xuICAgIH1cblxuICAgIHJldHVybiBJTlRFUlNFQ1RJT04uSU5URVJTRUNUSU5HO1xuICB9XG5cbiAgZGlzdGFuY2VUbyhwb2ludCkge1xuICAgIHJldHVybiBNYXRoLnNxcnQodGhpcy5kaXN0YW5jZVNxdWFyZWRUbyhwb2ludCkpO1xuICB9XG5cbiAgZGlzdGFuY2VTcXVhcmVkVG8ocG9pbnQpIHtcbiAgICBjb25zdCBvZmZzZXQgPSBzY3JhdGNoT2Zmc2V0LmZyb20ocG9pbnQpLnN1YnRyYWN0KHRoaXMuY2VudGVyKTtcbiAgICBjb25zdCBoYWxmQXhlcyA9IHRoaXMuaGFsZkF4ZXM7XG4gICAgY29uc3QgdSA9IGhhbGZBeGVzLmdldENvbHVtbigwLCBzY3JhdGNoVmVjdG9yVSk7XG4gICAgY29uc3QgdiA9IGhhbGZBeGVzLmdldENvbHVtbigxLCBzY3JhdGNoVmVjdG9yVik7XG4gICAgY29uc3QgdyA9IGhhbGZBeGVzLmdldENvbHVtbigyLCBzY3JhdGNoVmVjdG9yVyk7XG4gICAgY29uc3QgdUhhbGYgPSB1Lm1hZ25pdHVkZSgpO1xuICAgIGNvbnN0IHZIYWxmID0gdi5tYWduaXR1ZGUoKTtcbiAgICBjb25zdCB3SGFsZiA9IHcubWFnbml0dWRlKCk7XG4gICAgdS5ub3JtYWxpemUoKTtcbiAgICB2Lm5vcm1hbGl6ZSgpO1xuICAgIHcubm9ybWFsaXplKCk7XG4gICAgbGV0IGRpc3RhbmNlU3F1YXJlZCA9IDAuMDtcbiAgICBsZXQgZDtcbiAgICBkID0gTWF0aC5hYnMob2Zmc2V0LmRvdCh1KSkgLSB1SGFsZjtcblxuICAgIGlmIChkID4gMCkge1xuICAgICAgZGlzdGFuY2VTcXVhcmVkICs9IGQgKiBkO1xuICAgIH1cblxuICAgIGQgPSBNYXRoLmFicyhvZmZzZXQuZG90KHYpKSAtIHZIYWxmO1xuXG4gICAgaWYgKGQgPiAwKSB7XG4gICAgICBkaXN0YW5jZVNxdWFyZWQgKz0gZCAqIGQ7XG4gICAgfVxuXG4gICAgZCA9IE1hdGguYWJzKG9mZnNldC5kb3QodykpIC0gd0hhbGY7XG5cbiAgICBpZiAoZCA+IDApIHtcbiAgICAgIGRpc3RhbmNlU3F1YXJlZCArPSBkICogZDtcbiAgICB9XG5cbiAgICByZXR1cm4gZGlzdGFuY2VTcXVhcmVkO1xuICB9XG5cbiAgY29tcHV0ZVBsYW5lRGlzdGFuY2VzKHBvc2l0aW9uLCBkaXJlY3Rpb24sIHJlc3VsdCA9IFstMCwgLTBdKSB7XG4gICAgbGV0IG1pbkRpc3QgPSBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFk7XG4gICAgbGV0IG1heERpc3QgPSBOdW1iZXIuTkVHQVRJVkVfSU5GSU5JVFk7XG4gICAgY29uc3QgY2VudGVyID0gdGhpcy5jZW50ZXI7XG4gICAgY29uc3QgaGFsZkF4ZXMgPSB0aGlzLmhhbGZBeGVzO1xuICAgIGNvbnN0IHUgPSBoYWxmQXhlcy5nZXRDb2x1bW4oMCwgc2NyYXRjaFZlY3RvclUpO1xuICAgIGNvbnN0IHYgPSBoYWxmQXhlcy5nZXRDb2x1bW4oMSwgc2NyYXRjaFZlY3RvclYpO1xuICAgIGNvbnN0IHcgPSBoYWxmQXhlcy5nZXRDb2x1bW4oMiwgc2NyYXRjaFZlY3RvclcpO1xuICAgIGNvbnN0IGNvcm5lciA9IHNjcmF0Y2hDb3JuZXIuY29weSh1KS5hZGQodikuYWRkKHcpLmFkZChjZW50ZXIpO1xuICAgIGNvbnN0IHRvQ2VudGVyID0gc2NyYXRjaFRvQ2VudGVyLmNvcHkoY29ybmVyKS5zdWJ0cmFjdChwb3NpdGlvbik7XG4gICAgbGV0IG1hZyA9IGRpcmVjdGlvbi5kb3QodG9DZW50ZXIpO1xuICAgIG1pbkRpc3QgPSBNYXRoLm1pbihtYWcsIG1pbkRpc3QpO1xuICAgIG1heERpc3QgPSBNYXRoLm1heChtYWcsIG1heERpc3QpO1xuICAgIGNvcm5lci5jb3B5KGNlbnRlcikuYWRkKHUpLmFkZCh2KS5zdWJ0cmFjdCh3KTtcbiAgICB0b0NlbnRlci5jb3B5KGNvcm5lcikuc3VidHJhY3QocG9zaXRpb24pO1xuICAgIG1hZyA9IGRpcmVjdGlvbi5kb3QodG9DZW50ZXIpO1xuICAgIG1pbkRpc3QgPSBNYXRoLm1pbihtYWcsIG1pbkRpc3QpO1xuICAgIG1heERpc3QgPSBNYXRoLm1heChtYWcsIG1heERpc3QpO1xuICAgIGNvcm5lci5jb3B5KGNlbnRlcikuYWRkKHUpLnN1YnRyYWN0KHYpLmFkZCh3KTtcbiAgICB0b0NlbnRlci5jb3B5KGNvcm5lcikuc3VidHJhY3QocG9zaXRpb24pO1xuICAgIG1hZyA9IGRpcmVjdGlvbi5kb3QodG9DZW50ZXIpO1xuICAgIG1pbkRpc3QgPSBNYXRoLm1pbihtYWcsIG1pbkRpc3QpO1xuICAgIG1heERpc3QgPSBNYXRoLm1heChtYWcsIG1heERpc3QpO1xuICAgIGNvcm5lci5jb3B5KGNlbnRlcikuYWRkKHUpLnN1YnRyYWN0KHYpLnN1YnRyYWN0KHcpO1xuICAgIHRvQ2VudGVyLmNvcHkoY29ybmVyKS5zdWJ0cmFjdChwb3NpdGlvbik7XG4gICAgbWFnID0gZGlyZWN0aW9uLmRvdCh0b0NlbnRlcik7XG4gICAgbWluRGlzdCA9IE1hdGgubWluKG1hZywgbWluRGlzdCk7XG4gICAgbWF4RGlzdCA9IE1hdGgubWF4KG1hZywgbWF4RGlzdCk7XG4gICAgY2VudGVyLmNvcHkoY29ybmVyKS5zdWJ0cmFjdCh1KS5hZGQodikuYWRkKHcpO1xuICAgIHRvQ2VudGVyLmNvcHkoY29ybmVyKS5zdWJ0cmFjdChwb3NpdGlvbik7XG4gICAgbWFnID0gZGlyZWN0aW9uLmRvdCh0b0NlbnRlcik7XG4gICAgbWluRGlzdCA9IE1hdGgubWluKG1hZywgbWluRGlzdCk7XG4gICAgbWF4RGlzdCA9IE1hdGgubWF4KG1hZywgbWF4RGlzdCk7XG4gICAgY2VudGVyLmNvcHkoY29ybmVyKS5zdWJ0cmFjdCh1KS5hZGQodikuc3VidHJhY3Qodyk7XG4gICAgdG9DZW50ZXIuY29weShjb3JuZXIpLnN1YnRyYWN0KHBvc2l0aW9uKTtcbiAgICBtYWcgPSBkaXJlY3Rpb24uZG90KHRvQ2VudGVyKTtcbiAgICBtaW5EaXN0ID0gTWF0aC5taW4obWFnLCBtaW5EaXN0KTtcbiAgICBtYXhEaXN0ID0gTWF0aC5tYXgobWFnLCBtYXhEaXN0KTtcbiAgICBjZW50ZXIuY29weShjb3JuZXIpLnN1YnRyYWN0KHUpLnN1YnRyYWN0KHYpLmFkZCh3KTtcbiAgICB0b0NlbnRlci5jb3B5KGNvcm5lcikuc3VidHJhY3QocG9zaXRpb24pO1xuICAgIG1hZyA9IGRpcmVjdGlvbi5kb3QodG9DZW50ZXIpO1xuICAgIG1pbkRpc3QgPSBNYXRoLm1pbihtYWcsIG1pbkRpc3QpO1xuICAgIG1heERpc3QgPSBNYXRoLm1heChtYWcsIG1heERpc3QpO1xuICAgIGNlbnRlci5jb3B5KGNvcm5lcikuc3VidHJhY3QodSkuc3VidHJhY3Qodikuc3VidHJhY3Qodyk7XG4gICAgdG9DZW50ZXIuY29weShjb3JuZXIpLnN1YnRyYWN0KHBvc2l0aW9uKTtcbiAgICBtYWcgPSBkaXJlY3Rpb24uZG90KHRvQ2VudGVyKTtcbiAgICBtaW5EaXN0ID0gTWF0aC5taW4obWFnLCBtaW5EaXN0KTtcbiAgICBtYXhEaXN0ID0gTWF0aC5tYXgobWFnLCBtYXhEaXN0KTtcbiAgICByZXN1bHRbMF0gPSBtaW5EaXN0O1xuICAgIHJlc3VsdFsxXSA9IG1heERpc3Q7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIHRyYW5zZm9ybSh0cmFuc2Zvcm1hdGlvbikge1xuICAgIHRoaXMuY2VudGVyLnRyYW5zZm9ybUFzUG9pbnQodHJhbnNmb3JtYXRpb24pO1xuICAgIGNvbnN0IHhBeGlzID0gdGhpcy5oYWxmQXhlcy5nZXRDb2x1bW4oMCwgc2NyYXRjaFZlY3RvclUpO1xuICAgIHhBeGlzLnRyYW5zZm9ybUFzUG9pbnQodHJhbnNmb3JtYXRpb24pO1xuICAgIGNvbnN0IHlBeGlzID0gdGhpcy5oYWxmQXhlcy5nZXRDb2x1bW4oMSwgc2NyYXRjaFZlY3RvclYpO1xuICAgIHlBeGlzLnRyYW5zZm9ybUFzUG9pbnQodHJhbnNmb3JtYXRpb24pO1xuICAgIGNvbnN0IHpBeGlzID0gdGhpcy5oYWxmQXhlcy5nZXRDb2x1bW4oMiwgc2NyYXRjaFZlY3RvclcpO1xuICAgIHpBeGlzLnRyYW5zZm9ybUFzUG9pbnQodHJhbnNmb3JtYXRpb24pO1xuICAgIHRoaXMuaGFsZkF4ZXMgPSBuZXcgTWF0cml4MyhbLi4ueEF4aXMsIC4uLnlBeGlzLCAuLi56QXhpc10pO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgZ2V0VHJhbnNmb3JtKCkge1xuICAgIHRocm93IG5ldyBFcnJvcignbm90IGltcGxlbWVudGVkJyk7XG4gIH1cblxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9b3JpZW50ZWQtYm91bmRpbmctYm94LmpzLm1hcCIsImltcG9ydCBfZGVmaW5lUHJvcGVydHkgZnJvbSBcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL2RlZmluZVByb3BlcnR5XCI7XG5pbXBvcnQgeyBWZWN0b3IzLCBlcXVhbHMsIGFzc2VydCB9IGZyb20gJ0BtYXRoLmdsL2NvcmUnO1xuY29uc3Qgc2NyYXRjaFBvc2l0aW9uID0gbmV3IFZlY3RvcjMoKTtcbmNvbnN0IHNjcmF0Y2hOb3JtYWwgPSBuZXcgVmVjdG9yMygpO1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgUGxhbmUge1xuICBjb25zdHJ1Y3Rvcihub3JtYWwgPSBbMCwgMCwgMV0sIGRpc3RhbmNlID0gMCkge1xuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIm5vcm1hbFwiLCB2b2lkIDApO1xuXG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwiZGlzdGFuY2VcIiwgdm9pZCAwKTtcblxuICAgIHRoaXMubm9ybWFsID0gbmV3IFZlY3RvcjMoKTtcbiAgICB0aGlzLmRpc3RhbmNlID0gLTA7XG4gICAgdGhpcy5mcm9tTm9ybWFsRGlzdGFuY2Uobm9ybWFsLCBkaXN0YW5jZSk7XG4gIH1cblxuICBmcm9tTm9ybWFsRGlzdGFuY2Uobm9ybWFsLCBkaXN0YW5jZSkge1xuICAgIGFzc2VydChOdW1iZXIuaXNGaW5pdGUoZGlzdGFuY2UpKTtcbiAgICB0aGlzLm5vcm1hbC5mcm9tKG5vcm1hbCkubm9ybWFsaXplKCk7XG4gICAgdGhpcy5kaXN0YW5jZSA9IGRpc3RhbmNlO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgZnJvbVBvaW50Tm9ybWFsKHBvaW50LCBub3JtYWwpIHtcbiAgICBwb2ludCA9IHNjcmF0Y2hQb3NpdGlvbi5mcm9tKHBvaW50KTtcbiAgICB0aGlzLm5vcm1hbC5mcm9tKG5vcm1hbCkubm9ybWFsaXplKCk7XG4gICAgY29uc3QgZGlzdGFuY2UgPSAtdGhpcy5ub3JtYWwuZG90KHBvaW50KTtcbiAgICB0aGlzLmRpc3RhbmNlID0gZGlzdGFuY2U7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICBmcm9tQ29lZmZpY2llbnRzKGEsIGIsIGMsIGQpIHtcbiAgICB0aGlzLm5vcm1hbC5zZXQoYSwgYiwgYyk7XG4gICAgYXNzZXJ0KGVxdWFscyh0aGlzLm5vcm1hbC5sZW4oKSwgMSkpO1xuICAgIHRoaXMuZGlzdGFuY2UgPSBkO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgY2xvbmUoKSB7XG4gICAgcmV0dXJuIG5ldyBQbGFuZSh0aGlzLm5vcm1hbCwgdGhpcy5kaXN0YW5jZSk7XG4gIH1cblxuICBlcXVhbHMocmlnaHQpIHtcbiAgICByZXR1cm4gZXF1YWxzKHRoaXMuZGlzdGFuY2UsIHJpZ2h0LmRpc3RhbmNlKSAmJiBlcXVhbHModGhpcy5ub3JtYWwsIHJpZ2h0Lm5vcm1hbCk7XG4gIH1cblxuICBnZXRQb2ludERpc3RhbmNlKHBvaW50KSB7XG4gICAgcmV0dXJuIHRoaXMubm9ybWFsLmRvdChwb2ludCkgKyB0aGlzLmRpc3RhbmNlO1xuICB9XG5cbiAgdHJhbnNmb3JtKG1hdHJpeDQpIHtcbiAgICBjb25zdCBub3JtYWwgPSBzY3JhdGNoTm9ybWFsLmNvcHkodGhpcy5ub3JtYWwpLnRyYW5zZm9ybUFzVmVjdG9yKG1hdHJpeDQpLm5vcm1hbGl6ZSgpO1xuICAgIGNvbnN0IHBvaW50ID0gdGhpcy5ub3JtYWwuc2NhbGUoLXRoaXMuZGlzdGFuY2UpLnRyYW5zZm9ybShtYXRyaXg0KTtcbiAgICByZXR1cm4gdGhpcy5mcm9tUG9pbnROb3JtYWwocG9pbnQsIG5vcm1hbCk7XG4gIH1cblxuICBwcm9qZWN0UG9pbnRPbnRvUGxhbmUocG9pbnQsIHJlc3VsdCA9IFswLCAwLCAwXSkge1xuICAgIHBvaW50ID0gc2NyYXRjaFBvc2l0aW9uLmZyb20ocG9pbnQpO1xuICAgIGNvbnN0IHBvaW50RGlzdGFuY2UgPSB0aGlzLmdldFBvaW50RGlzdGFuY2UocG9pbnQpO1xuICAgIGNvbnN0IHNjYWxlZE5vcm1hbCA9IHNjcmF0Y2hOb3JtYWwuY29weSh0aGlzLm5vcm1hbCkuc2NhbGUocG9pbnREaXN0YW5jZSk7XG4gICAgcmV0dXJuIHBvaW50LnN1YnRyYWN0KHNjYWxlZE5vcm1hbCkudG8ocmVzdWx0KTtcbiAgfVxuXG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1wbGFuZS5qcy5tYXAiLCJpbXBvcnQgX2RlZmluZVByb3BlcnR5IGZyb20gXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9kZWZpbmVQcm9wZXJ0eVwiO1xuaW1wb3J0IHsgVmVjdG9yMywgYXNzZXJ0IH0gZnJvbSAnQG1hdGguZ2wvY29yZSc7XG5pbXBvcnQgeyBJTlRFUlNFQ1RJT04gfSBmcm9tICcuLi9jb25zdGFudHMnO1xuaW1wb3J0IFBsYW5lIGZyb20gJy4vcGxhbmUnO1xuY29uc3QgZmFjZXMgPSBbbmV3IFZlY3RvcjMoWzEsIDAsIDBdKSwgbmV3IFZlY3RvcjMoWzAsIDEsIDBdKSwgbmV3IFZlY3RvcjMoWzAsIDAsIDFdKV07XG5jb25zdCBzY3JhdGNoUGxhbmVDZW50ZXIgPSBuZXcgVmVjdG9yMygpO1xuY29uc3Qgc2NyYXRjaFBsYW5lTm9ybWFsID0gbmV3IFZlY3RvcjMoKTtcbmNvbnN0IHNjcmF0Y2hQbGFuZSA9IG5ldyBQbGFuZShuZXcgVmVjdG9yMygxLjAsIDAuMCwgMC4wKSwgMC4wKTtcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEN1bGxpbmdWb2x1bWUge1xuICBjb25zdHJ1Y3RvcihwbGFuZXMgPSBbXSkge1xuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInBsYW5lc1wiLCB2b2lkIDApO1xuXG4gICAgdGhpcy5wbGFuZXMgPSBwbGFuZXM7XG4gIH1cblxuICBmcm9tQm91bmRpbmdTcGhlcmUoYm91bmRpbmdTcGhlcmUpIHtcbiAgICB0aGlzLnBsYW5lcy5sZW5ndGggPSAyICogZmFjZXMubGVuZ3RoO1xuICAgIGNvbnN0IGNlbnRlciA9IGJvdW5kaW5nU3BoZXJlLmNlbnRlcjtcbiAgICBjb25zdCByYWRpdXMgPSBib3VuZGluZ1NwaGVyZS5yYWRpdXM7XG4gICAgbGV0IHBsYW5lSW5kZXggPSAwO1xuXG4gICAgZm9yIChjb25zdCBmYWNlTm9ybWFsIG9mIGZhY2VzKSB7XG4gICAgICBsZXQgcGxhbmUwID0gdGhpcy5wbGFuZXNbcGxhbmVJbmRleF07XG4gICAgICBsZXQgcGxhbmUxID0gdGhpcy5wbGFuZXNbcGxhbmVJbmRleCArIDFdO1xuXG4gICAgICBpZiAoIXBsYW5lMCkge1xuICAgICAgICBwbGFuZTAgPSB0aGlzLnBsYW5lc1twbGFuZUluZGV4XSA9IG5ldyBQbGFuZSgpO1xuICAgICAgfVxuXG4gICAgICBpZiAoIXBsYW5lMSkge1xuICAgICAgICBwbGFuZTEgPSB0aGlzLnBsYW5lc1twbGFuZUluZGV4ICsgMV0gPSBuZXcgUGxhbmUoKTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgcGxhbmUwQ2VudGVyID0gc2NyYXRjaFBsYW5lQ2VudGVyLmNvcHkoZmFjZU5vcm1hbCkuc2NhbGUoLXJhZGl1cykuYWRkKGNlbnRlcik7XG4gICAgICBjb25zdCBwbGFuZTBEaXN0YW5jZSA9IC1mYWNlTm9ybWFsLmRvdChwbGFuZTBDZW50ZXIpO1xuICAgICAgcGxhbmUwLmZyb21Qb2ludE5vcm1hbChwbGFuZTBDZW50ZXIsIGZhY2VOb3JtYWwpO1xuICAgICAgY29uc3QgcGxhbmUxQ2VudGVyID0gc2NyYXRjaFBsYW5lQ2VudGVyLmNvcHkoZmFjZU5vcm1hbCkuc2NhbGUocmFkaXVzKS5hZGQoY2VudGVyKTtcbiAgICAgIGNvbnN0IG5lZ2F0ZWRGYWNlTm9ybWFsID0gc2NyYXRjaFBsYW5lTm9ybWFsLmNvcHkoZmFjZU5vcm1hbCkubmVnYXRlKCk7XG4gICAgICBjb25zdCBwbGFuZTFEaXN0YW5jZSA9IC1uZWdhdGVkRmFjZU5vcm1hbC5kb3QocGxhbmUxQ2VudGVyKTtcbiAgICAgIHBsYW5lMS5mcm9tUG9pbnROb3JtYWwocGxhbmUxQ2VudGVyLCBuZWdhdGVkRmFjZU5vcm1hbCk7XG4gICAgICBwbGFuZUluZGV4ICs9IDI7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICBjb21wdXRlVmlzaWJpbGl0eShib3VuZGluZ1ZvbHVtZSkge1xuICAgIGxldCBpbnRlcnNlY3QgPSBJTlRFUlNFQ1RJT04uSU5TSURFO1xuXG4gICAgZm9yIChjb25zdCBwbGFuZSBvZiB0aGlzLnBsYW5lcykge1xuICAgICAgY29uc3QgcmVzdWx0ID0gYm91bmRpbmdWb2x1bWUuaW50ZXJzZWN0UGxhbmUocGxhbmUpO1xuXG4gICAgICBzd2l0Y2ggKHJlc3VsdCkge1xuICAgICAgICBjYXNlIElOVEVSU0VDVElPTi5PVVRTSURFOlxuICAgICAgICAgIHJldHVybiBJTlRFUlNFQ1RJT04uT1VUU0lERTtcblxuICAgICAgICBjYXNlIElOVEVSU0VDVElPTi5JTlRFUlNFQ1RJTkc6XG4gICAgICAgICAgaW50ZXJzZWN0ID0gSU5URVJTRUNUSU9OLklOVEVSU0VDVElORztcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBkZWZhdWx0OlxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBpbnRlcnNlY3Q7XG4gIH1cblxuICBjb21wdXRlVmlzaWJpbGl0eVdpdGhQbGFuZU1hc2soYm91bmRpbmdWb2x1bWUsIHBhcmVudFBsYW5lTWFzaykge1xuICAgIGFzc2VydChOdW1iZXIuaXNGaW5pdGUocGFyZW50UGxhbmVNYXNrKSwgJ3BhcmVudFBsYW5lTWFzayBpcyByZXF1aXJlZC4nKTtcblxuICAgIGlmIChwYXJlbnRQbGFuZU1hc2sgPT09IEN1bGxpbmdWb2x1bWUuTUFTS19PVVRTSURFIHx8IHBhcmVudFBsYW5lTWFzayA9PT0gQ3VsbGluZ1ZvbHVtZS5NQVNLX0lOU0lERSkge1xuICAgICAgcmV0dXJuIHBhcmVudFBsYW5lTWFzaztcbiAgICB9XG5cbiAgICBsZXQgbWFzayA9IEN1bGxpbmdWb2x1bWUuTUFTS19JTlNJREU7XG4gICAgY29uc3QgcGxhbmVzID0gdGhpcy5wbGFuZXM7XG5cbiAgICBmb3IgKGxldCBrID0gMDsgayA8IHRoaXMucGxhbmVzLmxlbmd0aDsgKytrKSB7XG4gICAgICBjb25zdCBmbGFnID0gayA8IDMxID8gMSA8PCBrIDogMDtcblxuICAgICAgaWYgKGsgPCAzMSAmJiAocGFyZW50UGxhbmVNYXNrICYgZmxhZykgPT09IDApIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHBsYW5lID0gcGxhbmVzW2tdO1xuICAgICAgY29uc3QgcmVzdWx0ID0gYm91bmRpbmdWb2x1bWUuaW50ZXJzZWN0UGxhbmUocGxhbmUpO1xuXG4gICAgICBpZiAocmVzdWx0ID09PSBJTlRFUlNFQ1RJT04uT1VUU0lERSkge1xuICAgICAgICByZXR1cm4gQ3VsbGluZ1ZvbHVtZS5NQVNLX09VVFNJREU7XG4gICAgICB9IGVsc2UgaWYgKHJlc3VsdCA9PT0gSU5URVJTRUNUSU9OLklOVEVSU0VDVElORykge1xuICAgICAgICBtYXNrIHw9IGZsYWc7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIG1hc2s7XG4gIH1cblxufVxuXG5fZGVmaW5lUHJvcGVydHkoQ3VsbGluZ1ZvbHVtZSwgXCJNQVNLX09VVFNJREVcIiwgMHhmZmZmZmZmZik7XG5cbl9kZWZpbmVQcm9wZXJ0eShDdWxsaW5nVm9sdW1lLCBcIk1BU0tfSU5TSURFXCIsIDB4MDAwMDAwMDApO1xuXG5fZGVmaW5lUHJvcGVydHkoQ3VsbGluZ1ZvbHVtZSwgXCJNQVNLX0lOREVURVJNSU5BVEVcIiwgMHg3ZmZmZmZmZik7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jdWxsaW5nLXZvbHVtZS5qcy5tYXAiLCJpbXBvcnQgX2RlZmluZVByb3BlcnR5IGZyb20gXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9kZWZpbmVQcm9wZXJ0eVwiO1xuaW1wb3J0IHsgVmVjdG9yMywgTWF0cml4NCwgYXNzZXJ0IH0gZnJvbSAnQG1hdGguZ2wvY29yZSc7XG5pbXBvcnQgQ3VsbGluZ1ZvbHVtZSBmcm9tICcuL2N1bGxpbmctdm9sdW1lJztcbmltcG9ydCBQbGFuZSBmcm9tICcuL3BsYW5lJztcbmNvbnN0IHNjcmF0Y2hQbGFuZVVwVmVjdG9yID0gbmV3IFZlY3RvcjMoKTtcbmNvbnN0IHNjcmF0Y2hQbGFuZVJpZ2h0VmVjdG9yID0gbmV3IFZlY3RvcjMoKTtcbmNvbnN0IHNjcmF0Y2hQbGFuZU5lYXJDZW50ZXIgPSBuZXcgVmVjdG9yMygpO1xuY29uc3Qgc2NyYXRjaFBsYW5lRmFyQ2VudGVyID0gbmV3IFZlY3RvcjMoKTtcbmNvbnN0IHNjcmF0Y2hQbGFuZU5vcm1hbCA9IG5ldyBWZWN0b3IzKCk7XG5leHBvcnQgZGVmYXVsdCBjbGFzcyBQZXJzcGVjdGl2ZU9mZkNlbnRlckZydXN0dW0ge1xuICBjb25zdHJ1Y3RvcihvcHRpb25zID0ge30pIHtcbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJsZWZ0XCIsIHZvaWQgMCk7XG5cbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJfbGVmdFwiLCB2b2lkIDApO1xuXG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwicmlnaHRcIiwgdm9pZCAwKTtcblxuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIl9yaWdodFwiLCB2b2lkIDApO1xuXG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwidG9wXCIsIHZvaWQgMCk7XG5cbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJfdG9wXCIsIHZvaWQgMCk7XG5cbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJib3R0b21cIiwgdm9pZCAwKTtcblxuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIl9ib3R0b21cIiwgdm9pZCAwKTtcblxuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIm5lYXJcIiwgdm9pZCAwKTtcblxuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIl9uZWFyXCIsIHZvaWQgMCk7XG5cbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJmYXJcIiwgdm9pZCAwKTtcblxuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIl9mYXJcIiwgdm9pZCAwKTtcblxuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIl9jdWxsaW5nVm9sdW1lXCIsIG5ldyBDdWxsaW5nVm9sdW1lKFtuZXcgUGxhbmUoKSwgbmV3IFBsYW5lKCksIG5ldyBQbGFuZSgpLCBuZXcgUGxhbmUoKSwgbmV3IFBsYW5lKCksIG5ldyBQbGFuZSgpXSkpO1xuXG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwiX3BlcnNwZWN0aXZlTWF0cml4XCIsIG5ldyBNYXRyaXg0KCkpO1xuXG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwiX2luZmluaXRlUGVyc3BlY3RpdmVcIiwgbmV3IE1hdHJpeDQoKSk7XG5cbiAgICBjb25zdCB7XG4gICAgICBuZWFyID0gMS4wLFxuICAgICAgZmFyID0gNTAwMDAwMDAwLjBcbiAgICB9ID0gb3B0aW9ucztcbiAgICB0aGlzLmxlZnQgPSBvcHRpb25zLmxlZnQ7XG4gICAgdGhpcy5fbGVmdCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLnJpZ2h0ID0gb3B0aW9ucy5yaWdodDtcbiAgICB0aGlzLl9yaWdodCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLnRvcCA9IG9wdGlvbnMudG9wO1xuICAgIHRoaXMuX3RvcCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLmJvdHRvbSA9IG9wdGlvbnMuYm90dG9tO1xuICAgIHRoaXMuX2JvdHRvbSA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLm5lYXIgPSBuZWFyO1xuICAgIHRoaXMuX25lYXIgPSBuZWFyO1xuICAgIHRoaXMuZmFyID0gZmFyO1xuICAgIHRoaXMuX2ZhciA9IGZhcjtcbiAgfVxuXG4gIGNsb25lKCkge1xuICAgIHJldHVybiBuZXcgUGVyc3BlY3RpdmVPZmZDZW50ZXJGcnVzdHVtKHtcbiAgICAgIHJpZ2h0OiB0aGlzLnJpZ2h0LFxuICAgICAgbGVmdDogdGhpcy5sZWZ0LFxuICAgICAgdG9wOiB0aGlzLnRvcCxcbiAgICAgIGJvdHRvbTogdGhpcy5ib3R0b20sXG4gICAgICBuZWFyOiB0aGlzLm5lYXIsXG4gICAgICBmYXI6IHRoaXMuZmFyXG4gICAgfSk7XG4gIH1cblxuICBlcXVhbHMob3RoZXIpIHtcbiAgICByZXR1cm4gb3RoZXIgJiYgb3RoZXIgaW5zdGFuY2VvZiBQZXJzcGVjdGl2ZU9mZkNlbnRlckZydXN0dW0gJiYgdGhpcy5yaWdodCA9PT0gb3RoZXIucmlnaHQgJiYgdGhpcy5sZWZ0ID09PSBvdGhlci5sZWZ0ICYmIHRoaXMudG9wID09PSBvdGhlci50b3AgJiYgdGhpcy5ib3R0b20gPT09IG90aGVyLmJvdHRvbSAmJiB0aGlzLm5lYXIgPT09IG90aGVyLm5lYXIgJiYgdGhpcy5mYXIgPT09IG90aGVyLmZhcjtcbiAgfVxuXG4gIGdldCBwcm9qZWN0aW9uTWF0cml4KCkge1xuICAgIHRoaXMuX3VwZGF0ZSgpO1xuXG4gICAgcmV0dXJuIHRoaXMuX3BlcnNwZWN0aXZlTWF0cml4O1xuICB9XG5cbiAgZ2V0IGluZmluaXRlUHJvamVjdGlvbk1hdHJpeCgpIHtcbiAgICB0aGlzLl91cGRhdGUoKTtcblxuICAgIHJldHVybiB0aGlzLl9pbmZpbml0ZVBlcnNwZWN0aXZlO1xuICB9XG5cbiAgY29tcHV0ZUN1bGxpbmdWb2x1bWUocG9zaXRpb24sIGRpcmVjdGlvbiwgdXApIHtcbiAgICBhc3NlcnQocG9zaXRpb24sICdwb3NpdGlvbiBpcyByZXF1aXJlZC4nKTtcbiAgICBhc3NlcnQoZGlyZWN0aW9uLCAnZGlyZWN0aW9uIGlzIHJlcXVpcmVkLicpO1xuICAgIGFzc2VydCh1cCwgJ3VwIGlzIHJlcXVpcmVkLicpO1xuICAgIGNvbnN0IHBsYW5lcyA9IHRoaXMuX2N1bGxpbmdWb2x1bWUucGxhbmVzO1xuICAgIHVwID0gc2NyYXRjaFBsYW5lVXBWZWN0b3IuY29weSh1cCkubm9ybWFsaXplKCk7XG4gICAgY29uc3QgcmlnaHQgPSBzY3JhdGNoUGxhbmVSaWdodFZlY3Rvci5jb3B5KGRpcmVjdGlvbikuY3Jvc3ModXApLm5vcm1hbGl6ZSgpO1xuICAgIGNvbnN0IG5lYXJDZW50ZXIgPSBzY3JhdGNoUGxhbmVOZWFyQ2VudGVyLmNvcHkoZGlyZWN0aW9uKS5tdWx0aXBseUJ5U2NhbGFyKHRoaXMubmVhcikuYWRkKHBvc2l0aW9uKTtcbiAgICBjb25zdCBmYXJDZW50ZXIgPSBzY3JhdGNoUGxhbmVGYXJDZW50ZXIuY29weShkaXJlY3Rpb24pLm11bHRpcGx5QnlTY2FsYXIodGhpcy5mYXIpLmFkZChwb3NpdGlvbik7XG4gICAgbGV0IG5vcm1hbCA9IHNjcmF0Y2hQbGFuZU5vcm1hbDtcbiAgICBub3JtYWwuY29weShyaWdodCkubXVsdGlwbHlCeVNjYWxhcih0aGlzLmxlZnQpLmFkZChuZWFyQ2VudGVyKS5zdWJ0cmFjdChwb3NpdGlvbikuY3Jvc3ModXApO1xuICAgIHBsYW5lc1swXS5mcm9tUG9pbnROb3JtYWwocG9zaXRpb24sIG5vcm1hbCk7XG4gICAgbm9ybWFsLmNvcHkocmlnaHQpLm11bHRpcGx5QnlTY2FsYXIodGhpcy5yaWdodCkuYWRkKG5lYXJDZW50ZXIpLnN1YnRyYWN0KHBvc2l0aW9uKS5jcm9zcyh1cCkubmVnYXRlKCk7XG4gICAgcGxhbmVzWzFdLmZyb21Qb2ludE5vcm1hbChwb3NpdGlvbiwgbm9ybWFsKTtcbiAgICBub3JtYWwuY29weSh1cCkubXVsdGlwbHlCeVNjYWxhcih0aGlzLmJvdHRvbSkuYWRkKG5lYXJDZW50ZXIpLnN1YnRyYWN0KHBvc2l0aW9uKS5jcm9zcyhyaWdodCkubmVnYXRlKCk7XG4gICAgcGxhbmVzWzJdLmZyb21Qb2ludE5vcm1hbChwb3NpdGlvbiwgbm9ybWFsKTtcbiAgICBub3JtYWwuY29weSh1cCkubXVsdGlwbHlCeVNjYWxhcih0aGlzLnRvcCkuYWRkKG5lYXJDZW50ZXIpLnN1YnRyYWN0KHBvc2l0aW9uKS5jcm9zcyhyaWdodCk7XG4gICAgcGxhbmVzWzNdLmZyb21Qb2ludE5vcm1hbChwb3NpdGlvbiwgbm9ybWFsKTtcbiAgICBub3JtYWwgPSBuZXcgVmVjdG9yMygpLmNvcHkoZGlyZWN0aW9uKTtcbiAgICBwbGFuZXNbNF0uZnJvbVBvaW50Tm9ybWFsKG5lYXJDZW50ZXIsIG5vcm1hbCk7XG4gICAgbm9ybWFsLm5lZ2F0ZSgpO1xuICAgIHBsYW5lc1s1XS5mcm9tUG9pbnROb3JtYWwoZmFyQ2VudGVyLCBub3JtYWwpO1xuICAgIHJldHVybiB0aGlzLl9jdWxsaW5nVm9sdW1lO1xuICB9XG5cbiAgZ2V0UGl4ZWxEaW1lbnNpb25zKGRyYXdpbmdCdWZmZXJXaWR0aCwgZHJhd2luZ0J1ZmZlckhlaWdodCwgZGlzdGFuY2UsIHJlc3VsdCkge1xuICAgIHRoaXMuX3VwZGF0ZSgpO1xuXG4gICAgYXNzZXJ0KE51bWJlci5pc0Zpbml0ZShkcmF3aW5nQnVmZmVyV2lkdGgpICYmIE51bWJlci5pc0Zpbml0ZShkcmF3aW5nQnVmZmVySGVpZ2h0KSk7XG4gICAgYXNzZXJ0KGRyYXdpbmdCdWZmZXJXaWR0aCA+IDApO1xuICAgIGFzc2VydChkcmF3aW5nQnVmZmVySGVpZ2h0ID4gMCk7XG4gICAgYXNzZXJ0KGRpc3RhbmNlID4gMCk7XG4gICAgYXNzZXJ0KHJlc3VsdCk7XG4gICAgY29uc3QgaW52ZXJzZU5lYXIgPSAxLjAgLyB0aGlzLm5lYXI7XG4gICAgbGV0IHRhblRoZXRhID0gdGhpcy50b3AgKiBpbnZlcnNlTmVhcjtcbiAgICBjb25zdCBwaXhlbEhlaWdodCA9IDIuMCAqIGRpc3RhbmNlICogdGFuVGhldGEgLyBkcmF3aW5nQnVmZmVySGVpZ2h0O1xuICAgIHRhblRoZXRhID0gdGhpcy5yaWdodCAqIGludmVyc2VOZWFyO1xuICAgIGNvbnN0IHBpeGVsV2lkdGggPSAyLjAgKiBkaXN0YW5jZSAqIHRhblRoZXRhIC8gZHJhd2luZ0J1ZmZlcldpZHRoO1xuICAgIHJlc3VsdC54ID0gcGl4ZWxXaWR0aDtcbiAgICByZXN1bHQueSA9IHBpeGVsSGVpZ2h0O1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICBfdXBkYXRlKCkge1xuICAgIGFzc2VydChOdW1iZXIuaXNGaW5pdGUodGhpcy5yaWdodCkgJiYgTnVtYmVyLmlzRmluaXRlKHRoaXMubGVmdCkgJiYgTnVtYmVyLmlzRmluaXRlKHRoaXMudG9wKSAmJiBOdW1iZXIuaXNGaW5pdGUodGhpcy5ib3R0b20pICYmIE51bWJlci5pc0Zpbml0ZSh0aGlzLm5lYXIpICYmIE51bWJlci5pc0Zpbml0ZSh0aGlzLmZhcikpO1xuICAgIGNvbnN0IHtcbiAgICAgIHRvcCxcbiAgICAgIGJvdHRvbSxcbiAgICAgIHJpZ2h0LFxuICAgICAgbGVmdCxcbiAgICAgIG5lYXIsXG4gICAgICBmYXJcbiAgICB9ID0gdGhpcztcblxuICAgIGlmICh0b3AgIT09IHRoaXMuX3RvcCB8fCBib3R0b20gIT09IHRoaXMuX2JvdHRvbSB8fCBsZWZ0ICE9PSB0aGlzLl9sZWZ0IHx8IHJpZ2h0ICE9PSB0aGlzLl9yaWdodCB8fCBuZWFyICE9PSB0aGlzLl9uZWFyIHx8IGZhciAhPT0gdGhpcy5fZmFyKSB7XG4gICAgICBhc3NlcnQodGhpcy5uZWFyID4gMCAmJiB0aGlzLm5lYXIgPCB0aGlzLmZhciwgJ25lYXIgbXVzdCBiZSBncmVhdGVyIHRoYW4gemVybyBhbmQgbGVzcyB0aGFuIGZhci4nKTtcbiAgICAgIHRoaXMuX2xlZnQgPSBsZWZ0O1xuICAgICAgdGhpcy5fcmlnaHQgPSByaWdodDtcbiAgICAgIHRoaXMuX3RvcCA9IHRvcDtcbiAgICAgIHRoaXMuX2JvdHRvbSA9IGJvdHRvbTtcbiAgICAgIHRoaXMuX25lYXIgPSBuZWFyO1xuICAgICAgdGhpcy5fZmFyID0gZmFyO1xuICAgICAgdGhpcy5fcGVyc3BlY3RpdmVNYXRyaXggPSBuZXcgTWF0cml4NCgpLmZydXN0dW0oe1xuICAgICAgICBsZWZ0LFxuICAgICAgICByaWdodCxcbiAgICAgICAgYm90dG9tLFxuICAgICAgICB0b3AsXG4gICAgICAgIG5lYXIsXG4gICAgICAgIGZhclxuICAgICAgfSk7XG4gICAgICB0aGlzLl9pbmZpbml0ZVBlcnNwZWN0aXZlID0gbmV3IE1hdHJpeDQoKS5mcnVzdHVtKHtcbiAgICAgICAgbGVmdCxcbiAgICAgICAgcmlnaHQsXG4gICAgICAgIGJvdHRvbSxcbiAgICAgICAgdG9wLFxuICAgICAgICBuZWFyLFxuICAgICAgICBmYXI6IEluZmluaXR5XG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cGVyc3BlY3RpdmUtb2ZmLWNlbnRlci1mcnVzdHVtLmpzLm1hcCIsImltcG9ydCBfZGVmaW5lUHJvcGVydHkgZnJvbSBcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL2RlZmluZVByb3BlcnR5XCI7XG5pbXBvcnQgeyBhc3NlcnQsIFZlY3RvcjIgfSBmcm9tICdAbWF0aC5nbC9jb3JlJztcbmltcG9ydCBQZXJzcGVjdGl2ZU9mZkNlbnRlckZydXN0dW0gZnJvbSAnLi9wZXJzcGVjdGl2ZS1vZmYtY2VudGVyLWZydXN0dW0nO1xuXG5jb25zdCBkZWZpbmVkID0gdmFsID0+IHZhbCAhPT0gbnVsbCAmJiB0eXBlb2YgdmFsICE9PSAndW5kZWZpbmVkJztcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgUGVyc3BlY3RpdmVGcnVzdHVtIHtcbiAgY29uc3RydWN0b3Iob3B0aW9ucyA9IHt9KSB7XG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwiX29mZkNlbnRlckZydXN0dW1cIiwgbmV3IFBlcnNwZWN0aXZlT2ZmQ2VudGVyRnJ1c3R1bSgpKTtcblxuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImZvdlwiLCB2b2lkIDApO1xuXG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwiX2ZvdlwiLCB2b2lkIDApO1xuXG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwiX2ZvdnlcIiwgdm9pZCAwKTtcblxuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIl9zc2VEZW5vbWluYXRvclwiLCB2b2lkIDApO1xuXG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwiYXNwZWN0UmF0aW9cIiwgdm9pZCAwKTtcblxuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIl9hc3BlY3RSYXRpb1wiLCB2b2lkIDApO1xuXG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwibmVhclwiLCB2b2lkIDApO1xuXG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwiX25lYXJcIiwgdm9pZCAwKTtcblxuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImZhclwiLCB2b2lkIDApO1xuXG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwiX2ZhclwiLCB2b2lkIDApO1xuXG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwieE9mZnNldFwiLCB2b2lkIDApO1xuXG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwiX3hPZmZzZXRcIiwgdm9pZCAwKTtcblxuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInlPZmZzZXRcIiwgdm9pZCAwKTtcblxuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIl95T2Zmc2V0XCIsIHZvaWQgMCk7XG5cbiAgICBjb25zdCB7XG4gICAgICBmb3YsXG4gICAgICBhc3BlY3RSYXRpbyxcbiAgICAgIG5lYXIgPSAxLjAsXG4gICAgICBmYXIgPSA1MDAwMDAwMDAuMCxcbiAgICAgIHhPZmZzZXQgPSAwLjAsXG4gICAgICB5T2Zmc2V0ID0gMC4wXG4gICAgfSA9IG9wdGlvbnM7XG4gICAgdGhpcy5mb3YgPSBmb3Y7XG4gICAgdGhpcy5hc3BlY3RSYXRpbyA9IGFzcGVjdFJhdGlvO1xuICAgIHRoaXMubmVhciA9IG5lYXI7XG4gICAgdGhpcy5mYXIgPSBmYXI7XG4gICAgdGhpcy54T2Zmc2V0ID0geE9mZnNldDtcbiAgICB0aGlzLnlPZmZzZXQgPSB5T2Zmc2V0O1xuICB9XG5cbiAgY2xvbmUoKSB7XG4gICAgcmV0dXJuIG5ldyBQZXJzcGVjdGl2ZUZydXN0dW0oe1xuICAgICAgYXNwZWN0UmF0aW86IHRoaXMuYXNwZWN0UmF0aW8sXG4gICAgICBmb3Y6IHRoaXMuZm92LFxuICAgICAgbmVhcjogdGhpcy5uZWFyLFxuICAgICAgZmFyOiB0aGlzLmZhclxuICAgIH0pO1xuICB9XG5cbiAgZXF1YWxzKG90aGVyKSB7XG4gICAgaWYgKCFkZWZpbmVkKG90aGVyKSB8fCAhKG90aGVyIGluc3RhbmNlb2YgUGVyc3BlY3RpdmVGcnVzdHVtKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHRoaXMuX3VwZGF0ZSgpO1xuXG4gICAgb3RoZXIuX3VwZGF0ZSgpO1xuXG4gICAgcmV0dXJuIHRoaXMuZm92ID09PSBvdGhlci5mb3YgJiYgdGhpcy5hc3BlY3RSYXRpbyA9PT0gb3RoZXIuYXNwZWN0UmF0aW8gJiYgdGhpcy5uZWFyID09PSBvdGhlci5uZWFyICYmIHRoaXMuZmFyID09PSBvdGhlci5mYXIgJiYgdGhpcy5fb2ZmQ2VudGVyRnJ1c3R1bS5lcXVhbHMob3RoZXIuX29mZkNlbnRlckZydXN0dW0pO1xuICB9XG5cbiAgZ2V0IHByb2plY3Rpb25NYXRyaXgoKSB7XG4gICAgdGhpcy5fdXBkYXRlKCk7XG5cbiAgICByZXR1cm4gdGhpcy5fb2ZmQ2VudGVyRnJ1c3R1bS5wcm9qZWN0aW9uTWF0cml4O1xuICB9XG5cbiAgZ2V0IGluZmluaXRlUHJvamVjdGlvbk1hdHJpeCgpIHtcbiAgICB0aGlzLl91cGRhdGUoKTtcblxuICAgIHJldHVybiB0aGlzLl9vZmZDZW50ZXJGcnVzdHVtLmluZmluaXRlUHJvamVjdGlvbk1hdHJpeDtcbiAgfVxuXG4gIGdldCBmb3Z5KCkge1xuICAgIHRoaXMuX3VwZGF0ZSgpO1xuXG4gICAgcmV0dXJuIHRoaXMuX2Zvdnk7XG4gIH1cblxuICBnZXQgc3NlRGVub21pbmF0b3IoKSB7XG4gICAgdGhpcy5fdXBkYXRlKCk7XG5cbiAgICByZXR1cm4gdGhpcy5fc3NlRGVub21pbmF0b3I7XG4gIH1cblxuICBjb21wdXRlQ3VsbGluZ1ZvbHVtZShwb3NpdGlvbiwgZGlyZWN0aW9uLCB1cCkge1xuICAgIHRoaXMuX3VwZGF0ZSgpO1xuXG4gICAgcmV0dXJuIHRoaXMuX29mZkNlbnRlckZydXN0dW0uY29tcHV0ZUN1bGxpbmdWb2x1bWUocG9zaXRpb24sIGRpcmVjdGlvbiwgdXApO1xuICB9XG5cbiAgZ2V0UGl4ZWxEaW1lbnNpb25zKGRyYXdpbmdCdWZmZXJXaWR0aCwgZHJhd2luZ0J1ZmZlckhlaWdodCwgZGlzdGFuY2UsIHJlc3VsdCkge1xuICAgIHRoaXMuX3VwZGF0ZSgpO1xuXG4gICAgcmV0dXJuIHRoaXMuX29mZkNlbnRlckZydXN0dW0uZ2V0UGl4ZWxEaW1lbnNpb25zKGRyYXdpbmdCdWZmZXJXaWR0aCwgZHJhd2luZ0J1ZmZlckhlaWdodCwgZGlzdGFuY2UsIHJlc3VsdCB8fCBuZXcgVmVjdG9yMigpKTtcbiAgfVxuXG4gIF91cGRhdGUoKSB7XG4gICAgYXNzZXJ0KE51bWJlci5pc0Zpbml0ZSh0aGlzLmZvdikgJiYgTnVtYmVyLmlzRmluaXRlKHRoaXMuYXNwZWN0UmF0aW8pICYmIE51bWJlci5pc0Zpbml0ZSh0aGlzLm5lYXIpICYmIE51bWJlci5pc0Zpbml0ZSh0aGlzLmZhcikpO1xuICAgIGNvbnN0IGYgPSB0aGlzLl9vZmZDZW50ZXJGcnVzdHVtO1xuXG4gICAgaWYgKHRoaXMuZm92ICE9PSB0aGlzLl9mb3YgfHwgdGhpcy5hc3BlY3RSYXRpbyAhPT0gdGhpcy5fYXNwZWN0UmF0aW8gfHwgdGhpcy5uZWFyICE9PSB0aGlzLl9uZWFyIHx8IHRoaXMuZmFyICE9PSB0aGlzLl9mYXIgfHwgdGhpcy54T2Zmc2V0ICE9PSB0aGlzLl94T2Zmc2V0IHx8IHRoaXMueU9mZnNldCAhPT0gdGhpcy5feU9mZnNldCkge1xuICAgICAgYXNzZXJ0KHRoaXMuZm92ID49IDAgJiYgdGhpcy5mb3YgPCBNYXRoLlBJKTtcbiAgICAgIGFzc2VydCh0aGlzLmFzcGVjdFJhdGlvID4gMCk7XG4gICAgICBhc3NlcnQodGhpcy5uZWFyID49IDAgJiYgdGhpcy5uZWFyIDwgdGhpcy5mYXIpO1xuICAgICAgdGhpcy5fYXNwZWN0UmF0aW8gPSB0aGlzLmFzcGVjdFJhdGlvO1xuICAgICAgdGhpcy5fZm92ID0gdGhpcy5mb3Y7XG4gICAgICB0aGlzLl9mb3Z5ID0gdGhpcy5hc3BlY3RSYXRpbyA8PSAxID8gdGhpcy5mb3YgOiBNYXRoLmF0YW4oTWF0aC50YW4odGhpcy5mb3YgKiAwLjUpIC8gdGhpcy5hc3BlY3RSYXRpbykgKiAyLjA7XG4gICAgICB0aGlzLl9uZWFyID0gdGhpcy5uZWFyO1xuICAgICAgdGhpcy5fZmFyID0gdGhpcy5mYXI7XG4gICAgICB0aGlzLl9zc2VEZW5vbWluYXRvciA9IDIuMCAqIE1hdGgudGFuKDAuNSAqIHRoaXMuX2ZvdnkpO1xuICAgICAgdGhpcy5feE9mZnNldCA9IHRoaXMueE9mZnNldDtcbiAgICAgIHRoaXMuX3lPZmZzZXQgPSB0aGlzLnlPZmZzZXQ7XG4gICAgICBmLnRvcCA9IHRoaXMubmVhciAqIE1hdGgudGFuKDAuNSAqIHRoaXMuX2ZvdnkpO1xuICAgICAgZi5ib3R0b20gPSAtZi50b3A7XG4gICAgICBmLnJpZ2h0ID0gdGhpcy5hc3BlY3RSYXRpbyAqIGYudG9wO1xuICAgICAgZi5sZWZ0ID0gLWYucmlnaHQ7XG4gICAgICBmLm5lYXIgPSB0aGlzLm5lYXI7XG4gICAgICBmLmZhciA9IHRoaXMuZmFyO1xuICAgICAgZi5yaWdodCArPSB0aGlzLnhPZmZzZXQ7XG4gICAgICBmLmxlZnQgKz0gdGhpcy54T2Zmc2V0O1xuICAgICAgZi50b3AgKz0gdGhpcy55T2Zmc2V0O1xuICAgICAgZi5ib3R0b20gKz0gdGhpcy55T2Zmc2V0O1xuICAgIH1cbiAgfVxuXG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1wZXJzcGVjdGl2ZS1mcnVzdHVtLmpzLm1hcCIsImltcG9ydCB7IFZlY3RvcjMgfSBmcm9tICdAbWF0aC5nbC9jb3JlJztcbmltcG9ydCBCb3VuZGluZ1NwaGVyZSBmcm9tICcuLi9ib3VuZGluZy12b2x1bWVzL2JvdW5kaW5nLXNwaGVyZSc7XG5jb25zdCBmcm9tUG9pbnRzWE1pbiA9IG5ldyBWZWN0b3IzKCk7XG5jb25zdCBmcm9tUG9pbnRzWU1pbiA9IG5ldyBWZWN0b3IzKCk7XG5jb25zdCBmcm9tUG9pbnRzWk1pbiA9IG5ldyBWZWN0b3IzKCk7XG5jb25zdCBmcm9tUG9pbnRzWE1heCA9IG5ldyBWZWN0b3IzKCk7XG5jb25zdCBmcm9tUG9pbnRzWU1heCA9IG5ldyBWZWN0b3IzKCk7XG5jb25zdCBmcm9tUG9pbnRzWk1heCA9IG5ldyBWZWN0b3IzKCk7XG5jb25zdCBmcm9tUG9pbnRzQ3VycmVudFBvcyA9IG5ldyBWZWN0b3IzKCk7XG5jb25zdCBmcm9tUG9pbnRzU2NyYXRjaCA9IG5ldyBWZWN0b3IzKCk7XG5jb25zdCBmcm9tUG9pbnRzUml0dGVyQ2VudGVyID0gbmV3IFZlY3RvcjMoKTtcbmNvbnN0IGZyb21Qb2ludHNNaW5Cb3hQdCA9IG5ldyBWZWN0b3IzKCk7XG5jb25zdCBmcm9tUG9pbnRzTWF4Qm94UHQgPSBuZXcgVmVjdG9yMygpO1xuY29uc3QgZnJvbVBvaW50c05haXZlQ2VudGVyU2NyYXRjaCA9IG5ldyBWZWN0b3IzKCk7XG5jb25zdCB2b2x1bWVDb25zdGFudCA9IDQuMCAvIDMuMCAqIE1hdGguUEk7XG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBtYWtlQm91bmRpbmdTcGhlcmVGcm9tUG9pbnRzKHBvc2l0aW9ucywgcmVzdWx0ID0gbmV3IEJvdW5kaW5nU3BoZXJlKCkpIHtcbiAgaWYgKCFwb3NpdGlvbnMgfHwgcG9zaXRpb25zLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiByZXN1bHQuZnJvbUNlbnRlclJhZGl1cyhbMCwgMCwgMF0sIDApO1xuICB9XG5cbiAgY29uc3QgY3VycmVudFBvcyA9IGZyb21Qb2ludHNDdXJyZW50UG9zLmNvcHkocG9zaXRpb25zWzBdKTtcbiAgY29uc3QgeE1pbiA9IGZyb21Qb2ludHNYTWluLmNvcHkoY3VycmVudFBvcyk7XG4gIGNvbnN0IHlNaW4gPSBmcm9tUG9pbnRzWU1pbi5jb3B5KGN1cnJlbnRQb3MpO1xuICBjb25zdCB6TWluID0gZnJvbVBvaW50c1pNaW4uY29weShjdXJyZW50UG9zKTtcbiAgY29uc3QgeE1heCA9IGZyb21Qb2ludHNYTWF4LmNvcHkoY3VycmVudFBvcyk7XG4gIGNvbnN0IHlNYXggPSBmcm9tUG9pbnRzWU1heC5jb3B5KGN1cnJlbnRQb3MpO1xuICBjb25zdCB6TWF4ID0gZnJvbVBvaW50c1pNYXguY29weShjdXJyZW50UG9zKTtcblxuICBmb3IgKGNvbnN0IHBvc2l0aW9uIG9mIHBvc2l0aW9ucykge1xuICAgIGN1cnJlbnRQb3MuY29weShwb3NpdGlvbik7XG4gICAgY29uc3QgeCA9IGN1cnJlbnRQb3MueDtcbiAgICBjb25zdCB5ID0gY3VycmVudFBvcy55O1xuICAgIGNvbnN0IHogPSBjdXJyZW50UG9zLno7XG5cbiAgICBpZiAoeCA8IHhNaW4ueCkge1xuICAgICAgeE1pbi5jb3B5KGN1cnJlbnRQb3MpO1xuICAgIH1cblxuICAgIGlmICh4ID4geE1heC54KSB7XG4gICAgICB4TWF4LmNvcHkoY3VycmVudFBvcyk7XG4gICAgfVxuXG4gICAgaWYgKHkgPCB5TWluLnkpIHtcbiAgICAgIHlNaW4uY29weShjdXJyZW50UG9zKTtcbiAgICB9XG5cbiAgICBpZiAoeSA+IHlNYXgueSkge1xuICAgICAgeU1heC5jb3B5KGN1cnJlbnRQb3MpO1xuICAgIH1cblxuICAgIGlmICh6IDwgek1pbi56KSB7XG4gICAgICB6TWluLmNvcHkoY3VycmVudFBvcyk7XG4gICAgfVxuXG4gICAgaWYgKHogPiB6TWF4LnopIHtcbiAgICAgIHpNYXguY29weShjdXJyZW50UG9zKTtcbiAgICB9XG4gIH1cblxuICBjb25zdCB4U3BhbiA9IGZyb21Qb2ludHNTY3JhdGNoLmNvcHkoeE1heCkuc3VidHJhY3QoeE1pbikubWFnbml0dWRlU3F1YXJlZCgpO1xuICBjb25zdCB5U3BhbiA9IGZyb21Qb2ludHNTY3JhdGNoLmNvcHkoeU1heCkuc3VidHJhY3QoeU1pbikubWFnbml0dWRlU3F1YXJlZCgpO1xuICBjb25zdCB6U3BhbiA9IGZyb21Qb2ludHNTY3JhdGNoLmNvcHkoek1heCkuc3VidHJhY3Qoek1pbikubWFnbml0dWRlU3F1YXJlZCgpO1xuICBsZXQgZGlhbWV0ZXIxID0geE1pbjtcbiAgbGV0IGRpYW1ldGVyMiA9IHhNYXg7XG4gIGxldCBtYXhTcGFuID0geFNwYW47XG5cbiAgaWYgKHlTcGFuID4gbWF4U3Bhbikge1xuICAgIG1heFNwYW4gPSB5U3BhbjtcbiAgICBkaWFtZXRlcjEgPSB5TWluO1xuICAgIGRpYW1ldGVyMiA9IHlNYXg7XG4gIH1cblxuICBpZiAoelNwYW4gPiBtYXhTcGFuKSB7XG4gICAgbWF4U3BhbiA9IHpTcGFuO1xuICAgIGRpYW1ldGVyMSA9IHpNaW47XG4gICAgZGlhbWV0ZXIyID0gek1heDtcbiAgfVxuXG4gIGNvbnN0IHJpdHRlckNlbnRlciA9IGZyb21Qb2ludHNSaXR0ZXJDZW50ZXI7XG4gIHJpdHRlckNlbnRlci54ID0gKGRpYW1ldGVyMS54ICsgZGlhbWV0ZXIyLngpICogMC41O1xuICByaXR0ZXJDZW50ZXIueSA9IChkaWFtZXRlcjEueSArIGRpYW1ldGVyMi55KSAqIDAuNTtcbiAgcml0dGVyQ2VudGVyLnogPSAoZGlhbWV0ZXIxLnogKyBkaWFtZXRlcjIueikgKiAwLjU7XG4gIGxldCByYWRpdXNTcXVhcmVkID0gZnJvbVBvaW50c1NjcmF0Y2guY29weShkaWFtZXRlcjIpLnN1YnRyYWN0KHJpdHRlckNlbnRlcikubWFnbml0dWRlU3F1YXJlZCgpO1xuICBsZXQgcml0dGVyUmFkaXVzID0gTWF0aC5zcXJ0KHJhZGl1c1NxdWFyZWQpO1xuICBjb25zdCBtaW5Cb3hQdCA9IGZyb21Qb2ludHNNaW5Cb3hQdDtcbiAgbWluQm94UHQueCA9IHhNaW4ueDtcbiAgbWluQm94UHQueSA9IHlNaW4ueTtcbiAgbWluQm94UHQueiA9IHpNaW4uejtcbiAgY29uc3QgbWF4Qm94UHQgPSBmcm9tUG9pbnRzTWF4Qm94UHQ7XG4gIG1heEJveFB0LnggPSB4TWF4Lng7XG4gIG1heEJveFB0LnkgPSB5TWF4Lnk7XG4gIG1heEJveFB0LnogPSB6TWF4Lno7XG4gIGNvbnN0IG5haXZlQ2VudGVyID0gZnJvbVBvaW50c05haXZlQ2VudGVyU2NyYXRjaC5jb3B5KG1pbkJveFB0KS5hZGQobWF4Qm94UHQpLm11bHRpcGx5QnlTY2FsYXIoMC41KTtcbiAgbGV0IG5haXZlUmFkaXVzID0gMDtcblxuICBmb3IgKGNvbnN0IHBvc2l0aW9uIG9mIHBvc2l0aW9ucykge1xuICAgIGN1cnJlbnRQb3MuY29weShwb3NpdGlvbik7XG4gICAgY29uc3QgciA9IGZyb21Qb2ludHNTY3JhdGNoLmNvcHkoY3VycmVudFBvcykuc3VidHJhY3QobmFpdmVDZW50ZXIpLm1hZ25pdHVkZSgpO1xuXG4gICAgaWYgKHIgPiBuYWl2ZVJhZGl1cykge1xuICAgICAgbmFpdmVSYWRpdXMgPSByO1xuICAgIH1cblxuICAgIGNvbnN0IG9sZENlbnRlclRvUG9pbnRTcXVhcmVkID0gZnJvbVBvaW50c1NjcmF0Y2guY29weShjdXJyZW50UG9zKS5zdWJ0cmFjdChyaXR0ZXJDZW50ZXIpLm1hZ25pdHVkZVNxdWFyZWQoKTtcblxuICAgIGlmIChvbGRDZW50ZXJUb1BvaW50U3F1YXJlZCA+IHJhZGl1c1NxdWFyZWQpIHtcbiAgICAgIGNvbnN0IG9sZENlbnRlclRvUG9pbnQgPSBNYXRoLnNxcnQob2xkQ2VudGVyVG9Qb2ludFNxdWFyZWQpO1xuICAgICAgcml0dGVyUmFkaXVzID0gKHJpdHRlclJhZGl1cyArIG9sZENlbnRlclRvUG9pbnQpICogMC41O1xuICAgICAgcmFkaXVzU3F1YXJlZCA9IHJpdHRlclJhZGl1cyAqIHJpdHRlclJhZGl1cztcbiAgICAgIGNvbnN0IG9sZFRvTmV3ID0gb2xkQ2VudGVyVG9Qb2ludCAtIHJpdHRlclJhZGl1cztcbiAgICAgIHJpdHRlckNlbnRlci54ID0gKHJpdHRlclJhZGl1cyAqIHJpdHRlckNlbnRlci54ICsgb2xkVG9OZXcgKiBjdXJyZW50UG9zLngpIC8gb2xkQ2VudGVyVG9Qb2ludDtcbiAgICAgIHJpdHRlckNlbnRlci55ID0gKHJpdHRlclJhZGl1cyAqIHJpdHRlckNlbnRlci55ICsgb2xkVG9OZXcgKiBjdXJyZW50UG9zLnkpIC8gb2xkQ2VudGVyVG9Qb2ludDtcbiAgICAgIHJpdHRlckNlbnRlci56ID0gKHJpdHRlclJhZGl1cyAqIHJpdHRlckNlbnRlci56ICsgb2xkVG9OZXcgKiBjdXJyZW50UG9zLnopIC8gb2xkQ2VudGVyVG9Qb2ludDtcbiAgICB9XG4gIH1cblxuICBpZiAocml0dGVyUmFkaXVzIDwgbmFpdmVSYWRpdXMpIHtcbiAgICByaXR0ZXJDZW50ZXIudG8ocmVzdWx0LmNlbnRlcik7XG4gICAgcmVzdWx0LnJhZGl1cyA9IHJpdHRlclJhZGl1cztcbiAgfSBlbHNlIHtcbiAgICBuYWl2ZUNlbnRlci50byhyZXN1bHQuY2VudGVyKTtcbiAgICByZXN1bHQucmFkaXVzID0gbmFpdmVSYWRpdXM7XG4gIH1cblxuICByZXR1cm4gcmVzdWx0O1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Ym91bmRpbmctc3BoZXJlLWZyb20tcG9pbnRzLmpzLm1hcCIsImV4cG9ydCBkZWZhdWx0IHtcbiAgRVBTSUxPTjE6IDFlLTEsXG4gIEVQU0lMT04yOiAxZS0yLFxuICBFUFNJTE9OMzogMWUtMyxcbiAgRVBTSUxPTjQ6IDFlLTQsXG4gIEVQU0lMT041OiAxZS01LFxuICBFUFNJTE9ONjogMWUtNixcbiAgRVBTSUxPTjc6IDFlLTcsXG4gIEVQU0lMT044OiAxZS04LFxuICBFUFNJTE9OOTogMWUtOSxcbiAgRVBTSUxPTjEwOiAxZS0xMCxcbiAgRVBTSUxPTjExOiAxZS0xMSxcbiAgRVBTSUxPTjEyOiAxZS0xMixcbiAgRVBTSUxPTjEzOiAxZS0xMyxcbiAgRVBTSUxPTjE0OiAxZS0xNCxcbiAgRVBTSUxPTjE1OiAxZS0xNSxcbiAgRVBTSUxPTjE2OiAxZS0xNixcbiAgRVBTSUxPTjE3OiAxZS0xNyxcbiAgRVBTSUxPTjE4OiAxZS0xOCxcbiAgRVBTSUxPTjE5OiAxZS0xOSxcbiAgRVBTSUxPTjIwOiAxZS0yMCxcbiAgUElfT1ZFUl9UV086IE1hdGguUEkgLyAyLFxuICBQSV9PVkVSX0ZPVVI6IE1hdGguUEkgLyA0LFxuICBQSV9PVkVSX1NJWDogTWF0aC5QSSAvIDYsXG4gIFRXT19QSTogTWF0aC5QSSAqIDJcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1tYXRoLXV0aWxzLmpzLm1hcCIsImltcG9ydCB7IE1hdHJpeDMsIF9NYXRoVXRpbHMgfSBmcm9tICdAbWF0aC5nbC9jb3JlJztcbmNvbnN0IHNjcmF0Y2hNYXRyaXggPSBuZXcgTWF0cml4MygpO1xuY29uc3Qgc2NyYXRjaFVuaXRhcnkgPSBuZXcgTWF0cml4MygpO1xuY29uc3Qgc2NyYXRjaERpYWdvbmFsID0gbmV3IE1hdHJpeDMoKTtcbmNvbnN0IGpNYXRyaXggPSBuZXcgTWF0cml4MygpO1xuY29uc3Qgak1hdHJpeFRyYW5zcG9zZSA9IG5ldyBNYXRyaXgzKCk7XG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBjb21wdXRlRWlnZW5EZWNvbXBvc2l0aW9uKG1hdHJpeCwgcmVzdWx0ID0ge30pIHtcbiAgY29uc3QgRUlHRU5fVE9MRVJBTkNFID0gX01hdGhVdGlscy5FUFNJTE9OMjA7XG4gIGNvbnN0IEVJR0VOX01BWF9TV0VFUFMgPSAxMDtcbiAgbGV0IGNvdW50ID0gMDtcbiAgbGV0IHN3ZWVwID0gMDtcbiAgY29uc3QgdW5pdGFyeU1hdHJpeCA9IHNjcmF0Y2hVbml0YXJ5O1xuICBjb25zdCBkaWFnb25hbE1hdHJpeCA9IHNjcmF0Y2hEaWFnb25hbDtcbiAgdW5pdGFyeU1hdHJpeC5pZGVudGl0eSgpO1xuICBkaWFnb25hbE1hdHJpeC5jb3B5KG1hdHJpeCk7XG4gIGNvbnN0IGVwc2lsb24gPSBFSUdFTl9UT0xFUkFOQ0UgKiBjb21wdXRlRnJvYmVuaXVzTm9ybShkaWFnb25hbE1hdHJpeCk7XG5cbiAgd2hpbGUgKHN3ZWVwIDwgRUlHRU5fTUFYX1NXRUVQUyAmJiBvZmZEaWFnb25hbEZyb2Jlbml1c05vcm0oZGlhZ29uYWxNYXRyaXgpID4gZXBzaWxvbikge1xuICAgIHNodXJEZWNvbXBvc2l0aW9uKGRpYWdvbmFsTWF0cml4LCBqTWF0cml4KTtcbiAgICBqTWF0cml4VHJhbnNwb3NlLmNvcHkoak1hdHJpeCkudHJhbnNwb3NlKCk7XG4gICAgZGlhZ29uYWxNYXRyaXgubXVsdGlwbHlSaWdodChqTWF0cml4KTtcbiAgICBkaWFnb25hbE1hdHJpeC5tdWx0aXBseUxlZnQoak1hdHJpeFRyYW5zcG9zZSk7XG4gICAgdW5pdGFyeU1hdHJpeC5tdWx0aXBseVJpZ2h0KGpNYXRyaXgpO1xuXG4gICAgaWYgKCsrY291bnQgPiAyKSB7XG4gICAgICArK3N3ZWVwO1xuICAgICAgY291bnQgPSAwO1xuICAgIH1cbiAgfVxuXG4gIHJlc3VsdC51bml0YXJ5ID0gdW5pdGFyeU1hdHJpeC50b1RhcmdldChyZXN1bHQudW5pdGFyeSk7XG4gIHJlc3VsdC5kaWFnb25hbCA9IGRpYWdvbmFsTWF0cml4LnRvVGFyZ2V0KHJlc3VsdC5kaWFnb25hbCk7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbmZ1bmN0aW9uIGNvbXB1dGVGcm9iZW5pdXNOb3JtKG1hdHJpeCkge1xuICBsZXQgbm9ybSA9IDAuMDtcblxuICBmb3IgKGxldCBpID0gMDsgaSA8IDk7ICsraSkge1xuICAgIGNvbnN0IHRlbXAgPSBtYXRyaXhbaV07XG4gICAgbm9ybSArPSB0ZW1wICogdGVtcDtcbiAgfVxuXG4gIHJldHVybiBNYXRoLnNxcnQobm9ybSk7XG59XG5cbmNvbnN0IHJvd1ZhbCA9IFsxLCAwLCAwXTtcbmNvbnN0IGNvbFZhbCA9IFsyLCAyLCAxXTtcblxuZnVuY3Rpb24gb2ZmRGlhZ29uYWxGcm9iZW5pdXNOb3JtKG1hdHJpeCkge1xuICBsZXQgbm9ybSA9IDAuMDtcblxuICBmb3IgKGxldCBpID0gMDsgaSA8IDM7ICsraSkge1xuICAgIGNvbnN0IHRlbXAgPSBtYXRyaXhbc2NyYXRjaE1hdHJpeC5nZXRFbGVtZW50SW5kZXgoY29sVmFsW2ldLCByb3dWYWxbaV0pXTtcbiAgICBub3JtICs9IDIuMCAqIHRlbXAgKiB0ZW1wO1xuICB9XG5cbiAgcmV0dXJuIE1hdGguc3FydChub3JtKTtcbn1cblxuZnVuY3Rpb24gc2h1ckRlY29tcG9zaXRpb24obWF0cml4LCByZXN1bHQpIHtcbiAgY29uc3QgdG9sZXJhbmNlID0gX01hdGhVdGlscy5FUFNJTE9OMTU7XG4gIGxldCBtYXhEaWFnb25hbCA9IDAuMDtcbiAgbGV0IHJvdEF4aXMgPSAxO1xuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgMzsgKytpKSB7XG4gICAgY29uc3QgdGVtcCA9IE1hdGguYWJzKG1hdHJpeFtzY3JhdGNoTWF0cml4LmdldEVsZW1lbnRJbmRleChjb2xWYWxbaV0sIHJvd1ZhbFtpXSldKTtcblxuICAgIGlmICh0ZW1wID4gbWF4RGlhZ29uYWwpIHtcbiAgICAgIHJvdEF4aXMgPSBpO1xuICAgICAgbWF4RGlhZ29uYWwgPSB0ZW1wO1xuICAgIH1cbiAgfVxuXG4gIGNvbnN0IHAgPSByb3dWYWxbcm90QXhpc107XG4gIGNvbnN0IHEgPSBjb2xWYWxbcm90QXhpc107XG4gIGxldCBjID0gMS4wO1xuICBsZXQgcyA9IDAuMDtcblxuICBpZiAoTWF0aC5hYnMobWF0cml4W3NjcmF0Y2hNYXRyaXguZ2V0RWxlbWVudEluZGV4KHEsIHApXSkgPiB0b2xlcmFuY2UpIHtcbiAgICBjb25zdCBxcSA9IG1hdHJpeFtzY3JhdGNoTWF0cml4LmdldEVsZW1lbnRJbmRleChxLCBxKV07XG4gICAgY29uc3QgcHAgPSBtYXRyaXhbc2NyYXRjaE1hdHJpeC5nZXRFbGVtZW50SW5kZXgocCwgcCldO1xuICAgIGNvbnN0IHFwID0gbWF0cml4W3NjcmF0Y2hNYXRyaXguZ2V0RWxlbWVudEluZGV4KHEsIHApXTtcbiAgICBjb25zdCB0YXUgPSAocXEgLSBwcCkgLyAyLjAgLyBxcDtcbiAgICBsZXQgdDtcblxuICAgIGlmICh0YXUgPCAwLjApIHtcbiAgICAgIHQgPSAtMS4wIC8gKC10YXUgKyBNYXRoLnNxcnQoMS4wICsgdGF1ICogdGF1KSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHQgPSAxLjAgLyAodGF1ICsgTWF0aC5zcXJ0KDEuMCArIHRhdSAqIHRhdSkpO1xuICAgIH1cblxuICAgIGMgPSAxLjAgLyBNYXRoLnNxcnQoMS4wICsgdCAqIHQpO1xuICAgIHMgPSB0ICogYztcbiAgfVxuXG4gIE1hdHJpeDMuSURFTlRJVFkudG8ocmVzdWx0KTtcbiAgcmVzdWx0W3NjcmF0Y2hNYXRyaXguZ2V0RWxlbWVudEluZGV4KHAsIHApXSA9IHJlc3VsdFtzY3JhdGNoTWF0cml4LmdldEVsZW1lbnRJbmRleChxLCBxKV0gPSBjO1xuICByZXN1bHRbc2NyYXRjaE1hdHJpeC5nZXRFbGVtZW50SW5kZXgocSwgcCldID0gcztcbiAgcmVzdWx0W3NjcmF0Y2hNYXRyaXguZ2V0RWxlbWVudEluZGV4KHAsIHEpXSA9IC1zO1xuICByZXR1cm4gcmVzdWx0O1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y29tcHV0ZS1laWdlbi1kZWNvbXBvc2l0aW9uLmpzLm1hcCIsImltcG9ydCB7IFZlY3RvcjMsIE1hdHJpeDMgfSBmcm9tICdAbWF0aC5nbC9jb3JlJztcbmltcG9ydCBjb21wdXRlRWlnZW5EZWNvbXBvc2l0aW9uIGZyb20gJy4vY29tcHV0ZS1laWdlbi1kZWNvbXBvc2l0aW9uJztcbmltcG9ydCBPcmllbnRlZEJvdW5kaW5nQm94IGZyb20gJy4uL2JvdW5kaW5nLXZvbHVtZXMvb3JpZW50ZWQtYm91bmRpbmctYm94JztcbmltcG9ydCBBeGlzQWxpZ25lZEJvdW5kaW5nQm94IGZyb20gJy4uL2JvdW5kaW5nLXZvbHVtZXMvYXhpcy1hbGlnbmVkLWJvdW5kaW5nLWJveCc7XG5jb25zdCBzY3JhdGNoVmVjdG9yMiA9IG5ldyBWZWN0b3IzKCk7XG5jb25zdCBzY3JhdGNoVmVjdG9yMyA9IG5ldyBWZWN0b3IzKCk7XG5jb25zdCBzY3JhdGNoVmVjdG9yNCA9IG5ldyBWZWN0b3IzKCk7XG5jb25zdCBzY3JhdGNoVmVjdG9yNSA9IG5ldyBWZWN0b3IzKCk7XG5jb25zdCBzY3JhdGNoVmVjdG9yNiA9IG5ldyBWZWN0b3IzKCk7XG5jb25zdCBzY3JhdGNoQ292YXJpYW5jZVJlc3VsdCA9IG5ldyBNYXRyaXgzKCk7XG5jb25zdCBzY3JhdGNoRWlnZW5SZXN1bHQgPSB7XG4gIGRpYWdvbmFsOiBuZXcgTWF0cml4MygpLFxuICB1bml0YXJ5OiBuZXcgTWF0cml4MygpXG59O1xuZXhwb3J0IGZ1bmN0aW9uIG1ha2VPcmllbnRlZEJvdW5kaW5nQm94RnJvbVBvaW50cyhwb3NpdGlvbnMsIHJlc3VsdCA9IG5ldyBPcmllbnRlZEJvdW5kaW5nQm94KCkpIHtcbiAgaWYgKCFwb3NpdGlvbnMgfHwgcG9zaXRpb25zLmxlbmd0aCA9PT0gMCkge1xuICAgIHJlc3VsdC5oYWxmQXhlcyA9IG5ldyBNYXRyaXgzKFswLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwXSk7XG4gICAgcmVzdWx0LmNlbnRlciA9IG5ldyBWZWN0b3IzKCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIGNvbnN0IGxlbmd0aCA9IHBvc2l0aW9ucy5sZW5ndGg7XG4gIGNvbnN0IG1lYW5Qb2ludCA9IG5ldyBWZWN0b3IzKDAsIDAsIDApO1xuXG4gIGZvciAoY29uc3QgcG9zaXRpb24gb2YgcG9zaXRpb25zKSB7XG4gICAgbWVhblBvaW50LmFkZChwb3NpdGlvbik7XG4gIH1cblxuICBjb25zdCBpbnZMZW5ndGggPSAxLjAgLyBsZW5ndGg7XG4gIG1lYW5Qb2ludC5tdWx0aXBseUJ5U2NhbGFyKGludkxlbmd0aCk7XG4gIGxldCBleHggPSAwLjA7XG4gIGxldCBleHkgPSAwLjA7XG4gIGxldCBleHogPSAwLjA7XG4gIGxldCBleXkgPSAwLjA7XG4gIGxldCBleXogPSAwLjA7XG4gIGxldCBlenogPSAwLjA7XG5cbiAgZm9yIChjb25zdCBwb3NpdGlvbiBvZiBwb3NpdGlvbnMpIHtcbiAgICBjb25zdCBwID0gc2NyYXRjaFZlY3RvcjIuY29weShwb3NpdGlvbikuc3VidHJhY3QobWVhblBvaW50KTtcbiAgICBleHggKz0gcC54ICogcC54O1xuICAgIGV4eSArPSBwLnggKiBwLnk7XG4gICAgZXh6ICs9IHAueCAqIHAuejtcbiAgICBleXkgKz0gcC55ICogcC55O1xuICAgIGV5eiArPSBwLnkgKiBwLno7XG4gICAgZXp6ICs9IHAueiAqIHAuejtcbiAgfVxuXG4gIGV4eCAqPSBpbnZMZW5ndGg7XG4gIGV4eSAqPSBpbnZMZW5ndGg7XG4gIGV4eiAqPSBpbnZMZW5ndGg7XG4gIGV5eSAqPSBpbnZMZW5ndGg7XG4gIGV5eiAqPSBpbnZMZW5ndGg7XG4gIGV6eiAqPSBpbnZMZW5ndGg7XG4gIGNvbnN0IGNvdmFyaWFuY2VNYXRyaXggPSBzY3JhdGNoQ292YXJpYW5jZVJlc3VsdDtcbiAgY292YXJpYW5jZU1hdHJpeFswXSA9IGV4eDtcbiAgY292YXJpYW5jZU1hdHJpeFsxXSA9IGV4eTtcbiAgY292YXJpYW5jZU1hdHJpeFsyXSA9IGV4ejtcbiAgY292YXJpYW5jZU1hdHJpeFszXSA9IGV4eTtcbiAgY292YXJpYW5jZU1hdHJpeFs0XSA9IGV5eTtcbiAgY292YXJpYW5jZU1hdHJpeFs1XSA9IGV5ejtcbiAgY292YXJpYW5jZU1hdHJpeFs2XSA9IGV4ejtcbiAgY292YXJpYW5jZU1hdHJpeFs3XSA9IGV5ejtcbiAgY292YXJpYW5jZU1hdHJpeFs4XSA9IGV6ejtcbiAgY29uc3Qge1xuICAgIHVuaXRhcnlcbiAgfSA9IGNvbXB1dGVFaWdlbkRlY29tcG9zaXRpb24oY292YXJpYW5jZU1hdHJpeCwgc2NyYXRjaEVpZ2VuUmVzdWx0KTtcbiAgY29uc3Qgcm90YXRpb24gPSByZXN1bHQuaGFsZkF4ZXMuY29weSh1bml0YXJ5KTtcbiAgbGV0IHYxID0gcm90YXRpb24uZ2V0Q29sdW1uKDAsIHNjcmF0Y2hWZWN0b3I0KTtcbiAgbGV0IHYyID0gcm90YXRpb24uZ2V0Q29sdW1uKDEsIHNjcmF0Y2hWZWN0b3I1KTtcbiAgbGV0IHYzID0gcm90YXRpb24uZ2V0Q29sdW1uKDIsIHNjcmF0Y2hWZWN0b3I2KTtcbiAgbGV0IHUxID0gLU51bWJlci5NQVhfVkFMVUU7XG4gIGxldCB1MiA9IC1OdW1iZXIuTUFYX1ZBTFVFO1xuICBsZXQgdTMgPSAtTnVtYmVyLk1BWF9WQUxVRTtcbiAgbGV0IGwxID0gTnVtYmVyLk1BWF9WQUxVRTtcbiAgbGV0IGwyID0gTnVtYmVyLk1BWF9WQUxVRTtcbiAgbGV0IGwzID0gTnVtYmVyLk1BWF9WQUxVRTtcblxuICBmb3IgKGNvbnN0IHBvc2l0aW9uIG9mIHBvc2l0aW9ucykge1xuICAgIHNjcmF0Y2hWZWN0b3IyLmNvcHkocG9zaXRpb24pO1xuICAgIHUxID0gTWF0aC5tYXgoc2NyYXRjaFZlY3RvcjIuZG90KHYxKSwgdTEpO1xuICAgIHUyID0gTWF0aC5tYXgoc2NyYXRjaFZlY3RvcjIuZG90KHYyKSwgdTIpO1xuICAgIHUzID0gTWF0aC5tYXgoc2NyYXRjaFZlY3RvcjIuZG90KHYzKSwgdTMpO1xuICAgIGwxID0gTWF0aC5taW4oc2NyYXRjaFZlY3RvcjIuZG90KHYxKSwgbDEpO1xuICAgIGwyID0gTWF0aC5taW4oc2NyYXRjaFZlY3RvcjIuZG90KHYyKSwgbDIpO1xuICAgIGwzID0gTWF0aC5taW4oc2NyYXRjaFZlY3RvcjIuZG90KHYzKSwgbDMpO1xuICB9XG5cbiAgdjEgPSB2MS5tdWx0aXBseUJ5U2NhbGFyKDAuNSAqIChsMSArIHUxKSk7XG4gIHYyID0gdjIubXVsdGlwbHlCeVNjYWxhcigwLjUgKiAobDIgKyB1MikpO1xuICB2MyA9IHYzLm11bHRpcGx5QnlTY2FsYXIoMC41ICogKGwzICsgdTMpKTtcbiAgcmVzdWx0LmNlbnRlci5jb3B5KHYxKS5hZGQodjIpLmFkZCh2Myk7XG4gIGNvbnN0IHNjYWxlID0gc2NyYXRjaFZlY3RvcjMuc2V0KHUxIC0gbDEsIHUyIC0gbDIsIHUzIC0gbDMpLm11bHRpcGx5QnlTY2FsYXIoMC41KTtcbiAgY29uc3Qgc2NhbGVNYXRyaXggPSBuZXcgTWF0cml4Myhbc2NhbGVbMF0sIDAsIDAsIDAsIHNjYWxlWzFdLCAwLCAwLCAwLCBzY2FsZVsyXV0pO1xuICByZXN1bHQuaGFsZkF4ZXMubXVsdGlwbHlSaWdodChzY2FsZU1hdHJpeCk7XG4gIHJldHVybiByZXN1bHQ7XG59XG5leHBvcnQgZnVuY3Rpb24gbWFrZUF4aXNBbGlnbmVkQm91bmRpbmdCb3hGcm9tUG9pbnRzKHBvc2l0aW9ucywgcmVzdWx0ID0gbmV3IEF4aXNBbGlnbmVkQm91bmRpbmdCb3goKSkge1xuICBpZiAoIXBvc2l0aW9ucyB8fCBwb3NpdGlvbnMubGVuZ3RoID09PSAwKSB7XG4gICAgcmVzdWx0Lm1pbmltdW0uc2V0KDAsIDAsIDApO1xuICAgIHJlc3VsdC5tYXhpbXVtLnNldCgwLCAwLCAwKTtcbiAgICByZXN1bHQuY2VudGVyLnNldCgwLCAwLCAwKTtcbiAgICByZXN1bHQuaGFsZkRpYWdvbmFsLnNldCgwLCAwLCAwKTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgbGV0IG1pbmltdW1YID0gcG9zaXRpb25zWzBdWzBdO1xuICBsZXQgbWluaW11bVkgPSBwb3NpdGlvbnNbMF1bMV07XG4gIGxldCBtaW5pbXVtWiA9IHBvc2l0aW9uc1swXVsyXTtcbiAgbGV0IG1heGltdW1YID0gcG9zaXRpb25zWzBdWzBdO1xuICBsZXQgbWF4aW11bVkgPSBwb3NpdGlvbnNbMF1bMV07XG4gIGxldCBtYXhpbXVtWiA9IHBvc2l0aW9uc1swXVsyXTtcblxuICBmb3IgKGNvbnN0IHAgb2YgcG9zaXRpb25zKSB7XG4gICAgY29uc3QgeCA9IHBbMF07XG4gICAgY29uc3QgeSA9IHBbMV07XG4gICAgY29uc3QgeiA9IHBbMl07XG4gICAgbWluaW11bVggPSBNYXRoLm1pbih4LCBtaW5pbXVtWCk7XG4gICAgbWF4aW11bVggPSBNYXRoLm1heCh4LCBtYXhpbXVtWCk7XG4gICAgbWluaW11bVkgPSBNYXRoLm1pbih5LCBtaW5pbXVtWSk7XG4gICAgbWF4aW11bVkgPSBNYXRoLm1heCh5LCBtYXhpbXVtWSk7XG4gICAgbWluaW11bVogPSBNYXRoLm1pbih6LCBtaW5pbXVtWik7XG4gICAgbWF4aW11bVogPSBNYXRoLm1heCh6LCBtYXhpbXVtWik7XG4gIH1cblxuICByZXN1bHQubWluaW11bS5zZXQobWluaW11bVgsIG1pbmltdW1ZLCBtaW5pbXVtWik7XG4gIHJlc3VsdC5tYXhpbXVtLnNldChtYXhpbXVtWCwgbWF4aW11bVksIG1heGltdW1aKTtcbiAgcmVzdWx0LmNlbnRlci5jb3B5KHJlc3VsdC5taW5pbXVtKS5hZGQocmVzdWx0Lm1heGltdW0pLnNjYWxlKDAuNSk7XG4gIHJlc3VsdC5oYWxmRGlhZ29uYWwuY29weShyZXN1bHQubWF4aW11bSkuc3VidHJhY3QocmVzdWx0LmNlbnRlcik7XG4gIHJldHVybiByZXN1bHQ7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1ib3VuZGluZy1ib3gtZnJvbS1wb2ludHMuanMubWFwIiwiZXhwb3J0IHsgSU5URVJTRUNUSU9OIH0gZnJvbSAnLi9jb25zdGFudHMnO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBBeGlzQWxpZ25lZEJvdW5kaW5nQm94IH0gZnJvbSAnLi9saWIvYm91bmRpbmctdm9sdW1lcy9heGlzLWFsaWduZWQtYm91bmRpbmctYm94JztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgQm91bmRpbmdTcGhlcmUgfSBmcm9tICcuL2xpYi9ib3VuZGluZy12b2x1bWVzL2JvdW5kaW5nLXNwaGVyZSc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIE9yaWVudGVkQm91bmRpbmdCb3ggfSBmcm9tICcuL2xpYi9ib3VuZGluZy12b2x1bWVzL29yaWVudGVkLWJvdW5kaW5nLWJveCc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIEN1bGxpbmdWb2x1bWUgfSBmcm9tICcuL2xpYi9jdWxsaW5nLXZvbHVtZSc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIFBsYW5lIH0gZnJvbSAnLi9saWIvcGxhbmUnO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBfUGVyc3BlY3RpdmVPZmZDZW50ZXJGcnVzdHVtIH0gZnJvbSAnLi9saWIvcGVyc3BlY3RpdmUtb2ZmLWNlbnRlci1mcnVzdHVtJztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgX1BlcnNwZWN0aXZlRnJ1c3R1bSB9IGZyb20gJy4vbGliL3BlcnNwZWN0aXZlLWZydXN0dW0nO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBtYWtlQm91bmRpbmdTcGhlcmVGcm9tUG9pbnRzIH0gZnJvbSAnLi9saWIvYWxnb3JpdGhtcy9ib3VuZGluZy1zcGhlcmUtZnJvbS1wb2ludHMnO1xuZXhwb3J0IHsgbWFrZUF4aXNBbGlnbmVkQm91bmRpbmdCb3hGcm9tUG9pbnRzLCBtYWtlT3JpZW50ZWRCb3VuZGluZ0JveEZyb21Qb2ludHMgfSBmcm9tICcuL2xpYi9hbGdvcml0aG1zL2JvdW5kaW5nLWJveC1mcm9tLXBvaW50cyc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIGNvbXB1dGVFaWdlbkRlY29tcG9zaXRpb24gfSBmcm9tICcuL2xpYi9hbGdvcml0aG1zL2NvbXB1dGUtZWlnZW4tZGVjb21wb3NpdGlvbic7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///36772\n')},89513:function(__unused_webpack_module,__webpack_exports__,__webpack_require__){eval('\n// EXPORTS\n__webpack_require__.d(__webpack_exports__, {\n  "wG": function() { return /* reexport */ WINDING; },\n  "WZ": function() { return /* reexport */ cutPolygonByGrid; },\n  "GU": function() { return /* reexport */ cutPolygonByMercatorBounds; },\n  "dj": function() { return /* reexport */ cutPolylineByGrid; },\n  "ct": function() { return /* reexport */ cutPolylineByMercatorBounds; },\n  "Ny": function() { return /* reexport */ polygon_utils_modifyPolygonWindingDirection; }\n});\n\n// UNUSED EXPORTS: Polygon, _Polygon, clipPolygon, clipPolyline, earcut, forEachSegmentInPolygon, getPolygonSignedArea, getPolygonWindingDirection\n\n// EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/esm/defineProperty.js\nvar defineProperty = __webpack_require__(82482);\n;// CONCATENATED MODULE: ./node_modules/@math.gl/polygon/dist/esm/polygon-utils.js\n\nconst WINDING = {\n  CLOCKWISE: 1,\n  COUNTER_CLOCKWISE: -1\n};\nfunction polygon_utils_modifyPolygonWindingDirection(points, direction, options = {}) {\n  const windingDirection = getPolygonWindingDirection(points, options);\n\n  if (windingDirection !== direction) {\n    reversePolygon(points, options);\n    return true;\n  }\n\n  return false;\n}\nfunction getPolygonWindingDirection(points, options = {}) {\n  return Math.sign(polygon_utils_getPolygonSignedArea(points, options));\n}\nfunction polygon_utils_getPolygonSignedArea(points, options = {}) {\n  const {\n    start = 0,\n    end = points.length\n  } = options;\n  const dim = options.size || 2;\n  let area = 0;\n\n  for (let i = start, j = end - dim; i < end; i += dim) {\n    area += (points[i] - points[j]) * (points[i + 1] + points[j + 1]);\n    j = i;\n  }\n\n  return area / 2;\n}\nfunction polygon_utils_forEachSegmentInPolygon(points, visitor, options = {}) {\n  const {\n    start = 0,\n    end = points.length,\n    size = 2,\n    isClosed\n  } = options;\n  const numPoints = (end - start) / size;\n\n  for (let i = 0; i < numPoints - 1; ++i) {\n    visitor(points[start + i * size], points[start + i * size + 1], points[start + (i + 1) * size], points[start + (i + 1) * size + 1], i, i + 1);\n  }\n\n  const endPointIndex = start + (numPoints - 1) * size;\n  const isClosedEx = isClosed || equals(points[start], points[endPointIndex]) && equals(points[start + 1], points[endPointIndex + 1]);\n\n  if (!isClosedEx) {\n    visitor(points[endPointIndex], points[endPointIndex + 1], points[start], points[start + 1], numPoints - 1, 0);\n  }\n}\n\nfunction reversePolygon(points, options) {\n  const {\n    start = 0,\n    end = points.length,\n    size = 2\n  } = options;\n  const numPoints = (end - start) / size;\n  const numSwaps = Math.floor(numPoints / 2);\n\n  for (let i = 0; i < numSwaps; ++i) {\n    const b1 = start + i * size;\n    const b2 = start + (numPoints - 1 - i) * size;\n\n    for (let j = 0; j < size; ++j) {\n      const tmp = points[b1 + j];\n      points[b1 + j] = points[b2 + j];\n      points[b2 + j] = tmp;\n    }\n  }\n}\n\nfunction polygon_utils_modifyPolygonWindingDirectionPoints(points, direction, options = {}) {\n  const currentDirection = getPolygonWindingDirectionPoints(points, options);\n\n  if (currentDirection !== direction) {\n    points.reverse();\n    return true;\n  }\n\n  return false;\n}\nfunction getPolygonWindingDirectionPoints(points, options = {}) {\n  return Math.sign(polygon_utils_getPolygonSignedAreaPoints(points, options));\n}\nfunction polygon_utils_getPolygonSignedAreaPoints(points, options = {}) {\n  const {\n    start = 0,\n    end = points.length\n  } = options;\n  let area = 0;\n\n  for (let i = start, j = end - 1; i < end; ++i) {\n    area += (points[i][0] - points[j][0]) * (points[i][1] + points[j][1]);\n    j = i;\n  }\n\n  return area / 2;\n}\nfunction polygon_utils_forEachSegmentInPolygonPoints(points, visitor, options = {}) {\n  const {\n    start = 0,\n    end = points.length,\n    isClosed\n  } = options;\n\n  for (let i = start; i < end - 1; ++i) {\n    visitor(points[i], points[i + 1], i, i + 1);\n  }\n\n  const isClosedEx = isClosed || equals(points[end - 1], points[0]);\n\n  if (!isClosedEx) {\n    visitor(points[end - 1], points[0], end - 1, 0);\n  }\n}\n//# sourceMappingURL=polygon-utils.js.map\n;// CONCATENATED MODULE: ./node_modules/@math.gl/polygon/dist/esm/polygon.js\n\n\n\nclass Polygon {\n  constructor(points, options = {}) {\n    _defineProperty(this, "points", void 0);\n\n    _defineProperty(this, "isFlatArray", void 0);\n\n    _defineProperty(this, "options", void 0);\n\n    this.points = points;\n    this.isFlatArray = !isArray(points[0]);\n    this.options = {\n      start: options.start || 0,\n      end: options.end || points.length,\n      size: options.size || 2,\n      isClosed: options.isClosed\n    };\n    Object.freeze(this);\n  }\n\n  getSignedArea() {\n    if (this.isFlatArray) return getPolygonSignedArea(this.points, this.options);\n    return getPolygonSignedAreaPoints(this.points, this.options);\n  }\n\n  getArea() {\n    return Math.abs(this.getSignedArea());\n  }\n\n  getWindingDirection() {\n    return Math.sign(this.getSignedArea());\n  }\n\n  forEachSegment(visitor) {\n    if (this.isFlatArray) {\n      forEachSegmentInPolygon(this.points, (x1, y1, x2, y2, i1, i2) => {\n        visitor([x1, y1], [x2, y2], i1, i2);\n      }, this.options);\n    } else {\n      forEachSegmentInPolygonPoints(this.points, visitor, this.options);\n    }\n  }\n\n  modifyWindingDirection(direction) {\n    if (this.isFlatArray) {\n      return modifyPolygonWindingDirection(this.points, direction, this.options);\n    }\n\n    return modifyPolygonWindingDirectionPoints(this.points, direction, this.options);\n  }\n\n}\n//# sourceMappingURL=polygon.js.map\n;// CONCATENATED MODULE: ./node_modules/@math.gl/polygon/dist/esm/earcut.js\n\nfunction earcut(positions, holeIndices, dim = 2, areas) {\n  const hasHoles = holeIndices && holeIndices.length;\n  const outerLen = hasHoles ? holeIndices[0] * dim : positions.length;\n  let outerNode = linkedList(positions, 0, outerLen, dim, true, areas && areas[0]);\n  const triangles = [];\n  if (!outerNode || outerNode.next === outerNode.prev) return triangles;\n  let invSize;\n  let maxX;\n  let maxY;\n  let minX;\n  let minY;\n  let x;\n  let y;\n  if (hasHoles) outerNode = eliminateHoles(positions, holeIndices, outerNode, dim, areas);\n\n  if (positions.length > 80 * dim) {\n    minX = maxX = positions[0];\n    minY = maxY = positions[1];\n\n    for (let i = dim; i < outerLen; i += dim) {\n      x = positions[i];\n      y = positions[i + 1];\n      if (x < minX) minX = x;\n      if (y < minY) minY = y;\n      if (x > maxX) maxX = x;\n      if (y > maxY) maxY = y;\n    }\n\n    invSize = Math.max(maxX - minX, maxY - minY);\n    invSize = invSize !== 0 ? 1 / invSize : 0;\n  }\n\n  earcutLinked(outerNode, triangles, dim, minX, minY, invSize);\n  return triangles;\n}\n\nfunction linkedList(data, start, end, dim, clockwise, area) {\n  let i;\n  let last;\n\n  if (area === undefined) {\n    area = getPolygonSignedArea(data, {\n      start,\n      end,\n      size: dim\n    });\n  }\n\n  if (clockwise === area < 0) {\n    for (i = start; i < end; i += dim) last = insertNode(i, data[i], data[i + 1], last);\n  } else {\n    for (i = end - dim; i >= start; i -= dim) last = insertNode(i, data[i], data[i + 1], last);\n  }\n\n  if (last && earcut_equals(last, last.next)) {\n    removeNode(last);\n    last = last.next;\n  }\n\n  return last;\n}\n\nfunction filterPoints(start, end) {\n  if (!start) return start;\n  if (!end) end = start;\n  let p = start;\n  let again;\n\n  do {\n    again = false;\n\n    if (!p.steiner && (earcut_equals(p, p.next) || earcut_area(p.prev, p, p.next) === 0)) {\n      removeNode(p);\n      p = end = p.prev;\n      if (p === p.next) break;\n      again = true;\n    } else {\n      p = p.next;\n    }\n  } while (again || p !== end);\n\n  return end;\n}\n\nfunction earcutLinked(ear, triangles, dim, minX, minY, invSize, pass) {\n  if (!ear) return;\n  if (!pass && invSize) indexCurve(ear, minX, minY, invSize);\n  let stop = ear;\n  let prev;\n  let next;\n\n  while (ear.prev !== ear.next) {\n    prev = ear.prev;\n    next = ear.next;\n\n    if (invSize ? isEarHashed(ear, minX, minY, invSize) : isEar(ear)) {\n      triangles.push(prev.i / dim);\n      triangles.push(ear.i / dim);\n      triangles.push(next.i / dim);\n      removeNode(ear);\n      ear = next.next;\n      stop = next.next;\n      continue;\n    }\n\n    ear = next;\n\n    if (ear === stop) {\n      if (!pass) {\n        earcutLinked(filterPoints(ear), triangles, dim, minX, minY, invSize, 1);\n      } else if (pass === 1) {\n        ear = cureLocalIntersections(filterPoints(ear), triangles, dim);\n        earcutLinked(ear, triangles, dim, minX, minY, invSize, 2);\n      } else if (pass === 2) {\n        splitEarcut(ear, triangles, dim, minX, minY, invSize);\n      }\n\n      break;\n    }\n  }\n}\n\nfunction isEar(ear) {\n  const a = ear.prev;\n  const b = ear;\n  const c = ear.next;\n  if (earcut_area(a, b, c) >= 0) return false;\n  let p = ear.next.next;\n\n  while (p !== ear.prev) {\n    if (pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) && earcut_area(p.prev, p, p.next) >= 0) return false;\n    p = p.next;\n  }\n\n  return true;\n}\n\nfunction isEarHashed(ear, minX, minY, invSize) {\n  const a = ear.prev;\n  const b = ear;\n  const c = ear.next;\n  if (earcut_area(a, b, c) >= 0) return false;\n  const minTX = a.x < b.x ? a.x < c.x ? a.x : c.x : b.x < c.x ? b.x : c.x;\n  const minTY = a.y < b.y ? a.y < c.y ? a.y : c.y : b.y < c.y ? b.y : c.y;\n  const maxTX = a.x > b.x ? a.x > c.x ? a.x : c.x : b.x > c.x ? b.x : c.x;\n  const maxTY = a.y > b.y ? a.y > c.y ? a.y : c.y : b.y > c.y ? b.y : c.y;\n  const minZ = zOrder(minTX, minTY, minX, minY, invSize);\n  const maxZ = zOrder(maxTX, maxTY, minX, minY, invSize);\n  let p = ear.prevZ;\n  let n = ear.nextZ;\n\n  while (p && p.z >= minZ && n && n.z <= maxZ) {\n    if (p !== ear.prev && p !== ear.next && pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) && earcut_area(p.prev, p, p.next) >= 0) return false;\n    p = p.prevZ;\n    if (n !== ear.prev && n !== ear.next && pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, n.x, n.y) && earcut_area(n.prev, n, n.next) >= 0) return false;\n    n = n.nextZ;\n  }\n\n  while (p && p.z >= minZ) {\n    if (p !== ear.prev && p !== ear.next && pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) && earcut_area(p.prev, p, p.next) >= 0) return false;\n    p = p.prevZ;\n  }\n\n  while (n && n.z <= maxZ) {\n    if (n !== ear.prev && n !== ear.next && pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, n.x, n.y) && earcut_area(n.prev, n, n.next) >= 0) return false;\n    n = n.nextZ;\n  }\n\n  return true;\n}\n\nfunction cureLocalIntersections(start, triangles, dim) {\n  let p = start;\n\n  do {\n    const a = p.prev;\n    const b = p.next.next;\n\n    if (!earcut_equals(a, b) && intersects(a, p, p.next, b) && locallyInside(a, b) && locallyInside(b, a)) {\n      triangles.push(a.i / dim);\n      triangles.push(p.i / dim);\n      triangles.push(b.i / dim);\n      removeNode(p);\n      removeNode(p.next);\n      p = start = b;\n    }\n\n    p = p.next;\n  } while (p !== start);\n\n  return filterPoints(p);\n}\n\nfunction splitEarcut(start, triangles, dim, minX, minY, invSize) {\n  let a = start;\n\n  do {\n    let b = a.next.next;\n\n    while (b !== a.prev) {\n      if (a.i !== b.i && isValidDiagonal(a, b)) {\n        let c = splitPolygon(a, b);\n        a = filterPoints(a, a.next);\n        c = filterPoints(c, c.next);\n        earcutLinked(a, triangles, dim, minX, minY, invSize);\n        earcutLinked(c, triangles, dim, minX, minY, invSize);\n        return;\n      }\n\n      b = b.next;\n    }\n\n    a = a.next;\n  } while (a !== start);\n}\n\nfunction eliminateHoles(data, holeIndices, outerNode, dim, areas) {\n  const queue = [];\n  let i;\n  let len;\n  let start;\n  let end;\n  let list;\n\n  for (i = 0, len = holeIndices.length; i < len; i++) {\n    start = holeIndices[i] * dim;\n    end = i < len - 1 ? holeIndices[i + 1] * dim : data.length;\n    list = linkedList(data, start, end, dim, false, areas && areas[i + 1]);\n    if (list === list.next) list.steiner = true;\n    queue.push(getLeftmost(list));\n  }\n\n  queue.sort(compareX);\n\n  for (i = 0; i < queue.length; i++) {\n    eliminateHole(queue[i], outerNode);\n    outerNode = filterPoints(outerNode, outerNode.next);\n  }\n\n  return outerNode;\n}\n\nfunction compareX(a, b) {\n  return a.x - b.x;\n}\n\nfunction eliminateHole(hole, outerNode) {\n  outerNode = findHoleBridge(hole, outerNode);\n\n  if (outerNode) {\n    const b = splitPolygon(outerNode, hole);\n    filterPoints(outerNode, outerNode.next);\n    filterPoints(b, b.next);\n  }\n}\n\nfunction findHoleBridge(hole, outerNode) {\n  let p = outerNode;\n  const hx = hole.x;\n  const hy = hole.y;\n  let qx = -Infinity;\n  let m;\n\n  do {\n    if (hy <= p.y && hy >= p.next.y && p.next.y !== p.y) {\n      const x = p.x + (hy - p.y) * (p.next.x - p.x) / (p.next.y - p.y);\n\n      if (x <= hx && x > qx) {\n        qx = x;\n\n        if (x === hx) {\n          if (hy === p.y) return p;\n          if (hy === p.next.y) return p.next;\n        }\n\n        m = p.x < p.next.x ? p : p.next;\n      }\n    }\n\n    p = p.next;\n  } while (p !== outerNode);\n\n  if (!m) return null;\n  if (hx === qx) return m;\n  const stop = m;\n  const mx = m.x;\n  const my = m.y;\n  let tanMin = Infinity;\n  let tan;\n  p = m;\n\n  do {\n    if (hx >= p.x && p.x >= mx && hx !== p.x && pointInTriangle(hy < my ? hx : qx, hy, mx, my, hy < my ? qx : hx, hy, p.x, p.y)) {\n      tan = Math.abs(hy - p.y) / (hx - p.x);\n\n      if (locallyInside(p, hole) && (tan < tanMin || tan === tanMin && (p.x > m.x || p.x === m.x && sectorContainsSector(m, p)))) {\n        m = p;\n        tanMin = tan;\n      }\n    }\n\n    p = p.next;\n  } while (p !== stop);\n\n  return m;\n}\n\nfunction sectorContainsSector(m, p) {\n  return earcut_area(m.prev, m, p.prev) < 0 && earcut_area(p.next, m, m.next) < 0;\n}\n\nfunction indexCurve(start, minX, minY, invSize) {\n  let p = start;\n\n  do {\n    if (p.z === null) p.z = zOrder(p.x, p.y, minX, minY, invSize);\n    p.prevZ = p.prev;\n    p.nextZ = p.next;\n    p = p.next;\n  } while (p !== start);\n\n  p.prevZ.nextZ = null;\n  p.prevZ = null;\n  sortLinked(p);\n}\n\nfunction sortLinked(list) {\n  let e;\n  let i;\n  let inSize = 1;\n  let numMerges;\n  let p;\n  let pSize;\n  let q;\n  let qSize;\n  let tail;\n\n  do {\n    p = list;\n    list = null;\n    tail = null;\n    numMerges = 0;\n\n    while (p) {\n      numMerges++;\n      q = p;\n      pSize = 0;\n\n      for (i = 0; i < inSize; i++) {\n        pSize++;\n        q = q.nextZ;\n        if (!q) break;\n      }\n\n      qSize = inSize;\n\n      while (pSize > 0 || qSize > 0 && q) {\n        if (pSize !== 0 && (qSize === 0 || !q || p.z <= q.z)) {\n          e = p;\n          p = p.nextZ;\n          pSize--;\n        } else {\n          e = q;\n          q = q.nextZ;\n          qSize--;\n        }\n\n        if (tail) tail.nextZ = e;else list = e;\n        e.prevZ = tail;\n        tail = e;\n      }\n\n      p = q;\n    }\n\n    tail.nextZ = null;\n    inSize *= 2;\n  } while (numMerges > 1);\n\n  return list;\n}\n\nfunction zOrder(x, y, minX, minY, invSize) {\n  x = 32767 * (x - minX) * invSize;\n  y = 32767 * (y - minY) * invSize;\n  x = (x | x << 8) & 0x00ff00ff;\n  x = (x | x << 4) & 0x0f0f0f0f;\n  x = (x | x << 2) & 0x33333333;\n  x = (x | x << 1) & 0x55555555;\n  y = (y | y << 8) & 0x00ff00ff;\n  y = (y | y << 4) & 0x0f0f0f0f;\n  y = (y | y << 2) & 0x33333333;\n  y = (y | y << 1) & 0x55555555;\n  return x | y << 1;\n}\n\nfunction getLeftmost(start) {\n  let p = start;\n  let leftmost = start;\n\n  do {\n    if (p.x < leftmost.x || p.x === leftmost.x && p.y < leftmost.y) leftmost = p;\n    p = p.next;\n  } while (p !== start);\n\n  return leftmost;\n}\n\nfunction pointInTriangle(ax, ay, bx, by, cx, cy, px, py) {\n  return (cx - px) * (ay - py) - (ax - px) * (cy - py) >= 0 && (ax - px) * (by - py) - (bx - px) * (ay - py) >= 0 && (bx - px) * (cy - py) - (cx - px) * (by - py) >= 0;\n}\n\nfunction isValidDiagonal(a, b) {\n  return a.next.i !== b.i && a.prev.i !== b.i && !intersectsPolygon(a, b) && (locallyInside(a, b) && locallyInside(b, a) && middleInside(a, b) && (earcut_area(a.prev, a, b.prev) || earcut_area(a, b.prev, b)) || earcut_equals(a, b) && earcut_area(a.prev, a, a.next) > 0 && earcut_area(b.prev, b, b.next) > 0);\n}\n\nfunction earcut_area(p, q, r) {\n  return (q.y - p.y) * (r.x - q.x) - (q.x - p.x) * (r.y - q.y);\n}\n\nfunction earcut_equals(p1, p2) {\n  return p1.x === p2.x && p1.y === p2.y;\n}\n\nfunction intersects(p1, q1, p2, q2) {\n  const o1 = sign(earcut_area(p1, q1, p2));\n  const o2 = sign(earcut_area(p1, q1, q2));\n  const o3 = sign(earcut_area(p2, q2, p1));\n  const o4 = sign(earcut_area(p2, q2, q1));\n  if (o1 !== o2 && o3 !== o4) return true;\n  if (o1 === 0 && onSegment(p1, p2, q1)) return true;\n  if (o2 === 0 && onSegment(p1, q2, q1)) return true;\n  if (o3 === 0 && onSegment(p2, p1, q2)) return true;\n  if (o4 === 0 && onSegment(p2, q1, q2)) return true;\n  return false;\n}\n\nfunction onSegment(p, q, r) {\n  return q.x <= Math.max(p.x, r.x) && q.x >= Math.min(p.x, r.x) && q.y <= Math.max(p.y, r.y) && q.y >= Math.min(p.y, r.y);\n}\n\nfunction sign(num) {\n  return num > 0 ? 1 : num < 0 ? -1 : 0;\n}\n\nfunction intersectsPolygon(a, b) {\n  let p = a;\n\n  do {\n    if (p.i !== a.i && p.next.i !== a.i && p.i !== b.i && p.next.i !== b.i && intersects(p, p.next, a, b)) return true;\n    p = p.next;\n  } while (p !== a);\n\n  return false;\n}\n\nfunction locallyInside(a, b) {\n  return earcut_area(a.prev, a, a.next) < 0 ? earcut_area(a, b, a.next) >= 0 && earcut_area(a, a.prev, b) >= 0 : earcut_area(a, b, a.prev) < 0 || earcut_area(a, a.next, b) < 0;\n}\n\nfunction middleInside(a, b) {\n  let p = a;\n  let inside = false;\n  const px = (a.x + b.x) / 2;\n  const py = (a.y + b.y) / 2;\n\n  do {\n    if (p.y > py !== p.next.y > py && p.next.y !== p.y && px < (p.next.x - p.x) * (py - p.y) / (p.next.y - p.y) + p.x) inside = !inside;\n    p = p.next;\n  } while (p !== a);\n\n  return inside;\n}\n\nfunction splitPolygon(a, b) {\n  const a2 = new Node(a.i, a.x, a.y);\n  const b2 = new Node(b.i, b.x, b.y);\n  const an = a.next;\n  const bp = b.prev;\n  a.next = b;\n  b.prev = a;\n  a2.next = an;\n  an.prev = a2;\n  b2.next = a2;\n  a2.prev = b2;\n  bp.next = b2;\n  b2.prev = bp;\n  return b2;\n}\n\nfunction insertNode(i, x, y, last) {\n  const p = new Node(i, x, y);\n\n  if (!last) {\n    p.prev = p;\n    p.next = p;\n  } else {\n    p.next = last.next;\n    p.prev = last;\n    last.next.prev = p;\n    last.next = p;\n  }\n\n  return p;\n}\n\nfunction removeNode(p) {\n  p.next.prev = p.prev;\n  p.prev.next = p.next;\n  if (p.prevZ) p.prevZ.nextZ = p.nextZ;\n  if (p.nextZ) p.nextZ.prevZ = p.prevZ;\n}\n\nfunction Node(i, x, y) {\n  this.i = i;\n  this.x = x;\n  this.y = y;\n  this.prev = null;\n  this.next = null;\n  this.z = null;\n  this.prevZ = null;\n  this.nextZ = null;\n  this.steiner = false;\n}\n//# sourceMappingURL=earcut.js.map\n;// CONCATENATED MODULE: ./node_modules/@math.gl/polygon/dist/esm/lineclip.js\n\nfunction clipPolyline(positions, bbox, options) {\n  const {\n    size = 2,\n    startIndex = 0,\n    endIndex = positions.length\n  } = options || {};\n  const numPoints = (endIndex - startIndex) / size;\n  const result = [];\n  let part = [];\n  let a;\n  let b;\n  let codeA = -1;\n  let codeB;\n  let lastCode;\n\n  for (let i = 1; i < numPoints; i++) {\n    a = getPointAtIndex(positions, i - 1, size, startIndex, a);\n    b = getPointAtIndex(positions, i, size, startIndex, b);\n\n    if (codeA < 0) {\n      codeA = bitCode(a, bbox);\n    }\n\n    codeB = lastCode = bitCode(b, bbox);\n\n    while (true) {\n      if (!(codeA | codeB)) {\n        push(part, a);\n\n        if (codeB !== lastCode) {\n          push(part, b);\n\n          if (i < numPoints - 1) {\n            result.push(part);\n            part = [];\n          }\n        } else if (i === numPoints - 1) {\n          push(part, b);\n        }\n\n        break;\n      } else if (codeA & codeB) {\n        break;\n      } else if (codeA) {\n        intersect(a, b, codeA, bbox, a);\n        codeA = bitCode(a, bbox);\n      } else {\n        intersect(a, b, codeB, bbox, b);\n        codeB = bitCode(b, bbox);\n      }\n    }\n\n    codeA = lastCode;\n  }\n\n  if (part.length) result.push(part);\n  return result;\n}\nfunction clipPolygon(positions, bbox, options) {\n  const {\n    size = 2,\n    endIndex = positions.length\n  } = options || {};\n  let {\n    startIndex = 0\n  } = options || {};\n  let numPoints = (endIndex - startIndex) / size;\n  let result;\n  let p;\n  let prev;\n  let inside;\n  let prevInside;\n\n  for (let edge = 1; edge <= 8; edge *= 2) {\n    result = [];\n    prev = getPointAtIndex(positions, numPoints - 1, size, startIndex, prev);\n    prevInside = !(bitCode(prev, bbox) & edge);\n\n    for (let i = 0; i < numPoints; i++) {\n      p = getPointAtIndex(positions, i, size, startIndex, p);\n      inside = !(bitCode(p, bbox) & edge);\n      if (inside !== prevInside) push(result, intersect(prev, p, edge, bbox));\n      if (inside) push(result, p);\n      copy(prev, p);\n      prevInside = inside;\n    }\n\n    positions = result;\n    startIndex = 0;\n    numPoints = result.length / size;\n    if (!numPoints) break;\n  }\n\n  return result;\n}\nfunction intersect(a, b, edge, bbox, out = []) {\n  let t;\n  let snap;\n\n  if (edge & 8) {\n    t = (bbox[3] - a[1]) / (b[1] - a[1]);\n    snap = 3;\n  } else if (edge & 4) {\n    t = (bbox[1] - a[1]) / (b[1] - a[1]);\n    snap = 1;\n  } else if (edge & 2) {\n    t = (bbox[2] - a[0]) / (b[0] - a[0]);\n    snap = 2;\n  } else if (edge & 1) {\n    t = (bbox[0] - a[0]) / (b[0] - a[0]);\n    snap = 0;\n  } else {\n    return null;\n  }\n\n  for (let i = 0; i < a.length; i++) {\n    out[i] = (snap & 1) === i ? bbox[snap] : t * (b[i] - a[i]) + a[i];\n  }\n\n  return out;\n}\nfunction bitCode(p, bbox) {\n  let code = 0;\n  if (p[0] < bbox[0]) code |= 1;else if (p[0] > bbox[2]) code |= 2;\n  if (p[1] < bbox[1]) code |= 4;else if (p[1] > bbox[3]) code |= 8;\n  return code;\n}\n//# sourceMappingURL=lineclip.js.map\n;// CONCATENATED MODULE: ./node_modules/@math.gl/polygon/dist/esm/utils.js\nfunction utils_push(target, source) {\n  const size = source.length;\n  const startIndex = target.length;\n\n  if (startIndex > 0) {\n    let isDuplicate = true;\n\n    for (let i = 0; i < size; i++) {\n      if (target[startIndex - size + i] !== source[i]) {\n        isDuplicate = false;\n        break;\n      }\n    }\n\n    if (isDuplicate) {\n      return false;\n    }\n  }\n\n  for (let i = 0; i < size; i++) {\n    target[startIndex + i] = source[i];\n  }\n\n  return true;\n}\nfunction utils_copy(target, source) {\n  const size = source.length;\n\n  for (let i = 0; i < size; i++) {\n    target[i] = source[i];\n  }\n}\nfunction utils_getPointAtIndex(positions, index, size, offset, out = []) {\n  const startI = offset + index * size;\n\n  for (let i = 0; i < size; i++) {\n    out[i] = positions[startI + i];\n  }\n\n  return out;\n}\n//# sourceMappingURL=utils.js.map\n;// CONCATENATED MODULE: ./node_modules/@math.gl/polygon/dist/esm/cut-by-grid.js\n\n\nfunction cutPolylineByGrid(positions, options) {\n  const {\n    size = 2,\n    broken = false,\n    gridResolution = 10,\n    gridOffset = [0, 0],\n    startIndex = 0,\n    endIndex = positions.length\n  } = options || {};\n  const numPoints = (endIndex - startIndex) / size;\n  let part = [];\n  const result = [part];\n  const a = utils_getPointAtIndex(positions, 0, size, startIndex);\n  let b;\n  let codeB;\n  const cell = getGridCell(a, gridResolution, gridOffset, []);\n  const scratchPoint = [];\n  utils_push(part, a);\n\n  for (let i = 1; i < numPoints; i++) {\n    b = utils_getPointAtIndex(positions, i, size, startIndex, b);\n    codeB = bitCode(b, cell);\n\n    while (codeB) {\n      intersect(a, b, codeB, cell, scratchPoint);\n      const codeAlt = bitCode(scratchPoint, cell);\n\n      if (codeAlt) {\n        intersect(a, scratchPoint, codeAlt, cell, scratchPoint);\n        codeB = codeAlt;\n      }\n\n      utils_push(part, scratchPoint);\n      utils_copy(a, scratchPoint);\n      moveToNeighborCell(cell, gridResolution, codeB);\n\n      if (broken && part.length > size) {\n        part = [];\n        result.push(part);\n        utils_push(part, a);\n      }\n\n      codeB = bitCode(b, cell);\n    }\n\n    utils_push(part, b);\n    utils_copy(a, b);\n  }\n\n  return broken ? result : result[0];\n}\nconst TYPE_INSIDE = 0;\nconst TYPE_BORDER = 1;\n\nfunction concatInPlace(arr1, arr2) {\n  for (let i = 0; i < arr2.length; i++) {\n    arr1.push(arr2[i]);\n  }\n\n  return arr1;\n}\n\nfunction cutPolygonByGrid(positions, holeIndices = null, options) {\n  if (!positions.length) {\n    return [];\n  }\n\n  const {\n    size = 2,\n    gridResolution = 10,\n    gridOffset = [0, 0],\n    edgeTypes = false\n  } = options || {};\n  const result = [];\n  const queue = [{\n    pos: positions,\n    types: edgeTypes ? new Array(positions.length / size).fill(TYPE_BORDER) : null,\n    holes: holeIndices || []\n  }];\n  const bbox = [[], []];\n  let cell = [];\n\n  while (queue.length) {\n    const {\n      pos,\n      types,\n      holes\n    } = queue.shift();\n    getBoundingBox(pos, size, holes[0] || pos.length, bbox);\n    cell = getGridCell(bbox[0], gridResolution, gridOffset, cell);\n    const code = bitCode(bbox[1], cell);\n\n    if (code) {\n      let parts = bisectPolygon(pos, types, size, 0, holes[0] || pos.length, cell, code);\n      const polygonLow = {\n        pos: parts[0].pos,\n        types: parts[0].types,\n        holes: []\n      };\n      const polygonHigh = {\n        pos: parts[1].pos,\n        types: parts[1].types,\n        holes: []\n      };\n      queue.push(polygonLow, polygonHigh);\n\n      for (let i = 0; i < holes.length; i++) {\n        parts = bisectPolygon(pos, types, size, holes[i], holes[i + 1] || pos.length, cell, code);\n\n        if (parts[0]) {\n          polygonLow.holes.push(polygonLow.pos.length);\n          polygonLow.pos = concatInPlace(polygonLow.pos, parts[0].pos);\n\n          if (edgeTypes) {\n            polygonLow.types = concatInPlace(polygonLow.types, parts[0].types);\n          }\n        }\n\n        if (parts[1]) {\n          polygonHigh.holes.push(polygonHigh.pos.length);\n          polygonHigh.pos = concatInPlace(polygonHigh.pos, parts[1].pos);\n\n          if (edgeTypes) {\n            polygonHigh.types = concatInPlace(polygonHigh.types, parts[1].types);\n          }\n        }\n      }\n    } else {\n      const polygon = {\n        positions: pos\n      };\n\n      if (edgeTypes) {\n        polygon.edgeTypes = types;\n      }\n\n      if (holes.length) {\n        polygon.holeIndices = holes;\n      }\n\n      result.push(polygon);\n    }\n  }\n\n  return result;\n}\n\nfunction bisectPolygon(positions, edgeTypes, size, startIndex, endIndex, bbox, edge) {\n  const numPoints = (endIndex - startIndex) / size;\n  const resultLow = [];\n  const resultHigh = [];\n  const typesLow = [];\n  const typesHigh = [];\n  const scratchPoint = [];\n  let p;\n  let side;\n  let type;\n  const prev = utils_getPointAtIndex(positions, numPoints - 1, size, startIndex);\n  let prevSide = Math.sign(edge & 8 ? prev[1] - bbox[3] : prev[0] - bbox[2]);\n  let prevType = edgeTypes && edgeTypes[numPoints - 1];\n  let lowPointCount = 0;\n  let highPointCount = 0;\n\n  for (let i = 0; i < numPoints; i++) {\n    p = utils_getPointAtIndex(positions, i, size, startIndex, p);\n    side = Math.sign(edge & 8 ? p[1] - bbox[3] : p[0] - bbox[2]);\n    type = edgeTypes && edgeTypes[startIndex / size + i];\n\n    if (side && prevSide && prevSide !== side) {\n      intersect(prev, p, edge, bbox, scratchPoint);\n      utils_push(resultLow, scratchPoint) && typesLow.push(prevType);\n      utils_push(resultHigh, scratchPoint) && typesHigh.push(prevType);\n    }\n\n    if (side <= 0) {\n      utils_push(resultLow, p) && typesLow.push(type);\n      lowPointCount -= side;\n    } else if (typesLow.length) {\n      typesLow[typesLow.length - 1] = TYPE_INSIDE;\n    }\n\n    if (side >= 0) {\n      utils_push(resultHigh, p) && typesHigh.push(type);\n      highPointCount += side;\n    } else if (typesHigh.length) {\n      typesHigh[typesHigh.length - 1] = TYPE_INSIDE;\n    }\n\n    utils_copy(prev, p);\n    prevSide = side;\n    prevType = type;\n  }\n\n  return [lowPointCount ? {\n    pos: resultLow,\n    types: edgeTypes && typesLow\n  } : null, highPointCount ? {\n    pos: resultHigh,\n    types: edgeTypes && typesHigh\n  } : null];\n}\n\nfunction getGridCell(p, gridResolution, gridOffset, out) {\n  const left = Math.floor((p[0] - gridOffset[0]) / gridResolution) * gridResolution + gridOffset[0];\n  const bottom = Math.floor((p[1] - gridOffset[1]) / gridResolution) * gridResolution + gridOffset[1];\n  out[0] = left;\n  out[1] = bottom;\n  out[2] = left + gridResolution;\n  out[3] = bottom + gridResolution;\n  return out;\n}\n\nfunction moveToNeighborCell(cell, gridResolution, edge) {\n  if (edge & 8) {\n    cell[1] += gridResolution;\n    cell[3] += gridResolution;\n  } else if (edge & 4) {\n    cell[1] -= gridResolution;\n    cell[3] -= gridResolution;\n  } else if (edge & 2) {\n    cell[0] += gridResolution;\n    cell[2] += gridResolution;\n  } else if (edge & 1) {\n    cell[0] -= gridResolution;\n    cell[2] -= gridResolution;\n  }\n}\n\nfunction getBoundingBox(positions, size, endIndex, out) {\n  let minX = Infinity;\n  let maxX = -Infinity;\n  let minY = Infinity;\n  let maxY = -Infinity;\n\n  for (let i = 0; i < endIndex; i += size) {\n    const x = positions[i];\n    const y = positions[i + 1];\n    minX = x < minX ? x : minX;\n    maxX = x > maxX ? x : maxX;\n    minY = y < minY ? y : minY;\n    maxY = y > maxY ? y : maxY;\n  }\n\n  out[0][0] = minX;\n  out[0][1] = minY;\n  out[1][0] = maxX;\n  out[1][1] = maxY;\n  return out;\n}\n//# sourceMappingURL=cut-by-grid.js.map\n;// CONCATENATED MODULE: ./node_modules/@math.gl/polygon/dist/esm/cut-by-mercator-bounds.js\n\n\nconst DEFAULT_MAX_LATITUDE = 85.051129;\nfunction cutPolylineByMercatorBounds(positions, options) {\n  const {\n    size = 2,\n    startIndex = 0,\n    endIndex = positions.length,\n    normalize = true\n  } = options || {};\n  const newPositions = positions.slice(startIndex, endIndex);\n  wrapLongitudesForShortestPath(newPositions, size, 0, endIndex - startIndex);\n  const parts = cutPolylineByGrid(newPositions, {\n    size,\n    broken: true,\n    gridResolution: 360,\n    gridOffset: [-180, -180]\n  });\n\n  if (normalize) {\n    for (const part of parts) {\n      shiftLongitudesIntoRange(part, size);\n    }\n  }\n\n  return parts;\n}\nfunction cutPolygonByMercatorBounds(positions, holeIndices = null, options) {\n  const {\n    size = 2,\n    normalize = true,\n    edgeTypes = false\n  } = options || {};\n  holeIndices = holeIndices || [];\n  const newPositions = [];\n  const newHoleIndices = [];\n  let srcStartIndex = 0;\n  let targetIndex = 0;\n\n  for (let ringIndex = 0; ringIndex <= holeIndices.length; ringIndex++) {\n    const srcEndIndex = holeIndices[ringIndex] || positions.length;\n    const targetStartIndex = targetIndex;\n    const splitIndex = findSplitIndex(positions, size, srcStartIndex, srcEndIndex);\n\n    for (let i = splitIndex; i < srcEndIndex; i++) {\n      newPositions[targetIndex++] = positions[i];\n    }\n\n    for (let i = srcStartIndex; i < splitIndex; i++) {\n      newPositions[targetIndex++] = positions[i];\n    }\n\n    wrapLongitudesForShortestPath(newPositions, size, targetStartIndex, targetIndex);\n    insertPoleVertices(newPositions, size, targetStartIndex, targetIndex, options === null || options === void 0 ? void 0 : options.maxLatitude);\n    srcStartIndex = srcEndIndex;\n    newHoleIndices[ringIndex] = targetIndex;\n  }\n\n  newHoleIndices.pop();\n  const parts = cutPolygonByGrid(newPositions, newHoleIndices, {\n    size,\n    gridResolution: 360,\n    gridOffset: [-180, -180],\n    edgeTypes\n  });\n\n  if (normalize) {\n    for (const part of parts) {\n      shiftLongitudesIntoRange(part.positions, size);\n    }\n  }\n\n  return parts;\n}\n\nfunction findSplitIndex(positions, size, startIndex, endIndex) {\n  let maxLat = -1;\n  let pointIndex = -1;\n\n  for (let i = startIndex + 1; i < endIndex; i += size) {\n    const lat = Math.abs(positions[i]);\n\n    if (lat > maxLat) {\n      maxLat = lat;\n      pointIndex = i - 1;\n    }\n  }\n\n  return pointIndex;\n}\n\nfunction insertPoleVertices(positions, size, startIndex, endIndex, maxLatitude = DEFAULT_MAX_LATITUDE) {\n  const firstLng = positions[startIndex];\n  const lastLng = positions[endIndex - size];\n\n  if (Math.abs(firstLng - lastLng) > 180) {\n    const p = utils_getPointAtIndex(positions, 0, size, startIndex);\n    p[0] += Math.round((lastLng - firstLng) / 360) * 360;\n    utils_push(positions, p);\n    p[1] = Math.sign(p[1]) * maxLatitude;\n    utils_push(positions, p);\n    p[0] = firstLng;\n    utils_push(positions, p);\n  }\n}\n\nfunction wrapLongitudesForShortestPath(positions, size, startIndex, endIndex) {\n  let prevLng = positions[0];\n  let lng;\n\n  for (let i = startIndex; i < endIndex; i += size) {\n    lng = positions[i];\n    const delta = lng - prevLng;\n\n    if (delta > 180 || delta < -180) {\n      lng -= Math.round(delta / 360) * 360;\n    }\n\n    positions[i] = prevLng = lng;\n  }\n}\n\nfunction shiftLongitudesIntoRange(positions, size) {\n  let refLng;\n  const pointCount = positions.length / size;\n\n  for (let i = 0; i < pointCount; i++) {\n    refLng = positions[i * size];\n\n    if ((refLng + 180) % 360 !== 0) {\n      break;\n    }\n  }\n\n  const delta = -Math.round(refLng / 360) * 360;\n\n  if (delta === 0) {\n    return;\n  }\n\n  for (let i = 0; i < pointCount; i++) {\n    positions[i * size] += delta;\n  }\n}\n//# sourceMappingURL=cut-by-mercator-bounds.js.map\n;// CONCATENATED MODULE: ./node_modules/@math.gl/polygon/dist/esm/index.js\n\n\n\n\n\n\n\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QUNoSitDO0FBQ3FHO0FBQ2xIO0FBQ3FCO0FBQ2E7QUFDK0I7QUFDbkQ7QUFDaEQiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly92dWUzLXdlYnBhY2s1Ly4vbm9kZV9tb2R1bGVzL0BtYXRoLmdsL3BvbHlnb24vZGlzdC9lc20vcG9seWdvbi11dGlscy5qcz84NzA4Iiwid2VicGFjazovL3Z1ZTMtd2VicGFjazUvLi9ub2RlX21vZHVsZXMvQG1hdGguZ2wvcG9seWdvbi9kaXN0L2VzbS9wb2x5Z29uLmpzP2Y5ZWUiLCJ3ZWJwYWNrOi8vdnVlMy13ZWJwYWNrNS8uL25vZGVfbW9kdWxlcy9AbWF0aC5nbC9wb2x5Z29uL2Rpc3QvZXNtL2VhcmN1dC5qcz83ZDBhIiwid2VicGFjazovL3Z1ZTMtd2VicGFjazUvLi9ub2RlX21vZHVsZXMvQG1hdGguZ2wvcG9seWdvbi9kaXN0L2VzbS9saW5lY2xpcC5qcz84ODIwIiwid2VicGFjazovL3Z1ZTMtd2VicGFjazUvLi9ub2RlX21vZHVsZXMvQG1hdGguZ2wvcG9seWdvbi9kaXN0L2VzbS91dGlscy5qcz81YmU1Iiwid2VicGFjazovL3Z1ZTMtd2VicGFjazUvLi9ub2RlX21vZHVsZXMvQG1hdGguZ2wvcG9seWdvbi9kaXN0L2VzbS9jdXQtYnktZ3JpZC5qcz9jNmUwIiwid2VicGFjazovL3Z1ZTMtd2VicGFjazUvLi9ub2RlX21vZHVsZXMvQG1hdGguZ2wvcG9seWdvbi9kaXN0L2VzbS9jdXQtYnktbWVyY2F0b3ItYm91bmRzLmpzPzE4YWYiLCJ3ZWJwYWNrOi8vdnVlMy13ZWJwYWNrNS8uL25vZGVfbW9kdWxlcy9AbWF0aC5nbC9wb2x5Z29uL2Rpc3QvZXNtL2luZGV4LmpzPzZjOTYiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgZXF1YWxzIH0gZnJvbSAnQG1hdGguZ2wvY29yZSc7XG5leHBvcnQgY29uc3QgV0lORElORyA9IHtcbiAgQ0xPQ0tXSVNFOiAxLFxuICBDT1VOVEVSX0NMT0NLV0lTRTogLTFcbn07XG5leHBvcnQgZnVuY3Rpb24gbW9kaWZ5UG9seWdvbldpbmRpbmdEaXJlY3Rpb24ocG9pbnRzLCBkaXJlY3Rpb24sIG9wdGlvbnMgPSB7fSkge1xuICBjb25zdCB3aW5kaW5nRGlyZWN0aW9uID0gZ2V0UG9seWdvbldpbmRpbmdEaXJlY3Rpb24ocG9pbnRzLCBvcHRpb25zKTtcblxuICBpZiAod2luZGluZ0RpcmVjdGlvbiAhPT0gZGlyZWN0aW9uKSB7XG4gICAgcmV2ZXJzZVBvbHlnb24ocG9pbnRzLCBvcHRpb25zKTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBnZXRQb2x5Z29uV2luZGluZ0RpcmVjdGlvbihwb2ludHMsIG9wdGlvbnMgPSB7fSkge1xuICByZXR1cm4gTWF0aC5zaWduKGdldFBvbHlnb25TaWduZWRBcmVhKHBvaW50cywgb3B0aW9ucykpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGdldFBvbHlnb25TaWduZWRBcmVhKHBvaW50cywgb3B0aW9ucyA9IHt9KSB7XG4gIGNvbnN0IHtcbiAgICBzdGFydCA9IDAsXG4gICAgZW5kID0gcG9pbnRzLmxlbmd0aFxuICB9ID0gb3B0aW9ucztcbiAgY29uc3QgZGltID0gb3B0aW9ucy5zaXplIHx8IDI7XG4gIGxldCBhcmVhID0gMDtcblxuICBmb3IgKGxldCBpID0gc3RhcnQsIGogPSBlbmQgLSBkaW07IGkgPCBlbmQ7IGkgKz0gZGltKSB7XG4gICAgYXJlYSArPSAocG9pbnRzW2ldIC0gcG9pbnRzW2pdKSAqIChwb2ludHNbaSArIDFdICsgcG9pbnRzW2ogKyAxXSk7XG4gICAgaiA9IGk7XG4gIH1cblxuICByZXR1cm4gYXJlYSAvIDI7XG59XG5leHBvcnQgZnVuY3Rpb24gZm9yRWFjaFNlZ21lbnRJblBvbHlnb24ocG9pbnRzLCB2aXNpdG9yLCBvcHRpb25zID0ge30pIHtcbiAgY29uc3Qge1xuICAgIHN0YXJ0ID0gMCxcbiAgICBlbmQgPSBwb2ludHMubGVuZ3RoLFxuICAgIHNpemUgPSAyLFxuICAgIGlzQ2xvc2VkXG4gIH0gPSBvcHRpb25zO1xuICBjb25zdCBudW1Qb2ludHMgPSAoZW5kIC0gc3RhcnQpIC8gc2l6ZTtcblxuICBmb3IgKGxldCBpID0gMDsgaSA8IG51bVBvaW50cyAtIDE7ICsraSkge1xuICAgIHZpc2l0b3IocG9pbnRzW3N0YXJ0ICsgaSAqIHNpemVdLCBwb2ludHNbc3RhcnQgKyBpICogc2l6ZSArIDFdLCBwb2ludHNbc3RhcnQgKyAoaSArIDEpICogc2l6ZV0sIHBvaW50c1tzdGFydCArIChpICsgMSkgKiBzaXplICsgMV0sIGksIGkgKyAxKTtcbiAgfVxuXG4gIGNvbnN0IGVuZFBvaW50SW5kZXggPSBzdGFydCArIChudW1Qb2ludHMgLSAxKSAqIHNpemU7XG4gIGNvbnN0IGlzQ2xvc2VkRXggPSBpc0Nsb3NlZCB8fCBlcXVhbHMocG9pbnRzW3N0YXJ0XSwgcG9pbnRzW2VuZFBvaW50SW5kZXhdKSAmJiBlcXVhbHMocG9pbnRzW3N0YXJ0ICsgMV0sIHBvaW50c1tlbmRQb2ludEluZGV4ICsgMV0pO1xuXG4gIGlmICghaXNDbG9zZWRFeCkge1xuICAgIHZpc2l0b3IocG9pbnRzW2VuZFBvaW50SW5kZXhdLCBwb2ludHNbZW5kUG9pbnRJbmRleCArIDFdLCBwb2ludHNbc3RhcnRdLCBwb2ludHNbc3RhcnQgKyAxXSwgbnVtUG9pbnRzIC0gMSwgMCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gcmV2ZXJzZVBvbHlnb24ocG9pbnRzLCBvcHRpb25zKSB7XG4gIGNvbnN0IHtcbiAgICBzdGFydCA9IDAsXG4gICAgZW5kID0gcG9pbnRzLmxlbmd0aCxcbiAgICBzaXplID0gMlxuICB9ID0gb3B0aW9ucztcbiAgY29uc3QgbnVtUG9pbnRzID0gKGVuZCAtIHN0YXJ0KSAvIHNpemU7XG4gIGNvbnN0IG51bVN3YXBzID0gTWF0aC5mbG9vcihudW1Qb2ludHMgLyAyKTtcblxuICBmb3IgKGxldCBpID0gMDsgaSA8IG51bVN3YXBzOyArK2kpIHtcbiAgICBjb25zdCBiMSA9IHN0YXJ0ICsgaSAqIHNpemU7XG4gICAgY29uc3QgYjIgPSBzdGFydCArIChudW1Qb2ludHMgLSAxIC0gaSkgKiBzaXplO1xuXG4gICAgZm9yIChsZXQgaiA9IDA7IGogPCBzaXplOyArK2opIHtcbiAgICAgIGNvbnN0IHRtcCA9IHBvaW50c1tiMSArIGpdO1xuICAgICAgcG9pbnRzW2IxICsgal0gPSBwb2ludHNbYjIgKyBqXTtcbiAgICAgIHBvaW50c1tiMiArIGpdID0gdG1wO1xuICAgIH1cbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gbW9kaWZ5UG9seWdvbldpbmRpbmdEaXJlY3Rpb25Qb2ludHMocG9pbnRzLCBkaXJlY3Rpb24sIG9wdGlvbnMgPSB7fSkge1xuICBjb25zdCBjdXJyZW50RGlyZWN0aW9uID0gZ2V0UG9seWdvbldpbmRpbmdEaXJlY3Rpb25Qb2ludHMocG9pbnRzLCBvcHRpb25zKTtcblxuICBpZiAoY3VycmVudERpcmVjdGlvbiAhPT0gZGlyZWN0aW9uKSB7XG4gICAgcG9pbnRzLnJldmVyc2UoKTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBnZXRQb2x5Z29uV2luZGluZ0RpcmVjdGlvblBvaW50cyhwb2ludHMsIG9wdGlvbnMgPSB7fSkge1xuICByZXR1cm4gTWF0aC5zaWduKGdldFBvbHlnb25TaWduZWRBcmVhUG9pbnRzKHBvaW50cywgb3B0aW9ucykpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGdldFBvbHlnb25TaWduZWRBcmVhUG9pbnRzKHBvaW50cywgb3B0aW9ucyA9IHt9KSB7XG4gIGNvbnN0IHtcbiAgICBzdGFydCA9IDAsXG4gICAgZW5kID0gcG9pbnRzLmxlbmd0aFxuICB9ID0gb3B0aW9ucztcbiAgbGV0IGFyZWEgPSAwO1xuXG4gIGZvciAobGV0IGkgPSBzdGFydCwgaiA9IGVuZCAtIDE7IGkgPCBlbmQ7ICsraSkge1xuICAgIGFyZWEgKz0gKHBvaW50c1tpXVswXSAtIHBvaW50c1tqXVswXSkgKiAocG9pbnRzW2ldWzFdICsgcG9pbnRzW2pdWzFdKTtcbiAgICBqID0gaTtcbiAgfVxuXG4gIHJldHVybiBhcmVhIC8gMjtcbn1cbmV4cG9ydCBmdW5jdGlvbiBmb3JFYWNoU2VnbWVudEluUG9seWdvblBvaW50cyhwb2ludHMsIHZpc2l0b3IsIG9wdGlvbnMgPSB7fSkge1xuICBjb25zdCB7XG4gICAgc3RhcnQgPSAwLFxuICAgIGVuZCA9IHBvaW50cy5sZW5ndGgsXG4gICAgaXNDbG9zZWRcbiAgfSA9IG9wdGlvbnM7XG5cbiAgZm9yIChsZXQgaSA9IHN0YXJ0OyBpIDwgZW5kIC0gMTsgKytpKSB7XG4gICAgdmlzaXRvcihwb2ludHNbaV0sIHBvaW50c1tpICsgMV0sIGksIGkgKyAxKTtcbiAgfVxuXG4gIGNvbnN0IGlzQ2xvc2VkRXggPSBpc0Nsb3NlZCB8fCBlcXVhbHMocG9pbnRzW2VuZCAtIDFdLCBwb2ludHNbMF0pO1xuXG4gIGlmICghaXNDbG9zZWRFeCkge1xuICAgIHZpc2l0b3IocG9pbnRzW2VuZCAtIDFdLCBwb2ludHNbMF0sIGVuZCAtIDEsIDApO1xuICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1wb2x5Z29uLXV0aWxzLmpzLm1hcCIsImltcG9ydCBfZGVmaW5lUHJvcGVydHkgZnJvbSBcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL2RlZmluZVByb3BlcnR5XCI7XG5pbXBvcnQgeyBpc0FycmF5IH0gZnJvbSAnQG1hdGguZ2wvY29yZSc7XG5pbXBvcnQgeyBnZXRQb2x5Z29uU2lnbmVkQXJlYSwgZm9yRWFjaFNlZ21lbnRJblBvbHlnb24sIG1vZGlmeVBvbHlnb25XaW5kaW5nRGlyZWN0aW9uLCBnZXRQb2x5Z29uU2lnbmVkQXJlYVBvaW50cywgZm9yRWFjaFNlZ21lbnRJblBvbHlnb25Qb2ludHMsIG1vZGlmeVBvbHlnb25XaW5kaW5nRGlyZWN0aW9uUG9pbnRzIH0gZnJvbSAnLi9wb2x5Z29uLXV0aWxzJztcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFBvbHlnb24ge1xuICBjb25zdHJ1Y3Rvcihwb2ludHMsIG9wdGlvbnMgPSB7fSkge1xuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInBvaW50c1wiLCB2b2lkIDApO1xuXG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwiaXNGbGF0QXJyYXlcIiwgdm9pZCAwKTtcblxuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIm9wdGlvbnNcIiwgdm9pZCAwKTtcblxuICAgIHRoaXMucG9pbnRzID0gcG9pbnRzO1xuICAgIHRoaXMuaXNGbGF0QXJyYXkgPSAhaXNBcnJheShwb2ludHNbMF0pO1xuICAgIHRoaXMub3B0aW9ucyA9IHtcbiAgICAgIHN0YXJ0OiBvcHRpb25zLnN0YXJ0IHx8IDAsXG4gICAgICBlbmQ6IG9wdGlvbnMuZW5kIHx8IHBvaW50cy5sZW5ndGgsXG4gICAgICBzaXplOiBvcHRpb25zLnNpemUgfHwgMixcbiAgICAgIGlzQ2xvc2VkOiBvcHRpb25zLmlzQ2xvc2VkXG4gICAgfTtcbiAgICBPYmplY3QuZnJlZXplKHRoaXMpO1xuICB9XG5cbiAgZ2V0U2lnbmVkQXJlYSgpIHtcbiAgICBpZiAodGhpcy5pc0ZsYXRBcnJheSkgcmV0dXJuIGdldFBvbHlnb25TaWduZWRBcmVhKHRoaXMucG9pbnRzLCB0aGlzLm9wdGlvbnMpO1xuICAgIHJldHVybiBnZXRQb2x5Z29uU2lnbmVkQXJlYVBvaW50cyh0aGlzLnBvaW50cywgdGhpcy5vcHRpb25zKTtcbiAgfVxuXG4gIGdldEFyZWEoKSB7XG4gICAgcmV0dXJuIE1hdGguYWJzKHRoaXMuZ2V0U2lnbmVkQXJlYSgpKTtcbiAgfVxuXG4gIGdldFdpbmRpbmdEaXJlY3Rpb24oKSB7XG4gICAgcmV0dXJuIE1hdGguc2lnbih0aGlzLmdldFNpZ25lZEFyZWEoKSk7XG4gIH1cblxuICBmb3JFYWNoU2VnbWVudCh2aXNpdG9yKSB7XG4gICAgaWYgKHRoaXMuaXNGbGF0QXJyYXkpIHtcbiAgICAgIGZvckVhY2hTZWdtZW50SW5Qb2x5Z29uKHRoaXMucG9pbnRzLCAoeDEsIHkxLCB4MiwgeTIsIGkxLCBpMikgPT4ge1xuICAgICAgICB2aXNpdG9yKFt4MSwgeTFdLCBbeDIsIHkyXSwgaTEsIGkyKTtcbiAgICAgIH0sIHRoaXMub3B0aW9ucyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGZvckVhY2hTZWdtZW50SW5Qb2x5Z29uUG9pbnRzKHRoaXMucG9pbnRzLCB2aXNpdG9yLCB0aGlzLm9wdGlvbnMpO1xuICAgIH1cbiAgfVxuXG4gIG1vZGlmeVdpbmRpbmdEaXJlY3Rpb24oZGlyZWN0aW9uKSB7XG4gICAgaWYgKHRoaXMuaXNGbGF0QXJyYXkpIHtcbiAgICAgIHJldHVybiBtb2RpZnlQb2x5Z29uV2luZGluZ0RpcmVjdGlvbih0aGlzLnBvaW50cywgZGlyZWN0aW9uLCB0aGlzLm9wdGlvbnMpO1xuICAgIH1cblxuICAgIHJldHVybiBtb2RpZnlQb2x5Z29uV2luZGluZ0RpcmVjdGlvblBvaW50cyh0aGlzLnBvaW50cywgZGlyZWN0aW9uLCB0aGlzLm9wdGlvbnMpO1xuICB9XG5cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXBvbHlnb24uanMubWFwIiwiaW1wb3J0IHsgZ2V0UG9seWdvblNpZ25lZEFyZWEgfSBmcm9tICcuL3BvbHlnb24tdXRpbHMnO1xuZXhwb3J0IGZ1bmN0aW9uIGVhcmN1dChwb3NpdGlvbnMsIGhvbGVJbmRpY2VzLCBkaW0gPSAyLCBhcmVhcykge1xuICBjb25zdCBoYXNIb2xlcyA9IGhvbGVJbmRpY2VzICYmIGhvbGVJbmRpY2VzLmxlbmd0aDtcbiAgY29uc3Qgb3V0ZXJMZW4gPSBoYXNIb2xlcyA/IGhvbGVJbmRpY2VzWzBdICogZGltIDogcG9zaXRpb25zLmxlbmd0aDtcbiAgbGV0IG91dGVyTm9kZSA9IGxpbmtlZExpc3QocG9zaXRpb25zLCAwLCBvdXRlckxlbiwgZGltLCB0cnVlLCBhcmVhcyAmJiBhcmVhc1swXSk7XG4gIGNvbnN0IHRyaWFuZ2xlcyA9IFtdO1xuICBpZiAoIW91dGVyTm9kZSB8fCBvdXRlck5vZGUubmV4dCA9PT0gb3V0ZXJOb2RlLnByZXYpIHJldHVybiB0cmlhbmdsZXM7XG4gIGxldCBpbnZTaXplO1xuICBsZXQgbWF4WDtcbiAgbGV0IG1heFk7XG4gIGxldCBtaW5YO1xuICBsZXQgbWluWTtcbiAgbGV0IHg7XG4gIGxldCB5O1xuICBpZiAoaGFzSG9sZXMpIG91dGVyTm9kZSA9IGVsaW1pbmF0ZUhvbGVzKHBvc2l0aW9ucywgaG9sZUluZGljZXMsIG91dGVyTm9kZSwgZGltLCBhcmVhcyk7XG5cbiAgaWYgKHBvc2l0aW9ucy5sZW5ndGggPiA4MCAqIGRpbSkge1xuICAgIG1pblggPSBtYXhYID0gcG9zaXRpb25zWzBdO1xuICAgIG1pblkgPSBtYXhZID0gcG9zaXRpb25zWzFdO1xuXG4gICAgZm9yIChsZXQgaSA9IGRpbTsgaSA8IG91dGVyTGVuOyBpICs9IGRpbSkge1xuICAgICAgeCA9IHBvc2l0aW9uc1tpXTtcbiAgICAgIHkgPSBwb3NpdGlvbnNbaSArIDFdO1xuICAgICAgaWYgKHggPCBtaW5YKSBtaW5YID0geDtcbiAgICAgIGlmICh5IDwgbWluWSkgbWluWSA9IHk7XG4gICAgICBpZiAoeCA+IG1heFgpIG1heFggPSB4O1xuICAgICAgaWYgKHkgPiBtYXhZKSBtYXhZID0geTtcbiAgICB9XG5cbiAgICBpbnZTaXplID0gTWF0aC5tYXgobWF4WCAtIG1pblgsIG1heFkgLSBtaW5ZKTtcbiAgICBpbnZTaXplID0gaW52U2l6ZSAhPT0gMCA/IDEgLyBpbnZTaXplIDogMDtcbiAgfVxuXG4gIGVhcmN1dExpbmtlZChvdXRlck5vZGUsIHRyaWFuZ2xlcywgZGltLCBtaW5YLCBtaW5ZLCBpbnZTaXplKTtcbiAgcmV0dXJuIHRyaWFuZ2xlcztcbn1cblxuZnVuY3Rpb24gbGlua2VkTGlzdChkYXRhLCBzdGFydCwgZW5kLCBkaW0sIGNsb2Nrd2lzZSwgYXJlYSkge1xuICBsZXQgaTtcbiAgbGV0IGxhc3Q7XG5cbiAgaWYgKGFyZWEgPT09IHVuZGVmaW5lZCkge1xuICAgIGFyZWEgPSBnZXRQb2x5Z29uU2lnbmVkQXJlYShkYXRhLCB7XG4gICAgICBzdGFydCxcbiAgICAgIGVuZCxcbiAgICAgIHNpemU6IGRpbVxuICAgIH0pO1xuICB9XG5cbiAgaWYgKGNsb2Nrd2lzZSA9PT0gYXJlYSA8IDApIHtcbiAgICBmb3IgKGkgPSBzdGFydDsgaSA8IGVuZDsgaSArPSBkaW0pIGxhc3QgPSBpbnNlcnROb2RlKGksIGRhdGFbaV0sIGRhdGFbaSArIDFdLCBsYXN0KTtcbiAgfSBlbHNlIHtcbiAgICBmb3IgKGkgPSBlbmQgLSBkaW07IGkgPj0gc3RhcnQ7IGkgLT0gZGltKSBsYXN0ID0gaW5zZXJ0Tm9kZShpLCBkYXRhW2ldLCBkYXRhW2kgKyAxXSwgbGFzdCk7XG4gIH1cblxuICBpZiAobGFzdCAmJiBlcXVhbHMobGFzdCwgbGFzdC5uZXh0KSkge1xuICAgIHJlbW92ZU5vZGUobGFzdCk7XG4gICAgbGFzdCA9IGxhc3QubmV4dDtcbiAgfVxuXG4gIHJldHVybiBsYXN0O1xufVxuXG5mdW5jdGlvbiBmaWx0ZXJQb2ludHMoc3RhcnQsIGVuZCkge1xuICBpZiAoIXN0YXJ0KSByZXR1cm4gc3RhcnQ7XG4gIGlmICghZW5kKSBlbmQgPSBzdGFydDtcbiAgbGV0IHAgPSBzdGFydDtcbiAgbGV0IGFnYWluO1xuXG4gIGRvIHtcbiAgICBhZ2FpbiA9IGZhbHNlO1xuXG4gICAgaWYgKCFwLnN0ZWluZXIgJiYgKGVxdWFscyhwLCBwLm5leHQpIHx8IGFyZWEocC5wcmV2LCBwLCBwLm5leHQpID09PSAwKSkge1xuICAgICAgcmVtb3ZlTm9kZShwKTtcbiAgICAgIHAgPSBlbmQgPSBwLnByZXY7XG4gICAgICBpZiAocCA9PT0gcC5uZXh0KSBicmVhaztcbiAgICAgIGFnYWluID0gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcCA9IHAubmV4dDtcbiAgICB9XG4gIH0gd2hpbGUgKGFnYWluIHx8IHAgIT09IGVuZCk7XG5cbiAgcmV0dXJuIGVuZDtcbn1cblxuZnVuY3Rpb24gZWFyY3V0TGlua2VkKGVhciwgdHJpYW5nbGVzLCBkaW0sIG1pblgsIG1pblksIGludlNpemUsIHBhc3MpIHtcbiAgaWYgKCFlYXIpIHJldHVybjtcbiAgaWYgKCFwYXNzICYmIGludlNpemUpIGluZGV4Q3VydmUoZWFyLCBtaW5YLCBtaW5ZLCBpbnZTaXplKTtcbiAgbGV0IHN0b3AgPSBlYXI7XG4gIGxldCBwcmV2O1xuICBsZXQgbmV4dDtcblxuICB3aGlsZSAoZWFyLnByZXYgIT09IGVhci5uZXh0KSB7XG4gICAgcHJldiA9IGVhci5wcmV2O1xuICAgIG5leHQgPSBlYXIubmV4dDtcblxuICAgIGlmIChpbnZTaXplID8gaXNFYXJIYXNoZWQoZWFyLCBtaW5YLCBtaW5ZLCBpbnZTaXplKSA6IGlzRWFyKGVhcikpIHtcbiAgICAgIHRyaWFuZ2xlcy5wdXNoKHByZXYuaSAvIGRpbSk7XG4gICAgICB0cmlhbmdsZXMucHVzaChlYXIuaSAvIGRpbSk7XG4gICAgICB0cmlhbmdsZXMucHVzaChuZXh0LmkgLyBkaW0pO1xuICAgICAgcmVtb3ZlTm9kZShlYXIpO1xuICAgICAgZWFyID0gbmV4dC5uZXh0O1xuICAgICAgc3RvcCA9IG5leHQubmV4dDtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIGVhciA9IG5leHQ7XG5cbiAgICBpZiAoZWFyID09PSBzdG9wKSB7XG4gICAgICBpZiAoIXBhc3MpIHtcbiAgICAgICAgZWFyY3V0TGlua2VkKGZpbHRlclBvaW50cyhlYXIpLCB0cmlhbmdsZXMsIGRpbSwgbWluWCwgbWluWSwgaW52U2l6ZSwgMSk7XG4gICAgICB9IGVsc2UgaWYgKHBhc3MgPT09IDEpIHtcbiAgICAgICAgZWFyID0gY3VyZUxvY2FsSW50ZXJzZWN0aW9ucyhmaWx0ZXJQb2ludHMoZWFyKSwgdHJpYW5nbGVzLCBkaW0pO1xuICAgICAgICBlYXJjdXRMaW5rZWQoZWFyLCB0cmlhbmdsZXMsIGRpbSwgbWluWCwgbWluWSwgaW52U2l6ZSwgMik7XG4gICAgICB9IGVsc2UgaWYgKHBhc3MgPT09IDIpIHtcbiAgICAgICAgc3BsaXRFYXJjdXQoZWFyLCB0cmlhbmdsZXMsIGRpbSwgbWluWCwgbWluWSwgaW52U2l6ZSk7XG4gICAgICB9XG5cbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBpc0VhcihlYXIpIHtcbiAgY29uc3QgYSA9IGVhci5wcmV2O1xuICBjb25zdCBiID0gZWFyO1xuICBjb25zdCBjID0gZWFyLm5leHQ7XG4gIGlmIChhcmVhKGEsIGIsIGMpID49IDApIHJldHVybiBmYWxzZTtcbiAgbGV0IHAgPSBlYXIubmV4dC5uZXh0O1xuXG4gIHdoaWxlIChwICE9PSBlYXIucHJldikge1xuICAgIGlmIChwb2ludEluVHJpYW5nbGUoYS54LCBhLnksIGIueCwgYi55LCBjLngsIGMueSwgcC54LCBwLnkpICYmIGFyZWEocC5wcmV2LCBwLCBwLm5leHQpID49IDApIHJldHVybiBmYWxzZTtcbiAgICBwID0gcC5uZXh0O1xuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59XG5cbmZ1bmN0aW9uIGlzRWFySGFzaGVkKGVhciwgbWluWCwgbWluWSwgaW52U2l6ZSkge1xuICBjb25zdCBhID0gZWFyLnByZXY7XG4gIGNvbnN0IGIgPSBlYXI7XG4gIGNvbnN0IGMgPSBlYXIubmV4dDtcbiAgaWYgKGFyZWEoYSwgYiwgYykgPj0gMCkgcmV0dXJuIGZhbHNlO1xuICBjb25zdCBtaW5UWCA9IGEueCA8IGIueCA/IGEueCA8IGMueCA/IGEueCA6IGMueCA6IGIueCA8IGMueCA/IGIueCA6IGMueDtcbiAgY29uc3QgbWluVFkgPSBhLnkgPCBiLnkgPyBhLnkgPCBjLnkgPyBhLnkgOiBjLnkgOiBiLnkgPCBjLnkgPyBiLnkgOiBjLnk7XG4gIGNvbnN0IG1heFRYID0gYS54ID4gYi54ID8gYS54ID4gYy54ID8gYS54IDogYy54IDogYi54ID4gYy54ID8gYi54IDogYy54O1xuICBjb25zdCBtYXhUWSA9IGEueSA+IGIueSA/IGEueSA+IGMueSA/IGEueSA6IGMueSA6IGIueSA+IGMueSA/IGIueSA6IGMueTtcbiAgY29uc3QgbWluWiA9IHpPcmRlcihtaW5UWCwgbWluVFksIG1pblgsIG1pblksIGludlNpemUpO1xuICBjb25zdCBtYXhaID0gek9yZGVyKG1heFRYLCBtYXhUWSwgbWluWCwgbWluWSwgaW52U2l6ZSk7XG4gIGxldCBwID0gZWFyLnByZXZaO1xuICBsZXQgbiA9IGVhci5uZXh0WjtcblxuICB3aGlsZSAocCAmJiBwLnogPj0gbWluWiAmJiBuICYmIG4ueiA8PSBtYXhaKSB7XG4gICAgaWYgKHAgIT09IGVhci5wcmV2ICYmIHAgIT09IGVhci5uZXh0ICYmIHBvaW50SW5UcmlhbmdsZShhLngsIGEueSwgYi54LCBiLnksIGMueCwgYy55LCBwLngsIHAueSkgJiYgYXJlYShwLnByZXYsIHAsIHAubmV4dCkgPj0gMCkgcmV0dXJuIGZhbHNlO1xuICAgIHAgPSBwLnByZXZaO1xuICAgIGlmIChuICE9PSBlYXIucHJldiAmJiBuICE9PSBlYXIubmV4dCAmJiBwb2ludEluVHJpYW5nbGUoYS54LCBhLnksIGIueCwgYi55LCBjLngsIGMueSwgbi54LCBuLnkpICYmIGFyZWEobi5wcmV2LCBuLCBuLm5leHQpID49IDApIHJldHVybiBmYWxzZTtcbiAgICBuID0gbi5uZXh0WjtcbiAgfVxuXG4gIHdoaWxlIChwICYmIHAueiA+PSBtaW5aKSB7XG4gICAgaWYgKHAgIT09IGVhci5wcmV2ICYmIHAgIT09IGVhci5uZXh0ICYmIHBvaW50SW5UcmlhbmdsZShhLngsIGEueSwgYi54LCBiLnksIGMueCwgYy55LCBwLngsIHAueSkgJiYgYXJlYShwLnByZXYsIHAsIHAubmV4dCkgPj0gMCkgcmV0dXJuIGZhbHNlO1xuICAgIHAgPSBwLnByZXZaO1xuICB9XG5cbiAgd2hpbGUgKG4gJiYgbi56IDw9IG1heFopIHtcbiAgICBpZiAobiAhPT0gZWFyLnByZXYgJiYgbiAhPT0gZWFyLm5leHQgJiYgcG9pbnRJblRyaWFuZ2xlKGEueCwgYS55LCBiLngsIGIueSwgYy54LCBjLnksIG4ueCwgbi55KSAmJiBhcmVhKG4ucHJldiwgbiwgbi5uZXh0KSA+PSAwKSByZXR1cm4gZmFsc2U7XG4gICAgbiA9IG4ubmV4dFo7XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gY3VyZUxvY2FsSW50ZXJzZWN0aW9ucyhzdGFydCwgdHJpYW5nbGVzLCBkaW0pIHtcbiAgbGV0IHAgPSBzdGFydDtcblxuICBkbyB7XG4gICAgY29uc3QgYSA9IHAucHJldjtcbiAgICBjb25zdCBiID0gcC5uZXh0Lm5leHQ7XG5cbiAgICBpZiAoIWVxdWFscyhhLCBiKSAmJiBpbnRlcnNlY3RzKGEsIHAsIHAubmV4dCwgYikgJiYgbG9jYWxseUluc2lkZShhLCBiKSAmJiBsb2NhbGx5SW5zaWRlKGIsIGEpKSB7XG4gICAgICB0cmlhbmdsZXMucHVzaChhLmkgLyBkaW0pO1xuICAgICAgdHJpYW5nbGVzLnB1c2gocC5pIC8gZGltKTtcbiAgICAgIHRyaWFuZ2xlcy5wdXNoKGIuaSAvIGRpbSk7XG4gICAgICByZW1vdmVOb2RlKHApO1xuICAgICAgcmVtb3ZlTm9kZShwLm5leHQpO1xuICAgICAgcCA9IHN0YXJ0ID0gYjtcbiAgICB9XG5cbiAgICBwID0gcC5uZXh0O1xuICB9IHdoaWxlIChwICE9PSBzdGFydCk7XG5cbiAgcmV0dXJuIGZpbHRlclBvaW50cyhwKTtcbn1cblxuZnVuY3Rpb24gc3BsaXRFYXJjdXQoc3RhcnQsIHRyaWFuZ2xlcywgZGltLCBtaW5YLCBtaW5ZLCBpbnZTaXplKSB7XG4gIGxldCBhID0gc3RhcnQ7XG5cbiAgZG8ge1xuICAgIGxldCBiID0gYS5uZXh0Lm5leHQ7XG5cbiAgICB3aGlsZSAoYiAhPT0gYS5wcmV2KSB7XG4gICAgICBpZiAoYS5pICE9PSBiLmkgJiYgaXNWYWxpZERpYWdvbmFsKGEsIGIpKSB7XG4gICAgICAgIGxldCBjID0gc3BsaXRQb2x5Z29uKGEsIGIpO1xuICAgICAgICBhID0gZmlsdGVyUG9pbnRzKGEsIGEubmV4dCk7XG4gICAgICAgIGMgPSBmaWx0ZXJQb2ludHMoYywgYy5uZXh0KTtcbiAgICAgICAgZWFyY3V0TGlua2VkKGEsIHRyaWFuZ2xlcywgZGltLCBtaW5YLCBtaW5ZLCBpbnZTaXplKTtcbiAgICAgICAgZWFyY3V0TGlua2VkKGMsIHRyaWFuZ2xlcywgZGltLCBtaW5YLCBtaW5ZLCBpbnZTaXplKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBiID0gYi5uZXh0O1xuICAgIH1cblxuICAgIGEgPSBhLm5leHQ7XG4gIH0gd2hpbGUgKGEgIT09IHN0YXJ0KTtcbn1cblxuZnVuY3Rpb24gZWxpbWluYXRlSG9sZXMoZGF0YSwgaG9sZUluZGljZXMsIG91dGVyTm9kZSwgZGltLCBhcmVhcykge1xuICBjb25zdCBxdWV1ZSA9IFtdO1xuICBsZXQgaTtcbiAgbGV0IGxlbjtcbiAgbGV0IHN0YXJ0O1xuICBsZXQgZW5kO1xuICBsZXQgbGlzdDtcblxuICBmb3IgKGkgPSAwLCBsZW4gPSBob2xlSW5kaWNlcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgIHN0YXJ0ID0gaG9sZUluZGljZXNbaV0gKiBkaW07XG4gICAgZW5kID0gaSA8IGxlbiAtIDEgPyBob2xlSW5kaWNlc1tpICsgMV0gKiBkaW0gOiBkYXRhLmxlbmd0aDtcbiAgICBsaXN0ID0gbGlua2VkTGlzdChkYXRhLCBzdGFydCwgZW5kLCBkaW0sIGZhbHNlLCBhcmVhcyAmJiBhcmVhc1tpICsgMV0pO1xuICAgIGlmIChsaXN0ID09PSBsaXN0Lm5leHQpIGxpc3Quc3RlaW5lciA9IHRydWU7XG4gICAgcXVldWUucHVzaChnZXRMZWZ0bW9zdChsaXN0KSk7XG4gIH1cblxuICBxdWV1ZS5zb3J0KGNvbXBhcmVYKTtcblxuICBmb3IgKGkgPSAwOyBpIDwgcXVldWUubGVuZ3RoOyBpKyspIHtcbiAgICBlbGltaW5hdGVIb2xlKHF1ZXVlW2ldLCBvdXRlck5vZGUpO1xuICAgIG91dGVyTm9kZSA9IGZpbHRlclBvaW50cyhvdXRlck5vZGUsIG91dGVyTm9kZS5uZXh0KTtcbiAgfVxuXG4gIHJldHVybiBvdXRlck5vZGU7XG59XG5cbmZ1bmN0aW9uIGNvbXBhcmVYKGEsIGIpIHtcbiAgcmV0dXJuIGEueCAtIGIueDtcbn1cblxuZnVuY3Rpb24gZWxpbWluYXRlSG9sZShob2xlLCBvdXRlck5vZGUpIHtcbiAgb3V0ZXJOb2RlID0gZmluZEhvbGVCcmlkZ2UoaG9sZSwgb3V0ZXJOb2RlKTtcblxuICBpZiAob3V0ZXJOb2RlKSB7XG4gICAgY29uc3QgYiA9IHNwbGl0UG9seWdvbihvdXRlck5vZGUsIGhvbGUpO1xuICAgIGZpbHRlclBvaW50cyhvdXRlck5vZGUsIG91dGVyTm9kZS5uZXh0KTtcbiAgICBmaWx0ZXJQb2ludHMoYiwgYi5uZXh0KTtcbiAgfVxufVxuXG5mdW5jdGlvbiBmaW5kSG9sZUJyaWRnZShob2xlLCBvdXRlck5vZGUpIHtcbiAgbGV0IHAgPSBvdXRlck5vZGU7XG4gIGNvbnN0IGh4ID0gaG9sZS54O1xuICBjb25zdCBoeSA9IGhvbGUueTtcbiAgbGV0IHF4ID0gLUluZmluaXR5O1xuICBsZXQgbTtcblxuICBkbyB7XG4gICAgaWYgKGh5IDw9IHAueSAmJiBoeSA+PSBwLm5leHQueSAmJiBwLm5leHQueSAhPT0gcC55KSB7XG4gICAgICBjb25zdCB4ID0gcC54ICsgKGh5IC0gcC55KSAqIChwLm5leHQueCAtIHAueCkgLyAocC5uZXh0LnkgLSBwLnkpO1xuXG4gICAgICBpZiAoeCA8PSBoeCAmJiB4ID4gcXgpIHtcbiAgICAgICAgcXggPSB4O1xuXG4gICAgICAgIGlmICh4ID09PSBoeCkge1xuICAgICAgICAgIGlmIChoeSA9PT0gcC55KSByZXR1cm4gcDtcbiAgICAgICAgICBpZiAoaHkgPT09IHAubmV4dC55KSByZXR1cm4gcC5uZXh0O1xuICAgICAgICB9XG5cbiAgICAgICAgbSA9IHAueCA8IHAubmV4dC54ID8gcCA6IHAubmV4dDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBwID0gcC5uZXh0O1xuICB9IHdoaWxlIChwICE9PSBvdXRlck5vZGUpO1xuXG4gIGlmICghbSkgcmV0dXJuIG51bGw7XG4gIGlmIChoeCA9PT0gcXgpIHJldHVybiBtO1xuICBjb25zdCBzdG9wID0gbTtcbiAgY29uc3QgbXggPSBtLng7XG4gIGNvbnN0IG15ID0gbS55O1xuICBsZXQgdGFuTWluID0gSW5maW5pdHk7XG4gIGxldCB0YW47XG4gIHAgPSBtO1xuXG4gIGRvIHtcbiAgICBpZiAoaHggPj0gcC54ICYmIHAueCA+PSBteCAmJiBoeCAhPT0gcC54ICYmIHBvaW50SW5UcmlhbmdsZShoeSA8IG15ID8gaHggOiBxeCwgaHksIG14LCBteSwgaHkgPCBteSA/IHF4IDogaHgsIGh5LCBwLngsIHAueSkpIHtcbiAgICAgIHRhbiA9IE1hdGguYWJzKGh5IC0gcC55KSAvIChoeCAtIHAueCk7XG5cbiAgICAgIGlmIChsb2NhbGx5SW5zaWRlKHAsIGhvbGUpICYmICh0YW4gPCB0YW5NaW4gfHwgdGFuID09PSB0YW5NaW4gJiYgKHAueCA+IG0ueCB8fCBwLnggPT09IG0ueCAmJiBzZWN0b3JDb250YWluc1NlY3RvcihtLCBwKSkpKSB7XG4gICAgICAgIG0gPSBwO1xuICAgICAgICB0YW5NaW4gPSB0YW47XG4gICAgICB9XG4gICAgfVxuXG4gICAgcCA9IHAubmV4dDtcbiAgfSB3aGlsZSAocCAhPT0gc3RvcCk7XG5cbiAgcmV0dXJuIG07XG59XG5cbmZ1bmN0aW9uIHNlY3RvckNvbnRhaW5zU2VjdG9yKG0sIHApIHtcbiAgcmV0dXJuIGFyZWEobS5wcmV2LCBtLCBwLnByZXYpIDwgMCAmJiBhcmVhKHAubmV4dCwgbSwgbS5uZXh0KSA8IDA7XG59XG5cbmZ1bmN0aW9uIGluZGV4Q3VydmUoc3RhcnQsIG1pblgsIG1pblksIGludlNpemUpIHtcbiAgbGV0IHAgPSBzdGFydDtcblxuICBkbyB7XG4gICAgaWYgKHAueiA9PT0gbnVsbCkgcC56ID0gek9yZGVyKHAueCwgcC55LCBtaW5YLCBtaW5ZLCBpbnZTaXplKTtcbiAgICBwLnByZXZaID0gcC5wcmV2O1xuICAgIHAubmV4dFogPSBwLm5leHQ7XG4gICAgcCA9IHAubmV4dDtcbiAgfSB3aGlsZSAocCAhPT0gc3RhcnQpO1xuXG4gIHAucHJldloubmV4dFogPSBudWxsO1xuICBwLnByZXZaID0gbnVsbDtcbiAgc29ydExpbmtlZChwKTtcbn1cblxuZnVuY3Rpb24gc29ydExpbmtlZChsaXN0KSB7XG4gIGxldCBlO1xuICBsZXQgaTtcbiAgbGV0IGluU2l6ZSA9IDE7XG4gIGxldCBudW1NZXJnZXM7XG4gIGxldCBwO1xuICBsZXQgcFNpemU7XG4gIGxldCBxO1xuICBsZXQgcVNpemU7XG4gIGxldCB0YWlsO1xuXG4gIGRvIHtcbiAgICBwID0gbGlzdDtcbiAgICBsaXN0ID0gbnVsbDtcbiAgICB0YWlsID0gbnVsbDtcbiAgICBudW1NZXJnZXMgPSAwO1xuXG4gICAgd2hpbGUgKHApIHtcbiAgICAgIG51bU1lcmdlcysrO1xuICAgICAgcSA9IHA7XG4gICAgICBwU2l6ZSA9IDA7XG5cbiAgICAgIGZvciAoaSA9IDA7IGkgPCBpblNpemU7IGkrKykge1xuICAgICAgICBwU2l6ZSsrO1xuICAgICAgICBxID0gcS5uZXh0WjtcbiAgICAgICAgaWYgKCFxKSBicmVhaztcbiAgICAgIH1cblxuICAgICAgcVNpemUgPSBpblNpemU7XG5cbiAgICAgIHdoaWxlIChwU2l6ZSA+IDAgfHwgcVNpemUgPiAwICYmIHEpIHtcbiAgICAgICAgaWYgKHBTaXplICE9PSAwICYmIChxU2l6ZSA9PT0gMCB8fCAhcSB8fCBwLnogPD0gcS56KSkge1xuICAgICAgICAgIGUgPSBwO1xuICAgICAgICAgIHAgPSBwLm5leHRaO1xuICAgICAgICAgIHBTaXplLS07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZSA9IHE7XG4gICAgICAgICAgcSA9IHEubmV4dFo7XG4gICAgICAgICAgcVNpemUtLTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0YWlsKSB0YWlsLm5leHRaID0gZTtlbHNlIGxpc3QgPSBlO1xuICAgICAgICBlLnByZXZaID0gdGFpbDtcbiAgICAgICAgdGFpbCA9IGU7XG4gICAgICB9XG5cbiAgICAgIHAgPSBxO1xuICAgIH1cblxuICAgIHRhaWwubmV4dFogPSBudWxsO1xuICAgIGluU2l6ZSAqPSAyO1xuICB9IHdoaWxlIChudW1NZXJnZXMgPiAxKTtcblxuICByZXR1cm4gbGlzdDtcbn1cblxuZnVuY3Rpb24gek9yZGVyKHgsIHksIG1pblgsIG1pblksIGludlNpemUpIHtcbiAgeCA9IDMyNzY3ICogKHggLSBtaW5YKSAqIGludlNpemU7XG4gIHkgPSAzMjc2NyAqICh5IC0gbWluWSkgKiBpbnZTaXplO1xuICB4ID0gKHggfCB4IDw8IDgpICYgMHgwMGZmMDBmZjtcbiAgeCA9ICh4IHwgeCA8PCA0KSAmIDB4MGYwZjBmMGY7XG4gIHggPSAoeCB8IHggPDwgMikgJiAweDMzMzMzMzMzO1xuICB4ID0gKHggfCB4IDw8IDEpICYgMHg1NTU1NTU1NTtcbiAgeSA9ICh5IHwgeSA8PCA4KSAmIDB4MDBmZjAwZmY7XG4gIHkgPSAoeSB8IHkgPDwgNCkgJiAweDBmMGYwZjBmO1xuICB5ID0gKHkgfCB5IDw8IDIpICYgMHgzMzMzMzMzMztcbiAgeSA9ICh5IHwgeSA8PCAxKSAmIDB4NTU1NTU1NTU7XG4gIHJldHVybiB4IHwgeSA8PCAxO1xufVxuXG5mdW5jdGlvbiBnZXRMZWZ0bW9zdChzdGFydCkge1xuICBsZXQgcCA9IHN0YXJ0O1xuICBsZXQgbGVmdG1vc3QgPSBzdGFydDtcblxuICBkbyB7XG4gICAgaWYgKHAueCA8IGxlZnRtb3N0LnggfHwgcC54ID09PSBsZWZ0bW9zdC54ICYmIHAueSA8IGxlZnRtb3N0LnkpIGxlZnRtb3N0ID0gcDtcbiAgICBwID0gcC5uZXh0O1xuICB9IHdoaWxlIChwICE9PSBzdGFydCk7XG5cbiAgcmV0dXJuIGxlZnRtb3N0O1xufVxuXG5mdW5jdGlvbiBwb2ludEluVHJpYW5nbGUoYXgsIGF5LCBieCwgYnksIGN4LCBjeSwgcHgsIHB5KSB7XG4gIHJldHVybiAoY3ggLSBweCkgKiAoYXkgLSBweSkgLSAoYXggLSBweCkgKiAoY3kgLSBweSkgPj0gMCAmJiAoYXggLSBweCkgKiAoYnkgLSBweSkgLSAoYnggLSBweCkgKiAoYXkgLSBweSkgPj0gMCAmJiAoYnggLSBweCkgKiAoY3kgLSBweSkgLSAoY3ggLSBweCkgKiAoYnkgLSBweSkgPj0gMDtcbn1cblxuZnVuY3Rpb24gaXNWYWxpZERpYWdvbmFsKGEsIGIpIHtcbiAgcmV0dXJuIGEubmV4dC5pICE9PSBiLmkgJiYgYS5wcmV2LmkgIT09IGIuaSAmJiAhaW50ZXJzZWN0c1BvbHlnb24oYSwgYikgJiYgKGxvY2FsbHlJbnNpZGUoYSwgYikgJiYgbG9jYWxseUluc2lkZShiLCBhKSAmJiBtaWRkbGVJbnNpZGUoYSwgYikgJiYgKGFyZWEoYS5wcmV2LCBhLCBiLnByZXYpIHx8IGFyZWEoYSwgYi5wcmV2LCBiKSkgfHwgZXF1YWxzKGEsIGIpICYmIGFyZWEoYS5wcmV2LCBhLCBhLm5leHQpID4gMCAmJiBhcmVhKGIucHJldiwgYiwgYi5uZXh0KSA+IDApO1xufVxuXG5mdW5jdGlvbiBhcmVhKHAsIHEsIHIpIHtcbiAgcmV0dXJuIChxLnkgLSBwLnkpICogKHIueCAtIHEueCkgLSAocS54IC0gcC54KSAqIChyLnkgLSBxLnkpO1xufVxuXG5mdW5jdGlvbiBlcXVhbHMocDEsIHAyKSB7XG4gIHJldHVybiBwMS54ID09PSBwMi54ICYmIHAxLnkgPT09IHAyLnk7XG59XG5cbmZ1bmN0aW9uIGludGVyc2VjdHMocDEsIHExLCBwMiwgcTIpIHtcbiAgY29uc3QgbzEgPSBzaWduKGFyZWEocDEsIHExLCBwMikpO1xuICBjb25zdCBvMiA9IHNpZ24oYXJlYShwMSwgcTEsIHEyKSk7XG4gIGNvbnN0IG8zID0gc2lnbihhcmVhKHAyLCBxMiwgcDEpKTtcbiAgY29uc3QgbzQgPSBzaWduKGFyZWEocDIsIHEyLCBxMSkpO1xuICBpZiAobzEgIT09IG8yICYmIG8zICE9PSBvNCkgcmV0dXJuIHRydWU7XG4gIGlmIChvMSA9PT0gMCAmJiBvblNlZ21lbnQocDEsIHAyLCBxMSkpIHJldHVybiB0cnVlO1xuICBpZiAobzIgPT09IDAgJiYgb25TZWdtZW50KHAxLCBxMiwgcTEpKSByZXR1cm4gdHJ1ZTtcbiAgaWYgKG8zID09PSAwICYmIG9uU2VnbWVudChwMiwgcDEsIHEyKSkgcmV0dXJuIHRydWU7XG4gIGlmIChvNCA9PT0gMCAmJiBvblNlZ21lbnQocDIsIHExLCBxMikpIHJldHVybiB0cnVlO1xuICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIG9uU2VnbWVudChwLCBxLCByKSB7XG4gIHJldHVybiBxLnggPD0gTWF0aC5tYXgocC54LCByLngpICYmIHEueCA+PSBNYXRoLm1pbihwLngsIHIueCkgJiYgcS55IDw9IE1hdGgubWF4KHAueSwgci55KSAmJiBxLnkgPj0gTWF0aC5taW4ocC55LCByLnkpO1xufVxuXG5mdW5jdGlvbiBzaWduKG51bSkge1xuICByZXR1cm4gbnVtID4gMCA/IDEgOiBudW0gPCAwID8gLTEgOiAwO1xufVxuXG5mdW5jdGlvbiBpbnRlcnNlY3RzUG9seWdvbihhLCBiKSB7XG4gIGxldCBwID0gYTtcblxuICBkbyB7XG4gICAgaWYgKHAuaSAhPT0gYS5pICYmIHAubmV4dC5pICE9PSBhLmkgJiYgcC5pICE9PSBiLmkgJiYgcC5uZXh0LmkgIT09IGIuaSAmJiBpbnRlcnNlY3RzKHAsIHAubmV4dCwgYSwgYikpIHJldHVybiB0cnVlO1xuICAgIHAgPSBwLm5leHQ7XG4gIH0gd2hpbGUgKHAgIT09IGEpO1xuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gbG9jYWxseUluc2lkZShhLCBiKSB7XG4gIHJldHVybiBhcmVhKGEucHJldiwgYSwgYS5uZXh0KSA8IDAgPyBhcmVhKGEsIGIsIGEubmV4dCkgPj0gMCAmJiBhcmVhKGEsIGEucHJldiwgYikgPj0gMCA6IGFyZWEoYSwgYiwgYS5wcmV2KSA8IDAgfHwgYXJlYShhLCBhLm5leHQsIGIpIDwgMDtcbn1cblxuZnVuY3Rpb24gbWlkZGxlSW5zaWRlKGEsIGIpIHtcbiAgbGV0IHAgPSBhO1xuICBsZXQgaW5zaWRlID0gZmFsc2U7XG4gIGNvbnN0IHB4ID0gKGEueCArIGIueCkgLyAyO1xuICBjb25zdCBweSA9IChhLnkgKyBiLnkpIC8gMjtcblxuICBkbyB7XG4gICAgaWYgKHAueSA+IHB5ICE9PSBwLm5leHQueSA+IHB5ICYmIHAubmV4dC55ICE9PSBwLnkgJiYgcHggPCAocC5uZXh0LnggLSBwLngpICogKHB5IC0gcC55KSAvIChwLm5leHQueSAtIHAueSkgKyBwLngpIGluc2lkZSA9ICFpbnNpZGU7XG4gICAgcCA9IHAubmV4dDtcbiAgfSB3aGlsZSAocCAhPT0gYSk7XG5cbiAgcmV0dXJuIGluc2lkZTtcbn1cblxuZnVuY3Rpb24gc3BsaXRQb2x5Z29uKGEsIGIpIHtcbiAgY29uc3QgYTIgPSBuZXcgTm9kZShhLmksIGEueCwgYS55KTtcbiAgY29uc3QgYjIgPSBuZXcgTm9kZShiLmksIGIueCwgYi55KTtcbiAgY29uc3QgYW4gPSBhLm5leHQ7XG4gIGNvbnN0IGJwID0gYi5wcmV2O1xuICBhLm5leHQgPSBiO1xuICBiLnByZXYgPSBhO1xuICBhMi5uZXh0ID0gYW47XG4gIGFuLnByZXYgPSBhMjtcbiAgYjIubmV4dCA9IGEyO1xuICBhMi5wcmV2ID0gYjI7XG4gIGJwLm5leHQgPSBiMjtcbiAgYjIucHJldiA9IGJwO1xuICByZXR1cm4gYjI7XG59XG5cbmZ1bmN0aW9uIGluc2VydE5vZGUoaSwgeCwgeSwgbGFzdCkge1xuICBjb25zdCBwID0gbmV3IE5vZGUoaSwgeCwgeSk7XG5cbiAgaWYgKCFsYXN0KSB7XG4gICAgcC5wcmV2ID0gcDtcbiAgICBwLm5leHQgPSBwO1xuICB9IGVsc2Uge1xuICAgIHAubmV4dCA9IGxhc3QubmV4dDtcbiAgICBwLnByZXYgPSBsYXN0O1xuICAgIGxhc3QubmV4dC5wcmV2ID0gcDtcbiAgICBsYXN0Lm5leHQgPSBwO1xuICB9XG5cbiAgcmV0dXJuIHA7XG59XG5cbmZ1bmN0aW9uIHJlbW92ZU5vZGUocCkge1xuICBwLm5leHQucHJldiA9IHAucHJldjtcbiAgcC5wcmV2Lm5leHQgPSBwLm5leHQ7XG4gIGlmIChwLnByZXZaKSBwLnByZXZaLm5leHRaID0gcC5uZXh0WjtcbiAgaWYgKHAubmV4dFopIHAubmV4dFoucHJldlogPSBwLnByZXZaO1xufVxuXG5mdW5jdGlvbiBOb2RlKGksIHgsIHkpIHtcbiAgdGhpcy5pID0gaTtcbiAgdGhpcy54ID0geDtcbiAgdGhpcy55ID0geTtcbiAgdGhpcy5wcmV2ID0gbnVsbDtcbiAgdGhpcy5uZXh0ID0gbnVsbDtcbiAgdGhpcy56ID0gbnVsbDtcbiAgdGhpcy5wcmV2WiA9IG51bGw7XG4gIHRoaXMubmV4dFogPSBudWxsO1xuICB0aGlzLnN0ZWluZXIgPSBmYWxzZTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWVhcmN1dC5qcy5tYXAiLCJpbXBvcnQgeyBwdXNoLCBjb3B5LCBnZXRQb2ludEF0SW5kZXggfSBmcm9tICcuL3V0aWxzJztcbmV4cG9ydCBmdW5jdGlvbiBjbGlwUG9seWxpbmUocG9zaXRpb25zLCBiYm94LCBvcHRpb25zKSB7XG4gIGNvbnN0IHtcbiAgICBzaXplID0gMixcbiAgICBzdGFydEluZGV4ID0gMCxcbiAgICBlbmRJbmRleCA9IHBvc2l0aW9ucy5sZW5ndGhcbiAgfSA9IG9wdGlvbnMgfHwge307XG4gIGNvbnN0IG51bVBvaW50cyA9IChlbmRJbmRleCAtIHN0YXJ0SW5kZXgpIC8gc2l6ZTtcbiAgY29uc3QgcmVzdWx0ID0gW107XG4gIGxldCBwYXJ0ID0gW107XG4gIGxldCBhO1xuICBsZXQgYjtcbiAgbGV0IGNvZGVBID0gLTE7XG4gIGxldCBjb2RlQjtcbiAgbGV0IGxhc3RDb2RlO1xuXG4gIGZvciAobGV0IGkgPSAxOyBpIDwgbnVtUG9pbnRzOyBpKyspIHtcbiAgICBhID0gZ2V0UG9pbnRBdEluZGV4KHBvc2l0aW9ucywgaSAtIDEsIHNpemUsIHN0YXJ0SW5kZXgsIGEpO1xuICAgIGIgPSBnZXRQb2ludEF0SW5kZXgocG9zaXRpb25zLCBpLCBzaXplLCBzdGFydEluZGV4LCBiKTtcblxuICAgIGlmIChjb2RlQSA8IDApIHtcbiAgICAgIGNvZGVBID0gYml0Q29kZShhLCBiYm94KTtcbiAgICB9XG5cbiAgICBjb2RlQiA9IGxhc3RDb2RlID0gYml0Q29kZShiLCBiYm94KTtcblxuICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICBpZiAoIShjb2RlQSB8IGNvZGVCKSkge1xuICAgICAgICBwdXNoKHBhcnQsIGEpO1xuXG4gICAgICAgIGlmIChjb2RlQiAhPT0gbGFzdENvZGUpIHtcbiAgICAgICAgICBwdXNoKHBhcnQsIGIpO1xuXG4gICAgICAgICAgaWYgKGkgPCBudW1Qb2ludHMgLSAxKSB7XG4gICAgICAgICAgICByZXN1bHQucHVzaChwYXJ0KTtcbiAgICAgICAgICAgIHBhcnQgPSBbXTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoaSA9PT0gbnVtUG9pbnRzIC0gMSkge1xuICAgICAgICAgIHB1c2gocGFydCwgYik7XG4gICAgICAgIH1cblxuICAgICAgICBicmVhaztcbiAgICAgIH0gZWxzZSBpZiAoY29kZUEgJiBjb2RlQikge1xuICAgICAgICBicmVhaztcbiAgICAgIH0gZWxzZSBpZiAoY29kZUEpIHtcbiAgICAgICAgaW50ZXJzZWN0KGEsIGIsIGNvZGVBLCBiYm94LCBhKTtcbiAgICAgICAgY29kZUEgPSBiaXRDb2RlKGEsIGJib3gpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaW50ZXJzZWN0KGEsIGIsIGNvZGVCLCBiYm94LCBiKTtcbiAgICAgICAgY29kZUIgPSBiaXRDb2RlKGIsIGJib3gpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGNvZGVBID0gbGFzdENvZGU7XG4gIH1cblxuICBpZiAocGFydC5sZW5ndGgpIHJlc3VsdC5wdXNoKHBhcnQpO1xuICByZXR1cm4gcmVzdWx0O1xufVxuZXhwb3J0IGZ1bmN0aW9uIGNsaXBQb2x5Z29uKHBvc2l0aW9ucywgYmJveCwgb3B0aW9ucykge1xuICBjb25zdCB7XG4gICAgc2l6ZSA9IDIsXG4gICAgZW5kSW5kZXggPSBwb3NpdGlvbnMubGVuZ3RoXG4gIH0gPSBvcHRpb25zIHx8IHt9O1xuICBsZXQge1xuICAgIHN0YXJ0SW5kZXggPSAwXG4gIH0gPSBvcHRpb25zIHx8IHt9O1xuICBsZXQgbnVtUG9pbnRzID0gKGVuZEluZGV4IC0gc3RhcnRJbmRleCkgLyBzaXplO1xuICBsZXQgcmVzdWx0O1xuICBsZXQgcDtcbiAgbGV0IHByZXY7XG4gIGxldCBpbnNpZGU7XG4gIGxldCBwcmV2SW5zaWRlO1xuXG4gIGZvciAobGV0IGVkZ2UgPSAxOyBlZGdlIDw9IDg7IGVkZ2UgKj0gMikge1xuICAgIHJlc3VsdCA9IFtdO1xuICAgIHByZXYgPSBnZXRQb2ludEF0SW5kZXgocG9zaXRpb25zLCBudW1Qb2ludHMgLSAxLCBzaXplLCBzdGFydEluZGV4LCBwcmV2KTtcbiAgICBwcmV2SW5zaWRlID0gIShiaXRDb2RlKHByZXYsIGJib3gpICYgZWRnZSk7XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG51bVBvaW50czsgaSsrKSB7XG4gICAgICBwID0gZ2V0UG9pbnRBdEluZGV4KHBvc2l0aW9ucywgaSwgc2l6ZSwgc3RhcnRJbmRleCwgcCk7XG4gICAgICBpbnNpZGUgPSAhKGJpdENvZGUocCwgYmJveCkgJiBlZGdlKTtcbiAgICAgIGlmIChpbnNpZGUgIT09IHByZXZJbnNpZGUpIHB1c2gocmVzdWx0LCBpbnRlcnNlY3QocHJldiwgcCwgZWRnZSwgYmJveCkpO1xuICAgICAgaWYgKGluc2lkZSkgcHVzaChyZXN1bHQsIHApO1xuICAgICAgY29weShwcmV2LCBwKTtcbiAgICAgIHByZXZJbnNpZGUgPSBpbnNpZGU7XG4gICAgfVxuXG4gICAgcG9zaXRpb25zID0gcmVzdWx0O1xuICAgIHN0YXJ0SW5kZXggPSAwO1xuICAgIG51bVBvaW50cyA9IHJlc3VsdC5sZW5ndGggLyBzaXplO1xuICAgIGlmICghbnVtUG9pbnRzKSBicmVhaztcbiAgfVxuXG4gIHJldHVybiByZXN1bHQ7XG59XG5leHBvcnQgZnVuY3Rpb24gaW50ZXJzZWN0KGEsIGIsIGVkZ2UsIGJib3gsIG91dCA9IFtdKSB7XG4gIGxldCB0O1xuICBsZXQgc25hcDtcblxuICBpZiAoZWRnZSAmIDgpIHtcbiAgICB0ID0gKGJib3hbM10gLSBhWzFdKSAvIChiWzFdIC0gYVsxXSk7XG4gICAgc25hcCA9IDM7XG4gIH0gZWxzZSBpZiAoZWRnZSAmIDQpIHtcbiAgICB0ID0gKGJib3hbMV0gLSBhWzFdKSAvIChiWzFdIC0gYVsxXSk7XG4gICAgc25hcCA9IDE7XG4gIH0gZWxzZSBpZiAoZWRnZSAmIDIpIHtcbiAgICB0ID0gKGJib3hbMl0gLSBhWzBdKSAvIChiWzBdIC0gYVswXSk7XG4gICAgc25hcCA9IDI7XG4gIH0gZWxzZSBpZiAoZWRnZSAmIDEpIHtcbiAgICB0ID0gKGJib3hbMF0gLSBhWzBdKSAvIChiWzBdIC0gYVswXSk7XG4gICAgc25hcCA9IDA7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBmb3IgKGxldCBpID0gMDsgaSA8IGEubGVuZ3RoOyBpKyspIHtcbiAgICBvdXRbaV0gPSAoc25hcCAmIDEpID09PSBpID8gYmJveFtzbmFwXSA6IHQgKiAoYltpXSAtIGFbaV0pICsgYVtpXTtcbiAgfVxuXG4gIHJldHVybiBvdXQ7XG59XG5leHBvcnQgZnVuY3Rpb24gYml0Q29kZShwLCBiYm94KSB7XG4gIGxldCBjb2RlID0gMDtcbiAgaWYgKHBbMF0gPCBiYm94WzBdKSBjb2RlIHw9IDE7ZWxzZSBpZiAocFswXSA+IGJib3hbMl0pIGNvZGUgfD0gMjtcbiAgaWYgKHBbMV0gPCBiYm94WzFdKSBjb2RlIHw9IDQ7ZWxzZSBpZiAocFsxXSA+IGJib3hbM10pIGNvZGUgfD0gODtcbiAgcmV0dXJuIGNvZGU7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1saW5lY2xpcC5qcy5tYXAiLCJleHBvcnQgZnVuY3Rpb24gcHVzaCh0YXJnZXQsIHNvdXJjZSkge1xuICBjb25zdCBzaXplID0gc291cmNlLmxlbmd0aDtcbiAgY29uc3Qgc3RhcnRJbmRleCA9IHRhcmdldC5sZW5ndGg7XG5cbiAgaWYgKHN0YXJ0SW5kZXggPiAwKSB7XG4gICAgbGV0IGlzRHVwbGljYXRlID0gdHJ1ZTtcblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc2l6ZTsgaSsrKSB7XG4gICAgICBpZiAodGFyZ2V0W3N0YXJ0SW5kZXggLSBzaXplICsgaV0gIT09IHNvdXJjZVtpXSkge1xuICAgICAgICBpc0R1cGxpY2F0ZSA9IGZhbHNlO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoaXNEdXBsaWNhdGUpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cblxuICBmb3IgKGxldCBpID0gMDsgaSA8IHNpemU7IGkrKykge1xuICAgIHRhcmdldFtzdGFydEluZGV4ICsgaV0gPSBzb3VyY2VbaV07XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBjb3B5KHRhcmdldCwgc291cmNlKSB7XG4gIGNvbnN0IHNpemUgPSBzb3VyY2UubGVuZ3RoO1xuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgc2l6ZTsgaSsrKSB7XG4gICAgdGFyZ2V0W2ldID0gc291cmNlW2ldO1xuICB9XG59XG5leHBvcnQgZnVuY3Rpb24gZ2V0UG9pbnRBdEluZGV4KHBvc2l0aW9ucywgaW5kZXgsIHNpemUsIG9mZnNldCwgb3V0ID0gW10pIHtcbiAgY29uc3Qgc3RhcnRJID0gb2Zmc2V0ICsgaW5kZXggKiBzaXplO1xuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgc2l6ZTsgaSsrKSB7XG4gICAgb3V0W2ldID0gcG9zaXRpb25zW3N0YXJ0SSArIGldO1xuICB9XG5cbiAgcmV0dXJuIG91dDtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXV0aWxzLmpzLm1hcCIsImltcG9ydCB7IGJpdENvZGUsIGludGVyc2VjdCB9IGZyb20gJy4vbGluZWNsaXAnO1xuaW1wb3J0IHsgZ2V0UG9pbnRBdEluZGV4LCBjb3B5LCBwdXNoIH0gZnJvbSAnLi91dGlscyc7XG5leHBvcnQgZnVuY3Rpb24gY3V0UG9seWxpbmVCeUdyaWQocG9zaXRpb25zLCBvcHRpb25zKSB7XG4gIGNvbnN0IHtcbiAgICBzaXplID0gMixcbiAgICBicm9rZW4gPSBmYWxzZSxcbiAgICBncmlkUmVzb2x1dGlvbiA9IDEwLFxuICAgIGdyaWRPZmZzZXQgPSBbMCwgMF0sXG4gICAgc3RhcnRJbmRleCA9IDAsXG4gICAgZW5kSW5kZXggPSBwb3NpdGlvbnMubGVuZ3RoXG4gIH0gPSBvcHRpb25zIHx8IHt9O1xuICBjb25zdCBudW1Qb2ludHMgPSAoZW5kSW5kZXggLSBzdGFydEluZGV4KSAvIHNpemU7XG4gIGxldCBwYXJ0ID0gW107XG4gIGNvbnN0IHJlc3VsdCA9IFtwYXJ0XTtcbiAgY29uc3QgYSA9IGdldFBvaW50QXRJbmRleChwb3NpdGlvbnMsIDAsIHNpemUsIHN0YXJ0SW5kZXgpO1xuICBsZXQgYjtcbiAgbGV0IGNvZGVCO1xuICBjb25zdCBjZWxsID0gZ2V0R3JpZENlbGwoYSwgZ3JpZFJlc29sdXRpb24sIGdyaWRPZmZzZXQsIFtdKTtcbiAgY29uc3Qgc2NyYXRjaFBvaW50ID0gW107XG4gIHB1c2gocGFydCwgYSk7XG5cbiAgZm9yIChsZXQgaSA9IDE7IGkgPCBudW1Qb2ludHM7IGkrKykge1xuICAgIGIgPSBnZXRQb2ludEF0SW5kZXgocG9zaXRpb25zLCBpLCBzaXplLCBzdGFydEluZGV4LCBiKTtcbiAgICBjb2RlQiA9IGJpdENvZGUoYiwgY2VsbCk7XG5cbiAgICB3aGlsZSAoY29kZUIpIHtcbiAgICAgIGludGVyc2VjdChhLCBiLCBjb2RlQiwgY2VsbCwgc2NyYXRjaFBvaW50KTtcbiAgICAgIGNvbnN0IGNvZGVBbHQgPSBiaXRDb2RlKHNjcmF0Y2hQb2ludCwgY2VsbCk7XG5cbiAgICAgIGlmIChjb2RlQWx0KSB7XG4gICAgICAgIGludGVyc2VjdChhLCBzY3JhdGNoUG9pbnQsIGNvZGVBbHQsIGNlbGwsIHNjcmF0Y2hQb2ludCk7XG4gICAgICAgIGNvZGVCID0gY29kZUFsdDtcbiAgICAgIH1cblxuICAgICAgcHVzaChwYXJ0LCBzY3JhdGNoUG9pbnQpO1xuICAgICAgY29weShhLCBzY3JhdGNoUG9pbnQpO1xuICAgICAgbW92ZVRvTmVpZ2hib3JDZWxsKGNlbGwsIGdyaWRSZXNvbHV0aW9uLCBjb2RlQik7XG5cbiAgICAgIGlmIChicm9rZW4gJiYgcGFydC5sZW5ndGggPiBzaXplKSB7XG4gICAgICAgIHBhcnQgPSBbXTtcbiAgICAgICAgcmVzdWx0LnB1c2gocGFydCk7XG4gICAgICAgIHB1c2gocGFydCwgYSk7XG4gICAgICB9XG5cbiAgICAgIGNvZGVCID0gYml0Q29kZShiLCBjZWxsKTtcbiAgICB9XG5cbiAgICBwdXNoKHBhcnQsIGIpO1xuICAgIGNvcHkoYSwgYik7XG4gIH1cblxuICByZXR1cm4gYnJva2VuID8gcmVzdWx0IDogcmVzdWx0WzBdO1xufVxuY29uc3QgVFlQRV9JTlNJREUgPSAwO1xuY29uc3QgVFlQRV9CT1JERVIgPSAxO1xuXG5mdW5jdGlvbiBjb25jYXRJblBsYWNlKGFycjEsIGFycjIpIHtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBhcnIyLmxlbmd0aDsgaSsrKSB7XG4gICAgYXJyMS5wdXNoKGFycjJbaV0pO1xuICB9XG5cbiAgcmV0dXJuIGFycjE7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjdXRQb2x5Z29uQnlHcmlkKHBvc2l0aW9ucywgaG9sZUluZGljZXMgPSBudWxsLCBvcHRpb25zKSB7XG4gIGlmICghcG9zaXRpb25zLmxlbmd0aCkge1xuICAgIHJldHVybiBbXTtcbiAgfVxuXG4gIGNvbnN0IHtcbiAgICBzaXplID0gMixcbiAgICBncmlkUmVzb2x1dGlvbiA9IDEwLFxuICAgIGdyaWRPZmZzZXQgPSBbMCwgMF0sXG4gICAgZWRnZVR5cGVzID0gZmFsc2VcbiAgfSA9IG9wdGlvbnMgfHwge307XG4gIGNvbnN0IHJlc3VsdCA9IFtdO1xuICBjb25zdCBxdWV1ZSA9IFt7XG4gICAgcG9zOiBwb3NpdGlvbnMsXG4gICAgdHlwZXM6IGVkZ2VUeXBlcyA/IG5ldyBBcnJheShwb3NpdGlvbnMubGVuZ3RoIC8gc2l6ZSkuZmlsbChUWVBFX0JPUkRFUikgOiBudWxsLFxuICAgIGhvbGVzOiBob2xlSW5kaWNlcyB8fCBbXVxuICB9XTtcbiAgY29uc3QgYmJveCA9IFtbXSwgW11dO1xuICBsZXQgY2VsbCA9IFtdO1xuXG4gIHdoaWxlIChxdWV1ZS5sZW5ndGgpIHtcbiAgICBjb25zdCB7XG4gICAgICBwb3MsXG4gICAgICB0eXBlcyxcbiAgICAgIGhvbGVzXG4gICAgfSA9IHF1ZXVlLnNoaWZ0KCk7XG4gICAgZ2V0Qm91bmRpbmdCb3gocG9zLCBzaXplLCBob2xlc1swXSB8fCBwb3MubGVuZ3RoLCBiYm94KTtcbiAgICBjZWxsID0gZ2V0R3JpZENlbGwoYmJveFswXSwgZ3JpZFJlc29sdXRpb24sIGdyaWRPZmZzZXQsIGNlbGwpO1xuICAgIGNvbnN0IGNvZGUgPSBiaXRDb2RlKGJib3hbMV0sIGNlbGwpO1xuXG4gICAgaWYgKGNvZGUpIHtcbiAgICAgIGxldCBwYXJ0cyA9IGJpc2VjdFBvbHlnb24ocG9zLCB0eXBlcywgc2l6ZSwgMCwgaG9sZXNbMF0gfHwgcG9zLmxlbmd0aCwgY2VsbCwgY29kZSk7XG4gICAgICBjb25zdCBwb2x5Z29uTG93ID0ge1xuICAgICAgICBwb3M6IHBhcnRzWzBdLnBvcyxcbiAgICAgICAgdHlwZXM6IHBhcnRzWzBdLnR5cGVzLFxuICAgICAgICBob2xlczogW11cbiAgICAgIH07XG4gICAgICBjb25zdCBwb2x5Z29uSGlnaCA9IHtcbiAgICAgICAgcG9zOiBwYXJ0c1sxXS5wb3MsXG4gICAgICAgIHR5cGVzOiBwYXJ0c1sxXS50eXBlcyxcbiAgICAgICAgaG9sZXM6IFtdXG4gICAgICB9O1xuICAgICAgcXVldWUucHVzaChwb2x5Z29uTG93LCBwb2x5Z29uSGlnaCk7XG5cbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgaG9sZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgcGFydHMgPSBiaXNlY3RQb2x5Z29uKHBvcywgdHlwZXMsIHNpemUsIGhvbGVzW2ldLCBob2xlc1tpICsgMV0gfHwgcG9zLmxlbmd0aCwgY2VsbCwgY29kZSk7XG5cbiAgICAgICAgaWYgKHBhcnRzWzBdKSB7XG4gICAgICAgICAgcG9seWdvbkxvdy5ob2xlcy5wdXNoKHBvbHlnb25Mb3cucG9zLmxlbmd0aCk7XG4gICAgICAgICAgcG9seWdvbkxvdy5wb3MgPSBjb25jYXRJblBsYWNlKHBvbHlnb25Mb3cucG9zLCBwYXJ0c1swXS5wb3MpO1xuXG4gICAgICAgICAgaWYgKGVkZ2VUeXBlcykge1xuICAgICAgICAgICAgcG9seWdvbkxvdy50eXBlcyA9IGNvbmNhdEluUGxhY2UocG9seWdvbkxvdy50eXBlcywgcGFydHNbMF0udHlwZXMpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChwYXJ0c1sxXSkge1xuICAgICAgICAgIHBvbHlnb25IaWdoLmhvbGVzLnB1c2gocG9seWdvbkhpZ2gucG9zLmxlbmd0aCk7XG4gICAgICAgICAgcG9seWdvbkhpZ2gucG9zID0gY29uY2F0SW5QbGFjZShwb2x5Z29uSGlnaC5wb3MsIHBhcnRzWzFdLnBvcyk7XG5cbiAgICAgICAgICBpZiAoZWRnZVR5cGVzKSB7XG4gICAgICAgICAgICBwb2x5Z29uSGlnaC50eXBlcyA9IGNvbmNhdEluUGxhY2UocG9seWdvbkhpZ2gudHlwZXMsIHBhcnRzWzFdLnR5cGVzKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgcG9seWdvbiA9IHtcbiAgICAgICAgcG9zaXRpb25zOiBwb3NcbiAgICAgIH07XG5cbiAgICAgIGlmIChlZGdlVHlwZXMpIHtcbiAgICAgICAgcG9seWdvbi5lZGdlVHlwZXMgPSB0eXBlcztcbiAgICAgIH1cblxuICAgICAgaWYgKGhvbGVzLmxlbmd0aCkge1xuICAgICAgICBwb2x5Z29uLmhvbGVJbmRpY2VzID0gaG9sZXM7XG4gICAgICB9XG5cbiAgICAgIHJlc3VsdC5wdXNoKHBvbHlnb24pO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiByZXN1bHQ7XG59XG5cbmZ1bmN0aW9uIGJpc2VjdFBvbHlnb24ocG9zaXRpb25zLCBlZGdlVHlwZXMsIHNpemUsIHN0YXJ0SW5kZXgsIGVuZEluZGV4LCBiYm94LCBlZGdlKSB7XG4gIGNvbnN0IG51bVBvaW50cyA9IChlbmRJbmRleCAtIHN0YXJ0SW5kZXgpIC8gc2l6ZTtcbiAgY29uc3QgcmVzdWx0TG93ID0gW107XG4gIGNvbnN0IHJlc3VsdEhpZ2ggPSBbXTtcbiAgY29uc3QgdHlwZXNMb3cgPSBbXTtcbiAgY29uc3QgdHlwZXNIaWdoID0gW107XG4gIGNvbnN0IHNjcmF0Y2hQb2ludCA9IFtdO1xuICBsZXQgcDtcbiAgbGV0IHNpZGU7XG4gIGxldCB0eXBlO1xuICBjb25zdCBwcmV2ID0gZ2V0UG9pbnRBdEluZGV4KHBvc2l0aW9ucywgbnVtUG9pbnRzIC0gMSwgc2l6ZSwgc3RhcnRJbmRleCk7XG4gIGxldCBwcmV2U2lkZSA9IE1hdGguc2lnbihlZGdlICYgOCA/IHByZXZbMV0gLSBiYm94WzNdIDogcHJldlswXSAtIGJib3hbMl0pO1xuICBsZXQgcHJldlR5cGUgPSBlZGdlVHlwZXMgJiYgZWRnZVR5cGVzW251bVBvaW50cyAtIDFdO1xuICBsZXQgbG93UG9pbnRDb3VudCA9IDA7XG4gIGxldCBoaWdoUG9pbnRDb3VudCA9IDA7XG5cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBudW1Qb2ludHM7IGkrKykge1xuICAgIHAgPSBnZXRQb2ludEF0SW5kZXgocG9zaXRpb25zLCBpLCBzaXplLCBzdGFydEluZGV4LCBwKTtcbiAgICBzaWRlID0gTWF0aC5zaWduKGVkZ2UgJiA4ID8gcFsxXSAtIGJib3hbM10gOiBwWzBdIC0gYmJveFsyXSk7XG4gICAgdHlwZSA9IGVkZ2VUeXBlcyAmJiBlZGdlVHlwZXNbc3RhcnRJbmRleCAvIHNpemUgKyBpXTtcblxuICAgIGlmIChzaWRlICYmIHByZXZTaWRlICYmIHByZXZTaWRlICE9PSBzaWRlKSB7XG4gICAgICBpbnRlcnNlY3QocHJldiwgcCwgZWRnZSwgYmJveCwgc2NyYXRjaFBvaW50KTtcbiAgICAgIHB1c2gocmVzdWx0TG93LCBzY3JhdGNoUG9pbnQpICYmIHR5cGVzTG93LnB1c2gocHJldlR5cGUpO1xuICAgICAgcHVzaChyZXN1bHRIaWdoLCBzY3JhdGNoUG9pbnQpICYmIHR5cGVzSGlnaC5wdXNoKHByZXZUeXBlKTtcbiAgICB9XG5cbiAgICBpZiAoc2lkZSA8PSAwKSB7XG4gICAgICBwdXNoKHJlc3VsdExvdywgcCkgJiYgdHlwZXNMb3cucHVzaCh0eXBlKTtcbiAgICAgIGxvd1BvaW50Q291bnQgLT0gc2lkZTtcbiAgICB9IGVsc2UgaWYgKHR5cGVzTG93Lmxlbmd0aCkge1xuICAgICAgdHlwZXNMb3dbdHlwZXNMb3cubGVuZ3RoIC0gMV0gPSBUWVBFX0lOU0lERTtcbiAgICB9XG5cbiAgICBpZiAoc2lkZSA+PSAwKSB7XG4gICAgICBwdXNoKHJlc3VsdEhpZ2gsIHApICYmIHR5cGVzSGlnaC5wdXNoKHR5cGUpO1xuICAgICAgaGlnaFBvaW50Q291bnQgKz0gc2lkZTtcbiAgICB9IGVsc2UgaWYgKHR5cGVzSGlnaC5sZW5ndGgpIHtcbiAgICAgIHR5cGVzSGlnaFt0eXBlc0hpZ2gubGVuZ3RoIC0gMV0gPSBUWVBFX0lOU0lERTtcbiAgICB9XG5cbiAgICBjb3B5KHByZXYsIHApO1xuICAgIHByZXZTaWRlID0gc2lkZTtcbiAgICBwcmV2VHlwZSA9IHR5cGU7XG4gIH1cblxuICByZXR1cm4gW2xvd1BvaW50Q291bnQgPyB7XG4gICAgcG9zOiByZXN1bHRMb3csXG4gICAgdHlwZXM6IGVkZ2VUeXBlcyAmJiB0eXBlc0xvd1xuICB9IDogbnVsbCwgaGlnaFBvaW50Q291bnQgPyB7XG4gICAgcG9zOiByZXN1bHRIaWdoLFxuICAgIHR5cGVzOiBlZGdlVHlwZXMgJiYgdHlwZXNIaWdoXG4gIH0gOiBudWxsXTtcbn1cblxuZnVuY3Rpb24gZ2V0R3JpZENlbGwocCwgZ3JpZFJlc29sdXRpb24sIGdyaWRPZmZzZXQsIG91dCkge1xuICBjb25zdCBsZWZ0ID0gTWF0aC5mbG9vcigocFswXSAtIGdyaWRPZmZzZXRbMF0pIC8gZ3JpZFJlc29sdXRpb24pICogZ3JpZFJlc29sdXRpb24gKyBncmlkT2Zmc2V0WzBdO1xuICBjb25zdCBib3R0b20gPSBNYXRoLmZsb29yKChwWzFdIC0gZ3JpZE9mZnNldFsxXSkgLyBncmlkUmVzb2x1dGlvbikgKiBncmlkUmVzb2x1dGlvbiArIGdyaWRPZmZzZXRbMV07XG4gIG91dFswXSA9IGxlZnQ7XG4gIG91dFsxXSA9IGJvdHRvbTtcbiAgb3V0WzJdID0gbGVmdCArIGdyaWRSZXNvbHV0aW9uO1xuICBvdXRbM10gPSBib3R0b20gKyBncmlkUmVzb2x1dGlvbjtcbiAgcmV0dXJuIG91dDtcbn1cblxuZnVuY3Rpb24gbW92ZVRvTmVpZ2hib3JDZWxsKGNlbGwsIGdyaWRSZXNvbHV0aW9uLCBlZGdlKSB7XG4gIGlmIChlZGdlICYgOCkge1xuICAgIGNlbGxbMV0gKz0gZ3JpZFJlc29sdXRpb247XG4gICAgY2VsbFszXSArPSBncmlkUmVzb2x1dGlvbjtcbiAgfSBlbHNlIGlmIChlZGdlICYgNCkge1xuICAgIGNlbGxbMV0gLT0gZ3JpZFJlc29sdXRpb247XG4gICAgY2VsbFszXSAtPSBncmlkUmVzb2x1dGlvbjtcbiAgfSBlbHNlIGlmIChlZGdlICYgMikge1xuICAgIGNlbGxbMF0gKz0gZ3JpZFJlc29sdXRpb247XG4gICAgY2VsbFsyXSArPSBncmlkUmVzb2x1dGlvbjtcbiAgfSBlbHNlIGlmIChlZGdlICYgMSkge1xuICAgIGNlbGxbMF0gLT0gZ3JpZFJlc29sdXRpb247XG4gICAgY2VsbFsyXSAtPSBncmlkUmVzb2x1dGlvbjtcbiAgfVxufVxuXG5mdW5jdGlvbiBnZXRCb3VuZGluZ0JveChwb3NpdGlvbnMsIHNpemUsIGVuZEluZGV4LCBvdXQpIHtcbiAgbGV0IG1pblggPSBJbmZpbml0eTtcbiAgbGV0IG1heFggPSAtSW5maW5pdHk7XG4gIGxldCBtaW5ZID0gSW5maW5pdHk7XG4gIGxldCBtYXhZID0gLUluZmluaXR5O1xuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgZW5kSW5kZXg7IGkgKz0gc2l6ZSkge1xuICAgIGNvbnN0IHggPSBwb3NpdGlvbnNbaV07XG4gICAgY29uc3QgeSA9IHBvc2l0aW9uc1tpICsgMV07XG4gICAgbWluWCA9IHggPCBtaW5YID8geCA6IG1pblg7XG4gICAgbWF4WCA9IHggPiBtYXhYID8geCA6IG1heFg7XG4gICAgbWluWSA9IHkgPCBtaW5ZID8geSA6IG1pblk7XG4gICAgbWF4WSA9IHkgPiBtYXhZID8geSA6IG1heFk7XG4gIH1cblxuICBvdXRbMF1bMF0gPSBtaW5YO1xuICBvdXRbMF1bMV0gPSBtaW5ZO1xuICBvdXRbMV1bMF0gPSBtYXhYO1xuICBvdXRbMV1bMV0gPSBtYXhZO1xuICByZXR1cm4gb3V0O1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y3V0LWJ5LWdyaWQuanMubWFwIiwiaW1wb3J0IHsgY3V0UG9seWxpbmVCeUdyaWQsIGN1dFBvbHlnb25CeUdyaWQgfSBmcm9tICcuL2N1dC1ieS1ncmlkJztcbmltcG9ydCB7IGdldFBvaW50QXRJbmRleCwgcHVzaCB9IGZyb20gJy4vdXRpbHMnO1xuY29uc3QgREVGQVVMVF9NQVhfTEFUSVRVREUgPSA4NS4wNTExMjk7XG5leHBvcnQgZnVuY3Rpb24gY3V0UG9seWxpbmVCeU1lcmNhdG9yQm91bmRzKHBvc2l0aW9ucywgb3B0aW9ucykge1xuICBjb25zdCB7XG4gICAgc2l6ZSA9IDIsXG4gICAgc3RhcnRJbmRleCA9IDAsXG4gICAgZW5kSW5kZXggPSBwb3NpdGlvbnMubGVuZ3RoLFxuICAgIG5vcm1hbGl6ZSA9IHRydWVcbiAgfSA9IG9wdGlvbnMgfHwge307XG4gIGNvbnN0IG5ld1Bvc2l0aW9ucyA9IHBvc2l0aW9ucy5zbGljZShzdGFydEluZGV4LCBlbmRJbmRleCk7XG4gIHdyYXBMb25naXR1ZGVzRm9yU2hvcnRlc3RQYXRoKG5ld1Bvc2l0aW9ucywgc2l6ZSwgMCwgZW5kSW5kZXggLSBzdGFydEluZGV4KTtcbiAgY29uc3QgcGFydHMgPSBjdXRQb2x5bGluZUJ5R3JpZChuZXdQb3NpdGlvbnMsIHtcbiAgICBzaXplLFxuICAgIGJyb2tlbjogdHJ1ZSxcbiAgICBncmlkUmVzb2x1dGlvbjogMzYwLFxuICAgIGdyaWRPZmZzZXQ6IFstMTgwLCAtMTgwXVxuICB9KTtcblxuICBpZiAobm9ybWFsaXplKSB7XG4gICAgZm9yIChjb25zdCBwYXJ0IG9mIHBhcnRzKSB7XG4gICAgICBzaGlmdExvbmdpdHVkZXNJbnRvUmFuZ2UocGFydCwgc2l6ZSk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHBhcnRzO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGN1dFBvbHlnb25CeU1lcmNhdG9yQm91bmRzKHBvc2l0aW9ucywgaG9sZUluZGljZXMgPSBudWxsLCBvcHRpb25zKSB7XG4gIGNvbnN0IHtcbiAgICBzaXplID0gMixcbiAgICBub3JtYWxpemUgPSB0cnVlLFxuICAgIGVkZ2VUeXBlcyA9IGZhbHNlXG4gIH0gPSBvcHRpb25zIHx8IHt9O1xuICBob2xlSW5kaWNlcyA9IGhvbGVJbmRpY2VzIHx8IFtdO1xuICBjb25zdCBuZXdQb3NpdGlvbnMgPSBbXTtcbiAgY29uc3QgbmV3SG9sZUluZGljZXMgPSBbXTtcbiAgbGV0IHNyY1N0YXJ0SW5kZXggPSAwO1xuICBsZXQgdGFyZ2V0SW5kZXggPSAwO1xuXG4gIGZvciAobGV0IHJpbmdJbmRleCA9IDA7IHJpbmdJbmRleCA8PSBob2xlSW5kaWNlcy5sZW5ndGg7IHJpbmdJbmRleCsrKSB7XG4gICAgY29uc3Qgc3JjRW5kSW5kZXggPSBob2xlSW5kaWNlc1tyaW5nSW5kZXhdIHx8IHBvc2l0aW9ucy5sZW5ndGg7XG4gICAgY29uc3QgdGFyZ2V0U3RhcnRJbmRleCA9IHRhcmdldEluZGV4O1xuICAgIGNvbnN0IHNwbGl0SW5kZXggPSBmaW5kU3BsaXRJbmRleChwb3NpdGlvbnMsIHNpemUsIHNyY1N0YXJ0SW5kZXgsIHNyY0VuZEluZGV4KTtcblxuICAgIGZvciAobGV0IGkgPSBzcGxpdEluZGV4OyBpIDwgc3JjRW5kSW5kZXg7IGkrKykge1xuICAgICAgbmV3UG9zaXRpb25zW3RhcmdldEluZGV4KytdID0gcG9zaXRpb25zW2ldO1xuICAgIH1cblxuICAgIGZvciAobGV0IGkgPSBzcmNTdGFydEluZGV4OyBpIDwgc3BsaXRJbmRleDsgaSsrKSB7XG4gICAgICBuZXdQb3NpdGlvbnNbdGFyZ2V0SW5kZXgrK10gPSBwb3NpdGlvbnNbaV07XG4gICAgfVxuXG4gICAgd3JhcExvbmdpdHVkZXNGb3JTaG9ydGVzdFBhdGgobmV3UG9zaXRpb25zLCBzaXplLCB0YXJnZXRTdGFydEluZGV4LCB0YXJnZXRJbmRleCk7XG4gICAgaW5zZXJ0UG9sZVZlcnRpY2VzKG5ld1Bvc2l0aW9ucywgc2l6ZSwgdGFyZ2V0U3RhcnRJbmRleCwgdGFyZ2V0SW5kZXgsIG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5tYXhMYXRpdHVkZSk7XG4gICAgc3JjU3RhcnRJbmRleCA9IHNyY0VuZEluZGV4O1xuICAgIG5ld0hvbGVJbmRpY2VzW3JpbmdJbmRleF0gPSB0YXJnZXRJbmRleDtcbiAgfVxuXG4gIG5ld0hvbGVJbmRpY2VzLnBvcCgpO1xuICBjb25zdCBwYXJ0cyA9IGN1dFBvbHlnb25CeUdyaWQobmV3UG9zaXRpb25zLCBuZXdIb2xlSW5kaWNlcywge1xuICAgIHNpemUsXG4gICAgZ3JpZFJlc29sdXRpb246IDM2MCxcbiAgICBncmlkT2Zmc2V0OiBbLTE4MCwgLTE4MF0sXG4gICAgZWRnZVR5cGVzXG4gIH0pO1xuXG4gIGlmIChub3JtYWxpemUpIHtcbiAgICBmb3IgKGNvbnN0IHBhcnQgb2YgcGFydHMpIHtcbiAgICAgIHNoaWZ0TG9uZ2l0dWRlc0ludG9SYW5nZShwYXJ0LnBvc2l0aW9ucywgc2l6ZSk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHBhcnRzO1xufVxuXG5mdW5jdGlvbiBmaW5kU3BsaXRJbmRleChwb3NpdGlvbnMsIHNpemUsIHN0YXJ0SW5kZXgsIGVuZEluZGV4KSB7XG4gIGxldCBtYXhMYXQgPSAtMTtcbiAgbGV0IHBvaW50SW5kZXggPSAtMTtcblxuICBmb3IgKGxldCBpID0gc3RhcnRJbmRleCArIDE7IGkgPCBlbmRJbmRleDsgaSArPSBzaXplKSB7XG4gICAgY29uc3QgbGF0ID0gTWF0aC5hYnMocG9zaXRpb25zW2ldKTtcblxuICAgIGlmIChsYXQgPiBtYXhMYXQpIHtcbiAgICAgIG1heExhdCA9IGxhdDtcbiAgICAgIHBvaW50SW5kZXggPSBpIC0gMTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gcG9pbnRJbmRleDtcbn1cblxuZnVuY3Rpb24gaW5zZXJ0UG9sZVZlcnRpY2VzKHBvc2l0aW9ucywgc2l6ZSwgc3RhcnRJbmRleCwgZW5kSW5kZXgsIG1heExhdGl0dWRlID0gREVGQVVMVF9NQVhfTEFUSVRVREUpIHtcbiAgY29uc3QgZmlyc3RMbmcgPSBwb3NpdGlvbnNbc3RhcnRJbmRleF07XG4gIGNvbnN0IGxhc3RMbmcgPSBwb3NpdGlvbnNbZW5kSW5kZXggLSBzaXplXTtcblxuICBpZiAoTWF0aC5hYnMoZmlyc3RMbmcgLSBsYXN0TG5nKSA+IDE4MCkge1xuICAgIGNvbnN0IHAgPSBnZXRQb2ludEF0SW5kZXgocG9zaXRpb25zLCAwLCBzaXplLCBzdGFydEluZGV4KTtcbiAgICBwWzBdICs9IE1hdGgucm91bmQoKGxhc3RMbmcgLSBmaXJzdExuZykgLyAzNjApICogMzYwO1xuICAgIHB1c2gocG9zaXRpb25zLCBwKTtcbiAgICBwWzFdID0gTWF0aC5zaWduKHBbMV0pICogbWF4TGF0aXR1ZGU7XG4gICAgcHVzaChwb3NpdGlvbnMsIHApO1xuICAgIHBbMF0gPSBmaXJzdExuZztcbiAgICBwdXNoKHBvc2l0aW9ucywgcCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gd3JhcExvbmdpdHVkZXNGb3JTaG9ydGVzdFBhdGgocG9zaXRpb25zLCBzaXplLCBzdGFydEluZGV4LCBlbmRJbmRleCkge1xuICBsZXQgcHJldkxuZyA9IHBvc2l0aW9uc1swXTtcbiAgbGV0IGxuZztcblxuICBmb3IgKGxldCBpID0gc3RhcnRJbmRleDsgaSA8IGVuZEluZGV4OyBpICs9IHNpemUpIHtcbiAgICBsbmcgPSBwb3NpdGlvbnNbaV07XG4gICAgY29uc3QgZGVsdGEgPSBsbmcgLSBwcmV2TG5nO1xuXG4gICAgaWYgKGRlbHRhID4gMTgwIHx8IGRlbHRhIDwgLTE4MCkge1xuICAgICAgbG5nIC09IE1hdGgucm91bmQoZGVsdGEgLyAzNjApICogMzYwO1xuICAgIH1cblxuICAgIHBvc2l0aW9uc1tpXSA9IHByZXZMbmcgPSBsbmc7XG4gIH1cbn1cblxuZnVuY3Rpb24gc2hpZnRMb25naXR1ZGVzSW50b1JhbmdlKHBvc2l0aW9ucywgc2l6ZSkge1xuICBsZXQgcmVmTG5nO1xuICBjb25zdCBwb2ludENvdW50ID0gcG9zaXRpb25zLmxlbmd0aCAvIHNpemU7XG5cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBwb2ludENvdW50OyBpKyspIHtcbiAgICByZWZMbmcgPSBwb3NpdGlvbnNbaSAqIHNpemVdO1xuXG4gICAgaWYgKChyZWZMbmcgKyAxODApICUgMzYwICE9PSAwKSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cblxuICBjb25zdCBkZWx0YSA9IC1NYXRoLnJvdW5kKHJlZkxuZyAvIDM2MCkgKiAzNjA7XG5cbiAgaWYgKGRlbHRhID09PSAwKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBwb2ludENvdW50OyBpKyspIHtcbiAgICBwb3NpdGlvbnNbaSAqIHNpemVdICs9IGRlbHRhO1xuICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jdXQtYnktbWVyY2F0b3ItYm91bmRzLmpzLm1hcCIsImV4cG9ydCB7IGRlZmF1bHQgYXMgUG9seWdvbiB9IGZyb20gJy4vcG9seWdvbic7XG5leHBvcnQgeyBnZXRQb2x5Z29uU2lnbmVkQXJlYSwgZ2V0UG9seWdvbldpbmRpbmdEaXJlY3Rpb24sIGZvckVhY2hTZWdtZW50SW5Qb2x5Z29uLCBtb2RpZnlQb2x5Z29uV2luZGluZ0RpcmVjdGlvbiwgV0lORElORyB9IGZyb20gJy4vcG9seWdvbi11dGlscyc7XG5leHBvcnQgeyBlYXJjdXQgfSBmcm9tICcuL2VhcmN1dCc7XG5leHBvcnQgeyBjbGlwUG9seWdvbiwgY2xpcFBvbHlsaW5lIH0gZnJvbSAnLi9saW5lY2xpcCc7XG5leHBvcnQgeyBjdXRQb2x5Z29uQnlHcmlkLCBjdXRQb2x5bGluZUJ5R3JpZCB9IGZyb20gJy4vY3V0LWJ5LWdyaWQnO1xuZXhwb3J0IHsgY3V0UG9seWxpbmVCeU1lcmNhdG9yQm91bmRzLCBjdXRQb2x5Z29uQnlNZXJjYXRvckJvdW5kcyB9IGZyb20gJy4vY3V0LWJ5LW1lcmNhdG9yLWJvdW5kcyc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIF9Qb2x5Z29uIH0gZnJvbSAnLi9wb2x5Z29uJztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///89513\n')},78866:function(__unused_webpack_module,__webpack_exports__,__webpack_require__){eval('\n// EXPORTS\n__webpack_require__.d(__webpack_exports__, {\n  "eG": function() { return /* reexport */ addMetersToLngLat; },\n  "Lu": function() { return /* reexport */ web_mercator_utils_altitudeToFovy; },\n  "Xg": function() { return /* reexport */ fit_bounds_fitBounds; },\n  "sj": function() { return /* reexport */ web_mercator_utils_fovyToAltitude; },\n  "zX": function() { return /* reexport */ get_bounds_getBounds; },\n  "ro": function() { return /* reexport */ web_mercator_utils_getDistanceScales; },\n  "Bf": function() { return /* reexport */ getMeterZoom; },\n  "wl": function() { return /* reexport */ getProjectionParameters; },\n  "lf": function() { return /* reexport */ web_mercator_utils_getViewMatrix; },\n  "w5": function() { return /* reexport */ web_mercator_utils_lngLatToWorld; },\n  "QA": function() { return /* reexport */ normalizeViewportProps; },\n  "CT": function() { return /* reexport */ web_mercator_utils_pixelsToWorld; },\n  "NC": function() { return /* reexport */ unitsPerMeter; },\n  "es": function() { return /* reexport */ web_mercator_utils_worldToLngLat; },\n  "aW": function() { return /* reexport */ web_mercator_utils_worldToPixels; }\n});\n\n// UNUSED EXPORTS: MAX_LATITUDE, WebMercatorViewport, default, flyToViewport, getFlyToDuration, getProjectionMatrix, scaleToZoom, zoomToScale\n\n// EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/esm/defineProperty.js\nvar defineProperty = __webpack_require__(82482);\n// EXTERNAL MODULE: ./node_modules/gl-matrix/esm/vec4.js\nvar vec4 = __webpack_require__(98333);\n;// CONCATENATED MODULE: ./node_modules/@math.gl/web-mercator/dist/esm/math-utils.js\n\nfunction math_utils_createMat4() {\n  return [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];\n}\nfunction transformVector(matrix, vector) {\n  const result = (0,vec4/* transformMat4 */.fF)([], vector, matrix);\n  (0,vec4/* scale */.bA)(result, result, 1 / result[3]);\n  return result;\n}\nfunction mod(value, divisor) {\n  const modulus = value % divisor;\n  return modulus < 0 ? divisor + modulus : modulus;\n}\nfunction math_utils_lerp(start, end, step) {\n  return step * end + (1 - step) * start;\n}\nfunction clamp(x, min, max) {\n  return x < min ? min : x > max ? max : x;\n}\n\nfunction ieLog2(x) {\n  return Math.log(x) * Math.LOG2E;\n}\n\nconst log2 = Math.log2 || ieLog2;\n//# sourceMappingURL=math-utils.js.map\n// EXTERNAL MODULE: ./node_modules/gl-matrix/esm/mat4.js\nvar esm_mat4 = __webpack_require__(85975);\n// EXTERNAL MODULE: ./node_modules/gl-matrix/esm/vec2.js\nvar esm_vec2 = __webpack_require__(31437);\n// EXTERNAL MODULE: ./node_modules/gl-matrix/esm/vec3.js\nvar esm_vec3 = __webpack_require__(77160);\n;// CONCATENATED MODULE: ./node_modules/@math.gl/web-mercator/dist/esm/assert.js\nfunction assert(condition, message) {\n  if (!condition) {\n    throw new Error(message || \'@math.gl/web-mercator: assertion failed.\');\n  }\n}\n//# sourceMappingURL=assert.js.map\n;// CONCATENATED MODULE: ./node_modules/@math.gl/web-mercator/dist/esm/web-mercator-utils.js\n\n\n\n\n\nconst PI = Math.PI;\nconst PI_4 = PI / 4;\nconst DEGREES_TO_RADIANS = PI / 180;\nconst RADIANS_TO_DEGREES = 180 / PI;\nconst TILE_SIZE = 512;\nconst EARTH_CIRCUMFERENCE = 40.03e6;\nconst MAX_LATITUDE = 85.051129;\nconst web_mercator_utils_DEFAULT_ALTITUDE = 1.5;\nfunction web_mercator_utils_zoomToScale(zoom) {\n  return Math.pow(2, zoom);\n}\nfunction web_mercator_utils_scaleToZoom(scale) {\n  return log2(scale);\n}\nfunction web_mercator_utils_lngLatToWorld(lngLat) {\n  const [lng, lat] = lngLat;\n  assert(Number.isFinite(lng));\n  assert(Number.isFinite(lat) && lat >= -90 && lat <= 90, \'invalid latitude\');\n  const lambda2 = lng * DEGREES_TO_RADIANS;\n  const phi2 = lat * DEGREES_TO_RADIANS;\n  const x = TILE_SIZE * (lambda2 + PI) / (2 * PI);\n  const y = TILE_SIZE * (PI + Math.log(Math.tan(PI_4 + phi2 * 0.5))) / (2 * PI);\n  return [x, y];\n}\nfunction web_mercator_utils_worldToLngLat(xy) {\n  const [x, y] = xy;\n  const lambda2 = x / TILE_SIZE * (2 * PI) - PI;\n  const phi2 = 2 * (Math.atan(Math.exp(y / TILE_SIZE * (2 * PI) - PI)) - PI_4);\n  return [lambda2 * RADIANS_TO_DEGREES, phi2 * RADIANS_TO_DEGREES];\n}\nfunction getMeterZoom(options) {\n  const {\n    latitude\n  } = options;\n  assert(Number.isFinite(latitude));\n  const latCosine = Math.cos(latitude * DEGREES_TO_RADIANS);\n  return web_mercator_utils_scaleToZoom(EARTH_CIRCUMFERENCE * latCosine) - 9;\n}\nfunction unitsPerMeter(latitude) {\n  const latCosine = Math.cos(latitude * DEGREES_TO_RADIANS);\n  return TILE_SIZE / EARTH_CIRCUMFERENCE / latCosine;\n}\nfunction web_mercator_utils_getDistanceScales(options) {\n  const {\n    latitude,\n    longitude,\n    highPrecision = false\n  } = options;\n  assert(Number.isFinite(latitude) && Number.isFinite(longitude));\n  const worldSize = TILE_SIZE;\n  const latCosine = Math.cos(latitude * DEGREES_TO_RADIANS);\n  const unitsPerDegreeX = worldSize / 360;\n  const unitsPerDegreeY = unitsPerDegreeX / latCosine;\n  const altUnitsPerMeter = worldSize / EARTH_CIRCUMFERENCE / latCosine;\n  const result = {\n    unitsPerMeter: [altUnitsPerMeter, altUnitsPerMeter, altUnitsPerMeter],\n    metersPerUnit: [1 / altUnitsPerMeter, 1 / altUnitsPerMeter, 1 / altUnitsPerMeter],\n    unitsPerDegree: [unitsPerDegreeX, unitsPerDegreeY, altUnitsPerMeter],\n    degreesPerUnit: [1 / unitsPerDegreeX, 1 / unitsPerDegreeY, 1 / altUnitsPerMeter]\n  };\n\n  if (highPrecision) {\n    const latCosine2 = DEGREES_TO_RADIANS * Math.tan(latitude * DEGREES_TO_RADIANS) / latCosine;\n    const unitsPerDegreeY2 = unitsPerDegreeX * latCosine2 / 2;\n    const altUnitsPerDegree2 = worldSize / EARTH_CIRCUMFERENCE * latCosine2;\n    const altUnitsPerMeter2 = altUnitsPerDegree2 / unitsPerDegreeY * altUnitsPerMeter;\n    result.unitsPerDegree2 = [0, unitsPerDegreeY2, altUnitsPerDegree2];\n    result.unitsPerMeter2 = [altUnitsPerMeter2, 0, altUnitsPerMeter2];\n  }\n\n  return result;\n}\nfunction addMetersToLngLat(lngLatZ, xyz) {\n  const [longitude, latitude, z0] = lngLatZ;\n  const [x, y, z] = xyz;\n  const {\n    unitsPerMeter,\n    unitsPerMeter2\n  } = web_mercator_utils_getDistanceScales({\n    longitude,\n    latitude,\n    highPrecision: true\n  });\n  const worldspace = web_mercator_utils_lngLatToWorld(lngLatZ);\n  worldspace[0] += x * (unitsPerMeter[0] + unitsPerMeter2[0] * y);\n  worldspace[1] += y * (unitsPerMeter[1] + unitsPerMeter2[1] * y);\n  const newLngLat = web_mercator_utils_worldToLngLat(worldspace);\n  const newZ = (z0 || 0) + (z || 0);\n  return Number.isFinite(z0) || Number.isFinite(z) ? [newLngLat[0], newLngLat[1], newZ] : newLngLat;\n}\nfunction web_mercator_utils_getViewMatrix(options) {\n  const {\n    height,\n    pitch,\n    bearing,\n    altitude,\n    scale,\n    center\n  } = options;\n  const vm = math_utils_createMat4();\n  esm_mat4/* translate */.Iu(vm, vm, [0, 0, -altitude]);\n  esm_mat4/* rotateX */.lM(vm, vm, -pitch * DEGREES_TO_RADIANS);\n  esm_mat4/* rotateZ */.jI(vm, vm, bearing * DEGREES_TO_RADIANS);\n  const relativeScale = scale / height;\n  esm_mat4/* scale */.bA(vm, vm, [relativeScale, relativeScale, relativeScale]);\n\n  if (center) {\n    esm_mat4/* translate */.Iu(vm, vm, esm_vec3/* negate */.tk([], center));\n  }\n\n  return vm;\n}\nfunction getProjectionParameters(options) {\n  const {\n    width,\n    height,\n    altitude,\n    pitch = 0,\n    offset,\n    center,\n    scale,\n    nearZMultiplier = 1,\n    farZMultiplier = 1\n  } = options;\n  let {\n    fovy = web_mercator_utils_altitudeToFovy(web_mercator_utils_DEFAULT_ALTITUDE)\n  } = options;\n\n  if (altitude !== undefined) {\n    fovy = web_mercator_utils_altitudeToFovy(altitude);\n  }\n\n  const fovRadians = fovy * DEGREES_TO_RADIANS;\n  const pitchRadians = pitch * DEGREES_TO_RADIANS;\n  const focalDistance = web_mercator_utils_fovyToAltitude(fovy);\n  let cameraToSeaLevelDistance = focalDistance;\n\n  if (center) {\n    cameraToSeaLevelDistance += center[2] * scale / Math.cos(pitchRadians) / height;\n  }\n\n  const fovAboveCenter = fovRadians * (0.5 + (offset ? offset[1] : 0) / height);\n  const topHalfSurfaceDistance = Math.sin(fovAboveCenter) * cameraToSeaLevelDistance / Math.sin(clamp(Math.PI / 2 - pitchRadians - fovAboveCenter, 0.01, Math.PI - 0.01));\n  const furthestDistance = Math.sin(pitchRadians) * topHalfSurfaceDistance + cameraToSeaLevelDistance;\n  const horizonDistance = cameraToSeaLevelDistance * 10;\n  const farZ = Math.min(furthestDistance * farZMultiplier, horizonDistance);\n  return {\n    fov: fovRadians,\n    aspect: width / height,\n    focalDistance,\n    near: nearZMultiplier,\n    far: farZ\n  };\n}\nfunction web_mercator_utils_getProjectionMatrix(options) {\n  const {\n    fov,\n    aspect,\n    near,\n    far\n  } = getProjectionParameters(options);\n  const projectionMatrix = mat4.perspective([], fov, aspect, near, far);\n  return projectionMatrix;\n}\nfunction web_mercator_utils_altitudeToFovy(altitude) {\n  return 2 * Math.atan(0.5 / altitude) * RADIANS_TO_DEGREES;\n}\nfunction web_mercator_utils_fovyToAltitude(fovy) {\n  return 0.5 / Math.tan(0.5 * fovy * DEGREES_TO_RADIANS);\n}\nfunction web_mercator_utils_worldToPixels(xyz, pixelProjectionMatrix) {\n  const [x, y, z = 0] = xyz;\n  assert(Number.isFinite(x) && Number.isFinite(y) && Number.isFinite(z));\n  return transformVector(pixelProjectionMatrix, [x, y, z, 1]);\n}\nfunction web_mercator_utils_pixelsToWorld(xyz, pixelUnprojectionMatrix, targetZ = 0) {\n  const [x, y, z] = xyz;\n  assert(Number.isFinite(x) && Number.isFinite(y), \'invalid pixel coordinate\');\n\n  if (Number.isFinite(z)) {\n    const coord = transformVector(pixelUnprojectionMatrix, [x, y, z, 1]);\n    return coord;\n  }\n\n  const coord0 = transformVector(pixelUnprojectionMatrix, [x, y, 0, 1]);\n  const coord1 = transformVector(pixelUnprojectionMatrix, [x, y, 1, 1]);\n  const z0 = coord0[2];\n  const z1 = coord1[2];\n  const t = z0 === z1 ? 0 : ((targetZ || 0) - z0) / (z1 - z0);\n  return esm_vec2/* lerp */.t7([], coord0, coord1, t);\n}\n//# sourceMappingURL=web-mercator-utils.js.map\n;// CONCATENATED MODULE: ./node_modules/@math.gl/web-mercator/dist/esm/fit-bounds.js\n\n\n\nfunction fit_bounds_fitBounds(options) {\n  const {\n    width,\n    height,\n    bounds,\n    minExtent = 0,\n    maxZoom = 24,\n    offset = [0, 0]\n  } = options;\n  const [[west, south], [east, north]] = bounds;\n  const padding = getPaddingObject(options.padding);\n  const nw = web_mercator_utils_lngLatToWorld([west, clamp(north, -MAX_LATITUDE, MAX_LATITUDE)]);\n  const se = web_mercator_utils_lngLatToWorld([east, clamp(south, -MAX_LATITUDE, MAX_LATITUDE)]);\n  const size = [Math.max(Math.abs(se[0] - nw[0]), minExtent), Math.max(Math.abs(se[1] - nw[1]), minExtent)];\n  const targetSize = [width - padding.left - padding.right - Math.abs(offset[0]) * 2, height - padding.top - padding.bottom - Math.abs(offset[1]) * 2];\n  assert(targetSize[0] > 0 && targetSize[1] > 0);\n  const scaleX = targetSize[0] / size[0];\n  const scaleY = targetSize[1] / size[1];\n  const offsetX = (padding.right - padding.left) / 2 / scaleX;\n  const offsetY = (padding.top - padding.bottom) / 2 / scaleY;\n  const center = [(se[0] + nw[0]) / 2 + offsetX, (se[1] + nw[1]) / 2 + offsetY];\n  const centerLngLat = web_mercator_utils_worldToLngLat(center);\n  const zoom = Math.min(maxZoom, log2(Math.abs(Math.min(scaleX, scaleY))));\n  assert(Number.isFinite(zoom));\n  return {\n    longitude: centerLngLat[0],\n    latitude: centerLngLat[1],\n    zoom\n  };\n}\n\nfunction getPaddingObject(padding = 0) {\n  if (typeof padding === \'number\') {\n    return {\n      top: padding,\n      bottom: padding,\n      left: padding,\n      right: padding\n    };\n  }\n\n  assert(Number.isFinite(padding.top) && Number.isFinite(padding.bottom) && Number.isFinite(padding.left) && Number.isFinite(padding.right));\n  return padding;\n}\n//# sourceMappingURL=fit-bounds.js.map\n;// CONCATENATED MODULE: ./node_modules/@math.gl/web-mercator/dist/esm/get-bounds.js\n\n\n\nconst get_bounds_DEGREES_TO_RADIANS = Math.PI / 180;\nfunction get_bounds_getBounds(viewport, z = 0) {\n  const {\n    width,\n    height,\n    unproject\n  } = viewport;\n  const unprojectOps = {\n    targetZ: z\n  };\n  const bottomLeft = unproject([0, height], unprojectOps);\n  const bottomRight = unproject([width, height], unprojectOps);\n  let topLeft;\n  let topRight;\n  const halfFov = viewport.fovy ? 0.5 * viewport.fovy * get_bounds_DEGREES_TO_RADIANS : Math.atan(0.5 / viewport.altitude);\n  const angleToGround = (90 - viewport.pitch) * get_bounds_DEGREES_TO_RADIANS;\n\n  if (halfFov > angleToGround - 0.01) {\n    topLeft = unprojectOnFarPlane(viewport, 0, z);\n    topRight = unprojectOnFarPlane(viewport, width, z);\n  } else {\n    topLeft = unproject([0, 0], unprojectOps);\n    topRight = unproject([width, 0], unprojectOps);\n  }\n\n  return [bottomLeft, bottomRight, topRight, topLeft];\n}\n\nfunction unprojectOnFarPlane(viewport, x, targetZ) {\n  const {\n    pixelUnprojectionMatrix\n  } = viewport;\n  const coord0 = transformVector(pixelUnprojectionMatrix, [x, 0, 1, 1]);\n  const coord1 = transformVector(pixelUnprojectionMatrix, [x, viewport.height, 1, 1]);\n  const z = targetZ * viewport.distanceScales.unitsPerMeter[2];\n  const t = (z - coord0[2]) / (coord1[2] - coord0[2]);\n  const coord = esm_vec2/* lerp */.t7([], coord0, coord1, t);\n  const result = web_mercator_utils_worldToLngLat(coord);\n  result.push(targetZ);\n  return result;\n}\n//# sourceMappingURL=get-bounds.js.map\n;// CONCATENATED MODULE: ./node_modules/@math.gl/web-mercator/dist/esm/web-mercator-viewport.js\n\n\n\n\n\n\n\n\nclass WebMercatorViewport {\n  constructor(props = {\n    width: 1,\n    height: 1\n  }) {\n    _defineProperty(this, "latitude", void 0);\n\n    _defineProperty(this, "longitude", void 0);\n\n    _defineProperty(this, "zoom", void 0);\n\n    _defineProperty(this, "pitch", void 0);\n\n    _defineProperty(this, "bearing", void 0);\n\n    _defineProperty(this, "altitude", void 0);\n\n    _defineProperty(this, "fovy", void 0);\n\n    _defineProperty(this, "meterOffset", void 0);\n\n    _defineProperty(this, "center", void 0);\n\n    _defineProperty(this, "width", void 0);\n\n    _defineProperty(this, "height", void 0);\n\n    _defineProperty(this, "scale", void 0);\n\n    _defineProperty(this, "distanceScales", void 0);\n\n    _defineProperty(this, "viewMatrix", void 0);\n\n    _defineProperty(this, "projectionMatrix", void 0);\n\n    _defineProperty(this, "viewProjectionMatrix", void 0);\n\n    _defineProperty(this, "pixelProjectionMatrix", void 0);\n\n    _defineProperty(this, "pixelUnprojectionMatrix", void 0);\n\n    _defineProperty(this, "equals", viewport => {\n      if (!(viewport instanceof WebMercatorViewport)) {\n        return false;\n      }\n\n      return viewport.width === this.width && viewport.height === this.height && mat4.equals(viewport.projectionMatrix, this.projectionMatrix) && mat4.equals(viewport.viewMatrix, this.viewMatrix);\n    });\n\n    _defineProperty(this, "project", (lngLatZ, options = {}) => {\n      const {\n        topLeft = true\n      } = options;\n      const worldPosition = this.projectPosition(lngLatZ);\n      const coord = worldToPixels(worldPosition, this.pixelProjectionMatrix);\n      const [x, y] = coord;\n      const y2 = topLeft ? y : this.height - y;\n      return lngLatZ.length === 2 ? [x, y2] : [x, y2, coord[2]];\n    });\n\n    _defineProperty(this, "unproject", (xyz, options = {}) => {\n      const {\n        topLeft = true,\n        targetZ = undefined\n      } = options;\n      const [x, y, z] = xyz;\n      const y2 = topLeft ? y : this.height - y;\n      const targetZWorld = targetZ && targetZ * this.distanceScales.unitsPerMeter[2];\n      const coord = pixelsToWorld([x, y2, z], this.pixelUnprojectionMatrix, targetZWorld);\n      const [X, Y, Z] = this.unprojectPosition(coord);\n\n      if (Number.isFinite(z)) {\n        return [X, Y, Z];\n      }\n\n      return Number.isFinite(targetZ) ? [X, Y, targetZ] : [X, Y];\n    });\n\n    _defineProperty(this, "projectPosition", xyz => {\n      const [X, Y] = lngLatToWorld(xyz);\n      const Z = (xyz[2] || 0) * this.distanceScales.unitsPerMeter[2];\n      return [X, Y, Z];\n    });\n\n    _defineProperty(this, "unprojectPosition", xyz => {\n      const [X, Y] = worldToLngLat(xyz);\n      const Z = (xyz[2] || 0) * this.distanceScales.metersPerUnit[2];\n      return [X, Y, Z];\n    });\n\n    let {\n      width,\n      height,\n      altitude = null,\n      fovy = null\n    } = props;\n    const {\n      latitude = 0,\n      longitude = 0,\n      zoom = 0,\n      pitch = 0,\n      bearing = 0,\n      position = null,\n      nearZMultiplier = 0.02,\n      farZMultiplier = 1.01\n    } = props;\n    width = width || 1;\n    height = height || 1;\n\n    if (fovy === null && altitude === null) {\n      altitude = DEFAULT_ALTITUDE;\n      fovy = altitudeToFovy(altitude);\n    } else if (fovy === null) {\n      fovy = altitudeToFovy(altitude);\n    } else if (altitude === null) {\n      altitude = fovyToAltitude(fovy);\n    }\n\n    const scale = zoomToScale(zoom);\n    altitude = Math.max(0.75, altitude);\n    const distanceScales = getDistanceScales({\n      longitude,\n      latitude\n    });\n    const center = lngLatToWorld([longitude, latitude]);\n    center.push(0);\n\n    if (position) {\n      vec3.add(center, center, vec3.mul([], position, distanceScales.unitsPerMeter));\n    }\n\n    this.projectionMatrix = getProjectionMatrix({\n      width,\n      height,\n      scale,\n      center,\n      pitch,\n      fovy,\n      nearZMultiplier,\n      farZMultiplier\n    });\n    this.viewMatrix = getViewMatrix({\n      height,\n      scale,\n      center,\n      pitch,\n      bearing,\n      altitude\n    });\n    this.width = width;\n    this.height = height;\n    this.scale = scale;\n    this.latitude = latitude;\n    this.longitude = longitude;\n    this.zoom = zoom;\n    this.pitch = pitch;\n    this.bearing = bearing;\n    this.altitude = altitude;\n    this.fovy = fovy;\n    this.center = center;\n    this.meterOffset = position || [0, 0, 0];\n    this.distanceScales = distanceScales;\n\n    this._initMatrices();\n\n    Object.freeze(this);\n  }\n\n  _initMatrices() {\n    const {\n      width,\n      height,\n      projectionMatrix,\n      viewMatrix\n    } = this;\n    const vpm = createMat4();\n    mat4.multiply(vpm, vpm, projectionMatrix);\n    mat4.multiply(vpm, vpm, viewMatrix);\n    this.viewProjectionMatrix = vpm;\n    const m = createMat4();\n    mat4.scale(m, m, [width / 2, -height / 2, 1]);\n    mat4.translate(m, m, [1, -1, 0]);\n    mat4.multiply(m, m, vpm);\n    const mInverse = mat4.invert(createMat4(), m);\n\n    if (!mInverse) {\n      throw new Error(\'Pixel project matrix not invertible\');\n    }\n\n    this.pixelProjectionMatrix = m;\n    this.pixelUnprojectionMatrix = mInverse;\n  }\n\n  projectFlat(lngLat) {\n    return lngLatToWorld(lngLat);\n  }\n\n  unprojectFlat(xy) {\n    return worldToLngLat(xy);\n  }\n\n  getMapCenterByLngLatPosition({\n    lngLat,\n    pos\n  }) {\n    const fromLocation = pixelsToWorld(pos, this.pixelUnprojectionMatrix);\n    const toLocation = lngLatToWorld(lngLat);\n    const translate = vec2.add([], toLocation, vec2.negate([], fromLocation));\n    const newCenter = vec2.add([], this.center, translate);\n    return worldToLngLat(newCenter);\n  }\n\n  fitBounds(bounds, options = {}) {\n    const {\n      width,\n      height\n    } = this;\n    const {\n      longitude,\n      latitude,\n      zoom\n    } = fitBounds(Object.assign({\n      width,\n      height,\n      bounds\n    }, options));\n    return new WebMercatorViewport({\n      width,\n      height,\n      longitude,\n      latitude,\n      zoom\n    });\n  }\n\n  getBounds(options) {\n    const corners = this.getBoundingRegion(options);\n    const west = Math.min(...corners.map(p => p[0]));\n    const east = Math.max(...corners.map(p => p[0]));\n    const south = Math.min(...corners.map(p => p[1]));\n    const north = Math.max(...corners.map(p => p[1]));\n    return [[west, south], [east, north]];\n  }\n\n  getBoundingRegion(options = {}) {\n    return getBounds(this, options.z || 0);\n  }\n\n  getLocationAtPoint({\n    lngLat,\n    pos\n  }) {\n    return this.getMapCenterByLngLatPosition({\n      lngLat,\n      pos\n    });\n  }\n\n}\n//# sourceMappingURL=web-mercator-viewport.js.map\n;// CONCATENATED MODULE: ./node_modules/@math.gl/web-mercator/dist/esm/normalize-viewport-props.js\n\n\nconst normalize_viewport_props_TILE_SIZE = 512;\nfunction normalizeViewportProps(props) {\n  const {\n    width,\n    height,\n    pitch = 0\n  } = props;\n  let {\n    longitude,\n    latitude,\n    zoom,\n    bearing = 0\n  } = props;\n\n  if (longitude < -180 || longitude > 180) {\n    longitude = mod(longitude + 180, 360) - 180;\n  }\n\n  if (bearing < -180 || bearing > 180) {\n    bearing = mod(bearing + 180, 360) - 180;\n  }\n\n  const minZoom = log2(height / normalize_viewport_props_TILE_SIZE);\n\n  if (zoom <= minZoom) {\n    zoom = minZoom;\n    latitude = 0;\n  } else {\n    const halfHeightPixels = height / 2 / Math.pow(2, zoom);\n    const minLatitude = web_mercator_utils_worldToLngLat([0, halfHeightPixels])[1];\n\n    if (latitude < minLatitude) {\n      latitude = minLatitude;\n    } else {\n      const maxLatitude = web_mercator_utils_worldToLngLat([0, normalize_viewport_props_TILE_SIZE - halfHeightPixels])[1];\n\n      if (latitude > maxLatitude) {\n        latitude = maxLatitude;\n      }\n    }\n  }\n\n  return {\n    width,\n    height,\n    longitude,\n    latitude,\n    zoom,\n    pitch,\n    bearing\n  };\n}\n//# sourceMappingURL=normalize-viewport-props.js.map\n;// CONCATENATED MODULE: ./node_modules/@math.gl/web-mercator/dist/esm/fly-to-viewport.js\n\n\n\nconst EPSILON = 0.01;\nconst VIEWPORT_TRANSITION_PROPS = (/* unused pure expression or super */ null && ([\'longitude\', \'latitude\', \'zoom\']));\nconst DEFAULT_OPTS = {\n  curve: 1.414,\n  speed: 1.2\n};\nfunction flyToViewport(startProps, endProps, t, options) {\n  const {\n    startZoom,\n    startCenterXY,\n    uDelta,\n    w0,\n    u1,\n    S,\n    rho,\n    rho2,\n    r0\n  } = getFlyToTransitionParams(startProps, endProps, options);\n\n  if (u1 < EPSILON) {\n    const viewport = {};\n\n    for (const key of VIEWPORT_TRANSITION_PROPS) {\n      const startValue = startProps[key];\n      const endValue = endProps[key];\n      viewport[key] = lerp(startValue, endValue, t);\n    }\n\n    return viewport;\n  }\n\n  const s = t * S;\n  const w = Math.cosh(r0) / Math.cosh(r0 + rho * s);\n  const u = w0 * ((Math.cosh(r0) * Math.tanh(r0 + rho * s) - Math.sinh(r0)) / rho2) / u1;\n  const scaleIncrement = 1 / w;\n  const newZoom = startZoom + scaleToZoom(scaleIncrement);\n  const newCenterWorld = vec2.scale([], uDelta, u);\n  vec2.add(newCenterWorld, newCenterWorld, startCenterXY);\n  const newCenter = worldToLngLat(newCenterWorld);\n  return {\n    longitude: newCenter[0],\n    latitude: newCenter[1],\n    zoom: newZoom\n  };\n}\nfunction getFlyToDuration(startProps, endProps, options) {\n  const opts = { ...DEFAULT_OPTS,\n    ...options\n  };\n  const {\n    screenSpeed,\n    speed,\n    maxDuration\n  } = opts;\n  const {\n    S,\n    rho\n  } = getFlyToTransitionParams(startProps, endProps, opts);\n  const length = 1000 * S;\n  let duration;\n\n  if (Number.isFinite(screenSpeed)) {\n    duration = length / (screenSpeed / rho);\n  } else {\n    duration = length / speed;\n  }\n\n  return Number.isFinite(maxDuration) && duration > maxDuration ? 0 : duration;\n}\n\nfunction getFlyToTransitionParams(startProps, endProps, opts) {\n  opts = Object.assign({}, DEFAULT_OPTS, opts);\n  const rho = opts.curve;\n  const startZoom = startProps.zoom;\n  const startCenter = [startProps.longitude, startProps.latitude];\n  const startScale = zoomToScale(startZoom);\n  const endZoom = endProps.zoom;\n  const endCenter = [endProps.longitude, endProps.latitude];\n  const scale = zoomToScale(endZoom - startZoom);\n  const startCenterXY = lngLatToWorld(startCenter);\n  const endCenterXY = lngLatToWorld(endCenter);\n  const uDelta = vec2.sub([], endCenterXY, startCenterXY);\n  const w0 = Math.max(startProps.width, startProps.height);\n  const w1 = w0 / scale;\n  const u1 = vec2.length(uDelta) * startScale;\n\n  const _u1 = Math.max(u1, EPSILON);\n\n  const rho2 = rho * rho;\n  const b0 = (w1 * w1 - w0 * w0 + rho2 * rho2 * _u1 * _u1) / (2 * w0 * rho2 * _u1);\n  const b1 = (w1 * w1 - w0 * w0 - rho2 * rho2 * _u1 * _u1) / (2 * w1 * rho2 * _u1);\n  const r0 = Math.log(Math.sqrt(b0 * b0 + 1) - b0);\n  const r1 = Math.log(Math.sqrt(b1 * b1 + 1) - b1);\n  const S = (r1 - r0) / rho;\n  return {\n    startZoom,\n    startCenterXY,\n    uDelta,\n    w0,\n    u1,\n    S,\n    rho,\n    rho2,\n    r0,\n    r1\n  };\n}\n//# sourceMappingURL=fly-to-viewport.js.map\n;// CONCATENATED MODULE: ./node_modules/@math.gl/web-mercator/dist/esm/index.js\n\n\n\n\n\n\n\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNzg4NjYuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQXNEO0FBQy9DLFNBQVMscUJBQVU7QUFDMUI7QUFDQTtBQUNPO0FBQ1AsaUJBQWlCLDhCQUFhO0FBQzlCLEVBQUUsc0JBQUs7QUFDUDtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDTyxTQUFTLGVBQUk7QUFDcEI7QUFDQTtBQUNPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRU87QUFDUCxzQzs7Ozs7Ozs7QUN6QmU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDOztBQ0x3RTtBQUNqQztBQUNBO0FBQ0E7QUFDVDtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNBLE1BQU0sbUNBQWdCO0FBQ3RCLFNBQVMsOEJBQVc7QUFDM0I7QUFDQTtBQUNPLFNBQVMsOEJBQVc7QUFDM0IsU0FBUyxJQUFJO0FBQ2I7QUFDTyxTQUFTLGdDQUFhO0FBQzdCO0FBQ0EsRUFBRSxNQUFNO0FBQ1IsRUFBRSxNQUFNO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ08sU0FBUyxnQ0FBYTtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0EsSUFBSTtBQUNKLEVBQUUsTUFBTTtBQUNSO0FBQ0EsU0FBUyw4QkFBVztBQUNwQjtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ08sU0FBUyxvQ0FBaUI7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0osRUFBRSxNQUFNO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLEVBQUUsb0NBQWlCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxxQkFBcUIsZ0NBQWE7QUFDbEM7QUFDQTtBQUNBLG9CQUFvQixnQ0FBYTtBQUNqQztBQUNBO0FBQ0E7QUFDTyxTQUFTLGdDQUFhO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKLGFBQWEscUJBQVU7QUFDdkIsRUFBRSwwQkFBYztBQUNoQixFQUFFLHdCQUFZO0FBQ2QsRUFBRSx3QkFBWTtBQUNkO0FBQ0EsRUFBRSxzQkFBVTs7QUFFWjtBQUNBLElBQUksMEJBQWMsU0FBUyx1QkFBVztBQUN0Qzs7QUFFQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLFdBQVcsaUNBQWMsQ0FBQyxtQ0FBZ0I7QUFDMUMsSUFBSTs7QUFFSjtBQUNBLFdBQVcsaUNBQWM7QUFDekI7O0FBRUE7QUFDQTtBQUNBLHdCQUF3QixpQ0FBYztBQUN0Qzs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxnR0FBZ0csS0FBSztBQUNyRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ08sU0FBUyxzQ0FBbUI7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDTyxTQUFTLGlDQUFjO0FBQzlCO0FBQ0E7QUFDTyxTQUFTLGlDQUFjO0FBQzlCO0FBQ0E7QUFDTyxTQUFTLGdDQUFhO0FBQzdCO0FBQ0EsRUFBRSxNQUFNO0FBQ1IsU0FBUyxlQUFlO0FBQ3hCO0FBQ08sU0FBUyxnQ0FBYTtBQUM3QjtBQUNBLEVBQUUsTUFBTTs7QUFFUjtBQUNBLGtCQUFrQixlQUFlO0FBQ2pDO0FBQ0E7O0FBRUEsaUJBQWlCLGVBQWU7QUFDaEMsaUJBQWlCLGVBQWU7QUFDaEM7QUFDQTtBQUNBO0FBQ0EsU0FBUyxxQkFBUztBQUNsQjtBQUNBLDhDOztBQ3BNOEI7QUFDYTtBQUN1QztBQUNuRSxTQUFTLG9CQUFTO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxhQUFhLGdDQUFhLFFBQVEsS0FBSyxTQUFTLFlBQVksRUFBRSxZQUFZO0FBQzFFLGFBQWEsZ0NBQWEsUUFBUSxLQUFLLFNBQVMsWUFBWSxFQUFFLFlBQVk7QUFDMUU7QUFDQTtBQUNBLEVBQUUsTUFBTTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsZ0NBQWE7QUFDcEMsaUNBQWlDLElBQUk7QUFDckMsRUFBRSxNQUFNO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxFQUFFLE1BQU07QUFDUjtBQUNBO0FBQ0Esc0M7O0FDL0NxRDtBQUNkO0FBQ1E7QUFDL0MsTUFBTSw2QkFBa0I7QUFDVCxTQUFTLG9CQUFTO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0RBQXdELDZCQUFrQjtBQUMxRSxnREFBZ0QsNkJBQWtCOztBQUVsRTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKLGlCQUFpQixlQUFlO0FBQ2hDLGlCQUFpQixlQUFlO0FBQ2hDO0FBQ0E7QUFDQSxnQkFBZ0IscUJBQVM7QUFDekIsaUJBQWlCLGdDQUFhO0FBQzlCO0FBQ0E7QUFDQTtBQUNBLHNDOztBQzVDd0U7QUFDOUI7QUFDOEs7QUFDbkw7QUFDQTtBQUNFO0FBQ0E7QUFDQTtBQUN4QjtBQUNmO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUwsMkRBQTJEO0FBQzNEO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUwseURBQXlEO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxnQ0FBZ0M7QUFDaEM7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxnQ0FBZ0M7QUFDaEM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0EsaUQ7O0FDM1FxRDtBQUNaO0FBQ3pDLE1BQU0sa0NBQVM7QUFDQTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0EsZ0JBQWdCLEdBQUc7QUFDbkI7O0FBRUE7QUFDQSxjQUFjLEdBQUc7QUFDakI7O0FBRUEsa0JBQWtCLElBQUksVUFBVSxrQ0FBUzs7QUFFekM7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0Esd0JBQXdCLGdDQUFhOztBQUVyQztBQUNBO0FBQ0EsTUFBTTtBQUNOLDBCQUEwQixnQ0FBYSxLQUFLLGtDQUFTOztBQUVyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0Q7O0FDdERvQztBQUMwRDtBQUN2RDtBQUN2QztBQUNBLGtDQUFrQyxpRkFBaUM7QUFDbkU7QUFDQTtBQUNBO0FBQ0E7QUFDZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUCxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkM7O0FDOUdrRDtBQUN1QjtBQUNyQjtBQUNBO0FBQzJCO0FBQ0E7QUFDMk47QUFDMVMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly92dWUzLXdlYnBhY2s1Ly4vbm9kZV9tb2R1bGVzL0BtYXRoLmdsL3dlYi1tZXJjYXRvci9kaXN0L2VzbS9tYXRoLXV0aWxzLmpzPzYzZDgiLCJ3ZWJwYWNrOi8vdnVlMy13ZWJwYWNrNS8uL25vZGVfbW9kdWxlcy9AbWF0aC5nbC93ZWItbWVyY2F0b3IvZGlzdC9lc20vYXNzZXJ0LmpzP2E5ZTkiLCJ3ZWJwYWNrOi8vdnVlMy13ZWJwYWNrNS8uL25vZGVfbW9kdWxlcy9AbWF0aC5nbC93ZWItbWVyY2F0b3IvZGlzdC9lc20vd2ViLW1lcmNhdG9yLXV0aWxzLmpzPzg3ZWYiLCJ3ZWJwYWNrOi8vdnVlMy13ZWJwYWNrNS8uL25vZGVfbW9kdWxlcy9AbWF0aC5nbC93ZWItbWVyY2F0b3IvZGlzdC9lc20vZml0LWJvdW5kcy5qcz9kMWZmIiwid2VicGFjazovL3Z1ZTMtd2VicGFjazUvLi9ub2RlX21vZHVsZXMvQG1hdGguZ2wvd2ViLW1lcmNhdG9yL2Rpc3QvZXNtL2dldC1ib3VuZHMuanM/OWMwNyIsIndlYnBhY2s6Ly92dWUzLXdlYnBhY2s1Ly4vbm9kZV9tb2R1bGVzL0BtYXRoLmdsL3dlYi1tZXJjYXRvci9kaXN0L2VzbS93ZWItbWVyY2F0b3Itdmlld3BvcnQuanM/NTJjMiIsIndlYnBhY2s6Ly92dWUzLXdlYnBhY2s1Ly4vbm9kZV9tb2R1bGVzL0BtYXRoLmdsL3dlYi1tZXJjYXRvci9kaXN0L2VzbS9ub3JtYWxpemUtdmlld3BvcnQtcHJvcHMuanM/MzA0MSIsIndlYnBhY2s6Ly92dWUzLXdlYnBhY2s1Ly4vbm9kZV9tb2R1bGVzL0BtYXRoLmdsL3dlYi1tZXJjYXRvci9kaXN0L2VzbS9mbHktdG8tdmlld3BvcnQuanM/YmU5MSIsIndlYnBhY2s6Ly92dWUzLXdlYnBhY2s1Ly4vbm9kZV9tb2R1bGVzL0BtYXRoLmdsL3dlYi1tZXJjYXRvci9kaXN0L2VzbS9pbmRleC5qcz9iYjE2Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IHRyYW5zZm9ybU1hdDQsIHNjYWxlIH0gZnJvbSAnZ2wtbWF0cml4L3ZlYzQnO1xuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZU1hdDQoKSB7XG4gIHJldHVybiBbMSwgMCwgMCwgMCwgMCwgMSwgMCwgMCwgMCwgMCwgMSwgMCwgMCwgMCwgMCwgMV07XG59XG5leHBvcnQgZnVuY3Rpb24gdHJhbnNmb3JtVmVjdG9yKG1hdHJpeCwgdmVjdG9yKSB7XG4gIGNvbnN0IHJlc3VsdCA9IHRyYW5zZm9ybU1hdDQoW10sIHZlY3RvciwgbWF0cml4KTtcbiAgc2NhbGUocmVzdWx0LCByZXN1bHQsIDEgLyByZXN1bHRbM10pO1xuICByZXR1cm4gcmVzdWx0O1xufVxuZXhwb3J0IGZ1bmN0aW9uIG1vZCh2YWx1ZSwgZGl2aXNvcikge1xuICBjb25zdCBtb2R1bHVzID0gdmFsdWUgJSBkaXZpc29yO1xuICByZXR1cm4gbW9kdWx1cyA8IDAgPyBkaXZpc29yICsgbW9kdWx1cyA6IG1vZHVsdXM7XG59XG5leHBvcnQgZnVuY3Rpb24gbGVycChzdGFydCwgZW5kLCBzdGVwKSB7XG4gIHJldHVybiBzdGVwICogZW5kICsgKDEgLSBzdGVwKSAqIHN0YXJ0O1xufVxuZXhwb3J0IGZ1bmN0aW9uIGNsYW1wKHgsIG1pbiwgbWF4KSB7XG4gIHJldHVybiB4IDwgbWluID8gbWluIDogeCA+IG1heCA/IG1heCA6IHg7XG59XG5cbmZ1bmN0aW9uIGllTG9nMih4KSB7XG4gIHJldHVybiBNYXRoLmxvZyh4KSAqIE1hdGguTE9HMkU7XG59XG5cbmV4cG9ydCBjb25zdCBsb2cyID0gTWF0aC5sb2cyIHx8IGllTG9nMjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW1hdGgtdXRpbHMuanMubWFwIiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gYXNzZXJ0KGNvbmRpdGlvbiwgbWVzc2FnZSkge1xuICBpZiAoIWNvbmRpdGlvbikge1xuICAgIHRocm93IG5ldyBFcnJvcihtZXNzYWdlIHx8ICdAbWF0aC5nbC93ZWItbWVyY2F0b3I6IGFzc2VydGlvbiBmYWlsZWQuJyk7XG4gIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWFzc2VydC5qcy5tYXAiLCJpbXBvcnQgeyBjcmVhdGVNYXQ0LCB0cmFuc2Zvcm1WZWN0b3IsIGNsYW1wLCBsb2cyIH0gZnJvbSAnLi9tYXRoLXV0aWxzJztcbmltcG9ydCAqIGFzIG1hdDQgZnJvbSAnZ2wtbWF0cml4L21hdDQnO1xuaW1wb3J0ICogYXMgdmVjMiBmcm9tICdnbC1tYXRyaXgvdmVjMic7XG5pbXBvcnQgKiBhcyB2ZWMzIGZyb20gJ2dsLW1hdHJpeC92ZWMzJztcbmltcG9ydCBhc3NlcnQgZnJvbSAnLi9hc3NlcnQnO1xuY29uc3QgUEkgPSBNYXRoLlBJO1xuY29uc3QgUElfNCA9IFBJIC8gNDtcbmNvbnN0IERFR1JFRVNfVE9fUkFESUFOUyA9IFBJIC8gMTgwO1xuY29uc3QgUkFESUFOU19UT19ERUdSRUVTID0gMTgwIC8gUEk7XG5jb25zdCBUSUxFX1NJWkUgPSA1MTI7XG5jb25zdCBFQVJUSF9DSVJDVU1GRVJFTkNFID0gNDAuMDNlNjtcbmV4cG9ydCBjb25zdCBNQVhfTEFUSVRVREUgPSA4NS4wNTExMjk7XG5leHBvcnQgY29uc3QgREVGQVVMVF9BTFRJVFVERSA9IDEuNTtcbmV4cG9ydCBmdW5jdGlvbiB6b29tVG9TY2FsZSh6b29tKSB7XG4gIHJldHVybiBNYXRoLnBvdygyLCB6b29tKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBzY2FsZVRvWm9vbShzY2FsZSkge1xuICByZXR1cm4gbG9nMihzY2FsZSk7XG59XG5leHBvcnQgZnVuY3Rpb24gbG5nTGF0VG9Xb3JsZChsbmdMYXQpIHtcbiAgY29uc3QgW2xuZywgbGF0XSA9IGxuZ0xhdDtcbiAgYXNzZXJ0KE51bWJlci5pc0Zpbml0ZShsbmcpKTtcbiAgYXNzZXJ0KE51bWJlci5pc0Zpbml0ZShsYXQpICYmIGxhdCA+PSAtOTAgJiYgbGF0IDw9IDkwLCAnaW52YWxpZCBsYXRpdHVkZScpO1xuICBjb25zdCBsYW1iZGEyID0gbG5nICogREVHUkVFU19UT19SQURJQU5TO1xuICBjb25zdCBwaGkyID0gbGF0ICogREVHUkVFU19UT19SQURJQU5TO1xuICBjb25zdCB4ID0gVElMRV9TSVpFICogKGxhbWJkYTIgKyBQSSkgLyAoMiAqIFBJKTtcbiAgY29uc3QgeSA9IFRJTEVfU0laRSAqIChQSSArIE1hdGgubG9nKE1hdGgudGFuKFBJXzQgKyBwaGkyICogMC41KSkpIC8gKDIgKiBQSSk7XG4gIHJldHVybiBbeCwgeV07XG59XG5leHBvcnQgZnVuY3Rpb24gd29ybGRUb0xuZ0xhdCh4eSkge1xuICBjb25zdCBbeCwgeV0gPSB4eTtcbiAgY29uc3QgbGFtYmRhMiA9IHggLyBUSUxFX1NJWkUgKiAoMiAqIFBJKSAtIFBJO1xuICBjb25zdCBwaGkyID0gMiAqIChNYXRoLmF0YW4oTWF0aC5leHAoeSAvIFRJTEVfU0laRSAqICgyICogUEkpIC0gUEkpKSAtIFBJXzQpO1xuICByZXR1cm4gW2xhbWJkYTIgKiBSQURJQU5TX1RPX0RFR1JFRVMsIHBoaTIgKiBSQURJQU5TX1RPX0RFR1JFRVNdO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGdldE1ldGVyWm9vbShvcHRpb25zKSB7XG4gIGNvbnN0IHtcbiAgICBsYXRpdHVkZVxuICB9ID0gb3B0aW9ucztcbiAgYXNzZXJ0KE51bWJlci5pc0Zpbml0ZShsYXRpdHVkZSkpO1xuICBjb25zdCBsYXRDb3NpbmUgPSBNYXRoLmNvcyhsYXRpdHVkZSAqIERFR1JFRVNfVE9fUkFESUFOUyk7XG4gIHJldHVybiBzY2FsZVRvWm9vbShFQVJUSF9DSVJDVU1GRVJFTkNFICogbGF0Q29zaW5lKSAtIDk7XG59XG5leHBvcnQgZnVuY3Rpb24gdW5pdHNQZXJNZXRlcihsYXRpdHVkZSkge1xuICBjb25zdCBsYXRDb3NpbmUgPSBNYXRoLmNvcyhsYXRpdHVkZSAqIERFR1JFRVNfVE9fUkFESUFOUyk7XG4gIHJldHVybiBUSUxFX1NJWkUgLyBFQVJUSF9DSVJDVU1GRVJFTkNFIC8gbGF0Q29zaW5lO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGdldERpc3RhbmNlU2NhbGVzKG9wdGlvbnMpIHtcbiAgY29uc3Qge1xuICAgIGxhdGl0dWRlLFxuICAgIGxvbmdpdHVkZSxcbiAgICBoaWdoUHJlY2lzaW9uID0gZmFsc2VcbiAgfSA9IG9wdGlvbnM7XG4gIGFzc2VydChOdW1iZXIuaXNGaW5pdGUobGF0aXR1ZGUpICYmIE51bWJlci5pc0Zpbml0ZShsb25naXR1ZGUpKTtcbiAgY29uc3Qgd29ybGRTaXplID0gVElMRV9TSVpFO1xuICBjb25zdCBsYXRDb3NpbmUgPSBNYXRoLmNvcyhsYXRpdHVkZSAqIERFR1JFRVNfVE9fUkFESUFOUyk7XG4gIGNvbnN0IHVuaXRzUGVyRGVncmVlWCA9IHdvcmxkU2l6ZSAvIDM2MDtcbiAgY29uc3QgdW5pdHNQZXJEZWdyZWVZID0gdW5pdHNQZXJEZWdyZWVYIC8gbGF0Q29zaW5lO1xuICBjb25zdCBhbHRVbml0c1Blck1ldGVyID0gd29ybGRTaXplIC8gRUFSVEhfQ0lSQ1VNRkVSRU5DRSAvIGxhdENvc2luZTtcbiAgY29uc3QgcmVzdWx0ID0ge1xuICAgIHVuaXRzUGVyTWV0ZXI6IFthbHRVbml0c1Blck1ldGVyLCBhbHRVbml0c1Blck1ldGVyLCBhbHRVbml0c1Blck1ldGVyXSxcbiAgICBtZXRlcnNQZXJVbml0OiBbMSAvIGFsdFVuaXRzUGVyTWV0ZXIsIDEgLyBhbHRVbml0c1Blck1ldGVyLCAxIC8gYWx0VW5pdHNQZXJNZXRlcl0sXG4gICAgdW5pdHNQZXJEZWdyZWU6IFt1bml0c1BlckRlZ3JlZVgsIHVuaXRzUGVyRGVncmVlWSwgYWx0VW5pdHNQZXJNZXRlcl0sXG4gICAgZGVncmVlc1BlclVuaXQ6IFsxIC8gdW5pdHNQZXJEZWdyZWVYLCAxIC8gdW5pdHNQZXJEZWdyZWVZLCAxIC8gYWx0VW5pdHNQZXJNZXRlcl1cbiAgfTtcblxuICBpZiAoaGlnaFByZWNpc2lvbikge1xuICAgIGNvbnN0IGxhdENvc2luZTIgPSBERUdSRUVTX1RPX1JBRElBTlMgKiBNYXRoLnRhbihsYXRpdHVkZSAqIERFR1JFRVNfVE9fUkFESUFOUykgLyBsYXRDb3NpbmU7XG4gICAgY29uc3QgdW5pdHNQZXJEZWdyZWVZMiA9IHVuaXRzUGVyRGVncmVlWCAqIGxhdENvc2luZTIgLyAyO1xuICAgIGNvbnN0IGFsdFVuaXRzUGVyRGVncmVlMiA9IHdvcmxkU2l6ZSAvIEVBUlRIX0NJUkNVTUZFUkVOQ0UgKiBsYXRDb3NpbmUyO1xuICAgIGNvbnN0IGFsdFVuaXRzUGVyTWV0ZXIyID0gYWx0VW5pdHNQZXJEZWdyZWUyIC8gdW5pdHNQZXJEZWdyZWVZICogYWx0VW5pdHNQZXJNZXRlcjtcbiAgICByZXN1bHQudW5pdHNQZXJEZWdyZWUyID0gWzAsIHVuaXRzUGVyRGVncmVlWTIsIGFsdFVuaXRzUGVyRGVncmVlMl07XG4gICAgcmVzdWx0LnVuaXRzUGVyTWV0ZXIyID0gW2FsdFVuaXRzUGVyTWV0ZXIyLCAwLCBhbHRVbml0c1Blck1ldGVyMl07XG4gIH1cblxuICByZXR1cm4gcmVzdWx0O1xufVxuZXhwb3J0IGZ1bmN0aW9uIGFkZE1ldGVyc1RvTG5nTGF0KGxuZ0xhdFosIHh5eikge1xuICBjb25zdCBbbG9uZ2l0dWRlLCBsYXRpdHVkZSwgejBdID0gbG5nTGF0WjtcbiAgY29uc3QgW3gsIHksIHpdID0geHl6O1xuICBjb25zdCB7XG4gICAgdW5pdHNQZXJNZXRlcixcbiAgICB1bml0c1Blck1ldGVyMlxuICB9ID0gZ2V0RGlzdGFuY2VTY2FsZXMoe1xuICAgIGxvbmdpdHVkZSxcbiAgICBsYXRpdHVkZSxcbiAgICBoaWdoUHJlY2lzaW9uOiB0cnVlXG4gIH0pO1xuICBjb25zdCB3b3JsZHNwYWNlID0gbG5nTGF0VG9Xb3JsZChsbmdMYXRaKTtcbiAgd29ybGRzcGFjZVswXSArPSB4ICogKHVuaXRzUGVyTWV0ZXJbMF0gKyB1bml0c1Blck1ldGVyMlswXSAqIHkpO1xuICB3b3JsZHNwYWNlWzFdICs9IHkgKiAodW5pdHNQZXJNZXRlclsxXSArIHVuaXRzUGVyTWV0ZXIyWzFdICogeSk7XG4gIGNvbnN0IG5ld0xuZ0xhdCA9IHdvcmxkVG9MbmdMYXQod29ybGRzcGFjZSk7XG4gIGNvbnN0IG5ld1ogPSAoejAgfHwgMCkgKyAoeiB8fCAwKTtcbiAgcmV0dXJuIE51bWJlci5pc0Zpbml0ZSh6MCkgfHwgTnVtYmVyLmlzRmluaXRlKHopID8gW25ld0xuZ0xhdFswXSwgbmV3TG5nTGF0WzFdLCBuZXdaXSA6IG5ld0xuZ0xhdDtcbn1cbmV4cG9ydCBmdW5jdGlvbiBnZXRWaWV3TWF0cml4KG9wdGlvbnMpIHtcbiAgY29uc3Qge1xuICAgIGhlaWdodCxcbiAgICBwaXRjaCxcbiAgICBiZWFyaW5nLFxuICAgIGFsdGl0dWRlLFxuICAgIHNjYWxlLFxuICAgIGNlbnRlclxuICB9ID0gb3B0aW9ucztcbiAgY29uc3Qgdm0gPSBjcmVhdGVNYXQ0KCk7XG4gIG1hdDQudHJhbnNsYXRlKHZtLCB2bSwgWzAsIDAsIC1hbHRpdHVkZV0pO1xuICBtYXQ0LnJvdGF0ZVgodm0sIHZtLCAtcGl0Y2ggKiBERUdSRUVTX1RPX1JBRElBTlMpO1xuICBtYXQ0LnJvdGF0ZVoodm0sIHZtLCBiZWFyaW5nICogREVHUkVFU19UT19SQURJQU5TKTtcbiAgY29uc3QgcmVsYXRpdmVTY2FsZSA9IHNjYWxlIC8gaGVpZ2h0O1xuICBtYXQ0LnNjYWxlKHZtLCB2bSwgW3JlbGF0aXZlU2NhbGUsIHJlbGF0aXZlU2NhbGUsIHJlbGF0aXZlU2NhbGVdKTtcblxuICBpZiAoY2VudGVyKSB7XG4gICAgbWF0NC50cmFuc2xhdGUodm0sIHZtLCB2ZWMzLm5lZ2F0ZShbXSwgY2VudGVyKSk7XG4gIH1cblxuICByZXR1cm4gdm07XG59XG5leHBvcnQgZnVuY3Rpb24gZ2V0UHJvamVjdGlvblBhcmFtZXRlcnMob3B0aW9ucykge1xuICBjb25zdCB7XG4gICAgd2lkdGgsXG4gICAgaGVpZ2h0LFxuICAgIGFsdGl0dWRlLFxuICAgIHBpdGNoID0gMCxcbiAgICBvZmZzZXQsXG4gICAgY2VudGVyLFxuICAgIHNjYWxlLFxuICAgIG5lYXJaTXVsdGlwbGllciA9IDEsXG4gICAgZmFyWk11bHRpcGxpZXIgPSAxXG4gIH0gPSBvcHRpb25zO1xuICBsZXQge1xuICAgIGZvdnkgPSBhbHRpdHVkZVRvRm92eShERUZBVUxUX0FMVElUVURFKVxuICB9ID0gb3B0aW9ucztcblxuICBpZiAoYWx0aXR1ZGUgIT09IHVuZGVmaW5lZCkge1xuICAgIGZvdnkgPSBhbHRpdHVkZVRvRm92eShhbHRpdHVkZSk7XG4gIH1cblxuICBjb25zdCBmb3ZSYWRpYW5zID0gZm92eSAqIERFR1JFRVNfVE9fUkFESUFOUztcbiAgY29uc3QgcGl0Y2hSYWRpYW5zID0gcGl0Y2ggKiBERUdSRUVTX1RPX1JBRElBTlM7XG4gIGNvbnN0IGZvY2FsRGlzdGFuY2UgPSBmb3Z5VG9BbHRpdHVkZShmb3Z5KTtcbiAgbGV0IGNhbWVyYVRvU2VhTGV2ZWxEaXN0YW5jZSA9IGZvY2FsRGlzdGFuY2U7XG5cbiAgaWYgKGNlbnRlcikge1xuICAgIGNhbWVyYVRvU2VhTGV2ZWxEaXN0YW5jZSArPSBjZW50ZXJbMl0gKiBzY2FsZSAvIE1hdGguY29zKHBpdGNoUmFkaWFucykgLyBoZWlnaHQ7XG4gIH1cblxuICBjb25zdCBmb3ZBYm92ZUNlbnRlciA9IGZvdlJhZGlhbnMgKiAoMC41ICsgKG9mZnNldCA/IG9mZnNldFsxXSA6IDApIC8gaGVpZ2h0KTtcbiAgY29uc3QgdG9wSGFsZlN1cmZhY2VEaXN0YW5jZSA9IE1hdGguc2luKGZvdkFib3ZlQ2VudGVyKSAqIGNhbWVyYVRvU2VhTGV2ZWxEaXN0YW5jZSAvIE1hdGguc2luKGNsYW1wKE1hdGguUEkgLyAyIC0gcGl0Y2hSYWRpYW5zIC0gZm92QWJvdmVDZW50ZXIsIDAuMDEsIE1hdGguUEkgLSAwLjAxKSk7XG4gIGNvbnN0IGZ1cnRoZXN0RGlzdGFuY2UgPSBNYXRoLnNpbihwaXRjaFJhZGlhbnMpICogdG9wSGFsZlN1cmZhY2VEaXN0YW5jZSArIGNhbWVyYVRvU2VhTGV2ZWxEaXN0YW5jZTtcbiAgY29uc3QgaG9yaXpvbkRpc3RhbmNlID0gY2FtZXJhVG9TZWFMZXZlbERpc3RhbmNlICogMTA7XG4gIGNvbnN0IGZhclogPSBNYXRoLm1pbihmdXJ0aGVzdERpc3RhbmNlICogZmFyWk11bHRpcGxpZXIsIGhvcml6b25EaXN0YW5jZSk7XG4gIHJldHVybiB7XG4gICAgZm92OiBmb3ZSYWRpYW5zLFxuICAgIGFzcGVjdDogd2lkdGggLyBoZWlnaHQsXG4gICAgZm9jYWxEaXN0YW5jZSxcbiAgICBuZWFyOiBuZWFyWk11bHRpcGxpZXIsXG4gICAgZmFyOiBmYXJaXG4gIH07XG59XG5leHBvcnQgZnVuY3Rpb24gZ2V0UHJvamVjdGlvbk1hdHJpeChvcHRpb25zKSB7XG4gIGNvbnN0IHtcbiAgICBmb3YsXG4gICAgYXNwZWN0LFxuICAgIG5lYXIsXG4gICAgZmFyXG4gIH0gPSBnZXRQcm9qZWN0aW9uUGFyYW1ldGVycyhvcHRpb25zKTtcbiAgY29uc3QgcHJvamVjdGlvbk1hdHJpeCA9IG1hdDQucGVyc3BlY3RpdmUoW10sIGZvdiwgYXNwZWN0LCBuZWFyLCBmYXIpO1xuICByZXR1cm4gcHJvamVjdGlvbk1hdHJpeDtcbn1cbmV4cG9ydCBmdW5jdGlvbiBhbHRpdHVkZVRvRm92eShhbHRpdHVkZSkge1xuICByZXR1cm4gMiAqIE1hdGguYXRhbigwLjUgLyBhbHRpdHVkZSkgKiBSQURJQU5TX1RPX0RFR1JFRVM7XG59XG5leHBvcnQgZnVuY3Rpb24gZm92eVRvQWx0aXR1ZGUoZm92eSkge1xuICByZXR1cm4gMC41IC8gTWF0aC50YW4oMC41ICogZm92eSAqIERFR1JFRVNfVE9fUkFESUFOUyk7XG59XG5leHBvcnQgZnVuY3Rpb24gd29ybGRUb1BpeGVscyh4eXosIHBpeGVsUHJvamVjdGlvbk1hdHJpeCkge1xuICBjb25zdCBbeCwgeSwgeiA9IDBdID0geHl6O1xuICBhc3NlcnQoTnVtYmVyLmlzRmluaXRlKHgpICYmIE51bWJlci5pc0Zpbml0ZSh5KSAmJiBOdW1iZXIuaXNGaW5pdGUoeikpO1xuICByZXR1cm4gdHJhbnNmb3JtVmVjdG9yKHBpeGVsUHJvamVjdGlvbk1hdHJpeCwgW3gsIHksIHosIDFdKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBwaXhlbHNUb1dvcmxkKHh5eiwgcGl4ZWxVbnByb2plY3Rpb25NYXRyaXgsIHRhcmdldFogPSAwKSB7XG4gIGNvbnN0IFt4LCB5LCB6XSA9IHh5ejtcbiAgYXNzZXJ0KE51bWJlci5pc0Zpbml0ZSh4KSAmJiBOdW1iZXIuaXNGaW5pdGUoeSksICdpbnZhbGlkIHBpeGVsIGNvb3JkaW5hdGUnKTtcblxuICBpZiAoTnVtYmVyLmlzRmluaXRlKHopKSB7XG4gICAgY29uc3QgY29vcmQgPSB0cmFuc2Zvcm1WZWN0b3IocGl4ZWxVbnByb2plY3Rpb25NYXRyaXgsIFt4LCB5LCB6LCAxXSk7XG4gICAgcmV0dXJuIGNvb3JkO1xuICB9XG5cbiAgY29uc3QgY29vcmQwID0gdHJhbnNmb3JtVmVjdG9yKHBpeGVsVW5wcm9qZWN0aW9uTWF0cml4LCBbeCwgeSwgMCwgMV0pO1xuICBjb25zdCBjb29yZDEgPSB0cmFuc2Zvcm1WZWN0b3IocGl4ZWxVbnByb2plY3Rpb25NYXRyaXgsIFt4LCB5LCAxLCAxXSk7XG4gIGNvbnN0IHowID0gY29vcmQwWzJdO1xuICBjb25zdCB6MSA9IGNvb3JkMVsyXTtcbiAgY29uc3QgdCA9IHowID09PSB6MSA/IDAgOiAoKHRhcmdldFogfHwgMCkgLSB6MCkgLyAoejEgLSB6MCk7XG4gIHJldHVybiB2ZWMyLmxlcnAoW10sIGNvb3JkMCwgY29vcmQxLCB0KTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXdlYi1tZXJjYXRvci11dGlscy5qcy5tYXAiLCJpbXBvcnQgYXNzZXJ0IGZyb20gJy4vYXNzZXJ0JztcbmltcG9ydCB7IGxvZzIsIGNsYW1wIH0gZnJvbSAnLi9tYXRoLXV0aWxzJztcbmltcG9ydCB7IE1BWF9MQVRJVFVERSwgbG5nTGF0VG9Xb3JsZCwgd29ybGRUb0xuZ0xhdCB9IGZyb20gJy4vd2ViLW1lcmNhdG9yLXV0aWxzJztcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGZpdEJvdW5kcyhvcHRpb25zKSB7XG4gIGNvbnN0IHtcbiAgICB3aWR0aCxcbiAgICBoZWlnaHQsXG4gICAgYm91bmRzLFxuICAgIG1pbkV4dGVudCA9IDAsXG4gICAgbWF4Wm9vbSA9IDI0LFxuICAgIG9mZnNldCA9IFswLCAwXVxuICB9ID0gb3B0aW9ucztcbiAgY29uc3QgW1t3ZXN0LCBzb3V0aF0sIFtlYXN0LCBub3J0aF1dID0gYm91bmRzO1xuICBjb25zdCBwYWRkaW5nID0gZ2V0UGFkZGluZ09iamVjdChvcHRpb25zLnBhZGRpbmcpO1xuICBjb25zdCBudyA9IGxuZ0xhdFRvV29ybGQoW3dlc3QsIGNsYW1wKG5vcnRoLCAtTUFYX0xBVElUVURFLCBNQVhfTEFUSVRVREUpXSk7XG4gIGNvbnN0IHNlID0gbG5nTGF0VG9Xb3JsZChbZWFzdCwgY2xhbXAoc291dGgsIC1NQVhfTEFUSVRVREUsIE1BWF9MQVRJVFVERSldKTtcbiAgY29uc3Qgc2l6ZSA9IFtNYXRoLm1heChNYXRoLmFicyhzZVswXSAtIG53WzBdKSwgbWluRXh0ZW50KSwgTWF0aC5tYXgoTWF0aC5hYnMoc2VbMV0gLSBud1sxXSksIG1pbkV4dGVudCldO1xuICBjb25zdCB0YXJnZXRTaXplID0gW3dpZHRoIC0gcGFkZGluZy5sZWZ0IC0gcGFkZGluZy5yaWdodCAtIE1hdGguYWJzKG9mZnNldFswXSkgKiAyLCBoZWlnaHQgLSBwYWRkaW5nLnRvcCAtIHBhZGRpbmcuYm90dG9tIC0gTWF0aC5hYnMob2Zmc2V0WzFdKSAqIDJdO1xuICBhc3NlcnQodGFyZ2V0U2l6ZVswXSA+IDAgJiYgdGFyZ2V0U2l6ZVsxXSA+IDApO1xuICBjb25zdCBzY2FsZVggPSB0YXJnZXRTaXplWzBdIC8gc2l6ZVswXTtcbiAgY29uc3Qgc2NhbGVZID0gdGFyZ2V0U2l6ZVsxXSAvIHNpemVbMV07XG4gIGNvbnN0IG9mZnNldFggPSAocGFkZGluZy5yaWdodCAtIHBhZGRpbmcubGVmdCkgLyAyIC8gc2NhbGVYO1xuICBjb25zdCBvZmZzZXRZID0gKHBhZGRpbmcudG9wIC0gcGFkZGluZy5ib3R0b20pIC8gMiAvIHNjYWxlWTtcbiAgY29uc3QgY2VudGVyID0gWyhzZVswXSArIG53WzBdKSAvIDIgKyBvZmZzZXRYLCAoc2VbMV0gKyBud1sxXSkgLyAyICsgb2Zmc2V0WV07XG4gIGNvbnN0IGNlbnRlckxuZ0xhdCA9IHdvcmxkVG9MbmdMYXQoY2VudGVyKTtcbiAgY29uc3Qgem9vbSA9IE1hdGgubWluKG1heFpvb20sIGxvZzIoTWF0aC5hYnMoTWF0aC5taW4oc2NhbGVYLCBzY2FsZVkpKSkpO1xuICBhc3NlcnQoTnVtYmVyLmlzRmluaXRlKHpvb20pKTtcbiAgcmV0dXJuIHtcbiAgICBsb25naXR1ZGU6IGNlbnRlckxuZ0xhdFswXSxcbiAgICBsYXRpdHVkZTogY2VudGVyTG5nTGF0WzFdLFxuICAgIHpvb21cbiAgfTtcbn1cblxuZnVuY3Rpb24gZ2V0UGFkZGluZ09iamVjdChwYWRkaW5nID0gMCkge1xuICBpZiAodHlwZW9mIHBhZGRpbmcgPT09ICdudW1iZXInKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHRvcDogcGFkZGluZyxcbiAgICAgIGJvdHRvbTogcGFkZGluZyxcbiAgICAgIGxlZnQ6IHBhZGRpbmcsXG4gICAgICByaWdodDogcGFkZGluZ1xuICAgIH07XG4gIH1cblxuICBhc3NlcnQoTnVtYmVyLmlzRmluaXRlKHBhZGRpbmcudG9wKSAmJiBOdW1iZXIuaXNGaW5pdGUocGFkZGluZy5ib3R0b20pICYmIE51bWJlci5pc0Zpbml0ZShwYWRkaW5nLmxlZnQpICYmIE51bWJlci5pc0Zpbml0ZShwYWRkaW5nLnJpZ2h0KSk7XG4gIHJldHVybiBwYWRkaW5nO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Zml0LWJvdW5kcy5qcy5tYXAiLCJpbXBvcnQgeyB3b3JsZFRvTG5nTGF0IH0gZnJvbSAnLi93ZWItbWVyY2F0b3ItdXRpbHMnO1xuaW1wb3J0ICogYXMgdmVjMiBmcm9tICdnbC1tYXRyaXgvdmVjMic7XG5pbXBvcnQgeyB0cmFuc2Zvcm1WZWN0b3IgfSBmcm9tICcuL21hdGgtdXRpbHMnO1xuY29uc3QgREVHUkVFU19UT19SQURJQU5TID0gTWF0aC5QSSAvIDE4MDtcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGdldEJvdW5kcyh2aWV3cG9ydCwgeiA9IDApIHtcbiAgY29uc3Qge1xuICAgIHdpZHRoLFxuICAgIGhlaWdodCxcbiAgICB1bnByb2plY3RcbiAgfSA9IHZpZXdwb3J0O1xuICBjb25zdCB1bnByb2plY3RPcHMgPSB7XG4gICAgdGFyZ2V0WjogelxuICB9O1xuICBjb25zdCBib3R0b21MZWZ0ID0gdW5wcm9qZWN0KFswLCBoZWlnaHRdLCB1bnByb2plY3RPcHMpO1xuICBjb25zdCBib3R0b21SaWdodCA9IHVucHJvamVjdChbd2lkdGgsIGhlaWdodF0sIHVucHJvamVjdE9wcyk7XG4gIGxldCB0b3BMZWZ0O1xuICBsZXQgdG9wUmlnaHQ7XG4gIGNvbnN0IGhhbGZGb3YgPSB2aWV3cG9ydC5mb3Z5ID8gMC41ICogdmlld3BvcnQuZm92eSAqIERFR1JFRVNfVE9fUkFESUFOUyA6IE1hdGguYXRhbigwLjUgLyB2aWV3cG9ydC5hbHRpdHVkZSk7XG4gIGNvbnN0IGFuZ2xlVG9Hcm91bmQgPSAoOTAgLSB2aWV3cG9ydC5waXRjaCkgKiBERUdSRUVTX1RPX1JBRElBTlM7XG5cbiAgaWYgKGhhbGZGb3YgPiBhbmdsZVRvR3JvdW5kIC0gMC4wMSkge1xuICAgIHRvcExlZnQgPSB1bnByb2plY3RPbkZhclBsYW5lKHZpZXdwb3J0LCAwLCB6KTtcbiAgICB0b3BSaWdodCA9IHVucHJvamVjdE9uRmFyUGxhbmUodmlld3BvcnQsIHdpZHRoLCB6KTtcbiAgfSBlbHNlIHtcbiAgICB0b3BMZWZ0ID0gdW5wcm9qZWN0KFswLCAwXSwgdW5wcm9qZWN0T3BzKTtcbiAgICB0b3BSaWdodCA9IHVucHJvamVjdChbd2lkdGgsIDBdLCB1bnByb2plY3RPcHMpO1xuICB9XG5cbiAgcmV0dXJuIFtib3R0b21MZWZ0LCBib3R0b21SaWdodCwgdG9wUmlnaHQsIHRvcExlZnRdO1xufVxuXG5mdW5jdGlvbiB1bnByb2plY3RPbkZhclBsYW5lKHZpZXdwb3J0LCB4LCB0YXJnZXRaKSB7XG4gIGNvbnN0IHtcbiAgICBwaXhlbFVucHJvamVjdGlvbk1hdHJpeFxuICB9ID0gdmlld3BvcnQ7XG4gIGNvbnN0IGNvb3JkMCA9IHRyYW5zZm9ybVZlY3RvcihwaXhlbFVucHJvamVjdGlvbk1hdHJpeCwgW3gsIDAsIDEsIDFdKTtcbiAgY29uc3QgY29vcmQxID0gdHJhbnNmb3JtVmVjdG9yKHBpeGVsVW5wcm9qZWN0aW9uTWF0cml4LCBbeCwgdmlld3BvcnQuaGVpZ2h0LCAxLCAxXSk7XG4gIGNvbnN0IHogPSB0YXJnZXRaICogdmlld3BvcnQuZGlzdGFuY2VTY2FsZXMudW5pdHNQZXJNZXRlclsyXTtcbiAgY29uc3QgdCA9ICh6IC0gY29vcmQwWzJdKSAvIChjb29yZDFbMl0gLSBjb29yZDBbMl0pO1xuICBjb25zdCBjb29yZCA9IHZlYzIubGVycChbXSwgY29vcmQwLCBjb29yZDEsIHQpO1xuICBjb25zdCByZXN1bHQgPSB3b3JsZFRvTG5nTGF0KGNvb3JkKTtcbiAgcmVzdWx0LnB1c2godGFyZ2V0Wik7XG4gIHJldHVybiByZXN1bHQ7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1nZXQtYm91bmRzLmpzLm1hcCIsImltcG9ydCBfZGVmaW5lUHJvcGVydHkgZnJvbSBcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL2RlZmluZVByb3BlcnR5XCI7XG5pbXBvcnQgeyBjcmVhdGVNYXQ0IH0gZnJvbSAnLi9tYXRoLXV0aWxzJztcbmltcG9ydCB7IHpvb21Ub1NjYWxlLCBwaXhlbHNUb1dvcmxkLCBsbmdMYXRUb1dvcmxkLCB3b3JsZFRvTG5nTGF0LCB3b3JsZFRvUGl4ZWxzLCBhbHRpdHVkZVRvRm92eSwgZm92eVRvQWx0aXR1ZGUsIERFRkFVTFRfQUxUSVRVREUsIGdldFByb2plY3Rpb25NYXRyaXgsIGdldERpc3RhbmNlU2NhbGVzLCBnZXRWaWV3TWF0cml4IH0gZnJvbSAnLi93ZWItbWVyY2F0b3ItdXRpbHMnO1xuaW1wb3J0IGZpdEJvdW5kcyBmcm9tICcuL2ZpdC1ib3VuZHMnO1xuaW1wb3J0IGdldEJvdW5kcyBmcm9tICcuL2dldC1ib3VuZHMnO1xuaW1wb3J0ICogYXMgbWF0NCBmcm9tICdnbC1tYXRyaXgvbWF0NCc7XG5pbXBvcnQgKiBhcyB2ZWMyIGZyb20gJ2dsLW1hdHJpeC92ZWMyJztcbmltcG9ydCAqIGFzIHZlYzMgZnJvbSAnZ2wtbWF0cml4L3ZlYzMnO1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgV2ViTWVyY2F0b3JWaWV3cG9ydCB7XG4gIGNvbnN0cnVjdG9yKHByb3BzID0ge1xuICAgIHdpZHRoOiAxLFxuICAgIGhlaWdodDogMVxuICB9KSB7XG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwibGF0aXR1ZGVcIiwgdm9pZCAwKTtcblxuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImxvbmdpdHVkZVwiLCB2b2lkIDApO1xuXG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwiem9vbVwiLCB2b2lkIDApO1xuXG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwicGl0Y2hcIiwgdm9pZCAwKTtcblxuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImJlYXJpbmdcIiwgdm9pZCAwKTtcblxuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImFsdGl0dWRlXCIsIHZvaWQgMCk7XG5cbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJmb3Z5XCIsIHZvaWQgMCk7XG5cbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJtZXRlck9mZnNldFwiLCB2b2lkIDApO1xuXG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwiY2VudGVyXCIsIHZvaWQgMCk7XG5cbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJ3aWR0aFwiLCB2b2lkIDApO1xuXG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwiaGVpZ2h0XCIsIHZvaWQgMCk7XG5cbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJzY2FsZVwiLCB2b2lkIDApO1xuXG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwiZGlzdGFuY2VTY2FsZXNcIiwgdm9pZCAwKTtcblxuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInZpZXdNYXRyaXhcIiwgdm9pZCAwKTtcblxuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInByb2plY3Rpb25NYXRyaXhcIiwgdm9pZCAwKTtcblxuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInZpZXdQcm9qZWN0aW9uTWF0cml4XCIsIHZvaWQgMCk7XG5cbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJwaXhlbFByb2plY3Rpb25NYXRyaXhcIiwgdm9pZCAwKTtcblxuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInBpeGVsVW5wcm9qZWN0aW9uTWF0cml4XCIsIHZvaWQgMCk7XG5cbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJlcXVhbHNcIiwgdmlld3BvcnQgPT4ge1xuICAgICAgaWYgKCEodmlld3BvcnQgaW5zdGFuY2VvZiBXZWJNZXJjYXRvclZpZXdwb3J0KSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB2aWV3cG9ydC53aWR0aCA9PT0gdGhpcy53aWR0aCAmJiB2aWV3cG9ydC5oZWlnaHQgPT09IHRoaXMuaGVpZ2h0ICYmIG1hdDQuZXF1YWxzKHZpZXdwb3J0LnByb2plY3Rpb25NYXRyaXgsIHRoaXMucHJvamVjdGlvbk1hdHJpeCkgJiYgbWF0NC5lcXVhbHModmlld3BvcnQudmlld01hdHJpeCwgdGhpcy52aWV3TWF0cml4KTtcbiAgICB9KTtcblxuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInByb2plY3RcIiwgKGxuZ0xhdFosIG9wdGlvbnMgPSB7fSkgPT4ge1xuICAgICAgY29uc3Qge1xuICAgICAgICB0b3BMZWZ0ID0gdHJ1ZVxuICAgICAgfSA9IG9wdGlvbnM7XG4gICAgICBjb25zdCB3b3JsZFBvc2l0aW9uID0gdGhpcy5wcm9qZWN0UG9zaXRpb24obG5nTGF0Wik7XG4gICAgICBjb25zdCBjb29yZCA9IHdvcmxkVG9QaXhlbHMod29ybGRQb3NpdGlvbiwgdGhpcy5waXhlbFByb2plY3Rpb25NYXRyaXgpO1xuICAgICAgY29uc3QgW3gsIHldID0gY29vcmQ7XG4gICAgICBjb25zdCB5MiA9IHRvcExlZnQgPyB5IDogdGhpcy5oZWlnaHQgLSB5O1xuICAgICAgcmV0dXJuIGxuZ0xhdFoubGVuZ3RoID09PSAyID8gW3gsIHkyXSA6IFt4LCB5MiwgY29vcmRbMl1dO1xuICAgIH0pO1xuXG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwidW5wcm9qZWN0XCIsICh4eXosIG9wdGlvbnMgPSB7fSkgPT4ge1xuICAgICAgY29uc3Qge1xuICAgICAgICB0b3BMZWZ0ID0gdHJ1ZSxcbiAgICAgICAgdGFyZ2V0WiA9IHVuZGVmaW5lZFxuICAgICAgfSA9IG9wdGlvbnM7XG4gICAgICBjb25zdCBbeCwgeSwgel0gPSB4eXo7XG4gICAgICBjb25zdCB5MiA9IHRvcExlZnQgPyB5IDogdGhpcy5oZWlnaHQgLSB5O1xuICAgICAgY29uc3QgdGFyZ2V0WldvcmxkID0gdGFyZ2V0WiAmJiB0YXJnZXRaICogdGhpcy5kaXN0YW5jZVNjYWxlcy51bml0c1Blck1ldGVyWzJdO1xuICAgICAgY29uc3QgY29vcmQgPSBwaXhlbHNUb1dvcmxkKFt4LCB5Miwgel0sIHRoaXMucGl4ZWxVbnByb2plY3Rpb25NYXRyaXgsIHRhcmdldFpXb3JsZCk7XG4gICAgICBjb25zdCBbWCwgWSwgWl0gPSB0aGlzLnVucHJvamVjdFBvc2l0aW9uKGNvb3JkKTtcblxuICAgICAgaWYgKE51bWJlci5pc0Zpbml0ZSh6KSkge1xuICAgICAgICByZXR1cm4gW1gsIFksIFpdO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gTnVtYmVyLmlzRmluaXRlKHRhcmdldFopID8gW1gsIFksIHRhcmdldFpdIDogW1gsIFldO1xuICAgIH0pO1xuXG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwicHJvamVjdFBvc2l0aW9uXCIsIHh5eiA9PiB7XG4gICAgICBjb25zdCBbWCwgWV0gPSBsbmdMYXRUb1dvcmxkKHh5eik7XG4gICAgICBjb25zdCBaID0gKHh5elsyXSB8fCAwKSAqIHRoaXMuZGlzdGFuY2VTY2FsZXMudW5pdHNQZXJNZXRlclsyXTtcbiAgICAgIHJldHVybiBbWCwgWSwgWl07XG4gICAgfSk7XG5cbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJ1bnByb2plY3RQb3NpdGlvblwiLCB4eXogPT4ge1xuICAgICAgY29uc3QgW1gsIFldID0gd29ybGRUb0xuZ0xhdCh4eXopO1xuICAgICAgY29uc3QgWiA9ICh4eXpbMl0gfHwgMCkgKiB0aGlzLmRpc3RhbmNlU2NhbGVzLm1ldGVyc1BlclVuaXRbMl07XG4gICAgICByZXR1cm4gW1gsIFksIFpdO1xuICAgIH0pO1xuXG4gICAgbGV0IHtcbiAgICAgIHdpZHRoLFxuICAgICAgaGVpZ2h0LFxuICAgICAgYWx0aXR1ZGUgPSBudWxsLFxuICAgICAgZm92eSA9IG51bGxcbiAgICB9ID0gcHJvcHM7XG4gICAgY29uc3Qge1xuICAgICAgbGF0aXR1ZGUgPSAwLFxuICAgICAgbG9uZ2l0dWRlID0gMCxcbiAgICAgIHpvb20gPSAwLFxuICAgICAgcGl0Y2ggPSAwLFxuICAgICAgYmVhcmluZyA9IDAsXG4gICAgICBwb3NpdGlvbiA9IG51bGwsXG4gICAgICBuZWFyWk11bHRpcGxpZXIgPSAwLjAyLFxuICAgICAgZmFyWk11bHRpcGxpZXIgPSAxLjAxXG4gICAgfSA9IHByb3BzO1xuICAgIHdpZHRoID0gd2lkdGggfHwgMTtcbiAgICBoZWlnaHQgPSBoZWlnaHQgfHwgMTtcblxuICAgIGlmIChmb3Z5ID09PSBudWxsICYmIGFsdGl0dWRlID09PSBudWxsKSB7XG4gICAgICBhbHRpdHVkZSA9IERFRkFVTFRfQUxUSVRVREU7XG4gICAgICBmb3Z5ID0gYWx0aXR1ZGVUb0ZvdnkoYWx0aXR1ZGUpO1xuICAgIH0gZWxzZSBpZiAoZm92eSA9PT0gbnVsbCkge1xuICAgICAgZm92eSA9IGFsdGl0dWRlVG9Gb3Z5KGFsdGl0dWRlKTtcbiAgICB9IGVsc2UgaWYgKGFsdGl0dWRlID09PSBudWxsKSB7XG4gICAgICBhbHRpdHVkZSA9IGZvdnlUb0FsdGl0dWRlKGZvdnkpO1xuICAgIH1cblxuICAgIGNvbnN0IHNjYWxlID0gem9vbVRvU2NhbGUoem9vbSk7XG4gICAgYWx0aXR1ZGUgPSBNYXRoLm1heCgwLjc1LCBhbHRpdHVkZSk7XG4gICAgY29uc3QgZGlzdGFuY2VTY2FsZXMgPSBnZXREaXN0YW5jZVNjYWxlcyh7XG4gICAgICBsb25naXR1ZGUsXG4gICAgICBsYXRpdHVkZVxuICAgIH0pO1xuICAgIGNvbnN0IGNlbnRlciA9IGxuZ0xhdFRvV29ybGQoW2xvbmdpdHVkZSwgbGF0aXR1ZGVdKTtcbiAgICBjZW50ZXIucHVzaCgwKTtcblxuICAgIGlmIChwb3NpdGlvbikge1xuICAgICAgdmVjMy5hZGQoY2VudGVyLCBjZW50ZXIsIHZlYzMubXVsKFtdLCBwb3NpdGlvbiwgZGlzdGFuY2VTY2FsZXMudW5pdHNQZXJNZXRlcikpO1xuICAgIH1cblxuICAgIHRoaXMucHJvamVjdGlvbk1hdHJpeCA9IGdldFByb2plY3Rpb25NYXRyaXgoe1xuICAgICAgd2lkdGgsXG4gICAgICBoZWlnaHQsXG4gICAgICBzY2FsZSxcbiAgICAgIGNlbnRlcixcbiAgICAgIHBpdGNoLFxuICAgICAgZm92eSxcbiAgICAgIG5lYXJaTXVsdGlwbGllcixcbiAgICAgIGZhclpNdWx0aXBsaWVyXG4gICAgfSk7XG4gICAgdGhpcy52aWV3TWF0cml4ID0gZ2V0Vmlld01hdHJpeCh7XG4gICAgICBoZWlnaHQsXG4gICAgICBzY2FsZSxcbiAgICAgIGNlbnRlcixcbiAgICAgIHBpdGNoLFxuICAgICAgYmVhcmluZyxcbiAgICAgIGFsdGl0dWRlXG4gICAgfSk7XG4gICAgdGhpcy53aWR0aCA9IHdpZHRoO1xuICAgIHRoaXMuaGVpZ2h0ID0gaGVpZ2h0O1xuICAgIHRoaXMuc2NhbGUgPSBzY2FsZTtcbiAgICB0aGlzLmxhdGl0dWRlID0gbGF0aXR1ZGU7XG4gICAgdGhpcy5sb25naXR1ZGUgPSBsb25naXR1ZGU7XG4gICAgdGhpcy56b29tID0gem9vbTtcbiAgICB0aGlzLnBpdGNoID0gcGl0Y2g7XG4gICAgdGhpcy5iZWFyaW5nID0gYmVhcmluZztcbiAgICB0aGlzLmFsdGl0dWRlID0gYWx0aXR1ZGU7XG4gICAgdGhpcy5mb3Z5ID0gZm92eTtcbiAgICB0aGlzLmNlbnRlciA9IGNlbnRlcjtcbiAgICB0aGlzLm1ldGVyT2Zmc2V0ID0gcG9zaXRpb24gfHwgWzAsIDAsIDBdO1xuICAgIHRoaXMuZGlzdGFuY2VTY2FsZXMgPSBkaXN0YW5jZVNjYWxlcztcblxuICAgIHRoaXMuX2luaXRNYXRyaWNlcygpO1xuXG4gICAgT2JqZWN0LmZyZWV6ZSh0aGlzKTtcbiAgfVxuXG4gIF9pbml0TWF0cmljZXMoKSB7XG4gICAgY29uc3Qge1xuICAgICAgd2lkdGgsXG4gICAgICBoZWlnaHQsXG4gICAgICBwcm9qZWN0aW9uTWF0cml4LFxuICAgICAgdmlld01hdHJpeFxuICAgIH0gPSB0aGlzO1xuICAgIGNvbnN0IHZwbSA9IGNyZWF0ZU1hdDQoKTtcbiAgICBtYXQ0Lm11bHRpcGx5KHZwbSwgdnBtLCBwcm9qZWN0aW9uTWF0cml4KTtcbiAgICBtYXQ0Lm11bHRpcGx5KHZwbSwgdnBtLCB2aWV3TWF0cml4KTtcbiAgICB0aGlzLnZpZXdQcm9qZWN0aW9uTWF0cml4ID0gdnBtO1xuICAgIGNvbnN0IG0gPSBjcmVhdGVNYXQ0KCk7XG4gICAgbWF0NC5zY2FsZShtLCBtLCBbd2lkdGggLyAyLCAtaGVpZ2h0IC8gMiwgMV0pO1xuICAgIG1hdDQudHJhbnNsYXRlKG0sIG0sIFsxLCAtMSwgMF0pO1xuICAgIG1hdDQubXVsdGlwbHkobSwgbSwgdnBtKTtcbiAgICBjb25zdCBtSW52ZXJzZSA9IG1hdDQuaW52ZXJ0KGNyZWF0ZU1hdDQoKSwgbSk7XG5cbiAgICBpZiAoIW1JbnZlcnNlKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1BpeGVsIHByb2plY3QgbWF0cml4IG5vdCBpbnZlcnRpYmxlJyk7XG4gICAgfVxuXG4gICAgdGhpcy5waXhlbFByb2plY3Rpb25NYXRyaXggPSBtO1xuICAgIHRoaXMucGl4ZWxVbnByb2plY3Rpb25NYXRyaXggPSBtSW52ZXJzZTtcbiAgfVxuXG4gIHByb2plY3RGbGF0KGxuZ0xhdCkge1xuICAgIHJldHVybiBsbmdMYXRUb1dvcmxkKGxuZ0xhdCk7XG4gIH1cblxuICB1bnByb2plY3RGbGF0KHh5KSB7XG4gICAgcmV0dXJuIHdvcmxkVG9MbmdMYXQoeHkpO1xuICB9XG5cbiAgZ2V0TWFwQ2VudGVyQnlMbmdMYXRQb3NpdGlvbih7XG4gICAgbG5nTGF0LFxuICAgIHBvc1xuICB9KSB7XG4gICAgY29uc3QgZnJvbUxvY2F0aW9uID0gcGl4ZWxzVG9Xb3JsZChwb3MsIHRoaXMucGl4ZWxVbnByb2plY3Rpb25NYXRyaXgpO1xuICAgIGNvbnN0IHRvTG9jYXRpb24gPSBsbmdMYXRUb1dvcmxkKGxuZ0xhdCk7XG4gICAgY29uc3QgdHJhbnNsYXRlID0gdmVjMi5hZGQoW10sIHRvTG9jYXRpb24sIHZlYzIubmVnYXRlKFtdLCBmcm9tTG9jYXRpb24pKTtcbiAgICBjb25zdCBuZXdDZW50ZXIgPSB2ZWMyLmFkZChbXSwgdGhpcy5jZW50ZXIsIHRyYW5zbGF0ZSk7XG4gICAgcmV0dXJuIHdvcmxkVG9MbmdMYXQobmV3Q2VudGVyKTtcbiAgfVxuXG4gIGZpdEJvdW5kcyhib3VuZHMsIG9wdGlvbnMgPSB7fSkge1xuICAgIGNvbnN0IHtcbiAgICAgIHdpZHRoLFxuICAgICAgaGVpZ2h0XG4gICAgfSA9IHRoaXM7XG4gICAgY29uc3Qge1xuICAgICAgbG9uZ2l0dWRlLFxuICAgICAgbGF0aXR1ZGUsXG4gICAgICB6b29tXG4gICAgfSA9IGZpdEJvdW5kcyhPYmplY3QuYXNzaWduKHtcbiAgICAgIHdpZHRoLFxuICAgICAgaGVpZ2h0LFxuICAgICAgYm91bmRzXG4gICAgfSwgb3B0aW9ucykpO1xuICAgIHJldHVybiBuZXcgV2ViTWVyY2F0b3JWaWV3cG9ydCh7XG4gICAgICB3aWR0aCxcbiAgICAgIGhlaWdodCxcbiAgICAgIGxvbmdpdHVkZSxcbiAgICAgIGxhdGl0dWRlLFxuICAgICAgem9vbVxuICAgIH0pO1xuICB9XG5cbiAgZ2V0Qm91bmRzKG9wdGlvbnMpIHtcbiAgICBjb25zdCBjb3JuZXJzID0gdGhpcy5nZXRCb3VuZGluZ1JlZ2lvbihvcHRpb25zKTtcbiAgICBjb25zdCB3ZXN0ID0gTWF0aC5taW4oLi4uY29ybmVycy5tYXAocCA9PiBwWzBdKSk7XG4gICAgY29uc3QgZWFzdCA9IE1hdGgubWF4KC4uLmNvcm5lcnMubWFwKHAgPT4gcFswXSkpO1xuICAgIGNvbnN0IHNvdXRoID0gTWF0aC5taW4oLi4uY29ybmVycy5tYXAocCA9PiBwWzFdKSk7XG4gICAgY29uc3Qgbm9ydGggPSBNYXRoLm1heCguLi5jb3JuZXJzLm1hcChwID0+IHBbMV0pKTtcbiAgICByZXR1cm4gW1t3ZXN0LCBzb3V0aF0sIFtlYXN0LCBub3J0aF1dO1xuICB9XG5cbiAgZ2V0Qm91bmRpbmdSZWdpb24ob3B0aW9ucyA9IHt9KSB7XG4gICAgcmV0dXJuIGdldEJvdW5kcyh0aGlzLCBvcHRpb25zLnogfHwgMCk7XG4gIH1cblxuICBnZXRMb2NhdGlvbkF0UG9pbnQoe1xuICAgIGxuZ0xhdCxcbiAgICBwb3NcbiAgfSkge1xuICAgIHJldHVybiB0aGlzLmdldE1hcENlbnRlckJ5TG5nTGF0UG9zaXRpb24oe1xuICAgICAgbG5nTGF0LFxuICAgICAgcG9zXG4gICAgfSk7XG4gIH1cblxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9d2ViLW1lcmNhdG9yLXZpZXdwb3J0LmpzLm1hcCIsImltcG9ydCB7IHdvcmxkVG9MbmdMYXQgfSBmcm9tICcuL3dlYi1tZXJjYXRvci11dGlscyc7XG5pbXBvcnQgeyBtb2QsIGxvZzIgfSBmcm9tICcuL21hdGgtdXRpbHMnO1xuY29uc3QgVElMRV9TSVpFID0gNTEyO1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gbm9ybWFsaXplVmlld3BvcnRQcm9wcyhwcm9wcykge1xuICBjb25zdCB7XG4gICAgd2lkdGgsXG4gICAgaGVpZ2h0LFxuICAgIHBpdGNoID0gMFxuICB9ID0gcHJvcHM7XG4gIGxldCB7XG4gICAgbG9uZ2l0dWRlLFxuICAgIGxhdGl0dWRlLFxuICAgIHpvb20sXG4gICAgYmVhcmluZyA9IDBcbiAgfSA9IHByb3BzO1xuXG4gIGlmIChsb25naXR1ZGUgPCAtMTgwIHx8IGxvbmdpdHVkZSA+IDE4MCkge1xuICAgIGxvbmdpdHVkZSA9IG1vZChsb25naXR1ZGUgKyAxODAsIDM2MCkgLSAxODA7XG4gIH1cblxuICBpZiAoYmVhcmluZyA8IC0xODAgfHwgYmVhcmluZyA+IDE4MCkge1xuICAgIGJlYXJpbmcgPSBtb2QoYmVhcmluZyArIDE4MCwgMzYwKSAtIDE4MDtcbiAgfVxuXG4gIGNvbnN0IG1pblpvb20gPSBsb2cyKGhlaWdodCAvIFRJTEVfU0laRSk7XG5cbiAgaWYgKHpvb20gPD0gbWluWm9vbSkge1xuICAgIHpvb20gPSBtaW5ab29tO1xuICAgIGxhdGl0dWRlID0gMDtcbiAgfSBlbHNlIHtcbiAgICBjb25zdCBoYWxmSGVpZ2h0UGl4ZWxzID0gaGVpZ2h0IC8gMiAvIE1hdGgucG93KDIsIHpvb20pO1xuICAgIGNvbnN0IG1pbkxhdGl0dWRlID0gd29ybGRUb0xuZ0xhdChbMCwgaGFsZkhlaWdodFBpeGVsc10pWzFdO1xuXG4gICAgaWYgKGxhdGl0dWRlIDwgbWluTGF0aXR1ZGUpIHtcbiAgICAgIGxhdGl0dWRlID0gbWluTGF0aXR1ZGU7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IG1heExhdGl0dWRlID0gd29ybGRUb0xuZ0xhdChbMCwgVElMRV9TSVpFIC0gaGFsZkhlaWdodFBpeGVsc10pWzFdO1xuXG4gICAgICBpZiAobGF0aXR1ZGUgPiBtYXhMYXRpdHVkZSkge1xuICAgICAgICBsYXRpdHVkZSA9IG1heExhdGl0dWRlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiB7XG4gICAgd2lkdGgsXG4gICAgaGVpZ2h0LFxuICAgIGxvbmdpdHVkZSxcbiAgICBsYXRpdHVkZSxcbiAgICB6b29tLFxuICAgIHBpdGNoLFxuICAgIGJlYXJpbmdcbiAgfTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW5vcm1hbGl6ZS12aWV3cG9ydC1wcm9wcy5qcy5tYXAiLCJpbXBvcnQgeyBsZXJwIH0gZnJvbSAnLi9tYXRoLXV0aWxzJztcbmltcG9ydCB7IHNjYWxlVG9ab29tLCB6b29tVG9TY2FsZSwgbG5nTGF0VG9Xb3JsZCwgd29ybGRUb0xuZ0xhdCB9IGZyb20gJy4vd2ViLW1lcmNhdG9yLXV0aWxzJztcbmltcG9ydCAqIGFzIHZlYzIgZnJvbSAnZ2wtbWF0cml4L3ZlYzInO1xuY29uc3QgRVBTSUxPTiA9IDAuMDE7XG5jb25zdCBWSUVXUE9SVF9UUkFOU0lUSU9OX1BST1BTID0gWydsb25naXR1ZGUnLCAnbGF0aXR1ZGUnLCAnem9vbSddO1xuY29uc3QgREVGQVVMVF9PUFRTID0ge1xuICBjdXJ2ZTogMS40MTQsXG4gIHNwZWVkOiAxLjJcbn07XG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBmbHlUb1ZpZXdwb3J0KHN0YXJ0UHJvcHMsIGVuZFByb3BzLCB0LCBvcHRpb25zKSB7XG4gIGNvbnN0IHtcbiAgICBzdGFydFpvb20sXG4gICAgc3RhcnRDZW50ZXJYWSxcbiAgICB1RGVsdGEsXG4gICAgdzAsXG4gICAgdTEsXG4gICAgUyxcbiAgICByaG8sXG4gICAgcmhvMixcbiAgICByMFxuICB9ID0gZ2V0Rmx5VG9UcmFuc2l0aW9uUGFyYW1zKHN0YXJ0UHJvcHMsIGVuZFByb3BzLCBvcHRpb25zKTtcblxuICBpZiAodTEgPCBFUFNJTE9OKSB7XG4gICAgY29uc3Qgdmlld3BvcnQgPSB7fTtcblxuICAgIGZvciAoY29uc3Qga2V5IG9mIFZJRVdQT1JUX1RSQU5TSVRJT05fUFJPUFMpIHtcbiAgICAgIGNvbnN0IHN0YXJ0VmFsdWUgPSBzdGFydFByb3BzW2tleV07XG4gICAgICBjb25zdCBlbmRWYWx1ZSA9IGVuZFByb3BzW2tleV07XG4gICAgICB2aWV3cG9ydFtrZXldID0gbGVycChzdGFydFZhbHVlLCBlbmRWYWx1ZSwgdCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHZpZXdwb3J0O1xuICB9XG5cbiAgY29uc3QgcyA9IHQgKiBTO1xuICBjb25zdCB3ID0gTWF0aC5jb3NoKHIwKSAvIE1hdGguY29zaChyMCArIHJobyAqIHMpO1xuICBjb25zdCB1ID0gdzAgKiAoKE1hdGguY29zaChyMCkgKiBNYXRoLnRhbmgocjAgKyByaG8gKiBzKSAtIE1hdGguc2luaChyMCkpIC8gcmhvMikgLyB1MTtcbiAgY29uc3Qgc2NhbGVJbmNyZW1lbnQgPSAxIC8gdztcbiAgY29uc3QgbmV3Wm9vbSA9IHN0YXJ0Wm9vbSArIHNjYWxlVG9ab29tKHNjYWxlSW5jcmVtZW50KTtcbiAgY29uc3QgbmV3Q2VudGVyV29ybGQgPSB2ZWMyLnNjYWxlKFtdLCB1RGVsdGEsIHUpO1xuICB2ZWMyLmFkZChuZXdDZW50ZXJXb3JsZCwgbmV3Q2VudGVyV29ybGQsIHN0YXJ0Q2VudGVyWFkpO1xuICBjb25zdCBuZXdDZW50ZXIgPSB3b3JsZFRvTG5nTGF0KG5ld0NlbnRlcldvcmxkKTtcbiAgcmV0dXJuIHtcbiAgICBsb25naXR1ZGU6IG5ld0NlbnRlclswXSxcbiAgICBsYXRpdHVkZTogbmV3Q2VudGVyWzFdLFxuICAgIHpvb206IG5ld1pvb21cbiAgfTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBnZXRGbHlUb0R1cmF0aW9uKHN0YXJ0UHJvcHMsIGVuZFByb3BzLCBvcHRpb25zKSB7XG4gIGNvbnN0IG9wdHMgPSB7IC4uLkRFRkFVTFRfT1BUUyxcbiAgICAuLi5vcHRpb25zXG4gIH07XG4gIGNvbnN0IHtcbiAgICBzY3JlZW5TcGVlZCxcbiAgICBzcGVlZCxcbiAgICBtYXhEdXJhdGlvblxuICB9ID0gb3B0cztcbiAgY29uc3Qge1xuICAgIFMsXG4gICAgcmhvXG4gIH0gPSBnZXRGbHlUb1RyYW5zaXRpb25QYXJhbXMoc3RhcnRQcm9wcywgZW5kUHJvcHMsIG9wdHMpO1xuICBjb25zdCBsZW5ndGggPSAxMDAwICogUztcbiAgbGV0IGR1cmF0aW9uO1xuXG4gIGlmIChOdW1iZXIuaXNGaW5pdGUoc2NyZWVuU3BlZWQpKSB7XG4gICAgZHVyYXRpb24gPSBsZW5ndGggLyAoc2NyZWVuU3BlZWQgLyByaG8pO1xuICB9IGVsc2Uge1xuICAgIGR1cmF0aW9uID0gbGVuZ3RoIC8gc3BlZWQ7XG4gIH1cblxuICByZXR1cm4gTnVtYmVyLmlzRmluaXRlKG1heER1cmF0aW9uKSAmJiBkdXJhdGlvbiA+IG1heER1cmF0aW9uID8gMCA6IGR1cmF0aW9uO1xufVxuXG5mdW5jdGlvbiBnZXRGbHlUb1RyYW5zaXRpb25QYXJhbXMoc3RhcnRQcm9wcywgZW5kUHJvcHMsIG9wdHMpIHtcbiAgb3B0cyA9IE9iamVjdC5hc3NpZ24oe30sIERFRkFVTFRfT1BUUywgb3B0cyk7XG4gIGNvbnN0IHJobyA9IG9wdHMuY3VydmU7XG4gIGNvbnN0IHN0YXJ0Wm9vbSA9IHN0YXJ0UHJvcHMuem9vbTtcbiAgY29uc3Qgc3RhcnRDZW50ZXIgPSBbc3RhcnRQcm9wcy5sb25naXR1ZGUsIHN0YXJ0UHJvcHMubGF0aXR1ZGVdO1xuICBjb25zdCBzdGFydFNjYWxlID0gem9vbVRvU2NhbGUoc3RhcnRab29tKTtcbiAgY29uc3QgZW5kWm9vbSA9IGVuZFByb3BzLnpvb207XG4gIGNvbnN0IGVuZENlbnRlciA9IFtlbmRQcm9wcy5sb25naXR1ZGUsIGVuZFByb3BzLmxhdGl0dWRlXTtcbiAgY29uc3Qgc2NhbGUgPSB6b29tVG9TY2FsZShlbmRab29tIC0gc3RhcnRab29tKTtcbiAgY29uc3Qgc3RhcnRDZW50ZXJYWSA9IGxuZ0xhdFRvV29ybGQoc3RhcnRDZW50ZXIpO1xuICBjb25zdCBlbmRDZW50ZXJYWSA9IGxuZ0xhdFRvV29ybGQoZW5kQ2VudGVyKTtcbiAgY29uc3QgdURlbHRhID0gdmVjMi5zdWIoW10sIGVuZENlbnRlclhZLCBzdGFydENlbnRlclhZKTtcbiAgY29uc3QgdzAgPSBNYXRoLm1heChzdGFydFByb3BzLndpZHRoLCBzdGFydFByb3BzLmhlaWdodCk7XG4gIGNvbnN0IHcxID0gdzAgLyBzY2FsZTtcbiAgY29uc3QgdTEgPSB2ZWMyLmxlbmd0aCh1RGVsdGEpICogc3RhcnRTY2FsZTtcblxuICBjb25zdCBfdTEgPSBNYXRoLm1heCh1MSwgRVBTSUxPTik7XG5cbiAgY29uc3QgcmhvMiA9IHJobyAqIHJobztcbiAgY29uc3QgYjAgPSAodzEgKiB3MSAtIHcwICogdzAgKyByaG8yICogcmhvMiAqIF91MSAqIF91MSkgLyAoMiAqIHcwICogcmhvMiAqIF91MSk7XG4gIGNvbnN0IGIxID0gKHcxICogdzEgLSB3MCAqIHcwIC0gcmhvMiAqIHJobzIgKiBfdTEgKiBfdTEpIC8gKDIgKiB3MSAqIHJobzIgKiBfdTEpO1xuICBjb25zdCByMCA9IE1hdGgubG9nKE1hdGguc3FydChiMCAqIGIwICsgMSkgLSBiMCk7XG4gIGNvbnN0IHIxID0gTWF0aC5sb2coTWF0aC5zcXJ0KGIxICogYjEgKyAxKSAtIGIxKTtcbiAgY29uc3QgUyA9IChyMSAtIHIwKSAvIHJobztcbiAgcmV0dXJuIHtcbiAgICBzdGFydFpvb20sXG4gICAgc3RhcnRDZW50ZXJYWSxcbiAgICB1RGVsdGEsXG4gICAgdzAsXG4gICAgdTEsXG4gICAgUyxcbiAgICByaG8sXG4gICAgcmhvMixcbiAgICByMCxcbiAgICByMVxuICB9O1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Zmx5LXRvLXZpZXdwb3J0LmpzLm1hcCIsImV4cG9ydCB7IGRlZmF1bHQgfSBmcm9tICcuL3dlYi1tZXJjYXRvci12aWV3cG9ydCc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIFdlYk1lcmNhdG9yVmlld3BvcnQgfSBmcm9tICcuL3dlYi1tZXJjYXRvci12aWV3cG9ydCc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIGdldEJvdW5kcyB9IGZyb20gJy4vZ2V0LWJvdW5kcyc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIGZpdEJvdW5kcyB9IGZyb20gJy4vZml0LWJvdW5kcyc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIG5vcm1hbGl6ZVZpZXdwb3J0UHJvcHMgfSBmcm9tICcuL25vcm1hbGl6ZS12aWV3cG9ydC1wcm9wcyc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIGZseVRvVmlld3BvcnQsIGdldEZseVRvRHVyYXRpb24gfSBmcm9tICcuL2ZseS10by12aWV3cG9ydCc7XG5leHBvcnQgeyBNQVhfTEFUSVRVREUsIGxuZ0xhdFRvV29ybGQsIHdvcmxkVG9MbmdMYXQsIHdvcmxkVG9QaXhlbHMsIHBpeGVsc1RvV29ybGQsIHpvb21Ub1NjYWxlLCBzY2FsZVRvWm9vbSwgYWx0aXR1ZGVUb0ZvdnksIGZvdnlUb0FsdGl0dWRlLCBnZXRNZXRlclpvb20sIHVuaXRzUGVyTWV0ZXIsIGdldERpc3RhbmNlU2NhbGVzLCBhZGRNZXRlcnNUb0xuZ0xhdCwgZ2V0Vmlld01hdHJpeCwgZ2V0UHJvamVjdGlvbk1hdHJpeCwgZ2V0UHJvamVjdGlvblBhcmFtZXRlcnMgfSBmcm9tICcuL3dlYi1tZXJjYXRvci11dGlscyc7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///78866\n')},59391:function(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__){eval('/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "Z": function() { return /* export default binding */ __WEBPACK_DEFAULT_EXPORT__; }\n/* harmony export */ });\n/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(n){return{all:n=n||new Map,on:function(t,e){var i=n.get(t);i?i.push(e):n.set(t,[e])},off:function(t,e){var i=n.get(t);i&&(e?i.splice(i.indexOf(e)>>>0,1):n.set(t,[]))},emit:function(t,e){var i=n.get(t);i&&i.slice().map(function(n){n(e)}),(i=n.get("*"))&&i.slice().map(function(n){n(t,e)})}}}\n//# sourceMappingURL=mitt.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNTkzOTEuanMiLCJtYXBwaW5ncyI6Ijs7O0FBQUEsNkJBQWUsb0NBQVMsR0FBRyxPQUFPLGtDQUFrQyxlQUFlLHlCQUF5QixtQkFBbUIsZUFBZSxnREFBZ0Qsb0JBQW9CLGVBQWUsNkJBQTZCLEtBQUssNENBQTRDLE9BQU87QUFDdFQiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly92dWUzLXdlYnBhY2s1Ly4vbm9kZV9tb2R1bGVzL21pdHQvZGlzdC9taXR0Lm1qcz8zN2M4Il0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKG4pe3JldHVybnthbGw6bj1ufHxuZXcgTWFwLG9uOmZ1bmN0aW9uKHQsZSl7dmFyIGk9bi5nZXQodCk7aT9pLnB1c2goZSk6bi5zZXQodCxbZV0pfSxvZmY6ZnVuY3Rpb24odCxlKXt2YXIgaT1uLmdldCh0KTtpJiYoZT9pLnNwbGljZShpLmluZGV4T2YoZSk+Pj4wLDEpOm4uc2V0KHQsW10pKX0sZW1pdDpmdW5jdGlvbih0LGUpe3ZhciBpPW4uZ2V0KHQpO2kmJmkuc2xpY2UoKS5tYXAoZnVuY3Rpb24obil7bihlKX0pLChpPW4uZ2V0KFwiKlwiKSkmJmkuc2xpY2UoKS5tYXAoZnVuY3Rpb24obil7bih0LGUpfSl9fX1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW1pdHQubWpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///59391\n')}}]);