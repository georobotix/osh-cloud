"use strict";(self["webpackChunkvue3_webpack5"]=self["webpackChunkvue3_webpack5"]||[]).push([[5885],{90791:function(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__){eval('/* harmony import */ var _Cartesian3_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(60216);\n/* harmony import */ var _Cartographic_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(51688);\n/* harmony import */ var _Check_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(66553);\n/* harmony import */ var _defaultValue_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(62200);\n/* harmony import */ var _defined_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(82982);\n/* harmony import */ var _DeveloperError_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(12572);\n/* harmony import */ var _Ellipsoid_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(50491);\n/* harmony import */ var _FeatureDetection_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(96037);\n/* harmony import */ var _RuntimeError_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(9407);\n/* eslint-disable new-cap */\n\n\n\n\n\n\n\n\n\n\n/**\n * S2\n * --\n *\n * This implementation is based on the S2 C++ reference implementation: https://github.com/google/s2geometry\n *\n *\n * Overview:\n * ---------\n * The S2 library decomposes the unit sphere into a hierarchy of cells. A cell is a quadrilateral bounded by 4 geodesics.\n * The 6 root cells are obtained by projecting the six faces of a cube on a unit sphere. Each root cell follows a quadtree\n * subdivision scheme, i.e. each cell subdivides into 4 smaller cells that cover the same area as the parent cell. The S2 cell\n * hierarchy extends from level 0 (root cells) to level 30 (leaf cells). The root cells are rotated to enable a continuous Hilbert\n * curve to map all 6 faces of the cube.\n *\n *\n * Cell ID:\n * --------\n * Each cell in S2 can be uniquely identified using a 64-bit unsigned integer, its cell ID. The first 3 bits of the cell ID are the face bits, i.e.\n * they indicate which of the 6 faces of the cube a cell lies on. After the face bits are the position bits, i.e. they indicate the position\n * of the cell along the Hilbert curve. After the positions bits is the sentinel bit, which is always set to 1, and it indicates the level of the\n * cell. Again, the level can be between 0 and 30 in S2.\n *\n *   Note: In the illustration below, the face bits are marked with \'f\', the position bits are marked with \'p\', the zero bits are marked with \'-\'.\n *\n *   Cell ID (base 10): 3170534137668829184\n *   Cell ID (base 2) : 0010110000000000000000000000000000000000000000000000000000000000\n *\n *   001 0110000000000000000000000000000000000000000000000000000000000\n *   fff pps----------------------------------------------------------\n *\n * For the cell above, we can see that it lies on face 1 (01), with a Hilbert index of 1 (1).\n *\n *\n * Cell Subdivision:\n * ------------------\n * Cells in S2 subdivide recursively using quadtree subdivision. For each cell, you can get a child of index [0-3]. To compute the child at index i,\n * insert the base 2 representation of i to the right of the parent\'s position bits. Ensure that the sentinel bit is also shifted two places to the right.\n *\n *   Parent Cell ID (base 10) : 3170534137668829184\n *   Parent Cell ID (base 2)  : 0010110000000000000000000000000000000000000000000000000000000000\n *\n *   001 0110000000000000000000000000000000000000000000000000000000000\n *   fff pps----------------------------------------------------------\n *\n *   To get the 3rd child of the cell above, we insert the binary representation of 3 to the right of the parent\'s position bits:\n *\n *   Note: In the illustration below, the bits to be added are highlighted with \'^\'.\n *\n *   001 0111100000000000000000000000000000000000000000000000000000000\n *   fff pppps--------------------------------------------------------\n *         ^^\n *\n *   Child(3) Cell ID (base 10) : 3386706919782612992\n *   Child(3) Cell ID (base 2)  : 0010111100000000000000000000000000000000000000000000000000000000\n *\n * Cell Token:\n * -----------\n * To provide a more concise representation of the S2 cell ID, we can use their hexadecimal representation.\n *\n *   Cell ID (base 10): 3170534137668829184\n *   Cell ID (base 2) : 0010110000000000000000000000000000000000000000000000000000000000\n *\n *   We remove all trailing zero bits, until we reach the nybble (4 bits) that contains the sentinel bit.\n *\n *   Note: In the illustration below, the bits to be removed are highlighted with \'X\'.\n *\n *   0010110000000000000000000000000000000000000000000000000000000000\n *   fffpps--XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n *\n *   We convert the remaining bits to their hexadecimal representation.\n *\n *   Base 2: 0010 1100\n *   Base 16: "2"  "c"\n *\n *   Cell Token: "2c"\n *\n * To compute the cell ID from the token, we simply add enough zeros to the right to make the ID span 64 bits.\n *\n * Coordinate Transforms:\n * ----------------------\n *\n * To go from a cell in S2 to a point on the ellipsoid, the following order of transforms is applied:\n *\n *   1. (Cell ID): S2 cell ID\n *   2. (Face, I, J): Leaf cell coordinates, where i and j are in range [0, 2^30 - 1]\n *   3. (Face, S, T): Cell space coordinates, where s and t are in range [0, 1].\n *   4. (Face, Si, Ti): Discrete cell space coordinates, where si and ti are in range [0, 2^31]\n *   5. (Face, U, V): Cube space coordinates, where u and v are in range [-1, 1]. We apply the non-linear quadratic transform here.\n *   6. (X, Y, Z): Direction vector, where vector may not be unit length. Can be normalized to obtain point on unit sphere\n *   7. (Latitude, Longitude): Direction vector, where latitude is in range [-90, 90] and longitude is in range [-180, 180]\n *\n * @ignore\n */\n\n// The maximum level supported within an S2 cell ID. Each level is represented by two bits in the final cell ID\nvar S2_MAX_LEVEL = 30;\n\n// The maximum index of a valid leaf cell plus one.  The range of valid leaf cell indices is [0..S2_LIMIT_IJ-1].\nvar S2_LIMIT_IJ = 1 << S2_MAX_LEVEL;\n\n// The maximum value of an si- or ti-coordinate.  The range of valid (si,ti) values is [0..S2_MAX_SITI].  Use `>>>` to convert to unsigned.\nvar S2_MAX_SITI = (1 << (S2_MAX_LEVEL + 1)) >>> 0;\n\n// The number of bits in a S2 cell ID used for specifying the position along the Hilbert curve\nvar S2_POSITION_BITS = 2 * S2_MAX_LEVEL + 1;\n\n// The number of bits per I and J in the lookup tables\nvar S2_LOOKUP_BITS = 4;\n\n// Lookup table for mapping 10 bits of IJ + orientation to 10 bits of Hilbert curve position + orientation.\nvar S2_LOOKUP_POSITIONS = [];\n\n// Lookup table for mapping 10 bits of IJ + orientation to 10 bits of Hilbert curve position + orientation.\nvar S2_LOOKUP_IJ = [];\n\n// Lookup table of two bits of IJ from two bits of curve position, based also on the current curve orientation from the swap and invert bits\nvar S2_POSITION_TO_IJ = [\n  [0, 1, 3, 2], // 0: Normal order, no swap or invert\n  [0, 2, 3, 1], // 1: Swap bit set, swap I and J bits\n  [3, 2, 0, 1], // 2: Invert bit set, invert bits\n  [3, 1, 0, 2], // 3: Swap and invert bits set\n];\n\n// Mask that specifies the swap orientation bit for the Hilbert curve\nvar S2_SWAP_MASK = 1;\n\n// Mask that specifies the invert orientation bit for the Hilbert curve\nvar S2_INVERT_MASK = 2;\n\n// Lookup for the orientation update mask of one of the four sub-cells within a higher level cell.\n// This mask is XOR\'ed with the current orientation to get the sub-cell orientation.\nvar S2_POSITION_TO_ORIENTATION_MASK = [\n  S2_SWAP_MASK,\n  0,\n  0,\n  S2_SWAP_MASK | S2_INVERT_MASK,\n];\n\n/**\n * Represents a cell in the S2 geometry library.\n *\n * @alias S2Cell\n * @constructor\n *\n * @param {BigInt} [cellId] The 64-bit S2CellId.\n * @private\n */\nfunction S2Cell(cellId) {\n  if (!_FeatureDetection_js__WEBPACK_IMPORTED_MODULE_6__/* ["default"].supportsBigInt */ .Z.supportsBigInt()) {\n    throw new _RuntimeError_js__WEBPACK_IMPORTED_MODULE_7__/* ["default"] */ .Z("S2 required BigInt support");\n  }\n  //>>includeStart(\'debug\', pragmas.debug);\n  if (!(0,_defined_js__WEBPACK_IMPORTED_MODULE_8__/* ["default"] */ .Z)(cellId)) {\n    throw new _DeveloperError_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .Z("cell ID is required.");\n  }\n  if (!S2Cell.isValidId(cellId)) {\n    throw new _DeveloperError_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .Z("cell ID is invalid.");\n  }\n  //>>includeEnd(\'debug\');\n\n  this._cellId = cellId;\n  this._level = S2Cell.getLevel(cellId);\n}\n\n/**\n * Creates a new S2Cell from a token. A token is a hexadecimal representation of the 64-bit S2CellId.\n *\n * @param {String} token The token for the S2 Cell.\n * @returns {S2Cell} Returns a new S2Cell.\n * @private\n */\nS2Cell.fromToken = function (token) {\n  //>>includeStart(\'debug\', pragmas.debug);\n  _Check_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"].typeOf.string */ .Z.typeOf.string("token", token);\n  if (!S2Cell.isValidToken(token)) {\n    throw new _DeveloperError_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .Z("token is invalid.");\n  }\n  //>>includeEnd(\'debug\');\n\n  return new S2Cell(S2Cell.getIdFromToken(token));\n};\n\n/**\n * Validates an S2 cell ID.\n *\n * @param {BigInt} [cellId] The S2CellId.\n * @returns {Boolean} Returns true if the cell ID is valid, returns false otherwise.\n * @private\n */\nS2Cell.isValidId = function (cellId) {\n  //>>includeStart(\'debug\', pragmas.debug);\n  _Check_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"].typeOf.bigint */ .Z.typeOf.bigint("cellId", cellId);\n  //>>includeEnd(\'debug\');\n\n  // Check if sentinel bit is missing.\n  if (cellId <= 0) {\n    return false;\n  }\n\n  // Check if face bits indicate a valid value, in range [0-5].\n  // eslint-disable-next-line\n  if (cellId >> BigInt(S2_POSITION_BITS) > 5) {\n    return false;\n  }\n\n  // Check trailing 1 bit is in one of the even bit positions allowed for the 30 levels, using a bitmask.\n  var lowestSetBit = cellId & (~cellId + BigInt(1)); // eslint-disable-line\n  // eslint-disable-next-line\n  if (!(lowestSetBit & BigInt("0x1555555555555555"))) {\n    return false;\n  }\n\n  return true;\n};\n\n/**\n * Validates an S2 cell token.\n *\n * @param {String} [token] The hexadecimal representation of an S2CellId.\n * @returns {Boolean} Returns true if the token is valid, returns false otherwise.\n * @private\n */\nS2Cell.isValidToken = function (token) {\n  //>>includeStart(\'debug\', pragmas.debug);\n  _Check_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"].typeOf.string */ .Z.typeOf.string("token", token);\n  //>>includeEnd(\'debug\');\n\n  if (!/^[0-9a-fA-F]{1,16}$/.test(token)) {\n    return false;\n  }\n\n  return S2Cell.isValidId(S2Cell.getIdFromToken(token));\n};\n\n/**\n * Converts an S2 cell token to a 64-bit S2 cell ID.\n *\n * @param {String} [token] The hexadecimal representation of an S2CellId. Expected to be a valid S2 token.\n * @returns {BigInt} Returns the S2 cell ID.\n * @private\n */\nS2Cell.getIdFromToken = function (token) {\n  //>>includeStart(\'debug\', pragmas.debug);\n  _Check_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"].typeOf.string */ .Z.typeOf.string("token", token);\n  //>>includeEnd(\'debug\');\n\n  return BigInt("0x" + token + "0".repeat(16 - token.length)); // eslint-disable-line\n};\n\n/**\n * Converts a 64-bit S2 cell ID to an S2 cell token.\n *\n * @param {BigInt} [cellId] The S2 cell ID.\n * @returns {BigInt} Returns hexadecimal representation of an S2CellId.\n * @private\n */\nS2Cell.getTokenFromId = function (cellId) {\n  //>>includeStart(\'debug\', pragmas.debug);\n  _Check_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"].typeOf.bigint */ .Z.typeOf.bigint("cellId", cellId);\n  //>>includeEnd(\'debug\');\n\n  var trailingZeroHexChars = Math.floor(countTrailingZeroBits(cellId) / 4);\n  var hexString = cellId.toString(16).replace(/0*$/, "");\n\n  var zeroString = Array(17 - trailingZeroHexChars - hexString.length).join(\n    "0"\n  );\n  return zeroString + hexString;\n};\n\n/**\n * Gets the level of the cell from the cell ID.\n *\n * @param {BigInt} [cellId] The S2 cell ID.\n * @returns {number} Returns the level of the cell.\n * @private\n */\nS2Cell.getLevel = function (cellId) {\n  //>>includeStart(\'debug\', pragmas.debug);\n  _Check_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"].typeOf.bigint */ .Z.typeOf.bigint("cellId", cellId);\n  if (!S2Cell.isValidId(cellId)) {\n    throw new _DeveloperError_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .Z();\n  }\n  //>>includeEnd(\'debug\');\n\n  var lsbPosition = 0;\n  // eslint-disable-next-line\n  while (cellId !== BigInt(0)) {\n    // eslint-disable-next-line\n    if (cellId & BigInt(1)) {\n      break;\n    }\n    lsbPosition++;\n    cellId = cellId >> BigInt(1); // eslint-disable-line\n  }\n\n  // We use (>> 1) because there are 2 bits per level.\n  return S2_MAX_LEVEL - (lsbPosition >> 1);\n};\n\n/**\n * Gets the child cell of the cell at the given index.\n *\n * @param {Number} index An integer index of the child.\n * @returns {S2Cell} The child of the S2Cell.\n * @private\n */\nS2Cell.prototype.getChild = function (index) {\n  //>>includeStart(\'debug\', pragmas.debug);\n  _Check_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"].typeOf.number */ .Z.typeOf.number("index", index);\n  if (index < 0 || index > 3) {\n    throw new _DeveloperError_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .Z("child index must be in the range [0-3].");\n  }\n  if (this._level === 30) {\n    throw new _DeveloperError_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .Z("cannot get child of leaf cell.");\n  }\n  //>>includeEnd(\'debug\');\n\n  // Shift sentinel bit 2 positions to the right.\n  var newLsb = lsb(this._cellId) >> BigInt(2); // eslint-disable-line\n  // Insert child index before the sentinel bit.\n  var childCellId = this._cellId + BigInt(2 * index + 1 - 4) * newLsb; // eslint-disable-line\n  return new S2Cell(childCellId);\n};\n\n/**\n * Gets the parent cell of an S2Cell.\n *\n * @returns {S2Cell} Returns the parent of the S2Cell.\n * @private\n */\nS2Cell.prototype.getParent = function () {\n  //>>includeStart(\'debug\', pragmas.debug);\n  if (this._level === 0) {\n    throw new _DeveloperError_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .Z("cannot get parent of root cell.");\n  }\n  //>>includeEnd(\'debug\');\n  // Shift the sentinel bit 2 positions to the left.\n  var newLsb = lsb(this._cellId) << BigInt(2); // eslint-disable-line\n  // Erase the left over bits to the right of the sentinel bit.\n  return new S2Cell((this._cellId & (~newLsb + BigInt(1))) | newLsb); // eslint-disable-line\n};\n\n/**\n * Gets the parent cell at the given level.\n *\n * @returns {S2Cell} Returns the parent of the S2Cell.\n * @private\n */\nS2Cell.prototype.getParentAtLevel = function (level) {\n  //>>includeStart(\'debug\', pragmas.debug);\n  if (this._level === 0 || level < 0 || this._level < level) {\n    throw new _DeveloperError_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .Z("cannot get parent at invalid level.");\n  }\n  //>>includeEnd(\'debug\');\n  var newLsb = lsbForLevel(level);\n  return new S2Cell((this._cellId & -newLsb) | newLsb);\n};\n\n/**\n * Get center of the S2 cell.\n *\n * @param {Ellipsoid} [options.ellipsoid=Ellipsoid.WGS84] The ellipsoid.\n * @returns {Cartesian} The position of center of the S2 cell.\n * @private\n */\nS2Cell.prototype.getCenter = function (ellipsoid) {\n  ellipsoid = (0,_defaultValue_js__WEBPACK_IMPORTED_MODULE_3__/* ["default"] */ .Z)(ellipsoid, _Ellipsoid_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"].WGS84 */ .Z.WGS84);\n\n  var center = getS2Center(this._cellId, this._level);\n  // Normalize XYZ.\n  center = _Cartesian3_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].normalize */ .Z.normalize(center, center);\n  var cartographic = new _Cartographic_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"].fromCartesian */ .Z.fromCartesian(\n    center,\n    _Ellipsoid_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"].UNIT_SPHERE */ .Z.UNIT_SPHERE\n  );\n  // Interpret as geodetic coordinates on the ellipsoid.\n  return _Cartographic_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"].toCartesian */ .Z.toCartesian(cartographic, ellipsoid, new _Cartesian3_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .Z());\n};\n\n/**\n * Get vertex of the S2 cell. Vertices are indexed in CCW order.\n *\n * @param {Number} index An integer index of the vertex. Must be in the range [0-3].\n * @param {Ellipsoid} [options.ellipsoid=Ellipsoid.WGS84] The ellipsoid.\n * @returns {Cartesian} The position of the vertex of the S2 cell.\n * @private\n */\nS2Cell.prototype.getVertex = function (index, ellipsoid) {\n  //>>includeStart(\'debug\', pragmas.debug);\n  _Check_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"].typeOf.number */ .Z.typeOf.number("index", index);\n  if (index < 0 || index > 3) {\n    throw new _DeveloperError_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .Z("vertex index must be in the range [0-3].");\n  }\n  //>>includeEnd(\'debug\');\n\n  ellipsoid = (0,_defaultValue_js__WEBPACK_IMPORTED_MODULE_3__/* ["default"] */ .Z)(ellipsoid, _Ellipsoid_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"].WGS84 */ .Z.WGS84);\n\n  var vertex = getS2Vertex(this._cellId, this._level, index);\n  // Normalize XYZ.\n  vertex = _Cartesian3_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].normalize */ .Z.normalize(vertex, vertex);\n  var cartographic = new _Cartographic_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"].fromCartesian */ .Z.fromCartesian(\n    vertex,\n    _Ellipsoid_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"].UNIT_SPHERE */ .Z.UNIT_SPHERE\n  );\n  // Interpret as geodetic coordinates on the ellipsoid.\n  return _Cartographic_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"].toCartesian */ .Z.toCartesian(cartographic, ellipsoid, new _Cartesian3_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .Z());\n};\n\n/**\n * Creates an S2Cell from its face, position along the Hilbert curve for a given level.\n *\n * @param {Number} face The root face of S2 this cell is on. Must be in the range [0-5].\n * @param {BigInt} position The position along the Hilbert curve. Must be in the range [0-4**level).\n * @param {Number} level The level of the S2 curve. Must be in the range [0-30].\n * @returns {S2Cell} A new S2Cell from the given parameters.\n * @private\n */\nS2Cell.fromFacePositionLevel = function (face, position, level) {\n  //>>includeStart(\'debug\', pragmas.debug);\n  _Check_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"].typeOf.bigint */ .Z.typeOf.bigint("position", position);\n  if (face < 0 || face > 5) {\n    throw new _DeveloperError_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .Z("Invalid S2 Face (must be within 0-5)");\n  }\n\n  if (level < 0 || level > S2_MAX_LEVEL) {\n    throw new _DeveloperError_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .Z("Invalid level (must be within 0-30)");\n  }\n  if (position < 0 || position >= Math.pow(4, level)) {\n    throw new _DeveloperError_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .Z("Invalid Hilbert position for level");\n  }\n  //>>includeEnd(\'debug\');\n\n  var faceBitString =\n    (face < 4 ? "0" : "") + (face < 2 ? "0" : "") + face.toString(2);\n  var positionBitString = position.toString(2);\n  var positionPrefixPadding = Array(\n    2 * level - positionBitString.length + 1\n  ).join("0");\n  var positionSuffixPadding = Array(S2_POSITION_BITS - 2 * level).join("0");\n\n  // eslint-disable-next-line\n  var cellId = BigInt(\n    "0b" +\n      faceBitString +\n      positionPrefixPadding +\n      positionBitString +\n      "1" + // Adding the sentinel bit that always follows the position bits.\n      positionSuffixPadding\n  );\n  return new S2Cell(cellId);\n};\n\n/**\n * @private\n */\nfunction getS2Center(cellId, level) {\n  var faceSiTi = convertCellIdToFaceSiTi(cellId, level);\n  return convertFaceSiTitoXYZ(faceSiTi[0], faceSiTi[1], faceSiTi[2]);\n}\n/**\n * @private\n */\nfunction getS2Vertex(cellId, level, index) {\n  var faceIJ = convertCellIdToFaceIJ(cellId, level);\n  var uv = convertIJLeveltoBoundUV([faceIJ[1], faceIJ[2]], level);\n  // Handles CCW ordering of the vertices.\n  var y = (index >> 1) & 1;\n  return convertFaceUVtoXYZ(faceIJ[0], uv[0][y ^ (index & 1)], uv[1][y]);\n}\n\n// S2 Coordinate Conversions\n\n/**\n * @private\n */\nfunction convertCellIdToFaceSiTi(cellId, level) {\n  var faceIJ = convertCellIdToFaceIJ(cellId);\n  var face = faceIJ[0];\n  var i = faceIJ[1];\n  var j = faceIJ[2];\n\n  // We\'re resolving the center when we do the coordinate transform here. For the leaf cells, we\'re adding half the cell size\n  // (remember that this space has 31 levels - which allows us to pick center and edges of the leaf cells). For non leaf cells,\n  // we get one of either two cells diagonal to the cell center. The correction is used to make sure we pick the leaf cell edges\n  // that represent the parent cell center.\n  var isLeaf = level === 30;\n  var shouldCorrect =\n    !isLeaf && (BigInt(i) ^ (cellId >> BigInt(2))) & BigInt(1); // eslint-disable-line\n  var correction = isLeaf ? 1 : shouldCorrect ? 2 : 0;\n  var si = (i << 1) + correction;\n  var ti = (j << 1) + correction;\n  return [face, si, ti];\n}\n\n/**\n * @private\n */\nfunction convertCellIdToFaceIJ(cellId) {\n  if (S2_LOOKUP_POSITIONS.length === 0) {\n    generateLookupTable();\n  }\n\n  var face = Number(cellId >> BigInt(S2_POSITION_BITS)); // eslint-disable-line\n  var bits = face & S2_SWAP_MASK;\n  var lookupMask = (1 << S2_LOOKUP_BITS) - 1;\n\n  var i = 0;\n  var j = 0;\n\n  for (var k = 7; k >= 0; k--) {\n    var numberOfBits =\n      k === 7 ? S2_MAX_LEVEL - 7 * S2_LOOKUP_BITS : S2_LOOKUP_BITS;\n    var extractMask = (1 << (2 * numberOfBits)) - 1;\n    bits +=\n      Number(\n        (cellId >> BigInt(k * 2 * S2_LOOKUP_BITS + 1)) & BigInt(extractMask) // eslint-disable-line\n      ) << 2;\n\n    bits = S2_LOOKUP_IJ[bits];\n\n    var offset = k * S2_LOOKUP_BITS;\n    i += (bits >> (S2_LOOKUP_BITS + 2)) << offset;\n    j += ((bits >> 2) & lookupMask) << offset;\n\n    bits &= S2_SWAP_MASK | S2_INVERT_MASK;\n  }\n\n  return [face, i, j];\n}\n\n/**\n * @private\n */\nfunction convertFaceSiTitoXYZ(face, si, ti) {\n  var s = convertSiTitoST(si);\n  var t = convertSiTitoST(ti);\n\n  var u = convertSTtoUV(s);\n  var v = convertSTtoUV(t);\n  return convertFaceUVtoXYZ(face, u, v);\n}\n\n/**\n * @private\n */\nfunction convertFaceUVtoXYZ(face, u, v) {\n  switch (face) {\n    case 0:\n      return new _Cartesian3_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .Z(1, u, v);\n    case 1:\n      return new _Cartesian3_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .Z(-u, 1, v);\n    case 2:\n      return new _Cartesian3_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .Z(-u, -v, 1);\n    case 3:\n      return new _Cartesian3_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .Z(-1, -v, -u);\n    case 4:\n      return new _Cartesian3_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .Z(v, -1, -u);\n    default:\n      return new _Cartesian3_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .Z(v, u, -1);\n  }\n}\n\n/**\n * S2 provides 3 methods for the non-linear transform: linear, quadratic and tangential.\n * This implementation uses the quadratic method because it provides a good balance of\n * accuracy and speed.\n *\n * For a more detailed comparison of these transform methods, see\n * {@link https://github.com/google/s2geometry/blob/0c4c460bdfe696da303641771f9def900b3e440f/src/s2/s2metrics.cc}\n * @private\n */\nfunction convertSTtoUV(s) {\n  if (s >= 0.5) return (1 / 3) * (4 * s * s - 1);\n  return (1 / 3) * (1 - 4 * (1 - s) * (1 - s));\n}\n\n/**\n * @private\n */\nfunction convertSiTitoST(si) {\n  return (1.0 / S2_MAX_SITI) * si;\n}\n\n/**\n * @private\n */\nfunction convertIJLeveltoBoundUV(ij, level) {\n  var result = [[], []];\n  var cellSize = getSizeIJ(level);\n  for (var d = 0; d < 2; ++d) {\n    var ijLow = ij[d] & -cellSize;\n    var ijHigh = ijLow + cellSize;\n    result[d][0] = convertSTtoUV(convertIJtoSTMinimum(ijLow));\n    result[d][1] = convertSTtoUV(convertIJtoSTMinimum(ijHigh));\n  }\n  return result;\n}\n\n/**\n * @private\n */\nfunction getSizeIJ(level) {\n  return (1 << (S2_MAX_LEVEL - level)) >>> 0;\n}\n\n/**\n * @private\n */\nfunction convertIJtoSTMinimum(i) {\n  return (1.0 / S2_LIMIT_IJ) * i;\n}\n\n// Utility Functions\n\n/**\n * This function generates 4 variations of a Hilbert curve of level 4, based on the S2_POSITION_TO_IJ table, for fast lookups of (i, j)\n * to position along Hilbert curve. The reference C++ implementation uses an iterative approach, however, this function is implemented\n * recursively.\n *\n * See {@link https://github.com/google/s2geometry/blob/c59d0ca01ae3976db7f8abdc83fcc871a3a95186/src/s2/s2cell_id.cc#L75-L109}\n * @private\n */\nfunction generateLookupCell(\n  level,\n  i,\n  j,\n  originalOrientation,\n  position,\n  orientation\n) {\n  if (level === S2_LOOKUP_BITS) {\n    var ij = (i << S2_LOOKUP_BITS) + j;\n    S2_LOOKUP_POSITIONS[(ij << 2) + originalOrientation] =\n      (position << 2) + orientation;\n    S2_LOOKUP_IJ[(position << 2) + originalOrientation] =\n      (ij << 2) + orientation;\n  } else {\n    level++;\n    i <<= 1;\n    j <<= 1;\n    position <<= 2;\n    var r = S2_POSITION_TO_IJ[orientation];\n    generateLookupCell(\n      level,\n      i + (r[0] >> 1),\n      j + (r[0] & 1),\n      originalOrientation,\n      position,\n      orientation ^ S2_POSITION_TO_ORIENTATION_MASK[0]\n    );\n    generateLookupCell(\n      level,\n      i + (r[1] >> 1),\n      j + (r[1] & 1),\n      originalOrientation,\n      position + 1,\n      orientation ^ S2_POSITION_TO_ORIENTATION_MASK[1]\n    );\n    generateLookupCell(\n      level,\n      i + (r[2] >> 1),\n      j + (r[2] & 1),\n      originalOrientation,\n      position + 2,\n      orientation ^ S2_POSITION_TO_ORIENTATION_MASK[2]\n    );\n    generateLookupCell(\n      level,\n      i + (r[3] >> 1),\n      j + (r[3] & 1),\n      originalOrientation,\n      position + 3,\n      orientation ^ S2_POSITION_TO_ORIENTATION_MASK[3]\n    );\n  }\n}\n\n/**\n * @private\n */\nfunction generateLookupTable() {\n  generateLookupCell(0, 0, 0, 0, 0, 0);\n  generateLookupCell(0, 0, 0, S2_SWAP_MASK, 0, S2_SWAP_MASK);\n  generateLookupCell(0, 0, 0, S2_INVERT_MASK, 0, S2_INVERT_MASK);\n  generateLookupCell(\n    0,\n    0,\n    0,\n    S2_SWAP_MASK | S2_INVERT_MASK,\n    0,\n    S2_SWAP_MASK | S2_INVERT_MASK\n  );\n}\n\n/**\n * Return the lowest-numbered bit that is on for this cell id\n * @private\n */\nfunction lsb(cellId) {\n  return cellId & (~cellId + BigInt(1)); // eslint-disable-line\n}\n\n/**\n * Return the lowest-numbered bit that is on for cells at the given level.\n * @private\n */\nfunction lsbForLevel(level) {\n  return BigInt(1) << BigInt(2 * (S2_MAX_LEVEL - level)); // eslint-disable-line\n}\n\n// Lookup table for getting trailing zero bits.\n// https://graphics.stanford.edu/~seander/bithacks.html\nvar Mod67BitPosition = [\n  64,\n  0,\n  1,\n  39,\n  2,\n  15,\n  40,\n  23,\n  3,\n  12,\n  16,\n  59,\n  41,\n  19,\n  24,\n  54,\n  4,\n  64,\n  13,\n  10,\n  17,\n  62,\n  60,\n  28,\n  42,\n  30,\n  20,\n  51,\n  25,\n  44,\n  55,\n  47,\n  5,\n  32,\n  65,\n  38,\n  14,\n  22,\n  11,\n  58,\n  18,\n  53,\n  63,\n  9,\n  61,\n  27,\n  29,\n  50,\n  43,\n  46,\n  31,\n  37,\n  21,\n  57,\n  52,\n  8,\n  26,\n  49,\n  45,\n  36,\n  56,\n  7,\n  48,\n  35,\n  6,\n  34,\n  33,\n  0,\n];\n\n/**\n * Return the number of trailing zeros in number.\n * @private\n */\nfunction countTrailingZeroBits(x) {\n  return Mod67BitPosition[(-x & x) % BigInt(67)]; // eslint-disable-line\n}\n\n/* harmony default export */ __webpack_exports__["Z"] = (S2Cell);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QUFDQSxpQkFBaUIsK0RBQVU7QUFDM0I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsT0FBTztBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUM7QUFDekM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBEQUEwRDtBQUMxRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRDtBQUNsRDs7QUFFQSx5REFBZSxNQUFNLEVBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly92dWUzLXdlYnBhY2s1Ly4vbm9kZV9tb2R1bGVzL2Nlc2l1bS9Tb3VyY2UvQ29yZS9TMkNlbGwuanM/MDUxOSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiBlc2xpbnQtZGlzYWJsZSBuZXctY2FwICovXG5pbXBvcnQgQ2FydGVzaWFuMyBmcm9tIFwiLi9DYXJ0ZXNpYW4zLmpzXCI7XG5pbXBvcnQgQ2FydG9ncmFwaGljIGZyb20gXCIuL0NhcnRvZ3JhcGhpYy5qc1wiO1xuaW1wb3J0IENoZWNrIGZyb20gXCIuL0NoZWNrLmpzXCI7XG5pbXBvcnQgZGVmYXVsdFZhbHVlIGZyb20gXCIuL2RlZmF1bHRWYWx1ZS5qc1wiO1xuaW1wb3J0IGRlZmluZWQgZnJvbSBcIi4vZGVmaW5lZC5qc1wiO1xuaW1wb3J0IERldmVsb3BlckVycm9yIGZyb20gXCIuL0RldmVsb3BlckVycm9yLmpzXCI7XG5pbXBvcnQgRWxsaXBzb2lkIGZyb20gXCIuL0VsbGlwc29pZC5qc1wiO1xuaW1wb3J0IEZlYXR1cmVEZXRlY3Rpb24gZnJvbSBcIi4vRmVhdHVyZURldGVjdGlvbi5qc1wiO1xuaW1wb3J0IFJ1bnRpbWVFcnJvciBmcm9tIFwiLi9SdW50aW1lRXJyb3IuanNcIjtcblxuLyoqXG4gKiBTMlxuICogLS1cbiAqXG4gKiBUaGlzIGltcGxlbWVudGF0aW9uIGlzIGJhc2VkIG9uIHRoZSBTMiBDKysgcmVmZXJlbmNlIGltcGxlbWVudGF0aW9uOiBodHRwczovL2dpdGh1Yi5jb20vZ29vZ2xlL3MyZ2VvbWV0cnlcbiAqXG4gKlxuICogT3ZlcnZpZXc6XG4gKiAtLS0tLS0tLS1cbiAqIFRoZSBTMiBsaWJyYXJ5IGRlY29tcG9zZXMgdGhlIHVuaXQgc3BoZXJlIGludG8gYSBoaWVyYXJjaHkgb2YgY2VsbHMuIEEgY2VsbCBpcyBhIHF1YWRyaWxhdGVyYWwgYm91bmRlZCBieSA0IGdlb2Rlc2ljcy5cbiAqIFRoZSA2IHJvb3QgY2VsbHMgYXJlIG9idGFpbmVkIGJ5IHByb2plY3RpbmcgdGhlIHNpeCBmYWNlcyBvZiBhIGN1YmUgb24gYSB1bml0IHNwaGVyZS4gRWFjaCByb290IGNlbGwgZm9sbG93cyBhIHF1YWR0cmVlXG4gKiBzdWJkaXZpc2lvbiBzY2hlbWUsIGkuZS4gZWFjaCBjZWxsIHN1YmRpdmlkZXMgaW50byA0IHNtYWxsZXIgY2VsbHMgdGhhdCBjb3ZlciB0aGUgc2FtZSBhcmVhIGFzIHRoZSBwYXJlbnQgY2VsbC4gVGhlIFMyIGNlbGxcbiAqIGhpZXJhcmNoeSBleHRlbmRzIGZyb20gbGV2ZWwgMCAocm9vdCBjZWxscykgdG8gbGV2ZWwgMzAgKGxlYWYgY2VsbHMpLiBUaGUgcm9vdCBjZWxscyBhcmUgcm90YXRlZCB0byBlbmFibGUgYSBjb250aW51b3VzIEhpbGJlcnRcbiAqIGN1cnZlIHRvIG1hcCBhbGwgNiBmYWNlcyBvZiB0aGUgY3ViZS5cbiAqXG4gKlxuICogQ2VsbCBJRDpcbiAqIC0tLS0tLS0tXG4gKiBFYWNoIGNlbGwgaW4gUzIgY2FuIGJlIHVuaXF1ZWx5IGlkZW50aWZpZWQgdXNpbmcgYSA2NC1iaXQgdW5zaWduZWQgaW50ZWdlciwgaXRzIGNlbGwgSUQuIFRoZSBmaXJzdCAzIGJpdHMgb2YgdGhlIGNlbGwgSUQgYXJlIHRoZSBmYWNlIGJpdHMsIGkuZS5cbiAqIHRoZXkgaW5kaWNhdGUgd2hpY2ggb2YgdGhlIDYgZmFjZXMgb2YgdGhlIGN1YmUgYSBjZWxsIGxpZXMgb24uIEFmdGVyIHRoZSBmYWNlIGJpdHMgYXJlIHRoZSBwb3NpdGlvbiBiaXRzLCBpLmUuIHRoZXkgaW5kaWNhdGUgdGhlIHBvc2l0aW9uXG4gKiBvZiB0aGUgY2VsbCBhbG9uZyB0aGUgSGlsYmVydCBjdXJ2ZS4gQWZ0ZXIgdGhlIHBvc2l0aW9ucyBiaXRzIGlzIHRoZSBzZW50aW5lbCBiaXQsIHdoaWNoIGlzIGFsd2F5cyBzZXQgdG8gMSwgYW5kIGl0IGluZGljYXRlcyB0aGUgbGV2ZWwgb2YgdGhlXG4gKiBjZWxsLiBBZ2FpbiwgdGhlIGxldmVsIGNhbiBiZSBiZXR3ZWVuIDAgYW5kIDMwIGluIFMyLlxuICpcbiAqICAgTm90ZTogSW4gdGhlIGlsbHVzdHJhdGlvbiBiZWxvdywgdGhlIGZhY2UgYml0cyBhcmUgbWFya2VkIHdpdGggJ2YnLCB0aGUgcG9zaXRpb24gYml0cyBhcmUgbWFya2VkIHdpdGggJ3AnLCB0aGUgemVybyBiaXRzIGFyZSBtYXJrZWQgd2l0aCAnLScuXG4gKlxuICogICBDZWxsIElEIChiYXNlIDEwKTogMzE3MDUzNDEzNzY2ODgyOTE4NFxuICogICBDZWxsIElEIChiYXNlIDIpIDogMDAxMDExMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMFxuICpcbiAqICAgMDAxIDAxMTAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDBcbiAqICAgZmZmIHBwcy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqXG4gKiBGb3IgdGhlIGNlbGwgYWJvdmUsIHdlIGNhbiBzZWUgdGhhdCBpdCBsaWVzIG9uIGZhY2UgMSAoMDEpLCB3aXRoIGEgSGlsYmVydCBpbmRleCBvZiAxICgxKS5cbiAqXG4gKlxuICogQ2VsbCBTdWJkaXZpc2lvbjpcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLVxuICogQ2VsbHMgaW4gUzIgc3ViZGl2aWRlIHJlY3Vyc2l2ZWx5IHVzaW5nIHF1YWR0cmVlIHN1YmRpdmlzaW9uLiBGb3IgZWFjaCBjZWxsLCB5b3UgY2FuIGdldCBhIGNoaWxkIG9mIGluZGV4IFswLTNdLiBUbyBjb21wdXRlIHRoZSBjaGlsZCBhdCBpbmRleCBpLFxuICogaW5zZXJ0IHRoZSBiYXNlIDIgcmVwcmVzZW50YXRpb24gb2YgaSB0byB0aGUgcmlnaHQgb2YgdGhlIHBhcmVudCdzIHBvc2l0aW9uIGJpdHMuIEVuc3VyZSB0aGF0IHRoZSBzZW50aW5lbCBiaXQgaXMgYWxzbyBzaGlmdGVkIHR3byBwbGFjZXMgdG8gdGhlIHJpZ2h0LlxuICpcbiAqICAgUGFyZW50IENlbGwgSUQgKGJhc2UgMTApIDogMzE3MDUzNDEzNzY2ODgyOTE4NFxuICogICBQYXJlbnQgQ2VsbCBJRCAoYmFzZSAyKSAgOiAwMDEwMTEwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwXG4gKlxuICogICAwMDEgMDExMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMFxuICogICBmZmYgcHBzLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICpcbiAqICAgVG8gZ2V0IHRoZSAzcmQgY2hpbGQgb2YgdGhlIGNlbGwgYWJvdmUsIHdlIGluc2VydCB0aGUgYmluYXJ5IHJlcHJlc2VudGF0aW9uIG9mIDMgdG8gdGhlIHJpZ2h0IG9mIHRoZSBwYXJlbnQncyBwb3NpdGlvbiBiaXRzOlxuICpcbiAqICAgTm90ZTogSW4gdGhlIGlsbHVzdHJhdGlvbiBiZWxvdywgdGhlIGJpdHMgdG8gYmUgYWRkZWQgYXJlIGhpZ2hsaWdodGVkIHdpdGggJ14nLlxuICpcbiAqICAgMDAxIDAxMTExMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDBcbiAqICAgZmZmIHBwcHBzLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqICAgICAgICAgXl5cbiAqXG4gKiAgIENoaWxkKDMpIENlbGwgSUQgKGJhc2UgMTApIDogMzM4NjcwNjkxOTc4MjYxMjk5MlxuICogICBDaGlsZCgzKSBDZWxsIElEIChiYXNlIDIpICA6IDAwMTAxMTExMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDBcbiAqXG4gKiBDZWxsIFRva2VuOlxuICogLS0tLS0tLS0tLS1cbiAqIFRvIHByb3ZpZGUgYSBtb3JlIGNvbmNpc2UgcmVwcmVzZW50YXRpb24gb2YgdGhlIFMyIGNlbGwgSUQsIHdlIGNhbiB1c2UgdGhlaXIgaGV4YWRlY2ltYWwgcmVwcmVzZW50YXRpb24uXG4gKlxuICogICBDZWxsIElEIChiYXNlIDEwKTogMzE3MDUzNDEzNzY2ODgyOTE4NFxuICogICBDZWxsIElEIChiYXNlIDIpIDogMDAxMDExMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMFxuICpcbiAqICAgV2UgcmVtb3ZlIGFsbCB0cmFpbGluZyB6ZXJvIGJpdHMsIHVudGlsIHdlIHJlYWNoIHRoZSBueWJibGUgKDQgYml0cykgdGhhdCBjb250YWlucyB0aGUgc2VudGluZWwgYml0LlxuICpcbiAqICAgTm90ZTogSW4gdGhlIGlsbHVzdHJhdGlvbiBiZWxvdywgdGhlIGJpdHMgdG8gYmUgcmVtb3ZlZCBhcmUgaGlnaGxpZ2h0ZWQgd2l0aCAnWCcuXG4gKlxuICogICAwMDEwMTEwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwXG4gKiAgIGZmZnBwcy0tWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhcbiAqXG4gKiAgIFdlIGNvbnZlcnQgdGhlIHJlbWFpbmluZyBiaXRzIHRvIHRoZWlyIGhleGFkZWNpbWFsIHJlcHJlc2VudGF0aW9uLlxuICpcbiAqICAgQmFzZSAyOiAwMDEwIDExMDBcbiAqICAgQmFzZSAxNjogXCIyXCIgIFwiY1wiXG4gKlxuICogICBDZWxsIFRva2VuOiBcIjJjXCJcbiAqXG4gKiBUbyBjb21wdXRlIHRoZSBjZWxsIElEIGZyb20gdGhlIHRva2VuLCB3ZSBzaW1wbHkgYWRkIGVub3VnaCB6ZXJvcyB0byB0aGUgcmlnaHQgdG8gbWFrZSB0aGUgSUQgc3BhbiA2NCBiaXRzLlxuICpcbiAqIENvb3JkaW5hdGUgVHJhbnNmb3JtczpcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqXG4gKiBUbyBnbyBmcm9tIGEgY2VsbCBpbiBTMiB0byBhIHBvaW50IG9uIHRoZSBlbGxpcHNvaWQsIHRoZSBmb2xsb3dpbmcgb3JkZXIgb2YgdHJhbnNmb3JtcyBpcyBhcHBsaWVkOlxuICpcbiAqICAgMS4gKENlbGwgSUQpOiBTMiBjZWxsIElEXG4gKiAgIDIuIChGYWNlLCBJLCBKKTogTGVhZiBjZWxsIGNvb3JkaW5hdGVzLCB3aGVyZSBpIGFuZCBqIGFyZSBpbiByYW5nZSBbMCwgMl4zMCAtIDFdXG4gKiAgIDMuIChGYWNlLCBTLCBUKTogQ2VsbCBzcGFjZSBjb29yZGluYXRlcywgd2hlcmUgcyBhbmQgdCBhcmUgaW4gcmFuZ2UgWzAsIDFdLlxuICogICA0LiAoRmFjZSwgU2ksIFRpKTogRGlzY3JldGUgY2VsbCBzcGFjZSBjb29yZGluYXRlcywgd2hlcmUgc2kgYW5kIHRpIGFyZSBpbiByYW5nZSBbMCwgMl4zMV1cbiAqICAgNS4gKEZhY2UsIFUsIFYpOiBDdWJlIHNwYWNlIGNvb3JkaW5hdGVzLCB3aGVyZSB1IGFuZCB2IGFyZSBpbiByYW5nZSBbLTEsIDFdLiBXZSBhcHBseSB0aGUgbm9uLWxpbmVhciBxdWFkcmF0aWMgdHJhbnNmb3JtIGhlcmUuXG4gKiAgIDYuIChYLCBZLCBaKTogRGlyZWN0aW9uIHZlY3Rvciwgd2hlcmUgdmVjdG9yIG1heSBub3QgYmUgdW5pdCBsZW5ndGguIENhbiBiZSBub3JtYWxpemVkIHRvIG9idGFpbiBwb2ludCBvbiB1bml0IHNwaGVyZVxuICogICA3LiAoTGF0aXR1ZGUsIExvbmdpdHVkZSk6IERpcmVjdGlvbiB2ZWN0b3IsIHdoZXJlIGxhdGl0dWRlIGlzIGluIHJhbmdlIFstOTAsIDkwXSBhbmQgbG9uZ2l0dWRlIGlzIGluIHJhbmdlIFstMTgwLCAxODBdXG4gKlxuICogQGlnbm9yZVxuICovXG5cbi8vIFRoZSBtYXhpbXVtIGxldmVsIHN1cHBvcnRlZCB3aXRoaW4gYW4gUzIgY2VsbCBJRC4gRWFjaCBsZXZlbCBpcyByZXByZXNlbnRlZCBieSB0d28gYml0cyBpbiB0aGUgZmluYWwgY2VsbCBJRFxudmFyIFMyX01BWF9MRVZFTCA9IDMwO1xuXG4vLyBUaGUgbWF4aW11bSBpbmRleCBvZiBhIHZhbGlkIGxlYWYgY2VsbCBwbHVzIG9uZS4gIFRoZSByYW5nZSBvZiB2YWxpZCBsZWFmIGNlbGwgaW5kaWNlcyBpcyBbMC4uUzJfTElNSVRfSUotMV0uXG52YXIgUzJfTElNSVRfSUogPSAxIDw8IFMyX01BWF9MRVZFTDtcblxuLy8gVGhlIG1heGltdW0gdmFsdWUgb2YgYW4gc2ktIG9yIHRpLWNvb3JkaW5hdGUuICBUaGUgcmFuZ2Ugb2YgdmFsaWQgKHNpLHRpKSB2YWx1ZXMgaXMgWzAuLlMyX01BWF9TSVRJXS4gIFVzZSBgPj4+YCB0byBjb252ZXJ0IHRvIHVuc2lnbmVkLlxudmFyIFMyX01BWF9TSVRJID0gKDEgPDwgKFMyX01BWF9MRVZFTCArIDEpKSA+Pj4gMDtcblxuLy8gVGhlIG51bWJlciBvZiBiaXRzIGluIGEgUzIgY2VsbCBJRCB1c2VkIGZvciBzcGVjaWZ5aW5nIHRoZSBwb3NpdGlvbiBhbG9uZyB0aGUgSGlsYmVydCBjdXJ2ZVxudmFyIFMyX1BPU0lUSU9OX0JJVFMgPSAyICogUzJfTUFYX0xFVkVMICsgMTtcblxuLy8gVGhlIG51bWJlciBvZiBiaXRzIHBlciBJIGFuZCBKIGluIHRoZSBsb29rdXAgdGFibGVzXG52YXIgUzJfTE9PS1VQX0JJVFMgPSA0O1xuXG4vLyBMb29rdXAgdGFibGUgZm9yIG1hcHBpbmcgMTAgYml0cyBvZiBJSiArIG9yaWVudGF0aW9uIHRvIDEwIGJpdHMgb2YgSGlsYmVydCBjdXJ2ZSBwb3NpdGlvbiArIG9yaWVudGF0aW9uLlxudmFyIFMyX0xPT0tVUF9QT1NJVElPTlMgPSBbXTtcblxuLy8gTG9va3VwIHRhYmxlIGZvciBtYXBwaW5nIDEwIGJpdHMgb2YgSUogKyBvcmllbnRhdGlvbiB0byAxMCBiaXRzIG9mIEhpbGJlcnQgY3VydmUgcG9zaXRpb24gKyBvcmllbnRhdGlvbi5cbnZhciBTMl9MT09LVVBfSUogPSBbXTtcblxuLy8gTG9va3VwIHRhYmxlIG9mIHR3byBiaXRzIG9mIElKIGZyb20gdHdvIGJpdHMgb2YgY3VydmUgcG9zaXRpb24sIGJhc2VkIGFsc28gb24gdGhlIGN1cnJlbnQgY3VydmUgb3JpZW50YXRpb24gZnJvbSB0aGUgc3dhcCBhbmQgaW52ZXJ0IGJpdHNcbnZhciBTMl9QT1NJVElPTl9UT19JSiA9IFtcbiAgWzAsIDEsIDMsIDJdLCAvLyAwOiBOb3JtYWwgb3JkZXIsIG5vIHN3YXAgb3IgaW52ZXJ0XG4gIFswLCAyLCAzLCAxXSwgLy8gMTogU3dhcCBiaXQgc2V0LCBzd2FwIEkgYW5kIEogYml0c1xuICBbMywgMiwgMCwgMV0sIC8vIDI6IEludmVydCBiaXQgc2V0LCBpbnZlcnQgYml0c1xuICBbMywgMSwgMCwgMl0sIC8vIDM6IFN3YXAgYW5kIGludmVydCBiaXRzIHNldFxuXTtcblxuLy8gTWFzayB0aGF0IHNwZWNpZmllcyB0aGUgc3dhcCBvcmllbnRhdGlvbiBiaXQgZm9yIHRoZSBIaWxiZXJ0IGN1cnZlXG52YXIgUzJfU1dBUF9NQVNLID0gMTtcblxuLy8gTWFzayB0aGF0IHNwZWNpZmllcyB0aGUgaW52ZXJ0IG9yaWVudGF0aW9uIGJpdCBmb3IgdGhlIEhpbGJlcnQgY3VydmVcbnZhciBTMl9JTlZFUlRfTUFTSyA9IDI7XG5cbi8vIExvb2t1cCBmb3IgdGhlIG9yaWVudGF0aW9uIHVwZGF0ZSBtYXNrIG9mIG9uZSBvZiB0aGUgZm91ciBzdWItY2VsbHMgd2l0aGluIGEgaGlnaGVyIGxldmVsIGNlbGwuXG4vLyBUaGlzIG1hc2sgaXMgWE9SJ2VkIHdpdGggdGhlIGN1cnJlbnQgb3JpZW50YXRpb24gdG8gZ2V0IHRoZSBzdWItY2VsbCBvcmllbnRhdGlvbi5cbnZhciBTMl9QT1NJVElPTl9UT19PUklFTlRBVElPTl9NQVNLID0gW1xuICBTMl9TV0FQX01BU0ssXG4gIDAsXG4gIDAsXG4gIFMyX1NXQVBfTUFTSyB8IFMyX0lOVkVSVF9NQVNLLFxuXTtcblxuLyoqXG4gKiBSZXByZXNlbnRzIGEgY2VsbCBpbiB0aGUgUzIgZ2VvbWV0cnkgbGlicmFyeS5cbiAqXG4gKiBAYWxpYXMgUzJDZWxsXG4gKiBAY29uc3RydWN0b3JcbiAqXG4gKiBAcGFyYW0ge0JpZ0ludH0gW2NlbGxJZF0gVGhlIDY0LWJpdCBTMkNlbGxJZC5cbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIFMyQ2VsbChjZWxsSWQpIHtcbiAgaWYgKCFGZWF0dXJlRGV0ZWN0aW9uLnN1cHBvcnRzQmlnSW50KCkpIHtcbiAgICB0aHJvdyBuZXcgUnVudGltZUVycm9yKFwiUzIgcmVxdWlyZWQgQmlnSW50IHN1cHBvcnRcIik7XG4gIH1cbiAgLy8+PmluY2x1ZGVTdGFydCgnZGVidWcnLCBwcmFnbWFzLmRlYnVnKTtcbiAgaWYgKCFkZWZpbmVkKGNlbGxJZCkpIHtcbiAgICB0aHJvdyBuZXcgRGV2ZWxvcGVyRXJyb3IoXCJjZWxsIElEIGlzIHJlcXVpcmVkLlwiKTtcbiAgfVxuICBpZiAoIVMyQ2VsbC5pc1ZhbGlkSWQoY2VsbElkKSkge1xuICAgIHRocm93IG5ldyBEZXZlbG9wZXJFcnJvcihcImNlbGwgSUQgaXMgaW52YWxpZC5cIik7XG4gIH1cbiAgLy8+PmluY2x1ZGVFbmQoJ2RlYnVnJyk7XG5cbiAgdGhpcy5fY2VsbElkID0gY2VsbElkO1xuICB0aGlzLl9sZXZlbCA9IFMyQ2VsbC5nZXRMZXZlbChjZWxsSWQpO1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgUzJDZWxsIGZyb20gYSB0b2tlbi4gQSB0b2tlbiBpcyBhIGhleGFkZWNpbWFsIHJlcHJlc2VudGF0aW9uIG9mIHRoZSA2NC1iaXQgUzJDZWxsSWQuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHRva2VuIFRoZSB0b2tlbiBmb3IgdGhlIFMyIENlbGwuXG4gKiBAcmV0dXJucyB7UzJDZWxsfSBSZXR1cm5zIGEgbmV3IFMyQ2VsbC5cbiAqIEBwcml2YXRlXG4gKi9cblMyQ2VsbC5mcm9tVG9rZW4gPSBmdW5jdGlvbiAodG9rZW4pIHtcbiAgLy8+PmluY2x1ZGVTdGFydCgnZGVidWcnLCBwcmFnbWFzLmRlYnVnKTtcbiAgQ2hlY2sudHlwZU9mLnN0cmluZyhcInRva2VuXCIsIHRva2VuKTtcbiAgaWYgKCFTMkNlbGwuaXNWYWxpZFRva2VuKHRva2VuKSkge1xuICAgIHRocm93IG5ldyBEZXZlbG9wZXJFcnJvcihcInRva2VuIGlzIGludmFsaWQuXCIpO1xuICB9XG4gIC8vPj5pbmNsdWRlRW5kKCdkZWJ1ZycpO1xuXG4gIHJldHVybiBuZXcgUzJDZWxsKFMyQ2VsbC5nZXRJZEZyb21Ub2tlbih0b2tlbikpO1xufTtcblxuLyoqXG4gKiBWYWxpZGF0ZXMgYW4gUzIgY2VsbCBJRC5cbiAqXG4gKiBAcGFyYW0ge0JpZ0ludH0gW2NlbGxJZF0gVGhlIFMyQ2VsbElkLlxuICogQHJldHVybnMge0Jvb2xlYW59IFJldHVybnMgdHJ1ZSBpZiB0aGUgY2VsbCBJRCBpcyB2YWxpZCwgcmV0dXJucyBmYWxzZSBvdGhlcndpc2UuXG4gKiBAcHJpdmF0ZVxuICovXG5TMkNlbGwuaXNWYWxpZElkID0gZnVuY3Rpb24gKGNlbGxJZCkge1xuICAvLz4+aW5jbHVkZVN0YXJ0KCdkZWJ1ZycsIHByYWdtYXMuZGVidWcpO1xuICBDaGVjay50eXBlT2YuYmlnaW50KFwiY2VsbElkXCIsIGNlbGxJZCk7XG4gIC8vPj5pbmNsdWRlRW5kKCdkZWJ1ZycpO1xuXG4gIC8vIENoZWNrIGlmIHNlbnRpbmVsIGJpdCBpcyBtaXNzaW5nLlxuICBpZiAoY2VsbElkIDw9IDApIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICAvLyBDaGVjayBpZiBmYWNlIGJpdHMgaW5kaWNhdGUgYSB2YWxpZCB2YWx1ZSwgaW4gcmFuZ2UgWzAtNV0uXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZVxuICBpZiAoY2VsbElkID4+IEJpZ0ludChTMl9QT1NJVElPTl9CSVRTKSA+IDUpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICAvLyBDaGVjayB0cmFpbGluZyAxIGJpdCBpcyBpbiBvbmUgb2YgdGhlIGV2ZW4gYml0IHBvc2l0aW9ucyBhbGxvd2VkIGZvciB0aGUgMzAgbGV2ZWxzLCB1c2luZyBhIGJpdG1hc2suXG4gIHZhciBsb3dlc3RTZXRCaXQgPSBjZWxsSWQgJiAofmNlbGxJZCArIEJpZ0ludCgxKSk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmVcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lXG4gIGlmICghKGxvd2VzdFNldEJpdCAmIEJpZ0ludChcIjB4MTU1NTU1NTU1NTU1NTU1NVwiKSkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn07XG5cbi8qKlxuICogVmFsaWRhdGVzIGFuIFMyIGNlbGwgdG9rZW4uXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IFt0b2tlbl0gVGhlIGhleGFkZWNpbWFsIHJlcHJlc2VudGF0aW9uIG9mIGFuIFMyQ2VsbElkLlxuICogQHJldHVybnMge0Jvb2xlYW59IFJldHVybnMgdHJ1ZSBpZiB0aGUgdG9rZW4gaXMgdmFsaWQsIHJldHVybnMgZmFsc2Ugb3RoZXJ3aXNlLlxuICogQHByaXZhdGVcbiAqL1xuUzJDZWxsLmlzVmFsaWRUb2tlbiA9IGZ1bmN0aW9uICh0b2tlbikge1xuICAvLz4+aW5jbHVkZVN0YXJ0KCdkZWJ1ZycsIHByYWdtYXMuZGVidWcpO1xuICBDaGVjay50eXBlT2Yuc3RyaW5nKFwidG9rZW5cIiwgdG9rZW4pO1xuICAvLz4+aW5jbHVkZUVuZCgnZGVidWcnKTtcblxuICBpZiAoIS9eWzAtOWEtZkEtRl17MSwxNn0kLy50ZXN0KHRva2VuKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHJldHVybiBTMkNlbGwuaXNWYWxpZElkKFMyQ2VsbC5nZXRJZEZyb21Ub2tlbih0b2tlbikpO1xufTtcblxuLyoqXG4gKiBDb252ZXJ0cyBhbiBTMiBjZWxsIHRva2VuIHRvIGEgNjQtYml0IFMyIGNlbGwgSUQuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IFt0b2tlbl0gVGhlIGhleGFkZWNpbWFsIHJlcHJlc2VudGF0aW9uIG9mIGFuIFMyQ2VsbElkLiBFeHBlY3RlZCB0byBiZSBhIHZhbGlkIFMyIHRva2VuLlxuICogQHJldHVybnMge0JpZ0ludH0gUmV0dXJucyB0aGUgUzIgY2VsbCBJRC5cbiAqIEBwcml2YXRlXG4gKi9cblMyQ2VsbC5nZXRJZEZyb21Ub2tlbiA9IGZ1bmN0aW9uICh0b2tlbikge1xuICAvLz4+aW5jbHVkZVN0YXJ0KCdkZWJ1ZycsIHByYWdtYXMuZGVidWcpO1xuICBDaGVjay50eXBlT2Yuc3RyaW5nKFwidG9rZW5cIiwgdG9rZW4pO1xuICAvLz4+aW5jbHVkZUVuZCgnZGVidWcnKTtcblxuICByZXR1cm4gQmlnSW50KFwiMHhcIiArIHRva2VuICsgXCIwXCIucmVwZWF0KDE2IC0gdG9rZW4ubGVuZ3RoKSk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmVcbn07XG5cbi8qKlxuICogQ29udmVydHMgYSA2NC1iaXQgUzIgY2VsbCBJRCB0byBhbiBTMiBjZWxsIHRva2VuLlxuICpcbiAqIEBwYXJhbSB7QmlnSW50fSBbY2VsbElkXSBUaGUgUzIgY2VsbCBJRC5cbiAqIEByZXR1cm5zIHtCaWdJbnR9IFJldHVybnMgaGV4YWRlY2ltYWwgcmVwcmVzZW50YXRpb24gb2YgYW4gUzJDZWxsSWQuXG4gKiBAcHJpdmF0ZVxuICovXG5TMkNlbGwuZ2V0VG9rZW5Gcm9tSWQgPSBmdW5jdGlvbiAoY2VsbElkKSB7XG4gIC8vPj5pbmNsdWRlU3RhcnQoJ2RlYnVnJywgcHJhZ21hcy5kZWJ1Zyk7XG4gIENoZWNrLnR5cGVPZi5iaWdpbnQoXCJjZWxsSWRcIiwgY2VsbElkKTtcbiAgLy8+PmluY2x1ZGVFbmQoJ2RlYnVnJyk7XG5cbiAgdmFyIHRyYWlsaW5nWmVyb0hleENoYXJzID0gTWF0aC5mbG9vcihjb3VudFRyYWlsaW5nWmVyb0JpdHMoY2VsbElkKSAvIDQpO1xuICB2YXIgaGV4U3RyaW5nID0gY2VsbElkLnRvU3RyaW5nKDE2KS5yZXBsYWNlKC8wKiQvLCBcIlwiKTtcblxuICB2YXIgemVyb1N0cmluZyA9IEFycmF5KDE3IC0gdHJhaWxpbmdaZXJvSGV4Q2hhcnMgLSBoZXhTdHJpbmcubGVuZ3RoKS5qb2luKFxuICAgIFwiMFwiXG4gICk7XG4gIHJldHVybiB6ZXJvU3RyaW5nICsgaGV4U3RyaW5nO1xufTtcblxuLyoqXG4gKiBHZXRzIHRoZSBsZXZlbCBvZiB0aGUgY2VsbCBmcm9tIHRoZSBjZWxsIElELlxuICpcbiAqIEBwYXJhbSB7QmlnSW50fSBbY2VsbElkXSBUaGUgUzIgY2VsbCBJRC5cbiAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIGxldmVsIG9mIHRoZSBjZWxsLlxuICogQHByaXZhdGVcbiAqL1xuUzJDZWxsLmdldExldmVsID0gZnVuY3Rpb24gKGNlbGxJZCkge1xuICAvLz4+aW5jbHVkZVN0YXJ0KCdkZWJ1ZycsIHByYWdtYXMuZGVidWcpO1xuICBDaGVjay50eXBlT2YuYmlnaW50KFwiY2VsbElkXCIsIGNlbGxJZCk7XG4gIGlmICghUzJDZWxsLmlzVmFsaWRJZChjZWxsSWQpKSB7XG4gICAgdGhyb3cgbmV3IERldmVsb3BlckVycm9yKCk7XG4gIH1cbiAgLy8+PmluY2x1ZGVFbmQoJ2RlYnVnJyk7XG5cbiAgdmFyIGxzYlBvc2l0aW9uID0gMDtcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lXG4gIHdoaWxlIChjZWxsSWQgIT09IEJpZ0ludCgwKSkge1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZVxuICAgIGlmIChjZWxsSWQgJiBCaWdJbnQoMSkpIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBsc2JQb3NpdGlvbisrO1xuICAgIGNlbGxJZCA9IGNlbGxJZCA+PiBCaWdJbnQoMSk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmVcbiAgfVxuXG4gIC8vIFdlIHVzZSAoPj4gMSkgYmVjYXVzZSB0aGVyZSBhcmUgMiBiaXRzIHBlciBsZXZlbC5cbiAgcmV0dXJuIFMyX01BWF9MRVZFTCAtIChsc2JQb3NpdGlvbiA+PiAxKTtcbn07XG5cbi8qKlxuICogR2V0cyB0aGUgY2hpbGQgY2VsbCBvZiB0aGUgY2VsbCBhdCB0aGUgZ2l2ZW4gaW5kZXguXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IGluZGV4IEFuIGludGVnZXIgaW5kZXggb2YgdGhlIGNoaWxkLlxuICogQHJldHVybnMge1MyQ2VsbH0gVGhlIGNoaWxkIG9mIHRoZSBTMkNlbGwuXG4gKiBAcHJpdmF0ZVxuICovXG5TMkNlbGwucHJvdG90eXBlLmdldENoaWxkID0gZnVuY3Rpb24gKGluZGV4KSB7XG4gIC8vPj5pbmNsdWRlU3RhcnQoJ2RlYnVnJywgcHJhZ21hcy5kZWJ1Zyk7XG4gIENoZWNrLnR5cGVPZi5udW1iZXIoXCJpbmRleFwiLCBpbmRleCk7XG4gIGlmIChpbmRleCA8IDAgfHwgaW5kZXggPiAzKSB7XG4gICAgdGhyb3cgbmV3IERldmVsb3BlckVycm9yKFwiY2hpbGQgaW5kZXggbXVzdCBiZSBpbiB0aGUgcmFuZ2UgWzAtM10uXCIpO1xuICB9XG4gIGlmICh0aGlzLl9sZXZlbCA9PT0gMzApIHtcbiAgICB0aHJvdyBuZXcgRGV2ZWxvcGVyRXJyb3IoXCJjYW5ub3QgZ2V0IGNoaWxkIG9mIGxlYWYgY2VsbC5cIik7XG4gIH1cbiAgLy8+PmluY2x1ZGVFbmQoJ2RlYnVnJyk7XG5cbiAgLy8gU2hpZnQgc2VudGluZWwgYml0IDIgcG9zaXRpb25zIHRvIHRoZSByaWdodC5cbiAgdmFyIG5ld0xzYiA9IGxzYih0aGlzLl9jZWxsSWQpID4+IEJpZ0ludCgyKTsgLy8gZXNsaW50LWRpc2FibGUtbGluZVxuICAvLyBJbnNlcnQgY2hpbGQgaW5kZXggYmVmb3JlIHRoZSBzZW50aW5lbCBiaXQuXG4gIHZhciBjaGlsZENlbGxJZCA9IHRoaXMuX2NlbGxJZCArIEJpZ0ludCgyICogaW5kZXggKyAxIC0gNCkgKiBuZXdMc2I7IC8vIGVzbGludC1kaXNhYmxlLWxpbmVcbiAgcmV0dXJuIG5ldyBTMkNlbGwoY2hpbGRDZWxsSWQpO1xufTtcblxuLyoqXG4gKiBHZXRzIHRoZSBwYXJlbnQgY2VsbCBvZiBhbiBTMkNlbGwuXG4gKlxuICogQHJldHVybnMge1MyQ2VsbH0gUmV0dXJucyB0aGUgcGFyZW50IG9mIHRoZSBTMkNlbGwuXG4gKiBAcHJpdmF0ZVxuICovXG5TMkNlbGwucHJvdG90eXBlLmdldFBhcmVudCA9IGZ1bmN0aW9uICgpIHtcbiAgLy8+PmluY2x1ZGVTdGFydCgnZGVidWcnLCBwcmFnbWFzLmRlYnVnKTtcbiAgaWYgKHRoaXMuX2xldmVsID09PSAwKSB7XG4gICAgdGhyb3cgbmV3IERldmVsb3BlckVycm9yKFwiY2Fubm90IGdldCBwYXJlbnQgb2Ygcm9vdCBjZWxsLlwiKTtcbiAgfVxuICAvLz4+aW5jbHVkZUVuZCgnZGVidWcnKTtcbiAgLy8gU2hpZnQgdGhlIHNlbnRpbmVsIGJpdCAyIHBvc2l0aW9ucyB0byB0aGUgbGVmdC5cbiAgdmFyIG5ld0xzYiA9IGxzYih0aGlzLl9jZWxsSWQpIDw8IEJpZ0ludCgyKTsgLy8gZXNsaW50LWRpc2FibGUtbGluZVxuICAvLyBFcmFzZSB0aGUgbGVmdCBvdmVyIGJpdHMgdG8gdGhlIHJpZ2h0IG9mIHRoZSBzZW50aW5lbCBiaXQuXG4gIHJldHVybiBuZXcgUzJDZWxsKCh0aGlzLl9jZWxsSWQgJiAofm5ld0xzYiArIEJpZ0ludCgxKSkpIHwgbmV3THNiKTsgLy8gZXNsaW50LWRpc2FibGUtbGluZVxufTtcblxuLyoqXG4gKiBHZXRzIHRoZSBwYXJlbnQgY2VsbCBhdCB0aGUgZ2l2ZW4gbGV2ZWwuXG4gKlxuICogQHJldHVybnMge1MyQ2VsbH0gUmV0dXJucyB0aGUgcGFyZW50IG9mIHRoZSBTMkNlbGwuXG4gKiBAcHJpdmF0ZVxuICovXG5TMkNlbGwucHJvdG90eXBlLmdldFBhcmVudEF0TGV2ZWwgPSBmdW5jdGlvbiAobGV2ZWwpIHtcbiAgLy8+PmluY2x1ZGVTdGFydCgnZGVidWcnLCBwcmFnbWFzLmRlYnVnKTtcbiAgaWYgKHRoaXMuX2xldmVsID09PSAwIHx8IGxldmVsIDwgMCB8fCB0aGlzLl9sZXZlbCA8IGxldmVsKSB7XG4gICAgdGhyb3cgbmV3IERldmVsb3BlckVycm9yKFwiY2Fubm90IGdldCBwYXJlbnQgYXQgaW52YWxpZCBsZXZlbC5cIik7XG4gIH1cbiAgLy8+PmluY2x1ZGVFbmQoJ2RlYnVnJyk7XG4gIHZhciBuZXdMc2IgPSBsc2JGb3JMZXZlbChsZXZlbCk7XG4gIHJldHVybiBuZXcgUzJDZWxsKCh0aGlzLl9jZWxsSWQgJiAtbmV3THNiKSB8IG5ld0xzYik7XG59O1xuXG4vKipcbiAqIEdldCBjZW50ZXIgb2YgdGhlIFMyIGNlbGwuXG4gKlxuICogQHBhcmFtIHtFbGxpcHNvaWR9IFtvcHRpb25zLmVsbGlwc29pZD1FbGxpcHNvaWQuV0dTODRdIFRoZSBlbGxpcHNvaWQuXG4gKiBAcmV0dXJucyB7Q2FydGVzaWFufSBUaGUgcG9zaXRpb24gb2YgY2VudGVyIG9mIHRoZSBTMiBjZWxsLlxuICogQHByaXZhdGVcbiAqL1xuUzJDZWxsLnByb3RvdHlwZS5nZXRDZW50ZXIgPSBmdW5jdGlvbiAoZWxsaXBzb2lkKSB7XG4gIGVsbGlwc29pZCA9IGRlZmF1bHRWYWx1ZShlbGxpcHNvaWQsIEVsbGlwc29pZC5XR1M4NCk7XG5cbiAgdmFyIGNlbnRlciA9IGdldFMyQ2VudGVyKHRoaXMuX2NlbGxJZCwgdGhpcy5fbGV2ZWwpO1xuICAvLyBOb3JtYWxpemUgWFlaLlxuICBjZW50ZXIgPSBDYXJ0ZXNpYW4zLm5vcm1hbGl6ZShjZW50ZXIsIGNlbnRlcik7XG4gIHZhciBjYXJ0b2dyYXBoaWMgPSBuZXcgQ2FydG9ncmFwaGljLmZyb21DYXJ0ZXNpYW4oXG4gICAgY2VudGVyLFxuICAgIEVsbGlwc29pZC5VTklUX1NQSEVSRVxuICApO1xuICAvLyBJbnRlcnByZXQgYXMgZ2VvZGV0aWMgY29vcmRpbmF0ZXMgb24gdGhlIGVsbGlwc29pZC5cbiAgcmV0dXJuIENhcnRvZ3JhcGhpYy50b0NhcnRlc2lhbihjYXJ0b2dyYXBoaWMsIGVsbGlwc29pZCwgbmV3IENhcnRlc2lhbjMoKSk7XG59O1xuXG4vKipcbiAqIEdldCB2ZXJ0ZXggb2YgdGhlIFMyIGNlbGwuIFZlcnRpY2VzIGFyZSBpbmRleGVkIGluIENDVyBvcmRlci5cbiAqXG4gKiBAcGFyYW0ge051bWJlcn0gaW5kZXggQW4gaW50ZWdlciBpbmRleCBvZiB0aGUgdmVydGV4LiBNdXN0IGJlIGluIHRoZSByYW5nZSBbMC0zXS5cbiAqIEBwYXJhbSB7RWxsaXBzb2lkfSBbb3B0aW9ucy5lbGxpcHNvaWQ9RWxsaXBzb2lkLldHUzg0XSBUaGUgZWxsaXBzb2lkLlxuICogQHJldHVybnMge0NhcnRlc2lhbn0gVGhlIHBvc2l0aW9uIG9mIHRoZSB2ZXJ0ZXggb2YgdGhlIFMyIGNlbGwuXG4gKiBAcHJpdmF0ZVxuICovXG5TMkNlbGwucHJvdG90eXBlLmdldFZlcnRleCA9IGZ1bmN0aW9uIChpbmRleCwgZWxsaXBzb2lkKSB7XG4gIC8vPj5pbmNsdWRlU3RhcnQoJ2RlYnVnJywgcHJhZ21hcy5kZWJ1Zyk7XG4gIENoZWNrLnR5cGVPZi5udW1iZXIoXCJpbmRleFwiLCBpbmRleCk7XG4gIGlmIChpbmRleCA8IDAgfHwgaW5kZXggPiAzKSB7XG4gICAgdGhyb3cgbmV3IERldmVsb3BlckVycm9yKFwidmVydGV4IGluZGV4IG11c3QgYmUgaW4gdGhlIHJhbmdlIFswLTNdLlwiKTtcbiAgfVxuICAvLz4+aW5jbHVkZUVuZCgnZGVidWcnKTtcblxuICBlbGxpcHNvaWQgPSBkZWZhdWx0VmFsdWUoZWxsaXBzb2lkLCBFbGxpcHNvaWQuV0dTODQpO1xuXG4gIHZhciB2ZXJ0ZXggPSBnZXRTMlZlcnRleCh0aGlzLl9jZWxsSWQsIHRoaXMuX2xldmVsLCBpbmRleCk7XG4gIC8vIE5vcm1hbGl6ZSBYWVouXG4gIHZlcnRleCA9IENhcnRlc2lhbjMubm9ybWFsaXplKHZlcnRleCwgdmVydGV4KTtcbiAgdmFyIGNhcnRvZ3JhcGhpYyA9IG5ldyBDYXJ0b2dyYXBoaWMuZnJvbUNhcnRlc2lhbihcbiAgICB2ZXJ0ZXgsXG4gICAgRWxsaXBzb2lkLlVOSVRfU1BIRVJFXG4gICk7XG4gIC8vIEludGVycHJldCBhcyBnZW9kZXRpYyBjb29yZGluYXRlcyBvbiB0aGUgZWxsaXBzb2lkLlxuICByZXR1cm4gQ2FydG9ncmFwaGljLnRvQ2FydGVzaWFuKGNhcnRvZ3JhcGhpYywgZWxsaXBzb2lkLCBuZXcgQ2FydGVzaWFuMygpKTtcbn07XG5cbi8qKlxuICogQ3JlYXRlcyBhbiBTMkNlbGwgZnJvbSBpdHMgZmFjZSwgcG9zaXRpb24gYWxvbmcgdGhlIEhpbGJlcnQgY3VydmUgZm9yIGEgZ2l2ZW4gbGV2ZWwuXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IGZhY2UgVGhlIHJvb3QgZmFjZSBvZiBTMiB0aGlzIGNlbGwgaXMgb24uIE11c3QgYmUgaW4gdGhlIHJhbmdlIFswLTVdLlxuICogQHBhcmFtIHtCaWdJbnR9IHBvc2l0aW9uIFRoZSBwb3NpdGlvbiBhbG9uZyB0aGUgSGlsYmVydCBjdXJ2ZS4gTXVzdCBiZSBpbiB0aGUgcmFuZ2UgWzAtNCoqbGV2ZWwpLlxuICogQHBhcmFtIHtOdW1iZXJ9IGxldmVsIFRoZSBsZXZlbCBvZiB0aGUgUzIgY3VydmUuIE11c3QgYmUgaW4gdGhlIHJhbmdlIFswLTMwXS5cbiAqIEByZXR1cm5zIHtTMkNlbGx9IEEgbmV3IFMyQ2VsbCBmcm9tIHRoZSBnaXZlbiBwYXJhbWV0ZXJzLlxuICogQHByaXZhdGVcbiAqL1xuUzJDZWxsLmZyb21GYWNlUG9zaXRpb25MZXZlbCA9IGZ1bmN0aW9uIChmYWNlLCBwb3NpdGlvbiwgbGV2ZWwpIHtcbiAgLy8+PmluY2x1ZGVTdGFydCgnZGVidWcnLCBwcmFnbWFzLmRlYnVnKTtcbiAgQ2hlY2sudHlwZU9mLmJpZ2ludChcInBvc2l0aW9uXCIsIHBvc2l0aW9uKTtcbiAgaWYgKGZhY2UgPCAwIHx8IGZhY2UgPiA1KSB7XG4gICAgdGhyb3cgbmV3IERldmVsb3BlckVycm9yKFwiSW52YWxpZCBTMiBGYWNlIChtdXN0IGJlIHdpdGhpbiAwLTUpXCIpO1xuICB9XG5cbiAgaWYgKGxldmVsIDwgMCB8fCBsZXZlbCA+IFMyX01BWF9MRVZFTCkge1xuICAgIHRocm93IG5ldyBEZXZlbG9wZXJFcnJvcihcIkludmFsaWQgbGV2ZWwgKG11c3QgYmUgd2l0aGluIDAtMzApXCIpO1xuICB9XG4gIGlmIChwb3NpdGlvbiA8IDAgfHwgcG9zaXRpb24gPj0gTWF0aC5wb3coNCwgbGV2ZWwpKSB7XG4gICAgdGhyb3cgbmV3IERldmVsb3BlckVycm9yKFwiSW52YWxpZCBIaWxiZXJ0IHBvc2l0aW9uIGZvciBsZXZlbFwiKTtcbiAgfVxuICAvLz4+aW5jbHVkZUVuZCgnZGVidWcnKTtcblxuICB2YXIgZmFjZUJpdFN0cmluZyA9XG4gICAgKGZhY2UgPCA0ID8gXCIwXCIgOiBcIlwiKSArIChmYWNlIDwgMiA/IFwiMFwiIDogXCJcIikgKyBmYWNlLnRvU3RyaW5nKDIpO1xuICB2YXIgcG9zaXRpb25CaXRTdHJpbmcgPSBwb3NpdGlvbi50b1N0cmluZygyKTtcbiAgdmFyIHBvc2l0aW9uUHJlZml4UGFkZGluZyA9IEFycmF5KFxuICAgIDIgKiBsZXZlbCAtIHBvc2l0aW9uQml0U3RyaW5nLmxlbmd0aCArIDFcbiAgKS5qb2luKFwiMFwiKTtcbiAgdmFyIHBvc2l0aW9uU3VmZml4UGFkZGluZyA9IEFycmF5KFMyX1BPU0lUSU9OX0JJVFMgLSAyICogbGV2ZWwpLmpvaW4oXCIwXCIpO1xuXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZVxuICB2YXIgY2VsbElkID0gQmlnSW50KFxuICAgIFwiMGJcIiArXG4gICAgICBmYWNlQml0U3RyaW5nICtcbiAgICAgIHBvc2l0aW9uUHJlZml4UGFkZGluZyArXG4gICAgICBwb3NpdGlvbkJpdFN0cmluZyArXG4gICAgICBcIjFcIiArIC8vIEFkZGluZyB0aGUgc2VudGluZWwgYml0IHRoYXQgYWx3YXlzIGZvbGxvd3MgdGhlIHBvc2l0aW9uIGJpdHMuXG4gICAgICBwb3NpdGlvblN1ZmZpeFBhZGRpbmdcbiAgKTtcbiAgcmV0dXJuIG5ldyBTMkNlbGwoY2VsbElkKTtcbn07XG5cbi8qKlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gZ2V0UzJDZW50ZXIoY2VsbElkLCBsZXZlbCkge1xuICB2YXIgZmFjZVNpVGkgPSBjb252ZXJ0Q2VsbElkVG9GYWNlU2lUaShjZWxsSWQsIGxldmVsKTtcbiAgcmV0dXJuIGNvbnZlcnRGYWNlU2lUaXRvWFlaKGZhY2VTaVRpWzBdLCBmYWNlU2lUaVsxXSwgZmFjZVNpVGlbMl0pO1xufVxuLyoqXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBnZXRTMlZlcnRleChjZWxsSWQsIGxldmVsLCBpbmRleCkge1xuICB2YXIgZmFjZUlKID0gY29udmVydENlbGxJZFRvRmFjZUlKKGNlbGxJZCwgbGV2ZWwpO1xuICB2YXIgdXYgPSBjb252ZXJ0SUpMZXZlbHRvQm91bmRVVihbZmFjZUlKWzFdLCBmYWNlSUpbMl1dLCBsZXZlbCk7XG4gIC8vIEhhbmRsZXMgQ0NXIG9yZGVyaW5nIG9mIHRoZSB2ZXJ0aWNlcy5cbiAgdmFyIHkgPSAoaW5kZXggPj4gMSkgJiAxO1xuICByZXR1cm4gY29udmVydEZhY2VVVnRvWFlaKGZhY2VJSlswXSwgdXZbMF1beSBeIChpbmRleCAmIDEpXSwgdXZbMV1beV0pO1xufVxuXG4vLyBTMiBDb29yZGluYXRlIENvbnZlcnNpb25zXG5cbi8qKlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gY29udmVydENlbGxJZFRvRmFjZVNpVGkoY2VsbElkLCBsZXZlbCkge1xuICB2YXIgZmFjZUlKID0gY29udmVydENlbGxJZFRvRmFjZUlKKGNlbGxJZCk7XG4gIHZhciBmYWNlID0gZmFjZUlKWzBdO1xuICB2YXIgaSA9IGZhY2VJSlsxXTtcbiAgdmFyIGogPSBmYWNlSUpbMl07XG5cbiAgLy8gV2UncmUgcmVzb2x2aW5nIHRoZSBjZW50ZXIgd2hlbiB3ZSBkbyB0aGUgY29vcmRpbmF0ZSB0cmFuc2Zvcm0gaGVyZS4gRm9yIHRoZSBsZWFmIGNlbGxzLCB3ZSdyZSBhZGRpbmcgaGFsZiB0aGUgY2VsbCBzaXplXG4gIC8vIChyZW1lbWJlciB0aGF0IHRoaXMgc3BhY2UgaGFzIDMxIGxldmVscyAtIHdoaWNoIGFsbG93cyB1cyB0byBwaWNrIGNlbnRlciBhbmQgZWRnZXMgb2YgdGhlIGxlYWYgY2VsbHMpLiBGb3Igbm9uIGxlYWYgY2VsbHMsXG4gIC8vIHdlIGdldCBvbmUgb2YgZWl0aGVyIHR3byBjZWxscyBkaWFnb25hbCB0byB0aGUgY2VsbCBjZW50ZXIuIFRoZSBjb3JyZWN0aW9uIGlzIHVzZWQgdG8gbWFrZSBzdXJlIHdlIHBpY2sgdGhlIGxlYWYgY2VsbCBlZGdlc1xuICAvLyB0aGF0IHJlcHJlc2VudCB0aGUgcGFyZW50IGNlbGwgY2VudGVyLlxuICB2YXIgaXNMZWFmID0gbGV2ZWwgPT09IDMwO1xuICB2YXIgc2hvdWxkQ29ycmVjdCA9XG4gICAgIWlzTGVhZiAmJiAoQmlnSW50KGkpIF4gKGNlbGxJZCA+PiBCaWdJbnQoMikpKSAmIEJpZ0ludCgxKTsgLy8gZXNsaW50LWRpc2FibGUtbGluZVxuICB2YXIgY29ycmVjdGlvbiA9IGlzTGVhZiA/IDEgOiBzaG91bGRDb3JyZWN0ID8gMiA6IDA7XG4gIHZhciBzaSA9IChpIDw8IDEpICsgY29ycmVjdGlvbjtcbiAgdmFyIHRpID0gKGogPDwgMSkgKyBjb3JyZWN0aW9uO1xuICByZXR1cm4gW2ZhY2UsIHNpLCB0aV07XG59XG5cbi8qKlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gY29udmVydENlbGxJZFRvRmFjZUlKKGNlbGxJZCkge1xuICBpZiAoUzJfTE9PS1VQX1BPU0lUSU9OUy5sZW5ndGggPT09IDApIHtcbiAgICBnZW5lcmF0ZUxvb2t1cFRhYmxlKCk7XG4gIH1cblxuICB2YXIgZmFjZSA9IE51bWJlcihjZWxsSWQgPj4gQmlnSW50KFMyX1BPU0lUSU9OX0JJVFMpKTsgLy8gZXNsaW50LWRpc2FibGUtbGluZVxuICB2YXIgYml0cyA9IGZhY2UgJiBTMl9TV0FQX01BU0s7XG4gIHZhciBsb29rdXBNYXNrID0gKDEgPDwgUzJfTE9PS1VQX0JJVFMpIC0gMTtcblxuICB2YXIgaSA9IDA7XG4gIHZhciBqID0gMDtcblxuICBmb3IgKHZhciBrID0gNzsgayA+PSAwOyBrLS0pIHtcbiAgICB2YXIgbnVtYmVyT2ZCaXRzID1cbiAgICAgIGsgPT09IDcgPyBTMl9NQVhfTEVWRUwgLSA3ICogUzJfTE9PS1VQX0JJVFMgOiBTMl9MT09LVVBfQklUUztcbiAgICB2YXIgZXh0cmFjdE1hc2sgPSAoMSA8PCAoMiAqIG51bWJlck9mQml0cykpIC0gMTtcbiAgICBiaXRzICs9XG4gICAgICBOdW1iZXIoXG4gICAgICAgIChjZWxsSWQgPj4gQmlnSW50KGsgKiAyICogUzJfTE9PS1VQX0JJVFMgKyAxKSkgJiBCaWdJbnQoZXh0cmFjdE1hc2spIC8vIGVzbGludC1kaXNhYmxlLWxpbmVcbiAgICAgICkgPDwgMjtcblxuICAgIGJpdHMgPSBTMl9MT09LVVBfSUpbYml0c107XG5cbiAgICB2YXIgb2Zmc2V0ID0gayAqIFMyX0xPT0tVUF9CSVRTO1xuICAgIGkgKz0gKGJpdHMgPj4gKFMyX0xPT0tVUF9CSVRTICsgMikpIDw8IG9mZnNldDtcbiAgICBqICs9ICgoYml0cyA+PiAyKSAmIGxvb2t1cE1hc2spIDw8IG9mZnNldDtcblxuICAgIGJpdHMgJj0gUzJfU1dBUF9NQVNLIHwgUzJfSU5WRVJUX01BU0s7XG4gIH1cblxuICByZXR1cm4gW2ZhY2UsIGksIGpdO1xufVxuXG4vKipcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGNvbnZlcnRGYWNlU2lUaXRvWFlaKGZhY2UsIHNpLCB0aSkge1xuICB2YXIgcyA9IGNvbnZlcnRTaVRpdG9TVChzaSk7XG4gIHZhciB0ID0gY29udmVydFNpVGl0b1NUKHRpKTtcblxuICB2YXIgdSA9IGNvbnZlcnRTVHRvVVYocyk7XG4gIHZhciB2ID0gY29udmVydFNUdG9VVih0KTtcbiAgcmV0dXJuIGNvbnZlcnRGYWNlVVZ0b1hZWihmYWNlLCB1LCB2KTtcbn1cblxuLyoqXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBjb252ZXJ0RmFjZVVWdG9YWVooZmFjZSwgdSwgdikge1xuICBzd2l0Y2ggKGZhY2UpIHtcbiAgICBjYXNlIDA6XG4gICAgICByZXR1cm4gbmV3IENhcnRlc2lhbjMoMSwgdSwgdik7XG4gICAgY2FzZSAxOlxuICAgICAgcmV0dXJuIG5ldyBDYXJ0ZXNpYW4zKC11LCAxLCB2KTtcbiAgICBjYXNlIDI6XG4gICAgICByZXR1cm4gbmV3IENhcnRlc2lhbjMoLXUsIC12LCAxKTtcbiAgICBjYXNlIDM6XG4gICAgICByZXR1cm4gbmV3IENhcnRlc2lhbjMoLTEsIC12LCAtdSk7XG4gICAgY2FzZSA0OlxuICAgICAgcmV0dXJuIG5ldyBDYXJ0ZXNpYW4zKHYsIC0xLCAtdSk7XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBuZXcgQ2FydGVzaWFuMyh2LCB1LCAtMSk7XG4gIH1cbn1cblxuLyoqXG4gKiBTMiBwcm92aWRlcyAzIG1ldGhvZHMgZm9yIHRoZSBub24tbGluZWFyIHRyYW5zZm9ybTogbGluZWFyLCBxdWFkcmF0aWMgYW5kIHRhbmdlbnRpYWwuXG4gKiBUaGlzIGltcGxlbWVudGF0aW9uIHVzZXMgdGhlIHF1YWRyYXRpYyBtZXRob2QgYmVjYXVzZSBpdCBwcm92aWRlcyBhIGdvb2QgYmFsYW5jZSBvZlxuICogYWNjdXJhY3kgYW5kIHNwZWVkLlxuICpcbiAqIEZvciBhIG1vcmUgZGV0YWlsZWQgY29tcGFyaXNvbiBvZiB0aGVzZSB0cmFuc2Zvcm0gbWV0aG9kcywgc2VlXG4gKiB7QGxpbmsgaHR0cHM6Ly9naXRodWIuY29tL2dvb2dsZS9zMmdlb21ldHJ5L2Jsb2IvMGM0YzQ2MGJkZmU2OTZkYTMwMzY0MTc3MWY5ZGVmOTAwYjNlNDQwZi9zcmMvczIvczJtZXRyaWNzLmNjfVxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gY29udmVydFNUdG9VVihzKSB7XG4gIGlmIChzID49IDAuNSkgcmV0dXJuICgxIC8gMykgKiAoNCAqIHMgKiBzIC0gMSk7XG4gIHJldHVybiAoMSAvIDMpICogKDEgLSA0ICogKDEgLSBzKSAqICgxIC0gcykpO1xufVxuXG4vKipcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGNvbnZlcnRTaVRpdG9TVChzaSkge1xuICByZXR1cm4gKDEuMCAvIFMyX01BWF9TSVRJKSAqIHNpO1xufVxuXG4vKipcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGNvbnZlcnRJSkxldmVsdG9Cb3VuZFVWKGlqLCBsZXZlbCkge1xuICB2YXIgcmVzdWx0ID0gW1tdLCBbXV07XG4gIHZhciBjZWxsU2l6ZSA9IGdldFNpemVJSihsZXZlbCk7XG4gIGZvciAodmFyIGQgPSAwOyBkIDwgMjsgKytkKSB7XG4gICAgdmFyIGlqTG93ID0gaWpbZF0gJiAtY2VsbFNpemU7XG4gICAgdmFyIGlqSGlnaCA9IGlqTG93ICsgY2VsbFNpemU7XG4gICAgcmVzdWx0W2RdWzBdID0gY29udmVydFNUdG9VVihjb252ZXJ0SUp0b1NUTWluaW11bShpakxvdykpO1xuICAgIHJlc3VsdFtkXVsxXSA9IGNvbnZlcnRTVHRvVVYoY29udmVydElKdG9TVE1pbmltdW0oaWpIaWdoKSk7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBnZXRTaXplSUoobGV2ZWwpIHtcbiAgcmV0dXJuICgxIDw8IChTMl9NQVhfTEVWRUwgLSBsZXZlbCkpID4+PiAwO1xufVxuXG4vKipcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGNvbnZlcnRJSnRvU1RNaW5pbXVtKGkpIHtcbiAgcmV0dXJuICgxLjAgLyBTMl9MSU1JVF9JSikgKiBpO1xufVxuXG4vLyBVdGlsaXR5IEZ1bmN0aW9uc1xuXG4vKipcbiAqIFRoaXMgZnVuY3Rpb24gZ2VuZXJhdGVzIDQgdmFyaWF0aW9ucyBvZiBhIEhpbGJlcnQgY3VydmUgb2YgbGV2ZWwgNCwgYmFzZWQgb24gdGhlIFMyX1BPU0lUSU9OX1RPX0lKIHRhYmxlLCBmb3IgZmFzdCBsb29rdXBzIG9mIChpLCBqKVxuICogdG8gcG9zaXRpb24gYWxvbmcgSGlsYmVydCBjdXJ2ZS4gVGhlIHJlZmVyZW5jZSBDKysgaW1wbGVtZW50YXRpb24gdXNlcyBhbiBpdGVyYXRpdmUgYXBwcm9hY2gsIGhvd2V2ZXIsIHRoaXMgZnVuY3Rpb24gaXMgaW1wbGVtZW50ZWRcbiAqIHJlY3Vyc2l2ZWx5LlxuICpcbiAqIFNlZSB7QGxpbmsgaHR0cHM6Ly9naXRodWIuY29tL2dvb2dsZS9zMmdlb21ldHJ5L2Jsb2IvYzU5ZDBjYTAxYWUzOTc2ZGI3ZjhhYmRjODNmY2M4NzFhM2E5NTE4Ni9zcmMvczIvczJjZWxsX2lkLmNjI0w3NS1MMTA5fVxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gZ2VuZXJhdGVMb29rdXBDZWxsKFxuICBsZXZlbCxcbiAgaSxcbiAgaixcbiAgb3JpZ2luYWxPcmllbnRhdGlvbixcbiAgcG9zaXRpb24sXG4gIG9yaWVudGF0aW9uXG4pIHtcbiAgaWYgKGxldmVsID09PSBTMl9MT09LVVBfQklUUykge1xuICAgIHZhciBpaiA9IChpIDw8IFMyX0xPT0tVUF9CSVRTKSArIGo7XG4gICAgUzJfTE9PS1VQX1BPU0lUSU9OU1soaWogPDwgMikgKyBvcmlnaW5hbE9yaWVudGF0aW9uXSA9XG4gICAgICAocG9zaXRpb24gPDwgMikgKyBvcmllbnRhdGlvbjtcbiAgICBTMl9MT09LVVBfSUpbKHBvc2l0aW9uIDw8IDIpICsgb3JpZ2luYWxPcmllbnRhdGlvbl0gPVxuICAgICAgKGlqIDw8IDIpICsgb3JpZW50YXRpb247XG4gIH0gZWxzZSB7XG4gICAgbGV2ZWwrKztcbiAgICBpIDw8PSAxO1xuICAgIGogPDw9IDE7XG4gICAgcG9zaXRpb24gPDw9IDI7XG4gICAgdmFyIHIgPSBTMl9QT1NJVElPTl9UT19JSltvcmllbnRhdGlvbl07XG4gICAgZ2VuZXJhdGVMb29rdXBDZWxsKFxuICAgICAgbGV2ZWwsXG4gICAgICBpICsgKHJbMF0gPj4gMSksXG4gICAgICBqICsgKHJbMF0gJiAxKSxcbiAgICAgIG9yaWdpbmFsT3JpZW50YXRpb24sXG4gICAgICBwb3NpdGlvbixcbiAgICAgIG9yaWVudGF0aW9uIF4gUzJfUE9TSVRJT05fVE9fT1JJRU5UQVRJT05fTUFTS1swXVxuICAgICk7XG4gICAgZ2VuZXJhdGVMb29rdXBDZWxsKFxuICAgICAgbGV2ZWwsXG4gICAgICBpICsgKHJbMV0gPj4gMSksXG4gICAgICBqICsgKHJbMV0gJiAxKSxcbiAgICAgIG9yaWdpbmFsT3JpZW50YXRpb24sXG4gICAgICBwb3NpdGlvbiArIDEsXG4gICAgICBvcmllbnRhdGlvbiBeIFMyX1BPU0lUSU9OX1RPX09SSUVOVEFUSU9OX01BU0tbMV1cbiAgICApO1xuICAgIGdlbmVyYXRlTG9va3VwQ2VsbChcbiAgICAgIGxldmVsLFxuICAgICAgaSArIChyWzJdID4+IDEpLFxuICAgICAgaiArIChyWzJdICYgMSksXG4gICAgICBvcmlnaW5hbE9yaWVudGF0aW9uLFxuICAgICAgcG9zaXRpb24gKyAyLFxuICAgICAgb3JpZW50YXRpb24gXiBTMl9QT1NJVElPTl9UT19PUklFTlRBVElPTl9NQVNLWzJdXG4gICAgKTtcbiAgICBnZW5lcmF0ZUxvb2t1cENlbGwoXG4gICAgICBsZXZlbCxcbiAgICAgIGkgKyAoclszXSA+PiAxKSxcbiAgICAgIGogKyAoclszXSAmIDEpLFxuICAgICAgb3JpZ2luYWxPcmllbnRhdGlvbixcbiAgICAgIHBvc2l0aW9uICsgMyxcbiAgICAgIG9yaWVudGF0aW9uIF4gUzJfUE9TSVRJT05fVE9fT1JJRU5UQVRJT05fTUFTS1szXVxuICAgICk7XG4gIH1cbn1cblxuLyoqXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBnZW5lcmF0ZUxvb2t1cFRhYmxlKCkge1xuICBnZW5lcmF0ZUxvb2t1cENlbGwoMCwgMCwgMCwgMCwgMCwgMCk7XG4gIGdlbmVyYXRlTG9va3VwQ2VsbCgwLCAwLCAwLCBTMl9TV0FQX01BU0ssIDAsIFMyX1NXQVBfTUFTSyk7XG4gIGdlbmVyYXRlTG9va3VwQ2VsbCgwLCAwLCAwLCBTMl9JTlZFUlRfTUFTSywgMCwgUzJfSU5WRVJUX01BU0spO1xuICBnZW5lcmF0ZUxvb2t1cENlbGwoXG4gICAgMCxcbiAgICAwLFxuICAgIDAsXG4gICAgUzJfU1dBUF9NQVNLIHwgUzJfSU5WRVJUX01BU0ssXG4gICAgMCxcbiAgICBTMl9TV0FQX01BU0sgfCBTMl9JTlZFUlRfTUFTS1xuICApO1xufVxuXG4vKipcbiAqIFJldHVybiB0aGUgbG93ZXN0LW51bWJlcmVkIGJpdCB0aGF0IGlzIG9uIGZvciB0aGlzIGNlbGwgaWRcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGxzYihjZWxsSWQpIHtcbiAgcmV0dXJuIGNlbGxJZCAmICh+Y2VsbElkICsgQmlnSW50KDEpKTsgLy8gZXNsaW50LWRpc2FibGUtbGluZVxufVxuXG4vKipcbiAqIFJldHVybiB0aGUgbG93ZXN0LW51bWJlcmVkIGJpdCB0aGF0IGlzIG9uIGZvciBjZWxscyBhdCB0aGUgZ2l2ZW4gbGV2ZWwuXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBsc2JGb3JMZXZlbChsZXZlbCkge1xuICByZXR1cm4gQmlnSW50KDEpIDw8IEJpZ0ludCgyICogKFMyX01BWF9MRVZFTCAtIGxldmVsKSk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmVcbn1cblxuLy8gTG9va3VwIHRhYmxlIGZvciBnZXR0aW5nIHRyYWlsaW5nIHplcm8gYml0cy5cbi8vIGh0dHBzOi8vZ3JhcGhpY3Muc3RhbmZvcmQuZWR1L35zZWFuZGVyL2JpdGhhY2tzLmh0bWxcbnZhciBNb2Q2N0JpdFBvc2l0aW9uID0gW1xuICA2NCxcbiAgMCxcbiAgMSxcbiAgMzksXG4gIDIsXG4gIDE1LFxuICA0MCxcbiAgMjMsXG4gIDMsXG4gIDEyLFxuICAxNixcbiAgNTksXG4gIDQxLFxuICAxOSxcbiAgMjQsXG4gIDU0LFxuICA0LFxuICA2NCxcbiAgMTMsXG4gIDEwLFxuICAxNyxcbiAgNjIsXG4gIDYwLFxuICAyOCxcbiAgNDIsXG4gIDMwLFxuICAyMCxcbiAgNTEsXG4gIDI1LFxuICA0NCxcbiAgNTUsXG4gIDQ3LFxuICA1LFxuICAzMixcbiAgNjUsXG4gIDM4LFxuICAxNCxcbiAgMjIsXG4gIDExLFxuICA1OCxcbiAgMTgsXG4gIDUzLFxuICA2MyxcbiAgOSxcbiAgNjEsXG4gIDI3LFxuICAyOSxcbiAgNTAsXG4gIDQzLFxuICA0NixcbiAgMzEsXG4gIDM3LFxuICAyMSxcbiAgNTcsXG4gIDUyLFxuICA4LFxuICAyNixcbiAgNDksXG4gIDQ1LFxuICAzNixcbiAgNTYsXG4gIDcsXG4gIDQ4LFxuICAzNSxcbiAgNixcbiAgMzQsXG4gIDMzLFxuICAwLFxuXTtcblxuLyoqXG4gKiBSZXR1cm4gdGhlIG51bWJlciBvZiB0cmFpbGluZyB6ZXJvcyBpbiBudW1iZXIuXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBjb3VudFRyYWlsaW5nWmVyb0JpdHMoeCkge1xuICByZXR1cm4gTW9kNjdCaXRQb3NpdGlvblsoLXggJiB4KSAlIEJpZ0ludCg2NyldOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG59XG5cbmV4cG9ydCBkZWZhdWx0IFMyQ2VsbDtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///90791\n')},20406:function(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__){eval('/* harmony import */ var _AssociativeArray_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(8629);\n/* harmony import */ var _Cartesian2_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(60838);\n/* harmony import */ var _defaultValue_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(62200);\n/* harmony import */ var _defined_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(82982);\n/* harmony import */ var _destroyObject_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(86511);\n/* harmony import */ var _DeveloperError_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(12572);\n/* harmony import */ var _FeatureDetection_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(96037);\n/* harmony import */ var _getTimestamp_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(59081);\n/* harmony import */ var _KeyboardEventModifier_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(89232);\n/* harmony import */ var _ScreenSpaceEventType_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(35452);\n\n\n\n\n\n\n\n\n\n\n\nfunction getPosition(screenSpaceEventHandler, event, result) {\n  var element = screenSpaceEventHandler._element;\n  if (element === document) {\n    result.x = event.clientX;\n    result.y = event.clientY;\n    return result;\n  }\n\n  var rect = element.getBoundingClientRect();\n  result.x = event.clientX - rect.left;\n  result.y = event.clientY - rect.top;\n  return result;\n}\n\nfunction getInputEventKey(type, modifier) {\n  var key = type;\n  if ((0,_defined_js__WEBPACK_IMPORTED_MODULE_9__/* ["default"] */ .Z)(modifier)) {\n    key += "+" + modifier;\n  }\n  return key;\n}\n\nfunction getModifier(event) {\n  if (event.shiftKey) {\n    return _KeyboardEventModifier_js__WEBPACK_IMPORTED_MODULE_7__/* ["default"].SHIFT */ .Z.SHIFT;\n  } else if (event.ctrlKey) {\n    return _KeyboardEventModifier_js__WEBPACK_IMPORTED_MODULE_7__/* ["default"].CTRL */ .Z.CTRL;\n  } else if (event.altKey) {\n    return _KeyboardEventModifier_js__WEBPACK_IMPORTED_MODULE_7__/* ["default"].ALT */ .Z.ALT;\n  }\n\n  return undefined;\n}\n\nvar MouseButton = {\n  LEFT: 0,\n  MIDDLE: 1,\n  RIGHT: 2,\n};\n\nfunction registerListener(screenSpaceEventHandler, domType, element, callback) {\n  function listener(e) {\n    callback(screenSpaceEventHandler, e);\n  }\n\n  if (_FeatureDetection_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"].isInternetExplorer */ .Z.isInternetExplorer()) {\n    element.addEventListener(domType, listener, false);\n  } else {\n    element.addEventListener(domType, listener, {\n      capture: false,\n      passive: false,\n    });\n  }\n\n  screenSpaceEventHandler._removalFunctions.push(function () {\n    element.removeEventListener(domType, listener, false);\n  });\n}\n\nfunction registerListeners(screenSpaceEventHandler) {\n  var element = screenSpaceEventHandler._element;\n\n  // some listeners may be registered on the document, so we still get events even after\n  // leaving the bounds of element.\n  // this is affected by the existence of an undocumented disableRootEvents property on element.\n  var alternateElement = !(0,_defined_js__WEBPACK_IMPORTED_MODULE_9__/* ["default"] */ .Z)(element.disableRootEvents)\n    ? document\n    : element;\n\n  if (_FeatureDetection_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"].supportsPointerEvents */ .Z.supportsPointerEvents()) {\n    registerListener(\n      screenSpaceEventHandler,\n      "pointerdown",\n      element,\n      handlePointerDown\n    );\n    registerListener(\n      screenSpaceEventHandler,\n      "pointerup",\n      element,\n      handlePointerUp\n    );\n    registerListener(\n      screenSpaceEventHandler,\n      "pointermove",\n      element,\n      handlePointerMove\n    );\n    registerListener(\n      screenSpaceEventHandler,\n      "pointercancel",\n      element,\n      handlePointerUp\n    );\n  } else {\n    registerListener(\n      screenSpaceEventHandler,\n      "mousedown",\n      element,\n      handleMouseDown\n    );\n    registerListener(\n      screenSpaceEventHandler,\n      "mouseup",\n      alternateElement,\n      handleMouseUp\n    );\n    registerListener(\n      screenSpaceEventHandler,\n      "mousemove",\n      alternateElement,\n      handleMouseMove\n    );\n    registerListener(\n      screenSpaceEventHandler,\n      "touchstart",\n      element,\n      handleTouchStart\n    );\n    registerListener(\n      screenSpaceEventHandler,\n      "touchend",\n      alternateElement,\n      handleTouchEnd\n    );\n    registerListener(\n      screenSpaceEventHandler,\n      "touchmove",\n      alternateElement,\n      handleTouchMove\n    );\n    registerListener(\n      screenSpaceEventHandler,\n      "touchcancel",\n      alternateElement,\n      handleTouchEnd\n    );\n  }\n\n  registerListener(\n    screenSpaceEventHandler,\n    "dblclick",\n    element,\n    handleDblClick\n  );\n\n  // detect available wheel event\n  var wheelEvent;\n  if ("onwheel" in element) {\n    // spec event type\n    wheelEvent = "wheel";\n  } else if (document.onmousewheel !== undefined) {\n    // legacy event type\n    wheelEvent = "mousewheel";\n  } else {\n    // older Firefox\n    wheelEvent = "DOMMouseScroll";\n  }\n\n  registerListener(screenSpaceEventHandler, wheelEvent, element, handleWheel);\n}\n\nfunction unregisterListeners(screenSpaceEventHandler) {\n  var removalFunctions = screenSpaceEventHandler._removalFunctions;\n  for (var i = 0; i < removalFunctions.length; ++i) {\n    removalFunctions[i]();\n  }\n}\n\nvar mouseDownEvent = {\n  position: new _Cartesian2_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .Z(),\n};\n\nfunction gotTouchEvent(screenSpaceEventHandler) {\n  screenSpaceEventHandler._lastSeenTouchEvent = (0,_getTimestamp_js__WEBPACK_IMPORTED_MODULE_6__/* ["default"] */ .Z)();\n}\n\nfunction canProcessMouseEvent(screenSpaceEventHandler) {\n  return (\n    (0,_getTimestamp_js__WEBPACK_IMPORTED_MODULE_6__/* ["default"] */ .Z)() - screenSpaceEventHandler._lastSeenTouchEvent >\n    ScreenSpaceEventHandler.mouseEmulationIgnoreMilliseconds\n  );\n}\n\nfunction checkPixelTolerance(startPosition, endPosition, pixelTolerance) {\n  var xDiff = startPosition.x - endPosition.x;\n  var yDiff = startPosition.y - endPosition.y;\n  var totalPixels = Math.sqrt(xDiff * xDiff + yDiff * yDiff);\n\n  return totalPixels < pixelTolerance;\n}\n\nfunction handleMouseDown(screenSpaceEventHandler, event) {\n  if (!canProcessMouseEvent(screenSpaceEventHandler)) {\n    return;\n  }\n\n  var button = event.button;\n  screenSpaceEventHandler._buttonDown[button] = true;\n\n  var screenSpaceEventType;\n  if (button === MouseButton.LEFT) {\n    screenSpaceEventType = _ScreenSpaceEventType_js__WEBPACK_IMPORTED_MODULE_8__/* ["default"].LEFT_DOWN */ .Z.LEFT_DOWN;\n  } else if (button === MouseButton.MIDDLE) {\n    screenSpaceEventType = _ScreenSpaceEventType_js__WEBPACK_IMPORTED_MODULE_8__/* ["default"].MIDDLE_DOWN */ .Z.MIDDLE_DOWN;\n  } else if (button === MouseButton.RIGHT) {\n    screenSpaceEventType = _ScreenSpaceEventType_js__WEBPACK_IMPORTED_MODULE_8__/* ["default"].RIGHT_DOWN */ .Z.RIGHT_DOWN;\n  } else {\n    return;\n  }\n\n  var position = getPosition(\n    screenSpaceEventHandler,\n    event,\n    screenSpaceEventHandler._primaryPosition\n  );\n  _Cartesian2_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"].clone */ .Z.clone(position, screenSpaceEventHandler._primaryStartPosition);\n  _Cartesian2_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"].clone */ .Z.clone(position, screenSpaceEventHandler._primaryPreviousPosition);\n\n  var modifier = getModifier(event);\n\n  var action = screenSpaceEventHandler.getInputAction(\n    screenSpaceEventType,\n    modifier\n  );\n\n  if ((0,_defined_js__WEBPACK_IMPORTED_MODULE_9__/* ["default"] */ .Z)(action)) {\n    _Cartesian2_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"].clone */ .Z.clone(position, mouseDownEvent.position);\n\n    action(mouseDownEvent);\n\n    event.preventDefault();\n  }\n}\n\nvar mouseUpEvent = {\n  position: new _Cartesian2_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .Z(),\n};\nvar mouseClickEvent = {\n  position: new _Cartesian2_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .Z(),\n};\n\nfunction cancelMouseEvent(\n  screenSpaceEventHandler,\n  screenSpaceEventType,\n  clickScreenSpaceEventType,\n  event\n) {\n  var modifier = getModifier(event);\n\n  var action = screenSpaceEventHandler.getInputAction(\n    screenSpaceEventType,\n    modifier\n  );\n  var clickAction = screenSpaceEventHandler.getInputAction(\n    clickScreenSpaceEventType,\n    modifier\n  );\n\n  if ((0,_defined_js__WEBPACK_IMPORTED_MODULE_9__/* ["default"] */ .Z)(action) || (0,_defined_js__WEBPACK_IMPORTED_MODULE_9__/* ["default"] */ .Z)(clickAction)) {\n    var position = getPosition(\n      screenSpaceEventHandler,\n      event,\n      screenSpaceEventHandler._primaryPosition\n    );\n\n    if ((0,_defined_js__WEBPACK_IMPORTED_MODULE_9__/* ["default"] */ .Z)(action)) {\n      _Cartesian2_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"].clone */ .Z.clone(position, mouseUpEvent.position);\n\n      action(mouseUpEvent);\n    }\n\n    if ((0,_defined_js__WEBPACK_IMPORTED_MODULE_9__/* ["default"] */ .Z)(clickAction)) {\n      var startPosition = screenSpaceEventHandler._primaryStartPosition;\n      if (\n        checkPixelTolerance(\n          startPosition,\n          position,\n          screenSpaceEventHandler._clickPixelTolerance\n        )\n      ) {\n        _Cartesian2_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"].clone */ .Z.clone(position, mouseClickEvent.position);\n\n        clickAction(mouseClickEvent);\n      }\n    }\n  }\n}\n\nfunction handleMouseUp(screenSpaceEventHandler, event) {\n  if (!canProcessMouseEvent(screenSpaceEventHandler)) {\n    return;\n  }\n\n  var button = event.button;\n\n  if (\n    button !== MouseButton.LEFT &&\n    button !== MouseButton.MIDDLE &&\n    button !== MouseButton.RIGHT\n  ) {\n    return;\n  }\n\n  if (screenSpaceEventHandler._buttonDown[MouseButton.LEFT]) {\n    cancelMouseEvent(\n      screenSpaceEventHandler,\n      _ScreenSpaceEventType_js__WEBPACK_IMPORTED_MODULE_8__/* ["default"].LEFT_UP */ .Z.LEFT_UP,\n      _ScreenSpaceEventType_js__WEBPACK_IMPORTED_MODULE_8__/* ["default"].LEFT_CLICK */ .Z.LEFT_CLICK,\n      event\n    );\n    screenSpaceEventHandler._buttonDown[MouseButton.LEFT] = false;\n  }\n  if (screenSpaceEventHandler._buttonDown[MouseButton.MIDDLE]) {\n    cancelMouseEvent(\n      screenSpaceEventHandler,\n      _ScreenSpaceEventType_js__WEBPACK_IMPORTED_MODULE_8__/* ["default"].MIDDLE_UP */ .Z.MIDDLE_UP,\n      _ScreenSpaceEventType_js__WEBPACK_IMPORTED_MODULE_8__/* ["default"].MIDDLE_CLICK */ .Z.MIDDLE_CLICK,\n      event\n    );\n    screenSpaceEventHandler._buttonDown[MouseButton.MIDDLE] = false;\n  }\n  if (screenSpaceEventHandler._buttonDown[MouseButton.RIGHT]) {\n    cancelMouseEvent(\n      screenSpaceEventHandler,\n      _ScreenSpaceEventType_js__WEBPACK_IMPORTED_MODULE_8__/* ["default"].RIGHT_UP */ .Z.RIGHT_UP,\n      _ScreenSpaceEventType_js__WEBPACK_IMPORTED_MODULE_8__/* ["default"].RIGHT_CLICK */ .Z.RIGHT_CLICK,\n      event\n    );\n    screenSpaceEventHandler._buttonDown[MouseButton.RIGHT] = false;\n  }\n}\n\nvar mouseMoveEvent = {\n  startPosition: new _Cartesian2_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .Z(),\n  endPosition: new _Cartesian2_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .Z(),\n};\n\nfunction handleMouseMove(screenSpaceEventHandler, event) {\n  if (!canProcessMouseEvent(screenSpaceEventHandler)) {\n    return;\n  }\n\n  var modifier = getModifier(event);\n\n  var position = getPosition(\n    screenSpaceEventHandler,\n    event,\n    screenSpaceEventHandler._primaryPosition\n  );\n  var previousPosition = screenSpaceEventHandler._primaryPreviousPosition;\n\n  var action = screenSpaceEventHandler.getInputAction(\n    _ScreenSpaceEventType_js__WEBPACK_IMPORTED_MODULE_8__/* ["default"].MOUSE_MOVE */ .Z.MOUSE_MOVE,\n    modifier\n  );\n\n  if ((0,_defined_js__WEBPACK_IMPORTED_MODULE_9__/* ["default"] */ .Z)(action)) {\n    _Cartesian2_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"].clone */ .Z.clone(previousPosition, mouseMoveEvent.startPosition);\n    _Cartesian2_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"].clone */ .Z.clone(position, mouseMoveEvent.endPosition);\n\n    action(mouseMoveEvent);\n  }\n\n  _Cartesian2_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"].clone */ .Z.clone(position, previousPosition);\n\n  if (\n    screenSpaceEventHandler._buttonDown[MouseButton.LEFT] ||\n    screenSpaceEventHandler._buttonDown[MouseButton.MIDDLE] ||\n    screenSpaceEventHandler._buttonDown[MouseButton.RIGHT]\n  ) {\n    event.preventDefault();\n  }\n}\n\nvar mouseDblClickEvent = {\n  position: new _Cartesian2_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .Z(),\n};\n\nfunction handleDblClick(screenSpaceEventHandler, event) {\n  var button = event.button;\n\n  var screenSpaceEventType;\n  if (button === MouseButton.LEFT) {\n    screenSpaceEventType = _ScreenSpaceEventType_js__WEBPACK_IMPORTED_MODULE_8__/* ["default"].LEFT_DOUBLE_CLICK */ .Z.LEFT_DOUBLE_CLICK;\n  } else {\n    return;\n  }\n\n  var modifier = getModifier(event);\n\n  var action = screenSpaceEventHandler.getInputAction(\n    screenSpaceEventType,\n    modifier\n  );\n\n  if ((0,_defined_js__WEBPACK_IMPORTED_MODULE_9__/* ["default"] */ .Z)(action)) {\n    getPosition(screenSpaceEventHandler, event, mouseDblClickEvent.position);\n\n    action(mouseDblClickEvent);\n  }\n}\n\nfunction handleWheel(screenSpaceEventHandler, event) {\n  // currently this event exposes the delta value in terms of\n  // the obsolete mousewheel event type.  so, for now, we adapt the other\n  // values to that scheme.\n  var delta;\n\n  // standard wheel event uses deltaY.  sign is opposite wheelDelta.\n  // deltaMode indicates what unit it is in.\n  if ((0,_defined_js__WEBPACK_IMPORTED_MODULE_9__/* ["default"] */ .Z)(event.deltaY)) {\n    var deltaMode = event.deltaMode;\n    if (deltaMode === event.DOM_DELTA_PIXEL) {\n      delta = -event.deltaY;\n    } else if (deltaMode === event.DOM_DELTA_LINE) {\n      delta = -event.deltaY * 40;\n    } else {\n      // DOM_DELTA_PAGE\n      delta = -event.deltaY * 120;\n    }\n  } else if (event.detail > 0) {\n    // old Firefox versions use event.detail to count the number of clicks. The sign\n    // of the integer is the direction the wheel is scrolled.\n    delta = event.detail * -120;\n  } else {\n    delta = event.wheelDelta;\n  }\n\n  if (!(0,_defined_js__WEBPACK_IMPORTED_MODULE_9__/* ["default"] */ .Z)(delta)) {\n    return;\n  }\n\n  var modifier = getModifier(event);\n  var action = screenSpaceEventHandler.getInputAction(\n    _ScreenSpaceEventType_js__WEBPACK_IMPORTED_MODULE_8__/* ["default"].WHEEL */ .Z.WHEEL,\n    modifier\n  );\n\n  if ((0,_defined_js__WEBPACK_IMPORTED_MODULE_9__/* ["default"] */ .Z)(action)) {\n    action(delta);\n\n    event.preventDefault();\n  }\n}\n\nfunction handleTouchStart(screenSpaceEventHandler, event) {\n  gotTouchEvent(screenSpaceEventHandler);\n\n  var changedTouches = event.changedTouches;\n\n  var i;\n  var length = changedTouches.length;\n  var touch;\n  var identifier;\n  var positions = screenSpaceEventHandler._positions;\n\n  for (i = 0; i < length; ++i) {\n    touch = changedTouches[i];\n    identifier = touch.identifier;\n    positions.set(\n      identifier,\n      getPosition(screenSpaceEventHandler, touch, new _Cartesian2_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .Z())\n    );\n  }\n\n  fireTouchEvents(screenSpaceEventHandler, event);\n\n  var previousPositions = screenSpaceEventHandler._previousPositions;\n\n  for (i = 0; i < length; ++i) {\n    touch = changedTouches[i];\n    identifier = touch.identifier;\n    previousPositions.set(\n      identifier,\n      _Cartesian2_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"].clone */ .Z.clone(positions.get(identifier))\n    );\n  }\n}\n\nfunction handleTouchEnd(screenSpaceEventHandler, event) {\n  gotTouchEvent(screenSpaceEventHandler);\n\n  var changedTouches = event.changedTouches;\n\n  var i;\n  var length = changedTouches.length;\n  var touch;\n  var identifier;\n  var positions = screenSpaceEventHandler._positions;\n\n  for (i = 0; i < length; ++i) {\n    touch = changedTouches[i];\n    identifier = touch.identifier;\n    positions.remove(identifier);\n  }\n\n  fireTouchEvents(screenSpaceEventHandler, event);\n\n  var previousPositions = screenSpaceEventHandler._previousPositions;\n\n  for (i = 0; i < length; ++i) {\n    touch = changedTouches[i];\n    identifier = touch.identifier;\n    previousPositions.remove(identifier);\n  }\n}\n\nvar touchStartEvent = {\n  position: new _Cartesian2_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .Z(),\n};\nvar touch2StartEvent = {\n  position1: new _Cartesian2_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .Z(),\n  position2: new _Cartesian2_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .Z(),\n};\nvar touchEndEvent = {\n  position: new _Cartesian2_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .Z(),\n};\nvar touchClickEvent = {\n  position: new _Cartesian2_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .Z(),\n};\nvar touchHoldEvent = {\n  position: new _Cartesian2_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .Z(),\n};\n\nfunction fireTouchEvents(screenSpaceEventHandler, event) {\n  var modifier = getModifier(event);\n  var positions = screenSpaceEventHandler._positions;\n  var numberOfTouches = positions.length;\n  var action;\n  var clickAction;\n  var pinching = screenSpaceEventHandler._isPinching;\n\n  if (\n    numberOfTouches !== 1 &&\n    screenSpaceEventHandler._buttonDown[MouseButton.LEFT]\n  ) {\n    // transitioning from single touch, trigger UP and might trigger CLICK\n    screenSpaceEventHandler._buttonDown[MouseButton.LEFT] = false;\n\n    if ((0,_defined_js__WEBPACK_IMPORTED_MODULE_9__/* ["default"] */ .Z)(screenSpaceEventHandler._touchHoldTimer)) {\n      clearTimeout(screenSpaceEventHandler._touchHoldTimer);\n      screenSpaceEventHandler._touchHoldTimer = undefined;\n    }\n\n    action = screenSpaceEventHandler.getInputAction(\n      _ScreenSpaceEventType_js__WEBPACK_IMPORTED_MODULE_8__/* ["default"].LEFT_UP */ .Z.LEFT_UP,\n      modifier\n    );\n\n    if ((0,_defined_js__WEBPACK_IMPORTED_MODULE_9__/* ["default"] */ .Z)(action)) {\n      _Cartesian2_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"].clone */ .Z.clone(\n        screenSpaceEventHandler._primaryPosition,\n        touchEndEvent.position\n      );\n\n      action(touchEndEvent);\n    }\n\n    if (numberOfTouches === 0 && !screenSpaceEventHandler._isTouchHolding) {\n      // releasing single touch, check for CLICK\n      clickAction = screenSpaceEventHandler.getInputAction(\n        _ScreenSpaceEventType_js__WEBPACK_IMPORTED_MODULE_8__/* ["default"].LEFT_CLICK */ .Z.LEFT_CLICK,\n        modifier\n      );\n\n      if ((0,_defined_js__WEBPACK_IMPORTED_MODULE_9__/* ["default"] */ .Z)(clickAction)) {\n        var startPosition = screenSpaceEventHandler._primaryStartPosition;\n        var endPosition = screenSpaceEventHandler._previousPositions.values[0];\n        if (\n          checkPixelTolerance(\n            startPosition,\n            endPosition,\n            screenSpaceEventHandler._clickPixelTolerance\n          )\n        ) {\n          _Cartesian2_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"].clone */ .Z.clone(\n            screenSpaceEventHandler._primaryPosition,\n            touchClickEvent.position\n          );\n\n          clickAction(touchClickEvent);\n        }\n      }\n    }\n\n    screenSpaceEventHandler._isTouchHolding = false;\n\n    // Otherwise don\'t trigger CLICK, because we are adding more touches.\n  }\n\n  if (numberOfTouches === 0 && pinching) {\n    // transitioning from pinch, trigger PINCH_END\n    screenSpaceEventHandler._isPinching = false;\n\n    action = screenSpaceEventHandler.getInputAction(\n      _ScreenSpaceEventType_js__WEBPACK_IMPORTED_MODULE_8__/* ["default"].PINCH_END */ .Z.PINCH_END,\n      modifier\n    );\n\n    if ((0,_defined_js__WEBPACK_IMPORTED_MODULE_9__/* ["default"] */ .Z)(action)) {\n      action();\n    }\n  }\n\n  if (numberOfTouches === 1 && !pinching) {\n    // transitioning to single touch, trigger DOWN\n    var position = positions.values[0];\n    _Cartesian2_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"].clone */ .Z.clone(position, screenSpaceEventHandler._primaryPosition);\n    _Cartesian2_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"].clone */ .Z.clone(position, screenSpaceEventHandler._primaryStartPosition);\n    _Cartesian2_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"].clone */ .Z.clone(\n      position,\n      screenSpaceEventHandler._primaryPreviousPosition\n    );\n\n    screenSpaceEventHandler._buttonDown[MouseButton.LEFT] = true;\n\n    action = screenSpaceEventHandler.getInputAction(\n      _ScreenSpaceEventType_js__WEBPACK_IMPORTED_MODULE_8__/* ["default"].LEFT_DOWN */ .Z.LEFT_DOWN,\n      modifier\n    );\n\n    if ((0,_defined_js__WEBPACK_IMPORTED_MODULE_9__/* ["default"] */ .Z)(action)) {\n      _Cartesian2_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"].clone */ .Z.clone(position, touchStartEvent.position);\n\n      action(touchStartEvent);\n    }\n\n    screenSpaceEventHandler._touchHoldTimer = setTimeout(function () {\n      if (!screenSpaceEventHandler.isDestroyed()) {\n        screenSpaceEventHandler._touchHoldTimer = undefined;\n        screenSpaceEventHandler._isTouchHolding = true;\n\n        clickAction = screenSpaceEventHandler.getInputAction(\n          _ScreenSpaceEventType_js__WEBPACK_IMPORTED_MODULE_8__/* ["default"].RIGHT_CLICK */ .Z.RIGHT_CLICK,\n          modifier\n        );\n\n        if ((0,_defined_js__WEBPACK_IMPORTED_MODULE_9__/* ["default"] */ .Z)(clickAction)) {\n          var startPosition = screenSpaceEventHandler._primaryStartPosition;\n          var endPosition =\n            screenSpaceEventHandler._previousPositions.values[0];\n          if (\n            checkPixelTolerance(\n              startPosition,\n              endPosition,\n              screenSpaceEventHandler._holdPixelTolerance\n            )\n          ) {\n            _Cartesian2_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"].clone */ .Z.clone(\n              screenSpaceEventHandler._primaryPosition,\n              touchHoldEvent.position\n            );\n\n            clickAction(touchHoldEvent);\n          }\n        }\n      }\n    }, ScreenSpaceEventHandler.touchHoldDelayMilliseconds);\n\n    event.preventDefault();\n  }\n\n  if (numberOfTouches === 2 && !pinching) {\n    // transitioning to pinch, trigger PINCH_START\n    screenSpaceEventHandler._isPinching = true;\n\n    action = screenSpaceEventHandler.getInputAction(\n      _ScreenSpaceEventType_js__WEBPACK_IMPORTED_MODULE_8__/* ["default"].PINCH_START */ .Z.PINCH_START,\n      modifier\n    );\n\n    if ((0,_defined_js__WEBPACK_IMPORTED_MODULE_9__/* ["default"] */ .Z)(action)) {\n      _Cartesian2_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"].clone */ .Z.clone(positions.values[0], touch2StartEvent.position1);\n      _Cartesian2_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"].clone */ .Z.clone(positions.values[1], touch2StartEvent.position2);\n\n      action(touch2StartEvent);\n\n      // Touch-enabled devices, in particular iOS can have many default behaviours for\n      // "pinch" events, which can still be executed unless we prevent them here.\n      event.preventDefault();\n    }\n  }\n}\n\nfunction handleTouchMove(screenSpaceEventHandler, event) {\n  gotTouchEvent(screenSpaceEventHandler);\n\n  var changedTouches = event.changedTouches;\n\n  var i;\n  var length = changedTouches.length;\n  var touch;\n  var identifier;\n  var positions = screenSpaceEventHandler._positions;\n\n  for (i = 0; i < length; ++i) {\n    touch = changedTouches[i];\n    identifier = touch.identifier;\n    var position = positions.get(identifier);\n    if ((0,_defined_js__WEBPACK_IMPORTED_MODULE_9__/* ["default"] */ .Z)(position)) {\n      getPosition(screenSpaceEventHandler, touch, position);\n    }\n  }\n\n  fireTouchMoveEvents(screenSpaceEventHandler, event);\n\n  var previousPositions = screenSpaceEventHandler._previousPositions;\n\n  for (i = 0; i < length; ++i) {\n    touch = changedTouches[i];\n    identifier = touch.identifier;\n    _Cartesian2_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"].clone */ .Z.clone(\n      positions.get(identifier),\n      previousPositions.get(identifier)\n    );\n  }\n}\n\nvar touchMoveEvent = {\n  startPosition: new _Cartesian2_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .Z(),\n  endPosition: new _Cartesian2_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .Z(),\n};\nvar touchPinchMovementEvent = {\n  distance: {\n    startPosition: new _Cartesian2_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .Z(),\n    endPosition: new _Cartesian2_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .Z(),\n  },\n  angleAndHeight: {\n    startPosition: new _Cartesian2_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .Z(),\n    endPosition: new _Cartesian2_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .Z(),\n  },\n};\n\nfunction fireTouchMoveEvents(screenSpaceEventHandler, event) {\n  var modifier = getModifier(event);\n  var positions = screenSpaceEventHandler._positions;\n  var previousPositions = screenSpaceEventHandler._previousPositions;\n  var numberOfTouches = positions.length;\n  var action;\n\n  if (\n    numberOfTouches === 1 &&\n    screenSpaceEventHandler._buttonDown[MouseButton.LEFT]\n  ) {\n    // moving single touch\n    var position = positions.values[0];\n    _Cartesian2_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"].clone */ .Z.clone(position, screenSpaceEventHandler._primaryPosition);\n\n    var previousPosition = screenSpaceEventHandler._primaryPreviousPosition;\n\n    action = screenSpaceEventHandler.getInputAction(\n      _ScreenSpaceEventType_js__WEBPACK_IMPORTED_MODULE_8__/* ["default"].MOUSE_MOVE */ .Z.MOUSE_MOVE,\n      modifier\n    );\n\n    if ((0,_defined_js__WEBPACK_IMPORTED_MODULE_9__/* ["default"] */ .Z)(action)) {\n      _Cartesian2_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"].clone */ .Z.clone(previousPosition, touchMoveEvent.startPosition);\n      _Cartesian2_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"].clone */ .Z.clone(position, touchMoveEvent.endPosition);\n\n      action(touchMoveEvent);\n    }\n\n    _Cartesian2_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"].clone */ .Z.clone(position, previousPosition);\n\n    event.preventDefault();\n  } else if (numberOfTouches === 2 && screenSpaceEventHandler._isPinching) {\n    // moving pinch\n\n    action = screenSpaceEventHandler.getInputAction(\n      _ScreenSpaceEventType_js__WEBPACK_IMPORTED_MODULE_8__/* ["default"].PINCH_MOVE */ .Z.PINCH_MOVE,\n      modifier\n    );\n    if ((0,_defined_js__WEBPACK_IMPORTED_MODULE_9__/* ["default"] */ .Z)(action)) {\n      var position1 = positions.values[0];\n      var position2 = positions.values[1];\n      var previousPosition1 = previousPositions.values[0];\n      var previousPosition2 = previousPositions.values[1];\n\n      var dX = position2.x - position1.x;\n      var dY = position2.y - position1.y;\n      var dist = Math.sqrt(dX * dX + dY * dY) * 0.25;\n\n      var prevDX = previousPosition2.x - previousPosition1.x;\n      var prevDY = previousPosition2.y - previousPosition1.y;\n      var prevDist = Math.sqrt(prevDX * prevDX + prevDY * prevDY) * 0.25;\n\n      var cY = (position2.y + position1.y) * 0.125;\n      var prevCY = (previousPosition2.y + previousPosition1.y) * 0.125;\n      var angle = Math.atan2(dY, dX);\n      var prevAngle = Math.atan2(prevDY, prevDX);\n\n      _Cartesian2_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"].fromElements */ .Z.fromElements(\n        0.0,\n        prevDist,\n        touchPinchMovementEvent.distance.startPosition\n      );\n      _Cartesian2_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"].fromElements */ .Z.fromElements(\n        0.0,\n        dist,\n        touchPinchMovementEvent.distance.endPosition\n      );\n\n      _Cartesian2_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"].fromElements */ .Z.fromElements(\n        prevAngle,\n        prevCY,\n        touchPinchMovementEvent.angleAndHeight.startPosition\n      );\n      _Cartesian2_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"].fromElements */ .Z.fromElements(\n        angle,\n        cY,\n        touchPinchMovementEvent.angleAndHeight.endPosition\n      );\n\n      action(touchPinchMovementEvent);\n    }\n  }\n}\n\nfunction handlePointerDown(screenSpaceEventHandler, event) {\n  event.target.setPointerCapture(event.pointerId);\n\n  if (event.pointerType === "touch") {\n    var positions = screenSpaceEventHandler._positions;\n\n    var identifier = event.pointerId;\n    positions.set(\n      identifier,\n      getPosition(screenSpaceEventHandler, event, new _Cartesian2_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .Z())\n    );\n\n    fireTouchEvents(screenSpaceEventHandler, event);\n\n    var previousPositions = screenSpaceEventHandler._previousPositions;\n    previousPositions.set(\n      identifier,\n      _Cartesian2_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"].clone */ .Z.clone(positions.get(identifier))\n    );\n  } else {\n    handleMouseDown(screenSpaceEventHandler, event);\n  }\n}\n\nfunction handlePointerUp(screenSpaceEventHandler, event) {\n  if (event.pointerType === "touch") {\n    var positions = screenSpaceEventHandler._positions;\n\n    var identifier = event.pointerId;\n    positions.remove(identifier);\n\n    fireTouchEvents(screenSpaceEventHandler, event);\n\n    var previousPositions = screenSpaceEventHandler._previousPositions;\n    previousPositions.remove(identifier);\n  } else {\n    handleMouseUp(screenSpaceEventHandler, event);\n  }\n}\n\nfunction handlePointerMove(screenSpaceEventHandler, event) {\n  if (event.pointerType === "touch") {\n    var positions = screenSpaceEventHandler._positions;\n\n    var identifier = event.pointerId;\n    var position = positions.get(identifier);\n    if (!(0,_defined_js__WEBPACK_IMPORTED_MODULE_9__/* ["default"] */ .Z)(position)) {\n      return;\n    }\n\n    getPosition(screenSpaceEventHandler, event, position);\n    fireTouchMoveEvents(screenSpaceEventHandler, event);\n\n    var previousPositions = screenSpaceEventHandler._previousPositions;\n    _Cartesian2_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"].clone */ .Z.clone(\n      positions.get(identifier),\n      previousPositions.get(identifier)\n    );\n  } else {\n    handleMouseMove(screenSpaceEventHandler, event);\n  }\n}\n\n/**\n * Handles user input events. Custom functions can be added to be executed on\n * when the user enters input.\n *\n * @alias ScreenSpaceEventHandler\n *\n * @param {HTMLCanvasElement} [element=document] The element to add events to.\n *\n * @constructor\n */\nfunction ScreenSpaceEventHandler(element) {\n  this._inputEvents = {};\n  this._buttonDown = {\n    LEFT: false,\n    MIDDLE: false,\n    RIGHT: false,\n  };\n  this._isPinching = false;\n  this._isTouchHolding = false;\n  this._lastSeenTouchEvent = -ScreenSpaceEventHandler.mouseEmulationIgnoreMilliseconds;\n\n  this._primaryStartPosition = new _Cartesian2_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .Z();\n  this._primaryPosition = new _Cartesian2_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .Z();\n  this._primaryPreviousPosition = new _Cartesian2_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .Z();\n\n  this._positions = new _AssociativeArray_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .Z();\n  this._previousPositions = new _AssociativeArray_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .Z();\n\n  this._removalFunctions = [];\n\n  this._touchHoldTimer = undefined;\n\n  // TODO: Revisit when doing mobile development. May need to be configurable\n  // or determined based on the platform?\n  this._clickPixelTolerance = 5;\n  this._holdPixelTolerance = 25;\n\n  this._element = (0,_defaultValue_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"] */ .Z)(element, document);\n\n  registerListeners(this);\n}\n\n/**\n * Set a function to be executed on an input event.\n *\n * @param {Function} action Function to be executed when the input event occurs.\n * @param {Number} type The ScreenSpaceEventType of input event.\n * @param {Number} [modifier] A KeyboardEventModifier key that is held when a <code>type</code>\n * event occurs.\n *\n * @see ScreenSpaceEventHandler#getInputAction\n * @see ScreenSpaceEventHandler#removeInputAction\n */\nScreenSpaceEventHandler.prototype.setInputAction = function (\n  action,\n  type,\n  modifier\n) {\n  //>>includeStart(\'debug\', pragmas.debug);\n  if (!(0,_defined_js__WEBPACK_IMPORTED_MODULE_9__/* ["default"] */ .Z)(action)) {\n    throw new _DeveloperError_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .Z("action is required.");\n  }\n  if (!(0,_defined_js__WEBPACK_IMPORTED_MODULE_9__/* ["default"] */ .Z)(type)) {\n    throw new _DeveloperError_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .Z("type is required.");\n  }\n  //>>includeEnd(\'debug\');\n\n  var key = getInputEventKey(type, modifier);\n  this._inputEvents[key] = action;\n};\n\n/**\n * Returns the function to be executed on an input event.\n *\n * @param {Number} type The ScreenSpaceEventType of input event.\n * @param {Number} [modifier] A KeyboardEventModifier key that is held when a <code>type</code>\n * event occurs.\n *\n * @returns {Function} The function to be executed on an input event.\n *\n * @see ScreenSpaceEventHandler#setInputAction\n * @see ScreenSpaceEventHandler#removeInputAction\n */\nScreenSpaceEventHandler.prototype.getInputAction = function (type, modifier) {\n  //>>includeStart(\'debug\', pragmas.debug);\n  if (!(0,_defined_js__WEBPACK_IMPORTED_MODULE_9__/* ["default"] */ .Z)(type)) {\n    throw new _DeveloperError_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .Z("type is required.");\n  }\n  //>>includeEnd(\'debug\');\n\n  var key = getInputEventKey(type, modifier);\n  return this._inputEvents[key];\n};\n\n/**\n * Removes the function to be executed on an input event.\n *\n * @param {Number} type The ScreenSpaceEventType of input event.\n * @param {Number} [modifier] A KeyboardEventModifier key that is held when a <code>type</code>\n * event occurs.\n *\n * @see ScreenSpaceEventHandler#getInputAction\n * @see ScreenSpaceEventHandler#setInputAction\n */\nScreenSpaceEventHandler.prototype.removeInputAction = function (\n  type,\n  modifier\n) {\n  //>>includeStart(\'debug\', pragmas.debug);\n  if (!(0,_defined_js__WEBPACK_IMPORTED_MODULE_9__/* ["default"] */ .Z)(type)) {\n    throw new _DeveloperError_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .Z("type is required.");\n  }\n  //>>includeEnd(\'debug\');\n\n  var key = getInputEventKey(type, modifier);\n  delete this._inputEvents[key];\n};\n\n/**\n * Returns true if this object was destroyed; otherwise, false.\n * <br /><br />\n * If this object was destroyed, it should not be used; calling any function other than\n * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.\n *\n * @returns {Boolean} <code>true</code> if this object was destroyed; otherwise, <code>false</code>.\n *\n * @see ScreenSpaceEventHandler#destroy\n */\nScreenSpaceEventHandler.prototype.isDestroyed = function () {\n  return false;\n};\n\n/**\n * Removes listeners held by this object.\n * <br /><br />\n * Once an object is destroyed, it should not be used; calling any function other than\n * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.  Therefore,\n * assign the return value (<code>undefined</code>) to the object as done in the example.\n *\n * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.\n *\n *\n * @example\n * handler = handler && handler.destroy();\n *\n * @see ScreenSpaceEventHandler#isDestroyed\n */\nScreenSpaceEventHandler.prototype.destroy = function () {\n  unregisterListeners(this);\n\n  return (0,_destroyObject_js__WEBPACK_IMPORTED_MODULE_3__/* ["default"] */ .Z)(this);\n};\n\n/**\n * The amount of time, in milliseconds, that mouse events will be disabled after\n * receiving any touch events, such that any emulated mouse events will be ignored.\n * @type {Number}\n * @default 800\n */\nScreenSpaceEventHandler.mouseEmulationIgnoreMilliseconds = 800;\n\n/**\n * The amount of time, in milliseconds, before a touch on the screen becomes a\n * touch and hold.\n * @type {Number}\n * @default 1500\n */\nScreenSpaceEventHandler.touchHoldDelayMilliseconds = 1500;\n/* harmony default export */ __webpack_exports__["Z"] = (ScreenSpaceEventHandler);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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UyxnREFBZ0Q7QUFDdEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHVEQUF1RDtBQUN2RCw4Q0FBOEMsc0JBQXNCO0FBQ3BFO0FBQ0E7QUFDQSxlQUFlLGdCQUFnQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsU0FBUyxzRUFBYTtBQUN0Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSx5REFBZSx1QkFBdUIsRUFBQyIsInNvdXJjZXMiOlsid2VicGFjazovL3Z1ZTMtd2VicGFjazUvLi9ub2RlX21vZHVsZXMvY2VzaXVtL1NvdXJjZS9Db3JlL1NjcmVlblNwYWNlRXZlbnRIYW5kbGVyLmpzPzhiOTUiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IEFzc29jaWF0aXZlQXJyYXkgZnJvbSBcIi4vQXNzb2NpYXRpdmVBcnJheS5qc1wiO1xuaW1wb3J0IENhcnRlc2lhbjIgZnJvbSBcIi4vQ2FydGVzaWFuMi5qc1wiO1xuaW1wb3J0IGRlZmF1bHRWYWx1ZSBmcm9tIFwiLi9kZWZhdWx0VmFsdWUuanNcIjtcbmltcG9ydCBkZWZpbmVkIGZyb20gXCIuL2RlZmluZWQuanNcIjtcbmltcG9ydCBkZXN0cm95T2JqZWN0IGZyb20gXCIuL2Rlc3Ryb3lPYmplY3QuanNcIjtcbmltcG9ydCBEZXZlbG9wZXJFcnJvciBmcm9tIFwiLi9EZXZlbG9wZXJFcnJvci5qc1wiO1xuaW1wb3J0IEZlYXR1cmVEZXRlY3Rpb24gZnJvbSBcIi4vRmVhdHVyZURldGVjdGlvbi5qc1wiO1xuaW1wb3J0IGdldFRpbWVzdGFtcCBmcm9tIFwiLi9nZXRUaW1lc3RhbXAuanNcIjtcbmltcG9ydCBLZXlib2FyZEV2ZW50TW9kaWZpZXIgZnJvbSBcIi4vS2V5Ym9hcmRFdmVudE1vZGlmaWVyLmpzXCI7XG5pbXBvcnQgU2NyZWVuU3BhY2VFdmVudFR5cGUgZnJvbSBcIi4vU2NyZWVuU3BhY2VFdmVudFR5cGUuanNcIjtcblxuZnVuY3Rpb24gZ2V0UG9zaXRpb24oc2NyZWVuU3BhY2VFdmVudEhhbmRsZXIsIGV2ZW50LCByZXN1bHQpIHtcbiAgdmFyIGVsZW1lbnQgPSBzY3JlZW5TcGFjZUV2ZW50SGFuZGxlci5fZWxlbWVudDtcbiAgaWYgKGVsZW1lbnQgPT09IGRvY3VtZW50KSB7XG4gICAgcmVzdWx0LnggPSBldmVudC5jbGllbnRYO1xuICAgIHJlc3VsdC55ID0gZXZlbnQuY2xpZW50WTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgdmFyIHJlY3QgPSBlbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICByZXN1bHQueCA9IGV2ZW50LmNsaWVudFggLSByZWN0LmxlZnQ7XG4gIHJlc3VsdC55ID0gZXZlbnQuY2xpZW50WSAtIHJlY3QudG9wO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG5mdW5jdGlvbiBnZXRJbnB1dEV2ZW50S2V5KHR5cGUsIG1vZGlmaWVyKSB7XG4gIHZhciBrZXkgPSB0eXBlO1xuICBpZiAoZGVmaW5lZChtb2RpZmllcikpIHtcbiAgICBrZXkgKz0gXCIrXCIgKyBtb2RpZmllcjtcbiAgfVxuICByZXR1cm4ga2V5O1xufVxuXG5mdW5jdGlvbiBnZXRNb2RpZmllcihldmVudCkge1xuICBpZiAoZXZlbnQuc2hpZnRLZXkpIHtcbiAgICByZXR1cm4gS2V5Ym9hcmRFdmVudE1vZGlmaWVyLlNISUZUO1xuICB9IGVsc2UgaWYgKGV2ZW50LmN0cmxLZXkpIHtcbiAgICByZXR1cm4gS2V5Ym9hcmRFdmVudE1vZGlmaWVyLkNUUkw7XG4gIH0gZWxzZSBpZiAoZXZlbnQuYWx0S2V5KSB7XG4gICAgcmV0dXJuIEtleWJvYXJkRXZlbnRNb2RpZmllci5BTFQ7XG4gIH1cblxuICByZXR1cm4gdW5kZWZpbmVkO1xufVxuXG52YXIgTW91c2VCdXR0b24gPSB7XG4gIExFRlQ6IDAsXG4gIE1JRERMRTogMSxcbiAgUklHSFQ6IDIsXG59O1xuXG5mdW5jdGlvbiByZWdpc3Rlckxpc3RlbmVyKHNjcmVlblNwYWNlRXZlbnRIYW5kbGVyLCBkb21UeXBlLCBlbGVtZW50LCBjYWxsYmFjaykge1xuICBmdW5jdGlvbiBsaXN0ZW5lcihlKSB7XG4gICAgY2FsbGJhY2soc2NyZWVuU3BhY2VFdmVudEhhbmRsZXIsIGUpO1xuICB9XG5cbiAgaWYgKEZlYXR1cmVEZXRlY3Rpb24uaXNJbnRlcm5ldEV4cGxvcmVyKCkpIHtcbiAgICBlbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoZG9tVHlwZSwgbGlzdGVuZXIsIGZhbHNlKTtcbiAgfSBlbHNlIHtcbiAgICBlbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoZG9tVHlwZSwgbGlzdGVuZXIsIHtcbiAgICAgIGNhcHR1cmU6IGZhbHNlLFxuICAgICAgcGFzc2l2ZTogZmFsc2UsXG4gICAgfSk7XG4gIH1cblxuICBzY3JlZW5TcGFjZUV2ZW50SGFuZGxlci5fcmVtb3ZhbEZ1bmN0aW9ucy5wdXNoKGZ1bmN0aW9uICgpIHtcbiAgICBlbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoZG9tVHlwZSwgbGlzdGVuZXIsIGZhbHNlKTtcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIHJlZ2lzdGVyTGlzdGVuZXJzKHNjcmVlblNwYWNlRXZlbnRIYW5kbGVyKSB7XG4gIHZhciBlbGVtZW50ID0gc2NyZWVuU3BhY2VFdmVudEhhbmRsZXIuX2VsZW1lbnQ7XG5cbiAgLy8gc29tZSBsaXN0ZW5lcnMgbWF5IGJlIHJlZ2lzdGVyZWQgb24gdGhlIGRvY3VtZW50LCBzbyB3ZSBzdGlsbCBnZXQgZXZlbnRzIGV2ZW4gYWZ0ZXJcbiAgLy8gbGVhdmluZyB0aGUgYm91bmRzIG9mIGVsZW1lbnQuXG4gIC8vIHRoaXMgaXMgYWZmZWN0ZWQgYnkgdGhlIGV4aXN0ZW5jZSBvZiBhbiB1bmRvY3VtZW50ZWQgZGlzYWJsZVJvb3RFdmVudHMgcHJvcGVydHkgb24gZWxlbWVudC5cbiAgdmFyIGFsdGVybmF0ZUVsZW1lbnQgPSAhZGVmaW5lZChlbGVtZW50LmRpc2FibGVSb290RXZlbnRzKVxuICAgID8gZG9jdW1lbnRcbiAgICA6IGVsZW1lbnQ7XG5cbiAgaWYgKEZlYXR1cmVEZXRlY3Rpb24uc3VwcG9ydHNQb2ludGVyRXZlbnRzKCkpIHtcbiAgICByZWdpc3Rlckxpc3RlbmVyKFxuICAgICAgc2NyZWVuU3BhY2VFdmVudEhhbmRsZXIsXG4gICAgICBcInBvaW50ZXJkb3duXCIsXG4gICAgICBlbGVtZW50LFxuICAgICAgaGFuZGxlUG9pbnRlckRvd25cbiAgICApO1xuICAgIHJlZ2lzdGVyTGlzdGVuZXIoXG4gICAgICBzY3JlZW5TcGFjZUV2ZW50SGFuZGxlcixcbiAgICAgIFwicG9pbnRlcnVwXCIsXG4gICAgICBlbGVtZW50LFxuICAgICAgaGFuZGxlUG9pbnRlclVwXG4gICAgKTtcbiAgICByZWdpc3Rlckxpc3RlbmVyKFxuICAgICAgc2NyZWVuU3BhY2VFdmVudEhhbmRsZXIsXG4gICAgICBcInBvaW50ZXJtb3ZlXCIsXG4gICAgICBlbGVtZW50LFxuICAgICAgaGFuZGxlUG9pbnRlck1vdmVcbiAgICApO1xuICAgIHJlZ2lzdGVyTGlzdGVuZXIoXG4gICAgICBzY3JlZW5TcGFjZUV2ZW50SGFuZGxlcixcbiAgICAgIFwicG9pbnRlcmNhbmNlbFwiLFxuICAgICAgZWxlbWVudCxcbiAgICAgIGhhbmRsZVBvaW50ZXJVcFxuICAgICk7XG4gIH0gZWxzZSB7XG4gICAgcmVnaXN0ZXJMaXN0ZW5lcihcbiAgICAgIHNjcmVlblNwYWNlRXZlbnRIYW5kbGVyLFxuICAgICAgXCJtb3VzZWRvd25cIixcbiAgICAgIGVsZW1lbnQsXG4gICAgICBoYW5kbGVNb3VzZURvd25cbiAgICApO1xuICAgIHJlZ2lzdGVyTGlzdGVuZXIoXG4gICAgICBzY3JlZW5TcGFjZUV2ZW50SGFuZGxlcixcbiAgICAgIFwibW91c2V1cFwiLFxuICAgICAgYWx0ZXJuYXRlRWxlbWVudCxcbiAgICAgIGhhbmRsZU1vdXNlVXBcbiAgICApO1xuICAgIHJlZ2lzdGVyTGlzdGVuZXIoXG4gICAgICBzY3JlZW5TcGFjZUV2ZW50SGFuZGxlcixcbiAgICAgIFwibW91c2Vtb3ZlXCIsXG4gICAgICBhbHRlcm5hdGVFbGVtZW50LFxuICAgICAgaGFuZGxlTW91c2VNb3ZlXG4gICAgKTtcbiAgICByZWdpc3Rlckxpc3RlbmVyKFxuICAgICAgc2NyZWVuU3BhY2VFdmVudEhhbmRsZXIsXG4gICAgICBcInRvdWNoc3RhcnRcIixcbiAgICAgIGVsZW1lbnQsXG4gICAgICBoYW5kbGVUb3VjaFN0YXJ0XG4gICAgKTtcbiAgICByZWdpc3Rlckxpc3RlbmVyKFxuICAgICAgc2NyZWVuU3BhY2VFdmVudEhhbmRsZXIsXG4gICAgICBcInRvdWNoZW5kXCIsXG4gICAgICBhbHRlcm5hdGVFbGVtZW50LFxuICAgICAgaGFuZGxlVG91Y2hFbmRcbiAgICApO1xuICAgIHJlZ2lzdGVyTGlzdGVuZXIoXG4gICAgICBzY3JlZW5TcGFjZUV2ZW50SGFuZGxlcixcbiAgICAgIFwidG91Y2htb3ZlXCIsXG4gICAgICBhbHRlcm5hdGVFbGVtZW50LFxuICAgICAgaGFuZGxlVG91Y2hNb3ZlXG4gICAgKTtcbiAgICByZWdpc3Rlckxpc3RlbmVyKFxuICAgICAgc2NyZWVuU3BhY2VFdmVudEhhbmRsZXIsXG4gICAgICBcInRvdWNoY2FuY2VsXCIsXG4gICAgICBhbHRlcm5hdGVFbGVtZW50LFxuICAgICAgaGFuZGxlVG91Y2hFbmRcbiAgICApO1xuICB9XG5cbiAgcmVnaXN0ZXJMaXN0ZW5lcihcbiAgICBzY3JlZW5TcGFjZUV2ZW50SGFuZGxlcixcbiAgICBcImRibGNsaWNrXCIsXG4gICAgZWxlbWVudCxcbiAgICBoYW5kbGVEYmxDbGlja1xuICApO1xuXG4gIC8vIGRldGVjdCBhdmFpbGFibGUgd2hlZWwgZXZlbnRcbiAgdmFyIHdoZWVsRXZlbnQ7XG4gIGlmIChcIm9ud2hlZWxcIiBpbiBlbGVtZW50KSB7XG4gICAgLy8gc3BlYyBldmVudCB0eXBlXG4gICAgd2hlZWxFdmVudCA9IFwid2hlZWxcIjtcbiAgfSBlbHNlIGlmIChkb2N1bWVudC5vbm1vdXNld2hlZWwgIT09IHVuZGVmaW5lZCkge1xuICAgIC8vIGxlZ2FjeSBldmVudCB0eXBlXG4gICAgd2hlZWxFdmVudCA9IFwibW91c2V3aGVlbFwiO1xuICB9IGVsc2Uge1xuICAgIC8vIG9sZGVyIEZpcmVmb3hcbiAgICB3aGVlbEV2ZW50ID0gXCJET01Nb3VzZVNjcm9sbFwiO1xuICB9XG5cbiAgcmVnaXN0ZXJMaXN0ZW5lcihzY3JlZW5TcGFjZUV2ZW50SGFuZGxlciwgd2hlZWxFdmVudCwgZWxlbWVudCwgaGFuZGxlV2hlZWwpO1xufVxuXG5mdW5jdGlvbiB1bnJlZ2lzdGVyTGlzdGVuZXJzKHNjcmVlblNwYWNlRXZlbnRIYW5kbGVyKSB7XG4gIHZhciByZW1vdmFsRnVuY3Rpb25zID0gc2NyZWVuU3BhY2VFdmVudEhhbmRsZXIuX3JlbW92YWxGdW5jdGlvbnM7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcmVtb3ZhbEZ1bmN0aW9ucy5sZW5ndGg7ICsraSkge1xuICAgIHJlbW92YWxGdW5jdGlvbnNbaV0oKTtcbiAgfVxufVxuXG52YXIgbW91c2VEb3duRXZlbnQgPSB7XG4gIHBvc2l0aW9uOiBuZXcgQ2FydGVzaWFuMigpLFxufTtcblxuZnVuY3Rpb24gZ290VG91Y2hFdmVudChzY3JlZW5TcGFjZUV2ZW50SGFuZGxlcikge1xuICBzY3JlZW5TcGFjZUV2ZW50SGFuZGxlci5fbGFzdFNlZW5Ub3VjaEV2ZW50ID0gZ2V0VGltZXN0YW1wKCk7XG59XG5cbmZ1bmN0aW9uIGNhblByb2Nlc3NNb3VzZUV2ZW50KHNjcmVlblNwYWNlRXZlbnRIYW5kbGVyKSB7XG4gIHJldHVybiAoXG4gICAgZ2V0VGltZXN0YW1wKCkgLSBzY3JlZW5TcGFjZUV2ZW50SGFuZGxlci5fbGFzdFNlZW5Ub3VjaEV2ZW50ID5cbiAgICBTY3JlZW5TcGFjZUV2ZW50SGFuZGxlci5tb3VzZUVtdWxhdGlvbklnbm9yZU1pbGxpc2Vjb25kc1xuICApO1xufVxuXG5mdW5jdGlvbiBjaGVja1BpeGVsVG9sZXJhbmNlKHN0YXJ0UG9zaXRpb24sIGVuZFBvc2l0aW9uLCBwaXhlbFRvbGVyYW5jZSkge1xuICB2YXIgeERpZmYgPSBzdGFydFBvc2l0aW9uLnggLSBlbmRQb3NpdGlvbi54O1xuICB2YXIgeURpZmYgPSBzdGFydFBvc2l0aW9uLnkgLSBlbmRQb3NpdGlvbi55O1xuICB2YXIgdG90YWxQaXhlbHMgPSBNYXRoLnNxcnQoeERpZmYgKiB4RGlmZiArIHlEaWZmICogeURpZmYpO1xuXG4gIHJldHVybiB0b3RhbFBpeGVscyA8IHBpeGVsVG9sZXJhbmNlO1xufVxuXG5mdW5jdGlvbiBoYW5kbGVNb3VzZURvd24oc2NyZWVuU3BhY2VFdmVudEhhbmRsZXIsIGV2ZW50KSB7XG4gIGlmICghY2FuUHJvY2Vzc01vdXNlRXZlbnQoc2NyZWVuU3BhY2VFdmVudEhhbmRsZXIpKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIGJ1dHRvbiA9IGV2ZW50LmJ1dHRvbjtcbiAgc2NyZWVuU3BhY2VFdmVudEhhbmRsZXIuX2J1dHRvbkRvd25bYnV0dG9uXSA9IHRydWU7XG5cbiAgdmFyIHNjcmVlblNwYWNlRXZlbnRUeXBlO1xuICBpZiAoYnV0dG9uID09PSBNb3VzZUJ1dHRvbi5MRUZUKSB7XG4gICAgc2NyZWVuU3BhY2VFdmVudFR5cGUgPSBTY3JlZW5TcGFjZUV2ZW50VHlwZS5MRUZUX0RPV047XG4gIH0gZWxzZSBpZiAoYnV0dG9uID09PSBNb3VzZUJ1dHRvbi5NSURETEUpIHtcbiAgICBzY3JlZW5TcGFjZUV2ZW50VHlwZSA9IFNjcmVlblNwYWNlRXZlbnRUeXBlLk1JRERMRV9ET1dOO1xuICB9IGVsc2UgaWYgKGJ1dHRvbiA9PT0gTW91c2VCdXR0b24uUklHSFQpIHtcbiAgICBzY3JlZW5TcGFjZUV2ZW50VHlwZSA9IFNjcmVlblNwYWNlRXZlbnRUeXBlLlJJR0hUX0RPV047XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIHBvc2l0aW9uID0gZ2V0UG9zaXRpb24oXG4gICAgc2NyZWVuU3BhY2VFdmVudEhhbmRsZXIsXG4gICAgZXZlbnQsXG4gICAgc2NyZWVuU3BhY2VFdmVudEhhbmRsZXIuX3ByaW1hcnlQb3NpdGlvblxuICApO1xuICBDYXJ0ZXNpYW4yLmNsb25lKHBvc2l0aW9uLCBzY3JlZW5TcGFjZUV2ZW50SGFuZGxlci5fcHJpbWFyeVN0YXJ0UG9zaXRpb24pO1xuICBDYXJ0ZXNpYW4yLmNsb25lKHBvc2l0aW9uLCBzY3JlZW5TcGFjZUV2ZW50SGFuZGxlci5fcHJpbWFyeVByZXZpb3VzUG9zaXRpb24pO1xuXG4gIHZhciBtb2RpZmllciA9IGdldE1vZGlmaWVyKGV2ZW50KTtcblxuICB2YXIgYWN0aW9uID0gc2NyZWVuU3BhY2VFdmVudEhhbmRsZXIuZ2V0SW5wdXRBY3Rpb24oXG4gICAgc2NyZWVuU3BhY2VFdmVudFR5cGUsXG4gICAgbW9kaWZpZXJcbiAgKTtcblxuICBpZiAoZGVmaW5lZChhY3Rpb24pKSB7XG4gICAgQ2FydGVzaWFuMi5jbG9uZShwb3NpdGlvbiwgbW91c2VEb3duRXZlbnQucG9zaXRpb24pO1xuXG4gICAgYWN0aW9uKG1vdXNlRG93bkV2ZW50KTtcblxuICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gIH1cbn1cblxudmFyIG1vdXNlVXBFdmVudCA9IHtcbiAgcG9zaXRpb246IG5ldyBDYXJ0ZXNpYW4yKCksXG59O1xudmFyIG1vdXNlQ2xpY2tFdmVudCA9IHtcbiAgcG9zaXRpb246IG5ldyBDYXJ0ZXNpYW4yKCksXG59O1xuXG5mdW5jdGlvbiBjYW5jZWxNb3VzZUV2ZW50KFxuICBzY3JlZW5TcGFjZUV2ZW50SGFuZGxlcixcbiAgc2NyZWVuU3BhY2VFdmVudFR5cGUsXG4gIGNsaWNrU2NyZWVuU3BhY2VFdmVudFR5cGUsXG4gIGV2ZW50XG4pIHtcbiAgdmFyIG1vZGlmaWVyID0gZ2V0TW9kaWZpZXIoZXZlbnQpO1xuXG4gIHZhciBhY3Rpb24gPSBzY3JlZW5TcGFjZUV2ZW50SGFuZGxlci5nZXRJbnB1dEFjdGlvbihcbiAgICBzY3JlZW5TcGFjZUV2ZW50VHlwZSxcbiAgICBtb2RpZmllclxuICApO1xuICB2YXIgY2xpY2tBY3Rpb24gPSBzY3JlZW5TcGFjZUV2ZW50SGFuZGxlci5nZXRJbnB1dEFjdGlvbihcbiAgICBjbGlja1NjcmVlblNwYWNlRXZlbnRUeXBlLFxuICAgIG1vZGlmaWVyXG4gICk7XG5cbiAgaWYgKGRlZmluZWQoYWN0aW9uKSB8fCBkZWZpbmVkKGNsaWNrQWN0aW9uKSkge1xuICAgIHZhciBwb3NpdGlvbiA9IGdldFBvc2l0aW9uKFxuICAgICAgc2NyZWVuU3BhY2VFdmVudEhhbmRsZXIsXG4gICAgICBldmVudCxcbiAgICAgIHNjcmVlblNwYWNlRXZlbnRIYW5kbGVyLl9wcmltYXJ5UG9zaXRpb25cbiAgICApO1xuXG4gICAgaWYgKGRlZmluZWQoYWN0aW9uKSkge1xuICAgICAgQ2FydGVzaWFuMi5jbG9uZShwb3NpdGlvbiwgbW91c2VVcEV2ZW50LnBvc2l0aW9uKTtcblxuICAgICAgYWN0aW9uKG1vdXNlVXBFdmVudCk7XG4gICAgfVxuXG4gICAgaWYgKGRlZmluZWQoY2xpY2tBY3Rpb24pKSB7XG4gICAgICB2YXIgc3RhcnRQb3NpdGlvbiA9IHNjcmVlblNwYWNlRXZlbnRIYW5kbGVyLl9wcmltYXJ5U3RhcnRQb3NpdGlvbjtcbiAgICAgIGlmIChcbiAgICAgICAgY2hlY2tQaXhlbFRvbGVyYW5jZShcbiAgICAgICAgICBzdGFydFBvc2l0aW9uLFxuICAgICAgICAgIHBvc2l0aW9uLFxuICAgICAgICAgIHNjcmVlblNwYWNlRXZlbnRIYW5kbGVyLl9jbGlja1BpeGVsVG9sZXJhbmNlXG4gICAgICAgIClcbiAgICAgICkge1xuICAgICAgICBDYXJ0ZXNpYW4yLmNsb25lKHBvc2l0aW9uLCBtb3VzZUNsaWNrRXZlbnQucG9zaXRpb24pO1xuXG4gICAgICAgIGNsaWNrQWN0aW9uKG1vdXNlQ2xpY2tFdmVudCk7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGhhbmRsZU1vdXNlVXAoc2NyZWVuU3BhY2VFdmVudEhhbmRsZXIsIGV2ZW50KSB7XG4gIGlmICghY2FuUHJvY2Vzc01vdXNlRXZlbnQoc2NyZWVuU3BhY2VFdmVudEhhbmRsZXIpKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIGJ1dHRvbiA9IGV2ZW50LmJ1dHRvbjtcblxuICBpZiAoXG4gICAgYnV0dG9uICE9PSBNb3VzZUJ1dHRvbi5MRUZUICYmXG4gICAgYnV0dG9uICE9PSBNb3VzZUJ1dHRvbi5NSURETEUgJiZcbiAgICBidXR0b24gIT09IE1vdXNlQnV0dG9uLlJJR0hUXG4gICkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGlmIChzY3JlZW5TcGFjZUV2ZW50SGFuZGxlci5fYnV0dG9uRG93bltNb3VzZUJ1dHRvbi5MRUZUXSkge1xuICAgIGNhbmNlbE1vdXNlRXZlbnQoXG4gICAgICBzY3JlZW5TcGFjZUV2ZW50SGFuZGxlcixcbiAgICAgIFNjcmVlblNwYWNlRXZlbnRUeXBlLkxFRlRfVVAsXG4gICAgICBTY3JlZW5TcGFjZUV2ZW50VHlwZS5MRUZUX0NMSUNLLFxuICAgICAgZXZlbnRcbiAgICApO1xuICAgIHNjcmVlblNwYWNlRXZlbnRIYW5kbGVyLl9idXR0b25Eb3duW01vdXNlQnV0dG9uLkxFRlRdID0gZmFsc2U7XG4gIH1cbiAgaWYgKHNjcmVlblNwYWNlRXZlbnRIYW5kbGVyLl9idXR0b25Eb3duW01vdXNlQnV0dG9uLk1JRERMRV0pIHtcbiAgICBjYW5jZWxNb3VzZUV2ZW50KFxuICAgICAgc2NyZWVuU3BhY2VFdmVudEhhbmRsZXIsXG4gICAgICBTY3JlZW5TcGFjZUV2ZW50VHlwZS5NSURETEVfVVAsXG4gICAgICBTY3JlZW5TcGFjZUV2ZW50VHlwZS5NSURETEVfQ0xJQ0ssXG4gICAgICBldmVudFxuICAgICk7XG4gICAgc2NyZWVuU3BhY2VFdmVudEhhbmRsZXIuX2J1dHRvbkRvd25bTW91c2VCdXR0b24uTUlERExFXSA9IGZhbHNlO1xuICB9XG4gIGlmIChzY3JlZW5TcGFjZUV2ZW50SGFuZGxlci5fYnV0dG9uRG93bltNb3VzZUJ1dHRvbi5SSUdIVF0pIHtcbiAgICBjYW5jZWxNb3VzZUV2ZW50KFxuICAgICAgc2NyZWVuU3BhY2VFdmVudEhhbmRsZXIsXG4gICAgICBTY3JlZW5TcGFjZUV2ZW50VHlwZS5SSUdIVF9VUCxcbiAgICAgIFNjcmVlblNwYWNlRXZlbnRUeXBlLlJJR0hUX0NMSUNLLFxuICAgICAgZXZlbnRcbiAgICApO1xuICAgIHNjcmVlblNwYWNlRXZlbnRIYW5kbGVyLl9idXR0b25Eb3duW01vdXNlQnV0dG9uLlJJR0hUXSA9IGZhbHNlO1xuICB9XG59XG5cbnZhciBtb3VzZU1vdmVFdmVudCA9IHtcbiAgc3RhcnRQb3NpdGlvbjogbmV3IENhcnRlc2lhbjIoKSxcbiAgZW5kUG9zaXRpb246IG5ldyBDYXJ0ZXNpYW4yKCksXG59O1xuXG5mdW5jdGlvbiBoYW5kbGVNb3VzZU1vdmUoc2NyZWVuU3BhY2VFdmVudEhhbmRsZXIsIGV2ZW50KSB7XG4gIGlmICghY2FuUHJvY2Vzc01vdXNlRXZlbnQoc2NyZWVuU3BhY2VFdmVudEhhbmRsZXIpKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIG1vZGlmaWVyID0gZ2V0TW9kaWZpZXIoZXZlbnQpO1xuXG4gIHZhciBwb3NpdGlvbiA9IGdldFBvc2l0aW9uKFxuICAgIHNjcmVlblNwYWNlRXZlbnRIYW5kbGVyLFxuICAgIGV2ZW50LFxuICAgIHNjcmVlblNwYWNlRXZlbnRIYW5kbGVyLl9wcmltYXJ5UG9zaXRpb25cbiAgKTtcbiAgdmFyIHByZXZpb3VzUG9zaXRpb24gPSBzY3JlZW5TcGFjZUV2ZW50SGFuZGxlci5fcHJpbWFyeVByZXZpb3VzUG9zaXRpb247XG5cbiAgdmFyIGFjdGlvbiA9IHNjcmVlblNwYWNlRXZlbnRIYW5kbGVyLmdldElucHV0QWN0aW9uKFxuICAgIFNjcmVlblNwYWNlRXZlbnRUeXBlLk1PVVNFX01PVkUsXG4gICAgbW9kaWZpZXJcbiAgKTtcblxuICBpZiAoZGVmaW5lZChhY3Rpb24pKSB7XG4gICAgQ2FydGVzaWFuMi5jbG9uZShwcmV2aW91c1Bvc2l0aW9uLCBtb3VzZU1vdmVFdmVudC5zdGFydFBvc2l0aW9uKTtcbiAgICBDYXJ0ZXNpYW4yLmNsb25lKHBvc2l0aW9uLCBtb3VzZU1vdmVFdmVudC5lbmRQb3NpdGlvbik7XG5cbiAgICBhY3Rpb24obW91c2VNb3ZlRXZlbnQpO1xuICB9XG5cbiAgQ2FydGVzaWFuMi5jbG9uZShwb3NpdGlvbiwgcHJldmlvdXNQb3NpdGlvbik7XG5cbiAgaWYgKFxuICAgIHNjcmVlblNwYWNlRXZlbnRIYW5kbGVyLl9idXR0b25Eb3duW01vdXNlQnV0dG9uLkxFRlRdIHx8XG4gICAgc2NyZWVuU3BhY2VFdmVudEhhbmRsZXIuX2J1dHRvbkRvd25bTW91c2VCdXR0b24uTUlERExFXSB8fFxuICAgIHNjcmVlblNwYWNlRXZlbnRIYW5kbGVyLl9idXR0b25Eb3duW01vdXNlQnV0dG9uLlJJR0hUXVxuICApIHtcbiAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICB9XG59XG5cbnZhciBtb3VzZURibENsaWNrRXZlbnQgPSB7XG4gIHBvc2l0aW9uOiBuZXcgQ2FydGVzaWFuMigpLFxufTtcblxuZnVuY3Rpb24gaGFuZGxlRGJsQ2xpY2soc2NyZWVuU3BhY2VFdmVudEhhbmRsZXIsIGV2ZW50KSB7XG4gIHZhciBidXR0b24gPSBldmVudC5idXR0b247XG5cbiAgdmFyIHNjcmVlblNwYWNlRXZlbnRUeXBlO1xuICBpZiAoYnV0dG9uID09PSBNb3VzZUJ1dHRvbi5MRUZUKSB7XG4gICAgc2NyZWVuU3BhY2VFdmVudFR5cGUgPSBTY3JlZW5TcGFjZUV2ZW50VHlwZS5MRUZUX0RPVUJMRV9DTElDSztcbiAgfSBlbHNlIHtcbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgbW9kaWZpZXIgPSBnZXRNb2RpZmllcihldmVudCk7XG5cbiAgdmFyIGFjdGlvbiA9IHNjcmVlblNwYWNlRXZlbnRIYW5kbGVyLmdldElucHV0QWN0aW9uKFxuICAgIHNjcmVlblNwYWNlRXZlbnRUeXBlLFxuICAgIG1vZGlmaWVyXG4gICk7XG5cbiAgaWYgKGRlZmluZWQoYWN0aW9uKSkge1xuICAgIGdldFBvc2l0aW9uKHNjcmVlblNwYWNlRXZlbnRIYW5kbGVyLCBldmVudCwgbW91c2VEYmxDbGlja0V2ZW50LnBvc2l0aW9uKTtcblxuICAgIGFjdGlvbihtb3VzZURibENsaWNrRXZlbnQpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGhhbmRsZVdoZWVsKHNjcmVlblNwYWNlRXZlbnRIYW5kbGVyLCBldmVudCkge1xuICAvLyBjdXJyZW50bHkgdGhpcyBldmVudCBleHBvc2VzIHRoZSBkZWx0YSB2YWx1ZSBpbiB0ZXJtcyBvZlxuICAvLyB0aGUgb2Jzb2xldGUgbW91c2V3aGVlbCBldmVudCB0eXBlLiAgc28sIGZvciBub3csIHdlIGFkYXB0IHRoZSBvdGhlclxuICAvLyB2YWx1ZXMgdG8gdGhhdCBzY2hlbWUuXG4gIHZhciBkZWx0YTtcblxuICAvLyBzdGFuZGFyZCB3aGVlbCBldmVudCB1c2VzIGRlbHRhWS4gIHNpZ24gaXMgb3Bwb3NpdGUgd2hlZWxEZWx0YS5cbiAgLy8gZGVsdGFNb2RlIGluZGljYXRlcyB3aGF0IHVuaXQgaXQgaXMgaW4uXG4gIGlmIChkZWZpbmVkKGV2ZW50LmRlbHRhWSkpIHtcbiAgICB2YXIgZGVsdGFNb2RlID0gZXZlbnQuZGVsdGFNb2RlO1xuICAgIGlmIChkZWx0YU1vZGUgPT09IGV2ZW50LkRPTV9ERUxUQV9QSVhFTCkge1xuICAgICAgZGVsdGEgPSAtZXZlbnQuZGVsdGFZO1xuICAgIH0gZWxzZSBpZiAoZGVsdGFNb2RlID09PSBldmVudC5ET01fREVMVEFfTElORSkge1xuICAgICAgZGVsdGEgPSAtZXZlbnQuZGVsdGFZICogNDA7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIERPTV9ERUxUQV9QQUdFXG4gICAgICBkZWx0YSA9IC1ldmVudC5kZWx0YVkgKiAxMjA7XG4gICAgfVxuICB9IGVsc2UgaWYgKGV2ZW50LmRldGFpbCA+IDApIHtcbiAgICAvLyBvbGQgRmlyZWZveCB2ZXJzaW9ucyB1c2UgZXZlbnQuZGV0YWlsIHRvIGNvdW50IHRoZSBudW1iZXIgb2YgY2xpY2tzLiBUaGUgc2lnblxuICAgIC8vIG9mIHRoZSBpbnRlZ2VyIGlzIHRoZSBkaXJlY3Rpb24gdGhlIHdoZWVsIGlzIHNjcm9sbGVkLlxuICAgIGRlbHRhID0gZXZlbnQuZGV0YWlsICogLTEyMDtcbiAgfSBlbHNlIHtcbiAgICBkZWx0YSA9IGV2ZW50LndoZWVsRGVsdGE7XG4gIH1cblxuICBpZiAoIWRlZmluZWQoZGVsdGEpKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIG1vZGlmaWVyID0gZ2V0TW9kaWZpZXIoZXZlbnQpO1xuICB2YXIgYWN0aW9uID0gc2NyZWVuU3BhY2VFdmVudEhhbmRsZXIuZ2V0SW5wdXRBY3Rpb24oXG4gICAgU2NyZWVuU3BhY2VFdmVudFR5cGUuV0hFRUwsXG4gICAgbW9kaWZpZXJcbiAgKTtcblxuICBpZiAoZGVmaW5lZChhY3Rpb24pKSB7XG4gICAgYWN0aW9uKGRlbHRhKTtcblxuICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gaGFuZGxlVG91Y2hTdGFydChzY3JlZW5TcGFjZUV2ZW50SGFuZGxlciwgZXZlbnQpIHtcbiAgZ290VG91Y2hFdmVudChzY3JlZW5TcGFjZUV2ZW50SGFuZGxlcik7XG5cbiAgdmFyIGNoYW5nZWRUb3VjaGVzID0gZXZlbnQuY2hhbmdlZFRvdWNoZXM7XG5cbiAgdmFyIGk7XG4gIHZhciBsZW5ndGggPSBjaGFuZ2VkVG91Y2hlcy5sZW5ndGg7XG4gIHZhciB0b3VjaDtcbiAgdmFyIGlkZW50aWZpZXI7XG4gIHZhciBwb3NpdGlvbnMgPSBzY3JlZW5TcGFjZUV2ZW50SGFuZGxlci5fcG9zaXRpb25zO1xuXG4gIGZvciAoaSA9IDA7IGkgPCBsZW5ndGg7ICsraSkge1xuICAgIHRvdWNoID0gY2hhbmdlZFRvdWNoZXNbaV07XG4gICAgaWRlbnRpZmllciA9IHRvdWNoLmlkZW50aWZpZXI7XG4gICAgcG9zaXRpb25zLnNldChcbiAgICAgIGlkZW50aWZpZXIsXG4gICAgICBnZXRQb3NpdGlvbihzY3JlZW5TcGFjZUV2ZW50SGFuZGxlciwgdG91Y2gsIG5ldyBDYXJ0ZXNpYW4yKCkpXG4gICAgKTtcbiAgfVxuXG4gIGZpcmVUb3VjaEV2ZW50cyhzY3JlZW5TcGFjZUV2ZW50SGFuZGxlciwgZXZlbnQpO1xuXG4gIHZhciBwcmV2aW91c1Bvc2l0aW9ucyA9IHNjcmVlblNwYWNlRXZlbnRIYW5kbGVyLl9wcmV2aW91c1Bvc2l0aW9ucztcblxuICBmb3IgKGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kpIHtcbiAgICB0b3VjaCA9IGNoYW5nZWRUb3VjaGVzW2ldO1xuICAgIGlkZW50aWZpZXIgPSB0b3VjaC5pZGVudGlmaWVyO1xuICAgIHByZXZpb3VzUG9zaXRpb25zLnNldChcbiAgICAgIGlkZW50aWZpZXIsXG4gICAgICBDYXJ0ZXNpYW4yLmNsb25lKHBvc2l0aW9ucy5nZXQoaWRlbnRpZmllcikpXG4gICAgKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBoYW5kbGVUb3VjaEVuZChzY3JlZW5TcGFjZUV2ZW50SGFuZGxlciwgZXZlbnQpIHtcbiAgZ290VG91Y2hFdmVudChzY3JlZW5TcGFjZUV2ZW50SGFuZGxlcik7XG5cbiAgdmFyIGNoYW5nZWRUb3VjaGVzID0gZXZlbnQuY2hhbmdlZFRvdWNoZXM7XG5cbiAgdmFyIGk7XG4gIHZhciBsZW5ndGggPSBjaGFuZ2VkVG91Y2hlcy5sZW5ndGg7XG4gIHZhciB0b3VjaDtcbiAgdmFyIGlkZW50aWZpZXI7XG4gIHZhciBwb3NpdGlvbnMgPSBzY3JlZW5TcGFjZUV2ZW50SGFuZGxlci5fcG9zaXRpb25zO1xuXG4gIGZvciAoaSA9IDA7IGkgPCBsZW5ndGg7ICsraSkge1xuICAgIHRvdWNoID0gY2hhbmdlZFRvdWNoZXNbaV07XG4gICAgaWRlbnRpZmllciA9IHRvdWNoLmlkZW50aWZpZXI7XG4gICAgcG9zaXRpb25zLnJlbW92ZShpZGVudGlmaWVyKTtcbiAgfVxuXG4gIGZpcmVUb3VjaEV2ZW50cyhzY3JlZW5TcGFjZUV2ZW50SGFuZGxlciwgZXZlbnQpO1xuXG4gIHZhciBwcmV2aW91c1Bvc2l0aW9ucyA9IHNjcmVlblNwYWNlRXZlbnRIYW5kbGVyLl9wcmV2aW91c1Bvc2l0aW9ucztcblxuICBmb3IgKGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kpIHtcbiAgICB0b3VjaCA9IGNoYW5nZWRUb3VjaGVzW2ldO1xuICAgIGlkZW50aWZpZXIgPSB0b3VjaC5pZGVudGlmaWVyO1xuICAgIHByZXZpb3VzUG9zaXRpb25zLnJlbW92ZShpZGVudGlmaWVyKTtcbiAgfVxufVxuXG52YXIgdG91Y2hTdGFydEV2ZW50ID0ge1xuICBwb3NpdGlvbjogbmV3IENhcnRlc2lhbjIoKSxcbn07XG52YXIgdG91Y2gyU3RhcnRFdmVudCA9IHtcbiAgcG9zaXRpb24xOiBuZXcgQ2FydGVzaWFuMigpLFxuICBwb3NpdGlvbjI6IG5ldyBDYXJ0ZXNpYW4yKCksXG59O1xudmFyIHRvdWNoRW5kRXZlbnQgPSB7XG4gIHBvc2l0aW9uOiBuZXcgQ2FydGVzaWFuMigpLFxufTtcbnZhciB0b3VjaENsaWNrRXZlbnQgPSB7XG4gIHBvc2l0aW9uOiBuZXcgQ2FydGVzaWFuMigpLFxufTtcbnZhciB0b3VjaEhvbGRFdmVudCA9IHtcbiAgcG9zaXRpb246IG5ldyBDYXJ0ZXNpYW4yKCksXG59O1xuXG5mdW5jdGlvbiBmaXJlVG91Y2hFdmVudHMoc2NyZWVuU3BhY2VFdmVudEhhbmRsZXIsIGV2ZW50KSB7XG4gIHZhciBtb2RpZmllciA9IGdldE1vZGlmaWVyKGV2ZW50KTtcbiAgdmFyIHBvc2l0aW9ucyA9IHNjcmVlblNwYWNlRXZlbnRIYW5kbGVyLl9wb3NpdGlvbnM7XG4gIHZhciBudW1iZXJPZlRvdWNoZXMgPSBwb3NpdGlvbnMubGVuZ3RoO1xuICB2YXIgYWN0aW9uO1xuICB2YXIgY2xpY2tBY3Rpb247XG4gIHZhciBwaW5jaGluZyA9IHNjcmVlblNwYWNlRXZlbnRIYW5kbGVyLl9pc1BpbmNoaW5nO1xuXG4gIGlmIChcbiAgICBudW1iZXJPZlRvdWNoZXMgIT09IDEgJiZcbiAgICBzY3JlZW5TcGFjZUV2ZW50SGFuZGxlci5fYnV0dG9uRG93bltNb3VzZUJ1dHRvbi5MRUZUXVxuICApIHtcbiAgICAvLyB0cmFuc2l0aW9uaW5nIGZyb20gc2luZ2xlIHRvdWNoLCB0cmlnZ2VyIFVQIGFuZCBtaWdodCB0cmlnZ2VyIENMSUNLXG4gICAgc2NyZWVuU3BhY2VFdmVudEhhbmRsZXIuX2J1dHRvbkRvd25bTW91c2VCdXR0b24uTEVGVF0gPSBmYWxzZTtcblxuICAgIGlmIChkZWZpbmVkKHNjcmVlblNwYWNlRXZlbnRIYW5kbGVyLl90b3VjaEhvbGRUaW1lcikpIHtcbiAgICAgIGNsZWFyVGltZW91dChzY3JlZW5TcGFjZUV2ZW50SGFuZGxlci5fdG91Y2hIb2xkVGltZXIpO1xuICAgICAgc2NyZWVuU3BhY2VFdmVudEhhbmRsZXIuX3RvdWNoSG9sZFRpbWVyID0gdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIGFjdGlvbiA9IHNjcmVlblNwYWNlRXZlbnRIYW5kbGVyLmdldElucHV0QWN0aW9uKFxuICAgICAgU2NyZWVuU3BhY2VFdmVudFR5cGUuTEVGVF9VUCxcbiAgICAgIG1vZGlmaWVyXG4gICAgKTtcblxuICAgIGlmIChkZWZpbmVkKGFjdGlvbikpIHtcbiAgICAgIENhcnRlc2lhbjIuY2xvbmUoXG4gICAgICAgIHNjcmVlblNwYWNlRXZlbnRIYW5kbGVyLl9wcmltYXJ5UG9zaXRpb24sXG4gICAgICAgIHRvdWNoRW5kRXZlbnQucG9zaXRpb25cbiAgICAgICk7XG5cbiAgICAgIGFjdGlvbih0b3VjaEVuZEV2ZW50KTtcbiAgICB9XG5cbiAgICBpZiAobnVtYmVyT2ZUb3VjaGVzID09PSAwICYmICFzY3JlZW5TcGFjZUV2ZW50SGFuZGxlci5faXNUb3VjaEhvbGRpbmcpIHtcbiAgICAgIC8vIHJlbGVhc2luZyBzaW5nbGUgdG91Y2gsIGNoZWNrIGZvciBDTElDS1xuICAgICAgY2xpY2tBY3Rpb24gPSBzY3JlZW5TcGFjZUV2ZW50SGFuZGxlci5nZXRJbnB1dEFjdGlvbihcbiAgICAgICAgU2NyZWVuU3BhY2VFdmVudFR5cGUuTEVGVF9DTElDSyxcbiAgICAgICAgbW9kaWZpZXJcbiAgICAgICk7XG5cbiAgICAgIGlmIChkZWZpbmVkKGNsaWNrQWN0aW9uKSkge1xuICAgICAgICB2YXIgc3RhcnRQb3NpdGlvbiA9IHNjcmVlblNwYWNlRXZlbnRIYW5kbGVyLl9wcmltYXJ5U3RhcnRQb3NpdGlvbjtcbiAgICAgICAgdmFyIGVuZFBvc2l0aW9uID0gc2NyZWVuU3BhY2VFdmVudEhhbmRsZXIuX3ByZXZpb3VzUG9zaXRpb25zLnZhbHVlc1swXTtcbiAgICAgICAgaWYgKFxuICAgICAgICAgIGNoZWNrUGl4ZWxUb2xlcmFuY2UoXG4gICAgICAgICAgICBzdGFydFBvc2l0aW9uLFxuICAgICAgICAgICAgZW5kUG9zaXRpb24sXG4gICAgICAgICAgICBzY3JlZW5TcGFjZUV2ZW50SGFuZGxlci5fY2xpY2tQaXhlbFRvbGVyYW5jZVxuICAgICAgICAgIClcbiAgICAgICAgKSB7XG4gICAgICAgICAgQ2FydGVzaWFuMi5jbG9uZShcbiAgICAgICAgICAgIHNjcmVlblNwYWNlRXZlbnRIYW5kbGVyLl9wcmltYXJ5UG9zaXRpb24sXG4gICAgICAgICAgICB0b3VjaENsaWNrRXZlbnQucG9zaXRpb25cbiAgICAgICAgICApO1xuXG4gICAgICAgICAgY2xpY2tBY3Rpb24odG91Y2hDbGlja0V2ZW50KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHNjcmVlblNwYWNlRXZlbnRIYW5kbGVyLl9pc1RvdWNoSG9sZGluZyA9IGZhbHNlO1xuXG4gICAgLy8gT3RoZXJ3aXNlIGRvbid0IHRyaWdnZXIgQ0xJQ0ssIGJlY2F1c2Ugd2UgYXJlIGFkZGluZyBtb3JlIHRvdWNoZXMuXG4gIH1cblxuICBpZiAobnVtYmVyT2ZUb3VjaGVzID09PSAwICYmIHBpbmNoaW5nKSB7XG4gICAgLy8gdHJhbnNpdGlvbmluZyBmcm9tIHBpbmNoLCB0cmlnZ2VyIFBJTkNIX0VORFxuICAgIHNjcmVlblNwYWNlRXZlbnRIYW5kbGVyLl9pc1BpbmNoaW5nID0gZmFsc2U7XG5cbiAgICBhY3Rpb24gPSBzY3JlZW5TcGFjZUV2ZW50SGFuZGxlci5nZXRJbnB1dEFjdGlvbihcbiAgICAgIFNjcmVlblNwYWNlRXZlbnRUeXBlLlBJTkNIX0VORCxcbiAgICAgIG1vZGlmaWVyXG4gICAgKTtcblxuICAgIGlmIChkZWZpbmVkKGFjdGlvbikpIHtcbiAgICAgIGFjdGlvbigpO1xuICAgIH1cbiAgfVxuXG4gIGlmIChudW1iZXJPZlRvdWNoZXMgPT09IDEgJiYgIXBpbmNoaW5nKSB7XG4gICAgLy8gdHJhbnNpdGlvbmluZyB0byBzaW5nbGUgdG91Y2gsIHRyaWdnZXIgRE9XTlxuICAgIHZhciBwb3NpdGlvbiA9IHBvc2l0aW9ucy52YWx1ZXNbMF07XG4gICAgQ2FydGVzaWFuMi5jbG9uZShwb3NpdGlvbiwgc2NyZWVuU3BhY2VFdmVudEhhbmRsZXIuX3ByaW1hcnlQb3NpdGlvbik7XG4gICAgQ2FydGVzaWFuMi5jbG9uZShwb3NpdGlvbiwgc2NyZWVuU3BhY2VFdmVudEhhbmRsZXIuX3ByaW1hcnlTdGFydFBvc2l0aW9uKTtcbiAgICBDYXJ0ZXNpYW4yLmNsb25lKFxuICAgICAgcG9zaXRpb24sXG4gICAgICBzY3JlZW5TcGFjZUV2ZW50SGFuZGxlci5fcHJpbWFyeVByZXZpb3VzUG9zaXRpb25cbiAgICApO1xuXG4gICAgc2NyZWVuU3BhY2VFdmVudEhhbmRsZXIuX2J1dHRvbkRvd25bTW91c2VCdXR0b24uTEVGVF0gPSB0cnVlO1xuXG4gICAgYWN0aW9uID0gc2NyZWVuU3BhY2VFdmVudEhhbmRsZXIuZ2V0SW5wdXRBY3Rpb24oXG4gICAgICBTY3JlZW5TcGFjZUV2ZW50VHlwZS5MRUZUX0RPV04sXG4gICAgICBtb2RpZmllclxuICAgICk7XG5cbiAgICBpZiAoZGVmaW5lZChhY3Rpb24pKSB7XG4gICAgICBDYXJ0ZXNpYW4yLmNsb25lKHBvc2l0aW9uLCB0b3VjaFN0YXJ0RXZlbnQucG9zaXRpb24pO1xuXG4gICAgICBhY3Rpb24odG91Y2hTdGFydEV2ZW50KTtcbiAgICB9XG5cbiAgICBzY3JlZW5TcGFjZUV2ZW50SGFuZGxlci5fdG91Y2hIb2xkVGltZXIgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmICghc2NyZWVuU3BhY2VFdmVudEhhbmRsZXIuaXNEZXN0cm95ZWQoKSkge1xuICAgICAgICBzY3JlZW5TcGFjZUV2ZW50SGFuZGxlci5fdG91Y2hIb2xkVGltZXIgPSB1bmRlZmluZWQ7XG4gICAgICAgIHNjcmVlblNwYWNlRXZlbnRIYW5kbGVyLl9pc1RvdWNoSG9sZGluZyA9IHRydWU7XG5cbiAgICAgICAgY2xpY2tBY3Rpb24gPSBzY3JlZW5TcGFjZUV2ZW50SGFuZGxlci5nZXRJbnB1dEFjdGlvbihcbiAgICAgICAgICBTY3JlZW5TcGFjZUV2ZW50VHlwZS5SSUdIVF9DTElDSyxcbiAgICAgICAgICBtb2RpZmllclxuICAgICAgICApO1xuXG4gICAgICAgIGlmIChkZWZpbmVkKGNsaWNrQWN0aW9uKSkge1xuICAgICAgICAgIHZhciBzdGFydFBvc2l0aW9uID0gc2NyZWVuU3BhY2VFdmVudEhhbmRsZXIuX3ByaW1hcnlTdGFydFBvc2l0aW9uO1xuICAgICAgICAgIHZhciBlbmRQb3NpdGlvbiA9XG4gICAgICAgICAgICBzY3JlZW5TcGFjZUV2ZW50SGFuZGxlci5fcHJldmlvdXNQb3NpdGlvbnMudmFsdWVzWzBdO1xuICAgICAgICAgIGlmIChcbiAgICAgICAgICAgIGNoZWNrUGl4ZWxUb2xlcmFuY2UoXG4gICAgICAgICAgICAgIHN0YXJ0UG9zaXRpb24sXG4gICAgICAgICAgICAgIGVuZFBvc2l0aW9uLFxuICAgICAgICAgICAgICBzY3JlZW5TcGFjZUV2ZW50SGFuZGxlci5faG9sZFBpeGVsVG9sZXJhbmNlXG4gICAgICAgICAgICApXG4gICAgICAgICAgKSB7XG4gICAgICAgICAgICBDYXJ0ZXNpYW4yLmNsb25lKFxuICAgICAgICAgICAgICBzY3JlZW5TcGFjZUV2ZW50SGFuZGxlci5fcHJpbWFyeVBvc2l0aW9uLFxuICAgICAgICAgICAgICB0b3VjaEhvbGRFdmVudC5wb3NpdGlvblxuICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgY2xpY2tBY3Rpb24odG91Y2hIb2xkRXZlbnQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sIFNjcmVlblNwYWNlRXZlbnRIYW5kbGVyLnRvdWNoSG9sZERlbGF5TWlsbGlzZWNvbmRzKTtcblxuICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gIH1cblxuICBpZiAobnVtYmVyT2ZUb3VjaGVzID09PSAyICYmICFwaW5jaGluZykge1xuICAgIC8vIHRyYW5zaXRpb25pbmcgdG8gcGluY2gsIHRyaWdnZXIgUElOQ0hfU1RBUlRcbiAgICBzY3JlZW5TcGFjZUV2ZW50SGFuZGxlci5faXNQaW5jaGluZyA9IHRydWU7XG5cbiAgICBhY3Rpb24gPSBzY3JlZW5TcGFjZUV2ZW50SGFuZGxlci5nZXRJbnB1dEFjdGlvbihcbiAgICAgIFNjcmVlblNwYWNlRXZlbnRUeXBlLlBJTkNIX1NUQVJULFxuICAgICAgbW9kaWZpZXJcbiAgICApO1xuXG4gICAgaWYgKGRlZmluZWQoYWN0aW9uKSkge1xuICAgICAgQ2FydGVzaWFuMi5jbG9uZShwb3NpdGlvbnMudmFsdWVzWzBdLCB0b3VjaDJTdGFydEV2ZW50LnBvc2l0aW9uMSk7XG4gICAgICBDYXJ0ZXNpYW4yLmNsb25lKHBvc2l0aW9ucy52YWx1ZXNbMV0sIHRvdWNoMlN0YXJ0RXZlbnQucG9zaXRpb24yKTtcblxuICAgICAgYWN0aW9uKHRvdWNoMlN0YXJ0RXZlbnQpO1xuXG4gICAgICAvLyBUb3VjaC1lbmFibGVkIGRldmljZXMsIGluIHBhcnRpY3VsYXIgaU9TIGNhbiBoYXZlIG1hbnkgZGVmYXVsdCBiZWhhdmlvdXJzIGZvclxuICAgICAgLy8gXCJwaW5jaFwiIGV2ZW50cywgd2hpY2ggY2FuIHN0aWxsIGJlIGV4ZWN1dGVkIHVubGVzcyB3ZSBwcmV2ZW50IHRoZW0gaGVyZS5cbiAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGhhbmRsZVRvdWNoTW92ZShzY3JlZW5TcGFjZUV2ZW50SGFuZGxlciwgZXZlbnQpIHtcbiAgZ290VG91Y2hFdmVudChzY3JlZW5TcGFjZUV2ZW50SGFuZGxlcik7XG5cbiAgdmFyIGNoYW5nZWRUb3VjaGVzID0gZXZlbnQuY2hhbmdlZFRvdWNoZXM7XG5cbiAgdmFyIGk7XG4gIHZhciBsZW5ndGggPSBjaGFuZ2VkVG91Y2hlcy5sZW5ndGg7XG4gIHZhciB0b3VjaDtcbiAgdmFyIGlkZW50aWZpZXI7XG4gIHZhciBwb3NpdGlvbnMgPSBzY3JlZW5TcGFjZUV2ZW50SGFuZGxlci5fcG9zaXRpb25zO1xuXG4gIGZvciAoaSA9IDA7IGkgPCBsZW5ndGg7ICsraSkge1xuICAgIHRvdWNoID0gY2hhbmdlZFRvdWNoZXNbaV07XG4gICAgaWRlbnRpZmllciA9IHRvdWNoLmlkZW50aWZpZXI7XG4gICAgdmFyIHBvc2l0aW9uID0gcG9zaXRpb25zLmdldChpZGVudGlmaWVyKTtcbiAgICBpZiAoZGVmaW5lZChwb3NpdGlvbikpIHtcbiAgICAgIGdldFBvc2l0aW9uKHNjcmVlblNwYWNlRXZlbnRIYW5kbGVyLCB0b3VjaCwgcG9zaXRpb24pO1xuICAgIH1cbiAgfVxuXG4gIGZpcmVUb3VjaE1vdmVFdmVudHMoc2NyZWVuU3BhY2VFdmVudEhhbmRsZXIsIGV2ZW50KTtcblxuICB2YXIgcHJldmlvdXNQb3NpdGlvbnMgPSBzY3JlZW5TcGFjZUV2ZW50SGFuZGxlci5fcHJldmlvdXNQb3NpdGlvbnM7XG5cbiAgZm9yIChpID0gMDsgaSA8IGxlbmd0aDsgKytpKSB7XG4gICAgdG91Y2ggPSBjaGFuZ2VkVG91Y2hlc1tpXTtcbiAgICBpZGVudGlmaWVyID0gdG91Y2guaWRlbnRpZmllcjtcbiAgICBDYXJ0ZXNpYW4yLmNsb25lKFxuICAgICAgcG9zaXRpb25zLmdldChpZGVudGlmaWVyKSxcbiAgICAgIHByZXZpb3VzUG9zaXRpb25zLmdldChpZGVudGlmaWVyKVxuICAgICk7XG4gIH1cbn1cblxudmFyIHRvdWNoTW92ZUV2ZW50ID0ge1xuICBzdGFydFBvc2l0aW9uOiBuZXcgQ2FydGVzaWFuMigpLFxuICBlbmRQb3NpdGlvbjogbmV3IENhcnRlc2lhbjIoKSxcbn07XG52YXIgdG91Y2hQaW5jaE1vdmVtZW50RXZlbnQgPSB7XG4gIGRpc3RhbmNlOiB7XG4gICAgc3RhcnRQb3NpdGlvbjogbmV3IENhcnRlc2lhbjIoKSxcbiAgICBlbmRQb3NpdGlvbjogbmV3IENhcnRlc2lhbjIoKSxcbiAgfSxcbiAgYW5nbGVBbmRIZWlnaHQ6IHtcbiAgICBzdGFydFBvc2l0aW9uOiBuZXcgQ2FydGVzaWFuMigpLFxuICAgIGVuZFBvc2l0aW9uOiBuZXcgQ2FydGVzaWFuMigpLFxuICB9LFxufTtcblxuZnVuY3Rpb24gZmlyZVRvdWNoTW92ZUV2ZW50cyhzY3JlZW5TcGFjZUV2ZW50SGFuZGxlciwgZXZlbnQpIHtcbiAgdmFyIG1vZGlmaWVyID0gZ2V0TW9kaWZpZXIoZXZlbnQpO1xuICB2YXIgcG9zaXRpb25zID0gc2NyZWVuU3BhY2VFdmVudEhhbmRsZXIuX3Bvc2l0aW9ucztcbiAgdmFyIHByZXZpb3VzUG9zaXRpb25zID0gc2NyZWVuU3BhY2VFdmVudEhhbmRsZXIuX3ByZXZpb3VzUG9zaXRpb25zO1xuICB2YXIgbnVtYmVyT2ZUb3VjaGVzID0gcG9zaXRpb25zLmxlbmd0aDtcbiAgdmFyIGFjdGlvbjtcblxuICBpZiAoXG4gICAgbnVtYmVyT2ZUb3VjaGVzID09PSAxICYmXG4gICAgc2NyZWVuU3BhY2VFdmVudEhhbmRsZXIuX2J1dHRvbkRvd25bTW91c2VCdXR0b24uTEVGVF1cbiAgKSB7XG4gICAgLy8gbW92aW5nIHNpbmdsZSB0b3VjaFxuICAgIHZhciBwb3NpdGlvbiA9IHBvc2l0aW9ucy52YWx1ZXNbMF07XG4gICAgQ2FydGVzaWFuMi5jbG9uZShwb3NpdGlvbiwgc2NyZWVuU3BhY2VFdmVudEhhbmRsZXIuX3ByaW1hcnlQb3NpdGlvbik7XG5cbiAgICB2YXIgcHJldmlvdXNQb3NpdGlvbiA9IHNjcmVlblNwYWNlRXZlbnRIYW5kbGVyLl9wcmltYXJ5UHJldmlvdXNQb3NpdGlvbjtcblxuICAgIGFjdGlvbiA9IHNjcmVlblNwYWNlRXZlbnRIYW5kbGVyLmdldElucHV0QWN0aW9uKFxuICAgICAgU2NyZWVuU3BhY2VFdmVudFR5cGUuTU9VU0VfTU9WRSxcbiAgICAgIG1vZGlmaWVyXG4gICAgKTtcblxuICAgIGlmIChkZWZpbmVkKGFjdGlvbikpIHtcbiAgICAgIENhcnRlc2lhbjIuY2xvbmUocHJldmlvdXNQb3NpdGlvbiwgdG91Y2hNb3ZlRXZlbnQuc3RhcnRQb3NpdGlvbik7XG4gICAgICBDYXJ0ZXNpYW4yLmNsb25lKHBvc2l0aW9uLCB0b3VjaE1vdmVFdmVudC5lbmRQb3NpdGlvbik7XG5cbiAgICAgIGFjdGlvbih0b3VjaE1vdmVFdmVudCk7XG4gICAgfVxuXG4gICAgQ2FydGVzaWFuMi5jbG9uZShwb3NpdGlvbiwgcHJldmlvdXNQb3NpdGlvbik7XG5cbiAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICB9IGVsc2UgaWYgKG51bWJlck9mVG91Y2hlcyA9PT0gMiAmJiBzY3JlZW5TcGFjZUV2ZW50SGFuZGxlci5faXNQaW5jaGluZykge1xuICAgIC8vIG1vdmluZyBwaW5jaFxuXG4gICAgYWN0aW9uID0gc2NyZWVuU3BhY2VFdmVudEhhbmRsZXIuZ2V0SW5wdXRBY3Rpb24oXG4gICAgICBTY3JlZW5TcGFjZUV2ZW50VHlwZS5QSU5DSF9NT1ZFLFxuICAgICAgbW9kaWZpZXJcbiAgICApO1xuICAgIGlmIChkZWZpbmVkKGFjdGlvbikpIHtcbiAgICAgIHZhciBwb3NpdGlvbjEgPSBwb3NpdGlvbnMudmFsdWVzWzBdO1xuICAgICAgdmFyIHBvc2l0aW9uMiA9IHBvc2l0aW9ucy52YWx1ZXNbMV07XG4gICAgICB2YXIgcHJldmlvdXNQb3NpdGlvbjEgPSBwcmV2aW91c1Bvc2l0aW9ucy52YWx1ZXNbMF07XG4gICAgICB2YXIgcHJldmlvdXNQb3NpdGlvbjIgPSBwcmV2aW91c1Bvc2l0aW9ucy52YWx1ZXNbMV07XG5cbiAgICAgIHZhciBkWCA9IHBvc2l0aW9uMi54IC0gcG9zaXRpb24xLng7XG4gICAgICB2YXIgZFkgPSBwb3NpdGlvbjIueSAtIHBvc2l0aW9uMS55O1xuICAgICAgdmFyIGRpc3QgPSBNYXRoLnNxcnQoZFggKiBkWCArIGRZICogZFkpICogMC4yNTtcblxuICAgICAgdmFyIHByZXZEWCA9IHByZXZpb3VzUG9zaXRpb24yLnggLSBwcmV2aW91c1Bvc2l0aW9uMS54O1xuICAgICAgdmFyIHByZXZEWSA9IHByZXZpb3VzUG9zaXRpb24yLnkgLSBwcmV2aW91c1Bvc2l0aW9uMS55O1xuICAgICAgdmFyIHByZXZEaXN0ID0gTWF0aC5zcXJ0KHByZXZEWCAqIHByZXZEWCArIHByZXZEWSAqIHByZXZEWSkgKiAwLjI1O1xuXG4gICAgICB2YXIgY1kgPSAocG9zaXRpb24yLnkgKyBwb3NpdGlvbjEueSkgKiAwLjEyNTtcbiAgICAgIHZhciBwcmV2Q1kgPSAocHJldmlvdXNQb3NpdGlvbjIueSArIHByZXZpb3VzUG9zaXRpb24xLnkpICogMC4xMjU7XG4gICAgICB2YXIgYW5nbGUgPSBNYXRoLmF0YW4yKGRZLCBkWCk7XG4gICAgICB2YXIgcHJldkFuZ2xlID0gTWF0aC5hdGFuMihwcmV2RFksIHByZXZEWCk7XG5cbiAgICAgIENhcnRlc2lhbjIuZnJvbUVsZW1lbnRzKFxuICAgICAgICAwLjAsXG4gICAgICAgIHByZXZEaXN0LFxuICAgICAgICB0b3VjaFBpbmNoTW92ZW1lbnRFdmVudC5kaXN0YW5jZS5zdGFydFBvc2l0aW9uXG4gICAgICApO1xuICAgICAgQ2FydGVzaWFuMi5mcm9tRWxlbWVudHMoXG4gICAgICAgIDAuMCxcbiAgICAgICAgZGlzdCxcbiAgICAgICAgdG91Y2hQaW5jaE1vdmVtZW50RXZlbnQuZGlzdGFuY2UuZW5kUG9zaXRpb25cbiAgICAgICk7XG5cbiAgICAgIENhcnRlc2lhbjIuZnJvbUVsZW1lbnRzKFxuICAgICAgICBwcmV2QW5nbGUsXG4gICAgICAgIHByZXZDWSxcbiAgICAgICAgdG91Y2hQaW5jaE1vdmVtZW50RXZlbnQuYW5nbGVBbmRIZWlnaHQuc3RhcnRQb3NpdGlvblxuICAgICAgKTtcbiAgICAgIENhcnRlc2lhbjIuZnJvbUVsZW1lbnRzKFxuICAgICAgICBhbmdsZSxcbiAgICAgICAgY1ksXG4gICAgICAgIHRvdWNoUGluY2hNb3ZlbWVudEV2ZW50LmFuZ2xlQW5kSGVpZ2h0LmVuZFBvc2l0aW9uXG4gICAgICApO1xuXG4gICAgICBhY3Rpb24odG91Y2hQaW5jaE1vdmVtZW50RXZlbnQpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBoYW5kbGVQb2ludGVyRG93bihzY3JlZW5TcGFjZUV2ZW50SGFuZGxlciwgZXZlbnQpIHtcbiAgZXZlbnQudGFyZ2V0LnNldFBvaW50ZXJDYXB0dXJlKGV2ZW50LnBvaW50ZXJJZCk7XG5cbiAgaWYgKGV2ZW50LnBvaW50ZXJUeXBlID09PSBcInRvdWNoXCIpIHtcbiAgICB2YXIgcG9zaXRpb25zID0gc2NyZWVuU3BhY2VFdmVudEhhbmRsZXIuX3Bvc2l0aW9ucztcblxuICAgIHZhciBpZGVudGlmaWVyID0gZXZlbnQucG9pbnRlcklkO1xuICAgIHBvc2l0aW9ucy5zZXQoXG4gICAgICBpZGVudGlmaWVyLFxuICAgICAgZ2V0UG9zaXRpb24oc2NyZWVuU3BhY2VFdmVudEhhbmRsZXIsIGV2ZW50LCBuZXcgQ2FydGVzaWFuMigpKVxuICAgICk7XG5cbiAgICBmaXJlVG91Y2hFdmVudHMoc2NyZWVuU3BhY2VFdmVudEhhbmRsZXIsIGV2ZW50KTtcblxuICAgIHZhciBwcmV2aW91c1Bvc2l0aW9ucyA9IHNjcmVlblNwYWNlRXZlbnRIYW5kbGVyLl9wcmV2aW91c1Bvc2l0aW9ucztcbiAgICBwcmV2aW91c1Bvc2l0aW9ucy5zZXQoXG4gICAgICBpZGVudGlmaWVyLFxuICAgICAgQ2FydGVzaWFuMi5jbG9uZShwb3NpdGlvbnMuZ2V0KGlkZW50aWZpZXIpKVxuICAgICk7XG4gIH0gZWxzZSB7XG4gICAgaGFuZGxlTW91c2VEb3duKHNjcmVlblNwYWNlRXZlbnRIYW5kbGVyLCBldmVudCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gaGFuZGxlUG9pbnRlclVwKHNjcmVlblNwYWNlRXZlbnRIYW5kbGVyLCBldmVudCkge1xuICBpZiAoZXZlbnQucG9pbnRlclR5cGUgPT09IFwidG91Y2hcIikge1xuICAgIHZhciBwb3NpdGlvbnMgPSBzY3JlZW5TcGFjZUV2ZW50SGFuZGxlci5fcG9zaXRpb25zO1xuXG4gICAgdmFyIGlkZW50aWZpZXIgPSBldmVudC5wb2ludGVySWQ7XG4gICAgcG9zaXRpb25zLnJlbW92ZShpZGVudGlmaWVyKTtcblxuICAgIGZpcmVUb3VjaEV2ZW50cyhzY3JlZW5TcGFjZUV2ZW50SGFuZGxlciwgZXZlbnQpO1xuXG4gICAgdmFyIHByZXZpb3VzUG9zaXRpb25zID0gc2NyZWVuU3BhY2VFdmVudEhhbmRsZXIuX3ByZXZpb3VzUG9zaXRpb25zO1xuICAgIHByZXZpb3VzUG9zaXRpb25zLnJlbW92ZShpZGVudGlmaWVyKTtcbiAgfSBlbHNlIHtcbiAgICBoYW5kbGVNb3VzZVVwKHNjcmVlblNwYWNlRXZlbnRIYW5kbGVyLCBldmVudCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gaGFuZGxlUG9pbnRlck1vdmUoc2NyZWVuU3BhY2VFdmVudEhhbmRsZXIsIGV2ZW50KSB7XG4gIGlmIChldmVudC5wb2ludGVyVHlwZSA9PT0gXCJ0b3VjaFwiKSB7XG4gICAgdmFyIHBvc2l0aW9ucyA9IHNjcmVlblNwYWNlRXZlbnRIYW5kbGVyLl9wb3NpdGlvbnM7XG5cbiAgICB2YXIgaWRlbnRpZmllciA9IGV2ZW50LnBvaW50ZXJJZDtcbiAgICB2YXIgcG9zaXRpb24gPSBwb3NpdGlvbnMuZ2V0KGlkZW50aWZpZXIpO1xuICAgIGlmICghZGVmaW5lZChwb3NpdGlvbikpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBnZXRQb3NpdGlvbihzY3JlZW5TcGFjZUV2ZW50SGFuZGxlciwgZXZlbnQsIHBvc2l0aW9uKTtcbiAgICBmaXJlVG91Y2hNb3ZlRXZlbnRzKHNjcmVlblNwYWNlRXZlbnRIYW5kbGVyLCBldmVudCk7XG5cbiAgICB2YXIgcHJldmlvdXNQb3NpdGlvbnMgPSBzY3JlZW5TcGFjZUV2ZW50SGFuZGxlci5fcHJldmlvdXNQb3NpdGlvbnM7XG4gICAgQ2FydGVzaWFuMi5jbG9uZShcbiAgICAgIHBvc2l0aW9ucy5nZXQoaWRlbnRpZmllciksXG4gICAgICBwcmV2aW91c1Bvc2l0aW9ucy5nZXQoaWRlbnRpZmllcilcbiAgICApO1xuICB9IGVsc2Uge1xuICAgIGhhbmRsZU1vdXNlTW92ZShzY3JlZW5TcGFjZUV2ZW50SGFuZGxlciwgZXZlbnQpO1xuICB9XG59XG5cbi8qKlxuICogSGFuZGxlcyB1c2VyIGlucHV0IGV2ZW50cy4gQ3VzdG9tIGZ1bmN0aW9ucyBjYW4gYmUgYWRkZWQgdG8gYmUgZXhlY3V0ZWQgb25cbiAqIHdoZW4gdGhlIHVzZXIgZW50ZXJzIGlucHV0LlxuICpcbiAqIEBhbGlhcyBTY3JlZW5TcGFjZUV2ZW50SGFuZGxlclxuICpcbiAqIEBwYXJhbSB7SFRNTENhbnZhc0VsZW1lbnR9IFtlbGVtZW50PWRvY3VtZW50XSBUaGUgZWxlbWVudCB0byBhZGQgZXZlbnRzIHRvLlxuICpcbiAqIEBjb25zdHJ1Y3RvclxuICovXG5mdW5jdGlvbiBTY3JlZW5TcGFjZUV2ZW50SGFuZGxlcihlbGVtZW50KSB7XG4gIHRoaXMuX2lucHV0RXZlbnRzID0ge307XG4gIHRoaXMuX2J1dHRvbkRvd24gPSB7XG4gICAgTEVGVDogZmFsc2UsXG4gICAgTUlERExFOiBmYWxzZSxcbiAgICBSSUdIVDogZmFsc2UsXG4gIH07XG4gIHRoaXMuX2lzUGluY2hpbmcgPSBmYWxzZTtcbiAgdGhpcy5faXNUb3VjaEhvbGRpbmcgPSBmYWxzZTtcbiAgdGhpcy5fbGFzdFNlZW5Ub3VjaEV2ZW50ID0gLVNjcmVlblNwYWNlRXZlbnRIYW5kbGVyLm1vdXNlRW11bGF0aW9uSWdub3JlTWlsbGlzZWNvbmRzO1xuXG4gIHRoaXMuX3ByaW1hcnlTdGFydFBvc2l0aW9uID0gbmV3IENhcnRlc2lhbjIoKTtcbiAgdGhpcy5fcHJpbWFyeVBvc2l0aW9uID0gbmV3IENhcnRlc2lhbjIoKTtcbiAgdGhpcy5fcHJpbWFyeVByZXZpb3VzUG9zaXRpb24gPSBuZXcgQ2FydGVzaWFuMigpO1xuXG4gIHRoaXMuX3Bvc2l0aW9ucyA9IG5ldyBBc3NvY2lhdGl2ZUFycmF5KCk7XG4gIHRoaXMuX3ByZXZpb3VzUG9zaXRpb25zID0gbmV3IEFzc29jaWF0aXZlQXJyYXkoKTtcblxuICB0aGlzLl9yZW1vdmFsRnVuY3Rpb25zID0gW107XG5cbiAgdGhpcy5fdG91Y2hIb2xkVGltZXIgPSB1bmRlZmluZWQ7XG5cbiAgLy8gVE9ETzogUmV2aXNpdCB3aGVuIGRvaW5nIG1vYmlsZSBkZXZlbG9wbWVudC4gTWF5IG5lZWQgdG8gYmUgY29uZmlndXJhYmxlXG4gIC8vIG9yIGRldGVybWluZWQgYmFzZWQgb24gdGhlIHBsYXRmb3JtP1xuICB0aGlzLl9jbGlja1BpeGVsVG9sZXJhbmNlID0gNTtcbiAgdGhpcy5faG9sZFBpeGVsVG9sZXJhbmNlID0gMjU7XG5cbiAgdGhpcy5fZWxlbWVudCA9IGRlZmF1bHRWYWx1ZShlbGVtZW50LCBkb2N1bWVudCk7XG5cbiAgcmVnaXN0ZXJMaXN0ZW5lcnModGhpcyk7XG59XG5cbi8qKlxuICogU2V0IGEgZnVuY3Rpb24gdG8gYmUgZXhlY3V0ZWQgb24gYW4gaW5wdXQgZXZlbnQuXG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gYWN0aW9uIEZ1bmN0aW9uIHRvIGJlIGV4ZWN1dGVkIHdoZW4gdGhlIGlucHV0IGV2ZW50IG9jY3Vycy5cbiAqIEBwYXJhbSB7TnVtYmVyfSB0eXBlIFRoZSBTY3JlZW5TcGFjZUV2ZW50VHlwZSBvZiBpbnB1dCBldmVudC5cbiAqIEBwYXJhbSB7TnVtYmVyfSBbbW9kaWZpZXJdIEEgS2V5Ym9hcmRFdmVudE1vZGlmaWVyIGtleSB0aGF0IGlzIGhlbGQgd2hlbiBhIDxjb2RlPnR5cGU8L2NvZGU+XG4gKiBldmVudCBvY2N1cnMuXG4gKlxuICogQHNlZSBTY3JlZW5TcGFjZUV2ZW50SGFuZGxlciNnZXRJbnB1dEFjdGlvblxuICogQHNlZSBTY3JlZW5TcGFjZUV2ZW50SGFuZGxlciNyZW1vdmVJbnB1dEFjdGlvblxuICovXG5TY3JlZW5TcGFjZUV2ZW50SGFuZGxlci5wcm90b3R5cGUuc2V0SW5wdXRBY3Rpb24gPSBmdW5jdGlvbiAoXG4gIGFjdGlvbixcbiAgdHlwZSxcbiAgbW9kaWZpZXJcbikge1xuICAvLz4+aW5jbHVkZVN0YXJ0KCdkZWJ1ZycsIHByYWdtYXMuZGVidWcpO1xuICBpZiAoIWRlZmluZWQoYWN0aW9uKSkge1xuICAgIHRocm93IG5ldyBEZXZlbG9wZXJFcnJvcihcImFjdGlvbiBpcyByZXF1aXJlZC5cIik7XG4gIH1cbiAgaWYgKCFkZWZpbmVkKHR5cGUpKSB7XG4gICAgdGhyb3cgbmV3IERldmVsb3BlckVycm9yKFwidHlwZSBpcyByZXF1aXJlZC5cIik7XG4gIH1cbiAgLy8+PmluY2x1ZGVFbmQoJ2RlYnVnJyk7XG5cbiAgdmFyIGtleSA9IGdldElucHV0RXZlbnRLZXkodHlwZSwgbW9kaWZpZXIpO1xuICB0aGlzLl9pbnB1dEV2ZW50c1trZXldID0gYWN0aW9uO1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBmdW5jdGlvbiB0byBiZSBleGVjdXRlZCBvbiBhbiBpbnB1dCBldmVudC5cbiAqXG4gKiBAcGFyYW0ge051bWJlcn0gdHlwZSBUaGUgU2NyZWVuU3BhY2VFdmVudFR5cGUgb2YgaW5wdXQgZXZlbnQuXG4gKiBAcGFyYW0ge051bWJlcn0gW21vZGlmaWVyXSBBIEtleWJvYXJkRXZlbnRNb2RpZmllciBrZXkgdGhhdCBpcyBoZWxkIHdoZW4gYSA8Y29kZT50eXBlPC9jb2RlPlxuICogZXZlbnQgb2NjdXJzLlxuICpcbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gVGhlIGZ1bmN0aW9uIHRvIGJlIGV4ZWN1dGVkIG9uIGFuIGlucHV0IGV2ZW50LlxuICpcbiAqIEBzZWUgU2NyZWVuU3BhY2VFdmVudEhhbmRsZXIjc2V0SW5wdXRBY3Rpb25cbiAqIEBzZWUgU2NyZWVuU3BhY2VFdmVudEhhbmRsZXIjcmVtb3ZlSW5wdXRBY3Rpb25cbiAqL1xuU2NyZWVuU3BhY2VFdmVudEhhbmRsZXIucHJvdG90eXBlLmdldElucHV0QWN0aW9uID0gZnVuY3Rpb24gKHR5cGUsIG1vZGlmaWVyKSB7XG4gIC8vPj5pbmNsdWRlU3RhcnQoJ2RlYnVnJywgcHJhZ21hcy5kZWJ1Zyk7XG4gIGlmICghZGVmaW5lZCh0eXBlKSkge1xuICAgIHRocm93IG5ldyBEZXZlbG9wZXJFcnJvcihcInR5cGUgaXMgcmVxdWlyZWQuXCIpO1xuICB9XG4gIC8vPj5pbmNsdWRlRW5kKCdkZWJ1ZycpO1xuXG4gIHZhciBrZXkgPSBnZXRJbnB1dEV2ZW50S2V5KHR5cGUsIG1vZGlmaWVyKTtcbiAgcmV0dXJuIHRoaXMuX2lucHV0RXZlbnRzW2tleV07XG59O1xuXG4vKipcbiAqIFJlbW92ZXMgdGhlIGZ1bmN0aW9uIHRvIGJlIGV4ZWN1dGVkIG9uIGFuIGlucHV0IGV2ZW50LlxuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSB0eXBlIFRoZSBTY3JlZW5TcGFjZUV2ZW50VHlwZSBvZiBpbnB1dCBldmVudC5cbiAqIEBwYXJhbSB7TnVtYmVyfSBbbW9kaWZpZXJdIEEgS2V5Ym9hcmRFdmVudE1vZGlmaWVyIGtleSB0aGF0IGlzIGhlbGQgd2hlbiBhIDxjb2RlPnR5cGU8L2NvZGU+XG4gKiBldmVudCBvY2N1cnMuXG4gKlxuICogQHNlZSBTY3JlZW5TcGFjZUV2ZW50SGFuZGxlciNnZXRJbnB1dEFjdGlvblxuICogQHNlZSBTY3JlZW5TcGFjZUV2ZW50SGFuZGxlciNzZXRJbnB1dEFjdGlvblxuICovXG5TY3JlZW5TcGFjZUV2ZW50SGFuZGxlci5wcm90b3R5cGUucmVtb3ZlSW5wdXRBY3Rpb24gPSBmdW5jdGlvbiAoXG4gIHR5cGUsXG4gIG1vZGlmaWVyXG4pIHtcbiAgLy8+PmluY2x1ZGVTdGFydCgnZGVidWcnLCBwcmFnbWFzLmRlYnVnKTtcbiAgaWYgKCFkZWZpbmVkKHR5cGUpKSB7XG4gICAgdGhyb3cgbmV3IERldmVsb3BlckVycm9yKFwidHlwZSBpcyByZXF1aXJlZC5cIik7XG4gIH1cbiAgLy8+PmluY2x1ZGVFbmQoJ2RlYnVnJyk7XG5cbiAgdmFyIGtleSA9IGdldElucHV0RXZlbnRLZXkodHlwZSwgbW9kaWZpZXIpO1xuICBkZWxldGUgdGhpcy5faW5wdXRFdmVudHNba2V5XTtcbn07XG5cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIHRoaXMgb2JqZWN0IHdhcyBkZXN0cm95ZWQ7IG90aGVyd2lzZSwgZmFsc2UuXG4gKiA8YnIgLz48YnIgLz5cbiAqIElmIHRoaXMgb2JqZWN0IHdhcyBkZXN0cm95ZWQsIGl0IHNob3VsZCBub3QgYmUgdXNlZDsgY2FsbGluZyBhbnkgZnVuY3Rpb24gb3RoZXIgdGhhblxuICogPGNvZGU+aXNEZXN0cm95ZWQ8L2NvZGU+IHdpbGwgcmVzdWx0IGluIGEge0BsaW5rIERldmVsb3BlckVycm9yfSBleGNlcHRpb24uXG4gKlxuICogQHJldHVybnMge0Jvb2xlYW59IDxjb2RlPnRydWU8L2NvZGU+IGlmIHRoaXMgb2JqZWN0IHdhcyBkZXN0cm95ZWQ7IG90aGVyd2lzZSwgPGNvZGU+ZmFsc2U8L2NvZGU+LlxuICpcbiAqIEBzZWUgU2NyZWVuU3BhY2VFdmVudEhhbmRsZXIjZGVzdHJveVxuICovXG5TY3JlZW5TcGFjZUV2ZW50SGFuZGxlci5wcm90b3R5cGUuaXNEZXN0cm95ZWQgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiBmYWxzZTtcbn07XG5cbi8qKlxuICogUmVtb3ZlcyBsaXN0ZW5lcnMgaGVsZCBieSB0aGlzIG9iamVjdC5cbiAqIDxiciAvPjxiciAvPlxuICogT25jZSBhbiBvYmplY3QgaXMgZGVzdHJveWVkLCBpdCBzaG91bGQgbm90IGJlIHVzZWQ7IGNhbGxpbmcgYW55IGZ1bmN0aW9uIG90aGVyIHRoYW5cbiAqIDxjb2RlPmlzRGVzdHJveWVkPC9jb2RlPiB3aWxsIHJlc3VsdCBpbiBhIHtAbGluayBEZXZlbG9wZXJFcnJvcn0gZXhjZXB0aW9uLiAgVGhlcmVmb3JlLFxuICogYXNzaWduIHRoZSByZXR1cm4gdmFsdWUgKDxjb2RlPnVuZGVmaW5lZDwvY29kZT4pIHRvIHRoZSBvYmplY3QgYXMgZG9uZSBpbiB0aGUgZXhhbXBsZS5cbiAqXG4gKiBAZXhjZXB0aW9uIHtEZXZlbG9wZXJFcnJvcn0gVGhpcyBvYmplY3Qgd2FzIGRlc3Ryb3llZCwgaS5lLiwgZGVzdHJveSgpIHdhcyBjYWxsZWQuXG4gKlxuICpcbiAqIEBleGFtcGxlXG4gKiBoYW5kbGVyID0gaGFuZGxlciAmJiBoYW5kbGVyLmRlc3Ryb3koKTtcbiAqXG4gKiBAc2VlIFNjcmVlblNwYWNlRXZlbnRIYW5kbGVyI2lzRGVzdHJveWVkXG4gKi9cblNjcmVlblNwYWNlRXZlbnRIYW5kbGVyLnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24gKCkge1xuICB1bnJlZ2lzdGVyTGlzdGVuZXJzKHRoaXMpO1xuXG4gIHJldHVybiBkZXN0cm95T2JqZWN0KHRoaXMpO1xufTtcblxuLyoqXG4gKiBUaGUgYW1vdW50IG9mIHRpbWUsIGluIG1pbGxpc2Vjb25kcywgdGhhdCBtb3VzZSBldmVudHMgd2lsbCBiZSBkaXNhYmxlZCBhZnRlclxuICogcmVjZWl2aW5nIGFueSB0b3VjaCBldmVudHMsIHN1Y2ggdGhhdCBhbnkgZW11bGF0ZWQgbW91c2UgZXZlbnRzIHdpbGwgYmUgaWdub3JlZC5cbiAqIEB0eXBlIHtOdW1iZXJ9XG4gKiBAZGVmYXVsdCA4MDBcbiAqL1xuU2NyZWVuU3BhY2VFdmVudEhhbmRsZXIubW91c2VFbXVsYXRpb25JZ25vcmVNaWxsaXNlY29uZHMgPSA4MDA7XG5cbi8qKlxuICogVGhlIGFtb3VudCBvZiB0aW1lLCBpbiBtaWxsaXNlY29uZHMsIGJlZm9yZSBhIHRvdWNoIG9uIHRoZSBzY3JlZW4gYmVjb21lcyBhXG4gKiB0b3VjaCBhbmQgaG9sZC5cbiAqIEB0eXBlIHtOdW1iZXJ9XG4gKiBAZGVmYXVsdCAxNTAwXG4gKi9cblNjcmVlblNwYWNlRXZlbnRIYW5kbGVyLnRvdWNoSG9sZERlbGF5TWlsbGlzZWNvbmRzID0gMTUwMDtcbmV4cG9ydCBkZWZhdWx0IFNjcmVlblNwYWNlRXZlbnRIYW5kbGVyO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///20406\n')},35452:function(__unused_webpack___webpack_module__,__webpack_exports__){eval('/**\n * This enumerated type is for classifying mouse events: down, up, click, double click, move and move while a button is held down.\n *\n * @enum {Number}\n */\nvar ScreenSpaceEventType = {\n  /**\n   * Represents a mouse left button down event.\n   *\n   * @type {Number}\n   * @constant\n   */\n  LEFT_DOWN: 0,\n\n  /**\n   * Represents a mouse left button up event.\n   *\n   * @type {Number}\n   * @constant\n   */\n  LEFT_UP: 1,\n\n  /**\n   * Represents a mouse left click event.\n   *\n   * @type {Number}\n   * @constant\n   */\n  LEFT_CLICK: 2,\n\n  /**\n   * Represents a mouse left double click event.\n   *\n   * @type {Number}\n   * @constant\n   */\n  LEFT_DOUBLE_CLICK: 3,\n\n  /**\n   * Represents a mouse left button down event.\n   *\n   * @type {Number}\n   * @constant\n   */\n  RIGHT_DOWN: 5,\n\n  /**\n   * Represents a mouse right button up event.\n   *\n   * @type {Number}\n   * @constant\n   */\n  RIGHT_UP: 6,\n\n  /**\n   * Represents a mouse right click event.\n   *\n   * @type {Number}\n   * @constant\n   */\n  RIGHT_CLICK: 7,\n\n  /**\n   * Represents a mouse middle button down event.\n   *\n   * @type {Number}\n   * @constant\n   */\n  MIDDLE_DOWN: 10,\n\n  /**\n   * Represents a mouse middle button up event.\n   *\n   * @type {Number}\n   * @constant\n   */\n  MIDDLE_UP: 11,\n\n  /**\n   * Represents a mouse middle click event.\n   *\n   * @type {Number}\n   * @constant\n   */\n  MIDDLE_CLICK: 12,\n\n  /**\n   * Represents a mouse move event.\n   *\n   * @type {Number}\n   * @constant\n   */\n  MOUSE_MOVE: 15,\n\n  /**\n   * Represents a mouse wheel event.\n   *\n   * @type {Number}\n   * @constant\n   */\n  WHEEL: 16,\n\n  /**\n   * Represents the start of a two-finger event on a touch surface.\n   *\n   * @type {Number}\n   * @constant\n   */\n  PINCH_START: 17,\n\n  /**\n   * Represents the end of a two-finger event on a touch surface.\n   *\n   * @type {Number}\n   * @constant\n   */\n  PINCH_END: 18,\n\n  /**\n   * Represents a change of a two-finger event on a touch surface.\n   *\n   * @type {Number}\n   * @constant\n   */\n  PINCH_MOVE: 19,\n};\n/* harmony default export */ __webpack_exports__["Z"] = (Object.freeze(ScreenSpaceEventType));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMzU0NTIuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseURBQWUsbUNBQW1DLEVBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly92dWUzLXdlYnBhY2s1Ly4vbm9kZV9tb2R1bGVzL2Nlc2l1bS9Tb3VyY2UvQ29yZS9TY3JlZW5TcGFjZUV2ZW50VHlwZS5qcz9hMzM4Il0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogVGhpcyBlbnVtZXJhdGVkIHR5cGUgaXMgZm9yIGNsYXNzaWZ5aW5nIG1vdXNlIGV2ZW50czogZG93biwgdXAsIGNsaWNrLCBkb3VibGUgY2xpY2ssIG1vdmUgYW5kIG1vdmUgd2hpbGUgYSBidXR0b24gaXMgaGVsZCBkb3duLlxuICpcbiAqIEBlbnVtIHtOdW1iZXJ9XG4gKi9cbnZhciBTY3JlZW5TcGFjZUV2ZW50VHlwZSA9IHtcbiAgLyoqXG4gICAqIFJlcHJlc2VudHMgYSBtb3VzZSBsZWZ0IGJ1dHRvbiBkb3duIGV2ZW50LlxuICAgKlxuICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgKiBAY29uc3RhbnRcbiAgICovXG4gIExFRlRfRE9XTjogMCxcblxuICAvKipcbiAgICogUmVwcmVzZW50cyBhIG1vdXNlIGxlZnQgYnV0dG9uIHVwIGV2ZW50LlxuICAgKlxuICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgKiBAY29uc3RhbnRcbiAgICovXG4gIExFRlRfVVA6IDEsXG5cbiAgLyoqXG4gICAqIFJlcHJlc2VudHMgYSBtb3VzZSBsZWZ0IGNsaWNrIGV2ZW50LlxuICAgKlxuICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgKiBAY29uc3RhbnRcbiAgICovXG4gIExFRlRfQ0xJQ0s6IDIsXG5cbiAgLyoqXG4gICAqIFJlcHJlc2VudHMgYSBtb3VzZSBsZWZ0IGRvdWJsZSBjbGljayBldmVudC5cbiAgICpcbiAgICogQHR5cGUge051bWJlcn1cbiAgICogQGNvbnN0YW50XG4gICAqL1xuICBMRUZUX0RPVUJMRV9DTElDSzogMyxcblxuICAvKipcbiAgICogUmVwcmVzZW50cyBhIG1vdXNlIGxlZnQgYnV0dG9uIGRvd24gZXZlbnQuXG4gICAqXG4gICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAqIEBjb25zdGFudFxuICAgKi9cbiAgUklHSFRfRE9XTjogNSxcblxuICAvKipcbiAgICogUmVwcmVzZW50cyBhIG1vdXNlIHJpZ2h0IGJ1dHRvbiB1cCBldmVudC5cbiAgICpcbiAgICogQHR5cGUge051bWJlcn1cbiAgICogQGNvbnN0YW50XG4gICAqL1xuICBSSUdIVF9VUDogNixcblxuICAvKipcbiAgICogUmVwcmVzZW50cyBhIG1vdXNlIHJpZ2h0IGNsaWNrIGV2ZW50LlxuICAgKlxuICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgKiBAY29uc3RhbnRcbiAgICovXG4gIFJJR0hUX0NMSUNLOiA3LFxuXG4gIC8qKlxuICAgKiBSZXByZXNlbnRzIGEgbW91c2UgbWlkZGxlIGJ1dHRvbiBkb3duIGV2ZW50LlxuICAgKlxuICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgKiBAY29uc3RhbnRcbiAgICovXG4gIE1JRERMRV9ET1dOOiAxMCxcblxuICAvKipcbiAgICogUmVwcmVzZW50cyBhIG1vdXNlIG1pZGRsZSBidXR0b24gdXAgZXZlbnQuXG4gICAqXG4gICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAqIEBjb25zdGFudFxuICAgKi9cbiAgTUlERExFX1VQOiAxMSxcblxuICAvKipcbiAgICogUmVwcmVzZW50cyBhIG1vdXNlIG1pZGRsZSBjbGljayBldmVudC5cbiAgICpcbiAgICogQHR5cGUge051bWJlcn1cbiAgICogQGNvbnN0YW50XG4gICAqL1xuICBNSURETEVfQ0xJQ0s6IDEyLFxuXG4gIC8qKlxuICAgKiBSZXByZXNlbnRzIGEgbW91c2UgbW92ZSBldmVudC5cbiAgICpcbiAgICogQHR5cGUge051bWJlcn1cbiAgICogQGNvbnN0YW50XG4gICAqL1xuICBNT1VTRV9NT1ZFOiAxNSxcblxuICAvKipcbiAgICogUmVwcmVzZW50cyBhIG1vdXNlIHdoZWVsIGV2ZW50LlxuICAgKlxuICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgKiBAY29uc3RhbnRcbiAgICovXG4gIFdIRUVMOiAxNixcblxuICAvKipcbiAgICogUmVwcmVzZW50cyB0aGUgc3RhcnQgb2YgYSB0d28tZmluZ2VyIGV2ZW50IG9uIGEgdG91Y2ggc3VyZmFjZS5cbiAgICpcbiAgICogQHR5cGUge051bWJlcn1cbiAgICogQGNvbnN0YW50XG4gICAqL1xuICBQSU5DSF9TVEFSVDogMTcsXG5cbiAgLyoqXG4gICAqIFJlcHJlc2VudHMgdGhlIGVuZCBvZiBhIHR3by1maW5nZXIgZXZlbnQgb24gYSB0b3VjaCBzdXJmYWNlLlxuICAgKlxuICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgKiBAY29uc3RhbnRcbiAgICovXG4gIFBJTkNIX0VORDogMTgsXG5cbiAgLyoqXG4gICAqIFJlcHJlc2VudHMgYSBjaGFuZ2Ugb2YgYSB0d28tZmluZ2VyIGV2ZW50IG9uIGEgdG91Y2ggc3VyZmFjZS5cbiAgICpcbiAgICogQHR5cGUge051bWJlcn1cbiAgICogQGNvbnN0YW50XG4gICAqL1xuICBQSU5DSF9NT1ZFOiAxOSxcbn07XG5leHBvcnQgZGVmYXVsdCBPYmplY3QuZnJlZXplKFNjcmVlblNwYWNlRXZlbnRUeXBlKTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///35452\n')},37939:function(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__){eval('/* harmony import */ var _ComponentDatatype_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(84828);\n/* harmony import */ var _defaultValue_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(62200);\n/* harmony import */ var _defined_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(82982);\n/* harmony import */ var _DeveloperError_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(12572);\n\n\n\n\n\n/**\n * Value and type information for per-instance geometry attribute that determines if the geometry instance will be shown.\n *\n * @alias ShowGeometryInstanceAttribute\n * @constructor\n *\n * @param {Boolean} [show=true] Determines if the geometry instance will be shown.\n *\n *\n * @example\n * var instance = new Cesium.GeometryInstance({\n *   geometry : new Cesium.BoxGeometry({\n *     vertexFormat : Cesium.VertexFormat.POSITION_AND_NORMAL,\n *     minimum : new Cesium.Cartesian3(-250000.0, -250000.0, -250000.0),\n *     maximum : new Cesium.Cartesian3(250000.0, 250000.0, 250000.0)\n *   }),\n *   modelMatrix : Cesium.Matrix4.multiplyByTranslation(Cesium.Transforms.eastNorthUpToFixedFrame(\n *     Cesium.Cartesian3.fromDegrees(-75.59777, 40.03883)), new Cesium.Cartesian3(0.0, 0.0, 1000000.0), new Cesium.Matrix4()),\n *   id : \'box\',\n *   attributes : {\n *     show : new Cesium.ShowGeometryInstanceAttribute(false)\n *   }\n * });\n *\n * @see GeometryInstance\n * @see GeometryInstanceAttribute\n */\nfunction ShowGeometryInstanceAttribute(show) {\n  show = (0,_defaultValue_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .Z)(show, true);\n\n  /**\n   * The values for the attributes stored in a typed array.\n   *\n   * @type Uint8Array\n   *\n   * @default [1.0]\n   */\n  this.value = ShowGeometryInstanceAttribute.toValue(show);\n}\n\nObject.defineProperties(ShowGeometryInstanceAttribute.prototype, {\n  /**\n   * The datatype of each component in the attribute, e.g., individual elements in\n   * {@link ColorGeometryInstanceAttribute#value}.\n   *\n   * @memberof ShowGeometryInstanceAttribute.prototype\n   *\n   * @type {ComponentDatatype}\n   * @readonly\n   *\n   * @default {@link ComponentDatatype.UNSIGNED_BYTE}\n   */\n  componentDatatype: {\n    get: function () {\n      return _ComponentDatatype_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].UNSIGNED_BYTE */ .Z.UNSIGNED_BYTE;\n    },\n  },\n\n  /**\n   * The number of components in the attributes, i.e., {@link ColorGeometryInstanceAttribute#value}.\n   *\n   * @memberof ShowGeometryInstanceAttribute.prototype\n   *\n   * @type {Number}\n   * @readonly\n   *\n   * @default 1\n   */\n  componentsPerAttribute: {\n    get: function () {\n      return 1;\n    },\n  },\n\n  /**\n   * When <code>true</code> and <code>componentDatatype</code> is an integer format,\n   * indicate that the components should be mapped to the range [0, 1] (unsigned)\n   * or [-1, 1] (signed) when they are accessed as floating-point for rendering.\n   *\n   * @memberof ShowGeometryInstanceAttribute.prototype\n   *\n   * @type {Boolean}\n   * @readonly\n   *\n   * @default true\n   */\n  normalize: {\n    get: function () {\n      return false;\n    },\n  },\n});\n\n/**\n * Converts a boolean show to a typed array that can be used to assign a show attribute.\n *\n * @param {Boolean} show The show value.\n * @param {Uint8Array} [result] The array to store the result in, if undefined a new instance will be created.\n * @returns {Uint8Array} The modified result parameter or a new instance if result was undefined.\n *\n * @example\n * var attributes = primitive.getGeometryInstanceAttributes(\'an id\');\n * attributes.show = Cesium.ShowGeometryInstanceAttribute.toValue(true, attributes.show);\n */\nShowGeometryInstanceAttribute.toValue = function (show, result) {\n  //>>includeStart(\'debug\', pragmas.debug);\n  if (!(0,_defined_js__WEBPACK_IMPORTED_MODULE_3__/* ["default"] */ .Z)(show)) {\n    throw new _DeveloperError_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"] */ .Z("show is required.");\n  }\n  //>>includeEnd(\'debug\');\n\n  if (!(0,_defined_js__WEBPACK_IMPORTED_MODULE_3__/* ["default"] */ .Z)(result)) {\n    return new Uint8Array([show]);\n  }\n  result[0] = show;\n  return result;\n};\n/* harmony default export */ __webpack_exports__["Z"] = (ShowGeometryInstanceAttribute);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMzc5MzkuanMiLCJtYXBwaW5ncyI6Ijs7OztBQUF1RDtBQUNWO0FBQ1Y7QUFDYzs7QUFFakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxTQUFTO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLHFFQUFZOztBQUVyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTSwyQ0FBMkM7QUFDakQ7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0EsYUFBYSxrR0FBK0I7QUFDNUMsS0FBSztBQUNMLEdBQUc7O0FBRUg7QUFDQSx3REFBd0QsMkNBQTJDO0FBQ25HO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSCxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBLFdBQVcsU0FBUztBQUNwQixXQUFXLFlBQVk7QUFDdkIsYUFBYSxZQUFZO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTyxnRUFBTztBQUNkLGNBQWMsbUVBQWM7QUFDNUI7QUFDQTs7QUFFQSxPQUFPLGdFQUFPO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlEQUFlLDZCQUE2QixFQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdnVlMy13ZWJwYWNrNS8uL25vZGVfbW9kdWxlcy9jZXNpdW0vU291cmNlL0NvcmUvU2hvd0dlb21ldHJ5SW5zdGFuY2VBdHRyaWJ1dGUuanM/MWI5ZCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgQ29tcG9uZW50RGF0YXR5cGUgZnJvbSBcIi4vQ29tcG9uZW50RGF0YXR5cGUuanNcIjtcbmltcG9ydCBkZWZhdWx0VmFsdWUgZnJvbSBcIi4vZGVmYXVsdFZhbHVlLmpzXCI7XG5pbXBvcnQgZGVmaW5lZCBmcm9tIFwiLi9kZWZpbmVkLmpzXCI7XG5pbXBvcnQgRGV2ZWxvcGVyRXJyb3IgZnJvbSBcIi4vRGV2ZWxvcGVyRXJyb3IuanNcIjtcblxuLyoqXG4gKiBWYWx1ZSBhbmQgdHlwZSBpbmZvcm1hdGlvbiBmb3IgcGVyLWluc3RhbmNlIGdlb21ldHJ5IGF0dHJpYnV0ZSB0aGF0IGRldGVybWluZXMgaWYgdGhlIGdlb21ldHJ5IGluc3RhbmNlIHdpbGwgYmUgc2hvd24uXG4gKlxuICogQGFsaWFzIFNob3dHZW9tZXRyeUluc3RhbmNlQXR0cmlidXRlXG4gKiBAY29uc3RydWN0b3JcbiAqXG4gKiBAcGFyYW0ge0Jvb2xlYW59IFtzaG93PXRydWVdIERldGVybWluZXMgaWYgdGhlIGdlb21ldHJ5IGluc3RhbmNlIHdpbGwgYmUgc2hvd24uXG4gKlxuICpcbiAqIEBleGFtcGxlXG4gKiB2YXIgaW5zdGFuY2UgPSBuZXcgQ2VzaXVtLkdlb21ldHJ5SW5zdGFuY2Uoe1xuICogICBnZW9tZXRyeSA6IG5ldyBDZXNpdW0uQm94R2VvbWV0cnkoe1xuICogICAgIHZlcnRleEZvcm1hdCA6IENlc2l1bS5WZXJ0ZXhGb3JtYXQuUE9TSVRJT05fQU5EX05PUk1BTCxcbiAqICAgICBtaW5pbXVtIDogbmV3IENlc2l1bS5DYXJ0ZXNpYW4zKC0yNTAwMDAuMCwgLTI1MDAwMC4wLCAtMjUwMDAwLjApLFxuICogICAgIG1heGltdW0gOiBuZXcgQ2VzaXVtLkNhcnRlc2lhbjMoMjUwMDAwLjAsIDI1MDAwMC4wLCAyNTAwMDAuMClcbiAqICAgfSksXG4gKiAgIG1vZGVsTWF0cml4IDogQ2VzaXVtLk1hdHJpeDQubXVsdGlwbHlCeVRyYW5zbGF0aW9uKENlc2l1bS5UcmFuc2Zvcm1zLmVhc3ROb3J0aFVwVG9GaXhlZEZyYW1lKFxuICogICAgIENlc2l1bS5DYXJ0ZXNpYW4zLmZyb21EZWdyZWVzKC03NS41OTc3NywgNDAuMDM4ODMpKSwgbmV3IENlc2l1bS5DYXJ0ZXNpYW4zKDAuMCwgMC4wLCAxMDAwMDAwLjApLCBuZXcgQ2VzaXVtLk1hdHJpeDQoKSksXG4gKiAgIGlkIDogJ2JveCcsXG4gKiAgIGF0dHJpYnV0ZXMgOiB7XG4gKiAgICAgc2hvdyA6IG5ldyBDZXNpdW0uU2hvd0dlb21ldHJ5SW5zdGFuY2VBdHRyaWJ1dGUoZmFsc2UpXG4gKiAgIH1cbiAqIH0pO1xuICpcbiAqIEBzZWUgR2VvbWV0cnlJbnN0YW5jZVxuICogQHNlZSBHZW9tZXRyeUluc3RhbmNlQXR0cmlidXRlXG4gKi9cbmZ1bmN0aW9uIFNob3dHZW9tZXRyeUluc3RhbmNlQXR0cmlidXRlKHNob3cpIHtcbiAgc2hvdyA9IGRlZmF1bHRWYWx1ZShzaG93LCB0cnVlKTtcblxuICAvKipcbiAgICogVGhlIHZhbHVlcyBmb3IgdGhlIGF0dHJpYnV0ZXMgc3RvcmVkIGluIGEgdHlwZWQgYXJyYXkuXG4gICAqXG4gICAqIEB0eXBlIFVpbnQ4QXJyYXlcbiAgICpcbiAgICogQGRlZmF1bHQgWzEuMF1cbiAgICovXG4gIHRoaXMudmFsdWUgPSBTaG93R2VvbWV0cnlJbnN0YW5jZUF0dHJpYnV0ZS50b1ZhbHVlKHNob3cpO1xufVxuXG5PYmplY3QuZGVmaW5lUHJvcGVydGllcyhTaG93R2VvbWV0cnlJbnN0YW5jZUF0dHJpYnV0ZS5wcm90b3R5cGUsIHtcbiAgLyoqXG4gICAqIFRoZSBkYXRhdHlwZSBvZiBlYWNoIGNvbXBvbmVudCBpbiB0aGUgYXR0cmlidXRlLCBlLmcuLCBpbmRpdmlkdWFsIGVsZW1lbnRzIGluXG4gICAqIHtAbGluayBDb2xvckdlb21ldHJ5SW5zdGFuY2VBdHRyaWJ1dGUjdmFsdWV9LlxuICAgKlxuICAgKiBAbWVtYmVyb2YgU2hvd0dlb21ldHJ5SW5zdGFuY2VBdHRyaWJ1dGUucHJvdG90eXBlXG4gICAqXG4gICAqIEB0eXBlIHtDb21wb25lbnREYXRhdHlwZX1cbiAgICogQHJlYWRvbmx5XG4gICAqXG4gICAqIEBkZWZhdWx0IHtAbGluayBDb21wb25lbnREYXRhdHlwZS5VTlNJR05FRF9CWVRFfVxuICAgKi9cbiAgY29tcG9uZW50RGF0YXR5cGU6IHtcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBDb21wb25lbnREYXRhdHlwZS5VTlNJR05FRF9CWVRFO1xuICAgIH0sXG4gIH0sXG5cbiAgLyoqXG4gICAqIFRoZSBudW1iZXIgb2YgY29tcG9uZW50cyBpbiB0aGUgYXR0cmlidXRlcywgaS5lLiwge0BsaW5rIENvbG9yR2VvbWV0cnlJbnN0YW5jZUF0dHJpYnV0ZSN2YWx1ZX0uXG4gICAqXG4gICAqIEBtZW1iZXJvZiBTaG93R2VvbWV0cnlJbnN0YW5jZUF0dHJpYnV0ZS5wcm90b3R5cGVcbiAgICpcbiAgICogQHR5cGUge051bWJlcn1cbiAgICogQHJlYWRvbmx5XG4gICAqXG4gICAqIEBkZWZhdWx0IDFcbiAgICovXG4gIGNvbXBvbmVudHNQZXJBdHRyaWJ1dGU6IHtcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiAxO1xuICAgIH0sXG4gIH0sXG5cbiAgLyoqXG4gICAqIFdoZW4gPGNvZGU+dHJ1ZTwvY29kZT4gYW5kIDxjb2RlPmNvbXBvbmVudERhdGF0eXBlPC9jb2RlPiBpcyBhbiBpbnRlZ2VyIGZvcm1hdCxcbiAgICogaW5kaWNhdGUgdGhhdCB0aGUgY29tcG9uZW50cyBzaG91bGQgYmUgbWFwcGVkIHRvIHRoZSByYW5nZSBbMCwgMV0gKHVuc2lnbmVkKVxuICAgKiBvciBbLTEsIDFdIChzaWduZWQpIHdoZW4gdGhleSBhcmUgYWNjZXNzZWQgYXMgZmxvYXRpbmctcG9pbnQgZm9yIHJlbmRlcmluZy5cbiAgICpcbiAgICogQG1lbWJlcm9mIFNob3dHZW9tZXRyeUluc3RhbmNlQXR0cmlidXRlLnByb3RvdHlwZVxuICAgKlxuICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICogQHJlYWRvbmx5XG4gICAqXG4gICAqIEBkZWZhdWx0IHRydWVcbiAgICovXG4gIG5vcm1hbGl6ZToge1xuICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0sXG4gIH0sXG59KTtcblxuLyoqXG4gKiBDb252ZXJ0cyBhIGJvb2xlYW4gc2hvdyB0byBhIHR5cGVkIGFycmF5IHRoYXQgY2FuIGJlIHVzZWQgdG8gYXNzaWduIGEgc2hvdyBhdHRyaWJ1dGUuXG4gKlxuICogQHBhcmFtIHtCb29sZWFufSBzaG93IFRoZSBzaG93IHZhbHVlLlxuICogQHBhcmFtIHtVaW50OEFycmF5fSBbcmVzdWx0XSBUaGUgYXJyYXkgdG8gc3RvcmUgdGhlIHJlc3VsdCBpbiwgaWYgdW5kZWZpbmVkIGEgbmV3IGluc3RhbmNlIHdpbGwgYmUgY3JlYXRlZC5cbiAqIEByZXR1cm5zIHtVaW50OEFycmF5fSBUaGUgbW9kaWZpZWQgcmVzdWx0IHBhcmFtZXRlciBvciBhIG5ldyBpbnN0YW5jZSBpZiByZXN1bHQgd2FzIHVuZGVmaW5lZC5cbiAqXG4gKiBAZXhhbXBsZVxuICogdmFyIGF0dHJpYnV0ZXMgPSBwcmltaXRpdmUuZ2V0R2VvbWV0cnlJbnN0YW5jZUF0dHJpYnV0ZXMoJ2FuIGlkJyk7XG4gKiBhdHRyaWJ1dGVzLnNob3cgPSBDZXNpdW0uU2hvd0dlb21ldHJ5SW5zdGFuY2VBdHRyaWJ1dGUudG9WYWx1ZSh0cnVlLCBhdHRyaWJ1dGVzLnNob3cpO1xuICovXG5TaG93R2VvbWV0cnlJbnN0YW5jZUF0dHJpYnV0ZS50b1ZhbHVlID0gZnVuY3Rpb24gKHNob3csIHJlc3VsdCkge1xuICAvLz4+aW5jbHVkZVN0YXJ0KCdkZWJ1ZycsIHByYWdtYXMuZGVidWcpO1xuICBpZiAoIWRlZmluZWQoc2hvdykpIHtcbiAgICB0aHJvdyBuZXcgRGV2ZWxvcGVyRXJyb3IoXCJzaG93IGlzIHJlcXVpcmVkLlwiKTtcbiAgfVxuICAvLz4+aW5jbHVkZUVuZCgnZGVidWcnKTtcblxuICBpZiAoIWRlZmluZWQocmVzdWx0KSkge1xuICAgIHJldHVybiBuZXcgVWludDhBcnJheShbc2hvd10pO1xuICB9XG4gIHJlc3VsdFswXSA9IHNob3c7XG4gIHJldHVybiByZXN1bHQ7XG59O1xuZXhwb3J0IGRlZmF1bHQgU2hvd0dlb21ldHJ5SW5zdGFuY2VBdHRyaWJ1dGU7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///37939\n')},83156:function(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__){eval('/* harmony import */ var _Cartesian3_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(60216);\n/* harmony import */ var _defined_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(82982);\n/* harmony import */ var _DeveloperError_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(12572);\n/* harmony import */ var _JulianDate_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(55293);\n/* harmony import */ var _Math_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(99417);\n/* harmony import */ var _Matrix3_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(68201);\n/* harmony import */ var _TimeConstants_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(4877);\n/* harmony import */ var _TimeStandard_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(13098);\n\n\n\n\n\n\n\n\n\n/**\n * Contains functions for finding the Cartesian coordinates of the sun and the moon in the\n * Earth-centered inertial frame.\n *\n * @namespace Simon1994PlanetaryPositions\n */\nvar Simon1994PlanetaryPositions = {};\n\nfunction computeTdbMinusTtSpice(daysSinceJ2000InTerrestrialTime) {\n  /* STK Comments ------------------------------------------------------\n   * This function uses constants designed to be consistent with\n   * the SPICE Toolkit from JPL version N0051 (unitim.c)\n   * M0 = 6.239996\n   * M0Dot = 1.99096871e-7 rad/s = 0.01720197 rad/d\n   * EARTH_ECC = 1.671e-2\n   * TDB_AMPL = 1.657e-3 secs\n   *--------------------------------------------------------------------*/\n\n  //* Values taken as specified in STK Comments except: 0.01720197 rad/day = 1.99096871e-7 rad/sec\n  //* Here we use the more precise value taken from the SPICE value 1.99096871e-7 rad/sec converted to rad/day\n  //* All other constants are consistent with the SPICE implementation of the TDB conversion\n  //* except where we treat the independent time parameter to be in TT instead of TDB.\n  //* This is an approximation made to facilitate performance due to the higher prevalance of\n  //* the TT2TDB conversion over TDB2TT in order to avoid having to iterate when converting to TDB for the JPL ephemeris.\n  //* Days are used instead of seconds to provide a slight improvement in numerical precision.\n\n  //* For more information see:\n  //* http://www.cv.nrao.edu/~rfisher/Ephemerides/times.html#TDB\n  //* ftp://ssd.jpl.nasa.gov/pub/eph/planets/ioms/ExplSupplChap8.pdf\n\n  var g = 6.239996 + 0.0172019696544 * daysSinceJ2000InTerrestrialTime;\n  return 1.657e-3 * Math.sin(g + 1.671e-2 * Math.sin(g));\n}\n\nvar TdtMinusTai = 32.184;\nvar J2000d = 2451545;\nfunction taiToTdb(date, result) {\n  //Converts TAI to TT\n  result = _JulianDate_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"].addSeconds */ .Z.addSeconds(date, TdtMinusTai, result);\n\n  //Converts TT to TDB\n  var days = _JulianDate_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"].totalDays */ .Z.totalDays(result) - J2000d;\n  result = _JulianDate_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"].addSeconds */ .Z.addSeconds(result, computeTdbMinusTtSpice(days), result);\n\n  return result;\n}\n\nvar epoch = new _JulianDate_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"] */ .Z(2451545, 0, _TimeStandard_js__WEBPACK_IMPORTED_MODULE_6__/* ["default"].TAI */ .Z.TAI); //Actually TDB (not TAI)\nvar MetersPerKilometer = 1000.0;\nvar RadiansPerDegree = _Math_js__WEBPACK_IMPORTED_MODULE_3__/* ["default"].RADIANS_PER_DEGREE */ .Z.RADIANS_PER_DEGREE;\nvar RadiansPerArcSecond = _Math_js__WEBPACK_IMPORTED_MODULE_3__/* ["default"].RADIANS_PER_ARCSECOND */ .Z.RADIANS_PER_ARCSECOND;\nvar MetersPerAstronomicalUnit = 1.4959787e11; // IAU 1976 value\n\nvar perifocalToEquatorial = new _Matrix3_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .Z();\nfunction elementsToCartesian(\n  semimajorAxis,\n  eccentricity,\n  inclination,\n  longitudeOfPerigee,\n  longitudeOfNode,\n  meanLongitude,\n  result\n) {\n  if (inclination < 0.0) {\n    inclination = -inclination;\n    longitudeOfNode += _Math_js__WEBPACK_IMPORTED_MODULE_3__/* ["default"].PI */ .Z.PI;\n  }\n\n  //>>includeStart(\'debug\', pragmas.debug);\n  if (inclination < 0 || inclination > _Math_js__WEBPACK_IMPORTED_MODULE_3__/* ["default"].PI */ .Z.PI) {\n    throw new _DeveloperError_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .Z(\n      "The inclination is out of range. Inclination must be greater than or equal to zero and less than or equal to Pi radians."\n    );\n  }\n  //>>includeEnd(\'debug\')\n\n  var radiusOfPeriapsis = semimajorAxis * (1.0 - eccentricity);\n  var argumentOfPeriapsis = longitudeOfPerigee - longitudeOfNode;\n  var rightAscensionOfAscendingNode = longitudeOfNode;\n  var trueAnomaly = meanAnomalyToTrueAnomaly(\n    meanLongitude - longitudeOfPerigee,\n    eccentricity\n  );\n  var type = chooseOrbit(eccentricity, 0.0);\n\n  //>>includeStart(\'debug\', pragmas.debug);\n  if (\n    type === "Hyperbolic" &&\n    Math.abs(_Math_js__WEBPACK_IMPORTED_MODULE_3__/* ["default"].negativePiToPi */ .Z.negativePiToPi(trueAnomaly)) >=\n      Math.acos(-1.0 / eccentricity)\n  ) {\n    throw new _DeveloperError_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .Z(\n      "The true anomaly of the hyperbolic orbit lies outside of the bounds of the hyperbola."\n    );\n  }\n  //>>includeEnd(\'debug\')\n\n  perifocalToCartesianMatrix(\n    argumentOfPeriapsis,\n    inclination,\n    rightAscensionOfAscendingNode,\n    perifocalToEquatorial\n  );\n  var semilatus = radiusOfPeriapsis * (1.0 + eccentricity);\n  var costheta = Math.cos(trueAnomaly);\n  var sintheta = Math.sin(trueAnomaly);\n\n  var denom = 1.0 + eccentricity * costheta;\n\n  //>>includeStart(\'debug\', pragmas.debug);\n  if (denom <= _Math_js__WEBPACK_IMPORTED_MODULE_3__/* ["default"].Epsilon10 */ .Z.Epsilon10) {\n    throw new _DeveloperError_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .Z("elements cannot be converted to cartesian");\n  }\n  //>>includeEnd(\'debug\')\n\n  var radius = semilatus / denom;\n  if (!(0,_defined_js__WEBPACK_IMPORTED_MODULE_7__/* ["default"] */ .Z)(result)) {\n    result = new _Cartesian3_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .Z(radius * costheta, radius * sintheta, 0.0);\n  } else {\n    result.x = radius * costheta;\n    result.y = radius * sintheta;\n    result.z = 0.0;\n  }\n\n  return _Matrix3_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"].multiplyByVector */ .Z.multiplyByVector(perifocalToEquatorial, result, result);\n}\n\nfunction chooseOrbit(eccentricity, tolerance) {\n  //>>includeStart(\'debug\', pragmas.debug);\n  if (eccentricity < 0) {\n    throw new _DeveloperError_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .Z("eccentricity cannot be negative.");\n  }\n  //>>includeEnd(\'debug\')\n\n  if (eccentricity <= tolerance) {\n    return "Circular";\n  } else if (eccentricity < 1.0 - tolerance) {\n    return "Elliptical";\n  } else if (eccentricity <= 1.0 + tolerance) {\n    return "Parabolic";\n  }\n  return "Hyperbolic";\n}\n\n// Calculates the true anomaly given the mean anomaly and the eccentricity.\nfunction meanAnomalyToTrueAnomaly(meanAnomaly, eccentricity) {\n  //>>includeStart(\'debug\', pragmas.debug);\n  if (eccentricity < 0.0 || eccentricity >= 1.0) {\n    throw new _DeveloperError_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .Z("eccentricity out of range.");\n  }\n  //>>includeEnd(\'debug\')\n\n  var eccentricAnomaly = meanAnomalyToEccentricAnomaly(\n    meanAnomaly,\n    eccentricity\n  );\n  return eccentricAnomalyToTrueAnomaly(eccentricAnomaly, eccentricity);\n}\n\nvar maxIterationCount = 50;\nvar keplerEqConvergence = _Math_js__WEBPACK_IMPORTED_MODULE_3__/* ["default"].EPSILON8 */ .Z.EPSILON8;\n// Calculates the eccentric anomaly given the mean anomaly and the eccentricity.\nfunction meanAnomalyToEccentricAnomaly(meanAnomaly, eccentricity) {\n  //>>includeStart(\'debug\', pragmas.debug);\n  if (eccentricity < 0.0 || eccentricity >= 1.0) {\n    throw new _DeveloperError_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .Z("eccentricity out of range.");\n  }\n  //>>includeEnd(\'debug\')\n\n  var revs = Math.floor(meanAnomaly / _Math_js__WEBPACK_IMPORTED_MODULE_3__/* ["default"].TWO_PI */ .Z.TWO_PI);\n\n  // Find angle in current revolution\n  meanAnomaly -= revs * _Math_js__WEBPACK_IMPORTED_MODULE_3__/* ["default"].TWO_PI */ .Z.TWO_PI;\n\n  // calculate starting value for iteration sequence\n  var iterationValue =\n    meanAnomaly +\n    (eccentricity * Math.sin(meanAnomaly)) /\n      (1.0 - Math.sin(meanAnomaly + eccentricity) + Math.sin(meanAnomaly));\n\n  // Perform Newton-Raphson iteration on Kepler\'s equation\n  var eccentricAnomaly = Number.MAX_VALUE;\n\n  var count;\n  for (\n    count = 0;\n    count < maxIterationCount &&\n    Math.abs(eccentricAnomaly - iterationValue) > keplerEqConvergence;\n    ++count\n  ) {\n    eccentricAnomaly = iterationValue;\n    var NRfunction =\n      eccentricAnomaly -\n      eccentricity * Math.sin(eccentricAnomaly) -\n      meanAnomaly;\n    var dNRfunction = 1 - eccentricity * Math.cos(eccentricAnomaly);\n    iterationValue = eccentricAnomaly - NRfunction / dNRfunction;\n  }\n\n  //>>includeStart(\'debug\', pragmas.debug);\n  if (count >= maxIterationCount) {\n    throw new _DeveloperError_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .Z("Kepler equation did not converge");\n    // STK Components uses a numerical method to find the eccentric anomaly in the case that Kepler\'s\n    // equation does not converge. We don\'t expect that to ever be necessary for the reasonable orbits used here.\n  }\n  //>>includeEnd(\'debug\')\n\n  eccentricAnomaly = iterationValue + revs * _Math_js__WEBPACK_IMPORTED_MODULE_3__/* ["default"].TWO_PI */ .Z.TWO_PI;\n  return eccentricAnomaly;\n}\n\n// Calculates the true anomaly given the eccentric anomaly and the eccentricity.\nfunction eccentricAnomalyToTrueAnomaly(eccentricAnomaly, eccentricity) {\n  //>>includeStart(\'debug\', pragmas.debug);\n  if (eccentricity < 0.0 || eccentricity >= 1.0) {\n    throw new _DeveloperError_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .Z("eccentricity out of range.");\n  }\n  //>>includeEnd(\'debug\')\n\n  // Calculate the number of previous revolutions\n  var revs = Math.floor(eccentricAnomaly / _Math_js__WEBPACK_IMPORTED_MODULE_3__/* ["default"].TWO_PI */ .Z.TWO_PI);\n\n  // Find angle in current revolution\n  eccentricAnomaly -= revs * _Math_js__WEBPACK_IMPORTED_MODULE_3__/* ["default"].TWO_PI */ .Z.TWO_PI;\n\n  // Calculate true anomaly from eccentric anomaly\n  var trueAnomalyX = Math.cos(eccentricAnomaly) - eccentricity;\n  var trueAnomalyY =\n    Math.sin(eccentricAnomaly) * Math.sqrt(1 - eccentricity * eccentricity);\n\n  var trueAnomaly = Math.atan2(trueAnomalyY, trueAnomalyX);\n\n  // Ensure the correct quadrant\n  trueAnomaly = _Math_js__WEBPACK_IMPORTED_MODULE_3__/* ["default"].zeroToTwoPi */ .Z.zeroToTwoPi(trueAnomaly);\n  if (eccentricAnomaly < 0) {\n    trueAnomaly -= _Math_js__WEBPACK_IMPORTED_MODULE_3__/* ["default"].TWO_PI */ .Z.TWO_PI;\n  }\n\n  // Add on previous revolutions\n  trueAnomaly += revs * _Math_js__WEBPACK_IMPORTED_MODULE_3__/* ["default"].TWO_PI */ .Z.TWO_PI;\n\n  return trueAnomaly;\n}\n\n// Calculates the transformation matrix to convert from the perifocal (PQW) coordinate\n// system to inertial cartesian coordinates.\nfunction perifocalToCartesianMatrix(\n  argumentOfPeriapsis,\n  inclination,\n  rightAscension,\n  result\n) {\n  //>>includeStart(\'debug\', pragmas.debug);\n  if (inclination < 0 || inclination > _Math_js__WEBPACK_IMPORTED_MODULE_3__/* ["default"].PI */ .Z.PI) {\n    throw new _DeveloperError_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .Z("inclination out of range");\n  }\n  //>>includeEnd(\'debug\')\n\n  var cosap = Math.cos(argumentOfPeriapsis);\n  var sinap = Math.sin(argumentOfPeriapsis);\n\n  var cosi = Math.cos(inclination);\n  var sini = Math.sin(inclination);\n\n  var cosraan = Math.cos(rightAscension);\n  var sinraan = Math.sin(rightAscension);\n  if (!(0,_defined_js__WEBPACK_IMPORTED_MODULE_7__/* ["default"] */ .Z)(result)) {\n    result = new _Matrix3_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .Z(\n      cosraan * cosap - sinraan * sinap * cosi,\n      -cosraan * sinap - sinraan * cosap * cosi,\n      sinraan * sini,\n\n      sinraan * cosap + cosraan * sinap * cosi,\n      -sinraan * sinap + cosraan * cosap * cosi,\n      -cosraan * sini,\n\n      sinap * sini,\n      cosap * sini,\n      cosi\n    );\n  } else {\n    result[0] = cosraan * cosap - sinraan * sinap * cosi;\n    result[1] = sinraan * cosap + cosraan * sinap * cosi;\n    result[2] = sinap * sini;\n    result[3] = -cosraan * sinap - sinraan * cosap * cosi;\n    result[4] = -sinraan * sinap + cosraan * cosap * cosi;\n    result[5] = cosap * sini;\n    result[6] = sinraan * sini;\n    result[7] = -cosraan * sini;\n    result[8] = cosi;\n  }\n  return result;\n}\n\n// From section 5.8\nvar semiMajorAxis0 = 1.0000010178 * MetersPerAstronomicalUnit;\nvar meanLongitude0 = 100.46645683 * RadiansPerDegree;\nvar meanLongitude1 = 1295977422.83429 * RadiansPerArcSecond;\n\n// From table 6\nvar p1u = 16002;\nvar p2u = 21863;\nvar p3u = 32004;\nvar p4u = 10931;\nvar p5u = 14529;\nvar p6u = 16368;\nvar p7u = 15318;\nvar p8u = 32794;\n\nvar Ca1 = 64 * 1e-7 * MetersPerAstronomicalUnit;\nvar Ca2 = -152 * 1e-7 * MetersPerAstronomicalUnit;\nvar Ca3 = 62 * 1e-7 * MetersPerAstronomicalUnit;\nvar Ca4 = -8 * 1e-7 * MetersPerAstronomicalUnit;\nvar Ca5 = 32 * 1e-7 * MetersPerAstronomicalUnit;\nvar Ca6 = -41 * 1e-7 * MetersPerAstronomicalUnit;\nvar Ca7 = 19 * 1e-7 * MetersPerAstronomicalUnit;\nvar Ca8 = -11 * 1e-7 * MetersPerAstronomicalUnit;\n\nvar Sa1 = -150 * 1e-7 * MetersPerAstronomicalUnit;\nvar Sa2 = -46 * 1e-7 * MetersPerAstronomicalUnit;\nvar Sa3 = 68 * 1e-7 * MetersPerAstronomicalUnit;\nvar Sa4 = 54 * 1e-7 * MetersPerAstronomicalUnit;\nvar Sa5 = 14 * 1e-7 * MetersPerAstronomicalUnit;\nvar Sa6 = 24 * 1e-7 * MetersPerAstronomicalUnit;\nvar Sa7 = -28 * 1e-7 * MetersPerAstronomicalUnit;\nvar Sa8 = 22 * 1e-7 * MetersPerAstronomicalUnit;\n\nvar q1u = 10;\nvar q2u = 16002;\nvar q3u = 21863;\nvar q4u = 10931;\nvar q5u = 1473;\nvar q6u = 32004;\nvar q7u = 4387;\nvar q8u = 73;\n\nvar Cl1 = -325 * 1e-7;\nvar Cl2 = -322 * 1e-7;\nvar Cl3 = -79 * 1e-7;\nvar Cl4 = 232 * 1e-7;\nvar Cl5 = -52 * 1e-7;\nvar Cl6 = 97 * 1e-7;\nvar Cl7 = 55 * 1e-7;\nvar Cl8 = -41 * 1e-7;\n\nvar Sl1 = -105 * 1e-7;\nvar Sl2 = -137 * 1e-7;\nvar Sl3 = 258 * 1e-7;\nvar Sl4 = 35 * 1e-7;\nvar Sl5 = -116 * 1e-7;\nvar Sl6 = -88 * 1e-7;\nvar Sl7 = -112 * 1e-7;\nvar Sl8 = -80 * 1e-7;\n\nvar scratchDate = new _JulianDate_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"] */ .Z(0, 0.0, _TimeStandard_js__WEBPACK_IMPORTED_MODULE_6__/* ["default"].TAI */ .Z.TAI);\n// Gets a point describing the motion of the Earth-Moon barycenter according to the equations described in section 6.\nfunction computeSimonEarthMoonBarycenter(date, result) {\n  // t is thousands of years from J2000 TDB\n  taiToTdb(date, scratchDate);\n  var x =\n    scratchDate.dayNumber -\n    epoch.dayNumber +\n    (scratchDate.secondsOfDay - epoch.secondsOfDay) /\n      _TimeConstants_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"].SECONDS_PER_DAY */ .Z.SECONDS_PER_DAY;\n  var t = x / (_TimeConstants_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"].DAYS_PER_JULIAN_CENTURY */ .Z.DAYS_PER_JULIAN_CENTURY * 10.0);\n\n  var u = 0.3595362 * t;\n  var semimajorAxis =\n    semiMajorAxis0 +\n    Ca1 * Math.cos(p1u * u) +\n    Sa1 * Math.sin(p1u * u) +\n    Ca2 * Math.cos(p2u * u) +\n    Sa2 * Math.sin(p2u * u) +\n    Ca3 * Math.cos(p3u * u) +\n    Sa3 * Math.sin(p3u * u) +\n    Ca4 * Math.cos(p4u * u) +\n    Sa4 * Math.sin(p4u * u) +\n    Ca5 * Math.cos(p5u * u) +\n    Sa5 * Math.sin(p5u * u) +\n    Ca6 * Math.cos(p6u * u) +\n    Sa6 * Math.sin(p6u * u) +\n    Ca7 * Math.cos(p7u * u) +\n    Sa7 * Math.sin(p7u * u) +\n    Ca8 * Math.cos(p8u * u) +\n    Sa8 * Math.sin(p8u * u);\n  var meanLongitude =\n    meanLongitude0 +\n    meanLongitude1 * t +\n    Cl1 * Math.cos(q1u * u) +\n    Sl1 * Math.sin(q1u * u) +\n    Cl2 * Math.cos(q2u * u) +\n    Sl2 * Math.sin(q2u * u) +\n    Cl3 * Math.cos(q3u * u) +\n    Sl3 * Math.sin(q3u * u) +\n    Cl4 * Math.cos(q4u * u) +\n    Sl4 * Math.sin(q4u * u) +\n    Cl5 * Math.cos(q5u * u) +\n    Sl5 * Math.sin(q5u * u) +\n    Cl6 * Math.cos(q6u * u) +\n    Sl6 * Math.sin(q6u * u) +\n    Cl7 * Math.cos(q7u * u) +\n    Sl7 * Math.sin(q7u * u) +\n    Cl8 * Math.cos(q8u * u) +\n    Sl8 * Math.sin(q8u * u);\n\n  // All constants in this part are from section 5.8\n  var eccentricity = 0.0167086342 - 0.0004203654 * t;\n  var longitudeOfPerigee =\n    102.93734808 * RadiansPerDegree + 11612.3529 * RadiansPerArcSecond * t;\n  var inclination = 469.97289 * RadiansPerArcSecond * t;\n  var longitudeOfNode =\n    174.87317577 * RadiansPerDegree - 8679.27034 * RadiansPerArcSecond * t;\n\n  return elementsToCartesian(\n    semimajorAxis,\n    eccentricity,\n    inclination,\n    longitudeOfPerigee,\n    longitudeOfNode,\n    meanLongitude,\n    result\n  );\n}\n\n// Gets a point describing the position of the moon according to the equations described in section 4.\nfunction computeSimonMoon(date, result) {\n  taiToTdb(date, scratchDate);\n  var x =\n    scratchDate.dayNumber -\n    epoch.dayNumber +\n    (scratchDate.secondsOfDay - epoch.secondsOfDay) /\n      _TimeConstants_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"].SECONDS_PER_DAY */ .Z.SECONDS_PER_DAY;\n  var t = x / _TimeConstants_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"].DAYS_PER_JULIAN_CENTURY */ .Z.DAYS_PER_JULIAN_CENTURY;\n  var t2 = t * t;\n  var t3 = t2 * t;\n  var t4 = t3 * t;\n\n  // Terms from section 3.4 (b.1)\n  var semimajorAxis = 383397.7725 + 0.004 * t;\n  var eccentricity = 0.055545526 - 0.000000016 * t;\n  var inclinationConstant = 5.15668983 * RadiansPerDegree;\n  var inclinationSecPart =\n    -0.00008 * t + 0.02966 * t2 - 0.000042 * t3 - 0.00000013 * t4;\n  var longitudeOfPerigeeConstant = 83.35324312 * RadiansPerDegree;\n  var longitudeOfPerigeeSecPart =\n    14643420.2669 * t - 38.2702 * t2 - 0.045047 * t3 + 0.00021301 * t4;\n  var longitudeOfNodeConstant = 125.04455501 * RadiansPerDegree;\n  var longitudeOfNodeSecPart =\n    -6967919.3631 * t + 6.3602 * t2 + 0.007625 * t3 - 0.00003586 * t4;\n  var meanLongitudeConstant = 218.31664563 * RadiansPerDegree;\n  var meanLongitudeSecPart =\n    1732559343.4847 * t - 6.391 * t2 + 0.006588 * t3 - 0.00003169 * t4;\n\n  // Delaunay arguments from section 3.5 b\n  var D =\n    297.85019547 * RadiansPerDegree +\n    RadiansPerArcSecond *\n      (1602961601.209 * t - 6.3706 * t2 + 0.006593 * t3 - 0.00003169 * t4);\n  var F =\n    93.27209062 * RadiansPerDegree +\n    RadiansPerArcSecond *\n      (1739527262.8478 * t - 12.7512 * t2 - 0.001037 * t3 + 0.00000417 * t4);\n  var l =\n    134.96340251 * RadiansPerDegree +\n    RadiansPerArcSecond *\n      (1717915923.2178 * t + 31.8792 * t2 + 0.051635 * t3 - 0.0002447 * t4);\n  var lprime =\n    357.52910918 * RadiansPerDegree +\n    RadiansPerArcSecond *\n      (129596581.0481 * t - 0.5532 * t2 + 0.000136 * t3 - 0.00001149 * t4);\n  var psi =\n    310.17137918 * RadiansPerDegree -\n    RadiansPerArcSecond *\n      (6967051.436 * t + 6.2068 * t2 + 0.007618 * t3 - 0.00003219 * t4);\n\n  // Add terms from Table 4\n  var twoD = 2.0 * D;\n  var fourD = 4.0 * D;\n  var sixD = 6.0 * D;\n  var twol = 2.0 * l;\n  var threel = 3.0 * l;\n  var fourl = 4.0 * l;\n  var twoF = 2.0 * F;\n  semimajorAxis +=\n    3400.4 * Math.cos(twoD) -\n    635.6 * Math.cos(twoD - l) -\n    235.6 * Math.cos(l) +\n    218.1 * Math.cos(twoD - lprime) +\n    181.0 * Math.cos(twoD + l);\n  eccentricity +=\n    0.014216 * Math.cos(twoD - l) +\n    0.008551 * Math.cos(twoD - twol) -\n    0.001383 * Math.cos(l) +\n    0.001356 * Math.cos(twoD + l) -\n    0.001147 * Math.cos(fourD - threel) -\n    0.000914 * Math.cos(fourD - twol) +\n    0.000869 * Math.cos(twoD - lprime - l) -\n    0.000627 * Math.cos(twoD) -\n    0.000394 * Math.cos(fourD - fourl) +\n    0.000282 * Math.cos(twoD - lprime - twol) -\n    0.000279 * Math.cos(D - l) -\n    0.000236 * Math.cos(twol) +\n    0.000231 * Math.cos(fourD) +\n    0.000229 * Math.cos(sixD - fourl) -\n    0.000201 * Math.cos(twol - twoF);\n  inclinationSecPart +=\n    486.26 * Math.cos(twoD - twoF) -\n    40.13 * Math.cos(twoD) +\n    37.51 * Math.cos(twoF) +\n    25.73 * Math.cos(twol - twoF) +\n    19.97 * Math.cos(twoD - lprime - twoF);\n  longitudeOfPerigeeSecPart +=\n    -55609 * Math.sin(twoD - l) -\n    34711 * Math.sin(twoD - twol) -\n    9792 * Math.sin(l) +\n    9385 * Math.sin(fourD - threel) +\n    7505 * Math.sin(fourD - twol) +\n    5318 * Math.sin(twoD + l) +\n    3484 * Math.sin(fourD - fourl) -\n    3417 * Math.sin(twoD - lprime - l) -\n    2530 * Math.sin(sixD - fourl) -\n    2376 * Math.sin(twoD) -\n    2075 * Math.sin(twoD - threel) -\n    1883 * Math.sin(twol) -\n    1736 * Math.sin(sixD - 5.0 * l) +\n    1626 * Math.sin(lprime) -\n    1370 * Math.sin(sixD - threel);\n  longitudeOfNodeSecPart +=\n    -5392 * Math.sin(twoD - twoF) -\n    540 * Math.sin(lprime) -\n    441 * Math.sin(twoD) +\n    423 * Math.sin(twoF) -\n    288 * Math.sin(twol - twoF);\n  meanLongitudeSecPart +=\n    -3332.9 * Math.sin(twoD) +\n    1197.4 * Math.sin(twoD - l) -\n    662.5 * Math.sin(lprime) +\n    396.3 * Math.sin(l) -\n    218.0 * Math.sin(twoD - lprime);\n\n  // Add terms from Table 5\n  var twoPsi = 2.0 * psi;\n  var threePsi = 3.0 * psi;\n  inclinationSecPart +=\n    46.997 * Math.cos(psi) * t -\n    0.614 * Math.cos(twoD - twoF + psi) * t +\n    0.614 * Math.cos(twoD - twoF - psi) * t -\n    0.0297 * Math.cos(twoPsi) * t2 -\n    0.0335 * Math.cos(psi) * t2 +\n    0.0012 * Math.cos(twoD - twoF + twoPsi) * t2 -\n    0.00016 * Math.cos(psi) * t3 +\n    0.00004 * Math.cos(threePsi) * t3 +\n    0.00004 * Math.cos(twoPsi) * t3;\n  var perigeeAndMean =\n    2.116 * Math.sin(psi) * t -\n    0.111 * Math.sin(twoD - twoF - psi) * t -\n    0.0015 * Math.sin(psi) * t2;\n  longitudeOfPerigeeSecPart += perigeeAndMean;\n  meanLongitudeSecPart += perigeeAndMean;\n  longitudeOfNodeSecPart +=\n    -520.77 * Math.sin(psi) * t +\n    13.66 * Math.sin(twoD - twoF + psi) * t +\n    1.12 * Math.sin(twoD - psi) * t -\n    1.06 * Math.sin(twoF - psi) * t +\n    0.66 * Math.sin(twoPsi) * t2 +\n    0.371 * Math.sin(psi) * t2 -\n    0.035 * Math.sin(twoD - twoF + twoPsi) * t2 -\n    0.015 * Math.sin(twoD - twoF + psi) * t2 +\n    0.0014 * Math.sin(psi) * t3 -\n    0.0011 * Math.sin(threePsi) * t3 -\n    0.0009 * Math.sin(twoPsi) * t3;\n\n  // Add constants and convert units\n  semimajorAxis *= MetersPerKilometer;\n  var inclination =\n    inclinationConstant + inclinationSecPart * RadiansPerArcSecond;\n  var longitudeOfPerigee =\n    longitudeOfPerigeeConstant +\n    longitudeOfPerigeeSecPart * RadiansPerArcSecond;\n  var meanLongitude =\n    meanLongitudeConstant + meanLongitudeSecPart * RadiansPerArcSecond;\n  var longitudeOfNode =\n    longitudeOfNodeConstant + longitudeOfNodeSecPart * RadiansPerArcSecond;\n\n  return elementsToCartesian(\n    semimajorAxis,\n    eccentricity,\n    inclination,\n    longitudeOfPerigee,\n    longitudeOfNode,\n    meanLongitude,\n    result\n  );\n}\n\n// Gets a point describing the motion of the Earth.  This point uses the Moon point and\n// the 1992 mu value (ratio between Moon and Earth masses) in Table 2 of the paper in order\n// to determine the position of the Earth relative to the Earth-Moon barycenter.\nvar moonEarthMassRatio = 0.012300034; // From 1992 mu value in Table 2\nvar factor = (moonEarthMassRatio / (moonEarthMassRatio + 1.0)) * -1;\nfunction computeSimonEarth(date, result) {\n  result = computeSimonMoon(date, result);\n  return _Cartesian3_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].multiplyByScalar */ .Z.multiplyByScalar(result, factor, result);\n}\n\n// Values for the <code>axesTransformation</code> needed for the rotation were found using the STK Components\n// GreographicTransformer on the position of the sun center of mass point and the earth J2000 frame.\n\nvar axesTransformation = new _Matrix3_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .Z(\n  1.0000000000000002,\n  5.619723173785822e-16,\n  4.690511510146299e-19,\n  -5.154129427414611e-16,\n  0.9174820620691819,\n  -0.39777715593191376,\n  -2.23970096136568e-16,\n  0.39777715593191376,\n  0.9174820620691819\n);\nvar translation = new _Cartesian3_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .Z();\n/**\n * Computes the position of the Sun in the Earth-centered inertial frame\n *\n * @param {JulianDate} [julianDate] The time at which to compute the Sun\'s position, if not provided the current system time is used.\n * @param {Cartesian3} [result] The object onto which to store the result.\n * @returns {Cartesian3} Calculated sun position\n */\nSimon1994PlanetaryPositions.computeSunPositionInEarthInertialFrame = function (\n  julianDate,\n  result\n) {\n  if (!(0,_defined_js__WEBPACK_IMPORTED_MODULE_7__/* ["default"] */ .Z)(julianDate)) {\n    julianDate = _JulianDate_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"].now */ .Z.now();\n  }\n\n  if (!(0,_defined_js__WEBPACK_IMPORTED_MODULE_7__/* ["default"] */ .Z)(result)) {\n    result = new _Cartesian3_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .Z();\n  }\n\n  //first forward transformation\n  translation = computeSimonEarthMoonBarycenter(julianDate, translation);\n  result = _Cartesian3_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].negate */ .Z.negate(translation, result);\n\n  //second forward transformation\n  computeSimonEarth(julianDate, translation);\n\n  _Cartesian3_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].subtract */ .Z.subtract(result, translation, result);\n  _Matrix3_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"].multiplyByVector */ .Z.multiplyByVector(axesTransformation, result, result);\n\n  return result;\n};\n\n/**\n * Computes the position of the Moon in the Earth-centered inertial frame\n *\n * @param {JulianDate} [julianDate] The time at which to compute the Sun\'s position, if not provided the current system time is used.\n * @param {Cartesian3} [result] The object onto which to store the result.\n * @returns {Cartesian3} Calculated moon position\n */\nSimon1994PlanetaryPositions.computeMoonPositionInEarthInertialFrame = function (\n  julianDate,\n  result\n) {\n  if (!(0,_defined_js__WEBPACK_IMPORTED_MODULE_7__/* ["default"] */ .Z)(julianDate)) {\n    julianDate = _JulianDate_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"].now */ .Z.now();\n  }\n\n  result = computeSimonMoon(julianDate, result);\n  _Matrix3_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"].multiplyByVector */ .Z.multiplyByVector(axesTransformation, result, result);\n\n  return result;\n};\n/* harmony default export */ __webpack_exports__["Z"] = (Simon1994PlanetaryPositions);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBLFNBQVMsaUdBQTJCO0FBQ3BDOztBQUVBO0FBQ0E7O0FBRUEsNkJBQTZCLDREQUFPO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLCtEQUFVO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBLFdBQVcsWUFBWTtBQUN2QixXQUFXLFlBQVk7QUFDdkIsYUFBYSxZQUFZO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPLGdFQUFPO0FBQ2QsaUJBQWlCLHVFQUFjO0FBQy9COztBQUVBLE9BQU8sZ0VBQU87QUFDZCxpQkFBaUIsK0RBQVU7QUFDM0I7O0FBRUE7QUFDQTtBQUNBLFdBQVcsNkVBQWlCOztBQUU1QjtBQUNBOztBQUVBLEVBQUUsaUZBQW1CO0FBQ3JCLEVBQUUsOEZBQXdCOztBQUUxQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsWUFBWTtBQUN2QixXQUFXLFlBQVk7QUFDdkIsYUFBYSxZQUFZO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPLGdFQUFPO0FBQ2QsaUJBQWlCLHVFQUFjO0FBQy9COztBQUVBO0FBQ0EsRUFBRSw4RkFBd0I7O0FBRTFCO0FBQ0E7QUFDQSx5REFBZSwyQkFBMkIsRUFBQyIsInNvdXJjZXMiOlsid2VicGFjazovL3Z1ZTMtd2VicGFjazUvLi9ub2RlX21vZHVsZXMvY2VzaXVtL1NvdXJjZS9Db3JlL1NpbW9uMTk5NFBsYW5ldGFyeVBvc2l0aW9ucy5qcz8xOTk0Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBDYXJ0ZXNpYW4zIGZyb20gXCIuL0NhcnRlc2lhbjMuanNcIjtcbmltcG9ydCBkZWZpbmVkIGZyb20gXCIuL2RlZmluZWQuanNcIjtcbmltcG9ydCBEZXZlbG9wZXJFcnJvciBmcm9tIFwiLi9EZXZlbG9wZXJFcnJvci5qc1wiO1xuaW1wb3J0IEp1bGlhbkRhdGUgZnJvbSBcIi4vSnVsaWFuRGF0ZS5qc1wiO1xuaW1wb3J0IENlc2l1bU1hdGggZnJvbSBcIi4vTWF0aC5qc1wiO1xuaW1wb3J0IE1hdHJpeDMgZnJvbSBcIi4vTWF0cml4My5qc1wiO1xuaW1wb3J0IFRpbWVDb25zdGFudHMgZnJvbSBcIi4vVGltZUNvbnN0YW50cy5qc1wiO1xuaW1wb3J0IFRpbWVTdGFuZGFyZCBmcm9tIFwiLi9UaW1lU3RhbmRhcmQuanNcIjtcblxuLyoqXG4gKiBDb250YWlucyBmdW5jdGlvbnMgZm9yIGZpbmRpbmcgdGhlIENhcnRlc2lhbiBjb29yZGluYXRlcyBvZiB0aGUgc3VuIGFuZCB0aGUgbW9vbiBpbiB0aGVcbiAqIEVhcnRoLWNlbnRlcmVkIGluZXJ0aWFsIGZyYW1lLlxuICpcbiAqIEBuYW1lc3BhY2UgU2ltb24xOTk0UGxhbmV0YXJ5UG9zaXRpb25zXG4gKi9cbnZhciBTaW1vbjE5OTRQbGFuZXRhcnlQb3NpdGlvbnMgPSB7fTtcblxuZnVuY3Rpb24gY29tcHV0ZVRkYk1pbnVzVHRTcGljZShkYXlzU2luY2VKMjAwMEluVGVycmVzdHJpYWxUaW1lKSB7XG4gIC8qIFNUSyBDb21tZW50cyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICogVGhpcyBmdW5jdGlvbiB1c2VzIGNvbnN0YW50cyBkZXNpZ25lZCB0byBiZSBjb25zaXN0ZW50IHdpdGhcbiAgICogdGhlIFNQSUNFIFRvb2xraXQgZnJvbSBKUEwgdmVyc2lvbiBOMDA1MSAodW5pdGltLmMpXG4gICAqIE0wID0gNi4yMzk5OTZcbiAgICogTTBEb3QgPSAxLjk5MDk2ODcxZS03IHJhZC9zID0gMC4wMTcyMDE5NyByYWQvZFxuICAgKiBFQVJUSF9FQ0MgPSAxLjY3MWUtMlxuICAgKiBUREJfQU1QTCA9IDEuNjU3ZS0zIHNlY3NcbiAgICotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cbiAgLy8qIFZhbHVlcyB0YWtlbiBhcyBzcGVjaWZpZWQgaW4gU1RLIENvbW1lbnRzIGV4Y2VwdDogMC4wMTcyMDE5NyByYWQvZGF5ID0gMS45OTA5Njg3MWUtNyByYWQvc2VjXG4gIC8vKiBIZXJlIHdlIHVzZSB0aGUgbW9yZSBwcmVjaXNlIHZhbHVlIHRha2VuIGZyb20gdGhlIFNQSUNFIHZhbHVlIDEuOTkwOTY4NzFlLTcgcmFkL3NlYyBjb252ZXJ0ZWQgdG8gcmFkL2RheVxuICAvLyogQWxsIG90aGVyIGNvbnN0YW50cyBhcmUgY29uc2lzdGVudCB3aXRoIHRoZSBTUElDRSBpbXBsZW1lbnRhdGlvbiBvZiB0aGUgVERCIGNvbnZlcnNpb25cbiAgLy8qIGV4Y2VwdCB3aGVyZSB3ZSB0cmVhdCB0aGUgaW5kZXBlbmRlbnQgdGltZSBwYXJhbWV0ZXIgdG8gYmUgaW4gVFQgaW5zdGVhZCBvZiBUREIuXG4gIC8vKiBUaGlzIGlzIGFuIGFwcHJveGltYXRpb24gbWFkZSB0byBmYWNpbGl0YXRlIHBlcmZvcm1hbmNlIGR1ZSB0byB0aGUgaGlnaGVyIHByZXZhbGFuY2Ugb2ZcbiAgLy8qIHRoZSBUVDJUREIgY29udmVyc2lvbiBvdmVyIFREQjJUVCBpbiBvcmRlciB0byBhdm9pZCBoYXZpbmcgdG8gaXRlcmF0ZSB3aGVuIGNvbnZlcnRpbmcgdG8gVERCIGZvciB0aGUgSlBMIGVwaGVtZXJpcy5cbiAgLy8qIERheXMgYXJlIHVzZWQgaW5zdGVhZCBvZiBzZWNvbmRzIHRvIHByb3ZpZGUgYSBzbGlnaHQgaW1wcm92ZW1lbnQgaW4gbnVtZXJpY2FsIHByZWNpc2lvbi5cblxuICAvLyogRm9yIG1vcmUgaW5mb3JtYXRpb24gc2VlOlxuICAvLyogaHR0cDovL3d3dy5jdi5ucmFvLmVkdS9+cmZpc2hlci9FcGhlbWVyaWRlcy90aW1lcy5odG1sI1REQlxuICAvLyogZnRwOi8vc3NkLmpwbC5uYXNhLmdvdi9wdWIvZXBoL3BsYW5ldHMvaW9tcy9FeHBsU3VwcGxDaGFwOC5wZGZcblxuICB2YXIgZyA9IDYuMjM5OTk2ICsgMC4wMTcyMDE5Njk2NTQ0ICogZGF5c1NpbmNlSjIwMDBJblRlcnJlc3RyaWFsVGltZTtcbiAgcmV0dXJuIDEuNjU3ZS0zICogTWF0aC5zaW4oZyArIDEuNjcxZS0yICogTWF0aC5zaW4oZykpO1xufVxuXG52YXIgVGR0TWludXNUYWkgPSAzMi4xODQ7XG52YXIgSjIwMDBkID0gMjQ1MTU0NTtcbmZ1bmN0aW9uIHRhaVRvVGRiKGRhdGUsIHJlc3VsdCkge1xuICAvL0NvbnZlcnRzIFRBSSB0byBUVFxuICByZXN1bHQgPSBKdWxpYW5EYXRlLmFkZFNlY29uZHMoZGF0ZSwgVGR0TWludXNUYWksIHJlc3VsdCk7XG5cbiAgLy9Db252ZXJ0cyBUVCB0byBUREJcbiAgdmFyIGRheXMgPSBKdWxpYW5EYXRlLnRvdGFsRGF5cyhyZXN1bHQpIC0gSjIwMDBkO1xuICByZXN1bHQgPSBKdWxpYW5EYXRlLmFkZFNlY29uZHMocmVzdWx0LCBjb21wdXRlVGRiTWludXNUdFNwaWNlKGRheXMpLCByZXN1bHQpO1xuXG4gIHJldHVybiByZXN1bHQ7XG59XG5cbnZhciBlcG9jaCA9IG5ldyBKdWxpYW5EYXRlKDI0NTE1NDUsIDAsIFRpbWVTdGFuZGFyZC5UQUkpOyAvL0FjdHVhbGx5IFREQiAobm90IFRBSSlcbnZhciBNZXRlcnNQZXJLaWxvbWV0ZXIgPSAxMDAwLjA7XG52YXIgUmFkaWFuc1BlckRlZ3JlZSA9IENlc2l1bU1hdGguUkFESUFOU19QRVJfREVHUkVFO1xudmFyIFJhZGlhbnNQZXJBcmNTZWNvbmQgPSBDZXNpdW1NYXRoLlJBRElBTlNfUEVSX0FSQ1NFQ09ORDtcbnZhciBNZXRlcnNQZXJBc3Ryb25vbWljYWxVbml0ID0gMS40OTU5Nzg3ZTExOyAvLyBJQVUgMTk3NiB2YWx1ZVxuXG52YXIgcGVyaWZvY2FsVG9FcXVhdG9yaWFsID0gbmV3IE1hdHJpeDMoKTtcbmZ1bmN0aW9uIGVsZW1lbnRzVG9DYXJ0ZXNpYW4oXG4gIHNlbWltYWpvckF4aXMsXG4gIGVjY2VudHJpY2l0eSxcbiAgaW5jbGluYXRpb24sXG4gIGxvbmdpdHVkZU9mUGVyaWdlZSxcbiAgbG9uZ2l0dWRlT2ZOb2RlLFxuICBtZWFuTG9uZ2l0dWRlLFxuICByZXN1bHRcbikge1xuICBpZiAoaW5jbGluYXRpb24gPCAwLjApIHtcbiAgICBpbmNsaW5hdGlvbiA9IC1pbmNsaW5hdGlvbjtcbiAgICBsb25naXR1ZGVPZk5vZGUgKz0gQ2VzaXVtTWF0aC5QSTtcbiAgfVxuXG4gIC8vPj5pbmNsdWRlU3RhcnQoJ2RlYnVnJywgcHJhZ21hcy5kZWJ1Zyk7XG4gIGlmIChpbmNsaW5hdGlvbiA8IDAgfHwgaW5jbGluYXRpb24gPiBDZXNpdW1NYXRoLlBJKSB7XG4gICAgdGhyb3cgbmV3IERldmVsb3BlckVycm9yKFxuICAgICAgXCJUaGUgaW5jbGluYXRpb24gaXMgb3V0IG9mIHJhbmdlLiBJbmNsaW5hdGlvbiBtdXN0IGJlIGdyZWF0ZXIgdGhhbiBvciBlcXVhbCB0byB6ZXJvIGFuZCBsZXNzIHRoYW4gb3IgZXF1YWwgdG8gUGkgcmFkaWFucy5cIlxuICAgICk7XG4gIH1cbiAgLy8+PmluY2x1ZGVFbmQoJ2RlYnVnJylcblxuICB2YXIgcmFkaXVzT2ZQZXJpYXBzaXMgPSBzZW1pbWFqb3JBeGlzICogKDEuMCAtIGVjY2VudHJpY2l0eSk7XG4gIHZhciBhcmd1bWVudE9mUGVyaWFwc2lzID0gbG9uZ2l0dWRlT2ZQZXJpZ2VlIC0gbG9uZ2l0dWRlT2ZOb2RlO1xuICB2YXIgcmlnaHRBc2NlbnNpb25PZkFzY2VuZGluZ05vZGUgPSBsb25naXR1ZGVPZk5vZGU7XG4gIHZhciB0cnVlQW5vbWFseSA9IG1lYW5Bbm9tYWx5VG9UcnVlQW5vbWFseShcbiAgICBtZWFuTG9uZ2l0dWRlIC0gbG9uZ2l0dWRlT2ZQZXJpZ2VlLFxuICAgIGVjY2VudHJpY2l0eVxuICApO1xuICB2YXIgdHlwZSA9IGNob29zZU9yYml0KGVjY2VudHJpY2l0eSwgMC4wKTtcblxuICAvLz4+aW5jbHVkZVN0YXJ0KCdkZWJ1ZycsIHByYWdtYXMuZGVidWcpO1xuICBpZiAoXG4gICAgdHlwZSA9PT0gXCJIeXBlcmJvbGljXCIgJiZcbiAgICBNYXRoLmFicyhDZXNpdW1NYXRoLm5lZ2F0aXZlUGlUb1BpKHRydWVBbm9tYWx5KSkgPj1cbiAgICAgIE1hdGguYWNvcygtMS4wIC8gZWNjZW50cmljaXR5KVxuICApIHtcbiAgICB0aHJvdyBuZXcgRGV2ZWxvcGVyRXJyb3IoXG4gICAgICBcIlRoZSB0cnVlIGFub21hbHkgb2YgdGhlIGh5cGVyYm9saWMgb3JiaXQgbGllcyBvdXRzaWRlIG9mIHRoZSBib3VuZHMgb2YgdGhlIGh5cGVyYm9sYS5cIlxuICAgICk7XG4gIH1cbiAgLy8+PmluY2x1ZGVFbmQoJ2RlYnVnJylcblxuICBwZXJpZm9jYWxUb0NhcnRlc2lhbk1hdHJpeChcbiAgICBhcmd1bWVudE9mUGVyaWFwc2lzLFxuICAgIGluY2xpbmF0aW9uLFxuICAgIHJpZ2h0QXNjZW5zaW9uT2ZBc2NlbmRpbmdOb2RlLFxuICAgIHBlcmlmb2NhbFRvRXF1YXRvcmlhbFxuICApO1xuICB2YXIgc2VtaWxhdHVzID0gcmFkaXVzT2ZQZXJpYXBzaXMgKiAoMS4wICsgZWNjZW50cmljaXR5KTtcbiAgdmFyIGNvc3RoZXRhID0gTWF0aC5jb3ModHJ1ZUFub21hbHkpO1xuICB2YXIgc2ludGhldGEgPSBNYXRoLnNpbih0cnVlQW5vbWFseSk7XG5cbiAgdmFyIGRlbm9tID0gMS4wICsgZWNjZW50cmljaXR5ICogY29zdGhldGE7XG5cbiAgLy8+PmluY2x1ZGVTdGFydCgnZGVidWcnLCBwcmFnbWFzLmRlYnVnKTtcbiAgaWYgKGRlbm9tIDw9IENlc2l1bU1hdGguRXBzaWxvbjEwKSB7XG4gICAgdGhyb3cgbmV3IERldmVsb3BlckVycm9yKFwiZWxlbWVudHMgY2Fubm90IGJlIGNvbnZlcnRlZCB0byBjYXJ0ZXNpYW5cIik7XG4gIH1cbiAgLy8+PmluY2x1ZGVFbmQoJ2RlYnVnJylcblxuICB2YXIgcmFkaXVzID0gc2VtaWxhdHVzIC8gZGVub207XG4gIGlmICghZGVmaW5lZChyZXN1bHQpKSB7XG4gICAgcmVzdWx0ID0gbmV3IENhcnRlc2lhbjMocmFkaXVzICogY29zdGhldGEsIHJhZGl1cyAqIHNpbnRoZXRhLCAwLjApO1xuICB9IGVsc2Uge1xuICAgIHJlc3VsdC54ID0gcmFkaXVzICogY29zdGhldGE7XG4gICAgcmVzdWx0LnkgPSByYWRpdXMgKiBzaW50aGV0YTtcbiAgICByZXN1bHQueiA9IDAuMDtcbiAgfVxuXG4gIHJldHVybiBNYXRyaXgzLm11bHRpcGx5QnlWZWN0b3IocGVyaWZvY2FsVG9FcXVhdG9yaWFsLCByZXN1bHQsIHJlc3VsdCk7XG59XG5cbmZ1bmN0aW9uIGNob29zZU9yYml0KGVjY2VudHJpY2l0eSwgdG9sZXJhbmNlKSB7XG4gIC8vPj5pbmNsdWRlU3RhcnQoJ2RlYnVnJywgcHJhZ21hcy5kZWJ1Zyk7XG4gIGlmIChlY2NlbnRyaWNpdHkgPCAwKSB7XG4gICAgdGhyb3cgbmV3IERldmVsb3BlckVycm9yKFwiZWNjZW50cmljaXR5IGNhbm5vdCBiZSBuZWdhdGl2ZS5cIik7XG4gIH1cbiAgLy8+PmluY2x1ZGVFbmQoJ2RlYnVnJylcblxuICBpZiAoZWNjZW50cmljaXR5IDw9IHRvbGVyYW5jZSkge1xuICAgIHJldHVybiBcIkNpcmN1bGFyXCI7XG4gIH0gZWxzZSBpZiAoZWNjZW50cmljaXR5IDwgMS4wIC0gdG9sZXJhbmNlKSB7XG4gICAgcmV0dXJuIFwiRWxsaXB0aWNhbFwiO1xuICB9IGVsc2UgaWYgKGVjY2VudHJpY2l0eSA8PSAxLjAgKyB0b2xlcmFuY2UpIHtcbiAgICByZXR1cm4gXCJQYXJhYm9saWNcIjtcbiAgfVxuICByZXR1cm4gXCJIeXBlcmJvbGljXCI7XG59XG5cbi8vIENhbGN1bGF0ZXMgdGhlIHRydWUgYW5vbWFseSBnaXZlbiB0aGUgbWVhbiBhbm9tYWx5IGFuZCB0aGUgZWNjZW50cmljaXR5LlxuZnVuY3Rpb24gbWVhbkFub21hbHlUb1RydWVBbm9tYWx5KG1lYW5Bbm9tYWx5LCBlY2NlbnRyaWNpdHkpIHtcbiAgLy8+PmluY2x1ZGVTdGFydCgnZGVidWcnLCBwcmFnbWFzLmRlYnVnKTtcbiAgaWYgKGVjY2VudHJpY2l0eSA8IDAuMCB8fCBlY2NlbnRyaWNpdHkgPj0gMS4wKSB7XG4gICAgdGhyb3cgbmV3IERldmVsb3BlckVycm9yKFwiZWNjZW50cmljaXR5IG91dCBvZiByYW5nZS5cIik7XG4gIH1cbiAgLy8+PmluY2x1ZGVFbmQoJ2RlYnVnJylcblxuICB2YXIgZWNjZW50cmljQW5vbWFseSA9IG1lYW5Bbm9tYWx5VG9FY2NlbnRyaWNBbm9tYWx5KFxuICAgIG1lYW5Bbm9tYWx5LFxuICAgIGVjY2VudHJpY2l0eVxuICApO1xuICByZXR1cm4gZWNjZW50cmljQW5vbWFseVRvVHJ1ZUFub21hbHkoZWNjZW50cmljQW5vbWFseSwgZWNjZW50cmljaXR5KTtcbn1cblxudmFyIG1heEl0ZXJhdGlvbkNvdW50ID0gNTA7XG52YXIga2VwbGVyRXFDb252ZXJnZW5jZSA9IENlc2l1bU1hdGguRVBTSUxPTjg7XG4vLyBDYWxjdWxhdGVzIHRoZSBlY2NlbnRyaWMgYW5vbWFseSBnaXZlbiB0aGUgbWVhbiBhbm9tYWx5IGFuZCB0aGUgZWNjZW50cmljaXR5LlxuZnVuY3Rpb24gbWVhbkFub21hbHlUb0VjY2VudHJpY0Fub21hbHkobWVhbkFub21hbHksIGVjY2VudHJpY2l0eSkge1xuICAvLz4+aW5jbHVkZVN0YXJ0KCdkZWJ1ZycsIHByYWdtYXMuZGVidWcpO1xuICBpZiAoZWNjZW50cmljaXR5IDwgMC4wIHx8IGVjY2VudHJpY2l0eSA+PSAxLjApIHtcbiAgICB0aHJvdyBuZXcgRGV2ZWxvcGVyRXJyb3IoXCJlY2NlbnRyaWNpdHkgb3V0IG9mIHJhbmdlLlwiKTtcbiAgfVxuICAvLz4+aW5jbHVkZUVuZCgnZGVidWcnKVxuXG4gIHZhciByZXZzID0gTWF0aC5mbG9vcihtZWFuQW5vbWFseSAvIENlc2l1bU1hdGguVFdPX1BJKTtcblxuICAvLyBGaW5kIGFuZ2xlIGluIGN1cnJlbnQgcmV2b2x1dGlvblxuICBtZWFuQW5vbWFseSAtPSByZXZzICogQ2VzaXVtTWF0aC5UV09fUEk7XG5cbiAgLy8gY2FsY3VsYXRlIHN0YXJ0aW5nIHZhbHVlIGZvciBpdGVyYXRpb24gc2VxdWVuY2VcbiAgdmFyIGl0ZXJhdGlvblZhbHVlID1cbiAgICBtZWFuQW5vbWFseSArXG4gICAgKGVjY2VudHJpY2l0eSAqIE1hdGguc2luKG1lYW5Bbm9tYWx5KSkgL1xuICAgICAgKDEuMCAtIE1hdGguc2luKG1lYW5Bbm9tYWx5ICsgZWNjZW50cmljaXR5KSArIE1hdGguc2luKG1lYW5Bbm9tYWx5KSk7XG5cbiAgLy8gUGVyZm9ybSBOZXd0b24tUmFwaHNvbiBpdGVyYXRpb24gb24gS2VwbGVyJ3MgZXF1YXRpb25cbiAgdmFyIGVjY2VudHJpY0Fub21hbHkgPSBOdW1iZXIuTUFYX1ZBTFVFO1xuXG4gIHZhciBjb3VudDtcbiAgZm9yIChcbiAgICBjb3VudCA9IDA7XG4gICAgY291bnQgPCBtYXhJdGVyYXRpb25Db3VudCAmJlxuICAgIE1hdGguYWJzKGVjY2VudHJpY0Fub21hbHkgLSBpdGVyYXRpb25WYWx1ZSkgPiBrZXBsZXJFcUNvbnZlcmdlbmNlO1xuICAgICsrY291bnRcbiAgKSB7XG4gICAgZWNjZW50cmljQW5vbWFseSA9IGl0ZXJhdGlvblZhbHVlO1xuICAgIHZhciBOUmZ1bmN0aW9uID1cbiAgICAgIGVjY2VudHJpY0Fub21hbHkgLVxuICAgICAgZWNjZW50cmljaXR5ICogTWF0aC5zaW4oZWNjZW50cmljQW5vbWFseSkgLVxuICAgICAgbWVhbkFub21hbHk7XG4gICAgdmFyIGROUmZ1bmN0aW9uID0gMSAtIGVjY2VudHJpY2l0eSAqIE1hdGguY29zKGVjY2VudHJpY0Fub21hbHkpO1xuICAgIGl0ZXJhdGlvblZhbHVlID0gZWNjZW50cmljQW5vbWFseSAtIE5SZnVuY3Rpb24gLyBkTlJmdW5jdGlvbjtcbiAgfVxuXG4gIC8vPj5pbmNsdWRlU3RhcnQoJ2RlYnVnJywgcHJhZ21hcy5kZWJ1Zyk7XG4gIGlmIChjb3VudCA+PSBtYXhJdGVyYXRpb25Db3VudCkge1xuICAgIHRocm93IG5ldyBEZXZlbG9wZXJFcnJvcihcIktlcGxlciBlcXVhdGlvbiBkaWQgbm90IGNvbnZlcmdlXCIpO1xuICAgIC8vIFNUSyBDb21wb25lbnRzIHVzZXMgYSBudW1lcmljYWwgbWV0aG9kIHRvIGZpbmQgdGhlIGVjY2VudHJpYyBhbm9tYWx5IGluIHRoZSBjYXNlIHRoYXQgS2VwbGVyJ3NcbiAgICAvLyBlcXVhdGlvbiBkb2VzIG5vdCBjb252ZXJnZS4gV2UgZG9uJ3QgZXhwZWN0IHRoYXQgdG8gZXZlciBiZSBuZWNlc3NhcnkgZm9yIHRoZSByZWFzb25hYmxlIG9yYml0cyB1c2VkIGhlcmUuXG4gIH1cbiAgLy8+PmluY2x1ZGVFbmQoJ2RlYnVnJylcblxuICBlY2NlbnRyaWNBbm9tYWx5ID0gaXRlcmF0aW9uVmFsdWUgKyByZXZzICogQ2VzaXVtTWF0aC5UV09fUEk7XG4gIHJldHVybiBlY2NlbnRyaWNBbm9tYWx5O1xufVxuXG4vLyBDYWxjdWxhdGVzIHRoZSB0cnVlIGFub21hbHkgZ2l2ZW4gdGhlIGVjY2VudHJpYyBhbm9tYWx5IGFuZCB0aGUgZWNjZW50cmljaXR5LlxuZnVuY3Rpb24gZWNjZW50cmljQW5vbWFseVRvVHJ1ZUFub21hbHkoZWNjZW50cmljQW5vbWFseSwgZWNjZW50cmljaXR5KSB7XG4gIC8vPj5pbmNsdWRlU3RhcnQoJ2RlYnVnJywgcHJhZ21hcy5kZWJ1Zyk7XG4gIGlmIChlY2NlbnRyaWNpdHkgPCAwLjAgfHwgZWNjZW50cmljaXR5ID49IDEuMCkge1xuICAgIHRocm93IG5ldyBEZXZlbG9wZXJFcnJvcihcImVjY2VudHJpY2l0eSBvdXQgb2YgcmFuZ2UuXCIpO1xuICB9XG4gIC8vPj5pbmNsdWRlRW5kKCdkZWJ1ZycpXG5cbiAgLy8gQ2FsY3VsYXRlIHRoZSBudW1iZXIgb2YgcHJldmlvdXMgcmV2b2x1dGlvbnNcbiAgdmFyIHJldnMgPSBNYXRoLmZsb29yKGVjY2VudHJpY0Fub21hbHkgLyBDZXNpdW1NYXRoLlRXT19QSSk7XG5cbiAgLy8gRmluZCBhbmdsZSBpbiBjdXJyZW50IHJldm9sdXRpb25cbiAgZWNjZW50cmljQW5vbWFseSAtPSByZXZzICogQ2VzaXVtTWF0aC5UV09fUEk7XG5cbiAgLy8gQ2FsY3VsYXRlIHRydWUgYW5vbWFseSBmcm9tIGVjY2VudHJpYyBhbm9tYWx5XG4gIHZhciB0cnVlQW5vbWFseVggPSBNYXRoLmNvcyhlY2NlbnRyaWNBbm9tYWx5KSAtIGVjY2VudHJpY2l0eTtcbiAgdmFyIHRydWVBbm9tYWx5WSA9XG4gICAgTWF0aC5zaW4oZWNjZW50cmljQW5vbWFseSkgKiBNYXRoLnNxcnQoMSAtIGVjY2VudHJpY2l0eSAqIGVjY2VudHJpY2l0eSk7XG5cbiAgdmFyIHRydWVBbm9tYWx5ID0gTWF0aC5hdGFuMih0cnVlQW5vbWFseVksIHRydWVBbm9tYWx5WCk7XG5cbiAgLy8gRW5zdXJlIHRoZSBjb3JyZWN0IHF1YWRyYW50XG4gIHRydWVBbm9tYWx5ID0gQ2VzaXVtTWF0aC56ZXJvVG9Ud29QaSh0cnVlQW5vbWFseSk7XG4gIGlmIChlY2NlbnRyaWNBbm9tYWx5IDwgMCkge1xuICAgIHRydWVBbm9tYWx5IC09IENlc2l1bU1hdGguVFdPX1BJO1xuICB9XG5cbiAgLy8gQWRkIG9uIHByZXZpb3VzIHJldm9sdXRpb25zXG4gIHRydWVBbm9tYWx5ICs9IHJldnMgKiBDZXNpdW1NYXRoLlRXT19QSTtcblxuICByZXR1cm4gdHJ1ZUFub21hbHk7XG59XG5cbi8vIENhbGN1bGF0ZXMgdGhlIHRyYW5zZm9ybWF0aW9uIG1hdHJpeCB0byBjb252ZXJ0IGZyb20gdGhlIHBlcmlmb2NhbCAoUFFXKSBjb29yZGluYXRlXG4vLyBzeXN0ZW0gdG8gaW5lcnRpYWwgY2FydGVzaWFuIGNvb3JkaW5hdGVzLlxuZnVuY3Rpb24gcGVyaWZvY2FsVG9DYXJ0ZXNpYW5NYXRyaXgoXG4gIGFyZ3VtZW50T2ZQZXJpYXBzaXMsXG4gIGluY2xpbmF0aW9uLFxuICByaWdodEFzY2Vuc2lvbixcbiAgcmVzdWx0XG4pIHtcbiAgLy8+PmluY2x1ZGVTdGFydCgnZGVidWcnLCBwcmFnbWFzLmRlYnVnKTtcbiAgaWYgKGluY2xpbmF0aW9uIDwgMCB8fCBpbmNsaW5hdGlvbiA+IENlc2l1bU1hdGguUEkpIHtcbiAgICB0aHJvdyBuZXcgRGV2ZWxvcGVyRXJyb3IoXCJpbmNsaW5hdGlvbiBvdXQgb2YgcmFuZ2VcIik7XG4gIH1cbiAgLy8+PmluY2x1ZGVFbmQoJ2RlYnVnJylcblxuICB2YXIgY29zYXAgPSBNYXRoLmNvcyhhcmd1bWVudE9mUGVyaWFwc2lzKTtcbiAgdmFyIHNpbmFwID0gTWF0aC5zaW4oYXJndW1lbnRPZlBlcmlhcHNpcyk7XG5cbiAgdmFyIGNvc2kgPSBNYXRoLmNvcyhpbmNsaW5hdGlvbik7XG4gIHZhciBzaW5pID0gTWF0aC5zaW4oaW5jbGluYXRpb24pO1xuXG4gIHZhciBjb3NyYWFuID0gTWF0aC5jb3MocmlnaHRBc2NlbnNpb24pO1xuICB2YXIgc2lucmFhbiA9IE1hdGguc2luKHJpZ2h0QXNjZW5zaW9uKTtcbiAgaWYgKCFkZWZpbmVkKHJlc3VsdCkpIHtcbiAgICByZXN1bHQgPSBuZXcgTWF0cml4MyhcbiAgICAgIGNvc3JhYW4gKiBjb3NhcCAtIHNpbnJhYW4gKiBzaW5hcCAqIGNvc2ksXG4gICAgICAtY29zcmFhbiAqIHNpbmFwIC0gc2lucmFhbiAqIGNvc2FwICogY29zaSxcbiAgICAgIHNpbnJhYW4gKiBzaW5pLFxuXG4gICAgICBzaW5yYWFuICogY29zYXAgKyBjb3NyYWFuICogc2luYXAgKiBjb3NpLFxuICAgICAgLXNpbnJhYW4gKiBzaW5hcCArIGNvc3JhYW4gKiBjb3NhcCAqIGNvc2ksXG4gICAgICAtY29zcmFhbiAqIHNpbmksXG5cbiAgICAgIHNpbmFwICogc2luaSxcbiAgICAgIGNvc2FwICogc2luaSxcbiAgICAgIGNvc2lcbiAgICApO1xuICB9IGVsc2Uge1xuICAgIHJlc3VsdFswXSA9IGNvc3JhYW4gKiBjb3NhcCAtIHNpbnJhYW4gKiBzaW5hcCAqIGNvc2k7XG4gICAgcmVzdWx0WzFdID0gc2lucmFhbiAqIGNvc2FwICsgY29zcmFhbiAqIHNpbmFwICogY29zaTtcbiAgICByZXN1bHRbMl0gPSBzaW5hcCAqIHNpbmk7XG4gICAgcmVzdWx0WzNdID0gLWNvc3JhYW4gKiBzaW5hcCAtIHNpbnJhYW4gKiBjb3NhcCAqIGNvc2k7XG4gICAgcmVzdWx0WzRdID0gLXNpbnJhYW4gKiBzaW5hcCArIGNvc3JhYW4gKiBjb3NhcCAqIGNvc2k7XG4gICAgcmVzdWx0WzVdID0gY29zYXAgKiBzaW5pO1xuICAgIHJlc3VsdFs2XSA9IHNpbnJhYW4gKiBzaW5pO1xuICAgIHJlc3VsdFs3XSA9IC1jb3NyYWFuICogc2luaTtcbiAgICByZXN1bHRbOF0gPSBjb3NpO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbi8vIEZyb20gc2VjdGlvbiA1LjhcbnZhciBzZW1pTWFqb3JBeGlzMCA9IDEuMDAwMDAxMDE3OCAqIE1ldGVyc1BlckFzdHJvbm9taWNhbFVuaXQ7XG52YXIgbWVhbkxvbmdpdHVkZTAgPSAxMDAuNDY2NDU2ODMgKiBSYWRpYW5zUGVyRGVncmVlO1xudmFyIG1lYW5Mb25naXR1ZGUxID0gMTI5NTk3NzQyMi44MzQyOSAqIFJhZGlhbnNQZXJBcmNTZWNvbmQ7XG5cbi8vIEZyb20gdGFibGUgNlxudmFyIHAxdSA9IDE2MDAyO1xudmFyIHAydSA9IDIxODYzO1xudmFyIHAzdSA9IDMyMDA0O1xudmFyIHA0dSA9IDEwOTMxO1xudmFyIHA1dSA9IDE0NTI5O1xudmFyIHA2dSA9IDE2MzY4O1xudmFyIHA3dSA9IDE1MzE4O1xudmFyIHA4dSA9IDMyNzk0O1xuXG52YXIgQ2ExID0gNjQgKiAxZS03ICogTWV0ZXJzUGVyQXN0cm9ub21pY2FsVW5pdDtcbnZhciBDYTIgPSAtMTUyICogMWUtNyAqIE1ldGVyc1BlckFzdHJvbm9taWNhbFVuaXQ7XG52YXIgQ2EzID0gNjIgKiAxZS03ICogTWV0ZXJzUGVyQXN0cm9ub21pY2FsVW5pdDtcbnZhciBDYTQgPSAtOCAqIDFlLTcgKiBNZXRlcnNQZXJBc3Ryb25vbWljYWxVbml0O1xudmFyIENhNSA9IDMyICogMWUtNyAqIE1ldGVyc1BlckFzdHJvbm9taWNhbFVuaXQ7XG52YXIgQ2E2ID0gLTQxICogMWUtNyAqIE1ldGVyc1BlckFzdHJvbm9taWNhbFVuaXQ7XG52YXIgQ2E3ID0gMTkgKiAxZS03ICogTWV0ZXJzUGVyQXN0cm9ub21pY2FsVW5pdDtcbnZhciBDYTggPSAtMTEgKiAxZS03ICogTWV0ZXJzUGVyQXN0cm9ub21pY2FsVW5pdDtcblxudmFyIFNhMSA9IC0xNTAgKiAxZS03ICogTWV0ZXJzUGVyQXN0cm9ub21pY2FsVW5pdDtcbnZhciBTYTIgPSAtNDYgKiAxZS03ICogTWV0ZXJzUGVyQXN0cm9ub21pY2FsVW5pdDtcbnZhciBTYTMgPSA2OCAqIDFlLTcgKiBNZXRlcnNQZXJBc3Ryb25vbWljYWxVbml0O1xudmFyIFNhNCA9IDU0ICogMWUtNyAqIE1ldGVyc1BlckFzdHJvbm9taWNhbFVuaXQ7XG52YXIgU2E1ID0gMTQgKiAxZS03ICogTWV0ZXJzUGVyQXN0cm9ub21pY2FsVW5pdDtcbnZhciBTYTYgPSAyNCAqIDFlLTcgKiBNZXRlcnNQZXJBc3Ryb25vbWljYWxVbml0O1xudmFyIFNhNyA9IC0yOCAqIDFlLTcgKiBNZXRlcnNQZXJBc3Ryb25vbWljYWxVbml0O1xudmFyIFNhOCA9IDIyICogMWUtNyAqIE1ldGVyc1BlckFzdHJvbm9taWNhbFVuaXQ7XG5cbnZhciBxMXUgPSAxMDtcbnZhciBxMnUgPSAxNjAwMjtcbnZhciBxM3UgPSAyMTg2MztcbnZhciBxNHUgPSAxMDkzMTtcbnZhciBxNXUgPSAxNDczO1xudmFyIHE2dSA9IDMyMDA0O1xudmFyIHE3dSA9IDQzODc7XG52YXIgcTh1ID0gNzM7XG5cbnZhciBDbDEgPSAtMzI1ICogMWUtNztcbnZhciBDbDIgPSAtMzIyICogMWUtNztcbnZhciBDbDMgPSAtNzkgKiAxZS03O1xudmFyIENsNCA9IDIzMiAqIDFlLTc7XG52YXIgQ2w1ID0gLTUyICogMWUtNztcbnZhciBDbDYgPSA5NyAqIDFlLTc7XG52YXIgQ2w3ID0gNTUgKiAxZS03O1xudmFyIENsOCA9IC00MSAqIDFlLTc7XG5cbnZhciBTbDEgPSAtMTA1ICogMWUtNztcbnZhciBTbDIgPSAtMTM3ICogMWUtNztcbnZhciBTbDMgPSAyNTggKiAxZS03O1xudmFyIFNsNCA9IDM1ICogMWUtNztcbnZhciBTbDUgPSAtMTE2ICogMWUtNztcbnZhciBTbDYgPSAtODggKiAxZS03O1xudmFyIFNsNyA9IC0xMTIgKiAxZS03O1xudmFyIFNsOCA9IC04MCAqIDFlLTc7XG5cbnZhciBzY3JhdGNoRGF0ZSA9IG5ldyBKdWxpYW5EYXRlKDAsIDAuMCwgVGltZVN0YW5kYXJkLlRBSSk7XG4vLyBHZXRzIGEgcG9pbnQgZGVzY3JpYmluZyB0aGUgbW90aW9uIG9mIHRoZSBFYXJ0aC1Nb29uIGJhcnljZW50ZXIgYWNjb3JkaW5nIHRvIHRoZSBlcXVhdGlvbnMgZGVzY3JpYmVkIGluIHNlY3Rpb24gNi5cbmZ1bmN0aW9uIGNvbXB1dGVTaW1vbkVhcnRoTW9vbkJhcnljZW50ZXIoZGF0ZSwgcmVzdWx0KSB7XG4gIC8vIHQgaXMgdGhvdXNhbmRzIG9mIHllYXJzIGZyb20gSjIwMDAgVERCXG4gIHRhaVRvVGRiKGRhdGUsIHNjcmF0Y2hEYXRlKTtcbiAgdmFyIHggPVxuICAgIHNjcmF0Y2hEYXRlLmRheU51bWJlciAtXG4gICAgZXBvY2guZGF5TnVtYmVyICtcbiAgICAoc2NyYXRjaERhdGUuc2Vjb25kc09mRGF5IC0gZXBvY2guc2Vjb25kc09mRGF5KSAvXG4gICAgICBUaW1lQ29uc3RhbnRzLlNFQ09ORFNfUEVSX0RBWTtcbiAgdmFyIHQgPSB4IC8gKFRpbWVDb25zdGFudHMuREFZU19QRVJfSlVMSUFOX0NFTlRVUlkgKiAxMC4wKTtcblxuICB2YXIgdSA9IDAuMzU5NTM2MiAqIHQ7XG4gIHZhciBzZW1pbWFqb3JBeGlzID1cbiAgICBzZW1pTWFqb3JBeGlzMCArXG4gICAgQ2ExICogTWF0aC5jb3MocDF1ICogdSkgK1xuICAgIFNhMSAqIE1hdGguc2luKHAxdSAqIHUpICtcbiAgICBDYTIgKiBNYXRoLmNvcyhwMnUgKiB1KSArXG4gICAgU2EyICogTWF0aC5zaW4ocDJ1ICogdSkgK1xuICAgIENhMyAqIE1hdGguY29zKHAzdSAqIHUpICtcbiAgICBTYTMgKiBNYXRoLnNpbihwM3UgKiB1KSArXG4gICAgQ2E0ICogTWF0aC5jb3MocDR1ICogdSkgK1xuICAgIFNhNCAqIE1hdGguc2luKHA0dSAqIHUpICtcbiAgICBDYTUgKiBNYXRoLmNvcyhwNXUgKiB1KSArXG4gICAgU2E1ICogTWF0aC5zaW4ocDV1ICogdSkgK1xuICAgIENhNiAqIE1hdGguY29zKHA2dSAqIHUpICtcbiAgICBTYTYgKiBNYXRoLnNpbihwNnUgKiB1KSArXG4gICAgQ2E3ICogTWF0aC5jb3MocDd1ICogdSkgK1xuICAgIFNhNyAqIE1hdGguc2luKHA3dSAqIHUpICtcbiAgICBDYTggKiBNYXRoLmNvcyhwOHUgKiB1KSArXG4gICAgU2E4ICogTWF0aC5zaW4ocDh1ICogdSk7XG4gIHZhciBtZWFuTG9uZ2l0dWRlID1cbiAgICBtZWFuTG9uZ2l0dWRlMCArXG4gICAgbWVhbkxvbmdpdHVkZTEgKiB0ICtcbiAgICBDbDEgKiBNYXRoLmNvcyhxMXUgKiB1KSArXG4gICAgU2wxICogTWF0aC5zaW4ocTF1ICogdSkgK1xuICAgIENsMiAqIE1hdGguY29zKHEydSAqIHUpICtcbiAgICBTbDIgKiBNYXRoLnNpbihxMnUgKiB1KSArXG4gICAgQ2wzICogTWF0aC5jb3MocTN1ICogdSkgK1xuICAgIFNsMyAqIE1hdGguc2luKHEzdSAqIHUpICtcbiAgICBDbDQgKiBNYXRoLmNvcyhxNHUgKiB1KSArXG4gICAgU2w0ICogTWF0aC5zaW4ocTR1ICogdSkgK1xuICAgIENsNSAqIE1hdGguY29zKHE1dSAqIHUpICtcbiAgICBTbDUgKiBNYXRoLnNpbihxNXUgKiB1KSArXG4gICAgQ2w2ICogTWF0aC5jb3MocTZ1ICogdSkgK1xuICAgIFNsNiAqIE1hdGguc2luKHE2dSAqIHUpICtcbiAgICBDbDcgKiBNYXRoLmNvcyhxN3UgKiB1KSArXG4gICAgU2w3ICogTWF0aC5zaW4ocTd1ICogdSkgK1xuICAgIENsOCAqIE1hdGguY29zKHE4dSAqIHUpICtcbiAgICBTbDggKiBNYXRoLnNpbihxOHUgKiB1KTtcblxuICAvLyBBbGwgY29uc3RhbnRzIGluIHRoaXMgcGFydCBhcmUgZnJvbSBzZWN0aW9uIDUuOFxuICB2YXIgZWNjZW50cmljaXR5ID0gMC4wMTY3MDg2MzQyIC0gMC4wMDA0MjAzNjU0ICogdDtcbiAgdmFyIGxvbmdpdHVkZU9mUGVyaWdlZSA9XG4gICAgMTAyLjkzNzM0ODA4ICogUmFkaWFuc1BlckRlZ3JlZSArIDExNjEyLjM1MjkgKiBSYWRpYW5zUGVyQXJjU2Vjb25kICogdDtcbiAgdmFyIGluY2xpbmF0aW9uID0gNDY5Ljk3Mjg5ICogUmFkaWFuc1BlckFyY1NlY29uZCAqIHQ7XG4gIHZhciBsb25naXR1ZGVPZk5vZGUgPVxuICAgIDE3NC44NzMxNzU3NyAqIFJhZGlhbnNQZXJEZWdyZWUgLSA4Njc5LjI3MDM0ICogUmFkaWFuc1BlckFyY1NlY29uZCAqIHQ7XG5cbiAgcmV0dXJuIGVsZW1lbnRzVG9DYXJ0ZXNpYW4oXG4gICAgc2VtaW1ham9yQXhpcyxcbiAgICBlY2NlbnRyaWNpdHksXG4gICAgaW5jbGluYXRpb24sXG4gICAgbG9uZ2l0dWRlT2ZQZXJpZ2VlLFxuICAgIGxvbmdpdHVkZU9mTm9kZSxcbiAgICBtZWFuTG9uZ2l0dWRlLFxuICAgIHJlc3VsdFxuICApO1xufVxuXG4vLyBHZXRzIGEgcG9pbnQgZGVzY3JpYmluZyB0aGUgcG9zaXRpb24gb2YgdGhlIG1vb24gYWNjb3JkaW5nIHRvIHRoZSBlcXVhdGlvbnMgZGVzY3JpYmVkIGluIHNlY3Rpb24gNC5cbmZ1bmN0aW9uIGNvbXB1dGVTaW1vbk1vb24oZGF0ZSwgcmVzdWx0KSB7XG4gIHRhaVRvVGRiKGRhdGUsIHNjcmF0Y2hEYXRlKTtcbiAgdmFyIHggPVxuICAgIHNjcmF0Y2hEYXRlLmRheU51bWJlciAtXG4gICAgZXBvY2guZGF5TnVtYmVyICtcbiAgICAoc2NyYXRjaERhdGUuc2Vjb25kc09mRGF5IC0gZXBvY2guc2Vjb25kc09mRGF5KSAvXG4gICAgICBUaW1lQ29uc3RhbnRzLlNFQ09ORFNfUEVSX0RBWTtcbiAgdmFyIHQgPSB4IC8gVGltZUNvbnN0YW50cy5EQVlTX1BFUl9KVUxJQU5fQ0VOVFVSWTtcbiAgdmFyIHQyID0gdCAqIHQ7XG4gIHZhciB0MyA9IHQyICogdDtcbiAgdmFyIHQ0ID0gdDMgKiB0O1xuXG4gIC8vIFRlcm1zIGZyb20gc2VjdGlvbiAzLjQgKGIuMSlcbiAgdmFyIHNlbWltYWpvckF4aXMgPSAzODMzOTcuNzcyNSArIDAuMDA0ICogdDtcbiAgdmFyIGVjY2VudHJpY2l0eSA9IDAuMDU1NTQ1NTI2IC0gMC4wMDAwMDAwMTYgKiB0O1xuICB2YXIgaW5jbGluYXRpb25Db25zdGFudCA9IDUuMTU2Njg5ODMgKiBSYWRpYW5zUGVyRGVncmVlO1xuICB2YXIgaW5jbGluYXRpb25TZWNQYXJ0ID1cbiAgICAtMC4wMDAwOCAqIHQgKyAwLjAyOTY2ICogdDIgLSAwLjAwMDA0MiAqIHQzIC0gMC4wMDAwMDAxMyAqIHQ0O1xuICB2YXIgbG9uZ2l0dWRlT2ZQZXJpZ2VlQ29uc3RhbnQgPSA4My4zNTMyNDMxMiAqIFJhZGlhbnNQZXJEZWdyZWU7XG4gIHZhciBsb25naXR1ZGVPZlBlcmlnZWVTZWNQYXJ0ID1cbiAgICAxNDY0MzQyMC4yNjY5ICogdCAtIDM4LjI3MDIgKiB0MiAtIDAuMDQ1MDQ3ICogdDMgKyAwLjAwMDIxMzAxICogdDQ7XG4gIHZhciBsb25naXR1ZGVPZk5vZGVDb25zdGFudCA9IDEyNS4wNDQ1NTUwMSAqIFJhZGlhbnNQZXJEZWdyZWU7XG4gIHZhciBsb25naXR1ZGVPZk5vZGVTZWNQYXJ0ID1cbiAgICAtNjk2NzkxOS4zNjMxICogdCArIDYuMzYwMiAqIHQyICsgMC4wMDc2MjUgKiB0MyAtIDAuMDAwMDM1ODYgKiB0NDtcbiAgdmFyIG1lYW5Mb25naXR1ZGVDb25zdGFudCA9IDIxOC4zMTY2NDU2MyAqIFJhZGlhbnNQZXJEZWdyZWU7XG4gIHZhciBtZWFuTG9uZ2l0dWRlU2VjUGFydCA9XG4gICAgMTczMjU1OTM0My40ODQ3ICogdCAtIDYuMzkxICogdDIgKyAwLjAwNjU4OCAqIHQzIC0gMC4wMDAwMzE2OSAqIHQ0O1xuXG4gIC8vIERlbGF1bmF5IGFyZ3VtZW50cyBmcm9tIHNlY3Rpb24gMy41IGJcbiAgdmFyIEQgPVxuICAgIDI5Ny44NTAxOTU0NyAqIFJhZGlhbnNQZXJEZWdyZWUgK1xuICAgIFJhZGlhbnNQZXJBcmNTZWNvbmQgKlxuICAgICAgKDE2MDI5NjE2MDEuMjA5ICogdCAtIDYuMzcwNiAqIHQyICsgMC4wMDY1OTMgKiB0MyAtIDAuMDAwMDMxNjkgKiB0NCk7XG4gIHZhciBGID1cbiAgICA5My4yNzIwOTA2MiAqIFJhZGlhbnNQZXJEZWdyZWUgK1xuICAgIFJhZGlhbnNQZXJBcmNTZWNvbmQgKlxuICAgICAgKDE3Mzk1MjcyNjIuODQ3OCAqIHQgLSAxMi43NTEyICogdDIgLSAwLjAwMTAzNyAqIHQzICsgMC4wMDAwMDQxNyAqIHQ0KTtcbiAgdmFyIGwgPVxuICAgIDEzNC45NjM0MDI1MSAqIFJhZGlhbnNQZXJEZWdyZWUgK1xuICAgIFJhZGlhbnNQZXJBcmNTZWNvbmQgKlxuICAgICAgKDE3MTc5MTU5MjMuMjE3OCAqIHQgKyAzMS44NzkyICogdDIgKyAwLjA1MTYzNSAqIHQzIC0gMC4wMDAyNDQ3ICogdDQpO1xuICB2YXIgbHByaW1lID1cbiAgICAzNTcuNTI5MTA5MTggKiBSYWRpYW5zUGVyRGVncmVlICtcbiAgICBSYWRpYW5zUGVyQXJjU2Vjb25kICpcbiAgICAgICgxMjk1OTY1ODEuMDQ4MSAqIHQgLSAwLjU1MzIgKiB0MiArIDAuMDAwMTM2ICogdDMgLSAwLjAwMDAxMTQ5ICogdDQpO1xuICB2YXIgcHNpID1cbiAgICAzMTAuMTcxMzc5MTggKiBSYWRpYW5zUGVyRGVncmVlIC1cbiAgICBSYWRpYW5zUGVyQXJjU2Vjb25kICpcbiAgICAgICg2OTY3MDUxLjQzNiAqIHQgKyA2LjIwNjggKiB0MiArIDAuMDA3NjE4ICogdDMgLSAwLjAwMDAzMjE5ICogdDQpO1xuXG4gIC8vIEFkZCB0ZXJtcyBmcm9tIFRhYmxlIDRcbiAgdmFyIHR3b0QgPSAyLjAgKiBEO1xuICB2YXIgZm91ckQgPSA0LjAgKiBEO1xuICB2YXIgc2l4RCA9IDYuMCAqIEQ7XG4gIHZhciB0d29sID0gMi4wICogbDtcbiAgdmFyIHRocmVlbCA9IDMuMCAqIGw7XG4gIHZhciBmb3VybCA9IDQuMCAqIGw7XG4gIHZhciB0d29GID0gMi4wICogRjtcbiAgc2VtaW1ham9yQXhpcyArPVxuICAgIDM0MDAuNCAqIE1hdGguY29zKHR3b0QpIC1cbiAgICA2MzUuNiAqIE1hdGguY29zKHR3b0QgLSBsKSAtXG4gICAgMjM1LjYgKiBNYXRoLmNvcyhsKSArXG4gICAgMjE4LjEgKiBNYXRoLmNvcyh0d29EIC0gbHByaW1lKSArXG4gICAgMTgxLjAgKiBNYXRoLmNvcyh0d29EICsgbCk7XG4gIGVjY2VudHJpY2l0eSArPVxuICAgIDAuMDE0MjE2ICogTWF0aC5jb3ModHdvRCAtIGwpICtcbiAgICAwLjAwODU1MSAqIE1hdGguY29zKHR3b0QgLSB0d29sKSAtXG4gICAgMC4wMDEzODMgKiBNYXRoLmNvcyhsKSArXG4gICAgMC4wMDEzNTYgKiBNYXRoLmNvcyh0d29EICsgbCkgLVxuICAgIDAuMDAxMTQ3ICogTWF0aC5jb3MoZm91ckQgLSB0aHJlZWwpIC1cbiAgICAwLjAwMDkxNCAqIE1hdGguY29zKGZvdXJEIC0gdHdvbCkgK1xuICAgIDAuMDAwODY5ICogTWF0aC5jb3ModHdvRCAtIGxwcmltZSAtIGwpIC1cbiAgICAwLjAwMDYyNyAqIE1hdGguY29zKHR3b0QpIC1cbiAgICAwLjAwMDM5NCAqIE1hdGguY29zKGZvdXJEIC0gZm91cmwpICtcbiAgICAwLjAwMDI4MiAqIE1hdGguY29zKHR3b0QgLSBscHJpbWUgLSB0d29sKSAtXG4gICAgMC4wMDAyNzkgKiBNYXRoLmNvcyhEIC0gbCkgLVxuICAgIDAuMDAwMjM2ICogTWF0aC5jb3ModHdvbCkgK1xuICAgIDAuMDAwMjMxICogTWF0aC5jb3MoZm91ckQpICtcbiAgICAwLjAwMDIyOSAqIE1hdGguY29zKHNpeEQgLSBmb3VybCkgLVxuICAgIDAuMDAwMjAxICogTWF0aC5jb3ModHdvbCAtIHR3b0YpO1xuICBpbmNsaW5hdGlvblNlY1BhcnQgKz1cbiAgICA0ODYuMjYgKiBNYXRoLmNvcyh0d29EIC0gdHdvRikgLVxuICAgIDQwLjEzICogTWF0aC5jb3ModHdvRCkgK1xuICAgIDM3LjUxICogTWF0aC5jb3ModHdvRikgK1xuICAgIDI1LjczICogTWF0aC5jb3ModHdvbCAtIHR3b0YpICtcbiAgICAxOS45NyAqIE1hdGguY29zKHR3b0QgLSBscHJpbWUgLSB0d29GKTtcbiAgbG9uZ2l0dWRlT2ZQZXJpZ2VlU2VjUGFydCArPVxuICAgIC01NTYwOSAqIE1hdGguc2luKHR3b0QgLSBsKSAtXG4gICAgMzQ3MTEgKiBNYXRoLnNpbih0d29EIC0gdHdvbCkgLVxuICAgIDk3OTIgKiBNYXRoLnNpbihsKSArXG4gICAgOTM4NSAqIE1hdGguc2luKGZvdXJEIC0gdGhyZWVsKSArXG4gICAgNzUwNSAqIE1hdGguc2luKGZvdXJEIC0gdHdvbCkgK1xuICAgIDUzMTggKiBNYXRoLnNpbih0d29EICsgbCkgK1xuICAgIDM0ODQgKiBNYXRoLnNpbihmb3VyRCAtIGZvdXJsKSAtXG4gICAgMzQxNyAqIE1hdGguc2luKHR3b0QgLSBscHJpbWUgLSBsKSAtXG4gICAgMjUzMCAqIE1hdGguc2luKHNpeEQgLSBmb3VybCkgLVxuICAgIDIzNzYgKiBNYXRoLnNpbih0d29EKSAtXG4gICAgMjA3NSAqIE1hdGguc2luKHR3b0QgLSB0aHJlZWwpIC1cbiAgICAxODgzICogTWF0aC5zaW4odHdvbCkgLVxuICAgIDE3MzYgKiBNYXRoLnNpbihzaXhEIC0gNS4wICogbCkgK1xuICAgIDE2MjYgKiBNYXRoLnNpbihscHJpbWUpIC1cbiAgICAxMzcwICogTWF0aC5zaW4oc2l4RCAtIHRocmVlbCk7XG4gIGxvbmdpdHVkZU9mTm9kZVNlY1BhcnQgKz1cbiAgICAtNTM5MiAqIE1hdGguc2luKHR3b0QgLSB0d29GKSAtXG4gICAgNTQwICogTWF0aC5zaW4obHByaW1lKSAtXG4gICAgNDQxICogTWF0aC5zaW4odHdvRCkgK1xuICAgIDQyMyAqIE1hdGguc2luKHR3b0YpIC1cbiAgICAyODggKiBNYXRoLnNpbih0d29sIC0gdHdvRik7XG4gIG1lYW5Mb25naXR1ZGVTZWNQYXJ0ICs9XG4gICAgLTMzMzIuOSAqIE1hdGguc2luKHR3b0QpICtcbiAgICAxMTk3LjQgKiBNYXRoLnNpbih0d29EIC0gbCkgLVxuICAgIDY2Mi41ICogTWF0aC5zaW4obHByaW1lKSArXG4gICAgMzk2LjMgKiBNYXRoLnNpbihsKSAtXG4gICAgMjE4LjAgKiBNYXRoLnNpbih0d29EIC0gbHByaW1lKTtcblxuICAvLyBBZGQgdGVybXMgZnJvbSBUYWJsZSA1XG4gIHZhciB0d29Qc2kgPSAyLjAgKiBwc2k7XG4gIHZhciB0aHJlZVBzaSA9IDMuMCAqIHBzaTtcbiAgaW5jbGluYXRpb25TZWNQYXJ0ICs9XG4gICAgNDYuOTk3ICogTWF0aC5jb3MocHNpKSAqIHQgLVxuICAgIDAuNjE0ICogTWF0aC5jb3ModHdvRCAtIHR3b0YgKyBwc2kpICogdCArXG4gICAgMC42MTQgKiBNYXRoLmNvcyh0d29EIC0gdHdvRiAtIHBzaSkgKiB0IC1cbiAgICAwLjAyOTcgKiBNYXRoLmNvcyh0d29Qc2kpICogdDIgLVxuICAgIDAuMDMzNSAqIE1hdGguY29zKHBzaSkgKiB0MiArXG4gICAgMC4wMDEyICogTWF0aC5jb3ModHdvRCAtIHR3b0YgKyB0d29Qc2kpICogdDIgLVxuICAgIDAuMDAwMTYgKiBNYXRoLmNvcyhwc2kpICogdDMgK1xuICAgIDAuMDAwMDQgKiBNYXRoLmNvcyh0aHJlZVBzaSkgKiB0MyArXG4gICAgMC4wMDAwNCAqIE1hdGguY29zKHR3b1BzaSkgKiB0MztcbiAgdmFyIHBlcmlnZWVBbmRNZWFuID1cbiAgICAyLjExNiAqIE1hdGguc2luKHBzaSkgKiB0IC1cbiAgICAwLjExMSAqIE1hdGguc2luKHR3b0QgLSB0d29GIC0gcHNpKSAqIHQgLVxuICAgIDAuMDAxNSAqIE1hdGguc2luKHBzaSkgKiB0MjtcbiAgbG9uZ2l0dWRlT2ZQZXJpZ2VlU2VjUGFydCArPSBwZXJpZ2VlQW5kTWVhbjtcbiAgbWVhbkxvbmdpdHVkZVNlY1BhcnQgKz0gcGVyaWdlZUFuZE1lYW47XG4gIGxvbmdpdHVkZU9mTm9kZVNlY1BhcnQgKz1cbiAgICAtNTIwLjc3ICogTWF0aC5zaW4ocHNpKSAqIHQgK1xuICAgIDEzLjY2ICogTWF0aC5zaW4odHdvRCAtIHR3b0YgKyBwc2kpICogdCArXG4gICAgMS4xMiAqIE1hdGguc2luKHR3b0QgLSBwc2kpICogdCAtXG4gICAgMS4wNiAqIE1hdGguc2luKHR3b0YgLSBwc2kpICogdCArXG4gICAgMC42NiAqIE1hdGguc2luKHR3b1BzaSkgKiB0MiArXG4gICAgMC4zNzEgKiBNYXRoLnNpbihwc2kpICogdDIgLVxuICAgIDAuMDM1ICogTWF0aC5zaW4odHdvRCAtIHR3b0YgKyB0d29Qc2kpICogdDIgLVxuICAgIDAuMDE1ICogTWF0aC5zaW4odHdvRCAtIHR3b0YgKyBwc2kpICogdDIgK1xuICAgIDAuMDAxNCAqIE1hdGguc2luKHBzaSkgKiB0MyAtXG4gICAgMC4wMDExICogTWF0aC5zaW4odGhyZWVQc2kpICogdDMgLVxuICAgIDAuMDAwOSAqIE1hdGguc2luKHR3b1BzaSkgKiB0MztcblxuICAvLyBBZGQgY29uc3RhbnRzIGFuZCBjb252ZXJ0IHVuaXRzXG4gIHNlbWltYWpvckF4aXMgKj0gTWV0ZXJzUGVyS2lsb21ldGVyO1xuICB2YXIgaW5jbGluYXRpb24gPVxuICAgIGluY2xpbmF0aW9uQ29uc3RhbnQgKyBpbmNsaW5hdGlvblNlY1BhcnQgKiBSYWRpYW5zUGVyQXJjU2Vjb25kO1xuICB2YXIgbG9uZ2l0dWRlT2ZQZXJpZ2VlID1cbiAgICBsb25naXR1ZGVPZlBlcmlnZWVDb25zdGFudCArXG4gICAgbG9uZ2l0dWRlT2ZQZXJpZ2VlU2VjUGFydCAqIFJhZGlhbnNQZXJBcmNTZWNvbmQ7XG4gIHZhciBtZWFuTG9uZ2l0dWRlID1cbiAgICBtZWFuTG9uZ2l0dWRlQ29uc3RhbnQgKyBtZWFuTG9uZ2l0dWRlU2VjUGFydCAqIFJhZGlhbnNQZXJBcmNTZWNvbmQ7XG4gIHZhciBsb25naXR1ZGVPZk5vZGUgPVxuICAgIGxvbmdpdHVkZU9mTm9kZUNvbnN0YW50ICsgbG9uZ2l0dWRlT2ZOb2RlU2VjUGFydCAqIFJhZGlhbnNQZXJBcmNTZWNvbmQ7XG5cbiAgcmV0dXJuIGVsZW1lbnRzVG9DYXJ0ZXNpYW4oXG4gICAgc2VtaW1ham9yQXhpcyxcbiAgICBlY2NlbnRyaWNpdHksXG4gICAgaW5jbGluYXRpb24sXG4gICAgbG9uZ2l0dWRlT2ZQZXJpZ2VlLFxuICAgIGxvbmdpdHVkZU9mTm9kZSxcbiAgICBtZWFuTG9uZ2l0dWRlLFxuICAgIHJlc3VsdFxuICApO1xufVxuXG4vLyBHZXRzIGEgcG9pbnQgZGVzY3JpYmluZyB0aGUgbW90aW9uIG9mIHRoZSBFYXJ0aC4gIFRoaXMgcG9pbnQgdXNlcyB0aGUgTW9vbiBwb2ludCBhbmRcbi8vIHRoZSAxOTkyIG11IHZhbHVlIChyYXRpbyBiZXR3ZWVuIE1vb24gYW5kIEVhcnRoIG1hc3NlcykgaW4gVGFibGUgMiBvZiB0aGUgcGFwZXIgaW4gb3JkZXJcbi8vIHRvIGRldGVybWluZSB0aGUgcG9zaXRpb24gb2YgdGhlIEVhcnRoIHJlbGF0aXZlIHRvIHRoZSBFYXJ0aC1Nb29uIGJhcnljZW50ZXIuXG52YXIgbW9vbkVhcnRoTWFzc1JhdGlvID0gMC4wMTIzMDAwMzQ7IC8vIEZyb20gMTk5MiBtdSB2YWx1ZSBpbiBUYWJsZSAyXG52YXIgZmFjdG9yID0gKG1vb25FYXJ0aE1hc3NSYXRpbyAvIChtb29uRWFydGhNYXNzUmF0aW8gKyAxLjApKSAqIC0xO1xuZnVuY3Rpb24gY29tcHV0ZVNpbW9uRWFydGgoZGF0ZSwgcmVzdWx0KSB7XG4gIHJlc3VsdCA9IGNvbXB1dGVTaW1vbk1vb24oZGF0ZSwgcmVzdWx0KTtcbiAgcmV0dXJuIENhcnRlc2lhbjMubXVsdGlwbHlCeVNjYWxhcihyZXN1bHQsIGZhY3RvciwgcmVzdWx0KTtcbn1cblxuLy8gVmFsdWVzIGZvciB0aGUgPGNvZGU+YXhlc1RyYW5zZm9ybWF0aW9uPC9jb2RlPiBuZWVkZWQgZm9yIHRoZSByb3RhdGlvbiB3ZXJlIGZvdW5kIHVzaW5nIHRoZSBTVEsgQ29tcG9uZW50c1xuLy8gR3Jlb2dyYXBoaWNUcmFuc2Zvcm1lciBvbiB0aGUgcG9zaXRpb24gb2YgdGhlIHN1biBjZW50ZXIgb2YgbWFzcyBwb2ludCBhbmQgdGhlIGVhcnRoIEoyMDAwIGZyYW1lLlxuXG52YXIgYXhlc1RyYW5zZm9ybWF0aW9uID0gbmV3IE1hdHJpeDMoXG4gIDEuMDAwMDAwMDAwMDAwMDAwMixcbiAgNS42MTk3MjMxNzM3ODU4MjJlLTE2LFxuICA0LjY5MDUxMTUxMDE0NjI5OWUtMTksXG4gIC01LjE1NDEyOTQyNzQxNDYxMWUtMTYsXG4gIDAuOTE3NDgyMDYyMDY5MTgxOSxcbiAgLTAuMzk3Nzc3MTU1OTMxOTEzNzYsXG4gIC0yLjIzOTcwMDk2MTM2NTY4ZS0xNixcbiAgMC4zOTc3NzcxNTU5MzE5MTM3NixcbiAgMC45MTc0ODIwNjIwNjkxODE5XG4pO1xudmFyIHRyYW5zbGF0aW9uID0gbmV3IENhcnRlc2lhbjMoKTtcbi8qKlxuICogQ29tcHV0ZXMgdGhlIHBvc2l0aW9uIG9mIHRoZSBTdW4gaW4gdGhlIEVhcnRoLWNlbnRlcmVkIGluZXJ0aWFsIGZyYW1lXG4gKlxuICogQHBhcmFtIHtKdWxpYW5EYXRlfSBbanVsaWFuRGF0ZV0gVGhlIHRpbWUgYXQgd2hpY2ggdG8gY29tcHV0ZSB0aGUgU3VuJ3MgcG9zaXRpb24sIGlmIG5vdCBwcm92aWRlZCB0aGUgY3VycmVudCBzeXN0ZW0gdGltZSBpcyB1c2VkLlxuICogQHBhcmFtIHtDYXJ0ZXNpYW4zfSBbcmVzdWx0XSBUaGUgb2JqZWN0IG9udG8gd2hpY2ggdG8gc3RvcmUgdGhlIHJlc3VsdC5cbiAqIEByZXR1cm5zIHtDYXJ0ZXNpYW4zfSBDYWxjdWxhdGVkIHN1biBwb3NpdGlvblxuICovXG5TaW1vbjE5OTRQbGFuZXRhcnlQb3NpdGlvbnMuY29tcHV0ZVN1blBvc2l0aW9uSW5FYXJ0aEluZXJ0aWFsRnJhbWUgPSBmdW5jdGlvbiAoXG4gIGp1bGlhbkRhdGUsXG4gIHJlc3VsdFxuKSB7XG4gIGlmICghZGVmaW5lZChqdWxpYW5EYXRlKSkge1xuICAgIGp1bGlhbkRhdGUgPSBKdWxpYW5EYXRlLm5vdygpO1xuICB9XG5cbiAgaWYgKCFkZWZpbmVkKHJlc3VsdCkpIHtcbiAgICByZXN1bHQgPSBuZXcgQ2FydGVzaWFuMygpO1xuICB9XG5cbiAgLy9maXJzdCBmb3J3YXJkIHRyYW5zZm9ybWF0aW9uXG4gIHRyYW5zbGF0aW9uID0gY29tcHV0ZVNpbW9uRWFydGhNb29uQmFyeWNlbnRlcihqdWxpYW5EYXRlLCB0cmFuc2xhdGlvbik7XG4gIHJlc3VsdCA9IENhcnRlc2lhbjMubmVnYXRlKHRyYW5zbGF0aW9uLCByZXN1bHQpO1xuXG4gIC8vc2Vjb25kIGZvcndhcmQgdHJhbnNmb3JtYXRpb25cbiAgY29tcHV0ZVNpbW9uRWFydGgoanVsaWFuRGF0ZSwgdHJhbnNsYXRpb24pO1xuXG4gIENhcnRlc2lhbjMuc3VidHJhY3QocmVzdWx0LCB0cmFuc2xhdGlvbiwgcmVzdWx0KTtcbiAgTWF0cml4My5tdWx0aXBseUJ5VmVjdG9yKGF4ZXNUcmFuc2Zvcm1hdGlvbiwgcmVzdWx0LCByZXN1bHQpO1xuXG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG4vKipcbiAqIENvbXB1dGVzIHRoZSBwb3NpdGlvbiBvZiB0aGUgTW9vbiBpbiB0aGUgRWFydGgtY2VudGVyZWQgaW5lcnRpYWwgZnJhbWVcbiAqXG4gKiBAcGFyYW0ge0p1bGlhbkRhdGV9IFtqdWxpYW5EYXRlXSBUaGUgdGltZSBhdCB3aGljaCB0byBjb21wdXRlIHRoZSBTdW4ncyBwb3NpdGlvbiwgaWYgbm90IHByb3ZpZGVkIHRoZSBjdXJyZW50IHN5c3RlbSB0aW1lIGlzIHVzZWQuXG4gKiBAcGFyYW0ge0NhcnRlc2lhbjN9IFtyZXN1bHRdIFRoZSBvYmplY3Qgb250byB3aGljaCB0byBzdG9yZSB0aGUgcmVzdWx0LlxuICogQHJldHVybnMge0NhcnRlc2lhbjN9IENhbGN1bGF0ZWQgbW9vbiBwb3NpdGlvblxuICovXG5TaW1vbjE5OTRQbGFuZXRhcnlQb3NpdGlvbnMuY29tcHV0ZU1vb25Qb3NpdGlvbkluRWFydGhJbmVydGlhbEZyYW1lID0gZnVuY3Rpb24gKFxuICBqdWxpYW5EYXRlLFxuICByZXN1bHRcbikge1xuICBpZiAoIWRlZmluZWQoanVsaWFuRGF0ZSkpIHtcbiAgICBqdWxpYW5EYXRlID0gSnVsaWFuRGF0ZS5ub3coKTtcbiAgfVxuXG4gIHJlc3VsdCA9IGNvbXB1dGVTaW1vbk1vb24oanVsaWFuRGF0ZSwgcmVzdWx0KTtcbiAgTWF0cml4My5tdWx0aXBseUJ5VmVjdG9yKGF4ZXNUcmFuc2Zvcm1hdGlvbiwgcmVzdWx0LCByZXN1bHQpO1xuXG4gIHJldHVybiByZXN1bHQ7XG59O1xuZXhwb3J0IGRlZmF1bHQgU2ltb24xOTk0UGxhbmV0YXJ5UG9zaXRpb25zO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///83156\n')},85440:function(__unused_webpack___webpack_module__,__unused_webpack___webpack_exports__,__webpack_require__){eval('/* harmony import */ var _ArcType_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(11491);\n/* harmony import */ var _BoundingSphere_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(48243);\n/* harmony import */ var _Cartesian3_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(60216);\n/* harmony import */ var _Color_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(59947);\n/* harmony import */ var _ComponentDatatype_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(84828);\n/* harmony import */ var _defaultValue_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(62200);\n/* harmony import */ var _defined_js__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(82982);\n/* harmony import */ var _DeveloperError_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(12572);\n/* harmony import */ var _Ellipsoid_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(50491);\n/* harmony import */ var _Geometry_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(82408);\n/* harmony import */ var _GeometryAttribute_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(13616);\n/* harmony import */ var _GeometryAttributes_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(56652);\n/* harmony import */ var _IndexDatatype_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(22832);\n/* harmony import */ var _Math_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(99417);\n/* harmony import */ var _PolylinePipeline_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(61733);\n/* harmony import */ var _PrimitiveType_js__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(97264);\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunction interpolateColors(p0, p1, color0, color1, minDistance, array, offset) {\n  var numPoints = _PolylinePipeline_js__WEBPACK_IMPORTED_MODULE_13__/* ["default"].numberOfPoints */ .Z.numberOfPoints(p0, p1, minDistance);\n  var i;\n\n  var r0 = color0.red;\n  var g0 = color0.green;\n  var b0 = color0.blue;\n  var a0 = color0.alpha;\n\n  var r1 = color1.red;\n  var g1 = color1.green;\n  var b1 = color1.blue;\n  var a1 = color1.alpha;\n\n  if (_Color_js__WEBPACK_IMPORTED_MODULE_3__/* ["default"].equals */ .Z.equals(color0, color1)) {\n    for (i = 0; i < numPoints; i++) {\n      array[offset++] = _Color_js__WEBPACK_IMPORTED_MODULE_3__/* ["default"].floatToByte */ .Z.floatToByte(r0);\n      array[offset++] = _Color_js__WEBPACK_IMPORTED_MODULE_3__/* ["default"].floatToByte */ .Z.floatToByte(g0);\n      array[offset++] = _Color_js__WEBPACK_IMPORTED_MODULE_3__/* ["default"].floatToByte */ .Z.floatToByte(b0);\n      array[offset++] = _Color_js__WEBPACK_IMPORTED_MODULE_3__/* ["default"].floatToByte */ .Z.floatToByte(a0);\n    }\n    return offset;\n  }\n\n  var redPerVertex = (r1 - r0) / numPoints;\n  var greenPerVertex = (g1 - g0) / numPoints;\n  var bluePerVertex = (b1 - b0) / numPoints;\n  var alphaPerVertex = (a1 - a0) / numPoints;\n\n  var index = offset;\n  for (i = 0; i < numPoints; i++) {\n    array[index++] = _Color_js__WEBPACK_IMPORTED_MODULE_3__/* ["default"].floatToByte */ .Z.floatToByte(r0 + i * redPerVertex);\n    array[index++] = _Color_js__WEBPACK_IMPORTED_MODULE_3__/* ["default"].floatToByte */ .Z.floatToByte(g0 + i * greenPerVertex);\n    array[index++] = _Color_js__WEBPACK_IMPORTED_MODULE_3__/* ["default"].floatToByte */ .Z.floatToByte(b0 + i * bluePerVertex);\n    array[index++] = _Color_js__WEBPACK_IMPORTED_MODULE_3__/* ["default"].floatToByte */ .Z.floatToByte(a0 + i * alphaPerVertex);\n  }\n\n  return index;\n}\n\n/**\n * A description of a polyline modeled as a line strip; the first two positions define a line segment,\n * and each additional position defines a line segment from the previous position.\n *\n * @alias SimplePolylineGeometry\n * @constructor\n *\n * @param {Object} options Object with the following properties:\n * @param {Cartesian3[]} options.positions An array of {@link Cartesian3} defining the positions in the polyline as a line strip.\n * @param {Color[]} [options.colors] An Array of {@link Color} defining the per vertex or per segment colors.\n * @param {Boolean} [options.colorsPerVertex=false] A boolean that determines whether the colors will be flat across each segment of the line or interpolated across the vertices.\n * @param {ArcType} [options.arcType=ArcType.GEODESIC] The type of line the polyline segments must follow.\n * @param {Number} [options.granularity=CesiumMath.RADIANS_PER_DEGREE] The distance, in radians, between each latitude and longitude if options.arcType is not ArcType.NONE. Determines the number of positions in the buffer.\n * @param {Ellipsoid} [options.ellipsoid=Ellipsoid.WGS84] The ellipsoid to be used as a reference.\n *\n * @exception {DeveloperError} At least two positions are required.\n * @exception {DeveloperError} colors has an invalid length.\n *\n * @see SimplePolylineGeometry#createGeometry\n *\n * @example\n * // A polyline with two connected line segments\n * var polyline = new Cesium.SimplePolylineGeometry({\n *   positions : Cesium.Cartesian3.fromDegreesArray([\n *     0.0, 0.0,\n *     5.0, 0.0,\n *     5.0, 5.0\n *   ])\n * });\n * var geometry = Cesium.SimplePolylineGeometry.createGeometry(polyline);\n */\nfunction SimplePolylineGeometry(options) {\n  options = (0,_defaultValue_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"] */ .Z)(options, _defaultValue_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"].EMPTY_OBJECT */ .Z.EMPTY_OBJECT);\n  var positions = options.positions;\n  var colors = options.colors;\n  var colorsPerVertex = (0,_defaultValue_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"] */ .Z)(options.colorsPerVertex, false);\n\n  //>>includeStart(\'debug\', pragmas.debug);\n  if (!(0,_defined_js__WEBPACK_IMPORTED_MODULE_15__/* ["default"] */ .Z)(positions) || positions.length < 2) {\n    throw new _DeveloperError_js__WEBPACK_IMPORTED_MODULE_6__/* ["default"] */ .Z("At least two positions are required.");\n  }\n  if (\n    (0,_defined_js__WEBPACK_IMPORTED_MODULE_15__/* ["default"] */ .Z)(colors) &&\n    ((colorsPerVertex && colors.length < positions.length) ||\n      (!colorsPerVertex && colors.length < positions.length - 1))\n  ) {\n    throw new _DeveloperError_js__WEBPACK_IMPORTED_MODULE_6__/* ["default"] */ .Z("colors has an invalid length.");\n  }\n  //>>includeEnd(\'debug\');\n\n  this._positions = positions;\n  this._colors = colors;\n  this._colorsPerVertex = colorsPerVertex;\n\n  this._arcType = (0,_defaultValue_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"] */ .Z)(options.arcType, _ArcType_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].GEODESIC */ .Z.GEODESIC);\n  this._granularity = (0,_defaultValue_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"] */ .Z)(\n    options.granularity,\n    _Math_js__WEBPACK_IMPORTED_MODULE_12__/* ["default"].RADIANS_PER_DEGREE */ .Z.RADIANS_PER_DEGREE\n  );\n  this._ellipsoid = (0,_defaultValue_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"] */ .Z)(options.ellipsoid, _Ellipsoid_js__WEBPACK_IMPORTED_MODULE_7__/* ["default"].WGS84 */ .Z.WGS84);\n  this._workerName = "createSimplePolylineGeometry";\n\n  var numComponents = 1 + positions.length * _Cartesian3_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"].packedLength */ .Z.packedLength;\n  numComponents += (0,_defined_js__WEBPACK_IMPORTED_MODULE_15__/* ["default"] */ .Z)(colors) ? 1 + colors.length * _Color_js__WEBPACK_IMPORTED_MODULE_3__/* ["default"].packedLength */ .Z.packedLength : 1;\n\n  /**\n   * The number of elements used to pack the object into an array.\n   * @type {Number}\n   */\n  this.packedLength = numComponents + _Ellipsoid_js__WEBPACK_IMPORTED_MODULE_7__/* ["default"].packedLength */ .Z.packedLength + 3;\n}\n\n/**\n * Stores the provided instance into the provided array.\n *\n * @param {SimplePolylineGeometry} value The value to pack.\n * @param {Number[]} array The array to pack into.\n * @param {Number} [startingIndex=0] The index into the array at which to start packing the elements.\n *\n * @returns {Number[]} The array that was packed into\n */\nSimplePolylineGeometry.pack = function (value, array, startingIndex) {\n  //>>includeStart(\'debug\', pragmas.debug);\n  if (!(0,_defined_js__WEBPACK_IMPORTED_MODULE_15__/* ["default"] */ .Z)(value)) {\n    throw new _DeveloperError_js__WEBPACK_IMPORTED_MODULE_6__/* ["default"] */ .Z("value is required");\n  }\n  if (!(0,_defined_js__WEBPACK_IMPORTED_MODULE_15__/* ["default"] */ .Z)(array)) {\n    throw new _DeveloperError_js__WEBPACK_IMPORTED_MODULE_6__/* ["default"] */ .Z("array is required");\n  }\n  //>>includeEnd(\'debug\');\n\n  startingIndex = (0,_defaultValue_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"] */ .Z)(startingIndex, 0);\n\n  var i;\n\n  var positions = value._positions;\n  var length = positions.length;\n  array[startingIndex++] = length;\n\n  for (i = 0; i < length; ++i, startingIndex += _Cartesian3_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"].packedLength */ .Z.packedLength) {\n    _Cartesian3_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"].pack */ .Z.pack(positions[i], array, startingIndex);\n  }\n\n  var colors = value._colors;\n  length = (0,_defined_js__WEBPACK_IMPORTED_MODULE_15__/* ["default"] */ .Z)(colors) ? colors.length : 0.0;\n  array[startingIndex++] = length;\n\n  for (i = 0; i < length; ++i, startingIndex += _Color_js__WEBPACK_IMPORTED_MODULE_3__/* ["default"].packedLength */ .Z.packedLength) {\n    _Color_js__WEBPACK_IMPORTED_MODULE_3__/* ["default"].pack */ .Z.pack(colors[i], array, startingIndex);\n  }\n\n  _Ellipsoid_js__WEBPACK_IMPORTED_MODULE_7__/* ["default"].pack */ .Z.pack(value._ellipsoid, array, startingIndex);\n  startingIndex += _Ellipsoid_js__WEBPACK_IMPORTED_MODULE_7__/* ["default"].packedLength */ .Z.packedLength;\n\n  array[startingIndex++] = value._colorsPerVertex ? 1.0 : 0.0;\n  array[startingIndex++] = value._arcType;\n  array[startingIndex] = value._granularity;\n\n  return array;\n};\n\n/**\n * Retrieves an instance from a packed array.\n *\n * @param {Number[]} array The packed array.\n * @param {Number} [startingIndex=0] The starting index of the element to be unpacked.\n * @param {SimplePolylineGeometry} [result] The object into which to store the result.\n * @returns {SimplePolylineGeometry} The modified result parameter or a new SimplePolylineGeometry instance if one was not provided.\n */\nSimplePolylineGeometry.unpack = function (array, startingIndex, result) {\n  //>>includeStart(\'debug\', pragmas.debug);\n  if (!(0,_defined_js__WEBPACK_IMPORTED_MODULE_15__/* ["default"] */ .Z)(array)) {\n    throw new _DeveloperError_js__WEBPACK_IMPORTED_MODULE_6__/* ["default"] */ .Z("array is required");\n  }\n  //>>includeEnd(\'debug\');\n\n  startingIndex = (0,_defaultValue_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"] */ .Z)(startingIndex, 0);\n\n  var i;\n\n  var length = array[startingIndex++];\n  var positions = new Array(length);\n\n  for (i = 0; i < length; ++i, startingIndex += _Cartesian3_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"].packedLength */ .Z.packedLength) {\n    positions[i] = _Cartesian3_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"].unpack */ .Z.unpack(array, startingIndex);\n  }\n\n  length = array[startingIndex++];\n  var colors = length > 0 ? new Array(length) : undefined;\n\n  for (i = 0; i < length; ++i, startingIndex += _Color_js__WEBPACK_IMPORTED_MODULE_3__/* ["default"].packedLength */ .Z.packedLength) {\n    colors[i] = _Color_js__WEBPACK_IMPORTED_MODULE_3__/* ["default"].unpack */ .Z.unpack(array, startingIndex);\n  }\n\n  var ellipsoid = _Ellipsoid_js__WEBPACK_IMPORTED_MODULE_7__/* ["default"].unpack */ .Z.unpack(array, startingIndex);\n  startingIndex += _Ellipsoid_js__WEBPACK_IMPORTED_MODULE_7__/* ["default"].packedLength */ .Z.packedLength;\n\n  var colorsPerVertex = array[startingIndex++] === 1.0;\n  var arcType = array[startingIndex++];\n  var granularity = array[startingIndex];\n\n  if (!(0,_defined_js__WEBPACK_IMPORTED_MODULE_15__/* ["default"] */ .Z)(result)) {\n    return new SimplePolylineGeometry({\n      positions: positions,\n      colors: colors,\n      ellipsoid: ellipsoid,\n      colorsPerVertex: colorsPerVertex,\n      arcType: arcType,\n      granularity: granularity,\n    });\n  }\n\n  result._positions = positions;\n  result._colors = colors;\n  result._ellipsoid = ellipsoid;\n  result._colorsPerVertex = colorsPerVertex;\n  result._arcType = arcType;\n  result._granularity = granularity;\n\n  return result;\n};\n\nvar scratchArray1 = new Array(2);\nvar scratchArray2 = new Array(2);\nvar generateArcOptionsScratch = {\n  positions: scratchArray1,\n  height: scratchArray2,\n  ellipsoid: undefined,\n  minDistance: undefined,\n  granularity: undefined,\n};\n\n/**\n * Computes the geometric representation of a simple polyline, including its vertices, indices, and a bounding sphere.\n *\n * @param {SimplePolylineGeometry} simplePolylineGeometry A description of the polyline.\n * @returns {Geometry|undefined} The computed vertices and indices.\n */\nSimplePolylineGeometry.createGeometry = function (simplePolylineGeometry) {\n  var positions = simplePolylineGeometry._positions;\n  var colors = simplePolylineGeometry._colors;\n  var colorsPerVertex = simplePolylineGeometry._colorsPerVertex;\n  var arcType = simplePolylineGeometry._arcType;\n  var granularity = simplePolylineGeometry._granularity;\n  var ellipsoid = simplePolylineGeometry._ellipsoid;\n\n  var minDistance = _Math_js__WEBPACK_IMPORTED_MODULE_12__/* ["default"].chordLength */ .Z.chordLength(\n    granularity,\n    ellipsoid.maximumRadius\n  );\n  var perSegmentColors = (0,_defined_js__WEBPACK_IMPORTED_MODULE_15__/* ["default"] */ .Z)(colors) && !colorsPerVertex;\n\n  var i;\n  var length = positions.length;\n\n  var positionValues;\n  var numberOfPositions;\n  var colorValues;\n  var color;\n  var offset = 0;\n\n  if (arcType === _ArcType_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].GEODESIC */ .Z.GEODESIC || arcType === _ArcType_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].RHUMB */ .Z.RHUMB) {\n    var subdivisionSize;\n    var numberOfPointsFunction;\n    var generateArcFunction;\n    if (arcType === _ArcType_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].GEODESIC */ .Z.GEODESIC) {\n      subdivisionSize = _Math_js__WEBPACK_IMPORTED_MODULE_12__/* ["default"].chordLength */ .Z.chordLength(\n        granularity,\n        ellipsoid.maximumRadius\n      );\n      numberOfPointsFunction = _PolylinePipeline_js__WEBPACK_IMPORTED_MODULE_13__/* ["default"].numberOfPoints */ .Z.numberOfPoints;\n      generateArcFunction = _PolylinePipeline_js__WEBPACK_IMPORTED_MODULE_13__/* ["default"].generateArc */ .Z.generateArc;\n    } else {\n      subdivisionSize = granularity;\n      numberOfPointsFunction = _PolylinePipeline_js__WEBPACK_IMPORTED_MODULE_13__/* ["default"].numberOfPointsRhumbLine */ .Z.numberOfPointsRhumbLine;\n      generateArcFunction = _PolylinePipeline_js__WEBPACK_IMPORTED_MODULE_13__/* ["default"].generateRhumbArc */ .Z.generateRhumbArc;\n    }\n\n    var heights = _PolylinePipeline_js__WEBPACK_IMPORTED_MODULE_13__/* ["default"].extractHeights */ .Z.extractHeights(positions, ellipsoid);\n\n    var generateArcOptions = generateArcOptionsScratch;\n    if (arcType === _ArcType_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].GEODESIC */ .Z.GEODESIC) {\n      generateArcOptions.minDistance = minDistance;\n    } else {\n      generateArcOptions.granularity = granularity;\n    }\n    generateArcOptions.ellipsoid = ellipsoid;\n\n    if (perSegmentColors) {\n      var positionCount = 0;\n      for (i = 0; i < length - 1; i++) {\n        positionCount +=\n          numberOfPointsFunction(\n            positions[i],\n            positions[i + 1],\n            subdivisionSize\n          ) + 1;\n      }\n\n      positionValues = new Float64Array(positionCount * 3);\n      colorValues = new Uint8Array(positionCount * 4);\n\n      generateArcOptions.positions = scratchArray1;\n      generateArcOptions.height = scratchArray2;\n\n      var ci = 0;\n      for (i = 0; i < length - 1; ++i) {\n        scratchArray1[0] = positions[i];\n        scratchArray1[1] = positions[i + 1];\n\n        scratchArray2[0] = heights[i];\n        scratchArray2[1] = heights[i + 1];\n\n        var pos = generateArcFunction(generateArcOptions);\n\n        if ((0,_defined_js__WEBPACK_IMPORTED_MODULE_15__/* ["default"] */ .Z)(colors)) {\n          var segLen = pos.length / 3;\n          color = colors[i];\n          for (var k = 0; k < segLen; ++k) {\n            colorValues[ci++] = _Color_js__WEBPACK_IMPORTED_MODULE_3__/* ["default"].floatToByte */ .Z.floatToByte(color.red);\n            colorValues[ci++] = _Color_js__WEBPACK_IMPORTED_MODULE_3__/* ["default"].floatToByte */ .Z.floatToByte(color.green);\n            colorValues[ci++] = _Color_js__WEBPACK_IMPORTED_MODULE_3__/* ["default"].floatToByte */ .Z.floatToByte(color.blue);\n            colorValues[ci++] = _Color_js__WEBPACK_IMPORTED_MODULE_3__/* ["default"].floatToByte */ .Z.floatToByte(color.alpha);\n          }\n        }\n\n        positionValues.set(pos, offset);\n        offset += pos.length;\n      }\n    } else {\n      generateArcOptions.positions = positions;\n      generateArcOptions.height = heights;\n      positionValues = new Float64Array(\n        generateArcFunction(generateArcOptions)\n      );\n\n      if ((0,_defined_js__WEBPACK_IMPORTED_MODULE_15__/* ["default"] */ .Z)(colors)) {\n        colorValues = new Uint8Array((positionValues.length / 3) * 4);\n\n        for (i = 0; i < length - 1; ++i) {\n          var p0 = positions[i];\n          var p1 = positions[i + 1];\n          var c0 = colors[i];\n          var c1 = colors[i + 1];\n          offset = interpolateColors(\n            p0,\n            p1,\n            c0,\n            c1,\n            minDistance,\n            colorValues,\n            offset\n          );\n        }\n\n        var lastColor = colors[length - 1];\n        colorValues[offset++] = _Color_js__WEBPACK_IMPORTED_MODULE_3__/* ["default"].floatToByte */ .Z.floatToByte(lastColor.red);\n        colorValues[offset++] = _Color_js__WEBPACK_IMPORTED_MODULE_3__/* ["default"].floatToByte */ .Z.floatToByte(lastColor.green);\n        colorValues[offset++] = _Color_js__WEBPACK_IMPORTED_MODULE_3__/* ["default"].floatToByte */ .Z.floatToByte(lastColor.blue);\n        colorValues[offset++] = _Color_js__WEBPACK_IMPORTED_MODULE_3__/* ["default"].floatToByte */ .Z.floatToByte(lastColor.alpha);\n      }\n    }\n  } else {\n    numberOfPositions = perSegmentColors ? length * 2 - 2 : length;\n    positionValues = new Float64Array(numberOfPositions * 3);\n    colorValues = (0,_defined_js__WEBPACK_IMPORTED_MODULE_15__/* ["default"] */ .Z)(colors)\n      ? new Uint8Array(numberOfPositions * 4)\n      : undefined;\n\n    var positionIndex = 0;\n    var colorIndex = 0;\n\n    for (i = 0; i < length; ++i) {\n      var p = positions[i];\n\n      if (perSegmentColors && i > 0) {\n        _Cartesian3_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"].pack */ .Z.pack(p, positionValues, positionIndex);\n        positionIndex += 3;\n\n        color = colors[i - 1];\n        colorValues[colorIndex++] = _Color_js__WEBPACK_IMPORTED_MODULE_3__/* ["default"].floatToByte */ .Z.floatToByte(color.red);\n        colorValues[colorIndex++] = _Color_js__WEBPACK_IMPORTED_MODULE_3__/* ["default"].floatToByte */ .Z.floatToByte(color.green);\n        colorValues[colorIndex++] = _Color_js__WEBPACK_IMPORTED_MODULE_3__/* ["default"].floatToByte */ .Z.floatToByte(color.blue);\n        colorValues[colorIndex++] = _Color_js__WEBPACK_IMPORTED_MODULE_3__/* ["default"].floatToByte */ .Z.floatToByte(color.alpha);\n      }\n\n      if (perSegmentColors && i === length - 1) {\n        break;\n      }\n\n      _Cartesian3_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"].pack */ .Z.pack(p, positionValues, positionIndex);\n      positionIndex += 3;\n\n      if ((0,_defined_js__WEBPACK_IMPORTED_MODULE_15__/* ["default"] */ .Z)(colors)) {\n        color = colors[i];\n        colorValues[colorIndex++] = _Color_js__WEBPACK_IMPORTED_MODULE_3__/* ["default"].floatToByte */ .Z.floatToByte(color.red);\n        colorValues[colorIndex++] = _Color_js__WEBPACK_IMPORTED_MODULE_3__/* ["default"].floatToByte */ .Z.floatToByte(color.green);\n        colorValues[colorIndex++] = _Color_js__WEBPACK_IMPORTED_MODULE_3__/* ["default"].floatToByte */ .Z.floatToByte(color.blue);\n        colorValues[colorIndex++] = _Color_js__WEBPACK_IMPORTED_MODULE_3__/* ["default"].floatToByte */ .Z.floatToByte(color.alpha);\n      }\n    }\n  }\n\n  var attributes = new _GeometryAttributes_js__WEBPACK_IMPORTED_MODULE_10__/* ["default"] */ .Z();\n  attributes.position = new _GeometryAttribute_js__WEBPACK_IMPORTED_MODULE_9__/* ["default"] */ .Z({\n    componentDatatype: _ComponentDatatype_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"].DOUBLE */ .Z.DOUBLE,\n    componentsPerAttribute: 3,\n    values: positionValues,\n  });\n\n  if ((0,_defined_js__WEBPACK_IMPORTED_MODULE_15__/* ["default"] */ .Z)(colors)) {\n    attributes.color = new _GeometryAttribute_js__WEBPACK_IMPORTED_MODULE_9__/* ["default"] */ .Z({\n      componentDatatype: _ComponentDatatype_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"].UNSIGNED_BYTE */ .Z.UNSIGNED_BYTE,\n      componentsPerAttribute: 4,\n      values: colorValues,\n      normalize: true,\n    });\n  }\n\n  numberOfPositions = positionValues.length / 3;\n  var numberOfIndices = (numberOfPositions - 1) * 2;\n  var indices = _IndexDatatype_js__WEBPACK_IMPORTED_MODULE_11__/* ["default"].createTypedArray */ .Z.createTypedArray(\n    numberOfPositions,\n    numberOfIndices\n  );\n\n  var index = 0;\n  for (i = 0; i < numberOfPositions - 1; ++i) {\n    indices[index++] = i;\n    indices[index++] = i + 1;\n  }\n\n  return new _Geometry_js__WEBPACK_IMPORTED_MODULE_8__/* ["default"] */ .Z({\n    attributes: attributes,\n    indices: indices,\n    primitiveType: _PrimitiveType_js__WEBPACK_IMPORTED_MODULE_14__/* ["default"].LINES */ .Z.LINES,\n    boundingSphere: _BoundingSphere_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"].fromPoints */ .Z.fromPoints(positions),\n  });\n};\n/* unused harmony default export */ var __WEBPACK_DEFAULT_EXPORT__ = ((/* unused pure expression or super */ null && (SimplePolylineGeometry)));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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MkIsc0VBQWlCO0FBQzVDLHlCQUF5QixrR0FBK0I7QUFDeEQ7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQSxnQkFBZ0IscUdBQThCO0FBQzlDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGNBQWMsMkJBQTJCO0FBQ3pDO0FBQ0E7QUFDQTs7QUFFQSxhQUFhLDZEQUFRO0FBQ3JCO0FBQ0E7QUFDQSxtQkFBbUIsK0VBQW1CO0FBQ3RDLG9CQUFvQix5RkFBeUI7QUFDN0MsR0FBRztBQUNIO0FBQ0Esc0VBQWUsc0VBQXNCLElBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly92dWUzLXdlYnBhY2s1Ly4vbm9kZV9tb2R1bGVzL2Nlc2l1bS9Tb3VyY2UvQ29yZS9TaW1wbGVQb2x5bGluZUdlb21ldHJ5LmpzPzNmOTUiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IEFyY1R5cGUgZnJvbSBcIi4vQXJjVHlwZS5qc1wiO1xuaW1wb3J0IEJvdW5kaW5nU3BoZXJlIGZyb20gXCIuL0JvdW5kaW5nU3BoZXJlLmpzXCI7XG5pbXBvcnQgQ2FydGVzaWFuMyBmcm9tIFwiLi9DYXJ0ZXNpYW4zLmpzXCI7XG5pbXBvcnQgQ29sb3IgZnJvbSBcIi4vQ29sb3IuanNcIjtcbmltcG9ydCBDb21wb25lbnREYXRhdHlwZSBmcm9tIFwiLi9Db21wb25lbnREYXRhdHlwZS5qc1wiO1xuaW1wb3J0IGRlZmF1bHRWYWx1ZSBmcm9tIFwiLi9kZWZhdWx0VmFsdWUuanNcIjtcbmltcG9ydCBkZWZpbmVkIGZyb20gXCIuL2RlZmluZWQuanNcIjtcbmltcG9ydCBEZXZlbG9wZXJFcnJvciBmcm9tIFwiLi9EZXZlbG9wZXJFcnJvci5qc1wiO1xuaW1wb3J0IEVsbGlwc29pZCBmcm9tIFwiLi9FbGxpcHNvaWQuanNcIjtcbmltcG9ydCBHZW9tZXRyeSBmcm9tIFwiLi9HZW9tZXRyeS5qc1wiO1xuaW1wb3J0IEdlb21ldHJ5QXR0cmlidXRlIGZyb20gXCIuL0dlb21ldHJ5QXR0cmlidXRlLmpzXCI7XG5pbXBvcnQgR2VvbWV0cnlBdHRyaWJ1dGVzIGZyb20gXCIuL0dlb21ldHJ5QXR0cmlidXRlcy5qc1wiO1xuaW1wb3J0IEluZGV4RGF0YXR5cGUgZnJvbSBcIi4vSW5kZXhEYXRhdHlwZS5qc1wiO1xuaW1wb3J0IENlc2l1bU1hdGggZnJvbSBcIi4vTWF0aC5qc1wiO1xuaW1wb3J0IFBvbHlsaW5lUGlwZWxpbmUgZnJvbSBcIi4vUG9seWxpbmVQaXBlbGluZS5qc1wiO1xuaW1wb3J0IFByaW1pdGl2ZVR5cGUgZnJvbSBcIi4vUHJpbWl0aXZlVHlwZS5qc1wiO1xuXG5mdW5jdGlvbiBpbnRlcnBvbGF0ZUNvbG9ycyhwMCwgcDEsIGNvbG9yMCwgY29sb3IxLCBtaW5EaXN0YW5jZSwgYXJyYXksIG9mZnNldCkge1xuICB2YXIgbnVtUG9pbnRzID0gUG9seWxpbmVQaXBlbGluZS5udW1iZXJPZlBvaW50cyhwMCwgcDEsIG1pbkRpc3RhbmNlKTtcbiAgdmFyIGk7XG5cbiAgdmFyIHIwID0gY29sb3IwLnJlZDtcbiAgdmFyIGcwID0gY29sb3IwLmdyZWVuO1xuICB2YXIgYjAgPSBjb2xvcjAuYmx1ZTtcbiAgdmFyIGEwID0gY29sb3IwLmFscGhhO1xuXG4gIHZhciByMSA9IGNvbG9yMS5yZWQ7XG4gIHZhciBnMSA9IGNvbG9yMS5ncmVlbjtcbiAgdmFyIGIxID0gY29sb3IxLmJsdWU7XG4gIHZhciBhMSA9IGNvbG9yMS5hbHBoYTtcblxuICBpZiAoQ29sb3IuZXF1YWxzKGNvbG9yMCwgY29sb3IxKSkge1xuICAgIGZvciAoaSA9IDA7IGkgPCBudW1Qb2ludHM7IGkrKykge1xuICAgICAgYXJyYXlbb2Zmc2V0KytdID0gQ29sb3IuZmxvYXRUb0J5dGUocjApO1xuICAgICAgYXJyYXlbb2Zmc2V0KytdID0gQ29sb3IuZmxvYXRUb0J5dGUoZzApO1xuICAgICAgYXJyYXlbb2Zmc2V0KytdID0gQ29sb3IuZmxvYXRUb0J5dGUoYjApO1xuICAgICAgYXJyYXlbb2Zmc2V0KytdID0gQ29sb3IuZmxvYXRUb0J5dGUoYTApO1xuICAgIH1cbiAgICByZXR1cm4gb2Zmc2V0O1xuICB9XG5cbiAgdmFyIHJlZFBlclZlcnRleCA9IChyMSAtIHIwKSAvIG51bVBvaW50cztcbiAgdmFyIGdyZWVuUGVyVmVydGV4ID0gKGcxIC0gZzApIC8gbnVtUG9pbnRzO1xuICB2YXIgYmx1ZVBlclZlcnRleCA9IChiMSAtIGIwKSAvIG51bVBvaW50cztcbiAgdmFyIGFscGhhUGVyVmVydGV4ID0gKGExIC0gYTApIC8gbnVtUG9pbnRzO1xuXG4gIHZhciBpbmRleCA9IG9mZnNldDtcbiAgZm9yIChpID0gMDsgaSA8IG51bVBvaW50czsgaSsrKSB7XG4gICAgYXJyYXlbaW5kZXgrK10gPSBDb2xvci5mbG9hdFRvQnl0ZShyMCArIGkgKiByZWRQZXJWZXJ0ZXgpO1xuICAgIGFycmF5W2luZGV4KytdID0gQ29sb3IuZmxvYXRUb0J5dGUoZzAgKyBpICogZ3JlZW5QZXJWZXJ0ZXgpO1xuICAgIGFycmF5W2luZGV4KytdID0gQ29sb3IuZmxvYXRUb0J5dGUoYjAgKyBpICogYmx1ZVBlclZlcnRleCk7XG4gICAgYXJyYXlbaW5kZXgrK10gPSBDb2xvci5mbG9hdFRvQnl0ZShhMCArIGkgKiBhbHBoYVBlclZlcnRleCk7XG4gIH1cblxuICByZXR1cm4gaW5kZXg7XG59XG5cbi8qKlxuICogQSBkZXNjcmlwdGlvbiBvZiBhIHBvbHlsaW5lIG1vZGVsZWQgYXMgYSBsaW5lIHN0cmlwOyB0aGUgZmlyc3QgdHdvIHBvc2l0aW9ucyBkZWZpbmUgYSBsaW5lIHNlZ21lbnQsXG4gKiBhbmQgZWFjaCBhZGRpdGlvbmFsIHBvc2l0aW9uIGRlZmluZXMgYSBsaW5lIHNlZ21lbnQgZnJvbSB0aGUgcHJldmlvdXMgcG9zaXRpb24uXG4gKlxuICogQGFsaWFzIFNpbXBsZVBvbHlsaW5lR2VvbWV0cnlcbiAqIEBjb25zdHJ1Y3RvclxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIE9iamVjdCB3aXRoIHRoZSBmb2xsb3dpbmcgcHJvcGVydGllczpcbiAqIEBwYXJhbSB7Q2FydGVzaWFuM1tdfSBvcHRpb25zLnBvc2l0aW9ucyBBbiBhcnJheSBvZiB7QGxpbmsgQ2FydGVzaWFuM30gZGVmaW5pbmcgdGhlIHBvc2l0aW9ucyBpbiB0aGUgcG9seWxpbmUgYXMgYSBsaW5lIHN0cmlwLlxuICogQHBhcmFtIHtDb2xvcltdfSBbb3B0aW9ucy5jb2xvcnNdIEFuIEFycmF5IG9mIHtAbGluayBDb2xvcn0gZGVmaW5pbmcgdGhlIHBlciB2ZXJ0ZXggb3IgcGVyIHNlZ21lbnQgY29sb3JzLlxuICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5jb2xvcnNQZXJWZXJ0ZXg9ZmFsc2VdIEEgYm9vbGVhbiB0aGF0IGRldGVybWluZXMgd2hldGhlciB0aGUgY29sb3JzIHdpbGwgYmUgZmxhdCBhY3Jvc3MgZWFjaCBzZWdtZW50IG9mIHRoZSBsaW5lIG9yIGludGVycG9sYXRlZCBhY3Jvc3MgdGhlIHZlcnRpY2VzLlxuICogQHBhcmFtIHtBcmNUeXBlfSBbb3B0aW9ucy5hcmNUeXBlPUFyY1R5cGUuR0VPREVTSUNdIFRoZSB0eXBlIG9mIGxpbmUgdGhlIHBvbHlsaW5lIHNlZ21lbnRzIG11c3QgZm9sbG93LlxuICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLmdyYW51bGFyaXR5PUNlc2l1bU1hdGguUkFESUFOU19QRVJfREVHUkVFXSBUaGUgZGlzdGFuY2UsIGluIHJhZGlhbnMsIGJldHdlZW4gZWFjaCBsYXRpdHVkZSBhbmQgbG9uZ2l0dWRlIGlmIG9wdGlvbnMuYXJjVHlwZSBpcyBub3QgQXJjVHlwZS5OT05FLiBEZXRlcm1pbmVzIHRoZSBudW1iZXIgb2YgcG9zaXRpb25zIGluIHRoZSBidWZmZXIuXG4gKiBAcGFyYW0ge0VsbGlwc29pZH0gW29wdGlvbnMuZWxsaXBzb2lkPUVsbGlwc29pZC5XR1M4NF0gVGhlIGVsbGlwc29pZCB0byBiZSB1c2VkIGFzIGEgcmVmZXJlbmNlLlxuICpcbiAqIEBleGNlcHRpb24ge0RldmVsb3BlckVycm9yfSBBdCBsZWFzdCB0d28gcG9zaXRpb25zIGFyZSByZXF1aXJlZC5cbiAqIEBleGNlcHRpb24ge0RldmVsb3BlckVycm9yfSBjb2xvcnMgaGFzIGFuIGludmFsaWQgbGVuZ3RoLlxuICpcbiAqIEBzZWUgU2ltcGxlUG9seWxpbmVHZW9tZXRyeSNjcmVhdGVHZW9tZXRyeVxuICpcbiAqIEBleGFtcGxlXG4gKiAvLyBBIHBvbHlsaW5lIHdpdGggdHdvIGNvbm5lY3RlZCBsaW5lIHNlZ21lbnRzXG4gKiB2YXIgcG9seWxpbmUgPSBuZXcgQ2VzaXVtLlNpbXBsZVBvbHlsaW5lR2VvbWV0cnkoe1xuICogICBwb3NpdGlvbnMgOiBDZXNpdW0uQ2FydGVzaWFuMy5mcm9tRGVncmVlc0FycmF5KFtcbiAqICAgICAwLjAsIDAuMCxcbiAqICAgICA1LjAsIDAuMCxcbiAqICAgICA1LjAsIDUuMFxuICogICBdKVxuICogfSk7XG4gKiB2YXIgZ2VvbWV0cnkgPSBDZXNpdW0uU2ltcGxlUG9seWxpbmVHZW9tZXRyeS5jcmVhdGVHZW9tZXRyeShwb2x5bGluZSk7XG4gKi9cbmZ1bmN0aW9uIFNpbXBsZVBvbHlsaW5lR2VvbWV0cnkob3B0aW9ucykge1xuICBvcHRpb25zID0gZGVmYXVsdFZhbHVlKG9wdGlvbnMsIGRlZmF1bHRWYWx1ZS5FTVBUWV9PQkpFQ1QpO1xuICB2YXIgcG9zaXRpb25zID0gb3B0aW9ucy5wb3NpdGlvbnM7XG4gIHZhciBjb2xvcnMgPSBvcHRpb25zLmNvbG9ycztcbiAgdmFyIGNvbG9yc1BlclZlcnRleCA9IGRlZmF1bHRWYWx1ZShvcHRpb25zLmNvbG9yc1BlclZlcnRleCwgZmFsc2UpO1xuXG4gIC8vPj5pbmNsdWRlU3RhcnQoJ2RlYnVnJywgcHJhZ21hcy5kZWJ1Zyk7XG4gIGlmICghZGVmaW5lZChwb3NpdGlvbnMpIHx8IHBvc2l0aW9ucy5sZW5ndGggPCAyKSB7XG4gICAgdGhyb3cgbmV3IERldmVsb3BlckVycm9yKFwiQXQgbGVhc3QgdHdvIHBvc2l0aW9ucyBhcmUgcmVxdWlyZWQuXCIpO1xuICB9XG4gIGlmIChcbiAgICBkZWZpbmVkKGNvbG9ycykgJiZcbiAgICAoKGNvbG9yc1BlclZlcnRleCAmJiBjb2xvcnMubGVuZ3RoIDwgcG9zaXRpb25zLmxlbmd0aCkgfHxcbiAgICAgICghY29sb3JzUGVyVmVydGV4ICYmIGNvbG9ycy5sZW5ndGggPCBwb3NpdGlvbnMubGVuZ3RoIC0gMSkpXG4gICkge1xuICAgIHRocm93IG5ldyBEZXZlbG9wZXJFcnJvcihcImNvbG9ycyBoYXMgYW4gaW52YWxpZCBsZW5ndGguXCIpO1xuICB9XG4gIC8vPj5pbmNsdWRlRW5kKCdkZWJ1ZycpO1xuXG4gIHRoaXMuX3Bvc2l0aW9ucyA9IHBvc2l0aW9ucztcbiAgdGhpcy5fY29sb3JzID0gY29sb3JzO1xuICB0aGlzLl9jb2xvcnNQZXJWZXJ0ZXggPSBjb2xvcnNQZXJWZXJ0ZXg7XG5cbiAgdGhpcy5fYXJjVHlwZSA9IGRlZmF1bHRWYWx1ZShvcHRpb25zLmFyY1R5cGUsIEFyY1R5cGUuR0VPREVTSUMpO1xuICB0aGlzLl9ncmFudWxhcml0eSA9IGRlZmF1bHRWYWx1ZShcbiAgICBvcHRpb25zLmdyYW51bGFyaXR5LFxuICAgIENlc2l1bU1hdGguUkFESUFOU19QRVJfREVHUkVFXG4gICk7XG4gIHRoaXMuX2VsbGlwc29pZCA9IGRlZmF1bHRWYWx1ZShvcHRpb25zLmVsbGlwc29pZCwgRWxsaXBzb2lkLldHUzg0KTtcbiAgdGhpcy5fd29ya2VyTmFtZSA9IFwiY3JlYXRlU2ltcGxlUG9seWxpbmVHZW9tZXRyeVwiO1xuXG4gIHZhciBudW1Db21wb25lbnRzID0gMSArIHBvc2l0aW9ucy5sZW5ndGggKiBDYXJ0ZXNpYW4zLnBhY2tlZExlbmd0aDtcbiAgbnVtQ29tcG9uZW50cyArPSBkZWZpbmVkKGNvbG9ycykgPyAxICsgY29sb3JzLmxlbmd0aCAqIENvbG9yLnBhY2tlZExlbmd0aCA6IDE7XG5cbiAgLyoqXG4gICAqIFRoZSBudW1iZXIgb2YgZWxlbWVudHMgdXNlZCB0byBwYWNrIHRoZSBvYmplY3QgaW50byBhbiBhcnJheS5cbiAgICogQHR5cGUge051bWJlcn1cbiAgICovXG4gIHRoaXMucGFja2VkTGVuZ3RoID0gbnVtQ29tcG9uZW50cyArIEVsbGlwc29pZC5wYWNrZWRMZW5ndGggKyAzO1xufVxuXG4vKipcbiAqIFN0b3JlcyB0aGUgcHJvdmlkZWQgaW5zdGFuY2UgaW50byB0aGUgcHJvdmlkZWQgYXJyYXkuXG4gKlxuICogQHBhcmFtIHtTaW1wbGVQb2x5bGluZUdlb21ldHJ5fSB2YWx1ZSBUaGUgdmFsdWUgdG8gcGFjay5cbiAqIEBwYXJhbSB7TnVtYmVyW119IGFycmF5IFRoZSBhcnJheSB0byBwYWNrIGludG8uXG4gKiBAcGFyYW0ge051bWJlcn0gW3N0YXJ0aW5nSW5kZXg9MF0gVGhlIGluZGV4IGludG8gdGhlIGFycmF5IGF0IHdoaWNoIHRvIHN0YXJ0IHBhY2tpbmcgdGhlIGVsZW1lbnRzLlxuICpcbiAqIEByZXR1cm5zIHtOdW1iZXJbXX0gVGhlIGFycmF5IHRoYXQgd2FzIHBhY2tlZCBpbnRvXG4gKi9cblNpbXBsZVBvbHlsaW5lR2VvbWV0cnkucGFjayA9IGZ1bmN0aW9uICh2YWx1ZSwgYXJyYXksIHN0YXJ0aW5nSW5kZXgpIHtcbiAgLy8+PmluY2x1ZGVTdGFydCgnZGVidWcnLCBwcmFnbWFzLmRlYnVnKTtcbiAgaWYgKCFkZWZpbmVkKHZhbHVlKSkge1xuICAgIHRocm93IG5ldyBEZXZlbG9wZXJFcnJvcihcInZhbHVlIGlzIHJlcXVpcmVkXCIpO1xuICB9XG4gIGlmICghZGVmaW5lZChhcnJheSkpIHtcbiAgICB0aHJvdyBuZXcgRGV2ZWxvcGVyRXJyb3IoXCJhcnJheSBpcyByZXF1aXJlZFwiKTtcbiAgfVxuICAvLz4+aW5jbHVkZUVuZCgnZGVidWcnKTtcblxuICBzdGFydGluZ0luZGV4ID0gZGVmYXVsdFZhbHVlKHN0YXJ0aW5nSW5kZXgsIDApO1xuXG4gIHZhciBpO1xuXG4gIHZhciBwb3NpdGlvbnMgPSB2YWx1ZS5fcG9zaXRpb25zO1xuICB2YXIgbGVuZ3RoID0gcG9zaXRpb25zLmxlbmd0aDtcbiAgYXJyYXlbc3RhcnRpbmdJbmRleCsrXSA9IGxlbmd0aDtcblxuICBmb3IgKGkgPSAwOyBpIDwgbGVuZ3RoOyArK2ksIHN0YXJ0aW5nSW5kZXggKz0gQ2FydGVzaWFuMy5wYWNrZWRMZW5ndGgpIHtcbiAgICBDYXJ0ZXNpYW4zLnBhY2socG9zaXRpb25zW2ldLCBhcnJheSwgc3RhcnRpbmdJbmRleCk7XG4gIH1cblxuICB2YXIgY29sb3JzID0gdmFsdWUuX2NvbG9ycztcbiAgbGVuZ3RoID0gZGVmaW5lZChjb2xvcnMpID8gY29sb3JzLmxlbmd0aCA6IDAuMDtcbiAgYXJyYXlbc3RhcnRpbmdJbmRleCsrXSA9IGxlbmd0aDtcblxuICBmb3IgKGkgPSAwOyBpIDwgbGVuZ3RoOyArK2ksIHN0YXJ0aW5nSW5kZXggKz0gQ29sb3IucGFja2VkTGVuZ3RoKSB7XG4gICAgQ29sb3IucGFjayhjb2xvcnNbaV0sIGFycmF5LCBzdGFydGluZ0luZGV4KTtcbiAgfVxuXG4gIEVsbGlwc29pZC5wYWNrKHZhbHVlLl9lbGxpcHNvaWQsIGFycmF5LCBzdGFydGluZ0luZGV4KTtcbiAgc3RhcnRpbmdJbmRleCArPSBFbGxpcHNvaWQucGFja2VkTGVuZ3RoO1xuXG4gIGFycmF5W3N0YXJ0aW5nSW5kZXgrK10gPSB2YWx1ZS5fY29sb3JzUGVyVmVydGV4ID8gMS4wIDogMC4wO1xuICBhcnJheVtzdGFydGluZ0luZGV4KytdID0gdmFsdWUuX2FyY1R5cGU7XG4gIGFycmF5W3N0YXJ0aW5nSW5kZXhdID0gdmFsdWUuX2dyYW51bGFyaXR5O1xuXG4gIHJldHVybiBhcnJheTtcbn07XG5cbi8qKlxuICogUmV0cmlldmVzIGFuIGluc3RhbmNlIGZyb20gYSBwYWNrZWQgYXJyYXkuXG4gKlxuICogQHBhcmFtIHtOdW1iZXJbXX0gYXJyYXkgVGhlIHBhY2tlZCBhcnJheS5cbiAqIEBwYXJhbSB7TnVtYmVyfSBbc3RhcnRpbmdJbmRleD0wXSBUaGUgc3RhcnRpbmcgaW5kZXggb2YgdGhlIGVsZW1lbnQgdG8gYmUgdW5wYWNrZWQuXG4gKiBAcGFyYW0ge1NpbXBsZVBvbHlsaW5lR2VvbWV0cnl9IFtyZXN1bHRdIFRoZSBvYmplY3QgaW50byB3aGljaCB0byBzdG9yZSB0aGUgcmVzdWx0LlxuICogQHJldHVybnMge1NpbXBsZVBvbHlsaW5lR2VvbWV0cnl9IFRoZSBtb2RpZmllZCByZXN1bHQgcGFyYW1ldGVyIG9yIGEgbmV3IFNpbXBsZVBvbHlsaW5lR2VvbWV0cnkgaW5zdGFuY2UgaWYgb25lIHdhcyBub3QgcHJvdmlkZWQuXG4gKi9cblNpbXBsZVBvbHlsaW5lR2VvbWV0cnkudW5wYWNrID0gZnVuY3Rpb24gKGFycmF5LCBzdGFydGluZ0luZGV4LCByZXN1bHQpIHtcbiAgLy8+PmluY2x1ZGVTdGFydCgnZGVidWcnLCBwcmFnbWFzLmRlYnVnKTtcbiAgaWYgKCFkZWZpbmVkKGFycmF5KSkge1xuICAgIHRocm93IG5ldyBEZXZlbG9wZXJFcnJvcihcImFycmF5IGlzIHJlcXVpcmVkXCIpO1xuICB9XG4gIC8vPj5pbmNsdWRlRW5kKCdkZWJ1ZycpO1xuXG4gIHN0YXJ0aW5nSW5kZXggPSBkZWZhdWx0VmFsdWUoc3RhcnRpbmdJbmRleCwgMCk7XG5cbiAgdmFyIGk7XG5cbiAgdmFyIGxlbmd0aCA9IGFycmF5W3N0YXJ0aW5nSW5kZXgrK107XG4gIHZhciBwb3NpdGlvbnMgPSBuZXcgQXJyYXkobGVuZ3RoKTtcblxuICBmb3IgKGkgPSAwOyBpIDwgbGVuZ3RoOyArK2ksIHN0YXJ0aW5nSW5kZXggKz0gQ2FydGVzaWFuMy5wYWNrZWRMZW5ndGgpIHtcbiAgICBwb3NpdGlvbnNbaV0gPSBDYXJ0ZXNpYW4zLnVucGFjayhhcnJheSwgc3RhcnRpbmdJbmRleCk7XG4gIH1cblxuICBsZW5ndGggPSBhcnJheVtzdGFydGluZ0luZGV4KytdO1xuICB2YXIgY29sb3JzID0gbGVuZ3RoID4gMCA/IG5ldyBBcnJheShsZW5ndGgpIDogdW5kZWZpbmVkO1xuXG4gIGZvciAoaSA9IDA7IGkgPCBsZW5ndGg7ICsraSwgc3RhcnRpbmdJbmRleCArPSBDb2xvci5wYWNrZWRMZW5ndGgpIHtcbiAgICBjb2xvcnNbaV0gPSBDb2xvci51bnBhY2soYXJyYXksIHN0YXJ0aW5nSW5kZXgpO1xuICB9XG5cbiAgdmFyIGVsbGlwc29pZCA9IEVsbGlwc29pZC51bnBhY2soYXJyYXksIHN0YXJ0aW5nSW5kZXgpO1xuICBzdGFydGluZ0luZGV4ICs9IEVsbGlwc29pZC5wYWNrZWRMZW5ndGg7XG5cbiAgdmFyIGNvbG9yc1BlclZlcnRleCA9IGFycmF5W3N0YXJ0aW5nSW5kZXgrK10gPT09IDEuMDtcbiAgdmFyIGFyY1R5cGUgPSBhcnJheVtzdGFydGluZ0luZGV4KytdO1xuICB2YXIgZ3JhbnVsYXJpdHkgPSBhcnJheVtzdGFydGluZ0luZGV4XTtcblxuICBpZiAoIWRlZmluZWQocmVzdWx0KSkge1xuICAgIHJldHVybiBuZXcgU2ltcGxlUG9seWxpbmVHZW9tZXRyeSh7XG4gICAgICBwb3NpdGlvbnM6IHBvc2l0aW9ucyxcbiAgICAgIGNvbG9yczogY29sb3JzLFxuICAgICAgZWxsaXBzb2lkOiBlbGxpcHNvaWQsXG4gICAgICBjb2xvcnNQZXJWZXJ0ZXg6IGNvbG9yc1BlclZlcnRleCxcbiAgICAgIGFyY1R5cGU6IGFyY1R5cGUsXG4gICAgICBncmFudWxhcml0eTogZ3JhbnVsYXJpdHksXG4gICAgfSk7XG4gIH1cblxuICByZXN1bHQuX3Bvc2l0aW9ucyA9IHBvc2l0aW9ucztcbiAgcmVzdWx0Ll9jb2xvcnMgPSBjb2xvcnM7XG4gIHJlc3VsdC5fZWxsaXBzb2lkID0gZWxsaXBzb2lkO1xuICByZXN1bHQuX2NvbG9yc1BlclZlcnRleCA9IGNvbG9yc1BlclZlcnRleDtcbiAgcmVzdWx0Ll9hcmNUeXBlID0gYXJjVHlwZTtcbiAgcmVzdWx0Ll9ncmFudWxhcml0eSA9IGdyYW51bGFyaXR5O1xuXG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG52YXIgc2NyYXRjaEFycmF5MSA9IG5ldyBBcnJheSgyKTtcbnZhciBzY3JhdGNoQXJyYXkyID0gbmV3IEFycmF5KDIpO1xudmFyIGdlbmVyYXRlQXJjT3B0aW9uc1NjcmF0Y2ggPSB7XG4gIHBvc2l0aW9uczogc2NyYXRjaEFycmF5MSxcbiAgaGVpZ2h0OiBzY3JhdGNoQXJyYXkyLFxuICBlbGxpcHNvaWQ6IHVuZGVmaW5lZCxcbiAgbWluRGlzdGFuY2U6IHVuZGVmaW5lZCxcbiAgZ3JhbnVsYXJpdHk6IHVuZGVmaW5lZCxcbn07XG5cbi8qKlxuICogQ29tcHV0ZXMgdGhlIGdlb21ldHJpYyByZXByZXNlbnRhdGlvbiBvZiBhIHNpbXBsZSBwb2x5bGluZSwgaW5jbHVkaW5nIGl0cyB2ZXJ0aWNlcywgaW5kaWNlcywgYW5kIGEgYm91bmRpbmcgc3BoZXJlLlxuICpcbiAqIEBwYXJhbSB7U2ltcGxlUG9seWxpbmVHZW9tZXRyeX0gc2ltcGxlUG9seWxpbmVHZW9tZXRyeSBBIGRlc2NyaXB0aW9uIG9mIHRoZSBwb2x5bGluZS5cbiAqIEByZXR1cm5zIHtHZW9tZXRyeXx1bmRlZmluZWR9IFRoZSBjb21wdXRlZCB2ZXJ0aWNlcyBhbmQgaW5kaWNlcy5cbiAqL1xuU2ltcGxlUG9seWxpbmVHZW9tZXRyeS5jcmVhdGVHZW9tZXRyeSA9IGZ1bmN0aW9uIChzaW1wbGVQb2x5bGluZUdlb21ldHJ5KSB7XG4gIHZhciBwb3NpdGlvbnMgPSBzaW1wbGVQb2x5bGluZUdlb21ldHJ5Ll9wb3NpdGlvbnM7XG4gIHZhciBjb2xvcnMgPSBzaW1wbGVQb2x5bGluZUdlb21ldHJ5Ll9jb2xvcnM7XG4gIHZhciBjb2xvcnNQZXJWZXJ0ZXggPSBzaW1wbGVQb2x5bGluZUdlb21ldHJ5Ll9jb2xvcnNQZXJWZXJ0ZXg7XG4gIHZhciBhcmNUeXBlID0gc2ltcGxlUG9seWxpbmVHZW9tZXRyeS5fYXJjVHlwZTtcbiAgdmFyIGdyYW51bGFyaXR5ID0gc2ltcGxlUG9seWxpbmVHZW9tZXRyeS5fZ3JhbnVsYXJpdHk7XG4gIHZhciBlbGxpcHNvaWQgPSBzaW1wbGVQb2x5bGluZUdlb21ldHJ5Ll9lbGxpcHNvaWQ7XG5cbiAgdmFyIG1pbkRpc3RhbmNlID0gQ2VzaXVtTWF0aC5jaG9yZExlbmd0aChcbiAgICBncmFudWxhcml0eSxcbiAgICBlbGxpcHNvaWQubWF4aW11bVJhZGl1c1xuICApO1xuICB2YXIgcGVyU2VnbWVudENvbG9ycyA9IGRlZmluZWQoY29sb3JzKSAmJiAhY29sb3JzUGVyVmVydGV4O1xuXG4gIHZhciBpO1xuICB2YXIgbGVuZ3RoID0gcG9zaXRpb25zLmxlbmd0aDtcblxuICB2YXIgcG9zaXRpb25WYWx1ZXM7XG4gIHZhciBudW1iZXJPZlBvc2l0aW9ucztcbiAgdmFyIGNvbG9yVmFsdWVzO1xuICB2YXIgY29sb3I7XG4gIHZhciBvZmZzZXQgPSAwO1xuXG4gIGlmIChhcmNUeXBlID09PSBBcmNUeXBlLkdFT0RFU0lDIHx8IGFyY1R5cGUgPT09IEFyY1R5cGUuUkhVTUIpIHtcbiAgICB2YXIgc3ViZGl2aXNpb25TaXplO1xuICAgIHZhciBudW1iZXJPZlBvaW50c0Z1bmN0aW9uO1xuICAgIHZhciBnZW5lcmF0ZUFyY0Z1bmN0aW9uO1xuICAgIGlmIChhcmNUeXBlID09PSBBcmNUeXBlLkdFT0RFU0lDKSB7XG4gICAgICBzdWJkaXZpc2lvblNpemUgPSBDZXNpdW1NYXRoLmNob3JkTGVuZ3RoKFxuICAgICAgICBncmFudWxhcml0eSxcbiAgICAgICAgZWxsaXBzb2lkLm1heGltdW1SYWRpdXNcbiAgICAgICk7XG4gICAgICBudW1iZXJPZlBvaW50c0Z1bmN0aW9uID0gUG9seWxpbmVQaXBlbGluZS5udW1iZXJPZlBvaW50cztcbiAgICAgIGdlbmVyYXRlQXJjRnVuY3Rpb24gPSBQb2x5bGluZVBpcGVsaW5lLmdlbmVyYXRlQXJjO1xuICAgIH0gZWxzZSB7XG4gICAgICBzdWJkaXZpc2lvblNpemUgPSBncmFudWxhcml0eTtcbiAgICAgIG51bWJlck9mUG9pbnRzRnVuY3Rpb24gPSBQb2x5bGluZVBpcGVsaW5lLm51bWJlck9mUG9pbnRzUmh1bWJMaW5lO1xuICAgICAgZ2VuZXJhdGVBcmNGdW5jdGlvbiA9IFBvbHlsaW5lUGlwZWxpbmUuZ2VuZXJhdGVSaHVtYkFyYztcbiAgICB9XG5cbiAgICB2YXIgaGVpZ2h0cyA9IFBvbHlsaW5lUGlwZWxpbmUuZXh0cmFjdEhlaWdodHMocG9zaXRpb25zLCBlbGxpcHNvaWQpO1xuXG4gICAgdmFyIGdlbmVyYXRlQXJjT3B0aW9ucyA9IGdlbmVyYXRlQXJjT3B0aW9uc1NjcmF0Y2g7XG4gICAgaWYgKGFyY1R5cGUgPT09IEFyY1R5cGUuR0VPREVTSUMpIHtcbiAgICAgIGdlbmVyYXRlQXJjT3B0aW9ucy5taW5EaXN0YW5jZSA9IG1pbkRpc3RhbmNlO1xuICAgIH0gZWxzZSB7XG4gICAgICBnZW5lcmF0ZUFyY09wdGlvbnMuZ3JhbnVsYXJpdHkgPSBncmFudWxhcml0eTtcbiAgICB9XG4gICAgZ2VuZXJhdGVBcmNPcHRpb25zLmVsbGlwc29pZCA9IGVsbGlwc29pZDtcblxuICAgIGlmIChwZXJTZWdtZW50Q29sb3JzKSB7XG4gICAgICB2YXIgcG9zaXRpb25Db3VudCA9IDA7XG4gICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuZ3RoIC0gMTsgaSsrKSB7XG4gICAgICAgIHBvc2l0aW9uQ291bnQgKz1cbiAgICAgICAgICBudW1iZXJPZlBvaW50c0Z1bmN0aW9uKFxuICAgICAgICAgICAgcG9zaXRpb25zW2ldLFxuICAgICAgICAgICAgcG9zaXRpb25zW2kgKyAxXSxcbiAgICAgICAgICAgIHN1YmRpdmlzaW9uU2l6ZVxuICAgICAgICAgICkgKyAxO1xuICAgICAgfVxuXG4gICAgICBwb3NpdGlvblZhbHVlcyA9IG5ldyBGbG9hdDY0QXJyYXkocG9zaXRpb25Db3VudCAqIDMpO1xuICAgICAgY29sb3JWYWx1ZXMgPSBuZXcgVWludDhBcnJheShwb3NpdGlvbkNvdW50ICogNCk7XG5cbiAgICAgIGdlbmVyYXRlQXJjT3B0aW9ucy5wb3NpdGlvbnMgPSBzY3JhdGNoQXJyYXkxO1xuICAgICAgZ2VuZXJhdGVBcmNPcHRpb25zLmhlaWdodCA9IHNjcmF0Y2hBcnJheTI7XG5cbiAgICAgIHZhciBjaSA9IDA7XG4gICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuZ3RoIC0gMTsgKytpKSB7XG4gICAgICAgIHNjcmF0Y2hBcnJheTFbMF0gPSBwb3NpdGlvbnNbaV07XG4gICAgICAgIHNjcmF0Y2hBcnJheTFbMV0gPSBwb3NpdGlvbnNbaSArIDFdO1xuXG4gICAgICAgIHNjcmF0Y2hBcnJheTJbMF0gPSBoZWlnaHRzW2ldO1xuICAgICAgICBzY3JhdGNoQXJyYXkyWzFdID0gaGVpZ2h0c1tpICsgMV07XG5cbiAgICAgICAgdmFyIHBvcyA9IGdlbmVyYXRlQXJjRnVuY3Rpb24oZ2VuZXJhdGVBcmNPcHRpb25zKTtcblxuICAgICAgICBpZiAoZGVmaW5lZChjb2xvcnMpKSB7XG4gICAgICAgICAgdmFyIHNlZ0xlbiA9IHBvcy5sZW5ndGggLyAzO1xuICAgICAgICAgIGNvbG9yID0gY29sb3JzW2ldO1xuICAgICAgICAgIGZvciAodmFyIGsgPSAwOyBrIDwgc2VnTGVuOyArK2spIHtcbiAgICAgICAgICAgIGNvbG9yVmFsdWVzW2NpKytdID0gQ29sb3IuZmxvYXRUb0J5dGUoY29sb3IucmVkKTtcbiAgICAgICAgICAgIGNvbG9yVmFsdWVzW2NpKytdID0gQ29sb3IuZmxvYXRUb0J5dGUoY29sb3IuZ3JlZW4pO1xuICAgICAgICAgICAgY29sb3JWYWx1ZXNbY2krK10gPSBDb2xvci5mbG9hdFRvQnl0ZShjb2xvci5ibHVlKTtcbiAgICAgICAgICAgIGNvbG9yVmFsdWVzW2NpKytdID0gQ29sb3IuZmxvYXRUb0J5dGUoY29sb3IuYWxwaGEpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHBvc2l0aW9uVmFsdWVzLnNldChwb3MsIG9mZnNldCk7XG4gICAgICAgIG9mZnNldCArPSBwb3MubGVuZ3RoO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBnZW5lcmF0ZUFyY09wdGlvbnMucG9zaXRpb25zID0gcG9zaXRpb25zO1xuICAgICAgZ2VuZXJhdGVBcmNPcHRpb25zLmhlaWdodCA9IGhlaWdodHM7XG4gICAgICBwb3NpdGlvblZhbHVlcyA9IG5ldyBGbG9hdDY0QXJyYXkoXG4gICAgICAgIGdlbmVyYXRlQXJjRnVuY3Rpb24oZ2VuZXJhdGVBcmNPcHRpb25zKVxuICAgICAgKTtcblxuICAgICAgaWYgKGRlZmluZWQoY29sb3JzKSkge1xuICAgICAgICBjb2xvclZhbHVlcyA9IG5ldyBVaW50OEFycmF5KChwb3NpdGlvblZhbHVlcy5sZW5ndGggLyAzKSAqIDQpO1xuXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW5ndGggLSAxOyArK2kpIHtcbiAgICAgICAgICB2YXIgcDAgPSBwb3NpdGlvbnNbaV07XG4gICAgICAgICAgdmFyIHAxID0gcG9zaXRpb25zW2kgKyAxXTtcbiAgICAgICAgICB2YXIgYzAgPSBjb2xvcnNbaV07XG4gICAgICAgICAgdmFyIGMxID0gY29sb3JzW2kgKyAxXTtcbiAgICAgICAgICBvZmZzZXQgPSBpbnRlcnBvbGF0ZUNvbG9ycyhcbiAgICAgICAgICAgIHAwLFxuICAgICAgICAgICAgcDEsXG4gICAgICAgICAgICBjMCxcbiAgICAgICAgICAgIGMxLFxuICAgICAgICAgICAgbWluRGlzdGFuY2UsXG4gICAgICAgICAgICBjb2xvclZhbHVlcyxcbiAgICAgICAgICAgIG9mZnNldFxuICAgICAgICAgICk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgbGFzdENvbG9yID0gY29sb3JzW2xlbmd0aCAtIDFdO1xuICAgICAgICBjb2xvclZhbHVlc1tvZmZzZXQrK10gPSBDb2xvci5mbG9hdFRvQnl0ZShsYXN0Q29sb3IucmVkKTtcbiAgICAgICAgY29sb3JWYWx1ZXNbb2Zmc2V0KytdID0gQ29sb3IuZmxvYXRUb0J5dGUobGFzdENvbG9yLmdyZWVuKTtcbiAgICAgICAgY29sb3JWYWx1ZXNbb2Zmc2V0KytdID0gQ29sb3IuZmxvYXRUb0J5dGUobGFzdENvbG9yLmJsdWUpO1xuICAgICAgICBjb2xvclZhbHVlc1tvZmZzZXQrK10gPSBDb2xvci5mbG9hdFRvQnl0ZShsYXN0Q29sb3IuYWxwaGEpO1xuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBudW1iZXJPZlBvc2l0aW9ucyA9IHBlclNlZ21lbnRDb2xvcnMgPyBsZW5ndGggKiAyIC0gMiA6IGxlbmd0aDtcbiAgICBwb3NpdGlvblZhbHVlcyA9IG5ldyBGbG9hdDY0QXJyYXkobnVtYmVyT2ZQb3NpdGlvbnMgKiAzKTtcbiAgICBjb2xvclZhbHVlcyA9IGRlZmluZWQoY29sb3JzKVxuICAgICAgPyBuZXcgVWludDhBcnJheShudW1iZXJPZlBvc2l0aW9ucyAqIDQpXG4gICAgICA6IHVuZGVmaW5lZDtcblxuICAgIHZhciBwb3NpdGlvbkluZGV4ID0gMDtcbiAgICB2YXIgY29sb3JJbmRleCA9IDA7XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kpIHtcbiAgICAgIHZhciBwID0gcG9zaXRpb25zW2ldO1xuXG4gICAgICBpZiAocGVyU2VnbWVudENvbG9ycyAmJiBpID4gMCkge1xuICAgICAgICBDYXJ0ZXNpYW4zLnBhY2socCwgcG9zaXRpb25WYWx1ZXMsIHBvc2l0aW9uSW5kZXgpO1xuICAgICAgICBwb3NpdGlvbkluZGV4ICs9IDM7XG5cbiAgICAgICAgY29sb3IgPSBjb2xvcnNbaSAtIDFdO1xuICAgICAgICBjb2xvclZhbHVlc1tjb2xvckluZGV4KytdID0gQ29sb3IuZmxvYXRUb0J5dGUoY29sb3IucmVkKTtcbiAgICAgICAgY29sb3JWYWx1ZXNbY29sb3JJbmRleCsrXSA9IENvbG9yLmZsb2F0VG9CeXRlKGNvbG9yLmdyZWVuKTtcbiAgICAgICAgY29sb3JWYWx1ZXNbY29sb3JJbmRleCsrXSA9IENvbG9yLmZsb2F0VG9CeXRlKGNvbG9yLmJsdWUpO1xuICAgICAgICBjb2xvclZhbHVlc1tjb2xvckluZGV4KytdID0gQ29sb3IuZmxvYXRUb0J5dGUoY29sb3IuYWxwaGEpO1xuICAgICAgfVxuXG4gICAgICBpZiAocGVyU2VnbWVudENvbG9ycyAmJiBpID09PSBsZW5ndGggLSAxKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgICBDYXJ0ZXNpYW4zLnBhY2socCwgcG9zaXRpb25WYWx1ZXMsIHBvc2l0aW9uSW5kZXgpO1xuICAgICAgcG9zaXRpb25JbmRleCArPSAzO1xuXG4gICAgICBpZiAoZGVmaW5lZChjb2xvcnMpKSB7XG4gICAgICAgIGNvbG9yID0gY29sb3JzW2ldO1xuICAgICAgICBjb2xvclZhbHVlc1tjb2xvckluZGV4KytdID0gQ29sb3IuZmxvYXRUb0J5dGUoY29sb3IucmVkKTtcbiAgICAgICAgY29sb3JWYWx1ZXNbY29sb3JJbmRleCsrXSA9IENvbG9yLmZsb2F0VG9CeXRlKGNvbG9yLmdyZWVuKTtcbiAgICAgICAgY29sb3JWYWx1ZXNbY29sb3JJbmRleCsrXSA9IENvbG9yLmZsb2F0VG9CeXRlKGNvbG9yLmJsdWUpO1xuICAgICAgICBjb2xvclZhbHVlc1tjb2xvckluZGV4KytdID0gQ29sb3IuZmxvYXRUb0J5dGUoY29sb3IuYWxwaGEpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHZhciBhdHRyaWJ1dGVzID0gbmV3IEdlb21ldHJ5QXR0cmlidXRlcygpO1xuICBhdHRyaWJ1dGVzLnBvc2l0aW9uID0gbmV3IEdlb21ldHJ5QXR0cmlidXRlKHtcbiAgICBjb21wb25lbnREYXRhdHlwZTogQ29tcG9uZW50RGF0YXR5cGUuRE9VQkxFLFxuICAgIGNvbXBvbmVudHNQZXJBdHRyaWJ1dGU6IDMsXG4gICAgdmFsdWVzOiBwb3NpdGlvblZhbHVlcyxcbiAgfSk7XG5cbiAgaWYgKGRlZmluZWQoY29sb3JzKSkge1xuICAgIGF0dHJpYnV0ZXMuY29sb3IgPSBuZXcgR2VvbWV0cnlBdHRyaWJ1dGUoe1xuICAgICAgY29tcG9uZW50RGF0YXR5cGU6IENvbXBvbmVudERhdGF0eXBlLlVOU0lHTkVEX0JZVEUsXG4gICAgICBjb21wb25lbnRzUGVyQXR0cmlidXRlOiA0LFxuICAgICAgdmFsdWVzOiBjb2xvclZhbHVlcyxcbiAgICAgIG5vcm1hbGl6ZTogdHJ1ZSxcbiAgICB9KTtcbiAgfVxuXG4gIG51bWJlck9mUG9zaXRpb25zID0gcG9zaXRpb25WYWx1ZXMubGVuZ3RoIC8gMztcbiAgdmFyIG51bWJlck9mSW5kaWNlcyA9IChudW1iZXJPZlBvc2l0aW9ucyAtIDEpICogMjtcbiAgdmFyIGluZGljZXMgPSBJbmRleERhdGF0eXBlLmNyZWF0ZVR5cGVkQXJyYXkoXG4gICAgbnVtYmVyT2ZQb3NpdGlvbnMsXG4gICAgbnVtYmVyT2ZJbmRpY2VzXG4gICk7XG5cbiAgdmFyIGluZGV4ID0gMDtcbiAgZm9yIChpID0gMDsgaSA8IG51bWJlck9mUG9zaXRpb25zIC0gMTsgKytpKSB7XG4gICAgaW5kaWNlc1tpbmRleCsrXSA9IGk7XG4gICAgaW5kaWNlc1tpbmRleCsrXSA9IGkgKyAxO1xuICB9XG5cbiAgcmV0dXJuIG5ldyBHZW9tZXRyeSh7XG4gICAgYXR0cmlidXRlczogYXR0cmlidXRlcyxcbiAgICBpbmRpY2VzOiBpbmRpY2VzLFxuICAgIHByaW1pdGl2ZVR5cGU6IFByaW1pdGl2ZVR5cGUuTElORVMsXG4gICAgYm91bmRpbmdTcGhlcmU6IEJvdW5kaW5nU3BoZXJlLmZyb21Qb2ludHMocG9zaXRpb25zKSxcbiAgfSk7XG59O1xuZXhwb3J0IGRlZmF1bHQgU2ltcGxlUG9seWxpbmVHZW9tZXRyeTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///85440\n')},68738:function(__unused_webpack___webpack_module__,__unused_webpack___webpack_exports__,__webpack_require__){eval('/* harmony import */ var _Cartesian3_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(60216);\n/* harmony import */ var _Check_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(66553);\n/* harmony import */ var _defaultValue_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(62200);\n/* harmony import */ var _defined_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(82982);\n/* harmony import */ var _EllipsoidGeometry_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(64727);\n/* harmony import */ var _VertexFormat_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(67252);\n\n\n\n\n\n\n\n/**\n * A description of a sphere centered at the origin.\n *\n * @alias SphereGeometry\n * @constructor\n *\n * @param {Object} [options] Object with the following properties:\n * @param {Number} [options.radius=1.0] The radius of the sphere.\n * @param {Number} [options.stackPartitions=64] The number of times to partition the ellipsoid into stacks.\n * @param {Number} [options.slicePartitions=64] The number of times to partition the ellipsoid into radial slices.\n * @param {VertexFormat} [options.vertexFormat=VertexFormat.DEFAULT] The vertex attributes to be computed.\n *\n * @exception {DeveloperError} options.slicePartitions cannot be less than three.\n * @exception {DeveloperError} options.stackPartitions cannot be less than three.\n *\n * @see SphereGeometry#createGeometry\n *\n * @example\n * var sphere = new Cesium.SphereGeometry({\n *   radius : 100.0,\n *   vertexFormat : Cesium.VertexFormat.POSITION_ONLY\n * });\n * var geometry = Cesium.SphereGeometry.createGeometry(sphere);\n */\nfunction SphereGeometry(options) {\n  var radius = (0,_defaultValue_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"] */ .Z)(options.radius, 1.0);\n  var radii = new _Cartesian3_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .Z(radius, radius, radius);\n  var ellipsoidOptions = {\n    radii: radii,\n    stackPartitions: options.stackPartitions,\n    slicePartitions: options.slicePartitions,\n    vertexFormat: options.vertexFormat,\n  };\n\n  this._ellipsoidGeometry = new _EllipsoidGeometry_js__WEBPACK_IMPORTED_MODULE_3__/* ["default"] */ .Z(ellipsoidOptions);\n  this._workerName = "createSphereGeometry";\n}\n\n/**\n * The number of elements used to pack the object into an array.\n * @type {Number}\n */\nSphereGeometry.packedLength = _EllipsoidGeometry_js__WEBPACK_IMPORTED_MODULE_3__/* ["default"].packedLength */ .Z.packedLength;\n\n/**\n * Stores the provided instance into the provided array.\n *\n * @param {SphereGeometry} value The value to pack.\n * @param {Number[]} array The array to pack into.\n * @param {Number} [startingIndex=0] The index into the array at which to start packing the elements.\n *\n * @returns {Number[]} The array that was packed into\n */\nSphereGeometry.pack = function (value, array, startingIndex) {\n  //>>includeStart(\'debug\', pragmas.debug);\n  _Check_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"].typeOf.object */ .Z.typeOf.object("value", value);\n  //>>includeEnd(\'debug\');\n\n  return _EllipsoidGeometry_js__WEBPACK_IMPORTED_MODULE_3__/* ["default"].pack */ .Z.pack(value._ellipsoidGeometry, array, startingIndex);\n};\n\nvar scratchEllipsoidGeometry = new _EllipsoidGeometry_js__WEBPACK_IMPORTED_MODULE_3__/* ["default"] */ .Z();\nvar scratchOptions = {\n  radius: undefined,\n  radii: new _Cartesian3_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .Z(),\n  vertexFormat: new _VertexFormat_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .Z(),\n  stackPartitions: undefined,\n  slicePartitions: undefined,\n};\n\n/**\n * Retrieves an instance from a packed array.\n *\n * @param {Number[]} array The packed array.\n * @param {Number} [startingIndex=0] The starting index of the element to be unpacked.\n * @param {SphereGeometry} [result] The object into which to store the result.\n * @returns {SphereGeometry} The modified result parameter or a new SphereGeometry instance if one was not provided.\n */\nSphereGeometry.unpack = function (array, startingIndex, result) {\n  var ellipsoidGeometry = _EllipsoidGeometry_js__WEBPACK_IMPORTED_MODULE_3__/* ["default"].unpack */ .Z.unpack(\n    array,\n    startingIndex,\n    scratchEllipsoidGeometry\n  );\n  scratchOptions.vertexFormat = _VertexFormat_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"].clone */ .Z.clone(\n    ellipsoidGeometry._vertexFormat,\n    scratchOptions.vertexFormat\n  );\n  scratchOptions.stackPartitions = ellipsoidGeometry._stackPartitions;\n  scratchOptions.slicePartitions = ellipsoidGeometry._slicePartitions;\n\n  if (!(0,_defined_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"] */ .Z)(result)) {\n    scratchOptions.radius = ellipsoidGeometry._radii.x;\n    return new SphereGeometry(scratchOptions);\n  }\n\n  _Cartesian3_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].clone */ .Z.clone(ellipsoidGeometry._radii, scratchOptions.radii);\n  result._ellipsoidGeometry = new _EllipsoidGeometry_js__WEBPACK_IMPORTED_MODULE_3__/* ["default"] */ .Z(scratchOptions);\n  return result;\n};\n\n/**\n * Computes the geometric representation of a sphere, including its vertices, indices, and a bounding sphere.\n *\n * @param {SphereGeometry} sphereGeometry A description of the sphere.\n * @returns {Geometry|undefined} The computed vertices and indices.\n */\nSphereGeometry.createGeometry = function (sphereGeometry) {\n  return _EllipsoidGeometry_js__WEBPACK_IMPORTED_MODULE_3__/* ["default"].createGeometry */ .Z.createGeometry(sphereGeometry._ellipsoidGeometry);\n};\n/* unused harmony default export */ var __WEBPACK_DEFAULT_EXPORT__ = ((/* unused pure expression or super */ null && (SphereGeometry)));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNjg3MzguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQXlDO0FBQ1Y7QUFDYztBQUNWO0FBQ29CO0FBQ1Y7O0FBRTdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLGNBQWM7QUFDekI7QUFDQSxlQUFlLGdCQUFnQjtBQUMvQixlQUFlLGdCQUFnQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSxlQUFlLHFFQUFZO0FBQzNCLGtCQUFrQiwrREFBVTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsZ0NBQWdDLHNFQUFpQjtBQUNqRDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQSw4QkFBOEIsZ0dBQThCOztBQUU1RDtBQUNBO0FBQ0E7QUFDQSxXQUFXLGdCQUFnQjtBQUMzQixXQUFXLFVBQVU7QUFDckIsV0FBVyxRQUFRO0FBQ25CO0FBQ0EsYUFBYSxVQUFVO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBLEVBQUUsc0ZBQW1CO0FBQ3JCOztBQUVBLFNBQVMsZ0ZBQXNCO0FBQy9COztBQUVBLG1DQUFtQyxzRUFBaUI7QUFDcEQ7QUFDQTtBQUNBLGFBQWEsK0RBQVU7QUFDdkIsb0JBQW9CLGlFQUFZO0FBQ2hDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFVBQVU7QUFDckIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsZ0JBQWdCO0FBQzNCLGFBQWEsZ0JBQWdCO0FBQzdCO0FBQ0E7QUFDQSwwQkFBMEIsb0ZBQXdCO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLDZFQUFrQjtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLE9BQU8sZ0VBQU87QUFDZDtBQUNBO0FBQ0E7O0FBRUEsRUFBRSwyRUFBZ0I7QUFDbEIsa0NBQWtDLHNFQUFpQjtBQUNuRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsZ0JBQWdCO0FBQzNCLGFBQWEsb0JBQW9CO0FBQ2pDO0FBQ0E7QUFDQSxTQUFTLG9HQUFnQztBQUN6QztBQUNBLHNFQUFlLDhEQUFjLElBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly92dWUzLXdlYnBhY2s1Ly4vbm9kZV9tb2R1bGVzL2Nlc2l1bS9Tb3VyY2UvQ29yZS9TcGhlcmVHZW9tZXRyeS5qcz82YjY4Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBDYXJ0ZXNpYW4zIGZyb20gXCIuL0NhcnRlc2lhbjMuanNcIjtcbmltcG9ydCBDaGVjayBmcm9tIFwiLi9DaGVjay5qc1wiO1xuaW1wb3J0IGRlZmF1bHRWYWx1ZSBmcm9tIFwiLi9kZWZhdWx0VmFsdWUuanNcIjtcbmltcG9ydCBkZWZpbmVkIGZyb20gXCIuL2RlZmluZWQuanNcIjtcbmltcG9ydCBFbGxpcHNvaWRHZW9tZXRyeSBmcm9tIFwiLi9FbGxpcHNvaWRHZW9tZXRyeS5qc1wiO1xuaW1wb3J0IFZlcnRleEZvcm1hdCBmcm9tIFwiLi9WZXJ0ZXhGb3JtYXQuanNcIjtcblxuLyoqXG4gKiBBIGRlc2NyaXB0aW9uIG9mIGEgc3BoZXJlIGNlbnRlcmVkIGF0IHRoZSBvcmlnaW4uXG4gKlxuICogQGFsaWFzIFNwaGVyZUdlb21ldHJ5XG4gKiBAY29uc3RydWN0b3JcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIE9iamVjdCB3aXRoIHRoZSBmb2xsb3dpbmcgcHJvcGVydGllczpcbiAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5yYWRpdXM9MS4wXSBUaGUgcmFkaXVzIG9mIHRoZSBzcGhlcmUuXG4gKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMuc3RhY2tQYXJ0aXRpb25zPTY0XSBUaGUgbnVtYmVyIG9mIHRpbWVzIHRvIHBhcnRpdGlvbiB0aGUgZWxsaXBzb2lkIGludG8gc3RhY2tzLlxuICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLnNsaWNlUGFydGl0aW9ucz02NF0gVGhlIG51bWJlciBvZiB0aW1lcyB0byBwYXJ0aXRpb24gdGhlIGVsbGlwc29pZCBpbnRvIHJhZGlhbCBzbGljZXMuXG4gKiBAcGFyYW0ge1ZlcnRleEZvcm1hdH0gW29wdGlvbnMudmVydGV4Rm9ybWF0PVZlcnRleEZvcm1hdC5ERUZBVUxUXSBUaGUgdmVydGV4IGF0dHJpYnV0ZXMgdG8gYmUgY29tcHV0ZWQuXG4gKlxuICogQGV4Y2VwdGlvbiB7RGV2ZWxvcGVyRXJyb3J9IG9wdGlvbnMuc2xpY2VQYXJ0aXRpb25zIGNhbm5vdCBiZSBsZXNzIHRoYW4gdGhyZWUuXG4gKiBAZXhjZXB0aW9uIHtEZXZlbG9wZXJFcnJvcn0gb3B0aW9ucy5zdGFja1BhcnRpdGlvbnMgY2Fubm90IGJlIGxlc3MgdGhhbiB0aHJlZS5cbiAqXG4gKiBAc2VlIFNwaGVyZUdlb21ldHJ5I2NyZWF0ZUdlb21ldHJ5XG4gKlxuICogQGV4YW1wbGVcbiAqIHZhciBzcGhlcmUgPSBuZXcgQ2VzaXVtLlNwaGVyZUdlb21ldHJ5KHtcbiAqICAgcmFkaXVzIDogMTAwLjAsXG4gKiAgIHZlcnRleEZvcm1hdCA6IENlc2l1bS5WZXJ0ZXhGb3JtYXQuUE9TSVRJT05fT05MWVxuICogfSk7XG4gKiB2YXIgZ2VvbWV0cnkgPSBDZXNpdW0uU3BoZXJlR2VvbWV0cnkuY3JlYXRlR2VvbWV0cnkoc3BoZXJlKTtcbiAqL1xuZnVuY3Rpb24gU3BoZXJlR2VvbWV0cnkob3B0aW9ucykge1xuICB2YXIgcmFkaXVzID0gZGVmYXVsdFZhbHVlKG9wdGlvbnMucmFkaXVzLCAxLjApO1xuICB2YXIgcmFkaWkgPSBuZXcgQ2FydGVzaWFuMyhyYWRpdXMsIHJhZGl1cywgcmFkaXVzKTtcbiAgdmFyIGVsbGlwc29pZE9wdGlvbnMgPSB7XG4gICAgcmFkaWk6IHJhZGlpLFxuICAgIHN0YWNrUGFydGl0aW9uczogb3B0aW9ucy5zdGFja1BhcnRpdGlvbnMsXG4gICAgc2xpY2VQYXJ0aXRpb25zOiBvcHRpb25zLnNsaWNlUGFydGl0aW9ucyxcbiAgICB2ZXJ0ZXhGb3JtYXQ6IG9wdGlvbnMudmVydGV4Rm9ybWF0LFxuICB9O1xuXG4gIHRoaXMuX2VsbGlwc29pZEdlb21ldHJ5ID0gbmV3IEVsbGlwc29pZEdlb21ldHJ5KGVsbGlwc29pZE9wdGlvbnMpO1xuICB0aGlzLl93b3JrZXJOYW1lID0gXCJjcmVhdGVTcGhlcmVHZW9tZXRyeVwiO1xufVxuXG4vKipcbiAqIFRoZSBudW1iZXIgb2YgZWxlbWVudHMgdXNlZCB0byBwYWNrIHRoZSBvYmplY3QgaW50byBhbiBhcnJheS5cbiAqIEB0eXBlIHtOdW1iZXJ9XG4gKi9cblNwaGVyZUdlb21ldHJ5LnBhY2tlZExlbmd0aCA9IEVsbGlwc29pZEdlb21ldHJ5LnBhY2tlZExlbmd0aDtcblxuLyoqXG4gKiBTdG9yZXMgdGhlIHByb3ZpZGVkIGluc3RhbmNlIGludG8gdGhlIHByb3ZpZGVkIGFycmF5LlxuICpcbiAqIEBwYXJhbSB7U3BoZXJlR2VvbWV0cnl9IHZhbHVlIFRoZSB2YWx1ZSB0byBwYWNrLlxuICogQHBhcmFtIHtOdW1iZXJbXX0gYXJyYXkgVGhlIGFycmF5IHRvIHBhY2sgaW50by5cbiAqIEBwYXJhbSB7TnVtYmVyfSBbc3RhcnRpbmdJbmRleD0wXSBUaGUgaW5kZXggaW50byB0aGUgYXJyYXkgYXQgd2hpY2ggdG8gc3RhcnQgcGFja2luZyB0aGUgZWxlbWVudHMuXG4gKlxuICogQHJldHVybnMge051bWJlcltdfSBUaGUgYXJyYXkgdGhhdCB3YXMgcGFja2VkIGludG9cbiAqL1xuU3BoZXJlR2VvbWV0cnkucGFjayA9IGZ1bmN0aW9uICh2YWx1ZSwgYXJyYXksIHN0YXJ0aW5nSW5kZXgpIHtcbiAgLy8+PmluY2x1ZGVTdGFydCgnZGVidWcnLCBwcmFnbWFzLmRlYnVnKTtcbiAgQ2hlY2sudHlwZU9mLm9iamVjdChcInZhbHVlXCIsIHZhbHVlKTtcbiAgLy8+PmluY2x1ZGVFbmQoJ2RlYnVnJyk7XG5cbiAgcmV0dXJuIEVsbGlwc29pZEdlb21ldHJ5LnBhY2sodmFsdWUuX2VsbGlwc29pZEdlb21ldHJ5LCBhcnJheSwgc3RhcnRpbmdJbmRleCk7XG59O1xuXG52YXIgc2NyYXRjaEVsbGlwc29pZEdlb21ldHJ5ID0gbmV3IEVsbGlwc29pZEdlb21ldHJ5KCk7XG52YXIgc2NyYXRjaE9wdGlvbnMgPSB7XG4gIHJhZGl1czogdW5kZWZpbmVkLFxuICByYWRpaTogbmV3IENhcnRlc2lhbjMoKSxcbiAgdmVydGV4Rm9ybWF0OiBuZXcgVmVydGV4Rm9ybWF0KCksXG4gIHN0YWNrUGFydGl0aW9uczogdW5kZWZpbmVkLFxuICBzbGljZVBhcnRpdGlvbnM6IHVuZGVmaW5lZCxcbn07XG5cbi8qKlxuICogUmV0cmlldmVzIGFuIGluc3RhbmNlIGZyb20gYSBwYWNrZWQgYXJyYXkuXG4gKlxuICogQHBhcmFtIHtOdW1iZXJbXX0gYXJyYXkgVGhlIHBhY2tlZCBhcnJheS5cbiAqIEBwYXJhbSB7TnVtYmVyfSBbc3RhcnRpbmdJbmRleD0wXSBUaGUgc3RhcnRpbmcgaW5kZXggb2YgdGhlIGVsZW1lbnQgdG8gYmUgdW5wYWNrZWQuXG4gKiBAcGFyYW0ge1NwaGVyZUdlb21ldHJ5fSBbcmVzdWx0XSBUaGUgb2JqZWN0IGludG8gd2hpY2ggdG8gc3RvcmUgdGhlIHJlc3VsdC5cbiAqIEByZXR1cm5zIHtTcGhlcmVHZW9tZXRyeX0gVGhlIG1vZGlmaWVkIHJlc3VsdCBwYXJhbWV0ZXIgb3IgYSBuZXcgU3BoZXJlR2VvbWV0cnkgaW5zdGFuY2UgaWYgb25lIHdhcyBub3QgcHJvdmlkZWQuXG4gKi9cblNwaGVyZUdlb21ldHJ5LnVucGFjayA9IGZ1bmN0aW9uIChhcnJheSwgc3RhcnRpbmdJbmRleCwgcmVzdWx0KSB7XG4gIHZhciBlbGxpcHNvaWRHZW9tZXRyeSA9IEVsbGlwc29pZEdlb21ldHJ5LnVucGFjayhcbiAgICBhcnJheSxcbiAgICBzdGFydGluZ0luZGV4LFxuICAgIHNjcmF0Y2hFbGxpcHNvaWRHZW9tZXRyeVxuICApO1xuICBzY3JhdGNoT3B0aW9ucy52ZXJ0ZXhGb3JtYXQgPSBWZXJ0ZXhGb3JtYXQuY2xvbmUoXG4gICAgZWxsaXBzb2lkR2VvbWV0cnkuX3ZlcnRleEZvcm1hdCxcbiAgICBzY3JhdGNoT3B0aW9ucy52ZXJ0ZXhGb3JtYXRcbiAgKTtcbiAgc2NyYXRjaE9wdGlvbnMuc3RhY2tQYXJ0aXRpb25zID0gZWxsaXBzb2lkR2VvbWV0cnkuX3N0YWNrUGFydGl0aW9ucztcbiAgc2NyYXRjaE9wdGlvbnMuc2xpY2VQYXJ0aXRpb25zID0gZWxsaXBzb2lkR2VvbWV0cnkuX3NsaWNlUGFydGl0aW9ucztcblxuICBpZiAoIWRlZmluZWQocmVzdWx0KSkge1xuICAgIHNjcmF0Y2hPcHRpb25zLnJhZGl1cyA9IGVsbGlwc29pZEdlb21ldHJ5Ll9yYWRpaS54O1xuICAgIHJldHVybiBuZXcgU3BoZXJlR2VvbWV0cnkoc2NyYXRjaE9wdGlvbnMpO1xuICB9XG5cbiAgQ2FydGVzaWFuMy5jbG9uZShlbGxpcHNvaWRHZW9tZXRyeS5fcmFkaWksIHNjcmF0Y2hPcHRpb25zLnJhZGlpKTtcbiAgcmVzdWx0Ll9lbGxpcHNvaWRHZW9tZXRyeSA9IG5ldyBFbGxpcHNvaWRHZW9tZXRyeShzY3JhdGNoT3B0aW9ucyk7XG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG4vKipcbiAqIENvbXB1dGVzIHRoZSBnZW9tZXRyaWMgcmVwcmVzZW50YXRpb24gb2YgYSBzcGhlcmUsIGluY2x1ZGluZyBpdHMgdmVydGljZXMsIGluZGljZXMsIGFuZCBhIGJvdW5kaW5nIHNwaGVyZS5cbiAqXG4gKiBAcGFyYW0ge1NwaGVyZUdlb21ldHJ5fSBzcGhlcmVHZW9tZXRyeSBBIGRlc2NyaXB0aW9uIG9mIHRoZSBzcGhlcmUuXG4gKiBAcmV0dXJucyB7R2VvbWV0cnl8dW5kZWZpbmVkfSBUaGUgY29tcHV0ZWQgdmVydGljZXMgYW5kIGluZGljZXMuXG4gKi9cblNwaGVyZUdlb21ldHJ5LmNyZWF0ZUdlb21ldHJ5ID0gZnVuY3Rpb24gKHNwaGVyZUdlb21ldHJ5KSB7XG4gIHJldHVybiBFbGxpcHNvaWRHZW9tZXRyeS5jcmVhdGVHZW9tZXRyeShzcGhlcmVHZW9tZXRyeS5fZWxsaXBzb2lkR2VvbWV0cnkpO1xufTtcbmV4cG9ydCBkZWZhdWx0IFNwaGVyZUdlb21ldHJ5O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///68738\n')},38779:function(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__){eval('/* harmony import */ var _Cartesian3_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(60216);\n/* harmony import */ var _Check_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(66553);\n/* harmony import */ var _defaultValue_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(62200);\n/* harmony import */ var _defined_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(82982);\n/* harmony import */ var _EllipsoidOutlineGeometry_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(75619);\n\n\n\n\n\n\n/**\n * A description of the outline of a sphere.\n *\n * @alias SphereOutlineGeometry\n * @constructor\n *\n * @param {Object} [options] Object with the following properties:\n * @param {Number} [options.radius=1.0] The radius of the sphere.\n * @param {Number} [options.stackPartitions=10] The count of stacks for the sphere (1 greater than the number of parallel lines).\n * @param {Number} [options.slicePartitions=8] The count of slices for the sphere (Equal to the number of radial lines).\n * @param {Number} [options.subdivisions=200] The number of points per line, determining the granularity of the curvature .\n *\n * @exception {DeveloperError} options.stackPartitions must be greater than or equal to one.\n * @exception {DeveloperError} options.slicePartitions must be greater than or equal to zero.\n * @exception {DeveloperError} options.subdivisions must be greater than or equal to zero.\n *\n * @example\n * var sphere = new Cesium.SphereOutlineGeometry({\n *   radius : 100.0,\n *   stackPartitions : 6,\n *   slicePartitions: 5\n * });\n * var geometry = Cesium.SphereOutlineGeometry.createGeometry(sphere);\n */\nfunction SphereOutlineGeometry(options) {\n  var radius = (0,_defaultValue_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"] */ .Z)(options.radius, 1.0);\n  var radii = new _Cartesian3_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .Z(radius, radius, radius);\n  var ellipsoidOptions = {\n    radii: radii,\n    stackPartitions: options.stackPartitions,\n    slicePartitions: options.slicePartitions,\n    subdivisions: options.subdivisions,\n  };\n\n  this._ellipsoidGeometry = new _EllipsoidOutlineGeometry_js__WEBPACK_IMPORTED_MODULE_3__/* ["default"] */ .Z(ellipsoidOptions);\n  this._workerName = "createSphereOutlineGeometry";\n}\n\n/**\n * The number of elements used to pack the object into an array.\n * @type {Number}\n */\nSphereOutlineGeometry.packedLength = _EllipsoidOutlineGeometry_js__WEBPACK_IMPORTED_MODULE_3__/* ["default"].packedLength */ .Z.packedLength;\n\n/**\n * Stores the provided instance into the provided array.\n *\n * @param {SphereOutlineGeometry} value The value to pack.\n * @param {Number[]} array The array to pack into.\n * @param {Number} [startingIndex=0] The index into the array at which to start packing the elements.\n *\n * @returns {Number[]} The array that was packed into\n */\nSphereOutlineGeometry.pack = function (value, array, startingIndex) {\n  //>>includeStart(\'debug\', pragmas.debug);\n  _Check_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"].typeOf.object */ .Z.typeOf.object("value", value);\n  //>>includeEnd(\'debug\');\n\n  return _EllipsoidOutlineGeometry_js__WEBPACK_IMPORTED_MODULE_3__/* ["default"].pack */ .Z.pack(\n    value._ellipsoidGeometry,\n    array,\n    startingIndex\n  );\n};\n\nvar scratchEllipsoidGeometry = new _EllipsoidOutlineGeometry_js__WEBPACK_IMPORTED_MODULE_3__/* ["default"] */ .Z();\nvar scratchOptions = {\n  radius: undefined,\n  radii: new _Cartesian3_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .Z(),\n  stackPartitions: undefined,\n  slicePartitions: undefined,\n  subdivisions: undefined,\n};\n\n/**\n * Retrieves an instance from a packed array.\n *\n * @param {Number[]} array The packed array.\n * @param {Number} [startingIndex=0] The starting index of the element to be unpacked.\n * @param {SphereOutlineGeometry} [result] The object into which to store the result.\n * @returns {SphereOutlineGeometry} The modified result parameter or a new SphereOutlineGeometry instance if one was not provided.\n */\nSphereOutlineGeometry.unpack = function (array, startingIndex, result) {\n  var ellipsoidGeometry = _EllipsoidOutlineGeometry_js__WEBPACK_IMPORTED_MODULE_3__/* ["default"].unpack */ .Z.unpack(\n    array,\n    startingIndex,\n    scratchEllipsoidGeometry\n  );\n  scratchOptions.stackPartitions = ellipsoidGeometry._stackPartitions;\n  scratchOptions.slicePartitions = ellipsoidGeometry._slicePartitions;\n  scratchOptions.subdivisions = ellipsoidGeometry._subdivisions;\n\n  if (!(0,_defined_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .Z)(result)) {\n    scratchOptions.radius = ellipsoidGeometry._radii.x;\n    return new SphereOutlineGeometry(scratchOptions);\n  }\n\n  _Cartesian3_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].clone */ .Z.clone(ellipsoidGeometry._radii, scratchOptions.radii);\n  result._ellipsoidGeometry = new _EllipsoidOutlineGeometry_js__WEBPACK_IMPORTED_MODULE_3__/* ["default"] */ .Z(scratchOptions);\n  return result;\n};\n\n/**\n * Computes the geometric representation of an outline of a sphere, including its vertices, indices, and a bounding sphere.\n *\n * @param {SphereOutlineGeometry} sphereGeometry A description of the sphere outline.\n * @returns {Geometry|undefined} The computed vertices and indices.\n */\nSphereOutlineGeometry.createGeometry = function (sphereGeometry) {\n  return _EllipsoidOutlineGeometry_js__WEBPACK_IMPORTED_MODULE_3__/* ["default"].createGeometry */ .Z.createGeometry(\n    sphereGeometry._ellipsoidGeometry\n  );\n};\n/* harmony default export */ __webpack_exports__["Z"] = (SphereOutlineGeometry);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMzg3NzkuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBeUM7QUFDVjtBQUNjO0FBQ1Y7QUFDa0M7O0FBRXJFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkI7QUFDQSxlQUFlLGdCQUFnQjtBQUMvQixlQUFlLGdCQUFnQjtBQUMvQixlQUFlLGdCQUFnQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0EsZUFBZSxxRUFBWTtBQUMzQixrQkFBa0IsK0RBQVU7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGdDQUFnQyw2RUFBd0I7QUFDeEQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0EscUNBQXFDLHVHQUFxQzs7QUFFMUU7QUFDQTtBQUNBO0FBQ0EsV0FBVyx1QkFBdUI7QUFDbEMsV0FBVyxVQUFVO0FBQ3JCLFdBQVcsUUFBUTtBQUNuQjtBQUNBLGFBQWEsVUFBVTtBQUN2QjtBQUNBO0FBQ0E7QUFDQSxFQUFFLHNGQUFtQjtBQUNyQjs7QUFFQSxTQUFTLHVGQUE2QjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG1DQUFtQyw2RUFBd0I7QUFDM0Q7QUFDQTtBQUNBLGFBQWEsK0RBQVU7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxVQUFVO0FBQ3JCLFdBQVcsUUFBUTtBQUNuQixXQUFXLHVCQUF1QjtBQUNsQyxhQUFhLHVCQUF1QjtBQUNwQztBQUNBO0FBQ0EsMEJBQTBCLDJGQUErQjtBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxPQUFPLGdFQUFPO0FBQ2Q7QUFDQTtBQUNBOztBQUVBLEVBQUUsMkVBQWdCO0FBQ2xCLGtDQUFrQyw2RUFBd0I7QUFDMUQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLHVCQUF1QjtBQUNsQyxhQUFhLG9CQUFvQjtBQUNqQztBQUNBO0FBQ0EsU0FBUywyR0FBdUM7QUFDaEQ7QUFDQTtBQUNBO0FBQ0EseURBQWUscUJBQXFCLEVBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly92dWUzLXdlYnBhY2s1Ly4vbm9kZV9tb2R1bGVzL2Nlc2l1bS9Tb3VyY2UvQ29yZS9TcGhlcmVPdXRsaW5lR2VvbWV0cnkuanM/YTdmZiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgQ2FydGVzaWFuMyBmcm9tIFwiLi9DYXJ0ZXNpYW4zLmpzXCI7XG5pbXBvcnQgQ2hlY2sgZnJvbSBcIi4vQ2hlY2suanNcIjtcbmltcG9ydCBkZWZhdWx0VmFsdWUgZnJvbSBcIi4vZGVmYXVsdFZhbHVlLmpzXCI7XG5pbXBvcnQgZGVmaW5lZCBmcm9tIFwiLi9kZWZpbmVkLmpzXCI7XG5pbXBvcnQgRWxsaXBzb2lkT3V0bGluZUdlb21ldHJ5IGZyb20gXCIuL0VsbGlwc29pZE91dGxpbmVHZW9tZXRyeS5qc1wiO1xuXG4vKipcbiAqIEEgZGVzY3JpcHRpb24gb2YgdGhlIG91dGxpbmUgb2YgYSBzcGhlcmUuXG4gKlxuICogQGFsaWFzIFNwaGVyZU91dGxpbmVHZW9tZXRyeVxuICogQGNvbnN0cnVjdG9yXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSBPYmplY3Qgd2l0aCB0aGUgZm9sbG93aW5nIHByb3BlcnRpZXM6XG4gKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMucmFkaXVzPTEuMF0gVGhlIHJhZGl1cyBvZiB0aGUgc3BoZXJlLlxuICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLnN0YWNrUGFydGl0aW9ucz0xMF0gVGhlIGNvdW50IG9mIHN0YWNrcyBmb3IgdGhlIHNwaGVyZSAoMSBncmVhdGVyIHRoYW4gdGhlIG51bWJlciBvZiBwYXJhbGxlbCBsaW5lcykuXG4gKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMuc2xpY2VQYXJ0aXRpb25zPThdIFRoZSBjb3VudCBvZiBzbGljZXMgZm9yIHRoZSBzcGhlcmUgKEVxdWFsIHRvIHRoZSBudW1iZXIgb2YgcmFkaWFsIGxpbmVzKS5cbiAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5zdWJkaXZpc2lvbnM9MjAwXSBUaGUgbnVtYmVyIG9mIHBvaW50cyBwZXIgbGluZSwgZGV0ZXJtaW5pbmcgdGhlIGdyYW51bGFyaXR5IG9mIHRoZSBjdXJ2YXR1cmUgLlxuICpcbiAqIEBleGNlcHRpb24ge0RldmVsb3BlckVycm9yfSBvcHRpb25zLnN0YWNrUGFydGl0aW9ucyBtdXN0IGJlIGdyZWF0ZXIgdGhhbiBvciBlcXVhbCB0byBvbmUuXG4gKiBAZXhjZXB0aW9uIHtEZXZlbG9wZXJFcnJvcn0gb3B0aW9ucy5zbGljZVBhcnRpdGlvbnMgbXVzdCBiZSBncmVhdGVyIHRoYW4gb3IgZXF1YWwgdG8gemVyby5cbiAqIEBleGNlcHRpb24ge0RldmVsb3BlckVycm9yfSBvcHRpb25zLnN1YmRpdmlzaW9ucyBtdXN0IGJlIGdyZWF0ZXIgdGhhbiBvciBlcXVhbCB0byB6ZXJvLlxuICpcbiAqIEBleGFtcGxlXG4gKiB2YXIgc3BoZXJlID0gbmV3IENlc2l1bS5TcGhlcmVPdXRsaW5lR2VvbWV0cnkoe1xuICogICByYWRpdXMgOiAxMDAuMCxcbiAqICAgc3RhY2tQYXJ0aXRpb25zIDogNixcbiAqICAgc2xpY2VQYXJ0aXRpb25zOiA1XG4gKiB9KTtcbiAqIHZhciBnZW9tZXRyeSA9IENlc2l1bS5TcGhlcmVPdXRsaW5lR2VvbWV0cnkuY3JlYXRlR2VvbWV0cnkoc3BoZXJlKTtcbiAqL1xuZnVuY3Rpb24gU3BoZXJlT3V0bGluZUdlb21ldHJ5KG9wdGlvbnMpIHtcbiAgdmFyIHJhZGl1cyA9IGRlZmF1bHRWYWx1ZShvcHRpb25zLnJhZGl1cywgMS4wKTtcbiAgdmFyIHJhZGlpID0gbmV3IENhcnRlc2lhbjMocmFkaXVzLCByYWRpdXMsIHJhZGl1cyk7XG4gIHZhciBlbGxpcHNvaWRPcHRpb25zID0ge1xuICAgIHJhZGlpOiByYWRpaSxcbiAgICBzdGFja1BhcnRpdGlvbnM6IG9wdGlvbnMuc3RhY2tQYXJ0aXRpb25zLFxuICAgIHNsaWNlUGFydGl0aW9uczogb3B0aW9ucy5zbGljZVBhcnRpdGlvbnMsXG4gICAgc3ViZGl2aXNpb25zOiBvcHRpb25zLnN1YmRpdmlzaW9ucyxcbiAgfTtcblxuICB0aGlzLl9lbGxpcHNvaWRHZW9tZXRyeSA9IG5ldyBFbGxpcHNvaWRPdXRsaW5lR2VvbWV0cnkoZWxsaXBzb2lkT3B0aW9ucyk7XG4gIHRoaXMuX3dvcmtlck5hbWUgPSBcImNyZWF0ZVNwaGVyZU91dGxpbmVHZW9tZXRyeVwiO1xufVxuXG4vKipcbiAqIFRoZSBudW1iZXIgb2YgZWxlbWVudHMgdXNlZCB0byBwYWNrIHRoZSBvYmplY3QgaW50byBhbiBhcnJheS5cbiAqIEB0eXBlIHtOdW1iZXJ9XG4gKi9cblNwaGVyZU91dGxpbmVHZW9tZXRyeS5wYWNrZWRMZW5ndGggPSBFbGxpcHNvaWRPdXRsaW5lR2VvbWV0cnkucGFja2VkTGVuZ3RoO1xuXG4vKipcbiAqIFN0b3JlcyB0aGUgcHJvdmlkZWQgaW5zdGFuY2UgaW50byB0aGUgcHJvdmlkZWQgYXJyYXkuXG4gKlxuICogQHBhcmFtIHtTcGhlcmVPdXRsaW5lR2VvbWV0cnl9IHZhbHVlIFRoZSB2YWx1ZSB0byBwYWNrLlxuICogQHBhcmFtIHtOdW1iZXJbXX0gYXJyYXkgVGhlIGFycmF5IHRvIHBhY2sgaW50by5cbiAqIEBwYXJhbSB7TnVtYmVyfSBbc3RhcnRpbmdJbmRleD0wXSBUaGUgaW5kZXggaW50byB0aGUgYXJyYXkgYXQgd2hpY2ggdG8gc3RhcnQgcGFja2luZyB0aGUgZWxlbWVudHMuXG4gKlxuICogQHJldHVybnMge051bWJlcltdfSBUaGUgYXJyYXkgdGhhdCB3YXMgcGFja2VkIGludG9cbiAqL1xuU3BoZXJlT3V0bGluZUdlb21ldHJ5LnBhY2sgPSBmdW5jdGlvbiAodmFsdWUsIGFycmF5LCBzdGFydGluZ0luZGV4KSB7XG4gIC8vPj5pbmNsdWRlU3RhcnQoJ2RlYnVnJywgcHJhZ21hcy5kZWJ1Zyk7XG4gIENoZWNrLnR5cGVPZi5vYmplY3QoXCJ2YWx1ZVwiLCB2YWx1ZSk7XG4gIC8vPj5pbmNsdWRlRW5kKCdkZWJ1ZycpO1xuXG4gIHJldHVybiBFbGxpcHNvaWRPdXRsaW5lR2VvbWV0cnkucGFjayhcbiAgICB2YWx1ZS5fZWxsaXBzb2lkR2VvbWV0cnksXG4gICAgYXJyYXksXG4gICAgc3RhcnRpbmdJbmRleFxuICApO1xufTtcblxudmFyIHNjcmF0Y2hFbGxpcHNvaWRHZW9tZXRyeSA9IG5ldyBFbGxpcHNvaWRPdXRsaW5lR2VvbWV0cnkoKTtcbnZhciBzY3JhdGNoT3B0aW9ucyA9IHtcbiAgcmFkaXVzOiB1bmRlZmluZWQsXG4gIHJhZGlpOiBuZXcgQ2FydGVzaWFuMygpLFxuICBzdGFja1BhcnRpdGlvbnM6IHVuZGVmaW5lZCxcbiAgc2xpY2VQYXJ0aXRpb25zOiB1bmRlZmluZWQsXG4gIHN1YmRpdmlzaW9uczogdW5kZWZpbmVkLFxufTtcblxuLyoqXG4gKiBSZXRyaWV2ZXMgYW4gaW5zdGFuY2UgZnJvbSBhIHBhY2tlZCBhcnJheS5cbiAqXG4gKiBAcGFyYW0ge051bWJlcltdfSBhcnJheSBUaGUgcGFja2VkIGFycmF5LlxuICogQHBhcmFtIHtOdW1iZXJ9IFtzdGFydGluZ0luZGV4PTBdIFRoZSBzdGFydGluZyBpbmRleCBvZiB0aGUgZWxlbWVudCB0byBiZSB1bnBhY2tlZC5cbiAqIEBwYXJhbSB7U3BoZXJlT3V0bGluZUdlb21ldHJ5fSBbcmVzdWx0XSBUaGUgb2JqZWN0IGludG8gd2hpY2ggdG8gc3RvcmUgdGhlIHJlc3VsdC5cbiAqIEByZXR1cm5zIHtTcGhlcmVPdXRsaW5lR2VvbWV0cnl9IFRoZSBtb2RpZmllZCByZXN1bHQgcGFyYW1ldGVyIG9yIGEgbmV3IFNwaGVyZU91dGxpbmVHZW9tZXRyeSBpbnN0YW5jZSBpZiBvbmUgd2FzIG5vdCBwcm92aWRlZC5cbiAqL1xuU3BoZXJlT3V0bGluZUdlb21ldHJ5LnVucGFjayA9IGZ1bmN0aW9uIChhcnJheSwgc3RhcnRpbmdJbmRleCwgcmVzdWx0KSB7XG4gIHZhciBlbGxpcHNvaWRHZW9tZXRyeSA9IEVsbGlwc29pZE91dGxpbmVHZW9tZXRyeS51bnBhY2soXG4gICAgYXJyYXksXG4gICAgc3RhcnRpbmdJbmRleCxcbiAgICBzY3JhdGNoRWxsaXBzb2lkR2VvbWV0cnlcbiAgKTtcbiAgc2NyYXRjaE9wdGlvbnMuc3RhY2tQYXJ0aXRpb25zID0gZWxsaXBzb2lkR2VvbWV0cnkuX3N0YWNrUGFydGl0aW9ucztcbiAgc2NyYXRjaE9wdGlvbnMuc2xpY2VQYXJ0aXRpb25zID0gZWxsaXBzb2lkR2VvbWV0cnkuX3NsaWNlUGFydGl0aW9ucztcbiAgc2NyYXRjaE9wdGlvbnMuc3ViZGl2aXNpb25zID0gZWxsaXBzb2lkR2VvbWV0cnkuX3N1YmRpdmlzaW9ucztcblxuICBpZiAoIWRlZmluZWQocmVzdWx0KSkge1xuICAgIHNjcmF0Y2hPcHRpb25zLnJhZGl1cyA9IGVsbGlwc29pZEdlb21ldHJ5Ll9yYWRpaS54O1xuICAgIHJldHVybiBuZXcgU3BoZXJlT3V0bGluZUdlb21ldHJ5KHNjcmF0Y2hPcHRpb25zKTtcbiAgfVxuXG4gIENhcnRlc2lhbjMuY2xvbmUoZWxsaXBzb2lkR2VvbWV0cnkuX3JhZGlpLCBzY3JhdGNoT3B0aW9ucy5yYWRpaSk7XG4gIHJlc3VsdC5fZWxsaXBzb2lkR2VvbWV0cnkgPSBuZXcgRWxsaXBzb2lkT3V0bGluZUdlb21ldHJ5KHNjcmF0Y2hPcHRpb25zKTtcbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbi8qKlxuICogQ29tcHV0ZXMgdGhlIGdlb21ldHJpYyByZXByZXNlbnRhdGlvbiBvZiBhbiBvdXRsaW5lIG9mIGEgc3BoZXJlLCBpbmNsdWRpbmcgaXRzIHZlcnRpY2VzLCBpbmRpY2VzLCBhbmQgYSBib3VuZGluZyBzcGhlcmUuXG4gKlxuICogQHBhcmFtIHtTcGhlcmVPdXRsaW5lR2VvbWV0cnl9IHNwaGVyZUdlb21ldHJ5IEEgZGVzY3JpcHRpb24gb2YgdGhlIHNwaGVyZSBvdXRsaW5lLlxuICogQHJldHVybnMge0dlb21ldHJ5fHVuZGVmaW5lZH0gVGhlIGNvbXB1dGVkIHZlcnRpY2VzIGFuZCBpbmRpY2VzLlxuICovXG5TcGhlcmVPdXRsaW5lR2VvbWV0cnkuY3JlYXRlR2VvbWV0cnkgPSBmdW5jdGlvbiAoc3BoZXJlR2VvbWV0cnkpIHtcbiAgcmV0dXJuIEVsbGlwc29pZE91dGxpbmVHZW9tZXRyeS5jcmVhdGVHZW9tZXRyeShcbiAgICBzcGhlcmVHZW9tZXRyeS5fZWxsaXBzb2lkR2VvbWV0cnlcbiAgKTtcbn07XG5leHBvcnQgZGVmYXVsdCBTcGhlcmVPdXRsaW5lR2VvbWV0cnk7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///38779\n')},67807:function(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__){eval('/* harmony import */ var _Check_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(66553);\n/* harmony import */ var _defaultValue_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(62200);\n/* harmony import */ var _defined_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(82982);\n\n\n\n\n/**\n * A set of curvilinear 3-dimensional coordinates.\n *\n * @alias Spherical\n * @constructor\n *\n * @param {Number} [clock=0.0] The angular coordinate lying in the xy-plane measured from the positive x-axis and toward the positive y-axis.\n * @param {Number} [cone=0.0] The angular coordinate measured from the positive z-axis and toward the negative z-axis.\n * @param {Number} [magnitude=1.0] The linear coordinate measured from the origin.\n */\nfunction Spherical(clock, cone, magnitude) {\n  /**\n   * The clock component.\n   * @type {Number}\n   * @default 0.0\n   */\n  this.clock = (0,_defaultValue_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .Z)(clock, 0.0);\n  /**\n   * The cone component.\n   * @type {Number}\n   * @default 0.0\n   */\n  this.cone = (0,_defaultValue_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .Z)(cone, 0.0);\n  /**\n   * The magnitude component.\n   * @type {Number}\n   * @default 1.0\n   */\n  this.magnitude = (0,_defaultValue_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .Z)(magnitude, 1.0);\n}\n\n/**\n * Converts the provided Cartesian3 into Spherical coordinates.\n *\n * @param {Cartesian3} cartesian3 The Cartesian3 to be converted to Spherical.\n * @param {Spherical} [result] The object in which the result will be stored, if undefined a new instance will be created.\n * @returns {Spherical} The modified result parameter, or a new instance if one was not provided.\n */\nSpherical.fromCartesian3 = function (cartesian3, result) {\n  //>>includeStart(\'debug\', pragmas.debug);\n  _Check_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].typeOf.object */ .Z.typeOf.object("cartesian3", cartesian3);\n  //>>includeEnd(\'debug\');\n\n  var x = cartesian3.x;\n  var y = cartesian3.y;\n  var z = cartesian3.z;\n  var radialSquared = x * x + y * y;\n\n  if (!(0,_defined_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"] */ .Z)(result)) {\n    result = new Spherical();\n  }\n\n  result.clock = Math.atan2(y, x);\n  result.cone = Math.atan2(Math.sqrt(radialSquared), z);\n  result.magnitude = Math.sqrt(radialSquared + z * z);\n  return result;\n};\n\n/**\n * Creates a duplicate of a Spherical.\n *\n * @param {Spherical} spherical The spherical to clone.\n * @param {Spherical} [result] The object to store the result into, if undefined a new instance will be created.\n * @returns {Spherical} The modified result parameter or a new instance if result was undefined. (Returns undefined if spherical is undefined)\n */\nSpherical.clone = function (spherical, result) {\n  if (!(0,_defined_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"] */ .Z)(spherical)) {\n    return undefined;\n  }\n\n  if (!(0,_defined_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"] */ .Z)(result)) {\n    return new Spherical(spherical.clock, spherical.cone, spherical.magnitude);\n  }\n\n  result.clock = spherical.clock;\n  result.cone = spherical.cone;\n  result.magnitude = spherical.magnitude;\n  return result;\n};\n\n/**\n * Computes the normalized version of the provided spherical.\n *\n * @param {Spherical} spherical The spherical to be normalized.\n * @param {Spherical} [result] The object to store the result into, if undefined a new instance will be created.\n * @returns {Spherical} The modified result parameter or a new instance if result was undefined.\n */\nSpherical.normalize = function (spherical, result) {\n  //>>includeStart(\'debug\', pragmas.debug);\n  _Check_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].typeOf.object */ .Z.typeOf.object("spherical", spherical);\n  //>>includeEnd(\'debug\');\n\n  if (!(0,_defined_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"] */ .Z)(result)) {\n    return new Spherical(spherical.clock, spherical.cone, 1.0);\n  }\n\n  result.clock = spherical.clock;\n  result.cone = spherical.cone;\n  result.magnitude = 1.0;\n  return result;\n};\n\n/**\n * Returns true if the first spherical is equal to the second spherical, false otherwise.\n *\n * @param {Spherical} left The first Spherical to be compared.\n * @param {Spherical} right The second Spherical to be compared.\n * @returns {Boolean} true if the first spherical is equal to the second spherical, false otherwise.\n */\nSpherical.equals = function (left, right) {\n  return (\n    left === right ||\n    ((0,_defined_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"] */ .Z)(left) &&\n      (0,_defined_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"] */ .Z)(right) &&\n      left.clock === right.clock &&\n      left.cone === right.cone &&\n      left.magnitude === right.magnitude)\n  );\n};\n\n/**\n * Returns true if the first spherical is within the provided epsilon of the second spherical, false otherwise.\n *\n * @param {Spherical} left The first Spherical to be compared.\n * @param {Spherical} right The second Spherical to be compared.\n * @param {Number} [epsilon=0.0] The epsilon to compare against.\n * @returns {Boolean} true if the first spherical is within the provided epsilon of the second spherical, false otherwise.\n */\nSpherical.equalsEpsilon = function (left, right, epsilon) {\n  epsilon = (0,_defaultValue_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .Z)(epsilon, 0.0);\n  return (\n    left === right ||\n    ((0,_defined_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"] */ .Z)(left) &&\n      (0,_defined_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"] */ .Z)(right) &&\n      Math.abs(left.clock - right.clock) <= epsilon &&\n      Math.abs(left.cone - right.cone) <= epsilon &&\n      Math.abs(left.magnitude - right.magnitude) <= epsilon)\n  );\n};\n\n/**\n * Returns true if this spherical is equal to the provided spherical, false otherwise.\n *\n * @param {Spherical} other The Spherical to be compared.\n * @returns {Boolean} true if this spherical is equal to the provided spherical, false otherwise.\n */\nSpherical.prototype.equals = function (other) {\n  return Spherical.equals(this, other);\n};\n\n/**\n * Creates a duplicate of this Spherical.\n *\n * @param {Spherical} [result] The object to store the result into, if undefined a new instance will be created.\n * @returns {Spherical} The modified result parameter or a new instance if result was undefined.\n */\nSpherical.prototype.clone = function (result) {\n  return Spherical.clone(this, result);\n};\n\n/**\n * Returns true if this spherical is within the provided epsilon of the provided spherical, false otherwise.\n *\n * @param {Spherical} other The Spherical to be compared.\n * @param {Number} epsilon The epsilon to compare against.\n * @returns {Boolean} true if this spherical is within the provided epsilon of the provided spherical, false otherwise.\n */\nSpherical.prototype.equalsEpsilon = function (other, epsilon) {\n  return Spherical.equalsEpsilon(this, other, epsilon);\n};\n\n/**\n * Returns a string representing this instance in the format (clock, cone, magnitude).\n *\n * @returns {String} A string representing this instance.\n */\nSpherical.prototype.toString = function () {\n  return "(" + this.clock + ", " + this.cone + ", " + this.magnitude + ")";\n};\n/* harmony default export */ __webpack_exports__["Z"] = (Spherical);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNjc4MDcuanMiLCJtYXBwaW5ncyI6Ijs7O0FBQStCO0FBQ2M7QUFDVjs7QUFFbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBLGVBQWUscUVBQVk7QUFDM0I7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0EsY0FBYyxxRUFBWTtBQUMxQjtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQSxtQkFBbUIscUVBQVk7QUFDL0I7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxZQUFZO0FBQ3ZCLFdBQVcsV0FBVztBQUN0QixhQUFhLFdBQVc7QUFDeEI7QUFDQTtBQUNBO0FBQ0EsRUFBRSxzRkFBbUI7QUFDckI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsT0FBTyxnRUFBTztBQUNkO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFdBQVc7QUFDdEIsV0FBVyxXQUFXO0FBQ3RCLGFBQWEsV0FBVztBQUN4QjtBQUNBO0FBQ0EsT0FBTyxnRUFBTztBQUNkO0FBQ0E7O0FBRUEsT0FBTyxnRUFBTztBQUNkO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFdBQVc7QUFDdEIsV0FBVyxXQUFXO0FBQ3RCLGFBQWEsV0FBVztBQUN4QjtBQUNBO0FBQ0E7QUFDQSxFQUFFLHNGQUFtQjtBQUNyQjs7QUFFQSxPQUFPLGdFQUFPO0FBQ2Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsV0FBVztBQUN0QixXQUFXLFdBQVc7QUFDdEIsYUFBYSxTQUFTO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSyxnRUFBTztBQUNaLE1BQU0sZ0VBQU87QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsV0FBVztBQUN0QixXQUFXLFdBQVc7QUFDdEIsV0FBVyxRQUFRO0FBQ25CLGFBQWEsU0FBUztBQUN0QjtBQUNBO0FBQ0EsWUFBWSxxRUFBWTtBQUN4QjtBQUNBO0FBQ0EsS0FBSyxnRUFBTztBQUNaLE1BQU0sZ0VBQU87QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsV0FBVztBQUN0QixhQUFhLFNBQVM7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxXQUFXO0FBQ3RCLGFBQWEsV0FBVztBQUN4QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFdBQVc7QUFDdEIsV0FBVyxRQUFRO0FBQ25CLGFBQWEsU0FBUztBQUN0QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5REFBZSxTQUFTLEVBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly92dWUzLXdlYnBhY2s1Ly4vbm9kZV9tb2R1bGVzL2Nlc2l1bS9Tb3VyY2UvQ29yZS9TcGhlcmljYWwuanM/ZThjMyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgQ2hlY2sgZnJvbSBcIi4vQ2hlY2suanNcIjtcbmltcG9ydCBkZWZhdWx0VmFsdWUgZnJvbSBcIi4vZGVmYXVsdFZhbHVlLmpzXCI7XG5pbXBvcnQgZGVmaW5lZCBmcm9tIFwiLi9kZWZpbmVkLmpzXCI7XG5cbi8qKlxuICogQSBzZXQgb2YgY3VydmlsaW5lYXIgMy1kaW1lbnNpb25hbCBjb29yZGluYXRlcy5cbiAqXG4gKiBAYWxpYXMgU3BoZXJpY2FsXG4gKiBAY29uc3RydWN0b3JcbiAqXG4gKiBAcGFyYW0ge051bWJlcn0gW2Nsb2NrPTAuMF0gVGhlIGFuZ3VsYXIgY29vcmRpbmF0ZSBseWluZyBpbiB0aGUgeHktcGxhbmUgbWVhc3VyZWQgZnJvbSB0aGUgcG9zaXRpdmUgeC1heGlzIGFuZCB0b3dhcmQgdGhlIHBvc2l0aXZlIHktYXhpcy5cbiAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZT0wLjBdIFRoZSBhbmd1bGFyIGNvb3JkaW5hdGUgbWVhc3VyZWQgZnJvbSB0aGUgcG9zaXRpdmUgei1heGlzIGFuZCB0b3dhcmQgdGhlIG5lZ2F0aXZlIHotYXhpcy5cbiAqIEBwYXJhbSB7TnVtYmVyfSBbbWFnbml0dWRlPTEuMF0gVGhlIGxpbmVhciBjb29yZGluYXRlIG1lYXN1cmVkIGZyb20gdGhlIG9yaWdpbi5cbiAqL1xuZnVuY3Rpb24gU3BoZXJpY2FsKGNsb2NrLCBjb25lLCBtYWduaXR1ZGUpIHtcbiAgLyoqXG4gICAqIFRoZSBjbG9jayBjb21wb25lbnQuXG4gICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAqIEBkZWZhdWx0IDAuMFxuICAgKi9cbiAgdGhpcy5jbG9jayA9IGRlZmF1bHRWYWx1ZShjbG9jaywgMC4wKTtcbiAgLyoqXG4gICAqIFRoZSBjb25lIGNvbXBvbmVudC5cbiAgICogQHR5cGUge051bWJlcn1cbiAgICogQGRlZmF1bHQgMC4wXG4gICAqL1xuICB0aGlzLmNvbmUgPSBkZWZhdWx0VmFsdWUoY29uZSwgMC4wKTtcbiAgLyoqXG4gICAqIFRoZSBtYWduaXR1ZGUgY29tcG9uZW50LlxuICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgKiBAZGVmYXVsdCAxLjBcbiAgICovXG4gIHRoaXMubWFnbml0dWRlID0gZGVmYXVsdFZhbHVlKG1hZ25pdHVkZSwgMS4wKTtcbn1cblxuLyoqXG4gKiBDb252ZXJ0cyB0aGUgcHJvdmlkZWQgQ2FydGVzaWFuMyBpbnRvIFNwaGVyaWNhbCBjb29yZGluYXRlcy5cbiAqXG4gKiBAcGFyYW0ge0NhcnRlc2lhbjN9IGNhcnRlc2lhbjMgVGhlIENhcnRlc2lhbjMgdG8gYmUgY29udmVydGVkIHRvIFNwaGVyaWNhbC5cbiAqIEBwYXJhbSB7U3BoZXJpY2FsfSBbcmVzdWx0XSBUaGUgb2JqZWN0IGluIHdoaWNoIHRoZSByZXN1bHQgd2lsbCBiZSBzdG9yZWQsIGlmIHVuZGVmaW5lZCBhIG5ldyBpbnN0YW5jZSB3aWxsIGJlIGNyZWF0ZWQuXG4gKiBAcmV0dXJucyB7U3BoZXJpY2FsfSBUaGUgbW9kaWZpZWQgcmVzdWx0IHBhcmFtZXRlciwgb3IgYSBuZXcgaW5zdGFuY2UgaWYgb25lIHdhcyBub3QgcHJvdmlkZWQuXG4gKi9cblNwaGVyaWNhbC5mcm9tQ2FydGVzaWFuMyA9IGZ1bmN0aW9uIChjYXJ0ZXNpYW4zLCByZXN1bHQpIHtcbiAgLy8+PmluY2x1ZGVTdGFydCgnZGVidWcnLCBwcmFnbWFzLmRlYnVnKTtcbiAgQ2hlY2sudHlwZU9mLm9iamVjdChcImNhcnRlc2lhbjNcIiwgY2FydGVzaWFuMyk7XG4gIC8vPj5pbmNsdWRlRW5kKCdkZWJ1ZycpO1xuXG4gIHZhciB4ID0gY2FydGVzaWFuMy54O1xuICB2YXIgeSA9IGNhcnRlc2lhbjMueTtcbiAgdmFyIHogPSBjYXJ0ZXNpYW4zLno7XG4gIHZhciByYWRpYWxTcXVhcmVkID0geCAqIHggKyB5ICogeTtcblxuICBpZiAoIWRlZmluZWQocmVzdWx0KSkge1xuICAgIHJlc3VsdCA9IG5ldyBTcGhlcmljYWwoKTtcbiAgfVxuXG4gIHJlc3VsdC5jbG9jayA9IE1hdGguYXRhbjIoeSwgeCk7XG4gIHJlc3VsdC5jb25lID0gTWF0aC5hdGFuMihNYXRoLnNxcnQocmFkaWFsU3F1YXJlZCksIHopO1xuICByZXN1bHQubWFnbml0dWRlID0gTWF0aC5zcXJ0KHJhZGlhbFNxdWFyZWQgKyB6ICogeik7XG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG4vKipcbiAqIENyZWF0ZXMgYSBkdXBsaWNhdGUgb2YgYSBTcGhlcmljYWwuXG4gKlxuICogQHBhcmFtIHtTcGhlcmljYWx9IHNwaGVyaWNhbCBUaGUgc3BoZXJpY2FsIHRvIGNsb25lLlxuICogQHBhcmFtIHtTcGhlcmljYWx9IFtyZXN1bHRdIFRoZSBvYmplY3QgdG8gc3RvcmUgdGhlIHJlc3VsdCBpbnRvLCBpZiB1bmRlZmluZWQgYSBuZXcgaW5zdGFuY2Ugd2lsbCBiZSBjcmVhdGVkLlxuICogQHJldHVybnMge1NwaGVyaWNhbH0gVGhlIG1vZGlmaWVkIHJlc3VsdCBwYXJhbWV0ZXIgb3IgYSBuZXcgaW5zdGFuY2UgaWYgcmVzdWx0IHdhcyB1bmRlZmluZWQuIChSZXR1cm5zIHVuZGVmaW5lZCBpZiBzcGhlcmljYWwgaXMgdW5kZWZpbmVkKVxuICovXG5TcGhlcmljYWwuY2xvbmUgPSBmdW5jdGlvbiAoc3BoZXJpY2FsLCByZXN1bHQpIHtcbiAgaWYgKCFkZWZpbmVkKHNwaGVyaWNhbCkpIHtcbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG5cbiAgaWYgKCFkZWZpbmVkKHJlc3VsdCkpIHtcbiAgICByZXR1cm4gbmV3IFNwaGVyaWNhbChzcGhlcmljYWwuY2xvY2ssIHNwaGVyaWNhbC5jb25lLCBzcGhlcmljYWwubWFnbml0dWRlKTtcbiAgfVxuXG4gIHJlc3VsdC5jbG9jayA9IHNwaGVyaWNhbC5jbG9jaztcbiAgcmVzdWx0LmNvbmUgPSBzcGhlcmljYWwuY29uZTtcbiAgcmVzdWx0Lm1hZ25pdHVkZSA9IHNwaGVyaWNhbC5tYWduaXR1ZGU7XG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG4vKipcbiAqIENvbXB1dGVzIHRoZSBub3JtYWxpemVkIHZlcnNpb24gb2YgdGhlIHByb3ZpZGVkIHNwaGVyaWNhbC5cbiAqXG4gKiBAcGFyYW0ge1NwaGVyaWNhbH0gc3BoZXJpY2FsIFRoZSBzcGhlcmljYWwgdG8gYmUgbm9ybWFsaXplZC5cbiAqIEBwYXJhbSB7U3BoZXJpY2FsfSBbcmVzdWx0XSBUaGUgb2JqZWN0IHRvIHN0b3JlIHRoZSByZXN1bHQgaW50bywgaWYgdW5kZWZpbmVkIGEgbmV3IGluc3RhbmNlIHdpbGwgYmUgY3JlYXRlZC5cbiAqIEByZXR1cm5zIHtTcGhlcmljYWx9IFRoZSBtb2RpZmllZCByZXN1bHQgcGFyYW1ldGVyIG9yIGEgbmV3IGluc3RhbmNlIGlmIHJlc3VsdCB3YXMgdW5kZWZpbmVkLlxuICovXG5TcGhlcmljYWwubm9ybWFsaXplID0gZnVuY3Rpb24gKHNwaGVyaWNhbCwgcmVzdWx0KSB7XG4gIC8vPj5pbmNsdWRlU3RhcnQoJ2RlYnVnJywgcHJhZ21hcy5kZWJ1Zyk7XG4gIENoZWNrLnR5cGVPZi5vYmplY3QoXCJzcGhlcmljYWxcIiwgc3BoZXJpY2FsKTtcbiAgLy8+PmluY2x1ZGVFbmQoJ2RlYnVnJyk7XG5cbiAgaWYgKCFkZWZpbmVkKHJlc3VsdCkpIHtcbiAgICByZXR1cm4gbmV3IFNwaGVyaWNhbChzcGhlcmljYWwuY2xvY2ssIHNwaGVyaWNhbC5jb25lLCAxLjApO1xuICB9XG5cbiAgcmVzdWx0LmNsb2NrID0gc3BoZXJpY2FsLmNsb2NrO1xuICByZXN1bHQuY29uZSA9IHNwaGVyaWNhbC5jb25lO1xuICByZXN1bHQubWFnbml0dWRlID0gMS4wO1xuICByZXR1cm4gcmVzdWx0O1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgdGhlIGZpcnN0IHNwaGVyaWNhbCBpcyBlcXVhbCB0byB0aGUgc2Vjb25kIHNwaGVyaWNhbCwgZmFsc2Ugb3RoZXJ3aXNlLlxuICpcbiAqIEBwYXJhbSB7U3BoZXJpY2FsfSBsZWZ0IFRoZSBmaXJzdCBTcGhlcmljYWwgdG8gYmUgY29tcGFyZWQuXG4gKiBAcGFyYW0ge1NwaGVyaWNhbH0gcmlnaHQgVGhlIHNlY29uZCBTcGhlcmljYWwgdG8gYmUgY29tcGFyZWQuXG4gKiBAcmV0dXJucyB7Qm9vbGVhbn0gdHJ1ZSBpZiB0aGUgZmlyc3Qgc3BoZXJpY2FsIGlzIGVxdWFsIHRvIHRoZSBzZWNvbmQgc3BoZXJpY2FsLCBmYWxzZSBvdGhlcndpc2UuXG4gKi9cblNwaGVyaWNhbC5lcXVhbHMgPSBmdW5jdGlvbiAobGVmdCwgcmlnaHQpIHtcbiAgcmV0dXJuIChcbiAgICBsZWZ0ID09PSByaWdodCB8fFxuICAgIChkZWZpbmVkKGxlZnQpICYmXG4gICAgICBkZWZpbmVkKHJpZ2h0KSAmJlxuICAgICAgbGVmdC5jbG9jayA9PT0gcmlnaHQuY2xvY2sgJiZcbiAgICAgIGxlZnQuY29uZSA9PT0gcmlnaHQuY29uZSAmJlxuICAgICAgbGVmdC5tYWduaXR1ZGUgPT09IHJpZ2h0Lm1hZ25pdHVkZSlcbiAgKTtcbn07XG5cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIHRoZSBmaXJzdCBzcGhlcmljYWwgaXMgd2l0aGluIHRoZSBwcm92aWRlZCBlcHNpbG9uIG9mIHRoZSBzZWNvbmQgc3BoZXJpY2FsLCBmYWxzZSBvdGhlcndpc2UuXG4gKlxuICogQHBhcmFtIHtTcGhlcmljYWx9IGxlZnQgVGhlIGZpcnN0IFNwaGVyaWNhbCB0byBiZSBjb21wYXJlZC5cbiAqIEBwYXJhbSB7U3BoZXJpY2FsfSByaWdodCBUaGUgc2Vjb25kIFNwaGVyaWNhbCB0byBiZSBjb21wYXJlZC5cbiAqIEBwYXJhbSB7TnVtYmVyfSBbZXBzaWxvbj0wLjBdIFRoZSBlcHNpbG9uIHRvIGNvbXBhcmUgYWdhaW5zdC5cbiAqIEByZXR1cm5zIHtCb29sZWFufSB0cnVlIGlmIHRoZSBmaXJzdCBzcGhlcmljYWwgaXMgd2l0aGluIHRoZSBwcm92aWRlZCBlcHNpbG9uIG9mIHRoZSBzZWNvbmQgc3BoZXJpY2FsLCBmYWxzZSBvdGhlcndpc2UuXG4gKi9cblNwaGVyaWNhbC5lcXVhbHNFcHNpbG9uID0gZnVuY3Rpb24gKGxlZnQsIHJpZ2h0LCBlcHNpbG9uKSB7XG4gIGVwc2lsb24gPSBkZWZhdWx0VmFsdWUoZXBzaWxvbiwgMC4wKTtcbiAgcmV0dXJuIChcbiAgICBsZWZ0ID09PSByaWdodCB8fFxuICAgIChkZWZpbmVkKGxlZnQpICYmXG4gICAgICBkZWZpbmVkKHJpZ2h0KSAmJlxuICAgICAgTWF0aC5hYnMobGVmdC5jbG9jayAtIHJpZ2h0LmNsb2NrKSA8PSBlcHNpbG9uICYmXG4gICAgICBNYXRoLmFicyhsZWZ0LmNvbmUgLSByaWdodC5jb25lKSA8PSBlcHNpbG9uICYmXG4gICAgICBNYXRoLmFicyhsZWZ0Lm1hZ25pdHVkZSAtIHJpZ2h0Lm1hZ25pdHVkZSkgPD0gZXBzaWxvbilcbiAgKTtcbn07XG5cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIHRoaXMgc3BoZXJpY2FsIGlzIGVxdWFsIHRvIHRoZSBwcm92aWRlZCBzcGhlcmljYWwsIGZhbHNlIG90aGVyd2lzZS5cbiAqXG4gKiBAcGFyYW0ge1NwaGVyaWNhbH0gb3RoZXIgVGhlIFNwaGVyaWNhbCB0byBiZSBjb21wYXJlZC5cbiAqIEByZXR1cm5zIHtCb29sZWFufSB0cnVlIGlmIHRoaXMgc3BoZXJpY2FsIGlzIGVxdWFsIHRvIHRoZSBwcm92aWRlZCBzcGhlcmljYWwsIGZhbHNlIG90aGVyd2lzZS5cbiAqL1xuU3BoZXJpY2FsLnByb3RvdHlwZS5lcXVhbHMgPSBmdW5jdGlvbiAob3RoZXIpIHtcbiAgcmV0dXJuIFNwaGVyaWNhbC5lcXVhbHModGhpcywgb3RoZXIpO1xufTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgZHVwbGljYXRlIG9mIHRoaXMgU3BoZXJpY2FsLlxuICpcbiAqIEBwYXJhbSB7U3BoZXJpY2FsfSBbcmVzdWx0XSBUaGUgb2JqZWN0IHRvIHN0b3JlIHRoZSByZXN1bHQgaW50bywgaWYgdW5kZWZpbmVkIGEgbmV3IGluc3RhbmNlIHdpbGwgYmUgY3JlYXRlZC5cbiAqIEByZXR1cm5zIHtTcGhlcmljYWx9IFRoZSBtb2RpZmllZCByZXN1bHQgcGFyYW1ldGVyIG9yIGEgbmV3IGluc3RhbmNlIGlmIHJlc3VsdCB3YXMgdW5kZWZpbmVkLlxuICovXG5TcGhlcmljYWwucHJvdG90eXBlLmNsb25lID0gZnVuY3Rpb24gKHJlc3VsdCkge1xuICByZXR1cm4gU3BoZXJpY2FsLmNsb25lKHRoaXMsIHJlc3VsdCk7XG59O1xuXG4vKipcbiAqIFJldHVybnMgdHJ1ZSBpZiB0aGlzIHNwaGVyaWNhbCBpcyB3aXRoaW4gdGhlIHByb3ZpZGVkIGVwc2lsb24gb2YgdGhlIHByb3ZpZGVkIHNwaGVyaWNhbCwgZmFsc2Ugb3RoZXJ3aXNlLlxuICpcbiAqIEBwYXJhbSB7U3BoZXJpY2FsfSBvdGhlciBUaGUgU3BoZXJpY2FsIHRvIGJlIGNvbXBhcmVkLlxuICogQHBhcmFtIHtOdW1iZXJ9IGVwc2lsb24gVGhlIGVwc2lsb24gdG8gY29tcGFyZSBhZ2FpbnN0LlxuICogQHJldHVybnMge0Jvb2xlYW59IHRydWUgaWYgdGhpcyBzcGhlcmljYWwgaXMgd2l0aGluIHRoZSBwcm92aWRlZCBlcHNpbG9uIG9mIHRoZSBwcm92aWRlZCBzcGhlcmljYWwsIGZhbHNlIG90aGVyd2lzZS5cbiAqL1xuU3BoZXJpY2FsLnByb3RvdHlwZS5lcXVhbHNFcHNpbG9uID0gZnVuY3Rpb24gKG90aGVyLCBlcHNpbG9uKSB7XG4gIHJldHVybiBTcGhlcmljYWwuZXF1YWxzRXBzaWxvbih0aGlzLCBvdGhlciwgZXBzaWxvbik7XG59O1xuXG4vKipcbiAqIFJldHVybnMgYSBzdHJpbmcgcmVwcmVzZW50aW5nIHRoaXMgaW5zdGFuY2UgaW4gdGhlIGZvcm1hdCAoY2xvY2ssIGNvbmUsIG1hZ25pdHVkZSkuXG4gKlxuICogQHJldHVybnMge1N0cmluZ30gQSBzdHJpbmcgcmVwcmVzZW50aW5nIHRoaXMgaW5zdGFuY2UuXG4gKi9cblNwaGVyaWNhbC5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiBcIihcIiArIHRoaXMuY2xvY2sgKyBcIiwgXCIgKyB0aGlzLmNvbmUgKyBcIiwgXCIgKyB0aGlzLm1hZ25pdHVkZSArIFwiKVwiO1xufTtcbmV4cG9ydCBkZWZhdWx0IFNwaGVyaWNhbDtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///67807\n')},84543:function(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__){eval('/* harmony import */ var _Check_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(66553);\n/* harmony import */ var _defaultValue_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(62200);\n/* harmony import */ var _defined_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(82982);\n/* harmony import */ var _DeveloperError_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(12572);\n/* harmony import */ var _Math_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(99417);\n\n\n\n\n\n\n/**\n * Creates a curve parameterized and evaluated by time. This type describes an interface\n * and is not intended to be instantiated directly.\n *\n * @alias Spline\n * @constructor\n *\n * @see CatmullRomSpline\n * @see HermiteSpline\n * @see LinearSpline\n * @see QuaternionSpline\n */\nfunction Spline() {\n  /**\n   * An array of times for the control points.\n   * @type {Number[]}\n   * @default undefined\n   */\n  this.times = undefined;\n\n  /**\n   * An array of control points.\n   * @type {Cartesian3[]|Quaternion[]}\n   * @default undefined\n   */\n  this.points = undefined;\n\n  _DeveloperError_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"].throwInstantiationError */ .Z.throwInstantiationError();\n}\n\n/**\n * Evaluates the curve at a given time.\n * @function\n *\n * @param {Number} time The time at which to evaluate the curve.\n * @param {Cartesian3|Quaternion|Number[]} [result] The object onto which to store the result.\n * @returns {Cartesian3|Quaternion|Number[]} The modified result parameter or a new instance of the point on the curve at the given time.\n *\n * @exception {DeveloperError} time must be in the range <code>[t<sub>0</sub>, t<sub>n</sub>]</code>, where <code>t<sub>0</sub></code>\n *                             is the first element in the array <code>times</code> and <code>t<sub>n</sub></code> is the last element\n *                             in the array <code>times</code>.\n */\nSpline.prototype.evaluate = _DeveloperError_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"].throwInstantiationError */ .Z.throwInstantiationError;\n\n/**\n * Finds an index <code>i</code> in <code>times</code> such that the parameter\n * <code>time</code> is in the interval <code>[times[i], times[i + 1]]</code>.\n *\n * @param {Number} time The time.\n * @param {Number} startIndex The index from which to start the search.\n * @returns {Number} The index for the element at the start of the interval.\n *\n * @exception {DeveloperError} time must be in the range <code>[t<sub>0</sub>, t<sub>n</sub>]</code>, where <code>t<sub>0</sub></code>\n *                             is the first element in the array <code>times</code> and <code>t<sub>n</sub></code> is the last element\n *                             in the array <code>times</code>.\n */\nSpline.prototype.findTimeInterval = function (time, startIndex) {\n  var times = this.times;\n  var length = times.length;\n\n  //>>includeStart(\'debug\', pragmas.debug);\n  if (!(0,_defined_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .Z)(time)) {\n    throw new _DeveloperError_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"] */ .Z("time is required.");\n  }\n  if (time < times[0] || time > times[length - 1]) {\n    throw new _DeveloperError_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"] */ .Z("time is out of range.");\n  }\n  //>>includeEnd(\'debug\');\n\n  // Take advantage of temporal coherence by checking current, next and previous intervals\n  // for containment of time.\n  startIndex = (0,_defaultValue_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .Z)(startIndex, 0);\n\n  if (time >= times[startIndex]) {\n    if (startIndex + 1 < length && time < times[startIndex + 1]) {\n      return startIndex;\n    } else if (startIndex + 2 < length && time < times[startIndex + 2]) {\n      return startIndex + 1;\n    }\n  } else if (startIndex - 1 >= 0 && time >= times[startIndex - 1]) {\n    return startIndex - 1;\n  }\n\n  // The above failed so do a linear search. For the use cases so far, the\n  // length of the list is less than 10. In the future, if there is a bottle neck,\n  // it might be here.\n\n  var i;\n  if (time > times[startIndex]) {\n    for (i = startIndex; i < length - 1; ++i) {\n      if (time >= times[i] && time < times[i + 1]) {\n        break;\n      }\n    }\n  } else {\n    for (i = startIndex - 1; i >= 0; --i) {\n      if (time >= times[i] && time < times[i + 1]) {\n        break;\n      }\n    }\n  }\n\n  if (i === length - 1) {\n    i = length - 2;\n  }\n\n  return i;\n};\n\n/**\n * Wraps the given time to the period covered by the spline.\n * @function\n *\n * @param {Number} time The time.\n * @return {Number} The time, wrapped around the animation period.\n */\nSpline.prototype.wrapTime = function (time) {\n  //>>includeStart(\'debug\', pragmas.debug);\n  _Check_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].typeOf.number */ .Z.typeOf.number("time", time);\n  //>>includeEnd(\'debug\');\n\n  var times = this.times;\n  var timeEnd = times[times.length - 1];\n  var timeStart = times[0];\n  var timeStretch = timeEnd - timeStart;\n  var divs;\n  if (time < timeStart) {\n    divs = Math.floor((timeStart - time) / timeStretch) + 1;\n    time += divs * timeStretch;\n  }\n  if (time > timeEnd) {\n    divs = Math.floor((time - timeEnd) / timeStretch) + 1;\n    time -= divs * timeStretch;\n  }\n  return time;\n};\n\n/**\n * Clamps the given time to the period covered by the spline.\n * @function\n *\n * @param {Number} time The time.\n * @return {Number} The time, clamped to the animation period.\n */\nSpline.prototype.clampTime = function (time) {\n  //>>includeStart(\'debug\', pragmas.debug);\n  _Check_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].typeOf.number */ .Z.typeOf.number("time", time);\n  //>>includeEnd(\'debug\');\n\n  var times = this.times;\n  return _Math_js__WEBPACK_IMPORTED_MODULE_3__/* ["default"].clamp */ .Z.clamp(time, times[0], times[times.length - 1]);\n};\n/* harmony default export */ __webpack_exports__["Z"] = (Spline);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiODQ1NDMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBK0I7QUFDYztBQUNWO0FBQ2M7QUFDZDs7QUFFbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTs7QUFFQSxFQUFFLG1IQUFzQztBQUN4Qzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLGdDQUFnQztBQUMzQyxhQUFhLGdDQUFnQztBQUM3QztBQUNBLGVBQWUsZ0JBQWdCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixtSEFBc0M7O0FBRWxFO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixhQUFhLFFBQVE7QUFDckI7QUFDQSxlQUFlLGdCQUFnQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxPQUFPLGdFQUFPO0FBQ2QsY0FBYyxtRUFBYztBQUM1QjtBQUNBO0FBQ0EsY0FBYyxtRUFBYztBQUM1QjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFlLHFFQUFZOztBQUUzQjtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EseUJBQXlCLGdCQUFnQjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSiw2QkFBNkIsUUFBUTtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFlBQVksUUFBUTtBQUNwQjtBQUNBO0FBQ0E7QUFDQSxFQUFFLHNGQUFtQjtBQUNyQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsWUFBWSxRQUFRO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBLEVBQUUsc0ZBQW1CO0FBQ3JCOztBQUVBO0FBQ0EsU0FBUyxxRUFBZ0I7QUFDekI7QUFDQSx5REFBZSxNQUFNLEVBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly92dWUzLXdlYnBhY2s1Ly4vbm9kZV9tb2R1bGVzL2Nlc2l1bS9Tb3VyY2UvQ29yZS9TcGxpbmUuanM/MjMzZiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgQ2hlY2sgZnJvbSBcIi4vQ2hlY2suanNcIjtcbmltcG9ydCBkZWZhdWx0VmFsdWUgZnJvbSBcIi4vZGVmYXVsdFZhbHVlLmpzXCI7XG5pbXBvcnQgZGVmaW5lZCBmcm9tIFwiLi9kZWZpbmVkLmpzXCI7XG5pbXBvcnQgRGV2ZWxvcGVyRXJyb3IgZnJvbSBcIi4vRGV2ZWxvcGVyRXJyb3IuanNcIjtcbmltcG9ydCBDZXNpdW1NYXRoIGZyb20gXCIuL01hdGguanNcIjtcblxuLyoqXG4gKiBDcmVhdGVzIGEgY3VydmUgcGFyYW1ldGVyaXplZCBhbmQgZXZhbHVhdGVkIGJ5IHRpbWUuIFRoaXMgdHlwZSBkZXNjcmliZXMgYW4gaW50ZXJmYWNlXG4gKiBhbmQgaXMgbm90IGludGVuZGVkIHRvIGJlIGluc3RhbnRpYXRlZCBkaXJlY3RseS5cbiAqXG4gKiBAYWxpYXMgU3BsaW5lXG4gKiBAY29uc3RydWN0b3JcbiAqXG4gKiBAc2VlIENhdG11bGxSb21TcGxpbmVcbiAqIEBzZWUgSGVybWl0ZVNwbGluZVxuICogQHNlZSBMaW5lYXJTcGxpbmVcbiAqIEBzZWUgUXVhdGVybmlvblNwbGluZVxuICovXG5mdW5jdGlvbiBTcGxpbmUoKSB7XG4gIC8qKlxuICAgKiBBbiBhcnJheSBvZiB0aW1lcyBmb3IgdGhlIGNvbnRyb2wgcG9pbnRzLlxuICAgKiBAdHlwZSB7TnVtYmVyW119XG4gICAqIEBkZWZhdWx0IHVuZGVmaW5lZFxuICAgKi9cbiAgdGhpcy50aW1lcyA9IHVuZGVmaW5lZDtcblxuICAvKipcbiAgICogQW4gYXJyYXkgb2YgY29udHJvbCBwb2ludHMuXG4gICAqIEB0eXBlIHtDYXJ0ZXNpYW4zW118UXVhdGVybmlvbltdfVxuICAgKiBAZGVmYXVsdCB1bmRlZmluZWRcbiAgICovXG4gIHRoaXMucG9pbnRzID0gdW5kZWZpbmVkO1xuXG4gIERldmVsb3BlckVycm9yLnRocm93SW5zdGFudGlhdGlvbkVycm9yKCk7XG59XG5cbi8qKlxuICogRXZhbHVhdGVzIHRoZSBjdXJ2ZSBhdCBhIGdpdmVuIHRpbWUuXG4gKiBAZnVuY3Rpb25cbiAqXG4gKiBAcGFyYW0ge051bWJlcn0gdGltZSBUaGUgdGltZSBhdCB3aGljaCB0byBldmFsdWF0ZSB0aGUgY3VydmUuXG4gKiBAcGFyYW0ge0NhcnRlc2lhbjN8UXVhdGVybmlvbnxOdW1iZXJbXX0gW3Jlc3VsdF0gVGhlIG9iamVjdCBvbnRvIHdoaWNoIHRvIHN0b3JlIHRoZSByZXN1bHQuXG4gKiBAcmV0dXJucyB7Q2FydGVzaWFuM3xRdWF0ZXJuaW9ufE51bWJlcltdfSBUaGUgbW9kaWZpZWQgcmVzdWx0IHBhcmFtZXRlciBvciBhIG5ldyBpbnN0YW5jZSBvZiB0aGUgcG9pbnQgb24gdGhlIGN1cnZlIGF0IHRoZSBnaXZlbiB0aW1lLlxuICpcbiAqIEBleGNlcHRpb24ge0RldmVsb3BlckVycm9yfSB0aW1lIG11c3QgYmUgaW4gdGhlIHJhbmdlIDxjb2RlPlt0PHN1Yj4wPC9zdWI+LCB0PHN1Yj5uPC9zdWI+XTwvY29kZT4sIHdoZXJlIDxjb2RlPnQ8c3ViPjA8L3N1Yj48L2NvZGU+XG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaXMgdGhlIGZpcnN0IGVsZW1lbnQgaW4gdGhlIGFycmF5IDxjb2RlPnRpbWVzPC9jb2RlPiBhbmQgPGNvZGU+dDxzdWI+bjwvc3ViPjwvY29kZT4gaXMgdGhlIGxhc3QgZWxlbWVudFxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluIHRoZSBhcnJheSA8Y29kZT50aW1lczwvY29kZT4uXG4gKi9cblNwbGluZS5wcm90b3R5cGUuZXZhbHVhdGUgPSBEZXZlbG9wZXJFcnJvci50aHJvd0luc3RhbnRpYXRpb25FcnJvcjtcblxuLyoqXG4gKiBGaW5kcyBhbiBpbmRleCA8Y29kZT5pPC9jb2RlPiBpbiA8Y29kZT50aW1lczwvY29kZT4gc3VjaCB0aGF0IHRoZSBwYXJhbWV0ZXJcbiAqIDxjb2RlPnRpbWU8L2NvZGU+IGlzIGluIHRoZSBpbnRlcnZhbCA8Y29kZT5bdGltZXNbaV0sIHRpbWVzW2kgKyAxXV08L2NvZGU+LlxuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSB0aW1lIFRoZSB0aW1lLlxuICogQHBhcmFtIHtOdW1iZXJ9IHN0YXJ0SW5kZXggVGhlIGluZGV4IGZyb20gd2hpY2ggdG8gc3RhcnQgdGhlIHNlYXJjaC5cbiAqIEByZXR1cm5zIHtOdW1iZXJ9IFRoZSBpbmRleCBmb3IgdGhlIGVsZW1lbnQgYXQgdGhlIHN0YXJ0IG9mIHRoZSBpbnRlcnZhbC5cbiAqXG4gKiBAZXhjZXB0aW9uIHtEZXZlbG9wZXJFcnJvcn0gdGltZSBtdXN0IGJlIGluIHRoZSByYW5nZSA8Y29kZT5bdDxzdWI+MDwvc3ViPiwgdDxzdWI+bjwvc3ViPl08L2NvZGU+LCB3aGVyZSA8Y29kZT50PHN1Yj4wPC9zdWI+PC9jb2RlPlxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlzIHRoZSBmaXJzdCBlbGVtZW50IGluIHRoZSBhcnJheSA8Y29kZT50aW1lczwvY29kZT4gYW5kIDxjb2RlPnQ8c3ViPm48L3N1Yj48L2NvZGU+IGlzIHRoZSBsYXN0IGVsZW1lbnRcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbiB0aGUgYXJyYXkgPGNvZGU+dGltZXM8L2NvZGU+LlxuICovXG5TcGxpbmUucHJvdG90eXBlLmZpbmRUaW1lSW50ZXJ2YWwgPSBmdW5jdGlvbiAodGltZSwgc3RhcnRJbmRleCkge1xuICB2YXIgdGltZXMgPSB0aGlzLnRpbWVzO1xuICB2YXIgbGVuZ3RoID0gdGltZXMubGVuZ3RoO1xuXG4gIC8vPj5pbmNsdWRlU3RhcnQoJ2RlYnVnJywgcHJhZ21hcy5kZWJ1Zyk7XG4gIGlmICghZGVmaW5lZCh0aW1lKSkge1xuICAgIHRocm93IG5ldyBEZXZlbG9wZXJFcnJvcihcInRpbWUgaXMgcmVxdWlyZWQuXCIpO1xuICB9XG4gIGlmICh0aW1lIDwgdGltZXNbMF0gfHwgdGltZSA+IHRpbWVzW2xlbmd0aCAtIDFdKSB7XG4gICAgdGhyb3cgbmV3IERldmVsb3BlckVycm9yKFwidGltZSBpcyBvdXQgb2YgcmFuZ2UuXCIpO1xuICB9XG4gIC8vPj5pbmNsdWRlRW5kKCdkZWJ1ZycpO1xuXG4gIC8vIFRha2UgYWR2YW50YWdlIG9mIHRlbXBvcmFsIGNvaGVyZW5jZSBieSBjaGVja2luZyBjdXJyZW50LCBuZXh0IGFuZCBwcmV2aW91cyBpbnRlcnZhbHNcbiAgLy8gZm9yIGNvbnRhaW5tZW50IG9mIHRpbWUuXG4gIHN0YXJ0SW5kZXggPSBkZWZhdWx0VmFsdWUoc3RhcnRJbmRleCwgMCk7XG5cbiAgaWYgKHRpbWUgPj0gdGltZXNbc3RhcnRJbmRleF0pIHtcbiAgICBpZiAoc3RhcnRJbmRleCArIDEgPCBsZW5ndGggJiYgdGltZSA8IHRpbWVzW3N0YXJ0SW5kZXggKyAxXSkge1xuICAgICAgcmV0dXJuIHN0YXJ0SW5kZXg7XG4gICAgfSBlbHNlIGlmIChzdGFydEluZGV4ICsgMiA8IGxlbmd0aCAmJiB0aW1lIDwgdGltZXNbc3RhcnRJbmRleCArIDJdKSB7XG4gICAgICByZXR1cm4gc3RhcnRJbmRleCArIDE7XG4gICAgfVxuICB9IGVsc2UgaWYgKHN0YXJ0SW5kZXggLSAxID49IDAgJiYgdGltZSA+PSB0aW1lc1tzdGFydEluZGV4IC0gMV0pIHtcbiAgICByZXR1cm4gc3RhcnRJbmRleCAtIDE7XG4gIH1cblxuICAvLyBUaGUgYWJvdmUgZmFpbGVkIHNvIGRvIGEgbGluZWFyIHNlYXJjaC4gRm9yIHRoZSB1c2UgY2FzZXMgc28gZmFyLCB0aGVcbiAgLy8gbGVuZ3RoIG9mIHRoZSBsaXN0IGlzIGxlc3MgdGhhbiAxMC4gSW4gdGhlIGZ1dHVyZSwgaWYgdGhlcmUgaXMgYSBib3R0bGUgbmVjayxcbiAgLy8gaXQgbWlnaHQgYmUgaGVyZS5cblxuICB2YXIgaTtcbiAgaWYgKHRpbWUgPiB0aW1lc1tzdGFydEluZGV4XSkge1xuICAgIGZvciAoaSA9IHN0YXJ0SW5kZXg7IGkgPCBsZW5ndGggLSAxOyArK2kpIHtcbiAgICAgIGlmICh0aW1lID49IHRpbWVzW2ldICYmIHRpbWUgPCB0aW1lc1tpICsgMV0pIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGZvciAoaSA9IHN0YXJ0SW5kZXggLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgaWYgKHRpbWUgPj0gdGltZXNbaV0gJiYgdGltZSA8IHRpbWVzW2kgKyAxXSkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBpZiAoaSA9PT0gbGVuZ3RoIC0gMSkge1xuICAgIGkgPSBsZW5ndGggLSAyO1xuICB9XG5cbiAgcmV0dXJuIGk7XG59O1xuXG4vKipcbiAqIFdyYXBzIHRoZSBnaXZlbiB0aW1lIHRvIHRoZSBwZXJpb2QgY292ZXJlZCBieSB0aGUgc3BsaW5lLlxuICogQGZ1bmN0aW9uXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IHRpbWUgVGhlIHRpbWUuXG4gKiBAcmV0dXJuIHtOdW1iZXJ9IFRoZSB0aW1lLCB3cmFwcGVkIGFyb3VuZCB0aGUgYW5pbWF0aW9uIHBlcmlvZC5cbiAqL1xuU3BsaW5lLnByb3RvdHlwZS53cmFwVGltZSA9IGZ1bmN0aW9uICh0aW1lKSB7XG4gIC8vPj5pbmNsdWRlU3RhcnQoJ2RlYnVnJywgcHJhZ21hcy5kZWJ1Zyk7XG4gIENoZWNrLnR5cGVPZi5udW1iZXIoXCJ0aW1lXCIsIHRpbWUpO1xuICAvLz4+aW5jbHVkZUVuZCgnZGVidWcnKTtcblxuICB2YXIgdGltZXMgPSB0aGlzLnRpbWVzO1xuICB2YXIgdGltZUVuZCA9IHRpbWVzW3RpbWVzLmxlbmd0aCAtIDFdO1xuICB2YXIgdGltZVN0YXJ0ID0gdGltZXNbMF07XG4gIHZhciB0aW1lU3RyZXRjaCA9IHRpbWVFbmQgLSB0aW1lU3RhcnQ7XG4gIHZhciBkaXZzO1xuICBpZiAodGltZSA8IHRpbWVTdGFydCkge1xuICAgIGRpdnMgPSBNYXRoLmZsb29yKCh0aW1lU3RhcnQgLSB0aW1lKSAvIHRpbWVTdHJldGNoKSArIDE7XG4gICAgdGltZSArPSBkaXZzICogdGltZVN0cmV0Y2g7XG4gIH1cbiAgaWYgKHRpbWUgPiB0aW1lRW5kKSB7XG4gICAgZGl2cyA9IE1hdGguZmxvb3IoKHRpbWUgLSB0aW1lRW5kKSAvIHRpbWVTdHJldGNoKSArIDE7XG4gICAgdGltZSAtPSBkaXZzICogdGltZVN0cmV0Y2g7XG4gIH1cbiAgcmV0dXJuIHRpbWU7XG59O1xuXG4vKipcbiAqIENsYW1wcyB0aGUgZ2l2ZW4gdGltZSB0byB0aGUgcGVyaW9kIGNvdmVyZWQgYnkgdGhlIHNwbGluZS5cbiAqIEBmdW5jdGlvblxuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSB0aW1lIFRoZSB0aW1lLlxuICogQHJldHVybiB7TnVtYmVyfSBUaGUgdGltZSwgY2xhbXBlZCB0byB0aGUgYW5pbWF0aW9uIHBlcmlvZC5cbiAqL1xuU3BsaW5lLnByb3RvdHlwZS5jbGFtcFRpbWUgPSBmdW5jdGlvbiAodGltZSkge1xuICAvLz4+aW5jbHVkZVN0YXJ0KCdkZWJ1ZycsIHByYWdtYXMuZGVidWcpO1xuICBDaGVjay50eXBlT2YubnVtYmVyKFwidGltZVwiLCB0aW1lKTtcbiAgLy8+PmluY2x1ZGVFbmQoJ2RlYnVnJyk7XG5cbiAgdmFyIHRpbWVzID0gdGhpcy50aW1lcztcbiAgcmV0dXJuIENlc2l1bU1hdGguY2xhbXAodGltZSwgdGltZXNbMF0sIHRpbWVzW3RpbWVzLmxlbmd0aCAtIDFdKTtcbn07XG5leHBvcnQgZGVmYXVsdCBTcGxpbmU7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///84543\n')}}]);