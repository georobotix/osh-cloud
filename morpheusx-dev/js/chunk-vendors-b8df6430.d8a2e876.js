"use strict";(self["webpackChunkvue3_webpack5"]=self["webpackChunkvue3_webpack5"]||[]).push([[2257],{76754:function(__unused_webpack___webpack_module__,__webpack_exports__){eval('//This file is automatically rebuilt by the Cesium build process.\n/* harmony default export */ __webpack_exports__["Z"] = ("varying vec3 v_positionEC;\\n\\\nvarying vec3 v_normalEC;\\n\\\nvarying vec3 v_tangentEC;\\n\\\nvarying vec3 v_bitangentEC;\\n\\\nvarying vec2 v_st;\\n\\\n\\n\\\nvoid main()\\n\\\n{\\n\\\n    vec3 positionToEyeEC = -v_positionEC;\\n\\\n    mat3 tangentToEyeMatrix = czm_tangentToEyeSpaceMatrix(v_normalEC, v_tangentEC, v_bitangentEC);\\n\\\n\\n\\\n    vec3 normalEC = normalize(v_normalEC);\\n\\\n#ifdef FACE_FORWARD\\n\\\n    normalEC = faceforward(normalEC, vec3(0.0, 0.0, 1.0), -normalEC);\\n\\\n#endif\\n\\\n\\n\\\n    czm_materialInput materialInput;\\n\\\n    materialInput.normalEC = normalEC;\\n\\\n    materialInput.tangentToEyeMatrix = tangentToEyeMatrix;\\n\\\n    materialInput.positionToEyeEC = positionToEyeEC;\\n\\\n    materialInput.st = v_st;\\n\\\n    czm_material material = czm_getMaterial(materialInput);\\n\\\n\\n\\\n#ifdef FLAT\\n\\\n    gl_FragColor = vec4(material.diffuse + material.emission, material.alpha);\\n\\\n#else\\n\\\n    gl_FragColor = czm_phong(normalize(positionToEyeEC), material, czm_lightDirectionEC);\\n\\\n#endif\\n\\\n}\\n\\\n");\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNzY3NTQuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQSx5REFBZSwyQkFBMkI7QUFDMUMsd0JBQXdCO0FBQ3hCLHlCQUF5QjtBQUN6QiwyQkFBMkI7QUFDM0Isa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQSxDQUFDO0FBQ0QseUNBQXlDO0FBQ3pDLGtHQUFrRztBQUNsRztBQUNBLDBDQUEwQztBQUMxQztBQUNBLHFFQUFxRTtBQUNyRTtBQUNBO0FBQ0Esb0NBQW9DO0FBQ3BDLHNDQUFzQztBQUN0QywwREFBMEQ7QUFDMUQsb0RBQW9EO0FBQ3BELDRCQUE0QjtBQUM1QiwyREFBMkQ7QUFDM0Q7QUFDQTtBQUNBLDhFQUE4RTtBQUM5RTtBQUNBLHlGQUF5RjtBQUN6RjtBQUNBLENBQUM7QUFDRCxDQUFDLEVBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly92dWUzLXdlYnBhY2s1Ly4vbm9kZV9tb2R1bGVzL2Nlc2l1bS9Tb3VyY2UvU2hhZGVycy9BcHBlYXJhbmNlcy9BbGxNYXRlcmlhbEFwcGVhcmFuY2VGUy5qcz84MzRjIl0sInNvdXJjZXNDb250ZW50IjpbIi8vVGhpcyBmaWxlIGlzIGF1dG9tYXRpY2FsbHkgcmVidWlsdCBieSB0aGUgQ2VzaXVtIGJ1aWxkIHByb2Nlc3MuXG5leHBvcnQgZGVmYXVsdCBcInZhcnlpbmcgdmVjMyB2X3Bvc2l0aW9uRUM7XFxuXFxcbnZhcnlpbmcgdmVjMyB2X25vcm1hbEVDO1xcblxcXG52YXJ5aW5nIHZlYzMgdl90YW5nZW50RUM7XFxuXFxcbnZhcnlpbmcgdmVjMyB2X2JpdGFuZ2VudEVDO1xcblxcXG52YXJ5aW5nIHZlYzIgdl9zdDtcXG5cXFxuXFxuXFxcbnZvaWQgbWFpbigpXFxuXFxcbntcXG5cXFxuICAgIHZlYzMgcG9zaXRpb25Ub0V5ZUVDID0gLXZfcG9zaXRpb25FQztcXG5cXFxuICAgIG1hdDMgdGFuZ2VudFRvRXllTWF0cml4ID0gY3ptX3RhbmdlbnRUb0V5ZVNwYWNlTWF0cml4KHZfbm9ybWFsRUMsIHZfdGFuZ2VudEVDLCB2X2JpdGFuZ2VudEVDKTtcXG5cXFxuXFxuXFxcbiAgICB2ZWMzIG5vcm1hbEVDID0gbm9ybWFsaXplKHZfbm9ybWFsRUMpO1xcblxcXG4jaWZkZWYgRkFDRV9GT1JXQVJEXFxuXFxcbiAgICBub3JtYWxFQyA9IGZhY2Vmb3J3YXJkKG5vcm1hbEVDLCB2ZWMzKDAuMCwgMC4wLCAxLjApLCAtbm9ybWFsRUMpO1xcblxcXG4jZW5kaWZcXG5cXFxuXFxuXFxcbiAgICBjem1fbWF0ZXJpYWxJbnB1dCBtYXRlcmlhbElucHV0O1xcblxcXG4gICAgbWF0ZXJpYWxJbnB1dC5ub3JtYWxFQyA9IG5vcm1hbEVDO1xcblxcXG4gICAgbWF0ZXJpYWxJbnB1dC50YW5nZW50VG9FeWVNYXRyaXggPSB0YW5nZW50VG9FeWVNYXRyaXg7XFxuXFxcbiAgICBtYXRlcmlhbElucHV0LnBvc2l0aW9uVG9FeWVFQyA9IHBvc2l0aW9uVG9FeWVFQztcXG5cXFxuICAgIG1hdGVyaWFsSW5wdXQuc3QgPSB2X3N0O1xcblxcXG4gICAgY3ptX21hdGVyaWFsIG1hdGVyaWFsID0gY3ptX2dldE1hdGVyaWFsKG1hdGVyaWFsSW5wdXQpO1xcblxcXG5cXG5cXFxuI2lmZGVmIEZMQVRcXG5cXFxuICAgIGdsX0ZyYWdDb2xvciA9IHZlYzQobWF0ZXJpYWwuZGlmZnVzZSArIG1hdGVyaWFsLmVtaXNzaW9uLCBtYXRlcmlhbC5hbHBoYSk7XFxuXFxcbiNlbHNlXFxuXFxcbiAgICBnbF9GcmFnQ29sb3IgPSBjem1fcGhvbmcobm9ybWFsaXplKHBvc2l0aW9uVG9FeWVFQyksIG1hdGVyaWFsLCBjem1fbGlnaHREaXJlY3Rpb25FQyk7XFxuXFxcbiNlbmRpZlxcblxcXG59XFxuXFxcblwiO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///76754\n')},66433:function(__unused_webpack___webpack_module__,__webpack_exports__){eval('//This file is automatically rebuilt by the Cesium build process.\n/* harmony default export */ __webpack_exports__["Z"] = ("attribute vec3 position3DHigh;\\n\\\nattribute vec3 position3DLow;\\n\\\nattribute vec3 normal;\\n\\\nattribute vec3 tangent;\\n\\\nattribute vec3 bitangent;\\n\\\nattribute vec2 st;\\n\\\nattribute float batchId;\\n\\\n\\n\\\nvarying vec3 v_positionEC;\\n\\\nvarying vec3 v_normalEC;\\n\\\nvarying vec3 v_tangentEC;\\n\\\nvarying vec3 v_bitangentEC;\\n\\\nvarying vec2 v_st;\\n\\\n\\n\\\nvoid main()\\n\\\n{\\n\\\n    vec4 p = czm_computePosition();\\n\\\n\\n\\\n    v_positionEC = (czm_modelViewRelativeToEye * p).xyz;      // position in eye coordinates\\n\\\n    v_normalEC = czm_normal * normal;                         // normal in eye coordinates\\n\\\n    v_tangentEC = czm_normal * tangent;                       // tangent in eye coordinates\\n\\\n    v_bitangentEC = czm_normal * bitangent;                   // bitangent in eye coordinates\\n\\\n    v_st = st;\\n\\\n\\n\\\n    gl_Position = czm_modelViewProjectionRelativeToEye * p;\\n\\\n}\\n\\\n");\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNjY0MzMuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQSx5REFBZSwrQkFBK0I7QUFDOUMsNkJBQTZCO0FBQzdCLHNCQUFzQjtBQUN0Qix1QkFBdUI7QUFDdkIseUJBQXlCO0FBQ3pCLGtCQUFrQjtBQUNsQix3QkFBd0I7QUFDeEI7QUFDQSwwQkFBMEI7QUFDMUIsd0JBQXdCO0FBQ3hCLHlCQUF5QjtBQUN6QiwyQkFBMkI7QUFDM0Isa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQSxDQUFDO0FBQ0QsbUNBQW1DO0FBQ25DO0FBQ0EsOERBQThEO0FBQzlELDhEQUE4RDtBQUM5RCw4REFBOEQ7QUFDOUQsOERBQThEO0FBQzlELGNBQWM7QUFDZDtBQUNBLDJEQUEyRDtBQUMzRCxDQUFDO0FBQ0QsQ0FBQyxFQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdnVlMy13ZWJwYWNrNS8uL25vZGVfbW9kdWxlcy9jZXNpdW0vU291cmNlL1NoYWRlcnMvQXBwZWFyYW5jZXMvQWxsTWF0ZXJpYWxBcHBlYXJhbmNlVlMuanM/ZTFkZCJdLCJzb3VyY2VzQ29udGVudCI6WyIvL1RoaXMgZmlsZSBpcyBhdXRvbWF0aWNhbGx5IHJlYnVpbHQgYnkgdGhlIENlc2l1bSBidWlsZCBwcm9jZXNzLlxuZXhwb3J0IGRlZmF1bHQgXCJhdHRyaWJ1dGUgdmVjMyBwb3NpdGlvbjNESGlnaDtcXG5cXFxuYXR0cmlidXRlIHZlYzMgcG9zaXRpb24zRExvdztcXG5cXFxuYXR0cmlidXRlIHZlYzMgbm9ybWFsO1xcblxcXG5hdHRyaWJ1dGUgdmVjMyB0YW5nZW50O1xcblxcXG5hdHRyaWJ1dGUgdmVjMyBiaXRhbmdlbnQ7XFxuXFxcbmF0dHJpYnV0ZSB2ZWMyIHN0O1xcblxcXG5hdHRyaWJ1dGUgZmxvYXQgYmF0Y2hJZDtcXG5cXFxuXFxuXFxcbnZhcnlpbmcgdmVjMyB2X3Bvc2l0aW9uRUM7XFxuXFxcbnZhcnlpbmcgdmVjMyB2X25vcm1hbEVDO1xcblxcXG52YXJ5aW5nIHZlYzMgdl90YW5nZW50RUM7XFxuXFxcbnZhcnlpbmcgdmVjMyB2X2JpdGFuZ2VudEVDO1xcblxcXG52YXJ5aW5nIHZlYzIgdl9zdDtcXG5cXFxuXFxuXFxcbnZvaWQgbWFpbigpXFxuXFxcbntcXG5cXFxuICAgIHZlYzQgcCA9IGN6bV9jb21wdXRlUG9zaXRpb24oKTtcXG5cXFxuXFxuXFxcbiAgICB2X3Bvc2l0aW9uRUMgPSAoY3ptX21vZGVsVmlld1JlbGF0aXZlVG9FeWUgKiBwKS54eXo7ICAgICAgLy8gcG9zaXRpb24gaW4gZXllIGNvb3JkaW5hdGVzXFxuXFxcbiAgICB2X25vcm1hbEVDID0gY3ptX25vcm1hbCAqIG5vcm1hbDsgICAgICAgICAgICAgICAgICAgICAgICAgLy8gbm9ybWFsIGluIGV5ZSBjb29yZGluYXRlc1xcblxcXG4gICAgdl90YW5nZW50RUMgPSBjem1fbm9ybWFsICogdGFuZ2VudDsgICAgICAgICAgICAgICAgICAgICAgIC8vIHRhbmdlbnQgaW4gZXllIGNvb3JkaW5hdGVzXFxuXFxcbiAgICB2X2JpdGFuZ2VudEVDID0gY3ptX25vcm1hbCAqIGJpdGFuZ2VudDsgICAgICAgICAgICAgICAgICAgLy8gYml0YW5nZW50IGluIGV5ZSBjb29yZGluYXRlc1xcblxcXG4gICAgdl9zdCA9IHN0O1xcblxcXG5cXG5cXFxuICAgIGdsX1Bvc2l0aW9uID0gY3ptX21vZGVsVmlld1Byb2plY3Rpb25SZWxhdGl2ZVRvRXllICogcDtcXG5cXFxufVxcblxcXG5cIjtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///66433\n')},13366:function(__unused_webpack___webpack_module__,__webpack_exports__){eval('//This file is automatically rebuilt by the Cesium build process.\n/* harmony default export */ __webpack_exports__["Z"] = ("varying vec3 v_positionEC;\\n\\\nvarying vec3 v_normalEC;\\n\\\n\\n\\\nvoid main()\\n\\\n{\\n\\\n    vec3 positionToEyeEC = -v_positionEC;\\n\\\n\\n\\\n    vec3 normalEC = normalize(v_normalEC);\\n\\\n#ifdef FACE_FORWARD\\n\\\n    normalEC = faceforward(normalEC, vec3(0.0, 0.0, 1.0), -normalEC);\\n\\\n#endif\\n\\\n\\n\\\n    czm_materialInput materialInput;\\n\\\n    materialInput.normalEC = normalEC;\\n\\\n    materialInput.positionToEyeEC = positionToEyeEC;\\n\\\n    czm_material material = czm_getMaterial(materialInput);\\n\\\n\\n\\\n#ifdef FLAT\\n\\\n    gl_FragColor = vec4(material.diffuse + material.emission, material.alpha);\\n\\\n#else\\n\\\n    gl_FragColor = czm_phong(normalize(positionToEyeEC), material, czm_lightDirectionEC);\\n\\\n#endif\\n\\\n}\\n\\\n");\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTMzNjYuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQSx5REFBZSwyQkFBMkI7QUFDMUMsd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQSxDQUFDO0FBQ0QseUNBQXlDO0FBQ3pDO0FBQ0EsMENBQTBDO0FBQzFDO0FBQ0EscUVBQXFFO0FBQ3JFO0FBQ0E7QUFDQSxvQ0FBb0M7QUFDcEMsc0NBQXNDO0FBQ3RDLG9EQUFvRDtBQUNwRCwyREFBMkQ7QUFDM0Q7QUFDQTtBQUNBLDhFQUE4RTtBQUM5RTtBQUNBLHlGQUF5RjtBQUN6RjtBQUNBLENBQUM7QUFDRCxDQUFDLEVBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly92dWUzLXdlYnBhY2s1Ly4vbm9kZV9tb2R1bGVzL2Nlc2l1bS9Tb3VyY2UvU2hhZGVycy9BcHBlYXJhbmNlcy9CYXNpY01hdGVyaWFsQXBwZWFyYW5jZUZTLmpzP2MzMTQiXSwic291cmNlc0NvbnRlbnQiOlsiLy9UaGlzIGZpbGUgaXMgYXV0b21hdGljYWxseSByZWJ1aWx0IGJ5IHRoZSBDZXNpdW0gYnVpbGQgcHJvY2Vzcy5cbmV4cG9ydCBkZWZhdWx0IFwidmFyeWluZyB2ZWMzIHZfcG9zaXRpb25FQztcXG5cXFxudmFyeWluZyB2ZWMzIHZfbm9ybWFsRUM7XFxuXFxcblxcblxcXG52b2lkIG1haW4oKVxcblxcXG57XFxuXFxcbiAgICB2ZWMzIHBvc2l0aW9uVG9FeWVFQyA9IC12X3Bvc2l0aW9uRUM7XFxuXFxcblxcblxcXG4gICAgdmVjMyBub3JtYWxFQyA9IG5vcm1hbGl6ZSh2X25vcm1hbEVDKTtcXG5cXFxuI2lmZGVmIEZBQ0VfRk9SV0FSRFxcblxcXG4gICAgbm9ybWFsRUMgPSBmYWNlZm9yd2FyZChub3JtYWxFQywgdmVjMygwLjAsIDAuMCwgMS4wKSwgLW5vcm1hbEVDKTtcXG5cXFxuI2VuZGlmXFxuXFxcblxcblxcXG4gICAgY3ptX21hdGVyaWFsSW5wdXQgbWF0ZXJpYWxJbnB1dDtcXG5cXFxuICAgIG1hdGVyaWFsSW5wdXQubm9ybWFsRUMgPSBub3JtYWxFQztcXG5cXFxuICAgIG1hdGVyaWFsSW5wdXQucG9zaXRpb25Ub0V5ZUVDID0gcG9zaXRpb25Ub0V5ZUVDO1xcblxcXG4gICAgY3ptX21hdGVyaWFsIG1hdGVyaWFsID0gY3ptX2dldE1hdGVyaWFsKG1hdGVyaWFsSW5wdXQpO1xcblxcXG5cXG5cXFxuI2lmZGVmIEZMQVRcXG5cXFxuICAgIGdsX0ZyYWdDb2xvciA9IHZlYzQobWF0ZXJpYWwuZGlmZnVzZSArIG1hdGVyaWFsLmVtaXNzaW9uLCBtYXRlcmlhbC5hbHBoYSk7XFxuXFxcbiNlbHNlXFxuXFxcbiAgICBnbF9GcmFnQ29sb3IgPSBjem1fcGhvbmcobm9ybWFsaXplKHBvc2l0aW9uVG9FeWVFQyksIG1hdGVyaWFsLCBjem1fbGlnaHREaXJlY3Rpb25FQyk7XFxuXFxcbiNlbmRpZlxcblxcXG59XFxuXFxcblwiO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///13366\n')},26479:function(__unused_webpack___webpack_module__,__webpack_exports__){eval('//This file is automatically rebuilt by the Cesium build process.\n/* harmony default export */ __webpack_exports__["Z"] = ("attribute vec3 position3DHigh;\\n\\\nattribute vec3 position3DLow;\\n\\\nattribute vec3 normal;\\n\\\nattribute float batchId;\\n\\\n\\n\\\nvarying vec3 v_positionEC;\\n\\\nvarying vec3 v_normalEC;\\n\\\n\\n\\\nvoid main()\\n\\\n{\\n\\\n    vec4 p = czm_computePosition();\\n\\\n\\n\\\n    v_positionEC = (czm_modelViewRelativeToEye * p).xyz;      // position in eye coordinates\\n\\\n    v_normalEC = czm_normal * normal;                         // normal in eye coordinates\\n\\\n\\n\\\n    gl_Position = czm_modelViewProjectionRelativeToEye * p;\\n\\\n}\\n\\\n");\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjY0NzkuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQSx5REFBZSwrQkFBK0I7QUFDOUMsNkJBQTZCO0FBQzdCLHNCQUFzQjtBQUN0Qix3QkFBd0I7QUFDeEI7QUFDQSwwQkFBMEI7QUFDMUIsd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQSxDQUFDO0FBQ0QsbUNBQW1DO0FBQ25DO0FBQ0EsOERBQThEO0FBQzlELDhEQUE4RDtBQUM5RDtBQUNBLDJEQUEyRDtBQUMzRCxDQUFDO0FBQ0QsQ0FBQyxFQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdnVlMy13ZWJwYWNrNS8uL25vZGVfbW9kdWxlcy9jZXNpdW0vU291cmNlL1NoYWRlcnMvQXBwZWFyYW5jZXMvQmFzaWNNYXRlcmlhbEFwcGVhcmFuY2VWUy5qcz8wMzY5Il0sInNvdXJjZXNDb250ZW50IjpbIi8vVGhpcyBmaWxlIGlzIGF1dG9tYXRpY2FsbHkgcmVidWlsdCBieSB0aGUgQ2VzaXVtIGJ1aWxkIHByb2Nlc3MuXG5leHBvcnQgZGVmYXVsdCBcImF0dHJpYnV0ZSB2ZWMzIHBvc2l0aW9uM0RIaWdoO1xcblxcXG5hdHRyaWJ1dGUgdmVjMyBwb3NpdGlvbjNETG93O1xcblxcXG5hdHRyaWJ1dGUgdmVjMyBub3JtYWw7XFxuXFxcbmF0dHJpYnV0ZSBmbG9hdCBiYXRjaElkO1xcblxcXG5cXG5cXFxudmFyeWluZyB2ZWMzIHZfcG9zaXRpb25FQztcXG5cXFxudmFyeWluZyB2ZWMzIHZfbm9ybWFsRUM7XFxuXFxcblxcblxcXG52b2lkIG1haW4oKVxcblxcXG57XFxuXFxcbiAgICB2ZWM0IHAgPSBjem1fY29tcHV0ZVBvc2l0aW9uKCk7XFxuXFxcblxcblxcXG4gICAgdl9wb3NpdGlvbkVDID0gKGN6bV9tb2RlbFZpZXdSZWxhdGl2ZVRvRXllICogcCkueHl6OyAgICAgIC8vIHBvc2l0aW9uIGluIGV5ZSBjb29yZGluYXRlc1xcblxcXG4gICAgdl9ub3JtYWxFQyA9IGN6bV9ub3JtYWwgKiBub3JtYWw7ICAgICAgICAgICAgICAgICAgICAgICAgIC8vIG5vcm1hbCBpbiBleWUgY29vcmRpbmF0ZXNcXG5cXFxuXFxuXFxcbiAgICBnbF9Qb3NpdGlvbiA9IGN6bV9tb2RlbFZpZXdQcm9qZWN0aW9uUmVsYXRpdmVUb0V5ZSAqIHA7XFxuXFxcbn1cXG5cXFxuXCI7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///26479\n')},63773:function(__unused_webpack___webpack_module__,__webpack_exports__){eval('//This file is automatically rebuilt by the Cesium build process.\n/* harmony default export */ __webpack_exports__["Z"] = ("varying vec3 v_positionMC;\\n\\\nvarying vec3 v_positionEC;\\n\\\nvarying vec2 v_st;\\n\\\n\\n\\\nvoid main()\\n\\\n{\\n\\\n    czm_materialInput materialInput;\\n\\\n\\n\\\n    vec3 normalEC = normalize(czm_normal3D * czm_geodeticSurfaceNormal(v_positionMC, vec3(0.0), vec3(1.0)));\\n\\\n#ifdef FACE_FORWARD\\n\\\n    normalEC = faceforward(normalEC, vec3(0.0, 0.0, 1.0), -normalEC);\\n\\\n#endif\\n\\\n\\n\\\n    materialInput.s = v_st.s;\\n\\\n    materialInput.st = v_st;\\n\\\n    materialInput.str = vec3(v_st, 0.0);\\n\\\n\\n\\\n    // Convert tangent space material normal to eye space\\n\\\n    materialInput.normalEC = normalEC;\\n\\\n    materialInput.tangentToEyeMatrix = czm_eastNorthUpToEyeCoordinates(v_positionMC, materialInput.normalEC);\\n\\\n\\n\\\n    // Convert view vector to world space\\n\\\n    vec3 positionToEyeEC = -v_positionEC;\\n\\\n    materialInput.positionToEyeEC = positionToEyeEC;\\n\\\n\\n\\\n    czm_material material = czm_getMaterial(materialInput);\\n\\\n\\n\\\n#ifdef FLAT\\n\\\n    gl_FragColor = vec4(material.diffuse + material.emission, material.alpha);\\n\\\n#else\\n\\\n    gl_FragColor = czm_phong(normalize(positionToEyeEC), material, czm_lightDirectionEC);\\n\\\n#endif\\n\\\n}\\n\\\n");\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNjM3NzMuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQSx5REFBZSwyQkFBMkI7QUFDMUMsMEJBQTBCO0FBQzFCLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0EsQ0FBQztBQUNELG9DQUFvQztBQUNwQztBQUNBLDRHQUE0RztBQUM1RztBQUNBLHFFQUFxRTtBQUNyRTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCLDRCQUE0QjtBQUM1Qix3Q0FBd0M7QUFDeEM7QUFDQTtBQUNBLHNDQUFzQztBQUN0Qyw2R0FBNkc7QUFDN0c7QUFDQTtBQUNBLHlDQUF5QztBQUN6QyxvREFBb0Q7QUFDcEQ7QUFDQSwyREFBMkQ7QUFDM0Q7QUFDQTtBQUNBLDhFQUE4RTtBQUM5RTtBQUNBLHlGQUF5RjtBQUN6RjtBQUNBLENBQUM7QUFDRCxDQUFDLEVBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly92dWUzLXdlYnBhY2s1Ly4vbm9kZV9tb2R1bGVzL2Nlc2l1bS9Tb3VyY2UvU2hhZGVycy9BcHBlYXJhbmNlcy9FbGxpcHNvaWRTdXJmYWNlQXBwZWFyYW5jZUZTLmpzPzgxYTUiXSwic291cmNlc0NvbnRlbnQiOlsiLy9UaGlzIGZpbGUgaXMgYXV0b21hdGljYWxseSByZWJ1aWx0IGJ5IHRoZSBDZXNpdW0gYnVpbGQgcHJvY2Vzcy5cbmV4cG9ydCBkZWZhdWx0IFwidmFyeWluZyB2ZWMzIHZfcG9zaXRpb25NQztcXG5cXFxudmFyeWluZyB2ZWMzIHZfcG9zaXRpb25FQztcXG5cXFxudmFyeWluZyB2ZWMyIHZfc3Q7XFxuXFxcblxcblxcXG52b2lkIG1haW4oKVxcblxcXG57XFxuXFxcbiAgICBjem1fbWF0ZXJpYWxJbnB1dCBtYXRlcmlhbElucHV0O1xcblxcXG5cXG5cXFxuICAgIHZlYzMgbm9ybWFsRUMgPSBub3JtYWxpemUoY3ptX25vcm1hbDNEICogY3ptX2dlb2RldGljU3VyZmFjZU5vcm1hbCh2X3Bvc2l0aW9uTUMsIHZlYzMoMC4wKSwgdmVjMygxLjApKSk7XFxuXFxcbiNpZmRlZiBGQUNFX0ZPUldBUkRcXG5cXFxuICAgIG5vcm1hbEVDID0gZmFjZWZvcndhcmQobm9ybWFsRUMsIHZlYzMoMC4wLCAwLjAsIDEuMCksIC1ub3JtYWxFQyk7XFxuXFxcbiNlbmRpZlxcblxcXG5cXG5cXFxuICAgIG1hdGVyaWFsSW5wdXQucyA9IHZfc3QucztcXG5cXFxuICAgIG1hdGVyaWFsSW5wdXQuc3QgPSB2X3N0O1xcblxcXG4gICAgbWF0ZXJpYWxJbnB1dC5zdHIgPSB2ZWMzKHZfc3QsIDAuMCk7XFxuXFxcblxcblxcXG4gICAgLy8gQ29udmVydCB0YW5nZW50IHNwYWNlIG1hdGVyaWFsIG5vcm1hbCB0byBleWUgc3BhY2VcXG5cXFxuICAgIG1hdGVyaWFsSW5wdXQubm9ybWFsRUMgPSBub3JtYWxFQztcXG5cXFxuICAgIG1hdGVyaWFsSW5wdXQudGFuZ2VudFRvRXllTWF0cml4ID0gY3ptX2Vhc3ROb3J0aFVwVG9FeWVDb29yZGluYXRlcyh2X3Bvc2l0aW9uTUMsIG1hdGVyaWFsSW5wdXQubm9ybWFsRUMpO1xcblxcXG5cXG5cXFxuICAgIC8vIENvbnZlcnQgdmlldyB2ZWN0b3IgdG8gd29ybGQgc3BhY2VcXG5cXFxuICAgIHZlYzMgcG9zaXRpb25Ub0V5ZUVDID0gLXZfcG9zaXRpb25FQztcXG5cXFxuICAgIG1hdGVyaWFsSW5wdXQucG9zaXRpb25Ub0V5ZUVDID0gcG9zaXRpb25Ub0V5ZUVDO1xcblxcXG5cXG5cXFxuICAgIGN6bV9tYXRlcmlhbCBtYXRlcmlhbCA9IGN6bV9nZXRNYXRlcmlhbChtYXRlcmlhbElucHV0KTtcXG5cXFxuXFxuXFxcbiNpZmRlZiBGTEFUXFxuXFxcbiAgICBnbF9GcmFnQ29sb3IgPSB2ZWM0KG1hdGVyaWFsLmRpZmZ1c2UgKyBtYXRlcmlhbC5lbWlzc2lvbiwgbWF0ZXJpYWwuYWxwaGEpO1xcblxcXG4jZWxzZVxcblxcXG4gICAgZ2xfRnJhZ0NvbG9yID0gY3ptX3Bob25nKG5vcm1hbGl6ZShwb3NpdGlvblRvRXllRUMpLCBtYXRlcmlhbCwgY3ptX2xpZ2h0RGlyZWN0aW9uRUMpO1xcblxcXG4jZW5kaWZcXG5cXFxufVxcblxcXG5cIjtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///63773\n')},75350:function(__unused_webpack___webpack_module__,__webpack_exports__){eval('//This file is automatically rebuilt by the Cesium build process.\n/* harmony default export */ __webpack_exports__["Z"] = ("attribute vec3 position3DHigh;\\n\\\nattribute vec3 position3DLow;\\n\\\nattribute vec2 st;\\n\\\nattribute float batchId;\\n\\\n\\n\\\nvarying vec3 v_positionMC;\\n\\\nvarying vec3 v_positionEC;\\n\\\nvarying vec2 v_st;\\n\\\n\\n\\\nvoid main()\\n\\\n{\\n\\\n    vec4 p = czm_computePosition();\\n\\\n\\n\\\n    v_positionMC = position3DHigh + position3DLow;           // position in model coordinates\\n\\\n    v_positionEC = (czm_modelViewRelativeToEye * p).xyz;     // position in eye coordinates\\n\\\n    v_st = st;\\n\\\n\\n\\\n    gl_Position = czm_modelViewProjectionRelativeToEye * p;\\n\\\n}\\n\\\n");\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNzUzNTAuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQSx5REFBZSwrQkFBK0I7QUFDOUMsNkJBQTZCO0FBQzdCLGtCQUFrQjtBQUNsQix3QkFBd0I7QUFDeEI7QUFDQSwwQkFBMEI7QUFDMUIsMEJBQTBCO0FBQzFCLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0EsQ0FBQztBQUNELG1DQUFtQztBQUNuQztBQUNBLDZEQUE2RDtBQUM3RCw2REFBNkQ7QUFDN0QsY0FBYztBQUNkO0FBQ0EsMkRBQTJEO0FBQzNELENBQUM7QUFDRCxDQUFDLEVBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly92dWUzLXdlYnBhY2s1Ly4vbm9kZV9tb2R1bGVzL2Nlc2l1bS9Tb3VyY2UvU2hhZGVycy9BcHBlYXJhbmNlcy9FbGxpcHNvaWRTdXJmYWNlQXBwZWFyYW5jZVZTLmpzP2M0ZDkiXSwic291cmNlc0NvbnRlbnQiOlsiLy9UaGlzIGZpbGUgaXMgYXV0b21hdGljYWxseSByZWJ1aWx0IGJ5IHRoZSBDZXNpdW0gYnVpbGQgcHJvY2Vzcy5cbmV4cG9ydCBkZWZhdWx0IFwiYXR0cmlidXRlIHZlYzMgcG9zaXRpb24zREhpZ2g7XFxuXFxcbmF0dHJpYnV0ZSB2ZWMzIHBvc2l0aW9uM0RMb3c7XFxuXFxcbmF0dHJpYnV0ZSB2ZWMyIHN0O1xcblxcXG5hdHRyaWJ1dGUgZmxvYXQgYmF0Y2hJZDtcXG5cXFxuXFxuXFxcbnZhcnlpbmcgdmVjMyB2X3Bvc2l0aW9uTUM7XFxuXFxcbnZhcnlpbmcgdmVjMyB2X3Bvc2l0aW9uRUM7XFxuXFxcbnZhcnlpbmcgdmVjMiB2X3N0O1xcblxcXG5cXG5cXFxudm9pZCBtYWluKClcXG5cXFxue1xcblxcXG4gICAgdmVjNCBwID0gY3ptX2NvbXB1dGVQb3NpdGlvbigpO1xcblxcXG5cXG5cXFxuICAgIHZfcG9zaXRpb25NQyA9IHBvc2l0aW9uM0RIaWdoICsgcG9zaXRpb24zRExvdzsgICAgICAgICAgIC8vIHBvc2l0aW9uIGluIG1vZGVsIGNvb3JkaW5hdGVzXFxuXFxcbiAgICB2X3Bvc2l0aW9uRUMgPSAoY3ptX21vZGVsVmlld1JlbGF0aXZlVG9FeWUgKiBwKS54eXo7ICAgICAvLyBwb3NpdGlvbiBpbiBleWUgY29vcmRpbmF0ZXNcXG5cXFxuICAgIHZfc3QgPSBzdDtcXG5cXFxuXFxuXFxcbiAgICBnbF9Qb3NpdGlvbiA9IGN6bV9tb2RlbFZpZXdQcm9qZWN0aW9uUmVsYXRpdmVUb0V5ZSAqIHA7XFxuXFxcbn1cXG5cXFxuXCI7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///75350\n')},26712:function(__unused_webpack___webpack_module__,__webpack_exports__){eval('//This file is automatically rebuilt by the Cesium build process.\n/* harmony default export */ __webpack_exports__["Z"] = ("varying vec3 v_positionEC;\\n\\\nvarying vec3 v_normalEC;\\n\\\nvarying vec4 v_color;\\n\\\n\\n\\\nvoid main()\\n\\\n{\\n\\\n    vec3 positionToEyeEC = -v_positionEC;\\n\\\n\\n\\\n    vec3 normalEC = normalize(v_normalEC);\\n\\\n#ifdef FACE_FORWARD\\n\\\n    normalEC = faceforward(normalEC, vec3(0.0, 0.0, 1.0), -normalEC);\\n\\\n#endif\\n\\\n\\n\\\n    vec4 color = czm_gammaCorrect(v_color);\\n\\\n\\n\\\n    czm_materialInput materialInput;\\n\\\n    materialInput.normalEC = normalEC;\\n\\\n    materialInput.positionToEyeEC = positionToEyeEC;\\n\\\n    czm_material material = czm_getDefaultMaterial(materialInput);\\n\\\n    material.diffuse = color.rgb;\\n\\\n    material.alpha = color.a;\\n\\\n\\n\\\n    gl_FragColor = czm_phong(normalize(positionToEyeEC), material, czm_lightDirectionEC);\\n\\\n}\\n\\\n");\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjY3MTIuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQSx5REFBZSwyQkFBMkI7QUFDMUMsd0JBQXdCO0FBQ3hCLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0EsQ0FBQztBQUNELHlDQUF5QztBQUN6QztBQUNBLDBDQUEwQztBQUMxQztBQUNBLHFFQUFxRTtBQUNyRTtBQUNBO0FBQ0EsMkNBQTJDO0FBQzNDO0FBQ0Esb0NBQW9DO0FBQ3BDLHNDQUFzQztBQUN0QyxvREFBb0Q7QUFDcEQsa0VBQWtFO0FBQ2xFLGlDQUFpQztBQUNqQyw2QkFBNkI7QUFDN0I7QUFDQSx5RkFBeUY7QUFDekYsQ0FBQztBQUNELENBQUMsRUFBQyIsInNvdXJjZXMiOlsid2VicGFjazovL3Z1ZTMtd2VicGFjazUvLi9ub2RlX21vZHVsZXMvY2VzaXVtL1NvdXJjZS9TaGFkZXJzL0FwcGVhcmFuY2VzL1Blckluc3RhbmNlQ29sb3JBcHBlYXJhbmNlRlMuanM/YzNlZSJdLCJzb3VyY2VzQ29udGVudCI6WyIvL1RoaXMgZmlsZSBpcyBhdXRvbWF0aWNhbGx5IHJlYnVpbHQgYnkgdGhlIENlc2l1bSBidWlsZCBwcm9jZXNzLlxuZXhwb3J0IGRlZmF1bHQgXCJ2YXJ5aW5nIHZlYzMgdl9wb3NpdGlvbkVDO1xcblxcXG52YXJ5aW5nIHZlYzMgdl9ub3JtYWxFQztcXG5cXFxudmFyeWluZyB2ZWM0IHZfY29sb3I7XFxuXFxcblxcblxcXG52b2lkIG1haW4oKVxcblxcXG57XFxuXFxcbiAgICB2ZWMzIHBvc2l0aW9uVG9FeWVFQyA9IC12X3Bvc2l0aW9uRUM7XFxuXFxcblxcblxcXG4gICAgdmVjMyBub3JtYWxFQyA9IG5vcm1hbGl6ZSh2X25vcm1hbEVDKTtcXG5cXFxuI2lmZGVmIEZBQ0VfRk9SV0FSRFxcblxcXG4gICAgbm9ybWFsRUMgPSBmYWNlZm9yd2FyZChub3JtYWxFQywgdmVjMygwLjAsIDAuMCwgMS4wKSwgLW5vcm1hbEVDKTtcXG5cXFxuI2VuZGlmXFxuXFxcblxcblxcXG4gICAgdmVjNCBjb2xvciA9IGN6bV9nYW1tYUNvcnJlY3Qodl9jb2xvcik7XFxuXFxcblxcblxcXG4gICAgY3ptX21hdGVyaWFsSW5wdXQgbWF0ZXJpYWxJbnB1dDtcXG5cXFxuICAgIG1hdGVyaWFsSW5wdXQubm9ybWFsRUMgPSBub3JtYWxFQztcXG5cXFxuICAgIG1hdGVyaWFsSW5wdXQucG9zaXRpb25Ub0V5ZUVDID0gcG9zaXRpb25Ub0V5ZUVDO1xcblxcXG4gICAgY3ptX21hdGVyaWFsIG1hdGVyaWFsID0gY3ptX2dldERlZmF1bHRNYXRlcmlhbChtYXRlcmlhbElucHV0KTtcXG5cXFxuICAgIG1hdGVyaWFsLmRpZmZ1c2UgPSBjb2xvci5yZ2I7XFxuXFxcbiAgICBtYXRlcmlhbC5hbHBoYSA9IGNvbG9yLmE7XFxuXFxcblxcblxcXG4gICAgZ2xfRnJhZ0NvbG9yID0gY3ptX3Bob25nKG5vcm1hbGl6ZShwb3NpdGlvblRvRXllRUMpLCBtYXRlcmlhbCwgY3ptX2xpZ2h0RGlyZWN0aW9uRUMpO1xcblxcXG59XFxuXFxcblwiO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///26712\n')},82926:function(__unused_webpack___webpack_module__,__webpack_exports__){eval('//This file is automatically rebuilt by the Cesium build process.\n/* harmony default export */ __webpack_exports__["Z"] = ("attribute vec3 position3DHigh;\\n\\\nattribute vec3 position3DLow;\\n\\\nattribute vec3 normal;\\n\\\nattribute vec4 color;\\n\\\nattribute float batchId;\\n\\\n\\n\\\nvarying vec3 v_positionEC;\\n\\\nvarying vec3 v_normalEC;\\n\\\nvarying vec4 v_color;\\n\\\n\\n\\\nvoid main()\\n\\\n{\\n\\\n    vec4 p = czm_computePosition();\\n\\\n\\n\\\n    v_positionEC = (czm_modelViewRelativeToEye * p).xyz;      // position in eye coordinates\\n\\\n    v_normalEC = czm_normal * normal;                         // normal in eye coordinates\\n\\\n    v_color = color;\\n\\\n\\n\\\n    gl_Position = czm_modelViewProjectionRelativeToEye * p;\\n\\\n}\\n\\\n");\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiODI5MjYuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQSx5REFBZSwrQkFBK0I7QUFDOUMsNkJBQTZCO0FBQzdCLHNCQUFzQjtBQUN0QixxQkFBcUI7QUFDckIsd0JBQXdCO0FBQ3hCO0FBQ0EsMEJBQTBCO0FBQzFCLHdCQUF3QjtBQUN4QixxQkFBcUI7QUFDckI7QUFDQTtBQUNBLENBQUM7QUFDRCxtQ0FBbUM7QUFDbkM7QUFDQSw4REFBOEQ7QUFDOUQsOERBQThEO0FBQzlELG9CQUFvQjtBQUNwQjtBQUNBLDJEQUEyRDtBQUMzRCxDQUFDO0FBQ0QsQ0FBQyxFQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdnVlMy13ZWJwYWNrNS8uL25vZGVfbW9kdWxlcy9jZXNpdW0vU291cmNlL1NoYWRlcnMvQXBwZWFyYW5jZXMvUGVySW5zdGFuY2VDb2xvckFwcGVhcmFuY2VWUy5qcz84ZWRmIl0sInNvdXJjZXNDb250ZW50IjpbIi8vVGhpcyBmaWxlIGlzIGF1dG9tYXRpY2FsbHkgcmVidWlsdCBieSB0aGUgQ2VzaXVtIGJ1aWxkIHByb2Nlc3MuXG5leHBvcnQgZGVmYXVsdCBcImF0dHJpYnV0ZSB2ZWMzIHBvc2l0aW9uM0RIaWdoO1xcblxcXG5hdHRyaWJ1dGUgdmVjMyBwb3NpdGlvbjNETG93O1xcblxcXG5hdHRyaWJ1dGUgdmVjMyBub3JtYWw7XFxuXFxcbmF0dHJpYnV0ZSB2ZWM0IGNvbG9yO1xcblxcXG5hdHRyaWJ1dGUgZmxvYXQgYmF0Y2hJZDtcXG5cXFxuXFxuXFxcbnZhcnlpbmcgdmVjMyB2X3Bvc2l0aW9uRUM7XFxuXFxcbnZhcnlpbmcgdmVjMyB2X25vcm1hbEVDO1xcblxcXG52YXJ5aW5nIHZlYzQgdl9jb2xvcjtcXG5cXFxuXFxuXFxcbnZvaWQgbWFpbigpXFxuXFxcbntcXG5cXFxuICAgIHZlYzQgcCA9IGN6bV9jb21wdXRlUG9zaXRpb24oKTtcXG5cXFxuXFxuXFxcbiAgICB2X3Bvc2l0aW9uRUMgPSAoY3ptX21vZGVsVmlld1JlbGF0aXZlVG9FeWUgKiBwKS54eXo7ICAgICAgLy8gcG9zaXRpb24gaW4gZXllIGNvb3JkaW5hdGVzXFxuXFxcbiAgICB2X25vcm1hbEVDID0gY3ptX25vcm1hbCAqIG5vcm1hbDsgICAgICAgICAgICAgICAgICAgICAgICAgLy8gbm9ybWFsIGluIGV5ZSBjb29yZGluYXRlc1xcblxcXG4gICAgdl9jb2xvciA9IGNvbG9yO1xcblxcXG5cXG5cXFxuICAgIGdsX1Bvc2l0aW9uID0gY3ptX21vZGVsVmlld1Byb2plY3Rpb25SZWxhdGl2ZVRvRXllICogcDtcXG5cXFxufVxcblxcXG5cIjtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///82926\n')},76257:function(__unused_webpack___webpack_module__,__webpack_exports__){eval('//This file is automatically rebuilt by the Cesium build process.\n/* harmony default export */ __webpack_exports__["Z"] = ("varying vec4 v_color;\\n\\\n\\n\\\nvoid main()\\n\\\n{\\n\\\n    gl_FragColor = czm_gammaCorrect(v_color);\\n\\\n}\\n\\\n");\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNzYyNTcuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQSx5REFBZSxzQkFBc0I7QUFDckM7QUFDQTtBQUNBLENBQUM7QUFDRCw2Q0FBNkM7QUFDN0MsQ0FBQztBQUNELENBQUMsRUFBQyIsInNvdXJjZXMiOlsid2VicGFjazovL3Z1ZTMtd2VicGFjazUvLi9ub2RlX21vZHVsZXMvY2VzaXVtL1NvdXJjZS9TaGFkZXJzL0FwcGVhcmFuY2VzL1Blckluc3RhbmNlRmxhdENvbG9yQXBwZWFyYW5jZUZTLmpzPzdjNzYiXSwic291cmNlc0NvbnRlbnQiOlsiLy9UaGlzIGZpbGUgaXMgYXV0b21hdGljYWxseSByZWJ1aWx0IGJ5IHRoZSBDZXNpdW0gYnVpbGQgcHJvY2Vzcy5cbmV4cG9ydCBkZWZhdWx0IFwidmFyeWluZyB2ZWM0IHZfY29sb3I7XFxuXFxcblxcblxcXG52b2lkIG1haW4oKVxcblxcXG57XFxuXFxcbiAgICBnbF9GcmFnQ29sb3IgPSBjem1fZ2FtbWFDb3JyZWN0KHZfY29sb3IpO1xcblxcXG59XFxuXFxcblwiO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///76257\n')},32321:function(__unused_webpack___webpack_module__,__webpack_exports__){eval('//This file is automatically rebuilt by the Cesium build process.\n/* harmony default export */ __webpack_exports__["Z"] = ("attribute vec3 position3DHigh;\\n\\\nattribute vec3 position3DLow;\\n\\\nattribute vec4 color;\\n\\\nattribute float batchId;\\n\\\n\\n\\\nvarying vec4 v_color;\\n\\\n\\n\\\nvoid main()\\n\\\n{\\n\\\n    vec4 p = czm_computePosition();\\n\\\n\\n\\\n    v_color = color;\\n\\\n\\n\\\n    gl_Position = czm_modelViewProjectionRelativeToEye * p;\\n\\\n}\\n\\\n");\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMzIzMjEuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQSx5REFBZSwrQkFBK0I7QUFDOUMsNkJBQTZCO0FBQzdCLHFCQUFxQjtBQUNyQix3QkFBd0I7QUFDeEI7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBLENBQUM7QUFDRCxtQ0FBbUM7QUFDbkM7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQSwyREFBMkQ7QUFDM0QsQ0FBQztBQUNELENBQUMsRUFBQyIsInNvdXJjZXMiOlsid2VicGFjazovL3Z1ZTMtd2VicGFjazUvLi9ub2RlX21vZHVsZXMvY2VzaXVtL1NvdXJjZS9TaGFkZXJzL0FwcGVhcmFuY2VzL1Blckluc3RhbmNlRmxhdENvbG9yQXBwZWFyYW5jZVZTLmpzPzRjOWYiXSwic291cmNlc0NvbnRlbnQiOlsiLy9UaGlzIGZpbGUgaXMgYXV0b21hdGljYWxseSByZWJ1aWx0IGJ5IHRoZSBDZXNpdW0gYnVpbGQgcHJvY2Vzcy5cbmV4cG9ydCBkZWZhdWx0IFwiYXR0cmlidXRlIHZlYzMgcG9zaXRpb24zREhpZ2g7XFxuXFxcbmF0dHJpYnV0ZSB2ZWMzIHBvc2l0aW9uM0RMb3c7XFxuXFxcbmF0dHJpYnV0ZSB2ZWM0IGNvbG9yO1xcblxcXG5hdHRyaWJ1dGUgZmxvYXQgYmF0Y2hJZDtcXG5cXFxuXFxuXFxcbnZhcnlpbmcgdmVjNCB2X2NvbG9yO1xcblxcXG5cXG5cXFxudm9pZCBtYWluKClcXG5cXFxue1xcblxcXG4gICAgdmVjNCBwID0gY3ptX2NvbXB1dGVQb3NpdGlvbigpO1xcblxcXG5cXG5cXFxuICAgIHZfY29sb3IgPSBjb2xvcjtcXG5cXFxuXFxuXFxcbiAgICBnbF9Qb3NpdGlvbiA9IGN6bV9tb2RlbFZpZXdQcm9qZWN0aW9uUmVsYXRpdmVUb0V5ZSAqIHA7XFxuXFxcbn1cXG5cXFxuXCI7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///32321\n')},12120:function(__unused_webpack___webpack_module__,__webpack_exports__){eval('//This file is automatically rebuilt by the Cesium build process.\n/* harmony default export */ __webpack_exports__["Z"] = ("attribute vec3 position3DHigh;\\n\\\nattribute vec3 position3DLow;\\n\\\nattribute vec3 prevPosition3DHigh;\\n\\\nattribute vec3 prevPosition3DLow;\\n\\\nattribute vec3 nextPosition3DHigh;\\n\\\nattribute vec3 nextPosition3DLow;\\n\\\nattribute vec2 expandAndWidth;\\n\\\nattribute vec4 color;\\n\\\nattribute float batchId;\\n\\\n\\n\\\nvarying vec4 v_color;\\n\\\n\\n\\\nvoid main()\\n\\\n{\\n\\\n    float expandDir = expandAndWidth.x;\\n\\\n    float width = abs(expandAndWidth.y) + 0.5;\\n\\\n    bool usePrev = expandAndWidth.y < 0.0;\\n\\\n\\n\\\n    vec4 p = czm_computePosition();\\n\\\n    vec4 prev = czm_computePrevPosition();\\n\\\n    vec4 next = czm_computeNextPosition();\\n\\\n\\n\\\n    float angle;\\n\\\n    vec4 positionWC = getPolylineWindowCoordinates(p, prev, next, expandDir, width, usePrev, angle);\\n\\\n    gl_Position = czm_viewportOrthographic * positionWC;\\n\\\n\\n\\\n    v_color = color;\\n\\\n}\\n\\\n");\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTIxMjAuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQSx5REFBZSwrQkFBK0I7QUFDOUMsNkJBQTZCO0FBQzdCLGtDQUFrQztBQUNsQyxpQ0FBaUM7QUFDakMsa0NBQWtDO0FBQ2xDLGlDQUFpQztBQUNqQyw4QkFBOEI7QUFDOUIscUJBQXFCO0FBQ3JCLHdCQUF3QjtBQUN4QjtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0EsQ0FBQztBQUNELHVDQUF1QztBQUN2Qyw4Q0FBOEM7QUFDOUMsMENBQTBDO0FBQzFDO0FBQ0EsbUNBQW1DO0FBQ25DLDBDQUEwQztBQUMxQywwQ0FBMEM7QUFDMUM7QUFDQSxnQkFBZ0I7QUFDaEIsb0dBQW9HO0FBQ3BHLHdEQUF3RDtBQUN4RDtBQUNBLG9CQUFvQjtBQUNwQixDQUFDO0FBQ0QsQ0FBQyxFQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdnVlMy13ZWJwYWNrNS8uL25vZGVfbW9kdWxlcy9jZXNpdW0vU291cmNlL1NoYWRlcnMvQXBwZWFyYW5jZXMvUG9seWxpbmVDb2xvckFwcGVhcmFuY2VWUy5qcz82ZjQxIl0sInNvdXJjZXNDb250ZW50IjpbIi8vVGhpcyBmaWxlIGlzIGF1dG9tYXRpY2FsbHkgcmVidWlsdCBieSB0aGUgQ2VzaXVtIGJ1aWxkIHByb2Nlc3MuXG5leHBvcnQgZGVmYXVsdCBcImF0dHJpYnV0ZSB2ZWMzIHBvc2l0aW9uM0RIaWdoO1xcblxcXG5hdHRyaWJ1dGUgdmVjMyBwb3NpdGlvbjNETG93O1xcblxcXG5hdHRyaWJ1dGUgdmVjMyBwcmV2UG9zaXRpb24zREhpZ2g7XFxuXFxcbmF0dHJpYnV0ZSB2ZWMzIHByZXZQb3NpdGlvbjNETG93O1xcblxcXG5hdHRyaWJ1dGUgdmVjMyBuZXh0UG9zaXRpb24zREhpZ2g7XFxuXFxcbmF0dHJpYnV0ZSB2ZWMzIG5leHRQb3NpdGlvbjNETG93O1xcblxcXG5hdHRyaWJ1dGUgdmVjMiBleHBhbmRBbmRXaWR0aDtcXG5cXFxuYXR0cmlidXRlIHZlYzQgY29sb3I7XFxuXFxcbmF0dHJpYnV0ZSBmbG9hdCBiYXRjaElkO1xcblxcXG5cXG5cXFxudmFyeWluZyB2ZWM0IHZfY29sb3I7XFxuXFxcblxcblxcXG52b2lkIG1haW4oKVxcblxcXG57XFxuXFxcbiAgICBmbG9hdCBleHBhbmREaXIgPSBleHBhbmRBbmRXaWR0aC54O1xcblxcXG4gICAgZmxvYXQgd2lkdGggPSBhYnMoZXhwYW5kQW5kV2lkdGgueSkgKyAwLjU7XFxuXFxcbiAgICBib29sIHVzZVByZXYgPSBleHBhbmRBbmRXaWR0aC55IDwgMC4wO1xcblxcXG5cXG5cXFxuICAgIHZlYzQgcCA9IGN6bV9jb21wdXRlUG9zaXRpb24oKTtcXG5cXFxuICAgIHZlYzQgcHJldiA9IGN6bV9jb21wdXRlUHJldlBvc2l0aW9uKCk7XFxuXFxcbiAgICB2ZWM0IG5leHQgPSBjem1fY29tcHV0ZU5leHRQb3NpdGlvbigpO1xcblxcXG5cXG5cXFxuICAgIGZsb2F0IGFuZ2xlO1xcblxcXG4gICAgdmVjNCBwb3NpdGlvbldDID0gZ2V0UG9seWxpbmVXaW5kb3dDb29yZGluYXRlcyhwLCBwcmV2LCBuZXh0LCBleHBhbmREaXIsIHdpZHRoLCB1c2VQcmV2LCBhbmdsZSk7XFxuXFxcbiAgICBnbF9Qb3NpdGlvbiA9IGN6bV92aWV3cG9ydE9ydGhvZ3JhcGhpYyAqIHBvc2l0aW9uV0M7XFxuXFxcblxcblxcXG4gICAgdl9jb2xvciA9IGNvbG9yO1xcblxcXG59XFxuXFxcblwiO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///12120\n')},93981:function(__unused_webpack___webpack_module__,__webpack_exports__){eval('//This file is automatically rebuilt by the Cesium build process.\n/* harmony default export */ __webpack_exports__["Z"] = ("attribute vec3 position3DHigh;\\n\\\nattribute vec3 position3DLow;\\n\\\nattribute vec3 prevPosition3DHigh;\\n\\\nattribute vec3 prevPosition3DLow;\\n\\\nattribute vec3 nextPosition3DHigh;\\n\\\nattribute vec3 nextPosition3DLow;\\n\\\nattribute vec2 expandAndWidth;\\n\\\nattribute vec2 st;\\n\\\nattribute float batchId;\\n\\\n\\n\\\nvarying float v_width;\\n\\\nvarying vec2 v_st;\\n\\\nvarying float v_polylineAngle;\\n\\\n\\n\\\nvoid main()\\n\\\n{\\n\\\n    float expandDir = expandAndWidth.x;\\n\\\n    float width = abs(expandAndWidth.y) + 0.5;\\n\\\n    bool usePrev = expandAndWidth.y < 0.0;\\n\\\n\\n\\\n    vec4 p = czm_computePosition();\\n\\\n    vec4 prev = czm_computePrevPosition();\\n\\\n    vec4 next = czm_computeNextPosition();\\n\\\n\\n\\\n    float angle;\\n\\\n    vec4 positionWC = getPolylineWindowCoordinates(p, prev, next, expandDir, width, usePrev, angle);\\n\\\n    gl_Position = czm_viewportOrthographic * positionWC;\\n\\\n\\n\\\n    v_width = width;\\n\\\n    v_st.s = st.s;\\n\\\n    v_st.t = czm_writeNonPerspective(st.t, gl_Position.w);\\n\\\n    v_polylineAngle = angle;\\n\\\n}\\n\\\n");\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiOTM5ODEuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQSx5REFBZSwrQkFBK0I7QUFDOUMsNkJBQTZCO0FBQzdCLGtDQUFrQztBQUNsQyxpQ0FBaUM7QUFDakMsa0NBQWtDO0FBQ2xDLGlDQUFpQztBQUNqQyw4QkFBOEI7QUFDOUIsa0JBQWtCO0FBQ2xCLHdCQUF3QjtBQUN4QjtBQUNBLHNCQUFzQjtBQUN0QixrQkFBa0I7QUFDbEIsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQSxDQUFDO0FBQ0QsdUNBQXVDO0FBQ3ZDLDhDQUE4QztBQUM5QywwQ0FBMEM7QUFDMUM7QUFDQSxtQ0FBbUM7QUFDbkMsMENBQTBDO0FBQzFDLDBDQUEwQztBQUMxQztBQUNBLGdCQUFnQjtBQUNoQixvR0FBb0c7QUFDcEcsd0RBQXdEO0FBQ3hEO0FBQ0Esb0JBQW9CO0FBQ3BCLGtCQUFrQjtBQUNsQiwwREFBMEQ7QUFDMUQsNEJBQTRCO0FBQzVCLENBQUM7QUFDRCxDQUFDLEVBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly92dWUzLXdlYnBhY2s1Ly4vbm9kZV9tb2R1bGVzL2Nlc2l1bS9Tb3VyY2UvU2hhZGVycy9BcHBlYXJhbmNlcy9Qb2x5bGluZU1hdGVyaWFsQXBwZWFyYW5jZVZTLmpzPzBmNzgiXSwic291cmNlc0NvbnRlbnQiOlsiLy9UaGlzIGZpbGUgaXMgYXV0b21hdGljYWxseSByZWJ1aWx0IGJ5IHRoZSBDZXNpdW0gYnVpbGQgcHJvY2Vzcy5cbmV4cG9ydCBkZWZhdWx0IFwiYXR0cmlidXRlIHZlYzMgcG9zaXRpb24zREhpZ2g7XFxuXFxcbmF0dHJpYnV0ZSB2ZWMzIHBvc2l0aW9uM0RMb3c7XFxuXFxcbmF0dHJpYnV0ZSB2ZWMzIHByZXZQb3NpdGlvbjNESGlnaDtcXG5cXFxuYXR0cmlidXRlIHZlYzMgcHJldlBvc2l0aW9uM0RMb3c7XFxuXFxcbmF0dHJpYnV0ZSB2ZWMzIG5leHRQb3NpdGlvbjNESGlnaDtcXG5cXFxuYXR0cmlidXRlIHZlYzMgbmV4dFBvc2l0aW9uM0RMb3c7XFxuXFxcbmF0dHJpYnV0ZSB2ZWMyIGV4cGFuZEFuZFdpZHRoO1xcblxcXG5hdHRyaWJ1dGUgdmVjMiBzdDtcXG5cXFxuYXR0cmlidXRlIGZsb2F0IGJhdGNoSWQ7XFxuXFxcblxcblxcXG52YXJ5aW5nIGZsb2F0IHZfd2lkdGg7XFxuXFxcbnZhcnlpbmcgdmVjMiB2X3N0O1xcblxcXG52YXJ5aW5nIGZsb2F0IHZfcG9seWxpbmVBbmdsZTtcXG5cXFxuXFxuXFxcbnZvaWQgbWFpbigpXFxuXFxcbntcXG5cXFxuICAgIGZsb2F0IGV4cGFuZERpciA9IGV4cGFuZEFuZFdpZHRoLng7XFxuXFxcbiAgICBmbG9hdCB3aWR0aCA9IGFicyhleHBhbmRBbmRXaWR0aC55KSArIDAuNTtcXG5cXFxuICAgIGJvb2wgdXNlUHJldiA9IGV4cGFuZEFuZFdpZHRoLnkgPCAwLjA7XFxuXFxcblxcblxcXG4gICAgdmVjNCBwID0gY3ptX2NvbXB1dGVQb3NpdGlvbigpO1xcblxcXG4gICAgdmVjNCBwcmV2ID0gY3ptX2NvbXB1dGVQcmV2UG9zaXRpb24oKTtcXG5cXFxuICAgIHZlYzQgbmV4dCA9IGN6bV9jb21wdXRlTmV4dFBvc2l0aW9uKCk7XFxuXFxcblxcblxcXG4gICAgZmxvYXQgYW5nbGU7XFxuXFxcbiAgICB2ZWM0IHBvc2l0aW9uV0MgPSBnZXRQb2x5bGluZVdpbmRvd0Nvb3JkaW5hdGVzKHAsIHByZXYsIG5leHQsIGV4cGFuZERpciwgd2lkdGgsIHVzZVByZXYsIGFuZ2xlKTtcXG5cXFxuICAgIGdsX1Bvc2l0aW9uID0gY3ptX3ZpZXdwb3J0T3J0aG9ncmFwaGljICogcG9zaXRpb25XQztcXG5cXFxuXFxuXFxcbiAgICB2X3dpZHRoID0gd2lkdGg7XFxuXFxcbiAgICB2X3N0LnMgPSBzdC5zO1xcblxcXG4gICAgdl9zdC50ID0gY3ptX3dyaXRlTm9uUGVyc3BlY3RpdmUoc3QudCwgZ2xfUG9zaXRpb24udyk7XFxuXFxcbiAgICB2X3BvbHlsaW5lQW5nbGUgPSBhbmdsZTtcXG5cXFxufVxcblxcXG5cIjtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///93981\n')},93774:function(__unused_webpack___webpack_module__,__webpack_exports__){eval('//This file is automatically rebuilt by the Cesium build process.\n/* harmony default export */ __webpack_exports__["Z"] = ("varying vec3 v_positionEC;\\n\\\nvarying vec3 v_normalEC;\\n\\\nvarying vec2 v_st;\\n\\\n\\n\\\nvoid main()\\n\\\n{\\n\\\n    vec3 positionToEyeEC = -v_positionEC;\\n\\\n\\n\\\n    vec3 normalEC = normalize(v_normalEC);\\n\\\n#ifdef FACE_FORWARD\\n\\\n    normalEC = faceforward(normalEC, vec3(0.0, 0.0, 1.0), -normalEC);\\n\\\n#endif\\n\\\n\\n\\\n    czm_materialInput materialInput;\\n\\\n    materialInput.normalEC = normalEC;\\n\\\n    materialInput.positionToEyeEC = positionToEyeEC;\\n\\\n    materialInput.st = v_st;\\n\\\n    czm_material material = czm_getMaterial(materialInput);\\n\\\n\\n\\\n#ifdef FLAT\\n\\\n    gl_FragColor = vec4(material.diffuse + material.emission, material.alpha);\\n\\\n#else\\n\\\n    gl_FragColor = czm_phong(normalize(positionToEyeEC), material, czm_lightDirectionEC);\\n\\\n#endif\\n\\\n}\\n\\\n");\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiOTM3NzQuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQSx5REFBZSwyQkFBMkI7QUFDMUMsd0JBQXdCO0FBQ3hCLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0EsQ0FBQztBQUNELHlDQUF5QztBQUN6QztBQUNBLDBDQUEwQztBQUMxQztBQUNBLHFFQUFxRTtBQUNyRTtBQUNBO0FBQ0Esb0NBQW9DO0FBQ3BDLHNDQUFzQztBQUN0QyxvREFBb0Q7QUFDcEQsNEJBQTRCO0FBQzVCLDJEQUEyRDtBQUMzRDtBQUNBO0FBQ0EsOEVBQThFO0FBQzlFO0FBQ0EseUZBQXlGO0FBQ3pGO0FBQ0EsQ0FBQztBQUNELENBQUMsRUFBQyIsInNvdXJjZXMiOlsid2VicGFjazovL3Z1ZTMtd2VicGFjazUvLi9ub2RlX21vZHVsZXMvY2VzaXVtL1NvdXJjZS9TaGFkZXJzL0FwcGVhcmFuY2VzL1RleHR1cmVkTWF0ZXJpYWxBcHBlYXJhbmNlRlMuanM/YmJmYSJdLCJzb3VyY2VzQ29udGVudCI6WyIvL1RoaXMgZmlsZSBpcyBhdXRvbWF0aWNhbGx5IHJlYnVpbHQgYnkgdGhlIENlc2l1bSBidWlsZCBwcm9jZXNzLlxuZXhwb3J0IGRlZmF1bHQgXCJ2YXJ5aW5nIHZlYzMgdl9wb3NpdGlvbkVDO1xcblxcXG52YXJ5aW5nIHZlYzMgdl9ub3JtYWxFQztcXG5cXFxudmFyeWluZyB2ZWMyIHZfc3Q7XFxuXFxcblxcblxcXG52b2lkIG1haW4oKVxcblxcXG57XFxuXFxcbiAgICB2ZWMzIHBvc2l0aW9uVG9FeWVFQyA9IC12X3Bvc2l0aW9uRUM7XFxuXFxcblxcblxcXG4gICAgdmVjMyBub3JtYWxFQyA9IG5vcm1hbGl6ZSh2X25vcm1hbEVDKTtcXG5cXFxuI2lmZGVmIEZBQ0VfRk9SV0FSRFxcblxcXG4gICAgbm9ybWFsRUMgPSBmYWNlZm9yd2FyZChub3JtYWxFQywgdmVjMygwLjAsIDAuMCwgMS4wKSwgLW5vcm1hbEVDKTtcXG5cXFxuI2VuZGlmXFxuXFxcblxcblxcXG4gICAgY3ptX21hdGVyaWFsSW5wdXQgbWF0ZXJpYWxJbnB1dDtcXG5cXFxuICAgIG1hdGVyaWFsSW5wdXQubm9ybWFsRUMgPSBub3JtYWxFQztcXG5cXFxuICAgIG1hdGVyaWFsSW5wdXQucG9zaXRpb25Ub0V5ZUVDID0gcG9zaXRpb25Ub0V5ZUVDO1xcblxcXG4gICAgbWF0ZXJpYWxJbnB1dC5zdCA9IHZfc3Q7XFxuXFxcbiAgICBjem1fbWF0ZXJpYWwgbWF0ZXJpYWwgPSBjem1fZ2V0TWF0ZXJpYWwobWF0ZXJpYWxJbnB1dCk7XFxuXFxcblxcblxcXG4jaWZkZWYgRkxBVFxcblxcXG4gICAgZ2xfRnJhZ0NvbG9yID0gdmVjNChtYXRlcmlhbC5kaWZmdXNlICsgbWF0ZXJpYWwuZW1pc3Npb24sIG1hdGVyaWFsLmFscGhhKTtcXG5cXFxuI2Vsc2VcXG5cXFxuICAgIGdsX0ZyYWdDb2xvciA9IGN6bV9waG9uZyhub3JtYWxpemUocG9zaXRpb25Ub0V5ZUVDKSwgbWF0ZXJpYWwsIGN6bV9saWdodERpcmVjdGlvbkVDKTtcXG5cXFxuI2VuZGlmXFxuXFxcbn1cXG5cXFxuXCI7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///93774\n')},80330:function(__unused_webpack___webpack_module__,__webpack_exports__){eval('//This file is automatically rebuilt by the Cesium build process.\n/* harmony default export */ __webpack_exports__["Z"] = ("attribute vec3 position3DHigh;\\n\\\nattribute vec3 position3DLow;\\n\\\nattribute vec3 normal;\\n\\\nattribute vec2 st;\\n\\\nattribute float batchId;\\n\\\n\\n\\\nvarying vec3 v_positionEC;\\n\\\nvarying vec3 v_normalEC;\\n\\\nvarying vec2 v_st;\\n\\\n\\n\\\nvoid main()\\n\\\n{\\n\\\n    vec4 p = czm_computePosition();\\n\\\n\\n\\\n    v_positionEC = (czm_modelViewRelativeToEye * p).xyz;      // position in eye coordinates\\n\\\n    v_normalEC = czm_normal * normal;                         // normal in eye coordinates\\n\\\n    v_st = st;\\n\\\n\\n\\\n    gl_Position = czm_modelViewProjectionRelativeToEye * p;\\n\\\n}\\n\\\n");\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiODAzMzAuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQSx5REFBZSwrQkFBK0I7QUFDOUMsNkJBQTZCO0FBQzdCLHNCQUFzQjtBQUN0QixrQkFBa0I7QUFDbEIsd0JBQXdCO0FBQ3hCO0FBQ0EsMEJBQTBCO0FBQzFCLHdCQUF3QjtBQUN4QixrQkFBa0I7QUFDbEI7QUFDQTtBQUNBLENBQUM7QUFDRCxtQ0FBbUM7QUFDbkM7QUFDQSw4REFBOEQ7QUFDOUQsOERBQThEO0FBQzlELGNBQWM7QUFDZDtBQUNBLDJEQUEyRDtBQUMzRCxDQUFDO0FBQ0QsQ0FBQyxFQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdnVlMy13ZWJwYWNrNS8uL25vZGVfbW9kdWxlcy9jZXNpdW0vU291cmNlL1NoYWRlcnMvQXBwZWFyYW5jZXMvVGV4dHVyZWRNYXRlcmlhbEFwcGVhcmFuY2VWUy5qcz82MmM3Il0sInNvdXJjZXNDb250ZW50IjpbIi8vVGhpcyBmaWxlIGlzIGF1dG9tYXRpY2FsbHkgcmVidWlsdCBieSB0aGUgQ2VzaXVtIGJ1aWxkIHByb2Nlc3MuXG5leHBvcnQgZGVmYXVsdCBcImF0dHJpYnV0ZSB2ZWMzIHBvc2l0aW9uM0RIaWdoO1xcblxcXG5hdHRyaWJ1dGUgdmVjMyBwb3NpdGlvbjNETG93O1xcblxcXG5hdHRyaWJ1dGUgdmVjMyBub3JtYWw7XFxuXFxcbmF0dHJpYnV0ZSB2ZWMyIHN0O1xcblxcXG5hdHRyaWJ1dGUgZmxvYXQgYmF0Y2hJZDtcXG5cXFxuXFxuXFxcbnZhcnlpbmcgdmVjMyB2X3Bvc2l0aW9uRUM7XFxuXFxcbnZhcnlpbmcgdmVjMyB2X25vcm1hbEVDO1xcblxcXG52YXJ5aW5nIHZlYzIgdl9zdDtcXG5cXFxuXFxuXFxcbnZvaWQgbWFpbigpXFxuXFxcbntcXG5cXFxuICAgIHZlYzQgcCA9IGN6bV9jb21wdXRlUG9zaXRpb24oKTtcXG5cXFxuXFxuXFxcbiAgICB2X3Bvc2l0aW9uRUMgPSAoY3ptX21vZGVsVmlld1JlbGF0aXZlVG9FeWUgKiBwKS54eXo7ICAgICAgLy8gcG9zaXRpb24gaW4gZXllIGNvb3JkaW5hdGVzXFxuXFxcbiAgICB2X25vcm1hbEVDID0gY3ptX25vcm1hbCAqIG5vcm1hbDsgICAgICAgICAgICAgICAgICAgICAgICAgLy8gbm9ybWFsIGluIGV5ZSBjb29yZGluYXRlc1xcblxcXG4gICAgdl9zdCA9IHN0O1xcblxcXG5cXG5cXFxuICAgIGdsX1Bvc2l0aW9uID0gY3ptX21vZGVsVmlld1Byb2plY3Rpb25SZWxhdGl2ZVRvRXllICogcDtcXG5cXFxufVxcblxcXG5cIjtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///80330\n')},39111:function(__unused_webpack___webpack_module__,__webpack_exports__){eval('//This file is automatically rebuilt by the Cesium build process.\n/* harmony default export */ __webpack_exports__["Z"] = ("#ifdef GL_OES_standard_derivatives\\n\\\n#extension GL_OES_standard_derivatives : enable\\n\\\n#endif\\n\\\n\\n\\\nuniform sampler2D u_atlas;\\n\\\n\\n\\\n#ifdef VECTOR_TILE\\n\\\nuniform vec4 u_highlightColor;\\n\\\n#endif\\n\\\n\\n\\\nvarying vec2 v_textureCoordinates;\\n\\\nvarying vec4 v_pickColor;\\n\\\nvarying vec4 v_color;\\n\\\n\\n\\\n#ifdef SDF\\n\\\nvarying vec4 v_outlineColor;\\n\\\nvarying float v_outlineWidth;\\n\\\n#endif\\n\\\n\\n\\\n#ifdef FRAGMENT_DEPTH_CHECK\\n\\\nvarying vec4 v_textureCoordinateBounds;                  // the min and max x and y values for the texture coordinates\\n\\\nvarying vec4 v_originTextureCoordinateAndTranslate;      // texture coordinate at the origin, billboard translate (used for label glyphs)\\n\\\nvarying vec4 v_compressed;                               // x: eyeDepth, y: applyTranslate & enableDepthCheck, z: dimensions, w: imageSize\\n\\\nvarying mat2 v_rotationMatrix;\\n\\\n\\n\\\nconst float SHIFT_LEFT12 = 4096.0;\\n\\\nconst float SHIFT_LEFT1 = 2.0;\\n\\\n\\n\\\nconst float SHIFT_RIGHT12 = 1.0 / 4096.0;\\n\\\nconst float SHIFT_RIGHT1 = 1.0 / 2.0;\\n\\\n\\n\\\nfloat getGlobeDepth(vec2 adjustedST, vec2 depthLookupST, bool applyTranslate, vec2 dimensions, vec2 imageSize)\\n\\\n{\\n\\\n    vec2 lookupVector = imageSize * (depthLookupST - adjustedST);\\n\\\n    lookupVector = v_rotationMatrix * lookupVector;\\n\\\n    vec2 labelOffset = (dimensions - imageSize) * (depthLookupST - vec2(0.0, v_originTextureCoordinateAndTranslate.y)); // aligns label glyph with bounding rectangle.  Will be zero for billboards because dimensions and imageSize will be equal\\n\\\n\\n\\\n    vec2 translation = v_originTextureCoordinateAndTranslate.zw;\\n\\\n\\n\\\n    if (applyTranslate)\\n\\\n    {\\n\\\n        // this is only needed for labels where the horizontal origin is not LEFT\\n\\\n        // it moves the label back to where the \\"origin\\" should be since all label glyphs are set to HorizontalOrigin.LEFT\\n\\\n        translation += (dimensions * v_originTextureCoordinateAndTranslate.xy * vec2(1.0, 0.0));\\n\\\n    }\\n\\\n\\n\\\n    vec2 st = ((lookupVector - translation + labelOffset) + gl_FragCoord.xy) / czm_viewport.zw;\\n\\\n    float logDepthOrDepth = czm_unpackDepth(texture2D(czm_globeDepthTexture, st));\\n\\\n\\n\\\n    if (logDepthOrDepth == 0.0)\\n\\\n    {\\n\\\n        return 0.0; // not on the globe\\n\\\n    }\\n\\\n\\n\\\n    vec4 eyeCoordinate = czm_windowToEyeCoordinates(gl_FragCoord.xy, logDepthOrDepth);\\n\\\n    return eyeCoordinate.z / eyeCoordinate.w;\\n\\\n}\\n\\\n#endif\\n\\\n\\n\\\n\\n\\\n#ifdef SDF\\n\\\n\\n\\\n// Get the distance from the edge of a glyph at a given position sampling an SDF texture.\\n\\\nfloat getDistance(vec2 position)\\n\\\n{\\n\\\n    return texture2D(u_atlas, position).r;\\n\\\n}\\n\\\n\\n\\\n// Samples the sdf texture at the given position and produces a color based on the fill color and the outline.\\n\\\nvec4 getSDFColor(vec2 position, float outlineWidth, vec4 outlineColor, float smoothing)\\n\\\n{\\n\\\n    float distance = getDistance(position);\\n\\\n\\n\\\n    if (outlineWidth > 0.0)\\n\\\n    {\\n\\\n        // Don\'t get the outline edge exceed the SDF_EDGE\\n\\\n        float outlineEdge = clamp(SDF_EDGE - outlineWidth, 0.0, SDF_EDGE);\\n\\\n        float outlineFactor = smoothstep(SDF_EDGE - smoothing, SDF_EDGE + smoothing, distance);\\n\\\n        vec4 sdfColor = mix(outlineColor, v_color, outlineFactor);\\n\\\n        float alpha = smoothstep(outlineEdge - smoothing, outlineEdge + smoothing, distance);\\n\\\n        return vec4(sdfColor.rgb, sdfColor.a * alpha);\\n\\\n    }\\n\\\n    else\\n\\\n    {\\n\\\n        float alpha = smoothstep(SDF_EDGE - smoothing, SDF_EDGE + smoothing, distance);\\n\\\n        return vec4(v_color.rgb, v_color.a * alpha);\\n\\\n    }\\n\\\n}\\n\\\n#endif\\n\\\n\\n\\\nvoid main()\\n\\\n{\\n\\\n    vec4 color = texture2D(u_atlas, v_textureCoordinates);\\n\\\n\\n\\\n#ifdef SDF\\n\\\n    float outlineWidth = v_outlineWidth;\\n\\\n    vec4 outlineColor = v_outlineColor;\\n\\\n\\n\\\n    // Get the current distance\\n\\\n    float distance = getDistance(v_textureCoordinates);\\n\\\n\\n\\\n#ifdef GL_OES_standard_derivatives\\n\\\n    float smoothing = fwidth(distance);\\n\\\n    // Get an offset that is approximately half the distance to the neighbor pixels\\n\\\n    // 0.354 is approximately half of 1/sqrt(2)\\n\\\n    vec2 sampleOffset = 0.354 * vec2(dFdx(v_textureCoordinates) + dFdy(v_textureCoordinates));\\n\\\n\\n\\\n    // Sample the center point\\n\\\n    vec4 center = getSDFColor(v_textureCoordinates, outlineWidth, outlineColor, smoothing);\\n\\\n\\n\\\n    // Sample the 4 neighbors\\n\\\n    vec4 color1 = getSDFColor(v_textureCoordinates + vec2(sampleOffset.x, sampleOffset.y), outlineWidth, outlineColor, smoothing);\\n\\\n    vec4 color2 = getSDFColor(v_textureCoordinates + vec2(-sampleOffset.x, sampleOffset.y), outlineWidth, outlineColor, smoothing);\\n\\\n    vec4 color3 = getSDFColor(v_textureCoordinates + vec2(-sampleOffset.x, -sampleOffset.y), outlineWidth, outlineColor, smoothing);\\n\\\n    vec4 color4 = getSDFColor(v_textureCoordinates + vec2(sampleOffset.x, -sampleOffset.y), outlineWidth, outlineColor, smoothing);\\n\\\n\\n\\\n    // Equally weight the center sample and the 4 neighboring samples\\n\\\n    color = (center + color1 + color2 + color3 + color4)/5.0;\\n\\\n#else\\n\\\n    // Just do a single sample\\n\\\n    float smoothing = 1.0/32.0;\\n\\\n    color = getSDFColor(v_textureCoordinates, outlineWidth, outlineColor, smoothing);\\n\\\n#endif\\n\\\n\\n\\\n    color = czm_gammaCorrect(color);\\n\\\n#else\\n\\\n    color = czm_gammaCorrect(color);\\n\\\n    color *= czm_gammaCorrect(v_color);\\n\\\n#endif\\n\\\n\\n\\\n// Fully transparent parts of the billboard are not pickable.\\n\\\n#if !defined(OPAQUE) && !defined(TRANSLUCENT)\\n\\\n    if (color.a < 0.005)   // matches 0/255 and 1/255\\n\\\n    {\\n\\\n        discard;\\n\\\n    }\\n\\\n#else\\n\\\n// The billboard is rendered twice. The opaque pass discards translucent fragments\\n\\\n// and the translucent pass discards opaque fragments.\\n\\\n#ifdef OPAQUE\\n\\\n    if (color.a < 0.995)   // matches < 254/255\\n\\\n    {\\n\\\n        discard;\\n\\\n    }\\n\\\n#else\\n\\\n    if (color.a >= 0.995)  // matches 254/255 and 255/255\\n\\\n    {\\n\\\n        discard;\\n\\\n    }\\n\\\n#endif\\n\\\n#endif\\n\\\n\\n\\\n#ifdef VECTOR_TILE\\n\\\n    color *= u_highlightColor;\\n\\\n#endif\\n\\\n    gl_FragColor = color;\\n\\\n\\n\\\n#ifdef LOG_DEPTH\\n\\\n    czm_writeLogDepth();\\n\\\n#endif\\n\\\n\\n\\\n#ifdef FRAGMENT_DEPTH_CHECK\\n\\\n    float temp = v_compressed.y;\\n\\\n\\n\\\n    temp = temp * SHIFT_RIGHT1;\\n\\\n\\n\\\n    float temp2 = (temp - floor(temp)) * SHIFT_LEFT1;\\n\\\n    bool enableDepthTest = temp2 != 0.0;\\n\\\n    bool applyTranslate = floor(temp) != 0.0;\\n\\\n\\n\\\n    if (enableDepthTest) {\\n\\\n        temp = v_compressed.z;\\n\\\n        temp = temp * SHIFT_RIGHT12;\\n\\\n\\n\\\n        vec2 dimensions;\\n\\\n        dimensions.y = (temp - floor(temp)) * SHIFT_LEFT12;\\n\\\n        dimensions.x = floor(temp);\\n\\\n\\n\\\n        temp = v_compressed.w;\\n\\\n        temp = temp * SHIFT_RIGHT12;\\n\\\n\\n\\\n        vec2 imageSize;\\n\\\n        imageSize.y = (temp - floor(temp)) * SHIFT_LEFT12;\\n\\\n        imageSize.x = floor(temp);\\n\\\n\\n\\\n        vec2 adjustedST = v_textureCoordinates - v_textureCoordinateBounds.xy;\\n\\\n        adjustedST = adjustedST / vec2(v_textureCoordinateBounds.z - v_textureCoordinateBounds.x, v_textureCoordinateBounds.w - v_textureCoordinateBounds.y);\\n\\\n\\n\\\n        float epsilonEyeDepth = v_compressed.x + czm_epsilon1;\\n\\\n        float globeDepth1 = getGlobeDepth(adjustedST, v_originTextureCoordinateAndTranslate.xy, applyTranslate, dimensions, imageSize);\\n\\\n\\n\\\n        // negative values go into the screen\\n\\\n        if (globeDepth1 != 0.0 && globeDepth1 > epsilonEyeDepth)\\n\\\n        {\\n\\\n            float globeDepth2 = getGlobeDepth(adjustedST, vec2(0.0, 1.0), applyTranslate, dimensions, imageSize); // top left corner\\n\\\n            if (globeDepth2 != 0.0 && globeDepth2 > epsilonEyeDepth)\\n\\\n            {\\n\\\n                float globeDepth3 = getGlobeDepth(adjustedST, vec2(1.0, 1.0), applyTranslate, dimensions, imageSize); // top right corner\\n\\\n                if (globeDepth3 != 0.0 && globeDepth3 > epsilonEyeDepth)\\n\\\n                {\\n\\\n                    discard;\\n\\\n                }\\n\\\n            }\\n\\\n        }\\n\\\n    }\\n\\\n#endif\\n\\\n\\n\\\n}\\n\\\n");\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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LGlCQUFpQjtBQUNqQiw0QkFBNEI7QUFDNUIsaUJBQWlCO0FBQ2pCLGFBQWE7QUFDYixTQUFTO0FBQ1QsS0FBSztBQUNMO0FBQ0E7QUFDQSxDQUFDO0FBQ0QsQ0FBQyxFQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdnVlMy13ZWJwYWNrNS8uL25vZGVfbW9kdWxlcy9jZXNpdW0vU291cmNlL1NoYWRlcnMvQmlsbGJvYXJkQ29sbGVjdGlvbkZTLmpzPzVhYWEiXSwic291cmNlc0NvbnRlbnQiOlsiLy9UaGlzIGZpbGUgaXMgYXV0b21hdGljYWxseSByZWJ1aWx0IGJ5IHRoZSBDZXNpdW0gYnVpbGQgcHJvY2Vzcy5cbmV4cG9ydCBkZWZhdWx0IFwiI2lmZGVmIEdMX09FU19zdGFuZGFyZF9kZXJpdmF0aXZlc1xcblxcXG4jZXh0ZW5zaW9uIEdMX09FU19zdGFuZGFyZF9kZXJpdmF0aXZlcyA6IGVuYWJsZVxcblxcXG4jZW5kaWZcXG5cXFxuXFxuXFxcbnVuaWZvcm0gc2FtcGxlcjJEIHVfYXRsYXM7XFxuXFxcblxcblxcXG4jaWZkZWYgVkVDVE9SX1RJTEVcXG5cXFxudW5pZm9ybSB2ZWM0IHVfaGlnaGxpZ2h0Q29sb3I7XFxuXFxcbiNlbmRpZlxcblxcXG5cXG5cXFxudmFyeWluZyB2ZWMyIHZfdGV4dHVyZUNvb3JkaW5hdGVzO1xcblxcXG52YXJ5aW5nIHZlYzQgdl9waWNrQ29sb3I7XFxuXFxcbnZhcnlpbmcgdmVjNCB2X2NvbG9yO1xcblxcXG5cXG5cXFxuI2lmZGVmIFNERlxcblxcXG52YXJ5aW5nIHZlYzQgdl9vdXRsaW5lQ29sb3I7XFxuXFxcbnZhcnlpbmcgZmxvYXQgdl9vdXRsaW5lV2lkdGg7XFxuXFxcbiNlbmRpZlxcblxcXG5cXG5cXFxuI2lmZGVmIEZSQUdNRU5UX0RFUFRIX0NIRUNLXFxuXFxcbnZhcnlpbmcgdmVjNCB2X3RleHR1cmVDb29yZGluYXRlQm91bmRzOyAgICAgICAgICAgICAgICAgIC8vIHRoZSBtaW4gYW5kIG1heCB4IGFuZCB5IHZhbHVlcyBmb3IgdGhlIHRleHR1cmUgY29vcmRpbmF0ZXNcXG5cXFxudmFyeWluZyB2ZWM0IHZfb3JpZ2luVGV4dHVyZUNvb3JkaW5hdGVBbmRUcmFuc2xhdGU7ICAgICAgLy8gdGV4dHVyZSBjb29yZGluYXRlIGF0IHRoZSBvcmlnaW4sIGJpbGxib2FyZCB0cmFuc2xhdGUgKHVzZWQgZm9yIGxhYmVsIGdseXBocylcXG5cXFxudmFyeWluZyB2ZWM0IHZfY29tcHJlc3NlZDsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8geDogZXllRGVwdGgsIHk6IGFwcGx5VHJhbnNsYXRlICYgZW5hYmxlRGVwdGhDaGVjaywgejogZGltZW5zaW9ucywgdzogaW1hZ2VTaXplXFxuXFxcbnZhcnlpbmcgbWF0MiB2X3JvdGF0aW9uTWF0cml4O1xcblxcXG5cXG5cXFxuY29uc3QgZmxvYXQgU0hJRlRfTEVGVDEyID0gNDA5Ni4wO1xcblxcXG5jb25zdCBmbG9hdCBTSElGVF9MRUZUMSA9IDIuMDtcXG5cXFxuXFxuXFxcbmNvbnN0IGZsb2F0IFNISUZUX1JJR0hUMTIgPSAxLjAgLyA0MDk2LjA7XFxuXFxcbmNvbnN0IGZsb2F0IFNISUZUX1JJR0hUMSA9IDEuMCAvIDIuMDtcXG5cXFxuXFxuXFxcbmZsb2F0IGdldEdsb2JlRGVwdGgodmVjMiBhZGp1c3RlZFNULCB2ZWMyIGRlcHRoTG9va3VwU1QsIGJvb2wgYXBwbHlUcmFuc2xhdGUsIHZlYzIgZGltZW5zaW9ucywgdmVjMiBpbWFnZVNpemUpXFxuXFxcbntcXG5cXFxuICAgIHZlYzIgbG9va3VwVmVjdG9yID0gaW1hZ2VTaXplICogKGRlcHRoTG9va3VwU1QgLSBhZGp1c3RlZFNUKTtcXG5cXFxuICAgIGxvb2t1cFZlY3RvciA9IHZfcm90YXRpb25NYXRyaXggKiBsb29rdXBWZWN0b3I7XFxuXFxcbiAgICB2ZWMyIGxhYmVsT2Zmc2V0ID0gKGRpbWVuc2lvbnMgLSBpbWFnZVNpemUpICogKGRlcHRoTG9va3VwU1QgLSB2ZWMyKDAuMCwgdl9vcmlnaW5UZXh0dXJlQ29vcmRpbmF0ZUFuZFRyYW5zbGF0ZS55KSk7IC8vIGFsaWducyBsYWJlbCBnbHlwaCB3aXRoIGJvdW5kaW5nIHJlY3RhbmdsZS4gIFdpbGwgYmUgemVybyBmb3IgYmlsbGJvYXJkcyBiZWNhdXNlIGRpbWVuc2lvbnMgYW5kIGltYWdlU2l6ZSB3aWxsIGJlIGVxdWFsXFxuXFxcblxcblxcXG4gICAgdmVjMiB0cmFuc2xhdGlvbiA9IHZfb3JpZ2luVGV4dHVyZUNvb3JkaW5hdGVBbmRUcmFuc2xhdGUuenc7XFxuXFxcblxcblxcXG4gICAgaWYgKGFwcGx5VHJhbnNsYXRlKVxcblxcXG4gICAge1xcblxcXG4gICAgICAgIC8vIHRoaXMgaXMgb25seSBuZWVkZWQgZm9yIGxhYmVscyB3aGVyZSB0aGUgaG9yaXpvbnRhbCBvcmlnaW4gaXMgbm90IExFRlRcXG5cXFxuICAgICAgICAvLyBpdCBtb3ZlcyB0aGUgbGFiZWwgYmFjayB0byB3aGVyZSB0aGUgXFxcIm9yaWdpblxcXCIgc2hvdWxkIGJlIHNpbmNlIGFsbCBsYWJlbCBnbHlwaHMgYXJlIHNldCB0byBIb3Jpem9udGFsT3JpZ2luLkxFRlRcXG5cXFxuICAgICAgICB0cmFuc2xhdGlvbiArPSAoZGltZW5zaW9ucyAqIHZfb3JpZ2luVGV4dHVyZUNvb3JkaW5hdGVBbmRUcmFuc2xhdGUueHkgKiB2ZWMyKDEuMCwgMC4wKSk7XFxuXFxcbiAgICB9XFxuXFxcblxcblxcXG4gICAgdmVjMiBzdCA9ICgobG9va3VwVmVjdG9yIC0gdHJhbnNsYXRpb24gKyBsYWJlbE9mZnNldCkgKyBnbF9GcmFnQ29vcmQueHkpIC8gY3ptX3ZpZXdwb3J0Lnp3O1xcblxcXG4gICAgZmxvYXQgbG9nRGVwdGhPckRlcHRoID0gY3ptX3VucGFja0RlcHRoKHRleHR1cmUyRChjem1fZ2xvYmVEZXB0aFRleHR1cmUsIHN0KSk7XFxuXFxcblxcblxcXG4gICAgaWYgKGxvZ0RlcHRoT3JEZXB0aCA9PSAwLjApXFxuXFxcbiAgICB7XFxuXFxcbiAgICAgICAgcmV0dXJuIDAuMDsgLy8gbm90IG9uIHRoZSBnbG9iZVxcblxcXG4gICAgfVxcblxcXG5cXG5cXFxuICAgIHZlYzQgZXllQ29vcmRpbmF0ZSA9IGN6bV93aW5kb3dUb0V5ZUNvb3JkaW5hdGVzKGdsX0ZyYWdDb29yZC54eSwgbG9nRGVwdGhPckRlcHRoKTtcXG5cXFxuICAgIHJldHVybiBleWVDb29yZGluYXRlLnogLyBleWVDb29yZGluYXRlLnc7XFxuXFxcbn1cXG5cXFxuI2VuZGlmXFxuXFxcblxcblxcXG5cXG5cXFxuI2lmZGVmIFNERlxcblxcXG5cXG5cXFxuLy8gR2V0IHRoZSBkaXN0YW5jZSBmcm9tIHRoZSBlZGdlIG9mIGEgZ2x5cGggYXQgYSBnaXZlbiBwb3NpdGlvbiBzYW1wbGluZyBhbiBTREYgdGV4dHVyZS5cXG5cXFxuZmxvYXQgZ2V0RGlzdGFuY2UodmVjMiBwb3NpdGlvbilcXG5cXFxue1xcblxcXG4gICAgcmV0dXJuIHRleHR1cmUyRCh1X2F0bGFzLCBwb3NpdGlvbikucjtcXG5cXFxufVxcblxcXG5cXG5cXFxuLy8gU2FtcGxlcyB0aGUgc2RmIHRleHR1cmUgYXQgdGhlIGdpdmVuIHBvc2l0aW9uIGFuZCBwcm9kdWNlcyBhIGNvbG9yIGJhc2VkIG9uIHRoZSBmaWxsIGNvbG9yIGFuZCB0aGUgb3V0bGluZS5cXG5cXFxudmVjNCBnZXRTREZDb2xvcih2ZWMyIHBvc2l0aW9uLCBmbG9hdCBvdXRsaW5lV2lkdGgsIHZlYzQgb3V0bGluZUNvbG9yLCBmbG9hdCBzbW9vdGhpbmcpXFxuXFxcbntcXG5cXFxuICAgIGZsb2F0IGRpc3RhbmNlID0gZ2V0RGlzdGFuY2UocG9zaXRpb24pO1xcblxcXG5cXG5cXFxuICAgIGlmIChvdXRsaW5lV2lkdGggPiAwLjApXFxuXFxcbiAgICB7XFxuXFxcbiAgICAgICAgLy8gRG9uJ3QgZ2V0IHRoZSBvdXRsaW5lIGVkZ2UgZXhjZWVkIHRoZSBTREZfRURHRVxcblxcXG4gICAgICAgIGZsb2F0IG91dGxpbmVFZGdlID0gY2xhbXAoU0RGX0VER0UgLSBvdXRsaW5lV2lkdGgsIDAuMCwgU0RGX0VER0UpO1xcblxcXG4gICAgICAgIGZsb2F0IG91dGxpbmVGYWN0b3IgPSBzbW9vdGhzdGVwKFNERl9FREdFIC0gc21vb3RoaW5nLCBTREZfRURHRSArIHNtb290aGluZywgZGlzdGFuY2UpO1xcblxcXG4gICAgICAgIHZlYzQgc2RmQ29sb3IgPSBtaXgob3V0bGluZUNvbG9yLCB2X2NvbG9yLCBvdXRsaW5lRmFjdG9yKTtcXG5cXFxuICAgICAgICBmbG9hdCBhbHBoYSA9IHNtb290aHN0ZXAob3V0bGluZUVkZ2UgLSBzbW9vdGhpbmcsIG91dGxpbmVFZGdlICsgc21vb3RoaW5nLCBkaXN0YW5jZSk7XFxuXFxcbiAgICAgICAgcmV0dXJuIHZlYzQoc2RmQ29sb3IucmdiLCBzZGZDb2xvci5hICogYWxwaGEpO1xcblxcXG4gICAgfVxcblxcXG4gICAgZWxzZVxcblxcXG4gICAge1xcblxcXG4gICAgICAgIGZsb2F0IGFscGhhID0gc21vb3Roc3RlcChTREZfRURHRSAtIHNtb290aGluZywgU0RGX0VER0UgKyBzbW9vdGhpbmcsIGRpc3RhbmNlKTtcXG5cXFxuICAgICAgICByZXR1cm4gdmVjNCh2X2NvbG9yLnJnYiwgdl9jb2xvci5hICogYWxwaGEpO1xcblxcXG4gICAgfVxcblxcXG59XFxuXFxcbiNlbmRpZlxcblxcXG5cXG5cXFxudm9pZCBtYWluKClcXG5cXFxue1xcblxcXG4gICAgdmVjNCBjb2xvciA9IHRleHR1cmUyRCh1X2F0bGFzLCB2X3RleHR1cmVDb29yZGluYXRlcyk7XFxuXFxcblxcblxcXG4jaWZkZWYgU0RGXFxuXFxcbiAgICBmbG9hdCBvdXRsaW5lV2lkdGggPSB2X291dGxpbmVXaWR0aDtcXG5cXFxuICAgIHZlYzQgb3V0bGluZUNvbG9yID0gdl9vdXRsaW5lQ29sb3I7XFxuXFxcblxcblxcXG4gICAgLy8gR2V0IHRoZSBjdXJyZW50IGRpc3RhbmNlXFxuXFxcbiAgICBmbG9hdCBkaXN0YW5jZSA9IGdldERpc3RhbmNlKHZfdGV4dHVyZUNvb3JkaW5hdGVzKTtcXG5cXFxuXFxuXFxcbiNpZmRlZiBHTF9PRVNfc3RhbmRhcmRfZGVyaXZhdGl2ZXNcXG5cXFxuICAgIGZsb2F0IHNtb290aGluZyA9IGZ3aWR0aChkaXN0YW5jZSk7XFxuXFxcbiAgICAvLyBHZXQgYW4gb2Zmc2V0IHRoYXQgaXMgYXBwcm94aW1hdGVseSBoYWxmIHRoZSBkaXN0YW5jZSB0byB0aGUgbmVpZ2hib3IgcGl4ZWxzXFxuXFxcbiAgICAvLyAwLjM1NCBpcyBhcHByb3hpbWF0ZWx5IGhhbGYgb2YgMS9zcXJ0KDIpXFxuXFxcbiAgICB2ZWMyIHNhbXBsZU9mZnNldCA9IDAuMzU0ICogdmVjMihkRmR4KHZfdGV4dHVyZUNvb3JkaW5hdGVzKSArIGRGZHkodl90ZXh0dXJlQ29vcmRpbmF0ZXMpKTtcXG5cXFxuXFxuXFxcbiAgICAvLyBTYW1wbGUgdGhlIGNlbnRlciBwb2ludFxcblxcXG4gICAgdmVjNCBjZW50ZXIgPSBnZXRTREZDb2xvcih2X3RleHR1cmVDb29yZGluYXRlcywgb3V0bGluZVdpZHRoLCBvdXRsaW5lQ29sb3IsIHNtb290aGluZyk7XFxuXFxcblxcblxcXG4gICAgLy8gU2FtcGxlIHRoZSA0IG5laWdoYm9yc1xcblxcXG4gICAgdmVjNCBjb2xvcjEgPSBnZXRTREZDb2xvcih2X3RleHR1cmVDb29yZGluYXRlcyArIHZlYzIoc2FtcGxlT2Zmc2V0LngsIHNhbXBsZU9mZnNldC55KSwgb3V0bGluZVdpZHRoLCBvdXRsaW5lQ29sb3IsIHNtb290aGluZyk7XFxuXFxcbiAgICB2ZWM0IGNvbG9yMiA9IGdldFNERkNvbG9yKHZfdGV4dHVyZUNvb3JkaW5hdGVzICsgdmVjMigtc2FtcGxlT2Zmc2V0LngsIHNhbXBsZU9mZnNldC55KSwgb3V0bGluZVdpZHRoLCBvdXRsaW5lQ29sb3IsIHNtb290aGluZyk7XFxuXFxcbiAgICB2ZWM0IGNvbG9yMyA9IGdldFNERkNvbG9yKHZfdGV4dHVyZUNvb3JkaW5hdGVzICsgdmVjMigtc2FtcGxlT2Zmc2V0LngsIC1zYW1wbGVPZmZzZXQueSksIG91dGxpbmVXaWR0aCwgb3V0bGluZUNvbG9yLCBzbW9vdGhpbmcpO1xcblxcXG4gICAgdmVjNCBjb2xvcjQgPSBnZXRTREZDb2xvcih2X3RleHR1cmVDb29yZGluYXRlcyArIHZlYzIoc2FtcGxlT2Zmc2V0LngsIC1zYW1wbGVPZmZzZXQueSksIG91dGxpbmVXaWR0aCwgb3V0bGluZUNvbG9yLCBzbW9vdGhpbmcpO1xcblxcXG5cXG5cXFxuICAgIC8vIEVxdWFsbHkgd2VpZ2h0IHRoZSBjZW50ZXIgc2FtcGxlIGFuZCB0aGUgNCBuZWlnaGJvcmluZyBzYW1wbGVzXFxuXFxcbiAgICBjb2xvciA9IChjZW50ZXIgKyBjb2xvcjEgKyBjb2xvcjIgKyBjb2xvcjMgKyBjb2xvcjQpLzUuMDtcXG5cXFxuI2Vsc2VcXG5cXFxuICAgIC8vIEp1c3QgZG8gYSBzaW5nbGUgc2FtcGxlXFxuXFxcbiAgICBmbG9hdCBzbW9vdGhpbmcgPSAxLjAvMzIuMDtcXG5cXFxuICAgIGNvbG9yID0gZ2V0U0RGQ29sb3Iodl90ZXh0dXJlQ29vcmRpbmF0ZXMsIG91dGxpbmVXaWR0aCwgb3V0bGluZUNvbG9yLCBzbW9vdGhpbmcpO1xcblxcXG4jZW5kaWZcXG5cXFxuXFxuXFxcbiAgICBjb2xvciA9IGN6bV9nYW1tYUNvcnJlY3QoY29sb3IpO1xcblxcXG4jZWxzZVxcblxcXG4gICAgY29sb3IgPSBjem1fZ2FtbWFDb3JyZWN0KGNvbG9yKTtcXG5cXFxuICAgIGNvbG9yICo9IGN6bV9nYW1tYUNvcnJlY3Qodl9jb2xvcik7XFxuXFxcbiNlbmRpZlxcblxcXG5cXG5cXFxuLy8gRnVsbHkgdHJhbnNwYXJlbnQgcGFydHMgb2YgdGhlIGJpbGxib2FyZCBhcmUgbm90IHBpY2thYmxlLlxcblxcXG4jaWYgIWRlZmluZWQoT1BBUVVFKSAmJiAhZGVmaW5lZChUUkFOU0xVQ0VOVClcXG5cXFxuICAgIGlmIChjb2xvci5hIDwgMC4wMDUpICAgLy8gbWF0Y2hlcyAwLzI1NSBhbmQgMS8yNTVcXG5cXFxuICAgIHtcXG5cXFxuICAgICAgICBkaXNjYXJkO1xcblxcXG4gICAgfVxcblxcXG4jZWxzZVxcblxcXG4vLyBUaGUgYmlsbGJvYXJkIGlzIHJlbmRlcmVkIHR3aWNlLiBUaGUgb3BhcXVlIHBhc3MgZGlzY2FyZHMgdHJhbnNsdWNlbnQgZnJhZ21lbnRzXFxuXFxcbi8vIGFuZCB0aGUgdHJhbnNsdWNlbnQgcGFzcyBkaXNjYXJkcyBvcGFxdWUgZnJhZ21lbnRzLlxcblxcXG4jaWZkZWYgT1BBUVVFXFxuXFxcbiAgICBpZiAoY29sb3IuYSA8IDAuOTk1KSAgIC8vIG1hdGNoZXMgPCAyNTQvMjU1XFxuXFxcbiAgICB7XFxuXFxcbiAgICAgICAgZGlzY2FyZDtcXG5cXFxuICAgIH1cXG5cXFxuI2Vsc2VcXG5cXFxuICAgIGlmIChjb2xvci5hID49IDAuOTk1KSAgLy8gbWF0Y2hlcyAyNTQvMjU1IGFuZCAyNTUvMjU1XFxuXFxcbiAgICB7XFxuXFxcbiAgICAgICAgZGlzY2FyZDtcXG5cXFxuICAgIH1cXG5cXFxuI2VuZGlmXFxuXFxcbiNlbmRpZlxcblxcXG5cXG5cXFxuI2lmZGVmIFZFQ1RPUl9USUxFXFxuXFxcbiAgICBjb2xvciAqPSB1X2hpZ2hsaWdodENvbG9yO1xcblxcXG4jZW5kaWZcXG5cXFxuICAgIGdsX0ZyYWdDb2xvciA9IGNvbG9yO1xcblxcXG5cXG5cXFxuI2lmZGVmIExPR19ERVBUSFxcblxcXG4gICAgY3ptX3dyaXRlTG9nRGVwdGgoKTtcXG5cXFxuI2VuZGlmXFxuXFxcblxcblxcXG4jaWZkZWYgRlJBR01FTlRfREVQVEhfQ0hFQ0tcXG5cXFxuICAgIGZsb2F0IHRlbXAgPSB2X2NvbXByZXNzZWQueTtcXG5cXFxuXFxuXFxcbiAgICB0ZW1wID0gdGVtcCAqIFNISUZUX1JJR0hUMTtcXG5cXFxuXFxuXFxcbiAgICBmbG9hdCB0ZW1wMiA9ICh0ZW1wIC0gZmxvb3IodGVtcCkpICogU0hJRlRfTEVGVDE7XFxuXFxcbiAgICBib29sIGVuYWJsZURlcHRoVGVzdCA9IHRlbXAyICE9IDAuMDtcXG5cXFxuICAgIGJvb2wgYXBwbHlUcmFuc2xhdGUgPSBmbG9vcih0ZW1wKSAhPSAwLjA7XFxuXFxcblxcblxcXG4gICAgaWYgKGVuYWJsZURlcHRoVGVzdCkge1xcblxcXG4gICAgICAgIHRlbXAgPSB2X2NvbXByZXNzZWQuejtcXG5cXFxuICAgICAgICB0ZW1wID0gdGVtcCAqIFNISUZUX1JJR0hUMTI7XFxuXFxcblxcblxcXG4gICAgICAgIHZlYzIgZGltZW5zaW9ucztcXG5cXFxuICAgICAgICBkaW1lbnNpb25zLnkgPSAodGVtcCAtIGZsb29yKHRlbXApKSAqIFNISUZUX0xFRlQxMjtcXG5cXFxuICAgICAgICBkaW1lbnNpb25zLnggPSBmbG9vcih0ZW1wKTtcXG5cXFxuXFxuXFxcbiAgICAgICAgdGVtcCA9IHZfY29tcHJlc3NlZC53O1xcblxcXG4gICAgICAgIHRlbXAgPSB0ZW1wICogU0hJRlRfUklHSFQxMjtcXG5cXFxuXFxuXFxcbiAgICAgICAgdmVjMiBpbWFnZVNpemU7XFxuXFxcbiAgICAgICAgaW1hZ2VTaXplLnkgPSAodGVtcCAtIGZsb29yKHRlbXApKSAqIFNISUZUX0xFRlQxMjtcXG5cXFxuICAgICAgICBpbWFnZVNpemUueCA9IGZsb29yKHRlbXApO1xcblxcXG5cXG5cXFxuICAgICAgICB2ZWMyIGFkanVzdGVkU1QgPSB2X3RleHR1cmVDb29yZGluYXRlcyAtIHZfdGV4dHVyZUNvb3JkaW5hdGVCb3VuZHMueHk7XFxuXFxcbiAgICAgICAgYWRqdXN0ZWRTVCA9IGFkanVzdGVkU1QgLyB2ZWMyKHZfdGV4dHVyZUNvb3JkaW5hdGVCb3VuZHMueiAtIHZfdGV4dHVyZUNvb3JkaW5hdGVCb3VuZHMueCwgdl90ZXh0dXJlQ29vcmRpbmF0ZUJvdW5kcy53IC0gdl90ZXh0dXJlQ29vcmRpbmF0ZUJvdW5kcy55KTtcXG5cXFxuXFxuXFxcbiAgICAgICAgZmxvYXQgZXBzaWxvbkV5ZURlcHRoID0gdl9jb21wcmVzc2VkLnggKyBjem1fZXBzaWxvbjE7XFxuXFxcbiAgICAgICAgZmxvYXQgZ2xvYmVEZXB0aDEgPSBnZXRHbG9iZURlcHRoKGFkanVzdGVkU1QsIHZfb3JpZ2luVGV4dHVyZUNvb3JkaW5hdGVBbmRUcmFuc2xhdGUueHksIGFwcGx5VHJhbnNsYXRlLCBkaW1lbnNpb25zLCBpbWFnZVNpemUpO1xcblxcXG5cXG5cXFxuICAgICAgICAvLyBuZWdhdGl2ZSB2YWx1ZXMgZ28gaW50byB0aGUgc2NyZWVuXFxuXFxcbiAgICAgICAgaWYgKGdsb2JlRGVwdGgxICE9IDAuMCAmJiBnbG9iZURlcHRoMSA+IGVwc2lsb25FeWVEZXB0aClcXG5cXFxuICAgICAgICB7XFxuXFxcbiAgICAgICAgICAgIGZsb2F0IGdsb2JlRGVwdGgyID0gZ2V0R2xvYmVEZXB0aChhZGp1c3RlZFNULCB2ZWMyKDAuMCwgMS4wKSwgYXBwbHlUcmFuc2xhdGUsIGRpbWVuc2lvbnMsIGltYWdlU2l6ZSk7IC8vIHRvcCBsZWZ0IGNvcm5lclxcblxcXG4gICAgICAgICAgICBpZiAoZ2xvYmVEZXB0aDIgIT0gMC4wICYmIGdsb2JlRGVwdGgyID4gZXBzaWxvbkV5ZURlcHRoKVxcblxcXG4gICAgICAgICAgICB7XFxuXFxcbiAgICAgICAgICAgICAgICBmbG9hdCBnbG9iZURlcHRoMyA9IGdldEdsb2JlRGVwdGgoYWRqdXN0ZWRTVCwgdmVjMigxLjAsIDEuMCksIGFwcGx5VHJhbnNsYXRlLCBkaW1lbnNpb25zLCBpbWFnZVNpemUpOyAvLyB0b3AgcmlnaHQgY29ybmVyXFxuXFxcbiAgICAgICAgICAgICAgICBpZiAoZ2xvYmVEZXB0aDMgIT0gMC4wICYmIGdsb2JlRGVwdGgzID4gZXBzaWxvbkV5ZURlcHRoKVxcblxcXG4gICAgICAgICAgICAgICAge1xcblxcXG4gICAgICAgICAgICAgICAgICAgIGRpc2NhcmQ7XFxuXFxcbiAgICAgICAgICAgICAgICB9XFxuXFxcbiAgICAgICAgICAgIH1cXG5cXFxuICAgICAgICB9XFxuXFxcbiAgICB9XFxuXFxcbiNlbmRpZlxcblxcXG5cXG5cXFxufVxcblxcXG5cIjtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///39111\n')},64059:function(__unused_webpack___webpack_module__,__webpack_exports__){eval('//This file is automatically rebuilt by the Cesium build process.\n/* harmony default export */ __webpack_exports__["Z"] = ("#ifdef INSTANCED\\n\\\nattribute vec2 direction;\\n\\\n#endif\\n\\\nattribute vec4 positionHighAndScale;\\n\\\nattribute vec4 positionLowAndRotation;\\n\\\nattribute vec4 compressedAttribute0;                       // pixel offset, translate, horizontal origin, vertical origin, show, direction, texture coordinates (texture offset)\\n\\\nattribute vec4 compressedAttribute1;                       // aligned axis, translucency by distance, image width\\n\\\nattribute vec4 compressedAttribute2;                       // label horizontal origin, image height, color, pick color, size in meters, valid aligned axis, 13 bits free\\n\\\nattribute vec4 eyeOffset;                                  // eye offset in meters, 4 bytes free (texture range)\\n\\\nattribute vec4 scaleByDistance;                            // near, nearScale, far, farScale\\n\\\nattribute vec4 pixelOffsetScaleByDistance;                 // near, nearScale, far, farScale\\n\\\nattribute vec4 compressedAttribute3;                       // distance display condition near, far, disableDepthTestDistance, dimensions\\n\\\nattribute vec2 sdf;                                        // sdf outline color (rgb) and width (w)\\n\\\n#if defined(VERTEX_DEPTH_CHECK) || defined(FRAGMENT_DEPTH_CHECK)\\n\\\nattribute vec4 textureCoordinateBoundsOrLabelTranslate;    // the min and max x and y values for the texture coordinates\\n\\\n#endif\\n\\\n#ifdef VECTOR_TILE\\n\\\nattribute float a_batchId;\\n\\\n#endif\\n\\\n\\n\\\nvarying vec2 v_textureCoordinates;\\n\\\n#ifdef FRAGMENT_DEPTH_CHECK\\n\\\nvarying vec4 v_textureCoordinateBounds;\\n\\\nvarying vec4 v_originTextureCoordinateAndTranslate;\\n\\\nvarying vec4 v_compressed;                                 // x: eyeDepth, y: applyTranslate & enableDepthCheck, z: dimensions, w: imageSize\\n\\\nvarying mat2 v_rotationMatrix;\\n\\\n#endif\\n\\\n\\n\\\nvarying vec4 v_pickColor;\\n\\\nvarying vec4 v_color;\\n\\\n#ifdef SDF\\n\\\nvarying vec4 v_outlineColor;\\n\\\nvarying float v_outlineWidth;\\n\\\n#endif\\n\\\n\\n\\\nconst float UPPER_BOUND = 32768.0;\\n\\\n\\n\\\nconst float SHIFT_LEFT16 = 65536.0;\\n\\\nconst float SHIFT_LEFT12 = 4096.0;\\n\\\nconst float SHIFT_LEFT8 = 256.0;\\n\\\nconst float SHIFT_LEFT7 = 128.0;\\n\\\nconst float SHIFT_LEFT5 = 32.0;\\n\\\nconst float SHIFT_LEFT3 = 8.0;\\n\\\nconst float SHIFT_LEFT2 = 4.0;\\n\\\nconst float SHIFT_LEFT1 = 2.0;\\n\\\n\\n\\\nconst float SHIFT_RIGHT12 = 1.0 / 4096.0;\\n\\\nconst float SHIFT_RIGHT8 = 1.0 / 256.0;\\n\\\nconst float SHIFT_RIGHT7 = 1.0 / 128.0;\\n\\\nconst float SHIFT_RIGHT5 = 1.0 / 32.0;\\n\\\nconst float SHIFT_RIGHT3 = 1.0 / 8.0;\\n\\\nconst float SHIFT_RIGHT2 = 1.0 / 4.0;\\n\\\nconst float SHIFT_RIGHT1 = 1.0 / 2.0;\\n\\\n\\n\\\nvec4 addScreenSpaceOffset(vec4 positionEC, vec2 imageSize, float scale, vec2 direction, vec2 origin, vec2 translate, vec2 pixelOffset, vec3 alignedAxis, bool validAlignedAxis, float rotation, bool sizeInMeters, out mat2 rotationMatrix, out float mpp)\\n\\\n{\\n\\\n    // Note the halfSize cannot be computed in JavaScript because it is sent via\\n\\\n    // compressed vertex attributes that coerce it to an integer.\\n\\\n    vec2 halfSize = imageSize * scale * 0.5;\\n\\\n    halfSize *= ((direction * 2.0) - 1.0);\\n\\\n\\n\\\n    vec2 originTranslate = origin * abs(halfSize);\\n\\\n\\n\\\n#if defined(ROTATION) || defined(ALIGNED_AXIS)\\n\\\n    if (validAlignedAxis || rotation != 0.0)\\n\\\n    {\\n\\\n        float angle = rotation;\\n\\\n        if (validAlignedAxis)\\n\\\n        {\\n\\\n            vec4 projectedAlignedAxis = czm_modelViewProjection * vec4(alignedAxis, 0.0);\\n\\\n            angle += sign(-projectedAlignedAxis.x) * acos(sign(projectedAlignedAxis.y) * (projectedAlignedAxis.y * projectedAlignedAxis.y) /\\n\\\n                    (projectedAlignedAxis.x * projectedAlignedAxis.x + projectedAlignedAxis.y * projectedAlignedAxis.y));\\n\\\n        }\\n\\\n\\n\\\n        float cosTheta = cos(angle);\\n\\\n        float sinTheta = sin(angle);\\n\\\n        rotationMatrix = mat2(cosTheta, sinTheta, -sinTheta, cosTheta);\\n\\\n        halfSize = rotationMatrix * halfSize;\\n\\\n    }\\n\\\n    else\\n\\\n    {\\n\\\n        rotationMatrix = mat2(1.0, 0.0, 0.0, 1.0);\\n\\\n    }\\n\\\n#endif\\n\\\n\\n\\\n    mpp = czm_metersPerPixel(positionEC);\\n\\\n    positionEC.xy += (originTranslate + halfSize) * czm_branchFreeTernary(sizeInMeters, 1.0, mpp);\\n\\\n    positionEC.xy += (translate + pixelOffset) * mpp;\\n\\\n\\n\\\n    return positionEC;\\n\\\n}\\n\\\n\\n\\\n#ifdef VERTEX_DEPTH_CHECK\\n\\\nfloat getGlobeDepth(vec4 positionEC)\\n\\\n{\\n\\\n    vec4 posWC = czm_eyeToWindowCoordinates(positionEC);\\n\\\n\\n\\\n    float globeDepth = czm_unpackDepth(texture2D(czm_globeDepthTexture, posWC.xy / czm_viewport.zw));\\n\\\n\\n\\\n    if (globeDepth == 0.0)\\n\\\n    {\\n\\\n        return 0.0; // not on the globe\\n\\\n    }\\n\\\n\\n\\\n    vec4 eyeCoordinate = czm_windowToEyeCoordinates(posWC.xy, globeDepth);\\n\\\n    return eyeCoordinate.z / eyeCoordinate.w;\\n\\\n}\\n\\\n#endif\\n\\\nvoid main()\\n\\\n{\\n\\\n    // Modifying this shader may also require modifications to Billboard._computeScreenSpacePosition\\n\\\n\\n\\\n    // unpack attributes\\n\\\n    vec3 positionHigh = positionHighAndScale.xyz;\\n\\\n    vec3 positionLow = positionLowAndRotation.xyz;\\n\\\n    float scale = positionHighAndScale.w;\\n\\\n\\n\\\n#if defined(ROTATION) || defined(ALIGNED_AXIS)\\n\\\n    float rotation = positionLowAndRotation.w;\\n\\\n#else\\n\\\n    float rotation = 0.0;\\n\\\n#endif\\n\\\n\\n\\\n    float compressed = compressedAttribute0.x;\\n\\\n\\n\\\n    vec2 pixelOffset;\\n\\\n    pixelOffset.x = floor(compressed * SHIFT_RIGHT7);\\n\\\n    compressed -= pixelOffset.x * SHIFT_LEFT7;\\n\\\n    pixelOffset.x -= UPPER_BOUND;\\n\\\n\\n\\\n    vec2 origin;\\n\\\n    origin.x = floor(compressed * SHIFT_RIGHT5);\\n\\\n    compressed -= origin.x * SHIFT_LEFT5;\\n\\\n\\n\\\n    origin.y = floor(compressed * SHIFT_RIGHT3);\\n\\\n    compressed -= origin.y * SHIFT_LEFT3;\\n\\\n\\n\\\n#ifdef FRAGMENT_DEPTH_CHECK\\n\\\n    vec2 depthOrigin = origin.xy;\\n\\\n#endif\\n\\\n    origin -= vec2(1.0);\\n\\\n\\n\\\n    float show = floor(compressed * SHIFT_RIGHT2);\\n\\\n    compressed -= show * SHIFT_LEFT2;\\n\\\n\\n\\\n#ifdef INSTANCED\\n\\\n    vec2 textureCoordinatesBottomLeft = czm_decompressTextureCoordinates(compressedAttribute0.w);\\n\\\n    vec2 textureCoordinatesRange = czm_decompressTextureCoordinates(eyeOffset.w);\\n\\\n    vec2 textureCoordinates = textureCoordinatesBottomLeft + direction * textureCoordinatesRange;\\n\\\n#else\\n\\\n    vec2 direction;\\n\\\n    direction.x = floor(compressed * SHIFT_RIGHT1);\\n\\\n    direction.y = compressed - direction.x * SHIFT_LEFT1;\\n\\\n\\n\\\n    vec2 textureCoordinates = czm_decompressTextureCoordinates(compressedAttribute0.w);\\n\\\n#endif\\n\\\n\\n\\\n    float temp = compressedAttribute0.y  * SHIFT_RIGHT8;\\n\\\n    pixelOffset.y = -(floor(temp) - UPPER_BOUND);\\n\\\n\\n\\\n    vec2 translate;\\n\\\n    translate.y = (temp - floor(temp)) * SHIFT_LEFT16;\\n\\\n\\n\\\n    temp = compressedAttribute0.z * SHIFT_RIGHT8;\\n\\\n    translate.x = floor(temp) - UPPER_BOUND;\\n\\\n\\n\\\n    translate.y += (temp - floor(temp)) * SHIFT_LEFT8;\\n\\\n    translate.y -= UPPER_BOUND;\\n\\\n\\n\\\n    temp = compressedAttribute1.x * SHIFT_RIGHT8;\\n\\\n    float temp2 = floor(compressedAttribute2.w * SHIFT_RIGHT2);\\n\\\n\\n\\\n    vec2 imageSize = vec2(floor(temp), temp2);\\n\\\n\\n\\\n#ifdef FRAGMENT_DEPTH_CHECK\\n\\\n    float labelHorizontalOrigin = floor(compressedAttribute2.w - (temp2 * SHIFT_LEFT2));\\n\\\n    float applyTranslate = 0.0;\\n\\\n    if (labelHorizontalOrigin != 0.0) // is a billboard, so set apply translate to false\\n\\\n    {\\n\\\n        applyTranslate = 1.0;\\n\\\n        labelHorizontalOrigin -= 2.0;\\n\\\n        depthOrigin.x = labelHorizontalOrigin + 1.0;\\n\\\n    }\\n\\\n\\n\\\n    depthOrigin = vec2(1.0) - (depthOrigin * 0.5);\\n\\\n#endif\\n\\\n\\n\\\n#ifdef EYE_DISTANCE_TRANSLUCENCY\\n\\\n    vec4 translucencyByDistance;\\n\\\n    translucencyByDistance.x = compressedAttribute1.z;\\n\\\n    translucencyByDistance.z = compressedAttribute1.w;\\n\\\n\\n\\\n    translucencyByDistance.y = ((temp - floor(temp)) * SHIFT_LEFT8) / 255.0;\\n\\\n\\n\\\n    temp = compressedAttribute1.y * SHIFT_RIGHT8;\\n\\\n    translucencyByDistance.w = ((temp - floor(temp)) * SHIFT_LEFT8) / 255.0;\\n\\\n#endif\\n\\\n\\n\\\n#if defined(VERTEX_DEPTH_CHECK) || defined(FRAGMENT_DEPTH_CHECK)\\n\\\n    temp = compressedAttribute3.w;\\n\\\n    temp = temp * SHIFT_RIGHT12;\\n\\\n\\n\\\n    vec2 dimensions;\\n\\\n    dimensions.y = (temp - floor(temp)) * SHIFT_LEFT12;\\n\\\n    dimensions.x = floor(temp);\\n\\\n#endif\\n\\\n\\n\\\n#ifdef ALIGNED_AXIS\\n\\\n    vec3 alignedAxis = czm_octDecode(floor(compressedAttribute1.y * SHIFT_RIGHT8));\\n\\\n    temp = compressedAttribute2.z * SHIFT_RIGHT5;\\n\\\n    bool validAlignedAxis = (temp - floor(temp)) * SHIFT_LEFT1 > 0.0;\\n\\\n#else\\n\\\n    vec3 alignedAxis = vec3(0.0);\\n\\\n    bool validAlignedAxis = false;\\n\\\n#endif\\n\\\n\\n\\\n    vec4 pickColor;\\n\\\n    vec4 color;\\n\\\n\\n\\\n    temp = compressedAttribute2.y;\\n\\\n    temp = temp * SHIFT_RIGHT8;\\n\\\n    pickColor.b = (temp - floor(temp)) * SHIFT_LEFT8;\\n\\\n    temp = floor(temp) * SHIFT_RIGHT8;\\n\\\n    pickColor.g = (temp - floor(temp)) * SHIFT_LEFT8;\\n\\\n    pickColor.r = floor(temp);\\n\\\n\\n\\\n    temp = compressedAttribute2.x;\\n\\\n    temp = temp * SHIFT_RIGHT8;\\n\\\n    color.b = (temp - floor(temp)) * SHIFT_LEFT8;\\n\\\n    temp = floor(temp) * SHIFT_RIGHT8;\\n\\\n    color.g = (temp - floor(temp)) * SHIFT_LEFT8;\\n\\\n    color.r = floor(temp);\\n\\\n\\n\\\n    temp = compressedAttribute2.z * SHIFT_RIGHT8;\\n\\\n    bool sizeInMeters = floor((temp - floor(temp)) * SHIFT_LEFT7) > 0.0;\\n\\\n    temp = floor(temp) * SHIFT_RIGHT8;\\n\\\n\\n\\\n    pickColor.a = (temp - floor(temp)) * SHIFT_LEFT8;\\n\\\n    pickColor /= 255.0;\\n\\\n\\n\\\n    color.a = floor(temp);\\n\\\n    color /= 255.0;\\n\\\n\\n\\\n    ///////////////////////////////////////////////////////////////////////////\\n\\\n\\n\\\n    vec4 p = czm_translateRelativeToEye(positionHigh, positionLow);\\n\\\n    vec4 positionEC = czm_modelViewRelativeToEye * p;\\n\\\n\\n\\\n#if defined(FRAGMENT_DEPTH_CHECK) || defined(VERTEX_DEPTH_CHECK)\\n\\\n    float eyeDepth = positionEC.z;\\n\\\n#endif\\n\\\n\\n\\\n    positionEC = czm_eyeOffset(positionEC, eyeOffset.xyz);\\n\\\n    positionEC.xyz *= show;\\n\\\n\\n\\\n    ///////////////////////////////////////////////////////////////////////////\\n\\\n\\n\\\n#if defined(EYE_DISTANCE_SCALING) || defined(EYE_DISTANCE_TRANSLUCENCY) || defined(EYE_DISTANCE_PIXEL_OFFSET) || defined(DISTANCE_DISPLAY_CONDITION) || defined(DISABLE_DEPTH_DISTANCE)\\n\\\n    float lengthSq;\\n\\\n    if (czm_sceneMode == czm_sceneMode2D)\\n\\\n    {\\n\\\n        // 2D camera distance is a special case\\n\\\n        // treat all billboards as flattened to the z=0.0 plane\\n\\\n        lengthSq = czm_eyeHeight2D.y;\\n\\\n    }\\n\\\n    else\\n\\\n    {\\n\\\n        lengthSq = dot(positionEC.xyz, positionEC.xyz);\\n\\\n    }\\n\\\n#endif\\n\\\n\\n\\\n#ifdef EYE_DISTANCE_SCALING\\n\\\n    float distanceScale = czm_nearFarScalar(scaleByDistance, lengthSq);\\n\\\n    scale *= distanceScale;\\n\\\n    translate *= distanceScale;\\n\\\n    // push vertex behind near plane for clipping\\n\\\n    if (scale == 0.0)\\n\\\n    {\\n\\\n        positionEC.xyz = vec3(0.0);\\n\\\n    }\\n\\\n#endif\\n\\\n\\n\\\n    float translucency = 1.0;\\n\\\n#ifdef EYE_DISTANCE_TRANSLUCENCY\\n\\\n    translucency = czm_nearFarScalar(translucencyByDistance, lengthSq);\\n\\\n    // push vertex behind near plane for clipping\\n\\\n    if (translucency == 0.0)\\n\\\n    {\\n\\\n        positionEC.xyz = vec3(0.0);\\n\\\n    }\\n\\\n#endif\\n\\\n\\n\\\n#ifdef EYE_DISTANCE_PIXEL_OFFSET\\n\\\n    float pixelOffsetScale = czm_nearFarScalar(pixelOffsetScaleByDistance, lengthSq);\\n\\\n    pixelOffset *= pixelOffsetScale;\\n\\\n#endif\\n\\\n\\n\\\n#ifdef DISTANCE_DISPLAY_CONDITION\\n\\\n    float nearSq = compressedAttribute3.x;\\n\\\n    float farSq = compressedAttribute3.y;\\n\\\n    if (lengthSq < nearSq || lengthSq > farSq)\\n\\\n    {\\n\\\n        positionEC.xyz = vec3(0.0);\\n\\\n    }\\n\\\n#endif\\n\\\n\\n\\\n    mat2 rotationMatrix;\\n\\\n    float mpp;\\n\\\n\\n\\\n#ifdef DISABLE_DEPTH_DISTANCE\\n\\\n    float disableDepthTestDistance = compressedAttribute3.z;\\n\\\n#endif\\n\\\n\\n\\\n#ifdef VERTEX_DEPTH_CHECK\\n\\\nif (lengthSq < disableDepthTestDistance) {\\n\\\n    float depthsilon = 10.0;\\n\\\n\\n\\\n    vec2 labelTranslate = textureCoordinateBoundsOrLabelTranslate.xy;\\n\\\n    vec4 pEC1 = addScreenSpaceOffset(positionEC, dimensions, scale, vec2(0.0), origin, labelTranslate, pixelOffset, alignedAxis, validAlignedAxis, rotation, sizeInMeters, rotationMatrix, mpp);\\n\\\n    float globeDepth1 = getGlobeDepth(pEC1);\\n\\\n\\n\\\n    if (globeDepth1 != 0.0 && pEC1.z + depthsilon < globeDepth1)\\n\\\n    {\\n\\\n        vec4 pEC2 = addScreenSpaceOffset(positionEC, dimensions, scale, vec2(0.0, 1.0), origin, labelTranslate, pixelOffset, alignedAxis, validAlignedAxis, rotation, sizeInMeters, rotationMatrix, mpp);\\n\\\n        float globeDepth2 = getGlobeDepth(pEC2);\\n\\\n\\n\\\n        if (globeDepth2 != 0.0 && pEC2.z + depthsilon < globeDepth2)\\n\\\n        {\\n\\\n            vec4 pEC3 = addScreenSpaceOffset(positionEC, dimensions, scale, vec2(1.0), origin, labelTranslate, pixelOffset, alignedAxis, validAlignedAxis, rotation, sizeInMeters, rotationMatrix, mpp);\\n\\\n            float globeDepth3 = getGlobeDepth(pEC3);\\n\\\n            if (globeDepth3 != 0.0 && pEC3.z + depthsilon < globeDepth3)\\n\\\n            {\\n\\\n                positionEC.xyz = vec3(0.0);\\n\\\n            }\\n\\\n        }\\n\\\n    }\\n\\\n}\\n\\\n#endif\\n\\\n\\n\\\n    positionEC = addScreenSpaceOffset(positionEC, imageSize, scale, direction, origin, translate, pixelOffset, alignedAxis, validAlignedAxis, rotation, sizeInMeters, rotationMatrix, mpp);\\n\\\n    gl_Position = czm_projection * positionEC;\\n\\\n    v_textureCoordinates = textureCoordinates;\\n\\\n\\n\\\n#ifdef LOG_DEPTH\\n\\\n    czm_vertexLogDepth();\\n\\\n#endif\\n\\\n\\n\\\n#ifdef DISABLE_DEPTH_DISTANCE\\n\\\n    if (disableDepthTestDistance == 0.0 && czm_minimumDisableDepthTestDistance != 0.0)\\n\\\n    {\\n\\\n        disableDepthTestDistance = czm_minimumDisableDepthTestDistance;\\n\\\n    }\\n\\\n\\n\\\n    if (disableDepthTestDistance != 0.0)\\n\\\n    {\\n\\\n        // Don\'t try to \\"multiply both sides\\" by w.  Greater/less-than comparisons won\'t work for negative values of w.\\n\\\n        float zclip = gl_Position.z / gl_Position.w;\\n\\\n        bool clipped = (zclip < -1.0 || zclip > 1.0);\\n\\\n        if (!clipped && (disableDepthTestDistance < 0.0 || (lengthSq > 0.0 && lengthSq < disableDepthTestDistance)))\\n\\\n        {\\n\\\n            // Position z on the near plane.\\n\\\n            gl_Position.z = -gl_Position.w;\\n\\\n#ifdef LOG_DEPTH\\n\\\n            v_depthFromNearPlusOne = 1.0;\\n\\\n#endif\\n\\\n        }\\n\\\n    }\\n\\\n#endif\\n\\\n\\n\\\n#ifdef FRAGMENT_DEPTH_CHECK\\n\\\n    if (sizeInMeters) {\\n\\\n        translate /= mpp;\\n\\\n        dimensions /= mpp;\\n\\\n        imageSize /= mpp;\\n\\\n    }\\n\\\n\\n\\\n#if defined(ROTATION) || defined(ALIGNED_AXIS)\\n\\\n    v_rotationMatrix = rotationMatrix;\\n\\\n#else\\n\\\n    v_rotationMatrix = mat2(1.0, 0.0, 0.0, 1.0);\\n\\\n#endif\\n\\\n\\n\\\n    float enableDepthCheck = 0.0;\\n\\\n    if (lengthSq < disableDepthTestDistance)\\n\\\n    {\\n\\\n        enableDepthCheck = 1.0;\\n\\\n    }\\n\\\n\\n\\\n    float dw = floor(clamp(dimensions.x, 0.0, SHIFT_LEFT12));\\n\\\n    float dh = floor(clamp(dimensions.y, 0.0, SHIFT_LEFT12));\\n\\\n\\n\\\n    float iw = floor(clamp(imageSize.x, 0.0, SHIFT_LEFT12));\\n\\\n    float ih = floor(clamp(imageSize.y, 0.0, SHIFT_LEFT12));\\n\\\n\\n\\\n    v_compressed.x = eyeDepth;\\n\\\n    v_compressed.y = applyTranslate * SHIFT_LEFT1 + enableDepthCheck;\\n\\\n    v_compressed.z = dw * SHIFT_LEFT12 + dh;\\n\\\n    v_compressed.w = iw * SHIFT_LEFT12 + ih;\\n\\\n    v_originTextureCoordinateAndTranslate.xy = depthOrigin;\\n\\\n    v_originTextureCoordinateAndTranslate.zw = translate;\\n\\\n    v_textureCoordinateBounds = textureCoordinateBoundsOrLabelTranslate;\\n\\\n\\n\\\n#endif\\n\\\n\\n\\\n#ifdef SDF\\n\\\n    vec4 outlineColor;\\n\\\n    float outlineWidth;\\n\\\n\\n\\\n    temp = sdf.x;\\n\\\n    temp = temp * SHIFT_RIGHT8;\\n\\\n    outlineColor.b = (temp - floor(temp)) * SHIFT_LEFT8;\\n\\\n    temp = floor(temp) * SHIFT_RIGHT8;\\n\\\n    outlineColor.g = (temp - floor(temp)) * SHIFT_LEFT8;\\n\\\n    outlineColor.r = floor(temp);\\n\\\n\\n\\\n    temp = sdf.y;\\n\\\n    temp = temp * SHIFT_RIGHT8;\\n\\\n    float temp3 = (temp - floor(temp)) * SHIFT_LEFT8;\\n\\\n    temp = floor(temp) * SHIFT_RIGHT8;\\n\\\n    outlineWidth = (temp - floor(temp)) * SHIFT_LEFT8;\\n\\\n    outlineColor.a = floor(temp);\\n\\\n    outlineColor /= 255.0;\\n\\\n\\n\\\n    v_outlineWidth = outlineWidth / 255.0;\\n\\\n    v_outlineColor = outlineColor;\\n\\\n    v_outlineColor.a *= translucency;\\n\\\n#endif\\n\\\n\\n\\\n    v_pickColor = pickColor;\\n\\\n\\n\\\n    v_color = color;\\n\\\n    v_color.a *= translucency;\\n\\\n\\n\\\n}\\n\\\n");\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QUFDQSxzQ0FBc0M7QUFDdEM7QUFDQSxnREFBZ0Q7QUFDaEQ7QUFDQTtBQUNBLGlDQUFpQztBQUNqQztBQUNBLEtBQUs7QUFDTCwrQkFBK0I7QUFDL0IsS0FBSztBQUNMO0FBQ0EsNkRBQTZEO0FBQzdELDZEQUE2RDtBQUM3RDtBQUNBLDREQUE0RDtBQUM1RCw0REFBNEQ7QUFDNUQ7QUFDQSw4QkFBOEI7QUFDOUIscUVBQXFFO0FBQ3JFLDRDQUE0QztBQUM1Qyw0Q0FBNEM7QUFDNUMsMkRBQTJEO0FBQzNELHlEQUF5RDtBQUN6RCx3RUFBd0U7QUFDeEU7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEIsdUJBQXVCO0FBQ3ZCO0FBQ0EsaUJBQWlCO0FBQ2pCLCtCQUErQjtBQUMvQix3REFBd0Q7QUFDeEQsc0NBQXNDO0FBQ3RDLHdEQUF3RDtBQUN4RCxpQ0FBaUM7QUFDakM7QUFDQSxpQkFBaUI7QUFDakIsK0JBQStCO0FBQy9CLHFEQUFxRDtBQUNyRCxzQ0FBc0M7QUFDdEMsc0RBQXNEO0FBQ3RELGlDQUFpQztBQUNqQywwQkFBMEI7QUFDMUI7QUFDQSwwQ0FBMEM7QUFDMUMsa0NBQWtDO0FBQ2xDLHFDQUFxQztBQUNyQztBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0Esb0JBQW9CO0FBQ3BCLDhCQUE4QjtBQUM5QjtBQUNBLENBQUM7QUFDRCxDQUFDLEVBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly92dWUzLXdlYnBhY2s1Ly4vbm9kZV9tb2R1bGVzL2Nlc2l1bS9Tb3VyY2UvU2hhZGVycy9CaWxsYm9hcmRDb2xsZWN0aW9uVlMuanM/ZmFiZCJdLCJzb3VyY2VzQ29udGVudCI6WyIvL1RoaXMgZmlsZSBpcyBhdXRvbWF0aWNhbGx5IHJlYnVpbHQgYnkgdGhlIENlc2l1bSBidWlsZCBwcm9jZXNzLlxuZXhwb3J0IGRlZmF1bHQgXCIjaWZkZWYgSU5TVEFOQ0VEXFxuXFxcbmF0dHJpYnV0ZSB2ZWMyIGRpcmVjdGlvbjtcXG5cXFxuI2VuZGlmXFxuXFxcbmF0dHJpYnV0ZSB2ZWM0IHBvc2l0aW9uSGlnaEFuZFNjYWxlO1xcblxcXG5hdHRyaWJ1dGUgdmVjNCBwb3NpdGlvbkxvd0FuZFJvdGF0aW9uO1xcblxcXG5hdHRyaWJ1dGUgdmVjNCBjb21wcmVzc2VkQXR0cmlidXRlMDsgICAgICAgICAgICAgICAgICAgICAgIC8vIHBpeGVsIG9mZnNldCwgdHJhbnNsYXRlLCBob3Jpem9udGFsIG9yaWdpbiwgdmVydGljYWwgb3JpZ2luLCBzaG93LCBkaXJlY3Rpb24sIHRleHR1cmUgY29vcmRpbmF0ZXMgKHRleHR1cmUgb2Zmc2V0KVxcblxcXG5hdHRyaWJ1dGUgdmVjNCBjb21wcmVzc2VkQXR0cmlidXRlMTsgICAgICAgICAgICAgICAgICAgICAgIC8vIGFsaWduZWQgYXhpcywgdHJhbnNsdWNlbmN5IGJ5IGRpc3RhbmNlLCBpbWFnZSB3aWR0aFxcblxcXG5hdHRyaWJ1dGUgdmVjNCBjb21wcmVzc2VkQXR0cmlidXRlMjsgICAgICAgICAgICAgICAgICAgICAgIC8vIGxhYmVsIGhvcml6b250YWwgb3JpZ2luLCBpbWFnZSBoZWlnaHQsIGNvbG9yLCBwaWNrIGNvbG9yLCBzaXplIGluIG1ldGVycywgdmFsaWQgYWxpZ25lZCBheGlzLCAxMyBiaXRzIGZyZWVcXG5cXFxuYXR0cmlidXRlIHZlYzQgZXllT2Zmc2V0OyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBleWUgb2Zmc2V0IGluIG1ldGVycywgNCBieXRlcyBmcmVlICh0ZXh0dXJlIHJhbmdlKVxcblxcXG5hdHRyaWJ1dGUgdmVjNCBzY2FsZUJ5RGlzdGFuY2U7ICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIG5lYXIsIG5lYXJTY2FsZSwgZmFyLCBmYXJTY2FsZVxcblxcXG5hdHRyaWJ1dGUgdmVjNCBwaXhlbE9mZnNldFNjYWxlQnlEaXN0YW5jZTsgICAgICAgICAgICAgICAgIC8vIG5lYXIsIG5lYXJTY2FsZSwgZmFyLCBmYXJTY2FsZVxcblxcXG5hdHRyaWJ1dGUgdmVjNCBjb21wcmVzc2VkQXR0cmlidXRlMzsgICAgICAgICAgICAgICAgICAgICAgIC8vIGRpc3RhbmNlIGRpc3BsYXkgY29uZGl0aW9uIG5lYXIsIGZhciwgZGlzYWJsZURlcHRoVGVzdERpc3RhbmNlLCBkaW1lbnNpb25zXFxuXFxcbmF0dHJpYnV0ZSB2ZWMyIHNkZjsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gc2RmIG91dGxpbmUgY29sb3IgKHJnYikgYW5kIHdpZHRoICh3KVxcblxcXG4jaWYgZGVmaW5lZChWRVJURVhfREVQVEhfQ0hFQ0spIHx8IGRlZmluZWQoRlJBR01FTlRfREVQVEhfQ0hFQ0spXFxuXFxcbmF0dHJpYnV0ZSB2ZWM0IHRleHR1cmVDb29yZGluYXRlQm91bmRzT3JMYWJlbFRyYW5zbGF0ZTsgICAgLy8gdGhlIG1pbiBhbmQgbWF4IHggYW5kIHkgdmFsdWVzIGZvciB0aGUgdGV4dHVyZSBjb29yZGluYXRlc1xcblxcXG4jZW5kaWZcXG5cXFxuI2lmZGVmIFZFQ1RPUl9USUxFXFxuXFxcbmF0dHJpYnV0ZSBmbG9hdCBhX2JhdGNoSWQ7XFxuXFxcbiNlbmRpZlxcblxcXG5cXG5cXFxudmFyeWluZyB2ZWMyIHZfdGV4dHVyZUNvb3JkaW5hdGVzO1xcblxcXG4jaWZkZWYgRlJBR01FTlRfREVQVEhfQ0hFQ0tcXG5cXFxudmFyeWluZyB2ZWM0IHZfdGV4dHVyZUNvb3JkaW5hdGVCb3VuZHM7XFxuXFxcbnZhcnlpbmcgdmVjNCB2X29yaWdpblRleHR1cmVDb29yZGluYXRlQW5kVHJhbnNsYXRlO1xcblxcXG52YXJ5aW5nIHZlYzQgdl9jb21wcmVzc2VkOyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHg6IGV5ZURlcHRoLCB5OiBhcHBseVRyYW5zbGF0ZSAmIGVuYWJsZURlcHRoQ2hlY2ssIHo6IGRpbWVuc2lvbnMsIHc6IGltYWdlU2l6ZVxcblxcXG52YXJ5aW5nIG1hdDIgdl9yb3RhdGlvbk1hdHJpeDtcXG5cXFxuI2VuZGlmXFxuXFxcblxcblxcXG52YXJ5aW5nIHZlYzQgdl9waWNrQ29sb3I7XFxuXFxcbnZhcnlpbmcgdmVjNCB2X2NvbG9yO1xcblxcXG4jaWZkZWYgU0RGXFxuXFxcbnZhcnlpbmcgdmVjNCB2X291dGxpbmVDb2xvcjtcXG5cXFxudmFyeWluZyBmbG9hdCB2X291dGxpbmVXaWR0aDtcXG5cXFxuI2VuZGlmXFxuXFxcblxcblxcXG5jb25zdCBmbG9hdCBVUFBFUl9CT1VORCA9IDMyNzY4LjA7XFxuXFxcblxcblxcXG5jb25zdCBmbG9hdCBTSElGVF9MRUZUMTYgPSA2NTUzNi4wO1xcblxcXG5jb25zdCBmbG9hdCBTSElGVF9MRUZUMTIgPSA0MDk2LjA7XFxuXFxcbmNvbnN0IGZsb2F0IFNISUZUX0xFRlQ4ID0gMjU2LjA7XFxuXFxcbmNvbnN0IGZsb2F0IFNISUZUX0xFRlQ3ID0gMTI4LjA7XFxuXFxcbmNvbnN0IGZsb2F0IFNISUZUX0xFRlQ1ID0gMzIuMDtcXG5cXFxuY29uc3QgZmxvYXQgU0hJRlRfTEVGVDMgPSA4LjA7XFxuXFxcbmNvbnN0IGZsb2F0IFNISUZUX0xFRlQyID0gNC4wO1xcblxcXG5jb25zdCBmbG9hdCBTSElGVF9MRUZUMSA9IDIuMDtcXG5cXFxuXFxuXFxcbmNvbnN0IGZsb2F0IFNISUZUX1JJR0hUMTIgPSAxLjAgLyA0MDk2LjA7XFxuXFxcbmNvbnN0IGZsb2F0IFNISUZUX1JJR0hUOCA9IDEuMCAvIDI1Ni4wO1xcblxcXG5jb25zdCBmbG9hdCBTSElGVF9SSUdIVDcgPSAxLjAgLyAxMjguMDtcXG5cXFxuY29uc3QgZmxvYXQgU0hJRlRfUklHSFQ1ID0gMS4wIC8gMzIuMDtcXG5cXFxuY29uc3QgZmxvYXQgU0hJRlRfUklHSFQzID0gMS4wIC8gOC4wO1xcblxcXG5jb25zdCBmbG9hdCBTSElGVF9SSUdIVDIgPSAxLjAgLyA0LjA7XFxuXFxcbmNvbnN0IGZsb2F0IFNISUZUX1JJR0hUMSA9IDEuMCAvIDIuMDtcXG5cXFxuXFxuXFxcbnZlYzQgYWRkU2NyZWVuU3BhY2VPZmZzZXQodmVjNCBwb3NpdGlvbkVDLCB2ZWMyIGltYWdlU2l6ZSwgZmxvYXQgc2NhbGUsIHZlYzIgZGlyZWN0aW9uLCB2ZWMyIG9yaWdpbiwgdmVjMiB0cmFuc2xhdGUsIHZlYzIgcGl4ZWxPZmZzZXQsIHZlYzMgYWxpZ25lZEF4aXMsIGJvb2wgdmFsaWRBbGlnbmVkQXhpcywgZmxvYXQgcm90YXRpb24sIGJvb2wgc2l6ZUluTWV0ZXJzLCBvdXQgbWF0MiByb3RhdGlvbk1hdHJpeCwgb3V0IGZsb2F0IG1wcClcXG5cXFxue1xcblxcXG4gICAgLy8gTm90ZSB0aGUgaGFsZlNpemUgY2Fubm90IGJlIGNvbXB1dGVkIGluIEphdmFTY3JpcHQgYmVjYXVzZSBpdCBpcyBzZW50IHZpYVxcblxcXG4gICAgLy8gY29tcHJlc3NlZCB2ZXJ0ZXggYXR0cmlidXRlcyB0aGF0IGNvZXJjZSBpdCB0byBhbiBpbnRlZ2VyLlxcblxcXG4gICAgdmVjMiBoYWxmU2l6ZSA9IGltYWdlU2l6ZSAqIHNjYWxlICogMC41O1xcblxcXG4gICAgaGFsZlNpemUgKj0gKChkaXJlY3Rpb24gKiAyLjApIC0gMS4wKTtcXG5cXFxuXFxuXFxcbiAgICB2ZWMyIG9yaWdpblRyYW5zbGF0ZSA9IG9yaWdpbiAqIGFicyhoYWxmU2l6ZSk7XFxuXFxcblxcblxcXG4jaWYgZGVmaW5lZChST1RBVElPTikgfHwgZGVmaW5lZChBTElHTkVEX0FYSVMpXFxuXFxcbiAgICBpZiAodmFsaWRBbGlnbmVkQXhpcyB8fCByb3RhdGlvbiAhPSAwLjApXFxuXFxcbiAgICB7XFxuXFxcbiAgICAgICAgZmxvYXQgYW5nbGUgPSByb3RhdGlvbjtcXG5cXFxuICAgICAgICBpZiAodmFsaWRBbGlnbmVkQXhpcylcXG5cXFxuICAgICAgICB7XFxuXFxcbiAgICAgICAgICAgIHZlYzQgcHJvamVjdGVkQWxpZ25lZEF4aXMgPSBjem1fbW9kZWxWaWV3UHJvamVjdGlvbiAqIHZlYzQoYWxpZ25lZEF4aXMsIDAuMCk7XFxuXFxcbiAgICAgICAgICAgIGFuZ2xlICs9IHNpZ24oLXByb2plY3RlZEFsaWduZWRBeGlzLngpICogYWNvcyhzaWduKHByb2plY3RlZEFsaWduZWRBeGlzLnkpICogKHByb2plY3RlZEFsaWduZWRBeGlzLnkgKiBwcm9qZWN0ZWRBbGlnbmVkQXhpcy55KSAvXFxuXFxcbiAgICAgICAgICAgICAgICAgICAgKHByb2plY3RlZEFsaWduZWRBeGlzLnggKiBwcm9qZWN0ZWRBbGlnbmVkQXhpcy54ICsgcHJvamVjdGVkQWxpZ25lZEF4aXMueSAqIHByb2plY3RlZEFsaWduZWRBeGlzLnkpKTtcXG5cXFxuICAgICAgICB9XFxuXFxcblxcblxcXG4gICAgICAgIGZsb2F0IGNvc1RoZXRhID0gY29zKGFuZ2xlKTtcXG5cXFxuICAgICAgICBmbG9hdCBzaW5UaGV0YSA9IHNpbihhbmdsZSk7XFxuXFxcbiAgICAgICAgcm90YXRpb25NYXRyaXggPSBtYXQyKGNvc1RoZXRhLCBzaW5UaGV0YSwgLXNpblRoZXRhLCBjb3NUaGV0YSk7XFxuXFxcbiAgICAgICAgaGFsZlNpemUgPSByb3RhdGlvbk1hdHJpeCAqIGhhbGZTaXplO1xcblxcXG4gICAgfVxcblxcXG4gICAgZWxzZVxcblxcXG4gICAge1xcblxcXG4gICAgICAgIHJvdGF0aW9uTWF0cml4ID0gbWF0MigxLjAsIDAuMCwgMC4wLCAxLjApO1xcblxcXG4gICAgfVxcblxcXG4jZW5kaWZcXG5cXFxuXFxuXFxcbiAgICBtcHAgPSBjem1fbWV0ZXJzUGVyUGl4ZWwocG9zaXRpb25FQyk7XFxuXFxcbiAgICBwb3NpdGlvbkVDLnh5ICs9IChvcmlnaW5UcmFuc2xhdGUgKyBoYWxmU2l6ZSkgKiBjem1fYnJhbmNoRnJlZVRlcm5hcnkoc2l6ZUluTWV0ZXJzLCAxLjAsIG1wcCk7XFxuXFxcbiAgICBwb3NpdGlvbkVDLnh5ICs9ICh0cmFuc2xhdGUgKyBwaXhlbE9mZnNldCkgKiBtcHA7XFxuXFxcblxcblxcXG4gICAgcmV0dXJuIHBvc2l0aW9uRUM7XFxuXFxcbn1cXG5cXFxuXFxuXFxcbiNpZmRlZiBWRVJURVhfREVQVEhfQ0hFQ0tcXG5cXFxuZmxvYXQgZ2V0R2xvYmVEZXB0aCh2ZWM0IHBvc2l0aW9uRUMpXFxuXFxcbntcXG5cXFxuICAgIHZlYzQgcG9zV0MgPSBjem1fZXllVG9XaW5kb3dDb29yZGluYXRlcyhwb3NpdGlvbkVDKTtcXG5cXFxuXFxuXFxcbiAgICBmbG9hdCBnbG9iZURlcHRoID0gY3ptX3VucGFja0RlcHRoKHRleHR1cmUyRChjem1fZ2xvYmVEZXB0aFRleHR1cmUsIHBvc1dDLnh5IC8gY3ptX3ZpZXdwb3J0Lnp3KSk7XFxuXFxcblxcblxcXG4gICAgaWYgKGdsb2JlRGVwdGggPT0gMC4wKVxcblxcXG4gICAge1xcblxcXG4gICAgICAgIHJldHVybiAwLjA7IC8vIG5vdCBvbiB0aGUgZ2xvYmVcXG5cXFxuICAgIH1cXG5cXFxuXFxuXFxcbiAgICB2ZWM0IGV5ZUNvb3JkaW5hdGUgPSBjem1fd2luZG93VG9FeWVDb29yZGluYXRlcyhwb3NXQy54eSwgZ2xvYmVEZXB0aCk7XFxuXFxcbiAgICByZXR1cm4gZXllQ29vcmRpbmF0ZS56IC8gZXllQ29vcmRpbmF0ZS53O1xcblxcXG59XFxuXFxcbiNlbmRpZlxcblxcXG52b2lkIG1haW4oKVxcblxcXG57XFxuXFxcbiAgICAvLyBNb2RpZnlpbmcgdGhpcyBzaGFkZXIgbWF5IGFsc28gcmVxdWlyZSBtb2RpZmljYXRpb25zIHRvIEJpbGxib2FyZC5fY29tcHV0ZVNjcmVlblNwYWNlUG9zaXRpb25cXG5cXFxuXFxuXFxcbiAgICAvLyB1bnBhY2sgYXR0cmlidXRlc1xcblxcXG4gICAgdmVjMyBwb3NpdGlvbkhpZ2ggPSBwb3NpdGlvbkhpZ2hBbmRTY2FsZS54eXo7XFxuXFxcbiAgICB2ZWMzIHBvc2l0aW9uTG93ID0gcG9zaXRpb25Mb3dBbmRSb3RhdGlvbi54eXo7XFxuXFxcbiAgICBmbG9hdCBzY2FsZSA9IHBvc2l0aW9uSGlnaEFuZFNjYWxlLnc7XFxuXFxcblxcblxcXG4jaWYgZGVmaW5lZChST1RBVElPTikgfHwgZGVmaW5lZChBTElHTkVEX0FYSVMpXFxuXFxcbiAgICBmbG9hdCByb3RhdGlvbiA9IHBvc2l0aW9uTG93QW5kUm90YXRpb24udztcXG5cXFxuI2Vsc2VcXG5cXFxuICAgIGZsb2F0IHJvdGF0aW9uID0gMC4wO1xcblxcXG4jZW5kaWZcXG5cXFxuXFxuXFxcbiAgICBmbG9hdCBjb21wcmVzc2VkID0gY29tcHJlc3NlZEF0dHJpYnV0ZTAueDtcXG5cXFxuXFxuXFxcbiAgICB2ZWMyIHBpeGVsT2Zmc2V0O1xcblxcXG4gICAgcGl4ZWxPZmZzZXQueCA9IGZsb29yKGNvbXByZXNzZWQgKiBTSElGVF9SSUdIVDcpO1xcblxcXG4gICAgY29tcHJlc3NlZCAtPSBwaXhlbE9mZnNldC54ICogU0hJRlRfTEVGVDc7XFxuXFxcbiAgICBwaXhlbE9mZnNldC54IC09IFVQUEVSX0JPVU5EO1xcblxcXG5cXG5cXFxuICAgIHZlYzIgb3JpZ2luO1xcblxcXG4gICAgb3JpZ2luLnggPSBmbG9vcihjb21wcmVzc2VkICogU0hJRlRfUklHSFQ1KTtcXG5cXFxuICAgIGNvbXByZXNzZWQgLT0gb3JpZ2luLnggKiBTSElGVF9MRUZUNTtcXG5cXFxuXFxuXFxcbiAgICBvcmlnaW4ueSA9IGZsb29yKGNvbXByZXNzZWQgKiBTSElGVF9SSUdIVDMpO1xcblxcXG4gICAgY29tcHJlc3NlZCAtPSBvcmlnaW4ueSAqIFNISUZUX0xFRlQzO1xcblxcXG5cXG5cXFxuI2lmZGVmIEZSQUdNRU5UX0RFUFRIX0NIRUNLXFxuXFxcbiAgICB2ZWMyIGRlcHRoT3JpZ2luID0gb3JpZ2luLnh5O1xcblxcXG4jZW5kaWZcXG5cXFxuICAgIG9yaWdpbiAtPSB2ZWMyKDEuMCk7XFxuXFxcblxcblxcXG4gICAgZmxvYXQgc2hvdyA9IGZsb29yKGNvbXByZXNzZWQgKiBTSElGVF9SSUdIVDIpO1xcblxcXG4gICAgY29tcHJlc3NlZCAtPSBzaG93ICogU0hJRlRfTEVGVDI7XFxuXFxcblxcblxcXG4jaWZkZWYgSU5TVEFOQ0VEXFxuXFxcbiAgICB2ZWMyIHRleHR1cmVDb29yZGluYXRlc0JvdHRvbUxlZnQgPSBjem1fZGVjb21wcmVzc1RleHR1cmVDb29yZGluYXRlcyhjb21wcmVzc2VkQXR0cmlidXRlMC53KTtcXG5cXFxuICAgIHZlYzIgdGV4dHVyZUNvb3JkaW5hdGVzUmFuZ2UgPSBjem1fZGVjb21wcmVzc1RleHR1cmVDb29yZGluYXRlcyhleWVPZmZzZXQudyk7XFxuXFxcbiAgICB2ZWMyIHRleHR1cmVDb29yZGluYXRlcyA9IHRleHR1cmVDb29yZGluYXRlc0JvdHRvbUxlZnQgKyBkaXJlY3Rpb24gKiB0ZXh0dXJlQ29vcmRpbmF0ZXNSYW5nZTtcXG5cXFxuI2Vsc2VcXG5cXFxuICAgIHZlYzIgZGlyZWN0aW9uO1xcblxcXG4gICAgZGlyZWN0aW9uLnggPSBmbG9vcihjb21wcmVzc2VkICogU0hJRlRfUklHSFQxKTtcXG5cXFxuICAgIGRpcmVjdGlvbi55ID0gY29tcHJlc3NlZCAtIGRpcmVjdGlvbi54ICogU0hJRlRfTEVGVDE7XFxuXFxcblxcblxcXG4gICAgdmVjMiB0ZXh0dXJlQ29vcmRpbmF0ZXMgPSBjem1fZGVjb21wcmVzc1RleHR1cmVDb29yZGluYXRlcyhjb21wcmVzc2VkQXR0cmlidXRlMC53KTtcXG5cXFxuI2VuZGlmXFxuXFxcblxcblxcXG4gICAgZmxvYXQgdGVtcCA9IGNvbXByZXNzZWRBdHRyaWJ1dGUwLnkgICogU0hJRlRfUklHSFQ4O1xcblxcXG4gICAgcGl4ZWxPZmZzZXQueSA9IC0oZmxvb3IodGVtcCkgLSBVUFBFUl9CT1VORCk7XFxuXFxcblxcblxcXG4gICAgdmVjMiB0cmFuc2xhdGU7XFxuXFxcbiAgICB0cmFuc2xhdGUueSA9ICh0ZW1wIC0gZmxvb3IodGVtcCkpICogU0hJRlRfTEVGVDE2O1xcblxcXG5cXG5cXFxuICAgIHRlbXAgPSBjb21wcmVzc2VkQXR0cmlidXRlMC56ICogU0hJRlRfUklHSFQ4O1xcblxcXG4gICAgdHJhbnNsYXRlLnggPSBmbG9vcih0ZW1wKSAtIFVQUEVSX0JPVU5EO1xcblxcXG5cXG5cXFxuICAgIHRyYW5zbGF0ZS55ICs9ICh0ZW1wIC0gZmxvb3IodGVtcCkpICogU0hJRlRfTEVGVDg7XFxuXFxcbiAgICB0cmFuc2xhdGUueSAtPSBVUFBFUl9CT1VORDtcXG5cXFxuXFxuXFxcbiAgICB0ZW1wID0gY29tcHJlc3NlZEF0dHJpYnV0ZTEueCAqIFNISUZUX1JJR0hUODtcXG5cXFxuICAgIGZsb2F0IHRlbXAyID0gZmxvb3IoY29tcHJlc3NlZEF0dHJpYnV0ZTIudyAqIFNISUZUX1JJR0hUMik7XFxuXFxcblxcblxcXG4gICAgdmVjMiBpbWFnZVNpemUgPSB2ZWMyKGZsb29yKHRlbXApLCB0ZW1wMik7XFxuXFxcblxcblxcXG4jaWZkZWYgRlJBR01FTlRfREVQVEhfQ0hFQ0tcXG5cXFxuICAgIGZsb2F0IGxhYmVsSG9yaXpvbnRhbE9yaWdpbiA9IGZsb29yKGNvbXByZXNzZWRBdHRyaWJ1dGUyLncgLSAodGVtcDIgKiBTSElGVF9MRUZUMikpO1xcblxcXG4gICAgZmxvYXQgYXBwbHlUcmFuc2xhdGUgPSAwLjA7XFxuXFxcbiAgICBpZiAobGFiZWxIb3Jpem9udGFsT3JpZ2luICE9IDAuMCkgLy8gaXMgYSBiaWxsYm9hcmQsIHNvIHNldCBhcHBseSB0cmFuc2xhdGUgdG8gZmFsc2VcXG5cXFxuICAgIHtcXG5cXFxuICAgICAgICBhcHBseVRyYW5zbGF0ZSA9IDEuMDtcXG5cXFxuICAgICAgICBsYWJlbEhvcml6b250YWxPcmlnaW4gLT0gMi4wO1xcblxcXG4gICAgICAgIGRlcHRoT3JpZ2luLnggPSBsYWJlbEhvcml6b250YWxPcmlnaW4gKyAxLjA7XFxuXFxcbiAgICB9XFxuXFxcblxcblxcXG4gICAgZGVwdGhPcmlnaW4gPSB2ZWMyKDEuMCkgLSAoZGVwdGhPcmlnaW4gKiAwLjUpO1xcblxcXG4jZW5kaWZcXG5cXFxuXFxuXFxcbiNpZmRlZiBFWUVfRElTVEFOQ0VfVFJBTlNMVUNFTkNZXFxuXFxcbiAgICB2ZWM0IHRyYW5zbHVjZW5jeUJ5RGlzdGFuY2U7XFxuXFxcbiAgICB0cmFuc2x1Y2VuY3lCeURpc3RhbmNlLnggPSBjb21wcmVzc2VkQXR0cmlidXRlMS56O1xcblxcXG4gICAgdHJhbnNsdWNlbmN5QnlEaXN0YW5jZS56ID0gY29tcHJlc3NlZEF0dHJpYnV0ZTEudztcXG5cXFxuXFxuXFxcbiAgICB0cmFuc2x1Y2VuY3lCeURpc3RhbmNlLnkgPSAoKHRlbXAgLSBmbG9vcih0ZW1wKSkgKiBTSElGVF9MRUZUOCkgLyAyNTUuMDtcXG5cXFxuXFxuXFxcbiAgICB0ZW1wID0gY29tcHJlc3NlZEF0dHJpYnV0ZTEueSAqIFNISUZUX1JJR0hUODtcXG5cXFxuICAgIHRyYW5zbHVjZW5jeUJ5RGlzdGFuY2UudyA9ICgodGVtcCAtIGZsb29yKHRlbXApKSAqIFNISUZUX0xFRlQ4KSAvIDI1NS4wO1xcblxcXG4jZW5kaWZcXG5cXFxuXFxuXFxcbiNpZiBkZWZpbmVkKFZFUlRFWF9ERVBUSF9DSEVDSykgfHwgZGVmaW5lZChGUkFHTUVOVF9ERVBUSF9DSEVDSylcXG5cXFxuICAgIHRlbXAgPSBjb21wcmVzc2VkQXR0cmlidXRlMy53O1xcblxcXG4gICAgdGVtcCA9IHRlbXAgKiBTSElGVF9SSUdIVDEyO1xcblxcXG5cXG5cXFxuICAgIHZlYzIgZGltZW5zaW9ucztcXG5cXFxuICAgIGRpbWVuc2lvbnMueSA9ICh0ZW1wIC0gZmxvb3IodGVtcCkpICogU0hJRlRfTEVGVDEyO1xcblxcXG4gICAgZGltZW5zaW9ucy54ID0gZmxvb3IodGVtcCk7XFxuXFxcbiNlbmRpZlxcblxcXG5cXG5cXFxuI2lmZGVmIEFMSUdORURfQVhJU1xcblxcXG4gICAgdmVjMyBhbGlnbmVkQXhpcyA9IGN6bV9vY3REZWNvZGUoZmxvb3IoY29tcHJlc3NlZEF0dHJpYnV0ZTEueSAqIFNISUZUX1JJR0hUOCkpO1xcblxcXG4gICAgdGVtcCA9IGNvbXByZXNzZWRBdHRyaWJ1dGUyLnogKiBTSElGVF9SSUdIVDU7XFxuXFxcbiAgICBib29sIHZhbGlkQWxpZ25lZEF4aXMgPSAodGVtcCAtIGZsb29yKHRlbXApKSAqIFNISUZUX0xFRlQxID4gMC4wO1xcblxcXG4jZWxzZVxcblxcXG4gICAgdmVjMyBhbGlnbmVkQXhpcyA9IHZlYzMoMC4wKTtcXG5cXFxuICAgIGJvb2wgdmFsaWRBbGlnbmVkQXhpcyA9IGZhbHNlO1xcblxcXG4jZW5kaWZcXG5cXFxuXFxuXFxcbiAgICB2ZWM0IHBpY2tDb2xvcjtcXG5cXFxuICAgIHZlYzQgY29sb3I7XFxuXFxcblxcblxcXG4gICAgdGVtcCA9IGNvbXByZXNzZWRBdHRyaWJ1dGUyLnk7XFxuXFxcbiAgICB0ZW1wID0gdGVtcCAqIFNISUZUX1JJR0hUODtcXG5cXFxuICAgIHBpY2tDb2xvci5iID0gKHRlbXAgLSBmbG9vcih0ZW1wKSkgKiBTSElGVF9MRUZUODtcXG5cXFxuICAgIHRlbXAgPSBmbG9vcih0ZW1wKSAqIFNISUZUX1JJR0hUODtcXG5cXFxuICAgIHBpY2tDb2xvci5nID0gKHRlbXAgLSBmbG9vcih0ZW1wKSkgKiBTSElGVF9MRUZUODtcXG5cXFxuICAgIHBpY2tDb2xvci5yID0gZmxvb3IodGVtcCk7XFxuXFxcblxcblxcXG4gICAgdGVtcCA9IGNvbXByZXNzZWRBdHRyaWJ1dGUyLng7XFxuXFxcbiAgICB0ZW1wID0gdGVtcCAqIFNISUZUX1JJR0hUODtcXG5cXFxuICAgIGNvbG9yLmIgPSAodGVtcCAtIGZsb29yKHRlbXApKSAqIFNISUZUX0xFRlQ4O1xcblxcXG4gICAgdGVtcCA9IGZsb29yKHRlbXApICogU0hJRlRfUklHSFQ4O1xcblxcXG4gICAgY29sb3IuZyA9ICh0ZW1wIC0gZmxvb3IodGVtcCkpICogU0hJRlRfTEVGVDg7XFxuXFxcbiAgICBjb2xvci5yID0gZmxvb3IodGVtcCk7XFxuXFxcblxcblxcXG4gICAgdGVtcCA9IGNvbXByZXNzZWRBdHRyaWJ1dGUyLnogKiBTSElGVF9SSUdIVDg7XFxuXFxcbiAgICBib29sIHNpemVJbk1ldGVycyA9IGZsb29yKCh0ZW1wIC0gZmxvb3IodGVtcCkpICogU0hJRlRfTEVGVDcpID4gMC4wO1xcblxcXG4gICAgdGVtcCA9IGZsb29yKHRlbXApICogU0hJRlRfUklHSFQ4O1xcblxcXG5cXG5cXFxuICAgIHBpY2tDb2xvci5hID0gKHRlbXAgLSBmbG9vcih0ZW1wKSkgKiBTSElGVF9MRUZUODtcXG5cXFxuICAgIHBpY2tDb2xvciAvPSAyNTUuMDtcXG5cXFxuXFxuXFxcbiAgICBjb2xvci5hID0gZmxvb3IodGVtcCk7XFxuXFxcbiAgICBjb2xvciAvPSAyNTUuMDtcXG5cXFxuXFxuXFxcbiAgICAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cXG5cXFxuXFxuXFxcbiAgICB2ZWM0IHAgPSBjem1fdHJhbnNsYXRlUmVsYXRpdmVUb0V5ZShwb3NpdGlvbkhpZ2gsIHBvc2l0aW9uTG93KTtcXG5cXFxuICAgIHZlYzQgcG9zaXRpb25FQyA9IGN6bV9tb2RlbFZpZXdSZWxhdGl2ZVRvRXllICogcDtcXG5cXFxuXFxuXFxcbiNpZiBkZWZpbmVkKEZSQUdNRU5UX0RFUFRIX0NIRUNLKSB8fCBkZWZpbmVkKFZFUlRFWF9ERVBUSF9DSEVDSylcXG5cXFxuICAgIGZsb2F0IGV5ZURlcHRoID0gcG9zaXRpb25FQy56O1xcblxcXG4jZW5kaWZcXG5cXFxuXFxuXFxcbiAgICBwb3NpdGlvbkVDID0gY3ptX2V5ZU9mZnNldChwb3NpdGlvbkVDLCBleWVPZmZzZXQueHl6KTtcXG5cXFxuICAgIHBvc2l0aW9uRUMueHl6ICo9IHNob3c7XFxuXFxcblxcblxcXG4gICAgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXFxuXFxcblxcblxcXG4jaWYgZGVmaW5lZChFWUVfRElTVEFOQ0VfU0NBTElORykgfHwgZGVmaW5lZChFWUVfRElTVEFOQ0VfVFJBTlNMVUNFTkNZKSB8fCBkZWZpbmVkKEVZRV9ESVNUQU5DRV9QSVhFTF9PRkZTRVQpIHx8IGRlZmluZWQoRElTVEFOQ0VfRElTUExBWV9DT05ESVRJT04pIHx8IGRlZmluZWQoRElTQUJMRV9ERVBUSF9ESVNUQU5DRSlcXG5cXFxuICAgIGZsb2F0IGxlbmd0aFNxO1xcblxcXG4gICAgaWYgKGN6bV9zY2VuZU1vZGUgPT0gY3ptX3NjZW5lTW9kZTJEKVxcblxcXG4gICAge1xcblxcXG4gICAgICAgIC8vIDJEIGNhbWVyYSBkaXN0YW5jZSBpcyBhIHNwZWNpYWwgY2FzZVxcblxcXG4gICAgICAgIC8vIHRyZWF0IGFsbCBiaWxsYm9hcmRzIGFzIGZsYXR0ZW5lZCB0byB0aGUgej0wLjAgcGxhbmVcXG5cXFxuICAgICAgICBsZW5ndGhTcSA9IGN6bV9leWVIZWlnaHQyRC55O1xcblxcXG4gICAgfVxcblxcXG4gICAgZWxzZVxcblxcXG4gICAge1xcblxcXG4gICAgICAgIGxlbmd0aFNxID0gZG90KHBvc2l0aW9uRUMueHl6LCBwb3NpdGlvbkVDLnh5eik7XFxuXFxcbiAgICB9XFxuXFxcbiNlbmRpZlxcblxcXG5cXG5cXFxuI2lmZGVmIEVZRV9ESVNUQU5DRV9TQ0FMSU5HXFxuXFxcbiAgICBmbG9hdCBkaXN0YW5jZVNjYWxlID0gY3ptX25lYXJGYXJTY2FsYXIoc2NhbGVCeURpc3RhbmNlLCBsZW5ndGhTcSk7XFxuXFxcbiAgICBzY2FsZSAqPSBkaXN0YW5jZVNjYWxlO1xcblxcXG4gICAgdHJhbnNsYXRlICo9IGRpc3RhbmNlU2NhbGU7XFxuXFxcbiAgICAvLyBwdXNoIHZlcnRleCBiZWhpbmQgbmVhciBwbGFuZSBmb3IgY2xpcHBpbmdcXG5cXFxuICAgIGlmIChzY2FsZSA9PSAwLjApXFxuXFxcbiAgICB7XFxuXFxcbiAgICAgICAgcG9zaXRpb25FQy54eXogPSB2ZWMzKDAuMCk7XFxuXFxcbiAgICB9XFxuXFxcbiNlbmRpZlxcblxcXG5cXG5cXFxuICAgIGZsb2F0IHRyYW5zbHVjZW5jeSA9IDEuMDtcXG5cXFxuI2lmZGVmIEVZRV9ESVNUQU5DRV9UUkFOU0xVQ0VOQ1lcXG5cXFxuICAgIHRyYW5zbHVjZW5jeSA9IGN6bV9uZWFyRmFyU2NhbGFyKHRyYW5zbHVjZW5jeUJ5RGlzdGFuY2UsIGxlbmd0aFNxKTtcXG5cXFxuICAgIC8vIHB1c2ggdmVydGV4IGJlaGluZCBuZWFyIHBsYW5lIGZvciBjbGlwcGluZ1xcblxcXG4gICAgaWYgKHRyYW5zbHVjZW5jeSA9PSAwLjApXFxuXFxcbiAgICB7XFxuXFxcbiAgICAgICAgcG9zaXRpb25FQy54eXogPSB2ZWMzKDAuMCk7XFxuXFxcbiAgICB9XFxuXFxcbiNlbmRpZlxcblxcXG5cXG5cXFxuI2lmZGVmIEVZRV9ESVNUQU5DRV9QSVhFTF9PRkZTRVRcXG5cXFxuICAgIGZsb2F0IHBpeGVsT2Zmc2V0U2NhbGUgPSBjem1fbmVhckZhclNjYWxhcihwaXhlbE9mZnNldFNjYWxlQnlEaXN0YW5jZSwgbGVuZ3RoU3EpO1xcblxcXG4gICAgcGl4ZWxPZmZzZXQgKj0gcGl4ZWxPZmZzZXRTY2FsZTtcXG5cXFxuI2VuZGlmXFxuXFxcblxcblxcXG4jaWZkZWYgRElTVEFOQ0VfRElTUExBWV9DT05ESVRJT05cXG5cXFxuICAgIGZsb2F0IG5lYXJTcSA9IGNvbXByZXNzZWRBdHRyaWJ1dGUzLng7XFxuXFxcbiAgICBmbG9hdCBmYXJTcSA9IGNvbXByZXNzZWRBdHRyaWJ1dGUzLnk7XFxuXFxcbiAgICBpZiAobGVuZ3RoU3EgPCBuZWFyU3EgfHwgbGVuZ3RoU3EgPiBmYXJTcSlcXG5cXFxuICAgIHtcXG5cXFxuICAgICAgICBwb3NpdGlvbkVDLnh5eiA9IHZlYzMoMC4wKTtcXG5cXFxuICAgIH1cXG5cXFxuI2VuZGlmXFxuXFxcblxcblxcXG4gICAgbWF0MiByb3RhdGlvbk1hdHJpeDtcXG5cXFxuICAgIGZsb2F0IG1wcDtcXG5cXFxuXFxuXFxcbiNpZmRlZiBESVNBQkxFX0RFUFRIX0RJU1RBTkNFXFxuXFxcbiAgICBmbG9hdCBkaXNhYmxlRGVwdGhUZXN0RGlzdGFuY2UgPSBjb21wcmVzc2VkQXR0cmlidXRlMy56O1xcblxcXG4jZW5kaWZcXG5cXFxuXFxuXFxcbiNpZmRlZiBWRVJURVhfREVQVEhfQ0hFQ0tcXG5cXFxuaWYgKGxlbmd0aFNxIDwgZGlzYWJsZURlcHRoVGVzdERpc3RhbmNlKSB7XFxuXFxcbiAgICBmbG9hdCBkZXB0aHNpbG9uID0gMTAuMDtcXG5cXFxuXFxuXFxcbiAgICB2ZWMyIGxhYmVsVHJhbnNsYXRlID0gdGV4dHVyZUNvb3JkaW5hdGVCb3VuZHNPckxhYmVsVHJhbnNsYXRlLnh5O1xcblxcXG4gICAgdmVjNCBwRUMxID0gYWRkU2NyZWVuU3BhY2VPZmZzZXQocG9zaXRpb25FQywgZGltZW5zaW9ucywgc2NhbGUsIHZlYzIoMC4wKSwgb3JpZ2luLCBsYWJlbFRyYW5zbGF0ZSwgcGl4ZWxPZmZzZXQsIGFsaWduZWRBeGlzLCB2YWxpZEFsaWduZWRBeGlzLCByb3RhdGlvbiwgc2l6ZUluTWV0ZXJzLCByb3RhdGlvbk1hdHJpeCwgbXBwKTtcXG5cXFxuICAgIGZsb2F0IGdsb2JlRGVwdGgxID0gZ2V0R2xvYmVEZXB0aChwRUMxKTtcXG5cXFxuXFxuXFxcbiAgICBpZiAoZ2xvYmVEZXB0aDEgIT0gMC4wICYmIHBFQzEueiArIGRlcHRoc2lsb24gPCBnbG9iZURlcHRoMSlcXG5cXFxuICAgIHtcXG5cXFxuICAgICAgICB2ZWM0IHBFQzIgPSBhZGRTY3JlZW5TcGFjZU9mZnNldChwb3NpdGlvbkVDLCBkaW1lbnNpb25zLCBzY2FsZSwgdmVjMigwLjAsIDEuMCksIG9yaWdpbiwgbGFiZWxUcmFuc2xhdGUsIHBpeGVsT2Zmc2V0LCBhbGlnbmVkQXhpcywgdmFsaWRBbGlnbmVkQXhpcywgcm90YXRpb24sIHNpemVJbk1ldGVycywgcm90YXRpb25NYXRyaXgsIG1wcCk7XFxuXFxcbiAgICAgICAgZmxvYXQgZ2xvYmVEZXB0aDIgPSBnZXRHbG9iZURlcHRoKHBFQzIpO1xcblxcXG5cXG5cXFxuICAgICAgICBpZiAoZ2xvYmVEZXB0aDIgIT0gMC4wICYmIHBFQzIueiArIGRlcHRoc2lsb24gPCBnbG9iZURlcHRoMilcXG5cXFxuICAgICAgICB7XFxuXFxcbiAgICAgICAgICAgIHZlYzQgcEVDMyA9IGFkZFNjcmVlblNwYWNlT2Zmc2V0KHBvc2l0aW9uRUMsIGRpbWVuc2lvbnMsIHNjYWxlLCB2ZWMyKDEuMCksIG9yaWdpbiwgbGFiZWxUcmFuc2xhdGUsIHBpeGVsT2Zmc2V0LCBhbGlnbmVkQXhpcywgdmFsaWRBbGlnbmVkQXhpcywgcm90YXRpb24sIHNpemVJbk1ldGVycywgcm90YXRpb25NYXRyaXgsIG1wcCk7XFxuXFxcbiAgICAgICAgICAgIGZsb2F0IGdsb2JlRGVwdGgzID0gZ2V0R2xvYmVEZXB0aChwRUMzKTtcXG5cXFxuICAgICAgICAgICAgaWYgKGdsb2JlRGVwdGgzICE9IDAuMCAmJiBwRUMzLnogKyBkZXB0aHNpbG9uIDwgZ2xvYmVEZXB0aDMpXFxuXFxcbiAgICAgICAgICAgIHtcXG5cXFxuICAgICAgICAgICAgICAgIHBvc2l0aW9uRUMueHl6ID0gdmVjMygwLjApO1xcblxcXG4gICAgICAgICAgICB9XFxuXFxcbiAgICAgICAgfVxcblxcXG4gICAgfVxcblxcXG59XFxuXFxcbiNlbmRpZlxcblxcXG5cXG5cXFxuICAgIHBvc2l0aW9uRUMgPSBhZGRTY3JlZW5TcGFjZU9mZnNldChwb3NpdGlvbkVDLCBpbWFnZVNpemUsIHNjYWxlLCBkaXJlY3Rpb24sIG9yaWdpbiwgdHJhbnNsYXRlLCBwaXhlbE9mZnNldCwgYWxpZ25lZEF4aXMsIHZhbGlkQWxpZ25lZEF4aXMsIHJvdGF0aW9uLCBzaXplSW5NZXRlcnMsIHJvdGF0aW9uTWF0cml4LCBtcHApO1xcblxcXG4gICAgZ2xfUG9zaXRpb24gPSBjem1fcHJvamVjdGlvbiAqIHBvc2l0aW9uRUM7XFxuXFxcbiAgICB2X3RleHR1cmVDb29yZGluYXRlcyA9IHRleHR1cmVDb29yZGluYXRlcztcXG5cXFxuXFxuXFxcbiNpZmRlZiBMT0dfREVQVEhcXG5cXFxuICAgIGN6bV92ZXJ0ZXhMb2dEZXB0aCgpO1xcblxcXG4jZW5kaWZcXG5cXFxuXFxuXFxcbiNpZmRlZiBESVNBQkxFX0RFUFRIX0RJU1RBTkNFXFxuXFxcbiAgICBpZiAoZGlzYWJsZURlcHRoVGVzdERpc3RhbmNlID09IDAuMCAmJiBjem1fbWluaW11bURpc2FibGVEZXB0aFRlc3REaXN0YW5jZSAhPSAwLjApXFxuXFxcbiAgICB7XFxuXFxcbiAgICAgICAgZGlzYWJsZURlcHRoVGVzdERpc3RhbmNlID0gY3ptX21pbmltdW1EaXNhYmxlRGVwdGhUZXN0RGlzdGFuY2U7XFxuXFxcbiAgICB9XFxuXFxcblxcblxcXG4gICAgaWYgKGRpc2FibGVEZXB0aFRlc3REaXN0YW5jZSAhPSAwLjApXFxuXFxcbiAgICB7XFxuXFxcbiAgICAgICAgLy8gRG9uJ3QgdHJ5IHRvIFxcXCJtdWx0aXBseSBib3RoIHNpZGVzXFxcIiBieSB3LiAgR3JlYXRlci9sZXNzLXRoYW4gY29tcGFyaXNvbnMgd29uJ3Qgd29yayBmb3IgbmVnYXRpdmUgdmFsdWVzIG9mIHcuXFxuXFxcbiAgICAgICAgZmxvYXQgemNsaXAgPSBnbF9Qb3NpdGlvbi56IC8gZ2xfUG9zaXRpb24udztcXG5cXFxuICAgICAgICBib29sIGNsaXBwZWQgPSAoemNsaXAgPCAtMS4wIHx8IHpjbGlwID4gMS4wKTtcXG5cXFxuICAgICAgICBpZiAoIWNsaXBwZWQgJiYgKGRpc2FibGVEZXB0aFRlc3REaXN0YW5jZSA8IDAuMCB8fCAobGVuZ3RoU3EgPiAwLjAgJiYgbGVuZ3RoU3EgPCBkaXNhYmxlRGVwdGhUZXN0RGlzdGFuY2UpKSlcXG5cXFxuICAgICAgICB7XFxuXFxcbiAgICAgICAgICAgIC8vIFBvc2l0aW9uIHogb24gdGhlIG5lYXIgcGxhbmUuXFxuXFxcbiAgICAgICAgICAgIGdsX1Bvc2l0aW9uLnogPSAtZ2xfUG9zaXRpb24udztcXG5cXFxuI2lmZGVmIExPR19ERVBUSFxcblxcXG4gICAgICAgICAgICB2X2RlcHRoRnJvbU5lYXJQbHVzT25lID0gMS4wO1xcblxcXG4jZW5kaWZcXG5cXFxuICAgICAgICB9XFxuXFxcbiAgICB9XFxuXFxcbiNlbmRpZlxcblxcXG5cXG5cXFxuI2lmZGVmIEZSQUdNRU5UX0RFUFRIX0NIRUNLXFxuXFxcbiAgICBpZiAoc2l6ZUluTWV0ZXJzKSB7XFxuXFxcbiAgICAgICAgdHJhbnNsYXRlIC89IG1wcDtcXG5cXFxuICAgICAgICBkaW1lbnNpb25zIC89IG1wcDtcXG5cXFxuICAgICAgICBpbWFnZVNpemUgLz0gbXBwO1xcblxcXG4gICAgfVxcblxcXG5cXG5cXFxuI2lmIGRlZmluZWQoUk9UQVRJT04pIHx8IGRlZmluZWQoQUxJR05FRF9BWElTKVxcblxcXG4gICAgdl9yb3RhdGlvbk1hdHJpeCA9IHJvdGF0aW9uTWF0cml4O1xcblxcXG4jZWxzZVxcblxcXG4gICAgdl9yb3RhdGlvbk1hdHJpeCA9IG1hdDIoMS4wLCAwLjAsIDAuMCwgMS4wKTtcXG5cXFxuI2VuZGlmXFxuXFxcblxcblxcXG4gICAgZmxvYXQgZW5hYmxlRGVwdGhDaGVjayA9IDAuMDtcXG5cXFxuICAgIGlmIChsZW5ndGhTcSA8IGRpc2FibGVEZXB0aFRlc3REaXN0YW5jZSlcXG5cXFxuICAgIHtcXG5cXFxuICAgICAgICBlbmFibGVEZXB0aENoZWNrID0gMS4wO1xcblxcXG4gICAgfVxcblxcXG5cXG5cXFxuICAgIGZsb2F0IGR3ID0gZmxvb3IoY2xhbXAoZGltZW5zaW9ucy54LCAwLjAsIFNISUZUX0xFRlQxMikpO1xcblxcXG4gICAgZmxvYXQgZGggPSBmbG9vcihjbGFtcChkaW1lbnNpb25zLnksIDAuMCwgU0hJRlRfTEVGVDEyKSk7XFxuXFxcblxcblxcXG4gICAgZmxvYXQgaXcgPSBmbG9vcihjbGFtcChpbWFnZVNpemUueCwgMC4wLCBTSElGVF9MRUZUMTIpKTtcXG5cXFxuICAgIGZsb2F0IGloID0gZmxvb3IoY2xhbXAoaW1hZ2VTaXplLnksIDAuMCwgU0hJRlRfTEVGVDEyKSk7XFxuXFxcblxcblxcXG4gICAgdl9jb21wcmVzc2VkLnggPSBleWVEZXB0aDtcXG5cXFxuICAgIHZfY29tcHJlc3NlZC55ID0gYXBwbHlUcmFuc2xhdGUgKiBTSElGVF9MRUZUMSArIGVuYWJsZURlcHRoQ2hlY2s7XFxuXFxcbiAgICB2X2NvbXByZXNzZWQueiA9IGR3ICogU0hJRlRfTEVGVDEyICsgZGg7XFxuXFxcbiAgICB2X2NvbXByZXNzZWQudyA9IGl3ICogU0hJRlRfTEVGVDEyICsgaWg7XFxuXFxcbiAgICB2X29yaWdpblRleHR1cmVDb29yZGluYXRlQW5kVHJhbnNsYXRlLnh5ID0gZGVwdGhPcmlnaW47XFxuXFxcbiAgICB2X29yaWdpblRleHR1cmVDb29yZGluYXRlQW5kVHJhbnNsYXRlLnp3ID0gdHJhbnNsYXRlO1xcblxcXG4gICAgdl90ZXh0dXJlQ29vcmRpbmF0ZUJvdW5kcyA9IHRleHR1cmVDb29yZGluYXRlQm91bmRzT3JMYWJlbFRyYW5zbGF0ZTtcXG5cXFxuXFxuXFxcbiNlbmRpZlxcblxcXG5cXG5cXFxuI2lmZGVmIFNERlxcblxcXG4gICAgdmVjNCBvdXRsaW5lQ29sb3I7XFxuXFxcbiAgICBmbG9hdCBvdXRsaW5lV2lkdGg7XFxuXFxcblxcblxcXG4gICAgdGVtcCA9IHNkZi54O1xcblxcXG4gICAgdGVtcCA9IHRlbXAgKiBTSElGVF9SSUdIVDg7XFxuXFxcbiAgICBvdXRsaW5lQ29sb3IuYiA9ICh0ZW1wIC0gZmxvb3IodGVtcCkpICogU0hJRlRfTEVGVDg7XFxuXFxcbiAgICB0ZW1wID0gZmxvb3IodGVtcCkgKiBTSElGVF9SSUdIVDg7XFxuXFxcbiAgICBvdXRsaW5lQ29sb3IuZyA9ICh0ZW1wIC0gZmxvb3IodGVtcCkpICogU0hJRlRfTEVGVDg7XFxuXFxcbiAgICBvdXRsaW5lQ29sb3IuciA9IGZsb29yKHRlbXApO1xcblxcXG5cXG5cXFxuICAgIHRlbXAgPSBzZGYueTtcXG5cXFxuICAgIHRlbXAgPSB0ZW1wICogU0hJRlRfUklHSFQ4O1xcblxcXG4gICAgZmxvYXQgdGVtcDMgPSAodGVtcCAtIGZsb29yKHRlbXApKSAqIFNISUZUX0xFRlQ4O1xcblxcXG4gICAgdGVtcCA9IGZsb29yKHRlbXApICogU0hJRlRfUklHSFQ4O1xcblxcXG4gICAgb3V0bGluZVdpZHRoID0gKHRlbXAgLSBmbG9vcih0ZW1wKSkgKiBTSElGVF9MRUZUODtcXG5cXFxuICAgIG91dGxpbmVDb2xvci5hID0gZmxvb3IodGVtcCk7XFxuXFxcbiAgICBvdXRsaW5lQ29sb3IgLz0gMjU1LjA7XFxuXFxcblxcblxcXG4gICAgdl9vdXRsaW5lV2lkdGggPSBvdXRsaW5lV2lkdGggLyAyNTUuMDtcXG5cXFxuICAgIHZfb3V0bGluZUNvbG9yID0gb3V0bGluZUNvbG9yO1xcblxcXG4gICAgdl9vdXRsaW5lQ29sb3IuYSAqPSB0cmFuc2x1Y2VuY3k7XFxuXFxcbiNlbmRpZlxcblxcXG5cXG5cXFxuICAgIHZfcGlja0NvbG9yID0gcGlja0NvbG9yO1xcblxcXG5cXG5cXFxuICAgIHZfY29sb3IgPSBjb2xvcjtcXG5cXFxuICAgIHZfY29sb3IuYSAqPSB0cmFuc2x1Y2VuY3k7XFxuXFxcblxcblxcXG59XFxuXFxcblwiO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///64059\n')},90398:function(__unused_webpack___webpack_module__,__webpack_exports__){eval('//This file is automatically rebuilt by the Cesium build process.\n/* harmony default export */ __webpack_exports__["Z"] = ("varying vec2 v_textureCoordinates;\\n\\\nconst float M_PI = 3.141592653589793;\\n\\\n\\n\\\nfloat vdcRadicalInverse(int i)\\n\\\n{\\n\\\n    float r;\\n\\\n    float base = 2.0;\\n\\\n    float value = 0.0;\\n\\\n    float invBase = 1.0 / base;\\n\\\n    float invBi = invBase;\\n\\\n    for (int x = 0; x < 100; x++)\\n\\\n    {\\n\\\n        if (i <= 0)\\n\\\n        {\\n\\\n            break;\\n\\\n        }\\n\\\n        r = mod(float(i), base);\\n\\\n        value += r * invBi;\\n\\\n        invBi *= invBase;\\n\\\n        i = int(float(i) * invBase);\\n\\\n    }\\n\\\n    return value;\\n\\\n}\\n\\\n\\n\\\nvec2 hammersley2D(int i, int N)\\n\\\n{\\n\\\n    return vec2(float(i) / float(N), vdcRadicalInverse(i));\\n\\\n}\\n\\\n\\n\\\nvec3 importanceSampleGGX(vec2 xi, float roughness, vec3 N)\\n\\\n{\\n\\\n    float a = roughness * roughness;\\n\\\n    float phi = 2.0 * M_PI * xi.x;\\n\\\n    float cosTheta = sqrt((1.0 - xi.y) / (1.0 + (a * a - 1.0) * xi.y));\\n\\\n    float sinTheta = sqrt(1.0 - cosTheta * cosTheta);\\n\\\n    vec3 H = vec3(sinTheta * cos(phi), sinTheta * sin(phi), cosTheta);\\n\\\n    vec3 upVector = abs(N.z) < 0.999 ? vec3(0.0, 0.0, 1.0) : vec3(1.0, 0.0, 0.0);\\n\\\n    vec3 tangentX = normalize(cross(upVector, N));\\n\\\n    vec3 tangentY = cross(N, tangentX);\\n\\\n    return tangentX * H.x + tangentY * H.y + N * H.z;\\n\\\n}\\n\\\n\\n\\\nfloat G1_Smith(float NdotV, float k)\\n\\\n{\\n\\\n    return NdotV / (NdotV * (1.0 - k) + k);\\n\\\n}\\n\\\n\\n\\\nfloat G_Smith(float roughness, float NdotV, float NdotL)\\n\\\n{\\n\\\n    float k = roughness * roughness / 2.0;\\n\\\n    return G1_Smith(NdotV, k) * G1_Smith(NdotL, k);\\n\\\n}\\n\\\n\\n\\\nvec2 integrateBrdf(float roughness, float NdotV)\\n\\\n{\\n\\\n    vec3 V = vec3(sqrt(1.0 - NdotV * NdotV), 0.0, NdotV);\\n\\\n    float A = 0.0;\\n\\\n    float B = 0.0;\\n\\\n    const int NumSamples = 1024;\\n\\\n    for (int i = 0; i < NumSamples; i++)\\n\\\n    {\\n\\\n        vec2 xi = hammersley2D(i, NumSamples);\\n\\\n        vec3 H = importanceSampleGGX(xi, roughness, vec3(0.0, 0.0, 1.0));\\n\\\n        vec3 L = 2.0 * dot(V, H) * H - V;\\n\\\n        float NdotL = clamp(L.z, 0.0, 1.0);\\n\\\n        float NdotH = clamp(H.z, 0.0, 1.0);\\n\\\n        float VdotH = clamp(dot(V, H), 0.0, 1.0);\\n\\\n        if (NdotL > 0.0)\\n\\\n        {\\n\\\n            float G = G_Smith(roughness, NdotV, NdotL);\\n\\\n            float G_Vis = G * VdotH / (NdotH * NdotV);\\n\\\n            float Fc = pow(1.0 - VdotH, 5.0);\\n\\\n            A += (1.0 - Fc) * G_Vis;\\n\\\n            B += Fc * G_Vis;\\n\\\n        }\\n\\\n    }\\n\\\n    return vec2(A, B) / float(NumSamples);\\n\\\n}\\n\\\n\\n\\\nvoid main()\\n\\\n{\\n\\\n    gl_FragColor = vec4(integrateBrdf(v_textureCoordinates.y, v_textureCoordinates.x), 0.0, 1.0);\\n\\\n}\\n\\\n");\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiOTAzOTguanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQSx5REFBZSxtQ0FBbUM7QUFDbEQscUNBQXFDO0FBQ3JDO0FBQ0E7QUFDQSxDQUFDO0FBQ0QsWUFBWTtBQUNaLHFCQUFxQjtBQUNyQixzQkFBc0I7QUFDdEIsK0JBQStCO0FBQy9CLDBCQUEwQjtBQUMxQixvQkFBb0IsU0FBUztBQUM3QixLQUFLO0FBQ0w7QUFDQSxTQUFTO0FBQ1Qsa0JBQWtCO0FBQ2xCLFNBQVM7QUFDVCxnQ0FBZ0M7QUFDaEMsMkJBQTJCO0FBQzNCLHlCQUF5QjtBQUN6QixvQ0FBb0M7QUFDcEMsS0FBSztBQUNMLGlCQUFpQjtBQUNqQixDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRCwyREFBMkQ7QUFDM0QsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Qsb0NBQW9DO0FBQ3BDLGtDQUFrQztBQUNsQyx1RUFBdUU7QUFDdkUscURBQXFEO0FBQ3JELHNFQUFzRTtBQUN0RSxpRkFBaUY7QUFDakYsa0RBQWtEO0FBQ2xELHVDQUF1QztBQUN2QyxxREFBcUQ7QUFDckQsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0QsMkNBQTJDO0FBQzNDLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNELDBDQUEwQztBQUMxQyxtREFBbUQ7QUFDbkQsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0QseURBQXlEO0FBQ3pELGtCQUFrQjtBQUNsQixrQkFBa0I7QUFDbEIsZ0NBQWdDO0FBQ2hDLG9CQUFvQixnQkFBZ0I7QUFDcEMsS0FBSztBQUNMLDhDQUE4QztBQUM5Qyx5RUFBeUU7QUFDekUseUNBQXlDO0FBQ3pDLDJDQUEyQztBQUMzQywyQ0FBMkM7QUFDM0MsaURBQWlEO0FBQ2pEO0FBQ0EsU0FBUztBQUNULHVEQUF1RDtBQUN2RCxzREFBc0Q7QUFDdEQsNkNBQTZDO0FBQzdDLG9DQUFvQztBQUNwQyw0QkFBNEI7QUFDNUIsU0FBUztBQUNULEtBQUs7QUFDTCwwQ0FBMEM7QUFDMUMsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0QsaUdBQWlHO0FBQ2pHLENBQUM7QUFDRCxDQUFDLEVBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly92dWUzLXdlYnBhY2s1Ly4vbm9kZV9tb2R1bGVzL2Nlc2l1bS9Tb3VyY2UvU2hhZGVycy9CcmRmTHV0R2VuZXJhdG9yRlMuanM/MGE0MiJdLCJzb3VyY2VzQ29udGVudCI6WyIvL1RoaXMgZmlsZSBpcyBhdXRvbWF0aWNhbGx5IHJlYnVpbHQgYnkgdGhlIENlc2l1bSBidWlsZCBwcm9jZXNzLlxuZXhwb3J0IGRlZmF1bHQgXCJ2YXJ5aW5nIHZlYzIgdl90ZXh0dXJlQ29vcmRpbmF0ZXM7XFxuXFxcbmNvbnN0IGZsb2F0IE1fUEkgPSAzLjE0MTU5MjY1MzU4OTc5MztcXG5cXFxuXFxuXFxcbmZsb2F0IHZkY1JhZGljYWxJbnZlcnNlKGludCBpKVxcblxcXG57XFxuXFxcbiAgICBmbG9hdCByO1xcblxcXG4gICAgZmxvYXQgYmFzZSA9IDIuMDtcXG5cXFxuICAgIGZsb2F0IHZhbHVlID0gMC4wO1xcblxcXG4gICAgZmxvYXQgaW52QmFzZSA9IDEuMCAvIGJhc2U7XFxuXFxcbiAgICBmbG9hdCBpbnZCaSA9IGludkJhc2U7XFxuXFxcbiAgICBmb3IgKGludCB4ID0gMDsgeCA8IDEwMDsgeCsrKVxcblxcXG4gICAge1xcblxcXG4gICAgICAgIGlmIChpIDw9IDApXFxuXFxcbiAgICAgICAge1xcblxcXG4gICAgICAgICAgICBicmVhaztcXG5cXFxuICAgICAgICB9XFxuXFxcbiAgICAgICAgciA9IG1vZChmbG9hdChpKSwgYmFzZSk7XFxuXFxcbiAgICAgICAgdmFsdWUgKz0gciAqIGludkJpO1xcblxcXG4gICAgICAgIGludkJpICo9IGludkJhc2U7XFxuXFxcbiAgICAgICAgaSA9IGludChmbG9hdChpKSAqIGludkJhc2UpO1xcblxcXG4gICAgfVxcblxcXG4gICAgcmV0dXJuIHZhbHVlO1xcblxcXG59XFxuXFxcblxcblxcXG52ZWMyIGhhbW1lcnNsZXkyRChpbnQgaSwgaW50IE4pXFxuXFxcbntcXG5cXFxuICAgIHJldHVybiB2ZWMyKGZsb2F0KGkpIC8gZmxvYXQoTiksIHZkY1JhZGljYWxJbnZlcnNlKGkpKTtcXG5cXFxufVxcblxcXG5cXG5cXFxudmVjMyBpbXBvcnRhbmNlU2FtcGxlR0dYKHZlYzIgeGksIGZsb2F0IHJvdWdobmVzcywgdmVjMyBOKVxcblxcXG57XFxuXFxcbiAgICBmbG9hdCBhID0gcm91Z2huZXNzICogcm91Z2huZXNzO1xcblxcXG4gICAgZmxvYXQgcGhpID0gMi4wICogTV9QSSAqIHhpLng7XFxuXFxcbiAgICBmbG9hdCBjb3NUaGV0YSA9IHNxcnQoKDEuMCAtIHhpLnkpIC8gKDEuMCArIChhICogYSAtIDEuMCkgKiB4aS55KSk7XFxuXFxcbiAgICBmbG9hdCBzaW5UaGV0YSA9IHNxcnQoMS4wIC0gY29zVGhldGEgKiBjb3NUaGV0YSk7XFxuXFxcbiAgICB2ZWMzIEggPSB2ZWMzKHNpblRoZXRhICogY29zKHBoaSksIHNpblRoZXRhICogc2luKHBoaSksIGNvc1RoZXRhKTtcXG5cXFxuICAgIHZlYzMgdXBWZWN0b3IgPSBhYnMoTi56KSA8IDAuOTk5ID8gdmVjMygwLjAsIDAuMCwgMS4wKSA6IHZlYzMoMS4wLCAwLjAsIDAuMCk7XFxuXFxcbiAgICB2ZWMzIHRhbmdlbnRYID0gbm9ybWFsaXplKGNyb3NzKHVwVmVjdG9yLCBOKSk7XFxuXFxcbiAgICB2ZWMzIHRhbmdlbnRZID0gY3Jvc3MoTiwgdGFuZ2VudFgpO1xcblxcXG4gICAgcmV0dXJuIHRhbmdlbnRYICogSC54ICsgdGFuZ2VudFkgKiBILnkgKyBOICogSC56O1xcblxcXG59XFxuXFxcblxcblxcXG5mbG9hdCBHMV9TbWl0aChmbG9hdCBOZG90ViwgZmxvYXQgaylcXG5cXFxue1xcblxcXG4gICAgcmV0dXJuIE5kb3RWIC8gKE5kb3RWICogKDEuMCAtIGspICsgayk7XFxuXFxcbn1cXG5cXFxuXFxuXFxcbmZsb2F0IEdfU21pdGgoZmxvYXQgcm91Z2huZXNzLCBmbG9hdCBOZG90ViwgZmxvYXQgTmRvdEwpXFxuXFxcbntcXG5cXFxuICAgIGZsb2F0IGsgPSByb3VnaG5lc3MgKiByb3VnaG5lc3MgLyAyLjA7XFxuXFxcbiAgICByZXR1cm4gRzFfU21pdGgoTmRvdFYsIGspICogRzFfU21pdGgoTmRvdEwsIGspO1xcblxcXG59XFxuXFxcblxcblxcXG52ZWMyIGludGVncmF0ZUJyZGYoZmxvYXQgcm91Z2huZXNzLCBmbG9hdCBOZG90VilcXG5cXFxue1xcblxcXG4gICAgdmVjMyBWID0gdmVjMyhzcXJ0KDEuMCAtIE5kb3RWICogTmRvdFYpLCAwLjAsIE5kb3RWKTtcXG5cXFxuICAgIGZsb2F0IEEgPSAwLjA7XFxuXFxcbiAgICBmbG9hdCBCID0gMC4wO1xcblxcXG4gICAgY29uc3QgaW50IE51bVNhbXBsZXMgPSAxMDI0O1xcblxcXG4gICAgZm9yIChpbnQgaSA9IDA7IGkgPCBOdW1TYW1wbGVzOyBpKyspXFxuXFxcbiAgICB7XFxuXFxcbiAgICAgICAgdmVjMiB4aSA9IGhhbW1lcnNsZXkyRChpLCBOdW1TYW1wbGVzKTtcXG5cXFxuICAgICAgICB2ZWMzIEggPSBpbXBvcnRhbmNlU2FtcGxlR0dYKHhpLCByb3VnaG5lc3MsIHZlYzMoMC4wLCAwLjAsIDEuMCkpO1xcblxcXG4gICAgICAgIHZlYzMgTCA9IDIuMCAqIGRvdChWLCBIKSAqIEggLSBWO1xcblxcXG4gICAgICAgIGZsb2F0IE5kb3RMID0gY2xhbXAoTC56LCAwLjAsIDEuMCk7XFxuXFxcbiAgICAgICAgZmxvYXQgTmRvdEggPSBjbGFtcChILnosIDAuMCwgMS4wKTtcXG5cXFxuICAgICAgICBmbG9hdCBWZG90SCA9IGNsYW1wKGRvdChWLCBIKSwgMC4wLCAxLjApO1xcblxcXG4gICAgICAgIGlmIChOZG90TCA+IDAuMClcXG5cXFxuICAgICAgICB7XFxuXFxcbiAgICAgICAgICAgIGZsb2F0IEcgPSBHX1NtaXRoKHJvdWdobmVzcywgTmRvdFYsIE5kb3RMKTtcXG5cXFxuICAgICAgICAgICAgZmxvYXQgR19WaXMgPSBHICogVmRvdEggLyAoTmRvdEggKiBOZG90Vik7XFxuXFxcbiAgICAgICAgICAgIGZsb2F0IEZjID0gcG93KDEuMCAtIFZkb3RILCA1LjApO1xcblxcXG4gICAgICAgICAgICBBICs9ICgxLjAgLSBGYykgKiBHX1ZpcztcXG5cXFxuICAgICAgICAgICAgQiArPSBGYyAqIEdfVmlzO1xcblxcXG4gICAgICAgIH1cXG5cXFxuICAgIH1cXG5cXFxuICAgIHJldHVybiB2ZWMyKEEsIEIpIC8gZmxvYXQoTnVtU2FtcGxlcyk7XFxuXFxcbn1cXG5cXFxuXFxuXFxcbnZvaWQgbWFpbigpXFxuXFxcbntcXG5cXFxuICAgIGdsX0ZyYWdDb2xvciA9IHZlYzQoaW50ZWdyYXRlQnJkZih2X3RleHR1cmVDb29yZGluYXRlcy55LCB2X3RleHR1cmVDb29yZGluYXRlcy54KSwgMC4wLCAxLjApO1xcblxcXG59XFxuXFxcblwiO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///90398\n')},2303:function(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__){eval('\n// EXPORTS\n__webpack_require__.d(__webpack_exports__, {\n  "Z": function() { return /* binding */ CzmBuiltins; }\n});\n\n;// CONCATENATED MODULE: ./node_modules/cesium/Source/Shaders/Builtin/Constants/degreesPerRadian.js\n//This file is automatically rebuilt by the Cesium build process.\n/* harmony default export */ var degreesPerRadian = ("/**\\n\\\n * A built-in GLSL floating-point constant for converting radians to degrees.\\n\\\n *\\n\\\n * @alias czm_degreesPerRadian\\n\\\n * @glslConstant\\n\\\n *\\n\\\n * @see CesiumMath.DEGREES_PER_RADIAN\\n\\\n *\\n\\\n * @example\\n\\\n * // GLSL declaration\\n\\\n * const float czm_degreesPerRadian = ...;\\n\\\n *\\n\\\n * // Example\\n\\\n * float deg = czm_degreesPerRadian * rad;\\n\\\n */\\n\\\nconst float czm_degreesPerRadian = 57.29577951308232;\\n\\\n");\n\n;// CONCATENATED MODULE: ./node_modules/cesium/Source/Shaders/Builtin/Constants/depthRange.js\n//This file is automatically rebuilt by the Cesium build process.\n/* harmony default export */ var depthRange = ("/**\\n\\\n * A built-in GLSL vec2 constant for defining the depth range.\\n\\\n * This is a workaround to a bug where IE11 does not implement gl_DepthRange.\\n\\\n *\\n\\\n * @alias czm_depthRange\\n\\\n * @glslConstant\\n\\\n *\\n\\\n * @example\\n\\\n * // GLSL declaration\\n\\\n * float depthRangeNear = czm_depthRange.near;\\n\\\n * float depthRangeFar = czm_depthRange.far;\\n\\\n *\\n\\\n */\\n\\\nconst czm_depthRangeStruct czm_depthRange = czm_depthRangeStruct(0.0, 1.0);\\n\\\n");\n\n;// CONCATENATED MODULE: ./node_modules/cesium/Source/Shaders/Builtin/Constants/epsilon1.js\n//This file is automatically rebuilt by the Cesium build process.\n/* harmony default export */ var epsilon1 = ("/**\\n\\\n * 0.1\\n\\\n *\\n\\\n * @name czm_epsilon1\\n\\\n * @glslConstant\\n\\\n */\\n\\\nconst float czm_epsilon1 = 0.1;\\n\\\n");\n\n;// CONCATENATED MODULE: ./node_modules/cesium/Source/Shaders/Builtin/Constants/epsilon2.js\n//This file is automatically rebuilt by the Cesium build process.\n/* harmony default export */ var epsilon2 = ("/**\\n\\\n * 0.01\\n\\\n *\\n\\\n * @name czm_epsilon2\\n\\\n * @glslConstant\\n\\\n */\\n\\\nconst float czm_epsilon2 = 0.01;\\n\\\n");\n\n;// CONCATENATED MODULE: ./node_modules/cesium/Source/Shaders/Builtin/Constants/epsilon3.js\n//This file is automatically rebuilt by the Cesium build process.\n/* harmony default export */ var epsilon3 = ("/**\\n\\\n * 0.001\\n\\\n *\\n\\\n * @name czm_epsilon3\\n\\\n * @glslConstant\\n\\\n */\\n\\\nconst float czm_epsilon3 = 0.001;\\n\\\n");\n\n;// CONCATENATED MODULE: ./node_modules/cesium/Source/Shaders/Builtin/Constants/epsilon4.js\n//This file is automatically rebuilt by the Cesium build process.\n/* harmony default export */ var epsilon4 = ("/**\\n\\\n * 0.0001\\n\\\n *\\n\\\n * @name czm_epsilon4\\n\\\n * @glslConstant\\n\\\n */\\n\\\nconst float czm_epsilon4 = 0.0001;\\n\\\n");\n\n;// CONCATENATED MODULE: ./node_modules/cesium/Source/Shaders/Builtin/Constants/epsilon5.js\n//This file is automatically rebuilt by the Cesium build process.\n/* harmony default export */ var epsilon5 = ("/**\\n\\\n * 0.00001\\n\\\n *\\n\\\n * @name czm_epsilon5\\n\\\n * @glslConstant\\n\\\n */\\n\\\nconst float czm_epsilon5 = 0.00001;\\n\\\n");\n\n;// CONCATENATED MODULE: ./node_modules/cesium/Source/Shaders/Builtin/Constants/epsilon6.js\n//This file is automatically rebuilt by the Cesium build process.\n/* harmony default export */ var epsilon6 = ("/**\\n\\\n * 0.000001\\n\\\n *\\n\\\n * @name czm_epsilon6\\n\\\n * @glslConstant\\n\\\n */\\n\\\nconst float czm_epsilon6 = 0.000001;\\n\\\n");\n\n;// CONCATENATED MODULE: ./node_modules/cesium/Source/Shaders/Builtin/Constants/epsilon7.js\n//This file is automatically rebuilt by the Cesium build process.\n/* harmony default export */ var epsilon7 = ("/**\\n\\\n * 0.0000001\\n\\\n *\\n\\\n * @name czm_epsilon7\\n\\\n * @glslConstant\\n\\\n */\\n\\\nconst float czm_epsilon7 = 0.0000001;\\n\\\n");\n\n;// CONCATENATED MODULE: ./node_modules/cesium/Source/Shaders/Builtin/Constants/infinity.js\n//This file is automatically rebuilt by the Cesium build process.\n/* harmony default export */ var infinity = ("/**\\n\\\n * DOC_TBA\\n\\\n *\\n\\\n * @name czm_infinity\\n\\\n * @glslConstant\\n\\\n */\\n\\\nconst float czm_infinity = 5906376272000.0;  // Distance from the Sun to Pluto in meters.  TODO: What is best given lowp, mediump, and highp?\\n\\\n");\n\n;// CONCATENATED MODULE: ./node_modules/cesium/Source/Shaders/Builtin/Constants/oneOverPi.js\n//This file is automatically rebuilt by the Cesium build process.\n/* harmony default export */ var oneOverPi = ("/**\\n\\\n * A built-in GLSL floating-point constant for <code>1/pi</code>.\\n\\\n *\\n\\\n * @alias czm_oneOverPi\\n\\\n * @glslConstant\\n\\\n *\\n\\\n * @see CesiumMath.ONE_OVER_PI\\n\\\n *\\n\\\n * @example\\n\\\n * // GLSL declaration\\n\\\n * const float czm_oneOverPi = ...;\\n\\\n *\\n\\\n * // Example\\n\\\n * float pi = 1.0 / czm_oneOverPi;\\n\\\n */\\n\\\nconst float czm_oneOverPi = 0.3183098861837907;\\n\\\n");\n\n;// CONCATENATED MODULE: ./node_modules/cesium/Source/Shaders/Builtin/Constants/oneOverTwoPi.js\n//This file is automatically rebuilt by the Cesium build process.\n/* harmony default export */ var oneOverTwoPi = ("/**\\n\\\n * A built-in GLSL floating-point constant for <code>1/2pi</code>.\\n\\\n *\\n\\\n * @alias czm_oneOverTwoPi\\n\\\n * @glslConstant\\n\\\n *\\n\\\n * @see CesiumMath.ONE_OVER_TWO_PI\\n\\\n *\\n\\\n * @example\\n\\\n * // GLSL declaration\\n\\\n * const float czm_oneOverTwoPi = ...;\\n\\\n *\\n\\\n * // Example\\n\\\n * float pi = 2.0 * czm_oneOverTwoPi;\\n\\\n */\\n\\\nconst float czm_oneOverTwoPi = 0.15915494309189535;\\n\\\n");\n\n;// CONCATENATED MODULE: ./node_modules/cesium/Source/Shaders/Builtin/Constants/passCesium3DTile.js\n//This file is automatically rebuilt by the Cesium build process.\n/* harmony default export */ var passCesium3DTile = ("/**\\n\\\n * The automatic GLSL constant for {@link Pass#CESIUM_3D_TILE}\\n\\\n *\\n\\\n * @name czm_passCesium3DTile\\n\\\n * @glslConstant\\n\\\n *\\n\\\n * @see czm_pass\\n\\\n */\\n\\\nconst float czm_passCesium3DTile = 4.0;\\n\\\n");\n\n;// CONCATENATED MODULE: ./node_modules/cesium/Source/Shaders/Builtin/Constants/passCesium3DTileClassification.js\n//This file is automatically rebuilt by the Cesium build process.\n/* harmony default export */ var passCesium3DTileClassification = ("/**\\n\\\n * The automatic GLSL constant for {@link Pass#CESIUM_3D_TILE_CLASSIFICATION}\\n\\\n *\\n\\\n * @name czm_passCesium3DTileClassification\\n\\\n * @glslConstant\\n\\\n *\\n\\\n * @see czm_pass\\n\\\n */\\n\\\nconst float czm_passCesium3DTileClassification = 5.0;\\n\\\n");\n\n;// CONCATENATED MODULE: ./node_modules/cesium/Source/Shaders/Builtin/Constants/passCesium3DTileClassificationIgnoreShow.js\n//This file is automatically rebuilt by the Cesium build process.\n/* harmony default export */ var passCesium3DTileClassificationIgnoreShow = ("/**\\n\\\n * The automatic GLSL constant for {@link Pass#CESIUM_3D_TILE_CLASSIFICATION_IGNORE_SHOW}\\n\\\n *\\n\\\n * @name czm_passCesium3DTileClassificationIgnoreShow\\n\\\n * @glslConstant\\n\\\n *\\n\\\n * @see czm_pass\\n\\\n */\\n\\\nconst float czm_passCesium3DTileClassificationIgnoreShow = 6.0;\\n\\\n");\n\n;// CONCATENATED MODULE: ./node_modules/cesium/Source/Shaders/Builtin/Constants/passClassification.js\n//This file is automatically rebuilt by the Cesium build process.\n/* harmony default export */ var passClassification = ("/**\\n\\\n * The automatic GLSL constant for {@link Pass#CLASSIFICATION}\\n\\\n *\\n\\\n * @name czm_passClassification\\n\\\n * @glslConstant\\n\\\n *\\n\\\n * @see czm_pass\\n\\\n */\\n\\\nconst float czm_passClassification = 7.0;\\n\\\n");\n\n;// CONCATENATED MODULE: ./node_modules/cesium/Source/Shaders/Builtin/Constants/passCompute.js\n//This file is automatically rebuilt by the Cesium build process.\n/* harmony default export */ var passCompute = ("/**\\n\\\n * The automatic GLSL constant for {@link Pass#COMPUTE}\\n\\\n *\\n\\\n * @name czm_passCompute\\n\\\n * @glslConstant\\n\\\n *\\n\\\n * @see czm_pass\\n\\\n */\\n\\\nconst float czm_passCompute = 1.0;\\n\\\n");\n\n;// CONCATENATED MODULE: ./node_modules/cesium/Source/Shaders/Builtin/Constants/passEnvironment.js\n//This file is automatically rebuilt by the Cesium build process.\n/* harmony default export */ var passEnvironment = ("/**\\n\\\n * The automatic GLSL constant for {@link Pass#ENVIRONMENT}\\n\\\n *\\n\\\n * @name czm_passEnvironment\\n\\\n * @glslConstant\\n\\\n *\\n\\\n * @see czm_pass\\n\\\n */\\n\\\nconst float czm_passEnvironment = 0.0;\\n\\\n");\n\n;// CONCATENATED MODULE: ./node_modules/cesium/Source/Shaders/Builtin/Constants/passGlobe.js\n//This file is automatically rebuilt by the Cesium build process.\n/* harmony default export */ var passGlobe = ("/**\\n\\\n * The automatic GLSL constant for {@link Pass#GLOBE}\\n\\\n *\\n\\\n * @name czm_passGlobe\\n\\\n * @glslConstant\\n\\\n *\\n\\\n * @see czm_pass\\n\\\n */\\n\\\nconst float czm_passGlobe = 2.0;\\n\\\n");\n\n;// CONCATENATED MODULE: ./node_modules/cesium/Source/Shaders/Builtin/Constants/passOpaque.js\n//This file is automatically rebuilt by the Cesium build process.\n/* harmony default export */ var passOpaque = ("/**\\n\\\n * The automatic GLSL constant for {@link Pass#OPAQUE}\\n\\\n *\\n\\\n * @name czm_passOpaque\\n\\\n * @glslConstant\\n\\\n *\\n\\\n * @see czm_pass\\n\\\n */\\n\\\nconst float czm_passOpaque = 7.0;\\n\\\n");\n\n;// CONCATENATED MODULE: ./node_modules/cesium/Source/Shaders/Builtin/Constants/passOverlay.js\n//This file is automatically rebuilt by the Cesium build process.\n/* harmony default export */ var passOverlay = ("/**\\n\\\n * The automatic GLSL constant for {@link Pass#OVERLAY}\\n\\\n *\\n\\\n * @name czm_passOverlay\\n\\\n * @glslConstant\\n\\\n *\\n\\\n * @see czm_pass\\n\\\n */\\n\\\nconst float czm_passOverlay = 9.0;\\n\\\n");\n\n;// CONCATENATED MODULE: ./node_modules/cesium/Source/Shaders/Builtin/Constants/passTerrainClassification.js\n//This file is automatically rebuilt by the Cesium build process.\n/* harmony default export */ var passTerrainClassification = ("/**\\n\\\n * The automatic GLSL constant for {@link Pass#TERRAIN_CLASSIFICATION}\\n\\\n *\\n\\\n * @name czm_passTerrainClassification\\n\\\n * @glslConstant\\n\\\n *\\n\\\n * @see czm_pass\\n\\\n */\\n\\\nconst float czm_passTerrainClassification = 3.0;\\n\\\n");\n\n;// CONCATENATED MODULE: ./node_modules/cesium/Source/Shaders/Builtin/Constants/passTranslucent.js\n//This file is automatically rebuilt by the Cesium build process.\n/* harmony default export */ var passTranslucent = ("/**\\n\\\n * The automatic GLSL constant for {@link Pass#TRANSLUCENT}\\n\\\n *\\n\\\n * @name czm_passTranslucent\\n\\\n * @glslConstant\\n\\\n *\\n\\\n * @see czm_pass\\n\\\n */\\n\\\nconst float czm_passTranslucent = 8.0;\\n\\\n");\n\n;// CONCATENATED MODULE: ./node_modules/cesium/Source/Shaders/Builtin/Constants/pi.js\n//This file is automatically rebuilt by the Cesium build process.\n/* harmony default export */ var pi = ("/**\\n\\\n * A built-in GLSL floating-point constant for <code>Math.PI</code>.\\n\\\n *\\n\\\n * @alias czm_pi\\n\\\n * @glslConstant\\n\\\n *\\n\\\n * @see CesiumMath.PI\\n\\\n *\\n\\\n * @example\\n\\\n * // GLSL declaration\\n\\\n * const float czm_pi = ...;\\n\\\n *\\n\\\n * // Example\\n\\\n * float twoPi = 2.0 * czm_pi;\\n\\\n */\\n\\\nconst float czm_pi = 3.141592653589793;\\n\\\n");\n\n;// CONCATENATED MODULE: ./node_modules/cesium/Source/Shaders/Builtin/Constants/piOverFour.js\n//This file is automatically rebuilt by the Cesium build process.\n/* harmony default export */ var piOverFour = ("/**\\n\\\n * A built-in GLSL floating-point constant for <code>pi/4</code>.\\n\\\n *\\n\\\n * @alias czm_piOverFour\\n\\\n * @glslConstant\\n\\\n *\\n\\\n * @see CesiumMath.PI_OVER_FOUR\\n\\\n *\\n\\\n * @example\\n\\\n * // GLSL declaration\\n\\\n * const float czm_piOverFour = ...;\\n\\\n *\\n\\\n * // Example\\n\\\n * float pi = 4.0 * czm_piOverFour;\\n\\\n */\\n\\\nconst float czm_piOverFour = 0.7853981633974483;\\n\\\n");\n\n;// CONCATENATED MODULE: ./node_modules/cesium/Source/Shaders/Builtin/Constants/piOverSix.js\n//This file is automatically rebuilt by the Cesium build process.\n/* harmony default export */ var piOverSix = ("/**\\n\\\n * A built-in GLSL floating-point constant for <code>pi/6</code>.\\n\\\n *\\n\\\n * @alias czm_piOverSix\\n\\\n * @glslConstant\\n\\\n *\\n\\\n * @see CesiumMath.PI_OVER_SIX\\n\\\n *\\n\\\n * @example\\n\\\n * // GLSL declaration\\n\\\n * const float czm_piOverSix = ...;\\n\\\n *\\n\\\n * // Example\\n\\\n * float pi = 6.0 * czm_piOverSix;\\n\\\n */\\n\\\nconst float czm_piOverSix = 0.5235987755982988;\\n\\\n");\n\n;// CONCATENATED MODULE: ./node_modules/cesium/Source/Shaders/Builtin/Constants/piOverThree.js\n//This file is automatically rebuilt by the Cesium build process.\n/* harmony default export */ var piOverThree = ("/**\\n\\\n * A built-in GLSL floating-point constant for <code>pi/3</code>.\\n\\\n *\\n\\\n * @alias czm_piOverThree\\n\\\n * @glslConstant\\n\\\n *\\n\\\n * @see CesiumMath.PI_OVER_THREE\\n\\\n *\\n\\\n * @example\\n\\\n * // GLSL declaration\\n\\\n * const float czm_piOverThree = ...;\\n\\\n *\\n\\\n * // Example\\n\\\n * float pi = 3.0 * czm_piOverThree;\\n\\\n */\\n\\\nconst float czm_piOverThree = 1.0471975511965976;\\n\\\n");\n\n;// CONCATENATED MODULE: ./node_modules/cesium/Source/Shaders/Builtin/Constants/piOverTwo.js\n//This file is automatically rebuilt by the Cesium build process.\n/* harmony default export */ var piOverTwo = ("/**\\n\\\n * A built-in GLSL floating-point constant for <code>pi/2</code>.\\n\\\n *\\n\\\n * @alias czm_piOverTwo\\n\\\n * @glslConstant\\n\\\n *\\n\\\n * @see CesiumMath.PI_OVER_TWO\\n\\\n *\\n\\\n * @example\\n\\\n * // GLSL declaration\\n\\\n * const float czm_piOverTwo = ...;\\n\\\n *\\n\\\n * // Example\\n\\\n * float pi = 2.0 * czm_piOverTwo;\\n\\\n */\\n\\\nconst float czm_piOverTwo = 1.5707963267948966;\\n\\\n");\n\n;// CONCATENATED MODULE: ./node_modules/cesium/Source/Shaders/Builtin/Constants/radiansPerDegree.js\n//This file is automatically rebuilt by the Cesium build process.\n/* harmony default export */ var radiansPerDegree = ("/**\\n\\\n * A built-in GLSL floating-point constant for converting degrees to radians.\\n\\\n *\\n\\\n * @alias czm_radiansPerDegree\\n\\\n * @glslConstant\\n\\\n *\\n\\\n * @see CesiumMath.RADIANS_PER_DEGREE\\n\\\n *\\n\\\n * @example\\n\\\n * // GLSL declaration\\n\\\n * const float czm_radiansPerDegree = ...;\\n\\\n *\\n\\\n * // Example\\n\\\n * float rad = czm_radiansPerDegree * deg;\\n\\\n */\\n\\\nconst float czm_radiansPerDegree = 0.017453292519943295;\\n\\\n");\n\n;// CONCATENATED MODULE: ./node_modules/cesium/Source/Shaders/Builtin/Constants/sceneMode2D.js\n//This file is automatically rebuilt by the Cesium build process.\n/* harmony default export */ var sceneMode2D = ("/**\\n\\\n * The constant identifier for the 2D {@link SceneMode}\\n\\\n *\\n\\\n * @name czm_sceneMode2D\\n\\\n * @glslConstant\\n\\\n * @see czm_sceneMode\\n\\\n * @see czm_sceneModeColumbusView\\n\\\n * @see czm_sceneMode3D\\n\\\n * @see czm_sceneModeMorphing\\n\\\n */\\n\\\nconst float czm_sceneMode2D = 2.0;\\n\\\n");\n\n;// CONCATENATED MODULE: ./node_modules/cesium/Source/Shaders/Builtin/Constants/sceneMode3D.js\n//This file is automatically rebuilt by the Cesium build process.\n/* harmony default export */ var sceneMode3D = ("/**\\n\\\n * The constant identifier for the 3D {@link SceneMode}\\n\\\n *\\n\\\n * @name czm_sceneMode3D\\n\\\n * @glslConstant\\n\\\n * @see czm_sceneMode\\n\\\n * @see czm_sceneMode2D\\n\\\n * @see czm_sceneModeColumbusView\\n\\\n * @see czm_sceneModeMorphing\\n\\\n */\\n\\\nconst float czm_sceneMode3D = 3.0;\\n\\\n");\n\n;// CONCATENATED MODULE: ./node_modules/cesium/Source/Shaders/Builtin/Constants/sceneModeColumbusView.js\n//This file is automatically rebuilt by the Cesium build process.\n/* harmony default export */ var sceneModeColumbusView = ("/**\\n\\\n * The constant identifier for the Columbus View {@link SceneMode}\\n\\\n *\\n\\\n * @name czm_sceneModeColumbusView\\n\\\n * @glslConstant\\n\\\n * @see czm_sceneMode\\n\\\n * @see czm_sceneMode2D\\n\\\n * @see czm_sceneMode3D\\n\\\n * @see czm_sceneModeMorphing\\n\\\n */\\n\\\nconst float czm_sceneModeColumbusView = 1.0;\\n\\\n");\n\n;// CONCATENATED MODULE: ./node_modules/cesium/Source/Shaders/Builtin/Constants/sceneModeMorphing.js\n//This file is automatically rebuilt by the Cesium build process.\n/* harmony default export */ var sceneModeMorphing = ("/**\\n\\\n * The constant identifier for the Morphing {@link SceneMode}\\n\\\n *\\n\\\n * @name czm_sceneModeMorphing\\n\\\n * @glslConstant\\n\\\n * @see czm_sceneMode\\n\\\n * @see czm_sceneMode2D\\n\\\n * @see czm_sceneModeColumbusView\\n\\\n * @see czm_sceneMode3D\\n\\\n */\\n\\\nconst float czm_sceneModeMorphing = 0.0;\\n\\\n");\n\n;// CONCATENATED MODULE: ./node_modules/cesium/Source/Shaders/Builtin/Constants/solarRadius.js\n//This file is automatically rebuilt by the Cesium build process.\n/* harmony default export */ var solarRadius = ("/**\\n\\\n * A built-in GLSL floating-point constant for one solar radius.\\n\\\n *\\n\\\n * @alias czm_solarRadius\\n\\\n * @glslConstant\\n\\\n *\\n\\\n * @see CesiumMath.SOLAR_RADIUS\\n\\\n *\\n\\\n * @example\\n\\\n * // GLSL declaration\\n\\\n * const float czm_solarRadius = ...;\\n\\\n */\\n\\\nconst float czm_solarRadius = 695500000.0;\\n\\\n");\n\n;// CONCATENATED MODULE: ./node_modules/cesium/Source/Shaders/Builtin/Constants/threePiOver2.js\n//This file is automatically rebuilt by the Cesium build process.\n/* harmony default export */ var threePiOver2 = ("/**\\n\\\n * A built-in GLSL floating-point constant for <code>3pi/2</code>.\\n\\\n *\\n\\\n * @alias czm_threePiOver2\\n\\\n * @glslConstant\\n\\\n *\\n\\\n * @see CesiumMath.THREE_PI_OVER_TWO\\n\\\n *\\n\\\n * @example\\n\\\n * // GLSL declaration\\n\\\n * const float czm_threePiOver2 = ...;\\n\\\n *\\n\\\n * // Example\\n\\\n * float pi = (2.0 / 3.0) * czm_threePiOver2;\\n\\\n */\\n\\\nconst float czm_threePiOver2 = 4.71238898038469;\\n\\\n");\n\n;// CONCATENATED MODULE: ./node_modules/cesium/Source/Shaders/Builtin/Constants/twoPi.js\n//This file is automatically rebuilt by the Cesium build process.\n/* harmony default export */ var twoPi = ("/**\\n\\\n * A built-in GLSL floating-point constant for <code>2pi</code>.\\n\\\n *\\n\\\n * @alias czm_twoPi\\n\\\n * @glslConstant\\n\\\n *\\n\\\n * @see CesiumMath.TWO_PI\\n\\\n *\\n\\\n * @example\\n\\\n * // GLSL declaration\\n\\\n * const float czm_twoPi = ...;\\n\\\n *\\n\\\n * // Example\\n\\\n * float pi = czm_twoPi / 2.0;\\n\\\n */\\n\\\nconst float czm_twoPi = 6.283185307179586;\\n\\\n");\n\n;// CONCATENATED MODULE: ./node_modules/cesium/Source/Shaders/Builtin/Constants/webMercatorMaxLatitude.js\n//This file is automatically rebuilt by the Cesium build process.\n/* harmony default export */ var webMercatorMaxLatitude = ("/**\\n\\\n * The maximum latitude, in radians, both North and South, supported by a Web Mercator\\n\\\n * (EPSG:3857) projection.  Technically, the Mercator projection is defined\\n\\\n * for any latitude up to (but not including) 90 degrees, but it makes sense\\n\\\n * to cut it off sooner because it grows exponentially with increasing latitude.\\n\\\n * The logic behind this particular cutoff value, which is the one used by\\n\\\n * Google Maps, Bing Maps, and Esri, is that it makes the projection\\n\\\n * square.  That is, the rectangle is equal in the X and Y directions.\\n\\\n *\\n\\\n * The constant value is computed as follows:\\n\\\n *   czm_pi * 0.5 - (2.0 * atan(exp(-czm_pi)))\\n\\\n *\\n\\\n * @name czm_webMercatorMaxLatitude\\n\\\n * @glslConstant\\n\\\n */\\n\\\nconst float czm_webMercatorMaxLatitude = 1.4844222297453324;\\n\\\n");\n\n;// CONCATENATED MODULE: ./node_modules/cesium/Source/Shaders/Builtin/Structs/depthRangeStruct.js\n//This file is automatically rebuilt by the Cesium build process.\n/* harmony default export */ var depthRangeStruct = ("/**\\n\\\n * @name czm_depthRangeStruct\\n\\\n * @glslStruct\\n\\\n */\\n\\\nstruct czm_depthRangeStruct\\n\\\n{\\n\\\n    float near;\\n\\\n    float far;\\n\\\n};\\n\\\n");\n\n;// CONCATENATED MODULE: ./node_modules/cesium/Source/Shaders/Builtin/Structs/material.js\n//This file is automatically rebuilt by the Cesium build process.\n/* harmony default export */ var material = ("/**\\n\\\n * Holds material information that can be used for lighting. Returned by all czm_getMaterial functions.\\n\\\n *\\n\\\n * @name czm_material\\n\\\n * @glslStruct\\n\\\n *\\n\\\n * @property {vec3} diffuse Incoming light that scatters evenly in all directions.\\n\\\n * @property {float} specular Intensity of incoming light reflecting in a single direction.\\n\\\n * @property {float} shininess The sharpness of the specular reflection.  Higher values create a smaller, more focused specular highlight.\\n\\\n * @property {vec3} normal Surface\'s normal in eye coordinates. It is used for effects such as normal mapping. The default is the surface\'s unmodified normal.\\n\\\n * @property {vec3} emission Light emitted by the material equally in all directions. The default is vec3(0.0), which emits no light.\\n\\\n * @property {float} alpha Alpha of this material. 0.0 is completely transparent; 1.0 is completely opaque.\\n\\\n */\\n\\\nstruct czm_material\\n\\\n{\\n\\\n    vec3 diffuse;\\n\\\n    float specular;\\n\\\n    float shininess;\\n\\\n    vec3 normal;\\n\\\n    vec3 emission;\\n\\\n    float alpha;\\n\\\n};\\n\\\n");\n\n;// CONCATENATED MODULE: ./node_modules/cesium/Source/Shaders/Builtin/Structs/materialInput.js\n//This file is automatically rebuilt by the Cesium build process.\n/* harmony default export */ var materialInput = ("/**\\n\\\n * Used as input to every material\'s czm_getMaterial function.\\n\\\n *\\n\\\n * @name czm_materialInput\\n\\\n * @glslStruct\\n\\\n *\\n\\\n * @property {float} s 1D texture coordinates.\\n\\\n * @property {vec2} st 2D texture coordinates.\\n\\\n * @property {vec3} str 3D texture coordinates.\\n\\\n * @property {vec3} normalEC Unperturbed surface normal in eye coordinates.\\n\\\n * @property {mat3} tangentToEyeMatrix Matrix for converting a tangent space normal to eye space.\\n\\\n * @property {vec3} positionToEyeEC Vector from the fragment to the eye in eye coordinates.  The magnitude is the distance in meters from the fragment to the eye.\\n\\\n * @property {float} height The height of the terrain in meters above or below the WGS84 ellipsoid.  Only available for globe materials.\\n\\\n * @property {float} slope The slope of the terrain in radians.  0 is flat; pi/2 is vertical.  Only available for globe materials.\\n\\\n * @property {float} aspect The aspect of the terrain in radians.  0 is East, pi/2 is North, pi is West, 3pi/2 is South.  Only available for globe materials.\\n\\\n */\\n\\\nstruct czm_materialInput\\n\\\n{\\n\\\n    float s;\\n\\\n    vec2 st;\\n\\\n    vec3 str;\\n\\\n    vec3 normalEC;\\n\\\n    mat3 tangentToEyeMatrix;\\n\\\n    vec3 positionToEyeEC;\\n\\\n    float height;\\n\\\n    float slope;\\n\\\n    float aspect;\\n\\\n};\\n\\\n");\n\n;// CONCATENATED MODULE: ./node_modules/cesium/Source/Shaders/Builtin/Structs/modelMaterial.js\n//This file is automatically rebuilt by the Cesium build process.\n/* harmony default export */ var modelMaterial = ("/**\\n\\\n * Struct for representing a material for a {@link ModelExperimental}. The model\\n\\\n * rendering pipeline will pass this struct between material, custom shaders,\\n\\\n * and lighting stages. This is not to be confused with {@link czm_material}\\n\\\n * which is used by the older Fabric materials system, although they are similar\\n\\\n *\\n\\\n * @name czm_modelMaterial\\n\\\n * @glslStruct\\n\\\n *\\n\\\n * @property {vec3} diffuse Incoming light that scatters evenly in all directions.\\n\\\n * @property {float} alpha Alpha of this material. 0.0 is completely transparent; 1.0 is completely opaque.\\n\\\n * @property {vec3} specular Color of reflected light at normal incidence in PBR materials. This is sometimes referred to as f0 in the literature.\\n\\\n * @property {float} roughness A number from 0.0 to 1.0 representing how rough the surface is. Values near 0.0 produce glossy surfaces, while values near 1.0 produce rough surfaces.\\n\\\n * @property {vec3} normal Surface\'s normal in eye coordinates. It is used for effects such as normal mapping. The default is the surface\'s unmodified normal.\\n\\\n * @property {float} occlusion Ambient occlusion recieved at this point on the material. 1.0 means fully lit, 0.0 means fully occluded.\\n\\\n * @property {vec3} emissive Light emitted by the material equally in all directions. The default is vec3(0.0), which emits no light.\\n\\\n */\\n\\\nstruct czm_modelMaterial {\\n\\\n    vec3 diffuse;\\n\\\n    float alpha;\\n\\\n    vec3 specular;\\n\\\n    float roughness;\\n\\\n    vec3 normal;\\n\\\n    float occlusion;\\n\\\n    vec3 emissive;\\n\\\n};\\n\\\n");\n\n;// CONCATENATED MODULE: ./node_modules/cesium/Source/Shaders/Builtin/Structs/pbrParameters.js\n//This file is automatically rebuilt by the Cesium build process.\n/* harmony default export */ var pbrParameters = ("/**\\n\\\n * Parameters for {@link czm_pbrLighting}\\n\\\n *\\n\\\n * @name czm_material\\n\\\n * @glslStruct\\n\\\n *\\n\\\n * @property {vec3} diffuseColor the diffuse color of the material for the lambert term of the rendering equation\\n\\\n * @property {float} roughness a value from 0.0 to 1.0 that indicates how rough the surface of the material is.\\n\\\n * @property {vec3} f0 The reflectance of the material at normal incidence\\n\\\n */\\n\\\nstruct czm_pbrParameters\\n\\\n{\\n\\\n    vec3 diffuseColor;\\n\\\n    float roughness;\\n\\\n    vec3 f0;\\n\\\n};\\n\\\n");\n\n;// CONCATENATED MODULE: ./node_modules/cesium/Source/Shaders/Builtin/Structs/ray.js\n//This file is automatically rebuilt by the Cesium build process.\n/* harmony default export */ var ray = ("/**\\n\\\n * DOC_TBA\\n\\\n *\\n\\\n * @name czm_ray\\n\\\n * @glslStruct\\n\\\n */\\n\\\nstruct czm_ray\\n\\\n{\\n\\\n    vec3 origin;\\n\\\n    vec3 direction;\\n\\\n};\\n\\\n");\n\n;// CONCATENATED MODULE: ./node_modules/cesium/Source/Shaders/Builtin/Structs/raySegment.js\n//This file is automatically rebuilt by the Cesium build process.\n/* harmony default export */ var raySegment = ("/**\\n\\\n * DOC_TBA\\n\\\n *\\n\\\n * @name czm_raySegment\\n\\\n * @glslStruct\\n\\\n */\\n\\\nstruct czm_raySegment\\n\\\n{\\n\\\n    float start;\\n\\\n    float stop;\\n\\\n};\\n\\\n\\n\\\n/**\\n\\\n * DOC_TBA\\n\\\n *\\n\\\n * @name czm_emptyRaySegment\\n\\\n * @glslConstant \\n\\\n */\\n\\\nconst czm_raySegment czm_emptyRaySegment = czm_raySegment(-czm_infinity, -czm_infinity);\\n\\\n\\n\\\n/**\\n\\\n * DOC_TBA\\n\\\n *\\n\\\n * @name czm_fullRaySegment\\n\\\n * @glslConstant \\n\\\n */\\n\\\nconst czm_raySegment czm_fullRaySegment = czm_raySegment(0.0, czm_infinity);\\n\\\n");\n\n;// CONCATENATED MODULE: ./node_modules/cesium/Source/Shaders/Builtin/Structs/shadowParameters.js\n//This file is automatically rebuilt by the Cesium build process.\n/* harmony default export */ var shadowParameters = ("struct czm_shadowParameters\\n\\\n{\\n\\\n#ifdef USE_CUBE_MAP_SHADOW\\n\\\n    vec3 texCoords;\\n\\\n#else\\n\\\n    vec2 texCoords;\\n\\\n#endif\\n\\\n\\n\\\n    float depthBias;\\n\\\n    float depth;\\n\\\n    float nDotL;\\n\\\n    vec2 texelStepSize;\\n\\\n    float normalShadingSmooth;\\n\\\n    float darkness;\\n\\\n};\\n\\\n");\n\n;// CONCATENATED MODULE: ./node_modules/cesium/Source/Shaders/Builtin/Functions/HSBToRGB.js\n//This file is automatically rebuilt by the Cesium build process.\n/* harmony default export */ var HSBToRGB = ("/**\\n\\\n * Converts an HSB color (hue, saturation, brightness) to RGB\\n\\\n * HSB <-> RGB conversion with minimal branching: {@link http://lolengine.net/blog/2013/07/27/rgb-to-hsv-in-glsl}\\n\\\n *\\n\\\n * @name czm_HSBToRGB\\n\\\n * @glslFunction\\n\\\n * \\n\\\n * @param {vec3} hsb The color in HSB.\\n\\\n *\\n\\\n * @returns {vec3} The color in RGB.\\n\\\n *\\n\\\n * @example\\n\\\n * vec3 hsb = czm_RGBToHSB(rgb);\\n\\\n * hsb.z *= 0.1;\\n\\\n * rgb = czm_HSBToRGB(hsb);\\n\\\n */\\n\\\n\\n\\\nconst vec4 K_HSB2RGB = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\\n\\\n\\n\\\nvec3 czm_HSBToRGB(vec3 hsb)\\n\\\n{\\n\\\n    vec3 p = abs(fract(hsb.xxx + K_HSB2RGB.xyz) * 6.0 - K_HSB2RGB.www);\\n\\\n    return hsb.z * mix(K_HSB2RGB.xxx, clamp(p - K_HSB2RGB.xxx, 0.0, 1.0), hsb.y);\\n\\\n}\\n\\\n");\n\n;// CONCATENATED MODULE: ./node_modules/cesium/Source/Shaders/Builtin/Functions/HSLToRGB.js\n//This file is automatically rebuilt by the Cesium build process.\n/* harmony default export */ var HSLToRGB = ("/**\\n\\\n * Converts an HSL color (hue, saturation, lightness) to RGB\\n\\\n * HSL <-> RGB conversion: {@link http://www.chilliant.com/rgb2hsv.html}\\n\\\n *\\n\\\n * @name czm_HSLToRGB\\n\\\n * @glslFunction\\n\\\n * \\n\\\n * @param {vec3} rgb The color in HSL.\\n\\\n *\\n\\\n * @returns {vec3} The color in RGB.\\n\\\n *\\n\\\n * @example\\n\\\n * vec3 hsl = czm_RGBToHSL(rgb);\\n\\\n * hsl.z *= 0.1;\\n\\\n * rgb = czm_HSLToRGB(hsl);\\n\\\n */\\n\\\n\\n\\\nvec3 hueToRGB(float hue)\\n\\\n{\\n\\\n    float r = abs(hue * 6.0 - 3.0) - 1.0;\\n\\\n    float g = 2.0 - abs(hue * 6.0 - 2.0);\\n\\\n    float b = 2.0 - abs(hue * 6.0 - 4.0);\\n\\\n    return clamp(vec3(r, g, b), 0.0, 1.0);\\n\\\n}\\n\\\n\\n\\\nvec3 czm_HSLToRGB(vec3 hsl)\\n\\\n{\\n\\\n    vec3 rgb = hueToRGB(hsl.x);\\n\\\n    float c = (1.0 - abs(2.0 * hsl.z - 1.0)) * hsl.y;\\n\\\n    return (rgb - 0.5) * c + hsl.z;\\n\\\n}\\n\\\n");\n\n;// CONCATENATED MODULE: ./node_modules/cesium/Source/Shaders/Builtin/Functions/RGBToHSB.js\n//This file is automatically rebuilt by the Cesium build process.\n/* harmony default export */ var RGBToHSB = ("/**\\n\\\n * Converts an RGB color to HSB (hue, saturation, brightness)\\n\\\n * HSB <-> RGB conversion with minimal branching: {@link http://lolengine.net/blog/2013/07/27/rgb-to-hsv-in-glsl}\\n\\\n *\\n\\\n * @name czm_RGBToHSB\\n\\\n * @glslFunction\\n\\\n * \\n\\\n * @param {vec3} rgb The color in RGB.\\n\\\n *\\n\\\n * @returns {vec3} The color in HSB.\\n\\\n *\\n\\\n * @example\\n\\\n * vec3 hsb = czm_RGBToHSB(rgb);\\n\\\n * hsb.z *= 0.1;\\n\\\n * rgb = czm_HSBToRGB(hsb);\\n\\\n */\\n\\\n\\n\\\nconst vec4 K_RGB2HSB = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\\n\\\n\\n\\\nvec3 czm_RGBToHSB(vec3 rgb)\\n\\\n{\\n\\\n    vec4 p = mix(vec4(rgb.bg, K_RGB2HSB.wz), vec4(rgb.gb, K_RGB2HSB.xy), step(rgb.b, rgb.g));\\n\\\n    vec4 q = mix(vec4(p.xyw, rgb.r), vec4(rgb.r, p.yzx), step(p.x, rgb.r));\\n\\\n\\n\\\n    float d = q.x - min(q.w, q.y);\\n\\\n    return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + czm_epsilon7)), d / (q.x + czm_epsilon7), q.x);\\n\\\n}\\n\\\n");\n\n;// CONCATENATED MODULE: ./node_modules/cesium/Source/Shaders/Builtin/Functions/RGBToHSL.js\n//This file is automatically rebuilt by the Cesium build process.\n/* harmony default export */ var RGBToHSL = ("/**\\n\\\n * Converts an RGB color to HSL (hue, saturation, lightness)\\n\\\n * HSL <-> RGB conversion: {@link http://www.chilliant.com/rgb2hsv.html}\\n\\\n *\\n\\\n * @name czm_RGBToHSL\\n\\\n * @glslFunction\\n\\\n * \\n\\\n * @param {vec3} rgb The color in RGB.\\n\\\n *\\n\\\n * @returns {vec3} The color in HSL.\\n\\\n *\\n\\\n * @example\\n\\\n * vec3 hsl = czm_RGBToHSL(rgb);\\n\\\n * hsl.z *= 0.1;\\n\\\n * rgb = czm_HSLToRGB(hsl);\\n\\\n */\\n\\\n \\n\\\nvec3 RGBtoHCV(vec3 rgb)\\n\\\n{\\n\\\n    // Based on work by Sam Hocevar and Emil Persson\\n\\\n    vec4 p = (rgb.g < rgb.b) ? vec4(rgb.bg, -1.0, 2.0 / 3.0) : vec4(rgb.gb, 0.0, -1.0 / 3.0);\\n\\\n    vec4 q = (rgb.r < p.x) ? vec4(p.xyw, rgb.r) : vec4(rgb.r, p.yzx);\\n\\\n    float c = q.x - min(q.w, q.y);\\n\\\n    float h = abs((q.w - q.y) / (6.0 * c + czm_epsilon7) + q.z);\\n\\\n    return vec3(h, c, q.x);\\n\\\n}\\n\\\n\\n\\\nvec3 czm_RGBToHSL(vec3 rgb)\\n\\\n{\\n\\\n    vec3 hcv = RGBtoHCV(rgb);\\n\\\n    float l = hcv.z - hcv.y * 0.5;\\n\\\n    float s = hcv.y / (1.0 - abs(l * 2.0 - 1.0) + czm_epsilon7);\\n\\\n    return vec3(hcv.x, s, l);\\n\\\n}\\n\\\n");\n\n;// CONCATENATED MODULE: ./node_modules/cesium/Source/Shaders/Builtin/Functions/RGBToXYZ.js\n//This file is automatically rebuilt by the Cesium build process.\n/* harmony default export */ var RGBToXYZ = ("/**\\n\\\n * Converts an RGB color to CIE Yxy.\\n\\\n * <p>The conversion is described in\\n\\\n * {@link http://content.gpwiki.org/index.php/D3DBook:High-Dynamic_Range_Rendering#Luminance_Transform|Luminance Transform}\\n\\\n * </p>\\n\\\n * \\n\\\n * @name czm_RGBToXYZ\\n\\\n * @glslFunction\\n\\\n * \\n\\\n * @param {vec3} rgb The color in RGB.\\n\\\n *\\n\\\n * @returns {vec3} The color in CIE Yxy.\\n\\\n *\\n\\\n * @example\\n\\\n * vec3 xyz = czm_RGBToXYZ(rgb);\\n\\\n * xyz.x = max(xyz.x - luminanceThreshold, 0.0);\\n\\\n * rgb = czm_XYZToRGB(xyz);\\n\\\n */\\n\\\nvec3 czm_RGBToXYZ(vec3 rgb)\\n\\\n{\\n\\\n    const mat3 RGB2XYZ = mat3(0.4124, 0.2126, 0.0193,\\n\\\n                              0.3576, 0.7152, 0.1192,\\n\\\n                              0.1805, 0.0722, 0.9505);\\n\\\n    vec3 xyz = RGB2XYZ * rgb;\\n\\\n    vec3 Yxy;\\n\\\n    Yxy.r = xyz.g;\\n\\\n    float temp = dot(vec3(1.0), xyz);\\n\\\n    Yxy.gb = xyz.rg / temp;\\n\\\n    return Yxy;\\n\\\n}\\n\\\n");\n\n;// CONCATENATED MODULE: ./node_modules/cesium/Source/Shaders/Builtin/Functions/XYZToRGB.js\n//This file is automatically rebuilt by the Cesium build process.\n/* harmony default export */ var XYZToRGB = ("/**\\n\\\n * Converts a CIE Yxy color to RGB.\\n\\\n * <p>The conversion is described in\\n\\\n * {@link http://content.gpwiki.org/index.php/D3DBook:High-Dynamic_Range_Rendering#Luminance_Transform|Luminance Transform}\\n\\\n * </p>\\n\\\n * \\n\\\n * @name czm_XYZToRGB\\n\\\n * @glslFunction\\n\\\n * \\n\\\n * @param {vec3} Yxy The color in CIE Yxy.\\n\\\n *\\n\\\n * @returns {vec3} The color in RGB.\\n\\\n *\\n\\\n * @example\\n\\\n * vec3 xyz = czm_RGBToXYZ(rgb);\\n\\\n * xyz.x = max(xyz.x - luminanceThreshold, 0.0);\\n\\\n * rgb = czm_XYZToRGB(xyz);\\n\\\n */\\n\\\nvec3 czm_XYZToRGB(vec3 Yxy)\\n\\\n{\\n\\\n    const mat3 XYZ2RGB = mat3( 3.2405, -0.9693,  0.0556,\\n\\\n                              -1.5371,  1.8760, -0.2040,\\n\\\n                              -0.4985,  0.0416,  1.0572);\\n\\\n    vec3 xyz;\\n\\\n    xyz.r = Yxy.r * Yxy.g / Yxy.b;\\n\\\n    xyz.g = Yxy.r;\\n\\\n    xyz.b = Yxy.r * (1.0 - Yxy.g - Yxy.b) / Yxy.b;\\n\\\n    \\n\\\n    return XYZ2RGB * xyz;\\n\\\n}\\n\\\n");\n\n;// CONCATENATED MODULE: ./node_modules/cesium/Source/Shaders/Builtin/Functions/acesTonemapping.js\n//This file is automatically rebuilt by the Cesium build process.\n/* harmony default export */ var acesTonemapping = ("// See:\\n\\\n//    https://knarkowicz.wordpress.com/2016/01/06/aces-filmic-tone-mapping-curve/\\n\\\n\\n\\\nvec3 czm_acesTonemapping(vec3 color) {\\n\\\n    float g = 0.985;\\n\\\n    float a = 0.065;\\n\\\n    float b = 0.0001;\\n\\\n    float c = 0.433;\\n\\\n    float d = 0.238;\\n\\\n\\n\\\n    color = (color * (color + a) - b) / (color * (g * color + c) + d);\\n\\\n\\n\\\n    color = clamp(color, 0.0, 1.0);\\n\\\n\\n\\\n    return color;\\n\\\n}\\n\\\n");\n\n;// CONCATENATED MODULE: ./node_modules/cesium/Source/Shaders/Builtin/Functions/alphaWeight.js\n//This file is automatically rebuilt by the Cesium build process.\n/* harmony default export */ var alphaWeight = ("/**\\n\\\n * @private\\n\\\n */\\n\\\nfloat czm_alphaWeight(float a)\\n\\\n{\\n\\\n    float z = (gl_FragCoord.z - czm_viewportTransformation[3][2]) / czm_viewportTransformation[2][2];\\n\\\n\\n\\\n    // See Weighted Blended Order-Independent Transparency for examples of different weighting functions:\\n\\\n    // http://jcgt.org/published/0002/02/09/\\n\\\n    return pow(a + 0.01, 4.0) + max(1e-2, min(3.0 * 1e3, 0.003 / (1e-5 + pow(abs(z) / 200.0, 4.0))));\\n\\\n}\\n\\\n");\n\n;// CONCATENATED MODULE: ./node_modules/cesium/Source/Shaders/Builtin/Functions/antialias.js\n//This file is automatically rebuilt by the Cesium build process.\n/* harmony default export */ var antialias = ("/**\\n\\\n * Procedural anti-aliasing by blurring two colors that meet at a sharp edge.\\n\\\n *\\n\\\n * @name czm_antialias\\n\\\n * @glslFunction\\n\\\n *\\n\\\n * @param {vec4} color1 The color on one side of the edge.\\n\\\n * @param {vec4} color2 The color on the other side of the edge.\\n\\\n * @param {vec4} currentcolor The current color, either <code>color1</code> or <code>color2</code>.\\n\\\n * @param {float} dist The distance to the edge in texture coordinates.\\n\\\n * @param {float} [fuzzFactor=0.1] Controls the blurriness between the two colors.\\n\\\n * @returns {vec4} The anti-aliased color.\\n\\\n *\\n\\\n * @example\\n\\\n * // GLSL declarations\\n\\\n * vec4 czm_antialias(vec4 color1, vec4 color2, vec4 currentColor, float dist, float fuzzFactor);\\n\\\n * vec4 czm_antialias(vec4 color1, vec4 color2, vec4 currentColor, float dist);\\n\\\n *\\n\\\n * // get the color for a material that has a sharp edge at the line y = 0.5 in texture space\\n\\\n * float dist = abs(textureCoordinates.t - 0.5);\\n\\\n * vec4 currentColor = mix(bottomColor, topColor, step(0.5, textureCoordinates.t));\\n\\\n * vec4 color = czm_antialias(bottomColor, topColor, currentColor, dist, 0.1);\\n\\\n */\\n\\\nvec4 czm_antialias(vec4 color1, vec4 color2, vec4 currentColor, float dist, float fuzzFactor)\\n\\\n{\\n\\\n    float val1 = clamp(dist / fuzzFactor, 0.0, 1.0);\\n\\\n    float val2 = clamp((dist - 0.5) / fuzzFactor, 0.0, 1.0);\\n\\\n    val1 = val1 * (1.0 - val2);\\n\\\n    val1 = val1 * val1 * (3.0 - (2.0 * val1));\\n\\\n    val1 = pow(val1, 0.5); //makes the transition nicer\\n\\\n    \\n\\\n    vec4 midColor = (color1 + color2) * 0.5;\\n\\\n    return mix(midColor, currentColor, val1);\\n\\\n}\\n\\\n\\n\\\nvec4 czm_antialias(vec4 color1, vec4 color2, vec4 currentColor, float dist)\\n\\\n{\\n\\\n    return czm_antialias(color1, color2, currentColor, dist, 0.1);\\n\\\n}\\n\\\n");\n\n;// CONCATENATED MODULE: ./node_modules/cesium/Source/Shaders/Builtin/Functions/approximateSphericalCoordinates.js\n//This file is automatically rebuilt by the Cesium build process.\n/* harmony default export */ var approximateSphericalCoordinates = ("/**\\n\\\n * Approximately computes spherical coordinates given a normal.\\n\\\n * Uses approximate inverse trigonometry for speed and consistency,\\n\\\n * since inverse trigonometry can differ from vendor-to-vendor and when compared with the CPU.\\n\\\n *\\n\\\n * @name czm_approximateSphericalCoordinates\\n\\\n * @glslFunction\\n\\\n *\\n\\\n * @param {vec3} normal arbitrary-length normal.\\n\\\n *\\n\\\n * @returns {vec2} Approximate latitude and longitude spherical coordinates.\\n\\\n */\\n\\\nvec2 czm_approximateSphericalCoordinates(vec3 normal) {\\n\\\n    // Project into plane with vertical for latitude\\n\\\n    float latitudeApproximation = czm_fastApproximateAtan(sqrt(normal.x * normal.x + normal.y * normal.y), normal.z);\\n\\\n    float longitudeApproximation = czm_fastApproximateAtan(normal.x, normal.y);\\n\\\n    return vec2(latitudeApproximation, longitudeApproximation);\\n\\\n}\\n\\\n");\n\n;// CONCATENATED MODULE: ./node_modules/cesium/Source/Shaders/Builtin/Functions/backFacing.js\n//This file is automatically rebuilt by the Cesium build process.\n/* harmony default export */ var backFacing = ("/**\\n\\\n * Determines if the fragment is back facing\\n\\\n *\\n\\\n * @name czm_backFacing\\n\\\n * @glslFunction \\n\\\n * \\n\\\n * @returns {bool} <code>true</code> if the fragment is back facing; otherwise, <code>false</code>.\\n\\\n */\\n\\\nbool czm_backFacing()\\n\\\n{\\n\\\n    // !gl_FrontFacing doesn\'t work as expected on Mac/Intel so use the more verbose form instead. See https://github.com/CesiumGS/cesium/pull/8494.\\n\\\n    return gl_FrontFacing == false;\\n\\\n}\\n\\\n");\n\n;// CONCATENATED MODULE: ./node_modules/cesium/Source/Shaders/Builtin/Functions/branchFreeTernary.js\n//This file is automatically rebuilt by the Cesium build process.\n/* harmony default export */ var branchFreeTernary = ("/**\\n\\\n * Branchless ternary operator to be used when it\'s inexpensive to explicitly\\n\\\n * evaluate both possibilities for a float expression.\\n\\\n *\\n\\\n * @name czm_branchFreeTernary\\n\\\n * @glslFunction\\n\\\n *\\n\\\n * @param {bool} comparison A comparison statement\\n\\\n * @param {float} a Value to return if the comparison is true.\\n\\\n * @param {float} b Value to return if the comparison is false.\\n\\\n *\\n\\\n * @returns {float} equivalent of comparison ? a : b\\n\\\n */\\n\\\nfloat czm_branchFreeTernary(bool comparison, float a, float b) {\\n\\\n    float useA = float(comparison);\\n\\\n    return a * useA + b * (1.0 - useA);\\n\\\n}\\n\\\n\\n\\\n/**\\n\\\n * Branchless ternary operator to be used when it\'s inexpensive to explicitly\\n\\\n * evaluate both possibilities for a vec2 expression.\\n\\\n *\\n\\\n * @name czm_branchFreeTernary\\n\\\n * @glslFunction\\n\\\n *\\n\\\n * @param {bool} comparison A comparison statement\\n\\\n * @param {vec2} a Value to return if the comparison is true.\\n\\\n * @param {vec2} b Value to return if the comparison is false.\\n\\\n *\\n\\\n * @returns {vec2} equivalent of comparison ? a : b\\n\\\n */\\n\\\nvec2 czm_branchFreeTernary(bool comparison, vec2 a, vec2 b) {\\n\\\n    float useA = float(comparison);\\n\\\n    return a * useA + b * (1.0 - useA);\\n\\\n}\\n\\\n\\n\\\n/**\\n\\\n * Branchless ternary operator to be used when it\'s inexpensive to explicitly\\n\\\n * evaluate both possibilities for a vec3 expression.\\n\\\n *\\n\\\n * @name czm_branchFreeTernary\\n\\\n * @glslFunction\\n\\\n *\\n\\\n * @param {bool} comparison A comparison statement\\n\\\n * @param {vec3} a Value to return if the comparison is true.\\n\\\n * @param {vec3} b Value to return if the comparison is false.\\n\\\n *\\n\\\n * @returns {vec3} equivalent of comparison ? a : b\\n\\\n */\\n\\\nvec3 czm_branchFreeTernary(bool comparison, vec3 a, vec3 b) {\\n\\\n    float useA = float(comparison);\\n\\\n    return a * useA + b * (1.0 - useA);\\n\\\n}\\n\\\n\\n\\\n/**\\n\\\n * Branchless ternary operator to be used when it\'s inexpensive to explicitly\\n\\\n * evaluate both possibilities for a vec4 expression.\\n\\\n *\\n\\\n * @name czm_branchFreeTernary\\n\\\n * @glslFunction\\n\\\n *\\n\\\n * @param {bool} comparison A comparison statement\\n\\\n * @param {vec3} a Value to return if the comparison is true.\\n\\\n * @param {vec3} b Value to return if the comparison is false.\\n\\\n *\\n\\\n * @returns {vec3} equivalent of comparison ? a : b\\n\\\n */\\n\\\nvec4 czm_branchFreeTernary(bool comparison, vec4 a, vec4 b) {\\n\\\n    float useA = float(comparison);\\n\\\n    return a * useA + b * (1.0 - useA);\\n\\\n}\\n\\\n");\n\n;// CONCATENATED MODULE: ./node_modules/cesium/Source/Shaders/Builtin/Functions/cascadeColor.js\n//This file is automatically rebuilt by the Cesium build process.\n/* harmony default export */ var cascadeColor = ("\\n\\\nvec4 czm_cascadeColor(vec4 weights)\\n\\\n{\\n\\\n    return vec4(1.0, 0.0, 0.0, 1.0) * weights.x +\\n\\\n           vec4(0.0, 1.0, 0.0, 1.0) * weights.y +\\n\\\n           vec4(0.0, 0.0, 1.0, 1.0) * weights.z +\\n\\\n           vec4(1.0, 0.0, 1.0, 1.0) * weights.w;\\n\\\n}\\n\\\n");\n\n;// CONCATENATED MODULE: ./node_modules/cesium/Source/Shaders/Builtin/Functions/cascadeDistance.js\n//This file is automatically rebuilt by the Cesium build process.\n/* harmony default export */ var cascadeDistance = ("\\n\\\nuniform vec4 shadowMap_cascadeDistances;\\n\\\n\\n\\\nfloat czm_cascadeDistance(vec4 weights)\\n\\\n{\\n\\\n    return dot(shadowMap_cascadeDistances, weights);\\n\\\n}\\n\\\n");\n\n;// CONCATENATED MODULE: ./node_modules/cesium/Source/Shaders/Builtin/Functions/cascadeMatrix.js\n//This file is automatically rebuilt by the Cesium build process.\n/* harmony default export */ var cascadeMatrix = ("\\n\\\nuniform mat4 shadowMap_cascadeMatrices[4];\\n\\\n\\n\\\nmat4 czm_cascadeMatrix(vec4 weights)\\n\\\n{\\n\\\n    return shadowMap_cascadeMatrices[0] * weights.x +\\n\\\n           shadowMap_cascadeMatrices[1] * weights.y +\\n\\\n           shadowMap_cascadeMatrices[2] * weights.z +\\n\\\n           shadowMap_cascadeMatrices[3] * weights.w;\\n\\\n}\\n\\\n");\n\n;// CONCATENATED MODULE: ./node_modules/cesium/Source/Shaders/Builtin/Functions/cascadeWeights.js\n//This file is automatically rebuilt by the Cesium build process.\n/* harmony default export */ var cascadeWeights = ("\\n\\\nuniform vec4 shadowMap_cascadeSplits[2];\\n\\\n\\n\\\nvec4 czm_cascadeWeights(float depthEye)\\n\\\n{\\n\\\n    // One component is set to 1.0 and all others set to 0.0.\\n\\\n    vec4 near = step(shadowMap_cascadeSplits[0], vec4(depthEye));\\n\\\n    vec4 far = step(depthEye, shadowMap_cascadeSplits[1]);\\n\\\n    return near * far;\\n\\\n}\\n\\\n");\n\n;// CONCATENATED MODULE: ./node_modules/cesium/Source/Shaders/Builtin/Functions/columbusViewMorph.js\n//This file is automatically rebuilt by the Cesium build process.\n/* harmony default export */ var columbusViewMorph = ("/**\\n\\\n * DOC_TBA\\n\\\n *\\n\\\n * @name czm_columbusViewMorph\\n\\\n * @glslFunction\\n\\\n */\\n\\\nvec4 czm_columbusViewMorph(vec4 position2D, vec4 position3D, float time)\\n\\\n{\\n\\\n    // Just linear for now.\\n\\\n    vec3 p = mix(position2D.xyz, position3D.xyz, time);\\n\\\n    return vec4(p, 1.0);\\n\\\n}\\n\\\n");\n\n;// CONCATENATED MODULE: ./node_modules/cesium/Source/Shaders/Builtin/Functions/computePosition.js\n//This file is automatically rebuilt by the Cesium build process.\n/* harmony default export */ var computePosition = ("/**\\n\\\n * Returns a position in model coordinates relative to eye taking into\\n\\\n * account the current scene mode: 3D, 2D, or Columbus view.\\n\\\n * <p>\\n\\\n * This uses standard position attributes, <code>position3DHigh</code>, \\n\\\n * <code>position3DLow</code>, <code>position2DHigh</code>, and <code>position2DLow</code>, \\n\\\n * and should be used when writing a vertex shader for an {@link Appearance}.\\n\\\n * </p>\\n\\\n *\\n\\\n * @name czm_computePosition\\n\\\n * @glslFunction\\n\\\n *\\n\\\n * @returns {vec4} The position relative to eye.\\n\\\n *\\n\\\n * @example\\n\\\n * vec4 p = czm_computePosition();\\n\\\n * v_positionEC = (czm_modelViewRelativeToEye * p).xyz;\\n\\\n * gl_Position = czm_modelViewProjectionRelativeToEye * p;\\n\\\n *\\n\\\n * @see czm_translateRelativeToEye\\n\\\n */\\n\\\nvec4 czm_computePosition();\\n\\\n");\n\n;// CONCATENATED MODULE: ./node_modules/cesium/Source/Shaders/Builtin/Functions/cosineAndSine.js\n//This file is automatically rebuilt by the Cesium build process.\n/* harmony default export */ var cosineAndSine = ("/**\\n\\\n * @private\\n\\\n */\\n\\\nvec2 cordic(float angle)\\n\\\n{\\n\\\n// Scale the vector by the appropriate factor for the 24 iterations to follow.\\n\\\n    vec2 vector = vec2(6.0725293500888267e-1, 0.0);\\n\\\n// Iteration 1\\n\\\n    float sense = (angle < 0.0) ? -1.0 : 1.0;\\n\\\n //   float factor = sense * 1.0;  // 2^-0\\n\\\n    mat2 rotation = mat2(1.0, sense, -sense, 1.0);\\n\\\n    vector = rotation * vector;\\n\\\n    angle -= sense * 7.8539816339744828e-1;  // atan(2^-0)\\n\\\n// Iteration 2\\n\\\n    sense = (angle < 0.0) ? -1.0 : 1.0;\\n\\\n    float factor = sense * 5.0e-1;  // 2^-1\\n\\\n    rotation[0][1] = factor;\\n\\\n    rotation[1][0] = -factor;\\n\\\n    vector = rotation * vector;\\n\\\n    angle -= sense * 4.6364760900080609e-1;  // atan(2^-1)\\n\\\n// Iteration 3\\n\\\n    sense = (angle < 0.0) ? -1.0 : 1.0;\\n\\\n    factor = sense * 2.5e-1;  // 2^-2\\n\\\n    rotation[0][1] = factor;\\n\\\n    rotation[1][0] = -factor;\\n\\\n    vector = rotation * vector;\\n\\\n    angle -= sense * 2.4497866312686414e-1;  // atan(2^-2)\\n\\\n// Iteration 4\\n\\\n    sense = (angle < 0.0) ? -1.0 : 1.0;\\n\\\n    factor = sense * 1.25e-1;  // 2^-3\\n\\\n    rotation[0][1] = factor;\\n\\\n    rotation[1][0] = -factor;\\n\\\n    vector = rotation * vector;\\n\\\n    angle -= sense * 1.2435499454676144e-1;  // atan(2^-3)\\n\\\n// Iteration 5\\n\\\n    sense = (angle < 0.0) ? -1.0 : 1.0;\\n\\\n    factor = sense * 6.25e-2;  // 2^-4\\n\\\n    rotation[0][1] = factor;\\n\\\n    rotation[1][0] = -factor;\\n\\\n    vector = rotation * vector;\\n\\\n    angle -= sense * 6.2418809995957350e-2;  // atan(2^-4)\\n\\\n// Iteration 6\\n\\\n    sense = (angle < 0.0) ? -1.0 : 1.0;\\n\\\n    factor = sense * 3.125e-2;  // 2^-5\\n\\\n    rotation[0][1] = factor;\\n\\\n    rotation[1][0] = -factor;\\n\\\n    vector = rotation * vector;\\n\\\n    angle -= sense * 3.1239833430268277e-2;  // atan(2^-5)\\n\\\n// Iteration 7\\n\\\n    sense = (angle < 0.0) ? -1.0 : 1.0;\\n\\\n    factor = sense * 1.5625e-2;  // 2^-6\\n\\\n    rotation[0][1] = factor;\\n\\\n    rotation[1][0] = -factor;\\n\\\n    vector = rotation * vector;\\n\\\n    angle -= sense * 1.5623728620476831e-2;  // atan(2^-6)\\n\\\n// Iteration 8\\n\\\n    sense = (angle < 0.0) ? -1.0 : 1.0;\\n\\\n    factor = sense * 7.8125e-3;  // 2^-7\\n\\\n    rotation[0][1] = factor;\\n\\\n    rotation[1][0] = -factor;\\n\\\n    vector = rotation * vector;\\n\\\n    angle -= sense * 7.8123410601011111e-3;  // atan(2^-7)\\n\\\n// Iteration 9\\n\\\n    sense = (angle < 0.0) ? -1.0 : 1.0;\\n\\\n    factor = sense * 3.90625e-3;  // 2^-8\\n\\\n    rotation[0][1] = factor;\\n\\\n    rotation[1][0] = -factor;\\n\\\n    vector = rotation * vector;\\n\\\n    angle -= sense * 3.9062301319669718e-3;  // atan(2^-8)\\n\\\n// Iteration 10\\n\\\n    sense = (angle < 0.0) ? -1.0 : 1.0;\\n\\\n    factor = sense * 1.953125e-3;  // 2^-9\\n\\\n    rotation[0][1] = factor;\\n\\\n    rotation[1][0] = -factor;\\n\\\n    vector = rotation * vector;\\n\\\n    angle -= sense * 1.9531225164788188e-3;  // atan(2^-9)\\n\\\n// Iteration 11\\n\\\n    sense = (angle < 0.0) ? -1.0 : 1.0;\\n\\\n    factor = sense * 9.765625e-4;  // 2^-10\\n\\\n    rotation[0][1] = factor;\\n\\\n    rotation[1][0] = -factor;\\n\\\n    vector = rotation * vector;\\n\\\n    angle -= sense * 9.7656218955931946e-4;  // atan(2^-10)\\n\\\n// Iteration 12\\n\\\n    sense = (angle < 0.0) ? -1.0 : 1.0;\\n\\\n    factor = sense * 4.8828125e-4;  // 2^-11\\n\\\n    rotation[0][1] = factor;\\n\\\n    rotation[1][0] = -factor;\\n\\\n    vector = rotation * vector;\\n\\\n    angle -= sense * 4.8828121119489829e-4;  // atan(2^-11)\\n\\\n// Iteration 13\\n\\\n    sense = (angle < 0.0) ? -1.0 : 1.0;\\n\\\n    factor = sense * 2.44140625e-4;  // 2^-12\\n\\\n    rotation[0][1] = factor;\\n\\\n    rotation[1][0] = -factor;\\n\\\n    vector = rotation * vector;\\n\\\n    angle -= sense * 2.4414062014936177e-4;  // atan(2^-12)\\n\\\n// Iteration 14\\n\\\n    sense = (angle < 0.0) ? -1.0 : 1.0;\\n\\\n    factor = sense * 1.220703125e-4;  // 2^-13\\n\\\n    rotation[0][1] = factor;\\n\\\n    rotation[1][0] = -factor;\\n\\\n    vector = rotation * vector;\\n\\\n    angle -= sense * 1.2207031189367021e-4;  // atan(2^-13)\\n\\\n// Iteration 15\\n\\\n    sense = (angle < 0.0) ? -1.0 : 1.0;\\n\\\n    factor = sense * 6.103515625e-5;  // 2^-14\\n\\\n    rotation[0][1] = factor;\\n\\\n    rotation[1][0] = -factor;\\n\\\n    vector = rotation * vector;\\n\\\n    angle -= sense * 6.1035156174208773e-5;  // atan(2^-14)\\n\\\n// Iteration 16\\n\\\n    sense = (angle < 0.0) ? -1.0 : 1.0;\\n\\\n    factor = sense * 3.0517578125e-5;  // 2^-15\\n\\\n    rotation[0][1] = factor;\\n\\\n    rotation[1][0] = -factor;\\n\\\n    vector = rotation * vector;\\n\\\n    angle -= sense * 3.0517578115526096e-5;  // atan(2^-15)\\n\\\n// Iteration 17\\n\\\n    sense = (angle < 0.0) ? -1.0 : 1.0;\\n\\\n    factor = sense * 1.52587890625e-5;  // 2^-16\\n\\\n    rotation[0][1] = factor;\\n\\\n    rotation[1][0] = -factor;\\n\\\n    vector = rotation * vector;\\n\\\n    angle -= sense * 1.5258789061315762e-5;  // atan(2^-16)\\n\\\n// Iteration 18\\n\\\n    sense = (angle < 0.0) ? -1.0 : 1.0;\\n\\\n    factor = sense * 7.62939453125e-6;  // 2^-17\\n\\\n    rotation[0][1] = factor;\\n\\\n    rotation[1][0] = -factor;\\n\\\n    vector = rotation * vector;\\n\\\n    angle -= sense * 7.6293945311019700e-6;  // atan(2^-17)\\n\\\n// Iteration 19\\n\\\n    sense = (angle < 0.0) ? -1.0 : 1.0;\\n\\\n    factor = sense * 3.814697265625e-6;  // 2^-18\\n\\\n    rotation[0][1] = factor;\\n\\\n    rotation[1][0] = -factor;\\n\\\n    vector = rotation * vector;\\n\\\n    angle -= sense * 3.8146972656064961e-6;  // atan(2^-18)\\n\\\n// Iteration 20\\n\\\n    sense = (angle < 0.0) ? -1.0 : 1.0;\\n\\\n    factor = sense * 1.9073486328125e-6;  // 2^-19\\n\\\n    rotation[0][1] = factor;\\n\\\n    rotation[1][0] = -factor;\\n\\\n    vector = rotation * vector;\\n\\\n    angle -= sense * 1.9073486328101870e-6;  // atan(2^-19)\\n\\\n// Iteration 21\\n\\\n    sense = (angle < 0.0) ? -1.0 : 1.0;\\n\\\n    factor = sense * 9.5367431640625e-7;  // 2^-20\\n\\\n    rotation[0][1] = factor;\\n\\\n    rotation[1][0] = -factor;\\n\\\n    vector = rotation * vector;\\n\\\n    angle -= sense * 9.5367431640596084e-7;  // atan(2^-20)\\n\\\n// Iteration 22\\n\\\n    sense = (angle < 0.0) ? -1.0 : 1.0;\\n\\\n    factor = sense * 4.76837158203125e-7;  // 2^-21\\n\\\n    rotation[0][1] = factor;\\n\\\n    rotation[1][0] = -factor;\\n\\\n    vector = rotation * vector;\\n\\\n    angle -= sense * 4.7683715820308884e-7;  // atan(2^-21)\\n\\\n// Iteration 23\\n\\\n    sense = (angle < 0.0) ? -1.0 : 1.0;\\n\\\n    factor = sense * 2.384185791015625e-7;  // 2^-22\\n\\\n    rotation[0][1] = factor;\\n\\\n    rotation[1][0] = -factor;\\n\\\n    vector = rotation * vector;\\n\\\n    angle -= sense * 2.3841857910155797e-7;  // atan(2^-22)\\n\\\n// Iteration 24\\n\\\n    sense = (angle < 0.0) ? -1.0 : 1.0;\\n\\\n    factor = sense * 1.1920928955078125e-7;  // 2^-23\\n\\\n    rotation[0][1] = factor;\\n\\\n    rotation[1][0] = -factor;\\n\\\n    vector = rotation * vector;\\n\\\n//    angle -= sense * 1.1920928955078068e-7;  // atan(2^-23)\\n\\\n\\n\\\n    return vector;\\n\\\n}\\n\\\n\\n\\\n/**\\n\\\n * Computes the cosine and sine of the provided angle using the CORDIC algorithm.\\n\\\n *\\n\\\n * @name czm_cosineAndSine\\n\\\n * @glslFunction\\n\\\n *\\n\\\n * @param {float} angle The angle in radians.\\n\\\n *\\n\\\n * @returns {vec2} The resulting cosine of the angle (as the x coordinate) and sine of the angle (as the y coordinate).\\n\\\n *\\n\\\n * @example\\n\\\n * vec2 v = czm_cosineAndSine(czm_piOverSix);\\n\\\n * float cosine = v.x;\\n\\\n * float sine = v.y;\\n\\\n */\\n\\\nvec2 czm_cosineAndSine(float angle)\\n\\\n{\\n\\\n    if (angle < -czm_piOverTwo || angle > czm_piOverTwo)\\n\\\n    {\\n\\\n        if (angle < 0.0)\\n\\\n        {\\n\\\n            return -cordic(angle + czm_pi);\\n\\\n        }\\n\\\n        else\\n\\\n        {\\n\\\n            return -cordic(angle - czm_pi);\\n\\\n        }\\n\\\n    }\\n\\\n    else\\n\\\n    {\\n\\\n        return cordic(angle);\\n\\\n    }\\n\\\n}\\n\\\n");\n\n;// CONCATENATED MODULE: ./node_modules/cesium/Source/Shaders/Builtin/Functions/decompressTextureCoordinates.js\n//This file is automatically rebuilt by the Cesium build process.\n/* harmony default export */ var decompressTextureCoordinates = ("/**\\n\\\n * Decompresses texture coordinates that were packed into a single float.\\n\\\n *\\n\\\n * @name czm_decompressTextureCoordinates\\n\\\n * @glslFunction\\n\\\n *\\n\\\n * @param {float} encoded The compressed texture coordinates.\\n\\\n * @returns {vec2} The decompressed texture coordinates.\\n\\\n */\\n\\\n vec2 czm_decompressTextureCoordinates(float encoded)\\n\\\n {\\n\\\n    float temp = encoded / 4096.0;\\n\\\n    float xZeroTo4095 = floor(temp);\\n\\\n    float stx = xZeroTo4095 / 4095.0;\\n\\\n    float sty = (encoded - xZeroTo4095 * 4096.0) / 4095.0;\\n\\\n    return vec2(stx, sty);\\n\\\n }\\n\\\n");\n\n;// CONCATENATED MODULE: ./node_modules/cesium/Source/Shaders/Builtin/Functions/defaultPbrMaterial.js\n//This file is automatically rebuilt by the Cesium build process.\n/* harmony default export */ var defaultPbrMaterial = ("/**\\n\\\n * Get default parameters for physically based rendering. These defaults\\n\\\n * describe a rough dielectric (non-metal) surface (e.g. rough plastic).\\n\\\n *\\n\\\n * @return {czm_pbrParameters} Default parameters for {@link czm_pbrLighting}\\n\\\n */\\n\\\nczm_pbrParameters czm_defaultPbrMaterial()\\n\\\n{\\n\\\n    czm_pbrParameters results;\\n\\\n    results.diffuseColor = vec3(1.0);\\n\\\n    results.roughness = 1.0;\\n\\\n\\n\\\n    const vec3 REFLECTANCE_DIELECTRIC = vec3(0.04);\\n\\\n    results.f0 = REFLECTANCE_DIELECTRIC;\\n\\\n    return results;\\n\\\n}\\n\\\n");\n\n;// CONCATENATED MODULE: ./node_modules/cesium/Source/Shaders/Builtin/Functions/depthClamp.js\n//This file is automatically rebuilt by the Cesium build process.\n/* harmony default export */ var depthClamp = ("// emulated noperspective\\n\\\n#if defined(GL_EXT_frag_depth) && !defined(LOG_DEPTH)\\n\\\nvarying float v_WindowZ;\\n\\\n#endif\\n\\\n\\n\\\n/**\\n\\\n * Emulates GL_DEPTH_CLAMP, which is not available in WebGL 1 or 2.\\n\\\n * GL_DEPTH_CLAMP clamps geometry that is outside the near and far planes, \\n\\\n * capping the shadow volume. More information here: \\n\\\n * https://www.khronos.org/registry/OpenGL/extensions/ARB/ARB_depth_clamp.txt.\\n\\\n *\\n\\\n * When GL_EXT_frag_depth is available we emulate GL_DEPTH_CLAMP by ensuring \\n\\\n * no geometry gets clipped by setting the clip space z value to 0.0 and then\\n\\\n * sending the unaltered screen space z value (using emulated noperspective\\n\\\n * interpolation) to the frag shader where it is clamped to [0,1] and then\\n\\\n * written with gl_FragDepth (see czm_writeDepthClamp). This technique is based on:\\n\\\n * https://stackoverflow.com/questions/5960757/how-to-emulate-gl-depth-clamp-nv.\\n\\\n *\\n\\\n * When GL_EXT_frag_depth is not available, which is the case on some mobile \\n\\\n * devices, we must attempt to fix this only in the vertex shader. \\n\\\n * The approach is to clamp the z value to the far plane, which closes the \\n\\\n * shadow volume but also distorts the geometry, so there can still be artifacts\\n\\\n * on frustum seams.\\n\\\n *\\n\\\n * @name czm_depthClamp\\n\\\n * @glslFunction\\n\\\n *\\n\\\n * @param {vec4} coords The vertex in clip coordinates.\\n\\\n * @returns {vec4} The modified vertex.\\n\\\n *\\n\\\n * @example\\n\\\n * gl_Position = czm_depthClamp(czm_modelViewProjection * vec4(position, 1.0));\\n\\\n *\\n\\\n * @see czm_writeDepthClamp\\n\\\n */\\n\\\nvec4 czm_depthClamp(vec4 coords)\\n\\\n{\\n\\\n#ifndef LOG_DEPTH\\n\\\n#ifdef GL_EXT_frag_depth\\n\\\n    v_WindowZ = (0.5 * (coords.z / coords.w) + 0.5) * coords.w;\\n\\\n    coords.z = 0.0;\\n\\\n#else\\n\\\n    coords.z = min(coords.z, coords.w);\\n\\\n#endif\\n\\\n#endif\\n\\\n    return coords;\\n\\\n}\\n\\\n");\n\n;// CONCATENATED MODULE: ./node_modules/cesium/Source/Shaders/Builtin/Functions/eastNorthUpToEyeCoordinates.js\n//This file is automatically rebuilt by the Cesium build process.\n/* harmony default export */ var eastNorthUpToEyeCoordinates = ("/**\\n\\\n * Computes a 3x3 rotation matrix that transforms vectors from an ellipsoid\'s east-north-up coordinate system \\n\\\n * to eye coordinates.  In east-north-up coordinates, x points east, y points north, and z points along the \\n\\\n * surface normal.  East-north-up can be used as an ellipsoid\'s tangent space for operations such as bump mapping.\\n\\\n * <br /><br />\\n\\\n * The ellipsoid is assumed to be centered at the model coordinate\'s origin.\\n\\\n *\\n\\\n * @name czm_eastNorthUpToEyeCoordinates\\n\\\n * @glslFunction\\n\\\n *\\n\\\n * @param {vec3} positionMC The position on the ellipsoid in model coordinates.\\n\\\n * @param {vec3} normalEC The normalized ellipsoid surface normal, at <code>positionMC</code>, in eye coordinates.\\n\\\n *\\n\\\n * @returns {mat3} A 3x3 rotation matrix that transforms vectors from the east-north-up coordinate system to eye coordinates.\\n\\\n *\\n\\\n * @example\\n\\\n * // Transform a vector defined in the east-north-up coordinate \\n\\\n * // system, (0, 0, 1) which is the surface normal, to eye \\n\\\n * // coordinates.\\n\\\n * mat3 m = czm_eastNorthUpToEyeCoordinates(positionMC, normalEC);\\n\\\n * vec3 normalEC = m * vec3(0.0, 0.0, 1.0);\\n\\\n */\\n\\\nmat3 czm_eastNorthUpToEyeCoordinates(vec3 positionMC, vec3 normalEC)\\n\\\n{\\n\\\n    vec3 tangentMC = normalize(vec3(-positionMC.y, positionMC.x, 0.0));  // normalized surface tangent in model coordinates\\n\\\n    vec3 tangentEC = normalize(czm_normal3D * tangentMC);                // normalized surface tangent in eye coordiantes\\n\\\n    vec3 bitangentEC = normalize(cross(normalEC, tangentEC));            // normalized surface bitangent in eye coordinates\\n\\\n\\n\\\n    return mat3(\\n\\\n        tangentEC.x,   tangentEC.y,   tangentEC.z,\\n\\\n        bitangentEC.x, bitangentEC.y, bitangentEC.z,\\n\\\n        normalEC.x,    normalEC.y,    normalEC.z);\\n\\\n}\\n\\\n");\n\n;// CONCATENATED MODULE: ./node_modules/cesium/Source/Shaders/Builtin/Functions/ellipsoidContainsPoint.js\n//This file is automatically rebuilt by the Cesium build process.\n/* harmony default export */ var ellipsoidContainsPoint = ("/**\\n\\\n * DOC_TBA\\n\\\n *\\n\\\n * @name czm_ellipsoidContainsPoint\\n\\\n * @glslFunction\\n\\\n *\\n\\\n */\\n\\\nbool czm_ellipsoidContainsPoint(vec3 ellipsoid_inverseRadii, vec3 point)\\n\\\n{\\n\\\n    vec3 scaled = ellipsoid_inverseRadii * (czm_inverseModelView * vec4(point, 1.0)).xyz;\\n\\\n    return (dot(scaled, scaled) <= 1.0);\\n\\\n}\\n\\\n");\n\n;// CONCATENATED MODULE: ./node_modules/cesium/Source/Shaders/Builtin/Functions/ellipsoidWgs84TextureCoordinates.js\n//This file is automatically rebuilt by the Cesium build process.\n/* harmony default export */ var ellipsoidWgs84TextureCoordinates = ("/**\\n\\\n * DOC_TBA\\n\\\n *\\n\\\n * @name czm_ellipsoidWgs84TextureCoordinates\\n\\\n * @glslFunction\\n\\\n */\\n\\\nvec2 czm_ellipsoidWgs84TextureCoordinates(vec3 normal)\\n\\\n{\\n\\\n    return vec2(atan(normal.y, normal.x) * czm_oneOverTwoPi + 0.5, asin(normal.z) * czm_oneOverPi + 0.5);\\n\\\n}\\n\\\n");\n\n;// CONCATENATED MODULE: ./node_modules/cesium/Source/Shaders/Builtin/Functions/equalsEpsilon.js\n//This file is automatically rebuilt by the Cesium build process.\n/* harmony default export */ var equalsEpsilon = ("/**\\n\\\n * Compares <code>left</code> and <code>right</code> componentwise. Returns <code>true</code>\\n\\\n * if they are within <code>epsilon</code> and <code>false</code> otherwise. The inputs\\n\\\n * <code>left</code> and <code>right</code> can be <code>float</code>s, <code>vec2</code>s,\\n\\\n * <code>vec3</code>s, or <code>vec4</code>s.\\n\\\n *\\n\\\n * @name czm_equalsEpsilon\\n\\\n * @glslFunction\\n\\\n *\\n\\\n * @param {} left The first vector.\\n\\\n * @param {} right The second vector.\\n\\\n * @param {float} epsilon The epsilon to use for equality testing.\\n\\\n * @returns {bool} <code>true</code> if the components are within <code>epsilon</code> and <code>false</code> otherwise.\\n\\\n *\\n\\\n * @example\\n\\\n * // GLSL declarations\\n\\\n * bool czm_equalsEpsilon(float left, float right, float epsilon);\\n\\\n * bool czm_equalsEpsilon(vec2 left, vec2 right, float epsilon);\\n\\\n * bool czm_equalsEpsilon(vec3 left, vec3 right, float epsilon);\\n\\\n * bool czm_equalsEpsilon(vec4 left, vec4 right, float epsilon);\\n\\\n */\\n\\\nbool czm_equalsEpsilon(vec4 left, vec4 right, float epsilon) {\\n\\\n    return all(lessThanEqual(abs(left - right), vec4(epsilon)));\\n\\\n}\\n\\\n\\n\\\nbool czm_equalsEpsilon(vec3 left, vec3 right, float epsilon) {\\n\\\n    return all(lessThanEqual(abs(left - right), vec3(epsilon)));\\n\\\n}\\n\\\n\\n\\\nbool czm_equalsEpsilon(vec2 left, vec2 right, float epsilon) {\\n\\\n    return all(lessThanEqual(abs(left - right), vec2(epsilon)));\\n\\\n}\\n\\\n\\n\\\nbool czm_equalsEpsilon(float left, float right, float epsilon) {\\n\\\n    return (abs(left - right) <= epsilon);\\n\\\n}\\n\\\n");\n\n;// CONCATENATED MODULE: ./node_modules/cesium/Source/Shaders/Builtin/Functions/eyeOffset.js\n//This file is automatically rebuilt by the Cesium build process.\n/* harmony default export */ var eyeOffset = ("/**\\n\\\n * DOC_TBA\\n\\\n *\\n\\\n * @name czm_eyeOffset\\n\\\n * @glslFunction\\n\\\n *\\n\\\n * @param {vec4} positionEC DOC_TBA.\\n\\\n * @param {vec3} eyeOffset DOC_TBA.\\n\\\n *\\n\\\n * @returns {vec4} DOC_TBA.\\n\\\n */\\n\\\nvec4 czm_eyeOffset(vec4 positionEC, vec3 eyeOffset)\\n\\\n{\\n\\\n    // This equation is approximate in x and y.\\n\\\n    vec4 p = positionEC;\\n\\\n    vec4 zEyeOffset = normalize(p) * eyeOffset.z;\\n\\\n    p.xy += eyeOffset.xy + zEyeOffset.xy;\\n\\\n    p.z += zEyeOffset.z;\\n\\\n    return p;\\n\\\n}\\n\\\n");\n\n;// CONCATENATED MODULE: ./node_modules/cesium/Source/Shaders/Builtin/Functions/eyeToWindowCoordinates.js\n//This file is automatically rebuilt by the Cesium build process.\n/* harmony default export */ var eyeToWindowCoordinates = ("/**\\n\\\n * Transforms a position from eye to window coordinates.  The transformation\\n\\\n * from eye to clip coordinates is done using {@link czm_projection}.\\n\\\n * The transform from normalized device coordinates to window coordinates is\\n\\\n * done using {@link czm_viewportTransformation}, which assumes a depth range\\n\\\n * of <code>near = 0</code> and <code>far = 1</code>.\\n\\\n * <br /><br />\\n\\\n * This transform is useful when there is a need to manipulate window coordinates\\n\\\n * in a vertex shader as done by {@link BillboardCollection}.\\n\\\n *\\n\\\n * @name czm_eyeToWindowCoordinates\\n\\\n * @glslFunction\\n\\\n *\\n\\\n * @param {vec4} position The position in eye coordinates to transform.\\n\\\n *\\n\\\n * @returns {vec4} The transformed position in window coordinates.\\n\\\n *\\n\\\n * @see czm_modelToWindowCoordinates\\n\\\n * @see czm_projection\\n\\\n * @see czm_viewportTransformation\\n\\\n * @see BillboardCollection\\n\\\n *\\n\\\n * @example\\n\\\n * vec4 positionWC = czm_eyeToWindowCoordinates(positionEC);\\n\\\n */\\n\\\nvec4 czm_eyeToWindowCoordinates(vec4 positionEC)\\n\\\n{\\n\\\n    vec4 q = czm_projection * positionEC;                        // clip coordinates\\n\\\n    q.xyz /= q.w;                                                // normalized device coordinates\\n\\\n    q.xyz = (czm_viewportTransformation * vec4(q.xyz, 1.0)).xyz; // window coordinates\\n\\\n    return q;\\n\\\n}\\n\\\n");\n\n;// CONCATENATED MODULE: ./node_modules/cesium/Source/Shaders/Builtin/Functions/fastApproximateAtan.js\n//This file is automatically rebuilt by the Cesium build process.\n/* harmony default export */ var fastApproximateAtan = ("/**\\n\\\n * Approxiamtes atan over the range [0, 1]. Safe to flip output for negative input.\\n\\\n *\\n\\\n * Based on Michal Drobot\'s approximation from ShaderFastLibs, which in turn is based on\\n\\\n * \\"Efficient approximations for the arctangent function,\\" Rajan, S. Sichun Wang Inkol, R. Joyal, A., May 2006.\\n\\\n * Adapted from ShaderFastLibs under MIT License.\\n\\\n *\\n\\\n * Chosen for the following characteristics over range [0, 1]:\\n\\\n * - basically no error at 0 and 1, important for getting around range limit (naive atan2 via atan requires infinite range atan)\\n\\\n * - no visible artifacts from first-derivative discontinuities, unlike latitude via range-reduced sqrt asin approximations (at equator)\\n\\\n *\\n\\\n * The original code is x * (-0.1784 * abs(x) - 0.0663 * x * x + 1.0301);\\n\\\n * Removed the abs() in here because it isn\'t needed, the input range is guaranteed as [0, 1] by how we\'re approximating atan2.\\n\\\n *\\n\\\n * @name czm_fastApproximateAtan\\n\\\n * @glslFunction\\n\\\n *\\n\\\n * @param {float} x Value between 0 and 1 inclusive.\\n\\\n *\\n\\\n * @returns {float} Approximation of atan(x)\\n\\\n */\\n\\\nfloat czm_fastApproximateAtan(float x) {\\n\\\n    return x * (-0.1784 * x - 0.0663 * x * x + 1.0301);\\n\\\n}\\n\\\n\\n\\\n/**\\n\\\n * Approximation of atan2.\\n\\\n *\\n\\\n * Range reduction math based on nvidia\'s cg reference implementation for atan2: http://developer.download.nvidia.com/cg/atan2.html\\n\\\n * However, we replaced their atan curve with Michael Drobot\'s (see above).\\n\\\n *\\n\\\n * @name czm_fastApproximateAtan\\n\\\n * @glslFunction\\n\\\n *\\n\\\n * @param {float} x Value between -1 and 1 inclusive.\\n\\\n * @param {float} y Value between -1 and 1 inclusive.\\n\\\n *\\n\\\n * @returns {float} Approximation of atan2(x, y)\\n\\\n */\\n\\\nfloat czm_fastApproximateAtan(float x, float y) {\\n\\\n    // atan approximations are usually only reliable over [-1, 1], or, in our case, [0, 1] due to modifications.\\n\\\n    // So range-reduce using abs and by flipping whether x or y is on top.\\n\\\n    float t = abs(x); // t used as swap and atan result.\\n\\\n    float opposite = abs(y);\\n\\\n    float adjacent = max(t, opposite);\\n\\\n    opposite = min(t, opposite);\\n\\\n\\n\\\n    t = czm_fastApproximateAtan(opposite / adjacent);\\n\\\n\\n\\\n    // Undo range reduction\\n\\\n    t = czm_branchFreeTernary(abs(y) > abs(x), czm_piOverTwo - t, t);\\n\\\n    t = czm_branchFreeTernary(x < 0.0, czm_pi - t, t);\\n\\\n    t = czm_branchFreeTernary(y < 0.0, -t, t);\\n\\\n    return t;\\n\\\n}\\n\\\n");\n\n;// CONCATENATED MODULE: ./node_modules/cesium/Source/Shaders/Builtin/Functions/fog.js\n//This file is automatically rebuilt by the Cesium build process.\n/* harmony default export */ var fog = ("/**\\n\\\n * Gets the color with fog at a distance from the camera.\\n\\\n *\\n\\\n * @name czm_fog\\n\\\n * @glslFunction\\n\\\n *\\n\\\n * @param {float} distanceToCamera The distance to the camera in meters.\\n\\\n * @param {vec3} color The original color.\\n\\\n * @param {vec3} fogColor The color of the fog.\\n\\\n *\\n\\\n * @returns {vec3} The color adjusted for fog at the distance from the camera.\\n\\\n */\\n\\\nvec3 czm_fog(float distanceToCamera, vec3 color, vec3 fogColor)\\n\\\n{\\n\\\n    float scalar = distanceToCamera * czm_fogDensity;\\n\\\n    float fog = 1.0 - exp(-(scalar * scalar));\\n\\\n    return mix(color, fogColor, fog);\\n\\\n}\\n\\\n\\n\\\n/**\\n\\\n * Gets the color with fog at a distance from the camera.\\n\\\n *\\n\\\n * @name czm_fog\\n\\\n * @glslFunction\\n\\\n *\\n\\\n * @param {float} distanceToCamera The distance to the camera in meters.\\n\\\n * @param {vec3} color The original color.\\n\\\n * @param {vec3} fogColor The color of the fog.\\n\\\n * @param {float} fogModifierConstant A constant to modify the appearance of fog.\\n\\\n *\\n\\\n * @returns {vec3} The color adjusted for fog at the distance from the camera.\\n\\\n */\\n\\\nvec3 czm_fog(float distanceToCamera, vec3 color, vec3 fogColor, float fogModifierConstant)\\n\\\n{\\n\\\n    float scalar = distanceToCamera * czm_fogDensity;\\n\\\n    float fog = 1.0 - exp(-((fogModifierConstant * scalar + fogModifierConstant) * (scalar * (1.0 + fogModifierConstant))));\\n\\\n    return mix(color, fogColor, fog);\\n\\\n}\\n\\\n");\n\n;// CONCATENATED MODULE: ./node_modules/cesium/Source/Shaders/Builtin/Functions/gammaCorrect.js\n//This file is automatically rebuilt by the Cesium build process.\n/* harmony default export */ var gammaCorrect = ("/**\\n\\\n * Converts a color from RGB space to linear space.\\n\\\n *\\n\\\n * @name czm_gammaCorrect\\n\\\n * @glslFunction\\n\\\n *\\n\\\n * @param {vec3} color The color in RGB space.\\n\\\n * @returns {vec3} The color in linear space.\\n\\\n */\\n\\\nvec3 czm_gammaCorrect(vec3 color) {\\n\\\n#ifdef HDR\\n\\\n    color = pow(color, vec3(czm_gamma));\\n\\\n#endif\\n\\\n    return color;\\n\\\n}\\n\\\n\\n\\\nvec4 czm_gammaCorrect(vec4 color) {\\n\\\n#ifdef HDR\\n\\\n    color.rgb = pow(color.rgb, vec3(czm_gamma));\\n\\\n#endif\\n\\\n    return color;\\n\\\n}\\n\\\n");\n\n;// CONCATENATED MODULE: ./node_modules/cesium/Source/Shaders/Builtin/Functions/geodeticSurfaceNormal.js\n//This file is automatically rebuilt by the Cesium build process.\n/* harmony default export */ var geodeticSurfaceNormal = ("/**\\n\\\n * DOC_TBA\\n\\\n *\\n\\\n * @name czm_geodeticSurfaceNormal\\n\\\n * @glslFunction\\n\\\n *\\n\\\n * @param {vec3} positionOnEllipsoid DOC_TBA\\n\\\n * @param {vec3} ellipsoidCenter DOC_TBA\\n\\\n * @param {vec3} oneOverEllipsoidRadiiSquared DOC_TBA\\n\\\n * \\n\\\n * @returns {vec3} DOC_TBA.\\n\\\n */\\n\\\nvec3 czm_geodeticSurfaceNormal(vec3 positionOnEllipsoid, vec3 ellipsoidCenter, vec3 oneOverEllipsoidRadiiSquared)\\n\\\n{\\n\\\n    return normalize((positionOnEllipsoid - ellipsoidCenter) * oneOverEllipsoidRadiiSquared);\\n\\\n}\\n\\\n");\n\n;// CONCATENATED MODULE: ./node_modules/cesium/Source/Shaders/Builtin/Functions/getDefaultMaterial.js\n//This file is automatically rebuilt by the Cesium build process.\n/* harmony default export */ var getDefaultMaterial = ("/**\\n\\\n * An czm_material with default values. Every material\'s czm_getMaterial\\n\\\n * should use this default material as a base for the material it returns.\\n\\\n * The default normal value is given by materialInput.normalEC.\\n\\\n *\\n\\\n * @name czm_getDefaultMaterial\\n\\\n * @glslFunction\\n\\\n *\\n\\\n * @param {czm_materialInput} input The input used to construct the default material.\\n\\\n *\\n\\\n * @returns {czm_material} The default material.\\n\\\n *\\n\\\n * @see czm_materialInput\\n\\\n * @see czm_material\\n\\\n * @see czm_getMaterial\\n\\\n */\\n\\\nczm_material czm_getDefaultMaterial(czm_materialInput materialInput)\\n\\\n{\\n\\\n    czm_material material;\\n\\\n    material.diffuse = vec3(0.0);\\n\\\n    material.specular = 0.0;\\n\\\n    material.shininess = 1.0;\\n\\\n    material.normal = materialInput.normalEC;\\n\\\n    material.emission = vec3(0.0);\\n\\\n    material.alpha = 1.0;\\n\\\n    return material;\\n\\\n}\\n\\\n");\n\n;// CONCATENATED MODULE: ./node_modules/cesium/Source/Shaders/Builtin/Functions/getLambertDiffuse.js\n//This file is automatically rebuilt by the Cesium build process.\n/* harmony default export */ var getLambertDiffuse = ("/**\\n\\\n * Calculates the intensity of diffusely reflected light.\\n\\\n *\\n\\\n * @name czm_getLambertDiffuse\\n\\\n * @glslFunction\\n\\\n *\\n\\\n * @param {vec3} lightDirectionEC Unit vector pointing to the light source in eye coordinates.\\n\\\n * @param {vec3} normalEC The surface normal in eye coordinates.\\n\\\n *\\n\\\n * @returns {float} The intensity of the diffuse reflection.\\n\\\n *\\n\\\n * @see czm_phong\\n\\\n *\\n\\\n * @example\\n\\\n * float diffuseIntensity = czm_getLambertDiffuse(lightDirectionEC, normalEC);\\n\\\n * float specularIntensity = czm_getSpecular(lightDirectionEC, toEyeEC, normalEC, 200);\\n\\\n * vec3 color = (diffuseColor * diffuseIntensity) + (specularColor * specularIntensity);\\n\\\n */\\n\\\nfloat czm_getLambertDiffuse(vec3 lightDirectionEC, vec3 normalEC)\\n\\\n{\\n\\\n    return max(dot(lightDirectionEC, normalEC), 0.0);\\n\\\n}\\n\\\n");\n\n;// CONCATENATED MODULE: ./node_modules/cesium/Source/Shaders/Builtin/Functions/getSpecular.js\n//This file is automatically rebuilt by the Cesium build process.\n/* harmony default export */ var getSpecular = ("/**\\n\\\n * Calculates the specular intensity of reflected light.\\n\\\n *\\n\\\n * @name czm_getSpecular\\n\\\n * @glslFunction\\n\\\n *\\n\\\n * @param {vec3} lightDirectionEC Unit vector pointing to the light source in eye coordinates.\\n\\\n * @param {vec3} toEyeEC Unit vector pointing to the eye position in eye coordinates.\\n\\\n * @param {vec3} normalEC The surface normal in eye coordinates.\\n\\\n * @param {float} shininess The sharpness of the specular reflection.  Higher values create a smaller, more focused specular highlight.\\n\\\n *\\n\\\n * @returns {float} The intensity of the specular highlight.\\n\\\n *\\n\\\n * @see czm_phong\\n\\\n *\\n\\\n * @example\\n\\\n * float diffuseIntensity = czm_getLambertDiffuse(lightDirectionEC, normalEC);\\n\\\n * float specularIntensity = czm_getSpecular(lightDirectionEC, toEyeEC, normalEC, 200);\\n\\\n * vec3 color = (diffuseColor * diffuseIntensity) + (specularColor * specularIntensity);\\n\\\n */\\n\\\nfloat czm_getSpecular(vec3 lightDirectionEC, vec3 toEyeEC, vec3 normalEC, float shininess)\\n\\\n{\\n\\\n    vec3 toReflectedLight = reflect(-lightDirectionEC, normalEC);\\n\\\n    float specular = max(dot(toReflectedLight, toEyeEC), 0.0);\\n\\\n\\n\\\n    // pow has undefined behavior if both parameters <= 0.\\n\\\n    // Prevent this by making sure shininess is at least czm_epsilon2.\\n\\\n    return pow(specular, max(shininess, czm_epsilon2));\\n\\\n}\\n\\\n");\n\n;// CONCATENATED MODULE: ./node_modules/cesium/Source/Shaders/Builtin/Functions/getWaterNoise.js\n//This file is automatically rebuilt by the Cesium build process.\n/* harmony default export */ var getWaterNoise = ("/**\\n\\\n * @private\\n\\\n */\\n\\\nvec4 czm_getWaterNoise(sampler2D normalMap, vec2 uv, float time, float angleInRadians)\\n\\\n{\\n\\\n    float cosAngle = cos(angleInRadians);\\n\\\n    float sinAngle = sin(angleInRadians);\\n\\\n\\n\\\n    // time dependent sampling directions\\n\\\n    vec2 s0 = vec2(1.0/17.0, 0.0);\\n\\\n    vec2 s1 = vec2(-1.0/29.0, 0.0);\\n\\\n    vec2 s2 = vec2(1.0/101.0, 1.0/59.0);\\n\\\n    vec2 s3 = vec2(-1.0/109.0, -1.0/57.0);\\n\\\n\\n\\\n    // rotate sampling direction by specified angle\\n\\\n    s0 = vec2((cosAngle * s0.x) - (sinAngle * s0.y), (sinAngle * s0.x) + (cosAngle * s0.y));\\n\\\n    s1 = vec2((cosAngle * s1.x) - (sinAngle * s1.y), (sinAngle * s1.x) + (cosAngle * s1.y));\\n\\\n    s2 = vec2((cosAngle * s2.x) - (sinAngle * s2.y), (sinAngle * s2.x) + (cosAngle * s2.y));\\n\\\n    s3 = vec2((cosAngle * s3.x) - (sinAngle * s3.y), (sinAngle * s3.x) + (cosAngle * s3.y));\\n\\\n\\n\\\n    vec2 uv0 = (uv/103.0) + (time * s0);\\n\\\n    vec2 uv1 = uv/107.0 + (time * s1) + vec2(0.23);\\n\\\n    vec2 uv2 = uv/vec2(897.0, 983.0) + (time * s2) + vec2(0.51);\\n\\\n    vec2 uv3 = uv/vec2(991.0, 877.0) + (time * s3) + vec2(0.71);\\n\\\n\\n\\\n    uv0 = fract(uv0);\\n\\\n    uv1 = fract(uv1);\\n\\\n    uv2 = fract(uv2);\\n\\\n    uv3 = fract(uv3);\\n\\\n    vec4 noise = (texture2D(normalMap, uv0)) +\\n\\\n                 (texture2D(normalMap, uv1)) +\\n\\\n                 (texture2D(normalMap, uv2)) +\\n\\\n                 (texture2D(normalMap, uv3));\\n\\\n\\n\\\n    // average and scale to between -1 and 1\\n\\\n    return ((noise / 4.0) - 0.5) * 2.0;\\n\\\n}\\n\\\n");\n\n;// CONCATENATED MODULE: ./node_modules/cesium/Source/Shaders/Builtin/Functions/hue.js\n//This file is automatically rebuilt by the Cesium build process.\n/* harmony default export */ var hue = ("/**\\n\\\n * Adjusts the hue of a color.\\n\\\n * \\n\\\n * @name czm_hue\\n\\\n * @glslFunction\\n\\\n * \\n\\\n * @param {vec3} rgb The color.\\n\\\n * @param {float} adjustment The amount to adjust the hue of the color in radians.\\n\\\n *\\n\\\n * @returns {float} The color with the hue adjusted.\\n\\\n *\\n\\\n * @example\\n\\\n * vec3 adjustHue = czm_hue(color, czm_pi); // The same as czm_hue(color, -czm_pi)\\n\\\n */\\n\\\nvec3 czm_hue(vec3 rgb, float adjustment)\\n\\\n{\\n\\\n    const mat3 toYIQ = mat3(0.299,     0.587,     0.114,\\n\\\n                            0.595716, -0.274453, -0.321263,\\n\\\n                            0.211456, -0.522591,  0.311135);\\n\\\n    const mat3 toRGB = mat3(1.0,  0.9563,  0.6210,\\n\\\n                            1.0, -0.2721, -0.6474,\\n\\\n                            1.0, -1.107,   1.7046);\\n\\\n    \\n\\\n    vec3 yiq = toYIQ * rgb;\\n\\\n    float hue = atan(yiq.z, yiq.y) + adjustment;\\n\\\n    float chroma = sqrt(yiq.z * yiq.z + yiq.y * yiq.y);\\n\\\n    \\n\\\n    vec3 color = vec3(yiq.x, chroma * cos(hue), chroma * sin(hue));\\n\\\n    return toRGB * color;\\n\\\n}\\n\\\n");\n\n;// CONCATENATED MODULE: ./node_modules/cesium/Source/Shaders/Builtin/Functions/inverseGamma.js\n//This file is automatically rebuilt by the Cesium build process.\n/* harmony default export */ var inverseGamma = ("/**\\n\\\n * Converts a color in linear space to RGB space.\\n\\\n *\\n\\\n * @name czm_inverseGamma\\n\\\n * @glslFunction\\n\\\n *\\n\\\n * @param {vec3} color The color in linear space.\\n\\\n * @returns {vec3} The color in RGB space.\\n\\\n */\\n\\\nvec3 czm_inverseGamma(vec3 color) {\\n\\\n    return pow(color, vec3(1.0 / czm_gamma));\\n\\\n}\\n\\\n");\n\n;// CONCATENATED MODULE: ./node_modules/cesium/Source/Shaders/Builtin/Functions/isEmpty.js\n//This file is automatically rebuilt by the Cesium build process.\n/* harmony default export */ var isEmpty = ("/**\\n\\\n * Determines if a time interval is empty.\\n\\\n *\\n\\\n * @name czm_isEmpty\\n\\\n * @glslFunction \\n\\\n * \\n\\\n * @param {czm_raySegment} interval The interval to test.\\n\\\n * \\n\\\n * @returns {bool} <code>true</code> if the time interval is empty; otherwise, <code>false</code>.\\n\\\n *\\n\\\n * @example\\n\\\n * bool b0 = czm_isEmpty(czm_emptyRaySegment);      // true\\n\\\n * bool b1 = czm_isEmpty(czm_raySegment(0.0, 1.0)); // false\\n\\\n * bool b2 = czm_isEmpty(czm_raySegment(1.0, 1.0)); // false, contains 1.0.\\n\\\n */\\n\\\nbool czm_isEmpty(czm_raySegment interval)\\n\\\n{\\n\\\n    return (interval.stop < 0.0);\\n\\\n}\\n\\\n");\n\n;// CONCATENATED MODULE: ./node_modules/cesium/Source/Shaders/Builtin/Functions/isFull.js\n//This file is automatically rebuilt by the Cesium build process.\n/* harmony default export */ var isFull = ("/**\\n\\\n * Determines if a time interval is empty.\\n\\\n *\\n\\\n * @name czm_isFull\\n\\\n * @glslFunction \\n\\\n * \\n\\\n * @param {czm_raySegment} interval The interval to test.\\n\\\n * \\n\\\n * @returns {bool} <code>true</code> if the time interval is empty; otherwise, <code>false</code>.\\n\\\n *\\n\\\n * @example\\n\\\n * bool b0 = czm_isEmpty(czm_emptyRaySegment);      // true\\n\\\n * bool b1 = czm_isEmpty(czm_raySegment(0.0, 1.0)); // false\\n\\\n * bool b2 = czm_isEmpty(czm_raySegment(1.0, 1.0)); // false, contains 1.0.\\n\\\n */\\n\\\nbool czm_isFull(czm_raySegment interval)\\n\\\n{\\n\\\n    return (interval.start == 0.0 && interval.stop == czm_infinity);\\n\\\n}\\n\\\n");\n\n;// CONCATENATED MODULE: ./node_modules/cesium/Source/Shaders/Builtin/Functions/latitudeToWebMercatorFraction.js\n//This file is automatically rebuilt by the Cesium build process.\n/* harmony default export */ var latitudeToWebMercatorFraction = ("/**\\n\\\n * Computes the fraction of a Web Wercator rectangle at which a given geodetic latitude is located.\\n\\\n *\\n\\\n * @name czm_latitudeToWebMercatorFraction\\n\\\n * @glslFunction\\n\\\n *\\n\\\n * @param {float} latitude The geodetic latitude, in radians.\\n\\\n * @param {float} southMercatorY The Web Mercator coordinate of the southern boundary of the rectangle.\\n\\\n * @param {float} oneOverMercatorHeight The total height of the rectangle in Web Mercator coordinates.\\n\\\n *\\n\\\n * @returns {float} The fraction of the rectangle at which the latitude occurs.  If the latitude is the southern\\n\\\n *          boundary of the rectangle, the return value will be zero.  If it is the northern boundary, the return\\n\\\n *          value will be 1.0.  Latitudes in between are mapped according to the Web Mercator projection.\\n\\\n */ \\n\\\nfloat czm_latitudeToWebMercatorFraction(float latitude, float southMercatorY, float oneOverMercatorHeight)\\n\\\n{\\n\\\n    float sinLatitude = sin(latitude);\\n\\\n    float mercatorY = 0.5 * log((1.0 + sinLatitude) / (1.0 - sinLatitude));\\n\\\n    \\n\\\n    return (mercatorY - southMercatorY) * oneOverMercatorHeight;\\n\\\n}\\n\\\n");\n\n;// CONCATENATED MODULE: ./node_modules/cesium/Source/Shaders/Builtin/Functions/lineDistance.js\n//This file is automatically rebuilt by the Cesium build process.\n/* harmony default export */ var lineDistance = ("/**\\n\\\n * Computes distance from an point in 2D to a line in 2D.\\n\\\n *\\n\\\n * @name czm_lineDistance\\n\\\n * @glslFunction\\n\\\n *\\n\\\n * param {vec2} point1 A point along the line.\\n\\\n * param {vec2} point2 A point along the line.\\n\\\n * param {vec2} point A point that may or may not be on the line.\\n\\\n * returns {float} The distance from the point to the line.\\n\\\n */\\n\\\nfloat czm_lineDistance(vec2 point1, vec2 point2, vec2 point) {\\n\\\n    return abs((point2.y - point1.y) * point.x - (point2.x - point1.x) * point.y + point2.x * point1.y - point2.y * point1.x) / distance(point2, point1);\\n\\\n}\\n\\\n");\n\n;// CONCATENATED MODULE: ./node_modules/cesium/Source/Shaders/Builtin/Functions/luminance.js\n//This file is automatically rebuilt by the Cesium build process.\n/* harmony default export */ var luminance = ("/**\\n\\\n * Computes the luminance of a color. \\n\\\n *\\n\\\n * @name czm_luminance\\n\\\n * @glslFunction\\n\\\n *\\n\\\n * @param {vec3} rgb The color.\\n\\\n * \\n\\\n * @returns {float} The luminance.\\n\\\n *\\n\\\n * @example\\n\\\n * float light = czm_luminance(vec3(0.0)); // 0.0\\n\\\n * float dark = czm_luminance(vec3(1.0));  // ~1.0 \\n\\\n */\\n\\\nfloat czm_luminance(vec3 rgb)\\n\\\n{\\n\\\n    // Algorithm from Chapter 10 of Graphics Shaders.\\n\\\n    const vec3 W = vec3(0.2125, 0.7154, 0.0721);\\n\\\n    return dot(rgb, W);\\n\\\n}\\n\\\n");\n\n;// CONCATENATED MODULE: ./node_modules/cesium/Source/Shaders/Builtin/Functions/metersPerPixel.js\n//This file is automatically rebuilt by the Cesium build process.\n/* harmony default export */ var metersPerPixel = ("/**\\n\\\n * Computes the size of a pixel in meters at a distance from the eye.\\n\\\n * <p>\\n\\\n * Use this version when passing in a custom pixel ratio. For example, passing in 1.0 will return meters per native device pixel.\\n\\\n * </p>\\n\\\n * @name czm_metersPerPixel\\n\\\n * @glslFunction\\n\\\n *\\n\\\n * @param {vec3} positionEC The position to get the meters per pixel in eye coordinates.\\n\\\n * @param {float} pixelRatio The scaling factor from pixel space to coordinate space\\n\\\n *\\n\\\n * @returns {float} The meters per pixel at positionEC.\\n\\\n */\\n\\\nfloat czm_metersPerPixel(vec4 positionEC, float pixelRatio)\\n\\\n{\\n\\\n    float width = czm_viewport.z;\\n\\\n    float height = czm_viewport.w;\\n\\\n    float pixelWidth;\\n\\\n    float pixelHeight;\\n\\\n\\n\\\n    float top = czm_frustumPlanes.x;\\n\\\n    float bottom = czm_frustumPlanes.y;\\n\\\n    float left = czm_frustumPlanes.z;\\n\\\n    float right = czm_frustumPlanes.w;\\n\\\n\\n\\\n    if (czm_sceneMode == czm_sceneMode2D || czm_orthographicIn3D == 1.0)\\n\\\n    {\\n\\\n        float frustumWidth = right - left;\\n\\\n        float frustumHeight = top - bottom;\\n\\\n        pixelWidth = frustumWidth / width;\\n\\\n        pixelHeight = frustumHeight / height;\\n\\\n    }\\n\\\n    else\\n\\\n    {\\n\\\n        float distanceToPixel = -positionEC.z;\\n\\\n        float inverseNear = 1.0 / czm_currentFrustum.x;\\n\\\n        float tanTheta = top * inverseNear;\\n\\\n        pixelHeight = 2.0 * distanceToPixel * tanTheta / height;\\n\\\n        tanTheta = right * inverseNear;\\n\\\n        pixelWidth = 2.0 * distanceToPixel * tanTheta / width;\\n\\\n    }\\n\\\n\\n\\\n    return max(pixelWidth, pixelHeight) * pixelRatio;\\n\\\n}\\n\\\n\\n\\\n/**\\n\\\n * Computes the size of a pixel in meters at a distance from the eye.\\n\\\n * <p>\\n\\\n * Use this version when scaling by pixel ratio.\\n\\\n * </p>\\n\\\n * @name czm_metersPerPixel\\n\\\n * @glslFunction\\n\\\n *\\n\\\n * @param {vec3} positionEC The position to get the meters per pixel in eye coordinates.\\n\\\n *\\n\\\n * @returns {float} The meters per pixel at positionEC.\\n\\\n */\\n\\\nfloat czm_metersPerPixel(vec4 positionEC)\\n\\\n{\\n\\\n    return czm_metersPerPixel(positionEC, czm_pixelRatio);\\n\\\n}\\n\\\n");\n\n;// CONCATENATED MODULE: ./node_modules/cesium/Source/Shaders/Builtin/Functions/modelToWindowCoordinates.js\n//This file is automatically rebuilt by the Cesium build process.\n/* harmony default export */ var modelToWindowCoordinates = ("/**\\n\\\n * Transforms a position from model to window coordinates.  The transformation\\n\\\n * from model to clip coordinates is done using {@link czm_modelViewProjection}.\\n\\\n * The transform from normalized device coordinates to window coordinates is\\n\\\n * done using {@link czm_viewportTransformation}, which assumes a depth range\\n\\\n * of <code>near = 0</code> and <code>far = 1</code>.\\n\\\n * <br /><br />\\n\\\n * This transform is useful when there is a need to manipulate window coordinates\\n\\\n * in a vertex shader as done by {@link BillboardCollection}.\\n\\\n * <br /><br />\\n\\\n * This function should not be confused with {@link czm_viewportOrthographic},\\n\\\n * which is an orthographic projection matrix that transforms from window \\n\\\n * coordinates to clip coordinates.\\n\\\n *\\n\\\n * @name czm_modelToWindowCoordinates\\n\\\n * @glslFunction\\n\\\n *\\n\\\n * @param {vec4} position The position in model coordinates to transform.\\n\\\n *\\n\\\n * @returns {vec4} The transformed position in window coordinates.\\n\\\n *\\n\\\n * @see czm_eyeToWindowCoordinates\\n\\\n * @see czm_modelViewProjection\\n\\\n * @see czm_viewportTransformation\\n\\\n * @see czm_viewportOrthographic\\n\\\n * @see BillboardCollection\\n\\\n *\\n\\\n * @example\\n\\\n * vec4 positionWC = czm_modelToWindowCoordinates(positionMC);\\n\\\n */\\n\\\nvec4 czm_modelToWindowCoordinates(vec4 position)\\n\\\n{\\n\\\n    vec4 q = czm_modelViewProjection * position;                // clip coordinates\\n\\\n    q.xyz /= q.w;                                                // normalized device coordinates\\n\\\n    q.xyz = (czm_viewportTransformation * vec4(q.xyz, 1.0)).xyz; // window coordinates\\n\\\n    return q;\\n\\\n}\\n\\\n");\n\n;// CONCATENATED MODULE: ./node_modules/cesium/Source/Shaders/Builtin/Functions/multiplyWithColorBalance.js\n//This file is automatically rebuilt by the Cesium build process.\n/* harmony default export */ var multiplyWithColorBalance = ("/**\\n\\\n * DOC_TBA\\n\\\n *\\n\\\n * @name czm_multiplyWithColorBalance\\n\\\n * @glslFunction\\n\\\n */\\n\\\nvec3 czm_multiplyWithColorBalance(vec3 left, vec3 right)\\n\\\n{\\n\\\n    // Algorithm from Chapter 10 of Graphics Shaders.\\n\\\n    const vec3 W = vec3(0.2125, 0.7154, 0.0721);\\n\\\n    \\n\\\n    vec3 target = left * right;\\n\\\n    float leftLuminance = dot(left, W);\\n\\\n    float rightLuminance = dot(right, W);\\n\\\n    float targetLuminance = dot(target, W);\\n\\\n    \\n\\\n    return ((leftLuminance + rightLuminance) / (2.0 * targetLuminance)) * target;\\n\\\n}\\n\\\n");\n\n;// CONCATENATED MODULE: ./node_modules/cesium/Source/Shaders/Builtin/Functions/nearFarScalar.js\n//This file is automatically rebuilt by the Cesium build process.\n/* harmony default export */ var nearFarScalar = ("/**\\n\\\n * Computes a value that scales with distance.  The scaling is clamped at the near and\\n\\\n * far distances, and does not extrapolate.  This function works with the\\n\\\n * {@link NearFarScalar} JavaScript class.\\n\\\n *\\n\\\n * @name czm_nearFarScalar\\n\\\n * @glslFunction\\n\\\n *\\n\\\n * @param {vec4} nearFarScalar A vector with 4 components: Near distance (x), Near value (y), Far distance (z), Far value (w).\\n\\\n * @param {float} cameraDistSq The square of the current distance from the camera.\\n\\\n *\\n\\\n * @returns {float} The value at this distance.\\n\\\n */\\n\\\nfloat czm_nearFarScalar(vec4 nearFarScalar, float cameraDistSq)\\n\\\n{\\n\\\n    float valueAtMin = nearFarScalar.y;\\n\\\n    float valueAtMax = nearFarScalar.w;\\n\\\n    float nearDistanceSq = nearFarScalar.x * nearFarScalar.x;\\n\\\n    float farDistanceSq = nearFarScalar.z * nearFarScalar.z;\\n\\\n\\n\\\n    float t = (cameraDistSq - nearDistanceSq) / (farDistanceSq - nearDistanceSq);\\n\\\n\\n\\\n    t = pow(clamp(t, 0.0, 1.0), 0.2);\\n\\\n\\n\\\n    return mix(valueAtMin, valueAtMax, t);\\n\\\n}\\n\\\n");\n\n;// CONCATENATED MODULE: ./node_modules/cesium/Source/Shaders/Builtin/Functions/octDecode.js\n//This file is automatically rebuilt by the Cesium build process.\n/* harmony default export */ var octDecode = (" /**\\n\\\n  * Decodes a unit-length vector in \'oct\' encoding to a normalized 3-component Cartesian vector.\\n\\\n  * The \'oct\' encoding is described in \\"A Survey of Efficient Representations of Independent Unit Vectors\\",\\n\\\n  * Cigolle et al 2014: http://jcgt.org/published/0003/02/01/\\n\\\n  *\\n\\\n  * @name czm_octDecode\\n\\\n  * @param {vec2} encoded The oct-encoded, unit-length vector\\n\\\n  * @param {float} range The maximum value of the SNORM range. The encoded vector is stored in log2(rangeMax+1) bits.\\n\\\n  * @returns {vec3} The decoded and normalized vector\\n\\\n  */\\n\\\n  vec3 czm_octDecode(vec2 encoded, float range)\\n\\\n  {\\n\\\n      if (encoded.x == 0.0 && encoded.y == 0.0) {\\n\\\n          return vec3(0.0, 0.0, 0.0);\\n\\\n      }\\n\\\n\\n\\\n     encoded = encoded / range * 2.0 - 1.0;\\n\\\n     vec3 v = vec3(encoded.x, encoded.y, 1.0 - abs(encoded.x) - abs(encoded.y));\\n\\\n     if (v.z < 0.0)\\n\\\n     {\\n\\\n         v.xy = (1.0 - abs(v.yx)) * czm_signNotZero(v.xy);\\n\\\n     }\\n\\\n\\n\\\n     return normalize(v);\\n\\\n  }\\n\\\n\\n\\\n/**\\n\\\n * Decodes a unit-length vector in \'oct\' encoding to a normalized 3-component Cartesian vector.\\n\\\n * The \'oct\' encoding is described in \\"A Survey of Efficient Representations of Independent Unit Vectors\\",\\n\\\n * Cigolle et al 2014: http://jcgt.org/published/0003/02/01/\\n\\\n *\\n\\\n * @name czm_octDecode\\n\\\n * @param {vec2} encoded The oct-encoded, unit-length vector\\n\\\n * @returns {vec3} The decoded and normalized vector\\n\\\n */\\n\\\n vec3 czm_octDecode(vec2 encoded)\\n\\\n {\\n\\\n    return czm_octDecode(encoded, 255.0);\\n\\\n }\\n\\\n\\n\\\n /**\\n\\\n * Decodes a unit-length vector in \'oct\' encoding packed into a floating-point number to a normalized 3-component Cartesian vector.\\n\\\n * The \'oct\' encoding is described in \\"A Survey of Efficient Representations of Independent Unit Vectors\\",\\n\\\n * Cigolle et al 2014: http://jcgt.org/published/0003/02/01/\\n\\\n *\\n\\\n * @name czm_octDecode\\n\\\n * @param {float} encoded The oct-encoded, unit-length vector\\n\\\n * @returns {vec3} The decoded and normalized vector\\n\\\n */\\n\\\n vec3 czm_octDecode(float encoded)\\n\\\n {\\n\\\n    float temp = encoded / 256.0;\\n\\\n    float x = floor(temp);\\n\\\n    float y = (temp - x) * 256.0;\\n\\\n    return czm_octDecode(vec2(x, y));\\n\\\n }\\n\\\n\\n\\\n/**\\n\\\n * Decodes three unit-length vectors in \'oct\' encoding packed into two floating-point numbers to normalized 3-component Cartesian vectors.\\n\\\n * The \'oct\' encoding is described in \\"A Survey of Efficient Representations of Independent Unit Vectors\\",\\n\\\n * Cigolle et al 2014: http://jcgt.org/published/0003/02/01/\\n\\\n *\\n\\\n * @name czm_octDecode\\n\\\n * @param {vec2} encoded The packed oct-encoded, unit-length vectors.\\n\\\n * @param {vec3} vector1 One decoded and normalized vector.\\n\\\n * @param {vec3} vector2 One decoded and normalized vector.\\n\\\n * @param {vec3} vector3 One decoded and normalized vector.\\n\\\n */\\n\\\n  void czm_octDecode(vec2 encoded, out vec3 vector1, out vec3 vector2, out vec3 vector3)\\n\\\n {\\n\\\n    float temp = encoded.x / 65536.0;\\n\\\n    float x = floor(temp);\\n\\\n    float encodedFloat1 = (temp - x) * 65536.0;\\n\\\n\\n\\\n    temp = encoded.y / 65536.0;\\n\\\n    float y = floor(temp);\\n\\\n    float encodedFloat2 = (temp - y) * 65536.0;\\n\\\n\\n\\\n    vector1 = czm_octDecode(encodedFloat1);\\n\\\n    vector2 = czm_octDecode(encodedFloat2);\\n\\\n    vector3 = czm_octDecode(vec2(x, y));\\n\\\n }\\n\\\n\\n\\\n");\n\n;// CONCATENATED MODULE: ./node_modules/cesium/Source/Shaders/Builtin/Functions/packDepth.js\n//This file is automatically rebuilt by the Cesium build process.\n/* harmony default export */ var packDepth = ("/**\\n\\\n * Packs a depth value into a vec3 that can be represented by unsigned bytes.\\n\\\n *\\n\\\n * @name czm_packDepth\\n\\\n * @glslFunction\\n\\\n *\\n\\\n * @param {float} depth The floating-point depth.\\n\\\n * @returns {vec3} The packed depth.\\n\\\n */\\n\\\nvec4 czm_packDepth(float depth)\\n\\\n{\\n\\\n    // See Aras Pranckeviius\' post Encoding Floats to RGBA\\n\\\n    // http://aras-p.info/blog/2009/07/30/encoding-floats-to-rgba-the-final/\\n\\\n    vec4 enc = vec4(1.0, 255.0, 65025.0, 16581375.0) * depth;\\n\\\n    enc = fract(enc);\\n\\\n    enc -= enc.yzww * vec4(1.0 / 255.0, 1.0 / 255.0, 1.0 / 255.0, 0.0);\\n\\\n    return enc;\\n\\\n}\\n\\\n");\n\n;// CONCATENATED MODULE: ./node_modules/cesium/Source/Shaders/Builtin/Functions/pbrLighting.js\n//This file is automatically rebuilt by the Cesium build process.\n/* harmony default export */ var pbrLighting = ("vec3 lambertianDiffuse(vec3 diffuseColor)\\n\\\n{\\n\\\n    return diffuseColor / czm_pi;\\n\\\n}\\n\\\n\\n\\\nvec3 fresnelSchlick2(vec3 f0, vec3 f90, float VdotH)\\n\\\n{\\n\\\n    return f0 + (f90 - f0) * pow(clamp(1.0 - VdotH, 0.0, 1.0), 5.0);\\n\\\n}\\n\\\n\\n\\\nfloat smithVisibilityG1(float NdotV, float roughness)\\n\\\n{\\n\\\n    // this is the k value for direct lighting.\\n\\\n    // for image based lighting it will be roughness^2 / 2\\n\\\n    float k = (roughness + 1.0) * (roughness + 1.0) / 8.0;\\n\\\n    return NdotV / (NdotV * (1.0 - k) + k);\\n\\\n}\\n\\\n\\n\\\nfloat smithVisibilityGGX(float roughness, float NdotL, float NdotV)\\n\\\n{\\n\\\n    return (\\n\\\n        smithVisibilityG1(NdotL, roughness) *\\n\\\n        smithVisibilityG1(NdotV, roughness)\\n\\\n    );\\n\\\n}\\n\\\n\\n\\\nfloat GGX(float roughness, float NdotH)\\n\\\n{\\n\\\n    float roughnessSquared = roughness * roughness;\\n\\\n    float f = (NdotH * roughnessSquared - NdotH) * NdotH + 1.0;\\n\\\n    return roughnessSquared / (czm_pi * f * f);\\n\\\n}\\n\\\n\\n\\\n/**\\n\\\n * Compute the diffuse and specular contributions using physically based\\n\\\n * rendering. This function only handles direct lighting.\\n\\\n * <p>\\n\\\n * This function only handles the lighting calculations. Metallic/roughness\\n\\\n * and specular/glossy must be handled separately. See {@czm_pbrMetallicRoughnessMaterial}, {@czm_pbrSpecularGlossinessMaterial} and {@czm_defaultPbrMaterial}\\n\\\n * </p>\\n\\\n *\\n\\\n * @name czm_pbrlighting\\n\\\n * @glslFunction\\n\\\n *\\n\\\n * @param {vec3} positionEC The position of the fragment in eye coordinates\\n\\\n * @param {vec3} normalEC The surface normal in eye coordinates\\n\\\n * @param {vec3} lightDirectionEC Unit vector pointing to the light source in eye coordinates.\\n\\\n * @param {vec3} lightColorHdr radiance of the light source. This is a HDR value.\\n\\\n * @param {czm_pbrParameters} The computed PBR parameters.\\n\\\n * @return {vec3} The computed HDR color\\n\\\n *\\n\\\n * @example\\n\\\n * czm_pbrParameters pbrParameters = czm_pbrMetallicRoughnessMaterial(\\n\\\n *  baseColor,\\n\\\n *  metallic,\\n\\\n *  roughness\\n\\\n * );\\n\\\n * vec3 color = czm_pbrlighting(\\n\\\n *  positionEC,\\n\\\n *  normalEC,\\n\\\n *  lightDirectionEC,\\n\\\n *  lightColorHdr,\\n\\\n *  pbrParameters);\\n\\\n */\\n\\\nvec3 czm_pbrLighting(\\n\\\n    vec3 positionEC,\\n\\\n    vec3 normalEC,\\n\\\n    vec3 lightDirectionEC,\\n\\\n    vec3 lightColorHdr,\\n\\\n    czm_pbrParameters pbrParameters\\n\\\n)\\n\\\n{\\n\\\n    vec3 v = -normalize(positionEC);\\n\\\n    vec3 l = normalize(lightDirectionEC);\\n\\\n    vec3 h = normalize(v + l);\\n\\\n    vec3 n = normalEC;\\n\\\n    float NdotL = clamp(dot(n, l), 0.001, 1.0);\\n\\\n    float NdotV = abs(dot(n, v)) + 0.001;\\n\\\n    float NdotH = clamp(dot(n, h), 0.0, 1.0);\\n\\\n    float LdotH = clamp(dot(l, h), 0.0, 1.0);\\n\\\n    float VdotH = clamp(dot(v, h), 0.0, 1.0);\\n\\\n\\n\\\n    vec3 f0 = pbrParameters.f0;\\n\\\n    float reflectance = max(max(f0.r, f0.g), f0.b);\\n\\\n    vec3 f90 = vec3(clamp(reflectance * 25.0, 0.0, 1.0));\\n\\\n    vec3 F = fresnelSchlick2(f0, f90, VdotH);\\n\\\n\\n\\\n    float alpha = pbrParameters.roughness;\\n\\\n    float G = smithVisibilityGGX(alpha, NdotL, NdotV);\\n\\\n    float D = GGX(alpha, NdotH);\\n\\\n    vec3 specularContribution = F * G * D / (4.0 * NdotL * NdotV);\\n\\\n\\n\\\n    vec3 diffuseColor = pbrParameters.diffuseColor;\\n\\\n    // F here represents the specular contribution\\n\\\n    vec3 diffuseContribution = (1.0 - F) * lambertianDiffuse(diffuseColor);\\n\\\n\\n\\\n    // Lo = (diffuse + specular) * Li * NdotL\\n\\\n    return (diffuseContribution + specularContribution) * NdotL * lightColorHdr;\\n\\\n}\\n\\\n");\n\n;// CONCATENATED MODULE: ./node_modules/cesium/Source/Shaders/Builtin/Functions/pbrMetallicRoughnessMaterial.js\n//This file is automatically rebuilt by the Cesium build process.\n/* harmony default export */ var pbrMetallicRoughnessMaterial = ("/**\\n\\\n * Compute parameters for physically based rendering using the\\n\\\n * metallic/roughness workflow. All inputs are linear; sRGB texture values must\\n\\\n * be decoded beforehand\\n\\\n *\\n\\\n * @name czm_pbrMetallicRoughnessMaterial\\n\\\n * @glslFunction\\n\\\n *\\n\\\n * @param {vec3} baseColor For dielectrics, this is the base color. For metals, this is the f0 value (reflectance at normal incidence)\\n\\\n * @param {float} metallic 0.0 indicates dielectric. 1.0 indicates metal. Values in between are allowed (e.g. to model rust or dirt);\\n\\\n * @param {float} roughness A value between 0.0 and 1.0\\n\\\n * @return {czm_pbrParameters} parameters to pass into {@link czm_pbrLighting}\\n\\\n */\\n\\\nczm_pbrParameters czm_pbrMetallicRoughnessMaterial(\\n\\\n    vec3 baseColor,\\n\\\n    float metallic,\\n\\\n    float roughness\\n\\\n) \\n\\\n{\\n\\\n    czm_pbrParameters results;\\n\\\n\\n\\\n    // roughness is authored as perceptual roughness\\n\\\n    // square it to get material roughness\\n\\\n    roughness = clamp(roughness, 0.0, 1.0);\\n\\\n    results.roughness = roughness * roughness;\\n\\\n\\n\\\n    // dielectrics us f0 = 0.04, metals use albedo as f0\\n\\\n    metallic = clamp(metallic, 0.0, 1.0);\\n\\\n    const vec3 REFLECTANCE_DIELECTRIC = vec3(0.04);\\n\\\n    vec3 f0 = mix(REFLECTANCE_DIELECTRIC, baseColor, metallic);\\n\\\n    results.f0 = f0;\\n\\\n\\n\\\n    // diffuse only applies to dielectrics.\\n\\\n    results.diffuseColor = baseColor * (1.0 - f0) * (1.0 - metallic);\\n\\\n\\n\\\n    return results;\\n\\\n}\\n\\\n");\n\n;// CONCATENATED MODULE: ./node_modules/cesium/Source/Shaders/Builtin/Functions/pbrSpecularGlossinessMaterial.js\n//This file is automatically rebuilt by the Cesium build process.\n/* harmony default export */ var pbrSpecularGlossinessMaterial = ("/**\\n\\\n * Compute parameters for physically based rendering using the\\n\\\n * specular/glossy workflow. All inputs are linear; sRGB texture values must\\n\\\n * be decoded beforehand\\n\\\n *\\n\\\n * @name czm_pbrSpecularGlossinessMaterial\\n\\\n * @glslFunction\\n\\\n *\\n\\\n * @param {vec3} diffuse The diffuse color for dielectrics (non-metals)\\n\\\n * @param {vec3} specular The reflectance at normal incidence (f0)\\n\\\n * @param {float} glossiness A number from 0.0 to 1.0 indicating how smooth the surface is.\\n\\\n * @return {czm_pbrParameters} parameters to pass into {@link czm_pbrLighting}\\n\\\n */\\n\\\nczm_pbrParameters czm_pbrSpecularGlossinessMaterial(\\n\\\n    vec3 diffuse,\\n\\\n    vec3 specular,\\n\\\n    float glossiness\\n\\\n) \\n\\\n{\\n\\\n    czm_pbrParameters results;\\n\\\n\\n\\\n    // glossiness is the opposite of roughness, but easier for artists to use.\\n\\\n    float roughness = 1.0 - glossiness;\\n\\\n    results.roughness = roughness * roughness;\\n\\\n\\n\\\n    results.diffuseColor = diffuse * (1.0 - max(max(specular.r, specular.g), specular.b));\\n\\\n    results.f0 = specular;\\n\\\n\\n\\\n    return results;\\n\\\n}\\n\\\n");\n\n;// CONCATENATED MODULE: ./node_modules/cesium/Source/Shaders/Builtin/Functions/phong.js\n//This file is automatically rebuilt by the Cesium build process.\n/* harmony default export */ var phong = ("float czm_private_getLambertDiffuseOfMaterial(vec3 lightDirectionEC, czm_material material)\\n\\\n{\\n\\\n    return czm_getLambertDiffuse(lightDirectionEC, material.normal);\\n\\\n}\\n\\\n\\n\\\nfloat czm_private_getSpecularOfMaterial(vec3 lightDirectionEC, vec3 toEyeEC, czm_material material)\\n\\\n{\\n\\\n    return czm_getSpecular(lightDirectionEC, toEyeEC, material.normal, material.shininess);\\n\\\n}\\n\\\n\\n\\\n/**\\n\\\n * Computes a color using the Phong lighting model.\\n\\\n *\\n\\\n * @name czm_phong\\n\\\n * @glslFunction\\n\\\n *\\n\\\n * @param {vec3} toEye A normalized vector from the fragment to the eye in eye coordinates.\\n\\\n * @param {czm_material} material The fragment\'s material.\\n\\\n *\\n\\\n * @returns {vec4} The computed color.\\n\\\n *\\n\\\n * @example\\n\\\n * vec3 positionToEyeEC = // ...\\n\\\n * czm_material material = // ...\\n\\\n * vec3 lightDirectionEC = // ...\\n\\\n * gl_FragColor = czm_phong(normalize(positionToEyeEC), material, lightDirectionEC);\\n\\\n *\\n\\\n * @see czm_getMaterial\\n\\\n */\\n\\\nvec4 czm_phong(vec3 toEye, czm_material material, vec3 lightDirectionEC)\\n\\\n{\\n\\\n    // Diffuse from directional light sources at eye (for top-down)\\n\\\n    float diffuse = czm_private_getLambertDiffuseOfMaterial(vec3(0.0, 0.0, 1.0), material);\\n\\\n    if (czm_sceneMode == czm_sceneMode3D) {\\n\\\n        // (and horizon views in 3D)\\n\\\n        diffuse += czm_private_getLambertDiffuseOfMaterial(vec3(0.0, 1.0, 0.0), material);\\n\\\n    }\\n\\\n\\n\\\n    float specular = czm_private_getSpecularOfMaterial(lightDirectionEC, toEye, material);\\n\\\n\\n\\\n    // Temporary workaround for adding ambient.\\n\\\n    vec3 materialDiffuse = material.diffuse * 0.5;\\n\\\n\\n\\\n    vec3 ambient = materialDiffuse;\\n\\\n    vec3 color = ambient + material.emission;\\n\\\n    color += materialDiffuse * diffuse * czm_lightColor;\\n\\\n    color += material.specular * specular * czm_lightColor;\\n\\\n\\n\\\n    return vec4(color, material.alpha);\\n\\\n}\\n\\\n\\n\\\nvec4 czm_private_phong(vec3 toEye, czm_material material, vec3 lightDirectionEC)\\n\\\n{\\n\\\n    float diffuse = czm_private_getLambertDiffuseOfMaterial(lightDirectionEC, material);\\n\\\n    float specular = czm_private_getSpecularOfMaterial(lightDirectionEC, toEye, material);\\n\\\n\\n\\\n    vec3 ambient = vec3(0.0);\\n\\\n    vec3 color = ambient + material.emission;\\n\\\n    color += material.diffuse * diffuse * czm_lightColor;\\n\\\n    color += material.specular * specular * czm_lightColor;\\n\\\n\\n\\\n    return vec4(color, material.alpha);\\n\\\n}\\n\\\n");\n\n;// CONCATENATED MODULE: ./node_modules/cesium/Source/Shaders/Builtin/Functions/planeDistance.js\n//This file is automatically rebuilt by the Cesium build process.\n/* harmony default export */ var planeDistance = ("/**\\n\\\n * Computes distance from a point to a plane.\\n\\\n *\\n\\\n * @name czm_planeDistance\\n\\\n * @glslFunction\\n\\\n *\\n\\\n * param {vec4} plane A Plane in Hessian Normal Form. See Plane.js\\n\\\n * param {vec3} point A point in the same space as the plane.\\n\\\n * returns {float} The distance from the point to the plane.\\n\\\n */\\n\\\nfloat czm_planeDistance(vec4 plane, vec3 point) {\\n\\\n    return (dot(plane.xyz, point) + plane.w);\\n\\\n}\\n\\\n\\n\\\n/**\\n\\\n * Computes distance from a point to a plane.\\n\\\n *\\n\\\n * @name czm_planeDistance\\n\\\n * @glslFunction\\n\\\n *\\n\\\n * param {vec3} planeNormal Normal for a plane in Hessian Normal Form. See Plane.js\\n\\\n * param {float} planeDistance Distance for a plane in Hessian Normal form. See Plane.js\\n\\\n * param {vec3} point A point in the same space as the plane.\\n\\\n * returns {float} The distance from the point to the plane.\\n\\\n */\\n\\\nfloat czm_planeDistance(vec3 planeNormal, float planeDistance, vec3 point) {\\n\\\n    return (dot(planeNormal, point) + planeDistance);\\n\\\n}\\n\\\n");\n\n;// CONCATENATED MODULE: ./node_modules/cesium/Source/Shaders/Builtin/Functions/pointAlongRay.js\n//This file is automatically rebuilt by the Cesium build process.\n/* harmony default export */ var pointAlongRay = ("/**\\n\\\n * Computes the point along a ray at the given time.  <code>time</code> can be positive, negative, or zero.\\n\\\n *\\n\\\n * @name czm_pointAlongRay\\n\\\n * @glslFunction\\n\\\n *\\n\\\n * @param {czm_ray} ray The ray to compute the point along.\\n\\\n * @param {float} time The time along the ray.\\n\\\n * \\n\\\n * @returns {vec3} The point along the ray at the given time.\\n\\\n * \\n\\\n * @example\\n\\\n * czm_ray ray = czm_ray(vec3(0.0), vec3(1.0, 0.0, 0.0)); // origin, direction\\n\\\n * vec3 v = czm_pointAlongRay(ray, 2.0); // (2.0, 0.0, 0.0)\\n\\\n */\\n\\\nvec3 czm_pointAlongRay(czm_ray ray, float time)\\n\\\n{\\n\\\n    return ray.origin + (time * ray.direction);\\n\\\n}\\n\\\n");\n\n;// CONCATENATED MODULE: ./node_modules/cesium/Source/Shaders/Builtin/Functions/rayEllipsoidIntersectionInterval.js\n//This file is automatically rebuilt by the Cesium build process.\n/* harmony default export */ var rayEllipsoidIntersectionInterval = ("/**\\n\\\n * DOC_TBA\\n\\\n *\\n\\\n * @name czm_rayEllipsoidIntersectionInterval\\n\\\n * @glslFunction\\n\\\n */\\n\\\nczm_raySegment czm_rayEllipsoidIntersectionInterval(czm_ray ray, vec3 ellipsoid_center, vec3 ellipsoid_inverseRadii)\\n\\\n{\\n\\\n   // ray and ellipsoid center in eye coordinates.  radii in model coordinates.\\n\\\n    vec3 q = ellipsoid_inverseRadii * (czm_inverseModelView * vec4(ray.origin, 1.0)).xyz;\\n\\\n    vec3 w = ellipsoid_inverseRadii * (czm_inverseModelView * vec4(ray.direction, 0.0)).xyz;\\n\\\n\\n\\\n    q = q - ellipsoid_inverseRadii * (czm_inverseModelView * vec4(ellipsoid_center, 1.0)).xyz;\\n\\\n\\n\\\n    float q2 = dot(q, q);\\n\\\n    float qw = dot(q, w);\\n\\\n\\n\\\n    if (q2 > 1.0) // Outside ellipsoid.\\n\\\n    {\\n\\\n        if (qw >= 0.0) // Looking outward or tangent (0 intersections).\\n\\\n        {\\n\\\n            return czm_emptyRaySegment;\\n\\\n        }\\n\\\n        else // qw < 0.0.\\n\\\n        {\\n\\\n            float qw2 = qw * qw;\\n\\\n            float difference = q2 - 1.0; // Positively valued.\\n\\\n            float w2 = dot(w, w);\\n\\\n            float product = w2 * difference;\\n\\\n\\n\\\n            if (qw2 < product) // Imaginary roots (0 intersections).\\n\\\n            {\\n\\\n                return czm_emptyRaySegment;\\n\\\n            }\\n\\\n            else if (qw2 > product) // Distinct roots (2 intersections).\\n\\\n            {\\n\\\n                float discriminant = qw * qw - product;\\n\\\n                float temp = -qw + sqrt(discriminant); // Avoid cancellation.\\n\\\n                float root0 = temp / w2;\\n\\\n                float root1 = difference / temp;\\n\\\n                if (root0 < root1)\\n\\\n                {\\n\\\n                    czm_raySegment i = czm_raySegment(root0, root1);\\n\\\n                    return i;\\n\\\n                }\\n\\\n                else\\n\\\n                {\\n\\\n                    czm_raySegment i = czm_raySegment(root1, root0);\\n\\\n                    return i;\\n\\\n                }\\n\\\n            }\\n\\\n            else // qw2 == product.  Repeated roots (2 intersections).\\n\\\n            {\\n\\\n                float root = sqrt(difference / w2);\\n\\\n                czm_raySegment i = czm_raySegment(root, root);\\n\\\n                return i;\\n\\\n            }\\n\\\n        }\\n\\\n    }\\n\\\n    else if (q2 < 1.0) // Inside ellipsoid (2 intersections).\\n\\\n    {\\n\\\n        float difference = q2 - 1.0; // Negatively valued.\\n\\\n        float w2 = dot(w, w);\\n\\\n        float product = w2 * difference; // Negatively valued.\\n\\\n        float discriminant = qw * qw - product;\\n\\\n        float temp = -qw + sqrt(discriminant); // Positively valued.\\n\\\n        czm_raySegment i = czm_raySegment(0.0, temp / w2);\\n\\\n        return i;\\n\\\n    }\\n\\\n    else // q2 == 1.0. On ellipsoid.\\n\\\n    {\\n\\\n        if (qw < 0.0) // Looking inward.\\n\\\n        {\\n\\\n            float w2 = dot(w, w);\\n\\\n            czm_raySegment i = czm_raySegment(0.0, -qw / w2);\\n\\\n            return i;\\n\\\n        }\\n\\\n        else // qw >= 0.0.  Looking outward or tangent.\\n\\\n        {\\n\\\n            return czm_emptyRaySegment;\\n\\\n        }\\n\\\n    }\\n\\\n}\\n\\\n");\n\n;// CONCATENATED MODULE: ./node_modules/cesium/Source/Shaders/Builtin/Functions/readDepth.js\n//This file is automatically rebuilt by the Cesium build process.\n/* harmony default export */ var readDepth = ("float czm_readDepth(sampler2D depthTexture, vec2 texCoords)\\n\\\n{\\n\\\n    return czm_reverseLogDepth(texture2D(depthTexture, texCoords).r);\\n\\\n}\\n\\\n");\n\n;// CONCATENATED MODULE: ./node_modules/cesium/Source/Shaders/Builtin/Functions/readNonPerspective.js\n//This file is automatically rebuilt by the Cesium build process.\n/* harmony default export */ var readNonPerspective = ("/**\\n\\\n * Reads a value previously transformed with {@link czm_writeNonPerspective}\\n\\\n * by dividing it by `w`, the value used in the perspective divide.\\n\\\n * This function is intended to be called in a fragment shader to access a\\n\\\n * `varying` that should not be subject to perspective interpolation.\\n\\\n * For example, screen-space texture coordinates. The value should have been\\n\\\n * previously written in the vertex shader with a call to\\n\\\n * {@link czm_writeNonPerspective}.\\n\\\n *\\n\\\n * @name czm_readNonPerspective\\n\\\n * @glslFunction\\n\\\n *\\n\\\n * @param {float|vec2|vec3|vec4} value The non-perspective value to be read.\\n\\\n * @param {float} oneOverW One over the perspective divide value, `w`. Usually this is simply `gl_FragCoord.w`.\\n\\\n * @returns {float|vec2|vec3|vec4} The usable value.\\n\\\n */\\n\\\nfloat czm_readNonPerspective(float value, float oneOverW) {\\n\\\n    return value * oneOverW;\\n\\\n}\\n\\\n\\n\\\nvec2 czm_readNonPerspective(vec2 value, float oneOverW) {\\n\\\n    return value * oneOverW;\\n\\\n}\\n\\\n\\n\\\nvec3 czm_readNonPerspective(vec3 value, float oneOverW) {\\n\\\n    return value * oneOverW;\\n\\\n}\\n\\\n\\n\\\nvec4 czm_readNonPerspective(vec4 value, float oneOverW) {\\n\\\n    return value * oneOverW;\\n\\\n}\\n\\\n");\n\n;// CONCATENATED MODULE: ./node_modules/cesium/Source/Shaders/Builtin/Functions/reverseLogDepth.js\n//This file is automatically rebuilt by the Cesium build process.\n/* harmony default export */ var reverseLogDepth = ("float czm_reverseLogDepth(float logZ)\\n\\\n{\\n\\\n#ifdef LOG_DEPTH\\n\\\n    float near = czm_currentFrustum.x;\\n\\\n    float far = czm_currentFrustum.y;\\n\\\n    float log2Depth = logZ * czm_log2FarDepthFromNearPlusOne;\\n\\\n    float depthFromNear = pow(2.0, log2Depth) - 1.0;\\n\\\n    return far * (1.0 - near / (depthFromNear + near)) / (far - near);\\n\\\n#endif\\n\\\n    return logZ;\\n\\\n}\\n\\\n");\n\n;// CONCATENATED MODULE: ./node_modules/cesium/Source/Shaders/Builtin/Functions/sampleOctahedralProjection.js\n//This file is automatically rebuilt by the Cesium build process.\n/* harmony default export */ var sampleOctahedralProjection = ("/**\\n\\\n * Samples the 4 neighboring pixels and return the weighted average.\\n\\\n *\\n\\\n * @private\\n\\\n */\\n\\\nvec3 czm_sampleOctahedralProjectionWithFiltering(sampler2D projectedMap, vec2 textureSize, vec3 direction, float lod)\\n\\\n{\\n\\\n    direction /= dot(vec3(1.0), abs(direction));\\n\\\n    vec2 rev = abs(direction.zx) - vec2(1.0);\\n\\\n    vec2 neg = vec2(direction.x < 0.0 ? rev.x : -rev.x,\\n\\\n                    direction.z < 0.0 ? rev.y : -rev.y);\\n\\\n    vec2 uv = direction.y < 0.0 ? neg : direction.xz;\\n\\\n    vec2 coord = 0.5 * uv + vec2(0.5);\\n\\\n    vec2 pixel = 1.0 / textureSize;\\n\\\n\\n\\\n    if (lod > 0.0)\\n\\\n    {\\n\\\n        // Each subseqeuent mip level is half the size\\n\\\n        float scale = 1.0 / pow(2.0, lod);\\n\\\n        float offset = ((textureSize.y + 1.0) / textureSize.x);\\n\\\n\\n\\\n        coord.x *= offset;\\n\\\n        coord *= scale;\\n\\\n\\n\\\n        coord.x += offset + pixel.x;\\n\\\n        coord.y += (1.0 - (1.0 / pow(2.0, lod - 1.0))) + pixel.y * (lod - 1.0) * 2.0;\\n\\\n    }\\n\\\n    else\\n\\\n    {\\n\\\n        coord.x *= (textureSize.y / textureSize.x);\\n\\\n    }\\n\\\n\\n\\\n    // Do bilinear filtering\\n\\\n    #ifndef OES_texture_float_linear\\n\\\n        vec3 color1 = texture2D(projectedMap, coord + vec2(0.0, pixel.y)).rgb;\\n\\\n        vec3 color2 = texture2D(projectedMap, coord + vec2(pixel.x, 0.0)).rgb;\\n\\\n        vec3 color3 = texture2D(projectedMap, coord + pixel).rgb;\\n\\\n        vec3 color4 = texture2D(projectedMap, coord).rgb;\\n\\\n\\n\\\n        vec2 texturePosition = coord * textureSize;\\n\\\n\\n\\\n        float fu = fract(texturePosition.x);\\n\\\n        float fv = fract(texturePosition.y);\\n\\\n\\n\\\n        vec3 average1 = mix(color4, color2, fu);\\n\\\n        vec3 average2 = mix(color1, color3, fu);\\n\\\n\\n\\\n        vec3 color = mix(average1, average2, fv);\\n\\\n    #else\\n\\\n        vec3 color = texture2D(projectedMap, coord).rgb;\\n\\\n    #endif\\n\\\n\\n\\\n    return color;\\n\\\n}\\n\\\n\\n\\\n\\n\\\n/**\\n\\\n * Samples from a cube map that has been projected using an octahedral projection from the given direction.\\n\\\n *\\n\\\n * @name czm_sampleOctahedralProjection\\n\\\n * @glslFunction\\n\\\n *\\n\\\n * @param {sampler2D} projectedMap The texture with the octahedral projected cube map.\\n\\\n * @param {vec2} textureSize The width and height dimensions in pixels of the projected map.\\n\\\n * @param {vec3} direction The normalized direction used to sample the cube map.\\n\\\n * @param {float} lod The level of detail to sample.\\n\\\n * @param {float} maxLod The maximum level of detail.\\n\\\n * @returns {vec3} The color of the cube map at the direction.\\n\\\n */\\n\\\nvec3 czm_sampleOctahedralProjection(sampler2D projectedMap, vec2 textureSize, vec3 direction, float lod, float maxLod) {\\n\\\n    float currentLod = floor(lod + 0.5);\\n\\\n    float nextLod = min(currentLod + 1.0, maxLod);\\n\\\n\\n\\\n    vec3 colorCurrentLod = czm_sampleOctahedralProjectionWithFiltering(projectedMap, textureSize, direction, currentLod);\\n\\\n    vec3 colorNextLod = czm_sampleOctahedralProjectionWithFiltering(projectedMap, textureSize, direction, nextLod);\\n\\\n\\n\\\n    return mix(colorNextLod, colorCurrentLod, nextLod - lod);\\n\\\n}\\n\\\n");\n\n;// CONCATENATED MODULE: ./node_modules/cesium/Source/Shaders/Builtin/Functions/saturation.js\n//This file is automatically rebuilt by the Cesium build process.\n/* harmony default export */ var saturation = ("/**\\n\\\n * Adjusts the saturation of a color.\\n\\\n * \\n\\\n * @name czm_saturation\\n\\\n * @glslFunction\\n\\\n * \\n\\\n * @param {vec3} rgb The color.\\n\\\n * @param {float} adjustment The amount to adjust the saturation of the color.\\n\\\n *\\n\\\n * @returns {float} The color with the saturation adjusted.\\n\\\n *\\n\\\n * @example\\n\\\n * vec3 greyScale = czm_saturation(color, 0.0);\\n\\\n * vec3 doubleSaturation = czm_saturation(color, 2.0);\\n\\\n */\\n\\\nvec3 czm_saturation(vec3 rgb, float adjustment)\\n\\\n{\\n\\\n    // Algorithm from Chapter 16 of OpenGL Shading Language\\n\\\n    const vec3 W = vec3(0.2125, 0.7154, 0.0721);\\n\\\n    vec3 intensity = vec3(dot(rgb, W));\\n\\\n    return mix(intensity, rgb, adjustment);\\n\\\n}\\n\\\n");\n\n;// CONCATENATED MODULE: ./node_modules/cesium/Source/Shaders/Builtin/Functions/shadowDepthCompare.js\n//This file is automatically rebuilt by the Cesium build process.\n/* harmony default export */ var shadowDepthCompare = ("\\n\\\nfloat czm_sampleShadowMap(highp samplerCube shadowMap, vec3 d)\\n\\\n{\\n\\\n    return czm_unpackDepth(textureCube(shadowMap, d));\\n\\\n}\\n\\\n\\n\\\nfloat czm_sampleShadowMap(highp sampler2D shadowMap, vec2 uv)\\n\\\n{\\n\\\n#ifdef USE_SHADOW_DEPTH_TEXTURE\\n\\\n    return texture2D(shadowMap, uv).r;\\n\\\n#else\\n\\\n    return czm_unpackDepth(texture2D(shadowMap, uv));\\n\\\n#endif\\n\\\n}\\n\\\n\\n\\\nfloat czm_shadowDepthCompare(samplerCube shadowMap, vec3 uv, float depth)\\n\\\n{\\n\\\n    return step(depth, czm_sampleShadowMap(shadowMap, uv));\\n\\\n}\\n\\\n\\n\\\nfloat czm_shadowDepthCompare(sampler2D shadowMap, vec2 uv, float depth)\\n\\\n{\\n\\\n    return step(depth, czm_sampleShadowMap(shadowMap, uv));\\n\\\n}\\n\\\n");\n\n;// CONCATENATED MODULE: ./node_modules/cesium/Source/Shaders/Builtin/Functions/shadowVisibility.js\n//This file is automatically rebuilt by the Cesium build process.\n/* harmony default export */ var shadowVisibility = ("\\n\\\nfloat czm_private_shadowVisibility(float visibility, float nDotL, float normalShadingSmooth, float darkness)\\n\\\n{\\n\\\n#ifdef USE_NORMAL_SHADING\\n\\\n#ifdef USE_NORMAL_SHADING_SMOOTH\\n\\\n    float strength = clamp(nDotL / normalShadingSmooth, 0.0, 1.0);\\n\\\n#else\\n\\\n    float strength = step(0.0, nDotL);\\n\\\n#endif\\n\\\n    visibility *= strength;\\n\\\n#endif\\n\\\n\\n\\\n    visibility = max(visibility, darkness);\\n\\\n    return visibility;\\n\\\n}\\n\\\n\\n\\\n#ifdef USE_CUBE_MAP_SHADOW\\n\\\nfloat czm_shadowVisibility(samplerCube shadowMap, czm_shadowParameters shadowParameters)\\n\\\n{\\n\\\n    float depthBias = shadowParameters.depthBias;\\n\\\n    float depth = shadowParameters.depth;\\n\\\n    float nDotL = shadowParameters.nDotL;\\n\\\n    float normalShadingSmooth = shadowParameters.normalShadingSmooth;\\n\\\n    float darkness = shadowParameters.darkness;\\n\\\n    vec3 uvw = shadowParameters.texCoords;\\n\\\n\\n\\\n    depth -= depthBias;\\n\\\n    float visibility = czm_shadowDepthCompare(shadowMap, uvw, depth);\\n\\\n    return czm_private_shadowVisibility(visibility, nDotL, normalShadingSmooth, darkness);\\n\\\n}\\n\\\n#else\\n\\\nfloat czm_shadowVisibility(sampler2D shadowMap, czm_shadowParameters shadowParameters)\\n\\\n{\\n\\\n    float depthBias = shadowParameters.depthBias;\\n\\\n    float depth = shadowParameters.depth;\\n\\\n    float nDotL = shadowParameters.nDotL;\\n\\\n    float normalShadingSmooth = shadowParameters.normalShadingSmooth;\\n\\\n    float darkness = shadowParameters.darkness;\\n\\\n    vec2 uv = shadowParameters.texCoords;\\n\\\n\\n\\\n    depth -= depthBias;\\n\\\n#ifdef USE_SOFT_SHADOWS\\n\\\n    vec2 texelStepSize = shadowParameters.texelStepSize;\\n\\\n    float radius = 1.0;\\n\\\n    float dx0 = -texelStepSize.x * radius;\\n\\\n    float dy0 = -texelStepSize.y * radius;\\n\\\n    float dx1 = texelStepSize.x * radius;\\n\\\n    float dy1 = texelStepSize.y * radius;\\n\\\n    float visibility = (\\n\\\n        czm_shadowDepthCompare(shadowMap, uv, depth) +\\n\\\n        czm_shadowDepthCompare(shadowMap, uv + vec2(dx0, dy0), depth) +\\n\\\n        czm_shadowDepthCompare(shadowMap, uv + vec2(0.0, dy0), depth) +\\n\\\n        czm_shadowDepthCompare(shadowMap, uv + vec2(dx1, dy0), depth) +\\n\\\n        czm_shadowDepthCompare(shadowMap, uv + vec2(dx0, 0.0), depth) +\\n\\\n        czm_shadowDepthCompare(shadowMap, uv + vec2(dx1, 0.0), depth) +\\n\\\n        czm_shadowDepthCompare(shadowMap, uv + vec2(dx0, dy1), depth) +\\n\\\n        czm_shadowDepthCompare(shadowMap, uv + vec2(0.0, dy1), depth) +\\n\\\n        czm_shadowDepthCompare(shadowMap, uv + vec2(dx1, dy1), depth)\\n\\\n    ) * (1.0 / 9.0);\\n\\\n#else\\n\\\n    float visibility = czm_shadowDepthCompare(shadowMap, uv, depth);\\n\\\n#endif\\n\\\n\\n\\\n    return czm_private_shadowVisibility(visibility, nDotL, normalShadingSmooth, darkness);\\n\\\n}\\n\\\n#endif\\n\\\n");\n\n;// CONCATENATED MODULE: ./node_modules/cesium/Source/Shaders/Builtin/Functions/signNotZero.js\n//This file is automatically rebuilt by the Cesium build process.\n/* harmony default export */ var signNotZero = ("/**\\n\\\n * Returns 1.0 if the given value is positive or zero, and -1.0 if it is negative.  This is similar to the GLSL\\n\\\n * built-in function <code>sign</code> except that returns 1.0 instead of 0.0 when the input value is 0.0.\\n\\\n * \\n\\\n * @name czm_signNotZero\\n\\\n * @glslFunction\\n\\\n *\\n\\\n * @param {} value The value for which to determine the sign.\\n\\\n * @returns {} 1.0 if the value is positive or zero, -1.0 if the value is negative.\\n\\\n */\\n\\\nfloat czm_signNotZero(float value)\\n\\\n{\\n\\\n    return value >= 0.0 ? 1.0 : -1.0;\\n\\\n}\\n\\\n\\n\\\nvec2 czm_signNotZero(vec2 value)\\n\\\n{\\n\\\n    return vec2(czm_signNotZero(value.x), czm_signNotZero(value.y));\\n\\\n}\\n\\\n\\n\\\nvec3 czm_signNotZero(vec3 value)\\n\\\n{\\n\\\n    return vec3(czm_signNotZero(value.x), czm_signNotZero(value.y), czm_signNotZero(value.z));\\n\\\n}\\n\\\n\\n\\\nvec4 czm_signNotZero(vec4 value)\\n\\\n{\\n\\\n    return vec4(czm_signNotZero(value.x), czm_signNotZero(value.y), czm_signNotZero(value.z), czm_signNotZero(value.w));\\n\\\n}\\n\\\n");\n\n;// CONCATENATED MODULE: ./node_modules/cesium/Source/Shaders/Builtin/Functions/sphericalHarmonics.js\n//This file is automatically rebuilt by the Cesium build process.\n/* harmony default export */ var sphericalHarmonics = ("/**\\n\\\n * Computes a color from the third order spherical harmonic coefficients and a normalized direction vector.\\n\\\n * <p>\\n\\\n * The order of the coefficients is [L00, L1_1, L10, L11, L2_2, L2_1, L20, L21, L22].\\n\\\n * </p>\\n\\\n *\\n\\\n * @name czm_sphericalHarmonics\\n\\\n * @glslFunction\\n\\\n *\\n\\\n * @param {vec3} normal The normalized direction.\\n\\\n * @param {vec3[9]} coefficients The third order spherical harmonic coefficients.\\n\\\n * @returns {vec3} The color at the direction.\\n\\\n *\\n\\\n * @see https://graphics.stanford.edu/papers/envmap/envmap.pdf\\n\\\n */\\n\\\nvec3 czm_sphericalHarmonics(vec3 normal, vec3 coefficients[9])\\n\\\n{\\n\\\n    vec3 L00 = coefficients[0];\\n\\\n    vec3 L1_1 = coefficients[1];\\n\\\n    vec3 L10 = coefficients[2];\\n\\\n    vec3 L11 = coefficients[3];\\n\\\n    vec3 L2_2 = coefficients[4];\\n\\\n    vec3 L2_1 = coefficients[5];\\n\\\n    vec3 L20 = coefficients[6];\\n\\\n    vec3 L21 = coefficients[7];\\n\\\n    vec3 L22 = coefficients[8];\\n\\\n\\n\\\n    float x = normal.x;\\n\\\n    float y = normal.y;\\n\\\n    float z = normal.z;\\n\\\n\\n\\\n    return\\n\\\n          L00\\n\\\n        + L1_1 * y\\n\\\n        + L10 * z\\n\\\n        + L11 * x\\n\\\n        + L2_2 * (y * x)\\n\\\n        + L2_1 * (y * z)\\n\\\n        + L20 * (3.0 * z * z - 1.0)\\n\\\n        + L21 * (z * x)\\n\\\n        + L22 * (x * x - y * y);\\n\\\n}\\n\\\n");\n\n;// CONCATENATED MODULE: ./node_modules/cesium/Source/Shaders/Builtin/Functions/tangentToEyeSpaceMatrix.js\n//This file is automatically rebuilt by the Cesium build process.\n/* harmony default export */ var tangentToEyeSpaceMatrix = ("/**\\n\\\n * Creates a matrix that transforms vectors from tangent space to eye space.\\n\\\n *\\n\\\n * @name czm_tangentToEyeSpaceMatrix\\n\\\n * @glslFunction\\n\\\n *\\n\\\n * @param {vec3} normalEC The normal vector in eye coordinates.\\n\\\n * @param {vec3} tangentEC The tangent vector in eye coordinates.\\n\\\n * @param {vec3} bitangentEC The bitangent vector in eye coordinates.\\n\\\n *\\n\\\n * @returns {mat3} The matrix that transforms from tangent space to eye space.\\n\\\n *\\n\\\n * @example\\n\\\n * mat3 tangentToEye = czm_tangentToEyeSpaceMatrix(normalEC, tangentEC, bitangentEC);\\n\\\n * vec3 normal = tangentToEye * texture2D(normalMap, st).xyz;\\n\\\n */\\n\\\nmat3 czm_tangentToEyeSpaceMatrix(vec3 normalEC, vec3 tangentEC, vec3 bitangentEC)\\n\\\n{\\n\\\n    vec3 normal = normalize(normalEC);\\n\\\n    vec3 tangent = normalize(tangentEC);\\n\\\n    vec3 bitangent = normalize(bitangentEC);\\n\\\n    return mat3(tangent.x  , tangent.y  , tangent.z,\\n\\\n                bitangent.x, bitangent.y, bitangent.z,\\n\\\n                normal.x   , normal.y   , normal.z);\\n\\\n}\\n\\\n");\n\n;// CONCATENATED MODULE: ./node_modules/cesium/Source/Shaders/Builtin/Functions/transformPlane.js\n//This file is automatically rebuilt by the Cesium build process.\n/* harmony default export */ var transformPlane = ("/**\\n\\\n * Transforms a plane.\\n\\\n * \\n\\\n * @name czm_transformPlane\\n\\\n * @glslFunction\\n\\\n *\\n\\\n * @param {vec4} plane The plane in Hessian Normal Form.\\n\\\n * @param {mat4} transform The inverse-transpose of a transformation matrix.\\n\\\n */\\n\\\nvec4 czm_transformPlane(vec4 plane, mat4 transform) {\\n\\\n    vec4 transformedPlane = transform * plane;\\n\\\n    // Convert the transformed plane to Hessian Normal Form\\n\\\n    float normalMagnitude = length(transformedPlane.xyz);\\n\\\n    return transformedPlane / normalMagnitude;\\n\\\n}\\n\\\n");\n\n;// CONCATENATED MODULE: ./node_modules/cesium/Source/Shaders/Builtin/Functions/translateRelativeToEye.js\n//This file is automatically rebuilt by the Cesium build process.\n/* harmony default export */ var translateRelativeToEye = ("/**\\n\\\n * Translates a position (or any <code>vec3</code>) that was encoded with {@link EncodedCartesian3},\\n\\\n * and then provided to the shader as separate <code>high</code> and <code>low</code> bits to\\n\\\n * be relative to the eye.  As shown in the example, the position can then be transformed in eye\\n\\\n * or clip coordinates using {@link czm_modelViewRelativeToEye} or {@link czm_modelViewProjectionRelativeToEye},\\n\\\n * respectively.\\n\\\n * <p>\\n\\\n * This technique, called GPU RTE, eliminates jittering artifacts when using large coordinates as\\n\\\n * described in {@link http://help.agi.com/AGIComponents/html/BlogPrecisionsPrecisions.htm|Precisions, Precisions}.\\n\\\n * </p>\\n\\\n *\\n\\\n * @name czm_translateRelativeToEye\\n\\\n * @glslFunction\\n\\\n *\\n\\\n * @param {vec3} high The position\'s high bits.\\n\\\n * @param {vec3} low The position\'s low bits.\\n\\\n * @returns {vec3} The position translated to be relative to the camera\'s position.\\n\\\n *\\n\\\n * @example\\n\\\n * attribute vec3 positionHigh;\\n\\\n * attribute vec3 positionLow;\\n\\\n *\\n\\\n * void main()\\n\\\n * {\\n\\\n *   vec4 p = czm_translateRelativeToEye(positionHigh, positionLow);\\n\\\n *   gl_Position = czm_modelViewProjectionRelativeToEye * p;\\n\\\n * }\\n\\\n *\\n\\\n * @see czm_modelViewRelativeToEye\\n\\\n * @see czm_modelViewProjectionRelativeToEye\\n\\\n * @see czm_computePosition\\n\\\n * @see EncodedCartesian3\\n\\\n */\\n\\\nvec4 czm_translateRelativeToEye(vec3 high, vec3 low)\\n\\\n{\\n\\\n    vec3 highDifference = high - czm_encodedCameraPositionMCHigh;\\n\\\n    vec3 lowDifference = low - czm_encodedCameraPositionMCLow;\\n\\\n\\n\\\n    return vec4(highDifference + lowDifference, 1.0);\\n\\\n}\\n\\\n");\n\n;// CONCATENATED MODULE: ./node_modules/cesium/Source/Shaders/Builtin/Functions/translucentPhong.js\n//This file is automatically rebuilt by the Cesium build process.\n/* harmony default export */ var translucentPhong = ("/**\\n\\\n * @private\\n\\\n */\\n\\\nvec4 czm_translucentPhong(vec3 toEye, czm_material material, vec3 lightDirectionEC)\\n\\\n{\\n\\\n    // Diffuse from directional light sources at eye (for top-down and horizon views)\\n\\\n    float diffuse = czm_getLambertDiffuse(vec3(0.0, 0.0, 1.0), material.normal);\\n\\\n\\n\\\n    if (czm_sceneMode == czm_sceneMode3D) {\\n\\\n        // (and horizon views in 3D)\\n\\\n        diffuse += czm_getLambertDiffuse(vec3(0.0, 1.0, 0.0), material.normal);\\n\\\n    }\\n\\\n\\n\\\n    diffuse = clamp(diffuse, 0.0, 1.0);\\n\\\n\\n\\\n    float specular = czm_getSpecular(lightDirectionEC, toEye, material.normal, material.shininess);\\n\\\n\\n\\\n    // Temporary workaround for adding ambient.\\n\\\n    vec3 materialDiffuse = material.diffuse * 0.5;\\n\\\n\\n\\\n    vec3 ambient = materialDiffuse;\\n\\\n    vec3 color = ambient + material.emission;\\n\\\n    color += materialDiffuse * diffuse * czm_lightColor;\\n\\\n    color += material.specular * specular * czm_lightColor;\\n\\\n\\n\\\n    return vec4(color, material.alpha);\\n\\\n}\\n\\\n");\n\n;// CONCATENATED MODULE: ./node_modules/cesium/Source/Shaders/Builtin/Functions/transpose.js\n//This file is automatically rebuilt by the Cesium build process.\n/* harmony default export */ var transpose = ("/**\\n\\\n * Returns the transpose of the matrix.  The input <code>matrix</code> can be\\n\\\n * a <code>mat2</code>, <code>mat3</code>, or <code>mat4</code>.\\n\\\n *\\n\\\n * @name czm_transpose\\n\\\n * @glslFunction\\n\\\n *\\n\\\n * @param {} matrix The matrix to transpose.\\n\\\n *\\n\\\n * @returns {} The transposed matrix.\\n\\\n *\\n\\\n * @example\\n\\\n * // GLSL declarations\\n\\\n * mat2 czm_transpose(mat2 matrix);\\n\\\n * mat3 czm_transpose(mat3 matrix);\\n\\\n * mat4 czm_transpose(mat4 matrix);\\n\\\n *\\n\\\n * // Transpose a 3x3 rotation matrix to find its inverse.\\n\\\n * mat3 eastNorthUpToEye = czm_eastNorthUpToEyeCoordinates(\\n\\\n *     positionMC, normalEC);\\n\\\n * mat3 eyeToEastNorthUp = czm_transpose(eastNorthUpToEye);\\n\\\n */\\n\\\nmat2 czm_transpose(mat2 matrix)\\n\\\n{\\n\\\n    return mat2(\\n\\\n        matrix[0][0], matrix[1][0],\\n\\\n        matrix[0][1], matrix[1][1]);\\n\\\n}\\n\\\n\\n\\\nmat3 czm_transpose(mat3 matrix)\\n\\\n{\\n\\\n    return mat3(\\n\\\n        matrix[0][0], matrix[1][0], matrix[2][0],\\n\\\n        matrix[0][1], matrix[1][1], matrix[2][1],\\n\\\n        matrix[0][2], matrix[1][2], matrix[2][2]);\\n\\\n}\\n\\\n\\n\\\nmat4 czm_transpose(mat4 matrix)\\n\\\n{\\n\\\n    return mat4(\\n\\\n        matrix[0][0], matrix[1][0], matrix[2][0], matrix[3][0],\\n\\\n        matrix[0][1], matrix[1][1], matrix[2][1], matrix[3][1],\\n\\\n        matrix[0][2], matrix[1][2], matrix[2][2], matrix[3][2],\\n\\\n        matrix[0][3], matrix[1][3], matrix[2][3], matrix[3][3]);\\n\\\n}\\n\\\n");\n\n;// CONCATENATED MODULE: ./node_modules/cesium/Source/Shaders/Builtin/Functions/unpackDepth.js\n//This file is automatically rebuilt by the Cesium build process.\n/* harmony default export */ var unpackDepth = ("/**\\n\\\n * Unpacks a vec4 depth value to a float in [0, 1) range.\\n\\\n *\\n\\\n * @name czm_unpackDepth\\n\\\n * @glslFunction\\n\\\n *\\n\\\n * @param {vec4} packedDepth The packed depth.\\n\\\n *\\n\\\n * @returns {float} The floating-point depth in [0, 1) range.\\n\\\n */\\n\\\n float czm_unpackDepth(vec4 packedDepth)\\n\\\n {\\n\\\n    // See Aras Pranckeviius\' post Encoding Floats to RGBA\\n\\\n    // http://aras-p.info/blog/2009/07/30/encoding-floats-to-rgba-the-final/\\n\\\n    return dot(packedDepth, vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0));\\n\\\n }\\n\\\n");\n\n;// CONCATENATED MODULE: ./node_modules/cesium/Source/Shaders/Builtin/Functions/unpackFloat.js\n//This file is automatically rebuilt by the Cesium build process.\n/* harmony default export */ var unpackFloat = ("/**\\n\\\n * Unpack an IEEE 754 single-precision float that is packed as a little-endian unsigned normalized vec4.\\n\\\n *\\n\\\n * @name czm_unpackFloat\\n\\\n * @glslFunction\\n\\\n *\\n\\\n * @param {vec4} packedFloat The packed float.\\n\\\n *\\n\\\n * @returns {float} The floating-point depth in arbitrary range.\\n\\\n */\\n\\\nfloat czm_unpackFloat(vec4 packedFloat)\\n\\\n{\\n\\\n    // Convert to [0.0, 255.0] and round to integer\\n\\\n    packedFloat = floor(packedFloat * 255.0 + 0.5);\\n\\\n    float sign = 1.0 - step(128.0, packedFloat[3]) * 2.0;\\n\\\n    float exponent = 2.0 * mod(packedFloat[3], 128.0) + step(128.0, packedFloat[2]) - 127.0;    \\n\\\n    if (exponent == -127.0)\\n\\\n    {\\n\\\n        return 0.0;\\n\\\n    }\\n\\\n    float mantissa = mod(packedFloat[2], 128.0) * 65536.0 + packedFloat[1] * 256.0 + packedFloat[0] + float(0x800000);\\n\\\n    float result = sign * exp2(exponent - 23.0) * mantissa;\\n\\\n    return result;\\n\\\n}\\n\\\n");\n\n;// CONCATENATED MODULE: ./node_modules/cesium/Source/Shaders/Builtin/Functions/vertexLogDepth.js\n//This file is automatically rebuilt by the Cesium build process.\n/* harmony default export */ var vertexLogDepth = ("#ifdef LOG_DEPTH\\n\\\n// 1.0 at the near plane, increasing linearly from there.\\n\\\nvarying float v_depthFromNearPlusOne;\\n\\\n#ifdef SHADOW_MAP\\n\\\nvarying vec3 v_logPositionEC;\\n\\\n#endif\\n\\\n#endif\\n\\\n\\n\\\nvec4 czm_updatePositionDepth(vec4 coords) {\\n\\\n#if defined(LOG_DEPTH)\\n\\\n\\n\\\n#ifdef SHADOW_MAP\\n\\\n    vec3 logPositionEC = (czm_inverseProjection * coords).xyz;\\n\\\n    v_logPositionEC = logPositionEC;\\n\\\n#endif\\n\\\n\\n\\\n    // With the very high far/near ratios used with the logarithmic depth\\n\\\n    // buffer, floating point rounding errors can cause linear depth values\\n\\\n    // to end up on the wrong side of the far plane, even for vertices that\\n\\\n    // are really nowhere near it. Since we always write a correct logarithmic\\n\\\n    // depth value in the fragment shader anyway, we just need to make sure\\n\\\n    // such errors don\'t cause the primitive to be clipped entirely before\\n\\\n    // we even get to the fragment shader.\\n\\\n    coords.z = clamp(coords.z / coords.w, -1.0, 1.0) * coords.w;\\n\\\n#endif\\n\\\n\\n\\\n    return coords;\\n\\\n}\\n\\\n\\n\\\n/**\\n\\\n * Writes the logarithmic depth to gl_Position using the already computed gl_Position.\\n\\\n *\\n\\\n * @name czm_vertexLogDepth\\n\\\n * @glslFunction\\n\\\n */\\n\\\nvoid czm_vertexLogDepth()\\n\\\n{\\n\\\n#ifdef LOG_DEPTH\\n\\\n    v_depthFromNearPlusOne = (gl_Position.w - czm_currentFrustum.x) + 1.0;\\n\\\n    gl_Position = czm_updatePositionDepth(gl_Position);\\n\\\n#endif\\n\\\n}\\n\\\n\\n\\\n/**\\n\\\n * Writes the logarithmic depth to gl_Position using the provided clip coordinates.\\n\\\n * <p>\\n\\\n * An example use case for this function would be moving the vertex in window coordinates\\n\\\n * before converting back to clip coordinates. Use the original vertex clip coordinates.\\n\\\n * </p>\\n\\\n * @name czm_vertexLogDepth\\n\\\n * @glslFunction\\n\\\n *\\n\\\n * @param {vec4} clipCoords The vertex in clip coordinates.\\n\\\n *\\n\\\n * @example\\n\\\n * czm_vertexLogDepth(czm_projection * vec4(positionEyeCoordinates, 1.0));\\n\\\n */\\n\\\nvoid czm_vertexLogDepth(vec4 clipCoords)\\n\\\n{\\n\\\n#ifdef LOG_DEPTH\\n\\\n    v_depthFromNearPlusOne = (clipCoords.w - czm_currentFrustum.x) + 1.0;\\n\\\n    czm_updatePositionDepth(clipCoords);\\n\\\n#endif\\n\\\n}\\n\\\n");\n\n;// CONCATENATED MODULE: ./node_modules/cesium/Source/Shaders/Builtin/Functions/windowToEyeCoordinates.js\n//This file is automatically rebuilt by the Cesium build process.\n/* harmony default export */ var windowToEyeCoordinates = ("/**\\n\\\n * Transforms a position from window to eye coordinates.\\n\\\n * The transform from window to normalized device coordinates is done using components\\n\\\n * of (@link czm_viewport} and {@link czm_viewportTransformation} instead of calculating\\n\\\n * the inverse of <code>czm_viewportTransformation</code>. The transformation from\\n\\\n * normalized device coordinates to clip coordinates is done using <code>fragmentCoordinate.w</code>,\\n\\\n * which is expected to be the scalar used in the perspective divide. The transformation\\n\\\n * from clip to eye coordinates is done using {@link czm_inverseProjection}.\\n\\\n *\\n\\\n * @name czm_windowToEyeCoordinates\\n\\\n * @glslFunction\\n\\\n *\\n\\\n * @param {vec4} fragmentCoordinate The position in window coordinates to transform.\\n\\\n *\\n\\\n * @returns {vec4} The transformed position in eye coordinates.\\n\\\n *\\n\\\n * @see czm_modelToWindowCoordinates\\n\\\n * @see czm_eyeToWindowCoordinates\\n\\\n * @see czm_inverseProjection\\n\\\n * @see czm_viewport\\n\\\n * @see czm_viewportTransformation\\n\\\n *\\n\\\n * @example\\n\\\n * vec4 positionEC = czm_windowToEyeCoordinates(gl_FragCoord);\\n\\\n */\\n\\\nvec4 czm_windowToEyeCoordinates(vec4 fragmentCoordinate)\\n\\\n{\\n\\\n    // Reconstruct NDC coordinates\\n\\\n    float x = 2.0 * (fragmentCoordinate.x - czm_viewport.x) / czm_viewport.z - 1.0;\\n\\\n    float y = 2.0 * (fragmentCoordinate.y - czm_viewport.y) / czm_viewport.w - 1.0;\\n\\\n    float z = (fragmentCoordinate.z - czm_viewportTransformation[3][2]) / czm_viewportTransformation[2][2];\\n\\\n    vec4 q = vec4(x, y, z, 1.0);\\n\\\n\\n\\\n    // Reverse the perspective division to obtain clip coordinates.\\n\\\n    q /= fragmentCoordinate.w;\\n\\\n\\n\\\n    // Reverse the projection transformation to obtain eye coordinates.\\n\\\n    if (!(czm_inverseProjection == mat4(0.0))) // IE and Edge sometimes do something weird with != between mat4s\\n\\\n    {\\n\\\n        q = czm_inverseProjection * q;\\n\\\n    }\\n\\\n    else\\n\\\n    {\\n\\\n        float top = czm_frustumPlanes.x;\\n\\\n        float bottom = czm_frustumPlanes.y;\\n\\\n        float left = czm_frustumPlanes.z;\\n\\\n        float right = czm_frustumPlanes.w;\\n\\\n\\n\\\n        float near = czm_currentFrustum.x;\\n\\\n        float far = czm_currentFrustum.y;\\n\\\n\\n\\\n        q.x = (q.x * (right - left) + left + right) * 0.5;\\n\\\n        q.y = (q.y * (top - bottom) + bottom + top) * 0.5;\\n\\\n        q.z = (q.z * (near - far) - near - far) * 0.5;\\n\\\n        q.w = 1.0;\\n\\\n    }\\n\\\n\\n\\\n    return q;\\n\\\n}\\n\\\n\\n\\\n/**\\n\\\n * Transforms a position given as window x/y and a depth or a log depth from window to eye coordinates.\\n\\\n * This function produces more accurate results for window positions with log depth than\\n\\\n * conventionally unpacking the log depth using czm_reverseLogDepth and using the standard version\\n\\\n * of czm_windowToEyeCoordinates.\\n\\\n *\\n\\\n * @name czm_windowToEyeCoordinates\\n\\\n * @glslFunction\\n\\\n *\\n\\\n * @param {vec2} fragmentCoordinateXY The XY position in window coordinates to transform.\\n\\\n * @param {float} depthOrLogDepth A depth or log depth for the fragment.\\n\\\n *\\n\\\n * @see czm_modelToWindowCoordinates\\n\\\n * @see czm_eyeToWindowCoordinates\\n\\\n * @see czm_inverseProjection\\n\\\n * @see czm_viewport\\n\\\n * @see czm_viewportTransformation\\n\\\n *\\n\\\n * @returns {vec4} The transformed position in eye coordinates.\\n\\\n */\\n\\\nvec4 czm_windowToEyeCoordinates(vec2 fragmentCoordinateXY, float depthOrLogDepth)\\n\\\n{\\n\\\n    // See reverseLogDepth.glsl. This is separate to re-use the pow.\\n\\\n#ifdef LOG_DEPTH\\n\\\n    float near = czm_currentFrustum.x;\\n\\\n    float far = czm_currentFrustum.y;\\n\\\n    float log2Depth = depthOrLogDepth * czm_log2FarDepthFromNearPlusOne;\\n\\\n    float depthFromNear = pow(2.0, log2Depth) - 1.0;\\n\\\n    float depthFromCamera = depthFromNear + near;\\n\\\n    vec4 windowCoord = vec4(fragmentCoordinateXY, far * (1.0 - near / depthFromCamera) / (far - near), 1.0);\\n\\\n    vec4 eyeCoordinate = czm_windowToEyeCoordinates(windowCoord);\\n\\\n    eyeCoordinate.w = 1.0 / depthFromCamera; // Better precision\\n\\\n    return eyeCoordinate;\\n\\\n#else\\n\\\n    vec4 windowCoord = vec4(fragmentCoordinateXY, depthOrLogDepth, 1.0);\\n\\\n    vec4 eyeCoordinate = czm_windowToEyeCoordinates(windowCoord);\\n\\\n#endif\\n\\\n    return eyeCoordinate;\\n\\\n}\\n\\\n");\n\n;// CONCATENATED MODULE: ./node_modules/cesium/Source/Shaders/Builtin/Functions/writeDepthClamp.js\n//This file is automatically rebuilt by the Cesium build process.\n/* harmony default export */ var writeDepthClamp = ("// emulated noperspective\\n\\\n#if defined(GL_EXT_frag_depth) && !defined(LOG_DEPTH)\\n\\\nvarying float v_WindowZ;\\n\\\n#endif\\n\\\n\\n\\\n/**\\n\\\n * Emulates GL_DEPTH_CLAMP. Clamps a fragment to the near and far plane\\n\\\n * by writing the fragment\'s depth. See czm_depthClamp for more details.\\n\\\n * <p>\\n\\\n * The shader must enable the GL_EXT_frag_depth extension.\\n\\\n * </p>\\n\\\n *\\n\\\n * @name czm_writeDepthClamp\\n\\\n * @glslFunction\\n\\\n *\\n\\\n * @example\\n\\\n * gl_FragColor = color;\\n\\\n * czm_writeDepthClamp();\\n\\\n *\\n\\\n * @see czm_depthClamp\\n\\\n */\\n\\\nvoid czm_writeDepthClamp()\\n\\\n{\\n\\\n#if defined(GL_EXT_frag_depth) && !defined(LOG_DEPTH)\\n\\\n    gl_FragDepthEXT = clamp(v_WindowZ * gl_FragCoord.w, 0.0, 1.0);\\n\\\n#endif\\n\\\n}\\n\\\n");\n\n;// CONCATENATED MODULE: ./node_modules/cesium/Source/Shaders/Builtin/Functions/writeLogDepth.js\n//This file is automatically rebuilt by the Cesium build process.\n/* harmony default export */ var writeLogDepth = ("#ifdef LOG_DEPTH\\n\\\nvarying float v_depthFromNearPlusOne;\\n\\\n\\n\\\n#ifdef POLYGON_OFFSET\\n\\\nuniform vec2 u_polygonOffset;\\n\\\n#endif\\n\\\n\\n\\\n#endif\\n\\\n\\n\\\n/**\\n\\\n * Writes the fragment depth to the logarithmic depth buffer.\\n\\\n * <p>\\n\\\n * Use this when the vertex shader does not call {@link czm_vertexlogDepth}, for example, when\\n\\\n * ray-casting geometry using a full screen quad.\\n\\\n * </p>\\n\\\n * @name czm_writeLogDepth\\n\\\n * @glslFunction\\n\\\n *\\n\\\n * @param {float} depth The depth coordinate, where 1.0 is on the near plane and\\n\\\n *                      depth increases in eye-space units from there\\n\\\n *\\n\\\n * @example\\n\\\n * czm_writeLogDepth((czm_projection * v_positionEyeCoordinates).w + 1.0);\\n\\\n */\\n\\\nvoid czm_writeLogDepth(float depth)\\n\\\n{\\n\\\n#if defined(GL_EXT_frag_depth) && defined(LOG_DEPTH)\\n\\\n    // Discard the vertex if it\'s not between the near and far planes.\\n\\\n    // We allow a bit of epsilon on the near plane comparison because a 1.0\\n\\\n    // from the vertex shader (indicating the vertex should be _on_ the near\\n\\\n    // plane) will not necessarily come here as exactly 1.0.\\n\\\n    if (depth <= 0.9999999 || depth > czm_farDepthFromNearPlusOne) {\\n\\\n        discard;\\n\\\n    }\\n\\\n\\n\\\n#ifdef POLYGON_OFFSET\\n\\\n    // Polygon offset: m * factor + r * units\\n\\\n    float factor = u_polygonOffset[0];\\n\\\n    float units = u_polygonOffset[1];\\n\\\n\\n\\\n    // If we can\'t compute derivatives, just leave out the factor I guess?\\n\\\n#ifdef GL_OES_standard_derivatives\\n\\\n    // m = sqrt(dZdX^2 + dZdY^2);\\n\\\n    float x = dFdx(depth);\\n\\\n    float y = dFdy(depth);\\n\\\n    float m = sqrt(x * x + y * y);\\n\\\n\\n\\\n    // Apply the factor before computing the log depth.\\n\\\n    depth += m * factor;\\n\\\n#endif\\n\\\n\\n\\\n#endif\\n\\\n\\n\\\n    gl_FragDepthEXT = log2(depth) * czm_oneOverLog2FarDepthFromNearPlusOne;\\n\\\n\\n\\\n#ifdef POLYGON_OFFSET\\n\\\n    // Apply the units after the log depth.\\n\\\n    gl_FragDepthEXT += czm_epsilon7 * units;\\n\\\n#endif\\n\\\n\\n\\\n#endif\\n\\\n}\\n\\\n\\n\\\n/**\\n\\\n * Writes the fragment depth to the logarithmic depth buffer.\\n\\\n * <p>\\n\\\n * Use this when the vertex shader calls {@link czm_vertexlogDepth}.\\n\\\n * </p>\\n\\\n *\\n\\\n * @name czm_writeLogDepth\\n\\\n * @glslFunction\\n\\\n */\\n\\\nvoid czm_writeLogDepth() {\\n\\\n#ifdef LOG_DEPTH\\n\\\n    czm_writeLogDepth(v_depthFromNearPlusOne);\\n\\\n#endif\\n\\\n}\\n\\\n");\n\n;// CONCATENATED MODULE: ./node_modules/cesium/Source/Shaders/Builtin/Functions/writeNonPerspective.js\n//This file is automatically rebuilt by the Cesium build process.\n/* harmony default export */ var writeNonPerspective = ("/**\\n\\\n * Transforms a value for non-perspective interpolation by multiplying\\n\\\n * it by w, the value used in the perspective divide. This function is\\n\\\n * intended to be called in a vertex shader to compute the value of a\\n\\\n * `varying` that should not be subject to perspective interpolation.\\n\\\n * For example, screen-space texture coordinates. The fragment shader\\n\\\n * must call {@link czm_readNonPerspective} to retrieve the final\\n\\\n * non-perspective value.\\n\\\n *\\n\\\n * @name czm_writeNonPerspective\\n\\\n * @glslFunction\\n\\\n *\\n\\\n * @param {float|vec2|vec3|vec4} value The value to be interpolated without accounting for perspective.\\n\\\n * @param {float} w The perspective divide value. Usually this is the computed `gl_Position.w`.\\n\\\n * @returns {float|vec2|vec3|vec4} The transformed value, intended to be stored in a `varying` and read in the\\n\\\n *          fragment shader with {@link czm_readNonPerspective}.\\n\\\n */\\n\\\nfloat czm_writeNonPerspective(float value, float w) {\\n\\\n    return value * w;\\n\\\n}\\n\\\n\\n\\\nvec2 czm_writeNonPerspective(vec2 value, float w) {\\n\\\n    return value * w;\\n\\\n}\\n\\\n\\n\\\nvec3 czm_writeNonPerspective(vec3 value, float w) {\\n\\\n    return value * w;\\n\\\n}\\n\\\n\\n\\\nvec4 czm_writeNonPerspective(vec4 value, float w) {\\n\\\n    return value * w;\\n\\\n}\\n\\\n");\n\n;// CONCATENATED MODULE: ./node_modules/cesium/Source/Shaders/Builtin/CzmBuiltins.js\n//This file is automatically rebuilt by the Cesium build process.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n/* harmony default export */ var CzmBuiltins = ({\n    czm_degreesPerRadian : degreesPerRadian,\n    czm_depthRange : depthRange,\n    czm_epsilon1 : epsilon1,\n    czm_epsilon2 : epsilon2,\n    czm_epsilon3 : epsilon3,\n    czm_epsilon4 : epsilon4,\n    czm_epsilon5 : epsilon5,\n    czm_epsilon6 : epsilon6,\n    czm_epsilon7 : epsilon7,\n    czm_infinity : infinity,\n    czm_oneOverPi : oneOverPi,\n    czm_oneOverTwoPi : oneOverTwoPi,\n    czm_passCesium3DTile : passCesium3DTile,\n    czm_passCesium3DTileClassification : passCesium3DTileClassification,\n    czm_passCesium3DTileClassificationIgnoreShow : passCesium3DTileClassificationIgnoreShow,\n    czm_passClassification : passClassification,\n    czm_passCompute : passCompute,\n    czm_passEnvironment : passEnvironment,\n    czm_passGlobe : passGlobe,\n    czm_passOpaque : passOpaque,\n    czm_passOverlay : passOverlay,\n    czm_passTerrainClassification : passTerrainClassification,\n    czm_passTranslucent : passTranslucent,\n    czm_pi : pi,\n    czm_piOverFour : piOverFour,\n    czm_piOverSix : piOverSix,\n    czm_piOverThree : piOverThree,\n    czm_piOverTwo : piOverTwo,\n    czm_radiansPerDegree : radiansPerDegree,\n    czm_sceneMode2D : sceneMode2D,\n    czm_sceneMode3D : sceneMode3D,\n    czm_sceneModeColumbusView : sceneModeColumbusView,\n    czm_sceneModeMorphing : sceneModeMorphing,\n    czm_solarRadius : solarRadius,\n    czm_threePiOver2 : threePiOver2,\n    czm_twoPi : twoPi,\n    czm_webMercatorMaxLatitude : webMercatorMaxLatitude,\n    czm_depthRangeStruct : depthRangeStruct,\n    czm_material : material,\n    czm_materialInput : materialInput,\n    czm_modelMaterial : modelMaterial,\n    czm_pbrParameters : pbrParameters,\n    czm_ray : ray,\n    czm_raySegment : raySegment,\n    czm_shadowParameters : shadowParameters,\n    czm_HSBToRGB : HSBToRGB,\n    czm_HSLToRGB : HSLToRGB,\n    czm_RGBToHSB : RGBToHSB,\n    czm_RGBToHSL : RGBToHSL,\n    czm_RGBToXYZ : RGBToXYZ,\n    czm_XYZToRGB : XYZToRGB,\n    czm_acesTonemapping : acesTonemapping,\n    czm_alphaWeight : alphaWeight,\n    czm_antialias : antialias,\n    czm_approximateSphericalCoordinates : approximateSphericalCoordinates,\n    czm_backFacing : backFacing,\n    czm_branchFreeTernary : branchFreeTernary,\n    czm_cascadeColor : cascadeColor,\n    czm_cascadeDistance : cascadeDistance,\n    czm_cascadeMatrix : cascadeMatrix,\n    czm_cascadeWeights : cascadeWeights,\n    czm_columbusViewMorph : columbusViewMorph,\n    czm_computePosition : computePosition,\n    czm_cosineAndSine : cosineAndSine,\n    czm_decompressTextureCoordinates : decompressTextureCoordinates,\n    czm_defaultPbrMaterial : defaultPbrMaterial,\n    czm_depthClamp : depthClamp,\n    czm_eastNorthUpToEyeCoordinates : eastNorthUpToEyeCoordinates,\n    czm_ellipsoidContainsPoint : ellipsoidContainsPoint,\n    czm_ellipsoidWgs84TextureCoordinates : ellipsoidWgs84TextureCoordinates,\n    czm_equalsEpsilon : equalsEpsilon,\n    czm_eyeOffset : eyeOffset,\n    czm_eyeToWindowCoordinates : eyeToWindowCoordinates,\n    czm_fastApproximateAtan : fastApproximateAtan,\n    czm_fog : fog,\n    czm_gammaCorrect : gammaCorrect,\n    czm_geodeticSurfaceNormal : geodeticSurfaceNormal,\n    czm_getDefaultMaterial : getDefaultMaterial,\n    czm_getLambertDiffuse : getLambertDiffuse,\n    czm_getSpecular : getSpecular,\n    czm_getWaterNoise : getWaterNoise,\n    czm_hue : hue,\n    czm_inverseGamma : inverseGamma,\n    czm_isEmpty : isEmpty,\n    czm_isFull : isFull,\n    czm_latitudeToWebMercatorFraction : latitudeToWebMercatorFraction,\n    czm_lineDistance : lineDistance,\n    czm_luminance : luminance,\n    czm_metersPerPixel : metersPerPixel,\n    czm_modelToWindowCoordinates : modelToWindowCoordinates,\n    czm_multiplyWithColorBalance : multiplyWithColorBalance,\n    czm_nearFarScalar : nearFarScalar,\n    czm_octDecode : octDecode,\n    czm_packDepth : packDepth,\n    czm_pbrLighting : pbrLighting,\n    czm_pbrMetallicRoughnessMaterial : pbrMetallicRoughnessMaterial,\n    czm_pbrSpecularGlossinessMaterial : pbrSpecularGlossinessMaterial,\n    czm_phong : phong,\n    czm_planeDistance : planeDistance,\n    czm_pointAlongRay : pointAlongRay,\n    czm_rayEllipsoidIntersectionInterval : rayEllipsoidIntersectionInterval,\n    czm_readDepth : readDepth,\n    czm_readNonPerspective : readNonPerspective,\n    czm_reverseLogDepth : reverseLogDepth,\n    czm_sampleOctahedralProjection : sampleOctahedralProjection,\n    czm_saturation : saturation,\n    czm_shadowDepthCompare : shadowDepthCompare,\n    czm_shadowVisibility : shadowVisibility,\n    czm_signNotZero : signNotZero,\n    czm_sphericalHarmonics : sphericalHarmonics,\n    czm_tangentToEyeSpaceMatrix : tangentToEyeSpaceMatrix,\n    czm_transformPlane : transformPlane,\n    czm_translateRelativeToEye : translateRelativeToEye,\n    czm_translucentPhong : translucentPhong,\n    czm_transpose : transpose,\n    czm_unpackDepth : unpackDepth,\n    czm_unpackFloat : unpackFloat,\n    czm_vertexLogDepth : vertexLogDepth,\n    czm_windowToEyeCoordinates : windowToEyeCoordinates,\n    czm_writeDepthClamp : writeDepthClamp,\n    czm_writeLogDepth : writeLogDepth,\n    czm_writeNonPerspective : writeNonPerspective\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QUMzRCwwQkFBMEIsZUFBbUI7QUFDN0Msd0JBQXdCLGFBQWlCO0FBQ3pDLDhCQUE4QixtQkFBdUI7QUFDckQsQ0FBQyxFQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdnVlMy13ZWJwYWNrNS8uL25vZGVfbW9kdWxlcy9jZXNpdW0vU291cmNlL1NoYWRlcnMvQnVpbHRpbi9Db25zdGFudHMvZGVncmVlc1BlclJhZGlhbi5qcz8zMTY5Iiwid2VicGFjazovL3Z1ZTMtd2VicGFjazUvLi9ub2RlX21vZHVsZXMvY2VzaXVtL1NvdXJjZS9TaGFkZXJzL0J1aWx0aW4vQ29uc3RhbnRzL2RlcHRoUmFuZ2UuanM/ODNkOSIsIndlYnBhY2s6Ly92dWUzLXdlYnBhY2s1Ly4vbm9kZV9tb2R1bGVzL2Nlc2l1bS9Tb3VyY2UvU2hhZGVycy9CdWlsdGluL0NvbnN0YW50cy9lcHNpbG9uMS5qcz9hYjI3Iiwid2VicGFjazovL3Z1ZTMtd2VicGFjazUvLi9ub2RlX21vZHVsZXMvY2VzaXVtL1NvdXJjZS9TaGFkZXJzL0J1aWx0aW4vQ29uc3RhbnRzL2Vwc2lsb24yLmpzP2FhODIiLCJ3ZWJwYWNrOi8vdnVlMy13ZWJwYWNrNS8uL25vZGVfbW9kdWxlcy9jZXNpdW0vU291cmNlL1NoYWRlcnMvQnVpbHRpbi9Db25zdGFudHMvZXBzaWxvbjMuanM/OTU2NiIsIndlYnBhY2s6Ly92dWUzLXdlYnBhY2s1Ly4vbm9kZV9tb2R1bGVzL2Nlc2l1bS9Tb3VyY2UvU2hhZGVycy9CdWlsdGluL0NvbnN0YW50cy9lcHNpbG9uNC5qcz80NTkyIiwid2VicGFjazovL3Z1ZTMtd2VicGFjazUvLi9ub2RlX21vZHVsZXMvY2VzaXVtL1NvdXJjZS9TaGFkZXJzL0J1aWx0aW4vQ29uc3RhbnRzL2Vwc2lsb241LmpzP2ZiZTMiLCJ3ZWJwYWNrOi8vdnVlMy13ZWJwYWNrNS8uL25vZGVfbW9kdWxlcy9jZXNpdW0vU291cmNlL1NoYWRlcnMvQnVpbHRpbi9Db25zdGFudHMvZXBzaWxvbjYuanM/OWJkYyIsIndlYnBhY2s6Ly92dWUzLXdlYnBhY2s1Ly4vbm9kZV9tb2R1bGVzL2Nlc2l1bS9Tb3VyY2UvU2hhZGVycy9CdWlsdGluL0NvbnN0YW50cy9lcHNpbG9uNy5qcz8yZWExIiwid2VicGFjazovL3Z1ZTMtd2VicGFjazUvLi9ub2RlX21vZHVsZXMvY2VzaXVtL1NvdXJjZS9TaGFkZXJzL0J1aWx0aW4vQ29uc3RhbnRzL2luZmluaXR5LmpzPzI3NDUiLCJ3ZWJwYWNrOi8vdnVlMy13ZWJwYWNrNS8uL25vZGVfbW9kdWxlcy9jZXNpdW0vU291cmNlL1NoYWRlcnMvQnVpbHRpbi9Db25zdGFudHMvb25lT3ZlclBpLmpzP2ExYzkiLCJ3ZWJwYWNrOi8vdnVlMy13ZWJwYWNrNS8uL25vZGVfbW9kdWxlcy9jZXNpdW0vU291cmNlL1NoYWRlcnMvQnVpbHRpbi9Db25zdGFudHMvb25lT3ZlclR3b1BpLmpzP2Q1ZjkiLCJ3ZWJwYWNrOi8vdnVlMy13ZWJwYWNrNS8uL25vZGVfbW9kdWxlcy9jZXNpdW0vU291cmNlL1NoYWRlcnMvQnVpbHRpbi9Db25zdGFudHMvcGFzc0Nlc2l1bTNEVGlsZS5qcz85NTUzIiwid2VicGFjazovL3Z1ZTMtd2VicGFjazUvLi9ub2RlX21vZHVsZXMvY2VzaXVtL1NvdXJjZS9TaGFkZXJzL0J1aWx0aW4vQ29uc3RhbnRzL3Bhc3NDZXNpdW0zRFRpbGVDbGFzc2lmaWNhdGlvbi5qcz80OGFhIiwid2VicGFjazovL3Z1ZTMtd2VicGFjazUvLi9ub2RlX21vZHVsZXMvY2VzaXVtL1NvdXJjZS9TaGFkZXJzL0J1aWx0aW4vQ29uc3RhbnRzL3Bhc3NDZXNpdW0zRFRpbGVDbGFzc2lmaWNhdGlvbklnbm9yZVNob3cuanM/ZDg4MyIsIndlYnBhY2s6Ly92dWUzLXdlYnBhY2s1Ly4vbm9kZV9tb2R1bGVzL2Nlc2l1bS9Tb3VyY2UvU2hhZGVycy9CdWlsdGluL0NvbnN0YW50cy9wYXNzQ2xhc3NpZmljYXRpb24uanM/MzkyZSIsIndlYnBhY2s6Ly92dWUzLXdlYnBhY2s1Ly4vbm9kZV9tb2R1bGVzL2Nlc2l1bS9Tb3VyY2UvU2hhZGVycy9CdWlsdGluL0NvbnN0YW50cy9wYXNzQ29tcHV0ZS5qcz84YzQ5Iiwid2VicGFjazovL3Z1ZTMtd2VicGFjazUvLi9ub2RlX21vZHVsZXMvY2VzaXVtL1NvdXJjZS9TaGFkZXJzL0J1aWx0aW4vQ29uc3RhbnRzL3Bhc3NFbnZpcm9ubWVudC5qcz82Y2VjIiwid2VicGFjazovL3Z1ZTMtd2VicGFjazUvLi9ub2RlX21vZHVsZXMvY2VzaXVtL1NvdXJjZS9TaGFkZXJzL0J1aWx0aW4vQ29uc3RhbnRzL3Bhc3NHbG9iZS5qcz80NWIwIiwid2VicGFjazovL3Z1ZTMtd2VicGFjazUvLi9ub2RlX21vZHVsZXMvY2VzaXVtL1NvdXJjZS9TaGFkZXJzL0J1aWx0aW4vQ29uc3RhbnRzL3Bhc3NPcGFxdWUuanM/ZGMxYSIsIndlYnBhY2s6Ly92dWUzLXdlYnBhY2s1Ly4vbm9kZV9tb2R1bGVzL2Nlc2l1bS9Tb3VyY2UvU2hhZGVycy9CdWlsdGluL0NvbnN0YW50cy9wYXNzT3ZlcmxheS5qcz8zNzdiIiwid2VicGFjazovL3Z1ZTMtd2VicGFjazUvLi9ub2RlX21vZHVsZXMvY2VzaXVtL1NvdXJjZS9TaGFkZXJzL0J1aWx0aW4vQ29uc3RhbnRzL3Bhc3NUZXJyYWluQ2xhc3NpZmljYXRpb24uanM/YmM2NSIsIndlYnBhY2s6Ly92dWUzLXdlYnBhY2s1Ly4vbm9kZV9tb2R1bGVzL2Nlc2l1bS9Tb3VyY2UvU2hhZGVycy9CdWlsdGluL0NvbnN0YW50cy9wYXNzVHJhbnNsdWNlbnQuanM/MzI3ZCIsIndlYnBhY2s6Ly92dWUzLXdlYnBhY2s1Ly4vbm9kZV9tb2R1bGVzL2Nlc2l1bS9Tb3VyY2UvU2hhZGVycy9CdWlsdGluL0NvbnN0YW50cy9waS5qcz8zN2I1Iiwid2VicGFjazovL3Z1ZTMtd2VicGFjazUvLi9ub2RlX21vZHVsZXMvY2VzaXVtL1NvdXJjZS9TaGFkZXJzL0J1aWx0aW4vQ29uc3RhbnRzL3BpT3ZlckZvdXIuanM/ZWRlNCIsIndlYnBhY2s6Ly92dWUzLXdlYnBhY2s1Ly4vbm9kZV9tb2R1bGVzL2Nlc2l1bS9Tb3VyY2UvU2hhZGVycy9CdWlsdGluL0NvbnN0YW50cy9waU92ZXJTaXguanM/Nzk4ZiIsIndlYnBhY2s6Ly92dWUzLXdlYnBhY2s1Ly4vbm9kZV9tb2R1bGVzL2Nlc2l1bS9Tb3VyY2UvU2hhZGVycy9CdWlsdGluL0NvbnN0YW50cy9waU92ZXJUaHJlZS5qcz82YzIwIiwid2VicGFjazovL3Z1ZTMtd2VicGFjazUvLi9ub2RlX21vZHVsZXMvY2VzaXVtL1NvdXJjZS9TaGFkZXJzL0J1aWx0aW4vQ29uc3RhbnRzL3BpT3ZlclR3by5qcz9lNzA2Iiwid2VicGFjazovL3Z1ZTMtd2VicGFjazUvLi9ub2RlX21vZHVsZXMvY2VzaXVtL1NvdXJjZS9TaGFkZXJzL0J1aWx0aW4vQ29uc3RhbnRzL3JhZGlhbnNQZXJEZWdyZWUuanM/YmU1NiIsIndlYnBhY2s6Ly92dWUzLXdlYnBhY2s1Ly4vbm9kZV9tb2R1bGVzL2Nlc2l1bS9Tb3VyY2UvU2hhZGVycy9CdWlsdGluL0NvbnN0YW50cy9zY2VuZU1vZGUyRC5qcz8yZTM5Iiwid2VicGFjazovL3Z1ZTMtd2VicGFjazUvLi9ub2RlX21vZHVsZXMvY2VzaXVtL1NvdXJjZS9TaGFkZXJzL0J1aWx0aW4vQ29uc3RhbnRzL3NjZW5lTW9kZTNELmpzP2ExNmQiLCJ3ZWJwYWNrOi8vdnVlMy13ZWJwYWNrNS8uL25vZGVfbW9kdWxlcy9jZXNpdW0vU291cmNlL1NoYWRlcnMvQnVpbHRpbi9Db25zdGFudHMvc2NlbmVNb2RlQ29sdW1idXNWaWV3LmpzP2Y0NDAiLCJ3ZWJwYWNrOi8vdnVlMy13ZWJwYWNrNS8uL25vZGVfbW9kdWxlcy9jZXNpdW0vU291cmNlL1NoYWRlcnMvQnVpbHRpbi9Db25zdGFudHMvc2NlbmVNb2RlTW9ycGhpbmcuanM/YzFlOCIsIndlYnBhY2s6Ly92dWUzLXdlYnBhY2s1Ly4vbm9kZV9tb2R1bGVzL2Nlc2l1bS9Tb3VyY2UvU2hhZGVycy9CdWlsdGluL0NvbnN0YW50cy9zb2xhclJhZGl1cy5qcz9mNjFiIiwid2VicGFjazovL3Z1ZTMtd2VicGFjazUvLi9ub2RlX21vZHVsZXMvY2VzaXVtL1NvdXJjZS9TaGFkZXJzL0J1aWx0aW4vQ29uc3RhbnRzL3RocmVlUGlPdmVyMi5qcz82MGU0Iiwid2VicGFjazovL3Z1ZTMtd2VicGFjazUvLi9ub2RlX21vZHVsZXMvY2VzaXVtL1NvdXJjZS9TaGFkZXJzL0J1aWx0aW4vQ29uc3RhbnRzL3R3b1BpLmpzPzYxYjIiLCJ3ZWJwYWNrOi8vdnVlMy13ZWJwYWNrNS8uL25vZGVfbW9kdWxlcy9jZXNpdW0vU291cmNlL1NoYWRlcnMvQnVpbHRpbi9Db25zdGFudHMvd2ViTWVyY2F0b3JNYXhMYXRpdHVkZS5qcz9hZTljIiwid2VicGFjazovL3Z1ZTMtd2VicGFjazUvLi9ub2RlX21vZHVsZXMvY2VzaXVtL1NvdXJjZS9TaGFkZXJzL0J1aWx0aW4vU3RydWN0cy9kZXB0aFJhbmdlU3RydWN0LmpzP2ZhZWMiLCJ3ZWJwYWNrOi8vdnVlMy13ZWJwYWNrNS8uL25vZGVfbW9kdWxlcy9jZXNpdW0vU291cmNlL1NoYWRlcnMvQnVpbHRpbi9TdHJ1Y3RzL21hdGVyaWFsLmpzPzIwMjAiLCJ3ZWJwYWNrOi8vdnVlMy13ZWJwYWNrNS8uL25vZGVfbW9kdWxlcy9jZXNpdW0vU291cmNlL1NoYWRlcnMvQnVpbHRpbi9TdHJ1Y3RzL21hdGVyaWFsSW5wdXQuanM/ODVkOSIsIndlYnBhY2s6Ly92dWUzLXdlYnBhY2s1Ly4vbm9kZV9tb2R1bGVzL2Nlc2l1bS9Tb3VyY2UvU2hhZGVycy9CdWlsdGluL1N0cnVjdHMvbW9kZWxNYXRlcmlhbC5qcz85OTM1Iiwid2VicGFjazovL3Z1ZTMtd2VicGFjazUvLi9ub2RlX21vZHVsZXMvY2VzaXVtL1NvdXJjZS9TaGFkZXJzL0J1aWx0aW4vU3RydWN0cy9wYnJQYXJhbWV0ZXJzLmpzP2FmM2UiLCJ3ZWJwYWNrOi8vdnVlMy13ZWJwYWNrNS8uL25vZGVfbW9kdWxlcy9jZXNpdW0vU291cmNlL1NoYWRlcnMvQnVpbHRpbi9TdHJ1Y3RzL3JheS5qcz8xYjkxIiwid2VicGFjazovL3Z1ZTMtd2VicGFjazUvLi9ub2RlX21vZHVsZXMvY2VzaXVtL1NvdXJjZS9TaGFkZXJzL0J1aWx0aW4vU3RydWN0cy9yYXlTZWdtZW50LmpzPzgxYjAiLCJ3ZWJwYWNrOi8vdnVlMy13ZWJwYWNrNS8uL25vZGVfbW9kdWxlcy9jZXNpdW0vU291cmNlL1NoYWRlcnMvQnVpbHRpbi9TdHJ1Y3RzL3NoYWRvd1BhcmFtZXRlcnMuanM/ZThhYSIsIndlYnBhY2s6Ly92dWUzLXdlYnBhY2s1Ly4vbm9kZV9tb2R1bGVzL2Nlc2l1bS9Tb3VyY2UvU2hhZGVycy9CdWlsdGluL0Z1bmN0aW9ucy9IU0JUb1JHQi5qcz81Mzg4Iiwid2VicGFjazovL3Z1ZTMtd2VicGFjazUvLi9ub2RlX21vZHVsZXMvY2VzaXVtL1NvdXJjZS9TaGFkZXJzL0J1aWx0aW4vRnVuY3Rpb25zL0hTTFRvUkdCLmpzP2UzYzYiLCJ3ZWJwYWNrOi8vdnVlMy13ZWJwYWNrNS8uL25vZGVfbW9kdWxlcy9jZXNpdW0vU291cmNlL1NoYWRlcnMvQnVpbHRpbi9GdW5jdGlvbnMvUkdCVG9IU0IuanM/NzViZSIsIndlYnBhY2s6Ly92dWUzLXdlYnBhY2s1Ly4vbm9kZV9tb2R1bGVzL2Nlc2l1bS9Tb3VyY2UvU2hhZGVycy9CdWlsdGluL0Z1bmN0aW9ucy9SR0JUb0hTTC5qcz8zMTZjIiwid2VicGFjazovL3Z1ZTMtd2VicGFjazUvLi9ub2RlX21vZHVsZXMvY2VzaXVtL1NvdXJjZS9TaGFkZXJzL0J1aWx0aW4vRnVuY3Rpb25zL1JHQlRvWFlaLmpzPzFmMDIiLCJ3ZWJwYWNrOi8vdnVlMy13ZWJwYWNrNS8uL25vZGVfbW9kdWxlcy9jZXNpdW0vU291cmNlL1NoYWRlcnMvQnVpbHRpbi9GdW5jdGlvbnMvWFlaVG9SR0IuanM/NTQ3NCIsIndlYnBhY2s6Ly92dWUzLXdlYnBhY2s1Ly4vbm9kZV9tb2R1bGVzL2Nlc2l1bS9Tb3VyY2UvU2hhZGVycy9CdWlsdGluL0Z1bmN0aW9ucy9hY2VzVG9uZW1hcHBpbmcuanM/NTc2NSIsIndlYnBhY2s6Ly92dWUzLXdlYnBhY2s1Ly4vbm9kZV9tb2R1bGVzL2Nlc2l1bS9Tb3VyY2UvU2hhZGVycy9CdWlsdGluL0Z1bmN0aW9ucy9hbHBoYVdlaWdodC5qcz9hODlhIiwid2VicGFjazovL3Z1ZTMtd2VicGFjazUvLi9ub2RlX21vZHVsZXMvY2VzaXVtL1NvdXJjZS9TaGFkZXJzL0J1aWx0aW4vRnVuY3Rpb25zL2FudGlhbGlhcy5qcz9lZTZhIiwid2VicGFjazovL3Z1ZTMtd2VicGFjazUvLi9ub2RlX21vZHVsZXMvY2VzaXVtL1NvdXJjZS9TaGFkZXJzL0J1aWx0aW4vRnVuY3Rpb25zL2FwcHJveGltYXRlU3BoZXJpY2FsQ29vcmRpbmF0ZXMuanM/OTA4YyIsIndlYnBhY2s6Ly92dWUzLXdlYnBhY2s1Ly4vbm9kZV9tb2R1bGVzL2Nlc2l1bS9Tb3VyY2UvU2hhZGVycy9CdWlsdGluL0Z1bmN0aW9ucy9iYWNrRmFjaW5nLmpzPzRmOGEiLCJ3ZWJwYWNrOi8vdnVlMy13ZWJwYWNrNS8uL25vZGVfbW9kdWxlcy9jZXNpdW0vU291cmNlL1NoYWRlcnMvQnVpbHRpbi9GdW5jdGlvbnMvYnJhbmNoRnJlZVRlcm5hcnkuanM/MWE3NSIsIndlYnBhY2s6Ly92dWUzLXdlYnBhY2s1Ly4vbm9kZV9tb2R1bGVzL2Nlc2l1bS9Tb3VyY2UvU2hhZGVycy9CdWlsdGluL0Z1bmN0aW9ucy9jYXNjYWRlQ29sb3IuanM/OWE3YiIsIndlYnBhY2s6Ly92dWUzLXdlYnBhY2s1Ly4vbm9kZV9tb2R1bGVzL2Nlc2l1bS9Tb3VyY2UvU2hhZGVycy9CdWlsdGluL0Z1bmN0aW9ucy9jYXNjYWRlRGlzdGFuY2UuanM/NjA0ZSIsIndlYnBhY2s6Ly92dWUzLXdlYnBhY2s1Ly4vbm9kZV9tb2R1bGVzL2Nlc2l1bS9Tb3VyY2UvU2hhZGVycy9CdWlsdGluL0Z1bmN0aW9ucy9jYXNjYWRlTWF0cml4LmpzP2QwMWUiLCJ3ZWJwYWNrOi8vdnVlMy13ZWJwYWNrNS8uL25vZGVfbW9kdWxlcy9jZXNpdW0vU291cmNlL1NoYWRlcnMvQnVpbHRpbi9GdW5jdGlvbnMvY2FzY2FkZVdlaWdodHMuanM/Yjc4MCIsIndlYnBhY2s6Ly92dWUzLXdlYnBhY2s1Ly4vbm9kZV9tb2R1bGVzL2Nlc2l1bS9Tb3VyY2UvU2hhZGVycy9CdWlsdGluL0Z1bmN0aW9ucy9jb2x1bWJ1c1ZpZXdNb3JwaC5qcz8xY2UwIiwid2VicGFjazovL3Z1ZTMtd2VicGFjazUvLi9ub2RlX21vZHVsZXMvY2VzaXVtL1NvdXJjZS9TaGFkZXJzL0J1aWx0aW4vRnVuY3Rpb25zL2NvbXB1dGVQb3NpdGlvbi5qcz80NWQyIiwid2VicGFjazovL3Z1ZTMtd2VicGFjazUvLi9ub2RlX21vZHVsZXMvY2VzaXVtL1NvdXJjZS9TaGFkZXJzL0J1aWx0aW4vRnVuY3Rpb25zL2Nvc2luZUFuZFNpbmUuanM/Njk3NSIsIndlYnBhY2s6Ly92dWUzLXdlYnBhY2s1Ly4vbm9kZV9tb2R1bGVzL2Nlc2l1bS9Tb3VyY2UvU2hhZGVycy9CdWlsdGluL0Z1bmN0aW9ucy9kZWNvbXByZXNzVGV4dHVyZUNvb3JkaW5hdGVzLmpzP2I4NmIiLCJ3ZWJwYWNrOi8vdnVlMy13ZWJwYWNrNS8uL25vZGVfbW9kdWxlcy9jZXNpdW0vU291cmNlL1NoYWRlcnMvQnVpbHRpbi9GdW5jdGlvbnMvZGVmYXVsdFBick1hdGVyaWFsLmpzPzYxZjYiLCJ3ZWJwYWNrOi8vdnVlMy13ZWJwYWNrNS8uL25vZGVfbW9kdWxlcy9jZXNpdW0vU291cmNlL1NoYWRlcnMvQnVpbHRpbi9GdW5jdGlvbnMvZGVwdGhDbGFtcC5qcz9hZGFjIiwid2VicGFjazovL3Z1ZTMtd2VicGFjazUvLi9ub2RlX21vZHVsZXMvY2VzaXVtL1NvdXJjZS9TaGFkZXJzL0J1aWx0aW4vRnVuY3Rpb25zL2Vhc3ROb3J0aFVwVG9FeWVDb29yZGluYXRlcy5qcz9hZTNjIiwid2VicGFjazovL3Z1ZTMtd2VicGFjazUvLi9ub2RlX21vZHVsZXMvY2VzaXVtL1NvdXJjZS9TaGFkZXJzL0J1aWx0aW4vRnVuY3Rpb25zL2VsbGlwc29pZENvbnRhaW5zUG9pbnQuanM/YzU5YSIsIndlYnBhY2s6Ly92dWUzLXdlYnBhY2s1Ly4vbm9kZV9tb2R1bGVzL2Nlc2l1bS9Tb3VyY2UvU2hhZGVycy9CdWlsdGluL0Z1bmN0aW9ucy9lbGxpcHNvaWRXZ3M4NFRleHR1cmVDb29yZGluYXRlcy5qcz8zNDM5Iiwid2VicGFjazovL3Z1ZTMtd2VicGFjazUvLi9ub2RlX21vZHVsZXMvY2VzaXVtL1NvdXJjZS9TaGFkZXJzL0J1aWx0aW4vRnVuY3Rpb25zL2VxdWFsc0Vwc2lsb24uanM/NGZhOSIsIndlYnBhY2s6Ly92dWUzLXdlYnBhY2s1Ly4vbm9kZV9tb2R1bGVzL2Nlc2l1bS9Tb3VyY2UvU2hhZGVycy9CdWlsdGluL0Z1bmN0aW9ucy9leWVPZmZzZXQuanM/MjViYSIsIndlYnBhY2s6Ly92dWUzLXdlYnBhY2s1Ly4vbm9kZV9tb2R1bGVzL2Nlc2l1bS9Tb3VyY2UvU2hhZGVycy9CdWlsdGluL0Z1bmN0aW9ucy9leWVUb1dpbmRvd0Nvb3JkaW5hdGVzLmpzP2ZjMjEiLCJ3ZWJwYWNrOi8vdnVlMy13ZWJwYWNrNS8uL25vZGVfbW9kdWxlcy9jZXNpdW0vU291cmNlL1NoYWRlcnMvQnVpbHRpbi9GdW5jdGlvbnMvZmFzdEFwcHJveGltYXRlQXRhbi5qcz8xZjFhIiwid2VicGFjazovL3Z1ZTMtd2VicGFjazUvLi9ub2RlX21vZHVsZXMvY2VzaXVtL1NvdXJjZS9TaGFkZXJzL0J1aWx0aW4vRnVuY3Rpb25zL2ZvZy5qcz85YzA2Iiwid2VicGFjazovL3Z1ZTMtd2VicGFjazUvLi9ub2RlX21vZHVsZXMvY2VzaXVtL1NvdXJjZS9TaGFkZXJzL0J1aWx0aW4vRnVuY3Rpb25zL2dhbW1hQ29ycmVjdC5qcz80NDFlIiwid2VicGFjazovL3Z1ZTMtd2VicGFjazUvLi9ub2RlX21vZHVsZXMvY2VzaXVtL1NvdXJjZS9TaGFkZXJzL0J1aWx0aW4vRnVuY3Rpb25zL2dlb2RldGljU3VyZmFjZU5vcm1hbC5qcz80OWNlIiwid2VicGFjazovL3Z1ZTMtd2VicGFjazUvLi9ub2RlX21vZHVsZXMvY2VzaXVtL1NvdXJjZS9TaGFkZXJzL0J1aWx0aW4vRnVuY3Rpb25zL2dldERlZmF1bHRNYXRlcmlhbC5qcz82Y2JjIiwid2VicGFjazovL3Z1ZTMtd2VicGFjazUvLi9ub2RlX21vZHVsZXMvY2VzaXVtL1NvdXJjZS9TaGFkZXJzL0J1aWx0aW4vRnVuY3Rpb25zL2dldExhbWJlcnREaWZmdXNlLmpzPzdiZDYiLCJ3ZWJwYWNrOi8vdnVlMy13ZWJwYWNrNS8uL25vZGVfbW9kdWxlcy9jZXNpdW0vU291cmNlL1NoYWRlcnMvQnVpbHRpbi9GdW5jdGlvbnMvZ2V0U3BlY3VsYXIuanM/OWIzNCIsIndlYnBhY2s6Ly92dWUzLXdlYnBhY2s1Ly4vbm9kZV9tb2R1bGVzL2Nlc2l1bS9Tb3VyY2UvU2hhZGVycy9CdWlsdGluL0Z1bmN0aW9ucy9nZXRXYXRlck5vaXNlLmpzPzhlY2QiLCJ3ZWJwYWNrOi8vdnVlMy13ZWJwYWNrNS8uL25vZGVfbW9kdWxlcy9jZXNpdW0vU291cmNlL1NoYWRlcnMvQnVpbHRpbi9GdW5jdGlvbnMvaHVlLmpzPzFmODMiLCJ3ZWJwYWNrOi8vdnVlMy13ZWJwYWNrNS8uL25vZGVfbW9kdWxlcy9jZXNpdW0vU291cmNlL1NoYWRlcnMvQnVpbHRpbi9GdW5jdGlvbnMvaW52ZXJzZUdhbW1hLmpzPzg3OWUiLCJ3ZWJwYWNrOi8vdnVlMy13ZWJwYWNrNS8uL25vZGVfbW9kdWxlcy9jZXNpdW0vU291cmNlL1NoYWRlcnMvQnVpbHRpbi9GdW5jdGlvbnMvaXNFbXB0eS5qcz8wYWYxIiwid2VicGFjazovL3Z1ZTMtd2VicGFjazUvLi9ub2RlX21vZHVsZXMvY2VzaXVtL1NvdXJjZS9TaGFkZXJzL0J1aWx0aW4vRnVuY3Rpb25zL2lzRnVsbC5qcz82YzdiIiwid2VicGFjazovL3Z1ZTMtd2VicGFjazUvLi9ub2RlX21vZHVsZXMvY2VzaXVtL1NvdXJjZS9TaGFkZXJzL0J1aWx0aW4vRnVuY3Rpb25zL2xhdGl0dWRlVG9XZWJNZXJjYXRvckZyYWN0aW9uLmpzP2E3ZDgiLCJ3ZWJwYWNrOi8vdnVlMy13ZWJwYWNrNS8uL25vZGVfbW9kdWxlcy9jZXNpdW0vU291cmNlL1NoYWRlcnMvQnVpbHRpbi9GdW5jdGlvbnMvbGluZURpc3RhbmNlLmpzPzcwM2IiLCJ3ZWJwYWNrOi8vdnVlMy13ZWJwYWNrNS8uL25vZGVfbW9kdWxlcy9jZXNpdW0vU291cmNlL1NoYWRlcnMvQnVpbHRpbi9GdW5jdGlvbnMvbHVtaW5hbmNlLmpzPzk3YmUiLCJ3ZWJwYWNrOi8vdnVlMy13ZWJwYWNrNS8uL25vZGVfbW9kdWxlcy9jZXNpdW0vU291cmNlL1NoYWRlcnMvQnVpbHRpbi9GdW5jdGlvbnMvbWV0ZXJzUGVyUGl4ZWwuanM/YmZhNyIsIndlYnBhY2s6Ly92dWUzLXdlYnBhY2s1Ly4vbm9kZV9tb2R1bGVzL2Nlc2l1bS9Tb3VyY2UvU2hhZGVycy9CdWlsdGluL0Z1bmN0aW9ucy9tb2RlbFRvV2luZG93Q29vcmRpbmF0ZXMuanM/YjZmMiIsIndlYnBhY2s6Ly92dWUzLXdlYnBhY2s1Ly4vbm9kZV9tb2R1bGVzL2Nlc2l1bS9Tb3VyY2UvU2hhZGVycy9CdWlsdGluL0Z1bmN0aW9ucy9tdWx0aXBseVdpdGhDb2xvckJhbGFuY2UuanM/MjcxMyIsIndlYnBhY2s6Ly92dWUzLXdlYnBhY2s1Ly4vbm9kZV9tb2R1bGVzL2Nlc2l1bS9Tb3VyY2UvU2hhZGVycy9CdWlsdGluL0Z1bmN0aW9ucy9uZWFyRmFyU2NhbGFyLmpzP2Q4MWMiLCJ3ZWJwYWNrOi8vdnVlMy13ZWJwYWNrNS8uL25vZGVfbW9kdWxlcy9jZXNpdW0vU291cmNlL1NoYWRlcnMvQnVpbHRpbi9GdW5jdGlvbnMvb2N0RGVjb2RlLmpzPzFlODkiLCJ3ZWJwYWNrOi8vdnVlMy13ZWJwYWNrNS8uL25vZGVfbW9kdWxlcy9jZXNpdW0vU291cmNlL1NoYWRlcnMvQnVpbHRpbi9GdW5jdGlvbnMvcGFja0RlcHRoLmpzPzZkMjIiLCJ3ZWJwYWNrOi8vdnVlMy13ZWJwYWNrNS8uL25vZGVfbW9kdWxlcy9jZXNpdW0vU291cmNlL1NoYWRlcnMvQnVpbHRpbi9GdW5jdGlvbnMvcGJyTGlnaHRpbmcuanM/Y2Q3MyIsIndlYnBhY2s6Ly92dWUzLXdlYnBhY2s1Ly4vbm9kZV9tb2R1bGVzL2Nlc2l1bS9Tb3VyY2UvU2hhZGVycy9CdWlsdGluL0Z1bmN0aW9ucy9wYnJNZXRhbGxpY1JvdWdobmVzc01hdGVyaWFsLmpzP2Y4MjciLCJ3ZWJwYWNrOi8vdnVlMy13ZWJwYWNrNS8uL25vZGVfbW9kdWxlcy9jZXNpdW0vU291cmNlL1NoYWRlcnMvQnVpbHRpbi9GdW5jdGlvbnMvcGJyU3BlY3VsYXJHbG9zc2luZXNzTWF0ZXJpYWwuanM/Y2FlYiIsIndlYnBhY2s6Ly92dWUzLXdlYnBhY2s1Ly4vbm9kZV9tb2R1bGVzL2Nlc2l1bS9Tb3VyY2UvU2hhZGVycy9CdWlsdGluL0Z1bmN0aW9ucy9waG9uZy5qcz9hNDM2Iiwid2VicGFjazovL3Z1ZTMtd2VicGFjazUvLi9ub2RlX21vZHVsZXMvY2VzaXVtL1NvdXJjZS9TaGFkZXJzL0J1aWx0aW4vRnVuY3Rpb25zL3BsYW5lRGlzdGFuY2UuanM/ZGEyMyIsIndlYnBhY2s6Ly92dWUzLXdlYnBhY2s1Ly4vbm9kZV9tb2R1bGVzL2Nlc2l1bS9Tb3VyY2UvU2hhZGVycy9CdWlsdGluL0Z1bmN0aW9ucy9wb2ludEFsb25nUmF5LmpzP2ZiMjAiLCJ3ZWJwYWNrOi8vdnVlMy13ZWJwYWNrNS8uL25vZGVfbW9kdWxlcy9jZXNpdW0vU291cmNlL1NoYWRlcnMvQnVpbHRpbi9GdW5jdGlvbnMvcmF5RWxsaXBzb2lkSW50ZXJzZWN0aW9uSW50ZXJ2YWwuanM/MzIwMCIsIndlYnBhY2s6Ly92dWUzLXdlYnBhY2s1Ly4vbm9kZV9tb2R1bGVzL2Nlc2l1bS9Tb3VyY2UvU2hhZGVycy9CdWlsdGluL0Z1bmN0aW9ucy9yZWFkRGVwdGguanM/YmU0YiIsIndlYnBhY2s6Ly92dWUzLXdlYnBhY2s1Ly4vbm9kZV9tb2R1bGVzL2Nlc2l1bS9Tb3VyY2UvU2hhZGVycy9CdWlsdGluL0Z1bmN0aW9ucy9yZWFkTm9uUGVyc3BlY3RpdmUuanM/ZWVlMiIsIndlYnBhY2s6Ly92dWUzLXdlYnBhY2s1Ly4vbm9kZV9tb2R1bGVzL2Nlc2l1bS9Tb3VyY2UvU2hhZGVycy9CdWlsdGluL0Z1bmN0aW9ucy9yZXZlcnNlTG9nRGVwdGguanM/NDQ1NCIsIndlYnBhY2s6Ly92dWUzLXdlYnBhY2s1Ly4vbm9kZV9tb2R1bGVzL2Nlc2l1bS9Tb3VyY2UvU2hhZGVycy9CdWlsdGluL0Z1bmN0aW9ucy9zYW1wbGVPY3RhaGVkcmFsUHJvamVjdGlvbi5qcz9lZjgyIiwid2VicGFjazovL3Z1ZTMtd2VicGFjazUvLi9ub2RlX21vZHVsZXMvY2VzaXVtL1NvdXJjZS9TaGFkZXJzL0J1aWx0aW4vRnVuY3Rpb25zL3NhdHVyYXRpb24uanM/OTc2NiIsIndlYnBhY2s6Ly92dWUzLXdlYnBhY2s1Ly4vbm9kZV9tb2R1bGVzL2Nlc2l1bS9Tb3VyY2UvU2hhZGVycy9CdWlsdGluL0Z1bmN0aW9ucy9zaGFkb3dEZXB0aENvbXBhcmUuanM/ZWNkOSIsIndlYnBhY2s6Ly92dWUzLXdlYnBhY2s1Ly4vbm9kZV9tb2R1bGVzL2Nlc2l1bS9Tb3VyY2UvU2hhZGVycy9CdWlsdGluL0Z1bmN0aW9ucy9zaGFkb3dWaXNpYmlsaXR5LmpzP2ExMGIiLCJ3ZWJwYWNrOi8vdnVlMy13ZWJwYWNrNS8uL25vZGVfbW9kdWxlcy9jZXNpdW0vU291cmNlL1NoYWRlcnMvQnVpbHRpbi9GdW5jdGlvbnMvc2lnbk5vdFplcm8uanM/Mjc4NiIsIndlYnBhY2s6Ly92dWUzLXdlYnBhY2s1Ly4vbm9kZV9tb2R1bGVzL2Nlc2l1bS9Tb3VyY2UvU2hhZGVycy9CdWlsdGluL0Z1bmN0aW9ucy9zcGhlcmljYWxIYXJtb25pY3MuanM/NWMwZCIsIndlYnBhY2s6Ly92dWUzLXdlYnBhY2s1Ly4vbm9kZV9tb2R1bGVzL2Nlc2l1bS9Tb3VyY2UvU2hhZGVycy9CdWlsdGluL0Z1bmN0aW9ucy90YW5nZW50VG9FeWVTcGFjZU1hdHJpeC5qcz81ZjI1Iiwid2VicGFjazovL3Z1ZTMtd2VicGFjazUvLi9ub2RlX21vZHVsZXMvY2VzaXVtL1NvdXJjZS9TaGFkZXJzL0J1aWx0aW4vRnVuY3Rpb25zL3RyYW5zZm9ybVBsYW5lLmpzP2IzYzgiLCJ3ZWJwYWNrOi8vdnVlMy13ZWJwYWNrNS8uL25vZGVfbW9kdWxlcy9jZXNpdW0vU291cmNlL1NoYWRlcnMvQnVpbHRpbi9GdW5jdGlvbnMvdHJhbnNsYXRlUmVsYXRpdmVUb0V5ZS5qcz9lYzI4Iiwid2VicGFjazovL3Z1ZTMtd2VicGFjazUvLi9ub2RlX21vZHVsZXMvY2VzaXVtL1NvdXJjZS9TaGFkZXJzL0J1aWx0aW4vRnVuY3Rpb25zL3RyYW5zbHVjZW50UGhvbmcuanM/NWMzNSIsIndlYnBhY2s6Ly92dWUzLXdlYnBhY2s1Ly4vbm9kZV9tb2R1bGVzL2Nlc2l1bS9Tb3VyY2UvU2hhZGVycy9CdWlsdGluL0Z1bmN0aW9ucy90cmFuc3Bvc2UuanM/NzYxMyIsIndlYnBhY2s6Ly92dWUzLXdlYnBhY2s1Ly4vbm9kZV9tb2R1bGVzL2Nlc2l1bS9Tb3VyY2UvU2hhZGVycy9CdWlsdGluL0Z1bmN0aW9ucy91bnBhY2tEZXB0aC5qcz84Zjg3Iiwid2VicGFjazovL3Z1ZTMtd2VicGFjazUvLi9ub2RlX21vZHVsZXMvY2VzaXVtL1NvdXJjZS9TaGFkZXJzL0J1aWx0aW4vRnVuY3Rpb25zL3VucGFja0Zsb2F0LmpzP2NlNWUiLCJ3ZWJwYWNrOi8vdnVlMy13ZWJwYWNrNS8uL25vZGVfbW9kdWxlcy9jZXNpdW0vU291cmNlL1NoYWRlcnMvQnVpbHRpbi9GdW5jdGlvbnMvdmVydGV4TG9nRGVwdGguanM/NjNjYyIsIndlYnBhY2s6Ly92dWUzLXdlYnBhY2s1Ly4vbm9kZV9tb2R1bGVzL2Nlc2l1bS9Tb3VyY2UvU2hhZGVycy9CdWlsdGluL0Z1bmN0aW9ucy93aW5kb3dUb0V5ZUNvb3JkaW5hdGVzLmpzPzI3Y2EiLCJ3ZWJwYWNrOi8vdnVlMy13ZWJwYWNrNS8uL25vZGVfbW9kdWxlcy9jZXNpdW0vU291cmNlL1NoYWRlcnMvQnVpbHRpbi9GdW5jdGlvbnMvd3JpdGVEZXB0aENsYW1wLmpzP2U5ZjAiLCJ3ZWJwYWNrOi8vdnVlMy13ZWJwYWNrNS8uL25vZGVfbW9kdWxlcy9jZXNpdW0vU291cmNlL1NoYWRlcnMvQnVpbHRpbi9GdW5jdGlvbnMvd3JpdGVMb2dEZXB0aC5qcz9iNzQ1Iiwid2VicGFjazovL3Z1ZTMtd2VicGFjazUvLi9ub2RlX21vZHVsZXMvY2VzaXVtL1NvdXJjZS9TaGFkZXJzL0J1aWx0aW4vRnVuY3Rpb25zL3dyaXRlTm9uUGVyc3BlY3RpdmUuanM/YWQ1YyIsIndlYnBhY2s6Ly92dWUzLXdlYnBhY2s1Ly4vbm9kZV9tb2R1bGVzL2Nlc2l1bS9Tb3VyY2UvU2hhZGVycy9CdWlsdGluL0N6bUJ1aWx0aW5zLmpzPzY0OWIiXSwic291cmNlc0NvbnRlbnQiOlsiLy9UaGlzIGZpbGUgaXMgYXV0b21hdGljYWxseSByZWJ1aWx0IGJ5IHRoZSBDZXNpdW0gYnVpbGQgcHJvY2Vzcy5cbmV4cG9ydCBkZWZhdWx0IFwiLyoqXFxuXFxcbiAqIEEgYnVpbHQtaW4gR0xTTCBmbG9hdGluZy1wb2ludCBjb25zdGFudCBmb3IgY29udmVydGluZyByYWRpYW5zIHRvIGRlZ3JlZXMuXFxuXFxcbiAqXFxuXFxcbiAqIEBhbGlhcyBjem1fZGVncmVlc1BlclJhZGlhblxcblxcXG4gKiBAZ2xzbENvbnN0YW50XFxuXFxcbiAqXFxuXFxcbiAqIEBzZWUgQ2VzaXVtTWF0aC5ERUdSRUVTX1BFUl9SQURJQU5cXG5cXFxuICpcXG5cXFxuICogQGV4YW1wbGVcXG5cXFxuICogLy8gR0xTTCBkZWNsYXJhdGlvblxcblxcXG4gKiBjb25zdCBmbG9hdCBjem1fZGVncmVlc1BlclJhZGlhbiA9IC4uLjtcXG5cXFxuICpcXG5cXFxuICogLy8gRXhhbXBsZVxcblxcXG4gKiBmbG9hdCBkZWcgPSBjem1fZGVncmVlc1BlclJhZGlhbiAqIHJhZDtcXG5cXFxuICovXFxuXFxcbmNvbnN0IGZsb2F0IGN6bV9kZWdyZWVzUGVyUmFkaWFuID0gNTcuMjk1Nzc5NTEzMDgyMzI7XFxuXFxcblwiO1xuIiwiLy9UaGlzIGZpbGUgaXMgYXV0b21hdGljYWxseSByZWJ1aWx0IGJ5IHRoZSBDZXNpdW0gYnVpbGQgcHJvY2Vzcy5cbmV4cG9ydCBkZWZhdWx0IFwiLyoqXFxuXFxcbiAqIEEgYnVpbHQtaW4gR0xTTCB2ZWMyIGNvbnN0YW50IGZvciBkZWZpbmluZyB0aGUgZGVwdGggcmFuZ2UuXFxuXFxcbiAqIFRoaXMgaXMgYSB3b3JrYXJvdW5kIHRvIGEgYnVnIHdoZXJlIElFMTEgZG9lcyBub3QgaW1wbGVtZW50IGdsX0RlcHRoUmFuZ2UuXFxuXFxcbiAqXFxuXFxcbiAqIEBhbGlhcyBjem1fZGVwdGhSYW5nZVxcblxcXG4gKiBAZ2xzbENvbnN0YW50XFxuXFxcbiAqXFxuXFxcbiAqIEBleGFtcGxlXFxuXFxcbiAqIC8vIEdMU0wgZGVjbGFyYXRpb25cXG5cXFxuICogZmxvYXQgZGVwdGhSYW5nZU5lYXIgPSBjem1fZGVwdGhSYW5nZS5uZWFyO1xcblxcXG4gKiBmbG9hdCBkZXB0aFJhbmdlRmFyID0gY3ptX2RlcHRoUmFuZ2UuZmFyO1xcblxcXG4gKlxcblxcXG4gKi9cXG5cXFxuY29uc3QgY3ptX2RlcHRoUmFuZ2VTdHJ1Y3QgY3ptX2RlcHRoUmFuZ2UgPSBjem1fZGVwdGhSYW5nZVN0cnVjdCgwLjAsIDEuMCk7XFxuXFxcblwiO1xuIiwiLy9UaGlzIGZpbGUgaXMgYXV0b21hdGljYWxseSByZWJ1aWx0IGJ5IHRoZSBDZXNpdW0gYnVpbGQgcHJvY2Vzcy5cbmV4cG9ydCBkZWZhdWx0IFwiLyoqXFxuXFxcbiAqIDAuMVxcblxcXG4gKlxcblxcXG4gKiBAbmFtZSBjem1fZXBzaWxvbjFcXG5cXFxuICogQGdsc2xDb25zdGFudFxcblxcXG4gKi9cXG5cXFxuY29uc3QgZmxvYXQgY3ptX2Vwc2lsb24xID0gMC4xO1xcblxcXG5cIjtcbiIsIi8vVGhpcyBmaWxlIGlzIGF1dG9tYXRpY2FsbHkgcmVidWlsdCBieSB0aGUgQ2VzaXVtIGJ1aWxkIHByb2Nlc3MuXG5leHBvcnQgZGVmYXVsdCBcIi8qKlxcblxcXG4gKiAwLjAxXFxuXFxcbiAqXFxuXFxcbiAqIEBuYW1lIGN6bV9lcHNpbG9uMlxcblxcXG4gKiBAZ2xzbENvbnN0YW50XFxuXFxcbiAqL1xcblxcXG5jb25zdCBmbG9hdCBjem1fZXBzaWxvbjIgPSAwLjAxO1xcblxcXG5cIjtcbiIsIi8vVGhpcyBmaWxlIGlzIGF1dG9tYXRpY2FsbHkgcmVidWlsdCBieSB0aGUgQ2VzaXVtIGJ1aWxkIHByb2Nlc3MuXG5leHBvcnQgZGVmYXVsdCBcIi8qKlxcblxcXG4gKiAwLjAwMVxcblxcXG4gKlxcblxcXG4gKiBAbmFtZSBjem1fZXBzaWxvbjNcXG5cXFxuICogQGdsc2xDb25zdGFudFxcblxcXG4gKi9cXG5cXFxuY29uc3QgZmxvYXQgY3ptX2Vwc2lsb24zID0gMC4wMDE7XFxuXFxcblwiO1xuIiwiLy9UaGlzIGZpbGUgaXMgYXV0b21hdGljYWxseSByZWJ1aWx0IGJ5IHRoZSBDZXNpdW0gYnVpbGQgcHJvY2Vzcy5cbmV4cG9ydCBkZWZhdWx0IFwiLyoqXFxuXFxcbiAqIDAuMDAwMVxcblxcXG4gKlxcblxcXG4gKiBAbmFtZSBjem1fZXBzaWxvbjRcXG5cXFxuICogQGdsc2xDb25zdGFudFxcblxcXG4gKi9cXG5cXFxuY29uc3QgZmxvYXQgY3ptX2Vwc2lsb240ID0gMC4wMDAxO1xcblxcXG5cIjtcbiIsIi8vVGhpcyBmaWxlIGlzIGF1dG9tYXRpY2FsbHkgcmVidWlsdCBieSB0aGUgQ2VzaXVtIGJ1aWxkIHByb2Nlc3MuXG5leHBvcnQgZGVmYXVsdCBcIi8qKlxcblxcXG4gKiAwLjAwMDAxXFxuXFxcbiAqXFxuXFxcbiAqIEBuYW1lIGN6bV9lcHNpbG9uNVxcblxcXG4gKiBAZ2xzbENvbnN0YW50XFxuXFxcbiAqL1xcblxcXG5jb25zdCBmbG9hdCBjem1fZXBzaWxvbjUgPSAwLjAwMDAxO1xcblxcXG5cIjtcbiIsIi8vVGhpcyBmaWxlIGlzIGF1dG9tYXRpY2FsbHkgcmVidWlsdCBieSB0aGUgQ2VzaXVtIGJ1aWxkIHByb2Nlc3MuXG5leHBvcnQgZGVmYXVsdCBcIi8qKlxcblxcXG4gKiAwLjAwMDAwMVxcblxcXG4gKlxcblxcXG4gKiBAbmFtZSBjem1fZXBzaWxvbjZcXG5cXFxuICogQGdsc2xDb25zdGFudFxcblxcXG4gKi9cXG5cXFxuY29uc3QgZmxvYXQgY3ptX2Vwc2lsb242ID0gMC4wMDAwMDE7XFxuXFxcblwiO1xuIiwiLy9UaGlzIGZpbGUgaXMgYXV0b21hdGljYWxseSByZWJ1aWx0IGJ5IHRoZSBDZXNpdW0gYnVpbGQgcHJvY2Vzcy5cbmV4cG9ydCBkZWZhdWx0IFwiLyoqXFxuXFxcbiAqIDAuMDAwMDAwMVxcblxcXG4gKlxcblxcXG4gKiBAbmFtZSBjem1fZXBzaWxvbjdcXG5cXFxuICogQGdsc2xDb25zdGFudFxcblxcXG4gKi9cXG5cXFxuY29uc3QgZmxvYXQgY3ptX2Vwc2lsb243ID0gMC4wMDAwMDAxO1xcblxcXG5cIjtcbiIsIi8vVGhpcyBmaWxlIGlzIGF1dG9tYXRpY2FsbHkgcmVidWlsdCBieSB0aGUgQ2VzaXVtIGJ1aWxkIHByb2Nlc3MuXG5leHBvcnQgZGVmYXVsdCBcIi8qKlxcblxcXG4gKiBET0NfVEJBXFxuXFxcbiAqXFxuXFxcbiAqIEBuYW1lIGN6bV9pbmZpbml0eVxcblxcXG4gKiBAZ2xzbENvbnN0YW50XFxuXFxcbiAqL1xcblxcXG5jb25zdCBmbG9hdCBjem1faW5maW5pdHkgPSA1OTA2Mzc2MjcyMDAwLjA7ICAvLyBEaXN0YW5jZSBmcm9tIHRoZSBTdW4gdG8gUGx1dG8gaW4gbWV0ZXJzLiAgVE9ETzogV2hhdCBpcyBiZXN0IGdpdmVuIGxvd3AsIG1lZGl1bXAsIGFuZCBoaWdocD9cXG5cXFxuXCI7XG4iLCIvL1RoaXMgZmlsZSBpcyBhdXRvbWF0aWNhbGx5IHJlYnVpbHQgYnkgdGhlIENlc2l1bSBidWlsZCBwcm9jZXNzLlxuZXhwb3J0IGRlZmF1bHQgXCIvKipcXG5cXFxuICogQSBidWlsdC1pbiBHTFNMIGZsb2F0aW5nLXBvaW50IGNvbnN0YW50IGZvciA8Y29kZT4xL3BpPC9jb2RlPi5cXG5cXFxuICpcXG5cXFxuICogQGFsaWFzIGN6bV9vbmVPdmVyUGlcXG5cXFxuICogQGdsc2xDb25zdGFudFxcblxcXG4gKlxcblxcXG4gKiBAc2VlIENlc2l1bU1hdGguT05FX09WRVJfUElcXG5cXFxuICpcXG5cXFxuICogQGV4YW1wbGVcXG5cXFxuICogLy8gR0xTTCBkZWNsYXJhdGlvblxcblxcXG4gKiBjb25zdCBmbG9hdCBjem1fb25lT3ZlclBpID0gLi4uO1xcblxcXG4gKlxcblxcXG4gKiAvLyBFeGFtcGxlXFxuXFxcbiAqIGZsb2F0IHBpID0gMS4wIC8gY3ptX29uZU92ZXJQaTtcXG5cXFxuICovXFxuXFxcbmNvbnN0IGZsb2F0IGN6bV9vbmVPdmVyUGkgPSAwLjMxODMwOTg4NjE4Mzc5MDc7XFxuXFxcblwiO1xuIiwiLy9UaGlzIGZpbGUgaXMgYXV0b21hdGljYWxseSByZWJ1aWx0IGJ5IHRoZSBDZXNpdW0gYnVpbGQgcHJvY2Vzcy5cbmV4cG9ydCBkZWZhdWx0IFwiLyoqXFxuXFxcbiAqIEEgYnVpbHQtaW4gR0xTTCBmbG9hdGluZy1wb2ludCBjb25zdGFudCBmb3IgPGNvZGU+MS8ycGk8L2NvZGU+LlxcblxcXG4gKlxcblxcXG4gKiBAYWxpYXMgY3ptX29uZU92ZXJUd29QaVxcblxcXG4gKiBAZ2xzbENvbnN0YW50XFxuXFxcbiAqXFxuXFxcbiAqIEBzZWUgQ2VzaXVtTWF0aC5PTkVfT1ZFUl9UV09fUElcXG5cXFxuICpcXG5cXFxuICogQGV4YW1wbGVcXG5cXFxuICogLy8gR0xTTCBkZWNsYXJhdGlvblxcblxcXG4gKiBjb25zdCBmbG9hdCBjem1fb25lT3ZlclR3b1BpID0gLi4uO1xcblxcXG4gKlxcblxcXG4gKiAvLyBFeGFtcGxlXFxuXFxcbiAqIGZsb2F0IHBpID0gMi4wICogY3ptX29uZU92ZXJUd29QaTtcXG5cXFxuICovXFxuXFxcbmNvbnN0IGZsb2F0IGN6bV9vbmVPdmVyVHdvUGkgPSAwLjE1OTE1NDk0MzA5MTg5NTM1O1xcblxcXG5cIjtcbiIsIi8vVGhpcyBmaWxlIGlzIGF1dG9tYXRpY2FsbHkgcmVidWlsdCBieSB0aGUgQ2VzaXVtIGJ1aWxkIHByb2Nlc3MuXG5leHBvcnQgZGVmYXVsdCBcIi8qKlxcblxcXG4gKiBUaGUgYXV0b21hdGljIEdMU0wgY29uc3RhbnQgZm9yIHtAbGluayBQYXNzI0NFU0lVTV8zRF9USUxFfVxcblxcXG4gKlxcblxcXG4gKiBAbmFtZSBjem1fcGFzc0Nlc2l1bTNEVGlsZVxcblxcXG4gKiBAZ2xzbENvbnN0YW50XFxuXFxcbiAqXFxuXFxcbiAqIEBzZWUgY3ptX3Bhc3NcXG5cXFxuICovXFxuXFxcbmNvbnN0IGZsb2F0IGN6bV9wYXNzQ2VzaXVtM0RUaWxlID0gNC4wO1xcblxcXG5cIjtcbiIsIi8vVGhpcyBmaWxlIGlzIGF1dG9tYXRpY2FsbHkgcmVidWlsdCBieSB0aGUgQ2VzaXVtIGJ1aWxkIHByb2Nlc3MuXG5leHBvcnQgZGVmYXVsdCBcIi8qKlxcblxcXG4gKiBUaGUgYXV0b21hdGljIEdMU0wgY29uc3RhbnQgZm9yIHtAbGluayBQYXNzI0NFU0lVTV8zRF9USUxFX0NMQVNTSUZJQ0FUSU9OfVxcblxcXG4gKlxcblxcXG4gKiBAbmFtZSBjem1fcGFzc0Nlc2l1bTNEVGlsZUNsYXNzaWZpY2F0aW9uXFxuXFxcbiAqIEBnbHNsQ29uc3RhbnRcXG5cXFxuICpcXG5cXFxuICogQHNlZSBjem1fcGFzc1xcblxcXG4gKi9cXG5cXFxuY29uc3QgZmxvYXQgY3ptX3Bhc3NDZXNpdW0zRFRpbGVDbGFzc2lmaWNhdGlvbiA9IDUuMDtcXG5cXFxuXCI7XG4iLCIvL1RoaXMgZmlsZSBpcyBhdXRvbWF0aWNhbGx5IHJlYnVpbHQgYnkgdGhlIENlc2l1bSBidWlsZCBwcm9jZXNzLlxuZXhwb3J0IGRlZmF1bHQgXCIvKipcXG5cXFxuICogVGhlIGF1dG9tYXRpYyBHTFNMIGNvbnN0YW50IGZvciB7QGxpbmsgUGFzcyNDRVNJVU1fM0RfVElMRV9DTEFTU0lGSUNBVElPTl9JR05PUkVfU0hPV31cXG5cXFxuICpcXG5cXFxuICogQG5hbWUgY3ptX3Bhc3NDZXNpdW0zRFRpbGVDbGFzc2lmaWNhdGlvbklnbm9yZVNob3dcXG5cXFxuICogQGdsc2xDb25zdGFudFxcblxcXG4gKlxcblxcXG4gKiBAc2VlIGN6bV9wYXNzXFxuXFxcbiAqL1xcblxcXG5jb25zdCBmbG9hdCBjem1fcGFzc0Nlc2l1bTNEVGlsZUNsYXNzaWZpY2F0aW9uSWdub3JlU2hvdyA9IDYuMDtcXG5cXFxuXCI7XG4iLCIvL1RoaXMgZmlsZSBpcyBhdXRvbWF0aWNhbGx5IHJlYnVpbHQgYnkgdGhlIENlc2l1bSBidWlsZCBwcm9jZXNzLlxuZXhwb3J0IGRlZmF1bHQgXCIvKipcXG5cXFxuICogVGhlIGF1dG9tYXRpYyBHTFNMIGNvbnN0YW50IGZvciB7QGxpbmsgUGFzcyNDTEFTU0lGSUNBVElPTn1cXG5cXFxuICpcXG5cXFxuICogQG5hbWUgY3ptX3Bhc3NDbGFzc2lmaWNhdGlvblxcblxcXG4gKiBAZ2xzbENvbnN0YW50XFxuXFxcbiAqXFxuXFxcbiAqIEBzZWUgY3ptX3Bhc3NcXG5cXFxuICovXFxuXFxcbmNvbnN0IGZsb2F0IGN6bV9wYXNzQ2xhc3NpZmljYXRpb24gPSA3LjA7XFxuXFxcblwiO1xuIiwiLy9UaGlzIGZpbGUgaXMgYXV0b21hdGljYWxseSByZWJ1aWx0IGJ5IHRoZSBDZXNpdW0gYnVpbGQgcHJvY2Vzcy5cbmV4cG9ydCBkZWZhdWx0IFwiLyoqXFxuXFxcbiAqIFRoZSBhdXRvbWF0aWMgR0xTTCBjb25zdGFudCBmb3Ige0BsaW5rIFBhc3MjQ09NUFVURX1cXG5cXFxuICpcXG5cXFxuICogQG5hbWUgY3ptX3Bhc3NDb21wdXRlXFxuXFxcbiAqIEBnbHNsQ29uc3RhbnRcXG5cXFxuICpcXG5cXFxuICogQHNlZSBjem1fcGFzc1xcblxcXG4gKi9cXG5cXFxuY29uc3QgZmxvYXQgY3ptX3Bhc3NDb21wdXRlID0gMS4wO1xcblxcXG5cIjtcbiIsIi8vVGhpcyBmaWxlIGlzIGF1dG9tYXRpY2FsbHkgcmVidWlsdCBieSB0aGUgQ2VzaXVtIGJ1aWxkIHByb2Nlc3MuXG5leHBvcnQgZGVmYXVsdCBcIi8qKlxcblxcXG4gKiBUaGUgYXV0b21hdGljIEdMU0wgY29uc3RhbnQgZm9yIHtAbGluayBQYXNzI0VOVklST05NRU5UfVxcblxcXG4gKlxcblxcXG4gKiBAbmFtZSBjem1fcGFzc0Vudmlyb25tZW50XFxuXFxcbiAqIEBnbHNsQ29uc3RhbnRcXG5cXFxuICpcXG5cXFxuICogQHNlZSBjem1fcGFzc1xcblxcXG4gKi9cXG5cXFxuY29uc3QgZmxvYXQgY3ptX3Bhc3NFbnZpcm9ubWVudCA9IDAuMDtcXG5cXFxuXCI7XG4iLCIvL1RoaXMgZmlsZSBpcyBhdXRvbWF0aWNhbGx5IHJlYnVpbHQgYnkgdGhlIENlc2l1bSBidWlsZCBwcm9jZXNzLlxuZXhwb3J0IGRlZmF1bHQgXCIvKipcXG5cXFxuICogVGhlIGF1dG9tYXRpYyBHTFNMIGNvbnN0YW50IGZvciB7QGxpbmsgUGFzcyNHTE9CRX1cXG5cXFxuICpcXG5cXFxuICogQG5hbWUgY3ptX3Bhc3NHbG9iZVxcblxcXG4gKiBAZ2xzbENvbnN0YW50XFxuXFxcbiAqXFxuXFxcbiAqIEBzZWUgY3ptX3Bhc3NcXG5cXFxuICovXFxuXFxcbmNvbnN0IGZsb2F0IGN6bV9wYXNzR2xvYmUgPSAyLjA7XFxuXFxcblwiO1xuIiwiLy9UaGlzIGZpbGUgaXMgYXV0b21hdGljYWxseSByZWJ1aWx0IGJ5IHRoZSBDZXNpdW0gYnVpbGQgcHJvY2Vzcy5cbmV4cG9ydCBkZWZhdWx0IFwiLyoqXFxuXFxcbiAqIFRoZSBhdXRvbWF0aWMgR0xTTCBjb25zdGFudCBmb3Ige0BsaW5rIFBhc3MjT1BBUVVFfVxcblxcXG4gKlxcblxcXG4gKiBAbmFtZSBjem1fcGFzc09wYXF1ZVxcblxcXG4gKiBAZ2xzbENvbnN0YW50XFxuXFxcbiAqXFxuXFxcbiAqIEBzZWUgY3ptX3Bhc3NcXG5cXFxuICovXFxuXFxcbmNvbnN0IGZsb2F0IGN6bV9wYXNzT3BhcXVlID0gNy4wO1xcblxcXG5cIjtcbiIsIi8vVGhpcyBmaWxlIGlzIGF1dG9tYXRpY2FsbHkgcmVidWlsdCBieSB0aGUgQ2VzaXVtIGJ1aWxkIHByb2Nlc3MuXG5leHBvcnQgZGVmYXVsdCBcIi8qKlxcblxcXG4gKiBUaGUgYXV0b21hdGljIEdMU0wgY29uc3RhbnQgZm9yIHtAbGluayBQYXNzI09WRVJMQVl9XFxuXFxcbiAqXFxuXFxcbiAqIEBuYW1lIGN6bV9wYXNzT3ZlcmxheVxcblxcXG4gKiBAZ2xzbENvbnN0YW50XFxuXFxcbiAqXFxuXFxcbiAqIEBzZWUgY3ptX3Bhc3NcXG5cXFxuICovXFxuXFxcbmNvbnN0IGZsb2F0IGN6bV9wYXNzT3ZlcmxheSA9IDkuMDtcXG5cXFxuXCI7XG4iLCIvL1RoaXMgZmlsZSBpcyBhdXRvbWF0aWNhbGx5IHJlYnVpbHQgYnkgdGhlIENlc2l1bSBidWlsZCBwcm9jZXNzLlxuZXhwb3J0IGRlZmF1bHQgXCIvKipcXG5cXFxuICogVGhlIGF1dG9tYXRpYyBHTFNMIGNvbnN0YW50IGZvciB7QGxpbmsgUGFzcyNURVJSQUlOX0NMQVNTSUZJQ0FUSU9OfVxcblxcXG4gKlxcblxcXG4gKiBAbmFtZSBjem1fcGFzc1RlcnJhaW5DbGFzc2lmaWNhdGlvblxcblxcXG4gKiBAZ2xzbENvbnN0YW50XFxuXFxcbiAqXFxuXFxcbiAqIEBzZWUgY3ptX3Bhc3NcXG5cXFxuICovXFxuXFxcbmNvbnN0IGZsb2F0IGN6bV9wYXNzVGVycmFpbkNsYXNzaWZpY2F0aW9uID0gMy4wO1xcblxcXG5cIjtcbiIsIi8vVGhpcyBmaWxlIGlzIGF1dG9tYXRpY2FsbHkgcmVidWlsdCBieSB0aGUgQ2VzaXVtIGJ1aWxkIHByb2Nlc3MuXG5leHBvcnQgZGVmYXVsdCBcIi8qKlxcblxcXG4gKiBUaGUgYXV0b21hdGljIEdMU0wgY29uc3RhbnQgZm9yIHtAbGluayBQYXNzI1RSQU5TTFVDRU5UfVxcblxcXG4gKlxcblxcXG4gKiBAbmFtZSBjem1fcGFzc1RyYW5zbHVjZW50XFxuXFxcbiAqIEBnbHNsQ29uc3RhbnRcXG5cXFxuICpcXG5cXFxuICogQHNlZSBjem1fcGFzc1xcblxcXG4gKi9cXG5cXFxuY29uc3QgZmxvYXQgY3ptX3Bhc3NUcmFuc2x1Y2VudCA9IDguMDtcXG5cXFxuXCI7XG4iLCIvL1RoaXMgZmlsZSBpcyBhdXRvbWF0aWNhbGx5IHJlYnVpbHQgYnkgdGhlIENlc2l1bSBidWlsZCBwcm9jZXNzLlxuZXhwb3J0IGRlZmF1bHQgXCIvKipcXG5cXFxuICogQSBidWlsdC1pbiBHTFNMIGZsb2F0aW5nLXBvaW50IGNvbnN0YW50IGZvciA8Y29kZT5NYXRoLlBJPC9jb2RlPi5cXG5cXFxuICpcXG5cXFxuICogQGFsaWFzIGN6bV9waVxcblxcXG4gKiBAZ2xzbENvbnN0YW50XFxuXFxcbiAqXFxuXFxcbiAqIEBzZWUgQ2VzaXVtTWF0aC5QSVxcblxcXG4gKlxcblxcXG4gKiBAZXhhbXBsZVxcblxcXG4gKiAvLyBHTFNMIGRlY2xhcmF0aW9uXFxuXFxcbiAqIGNvbnN0IGZsb2F0IGN6bV9waSA9IC4uLjtcXG5cXFxuICpcXG5cXFxuICogLy8gRXhhbXBsZVxcblxcXG4gKiBmbG9hdCB0d29QaSA9IDIuMCAqIGN6bV9waTtcXG5cXFxuICovXFxuXFxcbmNvbnN0IGZsb2F0IGN6bV9waSA9IDMuMTQxNTkyNjUzNTg5NzkzO1xcblxcXG5cIjtcbiIsIi8vVGhpcyBmaWxlIGlzIGF1dG9tYXRpY2FsbHkgcmVidWlsdCBieSB0aGUgQ2VzaXVtIGJ1aWxkIHByb2Nlc3MuXG5leHBvcnQgZGVmYXVsdCBcIi8qKlxcblxcXG4gKiBBIGJ1aWx0LWluIEdMU0wgZmxvYXRpbmctcG9pbnQgY29uc3RhbnQgZm9yIDxjb2RlPnBpLzQ8L2NvZGU+LlxcblxcXG4gKlxcblxcXG4gKiBAYWxpYXMgY3ptX3BpT3ZlckZvdXJcXG5cXFxuICogQGdsc2xDb25zdGFudFxcblxcXG4gKlxcblxcXG4gKiBAc2VlIENlc2l1bU1hdGguUElfT1ZFUl9GT1VSXFxuXFxcbiAqXFxuXFxcbiAqIEBleGFtcGxlXFxuXFxcbiAqIC8vIEdMU0wgZGVjbGFyYXRpb25cXG5cXFxuICogY29uc3QgZmxvYXQgY3ptX3BpT3ZlckZvdXIgPSAuLi47XFxuXFxcbiAqXFxuXFxcbiAqIC8vIEV4YW1wbGVcXG5cXFxuICogZmxvYXQgcGkgPSA0LjAgKiBjem1fcGlPdmVyRm91cjtcXG5cXFxuICovXFxuXFxcbmNvbnN0IGZsb2F0IGN6bV9waU92ZXJGb3VyID0gMC43ODUzOTgxNjMzOTc0NDgzO1xcblxcXG5cIjtcbiIsIi8vVGhpcyBmaWxlIGlzIGF1dG9tYXRpY2FsbHkgcmVidWlsdCBieSB0aGUgQ2VzaXVtIGJ1aWxkIHByb2Nlc3MuXG5leHBvcnQgZGVmYXVsdCBcIi8qKlxcblxcXG4gKiBBIGJ1aWx0LWluIEdMU0wgZmxvYXRpbmctcG9pbnQgY29uc3RhbnQgZm9yIDxjb2RlPnBpLzY8L2NvZGU+LlxcblxcXG4gKlxcblxcXG4gKiBAYWxpYXMgY3ptX3BpT3ZlclNpeFxcblxcXG4gKiBAZ2xzbENvbnN0YW50XFxuXFxcbiAqXFxuXFxcbiAqIEBzZWUgQ2VzaXVtTWF0aC5QSV9PVkVSX1NJWFxcblxcXG4gKlxcblxcXG4gKiBAZXhhbXBsZVxcblxcXG4gKiAvLyBHTFNMIGRlY2xhcmF0aW9uXFxuXFxcbiAqIGNvbnN0IGZsb2F0IGN6bV9waU92ZXJTaXggPSAuLi47XFxuXFxcbiAqXFxuXFxcbiAqIC8vIEV4YW1wbGVcXG5cXFxuICogZmxvYXQgcGkgPSA2LjAgKiBjem1fcGlPdmVyU2l4O1xcblxcXG4gKi9cXG5cXFxuY29uc3QgZmxvYXQgY3ptX3BpT3ZlclNpeCA9IDAuNTIzNTk4Nzc1NTk4Mjk4ODtcXG5cXFxuXCI7XG4iLCIvL1RoaXMgZmlsZSBpcyBhdXRvbWF0aWNhbGx5IHJlYnVpbHQgYnkgdGhlIENlc2l1bSBidWlsZCBwcm9jZXNzLlxuZXhwb3J0IGRlZmF1bHQgXCIvKipcXG5cXFxuICogQSBidWlsdC1pbiBHTFNMIGZsb2F0aW5nLXBvaW50IGNvbnN0YW50IGZvciA8Y29kZT5waS8zPC9jb2RlPi5cXG5cXFxuICpcXG5cXFxuICogQGFsaWFzIGN6bV9waU92ZXJUaHJlZVxcblxcXG4gKiBAZ2xzbENvbnN0YW50XFxuXFxcbiAqXFxuXFxcbiAqIEBzZWUgQ2VzaXVtTWF0aC5QSV9PVkVSX1RIUkVFXFxuXFxcbiAqXFxuXFxcbiAqIEBleGFtcGxlXFxuXFxcbiAqIC8vIEdMU0wgZGVjbGFyYXRpb25cXG5cXFxuICogY29uc3QgZmxvYXQgY3ptX3BpT3ZlclRocmVlID0gLi4uO1xcblxcXG4gKlxcblxcXG4gKiAvLyBFeGFtcGxlXFxuXFxcbiAqIGZsb2F0IHBpID0gMy4wICogY3ptX3BpT3ZlclRocmVlO1xcblxcXG4gKi9cXG5cXFxuY29uc3QgZmxvYXQgY3ptX3BpT3ZlclRocmVlID0gMS4wNDcxOTc1NTExOTY1OTc2O1xcblxcXG5cIjtcbiIsIi8vVGhpcyBmaWxlIGlzIGF1dG9tYXRpY2FsbHkgcmVidWlsdCBieSB0aGUgQ2VzaXVtIGJ1aWxkIHByb2Nlc3MuXG5leHBvcnQgZGVmYXVsdCBcIi8qKlxcblxcXG4gKiBBIGJ1aWx0LWluIEdMU0wgZmxvYXRpbmctcG9pbnQgY29uc3RhbnQgZm9yIDxjb2RlPnBpLzI8L2NvZGU+LlxcblxcXG4gKlxcblxcXG4gKiBAYWxpYXMgY3ptX3BpT3ZlclR3b1xcblxcXG4gKiBAZ2xzbENvbnN0YW50XFxuXFxcbiAqXFxuXFxcbiAqIEBzZWUgQ2VzaXVtTWF0aC5QSV9PVkVSX1RXT1xcblxcXG4gKlxcblxcXG4gKiBAZXhhbXBsZVxcblxcXG4gKiAvLyBHTFNMIGRlY2xhcmF0aW9uXFxuXFxcbiAqIGNvbnN0IGZsb2F0IGN6bV9waU92ZXJUd28gPSAuLi47XFxuXFxcbiAqXFxuXFxcbiAqIC8vIEV4YW1wbGVcXG5cXFxuICogZmxvYXQgcGkgPSAyLjAgKiBjem1fcGlPdmVyVHdvO1xcblxcXG4gKi9cXG5cXFxuY29uc3QgZmxvYXQgY3ptX3BpT3ZlclR3byA9IDEuNTcwNzk2MzI2Nzk0ODk2NjtcXG5cXFxuXCI7XG4iLCIvL1RoaXMgZmlsZSBpcyBhdXRvbWF0aWNhbGx5IHJlYnVpbHQgYnkgdGhlIENlc2l1bSBidWlsZCBwcm9jZXNzLlxuZXhwb3J0IGRlZmF1bHQgXCIvKipcXG5cXFxuICogQSBidWlsdC1pbiBHTFNMIGZsb2F0aW5nLXBvaW50IGNvbnN0YW50IGZvciBjb252ZXJ0aW5nIGRlZ3JlZXMgdG8gcmFkaWFucy5cXG5cXFxuICpcXG5cXFxuICogQGFsaWFzIGN6bV9yYWRpYW5zUGVyRGVncmVlXFxuXFxcbiAqIEBnbHNsQ29uc3RhbnRcXG5cXFxuICpcXG5cXFxuICogQHNlZSBDZXNpdW1NYXRoLlJBRElBTlNfUEVSX0RFR1JFRVxcblxcXG4gKlxcblxcXG4gKiBAZXhhbXBsZVxcblxcXG4gKiAvLyBHTFNMIGRlY2xhcmF0aW9uXFxuXFxcbiAqIGNvbnN0IGZsb2F0IGN6bV9yYWRpYW5zUGVyRGVncmVlID0gLi4uO1xcblxcXG4gKlxcblxcXG4gKiAvLyBFeGFtcGxlXFxuXFxcbiAqIGZsb2F0IHJhZCA9IGN6bV9yYWRpYW5zUGVyRGVncmVlICogZGVnO1xcblxcXG4gKi9cXG5cXFxuY29uc3QgZmxvYXQgY3ptX3JhZGlhbnNQZXJEZWdyZWUgPSAwLjAxNzQ1MzI5MjUxOTk0MzI5NTtcXG5cXFxuXCI7XG4iLCIvL1RoaXMgZmlsZSBpcyBhdXRvbWF0aWNhbGx5IHJlYnVpbHQgYnkgdGhlIENlc2l1bSBidWlsZCBwcm9jZXNzLlxuZXhwb3J0IGRlZmF1bHQgXCIvKipcXG5cXFxuICogVGhlIGNvbnN0YW50IGlkZW50aWZpZXIgZm9yIHRoZSAyRCB7QGxpbmsgU2NlbmVNb2RlfVxcblxcXG4gKlxcblxcXG4gKiBAbmFtZSBjem1fc2NlbmVNb2RlMkRcXG5cXFxuICogQGdsc2xDb25zdGFudFxcblxcXG4gKiBAc2VlIGN6bV9zY2VuZU1vZGVcXG5cXFxuICogQHNlZSBjem1fc2NlbmVNb2RlQ29sdW1idXNWaWV3XFxuXFxcbiAqIEBzZWUgY3ptX3NjZW5lTW9kZTNEXFxuXFxcbiAqIEBzZWUgY3ptX3NjZW5lTW9kZU1vcnBoaW5nXFxuXFxcbiAqL1xcblxcXG5jb25zdCBmbG9hdCBjem1fc2NlbmVNb2RlMkQgPSAyLjA7XFxuXFxcblwiO1xuIiwiLy9UaGlzIGZpbGUgaXMgYXV0b21hdGljYWxseSByZWJ1aWx0IGJ5IHRoZSBDZXNpdW0gYnVpbGQgcHJvY2Vzcy5cbmV4cG9ydCBkZWZhdWx0IFwiLyoqXFxuXFxcbiAqIFRoZSBjb25zdGFudCBpZGVudGlmaWVyIGZvciB0aGUgM0Qge0BsaW5rIFNjZW5lTW9kZX1cXG5cXFxuICpcXG5cXFxuICogQG5hbWUgY3ptX3NjZW5lTW9kZTNEXFxuXFxcbiAqIEBnbHNsQ29uc3RhbnRcXG5cXFxuICogQHNlZSBjem1fc2NlbmVNb2RlXFxuXFxcbiAqIEBzZWUgY3ptX3NjZW5lTW9kZTJEXFxuXFxcbiAqIEBzZWUgY3ptX3NjZW5lTW9kZUNvbHVtYnVzVmlld1xcblxcXG4gKiBAc2VlIGN6bV9zY2VuZU1vZGVNb3JwaGluZ1xcblxcXG4gKi9cXG5cXFxuY29uc3QgZmxvYXQgY3ptX3NjZW5lTW9kZTNEID0gMy4wO1xcblxcXG5cIjtcbiIsIi8vVGhpcyBmaWxlIGlzIGF1dG9tYXRpY2FsbHkgcmVidWlsdCBieSB0aGUgQ2VzaXVtIGJ1aWxkIHByb2Nlc3MuXG5leHBvcnQgZGVmYXVsdCBcIi8qKlxcblxcXG4gKiBUaGUgY29uc3RhbnQgaWRlbnRpZmllciBmb3IgdGhlIENvbHVtYnVzIFZpZXcge0BsaW5rIFNjZW5lTW9kZX1cXG5cXFxuICpcXG5cXFxuICogQG5hbWUgY3ptX3NjZW5lTW9kZUNvbHVtYnVzVmlld1xcblxcXG4gKiBAZ2xzbENvbnN0YW50XFxuXFxcbiAqIEBzZWUgY3ptX3NjZW5lTW9kZVxcblxcXG4gKiBAc2VlIGN6bV9zY2VuZU1vZGUyRFxcblxcXG4gKiBAc2VlIGN6bV9zY2VuZU1vZGUzRFxcblxcXG4gKiBAc2VlIGN6bV9zY2VuZU1vZGVNb3JwaGluZ1xcblxcXG4gKi9cXG5cXFxuY29uc3QgZmxvYXQgY3ptX3NjZW5lTW9kZUNvbHVtYnVzVmlldyA9IDEuMDtcXG5cXFxuXCI7XG4iLCIvL1RoaXMgZmlsZSBpcyBhdXRvbWF0aWNhbGx5IHJlYnVpbHQgYnkgdGhlIENlc2l1bSBidWlsZCBwcm9jZXNzLlxuZXhwb3J0IGRlZmF1bHQgXCIvKipcXG5cXFxuICogVGhlIGNvbnN0YW50IGlkZW50aWZpZXIgZm9yIHRoZSBNb3JwaGluZyB7QGxpbmsgU2NlbmVNb2RlfVxcblxcXG4gKlxcblxcXG4gKiBAbmFtZSBjem1fc2NlbmVNb2RlTW9ycGhpbmdcXG5cXFxuICogQGdsc2xDb25zdGFudFxcblxcXG4gKiBAc2VlIGN6bV9zY2VuZU1vZGVcXG5cXFxuICogQHNlZSBjem1fc2NlbmVNb2RlMkRcXG5cXFxuICogQHNlZSBjem1fc2NlbmVNb2RlQ29sdW1idXNWaWV3XFxuXFxcbiAqIEBzZWUgY3ptX3NjZW5lTW9kZTNEXFxuXFxcbiAqL1xcblxcXG5jb25zdCBmbG9hdCBjem1fc2NlbmVNb2RlTW9ycGhpbmcgPSAwLjA7XFxuXFxcblwiO1xuIiwiLy9UaGlzIGZpbGUgaXMgYXV0b21hdGljYWxseSByZWJ1aWx0IGJ5IHRoZSBDZXNpdW0gYnVpbGQgcHJvY2Vzcy5cbmV4cG9ydCBkZWZhdWx0IFwiLyoqXFxuXFxcbiAqIEEgYnVpbHQtaW4gR0xTTCBmbG9hdGluZy1wb2ludCBjb25zdGFudCBmb3Igb25lIHNvbGFyIHJhZGl1cy5cXG5cXFxuICpcXG5cXFxuICogQGFsaWFzIGN6bV9zb2xhclJhZGl1c1xcblxcXG4gKiBAZ2xzbENvbnN0YW50XFxuXFxcbiAqXFxuXFxcbiAqIEBzZWUgQ2VzaXVtTWF0aC5TT0xBUl9SQURJVVNcXG5cXFxuICpcXG5cXFxuICogQGV4YW1wbGVcXG5cXFxuICogLy8gR0xTTCBkZWNsYXJhdGlvblxcblxcXG4gKiBjb25zdCBmbG9hdCBjem1fc29sYXJSYWRpdXMgPSAuLi47XFxuXFxcbiAqL1xcblxcXG5jb25zdCBmbG9hdCBjem1fc29sYXJSYWRpdXMgPSA2OTU1MDAwMDAuMDtcXG5cXFxuXCI7XG4iLCIvL1RoaXMgZmlsZSBpcyBhdXRvbWF0aWNhbGx5IHJlYnVpbHQgYnkgdGhlIENlc2l1bSBidWlsZCBwcm9jZXNzLlxuZXhwb3J0IGRlZmF1bHQgXCIvKipcXG5cXFxuICogQSBidWlsdC1pbiBHTFNMIGZsb2F0aW5nLXBvaW50IGNvbnN0YW50IGZvciA8Y29kZT4zcGkvMjwvY29kZT4uXFxuXFxcbiAqXFxuXFxcbiAqIEBhbGlhcyBjem1fdGhyZWVQaU92ZXIyXFxuXFxcbiAqIEBnbHNsQ29uc3RhbnRcXG5cXFxuICpcXG5cXFxuICogQHNlZSBDZXNpdW1NYXRoLlRIUkVFX1BJX09WRVJfVFdPXFxuXFxcbiAqXFxuXFxcbiAqIEBleGFtcGxlXFxuXFxcbiAqIC8vIEdMU0wgZGVjbGFyYXRpb25cXG5cXFxuICogY29uc3QgZmxvYXQgY3ptX3RocmVlUGlPdmVyMiA9IC4uLjtcXG5cXFxuICpcXG5cXFxuICogLy8gRXhhbXBsZVxcblxcXG4gKiBmbG9hdCBwaSA9ICgyLjAgLyAzLjApICogY3ptX3RocmVlUGlPdmVyMjtcXG5cXFxuICovXFxuXFxcbmNvbnN0IGZsb2F0IGN6bV90aHJlZVBpT3ZlcjIgPSA0LjcxMjM4ODk4MDM4NDY5O1xcblxcXG5cIjtcbiIsIi8vVGhpcyBmaWxlIGlzIGF1dG9tYXRpY2FsbHkgcmVidWlsdCBieSB0aGUgQ2VzaXVtIGJ1aWxkIHByb2Nlc3MuXG5leHBvcnQgZGVmYXVsdCBcIi8qKlxcblxcXG4gKiBBIGJ1aWx0LWluIEdMU0wgZmxvYXRpbmctcG9pbnQgY29uc3RhbnQgZm9yIDxjb2RlPjJwaTwvY29kZT4uXFxuXFxcbiAqXFxuXFxcbiAqIEBhbGlhcyBjem1fdHdvUGlcXG5cXFxuICogQGdsc2xDb25zdGFudFxcblxcXG4gKlxcblxcXG4gKiBAc2VlIENlc2l1bU1hdGguVFdPX1BJXFxuXFxcbiAqXFxuXFxcbiAqIEBleGFtcGxlXFxuXFxcbiAqIC8vIEdMU0wgZGVjbGFyYXRpb25cXG5cXFxuICogY29uc3QgZmxvYXQgY3ptX3R3b1BpID0gLi4uO1xcblxcXG4gKlxcblxcXG4gKiAvLyBFeGFtcGxlXFxuXFxcbiAqIGZsb2F0IHBpID0gY3ptX3R3b1BpIC8gMi4wO1xcblxcXG4gKi9cXG5cXFxuY29uc3QgZmxvYXQgY3ptX3R3b1BpID0gNi4yODMxODUzMDcxNzk1ODY7XFxuXFxcblwiO1xuIiwiLy9UaGlzIGZpbGUgaXMgYXV0b21hdGljYWxseSByZWJ1aWx0IGJ5IHRoZSBDZXNpdW0gYnVpbGQgcHJvY2Vzcy5cbmV4cG9ydCBkZWZhdWx0IFwiLyoqXFxuXFxcbiAqIFRoZSBtYXhpbXVtIGxhdGl0dWRlLCBpbiByYWRpYW5zLCBib3RoIE5vcnRoIGFuZCBTb3V0aCwgc3VwcG9ydGVkIGJ5IGEgV2ViIE1lcmNhdG9yXFxuXFxcbiAqIChFUFNHOjM4NTcpIHByb2plY3Rpb24uICBUZWNobmljYWxseSwgdGhlIE1lcmNhdG9yIHByb2plY3Rpb24gaXMgZGVmaW5lZFxcblxcXG4gKiBmb3IgYW55IGxhdGl0dWRlIHVwIHRvIChidXQgbm90IGluY2x1ZGluZykgOTAgZGVncmVlcywgYnV0IGl0IG1ha2VzIHNlbnNlXFxuXFxcbiAqIHRvIGN1dCBpdCBvZmYgc29vbmVyIGJlY2F1c2UgaXQgZ3Jvd3MgZXhwb25lbnRpYWxseSB3aXRoIGluY3JlYXNpbmcgbGF0aXR1ZGUuXFxuXFxcbiAqIFRoZSBsb2dpYyBiZWhpbmQgdGhpcyBwYXJ0aWN1bGFyIGN1dG9mZiB2YWx1ZSwgd2hpY2ggaXMgdGhlIG9uZSB1c2VkIGJ5XFxuXFxcbiAqIEdvb2dsZSBNYXBzLCBCaW5nIE1hcHMsIGFuZCBFc3JpLCBpcyB0aGF0IGl0IG1ha2VzIHRoZSBwcm9qZWN0aW9uXFxuXFxcbiAqIHNxdWFyZS4gIFRoYXQgaXMsIHRoZSByZWN0YW5nbGUgaXMgZXF1YWwgaW4gdGhlIFggYW5kIFkgZGlyZWN0aW9ucy5cXG5cXFxuICpcXG5cXFxuICogVGhlIGNvbnN0YW50IHZhbHVlIGlzIGNvbXB1dGVkIGFzIGZvbGxvd3M6XFxuXFxcbiAqICAgY3ptX3BpICogMC41IC0gKDIuMCAqIGF0YW4oZXhwKC1jem1fcGkpKSlcXG5cXFxuICpcXG5cXFxuICogQG5hbWUgY3ptX3dlYk1lcmNhdG9yTWF4TGF0aXR1ZGVcXG5cXFxuICogQGdsc2xDb25zdGFudFxcblxcXG4gKi9cXG5cXFxuY29uc3QgZmxvYXQgY3ptX3dlYk1lcmNhdG9yTWF4TGF0aXR1ZGUgPSAxLjQ4NDQyMjIyOTc0NTMzMjQ7XFxuXFxcblwiO1xuIiwiLy9UaGlzIGZpbGUgaXMgYXV0b21hdGljYWxseSByZWJ1aWx0IGJ5IHRoZSBDZXNpdW0gYnVpbGQgcHJvY2Vzcy5cbmV4cG9ydCBkZWZhdWx0IFwiLyoqXFxuXFxcbiAqIEBuYW1lIGN6bV9kZXB0aFJhbmdlU3RydWN0XFxuXFxcbiAqIEBnbHNsU3RydWN0XFxuXFxcbiAqL1xcblxcXG5zdHJ1Y3QgY3ptX2RlcHRoUmFuZ2VTdHJ1Y3RcXG5cXFxue1xcblxcXG4gICAgZmxvYXQgbmVhcjtcXG5cXFxuICAgIGZsb2F0IGZhcjtcXG5cXFxufTtcXG5cXFxuXCI7XG4iLCIvL1RoaXMgZmlsZSBpcyBhdXRvbWF0aWNhbGx5IHJlYnVpbHQgYnkgdGhlIENlc2l1bSBidWlsZCBwcm9jZXNzLlxuZXhwb3J0IGRlZmF1bHQgXCIvKipcXG5cXFxuICogSG9sZHMgbWF0ZXJpYWwgaW5mb3JtYXRpb24gdGhhdCBjYW4gYmUgdXNlZCBmb3IgbGlnaHRpbmcuIFJldHVybmVkIGJ5IGFsbCBjem1fZ2V0TWF0ZXJpYWwgZnVuY3Rpb25zLlxcblxcXG4gKlxcblxcXG4gKiBAbmFtZSBjem1fbWF0ZXJpYWxcXG5cXFxuICogQGdsc2xTdHJ1Y3RcXG5cXFxuICpcXG5cXFxuICogQHByb3BlcnR5IHt2ZWMzfSBkaWZmdXNlIEluY29taW5nIGxpZ2h0IHRoYXQgc2NhdHRlcnMgZXZlbmx5IGluIGFsbCBkaXJlY3Rpb25zLlxcblxcXG4gKiBAcHJvcGVydHkge2Zsb2F0fSBzcGVjdWxhciBJbnRlbnNpdHkgb2YgaW5jb21pbmcgbGlnaHQgcmVmbGVjdGluZyBpbiBhIHNpbmdsZSBkaXJlY3Rpb24uXFxuXFxcbiAqIEBwcm9wZXJ0eSB7ZmxvYXR9IHNoaW5pbmVzcyBUaGUgc2hhcnBuZXNzIG9mIHRoZSBzcGVjdWxhciByZWZsZWN0aW9uLiAgSGlnaGVyIHZhbHVlcyBjcmVhdGUgYSBzbWFsbGVyLCBtb3JlIGZvY3VzZWQgc3BlY3VsYXIgaGlnaGxpZ2h0LlxcblxcXG4gKiBAcHJvcGVydHkge3ZlYzN9IG5vcm1hbCBTdXJmYWNlJ3Mgbm9ybWFsIGluIGV5ZSBjb29yZGluYXRlcy4gSXQgaXMgdXNlZCBmb3IgZWZmZWN0cyBzdWNoIGFzIG5vcm1hbCBtYXBwaW5nLiBUaGUgZGVmYXVsdCBpcyB0aGUgc3VyZmFjZSdzIHVubW9kaWZpZWQgbm9ybWFsLlxcblxcXG4gKiBAcHJvcGVydHkge3ZlYzN9IGVtaXNzaW9uIExpZ2h0IGVtaXR0ZWQgYnkgdGhlIG1hdGVyaWFsIGVxdWFsbHkgaW4gYWxsIGRpcmVjdGlvbnMuIFRoZSBkZWZhdWx0IGlzIHZlYzMoMC4wKSwgd2hpY2ggZW1pdHMgbm8gbGlnaHQuXFxuXFxcbiAqIEBwcm9wZXJ0eSB7ZmxvYXR9IGFscGhhIEFscGhhIG9mIHRoaXMgbWF0ZXJpYWwuIDAuMCBpcyBjb21wbGV0ZWx5IHRyYW5zcGFyZW50OyAxLjAgaXMgY29tcGxldGVseSBvcGFxdWUuXFxuXFxcbiAqL1xcblxcXG5zdHJ1Y3QgY3ptX21hdGVyaWFsXFxuXFxcbntcXG5cXFxuICAgIHZlYzMgZGlmZnVzZTtcXG5cXFxuICAgIGZsb2F0IHNwZWN1bGFyO1xcblxcXG4gICAgZmxvYXQgc2hpbmluZXNzO1xcblxcXG4gICAgdmVjMyBub3JtYWw7XFxuXFxcbiAgICB2ZWMzIGVtaXNzaW9uO1xcblxcXG4gICAgZmxvYXQgYWxwaGE7XFxuXFxcbn07XFxuXFxcblwiO1xuIiwiLy9UaGlzIGZpbGUgaXMgYXV0b21hdGljYWxseSByZWJ1aWx0IGJ5IHRoZSBDZXNpdW0gYnVpbGQgcHJvY2Vzcy5cbmV4cG9ydCBkZWZhdWx0IFwiLyoqXFxuXFxcbiAqIFVzZWQgYXMgaW5wdXQgdG8gZXZlcnkgbWF0ZXJpYWwncyBjem1fZ2V0TWF0ZXJpYWwgZnVuY3Rpb24uXFxuXFxcbiAqXFxuXFxcbiAqIEBuYW1lIGN6bV9tYXRlcmlhbElucHV0XFxuXFxcbiAqIEBnbHNsU3RydWN0XFxuXFxcbiAqXFxuXFxcbiAqIEBwcm9wZXJ0eSB7ZmxvYXR9IHMgMUQgdGV4dHVyZSBjb29yZGluYXRlcy5cXG5cXFxuICogQHByb3BlcnR5IHt2ZWMyfSBzdCAyRCB0ZXh0dXJlIGNvb3JkaW5hdGVzLlxcblxcXG4gKiBAcHJvcGVydHkge3ZlYzN9IHN0ciAzRCB0ZXh0dXJlIGNvb3JkaW5hdGVzLlxcblxcXG4gKiBAcHJvcGVydHkge3ZlYzN9IG5vcm1hbEVDIFVucGVydHVyYmVkIHN1cmZhY2Ugbm9ybWFsIGluIGV5ZSBjb29yZGluYXRlcy5cXG5cXFxuICogQHByb3BlcnR5IHttYXQzfSB0YW5nZW50VG9FeWVNYXRyaXggTWF0cml4IGZvciBjb252ZXJ0aW5nIGEgdGFuZ2VudCBzcGFjZSBub3JtYWwgdG8gZXllIHNwYWNlLlxcblxcXG4gKiBAcHJvcGVydHkge3ZlYzN9IHBvc2l0aW9uVG9FeWVFQyBWZWN0b3IgZnJvbSB0aGUgZnJhZ21lbnQgdG8gdGhlIGV5ZSBpbiBleWUgY29vcmRpbmF0ZXMuICBUaGUgbWFnbml0dWRlIGlzIHRoZSBkaXN0YW5jZSBpbiBtZXRlcnMgZnJvbSB0aGUgZnJhZ21lbnQgdG8gdGhlIGV5ZS5cXG5cXFxuICogQHByb3BlcnR5IHtmbG9hdH0gaGVpZ2h0IFRoZSBoZWlnaHQgb2YgdGhlIHRlcnJhaW4gaW4gbWV0ZXJzIGFib3ZlIG9yIGJlbG93IHRoZSBXR1M4NCBlbGxpcHNvaWQuICBPbmx5IGF2YWlsYWJsZSBmb3IgZ2xvYmUgbWF0ZXJpYWxzLlxcblxcXG4gKiBAcHJvcGVydHkge2Zsb2F0fSBzbG9wZSBUaGUgc2xvcGUgb2YgdGhlIHRlcnJhaW4gaW4gcmFkaWFucy4gIDAgaXMgZmxhdDsgcGkvMiBpcyB2ZXJ0aWNhbC4gIE9ubHkgYXZhaWxhYmxlIGZvciBnbG9iZSBtYXRlcmlhbHMuXFxuXFxcbiAqIEBwcm9wZXJ0eSB7ZmxvYXR9IGFzcGVjdCBUaGUgYXNwZWN0IG9mIHRoZSB0ZXJyYWluIGluIHJhZGlhbnMuICAwIGlzIEVhc3QsIHBpLzIgaXMgTm9ydGgsIHBpIGlzIFdlc3QsIDNwaS8yIGlzIFNvdXRoLiAgT25seSBhdmFpbGFibGUgZm9yIGdsb2JlIG1hdGVyaWFscy5cXG5cXFxuICovXFxuXFxcbnN0cnVjdCBjem1fbWF0ZXJpYWxJbnB1dFxcblxcXG57XFxuXFxcbiAgICBmbG9hdCBzO1xcblxcXG4gICAgdmVjMiBzdDtcXG5cXFxuICAgIHZlYzMgc3RyO1xcblxcXG4gICAgdmVjMyBub3JtYWxFQztcXG5cXFxuICAgIG1hdDMgdGFuZ2VudFRvRXllTWF0cml4O1xcblxcXG4gICAgdmVjMyBwb3NpdGlvblRvRXllRUM7XFxuXFxcbiAgICBmbG9hdCBoZWlnaHQ7XFxuXFxcbiAgICBmbG9hdCBzbG9wZTtcXG5cXFxuICAgIGZsb2F0IGFzcGVjdDtcXG5cXFxufTtcXG5cXFxuXCI7XG4iLCIvL1RoaXMgZmlsZSBpcyBhdXRvbWF0aWNhbGx5IHJlYnVpbHQgYnkgdGhlIENlc2l1bSBidWlsZCBwcm9jZXNzLlxuZXhwb3J0IGRlZmF1bHQgXCIvKipcXG5cXFxuICogU3RydWN0IGZvciByZXByZXNlbnRpbmcgYSBtYXRlcmlhbCBmb3IgYSB7QGxpbmsgTW9kZWxFeHBlcmltZW50YWx9LiBUaGUgbW9kZWxcXG5cXFxuICogcmVuZGVyaW5nIHBpcGVsaW5lIHdpbGwgcGFzcyB0aGlzIHN0cnVjdCBiZXR3ZWVuIG1hdGVyaWFsLCBjdXN0b20gc2hhZGVycyxcXG5cXFxuICogYW5kIGxpZ2h0aW5nIHN0YWdlcy4gVGhpcyBpcyBub3QgdG8gYmUgY29uZnVzZWQgd2l0aCB7QGxpbmsgY3ptX21hdGVyaWFsfVxcblxcXG4gKiB3aGljaCBpcyB1c2VkIGJ5IHRoZSBvbGRlciBGYWJyaWMgbWF0ZXJpYWxzIHN5c3RlbSwgYWx0aG91Z2ggdGhleSBhcmUgc2ltaWxhclxcblxcXG4gKlxcblxcXG4gKiBAbmFtZSBjem1fbW9kZWxNYXRlcmlhbFxcblxcXG4gKiBAZ2xzbFN0cnVjdFxcblxcXG4gKlxcblxcXG4gKiBAcHJvcGVydHkge3ZlYzN9IGRpZmZ1c2UgSW5jb21pbmcgbGlnaHQgdGhhdCBzY2F0dGVycyBldmVubHkgaW4gYWxsIGRpcmVjdGlvbnMuXFxuXFxcbiAqIEBwcm9wZXJ0eSB7ZmxvYXR9IGFscGhhIEFscGhhIG9mIHRoaXMgbWF0ZXJpYWwuIDAuMCBpcyBjb21wbGV0ZWx5IHRyYW5zcGFyZW50OyAxLjAgaXMgY29tcGxldGVseSBvcGFxdWUuXFxuXFxcbiAqIEBwcm9wZXJ0eSB7dmVjM30gc3BlY3VsYXIgQ29sb3Igb2YgcmVmbGVjdGVkIGxpZ2h0IGF0IG5vcm1hbCBpbmNpZGVuY2UgaW4gUEJSIG1hdGVyaWFscy4gVGhpcyBpcyBzb21ldGltZXMgcmVmZXJyZWQgdG8gYXMgZjAgaW4gdGhlIGxpdGVyYXR1cmUuXFxuXFxcbiAqIEBwcm9wZXJ0eSB7ZmxvYXR9IHJvdWdobmVzcyBBIG51bWJlciBmcm9tIDAuMCB0byAxLjAgcmVwcmVzZW50aW5nIGhvdyByb3VnaCB0aGUgc3VyZmFjZSBpcy4gVmFsdWVzIG5lYXIgMC4wIHByb2R1Y2UgZ2xvc3N5IHN1cmZhY2VzLCB3aGlsZSB2YWx1ZXMgbmVhciAxLjAgcHJvZHVjZSByb3VnaCBzdXJmYWNlcy5cXG5cXFxuICogQHByb3BlcnR5IHt2ZWMzfSBub3JtYWwgU3VyZmFjZSdzIG5vcm1hbCBpbiBleWUgY29vcmRpbmF0ZXMuIEl0IGlzIHVzZWQgZm9yIGVmZmVjdHMgc3VjaCBhcyBub3JtYWwgbWFwcGluZy4gVGhlIGRlZmF1bHQgaXMgdGhlIHN1cmZhY2UncyB1bm1vZGlmaWVkIG5vcm1hbC5cXG5cXFxuICogQHByb3BlcnR5IHtmbG9hdH0gb2NjbHVzaW9uIEFtYmllbnQgb2NjbHVzaW9uIHJlY2lldmVkIGF0IHRoaXMgcG9pbnQgb24gdGhlIG1hdGVyaWFsLiAxLjAgbWVhbnMgZnVsbHkgbGl0LCAwLjAgbWVhbnMgZnVsbHkgb2NjbHVkZWQuXFxuXFxcbiAqIEBwcm9wZXJ0eSB7dmVjM30gZW1pc3NpdmUgTGlnaHQgZW1pdHRlZCBieSB0aGUgbWF0ZXJpYWwgZXF1YWxseSBpbiBhbGwgZGlyZWN0aW9ucy4gVGhlIGRlZmF1bHQgaXMgdmVjMygwLjApLCB3aGljaCBlbWl0cyBubyBsaWdodC5cXG5cXFxuICovXFxuXFxcbnN0cnVjdCBjem1fbW9kZWxNYXRlcmlhbCB7XFxuXFxcbiAgICB2ZWMzIGRpZmZ1c2U7XFxuXFxcbiAgICBmbG9hdCBhbHBoYTtcXG5cXFxuICAgIHZlYzMgc3BlY3VsYXI7XFxuXFxcbiAgICBmbG9hdCByb3VnaG5lc3M7XFxuXFxcbiAgICB2ZWMzIG5vcm1hbDtcXG5cXFxuICAgIGZsb2F0IG9jY2x1c2lvbjtcXG5cXFxuICAgIHZlYzMgZW1pc3NpdmU7XFxuXFxcbn07XFxuXFxcblwiO1xuIiwiLy9UaGlzIGZpbGUgaXMgYXV0b21hdGljYWxseSByZWJ1aWx0IGJ5IHRoZSBDZXNpdW0gYnVpbGQgcHJvY2Vzcy5cbmV4cG9ydCBkZWZhdWx0IFwiLyoqXFxuXFxcbiAqIFBhcmFtZXRlcnMgZm9yIHtAbGluayBjem1fcGJyTGlnaHRpbmd9XFxuXFxcbiAqXFxuXFxcbiAqIEBuYW1lIGN6bV9tYXRlcmlhbFxcblxcXG4gKiBAZ2xzbFN0cnVjdFxcblxcXG4gKlxcblxcXG4gKiBAcHJvcGVydHkge3ZlYzN9IGRpZmZ1c2VDb2xvciB0aGUgZGlmZnVzZSBjb2xvciBvZiB0aGUgbWF0ZXJpYWwgZm9yIHRoZSBsYW1iZXJ0IHRlcm0gb2YgdGhlIHJlbmRlcmluZyBlcXVhdGlvblxcblxcXG4gKiBAcHJvcGVydHkge2Zsb2F0fSByb3VnaG5lc3MgYSB2YWx1ZSBmcm9tIDAuMCB0byAxLjAgdGhhdCBpbmRpY2F0ZXMgaG93IHJvdWdoIHRoZSBzdXJmYWNlIG9mIHRoZSBtYXRlcmlhbCBpcy5cXG5cXFxuICogQHByb3BlcnR5IHt2ZWMzfSBmMCBUaGUgcmVmbGVjdGFuY2Ugb2YgdGhlIG1hdGVyaWFsIGF0IG5vcm1hbCBpbmNpZGVuY2VcXG5cXFxuICovXFxuXFxcbnN0cnVjdCBjem1fcGJyUGFyYW1ldGVyc1xcblxcXG57XFxuXFxcbiAgICB2ZWMzIGRpZmZ1c2VDb2xvcjtcXG5cXFxuICAgIGZsb2F0IHJvdWdobmVzcztcXG5cXFxuICAgIHZlYzMgZjA7XFxuXFxcbn07XFxuXFxcblwiO1xuIiwiLy9UaGlzIGZpbGUgaXMgYXV0b21hdGljYWxseSByZWJ1aWx0IGJ5IHRoZSBDZXNpdW0gYnVpbGQgcHJvY2Vzcy5cbmV4cG9ydCBkZWZhdWx0IFwiLyoqXFxuXFxcbiAqIERPQ19UQkFcXG5cXFxuICpcXG5cXFxuICogQG5hbWUgY3ptX3JheVxcblxcXG4gKiBAZ2xzbFN0cnVjdFxcblxcXG4gKi9cXG5cXFxuc3RydWN0IGN6bV9yYXlcXG5cXFxue1xcblxcXG4gICAgdmVjMyBvcmlnaW47XFxuXFxcbiAgICB2ZWMzIGRpcmVjdGlvbjtcXG5cXFxufTtcXG5cXFxuXCI7XG4iLCIvL1RoaXMgZmlsZSBpcyBhdXRvbWF0aWNhbGx5IHJlYnVpbHQgYnkgdGhlIENlc2l1bSBidWlsZCBwcm9jZXNzLlxuZXhwb3J0IGRlZmF1bHQgXCIvKipcXG5cXFxuICogRE9DX1RCQVxcblxcXG4gKlxcblxcXG4gKiBAbmFtZSBjem1fcmF5U2VnbWVudFxcblxcXG4gKiBAZ2xzbFN0cnVjdFxcblxcXG4gKi9cXG5cXFxuc3RydWN0IGN6bV9yYXlTZWdtZW50XFxuXFxcbntcXG5cXFxuICAgIGZsb2F0IHN0YXJ0O1xcblxcXG4gICAgZmxvYXQgc3RvcDtcXG5cXFxufTtcXG5cXFxuXFxuXFxcbi8qKlxcblxcXG4gKiBET0NfVEJBXFxuXFxcbiAqXFxuXFxcbiAqIEBuYW1lIGN6bV9lbXB0eVJheVNlZ21lbnRcXG5cXFxuICogQGdsc2xDb25zdGFudCBcXG5cXFxuICovXFxuXFxcbmNvbnN0IGN6bV9yYXlTZWdtZW50IGN6bV9lbXB0eVJheVNlZ21lbnQgPSBjem1fcmF5U2VnbWVudCgtY3ptX2luZmluaXR5LCAtY3ptX2luZmluaXR5KTtcXG5cXFxuXFxuXFxcbi8qKlxcblxcXG4gKiBET0NfVEJBXFxuXFxcbiAqXFxuXFxcbiAqIEBuYW1lIGN6bV9mdWxsUmF5U2VnbWVudFxcblxcXG4gKiBAZ2xzbENvbnN0YW50IFxcblxcXG4gKi9cXG5cXFxuY29uc3QgY3ptX3JheVNlZ21lbnQgY3ptX2Z1bGxSYXlTZWdtZW50ID0gY3ptX3JheVNlZ21lbnQoMC4wLCBjem1faW5maW5pdHkpO1xcblxcXG5cIjtcbiIsIi8vVGhpcyBmaWxlIGlzIGF1dG9tYXRpY2FsbHkgcmVidWlsdCBieSB0aGUgQ2VzaXVtIGJ1aWxkIHByb2Nlc3MuXG5leHBvcnQgZGVmYXVsdCBcInN0cnVjdCBjem1fc2hhZG93UGFyYW1ldGVyc1xcblxcXG57XFxuXFxcbiNpZmRlZiBVU0VfQ1VCRV9NQVBfU0hBRE9XXFxuXFxcbiAgICB2ZWMzIHRleENvb3JkcztcXG5cXFxuI2Vsc2VcXG5cXFxuICAgIHZlYzIgdGV4Q29vcmRzO1xcblxcXG4jZW5kaWZcXG5cXFxuXFxuXFxcbiAgICBmbG9hdCBkZXB0aEJpYXM7XFxuXFxcbiAgICBmbG9hdCBkZXB0aDtcXG5cXFxuICAgIGZsb2F0IG5Eb3RMO1xcblxcXG4gICAgdmVjMiB0ZXhlbFN0ZXBTaXplO1xcblxcXG4gICAgZmxvYXQgbm9ybWFsU2hhZGluZ1Ntb290aDtcXG5cXFxuICAgIGZsb2F0IGRhcmtuZXNzO1xcblxcXG59O1xcblxcXG5cIjtcbiIsIi8vVGhpcyBmaWxlIGlzIGF1dG9tYXRpY2FsbHkgcmVidWlsdCBieSB0aGUgQ2VzaXVtIGJ1aWxkIHByb2Nlc3MuXG5leHBvcnQgZGVmYXVsdCBcIi8qKlxcblxcXG4gKiBDb252ZXJ0cyBhbiBIU0IgY29sb3IgKGh1ZSwgc2F0dXJhdGlvbiwgYnJpZ2h0bmVzcykgdG8gUkdCXFxuXFxcbiAqIEhTQiA8LT4gUkdCIGNvbnZlcnNpb24gd2l0aCBtaW5pbWFsIGJyYW5jaGluZzoge0BsaW5rIGh0dHA6Ly9sb2xlbmdpbmUubmV0L2Jsb2cvMjAxMy8wNy8yNy9yZ2ItdG8taHN2LWluLWdsc2x9XFxuXFxcbiAqXFxuXFxcbiAqIEBuYW1lIGN6bV9IU0JUb1JHQlxcblxcXG4gKiBAZ2xzbEZ1bmN0aW9uXFxuXFxcbiAqIFxcblxcXG4gKiBAcGFyYW0ge3ZlYzN9IGhzYiBUaGUgY29sb3IgaW4gSFNCLlxcblxcXG4gKlxcblxcXG4gKiBAcmV0dXJucyB7dmVjM30gVGhlIGNvbG9yIGluIFJHQi5cXG5cXFxuICpcXG5cXFxuICogQGV4YW1wbGVcXG5cXFxuICogdmVjMyBoc2IgPSBjem1fUkdCVG9IU0IocmdiKTtcXG5cXFxuICogaHNiLnogKj0gMC4xO1xcblxcXG4gKiByZ2IgPSBjem1fSFNCVG9SR0IoaHNiKTtcXG5cXFxuICovXFxuXFxcblxcblxcXG5jb25zdCB2ZWM0IEtfSFNCMlJHQiA9IHZlYzQoMS4wLCAyLjAgLyAzLjAsIDEuMCAvIDMuMCwgMy4wKTtcXG5cXFxuXFxuXFxcbnZlYzMgY3ptX0hTQlRvUkdCKHZlYzMgaHNiKVxcblxcXG57XFxuXFxcbiAgICB2ZWMzIHAgPSBhYnMoZnJhY3QoaHNiLnh4eCArIEtfSFNCMlJHQi54eXopICogNi4wIC0gS19IU0IyUkdCLnd3dyk7XFxuXFxcbiAgICByZXR1cm4gaHNiLnogKiBtaXgoS19IU0IyUkdCLnh4eCwgY2xhbXAocCAtIEtfSFNCMlJHQi54eHgsIDAuMCwgMS4wKSwgaHNiLnkpO1xcblxcXG59XFxuXFxcblwiO1xuIiwiLy9UaGlzIGZpbGUgaXMgYXV0b21hdGljYWxseSByZWJ1aWx0IGJ5IHRoZSBDZXNpdW0gYnVpbGQgcHJvY2Vzcy5cbmV4cG9ydCBkZWZhdWx0IFwiLyoqXFxuXFxcbiAqIENvbnZlcnRzIGFuIEhTTCBjb2xvciAoaHVlLCBzYXR1cmF0aW9uLCBsaWdodG5lc3MpIHRvIFJHQlxcblxcXG4gKiBIU0wgPC0+IFJHQiBjb252ZXJzaW9uOiB7QGxpbmsgaHR0cDovL3d3dy5jaGlsbGlhbnQuY29tL3JnYjJoc3YuaHRtbH1cXG5cXFxuICpcXG5cXFxuICogQG5hbWUgY3ptX0hTTFRvUkdCXFxuXFxcbiAqIEBnbHNsRnVuY3Rpb25cXG5cXFxuICogXFxuXFxcbiAqIEBwYXJhbSB7dmVjM30gcmdiIFRoZSBjb2xvciBpbiBIU0wuXFxuXFxcbiAqXFxuXFxcbiAqIEByZXR1cm5zIHt2ZWMzfSBUaGUgY29sb3IgaW4gUkdCLlxcblxcXG4gKlxcblxcXG4gKiBAZXhhbXBsZVxcblxcXG4gKiB2ZWMzIGhzbCA9IGN6bV9SR0JUb0hTTChyZ2IpO1xcblxcXG4gKiBoc2wueiAqPSAwLjE7XFxuXFxcbiAqIHJnYiA9IGN6bV9IU0xUb1JHQihoc2wpO1xcblxcXG4gKi9cXG5cXFxuXFxuXFxcbnZlYzMgaHVlVG9SR0IoZmxvYXQgaHVlKVxcblxcXG57XFxuXFxcbiAgICBmbG9hdCByID0gYWJzKGh1ZSAqIDYuMCAtIDMuMCkgLSAxLjA7XFxuXFxcbiAgICBmbG9hdCBnID0gMi4wIC0gYWJzKGh1ZSAqIDYuMCAtIDIuMCk7XFxuXFxcbiAgICBmbG9hdCBiID0gMi4wIC0gYWJzKGh1ZSAqIDYuMCAtIDQuMCk7XFxuXFxcbiAgICByZXR1cm4gY2xhbXAodmVjMyhyLCBnLCBiKSwgMC4wLCAxLjApO1xcblxcXG59XFxuXFxcblxcblxcXG52ZWMzIGN6bV9IU0xUb1JHQih2ZWMzIGhzbClcXG5cXFxue1xcblxcXG4gICAgdmVjMyByZ2IgPSBodWVUb1JHQihoc2wueCk7XFxuXFxcbiAgICBmbG9hdCBjID0gKDEuMCAtIGFicygyLjAgKiBoc2wueiAtIDEuMCkpICogaHNsLnk7XFxuXFxcbiAgICByZXR1cm4gKHJnYiAtIDAuNSkgKiBjICsgaHNsLno7XFxuXFxcbn1cXG5cXFxuXCI7XG4iLCIvL1RoaXMgZmlsZSBpcyBhdXRvbWF0aWNhbGx5IHJlYnVpbHQgYnkgdGhlIENlc2l1bSBidWlsZCBwcm9jZXNzLlxuZXhwb3J0IGRlZmF1bHQgXCIvKipcXG5cXFxuICogQ29udmVydHMgYW4gUkdCIGNvbG9yIHRvIEhTQiAoaHVlLCBzYXR1cmF0aW9uLCBicmlnaHRuZXNzKVxcblxcXG4gKiBIU0IgPC0+IFJHQiBjb252ZXJzaW9uIHdpdGggbWluaW1hbCBicmFuY2hpbmc6IHtAbGluayBodHRwOi8vbG9sZW5naW5lLm5ldC9ibG9nLzIwMTMvMDcvMjcvcmdiLXRvLWhzdi1pbi1nbHNsfVxcblxcXG4gKlxcblxcXG4gKiBAbmFtZSBjem1fUkdCVG9IU0JcXG5cXFxuICogQGdsc2xGdW5jdGlvblxcblxcXG4gKiBcXG5cXFxuICogQHBhcmFtIHt2ZWMzfSByZ2IgVGhlIGNvbG9yIGluIFJHQi5cXG5cXFxuICpcXG5cXFxuICogQHJldHVybnMge3ZlYzN9IFRoZSBjb2xvciBpbiBIU0IuXFxuXFxcbiAqXFxuXFxcbiAqIEBleGFtcGxlXFxuXFxcbiAqIHZlYzMgaHNiID0gY3ptX1JHQlRvSFNCKHJnYik7XFxuXFxcbiAqIGhzYi56ICo9IDAuMTtcXG5cXFxuICogcmdiID0gY3ptX0hTQlRvUkdCKGhzYik7XFxuXFxcbiAqL1xcblxcXG5cXG5cXFxuY29uc3QgdmVjNCBLX1JHQjJIU0IgPSB2ZWM0KDAuMCwgLTEuMCAvIDMuMCwgMi4wIC8gMy4wLCAtMS4wKTtcXG5cXFxuXFxuXFxcbnZlYzMgY3ptX1JHQlRvSFNCKHZlYzMgcmdiKVxcblxcXG57XFxuXFxcbiAgICB2ZWM0IHAgPSBtaXgodmVjNChyZ2IuYmcsIEtfUkdCMkhTQi53eiksIHZlYzQocmdiLmdiLCBLX1JHQjJIU0IueHkpLCBzdGVwKHJnYi5iLCByZ2IuZykpO1xcblxcXG4gICAgdmVjNCBxID0gbWl4KHZlYzQocC54eXcsIHJnYi5yKSwgdmVjNChyZ2IuciwgcC55engpLCBzdGVwKHAueCwgcmdiLnIpKTtcXG5cXFxuXFxuXFxcbiAgICBmbG9hdCBkID0gcS54IC0gbWluKHEudywgcS55KTtcXG5cXFxuICAgIHJldHVybiB2ZWMzKGFicyhxLnogKyAocS53IC0gcS55KSAvICg2LjAgKiBkICsgY3ptX2Vwc2lsb243KSksIGQgLyAocS54ICsgY3ptX2Vwc2lsb243KSwgcS54KTtcXG5cXFxufVxcblxcXG5cIjtcbiIsIi8vVGhpcyBmaWxlIGlzIGF1dG9tYXRpY2FsbHkgcmVidWlsdCBieSB0aGUgQ2VzaXVtIGJ1aWxkIHByb2Nlc3MuXG5leHBvcnQgZGVmYXVsdCBcIi8qKlxcblxcXG4gKiBDb252ZXJ0cyBhbiBSR0IgY29sb3IgdG8gSFNMIChodWUsIHNhdHVyYXRpb24sIGxpZ2h0bmVzcylcXG5cXFxuICogSFNMIDwtPiBSR0IgY29udmVyc2lvbjoge0BsaW5rIGh0dHA6Ly93d3cuY2hpbGxpYW50LmNvbS9yZ2IyaHN2Lmh0bWx9XFxuXFxcbiAqXFxuXFxcbiAqIEBuYW1lIGN6bV9SR0JUb0hTTFxcblxcXG4gKiBAZ2xzbEZ1bmN0aW9uXFxuXFxcbiAqIFxcblxcXG4gKiBAcGFyYW0ge3ZlYzN9IHJnYiBUaGUgY29sb3IgaW4gUkdCLlxcblxcXG4gKlxcblxcXG4gKiBAcmV0dXJucyB7dmVjM30gVGhlIGNvbG9yIGluIEhTTC5cXG5cXFxuICpcXG5cXFxuICogQGV4YW1wbGVcXG5cXFxuICogdmVjMyBoc2wgPSBjem1fUkdCVG9IU0wocmdiKTtcXG5cXFxuICogaHNsLnogKj0gMC4xO1xcblxcXG4gKiByZ2IgPSBjem1fSFNMVG9SR0IoaHNsKTtcXG5cXFxuICovXFxuXFxcbiBcXG5cXFxudmVjMyBSR0J0b0hDVih2ZWMzIHJnYilcXG5cXFxue1xcblxcXG4gICAgLy8gQmFzZWQgb24gd29yayBieSBTYW0gSG9jZXZhciBhbmQgRW1pbCBQZXJzc29uXFxuXFxcbiAgICB2ZWM0IHAgPSAocmdiLmcgPCByZ2IuYikgPyB2ZWM0KHJnYi5iZywgLTEuMCwgMi4wIC8gMy4wKSA6IHZlYzQocmdiLmdiLCAwLjAsIC0xLjAgLyAzLjApO1xcblxcXG4gICAgdmVjNCBxID0gKHJnYi5yIDwgcC54KSA/IHZlYzQocC54eXcsIHJnYi5yKSA6IHZlYzQocmdiLnIsIHAueXp4KTtcXG5cXFxuICAgIGZsb2F0IGMgPSBxLnggLSBtaW4ocS53LCBxLnkpO1xcblxcXG4gICAgZmxvYXQgaCA9IGFicygocS53IC0gcS55KSAvICg2LjAgKiBjICsgY3ptX2Vwc2lsb243KSArIHEueik7XFxuXFxcbiAgICByZXR1cm4gdmVjMyhoLCBjLCBxLngpO1xcblxcXG59XFxuXFxcblxcblxcXG52ZWMzIGN6bV9SR0JUb0hTTCh2ZWMzIHJnYilcXG5cXFxue1xcblxcXG4gICAgdmVjMyBoY3YgPSBSR0J0b0hDVihyZ2IpO1xcblxcXG4gICAgZmxvYXQgbCA9IGhjdi56IC0gaGN2LnkgKiAwLjU7XFxuXFxcbiAgICBmbG9hdCBzID0gaGN2LnkgLyAoMS4wIC0gYWJzKGwgKiAyLjAgLSAxLjApICsgY3ptX2Vwc2lsb243KTtcXG5cXFxuICAgIHJldHVybiB2ZWMzKGhjdi54LCBzLCBsKTtcXG5cXFxufVxcblxcXG5cIjtcbiIsIi8vVGhpcyBmaWxlIGlzIGF1dG9tYXRpY2FsbHkgcmVidWlsdCBieSB0aGUgQ2VzaXVtIGJ1aWxkIHByb2Nlc3MuXG5leHBvcnQgZGVmYXVsdCBcIi8qKlxcblxcXG4gKiBDb252ZXJ0cyBhbiBSR0IgY29sb3IgdG8gQ0lFIFl4eS5cXG5cXFxuICogPHA+VGhlIGNvbnZlcnNpb24gaXMgZGVzY3JpYmVkIGluXFxuXFxcbiAqIHtAbGluayBodHRwOi8vY29udGVudC5ncHdpa2kub3JnL2luZGV4LnBocC9EM0RCb29rOkhpZ2gtRHluYW1pY19SYW5nZV9SZW5kZXJpbmcjTHVtaW5hbmNlX1RyYW5zZm9ybXxMdW1pbmFuY2UgVHJhbnNmb3JtfVxcblxcXG4gKiA8L3A+XFxuXFxcbiAqIFxcblxcXG4gKiBAbmFtZSBjem1fUkdCVG9YWVpcXG5cXFxuICogQGdsc2xGdW5jdGlvblxcblxcXG4gKiBcXG5cXFxuICogQHBhcmFtIHt2ZWMzfSByZ2IgVGhlIGNvbG9yIGluIFJHQi5cXG5cXFxuICpcXG5cXFxuICogQHJldHVybnMge3ZlYzN9IFRoZSBjb2xvciBpbiBDSUUgWXh5LlxcblxcXG4gKlxcblxcXG4gKiBAZXhhbXBsZVxcblxcXG4gKiB2ZWMzIHh5eiA9IGN6bV9SR0JUb1hZWihyZ2IpO1xcblxcXG4gKiB4eXoueCA9IG1heCh4eXoueCAtIGx1bWluYW5jZVRocmVzaG9sZCwgMC4wKTtcXG5cXFxuICogcmdiID0gY3ptX1hZWlRvUkdCKHh5eik7XFxuXFxcbiAqL1xcblxcXG52ZWMzIGN6bV9SR0JUb1hZWih2ZWMzIHJnYilcXG5cXFxue1xcblxcXG4gICAgY29uc3QgbWF0MyBSR0IyWFlaID0gbWF0MygwLjQxMjQsIDAuMjEyNiwgMC4wMTkzLFxcblxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAwLjM1NzYsIDAuNzE1MiwgMC4xMTkyLFxcblxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAwLjE4MDUsIDAuMDcyMiwgMC45NTA1KTtcXG5cXFxuICAgIHZlYzMgeHl6ID0gUkdCMlhZWiAqIHJnYjtcXG5cXFxuICAgIHZlYzMgWXh5O1xcblxcXG4gICAgWXh5LnIgPSB4eXouZztcXG5cXFxuICAgIGZsb2F0IHRlbXAgPSBkb3QodmVjMygxLjApLCB4eXopO1xcblxcXG4gICAgWXh5LmdiID0geHl6LnJnIC8gdGVtcDtcXG5cXFxuICAgIHJldHVybiBZeHk7XFxuXFxcbn1cXG5cXFxuXCI7XG4iLCIvL1RoaXMgZmlsZSBpcyBhdXRvbWF0aWNhbGx5IHJlYnVpbHQgYnkgdGhlIENlc2l1bSBidWlsZCBwcm9jZXNzLlxuZXhwb3J0IGRlZmF1bHQgXCIvKipcXG5cXFxuICogQ29udmVydHMgYSBDSUUgWXh5IGNvbG9yIHRvIFJHQi5cXG5cXFxuICogPHA+VGhlIGNvbnZlcnNpb24gaXMgZGVzY3JpYmVkIGluXFxuXFxcbiAqIHtAbGluayBodHRwOi8vY29udGVudC5ncHdpa2kub3JnL2luZGV4LnBocC9EM0RCb29rOkhpZ2gtRHluYW1pY19SYW5nZV9SZW5kZXJpbmcjTHVtaW5hbmNlX1RyYW5zZm9ybXxMdW1pbmFuY2UgVHJhbnNmb3JtfVxcblxcXG4gKiA8L3A+XFxuXFxcbiAqIFxcblxcXG4gKiBAbmFtZSBjem1fWFlaVG9SR0JcXG5cXFxuICogQGdsc2xGdW5jdGlvblxcblxcXG4gKiBcXG5cXFxuICogQHBhcmFtIHt2ZWMzfSBZeHkgVGhlIGNvbG9yIGluIENJRSBZeHkuXFxuXFxcbiAqXFxuXFxcbiAqIEByZXR1cm5zIHt2ZWMzfSBUaGUgY29sb3IgaW4gUkdCLlxcblxcXG4gKlxcblxcXG4gKiBAZXhhbXBsZVxcblxcXG4gKiB2ZWMzIHh5eiA9IGN6bV9SR0JUb1hZWihyZ2IpO1xcblxcXG4gKiB4eXoueCA9IG1heCh4eXoueCAtIGx1bWluYW5jZVRocmVzaG9sZCwgMC4wKTtcXG5cXFxuICogcmdiID0gY3ptX1hZWlRvUkdCKHh5eik7XFxuXFxcbiAqL1xcblxcXG52ZWMzIGN6bV9YWVpUb1JHQih2ZWMzIFl4eSlcXG5cXFxue1xcblxcXG4gICAgY29uc3QgbWF0MyBYWVoyUkdCID0gbWF0MyggMy4yNDA1LCAtMC45NjkzLCAgMC4wNTU2LFxcblxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAtMS41MzcxLCAgMS44NzYwLCAtMC4yMDQwLFxcblxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAtMC40OTg1LCAgMC4wNDE2LCAgMS4wNTcyKTtcXG5cXFxuICAgIHZlYzMgeHl6O1xcblxcXG4gICAgeHl6LnIgPSBZeHkuciAqIFl4eS5nIC8gWXh5LmI7XFxuXFxcbiAgICB4eXouZyA9IFl4eS5yO1xcblxcXG4gICAgeHl6LmIgPSBZeHkuciAqICgxLjAgLSBZeHkuZyAtIFl4eS5iKSAvIFl4eS5iO1xcblxcXG4gICAgXFxuXFxcbiAgICByZXR1cm4gWFlaMlJHQiAqIHh5ejtcXG5cXFxufVxcblxcXG5cIjtcbiIsIi8vVGhpcyBmaWxlIGlzIGF1dG9tYXRpY2FsbHkgcmVidWlsdCBieSB0aGUgQ2VzaXVtIGJ1aWxkIHByb2Nlc3MuXG5leHBvcnQgZGVmYXVsdCBcIi8vIFNlZTpcXG5cXFxuLy8gICAgaHR0cHM6Ly9rbmFya293aWN6LndvcmRwcmVzcy5jb20vMjAxNi8wMS8wNi9hY2VzLWZpbG1pYy10b25lLW1hcHBpbmctY3VydmUvXFxuXFxcblxcblxcXG52ZWMzIGN6bV9hY2VzVG9uZW1hcHBpbmcodmVjMyBjb2xvcikge1xcblxcXG4gICAgZmxvYXQgZyA9IDAuOTg1O1xcblxcXG4gICAgZmxvYXQgYSA9IDAuMDY1O1xcblxcXG4gICAgZmxvYXQgYiA9IDAuMDAwMTtcXG5cXFxuICAgIGZsb2F0IGMgPSAwLjQzMztcXG5cXFxuICAgIGZsb2F0IGQgPSAwLjIzODtcXG5cXFxuXFxuXFxcbiAgICBjb2xvciA9IChjb2xvciAqIChjb2xvciArIGEpIC0gYikgLyAoY29sb3IgKiAoZyAqIGNvbG9yICsgYykgKyBkKTtcXG5cXFxuXFxuXFxcbiAgICBjb2xvciA9IGNsYW1wKGNvbG9yLCAwLjAsIDEuMCk7XFxuXFxcblxcblxcXG4gICAgcmV0dXJuIGNvbG9yO1xcblxcXG59XFxuXFxcblwiO1xuIiwiLy9UaGlzIGZpbGUgaXMgYXV0b21hdGljYWxseSByZWJ1aWx0IGJ5IHRoZSBDZXNpdW0gYnVpbGQgcHJvY2Vzcy5cbmV4cG9ydCBkZWZhdWx0IFwiLyoqXFxuXFxcbiAqIEBwcml2YXRlXFxuXFxcbiAqL1xcblxcXG5mbG9hdCBjem1fYWxwaGFXZWlnaHQoZmxvYXQgYSlcXG5cXFxue1xcblxcXG4gICAgZmxvYXQgeiA9IChnbF9GcmFnQ29vcmQueiAtIGN6bV92aWV3cG9ydFRyYW5zZm9ybWF0aW9uWzNdWzJdKSAvIGN6bV92aWV3cG9ydFRyYW5zZm9ybWF0aW9uWzJdWzJdO1xcblxcXG5cXG5cXFxuICAgIC8vIFNlZSBXZWlnaHRlZCBCbGVuZGVkIE9yZGVyLUluZGVwZW5kZW50IFRyYW5zcGFyZW5jeSBmb3IgZXhhbXBsZXMgb2YgZGlmZmVyZW50IHdlaWdodGluZyBmdW5jdGlvbnM6XFxuXFxcbiAgICAvLyBodHRwOi8vamNndC5vcmcvcHVibGlzaGVkLzAwMDIvMDIvMDkvXFxuXFxcbiAgICByZXR1cm4gcG93KGEgKyAwLjAxLCA0LjApICsgbWF4KDFlLTIsIG1pbigzLjAgKiAxZTMsIDAuMDAzIC8gKDFlLTUgKyBwb3coYWJzKHopIC8gMjAwLjAsIDQuMCkpKSk7XFxuXFxcbn1cXG5cXFxuXCI7XG4iLCIvL1RoaXMgZmlsZSBpcyBhdXRvbWF0aWNhbGx5IHJlYnVpbHQgYnkgdGhlIENlc2l1bSBidWlsZCBwcm9jZXNzLlxuZXhwb3J0IGRlZmF1bHQgXCIvKipcXG5cXFxuICogUHJvY2VkdXJhbCBhbnRpLWFsaWFzaW5nIGJ5IGJsdXJyaW5nIHR3byBjb2xvcnMgdGhhdCBtZWV0IGF0IGEgc2hhcnAgZWRnZS5cXG5cXFxuICpcXG5cXFxuICogQG5hbWUgY3ptX2FudGlhbGlhc1xcblxcXG4gKiBAZ2xzbEZ1bmN0aW9uXFxuXFxcbiAqXFxuXFxcbiAqIEBwYXJhbSB7dmVjNH0gY29sb3IxIFRoZSBjb2xvciBvbiBvbmUgc2lkZSBvZiB0aGUgZWRnZS5cXG5cXFxuICogQHBhcmFtIHt2ZWM0fSBjb2xvcjIgVGhlIGNvbG9yIG9uIHRoZSBvdGhlciBzaWRlIG9mIHRoZSBlZGdlLlxcblxcXG4gKiBAcGFyYW0ge3ZlYzR9IGN1cnJlbnRjb2xvciBUaGUgY3VycmVudCBjb2xvciwgZWl0aGVyIDxjb2RlPmNvbG9yMTwvY29kZT4gb3IgPGNvZGU+Y29sb3IyPC9jb2RlPi5cXG5cXFxuICogQHBhcmFtIHtmbG9hdH0gZGlzdCBUaGUgZGlzdGFuY2UgdG8gdGhlIGVkZ2UgaW4gdGV4dHVyZSBjb29yZGluYXRlcy5cXG5cXFxuICogQHBhcmFtIHtmbG9hdH0gW2Z1enpGYWN0b3I9MC4xXSBDb250cm9scyB0aGUgYmx1cnJpbmVzcyBiZXR3ZWVuIHRoZSB0d28gY29sb3JzLlxcblxcXG4gKiBAcmV0dXJucyB7dmVjNH0gVGhlIGFudGktYWxpYXNlZCBjb2xvci5cXG5cXFxuICpcXG5cXFxuICogQGV4YW1wbGVcXG5cXFxuICogLy8gR0xTTCBkZWNsYXJhdGlvbnNcXG5cXFxuICogdmVjNCBjem1fYW50aWFsaWFzKHZlYzQgY29sb3IxLCB2ZWM0IGNvbG9yMiwgdmVjNCBjdXJyZW50Q29sb3IsIGZsb2F0IGRpc3QsIGZsb2F0IGZ1enpGYWN0b3IpO1xcblxcXG4gKiB2ZWM0IGN6bV9hbnRpYWxpYXModmVjNCBjb2xvcjEsIHZlYzQgY29sb3IyLCB2ZWM0IGN1cnJlbnRDb2xvciwgZmxvYXQgZGlzdCk7XFxuXFxcbiAqXFxuXFxcbiAqIC8vIGdldCB0aGUgY29sb3IgZm9yIGEgbWF0ZXJpYWwgdGhhdCBoYXMgYSBzaGFycCBlZGdlIGF0IHRoZSBsaW5lIHkgPSAwLjUgaW4gdGV4dHVyZSBzcGFjZVxcblxcXG4gKiBmbG9hdCBkaXN0ID0gYWJzKHRleHR1cmVDb29yZGluYXRlcy50IC0gMC41KTtcXG5cXFxuICogdmVjNCBjdXJyZW50Q29sb3IgPSBtaXgoYm90dG9tQ29sb3IsIHRvcENvbG9yLCBzdGVwKDAuNSwgdGV4dHVyZUNvb3JkaW5hdGVzLnQpKTtcXG5cXFxuICogdmVjNCBjb2xvciA9IGN6bV9hbnRpYWxpYXMoYm90dG9tQ29sb3IsIHRvcENvbG9yLCBjdXJyZW50Q29sb3IsIGRpc3QsIDAuMSk7XFxuXFxcbiAqL1xcblxcXG52ZWM0IGN6bV9hbnRpYWxpYXModmVjNCBjb2xvcjEsIHZlYzQgY29sb3IyLCB2ZWM0IGN1cnJlbnRDb2xvciwgZmxvYXQgZGlzdCwgZmxvYXQgZnV6ekZhY3RvcilcXG5cXFxue1xcblxcXG4gICAgZmxvYXQgdmFsMSA9IGNsYW1wKGRpc3QgLyBmdXp6RmFjdG9yLCAwLjAsIDEuMCk7XFxuXFxcbiAgICBmbG9hdCB2YWwyID0gY2xhbXAoKGRpc3QgLSAwLjUpIC8gZnV6ekZhY3RvciwgMC4wLCAxLjApO1xcblxcXG4gICAgdmFsMSA9IHZhbDEgKiAoMS4wIC0gdmFsMik7XFxuXFxcbiAgICB2YWwxID0gdmFsMSAqIHZhbDEgKiAoMy4wIC0gKDIuMCAqIHZhbDEpKTtcXG5cXFxuICAgIHZhbDEgPSBwb3codmFsMSwgMC41KTsgLy9tYWtlcyB0aGUgdHJhbnNpdGlvbiBuaWNlclxcblxcXG4gICAgXFxuXFxcbiAgICB2ZWM0IG1pZENvbG9yID0gKGNvbG9yMSArIGNvbG9yMikgKiAwLjU7XFxuXFxcbiAgICByZXR1cm4gbWl4KG1pZENvbG9yLCBjdXJyZW50Q29sb3IsIHZhbDEpO1xcblxcXG59XFxuXFxcblxcblxcXG52ZWM0IGN6bV9hbnRpYWxpYXModmVjNCBjb2xvcjEsIHZlYzQgY29sb3IyLCB2ZWM0IGN1cnJlbnRDb2xvciwgZmxvYXQgZGlzdClcXG5cXFxue1xcblxcXG4gICAgcmV0dXJuIGN6bV9hbnRpYWxpYXMoY29sb3IxLCBjb2xvcjIsIGN1cnJlbnRDb2xvciwgZGlzdCwgMC4xKTtcXG5cXFxufVxcblxcXG5cIjtcbiIsIi8vVGhpcyBmaWxlIGlzIGF1dG9tYXRpY2FsbHkgcmVidWlsdCBieSB0aGUgQ2VzaXVtIGJ1aWxkIHByb2Nlc3MuXG5leHBvcnQgZGVmYXVsdCBcIi8qKlxcblxcXG4gKiBBcHByb3hpbWF0ZWx5IGNvbXB1dGVzIHNwaGVyaWNhbCBjb29yZGluYXRlcyBnaXZlbiBhIG5vcm1hbC5cXG5cXFxuICogVXNlcyBhcHByb3hpbWF0ZSBpbnZlcnNlIHRyaWdvbm9tZXRyeSBmb3Igc3BlZWQgYW5kIGNvbnNpc3RlbmN5LFxcblxcXG4gKiBzaW5jZSBpbnZlcnNlIHRyaWdvbm9tZXRyeSBjYW4gZGlmZmVyIGZyb20gdmVuZG9yLXRvLXZlbmRvciBhbmQgd2hlbiBjb21wYXJlZCB3aXRoIHRoZSBDUFUuXFxuXFxcbiAqXFxuXFxcbiAqIEBuYW1lIGN6bV9hcHByb3hpbWF0ZVNwaGVyaWNhbENvb3JkaW5hdGVzXFxuXFxcbiAqIEBnbHNsRnVuY3Rpb25cXG5cXFxuICpcXG5cXFxuICogQHBhcmFtIHt2ZWMzfSBub3JtYWwgYXJiaXRyYXJ5LWxlbmd0aCBub3JtYWwuXFxuXFxcbiAqXFxuXFxcbiAqIEByZXR1cm5zIHt2ZWMyfSBBcHByb3hpbWF0ZSBsYXRpdHVkZSBhbmQgbG9uZ2l0dWRlIHNwaGVyaWNhbCBjb29yZGluYXRlcy5cXG5cXFxuICovXFxuXFxcbnZlYzIgY3ptX2FwcHJveGltYXRlU3BoZXJpY2FsQ29vcmRpbmF0ZXModmVjMyBub3JtYWwpIHtcXG5cXFxuICAgIC8vIFByb2plY3QgaW50byBwbGFuZSB3aXRoIHZlcnRpY2FsIGZvciBsYXRpdHVkZVxcblxcXG4gICAgZmxvYXQgbGF0aXR1ZGVBcHByb3hpbWF0aW9uID0gY3ptX2Zhc3RBcHByb3hpbWF0ZUF0YW4oc3FydChub3JtYWwueCAqIG5vcm1hbC54ICsgbm9ybWFsLnkgKiBub3JtYWwueSksIG5vcm1hbC56KTtcXG5cXFxuICAgIGZsb2F0IGxvbmdpdHVkZUFwcHJveGltYXRpb24gPSBjem1fZmFzdEFwcHJveGltYXRlQXRhbihub3JtYWwueCwgbm9ybWFsLnkpO1xcblxcXG4gICAgcmV0dXJuIHZlYzIobGF0aXR1ZGVBcHByb3hpbWF0aW9uLCBsb25naXR1ZGVBcHByb3hpbWF0aW9uKTtcXG5cXFxufVxcblxcXG5cIjtcbiIsIi8vVGhpcyBmaWxlIGlzIGF1dG9tYXRpY2FsbHkgcmVidWlsdCBieSB0aGUgQ2VzaXVtIGJ1aWxkIHByb2Nlc3MuXG5leHBvcnQgZGVmYXVsdCBcIi8qKlxcblxcXG4gKiBEZXRlcm1pbmVzIGlmIHRoZSBmcmFnbWVudCBpcyBiYWNrIGZhY2luZ1xcblxcXG4gKlxcblxcXG4gKiBAbmFtZSBjem1fYmFja0ZhY2luZ1xcblxcXG4gKiBAZ2xzbEZ1bmN0aW9uIFxcblxcXG4gKiBcXG5cXFxuICogQHJldHVybnMge2Jvb2x9IDxjb2RlPnRydWU8L2NvZGU+IGlmIHRoZSBmcmFnbWVudCBpcyBiYWNrIGZhY2luZzsgb3RoZXJ3aXNlLCA8Y29kZT5mYWxzZTwvY29kZT4uXFxuXFxcbiAqL1xcblxcXG5ib29sIGN6bV9iYWNrRmFjaW5nKClcXG5cXFxue1xcblxcXG4gICAgLy8gIWdsX0Zyb250RmFjaW5nIGRvZXNuJ3Qgd29yayBhcyBleHBlY3RlZCBvbiBNYWMvSW50ZWwgc28gdXNlIHRoZSBtb3JlIHZlcmJvc2UgZm9ybSBpbnN0ZWFkLiBTZWUgaHR0cHM6Ly9naXRodWIuY29tL0Nlc2l1bUdTL2Nlc2l1bS9wdWxsLzg0OTQuXFxuXFxcbiAgICByZXR1cm4gZ2xfRnJvbnRGYWNpbmcgPT0gZmFsc2U7XFxuXFxcbn1cXG5cXFxuXCI7XG4iLCIvL1RoaXMgZmlsZSBpcyBhdXRvbWF0aWNhbGx5IHJlYnVpbHQgYnkgdGhlIENlc2l1bSBidWlsZCBwcm9jZXNzLlxuZXhwb3J0IGRlZmF1bHQgXCIvKipcXG5cXFxuICogQnJhbmNobGVzcyB0ZXJuYXJ5IG9wZXJhdG9yIHRvIGJlIHVzZWQgd2hlbiBpdCdzIGluZXhwZW5zaXZlIHRvIGV4cGxpY2l0bHlcXG5cXFxuICogZXZhbHVhdGUgYm90aCBwb3NzaWJpbGl0aWVzIGZvciBhIGZsb2F0IGV4cHJlc3Npb24uXFxuXFxcbiAqXFxuXFxcbiAqIEBuYW1lIGN6bV9icmFuY2hGcmVlVGVybmFyeVxcblxcXG4gKiBAZ2xzbEZ1bmN0aW9uXFxuXFxcbiAqXFxuXFxcbiAqIEBwYXJhbSB7Ym9vbH0gY29tcGFyaXNvbiBBIGNvbXBhcmlzb24gc3RhdGVtZW50XFxuXFxcbiAqIEBwYXJhbSB7ZmxvYXR9IGEgVmFsdWUgdG8gcmV0dXJuIGlmIHRoZSBjb21wYXJpc29uIGlzIHRydWUuXFxuXFxcbiAqIEBwYXJhbSB7ZmxvYXR9IGIgVmFsdWUgdG8gcmV0dXJuIGlmIHRoZSBjb21wYXJpc29uIGlzIGZhbHNlLlxcblxcXG4gKlxcblxcXG4gKiBAcmV0dXJucyB7ZmxvYXR9IGVxdWl2YWxlbnQgb2YgY29tcGFyaXNvbiA/IGEgOiBiXFxuXFxcbiAqL1xcblxcXG5mbG9hdCBjem1fYnJhbmNoRnJlZVRlcm5hcnkoYm9vbCBjb21wYXJpc29uLCBmbG9hdCBhLCBmbG9hdCBiKSB7XFxuXFxcbiAgICBmbG9hdCB1c2VBID0gZmxvYXQoY29tcGFyaXNvbik7XFxuXFxcbiAgICByZXR1cm4gYSAqIHVzZUEgKyBiICogKDEuMCAtIHVzZUEpO1xcblxcXG59XFxuXFxcblxcblxcXG4vKipcXG5cXFxuICogQnJhbmNobGVzcyB0ZXJuYXJ5IG9wZXJhdG9yIHRvIGJlIHVzZWQgd2hlbiBpdCdzIGluZXhwZW5zaXZlIHRvIGV4cGxpY2l0bHlcXG5cXFxuICogZXZhbHVhdGUgYm90aCBwb3NzaWJpbGl0aWVzIGZvciBhIHZlYzIgZXhwcmVzc2lvbi5cXG5cXFxuICpcXG5cXFxuICogQG5hbWUgY3ptX2JyYW5jaEZyZWVUZXJuYXJ5XFxuXFxcbiAqIEBnbHNsRnVuY3Rpb25cXG5cXFxuICpcXG5cXFxuICogQHBhcmFtIHtib29sfSBjb21wYXJpc29uIEEgY29tcGFyaXNvbiBzdGF0ZW1lbnRcXG5cXFxuICogQHBhcmFtIHt2ZWMyfSBhIFZhbHVlIHRvIHJldHVybiBpZiB0aGUgY29tcGFyaXNvbiBpcyB0cnVlLlxcblxcXG4gKiBAcGFyYW0ge3ZlYzJ9IGIgVmFsdWUgdG8gcmV0dXJuIGlmIHRoZSBjb21wYXJpc29uIGlzIGZhbHNlLlxcblxcXG4gKlxcblxcXG4gKiBAcmV0dXJucyB7dmVjMn0gZXF1aXZhbGVudCBvZiBjb21wYXJpc29uID8gYSA6IGJcXG5cXFxuICovXFxuXFxcbnZlYzIgY3ptX2JyYW5jaEZyZWVUZXJuYXJ5KGJvb2wgY29tcGFyaXNvbiwgdmVjMiBhLCB2ZWMyIGIpIHtcXG5cXFxuICAgIGZsb2F0IHVzZUEgPSBmbG9hdChjb21wYXJpc29uKTtcXG5cXFxuICAgIHJldHVybiBhICogdXNlQSArIGIgKiAoMS4wIC0gdXNlQSk7XFxuXFxcbn1cXG5cXFxuXFxuXFxcbi8qKlxcblxcXG4gKiBCcmFuY2hsZXNzIHRlcm5hcnkgb3BlcmF0b3IgdG8gYmUgdXNlZCB3aGVuIGl0J3MgaW5leHBlbnNpdmUgdG8gZXhwbGljaXRseVxcblxcXG4gKiBldmFsdWF0ZSBib3RoIHBvc3NpYmlsaXRpZXMgZm9yIGEgdmVjMyBleHByZXNzaW9uLlxcblxcXG4gKlxcblxcXG4gKiBAbmFtZSBjem1fYnJhbmNoRnJlZVRlcm5hcnlcXG5cXFxuICogQGdsc2xGdW5jdGlvblxcblxcXG4gKlxcblxcXG4gKiBAcGFyYW0ge2Jvb2x9IGNvbXBhcmlzb24gQSBjb21wYXJpc29uIHN0YXRlbWVudFxcblxcXG4gKiBAcGFyYW0ge3ZlYzN9IGEgVmFsdWUgdG8gcmV0dXJuIGlmIHRoZSBjb21wYXJpc29uIGlzIHRydWUuXFxuXFxcbiAqIEBwYXJhbSB7dmVjM30gYiBWYWx1ZSB0byByZXR1cm4gaWYgdGhlIGNvbXBhcmlzb24gaXMgZmFsc2UuXFxuXFxcbiAqXFxuXFxcbiAqIEByZXR1cm5zIHt2ZWMzfSBlcXVpdmFsZW50IG9mIGNvbXBhcmlzb24gPyBhIDogYlxcblxcXG4gKi9cXG5cXFxudmVjMyBjem1fYnJhbmNoRnJlZVRlcm5hcnkoYm9vbCBjb21wYXJpc29uLCB2ZWMzIGEsIHZlYzMgYikge1xcblxcXG4gICAgZmxvYXQgdXNlQSA9IGZsb2F0KGNvbXBhcmlzb24pO1xcblxcXG4gICAgcmV0dXJuIGEgKiB1c2VBICsgYiAqICgxLjAgLSB1c2VBKTtcXG5cXFxufVxcblxcXG5cXG5cXFxuLyoqXFxuXFxcbiAqIEJyYW5jaGxlc3MgdGVybmFyeSBvcGVyYXRvciB0byBiZSB1c2VkIHdoZW4gaXQncyBpbmV4cGVuc2l2ZSB0byBleHBsaWNpdGx5XFxuXFxcbiAqIGV2YWx1YXRlIGJvdGggcG9zc2liaWxpdGllcyBmb3IgYSB2ZWM0IGV4cHJlc3Npb24uXFxuXFxcbiAqXFxuXFxcbiAqIEBuYW1lIGN6bV9icmFuY2hGcmVlVGVybmFyeVxcblxcXG4gKiBAZ2xzbEZ1bmN0aW9uXFxuXFxcbiAqXFxuXFxcbiAqIEBwYXJhbSB7Ym9vbH0gY29tcGFyaXNvbiBBIGNvbXBhcmlzb24gc3RhdGVtZW50XFxuXFxcbiAqIEBwYXJhbSB7dmVjM30gYSBWYWx1ZSB0byByZXR1cm4gaWYgdGhlIGNvbXBhcmlzb24gaXMgdHJ1ZS5cXG5cXFxuICogQHBhcmFtIHt2ZWMzfSBiIFZhbHVlIHRvIHJldHVybiBpZiB0aGUgY29tcGFyaXNvbiBpcyBmYWxzZS5cXG5cXFxuICpcXG5cXFxuICogQHJldHVybnMge3ZlYzN9IGVxdWl2YWxlbnQgb2YgY29tcGFyaXNvbiA/IGEgOiBiXFxuXFxcbiAqL1xcblxcXG52ZWM0IGN6bV9icmFuY2hGcmVlVGVybmFyeShib29sIGNvbXBhcmlzb24sIHZlYzQgYSwgdmVjNCBiKSB7XFxuXFxcbiAgICBmbG9hdCB1c2VBID0gZmxvYXQoY29tcGFyaXNvbik7XFxuXFxcbiAgICByZXR1cm4gYSAqIHVzZUEgKyBiICogKDEuMCAtIHVzZUEpO1xcblxcXG59XFxuXFxcblwiO1xuIiwiLy9UaGlzIGZpbGUgaXMgYXV0b21hdGljYWxseSByZWJ1aWx0IGJ5IHRoZSBDZXNpdW0gYnVpbGQgcHJvY2Vzcy5cbmV4cG9ydCBkZWZhdWx0IFwiXFxuXFxcbnZlYzQgY3ptX2Nhc2NhZGVDb2xvcih2ZWM0IHdlaWdodHMpXFxuXFxcbntcXG5cXFxuICAgIHJldHVybiB2ZWM0KDEuMCwgMC4wLCAwLjAsIDEuMCkgKiB3ZWlnaHRzLnggK1xcblxcXG4gICAgICAgICAgIHZlYzQoMC4wLCAxLjAsIDAuMCwgMS4wKSAqIHdlaWdodHMueSArXFxuXFxcbiAgICAgICAgICAgdmVjNCgwLjAsIDAuMCwgMS4wLCAxLjApICogd2VpZ2h0cy56ICtcXG5cXFxuICAgICAgICAgICB2ZWM0KDEuMCwgMC4wLCAxLjAsIDEuMCkgKiB3ZWlnaHRzLnc7XFxuXFxcbn1cXG5cXFxuXCI7XG4iLCIvL1RoaXMgZmlsZSBpcyBhdXRvbWF0aWNhbGx5IHJlYnVpbHQgYnkgdGhlIENlc2l1bSBidWlsZCBwcm9jZXNzLlxuZXhwb3J0IGRlZmF1bHQgXCJcXG5cXFxudW5pZm9ybSB2ZWM0IHNoYWRvd01hcF9jYXNjYWRlRGlzdGFuY2VzO1xcblxcXG5cXG5cXFxuZmxvYXQgY3ptX2Nhc2NhZGVEaXN0YW5jZSh2ZWM0IHdlaWdodHMpXFxuXFxcbntcXG5cXFxuICAgIHJldHVybiBkb3Qoc2hhZG93TWFwX2Nhc2NhZGVEaXN0YW5jZXMsIHdlaWdodHMpO1xcblxcXG59XFxuXFxcblwiO1xuIiwiLy9UaGlzIGZpbGUgaXMgYXV0b21hdGljYWxseSByZWJ1aWx0IGJ5IHRoZSBDZXNpdW0gYnVpbGQgcHJvY2Vzcy5cbmV4cG9ydCBkZWZhdWx0IFwiXFxuXFxcbnVuaWZvcm0gbWF0NCBzaGFkb3dNYXBfY2FzY2FkZU1hdHJpY2VzWzRdO1xcblxcXG5cXG5cXFxubWF0NCBjem1fY2FzY2FkZU1hdHJpeCh2ZWM0IHdlaWdodHMpXFxuXFxcbntcXG5cXFxuICAgIHJldHVybiBzaGFkb3dNYXBfY2FzY2FkZU1hdHJpY2VzWzBdICogd2VpZ2h0cy54ICtcXG5cXFxuICAgICAgICAgICBzaGFkb3dNYXBfY2FzY2FkZU1hdHJpY2VzWzFdICogd2VpZ2h0cy55ICtcXG5cXFxuICAgICAgICAgICBzaGFkb3dNYXBfY2FzY2FkZU1hdHJpY2VzWzJdICogd2VpZ2h0cy56ICtcXG5cXFxuICAgICAgICAgICBzaGFkb3dNYXBfY2FzY2FkZU1hdHJpY2VzWzNdICogd2VpZ2h0cy53O1xcblxcXG59XFxuXFxcblwiO1xuIiwiLy9UaGlzIGZpbGUgaXMgYXV0b21hdGljYWxseSByZWJ1aWx0IGJ5IHRoZSBDZXNpdW0gYnVpbGQgcHJvY2Vzcy5cbmV4cG9ydCBkZWZhdWx0IFwiXFxuXFxcbnVuaWZvcm0gdmVjNCBzaGFkb3dNYXBfY2FzY2FkZVNwbGl0c1syXTtcXG5cXFxuXFxuXFxcbnZlYzQgY3ptX2Nhc2NhZGVXZWlnaHRzKGZsb2F0IGRlcHRoRXllKVxcblxcXG57XFxuXFxcbiAgICAvLyBPbmUgY29tcG9uZW50IGlzIHNldCB0byAxLjAgYW5kIGFsbCBvdGhlcnMgc2V0IHRvIDAuMC5cXG5cXFxuICAgIHZlYzQgbmVhciA9IHN0ZXAoc2hhZG93TWFwX2Nhc2NhZGVTcGxpdHNbMF0sIHZlYzQoZGVwdGhFeWUpKTtcXG5cXFxuICAgIHZlYzQgZmFyID0gc3RlcChkZXB0aEV5ZSwgc2hhZG93TWFwX2Nhc2NhZGVTcGxpdHNbMV0pO1xcblxcXG4gICAgcmV0dXJuIG5lYXIgKiBmYXI7XFxuXFxcbn1cXG5cXFxuXCI7XG4iLCIvL1RoaXMgZmlsZSBpcyBhdXRvbWF0aWNhbGx5IHJlYnVpbHQgYnkgdGhlIENlc2l1bSBidWlsZCBwcm9jZXNzLlxuZXhwb3J0IGRlZmF1bHQgXCIvKipcXG5cXFxuICogRE9DX1RCQVxcblxcXG4gKlxcblxcXG4gKiBAbmFtZSBjem1fY29sdW1idXNWaWV3TW9ycGhcXG5cXFxuICogQGdsc2xGdW5jdGlvblxcblxcXG4gKi9cXG5cXFxudmVjNCBjem1fY29sdW1idXNWaWV3TW9ycGgodmVjNCBwb3NpdGlvbjJELCB2ZWM0IHBvc2l0aW9uM0QsIGZsb2F0IHRpbWUpXFxuXFxcbntcXG5cXFxuICAgIC8vIEp1c3QgbGluZWFyIGZvciBub3cuXFxuXFxcbiAgICB2ZWMzIHAgPSBtaXgocG9zaXRpb24yRC54eXosIHBvc2l0aW9uM0QueHl6LCB0aW1lKTtcXG5cXFxuICAgIHJldHVybiB2ZWM0KHAsIDEuMCk7XFxuXFxcbn1cXG5cXFxuXCI7XG4iLCIvL1RoaXMgZmlsZSBpcyBhdXRvbWF0aWNhbGx5IHJlYnVpbHQgYnkgdGhlIENlc2l1bSBidWlsZCBwcm9jZXNzLlxuZXhwb3J0IGRlZmF1bHQgXCIvKipcXG5cXFxuICogUmV0dXJucyBhIHBvc2l0aW9uIGluIG1vZGVsIGNvb3JkaW5hdGVzIHJlbGF0aXZlIHRvIGV5ZSB0YWtpbmcgaW50b1xcblxcXG4gKiBhY2NvdW50IHRoZSBjdXJyZW50IHNjZW5lIG1vZGU6IDNELCAyRCwgb3IgQ29sdW1idXMgdmlldy5cXG5cXFxuICogPHA+XFxuXFxcbiAqIFRoaXMgdXNlcyBzdGFuZGFyZCBwb3NpdGlvbiBhdHRyaWJ1dGVzLCA8Y29kZT5wb3NpdGlvbjNESGlnaDwvY29kZT4sIFxcblxcXG4gKiA8Y29kZT5wb3NpdGlvbjNETG93PC9jb2RlPiwgPGNvZGU+cG9zaXRpb24yREhpZ2g8L2NvZGU+LCBhbmQgPGNvZGU+cG9zaXRpb24yRExvdzwvY29kZT4sIFxcblxcXG4gKiBhbmQgc2hvdWxkIGJlIHVzZWQgd2hlbiB3cml0aW5nIGEgdmVydGV4IHNoYWRlciBmb3IgYW4ge0BsaW5rIEFwcGVhcmFuY2V9LlxcblxcXG4gKiA8L3A+XFxuXFxcbiAqXFxuXFxcbiAqIEBuYW1lIGN6bV9jb21wdXRlUG9zaXRpb25cXG5cXFxuICogQGdsc2xGdW5jdGlvblxcblxcXG4gKlxcblxcXG4gKiBAcmV0dXJucyB7dmVjNH0gVGhlIHBvc2l0aW9uIHJlbGF0aXZlIHRvIGV5ZS5cXG5cXFxuICpcXG5cXFxuICogQGV4YW1wbGVcXG5cXFxuICogdmVjNCBwID0gY3ptX2NvbXB1dGVQb3NpdGlvbigpO1xcblxcXG4gKiB2X3Bvc2l0aW9uRUMgPSAoY3ptX21vZGVsVmlld1JlbGF0aXZlVG9FeWUgKiBwKS54eXo7XFxuXFxcbiAqIGdsX1Bvc2l0aW9uID0gY3ptX21vZGVsVmlld1Byb2plY3Rpb25SZWxhdGl2ZVRvRXllICogcDtcXG5cXFxuICpcXG5cXFxuICogQHNlZSBjem1fdHJhbnNsYXRlUmVsYXRpdmVUb0V5ZVxcblxcXG4gKi9cXG5cXFxudmVjNCBjem1fY29tcHV0ZVBvc2l0aW9uKCk7XFxuXFxcblwiO1xuIiwiLy9UaGlzIGZpbGUgaXMgYXV0b21hdGljYWxseSByZWJ1aWx0IGJ5IHRoZSBDZXNpdW0gYnVpbGQgcHJvY2Vzcy5cbmV4cG9ydCBkZWZhdWx0IFwiLyoqXFxuXFxcbiAqIEBwcml2YXRlXFxuXFxcbiAqL1xcblxcXG52ZWMyIGNvcmRpYyhmbG9hdCBhbmdsZSlcXG5cXFxue1xcblxcXG4vLyBTY2FsZSB0aGUgdmVjdG9yIGJ5IHRoZSBhcHByb3ByaWF0ZSBmYWN0b3IgZm9yIHRoZSAyNCBpdGVyYXRpb25zIHRvIGZvbGxvdy5cXG5cXFxuICAgIHZlYzIgdmVjdG9yID0gdmVjMig2LjA3MjUyOTM1MDA4ODgyNjdlLTEsIDAuMCk7XFxuXFxcbi8vIEl0ZXJhdGlvbiAxXFxuXFxcbiAgICBmbG9hdCBzZW5zZSA9IChhbmdsZSA8IDAuMCkgPyAtMS4wIDogMS4wO1xcblxcXG4gLy8gICBmbG9hdCBmYWN0b3IgPSBzZW5zZSAqIDEuMDsgIC8vIDJeLTBcXG5cXFxuICAgIG1hdDIgcm90YXRpb24gPSBtYXQyKDEuMCwgc2Vuc2UsIC1zZW5zZSwgMS4wKTtcXG5cXFxuICAgIHZlY3RvciA9IHJvdGF0aW9uICogdmVjdG9yO1xcblxcXG4gICAgYW5nbGUgLT0gc2Vuc2UgKiA3Ljg1Mzk4MTYzMzk3NDQ4MjhlLTE7ICAvLyBhdGFuKDJeLTApXFxuXFxcbi8vIEl0ZXJhdGlvbiAyXFxuXFxcbiAgICBzZW5zZSA9IChhbmdsZSA8IDAuMCkgPyAtMS4wIDogMS4wO1xcblxcXG4gICAgZmxvYXQgZmFjdG9yID0gc2Vuc2UgKiA1LjBlLTE7ICAvLyAyXi0xXFxuXFxcbiAgICByb3RhdGlvblswXVsxXSA9IGZhY3RvcjtcXG5cXFxuICAgIHJvdGF0aW9uWzFdWzBdID0gLWZhY3RvcjtcXG5cXFxuICAgIHZlY3RvciA9IHJvdGF0aW9uICogdmVjdG9yO1xcblxcXG4gICAgYW5nbGUgLT0gc2Vuc2UgKiA0LjYzNjQ3NjA5MDAwODA2MDllLTE7ICAvLyBhdGFuKDJeLTEpXFxuXFxcbi8vIEl0ZXJhdGlvbiAzXFxuXFxcbiAgICBzZW5zZSA9IChhbmdsZSA8IDAuMCkgPyAtMS4wIDogMS4wO1xcblxcXG4gICAgZmFjdG9yID0gc2Vuc2UgKiAyLjVlLTE7ICAvLyAyXi0yXFxuXFxcbiAgICByb3RhdGlvblswXVsxXSA9IGZhY3RvcjtcXG5cXFxuICAgIHJvdGF0aW9uWzFdWzBdID0gLWZhY3RvcjtcXG5cXFxuICAgIHZlY3RvciA9IHJvdGF0aW9uICogdmVjdG9yO1xcblxcXG4gICAgYW5nbGUgLT0gc2Vuc2UgKiAyLjQ0OTc4NjYzMTI2ODY0MTRlLTE7ICAvLyBhdGFuKDJeLTIpXFxuXFxcbi8vIEl0ZXJhdGlvbiA0XFxuXFxcbiAgICBzZW5zZSA9IChhbmdsZSA8IDAuMCkgPyAtMS4wIDogMS4wO1xcblxcXG4gICAgZmFjdG9yID0gc2Vuc2UgKiAxLjI1ZS0xOyAgLy8gMl4tM1xcblxcXG4gICAgcm90YXRpb25bMF1bMV0gPSBmYWN0b3I7XFxuXFxcbiAgICByb3RhdGlvblsxXVswXSA9IC1mYWN0b3I7XFxuXFxcbiAgICB2ZWN0b3IgPSByb3RhdGlvbiAqIHZlY3RvcjtcXG5cXFxuICAgIGFuZ2xlIC09IHNlbnNlICogMS4yNDM1NDk5NDU0Njc2MTQ0ZS0xOyAgLy8gYXRhbigyXi0zKVxcblxcXG4vLyBJdGVyYXRpb24gNVxcblxcXG4gICAgc2Vuc2UgPSAoYW5nbGUgPCAwLjApID8gLTEuMCA6IDEuMDtcXG5cXFxuICAgIGZhY3RvciA9IHNlbnNlICogNi4yNWUtMjsgIC8vIDJeLTRcXG5cXFxuICAgIHJvdGF0aW9uWzBdWzFdID0gZmFjdG9yO1xcblxcXG4gICAgcm90YXRpb25bMV1bMF0gPSAtZmFjdG9yO1xcblxcXG4gICAgdmVjdG9yID0gcm90YXRpb24gKiB2ZWN0b3I7XFxuXFxcbiAgICBhbmdsZSAtPSBzZW5zZSAqIDYuMjQxODgwOTk5NTk1NzM1MGUtMjsgIC8vIGF0YW4oMl4tNClcXG5cXFxuLy8gSXRlcmF0aW9uIDZcXG5cXFxuICAgIHNlbnNlID0gKGFuZ2xlIDwgMC4wKSA/IC0xLjAgOiAxLjA7XFxuXFxcbiAgICBmYWN0b3IgPSBzZW5zZSAqIDMuMTI1ZS0yOyAgLy8gMl4tNVxcblxcXG4gICAgcm90YXRpb25bMF1bMV0gPSBmYWN0b3I7XFxuXFxcbiAgICByb3RhdGlvblsxXVswXSA9IC1mYWN0b3I7XFxuXFxcbiAgICB2ZWN0b3IgPSByb3RhdGlvbiAqIHZlY3RvcjtcXG5cXFxuICAgIGFuZ2xlIC09IHNlbnNlICogMy4xMjM5ODMzNDMwMjY4Mjc3ZS0yOyAgLy8gYXRhbigyXi01KVxcblxcXG4vLyBJdGVyYXRpb24gN1xcblxcXG4gICAgc2Vuc2UgPSAoYW5nbGUgPCAwLjApID8gLTEuMCA6IDEuMDtcXG5cXFxuICAgIGZhY3RvciA9IHNlbnNlICogMS41NjI1ZS0yOyAgLy8gMl4tNlxcblxcXG4gICAgcm90YXRpb25bMF1bMV0gPSBmYWN0b3I7XFxuXFxcbiAgICByb3RhdGlvblsxXVswXSA9IC1mYWN0b3I7XFxuXFxcbiAgICB2ZWN0b3IgPSByb3RhdGlvbiAqIHZlY3RvcjtcXG5cXFxuICAgIGFuZ2xlIC09IHNlbnNlICogMS41NjIzNzI4NjIwNDc2ODMxZS0yOyAgLy8gYXRhbigyXi02KVxcblxcXG4vLyBJdGVyYXRpb24gOFxcblxcXG4gICAgc2Vuc2UgPSAoYW5nbGUgPCAwLjApID8gLTEuMCA6IDEuMDtcXG5cXFxuICAgIGZhY3RvciA9IHNlbnNlICogNy44MTI1ZS0zOyAgLy8gMl4tN1xcblxcXG4gICAgcm90YXRpb25bMF1bMV0gPSBmYWN0b3I7XFxuXFxcbiAgICByb3RhdGlvblsxXVswXSA9IC1mYWN0b3I7XFxuXFxcbiAgICB2ZWN0b3IgPSByb3RhdGlvbiAqIHZlY3RvcjtcXG5cXFxuICAgIGFuZ2xlIC09IHNlbnNlICogNy44MTIzNDEwNjAxMDExMTExZS0zOyAgLy8gYXRhbigyXi03KVxcblxcXG4vLyBJdGVyYXRpb24gOVxcblxcXG4gICAgc2Vuc2UgPSAoYW5nbGUgPCAwLjApID8gLTEuMCA6IDEuMDtcXG5cXFxuICAgIGZhY3RvciA9IHNlbnNlICogMy45MDYyNWUtMzsgIC8vIDJeLThcXG5cXFxuICAgIHJvdGF0aW9uWzBdWzFdID0gZmFjdG9yO1xcblxcXG4gICAgcm90YXRpb25bMV1bMF0gPSAtZmFjdG9yO1xcblxcXG4gICAgdmVjdG9yID0gcm90YXRpb24gKiB2ZWN0b3I7XFxuXFxcbiAgICBhbmdsZSAtPSBzZW5zZSAqIDMuOTA2MjMwMTMxOTY2OTcxOGUtMzsgIC8vIGF0YW4oMl4tOClcXG5cXFxuLy8gSXRlcmF0aW9uIDEwXFxuXFxcbiAgICBzZW5zZSA9IChhbmdsZSA8IDAuMCkgPyAtMS4wIDogMS4wO1xcblxcXG4gICAgZmFjdG9yID0gc2Vuc2UgKiAxLjk1MzEyNWUtMzsgIC8vIDJeLTlcXG5cXFxuICAgIHJvdGF0aW9uWzBdWzFdID0gZmFjdG9yO1xcblxcXG4gICAgcm90YXRpb25bMV1bMF0gPSAtZmFjdG9yO1xcblxcXG4gICAgdmVjdG9yID0gcm90YXRpb24gKiB2ZWN0b3I7XFxuXFxcbiAgICBhbmdsZSAtPSBzZW5zZSAqIDEuOTUzMTIyNTE2NDc4ODE4OGUtMzsgIC8vIGF0YW4oMl4tOSlcXG5cXFxuLy8gSXRlcmF0aW9uIDExXFxuXFxcbiAgICBzZW5zZSA9IChhbmdsZSA8IDAuMCkgPyAtMS4wIDogMS4wO1xcblxcXG4gICAgZmFjdG9yID0gc2Vuc2UgKiA5Ljc2NTYyNWUtNDsgIC8vIDJeLTEwXFxuXFxcbiAgICByb3RhdGlvblswXVsxXSA9IGZhY3RvcjtcXG5cXFxuICAgIHJvdGF0aW9uWzFdWzBdID0gLWZhY3RvcjtcXG5cXFxuICAgIHZlY3RvciA9IHJvdGF0aW9uICogdmVjdG9yO1xcblxcXG4gICAgYW5nbGUgLT0gc2Vuc2UgKiA5Ljc2NTYyMTg5NTU5MzE5NDZlLTQ7ICAvLyBhdGFuKDJeLTEwKVxcblxcXG4vLyBJdGVyYXRpb24gMTJcXG5cXFxuICAgIHNlbnNlID0gKGFuZ2xlIDwgMC4wKSA/IC0xLjAgOiAxLjA7XFxuXFxcbiAgICBmYWN0b3IgPSBzZW5zZSAqIDQuODgyODEyNWUtNDsgIC8vIDJeLTExXFxuXFxcbiAgICByb3RhdGlvblswXVsxXSA9IGZhY3RvcjtcXG5cXFxuICAgIHJvdGF0aW9uWzFdWzBdID0gLWZhY3RvcjtcXG5cXFxuICAgIHZlY3RvciA9IHJvdGF0aW9uICogdmVjdG9yO1xcblxcXG4gICAgYW5nbGUgLT0gc2Vuc2UgKiA0Ljg4MjgxMjExMTk0ODk4MjllLTQ7ICAvLyBhdGFuKDJeLTExKVxcblxcXG4vLyBJdGVyYXRpb24gMTNcXG5cXFxuICAgIHNlbnNlID0gKGFuZ2xlIDwgMC4wKSA/IC0xLjAgOiAxLjA7XFxuXFxcbiAgICBmYWN0b3IgPSBzZW5zZSAqIDIuNDQxNDA2MjVlLTQ7ICAvLyAyXi0xMlxcblxcXG4gICAgcm90YXRpb25bMF1bMV0gPSBmYWN0b3I7XFxuXFxcbiAgICByb3RhdGlvblsxXVswXSA9IC1mYWN0b3I7XFxuXFxcbiAgICB2ZWN0b3IgPSByb3RhdGlvbiAqIHZlY3RvcjtcXG5cXFxuICAgIGFuZ2xlIC09IHNlbnNlICogMi40NDE0MDYyMDE0OTM2MTc3ZS00OyAgLy8gYXRhbigyXi0xMilcXG5cXFxuLy8gSXRlcmF0aW9uIDE0XFxuXFxcbiAgICBzZW5zZSA9IChhbmdsZSA8IDAuMCkgPyAtMS4wIDogMS4wO1xcblxcXG4gICAgZmFjdG9yID0gc2Vuc2UgKiAxLjIyMDcwMzEyNWUtNDsgIC8vIDJeLTEzXFxuXFxcbiAgICByb3RhdGlvblswXVsxXSA9IGZhY3RvcjtcXG5cXFxuICAgIHJvdGF0aW9uWzFdWzBdID0gLWZhY3RvcjtcXG5cXFxuICAgIHZlY3RvciA9IHJvdGF0aW9uICogdmVjdG9yO1xcblxcXG4gICAgYW5nbGUgLT0gc2Vuc2UgKiAxLjIyMDcwMzExODkzNjcwMjFlLTQ7ICAvLyBhdGFuKDJeLTEzKVxcblxcXG4vLyBJdGVyYXRpb24gMTVcXG5cXFxuICAgIHNlbnNlID0gKGFuZ2xlIDwgMC4wKSA/IC0xLjAgOiAxLjA7XFxuXFxcbiAgICBmYWN0b3IgPSBzZW5zZSAqIDYuMTAzNTE1NjI1ZS01OyAgLy8gMl4tMTRcXG5cXFxuICAgIHJvdGF0aW9uWzBdWzFdID0gZmFjdG9yO1xcblxcXG4gICAgcm90YXRpb25bMV1bMF0gPSAtZmFjdG9yO1xcblxcXG4gICAgdmVjdG9yID0gcm90YXRpb24gKiB2ZWN0b3I7XFxuXFxcbiAgICBhbmdsZSAtPSBzZW5zZSAqIDYuMTAzNTE1NjE3NDIwODc3M2UtNTsgIC8vIGF0YW4oMl4tMTQpXFxuXFxcbi8vIEl0ZXJhdGlvbiAxNlxcblxcXG4gICAgc2Vuc2UgPSAoYW5nbGUgPCAwLjApID8gLTEuMCA6IDEuMDtcXG5cXFxuICAgIGZhY3RvciA9IHNlbnNlICogMy4wNTE3NTc4MTI1ZS01OyAgLy8gMl4tMTVcXG5cXFxuICAgIHJvdGF0aW9uWzBdWzFdID0gZmFjdG9yO1xcblxcXG4gICAgcm90YXRpb25bMV1bMF0gPSAtZmFjdG9yO1xcblxcXG4gICAgdmVjdG9yID0gcm90YXRpb24gKiB2ZWN0b3I7XFxuXFxcbiAgICBhbmdsZSAtPSBzZW5zZSAqIDMuMDUxNzU3ODExNTUyNjA5NmUtNTsgIC8vIGF0YW4oMl4tMTUpXFxuXFxcbi8vIEl0ZXJhdGlvbiAxN1xcblxcXG4gICAgc2Vuc2UgPSAoYW5nbGUgPCAwLjApID8gLTEuMCA6IDEuMDtcXG5cXFxuICAgIGZhY3RvciA9IHNlbnNlICogMS41MjU4Nzg5MDYyNWUtNTsgIC8vIDJeLTE2XFxuXFxcbiAgICByb3RhdGlvblswXVsxXSA9IGZhY3RvcjtcXG5cXFxuICAgIHJvdGF0aW9uWzFdWzBdID0gLWZhY3RvcjtcXG5cXFxuICAgIHZlY3RvciA9IHJvdGF0aW9uICogdmVjdG9yO1xcblxcXG4gICAgYW5nbGUgLT0gc2Vuc2UgKiAxLjUyNTg3ODkwNjEzMTU3NjJlLTU7ICAvLyBhdGFuKDJeLTE2KVxcblxcXG4vLyBJdGVyYXRpb24gMThcXG5cXFxuICAgIHNlbnNlID0gKGFuZ2xlIDwgMC4wKSA/IC0xLjAgOiAxLjA7XFxuXFxcbiAgICBmYWN0b3IgPSBzZW5zZSAqIDcuNjI5Mzk0NTMxMjVlLTY7ICAvLyAyXi0xN1xcblxcXG4gICAgcm90YXRpb25bMF1bMV0gPSBmYWN0b3I7XFxuXFxcbiAgICByb3RhdGlvblsxXVswXSA9IC1mYWN0b3I7XFxuXFxcbiAgICB2ZWN0b3IgPSByb3RhdGlvbiAqIHZlY3RvcjtcXG5cXFxuICAgIGFuZ2xlIC09IHNlbnNlICogNy42MjkzOTQ1MzExMDE5NzAwZS02OyAgLy8gYXRhbigyXi0xNylcXG5cXFxuLy8gSXRlcmF0aW9uIDE5XFxuXFxcbiAgICBzZW5zZSA9IChhbmdsZSA8IDAuMCkgPyAtMS4wIDogMS4wO1xcblxcXG4gICAgZmFjdG9yID0gc2Vuc2UgKiAzLjgxNDY5NzI2NTYyNWUtNjsgIC8vIDJeLTE4XFxuXFxcbiAgICByb3RhdGlvblswXVsxXSA9IGZhY3RvcjtcXG5cXFxuICAgIHJvdGF0aW9uWzFdWzBdID0gLWZhY3RvcjtcXG5cXFxuICAgIHZlY3RvciA9IHJvdGF0aW9uICogdmVjdG9yO1xcblxcXG4gICAgYW5nbGUgLT0gc2Vuc2UgKiAzLjgxNDY5NzI2NTYwNjQ5NjFlLTY7ICAvLyBhdGFuKDJeLTE4KVxcblxcXG4vLyBJdGVyYXRpb24gMjBcXG5cXFxuICAgIHNlbnNlID0gKGFuZ2xlIDwgMC4wKSA/IC0xLjAgOiAxLjA7XFxuXFxcbiAgICBmYWN0b3IgPSBzZW5zZSAqIDEuOTA3MzQ4NjMyODEyNWUtNjsgIC8vIDJeLTE5XFxuXFxcbiAgICByb3RhdGlvblswXVsxXSA9IGZhY3RvcjtcXG5cXFxuICAgIHJvdGF0aW9uWzFdWzBdID0gLWZhY3RvcjtcXG5cXFxuICAgIHZlY3RvciA9IHJvdGF0aW9uICogdmVjdG9yO1xcblxcXG4gICAgYW5nbGUgLT0gc2Vuc2UgKiAxLjkwNzM0ODYzMjgxMDE4NzBlLTY7ICAvLyBhdGFuKDJeLTE5KVxcblxcXG4vLyBJdGVyYXRpb24gMjFcXG5cXFxuICAgIHNlbnNlID0gKGFuZ2xlIDwgMC4wKSA/IC0xLjAgOiAxLjA7XFxuXFxcbiAgICBmYWN0b3IgPSBzZW5zZSAqIDkuNTM2NzQzMTY0MDYyNWUtNzsgIC8vIDJeLTIwXFxuXFxcbiAgICByb3RhdGlvblswXVsxXSA9IGZhY3RvcjtcXG5cXFxuICAgIHJvdGF0aW9uWzFdWzBdID0gLWZhY3RvcjtcXG5cXFxuICAgIHZlY3RvciA9IHJvdGF0aW9uICogdmVjdG9yO1xcblxcXG4gICAgYW5nbGUgLT0gc2Vuc2UgKiA5LjUzNjc0MzE2NDA1OTYwODRlLTc7ICAvLyBhdGFuKDJeLTIwKVxcblxcXG4vLyBJdGVyYXRpb24gMjJcXG5cXFxuICAgIHNlbnNlID0gKGFuZ2xlIDwgMC4wKSA/IC0xLjAgOiAxLjA7XFxuXFxcbiAgICBmYWN0b3IgPSBzZW5zZSAqIDQuNzY4MzcxNTgyMDMxMjVlLTc7ICAvLyAyXi0yMVxcblxcXG4gICAgcm90YXRpb25bMF1bMV0gPSBmYWN0b3I7XFxuXFxcbiAgICByb3RhdGlvblsxXVswXSA9IC1mYWN0b3I7XFxuXFxcbiAgICB2ZWN0b3IgPSByb3RhdGlvbiAqIHZlY3RvcjtcXG5cXFxuICAgIGFuZ2xlIC09IHNlbnNlICogNC43NjgzNzE1ODIwMzA4ODg0ZS03OyAgLy8gYXRhbigyXi0yMSlcXG5cXFxuLy8gSXRlcmF0aW9uIDIzXFxuXFxcbiAgICBzZW5zZSA9IChhbmdsZSA8IDAuMCkgPyAtMS4wIDogMS4wO1xcblxcXG4gICAgZmFjdG9yID0gc2Vuc2UgKiAyLjM4NDE4NTc5MTAxNTYyNWUtNzsgIC8vIDJeLTIyXFxuXFxcbiAgICByb3RhdGlvblswXVsxXSA9IGZhY3RvcjtcXG5cXFxuICAgIHJvdGF0aW9uWzFdWzBdID0gLWZhY3RvcjtcXG5cXFxuICAgIHZlY3RvciA9IHJvdGF0aW9uICogdmVjdG9yO1xcblxcXG4gICAgYW5nbGUgLT0gc2Vuc2UgKiAyLjM4NDE4NTc5MTAxNTU3OTdlLTc7ICAvLyBhdGFuKDJeLTIyKVxcblxcXG4vLyBJdGVyYXRpb24gMjRcXG5cXFxuICAgIHNlbnNlID0gKGFuZ2xlIDwgMC4wKSA/IC0xLjAgOiAxLjA7XFxuXFxcbiAgICBmYWN0b3IgPSBzZW5zZSAqIDEuMTkyMDkyODk1NTA3ODEyNWUtNzsgIC8vIDJeLTIzXFxuXFxcbiAgICByb3RhdGlvblswXVsxXSA9IGZhY3RvcjtcXG5cXFxuICAgIHJvdGF0aW9uWzFdWzBdID0gLWZhY3RvcjtcXG5cXFxuICAgIHZlY3RvciA9IHJvdGF0aW9uICogdmVjdG9yO1xcblxcXG4vLyAgICBhbmdsZSAtPSBzZW5zZSAqIDEuMTkyMDkyODk1NTA3ODA2OGUtNzsgIC8vIGF0YW4oMl4tMjMpXFxuXFxcblxcblxcXG4gICAgcmV0dXJuIHZlY3RvcjtcXG5cXFxufVxcblxcXG5cXG5cXFxuLyoqXFxuXFxcbiAqIENvbXB1dGVzIHRoZSBjb3NpbmUgYW5kIHNpbmUgb2YgdGhlIHByb3ZpZGVkIGFuZ2xlIHVzaW5nIHRoZSBDT1JESUMgYWxnb3JpdGhtLlxcblxcXG4gKlxcblxcXG4gKiBAbmFtZSBjem1fY29zaW5lQW5kU2luZVxcblxcXG4gKiBAZ2xzbEZ1bmN0aW9uXFxuXFxcbiAqXFxuXFxcbiAqIEBwYXJhbSB7ZmxvYXR9IGFuZ2xlIFRoZSBhbmdsZSBpbiByYWRpYW5zLlxcblxcXG4gKlxcblxcXG4gKiBAcmV0dXJucyB7dmVjMn0gVGhlIHJlc3VsdGluZyBjb3NpbmUgb2YgdGhlIGFuZ2xlIChhcyB0aGUgeCBjb29yZGluYXRlKSBhbmQgc2luZSBvZiB0aGUgYW5nbGUgKGFzIHRoZSB5IGNvb3JkaW5hdGUpLlxcblxcXG4gKlxcblxcXG4gKiBAZXhhbXBsZVxcblxcXG4gKiB2ZWMyIHYgPSBjem1fY29zaW5lQW5kU2luZShjem1fcGlPdmVyU2l4KTtcXG5cXFxuICogZmxvYXQgY29zaW5lID0gdi54O1xcblxcXG4gKiBmbG9hdCBzaW5lID0gdi55O1xcblxcXG4gKi9cXG5cXFxudmVjMiBjem1fY29zaW5lQW5kU2luZShmbG9hdCBhbmdsZSlcXG5cXFxue1xcblxcXG4gICAgaWYgKGFuZ2xlIDwgLWN6bV9waU92ZXJUd28gfHwgYW5nbGUgPiBjem1fcGlPdmVyVHdvKVxcblxcXG4gICAge1xcblxcXG4gICAgICAgIGlmIChhbmdsZSA8IDAuMClcXG5cXFxuICAgICAgICB7XFxuXFxcbiAgICAgICAgICAgIHJldHVybiAtY29yZGljKGFuZ2xlICsgY3ptX3BpKTtcXG5cXFxuICAgICAgICB9XFxuXFxcbiAgICAgICAgZWxzZVxcblxcXG4gICAgICAgIHtcXG5cXFxuICAgICAgICAgICAgcmV0dXJuIC1jb3JkaWMoYW5nbGUgLSBjem1fcGkpO1xcblxcXG4gICAgICAgIH1cXG5cXFxuICAgIH1cXG5cXFxuICAgIGVsc2VcXG5cXFxuICAgIHtcXG5cXFxuICAgICAgICByZXR1cm4gY29yZGljKGFuZ2xlKTtcXG5cXFxuICAgIH1cXG5cXFxufVxcblxcXG5cIjtcbiIsIi8vVGhpcyBmaWxlIGlzIGF1dG9tYXRpY2FsbHkgcmVidWlsdCBieSB0aGUgQ2VzaXVtIGJ1aWxkIHByb2Nlc3MuXG5leHBvcnQgZGVmYXVsdCBcIi8qKlxcblxcXG4gKiBEZWNvbXByZXNzZXMgdGV4dHVyZSBjb29yZGluYXRlcyB0aGF0IHdlcmUgcGFja2VkIGludG8gYSBzaW5nbGUgZmxvYXQuXFxuXFxcbiAqXFxuXFxcbiAqIEBuYW1lIGN6bV9kZWNvbXByZXNzVGV4dHVyZUNvb3JkaW5hdGVzXFxuXFxcbiAqIEBnbHNsRnVuY3Rpb25cXG5cXFxuICpcXG5cXFxuICogQHBhcmFtIHtmbG9hdH0gZW5jb2RlZCBUaGUgY29tcHJlc3NlZCB0ZXh0dXJlIGNvb3JkaW5hdGVzLlxcblxcXG4gKiBAcmV0dXJucyB7dmVjMn0gVGhlIGRlY29tcHJlc3NlZCB0ZXh0dXJlIGNvb3JkaW5hdGVzLlxcblxcXG4gKi9cXG5cXFxuIHZlYzIgY3ptX2RlY29tcHJlc3NUZXh0dXJlQ29vcmRpbmF0ZXMoZmxvYXQgZW5jb2RlZClcXG5cXFxuIHtcXG5cXFxuICAgIGZsb2F0IHRlbXAgPSBlbmNvZGVkIC8gNDA5Ni4wO1xcblxcXG4gICAgZmxvYXQgeFplcm9UbzQwOTUgPSBmbG9vcih0ZW1wKTtcXG5cXFxuICAgIGZsb2F0IHN0eCA9IHhaZXJvVG80MDk1IC8gNDA5NS4wO1xcblxcXG4gICAgZmxvYXQgc3R5ID0gKGVuY29kZWQgLSB4WmVyb1RvNDA5NSAqIDQwOTYuMCkgLyA0MDk1LjA7XFxuXFxcbiAgICByZXR1cm4gdmVjMihzdHgsIHN0eSk7XFxuXFxcbiB9XFxuXFxcblwiO1xuIiwiLy9UaGlzIGZpbGUgaXMgYXV0b21hdGljYWxseSByZWJ1aWx0IGJ5IHRoZSBDZXNpdW0gYnVpbGQgcHJvY2Vzcy5cbmV4cG9ydCBkZWZhdWx0IFwiLyoqXFxuXFxcbiAqIEdldCBkZWZhdWx0IHBhcmFtZXRlcnMgZm9yIHBoeXNpY2FsbHkgYmFzZWQgcmVuZGVyaW5nLiBUaGVzZSBkZWZhdWx0c1xcblxcXG4gKiBkZXNjcmliZSBhIHJvdWdoIGRpZWxlY3RyaWMgKG5vbi1tZXRhbCkgc3VyZmFjZSAoZS5nLiByb3VnaCBwbGFzdGljKS5cXG5cXFxuICpcXG5cXFxuICogQHJldHVybiB7Y3ptX3BiclBhcmFtZXRlcnN9IERlZmF1bHQgcGFyYW1ldGVycyBmb3Ige0BsaW5rIGN6bV9wYnJMaWdodGluZ31cXG5cXFxuICovXFxuXFxcbmN6bV9wYnJQYXJhbWV0ZXJzIGN6bV9kZWZhdWx0UGJyTWF0ZXJpYWwoKVxcblxcXG57XFxuXFxcbiAgICBjem1fcGJyUGFyYW1ldGVycyByZXN1bHRzO1xcblxcXG4gICAgcmVzdWx0cy5kaWZmdXNlQ29sb3IgPSB2ZWMzKDEuMCk7XFxuXFxcbiAgICByZXN1bHRzLnJvdWdobmVzcyA9IDEuMDtcXG5cXFxuXFxuXFxcbiAgICBjb25zdCB2ZWMzIFJFRkxFQ1RBTkNFX0RJRUxFQ1RSSUMgPSB2ZWMzKDAuMDQpO1xcblxcXG4gICAgcmVzdWx0cy5mMCA9IFJFRkxFQ1RBTkNFX0RJRUxFQ1RSSUM7XFxuXFxcbiAgICByZXR1cm4gcmVzdWx0cztcXG5cXFxufVxcblxcXG5cIjtcbiIsIi8vVGhpcyBmaWxlIGlzIGF1dG9tYXRpY2FsbHkgcmVidWlsdCBieSB0aGUgQ2VzaXVtIGJ1aWxkIHByb2Nlc3MuXG5leHBvcnQgZGVmYXVsdCBcIi8vIGVtdWxhdGVkIG5vcGVyc3BlY3RpdmVcXG5cXFxuI2lmIGRlZmluZWQoR0xfRVhUX2ZyYWdfZGVwdGgpICYmICFkZWZpbmVkKExPR19ERVBUSClcXG5cXFxudmFyeWluZyBmbG9hdCB2X1dpbmRvd1o7XFxuXFxcbiNlbmRpZlxcblxcXG5cXG5cXFxuLyoqXFxuXFxcbiAqIEVtdWxhdGVzIEdMX0RFUFRIX0NMQU1QLCB3aGljaCBpcyBub3QgYXZhaWxhYmxlIGluIFdlYkdMIDEgb3IgMi5cXG5cXFxuICogR0xfREVQVEhfQ0xBTVAgY2xhbXBzIGdlb21ldHJ5IHRoYXQgaXMgb3V0c2lkZSB0aGUgbmVhciBhbmQgZmFyIHBsYW5lcywgXFxuXFxcbiAqIGNhcHBpbmcgdGhlIHNoYWRvdyB2b2x1bWUuIE1vcmUgaW5mb3JtYXRpb24gaGVyZTogXFxuXFxcbiAqIGh0dHBzOi8vd3d3Lmtocm9ub3Mub3JnL3JlZ2lzdHJ5L09wZW5HTC9leHRlbnNpb25zL0FSQi9BUkJfZGVwdGhfY2xhbXAudHh0LlxcblxcXG4gKlxcblxcXG4gKiBXaGVuIEdMX0VYVF9mcmFnX2RlcHRoIGlzIGF2YWlsYWJsZSB3ZSBlbXVsYXRlIEdMX0RFUFRIX0NMQU1QIGJ5IGVuc3VyaW5nIFxcblxcXG4gKiBubyBnZW9tZXRyeSBnZXRzIGNsaXBwZWQgYnkgc2V0dGluZyB0aGUgY2xpcCBzcGFjZSB6IHZhbHVlIHRvIDAuMCBhbmQgdGhlblxcblxcXG4gKiBzZW5kaW5nIHRoZSB1bmFsdGVyZWQgc2NyZWVuIHNwYWNlIHogdmFsdWUgKHVzaW5nIGVtdWxhdGVkIG5vcGVyc3BlY3RpdmVcXG5cXFxuICogaW50ZXJwb2xhdGlvbikgdG8gdGhlIGZyYWcgc2hhZGVyIHdoZXJlIGl0IGlzIGNsYW1wZWQgdG8gWzAsMV0gYW5kIHRoZW5cXG5cXFxuICogd3JpdHRlbiB3aXRoIGdsX0ZyYWdEZXB0aCAoc2VlIGN6bV93cml0ZURlcHRoQ2xhbXApLiBUaGlzIHRlY2huaXF1ZSBpcyBiYXNlZCBvbjpcXG5cXFxuICogaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvNTk2MDc1Ny9ob3ctdG8tZW11bGF0ZS1nbC1kZXB0aC1jbGFtcC1udi5cXG5cXFxuICpcXG5cXFxuICogV2hlbiBHTF9FWFRfZnJhZ19kZXB0aCBpcyBub3QgYXZhaWxhYmxlLCB3aGljaCBpcyB0aGUgY2FzZSBvbiBzb21lIG1vYmlsZSBcXG5cXFxuICogZGV2aWNlcywgd2UgbXVzdCBhdHRlbXB0IHRvIGZpeCB0aGlzIG9ubHkgaW4gdGhlIHZlcnRleCBzaGFkZXIuIFxcblxcXG4gKiBUaGUgYXBwcm9hY2ggaXMgdG8gY2xhbXAgdGhlIHogdmFsdWUgdG8gdGhlIGZhciBwbGFuZSwgd2hpY2ggY2xvc2VzIHRoZSBcXG5cXFxuICogc2hhZG93IHZvbHVtZSBidXQgYWxzbyBkaXN0b3J0cyB0aGUgZ2VvbWV0cnksIHNvIHRoZXJlIGNhbiBzdGlsbCBiZSBhcnRpZmFjdHNcXG5cXFxuICogb24gZnJ1c3R1bSBzZWFtcy5cXG5cXFxuICpcXG5cXFxuICogQG5hbWUgY3ptX2RlcHRoQ2xhbXBcXG5cXFxuICogQGdsc2xGdW5jdGlvblxcblxcXG4gKlxcblxcXG4gKiBAcGFyYW0ge3ZlYzR9IGNvb3JkcyBUaGUgdmVydGV4IGluIGNsaXAgY29vcmRpbmF0ZXMuXFxuXFxcbiAqIEByZXR1cm5zIHt2ZWM0fSBUaGUgbW9kaWZpZWQgdmVydGV4LlxcblxcXG4gKlxcblxcXG4gKiBAZXhhbXBsZVxcblxcXG4gKiBnbF9Qb3NpdGlvbiA9IGN6bV9kZXB0aENsYW1wKGN6bV9tb2RlbFZpZXdQcm9qZWN0aW9uICogdmVjNChwb3NpdGlvbiwgMS4wKSk7XFxuXFxcbiAqXFxuXFxcbiAqIEBzZWUgY3ptX3dyaXRlRGVwdGhDbGFtcFxcblxcXG4gKi9cXG5cXFxudmVjNCBjem1fZGVwdGhDbGFtcCh2ZWM0IGNvb3JkcylcXG5cXFxue1xcblxcXG4jaWZuZGVmIExPR19ERVBUSFxcblxcXG4jaWZkZWYgR0xfRVhUX2ZyYWdfZGVwdGhcXG5cXFxuICAgIHZfV2luZG93WiA9ICgwLjUgKiAoY29vcmRzLnogLyBjb29yZHMudykgKyAwLjUpICogY29vcmRzLnc7XFxuXFxcbiAgICBjb29yZHMueiA9IDAuMDtcXG5cXFxuI2Vsc2VcXG5cXFxuICAgIGNvb3Jkcy56ID0gbWluKGNvb3Jkcy56LCBjb29yZHMudyk7XFxuXFxcbiNlbmRpZlxcblxcXG4jZW5kaWZcXG5cXFxuICAgIHJldHVybiBjb29yZHM7XFxuXFxcbn1cXG5cXFxuXCI7XG4iLCIvL1RoaXMgZmlsZSBpcyBhdXRvbWF0aWNhbGx5IHJlYnVpbHQgYnkgdGhlIENlc2l1bSBidWlsZCBwcm9jZXNzLlxuZXhwb3J0IGRlZmF1bHQgXCIvKipcXG5cXFxuICogQ29tcHV0ZXMgYSAzeDMgcm90YXRpb24gbWF0cml4IHRoYXQgdHJhbnNmb3JtcyB2ZWN0b3JzIGZyb20gYW4gZWxsaXBzb2lkJ3MgZWFzdC1ub3J0aC11cCBjb29yZGluYXRlIHN5c3RlbSBcXG5cXFxuICogdG8gZXllIGNvb3JkaW5hdGVzLiAgSW4gZWFzdC1ub3J0aC11cCBjb29yZGluYXRlcywgeCBwb2ludHMgZWFzdCwgeSBwb2ludHMgbm9ydGgsIGFuZCB6IHBvaW50cyBhbG9uZyB0aGUgXFxuXFxcbiAqIHN1cmZhY2Ugbm9ybWFsLiAgRWFzdC1ub3J0aC11cCBjYW4gYmUgdXNlZCBhcyBhbiBlbGxpcHNvaWQncyB0YW5nZW50IHNwYWNlIGZvciBvcGVyYXRpb25zIHN1Y2ggYXMgYnVtcCBtYXBwaW5nLlxcblxcXG4gKiA8YnIgLz48YnIgLz5cXG5cXFxuICogVGhlIGVsbGlwc29pZCBpcyBhc3N1bWVkIHRvIGJlIGNlbnRlcmVkIGF0IHRoZSBtb2RlbCBjb29yZGluYXRlJ3Mgb3JpZ2luLlxcblxcXG4gKlxcblxcXG4gKiBAbmFtZSBjem1fZWFzdE5vcnRoVXBUb0V5ZUNvb3JkaW5hdGVzXFxuXFxcbiAqIEBnbHNsRnVuY3Rpb25cXG5cXFxuICpcXG5cXFxuICogQHBhcmFtIHt2ZWMzfSBwb3NpdGlvbk1DIFRoZSBwb3NpdGlvbiBvbiB0aGUgZWxsaXBzb2lkIGluIG1vZGVsIGNvb3JkaW5hdGVzLlxcblxcXG4gKiBAcGFyYW0ge3ZlYzN9IG5vcm1hbEVDIFRoZSBub3JtYWxpemVkIGVsbGlwc29pZCBzdXJmYWNlIG5vcm1hbCwgYXQgPGNvZGU+cG9zaXRpb25NQzwvY29kZT4sIGluIGV5ZSBjb29yZGluYXRlcy5cXG5cXFxuICpcXG5cXFxuICogQHJldHVybnMge21hdDN9IEEgM3gzIHJvdGF0aW9uIG1hdHJpeCB0aGF0IHRyYW5zZm9ybXMgdmVjdG9ycyBmcm9tIHRoZSBlYXN0LW5vcnRoLXVwIGNvb3JkaW5hdGUgc3lzdGVtIHRvIGV5ZSBjb29yZGluYXRlcy5cXG5cXFxuICpcXG5cXFxuICogQGV4YW1wbGVcXG5cXFxuICogLy8gVHJhbnNmb3JtIGEgdmVjdG9yIGRlZmluZWQgaW4gdGhlIGVhc3Qtbm9ydGgtdXAgY29vcmRpbmF0ZSBcXG5cXFxuICogLy8gc3lzdGVtLCAoMCwgMCwgMSkgd2hpY2ggaXMgdGhlIHN1cmZhY2Ugbm9ybWFsLCB0byBleWUgXFxuXFxcbiAqIC8vIGNvb3JkaW5hdGVzLlxcblxcXG4gKiBtYXQzIG0gPSBjem1fZWFzdE5vcnRoVXBUb0V5ZUNvb3JkaW5hdGVzKHBvc2l0aW9uTUMsIG5vcm1hbEVDKTtcXG5cXFxuICogdmVjMyBub3JtYWxFQyA9IG0gKiB2ZWMzKDAuMCwgMC4wLCAxLjApO1xcblxcXG4gKi9cXG5cXFxubWF0MyBjem1fZWFzdE5vcnRoVXBUb0V5ZUNvb3JkaW5hdGVzKHZlYzMgcG9zaXRpb25NQywgdmVjMyBub3JtYWxFQylcXG5cXFxue1xcblxcXG4gICAgdmVjMyB0YW5nZW50TUMgPSBub3JtYWxpemUodmVjMygtcG9zaXRpb25NQy55LCBwb3NpdGlvbk1DLngsIDAuMCkpOyAgLy8gbm9ybWFsaXplZCBzdXJmYWNlIHRhbmdlbnQgaW4gbW9kZWwgY29vcmRpbmF0ZXNcXG5cXFxuICAgIHZlYzMgdGFuZ2VudEVDID0gbm9ybWFsaXplKGN6bV9ub3JtYWwzRCAqIHRhbmdlbnRNQyk7ICAgICAgICAgICAgICAgIC8vIG5vcm1hbGl6ZWQgc3VyZmFjZSB0YW5nZW50IGluIGV5ZSBjb29yZGlhbnRlc1xcblxcXG4gICAgdmVjMyBiaXRhbmdlbnRFQyA9IG5vcm1hbGl6ZShjcm9zcyhub3JtYWxFQywgdGFuZ2VudEVDKSk7ICAgICAgICAgICAgLy8gbm9ybWFsaXplZCBzdXJmYWNlIGJpdGFuZ2VudCBpbiBleWUgY29vcmRpbmF0ZXNcXG5cXFxuXFxuXFxcbiAgICByZXR1cm4gbWF0MyhcXG5cXFxuICAgICAgICB0YW5nZW50RUMueCwgICB0YW5nZW50RUMueSwgICB0YW5nZW50RUMueixcXG5cXFxuICAgICAgICBiaXRhbmdlbnRFQy54LCBiaXRhbmdlbnRFQy55LCBiaXRhbmdlbnRFQy56LFxcblxcXG4gICAgICAgIG5vcm1hbEVDLngsICAgIG5vcm1hbEVDLnksICAgIG5vcm1hbEVDLnopO1xcblxcXG59XFxuXFxcblwiO1xuIiwiLy9UaGlzIGZpbGUgaXMgYXV0b21hdGljYWxseSByZWJ1aWx0IGJ5IHRoZSBDZXNpdW0gYnVpbGQgcHJvY2Vzcy5cbmV4cG9ydCBkZWZhdWx0IFwiLyoqXFxuXFxcbiAqIERPQ19UQkFcXG5cXFxuICpcXG5cXFxuICogQG5hbWUgY3ptX2VsbGlwc29pZENvbnRhaW5zUG9pbnRcXG5cXFxuICogQGdsc2xGdW5jdGlvblxcblxcXG4gKlxcblxcXG4gKi9cXG5cXFxuYm9vbCBjem1fZWxsaXBzb2lkQ29udGFpbnNQb2ludCh2ZWMzIGVsbGlwc29pZF9pbnZlcnNlUmFkaWksIHZlYzMgcG9pbnQpXFxuXFxcbntcXG5cXFxuICAgIHZlYzMgc2NhbGVkID0gZWxsaXBzb2lkX2ludmVyc2VSYWRpaSAqIChjem1faW52ZXJzZU1vZGVsVmlldyAqIHZlYzQocG9pbnQsIDEuMCkpLnh5ejtcXG5cXFxuICAgIHJldHVybiAoZG90KHNjYWxlZCwgc2NhbGVkKSA8PSAxLjApO1xcblxcXG59XFxuXFxcblwiO1xuIiwiLy9UaGlzIGZpbGUgaXMgYXV0b21hdGljYWxseSByZWJ1aWx0IGJ5IHRoZSBDZXNpdW0gYnVpbGQgcHJvY2Vzcy5cbmV4cG9ydCBkZWZhdWx0IFwiLyoqXFxuXFxcbiAqIERPQ19UQkFcXG5cXFxuICpcXG5cXFxuICogQG5hbWUgY3ptX2VsbGlwc29pZFdnczg0VGV4dHVyZUNvb3JkaW5hdGVzXFxuXFxcbiAqIEBnbHNsRnVuY3Rpb25cXG5cXFxuICovXFxuXFxcbnZlYzIgY3ptX2VsbGlwc29pZFdnczg0VGV4dHVyZUNvb3JkaW5hdGVzKHZlYzMgbm9ybWFsKVxcblxcXG57XFxuXFxcbiAgICByZXR1cm4gdmVjMihhdGFuKG5vcm1hbC55LCBub3JtYWwueCkgKiBjem1fb25lT3ZlclR3b1BpICsgMC41LCBhc2luKG5vcm1hbC56KSAqIGN6bV9vbmVPdmVyUGkgKyAwLjUpO1xcblxcXG59XFxuXFxcblwiO1xuIiwiLy9UaGlzIGZpbGUgaXMgYXV0b21hdGljYWxseSByZWJ1aWx0IGJ5IHRoZSBDZXNpdW0gYnVpbGQgcHJvY2Vzcy5cbmV4cG9ydCBkZWZhdWx0IFwiLyoqXFxuXFxcbiAqIENvbXBhcmVzIDxjb2RlPmxlZnQ8L2NvZGU+IGFuZCA8Y29kZT5yaWdodDwvY29kZT4gY29tcG9uZW50d2lzZS4gUmV0dXJucyA8Y29kZT50cnVlPC9jb2RlPlxcblxcXG4gKiBpZiB0aGV5IGFyZSB3aXRoaW4gPGNvZGU+ZXBzaWxvbjwvY29kZT4gYW5kIDxjb2RlPmZhbHNlPC9jb2RlPiBvdGhlcndpc2UuIFRoZSBpbnB1dHNcXG5cXFxuICogPGNvZGU+bGVmdDwvY29kZT4gYW5kIDxjb2RlPnJpZ2h0PC9jb2RlPiBjYW4gYmUgPGNvZGU+ZmxvYXQ8L2NvZGU+cywgPGNvZGU+dmVjMjwvY29kZT5zLFxcblxcXG4gKiA8Y29kZT52ZWMzPC9jb2RlPnMsIG9yIDxjb2RlPnZlYzQ8L2NvZGU+cy5cXG5cXFxuICpcXG5cXFxuICogQG5hbWUgY3ptX2VxdWFsc0Vwc2lsb25cXG5cXFxuICogQGdsc2xGdW5jdGlvblxcblxcXG4gKlxcblxcXG4gKiBAcGFyYW0ge30gbGVmdCBUaGUgZmlyc3QgdmVjdG9yLlxcblxcXG4gKiBAcGFyYW0ge30gcmlnaHQgVGhlIHNlY29uZCB2ZWN0b3IuXFxuXFxcbiAqIEBwYXJhbSB7ZmxvYXR9IGVwc2lsb24gVGhlIGVwc2lsb24gdG8gdXNlIGZvciBlcXVhbGl0eSB0ZXN0aW5nLlxcblxcXG4gKiBAcmV0dXJucyB7Ym9vbH0gPGNvZGU+dHJ1ZTwvY29kZT4gaWYgdGhlIGNvbXBvbmVudHMgYXJlIHdpdGhpbiA8Y29kZT5lcHNpbG9uPC9jb2RlPiBhbmQgPGNvZGU+ZmFsc2U8L2NvZGU+IG90aGVyd2lzZS5cXG5cXFxuICpcXG5cXFxuICogQGV4YW1wbGVcXG5cXFxuICogLy8gR0xTTCBkZWNsYXJhdGlvbnNcXG5cXFxuICogYm9vbCBjem1fZXF1YWxzRXBzaWxvbihmbG9hdCBsZWZ0LCBmbG9hdCByaWdodCwgZmxvYXQgZXBzaWxvbik7XFxuXFxcbiAqIGJvb2wgY3ptX2VxdWFsc0Vwc2lsb24odmVjMiBsZWZ0LCB2ZWMyIHJpZ2h0LCBmbG9hdCBlcHNpbG9uKTtcXG5cXFxuICogYm9vbCBjem1fZXF1YWxzRXBzaWxvbih2ZWMzIGxlZnQsIHZlYzMgcmlnaHQsIGZsb2F0IGVwc2lsb24pO1xcblxcXG4gKiBib29sIGN6bV9lcXVhbHNFcHNpbG9uKHZlYzQgbGVmdCwgdmVjNCByaWdodCwgZmxvYXQgZXBzaWxvbik7XFxuXFxcbiAqL1xcblxcXG5ib29sIGN6bV9lcXVhbHNFcHNpbG9uKHZlYzQgbGVmdCwgdmVjNCByaWdodCwgZmxvYXQgZXBzaWxvbikge1xcblxcXG4gICAgcmV0dXJuIGFsbChsZXNzVGhhbkVxdWFsKGFicyhsZWZ0IC0gcmlnaHQpLCB2ZWM0KGVwc2lsb24pKSk7XFxuXFxcbn1cXG5cXFxuXFxuXFxcbmJvb2wgY3ptX2VxdWFsc0Vwc2lsb24odmVjMyBsZWZ0LCB2ZWMzIHJpZ2h0LCBmbG9hdCBlcHNpbG9uKSB7XFxuXFxcbiAgICByZXR1cm4gYWxsKGxlc3NUaGFuRXF1YWwoYWJzKGxlZnQgLSByaWdodCksIHZlYzMoZXBzaWxvbikpKTtcXG5cXFxufVxcblxcXG5cXG5cXFxuYm9vbCBjem1fZXF1YWxzRXBzaWxvbih2ZWMyIGxlZnQsIHZlYzIgcmlnaHQsIGZsb2F0IGVwc2lsb24pIHtcXG5cXFxuICAgIHJldHVybiBhbGwobGVzc1RoYW5FcXVhbChhYnMobGVmdCAtIHJpZ2h0KSwgdmVjMihlcHNpbG9uKSkpO1xcblxcXG59XFxuXFxcblxcblxcXG5ib29sIGN6bV9lcXVhbHNFcHNpbG9uKGZsb2F0IGxlZnQsIGZsb2F0IHJpZ2h0LCBmbG9hdCBlcHNpbG9uKSB7XFxuXFxcbiAgICByZXR1cm4gKGFicyhsZWZ0IC0gcmlnaHQpIDw9IGVwc2lsb24pO1xcblxcXG59XFxuXFxcblwiO1xuIiwiLy9UaGlzIGZpbGUgaXMgYXV0b21hdGljYWxseSByZWJ1aWx0IGJ5IHRoZSBDZXNpdW0gYnVpbGQgcHJvY2Vzcy5cbmV4cG9ydCBkZWZhdWx0IFwiLyoqXFxuXFxcbiAqIERPQ19UQkFcXG5cXFxuICpcXG5cXFxuICogQG5hbWUgY3ptX2V5ZU9mZnNldFxcblxcXG4gKiBAZ2xzbEZ1bmN0aW9uXFxuXFxcbiAqXFxuXFxcbiAqIEBwYXJhbSB7dmVjNH0gcG9zaXRpb25FQyBET0NfVEJBLlxcblxcXG4gKiBAcGFyYW0ge3ZlYzN9IGV5ZU9mZnNldCBET0NfVEJBLlxcblxcXG4gKlxcblxcXG4gKiBAcmV0dXJucyB7dmVjNH0gRE9DX1RCQS5cXG5cXFxuICovXFxuXFxcbnZlYzQgY3ptX2V5ZU9mZnNldCh2ZWM0IHBvc2l0aW9uRUMsIHZlYzMgZXllT2Zmc2V0KVxcblxcXG57XFxuXFxcbiAgICAvLyBUaGlzIGVxdWF0aW9uIGlzIGFwcHJveGltYXRlIGluIHggYW5kIHkuXFxuXFxcbiAgICB2ZWM0IHAgPSBwb3NpdGlvbkVDO1xcblxcXG4gICAgdmVjNCB6RXllT2Zmc2V0ID0gbm9ybWFsaXplKHApICogZXllT2Zmc2V0Lno7XFxuXFxcbiAgICBwLnh5ICs9IGV5ZU9mZnNldC54eSArIHpFeWVPZmZzZXQueHk7XFxuXFxcbiAgICBwLnogKz0gekV5ZU9mZnNldC56O1xcblxcXG4gICAgcmV0dXJuIHA7XFxuXFxcbn1cXG5cXFxuXCI7XG4iLCIvL1RoaXMgZmlsZSBpcyBhdXRvbWF0aWNhbGx5IHJlYnVpbHQgYnkgdGhlIENlc2l1bSBidWlsZCBwcm9jZXNzLlxuZXhwb3J0IGRlZmF1bHQgXCIvKipcXG5cXFxuICogVHJhbnNmb3JtcyBhIHBvc2l0aW9uIGZyb20gZXllIHRvIHdpbmRvdyBjb29yZGluYXRlcy4gIFRoZSB0cmFuc2Zvcm1hdGlvblxcblxcXG4gKiBmcm9tIGV5ZSB0byBjbGlwIGNvb3JkaW5hdGVzIGlzIGRvbmUgdXNpbmcge0BsaW5rIGN6bV9wcm9qZWN0aW9ufS5cXG5cXFxuICogVGhlIHRyYW5zZm9ybSBmcm9tIG5vcm1hbGl6ZWQgZGV2aWNlIGNvb3JkaW5hdGVzIHRvIHdpbmRvdyBjb29yZGluYXRlcyBpc1xcblxcXG4gKiBkb25lIHVzaW5nIHtAbGluayBjem1fdmlld3BvcnRUcmFuc2Zvcm1hdGlvbn0sIHdoaWNoIGFzc3VtZXMgYSBkZXB0aCByYW5nZVxcblxcXG4gKiBvZiA8Y29kZT5uZWFyID0gMDwvY29kZT4gYW5kIDxjb2RlPmZhciA9IDE8L2NvZGU+LlxcblxcXG4gKiA8YnIgLz48YnIgLz5cXG5cXFxuICogVGhpcyB0cmFuc2Zvcm0gaXMgdXNlZnVsIHdoZW4gdGhlcmUgaXMgYSBuZWVkIHRvIG1hbmlwdWxhdGUgd2luZG93IGNvb3JkaW5hdGVzXFxuXFxcbiAqIGluIGEgdmVydGV4IHNoYWRlciBhcyBkb25lIGJ5IHtAbGluayBCaWxsYm9hcmRDb2xsZWN0aW9ufS5cXG5cXFxuICpcXG5cXFxuICogQG5hbWUgY3ptX2V5ZVRvV2luZG93Q29vcmRpbmF0ZXNcXG5cXFxuICogQGdsc2xGdW5jdGlvblxcblxcXG4gKlxcblxcXG4gKiBAcGFyYW0ge3ZlYzR9IHBvc2l0aW9uIFRoZSBwb3NpdGlvbiBpbiBleWUgY29vcmRpbmF0ZXMgdG8gdHJhbnNmb3JtLlxcblxcXG4gKlxcblxcXG4gKiBAcmV0dXJucyB7dmVjNH0gVGhlIHRyYW5zZm9ybWVkIHBvc2l0aW9uIGluIHdpbmRvdyBjb29yZGluYXRlcy5cXG5cXFxuICpcXG5cXFxuICogQHNlZSBjem1fbW9kZWxUb1dpbmRvd0Nvb3JkaW5hdGVzXFxuXFxcbiAqIEBzZWUgY3ptX3Byb2plY3Rpb25cXG5cXFxuICogQHNlZSBjem1fdmlld3BvcnRUcmFuc2Zvcm1hdGlvblxcblxcXG4gKiBAc2VlIEJpbGxib2FyZENvbGxlY3Rpb25cXG5cXFxuICpcXG5cXFxuICogQGV4YW1wbGVcXG5cXFxuICogdmVjNCBwb3NpdGlvbldDID0gY3ptX2V5ZVRvV2luZG93Q29vcmRpbmF0ZXMocG9zaXRpb25FQyk7XFxuXFxcbiAqL1xcblxcXG52ZWM0IGN6bV9leWVUb1dpbmRvd0Nvb3JkaW5hdGVzKHZlYzQgcG9zaXRpb25FQylcXG5cXFxue1xcblxcXG4gICAgdmVjNCBxID0gY3ptX3Byb2plY3Rpb24gKiBwb3NpdGlvbkVDOyAgICAgICAgICAgICAgICAgICAgICAgIC8vIGNsaXAgY29vcmRpbmF0ZXNcXG5cXFxuICAgIHEueHl6IC89IHEudzsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBub3JtYWxpemVkIGRldmljZSBjb29yZGluYXRlc1xcblxcXG4gICAgcS54eXogPSAoY3ptX3ZpZXdwb3J0VHJhbnNmb3JtYXRpb24gKiB2ZWM0KHEueHl6LCAxLjApKS54eXo7IC8vIHdpbmRvdyBjb29yZGluYXRlc1xcblxcXG4gICAgcmV0dXJuIHE7XFxuXFxcbn1cXG5cXFxuXCI7XG4iLCIvL1RoaXMgZmlsZSBpcyBhdXRvbWF0aWNhbGx5IHJlYnVpbHQgYnkgdGhlIENlc2l1bSBidWlsZCBwcm9jZXNzLlxuZXhwb3J0IGRlZmF1bHQgXCIvKipcXG5cXFxuICogQXBwcm94aWFtdGVzIGF0YW4gb3ZlciB0aGUgcmFuZ2UgWzAsIDFdLiBTYWZlIHRvIGZsaXAgb3V0cHV0IGZvciBuZWdhdGl2ZSBpbnB1dC5cXG5cXFxuICpcXG5cXFxuICogQmFzZWQgb24gTWljaGFsIERyb2JvdCdzIGFwcHJveGltYXRpb24gZnJvbSBTaGFkZXJGYXN0TGlicywgd2hpY2ggaW4gdHVybiBpcyBiYXNlZCBvblxcblxcXG4gKiBcXFwiRWZmaWNpZW50IGFwcHJveGltYXRpb25zIGZvciB0aGUgYXJjdGFuZ2VudCBmdW5jdGlvbixcXFwiIFJhamFuLCBTLiBTaWNodW4gV2FuZyBJbmtvbCwgUi4gSm95YWwsIEEuLCBNYXkgMjAwNi5cXG5cXFxuICogQWRhcHRlZCBmcm9tIFNoYWRlckZhc3RMaWJzIHVuZGVyIE1JVCBMaWNlbnNlLlxcblxcXG4gKlxcblxcXG4gKiBDaG9zZW4gZm9yIHRoZSBmb2xsb3dpbmcgY2hhcmFjdGVyaXN0aWNzIG92ZXIgcmFuZ2UgWzAsIDFdOlxcblxcXG4gKiAtIGJhc2ljYWxseSBubyBlcnJvciBhdCAwIGFuZCAxLCBpbXBvcnRhbnQgZm9yIGdldHRpbmcgYXJvdW5kIHJhbmdlIGxpbWl0IChuYWl2ZSBhdGFuMiB2aWEgYXRhbiByZXF1aXJlcyBpbmZpbml0ZSByYW5nZSBhdGFuKVxcblxcXG4gKiAtIG5vIHZpc2libGUgYXJ0aWZhY3RzIGZyb20gZmlyc3QtZGVyaXZhdGl2ZSBkaXNjb250aW51aXRpZXMsIHVubGlrZSBsYXRpdHVkZSB2aWEgcmFuZ2UtcmVkdWNlZCBzcXJ0IGFzaW4gYXBwcm94aW1hdGlvbnMgKGF0IGVxdWF0b3IpXFxuXFxcbiAqXFxuXFxcbiAqIFRoZSBvcmlnaW5hbCBjb2RlIGlzIHggKiAoLTAuMTc4NCAqIGFicyh4KSAtIDAuMDY2MyAqIHggKiB4ICsgMS4wMzAxKTtcXG5cXFxuICogUmVtb3ZlZCB0aGUgYWJzKCkgaW4gaGVyZSBiZWNhdXNlIGl0IGlzbid0IG5lZWRlZCwgdGhlIGlucHV0IHJhbmdlIGlzIGd1YXJhbnRlZWQgYXMgWzAsIDFdIGJ5IGhvdyB3ZSdyZSBhcHByb3hpbWF0aW5nIGF0YW4yLlxcblxcXG4gKlxcblxcXG4gKiBAbmFtZSBjem1fZmFzdEFwcHJveGltYXRlQXRhblxcblxcXG4gKiBAZ2xzbEZ1bmN0aW9uXFxuXFxcbiAqXFxuXFxcbiAqIEBwYXJhbSB7ZmxvYXR9IHggVmFsdWUgYmV0d2VlbiAwIGFuZCAxIGluY2x1c2l2ZS5cXG5cXFxuICpcXG5cXFxuICogQHJldHVybnMge2Zsb2F0fSBBcHByb3hpbWF0aW9uIG9mIGF0YW4oeClcXG5cXFxuICovXFxuXFxcbmZsb2F0IGN6bV9mYXN0QXBwcm94aW1hdGVBdGFuKGZsb2F0IHgpIHtcXG5cXFxuICAgIHJldHVybiB4ICogKC0wLjE3ODQgKiB4IC0gMC4wNjYzICogeCAqIHggKyAxLjAzMDEpO1xcblxcXG59XFxuXFxcblxcblxcXG4vKipcXG5cXFxuICogQXBwcm94aW1hdGlvbiBvZiBhdGFuMi5cXG5cXFxuICpcXG5cXFxuICogUmFuZ2UgcmVkdWN0aW9uIG1hdGggYmFzZWQgb24gbnZpZGlhJ3MgY2cgcmVmZXJlbmNlIGltcGxlbWVudGF0aW9uIGZvciBhdGFuMjogaHR0cDovL2RldmVsb3Blci5kb3dubG9hZC5udmlkaWEuY29tL2NnL2F0YW4yLmh0bWxcXG5cXFxuICogSG93ZXZlciwgd2UgcmVwbGFjZWQgdGhlaXIgYXRhbiBjdXJ2ZSB3aXRoIE1pY2hhZWwgRHJvYm90J3MgKHNlZSBhYm92ZSkuXFxuXFxcbiAqXFxuXFxcbiAqIEBuYW1lIGN6bV9mYXN0QXBwcm94aW1hdGVBdGFuXFxuXFxcbiAqIEBnbHNsRnVuY3Rpb25cXG5cXFxuICpcXG5cXFxuICogQHBhcmFtIHtmbG9hdH0geCBWYWx1ZSBiZXR3ZWVuIC0xIGFuZCAxIGluY2x1c2l2ZS5cXG5cXFxuICogQHBhcmFtIHtmbG9hdH0geSBWYWx1ZSBiZXR3ZWVuIC0xIGFuZCAxIGluY2x1c2l2ZS5cXG5cXFxuICpcXG5cXFxuICogQHJldHVybnMge2Zsb2F0fSBBcHByb3hpbWF0aW9uIG9mIGF0YW4yKHgsIHkpXFxuXFxcbiAqL1xcblxcXG5mbG9hdCBjem1fZmFzdEFwcHJveGltYXRlQXRhbihmbG9hdCB4LCBmbG9hdCB5KSB7XFxuXFxcbiAgICAvLyBhdGFuIGFwcHJveGltYXRpb25zIGFyZSB1c3VhbGx5IG9ubHkgcmVsaWFibGUgb3ZlciBbLTEsIDFdLCBvciwgaW4gb3VyIGNhc2UsIFswLCAxXSBkdWUgdG8gbW9kaWZpY2F0aW9ucy5cXG5cXFxuICAgIC8vIFNvIHJhbmdlLXJlZHVjZSB1c2luZyBhYnMgYW5kIGJ5IGZsaXBwaW5nIHdoZXRoZXIgeCBvciB5IGlzIG9uIHRvcC5cXG5cXFxuICAgIGZsb2F0IHQgPSBhYnMoeCk7IC8vIHQgdXNlZCBhcyBzd2FwIGFuZCBhdGFuIHJlc3VsdC5cXG5cXFxuICAgIGZsb2F0IG9wcG9zaXRlID0gYWJzKHkpO1xcblxcXG4gICAgZmxvYXQgYWRqYWNlbnQgPSBtYXgodCwgb3Bwb3NpdGUpO1xcblxcXG4gICAgb3Bwb3NpdGUgPSBtaW4odCwgb3Bwb3NpdGUpO1xcblxcXG5cXG5cXFxuICAgIHQgPSBjem1fZmFzdEFwcHJveGltYXRlQXRhbihvcHBvc2l0ZSAvIGFkamFjZW50KTtcXG5cXFxuXFxuXFxcbiAgICAvLyBVbmRvIHJhbmdlIHJlZHVjdGlvblxcblxcXG4gICAgdCA9IGN6bV9icmFuY2hGcmVlVGVybmFyeShhYnMoeSkgPiBhYnMoeCksIGN6bV9waU92ZXJUd28gLSB0LCB0KTtcXG5cXFxuICAgIHQgPSBjem1fYnJhbmNoRnJlZVRlcm5hcnkoeCA8IDAuMCwgY3ptX3BpIC0gdCwgdCk7XFxuXFxcbiAgICB0ID0gY3ptX2JyYW5jaEZyZWVUZXJuYXJ5KHkgPCAwLjAsIC10LCB0KTtcXG5cXFxuICAgIHJldHVybiB0O1xcblxcXG59XFxuXFxcblwiO1xuIiwiLy9UaGlzIGZpbGUgaXMgYXV0b21hdGljYWxseSByZWJ1aWx0IGJ5IHRoZSBDZXNpdW0gYnVpbGQgcHJvY2Vzcy5cbmV4cG9ydCBkZWZhdWx0IFwiLyoqXFxuXFxcbiAqIEdldHMgdGhlIGNvbG9yIHdpdGggZm9nIGF0IGEgZGlzdGFuY2UgZnJvbSB0aGUgY2FtZXJhLlxcblxcXG4gKlxcblxcXG4gKiBAbmFtZSBjem1fZm9nXFxuXFxcbiAqIEBnbHNsRnVuY3Rpb25cXG5cXFxuICpcXG5cXFxuICogQHBhcmFtIHtmbG9hdH0gZGlzdGFuY2VUb0NhbWVyYSBUaGUgZGlzdGFuY2UgdG8gdGhlIGNhbWVyYSBpbiBtZXRlcnMuXFxuXFxcbiAqIEBwYXJhbSB7dmVjM30gY29sb3IgVGhlIG9yaWdpbmFsIGNvbG9yLlxcblxcXG4gKiBAcGFyYW0ge3ZlYzN9IGZvZ0NvbG9yIFRoZSBjb2xvciBvZiB0aGUgZm9nLlxcblxcXG4gKlxcblxcXG4gKiBAcmV0dXJucyB7dmVjM30gVGhlIGNvbG9yIGFkanVzdGVkIGZvciBmb2cgYXQgdGhlIGRpc3RhbmNlIGZyb20gdGhlIGNhbWVyYS5cXG5cXFxuICovXFxuXFxcbnZlYzMgY3ptX2ZvZyhmbG9hdCBkaXN0YW5jZVRvQ2FtZXJhLCB2ZWMzIGNvbG9yLCB2ZWMzIGZvZ0NvbG9yKVxcblxcXG57XFxuXFxcbiAgICBmbG9hdCBzY2FsYXIgPSBkaXN0YW5jZVRvQ2FtZXJhICogY3ptX2ZvZ0RlbnNpdHk7XFxuXFxcbiAgICBmbG9hdCBmb2cgPSAxLjAgLSBleHAoLShzY2FsYXIgKiBzY2FsYXIpKTtcXG5cXFxuICAgIHJldHVybiBtaXgoY29sb3IsIGZvZ0NvbG9yLCBmb2cpO1xcblxcXG59XFxuXFxcblxcblxcXG4vKipcXG5cXFxuICogR2V0cyB0aGUgY29sb3Igd2l0aCBmb2cgYXQgYSBkaXN0YW5jZSBmcm9tIHRoZSBjYW1lcmEuXFxuXFxcbiAqXFxuXFxcbiAqIEBuYW1lIGN6bV9mb2dcXG5cXFxuICogQGdsc2xGdW5jdGlvblxcblxcXG4gKlxcblxcXG4gKiBAcGFyYW0ge2Zsb2F0fSBkaXN0YW5jZVRvQ2FtZXJhIFRoZSBkaXN0YW5jZSB0byB0aGUgY2FtZXJhIGluIG1ldGVycy5cXG5cXFxuICogQHBhcmFtIHt2ZWMzfSBjb2xvciBUaGUgb3JpZ2luYWwgY29sb3IuXFxuXFxcbiAqIEBwYXJhbSB7dmVjM30gZm9nQ29sb3IgVGhlIGNvbG9yIG9mIHRoZSBmb2cuXFxuXFxcbiAqIEBwYXJhbSB7ZmxvYXR9IGZvZ01vZGlmaWVyQ29uc3RhbnQgQSBjb25zdGFudCB0byBtb2RpZnkgdGhlIGFwcGVhcmFuY2Ugb2YgZm9nLlxcblxcXG4gKlxcblxcXG4gKiBAcmV0dXJucyB7dmVjM30gVGhlIGNvbG9yIGFkanVzdGVkIGZvciBmb2cgYXQgdGhlIGRpc3RhbmNlIGZyb20gdGhlIGNhbWVyYS5cXG5cXFxuICovXFxuXFxcbnZlYzMgY3ptX2ZvZyhmbG9hdCBkaXN0YW5jZVRvQ2FtZXJhLCB2ZWMzIGNvbG9yLCB2ZWMzIGZvZ0NvbG9yLCBmbG9hdCBmb2dNb2RpZmllckNvbnN0YW50KVxcblxcXG57XFxuXFxcbiAgICBmbG9hdCBzY2FsYXIgPSBkaXN0YW5jZVRvQ2FtZXJhICogY3ptX2ZvZ0RlbnNpdHk7XFxuXFxcbiAgICBmbG9hdCBmb2cgPSAxLjAgLSBleHAoLSgoZm9nTW9kaWZpZXJDb25zdGFudCAqIHNjYWxhciArIGZvZ01vZGlmaWVyQ29uc3RhbnQpICogKHNjYWxhciAqICgxLjAgKyBmb2dNb2RpZmllckNvbnN0YW50KSkpKTtcXG5cXFxuICAgIHJldHVybiBtaXgoY29sb3IsIGZvZ0NvbG9yLCBmb2cpO1xcblxcXG59XFxuXFxcblwiO1xuIiwiLy9UaGlzIGZpbGUgaXMgYXV0b21hdGljYWxseSByZWJ1aWx0IGJ5IHRoZSBDZXNpdW0gYnVpbGQgcHJvY2Vzcy5cbmV4cG9ydCBkZWZhdWx0IFwiLyoqXFxuXFxcbiAqIENvbnZlcnRzIGEgY29sb3IgZnJvbSBSR0Igc3BhY2UgdG8gbGluZWFyIHNwYWNlLlxcblxcXG4gKlxcblxcXG4gKiBAbmFtZSBjem1fZ2FtbWFDb3JyZWN0XFxuXFxcbiAqIEBnbHNsRnVuY3Rpb25cXG5cXFxuICpcXG5cXFxuICogQHBhcmFtIHt2ZWMzfSBjb2xvciBUaGUgY29sb3IgaW4gUkdCIHNwYWNlLlxcblxcXG4gKiBAcmV0dXJucyB7dmVjM30gVGhlIGNvbG9yIGluIGxpbmVhciBzcGFjZS5cXG5cXFxuICovXFxuXFxcbnZlYzMgY3ptX2dhbW1hQ29ycmVjdCh2ZWMzIGNvbG9yKSB7XFxuXFxcbiNpZmRlZiBIRFJcXG5cXFxuICAgIGNvbG9yID0gcG93KGNvbG9yLCB2ZWMzKGN6bV9nYW1tYSkpO1xcblxcXG4jZW5kaWZcXG5cXFxuICAgIHJldHVybiBjb2xvcjtcXG5cXFxufVxcblxcXG5cXG5cXFxudmVjNCBjem1fZ2FtbWFDb3JyZWN0KHZlYzQgY29sb3IpIHtcXG5cXFxuI2lmZGVmIEhEUlxcblxcXG4gICAgY29sb3IucmdiID0gcG93KGNvbG9yLnJnYiwgdmVjMyhjem1fZ2FtbWEpKTtcXG5cXFxuI2VuZGlmXFxuXFxcbiAgICByZXR1cm4gY29sb3I7XFxuXFxcbn1cXG5cXFxuXCI7XG4iLCIvL1RoaXMgZmlsZSBpcyBhdXRvbWF0aWNhbGx5IHJlYnVpbHQgYnkgdGhlIENlc2l1bSBidWlsZCBwcm9jZXNzLlxuZXhwb3J0IGRlZmF1bHQgXCIvKipcXG5cXFxuICogRE9DX1RCQVxcblxcXG4gKlxcblxcXG4gKiBAbmFtZSBjem1fZ2VvZGV0aWNTdXJmYWNlTm9ybWFsXFxuXFxcbiAqIEBnbHNsRnVuY3Rpb25cXG5cXFxuICpcXG5cXFxuICogQHBhcmFtIHt2ZWMzfSBwb3NpdGlvbk9uRWxsaXBzb2lkIERPQ19UQkFcXG5cXFxuICogQHBhcmFtIHt2ZWMzfSBlbGxpcHNvaWRDZW50ZXIgRE9DX1RCQVxcblxcXG4gKiBAcGFyYW0ge3ZlYzN9IG9uZU92ZXJFbGxpcHNvaWRSYWRpaVNxdWFyZWQgRE9DX1RCQVxcblxcXG4gKiBcXG5cXFxuICogQHJldHVybnMge3ZlYzN9IERPQ19UQkEuXFxuXFxcbiAqL1xcblxcXG52ZWMzIGN6bV9nZW9kZXRpY1N1cmZhY2VOb3JtYWwodmVjMyBwb3NpdGlvbk9uRWxsaXBzb2lkLCB2ZWMzIGVsbGlwc29pZENlbnRlciwgdmVjMyBvbmVPdmVyRWxsaXBzb2lkUmFkaWlTcXVhcmVkKVxcblxcXG57XFxuXFxcbiAgICByZXR1cm4gbm9ybWFsaXplKChwb3NpdGlvbk9uRWxsaXBzb2lkIC0gZWxsaXBzb2lkQ2VudGVyKSAqIG9uZU92ZXJFbGxpcHNvaWRSYWRpaVNxdWFyZWQpO1xcblxcXG59XFxuXFxcblwiO1xuIiwiLy9UaGlzIGZpbGUgaXMgYXV0b21hdGljYWxseSByZWJ1aWx0IGJ5IHRoZSBDZXNpdW0gYnVpbGQgcHJvY2Vzcy5cbmV4cG9ydCBkZWZhdWx0IFwiLyoqXFxuXFxcbiAqIEFuIGN6bV9tYXRlcmlhbCB3aXRoIGRlZmF1bHQgdmFsdWVzLiBFdmVyeSBtYXRlcmlhbCdzIGN6bV9nZXRNYXRlcmlhbFxcblxcXG4gKiBzaG91bGQgdXNlIHRoaXMgZGVmYXVsdCBtYXRlcmlhbCBhcyBhIGJhc2UgZm9yIHRoZSBtYXRlcmlhbCBpdCByZXR1cm5zLlxcblxcXG4gKiBUaGUgZGVmYXVsdCBub3JtYWwgdmFsdWUgaXMgZ2l2ZW4gYnkgbWF0ZXJpYWxJbnB1dC5ub3JtYWxFQy5cXG5cXFxuICpcXG5cXFxuICogQG5hbWUgY3ptX2dldERlZmF1bHRNYXRlcmlhbFxcblxcXG4gKiBAZ2xzbEZ1bmN0aW9uXFxuXFxcbiAqXFxuXFxcbiAqIEBwYXJhbSB7Y3ptX21hdGVyaWFsSW5wdXR9IGlucHV0IFRoZSBpbnB1dCB1c2VkIHRvIGNvbnN0cnVjdCB0aGUgZGVmYXVsdCBtYXRlcmlhbC5cXG5cXFxuICpcXG5cXFxuICogQHJldHVybnMge2N6bV9tYXRlcmlhbH0gVGhlIGRlZmF1bHQgbWF0ZXJpYWwuXFxuXFxcbiAqXFxuXFxcbiAqIEBzZWUgY3ptX21hdGVyaWFsSW5wdXRcXG5cXFxuICogQHNlZSBjem1fbWF0ZXJpYWxcXG5cXFxuICogQHNlZSBjem1fZ2V0TWF0ZXJpYWxcXG5cXFxuICovXFxuXFxcbmN6bV9tYXRlcmlhbCBjem1fZ2V0RGVmYXVsdE1hdGVyaWFsKGN6bV9tYXRlcmlhbElucHV0IG1hdGVyaWFsSW5wdXQpXFxuXFxcbntcXG5cXFxuICAgIGN6bV9tYXRlcmlhbCBtYXRlcmlhbDtcXG5cXFxuICAgIG1hdGVyaWFsLmRpZmZ1c2UgPSB2ZWMzKDAuMCk7XFxuXFxcbiAgICBtYXRlcmlhbC5zcGVjdWxhciA9IDAuMDtcXG5cXFxuICAgIG1hdGVyaWFsLnNoaW5pbmVzcyA9IDEuMDtcXG5cXFxuICAgIG1hdGVyaWFsLm5vcm1hbCA9IG1hdGVyaWFsSW5wdXQubm9ybWFsRUM7XFxuXFxcbiAgICBtYXRlcmlhbC5lbWlzc2lvbiA9IHZlYzMoMC4wKTtcXG5cXFxuICAgIG1hdGVyaWFsLmFscGhhID0gMS4wO1xcblxcXG4gICAgcmV0dXJuIG1hdGVyaWFsO1xcblxcXG59XFxuXFxcblwiO1xuIiwiLy9UaGlzIGZpbGUgaXMgYXV0b21hdGljYWxseSByZWJ1aWx0IGJ5IHRoZSBDZXNpdW0gYnVpbGQgcHJvY2Vzcy5cbmV4cG9ydCBkZWZhdWx0IFwiLyoqXFxuXFxcbiAqIENhbGN1bGF0ZXMgdGhlIGludGVuc2l0eSBvZiBkaWZmdXNlbHkgcmVmbGVjdGVkIGxpZ2h0LlxcblxcXG4gKlxcblxcXG4gKiBAbmFtZSBjem1fZ2V0TGFtYmVydERpZmZ1c2VcXG5cXFxuICogQGdsc2xGdW5jdGlvblxcblxcXG4gKlxcblxcXG4gKiBAcGFyYW0ge3ZlYzN9IGxpZ2h0RGlyZWN0aW9uRUMgVW5pdCB2ZWN0b3IgcG9pbnRpbmcgdG8gdGhlIGxpZ2h0IHNvdXJjZSBpbiBleWUgY29vcmRpbmF0ZXMuXFxuXFxcbiAqIEBwYXJhbSB7dmVjM30gbm9ybWFsRUMgVGhlIHN1cmZhY2Ugbm9ybWFsIGluIGV5ZSBjb29yZGluYXRlcy5cXG5cXFxuICpcXG5cXFxuICogQHJldHVybnMge2Zsb2F0fSBUaGUgaW50ZW5zaXR5IG9mIHRoZSBkaWZmdXNlIHJlZmxlY3Rpb24uXFxuXFxcbiAqXFxuXFxcbiAqIEBzZWUgY3ptX3Bob25nXFxuXFxcbiAqXFxuXFxcbiAqIEBleGFtcGxlXFxuXFxcbiAqIGZsb2F0IGRpZmZ1c2VJbnRlbnNpdHkgPSBjem1fZ2V0TGFtYmVydERpZmZ1c2UobGlnaHREaXJlY3Rpb25FQywgbm9ybWFsRUMpO1xcblxcXG4gKiBmbG9hdCBzcGVjdWxhckludGVuc2l0eSA9IGN6bV9nZXRTcGVjdWxhcihsaWdodERpcmVjdGlvbkVDLCB0b0V5ZUVDLCBub3JtYWxFQywgMjAwKTtcXG5cXFxuICogdmVjMyBjb2xvciA9IChkaWZmdXNlQ29sb3IgKiBkaWZmdXNlSW50ZW5zaXR5KSArIChzcGVjdWxhckNvbG9yICogc3BlY3VsYXJJbnRlbnNpdHkpO1xcblxcXG4gKi9cXG5cXFxuZmxvYXQgY3ptX2dldExhbWJlcnREaWZmdXNlKHZlYzMgbGlnaHREaXJlY3Rpb25FQywgdmVjMyBub3JtYWxFQylcXG5cXFxue1xcblxcXG4gICAgcmV0dXJuIG1heChkb3QobGlnaHREaXJlY3Rpb25FQywgbm9ybWFsRUMpLCAwLjApO1xcblxcXG59XFxuXFxcblwiO1xuIiwiLy9UaGlzIGZpbGUgaXMgYXV0b21hdGljYWxseSByZWJ1aWx0IGJ5IHRoZSBDZXNpdW0gYnVpbGQgcHJvY2Vzcy5cbmV4cG9ydCBkZWZhdWx0IFwiLyoqXFxuXFxcbiAqIENhbGN1bGF0ZXMgdGhlIHNwZWN1bGFyIGludGVuc2l0eSBvZiByZWZsZWN0ZWQgbGlnaHQuXFxuXFxcbiAqXFxuXFxcbiAqIEBuYW1lIGN6bV9nZXRTcGVjdWxhclxcblxcXG4gKiBAZ2xzbEZ1bmN0aW9uXFxuXFxcbiAqXFxuXFxcbiAqIEBwYXJhbSB7dmVjM30gbGlnaHREaXJlY3Rpb25FQyBVbml0IHZlY3RvciBwb2ludGluZyB0byB0aGUgbGlnaHQgc291cmNlIGluIGV5ZSBjb29yZGluYXRlcy5cXG5cXFxuICogQHBhcmFtIHt2ZWMzfSB0b0V5ZUVDIFVuaXQgdmVjdG9yIHBvaW50aW5nIHRvIHRoZSBleWUgcG9zaXRpb24gaW4gZXllIGNvb3JkaW5hdGVzLlxcblxcXG4gKiBAcGFyYW0ge3ZlYzN9IG5vcm1hbEVDIFRoZSBzdXJmYWNlIG5vcm1hbCBpbiBleWUgY29vcmRpbmF0ZXMuXFxuXFxcbiAqIEBwYXJhbSB7ZmxvYXR9IHNoaW5pbmVzcyBUaGUgc2hhcnBuZXNzIG9mIHRoZSBzcGVjdWxhciByZWZsZWN0aW9uLiAgSGlnaGVyIHZhbHVlcyBjcmVhdGUgYSBzbWFsbGVyLCBtb3JlIGZvY3VzZWQgc3BlY3VsYXIgaGlnaGxpZ2h0LlxcblxcXG4gKlxcblxcXG4gKiBAcmV0dXJucyB7ZmxvYXR9IFRoZSBpbnRlbnNpdHkgb2YgdGhlIHNwZWN1bGFyIGhpZ2hsaWdodC5cXG5cXFxuICpcXG5cXFxuICogQHNlZSBjem1fcGhvbmdcXG5cXFxuICpcXG5cXFxuICogQGV4YW1wbGVcXG5cXFxuICogZmxvYXQgZGlmZnVzZUludGVuc2l0eSA9IGN6bV9nZXRMYW1iZXJ0RGlmZnVzZShsaWdodERpcmVjdGlvbkVDLCBub3JtYWxFQyk7XFxuXFxcbiAqIGZsb2F0IHNwZWN1bGFySW50ZW5zaXR5ID0gY3ptX2dldFNwZWN1bGFyKGxpZ2h0RGlyZWN0aW9uRUMsIHRvRXllRUMsIG5vcm1hbEVDLCAyMDApO1xcblxcXG4gKiB2ZWMzIGNvbG9yID0gKGRpZmZ1c2VDb2xvciAqIGRpZmZ1c2VJbnRlbnNpdHkpICsgKHNwZWN1bGFyQ29sb3IgKiBzcGVjdWxhckludGVuc2l0eSk7XFxuXFxcbiAqL1xcblxcXG5mbG9hdCBjem1fZ2V0U3BlY3VsYXIodmVjMyBsaWdodERpcmVjdGlvbkVDLCB2ZWMzIHRvRXllRUMsIHZlYzMgbm9ybWFsRUMsIGZsb2F0IHNoaW5pbmVzcylcXG5cXFxue1xcblxcXG4gICAgdmVjMyB0b1JlZmxlY3RlZExpZ2h0ID0gcmVmbGVjdCgtbGlnaHREaXJlY3Rpb25FQywgbm9ybWFsRUMpO1xcblxcXG4gICAgZmxvYXQgc3BlY3VsYXIgPSBtYXgoZG90KHRvUmVmbGVjdGVkTGlnaHQsIHRvRXllRUMpLCAwLjApO1xcblxcXG5cXG5cXFxuICAgIC8vIHBvdyBoYXMgdW5kZWZpbmVkIGJlaGF2aW9yIGlmIGJvdGggcGFyYW1ldGVycyA8PSAwLlxcblxcXG4gICAgLy8gUHJldmVudCB0aGlzIGJ5IG1ha2luZyBzdXJlIHNoaW5pbmVzcyBpcyBhdCBsZWFzdCBjem1fZXBzaWxvbjIuXFxuXFxcbiAgICByZXR1cm4gcG93KHNwZWN1bGFyLCBtYXgoc2hpbmluZXNzLCBjem1fZXBzaWxvbjIpKTtcXG5cXFxufVxcblxcXG5cIjtcbiIsIi8vVGhpcyBmaWxlIGlzIGF1dG9tYXRpY2FsbHkgcmVidWlsdCBieSB0aGUgQ2VzaXVtIGJ1aWxkIHByb2Nlc3MuXG5leHBvcnQgZGVmYXVsdCBcIi8qKlxcblxcXG4gKiBAcHJpdmF0ZVxcblxcXG4gKi9cXG5cXFxudmVjNCBjem1fZ2V0V2F0ZXJOb2lzZShzYW1wbGVyMkQgbm9ybWFsTWFwLCB2ZWMyIHV2LCBmbG9hdCB0aW1lLCBmbG9hdCBhbmdsZUluUmFkaWFucylcXG5cXFxue1xcblxcXG4gICAgZmxvYXQgY29zQW5nbGUgPSBjb3MoYW5nbGVJblJhZGlhbnMpO1xcblxcXG4gICAgZmxvYXQgc2luQW5nbGUgPSBzaW4oYW5nbGVJblJhZGlhbnMpO1xcblxcXG5cXG5cXFxuICAgIC8vIHRpbWUgZGVwZW5kZW50IHNhbXBsaW5nIGRpcmVjdGlvbnNcXG5cXFxuICAgIHZlYzIgczAgPSB2ZWMyKDEuMC8xNy4wLCAwLjApO1xcblxcXG4gICAgdmVjMiBzMSA9IHZlYzIoLTEuMC8yOS4wLCAwLjApO1xcblxcXG4gICAgdmVjMiBzMiA9IHZlYzIoMS4wLzEwMS4wLCAxLjAvNTkuMCk7XFxuXFxcbiAgICB2ZWMyIHMzID0gdmVjMigtMS4wLzEwOS4wLCAtMS4wLzU3LjApO1xcblxcXG5cXG5cXFxuICAgIC8vIHJvdGF0ZSBzYW1wbGluZyBkaXJlY3Rpb24gYnkgc3BlY2lmaWVkIGFuZ2xlXFxuXFxcbiAgICBzMCA9IHZlYzIoKGNvc0FuZ2xlICogczAueCkgLSAoc2luQW5nbGUgKiBzMC55KSwgKHNpbkFuZ2xlICogczAueCkgKyAoY29zQW5nbGUgKiBzMC55KSk7XFxuXFxcbiAgICBzMSA9IHZlYzIoKGNvc0FuZ2xlICogczEueCkgLSAoc2luQW5nbGUgKiBzMS55KSwgKHNpbkFuZ2xlICogczEueCkgKyAoY29zQW5nbGUgKiBzMS55KSk7XFxuXFxcbiAgICBzMiA9IHZlYzIoKGNvc0FuZ2xlICogczIueCkgLSAoc2luQW5nbGUgKiBzMi55KSwgKHNpbkFuZ2xlICogczIueCkgKyAoY29zQW5nbGUgKiBzMi55KSk7XFxuXFxcbiAgICBzMyA9IHZlYzIoKGNvc0FuZ2xlICogczMueCkgLSAoc2luQW5nbGUgKiBzMy55KSwgKHNpbkFuZ2xlICogczMueCkgKyAoY29zQW5nbGUgKiBzMy55KSk7XFxuXFxcblxcblxcXG4gICAgdmVjMiB1djAgPSAodXYvMTAzLjApICsgKHRpbWUgKiBzMCk7XFxuXFxcbiAgICB2ZWMyIHV2MSA9IHV2LzEwNy4wICsgKHRpbWUgKiBzMSkgKyB2ZWMyKDAuMjMpO1xcblxcXG4gICAgdmVjMiB1djIgPSB1di92ZWMyKDg5Ny4wLCA5ODMuMCkgKyAodGltZSAqIHMyKSArIHZlYzIoMC41MSk7XFxuXFxcbiAgICB2ZWMyIHV2MyA9IHV2L3ZlYzIoOTkxLjAsIDg3Ny4wKSArICh0aW1lICogczMpICsgdmVjMigwLjcxKTtcXG5cXFxuXFxuXFxcbiAgICB1djAgPSBmcmFjdCh1djApO1xcblxcXG4gICAgdXYxID0gZnJhY3QodXYxKTtcXG5cXFxuICAgIHV2MiA9IGZyYWN0KHV2Mik7XFxuXFxcbiAgICB1djMgPSBmcmFjdCh1djMpO1xcblxcXG4gICAgdmVjNCBub2lzZSA9ICh0ZXh0dXJlMkQobm9ybWFsTWFwLCB1djApKSArXFxuXFxcbiAgICAgICAgICAgICAgICAgKHRleHR1cmUyRChub3JtYWxNYXAsIHV2MSkpICtcXG5cXFxuICAgICAgICAgICAgICAgICAodGV4dHVyZTJEKG5vcm1hbE1hcCwgdXYyKSkgK1xcblxcXG4gICAgICAgICAgICAgICAgICh0ZXh0dXJlMkQobm9ybWFsTWFwLCB1djMpKTtcXG5cXFxuXFxuXFxcbiAgICAvLyBhdmVyYWdlIGFuZCBzY2FsZSB0byBiZXR3ZWVuIC0xIGFuZCAxXFxuXFxcbiAgICByZXR1cm4gKChub2lzZSAvIDQuMCkgLSAwLjUpICogMi4wO1xcblxcXG59XFxuXFxcblwiO1xuIiwiLy9UaGlzIGZpbGUgaXMgYXV0b21hdGljYWxseSByZWJ1aWx0IGJ5IHRoZSBDZXNpdW0gYnVpbGQgcHJvY2Vzcy5cbmV4cG9ydCBkZWZhdWx0IFwiLyoqXFxuXFxcbiAqIEFkanVzdHMgdGhlIGh1ZSBvZiBhIGNvbG9yLlxcblxcXG4gKiBcXG5cXFxuICogQG5hbWUgY3ptX2h1ZVxcblxcXG4gKiBAZ2xzbEZ1bmN0aW9uXFxuXFxcbiAqIFxcblxcXG4gKiBAcGFyYW0ge3ZlYzN9IHJnYiBUaGUgY29sb3IuXFxuXFxcbiAqIEBwYXJhbSB7ZmxvYXR9IGFkanVzdG1lbnQgVGhlIGFtb3VudCB0byBhZGp1c3QgdGhlIGh1ZSBvZiB0aGUgY29sb3IgaW4gcmFkaWFucy5cXG5cXFxuICpcXG5cXFxuICogQHJldHVybnMge2Zsb2F0fSBUaGUgY29sb3Igd2l0aCB0aGUgaHVlIGFkanVzdGVkLlxcblxcXG4gKlxcblxcXG4gKiBAZXhhbXBsZVxcblxcXG4gKiB2ZWMzIGFkanVzdEh1ZSA9IGN6bV9odWUoY29sb3IsIGN6bV9waSk7IC8vIFRoZSBzYW1lIGFzIGN6bV9odWUoY29sb3IsIC1jem1fcGkpXFxuXFxcbiAqL1xcblxcXG52ZWMzIGN6bV9odWUodmVjMyByZ2IsIGZsb2F0IGFkanVzdG1lbnQpXFxuXFxcbntcXG5cXFxuICAgIGNvbnN0IG1hdDMgdG9ZSVEgPSBtYXQzKDAuMjk5LCAgICAgMC41ODcsICAgICAwLjExNCxcXG5cXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDAuNTk1NzE2LCAtMC4yNzQ0NTMsIC0wLjMyMTI2MyxcXG5cXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDAuMjExNDU2LCAtMC41MjI1OTEsICAwLjMxMTEzNSk7XFxuXFxcbiAgICBjb25zdCBtYXQzIHRvUkdCID0gbWF0MygxLjAsICAwLjk1NjMsICAwLjYyMTAsXFxuXFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAxLjAsIC0wLjI3MjEsIC0wLjY0NzQsXFxuXFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAxLjAsIC0xLjEwNywgICAxLjcwNDYpO1xcblxcXG4gICAgXFxuXFxcbiAgICB2ZWMzIHlpcSA9IHRvWUlRICogcmdiO1xcblxcXG4gICAgZmxvYXQgaHVlID0gYXRhbih5aXEueiwgeWlxLnkpICsgYWRqdXN0bWVudDtcXG5cXFxuICAgIGZsb2F0IGNocm9tYSA9IHNxcnQoeWlxLnogKiB5aXEueiArIHlpcS55ICogeWlxLnkpO1xcblxcXG4gICAgXFxuXFxcbiAgICB2ZWMzIGNvbG9yID0gdmVjMyh5aXEueCwgY2hyb21hICogY29zKGh1ZSksIGNocm9tYSAqIHNpbihodWUpKTtcXG5cXFxuICAgIHJldHVybiB0b1JHQiAqIGNvbG9yO1xcblxcXG59XFxuXFxcblwiO1xuIiwiLy9UaGlzIGZpbGUgaXMgYXV0b21hdGljYWxseSByZWJ1aWx0IGJ5IHRoZSBDZXNpdW0gYnVpbGQgcHJvY2Vzcy5cbmV4cG9ydCBkZWZhdWx0IFwiLyoqXFxuXFxcbiAqIENvbnZlcnRzIGEgY29sb3IgaW4gbGluZWFyIHNwYWNlIHRvIFJHQiBzcGFjZS5cXG5cXFxuICpcXG5cXFxuICogQG5hbWUgY3ptX2ludmVyc2VHYW1tYVxcblxcXG4gKiBAZ2xzbEZ1bmN0aW9uXFxuXFxcbiAqXFxuXFxcbiAqIEBwYXJhbSB7dmVjM30gY29sb3IgVGhlIGNvbG9yIGluIGxpbmVhciBzcGFjZS5cXG5cXFxuICogQHJldHVybnMge3ZlYzN9IFRoZSBjb2xvciBpbiBSR0Igc3BhY2UuXFxuXFxcbiAqL1xcblxcXG52ZWMzIGN6bV9pbnZlcnNlR2FtbWEodmVjMyBjb2xvcikge1xcblxcXG4gICAgcmV0dXJuIHBvdyhjb2xvciwgdmVjMygxLjAgLyBjem1fZ2FtbWEpKTtcXG5cXFxufVxcblxcXG5cIjtcbiIsIi8vVGhpcyBmaWxlIGlzIGF1dG9tYXRpY2FsbHkgcmVidWlsdCBieSB0aGUgQ2VzaXVtIGJ1aWxkIHByb2Nlc3MuXG5leHBvcnQgZGVmYXVsdCBcIi8qKlxcblxcXG4gKiBEZXRlcm1pbmVzIGlmIGEgdGltZSBpbnRlcnZhbCBpcyBlbXB0eS5cXG5cXFxuICpcXG5cXFxuICogQG5hbWUgY3ptX2lzRW1wdHlcXG5cXFxuICogQGdsc2xGdW5jdGlvbiBcXG5cXFxuICogXFxuXFxcbiAqIEBwYXJhbSB7Y3ptX3JheVNlZ21lbnR9IGludGVydmFsIFRoZSBpbnRlcnZhbCB0byB0ZXN0LlxcblxcXG4gKiBcXG5cXFxuICogQHJldHVybnMge2Jvb2x9IDxjb2RlPnRydWU8L2NvZGU+IGlmIHRoZSB0aW1lIGludGVydmFsIGlzIGVtcHR5OyBvdGhlcndpc2UsIDxjb2RlPmZhbHNlPC9jb2RlPi5cXG5cXFxuICpcXG5cXFxuICogQGV4YW1wbGVcXG5cXFxuICogYm9vbCBiMCA9IGN6bV9pc0VtcHR5KGN6bV9lbXB0eVJheVNlZ21lbnQpOyAgICAgIC8vIHRydWVcXG5cXFxuICogYm9vbCBiMSA9IGN6bV9pc0VtcHR5KGN6bV9yYXlTZWdtZW50KDAuMCwgMS4wKSk7IC8vIGZhbHNlXFxuXFxcbiAqIGJvb2wgYjIgPSBjem1faXNFbXB0eShjem1fcmF5U2VnbWVudCgxLjAsIDEuMCkpOyAvLyBmYWxzZSwgY29udGFpbnMgMS4wLlxcblxcXG4gKi9cXG5cXFxuYm9vbCBjem1faXNFbXB0eShjem1fcmF5U2VnbWVudCBpbnRlcnZhbClcXG5cXFxue1xcblxcXG4gICAgcmV0dXJuIChpbnRlcnZhbC5zdG9wIDwgMC4wKTtcXG5cXFxufVxcblxcXG5cIjtcbiIsIi8vVGhpcyBmaWxlIGlzIGF1dG9tYXRpY2FsbHkgcmVidWlsdCBieSB0aGUgQ2VzaXVtIGJ1aWxkIHByb2Nlc3MuXG5leHBvcnQgZGVmYXVsdCBcIi8qKlxcblxcXG4gKiBEZXRlcm1pbmVzIGlmIGEgdGltZSBpbnRlcnZhbCBpcyBlbXB0eS5cXG5cXFxuICpcXG5cXFxuICogQG5hbWUgY3ptX2lzRnVsbFxcblxcXG4gKiBAZ2xzbEZ1bmN0aW9uIFxcblxcXG4gKiBcXG5cXFxuICogQHBhcmFtIHtjem1fcmF5U2VnbWVudH0gaW50ZXJ2YWwgVGhlIGludGVydmFsIHRvIHRlc3QuXFxuXFxcbiAqIFxcblxcXG4gKiBAcmV0dXJucyB7Ym9vbH0gPGNvZGU+dHJ1ZTwvY29kZT4gaWYgdGhlIHRpbWUgaW50ZXJ2YWwgaXMgZW1wdHk7IG90aGVyd2lzZSwgPGNvZGU+ZmFsc2U8L2NvZGU+LlxcblxcXG4gKlxcblxcXG4gKiBAZXhhbXBsZVxcblxcXG4gKiBib29sIGIwID0gY3ptX2lzRW1wdHkoY3ptX2VtcHR5UmF5U2VnbWVudCk7ICAgICAgLy8gdHJ1ZVxcblxcXG4gKiBib29sIGIxID0gY3ptX2lzRW1wdHkoY3ptX3JheVNlZ21lbnQoMC4wLCAxLjApKTsgLy8gZmFsc2VcXG5cXFxuICogYm9vbCBiMiA9IGN6bV9pc0VtcHR5KGN6bV9yYXlTZWdtZW50KDEuMCwgMS4wKSk7IC8vIGZhbHNlLCBjb250YWlucyAxLjAuXFxuXFxcbiAqL1xcblxcXG5ib29sIGN6bV9pc0Z1bGwoY3ptX3JheVNlZ21lbnQgaW50ZXJ2YWwpXFxuXFxcbntcXG5cXFxuICAgIHJldHVybiAoaW50ZXJ2YWwuc3RhcnQgPT0gMC4wICYmIGludGVydmFsLnN0b3AgPT0gY3ptX2luZmluaXR5KTtcXG5cXFxufVxcblxcXG5cIjtcbiIsIi8vVGhpcyBmaWxlIGlzIGF1dG9tYXRpY2FsbHkgcmVidWlsdCBieSB0aGUgQ2VzaXVtIGJ1aWxkIHByb2Nlc3MuXG5leHBvcnQgZGVmYXVsdCBcIi8qKlxcblxcXG4gKiBDb21wdXRlcyB0aGUgZnJhY3Rpb24gb2YgYSBXZWIgV2VyY2F0b3IgcmVjdGFuZ2xlIGF0IHdoaWNoIGEgZ2l2ZW4gZ2VvZGV0aWMgbGF0aXR1ZGUgaXMgbG9jYXRlZC5cXG5cXFxuICpcXG5cXFxuICogQG5hbWUgY3ptX2xhdGl0dWRlVG9XZWJNZXJjYXRvckZyYWN0aW9uXFxuXFxcbiAqIEBnbHNsRnVuY3Rpb25cXG5cXFxuICpcXG5cXFxuICogQHBhcmFtIHtmbG9hdH0gbGF0aXR1ZGUgVGhlIGdlb2RldGljIGxhdGl0dWRlLCBpbiByYWRpYW5zLlxcblxcXG4gKiBAcGFyYW0ge2Zsb2F0fSBzb3V0aE1lcmNhdG9yWSBUaGUgV2ViIE1lcmNhdG9yIGNvb3JkaW5hdGUgb2YgdGhlIHNvdXRoZXJuIGJvdW5kYXJ5IG9mIHRoZSByZWN0YW5nbGUuXFxuXFxcbiAqIEBwYXJhbSB7ZmxvYXR9IG9uZU92ZXJNZXJjYXRvckhlaWdodCBUaGUgdG90YWwgaGVpZ2h0IG9mIHRoZSByZWN0YW5nbGUgaW4gV2ViIE1lcmNhdG9yIGNvb3JkaW5hdGVzLlxcblxcXG4gKlxcblxcXG4gKiBAcmV0dXJucyB7ZmxvYXR9IFRoZSBmcmFjdGlvbiBvZiB0aGUgcmVjdGFuZ2xlIGF0IHdoaWNoIHRoZSBsYXRpdHVkZSBvY2N1cnMuICBJZiB0aGUgbGF0aXR1ZGUgaXMgdGhlIHNvdXRoZXJuXFxuXFxcbiAqICAgICAgICAgIGJvdW5kYXJ5IG9mIHRoZSByZWN0YW5nbGUsIHRoZSByZXR1cm4gdmFsdWUgd2lsbCBiZSB6ZXJvLiAgSWYgaXQgaXMgdGhlIG5vcnRoZXJuIGJvdW5kYXJ5LCB0aGUgcmV0dXJuXFxuXFxcbiAqICAgICAgICAgIHZhbHVlIHdpbGwgYmUgMS4wLiAgTGF0aXR1ZGVzIGluIGJldHdlZW4gYXJlIG1hcHBlZCBhY2NvcmRpbmcgdG8gdGhlIFdlYiBNZXJjYXRvciBwcm9qZWN0aW9uLlxcblxcXG4gKi8gXFxuXFxcbmZsb2F0IGN6bV9sYXRpdHVkZVRvV2ViTWVyY2F0b3JGcmFjdGlvbihmbG9hdCBsYXRpdHVkZSwgZmxvYXQgc291dGhNZXJjYXRvclksIGZsb2F0IG9uZU92ZXJNZXJjYXRvckhlaWdodClcXG5cXFxue1xcblxcXG4gICAgZmxvYXQgc2luTGF0aXR1ZGUgPSBzaW4obGF0aXR1ZGUpO1xcblxcXG4gICAgZmxvYXQgbWVyY2F0b3JZID0gMC41ICogbG9nKCgxLjAgKyBzaW5MYXRpdHVkZSkgLyAoMS4wIC0gc2luTGF0aXR1ZGUpKTtcXG5cXFxuICAgIFxcblxcXG4gICAgcmV0dXJuIChtZXJjYXRvclkgLSBzb3V0aE1lcmNhdG9yWSkgKiBvbmVPdmVyTWVyY2F0b3JIZWlnaHQ7XFxuXFxcbn1cXG5cXFxuXCI7XG4iLCIvL1RoaXMgZmlsZSBpcyBhdXRvbWF0aWNhbGx5IHJlYnVpbHQgYnkgdGhlIENlc2l1bSBidWlsZCBwcm9jZXNzLlxuZXhwb3J0IGRlZmF1bHQgXCIvKipcXG5cXFxuICogQ29tcHV0ZXMgZGlzdGFuY2UgZnJvbSBhbiBwb2ludCBpbiAyRCB0byBhIGxpbmUgaW4gMkQuXFxuXFxcbiAqXFxuXFxcbiAqIEBuYW1lIGN6bV9saW5lRGlzdGFuY2VcXG5cXFxuICogQGdsc2xGdW5jdGlvblxcblxcXG4gKlxcblxcXG4gKiBwYXJhbSB7dmVjMn0gcG9pbnQxIEEgcG9pbnQgYWxvbmcgdGhlIGxpbmUuXFxuXFxcbiAqIHBhcmFtIHt2ZWMyfSBwb2ludDIgQSBwb2ludCBhbG9uZyB0aGUgbGluZS5cXG5cXFxuICogcGFyYW0ge3ZlYzJ9IHBvaW50IEEgcG9pbnQgdGhhdCBtYXkgb3IgbWF5IG5vdCBiZSBvbiB0aGUgbGluZS5cXG5cXFxuICogcmV0dXJucyB7ZmxvYXR9IFRoZSBkaXN0YW5jZSBmcm9tIHRoZSBwb2ludCB0byB0aGUgbGluZS5cXG5cXFxuICovXFxuXFxcbmZsb2F0IGN6bV9saW5lRGlzdGFuY2UodmVjMiBwb2ludDEsIHZlYzIgcG9pbnQyLCB2ZWMyIHBvaW50KSB7XFxuXFxcbiAgICByZXR1cm4gYWJzKChwb2ludDIueSAtIHBvaW50MS55KSAqIHBvaW50LnggLSAocG9pbnQyLnggLSBwb2ludDEueCkgKiBwb2ludC55ICsgcG9pbnQyLnggKiBwb2ludDEueSAtIHBvaW50Mi55ICogcG9pbnQxLngpIC8gZGlzdGFuY2UocG9pbnQyLCBwb2ludDEpO1xcblxcXG59XFxuXFxcblwiO1xuIiwiLy9UaGlzIGZpbGUgaXMgYXV0b21hdGljYWxseSByZWJ1aWx0IGJ5IHRoZSBDZXNpdW0gYnVpbGQgcHJvY2Vzcy5cbmV4cG9ydCBkZWZhdWx0IFwiLyoqXFxuXFxcbiAqIENvbXB1dGVzIHRoZSBsdW1pbmFuY2Ugb2YgYSBjb2xvci4gXFxuXFxcbiAqXFxuXFxcbiAqIEBuYW1lIGN6bV9sdW1pbmFuY2VcXG5cXFxuICogQGdsc2xGdW5jdGlvblxcblxcXG4gKlxcblxcXG4gKiBAcGFyYW0ge3ZlYzN9IHJnYiBUaGUgY29sb3IuXFxuXFxcbiAqIFxcblxcXG4gKiBAcmV0dXJucyB7ZmxvYXR9IFRoZSBsdW1pbmFuY2UuXFxuXFxcbiAqXFxuXFxcbiAqIEBleGFtcGxlXFxuXFxcbiAqIGZsb2F0IGxpZ2h0ID0gY3ptX2x1bWluYW5jZSh2ZWMzKDAuMCkpOyAvLyAwLjBcXG5cXFxuICogZmxvYXQgZGFyayA9IGN6bV9sdW1pbmFuY2UodmVjMygxLjApKTsgIC8vIH4xLjAgXFxuXFxcbiAqL1xcblxcXG5mbG9hdCBjem1fbHVtaW5hbmNlKHZlYzMgcmdiKVxcblxcXG57XFxuXFxcbiAgICAvLyBBbGdvcml0aG0gZnJvbSBDaGFwdGVyIDEwIG9mIEdyYXBoaWNzIFNoYWRlcnMuXFxuXFxcbiAgICBjb25zdCB2ZWMzIFcgPSB2ZWMzKDAuMjEyNSwgMC43MTU0LCAwLjA3MjEpO1xcblxcXG4gICAgcmV0dXJuIGRvdChyZ2IsIFcpO1xcblxcXG59XFxuXFxcblwiO1xuIiwiLy9UaGlzIGZpbGUgaXMgYXV0b21hdGljYWxseSByZWJ1aWx0IGJ5IHRoZSBDZXNpdW0gYnVpbGQgcHJvY2Vzcy5cbmV4cG9ydCBkZWZhdWx0IFwiLyoqXFxuXFxcbiAqIENvbXB1dGVzIHRoZSBzaXplIG9mIGEgcGl4ZWwgaW4gbWV0ZXJzIGF0IGEgZGlzdGFuY2UgZnJvbSB0aGUgZXllLlxcblxcXG4gKiA8cD5cXG5cXFxuICogVXNlIHRoaXMgdmVyc2lvbiB3aGVuIHBhc3NpbmcgaW4gYSBjdXN0b20gcGl4ZWwgcmF0aW8uIEZvciBleGFtcGxlLCBwYXNzaW5nIGluIDEuMCB3aWxsIHJldHVybiBtZXRlcnMgcGVyIG5hdGl2ZSBkZXZpY2UgcGl4ZWwuXFxuXFxcbiAqIDwvcD5cXG5cXFxuICogQG5hbWUgY3ptX21ldGVyc1BlclBpeGVsXFxuXFxcbiAqIEBnbHNsRnVuY3Rpb25cXG5cXFxuICpcXG5cXFxuICogQHBhcmFtIHt2ZWMzfSBwb3NpdGlvbkVDIFRoZSBwb3NpdGlvbiB0byBnZXQgdGhlIG1ldGVycyBwZXIgcGl4ZWwgaW4gZXllIGNvb3JkaW5hdGVzLlxcblxcXG4gKiBAcGFyYW0ge2Zsb2F0fSBwaXhlbFJhdGlvIFRoZSBzY2FsaW5nIGZhY3RvciBmcm9tIHBpeGVsIHNwYWNlIHRvIGNvb3JkaW5hdGUgc3BhY2VcXG5cXFxuICpcXG5cXFxuICogQHJldHVybnMge2Zsb2F0fSBUaGUgbWV0ZXJzIHBlciBwaXhlbCBhdCBwb3NpdGlvbkVDLlxcblxcXG4gKi9cXG5cXFxuZmxvYXQgY3ptX21ldGVyc1BlclBpeGVsKHZlYzQgcG9zaXRpb25FQywgZmxvYXQgcGl4ZWxSYXRpbylcXG5cXFxue1xcblxcXG4gICAgZmxvYXQgd2lkdGggPSBjem1fdmlld3BvcnQuejtcXG5cXFxuICAgIGZsb2F0IGhlaWdodCA9IGN6bV92aWV3cG9ydC53O1xcblxcXG4gICAgZmxvYXQgcGl4ZWxXaWR0aDtcXG5cXFxuICAgIGZsb2F0IHBpeGVsSGVpZ2h0O1xcblxcXG5cXG5cXFxuICAgIGZsb2F0IHRvcCA9IGN6bV9mcnVzdHVtUGxhbmVzLng7XFxuXFxcbiAgICBmbG9hdCBib3R0b20gPSBjem1fZnJ1c3R1bVBsYW5lcy55O1xcblxcXG4gICAgZmxvYXQgbGVmdCA9IGN6bV9mcnVzdHVtUGxhbmVzLno7XFxuXFxcbiAgICBmbG9hdCByaWdodCA9IGN6bV9mcnVzdHVtUGxhbmVzLnc7XFxuXFxcblxcblxcXG4gICAgaWYgKGN6bV9zY2VuZU1vZGUgPT0gY3ptX3NjZW5lTW9kZTJEIHx8IGN6bV9vcnRob2dyYXBoaWNJbjNEID09IDEuMClcXG5cXFxuICAgIHtcXG5cXFxuICAgICAgICBmbG9hdCBmcnVzdHVtV2lkdGggPSByaWdodCAtIGxlZnQ7XFxuXFxcbiAgICAgICAgZmxvYXQgZnJ1c3R1bUhlaWdodCA9IHRvcCAtIGJvdHRvbTtcXG5cXFxuICAgICAgICBwaXhlbFdpZHRoID0gZnJ1c3R1bVdpZHRoIC8gd2lkdGg7XFxuXFxcbiAgICAgICAgcGl4ZWxIZWlnaHQgPSBmcnVzdHVtSGVpZ2h0IC8gaGVpZ2h0O1xcblxcXG4gICAgfVxcblxcXG4gICAgZWxzZVxcblxcXG4gICAge1xcblxcXG4gICAgICAgIGZsb2F0IGRpc3RhbmNlVG9QaXhlbCA9IC1wb3NpdGlvbkVDLno7XFxuXFxcbiAgICAgICAgZmxvYXQgaW52ZXJzZU5lYXIgPSAxLjAgLyBjem1fY3VycmVudEZydXN0dW0ueDtcXG5cXFxuICAgICAgICBmbG9hdCB0YW5UaGV0YSA9IHRvcCAqIGludmVyc2VOZWFyO1xcblxcXG4gICAgICAgIHBpeGVsSGVpZ2h0ID0gMi4wICogZGlzdGFuY2VUb1BpeGVsICogdGFuVGhldGEgLyBoZWlnaHQ7XFxuXFxcbiAgICAgICAgdGFuVGhldGEgPSByaWdodCAqIGludmVyc2VOZWFyO1xcblxcXG4gICAgICAgIHBpeGVsV2lkdGggPSAyLjAgKiBkaXN0YW5jZVRvUGl4ZWwgKiB0YW5UaGV0YSAvIHdpZHRoO1xcblxcXG4gICAgfVxcblxcXG5cXG5cXFxuICAgIHJldHVybiBtYXgocGl4ZWxXaWR0aCwgcGl4ZWxIZWlnaHQpICogcGl4ZWxSYXRpbztcXG5cXFxufVxcblxcXG5cXG5cXFxuLyoqXFxuXFxcbiAqIENvbXB1dGVzIHRoZSBzaXplIG9mIGEgcGl4ZWwgaW4gbWV0ZXJzIGF0IGEgZGlzdGFuY2UgZnJvbSB0aGUgZXllLlxcblxcXG4gKiA8cD5cXG5cXFxuICogVXNlIHRoaXMgdmVyc2lvbiB3aGVuIHNjYWxpbmcgYnkgcGl4ZWwgcmF0aW8uXFxuXFxcbiAqIDwvcD5cXG5cXFxuICogQG5hbWUgY3ptX21ldGVyc1BlclBpeGVsXFxuXFxcbiAqIEBnbHNsRnVuY3Rpb25cXG5cXFxuICpcXG5cXFxuICogQHBhcmFtIHt2ZWMzfSBwb3NpdGlvbkVDIFRoZSBwb3NpdGlvbiB0byBnZXQgdGhlIG1ldGVycyBwZXIgcGl4ZWwgaW4gZXllIGNvb3JkaW5hdGVzLlxcblxcXG4gKlxcblxcXG4gKiBAcmV0dXJucyB7ZmxvYXR9IFRoZSBtZXRlcnMgcGVyIHBpeGVsIGF0IHBvc2l0aW9uRUMuXFxuXFxcbiAqL1xcblxcXG5mbG9hdCBjem1fbWV0ZXJzUGVyUGl4ZWwodmVjNCBwb3NpdGlvbkVDKVxcblxcXG57XFxuXFxcbiAgICByZXR1cm4gY3ptX21ldGVyc1BlclBpeGVsKHBvc2l0aW9uRUMsIGN6bV9waXhlbFJhdGlvKTtcXG5cXFxufVxcblxcXG5cIjtcbiIsIi8vVGhpcyBmaWxlIGlzIGF1dG9tYXRpY2FsbHkgcmVidWlsdCBieSB0aGUgQ2VzaXVtIGJ1aWxkIHByb2Nlc3MuXG5leHBvcnQgZGVmYXVsdCBcIi8qKlxcblxcXG4gKiBUcmFuc2Zvcm1zIGEgcG9zaXRpb24gZnJvbSBtb2RlbCB0byB3aW5kb3cgY29vcmRpbmF0ZXMuICBUaGUgdHJhbnNmb3JtYXRpb25cXG5cXFxuICogZnJvbSBtb2RlbCB0byBjbGlwIGNvb3JkaW5hdGVzIGlzIGRvbmUgdXNpbmcge0BsaW5rIGN6bV9tb2RlbFZpZXdQcm9qZWN0aW9ufS5cXG5cXFxuICogVGhlIHRyYW5zZm9ybSBmcm9tIG5vcm1hbGl6ZWQgZGV2aWNlIGNvb3JkaW5hdGVzIHRvIHdpbmRvdyBjb29yZGluYXRlcyBpc1xcblxcXG4gKiBkb25lIHVzaW5nIHtAbGluayBjem1fdmlld3BvcnRUcmFuc2Zvcm1hdGlvbn0sIHdoaWNoIGFzc3VtZXMgYSBkZXB0aCByYW5nZVxcblxcXG4gKiBvZiA8Y29kZT5uZWFyID0gMDwvY29kZT4gYW5kIDxjb2RlPmZhciA9IDE8L2NvZGU+LlxcblxcXG4gKiA8YnIgLz48YnIgLz5cXG5cXFxuICogVGhpcyB0cmFuc2Zvcm0gaXMgdXNlZnVsIHdoZW4gdGhlcmUgaXMgYSBuZWVkIHRvIG1hbmlwdWxhdGUgd2luZG93IGNvb3JkaW5hdGVzXFxuXFxcbiAqIGluIGEgdmVydGV4IHNoYWRlciBhcyBkb25lIGJ5IHtAbGluayBCaWxsYm9hcmRDb2xsZWN0aW9ufS5cXG5cXFxuICogPGJyIC8+PGJyIC8+XFxuXFxcbiAqIFRoaXMgZnVuY3Rpb24gc2hvdWxkIG5vdCBiZSBjb25mdXNlZCB3aXRoIHtAbGluayBjem1fdmlld3BvcnRPcnRob2dyYXBoaWN9LFxcblxcXG4gKiB3aGljaCBpcyBhbiBvcnRob2dyYXBoaWMgcHJvamVjdGlvbiBtYXRyaXggdGhhdCB0cmFuc2Zvcm1zIGZyb20gd2luZG93IFxcblxcXG4gKiBjb29yZGluYXRlcyB0byBjbGlwIGNvb3JkaW5hdGVzLlxcblxcXG4gKlxcblxcXG4gKiBAbmFtZSBjem1fbW9kZWxUb1dpbmRvd0Nvb3JkaW5hdGVzXFxuXFxcbiAqIEBnbHNsRnVuY3Rpb25cXG5cXFxuICpcXG5cXFxuICogQHBhcmFtIHt2ZWM0fSBwb3NpdGlvbiBUaGUgcG9zaXRpb24gaW4gbW9kZWwgY29vcmRpbmF0ZXMgdG8gdHJhbnNmb3JtLlxcblxcXG4gKlxcblxcXG4gKiBAcmV0dXJucyB7dmVjNH0gVGhlIHRyYW5zZm9ybWVkIHBvc2l0aW9uIGluIHdpbmRvdyBjb29yZGluYXRlcy5cXG5cXFxuICpcXG5cXFxuICogQHNlZSBjem1fZXllVG9XaW5kb3dDb29yZGluYXRlc1xcblxcXG4gKiBAc2VlIGN6bV9tb2RlbFZpZXdQcm9qZWN0aW9uXFxuXFxcbiAqIEBzZWUgY3ptX3ZpZXdwb3J0VHJhbnNmb3JtYXRpb25cXG5cXFxuICogQHNlZSBjem1fdmlld3BvcnRPcnRob2dyYXBoaWNcXG5cXFxuICogQHNlZSBCaWxsYm9hcmRDb2xsZWN0aW9uXFxuXFxcbiAqXFxuXFxcbiAqIEBleGFtcGxlXFxuXFxcbiAqIHZlYzQgcG9zaXRpb25XQyA9IGN6bV9tb2RlbFRvV2luZG93Q29vcmRpbmF0ZXMocG9zaXRpb25NQyk7XFxuXFxcbiAqL1xcblxcXG52ZWM0IGN6bV9tb2RlbFRvV2luZG93Q29vcmRpbmF0ZXModmVjNCBwb3NpdGlvbilcXG5cXFxue1xcblxcXG4gICAgdmVjNCBxID0gY3ptX21vZGVsVmlld1Byb2plY3Rpb24gKiBwb3NpdGlvbjsgICAgICAgICAgICAgICAgLy8gY2xpcCBjb29yZGluYXRlc1xcblxcXG4gICAgcS54eXogLz0gcS53OyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIG5vcm1hbGl6ZWQgZGV2aWNlIGNvb3JkaW5hdGVzXFxuXFxcbiAgICBxLnh5eiA9IChjem1fdmlld3BvcnRUcmFuc2Zvcm1hdGlvbiAqIHZlYzQocS54eXosIDEuMCkpLnh5ejsgLy8gd2luZG93IGNvb3JkaW5hdGVzXFxuXFxcbiAgICByZXR1cm4gcTtcXG5cXFxufVxcblxcXG5cIjtcbiIsIi8vVGhpcyBmaWxlIGlzIGF1dG9tYXRpY2FsbHkgcmVidWlsdCBieSB0aGUgQ2VzaXVtIGJ1aWxkIHByb2Nlc3MuXG5leHBvcnQgZGVmYXVsdCBcIi8qKlxcblxcXG4gKiBET0NfVEJBXFxuXFxcbiAqXFxuXFxcbiAqIEBuYW1lIGN6bV9tdWx0aXBseVdpdGhDb2xvckJhbGFuY2VcXG5cXFxuICogQGdsc2xGdW5jdGlvblxcblxcXG4gKi9cXG5cXFxudmVjMyBjem1fbXVsdGlwbHlXaXRoQ29sb3JCYWxhbmNlKHZlYzMgbGVmdCwgdmVjMyByaWdodClcXG5cXFxue1xcblxcXG4gICAgLy8gQWxnb3JpdGhtIGZyb20gQ2hhcHRlciAxMCBvZiBHcmFwaGljcyBTaGFkZXJzLlxcblxcXG4gICAgY29uc3QgdmVjMyBXID0gdmVjMygwLjIxMjUsIDAuNzE1NCwgMC4wNzIxKTtcXG5cXFxuICAgIFxcblxcXG4gICAgdmVjMyB0YXJnZXQgPSBsZWZ0ICogcmlnaHQ7XFxuXFxcbiAgICBmbG9hdCBsZWZ0THVtaW5hbmNlID0gZG90KGxlZnQsIFcpO1xcblxcXG4gICAgZmxvYXQgcmlnaHRMdW1pbmFuY2UgPSBkb3QocmlnaHQsIFcpO1xcblxcXG4gICAgZmxvYXQgdGFyZ2V0THVtaW5hbmNlID0gZG90KHRhcmdldCwgVyk7XFxuXFxcbiAgICBcXG5cXFxuICAgIHJldHVybiAoKGxlZnRMdW1pbmFuY2UgKyByaWdodEx1bWluYW5jZSkgLyAoMi4wICogdGFyZ2V0THVtaW5hbmNlKSkgKiB0YXJnZXQ7XFxuXFxcbn1cXG5cXFxuXCI7XG4iLCIvL1RoaXMgZmlsZSBpcyBhdXRvbWF0aWNhbGx5IHJlYnVpbHQgYnkgdGhlIENlc2l1bSBidWlsZCBwcm9jZXNzLlxuZXhwb3J0IGRlZmF1bHQgXCIvKipcXG5cXFxuICogQ29tcHV0ZXMgYSB2YWx1ZSB0aGF0IHNjYWxlcyB3aXRoIGRpc3RhbmNlLiAgVGhlIHNjYWxpbmcgaXMgY2xhbXBlZCBhdCB0aGUgbmVhciBhbmRcXG5cXFxuICogZmFyIGRpc3RhbmNlcywgYW5kIGRvZXMgbm90IGV4dHJhcG9sYXRlLiAgVGhpcyBmdW5jdGlvbiB3b3JrcyB3aXRoIHRoZVxcblxcXG4gKiB7QGxpbmsgTmVhckZhclNjYWxhcn0gSmF2YVNjcmlwdCBjbGFzcy5cXG5cXFxuICpcXG5cXFxuICogQG5hbWUgY3ptX25lYXJGYXJTY2FsYXJcXG5cXFxuICogQGdsc2xGdW5jdGlvblxcblxcXG4gKlxcblxcXG4gKiBAcGFyYW0ge3ZlYzR9IG5lYXJGYXJTY2FsYXIgQSB2ZWN0b3Igd2l0aCA0IGNvbXBvbmVudHM6IE5lYXIgZGlzdGFuY2UgKHgpLCBOZWFyIHZhbHVlICh5KSwgRmFyIGRpc3RhbmNlICh6KSwgRmFyIHZhbHVlICh3KS5cXG5cXFxuICogQHBhcmFtIHtmbG9hdH0gY2FtZXJhRGlzdFNxIFRoZSBzcXVhcmUgb2YgdGhlIGN1cnJlbnQgZGlzdGFuY2UgZnJvbSB0aGUgY2FtZXJhLlxcblxcXG4gKlxcblxcXG4gKiBAcmV0dXJucyB7ZmxvYXR9IFRoZSB2YWx1ZSBhdCB0aGlzIGRpc3RhbmNlLlxcblxcXG4gKi9cXG5cXFxuZmxvYXQgY3ptX25lYXJGYXJTY2FsYXIodmVjNCBuZWFyRmFyU2NhbGFyLCBmbG9hdCBjYW1lcmFEaXN0U3EpXFxuXFxcbntcXG5cXFxuICAgIGZsb2F0IHZhbHVlQXRNaW4gPSBuZWFyRmFyU2NhbGFyLnk7XFxuXFxcbiAgICBmbG9hdCB2YWx1ZUF0TWF4ID0gbmVhckZhclNjYWxhci53O1xcblxcXG4gICAgZmxvYXQgbmVhckRpc3RhbmNlU3EgPSBuZWFyRmFyU2NhbGFyLnggKiBuZWFyRmFyU2NhbGFyLng7XFxuXFxcbiAgICBmbG9hdCBmYXJEaXN0YW5jZVNxID0gbmVhckZhclNjYWxhci56ICogbmVhckZhclNjYWxhci56O1xcblxcXG5cXG5cXFxuICAgIGZsb2F0IHQgPSAoY2FtZXJhRGlzdFNxIC0gbmVhckRpc3RhbmNlU3EpIC8gKGZhckRpc3RhbmNlU3EgLSBuZWFyRGlzdGFuY2VTcSk7XFxuXFxcblxcblxcXG4gICAgdCA9IHBvdyhjbGFtcCh0LCAwLjAsIDEuMCksIDAuMik7XFxuXFxcblxcblxcXG4gICAgcmV0dXJuIG1peCh2YWx1ZUF0TWluLCB2YWx1ZUF0TWF4LCB0KTtcXG5cXFxufVxcblxcXG5cIjtcbiIsIi8vVGhpcyBmaWxlIGlzIGF1dG9tYXRpY2FsbHkgcmVidWlsdCBieSB0aGUgQ2VzaXVtIGJ1aWxkIHByb2Nlc3MuXG5leHBvcnQgZGVmYXVsdCBcIiAvKipcXG5cXFxuICAqIERlY29kZXMgYSB1bml0LWxlbmd0aCB2ZWN0b3IgaW4gJ29jdCcgZW5jb2RpbmcgdG8gYSBub3JtYWxpemVkIDMtY29tcG9uZW50IENhcnRlc2lhbiB2ZWN0b3IuXFxuXFxcbiAgKiBUaGUgJ29jdCcgZW5jb2RpbmcgaXMgZGVzY3JpYmVkIGluIFxcXCJBIFN1cnZleSBvZiBFZmZpY2llbnQgUmVwcmVzZW50YXRpb25zIG9mIEluZGVwZW5kZW50IFVuaXQgVmVjdG9yc1xcXCIsXFxuXFxcbiAgKiBDaWdvbGxlIGV0IGFsIDIwMTQ6IGh0dHA6Ly9qY2d0Lm9yZy9wdWJsaXNoZWQvMDAwMy8wMi8wMS9cXG5cXFxuICAqXFxuXFxcbiAgKiBAbmFtZSBjem1fb2N0RGVjb2RlXFxuXFxcbiAgKiBAcGFyYW0ge3ZlYzJ9IGVuY29kZWQgVGhlIG9jdC1lbmNvZGVkLCB1bml0LWxlbmd0aCB2ZWN0b3JcXG5cXFxuICAqIEBwYXJhbSB7ZmxvYXR9IHJhbmdlIFRoZSBtYXhpbXVtIHZhbHVlIG9mIHRoZSBTTk9STSByYW5nZS4gVGhlIGVuY29kZWQgdmVjdG9yIGlzIHN0b3JlZCBpbiBsb2cyKHJhbmdlTWF4KzEpIGJpdHMuXFxuXFxcbiAgKiBAcmV0dXJucyB7dmVjM30gVGhlIGRlY29kZWQgYW5kIG5vcm1hbGl6ZWQgdmVjdG9yXFxuXFxcbiAgKi9cXG5cXFxuICB2ZWMzIGN6bV9vY3REZWNvZGUodmVjMiBlbmNvZGVkLCBmbG9hdCByYW5nZSlcXG5cXFxuICB7XFxuXFxcbiAgICAgIGlmIChlbmNvZGVkLnggPT0gMC4wICYmIGVuY29kZWQueSA9PSAwLjApIHtcXG5cXFxuICAgICAgICAgIHJldHVybiB2ZWMzKDAuMCwgMC4wLCAwLjApO1xcblxcXG4gICAgICB9XFxuXFxcblxcblxcXG4gICAgIGVuY29kZWQgPSBlbmNvZGVkIC8gcmFuZ2UgKiAyLjAgLSAxLjA7XFxuXFxcbiAgICAgdmVjMyB2ID0gdmVjMyhlbmNvZGVkLngsIGVuY29kZWQueSwgMS4wIC0gYWJzKGVuY29kZWQueCkgLSBhYnMoZW5jb2RlZC55KSk7XFxuXFxcbiAgICAgaWYgKHYueiA8IDAuMClcXG5cXFxuICAgICB7XFxuXFxcbiAgICAgICAgIHYueHkgPSAoMS4wIC0gYWJzKHYueXgpKSAqIGN6bV9zaWduTm90WmVybyh2Lnh5KTtcXG5cXFxuICAgICB9XFxuXFxcblxcblxcXG4gICAgIHJldHVybiBub3JtYWxpemUodik7XFxuXFxcbiAgfVxcblxcXG5cXG5cXFxuLyoqXFxuXFxcbiAqIERlY29kZXMgYSB1bml0LWxlbmd0aCB2ZWN0b3IgaW4gJ29jdCcgZW5jb2RpbmcgdG8gYSBub3JtYWxpemVkIDMtY29tcG9uZW50IENhcnRlc2lhbiB2ZWN0b3IuXFxuXFxcbiAqIFRoZSAnb2N0JyBlbmNvZGluZyBpcyBkZXNjcmliZWQgaW4gXFxcIkEgU3VydmV5IG9mIEVmZmljaWVudCBSZXByZXNlbnRhdGlvbnMgb2YgSW5kZXBlbmRlbnQgVW5pdCBWZWN0b3JzXFxcIixcXG5cXFxuICogQ2lnb2xsZSBldCBhbCAyMDE0OiBodHRwOi8vamNndC5vcmcvcHVibGlzaGVkLzAwMDMvMDIvMDEvXFxuXFxcbiAqXFxuXFxcbiAqIEBuYW1lIGN6bV9vY3REZWNvZGVcXG5cXFxuICogQHBhcmFtIHt2ZWMyfSBlbmNvZGVkIFRoZSBvY3QtZW5jb2RlZCwgdW5pdC1sZW5ndGggdmVjdG9yXFxuXFxcbiAqIEByZXR1cm5zIHt2ZWMzfSBUaGUgZGVjb2RlZCBhbmQgbm9ybWFsaXplZCB2ZWN0b3JcXG5cXFxuICovXFxuXFxcbiB2ZWMzIGN6bV9vY3REZWNvZGUodmVjMiBlbmNvZGVkKVxcblxcXG4ge1xcblxcXG4gICAgcmV0dXJuIGN6bV9vY3REZWNvZGUoZW5jb2RlZCwgMjU1LjApO1xcblxcXG4gfVxcblxcXG5cXG5cXFxuIC8qKlxcblxcXG4gKiBEZWNvZGVzIGEgdW5pdC1sZW5ndGggdmVjdG9yIGluICdvY3QnIGVuY29kaW5nIHBhY2tlZCBpbnRvIGEgZmxvYXRpbmctcG9pbnQgbnVtYmVyIHRvIGEgbm9ybWFsaXplZCAzLWNvbXBvbmVudCBDYXJ0ZXNpYW4gdmVjdG9yLlxcblxcXG4gKiBUaGUgJ29jdCcgZW5jb2RpbmcgaXMgZGVzY3JpYmVkIGluIFxcXCJBIFN1cnZleSBvZiBFZmZpY2llbnQgUmVwcmVzZW50YXRpb25zIG9mIEluZGVwZW5kZW50IFVuaXQgVmVjdG9yc1xcXCIsXFxuXFxcbiAqIENpZ29sbGUgZXQgYWwgMjAxNDogaHR0cDovL2pjZ3Qub3JnL3B1Ymxpc2hlZC8wMDAzLzAyLzAxL1xcblxcXG4gKlxcblxcXG4gKiBAbmFtZSBjem1fb2N0RGVjb2RlXFxuXFxcbiAqIEBwYXJhbSB7ZmxvYXR9IGVuY29kZWQgVGhlIG9jdC1lbmNvZGVkLCB1bml0LWxlbmd0aCB2ZWN0b3JcXG5cXFxuICogQHJldHVybnMge3ZlYzN9IFRoZSBkZWNvZGVkIGFuZCBub3JtYWxpemVkIHZlY3RvclxcblxcXG4gKi9cXG5cXFxuIHZlYzMgY3ptX29jdERlY29kZShmbG9hdCBlbmNvZGVkKVxcblxcXG4ge1xcblxcXG4gICAgZmxvYXQgdGVtcCA9IGVuY29kZWQgLyAyNTYuMDtcXG5cXFxuICAgIGZsb2F0IHggPSBmbG9vcih0ZW1wKTtcXG5cXFxuICAgIGZsb2F0IHkgPSAodGVtcCAtIHgpICogMjU2LjA7XFxuXFxcbiAgICByZXR1cm4gY3ptX29jdERlY29kZSh2ZWMyKHgsIHkpKTtcXG5cXFxuIH1cXG5cXFxuXFxuXFxcbi8qKlxcblxcXG4gKiBEZWNvZGVzIHRocmVlIHVuaXQtbGVuZ3RoIHZlY3RvcnMgaW4gJ29jdCcgZW5jb2RpbmcgcGFja2VkIGludG8gdHdvIGZsb2F0aW5nLXBvaW50IG51bWJlcnMgdG8gbm9ybWFsaXplZCAzLWNvbXBvbmVudCBDYXJ0ZXNpYW4gdmVjdG9ycy5cXG5cXFxuICogVGhlICdvY3QnIGVuY29kaW5nIGlzIGRlc2NyaWJlZCBpbiBcXFwiQSBTdXJ2ZXkgb2YgRWZmaWNpZW50IFJlcHJlc2VudGF0aW9ucyBvZiBJbmRlcGVuZGVudCBVbml0IFZlY3RvcnNcXFwiLFxcblxcXG4gKiBDaWdvbGxlIGV0IGFsIDIwMTQ6IGh0dHA6Ly9qY2d0Lm9yZy9wdWJsaXNoZWQvMDAwMy8wMi8wMS9cXG5cXFxuICpcXG5cXFxuICogQG5hbWUgY3ptX29jdERlY29kZVxcblxcXG4gKiBAcGFyYW0ge3ZlYzJ9IGVuY29kZWQgVGhlIHBhY2tlZCBvY3QtZW5jb2RlZCwgdW5pdC1sZW5ndGggdmVjdG9ycy5cXG5cXFxuICogQHBhcmFtIHt2ZWMzfSB2ZWN0b3IxIE9uZSBkZWNvZGVkIGFuZCBub3JtYWxpemVkIHZlY3Rvci5cXG5cXFxuICogQHBhcmFtIHt2ZWMzfSB2ZWN0b3IyIE9uZSBkZWNvZGVkIGFuZCBub3JtYWxpemVkIHZlY3Rvci5cXG5cXFxuICogQHBhcmFtIHt2ZWMzfSB2ZWN0b3IzIE9uZSBkZWNvZGVkIGFuZCBub3JtYWxpemVkIHZlY3Rvci5cXG5cXFxuICovXFxuXFxcbiAgdm9pZCBjem1fb2N0RGVjb2RlKHZlYzIgZW5jb2RlZCwgb3V0IHZlYzMgdmVjdG9yMSwgb3V0IHZlYzMgdmVjdG9yMiwgb3V0IHZlYzMgdmVjdG9yMylcXG5cXFxuIHtcXG5cXFxuICAgIGZsb2F0IHRlbXAgPSBlbmNvZGVkLnggLyA2NTUzNi4wO1xcblxcXG4gICAgZmxvYXQgeCA9IGZsb29yKHRlbXApO1xcblxcXG4gICAgZmxvYXQgZW5jb2RlZEZsb2F0MSA9ICh0ZW1wIC0geCkgKiA2NTUzNi4wO1xcblxcXG5cXG5cXFxuICAgIHRlbXAgPSBlbmNvZGVkLnkgLyA2NTUzNi4wO1xcblxcXG4gICAgZmxvYXQgeSA9IGZsb29yKHRlbXApO1xcblxcXG4gICAgZmxvYXQgZW5jb2RlZEZsb2F0MiA9ICh0ZW1wIC0geSkgKiA2NTUzNi4wO1xcblxcXG5cXG5cXFxuICAgIHZlY3RvcjEgPSBjem1fb2N0RGVjb2RlKGVuY29kZWRGbG9hdDEpO1xcblxcXG4gICAgdmVjdG9yMiA9IGN6bV9vY3REZWNvZGUoZW5jb2RlZEZsb2F0Mik7XFxuXFxcbiAgICB2ZWN0b3IzID0gY3ptX29jdERlY29kZSh2ZWMyKHgsIHkpKTtcXG5cXFxuIH1cXG5cXFxuXFxuXFxcblwiO1xuIiwiLy9UaGlzIGZpbGUgaXMgYXV0b21hdGljYWxseSByZWJ1aWx0IGJ5IHRoZSBDZXNpdW0gYnVpbGQgcHJvY2Vzcy5cbmV4cG9ydCBkZWZhdWx0IFwiLyoqXFxuXFxcbiAqIFBhY2tzIGEgZGVwdGggdmFsdWUgaW50byBhIHZlYzMgdGhhdCBjYW4gYmUgcmVwcmVzZW50ZWQgYnkgdW5zaWduZWQgYnl0ZXMuXFxuXFxcbiAqXFxuXFxcbiAqIEBuYW1lIGN6bV9wYWNrRGVwdGhcXG5cXFxuICogQGdsc2xGdW5jdGlvblxcblxcXG4gKlxcblxcXG4gKiBAcGFyYW0ge2Zsb2F0fSBkZXB0aCBUaGUgZmxvYXRpbmctcG9pbnQgZGVwdGguXFxuXFxcbiAqIEByZXR1cm5zIHt2ZWMzfSBUaGUgcGFja2VkIGRlcHRoLlxcblxcXG4gKi9cXG5cXFxudmVjNCBjem1fcGFja0RlcHRoKGZsb2F0IGRlcHRoKVxcblxcXG57XFxuXFxcbiAgICAvLyBTZWUgQXJhcyBQcmFuY2tldmnEjWl1cycgcG9zdCBFbmNvZGluZyBGbG9hdHMgdG8gUkdCQVxcblxcXG4gICAgLy8gaHR0cDovL2FyYXMtcC5pbmZvL2Jsb2cvMjAwOS8wNy8zMC9lbmNvZGluZy1mbG9hdHMtdG8tcmdiYS10aGUtZmluYWwvXFxuXFxcbiAgICB2ZWM0IGVuYyA9IHZlYzQoMS4wLCAyNTUuMCwgNjUwMjUuMCwgMTY1ODEzNzUuMCkgKiBkZXB0aDtcXG5cXFxuICAgIGVuYyA9IGZyYWN0KGVuYyk7XFxuXFxcbiAgICBlbmMgLT0gZW5jLnl6d3cgKiB2ZWM0KDEuMCAvIDI1NS4wLCAxLjAgLyAyNTUuMCwgMS4wIC8gMjU1LjAsIDAuMCk7XFxuXFxcbiAgICByZXR1cm4gZW5jO1xcblxcXG59XFxuXFxcblwiO1xuIiwiLy9UaGlzIGZpbGUgaXMgYXV0b21hdGljYWxseSByZWJ1aWx0IGJ5IHRoZSBDZXNpdW0gYnVpbGQgcHJvY2Vzcy5cbmV4cG9ydCBkZWZhdWx0IFwidmVjMyBsYW1iZXJ0aWFuRGlmZnVzZSh2ZWMzIGRpZmZ1c2VDb2xvcilcXG5cXFxue1xcblxcXG4gICAgcmV0dXJuIGRpZmZ1c2VDb2xvciAvIGN6bV9waTtcXG5cXFxufVxcblxcXG5cXG5cXFxudmVjMyBmcmVzbmVsU2NobGljazIodmVjMyBmMCwgdmVjMyBmOTAsIGZsb2F0IFZkb3RIKVxcblxcXG57XFxuXFxcbiAgICByZXR1cm4gZjAgKyAoZjkwIC0gZjApICogcG93KGNsYW1wKDEuMCAtIFZkb3RILCAwLjAsIDEuMCksIDUuMCk7XFxuXFxcbn1cXG5cXFxuXFxuXFxcbmZsb2F0IHNtaXRoVmlzaWJpbGl0eUcxKGZsb2F0IE5kb3RWLCBmbG9hdCByb3VnaG5lc3MpXFxuXFxcbntcXG5cXFxuICAgIC8vIHRoaXMgaXMgdGhlIGsgdmFsdWUgZm9yIGRpcmVjdCBsaWdodGluZy5cXG5cXFxuICAgIC8vIGZvciBpbWFnZSBiYXNlZCBsaWdodGluZyBpdCB3aWxsIGJlIHJvdWdobmVzc14yIC8gMlxcblxcXG4gICAgZmxvYXQgayA9IChyb3VnaG5lc3MgKyAxLjApICogKHJvdWdobmVzcyArIDEuMCkgLyA4LjA7XFxuXFxcbiAgICByZXR1cm4gTmRvdFYgLyAoTmRvdFYgKiAoMS4wIC0gaykgKyBrKTtcXG5cXFxufVxcblxcXG5cXG5cXFxuZmxvYXQgc21pdGhWaXNpYmlsaXR5R0dYKGZsb2F0IHJvdWdobmVzcywgZmxvYXQgTmRvdEwsIGZsb2F0IE5kb3RWKVxcblxcXG57XFxuXFxcbiAgICByZXR1cm4gKFxcblxcXG4gICAgICAgIHNtaXRoVmlzaWJpbGl0eUcxKE5kb3RMLCByb3VnaG5lc3MpICpcXG5cXFxuICAgICAgICBzbWl0aFZpc2liaWxpdHlHMShOZG90Viwgcm91Z2huZXNzKVxcblxcXG4gICAgKTtcXG5cXFxufVxcblxcXG5cXG5cXFxuZmxvYXQgR0dYKGZsb2F0IHJvdWdobmVzcywgZmxvYXQgTmRvdEgpXFxuXFxcbntcXG5cXFxuICAgIGZsb2F0IHJvdWdobmVzc1NxdWFyZWQgPSByb3VnaG5lc3MgKiByb3VnaG5lc3M7XFxuXFxcbiAgICBmbG9hdCBmID0gKE5kb3RIICogcm91Z2huZXNzU3F1YXJlZCAtIE5kb3RIKSAqIE5kb3RIICsgMS4wO1xcblxcXG4gICAgcmV0dXJuIHJvdWdobmVzc1NxdWFyZWQgLyAoY3ptX3BpICogZiAqIGYpO1xcblxcXG59XFxuXFxcblxcblxcXG4vKipcXG5cXFxuICogQ29tcHV0ZSB0aGUgZGlmZnVzZSBhbmQgc3BlY3VsYXIgY29udHJpYnV0aW9ucyB1c2luZyBwaHlzaWNhbGx5IGJhc2VkXFxuXFxcbiAqIHJlbmRlcmluZy4gVGhpcyBmdW5jdGlvbiBvbmx5IGhhbmRsZXMgZGlyZWN0IGxpZ2h0aW5nLlxcblxcXG4gKiA8cD5cXG5cXFxuICogVGhpcyBmdW5jdGlvbiBvbmx5IGhhbmRsZXMgdGhlIGxpZ2h0aW5nIGNhbGN1bGF0aW9ucy4gTWV0YWxsaWMvcm91Z2huZXNzXFxuXFxcbiAqIGFuZCBzcGVjdWxhci9nbG9zc3kgbXVzdCBiZSBoYW5kbGVkIHNlcGFyYXRlbHkuIFNlZSB7QGN6bV9wYnJNZXRhbGxpY1JvdWdobmVzc01hdGVyaWFsfSwge0Bjem1fcGJyU3BlY3VsYXJHbG9zc2luZXNzTWF0ZXJpYWx9IGFuZCB7QGN6bV9kZWZhdWx0UGJyTWF0ZXJpYWx9XFxuXFxcbiAqIDwvcD5cXG5cXFxuICpcXG5cXFxuICogQG5hbWUgY3ptX3BicmxpZ2h0aW5nXFxuXFxcbiAqIEBnbHNsRnVuY3Rpb25cXG5cXFxuICpcXG5cXFxuICogQHBhcmFtIHt2ZWMzfSBwb3NpdGlvbkVDIFRoZSBwb3NpdGlvbiBvZiB0aGUgZnJhZ21lbnQgaW4gZXllIGNvb3JkaW5hdGVzXFxuXFxcbiAqIEBwYXJhbSB7dmVjM30gbm9ybWFsRUMgVGhlIHN1cmZhY2Ugbm9ybWFsIGluIGV5ZSBjb29yZGluYXRlc1xcblxcXG4gKiBAcGFyYW0ge3ZlYzN9IGxpZ2h0RGlyZWN0aW9uRUMgVW5pdCB2ZWN0b3IgcG9pbnRpbmcgdG8gdGhlIGxpZ2h0IHNvdXJjZSBpbiBleWUgY29vcmRpbmF0ZXMuXFxuXFxcbiAqIEBwYXJhbSB7dmVjM30gbGlnaHRDb2xvckhkciByYWRpYW5jZSBvZiB0aGUgbGlnaHQgc291cmNlLiBUaGlzIGlzIGEgSERSIHZhbHVlLlxcblxcXG4gKiBAcGFyYW0ge2N6bV9wYnJQYXJhbWV0ZXJzfSBUaGUgY29tcHV0ZWQgUEJSIHBhcmFtZXRlcnMuXFxuXFxcbiAqIEByZXR1cm4ge3ZlYzN9IFRoZSBjb21wdXRlZCBIRFIgY29sb3JcXG5cXFxuICpcXG5cXFxuICogQGV4YW1wbGVcXG5cXFxuICogY3ptX3BiclBhcmFtZXRlcnMgcGJyUGFyYW1ldGVycyA9IGN6bV9wYnJNZXRhbGxpY1JvdWdobmVzc01hdGVyaWFsKFxcblxcXG4gKiAgYmFzZUNvbG9yLFxcblxcXG4gKiAgbWV0YWxsaWMsXFxuXFxcbiAqICByb3VnaG5lc3NcXG5cXFxuICogKTtcXG5cXFxuICogdmVjMyBjb2xvciA9IGN6bV9wYnJsaWdodGluZyhcXG5cXFxuICogIHBvc2l0aW9uRUMsXFxuXFxcbiAqICBub3JtYWxFQyxcXG5cXFxuICogIGxpZ2h0RGlyZWN0aW9uRUMsXFxuXFxcbiAqICBsaWdodENvbG9ySGRyLFxcblxcXG4gKiAgcGJyUGFyYW1ldGVycyk7XFxuXFxcbiAqL1xcblxcXG52ZWMzIGN6bV9wYnJMaWdodGluZyhcXG5cXFxuICAgIHZlYzMgcG9zaXRpb25FQyxcXG5cXFxuICAgIHZlYzMgbm9ybWFsRUMsXFxuXFxcbiAgICB2ZWMzIGxpZ2h0RGlyZWN0aW9uRUMsXFxuXFxcbiAgICB2ZWMzIGxpZ2h0Q29sb3JIZHIsXFxuXFxcbiAgICBjem1fcGJyUGFyYW1ldGVycyBwYnJQYXJhbWV0ZXJzXFxuXFxcbilcXG5cXFxue1xcblxcXG4gICAgdmVjMyB2ID0gLW5vcm1hbGl6ZShwb3NpdGlvbkVDKTtcXG5cXFxuICAgIHZlYzMgbCA9IG5vcm1hbGl6ZShsaWdodERpcmVjdGlvbkVDKTtcXG5cXFxuICAgIHZlYzMgaCA9IG5vcm1hbGl6ZSh2ICsgbCk7XFxuXFxcbiAgICB2ZWMzIG4gPSBub3JtYWxFQztcXG5cXFxuICAgIGZsb2F0IE5kb3RMID0gY2xhbXAoZG90KG4sIGwpLCAwLjAwMSwgMS4wKTtcXG5cXFxuICAgIGZsb2F0IE5kb3RWID0gYWJzKGRvdChuLCB2KSkgKyAwLjAwMTtcXG5cXFxuICAgIGZsb2F0IE5kb3RIID0gY2xhbXAoZG90KG4sIGgpLCAwLjAsIDEuMCk7XFxuXFxcbiAgICBmbG9hdCBMZG90SCA9IGNsYW1wKGRvdChsLCBoKSwgMC4wLCAxLjApO1xcblxcXG4gICAgZmxvYXQgVmRvdEggPSBjbGFtcChkb3QodiwgaCksIDAuMCwgMS4wKTtcXG5cXFxuXFxuXFxcbiAgICB2ZWMzIGYwID0gcGJyUGFyYW1ldGVycy5mMDtcXG5cXFxuICAgIGZsb2F0IHJlZmxlY3RhbmNlID0gbWF4KG1heChmMC5yLCBmMC5nKSwgZjAuYik7XFxuXFxcbiAgICB2ZWMzIGY5MCA9IHZlYzMoY2xhbXAocmVmbGVjdGFuY2UgKiAyNS4wLCAwLjAsIDEuMCkpO1xcblxcXG4gICAgdmVjMyBGID0gZnJlc25lbFNjaGxpY2syKGYwLCBmOTAsIFZkb3RIKTtcXG5cXFxuXFxuXFxcbiAgICBmbG9hdCBhbHBoYSA9IHBiclBhcmFtZXRlcnMucm91Z2huZXNzO1xcblxcXG4gICAgZmxvYXQgRyA9IHNtaXRoVmlzaWJpbGl0eUdHWChhbHBoYSwgTmRvdEwsIE5kb3RWKTtcXG5cXFxuICAgIGZsb2F0IEQgPSBHR1goYWxwaGEsIE5kb3RIKTtcXG5cXFxuICAgIHZlYzMgc3BlY3VsYXJDb250cmlidXRpb24gPSBGICogRyAqIEQgLyAoNC4wICogTmRvdEwgKiBOZG90Vik7XFxuXFxcblxcblxcXG4gICAgdmVjMyBkaWZmdXNlQ29sb3IgPSBwYnJQYXJhbWV0ZXJzLmRpZmZ1c2VDb2xvcjtcXG5cXFxuICAgIC8vIEYgaGVyZSByZXByZXNlbnRzIHRoZSBzcGVjdWxhciBjb250cmlidXRpb25cXG5cXFxuICAgIHZlYzMgZGlmZnVzZUNvbnRyaWJ1dGlvbiA9ICgxLjAgLSBGKSAqIGxhbWJlcnRpYW5EaWZmdXNlKGRpZmZ1c2VDb2xvcik7XFxuXFxcblxcblxcXG4gICAgLy8gTG8gPSAoZGlmZnVzZSArIHNwZWN1bGFyKSAqIExpICogTmRvdExcXG5cXFxuICAgIHJldHVybiAoZGlmZnVzZUNvbnRyaWJ1dGlvbiArIHNwZWN1bGFyQ29udHJpYnV0aW9uKSAqIE5kb3RMICogbGlnaHRDb2xvckhkcjtcXG5cXFxufVxcblxcXG5cIjtcbiIsIi8vVGhpcyBmaWxlIGlzIGF1dG9tYXRpY2FsbHkgcmVidWlsdCBieSB0aGUgQ2VzaXVtIGJ1aWxkIHByb2Nlc3MuXG5leHBvcnQgZGVmYXVsdCBcIi8qKlxcblxcXG4gKiBDb21wdXRlIHBhcmFtZXRlcnMgZm9yIHBoeXNpY2FsbHkgYmFzZWQgcmVuZGVyaW5nIHVzaW5nIHRoZVxcblxcXG4gKiBtZXRhbGxpYy9yb3VnaG5lc3Mgd29ya2Zsb3cuIEFsbCBpbnB1dHMgYXJlIGxpbmVhcjsgc1JHQiB0ZXh0dXJlIHZhbHVlcyBtdXN0XFxuXFxcbiAqIGJlIGRlY29kZWQgYmVmb3JlaGFuZFxcblxcXG4gKlxcblxcXG4gKiBAbmFtZSBjem1fcGJyTWV0YWxsaWNSb3VnaG5lc3NNYXRlcmlhbFxcblxcXG4gKiBAZ2xzbEZ1bmN0aW9uXFxuXFxcbiAqXFxuXFxcbiAqIEBwYXJhbSB7dmVjM30gYmFzZUNvbG9yIEZvciBkaWVsZWN0cmljcywgdGhpcyBpcyB0aGUgYmFzZSBjb2xvci4gRm9yIG1ldGFscywgdGhpcyBpcyB0aGUgZjAgdmFsdWUgKHJlZmxlY3RhbmNlIGF0IG5vcm1hbCBpbmNpZGVuY2UpXFxuXFxcbiAqIEBwYXJhbSB7ZmxvYXR9IG1ldGFsbGljIDAuMCBpbmRpY2F0ZXMgZGllbGVjdHJpYy4gMS4wIGluZGljYXRlcyBtZXRhbC4gVmFsdWVzIGluIGJldHdlZW4gYXJlIGFsbG93ZWQgKGUuZy4gdG8gbW9kZWwgcnVzdCBvciBkaXJ0KTtcXG5cXFxuICogQHBhcmFtIHtmbG9hdH0gcm91Z2huZXNzIEEgdmFsdWUgYmV0d2VlbiAwLjAgYW5kIDEuMFxcblxcXG4gKiBAcmV0dXJuIHtjem1fcGJyUGFyYW1ldGVyc30gcGFyYW1ldGVycyB0byBwYXNzIGludG8ge0BsaW5rIGN6bV9wYnJMaWdodGluZ31cXG5cXFxuICovXFxuXFxcbmN6bV9wYnJQYXJhbWV0ZXJzIGN6bV9wYnJNZXRhbGxpY1JvdWdobmVzc01hdGVyaWFsKFxcblxcXG4gICAgdmVjMyBiYXNlQ29sb3IsXFxuXFxcbiAgICBmbG9hdCBtZXRhbGxpYyxcXG5cXFxuICAgIGZsb2F0IHJvdWdobmVzc1xcblxcXG4pIFxcblxcXG57XFxuXFxcbiAgICBjem1fcGJyUGFyYW1ldGVycyByZXN1bHRzO1xcblxcXG5cXG5cXFxuICAgIC8vIHJvdWdobmVzcyBpcyBhdXRob3JlZCBhcyBwZXJjZXB0dWFsIHJvdWdobmVzc1xcblxcXG4gICAgLy8gc3F1YXJlIGl0IHRvIGdldCBtYXRlcmlhbCByb3VnaG5lc3NcXG5cXFxuICAgIHJvdWdobmVzcyA9IGNsYW1wKHJvdWdobmVzcywgMC4wLCAxLjApO1xcblxcXG4gICAgcmVzdWx0cy5yb3VnaG5lc3MgPSByb3VnaG5lc3MgKiByb3VnaG5lc3M7XFxuXFxcblxcblxcXG4gICAgLy8gZGllbGVjdHJpY3MgdXMgZjAgPSAwLjA0LCBtZXRhbHMgdXNlIGFsYmVkbyBhcyBmMFxcblxcXG4gICAgbWV0YWxsaWMgPSBjbGFtcChtZXRhbGxpYywgMC4wLCAxLjApO1xcblxcXG4gICAgY29uc3QgdmVjMyBSRUZMRUNUQU5DRV9ESUVMRUNUUklDID0gdmVjMygwLjA0KTtcXG5cXFxuICAgIHZlYzMgZjAgPSBtaXgoUkVGTEVDVEFOQ0VfRElFTEVDVFJJQywgYmFzZUNvbG9yLCBtZXRhbGxpYyk7XFxuXFxcbiAgICByZXN1bHRzLmYwID0gZjA7XFxuXFxcblxcblxcXG4gICAgLy8gZGlmZnVzZSBvbmx5IGFwcGxpZXMgdG8gZGllbGVjdHJpY3MuXFxuXFxcbiAgICByZXN1bHRzLmRpZmZ1c2VDb2xvciA9IGJhc2VDb2xvciAqICgxLjAgLSBmMCkgKiAoMS4wIC0gbWV0YWxsaWMpO1xcblxcXG5cXG5cXFxuICAgIHJldHVybiByZXN1bHRzO1xcblxcXG59XFxuXFxcblwiO1xuIiwiLy9UaGlzIGZpbGUgaXMgYXV0b21hdGljYWxseSByZWJ1aWx0IGJ5IHRoZSBDZXNpdW0gYnVpbGQgcHJvY2Vzcy5cbmV4cG9ydCBkZWZhdWx0IFwiLyoqXFxuXFxcbiAqIENvbXB1dGUgcGFyYW1ldGVycyBmb3IgcGh5c2ljYWxseSBiYXNlZCByZW5kZXJpbmcgdXNpbmcgdGhlXFxuXFxcbiAqIHNwZWN1bGFyL2dsb3NzeSB3b3JrZmxvdy4gQWxsIGlucHV0cyBhcmUgbGluZWFyOyBzUkdCIHRleHR1cmUgdmFsdWVzIG11c3RcXG5cXFxuICogYmUgZGVjb2RlZCBiZWZvcmVoYW5kXFxuXFxcbiAqXFxuXFxcbiAqIEBuYW1lIGN6bV9wYnJTcGVjdWxhckdsb3NzaW5lc3NNYXRlcmlhbFxcblxcXG4gKiBAZ2xzbEZ1bmN0aW9uXFxuXFxcbiAqXFxuXFxcbiAqIEBwYXJhbSB7dmVjM30gZGlmZnVzZSBUaGUgZGlmZnVzZSBjb2xvciBmb3IgZGllbGVjdHJpY3MgKG5vbi1tZXRhbHMpXFxuXFxcbiAqIEBwYXJhbSB7dmVjM30gc3BlY3VsYXIgVGhlIHJlZmxlY3RhbmNlIGF0IG5vcm1hbCBpbmNpZGVuY2UgKGYwKVxcblxcXG4gKiBAcGFyYW0ge2Zsb2F0fSBnbG9zc2luZXNzIEEgbnVtYmVyIGZyb20gMC4wIHRvIDEuMCBpbmRpY2F0aW5nIGhvdyBzbW9vdGggdGhlIHN1cmZhY2UgaXMuXFxuXFxcbiAqIEByZXR1cm4ge2N6bV9wYnJQYXJhbWV0ZXJzfSBwYXJhbWV0ZXJzIHRvIHBhc3MgaW50byB7QGxpbmsgY3ptX3BickxpZ2h0aW5nfVxcblxcXG4gKi9cXG5cXFxuY3ptX3BiclBhcmFtZXRlcnMgY3ptX3BiclNwZWN1bGFyR2xvc3NpbmVzc01hdGVyaWFsKFxcblxcXG4gICAgdmVjMyBkaWZmdXNlLFxcblxcXG4gICAgdmVjMyBzcGVjdWxhcixcXG5cXFxuICAgIGZsb2F0IGdsb3NzaW5lc3NcXG5cXFxuKSBcXG5cXFxue1xcblxcXG4gICAgY3ptX3BiclBhcmFtZXRlcnMgcmVzdWx0cztcXG5cXFxuXFxuXFxcbiAgICAvLyBnbG9zc2luZXNzIGlzIHRoZSBvcHBvc2l0ZSBvZiByb3VnaG5lc3MsIGJ1dCBlYXNpZXIgZm9yIGFydGlzdHMgdG8gdXNlLlxcblxcXG4gICAgZmxvYXQgcm91Z2huZXNzID0gMS4wIC0gZ2xvc3NpbmVzcztcXG5cXFxuICAgIHJlc3VsdHMucm91Z2huZXNzID0gcm91Z2huZXNzICogcm91Z2huZXNzO1xcblxcXG5cXG5cXFxuICAgIHJlc3VsdHMuZGlmZnVzZUNvbG9yID0gZGlmZnVzZSAqICgxLjAgLSBtYXgobWF4KHNwZWN1bGFyLnIsIHNwZWN1bGFyLmcpLCBzcGVjdWxhci5iKSk7XFxuXFxcbiAgICByZXN1bHRzLmYwID0gc3BlY3VsYXI7XFxuXFxcblxcblxcXG4gICAgcmV0dXJuIHJlc3VsdHM7XFxuXFxcbn1cXG5cXFxuXCI7XG4iLCIvL1RoaXMgZmlsZSBpcyBhdXRvbWF0aWNhbGx5IHJlYnVpbHQgYnkgdGhlIENlc2l1bSBidWlsZCBwcm9jZXNzLlxuZXhwb3J0IGRlZmF1bHQgXCJmbG9hdCBjem1fcHJpdmF0ZV9nZXRMYW1iZXJ0RGlmZnVzZU9mTWF0ZXJpYWwodmVjMyBsaWdodERpcmVjdGlvbkVDLCBjem1fbWF0ZXJpYWwgbWF0ZXJpYWwpXFxuXFxcbntcXG5cXFxuICAgIHJldHVybiBjem1fZ2V0TGFtYmVydERpZmZ1c2UobGlnaHREaXJlY3Rpb25FQywgbWF0ZXJpYWwubm9ybWFsKTtcXG5cXFxufVxcblxcXG5cXG5cXFxuZmxvYXQgY3ptX3ByaXZhdGVfZ2V0U3BlY3VsYXJPZk1hdGVyaWFsKHZlYzMgbGlnaHREaXJlY3Rpb25FQywgdmVjMyB0b0V5ZUVDLCBjem1fbWF0ZXJpYWwgbWF0ZXJpYWwpXFxuXFxcbntcXG5cXFxuICAgIHJldHVybiBjem1fZ2V0U3BlY3VsYXIobGlnaHREaXJlY3Rpb25FQywgdG9FeWVFQywgbWF0ZXJpYWwubm9ybWFsLCBtYXRlcmlhbC5zaGluaW5lc3MpO1xcblxcXG59XFxuXFxcblxcblxcXG4vKipcXG5cXFxuICogQ29tcHV0ZXMgYSBjb2xvciB1c2luZyB0aGUgUGhvbmcgbGlnaHRpbmcgbW9kZWwuXFxuXFxcbiAqXFxuXFxcbiAqIEBuYW1lIGN6bV9waG9uZ1xcblxcXG4gKiBAZ2xzbEZ1bmN0aW9uXFxuXFxcbiAqXFxuXFxcbiAqIEBwYXJhbSB7dmVjM30gdG9FeWUgQSBub3JtYWxpemVkIHZlY3RvciBmcm9tIHRoZSBmcmFnbWVudCB0byB0aGUgZXllIGluIGV5ZSBjb29yZGluYXRlcy5cXG5cXFxuICogQHBhcmFtIHtjem1fbWF0ZXJpYWx9IG1hdGVyaWFsIFRoZSBmcmFnbWVudCdzIG1hdGVyaWFsLlxcblxcXG4gKlxcblxcXG4gKiBAcmV0dXJucyB7dmVjNH0gVGhlIGNvbXB1dGVkIGNvbG9yLlxcblxcXG4gKlxcblxcXG4gKiBAZXhhbXBsZVxcblxcXG4gKiB2ZWMzIHBvc2l0aW9uVG9FeWVFQyA9IC8vIC4uLlxcblxcXG4gKiBjem1fbWF0ZXJpYWwgbWF0ZXJpYWwgPSAvLyAuLi5cXG5cXFxuICogdmVjMyBsaWdodERpcmVjdGlvbkVDID0gLy8gLi4uXFxuXFxcbiAqIGdsX0ZyYWdDb2xvciA9IGN6bV9waG9uZyhub3JtYWxpemUocG9zaXRpb25Ub0V5ZUVDKSwgbWF0ZXJpYWwsIGxpZ2h0RGlyZWN0aW9uRUMpO1xcblxcXG4gKlxcblxcXG4gKiBAc2VlIGN6bV9nZXRNYXRlcmlhbFxcblxcXG4gKi9cXG5cXFxudmVjNCBjem1fcGhvbmcodmVjMyB0b0V5ZSwgY3ptX21hdGVyaWFsIG1hdGVyaWFsLCB2ZWMzIGxpZ2h0RGlyZWN0aW9uRUMpXFxuXFxcbntcXG5cXFxuICAgIC8vIERpZmZ1c2UgZnJvbSBkaXJlY3Rpb25hbCBsaWdodCBzb3VyY2VzIGF0IGV5ZSAoZm9yIHRvcC1kb3duKVxcblxcXG4gICAgZmxvYXQgZGlmZnVzZSA9IGN6bV9wcml2YXRlX2dldExhbWJlcnREaWZmdXNlT2ZNYXRlcmlhbCh2ZWMzKDAuMCwgMC4wLCAxLjApLCBtYXRlcmlhbCk7XFxuXFxcbiAgICBpZiAoY3ptX3NjZW5lTW9kZSA9PSBjem1fc2NlbmVNb2RlM0QpIHtcXG5cXFxuICAgICAgICAvLyAoYW5kIGhvcml6b24gdmlld3MgaW4gM0QpXFxuXFxcbiAgICAgICAgZGlmZnVzZSArPSBjem1fcHJpdmF0ZV9nZXRMYW1iZXJ0RGlmZnVzZU9mTWF0ZXJpYWwodmVjMygwLjAsIDEuMCwgMC4wKSwgbWF0ZXJpYWwpO1xcblxcXG4gICAgfVxcblxcXG5cXG5cXFxuICAgIGZsb2F0IHNwZWN1bGFyID0gY3ptX3ByaXZhdGVfZ2V0U3BlY3VsYXJPZk1hdGVyaWFsKGxpZ2h0RGlyZWN0aW9uRUMsIHRvRXllLCBtYXRlcmlhbCk7XFxuXFxcblxcblxcXG4gICAgLy8gVGVtcG9yYXJ5IHdvcmthcm91bmQgZm9yIGFkZGluZyBhbWJpZW50LlxcblxcXG4gICAgdmVjMyBtYXRlcmlhbERpZmZ1c2UgPSBtYXRlcmlhbC5kaWZmdXNlICogMC41O1xcblxcXG5cXG5cXFxuICAgIHZlYzMgYW1iaWVudCA9IG1hdGVyaWFsRGlmZnVzZTtcXG5cXFxuICAgIHZlYzMgY29sb3IgPSBhbWJpZW50ICsgbWF0ZXJpYWwuZW1pc3Npb247XFxuXFxcbiAgICBjb2xvciArPSBtYXRlcmlhbERpZmZ1c2UgKiBkaWZmdXNlICogY3ptX2xpZ2h0Q29sb3I7XFxuXFxcbiAgICBjb2xvciArPSBtYXRlcmlhbC5zcGVjdWxhciAqIHNwZWN1bGFyICogY3ptX2xpZ2h0Q29sb3I7XFxuXFxcblxcblxcXG4gICAgcmV0dXJuIHZlYzQoY29sb3IsIG1hdGVyaWFsLmFscGhhKTtcXG5cXFxufVxcblxcXG5cXG5cXFxudmVjNCBjem1fcHJpdmF0ZV9waG9uZyh2ZWMzIHRvRXllLCBjem1fbWF0ZXJpYWwgbWF0ZXJpYWwsIHZlYzMgbGlnaHREaXJlY3Rpb25FQylcXG5cXFxue1xcblxcXG4gICAgZmxvYXQgZGlmZnVzZSA9IGN6bV9wcml2YXRlX2dldExhbWJlcnREaWZmdXNlT2ZNYXRlcmlhbChsaWdodERpcmVjdGlvbkVDLCBtYXRlcmlhbCk7XFxuXFxcbiAgICBmbG9hdCBzcGVjdWxhciA9IGN6bV9wcml2YXRlX2dldFNwZWN1bGFyT2ZNYXRlcmlhbChsaWdodERpcmVjdGlvbkVDLCB0b0V5ZSwgbWF0ZXJpYWwpO1xcblxcXG5cXG5cXFxuICAgIHZlYzMgYW1iaWVudCA9IHZlYzMoMC4wKTtcXG5cXFxuICAgIHZlYzMgY29sb3IgPSBhbWJpZW50ICsgbWF0ZXJpYWwuZW1pc3Npb247XFxuXFxcbiAgICBjb2xvciArPSBtYXRlcmlhbC5kaWZmdXNlICogZGlmZnVzZSAqIGN6bV9saWdodENvbG9yO1xcblxcXG4gICAgY29sb3IgKz0gbWF0ZXJpYWwuc3BlY3VsYXIgKiBzcGVjdWxhciAqIGN6bV9saWdodENvbG9yO1xcblxcXG5cXG5cXFxuICAgIHJldHVybiB2ZWM0KGNvbG9yLCBtYXRlcmlhbC5hbHBoYSk7XFxuXFxcbn1cXG5cXFxuXCI7XG4iLCIvL1RoaXMgZmlsZSBpcyBhdXRvbWF0aWNhbGx5IHJlYnVpbHQgYnkgdGhlIENlc2l1bSBidWlsZCBwcm9jZXNzLlxuZXhwb3J0IGRlZmF1bHQgXCIvKipcXG5cXFxuICogQ29tcHV0ZXMgZGlzdGFuY2UgZnJvbSBhIHBvaW50IHRvIGEgcGxhbmUuXFxuXFxcbiAqXFxuXFxcbiAqIEBuYW1lIGN6bV9wbGFuZURpc3RhbmNlXFxuXFxcbiAqIEBnbHNsRnVuY3Rpb25cXG5cXFxuICpcXG5cXFxuICogcGFyYW0ge3ZlYzR9IHBsYW5lIEEgUGxhbmUgaW4gSGVzc2lhbiBOb3JtYWwgRm9ybS4gU2VlIFBsYW5lLmpzXFxuXFxcbiAqIHBhcmFtIHt2ZWMzfSBwb2ludCBBIHBvaW50IGluIHRoZSBzYW1lIHNwYWNlIGFzIHRoZSBwbGFuZS5cXG5cXFxuICogcmV0dXJucyB7ZmxvYXR9IFRoZSBkaXN0YW5jZSBmcm9tIHRoZSBwb2ludCB0byB0aGUgcGxhbmUuXFxuXFxcbiAqL1xcblxcXG5mbG9hdCBjem1fcGxhbmVEaXN0YW5jZSh2ZWM0IHBsYW5lLCB2ZWMzIHBvaW50KSB7XFxuXFxcbiAgICByZXR1cm4gKGRvdChwbGFuZS54eXosIHBvaW50KSArIHBsYW5lLncpO1xcblxcXG59XFxuXFxcblxcblxcXG4vKipcXG5cXFxuICogQ29tcHV0ZXMgZGlzdGFuY2UgZnJvbSBhIHBvaW50IHRvIGEgcGxhbmUuXFxuXFxcbiAqXFxuXFxcbiAqIEBuYW1lIGN6bV9wbGFuZURpc3RhbmNlXFxuXFxcbiAqIEBnbHNsRnVuY3Rpb25cXG5cXFxuICpcXG5cXFxuICogcGFyYW0ge3ZlYzN9IHBsYW5lTm9ybWFsIE5vcm1hbCBmb3IgYSBwbGFuZSBpbiBIZXNzaWFuIE5vcm1hbCBGb3JtLiBTZWUgUGxhbmUuanNcXG5cXFxuICogcGFyYW0ge2Zsb2F0fSBwbGFuZURpc3RhbmNlIERpc3RhbmNlIGZvciBhIHBsYW5lIGluIEhlc3NpYW4gTm9ybWFsIGZvcm0uIFNlZSBQbGFuZS5qc1xcblxcXG4gKiBwYXJhbSB7dmVjM30gcG9pbnQgQSBwb2ludCBpbiB0aGUgc2FtZSBzcGFjZSBhcyB0aGUgcGxhbmUuXFxuXFxcbiAqIHJldHVybnMge2Zsb2F0fSBUaGUgZGlzdGFuY2UgZnJvbSB0aGUgcG9pbnQgdG8gdGhlIHBsYW5lLlxcblxcXG4gKi9cXG5cXFxuZmxvYXQgY3ptX3BsYW5lRGlzdGFuY2UodmVjMyBwbGFuZU5vcm1hbCwgZmxvYXQgcGxhbmVEaXN0YW5jZSwgdmVjMyBwb2ludCkge1xcblxcXG4gICAgcmV0dXJuIChkb3QocGxhbmVOb3JtYWwsIHBvaW50KSArIHBsYW5lRGlzdGFuY2UpO1xcblxcXG59XFxuXFxcblwiO1xuIiwiLy9UaGlzIGZpbGUgaXMgYXV0b21hdGljYWxseSByZWJ1aWx0IGJ5IHRoZSBDZXNpdW0gYnVpbGQgcHJvY2Vzcy5cbmV4cG9ydCBkZWZhdWx0IFwiLyoqXFxuXFxcbiAqIENvbXB1dGVzIHRoZSBwb2ludCBhbG9uZyBhIHJheSBhdCB0aGUgZ2l2ZW4gdGltZS4gIDxjb2RlPnRpbWU8L2NvZGU+IGNhbiBiZSBwb3NpdGl2ZSwgbmVnYXRpdmUsIG9yIHplcm8uXFxuXFxcbiAqXFxuXFxcbiAqIEBuYW1lIGN6bV9wb2ludEFsb25nUmF5XFxuXFxcbiAqIEBnbHNsRnVuY3Rpb25cXG5cXFxuICpcXG5cXFxuICogQHBhcmFtIHtjem1fcmF5fSByYXkgVGhlIHJheSB0byBjb21wdXRlIHRoZSBwb2ludCBhbG9uZy5cXG5cXFxuICogQHBhcmFtIHtmbG9hdH0gdGltZSBUaGUgdGltZSBhbG9uZyB0aGUgcmF5LlxcblxcXG4gKiBcXG5cXFxuICogQHJldHVybnMge3ZlYzN9IFRoZSBwb2ludCBhbG9uZyB0aGUgcmF5IGF0IHRoZSBnaXZlbiB0aW1lLlxcblxcXG4gKiBcXG5cXFxuICogQGV4YW1wbGVcXG5cXFxuICogY3ptX3JheSByYXkgPSBjem1fcmF5KHZlYzMoMC4wKSwgdmVjMygxLjAsIDAuMCwgMC4wKSk7IC8vIG9yaWdpbiwgZGlyZWN0aW9uXFxuXFxcbiAqIHZlYzMgdiA9IGN6bV9wb2ludEFsb25nUmF5KHJheSwgMi4wKTsgLy8gKDIuMCwgMC4wLCAwLjApXFxuXFxcbiAqL1xcblxcXG52ZWMzIGN6bV9wb2ludEFsb25nUmF5KGN6bV9yYXkgcmF5LCBmbG9hdCB0aW1lKVxcblxcXG57XFxuXFxcbiAgICByZXR1cm4gcmF5Lm9yaWdpbiArICh0aW1lICogcmF5LmRpcmVjdGlvbik7XFxuXFxcbn1cXG5cXFxuXCI7XG4iLCIvL1RoaXMgZmlsZSBpcyBhdXRvbWF0aWNhbGx5IHJlYnVpbHQgYnkgdGhlIENlc2l1bSBidWlsZCBwcm9jZXNzLlxuZXhwb3J0IGRlZmF1bHQgXCIvKipcXG5cXFxuICogRE9DX1RCQVxcblxcXG4gKlxcblxcXG4gKiBAbmFtZSBjem1fcmF5RWxsaXBzb2lkSW50ZXJzZWN0aW9uSW50ZXJ2YWxcXG5cXFxuICogQGdsc2xGdW5jdGlvblxcblxcXG4gKi9cXG5cXFxuY3ptX3JheVNlZ21lbnQgY3ptX3JheUVsbGlwc29pZEludGVyc2VjdGlvbkludGVydmFsKGN6bV9yYXkgcmF5LCB2ZWMzIGVsbGlwc29pZF9jZW50ZXIsIHZlYzMgZWxsaXBzb2lkX2ludmVyc2VSYWRpaSlcXG5cXFxue1xcblxcXG4gICAvLyByYXkgYW5kIGVsbGlwc29pZCBjZW50ZXIgaW4gZXllIGNvb3JkaW5hdGVzLiAgcmFkaWkgaW4gbW9kZWwgY29vcmRpbmF0ZXMuXFxuXFxcbiAgICB2ZWMzIHEgPSBlbGxpcHNvaWRfaW52ZXJzZVJhZGlpICogKGN6bV9pbnZlcnNlTW9kZWxWaWV3ICogdmVjNChyYXkub3JpZ2luLCAxLjApKS54eXo7XFxuXFxcbiAgICB2ZWMzIHcgPSBlbGxpcHNvaWRfaW52ZXJzZVJhZGlpICogKGN6bV9pbnZlcnNlTW9kZWxWaWV3ICogdmVjNChyYXkuZGlyZWN0aW9uLCAwLjApKS54eXo7XFxuXFxcblxcblxcXG4gICAgcSA9IHEgLSBlbGxpcHNvaWRfaW52ZXJzZVJhZGlpICogKGN6bV9pbnZlcnNlTW9kZWxWaWV3ICogdmVjNChlbGxpcHNvaWRfY2VudGVyLCAxLjApKS54eXo7XFxuXFxcblxcblxcXG4gICAgZmxvYXQgcTIgPSBkb3QocSwgcSk7XFxuXFxcbiAgICBmbG9hdCBxdyA9IGRvdChxLCB3KTtcXG5cXFxuXFxuXFxcbiAgICBpZiAocTIgPiAxLjApIC8vIE91dHNpZGUgZWxsaXBzb2lkLlxcblxcXG4gICAge1xcblxcXG4gICAgICAgIGlmIChxdyA+PSAwLjApIC8vIExvb2tpbmcgb3V0d2FyZCBvciB0YW5nZW50ICgwIGludGVyc2VjdGlvbnMpLlxcblxcXG4gICAgICAgIHtcXG5cXFxuICAgICAgICAgICAgcmV0dXJuIGN6bV9lbXB0eVJheVNlZ21lbnQ7XFxuXFxcbiAgICAgICAgfVxcblxcXG4gICAgICAgIGVsc2UgLy8gcXcgPCAwLjAuXFxuXFxcbiAgICAgICAge1xcblxcXG4gICAgICAgICAgICBmbG9hdCBxdzIgPSBxdyAqIHF3O1xcblxcXG4gICAgICAgICAgICBmbG9hdCBkaWZmZXJlbmNlID0gcTIgLSAxLjA7IC8vIFBvc2l0aXZlbHkgdmFsdWVkLlxcblxcXG4gICAgICAgICAgICBmbG9hdCB3MiA9IGRvdCh3LCB3KTtcXG5cXFxuICAgICAgICAgICAgZmxvYXQgcHJvZHVjdCA9IHcyICogZGlmZmVyZW5jZTtcXG5cXFxuXFxuXFxcbiAgICAgICAgICAgIGlmIChxdzIgPCBwcm9kdWN0KSAvLyBJbWFnaW5hcnkgcm9vdHMgKDAgaW50ZXJzZWN0aW9ucykuXFxuXFxcbiAgICAgICAgICAgIHtcXG5cXFxuICAgICAgICAgICAgICAgIHJldHVybiBjem1fZW1wdHlSYXlTZWdtZW50O1xcblxcXG4gICAgICAgICAgICB9XFxuXFxcbiAgICAgICAgICAgIGVsc2UgaWYgKHF3MiA+IHByb2R1Y3QpIC8vIERpc3RpbmN0IHJvb3RzICgyIGludGVyc2VjdGlvbnMpLlxcblxcXG4gICAgICAgICAgICB7XFxuXFxcbiAgICAgICAgICAgICAgICBmbG9hdCBkaXNjcmltaW5hbnQgPSBxdyAqIHF3IC0gcHJvZHVjdDtcXG5cXFxuICAgICAgICAgICAgICAgIGZsb2F0IHRlbXAgPSAtcXcgKyBzcXJ0KGRpc2NyaW1pbmFudCk7IC8vIEF2b2lkIGNhbmNlbGxhdGlvbi5cXG5cXFxuICAgICAgICAgICAgICAgIGZsb2F0IHJvb3QwID0gdGVtcCAvIHcyO1xcblxcXG4gICAgICAgICAgICAgICAgZmxvYXQgcm9vdDEgPSBkaWZmZXJlbmNlIC8gdGVtcDtcXG5cXFxuICAgICAgICAgICAgICAgIGlmIChyb290MCA8IHJvb3QxKVxcblxcXG4gICAgICAgICAgICAgICAge1xcblxcXG4gICAgICAgICAgICAgICAgICAgIGN6bV9yYXlTZWdtZW50IGkgPSBjem1fcmF5U2VnbWVudChyb290MCwgcm9vdDEpO1xcblxcXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBpO1xcblxcXG4gICAgICAgICAgICAgICAgfVxcblxcXG4gICAgICAgICAgICAgICAgZWxzZVxcblxcXG4gICAgICAgICAgICAgICAge1xcblxcXG4gICAgICAgICAgICAgICAgICAgIGN6bV9yYXlTZWdtZW50IGkgPSBjem1fcmF5U2VnbWVudChyb290MSwgcm9vdDApO1xcblxcXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBpO1xcblxcXG4gICAgICAgICAgICAgICAgfVxcblxcXG4gICAgICAgICAgICB9XFxuXFxcbiAgICAgICAgICAgIGVsc2UgLy8gcXcyID09IHByb2R1Y3QuICBSZXBlYXRlZCByb290cyAoMiBpbnRlcnNlY3Rpb25zKS5cXG5cXFxuICAgICAgICAgICAge1xcblxcXG4gICAgICAgICAgICAgICAgZmxvYXQgcm9vdCA9IHNxcnQoZGlmZmVyZW5jZSAvIHcyKTtcXG5cXFxuICAgICAgICAgICAgICAgIGN6bV9yYXlTZWdtZW50IGkgPSBjem1fcmF5U2VnbWVudChyb290LCByb290KTtcXG5cXFxuICAgICAgICAgICAgICAgIHJldHVybiBpO1xcblxcXG4gICAgICAgICAgICB9XFxuXFxcbiAgICAgICAgfVxcblxcXG4gICAgfVxcblxcXG4gICAgZWxzZSBpZiAocTIgPCAxLjApIC8vIEluc2lkZSBlbGxpcHNvaWQgKDIgaW50ZXJzZWN0aW9ucykuXFxuXFxcbiAgICB7XFxuXFxcbiAgICAgICAgZmxvYXQgZGlmZmVyZW5jZSA9IHEyIC0gMS4wOyAvLyBOZWdhdGl2ZWx5IHZhbHVlZC5cXG5cXFxuICAgICAgICBmbG9hdCB3MiA9IGRvdCh3LCB3KTtcXG5cXFxuICAgICAgICBmbG9hdCBwcm9kdWN0ID0gdzIgKiBkaWZmZXJlbmNlOyAvLyBOZWdhdGl2ZWx5IHZhbHVlZC5cXG5cXFxuICAgICAgICBmbG9hdCBkaXNjcmltaW5hbnQgPSBxdyAqIHF3IC0gcHJvZHVjdDtcXG5cXFxuICAgICAgICBmbG9hdCB0ZW1wID0gLXF3ICsgc3FydChkaXNjcmltaW5hbnQpOyAvLyBQb3NpdGl2ZWx5IHZhbHVlZC5cXG5cXFxuICAgICAgICBjem1fcmF5U2VnbWVudCBpID0gY3ptX3JheVNlZ21lbnQoMC4wLCB0ZW1wIC8gdzIpO1xcblxcXG4gICAgICAgIHJldHVybiBpO1xcblxcXG4gICAgfVxcblxcXG4gICAgZWxzZSAvLyBxMiA9PSAxLjAuIE9uIGVsbGlwc29pZC5cXG5cXFxuICAgIHtcXG5cXFxuICAgICAgICBpZiAocXcgPCAwLjApIC8vIExvb2tpbmcgaW53YXJkLlxcblxcXG4gICAgICAgIHtcXG5cXFxuICAgICAgICAgICAgZmxvYXQgdzIgPSBkb3Qodywgdyk7XFxuXFxcbiAgICAgICAgICAgIGN6bV9yYXlTZWdtZW50IGkgPSBjem1fcmF5U2VnbWVudCgwLjAsIC1xdyAvIHcyKTtcXG5cXFxuICAgICAgICAgICAgcmV0dXJuIGk7XFxuXFxcbiAgICAgICAgfVxcblxcXG4gICAgICAgIGVsc2UgLy8gcXcgPj0gMC4wLiAgTG9va2luZyBvdXR3YXJkIG9yIHRhbmdlbnQuXFxuXFxcbiAgICAgICAge1xcblxcXG4gICAgICAgICAgICByZXR1cm4gY3ptX2VtcHR5UmF5U2VnbWVudDtcXG5cXFxuICAgICAgICB9XFxuXFxcbiAgICB9XFxuXFxcbn1cXG5cXFxuXCI7XG4iLCIvL1RoaXMgZmlsZSBpcyBhdXRvbWF0aWNhbGx5IHJlYnVpbHQgYnkgdGhlIENlc2l1bSBidWlsZCBwcm9jZXNzLlxuZXhwb3J0IGRlZmF1bHQgXCJmbG9hdCBjem1fcmVhZERlcHRoKHNhbXBsZXIyRCBkZXB0aFRleHR1cmUsIHZlYzIgdGV4Q29vcmRzKVxcblxcXG57XFxuXFxcbiAgICByZXR1cm4gY3ptX3JldmVyc2VMb2dEZXB0aCh0ZXh0dXJlMkQoZGVwdGhUZXh0dXJlLCB0ZXhDb29yZHMpLnIpO1xcblxcXG59XFxuXFxcblwiO1xuIiwiLy9UaGlzIGZpbGUgaXMgYXV0b21hdGljYWxseSByZWJ1aWx0IGJ5IHRoZSBDZXNpdW0gYnVpbGQgcHJvY2Vzcy5cbmV4cG9ydCBkZWZhdWx0IFwiLyoqXFxuXFxcbiAqIFJlYWRzIGEgdmFsdWUgcHJldmlvdXNseSB0cmFuc2Zvcm1lZCB3aXRoIHtAbGluayBjem1fd3JpdGVOb25QZXJzcGVjdGl2ZX1cXG5cXFxuICogYnkgZGl2aWRpbmcgaXQgYnkgYHdgLCB0aGUgdmFsdWUgdXNlZCBpbiB0aGUgcGVyc3BlY3RpdmUgZGl2aWRlLlxcblxcXG4gKiBUaGlzIGZ1bmN0aW9uIGlzIGludGVuZGVkIHRvIGJlIGNhbGxlZCBpbiBhIGZyYWdtZW50IHNoYWRlciB0byBhY2Nlc3MgYVxcblxcXG4gKiBgdmFyeWluZ2AgdGhhdCBzaG91bGQgbm90IGJlIHN1YmplY3QgdG8gcGVyc3BlY3RpdmUgaW50ZXJwb2xhdGlvbi5cXG5cXFxuICogRm9yIGV4YW1wbGUsIHNjcmVlbi1zcGFjZSB0ZXh0dXJlIGNvb3JkaW5hdGVzLiBUaGUgdmFsdWUgc2hvdWxkIGhhdmUgYmVlblxcblxcXG4gKiBwcmV2aW91c2x5IHdyaXR0ZW4gaW4gdGhlIHZlcnRleCBzaGFkZXIgd2l0aCBhIGNhbGwgdG9cXG5cXFxuICoge0BsaW5rIGN6bV93cml0ZU5vblBlcnNwZWN0aXZlfS5cXG5cXFxuICpcXG5cXFxuICogQG5hbWUgY3ptX3JlYWROb25QZXJzcGVjdGl2ZVxcblxcXG4gKiBAZ2xzbEZ1bmN0aW9uXFxuXFxcbiAqXFxuXFxcbiAqIEBwYXJhbSB7ZmxvYXR8dmVjMnx2ZWMzfHZlYzR9IHZhbHVlIFRoZSBub24tcGVyc3BlY3RpdmUgdmFsdWUgdG8gYmUgcmVhZC5cXG5cXFxuICogQHBhcmFtIHtmbG9hdH0gb25lT3ZlclcgT25lIG92ZXIgdGhlIHBlcnNwZWN0aXZlIGRpdmlkZSB2YWx1ZSwgYHdgLiBVc3VhbGx5IHRoaXMgaXMgc2ltcGx5IGBnbF9GcmFnQ29vcmQud2AuXFxuXFxcbiAqIEByZXR1cm5zIHtmbG9hdHx2ZWMyfHZlYzN8dmVjNH0gVGhlIHVzYWJsZSB2YWx1ZS5cXG5cXFxuICovXFxuXFxcbmZsb2F0IGN6bV9yZWFkTm9uUGVyc3BlY3RpdmUoZmxvYXQgdmFsdWUsIGZsb2F0IG9uZU92ZXJXKSB7XFxuXFxcbiAgICByZXR1cm4gdmFsdWUgKiBvbmVPdmVyVztcXG5cXFxufVxcblxcXG5cXG5cXFxudmVjMiBjem1fcmVhZE5vblBlcnNwZWN0aXZlKHZlYzIgdmFsdWUsIGZsb2F0IG9uZU92ZXJXKSB7XFxuXFxcbiAgICByZXR1cm4gdmFsdWUgKiBvbmVPdmVyVztcXG5cXFxufVxcblxcXG5cXG5cXFxudmVjMyBjem1fcmVhZE5vblBlcnNwZWN0aXZlKHZlYzMgdmFsdWUsIGZsb2F0IG9uZU92ZXJXKSB7XFxuXFxcbiAgICByZXR1cm4gdmFsdWUgKiBvbmVPdmVyVztcXG5cXFxufVxcblxcXG5cXG5cXFxudmVjNCBjem1fcmVhZE5vblBlcnNwZWN0aXZlKHZlYzQgdmFsdWUsIGZsb2F0IG9uZU92ZXJXKSB7XFxuXFxcbiAgICByZXR1cm4gdmFsdWUgKiBvbmVPdmVyVztcXG5cXFxufVxcblxcXG5cIjtcbiIsIi8vVGhpcyBmaWxlIGlzIGF1dG9tYXRpY2FsbHkgcmVidWlsdCBieSB0aGUgQ2VzaXVtIGJ1aWxkIHByb2Nlc3MuXG5leHBvcnQgZGVmYXVsdCBcImZsb2F0IGN6bV9yZXZlcnNlTG9nRGVwdGgoZmxvYXQgbG9nWilcXG5cXFxue1xcblxcXG4jaWZkZWYgTE9HX0RFUFRIXFxuXFxcbiAgICBmbG9hdCBuZWFyID0gY3ptX2N1cnJlbnRGcnVzdHVtLng7XFxuXFxcbiAgICBmbG9hdCBmYXIgPSBjem1fY3VycmVudEZydXN0dW0ueTtcXG5cXFxuICAgIGZsb2F0IGxvZzJEZXB0aCA9IGxvZ1ogKiBjem1fbG9nMkZhckRlcHRoRnJvbU5lYXJQbHVzT25lO1xcblxcXG4gICAgZmxvYXQgZGVwdGhGcm9tTmVhciA9IHBvdygyLjAsIGxvZzJEZXB0aCkgLSAxLjA7XFxuXFxcbiAgICByZXR1cm4gZmFyICogKDEuMCAtIG5lYXIgLyAoZGVwdGhGcm9tTmVhciArIG5lYXIpKSAvIChmYXIgLSBuZWFyKTtcXG5cXFxuI2VuZGlmXFxuXFxcbiAgICByZXR1cm4gbG9nWjtcXG5cXFxufVxcblxcXG5cIjtcbiIsIi8vVGhpcyBmaWxlIGlzIGF1dG9tYXRpY2FsbHkgcmVidWlsdCBieSB0aGUgQ2VzaXVtIGJ1aWxkIHByb2Nlc3MuXG5leHBvcnQgZGVmYXVsdCBcIi8qKlxcblxcXG4gKiBTYW1wbGVzIHRoZSA0IG5laWdoYm9yaW5nIHBpeGVscyBhbmQgcmV0dXJuIHRoZSB3ZWlnaHRlZCBhdmVyYWdlLlxcblxcXG4gKlxcblxcXG4gKiBAcHJpdmF0ZVxcblxcXG4gKi9cXG5cXFxudmVjMyBjem1fc2FtcGxlT2N0YWhlZHJhbFByb2plY3Rpb25XaXRoRmlsdGVyaW5nKHNhbXBsZXIyRCBwcm9qZWN0ZWRNYXAsIHZlYzIgdGV4dHVyZVNpemUsIHZlYzMgZGlyZWN0aW9uLCBmbG9hdCBsb2QpXFxuXFxcbntcXG5cXFxuICAgIGRpcmVjdGlvbiAvPSBkb3QodmVjMygxLjApLCBhYnMoZGlyZWN0aW9uKSk7XFxuXFxcbiAgICB2ZWMyIHJldiA9IGFicyhkaXJlY3Rpb24uengpIC0gdmVjMigxLjApO1xcblxcXG4gICAgdmVjMiBuZWcgPSB2ZWMyKGRpcmVjdGlvbi54IDwgMC4wID8gcmV2LnggOiAtcmV2LngsXFxuXFxcbiAgICAgICAgICAgICAgICAgICAgZGlyZWN0aW9uLnogPCAwLjAgPyByZXYueSA6IC1yZXYueSk7XFxuXFxcbiAgICB2ZWMyIHV2ID0gZGlyZWN0aW9uLnkgPCAwLjAgPyBuZWcgOiBkaXJlY3Rpb24ueHo7XFxuXFxcbiAgICB2ZWMyIGNvb3JkID0gMC41ICogdXYgKyB2ZWMyKDAuNSk7XFxuXFxcbiAgICB2ZWMyIHBpeGVsID0gMS4wIC8gdGV4dHVyZVNpemU7XFxuXFxcblxcblxcXG4gICAgaWYgKGxvZCA+IDAuMClcXG5cXFxuICAgIHtcXG5cXFxuICAgICAgICAvLyBFYWNoIHN1YnNlcWV1ZW50IG1pcCBsZXZlbCBpcyBoYWxmIHRoZSBzaXplXFxuXFxcbiAgICAgICAgZmxvYXQgc2NhbGUgPSAxLjAgLyBwb3coMi4wLCBsb2QpO1xcblxcXG4gICAgICAgIGZsb2F0IG9mZnNldCA9ICgodGV4dHVyZVNpemUueSArIDEuMCkgLyB0ZXh0dXJlU2l6ZS54KTtcXG5cXFxuXFxuXFxcbiAgICAgICAgY29vcmQueCAqPSBvZmZzZXQ7XFxuXFxcbiAgICAgICAgY29vcmQgKj0gc2NhbGU7XFxuXFxcblxcblxcXG4gICAgICAgIGNvb3JkLnggKz0gb2Zmc2V0ICsgcGl4ZWwueDtcXG5cXFxuICAgICAgICBjb29yZC55ICs9ICgxLjAgLSAoMS4wIC8gcG93KDIuMCwgbG9kIC0gMS4wKSkpICsgcGl4ZWwueSAqIChsb2QgLSAxLjApICogMi4wO1xcblxcXG4gICAgfVxcblxcXG4gICAgZWxzZVxcblxcXG4gICAge1xcblxcXG4gICAgICAgIGNvb3JkLnggKj0gKHRleHR1cmVTaXplLnkgLyB0ZXh0dXJlU2l6ZS54KTtcXG5cXFxuICAgIH1cXG5cXFxuXFxuXFxcbiAgICAvLyBEbyBiaWxpbmVhciBmaWx0ZXJpbmdcXG5cXFxuICAgICNpZm5kZWYgT0VTX3RleHR1cmVfZmxvYXRfbGluZWFyXFxuXFxcbiAgICAgICAgdmVjMyBjb2xvcjEgPSB0ZXh0dXJlMkQocHJvamVjdGVkTWFwLCBjb29yZCArIHZlYzIoMC4wLCBwaXhlbC55KSkucmdiO1xcblxcXG4gICAgICAgIHZlYzMgY29sb3IyID0gdGV4dHVyZTJEKHByb2plY3RlZE1hcCwgY29vcmQgKyB2ZWMyKHBpeGVsLngsIDAuMCkpLnJnYjtcXG5cXFxuICAgICAgICB2ZWMzIGNvbG9yMyA9IHRleHR1cmUyRChwcm9qZWN0ZWRNYXAsIGNvb3JkICsgcGl4ZWwpLnJnYjtcXG5cXFxuICAgICAgICB2ZWMzIGNvbG9yNCA9IHRleHR1cmUyRChwcm9qZWN0ZWRNYXAsIGNvb3JkKS5yZ2I7XFxuXFxcblxcblxcXG4gICAgICAgIHZlYzIgdGV4dHVyZVBvc2l0aW9uID0gY29vcmQgKiB0ZXh0dXJlU2l6ZTtcXG5cXFxuXFxuXFxcbiAgICAgICAgZmxvYXQgZnUgPSBmcmFjdCh0ZXh0dXJlUG9zaXRpb24ueCk7XFxuXFxcbiAgICAgICAgZmxvYXQgZnYgPSBmcmFjdCh0ZXh0dXJlUG9zaXRpb24ueSk7XFxuXFxcblxcblxcXG4gICAgICAgIHZlYzMgYXZlcmFnZTEgPSBtaXgoY29sb3I0LCBjb2xvcjIsIGZ1KTtcXG5cXFxuICAgICAgICB2ZWMzIGF2ZXJhZ2UyID0gbWl4KGNvbG9yMSwgY29sb3IzLCBmdSk7XFxuXFxcblxcblxcXG4gICAgICAgIHZlYzMgY29sb3IgPSBtaXgoYXZlcmFnZTEsIGF2ZXJhZ2UyLCBmdik7XFxuXFxcbiAgICAjZWxzZVxcblxcXG4gICAgICAgIHZlYzMgY29sb3IgPSB0ZXh0dXJlMkQocHJvamVjdGVkTWFwLCBjb29yZCkucmdiO1xcblxcXG4gICAgI2VuZGlmXFxuXFxcblxcblxcXG4gICAgcmV0dXJuIGNvbG9yO1xcblxcXG59XFxuXFxcblxcblxcXG5cXG5cXFxuLyoqXFxuXFxcbiAqIFNhbXBsZXMgZnJvbSBhIGN1YmUgbWFwIHRoYXQgaGFzIGJlZW4gcHJvamVjdGVkIHVzaW5nIGFuIG9jdGFoZWRyYWwgcHJvamVjdGlvbiBmcm9tIHRoZSBnaXZlbiBkaXJlY3Rpb24uXFxuXFxcbiAqXFxuXFxcbiAqIEBuYW1lIGN6bV9zYW1wbGVPY3RhaGVkcmFsUHJvamVjdGlvblxcblxcXG4gKiBAZ2xzbEZ1bmN0aW9uXFxuXFxcbiAqXFxuXFxcbiAqIEBwYXJhbSB7c2FtcGxlcjJEfSBwcm9qZWN0ZWRNYXAgVGhlIHRleHR1cmUgd2l0aCB0aGUgb2N0YWhlZHJhbCBwcm9qZWN0ZWQgY3ViZSBtYXAuXFxuXFxcbiAqIEBwYXJhbSB7dmVjMn0gdGV4dHVyZVNpemUgVGhlIHdpZHRoIGFuZCBoZWlnaHQgZGltZW5zaW9ucyBpbiBwaXhlbHMgb2YgdGhlIHByb2plY3RlZCBtYXAuXFxuXFxcbiAqIEBwYXJhbSB7dmVjM30gZGlyZWN0aW9uIFRoZSBub3JtYWxpemVkIGRpcmVjdGlvbiB1c2VkIHRvIHNhbXBsZSB0aGUgY3ViZSBtYXAuXFxuXFxcbiAqIEBwYXJhbSB7ZmxvYXR9IGxvZCBUaGUgbGV2ZWwgb2YgZGV0YWlsIHRvIHNhbXBsZS5cXG5cXFxuICogQHBhcmFtIHtmbG9hdH0gbWF4TG9kIFRoZSBtYXhpbXVtIGxldmVsIG9mIGRldGFpbC5cXG5cXFxuICogQHJldHVybnMge3ZlYzN9IFRoZSBjb2xvciBvZiB0aGUgY3ViZSBtYXAgYXQgdGhlIGRpcmVjdGlvbi5cXG5cXFxuICovXFxuXFxcbnZlYzMgY3ptX3NhbXBsZU9jdGFoZWRyYWxQcm9qZWN0aW9uKHNhbXBsZXIyRCBwcm9qZWN0ZWRNYXAsIHZlYzIgdGV4dHVyZVNpemUsIHZlYzMgZGlyZWN0aW9uLCBmbG9hdCBsb2QsIGZsb2F0IG1heExvZCkge1xcblxcXG4gICAgZmxvYXQgY3VycmVudExvZCA9IGZsb29yKGxvZCArIDAuNSk7XFxuXFxcbiAgICBmbG9hdCBuZXh0TG9kID0gbWluKGN1cnJlbnRMb2QgKyAxLjAsIG1heExvZCk7XFxuXFxcblxcblxcXG4gICAgdmVjMyBjb2xvckN1cnJlbnRMb2QgPSBjem1fc2FtcGxlT2N0YWhlZHJhbFByb2plY3Rpb25XaXRoRmlsdGVyaW5nKHByb2plY3RlZE1hcCwgdGV4dHVyZVNpemUsIGRpcmVjdGlvbiwgY3VycmVudExvZCk7XFxuXFxcbiAgICB2ZWMzIGNvbG9yTmV4dExvZCA9IGN6bV9zYW1wbGVPY3RhaGVkcmFsUHJvamVjdGlvbldpdGhGaWx0ZXJpbmcocHJvamVjdGVkTWFwLCB0ZXh0dXJlU2l6ZSwgZGlyZWN0aW9uLCBuZXh0TG9kKTtcXG5cXFxuXFxuXFxcbiAgICByZXR1cm4gbWl4KGNvbG9yTmV4dExvZCwgY29sb3JDdXJyZW50TG9kLCBuZXh0TG9kIC0gbG9kKTtcXG5cXFxufVxcblxcXG5cIjtcbiIsIi8vVGhpcyBmaWxlIGlzIGF1dG9tYXRpY2FsbHkgcmVidWlsdCBieSB0aGUgQ2VzaXVtIGJ1aWxkIHByb2Nlc3MuXG5leHBvcnQgZGVmYXVsdCBcIi8qKlxcblxcXG4gKiBBZGp1c3RzIHRoZSBzYXR1cmF0aW9uIG9mIGEgY29sb3IuXFxuXFxcbiAqIFxcblxcXG4gKiBAbmFtZSBjem1fc2F0dXJhdGlvblxcblxcXG4gKiBAZ2xzbEZ1bmN0aW9uXFxuXFxcbiAqIFxcblxcXG4gKiBAcGFyYW0ge3ZlYzN9IHJnYiBUaGUgY29sb3IuXFxuXFxcbiAqIEBwYXJhbSB7ZmxvYXR9IGFkanVzdG1lbnQgVGhlIGFtb3VudCB0byBhZGp1c3QgdGhlIHNhdHVyYXRpb24gb2YgdGhlIGNvbG9yLlxcblxcXG4gKlxcblxcXG4gKiBAcmV0dXJucyB7ZmxvYXR9IFRoZSBjb2xvciB3aXRoIHRoZSBzYXR1cmF0aW9uIGFkanVzdGVkLlxcblxcXG4gKlxcblxcXG4gKiBAZXhhbXBsZVxcblxcXG4gKiB2ZWMzIGdyZXlTY2FsZSA9IGN6bV9zYXR1cmF0aW9uKGNvbG9yLCAwLjApO1xcblxcXG4gKiB2ZWMzIGRvdWJsZVNhdHVyYXRpb24gPSBjem1fc2F0dXJhdGlvbihjb2xvciwgMi4wKTtcXG5cXFxuICovXFxuXFxcbnZlYzMgY3ptX3NhdHVyYXRpb24odmVjMyByZ2IsIGZsb2F0IGFkanVzdG1lbnQpXFxuXFxcbntcXG5cXFxuICAgIC8vIEFsZ29yaXRobSBmcm9tIENoYXB0ZXIgMTYgb2YgT3BlbkdMIFNoYWRpbmcgTGFuZ3VhZ2VcXG5cXFxuICAgIGNvbnN0IHZlYzMgVyA9IHZlYzMoMC4yMTI1LCAwLjcxNTQsIDAuMDcyMSk7XFxuXFxcbiAgICB2ZWMzIGludGVuc2l0eSA9IHZlYzMoZG90KHJnYiwgVykpO1xcblxcXG4gICAgcmV0dXJuIG1peChpbnRlbnNpdHksIHJnYiwgYWRqdXN0bWVudCk7XFxuXFxcbn1cXG5cXFxuXCI7XG4iLCIvL1RoaXMgZmlsZSBpcyBhdXRvbWF0aWNhbGx5IHJlYnVpbHQgYnkgdGhlIENlc2l1bSBidWlsZCBwcm9jZXNzLlxuZXhwb3J0IGRlZmF1bHQgXCJcXG5cXFxuZmxvYXQgY3ptX3NhbXBsZVNoYWRvd01hcChoaWdocCBzYW1wbGVyQ3ViZSBzaGFkb3dNYXAsIHZlYzMgZClcXG5cXFxue1xcblxcXG4gICAgcmV0dXJuIGN6bV91bnBhY2tEZXB0aCh0ZXh0dXJlQ3ViZShzaGFkb3dNYXAsIGQpKTtcXG5cXFxufVxcblxcXG5cXG5cXFxuZmxvYXQgY3ptX3NhbXBsZVNoYWRvd01hcChoaWdocCBzYW1wbGVyMkQgc2hhZG93TWFwLCB2ZWMyIHV2KVxcblxcXG57XFxuXFxcbiNpZmRlZiBVU0VfU0hBRE9XX0RFUFRIX1RFWFRVUkVcXG5cXFxuICAgIHJldHVybiB0ZXh0dXJlMkQoc2hhZG93TWFwLCB1dikucjtcXG5cXFxuI2Vsc2VcXG5cXFxuICAgIHJldHVybiBjem1fdW5wYWNrRGVwdGgodGV4dHVyZTJEKHNoYWRvd01hcCwgdXYpKTtcXG5cXFxuI2VuZGlmXFxuXFxcbn1cXG5cXFxuXFxuXFxcbmZsb2F0IGN6bV9zaGFkb3dEZXB0aENvbXBhcmUoc2FtcGxlckN1YmUgc2hhZG93TWFwLCB2ZWMzIHV2LCBmbG9hdCBkZXB0aClcXG5cXFxue1xcblxcXG4gICAgcmV0dXJuIHN0ZXAoZGVwdGgsIGN6bV9zYW1wbGVTaGFkb3dNYXAoc2hhZG93TWFwLCB1dikpO1xcblxcXG59XFxuXFxcblxcblxcXG5mbG9hdCBjem1fc2hhZG93RGVwdGhDb21wYXJlKHNhbXBsZXIyRCBzaGFkb3dNYXAsIHZlYzIgdXYsIGZsb2F0IGRlcHRoKVxcblxcXG57XFxuXFxcbiAgICByZXR1cm4gc3RlcChkZXB0aCwgY3ptX3NhbXBsZVNoYWRvd01hcChzaGFkb3dNYXAsIHV2KSk7XFxuXFxcbn1cXG5cXFxuXCI7XG4iLCIvL1RoaXMgZmlsZSBpcyBhdXRvbWF0aWNhbGx5IHJlYnVpbHQgYnkgdGhlIENlc2l1bSBidWlsZCBwcm9jZXNzLlxuZXhwb3J0IGRlZmF1bHQgXCJcXG5cXFxuZmxvYXQgY3ptX3ByaXZhdGVfc2hhZG93VmlzaWJpbGl0eShmbG9hdCB2aXNpYmlsaXR5LCBmbG9hdCBuRG90TCwgZmxvYXQgbm9ybWFsU2hhZGluZ1Ntb290aCwgZmxvYXQgZGFya25lc3MpXFxuXFxcbntcXG5cXFxuI2lmZGVmIFVTRV9OT1JNQUxfU0hBRElOR1xcblxcXG4jaWZkZWYgVVNFX05PUk1BTF9TSEFESU5HX1NNT09USFxcblxcXG4gICAgZmxvYXQgc3RyZW5ndGggPSBjbGFtcChuRG90TCAvIG5vcm1hbFNoYWRpbmdTbW9vdGgsIDAuMCwgMS4wKTtcXG5cXFxuI2Vsc2VcXG5cXFxuICAgIGZsb2F0IHN0cmVuZ3RoID0gc3RlcCgwLjAsIG5Eb3RMKTtcXG5cXFxuI2VuZGlmXFxuXFxcbiAgICB2aXNpYmlsaXR5ICo9IHN0cmVuZ3RoO1xcblxcXG4jZW5kaWZcXG5cXFxuXFxuXFxcbiAgICB2aXNpYmlsaXR5ID0gbWF4KHZpc2liaWxpdHksIGRhcmtuZXNzKTtcXG5cXFxuICAgIHJldHVybiB2aXNpYmlsaXR5O1xcblxcXG59XFxuXFxcblxcblxcXG4jaWZkZWYgVVNFX0NVQkVfTUFQX1NIQURPV1xcblxcXG5mbG9hdCBjem1fc2hhZG93VmlzaWJpbGl0eShzYW1wbGVyQ3ViZSBzaGFkb3dNYXAsIGN6bV9zaGFkb3dQYXJhbWV0ZXJzIHNoYWRvd1BhcmFtZXRlcnMpXFxuXFxcbntcXG5cXFxuICAgIGZsb2F0IGRlcHRoQmlhcyA9IHNoYWRvd1BhcmFtZXRlcnMuZGVwdGhCaWFzO1xcblxcXG4gICAgZmxvYXQgZGVwdGggPSBzaGFkb3dQYXJhbWV0ZXJzLmRlcHRoO1xcblxcXG4gICAgZmxvYXQgbkRvdEwgPSBzaGFkb3dQYXJhbWV0ZXJzLm5Eb3RMO1xcblxcXG4gICAgZmxvYXQgbm9ybWFsU2hhZGluZ1Ntb290aCA9IHNoYWRvd1BhcmFtZXRlcnMubm9ybWFsU2hhZGluZ1Ntb290aDtcXG5cXFxuICAgIGZsb2F0IGRhcmtuZXNzID0gc2hhZG93UGFyYW1ldGVycy5kYXJrbmVzcztcXG5cXFxuICAgIHZlYzMgdXZ3ID0gc2hhZG93UGFyYW1ldGVycy50ZXhDb29yZHM7XFxuXFxcblxcblxcXG4gICAgZGVwdGggLT0gZGVwdGhCaWFzO1xcblxcXG4gICAgZmxvYXQgdmlzaWJpbGl0eSA9IGN6bV9zaGFkb3dEZXB0aENvbXBhcmUoc2hhZG93TWFwLCB1dncsIGRlcHRoKTtcXG5cXFxuICAgIHJldHVybiBjem1fcHJpdmF0ZV9zaGFkb3dWaXNpYmlsaXR5KHZpc2liaWxpdHksIG5Eb3RMLCBub3JtYWxTaGFkaW5nU21vb3RoLCBkYXJrbmVzcyk7XFxuXFxcbn1cXG5cXFxuI2Vsc2VcXG5cXFxuZmxvYXQgY3ptX3NoYWRvd1Zpc2liaWxpdHkoc2FtcGxlcjJEIHNoYWRvd01hcCwgY3ptX3NoYWRvd1BhcmFtZXRlcnMgc2hhZG93UGFyYW1ldGVycylcXG5cXFxue1xcblxcXG4gICAgZmxvYXQgZGVwdGhCaWFzID0gc2hhZG93UGFyYW1ldGVycy5kZXB0aEJpYXM7XFxuXFxcbiAgICBmbG9hdCBkZXB0aCA9IHNoYWRvd1BhcmFtZXRlcnMuZGVwdGg7XFxuXFxcbiAgICBmbG9hdCBuRG90TCA9IHNoYWRvd1BhcmFtZXRlcnMubkRvdEw7XFxuXFxcbiAgICBmbG9hdCBub3JtYWxTaGFkaW5nU21vb3RoID0gc2hhZG93UGFyYW1ldGVycy5ub3JtYWxTaGFkaW5nU21vb3RoO1xcblxcXG4gICAgZmxvYXQgZGFya25lc3MgPSBzaGFkb3dQYXJhbWV0ZXJzLmRhcmtuZXNzO1xcblxcXG4gICAgdmVjMiB1diA9IHNoYWRvd1BhcmFtZXRlcnMudGV4Q29vcmRzO1xcblxcXG5cXG5cXFxuICAgIGRlcHRoIC09IGRlcHRoQmlhcztcXG5cXFxuI2lmZGVmIFVTRV9TT0ZUX1NIQURPV1NcXG5cXFxuICAgIHZlYzIgdGV4ZWxTdGVwU2l6ZSA9IHNoYWRvd1BhcmFtZXRlcnMudGV4ZWxTdGVwU2l6ZTtcXG5cXFxuICAgIGZsb2F0IHJhZGl1cyA9IDEuMDtcXG5cXFxuICAgIGZsb2F0IGR4MCA9IC10ZXhlbFN0ZXBTaXplLnggKiByYWRpdXM7XFxuXFxcbiAgICBmbG9hdCBkeTAgPSAtdGV4ZWxTdGVwU2l6ZS55ICogcmFkaXVzO1xcblxcXG4gICAgZmxvYXQgZHgxID0gdGV4ZWxTdGVwU2l6ZS54ICogcmFkaXVzO1xcblxcXG4gICAgZmxvYXQgZHkxID0gdGV4ZWxTdGVwU2l6ZS55ICogcmFkaXVzO1xcblxcXG4gICAgZmxvYXQgdmlzaWJpbGl0eSA9IChcXG5cXFxuICAgICAgICBjem1fc2hhZG93RGVwdGhDb21wYXJlKHNoYWRvd01hcCwgdXYsIGRlcHRoKSArXFxuXFxcbiAgICAgICAgY3ptX3NoYWRvd0RlcHRoQ29tcGFyZShzaGFkb3dNYXAsIHV2ICsgdmVjMihkeDAsIGR5MCksIGRlcHRoKSArXFxuXFxcbiAgICAgICAgY3ptX3NoYWRvd0RlcHRoQ29tcGFyZShzaGFkb3dNYXAsIHV2ICsgdmVjMigwLjAsIGR5MCksIGRlcHRoKSArXFxuXFxcbiAgICAgICAgY3ptX3NoYWRvd0RlcHRoQ29tcGFyZShzaGFkb3dNYXAsIHV2ICsgdmVjMihkeDEsIGR5MCksIGRlcHRoKSArXFxuXFxcbiAgICAgICAgY3ptX3NoYWRvd0RlcHRoQ29tcGFyZShzaGFkb3dNYXAsIHV2ICsgdmVjMihkeDAsIDAuMCksIGRlcHRoKSArXFxuXFxcbiAgICAgICAgY3ptX3NoYWRvd0RlcHRoQ29tcGFyZShzaGFkb3dNYXAsIHV2ICsgdmVjMihkeDEsIDAuMCksIGRlcHRoKSArXFxuXFxcbiAgICAgICAgY3ptX3NoYWRvd0RlcHRoQ29tcGFyZShzaGFkb3dNYXAsIHV2ICsgdmVjMihkeDAsIGR5MSksIGRlcHRoKSArXFxuXFxcbiAgICAgICAgY3ptX3NoYWRvd0RlcHRoQ29tcGFyZShzaGFkb3dNYXAsIHV2ICsgdmVjMigwLjAsIGR5MSksIGRlcHRoKSArXFxuXFxcbiAgICAgICAgY3ptX3NoYWRvd0RlcHRoQ29tcGFyZShzaGFkb3dNYXAsIHV2ICsgdmVjMihkeDEsIGR5MSksIGRlcHRoKVxcblxcXG4gICAgKSAqICgxLjAgLyA5LjApO1xcblxcXG4jZWxzZVxcblxcXG4gICAgZmxvYXQgdmlzaWJpbGl0eSA9IGN6bV9zaGFkb3dEZXB0aENvbXBhcmUoc2hhZG93TWFwLCB1diwgZGVwdGgpO1xcblxcXG4jZW5kaWZcXG5cXFxuXFxuXFxcbiAgICByZXR1cm4gY3ptX3ByaXZhdGVfc2hhZG93VmlzaWJpbGl0eSh2aXNpYmlsaXR5LCBuRG90TCwgbm9ybWFsU2hhZGluZ1Ntb290aCwgZGFya25lc3MpO1xcblxcXG59XFxuXFxcbiNlbmRpZlxcblxcXG5cIjtcbiIsIi8vVGhpcyBmaWxlIGlzIGF1dG9tYXRpY2FsbHkgcmVidWlsdCBieSB0aGUgQ2VzaXVtIGJ1aWxkIHByb2Nlc3MuXG5leHBvcnQgZGVmYXVsdCBcIi8qKlxcblxcXG4gKiBSZXR1cm5zIDEuMCBpZiB0aGUgZ2l2ZW4gdmFsdWUgaXMgcG9zaXRpdmUgb3IgemVybywgYW5kIC0xLjAgaWYgaXQgaXMgbmVnYXRpdmUuICBUaGlzIGlzIHNpbWlsYXIgdG8gdGhlIEdMU0xcXG5cXFxuICogYnVpbHQtaW4gZnVuY3Rpb24gPGNvZGU+c2lnbjwvY29kZT4gZXhjZXB0IHRoYXQgcmV0dXJucyAxLjAgaW5zdGVhZCBvZiAwLjAgd2hlbiB0aGUgaW5wdXQgdmFsdWUgaXMgMC4wLlxcblxcXG4gKiBcXG5cXFxuICogQG5hbWUgY3ptX3NpZ25Ob3RaZXJvXFxuXFxcbiAqIEBnbHNsRnVuY3Rpb25cXG5cXFxuICpcXG5cXFxuICogQHBhcmFtIHt9IHZhbHVlIFRoZSB2YWx1ZSBmb3Igd2hpY2ggdG8gZGV0ZXJtaW5lIHRoZSBzaWduLlxcblxcXG4gKiBAcmV0dXJucyB7fSAxLjAgaWYgdGhlIHZhbHVlIGlzIHBvc2l0aXZlIG9yIHplcm8sIC0xLjAgaWYgdGhlIHZhbHVlIGlzIG5lZ2F0aXZlLlxcblxcXG4gKi9cXG5cXFxuZmxvYXQgY3ptX3NpZ25Ob3RaZXJvKGZsb2F0IHZhbHVlKVxcblxcXG57XFxuXFxcbiAgICByZXR1cm4gdmFsdWUgPj0gMC4wID8gMS4wIDogLTEuMDtcXG5cXFxufVxcblxcXG5cXG5cXFxudmVjMiBjem1fc2lnbk5vdFplcm8odmVjMiB2YWx1ZSlcXG5cXFxue1xcblxcXG4gICAgcmV0dXJuIHZlYzIoY3ptX3NpZ25Ob3RaZXJvKHZhbHVlLngpLCBjem1fc2lnbk5vdFplcm8odmFsdWUueSkpO1xcblxcXG59XFxuXFxcblxcblxcXG52ZWMzIGN6bV9zaWduTm90WmVybyh2ZWMzIHZhbHVlKVxcblxcXG57XFxuXFxcbiAgICByZXR1cm4gdmVjMyhjem1fc2lnbk5vdFplcm8odmFsdWUueCksIGN6bV9zaWduTm90WmVybyh2YWx1ZS55KSwgY3ptX3NpZ25Ob3RaZXJvKHZhbHVlLnopKTtcXG5cXFxufVxcblxcXG5cXG5cXFxudmVjNCBjem1fc2lnbk5vdFplcm8odmVjNCB2YWx1ZSlcXG5cXFxue1xcblxcXG4gICAgcmV0dXJuIHZlYzQoY3ptX3NpZ25Ob3RaZXJvKHZhbHVlLngpLCBjem1fc2lnbk5vdFplcm8odmFsdWUueSksIGN6bV9zaWduTm90WmVybyh2YWx1ZS56KSwgY3ptX3NpZ25Ob3RaZXJvKHZhbHVlLncpKTtcXG5cXFxufVxcblxcXG5cIjtcbiIsIi8vVGhpcyBmaWxlIGlzIGF1dG9tYXRpY2FsbHkgcmVidWlsdCBieSB0aGUgQ2VzaXVtIGJ1aWxkIHByb2Nlc3MuXG5leHBvcnQgZGVmYXVsdCBcIi8qKlxcblxcXG4gKiBDb21wdXRlcyBhIGNvbG9yIGZyb20gdGhlIHRoaXJkIG9yZGVyIHNwaGVyaWNhbCBoYXJtb25pYyBjb2VmZmljaWVudHMgYW5kIGEgbm9ybWFsaXplZCBkaXJlY3Rpb24gdmVjdG9yLlxcblxcXG4gKiA8cD5cXG5cXFxuICogVGhlIG9yZGVyIG9mIHRoZSBjb2VmZmljaWVudHMgaXMgW0wwMCwgTDFfMSwgTDEwLCBMMTEsIEwyXzIsIEwyXzEsIEwyMCwgTDIxLCBMMjJdLlxcblxcXG4gKiA8L3A+XFxuXFxcbiAqXFxuXFxcbiAqIEBuYW1lIGN6bV9zcGhlcmljYWxIYXJtb25pY3NcXG5cXFxuICogQGdsc2xGdW5jdGlvblxcblxcXG4gKlxcblxcXG4gKiBAcGFyYW0ge3ZlYzN9IG5vcm1hbCBUaGUgbm9ybWFsaXplZCBkaXJlY3Rpb24uXFxuXFxcbiAqIEBwYXJhbSB7dmVjM1s5XX0gY29lZmZpY2llbnRzIFRoZSB0aGlyZCBvcmRlciBzcGhlcmljYWwgaGFybW9uaWMgY29lZmZpY2llbnRzLlxcblxcXG4gKiBAcmV0dXJucyB7dmVjM30gVGhlIGNvbG9yIGF0IHRoZSBkaXJlY3Rpb24uXFxuXFxcbiAqXFxuXFxcbiAqIEBzZWUgaHR0cHM6Ly9ncmFwaGljcy5zdGFuZm9yZC5lZHUvcGFwZXJzL2Vudm1hcC9lbnZtYXAucGRmXFxuXFxcbiAqL1xcblxcXG52ZWMzIGN6bV9zcGhlcmljYWxIYXJtb25pY3ModmVjMyBub3JtYWwsIHZlYzMgY29lZmZpY2llbnRzWzldKVxcblxcXG57XFxuXFxcbiAgICB2ZWMzIEwwMCA9IGNvZWZmaWNpZW50c1swXTtcXG5cXFxuICAgIHZlYzMgTDFfMSA9IGNvZWZmaWNpZW50c1sxXTtcXG5cXFxuICAgIHZlYzMgTDEwID0gY29lZmZpY2llbnRzWzJdO1xcblxcXG4gICAgdmVjMyBMMTEgPSBjb2VmZmljaWVudHNbM107XFxuXFxcbiAgICB2ZWMzIEwyXzIgPSBjb2VmZmljaWVudHNbNF07XFxuXFxcbiAgICB2ZWMzIEwyXzEgPSBjb2VmZmljaWVudHNbNV07XFxuXFxcbiAgICB2ZWMzIEwyMCA9IGNvZWZmaWNpZW50c1s2XTtcXG5cXFxuICAgIHZlYzMgTDIxID0gY29lZmZpY2llbnRzWzddO1xcblxcXG4gICAgdmVjMyBMMjIgPSBjb2VmZmljaWVudHNbOF07XFxuXFxcblxcblxcXG4gICAgZmxvYXQgeCA9IG5vcm1hbC54O1xcblxcXG4gICAgZmxvYXQgeSA9IG5vcm1hbC55O1xcblxcXG4gICAgZmxvYXQgeiA9IG5vcm1hbC56O1xcblxcXG5cXG5cXFxuICAgIHJldHVyblxcblxcXG4gICAgICAgICAgTDAwXFxuXFxcbiAgICAgICAgKyBMMV8xICogeVxcblxcXG4gICAgICAgICsgTDEwICogelxcblxcXG4gICAgICAgICsgTDExICogeFxcblxcXG4gICAgICAgICsgTDJfMiAqICh5ICogeClcXG5cXFxuICAgICAgICArIEwyXzEgKiAoeSAqIHopXFxuXFxcbiAgICAgICAgKyBMMjAgKiAoMy4wICogeiAqIHogLSAxLjApXFxuXFxcbiAgICAgICAgKyBMMjEgKiAoeiAqIHgpXFxuXFxcbiAgICAgICAgKyBMMjIgKiAoeCAqIHggLSB5ICogeSk7XFxuXFxcbn1cXG5cXFxuXCI7XG4iLCIvL1RoaXMgZmlsZSBpcyBhdXRvbWF0aWNhbGx5IHJlYnVpbHQgYnkgdGhlIENlc2l1bSBidWlsZCBwcm9jZXNzLlxuZXhwb3J0IGRlZmF1bHQgXCIvKipcXG5cXFxuICogQ3JlYXRlcyBhIG1hdHJpeCB0aGF0IHRyYW5zZm9ybXMgdmVjdG9ycyBmcm9tIHRhbmdlbnQgc3BhY2UgdG8gZXllIHNwYWNlLlxcblxcXG4gKlxcblxcXG4gKiBAbmFtZSBjem1fdGFuZ2VudFRvRXllU3BhY2VNYXRyaXhcXG5cXFxuICogQGdsc2xGdW5jdGlvblxcblxcXG4gKlxcblxcXG4gKiBAcGFyYW0ge3ZlYzN9IG5vcm1hbEVDIFRoZSBub3JtYWwgdmVjdG9yIGluIGV5ZSBjb29yZGluYXRlcy5cXG5cXFxuICogQHBhcmFtIHt2ZWMzfSB0YW5nZW50RUMgVGhlIHRhbmdlbnQgdmVjdG9yIGluIGV5ZSBjb29yZGluYXRlcy5cXG5cXFxuICogQHBhcmFtIHt2ZWMzfSBiaXRhbmdlbnRFQyBUaGUgYml0YW5nZW50IHZlY3RvciBpbiBleWUgY29vcmRpbmF0ZXMuXFxuXFxcbiAqXFxuXFxcbiAqIEByZXR1cm5zIHttYXQzfSBUaGUgbWF0cml4IHRoYXQgdHJhbnNmb3JtcyBmcm9tIHRhbmdlbnQgc3BhY2UgdG8gZXllIHNwYWNlLlxcblxcXG4gKlxcblxcXG4gKiBAZXhhbXBsZVxcblxcXG4gKiBtYXQzIHRhbmdlbnRUb0V5ZSA9IGN6bV90YW5nZW50VG9FeWVTcGFjZU1hdHJpeChub3JtYWxFQywgdGFuZ2VudEVDLCBiaXRhbmdlbnRFQyk7XFxuXFxcbiAqIHZlYzMgbm9ybWFsID0gdGFuZ2VudFRvRXllICogdGV4dHVyZTJEKG5vcm1hbE1hcCwgc3QpLnh5ejtcXG5cXFxuICovXFxuXFxcbm1hdDMgY3ptX3RhbmdlbnRUb0V5ZVNwYWNlTWF0cml4KHZlYzMgbm9ybWFsRUMsIHZlYzMgdGFuZ2VudEVDLCB2ZWMzIGJpdGFuZ2VudEVDKVxcblxcXG57XFxuXFxcbiAgICB2ZWMzIG5vcm1hbCA9IG5vcm1hbGl6ZShub3JtYWxFQyk7XFxuXFxcbiAgICB2ZWMzIHRhbmdlbnQgPSBub3JtYWxpemUodGFuZ2VudEVDKTtcXG5cXFxuICAgIHZlYzMgYml0YW5nZW50ID0gbm9ybWFsaXplKGJpdGFuZ2VudEVDKTtcXG5cXFxuICAgIHJldHVybiBtYXQzKHRhbmdlbnQueCAgLCB0YW5nZW50LnkgICwgdGFuZ2VudC56LFxcblxcXG4gICAgICAgICAgICAgICAgYml0YW5nZW50LngsIGJpdGFuZ2VudC55LCBiaXRhbmdlbnQueixcXG5cXFxuICAgICAgICAgICAgICAgIG5vcm1hbC54ICAgLCBub3JtYWwueSAgICwgbm9ybWFsLnopO1xcblxcXG59XFxuXFxcblwiO1xuIiwiLy9UaGlzIGZpbGUgaXMgYXV0b21hdGljYWxseSByZWJ1aWx0IGJ5IHRoZSBDZXNpdW0gYnVpbGQgcHJvY2Vzcy5cbmV4cG9ydCBkZWZhdWx0IFwiLyoqXFxuXFxcbiAqIFRyYW5zZm9ybXMgYSBwbGFuZS5cXG5cXFxuICogXFxuXFxcbiAqIEBuYW1lIGN6bV90cmFuc2Zvcm1QbGFuZVxcblxcXG4gKiBAZ2xzbEZ1bmN0aW9uXFxuXFxcbiAqXFxuXFxcbiAqIEBwYXJhbSB7dmVjNH0gcGxhbmUgVGhlIHBsYW5lIGluIEhlc3NpYW4gTm9ybWFsIEZvcm0uXFxuXFxcbiAqIEBwYXJhbSB7bWF0NH0gdHJhbnNmb3JtIFRoZSBpbnZlcnNlLXRyYW5zcG9zZSBvZiBhIHRyYW5zZm9ybWF0aW9uIG1hdHJpeC5cXG5cXFxuICovXFxuXFxcbnZlYzQgY3ptX3RyYW5zZm9ybVBsYW5lKHZlYzQgcGxhbmUsIG1hdDQgdHJhbnNmb3JtKSB7XFxuXFxcbiAgICB2ZWM0IHRyYW5zZm9ybWVkUGxhbmUgPSB0cmFuc2Zvcm0gKiBwbGFuZTtcXG5cXFxuICAgIC8vIENvbnZlcnQgdGhlIHRyYW5zZm9ybWVkIHBsYW5lIHRvIEhlc3NpYW4gTm9ybWFsIEZvcm1cXG5cXFxuICAgIGZsb2F0IG5vcm1hbE1hZ25pdHVkZSA9IGxlbmd0aCh0cmFuc2Zvcm1lZFBsYW5lLnh5eik7XFxuXFxcbiAgICByZXR1cm4gdHJhbnNmb3JtZWRQbGFuZSAvIG5vcm1hbE1hZ25pdHVkZTtcXG5cXFxufVxcblxcXG5cIjtcbiIsIi8vVGhpcyBmaWxlIGlzIGF1dG9tYXRpY2FsbHkgcmVidWlsdCBieSB0aGUgQ2VzaXVtIGJ1aWxkIHByb2Nlc3MuXG5leHBvcnQgZGVmYXVsdCBcIi8qKlxcblxcXG4gKiBUcmFuc2xhdGVzIGEgcG9zaXRpb24gKG9yIGFueSA8Y29kZT52ZWMzPC9jb2RlPikgdGhhdCB3YXMgZW5jb2RlZCB3aXRoIHtAbGluayBFbmNvZGVkQ2FydGVzaWFuM30sXFxuXFxcbiAqIGFuZCB0aGVuIHByb3ZpZGVkIHRvIHRoZSBzaGFkZXIgYXMgc2VwYXJhdGUgPGNvZGU+aGlnaDwvY29kZT4gYW5kIDxjb2RlPmxvdzwvY29kZT4gYml0cyB0b1xcblxcXG4gKiBiZSByZWxhdGl2ZSB0byB0aGUgZXllLiAgQXMgc2hvd24gaW4gdGhlIGV4YW1wbGUsIHRoZSBwb3NpdGlvbiBjYW4gdGhlbiBiZSB0cmFuc2Zvcm1lZCBpbiBleWVcXG5cXFxuICogb3IgY2xpcCBjb29yZGluYXRlcyB1c2luZyB7QGxpbmsgY3ptX21vZGVsVmlld1JlbGF0aXZlVG9FeWV9IG9yIHtAbGluayBjem1fbW9kZWxWaWV3UHJvamVjdGlvblJlbGF0aXZlVG9FeWV9LFxcblxcXG4gKiByZXNwZWN0aXZlbHkuXFxuXFxcbiAqIDxwPlxcblxcXG4gKiBUaGlzIHRlY2huaXF1ZSwgY2FsbGVkIEdQVSBSVEUsIGVsaW1pbmF0ZXMgaml0dGVyaW5nIGFydGlmYWN0cyB3aGVuIHVzaW5nIGxhcmdlIGNvb3JkaW5hdGVzIGFzXFxuXFxcbiAqIGRlc2NyaWJlZCBpbiB7QGxpbmsgaHR0cDovL2hlbHAuYWdpLmNvbS9BR0lDb21wb25lbnRzL2h0bWwvQmxvZ1ByZWNpc2lvbnNQcmVjaXNpb25zLmh0bXxQcmVjaXNpb25zLCBQcmVjaXNpb25zfS5cXG5cXFxuICogPC9wPlxcblxcXG4gKlxcblxcXG4gKiBAbmFtZSBjem1fdHJhbnNsYXRlUmVsYXRpdmVUb0V5ZVxcblxcXG4gKiBAZ2xzbEZ1bmN0aW9uXFxuXFxcbiAqXFxuXFxcbiAqIEBwYXJhbSB7dmVjM30gaGlnaCBUaGUgcG9zaXRpb24ncyBoaWdoIGJpdHMuXFxuXFxcbiAqIEBwYXJhbSB7dmVjM30gbG93IFRoZSBwb3NpdGlvbidzIGxvdyBiaXRzLlxcblxcXG4gKiBAcmV0dXJucyB7dmVjM30gVGhlIHBvc2l0aW9uIHRyYW5zbGF0ZWQgdG8gYmUgcmVsYXRpdmUgdG8gdGhlIGNhbWVyYSdzIHBvc2l0aW9uLlxcblxcXG4gKlxcblxcXG4gKiBAZXhhbXBsZVxcblxcXG4gKiBhdHRyaWJ1dGUgdmVjMyBwb3NpdGlvbkhpZ2g7XFxuXFxcbiAqIGF0dHJpYnV0ZSB2ZWMzIHBvc2l0aW9uTG93O1xcblxcXG4gKlxcblxcXG4gKiB2b2lkIG1haW4oKVxcblxcXG4gKiB7XFxuXFxcbiAqICAgdmVjNCBwID0gY3ptX3RyYW5zbGF0ZVJlbGF0aXZlVG9FeWUocG9zaXRpb25IaWdoLCBwb3NpdGlvbkxvdyk7XFxuXFxcbiAqICAgZ2xfUG9zaXRpb24gPSBjem1fbW9kZWxWaWV3UHJvamVjdGlvblJlbGF0aXZlVG9FeWUgKiBwO1xcblxcXG4gKiB9XFxuXFxcbiAqXFxuXFxcbiAqIEBzZWUgY3ptX21vZGVsVmlld1JlbGF0aXZlVG9FeWVcXG5cXFxuICogQHNlZSBjem1fbW9kZWxWaWV3UHJvamVjdGlvblJlbGF0aXZlVG9FeWVcXG5cXFxuICogQHNlZSBjem1fY29tcHV0ZVBvc2l0aW9uXFxuXFxcbiAqIEBzZWUgRW5jb2RlZENhcnRlc2lhbjNcXG5cXFxuICovXFxuXFxcbnZlYzQgY3ptX3RyYW5zbGF0ZVJlbGF0aXZlVG9FeWUodmVjMyBoaWdoLCB2ZWMzIGxvdylcXG5cXFxue1xcblxcXG4gICAgdmVjMyBoaWdoRGlmZmVyZW5jZSA9IGhpZ2ggLSBjem1fZW5jb2RlZENhbWVyYVBvc2l0aW9uTUNIaWdoO1xcblxcXG4gICAgdmVjMyBsb3dEaWZmZXJlbmNlID0gbG93IC0gY3ptX2VuY29kZWRDYW1lcmFQb3NpdGlvbk1DTG93O1xcblxcXG5cXG5cXFxuICAgIHJldHVybiB2ZWM0KGhpZ2hEaWZmZXJlbmNlICsgbG93RGlmZmVyZW5jZSwgMS4wKTtcXG5cXFxufVxcblxcXG5cIjtcbiIsIi8vVGhpcyBmaWxlIGlzIGF1dG9tYXRpY2FsbHkgcmVidWlsdCBieSB0aGUgQ2VzaXVtIGJ1aWxkIHByb2Nlc3MuXG5leHBvcnQgZGVmYXVsdCBcIi8qKlxcblxcXG4gKiBAcHJpdmF0ZVxcblxcXG4gKi9cXG5cXFxudmVjNCBjem1fdHJhbnNsdWNlbnRQaG9uZyh2ZWMzIHRvRXllLCBjem1fbWF0ZXJpYWwgbWF0ZXJpYWwsIHZlYzMgbGlnaHREaXJlY3Rpb25FQylcXG5cXFxue1xcblxcXG4gICAgLy8gRGlmZnVzZSBmcm9tIGRpcmVjdGlvbmFsIGxpZ2h0IHNvdXJjZXMgYXQgZXllIChmb3IgdG9wLWRvd24gYW5kIGhvcml6b24gdmlld3MpXFxuXFxcbiAgICBmbG9hdCBkaWZmdXNlID0gY3ptX2dldExhbWJlcnREaWZmdXNlKHZlYzMoMC4wLCAwLjAsIDEuMCksIG1hdGVyaWFsLm5vcm1hbCk7XFxuXFxcblxcblxcXG4gICAgaWYgKGN6bV9zY2VuZU1vZGUgPT0gY3ptX3NjZW5lTW9kZTNEKSB7XFxuXFxcbiAgICAgICAgLy8gKGFuZCBob3Jpem9uIHZpZXdzIGluIDNEKVxcblxcXG4gICAgICAgIGRpZmZ1c2UgKz0gY3ptX2dldExhbWJlcnREaWZmdXNlKHZlYzMoMC4wLCAxLjAsIDAuMCksIG1hdGVyaWFsLm5vcm1hbCk7XFxuXFxcbiAgICB9XFxuXFxcblxcblxcXG4gICAgZGlmZnVzZSA9IGNsYW1wKGRpZmZ1c2UsIDAuMCwgMS4wKTtcXG5cXFxuXFxuXFxcbiAgICBmbG9hdCBzcGVjdWxhciA9IGN6bV9nZXRTcGVjdWxhcihsaWdodERpcmVjdGlvbkVDLCB0b0V5ZSwgbWF0ZXJpYWwubm9ybWFsLCBtYXRlcmlhbC5zaGluaW5lc3MpO1xcblxcXG5cXG5cXFxuICAgIC8vIFRlbXBvcmFyeSB3b3JrYXJvdW5kIGZvciBhZGRpbmcgYW1iaWVudC5cXG5cXFxuICAgIHZlYzMgbWF0ZXJpYWxEaWZmdXNlID0gbWF0ZXJpYWwuZGlmZnVzZSAqIDAuNTtcXG5cXFxuXFxuXFxcbiAgICB2ZWMzIGFtYmllbnQgPSBtYXRlcmlhbERpZmZ1c2U7XFxuXFxcbiAgICB2ZWMzIGNvbG9yID0gYW1iaWVudCArIG1hdGVyaWFsLmVtaXNzaW9uO1xcblxcXG4gICAgY29sb3IgKz0gbWF0ZXJpYWxEaWZmdXNlICogZGlmZnVzZSAqIGN6bV9saWdodENvbG9yO1xcblxcXG4gICAgY29sb3IgKz0gbWF0ZXJpYWwuc3BlY3VsYXIgKiBzcGVjdWxhciAqIGN6bV9saWdodENvbG9yO1xcblxcXG5cXG5cXFxuICAgIHJldHVybiB2ZWM0KGNvbG9yLCBtYXRlcmlhbC5hbHBoYSk7XFxuXFxcbn1cXG5cXFxuXCI7XG4iLCIvL1RoaXMgZmlsZSBpcyBhdXRvbWF0aWNhbGx5IHJlYnVpbHQgYnkgdGhlIENlc2l1bSBidWlsZCBwcm9jZXNzLlxuZXhwb3J0IGRlZmF1bHQgXCIvKipcXG5cXFxuICogUmV0dXJucyB0aGUgdHJhbnNwb3NlIG9mIHRoZSBtYXRyaXguICBUaGUgaW5wdXQgPGNvZGU+bWF0cml4PC9jb2RlPiBjYW4gYmVcXG5cXFxuICogYSA8Y29kZT5tYXQyPC9jb2RlPiwgPGNvZGU+bWF0MzwvY29kZT4sIG9yIDxjb2RlPm1hdDQ8L2NvZGU+LlxcblxcXG4gKlxcblxcXG4gKiBAbmFtZSBjem1fdHJhbnNwb3NlXFxuXFxcbiAqIEBnbHNsRnVuY3Rpb25cXG5cXFxuICpcXG5cXFxuICogQHBhcmFtIHt9IG1hdHJpeCBUaGUgbWF0cml4IHRvIHRyYW5zcG9zZS5cXG5cXFxuICpcXG5cXFxuICogQHJldHVybnMge30gVGhlIHRyYW5zcG9zZWQgbWF0cml4LlxcblxcXG4gKlxcblxcXG4gKiBAZXhhbXBsZVxcblxcXG4gKiAvLyBHTFNMIGRlY2xhcmF0aW9uc1xcblxcXG4gKiBtYXQyIGN6bV90cmFuc3Bvc2UobWF0MiBtYXRyaXgpO1xcblxcXG4gKiBtYXQzIGN6bV90cmFuc3Bvc2UobWF0MyBtYXRyaXgpO1xcblxcXG4gKiBtYXQ0IGN6bV90cmFuc3Bvc2UobWF0NCBtYXRyaXgpO1xcblxcXG4gKlxcblxcXG4gKiAvLyBUcmFuc3Bvc2UgYSAzeDMgcm90YXRpb24gbWF0cml4IHRvIGZpbmQgaXRzIGludmVyc2UuXFxuXFxcbiAqIG1hdDMgZWFzdE5vcnRoVXBUb0V5ZSA9IGN6bV9lYXN0Tm9ydGhVcFRvRXllQ29vcmRpbmF0ZXMoXFxuXFxcbiAqICAgICBwb3NpdGlvbk1DLCBub3JtYWxFQyk7XFxuXFxcbiAqIG1hdDMgZXllVG9FYXN0Tm9ydGhVcCA9IGN6bV90cmFuc3Bvc2UoZWFzdE5vcnRoVXBUb0V5ZSk7XFxuXFxcbiAqL1xcblxcXG5tYXQyIGN6bV90cmFuc3Bvc2UobWF0MiBtYXRyaXgpXFxuXFxcbntcXG5cXFxuICAgIHJldHVybiBtYXQyKFxcblxcXG4gICAgICAgIG1hdHJpeFswXVswXSwgbWF0cml4WzFdWzBdLFxcblxcXG4gICAgICAgIG1hdHJpeFswXVsxXSwgbWF0cml4WzFdWzFdKTtcXG5cXFxufVxcblxcXG5cXG5cXFxubWF0MyBjem1fdHJhbnNwb3NlKG1hdDMgbWF0cml4KVxcblxcXG57XFxuXFxcbiAgICByZXR1cm4gbWF0MyhcXG5cXFxuICAgICAgICBtYXRyaXhbMF1bMF0sIG1hdHJpeFsxXVswXSwgbWF0cml4WzJdWzBdLFxcblxcXG4gICAgICAgIG1hdHJpeFswXVsxXSwgbWF0cml4WzFdWzFdLCBtYXRyaXhbMl1bMV0sXFxuXFxcbiAgICAgICAgbWF0cml4WzBdWzJdLCBtYXRyaXhbMV1bMl0sIG1hdHJpeFsyXVsyXSk7XFxuXFxcbn1cXG5cXFxuXFxuXFxcbm1hdDQgY3ptX3RyYW5zcG9zZShtYXQ0IG1hdHJpeClcXG5cXFxue1xcblxcXG4gICAgcmV0dXJuIG1hdDQoXFxuXFxcbiAgICAgICAgbWF0cml4WzBdWzBdLCBtYXRyaXhbMV1bMF0sIG1hdHJpeFsyXVswXSwgbWF0cml4WzNdWzBdLFxcblxcXG4gICAgICAgIG1hdHJpeFswXVsxXSwgbWF0cml4WzFdWzFdLCBtYXRyaXhbMl1bMV0sIG1hdHJpeFszXVsxXSxcXG5cXFxuICAgICAgICBtYXRyaXhbMF1bMl0sIG1hdHJpeFsxXVsyXSwgbWF0cml4WzJdWzJdLCBtYXRyaXhbM11bMl0sXFxuXFxcbiAgICAgICAgbWF0cml4WzBdWzNdLCBtYXRyaXhbMV1bM10sIG1hdHJpeFsyXVszXSwgbWF0cml4WzNdWzNdKTtcXG5cXFxufVxcblxcXG5cIjtcbiIsIi8vVGhpcyBmaWxlIGlzIGF1dG9tYXRpY2FsbHkgcmVidWlsdCBieSB0aGUgQ2VzaXVtIGJ1aWxkIHByb2Nlc3MuXG5leHBvcnQgZGVmYXVsdCBcIi8qKlxcblxcXG4gKiBVbnBhY2tzIGEgdmVjNCBkZXB0aCB2YWx1ZSB0byBhIGZsb2F0IGluIFswLCAxKSByYW5nZS5cXG5cXFxuICpcXG5cXFxuICogQG5hbWUgY3ptX3VucGFja0RlcHRoXFxuXFxcbiAqIEBnbHNsRnVuY3Rpb25cXG5cXFxuICpcXG5cXFxuICogQHBhcmFtIHt2ZWM0fSBwYWNrZWREZXB0aCBUaGUgcGFja2VkIGRlcHRoLlxcblxcXG4gKlxcblxcXG4gKiBAcmV0dXJucyB7ZmxvYXR9IFRoZSBmbG9hdGluZy1wb2ludCBkZXB0aCBpbiBbMCwgMSkgcmFuZ2UuXFxuXFxcbiAqL1xcblxcXG4gZmxvYXQgY3ptX3VucGFja0RlcHRoKHZlYzQgcGFja2VkRGVwdGgpXFxuXFxcbiB7XFxuXFxcbiAgICAvLyBTZWUgQXJhcyBQcmFuY2tldmnEjWl1cycgcG9zdCBFbmNvZGluZyBGbG9hdHMgdG8gUkdCQVxcblxcXG4gICAgLy8gaHR0cDovL2FyYXMtcC5pbmZvL2Jsb2cvMjAwOS8wNy8zMC9lbmNvZGluZy1mbG9hdHMtdG8tcmdiYS10aGUtZmluYWwvXFxuXFxcbiAgICByZXR1cm4gZG90KHBhY2tlZERlcHRoLCB2ZWM0KDEuMCwgMS4wIC8gMjU1LjAsIDEuMCAvIDY1MDI1LjAsIDEuMCAvIDE2NTgxMzc1LjApKTtcXG5cXFxuIH1cXG5cXFxuXCI7XG4iLCIvL1RoaXMgZmlsZSBpcyBhdXRvbWF0aWNhbGx5IHJlYnVpbHQgYnkgdGhlIENlc2l1bSBidWlsZCBwcm9jZXNzLlxuZXhwb3J0IGRlZmF1bHQgXCIvKipcXG5cXFxuICogVW5wYWNrIGFuIElFRUUgNzU0IHNpbmdsZS1wcmVjaXNpb24gZmxvYXQgdGhhdCBpcyBwYWNrZWQgYXMgYSBsaXR0bGUtZW5kaWFuIHVuc2lnbmVkIG5vcm1hbGl6ZWQgdmVjNC5cXG5cXFxuICpcXG5cXFxuICogQG5hbWUgY3ptX3VucGFja0Zsb2F0XFxuXFxcbiAqIEBnbHNsRnVuY3Rpb25cXG5cXFxuICpcXG5cXFxuICogQHBhcmFtIHt2ZWM0fSBwYWNrZWRGbG9hdCBUaGUgcGFja2VkIGZsb2F0LlxcblxcXG4gKlxcblxcXG4gKiBAcmV0dXJucyB7ZmxvYXR9IFRoZSBmbG9hdGluZy1wb2ludCBkZXB0aCBpbiBhcmJpdHJhcnkgcmFuZ2UuXFxuXFxcbiAqL1xcblxcXG5mbG9hdCBjem1fdW5wYWNrRmxvYXQodmVjNCBwYWNrZWRGbG9hdClcXG5cXFxue1xcblxcXG4gICAgLy8gQ29udmVydCB0byBbMC4wLCAyNTUuMF0gYW5kIHJvdW5kIHRvIGludGVnZXJcXG5cXFxuICAgIHBhY2tlZEZsb2F0ID0gZmxvb3IocGFja2VkRmxvYXQgKiAyNTUuMCArIDAuNSk7XFxuXFxcbiAgICBmbG9hdCBzaWduID0gMS4wIC0gc3RlcCgxMjguMCwgcGFja2VkRmxvYXRbM10pICogMi4wO1xcblxcXG4gICAgZmxvYXQgZXhwb25lbnQgPSAyLjAgKiBtb2QocGFja2VkRmxvYXRbM10sIDEyOC4wKSArIHN0ZXAoMTI4LjAsIHBhY2tlZEZsb2F0WzJdKSAtIDEyNy4wOyAgICBcXG5cXFxuICAgIGlmIChleHBvbmVudCA9PSAtMTI3LjApXFxuXFxcbiAgICB7XFxuXFxcbiAgICAgICAgcmV0dXJuIDAuMDtcXG5cXFxuICAgIH1cXG5cXFxuICAgIGZsb2F0IG1hbnRpc3NhID0gbW9kKHBhY2tlZEZsb2F0WzJdLCAxMjguMCkgKiA2NTUzNi4wICsgcGFja2VkRmxvYXRbMV0gKiAyNTYuMCArIHBhY2tlZEZsb2F0WzBdICsgZmxvYXQoMHg4MDAwMDApO1xcblxcXG4gICAgZmxvYXQgcmVzdWx0ID0gc2lnbiAqIGV4cDIoZXhwb25lbnQgLSAyMy4wKSAqIG1hbnRpc3NhO1xcblxcXG4gICAgcmV0dXJuIHJlc3VsdDtcXG5cXFxufVxcblxcXG5cIjtcbiIsIi8vVGhpcyBmaWxlIGlzIGF1dG9tYXRpY2FsbHkgcmVidWlsdCBieSB0aGUgQ2VzaXVtIGJ1aWxkIHByb2Nlc3MuXG5leHBvcnQgZGVmYXVsdCBcIiNpZmRlZiBMT0dfREVQVEhcXG5cXFxuLy8gMS4wIGF0IHRoZSBuZWFyIHBsYW5lLCBpbmNyZWFzaW5nIGxpbmVhcmx5IGZyb20gdGhlcmUuXFxuXFxcbnZhcnlpbmcgZmxvYXQgdl9kZXB0aEZyb21OZWFyUGx1c09uZTtcXG5cXFxuI2lmZGVmIFNIQURPV19NQVBcXG5cXFxudmFyeWluZyB2ZWMzIHZfbG9nUG9zaXRpb25FQztcXG5cXFxuI2VuZGlmXFxuXFxcbiNlbmRpZlxcblxcXG5cXG5cXFxudmVjNCBjem1fdXBkYXRlUG9zaXRpb25EZXB0aCh2ZWM0IGNvb3Jkcykge1xcblxcXG4jaWYgZGVmaW5lZChMT0dfREVQVEgpXFxuXFxcblxcblxcXG4jaWZkZWYgU0hBRE9XX01BUFxcblxcXG4gICAgdmVjMyBsb2dQb3NpdGlvbkVDID0gKGN6bV9pbnZlcnNlUHJvamVjdGlvbiAqIGNvb3JkcykueHl6O1xcblxcXG4gICAgdl9sb2dQb3NpdGlvbkVDID0gbG9nUG9zaXRpb25FQztcXG5cXFxuI2VuZGlmXFxuXFxcblxcblxcXG4gICAgLy8gV2l0aCB0aGUgdmVyeSBoaWdoIGZhci9uZWFyIHJhdGlvcyB1c2VkIHdpdGggdGhlIGxvZ2FyaXRobWljIGRlcHRoXFxuXFxcbiAgICAvLyBidWZmZXIsIGZsb2F0aW5nIHBvaW50IHJvdW5kaW5nIGVycm9ycyBjYW4gY2F1c2UgbGluZWFyIGRlcHRoIHZhbHVlc1xcblxcXG4gICAgLy8gdG8gZW5kIHVwIG9uIHRoZSB3cm9uZyBzaWRlIG9mIHRoZSBmYXIgcGxhbmUsIGV2ZW4gZm9yIHZlcnRpY2VzIHRoYXRcXG5cXFxuICAgIC8vIGFyZSByZWFsbHkgbm93aGVyZSBuZWFyIGl0LiBTaW5jZSB3ZSBhbHdheXMgd3JpdGUgYSBjb3JyZWN0IGxvZ2FyaXRobWljXFxuXFxcbiAgICAvLyBkZXB0aCB2YWx1ZSBpbiB0aGUgZnJhZ21lbnQgc2hhZGVyIGFueXdheSwgd2UganVzdCBuZWVkIHRvIG1ha2Ugc3VyZVxcblxcXG4gICAgLy8gc3VjaCBlcnJvcnMgZG9uJ3QgY2F1c2UgdGhlIHByaW1pdGl2ZSB0byBiZSBjbGlwcGVkIGVudGlyZWx5IGJlZm9yZVxcblxcXG4gICAgLy8gd2UgZXZlbiBnZXQgdG8gdGhlIGZyYWdtZW50IHNoYWRlci5cXG5cXFxuICAgIGNvb3Jkcy56ID0gY2xhbXAoY29vcmRzLnogLyBjb29yZHMudywgLTEuMCwgMS4wKSAqIGNvb3Jkcy53O1xcblxcXG4jZW5kaWZcXG5cXFxuXFxuXFxcbiAgICByZXR1cm4gY29vcmRzO1xcblxcXG59XFxuXFxcblxcblxcXG4vKipcXG5cXFxuICogV3JpdGVzIHRoZSBsb2dhcml0aG1pYyBkZXB0aCB0byBnbF9Qb3NpdGlvbiB1c2luZyB0aGUgYWxyZWFkeSBjb21wdXRlZCBnbF9Qb3NpdGlvbi5cXG5cXFxuICpcXG5cXFxuICogQG5hbWUgY3ptX3ZlcnRleExvZ0RlcHRoXFxuXFxcbiAqIEBnbHNsRnVuY3Rpb25cXG5cXFxuICovXFxuXFxcbnZvaWQgY3ptX3ZlcnRleExvZ0RlcHRoKClcXG5cXFxue1xcblxcXG4jaWZkZWYgTE9HX0RFUFRIXFxuXFxcbiAgICB2X2RlcHRoRnJvbU5lYXJQbHVzT25lID0gKGdsX1Bvc2l0aW9uLncgLSBjem1fY3VycmVudEZydXN0dW0ueCkgKyAxLjA7XFxuXFxcbiAgICBnbF9Qb3NpdGlvbiA9IGN6bV91cGRhdGVQb3NpdGlvbkRlcHRoKGdsX1Bvc2l0aW9uKTtcXG5cXFxuI2VuZGlmXFxuXFxcbn1cXG5cXFxuXFxuXFxcbi8qKlxcblxcXG4gKiBXcml0ZXMgdGhlIGxvZ2FyaXRobWljIGRlcHRoIHRvIGdsX1Bvc2l0aW9uIHVzaW5nIHRoZSBwcm92aWRlZCBjbGlwIGNvb3JkaW5hdGVzLlxcblxcXG4gKiA8cD5cXG5cXFxuICogQW4gZXhhbXBsZSB1c2UgY2FzZSBmb3IgdGhpcyBmdW5jdGlvbiB3b3VsZCBiZSBtb3ZpbmcgdGhlIHZlcnRleCBpbiB3aW5kb3cgY29vcmRpbmF0ZXNcXG5cXFxuICogYmVmb3JlIGNvbnZlcnRpbmcgYmFjayB0byBjbGlwIGNvb3JkaW5hdGVzLiBVc2UgdGhlIG9yaWdpbmFsIHZlcnRleCBjbGlwIGNvb3JkaW5hdGVzLlxcblxcXG4gKiA8L3A+XFxuXFxcbiAqIEBuYW1lIGN6bV92ZXJ0ZXhMb2dEZXB0aFxcblxcXG4gKiBAZ2xzbEZ1bmN0aW9uXFxuXFxcbiAqXFxuXFxcbiAqIEBwYXJhbSB7dmVjNH0gY2xpcENvb3JkcyBUaGUgdmVydGV4IGluIGNsaXAgY29vcmRpbmF0ZXMuXFxuXFxcbiAqXFxuXFxcbiAqIEBleGFtcGxlXFxuXFxcbiAqIGN6bV92ZXJ0ZXhMb2dEZXB0aChjem1fcHJvamVjdGlvbiAqIHZlYzQocG9zaXRpb25FeWVDb29yZGluYXRlcywgMS4wKSk7XFxuXFxcbiAqL1xcblxcXG52b2lkIGN6bV92ZXJ0ZXhMb2dEZXB0aCh2ZWM0IGNsaXBDb29yZHMpXFxuXFxcbntcXG5cXFxuI2lmZGVmIExPR19ERVBUSFxcblxcXG4gICAgdl9kZXB0aEZyb21OZWFyUGx1c09uZSA9IChjbGlwQ29vcmRzLncgLSBjem1fY3VycmVudEZydXN0dW0ueCkgKyAxLjA7XFxuXFxcbiAgICBjem1fdXBkYXRlUG9zaXRpb25EZXB0aChjbGlwQ29vcmRzKTtcXG5cXFxuI2VuZGlmXFxuXFxcbn1cXG5cXFxuXCI7XG4iLCIvL1RoaXMgZmlsZSBpcyBhdXRvbWF0aWNhbGx5IHJlYnVpbHQgYnkgdGhlIENlc2l1bSBidWlsZCBwcm9jZXNzLlxuZXhwb3J0IGRlZmF1bHQgXCIvKipcXG5cXFxuICogVHJhbnNmb3JtcyBhIHBvc2l0aW9uIGZyb20gd2luZG93IHRvIGV5ZSBjb29yZGluYXRlcy5cXG5cXFxuICogVGhlIHRyYW5zZm9ybSBmcm9tIHdpbmRvdyB0byBub3JtYWxpemVkIGRldmljZSBjb29yZGluYXRlcyBpcyBkb25lIHVzaW5nIGNvbXBvbmVudHNcXG5cXFxuICogb2YgKEBsaW5rIGN6bV92aWV3cG9ydH0gYW5kIHtAbGluayBjem1fdmlld3BvcnRUcmFuc2Zvcm1hdGlvbn0gaW5zdGVhZCBvZiBjYWxjdWxhdGluZ1xcblxcXG4gKiB0aGUgaW52ZXJzZSBvZiA8Y29kZT5jem1fdmlld3BvcnRUcmFuc2Zvcm1hdGlvbjwvY29kZT4uIFRoZSB0cmFuc2Zvcm1hdGlvbiBmcm9tXFxuXFxcbiAqIG5vcm1hbGl6ZWQgZGV2aWNlIGNvb3JkaW5hdGVzIHRvIGNsaXAgY29vcmRpbmF0ZXMgaXMgZG9uZSB1c2luZyA8Y29kZT5mcmFnbWVudENvb3JkaW5hdGUudzwvY29kZT4sXFxuXFxcbiAqIHdoaWNoIGlzIGV4cGVjdGVkIHRvIGJlIHRoZSBzY2FsYXIgdXNlZCBpbiB0aGUgcGVyc3BlY3RpdmUgZGl2aWRlLiBUaGUgdHJhbnNmb3JtYXRpb25cXG5cXFxuICogZnJvbSBjbGlwIHRvIGV5ZSBjb29yZGluYXRlcyBpcyBkb25lIHVzaW5nIHtAbGluayBjem1faW52ZXJzZVByb2plY3Rpb259LlxcblxcXG4gKlxcblxcXG4gKiBAbmFtZSBjem1fd2luZG93VG9FeWVDb29yZGluYXRlc1xcblxcXG4gKiBAZ2xzbEZ1bmN0aW9uXFxuXFxcbiAqXFxuXFxcbiAqIEBwYXJhbSB7dmVjNH0gZnJhZ21lbnRDb29yZGluYXRlIFRoZSBwb3NpdGlvbiBpbiB3aW5kb3cgY29vcmRpbmF0ZXMgdG8gdHJhbnNmb3JtLlxcblxcXG4gKlxcblxcXG4gKiBAcmV0dXJucyB7dmVjNH0gVGhlIHRyYW5zZm9ybWVkIHBvc2l0aW9uIGluIGV5ZSBjb29yZGluYXRlcy5cXG5cXFxuICpcXG5cXFxuICogQHNlZSBjem1fbW9kZWxUb1dpbmRvd0Nvb3JkaW5hdGVzXFxuXFxcbiAqIEBzZWUgY3ptX2V5ZVRvV2luZG93Q29vcmRpbmF0ZXNcXG5cXFxuICogQHNlZSBjem1faW52ZXJzZVByb2plY3Rpb25cXG5cXFxuICogQHNlZSBjem1fdmlld3BvcnRcXG5cXFxuICogQHNlZSBjem1fdmlld3BvcnRUcmFuc2Zvcm1hdGlvblxcblxcXG4gKlxcblxcXG4gKiBAZXhhbXBsZVxcblxcXG4gKiB2ZWM0IHBvc2l0aW9uRUMgPSBjem1fd2luZG93VG9FeWVDb29yZGluYXRlcyhnbF9GcmFnQ29vcmQpO1xcblxcXG4gKi9cXG5cXFxudmVjNCBjem1fd2luZG93VG9FeWVDb29yZGluYXRlcyh2ZWM0IGZyYWdtZW50Q29vcmRpbmF0ZSlcXG5cXFxue1xcblxcXG4gICAgLy8gUmVjb25zdHJ1Y3QgTkRDIGNvb3JkaW5hdGVzXFxuXFxcbiAgICBmbG9hdCB4ID0gMi4wICogKGZyYWdtZW50Q29vcmRpbmF0ZS54IC0gY3ptX3ZpZXdwb3J0LngpIC8gY3ptX3ZpZXdwb3J0LnogLSAxLjA7XFxuXFxcbiAgICBmbG9hdCB5ID0gMi4wICogKGZyYWdtZW50Q29vcmRpbmF0ZS55IC0gY3ptX3ZpZXdwb3J0LnkpIC8gY3ptX3ZpZXdwb3J0LncgLSAxLjA7XFxuXFxcbiAgICBmbG9hdCB6ID0gKGZyYWdtZW50Q29vcmRpbmF0ZS56IC0gY3ptX3ZpZXdwb3J0VHJhbnNmb3JtYXRpb25bM11bMl0pIC8gY3ptX3ZpZXdwb3J0VHJhbnNmb3JtYXRpb25bMl1bMl07XFxuXFxcbiAgICB2ZWM0IHEgPSB2ZWM0KHgsIHksIHosIDEuMCk7XFxuXFxcblxcblxcXG4gICAgLy8gUmV2ZXJzZSB0aGUgcGVyc3BlY3RpdmUgZGl2aXNpb24gdG8gb2J0YWluIGNsaXAgY29vcmRpbmF0ZXMuXFxuXFxcbiAgICBxIC89IGZyYWdtZW50Q29vcmRpbmF0ZS53O1xcblxcXG5cXG5cXFxuICAgIC8vIFJldmVyc2UgdGhlIHByb2plY3Rpb24gdHJhbnNmb3JtYXRpb24gdG8gb2J0YWluIGV5ZSBjb29yZGluYXRlcy5cXG5cXFxuICAgIGlmICghKGN6bV9pbnZlcnNlUHJvamVjdGlvbiA9PSBtYXQ0KDAuMCkpKSAvLyBJRSBhbmQgRWRnZSBzb21ldGltZXMgZG8gc29tZXRoaW5nIHdlaXJkIHdpdGggIT0gYmV0d2VlbiBtYXQ0c1xcblxcXG4gICAge1xcblxcXG4gICAgICAgIHEgPSBjem1faW52ZXJzZVByb2plY3Rpb24gKiBxO1xcblxcXG4gICAgfVxcblxcXG4gICAgZWxzZVxcblxcXG4gICAge1xcblxcXG4gICAgICAgIGZsb2F0IHRvcCA9IGN6bV9mcnVzdHVtUGxhbmVzLng7XFxuXFxcbiAgICAgICAgZmxvYXQgYm90dG9tID0gY3ptX2ZydXN0dW1QbGFuZXMueTtcXG5cXFxuICAgICAgICBmbG9hdCBsZWZ0ID0gY3ptX2ZydXN0dW1QbGFuZXMuejtcXG5cXFxuICAgICAgICBmbG9hdCByaWdodCA9IGN6bV9mcnVzdHVtUGxhbmVzLnc7XFxuXFxcblxcblxcXG4gICAgICAgIGZsb2F0IG5lYXIgPSBjem1fY3VycmVudEZydXN0dW0ueDtcXG5cXFxuICAgICAgICBmbG9hdCBmYXIgPSBjem1fY3VycmVudEZydXN0dW0ueTtcXG5cXFxuXFxuXFxcbiAgICAgICAgcS54ID0gKHEueCAqIChyaWdodCAtIGxlZnQpICsgbGVmdCArIHJpZ2h0KSAqIDAuNTtcXG5cXFxuICAgICAgICBxLnkgPSAocS55ICogKHRvcCAtIGJvdHRvbSkgKyBib3R0b20gKyB0b3ApICogMC41O1xcblxcXG4gICAgICAgIHEueiA9IChxLnogKiAobmVhciAtIGZhcikgLSBuZWFyIC0gZmFyKSAqIDAuNTtcXG5cXFxuICAgICAgICBxLncgPSAxLjA7XFxuXFxcbiAgICB9XFxuXFxcblxcblxcXG4gICAgcmV0dXJuIHE7XFxuXFxcbn1cXG5cXFxuXFxuXFxcbi8qKlxcblxcXG4gKiBUcmFuc2Zvcm1zIGEgcG9zaXRpb24gZ2l2ZW4gYXMgd2luZG93IHgveSBhbmQgYSBkZXB0aCBvciBhIGxvZyBkZXB0aCBmcm9tIHdpbmRvdyB0byBleWUgY29vcmRpbmF0ZXMuXFxuXFxcbiAqIFRoaXMgZnVuY3Rpb24gcHJvZHVjZXMgbW9yZSBhY2N1cmF0ZSByZXN1bHRzIGZvciB3aW5kb3cgcG9zaXRpb25zIHdpdGggbG9nIGRlcHRoIHRoYW5cXG5cXFxuICogY29udmVudGlvbmFsbHkgdW5wYWNraW5nIHRoZSBsb2cgZGVwdGggdXNpbmcgY3ptX3JldmVyc2VMb2dEZXB0aCBhbmQgdXNpbmcgdGhlIHN0YW5kYXJkIHZlcnNpb25cXG5cXFxuICogb2YgY3ptX3dpbmRvd1RvRXllQ29vcmRpbmF0ZXMuXFxuXFxcbiAqXFxuXFxcbiAqIEBuYW1lIGN6bV93aW5kb3dUb0V5ZUNvb3JkaW5hdGVzXFxuXFxcbiAqIEBnbHNsRnVuY3Rpb25cXG5cXFxuICpcXG5cXFxuICogQHBhcmFtIHt2ZWMyfSBmcmFnbWVudENvb3JkaW5hdGVYWSBUaGUgWFkgcG9zaXRpb24gaW4gd2luZG93IGNvb3JkaW5hdGVzIHRvIHRyYW5zZm9ybS5cXG5cXFxuICogQHBhcmFtIHtmbG9hdH0gZGVwdGhPckxvZ0RlcHRoIEEgZGVwdGggb3IgbG9nIGRlcHRoIGZvciB0aGUgZnJhZ21lbnQuXFxuXFxcbiAqXFxuXFxcbiAqIEBzZWUgY3ptX21vZGVsVG9XaW5kb3dDb29yZGluYXRlc1xcblxcXG4gKiBAc2VlIGN6bV9leWVUb1dpbmRvd0Nvb3JkaW5hdGVzXFxuXFxcbiAqIEBzZWUgY3ptX2ludmVyc2VQcm9qZWN0aW9uXFxuXFxcbiAqIEBzZWUgY3ptX3ZpZXdwb3J0XFxuXFxcbiAqIEBzZWUgY3ptX3ZpZXdwb3J0VHJhbnNmb3JtYXRpb25cXG5cXFxuICpcXG5cXFxuICogQHJldHVybnMge3ZlYzR9IFRoZSB0cmFuc2Zvcm1lZCBwb3NpdGlvbiBpbiBleWUgY29vcmRpbmF0ZXMuXFxuXFxcbiAqL1xcblxcXG52ZWM0IGN6bV93aW5kb3dUb0V5ZUNvb3JkaW5hdGVzKHZlYzIgZnJhZ21lbnRDb29yZGluYXRlWFksIGZsb2F0IGRlcHRoT3JMb2dEZXB0aClcXG5cXFxue1xcblxcXG4gICAgLy8gU2VlIHJldmVyc2VMb2dEZXB0aC5nbHNsLiBUaGlzIGlzIHNlcGFyYXRlIHRvIHJlLXVzZSB0aGUgcG93LlxcblxcXG4jaWZkZWYgTE9HX0RFUFRIXFxuXFxcbiAgICBmbG9hdCBuZWFyID0gY3ptX2N1cnJlbnRGcnVzdHVtLng7XFxuXFxcbiAgICBmbG9hdCBmYXIgPSBjem1fY3VycmVudEZydXN0dW0ueTtcXG5cXFxuICAgIGZsb2F0IGxvZzJEZXB0aCA9IGRlcHRoT3JMb2dEZXB0aCAqIGN6bV9sb2cyRmFyRGVwdGhGcm9tTmVhclBsdXNPbmU7XFxuXFxcbiAgICBmbG9hdCBkZXB0aEZyb21OZWFyID0gcG93KDIuMCwgbG9nMkRlcHRoKSAtIDEuMDtcXG5cXFxuICAgIGZsb2F0IGRlcHRoRnJvbUNhbWVyYSA9IGRlcHRoRnJvbU5lYXIgKyBuZWFyO1xcblxcXG4gICAgdmVjNCB3aW5kb3dDb29yZCA9IHZlYzQoZnJhZ21lbnRDb29yZGluYXRlWFksIGZhciAqICgxLjAgLSBuZWFyIC8gZGVwdGhGcm9tQ2FtZXJhKSAvIChmYXIgLSBuZWFyKSwgMS4wKTtcXG5cXFxuICAgIHZlYzQgZXllQ29vcmRpbmF0ZSA9IGN6bV93aW5kb3dUb0V5ZUNvb3JkaW5hdGVzKHdpbmRvd0Nvb3JkKTtcXG5cXFxuICAgIGV5ZUNvb3JkaW5hdGUudyA9IDEuMCAvIGRlcHRoRnJvbUNhbWVyYTsgLy8gQmV0dGVyIHByZWNpc2lvblxcblxcXG4gICAgcmV0dXJuIGV5ZUNvb3JkaW5hdGU7XFxuXFxcbiNlbHNlXFxuXFxcbiAgICB2ZWM0IHdpbmRvd0Nvb3JkID0gdmVjNChmcmFnbWVudENvb3JkaW5hdGVYWSwgZGVwdGhPckxvZ0RlcHRoLCAxLjApO1xcblxcXG4gICAgdmVjNCBleWVDb29yZGluYXRlID0gY3ptX3dpbmRvd1RvRXllQ29vcmRpbmF0ZXMod2luZG93Q29vcmQpO1xcblxcXG4jZW5kaWZcXG5cXFxuICAgIHJldHVybiBleWVDb29yZGluYXRlO1xcblxcXG59XFxuXFxcblwiO1xuIiwiLy9UaGlzIGZpbGUgaXMgYXV0b21hdGljYWxseSByZWJ1aWx0IGJ5IHRoZSBDZXNpdW0gYnVpbGQgcHJvY2Vzcy5cbmV4cG9ydCBkZWZhdWx0IFwiLy8gZW11bGF0ZWQgbm9wZXJzcGVjdGl2ZVxcblxcXG4jaWYgZGVmaW5lZChHTF9FWFRfZnJhZ19kZXB0aCkgJiYgIWRlZmluZWQoTE9HX0RFUFRIKVxcblxcXG52YXJ5aW5nIGZsb2F0IHZfV2luZG93WjtcXG5cXFxuI2VuZGlmXFxuXFxcblxcblxcXG4vKipcXG5cXFxuICogRW11bGF0ZXMgR0xfREVQVEhfQ0xBTVAuIENsYW1wcyBhIGZyYWdtZW50IHRvIHRoZSBuZWFyIGFuZCBmYXIgcGxhbmVcXG5cXFxuICogYnkgd3JpdGluZyB0aGUgZnJhZ21lbnQncyBkZXB0aC4gU2VlIGN6bV9kZXB0aENsYW1wIGZvciBtb3JlIGRldGFpbHMuXFxuXFxcbiAqIDxwPlxcblxcXG4gKiBUaGUgc2hhZGVyIG11c3QgZW5hYmxlIHRoZSBHTF9FWFRfZnJhZ19kZXB0aCBleHRlbnNpb24uXFxuXFxcbiAqIDwvcD5cXG5cXFxuICpcXG5cXFxuICogQG5hbWUgY3ptX3dyaXRlRGVwdGhDbGFtcFxcblxcXG4gKiBAZ2xzbEZ1bmN0aW9uXFxuXFxcbiAqXFxuXFxcbiAqIEBleGFtcGxlXFxuXFxcbiAqIGdsX0ZyYWdDb2xvciA9IGNvbG9yO1xcblxcXG4gKiBjem1fd3JpdGVEZXB0aENsYW1wKCk7XFxuXFxcbiAqXFxuXFxcbiAqIEBzZWUgY3ptX2RlcHRoQ2xhbXBcXG5cXFxuICovXFxuXFxcbnZvaWQgY3ptX3dyaXRlRGVwdGhDbGFtcCgpXFxuXFxcbntcXG5cXFxuI2lmIGRlZmluZWQoR0xfRVhUX2ZyYWdfZGVwdGgpICYmICFkZWZpbmVkKExPR19ERVBUSClcXG5cXFxuICAgIGdsX0ZyYWdEZXB0aEVYVCA9IGNsYW1wKHZfV2luZG93WiAqIGdsX0ZyYWdDb29yZC53LCAwLjAsIDEuMCk7XFxuXFxcbiNlbmRpZlxcblxcXG59XFxuXFxcblwiO1xuIiwiLy9UaGlzIGZpbGUgaXMgYXV0b21hdGljYWxseSByZWJ1aWx0IGJ5IHRoZSBDZXNpdW0gYnVpbGQgcHJvY2Vzcy5cbmV4cG9ydCBkZWZhdWx0IFwiI2lmZGVmIExPR19ERVBUSFxcblxcXG52YXJ5aW5nIGZsb2F0IHZfZGVwdGhGcm9tTmVhclBsdXNPbmU7XFxuXFxcblxcblxcXG4jaWZkZWYgUE9MWUdPTl9PRkZTRVRcXG5cXFxudW5pZm9ybSB2ZWMyIHVfcG9seWdvbk9mZnNldDtcXG5cXFxuI2VuZGlmXFxuXFxcblxcblxcXG4jZW5kaWZcXG5cXFxuXFxuXFxcbi8qKlxcblxcXG4gKiBXcml0ZXMgdGhlIGZyYWdtZW50IGRlcHRoIHRvIHRoZSBsb2dhcml0aG1pYyBkZXB0aCBidWZmZXIuXFxuXFxcbiAqIDxwPlxcblxcXG4gKiBVc2UgdGhpcyB3aGVuIHRoZSB2ZXJ0ZXggc2hhZGVyIGRvZXMgbm90IGNhbGwge0BsaW5rIGN6bV92ZXJ0ZXhsb2dEZXB0aH0sIGZvciBleGFtcGxlLCB3aGVuXFxuXFxcbiAqIHJheS1jYXN0aW5nIGdlb21ldHJ5IHVzaW5nIGEgZnVsbCBzY3JlZW4gcXVhZC5cXG5cXFxuICogPC9wPlxcblxcXG4gKiBAbmFtZSBjem1fd3JpdGVMb2dEZXB0aFxcblxcXG4gKiBAZ2xzbEZ1bmN0aW9uXFxuXFxcbiAqXFxuXFxcbiAqIEBwYXJhbSB7ZmxvYXR9IGRlcHRoIFRoZSBkZXB0aCBjb29yZGluYXRlLCB3aGVyZSAxLjAgaXMgb24gdGhlIG5lYXIgcGxhbmUgYW5kXFxuXFxcbiAqICAgICAgICAgICAgICAgICAgICAgIGRlcHRoIGluY3JlYXNlcyBpbiBleWUtc3BhY2UgdW5pdHMgZnJvbSB0aGVyZVxcblxcXG4gKlxcblxcXG4gKiBAZXhhbXBsZVxcblxcXG4gKiBjem1fd3JpdGVMb2dEZXB0aCgoY3ptX3Byb2plY3Rpb24gKiB2X3Bvc2l0aW9uRXllQ29vcmRpbmF0ZXMpLncgKyAxLjApO1xcblxcXG4gKi9cXG5cXFxudm9pZCBjem1fd3JpdGVMb2dEZXB0aChmbG9hdCBkZXB0aClcXG5cXFxue1xcblxcXG4jaWYgZGVmaW5lZChHTF9FWFRfZnJhZ19kZXB0aCkgJiYgZGVmaW5lZChMT0dfREVQVEgpXFxuXFxcbiAgICAvLyBEaXNjYXJkIHRoZSB2ZXJ0ZXggaWYgaXQncyBub3QgYmV0d2VlbiB0aGUgbmVhciBhbmQgZmFyIHBsYW5lcy5cXG5cXFxuICAgIC8vIFdlIGFsbG93IGEgYml0IG9mIGVwc2lsb24gb24gdGhlIG5lYXIgcGxhbmUgY29tcGFyaXNvbiBiZWNhdXNlIGEgMS4wXFxuXFxcbiAgICAvLyBmcm9tIHRoZSB2ZXJ0ZXggc2hhZGVyIChpbmRpY2F0aW5nIHRoZSB2ZXJ0ZXggc2hvdWxkIGJlIF9vbl8gdGhlIG5lYXJcXG5cXFxuICAgIC8vIHBsYW5lKSB3aWxsIG5vdCBuZWNlc3NhcmlseSBjb21lIGhlcmUgYXMgZXhhY3RseSAxLjAuXFxuXFxcbiAgICBpZiAoZGVwdGggPD0gMC45OTk5OTk5IHx8IGRlcHRoID4gY3ptX2ZhckRlcHRoRnJvbU5lYXJQbHVzT25lKSB7XFxuXFxcbiAgICAgICAgZGlzY2FyZDtcXG5cXFxuICAgIH1cXG5cXFxuXFxuXFxcbiNpZmRlZiBQT0xZR09OX09GRlNFVFxcblxcXG4gICAgLy8gUG9seWdvbiBvZmZzZXQ6IG0gKiBmYWN0b3IgKyByICogdW5pdHNcXG5cXFxuICAgIGZsb2F0IGZhY3RvciA9IHVfcG9seWdvbk9mZnNldFswXTtcXG5cXFxuICAgIGZsb2F0IHVuaXRzID0gdV9wb2x5Z29uT2Zmc2V0WzFdO1xcblxcXG5cXG5cXFxuICAgIC8vIElmIHdlIGNhbid0IGNvbXB1dGUgZGVyaXZhdGl2ZXMsIGp1c3QgbGVhdmUgb3V0IHRoZSBmYWN0b3IgSSBndWVzcz9cXG5cXFxuI2lmZGVmIEdMX09FU19zdGFuZGFyZF9kZXJpdmF0aXZlc1xcblxcXG4gICAgLy8gbSA9IHNxcnQoZFpkWF4yICsgZFpkWV4yKTtcXG5cXFxuICAgIGZsb2F0IHggPSBkRmR4KGRlcHRoKTtcXG5cXFxuICAgIGZsb2F0IHkgPSBkRmR5KGRlcHRoKTtcXG5cXFxuICAgIGZsb2F0IG0gPSBzcXJ0KHggKiB4ICsgeSAqIHkpO1xcblxcXG5cXG5cXFxuICAgIC8vIEFwcGx5IHRoZSBmYWN0b3IgYmVmb3JlIGNvbXB1dGluZyB0aGUgbG9nIGRlcHRoLlxcblxcXG4gICAgZGVwdGggKz0gbSAqIGZhY3RvcjtcXG5cXFxuI2VuZGlmXFxuXFxcblxcblxcXG4jZW5kaWZcXG5cXFxuXFxuXFxcbiAgICBnbF9GcmFnRGVwdGhFWFQgPSBsb2cyKGRlcHRoKSAqIGN6bV9vbmVPdmVyTG9nMkZhckRlcHRoRnJvbU5lYXJQbHVzT25lO1xcblxcXG5cXG5cXFxuI2lmZGVmIFBPTFlHT05fT0ZGU0VUXFxuXFxcbiAgICAvLyBBcHBseSB0aGUgdW5pdHMgYWZ0ZXIgdGhlIGxvZyBkZXB0aC5cXG5cXFxuICAgIGdsX0ZyYWdEZXB0aEVYVCArPSBjem1fZXBzaWxvbjcgKiB1bml0cztcXG5cXFxuI2VuZGlmXFxuXFxcblxcblxcXG4jZW5kaWZcXG5cXFxufVxcblxcXG5cXG5cXFxuLyoqXFxuXFxcbiAqIFdyaXRlcyB0aGUgZnJhZ21lbnQgZGVwdGggdG8gdGhlIGxvZ2FyaXRobWljIGRlcHRoIGJ1ZmZlci5cXG5cXFxuICogPHA+XFxuXFxcbiAqIFVzZSB0aGlzIHdoZW4gdGhlIHZlcnRleCBzaGFkZXIgY2FsbHMge0BsaW5rIGN6bV92ZXJ0ZXhsb2dEZXB0aH0uXFxuXFxcbiAqIDwvcD5cXG5cXFxuICpcXG5cXFxuICogQG5hbWUgY3ptX3dyaXRlTG9nRGVwdGhcXG5cXFxuICogQGdsc2xGdW5jdGlvblxcblxcXG4gKi9cXG5cXFxudm9pZCBjem1fd3JpdGVMb2dEZXB0aCgpIHtcXG5cXFxuI2lmZGVmIExPR19ERVBUSFxcblxcXG4gICAgY3ptX3dyaXRlTG9nRGVwdGgodl9kZXB0aEZyb21OZWFyUGx1c09uZSk7XFxuXFxcbiNlbmRpZlxcblxcXG59XFxuXFxcblwiO1xuIiwiLy9UaGlzIGZpbGUgaXMgYXV0b21hdGljYWxseSByZWJ1aWx0IGJ5IHRoZSBDZXNpdW0gYnVpbGQgcHJvY2Vzcy5cbmV4cG9ydCBkZWZhdWx0IFwiLyoqXFxuXFxcbiAqIFRyYW5zZm9ybXMgYSB2YWx1ZSBmb3Igbm9uLXBlcnNwZWN0aXZlIGludGVycG9sYXRpb24gYnkgbXVsdGlwbHlpbmdcXG5cXFxuICogaXQgYnkgdywgdGhlIHZhbHVlIHVzZWQgaW4gdGhlIHBlcnNwZWN0aXZlIGRpdmlkZS4gVGhpcyBmdW5jdGlvbiBpc1xcblxcXG4gKiBpbnRlbmRlZCB0byBiZSBjYWxsZWQgaW4gYSB2ZXJ0ZXggc2hhZGVyIHRvIGNvbXB1dGUgdGhlIHZhbHVlIG9mIGFcXG5cXFxuICogYHZhcnlpbmdgIHRoYXQgc2hvdWxkIG5vdCBiZSBzdWJqZWN0IHRvIHBlcnNwZWN0aXZlIGludGVycG9sYXRpb24uXFxuXFxcbiAqIEZvciBleGFtcGxlLCBzY3JlZW4tc3BhY2UgdGV4dHVyZSBjb29yZGluYXRlcy4gVGhlIGZyYWdtZW50IHNoYWRlclxcblxcXG4gKiBtdXN0IGNhbGwge0BsaW5rIGN6bV9yZWFkTm9uUGVyc3BlY3RpdmV9IHRvIHJldHJpZXZlIHRoZSBmaW5hbFxcblxcXG4gKiBub24tcGVyc3BlY3RpdmUgdmFsdWUuXFxuXFxcbiAqXFxuXFxcbiAqIEBuYW1lIGN6bV93cml0ZU5vblBlcnNwZWN0aXZlXFxuXFxcbiAqIEBnbHNsRnVuY3Rpb25cXG5cXFxuICpcXG5cXFxuICogQHBhcmFtIHtmbG9hdHx2ZWMyfHZlYzN8dmVjNH0gdmFsdWUgVGhlIHZhbHVlIHRvIGJlIGludGVycG9sYXRlZCB3aXRob3V0IGFjY291bnRpbmcgZm9yIHBlcnNwZWN0aXZlLlxcblxcXG4gKiBAcGFyYW0ge2Zsb2F0fSB3IFRoZSBwZXJzcGVjdGl2ZSBkaXZpZGUgdmFsdWUuIFVzdWFsbHkgdGhpcyBpcyB0aGUgY29tcHV0ZWQgYGdsX1Bvc2l0aW9uLndgLlxcblxcXG4gKiBAcmV0dXJucyB7ZmxvYXR8dmVjMnx2ZWMzfHZlYzR9IFRoZSB0cmFuc2Zvcm1lZCB2YWx1ZSwgaW50ZW5kZWQgdG8gYmUgc3RvcmVkIGluIGEgYHZhcnlpbmdgIGFuZCByZWFkIGluIHRoZVxcblxcXG4gKiAgICAgICAgICBmcmFnbWVudCBzaGFkZXIgd2l0aCB7QGxpbmsgY3ptX3JlYWROb25QZXJzcGVjdGl2ZX0uXFxuXFxcbiAqL1xcblxcXG5mbG9hdCBjem1fd3JpdGVOb25QZXJzcGVjdGl2ZShmbG9hdCB2YWx1ZSwgZmxvYXQgdykge1xcblxcXG4gICAgcmV0dXJuIHZhbHVlICogdztcXG5cXFxufVxcblxcXG5cXG5cXFxudmVjMiBjem1fd3JpdGVOb25QZXJzcGVjdGl2ZSh2ZWMyIHZhbHVlLCBmbG9hdCB3KSB7XFxuXFxcbiAgICByZXR1cm4gdmFsdWUgKiB3O1xcblxcXG59XFxuXFxcblxcblxcXG52ZWMzIGN6bV93cml0ZU5vblBlcnNwZWN0aXZlKHZlYzMgdmFsdWUsIGZsb2F0IHcpIHtcXG5cXFxuICAgIHJldHVybiB2YWx1ZSAqIHc7XFxuXFxcbn1cXG5cXFxuXFxuXFxcbnZlYzQgY3ptX3dyaXRlTm9uUGVyc3BlY3RpdmUodmVjNCB2YWx1ZSwgZmxvYXQgdykge1xcblxcXG4gICAgcmV0dXJuIHZhbHVlICogdztcXG5cXFxufVxcblxcXG5cIjtcbiIsIi8vVGhpcyBmaWxlIGlzIGF1dG9tYXRpY2FsbHkgcmVidWlsdCBieSB0aGUgQ2VzaXVtIGJ1aWxkIHByb2Nlc3MuXG5pbXBvcnQgY3ptX2RlZ3JlZXNQZXJSYWRpYW4gZnJvbSAnLi9Db25zdGFudHMvZGVncmVlc1BlclJhZGlhbi5qcydcbmltcG9ydCBjem1fZGVwdGhSYW5nZSBmcm9tICcuL0NvbnN0YW50cy9kZXB0aFJhbmdlLmpzJ1xuaW1wb3J0IGN6bV9lcHNpbG9uMSBmcm9tICcuL0NvbnN0YW50cy9lcHNpbG9uMS5qcydcbmltcG9ydCBjem1fZXBzaWxvbjIgZnJvbSAnLi9Db25zdGFudHMvZXBzaWxvbjIuanMnXG5pbXBvcnQgY3ptX2Vwc2lsb24zIGZyb20gJy4vQ29uc3RhbnRzL2Vwc2lsb24zLmpzJ1xuaW1wb3J0IGN6bV9lcHNpbG9uNCBmcm9tICcuL0NvbnN0YW50cy9lcHNpbG9uNC5qcydcbmltcG9ydCBjem1fZXBzaWxvbjUgZnJvbSAnLi9Db25zdGFudHMvZXBzaWxvbjUuanMnXG5pbXBvcnQgY3ptX2Vwc2lsb242IGZyb20gJy4vQ29uc3RhbnRzL2Vwc2lsb242LmpzJ1xuaW1wb3J0IGN6bV9lcHNpbG9uNyBmcm9tICcuL0NvbnN0YW50cy9lcHNpbG9uNy5qcydcbmltcG9ydCBjem1faW5maW5pdHkgZnJvbSAnLi9Db25zdGFudHMvaW5maW5pdHkuanMnXG5pbXBvcnQgY3ptX29uZU92ZXJQaSBmcm9tICcuL0NvbnN0YW50cy9vbmVPdmVyUGkuanMnXG5pbXBvcnQgY3ptX29uZU92ZXJUd29QaSBmcm9tICcuL0NvbnN0YW50cy9vbmVPdmVyVHdvUGkuanMnXG5pbXBvcnQgY3ptX3Bhc3NDZXNpdW0zRFRpbGUgZnJvbSAnLi9Db25zdGFudHMvcGFzc0Nlc2l1bTNEVGlsZS5qcydcbmltcG9ydCBjem1fcGFzc0Nlc2l1bTNEVGlsZUNsYXNzaWZpY2F0aW9uIGZyb20gJy4vQ29uc3RhbnRzL3Bhc3NDZXNpdW0zRFRpbGVDbGFzc2lmaWNhdGlvbi5qcydcbmltcG9ydCBjem1fcGFzc0Nlc2l1bTNEVGlsZUNsYXNzaWZpY2F0aW9uSWdub3JlU2hvdyBmcm9tICcuL0NvbnN0YW50cy9wYXNzQ2VzaXVtM0RUaWxlQ2xhc3NpZmljYXRpb25JZ25vcmVTaG93LmpzJ1xuaW1wb3J0IGN6bV9wYXNzQ2xhc3NpZmljYXRpb24gZnJvbSAnLi9Db25zdGFudHMvcGFzc0NsYXNzaWZpY2F0aW9uLmpzJ1xuaW1wb3J0IGN6bV9wYXNzQ29tcHV0ZSBmcm9tICcuL0NvbnN0YW50cy9wYXNzQ29tcHV0ZS5qcydcbmltcG9ydCBjem1fcGFzc0Vudmlyb25tZW50IGZyb20gJy4vQ29uc3RhbnRzL3Bhc3NFbnZpcm9ubWVudC5qcydcbmltcG9ydCBjem1fcGFzc0dsb2JlIGZyb20gJy4vQ29uc3RhbnRzL3Bhc3NHbG9iZS5qcydcbmltcG9ydCBjem1fcGFzc09wYXF1ZSBmcm9tICcuL0NvbnN0YW50cy9wYXNzT3BhcXVlLmpzJ1xuaW1wb3J0IGN6bV9wYXNzT3ZlcmxheSBmcm9tICcuL0NvbnN0YW50cy9wYXNzT3ZlcmxheS5qcydcbmltcG9ydCBjem1fcGFzc1RlcnJhaW5DbGFzc2lmaWNhdGlvbiBmcm9tICcuL0NvbnN0YW50cy9wYXNzVGVycmFpbkNsYXNzaWZpY2F0aW9uLmpzJ1xuaW1wb3J0IGN6bV9wYXNzVHJhbnNsdWNlbnQgZnJvbSAnLi9Db25zdGFudHMvcGFzc1RyYW5zbHVjZW50LmpzJ1xuaW1wb3J0IGN6bV9waSBmcm9tICcuL0NvbnN0YW50cy9waS5qcydcbmltcG9ydCBjem1fcGlPdmVyRm91ciBmcm9tICcuL0NvbnN0YW50cy9waU92ZXJGb3VyLmpzJ1xuaW1wb3J0IGN6bV9waU92ZXJTaXggZnJvbSAnLi9Db25zdGFudHMvcGlPdmVyU2l4LmpzJ1xuaW1wb3J0IGN6bV9waU92ZXJUaHJlZSBmcm9tICcuL0NvbnN0YW50cy9waU92ZXJUaHJlZS5qcydcbmltcG9ydCBjem1fcGlPdmVyVHdvIGZyb20gJy4vQ29uc3RhbnRzL3BpT3ZlclR3by5qcydcbmltcG9ydCBjem1fcmFkaWFuc1BlckRlZ3JlZSBmcm9tICcuL0NvbnN0YW50cy9yYWRpYW5zUGVyRGVncmVlLmpzJ1xuaW1wb3J0IGN6bV9zY2VuZU1vZGUyRCBmcm9tICcuL0NvbnN0YW50cy9zY2VuZU1vZGUyRC5qcydcbmltcG9ydCBjem1fc2NlbmVNb2RlM0QgZnJvbSAnLi9Db25zdGFudHMvc2NlbmVNb2RlM0QuanMnXG5pbXBvcnQgY3ptX3NjZW5lTW9kZUNvbHVtYnVzVmlldyBmcm9tICcuL0NvbnN0YW50cy9zY2VuZU1vZGVDb2x1bWJ1c1ZpZXcuanMnXG5pbXBvcnQgY3ptX3NjZW5lTW9kZU1vcnBoaW5nIGZyb20gJy4vQ29uc3RhbnRzL3NjZW5lTW9kZU1vcnBoaW5nLmpzJ1xuaW1wb3J0IGN6bV9zb2xhclJhZGl1cyBmcm9tICcuL0NvbnN0YW50cy9zb2xhclJhZGl1cy5qcydcbmltcG9ydCBjem1fdGhyZWVQaU92ZXIyIGZyb20gJy4vQ29uc3RhbnRzL3RocmVlUGlPdmVyMi5qcydcbmltcG9ydCBjem1fdHdvUGkgZnJvbSAnLi9Db25zdGFudHMvdHdvUGkuanMnXG5pbXBvcnQgY3ptX3dlYk1lcmNhdG9yTWF4TGF0aXR1ZGUgZnJvbSAnLi9Db25zdGFudHMvd2ViTWVyY2F0b3JNYXhMYXRpdHVkZS5qcydcbmltcG9ydCBjem1fZGVwdGhSYW5nZVN0cnVjdCBmcm9tICcuL1N0cnVjdHMvZGVwdGhSYW5nZVN0cnVjdC5qcydcbmltcG9ydCBjem1fbWF0ZXJpYWwgZnJvbSAnLi9TdHJ1Y3RzL21hdGVyaWFsLmpzJ1xuaW1wb3J0IGN6bV9tYXRlcmlhbElucHV0IGZyb20gJy4vU3RydWN0cy9tYXRlcmlhbElucHV0LmpzJ1xuaW1wb3J0IGN6bV9tb2RlbE1hdGVyaWFsIGZyb20gJy4vU3RydWN0cy9tb2RlbE1hdGVyaWFsLmpzJ1xuaW1wb3J0IGN6bV9wYnJQYXJhbWV0ZXJzIGZyb20gJy4vU3RydWN0cy9wYnJQYXJhbWV0ZXJzLmpzJ1xuaW1wb3J0IGN6bV9yYXkgZnJvbSAnLi9TdHJ1Y3RzL3JheS5qcydcbmltcG9ydCBjem1fcmF5U2VnbWVudCBmcm9tICcuL1N0cnVjdHMvcmF5U2VnbWVudC5qcydcbmltcG9ydCBjem1fc2hhZG93UGFyYW1ldGVycyBmcm9tICcuL1N0cnVjdHMvc2hhZG93UGFyYW1ldGVycy5qcydcbmltcG9ydCBjem1fSFNCVG9SR0IgZnJvbSAnLi9GdW5jdGlvbnMvSFNCVG9SR0IuanMnXG5pbXBvcnQgY3ptX0hTTFRvUkdCIGZyb20gJy4vRnVuY3Rpb25zL0hTTFRvUkdCLmpzJ1xuaW1wb3J0IGN6bV9SR0JUb0hTQiBmcm9tICcuL0Z1bmN0aW9ucy9SR0JUb0hTQi5qcydcbmltcG9ydCBjem1fUkdCVG9IU0wgZnJvbSAnLi9GdW5jdGlvbnMvUkdCVG9IU0wuanMnXG5pbXBvcnQgY3ptX1JHQlRvWFlaIGZyb20gJy4vRnVuY3Rpb25zL1JHQlRvWFlaLmpzJ1xuaW1wb3J0IGN6bV9YWVpUb1JHQiBmcm9tICcuL0Z1bmN0aW9ucy9YWVpUb1JHQi5qcydcbmltcG9ydCBjem1fYWNlc1RvbmVtYXBwaW5nIGZyb20gJy4vRnVuY3Rpb25zL2FjZXNUb25lbWFwcGluZy5qcydcbmltcG9ydCBjem1fYWxwaGFXZWlnaHQgZnJvbSAnLi9GdW5jdGlvbnMvYWxwaGFXZWlnaHQuanMnXG5pbXBvcnQgY3ptX2FudGlhbGlhcyBmcm9tICcuL0Z1bmN0aW9ucy9hbnRpYWxpYXMuanMnXG5pbXBvcnQgY3ptX2FwcHJveGltYXRlU3BoZXJpY2FsQ29vcmRpbmF0ZXMgZnJvbSAnLi9GdW5jdGlvbnMvYXBwcm94aW1hdGVTcGhlcmljYWxDb29yZGluYXRlcy5qcydcbmltcG9ydCBjem1fYmFja0ZhY2luZyBmcm9tICcuL0Z1bmN0aW9ucy9iYWNrRmFjaW5nLmpzJ1xuaW1wb3J0IGN6bV9icmFuY2hGcmVlVGVybmFyeSBmcm9tICcuL0Z1bmN0aW9ucy9icmFuY2hGcmVlVGVybmFyeS5qcydcbmltcG9ydCBjem1fY2FzY2FkZUNvbG9yIGZyb20gJy4vRnVuY3Rpb25zL2Nhc2NhZGVDb2xvci5qcydcbmltcG9ydCBjem1fY2FzY2FkZURpc3RhbmNlIGZyb20gJy4vRnVuY3Rpb25zL2Nhc2NhZGVEaXN0YW5jZS5qcydcbmltcG9ydCBjem1fY2FzY2FkZU1hdHJpeCBmcm9tICcuL0Z1bmN0aW9ucy9jYXNjYWRlTWF0cml4LmpzJ1xuaW1wb3J0IGN6bV9jYXNjYWRlV2VpZ2h0cyBmcm9tICcuL0Z1bmN0aW9ucy9jYXNjYWRlV2VpZ2h0cy5qcydcbmltcG9ydCBjem1fY29sdW1idXNWaWV3TW9ycGggZnJvbSAnLi9GdW5jdGlvbnMvY29sdW1idXNWaWV3TW9ycGguanMnXG5pbXBvcnQgY3ptX2NvbXB1dGVQb3NpdGlvbiBmcm9tICcuL0Z1bmN0aW9ucy9jb21wdXRlUG9zaXRpb24uanMnXG5pbXBvcnQgY3ptX2Nvc2luZUFuZFNpbmUgZnJvbSAnLi9GdW5jdGlvbnMvY29zaW5lQW5kU2luZS5qcydcbmltcG9ydCBjem1fZGVjb21wcmVzc1RleHR1cmVDb29yZGluYXRlcyBmcm9tICcuL0Z1bmN0aW9ucy9kZWNvbXByZXNzVGV4dHVyZUNvb3JkaW5hdGVzLmpzJ1xuaW1wb3J0IGN6bV9kZWZhdWx0UGJyTWF0ZXJpYWwgZnJvbSAnLi9GdW5jdGlvbnMvZGVmYXVsdFBick1hdGVyaWFsLmpzJ1xuaW1wb3J0IGN6bV9kZXB0aENsYW1wIGZyb20gJy4vRnVuY3Rpb25zL2RlcHRoQ2xhbXAuanMnXG5pbXBvcnQgY3ptX2Vhc3ROb3J0aFVwVG9FeWVDb29yZGluYXRlcyBmcm9tICcuL0Z1bmN0aW9ucy9lYXN0Tm9ydGhVcFRvRXllQ29vcmRpbmF0ZXMuanMnXG5pbXBvcnQgY3ptX2VsbGlwc29pZENvbnRhaW5zUG9pbnQgZnJvbSAnLi9GdW5jdGlvbnMvZWxsaXBzb2lkQ29udGFpbnNQb2ludC5qcydcbmltcG9ydCBjem1fZWxsaXBzb2lkV2dzODRUZXh0dXJlQ29vcmRpbmF0ZXMgZnJvbSAnLi9GdW5jdGlvbnMvZWxsaXBzb2lkV2dzODRUZXh0dXJlQ29vcmRpbmF0ZXMuanMnXG5pbXBvcnQgY3ptX2VxdWFsc0Vwc2lsb24gZnJvbSAnLi9GdW5jdGlvbnMvZXF1YWxzRXBzaWxvbi5qcydcbmltcG9ydCBjem1fZXllT2Zmc2V0IGZyb20gJy4vRnVuY3Rpb25zL2V5ZU9mZnNldC5qcydcbmltcG9ydCBjem1fZXllVG9XaW5kb3dDb29yZGluYXRlcyBmcm9tICcuL0Z1bmN0aW9ucy9leWVUb1dpbmRvd0Nvb3JkaW5hdGVzLmpzJ1xuaW1wb3J0IGN6bV9mYXN0QXBwcm94aW1hdGVBdGFuIGZyb20gJy4vRnVuY3Rpb25zL2Zhc3RBcHByb3hpbWF0ZUF0YW4uanMnXG5pbXBvcnQgY3ptX2ZvZyBmcm9tICcuL0Z1bmN0aW9ucy9mb2cuanMnXG5pbXBvcnQgY3ptX2dhbW1hQ29ycmVjdCBmcm9tICcuL0Z1bmN0aW9ucy9nYW1tYUNvcnJlY3QuanMnXG5pbXBvcnQgY3ptX2dlb2RldGljU3VyZmFjZU5vcm1hbCBmcm9tICcuL0Z1bmN0aW9ucy9nZW9kZXRpY1N1cmZhY2VOb3JtYWwuanMnXG5pbXBvcnQgY3ptX2dldERlZmF1bHRNYXRlcmlhbCBmcm9tICcuL0Z1bmN0aW9ucy9nZXREZWZhdWx0TWF0ZXJpYWwuanMnXG5pbXBvcnQgY3ptX2dldExhbWJlcnREaWZmdXNlIGZyb20gJy4vRnVuY3Rpb25zL2dldExhbWJlcnREaWZmdXNlLmpzJ1xuaW1wb3J0IGN6bV9nZXRTcGVjdWxhciBmcm9tICcuL0Z1bmN0aW9ucy9nZXRTcGVjdWxhci5qcydcbmltcG9ydCBjem1fZ2V0V2F0ZXJOb2lzZSBmcm9tICcuL0Z1bmN0aW9ucy9nZXRXYXRlck5vaXNlLmpzJ1xuaW1wb3J0IGN6bV9odWUgZnJvbSAnLi9GdW5jdGlvbnMvaHVlLmpzJ1xuaW1wb3J0IGN6bV9pbnZlcnNlR2FtbWEgZnJvbSAnLi9GdW5jdGlvbnMvaW52ZXJzZUdhbW1hLmpzJ1xuaW1wb3J0IGN6bV9pc0VtcHR5IGZyb20gJy4vRnVuY3Rpb25zL2lzRW1wdHkuanMnXG5pbXBvcnQgY3ptX2lzRnVsbCBmcm9tICcuL0Z1bmN0aW9ucy9pc0Z1bGwuanMnXG5pbXBvcnQgY3ptX2xhdGl0dWRlVG9XZWJNZXJjYXRvckZyYWN0aW9uIGZyb20gJy4vRnVuY3Rpb25zL2xhdGl0dWRlVG9XZWJNZXJjYXRvckZyYWN0aW9uLmpzJ1xuaW1wb3J0IGN6bV9saW5lRGlzdGFuY2UgZnJvbSAnLi9GdW5jdGlvbnMvbGluZURpc3RhbmNlLmpzJ1xuaW1wb3J0IGN6bV9sdW1pbmFuY2UgZnJvbSAnLi9GdW5jdGlvbnMvbHVtaW5hbmNlLmpzJ1xuaW1wb3J0IGN6bV9tZXRlcnNQZXJQaXhlbCBmcm9tICcuL0Z1bmN0aW9ucy9tZXRlcnNQZXJQaXhlbC5qcydcbmltcG9ydCBjem1fbW9kZWxUb1dpbmRvd0Nvb3JkaW5hdGVzIGZyb20gJy4vRnVuY3Rpb25zL21vZGVsVG9XaW5kb3dDb29yZGluYXRlcy5qcydcbmltcG9ydCBjem1fbXVsdGlwbHlXaXRoQ29sb3JCYWxhbmNlIGZyb20gJy4vRnVuY3Rpb25zL211bHRpcGx5V2l0aENvbG9yQmFsYW5jZS5qcydcbmltcG9ydCBjem1fbmVhckZhclNjYWxhciBmcm9tICcuL0Z1bmN0aW9ucy9uZWFyRmFyU2NhbGFyLmpzJ1xuaW1wb3J0IGN6bV9vY3REZWNvZGUgZnJvbSAnLi9GdW5jdGlvbnMvb2N0RGVjb2RlLmpzJ1xuaW1wb3J0IGN6bV9wYWNrRGVwdGggZnJvbSAnLi9GdW5jdGlvbnMvcGFja0RlcHRoLmpzJ1xuaW1wb3J0IGN6bV9wYnJMaWdodGluZyBmcm9tICcuL0Z1bmN0aW9ucy9wYnJMaWdodGluZy5qcydcbmltcG9ydCBjem1fcGJyTWV0YWxsaWNSb3VnaG5lc3NNYXRlcmlhbCBmcm9tICcuL0Z1bmN0aW9ucy9wYnJNZXRhbGxpY1JvdWdobmVzc01hdGVyaWFsLmpzJ1xuaW1wb3J0IGN6bV9wYnJTcGVjdWxhckdsb3NzaW5lc3NNYXRlcmlhbCBmcm9tICcuL0Z1bmN0aW9ucy9wYnJTcGVjdWxhckdsb3NzaW5lc3NNYXRlcmlhbC5qcydcbmltcG9ydCBjem1fcGhvbmcgZnJvbSAnLi9GdW5jdGlvbnMvcGhvbmcuanMnXG5pbXBvcnQgY3ptX3BsYW5lRGlzdGFuY2UgZnJvbSAnLi9GdW5jdGlvbnMvcGxhbmVEaXN0YW5jZS5qcydcbmltcG9ydCBjem1fcG9pbnRBbG9uZ1JheSBmcm9tICcuL0Z1bmN0aW9ucy9wb2ludEFsb25nUmF5LmpzJ1xuaW1wb3J0IGN6bV9yYXlFbGxpcHNvaWRJbnRlcnNlY3Rpb25JbnRlcnZhbCBmcm9tICcuL0Z1bmN0aW9ucy9yYXlFbGxpcHNvaWRJbnRlcnNlY3Rpb25JbnRlcnZhbC5qcydcbmltcG9ydCBjem1fcmVhZERlcHRoIGZyb20gJy4vRnVuY3Rpb25zL3JlYWREZXB0aC5qcydcbmltcG9ydCBjem1fcmVhZE5vblBlcnNwZWN0aXZlIGZyb20gJy4vRnVuY3Rpb25zL3JlYWROb25QZXJzcGVjdGl2ZS5qcydcbmltcG9ydCBjem1fcmV2ZXJzZUxvZ0RlcHRoIGZyb20gJy4vRnVuY3Rpb25zL3JldmVyc2VMb2dEZXB0aC5qcydcbmltcG9ydCBjem1fc2FtcGxlT2N0YWhlZHJhbFByb2plY3Rpb24gZnJvbSAnLi9GdW5jdGlvbnMvc2FtcGxlT2N0YWhlZHJhbFByb2plY3Rpb24uanMnXG5pbXBvcnQgY3ptX3NhdHVyYXRpb24gZnJvbSAnLi9GdW5jdGlvbnMvc2F0dXJhdGlvbi5qcydcbmltcG9ydCBjem1fc2hhZG93RGVwdGhDb21wYXJlIGZyb20gJy4vRnVuY3Rpb25zL3NoYWRvd0RlcHRoQ29tcGFyZS5qcydcbmltcG9ydCBjem1fc2hhZG93VmlzaWJpbGl0eSBmcm9tICcuL0Z1bmN0aW9ucy9zaGFkb3dWaXNpYmlsaXR5LmpzJ1xuaW1wb3J0IGN6bV9zaWduTm90WmVybyBmcm9tICcuL0Z1bmN0aW9ucy9zaWduTm90WmVyby5qcydcbmltcG9ydCBjem1fc3BoZXJpY2FsSGFybW9uaWNzIGZyb20gJy4vRnVuY3Rpb25zL3NwaGVyaWNhbEhhcm1vbmljcy5qcydcbmltcG9ydCBjem1fdGFuZ2VudFRvRXllU3BhY2VNYXRyaXggZnJvbSAnLi9GdW5jdGlvbnMvdGFuZ2VudFRvRXllU3BhY2VNYXRyaXguanMnXG5pbXBvcnQgY3ptX3RyYW5zZm9ybVBsYW5lIGZyb20gJy4vRnVuY3Rpb25zL3RyYW5zZm9ybVBsYW5lLmpzJ1xuaW1wb3J0IGN6bV90cmFuc2xhdGVSZWxhdGl2ZVRvRXllIGZyb20gJy4vRnVuY3Rpb25zL3RyYW5zbGF0ZVJlbGF0aXZlVG9FeWUuanMnXG5pbXBvcnQgY3ptX3RyYW5zbHVjZW50UGhvbmcgZnJvbSAnLi9GdW5jdGlvbnMvdHJhbnNsdWNlbnRQaG9uZy5qcydcbmltcG9ydCBjem1fdHJhbnNwb3NlIGZyb20gJy4vRnVuY3Rpb25zL3RyYW5zcG9zZS5qcydcbmltcG9ydCBjem1fdW5wYWNrRGVwdGggZnJvbSAnLi9GdW5jdGlvbnMvdW5wYWNrRGVwdGguanMnXG5pbXBvcnQgY3ptX3VucGFja0Zsb2F0IGZyb20gJy4vRnVuY3Rpb25zL3VucGFja0Zsb2F0LmpzJ1xuaW1wb3J0IGN6bV92ZXJ0ZXhMb2dEZXB0aCBmcm9tICcuL0Z1bmN0aW9ucy92ZXJ0ZXhMb2dEZXB0aC5qcydcbmltcG9ydCBjem1fd2luZG93VG9FeWVDb29yZGluYXRlcyBmcm9tICcuL0Z1bmN0aW9ucy93aW5kb3dUb0V5ZUNvb3JkaW5hdGVzLmpzJ1xuaW1wb3J0IGN6bV93cml0ZURlcHRoQ2xhbXAgZnJvbSAnLi9GdW5jdGlvbnMvd3JpdGVEZXB0aENsYW1wLmpzJ1xuaW1wb3J0IGN6bV93cml0ZUxvZ0RlcHRoIGZyb20gJy4vRnVuY3Rpb25zL3dyaXRlTG9nRGVwdGguanMnXG5pbXBvcnQgY3ptX3dyaXRlTm9uUGVyc3BlY3RpdmUgZnJvbSAnLi9GdW5jdGlvbnMvd3JpdGVOb25QZXJzcGVjdGl2ZS5qcydcblxuZXhwb3J0IGRlZmF1bHQge1xuICAgIGN6bV9kZWdyZWVzUGVyUmFkaWFuIDogY3ptX2RlZ3JlZXNQZXJSYWRpYW4sXG4gICAgY3ptX2RlcHRoUmFuZ2UgOiBjem1fZGVwdGhSYW5nZSxcbiAgICBjem1fZXBzaWxvbjEgOiBjem1fZXBzaWxvbjEsXG4gICAgY3ptX2Vwc2lsb24yIDogY3ptX2Vwc2lsb24yLFxuICAgIGN6bV9lcHNpbG9uMyA6IGN6bV9lcHNpbG9uMyxcbiAgICBjem1fZXBzaWxvbjQgOiBjem1fZXBzaWxvbjQsXG4gICAgY3ptX2Vwc2lsb241IDogY3ptX2Vwc2lsb241LFxuICAgIGN6bV9lcHNpbG9uNiA6IGN6bV9lcHNpbG9uNixcbiAgICBjem1fZXBzaWxvbjcgOiBjem1fZXBzaWxvbjcsXG4gICAgY3ptX2luZmluaXR5IDogY3ptX2luZmluaXR5LFxuICAgIGN6bV9vbmVPdmVyUGkgOiBjem1fb25lT3ZlclBpLFxuICAgIGN6bV9vbmVPdmVyVHdvUGkgOiBjem1fb25lT3ZlclR3b1BpLFxuICAgIGN6bV9wYXNzQ2VzaXVtM0RUaWxlIDogY3ptX3Bhc3NDZXNpdW0zRFRpbGUsXG4gICAgY3ptX3Bhc3NDZXNpdW0zRFRpbGVDbGFzc2lmaWNhdGlvbiA6IGN6bV9wYXNzQ2VzaXVtM0RUaWxlQ2xhc3NpZmljYXRpb24sXG4gICAgY3ptX3Bhc3NDZXNpdW0zRFRpbGVDbGFzc2lmaWNhdGlvbklnbm9yZVNob3cgOiBjem1fcGFzc0Nlc2l1bTNEVGlsZUNsYXNzaWZpY2F0aW9uSWdub3JlU2hvdyxcbiAgICBjem1fcGFzc0NsYXNzaWZpY2F0aW9uIDogY3ptX3Bhc3NDbGFzc2lmaWNhdGlvbixcbiAgICBjem1fcGFzc0NvbXB1dGUgOiBjem1fcGFzc0NvbXB1dGUsXG4gICAgY3ptX3Bhc3NFbnZpcm9ubWVudCA6IGN6bV9wYXNzRW52aXJvbm1lbnQsXG4gICAgY3ptX3Bhc3NHbG9iZSA6IGN6bV9wYXNzR2xvYmUsXG4gICAgY3ptX3Bhc3NPcGFxdWUgOiBjem1fcGFzc09wYXF1ZSxcbiAgICBjem1fcGFzc092ZXJsYXkgOiBjem1fcGFzc092ZXJsYXksXG4gICAgY3ptX3Bhc3NUZXJyYWluQ2xhc3NpZmljYXRpb24gOiBjem1fcGFzc1RlcnJhaW5DbGFzc2lmaWNhdGlvbixcbiAgICBjem1fcGFzc1RyYW5zbHVjZW50IDogY3ptX3Bhc3NUcmFuc2x1Y2VudCxcbiAgICBjem1fcGkgOiBjem1fcGksXG4gICAgY3ptX3BpT3ZlckZvdXIgOiBjem1fcGlPdmVyRm91cixcbiAgICBjem1fcGlPdmVyU2l4IDogY3ptX3BpT3ZlclNpeCxcbiAgICBjem1fcGlPdmVyVGhyZWUgOiBjem1fcGlPdmVyVGhyZWUsXG4gICAgY3ptX3BpT3ZlclR3byA6IGN6bV9waU92ZXJUd28sXG4gICAgY3ptX3JhZGlhbnNQZXJEZWdyZWUgOiBjem1fcmFkaWFuc1BlckRlZ3JlZSxcbiAgICBjem1fc2NlbmVNb2RlMkQgOiBjem1fc2NlbmVNb2RlMkQsXG4gICAgY3ptX3NjZW5lTW9kZTNEIDogY3ptX3NjZW5lTW9kZTNELFxuICAgIGN6bV9zY2VuZU1vZGVDb2x1bWJ1c1ZpZXcgOiBjem1fc2NlbmVNb2RlQ29sdW1idXNWaWV3LFxuICAgIGN6bV9zY2VuZU1vZGVNb3JwaGluZyA6IGN6bV9zY2VuZU1vZGVNb3JwaGluZyxcbiAgICBjem1fc29sYXJSYWRpdXMgOiBjem1fc29sYXJSYWRpdXMsXG4gICAgY3ptX3RocmVlUGlPdmVyMiA6IGN6bV90aHJlZVBpT3ZlcjIsXG4gICAgY3ptX3R3b1BpIDogY3ptX3R3b1BpLFxuICAgIGN6bV93ZWJNZXJjYXRvck1heExhdGl0dWRlIDogY3ptX3dlYk1lcmNhdG9yTWF4TGF0aXR1ZGUsXG4gICAgY3ptX2RlcHRoUmFuZ2VTdHJ1Y3QgOiBjem1fZGVwdGhSYW5nZVN0cnVjdCxcbiAgICBjem1fbWF0ZXJpYWwgOiBjem1fbWF0ZXJpYWwsXG4gICAgY3ptX21hdGVyaWFsSW5wdXQgOiBjem1fbWF0ZXJpYWxJbnB1dCxcbiAgICBjem1fbW9kZWxNYXRlcmlhbCA6IGN6bV9tb2RlbE1hdGVyaWFsLFxuICAgIGN6bV9wYnJQYXJhbWV0ZXJzIDogY3ptX3BiclBhcmFtZXRlcnMsXG4gICAgY3ptX3JheSA6IGN6bV9yYXksXG4gICAgY3ptX3JheVNlZ21lbnQgOiBjem1fcmF5U2VnbWVudCxcbiAgICBjem1fc2hhZG93UGFyYW1ldGVycyA6IGN6bV9zaGFkb3dQYXJhbWV0ZXJzLFxuICAgIGN6bV9IU0JUb1JHQiA6IGN6bV9IU0JUb1JHQixcbiAgICBjem1fSFNMVG9SR0IgOiBjem1fSFNMVG9SR0IsXG4gICAgY3ptX1JHQlRvSFNCIDogY3ptX1JHQlRvSFNCLFxuICAgIGN6bV9SR0JUb0hTTCA6IGN6bV9SR0JUb0hTTCxcbiAgICBjem1fUkdCVG9YWVogOiBjem1fUkdCVG9YWVosXG4gICAgY3ptX1hZWlRvUkdCIDogY3ptX1hZWlRvUkdCLFxuICAgIGN6bV9hY2VzVG9uZW1hcHBpbmcgOiBjem1fYWNlc1RvbmVtYXBwaW5nLFxuICAgIGN6bV9hbHBoYVdlaWdodCA6IGN6bV9hbHBoYVdlaWdodCxcbiAgICBjem1fYW50aWFsaWFzIDogY3ptX2FudGlhbGlhcyxcbiAgICBjem1fYXBwcm94aW1hdGVTcGhlcmljYWxDb29yZGluYXRlcyA6IGN6bV9hcHByb3hpbWF0ZVNwaGVyaWNhbENvb3JkaW5hdGVzLFxuICAgIGN6bV9iYWNrRmFjaW5nIDogY3ptX2JhY2tGYWNpbmcsXG4gICAgY3ptX2JyYW5jaEZyZWVUZXJuYXJ5IDogY3ptX2JyYW5jaEZyZWVUZXJuYXJ5LFxuICAgIGN6bV9jYXNjYWRlQ29sb3IgOiBjem1fY2FzY2FkZUNvbG9yLFxuICAgIGN6bV9jYXNjYWRlRGlzdGFuY2UgOiBjem1fY2FzY2FkZURpc3RhbmNlLFxuICAgIGN6bV9jYXNjYWRlTWF0cml4IDogY3ptX2Nhc2NhZGVNYXRyaXgsXG4gICAgY3ptX2Nhc2NhZGVXZWlnaHRzIDogY3ptX2Nhc2NhZGVXZWlnaHRzLFxuICAgIGN6bV9jb2x1bWJ1c1ZpZXdNb3JwaCA6IGN6bV9jb2x1bWJ1c1ZpZXdNb3JwaCxcbiAgICBjem1fY29tcHV0ZVBvc2l0aW9uIDogY3ptX2NvbXB1dGVQb3NpdGlvbixcbiAgICBjem1fY29zaW5lQW5kU2luZSA6IGN6bV9jb3NpbmVBbmRTaW5lLFxuICAgIGN6bV9kZWNvbXByZXNzVGV4dHVyZUNvb3JkaW5hdGVzIDogY3ptX2RlY29tcHJlc3NUZXh0dXJlQ29vcmRpbmF0ZXMsXG4gICAgY3ptX2RlZmF1bHRQYnJNYXRlcmlhbCA6IGN6bV9kZWZhdWx0UGJyTWF0ZXJpYWwsXG4gICAgY3ptX2RlcHRoQ2xhbXAgOiBjem1fZGVwdGhDbGFtcCxcbiAgICBjem1fZWFzdE5vcnRoVXBUb0V5ZUNvb3JkaW5hdGVzIDogY3ptX2Vhc3ROb3J0aFVwVG9FeWVDb29yZGluYXRlcyxcbiAgICBjem1fZWxsaXBzb2lkQ29udGFpbnNQb2ludCA6IGN6bV9lbGxpcHNvaWRDb250YWluc1BvaW50LFxuICAgIGN6bV9lbGxpcHNvaWRXZ3M4NFRleHR1cmVDb29yZGluYXRlcyA6IGN6bV9lbGxpcHNvaWRXZ3M4NFRleHR1cmVDb29yZGluYXRlcyxcbiAgICBjem1fZXF1YWxzRXBzaWxvbiA6IGN6bV9lcXVhbHNFcHNpbG9uLFxuICAgIGN6bV9leWVPZmZzZXQgOiBjem1fZXllT2Zmc2V0LFxuICAgIGN6bV9leWVUb1dpbmRvd0Nvb3JkaW5hdGVzIDogY3ptX2V5ZVRvV2luZG93Q29vcmRpbmF0ZXMsXG4gICAgY3ptX2Zhc3RBcHByb3hpbWF0ZUF0YW4gOiBjem1fZmFzdEFwcHJveGltYXRlQXRhbixcbiAgICBjem1fZm9nIDogY3ptX2ZvZyxcbiAgICBjem1fZ2FtbWFDb3JyZWN0IDogY3ptX2dhbW1hQ29ycmVjdCxcbiAgICBjem1fZ2VvZGV0aWNTdXJmYWNlTm9ybWFsIDogY3ptX2dlb2RldGljU3VyZmFjZU5vcm1hbCxcbiAgICBjem1fZ2V0RGVmYXVsdE1hdGVyaWFsIDogY3ptX2dldERlZmF1bHRNYXRlcmlhbCxcbiAgICBjem1fZ2V0TGFtYmVydERpZmZ1c2UgOiBjem1fZ2V0TGFtYmVydERpZmZ1c2UsXG4gICAgY3ptX2dldFNwZWN1bGFyIDogY3ptX2dldFNwZWN1bGFyLFxuICAgIGN6bV9nZXRXYXRlck5vaXNlIDogY3ptX2dldFdhdGVyTm9pc2UsXG4gICAgY3ptX2h1ZSA6IGN6bV9odWUsXG4gICAgY3ptX2ludmVyc2VHYW1tYSA6IGN6bV9pbnZlcnNlR2FtbWEsXG4gICAgY3ptX2lzRW1wdHkgOiBjem1faXNFbXB0eSxcbiAgICBjem1faXNGdWxsIDogY3ptX2lzRnVsbCxcbiAgICBjem1fbGF0aXR1ZGVUb1dlYk1lcmNhdG9yRnJhY3Rpb24gOiBjem1fbGF0aXR1ZGVUb1dlYk1lcmNhdG9yRnJhY3Rpb24sXG4gICAgY3ptX2xpbmVEaXN0YW5jZSA6IGN6bV9saW5lRGlzdGFuY2UsXG4gICAgY3ptX2x1bWluYW5jZSA6IGN6bV9sdW1pbmFuY2UsXG4gICAgY3ptX21ldGVyc1BlclBpeGVsIDogY3ptX21ldGVyc1BlclBpeGVsLFxuICAgIGN6bV9tb2RlbFRvV2luZG93Q29vcmRpbmF0ZXMgOiBjem1fbW9kZWxUb1dpbmRvd0Nvb3JkaW5hdGVzLFxuICAgIGN6bV9tdWx0aXBseVdpdGhDb2xvckJhbGFuY2UgOiBjem1fbXVsdGlwbHlXaXRoQ29sb3JCYWxhbmNlLFxuICAgIGN6bV9uZWFyRmFyU2NhbGFyIDogY3ptX25lYXJGYXJTY2FsYXIsXG4gICAgY3ptX29jdERlY29kZSA6IGN6bV9vY3REZWNvZGUsXG4gICAgY3ptX3BhY2tEZXB0aCA6IGN6bV9wYWNrRGVwdGgsXG4gICAgY3ptX3BickxpZ2h0aW5nIDogY3ptX3BickxpZ2h0aW5nLFxuICAgIGN6bV9wYnJNZXRhbGxpY1JvdWdobmVzc01hdGVyaWFsIDogY3ptX3Bick1ldGFsbGljUm91Z2huZXNzTWF0ZXJpYWwsXG4gICAgY3ptX3BiclNwZWN1bGFyR2xvc3NpbmVzc01hdGVyaWFsIDogY3ptX3BiclNwZWN1bGFyR2xvc3NpbmVzc01hdGVyaWFsLFxuICAgIGN6bV9waG9uZyA6IGN6bV9waG9uZyxcbiAgICBjem1fcGxhbmVEaXN0YW5jZSA6IGN6bV9wbGFuZURpc3RhbmNlLFxuICAgIGN6bV9wb2ludEFsb25nUmF5IDogY3ptX3BvaW50QWxvbmdSYXksXG4gICAgY3ptX3JheUVsbGlwc29pZEludGVyc2VjdGlvbkludGVydmFsIDogY3ptX3JheUVsbGlwc29pZEludGVyc2VjdGlvbkludGVydmFsLFxuICAgIGN6bV9yZWFkRGVwdGggOiBjem1fcmVhZERlcHRoLFxuICAgIGN6bV9yZWFkTm9uUGVyc3BlY3RpdmUgOiBjem1fcmVhZE5vblBlcnNwZWN0aXZlLFxuICAgIGN6bV9yZXZlcnNlTG9nRGVwdGggOiBjem1fcmV2ZXJzZUxvZ0RlcHRoLFxuICAgIGN6bV9zYW1wbGVPY3RhaGVkcmFsUHJvamVjdGlvbiA6IGN6bV9zYW1wbGVPY3RhaGVkcmFsUHJvamVjdGlvbixcbiAgICBjem1fc2F0dXJhdGlvbiA6IGN6bV9zYXR1cmF0aW9uLFxuICAgIGN6bV9zaGFkb3dEZXB0aENvbXBhcmUgOiBjem1fc2hhZG93RGVwdGhDb21wYXJlLFxuICAgIGN6bV9zaGFkb3dWaXNpYmlsaXR5IDogY3ptX3NoYWRvd1Zpc2liaWxpdHksXG4gICAgY3ptX3NpZ25Ob3RaZXJvIDogY3ptX3NpZ25Ob3RaZXJvLFxuICAgIGN6bV9zcGhlcmljYWxIYXJtb25pY3MgOiBjem1fc3BoZXJpY2FsSGFybW9uaWNzLFxuICAgIGN6bV90YW5nZW50VG9FeWVTcGFjZU1hdHJpeCA6IGN6bV90YW5nZW50VG9FeWVTcGFjZU1hdHJpeCxcbiAgICBjem1fdHJhbnNmb3JtUGxhbmUgOiBjem1fdHJhbnNmb3JtUGxhbmUsXG4gICAgY3ptX3RyYW5zbGF0ZVJlbGF0aXZlVG9FeWUgOiBjem1fdHJhbnNsYXRlUmVsYXRpdmVUb0V5ZSxcbiAgICBjem1fdHJhbnNsdWNlbnRQaG9uZyA6IGN6bV90cmFuc2x1Y2VudFBob25nLFxuICAgIGN6bV90cmFuc3Bvc2UgOiBjem1fdHJhbnNwb3NlLFxuICAgIGN6bV91bnBhY2tEZXB0aCA6IGN6bV91bnBhY2tEZXB0aCxcbiAgICBjem1fdW5wYWNrRmxvYXQgOiBjem1fdW5wYWNrRmxvYXQsXG4gICAgY3ptX3ZlcnRleExvZ0RlcHRoIDogY3ptX3ZlcnRleExvZ0RlcHRoLFxuICAgIGN6bV93aW5kb3dUb0V5ZUNvb3JkaW5hdGVzIDogY3ptX3dpbmRvd1RvRXllQ29vcmRpbmF0ZXMsXG4gICAgY3ptX3dyaXRlRGVwdGhDbGFtcCA6IGN6bV93cml0ZURlcHRoQ2xhbXAsXG4gICAgY3ptX3dyaXRlTG9nRGVwdGggOiBjem1fd3JpdGVMb2dEZXB0aCxcbiAgICBjem1fd3JpdGVOb25QZXJzcGVjdGl2ZSA6IGN6bV93cml0ZU5vblBlcnNwZWN0aXZlXG59O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///2303\n')}}]);