"use strict";(self["webpackChunkvue3_webpack5"]=self["webpackChunkvue3_webpack5"]||[]).push([[5014],{81499:function(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__){eval('\n// EXPORTS\n__webpack_require__.d(__webpack_exports__, {\n  "Z": function() { return /* binding */ reproj_Tile; }\n});\n\n;// CONCATENATED MODULE: ./node_modules/ol/reproj/common.js\n/**\n * @module ol/reproj/common\n */\n\n/**\n * Default maximum allowed threshold  (in pixels) for reprojection\n * triangulation.\n * @type {number}\n */\nconst ERROR_THRESHOLD = 0.5;\n\n// EXTERNAL MODULE: ./node_modules/ol/events/EventType.js\nvar EventType = __webpack_require__(85487);\n// EXTERNAL MODULE: ./node_modules/ol/Tile.js\nvar Tile = __webpack_require__(94806);\n// EXTERNAL MODULE: ./node_modules/ol/TileState.js\nvar TileState = __webpack_require__(37195);\n// EXTERNAL MODULE: ./node_modules/ol/extent.js\nvar ol_extent = __webpack_require__(28641);\n// EXTERNAL MODULE: ./node_modules/ol/proj.js + 4 modules\nvar proj = __webpack_require__(24121);\n// EXTERNAL MODULE: ./node_modules/ol/math.js\nvar math = __webpack_require__(33983);\n;// CONCATENATED MODULE: ./node_modules/ol/reproj/Triangulation.js\n/**\n * @module ol/reproj/Triangulation\n */\n\n\n\n\n/**\n * Single triangle; consists of 3 source points and 3 target points.\n * @typedef {Object} Triangle\n * @property {Array<import("../coordinate.js").Coordinate>} source Source.\n * @property {Array<import("../coordinate.js").Coordinate>} target Target.\n */\n\n/**\n * Maximum number of subdivision steps during raster reprojection triangulation.\n * Prevents high memory usage and large number of proj4 calls (for certain\n * transformations and areas). At most `2*(2^this)` triangles are created for\n * each triangulated extent (tile/image).\n * @type {number}\n */\nconst MAX_SUBDIVISION = 10;\n\n/**\n * Maximum allowed size of triangle relative to world width. When transforming\n * corners of world extent between certain projections, the resulting\n * triangulation seems to have zero error and no subdivision is performed. If\n * the triangle width is more than this (relative to world width; 0-1),\n * subdivison is forced (up to `MAX_SUBDIVISION`). Default is `0.25`.\n * @type {number}\n */\nconst MAX_TRIANGLE_WIDTH = 0.25;\n\n/**\n * @classdesc\n * Class containing triangulation of the given target extent.\n * Used for determining source data and the reprojection itself.\n */\nclass Triangulation {\n  /**\n   * @param {import("../proj/Projection.js").default} sourceProj Source projection.\n   * @param {import("../proj/Projection.js").default} targetProj Target projection.\n   * @param {import("../extent.js").Extent} targetExtent Target extent to triangulate.\n   * @param {import("../extent.js").Extent} maxSourceExtent Maximal source extent that can be used.\n   * @param {number} errorThreshold Acceptable error (in source units).\n   * @param {?number} destinationResolution The (optional) resolution of the destination.\n   */\n  constructor(\n    sourceProj,\n    targetProj,\n    targetExtent,\n    maxSourceExtent,\n    errorThreshold,\n    destinationResolution\n  ) {\n    /**\n     * @type {import("../proj/Projection.js").default}\n     * @private\n     */\n    this.sourceProj_ = sourceProj;\n\n    /**\n     * @type {import("../proj/Projection.js").default}\n     * @private\n     */\n    this.targetProj_ = targetProj;\n\n    /** @type {!Object<string, import("../coordinate.js").Coordinate>} */\n    let transformInvCache = {};\n    const transformInv = (0,proj/* getTransform */.Ck)(this.targetProj_, this.sourceProj_);\n\n    /**\n     * @param {import("../coordinate.js").Coordinate} c A coordinate.\n     * @return {import("../coordinate.js").Coordinate} Transformed coordinate.\n     * @private\n     */\n    this.transformInv_ = function (c) {\n      const key = c[0] + \'/\' + c[1];\n      if (!transformInvCache[key]) {\n        transformInvCache[key] = transformInv(c);\n      }\n      return transformInvCache[key];\n    };\n\n    /**\n     * @type {import("../extent.js").Extent}\n     * @private\n     */\n    this.maxSourceExtent_ = maxSourceExtent;\n\n    /**\n     * @type {number}\n     * @private\n     */\n    this.errorThresholdSquared_ = errorThreshold * errorThreshold;\n\n    /**\n     * @type {Array<Triangle>}\n     * @private\n     */\n    this.triangles_ = [];\n\n    /**\n     * Indicates that the triangulation crosses edge of the source projection.\n     * @type {boolean}\n     * @private\n     */\n    this.wrapsXInSource_ = false;\n\n    /**\n     * @type {boolean}\n     * @private\n     */\n    this.canWrapXInSource_ =\n      this.sourceProj_.canWrapX() &&\n      !!maxSourceExtent &&\n      !!this.sourceProj_.getExtent() &&\n      (0,ol_extent/* getWidth */.dz)(maxSourceExtent) == (0,ol_extent/* getWidth */.dz)(this.sourceProj_.getExtent());\n\n    /**\n     * @type {?number}\n     * @private\n     */\n    this.sourceWorldWidth_ = this.sourceProj_.getExtent()\n      ? (0,ol_extent/* getWidth */.dz)(this.sourceProj_.getExtent())\n      : null;\n\n    /**\n     * @type {?number}\n     * @private\n     */\n    this.targetWorldWidth_ = this.targetProj_.getExtent()\n      ? (0,ol_extent/* getWidth */.dz)(this.targetProj_.getExtent())\n      : null;\n\n    const destinationTopLeft = (0,ol_extent/* getTopLeft */.rL)(targetExtent);\n    const destinationTopRight = (0,ol_extent/* getTopRight */.Xv)(targetExtent);\n    const destinationBottomRight = (0,ol_extent/* getBottomRight */.w$)(targetExtent);\n    const destinationBottomLeft = (0,ol_extent/* getBottomLeft */.hC)(targetExtent);\n    const sourceTopLeft = this.transformInv_(destinationTopLeft);\n    const sourceTopRight = this.transformInv_(destinationTopRight);\n    const sourceBottomRight = this.transformInv_(destinationBottomRight);\n    const sourceBottomLeft = this.transformInv_(destinationBottomLeft);\n\n    /*\n     * The maxSubdivision controls how many splittings of the target area can\n     * be done. The idea here is to do a linear mapping of the target areas\n     * but the actual overal reprojection (can be) extremely non-linear. The\n     * default value of MAX_SUBDIVISION was chosen based on mapping a 256x256\n     * tile size. However this function is also called to remap canvas rendered\n     * layers which can be much larger. This calculation increases the maxSubdivision\n     * value by the right factor so that each 256x256 pixel area has\n     * MAX_SUBDIVISION divisions.\n     */\n    const maxSubdivision =\n      MAX_SUBDIVISION +\n      (destinationResolution\n        ? Math.max(\n            0,\n            Math.ceil(\n              Math.log2(\n                (0,ol_extent/* getArea */.bg)(targetExtent) /\n                  (destinationResolution * destinationResolution * 256 * 256)\n              )\n            )\n          )\n        : 0);\n\n    this.addQuad_(\n      destinationTopLeft,\n      destinationTopRight,\n      destinationBottomRight,\n      destinationBottomLeft,\n      sourceTopLeft,\n      sourceTopRight,\n      sourceBottomRight,\n      sourceBottomLeft,\n      maxSubdivision\n    );\n\n    if (this.wrapsXInSource_) {\n      let leftBound = Infinity;\n      this.triangles_.forEach(function (triangle, i, arr) {\n        leftBound = Math.min(\n          leftBound,\n          triangle.source[0][0],\n          triangle.source[1][0],\n          triangle.source[2][0]\n        );\n      });\n\n      // Shift triangles to be as close to `leftBound` as possible\n      // (if the distance is more than `worldWidth / 2` it can be closer.\n      this.triangles_.forEach((triangle) => {\n        if (\n          Math.max(\n            triangle.source[0][0],\n            triangle.source[1][0],\n            triangle.source[2][0]\n          ) -\n            leftBound >\n          this.sourceWorldWidth_ / 2\n        ) {\n          const newTriangle = [\n            [triangle.source[0][0], triangle.source[0][1]],\n            [triangle.source[1][0], triangle.source[1][1]],\n            [triangle.source[2][0], triangle.source[2][1]],\n          ];\n          if (newTriangle[0][0] - leftBound > this.sourceWorldWidth_ / 2) {\n            newTriangle[0][0] -= this.sourceWorldWidth_;\n          }\n          if (newTriangle[1][0] - leftBound > this.sourceWorldWidth_ / 2) {\n            newTriangle[1][0] -= this.sourceWorldWidth_;\n          }\n          if (newTriangle[2][0] - leftBound > this.sourceWorldWidth_ / 2) {\n            newTriangle[2][0] -= this.sourceWorldWidth_;\n          }\n\n          // Rarely (if the extent contains both the dateline and prime meridian)\n          // the shift can in turn break some triangles.\n          // Detect this here and don\'t shift in such cases.\n          const minX = Math.min(\n            newTriangle[0][0],\n            newTriangle[1][0],\n            newTriangle[2][0]\n          );\n          const maxX = Math.max(\n            newTriangle[0][0],\n            newTriangle[1][0],\n            newTriangle[2][0]\n          );\n          if (maxX - minX < this.sourceWorldWidth_ / 2) {\n            triangle.source = newTriangle;\n          }\n        }\n      });\n    }\n\n    transformInvCache = {};\n  }\n\n  /**\n   * Adds triangle to the triangulation.\n   * @param {import("../coordinate.js").Coordinate} a The target a coordinate.\n   * @param {import("../coordinate.js").Coordinate} b The target b coordinate.\n   * @param {import("../coordinate.js").Coordinate} c The target c coordinate.\n   * @param {import("../coordinate.js").Coordinate} aSrc The source a coordinate.\n   * @param {import("../coordinate.js").Coordinate} bSrc The source b coordinate.\n   * @param {import("../coordinate.js").Coordinate} cSrc The source c coordinate.\n   * @private\n   */\n  addTriangle_(a, b, c, aSrc, bSrc, cSrc) {\n    this.triangles_.push({\n      source: [aSrc, bSrc, cSrc],\n      target: [a, b, c],\n    });\n  }\n\n  /**\n   * Adds quad (points in clock-wise order) to the triangulation\n   * (and reprojects the vertices) if valid.\n   * Performs quad subdivision if needed to increase precision.\n   *\n   * @param {import("../coordinate.js").Coordinate} a The target a coordinate.\n   * @param {import("../coordinate.js").Coordinate} b The target b coordinate.\n   * @param {import("../coordinate.js").Coordinate} c The target c coordinate.\n   * @param {import("../coordinate.js").Coordinate} d The target d coordinate.\n   * @param {import("../coordinate.js").Coordinate} aSrc The source a coordinate.\n   * @param {import("../coordinate.js").Coordinate} bSrc The source b coordinate.\n   * @param {import("../coordinate.js").Coordinate} cSrc The source c coordinate.\n   * @param {import("../coordinate.js").Coordinate} dSrc The source d coordinate.\n   * @param {number} maxSubdivision Maximal allowed subdivision of the quad.\n   * @private\n   */\n  addQuad_(a, b, c, d, aSrc, bSrc, cSrc, dSrc, maxSubdivision) {\n    const sourceQuadExtent = (0,ol_extent/* boundingExtent */.hI)([aSrc, bSrc, cSrc, dSrc]);\n    const sourceCoverageX = this.sourceWorldWidth_\n      ? (0,ol_extent/* getWidth */.dz)(sourceQuadExtent) / this.sourceWorldWidth_\n      : null;\n    const sourceWorldWidth = /** @type {number} */ (this.sourceWorldWidth_);\n\n    // when the quad is wrapped in the source projection\n    // it covers most of the projection extent, but not fully\n    const wrapsX =\n      this.sourceProj_.canWrapX() &&\n      sourceCoverageX > 0.5 &&\n      sourceCoverageX < 1;\n\n    let needsSubdivision = false;\n\n    if (maxSubdivision > 0) {\n      if (this.targetProj_.isGlobal() && this.targetWorldWidth_) {\n        const targetQuadExtent = (0,ol_extent/* boundingExtent */.hI)([a, b, c, d]);\n        const targetCoverageX =\n          (0,ol_extent/* getWidth */.dz)(targetQuadExtent) / this.targetWorldWidth_;\n        needsSubdivision =\n          targetCoverageX > MAX_TRIANGLE_WIDTH || needsSubdivision;\n      }\n      if (!wrapsX && this.sourceProj_.isGlobal() && sourceCoverageX) {\n        needsSubdivision =\n          sourceCoverageX > MAX_TRIANGLE_WIDTH || needsSubdivision;\n      }\n    }\n\n    if (!needsSubdivision && this.maxSourceExtent_) {\n      if (\n        isFinite(sourceQuadExtent[0]) &&\n        isFinite(sourceQuadExtent[1]) &&\n        isFinite(sourceQuadExtent[2]) &&\n        isFinite(sourceQuadExtent[3])\n      ) {\n        if (!(0,ol_extent/* intersects */.kK)(sourceQuadExtent, this.maxSourceExtent_)) {\n          // whole quad outside source projection extent -> ignore\n          return;\n        }\n      }\n    }\n\n    let isNotFinite = 0;\n\n    if (!needsSubdivision) {\n      if (\n        !isFinite(aSrc[0]) ||\n        !isFinite(aSrc[1]) ||\n        !isFinite(bSrc[0]) ||\n        !isFinite(bSrc[1]) ||\n        !isFinite(cSrc[0]) ||\n        !isFinite(cSrc[1]) ||\n        !isFinite(dSrc[0]) ||\n        !isFinite(dSrc[1])\n      ) {\n        if (maxSubdivision > 0) {\n          needsSubdivision = true;\n        } else {\n          // It might be the case that only 1 of the points is infinite. In this case\n          // we can draw a single triangle with the other three points\n          isNotFinite =\n            (!isFinite(aSrc[0]) || !isFinite(aSrc[1]) ? 8 : 0) +\n            (!isFinite(bSrc[0]) || !isFinite(bSrc[1]) ? 4 : 0) +\n            (!isFinite(cSrc[0]) || !isFinite(cSrc[1]) ? 2 : 0) +\n            (!isFinite(dSrc[0]) || !isFinite(dSrc[1]) ? 1 : 0);\n          if (\n            isNotFinite != 1 &&\n            isNotFinite != 2 &&\n            isNotFinite != 4 &&\n            isNotFinite != 8\n          ) {\n            return;\n          }\n        }\n      }\n    }\n\n    if (maxSubdivision > 0) {\n      if (!needsSubdivision) {\n        const center = [(a[0] + c[0]) / 2, (a[1] + c[1]) / 2];\n        const centerSrc = this.transformInv_(center);\n\n        let dx;\n        if (wrapsX) {\n          const centerSrcEstimX =\n            ((0,math/* modulo */.$W)(aSrc[0], sourceWorldWidth) +\n              (0,math/* modulo */.$W)(cSrc[0], sourceWorldWidth)) /\n            2;\n          dx = centerSrcEstimX - (0,math/* modulo */.$W)(centerSrc[0], sourceWorldWidth);\n        } else {\n          dx = (aSrc[0] + cSrc[0]) / 2 - centerSrc[0];\n        }\n        const dy = (aSrc[1] + cSrc[1]) / 2 - centerSrc[1];\n        const centerSrcErrorSquared = dx * dx + dy * dy;\n        needsSubdivision = centerSrcErrorSquared > this.errorThresholdSquared_;\n      }\n      if (needsSubdivision) {\n        if (Math.abs(a[0] - c[0]) <= Math.abs(a[1] - c[1])) {\n          // split horizontally (top & bottom)\n          const bc = [(b[0] + c[0]) / 2, (b[1] + c[1]) / 2];\n          const bcSrc = this.transformInv_(bc);\n          const da = [(d[0] + a[0]) / 2, (d[1] + a[1]) / 2];\n          const daSrc = this.transformInv_(da);\n\n          this.addQuad_(\n            a,\n            b,\n            bc,\n            da,\n            aSrc,\n            bSrc,\n            bcSrc,\n            daSrc,\n            maxSubdivision - 1\n          );\n          this.addQuad_(\n            da,\n            bc,\n            c,\n            d,\n            daSrc,\n            bcSrc,\n            cSrc,\n            dSrc,\n            maxSubdivision - 1\n          );\n        } else {\n          // split vertically (left & right)\n          const ab = [(a[0] + b[0]) / 2, (a[1] + b[1]) / 2];\n          const abSrc = this.transformInv_(ab);\n          const cd = [(c[0] + d[0]) / 2, (c[1] + d[1]) / 2];\n          const cdSrc = this.transformInv_(cd);\n\n          this.addQuad_(\n            a,\n            ab,\n            cd,\n            d,\n            aSrc,\n            abSrc,\n            cdSrc,\n            dSrc,\n            maxSubdivision - 1\n          );\n          this.addQuad_(\n            ab,\n            b,\n            c,\n            cd,\n            abSrc,\n            bSrc,\n            cSrc,\n            cdSrc,\n            maxSubdivision - 1\n          );\n        }\n        return;\n      }\n    }\n\n    if (wrapsX) {\n      if (!this.canWrapXInSource_) {\n        return;\n      }\n      this.wrapsXInSource_ = true;\n    }\n\n    // Exactly zero or one of *Src is not finite\n    // The triangles must have the diagonal line as the first side\n    // This is to allow easy code in reproj.s to make it straight for broken\n    // browsers that can\'t handle diagonal clipping\n    if ((isNotFinite & 0xb) == 0) {\n      this.addTriangle_(a, c, d, aSrc, cSrc, dSrc);\n    }\n    if ((isNotFinite & 0xe) == 0) {\n      this.addTriangle_(a, c, b, aSrc, cSrc, bSrc);\n    }\n    if (isNotFinite) {\n      // Try the other two triangles\n      if ((isNotFinite & 0xd) == 0) {\n        this.addTriangle_(b, d, a, bSrc, dSrc, aSrc);\n      }\n      if ((isNotFinite & 0x7) == 0) {\n        this.addTriangle_(b, d, c, bSrc, dSrc, cSrc);\n      }\n    }\n  }\n\n  /**\n   * Calculates extent of the `source` coordinates from all the triangles.\n   *\n   * @return {import("../extent.js").Extent} Calculated extent.\n   */\n  calculateSourceExtent() {\n    const extent = (0,ol_extent/* createEmpty */.lJ)();\n\n    this.triangles_.forEach(function (triangle, i, arr) {\n      const src = triangle.source;\n      (0,ol_extent/* extendCoordinate */.Wj)(extent, src[0]);\n      (0,ol_extent/* extendCoordinate */.Wj)(extent, src[1]);\n      (0,ol_extent/* extendCoordinate */.Wj)(extent, src[2]);\n    });\n\n    return extent;\n  }\n\n  /**\n   * @return {Array<Triangle>} Array of the calculated triangles.\n   */\n  getTriangles() {\n    return this.triangles_;\n  }\n}\n\n/* harmony default export */ var reproj_Triangulation = (Triangulation);\n\n// EXTERNAL MODULE: ./node_modules/ol/dom.js\nvar dom = __webpack_require__(68326);\n;// CONCATENATED MODULE: ./node_modules/ol/reproj.js\n/**\n * @module ol/reproj\n */\n\n\n\n\n\nlet brokenDiagonalRendering_;\n\n/**\n * @type {Array<HTMLCanvasElement>}\n */\nconst canvasPool = [];\n\n/**\n * This draws a small triangle into a canvas by setting the triangle as the clip region\n * and then drawing a (too large) rectangle\n *\n * @param {CanvasRenderingContext2D} ctx The context in which to draw the triangle\n * @param {number} u1 The x-coordinate of the second point. The first point is 0,0.\n * @param {number} v1 The y-coordinate of the second point.\n * @param {number} u2 The x-coordinate of the third point.\n * @param {number} v2 The y-coordinate of the third point.\n */\nfunction drawTestTriangle(ctx, u1, v1, u2, v2) {\n  ctx.beginPath();\n  ctx.moveTo(0, 0);\n  ctx.lineTo(u1, v1);\n  ctx.lineTo(u2, v2);\n  ctx.closePath();\n  ctx.save();\n  ctx.clip();\n  ctx.fillRect(0, 0, Math.max(u1, u2) + 1, Math.max(v1, v2));\n  ctx.restore();\n}\n\n/**\n * Given the data from getImageData, see if the right values appear at the provided offset.\n * Returns true if either the color or transparency is off\n *\n * @param {Uint8ClampedArray} data The data returned from getImageData\n * @param {number} offset The pixel offset from the start of data.\n * @return {boolean} true if the diagonal rendering is broken\n */\nfunction verifyBrokenDiagonalRendering(data, offset) {\n  // the values ought to be close to the rgba(210, 0, 0, 0.75)\n  return (\n    Math.abs(data[offset * 4] - 210) > 2 ||\n    Math.abs(data[offset * 4 + 3] - 0.75 * 255) > 2\n  );\n}\n\n/**\n * Determines if the current browser configuration can render triangular clip regions correctly.\n * This value is cached so the function is only expensive the first time called.\n * Firefox on Windows (as of now) does not if HWA is enabled. See https://bugzilla.mozilla.org/show_bug.cgi?id=1606976\n * Chrome works, and everything seems to work on OSX and Android. This function caches the\n * result. I suppose that it is conceivably possible that a browser might flip modes while the app is\n * running, but lets hope not.\n *\n * @return {boolean} true if the Diagonal Rendering is broken.\n */\nfunction isBrokenDiagonalRendering() {\n  if (brokenDiagonalRendering_ === undefined) {\n    const ctx = (0,dom/* createCanvasContext2D */.E4)(6, 6, canvasPool);\n    ctx.globalCompositeOperation = \'lighter\';\n    ctx.fillStyle = \'rgba(210, 0, 0, 0.75)\';\n    drawTestTriangle(ctx, 4, 5, 4, 0);\n    drawTestTriangle(ctx, 4, 5, 0, 5);\n    const data = ctx.getImageData(0, 0, 3, 3).data;\n    brokenDiagonalRendering_ =\n      verifyBrokenDiagonalRendering(data, 0) ||\n      verifyBrokenDiagonalRendering(data, 4) ||\n      verifyBrokenDiagonalRendering(data, 8);\n    (0,dom/* releaseCanvas */.jy)(ctx);\n    canvasPool.push(ctx.canvas);\n  }\n\n  return brokenDiagonalRendering_;\n}\n\n/**\n * Calculates ideal resolution to use from the source in order to achieve\n * pixel mapping as close as possible to 1:1 during reprojection.\n * The resolution is calculated regardless of what resolutions\n * are actually available in the dataset (TileGrid, Image, ...).\n *\n * @param {import("./proj/Projection.js").default} sourceProj Source projection.\n * @param {import("./proj/Projection.js").default} targetProj Target projection.\n * @param {import("./coordinate.js").Coordinate} targetCenter Target center.\n * @param {number} targetResolution Target resolution.\n * @return {number} The best resolution to use. Can be +-Infinity, NaN or 0.\n */\nfunction calculateSourceResolution(\n  sourceProj,\n  targetProj,\n  targetCenter,\n  targetResolution\n) {\n  const sourceCenter = (0,proj/* transform */.vs)(targetCenter, targetProj, sourceProj);\n\n  // calculate the ideal resolution of the source data\n  let sourceResolution = (0,proj/* getPointResolution */._Q)(\n    targetProj,\n    targetResolution,\n    targetCenter\n  );\n\n  const targetMetersPerUnit = targetProj.getMetersPerUnit();\n  if (targetMetersPerUnit !== undefined) {\n    sourceResolution *= targetMetersPerUnit;\n  }\n  const sourceMetersPerUnit = sourceProj.getMetersPerUnit();\n  if (sourceMetersPerUnit !== undefined) {\n    sourceResolution /= sourceMetersPerUnit;\n  }\n\n  // Based on the projection properties, the point resolution at the specified\n  // coordinates may be slightly different. We need to reverse-compensate this\n  // in order to achieve optimal results.\n\n  const sourceExtent = sourceProj.getExtent();\n  if (!sourceExtent || (0,ol_extent/* containsCoordinate */.b8)(sourceExtent, sourceCenter)) {\n    const compensationFactor =\n      (0,proj/* getPointResolution */._Q)(sourceProj, sourceResolution, sourceCenter) /\n      sourceResolution;\n    if (isFinite(compensationFactor) && compensationFactor > 0) {\n      sourceResolution /= compensationFactor;\n    }\n  }\n\n  return sourceResolution;\n}\n\n/**\n * Calculates ideal resolution to use from the source in order to achieve\n * pixel mapping as close as possible to 1:1 during reprojection.\n * The resolution is calculated regardless of what resolutions\n * are actually available in the dataset (TileGrid, Image, ...).\n *\n * @param {import("./proj/Projection.js").default} sourceProj Source projection.\n * @param {import("./proj/Projection.js").default} targetProj Target projection.\n * @param {import("./extent.js").Extent} targetExtent Target extent\n * @param {number} targetResolution Target resolution.\n * @return {number} The best resolution to use. Can be +-Infinity, NaN or 0.\n */\nfunction calculateSourceExtentResolution(\n  sourceProj,\n  targetProj,\n  targetExtent,\n  targetResolution\n) {\n  const targetCenter = (0,ol_extent/* getCenter */.qg)(targetExtent);\n  let sourceResolution = calculateSourceResolution(\n    sourceProj,\n    targetProj,\n    targetCenter,\n    targetResolution\n  );\n\n  if (!isFinite(sourceResolution) || sourceResolution <= 0) {\n    (0,ol_extent/* forEachCorner */.H6)(targetExtent, function (corner) {\n      sourceResolution = calculateSourceResolution(\n        sourceProj,\n        targetProj,\n        corner,\n        targetResolution\n      );\n      return isFinite(sourceResolution) && sourceResolution > 0;\n    });\n  }\n\n  return sourceResolution;\n}\n\n/**\n * @typedef {Object} ImageExtent\n * @property {import("./extent.js").Extent} extent Extent.\n * @property {HTMLCanvasElement|HTMLImageElement|HTMLVideoElement} image Image.\n */\n\n/**\n * Renders the source data into new canvas based on the triangulation.\n *\n * @param {number} width Width of the canvas.\n * @param {number} height Height of the canvas.\n * @param {number} pixelRatio Pixel ratio.\n * @param {number} sourceResolution Source resolution.\n * @param {import("./extent.js").Extent} sourceExtent Extent of the data source.\n * @param {number} targetResolution Target resolution.\n * @param {import("./extent.js").Extent} targetExtent Target extent.\n * @param {import("./reproj/Triangulation.js").default} triangulation Calculated triangulation.\n * @param {Array<ImageExtent>} sources Array of sources.\n * @param {number} gutter Gutter of the sources.\n * @param {boolean} [renderEdges] Render reprojection edges.\n * @param {boolean} [interpolate] Use linear interpolation when resampling.\n * @return {HTMLCanvasElement} Canvas with reprojected data.\n */\nfunction render(\n  width,\n  height,\n  pixelRatio,\n  sourceResolution,\n  sourceExtent,\n  targetResolution,\n  targetExtent,\n  triangulation,\n  sources,\n  gutter,\n  renderEdges,\n  interpolate\n) {\n  const context = (0,dom/* createCanvasContext2D */.E4)(\n    Math.round(pixelRatio * width),\n    Math.round(pixelRatio * height),\n    canvasPool\n  );\n\n  if (!interpolate) {\n    context.imageSmoothingEnabled = false;\n  }\n\n  if (sources.length === 0) {\n    return context.canvas;\n  }\n\n  context.scale(pixelRatio, pixelRatio);\n\n  function pixelRound(value) {\n    return Math.round(value * pixelRatio) / pixelRatio;\n  }\n\n  context.globalCompositeOperation = \'lighter\';\n\n  const sourceDataExtent = (0,ol_extent/* createEmpty */.lJ)();\n  sources.forEach(function (src, i, arr) {\n    (0,ol_extent/* extend */.l7)(sourceDataExtent, src.extent);\n  });\n\n  const canvasWidthInUnits = (0,ol_extent/* getWidth */.dz)(sourceDataExtent);\n  const canvasHeightInUnits = (0,ol_extent/* getHeight */.Cr)(sourceDataExtent);\n  const stitchContext = (0,dom/* createCanvasContext2D */.E4)(\n    Math.round((pixelRatio * canvasWidthInUnits) / sourceResolution),\n    Math.round((pixelRatio * canvasHeightInUnits) / sourceResolution),\n    canvasPool\n  );\n\n  if (!interpolate) {\n    stitchContext.imageSmoothingEnabled = false;\n  }\n\n  const stitchScale = pixelRatio / sourceResolution;\n\n  sources.forEach(function (src, i, arr) {\n    const xPos = src.extent[0] - sourceDataExtent[0];\n    const yPos = -(src.extent[3] - sourceDataExtent[3]);\n    const srcWidth = (0,ol_extent/* getWidth */.dz)(src.extent);\n    const srcHeight = (0,ol_extent/* getHeight */.Cr)(src.extent);\n\n    // This test should never fail -- but it does. Need to find a fix the upstream condition\n    if (src.image.width > 0 && src.image.height > 0) {\n      stitchContext.drawImage(\n        src.image,\n        gutter,\n        gutter,\n        src.image.width - 2 * gutter,\n        src.image.height - 2 * gutter,\n        xPos * stitchScale,\n        yPos * stitchScale,\n        srcWidth * stitchScale,\n        srcHeight * stitchScale\n      );\n    }\n  });\n\n  const targetTopLeft = (0,ol_extent/* getTopLeft */.rL)(targetExtent);\n\n  triangulation.getTriangles().forEach(function (triangle, i, arr) {\n    /* Calculate affine transform (src -> dst)\n     * Resulting matrix can be used to transform coordinate\n     * from `sourceProjection` to destination pixels.\n     *\n     * To optimize number of context calls and increase numerical stability,\n     * we also do the following operations:\n     * trans(-topLeftExtentCorner), scale(1 / targetResolution), scale(1, -1)\n     * here before solving the linear system so [ui, vi] are pixel coordinates.\n     *\n     * Src points: xi, yi\n     * Dst points: ui, vi\n     * Affine coefficients: aij\n     *\n     * | x0 y0 1  0  0 0 |   |a00|   |u0|\n     * | x1 y1 1  0  0 0 |   |a01|   |u1|\n     * | x2 y2 1  0  0 0 | x |a02| = |u2|\n     * |  0  0 0 x0 y0 1 |   |a10|   |v0|\n     * |  0  0 0 x1 y1 1 |   |a11|   |v1|\n     * |  0  0 0 x2 y2 1 |   |a12|   |v2|\n     */\n    const source = triangle.source;\n    const target = triangle.target;\n    let x0 = source[0][0],\n      y0 = source[0][1];\n    let x1 = source[1][0],\n      y1 = source[1][1];\n    let x2 = source[2][0],\n      y2 = source[2][1];\n    // Make sure that everything is on pixel boundaries\n    const u0 = pixelRound((target[0][0] - targetTopLeft[0]) / targetResolution);\n    const v0 = pixelRound(\n      -(target[0][1] - targetTopLeft[1]) / targetResolution\n    );\n    const u1 = pixelRound((target[1][0] - targetTopLeft[0]) / targetResolution);\n    const v1 = pixelRound(\n      -(target[1][1] - targetTopLeft[1]) / targetResolution\n    );\n    const u2 = pixelRound((target[2][0] - targetTopLeft[0]) / targetResolution);\n    const v2 = pixelRound(\n      -(target[2][1] - targetTopLeft[1]) / targetResolution\n    );\n\n    // Shift all the source points to improve numerical stability\n    // of all the subsequent calculations. The [x0, y0] is used here.\n    // This is also used to simplify the linear system.\n    const sourceNumericalShiftX = x0;\n    const sourceNumericalShiftY = y0;\n    x0 = 0;\n    y0 = 0;\n    x1 -= sourceNumericalShiftX;\n    y1 -= sourceNumericalShiftY;\n    x2 -= sourceNumericalShiftX;\n    y2 -= sourceNumericalShiftY;\n\n    const augmentedMatrix = [\n      [x1, y1, 0, 0, u1 - u0],\n      [x2, y2, 0, 0, u2 - u0],\n      [0, 0, x1, y1, v1 - v0],\n      [0, 0, x2, y2, v2 - v0],\n    ];\n    const affineCoefs = (0,math/* solveLinearSystem */.SV)(augmentedMatrix);\n    if (!affineCoefs) {\n      return;\n    }\n\n    context.save();\n    context.beginPath();\n\n    if (isBrokenDiagonalRendering() || !interpolate) {\n      // Make sure that all lines are horizontal or vertical\n      context.moveTo(u1, v1);\n      // This is the diagonal line. Do it in 4 steps\n      const steps = 4;\n      const ud = u0 - u1;\n      const vd = v0 - v1;\n      for (let step = 0; step < steps; step++) {\n        // Go horizontally\n        context.lineTo(\n          u1 + pixelRound(((step + 1) * ud) / steps),\n          v1 + pixelRound((step * vd) / (steps - 1))\n        );\n        // Go vertically\n        if (step != steps - 1) {\n          context.lineTo(\n            u1 + pixelRound(((step + 1) * ud) / steps),\n            v1 + pixelRound(((step + 1) * vd) / (steps - 1))\n          );\n        }\n      }\n      // We are almost at u0r, v0r\n      context.lineTo(u2, v2);\n    } else {\n      context.moveTo(u1, v1);\n      context.lineTo(u0, v0);\n      context.lineTo(u2, v2);\n    }\n\n    context.clip();\n\n    context.transform(\n      affineCoefs[0],\n      affineCoefs[2],\n      affineCoefs[1],\n      affineCoefs[3],\n      u0,\n      v0\n    );\n\n    context.translate(\n      sourceDataExtent[0] - sourceNumericalShiftX,\n      sourceDataExtent[3] - sourceNumericalShiftY\n    );\n\n    context.scale(\n      sourceResolution / pixelRatio,\n      -sourceResolution / pixelRatio\n    );\n\n    context.drawImage(stitchContext.canvas, 0, 0);\n    context.restore();\n  });\n\n  (0,dom/* releaseCanvas */.jy)(stitchContext);\n  canvasPool.push(stitchContext.canvas);\n\n  if (renderEdges) {\n    context.save();\n\n    context.globalCompositeOperation = \'source-over\';\n    context.strokeStyle = \'black\';\n    context.lineWidth = 1;\n\n    triangulation.getTriangles().forEach(function (triangle, i, arr) {\n      const target = triangle.target;\n      const u0 = (target[0][0] - targetTopLeft[0]) / targetResolution;\n      const v0 = -(target[0][1] - targetTopLeft[1]) / targetResolution;\n      const u1 = (target[1][0] - targetTopLeft[0]) / targetResolution;\n      const v1 = -(target[1][1] - targetTopLeft[1]) / targetResolution;\n      const u2 = (target[2][0] - targetTopLeft[0]) / targetResolution;\n      const v2 = -(target[2][1] - targetTopLeft[1]) / targetResolution;\n\n      context.beginPath();\n      context.moveTo(u1, v1);\n      context.lineTo(u0, v0);\n      context.lineTo(u2, v2);\n      context.closePath();\n      context.stroke();\n    });\n\n    context.restore();\n  }\n  return context.canvas;\n}\n\n// EXTERNAL MODULE: ./node_modules/ol/events.js\nvar events = __webpack_require__(65818);\n;// CONCATENATED MODULE: ./node_modules/ol/reproj/Tile.js\n/**\n * @module ol/reproj/Tile\n */\n\n\n\n\n\n\n\n\n\n\n\n\n/**\n * @typedef {function(number, number, number, number) : (import("../ImageTile.js").default)} FunctionType\n */\n\n/**\n * @classdesc\n * Class encapsulating single reprojected tile.\n * See {@link module:ol/source/TileImage~TileImage}.\n *\n */\nclass ReprojTile extends Tile/* default */.Z {\n  /**\n   * @param {import("../proj/Projection.js").default} sourceProj Source projection.\n   * @param {import("../tilegrid/TileGrid.js").default} sourceTileGrid Source tile grid.\n   * @param {import("../proj/Projection.js").default} targetProj Target projection.\n   * @param {import("../tilegrid/TileGrid.js").default} targetTileGrid Target tile grid.\n   * @param {import("../tilecoord.js").TileCoord} tileCoord Coordinate of the tile.\n   * @param {import("../tilecoord.js").TileCoord} wrappedTileCoord Coordinate of the tile wrapped in X.\n   * @param {number} pixelRatio Pixel ratio.\n   * @param {number} gutter Gutter of the source tiles.\n   * @param {FunctionType} getTileFunction\n   *     Function returning source tiles (z, x, y, pixelRatio).\n   * @param {number} [errorThreshold] Acceptable reprojection error (in px).\n   * @param {boolean} [renderEdges] Render reprojection edges.\n   * @param {boolean} [interpolate] Use linear interpolation when resampling.\n   */\n  constructor(\n    sourceProj,\n    sourceTileGrid,\n    targetProj,\n    targetTileGrid,\n    tileCoord,\n    wrappedTileCoord,\n    pixelRatio,\n    gutter,\n    getTileFunction,\n    errorThreshold,\n    renderEdges,\n    interpolate\n  ) {\n    super(tileCoord, TileState/* default.IDLE */.Z.IDLE, {interpolate: !!interpolate});\n\n    /**\n     * @private\n     * @type {boolean}\n     */\n    this.renderEdges_ = renderEdges !== undefined ? renderEdges : false;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.pixelRatio_ = pixelRatio;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.gutter_ = gutter;\n\n    /**\n     * @private\n     * @type {HTMLCanvasElement}\n     */\n    this.canvas_ = null;\n\n    /**\n     * @private\n     * @type {import("../tilegrid/TileGrid.js").default}\n     */\n    this.sourceTileGrid_ = sourceTileGrid;\n\n    /**\n     * @private\n     * @type {import("../tilegrid/TileGrid.js").default}\n     */\n    this.targetTileGrid_ = targetTileGrid;\n\n    /**\n     * @private\n     * @type {import("../tilecoord.js").TileCoord}\n     */\n    this.wrappedTileCoord_ = wrappedTileCoord ? wrappedTileCoord : tileCoord;\n\n    /**\n     * @private\n     * @type {!Array<import("../ImageTile.js").default>}\n     */\n    this.sourceTiles_ = [];\n\n    /**\n     * @private\n     * @type {?Array<import("../events.js").EventsKey>}\n     */\n    this.sourcesListenerKeys_ = null;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.sourceZ_ = 0;\n\n    const targetExtent = targetTileGrid.getTileCoordExtent(\n      this.wrappedTileCoord_\n    );\n    const maxTargetExtent = this.targetTileGrid_.getExtent();\n    let maxSourceExtent = this.sourceTileGrid_.getExtent();\n\n    const limitedTargetExtent = maxTargetExtent\n      ? (0,ol_extent/* getIntersection */.Ed)(targetExtent, maxTargetExtent)\n      : targetExtent;\n\n    if ((0,ol_extent/* getArea */.bg)(limitedTargetExtent) === 0) {\n      // Tile is completely outside range -> EMPTY\n      // TODO: is it actually correct that the source even creates the tile ?\n      this.state = TileState/* default.EMPTY */.Z.EMPTY;\n      return;\n    }\n\n    const sourceProjExtent = sourceProj.getExtent();\n    if (sourceProjExtent) {\n      if (!maxSourceExtent) {\n        maxSourceExtent = sourceProjExtent;\n      } else {\n        maxSourceExtent = (0,ol_extent/* getIntersection */.Ed)(maxSourceExtent, sourceProjExtent);\n      }\n    }\n\n    const targetResolution = targetTileGrid.getResolution(\n      this.wrappedTileCoord_[0]\n    );\n\n    const sourceResolution = calculateSourceExtentResolution(\n      sourceProj,\n      targetProj,\n      limitedTargetExtent,\n      targetResolution\n    );\n\n    if (!isFinite(sourceResolution) || sourceResolution <= 0) {\n      // invalid sourceResolution -> EMPTY\n      // probably edges of the projections when no extent is defined\n      this.state = TileState/* default.EMPTY */.Z.EMPTY;\n      return;\n    }\n\n    const errorThresholdInPixels =\n      errorThreshold !== undefined ? errorThreshold : ERROR_THRESHOLD;\n\n    /**\n     * @private\n     * @type {!import("./Triangulation.js").default}\n     */\n    this.triangulation_ = new reproj_Triangulation(\n      sourceProj,\n      targetProj,\n      limitedTargetExtent,\n      maxSourceExtent,\n      sourceResolution * errorThresholdInPixels,\n      targetResolution\n    );\n\n    if (this.triangulation_.getTriangles().length === 0) {\n      // no valid triangles -> EMPTY\n      this.state = TileState/* default.EMPTY */.Z.EMPTY;\n      return;\n    }\n\n    this.sourceZ_ = sourceTileGrid.getZForResolution(sourceResolution);\n    let sourceExtent = this.triangulation_.calculateSourceExtent();\n\n    if (maxSourceExtent) {\n      if (sourceProj.canWrapX()) {\n        sourceExtent[1] = (0,math/* clamp */.uZ)(\n          sourceExtent[1],\n          maxSourceExtent[1],\n          maxSourceExtent[3]\n        );\n        sourceExtent[3] = (0,math/* clamp */.uZ)(\n          sourceExtent[3],\n          maxSourceExtent[1],\n          maxSourceExtent[3]\n        );\n      } else {\n        sourceExtent = (0,ol_extent/* getIntersection */.Ed)(sourceExtent, maxSourceExtent);\n      }\n    }\n\n    if (!(0,ol_extent/* getArea */.bg)(sourceExtent)) {\n      this.state = TileState/* default.EMPTY */.Z.EMPTY;\n    } else {\n      const sourceRange = sourceTileGrid.getTileRangeForExtentAndZ(\n        sourceExtent,\n        this.sourceZ_\n      );\n\n      for (let srcX = sourceRange.minX; srcX <= sourceRange.maxX; srcX++) {\n        for (let srcY = sourceRange.minY; srcY <= sourceRange.maxY; srcY++) {\n          const tile = getTileFunction(this.sourceZ_, srcX, srcY, pixelRatio);\n          if (tile) {\n            this.sourceTiles_.push(tile);\n          }\n        }\n      }\n\n      if (this.sourceTiles_.length === 0) {\n        this.state = TileState/* default.EMPTY */.Z.EMPTY;\n      }\n    }\n  }\n\n  /**\n   * Get the HTML Canvas element for this tile.\n   * @return {HTMLCanvasElement} Canvas.\n   */\n  getImage() {\n    return this.canvas_;\n  }\n\n  /**\n   * @private\n   */\n  reproject_() {\n    const sources = [];\n    this.sourceTiles_.forEach((tile) => {\n      if (tile && tile.getState() == TileState/* default.LOADED */.Z.LOADED) {\n        sources.push({\n          extent: this.sourceTileGrid_.getTileCoordExtent(tile.tileCoord),\n          image: tile.getImage(),\n        });\n      }\n    });\n    this.sourceTiles_.length = 0;\n\n    if (sources.length === 0) {\n      this.state = TileState/* default.ERROR */.Z.ERROR;\n    } else {\n      const z = this.wrappedTileCoord_[0];\n      const size = this.targetTileGrid_.getTileSize(z);\n      const width = typeof size === \'number\' ? size : size[0];\n      const height = typeof size === \'number\' ? size : size[1];\n      const targetResolution = this.targetTileGrid_.getResolution(z);\n      const sourceResolution = this.sourceTileGrid_.getResolution(\n        this.sourceZ_\n      );\n\n      const targetExtent = this.targetTileGrid_.getTileCoordExtent(\n        this.wrappedTileCoord_\n      );\n\n      this.canvas_ = render(\n        width,\n        height,\n        this.pixelRatio_,\n        sourceResolution,\n        this.sourceTileGrid_.getExtent(),\n        targetResolution,\n        targetExtent,\n        this.triangulation_,\n        sources,\n        this.gutter_,\n        this.renderEdges_,\n        this.interpolate\n      );\n\n      this.state = TileState/* default.LOADED */.Z.LOADED;\n    }\n    this.changed();\n  }\n\n  /**\n   * Load not yet loaded URI.\n   */\n  load() {\n    if (this.state == TileState/* default.IDLE */.Z.IDLE) {\n      this.state = TileState/* default.LOADING */.Z.LOADING;\n      this.changed();\n\n      let leftToLoad = 0;\n\n      this.sourcesListenerKeys_ = [];\n      this.sourceTiles_.forEach((tile) => {\n        const state = tile.getState();\n        if (state == TileState/* default.IDLE */.Z.IDLE || state == TileState/* default.LOADING */.Z.LOADING) {\n          leftToLoad++;\n\n          const sourceListenKey = (0,events/* listen */.oL)(\n            tile,\n            EventType/* default.CHANGE */.Z.CHANGE,\n            function (e) {\n              const state = tile.getState();\n              if (\n                state == TileState/* default.LOADED */.Z.LOADED ||\n                state == TileState/* default.ERROR */.Z.ERROR ||\n                state == TileState/* default.EMPTY */.Z.EMPTY\n              ) {\n                (0,events/* unlistenByKey */.bN)(sourceListenKey);\n                leftToLoad--;\n                if (leftToLoad === 0) {\n                  this.unlistenSources_();\n                  this.reproject_();\n                }\n              }\n            },\n            this\n          );\n          this.sourcesListenerKeys_.push(sourceListenKey);\n        }\n      });\n\n      if (leftToLoad === 0) {\n        setTimeout(this.reproject_.bind(this), 0);\n      } else {\n        this.sourceTiles_.forEach(function (tile, i, arr) {\n          const state = tile.getState();\n          if (state == TileState/* default.IDLE */.Z.IDLE) {\n            tile.load();\n          }\n        });\n      }\n    }\n  }\n\n  /**\n   * @private\n   */\n  unlistenSources_() {\n    this.sourcesListenerKeys_.forEach(events/* unlistenByKey */.bN);\n    this.sourcesListenerKeys_ = null;\n  }\n\n  /**\n   * Remove from the cache due to expiry\n   */\n  release() {\n    if (this.canvas_) {\n      (0,dom/* releaseCanvas */.jy)(this.canvas_.getContext(\'2d\'));\n      canvasPool.push(this.canvas_);\n      this.canvas_ = null;\n    }\n    super.release();\n  }\n}\n\n/* harmony default export */ var reproj_Tile = (ReprojTile);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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O0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLHVCQUF1QixrQ0FBYztBQUNyQztBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQyw0QkFBYTtBQUNuRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNLDZCQUFhO0FBQ25CLE1BQU0sZUFBZTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGdEQUFlLFVBQVUsRUFBQyIsInNvdXJjZXMiOlsid2VicGFjazovL3Z1ZTMtd2VicGFjazUvLi9ub2RlX21vZHVsZXMvb2wvcmVwcm9qL2NvbW1vbi5qcz85ZjY4Iiwid2VicGFjazovL3Z1ZTMtd2VicGFjazUvLi9ub2RlX21vZHVsZXMvb2wvcmVwcm9qL1RyaWFuZ3VsYXRpb24uanM/MDgzMyIsIndlYnBhY2s6Ly92dWUzLXdlYnBhY2s1Ly4vbm9kZV9tb2R1bGVzL29sL3JlcHJvai5qcz8xNDQ5Iiwid2VicGFjazovL3Z1ZTMtd2VicGFjazUvLi9ub2RlX21vZHVsZXMvb2wvcmVwcm9qL1RpbGUuanM/M2U2NSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBtb2R1bGUgb2wvcmVwcm9qL2NvbW1vblxuICovXG5cbi8qKlxuICogRGVmYXVsdCBtYXhpbXVtIGFsbG93ZWQgdGhyZXNob2xkICAoaW4gcGl4ZWxzKSBmb3IgcmVwcm9qZWN0aW9uXG4gKiB0cmlhbmd1bGF0aW9uLlxuICogQHR5cGUge251bWJlcn1cbiAqL1xuZXhwb3J0IGNvbnN0IEVSUk9SX1RIUkVTSE9MRCA9IDAuNTtcbiIsIi8qKlxuICogQG1vZHVsZSBvbC9yZXByb2ovVHJpYW5ndWxhdGlvblxuICovXG5pbXBvcnQge1xuICBib3VuZGluZ0V4dGVudCxcbiAgY3JlYXRlRW1wdHksXG4gIGV4dGVuZENvb3JkaW5hdGUsXG4gIGdldEFyZWEsXG4gIGdldEJvdHRvbUxlZnQsXG4gIGdldEJvdHRvbVJpZ2h0LFxuICBnZXRUb3BMZWZ0LFxuICBnZXRUb3BSaWdodCxcbiAgZ2V0V2lkdGgsXG4gIGludGVyc2VjdHMsXG59IGZyb20gJy4uL2V4dGVudC5qcyc7XG5pbXBvcnQge2dldFRyYW5zZm9ybX0gZnJvbSAnLi4vcHJvai5qcyc7XG5pbXBvcnQge21vZHVsb30gZnJvbSAnLi4vbWF0aC5qcyc7XG5cbi8qKlxuICogU2luZ2xlIHRyaWFuZ2xlOyBjb25zaXN0cyBvZiAzIHNvdXJjZSBwb2ludHMgYW5kIDMgdGFyZ2V0IHBvaW50cy5cbiAqIEB0eXBlZGVmIHtPYmplY3R9IFRyaWFuZ2xlXG4gKiBAcHJvcGVydHkge0FycmF5PGltcG9ydChcIi4uL2Nvb3JkaW5hdGUuanNcIikuQ29vcmRpbmF0ZT59IHNvdXJjZSBTb3VyY2UuXG4gKiBAcHJvcGVydHkge0FycmF5PGltcG9ydChcIi4uL2Nvb3JkaW5hdGUuanNcIikuQ29vcmRpbmF0ZT59IHRhcmdldCBUYXJnZXQuXG4gKi9cblxuLyoqXG4gKiBNYXhpbXVtIG51bWJlciBvZiBzdWJkaXZpc2lvbiBzdGVwcyBkdXJpbmcgcmFzdGVyIHJlcHJvamVjdGlvbiB0cmlhbmd1bGF0aW9uLlxuICogUHJldmVudHMgaGlnaCBtZW1vcnkgdXNhZ2UgYW5kIGxhcmdlIG51bWJlciBvZiBwcm9qNCBjYWxscyAoZm9yIGNlcnRhaW5cbiAqIHRyYW5zZm9ybWF0aW9ucyBhbmQgYXJlYXMpLiBBdCBtb3N0IGAyKigyXnRoaXMpYCB0cmlhbmdsZXMgYXJlIGNyZWF0ZWQgZm9yXG4gKiBlYWNoIHRyaWFuZ3VsYXRlZCBleHRlbnQgKHRpbGUvaW1hZ2UpLlxuICogQHR5cGUge251bWJlcn1cbiAqL1xuY29uc3QgTUFYX1NVQkRJVklTSU9OID0gMTA7XG5cbi8qKlxuICogTWF4aW11bSBhbGxvd2VkIHNpemUgb2YgdHJpYW5nbGUgcmVsYXRpdmUgdG8gd29ybGQgd2lkdGguIFdoZW4gdHJhbnNmb3JtaW5nXG4gKiBjb3JuZXJzIG9mIHdvcmxkIGV4dGVudCBiZXR3ZWVuIGNlcnRhaW4gcHJvamVjdGlvbnMsIHRoZSByZXN1bHRpbmdcbiAqIHRyaWFuZ3VsYXRpb24gc2VlbXMgdG8gaGF2ZSB6ZXJvIGVycm9yIGFuZCBubyBzdWJkaXZpc2lvbiBpcyBwZXJmb3JtZWQuIElmXG4gKiB0aGUgdHJpYW5nbGUgd2lkdGggaXMgbW9yZSB0aGFuIHRoaXMgKHJlbGF0aXZlIHRvIHdvcmxkIHdpZHRoOyAwLTEpLFxuICogc3ViZGl2aXNvbiBpcyBmb3JjZWQgKHVwIHRvIGBNQVhfU1VCRElWSVNJT05gKS4gRGVmYXVsdCBpcyBgMC4yNWAuXG4gKiBAdHlwZSB7bnVtYmVyfVxuICovXG5jb25zdCBNQVhfVFJJQU5HTEVfV0lEVEggPSAwLjI1O1xuXG4vKipcbiAqIEBjbGFzc2Rlc2NcbiAqIENsYXNzIGNvbnRhaW5pbmcgdHJpYW5ndWxhdGlvbiBvZiB0aGUgZ2l2ZW4gdGFyZ2V0IGV4dGVudC5cbiAqIFVzZWQgZm9yIGRldGVybWluaW5nIHNvdXJjZSBkYXRhIGFuZCB0aGUgcmVwcm9qZWN0aW9uIGl0c2VsZi5cbiAqL1xuY2xhc3MgVHJpYW5ndWxhdGlvbiB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL3Byb2ovUHJvamVjdGlvbi5qc1wiKS5kZWZhdWx0fSBzb3VyY2VQcm9qIFNvdXJjZSBwcm9qZWN0aW9uLlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL3Byb2ovUHJvamVjdGlvbi5qc1wiKS5kZWZhdWx0fSB0YXJnZXRQcm9qIFRhcmdldCBwcm9qZWN0aW9uLlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL2V4dGVudC5qc1wiKS5FeHRlbnR9IHRhcmdldEV4dGVudCBUYXJnZXQgZXh0ZW50IHRvIHRyaWFuZ3VsYXRlLlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL2V4dGVudC5qc1wiKS5FeHRlbnR9IG1heFNvdXJjZUV4dGVudCBNYXhpbWFsIHNvdXJjZSBleHRlbnQgdGhhdCBjYW4gYmUgdXNlZC5cbiAgICogQHBhcmFtIHtudW1iZXJ9IGVycm9yVGhyZXNob2xkIEFjY2VwdGFibGUgZXJyb3IgKGluIHNvdXJjZSB1bml0cykuXG4gICAqIEBwYXJhbSB7P251bWJlcn0gZGVzdGluYXRpb25SZXNvbHV0aW9uIFRoZSAob3B0aW9uYWwpIHJlc29sdXRpb24gb2YgdGhlIGRlc3RpbmF0aW9uLlxuICAgKi9cbiAgY29uc3RydWN0b3IoXG4gICAgc291cmNlUHJvaixcbiAgICB0YXJnZXRQcm9qLFxuICAgIHRhcmdldEV4dGVudCxcbiAgICBtYXhTb3VyY2VFeHRlbnQsXG4gICAgZXJyb3JUaHJlc2hvbGQsXG4gICAgZGVzdGluYXRpb25SZXNvbHV0aW9uXG4gICkge1xuICAgIC8qKlxuICAgICAqIEB0eXBlIHtpbXBvcnQoXCIuLi9wcm9qL1Byb2plY3Rpb24uanNcIikuZGVmYXVsdH1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMuc291cmNlUHJval8gPSBzb3VyY2VQcm9qO1xuXG4gICAgLyoqXG4gICAgICogQHR5cGUge2ltcG9ydChcIi4uL3Byb2ovUHJvamVjdGlvbi5qc1wiKS5kZWZhdWx0fVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy50YXJnZXRQcm9qXyA9IHRhcmdldFByb2o7XG5cbiAgICAvKiogQHR5cGUgeyFPYmplY3Q8c3RyaW5nLCBpbXBvcnQoXCIuLi9jb29yZGluYXRlLmpzXCIpLkNvb3JkaW5hdGU+fSAqL1xuICAgIGxldCB0cmFuc2Zvcm1JbnZDYWNoZSA9IHt9O1xuICAgIGNvbnN0IHRyYW5zZm9ybUludiA9IGdldFRyYW5zZm9ybSh0aGlzLnRhcmdldFByb2pfLCB0aGlzLnNvdXJjZVByb2pfKTtcblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vY29vcmRpbmF0ZS5qc1wiKS5Db29yZGluYXRlfSBjIEEgY29vcmRpbmF0ZS5cbiAgICAgKiBAcmV0dXJuIHtpbXBvcnQoXCIuLi9jb29yZGluYXRlLmpzXCIpLkNvb3JkaW5hdGV9IFRyYW5zZm9ybWVkIGNvb3JkaW5hdGUuXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLnRyYW5zZm9ybUludl8gPSBmdW5jdGlvbiAoYykge1xuICAgICAgY29uc3Qga2V5ID0gY1swXSArICcvJyArIGNbMV07XG4gICAgICBpZiAoIXRyYW5zZm9ybUludkNhY2hlW2tleV0pIHtcbiAgICAgICAgdHJhbnNmb3JtSW52Q2FjaGVba2V5XSA9IHRyYW5zZm9ybUludihjKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0cmFuc2Zvcm1JbnZDYWNoZVtrZXldO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBAdHlwZSB7aW1wb3J0KFwiLi4vZXh0ZW50LmpzXCIpLkV4dGVudH1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMubWF4U291cmNlRXh0ZW50XyA9IG1heFNvdXJjZUV4dGVudDtcblxuICAgIC8qKlxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLmVycm9yVGhyZXNob2xkU3F1YXJlZF8gPSBlcnJvclRocmVzaG9sZCAqIGVycm9yVGhyZXNob2xkO1xuXG4gICAgLyoqXG4gICAgICogQHR5cGUge0FycmF5PFRyaWFuZ2xlPn1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMudHJpYW5nbGVzXyA9IFtdO1xuXG4gICAgLyoqXG4gICAgICogSW5kaWNhdGVzIHRoYXQgdGhlIHRyaWFuZ3VsYXRpb24gY3Jvc3NlcyBlZGdlIG9mIHRoZSBzb3VyY2UgcHJvamVjdGlvbi5cbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMud3JhcHNYSW5Tb3VyY2VfID0gZmFsc2U7XG5cbiAgICAvKipcbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMuY2FuV3JhcFhJblNvdXJjZV8gPVxuICAgICAgdGhpcy5zb3VyY2VQcm9qXy5jYW5XcmFwWCgpICYmXG4gICAgICAhIW1heFNvdXJjZUV4dGVudCAmJlxuICAgICAgISF0aGlzLnNvdXJjZVByb2pfLmdldEV4dGVudCgpICYmXG4gICAgICBnZXRXaWR0aChtYXhTb3VyY2VFeHRlbnQpID09IGdldFdpZHRoKHRoaXMuc291cmNlUHJval8uZ2V0RXh0ZW50KCkpO1xuXG4gICAgLyoqXG4gICAgICogQHR5cGUgez9udW1iZXJ9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLnNvdXJjZVdvcmxkV2lkdGhfID0gdGhpcy5zb3VyY2VQcm9qXy5nZXRFeHRlbnQoKVxuICAgICAgPyBnZXRXaWR0aCh0aGlzLnNvdXJjZVByb2pfLmdldEV4dGVudCgpKVxuICAgICAgOiBudWxsO1xuXG4gICAgLyoqXG4gICAgICogQHR5cGUgez9udW1iZXJ9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLnRhcmdldFdvcmxkV2lkdGhfID0gdGhpcy50YXJnZXRQcm9qXy5nZXRFeHRlbnQoKVxuICAgICAgPyBnZXRXaWR0aCh0aGlzLnRhcmdldFByb2pfLmdldEV4dGVudCgpKVxuICAgICAgOiBudWxsO1xuXG4gICAgY29uc3QgZGVzdGluYXRpb25Ub3BMZWZ0ID0gZ2V0VG9wTGVmdCh0YXJnZXRFeHRlbnQpO1xuICAgIGNvbnN0IGRlc3RpbmF0aW9uVG9wUmlnaHQgPSBnZXRUb3BSaWdodCh0YXJnZXRFeHRlbnQpO1xuICAgIGNvbnN0IGRlc3RpbmF0aW9uQm90dG9tUmlnaHQgPSBnZXRCb3R0b21SaWdodCh0YXJnZXRFeHRlbnQpO1xuICAgIGNvbnN0IGRlc3RpbmF0aW9uQm90dG9tTGVmdCA9IGdldEJvdHRvbUxlZnQodGFyZ2V0RXh0ZW50KTtcbiAgICBjb25zdCBzb3VyY2VUb3BMZWZ0ID0gdGhpcy50cmFuc2Zvcm1JbnZfKGRlc3RpbmF0aW9uVG9wTGVmdCk7XG4gICAgY29uc3Qgc291cmNlVG9wUmlnaHQgPSB0aGlzLnRyYW5zZm9ybUludl8oZGVzdGluYXRpb25Ub3BSaWdodCk7XG4gICAgY29uc3Qgc291cmNlQm90dG9tUmlnaHQgPSB0aGlzLnRyYW5zZm9ybUludl8oZGVzdGluYXRpb25Cb3R0b21SaWdodCk7XG4gICAgY29uc3Qgc291cmNlQm90dG9tTGVmdCA9IHRoaXMudHJhbnNmb3JtSW52XyhkZXN0aW5hdGlvbkJvdHRvbUxlZnQpO1xuXG4gICAgLypcbiAgICAgKiBUaGUgbWF4U3ViZGl2aXNpb24gY29udHJvbHMgaG93IG1hbnkgc3BsaXR0aW5ncyBvZiB0aGUgdGFyZ2V0IGFyZWEgY2FuXG4gICAgICogYmUgZG9uZS4gVGhlIGlkZWEgaGVyZSBpcyB0byBkbyBhIGxpbmVhciBtYXBwaW5nIG9mIHRoZSB0YXJnZXQgYXJlYXNcbiAgICAgKiBidXQgdGhlIGFjdHVhbCBvdmVyYWwgcmVwcm9qZWN0aW9uIChjYW4gYmUpIGV4dHJlbWVseSBub24tbGluZWFyLiBUaGVcbiAgICAgKiBkZWZhdWx0IHZhbHVlIG9mIE1BWF9TVUJESVZJU0lPTiB3YXMgY2hvc2VuIGJhc2VkIG9uIG1hcHBpbmcgYSAyNTZ4MjU2XG4gICAgICogdGlsZSBzaXplLiBIb3dldmVyIHRoaXMgZnVuY3Rpb24gaXMgYWxzbyBjYWxsZWQgdG8gcmVtYXAgY2FudmFzIHJlbmRlcmVkXG4gICAgICogbGF5ZXJzIHdoaWNoIGNhbiBiZSBtdWNoIGxhcmdlci4gVGhpcyBjYWxjdWxhdGlvbiBpbmNyZWFzZXMgdGhlIG1heFN1YmRpdmlzaW9uXG4gICAgICogdmFsdWUgYnkgdGhlIHJpZ2h0IGZhY3RvciBzbyB0aGF0IGVhY2ggMjU2eDI1NiBwaXhlbCBhcmVhIGhhc1xuICAgICAqIE1BWF9TVUJESVZJU0lPTiBkaXZpc2lvbnMuXG4gICAgICovXG4gICAgY29uc3QgbWF4U3ViZGl2aXNpb24gPVxuICAgICAgTUFYX1NVQkRJVklTSU9OICtcbiAgICAgIChkZXN0aW5hdGlvblJlc29sdXRpb25cbiAgICAgICAgPyBNYXRoLm1heChcbiAgICAgICAgICAgIDAsXG4gICAgICAgICAgICBNYXRoLmNlaWwoXG4gICAgICAgICAgICAgIE1hdGgubG9nMihcbiAgICAgICAgICAgICAgICBnZXRBcmVhKHRhcmdldEV4dGVudCkgL1xuICAgICAgICAgICAgICAgICAgKGRlc3RpbmF0aW9uUmVzb2x1dGlvbiAqIGRlc3RpbmF0aW9uUmVzb2x1dGlvbiAqIDI1NiAqIDI1NilcbiAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgKVxuICAgICAgICAgIClcbiAgICAgICAgOiAwKTtcblxuICAgIHRoaXMuYWRkUXVhZF8oXG4gICAgICBkZXN0aW5hdGlvblRvcExlZnQsXG4gICAgICBkZXN0aW5hdGlvblRvcFJpZ2h0LFxuICAgICAgZGVzdGluYXRpb25Cb3R0b21SaWdodCxcbiAgICAgIGRlc3RpbmF0aW9uQm90dG9tTGVmdCxcbiAgICAgIHNvdXJjZVRvcExlZnQsXG4gICAgICBzb3VyY2VUb3BSaWdodCxcbiAgICAgIHNvdXJjZUJvdHRvbVJpZ2h0LFxuICAgICAgc291cmNlQm90dG9tTGVmdCxcbiAgICAgIG1heFN1YmRpdmlzaW9uXG4gICAgKTtcblxuICAgIGlmICh0aGlzLndyYXBzWEluU291cmNlXykge1xuICAgICAgbGV0IGxlZnRCb3VuZCA9IEluZmluaXR5O1xuICAgICAgdGhpcy50cmlhbmdsZXNfLmZvckVhY2goZnVuY3Rpb24gKHRyaWFuZ2xlLCBpLCBhcnIpIHtcbiAgICAgICAgbGVmdEJvdW5kID0gTWF0aC5taW4oXG4gICAgICAgICAgbGVmdEJvdW5kLFxuICAgICAgICAgIHRyaWFuZ2xlLnNvdXJjZVswXVswXSxcbiAgICAgICAgICB0cmlhbmdsZS5zb3VyY2VbMV1bMF0sXG4gICAgICAgICAgdHJpYW5nbGUuc291cmNlWzJdWzBdXG4gICAgICAgICk7XG4gICAgICB9KTtcblxuICAgICAgLy8gU2hpZnQgdHJpYW5nbGVzIHRvIGJlIGFzIGNsb3NlIHRvIGBsZWZ0Qm91bmRgIGFzIHBvc3NpYmxlXG4gICAgICAvLyAoaWYgdGhlIGRpc3RhbmNlIGlzIG1vcmUgdGhhbiBgd29ybGRXaWR0aCAvIDJgIGl0IGNhbiBiZSBjbG9zZXIuXG4gICAgICB0aGlzLnRyaWFuZ2xlc18uZm9yRWFjaCgodHJpYW5nbGUpID0+IHtcbiAgICAgICAgaWYgKFxuICAgICAgICAgIE1hdGgubWF4KFxuICAgICAgICAgICAgdHJpYW5nbGUuc291cmNlWzBdWzBdLFxuICAgICAgICAgICAgdHJpYW5nbGUuc291cmNlWzFdWzBdLFxuICAgICAgICAgICAgdHJpYW5nbGUuc291cmNlWzJdWzBdXG4gICAgICAgICAgKSAtXG4gICAgICAgICAgICBsZWZ0Qm91bmQgPlxuICAgICAgICAgIHRoaXMuc291cmNlV29ybGRXaWR0aF8gLyAyXG4gICAgICAgICkge1xuICAgICAgICAgIGNvbnN0IG5ld1RyaWFuZ2xlID0gW1xuICAgICAgICAgICAgW3RyaWFuZ2xlLnNvdXJjZVswXVswXSwgdHJpYW5nbGUuc291cmNlWzBdWzFdXSxcbiAgICAgICAgICAgIFt0cmlhbmdsZS5zb3VyY2VbMV1bMF0sIHRyaWFuZ2xlLnNvdXJjZVsxXVsxXV0sXG4gICAgICAgICAgICBbdHJpYW5nbGUuc291cmNlWzJdWzBdLCB0cmlhbmdsZS5zb3VyY2VbMl1bMV1dLFxuICAgICAgICAgIF07XG4gICAgICAgICAgaWYgKG5ld1RyaWFuZ2xlWzBdWzBdIC0gbGVmdEJvdW5kID4gdGhpcy5zb3VyY2VXb3JsZFdpZHRoXyAvIDIpIHtcbiAgICAgICAgICAgIG5ld1RyaWFuZ2xlWzBdWzBdIC09IHRoaXMuc291cmNlV29ybGRXaWR0aF87XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChuZXdUcmlhbmdsZVsxXVswXSAtIGxlZnRCb3VuZCA+IHRoaXMuc291cmNlV29ybGRXaWR0aF8gLyAyKSB7XG4gICAgICAgICAgICBuZXdUcmlhbmdsZVsxXVswXSAtPSB0aGlzLnNvdXJjZVdvcmxkV2lkdGhfO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAobmV3VHJpYW5nbGVbMl1bMF0gLSBsZWZ0Qm91bmQgPiB0aGlzLnNvdXJjZVdvcmxkV2lkdGhfIC8gMikge1xuICAgICAgICAgICAgbmV3VHJpYW5nbGVbMl1bMF0gLT0gdGhpcy5zb3VyY2VXb3JsZFdpZHRoXztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBSYXJlbHkgKGlmIHRoZSBleHRlbnQgY29udGFpbnMgYm90aCB0aGUgZGF0ZWxpbmUgYW5kIHByaW1lIG1lcmlkaWFuKVxuICAgICAgICAgIC8vIHRoZSBzaGlmdCBjYW4gaW4gdHVybiBicmVhayBzb21lIHRyaWFuZ2xlcy5cbiAgICAgICAgICAvLyBEZXRlY3QgdGhpcyBoZXJlIGFuZCBkb24ndCBzaGlmdCBpbiBzdWNoIGNhc2VzLlxuICAgICAgICAgIGNvbnN0IG1pblggPSBNYXRoLm1pbihcbiAgICAgICAgICAgIG5ld1RyaWFuZ2xlWzBdWzBdLFxuICAgICAgICAgICAgbmV3VHJpYW5nbGVbMV1bMF0sXG4gICAgICAgICAgICBuZXdUcmlhbmdsZVsyXVswXVxuICAgICAgICAgICk7XG4gICAgICAgICAgY29uc3QgbWF4WCA9IE1hdGgubWF4KFxuICAgICAgICAgICAgbmV3VHJpYW5nbGVbMF1bMF0sXG4gICAgICAgICAgICBuZXdUcmlhbmdsZVsxXVswXSxcbiAgICAgICAgICAgIG5ld1RyaWFuZ2xlWzJdWzBdXG4gICAgICAgICAgKTtcbiAgICAgICAgICBpZiAobWF4WCAtIG1pblggPCB0aGlzLnNvdXJjZVdvcmxkV2lkdGhfIC8gMikge1xuICAgICAgICAgICAgdHJpYW5nbGUuc291cmNlID0gbmV3VHJpYW5nbGU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICB0cmFuc2Zvcm1JbnZDYWNoZSA9IHt9O1xuICB9XG5cbiAgLyoqXG4gICAqIEFkZHMgdHJpYW5nbGUgdG8gdGhlIHRyaWFuZ3VsYXRpb24uXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vY29vcmRpbmF0ZS5qc1wiKS5Db29yZGluYXRlfSBhIFRoZSB0YXJnZXQgYSBjb29yZGluYXRlLlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL2Nvb3JkaW5hdGUuanNcIikuQ29vcmRpbmF0ZX0gYiBUaGUgdGFyZ2V0IGIgY29vcmRpbmF0ZS5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9jb29yZGluYXRlLmpzXCIpLkNvb3JkaW5hdGV9IGMgVGhlIHRhcmdldCBjIGNvb3JkaW5hdGUuXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vY29vcmRpbmF0ZS5qc1wiKS5Db29yZGluYXRlfSBhU3JjIFRoZSBzb3VyY2UgYSBjb29yZGluYXRlLlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL2Nvb3JkaW5hdGUuanNcIikuQ29vcmRpbmF0ZX0gYlNyYyBUaGUgc291cmNlIGIgY29vcmRpbmF0ZS5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9jb29yZGluYXRlLmpzXCIpLkNvb3JkaW5hdGV9IGNTcmMgVGhlIHNvdXJjZSBjIGNvb3JkaW5hdGUuXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBhZGRUcmlhbmdsZV8oYSwgYiwgYywgYVNyYywgYlNyYywgY1NyYykge1xuICAgIHRoaXMudHJpYW5nbGVzXy5wdXNoKHtcbiAgICAgIHNvdXJjZTogW2FTcmMsIGJTcmMsIGNTcmNdLFxuICAgICAgdGFyZ2V0OiBbYSwgYiwgY10sXG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogQWRkcyBxdWFkIChwb2ludHMgaW4gY2xvY2std2lzZSBvcmRlcikgdG8gdGhlIHRyaWFuZ3VsYXRpb25cbiAgICogKGFuZCByZXByb2plY3RzIHRoZSB2ZXJ0aWNlcykgaWYgdmFsaWQuXG4gICAqIFBlcmZvcm1zIHF1YWQgc3ViZGl2aXNpb24gaWYgbmVlZGVkIHRvIGluY3JlYXNlIHByZWNpc2lvbi5cbiAgICpcbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9jb29yZGluYXRlLmpzXCIpLkNvb3JkaW5hdGV9IGEgVGhlIHRhcmdldCBhIGNvb3JkaW5hdGUuXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vY29vcmRpbmF0ZS5qc1wiKS5Db29yZGluYXRlfSBiIFRoZSB0YXJnZXQgYiBjb29yZGluYXRlLlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL2Nvb3JkaW5hdGUuanNcIikuQ29vcmRpbmF0ZX0gYyBUaGUgdGFyZ2V0IGMgY29vcmRpbmF0ZS5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9jb29yZGluYXRlLmpzXCIpLkNvb3JkaW5hdGV9IGQgVGhlIHRhcmdldCBkIGNvb3JkaW5hdGUuXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vY29vcmRpbmF0ZS5qc1wiKS5Db29yZGluYXRlfSBhU3JjIFRoZSBzb3VyY2UgYSBjb29yZGluYXRlLlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL2Nvb3JkaW5hdGUuanNcIikuQ29vcmRpbmF0ZX0gYlNyYyBUaGUgc291cmNlIGIgY29vcmRpbmF0ZS5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9jb29yZGluYXRlLmpzXCIpLkNvb3JkaW5hdGV9IGNTcmMgVGhlIHNvdXJjZSBjIGNvb3JkaW5hdGUuXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vY29vcmRpbmF0ZS5qc1wiKS5Db29yZGluYXRlfSBkU3JjIFRoZSBzb3VyY2UgZCBjb29yZGluYXRlLlxuICAgKiBAcGFyYW0ge251bWJlcn0gbWF4U3ViZGl2aXNpb24gTWF4aW1hbCBhbGxvd2VkIHN1YmRpdmlzaW9uIG9mIHRoZSBxdWFkLlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgYWRkUXVhZF8oYSwgYiwgYywgZCwgYVNyYywgYlNyYywgY1NyYywgZFNyYywgbWF4U3ViZGl2aXNpb24pIHtcbiAgICBjb25zdCBzb3VyY2VRdWFkRXh0ZW50ID0gYm91bmRpbmdFeHRlbnQoW2FTcmMsIGJTcmMsIGNTcmMsIGRTcmNdKTtcbiAgICBjb25zdCBzb3VyY2VDb3ZlcmFnZVggPSB0aGlzLnNvdXJjZVdvcmxkV2lkdGhfXG4gICAgICA/IGdldFdpZHRoKHNvdXJjZVF1YWRFeHRlbnQpIC8gdGhpcy5zb3VyY2VXb3JsZFdpZHRoX1xuICAgICAgOiBudWxsO1xuICAgIGNvbnN0IHNvdXJjZVdvcmxkV2lkdGggPSAvKiogQHR5cGUge251bWJlcn0gKi8gKHRoaXMuc291cmNlV29ybGRXaWR0aF8pO1xuXG4gICAgLy8gd2hlbiB0aGUgcXVhZCBpcyB3cmFwcGVkIGluIHRoZSBzb3VyY2UgcHJvamVjdGlvblxuICAgIC8vIGl0IGNvdmVycyBtb3N0IG9mIHRoZSBwcm9qZWN0aW9uIGV4dGVudCwgYnV0IG5vdCBmdWxseVxuICAgIGNvbnN0IHdyYXBzWCA9XG4gICAgICB0aGlzLnNvdXJjZVByb2pfLmNhbldyYXBYKCkgJiZcbiAgICAgIHNvdXJjZUNvdmVyYWdlWCA+IDAuNSAmJlxuICAgICAgc291cmNlQ292ZXJhZ2VYIDwgMTtcblxuICAgIGxldCBuZWVkc1N1YmRpdmlzaW9uID0gZmFsc2U7XG5cbiAgICBpZiAobWF4U3ViZGl2aXNpb24gPiAwKSB7XG4gICAgICBpZiAodGhpcy50YXJnZXRQcm9qXy5pc0dsb2JhbCgpICYmIHRoaXMudGFyZ2V0V29ybGRXaWR0aF8pIHtcbiAgICAgICAgY29uc3QgdGFyZ2V0UXVhZEV4dGVudCA9IGJvdW5kaW5nRXh0ZW50KFthLCBiLCBjLCBkXSk7XG4gICAgICAgIGNvbnN0IHRhcmdldENvdmVyYWdlWCA9XG4gICAgICAgICAgZ2V0V2lkdGgodGFyZ2V0UXVhZEV4dGVudCkgLyB0aGlzLnRhcmdldFdvcmxkV2lkdGhfO1xuICAgICAgICBuZWVkc1N1YmRpdmlzaW9uID1cbiAgICAgICAgICB0YXJnZXRDb3ZlcmFnZVggPiBNQVhfVFJJQU5HTEVfV0lEVEggfHwgbmVlZHNTdWJkaXZpc2lvbjtcbiAgICAgIH1cbiAgICAgIGlmICghd3JhcHNYICYmIHRoaXMuc291cmNlUHJval8uaXNHbG9iYWwoKSAmJiBzb3VyY2VDb3ZlcmFnZVgpIHtcbiAgICAgICAgbmVlZHNTdWJkaXZpc2lvbiA9XG4gICAgICAgICAgc291cmNlQ292ZXJhZ2VYID4gTUFYX1RSSUFOR0xFX1dJRFRIIHx8IG5lZWRzU3ViZGl2aXNpb247XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKCFuZWVkc1N1YmRpdmlzaW9uICYmIHRoaXMubWF4U291cmNlRXh0ZW50Xykge1xuICAgICAgaWYgKFxuICAgICAgICBpc0Zpbml0ZShzb3VyY2VRdWFkRXh0ZW50WzBdKSAmJlxuICAgICAgICBpc0Zpbml0ZShzb3VyY2VRdWFkRXh0ZW50WzFdKSAmJlxuICAgICAgICBpc0Zpbml0ZShzb3VyY2VRdWFkRXh0ZW50WzJdKSAmJlxuICAgICAgICBpc0Zpbml0ZShzb3VyY2VRdWFkRXh0ZW50WzNdKVxuICAgICAgKSB7XG4gICAgICAgIGlmICghaW50ZXJzZWN0cyhzb3VyY2VRdWFkRXh0ZW50LCB0aGlzLm1heFNvdXJjZUV4dGVudF8pKSB7XG4gICAgICAgICAgLy8gd2hvbGUgcXVhZCBvdXRzaWRlIHNvdXJjZSBwcm9qZWN0aW9uIGV4dGVudCAtPiBpZ25vcmVcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBsZXQgaXNOb3RGaW5pdGUgPSAwO1xuXG4gICAgaWYgKCFuZWVkc1N1YmRpdmlzaW9uKSB7XG4gICAgICBpZiAoXG4gICAgICAgICFpc0Zpbml0ZShhU3JjWzBdKSB8fFxuICAgICAgICAhaXNGaW5pdGUoYVNyY1sxXSkgfHxcbiAgICAgICAgIWlzRmluaXRlKGJTcmNbMF0pIHx8XG4gICAgICAgICFpc0Zpbml0ZShiU3JjWzFdKSB8fFxuICAgICAgICAhaXNGaW5pdGUoY1NyY1swXSkgfHxcbiAgICAgICAgIWlzRmluaXRlKGNTcmNbMV0pIHx8XG4gICAgICAgICFpc0Zpbml0ZShkU3JjWzBdKSB8fFxuICAgICAgICAhaXNGaW5pdGUoZFNyY1sxXSlcbiAgICAgICkge1xuICAgICAgICBpZiAobWF4U3ViZGl2aXNpb24gPiAwKSB7XG4gICAgICAgICAgbmVlZHNTdWJkaXZpc2lvbiA9IHRydWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gSXQgbWlnaHQgYmUgdGhlIGNhc2UgdGhhdCBvbmx5IDEgb2YgdGhlIHBvaW50cyBpcyBpbmZpbml0ZS4gSW4gdGhpcyBjYXNlXG4gICAgICAgICAgLy8gd2UgY2FuIGRyYXcgYSBzaW5nbGUgdHJpYW5nbGUgd2l0aCB0aGUgb3RoZXIgdGhyZWUgcG9pbnRzXG4gICAgICAgICAgaXNOb3RGaW5pdGUgPVxuICAgICAgICAgICAgKCFpc0Zpbml0ZShhU3JjWzBdKSB8fCAhaXNGaW5pdGUoYVNyY1sxXSkgPyA4IDogMCkgK1xuICAgICAgICAgICAgKCFpc0Zpbml0ZShiU3JjWzBdKSB8fCAhaXNGaW5pdGUoYlNyY1sxXSkgPyA0IDogMCkgK1xuICAgICAgICAgICAgKCFpc0Zpbml0ZShjU3JjWzBdKSB8fCAhaXNGaW5pdGUoY1NyY1sxXSkgPyAyIDogMCkgK1xuICAgICAgICAgICAgKCFpc0Zpbml0ZShkU3JjWzBdKSB8fCAhaXNGaW5pdGUoZFNyY1sxXSkgPyAxIDogMCk7XG4gICAgICAgICAgaWYgKFxuICAgICAgICAgICAgaXNOb3RGaW5pdGUgIT0gMSAmJlxuICAgICAgICAgICAgaXNOb3RGaW5pdGUgIT0gMiAmJlxuICAgICAgICAgICAgaXNOb3RGaW5pdGUgIT0gNCAmJlxuICAgICAgICAgICAgaXNOb3RGaW5pdGUgIT0gOFxuICAgICAgICAgICkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChtYXhTdWJkaXZpc2lvbiA+IDApIHtcbiAgICAgIGlmICghbmVlZHNTdWJkaXZpc2lvbikge1xuICAgICAgICBjb25zdCBjZW50ZXIgPSBbKGFbMF0gKyBjWzBdKSAvIDIsIChhWzFdICsgY1sxXSkgLyAyXTtcbiAgICAgICAgY29uc3QgY2VudGVyU3JjID0gdGhpcy50cmFuc2Zvcm1JbnZfKGNlbnRlcik7XG5cbiAgICAgICAgbGV0IGR4O1xuICAgICAgICBpZiAod3JhcHNYKSB7XG4gICAgICAgICAgY29uc3QgY2VudGVyU3JjRXN0aW1YID1cbiAgICAgICAgICAgIChtb2R1bG8oYVNyY1swXSwgc291cmNlV29ybGRXaWR0aCkgK1xuICAgICAgICAgICAgICBtb2R1bG8oY1NyY1swXSwgc291cmNlV29ybGRXaWR0aCkpIC9cbiAgICAgICAgICAgIDI7XG4gICAgICAgICAgZHggPSBjZW50ZXJTcmNFc3RpbVggLSBtb2R1bG8oY2VudGVyU3JjWzBdLCBzb3VyY2VXb3JsZFdpZHRoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBkeCA9IChhU3JjWzBdICsgY1NyY1swXSkgLyAyIC0gY2VudGVyU3JjWzBdO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGR5ID0gKGFTcmNbMV0gKyBjU3JjWzFdKSAvIDIgLSBjZW50ZXJTcmNbMV07XG4gICAgICAgIGNvbnN0IGNlbnRlclNyY0Vycm9yU3F1YXJlZCA9IGR4ICogZHggKyBkeSAqIGR5O1xuICAgICAgICBuZWVkc1N1YmRpdmlzaW9uID0gY2VudGVyU3JjRXJyb3JTcXVhcmVkID4gdGhpcy5lcnJvclRocmVzaG9sZFNxdWFyZWRfO1xuICAgICAgfVxuICAgICAgaWYgKG5lZWRzU3ViZGl2aXNpb24pIHtcbiAgICAgICAgaWYgKE1hdGguYWJzKGFbMF0gLSBjWzBdKSA8PSBNYXRoLmFicyhhWzFdIC0gY1sxXSkpIHtcbiAgICAgICAgICAvLyBzcGxpdCBob3Jpem9udGFsbHkgKHRvcCAmIGJvdHRvbSlcbiAgICAgICAgICBjb25zdCBiYyA9IFsoYlswXSArIGNbMF0pIC8gMiwgKGJbMV0gKyBjWzFdKSAvIDJdO1xuICAgICAgICAgIGNvbnN0IGJjU3JjID0gdGhpcy50cmFuc2Zvcm1JbnZfKGJjKTtcbiAgICAgICAgICBjb25zdCBkYSA9IFsoZFswXSArIGFbMF0pIC8gMiwgKGRbMV0gKyBhWzFdKSAvIDJdO1xuICAgICAgICAgIGNvbnN0IGRhU3JjID0gdGhpcy50cmFuc2Zvcm1JbnZfKGRhKTtcblxuICAgICAgICAgIHRoaXMuYWRkUXVhZF8oXG4gICAgICAgICAgICBhLFxuICAgICAgICAgICAgYixcbiAgICAgICAgICAgIGJjLFxuICAgICAgICAgICAgZGEsXG4gICAgICAgICAgICBhU3JjLFxuICAgICAgICAgICAgYlNyYyxcbiAgICAgICAgICAgIGJjU3JjLFxuICAgICAgICAgICAgZGFTcmMsXG4gICAgICAgICAgICBtYXhTdWJkaXZpc2lvbiAtIDFcbiAgICAgICAgICApO1xuICAgICAgICAgIHRoaXMuYWRkUXVhZF8oXG4gICAgICAgICAgICBkYSxcbiAgICAgICAgICAgIGJjLFxuICAgICAgICAgICAgYyxcbiAgICAgICAgICAgIGQsXG4gICAgICAgICAgICBkYVNyYyxcbiAgICAgICAgICAgIGJjU3JjLFxuICAgICAgICAgICAgY1NyYyxcbiAgICAgICAgICAgIGRTcmMsXG4gICAgICAgICAgICBtYXhTdWJkaXZpc2lvbiAtIDFcbiAgICAgICAgICApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIHNwbGl0IHZlcnRpY2FsbHkgKGxlZnQgJiByaWdodClcbiAgICAgICAgICBjb25zdCBhYiA9IFsoYVswXSArIGJbMF0pIC8gMiwgKGFbMV0gKyBiWzFdKSAvIDJdO1xuICAgICAgICAgIGNvbnN0IGFiU3JjID0gdGhpcy50cmFuc2Zvcm1JbnZfKGFiKTtcbiAgICAgICAgICBjb25zdCBjZCA9IFsoY1swXSArIGRbMF0pIC8gMiwgKGNbMV0gKyBkWzFdKSAvIDJdO1xuICAgICAgICAgIGNvbnN0IGNkU3JjID0gdGhpcy50cmFuc2Zvcm1JbnZfKGNkKTtcblxuICAgICAgICAgIHRoaXMuYWRkUXVhZF8oXG4gICAgICAgICAgICBhLFxuICAgICAgICAgICAgYWIsXG4gICAgICAgICAgICBjZCxcbiAgICAgICAgICAgIGQsXG4gICAgICAgICAgICBhU3JjLFxuICAgICAgICAgICAgYWJTcmMsXG4gICAgICAgICAgICBjZFNyYyxcbiAgICAgICAgICAgIGRTcmMsXG4gICAgICAgICAgICBtYXhTdWJkaXZpc2lvbiAtIDFcbiAgICAgICAgICApO1xuICAgICAgICAgIHRoaXMuYWRkUXVhZF8oXG4gICAgICAgICAgICBhYixcbiAgICAgICAgICAgIGIsXG4gICAgICAgICAgICBjLFxuICAgICAgICAgICAgY2QsXG4gICAgICAgICAgICBhYlNyYyxcbiAgICAgICAgICAgIGJTcmMsXG4gICAgICAgICAgICBjU3JjLFxuICAgICAgICAgICAgY2RTcmMsXG4gICAgICAgICAgICBtYXhTdWJkaXZpc2lvbiAtIDFcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAod3JhcHNYKSB7XG4gICAgICBpZiAoIXRoaXMuY2FuV3JhcFhJblNvdXJjZV8pIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdGhpcy53cmFwc1hJblNvdXJjZV8gPSB0cnVlO1xuICAgIH1cblxuICAgIC8vIEV4YWN0bHkgemVybyBvciBvbmUgb2YgKlNyYyBpcyBub3QgZmluaXRlXG4gICAgLy8gVGhlIHRyaWFuZ2xlcyBtdXN0IGhhdmUgdGhlIGRpYWdvbmFsIGxpbmUgYXMgdGhlIGZpcnN0IHNpZGVcbiAgICAvLyBUaGlzIGlzIHRvIGFsbG93IGVhc3kgY29kZSBpbiByZXByb2oucyB0byBtYWtlIGl0IHN0cmFpZ2h0IGZvciBicm9rZW5cbiAgICAvLyBicm93c2VycyB0aGF0IGNhbid0IGhhbmRsZSBkaWFnb25hbCBjbGlwcGluZ1xuICAgIGlmICgoaXNOb3RGaW5pdGUgJiAweGIpID09IDApIHtcbiAgICAgIHRoaXMuYWRkVHJpYW5nbGVfKGEsIGMsIGQsIGFTcmMsIGNTcmMsIGRTcmMpO1xuICAgIH1cbiAgICBpZiAoKGlzTm90RmluaXRlICYgMHhlKSA9PSAwKSB7XG4gICAgICB0aGlzLmFkZFRyaWFuZ2xlXyhhLCBjLCBiLCBhU3JjLCBjU3JjLCBiU3JjKTtcbiAgICB9XG4gICAgaWYgKGlzTm90RmluaXRlKSB7XG4gICAgICAvLyBUcnkgdGhlIG90aGVyIHR3byB0cmlhbmdsZXNcbiAgICAgIGlmICgoaXNOb3RGaW5pdGUgJiAweGQpID09IDApIHtcbiAgICAgICAgdGhpcy5hZGRUcmlhbmdsZV8oYiwgZCwgYSwgYlNyYywgZFNyYywgYVNyYyk7XG4gICAgICB9XG4gICAgICBpZiAoKGlzTm90RmluaXRlICYgMHg3KSA9PSAwKSB7XG4gICAgICAgIHRoaXMuYWRkVHJpYW5nbGVfKGIsIGQsIGMsIGJTcmMsIGRTcmMsIGNTcmMpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBDYWxjdWxhdGVzIGV4dGVudCBvZiB0aGUgYHNvdXJjZWAgY29vcmRpbmF0ZXMgZnJvbSBhbGwgdGhlIHRyaWFuZ2xlcy5cbiAgICpcbiAgICogQHJldHVybiB7aW1wb3J0KFwiLi4vZXh0ZW50LmpzXCIpLkV4dGVudH0gQ2FsY3VsYXRlZCBleHRlbnQuXG4gICAqL1xuICBjYWxjdWxhdGVTb3VyY2VFeHRlbnQoKSB7XG4gICAgY29uc3QgZXh0ZW50ID0gY3JlYXRlRW1wdHkoKTtcblxuICAgIHRoaXMudHJpYW5nbGVzXy5mb3JFYWNoKGZ1bmN0aW9uICh0cmlhbmdsZSwgaSwgYXJyKSB7XG4gICAgICBjb25zdCBzcmMgPSB0cmlhbmdsZS5zb3VyY2U7XG4gICAgICBleHRlbmRDb29yZGluYXRlKGV4dGVudCwgc3JjWzBdKTtcbiAgICAgIGV4dGVuZENvb3JkaW5hdGUoZXh0ZW50LCBzcmNbMV0pO1xuICAgICAgZXh0ZW5kQ29vcmRpbmF0ZShleHRlbnQsIHNyY1syXSk7XG4gICAgfSk7XG5cbiAgICByZXR1cm4gZXh0ZW50O1xuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge0FycmF5PFRyaWFuZ2xlPn0gQXJyYXkgb2YgdGhlIGNhbGN1bGF0ZWQgdHJpYW5nbGVzLlxuICAgKi9cbiAgZ2V0VHJpYW5nbGVzKCkge1xuICAgIHJldHVybiB0aGlzLnRyaWFuZ2xlc187XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgVHJpYW5ndWxhdGlvbjtcbiIsIi8qKlxuICogQG1vZHVsZSBvbC9yZXByb2pcbiAqL1xuaW1wb3J0IHtcbiAgY29udGFpbnNDb29yZGluYXRlLFxuICBjcmVhdGVFbXB0eSxcbiAgZXh0ZW5kLFxuICBmb3JFYWNoQ29ybmVyLFxuICBnZXRDZW50ZXIsXG4gIGdldEhlaWdodCxcbiAgZ2V0VG9wTGVmdCxcbiAgZ2V0V2lkdGgsXG59IGZyb20gJy4vZXh0ZW50LmpzJztcbmltcG9ydCB7Y3JlYXRlQ2FudmFzQ29udGV4dDJELCByZWxlYXNlQ2FudmFzfSBmcm9tICcuL2RvbS5qcyc7XG5pbXBvcnQge2dldFBvaW50UmVzb2x1dGlvbiwgdHJhbnNmb3JtfSBmcm9tICcuL3Byb2ouanMnO1xuaW1wb3J0IHtzb2x2ZUxpbmVhclN5c3RlbX0gZnJvbSAnLi9tYXRoLmpzJztcblxubGV0IGJyb2tlbkRpYWdvbmFsUmVuZGVyaW5nXztcblxuLyoqXG4gKiBAdHlwZSB7QXJyYXk8SFRNTENhbnZhc0VsZW1lbnQ+fVxuICovXG5leHBvcnQgY29uc3QgY2FudmFzUG9vbCA9IFtdO1xuXG4vKipcbiAqIFRoaXMgZHJhd3MgYSBzbWFsbCB0cmlhbmdsZSBpbnRvIGEgY2FudmFzIGJ5IHNldHRpbmcgdGhlIHRyaWFuZ2xlIGFzIHRoZSBjbGlwIHJlZ2lvblxuICogYW5kIHRoZW4gZHJhd2luZyBhICh0b28gbGFyZ2UpIHJlY3RhbmdsZVxuICpcbiAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHggVGhlIGNvbnRleHQgaW4gd2hpY2ggdG8gZHJhdyB0aGUgdHJpYW5nbGVcbiAqIEBwYXJhbSB7bnVtYmVyfSB1MSBUaGUgeC1jb29yZGluYXRlIG9mIHRoZSBzZWNvbmQgcG9pbnQuIFRoZSBmaXJzdCBwb2ludCBpcyAwLDAuXG4gKiBAcGFyYW0ge251bWJlcn0gdjEgVGhlIHktY29vcmRpbmF0ZSBvZiB0aGUgc2Vjb25kIHBvaW50LlxuICogQHBhcmFtIHtudW1iZXJ9IHUyIFRoZSB4LWNvb3JkaW5hdGUgb2YgdGhlIHRoaXJkIHBvaW50LlxuICogQHBhcmFtIHtudW1iZXJ9IHYyIFRoZSB5LWNvb3JkaW5hdGUgb2YgdGhlIHRoaXJkIHBvaW50LlxuICovXG5mdW5jdGlvbiBkcmF3VGVzdFRyaWFuZ2xlKGN0eCwgdTEsIHYxLCB1MiwgdjIpIHtcbiAgY3R4LmJlZ2luUGF0aCgpO1xuICBjdHgubW92ZVRvKDAsIDApO1xuICBjdHgubGluZVRvKHUxLCB2MSk7XG4gIGN0eC5saW5lVG8odTIsIHYyKTtcbiAgY3R4LmNsb3NlUGF0aCgpO1xuICBjdHguc2F2ZSgpO1xuICBjdHguY2xpcCgpO1xuICBjdHguZmlsbFJlY3QoMCwgMCwgTWF0aC5tYXgodTEsIHUyKSArIDEsIE1hdGgubWF4KHYxLCB2MikpO1xuICBjdHgucmVzdG9yZSgpO1xufVxuXG4vKipcbiAqIEdpdmVuIHRoZSBkYXRhIGZyb20gZ2V0SW1hZ2VEYXRhLCBzZWUgaWYgdGhlIHJpZ2h0IHZhbHVlcyBhcHBlYXIgYXQgdGhlIHByb3ZpZGVkIG9mZnNldC5cbiAqIFJldHVybnMgdHJ1ZSBpZiBlaXRoZXIgdGhlIGNvbG9yIG9yIHRyYW5zcGFyZW5jeSBpcyBvZmZcbiAqXG4gKiBAcGFyYW0ge1VpbnQ4Q2xhbXBlZEFycmF5fSBkYXRhIFRoZSBkYXRhIHJldHVybmVkIGZyb20gZ2V0SW1hZ2VEYXRhXG4gKiBAcGFyYW0ge251bWJlcn0gb2Zmc2V0IFRoZSBwaXhlbCBvZmZzZXQgZnJvbSB0aGUgc3RhcnQgb2YgZGF0YS5cbiAqIEByZXR1cm4ge2Jvb2xlYW59IHRydWUgaWYgdGhlIGRpYWdvbmFsIHJlbmRlcmluZyBpcyBicm9rZW5cbiAqL1xuZnVuY3Rpb24gdmVyaWZ5QnJva2VuRGlhZ29uYWxSZW5kZXJpbmcoZGF0YSwgb2Zmc2V0KSB7XG4gIC8vIHRoZSB2YWx1ZXMgb3VnaHQgdG8gYmUgY2xvc2UgdG8gdGhlIHJnYmEoMjEwLCAwLCAwLCAwLjc1KVxuICByZXR1cm4gKFxuICAgIE1hdGguYWJzKGRhdGFbb2Zmc2V0ICogNF0gLSAyMTApID4gMiB8fFxuICAgIE1hdGguYWJzKGRhdGFbb2Zmc2V0ICogNCArIDNdIC0gMC43NSAqIDI1NSkgPiAyXG4gICk7XG59XG5cbi8qKlxuICogRGV0ZXJtaW5lcyBpZiB0aGUgY3VycmVudCBicm93c2VyIGNvbmZpZ3VyYXRpb24gY2FuIHJlbmRlciB0cmlhbmd1bGFyIGNsaXAgcmVnaW9ucyBjb3JyZWN0bHkuXG4gKiBUaGlzIHZhbHVlIGlzIGNhY2hlZCBzbyB0aGUgZnVuY3Rpb24gaXMgb25seSBleHBlbnNpdmUgdGhlIGZpcnN0IHRpbWUgY2FsbGVkLlxuICogRmlyZWZveCBvbiBXaW5kb3dzIChhcyBvZiBub3cpIGRvZXMgbm90IGlmIEhXQSBpcyBlbmFibGVkLiBTZWUgaHR0cHM6Ly9idWd6aWxsYS5tb3ppbGxhLm9yZy9zaG93X2J1Zy5jZ2k/aWQ9MTYwNjk3NlxuICogQ2hyb21lIHdvcmtzLCBhbmQgZXZlcnl0aGluZyBzZWVtcyB0byB3b3JrIG9uIE9TWCBhbmQgQW5kcm9pZC4gVGhpcyBmdW5jdGlvbiBjYWNoZXMgdGhlXG4gKiByZXN1bHQuIEkgc3VwcG9zZSB0aGF0IGl0IGlzIGNvbmNlaXZhYmx5IHBvc3NpYmxlIHRoYXQgYSBicm93c2VyIG1pZ2h0IGZsaXAgbW9kZXMgd2hpbGUgdGhlIGFwcCBpc1xuICogcnVubmluZywgYnV0IGxldHMgaG9wZSBub3QuXG4gKlxuICogQHJldHVybiB7Ym9vbGVhbn0gdHJ1ZSBpZiB0aGUgRGlhZ29uYWwgUmVuZGVyaW5nIGlzIGJyb2tlbi5cbiAqL1xuZnVuY3Rpb24gaXNCcm9rZW5EaWFnb25hbFJlbmRlcmluZygpIHtcbiAgaWYgKGJyb2tlbkRpYWdvbmFsUmVuZGVyaW5nXyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgY29uc3QgY3R4ID0gY3JlYXRlQ2FudmFzQ29udGV4dDJEKDYsIDYsIGNhbnZhc1Bvb2wpO1xuICAgIGN0eC5nbG9iYWxDb21wb3NpdGVPcGVyYXRpb24gPSAnbGlnaHRlcic7XG4gICAgY3R4LmZpbGxTdHlsZSA9ICdyZ2JhKDIxMCwgMCwgMCwgMC43NSknO1xuICAgIGRyYXdUZXN0VHJpYW5nbGUoY3R4LCA0LCA1LCA0LCAwKTtcbiAgICBkcmF3VGVzdFRyaWFuZ2xlKGN0eCwgNCwgNSwgMCwgNSk7XG4gICAgY29uc3QgZGF0YSA9IGN0eC5nZXRJbWFnZURhdGEoMCwgMCwgMywgMykuZGF0YTtcbiAgICBicm9rZW5EaWFnb25hbFJlbmRlcmluZ18gPVxuICAgICAgdmVyaWZ5QnJva2VuRGlhZ29uYWxSZW5kZXJpbmcoZGF0YSwgMCkgfHxcbiAgICAgIHZlcmlmeUJyb2tlbkRpYWdvbmFsUmVuZGVyaW5nKGRhdGEsIDQpIHx8XG4gICAgICB2ZXJpZnlCcm9rZW5EaWFnb25hbFJlbmRlcmluZyhkYXRhLCA4KTtcbiAgICByZWxlYXNlQ2FudmFzKGN0eCk7XG4gICAgY2FudmFzUG9vbC5wdXNoKGN0eC5jYW52YXMpO1xuICB9XG5cbiAgcmV0dXJuIGJyb2tlbkRpYWdvbmFsUmVuZGVyaW5nXztcbn1cblxuLyoqXG4gKiBDYWxjdWxhdGVzIGlkZWFsIHJlc29sdXRpb24gdG8gdXNlIGZyb20gdGhlIHNvdXJjZSBpbiBvcmRlciB0byBhY2hpZXZlXG4gKiBwaXhlbCBtYXBwaW5nIGFzIGNsb3NlIGFzIHBvc3NpYmxlIHRvIDE6MSBkdXJpbmcgcmVwcm9qZWN0aW9uLlxuICogVGhlIHJlc29sdXRpb24gaXMgY2FsY3VsYXRlZCByZWdhcmRsZXNzIG9mIHdoYXQgcmVzb2x1dGlvbnNcbiAqIGFyZSBhY3R1YWxseSBhdmFpbGFibGUgaW4gdGhlIGRhdGFzZXQgKFRpbGVHcmlkLCBJbWFnZSwgLi4uKS5cbiAqXG4gKiBAcGFyYW0ge2ltcG9ydChcIi4vcHJvai9Qcm9qZWN0aW9uLmpzXCIpLmRlZmF1bHR9IHNvdXJjZVByb2ogU291cmNlIHByb2plY3Rpb24uXG4gKiBAcGFyYW0ge2ltcG9ydChcIi4vcHJvai9Qcm9qZWN0aW9uLmpzXCIpLmRlZmF1bHR9IHRhcmdldFByb2ogVGFyZ2V0IHByb2plY3Rpb24uXG4gKiBAcGFyYW0ge2ltcG9ydChcIi4vY29vcmRpbmF0ZS5qc1wiKS5Db29yZGluYXRlfSB0YXJnZXRDZW50ZXIgVGFyZ2V0IGNlbnRlci5cbiAqIEBwYXJhbSB7bnVtYmVyfSB0YXJnZXRSZXNvbHV0aW9uIFRhcmdldCByZXNvbHV0aW9uLlxuICogQHJldHVybiB7bnVtYmVyfSBUaGUgYmVzdCByZXNvbHV0aW9uIHRvIHVzZS4gQ2FuIGJlICstSW5maW5pdHksIE5hTiBvciAwLlxuICovXG5leHBvcnQgZnVuY3Rpb24gY2FsY3VsYXRlU291cmNlUmVzb2x1dGlvbihcbiAgc291cmNlUHJvaixcbiAgdGFyZ2V0UHJvaixcbiAgdGFyZ2V0Q2VudGVyLFxuICB0YXJnZXRSZXNvbHV0aW9uXG4pIHtcbiAgY29uc3Qgc291cmNlQ2VudGVyID0gdHJhbnNmb3JtKHRhcmdldENlbnRlciwgdGFyZ2V0UHJvaiwgc291cmNlUHJvaik7XG5cbiAgLy8gY2FsY3VsYXRlIHRoZSBpZGVhbCByZXNvbHV0aW9uIG9mIHRoZSBzb3VyY2UgZGF0YVxuICBsZXQgc291cmNlUmVzb2x1dGlvbiA9IGdldFBvaW50UmVzb2x1dGlvbihcbiAgICB0YXJnZXRQcm9qLFxuICAgIHRhcmdldFJlc29sdXRpb24sXG4gICAgdGFyZ2V0Q2VudGVyXG4gICk7XG5cbiAgY29uc3QgdGFyZ2V0TWV0ZXJzUGVyVW5pdCA9IHRhcmdldFByb2ouZ2V0TWV0ZXJzUGVyVW5pdCgpO1xuICBpZiAodGFyZ2V0TWV0ZXJzUGVyVW5pdCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgc291cmNlUmVzb2x1dGlvbiAqPSB0YXJnZXRNZXRlcnNQZXJVbml0O1xuICB9XG4gIGNvbnN0IHNvdXJjZU1ldGVyc1BlclVuaXQgPSBzb3VyY2VQcm9qLmdldE1ldGVyc1BlclVuaXQoKTtcbiAgaWYgKHNvdXJjZU1ldGVyc1BlclVuaXQgIT09IHVuZGVmaW5lZCkge1xuICAgIHNvdXJjZVJlc29sdXRpb24gLz0gc291cmNlTWV0ZXJzUGVyVW5pdDtcbiAgfVxuXG4gIC8vIEJhc2VkIG9uIHRoZSBwcm9qZWN0aW9uIHByb3BlcnRpZXMsIHRoZSBwb2ludCByZXNvbHV0aW9uIGF0IHRoZSBzcGVjaWZpZWRcbiAgLy8gY29vcmRpbmF0ZXMgbWF5IGJlIHNsaWdodGx5IGRpZmZlcmVudC4gV2UgbmVlZCB0byByZXZlcnNlLWNvbXBlbnNhdGUgdGhpc1xuICAvLyBpbiBvcmRlciB0byBhY2hpZXZlIG9wdGltYWwgcmVzdWx0cy5cblxuICBjb25zdCBzb3VyY2VFeHRlbnQgPSBzb3VyY2VQcm9qLmdldEV4dGVudCgpO1xuICBpZiAoIXNvdXJjZUV4dGVudCB8fCBjb250YWluc0Nvb3JkaW5hdGUoc291cmNlRXh0ZW50LCBzb3VyY2VDZW50ZXIpKSB7XG4gICAgY29uc3QgY29tcGVuc2F0aW9uRmFjdG9yID1cbiAgICAgIGdldFBvaW50UmVzb2x1dGlvbihzb3VyY2VQcm9qLCBzb3VyY2VSZXNvbHV0aW9uLCBzb3VyY2VDZW50ZXIpIC9cbiAgICAgIHNvdXJjZVJlc29sdXRpb247XG4gICAgaWYgKGlzRmluaXRlKGNvbXBlbnNhdGlvbkZhY3RvcikgJiYgY29tcGVuc2F0aW9uRmFjdG9yID4gMCkge1xuICAgICAgc291cmNlUmVzb2x1dGlvbiAvPSBjb21wZW5zYXRpb25GYWN0b3I7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHNvdXJjZVJlc29sdXRpb247XG59XG5cbi8qKlxuICogQ2FsY3VsYXRlcyBpZGVhbCByZXNvbHV0aW9uIHRvIHVzZSBmcm9tIHRoZSBzb3VyY2UgaW4gb3JkZXIgdG8gYWNoaWV2ZVxuICogcGl4ZWwgbWFwcGluZyBhcyBjbG9zZSBhcyBwb3NzaWJsZSB0byAxOjEgZHVyaW5nIHJlcHJvamVjdGlvbi5cbiAqIFRoZSByZXNvbHV0aW9uIGlzIGNhbGN1bGF0ZWQgcmVnYXJkbGVzcyBvZiB3aGF0IHJlc29sdXRpb25zXG4gKiBhcmUgYWN0dWFsbHkgYXZhaWxhYmxlIGluIHRoZSBkYXRhc2V0IChUaWxlR3JpZCwgSW1hZ2UsIC4uLikuXG4gKlxuICogQHBhcmFtIHtpbXBvcnQoXCIuL3Byb2ovUHJvamVjdGlvbi5qc1wiKS5kZWZhdWx0fSBzb3VyY2VQcm9qIFNvdXJjZSBwcm9qZWN0aW9uLlxuICogQHBhcmFtIHtpbXBvcnQoXCIuL3Byb2ovUHJvamVjdGlvbi5qc1wiKS5kZWZhdWx0fSB0YXJnZXRQcm9qIFRhcmdldCBwcm9qZWN0aW9uLlxuICogQHBhcmFtIHtpbXBvcnQoXCIuL2V4dGVudC5qc1wiKS5FeHRlbnR9IHRhcmdldEV4dGVudCBUYXJnZXQgZXh0ZW50XG4gKiBAcGFyYW0ge251bWJlcn0gdGFyZ2V0UmVzb2x1dGlvbiBUYXJnZXQgcmVzb2x1dGlvbi5cbiAqIEByZXR1cm4ge251bWJlcn0gVGhlIGJlc3QgcmVzb2x1dGlvbiB0byB1c2UuIENhbiBiZSArLUluZmluaXR5LCBOYU4gb3IgMC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNhbGN1bGF0ZVNvdXJjZUV4dGVudFJlc29sdXRpb24oXG4gIHNvdXJjZVByb2osXG4gIHRhcmdldFByb2osXG4gIHRhcmdldEV4dGVudCxcbiAgdGFyZ2V0UmVzb2x1dGlvblxuKSB7XG4gIGNvbnN0IHRhcmdldENlbnRlciA9IGdldENlbnRlcih0YXJnZXRFeHRlbnQpO1xuICBsZXQgc291cmNlUmVzb2x1dGlvbiA9IGNhbGN1bGF0ZVNvdXJjZVJlc29sdXRpb24oXG4gICAgc291cmNlUHJvaixcbiAgICB0YXJnZXRQcm9qLFxuICAgIHRhcmdldENlbnRlcixcbiAgICB0YXJnZXRSZXNvbHV0aW9uXG4gICk7XG5cbiAgaWYgKCFpc0Zpbml0ZShzb3VyY2VSZXNvbHV0aW9uKSB8fCBzb3VyY2VSZXNvbHV0aW9uIDw9IDApIHtcbiAgICBmb3JFYWNoQ29ybmVyKHRhcmdldEV4dGVudCwgZnVuY3Rpb24gKGNvcm5lcikge1xuICAgICAgc291cmNlUmVzb2x1dGlvbiA9IGNhbGN1bGF0ZVNvdXJjZVJlc29sdXRpb24oXG4gICAgICAgIHNvdXJjZVByb2osXG4gICAgICAgIHRhcmdldFByb2osXG4gICAgICAgIGNvcm5lcixcbiAgICAgICAgdGFyZ2V0UmVzb2x1dGlvblxuICAgICAgKTtcbiAgICAgIHJldHVybiBpc0Zpbml0ZShzb3VyY2VSZXNvbHV0aW9uKSAmJiBzb3VyY2VSZXNvbHV0aW9uID4gMDtcbiAgICB9KTtcbiAgfVxuXG4gIHJldHVybiBzb3VyY2VSZXNvbHV0aW9uO1xufVxuXG4vKipcbiAqIEB0eXBlZGVmIHtPYmplY3R9IEltYWdlRXh0ZW50XG4gKiBAcHJvcGVydHkge2ltcG9ydChcIi4vZXh0ZW50LmpzXCIpLkV4dGVudH0gZXh0ZW50IEV4dGVudC5cbiAqIEBwcm9wZXJ0eSB7SFRNTENhbnZhc0VsZW1lbnR8SFRNTEltYWdlRWxlbWVudHxIVE1MVmlkZW9FbGVtZW50fSBpbWFnZSBJbWFnZS5cbiAqL1xuXG4vKipcbiAqIFJlbmRlcnMgdGhlIHNvdXJjZSBkYXRhIGludG8gbmV3IGNhbnZhcyBiYXNlZCBvbiB0aGUgdHJpYW5ndWxhdGlvbi5cbiAqXG4gKiBAcGFyYW0ge251bWJlcn0gd2lkdGggV2lkdGggb2YgdGhlIGNhbnZhcy5cbiAqIEBwYXJhbSB7bnVtYmVyfSBoZWlnaHQgSGVpZ2h0IG9mIHRoZSBjYW52YXMuXG4gKiBAcGFyYW0ge251bWJlcn0gcGl4ZWxSYXRpbyBQaXhlbCByYXRpby5cbiAqIEBwYXJhbSB7bnVtYmVyfSBzb3VyY2VSZXNvbHV0aW9uIFNvdXJjZSByZXNvbHV0aW9uLlxuICogQHBhcmFtIHtpbXBvcnQoXCIuL2V4dGVudC5qc1wiKS5FeHRlbnR9IHNvdXJjZUV4dGVudCBFeHRlbnQgb2YgdGhlIGRhdGEgc291cmNlLlxuICogQHBhcmFtIHtudW1iZXJ9IHRhcmdldFJlc29sdXRpb24gVGFyZ2V0IHJlc29sdXRpb24uXG4gKiBAcGFyYW0ge2ltcG9ydChcIi4vZXh0ZW50LmpzXCIpLkV4dGVudH0gdGFyZ2V0RXh0ZW50IFRhcmdldCBleHRlbnQuXG4gKiBAcGFyYW0ge2ltcG9ydChcIi4vcmVwcm9qL1RyaWFuZ3VsYXRpb24uanNcIikuZGVmYXVsdH0gdHJpYW5ndWxhdGlvbiBDYWxjdWxhdGVkIHRyaWFuZ3VsYXRpb24uXG4gKiBAcGFyYW0ge0FycmF5PEltYWdlRXh0ZW50Pn0gc291cmNlcyBBcnJheSBvZiBzb3VyY2VzLlxuICogQHBhcmFtIHtudW1iZXJ9IGd1dHRlciBHdXR0ZXIgb2YgdGhlIHNvdXJjZXMuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtyZW5kZXJFZGdlc10gUmVuZGVyIHJlcHJvamVjdGlvbiBlZGdlcy5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW2ludGVycG9sYXRlXSBVc2UgbGluZWFyIGludGVycG9sYXRpb24gd2hlbiByZXNhbXBsaW5nLlxuICogQHJldHVybiB7SFRNTENhbnZhc0VsZW1lbnR9IENhbnZhcyB3aXRoIHJlcHJvamVjdGVkIGRhdGEuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiByZW5kZXIoXG4gIHdpZHRoLFxuICBoZWlnaHQsXG4gIHBpeGVsUmF0aW8sXG4gIHNvdXJjZVJlc29sdXRpb24sXG4gIHNvdXJjZUV4dGVudCxcbiAgdGFyZ2V0UmVzb2x1dGlvbixcbiAgdGFyZ2V0RXh0ZW50LFxuICB0cmlhbmd1bGF0aW9uLFxuICBzb3VyY2VzLFxuICBndXR0ZXIsXG4gIHJlbmRlckVkZ2VzLFxuICBpbnRlcnBvbGF0ZVxuKSB7XG4gIGNvbnN0IGNvbnRleHQgPSBjcmVhdGVDYW52YXNDb250ZXh0MkQoXG4gICAgTWF0aC5yb3VuZChwaXhlbFJhdGlvICogd2lkdGgpLFxuICAgIE1hdGgucm91bmQocGl4ZWxSYXRpbyAqIGhlaWdodCksXG4gICAgY2FudmFzUG9vbFxuICApO1xuXG4gIGlmICghaW50ZXJwb2xhdGUpIHtcbiAgICBjb250ZXh0LmltYWdlU21vb3RoaW5nRW5hYmxlZCA9IGZhbHNlO1xuICB9XG5cbiAgaWYgKHNvdXJjZXMubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIGNvbnRleHQuY2FudmFzO1xuICB9XG5cbiAgY29udGV4dC5zY2FsZShwaXhlbFJhdGlvLCBwaXhlbFJhdGlvKTtcblxuICBmdW5jdGlvbiBwaXhlbFJvdW5kKHZhbHVlKSB7XG4gICAgcmV0dXJuIE1hdGgucm91bmQodmFsdWUgKiBwaXhlbFJhdGlvKSAvIHBpeGVsUmF0aW87XG4gIH1cblxuICBjb250ZXh0Lmdsb2JhbENvbXBvc2l0ZU9wZXJhdGlvbiA9ICdsaWdodGVyJztcblxuICBjb25zdCBzb3VyY2VEYXRhRXh0ZW50ID0gY3JlYXRlRW1wdHkoKTtcbiAgc291cmNlcy5mb3JFYWNoKGZ1bmN0aW9uIChzcmMsIGksIGFycikge1xuICAgIGV4dGVuZChzb3VyY2VEYXRhRXh0ZW50LCBzcmMuZXh0ZW50KTtcbiAgfSk7XG5cbiAgY29uc3QgY2FudmFzV2lkdGhJblVuaXRzID0gZ2V0V2lkdGgoc291cmNlRGF0YUV4dGVudCk7XG4gIGNvbnN0IGNhbnZhc0hlaWdodEluVW5pdHMgPSBnZXRIZWlnaHQoc291cmNlRGF0YUV4dGVudCk7XG4gIGNvbnN0IHN0aXRjaENvbnRleHQgPSBjcmVhdGVDYW52YXNDb250ZXh0MkQoXG4gICAgTWF0aC5yb3VuZCgocGl4ZWxSYXRpbyAqIGNhbnZhc1dpZHRoSW5Vbml0cykgLyBzb3VyY2VSZXNvbHV0aW9uKSxcbiAgICBNYXRoLnJvdW5kKChwaXhlbFJhdGlvICogY2FudmFzSGVpZ2h0SW5Vbml0cykgLyBzb3VyY2VSZXNvbHV0aW9uKSxcbiAgICBjYW52YXNQb29sXG4gICk7XG5cbiAgaWYgKCFpbnRlcnBvbGF0ZSkge1xuICAgIHN0aXRjaENvbnRleHQuaW1hZ2VTbW9vdGhpbmdFbmFibGVkID0gZmFsc2U7XG4gIH1cblxuICBjb25zdCBzdGl0Y2hTY2FsZSA9IHBpeGVsUmF0aW8gLyBzb3VyY2VSZXNvbHV0aW9uO1xuXG4gIHNvdXJjZXMuZm9yRWFjaChmdW5jdGlvbiAoc3JjLCBpLCBhcnIpIHtcbiAgICBjb25zdCB4UG9zID0gc3JjLmV4dGVudFswXSAtIHNvdXJjZURhdGFFeHRlbnRbMF07XG4gICAgY29uc3QgeVBvcyA9IC0oc3JjLmV4dGVudFszXSAtIHNvdXJjZURhdGFFeHRlbnRbM10pO1xuICAgIGNvbnN0IHNyY1dpZHRoID0gZ2V0V2lkdGgoc3JjLmV4dGVudCk7XG4gICAgY29uc3Qgc3JjSGVpZ2h0ID0gZ2V0SGVpZ2h0KHNyYy5leHRlbnQpO1xuXG4gICAgLy8gVGhpcyB0ZXN0IHNob3VsZCBuZXZlciBmYWlsIC0tIGJ1dCBpdCBkb2VzLiBOZWVkIHRvIGZpbmQgYSBmaXggdGhlIHVwc3RyZWFtIGNvbmRpdGlvblxuICAgIGlmIChzcmMuaW1hZ2Uud2lkdGggPiAwICYmIHNyYy5pbWFnZS5oZWlnaHQgPiAwKSB7XG4gICAgICBzdGl0Y2hDb250ZXh0LmRyYXdJbWFnZShcbiAgICAgICAgc3JjLmltYWdlLFxuICAgICAgICBndXR0ZXIsXG4gICAgICAgIGd1dHRlcixcbiAgICAgICAgc3JjLmltYWdlLndpZHRoIC0gMiAqIGd1dHRlcixcbiAgICAgICAgc3JjLmltYWdlLmhlaWdodCAtIDIgKiBndXR0ZXIsXG4gICAgICAgIHhQb3MgKiBzdGl0Y2hTY2FsZSxcbiAgICAgICAgeVBvcyAqIHN0aXRjaFNjYWxlLFxuICAgICAgICBzcmNXaWR0aCAqIHN0aXRjaFNjYWxlLFxuICAgICAgICBzcmNIZWlnaHQgKiBzdGl0Y2hTY2FsZVxuICAgICAgKTtcbiAgICB9XG4gIH0pO1xuXG4gIGNvbnN0IHRhcmdldFRvcExlZnQgPSBnZXRUb3BMZWZ0KHRhcmdldEV4dGVudCk7XG5cbiAgdHJpYW5ndWxhdGlvbi5nZXRUcmlhbmdsZXMoKS5mb3JFYWNoKGZ1bmN0aW9uICh0cmlhbmdsZSwgaSwgYXJyKSB7XG4gICAgLyogQ2FsY3VsYXRlIGFmZmluZSB0cmFuc2Zvcm0gKHNyYyAtPiBkc3QpXG4gICAgICogUmVzdWx0aW5nIG1hdHJpeCBjYW4gYmUgdXNlZCB0byB0cmFuc2Zvcm0gY29vcmRpbmF0ZVxuICAgICAqIGZyb20gYHNvdXJjZVByb2plY3Rpb25gIHRvIGRlc3RpbmF0aW9uIHBpeGVscy5cbiAgICAgKlxuICAgICAqIFRvIG9wdGltaXplIG51bWJlciBvZiBjb250ZXh0IGNhbGxzIGFuZCBpbmNyZWFzZSBudW1lcmljYWwgc3RhYmlsaXR5LFxuICAgICAqIHdlIGFsc28gZG8gdGhlIGZvbGxvd2luZyBvcGVyYXRpb25zOlxuICAgICAqIHRyYW5zKC10b3BMZWZ0RXh0ZW50Q29ybmVyKSwgc2NhbGUoMSAvIHRhcmdldFJlc29sdXRpb24pLCBzY2FsZSgxLCAtMSlcbiAgICAgKiBoZXJlIGJlZm9yZSBzb2x2aW5nIHRoZSBsaW5lYXIgc3lzdGVtIHNvIFt1aSwgdmldIGFyZSBwaXhlbCBjb29yZGluYXRlcy5cbiAgICAgKlxuICAgICAqIFNyYyBwb2ludHM6IHhpLCB5aVxuICAgICAqIERzdCBwb2ludHM6IHVpLCB2aVxuICAgICAqIEFmZmluZSBjb2VmZmljaWVudHM6IGFpalxuICAgICAqXG4gICAgICogfCB4MCB5MCAxICAwICAwIDAgfCAgIHxhMDB8ICAgfHUwfFxuICAgICAqIHwgeDEgeTEgMSAgMCAgMCAwIHwgICB8YTAxfCAgIHx1MXxcbiAgICAgKiB8IHgyIHkyIDEgIDAgIDAgMCB8IHggfGEwMnwgPSB8dTJ8XG4gICAgICogfCAgMCAgMCAwIHgwIHkwIDEgfCAgIHxhMTB8ICAgfHYwfFxuICAgICAqIHwgIDAgIDAgMCB4MSB5MSAxIHwgICB8YTExfCAgIHx2MXxcbiAgICAgKiB8ICAwICAwIDAgeDIgeTIgMSB8ICAgfGExMnwgICB8djJ8XG4gICAgICovXG4gICAgY29uc3Qgc291cmNlID0gdHJpYW5nbGUuc291cmNlO1xuICAgIGNvbnN0IHRhcmdldCA9IHRyaWFuZ2xlLnRhcmdldDtcbiAgICBsZXQgeDAgPSBzb3VyY2VbMF1bMF0sXG4gICAgICB5MCA9IHNvdXJjZVswXVsxXTtcbiAgICBsZXQgeDEgPSBzb3VyY2VbMV1bMF0sXG4gICAgICB5MSA9IHNvdXJjZVsxXVsxXTtcbiAgICBsZXQgeDIgPSBzb3VyY2VbMl1bMF0sXG4gICAgICB5MiA9IHNvdXJjZVsyXVsxXTtcbiAgICAvLyBNYWtlIHN1cmUgdGhhdCBldmVyeXRoaW5nIGlzIG9uIHBpeGVsIGJvdW5kYXJpZXNcbiAgICBjb25zdCB1MCA9IHBpeGVsUm91bmQoKHRhcmdldFswXVswXSAtIHRhcmdldFRvcExlZnRbMF0pIC8gdGFyZ2V0UmVzb2x1dGlvbik7XG4gICAgY29uc3QgdjAgPSBwaXhlbFJvdW5kKFxuICAgICAgLSh0YXJnZXRbMF1bMV0gLSB0YXJnZXRUb3BMZWZ0WzFdKSAvIHRhcmdldFJlc29sdXRpb25cbiAgICApO1xuICAgIGNvbnN0IHUxID0gcGl4ZWxSb3VuZCgodGFyZ2V0WzFdWzBdIC0gdGFyZ2V0VG9wTGVmdFswXSkgLyB0YXJnZXRSZXNvbHV0aW9uKTtcbiAgICBjb25zdCB2MSA9IHBpeGVsUm91bmQoXG4gICAgICAtKHRhcmdldFsxXVsxXSAtIHRhcmdldFRvcExlZnRbMV0pIC8gdGFyZ2V0UmVzb2x1dGlvblxuICAgICk7XG4gICAgY29uc3QgdTIgPSBwaXhlbFJvdW5kKCh0YXJnZXRbMl1bMF0gLSB0YXJnZXRUb3BMZWZ0WzBdKSAvIHRhcmdldFJlc29sdXRpb24pO1xuICAgIGNvbnN0IHYyID0gcGl4ZWxSb3VuZChcbiAgICAgIC0odGFyZ2V0WzJdWzFdIC0gdGFyZ2V0VG9wTGVmdFsxXSkgLyB0YXJnZXRSZXNvbHV0aW9uXG4gICAgKTtcblxuICAgIC8vIFNoaWZ0IGFsbCB0aGUgc291cmNlIHBvaW50cyB0byBpbXByb3ZlIG51bWVyaWNhbCBzdGFiaWxpdHlcbiAgICAvLyBvZiBhbGwgdGhlIHN1YnNlcXVlbnQgY2FsY3VsYXRpb25zLiBUaGUgW3gwLCB5MF0gaXMgdXNlZCBoZXJlLlxuICAgIC8vIFRoaXMgaXMgYWxzbyB1c2VkIHRvIHNpbXBsaWZ5IHRoZSBsaW5lYXIgc3lzdGVtLlxuICAgIGNvbnN0IHNvdXJjZU51bWVyaWNhbFNoaWZ0WCA9IHgwO1xuICAgIGNvbnN0IHNvdXJjZU51bWVyaWNhbFNoaWZ0WSA9IHkwO1xuICAgIHgwID0gMDtcbiAgICB5MCA9IDA7XG4gICAgeDEgLT0gc291cmNlTnVtZXJpY2FsU2hpZnRYO1xuICAgIHkxIC09IHNvdXJjZU51bWVyaWNhbFNoaWZ0WTtcbiAgICB4MiAtPSBzb3VyY2VOdW1lcmljYWxTaGlmdFg7XG4gICAgeTIgLT0gc291cmNlTnVtZXJpY2FsU2hpZnRZO1xuXG4gICAgY29uc3QgYXVnbWVudGVkTWF0cml4ID0gW1xuICAgICAgW3gxLCB5MSwgMCwgMCwgdTEgLSB1MF0sXG4gICAgICBbeDIsIHkyLCAwLCAwLCB1MiAtIHUwXSxcbiAgICAgIFswLCAwLCB4MSwgeTEsIHYxIC0gdjBdLFxuICAgICAgWzAsIDAsIHgyLCB5MiwgdjIgLSB2MF0sXG4gICAgXTtcbiAgICBjb25zdCBhZmZpbmVDb2VmcyA9IHNvbHZlTGluZWFyU3lzdGVtKGF1Z21lbnRlZE1hdHJpeCk7XG4gICAgaWYgKCFhZmZpbmVDb2Vmcykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnRleHQuc2F2ZSgpO1xuICAgIGNvbnRleHQuYmVnaW5QYXRoKCk7XG5cbiAgICBpZiAoaXNCcm9rZW5EaWFnb25hbFJlbmRlcmluZygpIHx8ICFpbnRlcnBvbGF0ZSkge1xuICAgICAgLy8gTWFrZSBzdXJlIHRoYXQgYWxsIGxpbmVzIGFyZSBob3Jpem9udGFsIG9yIHZlcnRpY2FsXG4gICAgICBjb250ZXh0Lm1vdmVUbyh1MSwgdjEpO1xuICAgICAgLy8gVGhpcyBpcyB0aGUgZGlhZ29uYWwgbGluZS4gRG8gaXQgaW4gNCBzdGVwc1xuICAgICAgY29uc3Qgc3RlcHMgPSA0O1xuICAgICAgY29uc3QgdWQgPSB1MCAtIHUxO1xuICAgICAgY29uc3QgdmQgPSB2MCAtIHYxO1xuICAgICAgZm9yIChsZXQgc3RlcCA9IDA7IHN0ZXAgPCBzdGVwczsgc3RlcCsrKSB7XG4gICAgICAgIC8vIEdvIGhvcml6b250YWxseVxuICAgICAgICBjb250ZXh0LmxpbmVUbyhcbiAgICAgICAgICB1MSArIHBpeGVsUm91bmQoKChzdGVwICsgMSkgKiB1ZCkgLyBzdGVwcyksXG4gICAgICAgICAgdjEgKyBwaXhlbFJvdW5kKChzdGVwICogdmQpIC8gKHN0ZXBzIC0gMSkpXG4gICAgICAgICk7XG4gICAgICAgIC8vIEdvIHZlcnRpY2FsbHlcbiAgICAgICAgaWYgKHN0ZXAgIT0gc3RlcHMgLSAxKSB7XG4gICAgICAgICAgY29udGV4dC5saW5lVG8oXG4gICAgICAgICAgICB1MSArIHBpeGVsUm91bmQoKChzdGVwICsgMSkgKiB1ZCkgLyBzdGVwcyksXG4gICAgICAgICAgICB2MSArIHBpeGVsUm91bmQoKChzdGVwICsgMSkgKiB2ZCkgLyAoc3RlcHMgLSAxKSlcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICAvLyBXZSBhcmUgYWxtb3N0IGF0IHUwciwgdjByXG4gICAgICBjb250ZXh0LmxpbmVUbyh1MiwgdjIpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb250ZXh0Lm1vdmVUbyh1MSwgdjEpO1xuICAgICAgY29udGV4dC5saW5lVG8odTAsIHYwKTtcbiAgICAgIGNvbnRleHQubGluZVRvKHUyLCB2Mik7XG4gICAgfVxuXG4gICAgY29udGV4dC5jbGlwKCk7XG5cbiAgICBjb250ZXh0LnRyYW5zZm9ybShcbiAgICAgIGFmZmluZUNvZWZzWzBdLFxuICAgICAgYWZmaW5lQ29lZnNbMl0sXG4gICAgICBhZmZpbmVDb2Vmc1sxXSxcbiAgICAgIGFmZmluZUNvZWZzWzNdLFxuICAgICAgdTAsXG4gICAgICB2MFxuICAgICk7XG5cbiAgICBjb250ZXh0LnRyYW5zbGF0ZShcbiAgICAgIHNvdXJjZURhdGFFeHRlbnRbMF0gLSBzb3VyY2VOdW1lcmljYWxTaGlmdFgsXG4gICAgICBzb3VyY2VEYXRhRXh0ZW50WzNdIC0gc291cmNlTnVtZXJpY2FsU2hpZnRZXG4gICAgKTtcblxuICAgIGNvbnRleHQuc2NhbGUoXG4gICAgICBzb3VyY2VSZXNvbHV0aW9uIC8gcGl4ZWxSYXRpbyxcbiAgICAgIC1zb3VyY2VSZXNvbHV0aW9uIC8gcGl4ZWxSYXRpb1xuICAgICk7XG5cbiAgICBjb250ZXh0LmRyYXdJbWFnZShzdGl0Y2hDb250ZXh0LmNhbnZhcywgMCwgMCk7XG4gICAgY29udGV4dC5yZXN0b3JlKCk7XG4gIH0pO1xuXG4gIHJlbGVhc2VDYW52YXMoc3RpdGNoQ29udGV4dCk7XG4gIGNhbnZhc1Bvb2wucHVzaChzdGl0Y2hDb250ZXh0LmNhbnZhcyk7XG5cbiAgaWYgKHJlbmRlckVkZ2VzKSB7XG4gICAgY29udGV4dC5zYXZlKCk7XG5cbiAgICBjb250ZXh0Lmdsb2JhbENvbXBvc2l0ZU9wZXJhdGlvbiA9ICdzb3VyY2Utb3Zlcic7XG4gICAgY29udGV4dC5zdHJva2VTdHlsZSA9ICdibGFjayc7XG4gICAgY29udGV4dC5saW5lV2lkdGggPSAxO1xuXG4gICAgdHJpYW5ndWxhdGlvbi5nZXRUcmlhbmdsZXMoKS5mb3JFYWNoKGZ1bmN0aW9uICh0cmlhbmdsZSwgaSwgYXJyKSB7XG4gICAgICBjb25zdCB0YXJnZXQgPSB0cmlhbmdsZS50YXJnZXQ7XG4gICAgICBjb25zdCB1MCA9ICh0YXJnZXRbMF1bMF0gLSB0YXJnZXRUb3BMZWZ0WzBdKSAvIHRhcmdldFJlc29sdXRpb247XG4gICAgICBjb25zdCB2MCA9IC0odGFyZ2V0WzBdWzFdIC0gdGFyZ2V0VG9wTGVmdFsxXSkgLyB0YXJnZXRSZXNvbHV0aW9uO1xuICAgICAgY29uc3QgdTEgPSAodGFyZ2V0WzFdWzBdIC0gdGFyZ2V0VG9wTGVmdFswXSkgLyB0YXJnZXRSZXNvbHV0aW9uO1xuICAgICAgY29uc3QgdjEgPSAtKHRhcmdldFsxXVsxXSAtIHRhcmdldFRvcExlZnRbMV0pIC8gdGFyZ2V0UmVzb2x1dGlvbjtcbiAgICAgIGNvbnN0IHUyID0gKHRhcmdldFsyXVswXSAtIHRhcmdldFRvcExlZnRbMF0pIC8gdGFyZ2V0UmVzb2x1dGlvbjtcbiAgICAgIGNvbnN0IHYyID0gLSh0YXJnZXRbMl1bMV0gLSB0YXJnZXRUb3BMZWZ0WzFdKSAvIHRhcmdldFJlc29sdXRpb247XG5cbiAgICAgIGNvbnRleHQuYmVnaW5QYXRoKCk7XG4gICAgICBjb250ZXh0Lm1vdmVUbyh1MSwgdjEpO1xuICAgICAgY29udGV4dC5saW5lVG8odTAsIHYwKTtcbiAgICAgIGNvbnRleHQubGluZVRvKHUyLCB2Mik7XG4gICAgICBjb250ZXh0LmNsb3NlUGF0aCgpO1xuICAgICAgY29udGV4dC5zdHJva2UoKTtcbiAgICB9KTtcblxuICAgIGNvbnRleHQucmVzdG9yZSgpO1xuICB9XG4gIHJldHVybiBjb250ZXh0LmNhbnZhcztcbn1cbiIsIi8qKlxuICogQG1vZHVsZSBvbC9yZXByb2ovVGlsZVxuICovXG5pbXBvcnQge0VSUk9SX1RIUkVTSE9MRH0gZnJvbSAnLi9jb21tb24uanMnO1xuXG5pbXBvcnQgRXZlbnRUeXBlIGZyb20gJy4uL2V2ZW50cy9FdmVudFR5cGUuanMnO1xuaW1wb3J0IFRpbGUgZnJvbSAnLi4vVGlsZS5qcyc7XG5pbXBvcnQgVGlsZVN0YXRlIGZyb20gJy4uL1RpbGVTdGF0ZS5qcyc7XG5pbXBvcnQgVHJpYW5ndWxhdGlvbiBmcm9tICcuL1RyaWFuZ3VsYXRpb24uanMnO1xuaW1wb3J0IHtcbiAgY2FsY3VsYXRlU291cmNlRXh0ZW50UmVzb2x1dGlvbixcbiAgY2FudmFzUG9vbCxcbiAgcmVuZGVyIGFzIHJlbmRlclJlcHJvamVjdGVkLFxufSBmcm9tICcuLi9yZXByb2ouanMnO1xuaW1wb3J0IHtjbGFtcH0gZnJvbSAnLi4vbWF0aC5qcyc7XG5pbXBvcnQge2dldEFyZWEsIGdldEludGVyc2VjdGlvbn0gZnJvbSAnLi4vZXh0ZW50LmpzJztcbmltcG9ydCB7bGlzdGVuLCB1bmxpc3RlbkJ5S2V5fSBmcm9tICcuLi9ldmVudHMuanMnO1xuaW1wb3J0IHtyZWxlYXNlQ2FudmFzfSBmcm9tICcuLi9kb20uanMnO1xuXG4vKipcbiAqIEB0eXBlZGVmIHtmdW5jdGlvbihudW1iZXIsIG51bWJlciwgbnVtYmVyLCBudW1iZXIpIDogKGltcG9ydChcIi4uL0ltYWdlVGlsZS5qc1wiKS5kZWZhdWx0KX0gRnVuY3Rpb25UeXBlXG4gKi9cblxuLyoqXG4gKiBAY2xhc3NkZXNjXG4gKiBDbGFzcyBlbmNhcHN1bGF0aW5nIHNpbmdsZSByZXByb2plY3RlZCB0aWxlLlxuICogU2VlIHtAbGluayBtb2R1bGU6b2wvc291cmNlL1RpbGVJbWFnZX5UaWxlSW1hZ2V9LlxuICpcbiAqL1xuY2xhc3MgUmVwcm9qVGlsZSBleHRlbmRzIFRpbGUge1xuICAvKipcbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9wcm9qL1Byb2plY3Rpb24uanNcIikuZGVmYXVsdH0gc291cmNlUHJvaiBTb3VyY2UgcHJvamVjdGlvbi5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi90aWxlZ3JpZC9UaWxlR3JpZC5qc1wiKS5kZWZhdWx0fSBzb3VyY2VUaWxlR3JpZCBTb3VyY2UgdGlsZSBncmlkLlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL3Byb2ovUHJvamVjdGlvbi5qc1wiKS5kZWZhdWx0fSB0YXJnZXRQcm9qIFRhcmdldCBwcm9qZWN0aW9uLlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL3RpbGVncmlkL1RpbGVHcmlkLmpzXCIpLmRlZmF1bHR9IHRhcmdldFRpbGVHcmlkIFRhcmdldCB0aWxlIGdyaWQuXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vdGlsZWNvb3JkLmpzXCIpLlRpbGVDb29yZH0gdGlsZUNvb3JkIENvb3JkaW5hdGUgb2YgdGhlIHRpbGUuXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vdGlsZWNvb3JkLmpzXCIpLlRpbGVDb29yZH0gd3JhcHBlZFRpbGVDb29yZCBDb29yZGluYXRlIG9mIHRoZSB0aWxlIHdyYXBwZWQgaW4gWC5cbiAgICogQHBhcmFtIHtudW1iZXJ9IHBpeGVsUmF0aW8gUGl4ZWwgcmF0aW8uXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBndXR0ZXIgR3V0dGVyIG9mIHRoZSBzb3VyY2UgdGlsZXMuXG4gICAqIEBwYXJhbSB7RnVuY3Rpb25UeXBlfSBnZXRUaWxlRnVuY3Rpb25cbiAgICogICAgIEZ1bmN0aW9uIHJldHVybmluZyBzb3VyY2UgdGlsZXMgKHosIHgsIHksIHBpeGVsUmF0aW8pLlxuICAgKiBAcGFyYW0ge251bWJlcn0gW2Vycm9yVGhyZXNob2xkXSBBY2NlcHRhYmxlIHJlcHJvamVjdGlvbiBlcnJvciAoaW4gcHgpLlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtyZW5kZXJFZGdlc10gUmVuZGVyIHJlcHJvamVjdGlvbiBlZGdlcy5cbiAgICogQHBhcmFtIHtib29sZWFufSBbaW50ZXJwb2xhdGVdIFVzZSBsaW5lYXIgaW50ZXJwb2xhdGlvbiB3aGVuIHJlc2FtcGxpbmcuXG4gICAqL1xuICBjb25zdHJ1Y3RvcihcbiAgICBzb3VyY2VQcm9qLFxuICAgIHNvdXJjZVRpbGVHcmlkLFxuICAgIHRhcmdldFByb2osXG4gICAgdGFyZ2V0VGlsZUdyaWQsXG4gICAgdGlsZUNvb3JkLFxuICAgIHdyYXBwZWRUaWxlQ29vcmQsXG4gICAgcGl4ZWxSYXRpbyxcbiAgICBndXR0ZXIsXG4gICAgZ2V0VGlsZUZ1bmN0aW9uLFxuICAgIGVycm9yVGhyZXNob2xkLFxuICAgIHJlbmRlckVkZ2VzLFxuICAgIGludGVycG9sYXRlXG4gICkge1xuICAgIHN1cGVyKHRpbGVDb29yZCwgVGlsZVN0YXRlLklETEUsIHtpbnRlcnBvbGF0ZTogISFpbnRlcnBvbGF0ZX0pO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICB0aGlzLnJlbmRlckVkZ2VzXyA9IHJlbmRlckVkZ2VzICE9PSB1bmRlZmluZWQgPyByZW5kZXJFZGdlcyA6IGZhbHNlO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMucGl4ZWxSYXRpb18gPSBwaXhlbFJhdGlvO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMuZ3V0dGVyXyA9IGd1dHRlcjtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge0hUTUxDYW52YXNFbGVtZW50fVxuICAgICAqL1xuICAgIHRoaXMuY2FudmFzXyA9IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtpbXBvcnQoXCIuLi90aWxlZ3JpZC9UaWxlR3JpZC5qc1wiKS5kZWZhdWx0fVxuICAgICAqL1xuICAgIHRoaXMuc291cmNlVGlsZUdyaWRfID0gc291cmNlVGlsZUdyaWQ7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtpbXBvcnQoXCIuLi90aWxlZ3JpZC9UaWxlR3JpZC5qc1wiKS5kZWZhdWx0fVxuICAgICAqL1xuICAgIHRoaXMudGFyZ2V0VGlsZUdyaWRfID0gdGFyZ2V0VGlsZUdyaWQ7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtpbXBvcnQoXCIuLi90aWxlY29vcmQuanNcIikuVGlsZUNvb3JkfVxuICAgICAqL1xuICAgIHRoaXMud3JhcHBlZFRpbGVDb29yZF8gPSB3cmFwcGVkVGlsZUNvb3JkID8gd3JhcHBlZFRpbGVDb29yZCA6IHRpbGVDb29yZDtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUgeyFBcnJheTxpbXBvcnQoXCIuLi9JbWFnZVRpbGUuanNcIikuZGVmYXVsdD59XG4gICAgICovXG4gICAgdGhpcy5zb3VyY2VUaWxlc18gPSBbXTtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUgez9BcnJheTxpbXBvcnQoXCIuLi9ldmVudHMuanNcIikuRXZlbnRzS2V5Pn1cbiAgICAgKi9cbiAgICB0aGlzLnNvdXJjZXNMaXN0ZW5lcktleXNfID0gbnVsbDtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLnNvdXJjZVpfID0gMDtcblxuICAgIGNvbnN0IHRhcmdldEV4dGVudCA9IHRhcmdldFRpbGVHcmlkLmdldFRpbGVDb29yZEV4dGVudChcbiAgICAgIHRoaXMud3JhcHBlZFRpbGVDb29yZF9cbiAgICApO1xuICAgIGNvbnN0IG1heFRhcmdldEV4dGVudCA9IHRoaXMudGFyZ2V0VGlsZUdyaWRfLmdldEV4dGVudCgpO1xuICAgIGxldCBtYXhTb3VyY2VFeHRlbnQgPSB0aGlzLnNvdXJjZVRpbGVHcmlkXy5nZXRFeHRlbnQoKTtcblxuICAgIGNvbnN0IGxpbWl0ZWRUYXJnZXRFeHRlbnQgPSBtYXhUYXJnZXRFeHRlbnRcbiAgICAgID8gZ2V0SW50ZXJzZWN0aW9uKHRhcmdldEV4dGVudCwgbWF4VGFyZ2V0RXh0ZW50KVxuICAgICAgOiB0YXJnZXRFeHRlbnQ7XG5cbiAgICBpZiAoZ2V0QXJlYShsaW1pdGVkVGFyZ2V0RXh0ZW50KSA9PT0gMCkge1xuICAgICAgLy8gVGlsZSBpcyBjb21wbGV0ZWx5IG91dHNpZGUgcmFuZ2UgLT4gRU1QVFlcbiAgICAgIC8vIFRPRE86IGlzIGl0IGFjdHVhbGx5IGNvcnJlY3QgdGhhdCB0aGUgc291cmNlIGV2ZW4gY3JlYXRlcyB0aGUgdGlsZSA/XG4gICAgICB0aGlzLnN0YXRlID0gVGlsZVN0YXRlLkVNUFRZO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IHNvdXJjZVByb2pFeHRlbnQgPSBzb3VyY2VQcm9qLmdldEV4dGVudCgpO1xuICAgIGlmIChzb3VyY2VQcm9qRXh0ZW50KSB7XG4gICAgICBpZiAoIW1heFNvdXJjZUV4dGVudCkge1xuICAgICAgICBtYXhTb3VyY2VFeHRlbnQgPSBzb3VyY2VQcm9qRXh0ZW50O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbWF4U291cmNlRXh0ZW50ID0gZ2V0SW50ZXJzZWN0aW9uKG1heFNvdXJjZUV4dGVudCwgc291cmNlUHJvakV4dGVudCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgY29uc3QgdGFyZ2V0UmVzb2x1dGlvbiA9IHRhcmdldFRpbGVHcmlkLmdldFJlc29sdXRpb24oXG4gICAgICB0aGlzLndyYXBwZWRUaWxlQ29vcmRfWzBdXG4gICAgKTtcblxuICAgIGNvbnN0IHNvdXJjZVJlc29sdXRpb24gPSBjYWxjdWxhdGVTb3VyY2VFeHRlbnRSZXNvbHV0aW9uKFxuICAgICAgc291cmNlUHJvaixcbiAgICAgIHRhcmdldFByb2osXG4gICAgICBsaW1pdGVkVGFyZ2V0RXh0ZW50LFxuICAgICAgdGFyZ2V0UmVzb2x1dGlvblxuICAgICk7XG5cbiAgICBpZiAoIWlzRmluaXRlKHNvdXJjZVJlc29sdXRpb24pIHx8IHNvdXJjZVJlc29sdXRpb24gPD0gMCkge1xuICAgICAgLy8gaW52YWxpZCBzb3VyY2VSZXNvbHV0aW9uIC0+IEVNUFRZXG4gICAgICAvLyBwcm9iYWJseSBlZGdlcyBvZiB0aGUgcHJvamVjdGlvbnMgd2hlbiBubyBleHRlbnQgaXMgZGVmaW5lZFxuICAgICAgdGhpcy5zdGF0ZSA9IFRpbGVTdGF0ZS5FTVBUWTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCBlcnJvclRocmVzaG9sZEluUGl4ZWxzID1cbiAgICAgIGVycm9yVGhyZXNob2xkICE9PSB1bmRlZmluZWQgPyBlcnJvclRocmVzaG9sZCA6IEVSUk9SX1RIUkVTSE9MRDtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUgeyFpbXBvcnQoXCIuL1RyaWFuZ3VsYXRpb24uanNcIikuZGVmYXVsdH1cbiAgICAgKi9cbiAgICB0aGlzLnRyaWFuZ3VsYXRpb25fID0gbmV3IFRyaWFuZ3VsYXRpb24oXG4gICAgICBzb3VyY2VQcm9qLFxuICAgICAgdGFyZ2V0UHJvaixcbiAgICAgIGxpbWl0ZWRUYXJnZXRFeHRlbnQsXG4gICAgICBtYXhTb3VyY2VFeHRlbnQsXG4gICAgICBzb3VyY2VSZXNvbHV0aW9uICogZXJyb3JUaHJlc2hvbGRJblBpeGVscyxcbiAgICAgIHRhcmdldFJlc29sdXRpb25cbiAgICApO1xuXG4gICAgaWYgKHRoaXMudHJpYW5ndWxhdGlvbl8uZ2V0VHJpYW5nbGVzKCkubGVuZ3RoID09PSAwKSB7XG4gICAgICAvLyBubyB2YWxpZCB0cmlhbmdsZXMgLT4gRU1QVFlcbiAgICAgIHRoaXMuc3RhdGUgPSBUaWxlU3RhdGUuRU1QVFk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy5zb3VyY2VaXyA9IHNvdXJjZVRpbGVHcmlkLmdldFpGb3JSZXNvbHV0aW9uKHNvdXJjZVJlc29sdXRpb24pO1xuICAgIGxldCBzb3VyY2VFeHRlbnQgPSB0aGlzLnRyaWFuZ3VsYXRpb25fLmNhbGN1bGF0ZVNvdXJjZUV4dGVudCgpO1xuXG4gICAgaWYgKG1heFNvdXJjZUV4dGVudCkge1xuICAgICAgaWYgKHNvdXJjZVByb2ouY2FuV3JhcFgoKSkge1xuICAgICAgICBzb3VyY2VFeHRlbnRbMV0gPSBjbGFtcChcbiAgICAgICAgICBzb3VyY2VFeHRlbnRbMV0sXG4gICAgICAgICAgbWF4U291cmNlRXh0ZW50WzFdLFxuICAgICAgICAgIG1heFNvdXJjZUV4dGVudFszXVxuICAgICAgICApO1xuICAgICAgICBzb3VyY2VFeHRlbnRbM10gPSBjbGFtcChcbiAgICAgICAgICBzb3VyY2VFeHRlbnRbM10sXG4gICAgICAgICAgbWF4U291cmNlRXh0ZW50WzFdLFxuICAgICAgICAgIG1heFNvdXJjZUV4dGVudFszXVxuICAgICAgICApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc291cmNlRXh0ZW50ID0gZ2V0SW50ZXJzZWN0aW9uKHNvdXJjZUV4dGVudCwgbWF4U291cmNlRXh0ZW50KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoIWdldEFyZWEoc291cmNlRXh0ZW50KSkge1xuICAgICAgdGhpcy5zdGF0ZSA9IFRpbGVTdGF0ZS5FTVBUWTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3Qgc291cmNlUmFuZ2UgPSBzb3VyY2VUaWxlR3JpZC5nZXRUaWxlUmFuZ2VGb3JFeHRlbnRBbmRaKFxuICAgICAgICBzb3VyY2VFeHRlbnQsXG4gICAgICAgIHRoaXMuc291cmNlWl9cbiAgICAgICk7XG5cbiAgICAgIGZvciAobGV0IHNyY1ggPSBzb3VyY2VSYW5nZS5taW5YOyBzcmNYIDw9IHNvdXJjZVJhbmdlLm1heFg7IHNyY1grKykge1xuICAgICAgICBmb3IgKGxldCBzcmNZID0gc291cmNlUmFuZ2UubWluWTsgc3JjWSA8PSBzb3VyY2VSYW5nZS5tYXhZOyBzcmNZKyspIHtcbiAgICAgICAgICBjb25zdCB0aWxlID0gZ2V0VGlsZUZ1bmN0aW9uKHRoaXMuc291cmNlWl8sIHNyY1gsIHNyY1ksIHBpeGVsUmF0aW8pO1xuICAgICAgICAgIGlmICh0aWxlKSB7XG4gICAgICAgICAgICB0aGlzLnNvdXJjZVRpbGVzXy5wdXNoKHRpbGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5zb3VyY2VUaWxlc18ubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHRoaXMuc3RhdGUgPSBUaWxlU3RhdGUuRU1QVFk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgSFRNTCBDYW52YXMgZWxlbWVudCBmb3IgdGhpcyB0aWxlLlxuICAgKiBAcmV0dXJuIHtIVE1MQ2FudmFzRWxlbWVudH0gQ2FudmFzLlxuICAgKi9cbiAgZ2V0SW1hZ2UoKSB7XG4gICAgcmV0dXJuIHRoaXMuY2FudmFzXztcbiAgfVxuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgcmVwcm9qZWN0XygpIHtcbiAgICBjb25zdCBzb3VyY2VzID0gW107XG4gICAgdGhpcy5zb3VyY2VUaWxlc18uZm9yRWFjaCgodGlsZSkgPT4ge1xuICAgICAgaWYgKHRpbGUgJiYgdGlsZS5nZXRTdGF0ZSgpID09IFRpbGVTdGF0ZS5MT0FERUQpIHtcbiAgICAgICAgc291cmNlcy5wdXNoKHtcbiAgICAgICAgICBleHRlbnQ6IHRoaXMuc291cmNlVGlsZUdyaWRfLmdldFRpbGVDb29yZEV4dGVudCh0aWxlLnRpbGVDb29yZCksXG4gICAgICAgICAgaW1hZ2U6IHRpbGUuZ2V0SW1hZ2UoKSxcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgdGhpcy5zb3VyY2VUaWxlc18ubGVuZ3RoID0gMDtcblxuICAgIGlmIChzb3VyY2VzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgdGhpcy5zdGF0ZSA9IFRpbGVTdGF0ZS5FUlJPUjtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgeiA9IHRoaXMud3JhcHBlZFRpbGVDb29yZF9bMF07XG4gICAgICBjb25zdCBzaXplID0gdGhpcy50YXJnZXRUaWxlR3JpZF8uZ2V0VGlsZVNpemUoeik7XG4gICAgICBjb25zdCB3aWR0aCA9IHR5cGVvZiBzaXplID09PSAnbnVtYmVyJyA/IHNpemUgOiBzaXplWzBdO1xuICAgICAgY29uc3QgaGVpZ2h0ID0gdHlwZW9mIHNpemUgPT09ICdudW1iZXInID8gc2l6ZSA6IHNpemVbMV07XG4gICAgICBjb25zdCB0YXJnZXRSZXNvbHV0aW9uID0gdGhpcy50YXJnZXRUaWxlR3JpZF8uZ2V0UmVzb2x1dGlvbih6KTtcbiAgICAgIGNvbnN0IHNvdXJjZVJlc29sdXRpb24gPSB0aGlzLnNvdXJjZVRpbGVHcmlkXy5nZXRSZXNvbHV0aW9uKFxuICAgICAgICB0aGlzLnNvdXJjZVpfXG4gICAgICApO1xuXG4gICAgICBjb25zdCB0YXJnZXRFeHRlbnQgPSB0aGlzLnRhcmdldFRpbGVHcmlkXy5nZXRUaWxlQ29vcmRFeHRlbnQoXG4gICAgICAgIHRoaXMud3JhcHBlZFRpbGVDb29yZF9cbiAgICAgICk7XG5cbiAgICAgIHRoaXMuY2FudmFzXyA9IHJlbmRlclJlcHJvamVjdGVkKFxuICAgICAgICB3aWR0aCxcbiAgICAgICAgaGVpZ2h0LFxuICAgICAgICB0aGlzLnBpeGVsUmF0aW9fLFxuICAgICAgICBzb3VyY2VSZXNvbHV0aW9uLFxuICAgICAgICB0aGlzLnNvdXJjZVRpbGVHcmlkXy5nZXRFeHRlbnQoKSxcbiAgICAgICAgdGFyZ2V0UmVzb2x1dGlvbixcbiAgICAgICAgdGFyZ2V0RXh0ZW50LFxuICAgICAgICB0aGlzLnRyaWFuZ3VsYXRpb25fLFxuICAgICAgICBzb3VyY2VzLFxuICAgICAgICB0aGlzLmd1dHRlcl8sXG4gICAgICAgIHRoaXMucmVuZGVyRWRnZXNfLFxuICAgICAgICB0aGlzLmludGVycG9sYXRlXG4gICAgICApO1xuXG4gICAgICB0aGlzLnN0YXRlID0gVGlsZVN0YXRlLkxPQURFRDtcbiAgICB9XG4gICAgdGhpcy5jaGFuZ2VkKCk7XG4gIH1cblxuICAvKipcbiAgICogTG9hZCBub3QgeWV0IGxvYWRlZCBVUkkuXG4gICAqL1xuICBsb2FkKCkge1xuICAgIGlmICh0aGlzLnN0YXRlID09IFRpbGVTdGF0ZS5JRExFKSB7XG4gICAgICB0aGlzLnN0YXRlID0gVGlsZVN0YXRlLkxPQURJTkc7XG4gICAgICB0aGlzLmNoYW5nZWQoKTtcblxuICAgICAgbGV0IGxlZnRUb0xvYWQgPSAwO1xuXG4gICAgICB0aGlzLnNvdXJjZXNMaXN0ZW5lcktleXNfID0gW107XG4gICAgICB0aGlzLnNvdXJjZVRpbGVzXy5mb3JFYWNoKCh0aWxlKSA9PiB7XG4gICAgICAgIGNvbnN0IHN0YXRlID0gdGlsZS5nZXRTdGF0ZSgpO1xuICAgICAgICBpZiAoc3RhdGUgPT0gVGlsZVN0YXRlLklETEUgfHwgc3RhdGUgPT0gVGlsZVN0YXRlLkxPQURJTkcpIHtcbiAgICAgICAgICBsZWZ0VG9Mb2FkKys7XG5cbiAgICAgICAgICBjb25zdCBzb3VyY2VMaXN0ZW5LZXkgPSBsaXN0ZW4oXG4gICAgICAgICAgICB0aWxlLFxuICAgICAgICAgICAgRXZlbnRUeXBlLkNIQU5HRSxcbiAgICAgICAgICAgIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAgIGNvbnN0IHN0YXRlID0gdGlsZS5nZXRTdGF0ZSgpO1xuICAgICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgc3RhdGUgPT0gVGlsZVN0YXRlLkxPQURFRCB8fFxuICAgICAgICAgICAgICAgIHN0YXRlID09IFRpbGVTdGF0ZS5FUlJPUiB8fFxuICAgICAgICAgICAgICAgIHN0YXRlID09IFRpbGVTdGF0ZS5FTVBUWVxuICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICB1bmxpc3RlbkJ5S2V5KHNvdXJjZUxpc3RlbktleSk7XG4gICAgICAgICAgICAgICAgbGVmdFRvTG9hZC0tO1xuICAgICAgICAgICAgICAgIGlmIChsZWZ0VG9Mb2FkID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICB0aGlzLnVubGlzdGVuU291cmNlc18oKTtcbiAgICAgICAgICAgICAgICAgIHRoaXMucmVwcm9qZWN0XygpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHRoaXNcbiAgICAgICAgICApO1xuICAgICAgICAgIHRoaXMuc291cmNlc0xpc3RlbmVyS2V5c18ucHVzaChzb3VyY2VMaXN0ZW5LZXkpO1xuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgaWYgKGxlZnRUb0xvYWQgPT09IDApIHtcbiAgICAgICAgc2V0VGltZW91dCh0aGlzLnJlcHJvamVjdF8uYmluZCh0aGlzKSwgMCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnNvdXJjZVRpbGVzXy5mb3JFYWNoKGZ1bmN0aW9uICh0aWxlLCBpLCBhcnIpIHtcbiAgICAgICAgICBjb25zdCBzdGF0ZSA9IHRpbGUuZ2V0U3RhdGUoKTtcbiAgICAgICAgICBpZiAoc3RhdGUgPT0gVGlsZVN0YXRlLklETEUpIHtcbiAgICAgICAgICAgIHRpbGUubG9hZCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICB1bmxpc3RlblNvdXJjZXNfKCkge1xuICAgIHRoaXMuc291cmNlc0xpc3RlbmVyS2V5c18uZm9yRWFjaCh1bmxpc3RlbkJ5S2V5KTtcbiAgICB0aGlzLnNvdXJjZXNMaXN0ZW5lcktleXNfID0gbnVsbDtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZW1vdmUgZnJvbSB0aGUgY2FjaGUgZHVlIHRvIGV4cGlyeVxuICAgKi9cbiAgcmVsZWFzZSgpIHtcbiAgICBpZiAodGhpcy5jYW52YXNfKSB7XG4gICAgICByZWxlYXNlQ2FudmFzKHRoaXMuY2FudmFzXy5nZXRDb250ZXh0KCcyZCcpKTtcbiAgICAgIGNhbnZhc1Bvb2wucHVzaCh0aGlzLmNhbnZhc18pO1xuICAgICAgdGhpcy5jYW52YXNfID0gbnVsbDtcbiAgICB9XG4gICAgc3VwZXIucmVsZWFzZSgpO1xuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IFJlcHJvalRpbGU7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///81499\n')}}]);