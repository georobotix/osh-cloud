"use strict";(self["webpackChunkvue3_webpack5"]=self["webpackChunkvue3_webpack5"]||[]).push([[8972],{13222:function(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__){eval("/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Z\": function() { return /* binding */ when; }\n/* harmony export */ });\n/* harmony import */ var _commonjsHelpers_3aae1032_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(22549);\n/* This file is automatically rebuilt by the Cesium build process. */\n\n\nvar when = (0,_commonjsHelpers_3aae1032_js__WEBPACK_IMPORTED_MODULE_0__.c)(function (module, exports) {\n/** @license MIT License (c) copyright B Cavalier & J Hann */\n\n/**\n * A lightweight CommonJS Promises/A and when() implementation\n * when is part of the cujo.js family of libraries (http://cujojs.com/)\n *\n * Licensed under the MIT License at:\n * http://www.opensource.org/licenses/mit-license.php\n *\n * @version 1.7.1\n */\n\n(function(define) {define(function () {\n\tvar reduceArray, slice, undef;\n\n\t//\n\t// Public API\n\t//\n\n\twhen.defer     = defer;     // Create a deferred\n\twhen.resolve   = resolve;   // Create a resolved promise\n\twhen.reject    = reject;    // Create a rejected promise\n\n\twhen.join      = join;      // Join 2 or more promises\n\n\twhen.all       = all;       // Resolve a list of promises\n\twhen.map       = map;       // Array.map() for promises\n\twhen.reduce    = reduce;    // Array.reduce() for promises\n\n\twhen.any       = any;       // One-winner race\n\twhen.some      = some;      // Multi-winner race\n\n\twhen.chain     = chain;     // Make a promise trigger another resolver\n\n\twhen.isPromise = isPromise; // Determine if a thing is a promise\n\n\t/**\n\t * Register an observer for a promise or immediate value.\n\t *\n\t * @param {*} promiseOrValue\n\t * @param {function?} [onFulfilled] callback to be called when promiseOrValue is\n\t *   successfully fulfilled.  If promiseOrValue is an immediate value, callback\n\t *   will be invoked immediately.\n\t * @param {function?} [onRejected] callback to be called when promiseOrValue is\n\t *   rejected.\n\t * @param {function?} [onProgress] callback to be called when progress updates\n\t *   are issued for promiseOrValue.\n\t * @returns {Promise} a new {@link Promise} that will complete with the return\n\t *   value of callback or errback or the completion value of promiseOrValue if\n\t *   callback and/or errback is not supplied.\n\t */\n\tfunction when(promiseOrValue, onFulfilled, onRejected, onProgress) {\n\t\t// Get a trusted promise for the input promiseOrValue, and then\n\t\t// register promise handlers\n\t\treturn resolve(promiseOrValue).then(onFulfilled, onRejected, onProgress);\n\t}\n\n\t/**\n\t * Returns promiseOrValue if promiseOrValue is a {@link Promise}, a new Promise if\n\t * promiseOrValue is a foreign promise, or a new, already-fulfilled {@link Promise}\n\t * whose value is promiseOrValue if promiseOrValue is an immediate value.\n\t *\n\t * @param {*} promiseOrValue\n\t * @returns Guaranteed to return a trusted Promise.  If promiseOrValue is a when.js {@link Promise}\n\t *   returns promiseOrValue, otherwise, returns a new, already-resolved, when.js {@link Promise}\n\t *   whose resolution value is:\n\t *   * the resolution value of promiseOrValue if it's a foreign promise, or\n\t *   * promiseOrValue if it's a value\n\t */\n\tfunction resolve(promiseOrValue) {\n\t\tvar promise, deferred;\n\n\t\tif(promiseOrValue instanceof Promise) {\n\t\t\t// It's a when.js promise, so we trust it\n\t\t\tpromise = promiseOrValue;\n\n\t\t} else {\n\t\t\t// It's not a when.js promise. See if it's a foreign promise or a value.\n\t\t\tif(isPromise(promiseOrValue)) {\n\t\t\t\t// It's a thenable, but we don't know where it came from, so don't trust\n\t\t\t\t// its implementation entirely.  Introduce a trusted middleman when.js promise\n\t\t\t\tdeferred = defer();\n\n\t\t\t\t// IMPORTANT: This is the only place when.js should ever call .then() on an\n\t\t\t\t// untrusted promise. Don't expose the return value to the untrusted promise\n\t\t\t\tpromiseOrValue.then(\n\t\t\t\t\tfunction(value)  { deferred.resolve(value); },\n\t\t\t\t\tfunction(reason) { deferred.reject(reason); },\n\t\t\t\t\tfunction(update) { deferred.progress(update); }\n\t\t\t\t);\n\n\t\t\t\tpromise = deferred.promise;\n\n\t\t\t} else {\n\t\t\t\t// It's a value, not a promise.  Create a resolved promise for it.\n\t\t\t\tpromise = fulfilled(promiseOrValue);\n\t\t\t}\n\t\t}\n\n\t\treturn promise;\n\t}\n\n\t/**\n\t * Returns a rejected promise for the supplied promiseOrValue.  The returned\n\t * promise will be rejected with:\n\t * - promiseOrValue, if it is a value, or\n\t * - if promiseOrValue is a promise\n\t *   - promiseOrValue's value after it is fulfilled\n\t *   - promiseOrValue's reason after it is rejected\n\t * @param {*} promiseOrValue the rejected value of the returned {@link Promise}\n\t * @return {Promise} rejected {@link Promise}\n\t */\n\tfunction reject(promiseOrValue) {\n\t\treturn when(promiseOrValue, rejected);\n\t}\n\n\t/**\n\t * Trusted Promise constructor.  A Promise created from this constructor is\n\t * a trusted when.js promise.  Any other duck-typed promise is considered\n\t * untrusted.\n\t * @constructor\n\t * @name Promise\n\t */\n\tfunction Promise(then) {\n\t\tthis.then = then;\n\t}\n\n\tPromise.prototype = {\n\t\t/**\n\t\t * Register a callback that will be called when a promise is\n\t\t * fulfilled or rejected.  Optionally also register a progress handler.\n\t\t * Shortcut for .then(onFulfilledOrRejected, onFulfilledOrRejected, onProgress)\n\t\t * @param {function?} [onFulfilledOrRejected]\n\t\t * @param {function?} [onProgress]\n\t\t * @return {Promise}\n\t\t */\n\t\talways: function(onFulfilledOrRejected, onProgress) {\n\t\t\treturn this.then(onFulfilledOrRejected, onFulfilledOrRejected, onProgress);\n\t\t},\n\n\t\t/**\n\t\t * Register a rejection handler.  Shortcut for .then(undefined, onRejected)\n\t\t * @param {function?} onRejected\n\t\t * @return {Promise}\n\t\t */\n\t\totherwise: function(onRejected) {\n\t\t\treturn this.then(undef, onRejected);\n\t\t},\n\n\t\t/**\n\t\t * Shortcut for .then(function() { return value; })\n\t\t * @param  {*} value\n\t\t * @return {Promise} a promise that:\n\t\t *  - is fulfilled if value is not a promise, or\n\t\t *  - if value is a promise, will fulfill with its value, or reject\n\t\t *    with its reason.\n\t\t */\n\t\tyield: function(value) {\n\t\t\treturn this.then(function() {\n\t\t\t\treturn value;\n\t\t\t});\n\t\t},\n\n\t\t/**\n\t\t * Assumes that this promise will fulfill with an array, and arranges\n\t\t * for the onFulfilled to be called with the array as its argument list\n\t\t * i.e. onFulfilled.spread(undefined, array).\n\t\t * @param {function} onFulfilled function to receive spread arguments\n\t\t * @return {Promise}\n\t\t */\n\t\tspread: function(onFulfilled) {\n\t\t\treturn this.then(function(array) {\n\t\t\t\t// array may contain promises, so resolve its contents.\n\t\t\t\treturn all(array, function(array) {\n\t\t\t\t\treturn onFulfilled.apply(undef, array);\n\t\t\t\t});\n\t\t\t});\n\t\t}\n\t};\n\n\t/**\n\t * Create an already-resolved promise for the supplied value\n\t * @private\n\t *\n\t * @param {*} value\n\t * @return {Promise} fulfilled promise\n\t */\n\tfunction fulfilled(value) {\n\t\tvar p = new Promise(function(onFulfilled) {\n\t\t\t// TODO: Promises/A+ check typeof onFulfilled\n\t\t\ttry {\n\t\t\t\treturn resolve(onFulfilled ? onFulfilled(value) : value);\n\t\t\t} catch(e) {\n\t\t\t\treturn rejected(e);\n\t\t\t}\n\t\t});\n\n\t\treturn p;\n\t}\n\n\t/**\n\t * Create an already-rejected {@link Promise} with the supplied\n\t * rejection reason.\n\t * @private\n\t *\n\t * @param {*} reason\n\t * @return {Promise} rejected promise\n\t */\n\tfunction rejected(reason) {\n\t\tvar p = new Promise(function(_, onRejected) {\n\t\t\t// TODO: Promises/A+ check typeof onRejected\n\t\t\ttry {\n\t\t\t\treturn onRejected ? resolve(onRejected(reason)) : rejected(reason);\n\t\t\t} catch(e) {\n\t\t\t\treturn rejected(e);\n\t\t\t}\n\t\t});\n\n\t\treturn p;\n\t}\n\n\t/**\n\t * Creates a new, Deferred with fully isolated resolver and promise parts,\n\t * either or both of which may be given out safely to consumers.\n\t * The Deferred itself has the full API: resolve, reject, progress, and\n\t * then. The resolver has resolve, reject, and progress.  The promise\n\t * only has then.\n\t *\n\t * @return {Deferred}\n\t */\n\tfunction defer() {\n\t\tvar deferred, promise, handlers, progressHandlers,\n\t\t\t_then, _progress, _resolve;\n\n\t\t/**\n\t\t * The promise for the new deferred\n\t\t * @type {Promise}\n\t\t */\n\t\tpromise = new Promise(then);\n\n\t\t/**\n\t\t * The full Deferred object, with {@link Promise} and {@link Resolver} parts\n\t\t * @class Deferred\n\t\t * @name Deferred\n\t\t */\n\t\tdeferred = {\n\t\t\tthen:     then, // DEPRECATED: use deferred.promise.then\n\t\t\tresolve:  promiseResolve,\n\t\t\treject:   promiseReject,\n\t\t\t// TODO: Consider renaming progress() to notify()\n\t\t\tprogress: promiseProgress,\n\n\t\t\tpromise:  promise,\n\n\t\t\tresolver: {\n\t\t\t\tresolve:  promiseResolve,\n\t\t\t\treject:   promiseReject,\n\t\t\t\tprogress: promiseProgress\n\t\t\t}\n\t\t};\n\n\t\thandlers = [];\n\t\tprogressHandlers = [];\n\n\t\t/**\n\t\t * Pre-resolution then() that adds the supplied callback, errback, and progback\n\t\t * functions to the registered listeners\n\t\t * @private\n\t\t *\n\t\t * @param {function?} [onFulfilled] resolution handler\n\t\t * @param {function?} [onRejected] rejection handler\n\t\t * @param {function?} [onProgress] progress handler\n\t\t */\n\t\t_then = function(onFulfilled, onRejected, onProgress) {\n\t\t\t// TODO: Promises/A+ check typeof onFulfilled, onRejected, onProgress\n\t\t\tvar deferred, progressHandler;\n\n\t\t\tdeferred = defer();\n\n\t\t\tprogressHandler = typeof onProgress === 'function'\n\t\t\t\t? function(update) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\t// Allow progress handler to transform progress event\n\t\t\t\t\t\tdeferred.progress(onProgress(update));\n\t\t\t\t\t} catch(e) {\n\t\t\t\t\t\t// Use caught value as progress\n\t\t\t\t\t\tdeferred.progress(e);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t: function(update) { deferred.progress(update); };\n\n\t\t\thandlers.push(function(promise) {\n\t\t\t\tpromise.then(onFulfilled, onRejected)\n\t\t\t\t\t.then(deferred.resolve, deferred.reject, progressHandler);\n\t\t\t});\n\n\t\t\tprogressHandlers.push(progressHandler);\n\n\t\t\treturn deferred.promise;\n\t\t};\n\n\t\t/**\n\t\t * Issue a progress event, notifying all progress listeners\n\t\t * @private\n\t\t * @param {*} update progress event payload to pass to all listeners\n\t\t */\n\t\t_progress = function(update) {\n\t\t\tprocessQueue(progressHandlers, update);\n\t\t\treturn update;\n\t\t};\n\n\t\t/**\n\t\t * Transition from pre-resolution state to post-resolution state, notifying\n\t\t * all listeners of the resolution or rejection\n\t\t * @private\n\t\t * @param {*} value the value of this deferred\n\t\t */\n\t\t_resolve = function(value) {\n\t\t\tvalue = resolve(value);\n\n\t\t\t// Replace _then with one that directly notifies with the result.\n\t\t\t_then = value.then;\n\t\t\t// Replace _resolve so that this Deferred can only be resolved once\n\t\t\t_resolve = resolve;\n\t\t\t// Make _progress a noop, to disallow progress for the resolved promise.\n\t\t\t_progress = noop;\n\n\t\t\t// Notify handlers\n\t\t\tprocessQueue(handlers, value);\n\n\t\t\t// Free progressHandlers array since we'll never issue progress events\n\t\t\tprogressHandlers = handlers = undef;\n\n\t\t\treturn value;\n\t\t};\n\n\t\treturn deferred;\n\n\t\t/**\n\t\t * Wrapper to allow _then to be replaced safely\n\t\t * @param {function?} [onFulfilled] resolution handler\n\t\t * @param {function?} [onRejected] rejection handler\n\t\t * @param {function?} [onProgress] progress handler\n\t\t * @return {Promise} new promise\n\t\t */\n\t\tfunction then(onFulfilled, onRejected, onProgress) {\n\t\t\t// TODO: Promises/A+ check typeof onFulfilled, onRejected, onProgress\n\t\t\treturn _then(onFulfilled, onRejected, onProgress);\n\t\t}\n\n\t\t/**\n\t\t * Wrapper to allow _resolve to be replaced\n\t\t */\n\t\tfunction promiseResolve(val) {\n\t\t\treturn _resolve(val);\n\t\t}\n\n\t\t/**\n\t\t * Wrapper to allow _reject to be replaced\n\t\t */\n\t\tfunction promiseReject(err) {\n\t\t\treturn _resolve(rejected(err));\n\t\t}\n\n\t\t/**\n\t\t * Wrapper to allow _progress to be replaced\n\t\t */\n\t\tfunction promiseProgress(update) {\n\t\t\treturn _progress(update);\n\t\t}\n\t}\n\n\t/**\n\t * Determines if promiseOrValue is a promise or not.  Uses the feature\n\t * test from http://wiki.commonjs.org/wiki/Promises/A to determine if\n\t * promiseOrValue is a promise.\n\t *\n\t * @param {*} promiseOrValue anything\n\t * @returns {boolean} true if promiseOrValue is a {@link Promise}\n\t */\n\tfunction isPromise(promiseOrValue) {\n\t\treturn promiseOrValue && typeof promiseOrValue.then === 'function';\n\t}\n\n\t/**\n\t * Initiates a competitive race, returning a promise that will resolve when\n\t * howMany of the supplied promisesOrValues have resolved, or will reject when\n\t * it becomes impossible for howMany to resolve, for example, when\n\t * (promisesOrValues.length - howMany) + 1 input promises reject.\n\t *\n\t * @param {Array} promisesOrValues array of anything, may contain a mix\n\t *      of promises and values\n\t * @param howMany {number} number of promisesOrValues to resolve\n\t * @param {function?} [onFulfilled] resolution handler\n\t * @param {function?} [onRejected] rejection handler\n\t * @param {function?} [onProgress] progress handler\n\t * @returns {Promise} promise that will resolve to an array of howMany values that\n\t * resolved first, or will reject with an array of (promisesOrValues.length - howMany) + 1\n\t * rejection reasons.\n\t */\n\tfunction some(promisesOrValues, howMany, onFulfilled, onRejected, onProgress) {\n\n\t\tcheckCallbacks(2, arguments);\n\n\t\treturn when(promisesOrValues, function(promisesOrValues) {\n\n\t\t\tvar toResolve, toReject, values, reasons, deferred, fulfillOne, rejectOne, progress, len, i;\n\n\t\t\tlen = promisesOrValues.length >>> 0;\n\n\t\t\ttoResolve = Math.max(0, Math.min(howMany, len));\n\t\t\tvalues = [];\n\n\t\t\ttoReject = (len - toResolve) + 1;\n\t\t\treasons = [];\n\n\t\t\tdeferred = defer();\n\n\t\t\t// No items in the input, resolve immediately\n\t\t\tif (!toResolve) {\n\t\t\t\tdeferred.resolve(values);\n\n\t\t\t} else {\n\t\t\t\tprogress = deferred.progress;\n\n\t\t\t\trejectOne = function(reason) {\n\t\t\t\t\treasons.push(reason);\n\t\t\t\t\tif(!--toReject) {\n\t\t\t\t\t\tfulfillOne = rejectOne = noop;\n\t\t\t\t\t\tdeferred.reject(reasons);\n\t\t\t\t\t}\n\t\t\t\t};\n\n\t\t\t\tfulfillOne = function(val) {\n\t\t\t\t\t// This orders the values based on promise resolution order\n\t\t\t\t\t// Another strategy would be to use the original position of\n\t\t\t\t\t// the corresponding promise.\n\t\t\t\t\tvalues.push(val);\n\n\t\t\t\t\tif (!--toResolve) {\n\t\t\t\t\t\tfulfillOne = rejectOne = noop;\n\t\t\t\t\t\tdeferred.resolve(values);\n\t\t\t\t\t}\n\t\t\t\t};\n\n\t\t\t\tfor(i = 0; i < len; ++i) {\n\t\t\t\t\tif(i in promisesOrValues) {\n\t\t\t\t\t\twhen(promisesOrValues[i], fulfiller, rejecter, progress);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn deferred.then(onFulfilled, onRejected, onProgress);\n\n\t\t\tfunction rejecter(reason) {\n\t\t\t\trejectOne(reason);\n\t\t\t}\n\n\t\t\tfunction fulfiller(val) {\n\t\t\t\tfulfillOne(val);\n\t\t\t}\n\n\t\t});\n\t}\n\n\t/**\n\t * Initiates a competitive race, returning a promise that will resolve when\n\t * any one of the supplied promisesOrValues has resolved or will reject when\n\t * *all* promisesOrValues have rejected.\n\t *\n\t * @param {Array|Promise} promisesOrValues array of anything, may contain a mix\n\t *      of {@link Promise}s and values\n\t * @param {function?} [onFulfilled] resolution handler\n\t * @param {function?} [onRejected] rejection handler\n\t * @param {function?} [onProgress] progress handler\n\t * @returns {Promise} promise that will resolve to the value that resolved first, or\n\t * will reject with an array of all rejected inputs.\n\t */\n\tfunction any(promisesOrValues, onFulfilled, onRejected, onProgress) {\n\n\t\tfunction unwrapSingleResult(val) {\n\t\t\treturn onFulfilled ? onFulfilled(val[0]) : val[0];\n\t\t}\n\n\t\treturn some(promisesOrValues, 1, unwrapSingleResult, onRejected, onProgress);\n\t}\n\n\t/**\n\t * Return a promise that will resolve only once all the supplied promisesOrValues\n\t * have resolved. The resolution value of the returned promise will be an array\n\t * containing the resolution values of each of the promisesOrValues.\n\t * @memberOf when\n\t *\n\t * @param {Array|Promise} promisesOrValues array of anything, may contain a mix\n\t *      of {@link Promise}s and values\n\t * @param {function?} [onFulfilled] resolution handler\n\t * @param {function?} [onRejected] rejection handler\n\t * @param {function?} [onProgress] progress handler\n\t * @returns {Promise}\n\t */\n\tfunction all(promisesOrValues, onFulfilled, onRejected, onProgress) {\n\t\tcheckCallbacks(1, arguments);\n\t\treturn map(promisesOrValues, identity).then(onFulfilled, onRejected, onProgress);\n\t}\n\n\t/**\n\t * Joins multiple promises into a single returned promise.\n\t * @return {Promise} a promise that will fulfill when *all* the input promises\n\t * have fulfilled, or will reject when *any one* of the input promises rejects.\n\t */\n\tfunction join(/* ...promises */) {\n\t\treturn map(arguments, identity);\n\t}\n\n\t/**\n\t * Traditional map function, similar to `Array.prototype.map()`, but allows\n\t * input to contain {@link Promise}s and/or values, and mapFunc may return\n\t * either a value or a {@link Promise}\n\t *\n\t * @param {Array|Promise} promise array of anything, may contain a mix\n\t *      of {@link Promise}s and values\n\t * @param {function} mapFunc mapping function mapFunc(value) which may return\n\t *      either a {@link Promise} or value\n\t * @returns {Promise} a {@link Promise} that will resolve to an array containing\n\t *      the mapped output values.\n\t */\n\tfunction map(promise, mapFunc) {\n\t\treturn when(promise, function(array) {\n\t\t\tvar results, len, toResolve, resolve, i, d;\n\n\t\t\t// Since we know the resulting length, we can preallocate the results\n\t\t\t// array to avoid array expansions.\n\t\t\ttoResolve = len = array.length >>> 0;\n\t\t\tresults = [];\n\t\t\td = defer();\n\n\t\t\tif(!toResolve) {\n\t\t\t\td.resolve(results);\n\t\t\t} else {\n\n\t\t\t\tresolve = function resolveOne(item, i) {\n\t\t\t\t\twhen(item, mapFunc).then(function(mapped) {\n\t\t\t\t\t\tresults[i] = mapped;\n\n\t\t\t\t\t\tif(!--toResolve) {\n\t\t\t\t\t\t\td.resolve(results);\n\t\t\t\t\t\t}\n\t\t\t\t\t}, d.reject);\n\t\t\t\t};\n\n\t\t\t\t// Since mapFunc may be async, get all invocations of it into flight\n\t\t\t\tfor(i = 0; i < len; i++) {\n\t\t\t\t\tif(i in array) {\n\t\t\t\t\t\tresolve(array[i], i);\n\t\t\t\t\t} else {\n\t\t\t\t\t\t--toResolve;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn d.promise;\n\n\t\t});\n\t}\n\n\t/**\n\t * Traditional reduce function, similar to `Array.prototype.reduce()`, but\n\t * input may contain promises and/or values, and reduceFunc\n\t * may return either a value or a promise, *and* initialValue may\n\t * be a promise for the starting value.\n\t *\n\t * @param {Array|Promise} promise array or promise for an array of anything,\n\t *      may contain a mix of promises and values.\n\t * @param {function} reduceFunc reduce function reduce(currentValue, nextValue, index, total),\n\t *      where total is the total number of items being reduced, and will be the same\n\t *      in each call to reduceFunc.\n\t * @returns {Promise} that will resolve to the final reduced value\n\t */\n\tfunction reduce(promise, reduceFunc /*, initialValue */) {\n\t\tvar args = slice.call(arguments, 1);\n\n\t\treturn when(promise, function(array) {\n\t\t\tvar total;\n\n\t\t\ttotal = array.length;\n\n\t\t\t// Wrap the supplied reduceFunc with one that handles promises and then\n\t\t\t// delegates to the supplied.\n\t\t\targs[0] = function (current, val, i) {\n\t\t\t\treturn when(current, function (c) {\n\t\t\t\t\treturn when(val, function (value) {\n\t\t\t\t\t\treturn reduceFunc(c, value, i, total);\n\t\t\t\t\t});\n\t\t\t\t});\n\t\t\t};\n\n\t\t\treturn reduceArray.apply(array, args);\n\t\t});\n\t}\n\n\t/**\n\t * Ensure that resolution of promiseOrValue will trigger resolver with the\n\t * value or reason of promiseOrValue, or instead with resolveValue if it is provided.\n\t *\n\t * @param promiseOrValue\n\t * @param {Object} resolver\n\t * @param {function} resolver.resolve\n\t * @param {function} resolver.reject\n\t * @param {*} [resolveValue]\n\t * @returns {Promise}\n\t */\n\tfunction chain(promiseOrValue, resolver, resolveValue) {\n\t\tvar useResolveValue = arguments.length > 2;\n\n\t\treturn when(promiseOrValue,\n\t\t\tfunction(val) {\n\t\t\t\tval = useResolveValue ? resolveValue : val;\n\t\t\t\tresolver.resolve(val);\n\t\t\t\treturn val;\n\t\t\t},\n\t\t\tfunction(reason) {\n\t\t\t\tresolver.reject(reason);\n\t\t\t\treturn rejected(reason);\n\t\t\t},\n\t\t\tresolver.progress\n\t\t);\n\t}\n\n\t//\n\t// Utility functions\n\t//\n\n\t/**\n\t * Apply all functions in queue to value\n\t * @param {Array} queue array of functions to execute\n\t * @param {*} value argument passed to each function\n\t */\n\tfunction processQueue(queue, value) {\n\t\tvar handler, i = 0;\n\n\t\twhile (handler = queue[i++]) {\n\t\t\thandler(value);\n\t\t}\n\t}\n\n\t/**\n\t * Helper that checks arrayOfCallbacks to ensure that each element is either\n\t * a function, or null or undefined.\n\t * @private\n\t * @param {number} start index at which to start checking items in arrayOfCallbacks\n\t * @param {Array} arrayOfCallbacks array to check\n\t * @throws {Error} if any element of arrayOfCallbacks is something other than\n\t * a functions, null, or undefined.\n\t */\n\tfunction checkCallbacks(start, arrayOfCallbacks) {\n\t\t// TODO: Promises/A+ update type checking and docs\n\t\tvar arg, i = arrayOfCallbacks.length;\n\n\t\twhile(i > start) {\n\t\t\targ = arrayOfCallbacks[--i];\n\n\t\t\tif (arg != null && typeof arg != 'function') {\n\t\t\t\tthrow new Error('arg '+i+' must be a function');\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * No-Op function used in method replacement\n\t * @private\n\t */\n\tfunction noop() {}\n\n\tslice = [].slice;\n\n\t// ES5 reduce implementation if native not available\n\t// See: http://es5.github.com/#x15.4.4.21 as there are many\n\t// specifics and edge cases.\n\treduceArray = [].reduce ||\n\t\tfunction(reduceFunc /*, initialValue */) {\n\t\t\t/*jshint maxcomplexity: 7*/\n\n\t\t\t// ES5 dictates that reduce.length === 1\n\n\t\t\t// This implementation deviates from ES5 spec in the following ways:\n\t\t\t// 1. It does not check if reduceFunc is a Callable\n\n\t\t\tvar arr, args, reduced, len, i;\n\n\t\t\ti = 0;\n\t\t\t// This generates a jshint warning, despite being valid\n\t\t\t// \"Missing 'new' prefix when invoking a constructor.\"\n\t\t\t// See https://github.com/jshint/jshint/issues/392\n\t\t\tarr = Object(this);\n\t\t\tlen = arr.length >>> 0;\n\t\t\targs = arguments;\n\n\t\t\t// If no initialValue, use first item of array (we know length !== 0 here)\n\t\t\t// and adjust i to start at second item\n\t\t\tif(args.length <= 1) {\n\t\t\t\t// Skip to the first real element in the array\n\t\t\t\tfor(;;) {\n\t\t\t\t\tif(i in arr) {\n\t\t\t\t\t\treduced = arr[i++];\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\t// If we reached the end of the array without finding any real\n\t\t\t\t\t// elements, it's a TypeError\n\t\t\t\t\tif(++i >= len) {\n\t\t\t\t\t\tthrow new TypeError();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// If initialValue provided, use it\n\t\t\t\treduced = args[1];\n\t\t\t}\n\n\t\t\t// Do the actual reduce\n\t\t\tfor(;i < len; ++i) {\n\t\t\t\t// Skip holes\n\t\t\t\tif(i in arr) {\n\t\t\t\t\treduced = reduceFunc(reduced, arr[i], i, arr);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn reduced;\n\t\t};\n\n\tfunction identity(x) {\n\t\treturn x;\n\t}\n\n\treturn when;\n});\n})(function (factory) { (module.exports = factory())\n\t\t;\n\t}\n\t// Boilerplate for AMD, Node, and browser global\n);\n});\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QUFDQTs7QUFFQTtBQUNBLENBQUM7QUFDRCxDQUFDLHVCQUF1QjtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRTBCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdnVlMy13ZWJwYWNrNS8uL25vZGVfbW9kdWxlcy9jZXNpdW0vU291cmNlL1RoaXJkUGFydHkvd2hlbi5qcz9kOWY1Il0sInNvdXJjZXNDb250ZW50IjpbIi8qIFRoaXMgZmlsZSBpcyBhdXRvbWF0aWNhbGx5IHJlYnVpbHQgYnkgdGhlIENlc2l1bSBidWlsZCBwcm9jZXNzLiAqL1xuaW1wb3J0IHsgYyBhcyBjcmVhdGVDb21tb25qc01vZHVsZSB9IGZyb20gJy4vX2NvbW1vbmpzSGVscGVycy0zYWFlMTAzMi5qcyc7XG5cbnZhciB3aGVuID0gY3JlYXRlQ29tbW9uanNNb2R1bGUoZnVuY3Rpb24gKG1vZHVsZSwgZXhwb3J0cykge1xuLyoqIEBsaWNlbnNlIE1JVCBMaWNlbnNlIChjKSBjb3B5cmlnaHQgQiBDYXZhbGllciAmIEogSGFubiAqL1xuXG4vKipcbiAqIEEgbGlnaHR3ZWlnaHQgQ29tbW9uSlMgUHJvbWlzZXMvQSBhbmQgd2hlbigpIGltcGxlbWVudGF0aW9uXG4gKiB3aGVuIGlzIHBhcnQgb2YgdGhlIGN1am8uanMgZmFtaWx5IG9mIGxpYnJhcmllcyAoaHR0cDovL2N1am9qcy5jb20vKVxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZSBhdDpcbiAqIGh0dHA6Ly93d3cub3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvbWl0LWxpY2Vuc2UucGhwXG4gKlxuICogQHZlcnNpb24gMS43LjFcbiAqL1xuXG4oZnVuY3Rpb24oZGVmaW5lKSB7ZGVmaW5lKGZ1bmN0aW9uICgpIHtcblx0dmFyIHJlZHVjZUFycmF5LCBzbGljZSwgdW5kZWY7XG5cblx0Ly9cblx0Ly8gUHVibGljIEFQSVxuXHQvL1xuXG5cdHdoZW4uZGVmZXIgICAgID0gZGVmZXI7ICAgICAvLyBDcmVhdGUgYSBkZWZlcnJlZFxuXHR3aGVuLnJlc29sdmUgICA9IHJlc29sdmU7ICAgLy8gQ3JlYXRlIGEgcmVzb2x2ZWQgcHJvbWlzZVxuXHR3aGVuLnJlamVjdCAgICA9IHJlamVjdDsgICAgLy8gQ3JlYXRlIGEgcmVqZWN0ZWQgcHJvbWlzZVxuXG5cdHdoZW4uam9pbiAgICAgID0gam9pbjsgICAgICAvLyBKb2luIDIgb3IgbW9yZSBwcm9taXNlc1xuXG5cdHdoZW4uYWxsICAgICAgID0gYWxsOyAgICAgICAvLyBSZXNvbHZlIGEgbGlzdCBvZiBwcm9taXNlc1xuXHR3aGVuLm1hcCAgICAgICA9IG1hcDsgICAgICAgLy8gQXJyYXkubWFwKCkgZm9yIHByb21pc2VzXG5cdHdoZW4ucmVkdWNlICAgID0gcmVkdWNlOyAgICAvLyBBcnJheS5yZWR1Y2UoKSBmb3IgcHJvbWlzZXNcblxuXHR3aGVuLmFueSAgICAgICA9IGFueTsgICAgICAgLy8gT25lLXdpbm5lciByYWNlXG5cdHdoZW4uc29tZSAgICAgID0gc29tZTsgICAgICAvLyBNdWx0aS13aW5uZXIgcmFjZVxuXG5cdHdoZW4uY2hhaW4gICAgID0gY2hhaW47ICAgICAvLyBNYWtlIGEgcHJvbWlzZSB0cmlnZ2VyIGFub3RoZXIgcmVzb2x2ZXJcblxuXHR3aGVuLmlzUHJvbWlzZSA9IGlzUHJvbWlzZTsgLy8gRGV0ZXJtaW5lIGlmIGEgdGhpbmcgaXMgYSBwcm9taXNlXG5cblx0LyoqXG5cdCAqIFJlZ2lzdGVyIGFuIG9ic2VydmVyIGZvciBhIHByb21pc2Ugb3IgaW1tZWRpYXRlIHZhbHVlLlxuXHQgKlxuXHQgKiBAcGFyYW0geyp9IHByb21pc2VPclZhbHVlXG5cdCAqIEBwYXJhbSB7ZnVuY3Rpb24/fSBbb25GdWxmaWxsZWRdIGNhbGxiYWNrIHRvIGJlIGNhbGxlZCB3aGVuIHByb21pc2VPclZhbHVlIGlzXG5cdCAqICAgc3VjY2Vzc2Z1bGx5IGZ1bGZpbGxlZC4gIElmIHByb21pc2VPclZhbHVlIGlzIGFuIGltbWVkaWF0ZSB2YWx1ZSwgY2FsbGJhY2tcblx0ICogICB3aWxsIGJlIGludm9rZWQgaW1tZWRpYXRlbHkuXG5cdCAqIEBwYXJhbSB7ZnVuY3Rpb24/fSBbb25SZWplY3RlZF0gY2FsbGJhY2sgdG8gYmUgY2FsbGVkIHdoZW4gcHJvbWlzZU9yVmFsdWUgaXNcblx0ICogICByZWplY3RlZC5cblx0ICogQHBhcmFtIHtmdW5jdGlvbj99IFtvblByb2dyZXNzXSBjYWxsYmFjayB0byBiZSBjYWxsZWQgd2hlbiBwcm9ncmVzcyB1cGRhdGVzXG5cdCAqICAgYXJlIGlzc3VlZCBmb3IgcHJvbWlzZU9yVmFsdWUuXG5cdCAqIEByZXR1cm5zIHtQcm9taXNlfSBhIG5ldyB7QGxpbmsgUHJvbWlzZX0gdGhhdCB3aWxsIGNvbXBsZXRlIHdpdGggdGhlIHJldHVyblxuXHQgKiAgIHZhbHVlIG9mIGNhbGxiYWNrIG9yIGVycmJhY2sgb3IgdGhlIGNvbXBsZXRpb24gdmFsdWUgb2YgcHJvbWlzZU9yVmFsdWUgaWZcblx0ICogICBjYWxsYmFjayBhbmQvb3IgZXJyYmFjayBpcyBub3Qgc3VwcGxpZWQuXG5cdCAqL1xuXHRmdW5jdGlvbiB3aGVuKHByb21pc2VPclZhbHVlLCBvbkZ1bGZpbGxlZCwgb25SZWplY3RlZCwgb25Qcm9ncmVzcykge1xuXHRcdC8vIEdldCBhIHRydXN0ZWQgcHJvbWlzZSBmb3IgdGhlIGlucHV0IHByb21pc2VPclZhbHVlLCBhbmQgdGhlblxuXHRcdC8vIHJlZ2lzdGVyIHByb21pc2UgaGFuZGxlcnNcblx0XHRyZXR1cm4gcmVzb2x2ZShwcm9taXNlT3JWYWx1ZSkudGhlbihvbkZ1bGZpbGxlZCwgb25SZWplY3RlZCwgb25Qcm9ncmVzcyk7XG5cdH1cblxuXHQvKipcblx0ICogUmV0dXJucyBwcm9taXNlT3JWYWx1ZSBpZiBwcm9taXNlT3JWYWx1ZSBpcyBhIHtAbGluayBQcm9taXNlfSwgYSBuZXcgUHJvbWlzZSBpZlxuXHQgKiBwcm9taXNlT3JWYWx1ZSBpcyBhIGZvcmVpZ24gcHJvbWlzZSwgb3IgYSBuZXcsIGFscmVhZHktZnVsZmlsbGVkIHtAbGluayBQcm9taXNlfVxuXHQgKiB3aG9zZSB2YWx1ZSBpcyBwcm9taXNlT3JWYWx1ZSBpZiBwcm9taXNlT3JWYWx1ZSBpcyBhbiBpbW1lZGlhdGUgdmFsdWUuXG5cdCAqXG5cdCAqIEBwYXJhbSB7Kn0gcHJvbWlzZU9yVmFsdWVcblx0ICogQHJldHVybnMgR3VhcmFudGVlZCB0byByZXR1cm4gYSB0cnVzdGVkIFByb21pc2UuICBJZiBwcm9taXNlT3JWYWx1ZSBpcyBhIHdoZW4uanMge0BsaW5rIFByb21pc2V9XG5cdCAqICAgcmV0dXJucyBwcm9taXNlT3JWYWx1ZSwgb3RoZXJ3aXNlLCByZXR1cm5zIGEgbmV3LCBhbHJlYWR5LXJlc29sdmVkLCB3aGVuLmpzIHtAbGluayBQcm9taXNlfVxuXHQgKiAgIHdob3NlIHJlc29sdXRpb24gdmFsdWUgaXM6XG5cdCAqICAgKiB0aGUgcmVzb2x1dGlvbiB2YWx1ZSBvZiBwcm9taXNlT3JWYWx1ZSBpZiBpdCdzIGEgZm9yZWlnbiBwcm9taXNlLCBvclxuXHQgKiAgICogcHJvbWlzZU9yVmFsdWUgaWYgaXQncyBhIHZhbHVlXG5cdCAqL1xuXHRmdW5jdGlvbiByZXNvbHZlKHByb21pc2VPclZhbHVlKSB7XG5cdFx0dmFyIHByb21pc2UsIGRlZmVycmVkO1xuXG5cdFx0aWYocHJvbWlzZU9yVmFsdWUgaW5zdGFuY2VvZiBQcm9taXNlKSB7XG5cdFx0XHQvLyBJdCdzIGEgd2hlbi5qcyBwcm9taXNlLCBzbyB3ZSB0cnVzdCBpdFxuXHRcdFx0cHJvbWlzZSA9IHByb21pc2VPclZhbHVlO1xuXG5cdFx0fSBlbHNlIHtcblx0XHRcdC8vIEl0J3Mgbm90IGEgd2hlbi5qcyBwcm9taXNlLiBTZWUgaWYgaXQncyBhIGZvcmVpZ24gcHJvbWlzZSBvciBhIHZhbHVlLlxuXHRcdFx0aWYoaXNQcm9taXNlKHByb21pc2VPclZhbHVlKSkge1xuXHRcdFx0XHQvLyBJdCdzIGEgdGhlbmFibGUsIGJ1dCB3ZSBkb24ndCBrbm93IHdoZXJlIGl0IGNhbWUgZnJvbSwgc28gZG9uJ3QgdHJ1c3Rcblx0XHRcdFx0Ly8gaXRzIGltcGxlbWVudGF0aW9uIGVudGlyZWx5LiAgSW50cm9kdWNlIGEgdHJ1c3RlZCBtaWRkbGVtYW4gd2hlbi5qcyBwcm9taXNlXG5cdFx0XHRcdGRlZmVycmVkID0gZGVmZXIoKTtcblxuXHRcdFx0XHQvLyBJTVBPUlRBTlQ6IFRoaXMgaXMgdGhlIG9ubHkgcGxhY2Ugd2hlbi5qcyBzaG91bGQgZXZlciBjYWxsIC50aGVuKCkgb24gYW5cblx0XHRcdFx0Ly8gdW50cnVzdGVkIHByb21pc2UuIERvbid0IGV4cG9zZSB0aGUgcmV0dXJuIHZhbHVlIHRvIHRoZSB1bnRydXN0ZWQgcHJvbWlzZVxuXHRcdFx0XHRwcm9taXNlT3JWYWx1ZS50aGVuKFxuXHRcdFx0XHRcdGZ1bmN0aW9uKHZhbHVlKSAgeyBkZWZlcnJlZC5yZXNvbHZlKHZhbHVlKTsgfSxcblx0XHRcdFx0XHRmdW5jdGlvbihyZWFzb24pIHsgZGVmZXJyZWQucmVqZWN0KHJlYXNvbik7IH0sXG5cdFx0XHRcdFx0ZnVuY3Rpb24odXBkYXRlKSB7IGRlZmVycmVkLnByb2dyZXNzKHVwZGF0ZSk7IH1cblx0XHRcdFx0KTtcblxuXHRcdFx0XHRwcm9taXNlID0gZGVmZXJyZWQucHJvbWlzZTtcblxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Ly8gSXQncyBhIHZhbHVlLCBub3QgYSBwcm9taXNlLiAgQ3JlYXRlIGEgcmVzb2x2ZWQgcHJvbWlzZSBmb3IgaXQuXG5cdFx0XHRcdHByb21pc2UgPSBmdWxmaWxsZWQocHJvbWlzZU9yVmFsdWUpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiBwcm9taXNlO1xuXHR9XG5cblx0LyoqXG5cdCAqIFJldHVybnMgYSByZWplY3RlZCBwcm9taXNlIGZvciB0aGUgc3VwcGxpZWQgcHJvbWlzZU9yVmFsdWUuICBUaGUgcmV0dXJuZWRcblx0ICogcHJvbWlzZSB3aWxsIGJlIHJlamVjdGVkIHdpdGg6XG5cdCAqIC0gcHJvbWlzZU9yVmFsdWUsIGlmIGl0IGlzIGEgdmFsdWUsIG9yXG5cdCAqIC0gaWYgcHJvbWlzZU9yVmFsdWUgaXMgYSBwcm9taXNlXG5cdCAqICAgLSBwcm9taXNlT3JWYWx1ZSdzIHZhbHVlIGFmdGVyIGl0IGlzIGZ1bGZpbGxlZFxuXHQgKiAgIC0gcHJvbWlzZU9yVmFsdWUncyByZWFzb24gYWZ0ZXIgaXQgaXMgcmVqZWN0ZWRcblx0ICogQHBhcmFtIHsqfSBwcm9taXNlT3JWYWx1ZSB0aGUgcmVqZWN0ZWQgdmFsdWUgb2YgdGhlIHJldHVybmVkIHtAbGluayBQcm9taXNlfVxuXHQgKiBAcmV0dXJuIHtQcm9taXNlfSByZWplY3RlZCB7QGxpbmsgUHJvbWlzZX1cblx0ICovXG5cdGZ1bmN0aW9uIHJlamVjdChwcm9taXNlT3JWYWx1ZSkge1xuXHRcdHJldHVybiB3aGVuKHByb21pc2VPclZhbHVlLCByZWplY3RlZCk7XG5cdH1cblxuXHQvKipcblx0ICogVHJ1c3RlZCBQcm9taXNlIGNvbnN0cnVjdG9yLiAgQSBQcm9taXNlIGNyZWF0ZWQgZnJvbSB0aGlzIGNvbnN0cnVjdG9yIGlzXG5cdCAqIGEgdHJ1c3RlZCB3aGVuLmpzIHByb21pc2UuICBBbnkgb3RoZXIgZHVjay10eXBlZCBwcm9taXNlIGlzIGNvbnNpZGVyZWRcblx0ICogdW50cnVzdGVkLlxuXHQgKiBAY29uc3RydWN0b3Jcblx0ICogQG5hbWUgUHJvbWlzZVxuXHQgKi9cblx0ZnVuY3Rpb24gUHJvbWlzZSh0aGVuKSB7XG5cdFx0dGhpcy50aGVuID0gdGhlbjtcblx0fVxuXG5cdFByb21pc2UucHJvdG90eXBlID0ge1xuXHRcdC8qKlxuXHRcdCAqIFJlZ2lzdGVyIGEgY2FsbGJhY2sgdGhhdCB3aWxsIGJlIGNhbGxlZCB3aGVuIGEgcHJvbWlzZSBpc1xuXHRcdCAqIGZ1bGZpbGxlZCBvciByZWplY3RlZC4gIE9wdGlvbmFsbHkgYWxzbyByZWdpc3RlciBhIHByb2dyZXNzIGhhbmRsZXIuXG5cdFx0ICogU2hvcnRjdXQgZm9yIC50aGVuKG9uRnVsZmlsbGVkT3JSZWplY3RlZCwgb25GdWxmaWxsZWRPclJlamVjdGVkLCBvblByb2dyZXNzKVxuXHRcdCAqIEBwYXJhbSB7ZnVuY3Rpb24/fSBbb25GdWxmaWxsZWRPclJlamVjdGVkXVxuXHRcdCAqIEBwYXJhbSB7ZnVuY3Rpb24/fSBbb25Qcm9ncmVzc11cblx0XHQgKiBAcmV0dXJuIHtQcm9taXNlfVxuXHRcdCAqL1xuXHRcdGFsd2F5czogZnVuY3Rpb24ob25GdWxmaWxsZWRPclJlamVjdGVkLCBvblByb2dyZXNzKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy50aGVuKG9uRnVsZmlsbGVkT3JSZWplY3RlZCwgb25GdWxmaWxsZWRPclJlamVjdGVkLCBvblByb2dyZXNzKTtcblx0XHR9LFxuXG5cdFx0LyoqXG5cdFx0ICogUmVnaXN0ZXIgYSByZWplY3Rpb24gaGFuZGxlci4gIFNob3J0Y3V0IGZvciAudGhlbih1bmRlZmluZWQsIG9uUmVqZWN0ZWQpXG5cdFx0ICogQHBhcmFtIHtmdW5jdGlvbj99IG9uUmVqZWN0ZWRcblx0XHQgKiBAcmV0dXJuIHtQcm9taXNlfVxuXHRcdCAqL1xuXHRcdG90aGVyd2lzZTogZnVuY3Rpb24ob25SZWplY3RlZCkge1xuXHRcdFx0cmV0dXJuIHRoaXMudGhlbih1bmRlZiwgb25SZWplY3RlZCk7XG5cdFx0fSxcblxuXHRcdC8qKlxuXHRcdCAqIFNob3J0Y3V0IGZvciAudGhlbihmdW5jdGlvbigpIHsgcmV0dXJuIHZhbHVlOyB9KVxuXHRcdCAqIEBwYXJhbSAgeyp9IHZhbHVlXG5cdFx0ICogQHJldHVybiB7UHJvbWlzZX0gYSBwcm9taXNlIHRoYXQ6XG5cdFx0ICogIC0gaXMgZnVsZmlsbGVkIGlmIHZhbHVlIGlzIG5vdCBhIHByb21pc2UsIG9yXG5cdFx0ICogIC0gaWYgdmFsdWUgaXMgYSBwcm9taXNlLCB3aWxsIGZ1bGZpbGwgd2l0aCBpdHMgdmFsdWUsIG9yIHJlamVjdFxuXHRcdCAqICAgIHdpdGggaXRzIHJlYXNvbi5cblx0XHQgKi9cblx0XHR5aWVsZDogZnVuY3Rpb24odmFsdWUpIHtcblx0XHRcdHJldHVybiB0aGlzLnRoZW4oZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHJldHVybiB2YWx1ZTtcblx0XHRcdH0pO1xuXHRcdH0sXG5cblx0XHQvKipcblx0XHQgKiBBc3N1bWVzIHRoYXQgdGhpcyBwcm9taXNlIHdpbGwgZnVsZmlsbCB3aXRoIGFuIGFycmF5LCBhbmQgYXJyYW5nZXNcblx0XHQgKiBmb3IgdGhlIG9uRnVsZmlsbGVkIHRvIGJlIGNhbGxlZCB3aXRoIHRoZSBhcnJheSBhcyBpdHMgYXJndW1lbnQgbGlzdFxuXHRcdCAqIGkuZS4gb25GdWxmaWxsZWQuc3ByZWFkKHVuZGVmaW5lZCwgYXJyYXkpLlxuXHRcdCAqIEBwYXJhbSB7ZnVuY3Rpb259IG9uRnVsZmlsbGVkIGZ1bmN0aW9uIHRvIHJlY2VpdmUgc3ByZWFkIGFyZ3VtZW50c1xuXHRcdCAqIEByZXR1cm4ge1Byb21pc2V9XG5cdFx0ICovXG5cdFx0c3ByZWFkOiBmdW5jdGlvbihvbkZ1bGZpbGxlZCkge1xuXHRcdFx0cmV0dXJuIHRoaXMudGhlbihmdW5jdGlvbihhcnJheSkge1xuXHRcdFx0XHQvLyBhcnJheSBtYXkgY29udGFpbiBwcm9taXNlcywgc28gcmVzb2x2ZSBpdHMgY29udGVudHMuXG5cdFx0XHRcdHJldHVybiBhbGwoYXJyYXksIGZ1bmN0aW9uKGFycmF5KSB7XG5cdFx0XHRcdFx0cmV0dXJuIG9uRnVsZmlsbGVkLmFwcGx5KHVuZGVmLCBhcnJheSk7XG5cdFx0XHRcdH0pO1xuXHRcdFx0fSk7XG5cdFx0fVxuXHR9O1xuXG5cdC8qKlxuXHQgKiBDcmVhdGUgYW4gYWxyZWFkeS1yZXNvbHZlZCBwcm9taXNlIGZvciB0aGUgc3VwcGxpZWQgdmFsdWVcblx0ICogQHByaXZhdGVcblx0ICpcblx0ICogQHBhcmFtIHsqfSB2YWx1ZVxuXHQgKiBAcmV0dXJuIHtQcm9taXNlfSBmdWxmaWxsZWQgcHJvbWlzZVxuXHQgKi9cblx0ZnVuY3Rpb24gZnVsZmlsbGVkKHZhbHVlKSB7XG5cdFx0dmFyIHAgPSBuZXcgUHJvbWlzZShmdW5jdGlvbihvbkZ1bGZpbGxlZCkge1xuXHRcdFx0Ly8gVE9ETzogUHJvbWlzZXMvQSsgY2hlY2sgdHlwZW9mIG9uRnVsZmlsbGVkXG5cdFx0XHR0cnkge1xuXHRcdFx0XHRyZXR1cm4gcmVzb2x2ZShvbkZ1bGZpbGxlZCA/IG9uRnVsZmlsbGVkKHZhbHVlKSA6IHZhbHVlKTtcblx0XHRcdH0gY2F0Y2goZSkge1xuXHRcdFx0XHRyZXR1cm4gcmVqZWN0ZWQoZSk7XG5cdFx0XHR9XG5cdFx0fSk7XG5cblx0XHRyZXR1cm4gcDtcblx0fVxuXG5cdC8qKlxuXHQgKiBDcmVhdGUgYW4gYWxyZWFkeS1yZWplY3RlZCB7QGxpbmsgUHJvbWlzZX0gd2l0aCB0aGUgc3VwcGxpZWRcblx0ICogcmVqZWN0aW9uIHJlYXNvbi5cblx0ICogQHByaXZhdGVcblx0ICpcblx0ICogQHBhcmFtIHsqfSByZWFzb25cblx0ICogQHJldHVybiB7UHJvbWlzZX0gcmVqZWN0ZWQgcHJvbWlzZVxuXHQgKi9cblx0ZnVuY3Rpb24gcmVqZWN0ZWQocmVhc29uKSB7XG5cdFx0dmFyIHAgPSBuZXcgUHJvbWlzZShmdW5jdGlvbihfLCBvblJlamVjdGVkKSB7XG5cdFx0XHQvLyBUT0RPOiBQcm9taXNlcy9BKyBjaGVjayB0eXBlb2Ygb25SZWplY3RlZFxuXHRcdFx0dHJ5IHtcblx0XHRcdFx0cmV0dXJuIG9uUmVqZWN0ZWQgPyByZXNvbHZlKG9uUmVqZWN0ZWQocmVhc29uKSkgOiByZWplY3RlZChyZWFzb24pO1xuXHRcdFx0fSBjYXRjaChlKSB7XG5cdFx0XHRcdHJldHVybiByZWplY3RlZChlKTtcblx0XHRcdH1cblx0XHR9KTtcblxuXHRcdHJldHVybiBwO1xuXHR9XG5cblx0LyoqXG5cdCAqIENyZWF0ZXMgYSBuZXcsIERlZmVycmVkIHdpdGggZnVsbHkgaXNvbGF0ZWQgcmVzb2x2ZXIgYW5kIHByb21pc2UgcGFydHMsXG5cdCAqIGVpdGhlciBvciBib3RoIG9mIHdoaWNoIG1heSBiZSBnaXZlbiBvdXQgc2FmZWx5IHRvIGNvbnN1bWVycy5cblx0ICogVGhlIERlZmVycmVkIGl0c2VsZiBoYXMgdGhlIGZ1bGwgQVBJOiByZXNvbHZlLCByZWplY3QsIHByb2dyZXNzLCBhbmRcblx0ICogdGhlbi4gVGhlIHJlc29sdmVyIGhhcyByZXNvbHZlLCByZWplY3QsIGFuZCBwcm9ncmVzcy4gIFRoZSBwcm9taXNlXG5cdCAqIG9ubHkgaGFzIHRoZW4uXG5cdCAqXG5cdCAqIEByZXR1cm4ge0RlZmVycmVkfVxuXHQgKi9cblx0ZnVuY3Rpb24gZGVmZXIoKSB7XG5cdFx0dmFyIGRlZmVycmVkLCBwcm9taXNlLCBoYW5kbGVycywgcHJvZ3Jlc3NIYW5kbGVycyxcblx0XHRcdF90aGVuLCBfcHJvZ3Jlc3MsIF9yZXNvbHZlO1xuXG5cdFx0LyoqXG5cdFx0ICogVGhlIHByb21pc2UgZm9yIHRoZSBuZXcgZGVmZXJyZWRcblx0XHQgKiBAdHlwZSB7UHJvbWlzZX1cblx0XHQgKi9cblx0XHRwcm9taXNlID0gbmV3IFByb21pc2UodGhlbik7XG5cblx0XHQvKipcblx0XHQgKiBUaGUgZnVsbCBEZWZlcnJlZCBvYmplY3QsIHdpdGgge0BsaW5rIFByb21pc2V9IGFuZCB7QGxpbmsgUmVzb2x2ZXJ9IHBhcnRzXG5cdFx0ICogQGNsYXNzIERlZmVycmVkXG5cdFx0ICogQG5hbWUgRGVmZXJyZWRcblx0XHQgKi9cblx0XHRkZWZlcnJlZCA9IHtcblx0XHRcdHRoZW46ICAgICB0aGVuLCAvLyBERVBSRUNBVEVEOiB1c2UgZGVmZXJyZWQucHJvbWlzZS50aGVuXG5cdFx0XHRyZXNvbHZlOiAgcHJvbWlzZVJlc29sdmUsXG5cdFx0XHRyZWplY3Q6ICAgcHJvbWlzZVJlamVjdCxcblx0XHRcdC8vIFRPRE86IENvbnNpZGVyIHJlbmFtaW5nIHByb2dyZXNzKCkgdG8gbm90aWZ5KClcblx0XHRcdHByb2dyZXNzOiBwcm9taXNlUHJvZ3Jlc3MsXG5cblx0XHRcdHByb21pc2U6ICBwcm9taXNlLFxuXG5cdFx0XHRyZXNvbHZlcjoge1xuXHRcdFx0XHRyZXNvbHZlOiAgcHJvbWlzZVJlc29sdmUsXG5cdFx0XHRcdHJlamVjdDogICBwcm9taXNlUmVqZWN0LFxuXHRcdFx0XHRwcm9ncmVzczogcHJvbWlzZVByb2dyZXNzXG5cdFx0XHR9XG5cdFx0fTtcblxuXHRcdGhhbmRsZXJzID0gW107XG5cdFx0cHJvZ3Jlc3NIYW5kbGVycyA9IFtdO1xuXG5cdFx0LyoqXG5cdFx0ICogUHJlLXJlc29sdXRpb24gdGhlbigpIHRoYXQgYWRkcyB0aGUgc3VwcGxpZWQgY2FsbGJhY2ssIGVycmJhY2ssIGFuZCBwcm9nYmFja1xuXHRcdCAqIGZ1bmN0aW9ucyB0byB0aGUgcmVnaXN0ZXJlZCBsaXN0ZW5lcnNcblx0XHQgKiBAcHJpdmF0ZVxuXHRcdCAqXG5cdFx0ICogQHBhcmFtIHtmdW5jdGlvbj99IFtvbkZ1bGZpbGxlZF0gcmVzb2x1dGlvbiBoYW5kbGVyXG5cdFx0ICogQHBhcmFtIHtmdW5jdGlvbj99IFtvblJlamVjdGVkXSByZWplY3Rpb24gaGFuZGxlclxuXHRcdCAqIEBwYXJhbSB7ZnVuY3Rpb24/fSBbb25Qcm9ncmVzc10gcHJvZ3Jlc3MgaGFuZGxlclxuXHRcdCAqL1xuXHRcdF90aGVuID0gZnVuY3Rpb24ob25GdWxmaWxsZWQsIG9uUmVqZWN0ZWQsIG9uUHJvZ3Jlc3MpIHtcblx0XHRcdC8vIFRPRE86IFByb21pc2VzL0ErIGNoZWNrIHR5cGVvZiBvbkZ1bGZpbGxlZCwgb25SZWplY3RlZCwgb25Qcm9ncmVzc1xuXHRcdFx0dmFyIGRlZmVycmVkLCBwcm9ncmVzc0hhbmRsZXI7XG5cblx0XHRcdGRlZmVycmVkID0gZGVmZXIoKTtcblxuXHRcdFx0cHJvZ3Jlc3NIYW5kbGVyID0gdHlwZW9mIG9uUHJvZ3Jlc3MgPT09ICdmdW5jdGlvbidcblx0XHRcdFx0PyBmdW5jdGlvbih1cGRhdGUpIHtcblx0XHRcdFx0XHR0cnkge1xuXHRcdFx0XHRcdFx0Ly8gQWxsb3cgcHJvZ3Jlc3MgaGFuZGxlciB0byB0cmFuc2Zvcm0gcHJvZ3Jlc3MgZXZlbnRcblx0XHRcdFx0XHRcdGRlZmVycmVkLnByb2dyZXNzKG9uUHJvZ3Jlc3ModXBkYXRlKSk7XG5cdFx0XHRcdFx0fSBjYXRjaChlKSB7XG5cdFx0XHRcdFx0XHQvLyBVc2UgY2F1Z2h0IHZhbHVlIGFzIHByb2dyZXNzXG5cdFx0XHRcdFx0XHRkZWZlcnJlZC5wcm9ncmVzcyhlKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0OiBmdW5jdGlvbih1cGRhdGUpIHsgZGVmZXJyZWQucHJvZ3Jlc3ModXBkYXRlKTsgfTtcblxuXHRcdFx0aGFuZGxlcnMucHVzaChmdW5jdGlvbihwcm9taXNlKSB7XG5cdFx0XHRcdHByb21pc2UudGhlbihvbkZ1bGZpbGxlZCwgb25SZWplY3RlZClcblx0XHRcdFx0XHQudGhlbihkZWZlcnJlZC5yZXNvbHZlLCBkZWZlcnJlZC5yZWplY3QsIHByb2dyZXNzSGFuZGxlcik7XG5cdFx0XHR9KTtcblxuXHRcdFx0cHJvZ3Jlc3NIYW5kbGVycy5wdXNoKHByb2dyZXNzSGFuZGxlcik7XG5cblx0XHRcdHJldHVybiBkZWZlcnJlZC5wcm9taXNlO1xuXHRcdH07XG5cblx0XHQvKipcblx0XHQgKiBJc3N1ZSBhIHByb2dyZXNzIGV2ZW50LCBub3RpZnlpbmcgYWxsIHByb2dyZXNzIGxpc3RlbmVyc1xuXHRcdCAqIEBwcml2YXRlXG5cdFx0ICogQHBhcmFtIHsqfSB1cGRhdGUgcHJvZ3Jlc3MgZXZlbnQgcGF5bG9hZCB0byBwYXNzIHRvIGFsbCBsaXN0ZW5lcnNcblx0XHQgKi9cblx0XHRfcHJvZ3Jlc3MgPSBmdW5jdGlvbih1cGRhdGUpIHtcblx0XHRcdHByb2Nlc3NRdWV1ZShwcm9ncmVzc0hhbmRsZXJzLCB1cGRhdGUpO1xuXHRcdFx0cmV0dXJuIHVwZGF0ZTtcblx0XHR9O1xuXG5cdFx0LyoqXG5cdFx0ICogVHJhbnNpdGlvbiBmcm9tIHByZS1yZXNvbHV0aW9uIHN0YXRlIHRvIHBvc3QtcmVzb2x1dGlvbiBzdGF0ZSwgbm90aWZ5aW5nXG5cdFx0ICogYWxsIGxpc3RlbmVycyBvZiB0aGUgcmVzb2x1dGlvbiBvciByZWplY3Rpb25cblx0XHQgKiBAcHJpdmF0ZVxuXHRcdCAqIEBwYXJhbSB7Kn0gdmFsdWUgdGhlIHZhbHVlIG9mIHRoaXMgZGVmZXJyZWRcblx0XHQgKi9cblx0XHRfcmVzb2x2ZSA9IGZ1bmN0aW9uKHZhbHVlKSB7XG5cdFx0XHR2YWx1ZSA9IHJlc29sdmUodmFsdWUpO1xuXG5cdFx0XHQvLyBSZXBsYWNlIF90aGVuIHdpdGggb25lIHRoYXQgZGlyZWN0bHkgbm90aWZpZXMgd2l0aCB0aGUgcmVzdWx0LlxuXHRcdFx0X3RoZW4gPSB2YWx1ZS50aGVuO1xuXHRcdFx0Ly8gUmVwbGFjZSBfcmVzb2x2ZSBzbyB0aGF0IHRoaXMgRGVmZXJyZWQgY2FuIG9ubHkgYmUgcmVzb2x2ZWQgb25jZVxuXHRcdFx0X3Jlc29sdmUgPSByZXNvbHZlO1xuXHRcdFx0Ly8gTWFrZSBfcHJvZ3Jlc3MgYSBub29wLCB0byBkaXNhbGxvdyBwcm9ncmVzcyBmb3IgdGhlIHJlc29sdmVkIHByb21pc2UuXG5cdFx0XHRfcHJvZ3Jlc3MgPSBub29wO1xuXG5cdFx0XHQvLyBOb3RpZnkgaGFuZGxlcnNcblx0XHRcdHByb2Nlc3NRdWV1ZShoYW5kbGVycywgdmFsdWUpO1xuXG5cdFx0XHQvLyBGcmVlIHByb2dyZXNzSGFuZGxlcnMgYXJyYXkgc2luY2Ugd2UnbGwgbmV2ZXIgaXNzdWUgcHJvZ3Jlc3MgZXZlbnRzXG5cdFx0XHRwcm9ncmVzc0hhbmRsZXJzID0gaGFuZGxlcnMgPSB1bmRlZjtcblxuXHRcdFx0cmV0dXJuIHZhbHVlO1xuXHRcdH07XG5cblx0XHRyZXR1cm4gZGVmZXJyZWQ7XG5cblx0XHQvKipcblx0XHQgKiBXcmFwcGVyIHRvIGFsbG93IF90aGVuIHRvIGJlIHJlcGxhY2VkIHNhZmVseVxuXHRcdCAqIEBwYXJhbSB7ZnVuY3Rpb24/fSBbb25GdWxmaWxsZWRdIHJlc29sdXRpb24gaGFuZGxlclxuXHRcdCAqIEBwYXJhbSB7ZnVuY3Rpb24/fSBbb25SZWplY3RlZF0gcmVqZWN0aW9uIGhhbmRsZXJcblx0XHQgKiBAcGFyYW0ge2Z1bmN0aW9uP30gW29uUHJvZ3Jlc3NdIHByb2dyZXNzIGhhbmRsZXJcblx0XHQgKiBAcmV0dXJuIHtQcm9taXNlfSBuZXcgcHJvbWlzZVxuXHRcdCAqL1xuXHRcdGZ1bmN0aW9uIHRoZW4ob25GdWxmaWxsZWQsIG9uUmVqZWN0ZWQsIG9uUHJvZ3Jlc3MpIHtcblx0XHRcdC8vIFRPRE86IFByb21pc2VzL0ErIGNoZWNrIHR5cGVvZiBvbkZ1bGZpbGxlZCwgb25SZWplY3RlZCwgb25Qcm9ncmVzc1xuXHRcdFx0cmV0dXJuIF90aGVuKG9uRnVsZmlsbGVkLCBvblJlamVjdGVkLCBvblByb2dyZXNzKTtcblx0XHR9XG5cblx0XHQvKipcblx0XHQgKiBXcmFwcGVyIHRvIGFsbG93IF9yZXNvbHZlIHRvIGJlIHJlcGxhY2VkXG5cdFx0ICovXG5cdFx0ZnVuY3Rpb24gcHJvbWlzZVJlc29sdmUodmFsKSB7XG5cdFx0XHRyZXR1cm4gX3Jlc29sdmUodmFsKTtcblx0XHR9XG5cblx0XHQvKipcblx0XHQgKiBXcmFwcGVyIHRvIGFsbG93IF9yZWplY3QgdG8gYmUgcmVwbGFjZWRcblx0XHQgKi9cblx0XHRmdW5jdGlvbiBwcm9taXNlUmVqZWN0KGVycikge1xuXHRcdFx0cmV0dXJuIF9yZXNvbHZlKHJlamVjdGVkKGVycikpO1xuXHRcdH1cblxuXHRcdC8qKlxuXHRcdCAqIFdyYXBwZXIgdG8gYWxsb3cgX3Byb2dyZXNzIHRvIGJlIHJlcGxhY2VkXG5cdFx0ICovXG5cdFx0ZnVuY3Rpb24gcHJvbWlzZVByb2dyZXNzKHVwZGF0ZSkge1xuXHRcdFx0cmV0dXJuIF9wcm9ncmVzcyh1cGRhdGUpO1xuXHRcdH1cblx0fVxuXG5cdC8qKlxuXHQgKiBEZXRlcm1pbmVzIGlmIHByb21pc2VPclZhbHVlIGlzIGEgcHJvbWlzZSBvciBub3QuICBVc2VzIHRoZSBmZWF0dXJlXG5cdCAqIHRlc3QgZnJvbSBodHRwOi8vd2lraS5jb21tb25qcy5vcmcvd2lraS9Qcm9taXNlcy9BIHRvIGRldGVybWluZSBpZlxuXHQgKiBwcm9taXNlT3JWYWx1ZSBpcyBhIHByb21pc2UuXG5cdCAqXG5cdCAqIEBwYXJhbSB7Kn0gcHJvbWlzZU9yVmFsdWUgYW55dGhpbmdcblx0ICogQHJldHVybnMge2Jvb2xlYW59IHRydWUgaWYgcHJvbWlzZU9yVmFsdWUgaXMgYSB7QGxpbmsgUHJvbWlzZX1cblx0ICovXG5cdGZ1bmN0aW9uIGlzUHJvbWlzZShwcm9taXNlT3JWYWx1ZSkge1xuXHRcdHJldHVybiBwcm9taXNlT3JWYWx1ZSAmJiB0eXBlb2YgcHJvbWlzZU9yVmFsdWUudGhlbiA9PT0gJ2Z1bmN0aW9uJztcblx0fVxuXG5cdC8qKlxuXHQgKiBJbml0aWF0ZXMgYSBjb21wZXRpdGl2ZSByYWNlLCByZXR1cm5pbmcgYSBwcm9taXNlIHRoYXQgd2lsbCByZXNvbHZlIHdoZW5cblx0ICogaG93TWFueSBvZiB0aGUgc3VwcGxpZWQgcHJvbWlzZXNPclZhbHVlcyBoYXZlIHJlc29sdmVkLCBvciB3aWxsIHJlamVjdCB3aGVuXG5cdCAqIGl0IGJlY29tZXMgaW1wb3NzaWJsZSBmb3IgaG93TWFueSB0byByZXNvbHZlLCBmb3IgZXhhbXBsZSwgd2hlblxuXHQgKiAocHJvbWlzZXNPclZhbHVlcy5sZW5ndGggLSBob3dNYW55KSArIDEgaW5wdXQgcHJvbWlzZXMgcmVqZWN0LlxuXHQgKlxuXHQgKiBAcGFyYW0ge0FycmF5fSBwcm9taXNlc09yVmFsdWVzIGFycmF5IG9mIGFueXRoaW5nLCBtYXkgY29udGFpbiBhIG1peFxuXHQgKiAgICAgIG9mIHByb21pc2VzIGFuZCB2YWx1ZXNcblx0ICogQHBhcmFtIGhvd01hbnkge251bWJlcn0gbnVtYmVyIG9mIHByb21pc2VzT3JWYWx1ZXMgdG8gcmVzb2x2ZVxuXHQgKiBAcGFyYW0ge2Z1bmN0aW9uP30gW29uRnVsZmlsbGVkXSByZXNvbHV0aW9uIGhhbmRsZXJcblx0ICogQHBhcmFtIHtmdW5jdGlvbj99IFtvblJlamVjdGVkXSByZWplY3Rpb24gaGFuZGxlclxuXHQgKiBAcGFyYW0ge2Z1bmN0aW9uP30gW29uUHJvZ3Jlc3NdIHByb2dyZXNzIGhhbmRsZXJcblx0ICogQHJldHVybnMge1Byb21pc2V9IHByb21pc2UgdGhhdCB3aWxsIHJlc29sdmUgdG8gYW4gYXJyYXkgb2YgaG93TWFueSB2YWx1ZXMgdGhhdFxuXHQgKiByZXNvbHZlZCBmaXJzdCwgb3Igd2lsbCByZWplY3Qgd2l0aCBhbiBhcnJheSBvZiAocHJvbWlzZXNPclZhbHVlcy5sZW5ndGggLSBob3dNYW55KSArIDFcblx0ICogcmVqZWN0aW9uIHJlYXNvbnMuXG5cdCAqL1xuXHRmdW5jdGlvbiBzb21lKHByb21pc2VzT3JWYWx1ZXMsIGhvd01hbnksIG9uRnVsZmlsbGVkLCBvblJlamVjdGVkLCBvblByb2dyZXNzKSB7XG5cblx0XHRjaGVja0NhbGxiYWNrcygyLCBhcmd1bWVudHMpO1xuXG5cdFx0cmV0dXJuIHdoZW4ocHJvbWlzZXNPclZhbHVlcywgZnVuY3Rpb24ocHJvbWlzZXNPclZhbHVlcykge1xuXG5cdFx0XHR2YXIgdG9SZXNvbHZlLCB0b1JlamVjdCwgdmFsdWVzLCByZWFzb25zLCBkZWZlcnJlZCwgZnVsZmlsbE9uZSwgcmVqZWN0T25lLCBwcm9ncmVzcywgbGVuLCBpO1xuXG5cdFx0XHRsZW4gPSBwcm9taXNlc09yVmFsdWVzLmxlbmd0aCA+Pj4gMDtcblxuXHRcdFx0dG9SZXNvbHZlID0gTWF0aC5tYXgoMCwgTWF0aC5taW4oaG93TWFueSwgbGVuKSk7XG5cdFx0XHR2YWx1ZXMgPSBbXTtcblxuXHRcdFx0dG9SZWplY3QgPSAobGVuIC0gdG9SZXNvbHZlKSArIDE7XG5cdFx0XHRyZWFzb25zID0gW107XG5cblx0XHRcdGRlZmVycmVkID0gZGVmZXIoKTtcblxuXHRcdFx0Ly8gTm8gaXRlbXMgaW4gdGhlIGlucHV0LCByZXNvbHZlIGltbWVkaWF0ZWx5XG5cdFx0XHRpZiAoIXRvUmVzb2x2ZSkge1xuXHRcdFx0XHRkZWZlcnJlZC5yZXNvbHZlKHZhbHVlcyk7XG5cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHByb2dyZXNzID0gZGVmZXJyZWQucHJvZ3Jlc3M7XG5cblx0XHRcdFx0cmVqZWN0T25lID0gZnVuY3Rpb24ocmVhc29uKSB7XG5cdFx0XHRcdFx0cmVhc29ucy5wdXNoKHJlYXNvbik7XG5cdFx0XHRcdFx0aWYoIS0tdG9SZWplY3QpIHtcblx0XHRcdFx0XHRcdGZ1bGZpbGxPbmUgPSByZWplY3RPbmUgPSBub29wO1xuXHRcdFx0XHRcdFx0ZGVmZXJyZWQucmVqZWN0KHJlYXNvbnMpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fTtcblxuXHRcdFx0XHRmdWxmaWxsT25lID0gZnVuY3Rpb24odmFsKSB7XG5cdFx0XHRcdFx0Ly8gVGhpcyBvcmRlcnMgdGhlIHZhbHVlcyBiYXNlZCBvbiBwcm9taXNlIHJlc29sdXRpb24gb3JkZXJcblx0XHRcdFx0XHQvLyBBbm90aGVyIHN0cmF0ZWd5IHdvdWxkIGJlIHRvIHVzZSB0aGUgb3JpZ2luYWwgcG9zaXRpb24gb2Zcblx0XHRcdFx0XHQvLyB0aGUgY29ycmVzcG9uZGluZyBwcm9taXNlLlxuXHRcdFx0XHRcdHZhbHVlcy5wdXNoKHZhbCk7XG5cblx0XHRcdFx0XHRpZiAoIS0tdG9SZXNvbHZlKSB7XG5cdFx0XHRcdFx0XHRmdWxmaWxsT25lID0gcmVqZWN0T25lID0gbm9vcDtcblx0XHRcdFx0XHRcdGRlZmVycmVkLnJlc29sdmUodmFsdWVzKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH07XG5cblx0XHRcdFx0Zm9yKGkgPSAwOyBpIDwgbGVuOyArK2kpIHtcblx0XHRcdFx0XHRpZihpIGluIHByb21pc2VzT3JWYWx1ZXMpIHtcblx0XHRcdFx0XHRcdHdoZW4ocHJvbWlzZXNPclZhbHVlc1tpXSwgZnVsZmlsbGVyLCByZWplY3RlciwgcHJvZ3Jlc3MpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gZGVmZXJyZWQudGhlbihvbkZ1bGZpbGxlZCwgb25SZWplY3RlZCwgb25Qcm9ncmVzcyk7XG5cblx0XHRcdGZ1bmN0aW9uIHJlamVjdGVyKHJlYXNvbikge1xuXHRcdFx0XHRyZWplY3RPbmUocmVhc29uKTtcblx0XHRcdH1cblxuXHRcdFx0ZnVuY3Rpb24gZnVsZmlsbGVyKHZhbCkge1xuXHRcdFx0XHRmdWxmaWxsT25lKHZhbCk7XG5cdFx0XHR9XG5cblx0XHR9KTtcblx0fVxuXG5cdC8qKlxuXHQgKiBJbml0aWF0ZXMgYSBjb21wZXRpdGl2ZSByYWNlLCByZXR1cm5pbmcgYSBwcm9taXNlIHRoYXQgd2lsbCByZXNvbHZlIHdoZW5cblx0ICogYW55IG9uZSBvZiB0aGUgc3VwcGxpZWQgcHJvbWlzZXNPclZhbHVlcyBoYXMgcmVzb2x2ZWQgb3Igd2lsbCByZWplY3Qgd2hlblxuXHQgKiAqYWxsKiBwcm9taXNlc09yVmFsdWVzIGhhdmUgcmVqZWN0ZWQuXG5cdCAqXG5cdCAqIEBwYXJhbSB7QXJyYXl8UHJvbWlzZX0gcHJvbWlzZXNPclZhbHVlcyBhcnJheSBvZiBhbnl0aGluZywgbWF5IGNvbnRhaW4gYSBtaXhcblx0ICogICAgICBvZiB7QGxpbmsgUHJvbWlzZX1zIGFuZCB2YWx1ZXNcblx0ICogQHBhcmFtIHtmdW5jdGlvbj99IFtvbkZ1bGZpbGxlZF0gcmVzb2x1dGlvbiBoYW5kbGVyXG5cdCAqIEBwYXJhbSB7ZnVuY3Rpb24/fSBbb25SZWplY3RlZF0gcmVqZWN0aW9uIGhhbmRsZXJcblx0ICogQHBhcmFtIHtmdW5jdGlvbj99IFtvblByb2dyZXNzXSBwcm9ncmVzcyBoYW5kbGVyXG5cdCAqIEByZXR1cm5zIHtQcm9taXNlfSBwcm9taXNlIHRoYXQgd2lsbCByZXNvbHZlIHRvIHRoZSB2YWx1ZSB0aGF0IHJlc29sdmVkIGZpcnN0LCBvclxuXHQgKiB3aWxsIHJlamVjdCB3aXRoIGFuIGFycmF5IG9mIGFsbCByZWplY3RlZCBpbnB1dHMuXG5cdCAqL1xuXHRmdW5jdGlvbiBhbnkocHJvbWlzZXNPclZhbHVlcywgb25GdWxmaWxsZWQsIG9uUmVqZWN0ZWQsIG9uUHJvZ3Jlc3MpIHtcblxuXHRcdGZ1bmN0aW9uIHVud3JhcFNpbmdsZVJlc3VsdCh2YWwpIHtcblx0XHRcdHJldHVybiBvbkZ1bGZpbGxlZCA/IG9uRnVsZmlsbGVkKHZhbFswXSkgOiB2YWxbMF07XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHNvbWUocHJvbWlzZXNPclZhbHVlcywgMSwgdW53cmFwU2luZ2xlUmVzdWx0LCBvblJlamVjdGVkLCBvblByb2dyZXNzKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBSZXR1cm4gYSBwcm9taXNlIHRoYXQgd2lsbCByZXNvbHZlIG9ubHkgb25jZSBhbGwgdGhlIHN1cHBsaWVkIHByb21pc2VzT3JWYWx1ZXNcblx0ICogaGF2ZSByZXNvbHZlZC4gVGhlIHJlc29sdXRpb24gdmFsdWUgb2YgdGhlIHJldHVybmVkIHByb21pc2Ugd2lsbCBiZSBhbiBhcnJheVxuXHQgKiBjb250YWluaW5nIHRoZSByZXNvbHV0aW9uIHZhbHVlcyBvZiBlYWNoIG9mIHRoZSBwcm9taXNlc09yVmFsdWVzLlxuXHQgKiBAbWVtYmVyT2Ygd2hlblxuXHQgKlxuXHQgKiBAcGFyYW0ge0FycmF5fFByb21pc2V9IHByb21pc2VzT3JWYWx1ZXMgYXJyYXkgb2YgYW55dGhpbmcsIG1heSBjb250YWluIGEgbWl4XG5cdCAqICAgICAgb2Yge0BsaW5rIFByb21pc2V9cyBhbmQgdmFsdWVzXG5cdCAqIEBwYXJhbSB7ZnVuY3Rpb24/fSBbb25GdWxmaWxsZWRdIHJlc29sdXRpb24gaGFuZGxlclxuXHQgKiBAcGFyYW0ge2Z1bmN0aW9uP30gW29uUmVqZWN0ZWRdIHJlamVjdGlvbiBoYW5kbGVyXG5cdCAqIEBwYXJhbSB7ZnVuY3Rpb24/fSBbb25Qcm9ncmVzc10gcHJvZ3Jlc3MgaGFuZGxlclxuXHQgKiBAcmV0dXJucyB7UHJvbWlzZX1cblx0ICovXG5cdGZ1bmN0aW9uIGFsbChwcm9taXNlc09yVmFsdWVzLCBvbkZ1bGZpbGxlZCwgb25SZWplY3RlZCwgb25Qcm9ncmVzcykge1xuXHRcdGNoZWNrQ2FsbGJhY2tzKDEsIGFyZ3VtZW50cyk7XG5cdFx0cmV0dXJuIG1hcChwcm9taXNlc09yVmFsdWVzLCBpZGVudGl0eSkudGhlbihvbkZ1bGZpbGxlZCwgb25SZWplY3RlZCwgb25Qcm9ncmVzcyk7XG5cdH1cblxuXHQvKipcblx0ICogSm9pbnMgbXVsdGlwbGUgcHJvbWlzZXMgaW50byBhIHNpbmdsZSByZXR1cm5lZCBwcm9taXNlLlxuXHQgKiBAcmV0dXJuIHtQcm9taXNlfSBhIHByb21pc2UgdGhhdCB3aWxsIGZ1bGZpbGwgd2hlbiAqYWxsKiB0aGUgaW5wdXQgcHJvbWlzZXNcblx0ICogaGF2ZSBmdWxmaWxsZWQsIG9yIHdpbGwgcmVqZWN0IHdoZW4gKmFueSBvbmUqIG9mIHRoZSBpbnB1dCBwcm9taXNlcyByZWplY3RzLlxuXHQgKi9cblx0ZnVuY3Rpb24gam9pbigvKiAuLi5wcm9taXNlcyAqLykge1xuXHRcdHJldHVybiBtYXAoYXJndW1lbnRzLCBpZGVudGl0eSk7XG5cdH1cblxuXHQvKipcblx0ICogVHJhZGl0aW9uYWwgbWFwIGZ1bmN0aW9uLCBzaW1pbGFyIHRvIGBBcnJheS5wcm90b3R5cGUubWFwKClgLCBidXQgYWxsb3dzXG5cdCAqIGlucHV0IHRvIGNvbnRhaW4ge0BsaW5rIFByb21pc2V9cyBhbmQvb3IgdmFsdWVzLCBhbmQgbWFwRnVuYyBtYXkgcmV0dXJuXG5cdCAqIGVpdGhlciBhIHZhbHVlIG9yIGEge0BsaW5rIFByb21pc2V9XG5cdCAqXG5cdCAqIEBwYXJhbSB7QXJyYXl8UHJvbWlzZX0gcHJvbWlzZSBhcnJheSBvZiBhbnl0aGluZywgbWF5IGNvbnRhaW4gYSBtaXhcblx0ICogICAgICBvZiB7QGxpbmsgUHJvbWlzZX1zIGFuZCB2YWx1ZXNcblx0ICogQHBhcmFtIHtmdW5jdGlvbn0gbWFwRnVuYyBtYXBwaW5nIGZ1bmN0aW9uIG1hcEZ1bmModmFsdWUpIHdoaWNoIG1heSByZXR1cm5cblx0ICogICAgICBlaXRoZXIgYSB7QGxpbmsgUHJvbWlzZX0gb3IgdmFsdWVcblx0ICogQHJldHVybnMge1Byb21pc2V9IGEge0BsaW5rIFByb21pc2V9IHRoYXQgd2lsbCByZXNvbHZlIHRvIGFuIGFycmF5IGNvbnRhaW5pbmdcblx0ICogICAgICB0aGUgbWFwcGVkIG91dHB1dCB2YWx1ZXMuXG5cdCAqL1xuXHRmdW5jdGlvbiBtYXAocHJvbWlzZSwgbWFwRnVuYykge1xuXHRcdHJldHVybiB3aGVuKHByb21pc2UsIGZ1bmN0aW9uKGFycmF5KSB7XG5cdFx0XHR2YXIgcmVzdWx0cywgbGVuLCB0b1Jlc29sdmUsIHJlc29sdmUsIGksIGQ7XG5cblx0XHRcdC8vIFNpbmNlIHdlIGtub3cgdGhlIHJlc3VsdGluZyBsZW5ndGgsIHdlIGNhbiBwcmVhbGxvY2F0ZSB0aGUgcmVzdWx0c1xuXHRcdFx0Ly8gYXJyYXkgdG8gYXZvaWQgYXJyYXkgZXhwYW5zaW9ucy5cblx0XHRcdHRvUmVzb2x2ZSA9IGxlbiA9IGFycmF5Lmxlbmd0aCA+Pj4gMDtcblx0XHRcdHJlc3VsdHMgPSBbXTtcblx0XHRcdGQgPSBkZWZlcigpO1xuXG5cdFx0XHRpZighdG9SZXNvbHZlKSB7XG5cdFx0XHRcdGQucmVzb2x2ZShyZXN1bHRzKTtcblx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0cmVzb2x2ZSA9IGZ1bmN0aW9uIHJlc29sdmVPbmUoaXRlbSwgaSkge1xuXHRcdFx0XHRcdHdoZW4oaXRlbSwgbWFwRnVuYykudGhlbihmdW5jdGlvbihtYXBwZWQpIHtcblx0XHRcdFx0XHRcdHJlc3VsdHNbaV0gPSBtYXBwZWQ7XG5cblx0XHRcdFx0XHRcdGlmKCEtLXRvUmVzb2x2ZSkge1xuXHRcdFx0XHRcdFx0XHRkLnJlc29sdmUocmVzdWx0cyk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fSwgZC5yZWplY3QpO1xuXHRcdFx0XHR9O1xuXG5cdFx0XHRcdC8vIFNpbmNlIG1hcEZ1bmMgbWF5IGJlIGFzeW5jLCBnZXQgYWxsIGludm9jYXRpb25zIG9mIGl0IGludG8gZmxpZ2h0XG5cdFx0XHRcdGZvcihpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG5cdFx0XHRcdFx0aWYoaSBpbiBhcnJheSkge1xuXHRcdFx0XHRcdFx0cmVzb2x2ZShhcnJheVtpXSwgaSk7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdC0tdG9SZXNvbHZlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBkLnByb21pc2U7XG5cblx0XHR9KTtcblx0fVxuXG5cdC8qKlxuXHQgKiBUcmFkaXRpb25hbCByZWR1Y2UgZnVuY3Rpb24sIHNpbWlsYXIgdG8gYEFycmF5LnByb3RvdHlwZS5yZWR1Y2UoKWAsIGJ1dFxuXHQgKiBpbnB1dCBtYXkgY29udGFpbiBwcm9taXNlcyBhbmQvb3IgdmFsdWVzLCBhbmQgcmVkdWNlRnVuY1xuXHQgKiBtYXkgcmV0dXJuIGVpdGhlciBhIHZhbHVlIG9yIGEgcHJvbWlzZSwgKmFuZCogaW5pdGlhbFZhbHVlIG1heVxuXHQgKiBiZSBhIHByb21pc2UgZm9yIHRoZSBzdGFydGluZyB2YWx1ZS5cblx0ICpcblx0ICogQHBhcmFtIHtBcnJheXxQcm9taXNlfSBwcm9taXNlIGFycmF5IG9yIHByb21pc2UgZm9yIGFuIGFycmF5IG9mIGFueXRoaW5nLFxuXHQgKiAgICAgIG1heSBjb250YWluIGEgbWl4IG9mIHByb21pc2VzIGFuZCB2YWx1ZXMuXG5cdCAqIEBwYXJhbSB7ZnVuY3Rpb259IHJlZHVjZUZ1bmMgcmVkdWNlIGZ1bmN0aW9uIHJlZHVjZShjdXJyZW50VmFsdWUsIG5leHRWYWx1ZSwgaW5kZXgsIHRvdGFsKSxcblx0ICogICAgICB3aGVyZSB0b3RhbCBpcyB0aGUgdG90YWwgbnVtYmVyIG9mIGl0ZW1zIGJlaW5nIHJlZHVjZWQsIGFuZCB3aWxsIGJlIHRoZSBzYW1lXG5cdCAqICAgICAgaW4gZWFjaCBjYWxsIHRvIHJlZHVjZUZ1bmMuXG5cdCAqIEByZXR1cm5zIHtQcm9taXNlfSB0aGF0IHdpbGwgcmVzb2x2ZSB0byB0aGUgZmluYWwgcmVkdWNlZCB2YWx1ZVxuXHQgKi9cblx0ZnVuY3Rpb24gcmVkdWNlKHByb21pc2UsIHJlZHVjZUZ1bmMgLyosIGluaXRpYWxWYWx1ZSAqLykge1xuXHRcdHZhciBhcmdzID0gc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpO1xuXG5cdFx0cmV0dXJuIHdoZW4ocHJvbWlzZSwgZnVuY3Rpb24oYXJyYXkpIHtcblx0XHRcdHZhciB0b3RhbDtcblxuXHRcdFx0dG90YWwgPSBhcnJheS5sZW5ndGg7XG5cblx0XHRcdC8vIFdyYXAgdGhlIHN1cHBsaWVkIHJlZHVjZUZ1bmMgd2l0aCBvbmUgdGhhdCBoYW5kbGVzIHByb21pc2VzIGFuZCB0aGVuXG5cdFx0XHQvLyBkZWxlZ2F0ZXMgdG8gdGhlIHN1cHBsaWVkLlxuXHRcdFx0YXJnc1swXSA9IGZ1bmN0aW9uIChjdXJyZW50LCB2YWwsIGkpIHtcblx0XHRcdFx0cmV0dXJuIHdoZW4oY3VycmVudCwgZnVuY3Rpb24gKGMpIHtcblx0XHRcdFx0XHRyZXR1cm4gd2hlbih2YWwsIGZ1bmN0aW9uICh2YWx1ZSkge1xuXHRcdFx0XHRcdFx0cmV0dXJuIHJlZHVjZUZ1bmMoYywgdmFsdWUsIGksIHRvdGFsKTtcblx0XHRcdFx0XHR9KTtcblx0XHRcdFx0fSk7XG5cdFx0XHR9O1xuXG5cdFx0XHRyZXR1cm4gcmVkdWNlQXJyYXkuYXBwbHkoYXJyYXksIGFyZ3MpO1xuXHRcdH0pO1xuXHR9XG5cblx0LyoqXG5cdCAqIEVuc3VyZSB0aGF0IHJlc29sdXRpb24gb2YgcHJvbWlzZU9yVmFsdWUgd2lsbCB0cmlnZ2VyIHJlc29sdmVyIHdpdGggdGhlXG5cdCAqIHZhbHVlIG9yIHJlYXNvbiBvZiBwcm9taXNlT3JWYWx1ZSwgb3IgaW5zdGVhZCB3aXRoIHJlc29sdmVWYWx1ZSBpZiBpdCBpcyBwcm92aWRlZC5cblx0ICpcblx0ICogQHBhcmFtIHByb21pc2VPclZhbHVlXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSByZXNvbHZlclxuXHQgKiBAcGFyYW0ge2Z1bmN0aW9ufSByZXNvbHZlci5yZXNvbHZlXG5cdCAqIEBwYXJhbSB7ZnVuY3Rpb259IHJlc29sdmVyLnJlamVjdFxuXHQgKiBAcGFyYW0geyp9IFtyZXNvbHZlVmFsdWVdXG5cdCAqIEByZXR1cm5zIHtQcm9taXNlfVxuXHQgKi9cblx0ZnVuY3Rpb24gY2hhaW4ocHJvbWlzZU9yVmFsdWUsIHJlc29sdmVyLCByZXNvbHZlVmFsdWUpIHtcblx0XHR2YXIgdXNlUmVzb2x2ZVZhbHVlID0gYXJndW1lbnRzLmxlbmd0aCA+IDI7XG5cblx0XHRyZXR1cm4gd2hlbihwcm9taXNlT3JWYWx1ZSxcblx0XHRcdGZ1bmN0aW9uKHZhbCkge1xuXHRcdFx0XHR2YWwgPSB1c2VSZXNvbHZlVmFsdWUgPyByZXNvbHZlVmFsdWUgOiB2YWw7XG5cdFx0XHRcdHJlc29sdmVyLnJlc29sdmUodmFsKTtcblx0XHRcdFx0cmV0dXJuIHZhbDtcblx0XHRcdH0sXG5cdFx0XHRmdW5jdGlvbihyZWFzb24pIHtcblx0XHRcdFx0cmVzb2x2ZXIucmVqZWN0KHJlYXNvbik7XG5cdFx0XHRcdHJldHVybiByZWplY3RlZChyZWFzb24pO1xuXHRcdFx0fSxcblx0XHRcdHJlc29sdmVyLnByb2dyZXNzXG5cdFx0KTtcblx0fVxuXG5cdC8vXG5cdC8vIFV0aWxpdHkgZnVuY3Rpb25zXG5cdC8vXG5cblx0LyoqXG5cdCAqIEFwcGx5IGFsbCBmdW5jdGlvbnMgaW4gcXVldWUgdG8gdmFsdWVcblx0ICogQHBhcmFtIHtBcnJheX0gcXVldWUgYXJyYXkgb2YgZnVuY3Rpb25zIHRvIGV4ZWN1dGVcblx0ICogQHBhcmFtIHsqfSB2YWx1ZSBhcmd1bWVudCBwYXNzZWQgdG8gZWFjaCBmdW5jdGlvblxuXHQgKi9cblx0ZnVuY3Rpb24gcHJvY2Vzc1F1ZXVlKHF1ZXVlLCB2YWx1ZSkge1xuXHRcdHZhciBoYW5kbGVyLCBpID0gMDtcblxuXHRcdHdoaWxlIChoYW5kbGVyID0gcXVldWVbaSsrXSkge1xuXHRcdFx0aGFuZGxlcih2YWx1ZSk7XG5cdFx0fVxuXHR9XG5cblx0LyoqXG5cdCAqIEhlbHBlciB0aGF0IGNoZWNrcyBhcnJheU9mQ2FsbGJhY2tzIHRvIGVuc3VyZSB0aGF0IGVhY2ggZWxlbWVudCBpcyBlaXRoZXJcblx0ICogYSBmdW5jdGlvbiwgb3IgbnVsbCBvciB1bmRlZmluZWQuXG5cdCAqIEBwcml2YXRlXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBzdGFydCBpbmRleCBhdCB3aGljaCB0byBzdGFydCBjaGVja2luZyBpdGVtcyBpbiBhcnJheU9mQ2FsbGJhY2tzXG5cdCAqIEBwYXJhbSB7QXJyYXl9IGFycmF5T2ZDYWxsYmFja3MgYXJyYXkgdG8gY2hlY2tcblx0ICogQHRocm93cyB7RXJyb3J9IGlmIGFueSBlbGVtZW50IG9mIGFycmF5T2ZDYWxsYmFja3MgaXMgc29tZXRoaW5nIG90aGVyIHRoYW5cblx0ICogYSBmdW5jdGlvbnMsIG51bGwsIG9yIHVuZGVmaW5lZC5cblx0ICovXG5cdGZ1bmN0aW9uIGNoZWNrQ2FsbGJhY2tzKHN0YXJ0LCBhcnJheU9mQ2FsbGJhY2tzKSB7XG5cdFx0Ly8gVE9ETzogUHJvbWlzZXMvQSsgdXBkYXRlIHR5cGUgY2hlY2tpbmcgYW5kIGRvY3Ncblx0XHR2YXIgYXJnLCBpID0gYXJyYXlPZkNhbGxiYWNrcy5sZW5ndGg7XG5cblx0XHR3aGlsZShpID4gc3RhcnQpIHtcblx0XHRcdGFyZyA9IGFycmF5T2ZDYWxsYmFja3NbLS1pXTtcblxuXHRcdFx0aWYgKGFyZyAhPSBudWxsICYmIHR5cGVvZiBhcmcgIT0gJ2Z1bmN0aW9uJykge1xuXHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ2FyZyAnK2krJyBtdXN0IGJlIGEgZnVuY3Rpb24nKTtcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHQvKipcblx0ICogTm8tT3AgZnVuY3Rpb24gdXNlZCBpbiBtZXRob2QgcmVwbGFjZW1lbnRcblx0ICogQHByaXZhdGVcblx0ICovXG5cdGZ1bmN0aW9uIG5vb3AoKSB7fVxuXG5cdHNsaWNlID0gW10uc2xpY2U7XG5cblx0Ly8gRVM1IHJlZHVjZSBpbXBsZW1lbnRhdGlvbiBpZiBuYXRpdmUgbm90IGF2YWlsYWJsZVxuXHQvLyBTZWU6IGh0dHA6Ly9lczUuZ2l0aHViLmNvbS8jeDE1LjQuNC4yMSBhcyB0aGVyZSBhcmUgbWFueVxuXHQvLyBzcGVjaWZpY3MgYW5kIGVkZ2UgY2FzZXMuXG5cdHJlZHVjZUFycmF5ID0gW10ucmVkdWNlIHx8XG5cdFx0ZnVuY3Rpb24ocmVkdWNlRnVuYyAvKiwgaW5pdGlhbFZhbHVlICovKSB7XG5cdFx0XHQvKmpzaGludCBtYXhjb21wbGV4aXR5OiA3Ki9cblxuXHRcdFx0Ly8gRVM1IGRpY3RhdGVzIHRoYXQgcmVkdWNlLmxlbmd0aCA9PT0gMVxuXG5cdFx0XHQvLyBUaGlzIGltcGxlbWVudGF0aW9uIGRldmlhdGVzIGZyb20gRVM1IHNwZWMgaW4gdGhlIGZvbGxvd2luZyB3YXlzOlxuXHRcdFx0Ly8gMS4gSXQgZG9lcyBub3QgY2hlY2sgaWYgcmVkdWNlRnVuYyBpcyBhIENhbGxhYmxlXG5cblx0XHRcdHZhciBhcnIsIGFyZ3MsIHJlZHVjZWQsIGxlbiwgaTtcblxuXHRcdFx0aSA9IDA7XG5cdFx0XHQvLyBUaGlzIGdlbmVyYXRlcyBhIGpzaGludCB3YXJuaW5nLCBkZXNwaXRlIGJlaW5nIHZhbGlkXG5cdFx0XHQvLyBcIk1pc3NpbmcgJ25ldycgcHJlZml4IHdoZW4gaW52b2tpbmcgYSBjb25zdHJ1Y3Rvci5cIlxuXHRcdFx0Ly8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9qc2hpbnQvanNoaW50L2lzc3Vlcy8zOTJcblx0XHRcdGFyciA9IE9iamVjdCh0aGlzKTtcblx0XHRcdGxlbiA9IGFyci5sZW5ndGggPj4+IDA7XG5cdFx0XHRhcmdzID0gYXJndW1lbnRzO1xuXG5cdFx0XHQvLyBJZiBubyBpbml0aWFsVmFsdWUsIHVzZSBmaXJzdCBpdGVtIG9mIGFycmF5ICh3ZSBrbm93IGxlbmd0aCAhPT0gMCBoZXJlKVxuXHRcdFx0Ly8gYW5kIGFkanVzdCBpIHRvIHN0YXJ0IGF0IHNlY29uZCBpdGVtXG5cdFx0XHRpZihhcmdzLmxlbmd0aCA8PSAxKSB7XG5cdFx0XHRcdC8vIFNraXAgdG8gdGhlIGZpcnN0IHJlYWwgZWxlbWVudCBpbiB0aGUgYXJyYXlcblx0XHRcdFx0Zm9yKDs7KSB7XG5cdFx0XHRcdFx0aWYoaSBpbiBhcnIpIHtcblx0XHRcdFx0XHRcdHJlZHVjZWQgPSBhcnJbaSsrXTtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdC8vIElmIHdlIHJlYWNoZWQgdGhlIGVuZCBvZiB0aGUgYXJyYXkgd2l0aG91dCBmaW5kaW5nIGFueSByZWFsXG5cdFx0XHRcdFx0Ly8gZWxlbWVudHMsIGl0J3MgYSBUeXBlRXJyb3Jcblx0XHRcdFx0XHRpZigrK2kgPj0gbGVuKSB7XG5cdFx0XHRcdFx0XHR0aHJvdyBuZXcgVHlwZUVycm9yKCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHQvLyBJZiBpbml0aWFsVmFsdWUgcHJvdmlkZWQsIHVzZSBpdFxuXHRcdFx0XHRyZWR1Y2VkID0gYXJnc1sxXTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gRG8gdGhlIGFjdHVhbCByZWR1Y2Vcblx0XHRcdGZvcig7aSA8IGxlbjsgKytpKSB7XG5cdFx0XHRcdC8vIFNraXAgaG9sZXNcblx0XHRcdFx0aWYoaSBpbiBhcnIpIHtcblx0XHRcdFx0XHRyZWR1Y2VkID0gcmVkdWNlRnVuYyhyZWR1Y2VkLCBhcnJbaV0sIGksIGFycik7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIHJlZHVjZWQ7XG5cdFx0fTtcblxuXHRmdW5jdGlvbiBpZGVudGl0eSh4KSB7XG5cdFx0cmV0dXJuIHg7XG5cdH1cblxuXHRyZXR1cm4gd2hlbjtcbn0pO1xufSkoZnVuY3Rpb24gKGZhY3RvcnkpIHsgKG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeSgpKVxuXHRcdDtcblx0fVxuXHQvLyBCb2lsZXJwbGF0ZSBmb3IgQU1ELCBOb2RlLCBhbmQgYnJvd3NlciBnbG9iYWxcbik7XG59KTtcblxuZXhwb3J0IHsgd2hlbiBhcyBkZWZhdWx0IH07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///13222\n")},92678:function(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__){eval('/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "Z": function() { return /* binding */ zip; }\n/* harmony export */ });\n/* This file is automatically rebuilt by the Cesium build process. */\n/*\n Copyright (c) 2021 Gildas Lormeau. All rights reserved.\n\n Redistribution and use in source and binary forms, with or without\n modification, are permitted provided that the following conditions are met:\n\n 1. Redistributions of source code must retain the above copyright notice,\n this list of conditions and the following disclaimer.\n\n 2. Redistributions in binary form must reproduce the above copyright \n notice, this list of conditions and the following disclaimer in \n the documentation and/or other materials provided with the distribution.\n\n 3. The names of the authors may not be used to endorse or promote products\n derived from this software without specific prior written permission.\n\n THIS SOFTWARE IS PROVIDED \'\'AS IS\'\' AND ANY EXPRESSED OR IMPLIED WARRANTIES,\n INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\n FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL JCRAFT,\n INC. OR ANY CONTRIBUTORS TO THIS SOFTWARE BE LIABLE FOR ANY DIRECT, INDIRECT,\n INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,\n OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF\n LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING\n NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,\n EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\nconst DEFAULT_CONFIGURATION = {\n\tchunkSize: 512 * 1024,\n\tmaxWorkers: (typeof navigator != "undefined" && navigator.hardwareConcurrency) || 2,\n\tterminateWorkerTimeout: 5000,\n\tuseWebWorkers: true,\n\tworkerScripts: undefined\n};\n\nconst config = Object.assign({}, DEFAULT_CONFIGURATION);\n\nfunction getConfiguration() {\n\treturn config;\n}\n\nfunction configure(configuration) {\n\tif (configuration.chunkSize !== undefined) {\n\t\tconfig.chunkSize = configuration.chunkSize;\n\t}\n\tif (configuration.maxWorkers !== undefined) {\n\t\tconfig.maxWorkers = configuration.maxWorkers;\n\t}\n\tif (configuration.terminateWorkerTimeout !== undefined) {\n\t\tconfig.terminateWorkerTimeout = configuration.terminateWorkerTimeout;\n\t}\n\tif (configuration.useWebWorkers !== undefined) {\n\t\tconfig.useWebWorkers = configuration.useWebWorkers;\n\t}\n\tif (configuration.Deflate !== undefined) {\n\t\tconfig.Deflate = configuration.Deflate;\n\t}\n\tif (configuration.Inflate !== undefined) {\n\t\tconfig.Inflate = configuration.Inflate;\n\t}\n\tif (configuration.workerScripts !== undefined) {\n\t\tif (configuration.workerScripts.deflate) {\n\t\t\tif (!Array.isArray(configuration.workerScripts.deflate)) {\n\t\t\t\tthrow new Error("workerScripts.deflate must be an array");\n\t\t\t}\n\t\t\tif (!config.workerScripts) {\n\t\t\t\tconfig.workerScripts = {};\n\t\t\t}\n\t\t\tconfig.workerScripts.deflate = configuration.workerScripts.deflate;\n\t\t}\n\t\tif (configuration.workerScripts.inflate) {\n\t\t\tif (!Array.isArray(configuration.workerScripts.inflate)) {\n\t\t\t\tthrow new Error("workerScripts.inflate must be an array");\n\t\t\t}\n\t\t\tif (!config.workerScripts) {\n\t\t\t\tconfig.workerScripts = {};\n\t\t\t}\n\t\t\tconfig.workerScripts.inflate = configuration.workerScripts.inflate;\n\t\t}\n\t}\n}\n\nvar configureWebWorker = ()=>{if("function"==typeof URL.createObjectURL){const e=(()=>{const t=[];for(let e=0;e<256;e++){let n=e;for(let t=0;t<8;t++)1&n?n=n>>>1^3988292384:n>>>=1;t[e]=n;}class e{constructor(t){this.crc=t||-1;}append(e){let n=0|this.crc;for(let i=0,a=0|e.length;i<a;i++)n=n>>>8^t[255&(n^e[i])];this.crc=n;}get(){return ~this.crc}}const n={concat(t,e){if(0===t.length||0===e.length)return t.concat(e);const i=t[t.length-1],a=n.getPartial(i);return 32===a?t.concat(e):n._shiftRight(e,a,0|i,t.slice(0,t.length-1))},bitLength(t){const e=t.length;if(0===e)return 0;const i=t[e-1];return 32*(e-1)+n.getPartial(i)},clamp(t,e){if(32*t.length<e)return t;const i=(t=t.slice(0,Math.ceil(e/32))).length;return e&=31,i>0&&e&&(t[i-1]=n.partial(e,t[i-1]&2147483648>>e-1,1)),t},partial:(t,e,n)=>32===t?e:(n?0|e:e<<32-t)+1099511627776*t,getPartial:t=>Math.round(t/1099511627776)||32,_shiftRight(t,e,i,a){for(void 0===a&&(a=[]);e>=32;e-=32)a.push(i),i=0;if(0===e)return a.concat(t);for(let n=0;n<t.length;n++)a.push(i|t[n]>>>e),i=t[n]<<32-e;const r=t.length?t[t.length-1]:0,s=n.getPartial(r);return a.push(n.partial(e+s&31,e+s>32?i:a.pop(),1)),a}},i={bytes:{fromBits(t){const e=n.bitLength(t)/8,i=new Uint8Array(e);let a;for(let n=0;n<e;n++)0==(3&n)&&(a=t[n/4]),i[n]=a>>>24,a<<=8;return i},toBits(t){const e=[];let i,a=0;for(i=0;i<t.length;i++)a=a<<8|t[i],3==(3&i)&&(e.push(a),a=0);return 3&i&&e.push(n.partial(8*(3&i),a)),e}}},a={sha1:function(t){t?(this._h=t._h.slice(0),this._buffer=t._buffer.slice(0),this._length=t._length):this.reset();}};a.sha1.prototype={blockSize:512,reset:function(){const t=this;return t._h=this._init.slice(0),t._buffer=[],t._length=0,t},update:function(t){const e=this;"string"==typeof t&&(t=i.utf8String.toBits(t));const a=e._buffer=n.concat(e._buffer,t),r=e._length,s=e._length=r+n.bitLength(t);if(s>9007199254740991)throw new Error("Cannot hash more than 2^53 - 1 bits");const o=new Uint32Array(a);let l=0;for(let t=e.blockSize+r-(e.blockSize+r&e.blockSize-1);t<=s;t+=e.blockSize)e._block(o.subarray(16*l,16*(l+1))),l+=1;return a.splice(0,16*l),e},finalize:function(){const t=this;let e=t._buffer;const i=t._h;e=n.concat(e,[n.partial(1,1)]);for(let t=e.length+2;15&t;t++)e.push(0);for(e.push(Math.floor(t._length/4294967296)),e.push(0|t._length);e.length;)t._block(e.splice(0,16));return t.reset(),i},_init:[1732584193,4023233417,2562383102,271733878,3285377520],_key:[1518500249,1859775393,2400959708,3395469782],_f:function(t,e,n,i){return t<=19?e&n|~e&i:t<=39?e^n^i:t<=59?e&n|e&i|n&i:t<=79?e^n^i:void 0},_S:function(t,e){return e<<t|e>>>32-t},_block:function(t){const e=this,n=e._h,i=Array(80);for(let e=0;e<16;e++)i[e]=t[e];let a=n[0],r=n[1],s=n[2],o=n[3],l=n[4];for(let t=0;t<=79;t++){t>=16&&(i[t]=e._S(1,i[t-3]^i[t-8]^i[t-14]^i[t-16]));const n=e._S(5,a)+e._f(t,r,s,o)+l+i[t]+e._key[Math.floor(t/20)]|0;l=o,o=s,s=e._S(30,r),r=a,a=n;}n[0]=n[0]+a|0,n[1]=n[1]+r|0,n[2]=n[2]+s|0,n[3]=n[3]+o|0,n[4]=n[4]+l|0;}};const r=class{constructor(t){const e=this;e._tables=[[[],[],[],[],[]],[[],[],[],[],[]]],e._tables[0][0][0]||e._precompute();const n=e._tables[0][4],i=e._tables[1],a=t.length;let r,s,o,l=1;if(4!==a&&6!==a&&8!==a)throw new Error("invalid aes key size");for(e._key=[s=t.slice(0),o=[]],r=a;r<4*a+28;r++){let t=s[r-1];(r%a==0||8===a&&r%a==4)&&(t=n[t>>>24]<<24^n[t>>16&255]<<16^n[t>>8&255]<<8^n[255&t],r%a==0&&(t=t<<8^t>>>24^l<<24,l=l<<1^283*(l>>7))),s[r]=s[r-a]^t;}for(let t=0;r;t++,r--){const e=s[3&t?r:r-4];o[t]=r<=4||t<4?e:i[0][n[e>>>24]]^i[1][n[e>>16&255]]^i[2][n[e>>8&255]]^i[3][n[255&e]];}}encrypt(t){return this._crypt(t,0)}decrypt(t){return this._crypt(t,1)}_precompute(){const t=this._tables[0],e=this._tables[1],n=t[4],i=e[4],a=[],r=[];let s,o,l,_;for(let t=0;t<256;t++)r[(a[t]=t<<1^283*(t>>7))^t]=t;for(let d=s=0;!n[d];d^=o||1,s=r[s]||1){let r=s^s<<1^s<<2^s<<3^s<<4;r=r>>8^255&r^99,n[d]=r,i[r]=d,_=a[l=a[o=a[d]]];let c=16843009*_^65537*l^257*o^16843008*d,f=257*a[r]^16843008*r;for(let n=0;n<4;n++)t[n][d]=f=f<<24^f>>>8,e[n][r]=c=c<<24^c>>>8;}for(let n=0;n<5;n++)t[n]=t[n].slice(0),e[n]=e[n].slice(0);}_crypt(t,e){if(4!==t.length)throw new Error("invalid aes block size");const n=this._key[e],i=n.length/4-2,a=[0,0,0,0],r=this._tables[e],s=r[0],o=r[1],l=r[2],_=r[3],d=r[4];let c,f,u,h=t[0]^n[0],b=t[e?3:1]^n[1],p=t[2]^n[2],w=t[e?1:3]^n[3],x=4;for(let t=0;t<i;t++)c=s[h>>>24]^o[b>>16&255]^l[p>>8&255]^_[255&w]^n[x],f=s[b>>>24]^o[p>>16&255]^l[w>>8&255]^_[255&h]^n[x+1],u=s[p>>>24]^o[w>>16&255]^l[h>>8&255]^_[255&b]^n[x+2],w=s[w>>>24]^o[h>>16&255]^l[b>>8&255]^_[255&p]^n[x+3],x+=4,h=c,b=f,p=u;for(let t=0;t<4;t++)a[e?3&-t:t]=d[h>>>24]<<24^d[b>>16&255]<<16^d[p>>8&255]<<8^d[255&w]^n[x++],c=h,h=b,b=p,p=w,w=c;return a}},s=class{constructor(t,e){this._prf=t,this._initIv=e,this._iv=e;}reset(){this._iv=this._initIv;}update(t){return this.calculate(this._prf,t,this._iv)}incWord(t){if(255==(t>>24&255)){let e=t>>16&255,n=t>>8&255,i=255&t;255===e?(e=0,255===n?(n=0,255===i?i=0:++i):++n):++e,t=0,t+=e<<16,t+=n<<8,t+=i;}else t+=1<<24;return t}incCounter(t){0===(t[0]=this.incWord(t[0]))&&(t[1]=this.incWord(t[1]));}calculate(t,e,i){let a;if(!(a=e.length))return [];const r=n.bitLength(e);for(let n=0;n<a;n+=4){this.incCounter(i);const a=t.encrypt(i);e[n]^=a[0],e[n+1]^=a[1],e[n+2]^=a[2],e[n+3]^=a[3];}return n.clamp(e,r)}},o=class{constructor(t){const e=this,n=e._hash=a.sha1,i=[[],[]],r=n.prototype.blockSize/32;e._baseHash=[new n,new n],t.length>r&&(t=n.hash(t));for(let e=0;e<r;e++)i[0][e]=909522486^t[e],i[1][e]=1549556828^t[e];e._baseHash[0].update(i[0]),e._baseHash[1].update(i[1]),e._resultHash=new n(e._baseHash[0]);}reset(){const t=this;t._resultHash=new t._hash(t._baseHash[0]),t._updated=!1;}update(t){this._updated=!0,this._resultHash.update(t);}digest(){const t=this,e=t._resultHash.finalize(),n=new t._hash(t._baseHash[1]).update(e).finalize();return t.reset(),n}},l={name:"PBKDF2"},_=Object.assign({hash:{name:"HMAC"}},l),d=Object.assign({iterations:1e3,hash:{name:"SHA-1"}},l),c=["deriveBits"],f=[8,12,16],u=[16,24,32],h=[0,0,0,0],b=i.bytes,p=r,w=s,x=o;class g{constructor(t,e,n){Object.assign(this,{password:t,signed:e,strength:n-1,pendingInput:new Uint8Array(0)});}async append(t){const e=this;if(e.password){const n=A(t,0,f[e.strength]+2);await async function(t,e,n){await k(t,n,A(e,0,f[t.strength]));const i=A(e,f[t.strength]),a=t.keys.passwordVerification;if(a[0]!=i[0]||a[1]!=i[1])throw new Error("Invalid pasword")}(e,n,e.password),e.password=null,e.aesCtrGladman=new w(new p(e.keys.key),Array.from(h)),e.hmac=new x(e.keys.authentication),t=A(t,f[e.strength]+2);}return m(e,t,new Uint8Array(t.length-10-(t.length-10)%16),0,10,!0)}flush(){const t=this,e=t.pendingInput,n=A(e,0,e.length-10),i=A(e,e.length-10);let a=new Uint8Array(0);if(n.length){const e=b.toBits(n);t.hmac.update(e);const i=t.aesCtrGladman.update(e);a=b.fromBits(i);}let r=!0;if(t.signed){const e=A(b.fromBits(t.hmac.digest()),0,10);for(let t=0;t<10;t++)e[t]!=i[t]&&(r=!1);}return {valid:r,data:a}}}class y{constructor(t,e){Object.assign(this,{password:t,strength:e-1,pendingInput:new Uint8Array(0)});}async append(t){const e=this;let n=new Uint8Array(0);e.password&&(n=await async function(t,e){const n=crypto.getRandomValues(new Uint8Array(f[t.strength]));return await k(t,e,n),v(n,t.keys.passwordVerification)}(e,e.password),e.password=null,e.aesCtrGladman=new w(new p(e.keys.key),Array.from(h)),e.hmac=new x(e.keys.authentication));const i=new Uint8Array(n.length+t.length-t.length%16);return i.set(n,0),m(e,t,i,n.length,0)}flush(){const t=this;let e=new Uint8Array(0);if(t.pendingInput.length){const n=t.aesCtrGladman.update(b.toBits(t.pendingInput));t.hmac.update(n),e=b.fromBits(n);}const n=A(b.fromBits(t.hmac.digest()),0,10);return {data:v(e,n),signature:n}}}function m(t,e,n,i,a,r){const s=e.length-a;let o;for(t.pendingInput.length&&(e=v(t.pendingInput,e),n=function(t,e){if(e&&e>t.length){const n=t;(t=new Uint8Array(e)).set(n,0);}return t}(n,s-s%16)),o=0;o<=s-16;o+=16){const a=b.toBits(A(e,o,o+16));r&&t.hmac.update(a);const s=t.aesCtrGladman.update(a);r||t.hmac.update(s),n.set(b.fromBits(s),o+i);}return t.pendingInput=A(e,o),n}async function k(t,e,n){const i=(new TextEncoder).encode(e),a=await crypto.subtle.importKey("raw",i,_,!1,c),r=await crypto.subtle.deriveBits(Object.assign({salt:n},d),a,8*(2*u[t.strength]+2)),s=new Uint8Array(r);t.keys={key:b.toBits(A(s,0,u[t.strength])),authentication:b.toBits(A(s,u[t.strength],2*u[t.strength])),passwordVerification:A(s,2*u[t.strength])};}function v(t,e){let n=t;return t.length+e.length&&(n=new Uint8Array(t.length+e.length),n.set(t,0),n.set(e,t.length)),n}function A(t,e,n){return t.subarray(e,n)}class U{constructor(t,e){Object.assign(this,{password:t,passwordVerification:e}),E(this,t);}append(t){const e=this;if(e.password){const n=z(e,t.subarray(0,12));if(e.password=null,n[11]!=e.passwordVerification)throw new Error("Invalid pasword");t=t.subarray(12);}return z(e,t)}flush(){return {valid:!0,data:new Uint8Array(0)}}}class S{constructor(t,e){Object.assign(this,{password:t,passwordVerification:e}),E(this,t);}append(t){const e=this;let n,i;if(e.password){e.password=null;const a=crypto.getRandomValues(new Uint8Array(12));a[11]=e.passwordVerification,n=new Uint8Array(t.length+a.length),n.set(I(e,a),0),i=12;}else n=new Uint8Array(t.length),i=0;return n.set(I(e,t),i),n}flush(){return {data:new Uint8Array(0)}}}function z(t,e){const n=new Uint8Array(e.length);for(let i=0;i<e.length;i++)n[i]=M(t)^e[i],C(t,n[i]);return n}function I(t,e){const n=new Uint8Array(e.length);for(let i=0;i<e.length;i++)n[i]=M(t)^e[i],C(t,e[i]);return n}function E(t,n){t.keys=[305419896,591751049,878082192],t.crcKey0=new e(t.keys[0]),t.crcKey2=new e(t.keys[2]);for(let e=0;e<n.length;e++)C(t,n.charCodeAt(e));}function C(t,e){t.crcKey0.append([e]),t.keys[0]=~t.crcKey0.get(),t.keys[1]=j(t.keys[1]+B(t.keys[0])),t.keys[1]=j(Math.imul(t.keys[1],134775813)+1),t.crcKey2.append([t.keys[1]>>>24]),t.keys[2]=~t.crcKey2.get();}function M(t){const e=2|t.keys[2];return B(Math.imul(e,1^e)>>>8)}function B(t){return 255&t}function j(t){return 4294967295&t}class H{constructor(t,{signature:n,password:i,signed:a,compressed:r,zipCrypto:s,passwordVerification:o,encryptionStrength:l},{chunkSize:_}){const d=Boolean(i);Object.assign(this,{signature:n,encrypted:d,signed:a,compressed:r,inflate:r&&new t({chunkSize:_}),crc32:a&&new e,zipCrypto:s,decrypt:d&&s?new U(i,o):new g(i,a,l)});}async append(t){const e=this;return e.encrypted&&t.length&&(t=await e.decrypt.append(t)),e.compressed&&t.length&&(t=await e.inflate.append(t)),(!e.encrypted||e.zipCrypto)&&e.signed&&t.length&&e.crc32.append(t),t}async flush(){const t=this;let e,n=new Uint8Array(0);if(t.encrypted){const e=t.decrypt.flush();if(!e.valid)throw new Error("Invalid signature");n=e.data;}if((!t.encrypted||t.zipCrypto)&&t.signed){const n=new DataView(new Uint8Array(4).buffer);if(e=t.crc32.get(),n.setUint32(0,e),t.signature!=n.getUint32(0,!1))throw new Error("Invalid signature")}return t.compressed&&(n=await t.inflate.append(n)||new Uint8Array(0),await t.inflate.flush()),{data:n,signature:e}}}class V{constructor(t,{encrypted:n,signed:i,compressed:a,level:r,zipCrypto:s,password:o,passwordVerification:l,encryptionStrength:_},{chunkSize:d}){Object.assign(this,{encrypted:n,signed:i,compressed:a,deflate:a&&new t({level:r||5,chunkSize:d}),crc32:i&&new e,zipCrypto:s,encrypt:n&&s?new S(o,l):new y(o,_)});}async append(t){const e=this;let n=t;return e.compressed&&t.length&&(n=await e.deflate.append(t)),e.encrypted&&n.length&&(n=await e.encrypt.append(n)),(!e.encrypted||e.zipCrypto)&&e.signed&&t.length&&e.crc32.append(t),n}async flush(){const t=this;let e,n=new Uint8Array(0);if(t.compressed&&(n=await t.deflate.flush()||new Uint8Array(0)),t.encrypted){n=await t.encrypt.append(n);const i=t.encrypt.flush();e=i.signature;const a=new Uint8Array(n.length+i.data.length);a.set(n,0),a.set(i.data,n.length),n=a;}return t.encrypted&&!t.zipCrypto||!t.signed||(e=t.crc32.get()),{data:n,signature:e}}}const O={init(t){t.scripts&&t.scripts.length&&importScripts.apply(void 0,t.scripts);const e=t.options;let n;self.initCodec&&self.initCodec(),e.codecType.startsWith("deflate")?n=self.Deflate:e.codecType.startsWith("inflate")&&(n=self.Inflate),D=function(t,e,n){return e.codecType.startsWith("deflate")?new V(t,e,n):e.codecType.startsWith("inflate")?new H(t,e,n):void 0}(n,e,t.config);},append:async t=>({data:await D.append(t.data)}),flush:()=>D.flush()};let D;function L(t){return P(t.map((([t,e])=>new Array(t).fill(e,0,t))))}function P(t){return t.reduce(((t,e)=>t.concat(Array.isArray(e)?P(e):e)),[])}addEventListener("message",(async t=>{const e=t.data,n=e.type,i=O[n];if(i)try{e.data&&(e.data=new Uint8Array(e.data));const t=await i(e)||{};if(t.type=n,t.data)try{t.data=t.data.buffer,postMessage(t,[t.data]);}catch(e){postMessage(t);}else postMessage(t);}catch(t){postMessage({type:n,error:{message:t.message,stack:t.stack}});}}));const K=[0,1,2,3].concat(...L([[2,4],[2,5],[4,6],[4,7],[8,8],[8,9],[16,10],[16,11],[32,12],[32,13],[64,14],[64,15],[2,0],[1,16],[1,17],[2,18],[2,19],[4,20],[4,21],[8,22],[8,23],[16,24],[16,25],[32,26],[32,27],[64,28],[64,29]]));function R(){const t=this;function e(t,e){let n=0;do{n|=1&t,t>>>=1,n<<=1;}while(--e>0);return n>>>1}t.build_tree=function(n){const i=t.dyn_tree,a=t.stat_desc.static_tree,r=t.stat_desc.elems;let s,o,l,_=-1;for(n.heap_len=0,n.heap_max=573,s=0;s<r;s++)0!==i[2*s]?(n.heap[++n.heap_len]=_=s,n.depth[s]=0):i[2*s+1]=0;for(;n.heap_len<2;)l=n.heap[++n.heap_len]=_<2?++_:0,i[2*l]=1,n.depth[l]=0,n.opt_len--,a&&(n.static_len-=a[2*l+1]);for(t.max_code=_,s=Math.floor(n.heap_len/2);s>=1;s--)n.pqdownheap(i,s);l=r;do{s=n.heap[1],n.heap[1]=n.heap[n.heap_len--],n.pqdownheap(i,1),o=n.heap[1],n.heap[--n.heap_max]=s,n.heap[--n.heap_max]=o,i[2*l]=i[2*s]+i[2*o],n.depth[l]=Math.max(n.depth[s],n.depth[o])+1,i[2*s+1]=i[2*o+1]=l,n.heap[1]=l++,n.pqdownheap(i,1);}while(n.heap_len>=2);n.heap[--n.heap_max]=n.heap[1],function(e){const n=t.dyn_tree,i=t.stat_desc.static_tree,a=t.stat_desc.extra_bits,r=t.stat_desc.extra_base,s=t.stat_desc.max_length;let o,l,_,d,c,f,u=0;for(d=0;d<=15;d++)e.bl_count[d]=0;for(n[2*e.heap[e.heap_max]+1]=0,o=e.heap_max+1;o<573;o++)l=e.heap[o],d=n[2*n[2*l+1]+1]+1,d>s&&(d=s,u++),n[2*l+1]=d,l>t.max_code||(e.bl_count[d]++,c=0,l>=r&&(c=a[l-r]),f=n[2*l],e.opt_len+=f*(d+c),i&&(e.static_len+=f*(i[2*l+1]+c)));if(0!==u){do{for(d=s-1;0===e.bl_count[d];)d--;e.bl_count[d]--,e.bl_count[d+1]+=2,e.bl_count[s]--,u-=2;}while(u>0);for(d=s;0!==d;d--)for(l=e.bl_count[d];0!==l;)_=e.heap[--o],_>t.max_code||(n[2*_+1]!=d&&(e.opt_len+=(d-n[2*_+1])*n[2*_],n[2*_+1]=d),l--);}}(n),function(t,n,i){const a=[];let r,s,o,l=0;for(r=1;r<=15;r++)a[r]=l=l+i[r-1]<<1;for(s=0;s<=n;s++)o=t[2*s+1],0!==o&&(t[2*s]=e(a[o]++,o));}(i,t.max_code,n.bl_count);};}function W(t,e,n,i,a){const r=this;r.static_tree=t,r.extra_bits=e,r.extra_base=n,r.elems=i,r.max_length=a;}function G(t,e,n,i,a){const r=this;r.good_length=t,r.max_lazy=e,r.nice_length=n,r.max_chain=i,r.func=a;}R._length_code=[0,1,2,3,4,5,6,7].concat(...L([[2,8],[2,9],[2,10],[2,11],[4,12],[4,13],[4,14],[4,15],[8,16],[8,17],[8,18],[8,19],[16,20],[16,21],[16,22],[16,23],[32,24],[32,25],[32,26],[31,27],[1,28]])),R.base_length=[0,1,2,3,4,5,6,7,8,10,12,14,16,20,24,28,32,40,48,56,64,80,96,112,128,160,192,224,0],R.base_dist=[0,1,2,3,4,6,8,12,16,24,32,48,64,96,128,192,256,384,512,768,1024,1536,2048,3072,4096,6144,8192,12288,16384,24576],R.d_code=function(t){return t<256?K[t]:K[256+(t>>>7)]},R.extra_lbits=[0,0,0,0,0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,0],R.extra_dbits=[0,0,0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13],R.extra_blbits=[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,3,7],R.bl_order=[16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15],W.static_ltree=[12,8,140,8,76,8,204,8,44,8,172,8,108,8,236,8,28,8,156,8,92,8,220,8,60,8,188,8,124,8,252,8,2,8,130,8,66,8,194,8,34,8,162,8,98,8,226,8,18,8,146,8,82,8,210,8,50,8,178,8,114,8,242,8,10,8,138,8,74,8,202,8,42,8,170,8,106,8,234,8,26,8,154,8,90,8,218,8,58,8,186,8,122,8,250,8,6,8,134,8,70,8,198,8,38,8,166,8,102,8,230,8,22,8,150,8,86,8,214,8,54,8,182,8,118,8,246,8,14,8,142,8,78,8,206,8,46,8,174,8,110,8,238,8,30,8,158,8,94,8,222,8,62,8,190,8,126,8,254,8,1,8,129,8,65,8,193,8,33,8,161,8,97,8,225,8,17,8,145,8,81,8,209,8,49,8,177,8,113,8,241,8,9,8,137,8,73,8,201,8,41,8,169,8,105,8,233,8,25,8,153,8,89,8,217,8,57,8,185,8,121,8,249,8,5,8,133,8,69,8,197,8,37,8,165,8,101,8,229,8,21,8,149,8,85,8,213,8,53,8,181,8,117,8,245,8,13,8,141,8,77,8,205,8,45,8,173,8,109,8,237,8,29,8,157,8,93,8,221,8,61,8,189,8,125,8,253,8,19,9,275,9,147,9,403,9,83,9,339,9,211,9,467,9,51,9,307,9,179,9,435,9,115,9,371,9,243,9,499,9,11,9,267,9,139,9,395,9,75,9,331,9,203,9,459,9,43,9,299,9,171,9,427,9,107,9,363,9,235,9,491,9,27,9,283,9,155,9,411,9,91,9,347,9,219,9,475,9,59,9,315,9,187,9,443,9,123,9,379,9,251,9,507,9,7,9,263,9,135,9,391,9,71,9,327,9,199,9,455,9,39,9,295,9,167,9,423,9,103,9,359,9,231,9,487,9,23,9,279,9,151,9,407,9,87,9,343,9,215,9,471,9,55,9,311,9,183,9,439,9,119,9,375,9,247,9,503,9,15,9,271,9,143,9,399,9,79,9,335,9,207,9,463,9,47,9,303,9,175,9,431,9,111,9,367,9,239,9,495,9,31,9,287,9,159,9,415,9,95,9,351,9,223,9,479,9,63,9,319,9,191,9,447,9,127,9,383,9,255,9,511,9,0,7,64,7,32,7,96,7,16,7,80,7,48,7,112,7,8,7,72,7,40,7,104,7,24,7,88,7,56,7,120,7,4,7,68,7,36,7,100,7,20,7,84,7,52,7,116,7,3,8,131,8,67,8,195,8,35,8,163,8,99,8,227,8],W.static_dtree=[0,5,16,5,8,5,24,5,4,5,20,5,12,5,28,5,2,5,18,5,10,5,26,5,6,5,22,5,14,5,30,5,1,5,17,5,9,5,25,5,5,5,21,5,13,5,29,5,3,5,19,5,11,5,27,5,7,5,23,5],W.static_l_desc=new W(W.static_ltree,R.extra_lbits,257,286,15),W.static_d_desc=new W(W.static_dtree,R.extra_dbits,0,30,15),W.static_bl_desc=new W(null,R.extra_blbits,0,19,7);const T=[new G(0,0,0,0,0),new G(4,4,8,4,1),new G(4,5,16,8,1),new G(4,6,32,32,1),new G(4,4,16,16,2),new G(8,16,32,32,2),new G(8,16,128,128,2),new G(8,32,128,256,2),new G(32,128,258,1024,2),new G(32,258,258,4096,2)],q=["need dictionary","stream end","","","stream error","data error","","buffer error","",""];function F(t,e,n,i){const a=t[2*e],r=t[2*n];return a<r||a==r&&i[e]<=i[n]}function J(){const t=this;let e,n,i,a,r,s,o,l,_,d,c,f,u,h,b,p,w,x,g,y,m,k,v,A,U,S,z,I,E,C,M,B,j;const H=new R,V=new R,O=new R;let D,L,P,K,G,J,N,Q;function X(){let e;for(e=0;e<286;e++)M[2*e]=0;for(e=0;e<30;e++)B[2*e]=0;for(e=0;e<19;e++)j[2*e]=0;M[512]=1,t.opt_len=t.static_len=0,P=G=0;}function Y(t,e){let n,i=-1,a=t[1],r=0,s=7,o=4;0===a&&(s=138,o=3),t[2*(e+1)+1]=65535;for(let l=0;l<=e;l++)n=a,a=t[2*(l+1)+1],++r<s&&n==a||(r<o?j[2*n]+=r:0!==n?(n!=i&&j[2*n]++,j[32]++):r<=10?j[34]++:j[36]++,r=0,i=n,0===a?(s=138,o=3):n==a?(s=6,o=3):(s=7,o=4));}function Z(e){t.pending_buf[t.pending++]=e;}function $(t){Z(255&t),Z(t>>>8&255);}function tt(t,e){let n;const i=e;Q>16-i?(n=t,N|=n<<Q&65535,$(N),N=n>>>16-Q,Q+=i-16):(N|=t<<Q&65535,Q+=i);}function et(t,e){const n=2*t;tt(65535&e[n],65535&e[n+1]);}function nt(t,e){let n,i,a=-1,r=t[1],s=0,o=7,l=4;for(0===r&&(o=138,l=3),n=0;n<=e;n++)if(i=r,r=t[2*(n+1)+1],!(++s<o&&i==r)){if(s<l)do{et(i,j);}while(0!=--s);else 0!==i?(i!=a&&(et(i,j),s--),et(16,j),tt(s-3,2)):s<=10?(et(17,j),tt(s-3,3)):(et(18,j),tt(s-11,7));s=0,a=i,0===r?(o=138,l=3):i==r?(o=6,l=3):(o=7,l=4);}}function it(){16==Q?($(N),N=0,Q=0):Q>=8&&(Z(255&N),N>>>=8,Q-=8);}function at(e,n){let i,a,r;if(t.pending_buf[K+2*P]=e>>>8&255,t.pending_buf[K+2*P+1]=255&e,t.pending_buf[D+P]=255&n,P++,0===e?M[2*n]++:(G++,e--,M[2*(R._length_code[n]+256+1)]++,B[2*R.d_code(e)]++),0==(8191&P)&&z>2){for(i=8*P,a=m-w,r=0;r<30;r++)i+=B[2*r]*(5+R.extra_dbits[r]);if(i>>>=3,G<Math.floor(P/2)&&i<Math.floor(a/2))return !0}return P==L-1}function rt(e,n){let i,a,r,s,o=0;if(0!==P)do{i=t.pending_buf[K+2*o]<<8&65280|255&t.pending_buf[K+2*o+1],a=255&t.pending_buf[D+o],o++,0===i?et(a,e):(r=R._length_code[a],et(r+256+1,e),s=R.extra_lbits[r],0!==s&&(a-=R.base_length[r],tt(a,s)),i--,r=R.d_code(i),et(r,n),s=R.extra_dbits[r],0!==s&&(i-=R.base_dist[r],tt(i,s)));}while(o<P);et(256,e),J=e[513];}function st(){Q>8?$(N):Q>0&&Z(255&N),N=0,Q=0;}function ot(e,n,i){tt(0+(i?1:0),3),function(e,n,i){st(),J=8,$(n),$(~n),t.pending_buf.set(l.subarray(e,e+n),t.pending),t.pending+=n;}(e,n);}function lt(e,n,i){let a,r,s=0;z>0?(H.build_tree(t),V.build_tree(t),s=function(){let e;for(Y(M,H.max_code),Y(B,V.max_code),O.build_tree(t),e=18;e>=3&&0===j[2*R.bl_order[e]+1];e--);return t.opt_len+=3*(e+1)+5+5+4,e}(),a=t.opt_len+3+7>>>3,r=t.static_len+3+7>>>3,r<=a&&(a=r)):a=r=n+5,n+4<=a&&-1!=e?ot(e,n,i):r==a?(tt(2+(i?1:0),3),rt(W.static_ltree,W.static_dtree)):(tt(4+(i?1:0),3),function(t,e,n){let i;for(tt(t-257,5),tt(e-1,5),tt(n-4,4),i=0;i<n;i++)tt(j[2*R.bl_order[i]+1],3);nt(M,t-1),nt(B,e-1);}(H.max_code+1,V.max_code+1,s+1),rt(M,B)),X(),i&&st();}function _t(t){lt(w>=0?w:-1,m-w,t),w=m,e.flush_pending();}function dt(){let t,n,i,a;do{if(a=_-v-m,0===a&&0===m&&0===v)a=r;else if(-1==a)a--;else if(m>=r+r-262){l.set(l.subarray(r,r+r),0),k-=r,m-=r,w-=r,t=u,i=t;do{n=65535&c[--i],c[i]=n>=r?n-r:0;}while(0!=--t);t=r,i=t;do{n=65535&d[--i],d[i]=n>=r?n-r:0;}while(0!=--t);a+=r;}if(0===e.avail_in)return;t=e.read_buf(l,m+v,a),v+=t,v>=3&&(f=255&l[m],f=(f<<p^255&l[m+1])&b);}while(v<262&&0!==e.avail_in)}function ct(t){let e,n,i=U,a=m,s=A;const _=m>r-262?m-(r-262):0;let c=C;const f=o,u=m+258;let h=l[a+s-1],b=l[a+s];A>=E&&(i>>=2),c>v&&(c=v);do{if(e=t,l[e+s]==b&&l[e+s-1]==h&&l[e]==l[a]&&l[++e]==l[a+1]){a+=2,e++;do{}while(l[++a]==l[++e]&&l[++a]==l[++e]&&l[++a]==l[++e]&&l[++a]==l[++e]&&l[++a]==l[++e]&&l[++a]==l[++e]&&l[++a]==l[++e]&&l[++a]==l[++e]&&a<u);if(n=258-(u-a),a=u-258,n>s){if(k=t,s=n,n>=c)break;h=l[a+s-1],b=l[a+s];}}}while((t=65535&d[t&f])>_&&0!=--i);return s<=v?s:v}function ft(e){return e.total_in=e.total_out=0,e.msg=null,t.pending=0,t.pending_out=0,n=113,a=0,H.dyn_tree=M,H.stat_desc=W.static_l_desc,V.dyn_tree=B,V.stat_desc=W.static_d_desc,O.dyn_tree=j,O.stat_desc=W.static_bl_desc,N=0,Q=0,J=8,X(),function(){_=2*r,c[u-1]=0;for(let t=0;t<u-1;t++)c[t]=0;S=T[z].max_lazy,E=T[z].good_length,C=T[z].nice_length,U=T[z].max_chain,m=0,w=0,v=0,x=A=2,y=0,f=0;}(),0}t.depth=[],t.bl_count=[],t.heap=[],M=[],B=[],j=[],t.pqdownheap=function(e,n){const i=t.heap,a=i[n];let r=n<<1;for(;r<=t.heap_len&&(r<t.heap_len&&F(e,i[r+1],i[r],t.depth)&&r++,!F(e,a,i[r],t.depth));)i[n]=i[r],n=r,r<<=1;i[n]=a;},t.deflateInit=function(e,n,a,_,f,w){return _||(_=8),f||(f=8),w||(w=0),e.msg=null,-1==n&&(n=6),f<1||f>9||8!=_||a<9||a>15||n<0||n>9||w<0||w>2?-2:(e.dstate=t,s=a,r=1<<s,o=r-1,h=f+7,u=1<<h,b=u-1,p=Math.floor((h+3-1)/3),l=new Uint8Array(2*r),d=[],c=[],L=1<<f+6,t.pending_buf=new Uint8Array(4*L),i=4*L,K=Math.floor(L/2),D=3*L,z=n,I=w,ft(e))},t.deflateEnd=function(){return 42!=n&&113!=n&&666!=n?-2:(t.pending_buf=null,c=null,d=null,l=null,t.dstate=null,113==n?-3:0)},t.deflateParams=function(t,e,n){let i=0;return -1==e&&(e=6),e<0||e>9||n<0||n>2?-2:(T[z].func!=T[e].func&&0!==t.total_in&&(i=t.deflate(1)),z!=e&&(z=e,S=T[z].max_lazy,E=T[z].good_length,C=T[z].nice_length,U=T[z].max_chain),I=n,i)},t.deflateSetDictionary=function(t,e,i){let a,s=i,_=0;if(!e||42!=n)return -2;if(s<3)return 0;for(s>r-262&&(s=r-262,_=i-s),l.set(e.subarray(_,_+s),0),m=s,w=s,f=255&l[0],f=(f<<p^255&l[1])&b,a=0;a<=s-3;a++)f=(f<<p^255&l[a+2])&b,d[a&o]=c[f],c[f]=a;return 0},t.deflate=function(_,h){let U,E,C,M,B;if(h>4||h<0)return -2;if(!_.next_out||!_.next_in&&0!==_.avail_in||666==n&&4!=h)return _.msg=q[4],-2;if(0===_.avail_out)return _.msg=q[7],-5;var j;if(e=_,M=a,a=h,42==n&&(E=8+(s-8<<4)<<8,C=(z-1&255)>>1,C>3&&(C=3),E|=C<<6,0!==m&&(E|=32),E+=31-E%31,n=113,Z((j=E)>>8&255),Z(255&j)),0!==t.pending){if(e.flush_pending(),0===e.avail_out)return a=-1,0}else if(0===e.avail_in&&h<=M&&4!=h)return e.msg=q[7],-5;if(666==n&&0!==e.avail_in)return _.msg=q[7],-5;if(0!==e.avail_in||0!==v||0!=h&&666!=n){switch(B=-1,T[z].func){case 0:B=function(t){let n,a=65535;for(a>i-5&&(a=i-5);;){if(v<=1){if(dt(),0===v&&0==t)return 0;if(0===v)break}if(m+=v,v=0,n=w+a,(0===m||m>=n)&&(v=m-n,m=n,_t(!1),0===e.avail_out))return 0;if(m-w>=r-262&&(_t(!1),0===e.avail_out))return 0}return _t(4==t),0===e.avail_out?4==t?2:0:4==t?3:1}(h);break;case 1:B=function(t){let n,i=0;for(;;){if(v<262){if(dt(),v<262&&0==t)return 0;if(0===v)break}if(v>=3&&(f=(f<<p^255&l[m+2])&b,i=65535&c[f],d[m&o]=c[f],c[f]=m),0!==i&&(m-i&65535)<=r-262&&2!=I&&(x=ct(i)),x>=3)if(n=at(m-k,x-3),v-=x,x<=S&&v>=3){x--;do{m++,f=(f<<p^255&l[m+2])&b,i=65535&c[f],d[m&o]=c[f],c[f]=m;}while(0!=--x);m++;}else m+=x,x=0,f=255&l[m],f=(f<<p^255&l[m+1])&b;else n=at(0,255&l[m]),v--,m++;if(n&&(_t(!1),0===e.avail_out))return 0}return _t(4==t),0===e.avail_out?4==t?2:0:4==t?3:1}(h);break;case 2:B=function(t){let n,i,a=0;for(;;){if(v<262){if(dt(),v<262&&0==t)return 0;if(0===v)break}if(v>=3&&(f=(f<<p^255&l[m+2])&b,a=65535&c[f],d[m&o]=c[f],c[f]=m),A=x,g=k,x=2,0!==a&&A<S&&(m-a&65535)<=r-262&&(2!=I&&(x=ct(a)),x<=5&&(1==I||3==x&&m-k>4096)&&(x=2)),A>=3&&x<=A){i=m+v-3,n=at(m-1-g,A-3),v-=A-1,A-=2;do{++m<=i&&(f=(f<<p^255&l[m+2])&b,a=65535&c[f],d[m&o]=c[f],c[f]=m);}while(0!=--A);if(y=0,x=2,m++,n&&(_t(!1),0===e.avail_out))return 0}else if(0!==y){if(n=at(0,255&l[m-1]),n&&_t(!1),m++,v--,0===e.avail_out)return 0}else y=1,m++,v--;}return 0!==y&&(n=at(0,255&l[m-1]),y=0),_t(4==t),0===e.avail_out?4==t?2:0:4==t?3:1}(h);}if(2!=B&&3!=B||(n=666),0==B||2==B)return 0===e.avail_out&&(a=-1),0;if(1==B){if(1==h)tt(2,3),et(256,W.static_ltree),it(),1+J+10-Q<9&&(tt(2,3),et(256,W.static_ltree),it()),J=7;else if(ot(0,0,!1),3==h)for(U=0;U<u;U++)c[U]=0;if(e.flush_pending(),0===e.avail_out)return a=-1,0}}return 4!=h?0:1};}function N(){const t=this;t.next_in_index=0,t.next_out_index=0,t.avail_in=0,t.total_in=0,t.avail_out=0,t.total_out=0;}function Q(t){const e=new N,n=(i=t&&t.chunkSize?t.chunkSize:65536)+5*(Math.floor(i/16383)+1);var i;const a=new Uint8Array(n);let r=t?t.level:-1;void 0===r&&(r=-1),e.deflateInit(r),e.next_out=a,this.append=function(t,i){let r,s,o=0,l=0,_=0;const d=[];if(t.length){e.next_in_index=0,e.next_in=t,e.avail_in=t.length;do{if(e.next_out_index=0,e.avail_out=n,r=e.deflate(0),0!=r)throw new Error("deflating: "+e.msg);e.next_out_index&&(e.next_out_index==n?d.push(new Uint8Array(a)):d.push(a.slice(0,e.next_out_index))),_+=e.next_out_index,i&&e.next_in_index>0&&e.next_in_index!=o&&(i(e.next_in_index),o=e.next_in_index);}while(e.avail_in>0||0===e.avail_out);return d.length>1?(s=new Uint8Array(_),d.forEach((function(t){s.set(t,l),l+=t.length;}))):s=d[0]||new Uint8Array(0),s}},this.flush=function(){let t,i,r=0,s=0;const o=[];do{if(e.next_out_index=0,e.avail_out=n,t=e.deflate(4),1!=t&&0!=t)throw new Error("deflating: "+e.msg);n-e.avail_out>0&&o.push(a.slice(0,e.next_out_index)),s+=e.next_out_index;}while(e.avail_in>0||0===e.avail_out);return e.deflateEnd(),i=new Uint8Array(s),o.forEach((function(t){i.set(t,r),r+=t.length;})),i};}N.prototype={deflateInit:function(t,e){const n=this;return n.dstate=new J,e||(e=15),n.dstate.deflateInit(n,t,e)},deflate:function(t){const e=this;return e.dstate?e.dstate.deflate(e,t):-2},deflateEnd:function(){const t=this;if(!t.dstate)return -2;const e=t.dstate.deflateEnd();return t.dstate=null,e},deflateParams:function(t,e){const n=this;return n.dstate?n.dstate.deflateParams(n,t,e):-2},deflateSetDictionary:function(t,e){const n=this;return n.dstate?n.dstate.deflateSetDictionary(n,t,e):-2},read_buf:function(t,e,n){const i=this;let a=i.avail_in;return a>n&&(a=n),0===a?0:(i.avail_in-=a,t.set(i.next_in.subarray(i.next_in_index,i.next_in_index+a),e),i.next_in_index+=a,i.total_in+=a,a)},flush_pending:function(){const t=this;let e=t.dstate.pending;e>t.avail_out&&(e=t.avail_out),0!==e&&(t.next_out.set(t.dstate.pending_buf.subarray(t.dstate.pending_out,t.dstate.pending_out+e),t.next_out_index),t.next_out_index+=e,t.dstate.pending_out+=e,t.total_out+=e,t.avail_out-=e,t.dstate.pending-=e,0===t.dstate.pending&&(t.dstate.pending_out=0));}};const X=[0,1,3,7,15,31,63,127,255,511,1023,2047,4095,8191,16383,32767,65535],Y=[96,7,256,0,8,80,0,8,16,84,8,115,82,7,31,0,8,112,0,8,48,0,9,192,80,7,10,0,8,96,0,8,32,0,9,160,0,8,0,0,8,128,0,8,64,0,9,224,80,7,6,0,8,88,0,8,24,0,9,144,83,7,59,0,8,120,0,8,56,0,9,208,81,7,17,0,8,104,0,8,40,0,9,176,0,8,8,0,8,136,0,8,72,0,9,240,80,7,4,0,8,84,0,8,20,85,8,227,83,7,43,0,8,116,0,8,52,0,9,200,81,7,13,0,8,100,0,8,36,0,9,168,0,8,4,0,8,132,0,8,68,0,9,232,80,7,8,0,8,92,0,8,28,0,9,152,84,7,83,0,8,124,0,8,60,0,9,216,82,7,23,0,8,108,0,8,44,0,9,184,0,8,12,0,8,140,0,8,76,0,9,248,80,7,3,0,8,82,0,8,18,85,8,163,83,7,35,0,8,114,0,8,50,0,9,196,81,7,11,0,8,98,0,8,34,0,9,164,0,8,2,0,8,130,0,8,66,0,9,228,80,7,7,0,8,90,0,8,26,0,9,148,84,7,67,0,8,122,0,8,58,0,9,212,82,7,19,0,8,106,0,8,42,0,9,180,0,8,10,0,8,138,0,8,74,0,9,244,80,7,5,0,8,86,0,8,22,192,8,0,83,7,51,0,8,118,0,8,54,0,9,204,81,7,15,0,8,102,0,8,38,0,9,172,0,8,6,0,8,134,0,8,70,0,9,236,80,7,9,0,8,94,0,8,30,0,9,156,84,7,99,0,8,126,0,8,62,0,9,220,82,7,27,0,8,110,0,8,46,0,9,188,0,8,14,0,8,142,0,8,78,0,9,252,96,7,256,0,8,81,0,8,17,85,8,131,82,7,31,0,8,113,0,8,49,0,9,194,80,7,10,0,8,97,0,8,33,0,9,162,0,8,1,0,8,129,0,8,65,0,9,226,80,7,6,0,8,89,0,8,25,0,9,146,83,7,59,0,8,121,0,8,57,0,9,210,81,7,17,0,8,105,0,8,41,0,9,178,0,8,9,0,8,137,0,8,73,0,9,242,80,7,4,0,8,85,0,8,21,80,8,258,83,7,43,0,8,117,0,8,53,0,9,202,81,7,13,0,8,101,0,8,37,0,9,170,0,8,5,0,8,133,0,8,69,0,9,234,80,7,8,0,8,93,0,8,29,0,9,154,84,7,83,0,8,125,0,8,61,0,9,218,82,7,23,0,8,109,0,8,45,0,9,186,0,8,13,0,8,141,0,8,77,0,9,250,80,7,3,0,8,83,0,8,19,85,8,195,83,7,35,0,8,115,0,8,51,0,9,198,81,7,11,0,8,99,0,8,35,0,9,166,0,8,3,0,8,131,0,8,67,0,9,230,80,7,7,0,8,91,0,8,27,0,9,150,84,7,67,0,8,123,0,8,59,0,9,214,82,7,19,0,8,107,0,8,43,0,9,182,0,8,11,0,8,139,0,8,75,0,9,246,80,7,5,0,8,87,0,8,23,192,8,0,83,7,51,0,8,119,0,8,55,0,9,206,81,7,15,0,8,103,0,8,39,0,9,174,0,8,7,0,8,135,0,8,71,0,9,238,80,7,9,0,8,95,0,8,31,0,9,158,84,7,99,0,8,127,0,8,63,0,9,222,82,7,27,0,8,111,0,8,47,0,9,190,0,8,15,0,8,143,0,8,79,0,9,254,96,7,256,0,8,80,0,8,16,84,8,115,82,7,31,0,8,112,0,8,48,0,9,193,80,7,10,0,8,96,0,8,32,0,9,161,0,8,0,0,8,128,0,8,64,0,9,225,80,7,6,0,8,88,0,8,24,0,9,145,83,7,59,0,8,120,0,8,56,0,9,209,81,7,17,0,8,104,0,8,40,0,9,177,0,8,8,0,8,136,0,8,72,0,9,241,80,7,4,0,8,84,0,8,20,85,8,227,83,7,43,0,8,116,0,8,52,0,9,201,81,7,13,0,8,100,0,8,36,0,9,169,0,8,4,0,8,132,0,8,68,0,9,233,80,7,8,0,8,92,0,8,28,0,9,153,84,7,83,0,8,124,0,8,60,0,9,217,82,7,23,0,8,108,0,8,44,0,9,185,0,8,12,0,8,140,0,8,76,0,9,249,80,7,3,0,8,82,0,8,18,85,8,163,83,7,35,0,8,114,0,8,50,0,9,197,81,7,11,0,8,98,0,8,34,0,9,165,0,8,2,0,8,130,0,8,66,0,9,229,80,7,7,0,8,90,0,8,26,0,9,149,84,7,67,0,8,122,0,8,58,0,9,213,82,7,19,0,8,106,0,8,42,0,9,181,0,8,10,0,8,138,0,8,74,0,9,245,80,7,5,0,8,86,0,8,22,192,8,0,83,7,51,0,8,118,0,8,54,0,9,205,81,7,15,0,8,102,0,8,38,0,9,173,0,8,6,0,8,134,0,8,70,0,9,237,80,7,9,0,8,94,0,8,30,0,9,157,84,7,99,0,8,126,0,8,62,0,9,221,82,7,27,0,8,110,0,8,46,0,9,189,0,8,14,0,8,142,0,8,78,0,9,253,96,7,256,0,8,81,0,8,17,85,8,131,82,7,31,0,8,113,0,8,49,0,9,195,80,7,10,0,8,97,0,8,33,0,9,163,0,8,1,0,8,129,0,8,65,0,9,227,80,7,6,0,8,89,0,8,25,0,9,147,83,7,59,0,8,121,0,8,57,0,9,211,81,7,17,0,8,105,0,8,41,0,9,179,0,8,9,0,8,137,0,8,73,0,9,243,80,7,4,0,8,85,0,8,21,80,8,258,83,7,43,0,8,117,0,8,53,0,9,203,81,7,13,0,8,101,0,8,37,0,9,171,0,8,5,0,8,133,0,8,69,0,9,235,80,7,8,0,8,93,0,8,29,0,9,155,84,7,83,0,8,125,0,8,61,0,9,219,82,7,23,0,8,109,0,8,45,0,9,187,0,8,13,0,8,141,0,8,77,0,9,251,80,7,3,0,8,83,0,8,19,85,8,195,83,7,35,0,8,115,0,8,51,0,9,199,81,7,11,0,8,99,0,8,35,0,9,167,0,8,3,0,8,131,0,8,67,0,9,231,80,7,7,0,8,91,0,8,27,0,9,151,84,7,67,0,8,123,0,8,59,0,9,215,82,7,19,0,8,107,0,8,43,0,9,183,0,8,11,0,8,139,0,8,75,0,9,247,80,7,5,0,8,87,0,8,23,192,8,0,83,7,51,0,8,119,0,8,55,0,9,207,81,7,15,0,8,103,0,8,39,0,9,175,0,8,7,0,8,135,0,8,71,0,9,239,80,7,9,0,8,95,0,8,31,0,9,159,84,7,99,0,8,127,0,8,63,0,9,223,82,7,27,0,8,111,0,8,47,0,9,191,0,8,15,0,8,143,0,8,79,0,9,255],Z=[80,5,1,87,5,257,83,5,17,91,5,4097,81,5,5,89,5,1025,85,5,65,93,5,16385,80,5,3,88,5,513,84,5,33,92,5,8193,82,5,9,90,5,2049,86,5,129,192,5,24577,80,5,2,87,5,385,83,5,25,91,5,6145,81,5,7,89,5,1537,85,5,97,93,5,24577,80,5,4,88,5,769,84,5,49,92,5,12289,82,5,13,90,5,3073,86,5,193,192,5,24577],$=[3,4,5,6,7,8,9,10,11,13,15,17,19,23,27,31,35,43,51,59,67,83,99,115,131,163,195,227,258,0,0],tt=[0,0,0,0,0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,0,112,112],et=[1,2,3,4,5,7,9,13,17,25,33,49,65,97,129,193,257,385,513,769,1025,1537,2049,3073,4097,6145,8193,12289,16385,24577],nt=[0,0,0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13];function it(){let t,e,n,i,a,r;function s(t,e,s,o,l,_,d,c,f,u,h){let b,p,w,x,g,y,m,k,v,A,U,S,z,I,E;A=0,g=s;do{n[t[e+A]]++,A++,g--;}while(0!==g);if(n[0]==s)return d[0]=-1,c[0]=0,0;for(k=c[0],y=1;y<=15&&0===n[y];y++);for(m=y,k<y&&(k=y),g=15;0!==g&&0===n[g];g--);for(w=g,k>g&&(k=g),c[0]=k,I=1<<y;y<g;y++,I<<=1)if((I-=n[y])<0)return -3;if((I-=n[g])<0)return -3;for(n[g]+=I,r[1]=y=0,A=1,z=2;0!=--g;)r[z]=y+=n[A],z++,A++;g=0,A=0;do{0!==(y=t[e+A])&&(h[r[y]++]=g),A++;}while(++g<s);for(s=r[w],r[0]=g=0,A=0,x=-1,S=-k,a[0]=0,U=0,E=0;m<=w;m++)for(b=n[m];0!=b--;){for(;m>S+k;){if(x++,S+=k,E=w-S,E=E>k?k:E,(p=1<<(y=m-S))>b+1&&(p-=b+1,z=m,y<E))for(;++y<E&&!((p<<=1)<=n[++z]);)p-=n[z];if(E=1<<y,u[0]+E>1440)return -3;a[x]=U=u[0],u[0]+=E,0!==x?(r[x]=g,i[0]=y,i[1]=k,y=g>>>S-k,i[2]=U-a[x-1]-y,f.set(i,3*(a[x-1]+y))):d[0]=U;}for(i[1]=m-S,A>=s?i[0]=192:h[A]<o?(i[0]=h[A]<256?0:96,i[2]=h[A++]):(i[0]=_[h[A]-o]+16+64,i[2]=l[h[A++]-o]),p=1<<m-S,y=g>>>S;y<E;y+=p)f.set(i,3*(U+y));for(y=1<<m-1;0!=(g&y);y>>>=1)g^=y;for(g^=y,v=(1<<S)-1;(g&v)!=r[x];)x--,S-=k,v=(1<<S)-1;}return 0!==I&&1!=w?-5:0}function o(s){let o;for(t||(t=[],e=[],n=new Int32Array(16),i=[],a=new Int32Array(15),r=new Int32Array(16)),e.length<s&&(e=[]),o=0;o<s;o++)e[o]=0;for(o=0;o<16;o++)n[o]=0;for(o=0;o<3;o++)i[o]=0;a.set(n.subarray(0,15),0),r.set(n.subarray(0,16),0);}this.inflate_trees_bits=function(n,i,a,r,l){let _;return o(19),t[0]=0,_=s(n,0,19,19,null,null,a,i,r,t,e),-3==_?l.msg="oversubscribed dynamic bit lengths tree":-5!=_&&0!==i[0]||(l.msg="incomplete dynamic bit lengths tree",_=-3),_},this.inflate_trees_dynamic=function(n,i,a,r,l,_,d,c,f){let u;return o(288),t[0]=0,u=s(a,0,n,257,$,tt,_,r,c,t,e),0!=u||0===r[0]?(-3==u?f.msg="oversubscribed literal/length tree":-4!=u&&(f.msg="incomplete literal/length tree",u=-3),u):(o(288),u=s(a,n,i,0,et,nt,d,l,c,t,e),0!=u||0===l[0]&&n>257?(-3==u?f.msg="oversubscribed distance tree":-5==u?(f.msg="incomplete distance tree",u=-3):-4!=u&&(f.msg="empty distance tree with lengths",u=-3),u):0)};}function at(){const t=this;let e,n,i,a,r=0,s=0,o=0,l=0,_=0,d=0,c=0,f=0,u=0,h=0;function b(t,e,n,i,a,r,s,o){let l,_,d,c,f,u,h,b,p,w,x,g,y,m,k,v;h=o.next_in_index,b=o.avail_in,f=s.bitb,u=s.bitk,p=s.write,w=p<s.read?s.read-p-1:s.end-p,x=X[t],g=X[e];do{for(;u<20;)b--,f|=(255&o.read_byte(h++))<<u,u+=8;if(l=f&x,_=n,d=i,v=3*(d+l),0!==(c=_[v]))for(;;){if(f>>=_[v+1],u-=_[v+1],0!=(16&c)){for(c&=15,y=_[v+2]+(f&X[c]),f>>=c,u-=c;u<15;)b--,f|=(255&o.read_byte(h++))<<u,u+=8;for(l=f&g,_=a,d=r,v=3*(d+l),c=_[v];;){if(f>>=_[v+1],u-=_[v+1],0!=(16&c)){for(c&=15;u<c;)b--,f|=(255&o.read_byte(h++))<<u,u+=8;if(m=_[v+2]+(f&X[c]),f>>=c,u-=c,w-=y,p>=m)k=p-m,p-k>0&&2>p-k?(s.window[p++]=s.window[k++],s.window[p++]=s.window[k++],y-=2):(s.window.set(s.window.subarray(k,k+2),p),p+=2,k+=2,y-=2);else {k=p-m;do{k+=s.end;}while(k<0);if(c=s.end-k,y>c){if(y-=c,p-k>0&&c>p-k)do{s.window[p++]=s.window[k++];}while(0!=--c);else s.window.set(s.window.subarray(k,k+c),p),p+=c,k+=c,c=0;k=0;}}if(p-k>0&&y>p-k)do{s.window[p++]=s.window[k++];}while(0!=--y);else s.window.set(s.window.subarray(k,k+y),p),p+=y,k+=y,y=0;break}if(0!=(64&c))return o.msg="invalid distance code",y=o.avail_in-b,y=u>>3<y?u>>3:y,b+=y,h-=y,u-=y<<3,s.bitb=f,s.bitk=u,o.avail_in=b,o.total_in+=h-o.next_in_index,o.next_in_index=h,s.write=p,-3;l+=_[v+2],l+=f&X[c],v=3*(d+l),c=_[v];}break}if(0!=(64&c))return 0!=(32&c)?(y=o.avail_in-b,y=u>>3<y?u>>3:y,b+=y,h-=y,u-=y<<3,s.bitb=f,s.bitk=u,o.avail_in=b,o.total_in+=h-o.next_in_index,o.next_in_index=h,s.write=p,1):(o.msg="invalid literal/length code",y=o.avail_in-b,y=u>>3<y?u>>3:y,b+=y,h-=y,u-=y<<3,s.bitb=f,s.bitk=u,o.avail_in=b,o.total_in+=h-o.next_in_index,o.next_in_index=h,s.write=p,-3);if(l+=_[v+2],l+=f&X[c],v=3*(d+l),0===(c=_[v])){f>>=_[v+1],u-=_[v+1],s.window[p++]=_[v+2],w--;break}}else f>>=_[v+1],u-=_[v+1],s.window[p++]=_[v+2],w--;}while(w>=258&&b>=10);return y=o.avail_in-b,y=u>>3<y?u>>3:y,b+=y,h-=y,u-=y<<3,s.bitb=f,s.bitk=u,o.avail_in=b,o.total_in+=h-o.next_in_index,o.next_in_index=h,s.write=p,0}t.init=function(t,r,s,o,l,_){e=0,c=t,f=r,i=s,u=o,a=l,h=_,n=null;},t.proc=function(t,p,w){let x,g,y,m,k,v,A,U=0,S=0,z=0;for(z=p.next_in_index,m=p.avail_in,U=t.bitb,S=t.bitk,k=t.write,v=k<t.read?t.read-k-1:t.end-k;;)switch(e){case 0:if(v>=258&&m>=10&&(t.bitb=U,t.bitk=S,p.avail_in=m,p.total_in+=z-p.next_in_index,p.next_in_index=z,t.write=k,w=b(c,f,i,u,a,h,t,p),z=p.next_in_index,m=p.avail_in,U=t.bitb,S=t.bitk,k=t.write,v=k<t.read?t.read-k-1:t.end-k,0!=w)){e=1==w?7:9;break}o=c,n=i,s=u,e=1;case 1:for(x=o;S<x;){if(0===m)return t.bitb=U,t.bitk=S,p.avail_in=m,p.total_in+=z-p.next_in_index,p.next_in_index=z,t.write=k,t.inflate_flush(p,w);w=0,m--,U|=(255&p.read_byte(z++))<<S,S+=8;}if(g=3*(s+(U&X[x])),U>>>=n[g+1],S-=n[g+1],y=n[g],0===y){l=n[g+2],e=6;break}if(0!=(16&y)){_=15&y,r=n[g+2],e=2;break}if(0==(64&y)){o=y,s=g/3+n[g+2];break}if(0!=(32&y)){e=7;break}return e=9,p.msg="invalid literal/length code",w=-3,t.bitb=U,t.bitk=S,p.avail_in=m,p.total_in+=z-p.next_in_index,p.next_in_index=z,t.write=k,t.inflate_flush(p,w);case 2:for(x=_;S<x;){if(0===m)return t.bitb=U,t.bitk=S,p.avail_in=m,p.total_in+=z-p.next_in_index,p.next_in_index=z,t.write=k,t.inflate_flush(p,w);w=0,m--,U|=(255&p.read_byte(z++))<<S,S+=8;}r+=U&X[x],U>>=x,S-=x,o=f,n=a,s=h,e=3;case 3:for(x=o;S<x;){if(0===m)return t.bitb=U,t.bitk=S,p.avail_in=m,p.total_in+=z-p.next_in_index,p.next_in_index=z,t.write=k,t.inflate_flush(p,w);w=0,m--,U|=(255&p.read_byte(z++))<<S,S+=8;}if(g=3*(s+(U&X[x])),U>>=n[g+1],S-=n[g+1],y=n[g],0!=(16&y)){_=15&y,d=n[g+2],e=4;break}if(0==(64&y)){o=y,s=g/3+n[g+2];break}return e=9,p.msg="invalid distance code",w=-3,t.bitb=U,t.bitk=S,p.avail_in=m,p.total_in+=z-p.next_in_index,p.next_in_index=z,t.write=k,t.inflate_flush(p,w);case 4:for(x=_;S<x;){if(0===m)return t.bitb=U,t.bitk=S,p.avail_in=m,p.total_in+=z-p.next_in_index,p.next_in_index=z,t.write=k,t.inflate_flush(p,w);w=0,m--,U|=(255&p.read_byte(z++))<<S,S+=8;}d+=U&X[x],U>>=x,S-=x,e=5;case 5:for(A=k-d;A<0;)A+=t.end;for(;0!==r;){if(0===v&&(k==t.end&&0!==t.read&&(k=0,v=k<t.read?t.read-k-1:t.end-k),0===v&&(t.write=k,w=t.inflate_flush(p,w),k=t.write,v=k<t.read?t.read-k-1:t.end-k,k==t.end&&0!==t.read&&(k=0,v=k<t.read?t.read-k-1:t.end-k),0===v)))return t.bitb=U,t.bitk=S,p.avail_in=m,p.total_in+=z-p.next_in_index,p.next_in_index=z,t.write=k,t.inflate_flush(p,w);t.window[k++]=t.window[A++],v--,A==t.end&&(A=0),r--;}e=0;break;case 6:if(0===v&&(k==t.end&&0!==t.read&&(k=0,v=k<t.read?t.read-k-1:t.end-k),0===v&&(t.write=k,w=t.inflate_flush(p,w),k=t.write,v=k<t.read?t.read-k-1:t.end-k,k==t.end&&0!==t.read&&(k=0,v=k<t.read?t.read-k-1:t.end-k),0===v)))return t.bitb=U,t.bitk=S,p.avail_in=m,p.total_in+=z-p.next_in_index,p.next_in_index=z,t.write=k,t.inflate_flush(p,w);w=0,t.window[k++]=l,v--,e=0;break;case 7:if(S>7&&(S-=8,m++,z--),t.write=k,w=t.inflate_flush(p,w),k=t.write,v=k<t.read?t.read-k-1:t.end-k,t.read!=t.write)return t.bitb=U,t.bitk=S,p.avail_in=m,p.total_in+=z-p.next_in_index,p.next_in_index=z,t.write=k,t.inflate_flush(p,w);e=8;case 8:return w=1,t.bitb=U,t.bitk=S,p.avail_in=m,p.total_in+=z-p.next_in_index,p.next_in_index=z,t.write=k,t.inflate_flush(p,w);case 9:return w=-3,t.bitb=U,t.bitk=S,p.avail_in=m,p.total_in+=z-p.next_in_index,p.next_in_index=z,t.write=k,t.inflate_flush(p,w);default:return w=-2,t.bitb=U,t.bitk=S,p.avail_in=m,p.total_in+=z-p.next_in_index,p.next_in_index=z,t.write=k,t.inflate_flush(p,w)}},t.free=function(){};}it.inflate_trees_fixed=function(t,e,n,i){return t[0]=9,e[0]=5,n[0]=Y,i[0]=Z,0};const rt=[16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15];function st(t,e){const n=this;let i,a=0,r=0,s=0,o=0;const l=[0],_=[0],d=new at;let c=0,f=new Int32Array(4320);const u=new it;n.bitk=0,n.bitb=0,n.window=new Uint8Array(e),n.end=e,n.read=0,n.write=0,n.reset=function(t,e){e&&(e[0]=0),6==a&&d.free(t),a=0,n.bitk=0,n.bitb=0,n.read=n.write=0;},n.reset(t,null),n.inflate_flush=function(t,e){let i,a,r;return a=t.next_out_index,r=n.read,i=(r<=n.write?n.write:n.end)-r,i>t.avail_out&&(i=t.avail_out),0!==i&&-5==e&&(e=0),t.avail_out-=i,t.total_out+=i,t.next_out.set(n.window.subarray(r,r+i),a),a+=i,r+=i,r==n.end&&(r=0,n.write==n.end&&(n.write=0),i=n.write-r,i>t.avail_out&&(i=t.avail_out),0!==i&&-5==e&&(e=0),t.avail_out-=i,t.total_out+=i,t.next_out.set(n.window.subarray(r,r+i),a),a+=i,r+=i),t.next_out_index=a,n.read=r,e},n.proc=function(t,e){let h,b,p,w,x,g,y,m;for(w=t.next_in_index,x=t.avail_in,b=n.bitb,p=n.bitk,g=n.write,y=g<n.read?n.read-g-1:n.end-g;;){let k,v,A,U,S,z,I,E;switch(a){case 0:for(;p<3;){if(0===x)return n.bitb=b,n.bitk=p,t.avail_in=x,t.total_in+=w-t.next_in_index,t.next_in_index=w,n.write=g,n.inflate_flush(t,e);e=0,x--,b|=(255&t.read_byte(w++))<<p,p+=8;}switch(h=7&b,c=1&h,h>>>1){case 0:b>>>=3,p-=3,h=7&p,b>>>=h,p-=h,a=1;break;case 1:k=[],v=[],A=[[]],U=[[]],it.inflate_trees_fixed(k,v,A,U),d.init(k[0],v[0],A[0],0,U[0],0),b>>>=3,p-=3,a=6;break;case 2:b>>>=3,p-=3,a=3;break;case 3:return b>>>=3,p-=3,a=9,t.msg="invalid block type",e=-3,n.bitb=b,n.bitk=p,t.avail_in=x,t.total_in+=w-t.next_in_index,t.next_in_index=w,n.write=g,n.inflate_flush(t,e)}break;case 1:for(;p<32;){if(0===x)return n.bitb=b,n.bitk=p,t.avail_in=x,t.total_in+=w-t.next_in_index,t.next_in_index=w,n.write=g,n.inflate_flush(t,e);e=0,x--,b|=(255&t.read_byte(w++))<<p,p+=8;}if((~b>>>16&65535)!=(65535&b))return a=9,t.msg="invalid stored block lengths",e=-3,n.bitb=b,n.bitk=p,t.avail_in=x,t.total_in+=w-t.next_in_index,t.next_in_index=w,n.write=g,n.inflate_flush(t,e);r=65535&b,b=p=0,a=0!==r?2:0!==c?7:0;break;case 2:if(0===x)return n.bitb=b,n.bitk=p,t.avail_in=x,t.total_in+=w-t.next_in_index,t.next_in_index=w,n.write=g,n.inflate_flush(t,e);if(0===y&&(g==n.end&&0!==n.read&&(g=0,y=g<n.read?n.read-g-1:n.end-g),0===y&&(n.write=g,e=n.inflate_flush(t,e),g=n.write,y=g<n.read?n.read-g-1:n.end-g,g==n.end&&0!==n.read&&(g=0,y=g<n.read?n.read-g-1:n.end-g),0===y)))return n.bitb=b,n.bitk=p,t.avail_in=x,t.total_in+=w-t.next_in_index,t.next_in_index=w,n.write=g,n.inflate_flush(t,e);if(e=0,h=r,h>x&&(h=x),h>y&&(h=y),n.window.set(t.read_buf(w,h),g),w+=h,x-=h,g+=h,y-=h,0!=(r-=h))break;a=0!==c?7:0;break;case 3:for(;p<14;){if(0===x)return n.bitb=b,n.bitk=p,t.avail_in=x,t.total_in+=w-t.next_in_index,t.next_in_index=w,n.write=g,n.inflate_flush(t,e);e=0,x--,b|=(255&t.read_byte(w++))<<p,p+=8;}if(s=h=16383&b,(31&h)>29||(h>>5&31)>29)return a=9,t.msg="too many length or distance symbols",e=-3,n.bitb=b,n.bitk=p,t.avail_in=x,t.total_in+=w-t.next_in_index,t.next_in_index=w,n.write=g,n.inflate_flush(t,e);if(h=258+(31&h)+(h>>5&31),!i||i.length<h)i=[];else for(m=0;m<h;m++)i[m]=0;b>>>=14,p-=14,o=0,a=4;case 4:for(;o<4+(s>>>10);){for(;p<3;){if(0===x)return n.bitb=b,n.bitk=p,t.avail_in=x,t.total_in+=w-t.next_in_index,t.next_in_index=w,n.write=g,n.inflate_flush(t,e);e=0,x--,b|=(255&t.read_byte(w++))<<p,p+=8;}i[rt[o++]]=7&b,b>>>=3,p-=3;}for(;o<19;)i[rt[o++]]=0;if(l[0]=7,h=u.inflate_trees_bits(i,l,_,f,t),0!=h)return -3==(e=h)&&(i=null,a=9),n.bitb=b,n.bitk=p,t.avail_in=x,t.total_in+=w-t.next_in_index,t.next_in_index=w,n.write=g,n.inflate_flush(t,e);o=0,a=5;case 5:for(;h=s,!(o>=258+(31&h)+(h>>5&31));){let r,d;for(h=l[0];p<h;){if(0===x)return n.bitb=b,n.bitk=p,t.avail_in=x,t.total_in+=w-t.next_in_index,t.next_in_index=w,n.write=g,n.inflate_flush(t,e);e=0,x--,b|=(255&t.read_byte(w++))<<p,p+=8;}if(h=f[3*(_[0]+(b&X[h]))+1],d=f[3*(_[0]+(b&X[h]))+2],d<16)b>>>=h,p-=h,i[o++]=d;else {for(m=18==d?7:d-14,r=18==d?11:3;p<h+m;){if(0===x)return n.bitb=b,n.bitk=p,t.avail_in=x,t.total_in+=w-t.next_in_index,t.next_in_index=w,n.write=g,n.inflate_flush(t,e);e=0,x--,b|=(255&t.read_byte(w++))<<p,p+=8;}if(b>>>=h,p-=h,r+=b&X[m],b>>>=m,p-=m,m=o,h=s,m+r>258+(31&h)+(h>>5&31)||16==d&&m<1)return i=null,a=9,t.msg="invalid bit length repeat",e=-3,n.bitb=b,n.bitk=p,t.avail_in=x,t.total_in+=w-t.next_in_index,t.next_in_index=w,n.write=g,n.inflate_flush(t,e);d=16==d?i[m-1]:0;do{i[m++]=d;}while(0!=--r);o=m;}}if(_[0]=-1,S=[],z=[],I=[],E=[],S[0]=9,z[0]=6,h=s,h=u.inflate_trees_dynamic(257+(31&h),1+(h>>5&31),i,S,z,I,E,f,t),0!=h)return -3==h&&(i=null,a=9),e=h,n.bitb=b,n.bitk=p,t.avail_in=x,t.total_in+=w-t.next_in_index,t.next_in_index=w,n.write=g,n.inflate_flush(t,e);d.init(S[0],z[0],f,I[0],f,E[0]),a=6;case 6:if(n.bitb=b,n.bitk=p,t.avail_in=x,t.total_in+=w-t.next_in_index,t.next_in_index=w,n.write=g,1!=(e=d.proc(n,t,e)))return n.inflate_flush(t,e);if(e=0,d.free(t),w=t.next_in_index,x=t.avail_in,b=n.bitb,p=n.bitk,g=n.write,y=g<n.read?n.read-g-1:n.end-g,0===c){a=0;break}a=7;case 7:if(n.write=g,e=n.inflate_flush(t,e),g=n.write,y=g<n.read?n.read-g-1:n.end-g,n.read!=n.write)return n.bitb=b,n.bitk=p,t.avail_in=x,t.total_in+=w-t.next_in_index,t.next_in_index=w,n.write=g,n.inflate_flush(t,e);a=8;case 8:return e=1,n.bitb=b,n.bitk=p,t.avail_in=x,t.total_in+=w-t.next_in_index,t.next_in_index=w,n.write=g,n.inflate_flush(t,e);case 9:return e=-3,n.bitb=b,n.bitk=p,t.avail_in=x,t.total_in+=w-t.next_in_index,t.next_in_index=w,n.write=g,n.inflate_flush(t,e);default:return e=-2,n.bitb=b,n.bitk=p,t.avail_in=x,t.total_in+=w-t.next_in_index,t.next_in_index=w,n.write=g,n.inflate_flush(t,e)}}},n.free=function(t){n.reset(t,null),n.window=null,f=null;},n.set_dictionary=function(t,e,i){n.window.set(t.subarray(e,e+i),0),n.read=n.write=i;},n.sync_point=function(){return 1==a?1:0};}const ot=[0,0,255,255];function lt(){const t=this;function e(t){return t&&t.istate?(t.total_in=t.total_out=0,t.msg=null,t.istate.mode=7,t.istate.blocks.reset(t,null),0):-2}t.mode=0,t.method=0,t.was=[0],t.need=0,t.marker=0,t.wbits=0,t.inflateEnd=function(e){return t.blocks&&t.blocks.free(e),t.blocks=null,0},t.inflateInit=function(n,i){return n.msg=null,t.blocks=null,i<8||i>15?(t.inflateEnd(n),-2):(t.wbits=i,n.istate.blocks=new st(n,1<<i),e(n),0)},t.inflate=function(t,e){let n,i;if(!t||!t.istate||!t.next_in)return -2;const a=t.istate;for(e=4==e?-5:0,n=-5;;)switch(a.mode){case 0:if(0===t.avail_in)return n;if(n=e,t.avail_in--,t.total_in++,8!=(15&(a.method=t.read_byte(t.next_in_index++)))){a.mode=13,t.msg="unknown compression method",a.marker=5;break}if(8+(a.method>>4)>a.wbits){a.mode=13,t.msg="invalid window size",a.marker=5;break}a.mode=1;case 1:if(0===t.avail_in)return n;if(n=e,t.avail_in--,t.total_in++,i=255&t.read_byte(t.next_in_index++),((a.method<<8)+i)%31!=0){a.mode=13,t.msg="incorrect header check",a.marker=5;break}if(0==(32&i)){a.mode=7;break}a.mode=2;case 2:if(0===t.avail_in)return n;n=e,t.avail_in--,t.total_in++,a.need=(255&t.read_byte(t.next_in_index++))<<24&4278190080,a.mode=3;case 3:if(0===t.avail_in)return n;n=e,t.avail_in--,t.total_in++,a.need+=(255&t.read_byte(t.next_in_index++))<<16&16711680,a.mode=4;case 4:if(0===t.avail_in)return n;n=e,t.avail_in--,t.total_in++,a.need+=(255&t.read_byte(t.next_in_index++))<<8&65280,a.mode=5;case 5:return 0===t.avail_in?n:(n=e,t.avail_in--,t.total_in++,a.need+=255&t.read_byte(t.next_in_index++),a.mode=6,2);case 6:return a.mode=13,t.msg="need dictionary",a.marker=0,-2;case 7:if(n=a.blocks.proc(t,n),-3==n){a.mode=13,a.marker=0;break}if(0==n&&(n=e),1!=n)return n;n=e,a.blocks.reset(t,a.was),a.mode=12;case 12:return 1;case 13:return -3;default:return -2}},t.inflateSetDictionary=function(t,e,n){let i=0,a=n;if(!t||!t.istate||6!=t.istate.mode)return -2;const r=t.istate;return a>=1<<r.wbits&&(a=(1<<r.wbits)-1,i=n-a),r.blocks.set_dictionary(e,i,a),r.mode=7,0},t.inflateSync=function(t){let n,i,a,r,s;if(!t||!t.istate)return -2;const o=t.istate;if(13!=o.mode&&(o.mode=13,o.marker=0),0===(n=t.avail_in))return -5;for(i=t.next_in_index,a=o.marker;0!==n&&a<4;)t.read_byte(i)==ot[a]?a++:a=0!==t.read_byte(i)?0:4-a,i++,n--;return t.total_in+=i-t.next_in_index,t.next_in_index=i,t.avail_in=n,o.marker=a,4!=a?-3:(r=t.total_in,s=t.total_out,e(t),t.total_in=r,t.total_out=s,o.mode=7,0)},t.inflateSyncPoint=function(t){return t&&t.istate&&t.istate.blocks?t.istate.blocks.sync_point():-2};}function _t(){}function dt(t){const e=new _t,n=t&&t.chunkSize?Math.floor(2*t.chunkSize):131072,i=new Uint8Array(n);let a=!1;e.inflateInit(),e.next_out=i,this.append=function(t,r){const s=[];let o,l,_=0,d=0,c=0;if(0!==t.length){e.next_in_index=0,e.next_in=t,e.avail_in=t.length;do{if(e.next_out_index=0,e.avail_out=n,0!==e.avail_in||a||(e.next_in_index=0,a=!0),o=e.inflate(0),a&&-5===o){if(0!==e.avail_in)throw new Error("inflating: bad input")}else if(0!==o&&1!==o)throw new Error("inflating: "+e.msg);if((a||1===o)&&e.avail_in===t.length)throw new Error("inflating: bad input");e.next_out_index&&(e.next_out_index===n?s.push(new Uint8Array(i)):s.push(i.slice(0,e.next_out_index))),c+=e.next_out_index,r&&e.next_in_index>0&&e.next_in_index!=_&&(r(e.next_in_index),_=e.next_in_index);}while(e.avail_in>0||0===e.avail_out);return s.length>1?(l=new Uint8Array(c),s.forEach((function(t){l.set(t,d),d+=t.length;}))):l=s[0]||new Uint8Array(0),l}},this.flush=function(){e.inflateEnd();};}_t.prototype={inflateInit:function(t){const e=this;return e.istate=new lt,t||(t=15),e.istate.inflateInit(e,t)},inflate:function(t){const e=this;return e.istate?e.istate.inflate(e,t):-2},inflateEnd:function(){const t=this;if(!t.istate)return -2;const e=t.istate.inflateEnd(t);return t.istate=null,e},inflateSync:function(){const t=this;return t.istate?t.istate.inflateSync(t):-2},inflateSetDictionary:function(t,e){const n=this;return n.istate?n.istate.inflateSetDictionary(n,t,e):-2},read_byte:function(t){return this.next_in[t]},read_buf:function(t,e){return this.next_in.subarray(t,t+e)}},self.initCodec=()=>{self.Deflate=Q,self.Inflate=dt;};}).toString(),n=URL.createObjectURL(new Blob(["("+e+")()"],{type:"text/javascript"}));configure({workerScripts:{inflate:[n],deflate:[n]}});}};\n\n/*\n Copyright (c) 2021 Gildas Lormeau. All rights reserved.\n\n Redistribution and use in source and binary forms, with or without\n modification, are permitted provided that the following conditions are met:\n\n 1. Redistributions of source code must retain the above copyright notice,\n this list of conditions and the following disclaimer.\n\n 2. Redistributions in binary form must reproduce the above copyright \n notice, this list of conditions and the following disclaimer in \n the documentation and/or other materials provided with the distribution.\n\n 3. The names of the authors may not be used to endorse or promote products\n derived from this software without specific prior written permission.\n\n THIS SOFTWARE IS PROVIDED \'\'AS IS\'\' AND ANY EXPRESSED OR IMPLIED WARRANTIES,\n INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\n FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL JCRAFT,\n INC. OR ANY CONTRIBUTORS TO THIS SOFTWARE BE LIABLE FOR ANY DIRECT, INDIRECT,\n INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,\n OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF\n LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING\n NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,\n EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\nfunction getMimeType() {\n\treturn "application/octet-stream";\n}\n\nvar streamCodecShim = (library, options = {}, registerDataHandler) => {\n\treturn {\n\t\tDeflate: createCodecClass(library.Deflate, options.deflate, registerDataHandler),\n\t\tInflate: createCodecClass(library.Inflate, options.inflate, registerDataHandler)\n\t};\n};\n\nfunction createCodecClass(constructor, constructorOptions, registerDataHandler) {\n\treturn class {\n\n\t\tconstructor(options) {\n\t\t\tconst codecAdapter = this;\n\t\t\tconst onData = data => {\n\t\t\t\tif (codecAdapter.pendingData) {\n\t\t\t\t\tconst pendingData = codecAdapter.pendingData;\n\t\t\t\t\tcodecAdapter.pendingData = new Uint8Array(pendingData.length + data.length);\n\t\t\t\t\tcodecAdapter.pendingData.set(pendingData, 0);\n\t\t\t\t\tcodecAdapter.pendingData.set(data, pendingData.length);\n\t\t\t\t} else {\n\t\t\t\t\tcodecAdapter.pendingData = new Uint8Array(data);\n\t\t\t\t}\n\t\t\t};\n\t\t\tcodecAdapter.codec = new constructor(Object.assign({}, constructorOptions, options));\n\t\t\tregisterDataHandler(codecAdapter.codec, onData);\n\t\t}\n\t\tasync append(data) {\n\t\t\tthis.codec.push(data);\n\t\t\treturn getResponse(this);\n\t\t}\n\t\tasync flush() {\n\t\t\tthis.codec.push(new Uint8Array(0), true);\n\t\t\treturn getResponse(this);\n\t\t}\n\t};\n\n\tfunction getResponse(codec) {\n\t\tif (codec.pendingData) {\n\t\t\tconst output = codec.pendingData;\n\t\t\tcodec.pendingData = null;\n\t\t\treturn output;\n\t\t} else {\n\t\t\treturn new Uint8Array(0);\n\t\t}\n\t}\n}\n\n/*\n Copyright (c) 2021 Gildas Lormeau. All rights reserved.\n\n Redistribution and use in source and binary forms, with or without\n modification, are permitted provided that the following conditions are met:\n\n 1. Redistributions of source code must retain the above copyright notice,\n this list of conditions and the following disclaimer.\n\n 2. Redistributions in binary form must reproduce the above copyright \n notice, this list of conditions and the following disclaimer in \n the documentation and/or other materials provided with the distribution.\n\n 3. The names of the authors may not be used to endorse or promote products\n derived from this software without specific prior written permission.\n\n THIS SOFTWARE IS PROVIDED \'\'AS IS\'\' AND ANY EXPRESSED OR IMPLIED WARRANTIES,\n INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\n FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL JCRAFT,\n INC. OR ANY CONTRIBUTORS TO THIS SOFTWARE BE LIABLE FOR ANY DIRECT, INDIRECT,\n INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,\n OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF\n LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING\n NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,\n EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\nconst table = [];\nfor (let i = 0; i < 256; i++) {\n\tlet t = i;\n\tfor (let j = 0; j < 8; j++) {\n\t\tif (t & 1) {\n\t\t\tt = (t >>> 1) ^ 0xEDB88320;\n\t\t} else {\n\t\t\tt = t >>> 1;\n\t\t}\n\t}\n\ttable[i] = t;\n}\n\nclass Crc32 {\n\n\tconstructor(crc) {\n\t\tthis.crc = crc || -1;\n\t}\n\n\tappend(data) {\n\t\tlet crc = this.crc | 0;\n\t\tfor (let offset = 0, length = data.length | 0; offset < length; offset++) {\n\t\t\tcrc = (crc >>> 8) ^ table[(crc ^ data[offset]) & 0xFF];\n\t\t}\n\t\tthis.crc = crc;\n\t}\n\n\tget() {\n\t\treturn ~this.crc;\n\t}\n}\n\n// Derived from https://github.com/xqdoo00o/jszip/blob/master/lib/sjcl.js\n/*jslint indent: 2, bitwise: false, nomen: false, plusplus: false, white: false, regexp: false */\n\n/** @fileOverview Arrays of bits, encoded as arrays of Numbers.\n *\n * @author Emily Stark\n * @author Mike Hamburg\n * @author Dan Boneh\n */\n\n/**\n * Arrays of bits, encoded as arrays of Numbers.\n * @namespace\n * @description\n * <p>\n * These objects are the currency accepted by SJCL\'s crypto functions.\n * </p>\n *\n * <p>\n * Most of our crypto primitives operate on arrays of 4-byte words internally,\n * but many of them can take arguments that are not a multiple of 4 bytes.\n * This library encodes arrays of bits (whose size need not be a multiple of 8\n * bits) as arrays of 32-bit words.  The bits are packed, big-endian, into an\n * array of words, 32 bits at a time.  Since the words are double-precision\n * floating point numbers, they fit some extra data.  We use this (in a private,\n * possibly-changing manner) to encode the number of bits actually  present\n * in the last word of the array.\n * </p>\n *\n * <p>\n * Because bitwise ops clear this out-of-band data, these arrays can be passed\n * to ciphers like AES which want arrays of words.\n * </p>\n */\nconst bitArray = {\n\t/**\n\t * Concatenate two bit arrays.\n\t * @param {bitArray} a1 The first array.\n\t * @param {bitArray} a2 The second array.\n\t * @return {bitArray} The concatenation of a1 and a2.\n\t */\n\tconcat(a1, a2) {\n\t\tif (a1.length === 0 || a2.length === 0) {\n\t\t\treturn a1.concat(a2);\n\t\t}\n\n\t\tconst last = a1[a1.length - 1], shift = bitArray.getPartial(last);\n\t\tif (shift === 32) {\n\t\t\treturn a1.concat(a2);\n\t\t} else {\n\t\t\treturn bitArray._shiftRight(a2, shift, last | 0, a1.slice(0, a1.length - 1));\n\t\t}\n\t},\n\n\t/**\n\t * Find the length of an array of bits.\n\t * @param {bitArray} a The array.\n\t * @return {Number} The length of a, in bits.\n\t */\n\tbitLength(a) {\n\t\tconst l = a.length;\n\t\tif (l === 0) {\n\t\t\treturn 0;\n\t\t}\n\t\tconst x = a[l - 1];\n\t\treturn (l - 1) * 32 + bitArray.getPartial(x);\n\t},\n\n\t/**\n\t * Truncate an array.\n\t * @param {bitArray} a The array.\n\t * @param {Number} len The length to truncate to, in bits.\n\t * @return {bitArray} A new array, truncated to len bits.\n\t */\n\tclamp(a, len) {\n\t\tif (a.length * 32 < len) {\n\t\t\treturn a;\n\t\t}\n\t\ta = a.slice(0, Math.ceil(len / 32));\n\t\tconst l = a.length;\n\t\tlen = len & 31;\n\t\tif (l > 0 && len) {\n\t\t\ta[l - 1] = bitArray.partial(len, a[l - 1] & 0x80000000 >> (len - 1), 1);\n\t\t}\n\t\treturn a;\n\t},\n\n\t/**\n\t * Make a partial word for a bit array.\n\t * @param {Number} len The number of bits in the word.\n\t * @param {Number} x The bits.\n\t * @param {Number} [_end=0] Pass 1 if x has already been shifted to the high side.\n\t * @return {Number} The partial word.\n\t */\n\tpartial(len, x, _end) {\n\t\tif (len === 32) {\n\t\t\treturn x;\n\t\t}\n\t\treturn (_end ? x | 0 : x << (32 - len)) + len * 0x10000000000;\n\t},\n\n\t/**\n\t * Get the number of bits used by a partial word.\n\t * @param {Number} x The partial word.\n\t * @return {Number} The number of bits used by the partial word.\n\t */\n\tgetPartial(x) {\n\t\treturn Math.round(x / 0x10000000000) || 32;\n\t},\n\n\t/** Shift an array right.\n\t * @param {bitArray} a The array to shift.\n\t * @param {Number} shift The number of bits to shift.\n\t * @param {Number} [carry=0] A byte to carry in\n\t * @param {bitArray} [out=[]] An array to prepend to the output.\n\t * @private\n\t */\n\t_shiftRight(a, shift, carry, out) {\n\t\tif (out === undefined) {\n\t\t\tout = [];\n\t\t}\n\n\t\tfor (; shift >= 32; shift -= 32) {\n\t\t\tout.push(carry);\n\t\t\tcarry = 0;\n\t\t}\n\t\tif (shift === 0) {\n\t\t\treturn out.concat(a);\n\t\t}\n\n\t\tfor (let i = 0; i < a.length; i++) {\n\t\t\tout.push(carry | a[i] >>> shift);\n\t\t\tcarry = a[i] << (32 - shift);\n\t\t}\n\t\tconst last2 = a.length ? a[a.length - 1] : 0;\n\t\tconst shift2 = bitArray.getPartial(last2);\n\t\tout.push(bitArray.partial(shift + shift2 & 31, (shift + shift2 > 32) ? carry : out.pop(), 1));\n\t\treturn out;\n\t}\n};\n\n/** @fileOverview Bit array codec implementations.\n *\n * @author Emily Stark\n * @author Mike Hamburg\n * @author Dan Boneh\n */\n\n/**\n * Arrays of bytes\n * @namespace\n */\nconst codec = {\n\tbytes: {\n\t\t/** Convert from a bitArray to an array of bytes. */\n\t\tfromBits(arr) {\n\t\t\tconst bl = bitArray.bitLength(arr);\n\t\t\tconst byteLength = bl / 8;\n\t\t\tconst out = new Uint8Array(byteLength);\n\t\t\tlet tmp;\n\t\t\tfor (let i = 0; i < byteLength; i++) {\n\t\t\t\tif ((i & 3) === 0) {\n\t\t\t\t\ttmp = arr[i / 4];\n\t\t\t\t}\n\t\t\t\tout[i] = tmp >>> 24;\n\t\t\t\ttmp <<= 8;\n\t\t\t}\n\t\t\treturn out;\n\t\t},\n\t\t/** Convert from an array of bytes to a bitArray. */\n\t\ttoBits(bytes) {\n\t\t\tconst out = [];\n\t\t\tlet i;\n\t\t\tlet tmp = 0;\n\t\t\tfor (i = 0; i < bytes.length; i++) {\n\t\t\t\ttmp = tmp << 8 | bytes[i];\n\t\t\t\tif ((i & 3) === 3) {\n\t\t\t\t\tout.push(tmp);\n\t\t\t\t\ttmp = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (i & 3) {\n\t\t\t\tout.push(bitArray.partial(8 * (i & 3), tmp));\n\t\t\t}\n\t\t\treturn out;\n\t\t}\n\t}\n};\n\nconst hash = {};\n\n/**\n * Context for a SHA-1 operation in progress.\n * @constructor\n */\nhash.sha1 = function (hash) {\n\tif (hash) {\n\t\tthis._h = hash._h.slice(0);\n\t\tthis._buffer = hash._buffer.slice(0);\n\t\tthis._length = hash._length;\n\t} else {\n\t\tthis.reset();\n\t}\n};\n\nhash.sha1.prototype = {\n\t/**\n\t * The hash\'s block size, in bits.\n\t * @constant\n\t */\n\tblockSize: 512,\n\n\t/**\n\t * Reset the hash state.\n\t * @return this\n\t */\n\treset: function () {\n\t\tconst sha1 = this;\n\t\tsha1._h = this._init.slice(0);\n\t\tsha1._buffer = [];\n\t\tsha1._length = 0;\n\t\treturn sha1;\n\t},\n\n\t/**\n\t * Input several words to the hash.\n\t * @param {bitArray|String} data the data to hash.\n\t * @return this\n\t */\n\tupdate: function (data) {\n\t\tconst sha1 = this;\n\t\tif (typeof data === "string") {\n\t\t\tdata = codec.utf8String.toBits(data);\n\t\t}\n\t\tconst b = sha1._buffer = bitArray.concat(sha1._buffer, data);\n\t\tconst ol = sha1._length;\n\t\tconst nl = sha1._length = ol + bitArray.bitLength(data);\n\t\tif (nl > 9007199254740991) {\n\t\t\tthrow new Error("Cannot hash more than 2^53 - 1 bits");\n\t\t}\n\t\tconst c = new Uint32Array(b);\n\t\tlet j = 0;\n\t\tfor (let i = sha1.blockSize + ol - ((sha1.blockSize + ol) & (sha1.blockSize - 1)); i <= nl;\n\t\t\ti += sha1.blockSize) {\n\t\t\tsha1._block(c.subarray(16 * j, 16 * (j + 1)));\n\t\t\tj += 1;\n\t\t}\n\t\tb.splice(0, 16 * j);\n\t\treturn sha1;\n\t},\n\n\t/**\n\t * Complete hashing and output the hash value.\n\t * @return {bitArray} The hash value, an array of 5 big-endian words. TODO\n\t */\n\tfinalize: function () {\n\t\tconst sha1 = this;\n\t\tlet b = sha1._buffer;\n\t\tconst h = sha1._h;\n\n\t\t// Round out and push the buffer\n\t\tb = bitArray.concat(b, [bitArray.partial(1, 1)]);\n\t\t// Round out the buffer to a multiple of 16 words, less the 2 length words.\n\t\tfor (let i = b.length + 2; i & 15; i++) {\n\t\t\tb.push(0);\n\t\t}\n\n\t\t// append the length\n\t\tb.push(Math.floor(sha1._length / 0x100000000));\n\t\tb.push(sha1._length | 0);\n\n\t\twhile (b.length) {\n\t\t\tsha1._block(b.splice(0, 16));\n\t\t}\n\n\t\tsha1.reset();\n\t\treturn h;\n\t},\n\n\t/**\n\t * The SHA-1 initialization vector.\n\t * @private\n\t */\n\t_init: [0x67452301, 0xEFCDAB89, 0x98BADCFE, 0x10325476, 0xC3D2E1F0],\n\n\t/**\n\t * The SHA-1 hash key.\n\t * @private\n\t */\n\t_key: [0x5A827999, 0x6ED9EBA1, 0x8F1BBCDC, 0xCA62C1D6],\n\n\t/**\n\t * The SHA-1 logical functions f(0), f(1), ..., f(79).\n\t * @private\n\t */\n\t_f: function (t, b, c, d) {\n\t\tif (t <= 19) {\n\t\t\treturn (b & c) | (~b & d);\n\t\t} else if (t <= 39) {\n\t\t\treturn b ^ c ^ d;\n\t\t} else if (t <= 59) {\n\t\t\treturn (b & c) | (b & d) | (c & d);\n\t\t} else if (t <= 79) {\n\t\t\treturn b ^ c ^ d;\n\t\t}\n\t},\n\n\t/**\n\t * Circular left-shift operator.\n\t * @private\n\t */\n\t_S: function (n, x) {\n\t\treturn (x << n) | (x >>> 32 - n);\n\t},\n\n\t/**\n\t * Perform one cycle of SHA-1.\n\t * @param {Uint32Array|bitArray} words one block of words.\n\t * @private\n\t */\n\t_block: function (words) {\n\t\tconst sha1 = this;\n\t\tconst h = sha1._h;\n\t\t// When words is passed to _block, it has 16 elements. SHA1 _block\n\t\t// function extends words with new elements (at the end there are 80 elements). \n\t\t// The problem is that if we use Uint32Array instead of Array, \n\t\t// the length of Uint32Array cannot be changed. Thus, we replace words with a \n\t\t// normal Array here.\n\t\tconst w = Array(80); // do not use Uint32Array here as the instantiation is slower\n\t\tfor (let j = 0; j < 16; j++) {\n\t\t\tw[j] = words[j];\n\t\t}\n\n\t\tlet a = h[0];\n\t\tlet b = h[1];\n\t\tlet c = h[2];\n\t\tlet d = h[3];\n\t\tlet e = h[4];\n\n\t\tfor (let t = 0; t <= 79; t++) {\n\t\t\tif (t >= 16) {\n\t\t\t\tw[t] = sha1._S(1, w[t - 3] ^ w[t - 8] ^ w[t - 14] ^ w[t - 16]);\n\t\t\t}\n\t\t\tconst tmp = (sha1._S(5, a) + sha1._f(t, b, c, d) + e + w[t] +\n\t\t\t\tsha1._key[Math.floor(t / 20)]) | 0;\n\t\t\te = d;\n\t\t\td = c;\n\t\t\tc = sha1._S(30, b);\n\t\t\tb = a;\n\t\t\ta = tmp;\n\t\t}\n\n\t\th[0] = (h[0] + a) | 0;\n\t\th[1] = (h[1] + b) | 0;\n\t\th[2] = (h[2] + c) | 0;\n\t\th[3] = (h[3] + d) | 0;\n\t\th[4] = (h[4] + e) | 0;\n\t}\n};\n\n/** @fileOverview Low-level AES implementation.\n *\n * This file contains a low-level implementation of AES, optimized for\n * size and for efficiency on several browsers.  It is based on\n * OpenSSL\'s aes_core.c, a public-domain implementation by Vincent\n * Rijmen, Antoon Bosselaers and Paulo Barreto.\n *\n * An older version of this implementation is available in the public\n * domain, but this one is (c) Emily Stark, Mike Hamburg, Dan Boneh,\n * Stanford University 2008-2010 and BSD-licensed for liability\n * reasons.\n *\n * @author Emily Stark\n * @author Mike Hamburg\n * @author Dan Boneh\n */\n\nconst cipher = {};\n\n/**\n * Schedule out an AES key for both encryption and decryption.  This\n * is a low-level class.  Use a cipher mode to do bulk encryption.\n *\n * @constructor\n * @param {Array} key The key as an array of 4, 6 or 8 words.\n */\ncipher.aes = class {\n\tconstructor(key) {\n\t\t/**\n\t\t * The expanded S-box and inverse S-box tables.  These will be computed\n\t\t * on the client so that we don\'t have to send them down the wire.\n\t\t *\n\t\t * There are two tables, _tables[0] is for encryption and\n\t\t * _tables[1] is for decryption.\n\t\t *\n\t\t * The first 4 sub-tables are the expanded S-box with MixColumns.  The\n\t\t * last (_tables[01][4]) is the S-box itself.\n\t\t *\n\t\t * @private\n\t\t */\n\t\tconst aes = this;\n\t\taes._tables = [[[], [], [], [], []], [[], [], [], [], []]];\n\n\t\tif (!aes._tables[0][0][0]) {\n\t\t\taes._precompute();\n\t\t}\n\n\t\tconst sbox = aes._tables[0][4];\n\t\tconst decTable = aes._tables[1];\n\t\tconst keyLen = key.length;\n\n\t\tlet i, encKey, decKey, rcon = 1;\n\n\t\tif (keyLen !== 4 && keyLen !== 6 && keyLen !== 8) {\n\t\t\tthrow new Error("invalid aes key size");\n\t\t}\n\n\t\taes._key = [encKey = key.slice(0), decKey = []];\n\n\t\t// schedule encryption keys\n\t\tfor (i = keyLen; i < 4 * keyLen + 28; i++) {\n\t\t\tlet tmp = encKey[i - 1];\n\n\t\t\t// apply sbox\n\t\t\tif (i % keyLen === 0 || (keyLen === 8 && i % keyLen === 4)) {\n\t\t\t\ttmp = sbox[tmp >>> 24] << 24 ^ sbox[tmp >> 16 & 255] << 16 ^ sbox[tmp >> 8 & 255] << 8 ^ sbox[tmp & 255];\n\n\t\t\t\t// shift rows and add rcon\n\t\t\t\tif (i % keyLen === 0) {\n\t\t\t\t\ttmp = tmp << 8 ^ tmp >>> 24 ^ rcon << 24;\n\t\t\t\t\trcon = rcon << 1 ^ (rcon >> 7) * 283;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tencKey[i] = encKey[i - keyLen] ^ tmp;\n\t\t}\n\n\t\t// schedule decryption keys\n\t\tfor (let j = 0; i; j++, i--) {\n\t\t\tconst tmp = encKey[j & 3 ? i : i - 4];\n\t\t\tif (i <= 4 || j < 4) {\n\t\t\t\tdecKey[j] = tmp;\n\t\t\t} else {\n\t\t\t\tdecKey[j] = decTable[0][sbox[tmp >>> 24]] ^\n\t\t\t\t\tdecTable[1][sbox[tmp >> 16 & 255]] ^\n\t\t\t\t\tdecTable[2][sbox[tmp >> 8 & 255]] ^\n\t\t\t\t\tdecTable[3][sbox[tmp & 255]];\n\t\t\t}\n\t\t}\n\t}\n\t// public\n\t/* Something like this might appear here eventually\n\tname: "AES",\n\tblockSize: 4,\n\tkeySizes: [4,6,8],\n\t*/\n\n\t/**\n\t * Encrypt an array of 4 big-endian words.\n\t * @param {Array} data The plaintext.\n\t * @return {Array} The ciphertext.\n\t */\n\tencrypt(data) {\n\t\treturn this._crypt(data, 0);\n\t}\n\n\t/**\n\t * Decrypt an array of 4 big-endian words.\n\t * @param {Array} data The ciphertext.\n\t * @return {Array} The plaintext.\n\t */\n\tdecrypt(data) {\n\t\treturn this._crypt(data, 1);\n\t}\n\n\t/**\n\t * Expand the S-box tables.\n\t *\n\t * @private\n\t */\n\t_precompute() {\n\t\tconst encTable = this._tables[0];\n\t\tconst decTable = this._tables[1];\n\t\tconst sbox = encTable[4];\n\t\tconst sboxInv = decTable[4];\n\t\tconst d = [];\n\t\tconst th = [];\n\t\tlet xInv, x2, x4, x8;\n\n\t\t// Compute double and third tables\n\t\tfor (let i = 0; i < 256; i++) {\n\t\t\tth[(d[i] = i << 1 ^ (i >> 7) * 283) ^ i] = i;\n\t\t}\n\n\t\tfor (let x = xInv = 0; !sbox[x]; x ^= x2 || 1, xInv = th[xInv] || 1) {\n\t\t\t// Compute sbox\n\t\t\tlet s = xInv ^ xInv << 1 ^ xInv << 2 ^ xInv << 3 ^ xInv << 4;\n\t\t\ts = s >> 8 ^ s & 255 ^ 99;\n\t\t\tsbox[x] = s;\n\t\t\tsboxInv[s] = x;\n\n\t\t\t// Compute MixColumns\n\t\t\tx8 = d[x4 = d[x2 = d[x]]];\n\t\t\tlet tDec = x8 * 0x1010101 ^ x4 * 0x10001 ^ x2 * 0x101 ^ x * 0x1010100;\n\t\t\tlet tEnc = d[s] * 0x101 ^ s * 0x1010100;\n\n\t\t\tfor (let i = 0; i < 4; i++) {\n\t\t\t\tencTable[i][x] = tEnc = tEnc << 24 ^ tEnc >>> 8;\n\t\t\t\tdecTable[i][s] = tDec = tDec << 24 ^ tDec >>> 8;\n\t\t\t}\n\t\t}\n\n\t\t// Compactify.  Considerable speedup on Firefox.\n\t\tfor (let i = 0; i < 5; i++) {\n\t\t\tencTable[i] = encTable[i].slice(0);\n\t\t\tdecTable[i] = decTable[i].slice(0);\n\t\t}\n\t}\n\n\t/**\n\t * Encryption and decryption core.\n\t * @param {Array} input Four words to be encrypted or decrypted.\n\t * @param dir The direction, 0 for encrypt and 1 for decrypt.\n\t * @return {Array} The four encrypted or decrypted words.\n\t * @private\n\t */\n\t_crypt(input, dir) {\n\t\tif (input.length !== 4) {\n\t\t\tthrow new Error("invalid aes block size");\n\t\t}\n\n\t\tconst key = this._key[dir];\n\n\t\tconst nInnerRounds = key.length / 4 - 2;\n\t\tconst out = [0, 0, 0, 0];\n\t\tconst table = this._tables[dir];\n\n\t\t// load up the tables\n\t\tconst t0 = table[0];\n\t\tconst t1 = table[1];\n\t\tconst t2 = table[2];\n\t\tconst t3 = table[3];\n\t\tconst sbox = table[4];\n\n\t\t// state variables a,b,c,d are loaded with pre-whitened data\n\t\tlet a = input[0] ^ key[0];\n\t\tlet b = input[dir ? 3 : 1] ^ key[1];\n\t\tlet c = input[2] ^ key[2];\n\t\tlet d = input[dir ? 1 : 3] ^ key[3];\n\t\tlet kIndex = 4;\n\t\tlet a2, b2, c2;\n\n\t\t// Inner rounds.  Cribbed from OpenSSL.\n\t\tfor (let i = 0; i < nInnerRounds; i++) {\n\t\t\ta2 = t0[a >>> 24] ^ t1[b >> 16 & 255] ^ t2[c >> 8 & 255] ^ t3[d & 255] ^ key[kIndex];\n\t\t\tb2 = t0[b >>> 24] ^ t1[c >> 16 & 255] ^ t2[d >> 8 & 255] ^ t3[a & 255] ^ key[kIndex + 1];\n\t\t\tc2 = t0[c >>> 24] ^ t1[d >> 16 & 255] ^ t2[a >> 8 & 255] ^ t3[b & 255] ^ key[kIndex + 2];\n\t\t\td = t0[d >>> 24] ^ t1[a >> 16 & 255] ^ t2[b >> 8 & 255] ^ t3[c & 255] ^ key[kIndex + 3];\n\t\t\tkIndex += 4;\n\t\t\ta = a2; b = b2; c = c2;\n\t\t}\n\n\t\t// Last round.\n\t\tfor (let i = 0; i < 4; i++) {\n\t\t\tout[dir ? 3 & -i : i] =\n\t\t\t\tsbox[a >>> 24] << 24 ^\n\t\t\t\tsbox[b >> 16 & 255] << 16 ^\n\t\t\t\tsbox[c >> 8 & 255] << 8 ^\n\t\t\t\tsbox[d & 255] ^\n\t\t\t\tkey[kIndex++];\n\t\t\ta2 = a; a = b; b = c; c = d; d = a2;\n\t\t}\n\n\t\treturn out;\n\t}\n};\n\n/** @fileOverview CTR mode implementation.\n *\n * Special thanks to Roy Nicholson for pointing out a bug in our\n * implementation.\n *\n * @author Emily Stark\n * @author Mike Hamburg\n * @author Dan Boneh\n */\n\n/** Brian Gladman\'s CTR Mode.\n* @constructor\n* @param {Object} _prf The aes instance to generate key.\n* @param {bitArray} _iv The iv for ctr mode, it must be 128 bits.\n*/\n\nconst mode = {};\n\n/**\n * Brian Gladman\'s CTR Mode.\n * @namespace\n */\nmode.ctrGladman = class {\n\tconstructor(prf, iv) {\n\t\tthis._prf = prf;\n\t\tthis._initIv = iv;\n\t\tthis._iv = iv;\n\t}\n\n\treset() {\n\t\tthis._iv = this._initIv;\n\t}\n\n\t/** Input some data to calculate.\n\t * @param {bitArray} data the data to process, it must be intergral multiple of 128 bits unless it\'s the last.\n\t */\n\tupdate(data) {\n\t\treturn this.calculate(this._prf, data, this._iv);\n\t}\n\n\tincWord(word) {\n\t\tif (((word >> 24) & 0xff) === 0xff) { //overflow\n\t\t\tlet b1 = (word >> 16) & 0xff;\n\t\t\tlet b2 = (word >> 8) & 0xff;\n\t\t\tlet b3 = word & 0xff;\n\n\t\t\tif (b1 === 0xff) { // overflow b1   \n\t\t\t\tb1 = 0;\n\t\t\t\tif (b2 === 0xff) {\n\t\t\t\t\tb2 = 0;\n\t\t\t\t\tif (b3 === 0xff) {\n\t\t\t\t\t\tb3 = 0;\n\t\t\t\t\t} else {\n\t\t\t\t\t\t++b3;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\t++b2;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t++b1;\n\t\t\t}\n\n\t\t\tword = 0;\n\t\t\tword += (b1 << 16);\n\t\t\tword += (b2 << 8);\n\t\t\tword += b3;\n\t\t} else {\n\t\t\tword += (0x01 << 24);\n\t\t}\n\t\treturn word;\n\t}\n\n\tincCounter(counter) {\n\t\tif ((counter[0] = this.incWord(counter[0])) === 0) {\n\t\t\t// encr_data in fileenc.c from  Dr Brian Gladman\'s counts only with DWORD j < 8\n\t\t\tcounter[1] = this.incWord(counter[1]);\n\t\t}\n\t}\n\n\tcalculate(prf, data, iv) {\n\t\tlet l;\n\t\tif (!(l = data.length)) {\n\t\t\treturn [];\n\t\t}\n\t\tconst bl = bitArray.bitLength(data);\n\t\tfor (let i = 0; i < l; i += 4) {\n\t\t\tthis.incCounter(iv);\n\t\t\tconst e = prf.encrypt(iv);\n\t\t\tdata[i] ^= e[0];\n\t\t\tdata[i + 1] ^= e[1];\n\t\t\tdata[i + 2] ^= e[2];\n\t\t\tdata[i + 3] ^= e[3];\n\t\t}\n\t\treturn bitArray.clamp(data, bl);\n\t}\n};\n\n\nconst misc = {};\n\n/** @fileOverview HMAC implementation.\n *\n * @author Emily Stark\n * @author Mike Hamburg\n * @author Dan Boneh\n */\n\n/** HMAC with the specified hash function.\n * @constructor\n * @param {bitArray} key the key for HMAC.\n * @param {Object} [Hash=hash.sha1] The hash function to use.\n */\nmisc.hmacSha1 = class {\n\n\tconstructor(key) {\n\t\tconst hmac = this;\n\t\tconst Hash = hmac._hash = hash.sha1;\n\t\tconst exKey = [[], []];\n\t\tconst bs = Hash.prototype.blockSize / 32;\n\t\thmac._baseHash = [new Hash(), new Hash()];\n\n\t\tif (key.length > bs) {\n\t\t\tkey = Hash.hash(key);\n\t\t}\n\n\t\tfor (let i = 0; i < bs; i++) {\n\t\t\texKey[0][i] = key[i] ^ 0x36363636;\n\t\t\texKey[1][i] = key[i] ^ 0x5C5C5C5C;\n\t\t}\n\n\t\thmac._baseHash[0].update(exKey[0]);\n\t\thmac._baseHash[1].update(exKey[1]);\n\t\thmac._resultHash = new Hash(hmac._baseHash[0]);\n\t}\n\treset() {\n\t\tconst hmac = this;\n\t\thmac._resultHash = new hmac._hash(hmac._baseHash[0]);\n\t\thmac._updated = false;\n\t}\n\n\tupdate(data) {\n\t\tconst hmac = this;\n\t\thmac._updated = true;\n\t\thmac._resultHash.update(data);\n\t}\n\n\tdigest() {\n\t\tconst hmac = this;\n\t\tconst w = hmac._resultHash.finalize();\n\t\tconst result = new (hmac._hash)(hmac._baseHash[1]).update(w).finalize();\n\n\t\thmac.reset();\n\n\t\treturn result;\n\t}\n};\n\n/*\n Copyright (c) 2021 Gildas Lormeau. All rights reserved.\n\n Redistribution and use in source and binary forms, with or without\n modification, are permitted provided that the following conditions are met:\n\n 1. Redistributions of source code must retain the above copyright notice,\n this list of conditions and the following disclaimer.\n\n 2. Redistributions in binary form must reproduce the above copyright \n notice, this list of conditions and the following disclaimer in \n the documentation and/or other materials provided with the distribution.\n\n 3. The names of the authors may not be used to endorse or promote products\n derived from this software without specific prior written permission.\n\n THIS SOFTWARE IS PROVIDED \'\'AS IS\'\' AND ANY EXPRESSED OR IMPLIED WARRANTIES,\n INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\n FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL JCRAFT,\n INC. OR ANY CONTRIBUTORS TO THIS SOFTWARE BE LIABLE FOR ANY DIRECT, INDIRECT,\n INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,\n OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF\n LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING\n NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,\n EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\nconst ERR_INVALID_PASSWORD = "Invalid pasword";\nconst BLOCK_LENGTH = 16;\nconst RAW_FORMAT = "raw";\nconst PBKDF2_ALGORITHM = { name: "PBKDF2" };\nconst HASH_ALGORITHM = { name: "HMAC" };\nconst HASH_FUNCTION = "SHA-1";\nconst BASE_KEY_ALGORITHM = Object.assign({ hash: HASH_ALGORITHM }, PBKDF2_ALGORITHM);\nconst DERIVED_BITS_ALGORITHM = Object.assign({ iterations: 1000, hash: { name: HASH_FUNCTION } }, PBKDF2_ALGORITHM);\nconst DERIVED_BITS_USAGE = ["deriveBits"];\nconst SALT_LENGTH = [8, 12, 16];\nconst KEY_LENGTH = [16, 24, 32];\nconst SIGNATURE_LENGTH = 10;\nconst COUNTER_DEFAULT_VALUE = [0, 0, 0, 0];\nconst codecBytes = codec.bytes;\nconst Aes = cipher.aes;\nconst CtrGladman = mode.ctrGladman;\nconst HmacSha1 = misc.hmacSha1;\nclass AESDecrypt {\n\n\tconstructor(password, signed, strength) {\n\t\tObject.assign(this, {\n\t\t\tpassword,\n\t\t\tsigned,\n\t\t\tstrength: strength - 1,\n\t\t\tpendingInput: new Uint8Array(0)\n\t\t});\n\t}\n\n\tasync append(input) {\n\t\tconst aesCrypto = this;\n\t\tif (aesCrypto.password) {\n\t\t\tconst preamble = subarray(input, 0, SALT_LENGTH[aesCrypto.strength] + 2);\n\t\t\tawait createDecryptionKeys(aesCrypto, preamble, aesCrypto.password);\n\t\t\taesCrypto.password = null;\n\t\t\taesCrypto.aesCtrGladman = new CtrGladman(new Aes(aesCrypto.keys.key), Array.from(COUNTER_DEFAULT_VALUE));\n\t\t\taesCrypto.hmac = new HmacSha1(aesCrypto.keys.authentication);\n\t\t\tinput = subarray(input, SALT_LENGTH[aesCrypto.strength] + 2);\n\t\t}\n\t\tconst output = new Uint8Array(input.length - SIGNATURE_LENGTH - ((input.length - SIGNATURE_LENGTH) % BLOCK_LENGTH));\n\t\treturn append(aesCrypto, input, output, 0, SIGNATURE_LENGTH, true);\n\t}\n\n\tflush() {\n\t\tconst aesCrypto = this;\n\t\tconst pendingInput = aesCrypto.pendingInput;\n\t\tconst chunkToDecrypt = subarray(pendingInput, 0, pendingInput.length - SIGNATURE_LENGTH);\n\t\tconst originalSignature = subarray(pendingInput, pendingInput.length - SIGNATURE_LENGTH);\n\t\tlet decryptedChunkArray = new Uint8Array(0);\n\t\tif (chunkToDecrypt.length) {\n\t\t\tconst encryptedChunk = codecBytes.toBits(chunkToDecrypt);\n\t\t\taesCrypto.hmac.update(encryptedChunk);\n\t\t\tconst decryptedChunk = aesCrypto.aesCtrGladman.update(encryptedChunk);\n\t\t\tdecryptedChunkArray = codecBytes.fromBits(decryptedChunk);\n\t\t}\n\t\tlet valid = true;\n\t\tif (aesCrypto.signed) {\n\t\t\tconst signature = subarray(codecBytes.fromBits(aesCrypto.hmac.digest()), 0, SIGNATURE_LENGTH);\n\t\t\tfor (let indexSignature = 0; indexSignature < SIGNATURE_LENGTH; indexSignature++) {\n\t\t\t\tif (signature[indexSignature] != originalSignature[indexSignature]) {\n\t\t\t\t\tvalid = false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn {\n\t\t\tvalid,\n\t\t\tdata: decryptedChunkArray\n\t\t};\n\t}\n}\n\nclass AESEncrypt {\n\n\tconstructor(password, strength) {\n\t\tObject.assign(this, {\n\t\t\tpassword,\n\t\t\tstrength: strength - 1,\n\t\t\tpendingInput: new Uint8Array(0)\n\t\t});\n\t}\n\n\tasync append(input) {\n\t\tconst aesCrypto = this;\n\t\tlet preamble = new Uint8Array(0);\n\t\tif (aesCrypto.password) {\n\t\t\tpreamble = await createEncryptionKeys(aesCrypto, aesCrypto.password);\n\t\t\taesCrypto.password = null;\n\t\t\taesCrypto.aesCtrGladman = new CtrGladman(new Aes(aesCrypto.keys.key), Array.from(COUNTER_DEFAULT_VALUE));\n\t\t\taesCrypto.hmac = new HmacSha1(aesCrypto.keys.authentication);\n\t\t}\n\t\tconst output = new Uint8Array(preamble.length + input.length - (input.length % BLOCK_LENGTH));\n\t\toutput.set(preamble, 0);\n\t\treturn append(aesCrypto, input, output, preamble.length, 0);\n\t}\n\n\tflush() {\n\t\tconst aesCrypto = this;\n\t\tlet encryptedChunkArray = new Uint8Array(0);\n\t\tif (aesCrypto.pendingInput.length) {\n\t\t\tconst encryptedChunk = aesCrypto.aesCtrGladman.update(codecBytes.toBits(aesCrypto.pendingInput));\n\t\t\taesCrypto.hmac.update(encryptedChunk);\n\t\t\tencryptedChunkArray = codecBytes.fromBits(encryptedChunk);\n\t\t}\n\t\tconst signature = subarray(codecBytes.fromBits(aesCrypto.hmac.digest()), 0, SIGNATURE_LENGTH);\n\t\treturn {\n\t\t\tdata: concat(encryptedChunkArray, signature),\n\t\t\tsignature\n\t\t};\n\t}\n}\n\nfunction append(aesCrypto, input, output, paddingStart, paddingEnd, verifySignature) {\n\tconst inputLength = input.length - paddingEnd;\n\tif (aesCrypto.pendingInput.length) {\n\t\tinput = concat(aesCrypto.pendingInput, input);\n\t\toutput = expand(output, inputLength - (inputLength % BLOCK_LENGTH));\n\t}\n\tlet offset;\n\tfor (offset = 0; offset <= inputLength - BLOCK_LENGTH; offset += BLOCK_LENGTH) {\n\t\tconst inputChunk = codecBytes.toBits(subarray(input, offset, offset + BLOCK_LENGTH));\n\t\tif (verifySignature) {\n\t\t\taesCrypto.hmac.update(inputChunk);\n\t\t}\n\t\tconst outputChunk = aesCrypto.aesCtrGladman.update(inputChunk);\n\t\tif (!verifySignature) {\n\t\t\taesCrypto.hmac.update(outputChunk);\n\t\t}\n\t\toutput.set(codecBytes.fromBits(outputChunk), offset + paddingStart);\n\t}\n\taesCrypto.pendingInput = subarray(input, offset);\n\treturn output;\n}\n\nasync function createDecryptionKeys(decrypt, preambleArray, password) {\n\tawait createKeys$1(decrypt, password, subarray(preambleArray, 0, SALT_LENGTH[decrypt.strength]));\n\tconst passwordVerification = subarray(preambleArray, SALT_LENGTH[decrypt.strength]);\n\tconst passwordVerificationKey = decrypt.keys.passwordVerification;\n\tif (passwordVerificationKey[0] != passwordVerification[0] || passwordVerificationKey[1] != passwordVerification[1]) {\n\t\tthrow new Error(ERR_INVALID_PASSWORD);\n\t}\n}\n\nasync function createEncryptionKeys(encrypt, password) {\n\tconst salt = crypto.getRandomValues(new Uint8Array(SALT_LENGTH[encrypt.strength]));\n\tawait createKeys$1(encrypt, password, salt);\n\treturn concat(salt, encrypt.keys.passwordVerification);\n}\n\nasync function createKeys$1(target, password, salt) {\n\tconst encodedPassword = (new TextEncoder()).encode(password);\n\tconst basekey = await crypto.subtle.importKey(RAW_FORMAT, encodedPassword, BASE_KEY_ALGORITHM, false, DERIVED_BITS_USAGE);\n\tconst derivedBits = await crypto.subtle.deriveBits(Object.assign({ salt }, DERIVED_BITS_ALGORITHM), basekey, 8 * ((KEY_LENGTH[target.strength] * 2) + 2));\n\tconst compositeKey = new Uint8Array(derivedBits);\n\ttarget.keys = {\n\t\tkey: codecBytes.toBits(subarray(compositeKey, 0, KEY_LENGTH[target.strength])),\n\t\tauthentication: codecBytes.toBits(subarray(compositeKey, KEY_LENGTH[target.strength], KEY_LENGTH[target.strength] * 2)),\n\t\tpasswordVerification: subarray(compositeKey, KEY_LENGTH[target.strength] * 2)\n\t};\n}\n\nfunction concat(leftArray, rightArray) {\n\tlet array = leftArray;\n\tif (leftArray.length + rightArray.length) {\n\t\tarray = new Uint8Array(leftArray.length + rightArray.length);\n\t\tarray.set(leftArray, 0);\n\t\tarray.set(rightArray, leftArray.length);\n\t}\n\treturn array;\n}\n\nfunction expand(inputArray, length) {\n\tif (length && length > inputArray.length) {\n\t\tconst array = inputArray;\n\t\tinputArray = new Uint8Array(length);\n\t\tinputArray.set(array, 0);\n\t}\n\treturn inputArray;\n}\n\nfunction subarray(array, begin, end) {\n\treturn array.subarray(begin, end);\n}\n\n/*\n Copyright (c) 2021 Gildas Lormeau. All rights reserved.\n\n Redistribution and use in source and binary forms, with or without\n modification, are permitted provided that the following conditions are met:\n\n 1. Redistributions of source code must retain the above copyright notice,\n this list of conditions and the following disclaimer.\n\n 2. Redistributions in binary form must reproduce the above copyright \n notice, this list of conditions and the following disclaimer in \n the documentation and/or other materials provided with the distribution.\n\n 3. The names of the authors may not be used to endorse or promote products\n derived from this software without specific prior written permission.\n\n THIS SOFTWARE IS PROVIDED \'\'AS IS\'\' AND ANY EXPRESSED OR IMPLIED WARRANTIES,\n INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\n FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL JCRAFT,\n INC. OR ANY CONTRIBUTORS TO THIS SOFTWARE BE LIABLE FOR ANY DIRECT, INDIRECT,\n INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,\n OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF\n LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING\n NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,\n EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\nconst HEADER_LENGTH = 12;\n\nclass ZipCryptoDecrypt {\n\n\tconstructor(password, passwordVerification) {\n\t\tconst zipCrypto = this;\n\t\tObject.assign(zipCrypto, {\n\t\t\tpassword,\n\t\t\tpasswordVerification\n\t\t});\n\t\tcreateKeys(zipCrypto, password);\n\t}\n\n\tappend(input) {\n\t\tconst zipCrypto = this;\n\t\tif (zipCrypto.password) {\n\t\t\tconst decryptedHeader = decrypt(zipCrypto, input.subarray(0, HEADER_LENGTH));\n\t\t\tzipCrypto.password = null;\n\t\t\tif (decryptedHeader[HEADER_LENGTH - 1] != zipCrypto.passwordVerification) {\n\t\t\t\tthrow new Error(ERR_INVALID_PASSWORD);\n\t\t\t}\n\t\t\tinput = input.subarray(HEADER_LENGTH);\n\t\t}\n\t\treturn decrypt(zipCrypto, input);\n\t}\n\n\tflush() {\n\t\treturn {\n\t\t\tvalid: true,\n\t\t\tdata: new Uint8Array(0)\n\t\t};\n\t}\n}\n\nclass ZipCryptoEncrypt {\n\n\tconstructor(password, passwordVerification) {\n\t\tconst zipCrypto = this;\n\t\tObject.assign(zipCrypto, {\n\t\t\tpassword,\n\t\t\tpasswordVerification\n\t\t});\n\t\tcreateKeys(zipCrypto, password);\n\t}\n\n\tappend(input) {\n\t\tconst zipCrypto = this;\n\t\tlet output;\n\t\tlet offset;\n\t\tif (zipCrypto.password) {\n\t\t\tzipCrypto.password = null;\n\t\t\tconst header = crypto.getRandomValues(new Uint8Array(HEADER_LENGTH));\n\t\t\theader[HEADER_LENGTH - 1] = zipCrypto.passwordVerification;\n\t\t\toutput = new Uint8Array(input.length + header.length);\n\t\t\toutput.set(encrypt(zipCrypto, header), 0);\n\t\t\toffset = HEADER_LENGTH;\n\t\t} else {\n\t\t\toutput = new Uint8Array(input.length);\n\t\t\toffset = 0;\n\t\t}\n\t\toutput.set(encrypt(zipCrypto, input), offset);\n\t\treturn output;\n\t}\n\n\tflush() {\n\t\treturn {\n\t\t\tdata: new Uint8Array(0)\n\t\t};\n\t}\n}\n\nfunction decrypt(target, input) {\n\tconst output = new Uint8Array(input.length);\n\tfor (let index = 0; index < input.length; index++) {\n\t\toutput[index] = getByte(target) ^ input[index];\n\t\tupdateKeys(target, output[index]);\n\t}\n\treturn output;\n}\n\nfunction encrypt(target, input) {\n\tconst output = new Uint8Array(input.length);\n\tfor (let index = 0; index < input.length; index++) {\n\t\toutput[index] = getByte(target) ^ input[index];\n\t\tupdateKeys(target, input[index]);\n\t}\n\treturn output;\n}\n\nfunction createKeys(target, password) {\n\ttarget.keys = [0x12345678, 0x23456789, 0x34567890];\n\ttarget.crcKey0 = new Crc32(target.keys[0]);\n\ttarget.crcKey2 = new Crc32(target.keys[2]);\n\tfor (let index = 0; index < password.length; index++) {\n\t\tupdateKeys(target, password.charCodeAt(index));\n\t}\n}\n\nfunction updateKeys(target, byte) {\n\ttarget.crcKey0.append([byte]);\n\ttarget.keys[0] = ~target.crcKey0.get();\n\ttarget.keys[1] = getInt32(target.keys[1] + getInt8(target.keys[0]));\n\ttarget.keys[1] = getInt32(Math.imul(target.keys[1], 134775813) + 1);\n\ttarget.crcKey2.append([target.keys[1] >>> 24]);\n\ttarget.keys[2] = ~target.crcKey2.get();\n}\n\nfunction getByte(target) {\n\tconst temp = target.keys[2] | 2;\n\treturn getInt8(Math.imul(temp, (temp ^ 1)) >>> 8);\n}\n\nfunction getInt8(number) {\n\treturn number & 0xFF;\n}\n\nfunction getInt32(number) {\n\treturn number & 0xFFFFFFFF;\n}\n\n/*\n Copyright (c) 2021 Gildas Lormeau. All rights reserved.\n\n Redistribution and use in source and binary forms, with or without\n modification, are permitted provided that the following conditions are met:\n\n 1. Redistributions of source code must retain the above copyright notice,\n this list of conditions and the following disclaimer.\n\n 2. Redistributions in binary form must reproduce the above copyright \n notice, this list of conditions and the following disclaimer in \n the documentation and/or other materials provided with the distribution.\n\n 3. The names of the authors may not be used to endorse or promote products\n derived from this software without specific prior written permission.\n\n THIS SOFTWARE IS PROVIDED \'\'AS IS\'\' AND ANY EXPRESSED OR IMPLIED WARRANTIES,\n INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\n FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL JCRAFT,\n INC. OR ANY CONTRIBUTORS TO THIS SOFTWARE BE LIABLE FOR ANY DIRECT, INDIRECT,\n INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,\n OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF\n LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING\n NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,\n EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\nconst CODEC_DEFLATE = "deflate";\nconst CODEC_INFLATE = "inflate";\nconst ERR_INVALID_SIGNATURE = "Invalid signature";\n\nclass Inflate {\n\n\tconstructor(codecConstructor, {\n\t\tsignature,\n\t\tpassword,\n\t\tsigned,\n\t\tcompressed,\n\t\tzipCrypto,\n\t\tpasswordVerification,\n\t\tencryptionStrength\n\t}, { chunkSize }) {\n\t\tconst encrypted = Boolean(password);\n\t\tObject.assign(this, {\n\t\t\tsignature,\n\t\t\tencrypted,\n\t\t\tsigned,\n\t\t\tcompressed,\n\t\t\tinflate: compressed && new codecConstructor({ chunkSize }),\n\t\t\tcrc32: signed && new Crc32(),\n\t\t\tzipCrypto,\n\t\t\tdecrypt: encrypted && zipCrypto ?\n\t\t\t\tnew ZipCryptoDecrypt(password, passwordVerification) :\n\t\t\t\tnew AESDecrypt(password, signed, encryptionStrength)\n\t\t});\n\t}\n\n\tasync append(data) {\n\t\tconst codec = this;\n\t\tif (codec.encrypted && data.length) {\n\t\t\tdata = await codec.decrypt.append(data);\n\t\t}\n\t\tif (codec.compressed && data.length) {\n\t\t\tdata = await codec.inflate.append(data);\n\t\t}\n\t\tif ((!codec.encrypted || codec.zipCrypto) && codec.signed && data.length) {\n\t\t\tcodec.crc32.append(data);\n\t\t}\n\t\treturn data;\n\t}\n\n\tasync flush() {\n\t\tconst codec = this;\n\t\tlet signature;\n\t\tlet data = new Uint8Array(0);\n\t\tif (codec.encrypted) {\n\t\t\tconst result = codec.decrypt.flush();\n\t\t\tif (!result.valid) {\n\t\t\t\tthrow new Error(ERR_INVALID_SIGNATURE);\n\t\t\t}\n\t\t\tdata = result.data;\n\t\t}\n\t\tif ((!codec.encrypted || codec.zipCrypto) && codec.signed) {\n\t\t\tconst dataViewSignature = new DataView(new Uint8Array(4).buffer);\n\t\t\tsignature = codec.crc32.get();\n\t\t\tdataViewSignature.setUint32(0, signature);\n\t\t\tif (codec.signature != dataViewSignature.getUint32(0, false)) {\n\t\t\t\tthrow new Error(ERR_INVALID_SIGNATURE);\n\t\t\t}\n\t\t}\n\t\tif (codec.compressed) {\n\t\t\tdata = (await codec.inflate.append(data)) || new Uint8Array(0);\n\t\t\tawait codec.inflate.flush();\n\t\t}\n\t\treturn { data, signature };\n\t}\n}\n\nclass Deflate {\n\n\tconstructor(codecConstructor, {\n\t\tencrypted,\n\t\tsigned,\n\t\tcompressed,\n\t\tlevel,\n\t\tzipCrypto,\n\t\tpassword,\n\t\tpasswordVerification,\n\t\tencryptionStrength\n\t}, { chunkSize }) {\n\t\tObject.assign(this, {\n\t\t\tencrypted,\n\t\t\tsigned,\n\t\t\tcompressed,\n\t\t\tdeflate: compressed && new codecConstructor({ level: level || 5, chunkSize }),\n\t\t\tcrc32: signed && new Crc32(),\n\t\t\tzipCrypto,\n\t\t\tencrypt: encrypted && zipCrypto ?\n\t\t\t\tnew ZipCryptoEncrypt(password, passwordVerification) :\n\t\t\t\tnew AESEncrypt(password, encryptionStrength)\n\t\t});\n\t}\n\n\tasync append(inputData) {\n\t\tconst codec = this;\n\t\tlet data = inputData;\n\t\tif (codec.compressed && inputData.length) {\n\t\t\tdata = await codec.deflate.append(inputData);\n\t\t}\n\t\tif (codec.encrypted && data.length) {\n\t\t\tdata = await codec.encrypt.append(data);\n\t\t}\n\t\tif ((!codec.encrypted || codec.zipCrypto) && codec.signed && inputData.length) {\n\t\t\tcodec.crc32.append(inputData);\n\t\t}\n\t\treturn data;\n\t}\n\n\tasync flush() {\n\t\tconst codec = this;\n\t\tlet signature;\n\t\tlet data = new Uint8Array(0);\n\t\tif (codec.compressed) {\n\t\t\tdata = (await codec.deflate.flush()) || new Uint8Array(0);\n\t\t}\n\t\tif (codec.encrypted) {\n\t\t\tdata = await codec.encrypt.append(data);\n\t\t\tconst result = codec.encrypt.flush();\n\t\t\tsignature = result.signature;\n\t\t\tconst newData = new Uint8Array(data.length + result.data.length);\n\t\t\tnewData.set(data, 0);\n\t\t\tnewData.set(result.data, data.length);\n\t\t\tdata = newData;\n\t\t}\n\t\tif ((!codec.encrypted || codec.zipCrypto) && codec.signed) {\n\t\t\tsignature = codec.crc32.get();\n\t\t}\n\t\treturn { data, signature };\n\t}\n}\n\nfunction createCodec$1(codecConstructor, options, config) {\n\tif (options.codecType.startsWith(CODEC_DEFLATE)) {\n\t\treturn new Deflate(codecConstructor, options, config);\n\t} else if (options.codecType.startsWith(CODEC_INFLATE)) {\n\t\treturn new Inflate(codecConstructor, options, config);\n\t}\n}\n\n/*\n Copyright (c) 2021 Gildas Lormeau. All rights reserved.\n\n Redistribution and use in source and binary forms, with or without\n modification, are permitted provided that the following conditions are met:\n\n 1. Redistributions of source code must retain the above copyright notice,\n this list of conditions and the following disclaimer.\n\n 2. Redistributions in binary form must reproduce the above copyright \n notice, this list of conditions and the following disclaimer in \n the documentation and/or other materials provided with the distribution.\n\n 3. The names of the authors may not be used to endorse or promote products\n derived from this software without specific prior written permission.\n\n THIS SOFTWARE IS PROVIDED \'\'AS IS\'\' AND ANY EXPRESSED OR IMPLIED WARRANTIES,\n INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\n FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL JCRAFT,\n INC. OR ANY CONTRIBUTORS TO THIS SOFTWARE BE LIABLE FOR ANY DIRECT, INDIRECT,\n INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,\n OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF\n LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING\n NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,\n EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\nconst MESSAGE_INIT = "init";\nconst MESSAGE_APPEND = "append";\nconst MESSAGE_FLUSH = "flush";\nconst MESSAGE_EVENT_TYPE = "message";\n\nvar getWorker = (workerData, codecConstructor, options, config, onTaskFinished, webWorker, scripts) => {\n\tObject.assign(workerData, {\n\t\tbusy: true,\n\t\tcodecConstructor,\n\t\toptions: Object.assign({}, options),\n\t\tscripts,\n\t\tterminate() {\n\t\t\tif (workerData.worker && !workerData.busy) {\n\t\t\t\tworkerData.worker.terminate();\n\t\t\t\tworkerData.interface = null;\n\t\t\t}\n\t\t},\n\t\tonTaskFinished() {\n\t\t\tworkerData.busy = false;\n\t\t\tonTaskFinished(workerData);\n\t\t}\n\t});\n\treturn webWorker ? createWebWorkerInterface(workerData, config) : createWorkerInterface(workerData, config);\n};\n\nfunction createWorkerInterface(workerData, config) {\n\tconst interfaceCodec = createCodec$1(workerData.codecConstructor, workerData.options, config);\n\treturn {\n\t\tasync append(data) {\n\t\t\ttry {\n\t\t\t\treturn await interfaceCodec.append(data);\n\t\t\t} catch (error) {\n\t\t\t\tworkerData.onTaskFinished();\n\t\t\t\tthrow error;\n\t\t\t}\n\t\t},\n\t\tasync flush() {\n\t\t\ttry {\n\t\t\t\treturn await interfaceCodec.flush();\n\t\t\t} finally {\n\t\t\t\tworkerData.onTaskFinished();\n\t\t\t}\n\t\t}\n\t};\n}\n\nfunction createWebWorkerInterface(workerData, config) {\n\tlet messageTask;\n\tif (!workerData.interface) {\n\t\ttry {\n\t\t\tworkerData.worker = new Worker(new URL(workerData.scripts[0], "file:///home/nevro/Progs/progs-local/git-repo/OSH/gitlab/morpheusx/node_modules/cesium/Source/ThirdParty/zip.js"));\n\t\t} catch (error) {\n\t\t\tworkerData.worker = new Worker(new URL(workerData.scripts[0], "file:///home/nevro/Progs/progs-local/git-repo/OSH/gitlab/morpheusx/node_modules/cesium/Source/ThirdParty/zip.js"), { type: "module" });\n\t\t}\n\t\tworkerData.worker.addEventListener(MESSAGE_EVENT_TYPE, onMessage, false);\n\t\tworkerData.interface = {\n\t\t\tappend(data) {\n\t\t\t\treturn initAndSendMessage({ type: MESSAGE_APPEND, data });\n\t\t\t},\n\t\t\tflush() {\n\t\t\t\treturn initAndSendMessage({ type: MESSAGE_FLUSH });\n\t\t\t}\n\t\t};\n\t}\n\treturn workerData.interface;\n\n\tasync function initAndSendMessage(message) {\n\t\tif (!messageTask) {\n\t\t\tconst options = workerData.options;\n\t\t\tconst scripts = workerData.scripts.slice(1);\n\t\t\tawait sendMessage({ scripts, type: MESSAGE_INIT, options, config: { chunkSize: config.chunkSize } });\n\t\t}\n\t\treturn sendMessage(message);\n\t}\n\n\tfunction sendMessage(message) {\n\t\tconst worker = workerData.worker;\n\t\tconst result = new Promise((resolve, reject) => messageTask = { resolve, reject });\n\t\ttry {\n\t\t\tif (message.data) {\n\t\t\t\ttry {\n\t\t\t\t\tmessage.data = message.data.buffer;\n\t\t\t\t\tworker.postMessage(message, [message.data]);\n\t\t\t\t} catch (error) {\n\t\t\t\t\tworker.postMessage(message);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tworker.postMessage(message);\n\t\t\t}\n\t\t} catch (error) {\n\t\t\tmessageTask.reject(error);\n\t\t\tmessageTask = null;\n\t\t\tworkerData.onTaskFinished();\n\t\t}\n\t\treturn result;\n\t}\n\n\tfunction onMessage(event) {\n\t\tconst message = event.data;\n\t\tif (messageTask) {\n\t\t\tconst reponseError = message.error;\n\t\t\tconst type = message.type;\n\t\t\tif (reponseError) {\n\t\t\t\tconst error = new Error(reponseError.message);\n\t\t\t\terror.stack = reponseError.stack;\n\t\t\t\tmessageTask.reject(error);\n\t\t\t\tmessageTask = null;\n\t\t\t\tworkerData.onTaskFinished();\n\t\t\t} else if (type == MESSAGE_INIT || type == MESSAGE_FLUSH || type == MESSAGE_APPEND) {\n\t\t\t\tconst data = message.data;\n\t\t\t\tif (type == MESSAGE_FLUSH) {\n\t\t\t\t\tmessageTask.resolve({ data: new Uint8Array(data), signature: message.signature });\n\t\t\t\t\tmessageTask = null;\n\t\t\t\t\tworkerData.onTaskFinished();\n\t\t\t\t} else {\n\t\t\t\t\tmessageTask.resolve(data && new Uint8Array(data));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\n/*\n Copyright (c) 2021 Gildas Lormeau. All rights reserved.\n\n Redistribution and use in source and binary forms, with or without\n modification, are permitted provided that the following conditions are met:\n\n 1. Redistributions of source code must retain the above copyright notice,\n this list of conditions and the following disclaimer.\n\n 2. Redistributions in binary form must reproduce the above copyright \n notice, this list of conditions and the following disclaimer in \n the documentation and/or other materials provided with the distribution.\n\n 3. The names of the authors may not be used to endorse or promote products\n derived from this software without specific prior written permission.\n\n THIS SOFTWARE IS PROVIDED \'\'AS IS\'\' AND ANY EXPRESSED OR IMPLIED WARRANTIES,\n INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\n FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL JCRAFT,\n INC. OR ANY CONTRIBUTORS TO THIS SOFTWARE BE LIABLE FOR ANY DIRECT, INDIRECT,\n INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,\n OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF\n LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING\n NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,\n EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\nlet pool = [];\nlet pendingRequests = [];\n\nfunction createCodec(codecConstructor, options, config) {\n\tconst streamCopy = !options.compressed && !options.signed && !options.encrypted;\n\tconst webWorker = !streamCopy && (options.useWebWorkers || (options.useWebWorkers === undefined && config.useWebWorkers));\n\tconst scripts = webWorker && config.workerScripts ? config.workerScripts[options.codecType] : [];\n\tif (pool.length < config.maxWorkers) {\n\t\tconst workerData = {};\n\t\tpool.push(workerData);\n\t\treturn getWorker(workerData, codecConstructor, options, config, onTaskFinished, webWorker, scripts);\n\t} else {\n\t\tconst workerData = pool.find(workerData => !workerData.busy);\n\t\tif (workerData) {\n\t\t\tclearTerminateTimeout(workerData);\n\t\t\treturn getWorker(workerData, codecConstructor, options, config, onTaskFinished, webWorker, scripts);\n\t\t} else {\n\t\t\treturn new Promise(resolve => pendingRequests.push({ resolve, codecConstructor, options, webWorker, scripts }));\n\t\t}\n\t}\n\n\tfunction onTaskFinished(workerData) {\n\t\tif (pendingRequests.length) {\n\t\t\tconst [{ resolve, codecConstructor, options, webWorker, scripts }] = pendingRequests.splice(0, 1);\n\t\t\tresolve(getWorker(workerData, codecConstructor, options, config, onTaskFinished, webWorker, scripts));\n\t\t} else if (workerData.worker) {\n\t\t\tclearTerminateTimeout(workerData);\n\t\t\tif (Number.isFinite(config.terminateWorkerTimeout) && config.terminateWorkerTimeout >= 0) {\n\t\t\t\tworkerData.terminateTimeout = setTimeout(() => {\n\t\t\t\t\tpool = pool.filter(data => data != workerData);\n\t\t\t\t\tworkerData.terminate();\n\t\t\t\t}, config.terminateWorkerTimeout);\n\t\t\t}\n\t\t} else {\n\t\t\tpool = pool.filter(data => data != workerData);\n\t\t}\n\t}\n}\n\nfunction clearTerminateTimeout(workerData) {\n\tif (workerData.terminateTimeout) {\n\t\tclearTimeout(workerData.terminateTimeout);\n\t\tworkerData.terminateTimeout = null;\n\t}\n}\n\nfunction terminateWorkers() {\n\tpool.forEach(workerData => {\n\t\tclearTerminateTimeout(workerData);\n\t\tworkerData.terminate();\n\t});\n}\n\n/*\n Copyright (c) 2021 Gildas Lormeau. All rights reserved.\n\n Redistribution and use in source and binary forms, with or without\n modification, are permitted provided that the following conditions are met:\n\n 1. Redistributions of source code must retain the above copyright notice,\n this list of conditions and the following disclaimer.\n\n 2. Redistributions in binary form must reproduce the above copyright \n notice, this list of conditions and the following disclaimer in \n the documentation and/or other materials provided with the distribution.\n\n 3. The names of the authors may not be used to endorse or promote products\n derived from this software without specific prior written permission.\n\n THIS SOFTWARE IS PROVIDED \'\'AS IS\'\' AND ANY EXPRESSED OR IMPLIED WARRANTIES,\n INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\n FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL JCRAFT,\n INC. OR ANY CONTRIBUTORS TO THIS SOFTWARE BE LIABLE FOR ANY DIRECT, INDIRECT,\n INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,\n OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF\n LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING\n NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,\n EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\nconst MINIMUM_CHUNK_SIZE = 64;\nconst ERR_ABORT = "Abort error";\n\nasync function processData(codec, reader, writer, offset, inputLength, config, options) {\n\tconst chunkSize = Math.max(config.chunkSize, MINIMUM_CHUNK_SIZE);\n\treturn processChunk();\n\n\tasync function processChunk(chunkOffset = 0, outputLength = 0) {\n\t\tconst signal = options.signal;\n\t\tif (chunkOffset < inputLength) {\n\t\t\ttestAborted(signal, codec);\n\t\t\tconst inputData = await reader.readUint8Array(chunkOffset + offset, Math.min(chunkSize, inputLength - chunkOffset));\n\t\t\tconst chunkLength = inputData.length;\n\t\t\ttestAborted(signal, codec);\n\t\t\tconst data = await codec.append(inputData);\n\t\t\ttestAborted(signal, codec);\n\t\t\toutputLength += await writeData(writer, data);\n\t\t\tif (options.onprogress) {\n\t\t\t\ttry {\n\t\t\t\t\toptions.onprogress(chunkOffset + chunkLength, inputLength);\n\t\t\t\t} catch (error) {\n\t\t\t\t\t// ignored\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn processChunk(chunkOffset + chunkSize, outputLength);\n\t\t} else {\n\t\t\tconst result = await codec.flush();\n\t\t\toutputLength += await writeData(writer, result.data);\n\t\t\treturn { signature: result.signature, length: outputLength };\n\t\t}\n\t}\n}\n\nfunction testAborted(signal, codec) {\n\tif (signal && signal.aborted) {\n\t\tcodec.flush();\n\t\tthrow new Error(ERR_ABORT);\n\t}\n}\n\nasync function writeData(writer, data) {\n\tif (data.length) {\n\t\tawait writer.writeUint8Array(data);\n\t}\n\treturn data.length;\n}\n\n/*\n Copyright (c) 2021 Gildas Lormeau. All rights reserved.\n\n Redistribution and use in source and binary forms, with or without\n modification, are permitted provided that the following conditions are met:\n\n 1. Redistributions of source code must retain the above copyright notice,\n this list of conditions and the following disclaimer.\n\n 2. Redistributions in binary form must reproduce the above copyright \n notice, this list of conditions and the following disclaimer in \n the documentation and/or other materials provided with the distribution.\n\n 3. The names of the authors may not be used to endorse or promote products\n derived from this software without specific prior written permission.\n\n THIS SOFTWARE IS PROVIDED \'\'AS IS\'\' AND ANY EXPRESSED OR IMPLIED WARRANTIES,\n INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\n FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL JCRAFT,\n INC. OR ANY CONTRIBUTORS TO THIS SOFTWARE BE LIABLE FOR ANY DIRECT, INDIRECT,\n INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,\n OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF\n LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING\n NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,\n EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\nconst ERR_HTTP_STATUS = "HTTP error ";\nconst ERR_HTTP_RANGE = "HTTP Range not supported";\n\nconst CONTENT_TYPE_TEXT_PLAIN = "text/plain";\nconst HTTP_HEADER_CONTENT_LENGTH = "Content-Length";\nconst HTTP_HEADER_ACCEPT_RANGES = "Accept-Ranges";\nconst HTTP_HEADER_RANGE = "Range";\nconst HTTP_METHOD_HEAD = "HEAD";\nconst HTTP_METHOD_GET = "GET";\nconst HTTP_RANGE_UNIT = "bytes";\n\nclass Stream {\n\n\tconstructor() {\n\t\tthis.size = 0;\n\t}\n\n\tinit() {\n\t\tthis.initialized = true;\n\t}\n}\n\nclass Reader extends Stream {\n}\n\nclass Writer extends Stream {\n\n\twriteUint8Array(array) {\n\t\tthis.size += array.length;\n\t}\n}\n\nclass TextReader extends Reader {\n\n\tconstructor(text) {\n\t\tsuper();\n\t\tthis.blobReader = new BlobReader(new Blob([text], { type: CONTENT_TYPE_TEXT_PLAIN }));\n\t}\n\n\tasync init() {\n\t\tsuper.init();\n\t\tthis.blobReader.init();\n\t\tthis.size = this.blobReader.size;\n\t}\n\n\tasync readUint8Array(offset, length) {\n\t\treturn this.blobReader.readUint8Array(offset, length);\n\t}\n}\n\nclass TextWriter extends Writer {\n\n\tconstructor(encoding) {\n\t\tsuper();\n\t\tthis.encoding = encoding;\n\t\tthis.blob = new Blob([], { type: CONTENT_TYPE_TEXT_PLAIN });\n\t}\n\n\tasync writeUint8Array(array) {\n\t\tsuper.writeUint8Array(array);\n\t\tthis.blob = new Blob([this.blob, array.buffer], { type: CONTENT_TYPE_TEXT_PLAIN });\n\t}\n\n\tgetData() {\n\t\tconst reader = new FileReader();\n\t\treturn new Promise((resolve, reject) => {\n\t\t\treader.onload = event => resolve(event.target.result);\n\t\t\treader.onerror = () => reject(reader.error);\n\t\t\treader.readAsText(this.blob, this.encoding);\n\t\t});\n\t}\n}\n\nclass Data64URIReader extends Reader {\n\n\tconstructor(dataURI) {\n\t\tsuper();\n\t\tthis.dataURI = dataURI;\n\t\tlet dataEnd = dataURI.length;\n\t\twhile (dataURI.charAt(dataEnd - 1) == "=") {\n\t\t\tdataEnd--;\n\t\t}\n\t\tthis.dataStart = dataURI.indexOf(",") + 1;\n\t\tthis.size = Math.floor((dataEnd - this.dataStart) * 0.75);\n\t}\n\n\tasync readUint8Array(offset, length) {\n\t\tconst dataArray = new Uint8Array(length);\n\t\tconst start = Math.floor(offset / 3) * 4;\n\t\tconst bytes = atob(this.dataURI.substring(start + this.dataStart, Math.ceil((offset + length) / 3) * 4 + this.dataStart));\n\t\tconst delta = offset - Math.floor(start / 4) * 3;\n\t\tfor (let indexByte = delta; indexByte < delta + length; indexByte++) {\n\t\t\tdataArray[indexByte - delta] = bytes.charCodeAt(indexByte);\n\t\t}\n\t\treturn dataArray;\n\t}\n}\n\nclass Data64URIWriter extends Writer {\n\n\tconstructor(contentType) {\n\t\tsuper();\n\t\tthis.data = "data:" + (contentType || "") + ";base64,";\n\t\tthis.pending = [];\n\t}\n\n\tasync writeUint8Array(array) {\n\t\tsuper.writeUint8Array(array);\n\t\tlet indexArray = 0;\n\t\tlet dataString = this.pending;\n\t\tconst delta = this.pending.length;\n\t\tthis.pending = "";\n\t\tfor (indexArray = 0; indexArray < (Math.floor((delta + array.length) / 3) * 3) - delta; indexArray++) {\n\t\t\tdataString += String.fromCharCode(array[indexArray]);\n\t\t}\n\t\tfor (; indexArray < array.length; indexArray++) {\n\t\t\tthis.pending += String.fromCharCode(array[indexArray]);\n\t\t}\n\t\tif (dataString.length > 2) {\n\t\t\tthis.data += btoa(dataString);\n\t\t} else {\n\t\t\tthis.pending = dataString;\n\t\t}\n\t}\n\n\tgetData() {\n\t\treturn this.data + btoa(this.pending);\n\t}\n}\n\nclass BlobReader extends Reader {\n\n\tconstructor(blob) {\n\t\tsuper();\n\t\tthis.blob = blob;\n\t\tthis.size = blob.size;\n\t}\n\n\tasync readUint8Array(offset, length) {\n\t\tconst reader = new FileReader();\n\t\treturn new Promise((resolve, reject) => {\n\t\t\treader.onload = event => resolve(new Uint8Array(event.target.result));\n\t\t\treader.onerror = () => reject(reader.error);\n\t\t\treader.readAsArrayBuffer(this.blob.slice(offset, offset + length));\n\t\t});\n\t}\n}\n\nclass BlobWriter extends Writer {\n\n\tconstructor(contentType) {\n\t\tsuper();\n\t\tthis.offset = 0;\n\t\tthis.contentType = contentType;\n\t\tthis.blob = new Blob([], { type: contentType });\n\t}\n\n\tasync writeUint8Array(array) {\n\t\tsuper.writeUint8Array(array);\n\t\tthis.blob = new Blob([this.blob, array.buffer], { type: this.contentType });\n\t\tthis.offset = this.blob.size;\n\t}\n\n\tgetData() {\n\t\treturn this.blob;\n\t}\n}\n\nclass FetchReader extends Reader {\n\n\tconstructor(url, options) {\n\t\tsuper();\n\t\tthis.url = url;\n\t\tthis.preventHeadRequest = options.preventHeadRequest;\n\t\tthis.useRangeHeader = options.useRangeHeader;\n\t\tthis.forceRangeRequests = options.forceRangeRequests;\n\t\tthis.options = Object.assign({}, options);\n\t\tdelete this.options.preventHeadRequest;\n\t\tdelete this.options.useRangeHeader;\n\t\tdelete this.options.forceRangeRequests;\n\t\tdelete this.options.useXHR;\n\t}\n\n\tasync init() {\n\t\tsuper.init();\n\t\tif (isHttpFamily(this.url) && !this.preventHeadRequest) {\n\t\t\tconst response = await sendFetchRequest(HTTP_METHOD_HEAD, this.url, this.options);\n\t\t\tthis.size = Number(response.headers.get(HTTP_HEADER_CONTENT_LENGTH));\n\t\t\tif (!this.forceRangeRequests && this.useRangeHeader && response.headers.get(HTTP_HEADER_ACCEPT_RANGES) != HTTP_RANGE_UNIT) {\n\t\t\t\tthrow new Error(ERR_HTTP_RANGE);\n\t\t\t} else if (this.size === undefined) {\n\t\t\t\tawait getFetchData(this, this.options);\n\t\t\t}\n\t\t} else {\n\t\t\tawait getFetchData(this, this.options);\n\t\t}\n\t}\n\n\tasync readUint8Array(index, length) {\n\t\tif (this.useRangeHeader) {\n\t\t\tconst response = await sendFetchRequest(HTTP_METHOD_GET, this.url, this.options, Object.assign({}, this.options.headers,\n\t\t\t\t{ HEADER_RANGE: HTTP_RANGE_UNIT + "=" + index + "-" + (index + length - 1) }));\n\t\t\tif (response.status != 206) {\n\t\t\t\tthrow new Error(ERR_HTTP_RANGE);\n\t\t\t}\n\t\t\treturn new Uint8Array(await response.arrayBuffer());\n\t\t} else {\n\t\t\tif (!this.data) {\n\t\t\t\tawait getFetchData(this, this.options);\n\t\t\t}\n\t\t\treturn new Uint8Array(this.data.subarray(index, index + length));\n\t\t}\n\t}\n}\n\nasync function getFetchData(httpReader, options) {\n\tconst response = await sendFetchRequest(HTTP_METHOD_GET, httpReader.url, options);\n\thttpReader.data = new Uint8Array(await response.arrayBuffer());\n\tif (!httpReader.size) {\n\t\thttpReader.size = httpReader.data.length;\n\t}\n}\n\nasync function sendFetchRequest(method, url, options, headers) {\n\theaders = Object.assign({}, options.headers, headers);\n\tconst response = await fetch(url, Object.assign({}, options, { method, headers }));\n\tif (response.status < 400) {\n\t\treturn response;\n\t} else {\n\t\tthrow new Error(ERR_HTTP_STATUS + (response.statusText || response.status));\n\t}\n}\n\nclass XHRReader extends Reader {\n\n\tconstructor(url, options) {\n\t\tsuper();\n\t\tthis.url = url;\n\t\tthis.preventHeadRequest = options.preventHeadRequest;\n\t\tthis.useRangeHeader = options.useRangeHeader;\n\t\tthis.forceRangeRequests = options.forceRangeRequests;\n\t}\n\n\tasync init() {\n\t\tsuper.init();\n\t\tif (isHttpFamily(this.url) && !this.preventHeadRequest) {\n\t\t\treturn new Promise((resolve, reject) => sendXHR(HTTP_METHOD_HEAD, this.url, request => {\n\t\t\t\tthis.size = Number(request.getResponseHeader(HTTP_HEADER_CONTENT_LENGTH));\n\t\t\t\tif (this.useRangeHeader) {\n\t\t\t\t\tif (this.forceRangeRequests || request.getResponseHeader(HTTP_HEADER_ACCEPT_RANGES) == HTTP_RANGE_UNIT) {\n\t\t\t\t\t\tresolve();\n\t\t\t\t\t} else {\n\t\t\t\t\t\treject(new Error(ERR_HTTP_RANGE));\n\t\t\t\t\t}\n\t\t\t\t} else if (this.size === undefined) {\n\t\t\t\t\tgetXHRData(this, this.url).then(() => resolve()).catch(reject);\n\t\t\t\t} else {\n\t\t\t\t\tresolve();\n\t\t\t\t}\n\t\t\t}, reject));\n\t\t} else {\n\t\t\tawait getXHRData(this, this.url);\n\t\t}\n\t}\n\n\tasync readUint8Array(index, length) {\n\t\tif (this.useRangeHeader) {\n\t\t\tconst request = await new Promise((resolve, reject) => sendXHR(HTTP_METHOD_GET, this.url, request => resolve(new Uint8Array(request.response)), reject,\n\t\t\t\t[[HTTP_HEADER_RANGE, HTTP_RANGE_UNIT + "=" + index + "-" + (index + length - 1)]]));\n\t\t\tif (request.status != 206) {\n\t\t\t\tthrow new Error(ERR_HTTP_RANGE);\n\t\t\t}\n\t\t} else {\n\t\t\tif (!this.data) {\n\t\t\t\tawait getXHRData(this, this.url);\n\t\t\t}\n\t\t\treturn new Uint8Array(this.data.subarray(index, index + length));\n\t\t}\n\t}\n}\n\nfunction getXHRData(httpReader, url) {\n\treturn new Promise((resolve, reject) => sendXHR(HTTP_METHOD_GET, url, request => {\n\t\thttpReader.data = new Uint8Array(request.response);\n\t\tif (!httpReader.size) {\n\t\t\thttpReader.size = httpReader.data.length;\n\t\t}\n\t\tresolve();\n\t}, reject));\n}\n\nfunction sendXHR(method, url, onload, onerror, headers = []) {\n\tconst request = new XMLHttpRequest();\n\trequest.addEventListener("load", () => {\n\t\tif (request.status < 400) {\n\t\t\tonload(request);\n\t\t} else {\n\t\t\tonerror(ERR_HTTP_STATUS + (request.statusText || request.status));\n\t\t}\n\t}, false);\n\trequest.addEventListener("error", onerror, false);\n\trequest.open(method, url);\n\theaders.forEach(header => request.setRequestHeader(header[0], header[1]));\n\trequest.responseType = "arraybuffer";\n\trequest.send();\n\treturn request;\n}\n\nclass HttpReader extends Reader {\n\n\tconstructor(url, options = {}) {\n\t\tsuper();\n\t\tthis.url = url;\n\t\tif (options.useXHR) {\n\t\t\tthis.reader = new XHRReader(url, options);\n\t\t} else {\n\t\t\tthis.reader = new FetchReader(url, options);\n\t\t}\n\t}\n\n\tset size(value) {\n\t\t// ignored\n\t}\n\n\tget size() {\n\t\treturn this.reader.size;\n\t}\n\n\tasync init() {\n\t\tsuper.init();\n\t\tawait this.reader.init();\n\t}\n\n\tasync readUint8Array(index, length) {\n\t\treturn this.reader.readUint8Array(index, length);\n\t}\n}\n\nclass HttpRangeReader extends HttpReader {\n\n\tconstructor(url, options = {}) {\n\t\toptions.useRangeHeader = true;\n\t\tsuper(url, options);\n\t}\n}\n\n\nclass Uint8ArrayReader extends Reader {\n\n\tconstructor(array) {\n\t\tsuper();\n\t\tthis.array = array;\n\t\tthis.size = array.length;\n\t}\n\n\tasync readUint8Array(index, length) {\n\t\treturn this.array.slice(index, index + length);\n\t}\n}\n\nclass Uint8ArrayWriter extends Writer {\n\n\tconstructor() {\n\t\tsuper();\n\t\tthis.array = new Uint8Array(0);\n\t}\n\n\tasync writeUint8Array(array) {\n\t\tsuper.writeUint8Array(array);\n\t\tconst previousArray = this.array;\n\t\tthis.array = new Uint8Array(previousArray.length + array.length);\n\t\tthis.array.set(previousArray);\n\t\tthis.array.set(array, previousArray.length);\n\t}\n\n\tgetData() {\n\t\treturn this.array;\n\t}\n}\n\nfunction isHttpFamily(url) {\n\tif (typeof document != "undefined") {\n\t\tconst anchor = document.createElement("a");\n\t\tanchor.href = url;\n\t\treturn anchor.protocol == "http:" || anchor.protocol == "https:";\n\t} else {\n\t\treturn /^https?:\\/\\//i.test(url);\n\t}\n}\n\n/*\n Copyright (c) 2021 Gildas Lormeau. All rights reserved.\n\n Redistribution and use in source and binary forms, with or without\n modification, are permitted provided that the following conditions are met:\n\n 1. Redistributions of source code must retain the above copyright notice,\n this list of conditions and the following disclaimer.\n\n 2. Redistributions in binary form must reproduce the above copyright \n notice, this list of conditions and the following disclaimer in \n the documentation and/or other materials provided with the distribution.\n\n 3. The names of the authors may not be used to endorse or promote products\n derived from this software without specific prior written permission.\n\n THIS SOFTWARE IS PROVIDED \'\'AS IS\'\' AND ANY EXPRESSED OR IMPLIED WARRANTIES,\n INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\n FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL JCRAFT,\n INC. OR ANY CONTRIBUTORS TO THIS SOFTWARE BE LIABLE FOR ANY DIRECT, INDIRECT,\n INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,\n OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF\n LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING\n NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,\n EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\nconst MAX_32_BITS = 0xffffffff;\nconst MAX_16_BITS = 0xffff;\nconst COMPRESSION_METHOD_DEFLATE = 0x08;\nconst COMPRESSION_METHOD_STORE = 0x00;\nconst COMPRESSION_METHOD_AES = 0x63;\n\nconst LOCAL_FILE_HEADER_SIGNATURE = 0x04034b50;\nconst DATA_DESCRIPTOR_RECORD_SIGNATURE = 0x08074b50;\nconst CENTRAL_FILE_HEADER_SIGNATURE = 0x02014b50;\nconst END_OF_CENTRAL_DIR_SIGNATURE = 0x06054b50;\nconst ZIP64_END_OF_CENTRAL_DIR_SIGNATURE = 0x06064b50;\nconst ZIP64_END_OF_CENTRAL_DIR_LOCATOR_SIGNATURE = 0x07064b50;\nconst END_OF_CENTRAL_DIR_LENGTH = 22;\nconst ZIP64_END_OF_CENTRAL_DIR_LOCATOR_LENGTH = 20;\nconst ZIP64_END_OF_CENTRAL_DIR_LENGTH = 56;\nconst ZIP64_END_OF_CENTRAL_DIR_TOTAL_LENGTH = END_OF_CENTRAL_DIR_LENGTH + ZIP64_END_OF_CENTRAL_DIR_LOCATOR_LENGTH + ZIP64_END_OF_CENTRAL_DIR_LENGTH;\n\nconst ZIP64_TOTAL_NUMBER_OF_DISKS = 1;\n\nconst EXTRAFIELD_TYPE_ZIP64 = 0x0001;\nconst EXTRAFIELD_TYPE_AES = 0x9901;\nconst EXTRAFIELD_TYPE_NTFS = 0x000a;\nconst EXTRAFIELD_TYPE_NTFS_TAG1 = 0x0001;\nconst EXTRAFIELD_TYPE_EXTENDED_TIMESTAMP = 0x5455;\nconst EXTRAFIELD_TYPE_UNICODE_PATH = 0x7075;\nconst EXTRAFIELD_TYPE_UNICODE_COMMENT = 0x6375;\n\nconst BITFLAG_ENCRYPTED = 0x01;\nconst BITFLAG_LEVEL = 0x06;\nconst BITFLAG_DATA_DESCRIPTOR = 0x0008;\nconst BITFLAG_LANG_ENCODING_FLAG = 0x0800;\nconst FILE_ATTR_MSDOS_DIR_MASK = 0x10;\n\nconst VERSION_DEFLATE = 0x14;\nconst VERSION_ZIP64 = 0x2D;\nconst VERSION_AES = 0x33;\n\nconst DIRECTORY_SIGNATURE = "/";\n\nconst MAX_DATE = new Date(2107, 11, 31);\nconst MIN_DATE = new Date(1980, 0, 1);\n\n/*\n Copyright (c) 2021 Gildas Lormeau. All rights reserved.\n\n Redistribution and use in source and binary forms, with or without\n modification, are permitted provided that the following conditions are met:\n\n 1. Redistributions of source code must retain the above copyright notice,\n this list of conditions and the following disclaimer.\n\n 2. Redistributions in binary form must reproduce the above copyright \n notice, this list of conditions and the following disclaimer in \n the documentation and/or other materials provided with the distribution.\n\n 3. The names of the authors may not be used to endorse or promote products\n derived from this software without specific prior written permission.\n\n THIS SOFTWARE IS PROVIDED \'\'AS IS\'\' AND ANY EXPRESSED OR IMPLIED WARRANTIES,\n INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\n FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL JCRAFT,\n INC. OR ANY CONTRIBUTORS TO THIS SOFTWARE BE LIABLE FOR ANY DIRECT, INDIRECT,\n INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,\n OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF\n LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING\n NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,\n EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\nconst CP437 = "\\0☺☻♥♦♣♠•◘○◙♂♀♪♫☼►◄↕‼¶§▬↨↑↓→←∟↔▲▼ !\\"#$%&\'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\\\]^_`abcdefghijklmnopqrstuvwxyz{|}~⌂ÇüéâäàåçêëèïîìÄÅÉæÆôöòûùÿÖÜ¢£¥₧ƒáíóúñÑªº¿⌐¬½¼¡«»░▒▓│┤╡╢╖╕╣║╗╝╜╛┐└┴┬├─┼╞╟╚╔╩╦╠═╬╧╨╤╥╙╘╒╓╫╪┘┌█▄▌▐▀αßΓπΣσµτΦΘΩδ∞φε∩≡±≥≤⌠⌡÷≈°∙·√ⁿ²■ ".split("");\n\nvar decodeCP437 = stringValue => {\n\tlet result = "";\n\tfor (let indexCharacter = 0; indexCharacter < stringValue.length; indexCharacter++) {\n\t\tresult += CP437[stringValue[indexCharacter]];\n\t}\n\treturn result;\n};\n\n/*\n Copyright (c) 2021 Gildas Lormeau. All rights reserved.\n\n Redistribution and use in source and binary forms, with or without\n modification, are permitted provided that the following conditions are met:\n\n 1. Redistributions of source code must retain the above copyright notice,\n this list of conditions and the following disclaimer.\n\n 2. Redistributions in binary form must reproduce the above copyright \n notice, this list of conditions and the following disclaimer in \n the documentation and/or other materials provided with the distribution.\n\n 3. The names of the authors may not be used to endorse or promote products\n derived from this software without specific prior written permission.\n\n THIS SOFTWARE IS PROVIDED \'\'AS IS\'\' AND ANY EXPRESSED OR IMPLIED WARRANTIES,\n INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\n FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL JCRAFT,\n INC. OR ANY CONTRIBUTORS TO THIS SOFTWARE BE LIABLE FOR ANY DIRECT, INDIRECT,\n INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,\n OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF\n LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING\n NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,\n EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\nconst PROPERTY_NAMES = [\n\t"filename", "rawFilename", "directory", "encrypted", "compressedSize", "uncompressedSize",\n\t"lastModDate", "rawLastModDate", "comment", "rawComment", "signature", "extraField",\n\t"rawExtraField", "bitFlag", "extraFieldZip64", "extraFieldUnicodePath", "extraFieldUnicodeComment",\n\t"extraFieldAES", "filenameUTF8", "commentUTF8", "offset", "zip64", "compressionMethod",\n\t"extraFieldNTFS", "lastAccessDate", "creationDate", "extraFieldExtendedTimestamp",\n\t"version", "versionMadeBy", "msDosCompatible", "internalFileAttribute", "externalFileAttribute"];\n\nclass Entry {\n\n\tconstructor(data) {\n\t\tPROPERTY_NAMES.forEach(name => this[name] = data[name]);\n\t}\n\n}\n\n/*\n Copyright (c) 2021 Gildas Lormeau. All rights reserved.\n\n Redistribution and use in source and binary forms, with or without\n modification, are permitted provided that the following conditions are met:\n\n 1. Redistributions of source code must retain the above copyright notice,\n this list of conditions and the following disclaimer.\n\n 2. Redistributions in binary form must reproduce the above copyright \n notice, this list of conditions and the following disclaimer in \n the documentation and/or other materials provided with the distribution.\n\n 3. The names of the authors may not be used to endorse or promote products\n derived from this software without specific prior written permission.\n\n THIS SOFTWARE IS PROVIDED \'\'AS IS\'\' AND ANY EXPRESSED OR IMPLIED WARRANTIES,\n INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\n FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL JCRAFT,\n INC. OR ANY CONTRIBUTORS TO THIS SOFTWARE BE LIABLE FOR ANY DIRECT, INDIRECT,\n INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,\n OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF\n LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING\n NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,\n EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\nconst ERR_BAD_FORMAT = "File format is not recognized";\nconst ERR_EOCDR_NOT_FOUND = "End of central directory not found";\nconst ERR_EOCDR_ZIP64_NOT_FOUND = "End of Zip64 central directory not found";\nconst ERR_EOCDR_LOCATOR_ZIP64_NOT_FOUND = "End of Zip64 central directory locator not found";\nconst ERR_CENTRAL_DIRECTORY_NOT_FOUND = "Central directory header not found";\nconst ERR_LOCAL_FILE_HEADER_NOT_FOUND = "Local file header not found";\nconst ERR_EXTRAFIELD_ZIP64_NOT_FOUND = "Zip64 extra field not found";\nconst ERR_ENCRYPTED = "File contains encrypted entry";\nconst ERR_UNSUPPORTED_ENCRYPTION = "Encryption method not supported";\nconst ERR_UNSUPPORTED_COMPRESSION = "Compression method not supported";\nconst CHARSET_UTF8 = "utf-8";\nconst ZIP64_PROPERTIES = ["uncompressedSize", "compressedSize", "offset"];\n\nclass ZipReader {\n\n\tconstructor(reader, options = {}) {\n\t\tObject.assign(this, {\n\t\t\treader,\n\t\t\toptions,\n\t\t\tconfig: getConfiguration()\n\t\t});\n\t}\n\n\tasync getEntries(options = {}) {\n\t\tconst zipReader = this;\n\t\tconst reader = zipReader.reader;\n\t\tif (!reader.initialized) {\n\t\t\tawait reader.init();\n\t\t}\n\t\tif (reader.size < END_OF_CENTRAL_DIR_LENGTH) {\n\t\t\tthrow new Error(ERR_BAD_FORMAT);\n\t\t}\n\t\tconst endOfDirectoryInfo = await seekSignature(reader, END_OF_CENTRAL_DIR_SIGNATURE, reader.size, END_OF_CENTRAL_DIR_LENGTH, MAX_16_BITS * 16);\n\t\tif (!endOfDirectoryInfo) {\n\t\t\tthrow new Error(ERR_EOCDR_NOT_FOUND);\n\t\t}\n\t\tconst endOfDirectoryView = getDataView$1(endOfDirectoryInfo);\n\t\tlet directoryDataLength = getUint32(endOfDirectoryView, 12);\n\t\tlet directoryDataOffset = getUint32(endOfDirectoryView, 16);\n\t\tlet filesLength = getUint16(endOfDirectoryView, 8);\n\t\tlet prependedDataLength = 0;\n\t\tif (directoryDataOffset == MAX_32_BITS || filesLength == MAX_16_BITS) {\n\t\t\tconst endOfDirectoryLocatorArray = await readUint8Array(reader, endOfDirectoryInfo.offset - ZIP64_END_OF_CENTRAL_DIR_LOCATOR_LENGTH, ZIP64_END_OF_CENTRAL_DIR_LOCATOR_LENGTH);\n\t\t\tconst endOfDirectoryLocatorView = getDataView$1(endOfDirectoryLocatorArray);\n\t\t\tif (getUint32(endOfDirectoryLocatorView, 0) != ZIP64_END_OF_CENTRAL_DIR_LOCATOR_SIGNATURE) {\n\t\t\t\tthrow new Error(ERR_EOCDR_ZIP64_NOT_FOUND);\n\t\t\t}\n\t\t\tdirectoryDataOffset = getBigUint64(endOfDirectoryLocatorView, 8);\n\t\t\tlet endOfDirectoryArray = await readUint8Array(reader, directoryDataOffset, ZIP64_END_OF_CENTRAL_DIR_LENGTH);\n\t\t\tlet endOfDirectoryView = getDataView$1(endOfDirectoryArray);\n\t\t\tconst expectedDirectoryDataOffset = endOfDirectoryInfo.offset - ZIP64_END_OF_CENTRAL_DIR_LOCATOR_LENGTH - ZIP64_END_OF_CENTRAL_DIR_LENGTH;\n\t\t\tif (getUint32(endOfDirectoryView, 0) != ZIP64_END_OF_CENTRAL_DIR_SIGNATURE && directoryDataOffset != expectedDirectoryDataOffset) {\n\t\t\t\tconst originalDirectoryDataOffset = directoryDataOffset;\n\t\t\t\tdirectoryDataOffset = expectedDirectoryDataOffset;\n\t\t\t\tprependedDataLength = directoryDataOffset - originalDirectoryDataOffset;\n\t\t\t\tendOfDirectoryArray = await readUint8Array(reader, directoryDataOffset, ZIP64_END_OF_CENTRAL_DIR_LENGTH);\n\t\t\t\tendOfDirectoryView = getDataView$1(endOfDirectoryArray);\n\t\t\t}\n\t\t\tif (getUint32(endOfDirectoryView, 0) != ZIP64_END_OF_CENTRAL_DIR_SIGNATURE) {\n\t\t\t\tthrow new Error(ERR_EOCDR_LOCATOR_ZIP64_NOT_FOUND);\n\t\t\t}\n\t\t\tfilesLength = getBigUint64(endOfDirectoryView, 24);\n\t\t\tdirectoryDataLength = getUint32(endOfDirectoryLocatorView, 4);\n\t\t\tdirectoryDataOffset -= getBigUint64(endOfDirectoryView, 40);\n\t\t}\n\t\tif (directoryDataOffset < 0 || directoryDataOffset >= reader.size) {\n\t\t\tthrow new Error(ERR_BAD_FORMAT);\n\t\t}\n\t\tlet offset = 0;\n\t\tlet directoryArray = await readUint8Array(reader, directoryDataOffset, reader.size - directoryDataOffset);\n\t\tlet directoryView = getDataView$1(directoryArray);\n\t\tconst expectedDirectoryDataOffset = endOfDirectoryInfo.offset - directoryDataLength;\n\t\tif (getUint32(directoryView, offset) != CENTRAL_FILE_HEADER_SIGNATURE && directoryDataOffset != expectedDirectoryDataOffset) {\n\t\t\tconst originalDirectoryDataOffset = directoryDataOffset;\n\t\t\tdirectoryDataOffset = expectedDirectoryDataOffset;\n\t\t\tprependedDataLength = directoryDataOffset - originalDirectoryDataOffset;\n\t\t\tdirectoryArray = await readUint8Array(reader, directoryDataOffset, reader.size - directoryDataOffset);\n\t\t\tdirectoryView = getDataView$1(directoryArray);\n\t\t}\n\t\tif (directoryDataOffset < 0 || directoryDataOffset >= reader.size) {\n\t\t\tthrow new Error(ERR_BAD_FORMAT);\n\t\t}\n\t\tconst entries = [];\n\t\tfor (let indexFile = 0; indexFile < filesLength; indexFile++) {\n\t\t\tconst fileEntry = new ZipEntry(reader, zipReader.config, zipReader.options);\n\t\t\tif (getUint32(directoryView, offset) != CENTRAL_FILE_HEADER_SIGNATURE) {\n\t\t\t\tthrow new Error(ERR_CENTRAL_DIRECTORY_NOT_FOUND);\n\t\t\t}\n\t\t\treadCommonHeader(fileEntry, directoryView, offset + 6);\n\t\t\tconst languageEncodingFlag = Boolean(fileEntry.bitFlag.languageEncodingFlag);\n\t\t\tconst filenameOffset = offset + 46;\n\t\t\tconst extraFieldOffset = filenameOffset + fileEntry.filenameLength;\n\t\t\tconst commentOffset = extraFieldOffset + fileEntry.extraFieldLength;\n\t\t\tconst versionMadeBy = getUint16(directoryView, offset + 4);\n\t\t\tconst msDosCompatible = (versionMadeBy & 0) == 0;\n\t\t\tObject.assign(fileEntry, {\n\t\t\t\tversionMadeBy,\n\t\t\t\tmsDosCompatible,\n\t\t\t\tcompressedSize: 0,\n\t\t\t\tuncompressedSize: 0,\n\t\t\t\tcommentLength: getUint16(directoryView, offset + 32),\n\t\t\t\tdirectory: msDosCompatible && ((getUint8(directoryView, offset + 38) & FILE_ATTR_MSDOS_DIR_MASK) == FILE_ATTR_MSDOS_DIR_MASK),\n\t\t\t\toffset: getUint32(directoryView, offset + 42) + prependedDataLength,\n\t\t\t\tinternalFileAttribute: getUint32(directoryView, offset + 34),\n\t\t\t\texternalFileAttribute: getUint32(directoryView, offset + 38),\n\t\t\t\trawFilename: directoryArray.subarray(filenameOffset, extraFieldOffset),\n\t\t\t\tfilenameUTF8: languageEncodingFlag,\n\t\t\t\tcommentUTF8: languageEncodingFlag,\n\t\t\t\trawExtraField: directoryArray.subarray(extraFieldOffset, commentOffset)\n\t\t\t});\n\t\t\tconst endOffset = commentOffset + fileEntry.commentLength;\n\t\t\tfileEntry.rawComment = directoryArray.subarray(commentOffset, endOffset);\n\t\t\tfileEntry.filename = decodeString(fileEntry.rawFilename, fileEntry.filenameUTF8 ? CHARSET_UTF8 : getOptionValue$1(zipReader, options, "filenameEncoding"));\n\t\t\tfileEntry.comment = decodeString(fileEntry.rawComment, fileEntry.commentUTF8 ? CHARSET_UTF8 : getOptionValue$1(zipReader, options, "commentEncoding"));\n\t\t\tif (!fileEntry.directory && fileEntry.filename.endsWith(DIRECTORY_SIGNATURE)) {\n\t\t\t\tfileEntry.directory = true;\n\t\t\t}\n\t\t\treadCommonFooter(fileEntry, fileEntry, directoryView, offset + 6);\n\t\t\tconst entry = new Entry(fileEntry);\n\t\t\tentry.getData = (writer, options) => fileEntry.getData(writer, entry, options);\n\t\t\tentries.push(entry);\n\t\t\toffset = endOffset;\n\t\t\tif (options.onprogress) {\n\t\t\t\ttry {\n\t\t\t\t\toptions.onprogress(indexFile + 1, filesLength, new Entry(fileEntry));\n\t\t\t\t} catch (error) {\n\t\t\t\t\t// ignored\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn entries;\n\t}\n\n\tasync close() {\n\t}\n}\n\nclass ZipEntry {\n\n\tconstructor(reader, config, options) {\n\t\tObject.assign(this, {\n\t\t\treader,\n\t\t\tconfig,\n\t\t\toptions\n\t\t});\n\t}\n\n\tasync getData(writer, fileEntry, options = {}) {\n\t\tconst zipEntry = this;\n\t\tconst {\n\t\t\treader,\n\t\t\toffset,\n\t\t\textraFieldAES,\n\t\t\tcompressionMethod,\n\t\t\tconfig,\n\t\t\tbitFlag,\n\t\t\tsignature,\n\t\t\trawLastModDate,\n\t\t\tcompressedSize\n\t\t} = zipEntry;\n\t\tconst localDirectory = zipEntry.localDirectory = {};\n\t\tif (!reader.initialized) {\n\t\t\tawait reader.init();\n\t\t}\n\t\tlet dataArray = await readUint8Array(reader, offset, 30);\n\t\tconst dataView = getDataView$1(dataArray);\n\t\tlet password = getOptionValue$1(zipEntry, options, "password");\n\t\tpassword = password && password.length && password;\n\t\tif (extraFieldAES) {\n\t\t\tif (extraFieldAES.originalCompressionMethod != COMPRESSION_METHOD_AES) {\n\t\t\t\tthrow new Error(ERR_UNSUPPORTED_COMPRESSION);\n\t\t\t}\n\t\t}\n\t\tif (compressionMethod != COMPRESSION_METHOD_STORE && compressionMethod != COMPRESSION_METHOD_DEFLATE) {\n\t\t\tthrow new Error(ERR_UNSUPPORTED_COMPRESSION);\n\t\t}\n\t\tif (getUint32(dataView, 0) != LOCAL_FILE_HEADER_SIGNATURE) {\n\t\t\tthrow new Error(ERR_LOCAL_FILE_HEADER_NOT_FOUND);\n\t\t}\n\t\treadCommonHeader(localDirectory, dataView, 4);\n\t\tdataArray = await readUint8Array(reader, offset, 30 + localDirectory.filenameLength + localDirectory.extraFieldLength);\n\t\tlocalDirectory.rawExtraField = dataArray.subarray(30 + localDirectory.filenameLength);\n\t\treadCommonFooter(zipEntry, localDirectory, dataView, 4);\n\t\tfileEntry.lastAccessDate = localDirectory.lastAccessDate;\n\t\tfileEntry.creationDate = localDirectory.creationDate;\n\t\tconst encrypted = zipEntry.encrypted && localDirectory.encrypted;\n\t\tconst zipCrypto = encrypted && !extraFieldAES;\n\t\tif (encrypted) {\n\t\t\tif (!zipCrypto && extraFieldAES.strength === undefined) {\n\t\t\t\tthrow new Error(ERR_UNSUPPORTED_ENCRYPTION);\n\t\t\t} else if (!password) {\n\t\t\t\tthrow new Error(ERR_ENCRYPTED);\n\t\t\t}\n\t\t}\n\t\tconst codec = await createCodec(config.Inflate, {\n\t\t\tcodecType: CODEC_INFLATE,\n\t\t\tpassword,\n\t\t\tzipCrypto,\n\t\t\tencryptionStrength: extraFieldAES && extraFieldAES.strength,\n\t\t\tsigned: getOptionValue$1(zipEntry, options, "checkSignature"),\n\t\t\tpasswordVerification: zipCrypto && (bitFlag.dataDescriptor ? ((rawLastModDate >>> 8) & 0xFF) : ((signature >>> 24) & 0xFF)),\n\t\t\tsignature,\n\t\t\tcompressed: compressionMethod != 0,\n\t\t\tencrypted,\n\t\t\tuseWebWorkers: getOptionValue$1(zipEntry, options, "useWebWorkers")\n\t\t}, config);\n\t\tif (!writer.initialized) {\n\t\t\tawait writer.init();\n\t\t}\n\t\tconst signal = getOptionValue$1(zipEntry, options, "signal");\n\t\tconst dataOffset = offset + 30 + localDirectory.filenameLength + localDirectory.extraFieldLength;\n\t\tawait processData(codec, reader, writer, dataOffset, compressedSize, config, { onprogress: options.onprogress, signal });\n\t\treturn writer.getData();\n\t}\n}\n\nfunction readCommonHeader(directory, dataView, offset) {\n\tconst rawBitFlag = directory.rawBitFlag = getUint16(dataView, offset + 2);\n\tconst encrypted = (rawBitFlag & BITFLAG_ENCRYPTED) == BITFLAG_ENCRYPTED;\n\tconst rawLastModDate = getUint32(dataView, offset + 6);\n\tObject.assign(directory, {\n\t\tencrypted,\n\t\tversion: getUint16(dataView, offset),\n\t\tbitFlag: {\n\t\t\tlevel: (rawBitFlag & BITFLAG_LEVEL) >> 1,\n\t\t\tdataDescriptor: (rawBitFlag & BITFLAG_DATA_DESCRIPTOR) == BITFLAG_DATA_DESCRIPTOR,\n\t\t\tlanguageEncodingFlag: (rawBitFlag & BITFLAG_LANG_ENCODING_FLAG) == BITFLAG_LANG_ENCODING_FLAG\n\t\t},\n\t\trawLastModDate,\n\t\tlastModDate: getDate(rawLastModDate),\n\t\tfilenameLength: getUint16(dataView, offset + 22),\n\t\textraFieldLength: getUint16(dataView, offset + 24)\n\t});\n}\n\nfunction readCommonFooter(fileEntry, directory, dataView, offset) {\n\tconst rawExtraField = directory.rawExtraField;\n\tconst extraField = directory.extraField = new Map();\n\tconst rawExtraFieldView = getDataView$1(new Uint8Array(rawExtraField));\n\tlet offsetExtraField = 0;\n\ttry {\n\t\twhile (offsetExtraField < rawExtraField.length) {\n\t\t\tconst type = getUint16(rawExtraFieldView, offsetExtraField);\n\t\t\tconst size = getUint16(rawExtraFieldView, offsetExtraField + 2);\n\t\t\textraField.set(type, {\n\t\t\t\ttype,\n\t\t\t\tdata: rawExtraField.slice(offsetExtraField + 4, offsetExtraField + 4 + size)\n\t\t\t});\n\t\t\toffsetExtraField += 4 + size;\n\t\t}\n\t} catch (error) {\n\t\t// ignored\n\t}\n\tconst compressionMethod = getUint16(dataView, offset + 4);\n\tdirectory.signature = getUint32(dataView, offset + 10);\n\tdirectory.uncompressedSize = getUint32(dataView, offset + 18);\n\tdirectory.compressedSize = getUint32(dataView, offset + 14);\n\tconst extraFieldZip64 = extraField.get(EXTRAFIELD_TYPE_ZIP64);\n\tif (extraFieldZip64) {\n\t\treadExtraFieldZip64(extraFieldZip64, directory);\n\t\tdirectory.extraFieldZip64 = extraFieldZip64;\n\t}\n\tconst extraFieldUnicodePath = extraField.get(EXTRAFIELD_TYPE_UNICODE_PATH);\n\tif (extraFieldUnicodePath) {\n\t\treadExtraFieldUnicode(extraFieldUnicodePath, "filename", "rawFilename", directory, fileEntry);\n\t\tdirectory.extraFieldUnicodePath = extraFieldUnicodePath;\n\t}\n\tconst extraFieldUnicodeComment = extraField.get(EXTRAFIELD_TYPE_UNICODE_COMMENT);\n\tif (extraFieldUnicodeComment) {\n\t\treadExtraFieldUnicode(extraFieldUnicodeComment, "comment", "rawComment", directory, fileEntry);\n\t\tdirectory.extraFieldUnicodeComment = extraFieldUnicodeComment;\n\t}\n\tconst extraFieldAES = extraField.get(EXTRAFIELD_TYPE_AES);\n\tif (extraFieldAES) {\n\t\treadExtraFieldAES(extraFieldAES, directory, compressionMethod);\n\t\tdirectory.extraFieldAES = extraFieldAES;\n\t} else {\n\t\tdirectory.compressionMethod = compressionMethod;\n\t}\n\tconst extraFieldNTFS = extraField.get(EXTRAFIELD_TYPE_NTFS);\n\tif (extraFieldNTFS) {\n\t\treadExtraFieldNTFS(extraFieldNTFS, directory);\n\t\tdirectory.extraFieldNTFS = extraFieldNTFS;\n\t}\n\tconst extraFieldExtendedTimestamp = extraField.get(EXTRAFIELD_TYPE_EXTENDED_TIMESTAMP);\n\tif (extraFieldExtendedTimestamp) {\n\t\treadExtraFieldExtendedTimestamp(extraFieldExtendedTimestamp, directory);\n\t\tdirectory.extraFieldExtendedTimestamp = extraFieldExtendedTimestamp;\n\t}\n}\n\nfunction readExtraFieldZip64(extraFieldZip64, directory) {\n\tdirectory.zip64 = true;\n\tconst extraFieldView = getDataView$1(extraFieldZip64.data);\n\textraFieldZip64.values = [];\n\tfor (let indexValue = 0; indexValue < Math.floor(extraFieldZip64.data.length / 8); indexValue++) {\n\t\textraFieldZip64.values.push(getBigUint64(extraFieldView, 0 + indexValue * 8));\n\t}\n\tconst missingProperties = ZIP64_PROPERTIES.filter(propertyName => directory[propertyName] == MAX_32_BITS);\n\tfor (let indexMissingProperty = 0; indexMissingProperty < missingProperties.length; indexMissingProperty++) {\n\t\textraFieldZip64[missingProperties[indexMissingProperty]] = extraFieldZip64.values[indexMissingProperty];\n\t}\n\tZIP64_PROPERTIES.forEach(propertyName => {\n\t\tif (directory[propertyName] == MAX_32_BITS) {\n\t\t\tif (extraFieldZip64[propertyName] !== undefined) {\n\t\t\t\tdirectory[propertyName] = extraFieldZip64[propertyName];\n\t\t\t} else {\n\t\t\t\tthrow new Error(ERR_EXTRAFIELD_ZIP64_NOT_FOUND);\n\t\t\t}\n\t\t}\n\t});\n}\n\nfunction readExtraFieldUnicode(extraFieldUnicode, propertyName, rawPropertyName, directory, fileEntry) {\n\tconst extraFieldView = getDataView$1(extraFieldUnicode.data);\n\textraFieldUnicode.version = getUint8(extraFieldView, 0);\n\textraFieldUnicode.signature = getUint32(extraFieldView, 1);\n\tconst crc32 = new Crc32();\n\tcrc32.append(fileEntry[rawPropertyName]);\n\tconst dataViewSignature = getDataView$1(new Uint8Array(4));\n\tdataViewSignature.setUint32(0, crc32.get(), true);\n\textraFieldUnicode[propertyName] = (new TextDecoder()).decode(extraFieldUnicode.data.subarray(5));\n\textraFieldUnicode.valid = !fileEntry.bitFlag.languageEncodingFlag && extraFieldUnicode.signature == getUint32(dataViewSignature, 0);\n\tif (extraFieldUnicode.valid) {\n\t\tdirectory[propertyName] = extraFieldUnicode[propertyName];\n\t\tdirectory[propertyName + "UTF8"] = true;\n\t}\n}\n\nfunction readExtraFieldAES(extraFieldAES, directory, compressionMethod) {\n\tconst extraFieldView = getDataView$1(extraFieldAES.data);\n\textraFieldAES.vendorVersion = getUint8(extraFieldView, 0);\n\textraFieldAES.vendorId = getUint8(extraFieldView, 2);\n\tconst strength = getUint8(extraFieldView, 4);\n\textraFieldAES.strength = strength;\n\textraFieldAES.originalCompressionMethod = compressionMethod;\n\tdirectory.compressionMethod = extraFieldAES.compressionMethod = getUint16(extraFieldView, 5);\n}\n\nfunction readExtraFieldNTFS(extraFieldNTFS, directory) {\n\tconst extraFieldView = getDataView$1(extraFieldNTFS.data);\n\tlet offsetExtraField = 4;\n\tlet tag1Data;\n\ttry {\n\t\twhile (offsetExtraField < extraFieldNTFS.data.length && !tag1Data) {\n\t\t\tconst tagValue = getUint16(extraFieldView, offsetExtraField);\n\t\t\tconst attributeSize = getUint16(extraFieldView, offsetExtraField + 2);\n\t\t\tif (tagValue == EXTRAFIELD_TYPE_NTFS_TAG1) {\n\t\t\t\ttag1Data = extraFieldNTFS.data.slice(offsetExtraField + 4, offsetExtraField + 4 + attributeSize);\n\t\t\t}\n\t\t\toffsetExtraField += 4 + attributeSize;\n\t\t}\n\t} catch (error) {\n\t\t// ignored\n\t}\n\ttry {\n\t\tif (tag1Data && tag1Data.length == 24) {\n\t\t\tconst tag1View = getDataView$1(tag1Data);\n\t\t\tconst rawLastModDate = tag1View.getBigUint64(0, true);\n\t\t\tconst rawLastAccessDate = tag1View.getBigUint64(8, true);\n\t\t\tconst rawCreationDate = tag1View.getBigUint64(16, true);\n\t\t\tObject.assign(extraFieldNTFS, {\n\t\t\t\trawLastModDate,\n\t\t\t\trawLastAccessDate,\n\t\t\t\trawCreationDate\n\t\t\t});\n\t\t\tconst lastModDate = getDateNTFS(rawLastModDate);\n\t\t\tconst lastAccessDate = getDateNTFS(rawLastAccessDate);\n\t\t\tconst creationDate = getDateNTFS(rawCreationDate);\n\t\t\tconst extraFieldData = { lastModDate, lastAccessDate, creationDate };\n\t\t\tObject.assign(extraFieldNTFS, extraFieldData);\n\t\t\tObject.assign(directory, extraFieldData);\n\t\t}\n\t} catch (error) {\n\t\t// ignored\n\t}\n}\n\nfunction readExtraFieldExtendedTimestamp(extraFieldExtendedTimestamp, directory) {\n\tconst extraFieldView = getDataView$1(extraFieldExtendedTimestamp.data);\n\tconst flags = getUint8(extraFieldView, 0);\n\tconst timeProperties = [];\n\tconst timeRawProperties = [];\n\tif ((flags & 0x1) == 0x1) {\n\t\ttimeProperties.push("lastModDate");\n\t\ttimeRawProperties.push("rawLastModDate");\n\t}\n\tif ((flags & 0x2) == 0x2) {\n\t\ttimeProperties.push("lastAccessDate");\n\t\ttimeRawProperties.push("rawLastAccessDate");\n\t}\n\tif ((flags & 0x4) == 0x4) {\n\t\ttimeProperties.push("creationDate");\n\t\ttimeRawProperties.push("rawCreationDate");\n\t}\n\tlet offset = 1;\n\ttimeProperties.forEach((propertyName, indexProperty) => {\n\t\tif (extraFieldExtendedTimestamp.data.length >= offset + 4) {\n\t\t\tconst time = getUint32(extraFieldView, offset);\n\t\t\tdirectory[propertyName] = extraFieldExtendedTimestamp[propertyName] = new Date(time * 1000);\n\t\t\tconst rawPropertyName = timeRawProperties[indexProperty];\n\t\t\textraFieldExtendedTimestamp[rawPropertyName] = time;\n\t\t}\n\t\toffset += 4;\n\t});\n}\n\nasync function seekSignature(reader, signature, startOffset, minimumBytes, maximumLength) {\n\tconst signatureArray = new Uint8Array(4);\n\tconst signatureView = getDataView$1(signatureArray);\n\tsetUint32$1(signatureView, 0, signature);\n\tconst maximumBytes = minimumBytes + maximumLength;\n\treturn (await seek(minimumBytes)) || await seek(Math.min(maximumBytes, startOffset));\n\n\tasync function seek(length) {\n\t\tconst offset = startOffset - length;\n\t\tconst bytes = await readUint8Array(reader, offset, length);\n\t\tfor (let indexByte = bytes.length - minimumBytes; indexByte >= 0; indexByte--) {\n\t\t\tif (bytes[indexByte] == signatureArray[0] && bytes[indexByte + 1] == signatureArray[1] &&\n\t\t\t\tbytes[indexByte + 2] == signatureArray[2] && bytes[indexByte + 3] == signatureArray[3]) {\n\t\t\t\treturn {\n\t\t\t\t\toffset: offset + indexByte,\n\t\t\t\t\tbuffer: bytes.slice(indexByte, indexByte + minimumBytes).buffer\n\t\t\t\t};\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunction getOptionValue$1(zipReader, options, name) {\n\treturn options[name] === undefined ? zipReader.options[name] : options[name];\n}\n\nfunction decodeString(value, encoding) {\n\tif (!encoding || encoding.trim().toLowerCase() == "cp437") {\n\t\treturn decodeCP437(value);\n\t} else {\n\t\treturn (new TextDecoder(encoding)).decode(value);\n\t}\n}\n\nfunction getDate(timeRaw) {\n\tconst date = (timeRaw & 0xffff0000) >> 16, time = timeRaw & 0x0000ffff;\n\ttry {\n\t\treturn new Date(1980 + ((date & 0xFE00) >> 9), ((date & 0x01E0) >> 5) - 1, date & 0x001F, (time & 0xF800) >> 11, (time & 0x07E0) >> 5, (time & 0x001F) * 2, 0);\n\t} catch (error) {\n\t\t// ignored\n\t}\n}\n\nfunction getDateNTFS(timeRaw) {\n\treturn new Date((Number((timeRaw / BigInt(10000)) - BigInt(11644473600000))));\n}\n\nfunction getUint8(view, offset) {\n\treturn view.getUint8(offset);\n}\n\nfunction getUint16(view, offset) {\n\treturn view.getUint16(offset, true);\n}\n\nfunction getUint32(view, offset) {\n\treturn view.getUint32(offset, true);\n}\n\nfunction getBigUint64(view, offset) {\n\treturn Number(view.getBigUint64(offset, true));\n}\n\nfunction setUint32$1(view, offset, value) {\n\tview.setUint32(offset, value, true);\n}\n\nfunction getDataView$1(array) {\n\treturn new DataView(array.buffer);\n}\n\nfunction readUint8Array(reader, offset, size) {\n\treturn reader.readUint8Array(offset, size);\n}\n\n/*\n Copyright (c) 2021 Gildas Lormeau. All rights reserved.\n\n Redistribution and use in source and binary forms, with or without\n modification, are permitted provided that the following conditions are met:\n\n 1. Redistributions of source code must retain the above copyright notice,\n this list of conditions and the following disclaimer.\n\n 2. Redistributions in binary form must reproduce the above copyright \n notice, this list of conditions and the following disclaimer in \n the documentation and/or other materials provided with the distribution.\n\n 3. The names of the authors may not be used to endorse or promote products\n derived from this software without specific prior written permission.\n\n THIS SOFTWARE IS PROVIDED \'\'AS IS\'\' AND ANY EXPRESSED OR IMPLIED WARRANTIES,\n INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\n FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL JCRAFT,\n INC. OR ANY CONTRIBUTORS TO THIS SOFTWARE BE LIABLE FOR ANY DIRECT, INDIRECT,\n INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,\n OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF\n LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING\n NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,\n EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\nconst ERR_DUPLICATED_NAME = "File already exists";\nconst ERR_INVALID_COMMENT = "Zip file comment exceeds 64KB";\nconst ERR_INVALID_ENTRY_COMMENT = "File entry comment exceeds 64KB";\nconst ERR_INVALID_ENTRY_NAME = "File entry name exceeds 64KB";\nconst ERR_INVALID_VERSION = "Version exceeds 65535";\nconst ERR_INVALID_ENCRYPTION_STRENGTH = "The strength must equal 1, 2, or 3";\nconst ERR_INVALID_EXTRAFIELD_TYPE = "Extra field type exceeds 65535";\nconst ERR_INVALID_EXTRAFIELD_DATA = "Extra field data exceeds 64KB";\nconst ERR_UNSUPPORTED_FORMAT = "Zip64 is not supported";\n\nconst EXTRAFIELD_DATA_AES = new Uint8Array([0x07, 0x00, 0x02, 0x00, 0x41, 0x45, 0x03, 0x00, 0x00]);\nconst EXTRAFIELD_LENGTH_ZIP64 = 24;\n\nlet workers = 0;\n\nclass ZipWriter {\n\n\tconstructor(writer, options = {}) {\n\t\tObject.assign(this, {\n\t\t\twriter,\n\t\t\toptions,\n\t\t\tconfig: getConfiguration(),\n\t\t\tfiles: new Map(),\n\t\t\toffset: writer.size,\n\t\t\tpendingCompressedSize: 0,\n\t\t\tpendingEntries: []\n\t\t});\n\t}\n\n\tasync add(name = "", reader, options = {}) {\n\t\tconst zipWriter = this;\n\t\tif (workers < zipWriter.config.maxWorkers) {\n\t\t\tworkers++;\n\t\t\ttry {\n\t\t\t\treturn await addFile(zipWriter, name, reader, options);\n\t\t\t} finally {\n\t\t\t\tworkers--;\n\t\t\t\tconst pendingEntry = zipWriter.pendingEntries.shift();\n\t\t\t\tif (pendingEntry) {\n\t\t\t\t\tzipWriter.add(pendingEntry.name, pendingEntry.reader, pendingEntry.options)\n\t\t\t\t\t\t.then(pendingEntry.resolve)\n\t\t\t\t\t\t.catch(pendingEntry.reject);\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\treturn new Promise((resolve, reject) => zipWriter.pendingEntries.push({ name, reader, options, resolve, reject }));\n\t\t}\n\t}\n\n\tasync close(comment = new Uint8Array(0), options = {}) {\n\t\tawait closeFile(this, comment, options);\n\t\treturn this.writer.getData();\n\t}\n}\n\nasync function addFile(zipWriter, name, reader, options) {\n\tname = name.trim();\n\tif (options.directory && (!name.endsWith(DIRECTORY_SIGNATURE))) {\n\t\tname += DIRECTORY_SIGNATURE;\n\t} else {\n\t\toptions.directory = name.endsWith(DIRECTORY_SIGNATURE);\n\t}\n\tif (zipWriter.files.has(name)) {\n\t\tthrow new Error(ERR_DUPLICATED_NAME);\n\t}\n\tconst rawFilename = (new TextEncoder()).encode(name);\n\tif (rawFilename.length > MAX_16_BITS) {\n\t\tthrow new Error(ERR_INVALID_ENTRY_NAME);\n\t}\n\tconst comment = options.comment || "";\n\tconst rawComment = (new TextEncoder()).encode(comment);\n\tif (rawComment.length > MAX_16_BITS) {\n\t\tthrow new Error(ERR_INVALID_ENTRY_COMMENT);\n\t}\n\tconst version = zipWriter.options.version || options.version || 0;\n\tif (version > MAX_16_BITS) {\n\t\tthrow new Error(ERR_INVALID_VERSION);\n\t}\n\tconst versionMadeBy = zipWriter.options.versionMadeBy || options.versionMadeBy || 20;\n\tif (versionMadeBy > MAX_16_BITS) {\n\t\tthrow new Error(ERR_INVALID_VERSION);\n\t}\n\tconst lastModDate = getOptionValue(zipWriter, options, "lastModDate") || new Date();\n\tconst lastAccessDate = getOptionValue(zipWriter, options, "lastAccessDate");\n\tconst creationDate = getOptionValue(zipWriter, options, "creationDate");\n\tconst password = getOptionValue(zipWriter, options, "password");\n\tconst encryptionStrength = getOptionValue(zipWriter, options, "encryptionStrength") || 3;\n\tconst zipCrypto = getOptionValue(zipWriter, options, "zipCrypto");\n\tif (password !== undefined && encryptionStrength !== undefined && (encryptionStrength < 1 || encryptionStrength > 3)) {\n\t\tthrow new Error(ERR_INVALID_ENCRYPTION_STRENGTH);\n\t}\n\tlet rawExtraField = new Uint8Array(0);\n\tconst extraField = options.extraField;\n\tif (extraField) {\n\t\tlet extraFieldSize = 0;\n\t\tlet offset = 0;\n\t\textraField.forEach(data => extraFieldSize += 4 + data.length);\n\t\trawExtraField = new Uint8Array(extraFieldSize);\n\t\textraField.forEach((data, type) => {\n\t\t\tif (type > MAX_16_BITS) {\n\t\t\t\tthrow new Error(ERR_INVALID_EXTRAFIELD_TYPE);\n\t\t\t}\n\t\t\tif (data.length > MAX_16_BITS) {\n\t\t\t\tthrow new Error(ERR_INVALID_EXTRAFIELD_DATA);\n\t\t\t}\n\t\t\tarraySet(rawExtraField, new Uint16Array([type]), offset);\n\t\t\tarraySet(rawExtraField, new Uint16Array([data.length]), offset + 2);\n\t\t\tarraySet(rawExtraField, data, offset + 4);\n\t\t\toffset += 4 + data.length;\n\t\t});\n\t}\n\tlet extendedTimestamp = getOptionValue(zipWriter, options, "extendedTimestamp");\n\tif (extendedTimestamp === undefined) {\n\t\textendedTimestamp = true;\n\t}\n\tlet maximumCompressedSize = 0;\n\tlet keepOrder = getOptionValue(zipWriter, options, "keepOrder");\n\tif (keepOrder === undefined) {\n\t\tkeepOrder = true;\n\t}\n\tlet uncompressedSize = 0;\n\tlet msDosCompatible = getOptionValue(zipWriter, options, "msDosCompatible");\n\tif (msDosCompatible === undefined) {\n\t\tmsDosCompatible = true;\n\t}\n\tconst internalFileAttribute = getOptionValue(zipWriter, options, "internalFileAttribute") || 0;\n\tconst externalFileAttribute = getOptionValue(zipWriter, options, "externalFileAttribute") || 0;\n\tif (reader) {\n\t\tif (!reader.initialized) {\n\t\t\tawait reader.init();\n\t\t}\n\t\tuncompressedSize = reader.size;\n\t\tmaximumCompressedSize = getMaximumCompressedSize(uncompressedSize);\n\t}\n\tlet zip64 = options.zip64 || zipWriter.options.zip64 || false;\n\tif (zipWriter.offset + zipWriter.pendingCompressedSize >= MAX_32_BITS ||\n\t\tuncompressedSize >= MAX_32_BITS ||\n\t\tmaximumCompressedSize >= MAX_32_BITS) {\n\t\tif (options.zip64 === false || zipWriter.options.zip64 === false || !keepOrder) {\n\t\t\tthrow new Error(ERR_UNSUPPORTED_FORMAT);\n\t\t} else {\n\t\t\tzip64 = true;\n\t\t}\n\t}\n\tzipWriter.pendingCompressedSize += maximumCompressedSize;\n\tawait Promise.resolve();\n\tconst level = getOptionValue(zipWriter, options, "level");\n\tconst useWebWorkers = getOptionValue(zipWriter, options, "useWebWorkers");\n\tconst bufferedWrite = getOptionValue(zipWriter, options, "bufferedWrite");\n\tlet dataDescriptor = getOptionValue(zipWriter, options, "dataDescriptor");\n\tconst signal = getOptionValue(zipWriter, options, "signal");\n\tif (dataDescriptor === undefined) {\n\t\tdataDescriptor = true;\n\t}\n\tconst fileEntry = await getFileEntry(zipWriter, name, reader, Object.assign({}, options, {\n\t\trawFilename,\n\t\trawComment,\n\t\tversion,\n\t\tversionMadeBy,\n\t\tlastModDate,\n\t\tlastAccessDate,\n\t\tcreationDate,\n\t\trawExtraField,\n\t\tzip64,\n\t\tpassword,\n\t\tlevel,\n\t\tuseWebWorkers,\n\t\tencryptionStrength,\n\t\textendedTimestamp,\n\t\tzipCrypto,\n\t\tbufferedWrite,\n\t\tkeepOrder,\n\t\tdataDescriptor,\n\t\tsignal,\n\t\tmsDosCompatible,\n\t\tinternalFileAttribute,\n\t\texternalFileAttribute\n\t}));\n\tif (maximumCompressedSize) {\n\t\tzipWriter.pendingCompressedSize -= maximumCompressedSize;\n\t}\n\tObject.assign(fileEntry, { name, comment, extraField });\n\treturn new Entry(fileEntry);\n}\n\nasync function getFileEntry(zipWriter, name, reader, options) {\n\tconst files = zipWriter.files;\n\tconst writer = zipWriter.writer;\n\tconst previousFileEntry = Array.from(files.values()).pop();\n\tlet fileEntry = {};\n\tlet bufferedWrite;\n\tlet resolveLockUnbufferedWrite;\n\tlet resolveLockCurrentFileEntry;\n\tfiles.set(name, fileEntry);\n\ttry {\n\t\tlet lockPreviousFileEntry;\n\t\tlet fileWriter;\n\t\tlet lockCurrentFileEntry;\n\t\tif (options.keepOrder) {\n\t\t\tlockPreviousFileEntry = previousFileEntry && previousFileEntry.lock;\n\t\t}\n\t\tfileEntry.lock = lockCurrentFileEntry = new Promise(resolve => resolveLockCurrentFileEntry = resolve);\n\t\tif (options.bufferedWrite || zipWriter.lockWrite || !options.dataDescriptor) {\n\t\t\tfileWriter = new BlobWriter();\n\t\t\tfileWriter.init();\n\t\t\tbufferedWrite = true;\n\t\t} else {\n\t\t\tzipWriter.lockWrite = new Promise(resolve => resolveLockUnbufferedWrite = resolve);\n\t\t\tif (!writer.initialized) {\n\t\t\t\tawait writer.init();\n\t\t\t}\n\t\t\tfileWriter = writer;\n\t\t}\n\t\tfileEntry = await createFileEntry(reader, fileWriter, zipWriter.config, options);\n\t\tfileEntry.lock = lockCurrentFileEntry;\n\t\tfiles.set(name, fileEntry);\n\t\tfileEntry.filename = name;\n\t\tif (bufferedWrite) {\n\t\t\tlet indexWrittenData = 0;\n\t\t\tconst blob = fileWriter.getData();\n\t\t\tawait Promise.all([zipWriter.lockWrite, lockPreviousFileEntry]);\n\t\t\tlet pendingFileEntry;\n\t\t\tdo {\n\t\t\t\tpendingFileEntry = Array.from(files.values()).find(fileEntry => fileEntry.writingBufferedData);\n\t\t\t\tif (pendingFileEntry) {\n\t\t\t\t\tawait pendingFileEntry.lock;\n\t\t\t\t}\n\t\t\t} while (pendingFileEntry && pendingFileEntry.lock);\n\t\t\tfileEntry.writingBufferedData = true;\n\t\t\tif (!options.dataDescriptor) {\n\t\t\t\tconst headerLength = 26;\n\t\t\t\tconst arrayBuffer = await sliceAsArrayBuffer(blob, 0, headerLength);\n\t\t\t\tconst arrayBufferView = new DataView(arrayBuffer);\n\t\t\t\tif (!fileEntry.encrypted || options.zipCrypto) {\n\t\t\t\t\tsetUint32(arrayBufferView, 14, fileEntry.signature);\n\t\t\t\t}\n\t\t\t\tif (fileEntry.zip64) {\n\t\t\t\t\tsetUint32(arrayBufferView, 18, MAX_32_BITS);\n\t\t\t\t\tsetUint32(arrayBufferView, 22, MAX_32_BITS);\n\t\t\t\t} else {\n\t\t\t\t\tsetUint32(arrayBufferView, 18, fileEntry.compressedSize);\n\t\t\t\t\tsetUint32(arrayBufferView, 22, fileEntry.uncompressedSize);\n\t\t\t\t}\n\t\t\t\tawait writer.writeUint8Array(new Uint8Array(arrayBuffer));\n\t\t\t\tindexWrittenData = headerLength;\n\t\t\t}\n\t\t\tawait writeBlob(writer, blob, indexWrittenData);\n\t\t\tdelete fileEntry.writingBufferedData;\n\t\t}\n\t\tfileEntry.offset = zipWriter.offset;\n\t\tif (fileEntry.zip64) {\n\t\t\tconst rawExtraFieldZip64View = getDataView(fileEntry.rawExtraFieldZip64);\n\t\t\tsetBigUint64(rawExtraFieldZip64View, 20, BigInt(fileEntry.offset));\n\t\t} else if (fileEntry.offset >= MAX_32_BITS) {\n\t\t\tthrow new Error(ERR_UNSUPPORTED_FORMAT);\n\t\t}\n\t\tzipWriter.offset += fileEntry.length;\n\t\treturn fileEntry;\n\t} catch (error) {\n\t\tif ((bufferedWrite && fileEntry.writingBufferedData) || (!bufferedWrite && fileEntry.dataWritten)) {\n\t\t\terror.corruptedEntry = zipWriter.hasCorruptedEntries = true;\n\t\t\tif (fileEntry.uncompressedSize) {\n\t\t\t\tzipWriter.offset += fileEntry.uncompressedSize;\n\t\t\t}\n\t\t}\n\t\tfiles.delete(name);\n\t\tthrow error;\n\t} finally {\n\t\tresolveLockCurrentFileEntry();\n\t\tif (resolveLockUnbufferedWrite) {\n\t\t\tresolveLockUnbufferedWrite();\n\t\t}\n\t}\n}\n\nasync function createFileEntry(reader, writer, config, options) {\n\tconst {\n\t\trawFilename,\n\t\tlastAccessDate,\n\t\tcreationDate,\n\t\tpassword,\n\t\tlevel,\n\t\tzip64,\n\t\tzipCrypto,\n\t\tdataDescriptor,\n\t\tdirectory,\n\t\tversion,\n\t\tversionMadeBy,\n\t\trawComment,\n\t\trawExtraField,\n\t\tuseWebWorkers,\n\t\tonprogress,\n\t\tsignal,\n\t\tencryptionStrength,\n\t\textendedTimestamp,\n\t\tmsDosCompatible,\n\t\tinternalFileAttribute,\n\t\texternalFileAttribute\n\t} = options;\n\tconst encrypted = Boolean(password && password.length);\n\tconst compressed = level !== 0 && !directory;\n\tlet rawExtraFieldAES;\n\tif (encrypted && !zipCrypto) {\n\t\trawExtraFieldAES = new Uint8Array(EXTRAFIELD_DATA_AES.length + 2);\n\t\tconst extraFieldAESView = getDataView(rawExtraFieldAES);\n\t\tsetUint16(extraFieldAESView, 0, EXTRAFIELD_TYPE_AES);\n\t\tarraySet(rawExtraFieldAES, EXTRAFIELD_DATA_AES, 2);\n\t\tsetUint8(extraFieldAESView, 8, encryptionStrength);\n\t} else {\n\t\trawExtraFieldAES = new Uint8Array(0);\n\t}\n\tlet rawExtraFieldNTFS;\n\tlet rawExtraFieldExtendedTimestamp;\n\tif (extendedTimestamp) {\n\t\trawExtraFieldExtendedTimestamp = new Uint8Array(9 + (lastAccessDate ? 4 : 0) + (creationDate ? 4 : 0));\n\t\tconst extraFieldExtendedTimestampView = getDataView(rawExtraFieldExtendedTimestamp);\n\t\tsetUint16(extraFieldExtendedTimestampView, 0, EXTRAFIELD_TYPE_EXTENDED_TIMESTAMP);\n\t\tsetUint16(extraFieldExtendedTimestampView, 2, rawExtraFieldExtendedTimestamp.length - 4);\n\t\tconst extraFieldExtendedTimestampFlag = 0x1 + (lastAccessDate ? 0x2 : 0) + (creationDate ? 0x4 : 0);\n\t\tsetUint8(extraFieldExtendedTimestampView, 4, extraFieldExtendedTimestampFlag);\n\t\tsetUint32(extraFieldExtendedTimestampView, 5, Math.floor(options.lastModDate.getTime() / 1000));\n\t\tif (lastAccessDate) {\n\t\t\tsetUint32(extraFieldExtendedTimestampView, 9, Math.floor(lastAccessDate.getTime() / 1000));\n\t\t}\n\t\tif (creationDate) {\n\t\t\tsetUint32(extraFieldExtendedTimestampView, 13, Math.floor(creationDate.getTime() / 1000));\n\t\t}\n\t\ttry {\n\t\t\trawExtraFieldNTFS = new Uint8Array(36);\n\t\t\tconst extraFieldNTFSView = getDataView(rawExtraFieldNTFS);\n\t\t\tconst lastModTimeNTFS = getTimeNTFS(options.lastModDate);\n\t\t\tsetUint16(extraFieldNTFSView, 0, EXTRAFIELD_TYPE_NTFS);\n\t\t\tsetUint16(extraFieldNTFSView, 2, 32);\n\t\t\tsetUint16(extraFieldNTFSView, 8, EXTRAFIELD_TYPE_NTFS_TAG1);\n\t\t\tsetUint16(extraFieldNTFSView, 10, 24);\n\t\t\tsetBigUint64(extraFieldNTFSView, 12, lastModTimeNTFS);\n\t\t\tsetBigUint64(extraFieldNTFSView, 20, getTimeNTFS(lastAccessDate) || lastModTimeNTFS);\n\t\t\tsetBigUint64(extraFieldNTFSView, 28, getTimeNTFS(creationDate) || lastModTimeNTFS);\n\t\t} catch (error) {\n\t\t\trawExtraFieldNTFS = new Uint8Array(0);\n\t\t}\n\t} else {\n\t\trawExtraFieldNTFS = rawExtraFieldExtendedTimestamp = new Uint8Array(0);\n\t}\n\tconst fileEntry = {\n\t\tversion: version || VERSION_DEFLATE,\n\t\tversionMadeBy,\n\t\tzip64,\n\t\tdirectory: Boolean(directory),\n\t\tfilenameUTF8: true,\n\t\trawFilename,\n\t\tcommentUTF8: true,\n\t\trawComment,\n\t\trawExtraFieldZip64: zip64 ? new Uint8Array(EXTRAFIELD_LENGTH_ZIP64 + 4) : new Uint8Array(0),\n\t\trawExtraFieldExtendedTimestamp,\n\t\trawExtraFieldNTFS,\n\t\trawExtraFieldAES,\n\t\trawExtraField,\n\t\textendedTimestamp,\n\t\tmsDosCompatible,\n\t\tinternalFileAttribute,\n\t\texternalFileAttribute\n\t};\n\tlet uncompressedSize = fileEntry.uncompressedSize = 0;\n\tlet bitFlag = BITFLAG_LANG_ENCODING_FLAG;\n\tif (dataDescriptor) {\n\t\tbitFlag = bitFlag | BITFLAG_DATA_DESCRIPTOR;\n\t}\n\tlet compressionMethod = COMPRESSION_METHOD_STORE;\n\tif (compressed) {\n\t\tcompressionMethod = COMPRESSION_METHOD_DEFLATE;\n\t}\n\tif (zip64) {\n\t\tfileEntry.version = fileEntry.version > VERSION_ZIP64 ? fileEntry.version : VERSION_ZIP64;\n\t}\n\tif (encrypted) {\n\t\tbitFlag = bitFlag | BITFLAG_ENCRYPTED;\n\t\tif (!zipCrypto) {\n\t\t\tfileEntry.version = fileEntry.version > VERSION_AES ? fileEntry.version : VERSION_AES;\n\t\t\tcompressionMethod = COMPRESSION_METHOD_AES;\n\t\t\tif (compressed) {\n\t\t\t\tfileEntry.rawExtraFieldAES[9] = COMPRESSION_METHOD_DEFLATE;\n\t\t\t}\n\t\t}\n\t}\n\tfileEntry.compressionMethod = compressionMethod;\n\tconst headerArray = fileEntry.headerArray = new Uint8Array(26);\n\tconst headerView = getDataView(headerArray);\n\tsetUint16(headerView, 0, fileEntry.version);\n\tsetUint16(headerView, 2, bitFlag);\n\tsetUint16(headerView, 4, compressionMethod);\n\tconst dateArray = new Uint32Array(1);\n\tconst dateView = getDataView(dateArray);\n\tlet lastModDate;\n\tif (options.lastModDate < MIN_DATE) {\n\t\tlastModDate = MIN_DATE;\n\t} else if (options.lastModDate > MAX_DATE) {\n\t\tlastModDate = MAX_DATE;\n\t} else {\n\t\tlastModDate = options.lastModDate;\n\t}\n\tsetUint16(dateView, 0, (((lastModDate.getHours() << 6) | lastModDate.getMinutes()) << 5) | lastModDate.getSeconds() / 2);\n\tsetUint16(dateView, 2, ((((lastModDate.getFullYear() - 1980) << 4) | (lastModDate.getMonth() + 1)) << 5) | lastModDate.getDate());\n\tconst rawLastModDate = dateArray[0];\n\tsetUint32(headerView, 6, rawLastModDate);\n\tsetUint16(headerView, 22, rawFilename.length);\n\tconst extraFieldLength = rawExtraFieldAES.length + rawExtraFieldExtendedTimestamp.length + rawExtraFieldNTFS.length + fileEntry.rawExtraField.length;\n\tsetUint16(headerView, 24, extraFieldLength);\n\tconst localHeaderArray = new Uint8Array(30 + rawFilename.length + extraFieldLength);\n\tconst localHeaderView = getDataView(localHeaderArray);\n\tsetUint32(localHeaderView, 0, LOCAL_FILE_HEADER_SIGNATURE);\n\tarraySet(localHeaderArray, headerArray, 4);\n\tarraySet(localHeaderArray, rawFilename, 30);\n\tarraySet(localHeaderArray, rawExtraFieldAES, 30 + rawFilename.length);\n\tarraySet(localHeaderArray, rawExtraFieldExtendedTimestamp, 30 + rawFilename.length + rawExtraFieldAES.length);\n\tarraySet(localHeaderArray, rawExtraFieldNTFS, 30 + rawFilename.length + rawExtraFieldAES.length + rawExtraFieldExtendedTimestamp.length);\n\tarraySet(localHeaderArray, fileEntry.rawExtraField, 30 + rawFilename.length + rawExtraFieldAES.length + rawExtraFieldExtendedTimestamp.length + rawExtraFieldNTFS.length);\n\tlet result;\n\tlet compressedSize = 0;\n\tif (reader) {\n\t\tuncompressedSize = fileEntry.uncompressedSize = reader.size;\n\t\tconst codec = await createCodec(config.Deflate, {\n\t\t\tcodecType: CODEC_DEFLATE,\n\t\t\tlevel,\n\t\t\tpassword,\n\t\t\tencryptionStrength,\n\t\t\tzipCrypto: encrypted && zipCrypto,\n\t\t\tpasswordVerification: encrypted && zipCrypto && (rawLastModDate >> 8) & 0xFF,\n\t\t\tsigned: true,\n\t\t\tcompressed,\n\t\t\tencrypted,\n\t\t\tuseWebWorkers\n\t\t}, config);\n\t\tawait writer.writeUint8Array(localHeaderArray);\n\t\tfileEntry.dataWritten = true;\n\t\tresult = await processData(codec, reader, writer, 0, uncompressedSize, config, { onprogress, signal });\n\t\tcompressedSize = result.length;\n\t} else {\n\t\tawait writer.writeUint8Array(localHeaderArray);\n\t\tfileEntry.dataWritten = true;\n\t}\n\tlet dataDescriptorArray = new Uint8Array(0);\n\tlet dataDescriptorView;\n\tif (dataDescriptor) {\n\t\tdataDescriptorArray = new Uint8Array(zip64 ? 24 : 16);\n\t\tdataDescriptorView = getDataView(dataDescriptorArray);\n\t\tsetUint32(dataDescriptorView, 0, DATA_DESCRIPTOR_RECORD_SIGNATURE);\n\t}\n\tif (reader) {\n\t\tconst signature = result.signature;\n\t\tif ((!encrypted || zipCrypto) && signature !== undefined) {\n\t\t\tsetUint32(headerView, 10, signature);\n\t\t\tfileEntry.signature = signature;\n\t\t\tif (dataDescriptor) {\n\t\t\t\tsetUint32(dataDescriptorView, 4, signature);\n\t\t\t}\n\t\t}\n\t\tif (zip64) {\n\t\t\tconst rawExtraFieldZip64View = getDataView(fileEntry.rawExtraFieldZip64);\n\t\t\tsetUint16(rawExtraFieldZip64View, 0, EXTRAFIELD_TYPE_ZIP64);\n\t\t\tsetUint16(rawExtraFieldZip64View, 2, EXTRAFIELD_LENGTH_ZIP64);\n\t\t\tsetUint32(headerView, 14, MAX_32_BITS);\n\t\t\tsetBigUint64(rawExtraFieldZip64View, 12, BigInt(compressedSize));\n\t\t\tsetUint32(headerView, 18, MAX_32_BITS);\n\t\t\tsetBigUint64(rawExtraFieldZip64View, 4, BigInt(uncompressedSize));\n\t\t\tif (dataDescriptor) {\n\t\t\t\tsetBigUint64(dataDescriptorView, 8, BigInt(compressedSize));\n\t\t\t\tsetBigUint64(dataDescriptorView, 16, BigInt(uncompressedSize));\n\t\t\t}\n\t\t} else {\n\t\t\tsetUint32(headerView, 14, compressedSize);\n\t\t\tsetUint32(headerView, 18, uncompressedSize);\n\t\t\tif (dataDescriptor) {\n\t\t\t\tsetUint32(dataDescriptorView, 8, compressedSize);\n\t\t\t\tsetUint32(dataDescriptorView, 12, uncompressedSize);\n\t\t\t}\n\t\t}\n\t}\n\tif (dataDescriptor) {\n\t\tawait writer.writeUint8Array(dataDescriptorArray);\n\t}\n\tconst length = localHeaderArray.length + compressedSize + dataDescriptorArray.length;\n\tObject.assign(fileEntry, { compressedSize, lastModDate, rawLastModDate, creationDate, lastAccessDate, encrypted, length });\n\treturn fileEntry;\n}\n\nasync function closeFile(zipWriter, comment, options) {\n\tconst writer = zipWriter.writer;\n\tconst files = zipWriter.files;\n\tlet offset = 0;\n\tlet directoryDataLength = 0;\n\tlet directoryOffset = zipWriter.offset;\n\tlet filesLength = files.size;\n\tfor (const [, fileEntry] of files) {\n\t\tdirectoryDataLength += 46 +\n\t\t\tfileEntry.rawFilename.length +\n\t\t\tfileEntry.rawComment.length +\n\t\t\tfileEntry.rawExtraFieldZip64.length +\n\t\t\tfileEntry.rawExtraFieldAES.length +\n\t\t\tfileEntry.rawExtraFieldExtendedTimestamp.length +\n\t\t\tfileEntry.rawExtraFieldNTFS.length +\n\t\t\tfileEntry.rawExtraField.length;\n\t}\n\tlet zip64 = options.zip64 || zipWriter.options.zip64 || false;\n\tif (directoryOffset >= MAX_32_BITS || directoryDataLength >= MAX_32_BITS || filesLength >= MAX_16_BITS) {\n\t\tif (options.zip64 === false || zipWriter.options.zip64 === false) {\n\t\t\tthrow new Error(ERR_UNSUPPORTED_FORMAT);\n\t\t} else {\n\t\t\tzip64 = true;\n\t\t}\n\t}\n\tconst directoryArray = new Uint8Array(directoryDataLength + (zip64 ? ZIP64_END_OF_CENTRAL_DIR_TOTAL_LENGTH : END_OF_CENTRAL_DIR_LENGTH));\n\tconst directoryView = getDataView(directoryArray);\n\tif (comment && comment.length) {\n\t\tif (comment.length <= MAX_16_BITS) {\n\t\t\tsetUint16(directoryView, offset + 20, comment.length);\n\t\t} else {\n\t\t\tthrow new Error(ERR_INVALID_COMMENT);\n\t\t}\n\t}\n\tfor (const [indexFileEntry, fileEntry] of Array.from(files.values()).entries()) {\n\t\tconst {\n\t\t\trawFilename,\n\t\t\trawExtraFieldZip64,\n\t\t\trawExtraFieldAES,\n\t\t\trawExtraField,\n\t\t\trawComment,\n\t\t\tversionMadeBy,\n\t\t\theaderArray,\n\t\t\tdirectory,\n\t\t\tzip64,\n\t\t\tmsDosCompatible,\n\t\t\tinternalFileAttribute,\n\t\t\texternalFileAttribute\n\t\t} = fileEntry;\n\t\tlet rawExtraFieldExtendedTimestamp;\n\t\tlet rawExtraFieldNTFS;\n\t\tif (fileEntry.extendedTimestamp) {\n\t\t\trawExtraFieldNTFS = fileEntry.rawExtraFieldNTFS;\n\t\t\trawExtraFieldExtendedTimestamp = new Uint8Array(9);\n\t\t\tconst extraFieldExtendedTimestampView = getDataView(rawExtraFieldExtendedTimestamp);\n\t\t\tsetUint16(extraFieldExtendedTimestampView, 0, EXTRAFIELD_TYPE_EXTENDED_TIMESTAMP);\n\t\t\tsetUint16(extraFieldExtendedTimestampView, 2, rawExtraFieldExtendedTimestamp.length - 4);\n\t\t\tsetUint8(extraFieldExtendedTimestampView, 4, 0x1);\n\t\t\tsetUint32(extraFieldExtendedTimestampView, 5, Math.floor(fileEntry.lastModDate.getTime() / 1000));\n\t\t} else {\n\t\t\trawExtraFieldNTFS = rawExtraFieldExtendedTimestamp = new Uint8Array(0);\n\t\t}\n\t\tconst extraFieldLength = rawExtraFieldZip64.length + rawExtraFieldAES.length + rawExtraFieldExtendedTimestamp.length + rawExtraFieldNTFS.length + rawExtraField.length;\n\t\tsetUint32(directoryView, offset, CENTRAL_FILE_HEADER_SIGNATURE);\n\t\tsetUint16(directoryView, offset + 4, versionMadeBy);\n\t\tarraySet(directoryArray, headerArray, offset + 6);\n\t\tsetUint16(directoryView, offset + 30, extraFieldLength);\n\t\tsetUint16(directoryView, offset + 32, rawComment.length);\n\t\tsetUint32(directoryView, offset + 34, internalFileAttribute);\n\t\tif (externalFileAttribute) {\n\t\t\tsetUint32(directoryView, offset + 38, externalFileAttribute);\n\t\t} else if (directory && msDosCompatible) {\n\t\t\tsetUint8(directoryView, offset + 38, FILE_ATTR_MSDOS_DIR_MASK);\n\t\t}\n\t\tif (zip64) {\n\t\t\tsetUint32(directoryView, offset + 42, MAX_32_BITS);\n\t\t} else {\n\t\t\tsetUint32(directoryView, offset + 42, fileEntry.offset);\n\t\t}\n\t\tarraySet(directoryArray, rawFilename, offset + 46);\n\t\tarraySet(directoryArray, rawExtraFieldZip64, offset + 46 + rawFilename.length);\n\t\tarraySet(directoryArray, rawExtraFieldAES, offset + 46 + rawFilename.length + rawExtraFieldZip64.length);\n\t\tarraySet(directoryArray, rawExtraFieldExtendedTimestamp, offset + 46 + rawFilename.length + rawExtraFieldZip64.length + rawExtraFieldAES.length);\n\t\tarraySet(directoryArray, rawExtraFieldNTFS, offset + 46 + rawFilename.length + rawExtraFieldZip64.length + rawExtraFieldAES.length + rawExtraFieldExtendedTimestamp.length);\n\t\tarraySet(directoryArray, rawExtraField, offset + 46 + rawFilename.length + rawExtraFieldZip64.length + rawExtraFieldAES.length + rawExtraFieldExtendedTimestamp.length + rawExtraFieldNTFS.length);\n\t\tarraySet(directoryArray, rawComment, offset + 46 + rawFilename.length + extraFieldLength);\n\t\toffset += 46 + rawFilename.length + extraFieldLength + rawComment.length;\n\t\tif (options.onprogress) {\n\t\t\ttry {\n\t\t\t\toptions.onprogress(indexFileEntry + 1, files.size, new Entry(fileEntry));\n\t\t\t} catch (error) {\n\t\t\t\t// ignored\n\t\t\t}\n\t\t}\n\t}\n\tif (zip64) {\n\t\tsetUint32(directoryView, offset, ZIP64_END_OF_CENTRAL_DIR_SIGNATURE);\n\t\tsetBigUint64(directoryView, offset + 4, BigInt(44));\n\t\tsetUint16(directoryView, offset + 12, 45);\n\t\tsetUint16(directoryView, offset + 14, 45);\n\t\tsetBigUint64(directoryView, offset + 24, BigInt(filesLength));\n\t\tsetBigUint64(directoryView, offset + 32, BigInt(filesLength));\n\t\tsetBigUint64(directoryView, offset + 40, BigInt(directoryDataLength));\n\t\tsetBigUint64(directoryView, offset + 48, BigInt(directoryOffset));\n\t\tsetUint32(directoryView, offset + 56, ZIP64_END_OF_CENTRAL_DIR_LOCATOR_SIGNATURE);\n\t\tsetBigUint64(directoryView, offset + 64, BigInt(directoryOffset) + BigInt(directoryDataLength));\n\t\tsetUint32(directoryView, offset + 72, ZIP64_TOTAL_NUMBER_OF_DISKS);\n\t\tfilesLength = MAX_16_BITS;\n\t\tdirectoryOffset = MAX_32_BITS;\n\t\tdirectoryDataLength = MAX_32_BITS;\n\t\toffset += 76;\n\t}\n\tsetUint32(directoryView, offset, END_OF_CENTRAL_DIR_SIGNATURE);\n\tsetUint16(directoryView, offset + 8, filesLength);\n\tsetUint16(directoryView, offset + 10, filesLength);\n\tsetUint32(directoryView, offset + 12, directoryDataLength);\n\tsetUint32(directoryView, offset + 16, directoryOffset);\n\tawait writer.writeUint8Array(directoryArray);\n\tif (comment && comment.length) {\n\t\tawait writer.writeUint8Array(comment);\n\t}\n}\n\nfunction sliceAsArrayBuffer(blob, start, end) {\n\tconst fileReader = new FileReader();\n\treturn new Promise((resolve, reject) => {\n\t\tfileReader.onload = event => resolve(event.target.result);\n\t\tfileReader.onerror = () => reject(fileReader.error);\n\t\tfileReader.readAsArrayBuffer(start || end ? blob.slice(start, end) : blob);\n\t});\n}\n\nasync function writeBlob(writer, blob, start = 0) {\n\tconst blockSize = 512 * 1024 * 1024;\n\tawait writeSlice();\n\n\tasync function writeSlice() {\n\t\tif (start < blob.size) {\n\t\t\tconst arrayBuffer = await sliceAsArrayBuffer(blob, start, start + blockSize);\n\t\t\tawait writer.writeUint8Array(new Uint8Array(arrayBuffer));\n\t\t\tstart += blockSize;\n\t\t\tawait writeSlice();\n\t\t}\n\t}\n}\n\nfunction getTimeNTFS(date) {\n\tif (date) {\n\t\treturn ((BigInt(date.getTime()) + BigInt(11644473600000)) * BigInt(10000));\n\t}\n}\n\nfunction getOptionValue(zipWriter, options, name) {\n\treturn options[name] === undefined ? zipWriter.options[name] : options[name];\n}\n\nfunction getMaximumCompressedSize(uncompressedSize) {\n\treturn uncompressedSize + (5 * (Math.floor(uncompressedSize / 16383) + 1));\n}\n\nfunction setUint8(view, offset, value) {\n\tview.setUint8(offset, value);\n}\n\nfunction setUint16(view, offset, value) {\n\tview.setUint16(offset, value, true);\n}\n\nfunction setUint32(view, offset, value) {\n\tview.setUint32(offset, value, true);\n}\n\nfunction setBigUint64(view, offset, value) {\n\tview.setBigUint64(offset, value, true);\n}\n\nfunction arraySet(array, typedArray, offset) {\n\tarray.set(typedArray, offset);\n}\n\nfunction getDataView(array) {\n\treturn new DataView(array.buffer);\n}\n\n/*\n Copyright (c) 2021 Gildas Lormeau. All rights reserved.\n\n Redistribution and use in source and binary forms, with or without\n modification, are permitted provided that the following conditions are met:\n\n 1. Redistributions of source code must retain the above copyright notice,\n this list of conditions and the following disclaimer.\n\n 2. Redistributions in binary form must reproduce the above copyright \n notice, this list of conditions and the following disclaimer in \n the documentation and/or other materials provided with the distribution.\n\n 3. The names of the authors may not be used to endorse or promote products\n derived from this software without specific prior written permission.\n\n THIS SOFTWARE IS PROVIDED \'\'AS IS\'\' AND ANY EXPRESSED OR IMPLIED WARRANTIES,\n INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\n FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL JCRAFT,\n INC. OR ANY CONTRIBUTORS TO THIS SOFTWARE BE LIABLE FOR ANY DIRECT, INDIRECT,\n INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,\n OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF\n LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING\n NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,\n EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\nconfigureWebWorker();\n\nvar zip = /*#__PURE__*/Object.freeze({\n\t__proto__: null,\n\tgetMimeType: getMimeType,\n\tinitShimAsyncCodec: streamCodecShim,\n\tterminateWorkers: terminateWorkers,\n\tERR_ABORT: ERR_ABORT,\n\tconfigure: configure,\n\tReader: Reader,\n\tWriter: Writer,\n\tTextReader: TextReader,\n\tTextWriter: TextWriter,\n\tData64URIReader: Data64URIReader,\n\tData64URIWriter: Data64URIWriter,\n\tBlobReader: BlobReader,\n\tBlobWriter: BlobWriter,\n\tUint8ArrayReader: Uint8ArrayReader,\n\tUint8ArrayWriter: Uint8ArrayWriter,\n\tHttpReader: HttpReader,\n\tHttpRangeReader: HttpRangeReader,\n\tERR_HTTP_RANGE: ERR_HTTP_RANGE,\n\tZipReader: ZipReader,\n\tERR_BAD_FORMAT: ERR_BAD_FORMAT,\n\tERR_EOCDR_NOT_FOUND: ERR_EOCDR_NOT_FOUND,\n\tERR_EOCDR_ZIP64_NOT_FOUND: ERR_EOCDR_ZIP64_NOT_FOUND,\n\tERR_EOCDR_LOCATOR_ZIP64_NOT_FOUND: ERR_EOCDR_LOCATOR_ZIP64_NOT_FOUND,\n\tERR_CENTRAL_DIRECTORY_NOT_FOUND: ERR_CENTRAL_DIRECTORY_NOT_FOUND,\n\tERR_LOCAL_FILE_HEADER_NOT_FOUND: ERR_LOCAL_FILE_HEADER_NOT_FOUND,\n\tERR_EXTRAFIELD_ZIP64_NOT_FOUND: ERR_EXTRAFIELD_ZIP64_NOT_FOUND,\n\tERR_ENCRYPTED: ERR_ENCRYPTED,\n\tERR_UNSUPPORTED_ENCRYPTION: ERR_UNSUPPORTED_ENCRYPTION,\n\tERR_UNSUPPORTED_COMPRESSION: ERR_UNSUPPORTED_COMPRESSION,\n\tERR_INVALID_SIGNATURE: ERR_INVALID_SIGNATURE,\n\tERR_INVALID_PASSWORD: ERR_INVALID_PASSWORD,\n\tZipWriter: ZipWriter,\n\tERR_DUPLICATED_NAME: ERR_DUPLICATED_NAME,\n\tERR_INVALID_COMMENT: ERR_INVALID_COMMENT,\n\tERR_INVALID_ENTRY_NAME: ERR_INVALID_ENTRY_NAME,\n\tERR_INVALID_ENTRY_COMMENT: ERR_INVALID_ENTRY_COMMENT,\n\tERR_INVALID_VERSION: ERR_INVALID_VERSION,\n\tERR_INVALID_EXTRAFIELD_TYPE: ERR_INVALID_EXTRAFIELD_TYPE,\n\tERR_INVALID_EXTRAFIELD_DATA: ERR_INVALID_EXTRAFIELD_DATA,\n\tERR_INVALID_ENCRYPTION_STRENGTH: ERR_INVALID_ENCRYPTION_STRENGTH,\n\tERR_UNSUPPORTED_FORMAT: ERR_UNSUPPORTED_FORMAT\n});\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QUFDQSxvRUFBb0UsTUFBTTtBQUMxRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBEQUEwRDtBQUMxRCxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxxQkFBcUIsc0JBQXNCO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHFCQUFxQixzQkFBc0I7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQix5QkFBeUI7QUFDOUM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMERBQTBEO0FBQzFELGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUUsSUFBSSxXQUFXO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRCxXQUFXO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUUsSUFBSSxXQUFXO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWlELDhCQUE4QjtBQUMvRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwREFBMEQ7QUFDMUQsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpRUFBaUUsaUhBQWU7QUFDaEYsSUFBSTtBQUNKLGlFQUFpRSxpSEFBZSxLQUFLLGdCQUFnQjtBQUNyRztBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyw0QkFBNEI7QUFDNUQsSUFBSTtBQUNKO0FBQ0EsZ0NBQWdDLHFCQUFxQjtBQUNyRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixnREFBZ0QsK0JBQStCO0FBQ3RHO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esa0VBQWtFLGlCQUFpQjtBQUNuRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsMkJBQTJCLDBEQUEwRDtBQUNyRjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMERBQTBEO0FBQzFELGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0osd0RBQXdELHdEQUF3RDtBQUNoSDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxZQUFZLHdEQUF3RDtBQUNwRTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMERBQTBEO0FBQzFELGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwREFBMEQ7QUFDMUQsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLHNEQUFzRCwrQkFBK0I7QUFDckY7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsK0JBQStCO0FBQzVEOztBQUVBO0FBQ0E7QUFDQSxvREFBb0QsK0JBQStCO0FBQ25GOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsNEJBQTRCO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLGdEQUFnRDtBQUNoRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixtRUFBbUU7QUFDMUY7QUFDQTtBQUNBLFNBQVMsMkJBQTJCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLG1CQUFtQjtBQUNoRDs7QUFFQTtBQUNBO0FBQ0Esb0RBQW9ELHdCQUF3QjtBQUM1RTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxvR0FBb0c7QUFDcEcsTUFBTSwwRUFBMEU7QUFDaEY7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwyQkFBMkI7QUFDM0IsbURBQW1ELGFBQWEsaUJBQWlCO0FBQ2pGO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsSUFBSTtBQUNKLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7OztBQUdBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBEQUEwRDtBQUMxRCxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwREFBMEQ7QUFDMUQsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDZFQUE2RSxpRUFBaUUsRUFBRTs7QUFFaEo7QUFDQTtBQUNBLDhCQUE4QixxQ0FBcUM7QUFDbkU7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBEQUEwRDtBQUMxRCxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVB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QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxvREFBb0QsZ0JBQWdCO0FBQ3BFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwREFBMEQ7QUFDMUQsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLGlDQUFpQztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBLDBDQUEwQztBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0osMkVBQTJFLHdDQUF3QztBQUNuSDtBQUNBOztBQUVBLHNEQUFzRDtBQUN0RDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrRUFBK0U7QUFDL0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLDJCQUEyQjtBQUN2RDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLG1GQUFtRixvQkFBb0I7QUFDdkc7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLDhGQUE4RjtBQUMxSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBEQUEwRDtBQUMxRCxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUV5QiIsInNvdXJjZXMiOlsid2VicGFjazovL3Z1ZTMtd2VicGFjazUvLi9ub2RlX21vZHVsZXMvY2VzaXVtL1NvdXJjZS9UaGlyZFBhcnR5L3ppcC5qcz9mMTdkIl0sInNvdXJjZXNDb250ZW50IjpbIi8qIFRoaXMgZmlsZSBpcyBhdXRvbWF0aWNhbGx5IHJlYnVpbHQgYnkgdGhlIENlc2l1bSBidWlsZCBwcm9jZXNzLiAqL1xuLypcbiBDb3B5cmlnaHQgKGMpIDIwMjEgR2lsZGFzIExvcm1lYXUuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG5cbiBSZWRpc3RyaWJ1dGlvbiBhbmQgdXNlIGluIHNvdXJjZSBhbmQgYmluYXJ5IGZvcm1zLCB3aXRoIG9yIHdpdGhvdXRcbiBtb2RpZmljYXRpb24sIGFyZSBwZXJtaXR0ZWQgcHJvdmlkZWQgdGhhdCB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnMgYXJlIG1ldDpcblxuIDEuIFJlZGlzdHJpYnV0aW9ucyBvZiBzb3VyY2UgY29kZSBtdXN0IHJldGFpbiB0aGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSxcbiB0aGlzIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZyBkaXNjbGFpbWVyLlxuXG4gMi4gUmVkaXN0cmlidXRpb25zIGluIGJpbmFyeSBmb3JtIG11c3QgcmVwcm9kdWNlIHRoZSBhYm92ZSBjb3B5cmlnaHQgXG4gbm90aWNlLCB0aGlzIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZyBkaXNjbGFpbWVyIGluIFxuIHRoZSBkb2N1bWVudGF0aW9uIGFuZC9vciBvdGhlciBtYXRlcmlhbHMgcHJvdmlkZWQgd2l0aCB0aGUgZGlzdHJpYnV0aW9uLlxuXG4gMy4gVGhlIG5hbWVzIG9mIHRoZSBhdXRob3JzIG1heSBub3QgYmUgdXNlZCB0byBlbmRvcnNlIG9yIHByb21vdGUgcHJvZHVjdHNcbiBkZXJpdmVkIGZyb20gdGhpcyBzb2Z0d2FyZSB3aXRob3V0IHNwZWNpZmljIHByaW9yIHdyaXR0ZW4gcGVybWlzc2lvbi5cblxuIFRISVMgU09GVFdBUkUgSVMgUFJPVklERUQgJydBUyBJUycnIEFORCBBTlkgRVhQUkVTU0VEIE9SIElNUExJRUQgV0FSUkFOVElFUyxcbiBJTkNMVURJTkcsIEJVVCBOT1QgTElNSVRFRCBUTywgVEhFIElNUExJRUQgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFkgQU5EXG4gRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQVJFIERJU0NMQUlNRUQuIElOIE5PIEVWRU5UIFNIQUxMIEpDUkFGVCxcbiBJTkMuIE9SIEFOWSBDT05UUklCVVRPUlMgVE8gVEhJUyBTT0ZUV0FSRSBCRSBMSUFCTEUgRk9SIEFOWSBESVJFQ1QsIElORElSRUNULFxuIElOQ0lERU5UQUwsIFNQRUNJQUwsIEVYRU1QTEFSWSwgT1IgQ09OU0VRVUVOVElBTCBEQU1BR0VTIChJTkNMVURJTkcsIEJVVCBOT1RcbiBMSU1JVEVEIFRPLCBQUk9DVVJFTUVOVCBPRiBTVUJTVElUVVRFIEdPT0RTIE9SIFNFUlZJQ0VTOyBMT1NTIE9GIFVTRSwgREFUQSxcbiBPUiBQUk9GSVRTOyBPUiBCVVNJTkVTUyBJTlRFUlJVUFRJT04pIEhPV0VWRVIgQ0FVU0VEIEFORCBPTiBBTlkgVEhFT1JZIE9GXG4gTElBQklMSVRZLCBXSEVUSEVSIElOIENPTlRSQUNULCBTVFJJQ1QgTElBQklMSVRZLCBPUiBUT1JUIChJTkNMVURJTkdcbiBORUdMSUdFTkNFIE9SIE9USEVSV0lTRSkgQVJJU0lORyBJTiBBTlkgV0FZIE9VVCBPRiBUSEUgVVNFIE9GIFRISVMgU09GVFdBUkUsXG4gRVZFTiBJRiBBRFZJU0VEIE9GIFRIRSBQT1NTSUJJTElUWSBPRiBTVUNIIERBTUFHRS5cbiAqL1xuXG5jb25zdCBERUZBVUxUX0NPTkZJR1VSQVRJT04gPSB7XG5cdGNodW5rU2l6ZTogNTEyICogMTAyNCxcblx0bWF4V29ya2VyczogKHR5cGVvZiBuYXZpZ2F0b3IgIT0gXCJ1bmRlZmluZWRcIiAmJiBuYXZpZ2F0b3IuaGFyZHdhcmVDb25jdXJyZW5jeSkgfHwgMixcblx0dGVybWluYXRlV29ya2VyVGltZW91dDogNTAwMCxcblx0dXNlV2ViV29ya2VyczogdHJ1ZSxcblx0d29ya2VyU2NyaXB0czogdW5kZWZpbmVkXG59O1xuXG5jb25zdCBjb25maWcgPSBPYmplY3QuYXNzaWduKHt9LCBERUZBVUxUX0NPTkZJR1VSQVRJT04pO1xuXG5mdW5jdGlvbiBnZXRDb25maWd1cmF0aW9uKCkge1xuXHRyZXR1cm4gY29uZmlnO1xufVxuXG5mdW5jdGlvbiBjb25maWd1cmUoY29uZmlndXJhdGlvbikge1xuXHRpZiAoY29uZmlndXJhdGlvbi5jaHVua1NpemUgIT09IHVuZGVmaW5lZCkge1xuXHRcdGNvbmZpZy5jaHVua1NpemUgPSBjb25maWd1cmF0aW9uLmNodW5rU2l6ZTtcblx0fVxuXHRpZiAoY29uZmlndXJhdGlvbi5tYXhXb3JrZXJzICE9PSB1bmRlZmluZWQpIHtcblx0XHRjb25maWcubWF4V29ya2VycyA9IGNvbmZpZ3VyYXRpb24ubWF4V29ya2Vycztcblx0fVxuXHRpZiAoY29uZmlndXJhdGlvbi50ZXJtaW5hdGVXb3JrZXJUaW1lb3V0ICE9PSB1bmRlZmluZWQpIHtcblx0XHRjb25maWcudGVybWluYXRlV29ya2VyVGltZW91dCA9IGNvbmZpZ3VyYXRpb24udGVybWluYXRlV29ya2VyVGltZW91dDtcblx0fVxuXHRpZiAoY29uZmlndXJhdGlvbi51c2VXZWJXb3JrZXJzICE9PSB1bmRlZmluZWQpIHtcblx0XHRjb25maWcudXNlV2ViV29ya2VycyA9IGNvbmZpZ3VyYXRpb24udXNlV2ViV29ya2Vycztcblx0fVxuXHRpZiAoY29uZmlndXJhdGlvbi5EZWZsYXRlICE9PSB1bmRlZmluZWQpIHtcblx0XHRjb25maWcuRGVmbGF0ZSA9IGNvbmZpZ3VyYXRpb24uRGVmbGF0ZTtcblx0fVxuXHRpZiAoY29uZmlndXJhdGlvbi5JbmZsYXRlICE9PSB1bmRlZmluZWQpIHtcblx0XHRjb25maWcuSW5mbGF0ZSA9IGNvbmZpZ3VyYXRpb24uSW5mbGF0ZTtcblx0fVxuXHRpZiAoY29uZmlndXJhdGlvbi53b3JrZXJTY3JpcHRzICE9PSB1bmRlZmluZWQpIHtcblx0XHRpZiAoY29uZmlndXJhdGlvbi53b3JrZXJTY3JpcHRzLmRlZmxhdGUpIHtcblx0XHRcdGlmICghQXJyYXkuaXNBcnJheShjb25maWd1cmF0aW9uLndvcmtlclNjcmlwdHMuZGVmbGF0ZSkpIHtcblx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKFwid29ya2VyU2NyaXB0cy5kZWZsYXRlIG11c3QgYmUgYW4gYXJyYXlcIik7XG5cdFx0XHR9XG5cdFx0XHRpZiAoIWNvbmZpZy53b3JrZXJTY3JpcHRzKSB7XG5cdFx0XHRcdGNvbmZpZy53b3JrZXJTY3JpcHRzID0ge307XG5cdFx0XHR9XG5cdFx0XHRjb25maWcud29ya2VyU2NyaXB0cy5kZWZsYXRlID0gY29uZmlndXJhdGlvbi53b3JrZXJTY3JpcHRzLmRlZmxhdGU7XG5cdFx0fVxuXHRcdGlmIChjb25maWd1cmF0aW9uLndvcmtlclNjcmlwdHMuaW5mbGF0ZSkge1xuXHRcdFx0aWYgKCFBcnJheS5pc0FycmF5KGNvbmZpZ3VyYXRpb24ud29ya2VyU2NyaXB0cy5pbmZsYXRlKSkge1xuXHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoXCJ3b3JrZXJTY3JpcHRzLmluZmxhdGUgbXVzdCBiZSBhbiBhcnJheVwiKTtcblx0XHRcdH1cblx0XHRcdGlmICghY29uZmlnLndvcmtlclNjcmlwdHMpIHtcblx0XHRcdFx0Y29uZmlnLndvcmtlclNjcmlwdHMgPSB7fTtcblx0XHRcdH1cblx0XHRcdGNvbmZpZy53b3JrZXJTY3JpcHRzLmluZmxhdGUgPSBjb25maWd1cmF0aW9uLndvcmtlclNjcmlwdHMuaW5mbGF0ZTtcblx0XHR9XG5cdH1cbn1cblxudmFyIGNvbmZpZ3VyZVdlYldvcmtlciA9ICgpPT57aWYoXCJmdW5jdGlvblwiPT10eXBlb2YgVVJMLmNyZWF0ZU9iamVjdFVSTCl7Y29uc3QgZT0oKCk9Pntjb25zdCB0PVtdO2ZvcihsZXQgZT0wO2U8MjU2O2UrKyl7bGV0IG49ZTtmb3IobGV0IHQ9MDt0PDg7dCsrKTEmbj9uPW4+Pj4xXjM5ODgyOTIzODQ6bj4+Pj0xO3RbZV09bjt9Y2xhc3MgZXtjb25zdHJ1Y3Rvcih0KXt0aGlzLmNyYz10fHwtMTt9YXBwZW5kKGUpe2xldCBuPTB8dGhpcy5jcmM7Zm9yKGxldCBpPTAsYT0wfGUubGVuZ3RoO2k8YTtpKyspbj1uPj4+OF50WzI1NSYobl5lW2ldKV07dGhpcy5jcmM9bjt9Z2V0KCl7cmV0dXJuIH50aGlzLmNyY319Y29uc3Qgbj17Y29uY2F0KHQsZSl7aWYoMD09PXQubGVuZ3RofHwwPT09ZS5sZW5ndGgpcmV0dXJuIHQuY29uY2F0KGUpO2NvbnN0IGk9dFt0Lmxlbmd0aC0xXSxhPW4uZ2V0UGFydGlhbChpKTtyZXR1cm4gMzI9PT1hP3QuY29uY2F0KGUpOm4uX3NoaWZ0UmlnaHQoZSxhLDB8aSx0LnNsaWNlKDAsdC5sZW5ndGgtMSkpfSxiaXRMZW5ndGgodCl7Y29uc3QgZT10Lmxlbmd0aDtpZigwPT09ZSlyZXR1cm4gMDtjb25zdCBpPXRbZS0xXTtyZXR1cm4gMzIqKGUtMSkrbi5nZXRQYXJ0aWFsKGkpfSxjbGFtcCh0LGUpe2lmKDMyKnQubGVuZ3RoPGUpcmV0dXJuIHQ7Y29uc3QgaT0odD10LnNsaWNlKDAsTWF0aC5jZWlsKGUvMzIpKSkubGVuZ3RoO3JldHVybiBlJj0zMSxpPjAmJmUmJih0W2ktMV09bi5wYXJ0aWFsKGUsdFtpLTFdJjIxNDc0ODM2NDg+PmUtMSwxKSksdH0scGFydGlhbDoodCxlLG4pPT4zMj09PXQ/ZToobj8wfGU6ZTw8MzItdCkrMTA5OTUxMTYyNzc3Nip0LGdldFBhcnRpYWw6dD0+TWF0aC5yb3VuZCh0LzEwOTk1MTE2Mjc3NzYpfHwzMixfc2hpZnRSaWdodCh0LGUsaSxhKXtmb3Iodm9pZCAwPT09YSYmKGE9W10pO2U+PTMyO2UtPTMyKWEucHVzaChpKSxpPTA7aWYoMD09PWUpcmV0dXJuIGEuY29uY2F0KHQpO2ZvcihsZXQgbj0wO248dC5sZW5ndGg7bisrKWEucHVzaChpfHRbbl0+Pj5lKSxpPXRbbl08PDMyLWU7Y29uc3Qgcj10Lmxlbmd0aD90W3QubGVuZ3RoLTFdOjAscz1uLmdldFBhcnRpYWwocik7cmV0dXJuIGEucHVzaChuLnBhcnRpYWwoZStzJjMxLGUrcz4zMj9pOmEucG9wKCksMSkpLGF9fSxpPXtieXRlczp7ZnJvbUJpdHModCl7Y29uc3QgZT1uLmJpdExlbmd0aCh0KS84LGk9bmV3IFVpbnQ4QXJyYXkoZSk7bGV0IGE7Zm9yKGxldCBuPTA7bjxlO24rKykwPT0oMyZuKSYmKGE9dFtuLzRdKSxpW25dPWE+Pj4yNCxhPDw9ODtyZXR1cm4gaX0sdG9CaXRzKHQpe2NvbnN0IGU9W107bGV0IGksYT0wO2ZvcihpPTA7aTx0Lmxlbmd0aDtpKyspYT1hPDw4fHRbaV0sMz09KDMmaSkmJihlLnB1c2goYSksYT0wKTtyZXR1cm4gMyZpJiZlLnB1c2gobi5wYXJ0aWFsKDgqKDMmaSksYSkpLGV9fX0sYT17c2hhMTpmdW5jdGlvbih0KXt0Pyh0aGlzLl9oPXQuX2guc2xpY2UoMCksdGhpcy5fYnVmZmVyPXQuX2J1ZmZlci5zbGljZSgwKSx0aGlzLl9sZW5ndGg9dC5fbGVuZ3RoKTp0aGlzLnJlc2V0KCk7fX07YS5zaGExLnByb3RvdHlwZT17YmxvY2tTaXplOjUxMixyZXNldDpmdW5jdGlvbigpe2NvbnN0IHQ9dGhpcztyZXR1cm4gdC5faD10aGlzLl9pbml0LnNsaWNlKDApLHQuX2J1ZmZlcj1bXSx0Ll9sZW5ndGg9MCx0fSx1cGRhdGU6ZnVuY3Rpb24odCl7Y29uc3QgZT10aGlzO1wic3RyaW5nXCI9PXR5cGVvZiB0JiYodD1pLnV0ZjhTdHJpbmcudG9CaXRzKHQpKTtjb25zdCBhPWUuX2J1ZmZlcj1uLmNvbmNhdChlLl9idWZmZXIsdCkscj1lLl9sZW5ndGgscz1lLl9sZW5ndGg9cituLmJpdExlbmd0aCh0KTtpZihzPjkwMDcxOTkyNTQ3NDA5OTEpdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IGhhc2ggbW9yZSB0aGFuIDJeNTMgLSAxIGJpdHNcIik7Y29uc3Qgbz1uZXcgVWludDMyQXJyYXkoYSk7bGV0IGw9MDtmb3IobGV0IHQ9ZS5ibG9ja1NpemUrci0oZS5ibG9ja1NpemUrciZlLmJsb2NrU2l6ZS0xKTt0PD1zO3QrPWUuYmxvY2tTaXplKWUuX2Jsb2NrKG8uc3ViYXJyYXkoMTYqbCwxNioobCsxKSkpLGwrPTE7cmV0dXJuIGEuc3BsaWNlKDAsMTYqbCksZX0sZmluYWxpemU6ZnVuY3Rpb24oKXtjb25zdCB0PXRoaXM7bGV0IGU9dC5fYnVmZmVyO2NvbnN0IGk9dC5faDtlPW4uY29uY2F0KGUsW24ucGFydGlhbCgxLDEpXSk7Zm9yKGxldCB0PWUubGVuZ3RoKzI7MTUmdDt0KyspZS5wdXNoKDApO2ZvcihlLnB1c2goTWF0aC5mbG9vcih0Ll9sZW5ndGgvNDI5NDk2NzI5NikpLGUucHVzaCgwfHQuX2xlbmd0aCk7ZS5sZW5ndGg7KXQuX2Jsb2NrKGUuc3BsaWNlKDAsMTYpKTtyZXR1cm4gdC5yZXNldCgpLGl9LF9pbml0OlsxNzMyNTg0MTkzLDQwMjMyMzM0MTcsMjU2MjM4MzEwMiwyNzE3MzM4NzgsMzI4NTM3NzUyMF0sX2tleTpbMTUxODUwMDI0OSwxODU5Nzc1MzkzLDI0MDA5NTk3MDgsMzM5NTQ2OTc4Ml0sX2Y6ZnVuY3Rpb24odCxlLG4saSl7cmV0dXJuIHQ8PTE5P2Umbnx+ZSZpOnQ8PTM5P2Vebl5pOnQ8PTU5P2UmbnxlJml8biZpOnQ8PTc5P2Vebl5pOnZvaWQgMH0sX1M6ZnVuY3Rpb24odCxlKXtyZXR1cm4gZTw8dHxlPj4+MzItdH0sX2Jsb2NrOmZ1bmN0aW9uKHQpe2NvbnN0IGU9dGhpcyxuPWUuX2gsaT1BcnJheSg4MCk7Zm9yKGxldCBlPTA7ZTwxNjtlKyspaVtlXT10W2VdO2xldCBhPW5bMF0scj1uWzFdLHM9blsyXSxvPW5bM10sbD1uWzRdO2ZvcihsZXQgdD0wO3Q8PTc5O3QrKyl7dD49MTYmJihpW3RdPWUuX1MoMSxpW3QtM11eaVt0LThdXmlbdC0xNF1eaVt0LTE2XSkpO2NvbnN0IG49ZS5fUyg1LGEpK2UuX2YodCxyLHMsbykrbCtpW3RdK2UuX2tleVtNYXRoLmZsb29yKHQvMjApXXwwO2w9byxvPXMscz1lLl9TKDMwLHIpLHI9YSxhPW47fW5bMF09blswXSthfDAsblsxXT1uWzFdK3J8MCxuWzJdPW5bMl0rc3wwLG5bM109blszXStvfDAsbls0XT1uWzRdK2x8MDt9fTtjb25zdCByPWNsYXNze2NvbnN0cnVjdG9yKHQpe2NvbnN0IGU9dGhpcztlLl90YWJsZXM9W1tbXSxbXSxbXSxbXSxbXV0sW1tdLFtdLFtdLFtdLFtdXV0sZS5fdGFibGVzWzBdWzBdWzBdfHxlLl9wcmVjb21wdXRlKCk7Y29uc3Qgbj1lLl90YWJsZXNbMF1bNF0saT1lLl90YWJsZXNbMV0sYT10Lmxlbmd0aDtsZXQgcixzLG8sbD0xO2lmKDQhPT1hJiY2IT09YSYmOCE9PWEpdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBhZXMga2V5IHNpemVcIik7Zm9yKGUuX2tleT1bcz10LnNsaWNlKDApLG89W11dLHI9YTtyPDQqYSsyODtyKyspe2xldCB0PXNbci0xXTsociVhPT0wfHw4PT09YSYmciVhPT00KSYmKHQ9blt0Pj4+MjRdPDwyNF5uW3Q+PjE2JjI1NV08PDE2Xm5bdD4+OCYyNTVdPDw4Xm5bMjU1JnRdLHIlYT09MCYmKHQ9dDw8OF50Pj4+MjRebDw8MjQsbD1sPDwxXjI4MyoobD4+NykpKSxzW3JdPXNbci1hXV50O31mb3IobGV0IHQ9MDtyO3QrKyxyLS0pe2NvbnN0IGU9c1szJnQ/cjpyLTRdO29bdF09cjw9NHx8dDw0P2U6aVswXVtuW2U+Pj4yNF1dXmlbMV1bbltlPj4xNiYyNTVdXV5pWzJdW25bZT4+OCYyNTVdXV5pWzNdW25bMjU1JmVdXTt9fWVuY3J5cHQodCl7cmV0dXJuIHRoaXMuX2NyeXB0KHQsMCl9ZGVjcnlwdCh0KXtyZXR1cm4gdGhpcy5fY3J5cHQodCwxKX1fcHJlY29tcHV0ZSgpe2NvbnN0IHQ9dGhpcy5fdGFibGVzWzBdLGU9dGhpcy5fdGFibGVzWzFdLG49dFs0XSxpPWVbNF0sYT1bXSxyPVtdO2xldCBzLG8sbCxfO2ZvcihsZXQgdD0wO3Q8MjU2O3QrKylyWyhhW3RdPXQ8PDFeMjgzKih0Pj43KSledF09dDtmb3IobGV0IGQ9cz0wOyFuW2RdO2RePW98fDEscz1yW3NdfHwxKXtsZXQgcj1zXnM8PDFeczw8Ml5zPDwzXnM8PDQ7cj1yPj44XjI1NSZyXjk5LG5bZF09cixpW3JdPWQsXz1hW2w9YVtvPWFbZF1dXTtsZXQgYz0xNjg0MzAwOSpfXjY1NTM3KmxeMjU3Km9eMTY4NDMwMDgqZCxmPTI1NyphW3JdXjE2ODQzMDA4KnI7Zm9yKGxldCBuPTA7bjw0O24rKyl0W25dW2RdPWY9Zjw8MjReZj4+PjgsZVtuXVtyXT1jPWM8PDI0XmM+Pj44O31mb3IobGV0IG49MDtuPDU7bisrKXRbbl09dFtuXS5zbGljZSgwKSxlW25dPWVbbl0uc2xpY2UoMCk7fV9jcnlwdCh0LGUpe2lmKDQhPT10Lmxlbmd0aCl0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIGFlcyBibG9jayBzaXplXCIpO2NvbnN0IG49dGhpcy5fa2V5W2VdLGk9bi5sZW5ndGgvNC0yLGE9WzAsMCwwLDBdLHI9dGhpcy5fdGFibGVzW2VdLHM9clswXSxvPXJbMV0sbD1yWzJdLF89clszXSxkPXJbNF07bGV0IGMsZix1LGg9dFswXV5uWzBdLGI9dFtlPzM6MV1eblsxXSxwPXRbMl1eblsyXSx3PXRbZT8xOjNdXm5bM10seD00O2ZvcihsZXQgdD0wO3Q8aTt0KyspYz1zW2g+Pj4yNF1eb1tiPj4xNiYyNTVdXmxbcD4+OCYyNTVdXl9bMjU1JnddXm5beF0sZj1zW2I+Pj4yNF1eb1twPj4xNiYyNTVdXmxbdz4+OCYyNTVdXl9bMjU1JmhdXm5beCsxXSx1PXNbcD4+PjI0XV5vW3c+PjE2JjI1NV1ebFtoPj44JjI1NV1eX1syNTUmYl1eblt4KzJdLHc9c1t3Pj4+MjRdXm9baD4+MTYmMjU1XV5sW2I+PjgmMjU1XV5fWzI1NSZwXV5uW3grM10seCs9NCxoPWMsYj1mLHA9dTtmb3IobGV0IHQ9MDt0PDQ7dCsrKWFbZT8zJi10OnRdPWRbaD4+PjI0XTw8MjReZFtiPj4xNiYyNTVdPDwxNl5kW3A+PjgmMjU1XTw8OF5kWzI1NSZ3XV5uW3grK10sYz1oLGg9YixiPXAscD13LHc9YztyZXR1cm4gYX19LHM9Y2xhc3N7Y29uc3RydWN0b3IodCxlKXt0aGlzLl9wcmY9dCx0aGlzLl9pbml0SXY9ZSx0aGlzLl9pdj1lO31yZXNldCgpe3RoaXMuX2l2PXRoaXMuX2luaXRJdjt9dXBkYXRlKHQpe3JldHVybiB0aGlzLmNhbGN1bGF0ZSh0aGlzLl9wcmYsdCx0aGlzLl9pdil9aW5jV29yZCh0KXtpZigyNTU9PSh0Pj4yNCYyNTUpKXtsZXQgZT10Pj4xNiYyNTUsbj10Pj44JjI1NSxpPTI1NSZ0OzI1NT09PWU/KGU9MCwyNTU9PT1uPyhuPTAsMjU1PT09aT9pPTA6KytpKTorK24pOisrZSx0PTAsdCs9ZTw8MTYsdCs9bjw8OCx0Kz1pO31lbHNlIHQrPTE8PDI0O3JldHVybiB0fWluY0NvdW50ZXIodCl7MD09PSh0WzBdPXRoaXMuaW5jV29yZCh0WzBdKSkmJih0WzFdPXRoaXMuaW5jV29yZCh0WzFdKSk7fWNhbGN1bGF0ZSh0LGUsaSl7bGV0IGE7aWYoIShhPWUubGVuZ3RoKSlyZXR1cm4gW107Y29uc3Qgcj1uLmJpdExlbmd0aChlKTtmb3IobGV0IG49MDtuPGE7bis9NCl7dGhpcy5pbmNDb3VudGVyKGkpO2NvbnN0IGE9dC5lbmNyeXB0KGkpO2Vbbl1ePWFbMF0sZVtuKzFdXj1hWzFdLGVbbisyXV49YVsyXSxlW24rM11ePWFbM107fXJldHVybiBuLmNsYW1wKGUscil9fSxvPWNsYXNze2NvbnN0cnVjdG9yKHQpe2NvbnN0IGU9dGhpcyxuPWUuX2hhc2g9YS5zaGExLGk9W1tdLFtdXSxyPW4ucHJvdG90eXBlLmJsb2NrU2l6ZS8zMjtlLl9iYXNlSGFzaD1bbmV3IG4sbmV3IG5dLHQubGVuZ3RoPnImJih0PW4uaGFzaCh0KSk7Zm9yKGxldCBlPTA7ZTxyO2UrKylpWzBdW2VdPTkwOTUyMjQ4Nl50W2VdLGlbMV1bZV09MTU0OTU1NjgyOF50W2VdO2UuX2Jhc2VIYXNoWzBdLnVwZGF0ZShpWzBdKSxlLl9iYXNlSGFzaFsxXS51cGRhdGUoaVsxXSksZS5fcmVzdWx0SGFzaD1uZXcgbihlLl9iYXNlSGFzaFswXSk7fXJlc2V0KCl7Y29uc3QgdD10aGlzO3QuX3Jlc3VsdEhhc2g9bmV3IHQuX2hhc2godC5fYmFzZUhhc2hbMF0pLHQuX3VwZGF0ZWQ9ITE7fXVwZGF0ZSh0KXt0aGlzLl91cGRhdGVkPSEwLHRoaXMuX3Jlc3VsdEhhc2gudXBkYXRlKHQpO31kaWdlc3QoKXtjb25zdCB0PXRoaXMsZT10Ll9yZXN1bHRIYXNoLmZpbmFsaXplKCksbj1uZXcgdC5faGFzaCh0Ll9iYXNlSGFzaFsxXSkudXBkYXRlKGUpLmZpbmFsaXplKCk7cmV0dXJuIHQucmVzZXQoKSxufX0sbD17bmFtZTpcIlBCS0RGMlwifSxfPU9iamVjdC5hc3NpZ24oe2hhc2g6e25hbWU6XCJITUFDXCJ9fSxsKSxkPU9iamVjdC5hc3NpZ24oe2l0ZXJhdGlvbnM6MWUzLGhhc2g6e25hbWU6XCJTSEEtMVwifX0sbCksYz1bXCJkZXJpdmVCaXRzXCJdLGY9WzgsMTIsMTZdLHU9WzE2LDI0LDMyXSxoPVswLDAsMCwwXSxiPWkuYnl0ZXMscD1yLHc9cyx4PW87Y2xhc3MgZ3tjb25zdHJ1Y3Rvcih0LGUsbil7T2JqZWN0LmFzc2lnbih0aGlzLHtwYXNzd29yZDp0LHNpZ25lZDplLHN0cmVuZ3RoOm4tMSxwZW5kaW5nSW5wdXQ6bmV3IFVpbnQ4QXJyYXkoMCl9KTt9YXN5bmMgYXBwZW5kKHQpe2NvbnN0IGU9dGhpcztpZihlLnBhc3N3b3JkKXtjb25zdCBuPUEodCwwLGZbZS5zdHJlbmd0aF0rMik7YXdhaXQgYXN5bmMgZnVuY3Rpb24odCxlLG4pe2F3YWl0IGsodCxuLEEoZSwwLGZbdC5zdHJlbmd0aF0pKTtjb25zdCBpPUEoZSxmW3Quc3RyZW5ndGhdKSxhPXQua2V5cy5wYXNzd29yZFZlcmlmaWNhdGlvbjtpZihhWzBdIT1pWzBdfHxhWzFdIT1pWzFdKXRocm93IG5ldyBFcnJvcihcIkludmFsaWQgcGFzd29yZFwiKX0oZSxuLGUucGFzc3dvcmQpLGUucGFzc3dvcmQ9bnVsbCxlLmFlc0N0ckdsYWRtYW49bmV3IHcobmV3IHAoZS5rZXlzLmtleSksQXJyYXkuZnJvbShoKSksZS5obWFjPW5ldyB4KGUua2V5cy5hdXRoZW50aWNhdGlvbiksdD1BKHQsZltlLnN0cmVuZ3RoXSsyKTt9cmV0dXJuIG0oZSx0LG5ldyBVaW50OEFycmF5KHQubGVuZ3RoLTEwLSh0Lmxlbmd0aC0xMCklMTYpLDAsMTAsITApfWZsdXNoKCl7Y29uc3QgdD10aGlzLGU9dC5wZW5kaW5nSW5wdXQsbj1BKGUsMCxlLmxlbmd0aC0xMCksaT1BKGUsZS5sZW5ndGgtMTApO2xldCBhPW5ldyBVaW50OEFycmF5KDApO2lmKG4ubGVuZ3RoKXtjb25zdCBlPWIudG9CaXRzKG4pO3QuaG1hYy51cGRhdGUoZSk7Y29uc3QgaT10LmFlc0N0ckdsYWRtYW4udXBkYXRlKGUpO2E9Yi5mcm9tQml0cyhpKTt9bGV0IHI9ITA7aWYodC5zaWduZWQpe2NvbnN0IGU9QShiLmZyb21CaXRzKHQuaG1hYy5kaWdlc3QoKSksMCwxMCk7Zm9yKGxldCB0PTA7dDwxMDt0KyspZVt0XSE9aVt0XSYmKHI9ITEpO31yZXR1cm4ge3ZhbGlkOnIsZGF0YTphfX19Y2xhc3MgeXtjb25zdHJ1Y3Rvcih0LGUpe09iamVjdC5hc3NpZ24odGhpcyx7cGFzc3dvcmQ6dCxzdHJlbmd0aDplLTEscGVuZGluZ0lucHV0Om5ldyBVaW50OEFycmF5KDApfSk7fWFzeW5jIGFwcGVuZCh0KXtjb25zdCBlPXRoaXM7bGV0IG49bmV3IFVpbnQ4QXJyYXkoMCk7ZS5wYXNzd29yZCYmKG49YXdhaXQgYXN5bmMgZnVuY3Rpb24odCxlKXtjb25zdCBuPWNyeXB0by5nZXRSYW5kb21WYWx1ZXMobmV3IFVpbnQ4QXJyYXkoZlt0LnN0cmVuZ3RoXSkpO3JldHVybiBhd2FpdCBrKHQsZSxuKSx2KG4sdC5rZXlzLnBhc3N3b3JkVmVyaWZpY2F0aW9uKX0oZSxlLnBhc3N3b3JkKSxlLnBhc3N3b3JkPW51bGwsZS5hZXNDdHJHbGFkbWFuPW5ldyB3KG5ldyBwKGUua2V5cy5rZXkpLEFycmF5LmZyb20oaCkpLGUuaG1hYz1uZXcgeChlLmtleXMuYXV0aGVudGljYXRpb24pKTtjb25zdCBpPW5ldyBVaW50OEFycmF5KG4ubGVuZ3RoK3QubGVuZ3RoLXQubGVuZ3RoJTE2KTtyZXR1cm4gaS5zZXQobiwwKSxtKGUsdCxpLG4ubGVuZ3RoLDApfWZsdXNoKCl7Y29uc3QgdD10aGlzO2xldCBlPW5ldyBVaW50OEFycmF5KDApO2lmKHQucGVuZGluZ0lucHV0Lmxlbmd0aCl7Y29uc3Qgbj10LmFlc0N0ckdsYWRtYW4udXBkYXRlKGIudG9CaXRzKHQucGVuZGluZ0lucHV0KSk7dC5obWFjLnVwZGF0ZShuKSxlPWIuZnJvbUJpdHMobik7fWNvbnN0IG49QShiLmZyb21CaXRzKHQuaG1hYy5kaWdlc3QoKSksMCwxMCk7cmV0dXJuIHtkYXRhOnYoZSxuKSxzaWduYXR1cmU6bn19fWZ1bmN0aW9uIG0odCxlLG4saSxhLHIpe2NvbnN0IHM9ZS5sZW5ndGgtYTtsZXQgbztmb3IodC5wZW5kaW5nSW5wdXQubGVuZ3RoJiYoZT12KHQucGVuZGluZ0lucHV0LGUpLG49ZnVuY3Rpb24odCxlKXtpZihlJiZlPnQubGVuZ3RoKXtjb25zdCBuPXQ7KHQ9bmV3IFVpbnQ4QXJyYXkoZSkpLnNldChuLDApO31yZXR1cm4gdH0obixzLXMlMTYpKSxvPTA7bzw9cy0xNjtvKz0xNil7Y29uc3QgYT1iLnRvQml0cyhBKGUsbyxvKzE2KSk7ciYmdC5obWFjLnVwZGF0ZShhKTtjb25zdCBzPXQuYWVzQ3RyR2xhZG1hbi51cGRhdGUoYSk7cnx8dC5obWFjLnVwZGF0ZShzKSxuLnNldChiLmZyb21CaXRzKHMpLG8raSk7fXJldHVybiB0LnBlbmRpbmdJbnB1dD1BKGUsbyksbn1hc3luYyBmdW5jdGlvbiBrKHQsZSxuKXtjb25zdCBpPShuZXcgVGV4dEVuY29kZXIpLmVuY29kZShlKSxhPWF3YWl0IGNyeXB0by5zdWJ0bGUuaW1wb3J0S2V5KFwicmF3XCIsaSxfLCExLGMpLHI9YXdhaXQgY3J5cHRvLnN1YnRsZS5kZXJpdmVCaXRzKE9iamVjdC5hc3NpZ24oe3NhbHQ6bn0sZCksYSw4KigyKnVbdC5zdHJlbmd0aF0rMikpLHM9bmV3IFVpbnQ4QXJyYXkocik7dC5rZXlzPXtrZXk6Yi50b0JpdHMoQShzLDAsdVt0LnN0cmVuZ3RoXSkpLGF1dGhlbnRpY2F0aW9uOmIudG9CaXRzKEEocyx1W3Quc3RyZW5ndGhdLDIqdVt0LnN0cmVuZ3RoXSkpLHBhc3N3b3JkVmVyaWZpY2F0aW9uOkEocywyKnVbdC5zdHJlbmd0aF0pfTt9ZnVuY3Rpb24gdih0LGUpe2xldCBuPXQ7cmV0dXJuIHQubGVuZ3RoK2UubGVuZ3RoJiYobj1uZXcgVWludDhBcnJheSh0Lmxlbmd0aCtlLmxlbmd0aCksbi5zZXQodCwwKSxuLnNldChlLHQubGVuZ3RoKSksbn1mdW5jdGlvbiBBKHQsZSxuKXtyZXR1cm4gdC5zdWJhcnJheShlLG4pfWNsYXNzIFV7Y29uc3RydWN0b3IodCxlKXtPYmplY3QuYXNzaWduKHRoaXMse3Bhc3N3b3JkOnQscGFzc3dvcmRWZXJpZmljYXRpb246ZX0pLEUodGhpcyx0KTt9YXBwZW5kKHQpe2NvbnN0IGU9dGhpcztpZihlLnBhc3N3b3JkKXtjb25zdCBuPXooZSx0LnN1YmFycmF5KDAsMTIpKTtpZihlLnBhc3N3b3JkPW51bGwsblsxMV0hPWUucGFzc3dvcmRWZXJpZmljYXRpb24pdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBwYXN3b3JkXCIpO3Q9dC5zdWJhcnJheSgxMik7fXJldHVybiB6KGUsdCl9Zmx1c2goKXtyZXR1cm4ge3ZhbGlkOiEwLGRhdGE6bmV3IFVpbnQ4QXJyYXkoMCl9fX1jbGFzcyBTe2NvbnN0cnVjdG9yKHQsZSl7T2JqZWN0LmFzc2lnbih0aGlzLHtwYXNzd29yZDp0LHBhc3N3b3JkVmVyaWZpY2F0aW9uOmV9KSxFKHRoaXMsdCk7fWFwcGVuZCh0KXtjb25zdCBlPXRoaXM7bGV0IG4saTtpZihlLnBhc3N3b3JkKXtlLnBhc3N3b3JkPW51bGw7Y29uc3QgYT1jcnlwdG8uZ2V0UmFuZG9tVmFsdWVzKG5ldyBVaW50OEFycmF5KDEyKSk7YVsxMV09ZS5wYXNzd29yZFZlcmlmaWNhdGlvbixuPW5ldyBVaW50OEFycmF5KHQubGVuZ3RoK2EubGVuZ3RoKSxuLnNldChJKGUsYSksMCksaT0xMjt9ZWxzZSBuPW5ldyBVaW50OEFycmF5KHQubGVuZ3RoKSxpPTA7cmV0dXJuIG4uc2V0KEkoZSx0KSxpKSxufWZsdXNoKCl7cmV0dXJuIHtkYXRhOm5ldyBVaW50OEFycmF5KDApfX19ZnVuY3Rpb24geih0LGUpe2NvbnN0IG49bmV3IFVpbnQ4QXJyYXkoZS5sZW5ndGgpO2ZvcihsZXQgaT0wO2k8ZS5sZW5ndGg7aSsrKW5baV09TSh0KV5lW2ldLEModCxuW2ldKTtyZXR1cm4gbn1mdW5jdGlvbiBJKHQsZSl7Y29uc3Qgbj1uZXcgVWludDhBcnJheShlLmxlbmd0aCk7Zm9yKGxldCBpPTA7aTxlLmxlbmd0aDtpKyspbltpXT1NKHQpXmVbaV0sQyh0LGVbaV0pO3JldHVybiBufWZ1bmN0aW9uIEUodCxuKXt0LmtleXM9WzMwNTQxOTg5Niw1OTE3NTEwNDksODc4MDgyMTkyXSx0LmNyY0tleTA9bmV3IGUodC5rZXlzWzBdKSx0LmNyY0tleTI9bmV3IGUodC5rZXlzWzJdKTtmb3IobGV0IGU9MDtlPG4ubGVuZ3RoO2UrKylDKHQsbi5jaGFyQ29kZUF0KGUpKTt9ZnVuY3Rpb24gQyh0LGUpe3QuY3JjS2V5MC5hcHBlbmQoW2VdKSx0LmtleXNbMF09fnQuY3JjS2V5MC5nZXQoKSx0LmtleXNbMV09aih0LmtleXNbMV0rQih0LmtleXNbMF0pKSx0LmtleXNbMV09aihNYXRoLmltdWwodC5rZXlzWzFdLDEzNDc3NTgxMykrMSksdC5jcmNLZXkyLmFwcGVuZChbdC5rZXlzWzFdPj4+MjRdKSx0LmtleXNbMl09fnQuY3JjS2V5Mi5nZXQoKTt9ZnVuY3Rpb24gTSh0KXtjb25zdCBlPTJ8dC5rZXlzWzJdO3JldHVybiBCKE1hdGguaW11bChlLDFeZSk+Pj44KX1mdW5jdGlvbiBCKHQpe3JldHVybiAyNTUmdH1mdW5jdGlvbiBqKHQpe3JldHVybiA0Mjk0OTY3Mjk1JnR9Y2xhc3MgSHtjb25zdHJ1Y3Rvcih0LHtzaWduYXR1cmU6bixwYXNzd29yZDppLHNpZ25lZDphLGNvbXByZXNzZWQ6cix6aXBDcnlwdG86cyxwYXNzd29yZFZlcmlmaWNhdGlvbjpvLGVuY3J5cHRpb25TdHJlbmd0aDpsfSx7Y2h1bmtTaXplOl99KXtjb25zdCBkPUJvb2xlYW4oaSk7T2JqZWN0LmFzc2lnbih0aGlzLHtzaWduYXR1cmU6bixlbmNyeXB0ZWQ6ZCxzaWduZWQ6YSxjb21wcmVzc2VkOnIsaW5mbGF0ZTpyJiZuZXcgdCh7Y2h1bmtTaXplOl99KSxjcmMzMjphJiZuZXcgZSx6aXBDcnlwdG86cyxkZWNyeXB0OmQmJnM/bmV3IFUoaSxvKTpuZXcgZyhpLGEsbCl9KTt9YXN5bmMgYXBwZW5kKHQpe2NvbnN0IGU9dGhpcztyZXR1cm4gZS5lbmNyeXB0ZWQmJnQubGVuZ3RoJiYodD1hd2FpdCBlLmRlY3J5cHQuYXBwZW5kKHQpKSxlLmNvbXByZXNzZWQmJnQubGVuZ3RoJiYodD1hd2FpdCBlLmluZmxhdGUuYXBwZW5kKHQpKSwoIWUuZW5jcnlwdGVkfHxlLnppcENyeXB0bykmJmUuc2lnbmVkJiZ0Lmxlbmd0aCYmZS5jcmMzMi5hcHBlbmQodCksdH1hc3luYyBmbHVzaCgpe2NvbnN0IHQ9dGhpcztsZXQgZSxuPW5ldyBVaW50OEFycmF5KDApO2lmKHQuZW5jcnlwdGVkKXtjb25zdCBlPXQuZGVjcnlwdC5mbHVzaCgpO2lmKCFlLnZhbGlkKXRocm93IG5ldyBFcnJvcihcIkludmFsaWQgc2lnbmF0dXJlXCIpO249ZS5kYXRhO31pZigoIXQuZW5jcnlwdGVkfHx0LnppcENyeXB0bykmJnQuc2lnbmVkKXtjb25zdCBuPW5ldyBEYXRhVmlldyhuZXcgVWludDhBcnJheSg0KS5idWZmZXIpO2lmKGU9dC5jcmMzMi5nZXQoKSxuLnNldFVpbnQzMigwLGUpLHQuc2lnbmF0dXJlIT1uLmdldFVpbnQzMigwLCExKSl0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIHNpZ25hdHVyZVwiKX1yZXR1cm4gdC5jb21wcmVzc2VkJiYobj1hd2FpdCB0LmluZmxhdGUuYXBwZW5kKG4pfHxuZXcgVWludDhBcnJheSgwKSxhd2FpdCB0LmluZmxhdGUuZmx1c2goKSkse2RhdGE6bixzaWduYXR1cmU6ZX19fWNsYXNzIFZ7Y29uc3RydWN0b3IodCx7ZW5jcnlwdGVkOm4sc2lnbmVkOmksY29tcHJlc3NlZDphLGxldmVsOnIsemlwQ3J5cHRvOnMscGFzc3dvcmQ6byxwYXNzd29yZFZlcmlmaWNhdGlvbjpsLGVuY3J5cHRpb25TdHJlbmd0aDpffSx7Y2h1bmtTaXplOmR9KXtPYmplY3QuYXNzaWduKHRoaXMse2VuY3J5cHRlZDpuLHNpZ25lZDppLGNvbXByZXNzZWQ6YSxkZWZsYXRlOmEmJm5ldyB0KHtsZXZlbDpyfHw1LGNodW5rU2l6ZTpkfSksY3JjMzI6aSYmbmV3IGUsemlwQ3J5cHRvOnMsZW5jcnlwdDpuJiZzP25ldyBTKG8sbCk6bmV3IHkobyxfKX0pO31hc3luYyBhcHBlbmQodCl7Y29uc3QgZT10aGlzO2xldCBuPXQ7cmV0dXJuIGUuY29tcHJlc3NlZCYmdC5sZW5ndGgmJihuPWF3YWl0IGUuZGVmbGF0ZS5hcHBlbmQodCkpLGUuZW5jcnlwdGVkJiZuLmxlbmd0aCYmKG49YXdhaXQgZS5lbmNyeXB0LmFwcGVuZChuKSksKCFlLmVuY3J5cHRlZHx8ZS56aXBDcnlwdG8pJiZlLnNpZ25lZCYmdC5sZW5ndGgmJmUuY3JjMzIuYXBwZW5kKHQpLG59YXN5bmMgZmx1c2goKXtjb25zdCB0PXRoaXM7bGV0IGUsbj1uZXcgVWludDhBcnJheSgwKTtpZih0LmNvbXByZXNzZWQmJihuPWF3YWl0IHQuZGVmbGF0ZS5mbHVzaCgpfHxuZXcgVWludDhBcnJheSgwKSksdC5lbmNyeXB0ZWQpe249YXdhaXQgdC5lbmNyeXB0LmFwcGVuZChuKTtjb25zdCBpPXQuZW5jcnlwdC5mbHVzaCgpO2U9aS5zaWduYXR1cmU7Y29uc3QgYT1uZXcgVWludDhBcnJheShuLmxlbmd0aCtpLmRhdGEubGVuZ3RoKTthLnNldChuLDApLGEuc2V0KGkuZGF0YSxuLmxlbmd0aCksbj1hO31yZXR1cm4gdC5lbmNyeXB0ZWQmJiF0LnppcENyeXB0b3x8IXQuc2lnbmVkfHwoZT10LmNyYzMyLmdldCgpKSx7ZGF0YTpuLHNpZ25hdHVyZTplfX19Y29uc3QgTz17aW5pdCh0KXt0LnNjcmlwdHMmJnQuc2NyaXB0cy5sZW5ndGgmJmltcG9ydFNjcmlwdHMuYXBwbHkodm9pZCAwLHQuc2NyaXB0cyk7Y29uc3QgZT10Lm9wdGlvbnM7bGV0IG47c2VsZi5pbml0Q29kZWMmJnNlbGYuaW5pdENvZGVjKCksZS5jb2RlY1R5cGUuc3RhcnRzV2l0aChcImRlZmxhdGVcIik/bj1zZWxmLkRlZmxhdGU6ZS5jb2RlY1R5cGUuc3RhcnRzV2l0aChcImluZmxhdGVcIikmJihuPXNlbGYuSW5mbGF0ZSksRD1mdW5jdGlvbih0LGUsbil7cmV0dXJuIGUuY29kZWNUeXBlLnN0YXJ0c1dpdGgoXCJkZWZsYXRlXCIpP25ldyBWKHQsZSxuKTplLmNvZGVjVHlwZS5zdGFydHNXaXRoKFwiaW5mbGF0ZVwiKT9uZXcgSCh0LGUsbik6dm9pZCAwfShuLGUsdC5jb25maWcpO30sYXBwZW5kOmFzeW5jIHQ9Pih7ZGF0YTphd2FpdCBELmFwcGVuZCh0LmRhdGEpfSksZmx1c2g6KCk9PkQuZmx1c2goKX07bGV0IEQ7ZnVuY3Rpb24gTCh0KXtyZXR1cm4gUCh0Lm1hcCgoKFt0LGVdKT0+bmV3IEFycmF5KHQpLmZpbGwoZSwwLHQpKSkpfWZ1bmN0aW9uIFAodCl7cmV0dXJuIHQucmVkdWNlKCgodCxlKT0+dC5jb25jYXQoQXJyYXkuaXNBcnJheShlKT9QKGUpOmUpKSxbXSl9YWRkRXZlbnRMaXN0ZW5lcihcIm1lc3NhZ2VcIiwoYXN5bmMgdD0+e2NvbnN0IGU9dC5kYXRhLG49ZS50eXBlLGk9T1tuXTtpZihpKXRyeXtlLmRhdGEmJihlLmRhdGE9bmV3IFVpbnQ4QXJyYXkoZS5kYXRhKSk7Y29uc3QgdD1hd2FpdCBpKGUpfHx7fTtpZih0LnR5cGU9bix0LmRhdGEpdHJ5e3QuZGF0YT10LmRhdGEuYnVmZmVyLHBvc3RNZXNzYWdlKHQsW3QuZGF0YV0pO31jYXRjaChlKXtwb3N0TWVzc2FnZSh0KTt9ZWxzZSBwb3N0TWVzc2FnZSh0KTt9Y2F0Y2godCl7cG9zdE1lc3NhZ2Uoe3R5cGU6bixlcnJvcjp7bWVzc2FnZTp0Lm1lc3NhZ2Usc3RhY2s6dC5zdGFja319KTt9fSkpO2NvbnN0IEs9WzAsMSwyLDNdLmNvbmNhdCguLi5MKFtbMiw0XSxbMiw1XSxbNCw2XSxbNCw3XSxbOCw4XSxbOCw5XSxbMTYsMTBdLFsxNiwxMV0sWzMyLDEyXSxbMzIsMTNdLFs2NCwxNF0sWzY0LDE1XSxbMiwwXSxbMSwxNl0sWzEsMTddLFsyLDE4XSxbMiwxOV0sWzQsMjBdLFs0LDIxXSxbOCwyMl0sWzgsMjNdLFsxNiwyNF0sWzE2LDI1XSxbMzIsMjZdLFszMiwyN10sWzY0LDI4XSxbNjQsMjldXSkpO2Z1bmN0aW9uIFIoKXtjb25zdCB0PXRoaXM7ZnVuY3Rpb24gZSh0LGUpe2xldCBuPTA7ZG97bnw9MSZ0LHQ+Pj49MSxuPDw9MTt9d2hpbGUoLS1lPjApO3JldHVybiBuPj4+MX10LmJ1aWxkX3RyZWU9ZnVuY3Rpb24obil7Y29uc3QgaT10LmR5bl90cmVlLGE9dC5zdGF0X2Rlc2Muc3RhdGljX3RyZWUscj10LnN0YXRfZGVzYy5lbGVtcztsZXQgcyxvLGwsXz0tMTtmb3Iobi5oZWFwX2xlbj0wLG4uaGVhcF9tYXg9NTczLHM9MDtzPHI7cysrKTAhPT1pWzIqc10/KG4uaGVhcFsrK24uaGVhcF9sZW5dPV89cyxuLmRlcHRoW3NdPTApOmlbMipzKzFdPTA7Zm9yKDtuLmhlYXBfbGVuPDI7KWw9bi5oZWFwWysrbi5oZWFwX2xlbl09XzwyPysrXzowLGlbMipsXT0xLG4uZGVwdGhbbF09MCxuLm9wdF9sZW4tLSxhJiYobi5zdGF0aWNfbGVuLT1hWzIqbCsxXSk7Zm9yKHQubWF4X2NvZGU9XyxzPU1hdGguZmxvb3Iobi5oZWFwX2xlbi8yKTtzPj0xO3MtLSluLnBxZG93bmhlYXAoaSxzKTtsPXI7ZG97cz1uLmhlYXBbMV0sbi5oZWFwWzFdPW4uaGVhcFtuLmhlYXBfbGVuLS1dLG4ucHFkb3duaGVhcChpLDEpLG89bi5oZWFwWzFdLG4uaGVhcFstLW4uaGVhcF9tYXhdPXMsbi5oZWFwWy0tbi5oZWFwX21heF09byxpWzIqbF09aVsyKnNdK2lbMipvXSxuLmRlcHRoW2xdPU1hdGgubWF4KG4uZGVwdGhbc10sbi5kZXB0aFtvXSkrMSxpWzIqcysxXT1pWzIqbysxXT1sLG4uaGVhcFsxXT1sKyssbi5wcWRvd25oZWFwKGksMSk7fXdoaWxlKG4uaGVhcF9sZW4+PTIpO24uaGVhcFstLW4uaGVhcF9tYXhdPW4uaGVhcFsxXSxmdW5jdGlvbihlKXtjb25zdCBuPXQuZHluX3RyZWUsaT10LnN0YXRfZGVzYy5zdGF0aWNfdHJlZSxhPXQuc3RhdF9kZXNjLmV4dHJhX2JpdHMscj10LnN0YXRfZGVzYy5leHRyYV9iYXNlLHM9dC5zdGF0X2Rlc2MubWF4X2xlbmd0aDtsZXQgbyxsLF8sZCxjLGYsdT0wO2ZvcihkPTA7ZDw9MTU7ZCsrKWUuYmxfY291bnRbZF09MDtmb3IoblsyKmUuaGVhcFtlLmhlYXBfbWF4XSsxXT0wLG89ZS5oZWFwX21heCsxO288NTczO28rKylsPWUuaGVhcFtvXSxkPW5bMipuWzIqbCsxXSsxXSsxLGQ+cyYmKGQ9cyx1KyspLG5bMipsKzFdPWQsbD50Lm1heF9jb2RlfHwoZS5ibF9jb3VudFtkXSsrLGM9MCxsPj1yJiYoYz1hW2wtcl0pLGY9blsyKmxdLGUub3B0X2xlbis9ZiooZCtjKSxpJiYoZS5zdGF0aWNfbGVuKz1mKihpWzIqbCsxXStjKSkpO2lmKDAhPT11KXtkb3tmb3IoZD1zLTE7MD09PWUuYmxfY291bnRbZF07KWQtLTtlLmJsX2NvdW50W2RdLS0sZS5ibF9jb3VudFtkKzFdKz0yLGUuYmxfY291bnRbc10tLSx1LT0yO313aGlsZSh1PjApO2ZvcihkPXM7MCE9PWQ7ZC0tKWZvcihsPWUuYmxfY291bnRbZF07MCE9PWw7KV89ZS5oZWFwWy0tb10sXz50Lm1heF9jb2RlfHwoblsyKl8rMV0hPWQmJihlLm9wdF9sZW4rPShkLW5bMipfKzFdKSpuWzIqX10sblsyKl8rMV09ZCksbC0tKTt9fShuKSxmdW5jdGlvbih0LG4saSl7Y29uc3QgYT1bXTtsZXQgcixzLG8sbD0wO2ZvcihyPTE7cjw9MTU7cisrKWFbcl09bD1sK2lbci0xXTw8MTtmb3Iocz0wO3M8PW47cysrKW89dFsyKnMrMV0sMCE9PW8mJih0WzIqc109ZShhW29dKyssbykpO30oaSx0Lm1heF9jb2RlLG4uYmxfY291bnQpO307fWZ1bmN0aW9uIFcodCxlLG4saSxhKXtjb25zdCByPXRoaXM7ci5zdGF0aWNfdHJlZT10LHIuZXh0cmFfYml0cz1lLHIuZXh0cmFfYmFzZT1uLHIuZWxlbXM9aSxyLm1heF9sZW5ndGg9YTt9ZnVuY3Rpb24gRyh0LGUsbixpLGEpe2NvbnN0IHI9dGhpcztyLmdvb2RfbGVuZ3RoPXQsci5tYXhfbGF6eT1lLHIubmljZV9sZW5ndGg9bixyLm1heF9jaGFpbj1pLHIuZnVuYz1hO31SLl9sZW5ndGhfY29kZT1bMCwxLDIsMyw0LDUsNiw3XS5jb25jYXQoLi4uTChbWzIsOF0sWzIsOV0sWzIsMTBdLFsyLDExXSxbNCwxMl0sWzQsMTNdLFs0LDE0XSxbNCwxNV0sWzgsMTZdLFs4LDE3XSxbOCwxOF0sWzgsMTldLFsxNiwyMF0sWzE2LDIxXSxbMTYsMjJdLFsxNiwyM10sWzMyLDI0XSxbMzIsMjVdLFszMiwyNl0sWzMxLDI3XSxbMSwyOF1dKSksUi5iYXNlX2xlbmd0aD1bMCwxLDIsMyw0LDUsNiw3LDgsMTAsMTIsMTQsMTYsMjAsMjQsMjgsMzIsNDAsNDgsNTYsNjQsODAsOTYsMTEyLDEyOCwxNjAsMTkyLDIyNCwwXSxSLmJhc2VfZGlzdD1bMCwxLDIsMyw0LDYsOCwxMiwxNiwyNCwzMiw0OCw2NCw5NiwxMjgsMTkyLDI1NiwzODQsNTEyLDc2OCwxMDI0LDE1MzYsMjA0OCwzMDcyLDQwOTYsNjE0NCw4MTkyLDEyMjg4LDE2Mzg0LDI0NTc2XSxSLmRfY29kZT1mdW5jdGlvbih0KXtyZXR1cm4gdDwyNTY/S1t0XTpLWzI1NisodD4+PjcpXX0sUi5leHRyYV9sYml0cz1bMCwwLDAsMCwwLDAsMCwwLDEsMSwxLDEsMiwyLDIsMiwzLDMsMywzLDQsNCw0LDQsNSw1LDUsNSwwXSxSLmV4dHJhX2RiaXRzPVswLDAsMCwwLDEsMSwyLDIsMywzLDQsNCw1LDUsNiw2LDcsNyw4LDgsOSw5LDEwLDEwLDExLDExLDEyLDEyLDEzLDEzXSxSLmV4dHJhX2JsYml0cz1bMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwyLDMsN10sUi5ibF9vcmRlcj1bMTYsMTcsMTgsMCw4LDcsOSw2LDEwLDUsMTEsNCwxMiwzLDEzLDIsMTQsMSwxNV0sVy5zdGF0aWNfbHRyZWU9WzEyLDgsMTQwLDgsNzYsOCwyMDQsOCw0NCw4LDE3Miw4LDEwOCw4LDIzNiw4LDI4LDgsMTU2LDgsOTIsOCwyMjAsOCw2MCw4LDE4OCw4LDEyNCw4LDI1Miw4LDIsOCwxMzAsOCw2Niw4LDE5NCw4LDM0LDgsMTYyLDgsOTgsOCwyMjYsOCwxOCw4LDE0Niw4LDgyLDgsMjEwLDgsNTAsOCwxNzgsOCwxMTQsOCwyNDIsOCwxMCw4LDEzOCw4LDc0LDgsMjAyLDgsNDIsOCwxNzAsOCwxMDYsOCwyMzQsOCwyNiw4LDE1NCw4LDkwLDgsMjE4LDgsNTgsOCwxODYsOCwxMjIsOCwyNTAsOCw2LDgsMTM0LDgsNzAsOCwxOTgsOCwzOCw4LDE2Niw4LDEwMiw4LDIzMCw4LDIyLDgsMTUwLDgsODYsOCwyMTQsOCw1NCw4LDE4Miw4LDExOCw4LDI0Niw4LDE0LDgsMTQyLDgsNzgsOCwyMDYsOCw0Niw4LDE3NCw4LDExMCw4LDIzOCw4LDMwLDgsMTU4LDgsOTQsOCwyMjIsOCw2Miw4LDE5MCw4LDEyNiw4LDI1NCw4LDEsOCwxMjksOCw2NSw4LDE5Myw4LDMzLDgsMTYxLDgsOTcsOCwyMjUsOCwxNyw4LDE0NSw4LDgxLDgsMjA5LDgsNDksOCwxNzcsOCwxMTMsOCwyNDEsOCw5LDgsMTM3LDgsNzMsOCwyMDEsOCw0MSw4LDE2OSw4LDEwNSw4LDIzMyw4LDI1LDgsMTUzLDgsODksOCwyMTcsOCw1Nyw4LDE4NSw4LDEyMSw4LDI0OSw4LDUsOCwxMzMsOCw2OSw4LDE5Nyw4LDM3LDgsMTY1LDgsMTAxLDgsMjI5LDgsMjEsOCwxNDksOCw4NSw4LDIxMyw4LDUzLDgsMTgxLDgsMTE3LDgsMjQ1LDgsMTMsOCwxNDEsOCw3Nyw4LDIwNSw4LDQ1LDgsMTczLDgsMTA5LDgsMjM3LDgsMjksOCwxNTcsOCw5Myw4LDIyMSw4LDYxLDgsMTg5LDgsMTI1LDgsMjUzLDgsMTksOSwyNzUsOSwxNDcsOSw0MDMsOSw4Myw5LDMzOSw5LDIxMSw5LDQ2Nyw5LDUxLDksMzA3LDksMTc5LDksNDM1LDksMTE1LDksMzcxLDksMjQzLDksNDk5LDksMTEsOSwyNjcsOSwxMzksOSwzOTUsOSw3NSw5LDMzMSw5LDIwMyw5LDQ1OSw5LDQzLDksMjk5LDksMTcxLDksNDI3LDksMTA3LDksMzYzLDksMjM1LDksNDkxLDksMjcsOSwyODMsOSwxNTUsOSw0MTEsOSw5MSw5LDM0Nyw5LDIxOSw5LDQ3NSw5LDU5LDksMzE1LDksMTg3LDksNDQzLDksMTIzLDksMzc5LDksMjUxLDksNTA3LDksNyw5LDI2Myw5LDEzNSw5LDM5MSw5LDcxLDksMzI3LDksMTk5LDksNDU1LDksMzksOSwyOTUsOSwxNjcsOSw0MjMsOSwxMDMsOSwzNTksOSwyMzEsOSw0ODcsOSwyMyw5LDI3OSw5LDE1MSw5LDQwNyw5LDg3LDksMzQzLDksMjE1LDksNDcxLDksNTUsOSwzMTEsOSwxODMsOSw0MzksOSwxMTksOSwzNzUsOSwyNDcsOSw1MDMsOSwxNSw5LDI3MSw5LDE0Myw5LDM5OSw5LDc5LDksMzM1LDksMjA3LDksNDYzLDksNDcsOSwzMDMsOSwxNzUsOSw0MzEsOSwxMTEsOSwzNjcsOSwyMzksOSw0OTUsOSwzMSw5LDI4Nyw5LDE1OSw5LDQxNSw5LDk1LDksMzUxLDksMjIzLDksNDc5LDksNjMsOSwzMTksOSwxOTEsOSw0NDcsOSwxMjcsOSwzODMsOSwyNTUsOSw1MTEsOSwwLDcsNjQsNywzMiw3LDk2LDcsMTYsNyw4MCw3LDQ4LDcsMTEyLDcsOCw3LDcyLDcsNDAsNywxMDQsNywyNCw3LDg4LDcsNTYsNywxMjAsNyw0LDcsNjgsNywzNiw3LDEwMCw3LDIwLDcsODQsNyw1Miw3LDExNiw3LDMsOCwxMzEsOCw2Nyw4LDE5NSw4LDM1LDgsMTYzLDgsOTksOCwyMjcsOF0sVy5zdGF0aWNfZHRyZWU9WzAsNSwxNiw1LDgsNSwyNCw1LDQsNSwyMCw1LDEyLDUsMjgsNSwyLDUsMTgsNSwxMCw1LDI2LDUsNiw1LDIyLDUsMTQsNSwzMCw1LDEsNSwxNyw1LDksNSwyNSw1LDUsNSwyMSw1LDEzLDUsMjksNSwzLDUsMTksNSwxMSw1LDI3LDUsNyw1LDIzLDVdLFcuc3RhdGljX2xfZGVzYz1uZXcgVyhXLnN0YXRpY19sdHJlZSxSLmV4dHJhX2xiaXRzLDI1NywyODYsMTUpLFcuc3RhdGljX2RfZGVzYz1uZXcgVyhXLnN0YXRpY19kdHJlZSxSLmV4dHJhX2RiaXRzLDAsMzAsMTUpLFcuc3RhdGljX2JsX2Rlc2M9bmV3IFcobnVsbCxSLmV4dHJhX2JsYml0cywwLDE5LDcpO2NvbnN0IFQ9W25ldyBHKDAsMCwwLDAsMCksbmV3IEcoNCw0LDgsNCwxKSxuZXcgRyg0LDUsMTYsOCwxKSxuZXcgRyg0LDYsMzIsMzIsMSksbmV3IEcoNCw0LDE2LDE2LDIpLG5ldyBHKDgsMTYsMzIsMzIsMiksbmV3IEcoOCwxNiwxMjgsMTI4LDIpLG5ldyBHKDgsMzIsMTI4LDI1NiwyKSxuZXcgRygzMiwxMjgsMjU4LDEwMjQsMiksbmV3IEcoMzIsMjU4LDI1OCw0MDk2LDIpXSxxPVtcIm5lZWQgZGljdGlvbmFyeVwiLFwic3RyZWFtIGVuZFwiLFwiXCIsXCJcIixcInN0cmVhbSBlcnJvclwiLFwiZGF0YSBlcnJvclwiLFwiXCIsXCJidWZmZXIgZXJyb3JcIixcIlwiLFwiXCJdO2Z1bmN0aW9uIEYodCxlLG4saSl7Y29uc3QgYT10WzIqZV0scj10WzIqbl07cmV0dXJuIGE8cnx8YT09ciYmaVtlXTw9aVtuXX1mdW5jdGlvbiBKKCl7Y29uc3QgdD10aGlzO2xldCBlLG4saSxhLHIscyxvLGwsXyxkLGMsZix1LGgsYixwLHcseCxnLHksbSxrLHYsQSxVLFMseixJLEUsQyxNLEIsajtjb25zdCBIPW5ldyBSLFY9bmV3IFIsTz1uZXcgUjtsZXQgRCxMLFAsSyxHLEosTixRO2Z1bmN0aW9uIFgoKXtsZXQgZTtmb3IoZT0wO2U8Mjg2O2UrKylNWzIqZV09MDtmb3IoZT0wO2U8MzA7ZSsrKUJbMiplXT0wO2ZvcihlPTA7ZTwxOTtlKyspalsyKmVdPTA7TVs1MTJdPTEsdC5vcHRfbGVuPXQuc3RhdGljX2xlbj0wLFA9Rz0wO31mdW5jdGlvbiBZKHQsZSl7bGV0IG4saT0tMSxhPXRbMV0scj0wLHM9NyxvPTQ7MD09PWEmJihzPTEzOCxvPTMpLHRbMiooZSsxKSsxXT02NTUzNTtmb3IobGV0IGw9MDtsPD1lO2wrKyluPWEsYT10WzIqKGwrMSkrMV0sKytyPHMmJm49PWF8fChyPG8/alsyKm5dKz1yOjAhPT1uPyhuIT1pJiZqWzIqbl0rKyxqWzMyXSsrKTpyPD0xMD9qWzM0XSsrOmpbMzZdKysscj0wLGk9biwwPT09YT8ocz0xMzgsbz0zKTpuPT1hPyhzPTYsbz0zKToocz03LG89NCkpO31mdW5jdGlvbiBaKGUpe3QucGVuZGluZ19idWZbdC5wZW5kaW5nKytdPWU7fWZ1bmN0aW9uICQodCl7WigyNTUmdCksWih0Pj4+OCYyNTUpO31mdW5jdGlvbiB0dCh0LGUpe2xldCBuO2NvbnN0IGk9ZTtRPjE2LWk/KG49dCxOfD1uPDxRJjY1NTM1LCQoTiksTj1uPj4+MTYtUSxRKz1pLTE2KTooTnw9dDw8USY2NTUzNSxRKz1pKTt9ZnVuY3Rpb24gZXQodCxlKXtjb25zdCBuPTIqdDt0dCg2NTUzNSZlW25dLDY1NTM1JmVbbisxXSk7fWZ1bmN0aW9uIG50KHQsZSl7bGV0IG4saSxhPS0xLHI9dFsxXSxzPTAsbz03LGw9NDtmb3IoMD09PXImJihvPTEzOCxsPTMpLG49MDtuPD1lO24rKylpZihpPXIscj10WzIqKG4rMSkrMV0sISgrK3M8byYmaT09cikpe2lmKHM8bClkb3tldChpLGopO313aGlsZSgwIT0tLXMpO2Vsc2UgMCE9PWk/KGkhPWEmJihldChpLGopLHMtLSksZXQoMTYsaiksdHQocy0zLDIpKTpzPD0xMD8oZXQoMTcsaiksdHQocy0zLDMpKTooZXQoMTgsaiksdHQocy0xMSw3KSk7cz0wLGE9aSwwPT09cj8obz0xMzgsbD0zKTppPT1yPyhvPTYsbD0zKToobz03LGw9NCk7fX1mdW5jdGlvbiBpdCgpezE2PT1RPygkKE4pLE49MCxRPTApOlE+PTgmJihaKDI1NSZOKSxOPj4+PTgsUS09OCk7fWZ1bmN0aW9uIGF0KGUsbil7bGV0IGksYSxyO2lmKHQucGVuZGluZ19idWZbSysyKlBdPWU+Pj44JjI1NSx0LnBlbmRpbmdfYnVmW0srMipQKzFdPTI1NSZlLHQucGVuZGluZ19idWZbRCtQXT0yNTUmbixQKyssMD09PWU/TVsyKm5dKys6KEcrKyxlLS0sTVsyKihSLl9sZW5ndGhfY29kZVtuXSsyNTYrMSldKyssQlsyKlIuZF9jb2RlKGUpXSsrKSwwPT0oODE5MSZQKSYmej4yKXtmb3IoaT04KlAsYT1tLXcscj0wO3I8MzA7cisrKWkrPUJbMipyXSooNStSLmV4dHJhX2RiaXRzW3JdKTtpZihpPj4+PTMsRzxNYXRoLmZsb29yKFAvMikmJmk8TWF0aC5mbG9vcihhLzIpKXJldHVybiAhMH1yZXR1cm4gUD09TC0xfWZ1bmN0aW9uIHJ0KGUsbil7bGV0IGksYSxyLHMsbz0wO2lmKDAhPT1QKWRve2k9dC5wZW5kaW5nX2J1ZltLKzIqb108PDgmNjUyODB8MjU1JnQucGVuZGluZ19idWZbSysyKm8rMV0sYT0yNTUmdC5wZW5kaW5nX2J1ZltEK29dLG8rKywwPT09aT9ldChhLGUpOihyPVIuX2xlbmd0aF9jb2RlW2FdLGV0KHIrMjU2KzEsZSkscz1SLmV4dHJhX2xiaXRzW3JdLDAhPT1zJiYoYS09Ui5iYXNlX2xlbmd0aFtyXSx0dChhLHMpKSxpLS0scj1SLmRfY29kZShpKSxldChyLG4pLHM9Ui5leHRyYV9kYml0c1tyXSwwIT09cyYmKGktPVIuYmFzZV9kaXN0W3JdLHR0KGkscykpKTt9d2hpbGUobzxQKTtldCgyNTYsZSksSj1lWzUxM107fWZ1bmN0aW9uIHN0KCl7UT44PyQoTik6UT4wJiZaKDI1NSZOKSxOPTAsUT0wO31mdW5jdGlvbiBvdChlLG4saSl7dHQoMCsoaT8xOjApLDMpLGZ1bmN0aW9uKGUsbixpKXtzdCgpLEo9OCwkKG4pLCQofm4pLHQucGVuZGluZ19idWYuc2V0KGwuc3ViYXJyYXkoZSxlK24pLHQucGVuZGluZyksdC5wZW5kaW5nKz1uO30oZSxuKTt9ZnVuY3Rpb24gbHQoZSxuLGkpe2xldCBhLHIscz0wO3o+MD8oSC5idWlsZF90cmVlKHQpLFYuYnVpbGRfdHJlZSh0KSxzPWZ1bmN0aW9uKCl7bGV0IGU7Zm9yKFkoTSxILm1heF9jb2RlKSxZKEIsVi5tYXhfY29kZSksTy5idWlsZF90cmVlKHQpLGU9MTg7ZT49MyYmMD09PWpbMipSLmJsX29yZGVyW2VdKzFdO2UtLSk7cmV0dXJuIHQub3B0X2xlbis9MyooZSsxKSs1KzUrNCxlfSgpLGE9dC5vcHRfbGVuKzMrNz4+PjMscj10LnN0YXRpY19sZW4rMys3Pj4+MyxyPD1hJiYoYT1yKSk6YT1yPW4rNSxuKzQ8PWEmJi0xIT1lP290KGUsbixpKTpyPT1hPyh0dCgyKyhpPzE6MCksMykscnQoVy5zdGF0aWNfbHRyZWUsVy5zdGF0aWNfZHRyZWUpKToodHQoNCsoaT8xOjApLDMpLGZ1bmN0aW9uKHQsZSxuKXtsZXQgaTtmb3IodHQodC0yNTcsNSksdHQoZS0xLDUpLHR0KG4tNCw0KSxpPTA7aTxuO2krKyl0dChqWzIqUi5ibF9vcmRlcltpXSsxXSwzKTtudChNLHQtMSksbnQoQixlLTEpO30oSC5tYXhfY29kZSsxLFYubWF4X2NvZGUrMSxzKzEpLHJ0KE0sQikpLFgoKSxpJiZzdCgpO31mdW5jdGlvbiBfdCh0KXtsdCh3Pj0wP3c6LTEsbS13LHQpLHc9bSxlLmZsdXNoX3BlbmRpbmcoKTt9ZnVuY3Rpb24gZHQoKXtsZXQgdCxuLGksYTtkb3tpZihhPV8tdi1tLDA9PT1hJiYwPT09bSYmMD09PXYpYT1yO2Vsc2UgaWYoLTE9PWEpYS0tO2Vsc2UgaWYobT49cityLTI2Mil7bC5zZXQobC5zdWJhcnJheShyLHIrciksMCksay09cixtLT1yLHctPXIsdD11LGk9dDtkb3tuPTY1NTM1JmNbLS1pXSxjW2ldPW4+PXI/bi1yOjA7fXdoaWxlKDAhPS0tdCk7dD1yLGk9dDtkb3tuPTY1NTM1JmRbLS1pXSxkW2ldPW4+PXI/bi1yOjA7fXdoaWxlKDAhPS0tdCk7YSs9cjt9aWYoMD09PWUuYXZhaWxfaW4pcmV0dXJuO3Q9ZS5yZWFkX2J1ZihsLG0rdixhKSx2Kz10LHY+PTMmJihmPTI1NSZsW21dLGY9KGY8PHBeMjU1JmxbbSsxXSkmYik7fXdoaWxlKHY8MjYyJiYwIT09ZS5hdmFpbF9pbil9ZnVuY3Rpb24gY3QodCl7bGV0IGUsbixpPVUsYT1tLHM9QTtjb25zdCBfPW0+ci0yNjI/bS0oci0yNjIpOjA7bGV0IGM9Qztjb25zdCBmPW8sdT1tKzI1ODtsZXQgaD1sW2Ercy0xXSxiPWxbYStzXTtBPj1FJiYoaT4+PTIpLGM+diYmKGM9dik7ZG97aWYoZT10LGxbZStzXT09YiYmbFtlK3MtMV09PWgmJmxbZV09PWxbYV0mJmxbKytlXT09bFthKzFdKXthKz0yLGUrKztkb3t9d2hpbGUobFsrK2FdPT1sWysrZV0mJmxbKythXT09bFsrK2VdJiZsWysrYV09PWxbKytlXSYmbFsrK2FdPT1sWysrZV0mJmxbKythXT09bFsrK2VdJiZsWysrYV09PWxbKytlXSYmbFsrK2FdPT1sWysrZV0mJmxbKythXT09bFsrK2VdJiZhPHUpO2lmKG49MjU4LSh1LWEpLGE9dS0yNTgsbj5zKXtpZihrPXQscz1uLG4+PWMpYnJlYWs7aD1sW2Ercy0xXSxiPWxbYStzXTt9fX13aGlsZSgodD02NTUzNSZkW3QmZl0pPl8mJjAhPS0taSk7cmV0dXJuIHM8PXY/czp2fWZ1bmN0aW9uIGZ0KGUpe3JldHVybiBlLnRvdGFsX2luPWUudG90YWxfb3V0PTAsZS5tc2c9bnVsbCx0LnBlbmRpbmc9MCx0LnBlbmRpbmdfb3V0PTAsbj0xMTMsYT0wLEguZHluX3RyZWU9TSxILnN0YXRfZGVzYz1XLnN0YXRpY19sX2Rlc2MsVi5keW5fdHJlZT1CLFYuc3RhdF9kZXNjPVcuc3RhdGljX2RfZGVzYyxPLmR5bl90cmVlPWosTy5zdGF0X2Rlc2M9Vy5zdGF0aWNfYmxfZGVzYyxOPTAsUT0wLEo9OCxYKCksZnVuY3Rpb24oKXtfPTIqcixjW3UtMV09MDtmb3IobGV0IHQ9MDt0PHUtMTt0KyspY1t0XT0wO1M9VFt6XS5tYXhfbGF6eSxFPVRbel0uZ29vZF9sZW5ndGgsQz1UW3pdLm5pY2VfbGVuZ3RoLFU9VFt6XS5tYXhfY2hhaW4sbT0wLHc9MCx2PTAseD1BPTIseT0wLGY9MDt9KCksMH10LmRlcHRoPVtdLHQuYmxfY291bnQ9W10sdC5oZWFwPVtdLE09W10sQj1bXSxqPVtdLHQucHFkb3duaGVhcD1mdW5jdGlvbihlLG4pe2NvbnN0IGk9dC5oZWFwLGE9aVtuXTtsZXQgcj1uPDwxO2Zvcig7cjw9dC5oZWFwX2xlbiYmKHI8dC5oZWFwX2xlbiYmRihlLGlbcisxXSxpW3JdLHQuZGVwdGgpJiZyKyssIUYoZSxhLGlbcl0sdC5kZXB0aCkpOylpW25dPWlbcl0sbj1yLHI8PD0xO2lbbl09YTt9LHQuZGVmbGF0ZUluaXQ9ZnVuY3Rpb24oZSxuLGEsXyxmLHcpe3JldHVybiBffHwoXz04KSxmfHwoZj04KSx3fHwodz0wKSxlLm1zZz1udWxsLC0xPT1uJiYobj02KSxmPDF8fGY+OXx8OCE9X3x8YTw5fHxhPjE1fHxuPDB8fG4+OXx8dzwwfHx3PjI/LTI6KGUuZHN0YXRlPXQscz1hLHI9MTw8cyxvPXItMSxoPWYrNyx1PTE8PGgsYj11LTEscD1NYXRoLmZsb29yKChoKzMtMSkvMyksbD1uZXcgVWludDhBcnJheSgyKnIpLGQ9W10sYz1bXSxMPTE8PGYrNix0LnBlbmRpbmdfYnVmPW5ldyBVaW50OEFycmF5KDQqTCksaT00KkwsSz1NYXRoLmZsb29yKEwvMiksRD0zKkwsej1uLEk9dyxmdChlKSl9LHQuZGVmbGF0ZUVuZD1mdW5jdGlvbigpe3JldHVybiA0MiE9biYmMTEzIT1uJiY2NjYhPW4/LTI6KHQucGVuZGluZ19idWY9bnVsbCxjPW51bGwsZD1udWxsLGw9bnVsbCx0LmRzdGF0ZT1udWxsLDExMz09bj8tMzowKX0sdC5kZWZsYXRlUGFyYW1zPWZ1bmN0aW9uKHQsZSxuKXtsZXQgaT0wO3JldHVybiAtMT09ZSYmKGU9NiksZTwwfHxlPjl8fG48MHx8bj4yPy0yOihUW3pdLmZ1bmMhPVRbZV0uZnVuYyYmMCE9PXQudG90YWxfaW4mJihpPXQuZGVmbGF0ZSgxKSkseiE9ZSYmKHo9ZSxTPVRbel0ubWF4X2xhenksRT1UW3pdLmdvb2RfbGVuZ3RoLEM9VFt6XS5uaWNlX2xlbmd0aCxVPVRbel0ubWF4X2NoYWluKSxJPW4saSl9LHQuZGVmbGF0ZVNldERpY3Rpb25hcnk9ZnVuY3Rpb24odCxlLGkpe2xldCBhLHM9aSxfPTA7aWYoIWV8fDQyIT1uKXJldHVybiAtMjtpZihzPDMpcmV0dXJuIDA7Zm9yKHM+ci0yNjImJihzPXItMjYyLF89aS1zKSxsLnNldChlLnN1YmFycmF5KF8sXytzKSwwKSxtPXMsdz1zLGY9MjU1JmxbMF0sZj0oZjw8cF4yNTUmbFsxXSkmYixhPTA7YTw9cy0zO2ErKylmPShmPDxwXjI1NSZsW2ErMl0pJmIsZFthJm9dPWNbZl0sY1tmXT1hO3JldHVybiAwfSx0LmRlZmxhdGU9ZnVuY3Rpb24oXyxoKXtsZXQgVSxFLEMsTSxCO2lmKGg+NHx8aDwwKXJldHVybiAtMjtpZighXy5uZXh0X291dHx8IV8ubmV4dF9pbiYmMCE9PV8uYXZhaWxfaW58fDY2Nj09biYmNCE9aClyZXR1cm4gXy5tc2c9cVs0XSwtMjtpZigwPT09Xy5hdmFpbF9vdXQpcmV0dXJuIF8ubXNnPXFbN10sLTU7dmFyIGo7aWYoZT1fLE09YSxhPWgsNDI9PW4mJihFPTgrKHMtODw8NCk8PDgsQz0oei0xJjI1NSk+PjEsQz4zJiYoQz0zKSxFfD1DPDw2LDAhPT1tJiYoRXw9MzIpLEUrPTMxLUUlMzEsbj0xMTMsWigoaj1FKT4+OCYyNTUpLFooMjU1JmopKSwwIT09dC5wZW5kaW5nKXtpZihlLmZsdXNoX3BlbmRpbmcoKSwwPT09ZS5hdmFpbF9vdXQpcmV0dXJuIGE9LTEsMH1lbHNlIGlmKDA9PT1lLmF2YWlsX2luJiZoPD1NJiY0IT1oKXJldHVybiBlLm1zZz1xWzddLC01O2lmKDY2Nj09biYmMCE9PWUuYXZhaWxfaW4pcmV0dXJuIF8ubXNnPXFbN10sLTU7aWYoMCE9PWUuYXZhaWxfaW58fDAhPT12fHwwIT1oJiY2NjYhPW4pe3N3aXRjaChCPS0xLFRbel0uZnVuYyl7Y2FzZSAwOkI9ZnVuY3Rpb24odCl7bGV0IG4sYT02NTUzNTtmb3IoYT5pLTUmJihhPWktNSk7Oyl7aWYodjw9MSl7aWYoZHQoKSwwPT09diYmMD09dClyZXR1cm4gMDtpZigwPT09dilicmVha31pZihtKz12LHY9MCxuPXcrYSwoMD09PW18fG0+PW4pJiYodj1tLW4sbT1uLF90KCExKSwwPT09ZS5hdmFpbF9vdXQpKXJldHVybiAwO2lmKG0tdz49ci0yNjImJihfdCghMSksMD09PWUuYXZhaWxfb3V0KSlyZXR1cm4gMH1yZXR1cm4gX3QoND09dCksMD09PWUuYXZhaWxfb3V0PzQ9PXQ/MjowOjQ9PXQ/MzoxfShoKTticmVhaztjYXNlIDE6Qj1mdW5jdGlvbih0KXtsZXQgbixpPTA7Zm9yKDs7KXtpZih2PDI2Mil7aWYoZHQoKSx2PDI2MiYmMD09dClyZXR1cm4gMDtpZigwPT09dilicmVha31pZih2Pj0zJiYoZj0oZjw8cF4yNTUmbFttKzJdKSZiLGk9NjU1MzUmY1tmXSxkW20mb109Y1tmXSxjW2ZdPW0pLDAhPT1pJiYobS1pJjY1NTM1KTw9ci0yNjImJjIhPUkmJih4PWN0KGkpKSx4Pj0zKWlmKG49YXQobS1rLHgtMyksdi09eCx4PD1TJiZ2Pj0zKXt4LS07ZG97bSsrLGY9KGY8PHBeMjU1JmxbbSsyXSkmYixpPTY1NTM1JmNbZl0sZFttJm9dPWNbZl0sY1tmXT1tO313aGlsZSgwIT0tLXgpO20rKzt9ZWxzZSBtKz14LHg9MCxmPTI1NSZsW21dLGY9KGY8PHBeMjU1JmxbbSsxXSkmYjtlbHNlIG49YXQoMCwyNTUmbFttXSksdi0tLG0rKztpZihuJiYoX3QoITEpLDA9PT1lLmF2YWlsX291dCkpcmV0dXJuIDB9cmV0dXJuIF90KDQ9PXQpLDA9PT1lLmF2YWlsX291dD80PT10PzI6MDo0PT10PzM6MX0oaCk7YnJlYWs7Y2FzZSAyOkI9ZnVuY3Rpb24odCl7bGV0IG4saSxhPTA7Zm9yKDs7KXtpZih2PDI2Mil7aWYoZHQoKSx2PDI2MiYmMD09dClyZXR1cm4gMDtpZigwPT09dilicmVha31pZih2Pj0zJiYoZj0oZjw8cF4yNTUmbFttKzJdKSZiLGE9NjU1MzUmY1tmXSxkW20mb109Y1tmXSxjW2ZdPW0pLEE9eCxnPWsseD0yLDAhPT1hJiZBPFMmJihtLWEmNjU1MzUpPD1yLTI2MiYmKDIhPUkmJih4PWN0KGEpKSx4PD01JiYoMT09SXx8Mz09eCYmbS1rPjQwOTYpJiYoeD0yKSksQT49MyYmeDw9QSl7aT1tK3YtMyxuPWF0KG0tMS1nLEEtMyksdi09QS0xLEEtPTI7ZG97KyttPD1pJiYoZj0oZjw8cF4yNTUmbFttKzJdKSZiLGE9NjU1MzUmY1tmXSxkW20mb109Y1tmXSxjW2ZdPW0pO313aGlsZSgwIT0tLUEpO2lmKHk9MCx4PTIsbSsrLG4mJihfdCghMSksMD09PWUuYXZhaWxfb3V0KSlyZXR1cm4gMH1lbHNlIGlmKDAhPT15KXtpZihuPWF0KDAsMjU1JmxbbS0xXSksbiYmX3QoITEpLG0rKyx2LS0sMD09PWUuYXZhaWxfb3V0KXJldHVybiAwfWVsc2UgeT0xLG0rKyx2LS07fXJldHVybiAwIT09eSYmKG49YXQoMCwyNTUmbFttLTFdKSx5PTApLF90KDQ9PXQpLDA9PT1lLmF2YWlsX291dD80PT10PzI6MDo0PT10PzM6MX0oaCk7fWlmKDIhPUImJjMhPUJ8fChuPTY2NiksMD09Qnx8Mj09QilyZXR1cm4gMD09PWUuYXZhaWxfb3V0JiYoYT0tMSksMDtpZigxPT1CKXtpZigxPT1oKXR0KDIsMyksZXQoMjU2LFcuc3RhdGljX2x0cmVlKSxpdCgpLDErSisxMC1RPDkmJih0dCgyLDMpLGV0KDI1NixXLnN0YXRpY19sdHJlZSksaXQoKSksSj03O2Vsc2UgaWYob3QoMCwwLCExKSwzPT1oKWZvcihVPTA7VTx1O1UrKyljW1VdPTA7aWYoZS5mbHVzaF9wZW5kaW5nKCksMD09PWUuYXZhaWxfb3V0KXJldHVybiBhPS0xLDB9fXJldHVybiA0IT1oPzA6MX07fWZ1bmN0aW9uIE4oKXtjb25zdCB0PXRoaXM7dC5uZXh0X2luX2luZGV4PTAsdC5uZXh0X291dF9pbmRleD0wLHQuYXZhaWxfaW49MCx0LnRvdGFsX2luPTAsdC5hdmFpbF9vdXQ9MCx0LnRvdGFsX291dD0wO31mdW5jdGlvbiBRKHQpe2NvbnN0IGU9bmV3IE4sbj0oaT10JiZ0LmNodW5rU2l6ZT90LmNodW5rU2l6ZTo2NTUzNikrNSooTWF0aC5mbG9vcihpLzE2MzgzKSsxKTt2YXIgaTtjb25zdCBhPW5ldyBVaW50OEFycmF5KG4pO2xldCByPXQ/dC5sZXZlbDotMTt2b2lkIDA9PT1yJiYocj0tMSksZS5kZWZsYXRlSW5pdChyKSxlLm5leHRfb3V0PWEsdGhpcy5hcHBlbmQ9ZnVuY3Rpb24odCxpKXtsZXQgcixzLG89MCxsPTAsXz0wO2NvbnN0IGQ9W107aWYodC5sZW5ndGgpe2UubmV4dF9pbl9pbmRleD0wLGUubmV4dF9pbj10LGUuYXZhaWxfaW49dC5sZW5ndGg7ZG97aWYoZS5uZXh0X291dF9pbmRleD0wLGUuYXZhaWxfb3V0PW4scj1lLmRlZmxhdGUoMCksMCE9cil0aHJvdyBuZXcgRXJyb3IoXCJkZWZsYXRpbmc6IFwiK2UubXNnKTtlLm5leHRfb3V0X2luZGV4JiYoZS5uZXh0X291dF9pbmRleD09bj9kLnB1c2gobmV3IFVpbnQ4QXJyYXkoYSkpOmQucHVzaChhLnNsaWNlKDAsZS5uZXh0X291dF9pbmRleCkpKSxfKz1lLm5leHRfb3V0X2luZGV4LGkmJmUubmV4dF9pbl9pbmRleD4wJiZlLm5leHRfaW5faW5kZXghPW8mJihpKGUubmV4dF9pbl9pbmRleCksbz1lLm5leHRfaW5faW5kZXgpO313aGlsZShlLmF2YWlsX2luPjB8fDA9PT1lLmF2YWlsX291dCk7cmV0dXJuIGQubGVuZ3RoPjE/KHM9bmV3IFVpbnQ4QXJyYXkoXyksZC5mb3JFYWNoKChmdW5jdGlvbih0KXtzLnNldCh0LGwpLGwrPXQubGVuZ3RoO30pKSk6cz1kWzBdfHxuZXcgVWludDhBcnJheSgwKSxzfX0sdGhpcy5mbHVzaD1mdW5jdGlvbigpe2xldCB0LGkscj0wLHM9MDtjb25zdCBvPVtdO2Rve2lmKGUubmV4dF9vdXRfaW5kZXg9MCxlLmF2YWlsX291dD1uLHQ9ZS5kZWZsYXRlKDQpLDEhPXQmJjAhPXQpdGhyb3cgbmV3IEVycm9yKFwiZGVmbGF0aW5nOiBcIitlLm1zZyk7bi1lLmF2YWlsX291dD4wJiZvLnB1c2goYS5zbGljZSgwLGUubmV4dF9vdXRfaW5kZXgpKSxzKz1lLm5leHRfb3V0X2luZGV4O313aGlsZShlLmF2YWlsX2luPjB8fDA9PT1lLmF2YWlsX291dCk7cmV0dXJuIGUuZGVmbGF0ZUVuZCgpLGk9bmV3IFVpbnQ4QXJyYXkocyksby5mb3JFYWNoKChmdW5jdGlvbih0KXtpLnNldCh0LHIpLHIrPXQubGVuZ3RoO30pKSxpfTt9Ti5wcm90b3R5cGU9e2RlZmxhdGVJbml0OmZ1bmN0aW9uKHQsZSl7Y29uc3Qgbj10aGlzO3JldHVybiBuLmRzdGF0ZT1uZXcgSixlfHwoZT0xNSksbi5kc3RhdGUuZGVmbGF0ZUluaXQobix0LGUpfSxkZWZsYXRlOmZ1bmN0aW9uKHQpe2NvbnN0IGU9dGhpcztyZXR1cm4gZS5kc3RhdGU/ZS5kc3RhdGUuZGVmbGF0ZShlLHQpOi0yfSxkZWZsYXRlRW5kOmZ1bmN0aW9uKCl7Y29uc3QgdD10aGlzO2lmKCF0LmRzdGF0ZSlyZXR1cm4gLTI7Y29uc3QgZT10LmRzdGF0ZS5kZWZsYXRlRW5kKCk7cmV0dXJuIHQuZHN0YXRlPW51bGwsZX0sZGVmbGF0ZVBhcmFtczpmdW5jdGlvbih0LGUpe2NvbnN0IG49dGhpcztyZXR1cm4gbi5kc3RhdGU/bi5kc3RhdGUuZGVmbGF0ZVBhcmFtcyhuLHQsZSk6LTJ9LGRlZmxhdGVTZXREaWN0aW9uYXJ5OmZ1bmN0aW9uKHQsZSl7Y29uc3Qgbj10aGlzO3JldHVybiBuLmRzdGF0ZT9uLmRzdGF0ZS5kZWZsYXRlU2V0RGljdGlvbmFyeShuLHQsZSk6LTJ9LHJlYWRfYnVmOmZ1bmN0aW9uKHQsZSxuKXtjb25zdCBpPXRoaXM7bGV0IGE9aS5hdmFpbF9pbjtyZXR1cm4gYT5uJiYoYT1uKSwwPT09YT8wOihpLmF2YWlsX2luLT1hLHQuc2V0KGkubmV4dF9pbi5zdWJhcnJheShpLm5leHRfaW5faW5kZXgsaS5uZXh0X2luX2luZGV4K2EpLGUpLGkubmV4dF9pbl9pbmRleCs9YSxpLnRvdGFsX2luKz1hLGEpfSxmbHVzaF9wZW5kaW5nOmZ1bmN0aW9uKCl7Y29uc3QgdD10aGlzO2xldCBlPXQuZHN0YXRlLnBlbmRpbmc7ZT50LmF2YWlsX291dCYmKGU9dC5hdmFpbF9vdXQpLDAhPT1lJiYodC5uZXh0X291dC5zZXQodC5kc3RhdGUucGVuZGluZ19idWYuc3ViYXJyYXkodC5kc3RhdGUucGVuZGluZ19vdXQsdC5kc3RhdGUucGVuZGluZ19vdXQrZSksdC5uZXh0X291dF9pbmRleCksdC5uZXh0X291dF9pbmRleCs9ZSx0LmRzdGF0ZS5wZW5kaW5nX291dCs9ZSx0LnRvdGFsX291dCs9ZSx0LmF2YWlsX291dC09ZSx0LmRzdGF0ZS5wZW5kaW5nLT1lLDA9PT10LmRzdGF0ZS5wZW5kaW5nJiYodC5kc3RhdGUucGVuZGluZ19vdXQ9MCkpO319O2NvbnN0IFg9WzAsMSwzLDcsMTUsMzEsNjMsMTI3LDI1NSw1MTEsMTAyMywyMDQ3LDQwOTUsODE5MSwxNjM4MywzMjc2Nyw2NTUzNV0sWT1bOTYsNywyNTYsMCw4LDgwLDAsOCwxNiw4NCw4LDExNSw4Miw3LDMxLDAsOCwxMTIsMCw4LDQ4LDAsOSwxOTIsODAsNywxMCwwLDgsOTYsMCw4LDMyLDAsOSwxNjAsMCw4LDAsMCw4LDEyOCwwLDgsNjQsMCw5LDIyNCw4MCw3LDYsMCw4LDg4LDAsOCwyNCwwLDksMTQ0LDgzLDcsNTksMCw4LDEyMCwwLDgsNTYsMCw5LDIwOCw4MSw3LDE3LDAsOCwxMDQsMCw4LDQwLDAsOSwxNzYsMCw4LDgsMCw4LDEzNiwwLDgsNzIsMCw5LDI0MCw4MCw3LDQsMCw4LDg0LDAsOCwyMCw4NSw4LDIyNyw4Myw3LDQzLDAsOCwxMTYsMCw4LDUyLDAsOSwyMDAsODEsNywxMywwLDgsMTAwLDAsOCwzNiwwLDksMTY4LDAsOCw0LDAsOCwxMzIsMCw4LDY4LDAsOSwyMzIsODAsNyw4LDAsOCw5MiwwLDgsMjgsMCw5LDE1Miw4NCw3LDgzLDAsOCwxMjQsMCw4LDYwLDAsOSwyMTYsODIsNywyMywwLDgsMTA4LDAsOCw0NCwwLDksMTg0LDAsOCwxMiwwLDgsMTQwLDAsOCw3NiwwLDksMjQ4LDgwLDcsMywwLDgsODIsMCw4LDE4LDg1LDgsMTYzLDgzLDcsMzUsMCw4LDExNCwwLDgsNTAsMCw5LDE5Niw4MSw3LDExLDAsOCw5OCwwLDgsMzQsMCw5LDE2NCwwLDgsMiwwLDgsMTMwLDAsOCw2NiwwLDksMjI4LDgwLDcsNywwLDgsOTAsMCw4LDI2LDAsOSwxNDgsODQsNyw2NywwLDgsMTIyLDAsOCw1OCwwLDksMjEyLDgyLDcsMTksMCw4LDEwNiwwLDgsNDIsMCw5LDE4MCwwLDgsMTAsMCw4LDEzOCwwLDgsNzQsMCw5LDI0NCw4MCw3LDUsMCw4LDg2LDAsOCwyMiwxOTIsOCwwLDgzLDcsNTEsMCw4LDExOCwwLDgsNTQsMCw5LDIwNCw4MSw3LDE1LDAsOCwxMDIsMCw4LDM4LDAsOSwxNzIsMCw4LDYsMCw4LDEzNCwwLDgsNzAsMCw5LDIzNiw4MCw3LDksMCw4LDk0LDAsOCwzMCwwLDksMTU2LDg0LDcsOTksMCw4LDEyNiwwLDgsNjIsMCw5LDIyMCw4Miw3LDI3LDAsOCwxMTAsMCw4LDQ2LDAsOSwxODgsMCw4LDE0LDAsOCwxNDIsMCw4LDc4LDAsOSwyNTIsOTYsNywyNTYsMCw4LDgxLDAsOCwxNyw4NSw4LDEzMSw4Miw3LDMxLDAsOCwxMTMsMCw4LDQ5LDAsOSwxOTQsODAsNywxMCwwLDgsOTcsMCw4LDMzLDAsOSwxNjIsMCw4LDEsMCw4LDEyOSwwLDgsNjUsMCw5LDIyNiw4MCw3LDYsMCw4LDg5LDAsOCwyNSwwLDksMTQ2LDgzLDcsNTksMCw4LDEyMSwwLDgsNTcsMCw5LDIxMCw4MSw3LDE3LDAsOCwxMDUsMCw4LDQxLDAsOSwxNzgsMCw4LDksMCw4LDEzNywwLDgsNzMsMCw5LDI0Miw4MCw3LDQsMCw4LDg1LDAsOCwyMSw4MCw4LDI1OCw4Myw3LDQzLDAsOCwxMTcsMCw4LDUzLDAsOSwyMDIsODEsNywxMywwLDgsMTAxLDAsOCwzNywwLDksMTcwLDAsOCw1LDAsOCwxMzMsMCw4LDY5LDAsOSwyMzQsODAsNyw4LDAsOCw5MywwLDgsMjksMCw5LDE1NCw4NCw3LDgzLDAsOCwxMjUsMCw4LDYxLDAsOSwyMTgsODIsNywyMywwLDgsMTA5LDAsOCw0NSwwLDksMTg2LDAsOCwxMywwLDgsMTQxLDAsOCw3NywwLDksMjUwLDgwLDcsMywwLDgsODMsMCw4LDE5LDg1LDgsMTk1LDgzLDcsMzUsMCw4LDExNSwwLDgsNTEsMCw5LDE5OCw4MSw3LDExLDAsOCw5OSwwLDgsMzUsMCw5LDE2NiwwLDgsMywwLDgsMTMxLDAsOCw2NywwLDksMjMwLDgwLDcsNywwLDgsOTEsMCw4LDI3LDAsOSwxNTAsODQsNyw2NywwLDgsMTIzLDAsOCw1OSwwLDksMjE0LDgyLDcsMTksMCw4LDEwNywwLDgsNDMsMCw5LDE4MiwwLDgsMTEsMCw4LDEzOSwwLDgsNzUsMCw5LDI0Niw4MCw3LDUsMCw4LDg3LDAsOCwyMywxOTIsOCwwLDgzLDcsNTEsMCw4LDExOSwwLDgsNTUsMCw5LDIwNiw4MSw3LDE1LDAsOCwxMDMsMCw4LDM5LDAsOSwxNzQsMCw4LDcsMCw4LDEzNSwwLDgsNzEsMCw5LDIzOCw4MCw3LDksMCw4LDk1LDAsOCwzMSwwLDksMTU4LDg0LDcsOTksMCw4LDEyNywwLDgsNjMsMCw5LDIyMiw4Miw3LDI3LDAsOCwxMTEsMCw4LDQ3LDAsOSwxOTAsMCw4LDE1LDAsOCwxNDMsMCw4LDc5LDAsOSwyNTQsOTYsNywyNTYsMCw4LDgwLDAsOCwxNiw4NCw4LDExNSw4Miw3LDMxLDAsOCwxMTIsMCw4LDQ4LDAsOSwxOTMsODAsNywxMCwwLDgsOTYsMCw4LDMyLDAsOSwxNjEsMCw4LDAsMCw4LDEyOCwwLDgsNjQsMCw5LDIyNSw4MCw3LDYsMCw4LDg4LDAsOCwyNCwwLDksMTQ1LDgzLDcsNTksMCw4LDEyMCwwLDgsNTYsMCw5LDIwOSw4MSw3LDE3LDAsOCwxMDQsMCw4LDQwLDAsOSwxNzcsMCw4LDgsMCw4LDEzNiwwLDgsNzIsMCw5LDI0MSw4MCw3LDQsMCw4LDg0LDAsOCwyMCw4NSw4LDIyNyw4Myw3LDQzLDAsOCwxMTYsMCw4LDUyLDAsOSwyMDEsODEsNywxMywwLDgsMTAwLDAsOCwzNiwwLDksMTY5LDAsOCw0LDAsOCwxMzIsMCw4LDY4LDAsOSwyMzMsODAsNyw4LDAsOCw5MiwwLDgsMjgsMCw5LDE1Myw4NCw3LDgzLDAsOCwxMjQsMCw4LDYwLDAsOSwyMTcsODIsNywyMywwLDgsMTA4LDAsOCw0NCwwLDksMTg1LDAsOCwxMiwwLDgsMTQwLDAsOCw3NiwwLDksMjQ5LDgwLDcsMywwLDgsODIsMCw4LDE4LDg1LDgsMTYzLDgzLDcsMzUsMCw4LDExNCwwLDgsNTAsMCw5LDE5Nyw4MSw3LDExLDAsOCw5OCwwLDgsMzQsMCw5LDE2NSwwLDgsMiwwLDgsMTMwLDAsOCw2NiwwLDksMjI5LDgwLDcsNywwLDgsOTAsMCw4LDI2LDAsOSwxNDksODQsNyw2NywwLDgsMTIyLDAsOCw1OCwwLDksMjEzLDgyLDcsMTksMCw4LDEwNiwwLDgsNDIsMCw5LDE4MSwwLDgsMTAsMCw4LDEzOCwwLDgsNzQsMCw5LDI0NSw4MCw3LDUsMCw4LDg2LDAsOCwyMiwxOTIsOCwwLDgzLDcsNTEsMCw4LDExOCwwLDgsNTQsMCw5LDIwNSw4MSw3LDE1LDAsOCwxMDIsMCw4LDM4LDAsOSwxNzMsMCw4LDYsMCw4LDEzNCwwLDgsNzAsMCw5LDIzNyw4MCw3LDksMCw4LDk0LDAsOCwzMCwwLDksMTU3LDg0LDcsOTksMCw4LDEyNiwwLDgsNjIsMCw5LDIyMSw4Miw3LDI3LDAsOCwxMTAsMCw4LDQ2LDAsOSwxODksMCw4LDE0LDAsOCwxNDIsMCw4LDc4LDAsOSwyNTMsOTYsNywyNTYsMCw4LDgxLDAsOCwxNyw4NSw4LDEzMSw4Miw3LDMxLDAsOCwxMTMsMCw4LDQ5LDAsOSwxOTUsODAsNywxMCwwLDgsOTcsMCw4LDMzLDAsOSwxNjMsMCw4LDEsMCw4LDEyOSwwLDgsNjUsMCw5LDIyNyw4MCw3LDYsMCw4LDg5LDAsOCwyNSwwLDksMTQ3LDgzLDcsNTksMCw4LDEyMSwwLDgsNTcsMCw5LDIxMSw4MSw3LDE3LDAsOCwxMDUsMCw4LDQxLDAsOSwxNzksMCw4LDksMCw4LDEzNywwLDgsNzMsMCw5LDI0Myw4MCw3LDQsMCw4LDg1LDAsOCwyMSw4MCw4LDI1OCw4Myw3LDQzLDAsOCwxMTcsMCw4LDUzLDAsOSwyMDMsODEsNywxMywwLDgsMTAxLDAsOCwzNywwLDksMTcxLDAsOCw1LDAsOCwxMzMsMCw4LDY5LDAsOSwyMzUsODAsNyw4LDAsOCw5MywwLDgsMjksMCw5LDE1NSw4NCw3LDgzLDAsOCwxMjUsMCw4LDYxLDAsOSwyMTksODIsNywyMywwLDgsMTA5LDAsOCw0NSwwLDksMTg3LDAsOCwxMywwLDgsMTQxLDAsOCw3NywwLDksMjUxLDgwLDcsMywwLDgsODMsMCw4LDE5LDg1LDgsMTk1LDgzLDcsMzUsMCw4LDExNSwwLDgsNTEsMCw5LDE5OSw4MSw3LDExLDAsOCw5OSwwLDgsMzUsMCw5LDE2NywwLDgsMywwLDgsMTMxLDAsOCw2NywwLDksMjMxLDgwLDcsNywwLDgsOTEsMCw4LDI3LDAsOSwxNTEsODQsNyw2NywwLDgsMTIzLDAsOCw1OSwwLDksMjE1LDgyLDcsMTksMCw4LDEwNywwLDgsNDMsMCw5LDE4MywwLDgsMTEsMCw4LDEzOSwwLDgsNzUsMCw5LDI0Nyw4MCw3LDUsMCw4LDg3LDAsOCwyMywxOTIsOCwwLDgzLDcsNTEsMCw4LDExOSwwLDgsNTUsMCw5LDIwNyw4MSw3LDE1LDAsOCwxMDMsMCw4LDM5LDAsOSwxNzUsMCw4LDcsMCw4LDEzNSwwLDgsNzEsMCw5LDIzOSw4MCw3LDksMCw4LDk1LDAsOCwzMSwwLDksMTU5LDg0LDcsOTksMCw4LDEyNywwLDgsNjMsMCw5LDIyMyw4Miw3LDI3LDAsOCwxMTEsMCw4LDQ3LDAsOSwxOTEsMCw4LDE1LDAsOCwxNDMsMCw4LDc5LDAsOSwyNTVdLFo9WzgwLDUsMSw4Nyw1LDI1Nyw4Myw1LDE3LDkxLDUsNDA5Nyw4MSw1LDUsODksNSwxMDI1LDg1LDUsNjUsOTMsNSwxNjM4NSw4MCw1LDMsODgsNSw1MTMsODQsNSwzMyw5Miw1LDgxOTMsODIsNSw5LDkwLDUsMjA0OSw4Niw1LDEyOSwxOTIsNSwyNDU3Nyw4MCw1LDIsODcsNSwzODUsODMsNSwyNSw5MSw1LDYxNDUsODEsNSw3LDg5LDUsMTUzNyw4NSw1LDk3LDkzLDUsMjQ1NzcsODAsNSw0LDg4LDUsNzY5LDg0LDUsNDksOTIsNSwxMjI4OSw4Miw1LDEzLDkwLDUsMzA3Myw4Niw1LDE5MywxOTIsNSwyNDU3N10sJD1bMyw0LDUsNiw3LDgsOSwxMCwxMSwxMywxNSwxNywxOSwyMywyNywzMSwzNSw0Myw1MSw1OSw2Nyw4Myw5OSwxMTUsMTMxLDE2MywxOTUsMjI3LDI1OCwwLDBdLHR0PVswLDAsMCwwLDAsMCwwLDAsMSwxLDEsMSwyLDIsMiwyLDMsMywzLDMsNCw0LDQsNCw1LDUsNSw1LDAsMTEyLDExMl0sZXQ9WzEsMiwzLDQsNSw3LDksMTMsMTcsMjUsMzMsNDksNjUsOTcsMTI5LDE5MywyNTcsMzg1LDUxMyw3NjksMTAyNSwxNTM3LDIwNDksMzA3Myw0MDk3LDYxNDUsODE5MywxMjI4OSwxNjM4NSwyNDU3N10sbnQ9WzAsMCwwLDAsMSwxLDIsMiwzLDMsNCw0LDUsNSw2LDYsNyw3LDgsOCw5LDksMTAsMTAsMTEsMTEsMTIsMTIsMTMsMTNdO2Z1bmN0aW9uIGl0KCl7bGV0IHQsZSxuLGksYSxyO2Z1bmN0aW9uIHModCxlLHMsbyxsLF8sZCxjLGYsdSxoKXtsZXQgYixwLHcseCxnLHksbSxrLHYsQSxVLFMseixJLEU7QT0wLGc9cztkb3tuW3RbZStBXV0rKyxBKyssZy0tO313aGlsZSgwIT09Zyk7aWYoblswXT09cylyZXR1cm4gZFswXT0tMSxjWzBdPTAsMDtmb3Ioaz1jWzBdLHk9MTt5PD0xNSYmMD09PW5beV07eSsrKTtmb3IobT15LGs8eSYmKGs9eSksZz0xNTswIT09ZyYmMD09PW5bZ107Zy0tKTtmb3Iodz1nLGs+ZyYmKGs9ZyksY1swXT1rLEk9MTw8eTt5PGc7eSsrLEk8PD0xKWlmKChJLT1uW3ldKTwwKXJldHVybiAtMztpZigoSS09bltnXSk8MClyZXR1cm4gLTM7Zm9yKG5bZ10rPUksclsxXT15PTAsQT0xLHo9MjswIT0tLWc7KXJbel09eSs9bltBXSx6KyssQSsrO2c9MCxBPTA7ZG97MCE9PSh5PXRbZStBXSkmJihoW3JbeV0rK109ZyksQSsrO313aGlsZSgrK2c8cyk7Zm9yKHM9clt3XSxyWzBdPWc9MCxBPTAseD0tMSxTPS1rLGFbMF09MCxVPTAsRT0wO208PXc7bSsrKWZvcihiPW5bbV07MCE9Yi0tOyl7Zm9yKDttPlMrazspe2lmKHgrKyxTKz1rLEU9dy1TLEU9RT5rP2s6RSwocD0xPDwoeT1tLVMpKT5iKzEmJihwLT1iKzEsej1tLHk8RSkpZm9yKDsrK3k8RSYmISgocDw8PTEpPD1uWysrel0pOylwLT1uW3pdO2lmKEU9MTw8eSx1WzBdK0U+MTQ0MClyZXR1cm4gLTM7YVt4XT1VPXVbMF0sdVswXSs9RSwwIT09eD8oclt4XT1nLGlbMF09eSxpWzFdPWsseT1nPj4+Uy1rLGlbMl09VS1hW3gtMV0teSxmLnNldChpLDMqKGFbeC0xXSt5KSkpOmRbMF09VTt9Zm9yKGlbMV09bS1TLEE+PXM/aVswXT0xOTI6aFtBXTxvPyhpWzBdPWhbQV08MjU2PzA6OTYsaVsyXT1oW0ErK10pOihpWzBdPV9baFtBXS1vXSsxNis2NCxpWzJdPWxbaFtBKytdLW9dKSxwPTE8PG0tUyx5PWc+Pj5TO3k8RTt5Kz1wKWYuc2V0KGksMyooVSt5KSk7Zm9yKHk9MTw8bS0xOzAhPShnJnkpO3k+Pj49MSlnXj15O2ZvcihnXj15LHY9KDE8PFMpLTE7KGcmdikhPXJbeF07KXgtLSxTLT1rLHY9KDE8PFMpLTE7fXJldHVybiAwIT09SSYmMSE9dz8tNTowfWZ1bmN0aW9uIG8ocyl7bGV0IG87Zm9yKHR8fCh0PVtdLGU9W10sbj1uZXcgSW50MzJBcnJheSgxNiksaT1bXSxhPW5ldyBJbnQzMkFycmF5KDE1KSxyPW5ldyBJbnQzMkFycmF5KDE2KSksZS5sZW5ndGg8cyYmKGU9W10pLG89MDtvPHM7bysrKWVbb109MDtmb3Iobz0wO288MTY7bysrKW5bb109MDtmb3Iobz0wO288MztvKyspaVtvXT0wO2Euc2V0KG4uc3ViYXJyYXkoMCwxNSksMCksci5zZXQobi5zdWJhcnJheSgwLDE2KSwwKTt9dGhpcy5pbmZsYXRlX3RyZWVzX2JpdHM9ZnVuY3Rpb24obixpLGEscixsKXtsZXQgXztyZXR1cm4gbygxOSksdFswXT0wLF89cyhuLDAsMTksMTksbnVsbCxudWxsLGEsaSxyLHQsZSksLTM9PV8/bC5tc2c9XCJvdmVyc3Vic2NyaWJlZCBkeW5hbWljIGJpdCBsZW5ndGhzIHRyZWVcIjotNSE9XyYmMCE9PWlbMF18fChsLm1zZz1cImluY29tcGxldGUgZHluYW1pYyBiaXQgbGVuZ3RocyB0cmVlXCIsXz0tMyksX30sdGhpcy5pbmZsYXRlX3RyZWVzX2R5bmFtaWM9ZnVuY3Rpb24obixpLGEscixsLF8sZCxjLGYpe2xldCB1O3JldHVybiBvKDI4OCksdFswXT0wLHU9cyhhLDAsbiwyNTcsJCx0dCxfLHIsYyx0LGUpLDAhPXV8fDA9PT1yWzBdPygtMz09dT9mLm1zZz1cIm92ZXJzdWJzY3JpYmVkIGxpdGVyYWwvbGVuZ3RoIHRyZWVcIjotNCE9dSYmKGYubXNnPVwiaW5jb21wbGV0ZSBsaXRlcmFsL2xlbmd0aCB0cmVlXCIsdT0tMyksdSk6KG8oMjg4KSx1PXMoYSxuLGksMCxldCxudCxkLGwsYyx0LGUpLDAhPXV8fDA9PT1sWzBdJiZuPjI1Nz8oLTM9PXU/Zi5tc2c9XCJvdmVyc3Vic2NyaWJlZCBkaXN0YW5jZSB0cmVlXCI6LTU9PXU/KGYubXNnPVwiaW5jb21wbGV0ZSBkaXN0YW5jZSB0cmVlXCIsdT0tMyk6LTQhPXUmJihmLm1zZz1cImVtcHR5IGRpc3RhbmNlIHRyZWUgd2l0aCBsZW5ndGhzXCIsdT0tMyksdSk6MCl9O31mdW5jdGlvbiBhdCgpe2NvbnN0IHQ9dGhpcztsZXQgZSxuLGksYSxyPTAscz0wLG89MCxsPTAsXz0wLGQ9MCxjPTAsZj0wLHU9MCxoPTA7ZnVuY3Rpb24gYih0LGUsbixpLGEscixzLG8pe2xldCBsLF8sZCxjLGYsdSxoLGIscCx3LHgsZyx5LG0sayx2O2g9by5uZXh0X2luX2luZGV4LGI9by5hdmFpbF9pbixmPXMuYml0Yix1PXMuYml0ayxwPXMud3JpdGUsdz1wPHMucmVhZD9zLnJlYWQtcC0xOnMuZW5kLXAseD1YW3RdLGc9WFtlXTtkb3tmb3IoO3U8MjA7KWItLSxmfD0oMjU1Jm8ucmVhZF9ieXRlKGgrKykpPDx1LHUrPTg7aWYobD1mJngsXz1uLGQ9aSx2PTMqKGQrbCksMCE9PShjPV9bdl0pKWZvcig7Oyl7aWYoZj4+PV9bdisxXSx1LT1fW3YrMV0sMCE9KDE2JmMpKXtmb3IoYyY9MTUseT1fW3YrMl0rKGYmWFtjXSksZj4+PWMsdS09Yzt1PDE1OyliLS0sZnw9KDI1NSZvLnJlYWRfYnl0ZShoKyspKTw8dSx1Kz04O2ZvcihsPWYmZyxfPWEsZD1yLHY9MyooZCtsKSxjPV9bdl07Oyl7aWYoZj4+PV9bdisxXSx1LT1fW3YrMV0sMCE9KDE2JmMpKXtmb3IoYyY9MTU7dTxjOyliLS0sZnw9KDI1NSZvLnJlYWRfYnl0ZShoKyspKTw8dSx1Kz04O2lmKG09X1t2KzJdKyhmJlhbY10pLGY+Pj1jLHUtPWMsdy09eSxwPj1tKWs9cC1tLHAtaz4wJiYyPnAtaz8ocy53aW5kb3dbcCsrXT1zLndpbmRvd1trKytdLHMud2luZG93W3ArK109cy53aW5kb3dbaysrXSx5LT0yKToocy53aW5kb3cuc2V0KHMud2luZG93LnN1YmFycmF5KGssaysyKSxwKSxwKz0yLGsrPTIseS09Mik7ZWxzZSB7az1wLW07ZG97ays9cy5lbmQ7fXdoaWxlKGs8MCk7aWYoYz1zLmVuZC1rLHk+Yyl7aWYoeS09YyxwLWs+MCYmYz5wLWspZG97cy53aW5kb3dbcCsrXT1zLndpbmRvd1trKytdO313aGlsZSgwIT0tLWMpO2Vsc2Ugcy53aW5kb3cuc2V0KHMud2luZG93LnN1YmFycmF5KGssaytjKSxwKSxwKz1jLGsrPWMsYz0wO2s9MDt9fWlmKHAtaz4wJiZ5PnAtaylkb3tzLndpbmRvd1twKytdPXMud2luZG93W2srK107fXdoaWxlKDAhPS0teSk7ZWxzZSBzLndpbmRvdy5zZXQocy53aW5kb3cuc3ViYXJyYXkoayxrK3kpLHApLHArPXksays9eSx5PTA7YnJlYWt9aWYoMCE9KDY0JmMpKXJldHVybiBvLm1zZz1cImludmFsaWQgZGlzdGFuY2UgY29kZVwiLHk9by5hdmFpbF9pbi1iLHk9dT4+Mzx5P3U+PjM6eSxiKz15LGgtPXksdS09eTw8MyxzLmJpdGI9ZixzLmJpdGs9dSxvLmF2YWlsX2luPWIsby50b3RhbF9pbis9aC1vLm5leHRfaW5faW5kZXgsby5uZXh0X2luX2luZGV4PWgscy53cml0ZT1wLC0zO2wrPV9bdisyXSxsKz1mJlhbY10sdj0zKihkK2wpLGM9X1t2XTt9YnJlYWt9aWYoMCE9KDY0JmMpKXJldHVybiAwIT0oMzImYyk/KHk9by5hdmFpbF9pbi1iLHk9dT4+Mzx5P3U+PjM6eSxiKz15LGgtPXksdS09eTw8MyxzLmJpdGI9ZixzLmJpdGs9dSxvLmF2YWlsX2luPWIsby50b3RhbF9pbis9aC1vLm5leHRfaW5faW5kZXgsby5uZXh0X2luX2luZGV4PWgscy53cml0ZT1wLDEpOihvLm1zZz1cImludmFsaWQgbGl0ZXJhbC9sZW5ndGggY29kZVwiLHk9by5hdmFpbF9pbi1iLHk9dT4+Mzx5P3U+PjM6eSxiKz15LGgtPXksdS09eTw8MyxzLmJpdGI9ZixzLmJpdGs9dSxvLmF2YWlsX2luPWIsby50b3RhbF9pbis9aC1vLm5leHRfaW5faW5kZXgsby5uZXh0X2luX2luZGV4PWgscy53cml0ZT1wLC0zKTtpZihsKz1fW3YrMl0sbCs9ZiZYW2NdLHY9MyooZCtsKSwwPT09KGM9X1t2XSkpe2Y+Pj1fW3YrMV0sdS09X1t2KzFdLHMud2luZG93W3ArK109X1t2KzJdLHctLTticmVha319ZWxzZSBmPj49X1t2KzFdLHUtPV9bdisxXSxzLndpbmRvd1twKytdPV9bdisyXSx3LS07fXdoaWxlKHc+PTI1OCYmYj49MTApO3JldHVybiB5PW8uYXZhaWxfaW4tYix5PXU+PjM8eT91Pj4zOnksYis9eSxoLT15LHUtPXk8PDMscy5iaXRiPWYscy5iaXRrPXUsby5hdmFpbF9pbj1iLG8udG90YWxfaW4rPWgtby5uZXh0X2luX2luZGV4LG8ubmV4dF9pbl9pbmRleD1oLHMud3JpdGU9cCwwfXQuaW5pdD1mdW5jdGlvbih0LHIscyxvLGwsXyl7ZT0wLGM9dCxmPXIsaT1zLHU9byxhPWwsaD1fLG49bnVsbDt9LHQucHJvYz1mdW5jdGlvbih0LHAsdyl7bGV0IHgsZyx5LG0sayx2LEEsVT0wLFM9MCx6PTA7Zm9yKHo9cC5uZXh0X2luX2luZGV4LG09cC5hdmFpbF9pbixVPXQuYml0YixTPXQuYml0ayxrPXQud3JpdGUsdj1rPHQucmVhZD90LnJlYWQtay0xOnQuZW5kLWs7Oylzd2l0Y2goZSl7Y2FzZSAwOmlmKHY+PTI1OCYmbT49MTAmJih0LmJpdGI9VSx0LmJpdGs9UyxwLmF2YWlsX2luPW0scC50b3RhbF9pbis9ei1wLm5leHRfaW5faW5kZXgscC5uZXh0X2luX2luZGV4PXosdC53cml0ZT1rLHc9YihjLGYsaSx1LGEsaCx0LHApLHo9cC5uZXh0X2luX2luZGV4LG09cC5hdmFpbF9pbixVPXQuYml0YixTPXQuYml0ayxrPXQud3JpdGUsdj1rPHQucmVhZD90LnJlYWQtay0xOnQuZW5kLWssMCE9dykpe2U9MT09dz83Ojk7YnJlYWt9bz1jLG49aSxzPXUsZT0xO2Nhc2UgMTpmb3IoeD1vO1M8eDspe2lmKDA9PT1tKXJldHVybiB0LmJpdGI9VSx0LmJpdGs9UyxwLmF2YWlsX2luPW0scC50b3RhbF9pbis9ei1wLm5leHRfaW5faW5kZXgscC5uZXh0X2luX2luZGV4PXosdC53cml0ZT1rLHQuaW5mbGF0ZV9mbHVzaChwLHcpO3c9MCxtLS0sVXw9KDI1NSZwLnJlYWRfYnl0ZSh6KyspKTw8UyxTKz04O31pZihnPTMqKHMrKFUmWFt4XSkpLFU+Pj49bltnKzFdLFMtPW5bZysxXSx5PW5bZ10sMD09PXkpe2w9bltnKzJdLGU9NjticmVha31pZigwIT0oMTYmeSkpe189MTUmeSxyPW5bZysyXSxlPTI7YnJlYWt9aWYoMD09KDY0JnkpKXtvPXkscz1nLzMrbltnKzJdO2JyZWFrfWlmKDAhPSgzMiZ5KSl7ZT03O2JyZWFrfXJldHVybiBlPTkscC5tc2c9XCJpbnZhbGlkIGxpdGVyYWwvbGVuZ3RoIGNvZGVcIix3PS0zLHQuYml0Yj1VLHQuYml0az1TLHAuYXZhaWxfaW49bSxwLnRvdGFsX2luKz16LXAubmV4dF9pbl9pbmRleCxwLm5leHRfaW5faW5kZXg9eix0LndyaXRlPWssdC5pbmZsYXRlX2ZsdXNoKHAsdyk7Y2FzZSAyOmZvcih4PV87Uzx4Oyl7aWYoMD09PW0pcmV0dXJuIHQuYml0Yj1VLHQuYml0az1TLHAuYXZhaWxfaW49bSxwLnRvdGFsX2luKz16LXAubmV4dF9pbl9pbmRleCxwLm5leHRfaW5faW5kZXg9eix0LndyaXRlPWssdC5pbmZsYXRlX2ZsdXNoKHAsdyk7dz0wLG0tLSxVfD0oMjU1JnAucmVhZF9ieXRlKHorKykpPDxTLFMrPTg7fXIrPVUmWFt4XSxVPj49eCxTLT14LG89ZixuPWEscz1oLGU9MztjYXNlIDM6Zm9yKHg9bztTPHg7KXtpZigwPT09bSlyZXR1cm4gdC5iaXRiPVUsdC5iaXRrPVMscC5hdmFpbF9pbj1tLHAudG90YWxfaW4rPXotcC5uZXh0X2luX2luZGV4LHAubmV4dF9pbl9pbmRleD16LHQud3JpdGU9ayx0LmluZmxhdGVfZmx1c2gocCx3KTt3PTAsbS0tLFV8PSgyNTUmcC5yZWFkX2J5dGUoeisrKSk8PFMsUys9ODt9aWYoZz0zKihzKyhVJlhbeF0pKSxVPj49bltnKzFdLFMtPW5bZysxXSx5PW5bZ10sMCE9KDE2JnkpKXtfPTE1JnksZD1uW2crMl0sZT00O2JyZWFrfWlmKDA9PSg2NCZ5KSl7bz15LHM9Zy8zK25bZysyXTticmVha31yZXR1cm4gZT05LHAubXNnPVwiaW52YWxpZCBkaXN0YW5jZSBjb2RlXCIsdz0tMyx0LmJpdGI9VSx0LmJpdGs9UyxwLmF2YWlsX2luPW0scC50b3RhbF9pbis9ei1wLm5leHRfaW5faW5kZXgscC5uZXh0X2luX2luZGV4PXosdC53cml0ZT1rLHQuaW5mbGF0ZV9mbHVzaChwLHcpO2Nhc2UgNDpmb3IoeD1fO1M8eDspe2lmKDA9PT1tKXJldHVybiB0LmJpdGI9VSx0LmJpdGs9UyxwLmF2YWlsX2luPW0scC50b3RhbF9pbis9ei1wLm5leHRfaW5faW5kZXgscC5uZXh0X2luX2luZGV4PXosdC53cml0ZT1rLHQuaW5mbGF0ZV9mbHVzaChwLHcpO3c9MCxtLS0sVXw9KDI1NSZwLnJlYWRfYnl0ZSh6KyspKTw8UyxTKz04O31kKz1VJlhbeF0sVT4+PXgsUy09eCxlPTU7Y2FzZSA1OmZvcihBPWstZDtBPDA7KUErPXQuZW5kO2Zvcig7MCE9PXI7KXtpZigwPT09diYmKGs9PXQuZW5kJiYwIT09dC5yZWFkJiYoaz0wLHY9azx0LnJlYWQ/dC5yZWFkLWstMTp0LmVuZC1rKSwwPT09diYmKHQud3JpdGU9ayx3PXQuaW5mbGF0ZV9mbHVzaChwLHcpLGs9dC53cml0ZSx2PWs8dC5yZWFkP3QucmVhZC1rLTE6dC5lbmQtayxrPT10LmVuZCYmMCE9PXQucmVhZCYmKGs9MCx2PWs8dC5yZWFkP3QucmVhZC1rLTE6dC5lbmQtayksMD09PXYpKSlyZXR1cm4gdC5iaXRiPVUsdC5iaXRrPVMscC5hdmFpbF9pbj1tLHAudG90YWxfaW4rPXotcC5uZXh0X2luX2luZGV4LHAubmV4dF9pbl9pbmRleD16LHQud3JpdGU9ayx0LmluZmxhdGVfZmx1c2gocCx3KTt0LndpbmRvd1trKytdPXQud2luZG93W0ErK10sdi0tLEE9PXQuZW5kJiYoQT0wKSxyLS07fWU9MDticmVhaztjYXNlIDY6aWYoMD09PXYmJihrPT10LmVuZCYmMCE9PXQucmVhZCYmKGs9MCx2PWs8dC5yZWFkP3QucmVhZC1rLTE6dC5lbmQtayksMD09PXYmJih0LndyaXRlPWssdz10LmluZmxhdGVfZmx1c2gocCx3KSxrPXQud3JpdGUsdj1rPHQucmVhZD90LnJlYWQtay0xOnQuZW5kLWssaz09dC5lbmQmJjAhPT10LnJlYWQmJihrPTAsdj1rPHQucmVhZD90LnJlYWQtay0xOnQuZW5kLWspLDA9PT12KSkpcmV0dXJuIHQuYml0Yj1VLHQuYml0az1TLHAuYXZhaWxfaW49bSxwLnRvdGFsX2luKz16LXAubmV4dF9pbl9pbmRleCxwLm5leHRfaW5faW5kZXg9eix0LndyaXRlPWssdC5pbmZsYXRlX2ZsdXNoKHAsdyk7dz0wLHQud2luZG93W2srK109bCx2LS0sZT0wO2JyZWFrO2Nhc2UgNzppZihTPjcmJihTLT04LG0rKyx6LS0pLHQud3JpdGU9ayx3PXQuaW5mbGF0ZV9mbHVzaChwLHcpLGs9dC53cml0ZSx2PWs8dC5yZWFkP3QucmVhZC1rLTE6dC5lbmQtayx0LnJlYWQhPXQud3JpdGUpcmV0dXJuIHQuYml0Yj1VLHQuYml0az1TLHAuYXZhaWxfaW49bSxwLnRvdGFsX2luKz16LXAubmV4dF9pbl9pbmRleCxwLm5leHRfaW5faW5kZXg9eix0LndyaXRlPWssdC5pbmZsYXRlX2ZsdXNoKHAsdyk7ZT04O2Nhc2UgODpyZXR1cm4gdz0xLHQuYml0Yj1VLHQuYml0az1TLHAuYXZhaWxfaW49bSxwLnRvdGFsX2luKz16LXAubmV4dF9pbl9pbmRleCxwLm5leHRfaW5faW5kZXg9eix0LndyaXRlPWssdC5pbmZsYXRlX2ZsdXNoKHAsdyk7Y2FzZSA5OnJldHVybiB3PS0zLHQuYml0Yj1VLHQuYml0az1TLHAuYXZhaWxfaW49bSxwLnRvdGFsX2luKz16LXAubmV4dF9pbl9pbmRleCxwLm5leHRfaW5faW5kZXg9eix0LndyaXRlPWssdC5pbmZsYXRlX2ZsdXNoKHAsdyk7ZGVmYXVsdDpyZXR1cm4gdz0tMix0LmJpdGI9VSx0LmJpdGs9UyxwLmF2YWlsX2luPW0scC50b3RhbF9pbis9ei1wLm5leHRfaW5faW5kZXgscC5uZXh0X2luX2luZGV4PXosdC53cml0ZT1rLHQuaW5mbGF0ZV9mbHVzaChwLHcpfX0sdC5mcmVlPWZ1bmN0aW9uKCl7fTt9aXQuaW5mbGF0ZV90cmVlc19maXhlZD1mdW5jdGlvbih0LGUsbixpKXtyZXR1cm4gdFswXT05LGVbMF09NSxuWzBdPVksaVswXT1aLDB9O2NvbnN0IHJ0PVsxNiwxNywxOCwwLDgsNyw5LDYsMTAsNSwxMSw0LDEyLDMsMTMsMiwxNCwxLDE1XTtmdW5jdGlvbiBzdCh0LGUpe2NvbnN0IG49dGhpcztsZXQgaSxhPTAscj0wLHM9MCxvPTA7Y29uc3QgbD1bMF0sXz1bMF0sZD1uZXcgYXQ7bGV0IGM9MCxmPW5ldyBJbnQzMkFycmF5KDQzMjApO2NvbnN0IHU9bmV3IGl0O24uYml0az0wLG4uYml0Yj0wLG4ud2luZG93PW5ldyBVaW50OEFycmF5KGUpLG4uZW5kPWUsbi5yZWFkPTAsbi53cml0ZT0wLG4ucmVzZXQ9ZnVuY3Rpb24odCxlKXtlJiYoZVswXT0wKSw2PT1hJiZkLmZyZWUodCksYT0wLG4uYml0az0wLG4uYml0Yj0wLG4ucmVhZD1uLndyaXRlPTA7fSxuLnJlc2V0KHQsbnVsbCksbi5pbmZsYXRlX2ZsdXNoPWZ1bmN0aW9uKHQsZSl7bGV0IGksYSxyO3JldHVybiBhPXQubmV4dF9vdXRfaW5kZXgscj1uLnJlYWQsaT0ocjw9bi53cml0ZT9uLndyaXRlOm4uZW5kKS1yLGk+dC5hdmFpbF9vdXQmJihpPXQuYXZhaWxfb3V0KSwwIT09aSYmLTU9PWUmJihlPTApLHQuYXZhaWxfb3V0LT1pLHQudG90YWxfb3V0Kz1pLHQubmV4dF9vdXQuc2V0KG4ud2luZG93LnN1YmFycmF5KHIscitpKSxhKSxhKz1pLHIrPWkscj09bi5lbmQmJihyPTAsbi53cml0ZT09bi5lbmQmJihuLndyaXRlPTApLGk9bi53cml0ZS1yLGk+dC5hdmFpbF9vdXQmJihpPXQuYXZhaWxfb3V0KSwwIT09aSYmLTU9PWUmJihlPTApLHQuYXZhaWxfb3V0LT1pLHQudG90YWxfb3V0Kz1pLHQubmV4dF9vdXQuc2V0KG4ud2luZG93LnN1YmFycmF5KHIscitpKSxhKSxhKz1pLHIrPWkpLHQubmV4dF9vdXRfaW5kZXg9YSxuLnJlYWQ9cixlfSxuLnByb2M9ZnVuY3Rpb24odCxlKXtsZXQgaCxiLHAsdyx4LGcseSxtO2Zvcih3PXQubmV4dF9pbl9pbmRleCx4PXQuYXZhaWxfaW4sYj1uLmJpdGIscD1uLmJpdGssZz1uLndyaXRlLHk9ZzxuLnJlYWQ/bi5yZWFkLWctMTpuLmVuZC1nOzspe2xldCBrLHYsQSxVLFMseixJLEU7c3dpdGNoKGEpe2Nhc2UgMDpmb3IoO3A8Mzspe2lmKDA9PT14KXJldHVybiBuLmJpdGI9YixuLmJpdGs9cCx0LmF2YWlsX2luPXgsdC50b3RhbF9pbis9dy10Lm5leHRfaW5faW5kZXgsdC5uZXh0X2luX2luZGV4PXcsbi53cml0ZT1nLG4uaW5mbGF0ZV9mbHVzaCh0LGUpO2U9MCx4LS0sYnw9KDI1NSZ0LnJlYWRfYnl0ZSh3KyspKTw8cCxwKz04O31zd2l0Y2goaD03JmIsYz0xJmgsaD4+PjEpe2Nhc2UgMDpiPj4+PTMscC09MyxoPTcmcCxiPj4+PWgscC09aCxhPTE7YnJlYWs7Y2FzZSAxOms9W10sdj1bXSxBPVtbXV0sVT1bW11dLGl0LmluZmxhdGVfdHJlZXNfZml4ZWQoayx2LEEsVSksZC5pbml0KGtbMF0sdlswXSxBWzBdLDAsVVswXSwwKSxiPj4+PTMscC09MyxhPTY7YnJlYWs7Y2FzZSAyOmI+Pj49MyxwLT0zLGE9MzticmVhaztjYXNlIDM6cmV0dXJuIGI+Pj49MyxwLT0zLGE9OSx0Lm1zZz1cImludmFsaWQgYmxvY2sgdHlwZVwiLGU9LTMsbi5iaXRiPWIsbi5iaXRrPXAsdC5hdmFpbF9pbj14LHQudG90YWxfaW4rPXctdC5uZXh0X2luX2luZGV4LHQubmV4dF9pbl9pbmRleD13LG4ud3JpdGU9ZyxuLmluZmxhdGVfZmx1c2godCxlKX1icmVhaztjYXNlIDE6Zm9yKDtwPDMyOyl7aWYoMD09PXgpcmV0dXJuIG4uYml0Yj1iLG4uYml0az1wLHQuYXZhaWxfaW49eCx0LnRvdGFsX2luKz13LXQubmV4dF9pbl9pbmRleCx0Lm5leHRfaW5faW5kZXg9dyxuLndyaXRlPWcsbi5pbmZsYXRlX2ZsdXNoKHQsZSk7ZT0wLHgtLSxifD0oMjU1JnQucmVhZF9ieXRlKHcrKykpPDxwLHArPTg7fWlmKCh+Yj4+PjE2JjY1NTM1KSE9KDY1NTM1JmIpKXJldHVybiBhPTksdC5tc2c9XCJpbnZhbGlkIHN0b3JlZCBibG9jayBsZW5ndGhzXCIsZT0tMyxuLmJpdGI9YixuLmJpdGs9cCx0LmF2YWlsX2luPXgsdC50b3RhbF9pbis9dy10Lm5leHRfaW5faW5kZXgsdC5uZXh0X2luX2luZGV4PXcsbi53cml0ZT1nLG4uaW5mbGF0ZV9mbHVzaCh0LGUpO3I9NjU1MzUmYixiPXA9MCxhPTAhPT1yPzI6MCE9PWM/NzowO2JyZWFrO2Nhc2UgMjppZigwPT09eClyZXR1cm4gbi5iaXRiPWIsbi5iaXRrPXAsdC5hdmFpbF9pbj14LHQudG90YWxfaW4rPXctdC5uZXh0X2luX2luZGV4LHQubmV4dF9pbl9pbmRleD13LG4ud3JpdGU9ZyxuLmluZmxhdGVfZmx1c2godCxlKTtpZigwPT09eSYmKGc9PW4uZW5kJiYwIT09bi5yZWFkJiYoZz0wLHk9ZzxuLnJlYWQ/bi5yZWFkLWctMTpuLmVuZC1nKSwwPT09eSYmKG4ud3JpdGU9ZyxlPW4uaW5mbGF0ZV9mbHVzaCh0LGUpLGc9bi53cml0ZSx5PWc8bi5yZWFkP24ucmVhZC1nLTE6bi5lbmQtZyxnPT1uLmVuZCYmMCE9PW4ucmVhZCYmKGc9MCx5PWc8bi5yZWFkP24ucmVhZC1nLTE6bi5lbmQtZyksMD09PXkpKSlyZXR1cm4gbi5iaXRiPWIsbi5iaXRrPXAsdC5hdmFpbF9pbj14LHQudG90YWxfaW4rPXctdC5uZXh0X2luX2luZGV4LHQubmV4dF9pbl9pbmRleD13LG4ud3JpdGU9ZyxuLmluZmxhdGVfZmx1c2godCxlKTtpZihlPTAsaD1yLGg+eCYmKGg9eCksaD55JiYoaD15KSxuLndpbmRvdy5zZXQodC5yZWFkX2J1Zih3LGgpLGcpLHcrPWgseC09aCxnKz1oLHktPWgsMCE9KHItPWgpKWJyZWFrO2E9MCE9PWM/NzowO2JyZWFrO2Nhc2UgMzpmb3IoO3A8MTQ7KXtpZigwPT09eClyZXR1cm4gbi5iaXRiPWIsbi5iaXRrPXAsdC5hdmFpbF9pbj14LHQudG90YWxfaW4rPXctdC5uZXh0X2luX2luZGV4LHQubmV4dF9pbl9pbmRleD13LG4ud3JpdGU9ZyxuLmluZmxhdGVfZmx1c2godCxlKTtlPTAseC0tLGJ8PSgyNTUmdC5yZWFkX2J5dGUodysrKSk8PHAscCs9ODt9aWYocz1oPTE2MzgzJmIsKDMxJmgpPjI5fHwoaD4+NSYzMSk+MjkpcmV0dXJuIGE9OSx0Lm1zZz1cInRvbyBtYW55IGxlbmd0aCBvciBkaXN0YW5jZSBzeW1ib2xzXCIsZT0tMyxuLmJpdGI9YixuLmJpdGs9cCx0LmF2YWlsX2luPXgsdC50b3RhbF9pbis9dy10Lm5leHRfaW5faW5kZXgsdC5uZXh0X2luX2luZGV4PXcsbi53cml0ZT1nLG4uaW5mbGF0ZV9mbHVzaCh0LGUpO2lmKGg9MjU4KygzMSZoKSsoaD4+NSYzMSksIWl8fGkubGVuZ3RoPGgpaT1bXTtlbHNlIGZvcihtPTA7bTxoO20rKylpW21dPTA7Yj4+Pj0xNCxwLT0xNCxvPTAsYT00O2Nhc2UgNDpmb3IoO288NCsocz4+PjEwKTspe2Zvcig7cDwzOyl7aWYoMD09PXgpcmV0dXJuIG4uYml0Yj1iLG4uYml0az1wLHQuYXZhaWxfaW49eCx0LnRvdGFsX2luKz13LXQubmV4dF9pbl9pbmRleCx0Lm5leHRfaW5faW5kZXg9dyxuLndyaXRlPWcsbi5pbmZsYXRlX2ZsdXNoKHQsZSk7ZT0wLHgtLSxifD0oMjU1JnQucmVhZF9ieXRlKHcrKykpPDxwLHArPTg7fWlbcnRbbysrXV09NyZiLGI+Pj49MyxwLT0zO31mb3IoO288MTk7KWlbcnRbbysrXV09MDtpZihsWzBdPTcsaD11LmluZmxhdGVfdHJlZXNfYml0cyhpLGwsXyxmLHQpLDAhPWgpcmV0dXJuIC0zPT0oZT1oKSYmKGk9bnVsbCxhPTkpLG4uYml0Yj1iLG4uYml0az1wLHQuYXZhaWxfaW49eCx0LnRvdGFsX2luKz13LXQubmV4dF9pbl9pbmRleCx0Lm5leHRfaW5faW5kZXg9dyxuLndyaXRlPWcsbi5pbmZsYXRlX2ZsdXNoKHQsZSk7bz0wLGE9NTtjYXNlIDU6Zm9yKDtoPXMsIShvPj0yNTgrKDMxJmgpKyhoPj41JjMxKSk7KXtsZXQgcixkO2ZvcihoPWxbMF07cDxoOyl7aWYoMD09PXgpcmV0dXJuIG4uYml0Yj1iLG4uYml0az1wLHQuYXZhaWxfaW49eCx0LnRvdGFsX2luKz13LXQubmV4dF9pbl9pbmRleCx0Lm5leHRfaW5faW5kZXg9dyxuLndyaXRlPWcsbi5pbmZsYXRlX2ZsdXNoKHQsZSk7ZT0wLHgtLSxifD0oMjU1JnQucmVhZF9ieXRlKHcrKykpPDxwLHArPTg7fWlmKGg9ZlszKihfWzBdKyhiJlhbaF0pKSsxXSxkPWZbMyooX1swXSsoYiZYW2hdKSkrMl0sZDwxNiliPj4+PWgscC09aCxpW28rK109ZDtlbHNlIHtmb3IobT0xOD09ZD83OmQtMTQscj0xOD09ZD8xMTozO3A8aCttOyl7aWYoMD09PXgpcmV0dXJuIG4uYml0Yj1iLG4uYml0az1wLHQuYXZhaWxfaW49eCx0LnRvdGFsX2luKz13LXQubmV4dF9pbl9pbmRleCx0Lm5leHRfaW5faW5kZXg9dyxuLndyaXRlPWcsbi5pbmZsYXRlX2ZsdXNoKHQsZSk7ZT0wLHgtLSxifD0oMjU1JnQucmVhZF9ieXRlKHcrKykpPDxwLHArPTg7fWlmKGI+Pj49aCxwLT1oLHIrPWImWFttXSxiPj4+PW0scC09bSxtPW8saD1zLG0rcj4yNTgrKDMxJmgpKyhoPj41JjMxKXx8MTY9PWQmJm08MSlyZXR1cm4gaT1udWxsLGE9OSx0Lm1zZz1cImludmFsaWQgYml0IGxlbmd0aCByZXBlYXRcIixlPS0zLG4uYml0Yj1iLG4uYml0az1wLHQuYXZhaWxfaW49eCx0LnRvdGFsX2luKz13LXQubmV4dF9pbl9pbmRleCx0Lm5leHRfaW5faW5kZXg9dyxuLndyaXRlPWcsbi5pbmZsYXRlX2ZsdXNoKHQsZSk7ZD0xNj09ZD9pW20tMV06MDtkb3tpW20rK109ZDt9d2hpbGUoMCE9LS1yKTtvPW07fX1pZihfWzBdPS0xLFM9W10sej1bXSxJPVtdLEU9W10sU1swXT05LHpbMF09NixoPXMsaD11LmluZmxhdGVfdHJlZXNfZHluYW1pYygyNTcrKDMxJmgpLDErKGg+PjUmMzEpLGksUyx6LEksRSxmLHQpLDAhPWgpcmV0dXJuIC0zPT1oJiYoaT1udWxsLGE9OSksZT1oLG4uYml0Yj1iLG4uYml0az1wLHQuYXZhaWxfaW49eCx0LnRvdGFsX2luKz13LXQubmV4dF9pbl9pbmRleCx0Lm5leHRfaW5faW5kZXg9dyxuLndyaXRlPWcsbi5pbmZsYXRlX2ZsdXNoKHQsZSk7ZC5pbml0KFNbMF0selswXSxmLElbMF0sZixFWzBdKSxhPTY7Y2FzZSA2OmlmKG4uYml0Yj1iLG4uYml0az1wLHQuYXZhaWxfaW49eCx0LnRvdGFsX2luKz13LXQubmV4dF9pbl9pbmRleCx0Lm5leHRfaW5faW5kZXg9dyxuLndyaXRlPWcsMSE9KGU9ZC5wcm9jKG4sdCxlKSkpcmV0dXJuIG4uaW5mbGF0ZV9mbHVzaCh0LGUpO2lmKGU9MCxkLmZyZWUodCksdz10Lm5leHRfaW5faW5kZXgseD10LmF2YWlsX2luLGI9bi5iaXRiLHA9bi5iaXRrLGc9bi53cml0ZSx5PWc8bi5yZWFkP24ucmVhZC1nLTE6bi5lbmQtZywwPT09Yyl7YT0wO2JyZWFrfWE9NztjYXNlIDc6aWYobi53cml0ZT1nLGU9bi5pbmZsYXRlX2ZsdXNoKHQsZSksZz1uLndyaXRlLHk9ZzxuLnJlYWQ/bi5yZWFkLWctMTpuLmVuZC1nLG4ucmVhZCE9bi53cml0ZSlyZXR1cm4gbi5iaXRiPWIsbi5iaXRrPXAsdC5hdmFpbF9pbj14LHQudG90YWxfaW4rPXctdC5uZXh0X2luX2luZGV4LHQubmV4dF9pbl9pbmRleD13LG4ud3JpdGU9ZyxuLmluZmxhdGVfZmx1c2godCxlKTthPTg7Y2FzZSA4OnJldHVybiBlPTEsbi5iaXRiPWIsbi5iaXRrPXAsdC5hdmFpbF9pbj14LHQudG90YWxfaW4rPXctdC5uZXh0X2luX2luZGV4LHQubmV4dF9pbl9pbmRleD13LG4ud3JpdGU9ZyxuLmluZmxhdGVfZmx1c2godCxlKTtjYXNlIDk6cmV0dXJuIGU9LTMsbi5iaXRiPWIsbi5iaXRrPXAsdC5hdmFpbF9pbj14LHQudG90YWxfaW4rPXctdC5uZXh0X2luX2luZGV4LHQubmV4dF9pbl9pbmRleD13LG4ud3JpdGU9ZyxuLmluZmxhdGVfZmx1c2godCxlKTtkZWZhdWx0OnJldHVybiBlPS0yLG4uYml0Yj1iLG4uYml0az1wLHQuYXZhaWxfaW49eCx0LnRvdGFsX2luKz13LXQubmV4dF9pbl9pbmRleCx0Lm5leHRfaW5faW5kZXg9dyxuLndyaXRlPWcsbi5pbmZsYXRlX2ZsdXNoKHQsZSl9fX0sbi5mcmVlPWZ1bmN0aW9uKHQpe24ucmVzZXQodCxudWxsKSxuLndpbmRvdz1udWxsLGY9bnVsbDt9LG4uc2V0X2RpY3Rpb25hcnk9ZnVuY3Rpb24odCxlLGkpe24ud2luZG93LnNldCh0LnN1YmFycmF5KGUsZStpKSwwKSxuLnJlYWQ9bi53cml0ZT1pO30sbi5zeW5jX3BvaW50PWZ1bmN0aW9uKCl7cmV0dXJuIDE9PWE/MTowfTt9Y29uc3Qgb3Q9WzAsMCwyNTUsMjU1XTtmdW5jdGlvbiBsdCgpe2NvbnN0IHQ9dGhpcztmdW5jdGlvbiBlKHQpe3JldHVybiB0JiZ0LmlzdGF0ZT8odC50b3RhbF9pbj10LnRvdGFsX291dD0wLHQubXNnPW51bGwsdC5pc3RhdGUubW9kZT03LHQuaXN0YXRlLmJsb2Nrcy5yZXNldCh0LG51bGwpLDApOi0yfXQubW9kZT0wLHQubWV0aG9kPTAsdC53YXM9WzBdLHQubmVlZD0wLHQubWFya2VyPTAsdC53Yml0cz0wLHQuaW5mbGF0ZUVuZD1mdW5jdGlvbihlKXtyZXR1cm4gdC5ibG9ja3MmJnQuYmxvY2tzLmZyZWUoZSksdC5ibG9ja3M9bnVsbCwwfSx0LmluZmxhdGVJbml0PWZ1bmN0aW9uKG4saSl7cmV0dXJuIG4ubXNnPW51bGwsdC5ibG9ja3M9bnVsbCxpPDh8fGk+MTU/KHQuaW5mbGF0ZUVuZChuKSwtMik6KHQud2JpdHM9aSxuLmlzdGF0ZS5ibG9ja3M9bmV3IHN0KG4sMTw8aSksZShuKSwwKX0sdC5pbmZsYXRlPWZ1bmN0aW9uKHQsZSl7bGV0IG4saTtpZighdHx8IXQuaXN0YXRlfHwhdC5uZXh0X2luKXJldHVybiAtMjtjb25zdCBhPXQuaXN0YXRlO2ZvcihlPTQ9PWU/LTU6MCxuPS01Ozspc3dpdGNoKGEubW9kZSl7Y2FzZSAwOmlmKDA9PT10LmF2YWlsX2luKXJldHVybiBuO2lmKG49ZSx0LmF2YWlsX2luLS0sdC50b3RhbF9pbisrLDghPSgxNSYoYS5tZXRob2Q9dC5yZWFkX2J5dGUodC5uZXh0X2luX2luZGV4KyspKSkpe2EubW9kZT0xMyx0Lm1zZz1cInVua25vd24gY29tcHJlc3Npb24gbWV0aG9kXCIsYS5tYXJrZXI9NTticmVha31pZig4KyhhLm1ldGhvZD4+NCk+YS53Yml0cyl7YS5tb2RlPTEzLHQubXNnPVwiaW52YWxpZCB3aW5kb3cgc2l6ZVwiLGEubWFya2VyPTU7YnJlYWt9YS5tb2RlPTE7Y2FzZSAxOmlmKDA9PT10LmF2YWlsX2luKXJldHVybiBuO2lmKG49ZSx0LmF2YWlsX2luLS0sdC50b3RhbF9pbisrLGk9MjU1JnQucmVhZF9ieXRlKHQubmV4dF9pbl9pbmRleCsrKSwoKGEubWV0aG9kPDw4KStpKSUzMSE9MCl7YS5tb2RlPTEzLHQubXNnPVwiaW5jb3JyZWN0IGhlYWRlciBjaGVja1wiLGEubWFya2VyPTU7YnJlYWt9aWYoMD09KDMyJmkpKXthLm1vZGU9NzticmVha31hLm1vZGU9MjtjYXNlIDI6aWYoMD09PXQuYXZhaWxfaW4pcmV0dXJuIG47bj1lLHQuYXZhaWxfaW4tLSx0LnRvdGFsX2luKyssYS5uZWVkPSgyNTUmdC5yZWFkX2J5dGUodC5uZXh0X2luX2luZGV4KyspKTw8MjQmNDI3ODE5MDA4MCxhLm1vZGU9MztjYXNlIDM6aWYoMD09PXQuYXZhaWxfaW4pcmV0dXJuIG47bj1lLHQuYXZhaWxfaW4tLSx0LnRvdGFsX2luKyssYS5uZWVkKz0oMjU1JnQucmVhZF9ieXRlKHQubmV4dF9pbl9pbmRleCsrKSk8PDE2JjE2NzExNjgwLGEubW9kZT00O2Nhc2UgNDppZigwPT09dC5hdmFpbF9pbilyZXR1cm4gbjtuPWUsdC5hdmFpbF9pbi0tLHQudG90YWxfaW4rKyxhLm5lZWQrPSgyNTUmdC5yZWFkX2J5dGUodC5uZXh0X2luX2luZGV4KyspKTw8OCY2NTI4MCxhLm1vZGU9NTtjYXNlIDU6cmV0dXJuIDA9PT10LmF2YWlsX2luP246KG49ZSx0LmF2YWlsX2luLS0sdC50b3RhbF9pbisrLGEubmVlZCs9MjU1JnQucmVhZF9ieXRlKHQubmV4dF9pbl9pbmRleCsrKSxhLm1vZGU9NiwyKTtjYXNlIDY6cmV0dXJuIGEubW9kZT0xMyx0Lm1zZz1cIm5lZWQgZGljdGlvbmFyeVwiLGEubWFya2VyPTAsLTI7Y2FzZSA3OmlmKG49YS5ibG9ja3MucHJvYyh0LG4pLC0zPT1uKXthLm1vZGU9MTMsYS5tYXJrZXI9MDticmVha31pZigwPT1uJiYobj1lKSwxIT1uKXJldHVybiBuO249ZSxhLmJsb2Nrcy5yZXNldCh0LGEud2FzKSxhLm1vZGU9MTI7Y2FzZSAxMjpyZXR1cm4gMTtjYXNlIDEzOnJldHVybiAtMztkZWZhdWx0OnJldHVybiAtMn19LHQuaW5mbGF0ZVNldERpY3Rpb25hcnk9ZnVuY3Rpb24odCxlLG4pe2xldCBpPTAsYT1uO2lmKCF0fHwhdC5pc3RhdGV8fDYhPXQuaXN0YXRlLm1vZGUpcmV0dXJuIC0yO2NvbnN0IHI9dC5pc3RhdGU7cmV0dXJuIGE+PTE8PHIud2JpdHMmJihhPSgxPDxyLndiaXRzKS0xLGk9bi1hKSxyLmJsb2Nrcy5zZXRfZGljdGlvbmFyeShlLGksYSksci5tb2RlPTcsMH0sdC5pbmZsYXRlU3luYz1mdW5jdGlvbih0KXtsZXQgbixpLGEscixzO2lmKCF0fHwhdC5pc3RhdGUpcmV0dXJuIC0yO2NvbnN0IG89dC5pc3RhdGU7aWYoMTMhPW8ubW9kZSYmKG8ubW9kZT0xMyxvLm1hcmtlcj0wKSwwPT09KG49dC5hdmFpbF9pbikpcmV0dXJuIC01O2ZvcihpPXQubmV4dF9pbl9pbmRleCxhPW8ubWFya2VyOzAhPT1uJiZhPDQ7KXQucmVhZF9ieXRlKGkpPT1vdFthXT9hKys6YT0wIT09dC5yZWFkX2J5dGUoaSk/MDo0LWEsaSsrLG4tLTtyZXR1cm4gdC50b3RhbF9pbis9aS10Lm5leHRfaW5faW5kZXgsdC5uZXh0X2luX2luZGV4PWksdC5hdmFpbF9pbj1uLG8ubWFya2VyPWEsNCE9YT8tMzoocj10LnRvdGFsX2luLHM9dC50b3RhbF9vdXQsZSh0KSx0LnRvdGFsX2luPXIsdC50b3RhbF9vdXQ9cyxvLm1vZGU9NywwKX0sdC5pbmZsYXRlU3luY1BvaW50PWZ1bmN0aW9uKHQpe3JldHVybiB0JiZ0LmlzdGF0ZSYmdC5pc3RhdGUuYmxvY2tzP3QuaXN0YXRlLmJsb2Nrcy5zeW5jX3BvaW50KCk6LTJ9O31mdW5jdGlvbiBfdCgpe31mdW5jdGlvbiBkdCh0KXtjb25zdCBlPW5ldyBfdCxuPXQmJnQuY2h1bmtTaXplP01hdGguZmxvb3IoMip0LmNodW5rU2l6ZSk6MTMxMDcyLGk9bmV3IFVpbnQ4QXJyYXkobik7bGV0IGE9ITE7ZS5pbmZsYXRlSW5pdCgpLGUubmV4dF9vdXQ9aSx0aGlzLmFwcGVuZD1mdW5jdGlvbih0LHIpe2NvbnN0IHM9W107bGV0IG8sbCxfPTAsZD0wLGM9MDtpZigwIT09dC5sZW5ndGgpe2UubmV4dF9pbl9pbmRleD0wLGUubmV4dF9pbj10LGUuYXZhaWxfaW49dC5sZW5ndGg7ZG97aWYoZS5uZXh0X291dF9pbmRleD0wLGUuYXZhaWxfb3V0PW4sMCE9PWUuYXZhaWxfaW58fGF8fChlLm5leHRfaW5faW5kZXg9MCxhPSEwKSxvPWUuaW5mbGF0ZSgwKSxhJiYtNT09PW8pe2lmKDAhPT1lLmF2YWlsX2luKXRocm93IG5ldyBFcnJvcihcImluZmxhdGluZzogYmFkIGlucHV0XCIpfWVsc2UgaWYoMCE9PW8mJjEhPT1vKXRocm93IG5ldyBFcnJvcihcImluZmxhdGluZzogXCIrZS5tc2cpO2lmKChhfHwxPT09bykmJmUuYXZhaWxfaW49PT10Lmxlbmd0aCl0aHJvdyBuZXcgRXJyb3IoXCJpbmZsYXRpbmc6IGJhZCBpbnB1dFwiKTtlLm5leHRfb3V0X2luZGV4JiYoZS5uZXh0X291dF9pbmRleD09PW4/cy5wdXNoKG5ldyBVaW50OEFycmF5KGkpKTpzLnB1c2goaS5zbGljZSgwLGUubmV4dF9vdXRfaW5kZXgpKSksYys9ZS5uZXh0X291dF9pbmRleCxyJiZlLm5leHRfaW5faW5kZXg+MCYmZS5uZXh0X2luX2luZGV4IT1fJiYocihlLm5leHRfaW5faW5kZXgpLF89ZS5uZXh0X2luX2luZGV4KTt9d2hpbGUoZS5hdmFpbF9pbj4wfHwwPT09ZS5hdmFpbF9vdXQpO3JldHVybiBzLmxlbmd0aD4xPyhsPW5ldyBVaW50OEFycmF5KGMpLHMuZm9yRWFjaCgoZnVuY3Rpb24odCl7bC5zZXQodCxkKSxkKz10Lmxlbmd0aDt9KSkpOmw9c1swXXx8bmV3IFVpbnQ4QXJyYXkoMCksbH19LHRoaXMuZmx1c2g9ZnVuY3Rpb24oKXtlLmluZmxhdGVFbmQoKTt9O31fdC5wcm90b3R5cGU9e2luZmxhdGVJbml0OmZ1bmN0aW9uKHQpe2NvbnN0IGU9dGhpcztyZXR1cm4gZS5pc3RhdGU9bmV3IGx0LHR8fCh0PTE1KSxlLmlzdGF0ZS5pbmZsYXRlSW5pdChlLHQpfSxpbmZsYXRlOmZ1bmN0aW9uKHQpe2NvbnN0IGU9dGhpcztyZXR1cm4gZS5pc3RhdGU/ZS5pc3RhdGUuaW5mbGF0ZShlLHQpOi0yfSxpbmZsYXRlRW5kOmZ1bmN0aW9uKCl7Y29uc3QgdD10aGlzO2lmKCF0LmlzdGF0ZSlyZXR1cm4gLTI7Y29uc3QgZT10LmlzdGF0ZS5pbmZsYXRlRW5kKHQpO3JldHVybiB0LmlzdGF0ZT1udWxsLGV9LGluZmxhdGVTeW5jOmZ1bmN0aW9uKCl7Y29uc3QgdD10aGlzO3JldHVybiB0LmlzdGF0ZT90LmlzdGF0ZS5pbmZsYXRlU3luYyh0KTotMn0saW5mbGF0ZVNldERpY3Rpb25hcnk6ZnVuY3Rpb24odCxlKXtjb25zdCBuPXRoaXM7cmV0dXJuIG4uaXN0YXRlP24uaXN0YXRlLmluZmxhdGVTZXREaWN0aW9uYXJ5KG4sdCxlKTotMn0scmVhZF9ieXRlOmZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLm5leHRfaW5bdF19LHJlYWRfYnVmOmZ1bmN0aW9uKHQsZSl7cmV0dXJuIHRoaXMubmV4dF9pbi5zdWJhcnJheSh0LHQrZSl9fSxzZWxmLmluaXRDb2RlYz0oKT0+e3NlbGYuRGVmbGF0ZT1RLHNlbGYuSW5mbGF0ZT1kdDt9O30pLnRvU3RyaW5nKCksbj1VUkwuY3JlYXRlT2JqZWN0VVJMKG5ldyBCbG9iKFtcIihcIitlK1wiKSgpXCJdLHt0eXBlOlwidGV4dC9qYXZhc2NyaXB0XCJ9KSk7Y29uZmlndXJlKHt3b3JrZXJTY3JpcHRzOntpbmZsYXRlOltuXSxkZWZsYXRlOltuXX19KTt9fTtcblxuLypcbiBDb3B5cmlnaHQgKGMpIDIwMjEgR2lsZGFzIExvcm1lYXUuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG5cbiBSZWRpc3RyaWJ1dGlvbiBhbmQgdXNlIGluIHNvdXJjZSBhbmQgYmluYXJ5IGZvcm1zLCB3aXRoIG9yIHdpdGhvdXRcbiBtb2RpZmljYXRpb24sIGFyZSBwZXJtaXR0ZWQgcHJvdmlkZWQgdGhhdCB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnMgYXJlIG1ldDpcblxuIDEuIFJlZGlzdHJpYnV0aW9ucyBvZiBzb3VyY2UgY29kZSBtdXN0IHJldGFpbiB0aGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSxcbiB0aGlzIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZyBkaXNjbGFpbWVyLlxuXG4gMi4gUmVkaXN0cmlidXRpb25zIGluIGJpbmFyeSBmb3JtIG11c3QgcmVwcm9kdWNlIHRoZSBhYm92ZSBjb3B5cmlnaHQgXG4gbm90aWNlLCB0aGlzIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZyBkaXNjbGFpbWVyIGluIFxuIHRoZSBkb2N1bWVudGF0aW9uIGFuZC9vciBvdGhlciBtYXRlcmlhbHMgcHJvdmlkZWQgd2l0aCB0aGUgZGlzdHJpYnV0aW9uLlxuXG4gMy4gVGhlIG5hbWVzIG9mIHRoZSBhdXRob3JzIG1heSBub3QgYmUgdXNlZCB0byBlbmRvcnNlIG9yIHByb21vdGUgcHJvZHVjdHNcbiBkZXJpdmVkIGZyb20gdGhpcyBzb2Z0d2FyZSB3aXRob3V0IHNwZWNpZmljIHByaW9yIHdyaXR0ZW4gcGVybWlzc2lvbi5cblxuIFRISVMgU09GVFdBUkUgSVMgUFJPVklERUQgJydBUyBJUycnIEFORCBBTlkgRVhQUkVTU0VEIE9SIElNUExJRUQgV0FSUkFOVElFUyxcbiBJTkNMVURJTkcsIEJVVCBOT1QgTElNSVRFRCBUTywgVEhFIElNUExJRUQgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFkgQU5EXG4gRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQVJFIERJU0NMQUlNRUQuIElOIE5PIEVWRU5UIFNIQUxMIEpDUkFGVCxcbiBJTkMuIE9SIEFOWSBDT05UUklCVVRPUlMgVE8gVEhJUyBTT0ZUV0FSRSBCRSBMSUFCTEUgRk9SIEFOWSBESVJFQ1QsIElORElSRUNULFxuIElOQ0lERU5UQUwsIFNQRUNJQUwsIEVYRU1QTEFSWSwgT1IgQ09OU0VRVUVOVElBTCBEQU1BR0VTIChJTkNMVURJTkcsIEJVVCBOT1RcbiBMSU1JVEVEIFRPLCBQUk9DVVJFTUVOVCBPRiBTVUJTVElUVVRFIEdPT0RTIE9SIFNFUlZJQ0VTOyBMT1NTIE9GIFVTRSwgREFUQSxcbiBPUiBQUk9GSVRTOyBPUiBCVVNJTkVTUyBJTlRFUlJVUFRJT04pIEhPV0VWRVIgQ0FVU0VEIEFORCBPTiBBTlkgVEhFT1JZIE9GXG4gTElBQklMSVRZLCBXSEVUSEVSIElOIENPTlRSQUNULCBTVFJJQ1QgTElBQklMSVRZLCBPUiBUT1JUIChJTkNMVURJTkdcbiBORUdMSUdFTkNFIE9SIE9USEVSV0lTRSkgQVJJU0lORyBJTiBBTlkgV0FZIE9VVCBPRiBUSEUgVVNFIE9GIFRISVMgU09GVFdBUkUsXG4gRVZFTiBJRiBBRFZJU0VEIE9GIFRIRSBQT1NTSUJJTElUWSBPRiBTVUNIIERBTUFHRS5cbiAqL1xuXG5mdW5jdGlvbiBnZXRNaW1lVHlwZSgpIHtcblx0cmV0dXJuIFwiYXBwbGljYXRpb24vb2N0ZXQtc3RyZWFtXCI7XG59XG5cbnZhciBzdHJlYW1Db2RlY1NoaW0gPSAobGlicmFyeSwgb3B0aW9ucyA9IHt9LCByZWdpc3RlckRhdGFIYW5kbGVyKSA9PiB7XG5cdHJldHVybiB7XG5cdFx0RGVmbGF0ZTogY3JlYXRlQ29kZWNDbGFzcyhsaWJyYXJ5LkRlZmxhdGUsIG9wdGlvbnMuZGVmbGF0ZSwgcmVnaXN0ZXJEYXRhSGFuZGxlciksXG5cdFx0SW5mbGF0ZTogY3JlYXRlQ29kZWNDbGFzcyhsaWJyYXJ5LkluZmxhdGUsIG9wdGlvbnMuaW5mbGF0ZSwgcmVnaXN0ZXJEYXRhSGFuZGxlcilcblx0fTtcbn07XG5cbmZ1bmN0aW9uIGNyZWF0ZUNvZGVjQ2xhc3MoY29uc3RydWN0b3IsIGNvbnN0cnVjdG9yT3B0aW9ucywgcmVnaXN0ZXJEYXRhSGFuZGxlcikge1xuXHRyZXR1cm4gY2xhc3Mge1xuXG5cdFx0Y29uc3RydWN0b3Iob3B0aW9ucykge1xuXHRcdFx0Y29uc3QgY29kZWNBZGFwdGVyID0gdGhpcztcblx0XHRcdGNvbnN0IG9uRGF0YSA9IGRhdGEgPT4ge1xuXHRcdFx0XHRpZiAoY29kZWNBZGFwdGVyLnBlbmRpbmdEYXRhKSB7XG5cdFx0XHRcdFx0Y29uc3QgcGVuZGluZ0RhdGEgPSBjb2RlY0FkYXB0ZXIucGVuZGluZ0RhdGE7XG5cdFx0XHRcdFx0Y29kZWNBZGFwdGVyLnBlbmRpbmdEYXRhID0gbmV3IFVpbnQ4QXJyYXkocGVuZGluZ0RhdGEubGVuZ3RoICsgZGF0YS5sZW5ndGgpO1xuXHRcdFx0XHRcdGNvZGVjQWRhcHRlci5wZW5kaW5nRGF0YS5zZXQocGVuZGluZ0RhdGEsIDApO1xuXHRcdFx0XHRcdGNvZGVjQWRhcHRlci5wZW5kaW5nRGF0YS5zZXQoZGF0YSwgcGVuZGluZ0RhdGEubGVuZ3RoKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRjb2RlY0FkYXB0ZXIucGVuZGluZ0RhdGEgPSBuZXcgVWludDhBcnJheShkYXRhKTtcblx0XHRcdFx0fVxuXHRcdFx0fTtcblx0XHRcdGNvZGVjQWRhcHRlci5jb2RlYyA9IG5ldyBjb25zdHJ1Y3RvcihPYmplY3QuYXNzaWduKHt9LCBjb25zdHJ1Y3Rvck9wdGlvbnMsIG9wdGlvbnMpKTtcblx0XHRcdHJlZ2lzdGVyRGF0YUhhbmRsZXIoY29kZWNBZGFwdGVyLmNvZGVjLCBvbkRhdGEpO1xuXHRcdH1cblx0XHRhc3luYyBhcHBlbmQoZGF0YSkge1xuXHRcdFx0dGhpcy5jb2RlYy5wdXNoKGRhdGEpO1xuXHRcdFx0cmV0dXJuIGdldFJlc3BvbnNlKHRoaXMpO1xuXHRcdH1cblx0XHRhc3luYyBmbHVzaCgpIHtcblx0XHRcdHRoaXMuY29kZWMucHVzaChuZXcgVWludDhBcnJheSgwKSwgdHJ1ZSk7XG5cdFx0XHRyZXR1cm4gZ2V0UmVzcG9uc2UodGhpcyk7XG5cdFx0fVxuXHR9O1xuXG5cdGZ1bmN0aW9uIGdldFJlc3BvbnNlKGNvZGVjKSB7XG5cdFx0aWYgKGNvZGVjLnBlbmRpbmdEYXRhKSB7XG5cdFx0XHRjb25zdCBvdXRwdXQgPSBjb2RlYy5wZW5kaW5nRGF0YTtcblx0XHRcdGNvZGVjLnBlbmRpbmdEYXRhID0gbnVsbDtcblx0XHRcdHJldHVybiBvdXRwdXQ7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHJldHVybiBuZXcgVWludDhBcnJheSgwKTtcblx0XHR9XG5cdH1cbn1cblxuLypcbiBDb3B5cmlnaHQgKGMpIDIwMjEgR2lsZGFzIExvcm1lYXUuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG5cbiBSZWRpc3RyaWJ1dGlvbiBhbmQgdXNlIGluIHNvdXJjZSBhbmQgYmluYXJ5IGZvcm1zLCB3aXRoIG9yIHdpdGhvdXRcbiBtb2RpZmljYXRpb24sIGFyZSBwZXJtaXR0ZWQgcHJvdmlkZWQgdGhhdCB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnMgYXJlIG1ldDpcblxuIDEuIFJlZGlzdHJpYnV0aW9ucyBvZiBzb3VyY2UgY29kZSBtdXN0IHJldGFpbiB0aGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSxcbiB0aGlzIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZyBkaXNjbGFpbWVyLlxuXG4gMi4gUmVkaXN0cmlidXRpb25zIGluIGJpbmFyeSBmb3JtIG11c3QgcmVwcm9kdWNlIHRoZSBhYm92ZSBjb3B5cmlnaHQgXG4gbm90aWNlLCB0aGlzIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZyBkaXNjbGFpbWVyIGluIFxuIHRoZSBkb2N1bWVudGF0aW9uIGFuZC9vciBvdGhlciBtYXRlcmlhbHMgcHJvdmlkZWQgd2l0aCB0aGUgZGlzdHJpYnV0aW9uLlxuXG4gMy4gVGhlIG5hbWVzIG9mIHRoZSBhdXRob3JzIG1heSBub3QgYmUgdXNlZCB0byBlbmRvcnNlIG9yIHByb21vdGUgcHJvZHVjdHNcbiBkZXJpdmVkIGZyb20gdGhpcyBzb2Z0d2FyZSB3aXRob3V0IHNwZWNpZmljIHByaW9yIHdyaXR0ZW4gcGVybWlzc2lvbi5cblxuIFRISVMgU09GVFdBUkUgSVMgUFJPVklERUQgJydBUyBJUycnIEFORCBBTlkgRVhQUkVTU0VEIE9SIElNUExJRUQgV0FSUkFOVElFUyxcbiBJTkNMVURJTkcsIEJVVCBOT1QgTElNSVRFRCBUTywgVEhFIElNUExJRUQgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFkgQU5EXG4gRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQVJFIERJU0NMQUlNRUQuIElOIE5PIEVWRU5UIFNIQUxMIEpDUkFGVCxcbiBJTkMuIE9SIEFOWSBDT05UUklCVVRPUlMgVE8gVEhJUyBTT0ZUV0FSRSBCRSBMSUFCTEUgRk9SIEFOWSBESVJFQ1QsIElORElSRUNULFxuIElOQ0lERU5UQUwsIFNQRUNJQUwsIEVYRU1QTEFSWSwgT1IgQ09OU0VRVUVOVElBTCBEQU1BR0VTIChJTkNMVURJTkcsIEJVVCBOT1RcbiBMSU1JVEVEIFRPLCBQUk9DVVJFTUVOVCBPRiBTVUJTVElUVVRFIEdPT0RTIE9SIFNFUlZJQ0VTOyBMT1NTIE9GIFVTRSwgREFUQSxcbiBPUiBQUk9GSVRTOyBPUiBCVVNJTkVTUyBJTlRFUlJVUFRJT04pIEhPV0VWRVIgQ0FVU0VEIEFORCBPTiBBTlkgVEhFT1JZIE9GXG4gTElBQklMSVRZLCBXSEVUSEVSIElOIENPTlRSQUNULCBTVFJJQ1QgTElBQklMSVRZLCBPUiBUT1JUIChJTkNMVURJTkdcbiBORUdMSUdFTkNFIE9SIE9USEVSV0lTRSkgQVJJU0lORyBJTiBBTlkgV0FZIE9VVCBPRiBUSEUgVVNFIE9GIFRISVMgU09GVFdBUkUsXG4gRVZFTiBJRiBBRFZJU0VEIE9GIFRIRSBQT1NTSUJJTElUWSBPRiBTVUNIIERBTUFHRS5cbiAqL1xuXG5jb25zdCB0YWJsZSA9IFtdO1xuZm9yIChsZXQgaSA9IDA7IGkgPCAyNTY7IGkrKykge1xuXHRsZXQgdCA9IGk7XG5cdGZvciAobGV0IGogPSAwOyBqIDwgODsgaisrKSB7XG5cdFx0aWYgKHQgJiAxKSB7XG5cdFx0XHR0ID0gKHQgPj4+IDEpIF4gMHhFREI4ODMyMDtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dCA9IHQgPj4+IDE7XG5cdFx0fVxuXHR9XG5cdHRhYmxlW2ldID0gdDtcbn1cblxuY2xhc3MgQ3JjMzIge1xuXG5cdGNvbnN0cnVjdG9yKGNyYykge1xuXHRcdHRoaXMuY3JjID0gY3JjIHx8IC0xO1xuXHR9XG5cblx0YXBwZW5kKGRhdGEpIHtcblx0XHRsZXQgY3JjID0gdGhpcy5jcmMgfCAwO1xuXHRcdGZvciAobGV0IG9mZnNldCA9IDAsIGxlbmd0aCA9IGRhdGEubGVuZ3RoIHwgMDsgb2Zmc2V0IDwgbGVuZ3RoOyBvZmZzZXQrKykge1xuXHRcdFx0Y3JjID0gKGNyYyA+Pj4gOCkgXiB0YWJsZVsoY3JjIF4gZGF0YVtvZmZzZXRdKSAmIDB4RkZdO1xuXHRcdH1cblx0XHR0aGlzLmNyYyA9IGNyYztcblx0fVxuXG5cdGdldCgpIHtcblx0XHRyZXR1cm4gfnRoaXMuY3JjO1xuXHR9XG59XG5cbi8vIERlcml2ZWQgZnJvbSBodHRwczovL2dpdGh1Yi5jb20veHFkb28wMG8vanN6aXAvYmxvYi9tYXN0ZXIvbGliL3NqY2wuanNcbi8qanNsaW50IGluZGVudDogMiwgYml0d2lzZTogZmFsc2UsIG5vbWVuOiBmYWxzZSwgcGx1c3BsdXM6IGZhbHNlLCB3aGl0ZTogZmFsc2UsIHJlZ2V4cDogZmFsc2UgKi9cblxuLyoqIEBmaWxlT3ZlcnZpZXcgQXJyYXlzIG9mIGJpdHMsIGVuY29kZWQgYXMgYXJyYXlzIG9mIE51bWJlcnMuXG4gKlxuICogQGF1dGhvciBFbWlseSBTdGFya1xuICogQGF1dGhvciBNaWtlIEhhbWJ1cmdcbiAqIEBhdXRob3IgRGFuIEJvbmVoXG4gKi9cblxuLyoqXG4gKiBBcnJheXMgb2YgYml0cywgZW5jb2RlZCBhcyBhcnJheXMgb2YgTnVtYmVycy5cbiAqIEBuYW1lc3BhY2VcbiAqIEBkZXNjcmlwdGlvblxuICogPHA+XG4gKiBUaGVzZSBvYmplY3RzIGFyZSB0aGUgY3VycmVuY3kgYWNjZXB0ZWQgYnkgU0pDTCdzIGNyeXB0byBmdW5jdGlvbnMuXG4gKiA8L3A+XG4gKlxuICogPHA+XG4gKiBNb3N0IG9mIG91ciBjcnlwdG8gcHJpbWl0aXZlcyBvcGVyYXRlIG9uIGFycmF5cyBvZiA0LWJ5dGUgd29yZHMgaW50ZXJuYWxseSxcbiAqIGJ1dCBtYW55IG9mIHRoZW0gY2FuIHRha2UgYXJndW1lbnRzIHRoYXQgYXJlIG5vdCBhIG11bHRpcGxlIG9mIDQgYnl0ZXMuXG4gKiBUaGlzIGxpYnJhcnkgZW5jb2RlcyBhcnJheXMgb2YgYml0cyAod2hvc2Ugc2l6ZSBuZWVkIG5vdCBiZSBhIG11bHRpcGxlIG9mIDhcbiAqIGJpdHMpIGFzIGFycmF5cyBvZiAzMi1iaXQgd29yZHMuICBUaGUgYml0cyBhcmUgcGFja2VkLCBiaWctZW5kaWFuLCBpbnRvIGFuXG4gKiBhcnJheSBvZiB3b3JkcywgMzIgYml0cyBhdCBhIHRpbWUuICBTaW5jZSB0aGUgd29yZHMgYXJlIGRvdWJsZS1wcmVjaXNpb25cbiAqIGZsb2F0aW5nIHBvaW50IG51bWJlcnMsIHRoZXkgZml0IHNvbWUgZXh0cmEgZGF0YS4gIFdlIHVzZSB0aGlzIChpbiBhIHByaXZhdGUsXG4gKiBwb3NzaWJseS1jaGFuZ2luZyBtYW5uZXIpIHRvIGVuY29kZSB0aGUgbnVtYmVyIG9mIGJpdHMgYWN0dWFsbHkgIHByZXNlbnRcbiAqIGluIHRoZSBsYXN0IHdvcmQgb2YgdGhlIGFycmF5LlxuICogPC9wPlxuICpcbiAqIDxwPlxuICogQmVjYXVzZSBiaXR3aXNlIG9wcyBjbGVhciB0aGlzIG91dC1vZi1iYW5kIGRhdGEsIHRoZXNlIGFycmF5cyBjYW4gYmUgcGFzc2VkXG4gKiB0byBjaXBoZXJzIGxpa2UgQUVTIHdoaWNoIHdhbnQgYXJyYXlzIG9mIHdvcmRzLlxuICogPC9wPlxuICovXG5jb25zdCBiaXRBcnJheSA9IHtcblx0LyoqXG5cdCAqIENvbmNhdGVuYXRlIHR3byBiaXQgYXJyYXlzLlxuXHQgKiBAcGFyYW0ge2JpdEFycmF5fSBhMSBUaGUgZmlyc3QgYXJyYXkuXG5cdCAqIEBwYXJhbSB7Yml0QXJyYXl9IGEyIFRoZSBzZWNvbmQgYXJyYXkuXG5cdCAqIEByZXR1cm4ge2JpdEFycmF5fSBUaGUgY29uY2F0ZW5hdGlvbiBvZiBhMSBhbmQgYTIuXG5cdCAqL1xuXHRjb25jYXQoYTEsIGEyKSB7XG5cdFx0aWYgKGExLmxlbmd0aCA9PT0gMCB8fCBhMi5sZW5ndGggPT09IDApIHtcblx0XHRcdHJldHVybiBhMS5jb25jYXQoYTIpO1xuXHRcdH1cblxuXHRcdGNvbnN0IGxhc3QgPSBhMVthMS5sZW5ndGggLSAxXSwgc2hpZnQgPSBiaXRBcnJheS5nZXRQYXJ0aWFsKGxhc3QpO1xuXHRcdGlmIChzaGlmdCA9PT0gMzIpIHtcblx0XHRcdHJldHVybiBhMS5jb25jYXQoYTIpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRyZXR1cm4gYml0QXJyYXkuX3NoaWZ0UmlnaHQoYTIsIHNoaWZ0LCBsYXN0IHwgMCwgYTEuc2xpY2UoMCwgYTEubGVuZ3RoIC0gMSkpO1xuXHRcdH1cblx0fSxcblxuXHQvKipcblx0ICogRmluZCB0aGUgbGVuZ3RoIG9mIGFuIGFycmF5IG9mIGJpdHMuXG5cdCAqIEBwYXJhbSB7Yml0QXJyYXl9IGEgVGhlIGFycmF5LlxuXHQgKiBAcmV0dXJuIHtOdW1iZXJ9IFRoZSBsZW5ndGggb2YgYSwgaW4gYml0cy5cblx0ICovXG5cdGJpdExlbmd0aChhKSB7XG5cdFx0Y29uc3QgbCA9IGEubGVuZ3RoO1xuXHRcdGlmIChsID09PSAwKSB7XG5cdFx0XHRyZXR1cm4gMDtcblx0XHR9XG5cdFx0Y29uc3QgeCA9IGFbbCAtIDFdO1xuXHRcdHJldHVybiAobCAtIDEpICogMzIgKyBiaXRBcnJheS5nZXRQYXJ0aWFsKHgpO1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBUcnVuY2F0ZSBhbiBhcnJheS5cblx0ICogQHBhcmFtIHtiaXRBcnJheX0gYSBUaGUgYXJyYXkuXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBsZW4gVGhlIGxlbmd0aCB0byB0cnVuY2F0ZSB0bywgaW4gYml0cy5cblx0ICogQHJldHVybiB7Yml0QXJyYXl9IEEgbmV3IGFycmF5LCB0cnVuY2F0ZWQgdG8gbGVuIGJpdHMuXG5cdCAqL1xuXHRjbGFtcChhLCBsZW4pIHtcblx0XHRpZiAoYS5sZW5ndGggKiAzMiA8IGxlbikge1xuXHRcdFx0cmV0dXJuIGE7XG5cdFx0fVxuXHRcdGEgPSBhLnNsaWNlKDAsIE1hdGguY2VpbChsZW4gLyAzMikpO1xuXHRcdGNvbnN0IGwgPSBhLmxlbmd0aDtcblx0XHRsZW4gPSBsZW4gJiAzMTtcblx0XHRpZiAobCA+IDAgJiYgbGVuKSB7XG5cdFx0XHRhW2wgLSAxXSA9IGJpdEFycmF5LnBhcnRpYWwobGVuLCBhW2wgLSAxXSAmIDB4ODAwMDAwMDAgPj4gKGxlbiAtIDEpLCAxKTtcblx0XHR9XG5cdFx0cmV0dXJuIGE7XG5cdH0sXG5cblx0LyoqXG5cdCAqIE1ha2UgYSBwYXJ0aWFsIHdvcmQgZm9yIGEgYml0IGFycmF5LlxuXHQgKiBAcGFyYW0ge051bWJlcn0gbGVuIFRoZSBudW1iZXIgb2YgYml0cyBpbiB0aGUgd29yZC5cblx0ICogQHBhcmFtIHtOdW1iZXJ9IHggVGhlIGJpdHMuXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBbX2VuZD0wXSBQYXNzIDEgaWYgeCBoYXMgYWxyZWFkeSBiZWVuIHNoaWZ0ZWQgdG8gdGhlIGhpZ2ggc2lkZS5cblx0ICogQHJldHVybiB7TnVtYmVyfSBUaGUgcGFydGlhbCB3b3JkLlxuXHQgKi9cblx0cGFydGlhbChsZW4sIHgsIF9lbmQpIHtcblx0XHRpZiAobGVuID09PSAzMikge1xuXHRcdFx0cmV0dXJuIHg7XG5cdFx0fVxuXHRcdHJldHVybiAoX2VuZCA/IHggfCAwIDogeCA8PCAoMzIgLSBsZW4pKSArIGxlbiAqIDB4MTAwMDAwMDAwMDA7XG5cdH0sXG5cblx0LyoqXG5cdCAqIEdldCB0aGUgbnVtYmVyIG9mIGJpdHMgdXNlZCBieSBhIHBhcnRpYWwgd29yZC5cblx0ICogQHBhcmFtIHtOdW1iZXJ9IHggVGhlIHBhcnRpYWwgd29yZC5cblx0ICogQHJldHVybiB7TnVtYmVyfSBUaGUgbnVtYmVyIG9mIGJpdHMgdXNlZCBieSB0aGUgcGFydGlhbCB3b3JkLlxuXHQgKi9cblx0Z2V0UGFydGlhbCh4KSB7XG5cdFx0cmV0dXJuIE1hdGgucm91bmQoeCAvIDB4MTAwMDAwMDAwMDApIHx8IDMyO1xuXHR9LFxuXG5cdC8qKiBTaGlmdCBhbiBhcnJheSByaWdodC5cblx0ICogQHBhcmFtIHtiaXRBcnJheX0gYSBUaGUgYXJyYXkgdG8gc2hpZnQuXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBzaGlmdCBUaGUgbnVtYmVyIG9mIGJpdHMgdG8gc2hpZnQuXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBbY2Fycnk9MF0gQSBieXRlIHRvIGNhcnJ5IGluXG5cdCAqIEBwYXJhbSB7Yml0QXJyYXl9IFtvdXQ9W11dIEFuIGFycmF5IHRvIHByZXBlbmQgdG8gdGhlIG91dHB1dC5cblx0ICogQHByaXZhdGVcblx0ICovXG5cdF9zaGlmdFJpZ2h0KGEsIHNoaWZ0LCBjYXJyeSwgb3V0KSB7XG5cdFx0aWYgKG91dCA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRvdXQgPSBbXTtcblx0XHR9XG5cblx0XHRmb3IgKDsgc2hpZnQgPj0gMzI7IHNoaWZ0IC09IDMyKSB7XG5cdFx0XHRvdXQucHVzaChjYXJyeSk7XG5cdFx0XHRjYXJyeSA9IDA7XG5cdFx0fVxuXHRcdGlmIChzaGlmdCA9PT0gMCkge1xuXHRcdFx0cmV0dXJuIG91dC5jb25jYXQoYSk7XG5cdFx0fVxuXG5cdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCBhLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRvdXQucHVzaChjYXJyeSB8IGFbaV0gPj4+IHNoaWZ0KTtcblx0XHRcdGNhcnJ5ID0gYVtpXSA8PCAoMzIgLSBzaGlmdCk7XG5cdFx0fVxuXHRcdGNvbnN0IGxhc3QyID0gYS5sZW5ndGggPyBhW2EubGVuZ3RoIC0gMV0gOiAwO1xuXHRcdGNvbnN0IHNoaWZ0MiA9IGJpdEFycmF5LmdldFBhcnRpYWwobGFzdDIpO1xuXHRcdG91dC5wdXNoKGJpdEFycmF5LnBhcnRpYWwoc2hpZnQgKyBzaGlmdDIgJiAzMSwgKHNoaWZ0ICsgc2hpZnQyID4gMzIpID8gY2FycnkgOiBvdXQucG9wKCksIDEpKTtcblx0XHRyZXR1cm4gb3V0O1xuXHR9XG59O1xuXG4vKiogQGZpbGVPdmVydmlldyBCaXQgYXJyYXkgY29kZWMgaW1wbGVtZW50YXRpb25zLlxuICpcbiAqIEBhdXRob3IgRW1pbHkgU3RhcmtcbiAqIEBhdXRob3IgTWlrZSBIYW1idXJnXG4gKiBAYXV0aG9yIERhbiBCb25laFxuICovXG5cbi8qKlxuICogQXJyYXlzIG9mIGJ5dGVzXG4gKiBAbmFtZXNwYWNlXG4gKi9cbmNvbnN0IGNvZGVjID0ge1xuXHRieXRlczoge1xuXHRcdC8qKiBDb252ZXJ0IGZyb20gYSBiaXRBcnJheSB0byBhbiBhcnJheSBvZiBieXRlcy4gKi9cblx0XHRmcm9tQml0cyhhcnIpIHtcblx0XHRcdGNvbnN0IGJsID0gYml0QXJyYXkuYml0TGVuZ3RoKGFycik7XG5cdFx0XHRjb25zdCBieXRlTGVuZ3RoID0gYmwgLyA4O1xuXHRcdFx0Y29uc3Qgb3V0ID0gbmV3IFVpbnQ4QXJyYXkoYnl0ZUxlbmd0aCk7XG5cdFx0XHRsZXQgdG1wO1xuXHRcdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCBieXRlTGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0aWYgKChpICYgMykgPT09IDApIHtcblx0XHRcdFx0XHR0bXAgPSBhcnJbaSAvIDRdO1xuXHRcdFx0XHR9XG5cdFx0XHRcdG91dFtpXSA9IHRtcCA+Pj4gMjQ7XG5cdFx0XHRcdHRtcCA8PD0gODtcblx0XHRcdH1cblx0XHRcdHJldHVybiBvdXQ7XG5cdFx0fSxcblx0XHQvKiogQ29udmVydCBmcm9tIGFuIGFycmF5IG9mIGJ5dGVzIHRvIGEgYml0QXJyYXkuICovXG5cdFx0dG9CaXRzKGJ5dGVzKSB7XG5cdFx0XHRjb25zdCBvdXQgPSBbXTtcblx0XHRcdGxldCBpO1xuXHRcdFx0bGV0IHRtcCA9IDA7XG5cdFx0XHRmb3IgKGkgPSAwOyBpIDwgYnl0ZXMubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0dG1wID0gdG1wIDw8IDggfCBieXRlc1tpXTtcblx0XHRcdFx0aWYgKChpICYgMykgPT09IDMpIHtcblx0XHRcdFx0XHRvdXQucHVzaCh0bXApO1xuXHRcdFx0XHRcdHRtcCA9IDA7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdGlmIChpICYgMykge1xuXHRcdFx0XHRvdXQucHVzaChiaXRBcnJheS5wYXJ0aWFsKDggKiAoaSAmIDMpLCB0bXApKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiBvdXQ7XG5cdFx0fVxuXHR9XG59O1xuXG5jb25zdCBoYXNoID0ge307XG5cbi8qKlxuICogQ29udGV4dCBmb3IgYSBTSEEtMSBvcGVyYXRpb24gaW4gcHJvZ3Jlc3MuXG4gKiBAY29uc3RydWN0b3JcbiAqL1xuaGFzaC5zaGExID0gZnVuY3Rpb24gKGhhc2gpIHtcblx0aWYgKGhhc2gpIHtcblx0XHR0aGlzLl9oID0gaGFzaC5faC5zbGljZSgwKTtcblx0XHR0aGlzLl9idWZmZXIgPSBoYXNoLl9idWZmZXIuc2xpY2UoMCk7XG5cdFx0dGhpcy5fbGVuZ3RoID0gaGFzaC5fbGVuZ3RoO1xuXHR9IGVsc2Uge1xuXHRcdHRoaXMucmVzZXQoKTtcblx0fVxufTtcblxuaGFzaC5zaGExLnByb3RvdHlwZSA9IHtcblx0LyoqXG5cdCAqIFRoZSBoYXNoJ3MgYmxvY2sgc2l6ZSwgaW4gYml0cy5cblx0ICogQGNvbnN0YW50XG5cdCAqL1xuXHRibG9ja1NpemU6IDUxMixcblxuXHQvKipcblx0ICogUmVzZXQgdGhlIGhhc2ggc3RhdGUuXG5cdCAqIEByZXR1cm4gdGhpc1xuXHQgKi9cblx0cmVzZXQ6IGZ1bmN0aW9uICgpIHtcblx0XHRjb25zdCBzaGExID0gdGhpcztcblx0XHRzaGExLl9oID0gdGhpcy5faW5pdC5zbGljZSgwKTtcblx0XHRzaGExLl9idWZmZXIgPSBbXTtcblx0XHRzaGExLl9sZW5ndGggPSAwO1xuXHRcdHJldHVybiBzaGExO1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBJbnB1dCBzZXZlcmFsIHdvcmRzIHRvIHRoZSBoYXNoLlxuXHQgKiBAcGFyYW0ge2JpdEFycmF5fFN0cmluZ30gZGF0YSB0aGUgZGF0YSB0byBoYXNoLlxuXHQgKiBAcmV0dXJuIHRoaXNcblx0ICovXG5cdHVwZGF0ZTogZnVuY3Rpb24gKGRhdGEpIHtcblx0XHRjb25zdCBzaGExID0gdGhpcztcblx0XHRpZiAodHlwZW9mIGRhdGEgPT09IFwic3RyaW5nXCIpIHtcblx0XHRcdGRhdGEgPSBjb2RlYy51dGY4U3RyaW5nLnRvQml0cyhkYXRhKTtcblx0XHR9XG5cdFx0Y29uc3QgYiA9IHNoYTEuX2J1ZmZlciA9IGJpdEFycmF5LmNvbmNhdChzaGExLl9idWZmZXIsIGRhdGEpO1xuXHRcdGNvbnN0IG9sID0gc2hhMS5fbGVuZ3RoO1xuXHRcdGNvbnN0IG5sID0gc2hhMS5fbGVuZ3RoID0gb2wgKyBiaXRBcnJheS5iaXRMZW5ndGgoZGF0YSk7XG5cdFx0aWYgKG5sID4gOTAwNzE5OTI1NDc0MDk5MSkge1xuXHRcdFx0dGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IGhhc2ggbW9yZSB0aGFuIDJeNTMgLSAxIGJpdHNcIik7XG5cdFx0fVxuXHRcdGNvbnN0IGMgPSBuZXcgVWludDMyQXJyYXkoYik7XG5cdFx0bGV0IGogPSAwO1xuXHRcdGZvciAobGV0IGkgPSBzaGExLmJsb2NrU2l6ZSArIG9sIC0gKChzaGExLmJsb2NrU2l6ZSArIG9sKSAmIChzaGExLmJsb2NrU2l6ZSAtIDEpKTsgaSA8PSBubDtcblx0XHRcdGkgKz0gc2hhMS5ibG9ja1NpemUpIHtcblx0XHRcdHNoYTEuX2Jsb2NrKGMuc3ViYXJyYXkoMTYgKiBqLCAxNiAqIChqICsgMSkpKTtcblx0XHRcdGogKz0gMTtcblx0XHR9XG5cdFx0Yi5zcGxpY2UoMCwgMTYgKiBqKTtcblx0XHRyZXR1cm4gc2hhMTtcblx0fSxcblxuXHQvKipcblx0ICogQ29tcGxldGUgaGFzaGluZyBhbmQgb3V0cHV0IHRoZSBoYXNoIHZhbHVlLlxuXHQgKiBAcmV0dXJuIHtiaXRBcnJheX0gVGhlIGhhc2ggdmFsdWUsIGFuIGFycmF5IG9mIDUgYmlnLWVuZGlhbiB3b3Jkcy4gVE9ET1xuXHQgKi9cblx0ZmluYWxpemU6IGZ1bmN0aW9uICgpIHtcblx0XHRjb25zdCBzaGExID0gdGhpcztcblx0XHRsZXQgYiA9IHNoYTEuX2J1ZmZlcjtcblx0XHRjb25zdCBoID0gc2hhMS5faDtcblxuXHRcdC8vIFJvdW5kIG91dCBhbmQgcHVzaCB0aGUgYnVmZmVyXG5cdFx0YiA9IGJpdEFycmF5LmNvbmNhdChiLCBbYml0QXJyYXkucGFydGlhbCgxLCAxKV0pO1xuXHRcdC8vIFJvdW5kIG91dCB0aGUgYnVmZmVyIHRvIGEgbXVsdGlwbGUgb2YgMTYgd29yZHMsIGxlc3MgdGhlIDIgbGVuZ3RoIHdvcmRzLlxuXHRcdGZvciAobGV0IGkgPSBiLmxlbmd0aCArIDI7IGkgJiAxNTsgaSsrKSB7XG5cdFx0XHRiLnB1c2goMCk7XG5cdFx0fVxuXG5cdFx0Ly8gYXBwZW5kIHRoZSBsZW5ndGhcblx0XHRiLnB1c2goTWF0aC5mbG9vcihzaGExLl9sZW5ndGggLyAweDEwMDAwMDAwMCkpO1xuXHRcdGIucHVzaChzaGExLl9sZW5ndGggfCAwKTtcblxuXHRcdHdoaWxlIChiLmxlbmd0aCkge1xuXHRcdFx0c2hhMS5fYmxvY2soYi5zcGxpY2UoMCwgMTYpKTtcblx0XHR9XG5cblx0XHRzaGExLnJlc2V0KCk7XG5cdFx0cmV0dXJuIGg7XG5cdH0sXG5cblx0LyoqXG5cdCAqIFRoZSBTSEEtMSBpbml0aWFsaXphdGlvbiB2ZWN0b3IuXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRfaW5pdDogWzB4Njc0NTIzMDEsIDB4RUZDREFCODksIDB4OThCQURDRkUsIDB4MTAzMjU0NzYsIDB4QzNEMkUxRjBdLFxuXG5cdC8qKlxuXHQgKiBUaGUgU0hBLTEgaGFzaCBrZXkuXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRfa2V5OiBbMHg1QTgyNzk5OSwgMHg2RUQ5RUJBMSwgMHg4RjFCQkNEQywgMHhDQTYyQzFENl0sXG5cblx0LyoqXG5cdCAqIFRoZSBTSEEtMSBsb2dpY2FsIGZ1bmN0aW9ucyBmKDApLCBmKDEpLCAuLi4sIGYoNzkpLlxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0X2Y6IGZ1bmN0aW9uICh0LCBiLCBjLCBkKSB7XG5cdFx0aWYgKHQgPD0gMTkpIHtcblx0XHRcdHJldHVybiAoYiAmIGMpIHwgKH5iICYgZCk7XG5cdFx0fSBlbHNlIGlmICh0IDw9IDM5KSB7XG5cdFx0XHRyZXR1cm4gYiBeIGMgXiBkO1xuXHRcdH0gZWxzZSBpZiAodCA8PSA1OSkge1xuXHRcdFx0cmV0dXJuIChiICYgYykgfCAoYiAmIGQpIHwgKGMgJiBkKTtcblx0XHR9IGVsc2UgaWYgKHQgPD0gNzkpIHtcblx0XHRcdHJldHVybiBiIF4gYyBeIGQ7XG5cdFx0fVxuXHR9LFxuXG5cdC8qKlxuXHQgKiBDaXJjdWxhciBsZWZ0LXNoaWZ0IG9wZXJhdG9yLlxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0X1M6IGZ1bmN0aW9uIChuLCB4KSB7XG5cdFx0cmV0dXJuICh4IDw8IG4pIHwgKHggPj4+IDMyIC0gbik7XG5cdH0sXG5cblx0LyoqXG5cdCAqIFBlcmZvcm0gb25lIGN5Y2xlIG9mIFNIQS0xLlxuXHQgKiBAcGFyYW0ge1VpbnQzMkFycmF5fGJpdEFycmF5fSB3b3JkcyBvbmUgYmxvY2sgb2Ygd29yZHMuXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRfYmxvY2s6IGZ1bmN0aW9uICh3b3Jkcykge1xuXHRcdGNvbnN0IHNoYTEgPSB0aGlzO1xuXHRcdGNvbnN0IGggPSBzaGExLl9oO1xuXHRcdC8vIFdoZW4gd29yZHMgaXMgcGFzc2VkIHRvIF9ibG9jaywgaXQgaGFzIDE2IGVsZW1lbnRzLiBTSEExIF9ibG9ja1xuXHRcdC8vIGZ1bmN0aW9uIGV4dGVuZHMgd29yZHMgd2l0aCBuZXcgZWxlbWVudHMgKGF0IHRoZSBlbmQgdGhlcmUgYXJlIDgwIGVsZW1lbnRzKS4gXG5cdFx0Ly8gVGhlIHByb2JsZW0gaXMgdGhhdCBpZiB3ZSB1c2UgVWludDMyQXJyYXkgaW5zdGVhZCBvZiBBcnJheSwgXG5cdFx0Ly8gdGhlIGxlbmd0aCBvZiBVaW50MzJBcnJheSBjYW5ub3QgYmUgY2hhbmdlZC4gVGh1cywgd2UgcmVwbGFjZSB3b3JkcyB3aXRoIGEgXG5cdFx0Ly8gbm9ybWFsIEFycmF5IGhlcmUuXG5cdFx0Y29uc3QgdyA9IEFycmF5KDgwKTsgLy8gZG8gbm90IHVzZSBVaW50MzJBcnJheSBoZXJlIGFzIHRoZSBpbnN0YW50aWF0aW9uIGlzIHNsb3dlclxuXHRcdGZvciAobGV0IGogPSAwOyBqIDwgMTY7IGorKykge1xuXHRcdFx0d1tqXSA9IHdvcmRzW2pdO1xuXHRcdH1cblxuXHRcdGxldCBhID0gaFswXTtcblx0XHRsZXQgYiA9IGhbMV07XG5cdFx0bGV0IGMgPSBoWzJdO1xuXHRcdGxldCBkID0gaFszXTtcblx0XHRsZXQgZSA9IGhbNF07XG5cblx0XHRmb3IgKGxldCB0ID0gMDsgdCA8PSA3OTsgdCsrKSB7XG5cdFx0XHRpZiAodCA+PSAxNikge1xuXHRcdFx0XHR3W3RdID0gc2hhMS5fUygxLCB3W3QgLSAzXSBeIHdbdCAtIDhdIF4gd1t0IC0gMTRdIF4gd1t0IC0gMTZdKTtcblx0XHRcdH1cblx0XHRcdGNvbnN0IHRtcCA9IChzaGExLl9TKDUsIGEpICsgc2hhMS5fZih0LCBiLCBjLCBkKSArIGUgKyB3W3RdICtcblx0XHRcdFx0c2hhMS5fa2V5W01hdGguZmxvb3IodCAvIDIwKV0pIHwgMDtcblx0XHRcdGUgPSBkO1xuXHRcdFx0ZCA9IGM7XG5cdFx0XHRjID0gc2hhMS5fUygzMCwgYik7XG5cdFx0XHRiID0gYTtcblx0XHRcdGEgPSB0bXA7XG5cdFx0fVxuXG5cdFx0aFswXSA9IChoWzBdICsgYSkgfCAwO1xuXHRcdGhbMV0gPSAoaFsxXSArIGIpIHwgMDtcblx0XHRoWzJdID0gKGhbMl0gKyBjKSB8IDA7XG5cdFx0aFszXSA9IChoWzNdICsgZCkgfCAwO1xuXHRcdGhbNF0gPSAoaFs0XSArIGUpIHwgMDtcblx0fVxufTtcblxuLyoqIEBmaWxlT3ZlcnZpZXcgTG93LWxldmVsIEFFUyBpbXBsZW1lbnRhdGlvbi5cbiAqXG4gKiBUaGlzIGZpbGUgY29udGFpbnMgYSBsb3ctbGV2ZWwgaW1wbGVtZW50YXRpb24gb2YgQUVTLCBvcHRpbWl6ZWQgZm9yXG4gKiBzaXplIGFuZCBmb3IgZWZmaWNpZW5jeSBvbiBzZXZlcmFsIGJyb3dzZXJzLiAgSXQgaXMgYmFzZWQgb25cbiAqIE9wZW5TU0wncyBhZXNfY29yZS5jLCBhIHB1YmxpYy1kb21haW4gaW1wbGVtZW50YXRpb24gYnkgVmluY2VudFxuICogUmlqbWVuLCBBbnRvb24gQm9zc2VsYWVycyBhbmQgUGF1bG8gQmFycmV0by5cbiAqXG4gKiBBbiBvbGRlciB2ZXJzaW9uIG9mIHRoaXMgaW1wbGVtZW50YXRpb24gaXMgYXZhaWxhYmxlIGluIHRoZSBwdWJsaWNcbiAqIGRvbWFpbiwgYnV0IHRoaXMgb25lIGlzIChjKSBFbWlseSBTdGFyaywgTWlrZSBIYW1idXJnLCBEYW4gQm9uZWgsXG4gKiBTdGFuZm9yZCBVbml2ZXJzaXR5IDIwMDgtMjAxMCBhbmQgQlNELWxpY2Vuc2VkIGZvciBsaWFiaWxpdHlcbiAqIHJlYXNvbnMuXG4gKlxuICogQGF1dGhvciBFbWlseSBTdGFya1xuICogQGF1dGhvciBNaWtlIEhhbWJ1cmdcbiAqIEBhdXRob3IgRGFuIEJvbmVoXG4gKi9cblxuY29uc3QgY2lwaGVyID0ge307XG5cbi8qKlxuICogU2NoZWR1bGUgb3V0IGFuIEFFUyBrZXkgZm9yIGJvdGggZW5jcnlwdGlvbiBhbmQgZGVjcnlwdGlvbi4gIFRoaXNcbiAqIGlzIGEgbG93LWxldmVsIGNsYXNzLiAgVXNlIGEgY2lwaGVyIG1vZGUgdG8gZG8gYnVsayBlbmNyeXB0aW9uLlxuICpcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtBcnJheX0ga2V5IFRoZSBrZXkgYXMgYW4gYXJyYXkgb2YgNCwgNiBvciA4IHdvcmRzLlxuICovXG5jaXBoZXIuYWVzID0gY2xhc3Mge1xuXHRjb25zdHJ1Y3RvcihrZXkpIHtcblx0XHQvKipcblx0XHQgKiBUaGUgZXhwYW5kZWQgUy1ib3ggYW5kIGludmVyc2UgUy1ib3ggdGFibGVzLiAgVGhlc2Ugd2lsbCBiZSBjb21wdXRlZFxuXHRcdCAqIG9uIHRoZSBjbGllbnQgc28gdGhhdCB3ZSBkb24ndCBoYXZlIHRvIHNlbmQgdGhlbSBkb3duIHRoZSB3aXJlLlxuXHRcdCAqXG5cdFx0ICogVGhlcmUgYXJlIHR3byB0YWJsZXMsIF90YWJsZXNbMF0gaXMgZm9yIGVuY3J5cHRpb24gYW5kXG5cdFx0ICogX3RhYmxlc1sxXSBpcyBmb3IgZGVjcnlwdGlvbi5cblx0XHQgKlxuXHRcdCAqIFRoZSBmaXJzdCA0IHN1Yi10YWJsZXMgYXJlIHRoZSBleHBhbmRlZCBTLWJveCB3aXRoIE1peENvbHVtbnMuICBUaGVcblx0XHQgKiBsYXN0IChfdGFibGVzWzAxXVs0XSkgaXMgdGhlIFMtYm94IGl0c2VsZi5cblx0XHQgKlxuXHRcdCAqIEBwcml2YXRlXG5cdFx0ICovXG5cdFx0Y29uc3QgYWVzID0gdGhpcztcblx0XHRhZXMuX3RhYmxlcyA9IFtbW10sIFtdLCBbXSwgW10sIFtdXSwgW1tdLCBbXSwgW10sIFtdLCBbXV1dO1xuXG5cdFx0aWYgKCFhZXMuX3RhYmxlc1swXVswXVswXSkge1xuXHRcdFx0YWVzLl9wcmVjb21wdXRlKCk7XG5cdFx0fVxuXG5cdFx0Y29uc3Qgc2JveCA9IGFlcy5fdGFibGVzWzBdWzRdO1xuXHRcdGNvbnN0IGRlY1RhYmxlID0gYWVzLl90YWJsZXNbMV07XG5cdFx0Y29uc3Qga2V5TGVuID0ga2V5Lmxlbmd0aDtcblxuXHRcdGxldCBpLCBlbmNLZXksIGRlY0tleSwgcmNvbiA9IDE7XG5cblx0XHRpZiAoa2V5TGVuICE9PSA0ICYmIGtleUxlbiAhPT0gNiAmJiBrZXlMZW4gIT09IDgpIHtcblx0XHRcdHRocm93IG5ldyBFcnJvcihcImludmFsaWQgYWVzIGtleSBzaXplXCIpO1xuXHRcdH1cblxuXHRcdGFlcy5fa2V5ID0gW2VuY0tleSA9IGtleS5zbGljZSgwKSwgZGVjS2V5ID0gW11dO1xuXG5cdFx0Ly8gc2NoZWR1bGUgZW5jcnlwdGlvbiBrZXlzXG5cdFx0Zm9yIChpID0ga2V5TGVuOyBpIDwgNCAqIGtleUxlbiArIDI4OyBpKyspIHtcblx0XHRcdGxldCB0bXAgPSBlbmNLZXlbaSAtIDFdO1xuXG5cdFx0XHQvLyBhcHBseSBzYm94XG5cdFx0XHRpZiAoaSAlIGtleUxlbiA9PT0gMCB8fCAoa2V5TGVuID09PSA4ICYmIGkgJSBrZXlMZW4gPT09IDQpKSB7XG5cdFx0XHRcdHRtcCA9IHNib3hbdG1wID4+PiAyNF0gPDwgMjQgXiBzYm94W3RtcCA+PiAxNiAmIDI1NV0gPDwgMTYgXiBzYm94W3RtcCA+PiA4ICYgMjU1XSA8PCA4IF4gc2JveFt0bXAgJiAyNTVdO1xuXG5cdFx0XHRcdC8vIHNoaWZ0IHJvd3MgYW5kIGFkZCByY29uXG5cdFx0XHRcdGlmIChpICUga2V5TGVuID09PSAwKSB7XG5cdFx0XHRcdFx0dG1wID0gdG1wIDw8IDggXiB0bXAgPj4+IDI0IF4gcmNvbiA8PCAyNDtcblx0XHRcdFx0XHRyY29uID0gcmNvbiA8PCAxIF4gKHJjb24gPj4gNykgKiAyODM7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0ZW5jS2V5W2ldID0gZW5jS2V5W2kgLSBrZXlMZW5dIF4gdG1wO1xuXHRcdH1cblxuXHRcdC8vIHNjaGVkdWxlIGRlY3J5cHRpb24ga2V5c1xuXHRcdGZvciAobGV0IGogPSAwOyBpOyBqKyssIGktLSkge1xuXHRcdFx0Y29uc3QgdG1wID0gZW5jS2V5W2ogJiAzID8gaSA6IGkgLSA0XTtcblx0XHRcdGlmIChpIDw9IDQgfHwgaiA8IDQpIHtcblx0XHRcdFx0ZGVjS2V5W2pdID0gdG1wO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0ZGVjS2V5W2pdID0gZGVjVGFibGVbMF1bc2JveFt0bXAgPj4+IDI0XV0gXlxuXHRcdFx0XHRcdGRlY1RhYmxlWzFdW3Nib3hbdG1wID4+IDE2ICYgMjU1XV0gXlxuXHRcdFx0XHRcdGRlY1RhYmxlWzJdW3Nib3hbdG1wID4+IDggJiAyNTVdXSBeXG5cdFx0XHRcdFx0ZGVjVGFibGVbM11bc2JveFt0bXAgJiAyNTVdXTtcblx0XHRcdH1cblx0XHR9XG5cdH1cblx0Ly8gcHVibGljXG5cdC8qIFNvbWV0aGluZyBsaWtlIHRoaXMgbWlnaHQgYXBwZWFyIGhlcmUgZXZlbnR1YWxseVxuXHRuYW1lOiBcIkFFU1wiLFxuXHRibG9ja1NpemU6IDQsXG5cdGtleVNpemVzOiBbNCw2LDhdLFxuXHQqL1xuXG5cdC8qKlxuXHQgKiBFbmNyeXB0IGFuIGFycmF5IG9mIDQgYmlnLWVuZGlhbiB3b3Jkcy5cblx0ICogQHBhcmFtIHtBcnJheX0gZGF0YSBUaGUgcGxhaW50ZXh0LlxuXHQgKiBAcmV0dXJuIHtBcnJheX0gVGhlIGNpcGhlcnRleHQuXG5cdCAqL1xuXHRlbmNyeXB0KGRhdGEpIHtcblx0XHRyZXR1cm4gdGhpcy5fY3J5cHQoZGF0YSwgMCk7XG5cdH1cblxuXHQvKipcblx0ICogRGVjcnlwdCBhbiBhcnJheSBvZiA0IGJpZy1lbmRpYW4gd29yZHMuXG5cdCAqIEBwYXJhbSB7QXJyYXl9IGRhdGEgVGhlIGNpcGhlcnRleHQuXG5cdCAqIEByZXR1cm4ge0FycmF5fSBUaGUgcGxhaW50ZXh0LlxuXHQgKi9cblx0ZGVjcnlwdChkYXRhKSB7XG5cdFx0cmV0dXJuIHRoaXMuX2NyeXB0KGRhdGEsIDEpO1xuXHR9XG5cblx0LyoqXG5cdCAqIEV4cGFuZCB0aGUgUy1ib3ggdGFibGVzLlxuXHQgKlxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0X3ByZWNvbXB1dGUoKSB7XG5cdFx0Y29uc3QgZW5jVGFibGUgPSB0aGlzLl90YWJsZXNbMF07XG5cdFx0Y29uc3QgZGVjVGFibGUgPSB0aGlzLl90YWJsZXNbMV07XG5cdFx0Y29uc3Qgc2JveCA9IGVuY1RhYmxlWzRdO1xuXHRcdGNvbnN0IHNib3hJbnYgPSBkZWNUYWJsZVs0XTtcblx0XHRjb25zdCBkID0gW107XG5cdFx0Y29uc3QgdGggPSBbXTtcblx0XHRsZXQgeEludiwgeDIsIHg0LCB4ODtcblxuXHRcdC8vIENvbXB1dGUgZG91YmxlIGFuZCB0aGlyZCB0YWJsZXNcblx0XHRmb3IgKGxldCBpID0gMDsgaSA8IDI1NjsgaSsrKSB7XG5cdFx0XHR0aFsoZFtpXSA9IGkgPDwgMSBeIChpID4+IDcpICogMjgzKSBeIGldID0gaTtcblx0XHR9XG5cblx0XHRmb3IgKGxldCB4ID0geEludiA9IDA7ICFzYm94W3hdOyB4IF49IHgyIHx8IDEsIHhJbnYgPSB0aFt4SW52XSB8fCAxKSB7XG5cdFx0XHQvLyBDb21wdXRlIHNib3hcblx0XHRcdGxldCBzID0geEludiBeIHhJbnYgPDwgMSBeIHhJbnYgPDwgMiBeIHhJbnYgPDwgMyBeIHhJbnYgPDwgNDtcblx0XHRcdHMgPSBzID4+IDggXiBzICYgMjU1IF4gOTk7XG5cdFx0XHRzYm94W3hdID0gcztcblx0XHRcdHNib3hJbnZbc10gPSB4O1xuXG5cdFx0XHQvLyBDb21wdXRlIE1peENvbHVtbnNcblx0XHRcdHg4ID0gZFt4NCA9IGRbeDIgPSBkW3hdXV07XG5cdFx0XHRsZXQgdERlYyA9IHg4ICogMHgxMDEwMTAxIF4geDQgKiAweDEwMDAxIF4geDIgKiAweDEwMSBeIHggKiAweDEwMTAxMDA7XG5cdFx0XHRsZXQgdEVuYyA9IGRbc10gKiAweDEwMSBeIHMgKiAweDEwMTAxMDA7XG5cblx0XHRcdGZvciAobGV0IGkgPSAwOyBpIDwgNDsgaSsrKSB7XG5cdFx0XHRcdGVuY1RhYmxlW2ldW3hdID0gdEVuYyA9IHRFbmMgPDwgMjQgXiB0RW5jID4+PiA4O1xuXHRcdFx0XHRkZWNUYWJsZVtpXVtzXSA9IHREZWMgPSB0RGVjIDw8IDI0IF4gdERlYyA+Pj4gODtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBDb21wYWN0aWZ5LiAgQ29uc2lkZXJhYmxlIHNwZWVkdXAgb24gRmlyZWZveC5cblx0XHRmb3IgKGxldCBpID0gMDsgaSA8IDU7IGkrKykge1xuXHRcdFx0ZW5jVGFibGVbaV0gPSBlbmNUYWJsZVtpXS5zbGljZSgwKTtcblx0XHRcdGRlY1RhYmxlW2ldID0gZGVjVGFibGVbaV0uc2xpY2UoMCk7XG5cdFx0fVxuXHR9XG5cblx0LyoqXG5cdCAqIEVuY3J5cHRpb24gYW5kIGRlY3J5cHRpb24gY29yZS5cblx0ICogQHBhcmFtIHtBcnJheX0gaW5wdXQgRm91ciB3b3JkcyB0byBiZSBlbmNyeXB0ZWQgb3IgZGVjcnlwdGVkLlxuXHQgKiBAcGFyYW0gZGlyIFRoZSBkaXJlY3Rpb24sIDAgZm9yIGVuY3J5cHQgYW5kIDEgZm9yIGRlY3J5cHQuXG5cdCAqIEByZXR1cm4ge0FycmF5fSBUaGUgZm91ciBlbmNyeXB0ZWQgb3IgZGVjcnlwdGVkIHdvcmRzLlxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0X2NyeXB0KGlucHV0LCBkaXIpIHtcblx0XHRpZiAoaW5wdXQubGVuZ3RoICE9PSA0KSB7XG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIGFlcyBibG9jayBzaXplXCIpO1xuXHRcdH1cblxuXHRcdGNvbnN0IGtleSA9IHRoaXMuX2tleVtkaXJdO1xuXG5cdFx0Y29uc3QgbklubmVyUm91bmRzID0ga2V5Lmxlbmd0aCAvIDQgLSAyO1xuXHRcdGNvbnN0IG91dCA9IFswLCAwLCAwLCAwXTtcblx0XHRjb25zdCB0YWJsZSA9IHRoaXMuX3RhYmxlc1tkaXJdO1xuXG5cdFx0Ly8gbG9hZCB1cCB0aGUgdGFibGVzXG5cdFx0Y29uc3QgdDAgPSB0YWJsZVswXTtcblx0XHRjb25zdCB0MSA9IHRhYmxlWzFdO1xuXHRcdGNvbnN0IHQyID0gdGFibGVbMl07XG5cdFx0Y29uc3QgdDMgPSB0YWJsZVszXTtcblx0XHRjb25zdCBzYm94ID0gdGFibGVbNF07XG5cblx0XHQvLyBzdGF0ZSB2YXJpYWJsZXMgYSxiLGMsZCBhcmUgbG9hZGVkIHdpdGggcHJlLXdoaXRlbmVkIGRhdGFcblx0XHRsZXQgYSA9IGlucHV0WzBdIF4ga2V5WzBdO1xuXHRcdGxldCBiID0gaW5wdXRbZGlyID8gMyA6IDFdIF4ga2V5WzFdO1xuXHRcdGxldCBjID0gaW5wdXRbMl0gXiBrZXlbMl07XG5cdFx0bGV0IGQgPSBpbnB1dFtkaXIgPyAxIDogM10gXiBrZXlbM107XG5cdFx0bGV0IGtJbmRleCA9IDQ7XG5cdFx0bGV0IGEyLCBiMiwgYzI7XG5cblx0XHQvLyBJbm5lciByb3VuZHMuICBDcmliYmVkIGZyb20gT3BlblNTTC5cblx0XHRmb3IgKGxldCBpID0gMDsgaSA8IG5Jbm5lclJvdW5kczsgaSsrKSB7XG5cdFx0XHRhMiA9IHQwW2EgPj4+IDI0XSBeIHQxW2IgPj4gMTYgJiAyNTVdIF4gdDJbYyA+PiA4ICYgMjU1XSBeIHQzW2QgJiAyNTVdIF4ga2V5W2tJbmRleF07XG5cdFx0XHRiMiA9IHQwW2IgPj4+IDI0XSBeIHQxW2MgPj4gMTYgJiAyNTVdIF4gdDJbZCA+PiA4ICYgMjU1XSBeIHQzW2EgJiAyNTVdIF4ga2V5W2tJbmRleCArIDFdO1xuXHRcdFx0YzIgPSB0MFtjID4+PiAyNF0gXiB0MVtkID4+IDE2ICYgMjU1XSBeIHQyW2EgPj4gOCAmIDI1NV0gXiB0M1tiICYgMjU1XSBeIGtleVtrSW5kZXggKyAyXTtcblx0XHRcdGQgPSB0MFtkID4+PiAyNF0gXiB0MVthID4+IDE2ICYgMjU1XSBeIHQyW2IgPj4gOCAmIDI1NV0gXiB0M1tjICYgMjU1XSBeIGtleVtrSW5kZXggKyAzXTtcblx0XHRcdGtJbmRleCArPSA0O1xuXHRcdFx0YSA9IGEyOyBiID0gYjI7IGMgPSBjMjtcblx0XHR9XG5cblx0XHQvLyBMYXN0IHJvdW5kLlxuXHRcdGZvciAobGV0IGkgPSAwOyBpIDwgNDsgaSsrKSB7XG5cdFx0XHRvdXRbZGlyID8gMyAmIC1pIDogaV0gPVxuXHRcdFx0XHRzYm94W2EgPj4+IDI0XSA8PCAyNCBeXG5cdFx0XHRcdHNib3hbYiA+PiAxNiAmIDI1NV0gPDwgMTYgXlxuXHRcdFx0XHRzYm94W2MgPj4gOCAmIDI1NV0gPDwgOCBeXG5cdFx0XHRcdHNib3hbZCAmIDI1NV0gXlxuXHRcdFx0XHRrZXlba0luZGV4KytdO1xuXHRcdFx0YTIgPSBhOyBhID0gYjsgYiA9IGM7IGMgPSBkOyBkID0gYTI7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIG91dDtcblx0fVxufTtcblxuLyoqIEBmaWxlT3ZlcnZpZXcgQ1RSIG1vZGUgaW1wbGVtZW50YXRpb24uXG4gKlxuICogU3BlY2lhbCB0aGFua3MgdG8gUm95IE5pY2hvbHNvbiBmb3IgcG9pbnRpbmcgb3V0IGEgYnVnIGluIG91clxuICogaW1wbGVtZW50YXRpb24uXG4gKlxuICogQGF1dGhvciBFbWlseSBTdGFya1xuICogQGF1dGhvciBNaWtlIEhhbWJ1cmdcbiAqIEBhdXRob3IgRGFuIEJvbmVoXG4gKi9cblxuLyoqIEJyaWFuIEdsYWRtYW4ncyBDVFIgTW9kZS5cbiogQGNvbnN0cnVjdG9yXG4qIEBwYXJhbSB7T2JqZWN0fSBfcHJmIFRoZSBhZXMgaW5zdGFuY2UgdG8gZ2VuZXJhdGUga2V5LlxuKiBAcGFyYW0ge2JpdEFycmF5fSBfaXYgVGhlIGl2IGZvciBjdHIgbW9kZSwgaXQgbXVzdCBiZSAxMjggYml0cy5cbiovXG5cbmNvbnN0IG1vZGUgPSB7fTtcblxuLyoqXG4gKiBCcmlhbiBHbGFkbWFuJ3MgQ1RSIE1vZGUuXG4gKiBAbmFtZXNwYWNlXG4gKi9cbm1vZGUuY3RyR2xhZG1hbiA9IGNsYXNzIHtcblx0Y29uc3RydWN0b3IocHJmLCBpdikge1xuXHRcdHRoaXMuX3ByZiA9IHByZjtcblx0XHR0aGlzLl9pbml0SXYgPSBpdjtcblx0XHR0aGlzLl9pdiA9IGl2O1xuXHR9XG5cblx0cmVzZXQoKSB7XG5cdFx0dGhpcy5faXYgPSB0aGlzLl9pbml0SXY7XG5cdH1cblxuXHQvKiogSW5wdXQgc29tZSBkYXRhIHRvIGNhbGN1bGF0ZS5cblx0ICogQHBhcmFtIHtiaXRBcnJheX0gZGF0YSB0aGUgZGF0YSB0byBwcm9jZXNzLCBpdCBtdXN0IGJlIGludGVyZ3JhbCBtdWx0aXBsZSBvZiAxMjggYml0cyB1bmxlc3MgaXQncyB0aGUgbGFzdC5cblx0ICovXG5cdHVwZGF0ZShkYXRhKSB7XG5cdFx0cmV0dXJuIHRoaXMuY2FsY3VsYXRlKHRoaXMuX3ByZiwgZGF0YSwgdGhpcy5faXYpO1xuXHR9XG5cblx0aW5jV29yZCh3b3JkKSB7XG5cdFx0aWYgKCgod29yZCA+PiAyNCkgJiAweGZmKSA9PT0gMHhmZikgeyAvL292ZXJmbG93XG5cdFx0XHRsZXQgYjEgPSAod29yZCA+PiAxNikgJiAweGZmO1xuXHRcdFx0bGV0IGIyID0gKHdvcmQgPj4gOCkgJiAweGZmO1xuXHRcdFx0bGV0IGIzID0gd29yZCAmIDB4ZmY7XG5cblx0XHRcdGlmIChiMSA9PT0gMHhmZikgeyAvLyBvdmVyZmxvdyBiMSAgIFxuXHRcdFx0XHRiMSA9IDA7XG5cdFx0XHRcdGlmIChiMiA9PT0gMHhmZikge1xuXHRcdFx0XHRcdGIyID0gMDtcblx0XHRcdFx0XHRpZiAoYjMgPT09IDB4ZmYpIHtcblx0XHRcdFx0XHRcdGIzID0gMDtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0KytiMztcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0KytiMjtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0KytiMTtcblx0XHRcdH1cblxuXHRcdFx0d29yZCA9IDA7XG5cdFx0XHR3b3JkICs9IChiMSA8PCAxNik7XG5cdFx0XHR3b3JkICs9IChiMiA8PCA4KTtcblx0XHRcdHdvcmQgKz0gYjM7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHdvcmQgKz0gKDB4MDEgPDwgMjQpO1xuXHRcdH1cblx0XHRyZXR1cm4gd29yZDtcblx0fVxuXG5cdGluY0NvdW50ZXIoY291bnRlcikge1xuXHRcdGlmICgoY291bnRlclswXSA9IHRoaXMuaW5jV29yZChjb3VudGVyWzBdKSkgPT09IDApIHtcblx0XHRcdC8vIGVuY3JfZGF0YSBpbiBmaWxlZW5jLmMgZnJvbSAgRHIgQnJpYW4gR2xhZG1hbidzIGNvdW50cyBvbmx5IHdpdGggRFdPUkQgaiA8IDhcblx0XHRcdGNvdW50ZXJbMV0gPSB0aGlzLmluY1dvcmQoY291bnRlclsxXSk7XG5cdFx0fVxuXHR9XG5cblx0Y2FsY3VsYXRlKHByZiwgZGF0YSwgaXYpIHtcblx0XHRsZXQgbDtcblx0XHRpZiAoIShsID0gZGF0YS5sZW5ndGgpKSB7XG5cdFx0XHRyZXR1cm4gW107XG5cdFx0fVxuXHRcdGNvbnN0IGJsID0gYml0QXJyYXkuYml0TGVuZ3RoKGRhdGEpO1xuXHRcdGZvciAobGV0IGkgPSAwOyBpIDwgbDsgaSArPSA0KSB7XG5cdFx0XHR0aGlzLmluY0NvdW50ZXIoaXYpO1xuXHRcdFx0Y29uc3QgZSA9IHByZi5lbmNyeXB0KGl2KTtcblx0XHRcdGRhdGFbaV0gXj0gZVswXTtcblx0XHRcdGRhdGFbaSArIDFdIF49IGVbMV07XG5cdFx0XHRkYXRhW2kgKyAyXSBePSBlWzJdO1xuXHRcdFx0ZGF0YVtpICsgM10gXj0gZVszXTtcblx0XHR9XG5cdFx0cmV0dXJuIGJpdEFycmF5LmNsYW1wKGRhdGEsIGJsKTtcblx0fVxufTtcblxuXG5jb25zdCBtaXNjID0ge307XG5cbi8qKiBAZmlsZU92ZXJ2aWV3IEhNQUMgaW1wbGVtZW50YXRpb24uXG4gKlxuICogQGF1dGhvciBFbWlseSBTdGFya1xuICogQGF1dGhvciBNaWtlIEhhbWJ1cmdcbiAqIEBhdXRob3IgRGFuIEJvbmVoXG4gKi9cblxuLyoqIEhNQUMgd2l0aCB0aGUgc3BlY2lmaWVkIGhhc2ggZnVuY3Rpb24uXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7Yml0QXJyYXl9IGtleSB0aGUga2V5IGZvciBITUFDLlxuICogQHBhcmFtIHtPYmplY3R9IFtIYXNoPWhhc2guc2hhMV0gVGhlIGhhc2ggZnVuY3Rpb24gdG8gdXNlLlxuICovXG5taXNjLmhtYWNTaGExID0gY2xhc3Mge1xuXG5cdGNvbnN0cnVjdG9yKGtleSkge1xuXHRcdGNvbnN0IGhtYWMgPSB0aGlzO1xuXHRcdGNvbnN0IEhhc2ggPSBobWFjLl9oYXNoID0gaGFzaC5zaGExO1xuXHRcdGNvbnN0IGV4S2V5ID0gW1tdLCBbXV07XG5cdFx0Y29uc3QgYnMgPSBIYXNoLnByb3RvdHlwZS5ibG9ja1NpemUgLyAzMjtcblx0XHRobWFjLl9iYXNlSGFzaCA9IFtuZXcgSGFzaCgpLCBuZXcgSGFzaCgpXTtcblxuXHRcdGlmIChrZXkubGVuZ3RoID4gYnMpIHtcblx0XHRcdGtleSA9IEhhc2guaGFzaChrZXkpO1xuXHRcdH1cblxuXHRcdGZvciAobGV0IGkgPSAwOyBpIDwgYnM7IGkrKykge1xuXHRcdFx0ZXhLZXlbMF1baV0gPSBrZXlbaV0gXiAweDM2MzYzNjM2O1xuXHRcdFx0ZXhLZXlbMV1baV0gPSBrZXlbaV0gXiAweDVDNUM1QzVDO1xuXHRcdH1cblxuXHRcdGhtYWMuX2Jhc2VIYXNoWzBdLnVwZGF0ZShleEtleVswXSk7XG5cdFx0aG1hYy5fYmFzZUhhc2hbMV0udXBkYXRlKGV4S2V5WzFdKTtcblx0XHRobWFjLl9yZXN1bHRIYXNoID0gbmV3IEhhc2goaG1hYy5fYmFzZUhhc2hbMF0pO1xuXHR9XG5cdHJlc2V0KCkge1xuXHRcdGNvbnN0IGhtYWMgPSB0aGlzO1xuXHRcdGhtYWMuX3Jlc3VsdEhhc2ggPSBuZXcgaG1hYy5faGFzaChobWFjLl9iYXNlSGFzaFswXSk7XG5cdFx0aG1hYy5fdXBkYXRlZCA9IGZhbHNlO1xuXHR9XG5cblx0dXBkYXRlKGRhdGEpIHtcblx0XHRjb25zdCBobWFjID0gdGhpcztcblx0XHRobWFjLl91cGRhdGVkID0gdHJ1ZTtcblx0XHRobWFjLl9yZXN1bHRIYXNoLnVwZGF0ZShkYXRhKTtcblx0fVxuXG5cdGRpZ2VzdCgpIHtcblx0XHRjb25zdCBobWFjID0gdGhpcztcblx0XHRjb25zdCB3ID0gaG1hYy5fcmVzdWx0SGFzaC5maW5hbGl6ZSgpO1xuXHRcdGNvbnN0IHJlc3VsdCA9IG5ldyAoaG1hYy5faGFzaCkoaG1hYy5fYmFzZUhhc2hbMV0pLnVwZGF0ZSh3KS5maW5hbGl6ZSgpO1xuXG5cdFx0aG1hYy5yZXNldCgpO1xuXG5cdFx0cmV0dXJuIHJlc3VsdDtcblx0fVxufTtcblxuLypcbiBDb3B5cmlnaHQgKGMpIDIwMjEgR2lsZGFzIExvcm1lYXUuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG5cbiBSZWRpc3RyaWJ1dGlvbiBhbmQgdXNlIGluIHNvdXJjZSBhbmQgYmluYXJ5IGZvcm1zLCB3aXRoIG9yIHdpdGhvdXRcbiBtb2RpZmljYXRpb24sIGFyZSBwZXJtaXR0ZWQgcHJvdmlkZWQgdGhhdCB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnMgYXJlIG1ldDpcblxuIDEuIFJlZGlzdHJpYnV0aW9ucyBvZiBzb3VyY2UgY29kZSBtdXN0IHJldGFpbiB0aGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSxcbiB0aGlzIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZyBkaXNjbGFpbWVyLlxuXG4gMi4gUmVkaXN0cmlidXRpb25zIGluIGJpbmFyeSBmb3JtIG11c3QgcmVwcm9kdWNlIHRoZSBhYm92ZSBjb3B5cmlnaHQgXG4gbm90aWNlLCB0aGlzIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZyBkaXNjbGFpbWVyIGluIFxuIHRoZSBkb2N1bWVudGF0aW9uIGFuZC9vciBvdGhlciBtYXRlcmlhbHMgcHJvdmlkZWQgd2l0aCB0aGUgZGlzdHJpYnV0aW9uLlxuXG4gMy4gVGhlIG5hbWVzIG9mIHRoZSBhdXRob3JzIG1heSBub3QgYmUgdXNlZCB0byBlbmRvcnNlIG9yIHByb21vdGUgcHJvZHVjdHNcbiBkZXJpdmVkIGZyb20gdGhpcyBzb2Z0d2FyZSB3aXRob3V0IHNwZWNpZmljIHByaW9yIHdyaXR0ZW4gcGVybWlzc2lvbi5cblxuIFRISVMgU09GVFdBUkUgSVMgUFJPVklERUQgJydBUyBJUycnIEFORCBBTlkgRVhQUkVTU0VEIE9SIElNUExJRUQgV0FSUkFOVElFUyxcbiBJTkNMVURJTkcsIEJVVCBOT1QgTElNSVRFRCBUTywgVEhFIElNUExJRUQgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFkgQU5EXG4gRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQVJFIERJU0NMQUlNRUQuIElOIE5PIEVWRU5UIFNIQUxMIEpDUkFGVCxcbiBJTkMuIE9SIEFOWSBDT05UUklCVVRPUlMgVE8gVEhJUyBTT0ZUV0FSRSBCRSBMSUFCTEUgRk9SIEFOWSBESVJFQ1QsIElORElSRUNULFxuIElOQ0lERU5UQUwsIFNQRUNJQUwsIEVYRU1QTEFSWSwgT1IgQ09OU0VRVUVOVElBTCBEQU1BR0VTIChJTkNMVURJTkcsIEJVVCBOT1RcbiBMSU1JVEVEIFRPLCBQUk9DVVJFTUVOVCBPRiBTVUJTVElUVVRFIEdPT0RTIE9SIFNFUlZJQ0VTOyBMT1NTIE9GIFVTRSwgREFUQSxcbiBPUiBQUk9GSVRTOyBPUiBCVVNJTkVTUyBJTlRFUlJVUFRJT04pIEhPV0VWRVIgQ0FVU0VEIEFORCBPTiBBTlkgVEhFT1JZIE9GXG4gTElBQklMSVRZLCBXSEVUSEVSIElOIENPTlRSQUNULCBTVFJJQ1QgTElBQklMSVRZLCBPUiBUT1JUIChJTkNMVURJTkdcbiBORUdMSUdFTkNFIE9SIE9USEVSV0lTRSkgQVJJU0lORyBJTiBBTlkgV0FZIE9VVCBPRiBUSEUgVVNFIE9GIFRISVMgU09GVFdBUkUsXG4gRVZFTiBJRiBBRFZJU0VEIE9GIFRIRSBQT1NTSUJJTElUWSBPRiBTVUNIIERBTUFHRS5cbiAqL1xuXG5jb25zdCBFUlJfSU5WQUxJRF9QQVNTV09SRCA9IFwiSW52YWxpZCBwYXN3b3JkXCI7XG5jb25zdCBCTE9DS19MRU5HVEggPSAxNjtcbmNvbnN0IFJBV19GT1JNQVQgPSBcInJhd1wiO1xuY29uc3QgUEJLREYyX0FMR09SSVRITSA9IHsgbmFtZTogXCJQQktERjJcIiB9O1xuY29uc3QgSEFTSF9BTEdPUklUSE0gPSB7IG5hbWU6IFwiSE1BQ1wiIH07XG5jb25zdCBIQVNIX0ZVTkNUSU9OID0gXCJTSEEtMVwiO1xuY29uc3QgQkFTRV9LRVlfQUxHT1JJVEhNID0gT2JqZWN0LmFzc2lnbih7IGhhc2g6IEhBU0hfQUxHT1JJVEhNIH0sIFBCS0RGMl9BTEdPUklUSE0pO1xuY29uc3QgREVSSVZFRF9CSVRTX0FMR09SSVRITSA9IE9iamVjdC5hc3NpZ24oeyBpdGVyYXRpb25zOiAxMDAwLCBoYXNoOiB7IG5hbWU6IEhBU0hfRlVOQ1RJT04gfSB9LCBQQktERjJfQUxHT1JJVEhNKTtcbmNvbnN0IERFUklWRURfQklUU19VU0FHRSA9IFtcImRlcml2ZUJpdHNcIl07XG5jb25zdCBTQUxUX0xFTkdUSCA9IFs4LCAxMiwgMTZdO1xuY29uc3QgS0VZX0xFTkdUSCA9IFsxNiwgMjQsIDMyXTtcbmNvbnN0IFNJR05BVFVSRV9MRU5HVEggPSAxMDtcbmNvbnN0IENPVU5URVJfREVGQVVMVF9WQUxVRSA9IFswLCAwLCAwLCAwXTtcbmNvbnN0IGNvZGVjQnl0ZXMgPSBjb2RlYy5ieXRlcztcbmNvbnN0IEFlcyA9IGNpcGhlci5hZXM7XG5jb25zdCBDdHJHbGFkbWFuID0gbW9kZS5jdHJHbGFkbWFuO1xuY29uc3QgSG1hY1NoYTEgPSBtaXNjLmhtYWNTaGExO1xuY2xhc3MgQUVTRGVjcnlwdCB7XG5cblx0Y29uc3RydWN0b3IocGFzc3dvcmQsIHNpZ25lZCwgc3RyZW5ndGgpIHtcblx0XHRPYmplY3QuYXNzaWduKHRoaXMsIHtcblx0XHRcdHBhc3N3b3JkLFxuXHRcdFx0c2lnbmVkLFxuXHRcdFx0c3RyZW5ndGg6IHN0cmVuZ3RoIC0gMSxcblx0XHRcdHBlbmRpbmdJbnB1dDogbmV3IFVpbnQ4QXJyYXkoMClcblx0XHR9KTtcblx0fVxuXG5cdGFzeW5jIGFwcGVuZChpbnB1dCkge1xuXHRcdGNvbnN0IGFlc0NyeXB0byA9IHRoaXM7XG5cdFx0aWYgKGFlc0NyeXB0by5wYXNzd29yZCkge1xuXHRcdFx0Y29uc3QgcHJlYW1ibGUgPSBzdWJhcnJheShpbnB1dCwgMCwgU0FMVF9MRU5HVEhbYWVzQ3J5cHRvLnN0cmVuZ3RoXSArIDIpO1xuXHRcdFx0YXdhaXQgY3JlYXRlRGVjcnlwdGlvbktleXMoYWVzQ3J5cHRvLCBwcmVhbWJsZSwgYWVzQ3J5cHRvLnBhc3N3b3JkKTtcblx0XHRcdGFlc0NyeXB0by5wYXNzd29yZCA9IG51bGw7XG5cdFx0XHRhZXNDcnlwdG8uYWVzQ3RyR2xhZG1hbiA9IG5ldyBDdHJHbGFkbWFuKG5ldyBBZXMoYWVzQ3J5cHRvLmtleXMua2V5KSwgQXJyYXkuZnJvbShDT1VOVEVSX0RFRkFVTFRfVkFMVUUpKTtcblx0XHRcdGFlc0NyeXB0by5obWFjID0gbmV3IEhtYWNTaGExKGFlc0NyeXB0by5rZXlzLmF1dGhlbnRpY2F0aW9uKTtcblx0XHRcdGlucHV0ID0gc3ViYXJyYXkoaW5wdXQsIFNBTFRfTEVOR1RIW2Flc0NyeXB0by5zdHJlbmd0aF0gKyAyKTtcblx0XHR9XG5cdFx0Y29uc3Qgb3V0cHV0ID0gbmV3IFVpbnQ4QXJyYXkoaW5wdXQubGVuZ3RoIC0gU0lHTkFUVVJFX0xFTkdUSCAtICgoaW5wdXQubGVuZ3RoIC0gU0lHTkFUVVJFX0xFTkdUSCkgJSBCTE9DS19MRU5HVEgpKTtcblx0XHRyZXR1cm4gYXBwZW5kKGFlc0NyeXB0bywgaW5wdXQsIG91dHB1dCwgMCwgU0lHTkFUVVJFX0xFTkdUSCwgdHJ1ZSk7XG5cdH1cblxuXHRmbHVzaCgpIHtcblx0XHRjb25zdCBhZXNDcnlwdG8gPSB0aGlzO1xuXHRcdGNvbnN0IHBlbmRpbmdJbnB1dCA9IGFlc0NyeXB0by5wZW5kaW5nSW5wdXQ7XG5cdFx0Y29uc3QgY2h1bmtUb0RlY3J5cHQgPSBzdWJhcnJheShwZW5kaW5nSW5wdXQsIDAsIHBlbmRpbmdJbnB1dC5sZW5ndGggLSBTSUdOQVRVUkVfTEVOR1RIKTtcblx0XHRjb25zdCBvcmlnaW5hbFNpZ25hdHVyZSA9IHN1YmFycmF5KHBlbmRpbmdJbnB1dCwgcGVuZGluZ0lucHV0Lmxlbmd0aCAtIFNJR05BVFVSRV9MRU5HVEgpO1xuXHRcdGxldCBkZWNyeXB0ZWRDaHVua0FycmF5ID0gbmV3IFVpbnQ4QXJyYXkoMCk7XG5cdFx0aWYgKGNodW5rVG9EZWNyeXB0Lmxlbmd0aCkge1xuXHRcdFx0Y29uc3QgZW5jcnlwdGVkQ2h1bmsgPSBjb2RlY0J5dGVzLnRvQml0cyhjaHVua1RvRGVjcnlwdCk7XG5cdFx0XHRhZXNDcnlwdG8uaG1hYy51cGRhdGUoZW5jcnlwdGVkQ2h1bmspO1xuXHRcdFx0Y29uc3QgZGVjcnlwdGVkQ2h1bmsgPSBhZXNDcnlwdG8uYWVzQ3RyR2xhZG1hbi51cGRhdGUoZW5jcnlwdGVkQ2h1bmspO1xuXHRcdFx0ZGVjcnlwdGVkQ2h1bmtBcnJheSA9IGNvZGVjQnl0ZXMuZnJvbUJpdHMoZGVjcnlwdGVkQ2h1bmspO1xuXHRcdH1cblx0XHRsZXQgdmFsaWQgPSB0cnVlO1xuXHRcdGlmIChhZXNDcnlwdG8uc2lnbmVkKSB7XG5cdFx0XHRjb25zdCBzaWduYXR1cmUgPSBzdWJhcnJheShjb2RlY0J5dGVzLmZyb21CaXRzKGFlc0NyeXB0by5obWFjLmRpZ2VzdCgpKSwgMCwgU0lHTkFUVVJFX0xFTkdUSCk7XG5cdFx0XHRmb3IgKGxldCBpbmRleFNpZ25hdHVyZSA9IDA7IGluZGV4U2lnbmF0dXJlIDwgU0lHTkFUVVJFX0xFTkdUSDsgaW5kZXhTaWduYXR1cmUrKykge1xuXHRcdFx0XHRpZiAoc2lnbmF0dXJlW2luZGV4U2lnbmF0dXJlXSAhPSBvcmlnaW5hbFNpZ25hdHVyZVtpbmRleFNpZ25hdHVyZV0pIHtcblx0XHRcdFx0XHR2YWxpZCA9IGZhbHNlO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiB7XG5cdFx0XHR2YWxpZCxcblx0XHRcdGRhdGE6IGRlY3J5cHRlZENodW5rQXJyYXlcblx0XHR9O1xuXHR9XG59XG5cbmNsYXNzIEFFU0VuY3J5cHQge1xuXG5cdGNvbnN0cnVjdG9yKHBhc3N3b3JkLCBzdHJlbmd0aCkge1xuXHRcdE9iamVjdC5hc3NpZ24odGhpcywge1xuXHRcdFx0cGFzc3dvcmQsXG5cdFx0XHRzdHJlbmd0aDogc3RyZW5ndGggLSAxLFxuXHRcdFx0cGVuZGluZ0lucHV0OiBuZXcgVWludDhBcnJheSgwKVxuXHRcdH0pO1xuXHR9XG5cblx0YXN5bmMgYXBwZW5kKGlucHV0KSB7XG5cdFx0Y29uc3QgYWVzQ3J5cHRvID0gdGhpcztcblx0XHRsZXQgcHJlYW1ibGUgPSBuZXcgVWludDhBcnJheSgwKTtcblx0XHRpZiAoYWVzQ3J5cHRvLnBhc3N3b3JkKSB7XG5cdFx0XHRwcmVhbWJsZSA9IGF3YWl0IGNyZWF0ZUVuY3J5cHRpb25LZXlzKGFlc0NyeXB0bywgYWVzQ3J5cHRvLnBhc3N3b3JkKTtcblx0XHRcdGFlc0NyeXB0by5wYXNzd29yZCA9IG51bGw7XG5cdFx0XHRhZXNDcnlwdG8uYWVzQ3RyR2xhZG1hbiA9IG5ldyBDdHJHbGFkbWFuKG5ldyBBZXMoYWVzQ3J5cHRvLmtleXMua2V5KSwgQXJyYXkuZnJvbShDT1VOVEVSX0RFRkFVTFRfVkFMVUUpKTtcblx0XHRcdGFlc0NyeXB0by5obWFjID0gbmV3IEhtYWNTaGExKGFlc0NyeXB0by5rZXlzLmF1dGhlbnRpY2F0aW9uKTtcblx0XHR9XG5cdFx0Y29uc3Qgb3V0cHV0ID0gbmV3IFVpbnQ4QXJyYXkocHJlYW1ibGUubGVuZ3RoICsgaW5wdXQubGVuZ3RoIC0gKGlucHV0Lmxlbmd0aCAlIEJMT0NLX0xFTkdUSCkpO1xuXHRcdG91dHB1dC5zZXQocHJlYW1ibGUsIDApO1xuXHRcdHJldHVybiBhcHBlbmQoYWVzQ3J5cHRvLCBpbnB1dCwgb3V0cHV0LCBwcmVhbWJsZS5sZW5ndGgsIDApO1xuXHR9XG5cblx0Zmx1c2goKSB7XG5cdFx0Y29uc3QgYWVzQ3J5cHRvID0gdGhpcztcblx0XHRsZXQgZW5jcnlwdGVkQ2h1bmtBcnJheSA9IG5ldyBVaW50OEFycmF5KDApO1xuXHRcdGlmIChhZXNDcnlwdG8ucGVuZGluZ0lucHV0Lmxlbmd0aCkge1xuXHRcdFx0Y29uc3QgZW5jcnlwdGVkQ2h1bmsgPSBhZXNDcnlwdG8uYWVzQ3RyR2xhZG1hbi51cGRhdGUoY29kZWNCeXRlcy50b0JpdHMoYWVzQ3J5cHRvLnBlbmRpbmdJbnB1dCkpO1xuXHRcdFx0YWVzQ3J5cHRvLmhtYWMudXBkYXRlKGVuY3J5cHRlZENodW5rKTtcblx0XHRcdGVuY3J5cHRlZENodW5rQXJyYXkgPSBjb2RlY0J5dGVzLmZyb21CaXRzKGVuY3J5cHRlZENodW5rKTtcblx0XHR9XG5cdFx0Y29uc3Qgc2lnbmF0dXJlID0gc3ViYXJyYXkoY29kZWNCeXRlcy5mcm9tQml0cyhhZXNDcnlwdG8uaG1hYy5kaWdlc3QoKSksIDAsIFNJR05BVFVSRV9MRU5HVEgpO1xuXHRcdHJldHVybiB7XG5cdFx0XHRkYXRhOiBjb25jYXQoZW5jcnlwdGVkQ2h1bmtBcnJheSwgc2lnbmF0dXJlKSxcblx0XHRcdHNpZ25hdHVyZVxuXHRcdH07XG5cdH1cbn1cblxuZnVuY3Rpb24gYXBwZW5kKGFlc0NyeXB0bywgaW5wdXQsIG91dHB1dCwgcGFkZGluZ1N0YXJ0LCBwYWRkaW5nRW5kLCB2ZXJpZnlTaWduYXR1cmUpIHtcblx0Y29uc3QgaW5wdXRMZW5ndGggPSBpbnB1dC5sZW5ndGggLSBwYWRkaW5nRW5kO1xuXHRpZiAoYWVzQ3J5cHRvLnBlbmRpbmdJbnB1dC5sZW5ndGgpIHtcblx0XHRpbnB1dCA9IGNvbmNhdChhZXNDcnlwdG8ucGVuZGluZ0lucHV0LCBpbnB1dCk7XG5cdFx0b3V0cHV0ID0gZXhwYW5kKG91dHB1dCwgaW5wdXRMZW5ndGggLSAoaW5wdXRMZW5ndGggJSBCTE9DS19MRU5HVEgpKTtcblx0fVxuXHRsZXQgb2Zmc2V0O1xuXHRmb3IgKG9mZnNldCA9IDA7IG9mZnNldCA8PSBpbnB1dExlbmd0aCAtIEJMT0NLX0xFTkdUSDsgb2Zmc2V0ICs9IEJMT0NLX0xFTkdUSCkge1xuXHRcdGNvbnN0IGlucHV0Q2h1bmsgPSBjb2RlY0J5dGVzLnRvQml0cyhzdWJhcnJheShpbnB1dCwgb2Zmc2V0LCBvZmZzZXQgKyBCTE9DS19MRU5HVEgpKTtcblx0XHRpZiAodmVyaWZ5U2lnbmF0dXJlKSB7XG5cdFx0XHRhZXNDcnlwdG8uaG1hYy51cGRhdGUoaW5wdXRDaHVuayk7XG5cdFx0fVxuXHRcdGNvbnN0IG91dHB1dENodW5rID0gYWVzQ3J5cHRvLmFlc0N0ckdsYWRtYW4udXBkYXRlKGlucHV0Q2h1bmspO1xuXHRcdGlmICghdmVyaWZ5U2lnbmF0dXJlKSB7XG5cdFx0XHRhZXNDcnlwdG8uaG1hYy51cGRhdGUob3V0cHV0Q2h1bmspO1xuXHRcdH1cblx0XHRvdXRwdXQuc2V0KGNvZGVjQnl0ZXMuZnJvbUJpdHMob3V0cHV0Q2h1bmspLCBvZmZzZXQgKyBwYWRkaW5nU3RhcnQpO1xuXHR9XG5cdGFlc0NyeXB0by5wZW5kaW5nSW5wdXQgPSBzdWJhcnJheShpbnB1dCwgb2Zmc2V0KTtcblx0cmV0dXJuIG91dHB1dDtcbn1cblxuYXN5bmMgZnVuY3Rpb24gY3JlYXRlRGVjcnlwdGlvbktleXMoZGVjcnlwdCwgcHJlYW1ibGVBcnJheSwgcGFzc3dvcmQpIHtcblx0YXdhaXQgY3JlYXRlS2V5cyQxKGRlY3J5cHQsIHBhc3N3b3JkLCBzdWJhcnJheShwcmVhbWJsZUFycmF5LCAwLCBTQUxUX0xFTkdUSFtkZWNyeXB0LnN0cmVuZ3RoXSkpO1xuXHRjb25zdCBwYXNzd29yZFZlcmlmaWNhdGlvbiA9IHN1YmFycmF5KHByZWFtYmxlQXJyYXksIFNBTFRfTEVOR1RIW2RlY3J5cHQuc3RyZW5ndGhdKTtcblx0Y29uc3QgcGFzc3dvcmRWZXJpZmljYXRpb25LZXkgPSBkZWNyeXB0LmtleXMucGFzc3dvcmRWZXJpZmljYXRpb247XG5cdGlmIChwYXNzd29yZFZlcmlmaWNhdGlvbktleVswXSAhPSBwYXNzd29yZFZlcmlmaWNhdGlvblswXSB8fCBwYXNzd29yZFZlcmlmaWNhdGlvbktleVsxXSAhPSBwYXNzd29yZFZlcmlmaWNhdGlvblsxXSkge1xuXHRcdHRocm93IG5ldyBFcnJvcihFUlJfSU5WQUxJRF9QQVNTV09SRCk7XG5cdH1cbn1cblxuYXN5bmMgZnVuY3Rpb24gY3JlYXRlRW5jcnlwdGlvbktleXMoZW5jcnlwdCwgcGFzc3dvcmQpIHtcblx0Y29uc3Qgc2FsdCA9IGNyeXB0by5nZXRSYW5kb21WYWx1ZXMobmV3IFVpbnQ4QXJyYXkoU0FMVF9MRU5HVEhbZW5jcnlwdC5zdHJlbmd0aF0pKTtcblx0YXdhaXQgY3JlYXRlS2V5cyQxKGVuY3J5cHQsIHBhc3N3b3JkLCBzYWx0KTtcblx0cmV0dXJuIGNvbmNhdChzYWx0LCBlbmNyeXB0LmtleXMucGFzc3dvcmRWZXJpZmljYXRpb24pO1xufVxuXG5hc3luYyBmdW5jdGlvbiBjcmVhdGVLZXlzJDEodGFyZ2V0LCBwYXNzd29yZCwgc2FsdCkge1xuXHRjb25zdCBlbmNvZGVkUGFzc3dvcmQgPSAobmV3IFRleHRFbmNvZGVyKCkpLmVuY29kZShwYXNzd29yZCk7XG5cdGNvbnN0IGJhc2VrZXkgPSBhd2FpdCBjcnlwdG8uc3VidGxlLmltcG9ydEtleShSQVdfRk9STUFULCBlbmNvZGVkUGFzc3dvcmQsIEJBU0VfS0VZX0FMR09SSVRITSwgZmFsc2UsIERFUklWRURfQklUU19VU0FHRSk7XG5cdGNvbnN0IGRlcml2ZWRCaXRzID0gYXdhaXQgY3J5cHRvLnN1YnRsZS5kZXJpdmVCaXRzKE9iamVjdC5hc3NpZ24oeyBzYWx0IH0sIERFUklWRURfQklUU19BTEdPUklUSE0pLCBiYXNla2V5LCA4ICogKChLRVlfTEVOR1RIW3RhcmdldC5zdHJlbmd0aF0gKiAyKSArIDIpKTtcblx0Y29uc3QgY29tcG9zaXRlS2V5ID0gbmV3IFVpbnQ4QXJyYXkoZGVyaXZlZEJpdHMpO1xuXHR0YXJnZXQua2V5cyA9IHtcblx0XHRrZXk6IGNvZGVjQnl0ZXMudG9CaXRzKHN1YmFycmF5KGNvbXBvc2l0ZUtleSwgMCwgS0VZX0xFTkdUSFt0YXJnZXQuc3RyZW5ndGhdKSksXG5cdFx0YXV0aGVudGljYXRpb246IGNvZGVjQnl0ZXMudG9CaXRzKHN1YmFycmF5KGNvbXBvc2l0ZUtleSwgS0VZX0xFTkdUSFt0YXJnZXQuc3RyZW5ndGhdLCBLRVlfTEVOR1RIW3RhcmdldC5zdHJlbmd0aF0gKiAyKSksXG5cdFx0cGFzc3dvcmRWZXJpZmljYXRpb246IHN1YmFycmF5KGNvbXBvc2l0ZUtleSwgS0VZX0xFTkdUSFt0YXJnZXQuc3RyZW5ndGhdICogMilcblx0fTtcbn1cblxuZnVuY3Rpb24gY29uY2F0KGxlZnRBcnJheSwgcmlnaHRBcnJheSkge1xuXHRsZXQgYXJyYXkgPSBsZWZ0QXJyYXk7XG5cdGlmIChsZWZ0QXJyYXkubGVuZ3RoICsgcmlnaHRBcnJheS5sZW5ndGgpIHtcblx0XHRhcnJheSA9IG5ldyBVaW50OEFycmF5KGxlZnRBcnJheS5sZW5ndGggKyByaWdodEFycmF5Lmxlbmd0aCk7XG5cdFx0YXJyYXkuc2V0KGxlZnRBcnJheSwgMCk7XG5cdFx0YXJyYXkuc2V0KHJpZ2h0QXJyYXksIGxlZnRBcnJheS5sZW5ndGgpO1xuXHR9XG5cdHJldHVybiBhcnJheTtcbn1cblxuZnVuY3Rpb24gZXhwYW5kKGlucHV0QXJyYXksIGxlbmd0aCkge1xuXHRpZiAobGVuZ3RoICYmIGxlbmd0aCA+IGlucHV0QXJyYXkubGVuZ3RoKSB7XG5cdFx0Y29uc3QgYXJyYXkgPSBpbnB1dEFycmF5O1xuXHRcdGlucHV0QXJyYXkgPSBuZXcgVWludDhBcnJheShsZW5ndGgpO1xuXHRcdGlucHV0QXJyYXkuc2V0KGFycmF5LCAwKTtcblx0fVxuXHRyZXR1cm4gaW5wdXRBcnJheTtcbn1cblxuZnVuY3Rpb24gc3ViYXJyYXkoYXJyYXksIGJlZ2luLCBlbmQpIHtcblx0cmV0dXJuIGFycmF5LnN1YmFycmF5KGJlZ2luLCBlbmQpO1xufVxuXG4vKlxuIENvcHlyaWdodCAoYykgMjAyMSBHaWxkYXMgTG9ybWVhdS4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cblxuIFJlZGlzdHJpYnV0aW9uIGFuZCB1c2UgaW4gc291cmNlIGFuZCBiaW5hcnkgZm9ybXMsIHdpdGggb3Igd2l0aG91dFxuIG1vZGlmaWNhdGlvbiwgYXJlIHBlcm1pdHRlZCBwcm92aWRlZCB0aGF0IHRoZSBmb2xsb3dpbmcgY29uZGl0aW9ucyBhcmUgbWV0OlxuXG4gMS4gUmVkaXN0cmlidXRpb25zIG9mIHNvdXJjZSBjb2RlIG11c3QgcmV0YWluIHRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlLFxuIHRoaXMgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nIGRpc2NsYWltZXIuXG5cbiAyLiBSZWRpc3RyaWJ1dGlvbnMgaW4gYmluYXJ5IGZvcm0gbXVzdCByZXByb2R1Y2UgdGhlIGFib3ZlIGNvcHlyaWdodCBcbiBub3RpY2UsIHRoaXMgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nIGRpc2NsYWltZXIgaW4gXG4gdGhlIGRvY3VtZW50YXRpb24gYW5kL29yIG90aGVyIG1hdGVyaWFscyBwcm92aWRlZCB3aXRoIHRoZSBkaXN0cmlidXRpb24uXG5cbiAzLiBUaGUgbmFtZXMgb2YgdGhlIGF1dGhvcnMgbWF5IG5vdCBiZSB1c2VkIHRvIGVuZG9yc2Ugb3IgcHJvbW90ZSBwcm9kdWN0c1xuIGRlcml2ZWQgZnJvbSB0aGlzIHNvZnR3YXJlIHdpdGhvdXQgc3BlY2lmaWMgcHJpb3Igd3JpdHRlbiBwZXJtaXNzaW9uLlxuXG4gVEhJUyBTT0ZUV0FSRSBJUyBQUk9WSURFRCAnJ0FTIElTJycgQU5EIEFOWSBFWFBSRVNTRUQgT1IgSU1QTElFRCBXQVJSQU5USUVTLFxuIElOQ0xVRElORywgQlVUIE5PVCBMSU1JVEVEIFRPLCBUSEUgSU1QTElFRCBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSBBTkRcbiBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBUkUgRElTQ0xBSU1FRC4gSU4gTk8gRVZFTlQgU0hBTEwgSkNSQUZULFxuIElOQy4gT1IgQU5ZIENPTlRSSUJVVE9SUyBUTyBUSElTIFNPRlRXQVJFIEJFIExJQUJMRSBGT1IgQU5ZIERJUkVDVCwgSU5ESVJFQ1QsXG4gSU5DSURFTlRBTCwgU1BFQ0lBTCwgRVhFTVBMQVJZLCBPUiBDT05TRVFVRU5USUFMIERBTUFHRVMgKElOQ0xVRElORywgQlVUIE5PVFxuIExJTUlURUQgVE8sIFBST0NVUkVNRU5UIE9GIFNVQlNUSVRVVEUgR09PRFMgT1IgU0VSVklDRVM7IExPU1MgT0YgVVNFLCBEQVRBLFxuIE9SIFBST0ZJVFM7IE9SIEJVU0lORVNTIElOVEVSUlVQVElPTikgSE9XRVZFUiBDQVVTRUQgQU5EIE9OIEFOWSBUSEVPUlkgT0ZcbiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQ09OVFJBQ1QsIFNUUklDVCBMSUFCSUxJVFksIE9SIFRPUlQgKElOQ0xVRElOR1xuIE5FR0xJR0VOQ0UgT1IgT1RIRVJXSVNFKSBBUklTSU5HIElOIEFOWSBXQVkgT1VUIE9GIFRIRSBVU0UgT0YgVEhJUyBTT0ZUV0FSRSxcbiBFVkVOIElGIEFEVklTRUQgT0YgVEhFIFBPU1NJQklMSVRZIE9GIFNVQ0ggREFNQUdFLlxuICovXG5cbmNvbnN0IEhFQURFUl9MRU5HVEggPSAxMjtcblxuY2xhc3MgWmlwQ3J5cHRvRGVjcnlwdCB7XG5cblx0Y29uc3RydWN0b3IocGFzc3dvcmQsIHBhc3N3b3JkVmVyaWZpY2F0aW9uKSB7XG5cdFx0Y29uc3QgemlwQ3J5cHRvID0gdGhpcztcblx0XHRPYmplY3QuYXNzaWduKHppcENyeXB0bywge1xuXHRcdFx0cGFzc3dvcmQsXG5cdFx0XHRwYXNzd29yZFZlcmlmaWNhdGlvblxuXHRcdH0pO1xuXHRcdGNyZWF0ZUtleXMoemlwQ3J5cHRvLCBwYXNzd29yZCk7XG5cdH1cblxuXHRhcHBlbmQoaW5wdXQpIHtcblx0XHRjb25zdCB6aXBDcnlwdG8gPSB0aGlzO1xuXHRcdGlmICh6aXBDcnlwdG8ucGFzc3dvcmQpIHtcblx0XHRcdGNvbnN0IGRlY3J5cHRlZEhlYWRlciA9IGRlY3J5cHQoemlwQ3J5cHRvLCBpbnB1dC5zdWJhcnJheSgwLCBIRUFERVJfTEVOR1RIKSk7XG5cdFx0XHR6aXBDcnlwdG8ucGFzc3dvcmQgPSBudWxsO1xuXHRcdFx0aWYgKGRlY3J5cHRlZEhlYWRlcltIRUFERVJfTEVOR1RIIC0gMV0gIT0gemlwQ3J5cHRvLnBhc3N3b3JkVmVyaWZpY2F0aW9uKSB7XG5cdFx0XHRcdHRocm93IG5ldyBFcnJvcihFUlJfSU5WQUxJRF9QQVNTV09SRCk7XG5cdFx0XHR9XG5cdFx0XHRpbnB1dCA9IGlucHV0LnN1YmFycmF5KEhFQURFUl9MRU5HVEgpO1xuXHRcdH1cblx0XHRyZXR1cm4gZGVjcnlwdCh6aXBDcnlwdG8sIGlucHV0KTtcblx0fVxuXG5cdGZsdXNoKCkge1xuXHRcdHJldHVybiB7XG5cdFx0XHR2YWxpZDogdHJ1ZSxcblx0XHRcdGRhdGE6IG5ldyBVaW50OEFycmF5KDApXG5cdFx0fTtcblx0fVxufVxuXG5jbGFzcyBaaXBDcnlwdG9FbmNyeXB0IHtcblxuXHRjb25zdHJ1Y3RvcihwYXNzd29yZCwgcGFzc3dvcmRWZXJpZmljYXRpb24pIHtcblx0XHRjb25zdCB6aXBDcnlwdG8gPSB0aGlzO1xuXHRcdE9iamVjdC5hc3NpZ24oemlwQ3J5cHRvLCB7XG5cdFx0XHRwYXNzd29yZCxcblx0XHRcdHBhc3N3b3JkVmVyaWZpY2F0aW9uXG5cdFx0fSk7XG5cdFx0Y3JlYXRlS2V5cyh6aXBDcnlwdG8sIHBhc3N3b3JkKTtcblx0fVxuXG5cdGFwcGVuZChpbnB1dCkge1xuXHRcdGNvbnN0IHppcENyeXB0byA9IHRoaXM7XG5cdFx0bGV0IG91dHB1dDtcblx0XHRsZXQgb2Zmc2V0O1xuXHRcdGlmICh6aXBDcnlwdG8ucGFzc3dvcmQpIHtcblx0XHRcdHppcENyeXB0by5wYXNzd29yZCA9IG51bGw7XG5cdFx0XHRjb25zdCBoZWFkZXIgPSBjcnlwdG8uZ2V0UmFuZG9tVmFsdWVzKG5ldyBVaW50OEFycmF5KEhFQURFUl9MRU5HVEgpKTtcblx0XHRcdGhlYWRlcltIRUFERVJfTEVOR1RIIC0gMV0gPSB6aXBDcnlwdG8ucGFzc3dvcmRWZXJpZmljYXRpb247XG5cdFx0XHRvdXRwdXQgPSBuZXcgVWludDhBcnJheShpbnB1dC5sZW5ndGggKyBoZWFkZXIubGVuZ3RoKTtcblx0XHRcdG91dHB1dC5zZXQoZW5jcnlwdCh6aXBDcnlwdG8sIGhlYWRlciksIDApO1xuXHRcdFx0b2Zmc2V0ID0gSEVBREVSX0xFTkdUSDtcblx0XHR9IGVsc2Uge1xuXHRcdFx0b3V0cHV0ID0gbmV3IFVpbnQ4QXJyYXkoaW5wdXQubGVuZ3RoKTtcblx0XHRcdG9mZnNldCA9IDA7XG5cdFx0fVxuXHRcdG91dHB1dC5zZXQoZW5jcnlwdCh6aXBDcnlwdG8sIGlucHV0KSwgb2Zmc2V0KTtcblx0XHRyZXR1cm4gb3V0cHV0O1xuXHR9XG5cblx0Zmx1c2goKSB7XG5cdFx0cmV0dXJuIHtcblx0XHRcdGRhdGE6IG5ldyBVaW50OEFycmF5KDApXG5cdFx0fTtcblx0fVxufVxuXG5mdW5jdGlvbiBkZWNyeXB0KHRhcmdldCwgaW5wdXQpIHtcblx0Y29uc3Qgb3V0cHV0ID0gbmV3IFVpbnQ4QXJyYXkoaW5wdXQubGVuZ3RoKTtcblx0Zm9yIChsZXQgaW5kZXggPSAwOyBpbmRleCA8IGlucHV0Lmxlbmd0aDsgaW5kZXgrKykge1xuXHRcdG91dHB1dFtpbmRleF0gPSBnZXRCeXRlKHRhcmdldCkgXiBpbnB1dFtpbmRleF07XG5cdFx0dXBkYXRlS2V5cyh0YXJnZXQsIG91dHB1dFtpbmRleF0pO1xuXHR9XG5cdHJldHVybiBvdXRwdXQ7XG59XG5cbmZ1bmN0aW9uIGVuY3J5cHQodGFyZ2V0LCBpbnB1dCkge1xuXHRjb25zdCBvdXRwdXQgPSBuZXcgVWludDhBcnJheShpbnB1dC5sZW5ndGgpO1xuXHRmb3IgKGxldCBpbmRleCA9IDA7IGluZGV4IDwgaW5wdXQubGVuZ3RoOyBpbmRleCsrKSB7XG5cdFx0b3V0cHV0W2luZGV4XSA9IGdldEJ5dGUodGFyZ2V0KSBeIGlucHV0W2luZGV4XTtcblx0XHR1cGRhdGVLZXlzKHRhcmdldCwgaW5wdXRbaW5kZXhdKTtcblx0fVxuXHRyZXR1cm4gb3V0cHV0O1xufVxuXG5mdW5jdGlvbiBjcmVhdGVLZXlzKHRhcmdldCwgcGFzc3dvcmQpIHtcblx0dGFyZ2V0LmtleXMgPSBbMHgxMjM0NTY3OCwgMHgyMzQ1Njc4OSwgMHgzNDU2Nzg5MF07XG5cdHRhcmdldC5jcmNLZXkwID0gbmV3IENyYzMyKHRhcmdldC5rZXlzWzBdKTtcblx0dGFyZ2V0LmNyY0tleTIgPSBuZXcgQ3JjMzIodGFyZ2V0LmtleXNbMl0pO1xuXHRmb3IgKGxldCBpbmRleCA9IDA7IGluZGV4IDwgcGFzc3dvcmQubGVuZ3RoOyBpbmRleCsrKSB7XG5cdFx0dXBkYXRlS2V5cyh0YXJnZXQsIHBhc3N3b3JkLmNoYXJDb2RlQXQoaW5kZXgpKTtcblx0fVxufVxuXG5mdW5jdGlvbiB1cGRhdGVLZXlzKHRhcmdldCwgYnl0ZSkge1xuXHR0YXJnZXQuY3JjS2V5MC5hcHBlbmQoW2J5dGVdKTtcblx0dGFyZ2V0LmtleXNbMF0gPSB+dGFyZ2V0LmNyY0tleTAuZ2V0KCk7XG5cdHRhcmdldC5rZXlzWzFdID0gZ2V0SW50MzIodGFyZ2V0LmtleXNbMV0gKyBnZXRJbnQ4KHRhcmdldC5rZXlzWzBdKSk7XG5cdHRhcmdldC5rZXlzWzFdID0gZ2V0SW50MzIoTWF0aC5pbXVsKHRhcmdldC5rZXlzWzFdLCAxMzQ3NzU4MTMpICsgMSk7XG5cdHRhcmdldC5jcmNLZXkyLmFwcGVuZChbdGFyZ2V0LmtleXNbMV0gPj4+IDI0XSk7XG5cdHRhcmdldC5rZXlzWzJdID0gfnRhcmdldC5jcmNLZXkyLmdldCgpO1xufVxuXG5mdW5jdGlvbiBnZXRCeXRlKHRhcmdldCkge1xuXHRjb25zdCB0ZW1wID0gdGFyZ2V0LmtleXNbMl0gfCAyO1xuXHRyZXR1cm4gZ2V0SW50OChNYXRoLmltdWwodGVtcCwgKHRlbXAgXiAxKSkgPj4+IDgpO1xufVxuXG5mdW5jdGlvbiBnZXRJbnQ4KG51bWJlcikge1xuXHRyZXR1cm4gbnVtYmVyICYgMHhGRjtcbn1cblxuZnVuY3Rpb24gZ2V0SW50MzIobnVtYmVyKSB7XG5cdHJldHVybiBudW1iZXIgJiAweEZGRkZGRkZGO1xufVxuXG4vKlxuIENvcHlyaWdodCAoYykgMjAyMSBHaWxkYXMgTG9ybWVhdS4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cblxuIFJlZGlzdHJpYnV0aW9uIGFuZCB1c2UgaW4gc291cmNlIGFuZCBiaW5hcnkgZm9ybXMsIHdpdGggb3Igd2l0aG91dFxuIG1vZGlmaWNhdGlvbiwgYXJlIHBlcm1pdHRlZCBwcm92aWRlZCB0aGF0IHRoZSBmb2xsb3dpbmcgY29uZGl0aW9ucyBhcmUgbWV0OlxuXG4gMS4gUmVkaXN0cmlidXRpb25zIG9mIHNvdXJjZSBjb2RlIG11c3QgcmV0YWluIHRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlLFxuIHRoaXMgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nIGRpc2NsYWltZXIuXG5cbiAyLiBSZWRpc3RyaWJ1dGlvbnMgaW4gYmluYXJ5IGZvcm0gbXVzdCByZXByb2R1Y2UgdGhlIGFib3ZlIGNvcHlyaWdodCBcbiBub3RpY2UsIHRoaXMgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nIGRpc2NsYWltZXIgaW4gXG4gdGhlIGRvY3VtZW50YXRpb24gYW5kL29yIG90aGVyIG1hdGVyaWFscyBwcm92aWRlZCB3aXRoIHRoZSBkaXN0cmlidXRpb24uXG5cbiAzLiBUaGUgbmFtZXMgb2YgdGhlIGF1dGhvcnMgbWF5IG5vdCBiZSB1c2VkIHRvIGVuZG9yc2Ugb3IgcHJvbW90ZSBwcm9kdWN0c1xuIGRlcml2ZWQgZnJvbSB0aGlzIHNvZnR3YXJlIHdpdGhvdXQgc3BlY2lmaWMgcHJpb3Igd3JpdHRlbiBwZXJtaXNzaW9uLlxuXG4gVEhJUyBTT0ZUV0FSRSBJUyBQUk9WSURFRCAnJ0FTIElTJycgQU5EIEFOWSBFWFBSRVNTRUQgT1IgSU1QTElFRCBXQVJSQU5USUVTLFxuIElOQ0xVRElORywgQlVUIE5PVCBMSU1JVEVEIFRPLCBUSEUgSU1QTElFRCBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSBBTkRcbiBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBUkUgRElTQ0xBSU1FRC4gSU4gTk8gRVZFTlQgU0hBTEwgSkNSQUZULFxuIElOQy4gT1IgQU5ZIENPTlRSSUJVVE9SUyBUTyBUSElTIFNPRlRXQVJFIEJFIExJQUJMRSBGT1IgQU5ZIERJUkVDVCwgSU5ESVJFQ1QsXG4gSU5DSURFTlRBTCwgU1BFQ0lBTCwgRVhFTVBMQVJZLCBPUiBDT05TRVFVRU5USUFMIERBTUFHRVMgKElOQ0xVRElORywgQlVUIE5PVFxuIExJTUlURUQgVE8sIFBST0NVUkVNRU5UIE9GIFNVQlNUSVRVVEUgR09PRFMgT1IgU0VSVklDRVM7IExPU1MgT0YgVVNFLCBEQVRBLFxuIE9SIFBST0ZJVFM7IE9SIEJVU0lORVNTIElOVEVSUlVQVElPTikgSE9XRVZFUiBDQVVTRUQgQU5EIE9OIEFOWSBUSEVPUlkgT0ZcbiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQ09OVFJBQ1QsIFNUUklDVCBMSUFCSUxJVFksIE9SIFRPUlQgKElOQ0xVRElOR1xuIE5FR0xJR0VOQ0UgT1IgT1RIRVJXSVNFKSBBUklTSU5HIElOIEFOWSBXQVkgT1VUIE9GIFRIRSBVU0UgT0YgVEhJUyBTT0ZUV0FSRSxcbiBFVkVOIElGIEFEVklTRUQgT0YgVEhFIFBPU1NJQklMSVRZIE9GIFNVQ0ggREFNQUdFLlxuICovXG5cbmNvbnN0IENPREVDX0RFRkxBVEUgPSBcImRlZmxhdGVcIjtcbmNvbnN0IENPREVDX0lORkxBVEUgPSBcImluZmxhdGVcIjtcbmNvbnN0IEVSUl9JTlZBTElEX1NJR05BVFVSRSA9IFwiSW52YWxpZCBzaWduYXR1cmVcIjtcblxuY2xhc3MgSW5mbGF0ZSB7XG5cblx0Y29uc3RydWN0b3IoY29kZWNDb25zdHJ1Y3Rvciwge1xuXHRcdHNpZ25hdHVyZSxcblx0XHRwYXNzd29yZCxcblx0XHRzaWduZWQsXG5cdFx0Y29tcHJlc3NlZCxcblx0XHR6aXBDcnlwdG8sXG5cdFx0cGFzc3dvcmRWZXJpZmljYXRpb24sXG5cdFx0ZW5jcnlwdGlvblN0cmVuZ3RoXG5cdH0sIHsgY2h1bmtTaXplIH0pIHtcblx0XHRjb25zdCBlbmNyeXB0ZWQgPSBCb29sZWFuKHBhc3N3b3JkKTtcblx0XHRPYmplY3QuYXNzaWduKHRoaXMsIHtcblx0XHRcdHNpZ25hdHVyZSxcblx0XHRcdGVuY3J5cHRlZCxcblx0XHRcdHNpZ25lZCxcblx0XHRcdGNvbXByZXNzZWQsXG5cdFx0XHRpbmZsYXRlOiBjb21wcmVzc2VkICYmIG5ldyBjb2RlY0NvbnN0cnVjdG9yKHsgY2h1bmtTaXplIH0pLFxuXHRcdFx0Y3JjMzI6IHNpZ25lZCAmJiBuZXcgQ3JjMzIoKSxcblx0XHRcdHppcENyeXB0byxcblx0XHRcdGRlY3J5cHQ6IGVuY3J5cHRlZCAmJiB6aXBDcnlwdG8gP1xuXHRcdFx0XHRuZXcgWmlwQ3J5cHRvRGVjcnlwdChwYXNzd29yZCwgcGFzc3dvcmRWZXJpZmljYXRpb24pIDpcblx0XHRcdFx0bmV3IEFFU0RlY3J5cHQocGFzc3dvcmQsIHNpZ25lZCwgZW5jcnlwdGlvblN0cmVuZ3RoKVxuXHRcdH0pO1xuXHR9XG5cblx0YXN5bmMgYXBwZW5kKGRhdGEpIHtcblx0XHRjb25zdCBjb2RlYyA9IHRoaXM7XG5cdFx0aWYgKGNvZGVjLmVuY3J5cHRlZCAmJiBkYXRhLmxlbmd0aCkge1xuXHRcdFx0ZGF0YSA9IGF3YWl0IGNvZGVjLmRlY3J5cHQuYXBwZW5kKGRhdGEpO1xuXHRcdH1cblx0XHRpZiAoY29kZWMuY29tcHJlc3NlZCAmJiBkYXRhLmxlbmd0aCkge1xuXHRcdFx0ZGF0YSA9IGF3YWl0IGNvZGVjLmluZmxhdGUuYXBwZW5kKGRhdGEpO1xuXHRcdH1cblx0XHRpZiAoKCFjb2RlYy5lbmNyeXB0ZWQgfHwgY29kZWMuemlwQ3J5cHRvKSAmJiBjb2RlYy5zaWduZWQgJiYgZGF0YS5sZW5ndGgpIHtcblx0XHRcdGNvZGVjLmNyYzMyLmFwcGVuZChkYXRhKTtcblx0XHR9XG5cdFx0cmV0dXJuIGRhdGE7XG5cdH1cblxuXHRhc3luYyBmbHVzaCgpIHtcblx0XHRjb25zdCBjb2RlYyA9IHRoaXM7XG5cdFx0bGV0IHNpZ25hdHVyZTtcblx0XHRsZXQgZGF0YSA9IG5ldyBVaW50OEFycmF5KDApO1xuXHRcdGlmIChjb2RlYy5lbmNyeXB0ZWQpIHtcblx0XHRcdGNvbnN0IHJlc3VsdCA9IGNvZGVjLmRlY3J5cHQuZmx1c2goKTtcblx0XHRcdGlmICghcmVzdWx0LnZhbGlkKSB7XG5cdFx0XHRcdHRocm93IG5ldyBFcnJvcihFUlJfSU5WQUxJRF9TSUdOQVRVUkUpO1xuXHRcdFx0fVxuXHRcdFx0ZGF0YSA9IHJlc3VsdC5kYXRhO1xuXHRcdH1cblx0XHRpZiAoKCFjb2RlYy5lbmNyeXB0ZWQgfHwgY29kZWMuemlwQ3J5cHRvKSAmJiBjb2RlYy5zaWduZWQpIHtcblx0XHRcdGNvbnN0IGRhdGFWaWV3U2lnbmF0dXJlID0gbmV3IERhdGFWaWV3KG5ldyBVaW50OEFycmF5KDQpLmJ1ZmZlcik7XG5cdFx0XHRzaWduYXR1cmUgPSBjb2RlYy5jcmMzMi5nZXQoKTtcblx0XHRcdGRhdGFWaWV3U2lnbmF0dXJlLnNldFVpbnQzMigwLCBzaWduYXR1cmUpO1xuXHRcdFx0aWYgKGNvZGVjLnNpZ25hdHVyZSAhPSBkYXRhVmlld1NpZ25hdHVyZS5nZXRVaW50MzIoMCwgZmFsc2UpKSB7XG5cdFx0XHRcdHRocm93IG5ldyBFcnJvcihFUlJfSU5WQUxJRF9TSUdOQVRVUkUpO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRpZiAoY29kZWMuY29tcHJlc3NlZCkge1xuXHRcdFx0ZGF0YSA9IChhd2FpdCBjb2RlYy5pbmZsYXRlLmFwcGVuZChkYXRhKSkgfHwgbmV3IFVpbnQ4QXJyYXkoMCk7XG5cdFx0XHRhd2FpdCBjb2RlYy5pbmZsYXRlLmZsdXNoKCk7XG5cdFx0fVxuXHRcdHJldHVybiB7IGRhdGEsIHNpZ25hdHVyZSB9O1xuXHR9XG59XG5cbmNsYXNzIERlZmxhdGUge1xuXG5cdGNvbnN0cnVjdG9yKGNvZGVjQ29uc3RydWN0b3IsIHtcblx0XHRlbmNyeXB0ZWQsXG5cdFx0c2lnbmVkLFxuXHRcdGNvbXByZXNzZWQsXG5cdFx0bGV2ZWwsXG5cdFx0emlwQ3J5cHRvLFxuXHRcdHBhc3N3b3JkLFxuXHRcdHBhc3N3b3JkVmVyaWZpY2F0aW9uLFxuXHRcdGVuY3J5cHRpb25TdHJlbmd0aFxuXHR9LCB7IGNodW5rU2l6ZSB9KSB7XG5cdFx0T2JqZWN0LmFzc2lnbih0aGlzLCB7XG5cdFx0XHRlbmNyeXB0ZWQsXG5cdFx0XHRzaWduZWQsXG5cdFx0XHRjb21wcmVzc2VkLFxuXHRcdFx0ZGVmbGF0ZTogY29tcHJlc3NlZCAmJiBuZXcgY29kZWNDb25zdHJ1Y3Rvcih7IGxldmVsOiBsZXZlbCB8fCA1LCBjaHVua1NpemUgfSksXG5cdFx0XHRjcmMzMjogc2lnbmVkICYmIG5ldyBDcmMzMigpLFxuXHRcdFx0emlwQ3J5cHRvLFxuXHRcdFx0ZW5jcnlwdDogZW5jcnlwdGVkICYmIHppcENyeXB0byA/XG5cdFx0XHRcdG5ldyBaaXBDcnlwdG9FbmNyeXB0KHBhc3N3b3JkLCBwYXNzd29yZFZlcmlmaWNhdGlvbikgOlxuXHRcdFx0XHRuZXcgQUVTRW5jcnlwdChwYXNzd29yZCwgZW5jcnlwdGlvblN0cmVuZ3RoKVxuXHRcdH0pO1xuXHR9XG5cblx0YXN5bmMgYXBwZW5kKGlucHV0RGF0YSkge1xuXHRcdGNvbnN0IGNvZGVjID0gdGhpcztcblx0XHRsZXQgZGF0YSA9IGlucHV0RGF0YTtcblx0XHRpZiAoY29kZWMuY29tcHJlc3NlZCAmJiBpbnB1dERhdGEubGVuZ3RoKSB7XG5cdFx0XHRkYXRhID0gYXdhaXQgY29kZWMuZGVmbGF0ZS5hcHBlbmQoaW5wdXREYXRhKTtcblx0XHR9XG5cdFx0aWYgKGNvZGVjLmVuY3J5cHRlZCAmJiBkYXRhLmxlbmd0aCkge1xuXHRcdFx0ZGF0YSA9IGF3YWl0IGNvZGVjLmVuY3J5cHQuYXBwZW5kKGRhdGEpO1xuXHRcdH1cblx0XHRpZiAoKCFjb2RlYy5lbmNyeXB0ZWQgfHwgY29kZWMuemlwQ3J5cHRvKSAmJiBjb2RlYy5zaWduZWQgJiYgaW5wdXREYXRhLmxlbmd0aCkge1xuXHRcdFx0Y29kZWMuY3JjMzIuYXBwZW5kKGlucHV0RGF0YSk7XG5cdFx0fVxuXHRcdHJldHVybiBkYXRhO1xuXHR9XG5cblx0YXN5bmMgZmx1c2goKSB7XG5cdFx0Y29uc3QgY29kZWMgPSB0aGlzO1xuXHRcdGxldCBzaWduYXR1cmU7XG5cdFx0bGV0IGRhdGEgPSBuZXcgVWludDhBcnJheSgwKTtcblx0XHRpZiAoY29kZWMuY29tcHJlc3NlZCkge1xuXHRcdFx0ZGF0YSA9IChhd2FpdCBjb2RlYy5kZWZsYXRlLmZsdXNoKCkpIHx8IG5ldyBVaW50OEFycmF5KDApO1xuXHRcdH1cblx0XHRpZiAoY29kZWMuZW5jcnlwdGVkKSB7XG5cdFx0XHRkYXRhID0gYXdhaXQgY29kZWMuZW5jcnlwdC5hcHBlbmQoZGF0YSk7XG5cdFx0XHRjb25zdCByZXN1bHQgPSBjb2RlYy5lbmNyeXB0LmZsdXNoKCk7XG5cdFx0XHRzaWduYXR1cmUgPSByZXN1bHQuc2lnbmF0dXJlO1xuXHRcdFx0Y29uc3QgbmV3RGF0YSA9IG5ldyBVaW50OEFycmF5KGRhdGEubGVuZ3RoICsgcmVzdWx0LmRhdGEubGVuZ3RoKTtcblx0XHRcdG5ld0RhdGEuc2V0KGRhdGEsIDApO1xuXHRcdFx0bmV3RGF0YS5zZXQocmVzdWx0LmRhdGEsIGRhdGEubGVuZ3RoKTtcblx0XHRcdGRhdGEgPSBuZXdEYXRhO1xuXHRcdH1cblx0XHRpZiAoKCFjb2RlYy5lbmNyeXB0ZWQgfHwgY29kZWMuemlwQ3J5cHRvKSAmJiBjb2RlYy5zaWduZWQpIHtcblx0XHRcdHNpZ25hdHVyZSA9IGNvZGVjLmNyYzMyLmdldCgpO1xuXHRcdH1cblx0XHRyZXR1cm4geyBkYXRhLCBzaWduYXR1cmUgfTtcblx0fVxufVxuXG5mdW5jdGlvbiBjcmVhdGVDb2RlYyQxKGNvZGVjQ29uc3RydWN0b3IsIG9wdGlvbnMsIGNvbmZpZykge1xuXHRpZiAob3B0aW9ucy5jb2RlY1R5cGUuc3RhcnRzV2l0aChDT0RFQ19ERUZMQVRFKSkge1xuXHRcdHJldHVybiBuZXcgRGVmbGF0ZShjb2RlY0NvbnN0cnVjdG9yLCBvcHRpb25zLCBjb25maWcpO1xuXHR9IGVsc2UgaWYgKG9wdGlvbnMuY29kZWNUeXBlLnN0YXJ0c1dpdGgoQ09ERUNfSU5GTEFURSkpIHtcblx0XHRyZXR1cm4gbmV3IEluZmxhdGUoY29kZWNDb25zdHJ1Y3Rvciwgb3B0aW9ucywgY29uZmlnKTtcblx0fVxufVxuXG4vKlxuIENvcHlyaWdodCAoYykgMjAyMSBHaWxkYXMgTG9ybWVhdS4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cblxuIFJlZGlzdHJpYnV0aW9uIGFuZCB1c2UgaW4gc291cmNlIGFuZCBiaW5hcnkgZm9ybXMsIHdpdGggb3Igd2l0aG91dFxuIG1vZGlmaWNhdGlvbiwgYXJlIHBlcm1pdHRlZCBwcm92aWRlZCB0aGF0IHRoZSBmb2xsb3dpbmcgY29uZGl0aW9ucyBhcmUgbWV0OlxuXG4gMS4gUmVkaXN0cmlidXRpb25zIG9mIHNvdXJjZSBjb2RlIG11c3QgcmV0YWluIHRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlLFxuIHRoaXMgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nIGRpc2NsYWltZXIuXG5cbiAyLiBSZWRpc3RyaWJ1dGlvbnMgaW4gYmluYXJ5IGZvcm0gbXVzdCByZXByb2R1Y2UgdGhlIGFib3ZlIGNvcHlyaWdodCBcbiBub3RpY2UsIHRoaXMgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nIGRpc2NsYWltZXIgaW4gXG4gdGhlIGRvY3VtZW50YXRpb24gYW5kL29yIG90aGVyIG1hdGVyaWFscyBwcm92aWRlZCB3aXRoIHRoZSBkaXN0cmlidXRpb24uXG5cbiAzLiBUaGUgbmFtZXMgb2YgdGhlIGF1dGhvcnMgbWF5IG5vdCBiZSB1c2VkIHRvIGVuZG9yc2Ugb3IgcHJvbW90ZSBwcm9kdWN0c1xuIGRlcml2ZWQgZnJvbSB0aGlzIHNvZnR3YXJlIHdpdGhvdXQgc3BlY2lmaWMgcHJpb3Igd3JpdHRlbiBwZXJtaXNzaW9uLlxuXG4gVEhJUyBTT0ZUV0FSRSBJUyBQUk9WSURFRCAnJ0FTIElTJycgQU5EIEFOWSBFWFBSRVNTRUQgT1IgSU1QTElFRCBXQVJSQU5USUVTLFxuIElOQ0xVRElORywgQlVUIE5PVCBMSU1JVEVEIFRPLCBUSEUgSU1QTElFRCBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSBBTkRcbiBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBUkUgRElTQ0xBSU1FRC4gSU4gTk8gRVZFTlQgU0hBTEwgSkNSQUZULFxuIElOQy4gT1IgQU5ZIENPTlRSSUJVVE9SUyBUTyBUSElTIFNPRlRXQVJFIEJFIExJQUJMRSBGT1IgQU5ZIERJUkVDVCwgSU5ESVJFQ1QsXG4gSU5DSURFTlRBTCwgU1BFQ0lBTCwgRVhFTVBMQVJZLCBPUiBDT05TRVFVRU5USUFMIERBTUFHRVMgKElOQ0xVRElORywgQlVUIE5PVFxuIExJTUlURUQgVE8sIFBST0NVUkVNRU5UIE9GIFNVQlNUSVRVVEUgR09PRFMgT1IgU0VSVklDRVM7IExPU1MgT0YgVVNFLCBEQVRBLFxuIE9SIFBST0ZJVFM7IE9SIEJVU0lORVNTIElOVEVSUlVQVElPTikgSE9XRVZFUiBDQVVTRUQgQU5EIE9OIEFOWSBUSEVPUlkgT0ZcbiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQ09OVFJBQ1QsIFNUUklDVCBMSUFCSUxJVFksIE9SIFRPUlQgKElOQ0xVRElOR1xuIE5FR0xJR0VOQ0UgT1IgT1RIRVJXSVNFKSBBUklTSU5HIElOIEFOWSBXQVkgT1VUIE9GIFRIRSBVU0UgT0YgVEhJUyBTT0ZUV0FSRSxcbiBFVkVOIElGIEFEVklTRUQgT0YgVEhFIFBPU1NJQklMSVRZIE9GIFNVQ0ggREFNQUdFLlxuICovXG5cbmNvbnN0IE1FU1NBR0VfSU5JVCA9IFwiaW5pdFwiO1xuY29uc3QgTUVTU0FHRV9BUFBFTkQgPSBcImFwcGVuZFwiO1xuY29uc3QgTUVTU0FHRV9GTFVTSCA9IFwiZmx1c2hcIjtcbmNvbnN0IE1FU1NBR0VfRVZFTlRfVFlQRSA9IFwibWVzc2FnZVwiO1xuXG52YXIgZ2V0V29ya2VyID0gKHdvcmtlckRhdGEsIGNvZGVjQ29uc3RydWN0b3IsIG9wdGlvbnMsIGNvbmZpZywgb25UYXNrRmluaXNoZWQsIHdlYldvcmtlciwgc2NyaXB0cykgPT4ge1xuXHRPYmplY3QuYXNzaWduKHdvcmtlckRhdGEsIHtcblx0XHRidXN5OiB0cnVlLFxuXHRcdGNvZGVjQ29uc3RydWN0b3IsXG5cdFx0b3B0aW9uczogT2JqZWN0LmFzc2lnbih7fSwgb3B0aW9ucyksXG5cdFx0c2NyaXB0cyxcblx0XHR0ZXJtaW5hdGUoKSB7XG5cdFx0XHRpZiAod29ya2VyRGF0YS53b3JrZXIgJiYgIXdvcmtlckRhdGEuYnVzeSkge1xuXHRcdFx0XHR3b3JrZXJEYXRhLndvcmtlci50ZXJtaW5hdGUoKTtcblx0XHRcdFx0d29ya2VyRGF0YS5pbnRlcmZhY2UgPSBudWxsO1xuXHRcdFx0fVxuXHRcdH0sXG5cdFx0b25UYXNrRmluaXNoZWQoKSB7XG5cdFx0XHR3b3JrZXJEYXRhLmJ1c3kgPSBmYWxzZTtcblx0XHRcdG9uVGFza0ZpbmlzaGVkKHdvcmtlckRhdGEpO1xuXHRcdH1cblx0fSk7XG5cdHJldHVybiB3ZWJXb3JrZXIgPyBjcmVhdGVXZWJXb3JrZXJJbnRlcmZhY2Uod29ya2VyRGF0YSwgY29uZmlnKSA6IGNyZWF0ZVdvcmtlckludGVyZmFjZSh3b3JrZXJEYXRhLCBjb25maWcpO1xufTtcblxuZnVuY3Rpb24gY3JlYXRlV29ya2VySW50ZXJmYWNlKHdvcmtlckRhdGEsIGNvbmZpZykge1xuXHRjb25zdCBpbnRlcmZhY2VDb2RlYyA9IGNyZWF0ZUNvZGVjJDEod29ya2VyRGF0YS5jb2RlY0NvbnN0cnVjdG9yLCB3b3JrZXJEYXRhLm9wdGlvbnMsIGNvbmZpZyk7XG5cdHJldHVybiB7XG5cdFx0YXN5bmMgYXBwZW5kKGRhdGEpIHtcblx0XHRcdHRyeSB7XG5cdFx0XHRcdHJldHVybiBhd2FpdCBpbnRlcmZhY2VDb2RlYy5hcHBlbmQoZGF0YSk7XG5cdFx0XHR9IGNhdGNoIChlcnJvcikge1xuXHRcdFx0XHR3b3JrZXJEYXRhLm9uVGFza0ZpbmlzaGVkKCk7XG5cdFx0XHRcdHRocm93IGVycm9yO1xuXHRcdFx0fVxuXHRcdH0sXG5cdFx0YXN5bmMgZmx1c2goKSB7XG5cdFx0XHR0cnkge1xuXHRcdFx0XHRyZXR1cm4gYXdhaXQgaW50ZXJmYWNlQ29kZWMuZmx1c2goKTtcblx0XHRcdH0gZmluYWxseSB7XG5cdFx0XHRcdHdvcmtlckRhdGEub25UYXNrRmluaXNoZWQoKTtcblx0XHRcdH1cblx0XHR9XG5cdH07XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVdlYldvcmtlckludGVyZmFjZSh3b3JrZXJEYXRhLCBjb25maWcpIHtcblx0bGV0IG1lc3NhZ2VUYXNrO1xuXHRpZiAoIXdvcmtlckRhdGEuaW50ZXJmYWNlKSB7XG5cdFx0dHJ5IHtcblx0XHRcdHdvcmtlckRhdGEud29ya2VyID0gbmV3IFdvcmtlcihuZXcgVVJMKHdvcmtlckRhdGEuc2NyaXB0c1swXSwgaW1wb3J0Lm1ldGEudXJsKSk7XG5cdFx0fSBjYXRjaCAoZXJyb3IpIHtcblx0XHRcdHdvcmtlckRhdGEud29ya2VyID0gbmV3IFdvcmtlcihuZXcgVVJMKHdvcmtlckRhdGEuc2NyaXB0c1swXSwgaW1wb3J0Lm1ldGEudXJsKSwgeyB0eXBlOiBcIm1vZHVsZVwiIH0pO1xuXHRcdH1cblx0XHR3b3JrZXJEYXRhLndvcmtlci5hZGRFdmVudExpc3RlbmVyKE1FU1NBR0VfRVZFTlRfVFlQRSwgb25NZXNzYWdlLCBmYWxzZSk7XG5cdFx0d29ya2VyRGF0YS5pbnRlcmZhY2UgPSB7XG5cdFx0XHRhcHBlbmQoZGF0YSkge1xuXHRcdFx0XHRyZXR1cm4gaW5pdEFuZFNlbmRNZXNzYWdlKHsgdHlwZTogTUVTU0FHRV9BUFBFTkQsIGRhdGEgfSk7XG5cdFx0XHR9LFxuXHRcdFx0Zmx1c2goKSB7XG5cdFx0XHRcdHJldHVybiBpbml0QW5kU2VuZE1lc3NhZ2UoeyB0eXBlOiBNRVNTQUdFX0ZMVVNIIH0pO1xuXHRcdFx0fVxuXHRcdH07XG5cdH1cblx0cmV0dXJuIHdvcmtlckRhdGEuaW50ZXJmYWNlO1xuXG5cdGFzeW5jIGZ1bmN0aW9uIGluaXRBbmRTZW5kTWVzc2FnZShtZXNzYWdlKSB7XG5cdFx0aWYgKCFtZXNzYWdlVGFzaykge1xuXHRcdFx0Y29uc3Qgb3B0aW9ucyA9IHdvcmtlckRhdGEub3B0aW9ucztcblx0XHRcdGNvbnN0IHNjcmlwdHMgPSB3b3JrZXJEYXRhLnNjcmlwdHMuc2xpY2UoMSk7XG5cdFx0XHRhd2FpdCBzZW5kTWVzc2FnZSh7IHNjcmlwdHMsIHR5cGU6IE1FU1NBR0VfSU5JVCwgb3B0aW9ucywgY29uZmlnOiB7IGNodW5rU2l6ZTogY29uZmlnLmNodW5rU2l6ZSB9IH0pO1xuXHRcdH1cblx0XHRyZXR1cm4gc2VuZE1lc3NhZ2UobWVzc2FnZSk7XG5cdH1cblxuXHRmdW5jdGlvbiBzZW5kTWVzc2FnZShtZXNzYWdlKSB7XG5cdFx0Y29uc3Qgd29ya2VyID0gd29ya2VyRGF0YS53b3JrZXI7XG5cdFx0Y29uc3QgcmVzdWx0ID0gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4gbWVzc2FnZVRhc2sgPSB7IHJlc29sdmUsIHJlamVjdCB9KTtcblx0XHR0cnkge1xuXHRcdFx0aWYgKG1lc3NhZ2UuZGF0YSkge1xuXHRcdFx0XHR0cnkge1xuXHRcdFx0XHRcdG1lc3NhZ2UuZGF0YSA9IG1lc3NhZ2UuZGF0YS5idWZmZXI7XG5cdFx0XHRcdFx0d29ya2VyLnBvc3RNZXNzYWdlKG1lc3NhZ2UsIFttZXNzYWdlLmRhdGFdKTtcblx0XHRcdFx0fSBjYXRjaCAoZXJyb3IpIHtcblx0XHRcdFx0XHR3b3JrZXIucG9zdE1lc3NhZ2UobWVzc2FnZSk7XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHdvcmtlci5wb3N0TWVzc2FnZShtZXNzYWdlKTtcblx0XHRcdH1cblx0XHR9IGNhdGNoIChlcnJvcikge1xuXHRcdFx0bWVzc2FnZVRhc2sucmVqZWN0KGVycm9yKTtcblx0XHRcdG1lc3NhZ2VUYXNrID0gbnVsbDtcblx0XHRcdHdvcmtlckRhdGEub25UYXNrRmluaXNoZWQoKTtcblx0XHR9XG5cdFx0cmV0dXJuIHJlc3VsdDtcblx0fVxuXG5cdGZ1bmN0aW9uIG9uTWVzc2FnZShldmVudCkge1xuXHRcdGNvbnN0IG1lc3NhZ2UgPSBldmVudC5kYXRhO1xuXHRcdGlmIChtZXNzYWdlVGFzaykge1xuXHRcdFx0Y29uc3QgcmVwb25zZUVycm9yID0gbWVzc2FnZS5lcnJvcjtcblx0XHRcdGNvbnN0IHR5cGUgPSBtZXNzYWdlLnR5cGU7XG5cdFx0XHRpZiAocmVwb25zZUVycm9yKSB7XG5cdFx0XHRcdGNvbnN0IGVycm9yID0gbmV3IEVycm9yKHJlcG9uc2VFcnJvci5tZXNzYWdlKTtcblx0XHRcdFx0ZXJyb3Iuc3RhY2sgPSByZXBvbnNlRXJyb3Iuc3RhY2s7XG5cdFx0XHRcdG1lc3NhZ2VUYXNrLnJlamVjdChlcnJvcik7XG5cdFx0XHRcdG1lc3NhZ2VUYXNrID0gbnVsbDtcblx0XHRcdFx0d29ya2VyRGF0YS5vblRhc2tGaW5pc2hlZCgpO1xuXHRcdFx0fSBlbHNlIGlmICh0eXBlID09IE1FU1NBR0VfSU5JVCB8fCB0eXBlID09IE1FU1NBR0VfRkxVU0ggfHwgdHlwZSA9PSBNRVNTQUdFX0FQUEVORCkge1xuXHRcdFx0XHRjb25zdCBkYXRhID0gbWVzc2FnZS5kYXRhO1xuXHRcdFx0XHRpZiAodHlwZSA9PSBNRVNTQUdFX0ZMVVNIKSB7XG5cdFx0XHRcdFx0bWVzc2FnZVRhc2sucmVzb2x2ZSh7IGRhdGE6IG5ldyBVaW50OEFycmF5KGRhdGEpLCBzaWduYXR1cmU6IG1lc3NhZ2Uuc2lnbmF0dXJlIH0pO1xuXHRcdFx0XHRcdG1lc3NhZ2VUYXNrID0gbnVsbDtcblx0XHRcdFx0XHR3b3JrZXJEYXRhLm9uVGFza0ZpbmlzaGVkKCk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0bWVzc2FnZVRhc2sucmVzb2x2ZShkYXRhICYmIG5ldyBVaW50OEFycmF5KGRhdGEpKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fVxufVxuXG4vKlxuIENvcHlyaWdodCAoYykgMjAyMSBHaWxkYXMgTG9ybWVhdS4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cblxuIFJlZGlzdHJpYnV0aW9uIGFuZCB1c2UgaW4gc291cmNlIGFuZCBiaW5hcnkgZm9ybXMsIHdpdGggb3Igd2l0aG91dFxuIG1vZGlmaWNhdGlvbiwgYXJlIHBlcm1pdHRlZCBwcm92aWRlZCB0aGF0IHRoZSBmb2xsb3dpbmcgY29uZGl0aW9ucyBhcmUgbWV0OlxuXG4gMS4gUmVkaXN0cmlidXRpb25zIG9mIHNvdXJjZSBjb2RlIG11c3QgcmV0YWluIHRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlLFxuIHRoaXMgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nIGRpc2NsYWltZXIuXG5cbiAyLiBSZWRpc3RyaWJ1dGlvbnMgaW4gYmluYXJ5IGZvcm0gbXVzdCByZXByb2R1Y2UgdGhlIGFib3ZlIGNvcHlyaWdodCBcbiBub3RpY2UsIHRoaXMgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nIGRpc2NsYWltZXIgaW4gXG4gdGhlIGRvY3VtZW50YXRpb24gYW5kL29yIG90aGVyIG1hdGVyaWFscyBwcm92aWRlZCB3aXRoIHRoZSBkaXN0cmlidXRpb24uXG5cbiAzLiBUaGUgbmFtZXMgb2YgdGhlIGF1dGhvcnMgbWF5IG5vdCBiZSB1c2VkIHRvIGVuZG9yc2Ugb3IgcHJvbW90ZSBwcm9kdWN0c1xuIGRlcml2ZWQgZnJvbSB0aGlzIHNvZnR3YXJlIHdpdGhvdXQgc3BlY2lmaWMgcHJpb3Igd3JpdHRlbiBwZXJtaXNzaW9uLlxuXG4gVEhJUyBTT0ZUV0FSRSBJUyBQUk9WSURFRCAnJ0FTIElTJycgQU5EIEFOWSBFWFBSRVNTRUQgT1IgSU1QTElFRCBXQVJSQU5USUVTLFxuIElOQ0xVRElORywgQlVUIE5PVCBMSU1JVEVEIFRPLCBUSEUgSU1QTElFRCBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSBBTkRcbiBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBUkUgRElTQ0xBSU1FRC4gSU4gTk8gRVZFTlQgU0hBTEwgSkNSQUZULFxuIElOQy4gT1IgQU5ZIENPTlRSSUJVVE9SUyBUTyBUSElTIFNPRlRXQVJFIEJFIExJQUJMRSBGT1IgQU5ZIERJUkVDVCwgSU5ESVJFQ1QsXG4gSU5DSURFTlRBTCwgU1BFQ0lBTCwgRVhFTVBMQVJZLCBPUiBDT05TRVFVRU5USUFMIERBTUFHRVMgKElOQ0xVRElORywgQlVUIE5PVFxuIExJTUlURUQgVE8sIFBST0NVUkVNRU5UIE9GIFNVQlNUSVRVVEUgR09PRFMgT1IgU0VSVklDRVM7IExPU1MgT0YgVVNFLCBEQVRBLFxuIE9SIFBST0ZJVFM7IE9SIEJVU0lORVNTIElOVEVSUlVQVElPTikgSE9XRVZFUiBDQVVTRUQgQU5EIE9OIEFOWSBUSEVPUlkgT0ZcbiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQ09OVFJBQ1QsIFNUUklDVCBMSUFCSUxJVFksIE9SIFRPUlQgKElOQ0xVRElOR1xuIE5FR0xJR0VOQ0UgT1IgT1RIRVJXSVNFKSBBUklTSU5HIElOIEFOWSBXQVkgT1VUIE9GIFRIRSBVU0UgT0YgVEhJUyBTT0ZUV0FSRSxcbiBFVkVOIElGIEFEVklTRUQgT0YgVEhFIFBPU1NJQklMSVRZIE9GIFNVQ0ggREFNQUdFLlxuICovXG5cbmxldCBwb29sID0gW107XG5sZXQgcGVuZGluZ1JlcXVlc3RzID0gW107XG5cbmZ1bmN0aW9uIGNyZWF0ZUNvZGVjKGNvZGVjQ29uc3RydWN0b3IsIG9wdGlvbnMsIGNvbmZpZykge1xuXHRjb25zdCBzdHJlYW1Db3B5ID0gIW9wdGlvbnMuY29tcHJlc3NlZCAmJiAhb3B0aW9ucy5zaWduZWQgJiYgIW9wdGlvbnMuZW5jcnlwdGVkO1xuXHRjb25zdCB3ZWJXb3JrZXIgPSAhc3RyZWFtQ29weSAmJiAob3B0aW9ucy51c2VXZWJXb3JrZXJzIHx8IChvcHRpb25zLnVzZVdlYldvcmtlcnMgPT09IHVuZGVmaW5lZCAmJiBjb25maWcudXNlV2ViV29ya2VycykpO1xuXHRjb25zdCBzY3JpcHRzID0gd2ViV29ya2VyICYmIGNvbmZpZy53b3JrZXJTY3JpcHRzID8gY29uZmlnLndvcmtlclNjcmlwdHNbb3B0aW9ucy5jb2RlY1R5cGVdIDogW107XG5cdGlmIChwb29sLmxlbmd0aCA8IGNvbmZpZy5tYXhXb3JrZXJzKSB7XG5cdFx0Y29uc3Qgd29ya2VyRGF0YSA9IHt9O1xuXHRcdHBvb2wucHVzaCh3b3JrZXJEYXRhKTtcblx0XHRyZXR1cm4gZ2V0V29ya2VyKHdvcmtlckRhdGEsIGNvZGVjQ29uc3RydWN0b3IsIG9wdGlvbnMsIGNvbmZpZywgb25UYXNrRmluaXNoZWQsIHdlYldvcmtlciwgc2NyaXB0cyk7XG5cdH0gZWxzZSB7XG5cdFx0Y29uc3Qgd29ya2VyRGF0YSA9IHBvb2wuZmluZCh3b3JrZXJEYXRhID0+ICF3b3JrZXJEYXRhLmJ1c3kpO1xuXHRcdGlmICh3b3JrZXJEYXRhKSB7XG5cdFx0XHRjbGVhclRlcm1pbmF0ZVRpbWVvdXQod29ya2VyRGF0YSk7XG5cdFx0XHRyZXR1cm4gZ2V0V29ya2VyKHdvcmtlckRhdGEsIGNvZGVjQ29uc3RydWN0b3IsIG9wdGlvbnMsIGNvbmZpZywgb25UYXNrRmluaXNoZWQsIHdlYldvcmtlciwgc2NyaXB0cyk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHJldHVybiBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHBlbmRpbmdSZXF1ZXN0cy5wdXNoKHsgcmVzb2x2ZSwgY29kZWNDb25zdHJ1Y3Rvciwgb3B0aW9ucywgd2ViV29ya2VyLCBzY3JpcHRzIH0pKTtcblx0XHR9XG5cdH1cblxuXHRmdW5jdGlvbiBvblRhc2tGaW5pc2hlZCh3b3JrZXJEYXRhKSB7XG5cdFx0aWYgKHBlbmRpbmdSZXF1ZXN0cy5sZW5ndGgpIHtcblx0XHRcdGNvbnN0IFt7IHJlc29sdmUsIGNvZGVjQ29uc3RydWN0b3IsIG9wdGlvbnMsIHdlYldvcmtlciwgc2NyaXB0cyB9XSA9IHBlbmRpbmdSZXF1ZXN0cy5zcGxpY2UoMCwgMSk7XG5cdFx0XHRyZXNvbHZlKGdldFdvcmtlcih3b3JrZXJEYXRhLCBjb2RlY0NvbnN0cnVjdG9yLCBvcHRpb25zLCBjb25maWcsIG9uVGFza0ZpbmlzaGVkLCB3ZWJXb3JrZXIsIHNjcmlwdHMpKTtcblx0XHR9IGVsc2UgaWYgKHdvcmtlckRhdGEud29ya2VyKSB7XG5cdFx0XHRjbGVhclRlcm1pbmF0ZVRpbWVvdXQod29ya2VyRGF0YSk7XG5cdFx0XHRpZiAoTnVtYmVyLmlzRmluaXRlKGNvbmZpZy50ZXJtaW5hdGVXb3JrZXJUaW1lb3V0KSAmJiBjb25maWcudGVybWluYXRlV29ya2VyVGltZW91dCA+PSAwKSB7XG5cdFx0XHRcdHdvcmtlckRhdGEudGVybWluYXRlVGltZW91dCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuXHRcdFx0XHRcdHBvb2wgPSBwb29sLmZpbHRlcihkYXRhID0+IGRhdGEgIT0gd29ya2VyRGF0YSk7XG5cdFx0XHRcdFx0d29ya2VyRGF0YS50ZXJtaW5hdGUoKTtcblx0XHRcdFx0fSwgY29uZmlnLnRlcm1pbmF0ZVdvcmtlclRpbWVvdXQpO1xuXHRcdFx0fVxuXHRcdH0gZWxzZSB7XG5cdFx0XHRwb29sID0gcG9vbC5maWx0ZXIoZGF0YSA9PiBkYXRhICE9IHdvcmtlckRhdGEpO1xuXHRcdH1cblx0fVxufVxuXG5mdW5jdGlvbiBjbGVhclRlcm1pbmF0ZVRpbWVvdXQod29ya2VyRGF0YSkge1xuXHRpZiAod29ya2VyRGF0YS50ZXJtaW5hdGVUaW1lb3V0KSB7XG5cdFx0Y2xlYXJUaW1lb3V0KHdvcmtlckRhdGEudGVybWluYXRlVGltZW91dCk7XG5cdFx0d29ya2VyRGF0YS50ZXJtaW5hdGVUaW1lb3V0ID0gbnVsbDtcblx0fVxufVxuXG5mdW5jdGlvbiB0ZXJtaW5hdGVXb3JrZXJzKCkge1xuXHRwb29sLmZvckVhY2god29ya2VyRGF0YSA9PiB7XG5cdFx0Y2xlYXJUZXJtaW5hdGVUaW1lb3V0KHdvcmtlckRhdGEpO1xuXHRcdHdvcmtlckRhdGEudGVybWluYXRlKCk7XG5cdH0pO1xufVxuXG4vKlxuIENvcHlyaWdodCAoYykgMjAyMSBHaWxkYXMgTG9ybWVhdS4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cblxuIFJlZGlzdHJpYnV0aW9uIGFuZCB1c2UgaW4gc291cmNlIGFuZCBiaW5hcnkgZm9ybXMsIHdpdGggb3Igd2l0aG91dFxuIG1vZGlmaWNhdGlvbiwgYXJlIHBlcm1pdHRlZCBwcm92aWRlZCB0aGF0IHRoZSBmb2xsb3dpbmcgY29uZGl0aW9ucyBhcmUgbWV0OlxuXG4gMS4gUmVkaXN0cmlidXRpb25zIG9mIHNvdXJjZSBjb2RlIG11c3QgcmV0YWluIHRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlLFxuIHRoaXMgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nIGRpc2NsYWltZXIuXG5cbiAyLiBSZWRpc3RyaWJ1dGlvbnMgaW4gYmluYXJ5IGZvcm0gbXVzdCByZXByb2R1Y2UgdGhlIGFib3ZlIGNvcHlyaWdodCBcbiBub3RpY2UsIHRoaXMgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nIGRpc2NsYWltZXIgaW4gXG4gdGhlIGRvY3VtZW50YXRpb24gYW5kL29yIG90aGVyIG1hdGVyaWFscyBwcm92aWRlZCB3aXRoIHRoZSBkaXN0cmlidXRpb24uXG5cbiAzLiBUaGUgbmFtZXMgb2YgdGhlIGF1dGhvcnMgbWF5IG5vdCBiZSB1c2VkIHRvIGVuZG9yc2Ugb3IgcHJvbW90ZSBwcm9kdWN0c1xuIGRlcml2ZWQgZnJvbSB0aGlzIHNvZnR3YXJlIHdpdGhvdXQgc3BlY2lmaWMgcHJpb3Igd3JpdHRlbiBwZXJtaXNzaW9uLlxuXG4gVEhJUyBTT0ZUV0FSRSBJUyBQUk9WSURFRCAnJ0FTIElTJycgQU5EIEFOWSBFWFBSRVNTRUQgT1IgSU1QTElFRCBXQVJSQU5USUVTLFxuIElOQ0xVRElORywgQlVUIE5PVCBMSU1JVEVEIFRPLCBUSEUgSU1QTElFRCBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSBBTkRcbiBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBUkUgRElTQ0xBSU1FRC4gSU4gTk8gRVZFTlQgU0hBTEwgSkNSQUZULFxuIElOQy4gT1IgQU5ZIENPTlRSSUJVVE9SUyBUTyBUSElTIFNPRlRXQVJFIEJFIExJQUJMRSBGT1IgQU5ZIERJUkVDVCwgSU5ESVJFQ1QsXG4gSU5DSURFTlRBTCwgU1BFQ0lBTCwgRVhFTVBMQVJZLCBPUiBDT05TRVFVRU5USUFMIERBTUFHRVMgKElOQ0xVRElORywgQlVUIE5PVFxuIExJTUlURUQgVE8sIFBST0NVUkVNRU5UIE9GIFNVQlNUSVRVVEUgR09PRFMgT1IgU0VSVklDRVM7IExPU1MgT0YgVVNFLCBEQVRBLFxuIE9SIFBST0ZJVFM7IE9SIEJVU0lORVNTIElOVEVSUlVQVElPTikgSE9XRVZFUiBDQVVTRUQgQU5EIE9OIEFOWSBUSEVPUlkgT0ZcbiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQ09OVFJBQ1QsIFNUUklDVCBMSUFCSUxJVFksIE9SIFRPUlQgKElOQ0xVRElOR1xuIE5FR0xJR0VOQ0UgT1IgT1RIRVJXSVNFKSBBUklTSU5HIElOIEFOWSBXQVkgT1VUIE9GIFRIRSBVU0UgT0YgVEhJUyBTT0ZUV0FSRSxcbiBFVkVOIElGIEFEVklTRUQgT0YgVEhFIFBPU1NJQklMSVRZIE9GIFNVQ0ggREFNQUdFLlxuICovXG5cbmNvbnN0IE1JTklNVU1fQ0hVTktfU0laRSA9IDY0O1xuY29uc3QgRVJSX0FCT1JUID0gXCJBYm9ydCBlcnJvclwiO1xuXG5hc3luYyBmdW5jdGlvbiBwcm9jZXNzRGF0YShjb2RlYywgcmVhZGVyLCB3cml0ZXIsIG9mZnNldCwgaW5wdXRMZW5ndGgsIGNvbmZpZywgb3B0aW9ucykge1xuXHRjb25zdCBjaHVua1NpemUgPSBNYXRoLm1heChjb25maWcuY2h1bmtTaXplLCBNSU5JTVVNX0NIVU5LX1NJWkUpO1xuXHRyZXR1cm4gcHJvY2Vzc0NodW5rKCk7XG5cblx0YXN5bmMgZnVuY3Rpb24gcHJvY2Vzc0NodW5rKGNodW5rT2Zmc2V0ID0gMCwgb3V0cHV0TGVuZ3RoID0gMCkge1xuXHRcdGNvbnN0IHNpZ25hbCA9IG9wdGlvbnMuc2lnbmFsO1xuXHRcdGlmIChjaHVua09mZnNldCA8IGlucHV0TGVuZ3RoKSB7XG5cdFx0XHR0ZXN0QWJvcnRlZChzaWduYWwsIGNvZGVjKTtcblx0XHRcdGNvbnN0IGlucHV0RGF0YSA9IGF3YWl0IHJlYWRlci5yZWFkVWludDhBcnJheShjaHVua09mZnNldCArIG9mZnNldCwgTWF0aC5taW4oY2h1bmtTaXplLCBpbnB1dExlbmd0aCAtIGNodW5rT2Zmc2V0KSk7XG5cdFx0XHRjb25zdCBjaHVua0xlbmd0aCA9IGlucHV0RGF0YS5sZW5ndGg7XG5cdFx0XHR0ZXN0QWJvcnRlZChzaWduYWwsIGNvZGVjKTtcblx0XHRcdGNvbnN0IGRhdGEgPSBhd2FpdCBjb2RlYy5hcHBlbmQoaW5wdXREYXRhKTtcblx0XHRcdHRlc3RBYm9ydGVkKHNpZ25hbCwgY29kZWMpO1xuXHRcdFx0b3V0cHV0TGVuZ3RoICs9IGF3YWl0IHdyaXRlRGF0YSh3cml0ZXIsIGRhdGEpO1xuXHRcdFx0aWYgKG9wdGlvbnMub25wcm9ncmVzcykge1xuXHRcdFx0XHR0cnkge1xuXHRcdFx0XHRcdG9wdGlvbnMub25wcm9ncmVzcyhjaHVua09mZnNldCArIGNodW5rTGVuZ3RoLCBpbnB1dExlbmd0aCk7XG5cdFx0XHRcdH0gY2F0Y2ggKGVycm9yKSB7XG5cdFx0XHRcdFx0Ly8gaWdub3JlZFxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gcHJvY2Vzc0NodW5rKGNodW5rT2Zmc2V0ICsgY2h1bmtTaXplLCBvdXRwdXRMZW5ndGgpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRjb25zdCByZXN1bHQgPSBhd2FpdCBjb2RlYy5mbHVzaCgpO1xuXHRcdFx0b3V0cHV0TGVuZ3RoICs9IGF3YWl0IHdyaXRlRGF0YSh3cml0ZXIsIHJlc3VsdC5kYXRhKTtcblx0XHRcdHJldHVybiB7IHNpZ25hdHVyZTogcmVzdWx0LnNpZ25hdHVyZSwgbGVuZ3RoOiBvdXRwdXRMZW5ndGggfTtcblx0XHR9XG5cdH1cbn1cblxuZnVuY3Rpb24gdGVzdEFib3J0ZWQoc2lnbmFsLCBjb2RlYykge1xuXHRpZiAoc2lnbmFsICYmIHNpZ25hbC5hYm9ydGVkKSB7XG5cdFx0Y29kZWMuZmx1c2goKTtcblx0XHR0aHJvdyBuZXcgRXJyb3IoRVJSX0FCT1JUKTtcblx0fVxufVxuXG5hc3luYyBmdW5jdGlvbiB3cml0ZURhdGEod3JpdGVyLCBkYXRhKSB7XG5cdGlmIChkYXRhLmxlbmd0aCkge1xuXHRcdGF3YWl0IHdyaXRlci53cml0ZVVpbnQ4QXJyYXkoZGF0YSk7XG5cdH1cblx0cmV0dXJuIGRhdGEubGVuZ3RoO1xufVxuXG4vKlxuIENvcHlyaWdodCAoYykgMjAyMSBHaWxkYXMgTG9ybWVhdS4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cblxuIFJlZGlzdHJpYnV0aW9uIGFuZCB1c2UgaW4gc291cmNlIGFuZCBiaW5hcnkgZm9ybXMsIHdpdGggb3Igd2l0aG91dFxuIG1vZGlmaWNhdGlvbiwgYXJlIHBlcm1pdHRlZCBwcm92aWRlZCB0aGF0IHRoZSBmb2xsb3dpbmcgY29uZGl0aW9ucyBhcmUgbWV0OlxuXG4gMS4gUmVkaXN0cmlidXRpb25zIG9mIHNvdXJjZSBjb2RlIG11c3QgcmV0YWluIHRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlLFxuIHRoaXMgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nIGRpc2NsYWltZXIuXG5cbiAyLiBSZWRpc3RyaWJ1dGlvbnMgaW4gYmluYXJ5IGZvcm0gbXVzdCByZXByb2R1Y2UgdGhlIGFib3ZlIGNvcHlyaWdodCBcbiBub3RpY2UsIHRoaXMgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nIGRpc2NsYWltZXIgaW4gXG4gdGhlIGRvY3VtZW50YXRpb24gYW5kL29yIG90aGVyIG1hdGVyaWFscyBwcm92aWRlZCB3aXRoIHRoZSBkaXN0cmlidXRpb24uXG5cbiAzLiBUaGUgbmFtZXMgb2YgdGhlIGF1dGhvcnMgbWF5IG5vdCBiZSB1c2VkIHRvIGVuZG9yc2Ugb3IgcHJvbW90ZSBwcm9kdWN0c1xuIGRlcml2ZWQgZnJvbSB0aGlzIHNvZnR3YXJlIHdpdGhvdXQgc3BlY2lmaWMgcHJpb3Igd3JpdHRlbiBwZXJtaXNzaW9uLlxuXG4gVEhJUyBTT0ZUV0FSRSBJUyBQUk9WSURFRCAnJ0FTIElTJycgQU5EIEFOWSBFWFBSRVNTRUQgT1IgSU1QTElFRCBXQVJSQU5USUVTLFxuIElOQ0xVRElORywgQlVUIE5PVCBMSU1JVEVEIFRPLCBUSEUgSU1QTElFRCBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSBBTkRcbiBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBUkUgRElTQ0xBSU1FRC4gSU4gTk8gRVZFTlQgU0hBTEwgSkNSQUZULFxuIElOQy4gT1IgQU5ZIENPTlRSSUJVVE9SUyBUTyBUSElTIFNPRlRXQVJFIEJFIExJQUJMRSBGT1IgQU5ZIERJUkVDVCwgSU5ESVJFQ1QsXG4gSU5DSURFTlRBTCwgU1BFQ0lBTCwgRVhFTVBMQVJZLCBPUiBDT05TRVFVRU5USUFMIERBTUFHRVMgKElOQ0xVRElORywgQlVUIE5PVFxuIExJTUlURUQgVE8sIFBST0NVUkVNRU5UIE9GIFNVQlNUSVRVVEUgR09PRFMgT1IgU0VSVklDRVM7IExPU1MgT0YgVVNFLCBEQVRBLFxuIE9SIFBST0ZJVFM7IE9SIEJVU0lORVNTIElOVEVSUlVQVElPTikgSE9XRVZFUiBDQVVTRUQgQU5EIE9OIEFOWSBUSEVPUlkgT0ZcbiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQ09OVFJBQ1QsIFNUUklDVCBMSUFCSUxJVFksIE9SIFRPUlQgKElOQ0xVRElOR1xuIE5FR0xJR0VOQ0UgT1IgT1RIRVJXSVNFKSBBUklTSU5HIElOIEFOWSBXQVkgT1VUIE9GIFRIRSBVU0UgT0YgVEhJUyBTT0ZUV0FSRSxcbiBFVkVOIElGIEFEVklTRUQgT0YgVEhFIFBPU1NJQklMSVRZIE9GIFNVQ0ggREFNQUdFLlxuICovXG5cbmNvbnN0IEVSUl9IVFRQX1NUQVRVUyA9IFwiSFRUUCBlcnJvciBcIjtcbmNvbnN0IEVSUl9IVFRQX1JBTkdFID0gXCJIVFRQIFJhbmdlIG5vdCBzdXBwb3J0ZWRcIjtcblxuY29uc3QgQ09OVEVOVF9UWVBFX1RFWFRfUExBSU4gPSBcInRleHQvcGxhaW5cIjtcbmNvbnN0IEhUVFBfSEVBREVSX0NPTlRFTlRfTEVOR1RIID0gXCJDb250ZW50LUxlbmd0aFwiO1xuY29uc3QgSFRUUF9IRUFERVJfQUNDRVBUX1JBTkdFUyA9IFwiQWNjZXB0LVJhbmdlc1wiO1xuY29uc3QgSFRUUF9IRUFERVJfUkFOR0UgPSBcIlJhbmdlXCI7XG5jb25zdCBIVFRQX01FVEhPRF9IRUFEID0gXCJIRUFEXCI7XG5jb25zdCBIVFRQX01FVEhPRF9HRVQgPSBcIkdFVFwiO1xuY29uc3QgSFRUUF9SQU5HRV9VTklUID0gXCJieXRlc1wiO1xuXG5jbGFzcyBTdHJlYW0ge1xuXG5cdGNvbnN0cnVjdG9yKCkge1xuXHRcdHRoaXMuc2l6ZSA9IDA7XG5cdH1cblxuXHRpbml0KCkge1xuXHRcdHRoaXMuaW5pdGlhbGl6ZWQgPSB0cnVlO1xuXHR9XG59XG5cbmNsYXNzIFJlYWRlciBleHRlbmRzIFN0cmVhbSB7XG59XG5cbmNsYXNzIFdyaXRlciBleHRlbmRzIFN0cmVhbSB7XG5cblx0d3JpdGVVaW50OEFycmF5KGFycmF5KSB7XG5cdFx0dGhpcy5zaXplICs9IGFycmF5Lmxlbmd0aDtcblx0fVxufVxuXG5jbGFzcyBUZXh0UmVhZGVyIGV4dGVuZHMgUmVhZGVyIHtcblxuXHRjb25zdHJ1Y3Rvcih0ZXh0KSB7XG5cdFx0c3VwZXIoKTtcblx0XHR0aGlzLmJsb2JSZWFkZXIgPSBuZXcgQmxvYlJlYWRlcihuZXcgQmxvYihbdGV4dF0sIHsgdHlwZTogQ09OVEVOVF9UWVBFX1RFWFRfUExBSU4gfSkpO1xuXHR9XG5cblx0YXN5bmMgaW5pdCgpIHtcblx0XHRzdXBlci5pbml0KCk7XG5cdFx0dGhpcy5ibG9iUmVhZGVyLmluaXQoKTtcblx0XHR0aGlzLnNpemUgPSB0aGlzLmJsb2JSZWFkZXIuc2l6ZTtcblx0fVxuXG5cdGFzeW5jIHJlYWRVaW50OEFycmF5KG9mZnNldCwgbGVuZ3RoKSB7XG5cdFx0cmV0dXJuIHRoaXMuYmxvYlJlYWRlci5yZWFkVWludDhBcnJheShvZmZzZXQsIGxlbmd0aCk7XG5cdH1cbn1cblxuY2xhc3MgVGV4dFdyaXRlciBleHRlbmRzIFdyaXRlciB7XG5cblx0Y29uc3RydWN0b3IoZW5jb2RpbmcpIHtcblx0XHRzdXBlcigpO1xuXHRcdHRoaXMuZW5jb2RpbmcgPSBlbmNvZGluZztcblx0XHR0aGlzLmJsb2IgPSBuZXcgQmxvYihbXSwgeyB0eXBlOiBDT05URU5UX1RZUEVfVEVYVF9QTEFJTiB9KTtcblx0fVxuXG5cdGFzeW5jIHdyaXRlVWludDhBcnJheShhcnJheSkge1xuXHRcdHN1cGVyLndyaXRlVWludDhBcnJheShhcnJheSk7XG5cdFx0dGhpcy5ibG9iID0gbmV3IEJsb2IoW3RoaXMuYmxvYiwgYXJyYXkuYnVmZmVyXSwgeyB0eXBlOiBDT05URU5UX1RZUEVfVEVYVF9QTEFJTiB9KTtcblx0fVxuXG5cdGdldERhdGEoKSB7XG5cdFx0Y29uc3QgcmVhZGVyID0gbmV3IEZpbGVSZWFkZXIoKTtcblx0XHRyZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuXHRcdFx0cmVhZGVyLm9ubG9hZCA9IGV2ZW50ID0+IHJlc29sdmUoZXZlbnQudGFyZ2V0LnJlc3VsdCk7XG5cdFx0XHRyZWFkZXIub25lcnJvciA9ICgpID0+IHJlamVjdChyZWFkZXIuZXJyb3IpO1xuXHRcdFx0cmVhZGVyLnJlYWRBc1RleHQodGhpcy5ibG9iLCB0aGlzLmVuY29kaW5nKTtcblx0XHR9KTtcblx0fVxufVxuXG5jbGFzcyBEYXRhNjRVUklSZWFkZXIgZXh0ZW5kcyBSZWFkZXIge1xuXG5cdGNvbnN0cnVjdG9yKGRhdGFVUkkpIHtcblx0XHRzdXBlcigpO1xuXHRcdHRoaXMuZGF0YVVSSSA9IGRhdGFVUkk7XG5cdFx0bGV0IGRhdGFFbmQgPSBkYXRhVVJJLmxlbmd0aDtcblx0XHR3aGlsZSAoZGF0YVVSSS5jaGFyQXQoZGF0YUVuZCAtIDEpID09IFwiPVwiKSB7XG5cdFx0XHRkYXRhRW5kLS07XG5cdFx0fVxuXHRcdHRoaXMuZGF0YVN0YXJ0ID0gZGF0YVVSSS5pbmRleE9mKFwiLFwiKSArIDE7XG5cdFx0dGhpcy5zaXplID0gTWF0aC5mbG9vcigoZGF0YUVuZCAtIHRoaXMuZGF0YVN0YXJ0KSAqIDAuNzUpO1xuXHR9XG5cblx0YXN5bmMgcmVhZFVpbnQ4QXJyYXkob2Zmc2V0LCBsZW5ndGgpIHtcblx0XHRjb25zdCBkYXRhQXJyYXkgPSBuZXcgVWludDhBcnJheShsZW5ndGgpO1xuXHRcdGNvbnN0IHN0YXJ0ID0gTWF0aC5mbG9vcihvZmZzZXQgLyAzKSAqIDQ7XG5cdFx0Y29uc3QgYnl0ZXMgPSBhdG9iKHRoaXMuZGF0YVVSSS5zdWJzdHJpbmcoc3RhcnQgKyB0aGlzLmRhdGFTdGFydCwgTWF0aC5jZWlsKChvZmZzZXQgKyBsZW5ndGgpIC8gMykgKiA0ICsgdGhpcy5kYXRhU3RhcnQpKTtcblx0XHRjb25zdCBkZWx0YSA9IG9mZnNldCAtIE1hdGguZmxvb3Ioc3RhcnQgLyA0KSAqIDM7XG5cdFx0Zm9yIChsZXQgaW5kZXhCeXRlID0gZGVsdGE7IGluZGV4Qnl0ZSA8IGRlbHRhICsgbGVuZ3RoOyBpbmRleEJ5dGUrKykge1xuXHRcdFx0ZGF0YUFycmF5W2luZGV4Qnl0ZSAtIGRlbHRhXSA9IGJ5dGVzLmNoYXJDb2RlQXQoaW5kZXhCeXRlKTtcblx0XHR9XG5cdFx0cmV0dXJuIGRhdGFBcnJheTtcblx0fVxufVxuXG5jbGFzcyBEYXRhNjRVUklXcml0ZXIgZXh0ZW5kcyBXcml0ZXIge1xuXG5cdGNvbnN0cnVjdG9yKGNvbnRlbnRUeXBlKSB7XG5cdFx0c3VwZXIoKTtcblx0XHR0aGlzLmRhdGEgPSBcImRhdGE6XCIgKyAoY29udGVudFR5cGUgfHwgXCJcIikgKyBcIjtiYXNlNjQsXCI7XG5cdFx0dGhpcy5wZW5kaW5nID0gW107XG5cdH1cblxuXHRhc3luYyB3cml0ZVVpbnQ4QXJyYXkoYXJyYXkpIHtcblx0XHRzdXBlci53cml0ZVVpbnQ4QXJyYXkoYXJyYXkpO1xuXHRcdGxldCBpbmRleEFycmF5ID0gMDtcblx0XHRsZXQgZGF0YVN0cmluZyA9IHRoaXMucGVuZGluZztcblx0XHRjb25zdCBkZWx0YSA9IHRoaXMucGVuZGluZy5sZW5ndGg7XG5cdFx0dGhpcy5wZW5kaW5nID0gXCJcIjtcblx0XHRmb3IgKGluZGV4QXJyYXkgPSAwOyBpbmRleEFycmF5IDwgKE1hdGguZmxvb3IoKGRlbHRhICsgYXJyYXkubGVuZ3RoKSAvIDMpICogMykgLSBkZWx0YTsgaW5kZXhBcnJheSsrKSB7XG5cdFx0XHRkYXRhU3RyaW5nICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoYXJyYXlbaW5kZXhBcnJheV0pO1xuXHRcdH1cblx0XHRmb3IgKDsgaW5kZXhBcnJheSA8IGFycmF5Lmxlbmd0aDsgaW5kZXhBcnJheSsrKSB7XG5cdFx0XHR0aGlzLnBlbmRpbmcgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShhcnJheVtpbmRleEFycmF5XSk7XG5cdFx0fVxuXHRcdGlmIChkYXRhU3RyaW5nLmxlbmd0aCA+IDIpIHtcblx0XHRcdHRoaXMuZGF0YSArPSBidG9hKGRhdGFTdHJpbmcpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR0aGlzLnBlbmRpbmcgPSBkYXRhU3RyaW5nO1xuXHRcdH1cblx0fVxuXG5cdGdldERhdGEoKSB7XG5cdFx0cmV0dXJuIHRoaXMuZGF0YSArIGJ0b2EodGhpcy5wZW5kaW5nKTtcblx0fVxufVxuXG5jbGFzcyBCbG9iUmVhZGVyIGV4dGVuZHMgUmVhZGVyIHtcblxuXHRjb25zdHJ1Y3RvcihibG9iKSB7XG5cdFx0c3VwZXIoKTtcblx0XHR0aGlzLmJsb2IgPSBibG9iO1xuXHRcdHRoaXMuc2l6ZSA9IGJsb2Iuc2l6ZTtcblx0fVxuXG5cdGFzeW5jIHJlYWRVaW50OEFycmF5KG9mZnNldCwgbGVuZ3RoKSB7XG5cdFx0Y29uc3QgcmVhZGVyID0gbmV3IEZpbGVSZWFkZXIoKTtcblx0XHRyZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuXHRcdFx0cmVhZGVyLm9ubG9hZCA9IGV2ZW50ID0+IHJlc29sdmUobmV3IFVpbnQ4QXJyYXkoZXZlbnQudGFyZ2V0LnJlc3VsdCkpO1xuXHRcdFx0cmVhZGVyLm9uZXJyb3IgPSAoKSA9PiByZWplY3QocmVhZGVyLmVycm9yKTtcblx0XHRcdHJlYWRlci5yZWFkQXNBcnJheUJ1ZmZlcih0aGlzLmJsb2Iuc2xpY2Uob2Zmc2V0LCBvZmZzZXQgKyBsZW5ndGgpKTtcblx0XHR9KTtcblx0fVxufVxuXG5jbGFzcyBCbG9iV3JpdGVyIGV4dGVuZHMgV3JpdGVyIHtcblxuXHRjb25zdHJ1Y3Rvcihjb250ZW50VHlwZSkge1xuXHRcdHN1cGVyKCk7XG5cdFx0dGhpcy5vZmZzZXQgPSAwO1xuXHRcdHRoaXMuY29udGVudFR5cGUgPSBjb250ZW50VHlwZTtcblx0XHR0aGlzLmJsb2IgPSBuZXcgQmxvYihbXSwgeyB0eXBlOiBjb250ZW50VHlwZSB9KTtcblx0fVxuXG5cdGFzeW5jIHdyaXRlVWludDhBcnJheShhcnJheSkge1xuXHRcdHN1cGVyLndyaXRlVWludDhBcnJheShhcnJheSk7XG5cdFx0dGhpcy5ibG9iID0gbmV3IEJsb2IoW3RoaXMuYmxvYiwgYXJyYXkuYnVmZmVyXSwgeyB0eXBlOiB0aGlzLmNvbnRlbnRUeXBlIH0pO1xuXHRcdHRoaXMub2Zmc2V0ID0gdGhpcy5ibG9iLnNpemU7XG5cdH1cblxuXHRnZXREYXRhKCkge1xuXHRcdHJldHVybiB0aGlzLmJsb2I7XG5cdH1cbn1cblxuY2xhc3MgRmV0Y2hSZWFkZXIgZXh0ZW5kcyBSZWFkZXIge1xuXG5cdGNvbnN0cnVjdG9yKHVybCwgb3B0aW9ucykge1xuXHRcdHN1cGVyKCk7XG5cdFx0dGhpcy51cmwgPSB1cmw7XG5cdFx0dGhpcy5wcmV2ZW50SGVhZFJlcXVlc3QgPSBvcHRpb25zLnByZXZlbnRIZWFkUmVxdWVzdDtcblx0XHR0aGlzLnVzZVJhbmdlSGVhZGVyID0gb3B0aW9ucy51c2VSYW5nZUhlYWRlcjtcblx0XHR0aGlzLmZvcmNlUmFuZ2VSZXF1ZXN0cyA9IG9wdGlvbnMuZm9yY2VSYW5nZVJlcXVlc3RzO1xuXHRcdHRoaXMub3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oe30sIG9wdGlvbnMpO1xuXHRcdGRlbGV0ZSB0aGlzLm9wdGlvbnMucHJldmVudEhlYWRSZXF1ZXN0O1xuXHRcdGRlbGV0ZSB0aGlzLm9wdGlvbnMudXNlUmFuZ2VIZWFkZXI7XG5cdFx0ZGVsZXRlIHRoaXMub3B0aW9ucy5mb3JjZVJhbmdlUmVxdWVzdHM7XG5cdFx0ZGVsZXRlIHRoaXMub3B0aW9ucy51c2VYSFI7XG5cdH1cblxuXHRhc3luYyBpbml0KCkge1xuXHRcdHN1cGVyLmluaXQoKTtcblx0XHRpZiAoaXNIdHRwRmFtaWx5KHRoaXMudXJsKSAmJiAhdGhpcy5wcmV2ZW50SGVhZFJlcXVlc3QpIHtcblx0XHRcdGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgc2VuZEZldGNoUmVxdWVzdChIVFRQX01FVEhPRF9IRUFELCB0aGlzLnVybCwgdGhpcy5vcHRpb25zKTtcblx0XHRcdHRoaXMuc2l6ZSA9IE51bWJlcihyZXNwb25zZS5oZWFkZXJzLmdldChIVFRQX0hFQURFUl9DT05URU5UX0xFTkdUSCkpO1xuXHRcdFx0aWYgKCF0aGlzLmZvcmNlUmFuZ2VSZXF1ZXN0cyAmJiB0aGlzLnVzZVJhbmdlSGVhZGVyICYmIHJlc3BvbnNlLmhlYWRlcnMuZ2V0KEhUVFBfSEVBREVSX0FDQ0VQVF9SQU5HRVMpICE9IEhUVFBfUkFOR0VfVU5JVCkge1xuXHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoRVJSX0hUVFBfUkFOR0UpO1xuXHRcdFx0fSBlbHNlIGlmICh0aGlzLnNpemUgPT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHRhd2FpdCBnZXRGZXRjaERhdGEodGhpcywgdGhpcy5vcHRpb25zKTtcblx0XHRcdH1cblx0XHR9IGVsc2Uge1xuXHRcdFx0YXdhaXQgZ2V0RmV0Y2hEYXRhKHRoaXMsIHRoaXMub3B0aW9ucyk7XG5cdFx0fVxuXHR9XG5cblx0YXN5bmMgcmVhZFVpbnQ4QXJyYXkoaW5kZXgsIGxlbmd0aCkge1xuXHRcdGlmICh0aGlzLnVzZVJhbmdlSGVhZGVyKSB7XG5cdFx0XHRjb25zdCByZXNwb25zZSA9IGF3YWl0IHNlbmRGZXRjaFJlcXVlc3QoSFRUUF9NRVRIT0RfR0VULCB0aGlzLnVybCwgdGhpcy5vcHRpb25zLCBPYmplY3QuYXNzaWduKHt9LCB0aGlzLm9wdGlvbnMuaGVhZGVycyxcblx0XHRcdFx0eyBIRUFERVJfUkFOR0U6IEhUVFBfUkFOR0VfVU5JVCArIFwiPVwiICsgaW5kZXggKyBcIi1cIiArIChpbmRleCArIGxlbmd0aCAtIDEpIH0pKTtcblx0XHRcdGlmIChyZXNwb25zZS5zdGF0dXMgIT0gMjA2KSB7XG5cdFx0XHRcdHRocm93IG5ldyBFcnJvcihFUlJfSFRUUF9SQU5HRSk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gbmV3IFVpbnQ4QXJyYXkoYXdhaXQgcmVzcG9uc2UuYXJyYXlCdWZmZXIoKSk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGlmICghdGhpcy5kYXRhKSB7XG5cdFx0XHRcdGF3YWl0IGdldEZldGNoRGF0YSh0aGlzLCB0aGlzLm9wdGlvbnMpO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIG5ldyBVaW50OEFycmF5KHRoaXMuZGF0YS5zdWJhcnJheShpbmRleCwgaW5kZXggKyBsZW5ndGgpKTtcblx0XHR9XG5cdH1cbn1cblxuYXN5bmMgZnVuY3Rpb24gZ2V0RmV0Y2hEYXRhKGh0dHBSZWFkZXIsIG9wdGlvbnMpIHtcblx0Y29uc3QgcmVzcG9uc2UgPSBhd2FpdCBzZW5kRmV0Y2hSZXF1ZXN0KEhUVFBfTUVUSE9EX0dFVCwgaHR0cFJlYWRlci51cmwsIG9wdGlvbnMpO1xuXHRodHRwUmVhZGVyLmRhdGEgPSBuZXcgVWludDhBcnJheShhd2FpdCByZXNwb25zZS5hcnJheUJ1ZmZlcigpKTtcblx0aWYgKCFodHRwUmVhZGVyLnNpemUpIHtcblx0XHRodHRwUmVhZGVyLnNpemUgPSBodHRwUmVhZGVyLmRhdGEubGVuZ3RoO1xuXHR9XG59XG5cbmFzeW5jIGZ1bmN0aW9uIHNlbmRGZXRjaFJlcXVlc3QobWV0aG9kLCB1cmwsIG9wdGlvbnMsIGhlYWRlcnMpIHtcblx0aGVhZGVycyA9IE9iamVjdC5hc3NpZ24oe30sIG9wdGlvbnMuaGVhZGVycywgaGVhZGVycyk7XG5cdGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2godXJsLCBPYmplY3QuYXNzaWduKHt9LCBvcHRpb25zLCB7IG1ldGhvZCwgaGVhZGVycyB9KSk7XG5cdGlmIChyZXNwb25zZS5zdGF0dXMgPCA0MDApIHtcblx0XHRyZXR1cm4gcmVzcG9uc2U7XG5cdH0gZWxzZSB7XG5cdFx0dGhyb3cgbmV3IEVycm9yKEVSUl9IVFRQX1NUQVRVUyArIChyZXNwb25zZS5zdGF0dXNUZXh0IHx8IHJlc3BvbnNlLnN0YXR1cykpO1xuXHR9XG59XG5cbmNsYXNzIFhIUlJlYWRlciBleHRlbmRzIFJlYWRlciB7XG5cblx0Y29uc3RydWN0b3IodXJsLCBvcHRpb25zKSB7XG5cdFx0c3VwZXIoKTtcblx0XHR0aGlzLnVybCA9IHVybDtcblx0XHR0aGlzLnByZXZlbnRIZWFkUmVxdWVzdCA9IG9wdGlvbnMucHJldmVudEhlYWRSZXF1ZXN0O1xuXHRcdHRoaXMudXNlUmFuZ2VIZWFkZXIgPSBvcHRpb25zLnVzZVJhbmdlSGVhZGVyO1xuXHRcdHRoaXMuZm9yY2VSYW5nZVJlcXVlc3RzID0gb3B0aW9ucy5mb3JjZVJhbmdlUmVxdWVzdHM7XG5cdH1cblxuXHRhc3luYyBpbml0KCkge1xuXHRcdHN1cGVyLmluaXQoKTtcblx0XHRpZiAoaXNIdHRwRmFtaWx5KHRoaXMudXJsKSAmJiAhdGhpcy5wcmV2ZW50SGVhZFJlcXVlc3QpIHtcblx0XHRcdHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiBzZW5kWEhSKEhUVFBfTUVUSE9EX0hFQUQsIHRoaXMudXJsLCByZXF1ZXN0ID0+IHtcblx0XHRcdFx0dGhpcy5zaXplID0gTnVtYmVyKHJlcXVlc3QuZ2V0UmVzcG9uc2VIZWFkZXIoSFRUUF9IRUFERVJfQ09OVEVOVF9MRU5HVEgpKTtcblx0XHRcdFx0aWYgKHRoaXMudXNlUmFuZ2VIZWFkZXIpIHtcblx0XHRcdFx0XHRpZiAodGhpcy5mb3JjZVJhbmdlUmVxdWVzdHMgfHwgcmVxdWVzdC5nZXRSZXNwb25zZUhlYWRlcihIVFRQX0hFQURFUl9BQ0NFUFRfUkFOR0VTKSA9PSBIVFRQX1JBTkdFX1VOSVQpIHtcblx0XHRcdFx0XHRcdHJlc29sdmUoKTtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0cmVqZWN0KG5ldyBFcnJvcihFUlJfSFRUUF9SQU5HRSkpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSBlbHNlIGlmICh0aGlzLnNpemUgPT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHRcdGdldFhIUkRhdGEodGhpcywgdGhpcy51cmwpLnRoZW4oKCkgPT4gcmVzb2x2ZSgpKS5jYXRjaChyZWplY3QpO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHJlc29sdmUoKTtcblx0XHRcdFx0fVxuXHRcdFx0fSwgcmVqZWN0KSk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGF3YWl0IGdldFhIUkRhdGEodGhpcywgdGhpcy51cmwpO1xuXHRcdH1cblx0fVxuXG5cdGFzeW5jIHJlYWRVaW50OEFycmF5KGluZGV4LCBsZW5ndGgpIHtcblx0XHRpZiAodGhpcy51c2VSYW5nZUhlYWRlcikge1xuXHRcdFx0Y29uc3QgcmVxdWVzdCA9IGF3YWl0IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHNlbmRYSFIoSFRUUF9NRVRIT0RfR0VULCB0aGlzLnVybCwgcmVxdWVzdCA9PiByZXNvbHZlKG5ldyBVaW50OEFycmF5KHJlcXVlc3QucmVzcG9uc2UpKSwgcmVqZWN0LFxuXHRcdFx0XHRbW0hUVFBfSEVBREVSX1JBTkdFLCBIVFRQX1JBTkdFX1VOSVQgKyBcIj1cIiArIGluZGV4ICsgXCItXCIgKyAoaW5kZXggKyBsZW5ndGggLSAxKV1dKSk7XG5cdFx0XHRpZiAocmVxdWVzdC5zdGF0dXMgIT0gMjA2KSB7XG5cdFx0XHRcdHRocm93IG5ldyBFcnJvcihFUlJfSFRUUF9SQU5HRSk7XG5cdFx0XHR9XG5cdFx0fSBlbHNlIHtcblx0XHRcdGlmICghdGhpcy5kYXRhKSB7XG5cdFx0XHRcdGF3YWl0IGdldFhIUkRhdGEodGhpcywgdGhpcy51cmwpO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIG5ldyBVaW50OEFycmF5KHRoaXMuZGF0YS5zdWJhcnJheShpbmRleCwgaW5kZXggKyBsZW5ndGgpKTtcblx0XHR9XG5cdH1cbn1cblxuZnVuY3Rpb24gZ2V0WEhSRGF0YShodHRwUmVhZGVyLCB1cmwpIHtcblx0cmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHNlbmRYSFIoSFRUUF9NRVRIT0RfR0VULCB1cmwsIHJlcXVlc3QgPT4ge1xuXHRcdGh0dHBSZWFkZXIuZGF0YSA9IG5ldyBVaW50OEFycmF5KHJlcXVlc3QucmVzcG9uc2UpO1xuXHRcdGlmICghaHR0cFJlYWRlci5zaXplKSB7XG5cdFx0XHRodHRwUmVhZGVyLnNpemUgPSBodHRwUmVhZGVyLmRhdGEubGVuZ3RoO1xuXHRcdH1cblx0XHRyZXNvbHZlKCk7XG5cdH0sIHJlamVjdCkpO1xufVxuXG5mdW5jdGlvbiBzZW5kWEhSKG1ldGhvZCwgdXJsLCBvbmxvYWQsIG9uZXJyb3IsIGhlYWRlcnMgPSBbXSkge1xuXHRjb25zdCByZXF1ZXN0ID0gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XG5cdHJlcXVlc3QuYWRkRXZlbnRMaXN0ZW5lcihcImxvYWRcIiwgKCkgPT4ge1xuXHRcdGlmIChyZXF1ZXN0LnN0YXR1cyA8IDQwMCkge1xuXHRcdFx0b25sb2FkKHJlcXVlc3QpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRvbmVycm9yKEVSUl9IVFRQX1NUQVRVUyArIChyZXF1ZXN0LnN0YXR1c1RleHQgfHwgcmVxdWVzdC5zdGF0dXMpKTtcblx0XHR9XG5cdH0sIGZhbHNlKTtcblx0cmVxdWVzdC5hZGRFdmVudExpc3RlbmVyKFwiZXJyb3JcIiwgb25lcnJvciwgZmFsc2UpO1xuXHRyZXF1ZXN0Lm9wZW4obWV0aG9kLCB1cmwpO1xuXHRoZWFkZXJzLmZvckVhY2goaGVhZGVyID0+IHJlcXVlc3Quc2V0UmVxdWVzdEhlYWRlcihoZWFkZXJbMF0sIGhlYWRlclsxXSkpO1xuXHRyZXF1ZXN0LnJlc3BvbnNlVHlwZSA9IFwiYXJyYXlidWZmZXJcIjtcblx0cmVxdWVzdC5zZW5kKCk7XG5cdHJldHVybiByZXF1ZXN0O1xufVxuXG5jbGFzcyBIdHRwUmVhZGVyIGV4dGVuZHMgUmVhZGVyIHtcblxuXHRjb25zdHJ1Y3Rvcih1cmwsIG9wdGlvbnMgPSB7fSkge1xuXHRcdHN1cGVyKCk7XG5cdFx0dGhpcy51cmwgPSB1cmw7XG5cdFx0aWYgKG9wdGlvbnMudXNlWEhSKSB7XG5cdFx0XHR0aGlzLnJlYWRlciA9IG5ldyBYSFJSZWFkZXIodXJsLCBvcHRpb25zKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dGhpcy5yZWFkZXIgPSBuZXcgRmV0Y2hSZWFkZXIodXJsLCBvcHRpb25zKTtcblx0XHR9XG5cdH1cblxuXHRzZXQgc2l6ZSh2YWx1ZSkge1xuXHRcdC8vIGlnbm9yZWRcblx0fVxuXG5cdGdldCBzaXplKCkge1xuXHRcdHJldHVybiB0aGlzLnJlYWRlci5zaXplO1xuXHR9XG5cblx0YXN5bmMgaW5pdCgpIHtcblx0XHRzdXBlci5pbml0KCk7XG5cdFx0YXdhaXQgdGhpcy5yZWFkZXIuaW5pdCgpO1xuXHR9XG5cblx0YXN5bmMgcmVhZFVpbnQ4QXJyYXkoaW5kZXgsIGxlbmd0aCkge1xuXHRcdHJldHVybiB0aGlzLnJlYWRlci5yZWFkVWludDhBcnJheShpbmRleCwgbGVuZ3RoKTtcblx0fVxufVxuXG5jbGFzcyBIdHRwUmFuZ2VSZWFkZXIgZXh0ZW5kcyBIdHRwUmVhZGVyIHtcblxuXHRjb25zdHJ1Y3Rvcih1cmwsIG9wdGlvbnMgPSB7fSkge1xuXHRcdG9wdGlvbnMudXNlUmFuZ2VIZWFkZXIgPSB0cnVlO1xuXHRcdHN1cGVyKHVybCwgb3B0aW9ucyk7XG5cdH1cbn1cblxuXG5jbGFzcyBVaW50OEFycmF5UmVhZGVyIGV4dGVuZHMgUmVhZGVyIHtcblxuXHRjb25zdHJ1Y3RvcihhcnJheSkge1xuXHRcdHN1cGVyKCk7XG5cdFx0dGhpcy5hcnJheSA9IGFycmF5O1xuXHRcdHRoaXMuc2l6ZSA9IGFycmF5Lmxlbmd0aDtcblx0fVxuXG5cdGFzeW5jIHJlYWRVaW50OEFycmF5KGluZGV4LCBsZW5ndGgpIHtcblx0XHRyZXR1cm4gdGhpcy5hcnJheS5zbGljZShpbmRleCwgaW5kZXggKyBsZW5ndGgpO1xuXHR9XG59XG5cbmNsYXNzIFVpbnQ4QXJyYXlXcml0ZXIgZXh0ZW5kcyBXcml0ZXIge1xuXG5cdGNvbnN0cnVjdG9yKCkge1xuXHRcdHN1cGVyKCk7XG5cdFx0dGhpcy5hcnJheSA9IG5ldyBVaW50OEFycmF5KDApO1xuXHR9XG5cblx0YXN5bmMgd3JpdGVVaW50OEFycmF5KGFycmF5KSB7XG5cdFx0c3VwZXIud3JpdGVVaW50OEFycmF5KGFycmF5KTtcblx0XHRjb25zdCBwcmV2aW91c0FycmF5ID0gdGhpcy5hcnJheTtcblx0XHR0aGlzLmFycmF5ID0gbmV3IFVpbnQ4QXJyYXkocHJldmlvdXNBcnJheS5sZW5ndGggKyBhcnJheS5sZW5ndGgpO1xuXHRcdHRoaXMuYXJyYXkuc2V0KHByZXZpb3VzQXJyYXkpO1xuXHRcdHRoaXMuYXJyYXkuc2V0KGFycmF5LCBwcmV2aW91c0FycmF5Lmxlbmd0aCk7XG5cdH1cblxuXHRnZXREYXRhKCkge1xuXHRcdHJldHVybiB0aGlzLmFycmF5O1xuXHR9XG59XG5cbmZ1bmN0aW9uIGlzSHR0cEZhbWlseSh1cmwpIHtcblx0aWYgKHR5cGVvZiBkb2N1bWVudCAhPSBcInVuZGVmaW5lZFwiKSB7XG5cdFx0Y29uc3QgYW5jaG9yID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImFcIik7XG5cdFx0YW5jaG9yLmhyZWYgPSB1cmw7XG5cdFx0cmV0dXJuIGFuY2hvci5wcm90b2NvbCA9PSBcImh0dHA6XCIgfHwgYW5jaG9yLnByb3RvY29sID09IFwiaHR0cHM6XCI7XG5cdH0gZWxzZSB7XG5cdFx0cmV0dXJuIC9eaHR0cHM/OlxcL1xcLy9pLnRlc3QodXJsKTtcblx0fVxufVxuXG4vKlxuIENvcHlyaWdodCAoYykgMjAyMSBHaWxkYXMgTG9ybWVhdS4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cblxuIFJlZGlzdHJpYnV0aW9uIGFuZCB1c2UgaW4gc291cmNlIGFuZCBiaW5hcnkgZm9ybXMsIHdpdGggb3Igd2l0aG91dFxuIG1vZGlmaWNhdGlvbiwgYXJlIHBlcm1pdHRlZCBwcm92aWRlZCB0aGF0IHRoZSBmb2xsb3dpbmcgY29uZGl0aW9ucyBhcmUgbWV0OlxuXG4gMS4gUmVkaXN0cmlidXRpb25zIG9mIHNvdXJjZSBjb2RlIG11c3QgcmV0YWluIHRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlLFxuIHRoaXMgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nIGRpc2NsYWltZXIuXG5cbiAyLiBSZWRpc3RyaWJ1dGlvbnMgaW4gYmluYXJ5IGZvcm0gbXVzdCByZXByb2R1Y2UgdGhlIGFib3ZlIGNvcHlyaWdodCBcbiBub3RpY2UsIHRoaXMgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nIGRpc2NsYWltZXIgaW4gXG4gdGhlIGRvY3VtZW50YXRpb24gYW5kL29yIG90aGVyIG1hdGVyaWFscyBwcm92aWRlZCB3aXRoIHRoZSBkaXN0cmlidXRpb24uXG5cbiAzLiBUaGUgbmFtZXMgb2YgdGhlIGF1dGhvcnMgbWF5IG5vdCBiZSB1c2VkIHRvIGVuZG9yc2Ugb3IgcHJvbW90ZSBwcm9kdWN0c1xuIGRlcml2ZWQgZnJvbSB0aGlzIHNvZnR3YXJlIHdpdGhvdXQgc3BlY2lmaWMgcHJpb3Igd3JpdHRlbiBwZXJtaXNzaW9uLlxuXG4gVEhJUyBTT0ZUV0FSRSBJUyBQUk9WSURFRCAnJ0FTIElTJycgQU5EIEFOWSBFWFBSRVNTRUQgT1IgSU1QTElFRCBXQVJSQU5USUVTLFxuIElOQ0xVRElORywgQlVUIE5PVCBMSU1JVEVEIFRPLCBUSEUgSU1QTElFRCBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSBBTkRcbiBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBUkUgRElTQ0xBSU1FRC4gSU4gTk8gRVZFTlQgU0hBTEwgSkNSQUZULFxuIElOQy4gT1IgQU5ZIENPTlRSSUJVVE9SUyBUTyBUSElTIFNPRlRXQVJFIEJFIExJQUJMRSBGT1IgQU5ZIERJUkVDVCwgSU5ESVJFQ1QsXG4gSU5DSURFTlRBTCwgU1BFQ0lBTCwgRVhFTVBMQVJZLCBPUiBDT05TRVFVRU5USUFMIERBTUFHRVMgKElOQ0xVRElORywgQlVUIE5PVFxuIExJTUlURUQgVE8sIFBST0NVUkVNRU5UIE9GIFNVQlNUSVRVVEUgR09PRFMgT1IgU0VSVklDRVM7IExPU1MgT0YgVVNFLCBEQVRBLFxuIE9SIFBST0ZJVFM7IE9SIEJVU0lORVNTIElOVEVSUlVQVElPTikgSE9XRVZFUiBDQVVTRUQgQU5EIE9OIEFOWSBUSEVPUlkgT0ZcbiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQ09OVFJBQ1QsIFNUUklDVCBMSUFCSUxJVFksIE9SIFRPUlQgKElOQ0xVRElOR1xuIE5FR0xJR0VOQ0UgT1IgT1RIRVJXSVNFKSBBUklTSU5HIElOIEFOWSBXQVkgT1VUIE9GIFRIRSBVU0UgT0YgVEhJUyBTT0ZUV0FSRSxcbiBFVkVOIElGIEFEVklTRUQgT0YgVEhFIFBPU1NJQklMSVRZIE9GIFNVQ0ggREFNQUdFLlxuICovXG5cbmNvbnN0IE1BWF8zMl9CSVRTID0gMHhmZmZmZmZmZjtcbmNvbnN0IE1BWF8xNl9CSVRTID0gMHhmZmZmO1xuY29uc3QgQ09NUFJFU1NJT05fTUVUSE9EX0RFRkxBVEUgPSAweDA4O1xuY29uc3QgQ09NUFJFU1NJT05fTUVUSE9EX1NUT1JFID0gMHgwMDtcbmNvbnN0IENPTVBSRVNTSU9OX01FVEhPRF9BRVMgPSAweDYzO1xuXG5jb25zdCBMT0NBTF9GSUxFX0hFQURFUl9TSUdOQVRVUkUgPSAweDA0MDM0YjUwO1xuY29uc3QgREFUQV9ERVNDUklQVE9SX1JFQ09SRF9TSUdOQVRVUkUgPSAweDA4MDc0YjUwO1xuY29uc3QgQ0VOVFJBTF9GSUxFX0hFQURFUl9TSUdOQVRVUkUgPSAweDAyMDE0YjUwO1xuY29uc3QgRU5EX09GX0NFTlRSQUxfRElSX1NJR05BVFVSRSA9IDB4MDYwNTRiNTA7XG5jb25zdCBaSVA2NF9FTkRfT0ZfQ0VOVFJBTF9ESVJfU0lHTkFUVVJFID0gMHgwNjA2NGI1MDtcbmNvbnN0IFpJUDY0X0VORF9PRl9DRU5UUkFMX0RJUl9MT0NBVE9SX1NJR05BVFVSRSA9IDB4MDcwNjRiNTA7XG5jb25zdCBFTkRfT0ZfQ0VOVFJBTF9ESVJfTEVOR1RIID0gMjI7XG5jb25zdCBaSVA2NF9FTkRfT0ZfQ0VOVFJBTF9ESVJfTE9DQVRPUl9MRU5HVEggPSAyMDtcbmNvbnN0IFpJUDY0X0VORF9PRl9DRU5UUkFMX0RJUl9MRU5HVEggPSA1NjtcbmNvbnN0IFpJUDY0X0VORF9PRl9DRU5UUkFMX0RJUl9UT1RBTF9MRU5HVEggPSBFTkRfT0ZfQ0VOVFJBTF9ESVJfTEVOR1RIICsgWklQNjRfRU5EX09GX0NFTlRSQUxfRElSX0xPQ0FUT1JfTEVOR1RIICsgWklQNjRfRU5EX09GX0NFTlRSQUxfRElSX0xFTkdUSDtcblxuY29uc3QgWklQNjRfVE9UQUxfTlVNQkVSX09GX0RJU0tTID0gMTtcblxuY29uc3QgRVhUUkFGSUVMRF9UWVBFX1pJUDY0ID0gMHgwMDAxO1xuY29uc3QgRVhUUkFGSUVMRF9UWVBFX0FFUyA9IDB4OTkwMTtcbmNvbnN0IEVYVFJBRklFTERfVFlQRV9OVEZTID0gMHgwMDBhO1xuY29uc3QgRVhUUkFGSUVMRF9UWVBFX05URlNfVEFHMSA9IDB4MDAwMTtcbmNvbnN0IEVYVFJBRklFTERfVFlQRV9FWFRFTkRFRF9USU1FU1RBTVAgPSAweDU0NTU7XG5jb25zdCBFWFRSQUZJRUxEX1RZUEVfVU5JQ09ERV9QQVRIID0gMHg3MDc1O1xuY29uc3QgRVhUUkFGSUVMRF9UWVBFX1VOSUNPREVfQ09NTUVOVCA9IDB4NjM3NTtcblxuY29uc3QgQklURkxBR19FTkNSWVBURUQgPSAweDAxO1xuY29uc3QgQklURkxBR19MRVZFTCA9IDB4MDY7XG5jb25zdCBCSVRGTEFHX0RBVEFfREVTQ1JJUFRPUiA9IDB4MDAwODtcbmNvbnN0IEJJVEZMQUdfTEFOR19FTkNPRElOR19GTEFHID0gMHgwODAwO1xuY29uc3QgRklMRV9BVFRSX01TRE9TX0RJUl9NQVNLID0gMHgxMDtcblxuY29uc3QgVkVSU0lPTl9ERUZMQVRFID0gMHgxNDtcbmNvbnN0IFZFUlNJT05fWklQNjQgPSAweDJEO1xuY29uc3QgVkVSU0lPTl9BRVMgPSAweDMzO1xuXG5jb25zdCBESVJFQ1RPUllfU0lHTkFUVVJFID0gXCIvXCI7XG5cbmNvbnN0IE1BWF9EQVRFID0gbmV3IERhdGUoMjEwNywgMTEsIDMxKTtcbmNvbnN0IE1JTl9EQVRFID0gbmV3IERhdGUoMTk4MCwgMCwgMSk7XG5cbi8qXG4gQ29weXJpZ2h0IChjKSAyMDIxIEdpbGRhcyBMb3JtZWF1LiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuXG4gUmVkaXN0cmlidXRpb24gYW5kIHVzZSBpbiBzb3VyY2UgYW5kIGJpbmFyeSBmb3Jtcywgd2l0aCBvciB3aXRob3V0XG4gbW9kaWZpY2F0aW9uLCBhcmUgcGVybWl0dGVkIHByb3ZpZGVkIHRoYXQgdGhlIGZvbGxvd2luZyBjb25kaXRpb25zIGFyZSBtZXQ6XG5cbiAxLiBSZWRpc3RyaWJ1dGlvbnMgb2Ygc291cmNlIGNvZGUgbXVzdCByZXRhaW4gdGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UsXG4gdGhpcyBsaXN0IG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmcgZGlzY2xhaW1lci5cblxuIDIuIFJlZGlzdHJpYnV0aW9ucyBpbiBiaW5hcnkgZm9ybSBtdXN0IHJlcHJvZHVjZSB0aGUgYWJvdmUgY29weXJpZ2h0IFxuIG5vdGljZSwgdGhpcyBsaXN0IG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmcgZGlzY2xhaW1lciBpbiBcbiB0aGUgZG9jdW1lbnRhdGlvbiBhbmQvb3Igb3RoZXIgbWF0ZXJpYWxzIHByb3ZpZGVkIHdpdGggdGhlIGRpc3RyaWJ1dGlvbi5cblxuIDMuIFRoZSBuYW1lcyBvZiB0aGUgYXV0aG9ycyBtYXkgbm90IGJlIHVzZWQgdG8gZW5kb3JzZSBvciBwcm9tb3RlIHByb2R1Y3RzXG4gZGVyaXZlZCBmcm9tIHRoaXMgc29mdHdhcmUgd2l0aG91dCBzcGVjaWZpYyBwcmlvciB3cml0dGVuIHBlcm1pc3Npb24uXG5cbiBUSElTIFNPRlRXQVJFIElTIFBST1ZJREVEICcnQVMgSVMnJyBBTkQgQU5ZIEVYUFJFU1NFRCBPUiBJTVBMSUVEIFdBUlJBTlRJRVMsXG4gSU5DTFVESU5HLCBCVVQgTk9UIExJTUlURUQgVE8sIFRIRSBJTVBMSUVEIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZIEFORFxuIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFSRSBESVNDTEFJTUVELiBJTiBOTyBFVkVOVCBTSEFMTCBKQ1JBRlQsXG4gSU5DLiBPUiBBTlkgQ09OVFJJQlVUT1JTIFRPIFRISVMgU09GVFdBUkUgQkUgTElBQkxFIEZPUiBBTlkgRElSRUNULCBJTkRJUkVDVCxcbiBJTkNJREVOVEFMLCBTUEVDSUFMLCBFWEVNUExBUlksIE9SIENPTlNFUVVFTlRJQUwgREFNQUdFUyAoSU5DTFVESU5HLCBCVVQgTk9UXG4gTElNSVRFRCBUTywgUFJPQ1VSRU1FTlQgT0YgU1VCU1RJVFVURSBHT09EUyBPUiBTRVJWSUNFUzsgTE9TUyBPRiBVU0UsIERBVEEsXG4gT1IgUFJPRklUUzsgT1IgQlVTSU5FU1MgSU5URVJSVVBUSU9OKSBIT1dFVkVSIENBVVNFRCBBTkQgT04gQU5ZIFRIRU9SWSBPRlxuIExJQUJJTElUWSwgV0hFVEhFUiBJTiBDT05UUkFDVCwgU1RSSUNUIExJQUJJTElUWSwgT1IgVE9SVCAoSU5DTFVESU5HXG4gTkVHTElHRU5DRSBPUiBPVEhFUldJU0UpIEFSSVNJTkcgSU4gQU5ZIFdBWSBPVVQgT0YgVEhFIFVTRSBPRiBUSElTIFNPRlRXQVJFLFxuIEVWRU4gSUYgQURWSVNFRCBPRiBUSEUgUE9TU0lCSUxJVFkgT0YgU1VDSCBEQU1BR0UuXG4gKi9cblxuY29uc3QgQ1A0MzcgPSBcIlxcMOKYuuKYu+KZpeKZpuKZo+KZoOKAouKXmOKXi+KXmeKZguKZgOKZquKZq+KYvOKWuuKXhOKGleKAvMK2wqfilqzihqjihpHihpPihpLihpDiiJ/ihpTilrLilrwgIVxcXCIjJCUmJygpKissLS4vMDEyMzQ1Njc4OTo7PD0+P0BBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWltcXFxcXV5fYGFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6e3x9fuKMgsOHw7zDqcOiw6TDoMOlw6fDqsOrw6jDr8Ouw6zDhMOFw4nDpsOGw7TDtsOyw7vDucO/w5bDnMKiwqPCpeKCp8aSw6HDrcOzw7rDscORwqrCusK/4oyQwqzCvcK8wqHCq8K74paR4paS4paT4pSC4pSk4pWh4pWi4pWW4pWV4pWj4pWR4pWX4pWd4pWc4pWb4pSQ4pSU4pS04pSs4pSc4pSA4pS84pWe4pWf4pWa4pWU4pWp4pWm4pWg4pWQ4pWs4pWn4pWo4pWk4pWl4pWZ4pWY4pWS4pWT4pWr4pWq4pSY4pSM4paI4paE4paM4paQ4paAzrHDn86Tz4DOo8+DwrXPhM6mzpjOqc604oiez4bOteKIqeKJocKx4oml4omk4oyg4oyhw7fiiYjCsOKImcK34oia4oG/wrLilqAgXCIuc3BsaXQoXCJcIik7XG5cbnZhciBkZWNvZGVDUDQzNyA9IHN0cmluZ1ZhbHVlID0+IHtcblx0bGV0IHJlc3VsdCA9IFwiXCI7XG5cdGZvciAobGV0IGluZGV4Q2hhcmFjdGVyID0gMDsgaW5kZXhDaGFyYWN0ZXIgPCBzdHJpbmdWYWx1ZS5sZW5ndGg7IGluZGV4Q2hhcmFjdGVyKyspIHtcblx0XHRyZXN1bHQgKz0gQ1A0Mzdbc3RyaW5nVmFsdWVbaW5kZXhDaGFyYWN0ZXJdXTtcblx0fVxuXHRyZXR1cm4gcmVzdWx0O1xufTtcblxuLypcbiBDb3B5cmlnaHQgKGMpIDIwMjEgR2lsZGFzIExvcm1lYXUuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG5cbiBSZWRpc3RyaWJ1dGlvbiBhbmQgdXNlIGluIHNvdXJjZSBhbmQgYmluYXJ5IGZvcm1zLCB3aXRoIG9yIHdpdGhvdXRcbiBtb2RpZmljYXRpb24sIGFyZSBwZXJtaXR0ZWQgcHJvdmlkZWQgdGhhdCB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnMgYXJlIG1ldDpcblxuIDEuIFJlZGlzdHJpYnV0aW9ucyBvZiBzb3VyY2UgY29kZSBtdXN0IHJldGFpbiB0aGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSxcbiB0aGlzIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZyBkaXNjbGFpbWVyLlxuXG4gMi4gUmVkaXN0cmlidXRpb25zIGluIGJpbmFyeSBmb3JtIG11c3QgcmVwcm9kdWNlIHRoZSBhYm92ZSBjb3B5cmlnaHQgXG4gbm90aWNlLCB0aGlzIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZyBkaXNjbGFpbWVyIGluIFxuIHRoZSBkb2N1bWVudGF0aW9uIGFuZC9vciBvdGhlciBtYXRlcmlhbHMgcHJvdmlkZWQgd2l0aCB0aGUgZGlzdHJpYnV0aW9uLlxuXG4gMy4gVGhlIG5hbWVzIG9mIHRoZSBhdXRob3JzIG1heSBub3QgYmUgdXNlZCB0byBlbmRvcnNlIG9yIHByb21vdGUgcHJvZHVjdHNcbiBkZXJpdmVkIGZyb20gdGhpcyBzb2Z0d2FyZSB3aXRob3V0IHNwZWNpZmljIHByaW9yIHdyaXR0ZW4gcGVybWlzc2lvbi5cblxuIFRISVMgU09GVFdBUkUgSVMgUFJPVklERUQgJydBUyBJUycnIEFORCBBTlkgRVhQUkVTU0VEIE9SIElNUExJRUQgV0FSUkFOVElFUyxcbiBJTkNMVURJTkcsIEJVVCBOT1QgTElNSVRFRCBUTywgVEhFIElNUExJRUQgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFkgQU5EXG4gRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQVJFIERJU0NMQUlNRUQuIElOIE5PIEVWRU5UIFNIQUxMIEpDUkFGVCxcbiBJTkMuIE9SIEFOWSBDT05UUklCVVRPUlMgVE8gVEhJUyBTT0ZUV0FSRSBCRSBMSUFCTEUgRk9SIEFOWSBESVJFQ1QsIElORElSRUNULFxuIElOQ0lERU5UQUwsIFNQRUNJQUwsIEVYRU1QTEFSWSwgT1IgQ09OU0VRVUVOVElBTCBEQU1BR0VTIChJTkNMVURJTkcsIEJVVCBOT1RcbiBMSU1JVEVEIFRPLCBQUk9DVVJFTUVOVCBPRiBTVUJTVElUVVRFIEdPT0RTIE9SIFNFUlZJQ0VTOyBMT1NTIE9GIFVTRSwgREFUQSxcbiBPUiBQUk9GSVRTOyBPUiBCVVNJTkVTUyBJTlRFUlJVUFRJT04pIEhPV0VWRVIgQ0FVU0VEIEFORCBPTiBBTlkgVEhFT1JZIE9GXG4gTElBQklMSVRZLCBXSEVUSEVSIElOIENPTlRSQUNULCBTVFJJQ1QgTElBQklMSVRZLCBPUiBUT1JUIChJTkNMVURJTkdcbiBORUdMSUdFTkNFIE9SIE9USEVSV0lTRSkgQVJJU0lORyBJTiBBTlkgV0FZIE9VVCBPRiBUSEUgVVNFIE9GIFRISVMgU09GVFdBUkUsXG4gRVZFTiBJRiBBRFZJU0VEIE9GIFRIRSBQT1NTSUJJTElUWSBPRiBTVUNIIERBTUFHRS5cbiAqL1xuXG5jb25zdCBQUk9QRVJUWV9OQU1FUyA9IFtcblx0XCJmaWxlbmFtZVwiLCBcInJhd0ZpbGVuYW1lXCIsIFwiZGlyZWN0b3J5XCIsIFwiZW5jcnlwdGVkXCIsIFwiY29tcHJlc3NlZFNpemVcIiwgXCJ1bmNvbXByZXNzZWRTaXplXCIsXG5cdFwibGFzdE1vZERhdGVcIiwgXCJyYXdMYXN0TW9kRGF0ZVwiLCBcImNvbW1lbnRcIiwgXCJyYXdDb21tZW50XCIsIFwic2lnbmF0dXJlXCIsIFwiZXh0cmFGaWVsZFwiLFxuXHRcInJhd0V4dHJhRmllbGRcIiwgXCJiaXRGbGFnXCIsIFwiZXh0cmFGaWVsZFppcDY0XCIsIFwiZXh0cmFGaWVsZFVuaWNvZGVQYXRoXCIsIFwiZXh0cmFGaWVsZFVuaWNvZGVDb21tZW50XCIsXG5cdFwiZXh0cmFGaWVsZEFFU1wiLCBcImZpbGVuYW1lVVRGOFwiLCBcImNvbW1lbnRVVEY4XCIsIFwib2Zmc2V0XCIsIFwiemlwNjRcIiwgXCJjb21wcmVzc2lvbk1ldGhvZFwiLFxuXHRcImV4dHJhRmllbGROVEZTXCIsIFwibGFzdEFjY2Vzc0RhdGVcIiwgXCJjcmVhdGlvbkRhdGVcIiwgXCJleHRyYUZpZWxkRXh0ZW5kZWRUaW1lc3RhbXBcIixcblx0XCJ2ZXJzaW9uXCIsIFwidmVyc2lvbk1hZGVCeVwiLCBcIm1zRG9zQ29tcGF0aWJsZVwiLCBcImludGVybmFsRmlsZUF0dHJpYnV0ZVwiLCBcImV4dGVybmFsRmlsZUF0dHJpYnV0ZVwiXTtcblxuY2xhc3MgRW50cnkge1xuXG5cdGNvbnN0cnVjdG9yKGRhdGEpIHtcblx0XHRQUk9QRVJUWV9OQU1FUy5mb3JFYWNoKG5hbWUgPT4gdGhpc1tuYW1lXSA9IGRhdGFbbmFtZV0pO1xuXHR9XG5cbn1cblxuLypcbiBDb3B5cmlnaHQgKGMpIDIwMjEgR2lsZGFzIExvcm1lYXUuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG5cbiBSZWRpc3RyaWJ1dGlvbiBhbmQgdXNlIGluIHNvdXJjZSBhbmQgYmluYXJ5IGZvcm1zLCB3aXRoIG9yIHdpdGhvdXRcbiBtb2RpZmljYXRpb24sIGFyZSBwZXJtaXR0ZWQgcHJvdmlkZWQgdGhhdCB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnMgYXJlIG1ldDpcblxuIDEuIFJlZGlzdHJpYnV0aW9ucyBvZiBzb3VyY2UgY29kZSBtdXN0IHJldGFpbiB0aGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSxcbiB0aGlzIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZyBkaXNjbGFpbWVyLlxuXG4gMi4gUmVkaXN0cmlidXRpb25zIGluIGJpbmFyeSBmb3JtIG11c3QgcmVwcm9kdWNlIHRoZSBhYm92ZSBjb3B5cmlnaHQgXG4gbm90aWNlLCB0aGlzIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZyBkaXNjbGFpbWVyIGluIFxuIHRoZSBkb2N1bWVudGF0aW9uIGFuZC9vciBvdGhlciBtYXRlcmlhbHMgcHJvdmlkZWQgd2l0aCB0aGUgZGlzdHJpYnV0aW9uLlxuXG4gMy4gVGhlIG5hbWVzIG9mIHRoZSBhdXRob3JzIG1heSBub3QgYmUgdXNlZCB0byBlbmRvcnNlIG9yIHByb21vdGUgcHJvZHVjdHNcbiBkZXJpdmVkIGZyb20gdGhpcyBzb2Z0d2FyZSB3aXRob3V0IHNwZWNpZmljIHByaW9yIHdyaXR0ZW4gcGVybWlzc2lvbi5cblxuIFRISVMgU09GVFdBUkUgSVMgUFJPVklERUQgJydBUyBJUycnIEFORCBBTlkgRVhQUkVTU0VEIE9SIElNUExJRUQgV0FSUkFOVElFUyxcbiBJTkNMVURJTkcsIEJVVCBOT1QgTElNSVRFRCBUTywgVEhFIElNUExJRUQgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFkgQU5EXG4gRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQVJFIERJU0NMQUlNRUQuIElOIE5PIEVWRU5UIFNIQUxMIEpDUkFGVCxcbiBJTkMuIE9SIEFOWSBDT05UUklCVVRPUlMgVE8gVEhJUyBTT0ZUV0FSRSBCRSBMSUFCTEUgRk9SIEFOWSBESVJFQ1QsIElORElSRUNULFxuIElOQ0lERU5UQUwsIFNQRUNJQUwsIEVYRU1QTEFSWSwgT1IgQ09OU0VRVUVOVElBTCBEQU1BR0VTIChJTkNMVURJTkcsIEJVVCBOT1RcbiBMSU1JVEVEIFRPLCBQUk9DVVJFTUVOVCBPRiBTVUJTVElUVVRFIEdPT0RTIE9SIFNFUlZJQ0VTOyBMT1NTIE9GIFVTRSwgREFUQSxcbiBPUiBQUk9GSVRTOyBPUiBCVVNJTkVTUyBJTlRFUlJVUFRJT04pIEhPV0VWRVIgQ0FVU0VEIEFORCBPTiBBTlkgVEhFT1JZIE9GXG4gTElBQklMSVRZLCBXSEVUSEVSIElOIENPTlRSQUNULCBTVFJJQ1QgTElBQklMSVRZLCBPUiBUT1JUIChJTkNMVURJTkdcbiBORUdMSUdFTkNFIE9SIE9USEVSV0lTRSkgQVJJU0lORyBJTiBBTlkgV0FZIE9VVCBPRiBUSEUgVVNFIE9GIFRISVMgU09GVFdBUkUsXG4gRVZFTiBJRiBBRFZJU0VEIE9GIFRIRSBQT1NTSUJJTElUWSBPRiBTVUNIIERBTUFHRS5cbiAqL1xuXG5jb25zdCBFUlJfQkFEX0ZPUk1BVCA9IFwiRmlsZSBmb3JtYXQgaXMgbm90IHJlY29nbml6ZWRcIjtcbmNvbnN0IEVSUl9FT0NEUl9OT1RfRk9VTkQgPSBcIkVuZCBvZiBjZW50cmFsIGRpcmVjdG9yeSBub3QgZm91bmRcIjtcbmNvbnN0IEVSUl9FT0NEUl9aSVA2NF9OT1RfRk9VTkQgPSBcIkVuZCBvZiBaaXA2NCBjZW50cmFsIGRpcmVjdG9yeSBub3QgZm91bmRcIjtcbmNvbnN0IEVSUl9FT0NEUl9MT0NBVE9SX1pJUDY0X05PVF9GT1VORCA9IFwiRW5kIG9mIFppcDY0IGNlbnRyYWwgZGlyZWN0b3J5IGxvY2F0b3Igbm90IGZvdW5kXCI7XG5jb25zdCBFUlJfQ0VOVFJBTF9ESVJFQ1RPUllfTk9UX0ZPVU5EID0gXCJDZW50cmFsIGRpcmVjdG9yeSBoZWFkZXIgbm90IGZvdW5kXCI7XG5jb25zdCBFUlJfTE9DQUxfRklMRV9IRUFERVJfTk9UX0ZPVU5EID0gXCJMb2NhbCBmaWxlIGhlYWRlciBub3QgZm91bmRcIjtcbmNvbnN0IEVSUl9FWFRSQUZJRUxEX1pJUDY0X05PVF9GT1VORCA9IFwiWmlwNjQgZXh0cmEgZmllbGQgbm90IGZvdW5kXCI7XG5jb25zdCBFUlJfRU5DUllQVEVEID0gXCJGaWxlIGNvbnRhaW5zIGVuY3J5cHRlZCBlbnRyeVwiO1xuY29uc3QgRVJSX1VOU1VQUE9SVEVEX0VOQ1JZUFRJT04gPSBcIkVuY3J5cHRpb24gbWV0aG9kIG5vdCBzdXBwb3J0ZWRcIjtcbmNvbnN0IEVSUl9VTlNVUFBPUlRFRF9DT01QUkVTU0lPTiA9IFwiQ29tcHJlc3Npb24gbWV0aG9kIG5vdCBzdXBwb3J0ZWRcIjtcbmNvbnN0IENIQVJTRVRfVVRGOCA9IFwidXRmLThcIjtcbmNvbnN0IFpJUDY0X1BST1BFUlRJRVMgPSBbXCJ1bmNvbXByZXNzZWRTaXplXCIsIFwiY29tcHJlc3NlZFNpemVcIiwgXCJvZmZzZXRcIl07XG5cbmNsYXNzIFppcFJlYWRlciB7XG5cblx0Y29uc3RydWN0b3IocmVhZGVyLCBvcHRpb25zID0ge30pIHtcblx0XHRPYmplY3QuYXNzaWduKHRoaXMsIHtcblx0XHRcdHJlYWRlcixcblx0XHRcdG9wdGlvbnMsXG5cdFx0XHRjb25maWc6IGdldENvbmZpZ3VyYXRpb24oKVxuXHRcdH0pO1xuXHR9XG5cblx0YXN5bmMgZ2V0RW50cmllcyhvcHRpb25zID0ge30pIHtcblx0XHRjb25zdCB6aXBSZWFkZXIgPSB0aGlzO1xuXHRcdGNvbnN0IHJlYWRlciA9IHppcFJlYWRlci5yZWFkZXI7XG5cdFx0aWYgKCFyZWFkZXIuaW5pdGlhbGl6ZWQpIHtcblx0XHRcdGF3YWl0IHJlYWRlci5pbml0KCk7XG5cdFx0fVxuXHRcdGlmIChyZWFkZXIuc2l6ZSA8IEVORF9PRl9DRU5UUkFMX0RJUl9MRU5HVEgpIHtcblx0XHRcdHRocm93IG5ldyBFcnJvcihFUlJfQkFEX0ZPUk1BVCk7XG5cdFx0fVxuXHRcdGNvbnN0IGVuZE9mRGlyZWN0b3J5SW5mbyA9IGF3YWl0IHNlZWtTaWduYXR1cmUocmVhZGVyLCBFTkRfT0ZfQ0VOVFJBTF9ESVJfU0lHTkFUVVJFLCByZWFkZXIuc2l6ZSwgRU5EX09GX0NFTlRSQUxfRElSX0xFTkdUSCwgTUFYXzE2X0JJVFMgKiAxNik7XG5cdFx0aWYgKCFlbmRPZkRpcmVjdG9yeUluZm8pIHtcblx0XHRcdHRocm93IG5ldyBFcnJvcihFUlJfRU9DRFJfTk9UX0ZPVU5EKTtcblx0XHR9XG5cdFx0Y29uc3QgZW5kT2ZEaXJlY3RvcnlWaWV3ID0gZ2V0RGF0YVZpZXckMShlbmRPZkRpcmVjdG9yeUluZm8pO1xuXHRcdGxldCBkaXJlY3RvcnlEYXRhTGVuZ3RoID0gZ2V0VWludDMyKGVuZE9mRGlyZWN0b3J5VmlldywgMTIpO1xuXHRcdGxldCBkaXJlY3RvcnlEYXRhT2Zmc2V0ID0gZ2V0VWludDMyKGVuZE9mRGlyZWN0b3J5VmlldywgMTYpO1xuXHRcdGxldCBmaWxlc0xlbmd0aCA9IGdldFVpbnQxNihlbmRPZkRpcmVjdG9yeVZpZXcsIDgpO1xuXHRcdGxldCBwcmVwZW5kZWREYXRhTGVuZ3RoID0gMDtcblx0XHRpZiAoZGlyZWN0b3J5RGF0YU9mZnNldCA9PSBNQVhfMzJfQklUUyB8fCBmaWxlc0xlbmd0aCA9PSBNQVhfMTZfQklUUykge1xuXHRcdFx0Y29uc3QgZW5kT2ZEaXJlY3RvcnlMb2NhdG9yQXJyYXkgPSBhd2FpdCByZWFkVWludDhBcnJheShyZWFkZXIsIGVuZE9mRGlyZWN0b3J5SW5mby5vZmZzZXQgLSBaSVA2NF9FTkRfT0ZfQ0VOVFJBTF9ESVJfTE9DQVRPUl9MRU5HVEgsIFpJUDY0X0VORF9PRl9DRU5UUkFMX0RJUl9MT0NBVE9SX0xFTkdUSCk7XG5cdFx0XHRjb25zdCBlbmRPZkRpcmVjdG9yeUxvY2F0b3JWaWV3ID0gZ2V0RGF0YVZpZXckMShlbmRPZkRpcmVjdG9yeUxvY2F0b3JBcnJheSk7XG5cdFx0XHRpZiAoZ2V0VWludDMyKGVuZE9mRGlyZWN0b3J5TG9jYXRvclZpZXcsIDApICE9IFpJUDY0X0VORF9PRl9DRU5UUkFMX0RJUl9MT0NBVE9SX1NJR05BVFVSRSkge1xuXHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoRVJSX0VPQ0RSX1pJUDY0X05PVF9GT1VORCk7XG5cdFx0XHR9XG5cdFx0XHRkaXJlY3RvcnlEYXRhT2Zmc2V0ID0gZ2V0QmlnVWludDY0KGVuZE9mRGlyZWN0b3J5TG9jYXRvclZpZXcsIDgpO1xuXHRcdFx0bGV0IGVuZE9mRGlyZWN0b3J5QXJyYXkgPSBhd2FpdCByZWFkVWludDhBcnJheShyZWFkZXIsIGRpcmVjdG9yeURhdGFPZmZzZXQsIFpJUDY0X0VORF9PRl9DRU5UUkFMX0RJUl9MRU5HVEgpO1xuXHRcdFx0bGV0IGVuZE9mRGlyZWN0b3J5VmlldyA9IGdldERhdGFWaWV3JDEoZW5kT2ZEaXJlY3RvcnlBcnJheSk7XG5cdFx0XHRjb25zdCBleHBlY3RlZERpcmVjdG9yeURhdGFPZmZzZXQgPSBlbmRPZkRpcmVjdG9yeUluZm8ub2Zmc2V0IC0gWklQNjRfRU5EX09GX0NFTlRSQUxfRElSX0xPQ0FUT1JfTEVOR1RIIC0gWklQNjRfRU5EX09GX0NFTlRSQUxfRElSX0xFTkdUSDtcblx0XHRcdGlmIChnZXRVaW50MzIoZW5kT2ZEaXJlY3RvcnlWaWV3LCAwKSAhPSBaSVA2NF9FTkRfT0ZfQ0VOVFJBTF9ESVJfU0lHTkFUVVJFICYmIGRpcmVjdG9yeURhdGFPZmZzZXQgIT0gZXhwZWN0ZWREaXJlY3RvcnlEYXRhT2Zmc2V0KSB7XG5cdFx0XHRcdGNvbnN0IG9yaWdpbmFsRGlyZWN0b3J5RGF0YU9mZnNldCA9IGRpcmVjdG9yeURhdGFPZmZzZXQ7XG5cdFx0XHRcdGRpcmVjdG9yeURhdGFPZmZzZXQgPSBleHBlY3RlZERpcmVjdG9yeURhdGFPZmZzZXQ7XG5cdFx0XHRcdHByZXBlbmRlZERhdGFMZW5ndGggPSBkaXJlY3RvcnlEYXRhT2Zmc2V0IC0gb3JpZ2luYWxEaXJlY3RvcnlEYXRhT2Zmc2V0O1xuXHRcdFx0XHRlbmRPZkRpcmVjdG9yeUFycmF5ID0gYXdhaXQgcmVhZFVpbnQ4QXJyYXkocmVhZGVyLCBkaXJlY3RvcnlEYXRhT2Zmc2V0LCBaSVA2NF9FTkRfT0ZfQ0VOVFJBTF9ESVJfTEVOR1RIKTtcblx0XHRcdFx0ZW5kT2ZEaXJlY3RvcnlWaWV3ID0gZ2V0RGF0YVZpZXckMShlbmRPZkRpcmVjdG9yeUFycmF5KTtcblx0XHRcdH1cblx0XHRcdGlmIChnZXRVaW50MzIoZW5kT2ZEaXJlY3RvcnlWaWV3LCAwKSAhPSBaSVA2NF9FTkRfT0ZfQ0VOVFJBTF9ESVJfU0lHTkFUVVJFKSB7XG5cdFx0XHRcdHRocm93IG5ldyBFcnJvcihFUlJfRU9DRFJfTE9DQVRPUl9aSVA2NF9OT1RfRk9VTkQpO1xuXHRcdFx0fVxuXHRcdFx0ZmlsZXNMZW5ndGggPSBnZXRCaWdVaW50NjQoZW5kT2ZEaXJlY3RvcnlWaWV3LCAyNCk7XG5cdFx0XHRkaXJlY3RvcnlEYXRhTGVuZ3RoID0gZ2V0VWludDMyKGVuZE9mRGlyZWN0b3J5TG9jYXRvclZpZXcsIDQpO1xuXHRcdFx0ZGlyZWN0b3J5RGF0YU9mZnNldCAtPSBnZXRCaWdVaW50NjQoZW5kT2ZEaXJlY3RvcnlWaWV3LCA0MCk7XG5cdFx0fVxuXHRcdGlmIChkaXJlY3RvcnlEYXRhT2Zmc2V0IDwgMCB8fCBkaXJlY3RvcnlEYXRhT2Zmc2V0ID49IHJlYWRlci5zaXplKSB7XG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoRVJSX0JBRF9GT1JNQVQpO1xuXHRcdH1cblx0XHRsZXQgb2Zmc2V0ID0gMDtcblx0XHRsZXQgZGlyZWN0b3J5QXJyYXkgPSBhd2FpdCByZWFkVWludDhBcnJheShyZWFkZXIsIGRpcmVjdG9yeURhdGFPZmZzZXQsIHJlYWRlci5zaXplIC0gZGlyZWN0b3J5RGF0YU9mZnNldCk7XG5cdFx0bGV0IGRpcmVjdG9yeVZpZXcgPSBnZXREYXRhVmlldyQxKGRpcmVjdG9yeUFycmF5KTtcblx0XHRjb25zdCBleHBlY3RlZERpcmVjdG9yeURhdGFPZmZzZXQgPSBlbmRPZkRpcmVjdG9yeUluZm8ub2Zmc2V0IC0gZGlyZWN0b3J5RGF0YUxlbmd0aDtcblx0XHRpZiAoZ2V0VWludDMyKGRpcmVjdG9yeVZpZXcsIG9mZnNldCkgIT0gQ0VOVFJBTF9GSUxFX0hFQURFUl9TSUdOQVRVUkUgJiYgZGlyZWN0b3J5RGF0YU9mZnNldCAhPSBleHBlY3RlZERpcmVjdG9yeURhdGFPZmZzZXQpIHtcblx0XHRcdGNvbnN0IG9yaWdpbmFsRGlyZWN0b3J5RGF0YU9mZnNldCA9IGRpcmVjdG9yeURhdGFPZmZzZXQ7XG5cdFx0XHRkaXJlY3RvcnlEYXRhT2Zmc2V0ID0gZXhwZWN0ZWREaXJlY3RvcnlEYXRhT2Zmc2V0O1xuXHRcdFx0cHJlcGVuZGVkRGF0YUxlbmd0aCA9IGRpcmVjdG9yeURhdGFPZmZzZXQgLSBvcmlnaW5hbERpcmVjdG9yeURhdGFPZmZzZXQ7XG5cdFx0XHRkaXJlY3RvcnlBcnJheSA9IGF3YWl0IHJlYWRVaW50OEFycmF5KHJlYWRlciwgZGlyZWN0b3J5RGF0YU9mZnNldCwgcmVhZGVyLnNpemUgLSBkaXJlY3RvcnlEYXRhT2Zmc2V0KTtcblx0XHRcdGRpcmVjdG9yeVZpZXcgPSBnZXREYXRhVmlldyQxKGRpcmVjdG9yeUFycmF5KTtcblx0XHR9XG5cdFx0aWYgKGRpcmVjdG9yeURhdGFPZmZzZXQgPCAwIHx8IGRpcmVjdG9yeURhdGFPZmZzZXQgPj0gcmVhZGVyLnNpemUpIHtcblx0XHRcdHRocm93IG5ldyBFcnJvcihFUlJfQkFEX0ZPUk1BVCk7XG5cdFx0fVxuXHRcdGNvbnN0IGVudHJpZXMgPSBbXTtcblx0XHRmb3IgKGxldCBpbmRleEZpbGUgPSAwOyBpbmRleEZpbGUgPCBmaWxlc0xlbmd0aDsgaW5kZXhGaWxlKyspIHtcblx0XHRcdGNvbnN0IGZpbGVFbnRyeSA9IG5ldyBaaXBFbnRyeShyZWFkZXIsIHppcFJlYWRlci5jb25maWcsIHppcFJlYWRlci5vcHRpb25zKTtcblx0XHRcdGlmIChnZXRVaW50MzIoZGlyZWN0b3J5Vmlldywgb2Zmc2V0KSAhPSBDRU5UUkFMX0ZJTEVfSEVBREVSX1NJR05BVFVSRSkge1xuXHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoRVJSX0NFTlRSQUxfRElSRUNUT1JZX05PVF9GT1VORCk7XG5cdFx0XHR9XG5cdFx0XHRyZWFkQ29tbW9uSGVhZGVyKGZpbGVFbnRyeSwgZGlyZWN0b3J5Vmlldywgb2Zmc2V0ICsgNik7XG5cdFx0XHRjb25zdCBsYW5ndWFnZUVuY29kaW5nRmxhZyA9IEJvb2xlYW4oZmlsZUVudHJ5LmJpdEZsYWcubGFuZ3VhZ2VFbmNvZGluZ0ZsYWcpO1xuXHRcdFx0Y29uc3QgZmlsZW5hbWVPZmZzZXQgPSBvZmZzZXQgKyA0Njtcblx0XHRcdGNvbnN0IGV4dHJhRmllbGRPZmZzZXQgPSBmaWxlbmFtZU9mZnNldCArIGZpbGVFbnRyeS5maWxlbmFtZUxlbmd0aDtcblx0XHRcdGNvbnN0IGNvbW1lbnRPZmZzZXQgPSBleHRyYUZpZWxkT2Zmc2V0ICsgZmlsZUVudHJ5LmV4dHJhRmllbGRMZW5ndGg7XG5cdFx0XHRjb25zdCB2ZXJzaW9uTWFkZUJ5ID0gZ2V0VWludDE2KGRpcmVjdG9yeVZpZXcsIG9mZnNldCArIDQpO1xuXHRcdFx0Y29uc3QgbXNEb3NDb21wYXRpYmxlID0gKHZlcnNpb25NYWRlQnkgJiAwKSA9PSAwO1xuXHRcdFx0T2JqZWN0LmFzc2lnbihmaWxlRW50cnksIHtcblx0XHRcdFx0dmVyc2lvbk1hZGVCeSxcblx0XHRcdFx0bXNEb3NDb21wYXRpYmxlLFxuXHRcdFx0XHRjb21wcmVzc2VkU2l6ZTogMCxcblx0XHRcdFx0dW5jb21wcmVzc2VkU2l6ZTogMCxcblx0XHRcdFx0Y29tbWVudExlbmd0aDogZ2V0VWludDE2KGRpcmVjdG9yeVZpZXcsIG9mZnNldCArIDMyKSxcblx0XHRcdFx0ZGlyZWN0b3J5OiBtc0Rvc0NvbXBhdGlibGUgJiYgKChnZXRVaW50OChkaXJlY3RvcnlWaWV3LCBvZmZzZXQgKyAzOCkgJiBGSUxFX0FUVFJfTVNET1NfRElSX01BU0spID09IEZJTEVfQVRUUl9NU0RPU19ESVJfTUFTSyksXG5cdFx0XHRcdG9mZnNldDogZ2V0VWludDMyKGRpcmVjdG9yeVZpZXcsIG9mZnNldCArIDQyKSArIHByZXBlbmRlZERhdGFMZW5ndGgsXG5cdFx0XHRcdGludGVybmFsRmlsZUF0dHJpYnV0ZTogZ2V0VWludDMyKGRpcmVjdG9yeVZpZXcsIG9mZnNldCArIDM0KSxcblx0XHRcdFx0ZXh0ZXJuYWxGaWxlQXR0cmlidXRlOiBnZXRVaW50MzIoZGlyZWN0b3J5Vmlldywgb2Zmc2V0ICsgMzgpLFxuXHRcdFx0XHRyYXdGaWxlbmFtZTogZGlyZWN0b3J5QXJyYXkuc3ViYXJyYXkoZmlsZW5hbWVPZmZzZXQsIGV4dHJhRmllbGRPZmZzZXQpLFxuXHRcdFx0XHRmaWxlbmFtZVVURjg6IGxhbmd1YWdlRW5jb2RpbmdGbGFnLFxuXHRcdFx0XHRjb21tZW50VVRGODogbGFuZ3VhZ2VFbmNvZGluZ0ZsYWcsXG5cdFx0XHRcdHJhd0V4dHJhRmllbGQ6IGRpcmVjdG9yeUFycmF5LnN1YmFycmF5KGV4dHJhRmllbGRPZmZzZXQsIGNvbW1lbnRPZmZzZXQpXG5cdFx0XHR9KTtcblx0XHRcdGNvbnN0IGVuZE9mZnNldCA9IGNvbW1lbnRPZmZzZXQgKyBmaWxlRW50cnkuY29tbWVudExlbmd0aDtcblx0XHRcdGZpbGVFbnRyeS5yYXdDb21tZW50ID0gZGlyZWN0b3J5QXJyYXkuc3ViYXJyYXkoY29tbWVudE9mZnNldCwgZW5kT2Zmc2V0KTtcblx0XHRcdGZpbGVFbnRyeS5maWxlbmFtZSA9IGRlY29kZVN0cmluZyhmaWxlRW50cnkucmF3RmlsZW5hbWUsIGZpbGVFbnRyeS5maWxlbmFtZVVURjggPyBDSEFSU0VUX1VURjggOiBnZXRPcHRpb25WYWx1ZSQxKHppcFJlYWRlciwgb3B0aW9ucywgXCJmaWxlbmFtZUVuY29kaW5nXCIpKTtcblx0XHRcdGZpbGVFbnRyeS5jb21tZW50ID0gZGVjb2RlU3RyaW5nKGZpbGVFbnRyeS5yYXdDb21tZW50LCBmaWxlRW50cnkuY29tbWVudFVURjggPyBDSEFSU0VUX1VURjggOiBnZXRPcHRpb25WYWx1ZSQxKHppcFJlYWRlciwgb3B0aW9ucywgXCJjb21tZW50RW5jb2RpbmdcIikpO1xuXHRcdFx0aWYgKCFmaWxlRW50cnkuZGlyZWN0b3J5ICYmIGZpbGVFbnRyeS5maWxlbmFtZS5lbmRzV2l0aChESVJFQ1RPUllfU0lHTkFUVVJFKSkge1xuXHRcdFx0XHRmaWxlRW50cnkuZGlyZWN0b3J5ID0gdHJ1ZTtcblx0XHRcdH1cblx0XHRcdHJlYWRDb21tb25Gb290ZXIoZmlsZUVudHJ5LCBmaWxlRW50cnksIGRpcmVjdG9yeVZpZXcsIG9mZnNldCArIDYpO1xuXHRcdFx0Y29uc3QgZW50cnkgPSBuZXcgRW50cnkoZmlsZUVudHJ5KTtcblx0XHRcdGVudHJ5LmdldERhdGEgPSAod3JpdGVyLCBvcHRpb25zKSA9PiBmaWxlRW50cnkuZ2V0RGF0YSh3cml0ZXIsIGVudHJ5LCBvcHRpb25zKTtcblx0XHRcdGVudHJpZXMucHVzaChlbnRyeSk7XG5cdFx0XHRvZmZzZXQgPSBlbmRPZmZzZXQ7XG5cdFx0XHRpZiAob3B0aW9ucy5vbnByb2dyZXNzKSB7XG5cdFx0XHRcdHRyeSB7XG5cdFx0XHRcdFx0b3B0aW9ucy5vbnByb2dyZXNzKGluZGV4RmlsZSArIDEsIGZpbGVzTGVuZ3RoLCBuZXcgRW50cnkoZmlsZUVudHJ5KSk7XG5cdFx0XHRcdH0gY2F0Y2ggKGVycm9yKSB7XG5cdFx0XHRcdFx0Ly8gaWdub3JlZFxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiBlbnRyaWVzO1xuXHR9XG5cblx0YXN5bmMgY2xvc2UoKSB7XG5cdH1cbn1cblxuY2xhc3MgWmlwRW50cnkge1xuXG5cdGNvbnN0cnVjdG9yKHJlYWRlciwgY29uZmlnLCBvcHRpb25zKSB7XG5cdFx0T2JqZWN0LmFzc2lnbih0aGlzLCB7XG5cdFx0XHRyZWFkZXIsXG5cdFx0XHRjb25maWcsXG5cdFx0XHRvcHRpb25zXG5cdFx0fSk7XG5cdH1cblxuXHRhc3luYyBnZXREYXRhKHdyaXRlciwgZmlsZUVudHJ5LCBvcHRpb25zID0ge30pIHtcblx0XHRjb25zdCB6aXBFbnRyeSA9IHRoaXM7XG5cdFx0Y29uc3Qge1xuXHRcdFx0cmVhZGVyLFxuXHRcdFx0b2Zmc2V0LFxuXHRcdFx0ZXh0cmFGaWVsZEFFUyxcblx0XHRcdGNvbXByZXNzaW9uTWV0aG9kLFxuXHRcdFx0Y29uZmlnLFxuXHRcdFx0Yml0RmxhZyxcblx0XHRcdHNpZ25hdHVyZSxcblx0XHRcdHJhd0xhc3RNb2REYXRlLFxuXHRcdFx0Y29tcHJlc3NlZFNpemVcblx0XHR9ID0gemlwRW50cnk7XG5cdFx0Y29uc3QgbG9jYWxEaXJlY3RvcnkgPSB6aXBFbnRyeS5sb2NhbERpcmVjdG9yeSA9IHt9O1xuXHRcdGlmICghcmVhZGVyLmluaXRpYWxpemVkKSB7XG5cdFx0XHRhd2FpdCByZWFkZXIuaW5pdCgpO1xuXHRcdH1cblx0XHRsZXQgZGF0YUFycmF5ID0gYXdhaXQgcmVhZFVpbnQ4QXJyYXkocmVhZGVyLCBvZmZzZXQsIDMwKTtcblx0XHRjb25zdCBkYXRhVmlldyA9IGdldERhdGFWaWV3JDEoZGF0YUFycmF5KTtcblx0XHRsZXQgcGFzc3dvcmQgPSBnZXRPcHRpb25WYWx1ZSQxKHppcEVudHJ5LCBvcHRpb25zLCBcInBhc3N3b3JkXCIpO1xuXHRcdHBhc3N3b3JkID0gcGFzc3dvcmQgJiYgcGFzc3dvcmQubGVuZ3RoICYmIHBhc3N3b3JkO1xuXHRcdGlmIChleHRyYUZpZWxkQUVTKSB7XG5cdFx0XHRpZiAoZXh0cmFGaWVsZEFFUy5vcmlnaW5hbENvbXByZXNzaW9uTWV0aG9kICE9IENPTVBSRVNTSU9OX01FVEhPRF9BRVMpIHtcblx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKEVSUl9VTlNVUFBPUlRFRF9DT01QUkVTU0lPTik7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdGlmIChjb21wcmVzc2lvbk1ldGhvZCAhPSBDT01QUkVTU0lPTl9NRVRIT0RfU1RPUkUgJiYgY29tcHJlc3Npb25NZXRob2QgIT0gQ09NUFJFU1NJT05fTUVUSE9EX0RFRkxBVEUpIHtcblx0XHRcdHRocm93IG5ldyBFcnJvcihFUlJfVU5TVVBQT1JURURfQ09NUFJFU1NJT04pO1xuXHRcdH1cblx0XHRpZiAoZ2V0VWludDMyKGRhdGFWaWV3LCAwKSAhPSBMT0NBTF9GSUxFX0hFQURFUl9TSUdOQVRVUkUpIHtcblx0XHRcdHRocm93IG5ldyBFcnJvcihFUlJfTE9DQUxfRklMRV9IRUFERVJfTk9UX0ZPVU5EKTtcblx0XHR9XG5cdFx0cmVhZENvbW1vbkhlYWRlcihsb2NhbERpcmVjdG9yeSwgZGF0YVZpZXcsIDQpO1xuXHRcdGRhdGFBcnJheSA9IGF3YWl0IHJlYWRVaW50OEFycmF5KHJlYWRlciwgb2Zmc2V0LCAzMCArIGxvY2FsRGlyZWN0b3J5LmZpbGVuYW1lTGVuZ3RoICsgbG9jYWxEaXJlY3RvcnkuZXh0cmFGaWVsZExlbmd0aCk7XG5cdFx0bG9jYWxEaXJlY3RvcnkucmF3RXh0cmFGaWVsZCA9IGRhdGFBcnJheS5zdWJhcnJheSgzMCArIGxvY2FsRGlyZWN0b3J5LmZpbGVuYW1lTGVuZ3RoKTtcblx0XHRyZWFkQ29tbW9uRm9vdGVyKHppcEVudHJ5LCBsb2NhbERpcmVjdG9yeSwgZGF0YVZpZXcsIDQpO1xuXHRcdGZpbGVFbnRyeS5sYXN0QWNjZXNzRGF0ZSA9IGxvY2FsRGlyZWN0b3J5Lmxhc3RBY2Nlc3NEYXRlO1xuXHRcdGZpbGVFbnRyeS5jcmVhdGlvbkRhdGUgPSBsb2NhbERpcmVjdG9yeS5jcmVhdGlvbkRhdGU7XG5cdFx0Y29uc3QgZW5jcnlwdGVkID0gemlwRW50cnkuZW5jcnlwdGVkICYmIGxvY2FsRGlyZWN0b3J5LmVuY3J5cHRlZDtcblx0XHRjb25zdCB6aXBDcnlwdG8gPSBlbmNyeXB0ZWQgJiYgIWV4dHJhRmllbGRBRVM7XG5cdFx0aWYgKGVuY3J5cHRlZCkge1xuXHRcdFx0aWYgKCF6aXBDcnlwdG8gJiYgZXh0cmFGaWVsZEFFUy5zdHJlbmd0aCA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdHRocm93IG5ldyBFcnJvcihFUlJfVU5TVVBQT1JURURfRU5DUllQVElPTik7XG5cdFx0XHR9IGVsc2UgaWYgKCFwYXNzd29yZCkge1xuXHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoRVJSX0VOQ1JZUFRFRCk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdGNvbnN0IGNvZGVjID0gYXdhaXQgY3JlYXRlQ29kZWMoY29uZmlnLkluZmxhdGUsIHtcblx0XHRcdGNvZGVjVHlwZTogQ09ERUNfSU5GTEFURSxcblx0XHRcdHBhc3N3b3JkLFxuXHRcdFx0emlwQ3J5cHRvLFxuXHRcdFx0ZW5jcnlwdGlvblN0cmVuZ3RoOiBleHRyYUZpZWxkQUVTICYmIGV4dHJhRmllbGRBRVMuc3RyZW5ndGgsXG5cdFx0XHRzaWduZWQ6IGdldE9wdGlvblZhbHVlJDEoemlwRW50cnksIG9wdGlvbnMsIFwiY2hlY2tTaWduYXR1cmVcIiksXG5cdFx0XHRwYXNzd29yZFZlcmlmaWNhdGlvbjogemlwQ3J5cHRvICYmIChiaXRGbGFnLmRhdGFEZXNjcmlwdG9yID8gKChyYXdMYXN0TW9kRGF0ZSA+Pj4gOCkgJiAweEZGKSA6ICgoc2lnbmF0dXJlID4+PiAyNCkgJiAweEZGKSksXG5cdFx0XHRzaWduYXR1cmUsXG5cdFx0XHRjb21wcmVzc2VkOiBjb21wcmVzc2lvbk1ldGhvZCAhPSAwLFxuXHRcdFx0ZW5jcnlwdGVkLFxuXHRcdFx0dXNlV2ViV29ya2VyczogZ2V0T3B0aW9uVmFsdWUkMSh6aXBFbnRyeSwgb3B0aW9ucywgXCJ1c2VXZWJXb3JrZXJzXCIpXG5cdFx0fSwgY29uZmlnKTtcblx0XHRpZiAoIXdyaXRlci5pbml0aWFsaXplZCkge1xuXHRcdFx0YXdhaXQgd3JpdGVyLmluaXQoKTtcblx0XHR9XG5cdFx0Y29uc3Qgc2lnbmFsID0gZ2V0T3B0aW9uVmFsdWUkMSh6aXBFbnRyeSwgb3B0aW9ucywgXCJzaWduYWxcIik7XG5cdFx0Y29uc3QgZGF0YU9mZnNldCA9IG9mZnNldCArIDMwICsgbG9jYWxEaXJlY3RvcnkuZmlsZW5hbWVMZW5ndGggKyBsb2NhbERpcmVjdG9yeS5leHRyYUZpZWxkTGVuZ3RoO1xuXHRcdGF3YWl0IHByb2Nlc3NEYXRhKGNvZGVjLCByZWFkZXIsIHdyaXRlciwgZGF0YU9mZnNldCwgY29tcHJlc3NlZFNpemUsIGNvbmZpZywgeyBvbnByb2dyZXNzOiBvcHRpb25zLm9ucHJvZ3Jlc3MsIHNpZ25hbCB9KTtcblx0XHRyZXR1cm4gd3JpdGVyLmdldERhdGEoKTtcblx0fVxufVxuXG5mdW5jdGlvbiByZWFkQ29tbW9uSGVhZGVyKGRpcmVjdG9yeSwgZGF0YVZpZXcsIG9mZnNldCkge1xuXHRjb25zdCByYXdCaXRGbGFnID0gZGlyZWN0b3J5LnJhd0JpdEZsYWcgPSBnZXRVaW50MTYoZGF0YVZpZXcsIG9mZnNldCArIDIpO1xuXHRjb25zdCBlbmNyeXB0ZWQgPSAocmF3Qml0RmxhZyAmIEJJVEZMQUdfRU5DUllQVEVEKSA9PSBCSVRGTEFHX0VOQ1JZUFRFRDtcblx0Y29uc3QgcmF3TGFzdE1vZERhdGUgPSBnZXRVaW50MzIoZGF0YVZpZXcsIG9mZnNldCArIDYpO1xuXHRPYmplY3QuYXNzaWduKGRpcmVjdG9yeSwge1xuXHRcdGVuY3J5cHRlZCxcblx0XHR2ZXJzaW9uOiBnZXRVaW50MTYoZGF0YVZpZXcsIG9mZnNldCksXG5cdFx0Yml0RmxhZzoge1xuXHRcdFx0bGV2ZWw6IChyYXdCaXRGbGFnICYgQklURkxBR19MRVZFTCkgPj4gMSxcblx0XHRcdGRhdGFEZXNjcmlwdG9yOiAocmF3Qml0RmxhZyAmIEJJVEZMQUdfREFUQV9ERVNDUklQVE9SKSA9PSBCSVRGTEFHX0RBVEFfREVTQ1JJUFRPUixcblx0XHRcdGxhbmd1YWdlRW5jb2RpbmdGbGFnOiAocmF3Qml0RmxhZyAmIEJJVEZMQUdfTEFOR19FTkNPRElOR19GTEFHKSA9PSBCSVRGTEFHX0xBTkdfRU5DT0RJTkdfRkxBR1xuXHRcdH0sXG5cdFx0cmF3TGFzdE1vZERhdGUsXG5cdFx0bGFzdE1vZERhdGU6IGdldERhdGUocmF3TGFzdE1vZERhdGUpLFxuXHRcdGZpbGVuYW1lTGVuZ3RoOiBnZXRVaW50MTYoZGF0YVZpZXcsIG9mZnNldCArIDIyKSxcblx0XHRleHRyYUZpZWxkTGVuZ3RoOiBnZXRVaW50MTYoZGF0YVZpZXcsIG9mZnNldCArIDI0KVxuXHR9KTtcbn1cblxuZnVuY3Rpb24gcmVhZENvbW1vbkZvb3RlcihmaWxlRW50cnksIGRpcmVjdG9yeSwgZGF0YVZpZXcsIG9mZnNldCkge1xuXHRjb25zdCByYXdFeHRyYUZpZWxkID0gZGlyZWN0b3J5LnJhd0V4dHJhRmllbGQ7XG5cdGNvbnN0IGV4dHJhRmllbGQgPSBkaXJlY3RvcnkuZXh0cmFGaWVsZCA9IG5ldyBNYXAoKTtcblx0Y29uc3QgcmF3RXh0cmFGaWVsZFZpZXcgPSBnZXREYXRhVmlldyQxKG5ldyBVaW50OEFycmF5KHJhd0V4dHJhRmllbGQpKTtcblx0bGV0IG9mZnNldEV4dHJhRmllbGQgPSAwO1xuXHR0cnkge1xuXHRcdHdoaWxlIChvZmZzZXRFeHRyYUZpZWxkIDwgcmF3RXh0cmFGaWVsZC5sZW5ndGgpIHtcblx0XHRcdGNvbnN0IHR5cGUgPSBnZXRVaW50MTYocmF3RXh0cmFGaWVsZFZpZXcsIG9mZnNldEV4dHJhRmllbGQpO1xuXHRcdFx0Y29uc3Qgc2l6ZSA9IGdldFVpbnQxNihyYXdFeHRyYUZpZWxkVmlldywgb2Zmc2V0RXh0cmFGaWVsZCArIDIpO1xuXHRcdFx0ZXh0cmFGaWVsZC5zZXQodHlwZSwge1xuXHRcdFx0XHR0eXBlLFxuXHRcdFx0XHRkYXRhOiByYXdFeHRyYUZpZWxkLnNsaWNlKG9mZnNldEV4dHJhRmllbGQgKyA0LCBvZmZzZXRFeHRyYUZpZWxkICsgNCArIHNpemUpXG5cdFx0XHR9KTtcblx0XHRcdG9mZnNldEV4dHJhRmllbGQgKz0gNCArIHNpemU7XG5cdFx0fVxuXHR9IGNhdGNoIChlcnJvcikge1xuXHRcdC8vIGlnbm9yZWRcblx0fVxuXHRjb25zdCBjb21wcmVzc2lvbk1ldGhvZCA9IGdldFVpbnQxNihkYXRhVmlldywgb2Zmc2V0ICsgNCk7XG5cdGRpcmVjdG9yeS5zaWduYXR1cmUgPSBnZXRVaW50MzIoZGF0YVZpZXcsIG9mZnNldCArIDEwKTtcblx0ZGlyZWN0b3J5LnVuY29tcHJlc3NlZFNpemUgPSBnZXRVaW50MzIoZGF0YVZpZXcsIG9mZnNldCArIDE4KTtcblx0ZGlyZWN0b3J5LmNvbXByZXNzZWRTaXplID0gZ2V0VWludDMyKGRhdGFWaWV3LCBvZmZzZXQgKyAxNCk7XG5cdGNvbnN0IGV4dHJhRmllbGRaaXA2NCA9IGV4dHJhRmllbGQuZ2V0KEVYVFJBRklFTERfVFlQRV9aSVA2NCk7XG5cdGlmIChleHRyYUZpZWxkWmlwNjQpIHtcblx0XHRyZWFkRXh0cmFGaWVsZFppcDY0KGV4dHJhRmllbGRaaXA2NCwgZGlyZWN0b3J5KTtcblx0XHRkaXJlY3RvcnkuZXh0cmFGaWVsZFppcDY0ID0gZXh0cmFGaWVsZFppcDY0O1xuXHR9XG5cdGNvbnN0IGV4dHJhRmllbGRVbmljb2RlUGF0aCA9IGV4dHJhRmllbGQuZ2V0KEVYVFJBRklFTERfVFlQRV9VTklDT0RFX1BBVEgpO1xuXHRpZiAoZXh0cmFGaWVsZFVuaWNvZGVQYXRoKSB7XG5cdFx0cmVhZEV4dHJhRmllbGRVbmljb2RlKGV4dHJhRmllbGRVbmljb2RlUGF0aCwgXCJmaWxlbmFtZVwiLCBcInJhd0ZpbGVuYW1lXCIsIGRpcmVjdG9yeSwgZmlsZUVudHJ5KTtcblx0XHRkaXJlY3RvcnkuZXh0cmFGaWVsZFVuaWNvZGVQYXRoID0gZXh0cmFGaWVsZFVuaWNvZGVQYXRoO1xuXHR9XG5cdGNvbnN0IGV4dHJhRmllbGRVbmljb2RlQ29tbWVudCA9IGV4dHJhRmllbGQuZ2V0KEVYVFJBRklFTERfVFlQRV9VTklDT0RFX0NPTU1FTlQpO1xuXHRpZiAoZXh0cmFGaWVsZFVuaWNvZGVDb21tZW50KSB7XG5cdFx0cmVhZEV4dHJhRmllbGRVbmljb2RlKGV4dHJhRmllbGRVbmljb2RlQ29tbWVudCwgXCJjb21tZW50XCIsIFwicmF3Q29tbWVudFwiLCBkaXJlY3RvcnksIGZpbGVFbnRyeSk7XG5cdFx0ZGlyZWN0b3J5LmV4dHJhRmllbGRVbmljb2RlQ29tbWVudCA9IGV4dHJhRmllbGRVbmljb2RlQ29tbWVudDtcblx0fVxuXHRjb25zdCBleHRyYUZpZWxkQUVTID0gZXh0cmFGaWVsZC5nZXQoRVhUUkFGSUVMRF9UWVBFX0FFUyk7XG5cdGlmIChleHRyYUZpZWxkQUVTKSB7XG5cdFx0cmVhZEV4dHJhRmllbGRBRVMoZXh0cmFGaWVsZEFFUywgZGlyZWN0b3J5LCBjb21wcmVzc2lvbk1ldGhvZCk7XG5cdFx0ZGlyZWN0b3J5LmV4dHJhRmllbGRBRVMgPSBleHRyYUZpZWxkQUVTO1xuXHR9IGVsc2Uge1xuXHRcdGRpcmVjdG9yeS5jb21wcmVzc2lvbk1ldGhvZCA9IGNvbXByZXNzaW9uTWV0aG9kO1xuXHR9XG5cdGNvbnN0IGV4dHJhRmllbGROVEZTID0gZXh0cmFGaWVsZC5nZXQoRVhUUkFGSUVMRF9UWVBFX05URlMpO1xuXHRpZiAoZXh0cmFGaWVsZE5URlMpIHtcblx0XHRyZWFkRXh0cmFGaWVsZE5URlMoZXh0cmFGaWVsZE5URlMsIGRpcmVjdG9yeSk7XG5cdFx0ZGlyZWN0b3J5LmV4dHJhRmllbGROVEZTID0gZXh0cmFGaWVsZE5URlM7XG5cdH1cblx0Y29uc3QgZXh0cmFGaWVsZEV4dGVuZGVkVGltZXN0YW1wID0gZXh0cmFGaWVsZC5nZXQoRVhUUkFGSUVMRF9UWVBFX0VYVEVOREVEX1RJTUVTVEFNUCk7XG5cdGlmIChleHRyYUZpZWxkRXh0ZW5kZWRUaW1lc3RhbXApIHtcblx0XHRyZWFkRXh0cmFGaWVsZEV4dGVuZGVkVGltZXN0YW1wKGV4dHJhRmllbGRFeHRlbmRlZFRpbWVzdGFtcCwgZGlyZWN0b3J5KTtcblx0XHRkaXJlY3RvcnkuZXh0cmFGaWVsZEV4dGVuZGVkVGltZXN0YW1wID0gZXh0cmFGaWVsZEV4dGVuZGVkVGltZXN0YW1wO1xuXHR9XG59XG5cbmZ1bmN0aW9uIHJlYWRFeHRyYUZpZWxkWmlwNjQoZXh0cmFGaWVsZFppcDY0LCBkaXJlY3RvcnkpIHtcblx0ZGlyZWN0b3J5LnppcDY0ID0gdHJ1ZTtcblx0Y29uc3QgZXh0cmFGaWVsZFZpZXcgPSBnZXREYXRhVmlldyQxKGV4dHJhRmllbGRaaXA2NC5kYXRhKTtcblx0ZXh0cmFGaWVsZFppcDY0LnZhbHVlcyA9IFtdO1xuXHRmb3IgKGxldCBpbmRleFZhbHVlID0gMDsgaW5kZXhWYWx1ZSA8IE1hdGguZmxvb3IoZXh0cmFGaWVsZFppcDY0LmRhdGEubGVuZ3RoIC8gOCk7IGluZGV4VmFsdWUrKykge1xuXHRcdGV4dHJhRmllbGRaaXA2NC52YWx1ZXMucHVzaChnZXRCaWdVaW50NjQoZXh0cmFGaWVsZFZpZXcsIDAgKyBpbmRleFZhbHVlICogOCkpO1xuXHR9XG5cdGNvbnN0IG1pc3NpbmdQcm9wZXJ0aWVzID0gWklQNjRfUFJPUEVSVElFUy5maWx0ZXIocHJvcGVydHlOYW1lID0+IGRpcmVjdG9yeVtwcm9wZXJ0eU5hbWVdID09IE1BWF8zMl9CSVRTKTtcblx0Zm9yIChsZXQgaW5kZXhNaXNzaW5nUHJvcGVydHkgPSAwOyBpbmRleE1pc3NpbmdQcm9wZXJ0eSA8IG1pc3NpbmdQcm9wZXJ0aWVzLmxlbmd0aDsgaW5kZXhNaXNzaW5nUHJvcGVydHkrKykge1xuXHRcdGV4dHJhRmllbGRaaXA2NFttaXNzaW5nUHJvcGVydGllc1tpbmRleE1pc3NpbmdQcm9wZXJ0eV1dID0gZXh0cmFGaWVsZFppcDY0LnZhbHVlc1tpbmRleE1pc3NpbmdQcm9wZXJ0eV07XG5cdH1cblx0WklQNjRfUFJPUEVSVElFUy5mb3JFYWNoKHByb3BlcnR5TmFtZSA9PiB7XG5cdFx0aWYgKGRpcmVjdG9yeVtwcm9wZXJ0eU5hbWVdID09IE1BWF8zMl9CSVRTKSB7XG5cdFx0XHRpZiAoZXh0cmFGaWVsZFppcDY0W3Byb3BlcnR5TmFtZV0gIT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHRkaXJlY3RvcnlbcHJvcGVydHlOYW1lXSA9IGV4dHJhRmllbGRaaXA2NFtwcm9wZXJ0eU5hbWVdO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKEVSUl9FWFRSQUZJRUxEX1pJUDY0X05PVF9GT1VORCk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9KTtcbn1cblxuZnVuY3Rpb24gcmVhZEV4dHJhRmllbGRVbmljb2RlKGV4dHJhRmllbGRVbmljb2RlLCBwcm9wZXJ0eU5hbWUsIHJhd1Byb3BlcnR5TmFtZSwgZGlyZWN0b3J5LCBmaWxlRW50cnkpIHtcblx0Y29uc3QgZXh0cmFGaWVsZFZpZXcgPSBnZXREYXRhVmlldyQxKGV4dHJhRmllbGRVbmljb2RlLmRhdGEpO1xuXHRleHRyYUZpZWxkVW5pY29kZS52ZXJzaW9uID0gZ2V0VWludDgoZXh0cmFGaWVsZFZpZXcsIDApO1xuXHRleHRyYUZpZWxkVW5pY29kZS5zaWduYXR1cmUgPSBnZXRVaW50MzIoZXh0cmFGaWVsZFZpZXcsIDEpO1xuXHRjb25zdCBjcmMzMiA9IG5ldyBDcmMzMigpO1xuXHRjcmMzMi5hcHBlbmQoZmlsZUVudHJ5W3Jhd1Byb3BlcnR5TmFtZV0pO1xuXHRjb25zdCBkYXRhVmlld1NpZ25hdHVyZSA9IGdldERhdGFWaWV3JDEobmV3IFVpbnQ4QXJyYXkoNCkpO1xuXHRkYXRhVmlld1NpZ25hdHVyZS5zZXRVaW50MzIoMCwgY3JjMzIuZ2V0KCksIHRydWUpO1xuXHRleHRyYUZpZWxkVW5pY29kZVtwcm9wZXJ0eU5hbWVdID0gKG5ldyBUZXh0RGVjb2RlcigpKS5kZWNvZGUoZXh0cmFGaWVsZFVuaWNvZGUuZGF0YS5zdWJhcnJheSg1KSk7XG5cdGV4dHJhRmllbGRVbmljb2RlLnZhbGlkID0gIWZpbGVFbnRyeS5iaXRGbGFnLmxhbmd1YWdlRW5jb2RpbmdGbGFnICYmIGV4dHJhRmllbGRVbmljb2RlLnNpZ25hdHVyZSA9PSBnZXRVaW50MzIoZGF0YVZpZXdTaWduYXR1cmUsIDApO1xuXHRpZiAoZXh0cmFGaWVsZFVuaWNvZGUudmFsaWQpIHtcblx0XHRkaXJlY3RvcnlbcHJvcGVydHlOYW1lXSA9IGV4dHJhRmllbGRVbmljb2RlW3Byb3BlcnR5TmFtZV07XG5cdFx0ZGlyZWN0b3J5W3Byb3BlcnR5TmFtZSArIFwiVVRGOFwiXSA9IHRydWU7XG5cdH1cbn1cblxuZnVuY3Rpb24gcmVhZEV4dHJhRmllbGRBRVMoZXh0cmFGaWVsZEFFUywgZGlyZWN0b3J5LCBjb21wcmVzc2lvbk1ldGhvZCkge1xuXHRjb25zdCBleHRyYUZpZWxkVmlldyA9IGdldERhdGFWaWV3JDEoZXh0cmFGaWVsZEFFUy5kYXRhKTtcblx0ZXh0cmFGaWVsZEFFUy52ZW5kb3JWZXJzaW9uID0gZ2V0VWludDgoZXh0cmFGaWVsZFZpZXcsIDApO1xuXHRleHRyYUZpZWxkQUVTLnZlbmRvcklkID0gZ2V0VWludDgoZXh0cmFGaWVsZFZpZXcsIDIpO1xuXHRjb25zdCBzdHJlbmd0aCA9IGdldFVpbnQ4KGV4dHJhRmllbGRWaWV3LCA0KTtcblx0ZXh0cmFGaWVsZEFFUy5zdHJlbmd0aCA9IHN0cmVuZ3RoO1xuXHRleHRyYUZpZWxkQUVTLm9yaWdpbmFsQ29tcHJlc3Npb25NZXRob2QgPSBjb21wcmVzc2lvbk1ldGhvZDtcblx0ZGlyZWN0b3J5LmNvbXByZXNzaW9uTWV0aG9kID0gZXh0cmFGaWVsZEFFUy5jb21wcmVzc2lvbk1ldGhvZCA9IGdldFVpbnQxNihleHRyYUZpZWxkVmlldywgNSk7XG59XG5cbmZ1bmN0aW9uIHJlYWRFeHRyYUZpZWxkTlRGUyhleHRyYUZpZWxkTlRGUywgZGlyZWN0b3J5KSB7XG5cdGNvbnN0IGV4dHJhRmllbGRWaWV3ID0gZ2V0RGF0YVZpZXckMShleHRyYUZpZWxkTlRGUy5kYXRhKTtcblx0bGV0IG9mZnNldEV4dHJhRmllbGQgPSA0O1xuXHRsZXQgdGFnMURhdGE7XG5cdHRyeSB7XG5cdFx0d2hpbGUgKG9mZnNldEV4dHJhRmllbGQgPCBleHRyYUZpZWxkTlRGUy5kYXRhLmxlbmd0aCAmJiAhdGFnMURhdGEpIHtcblx0XHRcdGNvbnN0IHRhZ1ZhbHVlID0gZ2V0VWludDE2KGV4dHJhRmllbGRWaWV3LCBvZmZzZXRFeHRyYUZpZWxkKTtcblx0XHRcdGNvbnN0IGF0dHJpYnV0ZVNpemUgPSBnZXRVaW50MTYoZXh0cmFGaWVsZFZpZXcsIG9mZnNldEV4dHJhRmllbGQgKyAyKTtcblx0XHRcdGlmICh0YWdWYWx1ZSA9PSBFWFRSQUZJRUxEX1RZUEVfTlRGU19UQUcxKSB7XG5cdFx0XHRcdHRhZzFEYXRhID0gZXh0cmFGaWVsZE5URlMuZGF0YS5zbGljZShvZmZzZXRFeHRyYUZpZWxkICsgNCwgb2Zmc2V0RXh0cmFGaWVsZCArIDQgKyBhdHRyaWJ1dGVTaXplKTtcblx0XHRcdH1cblx0XHRcdG9mZnNldEV4dHJhRmllbGQgKz0gNCArIGF0dHJpYnV0ZVNpemU7XG5cdFx0fVxuXHR9IGNhdGNoIChlcnJvcikge1xuXHRcdC8vIGlnbm9yZWRcblx0fVxuXHR0cnkge1xuXHRcdGlmICh0YWcxRGF0YSAmJiB0YWcxRGF0YS5sZW5ndGggPT0gMjQpIHtcblx0XHRcdGNvbnN0IHRhZzFWaWV3ID0gZ2V0RGF0YVZpZXckMSh0YWcxRGF0YSk7XG5cdFx0XHRjb25zdCByYXdMYXN0TW9kRGF0ZSA9IHRhZzFWaWV3LmdldEJpZ1VpbnQ2NCgwLCB0cnVlKTtcblx0XHRcdGNvbnN0IHJhd0xhc3RBY2Nlc3NEYXRlID0gdGFnMVZpZXcuZ2V0QmlnVWludDY0KDgsIHRydWUpO1xuXHRcdFx0Y29uc3QgcmF3Q3JlYXRpb25EYXRlID0gdGFnMVZpZXcuZ2V0QmlnVWludDY0KDE2LCB0cnVlKTtcblx0XHRcdE9iamVjdC5hc3NpZ24oZXh0cmFGaWVsZE5URlMsIHtcblx0XHRcdFx0cmF3TGFzdE1vZERhdGUsXG5cdFx0XHRcdHJhd0xhc3RBY2Nlc3NEYXRlLFxuXHRcdFx0XHRyYXdDcmVhdGlvbkRhdGVcblx0XHRcdH0pO1xuXHRcdFx0Y29uc3QgbGFzdE1vZERhdGUgPSBnZXREYXRlTlRGUyhyYXdMYXN0TW9kRGF0ZSk7XG5cdFx0XHRjb25zdCBsYXN0QWNjZXNzRGF0ZSA9IGdldERhdGVOVEZTKHJhd0xhc3RBY2Nlc3NEYXRlKTtcblx0XHRcdGNvbnN0IGNyZWF0aW9uRGF0ZSA9IGdldERhdGVOVEZTKHJhd0NyZWF0aW9uRGF0ZSk7XG5cdFx0XHRjb25zdCBleHRyYUZpZWxkRGF0YSA9IHsgbGFzdE1vZERhdGUsIGxhc3RBY2Nlc3NEYXRlLCBjcmVhdGlvbkRhdGUgfTtcblx0XHRcdE9iamVjdC5hc3NpZ24oZXh0cmFGaWVsZE5URlMsIGV4dHJhRmllbGREYXRhKTtcblx0XHRcdE9iamVjdC5hc3NpZ24oZGlyZWN0b3J5LCBleHRyYUZpZWxkRGF0YSk7XG5cdFx0fVxuXHR9IGNhdGNoIChlcnJvcikge1xuXHRcdC8vIGlnbm9yZWRcblx0fVxufVxuXG5mdW5jdGlvbiByZWFkRXh0cmFGaWVsZEV4dGVuZGVkVGltZXN0YW1wKGV4dHJhRmllbGRFeHRlbmRlZFRpbWVzdGFtcCwgZGlyZWN0b3J5KSB7XG5cdGNvbnN0IGV4dHJhRmllbGRWaWV3ID0gZ2V0RGF0YVZpZXckMShleHRyYUZpZWxkRXh0ZW5kZWRUaW1lc3RhbXAuZGF0YSk7XG5cdGNvbnN0IGZsYWdzID0gZ2V0VWludDgoZXh0cmFGaWVsZFZpZXcsIDApO1xuXHRjb25zdCB0aW1lUHJvcGVydGllcyA9IFtdO1xuXHRjb25zdCB0aW1lUmF3UHJvcGVydGllcyA9IFtdO1xuXHRpZiAoKGZsYWdzICYgMHgxKSA9PSAweDEpIHtcblx0XHR0aW1lUHJvcGVydGllcy5wdXNoKFwibGFzdE1vZERhdGVcIik7XG5cdFx0dGltZVJhd1Byb3BlcnRpZXMucHVzaChcInJhd0xhc3RNb2REYXRlXCIpO1xuXHR9XG5cdGlmICgoZmxhZ3MgJiAweDIpID09IDB4Mikge1xuXHRcdHRpbWVQcm9wZXJ0aWVzLnB1c2goXCJsYXN0QWNjZXNzRGF0ZVwiKTtcblx0XHR0aW1lUmF3UHJvcGVydGllcy5wdXNoKFwicmF3TGFzdEFjY2Vzc0RhdGVcIik7XG5cdH1cblx0aWYgKChmbGFncyAmIDB4NCkgPT0gMHg0KSB7XG5cdFx0dGltZVByb3BlcnRpZXMucHVzaChcImNyZWF0aW9uRGF0ZVwiKTtcblx0XHR0aW1lUmF3UHJvcGVydGllcy5wdXNoKFwicmF3Q3JlYXRpb25EYXRlXCIpO1xuXHR9XG5cdGxldCBvZmZzZXQgPSAxO1xuXHR0aW1lUHJvcGVydGllcy5mb3JFYWNoKChwcm9wZXJ0eU5hbWUsIGluZGV4UHJvcGVydHkpID0+IHtcblx0XHRpZiAoZXh0cmFGaWVsZEV4dGVuZGVkVGltZXN0YW1wLmRhdGEubGVuZ3RoID49IG9mZnNldCArIDQpIHtcblx0XHRcdGNvbnN0IHRpbWUgPSBnZXRVaW50MzIoZXh0cmFGaWVsZFZpZXcsIG9mZnNldCk7XG5cdFx0XHRkaXJlY3RvcnlbcHJvcGVydHlOYW1lXSA9IGV4dHJhRmllbGRFeHRlbmRlZFRpbWVzdGFtcFtwcm9wZXJ0eU5hbWVdID0gbmV3IERhdGUodGltZSAqIDEwMDApO1xuXHRcdFx0Y29uc3QgcmF3UHJvcGVydHlOYW1lID0gdGltZVJhd1Byb3BlcnRpZXNbaW5kZXhQcm9wZXJ0eV07XG5cdFx0XHRleHRyYUZpZWxkRXh0ZW5kZWRUaW1lc3RhbXBbcmF3UHJvcGVydHlOYW1lXSA9IHRpbWU7XG5cdFx0fVxuXHRcdG9mZnNldCArPSA0O1xuXHR9KTtcbn1cblxuYXN5bmMgZnVuY3Rpb24gc2Vla1NpZ25hdHVyZShyZWFkZXIsIHNpZ25hdHVyZSwgc3RhcnRPZmZzZXQsIG1pbmltdW1CeXRlcywgbWF4aW11bUxlbmd0aCkge1xuXHRjb25zdCBzaWduYXR1cmVBcnJheSA9IG5ldyBVaW50OEFycmF5KDQpO1xuXHRjb25zdCBzaWduYXR1cmVWaWV3ID0gZ2V0RGF0YVZpZXckMShzaWduYXR1cmVBcnJheSk7XG5cdHNldFVpbnQzMiQxKHNpZ25hdHVyZVZpZXcsIDAsIHNpZ25hdHVyZSk7XG5cdGNvbnN0IG1heGltdW1CeXRlcyA9IG1pbmltdW1CeXRlcyArIG1heGltdW1MZW5ndGg7XG5cdHJldHVybiAoYXdhaXQgc2VlayhtaW5pbXVtQnl0ZXMpKSB8fCBhd2FpdCBzZWVrKE1hdGgubWluKG1heGltdW1CeXRlcywgc3RhcnRPZmZzZXQpKTtcblxuXHRhc3luYyBmdW5jdGlvbiBzZWVrKGxlbmd0aCkge1xuXHRcdGNvbnN0IG9mZnNldCA9IHN0YXJ0T2Zmc2V0IC0gbGVuZ3RoO1xuXHRcdGNvbnN0IGJ5dGVzID0gYXdhaXQgcmVhZFVpbnQ4QXJyYXkocmVhZGVyLCBvZmZzZXQsIGxlbmd0aCk7XG5cdFx0Zm9yIChsZXQgaW5kZXhCeXRlID0gYnl0ZXMubGVuZ3RoIC0gbWluaW11bUJ5dGVzOyBpbmRleEJ5dGUgPj0gMDsgaW5kZXhCeXRlLS0pIHtcblx0XHRcdGlmIChieXRlc1tpbmRleEJ5dGVdID09IHNpZ25hdHVyZUFycmF5WzBdICYmIGJ5dGVzW2luZGV4Qnl0ZSArIDFdID09IHNpZ25hdHVyZUFycmF5WzFdICYmXG5cdFx0XHRcdGJ5dGVzW2luZGV4Qnl0ZSArIDJdID09IHNpZ25hdHVyZUFycmF5WzJdICYmIGJ5dGVzW2luZGV4Qnl0ZSArIDNdID09IHNpZ25hdHVyZUFycmF5WzNdKSB7XG5cdFx0XHRcdHJldHVybiB7XG5cdFx0XHRcdFx0b2Zmc2V0OiBvZmZzZXQgKyBpbmRleEJ5dGUsXG5cdFx0XHRcdFx0YnVmZmVyOiBieXRlcy5zbGljZShpbmRleEJ5dGUsIGluZGV4Qnl0ZSArIG1pbmltdW1CeXRlcykuYnVmZmVyXG5cdFx0XHRcdH07XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG59XG5cbmZ1bmN0aW9uIGdldE9wdGlvblZhbHVlJDEoemlwUmVhZGVyLCBvcHRpb25zLCBuYW1lKSB7XG5cdHJldHVybiBvcHRpb25zW25hbWVdID09PSB1bmRlZmluZWQgPyB6aXBSZWFkZXIub3B0aW9uc1tuYW1lXSA6IG9wdGlvbnNbbmFtZV07XG59XG5cbmZ1bmN0aW9uIGRlY29kZVN0cmluZyh2YWx1ZSwgZW5jb2RpbmcpIHtcblx0aWYgKCFlbmNvZGluZyB8fCBlbmNvZGluZy50cmltKCkudG9Mb3dlckNhc2UoKSA9PSBcImNwNDM3XCIpIHtcblx0XHRyZXR1cm4gZGVjb2RlQ1A0MzcodmFsdWUpO1xuXHR9IGVsc2Uge1xuXHRcdHJldHVybiAobmV3IFRleHREZWNvZGVyKGVuY29kaW5nKSkuZGVjb2RlKHZhbHVlKTtcblx0fVxufVxuXG5mdW5jdGlvbiBnZXREYXRlKHRpbWVSYXcpIHtcblx0Y29uc3QgZGF0ZSA9ICh0aW1lUmF3ICYgMHhmZmZmMDAwMCkgPj4gMTYsIHRpbWUgPSB0aW1lUmF3ICYgMHgwMDAwZmZmZjtcblx0dHJ5IHtcblx0XHRyZXR1cm4gbmV3IERhdGUoMTk4MCArICgoZGF0ZSAmIDB4RkUwMCkgPj4gOSksICgoZGF0ZSAmIDB4MDFFMCkgPj4gNSkgLSAxLCBkYXRlICYgMHgwMDFGLCAodGltZSAmIDB4RjgwMCkgPj4gMTEsICh0aW1lICYgMHgwN0UwKSA+PiA1LCAodGltZSAmIDB4MDAxRikgKiAyLCAwKTtcblx0fSBjYXRjaCAoZXJyb3IpIHtcblx0XHQvLyBpZ25vcmVkXG5cdH1cbn1cblxuZnVuY3Rpb24gZ2V0RGF0ZU5URlModGltZVJhdykge1xuXHRyZXR1cm4gbmV3IERhdGUoKE51bWJlcigodGltZVJhdyAvIEJpZ0ludCgxMDAwMCkpIC0gQmlnSW50KDExNjQ0NDczNjAwMDAwKSkpKTtcbn1cblxuZnVuY3Rpb24gZ2V0VWludDgodmlldywgb2Zmc2V0KSB7XG5cdHJldHVybiB2aWV3LmdldFVpbnQ4KG9mZnNldCk7XG59XG5cbmZ1bmN0aW9uIGdldFVpbnQxNih2aWV3LCBvZmZzZXQpIHtcblx0cmV0dXJuIHZpZXcuZ2V0VWludDE2KG9mZnNldCwgdHJ1ZSk7XG59XG5cbmZ1bmN0aW9uIGdldFVpbnQzMih2aWV3LCBvZmZzZXQpIHtcblx0cmV0dXJuIHZpZXcuZ2V0VWludDMyKG9mZnNldCwgdHJ1ZSk7XG59XG5cbmZ1bmN0aW9uIGdldEJpZ1VpbnQ2NCh2aWV3LCBvZmZzZXQpIHtcblx0cmV0dXJuIE51bWJlcih2aWV3LmdldEJpZ1VpbnQ2NChvZmZzZXQsIHRydWUpKTtcbn1cblxuZnVuY3Rpb24gc2V0VWludDMyJDEodmlldywgb2Zmc2V0LCB2YWx1ZSkge1xuXHR2aWV3LnNldFVpbnQzMihvZmZzZXQsIHZhbHVlLCB0cnVlKTtcbn1cblxuZnVuY3Rpb24gZ2V0RGF0YVZpZXckMShhcnJheSkge1xuXHRyZXR1cm4gbmV3IERhdGFWaWV3KGFycmF5LmJ1ZmZlcik7XG59XG5cbmZ1bmN0aW9uIHJlYWRVaW50OEFycmF5KHJlYWRlciwgb2Zmc2V0LCBzaXplKSB7XG5cdHJldHVybiByZWFkZXIucmVhZFVpbnQ4QXJyYXkob2Zmc2V0LCBzaXplKTtcbn1cblxuLypcbiBDb3B5cmlnaHQgKGMpIDIwMjEgR2lsZGFzIExvcm1lYXUuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG5cbiBSZWRpc3RyaWJ1dGlvbiBhbmQgdXNlIGluIHNvdXJjZSBhbmQgYmluYXJ5IGZvcm1zLCB3aXRoIG9yIHdpdGhvdXRcbiBtb2RpZmljYXRpb24sIGFyZSBwZXJtaXR0ZWQgcHJvdmlkZWQgdGhhdCB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnMgYXJlIG1ldDpcblxuIDEuIFJlZGlzdHJpYnV0aW9ucyBvZiBzb3VyY2UgY29kZSBtdXN0IHJldGFpbiB0aGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSxcbiB0aGlzIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZyBkaXNjbGFpbWVyLlxuXG4gMi4gUmVkaXN0cmlidXRpb25zIGluIGJpbmFyeSBmb3JtIG11c3QgcmVwcm9kdWNlIHRoZSBhYm92ZSBjb3B5cmlnaHQgXG4gbm90aWNlLCB0aGlzIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZyBkaXNjbGFpbWVyIGluIFxuIHRoZSBkb2N1bWVudGF0aW9uIGFuZC9vciBvdGhlciBtYXRlcmlhbHMgcHJvdmlkZWQgd2l0aCB0aGUgZGlzdHJpYnV0aW9uLlxuXG4gMy4gVGhlIG5hbWVzIG9mIHRoZSBhdXRob3JzIG1heSBub3QgYmUgdXNlZCB0byBlbmRvcnNlIG9yIHByb21vdGUgcHJvZHVjdHNcbiBkZXJpdmVkIGZyb20gdGhpcyBzb2Z0d2FyZSB3aXRob3V0IHNwZWNpZmljIHByaW9yIHdyaXR0ZW4gcGVybWlzc2lvbi5cblxuIFRISVMgU09GVFdBUkUgSVMgUFJPVklERUQgJydBUyBJUycnIEFORCBBTlkgRVhQUkVTU0VEIE9SIElNUExJRUQgV0FSUkFOVElFUyxcbiBJTkNMVURJTkcsIEJVVCBOT1QgTElNSVRFRCBUTywgVEhFIElNUExJRUQgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFkgQU5EXG4gRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQVJFIERJU0NMQUlNRUQuIElOIE5PIEVWRU5UIFNIQUxMIEpDUkFGVCxcbiBJTkMuIE9SIEFOWSBDT05UUklCVVRPUlMgVE8gVEhJUyBTT0ZUV0FSRSBCRSBMSUFCTEUgRk9SIEFOWSBESVJFQ1QsIElORElSRUNULFxuIElOQ0lERU5UQUwsIFNQRUNJQUwsIEVYRU1QTEFSWSwgT1IgQ09OU0VRVUVOVElBTCBEQU1BR0VTIChJTkNMVURJTkcsIEJVVCBOT1RcbiBMSU1JVEVEIFRPLCBQUk9DVVJFTUVOVCBPRiBTVUJTVElUVVRFIEdPT0RTIE9SIFNFUlZJQ0VTOyBMT1NTIE9GIFVTRSwgREFUQSxcbiBPUiBQUk9GSVRTOyBPUiBCVVNJTkVTUyBJTlRFUlJVUFRJT04pIEhPV0VWRVIgQ0FVU0VEIEFORCBPTiBBTlkgVEhFT1JZIE9GXG4gTElBQklMSVRZLCBXSEVUSEVSIElOIENPTlRSQUNULCBTVFJJQ1QgTElBQklMSVRZLCBPUiBUT1JUIChJTkNMVURJTkdcbiBORUdMSUdFTkNFIE9SIE9USEVSV0lTRSkgQVJJU0lORyBJTiBBTlkgV0FZIE9VVCBPRiBUSEUgVVNFIE9GIFRISVMgU09GVFdBUkUsXG4gRVZFTiBJRiBBRFZJU0VEIE9GIFRIRSBQT1NTSUJJTElUWSBPRiBTVUNIIERBTUFHRS5cbiAqL1xuXG5jb25zdCBFUlJfRFVQTElDQVRFRF9OQU1FID0gXCJGaWxlIGFscmVhZHkgZXhpc3RzXCI7XG5jb25zdCBFUlJfSU5WQUxJRF9DT01NRU5UID0gXCJaaXAgZmlsZSBjb21tZW50IGV4Y2VlZHMgNjRLQlwiO1xuY29uc3QgRVJSX0lOVkFMSURfRU5UUllfQ09NTUVOVCA9IFwiRmlsZSBlbnRyeSBjb21tZW50IGV4Y2VlZHMgNjRLQlwiO1xuY29uc3QgRVJSX0lOVkFMSURfRU5UUllfTkFNRSA9IFwiRmlsZSBlbnRyeSBuYW1lIGV4Y2VlZHMgNjRLQlwiO1xuY29uc3QgRVJSX0lOVkFMSURfVkVSU0lPTiA9IFwiVmVyc2lvbiBleGNlZWRzIDY1NTM1XCI7XG5jb25zdCBFUlJfSU5WQUxJRF9FTkNSWVBUSU9OX1NUUkVOR1RIID0gXCJUaGUgc3RyZW5ndGggbXVzdCBlcXVhbCAxLCAyLCBvciAzXCI7XG5jb25zdCBFUlJfSU5WQUxJRF9FWFRSQUZJRUxEX1RZUEUgPSBcIkV4dHJhIGZpZWxkIHR5cGUgZXhjZWVkcyA2NTUzNVwiO1xuY29uc3QgRVJSX0lOVkFMSURfRVhUUkFGSUVMRF9EQVRBID0gXCJFeHRyYSBmaWVsZCBkYXRhIGV4Y2VlZHMgNjRLQlwiO1xuY29uc3QgRVJSX1VOU1VQUE9SVEVEX0ZPUk1BVCA9IFwiWmlwNjQgaXMgbm90IHN1cHBvcnRlZFwiO1xuXG5jb25zdCBFWFRSQUZJRUxEX0RBVEFfQUVTID0gbmV3IFVpbnQ4QXJyYXkoWzB4MDcsIDB4MDAsIDB4MDIsIDB4MDAsIDB4NDEsIDB4NDUsIDB4MDMsIDB4MDAsIDB4MDBdKTtcbmNvbnN0IEVYVFJBRklFTERfTEVOR1RIX1pJUDY0ID0gMjQ7XG5cbmxldCB3b3JrZXJzID0gMDtcblxuY2xhc3MgWmlwV3JpdGVyIHtcblxuXHRjb25zdHJ1Y3Rvcih3cml0ZXIsIG9wdGlvbnMgPSB7fSkge1xuXHRcdE9iamVjdC5hc3NpZ24odGhpcywge1xuXHRcdFx0d3JpdGVyLFxuXHRcdFx0b3B0aW9ucyxcblx0XHRcdGNvbmZpZzogZ2V0Q29uZmlndXJhdGlvbigpLFxuXHRcdFx0ZmlsZXM6IG5ldyBNYXAoKSxcblx0XHRcdG9mZnNldDogd3JpdGVyLnNpemUsXG5cdFx0XHRwZW5kaW5nQ29tcHJlc3NlZFNpemU6IDAsXG5cdFx0XHRwZW5kaW5nRW50cmllczogW11cblx0XHR9KTtcblx0fVxuXG5cdGFzeW5jIGFkZChuYW1lID0gXCJcIiwgcmVhZGVyLCBvcHRpb25zID0ge30pIHtcblx0XHRjb25zdCB6aXBXcml0ZXIgPSB0aGlzO1xuXHRcdGlmICh3b3JrZXJzIDwgemlwV3JpdGVyLmNvbmZpZy5tYXhXb3JrZXJzKSB7XG5cdFx0XHR3b3JrZXJzKys7XG5cdFx0XHR0cnkge1xuXHRcdFx0XHRyZXR1cm4gYXdhaXQgYWRkRmlsZSh6aXBXcml0ZXIsIG5hbWUsIHJlYWRlciwgb3B0aW9ucyk7XG5cdFx0XHR9IGZpbmFsbHkge1xuXHRcdFx0XHR3b3JrZXJzLS07XG5cdFx0XHRcdGNvbnN0IHBlbmRpbmdFbnRyeSA9IHppcFdyaXRlci5wZW5kaW5nRW50cmllcy5zaGlmdCgpO1xuXHRcdFx0XHRpZiAocGVuZGluZ0VudHJ5KSB7XG5cdFx0XHRcdFx0emlwV3JpdGVyLmFkZChwZW5kaW5nRW50cnkubmFtZSwgcGVuZGluZ0VudHJ5LnJlYWRlciwgcGVuZGluZ0VudHJ5Lm9wdGlvbnMpXG5cdFx0XHRcdFx0XHQudGhlbihwZW5kaW5nRW50cnkucmVzb2x2ZSlcblx0XHRcdFx0XHRcdC5jYXRjaChwZW5kaW5nRW50cnkucmVqZWN0KTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0gZWxzZSB7XG5cdFx0XHRyZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4gemlwV3JpdGVyLnBlbmRpbmdFbnRyaWVzLnB1c2goeyBuYW1lLCByZWFkZXIsIG9wdGlvbnMsIHJlc29sdmUsIHJlamVjdCB9KSk7XG5cdFx0fVxuXHR9XG5cblx0YXN5bmMgY2xvc2UoY29tbWVudCA9IG5ldyBVaW50OEFycmF5KDApLCBvcHRpb25zID0ge30pIHtcblx0XHRhd2FpdCBjbG9zZUZpbGUodGhpcywgY29tbWVudCwgb3B0aW9ucyk7XG5cdFx0cmV0dXJuIHRoaXMud3JpdGVyLmdldERhdGEoKTtcblx0fVxufVxuXG5hc3luYyBmdW5jdGlvbiBhZGRGaWxlKHppcFdyaXRlciwgbmFtZSwgcmVhZGVyLCBvcHRpb25zKSB7XG5cdG5hbWUgPSBuYW1lLnRyaW0oKTtcblx0aWYgKG9wdGlvbnMuZGlyZWN0b3J5ICYmICghbmFtZS5lbmRzV2l0aChESVJFQ1RPUllfU0lHTkFUVVJFKSkpIHtcblx0XHRuYW1lICs9IERJUkVDVE9SWV9TSUdOQVRVUkU7XG5cdH0gZWxzZSB7XG5cdFx0b3B0aW9ucy5kaXJlY3RvcnkgPSBuYW1lLmVuZHNXaXRoKERJUkVDVE9SWV9TSUdOQVRVUkUpO1xuXHR9XG5cdGlmICh6aXBXcml0ZXIuZmlsZXMuaGFzKG5hbWUpKSB7XG5cdFx0dGhyb3cgbmV3IEVycm9yKEVSUl9EVVBMSUNBVEVEX05BTUUpO1xuXHR9XG5cdGNvbnN0IHJhd0ZpbGVuYW1lID0gKG5ldyBUZXh0RW5jb2RlcigpKS5lbmNvZGUobmFtZSk7XG5cdGlmIChyYXdGaWxlbmFtZS5sZW5ndGggPiBNQVhfMTZfQklUUykge1xuXHRcdHRocm93IG5ldyBFcnJvcihFUlJfSU5WQUxJRF9FTlRSWV9OQU1FKTtcblx0fVxuXHRjb25zdCBjb21tZW50ID0gb3B0aW9ucy5jb21tZW50IHx8IFwiXCI7XG5cdGNvbnN0IHJhd0NvbW1lbnQgPSAobmV3IFRleHRFbmNvZGVyKCkpLmVuY29kZShjb21tZW50KTtcblx0aWYgKHJhd0NvbW1lbnQubGVuZ3RoID4gTUFYXzE2X0JJVFMpIHtcblx0XHR0aHJvdyBuZXcgRXJyb3IoRVJSX0lOVkFMSURfRU5UUllfQ09NTUVOVCk7XG5cdH1cblx0Y29uc3QgdmVyc2lvbiA9IHppcFdyaXRlci5vcHRpb25zLnZlcnNpb24gfHwgb3B0aW9ucy52ZXJzaW9uIHx8IDA7XG5cdGlmICh2ZXJzaW9uID4gTUFYXzE2X0JJVFMpIHtcblx0XHR0aHJvdyBuZXcgRXJyb3IoRVJSX0lOVkFMSURfVkVSU0lPTik7XG5cdH1cblx0Y29uc3QgdmVyc2lvbk1hZGVCeSA9IHppcFdyaXRlci5vcHRpb25zLnZlcnNpb25NYWRlQnkgfHwgb3B0aW9ucy52ZXJzaW9uTWFkZUJ5IHx8IDIwO1xuXHRpZiAodmVyc2lvbk1hZGVCeSA+IE1BWF8xNl9CSVRTKSB7XG5cdFx0dGhyb3cgbmV3IEVycm9yKEVSUl9JTlZBTElEX1ZFUlNJT04pO1xuXHR9XG5cdGNvbnN0IGxhc3RNb2REYXRlID0gZ2V0T3B0aW9uVmFsdWUoemlwV3JpdGVyLCBvcHRpb25zLCBcImxhc3RNb2REYXRlXCIpIHx8IG5ldyBEYXRlKCk7XG5cdGNvbnN0IGxhc3RBY2Nlc3NEYXRlID0gZ2V0T3B0aW9uVmFsdWUoemlwV3JpdGVyLCBvcHRpb25zLCBcImxhc3RBY2Nlc3NEYXRlXCIpO1xuXHRjb25zdCBjcmVhdGlvbkRhdGUgPSBnZXRPcHRpb25WYWx1ZSh6aXBXcml0ZXIsIG9wdGlvbnMsIFwiY3JlYXRpb25EYXRlXCIpO1xuXHRjb25zdCBwYXNzd29yZCA9IGdldE9wdGlvblZhbHVlKHppcFdyaXRlciwgb3B0aW9ucywgXCJwYXNzd29yZFwiKTtcblx0Y29uc3QgZW5jcnlwdGlvblN0cmVuZ3RoID0gZ2V0T3B0aW9uVmFsdWUoemlwV3JpdGVyLCBvcHRpb25zLCBcImVuY3J5cHRpb25TdHJlbmd0aFwiKSB8fCAzO1xuXHRjb25zdCB6aXBDcnlwdG8gPSBnZXRPcHRpb25WYWx1ZSh6aXBXcml0ZXIsIG9wdGlvbnMsIFwiemlwQ3J5cHRvXCIpO1xuXHRpZiAocGFzc3dvcmQgIT09IHVuZGVmaW5lZCAmJiBlbmNyeXB0aW9uU3RyZW5ndGggIT09IHVuZGVmaW5lZCAmJiAoZW5jcnlwdGlvblN0cmVuZ3RoIDwgMSB8fCBlbmNyeXB0aW9uU3RyZW5ndGggPiAzKSkge1xuXHRcdHRocm93IG5ldyBFcnJvcihFUlJfSU5WQUxJRF9FTkNSWVBUSU9OX1NUUkVOR1RIKTtcblx0fVxuXHRsZXQgcmF3RXh0cmFGaWVsZCA9IG5ldyBVaW50OEFycmF5KDApO1xuXHRjb25zdCBleHRyYUZpZWxkID0gb3B0aW9ucy5leHRyYUZpZWxkO1xuXHRpZiAoZXh0cmFGaWVsZCkge1xuXHRcdGxldCBleHRyYUZpZWxkU2l6ZSA9IDA7XG5cdFx0bGV0IG9mZnNldCA9IDA7XG5cdFx0ZXh0cmFGaWVsZC5mb3JFYWNoKGRhdGEgPT4gZXh0cmFGaWVsZFNpemUgKz0gNCArIGRhdGEubGVuZ3RoKTtcblx0XHRyYXdFeHRyYUZpZWxkID0gbmV3IFVpbnQ4QXJyYXkoZXh0cmFGaWVsZFNpemUpO1xuXHRcdGV4dHJhRmllbGQuZm9yRWFjaCgoZGF0YSwgdHlwZSkgPT4ge1xuXHRcdFx0aWYgKHR5cGUgPiBNQVhfMTZfQklUUykge1xuXHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoRVJSX0lOVkFMSURfRVhUUkFGSUVMRF9UWVBFKTtcblx0XHRcdH1cblx0XHRcdGlmIChkYXRhLmxlbmd0aCA+IE1BWF8xNl9CSVRTKSB7XG5cdFx0XHRcdHRocm93IG5ldyBFcnJvcihFUlJfSU5WQUxJRF9FWFRSQUZJRUxEX0RBVEEpO1xuXHRcdFx0fVxuXHRcdFx0YXJyYXlTZXQocmF3RXh0cmFGaWVsZCwgbmV3IFVpbnQxNkFycmF5KFt0eXBlXSksIG9mZnNldCk7XG5cdFx0XHRhcnJheVNldChyYXdFeHRyYUZpZWxkLCBuZXcgVWludDE2QXJyYXkoW2RhdGEubGVuZ3RoXSksIG9mZnNldCArIDIpO1xuXHRcdFx0YXJyYXlTZXQocmF3RXh0cmFGaWVsZCwgZGF0YSwgb2Zmc2V0ICsgNCk7XG5cdFx0XHRvZmZzZXQgKz0gNCArIGRhdGEubGVuZ3RoO1xuXHRcdH0pO1xuXHR9XG5cdGxldCBleHRlbmRlZFRpbWVzdGFtcCA9IGdldE9wdGlvblZhbHVlKHppcFdyaXRlciwgb3B0aW9ucywgXCJleHRlbmRlZFRpbWVzdGFtcFwiKTtcblx0aWYgKGV4dGVuZGVkVGltZXN0YW1wID09PSB1bmRlZmluZWQpIHtcblx0XHRleHRlbmRlZFRpbWVzdGFtcCA9IHRydWU7XG5cdH1cblx0bGV0IG1heGltdW1Db21wcmVzc2VkU2l6ZSA9IDA7XG5cdGxldCBrZWVwT3JkZXIgPSBnZXRPcHRpb25WYWx1ZSh6aXBXcml0ZXIsIG9wdGlvbnMsIFwia2VlcE9yZGVyXCIpO1xuXHRpZiAoa2VlcE9yZGVyID09PSB1bmRlZmluZWQpIHtcblx0XHRrZWVwT3JkZXIgPSB0cnVlO1xuXHR9XG5cdGxldCB1bmNvbXByZXNzZWRTaXplID0gMDtcblx0bGV0IG1zRG9zQ29tcGF0aWJsZSA9IGdldE9wdGlvblZhbHVlKHppcFdyaXRlciwgb3B0aW9ucywgXCJtc0Rvc0NvbXBhdGlibGVcIik7XG5cdGlmIChtc0Rvc0NvbXBhdGlibGUgPT09IHVuZGVmaW5lZCkge1xuXHRcdG1zRG9zQ29tcGF0aWJsZSA9IHRydWU7XG5cdH1cblx0Y29uc3QgaW50ZXJuYWxGaWxlQXR0cmlidXRlID0gZ2V0T3B0aW9uVmFsdWUoemlwV3JpdGVyLCBvcHRpb25zLCBcImludGVybmFsRmlsZUF0dHJpYnV0ZVwiKSB8fCAwO1xuXHRjb25zdCBleHRlcm5hbEZpbGVBdHRyaWJ1dGUgPSBnZXRPcHRpb25WYWx1ZSh6aXBXcml0ZXIsIG9wdGlvbnMsIFwiZXh0ZXJuYWxGaWxlQXR0cmlidXRlXCIpIHx8IDA7XG5cdGlmIChyZWFkZXIpIHtcblx0XHRpZiAoIXJlYWRlci5pbml0aWFsaXplZCkge1xuXHRcdFx0YXdhaXQgcmVhZGVyLmluaXQoKTtcblx0XHR9XG5cdFx0dW5jb21wcmVzc2VkU2l6ZSA9IHJlYWRlci5zaXplO1xuXHRcdG1heGltdW1Db21wcmVzc2VkU2l6ZSA9IGdldE1heGltdW1Db21wcmVzc2VkU2l6ZSh1bmNvbXByZXNzZWRTaXplKTtcblx0fVxuXHRsZXQgemlwNjQgPSBvcHRpb25zLnppcDY0IHx8IHppcFdyaXRlci5vcHRpb25zLnppcDY0IHx8IGZhbHNlO1xuXHRpZiAoemlwV3JpdGVyLm9mZnNldCArIHppcFdyaXRlci5wZW5kaW5nQ29tcHJlc3NlZFNpemUgPj0gTUFYXzMyX0JJVFMgfHxcblx0XHR1bmNvbXByZXNzZWRTaXplID49IE1BWF8zMl9CSVRTIHx8XG5cdFx0bWF4aW11bUNvbXByZXNzZWRTaXplID49IE1BWF8zMl9CSVRTKSB7XG5cdFx0aWYgKG9wdGlvbnMuemlwNjQgPT09IGZhbHNlIHx8IHppcFdyaXRlci5vcHRpb25zLnppcDY0ID09PSBmYWxzZSB8fCAha2VlcE9yZGVyKSB7XG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoRVJSX1VOU1VQUE9SVEVEX0ZPUk1BVCk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHppcDY0ID0gdHJ1ZTtcblx0XHR9XG5cdH1cblx0emlwV3JpdGVyLnBlbmRpbmdDb21wcmVzc2VkU2l6ZSArPSBtYXhpbXVtQ29tcHJlc3NlZFNpemU7XG5cdGF3YWl0IFByb21pc2UucmVzb2x2ZSgpO1xuXHRjb25zdCBsZXZlbCA9IGdldE9wdGlvblZhbHVlKHppcFdyaXRlciwgb3B0aW9ucywgXCJsZXZlbFwiKTtcblx0Y29uc3QgdXNlV2ViV29ya2VycyA9IGdldE9wdGlvblZhbHVlKHppcFdyaXRlciwgb3B0aW9ucywgXCJ1c2VXZWJXb3JrZXJzXCIpO1xuXHRjb25zdCBidWZmZXJlZFdyaXRlID0gZ2V0T3B0aW9uVmFsdWUoemlwV3JpdGVyLCBvcHRpb25zLCBcImJ1ZmZlcmVkV3JpdGVcIik7XG5cdGxldCBkYXRhRGVzY3JpcHRvciA9IGdldE9wdGlvblZhbHVlKHppcFdyaXRlciwgb3B0aW9ucywgXCJkYXRhRGVzY3JpcHRvclwiKTtcblx0Y29uc3Qgc2lnbmFsID0gZ2V0T3B0aW9uVmFsdWUoemlwV3JpdGVyLCBvcHRpb25zLCBcInNpZ25hbFwiKTtcblx0aWYgKGRhdGFEZXNjcmlwdG9yID09PSB1bmRlZmluZWQpIHtcblx0XHRkYXRhRGVzY3JpcHRvciA9IHRydWU7XG5cdH1cblx0Y29uc3QgZmlsZUVudHJ5ID0gYXdhaXQgZ2V0RmlsZUVudHJ5KHppcFdyaXRlciwgbmFtZSwgcmVhZGVyLCBPYmplY3QuYXNzaWduKHt9LCBvcHRpb25zLCB7XG5cdFx0cmF3RmlsZW5hbWUsXG5cdFx0cmF3Q29tbWVudCxcblx0XHR2ZXJzaW9uLFxuXHRcdHZlcnNpb25NYWRlQnksXG5cdFx0bGFzdE1vZERhdGUsXG5cdFx0bGFzdEFjY2Vzc0RhdGUsXG5cdFx0Y3JlYXRpb25EYXRlLFxuXHRcdHJhd0V4dHJhRmllbGQsXG5cdFx0emlwNjQsXG5cdFx0cGFzc3dvcmQsXG5cdFx0bGV2ZWwsXG5cdFx0dXNlV2ViV29ya2Vycyxcblx0XHRlbmNyeXB0aW9uU3RyZW5ndGgsXG5cdFx0ZXh0ZW5kZWRUaW1lc3RhbXAsXG5cdFx0emlwQ3J5cHRvLFxuXHRcdGJ1ZmZlcmVkV3JpdGUsXG5cdFx0a2VlcE9yZGVyLFxuXHRcdGRhdGFEZXNjcmlwdG9yLFxuXHRcdHNpZ25hbCxcblx0XHRtc0Rvc0NvbXBhdGlibGUsXG5cdFx0aW50ZXJuYWxGaWxlQXR0cmlidXRlLFxuXHRcdGV4dGVybmFsRmlsZUF0dHJpYnV0ZVxuXHR9KSk7XG5cdGlmIChtYXhpbXVtQ29tcHJlc3NlZFNpemUpIHtcblx0XHR6aXBXcml0ZXIucGVuZGluZ0NvbXByZXNzZWRTaXplIC09IG1heGltdW1Db21wcmVzc2VkU2l6ZTtcblx0fVxuXHRPYmplY3QuYXNzaWduKGZpbGVFbnRyeSwgeyBuYW1lLCBjb21tZW50LCBleHRyYUZpZWxkIH0pO1xuXHRyZXR1cm4gbmV3IEVudHJ5KGZpbGVFbnRyeSk7XG59XG5cbmFzeW5jIGZ1bmN0aW9uIGdldEZpbGVFbnRyeSh6aXBXcml0ZXIsIG5hbWUsIHJlYWRlciwgb3B0aW9ucykge1xuXHRjb25zdCBmaWxlcyA9IHppcFdyaXRlci5maWxlcztcblx0Y29uc3Qgd3JpdGVyID0gemlwV3JpdGVyLndyaXRlcjtcblx0Y29uc3QgcHJldmlvdXNGaWxlRW50cnkgPSBBcnJheS5mcm9tKGZpbGVzLnZhbHVlcygpKS5wb3AoKTtcblx0bGV0IGZpbGVFbnRyeSA9IHt9O1xuXHRsZXQgYnVmZmVyZWRXcml0ZTtcblx0bGV0IHJlc29sdmVMb2NrVW5idWZmZXJlZFdyaXRlO1xuXHRsZXQgcmVzb2x2ZUxvY2tDdXJyZW50RmlsZUVudHJ5O1xuXHRmaWxlcy5zZXQobmFtZSwgZmlsZUVudHJ5KTtcblx0dHJ5IHtcblx0XHRsZXQgbG9ja1ByZXZpb3VzRmlsZUVudHJ5O1xuXHRcdGxldCBmaWxlV3JpdGVyO1xuXHRcdGxldCBsb2NrQ3VycmVudEZpbGVFbnRyeTtcblx0XHRpZiAob3B0aW9ucy5rZWVwT3JkZXIpIHtcblx0XHRcdGxvY2tQcmV2aW91c0ZpbGVFbnRyeSA9IHByZXZpb3VzRmlsZUVudHJ5ICYmIHByZXZpb3VzRmlsZUVudHJ5LmxvY2s7XG5cdFx0fVxuXHRcdGZpbGVFbnRyeS5sb2NrID0gbG9ja0N1cnJlbnRGaWxlRW50cnkgPSBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHJlc29sdmVMb2NrQ3VycmVudEZpbGVFbnRyeSA9IHJlc29sdmUpO1xuXHRcdGlmIChvcHRpb25zLmJ1ZmZlcmVkV3JpdGUgfHwgemlwV3JpdGVyLmxvY2tXcml0ZSB8fCAhb3B0aW9ucy5kYXRhRGVzY3JpcHRvcikge1xuXHRcdFx0ZmlsZVdyaXRlciA9IG5ldyBCbG9iV3JpdGVyKCk7XG5cdFx0XHRmaWxlV3JpdGVyLmluaXQoKTtcblx0XHRcdGJ1ZmZlcmVkV3JpdGUgPSB0cnVlO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR6aXBXcml0ZXIubG9ja1dyaXRlID0gbmV3IFByb21pc2UocmVzb2x2ZSA9PiByZXNvbHZlTG9ja1VuYnVmZmVyZWRXcml0ZSA9IHJlc29sdmUpO1xuXHRcdFx0aWYgKCF3cml0ZXIuaW5pdGlhbGl6ZWQpIHtcblx0XHRcdFx0YXdhaXQgd3JpdGVyLmluaXQoKTtcblx0XHRcdH1cblx0XHRcdGZpbGVXcml0ZXIgPSB3cml0ZXI7XG5cdFx0fVxuXHRcdGZpbGVFbnRyeSA9IGF3YWl0IGNyZWF0ZUZpbGVFbnRyeShyZWFkZXIsIGZpbGVXcml0ZXIsIHppcFdyaXRlci5jb25maWcsIG9wdGlvbnMpO1xuXHRcdGZpbGVFbnRyeS5sb2NrID0gbG9ja0N1cnJlbnRGaWxlRW50cnk7XG5cdFx0ZmlsZXMuc2V0KG5hbWUsIGZpbGVFbnRyeSk7XG5cdFx0ZmlsZUVudHJ5LmZpbGVuYW1lID0gbmFtZTtcblx0XHRpZiAoYnVmZmVyZWRXcml0ZSkge1xuXHRcdFx0bGV0IGluZGV4V3JpdHRlbkRhdGEgPSAwO1xuXHRcdFx0Y29uc3QgYmxvYiA9IGZpbGVXcml0ZXIuZ2V0RGF0YSgpO1xuXHRcdFx0YXdhaXQgUHJvbWlzZS5hbGwoW3ppcFdyaXRlci5sb2NrV3JpdGUsIGxvY2tQcmV2aW91c0ZpbGVFbnRyeV0pO1xuXHRcdFx0bGV0IHBlbmRpbmdGaWxlRW50cnk7XG5cdFx0XHRkbyB7XG5cdFx0XHRcdHBlbmRpbmdGaWxlRW50cnkgPSBBcnJheS5mcm9tKGZpbGVzLnZhbHVlcygpKS5maW5kKGZpbGVFbnRyeSA9PiBmaWxlRW50cnkud3JpdGluZ0J1ZmZlcmVkRGF0YSk7XG5cdFx0XHRcdGlmIChwZW5kaW5nRmlsZUVudHJ5KSB7XG5cdFx0XHRcdFx0YXdhaXQgcGVuZGluZ0ZpbGVFbnRyeS5sb2NrO1xuXHRcdFx0XHR9XG5cdFx0XHR9IHdoaWxlIChwZW5kaW5nRmlsZUVudHJ5ICYmIHBlbmRpbmdGaWxlRW50cnkubG9jayk7XG5cdFx0XHRmaWxlRW50cnkud3JpdGluZ0J1ZmZlcmVkRGF0YSA9IHRydWU7XG5cdFx0XHRpZiAoIW9wdGlvbnMuZGF0YURlc2NyaXB0b3IpIHtcblx0XHRcdFx0Y29uc3QgaGVhZGVyTGVuZ3RoID0gMjY7XG5cdFx0XHRcdGNvbnN0IGFycmF5QnVmZmVyID0gYXdhaXQgc2xpY2VBc0FycmF5QnVmZmVyKGJsb2IsIDAsIGhlYWRlckxlbmd0aCk7XG5cdFx0XHRcdGNvbnN0IGFycmF5QnVmZmVyVmlldyA9IG5ldyBEYXRhVmlldyhhcnJheUJ1ZmZlcik7XG5cdFx0XHRcdGlmICghZmlsZUVudHJ5LmVuY3J5cHRlZCB8fCBvcHRpb25zLnppcENyeXB0bykge1xuXHRcdFx0XHRcdHNldFVpbnQzMihhcnJheUJ1ZmZlclZpZXcsIDE0LCBmaWxlRW50cnkuc2lnbmF0dXJlKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoZmlsZUVudHJ5LnppcDY0KSB7XG5cdFx0XHRcdFx0c2V0VWludDMyKGFycmF5QnVmZmVyVmlldywgMTgsIE1BWF8zMl9CSVRTKTtcblx0XHRcdFx0XHRzZXRVaW50MzIoYXJyYXlCdWZmZXJWaWV3LCAyMiwgTUFYXzMyX0JJVFMpO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHNldFVpbnQzMihhcnJheUJ1ZmZlclZpZXcsIDE4LCBmaWxlRW50cnkuY29tcHJlc3NlZFNpemUpO1xuXHRcdFx0XHRcdHNldFVpbnQzMihhcnJheUJ1ZmZlclZpZXcsIDIyLCBmaWxlRW50cnkudW5jb21wcmVzc2VkU2l6ZSk7XG5cdFx0XHRcdH1cblx0XHRcdFx0YXdhaXQgd3JpdGVyLndyaXRlVWludDhBcnJheShuZXcgVWludDhBcnJheShhcnJheUJ1ZmZlcikpO1xuXHRcdFx0XHRpbmRleFdyaXR0ZW5EYXRhID0gaGVhZGVyTGVuZ3RoO1xuXHRcdFx0fVxuXHRcdFx0YXdhaXQgd3JpdGVCbG9iKHdyaXRlciwgYmxvYiwgaW5kZXhXcml0dGVuRGF0YSk7XG5cdFx0XHRkZWxldGUgZmlsZUVudHJ5LndyaXRpbmdCdWZmZXJlZERhdGE7XG5cdFx0fVxuXHRcdGZpbGVFbnRyeS5vZmZzZXQgPSB6aXBXcml0ZXIub2Zmc2V0O1xuXHRcdGlmIChmaWxlRW50cnkuemlwNjQpIHtcblx0XHRcdGNvbnN0IHJhd0V4dHJhRmllbGRaaXA2NFZpZXcgPSBnZXREYXRhVmlldyhmaWxlRW50cnkucmF3RXh0cmFGaWVsZFppcDY0KTtcblx0XHRcdHNldEJpZ1VpbnQ2NChyYXdFeHRyYUZpZWxkWmlwNjRWaWV3LCAyMCwgQmlnSW50KGZpbGVFbnRyeS5vZmZzZXQpKTtcblx0XHR9IGVsc2UgaWYgKGZpbGVFbnRyeS5vZmZzZXQgPj0gTUFYXzMyX0JJVFMpIHtcblx0XHRcdHRocm93IG5ldyBFcnJvcihFUlJfVU5TVVBQT1JURURfRk9STUFUKTtcblx0XHR9XG5cdFx0emlwV3JpdGVyLm9mZnNldCArPSBmaWxlRW50cnkubGVuZ3RoO1xuXHRcdHJldHVybiBmaWxlRW50cnk7XG5cdH0gY2F0Y2ggKGVycm9yKSB7XG5cdFx0aWYgKChidWZmZXJlZFdyaXRlICYmIGZpbGVFbnRyeS53cml0aW5nQnVmZmVyZWREYXRhKSB8fCAoIWJ1ZmZlcmVkV3JpdGUgJiYgZmlsZUVudHJ5LmRhdGFXcml0dGVuKSkge1xuXHRcdFx0ZXJyb3IuY29ycnVwdGVkRW50cnkgPSB6aXBXcml0ZXIuaGFzQ29ycnVwdGVkRW50cmllcyA9IHRydWU7XG5cdFx0XHRpZiAoZmlsZUVudHJ5LnVuY29tcHJlc3NlZFNpemUpIHtcblx0XHRcdFx0emlwV3JpdGVyLm9mZnNldCArPSBmaWxlRW50cnkudW5jb21wcmVzc2VkU2l6ZTtcblx0XHRcdH1cblx0XHR9XG5cdFx0ZmlsZXMuZGVsZXRlKG5hbWUpO1xuXHRcdHRocm93IGVycm9yO1xuXHR9IGZpbmFsbHkge1xuXHRcdHJlc29sdmVMb2NrQ3VycmVudEZpbGVFbnRyeSgpO1xuXHRcdGlmIChyZXNvbHZlTG9ja1VuYnVmZmVyZWRXcml0ZSkge1xuXHRcdFx0cmVzb2x2ZUxvY2tVbmJ1ZmZlcmVkV3JpdGUoKTtcblx0XHR9XG5cdH1cbn1cblxuYXN5bmMgZnVuY3Rpb24gY3JlYXRlRmlsZUVudHJ5KHJlYWRlciwgd3JpdGVyLCBjb25maWcsIG9wdGlvbnMpIHtcblx0Y29uc3Qge1xuXHRcdHJhd0ZpbGVuYW1lLFxuXHRcdGxhc3RBY2Nlc3NEYXRlLFxuXHRcdGNyZWF0aW9uRGF0ZSxcblx0XHRwYXNzd29yZCxcblx0XHRsZXZlbCxcblx0XHR6aXA2NCxcblx0XHR6aXBDcnlwdG8sXG5cdFx0ZGF0YURlc2NyaXB0b3IsXG5cdFx0ZGlyZWN0b3J5LFxuXHRcdHZlcnNpb24sXG5cdFx0dmVyc2lvbk1hZGVCeSxcblx0XHRyYXdDb21tZW50LFxuXHRcdHJhd0V4dHJhRmllbGQsXG5cdFx0dXNlV2ViV29ya2Vycyxcblx0XHRvbnByb2dyZXNzLFxuXHRcdHNpZ25hbCxcblx0XHRlbmNyeXB0aW9uU3RyZW5ndGgsXG5cdFx0ZXh0ZW5kZWRUaW1lc3RhbXAsXG5cdFx0bXNEb3NDb21wYXRpYmxlLFxuXHRcdGludGVybmFsRmlsZUF0dHJpYnV0ZSxcblx0XHRleHRlcm5hbEZpbGVBdHRyaWJ1dGVcblx0fSA9IG9wdGlvbnM7XG5cdGNvbnN0IGVuY3J5cHRlZCA9IEJvb2xlYW4ocGFzc3dvcmQgJiYgcGFzc3dvcmQubGVuZ3RoKTtcblx0Y29uc3QgY29tcHJlc3NlZCA9IGxldmVsICE9PSAwICYmICFkaXJlY3Rvcnk7XG5cdGxldCByYXdFeHRyYUZpZWxkQUVTO1xuXHRpZiAoZW5jcnlwdGVkICYmICF6aXBDcnlwdG8pIHtcblx0XHRyYXdFeHRyYUZpZWxkQUVTID0gbmV3IFVpbnQ4QXJyYXkoRVhUUkFGSUVMRF9EQVRBX0FFUy5sZW5ndGggKyAyKTtcblx0XHRjb25zdCBleHRyYUZpZWxkQUVTVmlldyA9IGdldERhdGFWaWV3KHJhd0V4dHJhRmllbGRBRVMpO1xuXHRcdHNldFVpbnQxNihleHRyYUZpZWxkQUVTVmlldywgMCwgRVhUUkFGSUVMRF9UWVBFX0FFUyk7XG5cdFx0YXJyYXlTZXQocmF3RXh0cmFGaWVsZEFFUywgRVhUUkFGSUVMRF9EQVRBX0FFUywgMik7XG5cdFx0c2V0VWludDgoZXh0cmFGaWVsZEFFU1ZpZXcsIDgsIGVuY3J5cHRpb25TdHJlbmd0aCk7XG5cdH0gZWxzZSB7XG5cdFx0cmF3RXh0cmFGaWVsZEFFUyA9IG5ldyBVaW50OEFycmF5KDApO1xuXHR9XG5cdGxldCByYXdFeHRyYUZpZWxkTlRGUztcblx0bGV0IHJhd0V4dHJhRmllbGRFeHRlbmRlZFRpbWVzdGFtcDtcblx0aWYgKGV4dGVuZGVkVGltZXN0YW1wKSB7XG5cdFx0cmF3RXh0cmFGaWVsZEV4dGVuZGVkVGltZXN0YW1wID0gbmV3IFVpbnQ4QXJyYXkoOSArIChsYXN0QWNjZXNzRGF0ZSA/IDQgOiAwKSArIChjcmVhdGlvbkRhdGUgPyA0IDogMCkpO1xuXHRcdGNvbnN0IGV4dHJhRmllbGRFeHRlbmRlZFRpbWVzdGFtcFZpZXcgPSBnZXREYXRhVmlldyhyYXdFeHRyYUZpZWxkRXh0ZW5kZWRUaW1lc3RhbXApO1xuXHRcdHNldFVpbnQxNihleHRyYUZpZWxkRXh0ZW5kZWRUaW1lc3RhbXBWaWV3LCAwLCBFWFRSQUZJRUxEX1RZUEVfRVhURU5ERURfVElNRVNUQU1QKTtcblx0XHRzZXRVaW50MTYoZXh0cmFGaWVsZEV4dGVuZGVkVGltZXN0YW1wVmlldywgMiwgcmF3RXh0cmFGaWVsZEV4dGVuZGVkVGltZXN0YW1wLmxlbmd0aCAtIDQpO1xuXHRcdGNvbnN0IGV4dHJhRmllbGRFeHRlbmRlZFRpbWVzdGFtcEZsYWcgPSAweDEgKyAobGFzdEFjY2Vzc0RhdGUgPyAweDIgOiAwKSArIChjcmVhdGlvbkRhdGUgPyAweDQgOiAwKTtcblx0XHRzZXRVaW50OChleHRyYUZpZWxkRXh0ZW5kZWRUaW1lc3RhbXBWaWV3LCA0LCBleHRyYUZpZWxkRXh0ZW5kZWRUaW1lc3RhbXBGbGFnKTtcblx0XHRzZXRVaW50MzIoZXh0cmFGaWVsZEV4dGVuZGVkVGltZXN0YW1wVmlldywgNSwgTWF0aC5mbG9vcihvcHRpb25zLmxhc3RNb2REYXRlLmdldFRpbWUoKSAvIDEwMDApKTtcblx0XHRpZiAobGFzdEFjY2Vzc0RhdGUpIHtcblx0XHRcdHNldFVpbnQzMihleHRyYUZpZWxkRXh0ZW5kZWRUaW1lc3RhbXBWaWV3LCA5LCBNYXRoLmZsb29yKGxhc3RBY2Nlc3NEYXRlLmdldFRpbWUoKSAvIDEwMDApKTtcblx0XHR9XG5cdFx0aWYgKGNyZWF0aW9uRGF0ZSkge1xuXHRcdFx0c2V0VWludDMyKGV4dHJhRmllbGRFeHRlbmRlZFRpbWVzdGFtcFZpZXcsIDEzLCBNYXRoLmZsb29yKGNyZWF0aW9uRGF0ZS5nZXRUaW1lKCkgLyAxMDAwKSk7XG5cdFx0fVxuXHRcdHRyeSB7XG5cdFx0XHRyYXdFeHRyYUZpZWxkTlRGUyA9IG5ldyBVaW50OEFycmF5KDM2KTtcblx0XHRcdGNvbnN0IGV4dHJhRmllbGROVEZTVmlldyA9IGdldERhdGFWaWV3KHJhd0V4dHJhRmllbGROVEZTKTtcblx0XHRcdGNvbnN0IGxhc3RNb2RUaW1lTlRGUyA9IGdldFRpbWVOVEZTKG9wdGlvbnMubGFzdE1vZERhdGUpO1xuXHRcdFx0c2V0VWludDE2KGV4dHJhRmllbGROVEZTVmlldywgMCwgRVhUUkFGSUVMRF9UWVBFX05URlMpO1xuXHRcdFx0c2V0VWludDE2KGV4dHJhRmllbGROVEZTVmlldywgMiwgMzIpO1xuXHRcdFx0c2V0VWludDE2KGV4dHJhRmllbGROVEZTVmlldywgOCwgRVhUUkFGSUVMRF9UWVBFX05URlNfVEFHMSk7XG5cdFx0XHRzZXRVaW50MTYoZXh0cmFGaWVsZE5URlNWaWV3LCAxMCwgMjQpO1xuXHRcdFx0c2V0QmlnVWludDY0KGV4dHJhRmllbGROVEZTVmlldywgMTIsIGxhc3RNb2RUaW1lTlRGUyk7XG5cdFx0XHRzZXRCaWdVaW50NjQoZXh0cmFGaWVsZE5URlNWaWV3LCAyMCwgZ2V0VGltZU5URlMobGFzdEFjY2Vzc0RhdGUpIHx8IGxhc3RNb2RUaW1lTlRGUyk7XG5cdFx0XHRzZXRCaWdVaW50NjQoZXh0cmFGaWVsZE5URlNWaWV3LCAyOCwgZ2V0VGltZU5URlMoY3JlYXRpb25EYXRlKSB8fCBsYXN0TW9kVGltZU5URlMpO1xuXHRcdH0gY2F0Y2ggKGVycm9yKSB7XG5cdFx0XHRyYXdFeHRyYUZpZWxkTlRGUyA9IG5ldyBVaW50OEFycmF5KDApO1xuXHRcdH1cblx0fSBlbHNlIHtcblx0XHRyYXdFeHRyYUZpZWxkTlRGUyA9IHJhd0V4dHJhRmllbGRFeHRlbmRlZFRpbWVzdGFtcCA9IG5ldyBVaW50OEFycmF5KDApO1xuXHR9XG5cdGNvbnN0IGZpbGVFbnRyeSA9IHtcblx0XHR2ZXJzaW9uOiB2ZXJzaW9uIHx8IFZFUlNJT05fREVGTEFURSxcblx0XHR2ZXJzaW9uTWFkZUJ5LFxuXHRcdHppcDY0LFxuXHRcdGRpcmVjdG9yeTogQm9vbGVhbihkaXJlY3RvcnkpLFxuXHRcdGZpbGVuYW1lVVRGODogdHJ1ZSxcblx0XHRyYXdGaWxlbmFtZSxcblx0XHRjb21tZW50VVRGODogdHJ1ZSxcblx0XHRyYXdDb21tZW50LFxuXHRcdHJhd0V4dHJhRmllbGRaaXA2NDogemlwNjQgPyBuZXcgVWludDhBcnJheShFWFRSQUZJRUxEX0xFTkdUSF9aSVA2NCArIDQpIDogbmV3IFVpbnQ4QXJyYXkoMCksXG5cdFx0cmF3RXh0cmFGaWVsZEV4dGVuZGVkVGltZXN0YW1wLFxuXHRcdHJhd0V4dHJhRmllbGROVEZTLFxuXHRcdHJhd0V4dHJhRmllbGRBRVMsXG5cdFx0cmF3RXh0cmFGaWVsZCxcblx0XHRleHRlbmRlZFRpbWVzdGFtcCxcblx0XHRtc0Rvc0NvbXBhdGlibGUsXG5cdFx0aW50ZXJuYWxGaWxlQXR0cmlidXRlLFxuXHRcdGV4dGVybmFsRmlsZUF0dHJpYnV0ZVxuXHR9O1xuXHRsZXQgdW5jb21wcmVzc2VkU2l6ZSA9IGZpbGVFbnRyeS51bmNvbXByZXNzZWRTaXplID0gMDtcblx0bGV0IGJpdEZsYWcgPSBCSVRGTEFHX0xBTkdfRU5DT0RJTkdfRkxBRztcblx0aWYgKGRhdGFEZXNjcmlwdG9yKSB7XG5cdFx0Yml0RmxhZyA9IGJpdEZsYWcgfCBCSVRGTEFHX0RBVEFfREVTQ1JJUFRPUjtcblx0fVxuXHRsZXQgY29tcHJlc3Npb25NZXRob2QgPSBDT01QUkVTU0lPTl9NRVRIT0RfU1RPUkU7XG5cdGlmIChjb21wcmVzc2VkKSB7XG5cdFx0Y29tcHJlc3Npb25NZXRob2QgPSBDT01QUkVTU0lPTl9NRVRIT0RfREVGTEFURTtcblx0fVxuXHRpZiAoemlwNjQpIHtcblx0XHRmaWxlRW50cnkudmVyc2lvbiA9IGZpbGVFbnRyeS52ZXJzaW9uID4gVkVSU0lPTl9aSVA2NCA/IGZpbGVFbnRyeS52ZXJzaW9uIDogVkVSU0lPTl9aSVA2NDtcblx0fVxuXHRpZiAoZW5jcnlwdGVkKSB7XG5cdFx0Yml0RmxhZyA9IGJpdEZsYWcgfCBCSVRGTEFHX0VOQ1JZUFRFRDtcblx0XHRpZiAoIXppcENyeXB0bykge1xuXHRcdFx0ZmlsZUVudHJ5LnZlcnNpb24gPSBmaWxlRW50cnkudmVyc2lvbiA+IFZFUlNJT05fQUVTID8gZmlsZUVudHJ5LnZlcnNpb24gOiBWRVJTSU9OX0FFUztcblx0XHRcdGNvbXByZXNzaW9uTWV0aG9kID0gQ09NUFJFU1NJT05fTUVUSE9EX0FFUztcblx0XHRcdGlmIChjb21wcmVzc2VkKSB7XG5cdFx0XHRcdGZpbGVFbnRyeS5yYXdFeHRyYUZpZWxkQUVTWzldID0gQ09NUFJFU1NJT05fTUVUSE9EX0RFRkxBVEU7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cdGZpbGVFbnRyeS5jb21wcmVzc2lvbk1ldGhvZCA9IGNvbXByZXNzaW9uTWV0aG9kO1xuXHRjb25zdCBoZWFkZXJBcnJheSA9IGZpbGVFbnRyeS5oZWFkZXJBcnJheSA9IG5ldyBVaW50OEFycmF5KDI2KTtcblx0Y29uc3QgaGVhZGVyVmlldyA9IGdldERhdGFWaWV3KGhlYWRlckFycmF5KTtcblx0c2V0VWludDE2KGhlYWRlclZpZXcsIDAsIGZpbGVFbnRyeS52ZXJzaW9uKTtcblx0c2V0VWludDE2KGhlYWRlclZpZXcsIDIsIGJpdEZsYWcpO1xuXHRzZXRVaW50MTYoaGVhZGVyVmlldywgNCwgY29tcHJlc3Npb25NZXRob2QpO1xuXHRjb25zdCBkYXRlQXJyYXkgPSBuZXcgVWludDMyQXJyYXkoMSk7XG5cdGNvbnN0IGRhdGVWaWV3ID0gZ2V0RGF0YVZpZXcoZGF0ZUFycmF5KTtcblx0bGV0IGxhc3RNb2REYXRlO1xuXHRpZiAob3B0aW9ucy5sYXN0TW9kRGF0ZSA8IE1JTl9EQVRFKSB7XG5cdFx0bGFzdE1vZERhdGUgPSBNSU5fREFURTtcblx0fSBlbHNlIGlmIChvcHRpb25zLmxhc3RNb2REYXRlID4gTUFYX0RBVEUpIHtcblx0XHRsYXN0TW9kRGF0ZSA9IE1BWF9EQVRFO1xuXHR9IGVsc2Uge1xuXHRcdGxhc3RNb2REYXRlID0gb3B0aW9ucy5sYXN0TW9kRGF0ZTtcblx0fVxuXHRzZXRVaW50MTYoZGF0ZVZpZXcsIDAsICgoKGxhc3RNb2REYXRlLmdldEhvdXJzKCkgPDwgNikgfCBsYXN0TW9kRGF0ZS5nZXRNaW51dGVzKCkpIDw8IDUpIHwgbGFzdE1vZERhdGUuZ2V0U2Vjb25kcygpIC8gMik7XG5cdHNldFVpbnQxNihkYXRlVmlldywgMiwgKCgoKGxhc3RNb2REYXRlLmdldEZ1bGxZZWFyKCkgLSAxOTgwKSA8PCA0KSB8IChsYXN0TW9kRGF0ZS5nZXRNb250aCgpICsgMSkpIDw8IDUpIHwgbGFzdE1vZERhdGUuZ2V0RGF0ZSgpKTtcblx0Y29uc3QgcmF3TGFzdE1vZERhdGUgPSBkYXRlQXJyYXlbMF07XG5cdHNldFVpbnQzMihoZWFkZXJWaWV3LCA2LCByYXdMYXN0TW9kRGF0ZSk7XG5cdHNldFVpbnQxNihoZWFkZXJWaWV3LCAyMiwgcmF3RmlsZW5hbWUubGVuZ3RoKTtcblx0Y29uc3QgZXh0cmFGaWVsZExlbmd0aCA9IHJhd0V4dHJhRmllbGRBRVMubGVuZ3RoICsgcmF3RXh0cmFGaWVsZEV4dGVuZGVkVGltZXN0YW1wLmxlbmd0aCArIHJhd0V4dHJhRmllbGROVEZTLmxlbmd0aCArIGZpbGVFbnRyeS5yYXdFeHRyYUZpZWxkLmxlbmd0aDtcblx0c2V0VWludDE2KGhlYWRlclZpZXcsIDI0LCBleHRyYUZpZWxkTGVuZ3RoKTtcblx0Y29uc3QgbG9jYWxIZWFkZXJBcnJheSA9IG5ldyBVaW50OEFycmF5KDMwICsgcmF3RmlsZW5hbWUubGVuZ3RoICsgZXh0cmFGaWVsZExlbmd0aCk7XG5cdGNvbnN0IGxvY2FsSGVhZGVyVmlldyA9IGdldERhdGFWaWV3KGxvY2FsSGVhZGVyQXJyYXkpO1xuXHRzZXRVaW50MzIobG9jYWxIZWFkZXJWaWV3LCAwLCBMT0NBTF9GSUxFX0hFQURFUl9TSUdOQVRVUkUpO1xuXHRhcnJheVNldChsb2NhbEhlYWRlckFycmF5LCBoZWFkZXJBcnJheSwgNCk7XG5cdGFycmF5U2V0KGxvY2FsSGVhZGVyQXJyYXksIHJhd0ZpbGVuYW1lLCAzMCk7XG5cdGFycmF5U2V0KGxvY2FsSGVhZGVyQXJyYXksIHJhd0V4dHJhRmllbGRBRVMsIDMwICsgcmF3RmlsZW5hbWUubGVuZ3RoKTtcblx0YXJyYXlTZXQobG9jYWxIZWFkZXJBcnJheSwgcmF3RXh0cmFGaWVsZEV4dGVuZGVkVGltZXN0YW1wLCAzMCArIHJhd0ZpbGVuYW1lLmxlbmd0aCArIHJhd0V4dHJhRmllbGRBRVMubGVuZ3RoKTtcblx0YXJyYXlTZXQobG9jYWxIZWFkZXJBcnJheSwgcmF3RXh0cmFGaWVsZE5URlMsIDMwICsgcmF3RmlsZW5hbWUubGVuZ3RoICsgcmF3RXh0cmFGaWVsZEFFUy5sZW5ndGggKyByYXdFeHRyYUZpZWxkRXh0ZW5kZWRUaW1lc3RhbXAubGVuZ3RoKTtcblx0YXJyYXlTZXQobG9jYWxIZWFkZXJBcnJheSwgZmlsZUVudHJ5LnJhd0V4dHJhRmllbGQsIDMwICsgcmF3RmlsZW5hbWUubGVuZ3RoICsgcmF3RXh0cmFGaWVsZEFFUy5sZW5ndGggKyByYXdFeHRyYUZpZWxkRXh0ZW5kZWRUaW1lc3RhbXAubGVuZ3RoICsgcmF3RXh0cmFGaWVsZE5URlMubGVuZ3RoKTtcblx0bGV0IHJlc3VsdDtcblx0bGV0IGNvbXByZXNzZWRTaXplID0gMDtcblx0aWYgKHJlYWRlcikge1xuXHRcdHVuY29tcHJlc3NlZFNpemUgPSBmaWxlRW50cnkudW5jb21wcmVzc2VkU2l6ZSA9IHJlYWRlci5zaXplO1xuXHRcdGNvbnN0IGNvZGVjID0gYXdhaXQgY3JlYXRlQ29kZWMoY29uZmlnLkRlZmxhdGUsIHtcblx0XHRcdGNvZGVjVHlwZTogQ09ERUNfREVGTEFURSxcblx0XHRcdGxldmVsLFxuXHRcdFx0cGFzc3dvcmQsXG5cdFx0XHRlbmNyeXB0aW9uU3RyZW5ndGgsXG5cdFx0XHR6aXBDcnlwdG86IGVuY3J5cHRlZCAmJiB6aXBDcnlwdG8sXG5cdFx0XHRwYXNzd29yZFZlcmlmaWNhdGlvbjogZW5jcnlwdGVkICYmIHppcENyeXB0byAmJiAocmF3TGFzdE1vZERhdGUgPj4gOCkgJiAweEZGLFxuXHRcdFx0c2lnbmVkOiB0cnVlLFxuXHRcdFx0Y29tcHJlc3NlZCxcblx0XHRcdGVuY3J5cHRlZCxcblx0XHRcdHVzZVdlYldvcmtlcnNcblx0XHR9LCBjb25maWcpO1xuXHRcdGF3YWl0IHdyaXRlci53cml0ZVVpbnQ4QXJyYXkobG9jYWxIZWFkZXJBcnJheSk7XG5cdFx0ZmlsZUVudHJ5LmRhdGFXcml0dGVuID0gdHJ1ZTtcblx0XHRyZXN1bHQgPSBhd2FpdCBwcm9jZXNzRGF0YShjb2RlYywgcmVhZGVyLCB3cml0ZXIsIDAsIHVuY29tcHJlc3NlZFNpemUsIGNvbmZpZywgeyBvbnByb2dyZXNzLCBzaWduYWwgfSk7XG5cdFx0Y29tcHJlc3NlZFNpemUgPSByZXN1bHQubGVuZ3RoO1xuXHR9IGVsc2Uge1xuXHRcdGF3YWl0IHdyaXRlci53cml0ZVVpbnQ4QXJyYXkobG9jYWxIZWFkZXJBcnJheSk7XG5cdFx0ZmlsZUVudHJ5LmRhdGFXcml0dGVuID0gdHJ1ZTtcblx0fVxuXHRsZXQgZGF0YURlc2NyaXB0b3JBcnJheSA9IG5ldyBVaW50OEFycmF5KDApO1xuXHRsZXQgZGF0YURlc2NyaXB0b3JWaWV3O1xuXHRpZiAoZGF0YURlc2NyaXB0b3IpIHtcblx0XHRkYXRhRGVzY3JpcHRvckFycmF5ID0gbmV3IFVpbnQ4QXJyYXkoemlwNjQgPyAyNCA6IDE2KTtcblx0XHRkYXRhRGVzY3JpcHRvclZpZXcgPSBnZXREYXRhVmlldyhkYXRhRGVzY3JpcHRvckFycmF5KTtcblx0XHRzZXRVaW50MzIoZGF0YURlc2NyaXB0b3JWaWV3LCAwLCBEQVRBX0RFU0NSSVBUT1JfUkVDT1JEX1NJR05BVFVSRSk7XG5cdH1cblx0aWYgKHJlYWRlcikge1xuXHRcdGNvbnN0IHNpZ25hdHVyZSA9IHJlc3VsdC5zaWduYXR1cmU7XG5cdFx0aWYgKCghZW5jcnlwdGVkIHx8IHppcENyeXB0bykgJiYgc2lnbmF0dXJlICE9PSB1bmRlZmluZWQpIHtcblx0XHRcdHNldFVpbnQzMihoZWFkZXJWaWV3LCAxMCwgc2lnbmF0dXJlKTtcblx0XHRcdGZpbGVFbnRyeS5zaWduYXR1cmUgPSBzaWduYXR1cmU7XG5cdFx0XHRpZiAoZGF0YURlc2NyaXB0b3IpIHtcblx0XHRcdFx0c2V0VWludDMyKGRhdGFEZXNjcmlwdG9yVmlldywgNCwgc2lnbmF0dXJlKTtcblx0XHRcdH1cblx0XHR9XG5cdFx0aWYgKHppcDY0KSB7XG5cdFx0XHRjb25zdCByYXdFeHRyYUZpZWxkWmlwNjRWaWV3ID0gZ2V0RGF0YVZpZXcoZmlsZUVudHJ5LnJhd0V4dHJhRmllbGRaaXA2NCk7XG5cdFx0XHRzZXRVaW50MTYocmF3RXh0cmFGaWVsZFppcDY0VmlldywgMCwgRVhUUkFGSUVMRF9UWVBFX1pJUDY0KTtcblx0XHRcdHNldFVpbnQxNihyYXdFeHRyYUZpZWxkWmlwNjRWaWV3LCAyLCBFWFRSQUZJRUxEX0xFTkdUSF9aSVA2NCk7XG5cdFx0XHRzZXRVaW50MzIoaGVhZGVyVmlldywgMTQsIE1BWF8zMl9CSVRTKTtcblx0XHRcdHNldEJpZ1VpbnQ2NChyYXdFeHRyYUZpZWxkWmlwNjRWaWV3LCAxMiwgQmlnSW50KGNvbXByZXNzZWRTaXplKSk7XG5cdFx0XHRzZXRVaW50MzIoaGVhZGVyVmlldywgMTgsIE1BWF8zMl9CSVRTKTtcblx0XHRcdHNldEJpZ1VpbnQ2NChyYXdFeHRyYUZpZWxkWmlwNjRWaWV3LCA0LCBCaWdJbnQodW5jb21wcmVzc2VkU2l6ZSkpO1xuXHRcdFx0aWYgKGRhdGFEZXNjcmlwdG9yKSB7XG5cdFx0XHRcdHNldEJpZ1VpbnQ2NChkYXRhRGVzY3JpcHRvclZpZXcsIDgsIEJpZ0ludChjb21wcmVzc2VkU2l6ZSkpO1xuXHRcdFx0XHRzZXRCaWdVaW50NjQoZGF0YURlc2NyaXB0b3JWaWV3LCAxNiwgQmlnSW50KHVuY29tcHJlc3NlZFNpemUpKTtcblx0XHRcdH1cblx0XHR9IGVsc2Uge1xuXHRcdFx0c2V0VWludDMyKGhlYWRlclZpZXcsIDE0LCBjb21wcmVzc2VkU2l6ZSk7XG5cdFx0XHRzZXRVaW50MzIoaGVhZGVyVmlldywgMTgsIHVuY29tcHJlc3NlZFNpemUpO1xuXHRcdFx0aWYgKGRhdGFEZXNjcmlwdG9yKSB7XG5cdFx0XHRcdHNldFVpbnQzMihkYXRhRGVzY3JpcHRvclZpZXcsIDgsIGNvbXByZXNzZWRTaXplKTtcblx0XHRcdFx0c2V0VWludDMyKGRhdGFEZXNjcmlwdG9yVmlldywgMTIsIHVuY29tcHJlc3NlZFNpemUpO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXHRpZiAoZGF0YURlc2NyaXB0b3IpIHtcblx0XHRhd2FpdCB3cml0ZXIud3JpdGVVaW50OEFycmF5KGRhdGFEZXNjcmlwdG9yQXJyYXkpO1xuXHR9XG5cdGNvbnN0IGxlbmd0aCA9IGxvY2FsSGVhZGVyQXJyYXkubGVuZ3RoICsgY29tcHJlc3NlZFNpemUgKyBkYXRhRGVzY3JpcHRvckFycmF5Lmxlbmd0aDtcblx0T2JqZWN0LmFzc2lnbihmaWxlRW50cnksIHsgY29tcHJlc3NlZFNpemUsIGxhc3RNb2REYXRlLCByYXdMYXN0TW9kRGF0ZSwgY3JlYXRpb25EYXRlLCBsYXN0QWNjZXNzRGF0ZSwgZW5jcnlwdGVkLCBsZW5ndGggfSk7XG5cdHJldHVybiBmaWxlRW50cnk7XG59XG5cbmFzeW5jIGZ1bmN0aW9uIGNsb3NlRmlsZSh6aXBXcml0ZXIsIGNvbW1lbnQsIG9wdGlvbnMpIHtcblx0Y29uc3Qgd3JpdGVyID0gemlwV3JpdGVyLndyaXRlcjtcblx0Y29uc3QgZmlsZXMgPSB6aXBXcml0ZXIuZmlsZXM7XG5cdGxldCBvZmZzZXQgPSAwO1xuXHRsZXQgZGlyZWN0b3J5RGF0YUxlbmd0aCA9IDA7XG5cdGxldCBkaXJlY3RvcnlPZmZzZXQgPSB6aXBXcml0ZXIub2Zmc2V0O1xuXHRsZXQgZmlsZXNMZW5ndGggPSBmaWxlcy5zaXplO1xuXHRmb3IgKGNvbnN0IFssIGZpbGVFbnRyeV0gb2YgZmlsZXMpIHtcblx0XHRkaXJlY3RvcnlEYXRhTGVuZ3RoICs9IDQ2ICtcblx0XHRcdGZpbGVFbnRyeS5yYXdGaWxlbmFtZS5sZW5ndGggK1xuXHRcdFx0ZmlsZUVudHJ5LnJhd0NvbW1lbnQubGVuZ3RoICtcblx0XHRcdGZpbGVFbnRyeS5yYXdFeHRyYUZpZWxkWmlwNjQubGVuZ3RoICtcblx0XHRcdGZpbGVFbnRyeS5yYXdFeHRyYUZpZWxkQUVTLmxlbmd0aCArXG5cdFx0XHRmaWxlRW50cnkucmF3RXh0cmFGaWVsZEV4dGVuZGVkVGltZXN0YW1wLmxlbmd0aCArXG5cdFx0XHRmaWxlRW50cnkucmF3RXh0cmFGaWVsZE5URlMubGVuZ3RoICtcblx0XHRcdGZpbGVFbnRyeS5yYXdFeHRyYUZpZWxkLmxlbmd0aDtcblx0fVxuXHRsZXQgemlwNjQgPSBvcHRpb25zLnppcDY0IHx8IHppcFdyaXRlci5vcHRpb25zLnppcDY0IHx8IGZhbHNlO1xuXHRpZiAoZGlyZWN0b3J5T2Zmc2V0ID49IE1BWF8zMl9CSVRTIHx8IGRpcmVjdG9yeURhdGFMZW5ndGggPj0gTUFYXzMyX0JJVFMgfHwgZmlsZXNMZW5ndGggPj0gTUFYXzE2X0JJVFMpIHtcblx0XHRpZiAob3B0aW9ucy56aXA2NCA9PT0gZmFsc2UgfHwgemlwV3JpdGVyLm9wdGlvbnMuemlwNjQgPT09IGZhbHNlKSB7XG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoRVJSX1VOU1VQUE9SVEVEX0ZPUk1BVCk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHppcDY0ID0gdHJ1ZTtcblx0XHR9XG5cdH1cblx0Y29uc3QgZGlyZWN0b3J5QXJyYXkgPSBuZXcgVWludDhBcnJheShkaXJlY3RvcnlEYXRhTGVuZ3RoICsgKHppcDY0ID8gWklQNjRfRU5EX09GX0NFTlRSQUxfRElSX1RPVEFMX0xFTkdUSCA6IEVORF9PRl9DRU5UUkFMX0RJUl9MRU5HVEgpKTtcblx0Y29uc3QgZGlyZWN0b3J5VmlldyA9IGdldERhdGFWaWV3KGRpcmVjdG9yeUFycmF5KTtcblx0aWYgKGNvbW1lbnQgJiYgY29tbWVudC5sZW5ndGgpIHtcblx0XHRpZiAoY29tbWVudC5sZW5ndGggPD0gTUFYXzE2X0JJVFMpIHtcblx0XHRcdHNldFVpbnQxNihkaXJlY3RvcnlWaWV3LCBvZmZzZXQgKyAyMCwgY29tbWVudC5sZW5ndGgpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoRVJSX0lOVkFMSURfQ09NTUVOVCk7XG5cdFx0fVxuXHR9XG5cdGZvciAoY29uc3QgW2luZGV4RmlsZUVudHJ5LCBmaWxlRW50cnldIG9mIEFycmF5LmZyb20oZmlsZXMudmFsdWVzKCkpLmVudHJpZXMoKSkge1xuXHRcdGNvbnN0IHtcblx0XHRcdHJhd0ZpbGVuYW1lLFxuXHRcdFx0cmF3RXh0cmFGaWVsZFppcDY0LFxuXHRcdFx0cmF3RXh0cmFGaWVsZEFFUyxcblx0XHRcdHJhd0V4dHJhRmllbGQsXG5cdFx0XHRyYXdDb21tZW50LFxuXHRcdFx0dmVyc2lvbk1hZGVCeSxcblx0XHRcdGhlYWRlckFycmF5LFxuXHRcdFx0ZGlyZWN0b3J5LFxuXHRcdFx0emlwNjQsXG5cdFx0XHRtc0Rvc0NvbXBhdGlibGUsXG5cdFx0XHRpbnRlcm5hbEZpbGVBdHRyaWJ1dGUsXG5cdFx0XHRleHRlcm5hbEZpbGVBdHRyaWJ1dGVcblx0XHR9ID0gZmlsZUVudHJ5O1xuXHRcdGxldCByYXdFeHRyYUZpZWxkRXh0ZW5kZWRUaW1lc3RhbXA7XG5cdFx0bGV0IHJhd0V4dHJhRmllbGROVEZTO1xuXHRcdGlmIChmaWxlRW50cnkuZXh0ZW5kZWRUaW1lc3RhbXApIHtcblx0XHRcdHJhd0V4dHJhRmllbGROVEZTID0gZmlsZUVudHJ5LnJhd0V4dHJhRmllbGROVEZTO1xuXHRcdFx0cmF3RXh0cmFGaWVsZEV4dGVuZGVkVGltZXN0YW1wID0gbmV3IFVpbnQ4QXJyYXkoOSk7XG5cdFx0XHRjb25zdCBleHRyYUZpZWxkRXh0ZW5kZWRUaW1lc3RhbXBWaWV3ID0gZ2V0RGF0YVZpZXcocmF3RXh0cmFGaWVsZEV4dGVuZGVkVGltZXN0YW1wKTtcblx0XHRcdHNldFVpbnQxNihleHRyYUZpZWxkRXh0ZW5kZWRUaW1lc3RhbXBWaWV3LCAwLCBFWFRSQUZJRUxEX1RZUEVfRVhURU5ERURfVElNRVNUQU1QKTtcblx0XHRcdHNldFVpbnQxNihleHRyYUZpZWxkRXh0ZW5kZWRUaW1lc3RhbXBWaWV3LCAyLCByYXdFeHRyYUZpZWxkRXh0ZW5kZWRUaW1lc3RhbXAubGVuZ3RoIC0gNCk7XG5cdFx0XHRzZXRVaW50OChleHRyYUZpZWxkRXh0ZW5kZWRUaW1lc3RhbXBWaWV3LCA0LCAweDEpO1xuXHRcdFx0c2V0VWludDMyKGV4dHJhRmllbGRFeHRlbmRlZFRpbWVzdGFtcFZpZXcsIDUsIE1hdGguZmxvb3IoZmlsZUVudHJ5Lmxhc3RNb2REYXRlLmdldFRpbWUoKSAvIDEwMDApKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0cmF3RXh0cmFGaWVsZE5URlMgPSByYXdFeHRyYUZpZWxkRXh0ZW5kZWRUaW1lc3RhbXAgPSBuZXcgVWludDhBcnJheSgwKTtcblx0XHR9XG5cdFx0Y29uc3QgZXh0cmFGaWVsZExlbmd0aCA9IHJhd0V4dHJhRmllbGRaaXA2NC5sZW5ndGggKyByYXdFeHRyYUZpZWxkQUVTLmxlbmd0aCArIHJhd0V4dHJhRmllbGRFeHRlbmRlZFRpbWVzdGFtcC5sZW5ndGggKyByYXdFeHRyYUZpZWxkTlRGUy5sZW5ndGggKyByYXdFeHRyYUZpZWxkLmxlbmd0aDtcblx0XHRzZXRVaW50MzIoZGlyZWN0b3J5Vmlldywgb2Zmc2V0LCBDRU5UUkFMX0ZJTEVfSEVBREVSX1NJR05BVFVSRSk7XG5cdFx0c2V0VWludDE2KGRpcmVjdG9yeVZpZXcsIG9mZnNldCArIDQsIHZlcnNpb25NYWRlQnkpO1xuXHRcdGFycmF5U2V0KGRpcmVjdG9yeUFycmF5LCBoZWFkZXJBcnJheSwgb2Zmc2V0ICsgNik7XG5cdFx0c2V0VWludDE2KGRpcmVjdG9yeVZpZXcsIG9mZnNldCArIDMwLCBleHRyYUZpZWxkTGVuZ3RoKTtcblx0XHRzZXRVaW50MTYoZGlyZWN0b3J5Vmlldywgb2Zmc2V0ICsgMzIsIHJhd0NvbW1lbnQubGVuZ3RoKTtcblx0XHRzZXRVaW50MzIoZGlyZWN0b3J5Vmlldywgb2Zmc2V0ICsgMzQsIGludGVybmFsRmlsZUF0dHJpYnV0ZSk7XG5cdFx0aWYgKGV4dGVybmFsRmlsZUF0dHJpYnV0ZSkge1xuXHRcdFx0c2V0VWludDMyKGRpcmVjdG9yeVZpZXcsIG9mZnNldCArIDM4LCBleHRlcm5hbEZpbGVBdHRyaWJ1dGUpO1xuXHRcdH0gZWxzZSBpZiAoZGlyZWN0b3J5ICYmIG1zRG9zQ29tcGF0aWJsZSkge1xuXHRcdFx0c2V0VWludDgoZGlyZWN0b3J5Vmlldywgb2Zmc2V0ICsgMzgsIEZJTEVfQVRUUl9NU0RPU19ESVJfTUFTSyk7XG5cdFx0fVxuXHRcdGlmICh6aXA2NCkge1xuXHRcdFx0c2V0VWludDMyKGRpcmVjdG9yeVZpZXcsIG9mZnNldCArIDQyLCBNQVhfMzJfQklUUyk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHNldFVpbnQzMihkaXJlY3RvcnlWaWV3LCBvZmZzZXQgKyA0MiwgZmlsZUVudHJ5Lm9mZnNldCk7XG5cdFx0fVxuXHRcdGFycmF5U2V0KGRpcmVjdG9yeUFycmF5LCByYXdGaWxlbmFtZSwgb2Zmc2V0ICsgNDYpO1xuXHRcdGFycmF5U2V0KGRpcmVjdG9yeUFycmF5LCByYXdFeHRyYUZpZWxkWmlwNjQsIG9mZnNldCArIDQ2ICsgcmF3RmlsZW5hbWUubGVuZ3RoKTtcblx0XHRhcnJheVNldChkaXJlY3RvcnlBcnJheSwgcmF3RXh0cmFGaWVsZEFFUywgb2Zmc2V0ICsgNDYgKyByYXdGaWxlbmFtZS5sZW5ndGggKyByYXdFeHRyYUZpZWxkWmlwNjQubGVuZ3RoKTtcblx0XHRhcnJheVNldChkaXJlY3RvcnlBcnJheSwgcmF3RXh0cmFGaWVsZEV4dGVuZGVkVGltZXN0YW1wLCBvZmZzZXQgKyA0NiArIHJhd0ZpbGVuYW1lLmxlbmd0aCArIHJhd0V4dHJhRmllbGRaaXA2NC5sZW5ndGggKyByYXdFeHRyYUZpZWxkQUVTLmxlbmd0aCk7XG5cdFx0YXJyYXlTZXQoZGlyZWN0b3J5QXJyYXksIHJhd0V4dHJhRmllbGROVEZTLCBvZmZzZXQgKyA0NiArIHJhd0ZpbGVuYW1lLmxlbmd0aCArIHJhd0V4dHJhRmllbGRaaXA2NC5sZW5ndGggKyByYXdFeHRyYUZpZWxkQUVTLmxlbmd0aCArIHJhd0V4dHJhRmllbGRFeHRlbmRlZFRpbWVzdGFtcC5sZW5ndGgpO1xuXHRcdGFycmF5U2V0KGRpcmVjdG9yeUFycmF5LCByYXdFeHRyYUZpZWxkLCBvZmZzZXQgKyA0NiArIHJhd0ZpbGVuYW1lLmxlbmd0aCArIHJhd0V4dHJhRmllbGRaaXA2NC5sZW5ndGggKyByYXdFeHRyYUZpZWxkQUVTLmxlbmd0aCArIHJhd0V4dHJhRmllbGRFeHRlbmRlZFRpbWVzdGFtcC5sZW5ndGggKyByYXdFeHRyYUZpZWxkTlRGUy5sZW5ndGgpO1xuXHRcdGFycmF5U2V0KGRpcmVjdG9yeUFycmF5LCByYXdDb21tZW50LCBvZmZzZXQgKyA0NiArIHJhd0ZpbGVuYW1lLmxlbmd0aCArIGV4dHJhRmllbGRMZW5ndGgpO1xuXHRcdG9mZnNldCArPSA0NiArIHJhd0ZpbGVuYW1lLmxlbmd0aCArIGV4dHJhRmllbGRMZW5ndGggKyByYXdDb21tZW50Lmxlbmd0aDtcblx0XHRpZiAob3B0aW9ucy5vbnByb2dyZXNzKSB7XG5cdFx0XHR0cnkge1xuXHRcdFx0XHRvcHRpb25zLm9ucHJvZ3Jlc3MoaW5kZXhGaWxlRW50cnkgKyAxLCBmaWxlcy5zaXplLCBuZXcgRW50cnkoZmlsZUVudHJ5KSk7XG5cdFx0XHR9IGNhdGNoIChlcnJvcikge1xuXHRcdFx0XHQvLyBpZ25vcmVkXG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cdGlmICh6aXA2NCkge1xuXHRcdHNldFVpbnQzMihkaXJlY3RvcnlWaWV3LCBvZmZzZXQsIFpJUDY0X0VORF9PRl9DRU5UUkFMX0RJUl9TSUdOQVRVUkUpO1xuXHRcdHNldEJpZ1VpbnQ2NChkaXJlY3RvcnlWaWV3LCBvZmZzZXQgKyA0LCBCaWdJbnQoNDQpKTtcblx0XHRzZXRVaW50MTYoZGlyZWN0b3J5Vmlldywgb2Zmc2V0ICsgMTIsIDQ1KTtcblx0XHRzZXRVaW50MTYoZGlyZWN0b3J5Vmlldywgb2Zmc2V0ICsgMTQsIDQ1KTtcblx0XHRzZXRCaWdVaW50NjQoZGlyZWN0b3J5Vmlldywgb2Zmc2V0ICsgMjQsIEJpZ0ludChmaWxlc0xlbmd0aCkpO1xuXHRcdHNldEJpZ1VpbnQ2NChkaXJlY3RvcnlWaWV3LCBvZmZzZXQgKyAzMiwgQmlnSW50KGZpbGVzTGVuZ3RoKSk7XG5cdFx0c2V0QmlnVWludDY0KGRpcmVjdG9yeVZpZXcsIG9mZnNldCArIDQwLCBCaWdJbnQoZGlyZWN0b3J5RGF0YUxlbmd0aCkpO1xuXHRcdHNldEJpZ1VpbnQ2NChkaXJlY3RvcnlWaWV3LCBvZmZzZXQgKyA0OCwgQmlnSW50KGRpcmVjdG9yeU9mZnNldCkpO1xuXHRcdHNldFVpbnQzMihkaXJlY3RvcnlWaWV3LCBvZmZzZXQgKyA1NiwgWklQNjRfRU5EX09GX0NFTlRSQUxfRElSX0xPQ0FUT1JfU0lHTkFUVVJFKTtcblx0XHRzZXRCaWdVaW50NjQoZGlyZWN0b3J5Vmlldywgb2Zmc2V0ICsgNjQsIEJpZ0ludChkaXJlY3RvcnlPZmZzZXQpICsgQmlnSW50KGRpcmVjdG9yeURhdGFMZW5ndGgpKTtcblx0XHRzZXRVaW50MzIoZGlyZWN0b3J5Vmlldywgb2Zmc2V0ICsgNzIsIFpJUDY0X1RPVEFMX05VTUJFUl9PRl9ESVNLUyk7XG5cdFx0ZmlsZXNMZW5ndGggPSBNQVhfMTZfQklUUztcblx0XHRkaXJlY3RvcnlPZmZzZXQgPSBNQVhfMzJfQklUUztcblx0XHRkaXJlY3RvcnlEYXRhTGVuZ3RoID0gTUFYXzMyX0JJVFM7XG5cdFx0b2Zmc2V0ICs9IDc2O1xuXHR9XG5cdHNldFVpbnQzMihkaXJlY3RvcnlWaWV3LCBvZmZzZXQsIEVORF9PRl9DRU5UUkFMX0RJUl9TSUdOQVRVUkUpO1xuXHRzZXRVaW50MTYoZGlyZWN0b3J5Vmlldywgb2Zmc2V0ICsgOCwgZmlsZXNMZW5ndGgpO1xuXHRzZXRVaW50MTYoZGlyZWN0b3J5Vmlldywgb2Zmc2V0ICsgMTAsIGZpbGVzTGVuZ3RoKTtcblx0c2V0VWludDMyKGRpcmVjdG9yeVZpZXcsIG9mZnNldCArIDEyLCBkaXJlY3RvcnlEYXRhTGVuZ3RoKTtcblx0c2V0VWludDMyKGRpcmVjdG9yeVZpZXcsIG9mZnNldCArIDE2LCBkaXJlY3RvcnlPZmZzZXQpO1xuXHRhd2FpdCB3cml0ZXIud3JpdGVVaW50OEFycmF5KGRpcmVjdG9yeUFycmF5KTtcblx0aWYgKGNvbW1lbnQgJiYgY29tbWVudC5sZW5ndGgpIHtcblx0XHRhd2FpdCB3cml0ZXIud3JpdGVVaW50OEFycmF5KGNvbW1lbnQpO1xuXHR9XG59XG5cbmZ1bmN0aW9uIHNsaWNlQXNBcnJheUJ1ZmZlcihibG9iLCBzdGFydCwgZW5kKSB7XG5cdGNvbnN0IGZpbGVSZWFkZXIgPSBuZXcgRmlsZVJlYWRlcigpO1xuXHRyZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuXHRcdGZpbGVSZWFkZXIub25sb2FkID0gZXZlbnQgPT4gcmVzb2x2ZShldmVudC50YXJnZXQucmVzdWx0KTtcblx0XHRmaWxlUmVhZGVyLm9uZXJyb3IgPSAoKSA9PiByZWplY3QoZmlsZVJlYWRlci5lcnJvcik7XG5cdFx0ZmlsZVJlYWRlci5yZWFkQXNBcnJheUJ1ZmZlcihzdGFydCB8fCBlbmQgPyBibG9iLnNsaWNlKHN0YXJ0LCBlbmQpIDogYmxvYik7XG5cdH0pO1xufVxuXG5hc3luYyBmdW5jdGlvbiB3cml0ZUJsb2Iod3JpdGVyLCBibG9iLCBzdGFydCA9IDApIHtcblx0Y29uc3QgYmxvY2tTaXplID0gNTEyICogMTAyNCAqIDEwMjQ7XG5cdGF3YWl0IHdyaXRlU2xpY2UoKTtcblxuXHRhc3luYyBmdW5jdGlvbiB3cml0ZVNsaWNlKCkge1xuXHRcdGlmIChzdGFydCA8IGJsb2Iuc2l6ZSkge1xuXHRcdFx0Y29uc3QgYXJyYXlCdWZmZXIgPSBhd2FpdCBzbGljZUFzQXJyYXlCdWZmZXIoYmxvYiwgc3RhcnQsIHN0YXJ0ICsgYmxvY2tTaXplKTtcblx0XHRcdGF3YWl0IHdyaXRlci53cml0ZVVpbnQ4QXJyYXkobmV3IFVpbnQ4QXJyYXkoYXJyYXlCdWZmZXIpKTtcblx0XHRcdHN0YXJ0ICs9IGJsb2NrU2l6ZTtcblx0XHRcdGF3YWl0IHdyaXRlU2xpY2UoKTtcblx0XHR9XG5cdH1cbn1cblxuZnVuY3Rpb24gZ2V0VGltZU5URlMoZGF0ZSkge1xuXHRpZiAoZGF0ZSkge1xuXHRcdHJldHVybiAoKEJpZ0ludChkYXRlLmdldFRpbWUoKSkgKyBCaWdJbnQoMTE2NDQ0NzM2MDAwMDApKSAqIEJpZ0ludCgxMDAwMCkpO1xuXHR9XG59XG5cbmZ1bmN0aW9uIGdldE9wdGlvblZhbHVlKHppcFdyaXRlciwgb3B0aW9ucywgbmFtZSkge1xuXHRyZXR1cm4gb3B0aW9uc1tuYW1lXSA9PT0gdW5kZWZpbmVkID8gemlwV3JpdGVyLm9wdGlvbnNbbmFtZV0gOiBvcHRpb25zW25hbWVdO1xufVxuXG5mdW5jdGlvbiBnZXRNYXhpbXVtQ29tcHJlc3NlZFNpemUodW5jb21wcmVzc2VkU2l6ZSkge1xuXHRyZXR1cm4gdW5jb21wcmVzc2VkU2l6ZSArICg1ICogKE1hdGguZmxvb3IodW5jb21wcmVzc2VkU2l6ZSAvIDE2MzgzKSArIDEpKTtcbn1cblxuZnVuY3Rpb24gc2V0VWludDgodmlldywgb2Zmc2V0LCB2YWx1ZSkge1xuXHR2aWV3LnNldFVpbnQ4KG9mZnNldCwgdmFsdWUpO1xufVxuXG5mdW5jdGlvbiBzZXRVaW50MTYodmlldywgb2Zmc2V0LCB2YWx1ZSkge1xuXHR2aWV3LnNldFVpbnQxNihvZmZzZXQsIHZhbHVlLCB0cnVlKTtcbn1cblxuZnVuY3Rpb24gc2V0VWludDMyKHZpZXcsIG9mZnNldCwgdmFsdWUpIHtcblx0dmlldy5zZXRVaW50MzIob2Zmc2V0LCB2YWx1ZSwgdHJ1ZSk7XG59XG5cbmZ1bmN0aW9uIHNldEJpZ1VpbnQ2NCh2aWV3LCBvZmZzZXQsIHZhbHVlKSB7XG5cdHZpZXcuc2V0QmlnVWludDY0KG9mZnNldCwgdmFsdWUsIHRydWUpO1xufVxuXG5mdW5jdGlvbiBhcnJheVNldChhcnJheSwgdHlwZWRBcnJheSwgb2Zmc2V0KSB7XG5cdGFycmF5LnNldCh0eXBlZEFycmF5LCBvZmZzZXQpO1xufVxuXG5mdW5jdGlvbiBnZXREYXRhVmlldyhhcnJheSkge1xuXHRyZXR1cm4gbmV3IERhdGFWaWV3KGFycmF5LmJ1ZmZlcik7XG59XG5cbi8qXG4gQ29weXJpZ2h0IChjKSAyMDIxIEdpbGRhcyBMb3JtZWF1LiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuXG4gUmVkaXN0cmlidXRpb24gYW5kIHVzZSBpbiBzb3VyY2UgYW5kIGJpbmFyeSBmb3Jtcywgd2l0aCBvciB3aXRob3V0XG4gbW9kaWZpY2F0aW9uLCBhcmUgcGVybWl0dGVkIHByb3ZpZGVkIHRoYXQgdGhlIGZvbGxvd2luZyBjb25kaXRpb25zIGFyZSBtZXQ6XG5cbiAxLiBSZWRpc3RyaWJ1dGlvbnMgb2Ygc291cmNlIGNvZGUgbXVzdCByZXRhaW4gdGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UsXG4gdGhpcyBsaXN0IG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmcgZGlzY2xhaW1lci5cblxuIDIuIFJlZGlzdHJpYnV0aW9ucyBpbiBiaW5hcnkgZm9ybSBtdXN0IHJlcHJvZHVjZSB0aGUgYWJvdmUgY29weXJpZ2h0IFxuIG5vdGljZSwgdGhpcyBsaXN0IG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmcgZGlzY2xhaW1lciBpbiBcbiB0aGUgZG9jdW1lbnRhdGlvbiBhbmQvb3Igb3RoZXIgbWF0ZXJpYWxzIHByb3ZpZGVkIHdpdGggdGhlIGRpc3RyaWJ1dGlvbi5cblxuIDMuIFRoZSBuYW1lcyBvZiB0aGUgYXV0aG9ycyBtYXkgbm90IGJlIHVzZWQgdG8gZW5kb3JzZSBvciBwcm9tb3RlIHByb2R1Y3RzXG4gZGVyaXZlZCBmcm9tIHRoaXMgc29mdHdhcmUgd2l0aG91dCBzcGVjaWZpYyBwcmlvciB3cml0dGVuIHBlcm1pc3Npb24uXG5cbiBUSElTIFNPRlRXQVJFIElTIFBST1ZJREVEICcnQVMgSVMnJyBBTkQgQU5ZIEVYUFJFU1NFRCBPUiBJTVBMSUVEIFdBUlJBTlRJRVMsXG4gSU5DTFVESU5HLCBCVVQgTk9UIExJTUlURUQgVE8sIFRIRSBJTVBMSUVEIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZIEFORFxuIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFSRSBESVNDTEFJTUVELiBJTiBOTyBFVkVOVCBTSEFMTCBKQ1JBRlQsXG4gSU5DLiBPUiBBTlkgQ09OVFJJQlVUT1JTIFRPIFRISVMgU09GVFdBUkUgQkUgTElBQkxFIEZPUiBBTlkgRElSRUNULCBJTkRJUkVDVCxcbiBJTkNJREVOVEFMLCBTUEVDSUFMLCBFWEVNUExBUlksIE9SIENPTlNFUVVFTlRJQUwgREFNQUdFUyAoSU5DTFVESU5HLCBCVVQgTk9UXG4gTElNSVRFRCBUTywgUFJPQ1VSRU1FTlQgT0YgU1VCU1RJVFVURSBHT09EUyBPUiBTRVJWSUNFUzsgTE9TUyBPRiBVU0UsIERBVEEsXG4gT1IgUFJPRklUUzsgT1IgQlVTSU5FU1MgSU5URVJSVVBUSU9OKSBIT1dFVkVSIENBVVNFRCBBTkQgT04gQU5ZIFRIRU9SWSBPRlxuIExJQUJJTElUWSwgV0hFVEhFUiBJTiBDT05UUkFDVCwgU1RSSUNUIExJQUJJTElUWSwgT1IgVE9SVCAoSU5DTFVESU5HXG4gTkVHTElHRU5DRSBPUiBPVEhFUldJU0UpIEFSSVNJTkcgSU4gQU5ZIFdBWSBPVVQgT0YgVEhFIFVTRSBPRiBUSElTIFNPRlRXQVJFLFxuIEVWRU4gSUYgQURWSVNFRCBPRiBUSEUgUE9TU0lCSUxJVFkgT0YgU1VDSCBEQU1BR0UuXG4gKi9cblxuY29uZmlndXJlV2ViV29ya2VyKCk7XG5cbnZhciB6aXAgPSAvKiNfX1BVUkVfXyovT2JqZWN0LmZyZWV6ZSh7XG5cdF9fcHJvdG9fXzogbnVsbCxcblx0Z2V0TWltZVR5cGU6IGdldE1pbWVUeXBlLFxuXHRpbml0U2hpbUFzeW5jQ29kZWM6IHN0cmVhbUNvZGVjU2hpbSxcblx0dGVybWluYXRlV29ya2VyczogdGVybWluYXRlV29ya2Vycyxcblx0RVJSX0FCT1JUOiBFUlJfQUJPUlQsXG5cdGNvbmZpZ3VyZTogY29uZmlndXJlLFxuXHRSZWFkZXI6IFJlYWRlcixcblx0V3JpdGVyOiBXcml0ZXIsXG5cdFRleHRSZWFkZXI6IFRleHRSZWFkZXIsXG5cdFRleHRXcml0ZXI6IFRleHRXcml0ZXIsXG5cdERhdGE2NFVSSVJlYWRlcjogRGF0YTY0VVJJUmVhZGVyLFxuXHREYXRhNjRVUklXcml0ZXI6IERhdGE2NFVSSVdyaXRlcixcblx0QmxvYlJlYWRlcjogQmxvYlJlYWRlcixcblx0QmxvYldyaXRlcjogQmxvYldyaXRlcixcblx0VWludDhBcnJheVJlYWRlcjogVWludDhBcnJheVJlYWRlcixcblx0VWludDhBcnJheVdyaXRlcjogVWludDhBcnJheVdyaXRlcixcblx0SHR0cFJlYWRlcjogSHR0cFJlYWRlcixcblx0SHR0cFJhbmdlUmVhZGVyOiBIdHRwUmFuZ2VSZWFkZXIsXG5cdEVSUl9IVFRQX1JBTkdFOiBFUlJfSFRUUF9SQU5HRSxcblx0WmlwUmVhZGVyOiBaaXBSZWFkZXIsXG5cdEVSUl9CQURfRk9STUFUOiBFUlJfQkFEX0ZPUk1BVCxcblx0RVJSX0VPQ0RSX05PVF9GT1VORDogRVJSX0VPQ0RSX05PVF9GT1VORCxcblx0RVJSX0VPQ0RSX1pJUDY0X05PVF9GT1VORDogRVJSX0VPQ0RSX1pJUDY0X05PVF9GT1VORCxcblx0RVJSX0VPQ0RSX0xPQ0FUT1JfWklQNjRfTk9UX0ZPVU5EOiBFUlJfRU9DRFJfTE9DQVRPUl9aSVA2NF9OT1RfRk9VTkQsXG5cdEVSUl9DRU5UUkFMX0RJUkVDVE9SWV9OT1RfRk9VTkQ6IEVSUl9DRU5UUkFMX0RJUkVDVE9SWV9OT1RfRk9VTkQsXG5cdEVSUl9MT0NBTF9GSUxFX0hFQURFUl9OT1RfRk9VTkQ6IEVSUl9MT0NBTF9GSUxFX0hFQURFUl9OT1RfRk9VTkQsXG5cdEVSUl9FWFRSQUZJRUxEX1pJUDY0X05PVF9GT1VORDogRVJSX0VYVFJBRklFTERfWklQNjRfTk9UX0ZPVU5ELFxuXHRFUlJfRU5DUllQVEVEOiBFUlJfRU5DUllQVEVELFxuXHRFUlJfVU5TVVBQT1JURURfRU5DUllQVElPTjogRVJSX1VOU1VQUE9SVEVEX0VOQ1JZUFRJT04sXG5cdEVSUl9VTlNVUFBPUlRFRF9DT01QUkVTU0lPTjogRVJSX1VOU1VQUE9SVEVEX0NPTVBSRVNTSU9OLFxuXHRFUlJfSU5WQUxJRF9TSUdOQVRVUkU6IEVSUl9JTlZBTElEX1NJR05BVFVSRSxcblx0RVJSX0lOVkFMSURfUEFTU1dPUkQ6IEVSUl9JTlZBTElEX1BBU1NXT1JELFxuXHRaaXBXcml0ZXI6IFppcFdyaXRlcixcblx0RVJSX0RVUExJQ0FURURfTkFNRTogRVJSX0RVUExJQ0FURURfTkFNRSxcblx0RVJSX0lOVkFMSURfQ09NTUVOVDogRVJSX0lOVkFMSURfQ09NTUVOVCxcblx0RVJSX0lOVkFMSURfRU5UUllfTkFNRTogRVJSX0lOVkFMSURfRU5UUllfTkFNRSxcblx0RVJSX0lOVkFMSURfRU5UUllfQ09NTUVOVDogRVJSX0lOVkFMSURfRU5UUllfQ09NTUVOVCxcblx0RVJSX0lOVkFMSURfVkVSU0lPTjogRVJSX0lOVkFMSURfVkVSU0lPTixcblx0RVJSX0lOVkFMSURfRVhUUkFGSUVMRF9UWVBFOiBFUlJfSU5WQUxJRF9FWFRSQUZJRUxEX1RZUEUsXG5cdEVSUl9JTlZBTElEX0VYVFJBRklFTERfREFUQTogRVJSX0lOVkFMSURfRVhUUkFGSUVMRF9EQVRBLFxuXHRFUlJfSU5WQUxJRF9FTkNSWVBUSU9OX1NUUkVOR1RIOiBFUlJfSU5WQUxJRF9FTkNSWVBUSU9OX1NUUkVOR1RILFxuXHRFUlJfVU5TVVBQT1JURURfRk9STUFUOiBFUlJfVU5TVVBQT1JURURfRk9STUFUXG59KTtcblxuZXhwb3J0IHsgemlwIGFzIGRlZmF1bHQgfTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///92678\n')}}]);