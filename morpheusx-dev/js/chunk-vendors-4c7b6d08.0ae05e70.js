"use strict";(self["webpackChunkvue3_webpack5"]=self["webpackChunkvue3_webpack5"]||[]).push([[345],{60838:function(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__){eval('/* harmony import */ var _Check_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(66553);\n/* harmony import */ var _defaultValue_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(62200);\n/* harmony import */ var _defined_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(82982);\n/* harmony import */ var _DeveloperError_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(12572);\n/* harmony import */ var _Math_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(99417);\n\n\n\n\n\n\n/**\n * A 2D Cartesian point.\n * @alias Cartesian2\n * @constructor\n *\n * @param {Number} [x=0.0] The X component.\n * @param {Number} [y=0.0] The Y component.\n *\n * @see Cartesian3\n * @see Cartesian4\n * @see Packable\n */\nfunction Cartesian2(x, y) {\n  /**\n   * The X component.\n   * @type {Number}\n   * @default 0.0\n   */\n  this.x = (0,_defaultValue_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .Z)(x, 0.0);\n\n  /**\n   * The Y component.\n   * @type {Number}\n   * @default 0.0\n   */\n  this.y = (0,_defaultValue_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .Z)(y, 0.0);\n}\n\n/**\n * Creates a Cartesian2 instance from x and y coordinates.\n *\n * @param {Number} x The x coordinate.\n * @param {Number} y The y coordinate.\n * @param {Cartesian2} [result] The object onto which to store the result.\n * @returns {Cartesian2} The modified result parameter or a new Cartesian2 instance if one was not provided.\n */\nCartesian2.fromElements = function (x, y, result) {\n  if (!(0,_defined_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .Z)(result)) {\n    return new Cartesian2(x, y);\n  }\n\n  result.x = x;\n  result.y = y;\n  return result;\n};\n\n/**\n * Duplicates a Cartesian2 instance.\n *\n * @param {Cartesian2} cartesian The Cartesian to duplicate.\n * @param {Cartesian2} [result] The object onto which to store the result.\n * @returns {Cartesian2} The modified result parameter or a new Cartesian2 instance if one was not provided. (Returns undefined if cartesian is undefined)\n */\nCartesian2.clone = function (cartesian, result) {\n  if (!(0,_defined_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .Z)(cartesian)) {\n    return undefined;\n  }\n  if (!(0,_defined_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .Z)(result)) {\n    return new Cartesian2(cartesian.x, cartesian.y);\n  }\n\n  result.x = cartesian.x;\n  result.y = cartesian.y;\n  return result;\n};\n\n/**\n * Creates a Cartesian2 instance from an existing Cartesian3.  This simply takes the\n * x and y properties of the Cartesian3 and drops z.\n * @function\n *\n * @param {Cartesian3} cartesian The Cartesian3 instance to create a Cartesian2 instance from.\n * @param {Cartesian2} [result] The object onto which to store the result.\n * @returns {Cartesian2} The modified result parameter or a new Cartesian2 instance if one was not provided.\n */\nCartesian2.fromCartesian3 = Cartesian2.clone;\n\n/**\n * Creates a Cartesian2 instance from an existing Cartesian4.  This simply takes the\n * x and y properties of the Cartesian4 and drops z and w.\n * @function\n *\n * @param {Cartesian4} cartesian The Cartesian4 instance to create a Cartesian2 instance from.\n * @param {Cartesian2} [result] The object onto which to store the result.\n * @returns {Cartesian2} The modified result parameter or a new Cartesian2 instance if one was not provided.\n */\nCartesian2.fromCartesian4 = Cartesian2.clone;\n\n/**\n * The number of elements used to pack the object into an array.\n * @type {Number}\n */\nCartesian2.packedLength = 2;\n\n/**\n * Stores the provided instance into the provided array.\n *\n * @param {Cartesian2} value The value to pack.\n * @param {Number[]} array The array to pack into.\n * @param {Number} [startingIndex=0] The index into the array at which to start packing the elements.\n *\n * @returns {Number[]} The array that was packed into\n */\nCartesian2.pack = function (value, array, startingIndex) {\n  //>>includeStart(\'debug\', pragmas.debug);\n  _Check_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].typeOf.object */ .Z.typeOf.object("value", value);\n  _Check_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].defined */ .Z.defined("array", array);\n  //>>includeEnd(\'debug\');\n\n  startingIndex = (0,_defaultValue_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .Z)(startingIndex, 0);\n\n  array[startingIndex++] = value.x;\n  array[startingIndex] = value.y;\n\n  return array;\n};\n\n/**\n * Retrieves an instance from a packed array.\n *\n * @param {Number[]} array The packed array.\n * @param {Number} [startingIndex=0] The starting index of the element to be unpacked.\n * @param {Cartesian2} [result] The object into which to store the result.\n * @returns {Cartesian2} The modified result parameter or a new Cartesian2 instance if one was not provided.\n */\nCartesian2.unpack = function (array, startingIndex, result) {\n  //>>includeStart(\'debug\', pragmas.debug);\n  _Check_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].defined */ .Z.defined("array", array);\n  //>>includeEnd(\'debug\');\n\n  startingIndex = (0,_defaultValue_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .Z)(startingIndex, 0);\n\n  if (!(0,_defined_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .Z)(result)) {\n    result = new Cartesian2();\n  }\n  result.x = array[startingIndex++];\n  result.y = array[startingIndex];\n  return result;\n};\n\n/**\n     * Flattens an array of Cartesian2s into and array of components.\n     *\n     * @param {Cartesian2[]} array The array of cartesians to pack.\n     * @param {Number[]} [result] The array onto which to store the result. If this is a typed array, it must have array.length * 2 components, else a {@link DeveloperError} will be thrown. If it is a regular array, it will be resized to have (array.length * 2) elements.\n\n     * @returns {Number[]} The packed array.\n     */\nCartesian2.packArray = function (array, result) {\n  //>>includeStart(\'debug\', pragmas.debug);\n  _Check_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].defined */ .Z.defined("array", array);\n  //>>includeEnd(\'debug\');\n\n  var length = array.length;\n  var resultLength = length * 2;\n  if (!(0,_defined_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .Z)(result)) {\n    result = new Array(resultLength);\n  } else if (!Array.isArray(result) && result.length !== resultLength) {\n    throw new _DeveloperError_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"] */ .Z(\n      "If result is a typed array, it must have exactly array.length * 2 elements"\n    );\n  } else if (result.length !== resultLength) {\n    result.length = resultLength;\n  }\n\n  for (var i = 0; i < length; ++i) {\n    Cartesian2.pack(array[i], result, i * 2);\n  }\n  return result;\n};\n\n/**\n * Unpacks an array of cartesian components into and array of Cartesian2s.\n *\n * @param {Number[]} array The array of components to unpack.\n * @param {Cartesian2[]} [result] The array onto which to store the result.\n * @returns {Cartesian2[]} The unpacked array.\n */\nCartesian2.unpackArray = function (array, result) {\n  //>>includeStart(\'debug\', pragmas.debug);\n  _Check_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].defined */ .Z.defined("array", array);\n  _Check_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].typeOf.number.greaterThanOrEquals */ .Z.typeOf.number.greaterThanOrEquals("array.length", array.length, 2);\n  if (array.length % 2 !== 0) {\n    throw new _DeveloperError_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"] */ .Z("array length must be a multiple of 2.");\n  }\n  //>>includeEnd(\'debug\');\n\n  var length = array.length;\n  if (!(0,_defined_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .Z)(result)) {\n    result = new Array(length / 2);\n  } else {\n    result.length = length / 2;\n  }\n\n  for (var i = 0; i < length; i += 2) {\n    var index = i / 2;\n    result[index] = Cartesian2.unpack(array, i, result[index]);\n  }\n  return result;\n};\n\n/**\n * Creates a Cartesian2 from two consecutive elements in an array.\n * @function\n *\n * @param {Number[]} array The array whose two consecutive elements correspond to the x and y components, respectively.\n * @param {Number} [startingIndex=0] The offset into the array of the first element, which corresponds to the x component.\n * @param {Cartesian2} [result] The object onto which to store the result.\n * @returns {Cartesian2} The modified result parameter or a new Cartesian2 instance if one was not provided.\n *\n * @example\n * // Create a Cartesian2 with (1.0, 2.0)\n * var v = [1.0, 2.0];\n * var p = Cesium.Cartesian2.fromArray(v);\n *\n * // Create a Cartesian2 with (1.0, 2.0) using an offset into an array\n * var v2 = [0.0, 0.0, 1.0, 2.0];\n * var p2 = Cesium.Cartesian2.fromArray(v2, 2);\n */\nCartesian2.fromArray = Cartesian2.unpack;\n\n/**\n * Computes the value of the maximum component for the supplied Cartesian.\n *\n * @param {Cartesian2} cartesian The cartesian to use.\n * @returns {Number} The value of the maximum component.\n */\nCartesian2.maximumComponent = function (cartesian) {\n  //>>includeStart(\'debug\', pragmas.debug);\n  _Check_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].typeOf.object */ .Z.typeOf.object("cartesian", cartesian);\n  //>>includeEnd(\'debug\');\n\n  return Math.max(cartesian.x, cartesian.y);\n};\n\n/**\n * Computes the value of the minimum component for the supplied Cartesian.\n *\n * @param {Cartesian2} cartesian The cartesian to use.\n * @returns {Number} The value of the minimum component.\n */\nCartesian2.minimumComponent = function (cartesian) {\n  //>>includeStart(\'debug\', pragmas.debug);\n  _Check_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].typeOf.object */ .Z.typeOf.object("cartesian", cartesian);\n  //>>includeEnd(\'debug\');\n\n  return Math.min(cartesian.x, cartesian.y);\n};\n\n/**\n * Compares two Cartesians and computes a Cartesian which contains the minimum components of the supplied Cartesians.\n *\n * @param {Cartesian2} first A cartesian to compare.\n * @param {Cartesian2} second A cartesian to compare.\n * @param {Cartesian2} result The object into which to store the result.\n * @returns {Cartesian2} A cartesian with the minimum components.\n */\nCartesian2.minimumByComponent = function (first, second, result) {\n  //>>includeStart(\'debug\', pragmas.debug);\n  _Check_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].typeOf.object */ .Z.typeOf.object("first", first);\n  _Check_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].typeOf.object */ .Z.typeOf.object("second", second);\n  _Check_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].typeOf.object */ .Z.typeOf.object("result", result);\n  //>>includeEnd(\'debug\');\n\n  result.x = Math.min(first.x, second.x);\n  result.y = Math.min(first.y, second.y);\n\n  return result;\n};\n\n/**\n * Compares two Cartesians and computes a Cartesian which contains the maximum components of the supplied Cartesians.\n *\n * @param {Cartesian2} first A cartesian to compare.\n * @param {Cartesian2} second A cartesian to compare.\n * @param {Cartesian2} result The object into which to store the result.\n * @returns {Cartesian2} A cartesian with the maximum components.\n */\nCartesian2.maximumByComponent = function (first, second, result) {\n  //>>includeStart(\'debug\', pragmas.debug);\n  _Check_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].typeOf.object */ .Z.typeOf.object("first", first);\n  _Check_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].typeOf.object */ .Z.typeOf.object("second", second);\n  _Check_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].typeOf.object */ .Z.typeOf.object("result", result);\n  //>>includeEnd(\'debug\');\n\n  result.x = Math.max(first.x, second.x);\n  result.y = Math.max(first.y, second.y);\n  return result;\n};\n\n/**\n * Computes the provided Cartesian\'s squared magnitude.\n *\n * @param {Cartesian2} cartesian The Cartesian instance whose squared magnitude is to be computed.\n * @returns {Number} The squared magnitude.\n */\nCartesian2.magnitudeSquared = function (cartesian) {\n  //>>includeStart(\'debug\', pragmas.debug);\n  _Check_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].typeOf.object */ .Z.typeOf.object("cartesian", cartesian);\n  //>>includeEnd(\'debug\');\n\n  return cartesian.x * cartesian.x + cartesian.y * cartesian.y;\n};\n\n/**\n * Computes the Cartesian\'s magnitude (length).\n *\n * @param {Cartesian2} cartesian The Cartesian instance whose magnitude is to be computed.\n * @returns {Number} The magnitude.\n */\nCartesian2.magnitude = function (cartesian) {\n  return Math.sqrt(Cartesian2.magnitudeSquared(cartesian));\n};\n\nvar distanceScratch = new Cartesian2();\n\n/**\n * Computes the distance between two points.\n *\n * @param {Cartesian2} left The first point to compute the distance from.\n * @param {Cartesian2} right The second point to compute the distance to.\n * @returns {Number} The distance between two points.\n *\n * @example\n * // Returns 1.0\n * var d = Cesium.Cartesian2.distance(new Cesium.Cartesian2(1.0, 0.0), new Cesium.Cartesian2(2.0, 0.0));\n */\nCartesian2.distance = function (left, right) {\n  //>>includeStart(\'debug\', pragmas.debug);\n  _Check_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].typeOf.object */ .Z.typeOf.object("left", left);\n  _Check_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].typeOf.object */ .Z.typeOf.object("right", right);\n  //>>includeEnd(\'debug\');\n\n  Cartesian2.subtract(left, right, distanceScratch);\n  return Cartesian2.magnitude(distanceScratch);\n};\n\n/**\n * Computes the squared distance between two points.  Comparing squared distances\n * using this function is more efficient than comparing distances using {@link Cartesian2#distance}.\n *\n * @param {Cartesian2} left The first point to compute the distance from.\n * @param {Cartesian2} right The second point to compute the distance to.\n * @returns {Number} The distance between two points.\n *\n * @example\n * // Returns 4.0, not 2.0\n * var d = Cesium.Cartesian2.distance(new Cesium.Cartesian2(1.0, 0.0), new Cesium.Cartesian2(3.0, 0.0));\n */\nCartesian2.distanceSquared = function (left, right) {\n  //>>includeStart(\'debug\', pragmas.debug);\n  _Check_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].typeOf.object */ .Z.typeOf.object("left", left);\n  _Check_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].typeOf.object */ .Z.typeOf.object("right", right);\n  //>>includeEnd(\'debug\');\n\n  Cartesian2.subtract(left, right, distanceScratch);\n  return Cartesian2.magnitudeSquared(distanceScratch);\n};\n\n/**\n * Computes the normalized form of the supplied Cartesian.\n *\n * @param {Cartesian2} cartesian The Cartesian to be normalized.\n * @param {Cartesian2} result The object onto which to store the result.\n * @returns {Cartesian2} The modified result parameter.\n */\nCartesian2.normalize = function (cartesian, result) {\n  //>>includeStart(\'debug\', pragmas.debug);\n  _Check_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].typeOf.object */ .Z.typeOf.object("cartesian", cartesian);\n  _Check_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].typeOf.object */ .Z.typeOf.object("result", result);\n  //>>includeEnd(\'debug\');\n\n  var magnitude = Cartesian2.magnitude(cartesian);\n\n  result.x = cartesian.x / magnitude;\n  result.y = cartesian.y / magnitude;\n\n  //>>includeStart(\'debug\', pragmas.debug);\n  if (isNaN(result.x) || isNaN(result.y)) {\n    throw new _DeveloperError_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"] */ .Z("normalized result is not a number");\n  }\n  //>>includeEnd(\'debug\');\n\n  return result;\n};\n\n/**\n * Computes the dot (scalar) product of two Cartesians.\n *\n * @param {Cartesian2} left The first Cartesian.\n * @param {Cartesian2} right The second Cartesian.\n * @returns {Number} The dot product.\n */\nCartesian2.dot = function (left, right) {\n  //>>includeStart(\'debug\', pragmas.debug);\n  _Check_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].typeOf.object */ .Z.typeOf.object("left", left);\n  _Check_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].typeOf.object */ .Z.typeOf.object("right", right);\n  //>>includeEnd(\'debug\');\n\n  return left.x * right.x + left.y * right.y;\n};\n\n/**\n * Computes the magnitude of the cross product that would result from implicitly setting the Z coordinate of the input vectors to 0\n *\n * @param {Cartesian2} left The first Cartesian.\n * @param {Cartesian2} right The second Cartesian.\n * @returns {Number} The cross product.\n */\nCartesian2.cross = function (left, right) {\n  //>>includeStart(\'debug\', pragmas.debug);\n  _Check_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].typeOf.object */ .Z.typeOf.object("left", left);\n  _Check_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].typeOf.object */ .Z.typeOf.object("right", right);\n  //>>includeEnd(\'debug\');\n\n  return left.x * right.y - left.y * right.x;\n};\n\n/**\n * Computes the componentwise product of two Cartesians.\n *\n * @param {Cartesian2} left The first Cartesian.\n * @param {Cartesian2} right The second Cartesian.\n * @param {Cartesian2} result The object onto which to store the result.\n * @returns {Cartesian2} The modified result parameter.\n */\nCartesian2.multiplyComponents = function (left, right, result) {\n  //>>includeStart(\'debug\', pragmas.debug);\n  _Check_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].typeOf.object */ .Z.typeOf.object("left", left);\n  _Check_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].typeOf.object */ .Z.typeOf.object("right", right);\n  _Check_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].typeOf.object */ .Z.typeOf.object("result", result);\n  //>>includeEnd(\'debug\');\n\n  result.x = left.x * right.x;\n  result.y = left.y * right.y;\n  return result;\n};\n\n/**\n * Computes the componentwise quotient of two Cartesians.\n *\n * @param {Cartesian2} left The first Cartesian.\n * @param {Cartesian2} right The second Cartesian.\n * @param {Cartesian2} result The object onto which to store the result.\n * @returns {Cartesian2} The modified result parameter.\n */\nCartesian2.divideComponents = function (left, right, result) {\n  //>>includeStart(\'debug\', pragmas.debug);\n  _Check_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].typeOf.object */ .Z.typeOf.object("left", left);\n  _Check_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].typeOf.object */ .Z.typeOf.object("right", right);\n  _Check_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].typeOf.object */ .Z.typeOf.object("result", result);\n  //>>includeEnd(\'debug\');\n\n  result.x = left.x / right.x;\n  result.y = left.y / right.y;\n  return result;\n};\n\n/**\n * Computes the componentwise sum of two Cartesians.\n *\n * @param {Cartesian2} left The first Cartesian.\n * @param {Cartesian2} right The second Cartesian.\n * @param {Cartesian2} result The object onto which to store the result.\n * @returns {Cartesian2} The modified result parameter.\n */\nCartesian2.add = function (left, right, result) {\n  //>>includeStart(\'debug\', pragmas.debug);\n  _Check_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].typeOf.object */ .Z.typeOf.object("left", left);\n  _Check_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].typeOf.object */ .Z.typeOf.object("right", right);\n  _Check_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].typeOf.object */ .Z.typeOf.object("result", result);\n  //>>includeEnd(\'debug\');\n\n  result.x = left.x + right.x;\n  result.y = left.y + right.y;\n  return result;\n};\n\n/**\n * Computes the componentwise difference of two Cartesians.\n *\n * @param {Cartesian2} left The first Cartesian.\n * @param {Cartesian2} right The second Cartesian.\n * @param {Cartesian2} result The object onto which to store the result.\n * @returns {Cartesian2} The modified result parameter.\n */\nCartesian2.subtract = function (left, right, result) {\n  //>>includeStart(\'debug\', pragmas.debug);\n  _Check_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].typeOf.object */ .Z.typeOf.object("left", left);\n  _Check_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].typeOf.object */ .Z.typeOf.object("right", right);\n  _Check_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].typeOf.object */ .Z.typeOf.object("result", result);\n  //>>includeEnd(\'debug\');\n\n  result.x = left.x - right.x;\n  result.y = left.y - right.y;\n  return result;\n};\n\n/**\n * Multiplies the provided Cartesian componentwise by the provided scalar.\n *\n * @param {Cartesian2} cartesian The Cartesian to be scaled.\n * @param {Number} scalar The scalar to multiply with.\n * @param {Cartesian2} result The object onto which to store the result.\n * @returns {Cartesian2} The modified result parameter.\n */\nCartesian2.multiplyByScalar = function (cartesian, scalar, result) {\n  //>>includeStart(\'debug\', pragmas.debug);\n  _Check_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].typeOf.object */ .Z.typeOf.object("cartesian", cartesian);\n  _Check_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].typeOf.number */ .Z.typeOf.number("scalar", scalar);\n  _Check_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].typeOf.object */ .Z.typeOf.object("result", result);\n  //>>includeEnd(\'debug\');\n\n  result.x = cartesian.x * scalar;\n  result.y = cartesian.y * scalar;\n  return result;\n};\n\n/**\n * Divides the provided Cartesian componentwise by the provided scalar.\n *\n * @param {Cartesian2} cartesian The Cartesian to be divided.\n * @param {Number} scalar The scalar to divide by.\n * @param {Cartesian2} result The object onto which to store the result.\n * @returns {Cartesian2} The modified result parameter.\n */\nCartesian2.divideByScalar = function (cartesian, scalar, result) {\n  //>>includeStart(\'debug\', pragmas.debug);\n  _Check_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].typeOf.object */ .Z.typeOf.object("cartesian", cartesian);\n  _Check_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].typeOf.number */ .Z.typeOf.number("scalar", scalar);\n  _Check_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].typeOf.object */ .Z.typeOf.object("result", result);\n  //>>includeEnd(\'debug\');\n\n  result.x = cartesian.x / scalar;\n  result.y = cartesian.y / scalar;\n  return result;\n};\n\n/**\n * Negates the provided Cartesian.\n *\n * @param {Cartesian2} cartesian The Cartesian to be negated.\n * @param {Cartesian2} result The object onto which to store the result.\n * @returns {Cartesian2} The modified result parameter.\n */\nCartesian2.negate = function (cartesian, result) {\n  //>>includeStart(\'debug\', pragmas.debug);\n  _Check_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].typeOf.object */ .Z.typeOf.object("cartesian", cartesian);\n  _Check_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].typeOf.object */ .Z.typeOf.object("result", result);\n  //>>includeEnd(\'debug\');\n\n  result.x = -cartesian.x;\n  result.y = -cartesian.y;\n  return result;\n};\n\n/**\n * Computes the absolute value of the provided Cartesian.\n *\n * @param {Cartesian2} cartesian The Cartesian whose absolute value is to be computed.\n * @param {Cartesian2} result The object onto which to store the result.\n * @returns {Cartesian2} The modified result parameter.\n */\nCartesian2.abs = function (cartesian, result) {\n  //>>includeStart(\'debug\', pragmas.debug);\n  _Check_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].typeOf.object */ .Z.typeOf.object("cartesian", cartesian);\n  _Check_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].typeOf.object */ .Z.typeOf.object("result", result);\n  //>>includeEnd(\'debug\');\n\n  result.x = Math.abs(cartesian.x);\n  result.y = Math.abs(cartesian.y);\n  return result;\n};\n\nvar lerpScratch = new Cartesian2();\n/**\n * Computes the linear interpolation or extrapolation at t using the provided cartesians.\n *\n * @param {Cartesian2} start The value corresponding to t at 0.0.\n * @param {Cartesian2} end The value corresponding to t at 1.0.\n * @param {Number} t The point along t at which to interpolate.\n * @param {Cartesian2} result The object onto which to store the result.\n * @returns {Cartesian2} The modified result parameter.\n */\nCartesian2.lerp = function (start, end, t, result) {\n  //>>includeStart(\'debug\', pragmas.debug);\n  _Check_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].typeOf.object */ .Z.typeOf.object("start", start);\n  _Check_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].typeOf.object */ .Z.typeOf.object("end", end);\n  _Check_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].typeOf.number */ .Z.typeOf.number("t", t);\n  _Check_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].typeOf.object */ .Z.typeOf.object("result", result);\n  //>>includeEnd(\'debug\');\n\n  Cartesian2.multiplyByScalar(end, t, lerpScratch);\n  result = Cartesian2.multiplyByScalar(start, 1.0 - t, result);\n  return Cartesian2.add(lerpScratch, result, result);\n};\n\nvar angleBetweenScratch = new Cartesian2();\nvar angleBetweenScratch2 = new Cartesian2();\n/**\n * Returns the angle, in radians, between the provided Cartesians.\n *\n * @param {Cartesian2} left The first Cartesian.\n * @param {Cartesian2} right The second Cartesian.\n * @returns {Number} The angle between the Cartesians.\n */\nCartesian2.angleBetween = function (left, right) {\n  //>>includeStart(\'debug\', pragmas.debug);\n  _Check_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].typeOf.object */ .Z.typeOf.object("left", left);\n  _Check_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].typeOf.object */ .Z.typeOf.object("right", right);\n  //>>includeEnd(\'debug\');\n\n  Cartesian2.normalize(left, angleBetweenScratch);\n  Cartesian2.normalize(right, angleBetweenScratch2);\n  return _Math_js__WEBPACK_IMPORTED_MODULE_3__/* ["default"].acosClamped */ .Z.acosClamped(\n    Cartesian2.dot(angleBetweenScratch, angleBetweenScratch2)\n  );\n};\n\nvar mostOrthogonalAxisScratch = new Cartesian2();\n/**\n * Returns the axis that is most orthogonal to the provided Cartesian.\n *\n * @param {Cartesian2} cartesian The Cartesian on which to find the most orthogonal axis.\n * @param {Cartesian2} result The object onto which to store the result.\n * @returns {Cartesian2} The most orthogonal axis.\n */\nCartesian2.mostOrthogonalAxis = function (cartesian, result) {\n  //>>includeStart(\'debug\', pragmas.debug);\n  _Check_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].typeOf.object */ .Z.typeOf.object("cartesian", cartesian);\n  _Check_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].typeOf.object */ .Z.typeOf.object("result", result);\n  //>>includeEnd(\'debug\');\n\n  var f = Cartesian2.normalize(cartesian, mostOrthogonalAxisScratch);\n  Cartesian2.abs(f, f);\n\n  if (f.x <= f.y) {\n    result = Cartesian2.clone(Cartesian2.UNIT_X, result);\n  } else {\n    result = Cartesian2.clone(Cartesian2.UNIT_Y, result);\n  }\n\n  return result;\n};\n\n/**\n * Compares the provided Cartesians componentwise and returns\n * <code>true</code> if they are equal, <code>false</code> otherwise.\n *\n * @param {Cartesian2} [left] The first Cartesian.\n * @param {Cartesian2} [right] The second Cartesian.\n * @returns {Boolean} <code>true</code> if left and right are equal, <code>false</code> otherwise.\n */\nCartesian2.equals = function (left, right) {\n  return (\n    left === right ||\n    ((0,_defined_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .Z)(left) &&\n      (0,_defined_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .Z)(right) &&\n      left.x === right.x &&\n      left.y === right.y)\n  );\n};\n\n/**\n * @private\n */\nCartesian2.equalsArray = function (cartesian, array, offset) {\n  return cartesian.x === array[offset] && cartesian.y === array[offset + 1];\n};\n\n/**\n * Compares the provided Cartesians componentwise and returns\n * <code>true</code> if they pass an absolute or relative tolerance test,\n * <code>false</code> otherwise.\n *\n * @param {Cartesian2} [left] The first Cartesian.\n * @param {Cartesian2} [right] The second Cartesian.\n * @param {Number} [relativeEpsilon=0] The relative epsilon tolerance to use for equality testing.\n * @param {Number} [absoluteEpsilon=relativeEpsilon] The absolute epsilon tolerance to use for equality testing.\n * @returns {Boolean} <code>true</code> if left and right are within the provided epsilon, <code>false</code> otherwise.\n */\nCartesian2.equalsEpsilon = function (\n  left,\n  right,\n  relativeEpsilon,\n  absoluteEpsilon\n) {\n  return (\n    left === right ||\n    ((0,_defined_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .Z)(left) &&\n      (0,_defined_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .Z)(right) &&\n      _Math_js__WEBPACK_IMPORTED_MODULE_3__/* ["default"].equalsEpsilon */ .Z.equalsEpsilon(\n        left.x,\n        right.x,\n        relativeEpsilon,\n        absoluteEpsilon\n      ) &&\n      _Math_js__WEBPACK_IMPORTED_MODULE_3__/* ["default"].equalsEpsilon */ .Z.equalsEpsilon(\n        left.y,\n        right.y,\n        relativeEpsilon,\n        absoluteEpsilon\n      ))\n  );\n};\n\n/**\n * An immutable Cartesian2 instance initialized to (0.0, 0.0).\n *\n * @type {Cartesian2}\n * @constant\n */\nCartesian2.ZERO = Object.freeze(new Cartesian2(0.0, 0.0));\n\n/**\n * An immutable Cartesian2 instance initialized to (1.0, 1.0).\n *\n * @type {Cartesian2}\n * @constant\n */\nCartesian2.ONE = Object.freeze(new Cartesian2(1.0, 1.0));\n\n/**\n * An immutable Cartesian2 instance initialized to (1.0, 0.0).\n *\n * @type {Cartesian2}\n * @constant\n */\nCartesian2.UNIT_X = Object.freeze(new Cartesian2(1.0, 0.0));\n\n/**\n * An immutable Cartesian2 instance initialized to (0.0, 1.0).\n *\n * @type {Cartesian2}\n * @constant\n */\nCartesian2.UNIT_Y = Object.freeze(new Cartesian2(0.0, 1.0));\n\n/**\n * Duplicates this Cartesian2 instance.\n *\n * @param {Cartesian2} [result] The object onto which to store the result.\n * @returns {Cartesian2} The modified result parameter or a new Cartesian2 instance if one was not provided.\n */\nCartesian2.prototype.clone = function (result) {\n  return Cartesian2.clone(this, result);\n};\n\n/**\n * Compares this Cartesian against the provided Cartesian componentwise and returns\n * <code>true</code> if they are equal, <code>false</code> otherwise.\n *\n * @param {Cartesian2} [right] The right hand side Cartesian.\n * @returns {Boolean} <code>true</code> if they are equal, <code>false</code> otherwise.\n */\nCartesian2.prototype.equals = function (right) {\n  return Cartesian2.equals(this, right);\n};\n\n/**\n * Compares this Cartesian against the provided Cartesian componentwise and returns\n * <code>true</code> if they pass an absolute or relative tolerance test,\n * <code>false</code> otherwise.\n *\n * @param {Cartesian2} [right] The right hand side Cartesian.\n * @param {Number} [relativeEpsilon=0] The relative epsilon tolerance to use for equality testing.\n * @param {Number} [absoluteEpsilon=relativeEpsilon] The absolute epsilon tolerance to use for equality testing.\n * @returns {Boolean} <code>true</code> if they are within the provided epsilon, <code>false</code> otherwise.\n */\nCartesian2.prototype.equalsEpsilon = function (\n  right,\n  relativeEpsilon,\n  absoluteEpsilon\n) {\n  return Cartesian2.equalsEpsilon(\n    this,\n    right,\n    relativeEpsilon,\n    absoluteEpsilon\n  );\n};\n\n/**\n * Creates a string representing this Cartesian in the format \'(x, y)\'.\n *\n * @returns {String} A string representing the provided Cartesian in the format \'(x, y)\'.\n */\nCartesian2.prototype.toString = function () {\n  return "(" + this.x + ", " + this.y + ")";\n};\n/* harmony default export */ __webpack_exports__["Z"] = (Cartesian2);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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UztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLLGdFQUFPO0FBQ1osTUFBTSxnRUFBTztBQUNiLE1BQU0scUZBQXdCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNLHFGQUF3QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsWUFBWTtBQUN2QixhQUFhLFlBQVk7QUFDekI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFlBQVk7QUFDdkIsYUFBYSxTQUFTO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFlBQVk7QUFDdkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixhQUFhLFNBQVM7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseURBQWUsVUFBVSxFQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdnVlMy13ZWJwYWNrNS8uL25vZGVfbW9kdWxlcy9jZXNpdW0vU291cmNlL0NvcmUvQ2FydGVzaWFuMi5qcz85Zjc4Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBDaGVjayBmcm9tIFwiLi9DaGVjay5qc1wiO1xuaW1wb3J0IGRlZmF1bHRWYWx1ZSBmcm9tIFwiLi9kZWZhdWx0VmFsdWUuanNcIjtcbmltcG9ydCBkZWZpbmVkIGZyb20gXCIuL2RlZmluZWQuanNcIjtcbmltcG9ydCBEZXZlbG9wZXJFcnJvciBmcm9tIFwiLi9EZXZlbG9wZXJFcnJvci5qc1wiO1xuaW1wb3J0IENlc2l1bU1hdGggZnJvbSBcIi4vTWF0aC5qc1wiO1xuXG4vKipcbiAqIEEgMkQgQ2FydGVzaWFuIHBvaW50LlxuICogQGFsaWFzIENhcnRlc2lhbjJcbiAqIEBjb25zdHJ1Y3RvclxuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSBbeD0wLjBdIFRoZSBYIGNvbXBvbmVudC5cbiAqIEBwYXJhbSB7TnVtYmVyfSBbeT0wLjBdIFRoZSBZIGNvbXBvbmVudC5cbiAqXG4gKiBAc2VlIENhcnRlc2lhbjNcbiAqIEBzZWUgQ2FydGVzaWFuNFxuICogQHNlZSBQYWNrYWJsZVxuICovXG5mdW5jdGlvbiBDYXJ0ZXNpYW4yKHgsIHkpIHtcbiAgLyoqXG4gICAqIFRoZSBYIGNvbXBvbmVudC5cbiAgICogQHR5cGUge051bWJlcn1cbiAgICogQGRlZmF1bHQgMC4wXG4gICAqL1xuICB0aGlzLnggPSBkZWZhdWx0VmFsdWUoeCwgMC4wKTtcblxuICAvKipcbiAgICogVGhlIFkgY29tcG9uZW50LlxuICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgKiBAZGVmYXVsdCAwLjBcbiAgICovXG4gIHRoaXMueSA9IGRlZmF1bHRWYWx1ZSh5LCAwLjApO1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYSBDYXJ0ZXNpYW4yIGluc3RhbmNlIGZyb20geCBhbmQgeSBjb29yZGluYXRlcy5cbiAqXG4gKiBAcGFyYW0ge051bWJlcn0geCBUaGUgeCBjb29yZGluYXRlLlxuICogQHBhcmFtIHtOdW1iZXJ9IHkgVGhlIHkgY29vcmRpbmF0ZS5cbiAqIEBwYXJhbSB7Q2FydGVzaWFuMn0gW3Jlc3VsdF0gVGhlIG9iamVjdCBvbnRvIHdoaWNoIHRvIHN0b3JlIHRoZSByZXN1bHQuXG4gKiBAcmV0dXJucyB7Q2FydGVzaWFuMn0gVGhlIG1vZGlmaWVkIHJlc3VsdCBwYXJhbWV0ZXIgb3IgYSBuZXcgQ2FydGVzaWFuMiBpbnN0YW5jZSBpZiBvbmUgd2FzIG5vdCBwcm92aWRlZC5cbiAqL1xuQ2FydGVzaWFuMi5mcm9tRWxlbWVudHMgPSBmdW5jdGlvbiAoeCwgeSwgcmVzdWx0KSB7XG4gIGlmICghZGVmaW5lZChyZXN1bHQpKSB7XG4gICAgcmV0dXJuIG5ldyBDYXJ0ZXNpYW4yKHgsIHkpO1xuICB9XG5cbiAgcmVzdWx0LnggPSB4O1xuICByZXN1bHQueSA9IHk7XG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG4vKipcbiAqIER1cGxpY2F0ZXMgYSBDYXJ0ZXNpYW4yIGluc3RhbmNlLlxuICpcbiAqIEBwYXJhbSB7Q2FydGVzaWFuMn0gY2FydGVzaWFuIFRoZSBDYXJ0ZXNpYW4gdG8gZHVwbGljYXRlLlxuICogQHBhcmFtIHtDYXJ0ZXNpYW4yfSBbcmVzdWx0XSBUaGUgb2JqZWN0IG9udG8gd2hpY2ggdG8gc3RvcmUgdGhlIHJlc3VsdC5cbiAqIEByZXR1cm5zIHtDYXJ0ZXNpYW4yfSBUaGUgbW9kaWZpZWQgcmVzdWx0IHBhcmFtZXRlciBvciBhIG5ldyBDYXJ0ZXNpYW4yIGluc3RhbmNlIGlmIG9uZSB3YXMgbm90IHByb3ZpZGVkLiAoUmV0dXJucyB1bmRlZmluZWQgaWYgY2FydGVzaWFuIGlzIHVuZGVmaW5lZClcbiAqL1xuQ2FydGVzaWFuMi5jbG9uZSA9IGZ1bmN0aW9uIChjYXJ0ZXNpYW4sIHJlc3VsdCkge1xuICBpZiAoIWRlZmluZWQoY2FydGVzaWFuKSkge1xuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cbiAgaWYgKCFkZWZpbmVkKHJlc3VsdCkpIHtcbiAgICByZXR1cm4gbmV3IENhcnRlc2lhbjIoY2FydGVzaWFuLngsIGNhcnRlc2lhbi55KTtcbiAgfVxuXG4gIHJlc3VsdC54ID0gY2FydGVzaWFuLng7XG4gIHJlc3VsdC55ID0gY2FydGVzaWFuLnk7XG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG4vKipcbiAqIENyZWF0ZXMgYSBDYXJ0ZXNpYW4yIGluc3RhbmNlIGZyb20gYW4gZXhpc3RpbmcgQ2FydGVzaWFuMy4gIFRoaXMgc2ltcGx5IHRha2VzIHRoZVxuICogeCBhbmQgeSBwcm9wZXJ0aWVzIG9mIHRoZSBDYXJ0ZXNpYW4zIGFuZCBkcm9wcyB6LlxuICogQGZ1bmN0aW9uXG4gKlxuICogQHBhcmFtIHtDYXJ0ZXNpYW4zfSBjYXJ0ZXNpYW4gVGhlIENhcnRlc2lhbjMgaW5zdGFuY2UgdG8gY3JlYXRlIGEgQ2FydGVzaWFuMiBpbnN0YW5jZSBmcm9tLlxuICogQHBhcmFtIHtDYXJ0ZXNpYW4yfSBbcmVzdWx0XSBUaGUgb2JqZWN0IG9udG8gd2hpY2ggdG8gc3RvcmUgdGhlIHJlc3VsdC5cbiAqIEByZXR1cm5zIHtDYXJ0ZXNpYW4yfSBUaGUgbW9kaWZpZWQgcmVzdWx0IHBhcmFtZXRlciBvciBhIG5ldyBDYXJ0ZXNpYW4yIGluc3RhbmNlIGlmIG9uZSB3YXMgbm90IHByb3ZpZGVkLlxuICovXG5DYXJ0ZXNpYW4yLmZyb21DYXJ0ZXNpYW4zID0gQ2FydGVzaWFuMi5jbG9uZTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgQ2FydGVzaWFuMiBpbnN0YW5jZSBmcm9tIGFuIGV4aXN0aW5nIENhcnRlc2lhbjQuICBUaGlzIHNpbXBseSB0YWtlcyB0aGVcbiAqIHggYW5kIHkgcHJvcGVydGllcyBvZiB0aGUgQ2FydGVzaWFuNCBhbmQgZHJvcHMgeiBhbmQgdy5cbiAqIEBmdW5jdGlvblxuICpcbiAqIEBwYXJhbSB7Q2FydGVzaWFuNH0gY2FydGVzaWFuIFRoZSBDYXJ0ZXNpYW40IGluc3RhbmNlIHRvIGNyZWF0ZSBhIENhcnRlc2lhbjIgaW5zdGFuY2UgZnJvbS5cbiAqIEBwYXJhbSB7Q2FydGVzaWFuMn0gW3Jlc3VsdF0gVGhlIG9iamVjdCBvbnRvIHdoaWNoIHRvIHN0b3JlIHRoZSByZXN1bHQuXG4gKiBAcmV0dXJucyB7Q2FydGVzaWFuMn0gVGhlIG1vZGlmaWVkIHJlc3VsdCBwYXJhbWV0ZXIgb3IgYSBuZXcgQ2FydGVzaWFuMiBpbnN0YW5jZSBpZiBvbmUgd2FzIG5vdCBwcm92aWRlZC5cbiAqL1xuQ2FydGVzaWFuMi5mcm9tQ2FydGVzaWFuNCA9IENhcnRlc2lhbjIuY2xvbmU7XG5cbi8qKlxuICogVGhlIG51bWJlciBvZiBlbGVtZW50cyB1c2VkIHRvIHBhY2sgdGhlIG9iamVjdCBpbnRvIGFuIGFycmF5LlxuICogQHR5cGUge051bWJlcn1cbiAqL1xuQ2FydGVzaWFuMi5wYWNrZWRMZW5ndGggPSAyO1xuXG4vKipcbiAqIFN0b3JlcyB0aGUgcHJvdmlkZWQgaW5zdGFuY2UgaW50byB0aGUgcHJvdmlkZWQgYXJyYXkuXG4gKlxuICogQHBhcmFtIHtDYXJ0ZXNpYW4yfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcGFjay5cbiAqIEBwYXJhbSB7TnVtYmVyW119IGFycmF5IFRoZSBhcnJheSB0byBwYWNrIGludG8uXG4gKiBAcGFyYW0ge051bWJlcn0gW3N0YXJ0aW5nSW5kZXg9MF0gVGhlIGluZGV4IGludG8gdGhlIGFycmF5IGF0IHdoaWNoIHRvIHN0YXJ0IHBhY2tpbmcgdGhlIGVsZW1lbnRzLlxuICpcbiAqIEByZXR1cm5zIHtOdW1iZXJbXX0gVGhlIGFycmF5IHRoYXQgd2FzIHBhY2tlZCBpbnRvXG4gKi9cbkNhcnRlc2lhbjIucGFjayA9IGZ1bmN0aW9uICh2YWx1ZSwgYXJyYXksIHN0YXJ0aW5nSW5kZXgpIHtcbiAgLy8+PmluY2x1ZGVTdGFydCgnZGVidWcnLCBwcmFnbWFzLmRlYnVnKTtcbiAgQ2hlY2sudHlwZU9mLm9iamVjdChcInZhbHVlXCIsIHZhbHVlKTtcbiAgQ2hlY2suZGVmaW5lZChcImFycmF5XCIsIGFycmF5KTtcbiAgLy8+PmluY2x1ZGVFbmQoJ2RlYnVnJyk7XG5cbiAgc3RhcnRpbmdJbmRleCA9IGRlZmF1bHRWYWx1ZShzdGFydGluZ0luZGV4LCAwKTtcblxuICBhcnJheVtzdGFydGluZ0luZGV4KytdID0gdmFsdWUueDtcbiAgYXJyYXlbc3RhcnRpbmdJbmRleF0gPSB2YWx1ZS55O1xuXG4gIHJldHVybiBhcnJheTtcbn07XG5cbi8qKlxuICogUmV0cmlldmVzIGFuIGluc3RhbmNlIGZyb20gYSBwYWNrZWQgYXJyYXkuXG4gKlxuICogQHBhcmFtIHtOdW1iZXJbXX0gYXJyYXkgVGhlIHBhY2tlZCBhcnJheS5cbiAqIEBwYXJhbSB7TnVtYmVyfSBbc3RhcnRpbmdJbmRleD0wXSBUaGUgc3RhcnRpbmcgaW5kZXggb2YgdGhlIGVsZW1lbnQgdG8gYmUgdW5wYWNrZWQuXG4gKiBAcGFyYW0ge0NhcnRlc2lhbjJ9IFtyZXN1bHRdIFRoZSBvYmplY3QgaW50byB3aGljaCB0byBzdG9yZSB0aGUgcmVzdWx0LlxuICogQHJldHVybnMge0NhcnRlc2lhbjJ9IFRoZSBtb2RpZmllZCByZXN1bHQgcGFyYW1ldGVyIG9yIGEgbmV3IENhcnRlc2lhbjIgaW5zdGFuY2UgaWYgb25lIHdhcyBub3QgcHJvdmlkZWQuXG4gKi9cbkNhcnRlc2lhbjIudW5wYWNrID0gZnVuY3Rpb24gKGFycmF5LCBzdGFydGluZ0luZGV4LCByZXN1bHQpIHtcbiAgLy8+PmluY2x1ZGVTdGFydCgnZGVidWcnLCBwcmFnbWFzLmRlYnVnKTtcbiAgQ2hlY2suZGVmaW5lZChcImFycmF5XCIsIGFycmF5KTtcbiAgLy8+PmluY2x1ZGVFbmQoJ2RlYnVnJyk7XG5cbiAgc3RhcnRpbmdJbmRleCA9IGRlZmF1bHRWYWx1ZShzdGFydGluZ0luZGV4LCAwKTtcblxuICBpZiAoIWRlZmluZWQocmVzdWx0KSkge1xuICAgIHJlc3VsdCA9IG5ldyBDYXJ0ZXNpYW4yKCk7XG4gIH1cbiAgcmVzdWx0LnggPSBhcnJheVtzdGFydGluZ0luZGV4KytdO1xuICByZXN1bHQueSA9IGFycmF5W3N0YXJ0aW5nSW5kZXhdO1xuICByZXR1cm4gcmVzdWx0O1xufTtcblxuLyoqXG4gICAgICogRmxhdHRlbnMgYW4gYXJyYXkgb2YgQ2FydGVzaWFuMnMgaW50byBhbmQgYXJyYXkgb2YgY29tcG9uZW50cy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Q2FydGVzaWFuMltdfSBhcnJheSBUaGUgYXJyYXkgb2YgY2FydGVzaWFucyB0byBwYWNrLlxuICAgICAqIEBwYXJhbSB7TnVtYmVyW119IFtyZXN1bHRdIFRoZSBhcnJheSBvbnRvIHdoaWNoIHRvIHN0b3JlIHRoZSByZXN1bHQuIElmIHRoaXMgaXMgYSB0eXBlZCBhcnJheSwgaXQgbXVzdCBoYXZlIGFycmF5Lmxlbmd0aCAqIDIgY29tcG9uZW50cywgZWxzZSBhIHtAbGluayBEZXZlbG9wZXJFcnJvcn0gd2lsbCBiZSB0aHJvd24uIElmIGl0IGlzIGEgcmVndWxhciBhcnJheSwgaXQgd2lsbCBiZSByZXNpemVkIHRvIGhhdmUgKGFycmF5Lmxlbmd0aCAqIDIpIGVsZW1lbnRzLlxuXG4gICAgICogQHJldHVybnMge051bWJlcltdfSBUaGUgcGFja2VkIGFycmF5LlxuICAgICAqL1xuQ2FydGVzaWFuMi5wYWNrQXJyYXkgPSBmdW5jdGlvbiAoYXJyYXksIHJlc3VsdCkge1xuICAvLz4+aW5jbHVkZVN0YXJ0KCdkZWJ1ZycsIHByYWdtYXMuZGVidWcpO1xuICBDaGVjay5kZWZpbmVkKFwiYXJyYXlcIiwgYXJyYXkpO1xuICAvLz4+aW5jbHVkZUVuZCgnZGVidWcnKTtcblxuICB2YXIgbGVuZ3RoID0gYXJyYXkubGVuZ3RoO1xuICB2YXIgcmVzdWx0TGVuZ3RoID0gbGVuZ3RoICogMjtcbiAgaWYgKCFkZWZpbmVkKHJlc3VsdCkpIHtcbiAgICByZXN1bHQgPSBuZXcgQXJyYXkocmVzdWx0TGVuZ3RoKTtcbiAgfSBlbHNlIGlmICghQXJyYXkuaXNBcnJheShyZXN1bHQpICYmIHJlc3VsdC5sZW5ndGggIT09IHJlc3VsdExlbmd0aCkge1xuICAgIHRocm93IG5ldyBEZXZlbG9wZXJFcnJvcihcbiAgICAgIFwiSWYgcmVzdWx0IGlzIGEgdHlwZWQgYXJyYXksIGl0IG11c3QgaGF2ZSBleGFjdGx5IGFycmF5Lmxlbmd0aCAqIDIgZWxlbWVudHNcIlxuICAgICk7XG4gIH0gZWxzZSBpZiAocmVzdWx0Lmxlbmd0aCAhPT0gcmVzdWx0TGVuZ3RoKSB7XG4gICAgcmVzdWx0Lmxlbmd0aCA9IHJlc3VsdExlbmd0aDtcbiAgfVxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kpIHtcbiAgICBDYXJ0ZXNpYW4yLnBhY2soYXJyYXlbaV0sIHJlc3VsdCwgaSAqIDIpO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG4vKipcbiAqIFVucGFja3MgYW4gYXJyYXkgb2YgY2FydGVzaWFuIGNvbXBvbmVudHMgaW50byBhbmQgYXJyYXkgb2YgQ2FydGVzaWFuMnMuXG4gKlxuICogQHBhcmFtIHtOdW1iZXJbXX0gYXJyYXkgVGhlIGFycmF5IG9mIGNvbXBvbmVudHMgdG8gdW5wYWNrLlxuICogQHBhcmFtIHtDYXJ0ZXNpYW4yW119IFtyZXN1bHRdIFRoZSBhcnJheSBvbnRvIHdoaWNoIHRvIHN0b3JlIHRoZSByZXN1bHQuXG4gKiBAcmV0dXJucyB7Q2FydGVzaWFuMltdfSBUaGUgdW5wYWNrZWQgYXJyYXkuXG4gKi9cbkNhcnRlc2lhbjIudW5wYWNrQXJyYXkgPSBmdW5jdGlvbiAoYXJyYXksIHJlc3VsdCkge1xuICAvLz4+aW5jbHVkZVN0YXJ0KCdkZWJ1ZycsIHByYWdtYXMuZGVidWcpO1xuICBDaGVjay5kZWZpbmVkKFwiYXJyYXlcIiwgYXJyYXkpO1xuICBDaGVjay50eXBlT2YubnVtYmVyLmdyZWF0ZXJUaGFuT3JFcXVhbHMoXCJhcnJheS5sZW5ndGhcIiwgYXJyYXkubGVuZ3RoLCAyKTtcbiAgaWYgKGFycmF5Lmxlbmd0aCAlIDIgIT09IDApIHtcbiAgICB0aHJvdyBuZXcgRGV2ZWxvcGVyRXJyb3IoXCJhcnJheSBsZW5ndGggbXVzdCBiZSBhIG11bHRpcGxlIG9mIDIuXCIpO1xuICB9XG4gIC8vPj5pbmNsdWRlRW5kKCdkZWJ1ZycpO1xuXG4gIHZhciBsZW5ndGggPSBhcnJheS5sZW5ndGg7XG4gIGlmICghZGVmaW5lZChyZXN1bHQpKSB7XG4gICAgcmVzdWx0ID0gbmV3IEFycmF5KGxlbmd0aCAvIDIpO1xuICB9IGVsc2Uge1xuICAgIHJlc3VsdC5sZW5ndGggPSBsZW5ndGggLyAyO1xuICB9XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkgKz0gMikge1xuICAgIHZhciBpbmRleCA9IGkgLyAyO1xuICAgIHJlc3VsdFtpbmRleF0gPSBDYXJ0ZXNpYW4yLnVucGFjayhhcnJheSwgaSwgcmVzdWx0W2luZGV4XSk7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbi8qKlxuICogQ3JlYXRlcyBhIENhcnRlc2lhbjIgZnJvbSB0d28gY29uc2VjdXRpdmUgZWxlbWVudHMgaW4gYW4gYXJyYXkuXG4gKiBAZnVuY3Rpb25cbiAqXG4gKiBAcGFyYW0ge051bWJlcltdfSBhcnJheSBUaGUgYXJyYXkgd2hvc2UgdHdvIGNvbnNlY3V0aXZlIGVsZW1lbnRzIGNvcnJlc3BvbmQgdG8gdGhlIHggYW5kIHkgY29tcG9uZW50cywgcmVzcGVjdGl2ZWx5LlxuICogQHBhcmFtIHtOdW1iZXJ9IFtzdGFydGluZ0luZGV4PTBdIFRoZSBvZmZzZXQgaW50byB0aGUgYXJyYXkgb2YgdGhlIGZpcnN0IGVsZW1lbnQsIHdoaWNoIGNvcnJlc3BvbmRzIHRvIHRoZSB4IGNvbXBvbmVudC5cbiAqIEBwYXJhbSB7Q2FydGVzaWFuMn0gW3Jlc3VsdF0gVGhlIG9iamVjdCBvbnRvIHdoaWNoIHRvIHN0b3JlIHRoZSByZXN1bHQuXG4gKiBAcmV0dXJucyB7Q2FydGVzaWFuMn0gVGhlIG1vZGlmaWVkIHJlc3VsdCBwYXJhbWV0ZXIgb3IgYSBuZXcgQ2FydGVzaWFuMiBpbnN0YW5jZSBpZiBvbmUgd2FzIG5vdCBwcm92aWRlZC5cbiAqXG4gKiBAZXhhbXBsZVxuICogLy8gQ3JlYXRlIGEgQ2FydGVzaWFuMiB3aXRoICgxLjAsIDIuMClcbiAqIHZhciB2ID0gWzEuMCwgMi4wXTtcbiAqIHZhciBwID0gQ2VzaXVtLkNhcnRlc2lhbjIuZnJvbUFycmF5KHYpO1xuICpcbiAqIC8vIENyZWF0ZSBhIENhcnRlc2lhbjIgd2l0aCAoMS4wLCAyLjApIHVzaW5nIGFuIG9mZnNldCBpbnRvIGFuIGFycmF5XG4gKiB2YXIgdjIgPSBbMC4wLCAwLjAsIDEuMCwgMi4wXTtcbiAqIHZhciBwMiA9IENlc2l1bS5DYXJ0ZXNpYW4yLmZyb21BcnJheSh2MiwgMik7XG4gKi9cbkNhcnRlc2lhbjIuZnJvbUFycmF5ID0gQ2FydGVzaWFuMi51bnBhY2s7XG5cbi8qKlxuICogQ29tcHV0ZXMgdGhlIHZhbHVlIG9mIHRoZSBtYXhpbXVtIGNvbXBvbmVudCBmb3IgdGhlIHN1cHBsaWVkIENhcnRlc2lhbi5cbiAqXG4gKiBAcGFyYW0ge0NhcnRlc2lhbjJ9IGNhcnRlc2lhbiBUaGUgY2FydGVzaWFuIHRvIHVzZS5cbiAqIEByZXR1cm5zIHtOdW1iZXJ9IFRoZSB2YWx1ZSBvZiB0aGUgbWF4aW11bSBjb21wb25lbnQuXG4gKi9cbkNhcnRlc2lhbjIubWF4aW11bUNvbXBvbmVudCA9IGZ1bmN0aW9uIChjYXJ0ZXNpYW4pIHtcbiAgLy8+PmluY2x1ZGVTdGFydCgnZGVidWcnLCBwcmFnbWFzLmRlYnVnKTtcbiAgQ2hlY2sudHlwZU9mLm9iamVjdChcImNhcnRlc2lhblwiLCBjYXJ0ZXNpYW4pO1xuICAvLz4+aW5jbHVkZUVuZCgnZGVidWcnKTtcblxuICByZXR1cm4gTWF0aC5tYXgoY2FydGVzaWFuLngsIGNhcnRlc2lhbi55KTtcbn07XG5cbi8qKlxuICogQ29tcHV0ZXMgdGhlIHZhbHVlIG9mIHRoZSBtaW5pbXVtIGNvbXBvbmVudCBmb3IgdGhlIHN1cHBsaWVkIENhcnRlc2lhbi5cbiAqXG4gKiBAcGFyYW0ge0NhcnRlc2lhbjJ9IGNhcnRlc2lhbiBUaGUgY2FydGVzaWFuIHRvIHVzZS5cbiAqIEByZXR1cm5zIHtOdW1iZXJ9IFRoZSB2YWx1ZSBvZiB0aGUgbWluaW11bSBjb21wb25lbnQuXG4gKi9cbkNhcnRlc2lhbjIubWluaW11bUNvbXBvbmVudCA9IGZ1bmN0aW9uIChjYXJ0ZXNpYW4pIHtcbiAgLy8+PmluY2x1ZGVTdGFydCgnZGVidWcnLCBwcmFnbWFzLmRlYnVnKTtcbiAgQ2hlY2sudHlwZU9mLm9iamVjdChcImNhcnRlc2lhblwiLCBjYXJ0ZXNpYW4pO1xuICAvLz4+aW5jbHVkZUVuZCgnZGVidWcnKTtcblxuICByZXR1cm4gTWF0aC5taW4oY2FydGVzaWFuLngsIGNhcnRlc2lhbi55KTtcbn07XG5cbi8qKlxuICogQ29tcGFyZXMgdHdvIENhcnRlc2lhbnMgYW5kIGNvbXB1dGVzIGEgQ2FydGVzaWFuIHdoaWNoIGNvbnRhaW5zIHRoZSBtaW5pbXVtIGNvbXBvbmVudHMgb2YgdGhlIHN1cHBsaWVkIENhcnRlc2lhbnMuXG4gKlxuICogQHBhcmFtIHtDYXJ0ZXNpYW4yfSBmaXJzdCBBIGNhcnRlc2lhbiB0byBjb21wYXJlLlxuICogQHBhcmFtIHtDYXJ0ZXNpYW4yfSBzZWNvbmQgQSBjYXJ0ZXNpYW4gdG8gY29tcGFyZS5cbiAqIEBwYXJhbSB7Q2FydGVzaWFuMn0gcmVzdWx0IFRoZSBvYmplY3QgaW50byB3aGljaCB0byBzdG9yZSB0aGUgcmVzdWx0LlxuICogQHJldHVybnMge0NhcnRlc2lhbjJ9IEEgY2FydGVzaWFuIHdpdGggdGhlIG1pbmltdW0gY29tcG9uZW50cy5cbiAqL1xuQ2FydGVzaWFuMi5taW5pbXVtQnlDb21wb25lbnQgPSBmdW5jdGlvbiAoZmlyc3QsIHNlY29uZCwgcmVzdWx0KSB7XG4gIC8vPj5pbmNsdWRlU3RhcnQoJ2RlYnVnJywgcHJhZ21hcy5kZWJ1Zyk7XG4gIENoZWNrLnR5cGVPZi5vYmplY3QoXCJmaXJzdFwiLCBmaXJzdCk7XG4gIENoZWNrLnR5cGVPZi5vYmplY3QoXCJzZWNvbmRcIiwgc2Vjb25kKTtcbiAgQ2hlY2sudHlwZU9mLm9iamVjdChcInJlc3VsdFwiLCByZXN1bHQpO1xuICAvLz4+aW5jbHVkZUVuZCgnZGVidWcnKTtcblxuICByZXN1bHQueCA9IE1hdGgubWluKGZpcnN0LngsIHNlY29uZC54KTtcbiAgcmVzdWx0LnkgPSBNYXRoLm1pbihmaXJzdC55LCBzZWNvbmQueSk7XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbi8qKlxuICogQ29tcGFyZXMgdHdvIENhcnRlc2lhbnMgYW5kIGNvbXB1dGVzIGEgQ2FydGVzaWFuIHdoaWNoIGNvbnRhaW5zIHRoZSBtYXhpbXVtIGNvbXBvbmVudHMgb2YgdGhlIHN1cHBsaWVkIENhcnRlc2lhbnMuXG4gKlxuICogQHBhcmFtIHtDYXJ0ZXNpYW4yfSBmaXJzdCBBIGNhcnRlc2lhbiB0byBjb21wYXJlLlxuICogQHBhcmFtIHtDYXJ0ZXNpYW4yfSBzZWNvbmQgQSBjYXJ0ZXNpYW4gdG8gY29tcGFyZS5cbiAqIEBwYXJhbSB7Q2FydGVzaWFuMn0gcmVzdWx0IFRoZSBvYmplY3QgaW50byB3aGljaCB0byBzdG9yZSB0aGUgcmVzdWx0LlxuICogQHJldHVybnMge0NhcnRlc2lhbjJ9IEEgY2FydGVzaWFuIHdpdGggdGhlIG1heGltdW0gY29tcG9uZW50cy5cbiAqL1xuQ2FydGVzaWFuMi5tYXhpbXVtQnlDb21wb25lbnQgPSBmdW5jdGlvbiAoZmlyc3QsIHNlY29uZCwgcmVzdWx0KSB7XG4gIC8vPj5pbmNsdWRlU3RhcnQoJ2RlYnVnJywgcHJhZ21hcy5kZWJ1Zyk7XG4gIENoZWNrLnR5cGVPZi5vYmplY3QoXCJmaXJzdFwiLCBmaXJzdCk7XG4gIENoZWNrLnR5cGVPZi5vYmplY3QoXCJzZWNvbmRcIiwgc2Vjb25kKTtcbiAgQ2hlY2sudHlwZU9mLm9iamVjdChcInJlc3VsdFwiLCByZXN1bHQpO1xuICAvLz4+aW5jbHVkZUVuZCgnZGVidWcnKTtcblxuICByZXN1bHQueCA9IE1hdGgubWF4KGZpcnN0LngsIHNlY29uZC54KTtcbiAgcmVzdWx0LnkgPSBNYXRoLm1heChmaXJzdC55LCBzZWNvbmQueSk7XG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG4vKipcbiAqIENvbXB1dGVzIHRoZSBwcm92aWRlZCBDYXJ0ZXNpYW4ncyBzcXVhcmVkIG1hZ25pdHVkZS5cbiAqXG4gKiBAcGFyYW0ge0NhcnRlc2lhbjJ9IGNhcnRlc2lhbiBUaGUgQ2FydGVzaWFuIGluc3RhbmNlIHdob3NlIHNxdWFyZWQgbWFnbml0dWRlIGlzIHRvIGJlIGNvbXB1dGVkLlxuICogQHJldHVybnMge051bWJlcn0gVGhlIHNxdWFyZWQgbWFnbml0dWRlLlxuICovXG5DYXJ0ZXNpYW4yLm1hZ25pdHVkZVNxdWFyZWQgPSBmdW5jdGlvbiAoY2FydGVzaWFuKSB7XG4gIC8vPj5pbmNsdWRlU3RhcnQoJ2RlYnVnJywgcHJhZ21hcy5kZWJ1Zyk7XG4gIENoZWNrLnR5cGVPZi5vYmplY3QoXCJjYXJ0ZXNpYW5cIiwgY2FydGVzaWFuKTtcbiAgLy8+PmluY2x1ZGVFbmQoJ2RlYnVnJyk7XG5cbiAgcmV0dXJuIGNhcnRlc2lhbi54ICogY2FydGVzaWFuLnggKyBjYXJ0ZXNpYW4ueSAqIGNhcnRlc2lhbi55O1xufTtcblxuLyoqXG4gKiBDb21wdXRlcyB0aGUgQ2FydGVzaWFuJ3MgbWFnbml0dWRlIChsZW5ndGgpLlxuICpcbiAqIEBwYXJhbSB7Q2FydGVzaWFuMn0gY2FydGVzaWFuIFRoZSBDYXJ0ZXNpYW4gaW5zdGFuY2Ugd2hvc2UgbWFnbml0dWRlIGlzIHRvIGJlIGNvbXB1dGVkLlxuICogQHJldHVybnMge051bWJlcn0gVGhlIG1hZ25pdHVkZS5cbiAqL1xuQ2FydGVzaWFuMi5tYWduaXR1ZGUgPSBmdW5jdGlvbiAoY2FydGVzaWFuKSB7XG4gIHJldHVybiBNYXRoLnNxcnQoQ2FydGVzaWFuMi5tYWduaXR1ZGVTcXVhcmVkKGNhcnRlc2lhbikpO1xufTtcblxudmFyIGRpc3RhbmNlU2NyYXRjaCA9IG5ldyBDYXJ0ZXNpYW4yKCk7XG5cbi8qKlxuICogQ29tcHV0ZXMgdGhlIGRpc3RhbmNlIGJldHdlZW4gdHdvIHBvaW50cy5cbiAqXG4gKiBAcGFyYW0ge0NhcnRlc2lhbjJ9IGxlZnQgVGhlIGZpcnN0IHBvaW50IHRvIGNvbXB1dGUgdGhlIGRpc3RhbmNlIGZyb20uXG4gKiBAcGFyYW0ge0NhcnRlc2lhbjJ9IHJpZ2h0IFRoZSBzZWNvbmQgcG9pbnQgdG8gY29tcHV0ZSB0aGUgZGlzdGFuY2UgdG8uXG4gKiBAcmV0dXJucyB7TnVtYmVyfSBUaGUgZGlzdGFuY2UgYmV0d2VlbiB0d28gcG9pbnRzLlxuICpcbiAqIEBleGFtcGxlXG4gKiAvLyBSZXR1cm5zIDEuMFxuICogdmFyIGQgPSBDZXNpdW0uQ2FydGVzaWFuMi5kaXN0YW5jZShuZXcgQ2VzaXVtLkNhcnRlc2lhbjIoMS4wLCAwLjApLCBuZXcgQ2VzaXVtLkNhcnRlc2lhbjIoMi4wLCAwLjApKTtcbiAqL1xuQ2FydGVzaWFuMi5kaXN0YW5jZSA9IGZ1bmN0aW9uIChsZWZ0LCByaWdodCkge1xuICAvLz4+aW5jbHVkZVN0YXJ0KCdkZWJ1ZycsIHByYWdtYXMuZGVidWcpO1xuICBDaGVjay50eXBlT2Yub2JqZWN0KFwibGVmdFwiLCBsZWZ0KTtcbiAgQ2hlY2sudHlwZU9mLm9iamVjdChcInJpZ2h0XCIsIHJpZ2h0KTtcbiAgLy8+PmluY2x1ZGVFbmQoJ2RlYnVnJyk7XG5cbiAgQ2FydGVzaWFuMi5zdWJ0cmFjdChsZWZ0LCByaWdodCwgZGlzdGFuY2VTY3JhdGNoKTtcbiAgcmV0dXJuIENhcnRlc2lhbjIubWFnbml0dWRlKGRpc3RhbmNlU2NyYXRjaCk7XG59O1xuXG4vKipcbiAqIENvbXB1dGVzIHRoZSBzcXVhcmVkIGRpc3RhbmNlIGJldHdlZW4gdHdvIHBvaW50cy4gIENvbXBhcmluZyBzcXVhcmVkIGRpc3RhbmNlc1xuICogdXNpbmcgdGhpcyBmdW5jdGlvbiBpcyBtb3JlIGVmZmljaWVudCB0aGFuIGNvbXBhcmluZyBkaXN0YW5jZXMgdXNpbmcge0BsaW5rIENhcnRlc2lhbjIjZGlzdGFuY2V9LlxuICpcbiAqIEBwYXJhbSB7Q2FydGVzaWFuMn0gbGVmdCBUaGUgZmlyc3QgcG9pbnQgdG8gY29tcHV0ZSB0aGUgZGlzdGFuY2UgZnJvbS5cbiAqIEBwYXJhbSB7Q2FydGVzaWFuMn0gcmlnaHQgVGhlIHNlY29uZCBwb2ludCB0byBjb21wdXRlIHRoZSBkaXN0YW5jZSB0by5cbiAqIEByZXR1cm5zIHtOdW1iZXJ9IFRoZSBkaXN0YW5jZSBiZXR3ZWVuIHR3byBwb2ludHMuXG4gKlxuICogQGV4YW1wbGVcbiAqIC8vIFJldHVybnMgNC4wLCBub3QgMi4wXG4gKiB2YXIgZCA9IENlc2l1bS5DYXJ0ZXNpYW4yLmRpc3RhbmNlKG5ldyBDZXNpdW0uQ2FydGVzaWFuMigxLjAsIDAuMCksIG5ldyBDZXNpdW0uQ2FydGVzaWFuMigzLjAsIDAuMCkpO1xuICovXG5DYXJ0ZXNpYW4yLmRpc3RhbmNlU3F1YXJlZCA9IGZ1bmN0aW9uIChsZWZ0LCByaWdodCkge1xuICAvLz4+aW5jbHVkZVN0YXJ0KCdkZWJ1ZycsIHByYWdtYXMuZGVidWcpO1xuICBDaGVjay50eXBlT2Yub2JqZWN0KFwibGVmdFwiLCBsZWZ0KTtcbiAgQ2hlY2sudHlwZU9mLm9iamVjdChcInJpZ2h0XCIsIHJpZ2h0KTtcbiAgLy8+PmluY2x1ZGVFbmQoJ2RlYnVnJyk7XG5cbiAgQ2FydGVzaWFuMi5zdWJ0cmFjdChsZWZ0LCByaWdodCwgZGlzdGFuY2VTY3JhdGNoKTtcbiAgcmV0dXJuIENhcnRlc2lhbjIubWFnbml0dWRlU3F1YXJlZChkaXN0YW5jZVNjcmF0Y2gpO1xufTtcblxuLyoqXG4gKiBDb21wdXRlcyB0aGUgbm9ybWFsaXplZCBmb3JtIG9mIHRoZSBzdXBwbGllZCBDYXJ0ZXNpYW4uXG4gKlxuICogQHBhcmFtIHtDYXJ0ZXNpYW4yfSBjYXJ0ZXNpYW4gVGhlIENhcnRlc2lhbiB0byBiZSBub3JtYWxpemVkLlxuICogQHBhcmFtIHtDYXJ0ZXNpYW4yfSByZXN1bHQgVGhlIG9iamVjdCBvbnRvIHdoaWNoIHRvIHN0b3JlIHRoZSByZXN1bHQuXG4gKiBAcmV0dXJucyB7Q2FydGVzaWFuMn0gVGhlIG1vZGlmaWVkIHJlc3VsdCBwYXJhbWV0ZXIuXG4gKi9cbkNhcnRlc2lhbjIubm9ybWFsaXplID0gZnVuY3Rpb24gKGNhcnRlc2lhbiwgcmVzdWx0KSB7XG4gIC8vPj5pbmNsdWRlU3RhcnQoJ2RlYnVnJywgcHJhZ21hcy5kZWJ1Zyk7XG4gIENoZWNrLnR5cGVPZi5vYmplY3QoXCJjYXJ0ZXNpYW5cIiwgY2FydGVzaWFuKTtcbiAgQ2hlY2sudHlwZU9mLm9iamVjdChcInJlc3VsdFwiLCByZXN1bHQpO1xuICAvLz4+aW5jbHVkZUVuZCgnZGVidWcnKTtcblxuICB2YXIgbWFnbml0dWRlID0gQ2FydGVzaWFuMi5tYWduaXR1ZGUoY2FydGVzaWFuKTtcblxuICByZXN1bHQueCA9IGNhcnRlc2lhbi54IC8gbWFnbml0dWRlO1xuICByZXN1bHQueSA9IGNhcnRlc2lhbi55IC8gbWFnbml0dWRlO1xuXG4gIC8vPj5pbmNsdWRlU3RhcnQoJ2RlYnVnJywgcHJhZ21hcy5kZWJ1Zyk7XG4gIGlmIChpc05hTihyZXN1bHQueCkgfHwgaXNOYU4ocmVzdWx0LnkpKSB7XG4gICAgdGhyb3cgbmV3IERldmVsb3BlckVycm9yKFwibm9ybWFsaXplZCByZXN1bHQgaXMgbm90IGEgbnVtYmVyXCIpO1xuICB9XG4gIC8vPj5pbmNsdWRlRW5kKCdkZWJ1ZycpO1xuXG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG4vKipcbiAqIENvbXB1dGVzIHRoZSBkb3QgKHNjYWxhcikgcHJvZHVjdCBvZiB0d28gQ2FydGVzaWFucy5cbiAqXG4gKiBAcGFyYW0ge0NhcnRlc2lhbjJ9IGxlZnQgVGhlIGZpcnN0IENhcnRlc2lhbi5cbiAqIEBwYXJhbSB7Q2FydGVzaWFuMn0gcmlnaHQgVGhlIHNlY29uZCBDYXJ0ZXNpYW4uXG4gKiBAcmV0dXJucyB7TnVtYmVyfSBUaGUgZG90IHByb2R1Y3QuXG4gKi9cbkNhcnRlc2lhbjIuZG90ID0gZnVuY3Rpb24gKGxlZnQsIHJpZ2h0KSB7XG4gIC8vPj5pbmNsdWRlU3RhcnQoJ2RlYnVnJywgcHJhZ21hcy5kZWJ1Zyk7XG4gIENoZWNrLnR5cGVPZi5vYmplY3QoXCJsZWZ0XCIsIGxlZnQpO1xuICBDaGVjay50eXBlT2Yub2JqZWN0KFwicmlnaHRcIiwgcmlnaHQpO1xuICAvLz4+aW5jbHVkZUVuZCgnZGVidWcnKTtcblxuICByZXR1cm4gbGVmdC54ICogcmlnaHQueCArIGxlZnQueSAqIHJpZ2h0Lnk7XG59O1xuXG4vKipcbiAqIENvbXB1dGVzIHRoZSBtYWduaXR1ZGUgb2YgdGhlIGNyb3NzIHByb2R1Y3QgdGhhdCB3b3VsZCByZXN1bHQgZnJvbSBpbXBsaWNpdGx5IHNldHRpbmcgdGhlIFogY29vcmRpbmF0ZSBvZiB0aGUgaW5wdXQgdmVjdG9ycyB0byAwXG4gKlxuICogQHBhcmFtIHtDYXJ0ZXNpYW4yfSBsZWZ0IFRoZSBmaXJzdCBDYXJ0ZXNpYW4uXG4gKiBAcGFyYW0ge0NhcnRlc2lhbjJ9IHJpZ2h0IFRoZSBzZWNvbmQgQ2FydGVzaWFuLlxuICogQHJldHVybnMge051bWJlcn0gVGhlIGNyb3NzIHByb2R1Y3QuXG4gKi9cbkNhcnRlc2lhbjIuY3Jvc3MgPSBmdW5jdGlvbiAobGVmdCwgcmlnaHQpIHtcbiAgLy8+PmluY2x1ZGVTdGFydCgnZGVidWcnLCBwcmFnbWFzLmRlYnVnKTtcbiAgQ2hlY2sudHlwZU9mLm9iamVjdChcImxlZnRcIiwgbGVmdCk7XG4gIENoZWNrLnR5cGVPZi5vYmplY3QoXCJyaWdodFwiLCByaWdodCk7XG4gIC8vPj5pbmNsdWRlRW5kKCdkZWJ1ZycpO1xuXG4gIHJldHVybiBsZWZ0LnggKiByaWdodC55IC0gbGVmdC55ICogcmlnaHQueDtcbn07XG5cbi8qKlxuICogQ29tcHV0ZXMgdGhlIGNvbXBvbmVudHdpc2UgcHJvZHVjdCBvZiB0d28gQ2FydGVzaWFucy5cbiAqXG4gKiBAcGFyYW0ge0NhcnRlc2lhbjJ9IGxlZnQgVGhlIGZpcnN0IENhcnRlc2lhbi5cbiAqIEBwYXJhbSB7Q2FydGVzaWFuMn0gcmlnaHQgVGhlIHNlY29uZCBDYXJ0ZXNpYW4uXG4gKiBAcGFyYW0ge0NhcnRlc2lhbjJ9IHJlc3VsdCBUaGUgb2JqZWN0IG9udG8gd2hpY2ggdG8gc3RvcmUgdGhlIHJlc3VsdC5cbiAqIEByZXR1cm5zIHtDYXJ0ZXNpYW4yfSBUaGUgbW9kaWZpZWQgcmVzdWx0IHBhcmFtZXRlci5cbiAqL1xuQ2FydGVzaWFuMi5tdWx0aXBseUNvbXBvbmVudHMgPSBmdW5jdGlvbiAobGVmdCwgcmlnaHQsIHJlc3VsdCkge1xuICAvLz4+aW5jbHVkZVN0YXJ0KCdkZWJ1ZycsIHByYWdtYXMuZGVidWcpO1xuICBDaGVjay50eXBlT2Yub2JqZWN0KFwibGVmdFwiLCBsZWZ0KTtcbiAgQ2hlY2sudHlwZU9mLm9iamVjdChcInJpZ2h0XCIsIHJpZ2h0KTtcbiAgQ2hlY2sudHlwZU9mLm9iamVjdChcInJlc3VsdFwiLCByZXN1bHQpO1xuICAvLz4+aW5jbHVkZUVuZCgnZGVidWcnKTtcblxuICByZXN1bHQueCA9IGxlZnQueCAqIHJpZ2h0Lng7XG4gIHJlc3VsdC55ID0gbGVmdC55ICogcmlnaHQueTtcbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbi8qKlxuICogQ29tcHV0ZXMgdGhlIGNvbXBvbmVudHdpc2UgcXVvdGllbnQgb2YgdHdvIENhcnRlc2lhbnMuXG4gKlxuICogQHBhcmFtIHtDYXJ0ZXNpYW4yfSBsZWZ0IFRoZSBmaXJzdCBDYXJ0ZXNpYW4uXG4gKiBAcGFyYW0ge0NhcnRlc2lhbjJ9IHJpZ2h0IFRoZSBzZWNvbmQgQ2FydGVzaWFuLlxuICogQHBhcmFtIHtDYXJ0ZXNpYW4yfSByZXN1bHQgVGhlIG9iamVjdCBvbnRvIHdoaWNoIHRvIHN0b3JlIHRoZSByZXN1bHQuXG4gKiBAcmV0dXJucyB7Q2FydGVzaWFuMn0gVGhlIG1vZGlmaWVkIHJlc3VsdCBwYXJhbWV0ZXIuXG4gKi9cbkNhcnRlc2lhbjIuZGl2aWRlQ29tcG9uZW50cyA9IGZ1bmN0aW9uIChsZWZ0LCByaWdodCwgcmVzdWx0KSB7XG4gIC8vPj5pbmNsdWRlU3RhcnQoJ2RlYnVnJywgcHJhZ21hcy5kZWJ1Zyk7XG4gIENoZWNrLnR5cGVPZi5vYmplY3QoXCJsZWZ0XCIsIGxlZnQpO1xuICBDaGVjay50eXBlT2Yub2JqZWN0KFwicmlnaHRcIiwgcmlnaHQpO1xuICBDaGVjay50eXBlT2Yub2JqZWN0KFwicmVzdWx0XCIsIHJlc3VsdCk7XG4gIC8vPj5pbmNsdWRlRW5kKCdkZWJ1ZycpO1xuXG4gIHJlc3VsdC54ID0gbGVmdC54IC8gcmlnaHQueDtcbiAgcmVzdWx0LnkgPSBsZWZ0LnkgLyByaWdodC55O1xuICByZXR1cm4gcmVzdWx0O1xufTtcblxuLyoqXG4gKiBDb21wdXRlcyB0aGUgY29tcG9uZW50d2lzZSBzdW0gb2YgdHdvIENhcnRlc2lhbnMuXG4gKlxuICogQHBhcmFtIHtDYXJ0ZXNpYW4yfSBsZWZ0IFRoZSBmaXJzdCBDYXJ0ZXNpYW4uXG4gKiBAcGFyYW0ge0NhcnRlc2lhbjJ9IHJpZ2h0IFRoZSBzZWNvbmQgQ2FydGVzaWFuLlxuICogQHBhcmFtIHtDYXJ0ZXNpYW4yfSByZXN1bHQgVGhlIG9iamVjdCBvbnRvIHdoaWNoIHRvIHN0b3JlIHRoZSByZXN1bHQuXG4gKiBAcmV0dXJucyB7Q2FydGVzaWFuMn0gVGhlIG1vZGlmaWVkIHJlc3VsdCBwYXJhbWV0ZXIuXG4gKi9cbkNhcnRlc2lhbjIuYWRkID0gZnVuY3Rpb24gKGxlZnQsIHJpZ2h0LCByZXN1bHQpIHtcbiAgLy8+PmluY2x1ZGVTdGFydCgnZGVidWcnLCBwcmFnbWFzLmRlYnVnKTtcbiAgQ2hlY2sudHlwZU9mLm9iamVjdChcImxlZnRcIiwgbGVmdCk7XG4gIENoZWNrLnR5cGVPZi5vYmplY3QoXCJyaWdodFwiLCByaWdodCk7XG4gIENoZWNrLnR5cGVPZi5vYmplY3QoXCJyZXN1bHRcIiwgcmVzdWx0KTtcbiAgLy8+PmluY2x1ZGVFbmQoJ2RlYnVnJyk7XG5cbiAgcmVzdWx0LnggPSBsZWZ0LnggKyByaWdodC54O1xuICByZXN1bHQueSA9IGxlZnQueSArIHJpZ2h0Lnk7XG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG4vKipcbiAqIENvbXB1dGVzIHRoZSBjb21wb25lbnR3aXNlIGRpZmZlcmVuY2Ugb2YgdHdvIENhcnRlc2lhbnMuXG4gKlxuICogQHBhcmFtIHtDYXJ0ZXNpYW4yfSBsZWZ0IFRoZSBmaXJzdCBDYXJ0ZXNpYW4uXG4gKiBAcGFyYW0ge0NhcnRlc2lhbjJ9IHJpZ2h0IFRoZSBzZWNvbmQgQ2FydGVzaWFuLlxuICogQHBhcmFtIHtDYXJ0ZXNpYW4yfSByZXN1bHQgVGhlIG9iamVjdCBvbnRvIHdoaWNoIHRvIHN0b3JlIHRoZSByZXN1bHQuXG4gKiBAcmV0dXJucyB7Q2FydGVzaWFuMn0gVGhlIG1vZGlmaWVkIHJlc3VsdCBwYXJhbWV0ZXIuXG4gKi9cbkNhcnRlc2lhbjIuc3VidHJhY3QgPSBmdW5jdGlvbiAobGVmdCwgcmlnaHQsIHJlc3VsdCkge1xuICAvLz4+aW5jbHVkZVN0YXJ0KCdkZWJ1ZycsIHByYWdtYXMuZGVidWcpO1xuICBDaGVjay50eXBlT2Yub2JqZWN0KFwibGVmdFwiLCBsZWZ0KTtcbiAgQ2hlY2sudHlwZU9mLm9iamVjdChcInJpZ2h0XCIsIHJpZ2h0KTtcbiAgQ2hlY2sudHlwZU9mLm9iamVjdChcInJlc3VsdFwiLCByZXN1bHQpO1xuICAvLz4+aW5jbHVkZUVuZCgnZGVidWcnKTtcblxuICByZXN1bHQueCA9IGxlZnQueCAtIHJpZ2h0Lng7XG4gIHJlc3VsdC55ID0gbGVmdC55IC0gcmlnaHQueTtcbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbi8qKlxuICogTXVsdGlwbGllcyB0aGUgcHJvdmlkZWQgQ2FydGVzaWFuIGNvbXBvbmVudHdpc2UgYnkgdGhlIHByb3ZpZGVkIHNjYWxhci5cbiAqXG4gKiBAcGFyYW0ge0NhcnRlc2lhbjJ9IGNhcnRlc2lhbiBUaGUgQ2FydGVzaWFuIHRvIGJlIHNjYWxlZC5cbiAqIEBwYXJhbSB7TnVtYmVyfSBzY2FsYXIgVGhlIHNjYWxhciB0byBtdWx0aXBseSB3aXRoLlxuICogQHBhcmFtIHtDYXJ0ZXNpYW4yfSByZXN1bHQgVGhlIG9iamVjdCBvbnRvIHdoaWNoIHRvIHN0b3JlIHRoZSByZXN1bHQuXG4gKiBAcmV0dXJucyB7Q2FydGVzaWFuMn0gVGhlIG1vZGlmaWVkIHJlc3VsdCBwYXJhbWV0ZXIuXG4gKi9cbkNhcnRlc2lhbjIubXVsdGlwbHlCeVNjYWxhciA9IGZ1bmN0aW9uIChjYXJ0ZXNpYW4sIHNjYWxhciwgcmVzdWx0KSB7XG4gIC8vPj5pbmNsdWRlU3RhcnQoJ2RlYnVnJywgcHJhZ21hcy5kZWJ1Zyk7XG4gIENoZWNrLnR5cGVPZi5vYmplY3QoXCJjYXJ0ZXNpYW5cIiwgY2FydGVzaWFuKTtcbiAgQ2hlY2sudHlwZU9mLm51bWJlcihcInNjYWxhclwiLCBzY2FsYXIpO1xuICBDaGVjay50eXBlT2Yub2JqZWN0KFwicmVzdWx0XCIsIHJlc3VsdCk7XG4gIC8vPj5pbmNsdWRlRW5kKCdkZWJ1ZycpO1xuXG4gIHJlc3VsdC54ID0gY2FydGVzaWFuLnggKiBzY2FsYXI7XG4gIHJlc3VsdC55ID0gY2FydGVzaWFuLnkgKiBzY2FsYXI7XG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG4vKipcbiAqIERpdmlkZXMgdGhlIHByb3ZpZGVkIENhcnRlc2lhbiBjb21wb25lbnR3aXNlIGJ5IHRoZSBwcm92aWRlZCBzY2FsYXIuXG4gKlxuICogQHBhcmFtIHtDYXJ0ZXNpYW4yfSBjYXJ0ZXNpYW4gVGhlIENhcnRlc2lhbiB0byBiZSBkaXZpZGVkLlxuICogQHBhcmFtIHtOdW1iZXJ9IHNjYWxhciBUaGUgc2NhbGFyIHRvIGRpdmlkZSBieS5cbiAqIEBwYXJhbSB7Q2FydGVzaWFuMn0gcmVzdWx0IFRoZSBvYmplY3Qgb250byB3aGljaCB0byBzdG9yZSB0aGUgcmVzdWx0LlxuICogQHJldHVybnMge0NhcnRlc2lhbjJ9IFRoZSBtb2RpZmllZCByZXN1bHQgcGFyYW1ldGVyLlxuICovXG5DYXJ0ZXNpYW4yLmRpdmlkZUJ5U2NhbGFyID0gZnVuY3Rpb24gKGNhcnRlc2lhbiwgc2NhbGFyLCByZXN1bHQpIHtcbiAgLy8+PmluY2x1ZGVTdGFydCgnZGVidWcnLCBwcmFnbWFzLmRlYnVnKTtcbiAgQ2hlY2sudHlwZU9mLm9iamVjdChcImNhcnRlc2lhblwiLCBjYXJ0ZXNpYW4pO1xuICBDaGVjay50eXBlT2YubnVtYmVyKFwic2NhbGFyXCIsIHNjYWxhcik7XG4gIENoZWNrLnR5cGVPZi5vYmplY3QoXCJyZXN1bHRcIiwgcmVzdWx0KTtcbiAgLy8+PmluY2x1ZGVFbmQoJ2RlYnVnJyk7XG5cbiAgcmVzdWx0LnggPSBjYXJ0ZXNpYW4ueCAvIHNjYWxhcjtcbiAgcmVzdWx0LnkgPSBjYXJ0ZXNpYW4ueSAvIHNjYWxhcjtcbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbi8qKlxuICogTmVnYXRlcyB0aGUgcHJvdmlkZWQgQ2FydGVzaWFuLlxuICpcbiAqIEBwYXJhbSB7Q2FydGVzaWFuMn0gY2FydGVzaWFuIFRoZSBDYXJ0ZXNpYW4gdG8gYmUgbmVnYXRlZC5cbiAqIEBwYXJhbSB7Q2FydGVzaWFuMn0gcmVzdWx0IFRoZSBvYmplY3Qgb250byB3aGljaCB0byBzdG9yZSB0aGUgcmVzdWx0LlxuICogQHJldHVybnMge0NhcnRlc2lhbjJ9IFRoZSBtb2RpZmllZCByZXN1bHQgcGFyYW1ldGVyLlxuICovXG5DYXJ0ZXNpYW4yLm5lZ2F0ZSA9IGZ1bmN0aW9uIChjYXJ0ZXNpYW4sIHJlc3VsdCkge1xuICAvLz4+aW5jbHVkZVN0YXJ0KCdkZWJ1ZycsIHByYWdtYXMuZGVidWcpO1xuICBDaGVjay50eXBlT2Yub2JqZWN0KFwiY2FydGVzaWFuXCIsIGNhcnRlc2lhbik7XG4gIENoZWNrLnR5cGVPZi5vYmplY3QoXCJyZXN1bHRcIiwgcmVzdWx0KTtcbiAgLy8+PmluY2x1ZGVFbmQoJ2RlYnVnJyk7XG5cbiAgcmVzdWx0LnggPSAtY2FydGVzaWFuLng7XG4gIHJlc3VsdC55ID0gLWNhcnRlc2lhbi55O1xuICByZXR1cm4gcmVzdWx0O1xufTtcblxuLyoqXG4gKiBDb21wdXRlcyB0aGUgYWJzb2x1dGUgdmFsdWUgb2YgdGhlIHByb3ZpZGVkIENhcnRlc2lhbi5cbiAqXG4gKiBAcGFyYW0ge0NhcnRlc2lhbjJ9IGNhcnRlc2lhbiBUaGUgQ2FydGVzaWFuIHdob3NlIGFic29sdXRlIHZhbHVlIGlzIHRvIGJlIGNvbXB1dGVkLlxuICogQHBhcmFtIHtDYXJ0ZXNpYW4yfSByZXN1bHQgVGhlIG9iamVjdCBvbnRvIHdoaWNoIHRvIHN0b3JlIHRoZSByZXN1bHQuXG4gKiBAcmV0dXJucyB7Q2FydGVzaWFuMn0gVGhlIG1vZGlmaWVkIHJlc3VsdCBwYXJhbWV0ZXIuXG4gKi9cbkNhcnRlc2lhbjIuYWJzID0gZnVuY3Rpb24gKGNhcnRlc2lhbiwgcmVzdWx0KSB7XG4gIC8vPj5pbmNsdWRlU3RhcnQoJ2RlYnVnJywgcHJhZ21hcy5kZWJ1Zyk7XG4gIENoZWNrLnR5cGVPZi5vYmplY3QoXCJjYXJ0ZXNpYW5cIiwgY2FydGVzaWFuKTtcbiAgQ2hlY2sudHlwZU9mLm9iamVjdChcInJlc3VsdFwiLCByZXN1bHQpO1xuICAvLz4+aW5jbHVkZUVuZCgnZGVidWcnKTtcblxuICByZXN1bHQueCA9IE1hdGguYWJzKGNhcnRlc2lhbi54KTtcbiAgcmVzdWx0LnkgPSBNYXRoLmFicyhjYXJ0ZXNpYW4ueSk7XG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG52YXIgbGVycFNjcmF0Y2ggPSBuZXcgQ2FydGVzaWFuMigpO1xuLyoqXG4gKiBDb21wdXRlcyB0aGUgbGluZWFyIGludGVycG9sYXRpb24gb3IgZXh0cmFwb2xhdGlvbiBhdCB0IHVzaW5nIHRoZSBwcm92aWRlZCBjYXJ0ZXNpYW5zLlxuICpcbiAqIEBwYXJhbSB7Q2FydGVzaWFuMn0gc3RhcnQgVGhlIHZhbHVlIGNvcnJlc3BvbmRpbmcgdG8gdCBhdCAwLjAuXG4gKiBAcGFyYW0ge0NhcnRlc2lhbjJ9IGVuZCBUaGUgdmFsdWUgY29ycmVzcG9uZGluZyB0byB0IGF0IDEuMC5cbiAqIEBwYXJhbSB7TnVtYmVyfSB0IFRoZSBwb2ludCBhbG9uZyB0IGF0IHdoaWNoIHRvIGludGVycG9sYXRlLlxuICogQHBhcmFtIHtDYXJ0ZXNpYW4yfSByZXN1bHQgVGhlIG9iamVjdCBvbnRvIHdoaWNoIHRvIHN0b3JlIHRoZSByZXN1bHQuXG4gKiBAcmV0dXJucyB7Q2FydGVzaWFuMn0gVGhlIG1vZGlmaWVkIHJlc3VsdCBwYXJhbWV0ZXIuXG4gKi9cbkNhcnRlc2lhbjIubGVycCA9IGZ1bmN0aW9uIChzdGFydCwgZW5kLCB0LCByZXN1bHQpIHtcbiAgLy8+PmluY2x1ZGVTdGFydCgnZGVidWcnLCBwcmFnbWFzLmRlYnVnKTtcbiAgQ2hlY2sudHlwZU9mLm9iamVjdChcInN0YXJ0XCIsIHN0YXJ0KTtcbiAgQ2hlY2sudHlwZU9mLm9iamVjdChcImVuZFwiLCBlbmQpO1xuICBDaGVjay50eXBlT2YubnVtYmVyKFwidFwiLCB0KTtcbiAgQ2hlY2sudHlwZU9mLm9iamVjdChcInJlc3VsdFwiLCByZXN1bHQpO1xuICAvLz4+aW5jbHVkZUVuZCgnZGVidWcnKTtcblxuICBDYXJ0ZXNpYW4yLm11bHRpcGx5QnlTY2FsYXIoZW5kLCB0LCBsZXJwU2NyYXRjaCk7XG4gIHJlc3VsdCA9IENhcnRlc2lhbjIubXVsdGlwbHlCeVNjYWxhcihzdGFydCwgMS4wIC0gdCwgcmVzdWx0KTtcbiAgcmV0dXJuIENhcnRlc2lhbjIuYWRkKGxlcnBTY3JhdGNoLCByZXN1bHQsIHJlc3VsdCk7XG59O1xuXG52YXIgYW5nbGVCZXR3ZWVuU2NyYXRjaCA9IG5ldyBDYXJ0ZXNpYW4yKCk7XG52YXIgYW5nbGVCZXR3ZWVuU2NyYXRjaDIgPSBuZXcgQ2FydGVzaWFuMigpO1xuLyoqXG4gKiBSZXR1cm5zIHRoZSBhbmdsZSwgaW4gcmFkaWFucywgYmV0d2VlbiB0aGUgcHJvdmlkZWQgQ2FydGVzaWFucy5cbiAqXG4gKiBAcGFyYW0ge0NhcnRlc2lhbjJ9IGxlZnQgVGhlIGZpcnN0IENhcnRlc2lhbi5cbiAqIEBwYXJhbSB7Q2FydGVzaWFuMn0gcmlnaHQgVGhlIHNlY29uZCBDYXJ0ZXNpYW4uXG4gKiBAcmV0dXJucyB7TnVtYmVyfSBUaGUgYW5nbGUgYmV0d2VlbiB0aGUgQ2FydGVzaWFucy5cbiAqL1xuQ2FydGVzaWFuMi5hbmdsZUJldHdlZW4gPSBmdW5jdGlvbiAobGVmdCwgcmlnaHQpIHtcbiAgLy8+PmluY2x1ZGVTdGFydCgnZGVidWcnLCBwcmFnbWFzLmRlYnVnKTtcbiAgQ2hlY2sudHlwZU9mLm9iamVjdChcImxlZnRcIiwgbGVmdCk7XG4gIENoZWNrLnR5cGVPZi5vYmplY3QoXCJyaWdodFwiLCByaWdodCk7XG4gIC8vPj5pbmNsdWRlRW5kKCdkZWJ1ZycpO1xuXG4gIENhcnRlc2lhbjIubm9ybWFsaXplKGxlZnQsIGFuZ2xlQmV0d2VlblNjcmF0Y2gpO1xuICBDYXJ0ZXNpYW4yLm5vcm1hbGl6ZShyaWdodCwgYW5nbGVCZXR3ZWVuU2NyYXRjaDIpO1xuICByZXR1cm4gQ2VzaXVtTWF0aC5hY29zQ2xhbXBlZChcbiAgICBDYXJ0ZXNpYW4yLmRvdChhbmdsZUJldHdlZW5TY3JhdGNoLCBhbmdsZUJldHdlZW5TY3JhdGNoMilcbiAgKTtcbn07XG5cbnZhciBtb3N0T3J0aG9nb25hbEF4aXNTY3JhdGNoID0gbmV3IENhcnRlc2lhbjIoKTtcbi8qKlxuICogUmV0dXJucyB0aGUgYXhpcyB0aGF0IGlzIG1vc3Qgb3J0aG9nb25hbCB0byB0aGUgcHJvdmlkZWQgQ2FydGVzaWFuLlxuICpcbiAqIEBwYXJhbSB7Q2FydGVzaWFuMn0gY2FydGVzaWFuIFRoZSBDYXJ0ZXNpYW4gb24gd2hpY2ggdG8gZmluZCB0aGUgbW9zdCBvcnRob2dvbmFsIGF4aXMuXG4gKiBAcGFyYW0ge0NhcnRlc2lhbjJ9IHJlc3VsdCBUaGUgb2JqZWN0IG9udG8gd2hpY2ggdG8gc3RvcmUgdGhlIHJlc3VsdC5cbiAqIEByZXR1cm5zIHtDYXJ0ZXNpYW4yfSBUaGUgbW9zdCBvcnRob2dvbmFsIGF4aXMuXG4gKi9cbkNhcnRlc2lhbjIubW9zdE9ydGhvZ29uYWxBeGlzID0gZnVuY3Rpb24gKGNhcnRlc2lhbiwgcmVzdWx0KSB7XG4gIC8vPj5pbmNsdWRlU3RhcnQoJ2RlYnVnJywgcHJhZ21hcy5kZWJ1Zyk7XG4gIENoZWNrLnR5cGVPZi5vYmplY3QoXCJjYXJ0ZXNpYW5cIiwgY2FydGVzaWFuKTtcbiAgQ2hlY2sudHlwZU9mLm9iamVjdChcInJlc3VsdFwiLCByZXN1bHQpO1xuICAvLz4+aW5jbHVkZUVuZCgnZGVidWcnKTtcblxuICB2YXIgZiA9IENhcnRlc2lhbjIubm9ybWFsaXplKGNhcnRlc2lhbiwgbW9zdE9ydGhvZ29uYWxBeGlzU2NyYXRjaCk7XG4gIENhcnRlc2lhbjIuYWJzKGYsIGYpO1xuXG4gIGlmIChmLnggPD0gZi55KSB7XG4gICAgcmVzdWx0ID0gQ2FydGVzaWFuMi5jbG9uZShDYXJ0ZXNpYW4yLlVOSVRfWCwgcmVzdWx0KTtcbiAgfSBlbHNlIHtcbiAgICByZXN1bHQgPSBDYXJ0ZXNpYW4yLmNsb25lKENhcnRlc2lhbjIuVU5JVF9ZLCByZXN1bHQpO1xuICB9XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbi8qKlxuICogQ29tcGFyZXMgdGhlIHByb3ZpZGVkIENhcnRlc2lhbnMgY29tcG9uZW50d2lzZSBhbmQgcmV0dXJuc1xuICogPGNvZGU+dHJ1ZTwvY29kZT4gaWYgdGhleSBhcmUgZXF1YWwsIDxjb2RlPmZhbHNlPC9jb2RlPiBvdGhlcndpc2UuXG4gKlxuICogQHBhcmFtIHtDYXJ0ZXNpYW4yfSBbbGVmdF0gVGhlIGZpcnN0IENhcnRlc2lhbi5cbiAqIEBwYXJhbSB7Q2FydGVzaWFuMn0gW3JpZ2h0XSBUaGUgc2Vjb25kIENhcnRlc2lhbi5cbiAqIEByZXR1cm5zIHtCb29sZWFufSA8Y29kZT50cnVlPC9jb2RlPiBpZiBsZWZ0IGFuZCByaWdodCBhcmUgZXF1YWwsIDxjb2RlPmZhbHNlPC9jb2RlPiBvdGhlcndpc2UuXG4gKi9cbkNhcnRlc2lhbjIuZXF1YWxzID0gZnVuY3Rpb24gKGxlZnQsIHJpZ2h0KSB7XG4gIHJldHVybiAoXG4gICAgbGVmdCA9PT0gcmlnaHQgfHxcbiAgICAoZGVmaW5lZChsZWZ0KSAmJlxuICAgICAgZGVmaW5lZChyaWdodCkgJiZcbiAgICAgIGxlZnQueCA9PT0gcmlnaHQueCAmJlxuICAgICAgbGVmdC55ID09PSByaWdodC55KVxuICApO1xufTtcblxuLyoqXG4gKiBAcHJpdmF0ZVxuICovXG5DYXJ0ZXNpYW4yLmVxdWFsc0FycmF5ID0gZnVuY3Rpb24gKGNhcnRlc2lhbiwgYXJyYXksIG9mZnNldCkge1xuICByZXR1cm4gY2FydGVzaWFuLnggPT09IGFycmF5W29mZnNldF0gJiYgY2FydGVzaWFuLnkgPT09IGFycmF5W29mZnNldCArIDFdO1xufTtcblxuLyoqXG4gKiBDb21wYXJlcyB0aGUgcHJvdmlkZWQgQ2FydGVzaWFucyBjb21wb25lbnR3aXNlIGFuZCByZXR1cm5zXG4gKiA8Y29kZT50cnVlPC9jb2RlPiBpZiB0aGV5IHBhc3MgYW4gYWJzb2x1dGUgb3IgcmVsYXRpdmUgdG9sZXJhbmNlIHRlc3QsXG4gKiA8Y29kZT5mYWxzZTwvY29kZT4gb3RoZXJ3aXNlLlxuICpcbiAqIEBwYXJhbSB7Q2FydGVzaWFuMn0gW2xlZnRdIFRoZSBmaXJzdCBDYXJ0ZXNpYW4uXG4gKiBAcGFyYW0ge0NhcnRlc2lhbjJ9IFtyaWdodF0gVGhlIHNlY29uZCBDYXJ0ZXNpYW4uXG4gKiBAcGFyYW0ge051bWJlcn0gW3JlbGF0aXZlRXBzaWxvbj0wXSBUaGUgcmVsYXRpdmUgZXBzaWxvbiB0b2xlcmFuY2UgdG8gdXNlIGZvciBlcXVhbGl0eSB0ZXN0aW5nLlxuICogQHBhcmFtIHtOdW1iZXJ9IFthYnNvbHV0ZUVwc2lsb249cmVsYXRpdmVFcHNpbG9uXSBUaGUgYWJzb2x1dGUgZXBzaWxvbiB0b2xlcmFuY2UgdG8gdXNlIGZvciBlcXVhbGl0eSB0ZXN0aW5nLlxuICogQHJldHVybnMge0Jvb2xlYW59IDxjb2RlPnRydWU8L2NvZGU+IGlmIGxlZnQgYW5kIHJpZ2h0IGFyZSB3aXRoaW4gdGhlIHByb3ZpZGVkIGVwc2lsb24sIDxjb2RlPmZhbHNlPC9jb2RlPiBvdGhlcndpc2UuXG4gKi9cbkNhcnRlc2lhbjIuZXF1YWxzRXBzaWxvbiA9IGZ1bmN0aW9uIChcbiAgbGVmdCxcbiAgcmlnaHQsXG4gIHJlbGF0aXZlRXBzaWxvbixcbiAgYWJzb2x1dGVFcHNpbG9uXG4pIHtcbiAgcmV0dXJuIChcbiAgICBsZWZ0ID09PSByaWdodCB8fFxuICAgIChkZWZpbmVkKGxlZnQpICYmXG4gICAgICBkZWZpbmVkKHJpZ2h0KSAmJlxuICAgICAgQ2VzaXVtTWF0aC5lcXVhbHNFcHNpbG9uKFxuICAgICAgICBsZWZ0LngsXG4gICAgICAgIHJpZ2h0LngsXG4gICAgICAgIHJlbGF0aXZlRXBzaWxvbixcbiAgICAgICAgYWJzb2x1dGVFcHNpbG9uXG4gICAgICApICYmXG4gICAgICBDZXNpdW1NYXRoLmVxdWFsc0Vwc2lsb24oXG4gICAgICAgIGxlZnQueSxcbiAgICAgICAgcmlnaHQueSxcbiAgICAgICAgcmVsYXRpdmVFcHNpbG9uLFxuICAgICAgICBhYnNvbHV0ZUVwc2lsb25cbiAgICAgICkpXG4gICk7XG59O1xuXG4vKipcbiAqIEFuIGltbXV0YWJsZSBDYXJ0ZXNpYW4yIGluc3RhbmNlIGluaXRpYWxpemVkIHRvICgwLjAsIDAuMCkuXG4gKlxuICogQHR5cGUge0NhcnRlc2lhbjJ9XG4gKiBAY29uc3RhbnRcbiAqL1xuQ2FydGVzaWFuMi5aRVJPID0gT2JqZWN0LmZyZWV6ZShuZXcgQ2FydGVzaWFuMigwLjAsIDAuMCkpO1xuXG4vKipcbiAqIEFuIGltbXV0YWJsZSBDYXJ0ZXNpYW4yIGluc3RhbmNlIGluaXRpYWxpemVkIHRvICgxLjAsIDEuMCkuXG4gKlxuICogQHR5cGUge0NhcnRlc2lhbjJ9XG4gKiBAY29uc3RhbnRcbiAqL1xuQ2FydGVzaWFuMi5PTkUgPSBPYmplY3QuZnJlZXplKG5ldyBDYXJ0ZXNpYW4yKDEuMCwgMS4wKSk7XG5cbi8qKlxuICogQW4gaW1tdXRhYmxlIENhcnRlc2lhbjIgaW5zdGFuY2UgaW5pdGlhbGl6ZWQgdG8gKDEuMCwgMC4wKS5cbiAqXG4gKiBAdHlwZSB7Q2FydGVzaWFuMn1cbiAqIEBjb25zdGFudFxuICovXG5DYXJ0ZXNpYW4yLlVOSVRfWCA9IE9iamVjdC5mcmVlemUobmV3IENhcnRlc2lhbjIoMS4wLCAwLjApKTtcblxuLyoqXG4gKiBBbiBpbW11dGFibGUgQ2FydGVzaWFuMiBpbnN0YW5jZSBpbml0aWFsaXplZCB0byAoMC4wLCAxLjApLlxuICpcbiAqIEB0eXBlIHtDYXJ0ZXNpYW4yfVxuICogQGNvbnN0YW50XG4gKi9cbkNhcnRlc2lhbjIuVU5JVF9ZID0gT2JqZWN0LmZyZWV6ZShuZXcgQ2FydGVzaWFuMigwLjAsIDEuMCkpO1xuXG4vKipcbiAqIER1cGxpY2F0ZXMgdGhpcyBDYXJ0ZXNpYW4yIGluc3RhbmNlLlxuICpcbiAqIEBwYXJhbSB7Q2FydGVzaWFuMn0gW3Jlc3VsdF0gVGhlIG9iamVjdCBvbnRvIHdoaWNoIHRvIHN0b3JlIHRoZSByZXN1bHQuXG4gKiBAcmV0dXJucyB7Q2FydGVzaWFuMn0gVGhlIG1vZGlmaWVkIHJlc3VsdCBwYXJhbWV0ZXIgb3IgYSBuZXcgQ2FydGVzaWFuMiBpbnN0YW5jZSBpZiBvbmUgd2FzIG5vdCBwcm92aWRlZC5cbiAqL1xuQ2FydGVzaWFuMi5wcm90b3R5cGUuY2xvbmUgPSBmdW5jdGlvbiAocmVzdWx0KSB7XG4gIHJldHVybiBDYXJ0ZXNpYW4yLmNsb25lKHRoaXMsIHJlc3VsdCk7XG59O1xuXG4vKipcbiAqIENvbXBhcmVzIHRoaXMgQ2FydGVzaWFuIGFnYWluc3QgdGhlIHByb3ZpZGVkIENhcnRlc2lhbiBjb21wb25lbnR3aXNlIGFuZCByZXR1cm5zXG4gKiA8Y29kZT50cnVlPC9jb2RlPiBpZiB0aGV5IGFyZSBlcXVhbCwgPGNvZGU+ZmFsc2U8L2NvZGU+IG90aGVyd2lzZS5cbiAqXG4gKiBAcGFyYW0ge0NhcnRlc2lhbjJ9IFtyaWdodF0gVGhlIHJpZ2h0IGhhbmQgc2lkZSBDYXJ0ZXNpYW4uXG4gKiBAcmV0dXJucyB7Qm9vbGVhbn0gPGNvZGU+dHJ1ZTwvY29kZT4gaWYgdGhleSBhcmUgZXF1YWwsIDxjb2RlPmZhbHNlPC9jb2RlPiBvdGhlcndpc2UuXG4gKi9cbkNhcnRlc2lhbjIucHJvdG90eXBlLmVxdWFscyA9IGZ1bmN0aW9uIChyaWdodCkge1xuICByZXR1cm4gQ2FydGVzaWFuMi5lcXVhbHModGhpcywgcmlnaHQpO1xufTtcblxuLyoqXG4gKiBDb21wYXJlcyB0aGlzIENhcnRlc2lhbiBhZ2FpbnN0IHRoZSBwcm92aWRlZCBDYXJ0ZXNpYW4gY29tcG9uZW50d2lzZSBhbmQgcmV0dXJuc1xuICogPGNvZGU+dHJ1ZTwvY29kZT4gaWYgdGhleSBwYXNzIGFuIGFic29sdXRlIG9yIHJlbGF0aXZlIHRvbGVyYW5jZSB0ZXN0LFxuICogPGNvZGU+ZmFsc2U8L2NvZGU+IG90aGVyd2lzZS5cbiAqXG4gKiBAcGFyYW0ge0NhcnRlc2lhbjJ9IFtyaWdodF0gVGhlIHJpZ2h0IGhhbmQgc2lkZSBDYXJ0ZXNpYW4uXG4gKiBAcGFyYW0ge051bWJlcn0gW3JlbGF0aXZlRXBzaWxvbj0wXSBUaGUgcmVsYXRpdmUgZXBzaWxvbiB0b2xlcmFuY2UgdG8gdXNlIGZvciBlcXVhbGl0eSB0ZXN0aW5nLlxuICogQHBhcmFtIHtOdW1iZXJ9IFthYnNvbHV0ZUVwc2lsb249cmVsYXRpdmVFcHNpbG9uXSBUaGUgYWJzb2x1dGUgZXBzaWxvbiB0b2xlcmFuY2UgdG8gdXNlIGZvciBlcXVhbGl0eSB0ZXN0aW5nLlxuICogQHJldHVybnMge0Jvb2xlYW59IDxjb2RlPnRydWU8L2NvZGU+IGlmIHRoZXkgYXJlIHdpdGhpbiB0aGUgcHJvdmlkZWQgZXBzaWxvbiwgPGNvZGU+ZmFsc2U8L2NvZGU+IG90aGVyd2lzZS5cbiAqL1xuQ2FydGVzaWFuMi5wcm90b3R5cGUuZXF1YWxzRXBzaWxvbiA9IGZ1bmN0aW9uIChcbiAgcmlnaHQsXG4gIHJlbGF0aXZlRXBzaWxvbixcbiAgYWJzb2x1dGVFcHNpbG9uXG4pIHtcbiAgcmV0dXJuIENhcnRlc2lhbjIuZXF1YWxzRXBzaWxvbihcbiAgICB0aGlzLFxuICAgIHJpZ2h0LFxuICAgIHJlbGF0aXZlRXBzaWxvbixcbiAgICBhYnNvbHV0ZUVwc2lsb25cbiAgKTtcbn07XG5cbi8qKlxuICogQ3JlYXRlcyBhIHN0cmluZyByZXByZXNlbnRpbmcgdGhpcyBDYXJ0ZXNpYW4gaW4gdGhlIGZvcm1hdCAnKHgsIHkpJy5cbiAqXG4gKiBAcmV0dXJucyB7U3RyaW5nfSBBIHN0cmluZyByZXByZXNlbnRpbmcgdGhlIHByb3ZpZGVkIENhcnRlc2lhbiBpbiB0aGUgZm9ybWF0ICcoeCwgeSknLlxuICovXG5DYXJ0ZXNpYW4yLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIFwiKFwiICsgdGhpcy54ICsgXCIsIFwiICsgdGhpcy55ICsgXCIpXCI7XG59O1xuZXhwb3J0IGRlZmF1bHQgQ2FydGVzaWFuMjtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///60838\n')},60216:function(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__){eval('/* harmony import */ var _Check_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(66553);\n/* harmony import */ var _defaultValue_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(62200);\n/* harmony import */ var _defined_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(82982);\n/* harmony import */ var _DeveloperError_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(12572);\n/* harmony import */ var _Math_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(99417);\n\n\n\n\n\n\n/**\n * A 3D Cartesian point.\n * @alias Cartesian3\n * @constructor\n *\n * @param {Number} [x=0.0] The X component.\n * @param {Number} [y=0.0] The Y component.\n * @param {Number} [z=0.0] The Z component.\n *\n * @see Cartesian2\n * @see Cartesian4\n * @see Packable\n */\nfunction Cartesian3(x, y, z) {\n  /**\n   * The X component.\n   * @type {Number}\n   * @default 0.0\n   */\n  this.x = (0,_defaultValue_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .Z)(x, 0.0);\n\n  /**\n   * The Y component.\n   * @type {Number}\n   * @default 0.0\n   */\n  this.y = (0,_defaultValue_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .Z)(y, 0.0);\n\n  /**\n   * The Z component.\n   * @type {Number}\n   * @default 0.0\n   */\n  this.z = (0,_defaultValue_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .Z)(z, 0.0);\n}\n\n/**\n * Converts the provided Spherical into Cartesian3 coordinates.\n *\n * @param {Spherical} spherical The Spherical to be converted to Cartesian3.\n * @param {Cartesian3} [result] The object onto which to store the result.\n * @returns {Cartesian3} The modified result parameter or a new Cartesian3 instance if one was not provided.\n */\nCartesian3.fromSpherical = function (spherical, result) {\n  //>>includeStart(\'debug\', pragmas.debug);\n  _Check_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].typeOf.object */ .Z.typeOf.object("spherical", spherical);\n  //>>includeEnd(\'debug\');\n\n  if (!(0,_defined_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .Z)(result)) {\n    result = new Cartesian3();\n  }\n\n  var clock = spherical.clock;\n  var cone = spherical.cone;\n  var magnitude = (0,_defaultValue_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .Z)(spherical.magnitude, 1.0);\n  var radial = magnitude * Math.sin(cone);\n  result.x = radial * Math.cos(clock);\n  result.y = radial * Math.sin(clock);\n  result.z = magnitude * Math.cos(cone);\n  return result;\n};\n\n/**\n * Creates a Cartesian3 instance from x, y and z coordinates.\n *\n * @param {Number} x The x coordinate.\n * @param {Number} y The y coordinate.\n * @param {Number} z The z coordinate.\n * @param {Cartesian3} [result] The object onto which to store the result.\n * @returns {Cartesian3} The modified result parameter or a new Cartesian3 instance if one was not provided.\n */\nCartesian3.fromElements = function (x, y, z, result) {\n  if (!(0,_defined_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .Z)(result)) {\n    return new Cartesian3(x, y, z);\n  }\n\n  result.x = x;\n  result.y = y;\n  result.z = z;\n  return result;\n};\n\n/**\n * Duplicates a Cartesian3 instance.\n *\n * @param {Cartesian3} cartesian The Cartesian to duplicate.\n * @param {Cartesian3} [result] The object onto which to store the result.\n * @returns {Cartesian3} The modified result parameter or a new Cartesian3 instance if one was not provided. (Returns undefined if cartesian is undefined)\n */\nCartesian3.clone = function (cartesian, result) {\n  if (!(0,_defined_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .Z)(cartesian)) {\n    return undefined;\n  }\n  if (!(0,_defined_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .Z)(result)) {\n    return new Cartesian3(cartesian.x, cartesian.y, cartesian.z);\n  }\n\n  result.x = cartesian.x;\n  result.y = cartesian.y;\n  result.z = cartesian.z;\n  return result;\n};\n\n/**\n * Creates a Cartesian3 instance from an existing Cartesian4.  This simply takes the\n * x, y, and z properties of the Cartesian4 and drops w.\n * @function\n *\n * @param {Cartesian4} cartesian The Cartesian4 instance to create a Cartesian3 instance from.\n * @param {Cartesian3} [result] The object onto which to store the result.\n * @returns {Cartesian3} The modified result parameter or a new Cartesian3 instance if one was not provided.\n */\nCartesian3.fromCartesian4 = Cartesian3.clone;\n\n/**\n * The number of elements used to pack the object into an array.\n * @type {Number}\n */\nCartesian3.packedLength = 3;\n\n/**\n * Stores the provided instance into the provided array.\n *\n * @param {Cartesian3} value The value to pack.\n * @param {Number[]} array The array to pack into.\n * @param {Number} [startingIndex=0] The index into the array at which to start packing the elements.\n *\n * @returns {Number[]} The array that was packed into\n */\nCartesian3.pack = function (value, array, startingIndex) {\n  //>>includeStart(\'debug\', pragmas.debug);\n  _Check_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].typeOf.object */ .Z.typeOf.object("value", value);\n  _Check_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].defined */ .Z.defined("array", array);\n  //>>includeEnd(\'debug\');\n\n  startingIndex = (0,_defaultValue_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .Z)(startingIndex, 0);\n\n  array[startingIndex++] = value.x;\n  array[startingIndex++] = value.y;\n  array[startingIndex] = value.z;\n\n  return array;\n};\n\n/**\n * Retrieves an instance from a packed array.\n *\n * @param {Number[]} array The packed array.\n * @param {Number} [startingIndex=0] The starting index of the element to be unpacked.\n * @param {Cartesian3} [result] The object into which to store the result.\n * @returns {Cartesian3} The modified result parameter or a new Cartesian3 instance if one was not provided.\n */\nCartesian3.unpack = function (array, startingIndex, result) {\n  //>>includeStart(\'debug\', pragmas.debug);\n  _Check_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].defined */ .Z.defined("array", array);\n  //>>includeEnd(\'debug\');\n\n  startingIndex = (0,_defaultValue_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .Z)(startingIndex, 0);\n\n  if (!(0,_defined_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .Z)(result)) {\n    result = new Cartesian3();\n  }\n  result.x = array[startingIndex++];\n  result.y = array[startingIndex++];\n  result.z = array[startingIndex];\n  return result;\n};\n\n/**\n * Flattens an array of Cartesian3s into an array of components.\n *\n * @param {Cartesian3[]} array The array of cartesians to pack.\n * @param {Number[]} [result] The array onto which to store the result. If this is a typed array, it must have array.length * 3 components, else a {@link DeveloperError} will be thrown. If it is a regular array, it will be resized to have (array.length * 3) elements.\n * @returns {Number[]} The packed array.\n */\nCartesian3.packArray = function (array, result) {\n  //>>includeStart(\'debug\', pragmas.debug);\n  _Check_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].defined */ .Z.defined("array", array);\n  //>>includeEnd(\'debug\');\n\n  var length = array.length;\n  var resultLength = length * 3;\n  if (!(0,_defined_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .Z)(result)) {\n    result = new Array(resultLength);\n  } else if (!Array.isArray(result) && result.length !== resultLength) {\n    throw new _DeveloperError_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"] */ .Z(\n      "If result is a typed array, it must have exactly array.length * 3 elements"\n    );\n  } else if (result.length !== resultLength) {\n    result.length = resultLength;\n  }\n\n  for (var i = 0; i < length; ++i) {\n    Cartesian3.pack(array[i], result, i * 3);\n  }\n  return result;\n};\n\n/**\n * Unpacks an array of cartesian components into an array of Cartesian3s.\n *\n * @param {Number[]} array The array of components to unpack.\n * @param {Cartesian3[]} [result] The array onto which to store the result.\n * @returns {Cartesian3[]} The unpacked array.\n */\nCartesian3.unpackArray = function (array, result) {\n  //>>includeStart(\'debug\', pragmas.debug);\n  _Check_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].defined */ .Z.defined("array", array);\n  _Check_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].typeOf.number.greaterThanOrEquals */ .Z.typeOf.number.greaterThanOrEquals("array.length", array.length, 3);\n  if (array.length % 3 !== 0) {\n    throw new _DeveloperError_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"] */ .Z("array length must be a multiple of 3.");\n  }\n  //>>includeEnd(\'debug\');\n\n  var length = array.length;\n  if (!(0,_defined_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .Z)(result)) {\n    result = new Array(length / 3);\n  } else {\n    result.length = length / 3;\n  }\n\n  for (var i = 0; i < length; i += 3) {\n    var index = i / 3;\n    result[index] = Cartesian3.unpack(array, i, result[index]);\n  }\n  return result;\n};\n\n/**\n * Creates a Cartesian3 from three consecutive elements in an array.\n * @function\n *\n * @param {Number[]} array The array whose three consecutive elements correspond to the x, y, and z components, respectively.\n * @param {Number} [startingIndex=0] The offset into the array of the first element, which corresponds to the x component.\n * @param {Cartesian3} [result] The object onto which to store the result.\n * @returns {Cartesian3} The modified result parameter or a new Cartesian3 instance if one was not provided.\n *\n * @example\n * // Create a Cartesian3 with (1.0, 2.0, 3.0)\n * var v = [1.0, 2.0, 3.0];\n * var p = Cesium.Cartesian3.fromArray(v);\n *\n * // Create a Cartesian3 with (1.0, 2.0, 3.0) using an offset into an array\n * var v2 = [0.0, 0.0, 1.0, 2.0, 3.0];\n * var p2 = Cesium.Cartesian3.fromArray(v2, 2);\n */\nCartesian3.fromArray = Cartesian3.unpack;\n\n/**\n * Computes the value of the maximum component for the supplied Cartesian.\n *\n * @param {Cartesian3} cartesian The cartesian to use.\n * @returns {Number} The value of the maximum component.\n */\nCartesian3.maximumComponent = function (cartesian) {\n  //>>includeStart(\'debug\', pragmas.debug);\n  _Check_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].typeOf.object */ .Z.typeOf.object("cartesian", cartesian);\n  //>>includeEnd(\'debug\');\n\n  return Math.max(cartesian.x, cartesian.y, cartesian.z);\n};\n\n/**\n * Computes the value of the minimum component for the supplied Cartesian.\n *\n * @param {Cartesian3} cartesian The cartesian to use.\n * @returns {Number} The value of the minimum component.\n */\nCartesian3.minimumComponent = function (cartesian) {\n  //>>includeStart(\'debug\', pragmas.debug);\n  _Check_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].typeOf.object */ .Z.typeOf.object("cartesian", cartesian);\n  //>>includeEnd(\'debug\');\n\n  return Math.min(cartesian.x, cartesian.y, cartesian.z);\n};\n\n/**\n * Compares two Cartesians and computes a Cartesian which contains the minimum components of the supplied Cartesians.\n *\n * @param {Cartesian3} first A cartesian to compare.\n * @param {Cartesian3} second A cartesian to compare.\n * @param {Cartesian3} result The object into which to store the result.\n * @returns {Cartesian3} A cartesian with the minimum components.\n */\nCartesian3.minimumByComponent = function (first, second, result) {\n  //>>includeStart(\'debug\', pragmas.debug);\n  _Check_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].typeOf.object */ .Z.typeOf.object("first", first);\n  _Check_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].typeOf.object */ .Z.typeOf.object("second", second);\n  _Check_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].typeOf.object */ .Z.typeOf.object("result", result);\n  //>>includeEnd(\'debug\');\n\n  result.x = Math.min(first.x, second.x);\n  result.y = Math.min(first.y, second.y);\n  result.z = Math.min(first.z, second.z);\n\n  return result;\n};\n\n/**\n * Compares two Cartesians and computes a Cartesian which contains the maximum components of the supplied Cartesians.\n *\n * @param {Cartesian3} first A cartesian to compare.\n * @param {Cartesian3} second A cartesian to compare.\n * @param {Cartesian3} result The object into which to store the result.\n * @returns {Cartesian3} A cartesian with the maximum components.\n */\nCartesian3.maximumByComponent = function (first, second, result) {\n  //>>includeStart(\'debug\', pragmas.debug);\n  _Check_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].typeOf.object */ .Z.typeOf.object("first", first);\n  _Check_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].typeOf.object */ .Z.typeOf.object("second", second);\n  _Check_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].typeOf.object */ .Z.typeOf.object("result", result);\n  //>>includeEnd(\'debug\');\n\n  result.x = Math.max(first.x, second.x);\n  result.y = Math.max(first.y, second.y);\n  result.z = Math.max(first.z, second.z);\n  return result;\n};\n\n/**\n * Computes the provided Cartesian\'s squared magnitude.\n *\n * @param {Cartesian3} cartesian The Cartesian instance whose squared magnitude is to be computed.\n * @returns {Number} The squared magnitude.\n */\nCartesian3.magnitudeSquared = function (cartesian) {\n  //>>includeStart(\'debug\', pragmas.debug);\n  _Check_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].typeOf.object */ .Z.typeOf.object("cartesian", cartesian);\n  //>>includeEnd(\'debug\');\n\n  return (\n    cartesian.x * cartesian.x +\n    cartesian.y * cartesian.y +\n    cartesian.z * cartesian.z\n  );\n};\n\n/**\n * Computes the Cartesian\'s magnitude (length).\n *\n * @param {Cartesian3} cartesian The Cartesian instance whose magnitude is to be computed.\n * @returns {Number} The magnitude.\n */\nCartesian3.magnitude = function (cartesian) {\n  return Math.sqrt(Cartesian3.magnitudeSquared(cartesian));\n};\n\nvar distanceScratch = new Cartesian3();\n\n/**\n * Computes the distance between two points.\n *\n * @param {Cartesian3} left The first point to compute the distance from.\n * @param {Cartesian3} right The second point to compute the distance to.\n * @returns {Number} The distance between two points.\n *\n * @example\n * // Returns 1.0\n * var d = Cesium.Cartesian3.distance(new Cesium.Cartesian3(1.0, 0.0, 0.0), new Cesium.Cartesian3(2.0, 0.0, 0.0));\n */\nCartesian3.distance = function (left, right) {\n  //>>includeStart(\'debug\', pragmas.debug);\n  _Check_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].typeOf.object */ .Z.typeOf.object("left", left);\n  _Check_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].typeOf.object */ .Z.typeOf.object("right", right);\n  //>>includeEnd(\'debug\');\n\n  Cartesian3.subtract(left, right, distanceScratch);\n  return Cartesian3.magnitude(distanceScratch);\n};\n\n/**\n * Computes the squared distance between two points.  Comparing squared distances\n * using this function is more efficient than comparing distances using {@link Cartesian3#distance}.\n *\n * @param {Cartesian3} left The first point to compute the distance from.\n * @param {Cartesian3} right The second point to compute the distance to.\n * @returns {Number} The distance between two points.\n *\n * @example\n * // Returns 4.0, not 2.0\n * var d = Cesium.Cartesian3.distanceSquared(new Cesium.Cartesian3(1.0, 0.0, 0.0), new Cesium.Cartesian3(3.0, 0.0, 0.0));\n */\nCartesian3.distanceSquared = function (left, right) {\n  //>>includeStart(\'debug\', pragmas.debug);\n  _Check_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].typeOf.object */ .Z.typeOf.object("left", left);\n  _Check_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].typeOf.object */ .Z.typeOf.object("right", right);\n  //>>includeEnd(\'debug\');\n\n  Cartesian3.subtract(left, right, distanceScratch);\n  return Cartesian3.magnitudeSquared(distanceScratch);\n};\n\n/**\n * Computes the normalized form of the supplied Cartesian.\n *\n * @param {Cartesian3} cartesian The Cartesian to be normalized.\n * @param {Cartesian3} result The object onto which to store the result.\n * @returns {Cartesian3} The modified result parameter.\n */\nCartesian3.normalize = function (cartesian, result) {\n  //>>includeStart(\'debug\', pragmas.debug);\n  _Check_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].typeOf.object */ .Z.typeOf.object("cartesian", cartesian);\n  _Check_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].typeOf.object */ .Z.typeOf.object("result", result);\n  //>>includeEnd(\'debug\');\n\n  var magnitude = Cartesian3.magnitude(cartesian);\n\n  result.x = cartesian.x / magnitude;\n  result.y = cartesian.y / magnitude;\n  result.z = cartesian.z / magnitude;\n\n  //>>includeStart(\'debug\', pragmas.debug);\n  if (isNaN(result.x) || isNaN(result.y) || isNaN(result.z)) {\n    throw new _DeveloperError_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"] */ .Z("normalized result is not a number");\n  }\n  //>>includeEnd(\'debug\');\n\n  return result;\n};\n\n/**\n * Computes the dot (scalar) product of two Cartesians.\n *\n * @param {Cartesian3} left The first Cartesian.\n * @param {Cartesian3} right The second Cartesian.\n * @returns {Number} The dot product.\n */\nCartesian3.dot = function (left, right) {\n  //>>includeStart(\'debug\', pragmas.debug);\n  _Check_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].typeOf.object */ .Z.typeOf.object("left", left);\n  _Check_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].typeOf.object */ .Z.typeOf.object("right", right);\n  //>>includeEnd(\'debug\');\n\n  return left.x * right.x + left.y * right.y + left.z * right.z;\n};\n\n/**\n * Computes the componentwise product of two Cartesians.\n *\n * @param {Cartesian3} left The first Cartesian.\n * @param {Cartesian3} right The second Cartesian.\n * @param {Cartesian3} result The object onto which to store the result.\n * @returns {Cartesian3} The modified result parameter.\n */\nCartesian3.multiplyComponents = function (left, right, result) {\n  //>>includeStart(\'debug\', pragmas.debug);\n  _Check_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].typeOf.object */ .Z.typeOf.object("left", left);\n  _Check_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].typeOf.object */ .Z.typeOf.object("right", right);\n  _Check_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].typeOf.object */ .Z.typeOf.object("result", result);\n  //>>includeEnd(\'debug\');\n\n  result.x = left.x * right.x;\n  result.y = left.y * right.y;\n  result.z = left.z * right.z;\n  return result;\n};\n\n/**\n * Computes the componentwise quotient of two Cartesians.\n *\n * @param {Cartesian3} left The first Cartesian.\n * @param {Cartesian3} right The second Cartesian.\n * @param {Cartesian3} result The object onto which to store the result.\n * @returns {Cartesian3} The modified result parameter.\n */\nCartesian3.divideComponents = function (left, right, result) {\n  //>>includeStart(\'debug\', pragmas.debug);\n  _Check_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].typeOf.object */ .Z.typeOf.object("left", left);\n  _Check_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].typeOf.object */ .Z.typeOf.object("right", right);\n  _Check_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].typeOf.object */ .Z.typeOf.object("result", result);\n  //>>includeEnd(\'debug\');\n\n  result.x = left.x / right.x;\n  result.y = left.y / right.y;\n  result.z = left.z / right.z;\n  return result;\n};\n\n/**\n * Computes the componentwise sum of two Cartesians.\n *\n * @param {Cartesian3} left The first Cartesian.\n * @param {Cartesian3} right The second Cartesian.\n * @param {Cartesian3} result The object onto which to store the result.\n * @returns {Cartesian3} The modified result parameter.\n */\nCartesian3.add = function (left, right, result) {\n  //>>includeStart(\'debug\', pragmas.debug);\n  _Check_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].typeOf.object */ .Z.typeOf.object("left", left);\n  _Check_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].typeOf.object */ .Z.typeOf.object("right", right);\n  _Check_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].typeOf.object */ .Z.typeOf.object("result", result);\n  //>>includeEnd(\'debug\');\n\n  result.x = left.x + right.x;\n  result.y = left.y + right.y;\n  result.z = left.z + right.z;\n  return result;\n};\n\n/**\n * Computes the componentwise difference of two Cartesians.\n *\n * @param {Cartesian3} left The first Cartesian.\n * @param {Cartesian3} right The second Cartesian.\n * @param {Cartesian3} result The object onto which to store the result.\n * @returns {Cartesian3} The modified result parameter.\n */\nCartesian3.subtract = function (left, right, result) {\n  //>>includeStart(\'debug\', pragmas.debug);\n  _Check_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].typeOf.object */ .Z.typeOf.object("left", left);\n  _Check_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].typeOf.object */ .Z.typeOf.object("right", right);\n  _Check_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].typeOf.object */ .Z.typeOf.object("result", result);\n  //>>includeEnd(\'debug\');\n\n  result.x = left.x - right.x;\n  result.y = left.y - right.y;\n  result.z = left.z - right.z;\n  return result;\n};\n\n/**\n * Multiplies the provided Cartesian componentwise by the provided scalar.\n *\n * @param {Cartesian3} cartesian The Cartesian to be scaled.\n * @param {Number} scalar The scalar to multiply with.\n * @param {Cartesian3} result The object onto which to store the result.\n * @returns {Cartesian3} The modified result parameter.\n */\nCartesian3.multiplyByScalar = function (cartesian, scalar, result) {\n  //>>includeStart(\'debug\', pragmas.debug);\n  _Check_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].typeOf.object */ .Z.typeOf.object("cartesian", cartesian);\n  _Check_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].typeOf.number */ .Z.typeOf.number("scalar", scalar);\n  _Check_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].typeOf.object */ .Z.typeOf.object("result", result);\n  //>>includeEnd(\'debug\');\n\n  result.x = cartesian.x * scalar;\n  result.y = cartesian.y * scalar;\n  result.z = cartesian.z * scalar;\n  return result;\n};\n\n/**\n * Divides the provided Cartesian componentwise by the provided scalar.\n *\n * @param {Cartesian3} cartesian The Cartesian to be divided.\n * @param {Number} scalar The scalar to divide by.\n * @param {Cartesian3} result The object onto which to store the result.\n * @returns {Cartesian3} The modified result parameter.\n */\nCartesian3.divideByScalar = function (cartesian, scalar, result) {\n  //>>includeStart(\'debug\', pragmas.debug);\n  _Check_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].typeOf.object */ .Z.typeOf.object("cartesian", cartesian);\n  _Check_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].typeOf.number */ .Z.typeOf.number("scalar", scalar);\n  _Check_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].typeOf.object */ .Z.typeOf.object("result", result);\n  //>>includeEnd(\'debug\');\n\n  result.x = cartesian.x / scalar;\n  result.y = cartesian.y / scalar;\n  result.z = cartesian.z / scalar;\n  return result;\n};\n\n/**\n * Negates the provided Cartesian.\n *\n * @param {Cartesian3} cartesian The Cartesian to be negated.\n * @param {Cartesian3} result The object onto which to store the result.\n * @returns {Cartesian3} The modified result parameter.\n */\nCartesian3.negate = function (cartesian, result) {\n  //>>includeStart(\'debug\', pragmas.debug);\n  _Check_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].typeOf.object */ .Z.typeOf.object("cartesian", cartesian);\n  _Check_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].typeOf.object */ .Z.typeOf.object("result", result);\n  //>>includeEnd(\'debug\');\n\n  result.x = -cartesian.x;\n  result.y = -cartesian.y;\n  result.z = -cartesian.z;\n  return result;\n};\n\n/**\n * Computes the absolute value of the provided Cartesian.\n *\n * @param {Cartesian3} cartesian The Cartesian whose absolute value is to be computed.\n * @param {Cartesian3} result The object onto which to store the result.\n * @returns {Cartesian3} The modified result parameter.\n */\nCartesian3.abs = function (cartesian, result) {\n  //>>includeStart(\'debug\', pragmas.debug);\n  _Check_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].typeOf.object */ .Z.typeOf.object("cartesian", cartesian);\n  _Check_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].typeOf.object */ .Z.typeOf.object("result", result);\n  //>>includeEnd(\'debug\');\n\n  result.x = Math.abs(cartesian.x);\n  result.y = Math.abs(cartesian.y);\n  result.z = Math.abs(cartesian.z);\n  return result;\n};\n\nvar lerpScratch = new Cartesian3();\n/**\n * Computes the linear interpolation or extrapolation at t using the provided cartesians.\n *\n * @param {Cartesian3} start The value corresponding to t at 0.0.\n * @param {Cartesian3} end The value corresponding to t at 1.0.\n * @param {Number} t The point along t at which to interpolate.\n * @param {Cartesian3} result The object onto which to store the result.\n * @returns {Cartesian3} The modified result parameter.\n */\nCartesian3.lerp = function (start, end, t, result) {\n  //>>includeStart(\'debug\', pragmas.debug);\n  _Check_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].typeOf.object */ .Z.typeOf.object("start", start);\n  _Check_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].typeOf.object */ .Z.typeOf.object("end", end);\n  _Check_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].typeOf.number */ .Z.typeOf.number("t", t);\n  _Check_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].typeOf.object */ .Z.typeOf.object("result", result);\n  //>>includeEnd(\'debug\');\n\n  Cartesian3.multiplyByScalar(end, t, lerpScratch);\n  result = Cartesian3.multiplyByScalar(start, 1.0 - t, result);\n  return Cartesian3.add(lerpScratch, result, result);\n};\n\nvar angleBetweenScratch = new Cartesian3();\nvar angleBetweenScratch2 = new Cartesian3();\n/**\n * Returns the angle, in radians, between the provided Cartesians.\n *\n * @param {Cartesian3} left The first Cartesian.\n * @param {Cartesian3} right The second Cartesian.\n * @returns {Number} The angle between the Cartesians.\n */\nCartesian3.angleBetween = function (left, right) {\n  //>>includeStart(\'debug\', pragmas.debug);\n  _Check_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].typeOf.object */ .Z.typeOf.object("left", left);\n  _Check_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].typeOf.object */ .Z.typeOf.object("right", right);\n  //>>includeEnd(\'debug\');\n\n  Cartesian3.normalize(left, angleBetweenScratch);\n  Cartesian3.normalize(right, angleBetweenScratch2);\n  var cosine = Cartesian3.dot(angleBetweenScratch, angleBetweenScratch2);\n  var sine = Cartesian3.magnitude(\n    Cartesian3.cross(\n      angleBetweenScratch,\n      angleBetweenScratch2,\n      angleBetweenScratch\n    )\n  );\n  return Math.atan2(sine, cosine);\n};\n\nvar mostOrthogonalAxisScratch = new Cartesian3();\n/**\n * Returns the axis that is most orthogonal to the provided Cartesian.\n *\n * @param {Cartesian3} cartesian The Cartesian on which to find the most orthogonal axis.\n * @param {Cartesian3} result The object onto which to store the result.\n * @returns {Cartesian3} The most orthogonal axis.\n */\nCartesian3.mostOrthogonalAxis = function (cartesian, result) {\n  //>>includeStart(\'debug\', pragmas.debug);\n  _Check_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].typeOf.object */ .Z.typeOf.object("cartesian", cartesian);\n  _Check_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].typeOf.object */ .Z.typeOf.object("result", result);\n  //>>includeEnd(\'debug\');\n\n  var f = Cartesian3.normalize(cartesian, mostOrthogonalAxisScratch);\n  Cartesian3.abs(f, f);\n\n  if (f.x <= f.y) {\n    if (f.x <= f.z) {\n      result = Cartesian3.clone(Cartesian3.UNIT_X, result);\n    } else {\n      result = Cartesian3.clone(Cartesian3.UNIT_Z, result);\n    }\n  } else if (f.y <= f.z) {\n    result = Cartesian3.clone(Cartesian3.UNIT_Y, result);\n  } else {\n    result = Cartesian3.clone(Cartesian3.UNIT_Z, result);\n  }\n\n  return result;\n};\n\n/**\n * Projects vector a onto vector b\n * @param {Cartesian3} a The vector that needs projecting\n * @param {Cartesian3} b The vector to project onto\n * @param {Cartesian3} result The result cartesian\n * @returns {Cartesian3} The modified result parameter\n */\nCartesian3.projectVector = function (a, b, result) {\n  //>>includeStart(\'debug\', pragmas.debug);\n  _Check_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].defined */ .Z.defined("a", a);\n  _Check_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].defined */ .Z.defined("b", b);\n  _Check_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].defined */ .Z.defined("result", result);\n  //>>includeEnd(\'debug\');\n\n  var scalar = Cartesian3.dot(a, b) / Cartesian3.dot(b, b);\n  return Cartesian3.multiplyByScalar(b, scalar, result);\n};\n\n/**\n * Compares the provided Cartesians componentwise and returns\n * <code>true</code> if they are equal, <code>false</code> otherwise.\n *\n * @param {Cartesian3} [left] The first Cartesian.\n * @param {Cartesian3} [right] The second Cartesian.\n * @returns {Boolean} <code>true</code> if left and right are equal, <code>false</code> otherwise.\n */\nCartesian3.equals = function (left, right) {\n  return (\n    left === right ||\n    ((0,_defined_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .Z)(left) &&\n      (0,_defined_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .Z)(right) &&\n      left.x === right.x &&\n      left.y === right.y &&\n      left.z === right.z)\n  );\n};\n\n/**\n * @private\n */\nCartesian3.equalsArray = function (cartesian, array, offset) {\n  return (\n    cartesian.x === array[offset] &&\n    cartesian.y === array[offset + 1] &&\n    cartesian.z === array[offset + 2]\n  );\n};\n\n/**\n * Compares the provided Cartesians componentwise and returns\n * <code>true</code> if they pass an absolute or relative tolerance test,\n * <code>false</code> otherwise.\n *\n * @param {Cartesian3} [left] The first Cartesian.\n * @param {Cartesian3} [right] The second Cartesian.\n * @param {Number} [relativeEpsilon=0] The relative epsilon tolerance to use for equality testing.\n * @param {Number} [absoluteEpsilon=relativeEpsilon] The absolute epsilon tolerance to use for equality testing.\n * @returns {Boolean} <code>true</code> if left and right are within the provided epsilon, <code>false</code> otherwise.\n */\nCartesian3.equalsEpsilon = function (\n  left,\n  right,\n  relativeEpsilon,\n  absoluteEpsilon\n) {\n  return (\n    left === right ||\n    ((0,_defined_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .Z)(left) &&\n      (0,_defined_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .Z)(right) &&\n      _Math_js__WEBPACK_IMPORTED_MODULE_3__/* ["default"].equalsEpsilon */ .Z.equalsEpsilon(\n        left.x,\n        right.x,\n        relativeEpsilon,\n        absoluteEpsilon\n      ) &&\n      _Math_js__WEBPACK_IMPORTED_MODULE_3__/* ["default"].equalsEpsilon */ .Z.equalsEpsilon(\n        left.y,\n        right.y,\n        relativeEpsilon,\n        absoluteEpsilon\n      ) &&\n      _Math_js__WEBPACK_IMPORTED_MODULE_3__/* ["default"].equalsEpsilon */ .Z.equalsEpsilon(\n        left.z,\n        right.z,\n        relativeEpsilon,\n        absoluteEpsilon\n      ))\n  );\n};\n\n/**\n * Computes the cross (outer) product of two Cartesians.\n *\n * @param {Cartesian3} left The first Cartesian.\n * @param {Cartesian3} right The second Cartesian.\n * @param {Cartesian3} result The object onto which to store the result.\n * @returns {Cartesian3} The cross product.\n */\nCartesian3.cross = function (left, right, result) {\n  //>>includeStart(\'debug\', pragmas.debug);\n  _Check_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].typeOf.object */ .Z.typeOf.object("left", left);\n  _Check_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].typeOf.object */ .Z.typeOf.object("right", right);\n  _Check_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].typeOf.object */ .Z.typeOf.object("result", result);\n  //>>includeEnd(\'debug\');\n\n  var leftX = left.x;\n  var leftY = left.y;\n  var leftZ = left.z;\n  var rightX = right.x;\n  var rightY = right.y;\n  var rightZ = right.z;\n\n  var x = leftY * rightZ - leftZ * rightY;\n  var y = leftZ * rightX - leftX * rightZ;\n  var z = leftX * rightY - leftY * rightX;\n\n  result.x = x;\n  result.y = y;\n  result.z = z;\n  return result;\n};\n\n/**\n * Computes the midpoint between the right and left Cartesian.\n * @param {Cartesian3} left The first Cartesian.\n * @param {Cartesian3} right The second Cartesian.\n * @param {Cartesian3} result The object onto which to store the result.\n * @returns {Cartesian3} The midpoint.\n */\nCartesian3.midpoint = function (left, right, result) {\n  //>>includeStart(\'debug\', pragmas.debug);\n  _Check_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].typeOf.object */ .Z.typeOf.object("left", left);\n  _Check_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].typeOf.object */ .Z.typeOf.object("right", right);\n  _Check_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].typeOf.object */ .Z.typeOf.object("result", result);\n  //>>includeEnd(\'debug\');\n\n  result.x = (left.x + right.x) * 0.5;\n  result.y = (left.y + right.y) * 0.5;\n  result.z = (left.z + right.z) * 0.5;\n\n  return result;\n};\n\n/**\n * Returns a Cartesian3 position from longitude and latitude values given in degrees.\n *\n * @param {Number} longitude The longitude, in degrees\n * @param {Number} latitude The latitude, in degrees\n * @param {Number} [height=0.0] The height, in meters, above the ellipsoid.\n * @param {Ellipsoid} [ellipsoid=Ellipsoid.WGS84] The ellipsoid on which the position lies.\n * @param {Cartesian3} [result] The object onto which to store the result.\n * @returns {Cartesian3} The position\n *\n * @example\n * var position = Cesium.Cartesian3.fromDegrees(-115.0, 37.0);\n */\nCartesian3.fromDegrees = function (\n  longitude,\n  latitude,\n  height,\n  ellipsoid,\n  result\n) {\n  //>>includeStart(\'debug\', pragmas.debug);\n  _Check_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].typeOf.number */ .Z.typeOf.number("longitude", longitude);\n  _Check_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].typeOf.number */ .Z.typeOf.number("latitude", latitude);\n  //>>includeEnd(\'debug\');\n\n  longitude = _Math_js__WEBPACK_IMPORTED_MODULE_3__/* ["default"].toRadians */ .Z.toRadians(longitude);\n  latitude = _Math_js__WEBPACK_IMPORTED_MODULE_3__/* ["default"].toRadians */ .Z.toRadians(latitude);\n  return Cartesian3.fromRadians(longitude, latitude, height, ellipsoid, result);\n};\n\nvar scratchN = new Cartesian3();\nvar scratchK = new Cartesian3();\nvar wgs84RadiiSquared = new Cartesian3(\n  6378137.0 * 6378137.0,\n  6378137.0 * 6378137.0,\n  6356752.3142451793 * 6356752.3142451793\n);\n\n/**\n * Returns a Cartesian3 position from longitude and latitude values given in radians.\n *\n * @param {Number} longitude The longitude, in radians\n * @param {Number} latitude The latitude, in radians\n * @param {Number} [height=0.0] The height, in meters, above the ellipsoid.\n * @param {Ellipsoid} [ellipsoid=Ellipsoid.WGS84] The ellipsoid on which the position lies.\n * @param {Cartesian3} [result] The object onto which to store the result.\n * @returns {Cartesian3} The position\n *\n * @example\n * var position = Cesium.Cartesian3.fromRadians(-2.007, 0.645);\n */\nCartesian3.fromRadians = function (\n  longitude,\n  latitude,\n  height,\n  ellipsoid,\n  result\n) {\n  //>>includeStart(\'debug\', pragmas.debug);\n  _Check_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].typeOf.number */ .Z.typeOf.number("longitude", longitude);\n  _Check_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].typeOf.number */ .Z.typeOf.number("latitude", latitude);\n  //>>includeEnd(\'debug\');\n\n  height = (0,_defaultValue_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .Z)(height, 0.0);\n  var radiiSquared = (0,_defined_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .Z)(ellipsoid)\n    ? ellipsoid.radiiSquared\n    : wgs84RadiiSquared;\n\n  var cosLatitude = Math.cos(latitude);\n  scratchN.x = cosLatitude * Math.cos(longitude);\n  scratchN.y = cosLatitude * Math.sin(longitude);\n  scratchN.z = Math.sin(latitude);\n  scratchN = Cartesian3.normalize(scratchN, scratchN);\n\n  Cartesian3.multiplyComponents(radiiSquared, scratchN, scratchK);\n  var gamma = Math.sqrt(Cartesian3.dot(scratchN, scratchK));\n  scratchK = Cartesian3.divideByScalar(scratchK, gamma, scratchK);\n  scratchN = Cartesian3.multiplyByScalar(scratchN, height, scratchN);\n\n  if (!(0,_defined_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .Z)(result)) {\n    result = new Cartesian3();\n  }\n  return Cartesian3.add(scratchK, scratchN, result);\n};\n\n/**\n * Returns an array of Cartesian3 positions given an array of longitude and latitude values given in degrees.\n *\n * @param {Number[]} coordinates A list of longitude and latitude values. Values alternate [longitude, latitude, longitude, latitude...].\n * @param {Ellipsoid} [ellipsoid=Ellipsoid.WGS84] The ellipsoid on which the coordinates lie.\n * @param {Cartesian3[]} [result] An array of Cartesian3 objects to store the result.\n * @returns {Cartesian3[]} The array of positions.\n *\n * @example\n * var positions = Cesium.Cartesian3.fromDegreesArray([-115.0, 37.0, -107.0, 33.0]);\n */\nCartesian3.fromDegreesArray = function (coordinates, ellipsoid, result) {\n  //>>includeStart(\'debug\', pragmas.debug);\n  _Check_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].defined */ .Z.defined("coordinates", coordinates);\n  if (coordinates.length < 2 || coordinates.length % 2 !== 0) {\n    throw new _DeveloperError_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"] */ .Z(\n      "the number of coordinates must be a multiple of 2 and at least 2"\n    );\n  }\n  //>>includeEnd(\'debug\');\n\n  var length = coordinates.length;\n  if (!(0,_defined_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .Z)(result)) {\n    result = new Array(length / 2);\n  } else {\n    result.length = length / 2;\n  }\n\n  for (var i = 0; i < length; i += 2) {\n    var longitude = coordinates[i];\n    var latitude = coordinates[i + 1];\n    var index = i / 2;\n    result[index] = Cartesian3.fromDegrees(\n      longitude,\n      latitude,\n      0,\n      ellipsoid,\n      result[index]\n    );\n  }\n\n  return result;\n};\n\n/**\n * Returns an array of Cartesian3 positions given an array of longitude and latitude values given in radians.\n *\n * @param {Number[]} coordinates A list of longitude and latitude values. Values alternate [longitude, latitude, longitude, latitude...].\n * @param {Ellipsoid} [ellipsoid=Ellipsoid.WGS84] The ellipsoid on which the coordinates lie.\n * @param {Cartesian3[]} [result] An array of Cartesian3 objects to store the result.\n * @returns {Cartesian3[]} The array of positions.\n *\n * @example\n * var positions = Cesium.Cartesian3.fromRadiansArray([-2.007, 0.645, -1.867, .575]);\n */\nCartesian3.fromRadiansArray = function (coordinates, ellipsoid, result) {\n  //>>includeStart(\'debug\', pragmas.debug);\n  _Check_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].defined */ .Z.defined("coordinates", coordinates);\n  if (coordinates.length < 2 || coordinates.length % 2 !== 0) {\n    throw new _DeveloperError_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"] */ .Z(\n      "the number of coordinates must be a multiple of 2 and at least 2"\n    );\n  }\n  //>>includeEnd(\'debug\');\n\n  var length = coordinates.length;\n  if (!(0,_defined_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .Z)(result)) {\n    result = new Array(length / 2);\n  } else {\n    result.length = length / 2;\n  }\n\n  for (var i = 0; i < length; i += 2) {\n    var longitude = coordinates[i];\n    var latitude = coordinates[i + 1];\n    var index = i / 2;\n    result[index] = Cartesian3.fromRadians(\n      longitude,\n      latitude,\n      0,\n      ellipsoid,\n      result[index]\n    );\n  }\n\n  return result;\n};\n\n/**\n * Returns an array of Cartesian3 positions given an array of longitude, latitude and height values where longitude and latitude are given in degrees.\n *\n * @param {Number[]} coordinates A list of longitude, latitude and height values. Values alternate [longitude, latitude, height, longitude, latitude, height...].\n * @param {Ellipsoid} [ellipsoid=Ellipsoid.WGS84] The ellipsoid on which the position lies.\n * @param {Cartesian3[]} [result] An array of Cartesian3 objects to store the result.\n * @returns {Cartesian3[]} The array of positions.\n *\n * @example\n * var positions = Cesium.Cartesian3.fromDegreesArrayHeights([-115.0, 37.0, 100000.0, -107.0, 33.0, 150000.0]);\n */\nCartesian3.fromDegreesArrayHeights = function (coordinates, ellipsoid, result) {\n  //>>includeStart(\'debug\', pragmas.debug);\n  _Check_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].defined */ .Z.defined("coordinates", coordinates);\n  if (coordinates.length < 3 || coordinates.length % 3 !== 0) {\n    throw new _DeveloperError_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"] */ .Z(\n      "the number of coordinates must be a multiple of 3 and at least 3"\n    );\n  }\n  //>>includeEnd(\'debug\');\n\n  var length = coordinates.length;\n  if (!(0,_defined_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .Z)(result)) {\n    result = new Array(length / 3);\n  } else {\n    result.length = length / 3;\n  }\n\n  for (var i = 0; i < length; i += 3) {\n    var longitude = coordinates[i];\n    var latitude = coordinates[i + 1];\n    var height = coordinates[i + 2];\n    var index = i / 3;\n    result[index] = Cartesian3.fromDegrees(\n      longitude,\n      latitude,\n      height,\n      ellipsoid,\n      result[index]\n    );\n  }\n\n  return result;\n};\n\n/**\n * Returns an array of Cartesian3 positions given an array of longitude, latitude and height values where longitude and latitude are given in radians.\n *\n * @param {Number[]} coordinates A list of longitude, latitude and height values. Values alternate [longitude, latitude, height, longitude, latitude, height...].\n * @param {Ellipsoid} [ellipsoid=Ellipsoid.WGS84] The ellipsoid on which the position lies.\n * @param {Cartesian3[]} [result] An array of Cartesian3 objects to store the result.\n * @returns {Cartesian3[]} The array of positions.\n *\n * @example\n * var positions = Cesium.Cartesian3.fromRadiansArrayHeights([-2.007, 0.645, 100000.0, -1.867, .575, 150000.0]);\n */\nCartesian3.fromRadiansArrayHeights = function (coordinates, ellipsoid, result) {\n  //>>includeStart(\'debug\', pragmas.debug);\n  _Check_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].defined */ .Z.defined("coordinates", coordinates);\n  if (coordinates.length < 3 || coordinates.length % 3 !== 0) {\n    throw new _DeveloperError_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"] */ .Z(\n      "the number of coordinates must be a multiple of 3 and at least 3"\n    );\n  }\n  //>>includeEnd(\'debug\');\n\n  var length = coordinates.length;\n  if (!(0,_defined_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .Z)(result)) {\n    result = new Array(length / 3);\n  } else {\n    result.length = length / 3;\n  }\n\n  for (var i = 0; i < length; i += 3) {\n    var longitude = coordinates[i];\n    var latitude = coordinates[i + 1];\n    var height = coordinates[i + 2];\n    var index = i / 3;\n    result[index] = Cartesian3.fromRadians(\n      longitude,\n      latitude,\n      height,\n      ellipsoid,\n      result[index]\n    );\n  }\n\n  return result;\n};\n\n/**\n * An immutable Cartesian3 instance initialized to (0.0, 0.0, 0.0).\n *\n * @type {Cartesian3}\n * @constant\n */\nCartesian3.ZERO = Object.freeze(new Cartesian3(0.0, 0.0, 0.0));\n\n/**\n * An immutable Cartesian3 instance initialized to (1.0, 1.0, 1.0).\n *\n * @type {Cartesian3}\n * @constant\n */\nCartesian3.ONE = Object.freeze(new Cartesian3(1.0, 1.0, 1.0));\n\n/**\n * An immutable Cartesian3 instance initialized to (1.0, 0.0, 0.0).\n *\n * @type {Cartesian3}\n * @constant\n */\nCartesian3.UNIT_X = Object.freeze(new Cartesian3(1.0, 0.0, 0.0));\n\n/**\n * An immutable Cartesian3 instance initialized to (0.0, 1.0, 0.0).\n *\n * @type {Cartesian3}\n * @constant\n */\nCartesian3.UNIT_Y = Object.freeze(new Cartesian3(0.0, 1.0, 0.0));\n\n/**\n * An immutable Cartesian3 instance initialized to (0.0, 0.0, 1.0).\n *\n * @type {Cartesian3}\n * @constant\n */\nCartesian3.UNIT_Z = Object.freeze(new Cartesian3(0.0, 0.0, 1.0));\n\n/**\n * Duplicates this Cartesian3 instance.\n *\n * @param {Cartesian3} [result] The object onto which to store the result.\n * @returns {Cartesian3} The modified result parameter or a new Cartesian3 instance if one was not provided.\n */\nCartesian3.prototype.clone = function (result) {\n  return Cartesian3.clone(this, result);\n};\n\n/**\n * Compares this Cartesian against the provided Cartesian componentwise and returns\n * <code>true</code> if they are equal, <code>false</code> otherwise.\n *\n * @param {Cartesian3} [right] The right hand side Cartesian.\n * @returns {Boolean} <code>true</code> if they are equal, <code>false</code> otherwise.\n */\nCartesian3.prototype.equals = function (right) {\n  return Cartesian3.equals(this, right);\n};\n\n/**\n * Compares this Cartesian against the provided Cartesian componentwise and returns\n * <code>true</code> if they pass an absolute or relative tolerance test,\n * <code>false</code> otherwise.\n *\n * @param {Cartesian3} [right] The right hand side Cartesian.\n * @param {Number} [relativeEpsilon=0] The relative epsilon tolerance to use for equality testing.\n * @param {Number} [absoluteEpsilon=relativeEpsilon] The absolute epsilon tolerance to use for equality testing.\n * @returns {Boolean} <code>true</code> if they are within the provided epsilon, <code>false</code> otherwise.\n */\nCartesian3.prototype.equalsEpsilon = function (\n  right,\n  relativeEpsilon,\n  absoluteEpsilon\n) {\n  return Cartesian3.equalsEpsilon(\n    this,\n    right,\n    relativeEpsilon,\n    absoluteEpsilon\n  );\n};\n\n/**\n * Creates a string representing this Cartesian in the format \'(x, y, z)\'.\n *\n * @returns {String} A string representing this Cartesian in the format \'(x, y, z)\'.\n */\nCartesian3.prototype.toString = function () {\n  return "(" + this.x + ", " + this.y + ", " + this.z + ")";\n};\n/* harmony default export */ __webpack_exports__["Z"] = (Cartesian3);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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Q0E7QUFDQTtBQUNBLEVBQUUsc0ZBQW1CO0FBQ3JCLEVBQUUsc0ZBQW1CO0FBQ3JCLEVBQUUsc0ZBQW1CO0FBQ3JCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxZQUFZO0FBQ3ZCLFdBQVcsWUFBWTtBQUN2QixXQUFXLFlBQVk7QUFDdkIsYUFBYSxZQUFZO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBLEVBQUUsc0ZBQW1CO0FBQ3JCLEVBQUUsc0ZBQW1CO0FBQ3JCLEVBQUUsc0ZBQW1CO0FBQ3JCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxZQUFZO0FBQ3ZCLFdBQVcsWUFBWTtBQUN2QixXQUFXLFlBQVk7QUFDdkIsYUFBYSxZQUFZO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBLEVBQUUsc0ZBQW1CO0FBQ3JCLEVBQUUsc0ZBQW1CO0FBQ3JCLEVBQUUsc0ZBQW1CO0FBQ3JCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxZQUFZO0FBQ3ZCLFdBQVcsUUFBUTtBQUNuQixXQUFXLFlBQVk7QUFDdkIsYUFBYSxZQUFZO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBLEVBQUUsc0ZBQW1CO0FBQ3JCLEVBQUUsc0ZBQW1CO0FBQ3JCLEVBQUUsc0ZBQW1CO0FBQ3JCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxZQUFZO0FBQ3ZCLFdBQVcsUUFBUTtBQUNuQixXQUFXLFlBQVk7QUFDdkIsYUFBYSxZQUFZO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBLEVBQUUsc0ZBQW1CO0FBQ3JCLEVBQUUsc0ZBQW1CO0FBQ3JCLEVBQUUsc0ZBQW1CO0FBQ3JCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxZQUFZO0FBQ3ZCLFdBQVcsWUFBWTtBQUN2QixhQUFhLFlBQVk7QUFDekI7QUFDQTtBQUNBO0FBQ0EsRUFB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O0FBQzVCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsT0FBTyxnRUFBTztBQUNkO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUEsa0JBQWtCLFlBQVk7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsWUFBWTtBQUN2QixhQUFhLFlBQVk7QUFDekI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFlBQVk7QUFDdkIsYUFBYSxTQUFTO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFlBQVk7QUFDdkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixhQUFhLFNBQVM7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseURBQWUsVUFBVSxFQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdnVlMy13ZWJwYWNrNS8uL25vZGVfbW9kdWxlcy9jZXNpdW0vU291cmNlL0NvcmUvQ2FydGVzaWFuMy5qcz8wOTE2Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBDaGVjayBmcm9tIFwiLi9DaGVjay5qc1wiO1xuaW1wb3J0IGRlZmF1bHRWYWx1ZSBmcm9tIFwiLi9kZWZhdWx0VmFsdWUuanNcIjtcbmltcG9ydCBkZWZpbmVkIGZyb20gXCIuL2RlZmluZWQuanNcIjtcbmltcG9ydCBEZXZlbG9wZXJFcnJvciBmcm9tIFwiLi9EZXZlbG9wZXJFcnJvci5qc1wiO1xuaW1wb3J0IENlc2l1bU1hdGggZnJvbSBcIi4vTWF0aC5qc1wiO1xuXG4vKipcbiAqIEEgM0QgQ2FydGVzaWFuIHBvaW50LlxuICogQGFsaWFzIENhcnRlc2lhbjNcbiAqIEBjb25zdHJ1Y3RvclxuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSBbeD0wLjBdIFRoZSBYIGNvbXBvbmVudC5cbiAqIEBwYXJhbSB7TnVtYmVyfSBbeT0wLjBdIFRoZSBZIGNvbXBvbmVudC5cbiAqIEBwYXJhbSB7TnVtYmVyfSBbej0wLjBdIFRoZSBaIGNvbXBvbmVudC5cbiAqXG4gKiBAc2VlIENhcnRlc2lhbjJcbiAqIEBzZWUgQ2FydGVzaWFuNFxuICogQHNlZSBQYWNrYWJsZVxuICovXG5mdW5jdGlvbiBDYXJ0ZXNpYW4zKHgsIHksIHopIHtcbiAgLyoqXG4gICAqIFRoZSBYIGNvbXBvbmVudC5cbiAgICogQHR5cGUge051bWJlcn1cbiAgICogQGRlZmF1bHQgMC4wXG4gICAqL1xuICB0aGlzLnggPSBkZWZhdWx0VmFsdWUoeCwgMC4wKTtcblxuICAvKipcbiAgICogVGhlIFkgY29tcG9uZW50LlxuICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgKiBAZGVmYXVsdCAwLjBcbiAgICovXG4gIHRoaXMueSA9IGRlZmF1bHRWYWx1ZSh5LCAwLjApO1xuXG4gIC8qKlxuICAgKiBUaGUgWiBjb21wb25lbnQuXG4gICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAqIEBkZWZhdWx0IDAuMFxuICAgKi9cbiAgdGhpcy56ID0gZGVmYXVsdFZhbHVlKHosIDAuMCk7XG59XG5cbi8qKlxuICogQ29udmVydHMgdGhlIHByb3ZpZGVkIFNwaGVyaWNhbCBpbnRvIENhcnRlc2lhbjMgY29vcmRpbmF0ZXMuXG4gKlxuICogQHBhcmFtIHtTcGhlcmljYWx9IHNwaGVyaWNhbCBUaGUgU3BoZXJpY2FsIHRvIGJlIGNvbnZlcnRlZCB0byBDYXJ0ZXNpYW4zLlxuICogQHBhcmFtIHtDYXJ0ZXNpYW4zfSBbcmVzdWx0XSBUaGUgb2JqZWN0IG9udG8gd2hpY2ggdG8gc3RvcmUgdGhlIHJlc3VsdC5cbiAqIEByZXR1cm5zIHtDYXJ0ZXNpYW4zfSBUaGUgbW9kaWZpZWQgcmVzdWx0IHBhcmFtZXRlciBvciBhIG5ldyBDYXJ0ZXNpYW4zIGluc3RhbmNlIGlmIG9uZSB3YXMgbm90IHByb3ZpZGVkLlxuICovXG5DYXJ0ZXNpYW4zLmZyb21TcGhlcmljYWwgPSBmdW5jdGlvbiAoc3BoZXJpY2FsLCByZXN1bHQpIHtcbiAgLy8+PmluY2x1ZGVTdGFydCgnZGVidWcnLCBwcmFnbWFzLmRlYnVnKTtcbiAgQ2hlY2sudHlwZU9mLm9iamVjdChcInNwaGVyaWNhbFwiLCBzcGhlcmljYWwpO1xuICAvLz4+aW5jbHVkZUVuZCgnZGVidWcnKTtcblxuICBpZiAoIWRlZmluZWQocmVzdWx0KSkge1xuICAgIHJlc3VsdCA9IG5ldyBDYXJ0ZXNpYW4zKCk7XG4gIH1cblxuICB2YXIgY2xvY2sgPSBzcGhlcmljYWwuY2xvY2s7XG4gIHZhciBjb25lID0gc3BoZXJpY2FsLmNvbmU7XG4gIHZhciBtYWduaXR1ZGUgPSBkZWZhdWx0VmFsdWUoc3BoZXJpY2FsLm1hZ25pdHVkZSwgMS4wKTtcbiAgdmFyIHJhZGlhbCA9IG1hZ25pdHVkZSAqIE1hdGguc2luKGNvbmUpO1xuICByZXN1bHQueCA9IHJhZGlhbCAqIE1hdGguY29zKGNsb2NrKTtcbiAgcmVzdWx0LnkgPSByYWRpYWwgKiBNYXRoLnNpbihjbG9jayk7XG4gIHJlc3VsdC56ID0gbWFnbml0dWRlICogTWF0aC5jb3MoY29uZSk7XG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG4vKipcbiAqIENyZWF0ZXMgYSBDYXJ0ZXNpYW4zIGluc3RhbmNlIGZyb20geCwgeSBhbmQgeiBjb29yZGluYXRlcy5cbiAqXG4gKiBAcGFyYW0ge051bWJlcn0geCBUaGUgeCBjb29yZGluYXRlLlxuICogQHBhcmFtIHtOdW1iZXJ9IHkgVGhlIHkgY29vcmRpbmF0ZS5cbiAqIEBwYXJhbSB7TnVtYmVyfSB6IFRoZSB6IGNvb3JkaW5hdGUuXG4gKiBAcGFyYW0ge0NhcnRlc2lhbjN9IFtyZXN1bHRdIFRoZSBvYmplY3Qgb250byB3aGljaCB0byBzdG9yZSB0aGUgcmVzdWx0LlxuICogQHJldHVybnMge0NhcnRlc2lhbjN9IFRoZSBtb2RpZmllZCByZXN1bHQgcGFyYW1ldGVyIG9yIGEgbmV3IENhcnRlc2lhbjMgaW5zdGFuY2UgaWYgb25lIHdhcyBub3QgcHJvdmlkZWQuXG4gKi9cbkNhcnRlc2lhbjMuZnJvbUVsZW1lbnRzID0gZnVuY3Rpb24gKHgsIHksIHosIHJlc3VsdCkge1xuICBpZiAoIWRlZmluZWQocmVzdWx0KSkge1xuICAgIHJldHVybiBuZXcgQ2FydGVzaWFuMyh4LCB5LCB6KTtcbiAgfVxuXG4gIHJlc3VsdC54ID0geDtcbiAgcmVzdWx0LnkgPSB5O1xuICByZXN1bHQueiA9IHo7XG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG4vKipcbiAqIER1cGxpY2F0ZXMgYSBDYXJ0ZXNpYW4zIGluc3RhbmNlLlxuICpcbiAqIEBwYXJhbSB7Q2FydGVzaWFuM30gY2FydGVzaWFuIFRoZSBDYXJ0ZXNpYW4gdG8gZHVwbGljYXRlLlxuICogQHBhcmFtIHtDYXJ0ZXNpYW4zfSBbcmVzdWx0XSBUaGUgb2JqZWN0IG9udG8gd2hpY2ggdG8gc3RvcmUgdGhlIHJlc3VsdC5cbiAqIEByZXR1cm5zIHtDYXJ0ZXNpYW4zfSBUaGUgbW9kaWZpZWQgcmVzdWx0IHBhcmFtZXRlciBvciBhIG5ldyBDYXJ0ZXNpYW4zIGluc3RhbmNlIGlmIG9uZSB3YXMgbm90IHByb3ZpZGVkLiAoUmV0dXJucyB1bmRlZmluZWQgaWYgY2FydGVzaWFuIGlzIHVuZGVmaW5lZClcbiAqL1xuQ2FydGVzaWFuMy5jbG9uZSA9IGZ1bmN0aW9uIChjYXJ0ZXNpYW4sIHJlc3VsdCkge1xuICBpZiAoIWRlZmluZWQoY2FydGVzaWFuKSkge1xuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cbiAgaWYgKCFkZWZpbmVkKHJlc3VsdCkpIHtcbiAgICByZXR1cm4gbmV3IENhcnRlc2lhbjMoY2FydGVzaWFuLngsIGNhcnRlc2lhbi55LCBjYXJ0ZXNpYW4ueik7XG4gIH1cblxuICByZXN1bHQueCA9IGNhcnRlc2lhbi54O1xuICByZXN1bHQueSA9IGNhcnRlc2lhbi55O1xuICByZXN1bHQueiA9IGNhcnRlc2lhbi56O1xuICByZXR1cm4gcmVzdWx0O1xufTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgQ2FydGVzaWFuMyBpbnN0YW5jZSBmcm9tIGFuIGV4aXN0aW5nIENhcnRlc2lhbjQuICBUaGlzIHNpbXBseSB0YWtlcyB0aGVcbiAqIHgsIHksIGFuZCB6IHByb3BlcnRpZXMgb2YgdGhlIENhcnRlc2lhbjQgYW5kIGRyb3BzIHcuXG4gKiBAZnVuY3Rpb25cbiAqXG4gKiBAcGFyYW0ge0NhcnRlc2lhbjR9IGNhcnRlc2lhbiBUaGUgQ2FydGVzaWFuNCBpbnN0YW5jZSB0byBjcmVhdGUgYSBDYXJ0ZXNpYW4zIGluc3RhbmNlIGZyb20uXG4gKiBAcGFyYW0ge0NhcnRlc2lhbjN9IFtyZXN1bHRdIFRoZSBvYmplY3Qgb250byB3aGljaCB0byBzdG9yZSB0aGUgcmVzdWx0LlxuICogQHJldHVybnMge0NhcnRlc2lhbjN9IFRoZSBtb2RpZmllZCByZXN1bHQgcGFyYW1ldGVyIG9yIGEgbmV3IENhcnRlc2lhbjMgaW5zdGFuY2UgaWYgb25lIHdhcyBub3QgcHJvdmlkZWQuXG4gKi9cbkNhcnRlc2lhbjMuZnJvbUNhcnRlc2lhbjQgPSBDYXJ0ZXNpYW4zLmNsb25lO1xuXG4vKipcbiAqIFRoZSBudW1iZXIgb2YgZWxlbWVudHMgdXNlZCB0byBwYWNrIHRoZSBvYmplY3QgaW50byBhbiBhcnJheS5cbiAqIEB0eXBlIHtOdW1iZXJ9XG4gKi9cbkNhcnRlc2lhbjMucGFja2VkTGVuZ3RoID0gMztcblxuLyoqXG4gKiBTdG9yZXMgdGhlIHByb3ZpZGVkIGluc3RhbmNlIGludG8gdGhlIHByb3ZpZGVkIGFycmF5LlxuICpcbiAqIEBwYXJhbSB7Q2FydGVzaWFuM30gdmFsdWUgVGhlIHZhbHVlIHRvIHBhY2suXG4gKiBAcGFyYW0ge051bWJlcltdfSBhcnJheSBUaGUgYXJyYXkgdG8gcGFjayBpbnRvLlxuICogQHBhcmFtIHtOdW1iZXJ9IFtzdGFydGluZ0luZGV4PTBdIFRoZSBpbmRleCBpbnRvIHRoZSBhcnJheSBhdCB3aGljaCB0byBzdGFydCBwYWNraW5nIHRoZSBlbGVtZW50cy5cbiAqXG4gKiBAcmV0dXJucyB7TnVtYmVyW119IFRoZSBhcnJheSB0aGF0IHdhcyBwYWNrZWQgaW50b1xuICovXG5DYXJ0ZXNpYW4zLnBhY2sgPSBmdW5jdGlvbiAodmFsdWUsIGFycmF5LCBzdGFydGluZ0luZGV4KSB7XG4gIC8vPj5pbmNsdWRlU3RhcnQoJ2RlYnVnJywgcHJhZ21hcy5kZWJ1Zyk7XG4gIENoZWNrLnR5cGVPZi5vYmplY3QoXCJ2YWx1ZVwiLCB2YWx1ZSk7XG4gIENoZWNrLmRlZmluZWQoXCJhcnJheVwiLCBhcnJheSk7XG4gIC8vPj5pbmNsdWRlRW5kKCdkZWJ1ZycpO1xuXG4gIHN0YXJ0aW5nSW5kZXggPSBkZWZhdWx0VmFsdWUoc3RhcnRpbmdJbmRleCwgMCk7XG5cbiAgYXJyYXlbc3RhcnRpbmdJbmRleCsrXSA9IHZhbHVlLng7XG4gIGFycmF5W3N0YXJ0aW5nSW5kZXgrK10gPSB2YWx1ZS55O1xuICBhcnJheVtzdGFydGluZ0luZGV4XSA9IHZhbHVlLno7XG5cbiAgcmV0dXJuIGFycmF5O1xufTtcblxuLyoqXG4gKiBSZXRyaWV2ZXMgYW4gaW5zdGFuY2UgZnJvbSBhIHBhY2tlZCBhcnJheS5cbiAqXG4gKiBAcGFyYW0ge051bWJlcltdfSBhcnJheSBUaGUgcGFja2VkIGFycmF5LlxuICogQHBhcmFtIHtOdW1iZXJ9IFtzdGFydGluZ0luZGV4PTBdIFRoZSBzdGFydGluZyBpbmRleCBvZiB0aGUgZWxlbWVudCB0byBiZSB1bnBhY2tlZC5cbiAqIEBwYXJhbSB7Q2FydGVzaWFuM30gW3Jlc3VsdF0gVGhlIG9iamVjdCBpbnRvIHdoaWNoIHRvIHN0b3JlIHRoZSByZXN1bHQuXG4gKiBAcmV0dXJucyB7Q2FydGVzaWFuM30gVGhlIG1vZGlmaWVkIHJlc3VsdCBwYXJhbWV0ZXIgb3IgYSBuZXcgQ2FydGVzaWFuMyBpbnN0YW5jZSBpZiBvbmUgd2FzIG5vdCBwcm92aWRlZC5cbiAqL1xuQ2FydGVzaWFuMy51bnBhY2sgPSBmdW5jdGlvbiAoYXJyYXksIHN0YXJ0aW5nSW5kZXgsIHJlc3VsdCkge1xuICAvLz4+aW5jbHVkZVN0YXJ0KCdkZWJ1ZycsIHByYWdtYXMuZGVidWcpO1xuICBDaGVjay5kZWZpbmVkKFwiYXJyYXlcIiwgYXJyYXkpO1xuICAvLz4+aW5jbHVkZUVuZCgnZGVidWcnKTtcblxuICBzdGFydGluZ0luZGV4ID0gZGVmYXVsdFZhbHVlKHN0YXJ0aW5nSW5kZXgsIDApO1xuXG4gIGlmICghZGVmaW5lZChyZXN1bHQpKSB7XG4gICAgcmVzdWx0ID0gbmV3IENhcnRlc2lhbjMoKTtcbiAgfVxuICByZXN1bHQueCA9IGFycmF5W3N0YXJ0aW5nSW5kZXgrK107XG4gIHJlc3VsdC55ID0gYXJyYXlbc3RhcnRpbmdJbmRleCsrXTtcbiAgcmVzdWx0LnogPSBhcnJheVtzdGFydGluZ0luZGV4XTtcbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbi8qKlxuICogRmxhdHRlbnMgYW4gYXJyYXkgb2YgQ2FydGVzaWFuM3MgaW50byBhbiBhcnJheSBvZiBjb21wb25lbnRzLlxuICpcbiAqIEBwYXJhbSB7Q2FydGVzaWFuM1tdfSBhcnJheSBUaGUgYXJyYXkgb2YgY2FydGVzaWFucyB0byBwYWNrLlxuICogQHBhcmFtIHtOdW1iZXJbXX0gW3Jlc3VsdF0gVGhlIGFycmF5IG9udG8gd2hpY2ggdG8gc3RvcmUgdGhlIHJlc3VsdC4gSWYgdGhpcyBpcyBhIHR5cGVkIGFycmF5LCBpdCBtdXN0IGhhdmUgYXJyYXkubGVuZ3RoICogMyBjb21wb25lbnRzLCBlbHNlIGEge0BsaW5rIERldmVsb3BlckVycm9yfSB3aWxsIGJlIHRocm93bi4gSWYgaXQgaXMgYSByZWd1bGFyIGFycmF5LCBpdCB3aWxsIGJlIHJlc2l6ZWQgdG8gaGF2ZSAoYXJyYXkubGVuZ3RoICogMykgZWxlbWVudHMuXG4gKiBAcmV0dXJucyB7TnVtYmVyW119IFRoZSBwYWNrZWQgYXJyYXkuXG4gKi9cbkNhcnRlc2lhbjMucGFja0FycmF5ID0gZnVuY3Rpb24gKGFycmF5LCByZXN1bHQpIHtcbiAgLy8+PmluY2x1ZGVTdGFydCgnZGVidWcnLCBwcmFnbWFzLmRlYnVnKTtcbiAgQ2hlY2suZGVmaW5lZChcImFycmF5XCIsIGFycmF5KTtcbiAgLy8+PmluY2x1ZGVFbmQoJ2RlYnVnJyk7XG5cbiAgdmFyIGxlbmd0aCA9IGFycmF5Lmxlbmd0aDtcbiAgdmFyIHJlc3VsdExlbmd0aCA9IGxlbmd0aCAqIDM7XG4gIGlmICghZGVmaW5lZChyZXN1bHQpKSB7XG4gICAgcmVzdWx0ID0gbmV3IEFycmF5KHJlc3VsdExlbmd0aCk7XG4gIH0gZWxzZSBpZiAoIUFycmF5LmlzQXJyYXkocmVzdWx0KSAmJiByZXN1bHQubGVuZ3RoICE9PSByZXN1bHRMZW5ndGgpIHtcbiAgICB0aHJvdyBuZXcgRGV2ZWxvcGVyRXJyb3IoXG4gICAgICBcIklmIHJlc3VsdCBpcyBhIHR5cGVkIGFycmF5LCBpdCBtdXN0IGhhdmUgZXhhY3RseSBhcnJheS5sZW5ndGggKiAzIGVsZW1lbnRzXCJcbiAgICApO1xuICB9IGVsc2UgaWYgKHJlc3VsdC5sZW5ndGggIT09IHJlc3VsdExlbmd0aCkge1xuICAgIHJlc3VsdC5sZW5ndGggPSByZXN1bHRMZW5ndGg7XG4gIH1cblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgKytpKSB7XG4gICAgQ2FydGVzaWFuMy5wYWNrKGFycmF5W2ldLCByZXN1bHQsIGkgKiAzKTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufTtcblxuLyoqXG4gKiBVbnBhY2tzIGFuIGFycmF5IG9mIGNhcnRlc2lhbiBjb21wb25lbnRzIGludG8gYW4gYXJyYXkgb2YgQ2FydGVzaWFuM3MuXG4gKlxuICogQHBhcmFtIHtOdW1iZXJbXX0gYXJyYXkgVGhlIGFycmF5IG9mIGNvbXBvbmVudHMgdG8gdW5wYWNrLlxuICogQHBhcmFtIHtDYXJ0ZXNpYW4zW119IFtyZXN1bHRdIFRoZSBhcnJheSBvbnRvIHdoaWNoIHRvIHN0b3JlIHRoZSByZXN1bHQuXG4gKiBAcmV0dXJucyB7Q2FydGVzaWFuM1tdfSBUaGUgdW5wYWNrZWQgYXJyYXkuXG4gKi9cbkNhcnRlc2lhbjMudW5wYWNrQXJyYXkgPSBmdW5jdGlvbiAoYXJyYXksIHJlc3VsdCkge1xuICAvLz4+aW5jbHVkZVN0YXJ0KCdkZWJ1ZycsIHByYWdtYXMuZGVidWcpO1xuICBDaGVjay5kZWZpbmVkKFwiYXJyYXlcIiwgYXJyYXkpO1xuICBDaGVjay50eXBlT2YubnVtYmVyLmdyZWF0ZXJUaGFuT3JFcXVhbHMoXCJhcnJheS5sZW5ndGhcIiwgYXJyYXkubGVuZ3RoLCAzKTtcbiAgaWYgKGFycmF5Lmxlbmd0aCAlIDMgIT09IDApIHtcbiAgICB0aHJvdyBuZXcgRGV2ZWxvcGVyRXJyb3IoXCJhcnJheSBsZW5ndGggbXVzdCBiZSBhIG11bHRpcGxlIG9mIDMuXCIpO1xuICB9XG4gIC8vPj5pbmNsdWRlRW5kKCdkZWJ1ZycpO1xuXG4gIHZhciBsZW5ndGggPSBhcnJheS5sZW5ndGg7XG4gIGlmICghZGVmaW5lZChyZXN1bHQpKSB7XG4gICAgcmVzdWx0ID0gbmV3IEFycmF5KGxlbmd0aCAvIDMpO1xuICB9IGVsc2Uge1xuICAgIHJlc3VsdC5sZW5ndGggPSBsZW5ndGggLyAzO1xuICB9XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkgKz0gMykge1xuICAgIHZhciBpbmRleCA9IGkgLyAzO1xuICAgIHJlc3VsdFtpbmRleF0gPSBDYXJ0ZXNpYW4zLnVucGFjayhhcnJheSwgaSwgcmVzdWx0W2luZGV4XSk7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbi8qKlxuICogQ3JlYXRlcyBhIENhcnRlc2lhbjMgZnJvbSB0aHJlZSBjb25zZWN1dGl2ZSBlbGVtZW50cyBpbiBhbiBhcnJheS5cbiAqIEBmdW5jdGlvblxuICpcbiAqIEBwYXJhbSB7TnVtYmVyW119IGFycmF5IFRoZSBhcnJheSB3aG9zZSB0aHJlZSBjb25zZWN1dGl2ZSBlbGVtZW50cyBjb3JyZXNwb25kIHRvIHRoZSB4LCB5LCBhbmQgeiBjb21wb25lbnRzLCByZXNwZWN0aXZlbHkuXG4gKiBAcGFyYW0ge051bWJlcn0gW3N0YXJ0aW5nSW5kZXg9MF0gVGhlIG9mZnNldCBpbnRvIHRoZSBhcnJheSBvZiB0aGUgZmlyc3QgZWxlbWVudCwgd2hpY2ggY29ycmVzcG9uZHMgdG8gdGhlIHggY29tcG9uZW50LlxuICogQHBhcmFtIHtDYXJ0ZXNpYW4zfSBbcmVzdWx0XSBUaGUgb2JqZWN0IG9udG8gd2hpY2ggdG8gc3RvcmUgdGhlIHJlc3VsdC5cbiAqIEByZXR1cm5zIHtDYXJ0ZXNpYW4zfSBUaGUgbW9kaWZpZWQgcmVzdWx0IHBhcmFtZXRlciBvciBhIG5ldyBDYXJ0ZXNpYW4zIGluc3RhbmNlIGlmIG9uZSB3YXMgbm90IHByb3ZpZGVkLlxuICpcbiAqIEBleGFtcGxlXG4gKiAvLyBDcmVhdGUgYSBDYXJ0ZXNpYW4zIHdpdGggKDEuMCwgMi4wLCAzLjApXG4gKiB2YXIgdiA9IFsxLjAsIDIuMCwgMy4wXTtcbiAqIHZhciBwID0gQ2VzaXVtLkNhcnRlc2lhbjMuZnJvbUFycmF5KHYpO1xuICpcbiAqIC8vIENyZWF0ZSBhIENhcnRlc2lhbjMgd2l0aCAoMS4wLCAyLjAsIDMuMCkgdXNpbmcgYW4gb2Zmc2V0IGludG8gYW4gYXJyYXlcbiAqIHZhciB2MiA9IFswLjAsIDAuMCwgMS4wLCAyLjAsIDMuMF07XG4gKiB2YXIgcDIgPSBDZXNpdW0uQ2FydGVzaWFuMy5mcm9tQXJyYXkodjIsIDIpO1xuICovXG5DYXJ0ZXNpYW4zLmZyb21BcnJheSA9IENhcnRlc2lhbjMudW5wYWNrO1xuXG4vKipcbiAqIENvbXB1dGVzIHRoZSB2YWx1ZSBvZiB0aGUgbWF4aW11bSBjb21wb25lbnQgZm9yIHRoZSBzdXBwbGllZCBDYXJ0ZXNpYW4uXG4gKlxuICogQHBhcmFtIHtDYXJ0ZXNpYW4zfSBjYXJ0ZXNpYW4gVGhlIGNhcnRlc2lhbiB0byB1c2UuXG4gKiBAcmV0dXJucyB7TnVtYmVyfSBUaGUgdmFsdWUgb2YgdGhlIG1heGltdW0gY29tcG9uZW50LlxuICovXG5DYXJ0ZXNpYW4zLm1heGltdW1Db21wb25lbnQgPSBmdW5jdGlvbiAoY2FydGVzaWFuKSB7XG4gIC8vPj5pbmNsdWRlU3RhcnQoJ2RlYnVnJywgcHJhZ21hcy5kZWJ1Zyk7XG4gIENoZWNrLnR5cGVPZi5vYmplY3QoXCJjYXJ0ZXNpYW5cIiwgY2FydGVzaWFuKTtcbiAgLy8+PmluY2x1ZGVFbmQoJ2RlYnVnJyk7XG5cbiAgcmV0dXJuIE1hdGgubWF4KGNhcnRlc2lhbi54LCBjYXJ0ZXNpYW4ueSwgY2FydGVzaWFuLnopO1xufTtcblxuLyoqXG4gKiBDb21wdXRlcyB0aGUgdmFsdWUgb2YgdGhlIG1pbmltdW0gY29tcG9uZW50IGZvciB0aGUgc3VwcGxpZWQgQ2FydGVzaWFuLlxuICpcbiAqIEBwYXJhbSB7Q2FydGVzaWFuM30gY2FydGVzaWFuIFRoZSBjYXJ0ZXNpYW4gdG8gdXNlLlxuICogQHJldHVybnMge051bWJlcn0gVGhlIHZhbHVlIG9mIHRoZSBtaW5pbXVtIGNvbXBvbmVudC5cbiAqL1xuQ2FydGVzaWFuMy5taW5pbXVtQ29tcG9uZW50ID0gZnVuY3Rpb24gKGNhcnRlc2lhbikge1xuICAvLz4+aW5jbHVkZVN0YXJ0KCdkZWJ1ZycsIHByYWdtYXMuZGVidWcpO1xuICBDaGVjay50eXBlT2Yub2JqZWN0KFwiY2FydGVzaWFuXCIsIGNhcnRlc2lhbik7XG4gIC8vPj5pbmNsdWRlRW5kKCdkZWJ1ZycpO1xuXG4gIHJldHVybiBNYXRoLm1pbihjYXJ0ZXNpYW4ueCwgY2FydGVzaWFuLnksIGNhcnRlc2lhbi56KTtcbn07XG5cbi8qKlxuICogQ29tcGFyZXMgdHdvIENhcnRlc2lhbnMgYW5kIGNvbXB1dGVzIGEgQ2FydGVzaWFuIHdoaWNoIGNvbnRhaW5zIHRoZSBtaW5pbXVtIGNvbXBvbmVudHMgb2YgdGhlIHN1cHBsaWVkIENhcnRlc2lhbnMuXG4gKlxuICogQHBhcmFtIHtDYXJ0ZXNpYW4zfSBmaXJzdCBBIGNhcnRlc2lhbiB0byBjb21wYXJlLlxuICogQHBhcmFtIHtDYXJ0ZXNpYW4zfSBzZWNvbmQgQSBjYXJ0ZXNpYW4gdG8gY29tcGFyZS5cbiAqIEBwYXJhbSB7Q2FydGVzaWFuM30gcmVzdWx0IFRoZSBvYmplY3QgaW50byB3aGljaCB0byBzdG9yZSB0aGUgcmVzdWx0LlxuICogQHJldHVybnMge0NhcnRlc2lhbjN9IEEgY2FydGVzaWFuIHdpdGggdGhlIG1pbmltdW0gY29tcG9uZW50cy5cbiAqL1xuQ2FydGVzaWFuMy5taW5pbXVtQnlDb21wb25lbnQgPSBmdW5jdGlvbiAoZmlyc3QsIHNlY29uZCwgcmVzdWx0KSB7XG4gIC8vPj5pbmNsdWRlU3RhcnQoJ2RlYnVnJywgcHJhZ21hcy5kZWJ1Zyk7XG4gIENoZWNrLnR5cGVPZi5vYmplY3QoXCJmaXJzdFwiLCBmaXJzdCk7XG4gIENoZWNrLnR5cGVPZi5vYmplY3QoXCJzZWNvbmRcIiwgc2Vjb25kKTtcbiAgQ2hlY2sudHlwZU9mLm9iamVjdChcInJlc3VsdFwiLCByZXN1bHQpO1xuICAvLz4+aW5jbHVkZUVuZCgnZGVidWcnKTtcblxuICByZXN1bHQueCA9IE1hdGgubWluKGZpcnN0LngsIHNlY29uZC54KTtcbiAgcmVzdWx0LnkgPSBNYXRoLm1pbihmaXJzdC55LCBzZWNvbmQueSk7XG4gIHJlc3VsdC56ID0gTWF0aC5taW4oZmlyc3Queiwgc2Vjb25kLnopO1xuXG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG4vKipcbiAqIENvbXBhcmVzIHR3byBDYXJ0ZXNpYW5zIGFuZCBjb21wdXRlcyBhIENhcnRlc2lhbiB3aGljaCBjb250YWlucyB0aGUgbWF4aW11bSBjb21wb25lbnRzIG9mIHRoZSBzdXBwbGllZCBDYXJ0ZXNpYW5zLlxuICpcbiAqIEBwYXJhbSB7Q2FydGVzaWFuM30gZmlyc3QgQSBjYXJ0ZXNpYW4gdG8gY29tcGFyZS5cbiAqIEBwYXJhbSB7Q2FydGVzaWFuM30gc2Vjb25kIEEgY2FydGVzaWFuIHRvIGNvbXBhcmUuXG4gKiBAcGFyYW0ge0NhcnRlc2lhbjN9IHJlc3VsdCBUaGUgb2JqZWN0IGludG8gd2hpY2ggdG8gc3RvcmUgdGhlIHJlc3VsdC5cbiAqIEByZXR1cm5zIHtDYXJ0ZXNpYW4zfSBBIGNhcnRlc2lhbiB3aXRoIHRoZSBtYXhpbXVtIGNvbXBvbmVudHMuXG4gKi9cbkNhcnRlc2lhbjMubWF4aW11bUJ5Q29tcG9uZW50ID0gZnVuY3Rpb24gKGZpcnN0LCBzZWNvbmQsIHJlc3VsdCkge1xuICAvLz4+aW5jbHVkZVN0YXJ0KCdkZWJ1ZycsIHByYWdtYXMuZGVidWcpO1xuICBDaGVjay50eXBlT2Yub2JqZWN0KFwiZmlyc3RcIiwgZmlyc3QpO1xuICBDaGVjay50eXBlT2Yub2JqZWN0KFwic2Vjb25kXCIsIHNlY29uZCk7XG4gIENoZWNrLnR5cGVPZi5vYmplY3QoXCJyZXN1bHRcIiwgcmVzdWx0KTtcbiAgLy8+PmluY2x1ZGVFbmQoJ2RlYnVnJyk7XG5cbiAgcmVzdWx0LnggPSBNYXRoLm1heChmaXJzdC54LCBzZWNvbmQueCk7XG4gIHJlc3VsdC55ID0gTWF0aC5tYXgoZmlyc3QueSwgc2Vjb25kLnkpO1xuICByZXN1bHQueiA9IE1hdGgubWF4KGZpcnN0LnosIHNlY29uZC56KTtcbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbi8qKlxuICogQ29tcHV0ZXMgdGhlIHByb3ZpZGVkIENhcnRlc2lhbidzIHNxdWFyZWQgbWFnbml0dWRlLlxuICpcbiAqIEBwYXJhbSB7Q2FydGVzaWFuM30gY2FydGVzaWFuIFRoZSBDYXJ0ZXNpYW4gaW5zdGFuY2Ugd2hvc2Ugc3F1YXJlZCBtYWduaXR1ZGUgaXMgdG8gYmUgY29tcHV0ZWQuXG4gKiBAcmV0dXJucyB7TnVtYmVyfSBUaGUgc3F1YXJlZCBtYWduaXR1ZGUuXG4gKi9cbkNhcnRlc2lhbjMubWFnbml0dWRlU3F1YXJlZCA9IGZ1bmN0aW9uIChjYXJ0ZXNpYW4pIHtcbiAgLy8+PmluY2x1ZGVTdGFydCgnZGVidWcnLCBwcmFnbWFzLmRlYnVnKTtcbiAgQ2hlY2sudHlwZU9mLm9iamVjdChcImNhcnRlc2lhblwiLCBjYXJ0ZXNpYW4pO1xuICAvLz4+aW5jbHVkZUVuZCgnZGVidWcnKTtcblxuICByZXR1cm4gKFxuICAgIGNhcnRlc2lhbi54ICogY2FydGVzaWFuLnggK1xuICAgIGNhcnRlc2lhbi55ICogY2FydGVzaWFuLnkgK1xuICAgIGNhcnRlc2lhbi56ICogY2FydGVzaWFuLnpcbiAgKTtcbn07XG5cbi8qKlxuICogQ29tcHV0ZXMgdGhlIENhcnRlc2lhbidzIG1hZ25pdHVkZSAobGVuZ3RoKS5cbiAqXG4gKiBAcGFyYW0ge0NhcnRlc2lhbjN9IGNhcnRlc2lhbiBUaGUgQ2FydGVzaWFuIGluc3RhbmNlIHdob3NlIG1hZ25pdHVkZSBpcyB0byBiZSBjb21wdXRlZC5cbiAqIEByZXR1cm5zIHtOdW1iZXJ9IFRoZSBtYWduaXR1ZGUuXG4gKi9cbkNhcnRlc2lhbjMubWFnbml0dWRlID0gZnVuY3Rpb24gKGNhcnRlc2lhbikge1xuICByZXR1cm4gTWF0aC5zcXJ0KENhcnRlc2lhbjMubWFnbml0dWRlU3F1YXJlZChjYXJ0ZXNpYW4pKTtcbn07XG5cbnZhciBkaXN0YW5jZVNjcmF0Y2ggPSBuZXcgQ2FydGVzaWFuMygpO1xuXG4vKipcbiAqIENvbXB1dGVzIHRoZSBkaXN0YW5jZSBiZXR3ZWVuIHR3byBwb2ludHMuXG4gKlxuICogQHBhcmFtIHtDYXJ0ZXNpYW4zfSBsZWZ0IFRoZSBmaXJzdCBwb2ludCB0byBjb21wdXRlIHRoZSBkaXN0YW5jZSBmcm9tLlxuICogQHBhcmFtIHtDYXJ0ZXNpYW4zfSByaWdodCBUaGUgc2Vjb25kIHBvaW50IHRvIGNvbXB1dGUgdGhlIGRpc3RhbmNlIHRvLlxuICogQHJldHVybnMge051bWJlcn0gVGhlIGRpc3RhbmNlIGJldHdlZW4gdHdvIHBvaW50cy5cbiAqXG4gKiBAZXhhbXBsZVxuICogLy8gUmV0dXJucyAxLjBcbiAqIHZhciBkID0gQ2VzaXVtLkNhcnRlc2lhbjMuZGlzdGFuY2UobmV3IENlc2l1bS5DYXJ0ZXNpYW4zKDEuMCwgMC4wLCAwLjApLCBuZXcgQ2VzaXVtLkNhcnRlc2lhbjMoMi4wLCAwLjAsIDAuMCkpO1xuICovXG5DYXJ0ZXNpYW4zLmRpc3RhbmNlID0gZnVuY3Rpb24gKGxlZnQsIHJpZ2h0KSB7XG4gIC8vPj5pbmNsdWRlU3RhcnQoJ2RlYnVnJywgcHJhZ21hcy5kZWJ1Zyk7XG4gIENoZWNrLnR5cGVPZi5vYmplY3QoXCJsZWZ0XCIsIGxlZnQpO1xuICBDaGVjay50eXBlT2Yub2JqZWN0KFwicmlnaHRcIiwgcmlnaHQpO1xuICAvLz4+aW5jbHVkZUVuZCgnZGVidWcnKTtcblxuICBDYXJ0ZXNpYW4zLnN1YnRyYWN0KGxlZnQsIHJpZ2h0LCBkaXN0YW5jZVNjcmF0Y2gpO1xuICByZXR1cm4gQ2FydGVzaWFuMy5tYWduaXR1ZGUoZGlzdGFuY2VTY3JhdGNoKTtcbn07XG5cbi8qKlxuICogQ29tcHV0ZXMgdGhlIHNxdWFyZWQgZGlzdGFuY2UgYmV0d2VlbiB0d28gcG9pbnRzLiAgQ29tcGFyaW5nIHNxdWFyZWQgZGlzdGFuY2VzXG4gKiB1c2luZyB0aGlzIGZ1bmN0aW9uIGlzIG1vcmUgZWZmaWNpZW50IHRoYW4gY29tcGFyaW5nIGRpc3RhbmNlcyB1c2luZyB7QGxpbmsgQ2FydGVzaWFuMyNkaXN0YW5jZX0uXG4gKlxuICogQHBhcmFtIHtDYXJ0ZXNpYW4zfSBsZWZ0IFRoZSBmaXJzdCBwb2ludCB0byBjb21wdXRlIHRoZSBkaXN0YW5jZSBmcm9tLlxuICogQHBhcmFtIHtDYXJ0ZXNpYW4zfSByaWdodCBUaGUgc2Vjb25kIHBvaW50IHRvIGNvbXB1dGUgdGhlIGRpc3RhbmNlIHRvLlxuICogQHJldHVybnMge051bWJlcn0gVGhlIGRpc3RhbmNlIGJldHdlZW4gdHdvIHBvaW50cy5cbiAqXG4gKiBAZXhhbXBsZVxuICogLy8gUmV0dXJucyA0LjAsIG5vdCAyLjBcbiAqIHZhciBkID0gQ2VzaXVtLkNhcnRlc2lhbjMuZGlzdGFuY2VTcXVhcmVkKG5ldyBDZXNpdW0uQ2FydGVzaWFuMygxLjAsIDAuMCwgMC4wKSwgbmV3IENlc2l1bS5DYXJ0ZXNpYW4zKDMuMCwgMC4wLCAwLjApKTtcbiAqL1xuQ2FydGVzaWFuMy5kaXN0YW5jZVNxdWFyZWQgPSBmdW5jdGlvbiAobGVmdCwgcmlnaHQpIHtcbiAgLy8+PmluY2x1ZGVTdGFydCgnZGVidWcnLCBwcmFnbWFzLmRlYnVnKTtcbiAgQ2hlY2sudHlwZU9mLm9iamVjdChcImxlZnRcIiwgbGVmdCk7XG4gIENoZWNrLnR5cGVPZi5vYmplY3QoXCJyaWdodFwiLCByaWdodCk7XG4gIC8vPj5pbmNsdWRlRW5kKCdkZWJ1ZycpO1xuXG4gIENhcnRlc2lhbjMuc3VidHJhY3QobGVmdCwgcmlnaHQsIGRpc3RhbmNlU2NyYXRjaCk7XG4gIHJldHVybiBDYXJ0ZXNpYW4zLm1hZ25pdHVkZVNxdWFyZWQoZGlzdGFuY2VTY3JhdGNoKTtcbn07XG5cbi8qKlxuICogQ29tcHV0ZXMgdGhlIG5vcm1hbGl6ZWQgZm9ybSBvZiB0aGUgc3VwcGxpZWQgQ2FydGVzaWFuLlxuICpcbiAqIEBwYXJhbSB7Q2FydGVzaWFuM30gY2FydGVzaWFuIFRoZSBDYXJ0ZXNpYW4gdG8gYmUgbm9ybWFsaXplZC5cbiAqIEBwYXJhbSB7Q2FydGVzaWFuM30gcmVzdWx0IFRoZSBvYmplY3Qgb250byB3aGljaCB0byBzdG9yZSB0aGUgcmVzdWx0LlxuICogQHJldHVybnMge0NhcnRlc2lhbjN9IFRoZSBtb2RpZmllZCByZXN1bHQgcGFyYW1ldGVyLlxuICovXG5DYXJ0ZXNpYW4zLm5vcm1hbGl6ZSA9IGZ1bmN0aW9uIChjYXJ0ZXNpYW4sIHJlc3VsdCkge1xuICAvLz4+aW5jbHVkZVN0YXJ0KCdkZWJ1ZycsIHByYWdtYXMuZGVidWcpO1xuICBDaGVjay50eXBlT2Yub2JqZWN0KFwiY2FydGVzaWFuXCIsIGNhcnRlc2lhbik7XG4gIENoZWNrLnR5cGVPZi5vYmplY3QoXCJyZXN1bHRcIiwgcmVzdWx0KTtcbiAgLy8+PmluY2x1ZGVFbmQoJ2RlYnVnJyk7XG5cbiAgdmFyIG1hZ25pdHVkZSA9IENhcnRlc2lhbjMubWFnbml0dWRlKGNhcnRlc2lhbik7XG5cbiAgcmVzdWx0LnggPSBjYXJ0ZXNpYW4ueCAvIG1hZ25pdHVkZTtcbiAgcmVzdWx0LnkgPSBjYXJ0ZXNpYW4ueSAvIG1hZ25pdHVkZTtcbiAgcmVzdWx0LnogPSBjYXJ0ZXNpYW4ueiAvIG1hZ25pdHVkZTtcblxuICAvLz4+aW5jbHVkZVN0YXJ0KCdkZWJ1ZycsIHByYWdtYXMuZGVidWcpO1xuICBpZiAoaXNOYU4ocmVzdWx0LngpIHx8IGlzTmFOKHJlc3VsdC55KSB8fCBpc05hTihyZXN1bHQueikpIHtcbiAgICB0aHJvdyBuZXcgRGV2ZWxvcGVyRXJyb3IoXCJub3JtYWxpemVkIHJlc3VsdCBpcyBub3QgYSBudW1iZXJcIik7XG4gIH1cbiAgLy8+PmluY2x1ZGVFbmQoJ2RlYnVnJyk7XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbi8qKlxuICogQ29tcHV0ZXMgdGhlIGRvdCAoc2NhbGFyKSBwcm9kdWN0IG9mIHR3byBDYXJ0ZXNpYW5zLlxuICpcbiAqIEBwYXJhbSB7Q2FydGVzaWFuM30gbGVmdCBUaGUgZmlyc3QgQ2FydGVzaWFuLlxuICogQHBhcmFtIHtDYXJ0ZXNpYW4zfSByaWdodCBUaGUgc2Vjb25kIENhcnRlc2lhbi5cbiAqIEByZXR1cm5zIHtOdW1iZXJ9IFRoZSBkb3QgcHJvZHVjdC5cbiAqL1xuQ2FydGVzaWFuMy5kb3QgPSBmdW5jdGlvbiAobGVmdCwgcmlnaHQpIHtcbiAgLy8+PmluY2x1ZGVTdGFydCgnZGVidWcnLCBwcmFnbWFzLmRlYnVnKTtcbiAgQ2hlY2sudHlwZU9mLm9iamVjdChcImxlZnRcIiwgbGVmdCk7XG4gIENoZWNrLnR5cGVPZi5vYmplY3QoXCJyaWdodFwiLCByaWdodCk7XG4gIC8vPj5pbmNsdWRlRW5kKCdkZWJ1ZycpO1xuXG4gIHJldHVybiBsZWZ0LnggKiByaWdodC54ICsgbGVmdC55ICogcmlnaHQueSArIGxlZnQueiAqIHJpZ2h0Lno7XG59O1xuXG4vKipcbiAqIENvbXB1dGVzIHRoZSBjb21wb25lbnR3aXNlIHByb2R1Y3Qgb2YgdHdvIENhcnRlc2lhbnMuXG4gKlxuICogQHBhcmFtIHtDYXJ0ZXNpYW4zfSBsZWZ0IFRoZSBmaXJzdCBDYXJ0ZXNpYW4uXG4gKiBAcGFyYW0ge0NhcnRlc2lhbjN9IHJpZ2h0IFRoZSBzZWNvbmQgQ2FydGVzaWFuLlxuICogQHBhcmFtIHtDYXJ0ZXNpYW4zfSByZXN1bHQgVGhlIG9iamVjdCBvbnRvIHdoaWNoIHRvIHN0b3JlIHRoZSByZXN1bHQuXG4gKiBAcmV0dXJucyB7Q2FydGVzaWFuM30gVGhlIG1vZGlmaWVkIHJlc3VsdCBwYXJhbWV0ZXIuXG4gKi9cbkNhcnRlc2lhbjMubXVsdGlwbHlDb21wb25lbnRzID0gZnVuY3Rpb24gKGxlZnQsIHJpZ2h0LCByZXN1bHQpIHtcbiAgLy8+PmluY2x1ZGVTdGFydCgnZGVidWcnLCBwcmFnbWFzLmRlYnVnKTtcbiAgQ2hlY2sudHlwZU9mLm9iamVjdChcImxlZnRcIiwgbGVmdCk7XG4gIENoZWNrLnR5cGVPZi5vYmplY3QoXCJyaWdodFwiLCByaWdodCk7XG4gIENoZWNrLnR5cGVPZi5vYmplY3QoXCJyZXN1bHRcIiwgcmVzdWx0KTtcbiAgLy8+PmluY2x1ZGVFbmQoJ2RlYnVnJyk7XG5cbiAgcmVzdWx0LnggPSBsZWZ0LnggKiByaWdodC54O1xuICByZXN1bHQueSA9IGxlZnQueSAqIHJpZ2h0Lnk7XG4gIHJlc3VsdC56ID0gbGVmdC56ICogcmlnaHQuejtcbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbi8qKlxuICogQ29tcHV0ZXMgdGhlIGNvbXBvbmVudHdpc2UgcXVvdGllbnQgb2YgdHdvIENhcnRlc2lhbnMuXG4gKlxuICogQHBhcmFtIHtDYXJ0ZXNpYW4zfSBsZWZ0IFRoZSBmaXJzdCBDYXJ0ZXNpYW4uXG4gKiBAcGFyYW0ge0NhcnRlc2lhbjN9IHJpZ2h0IFRoZSBzZWNvbmQgQ2FydGVzaWFuLlxuICogQHBhcmFtIHtDYXJ0ZXNpYW4zfSByZXN1bHQgVGhlIG9iamVjdCBvbnRvIHdoaWNoIHRvIHN0b3JlIHRoZSByZXN1bHQuXG4gKiBAcmV0dXJucyB7Q2FydGVzaWFuM30gVGhlIG1vZGlmaWVkIHJlc3VsdCBwYXJhbWV0ZXIuXG4gKi9cbkNhcnRlc2lhbjMuZGl2aWRlQ29tcG9uZW50cyA9IGZ1bmN0aW9uIChsZWZ0LCByaWdodCwgcmVzdWx0KSB7XG4gIC8vPj5pbmNsdWRlU3RhcnQoJ2RlYnVnJywgcHJhZ21hcy5kZWJ1Zyk7XG4gIENoZWNrLnR5cGVPZi5vYmplY3QoXCJsZWZ0XCIsIGxlZnQpO1xuICBDaGVjay50eXBlT2Yub2JqZWN0KFwicmlnaHRcIiwgcmlnaHQpO1xuICBDaGVjay50eXBlT2Yub2JqZWN0KFwicmVzdWx0XCIsIHJlc3VsdCk7XG4gIC8vPj5pbmNsdWRlRW5kKCdkZWJ1ZycpO1xuXG4gIHJlc3VsdC54ID0gbGVmdC54IC8gcmlnaHQueDtcbiAgcmVzdWx0LnkgPSBsZWZ0LnkgLyByaWdodC55O1xuICByZXN1bHQueiA9IGxlZnQueiAvIHJpZ2h0Lno7XG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG4vKipcbiAqIENvbXB1dGVzIHRoZSBjb21wb25lbnR3aXNlIHN1bSBvZiB0d28gQ2FydGVzaWFucy5cbiAqXG4gKiBAcGFyYW0ge0NhcnRlc2lhbjN9IGxlZnQgVGhlIGZpcnN0IENhcnRlc2lhbi5cbiAqIEBwYXJhbSB7Q2FydGVzaWFuM30gcmlnaHQgVGhlIHNlY29uZCBDYXJ0ZXNpYW4uXG4gKiBAcGFyYW0ge0NhcnRlc2lhbjN9IHJlc3VsdCBUaGUgb2JqZWN0IG9udG8gd2hpY2ggdG8gc3RvcmUgdGhlIHJlc3VsdC5cbiAqIEByZXR1cm5zIHtDYXJ0ZXNpYW4zfSBUaGUgbW9kaWZpZWQgcmVzdWx0IHBhcmFtZXRlci5cbiAqL1xuQ2FydGVzaWFuMy5hZGQgPSBmdW5jdGlvbiAobGVmdCwgcmlnaHQsIHJlc3VsdCkge1xuICAvLz4+aW5jbHVkZVN0YXJ0KCdkZWJ1ZycsIHByYWdtYXMuZGVidWcpO1xuICBDaGVjay50eXBlT2Yub2JqZWN0KFwibGVmdFwiLCBsZWZ0KTtcbiAgQ2hlY2sudHlwZU9mLm9iamVjdChcInJpZ2h0XCIsIHJpZ2h0KTtcbiAgQ2hlY2sudHlwZU9mLm9iamVjdChcInJlc3VsdFwiLCByZXN1bHQpO1xuICAvLz4+aW5jbHVkZUVuZCgnZGVidWcnKTtcblxuICByZXN1bHQueCA9IGxlZnQueCArIHJpZ2h0Lng7XG4gIHJlc3VsdC55ID0gbGVmdC55ICsgcmlnaHQueTtcbiAgcmVzdWx0LnogPSBsZWZ0LnogKyByaWdodC56O1xuICByZXR1cm4gcmVzdWx0O1xufTtcblxuLyoqXG4gKiBDb21wdXRlcyB0aGUgY29tcG9uZW50d2lzZSBkaWZmZXJlbmNlIG9mIHR3byBDYXJ0ZXNpYW5zLlxuICpcbiAqIEBwYXJhbSB7Q2FydGVzaWFuM30gbGVmdCBUaGUgZmlyc3QgQ2FydGVzaWFuLlxuICogQHBhcmFtIHtDYXJ0ZXNpYW4zfSByaWdodCBUaGUgc2Vjb25kIENhcnRlc2lhbi5cbiAqIEBwYXJhbSB7Q2FydGVzaWFuM30gcmVzdWx0IFRoZSBvYmplY3Qgb250byB3aGljaCB0byBzdG9yZSB0aGUgcmVzdWx0LlxuICogQHJldHVybnMge0NhcnRlc2lhbjN9IFRoZSBtb2RpZmllZCByZXN1bHQgcGFyYW1ldGVyLlxuICovXG5DYXJ0ZXNpYW4zLnN1YnRyYWN0ID0gZnVuY3Rpb24gKGxlZnQsIHJpZ2h0LCByZXN1bHQpIHtcbiAgLy8+PmluY2x1ZGVTdGFydCgnZGVidWcnLCBwcmFnbWFzLmRlYnVnKTtcbiAgQ2hlY2sudHlwZU9mLm9iamVjdChcImxlZnRcIiwgbGVmdCk7XG4gIENoZWNrLnR5cGVPZi5vYmplY3QoXCJyaWdodFwiLCByaWdodCk7XG4gIENoZWNrLnR5cGVPZi5vYmplY3QoXCJyZXN1bHRcIiwgcmVzdWx0KTtcbiAgLy8+PmluY2x1ZGVFbmQoJ2RlYnVnJyk7XG5cbiAgcmVzdWx0LnggPSBsZWZ0LnggLSByaWdodC54O1xuICByZXN1bHQueSA9IGxlZnQueSAtIHJpZ2h0Lnk7XG4gIHJlc3VsdC56ID0gbGVmdC56IC0gcmlnaHQuejtcbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbi8qKlxuICogTXVsdGlwbGllcyB0aGUgcHJvdmlkZWQgQ2FydGVzaWFuIGNvbXBvbmVudHdpc2UgYnkgdGhlIHByb3ZpZGVkIHNjYWxhci5cbiAqXG4gKiBAcGFyYW0ge0NhcnRlc2lhbjN9IGNhcnRlc2lhbiBUaGUgQ2FydGVzaWFuIHRvIGJlIHNjYWxlZC5cbiAqIEBwYXJhbSB7TnVtYmVyfSBzY2FsYXIgVGhlIHNjYWxhciB0byBtdWx0aXBseSB3aXRoLlxuICogQHBhcmFtIHtDYXJ0ZXNpYW4zfSByZXN1bHQgVGhlIG9iamVjdCBvbnRvIHdoaWNoIHRvIHN0b3JlIHRoZSByZXN1bHQuXG4gKiBAcmV0dXJucyB7Q2FydGVzaWFuM30gVGhlIG1vZGlmaWVkIHJlc3VsdCBwYXJhbWV0ZXIuXG4gKi9cbkNhcnRlc2lhbjMubXVsdGlwbHlCeVNjYWxhciA9IGZ1bmN0aW9uIChjYXJ0ZXNpYW4sIHNjYWxhciwgcmVzdWx0KSB7XG4gIC8vPj5pbmNsdWRlU3RhcnQoJ2RlYnVnJywgcHJhZ21hcy5kZWJ1Zyk7XG4gIENoZWNrLnR5cGVPZi5vYmplY3QoXCJjYXJ0ZXNpYW5cIiwgY2FydGVzaWFuKTtcbiAgQ2hlY2sudHlwZU9mLm51bWJlcihcInNjYWxhclwiLCBzY2FsYXIpO1xuICBDaGVjay50eXBlT2Yub2JqZWN0KFwicmVzdWx0XCIsIHJlc3VsdCk7XG4gIC8vPj5pbmNsdWRlRW5kKCdkZWJ1ZycpO1xuXG4gIHJlc3VsdC54ID0gY2FydGVzaWFuLnggKiBzY2FsYXI7XG4gIHJlc3VsdC55ID0gY2FydGVzaWFuLnkgKiBzY2FsYXI7XG4gIHJlc3VsdC56ID0gY2FydGVzaWFuLnogKiBzY2FsYXI7XG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG4vKipcbiAqIERpdmlkZXMgdGhlIHByb3ZpZGVkIENhcnRlc2lhbiBjb21wb25lbnR3aXNlIGJ5IHRoZSBwcm92aWRlZCBzY2FsYXIuXG4gKlxuICogQHBhcmFtIHtDYXJ0ZXNpYW4zfSBjYXJ0ZXNpYW4gVGhlIENhcnRlc2lhbiB0byBiZSBkaXZpZGVkLlxuICogQHBhcmFtIHtOdW1iZXJ9IHNjYWxhciBUaGUgc2NhbGFyIHRvIGRpdmlkZSBieS5cbiAqIEBwYXJhbSB7Q2FydGVzaWFuM30gcmVzdWx0IFRoZSBvYmplY3Qgb250byB3aGljaCB0byBzdG9yZSB0aGUgcmVzdWx0LlxuICogQHJldHVybnMge0NhcnRlc2lhbjN9IFRoZSBtb2RpZmllZCByZXN1bHQgcGFyYW1ldGVyLlxuICovXG5DYXJ0ZXNpYW4zLmRpdmlkZUJ5U2NhbGFyID0gZnVuY3Rpb24gKGNhcnRlc2lhbiwgc2NhbGFyLCByZXN1bHQpIHtcbiAgLy8+PmluY2x1ZGVTdGFydCgnZGVidWcnLCBwcmFnbWFzLmRlYnVnKTtcbiAgQ2hlY2sudHlwZU9mLm9iamVjdChcImNhcnRlc2lhblwiLCBjYXJ0ZXNpYW4pO1xuICBDaGVjay50eXBlT2YubnVtYmVyKFwic2NhbGFyXCIsIHNjYWxhcik7XG4gIENoZWNrLnR5cGVPZi5vYmplY3QoXCJyZXN1bHRcIiwgcmVzdWx0KTtcbiAgLy8+PmluY2x1ZGVFbmQoJ2RlYnVnJyk7XG5cbiAgcmVzdWx0LnggPSBjYXJ0ZXNpYW4ueCAvIHNjYWxhcjtcbiAgcmVzdWx0LnkgPSBjYXJ0ZXNpYW4ueSAvIHNjYWxhcjtcbiAgcmVzdWx0LnogPSBjYXJ0ZXNpYW4ueiAvIHNjYWxhcjtcbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbi8qKlxuICogTmVnYXRlcyB0aGUgcHJvdmlkZWQgQ2FydGVzaWFuLlxuICpcbiAqIEBwYXJhbSB7Q2FydGVzaWFuM30gY2FydGVzaWFuIFRoZSBDYXJ0ZXNpYW4gdG8gYmUgbmVnYXRlZC5cbiAqIEBwYXJhbSB7Q2FydGVzaWFuM30gcmVzdWx0IFRoZSBvYmplY3Qgb250byB3aGljaCB0byBzdG9yZSB0aGUgcmVzdWx0LlxuICogQHJldHVybnMge0NhcnRlc2lhbjN9IFRoZSBtb2RpZmllZCByZXN1bHQgcGFyYW1ldGVyLlxuICovXG5DYXJ0ZXNpYW4zLm5lZ2F0ZSA9IGZ1bmN0aW9uIChjYXJ0ZXNpYW4sIHJlc3VsdCkge1xuICAvLz4+aW5jbHVkZVN0YXJ0KCdkZWJ1ZycsIHByYWdtYXMuZGVidWcpO1xuICBDaGVjay50eXBlT2Yub2JqZWN0KFwiY2FydGVzaWFuXCIsIGNhcnRlc2lhbik7XG4gIENoZWNrLnR5cGVPZi5vYmplY3QoXCJyZXN1bHRcIiwgcmVzdWx0KTtcbiAgLy8+PmluY2x1ZGVFbmQoJ2RlYnVnJyk7XG5cbiAgcmVzdWx0LnggPSAtY2FydGVzaWFuLng7XG4gIHJlc3VsdC55ID0gLWNhcnRlc2lhbi55O1xuICByZXN1bHQueiA9IC1jYXJ0ZXNpYW4uejtcbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbi8qKlxuICogQ29tcHV0ZXMgdGhlIGFic29sdXRlIHZhbHVlIG9mIHRoZSBwcm92aWRlZCBDYXJ0ZXNpYW4uXG4gKlxuICogQHBhcmFtIHtDYXJ0ZXNpYW4zfSBjYXJ0ZXNpYW4gVGhlIENhcnRlc2lhbiB3aG9zZSBhYnNvbHV0ZSB2YWx1ZSBpcyB0byBiZSBjb21wdXRlZC5cbiAqIEBwYXJhbSB7Q2FydGVzaWFuM30gcmVzdWx0IFRoZSBvYmplY3Qgb250byB3aGljaCB0byBzdG9yZSB0aGUgcmVzdWx0LlxuICogQHJldHVybnMge0NhcnRlc2lhbjN9IFRoZSBtb2RpZmllZCByZXN1bHQgcGFyYW1ldGVyLlxuICovXG5DYXJ0ZXNpYW4zLmFicyA9IGZ1bmN0aW9uIChjYXJ0ZXNpYW4sIHJlc3VsdCkge1xuICAvLz4+aW5jbHVkZVN0YXJ0KCdkZWJ1ZycsIHByYWdtYXMuZGVidWcpO1xuICBDaGVjay50eXBlT2Yub2JqZWN0KFwiY2FydGVzaWFuXCIsIGNhcnRlc2lhbik7XG4gIENoZWNrLnR5cGVPZi5vYmplY3QoXCJyZXN1bHRcIiwgcmVzdWx0KTtcbiAgLy8+PmluY2x1ZGVFbmQoJ2RlYnVnJyk7XG5cbiAgcmVzdWx0LnggPSBNYXRoLmFicyhjYXJ0ZXNpYW4ueCk7XG4gIHJlc3VsdC55ID0gTWF0aC5hYnMoY2FydGVzaWFuLnkpO1xuICByZXN1bHQueiA9IE1hdGguYWJzKGNhcnRlc2lhbi56KTtcbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbnZhciBsZXJwU2NyYXRjaCA9IG5ldyBDYXJ0ZXNpYW4zKCk7XG4vKipcbiAqIENvbXB1dGVzIHRoZSBsaW5lYXIgaW50ZXJwb2xhdGlvbiBvciBleHRyYXBvbGF0aW9uIGF0IHQgdXNpbmcgdGhlIHByb3ZpZGVkIGNhcnRlc2lhbnMuXG4gKlxuICogQHBhcmFtIHtDYXJ0ZXNpYW4zfSBzdGFydCBUaGUgdmFsdWUgY29ycmVzcG9uZGluZyB0byB0IGF0IDAuMC5cbiAqIEBwYXJhbSB7Q2FydGVzaWFuM30gZW5kIFRoZSB2YWx1ZSBjb3JyZXNwb25kaW5nIHRvIHQgYXQgMS4wLlxuICogQHBhcmFtIHtOdW1iZXJ9IHQgVGhlIHBvaW50IGFsb25nIHQgYXQgd2hpY2ggdG8gaW50ZXJwb2xhdGUuXG4gKiBAcGFyYW0ge0NhcnRlc2lhbjN9IHJlc3VsdCBUaGUgb2JqZWN0IG9udG8gd2hpY2ggdG8gc3RvcmUgdGhlIHJlc3VsdC5cbiAqIEByZXR1cm5zIHtDYXJ0ZXNpYW4zfSBUaGUgbW9kaWZpZWQgcmVzdWx0IHBhcmFtZXRlci5cbiAqL1xuQ2FydGVzaWFuMy5sZXJwID0gZnVuY3Rpb24gKHN0YXJ0LCBlbmQsIHQsIHJlc3VsdCkge1xuICAvLz4+aW5jbHVkZVN0YXJ0KCdkZWJ1ZycsIHByYWdtYXMuZGVidWcpO1xuICBDaGVjay50eXBlT2Yub2JqZWN0KFwic3RhcnRcIiwgc3RhcnQpO1xuICBDaGVjay50eXBlT2Yub2JqZWN0KFwiZW5kXCIsIGVuZCk7XG4gIENoZWNrLnR5cGVPZi5udW1iZXIoXCJ0XCIsIHQpO1xuICBDaGVjay50eXBlT2Yub2JqZWN0KFwicmVzdWx0XCIsIHJlc3VsdCk7XG4gIC8vPj5pbmNsdWRlRW5kKCdkZWJ1ZycpO1xuXG4gIENhcnRlc2lhbjMubXVsdGlwbHlCeVNjYWxhcihlbmQsIHQsIGxlcnBTY3JhdGNoKTtcbiAgcmVzdWx0ID0gQ2FydGVzaWFuMy5tdWx0aXBseUJ5U2NhbGFyKHN0YXJ0LCAxLjAgLSB0LCByZXN1bHQpO1xuICByZXR1cm4gQ2FydGVzaWFuMy5hZGQobGVycFNjcmF0Y2gsIHJlc3VsdCwgcmVzdWx0KTtcbn07XG5cbnZhciBhbmdsZUJldHdlZW5TY3JhdGNoID0gbmV3IENhcnRlc2lhbjMoKTtcbnZhciBhbmdsZUJldHdlZW5TY3JhdGNoMiA9IG5ldyBDYXJ0ZXNpYW4zKCk7XG4vKipcbiAqIFJldHVybnMgdGhlIGFuZ2xlLCBpbiByYWRpYW5zLCBiZXR3ZWVuIHRoZSBwcm92aWRlZCBDYXJ0ZXNpYW5zLlxuICpcbiAqIEBwYXJhbSB7Q2FydGVzaWFuM30gbGVmdCBUaGUgZmlyc3QgQ2FydGVzaWFuLlxuICogQHBhcmFtIHtDYXJ0ZXNpYW4zfSByaWdodCBUaGUgc2Vjb25kIENhcnRlc2lhbi5cbiAqIEByZXR1cm5zIHtOdW1iZXJ9IFRoZSBhbmdsZSBiZXR3ZWVuIHRoZSBDYXJ0ZXNpYW5zLlxuICovXG5DYXJ0ZXNpYW4zLmFuZ2xlQmV0d2VlbiA9IGZ1bmN0aW9uIChsZWZ0LCByaWdodCkge1xuICAvLz4+aW5jbHVkZVN0YXJ0KCdkZWJ1ZycsIHByYWdtYXMuZGVidWcpO1xuICBDaGVjay50eXBlT2Yub2JqZWN0KFwibGVmdFwiLCBsZWZ0KTtcbiAgQ2hlY2sudHlwZU9mLm9iamVjdChcInJpZ2h0XCIsIHJpZ2h0KTtcbiAgLy8+PmluY2x1ZGVFbmQoJ2RlYnVnJyk7XG5cbiAgQ2FydGVzaWFuMy5ub3JtYWxpemUobGVmdCwgYW5nbGVCZXR3ZWVuU2NyYXRjaCk7XG4gIENhcnRlc2lhbjMubm9ybWFsaXplKHJpZ2h0LCBhbmdsZUJldHdlZW5TY3JhdGNoMik7XG4gIHZhciBjb3NpbmUgPSBDYXJ0ZXNpYW4zLmRvdChhbmdsZUJldHdlZW5TY3JhdGNoLCBhbmdsZUJldHdlZW5TY3JhdGNoMik7XG4gIHZhciBzaW5lID0gQ2FydGVzaWFuMy5tYWduaXR1ZGUoXG4gICAgQ2FydGVzaWFuMy5jcm9zcyhcbiAgICAgIGFuZ2xlQmV0d2VlblNjcmF0Y2gsXG4gICAgICBhbmdsZUJldHdlZW5TY3JhdGNoMixcbiAgICAgIGFuZ2xlQmV0d2VlblNjcmF0Y2hcbiAgICApXG4gICk7XG4gIHJldHVybiBNYXRoLmF0YW4yKHNpbmUsIGNvc2luZSk7XG59O1xuXG52YXIgbW9zdE9ydGhvZ29uYWxBeGlzU2NyYXRjaCA9IG5ldyBDYXJ0ZXNpYW4zKCk7XG4vKipcbiAqIFJldHVybnMgdGhlIGF4aXMgdGhhdCBpcyBtb3N0IG9ydGhvZ29uYWwgdG8gdGhlIHByb3ZpZGVkIENhcnRlc2lhbi5cbiAqXG4gKiBAcGFyYW0ge0NhcnRlc2lhbjN9IGNhcnRlc2lhbiBUaGUgQ2FydGVzaWFuIG9uIHdoaWNoIHRvIGZpbmQgdGhlIG1vc3Qgb3J0aG9nb25hbCBheGlzLlxuICogQHBhcmFtIHtDYXJ0ZXNpYW4zfSByZXN1bHQgVGhlIG9iamVjdCBvbnRvIHdoaWNoIHRvIHN0b3JlIHRoZSByZXN1bHQuXG4gKiBAcmV0dXJucyB7Q2FydGVzaWFuM30gVGhlIG1vc3Qgb3J0aG9nb25hbCBheGlzLlxuICovXG5DYXJ0ZXNpYW4zLm1vc3RPcnRob2dvbmFsQXhpcyA9IGZ1bmN0aW9uIChjYXJ0ZXNpYW4sIHJlc3VsdCkge1xuICAvLz4+aW5jbHVkZVN0YXJ0KCdkZWJ1ZycsIHByYWdtYXMuZGVidWcpO1xuICBDaGVjay50eXBlT2Yub2JqZWN0KFwiY2FydGVzaWFuXCIsIGNhcnRlc2lhbik7XG4gIENoZWNrLnR5cGVPZi5vYmplY3QoXCJyZXN1bHRcIiwgcmVzdWx0KTtcbiAgLy8+PmluY2x1ZGVFbmQoJ2RlYnVnJyk7XG5cbiAgdmFyIGYgPSBDYXJ0ZXNpYW4zLm5vcm1hbGl6ZShjYXJ0ZXNpYW4sIG1vc3RPcnRob2dvbmFsQXhpc1NjcmF0Y2gpO1xuICBDYXJ0ZXNpYW4zLmFicyhmLCBmKTtcblxuICBpZiAoZi54IDw9IGYueSkge1xuICAgIGlmIChmLnggPD0gZi56KSB7XG4gICAgICByZXN1bHQgPSBDYXJ0ZXNpYW4zLmNsb25lKENhcnRlc2lhbjMuVU5JVF9YLCByZXN1bHQpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXN1bHQgPSBDYXJ0ZXNpYW4zLmNsb25lKENhcnRlc2lhbjMuVU5JVF9aLCByZXN1bHQpO1xuICAgIH1cbiAgfSBlbHNlIGlmIChmLnkgPD0gZi56KSB7XG4gICAgcmVzdWx0ID0gQ2FydGVzaWFuMy5jbG9uZShDYXJ0ZXNpYW4zLlVOSVRfWSwgcmVzdWx0KTtcbiAgfSBlbHNlIHtcbiAgICByZXN1bHQgPSBDYXJ0ZXNpYW4zLmNsb25lKENhcnRlc2lhbjMuVU5JVF9aLCByZXN1bHQpO1xuICB9XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbi8qKlxuICogUHJvamVjdHMgdmVjdG9yIGEgb250byB2ZWN0b3IgYlxuICogQHBhcmFtIHtDYXJ0ZXNpYW4zfSBhIFRoZSB2ZWN0b3IgdGhhdCBuZWVkcyBwcm9qZWN0aW5nXG4gKiBAcGFyYW0ge0NhcnRlc2lhbjN9IGIgVGhlIHZlY3RvciB0byBwcm9qZWN0IG9udG9cbiAqIEBwYXJhbSB7Q2FydGVzaWFuM30gcmVzdWx0IFRoZSByZXN1bHQgY2FydGVzaWFuXG4gKiBAcmV0dXJucyB7Q2FydGVzaWFuM30gVGhlIG1vZGlmaWVkIHJlc3VsdCBwYXJhbWV0ZXJcbiAqL1xuQ2FydGVzaWFuMy5wcm9qZWN0VmVjdG9yID0gZnVuY3Rpb24gKGEsIGIsIHJlc3VsdCkge1xuICAvLz4+aW5jbHVkZVN0YXJ0KCdkZWJ1ZycsIHByYWdtYXMuZGVidWcpO1xuICBDaGVjay5kZWZpbmVkKFwiYVwiLCBhKTtcbiAgQ2hlY2suZGVmaW5lZChcImJcIiwgYik7XG4gIENoZWNrLmRlZmluZWQoXCJyZXN1bHRcIiwgcmVzdWx0KTtcbiAgLy8+PmluY2x1ZGVFbmQoJ2RlYnVnJyk7XG5cbiAgdmFyIHNjYWxhciA9IENhcnRlc2lhbjMuZG90KGEsIGIpIC8gQ2FydGVzaWFuMy5kb3QoYiwgYik7XG4gIHJldHVybiBDYXJ0ZXNpYW4zLm11bHRpcGx5QnlTY2FsYXIoYiwgc2NhbGFyLCByZXN1bHQpO1xufTtcblxuLyoqXG4gKiBDb21wYXJlcyB0aGUgcHJvdmlkZWQgQ2FydGVzaWFucyBjb21wb25lbnR3aXNlIGFuZCByZXR1cm5zXG4gKiA8Y29kZT50cnVlPC9jb2RlPiBpZiB0aGV5IGFyZSBlcXVhbCwgPGNvZGU+ZmFsc2U8L2NvZGU+IG90aGVyd2lzZS5cbiAqXG4gKiBAcGFyYW0ge0NhcnRlc2lhbjN9IFtsZWZ0XSBUaGUgZmlyc3QgQ2FydGVzaWFuLlxuICogQHBhcmFtIHtDYXJ0ZXNpYW4zfSBbcmlnaHRdIFRoZSBzZWNvbmQgQ2FydGVzaWFuLlxuICogQHJldHVybnMge0Jvb2xlYW59IDxjb2RlPnRydWU8L2NvZGU+IGlmIGxlZnQgYW5kIHJpZ2h0IGFyZSBlcXVhbCwgPGNvZGU+ZmFsc2U8L2NvZGU+IG90aGVyd2lzZS5cbiAqL1xuQ2FydGVzaWFuMy5lcXVhbHMgPSBmdW5jdGlvbiAobGVmdCwgcmlnaHQpIHtcbiAgcmV0dXJuIChcbiAgICBsZWZ0ID09PSByaWdodCB8fFxuICAgIChkZWZpbmVkKGxlZnQpICYmXG4gICAgICBkZWZpbmVkKHJpZ2h0KSAmJlxuICAgICAgbGVmdC54ID09PSByaWdodC54ICYmXG4gICAgICBsZWZ0LnkgPT09IHJpZ2h0LnkgJiZcbiAgICAgIGxlZnQueiA9PT0gcmlnaHQueilcbiAgKTtcbn07XG5cbi8qKlxuICogQHByaXZhdGVcbiAqL1xuQ2FydGVzaWFuMy5lcXVhbHNBcnJheSA9IGZ1bmN0aW9uIChjYXJ0ZXNpYW4sIGFycmF5LCBvZmZzZXQpIHtcbiAgcmV0dXJuIChcbiAgICBjYXJ0ZXNpYW4ueCA9PT0gYXJyYXlbb2Zmc2V0XSAmJlxuICAgIGNhcnRlc2lhbi55ID09PSBhcnJheVtvZmZzZXQgKyAxXSAmJlxuICAgIGNhcnRlc2lhbi56ID09PSBhcnJheVtvZmZzZXQgKyAyXVxuICApO1xufTtcblxuLyoqXG4gKiBDb21wYXJlcyB0aGUgcHJvdmlkZWQgQ2FydGVzaWFucyBjb21wb25lbnR3aXNlIGFuZCByZXR1cm5zXG4gKiA8Y29kZT50cnVlPC9jb2RlPiBpZiB0aGV5IHBhc3MgYW4gYWJzb2x1dGUgb3IgcmVsYXRpdmUgdG9sZXJhbmNlIHRlc3QsXG4gKiA8Y29kZT5mYWxzZTwvY29kZT4gb3RoZXJ3aXNlLlxuICpcbiAqIEBwYXJhbSB7Q2FydGVzaWFuM30gW2xlZnRdIFRoZSBmaXJzdCBDYXJ0ZXNpYW4uXG4gKiBAcGFyYW0ge0NhcnRlc2lhbjN9IFtyaWdodF0gVGhlIHNlY29uZCBDYXJ0ZXNpYW4uXG4gKiBAcGFyYW0ge051bWJlcn0gW3JlbGF0aXZlRXBzaWxvbj0wXSBUaGUgcmVsYXRpdmUgZXBzaWxvbiB0b2xlcmFuY2UgdG8gdXNlIGZvciBlcXVhbGl0eSB0ZXN0aW5nLlxuICogQHBhcmFtIHtOdW1iZXJ9IFthYnNvbHV0ZUVwc2lsb249cmVsYXRpdmVFcHNpbG9uXSBUaGUgYWJzb2x1dGUgZXBzaWxvbiB0b2xlcmFuY2UgdG8gdXNlIGZvciBlcXVhbGl0eSB0ZXN0aW5nLlxuICogQHJldHVybnMge0Jvb2xlYW59IDxjb2RlPnRydWU8L2NvZGU+IGlmIGxlZnQgYW5kIHJpZ2h0IGFyZSB3aXRoaW4gdGhlIHByb3ZpZGVkIGVwc2lsb24sIDxjb2RlPmZhbHNlPC9jb2RlPiBvdGhlcndpc2UuXG4gKi9cbkNhcnRlc2lhbjMuZXF1YWxzRXBzaWxvbiA9IGZ1bmN0aW9uIChcbiAgbGVmdCxcbiAgcmlnaHQsXG4gIHJlbGF0aXZlRXBzaWxvbixcbiAgYWJzb2x1dGVFcHNpbG9uXG4pIHtcbiAgcmV0dXJuIChcbiAgICBsZWZ0ID09PSByaWdodCB8fFxuICAgIChkZWZpbmVkKGxlZnQpICYmXG4gICAgICBkZWZpbmVkKHJpZ2h0KSAmJlxuICAgICAgQ2VzaXVtTWF0aC5lcXVhbHNFcHNpbG9uKFxuICAgICAgICBsZWZ0LngsXG4gICAgICAgIHJpZ2h0LngsXG4gICAgICAgIHJlbGF0aXZlRXBzaWxvbixcbiAgICAgICAgYWJzb2x1dGVFcHNpbG9uXG4gICAgICApICYmXG4gICAgICBDZXNpdW1NYXRoLmVxdWFsc0Vwc2lsb24oXG4gICAgICAgIGxlZnQueSxcbiAgICAgICAgcmlnaHQueSxcbiAgICAgICAgcmVsYXRpdmVFcHNpbG9uLFxuICAgICAgICBhYnNvbHV0ZUVwc2lsb25cbiAgICAgICkgJiZcbiAgICAgIENlc2l1bU1hdGguZXF1YWxzRXBzaWxvbihcbiAgICAgICAgbGVmdC56LFxuICAgICAgICByaWdodC56LFxuICAgICAgICByZWxhdGl2ZUVwc2lsb24sXG4gICAgICAgIGFic29sdXRlRXBzaWxvblxuICAgICAgKSlcbiAgKTtcbn07XG5cbi8qKlxuICogQ29tcHV0ZXMgdGhlIGNyb3NzIChvdXRlcikgcHJvZHVjdCBvZiB0d28gQ2FydGVzaWFucy5cbiAqXG4gKiBAcGFyYW0ge0NhcnRlc2lhbjN9IGxlZnQgVGhlIGZpcnN0IENhcnRlc2lhbi5cbiAqIEBwYXJhbSB7Q2FydGVzaWFuM30gcmlnaHQgVGhlIHNlY29uZCBDYXJ0ZXNpYW4uXG4gKiBAcGFyYW0ge0NhcnRlc2lhbjN9IHJlc3VsdCBUaGUgb2JqZWN0IG9udG8gd2hpY2ggdG8gc3RvcmUgdGhlIHJlc3VsdC5cbiAqIEByZXR1cm5zIHtDYXJ0ZXNpYW4zfSBUaGUgY3Jvc3MgcHJvZHVjdC5cbiAqL1xuQ2FydGVzaWFuMy5jcm9zcyA9IGZ1bmN0aW9uIChsZWZ0LCByaWdodCwgcmVzdWx0KSB7XG4gIC8vPj5pbmNsdWRlU3RhcnQoJ2RlYnVnJywgcHJhZ21hcy5kZWJ1Zyk7XG4gIENoZWNrLnR5cGVPZi5vYmplY3QoXCJsZWZ0XCIsIGxlZnQpO1xuICBDaGVjay50eXBlT2Yub2JqZWN0KFwicmlnaHRcIiwgcmlnaHQpO1xuICBDaGVjay50eXBlT2Yub2JqZWN0KFwicmVzdWx0XCIsIHJlc3VsdCk7XG4gIC8vPj5pbmNsdWRlRW5kKCdkZWJ1ZycpO1xuXG4gIHZhciBsZWZ0WCA9IGxlZnQueDtcbiAgdmFyIGxlZnRZID0gbGVmdC55O1xuICB2YXIgbGVmdFogPSBsZWZ0Lno7XG4gIHZhciByaWdodFggPSByaWdodC54O1xuICB2YXIgcmlnaHRZID0gcmlnaHQueTtcbiAgdmFyIHJpZ2h0WiA9IHJpZ2h0Lno7XG5cbiAgdmFyIHggPSBsZWZ0WSAqIHJpZ2h0WiAtIGxlZnRaICogcmlnaHRZO1xuICB2YXIgeSA9IGxlZnRaICogcmlnaHRYIC0gbGVmdFggKiByaWdodFo7XG4gIHZhciB6ID0gbGVmdFggKiByaWdodFkgLSBsZWZ0WSAqIHJpZ2h0WDtcblxuICByZXN1bHQueCA9IHg7XG4gIHJlc3VsdC55ID0geTtcbiAgcmVzdWx0LnogPSB6O1xuICByZXR1cm4gcmVzdWx0O1xufTtcblxuLyoqXG4gKiBDb21wdXRlcyB0aGUgbWlkcG9pbnQgYmV0d2VlbiB0aGUgcmlnaHQgYW5kIGxlZnQgQ2FydGVzaWFuLlxuICogQHBhcmFtIHtDYXJ0ZXNpYW4zfSBsZWZ0IFRoZSBmaXJzdCBDYXJ0ZXNpYW4uXG4gKiBAcGFyYW0ge0NhcnRlc2lhbjN9IHJpZ2h0IFRoZSBzZWNvbmQgQ2FydGVzaWFuLlxuICogQHBhcmFtIHtDYXJ0ZXNpYW4zfSByZXN1bHQgVGhlIG9iamVjdCBvbnRvIHdoaWNoIHRvIHN0b3JlIHRoZSByZXN1bHQuXG4gKiBAcmV0dXJucyB7Q2FydGVzaWFuM30gVGhlIG1pZHBvaW50LlxuICovXG5DYXJ0ZXNpYW4zLm1pZHBvaW50ID0gZnVuY3Rpb24gKGxlZnQsIHJpZ2h0LCByZXN1bHQpIHtcbiAgLy8+PmluY2x1ZGVTdGFydCgnZGVidWcnLCBwcmFnbWFzLmRlYnVnKTtcbiAgQ2hlY2sudHlwZU9mLm9iamVjdChcImxlZnRcIiwgbGVmdCk7XG4gIENoZWNrLnR5cGVPZi5vYmplY3QoXCJyaWdodFwiLCByaWdodCk7XG4gIENoZWNrLnR5cGVPZi5vYmplY3QoXCJyZXN1bHRcIiwgcmVzdWx0KTtcbiAgLy8+PmluY2x1ZGVFbmQoJ2RlYnVnJyk7XG5cbiAgcmVzdWx0LnggPSAobGVmdC54ICsgcmlnaHQueCkgKiAwLjU7XG4gIHJlc3VsdC55ID0gKGxlZnQueSArIHJpZ2h0LnkpICogMC41O1xuICByZXN1bHQueiA9IChsZWZ0LnogKyByaWdodC56KSAqIDAuNTtcblxuICByZXR1cm4gcmVzdWx0O1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIGEgQ2FydGVzaWFuMyBwb3NpdGlvbiBmcm9tIGxvbmdpdHVkZSBhbmQgbGF0aXR1ZGUgdmFsdWVzIGdpdmVuIGluIGRlZ3JlZXMuXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IGxvbmdpdHVkZSBUaGUgbG9uZ2l0dWRlLCBpbiBkZWdyZWVzXG4gKiBAcGFyYW0ge051bWJlcn0gbGF0aXR1ZGUgVGhlIGxhdGl0dWRlLCBpbiBkZWdyZWVzXG4gKiBAcGFyYW0ge051bWJlcn0gW2hlaWdodD0wLjBdIFRoZSBoZWlnaHQsIGluIG1ldGVycywgYWJvdmUgdGhlIGVsbGlwc29pZC5cbiAqIEBwYXJhbSB7RWxsaXBzb2lkfSBbZWxsaXBzb2lkPUVsbGlwc29pZC5XR1M4NF0gVGhlIGVsbGlwc29pZCBvbiB3aGljaCB0aGUgcG9zaXRpb24gbGllcy5cbiAqIEBwYXJhbSB7Q2FydGVzaWFuM30gW3Jlc3VsdF0gVGhlIG9iamVjdCBvbnRvIHdoaWNoIHRvIHN0b3JlIHRoZSByZXN1bHQuXG4gKiBAcmV0dXJucyB7Q2FydGVzaWFuM30gVGhlIHBvc2l0aW9uXG4gKlxuICogQGV4YW1wbGVcbiAqIHZhciBwb3NpdGlvbiA9IENlc2l1bS5DYXJ0ZXNpYW4zLmZyb21EZWdyZWVzKC0xMTUuMCwgMzcuMCk7XG4gKi9cbkNhcnRlc2lhbjMuZnJvbURlZ3JlZXMgPSBmdW5jdGlvbiAoXG4gIGxvbmdpdHVkZSxcbiAgbGF0aXR1ZGUsXG4gIGhlaWdodCxcbiAgZWxsaXBzb2lkLFxuICByZXN1bHRcbikge1xuICAvLz4+aW5jbHVkZVN0YXJ0KCdkZWJ1ZycsIHByYWdtYXMuZGVidWcpO1xuICBDaGVjay50eXBlT2YubnVtYmVyKFwibG9uZ2l0dWRlXCIsIGxvbmdpdHVkZSk7XG4gIENoZWNrLnR5cGVPZi5udW1iZXIoXCJsYXRpdHVkZVwiLCBsYXRpdHVkZSk7XG4gIC8vPj5pbmNsdWRlRW5kKCdkZWJ1ZycpO1xuXG4gIGxvbmdpdHVkZSA9IENlc2l1bU1hdGgudG9SYWRpYW5zKGxvbmdpdHVkZSk7XG4gIGxhdGl0dWRlID0gQ2VzaXVtTWF0aC50b1JhZGlhbnMobGF0aXR1ZGUpO1xuICByZXR1cm4gQ2FydGVzaWFuMy5mcm9tUmFkaWFucyhsb25naXR1ZGUsIGxhdGl0dWRlLCBoZWlnaHQsIGVsbGlwc29pZCwgcmVzdWx0KTtcbn07XG5cbnZhciBzY3JhdGNoTiA9IG5ldyBDYXJ0ZXNpYW4zKCk7XG52YXIgc2NyYXRjaEsgPSBuZXcgQ2FydGVzaWFuMygpO1xudmFyIHdnczg0UmFkaWlTcXVhcmVkID0gbmV3IENhcnRlc2lhbjMoXG4gIDYzNzgxMzcuMCAqIDYzNzgxMzcuMCxcbiAgNjM3ODEzNy4wICogNjM3ODEzNy4wLFxuICA2MzU2NzUyLjMxNDI0NTE3OTMgKiA2MzU2NzUyLjMxNDI0NTE3OTNcbik7XG5cbi8qKlxuICogUmV0dXJucyBhIENhcnRlc2lhbjMgcG9zaXRpb24gZnJvbSBsb25naXR1ZGUgYW5kIGxhdGl0dWRlIHZhbHVlcyBnaXZlbiBpbiByYWRpYW5zLlxuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSBsb25naXR1ZGUgVGhlIGxvbmdpdHVkZSwgaW4gcmFkaWFuc1xuICogQHBhcmFtIHtOdW1iZXJ9IGxhdGl0dWRlIFRoZSBsYXRpdHVkZSwgaW4gcmFkaWFuc1xuICogQHBhcmFtIHtOdW1iZXJ9IFtoZWlnaHQ9MC4wXSBUaGUgaGVpZ2h0LCBpbiBtZXRlcnMsIGFib3ZlIHRoZSBlbGxpcHNvaWQuXG4gKiBAcGFyYW0ge0VsbGlwc29pZH0gW2VsbGlwc29pZD1FbGxpcHNvaWQuV0dTODRdIFRoZSBlbGxpcHNvaWQgb24gd2hpY2ggdGhlIHBvc2l0aW9uIGxpZXMuXG4gKiBAcGFyYW0ge0NhcnRlc2lhbjN9IFtyZXN1bHRdIFRoZSBvYmplY3Qgb250byB3aGljaCB0byBzdG9yZSB0aGUgcmVzdWx0LlxuICogQHJldHVybnMge0NhcnRlc2lhbjN9IFRoZSBwb3NpdGlvblxuICpcbiAqIEBleGFtcGxlXG4gKiB2YXIgcG9zaXRpb24gPSBDZXNpdW0uQ2FydGVzaWFuMy5mcm9tUmFkaWFucygtMi4wMDcsIDAuNjQ1KTtcbiAqL1xuQ2FydGVzaWFuMy5mcm9tUmFkaWFucyA9IGZ1bmN0aW9uIChcbiAgbG9uZ2l0dWRlLFxuICBsYXRpdHVkZSxcbiAgaGVpZ2h0LFxuICBlbGxpcHNvaWQsXG4gIHJlc3VsdFxuKSB7XG4gIC8vPj5pbmNsdWRlU3RhcnQoJ2RlYnVnJywgcHJhZ21hcy5kZWJ1Zyk7XG4gIENoZWNrLnR5cGVPZi5udW1iZXIoXCJsb25naXR1ZGVcIiwgbG9uZ2l0dWRlKTtcbiAgQ2hlY2sudHlwZU9mLm51bWJlcihcImxhdGl0dWRlXCIsIGxhdGl0dWRlKTtcbiAgLy8+PmluY2x1ZGVFbmQoJ2RlYnVnJyk7XG5cbiAgaGVpZ2h0ID0gZGVmYXVsdFZhbHVlKGhlaWdodCwgMC4wKTtcbiAgdmFyIHJhZGlpU3F1YXJlZCA9IGRlZmluZWQoZWxsaXBzb2lkKVxuICAgID8gZWxsaXBzb2lkLnJhZGlpU3F1YXJlZFxuICAgIDogd2dzODRSYWRpaVNxdWFyZWQ7XG5cbiAgdmFyIGNvc0xhdGl0dWRlID0gTWF0aC5jb3MobGF0aXR1ZGUpO1xuICBzY3JhdGNoTi54ID0gY29zTGF0aXR1ZGUgKiBNYXRoLmNvcyhsb25naXR1ZGUpO1xuICBzY3JhdGNoTi55ID0gY29zTGF0aXR1ZGUgKiBNYXRoLnNpbihsb25naXR1ZGUpO1xuICBzY3JhdGNoTi56ID0gTWF0aC5zaW4obGF0aXR1ZGUpO1xuICBzY3JhdGNoTiA9IENhcnRlc2lhbjMubm9ybWFsaXplKHNjcmF0Y2hOLCBzY3JhdGNoTik7XG5cbiAgQ2FydGVzaWFuMy5tdWx0aXBseUNvbXBvbmVudHMocmFkaWlTcXVhcmVkLCBzY3JhdGNoTiwgc2NyYXRjaEspO1xuICB2YXIgZ2FtbWEgPSBNYXRoLnNxcnQoQ2FydGVzaWFuMy5kb3Qoc2NyYXRjaE4sIHNjcmF0Y2hLKSk7XG4gIHNjcmF0Y2hLID0gQ2FydGVzaWFuMy5kaXZpZGVCeVNjYWxhcihzY3JhdGNoSywgZ2FtbWEsIHNjcmF0Y2hLKTtcbiAgc2NyYXRjaE4gPSBDYXJ0ZXNpYW4zLm11bHRpcGx5QnlTY2FsYXIoc2NyYXRjaE4sIGhlaWdodCwgc2NyYXRjaE4pO1xuXG4gIGlmICghZGVmaW5lZChyZXN1bHQpKSB7XG4gICAgcmVzdWx0ID0gbmV3IENhcnRlc2lhbjMoKTtcbiAgfVxuICByZXR1cm4gQ2FydGVzaWFuMy5hZGQoc2NyYXRjaEssIHNjcmF0Y2hOLCByZXN1bHQpO1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIGFuIGFycmF5IG9mIENhcnRlc2lhbjMgcG9zaXRpb25zIGdpdmVuIGFuIGFycmF5IG9mIGxvbmdpdHVkZSBhbmQgbGF0aXR1ZGUgdmFsdWVzIGdpdmVuIGluIGRlZ3JlZXMuXG4gKlxuICogQHBhcmFtIHtOdW1iZXJbXX0gY29vcmRpbmF0ZXMgQSBsaXN0IG9mIGxvbmdpdHVkZSBhbmQgbGF0aXR1ZGUgdmFsdWVzLiBWYWx1ZXMgYWx0ZXJuYXRlIFtsb25naXR1ZGUsIGxhdGl0dWRlLCBsb25naXR1ZGUsIGxhdGl0dWRlLi4uXS5cbiAqIEBwYXJhbSB7RWxsaXBzb2lkfSBbZWxsaXBzb2lkPUVsbGlwc29pZC5XR1M4NF0gVGhlIGVsbGlwc29pZCBvbiB3aGljaCB0aGUgY29vcmRpbmF0ZXMgbGllLlxuICogQHBhcmFtIHtDYXJ0ZXNpYW4zW119IFtyZXN1bHRdIEFuIGFycmF5IG9mIENhcnRlc2lhbjMgb2JqZWN0cyB0byBzdG9yZSB0aGUgcmVzdWx0LlxuICogQHJldHVybnMge0NhcnRlc2lhbjNbXX0gVGhlIGFycmF5IG9mIHBvc2l0aW9ucy5cbiAqXG4gKiBAZXhhbXBsZVxuICogdmFyIHBvc2l0aW9ucyA9IENlc2l1bS5DYXJ0ZXNpYW4zLmZyb21EZWdyZWVzQXJyYXkoWy0xMTUuMCwgMzcuMCwgLTEwNy4wLCAzMy4wXSk7XG4gKi9cbkNhcnRlc2lhbjMuZnJvbURlZ3JlZXNBcnJheSA9IGZ1bmN0aW9uIChjb29yZGluYXRlcywgZWxsaXBzb2lkLCByZXN1bHQpIHtcbiAgLy8+PmluY2x1ZGVTdGFydCgnZGVidWcnLCBwcmFnbWFzLmRlYnVnKTtcbiAgQ2hlY2suZGVmaW5lZChcImNvb3JkaW5hdGVzXCIsIGNvb3JkaW5hdGVzKTtcbiAgaWYgKGNvb3JkaW5hdGVzLmxlbmd0aCA8IDIgfHwgY29vcmRpbmF0ZXMubGVuZ3RoICUgMiAhPT0gMCkge1xuICAgIHRocm93IG5ldyBEZXZlbG9wZXJFcnJvcihcbiAgICAgIFwidGhlIG51bWJlciBvZiBjb29yZGluYXRlcyBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgMiBhbmQgYXQgbGVhc3QgMlwiXG4gICAgKTtcbiAgfVxuICAvLz4+aW5jbHVkZUVuZCgnZGVidWcnKTtcblxuICB2YXIgbGVuZ3RoID0gY29vcmRpbmF0ZXMubGVuZ3RoO1xuICBpZiAoIWRlZmluZWQocmVzdWx0KSkge1xuICAgIHJlc3VsdCA9IG5ldyBBcnJheShsZW5ndGggLyAyKTtcbiAgfSBlbHNlIHtcbiAgICByZXN1bHQubGVuZ3RoID0gbGVuZ3RoIC8gMjtcbiAgfVxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpICs9IDIpIHtcbiAgICB2YXIgbG9uZ2l0dWRlID0gY29vcmRpbmF0ZXNbaV07XG4gICAgdmFyIGxhdGl0dWRlID0gY29vcmRpbmF0ZXNbaSArIDFdO1xuICAgIHZhciBpbmRleCA9IGkgLyAyO1xuICAgIHJlc3VsdFtpbmRleF0gPSBDYXJ0ZXNpYW4zLmZyb21EZWdyZWVzKFxuICAgICAgbG9uZ2l0dWRlLFxuICAgICAgbGF0aXR1ZGUsXG4gICAgICAwLFxuICAgICAgZWxsaXBzb2lkLFxuICAgICAgcmVzdWx0W2luZGV4XVxuICAgICk7XG4gIH1cblxuICByZXR1cm4gcmVzdWx0O1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIGFuIGFycmF5IG9mIENhcnRlc2lhbjMgcG9zaXRpb25zIGdpdmVuIGFuIGFycmF5IG9mIGxvbmdpdHVkZSBhbmQgbGF0aXR1ZGUgdmFsdWVzIGdpdmVuIGluIHJhZGlhbnMuXG4gKlxuICogQHBhcmFtIHtOdW1iZXJbXX0gY29vcmRpbmF0ZXMgQSBsaXN0IG9mIGxvbmdpdHVkZSBhbmQgbGF0aXR1ZGUgdmFsdWVzLiBWYWx1ZXMgYWx0ZXJuYXRlIFtsb25naXR1ZGUsIGxhdGl0dWRlLCBsb25naXR1ZGUsIGxhdGl0dWRlLi4uXS5cbiAqIEBwYXJhbSB7RWxsaXBzb2lkfSBbZWxsaXBzb2lkPUVsbGlwc29pZC5XR1M4NF0gVGhlIGVsbGlwc29pZCBvbiB3aGljaCB0aGUgY29vcmRpbmF0ZXMgbGllLlxuICogQHBhcmFtIHtDYXJ0ZXNpYW4zW119IFtyZXN1bHRdIEFuIGFycmF5IG9mIENhcnRlc2lhbjMgb2JqZWN0cyB0byBzdG9yZSB0aGUgcmVzdWx0LlxuICogQHJldHVybnMge0NhcnRlc2lhbjNbXX0gVGhlIGFycmF5IG9mIHBvc2l0aW9ucy5cbiAqXG4gKiBAZXhhbXBsZVxuICogdmFyIHBvc2l0aW9ucyA9IENlc2l1bS5DYXJ0ZXNpYW4zLmZyb21SYWRpYW5zQXJyYXkoWy0yLjAwNywgMC42NDUsIC0xLjg2NywgLjU3NV0pO1xuICovXG5DYXJ0ZXNpYW4zLmZyb21SYWRpYW5zQXJyYXkgPSBmdW5jdGlvbiAoY29vcmRpbmF0ZXMsIGVsbGlwc29pZCwgcmVzdWx0KSB7XG4gIC8vPj5pbmNsdWRlU3RhcnQoJ2RlYnVnJywgcHJhZ21hcy5kZWJ1Zyk7XG4gIENoZWNrLmRlZmluZWQoXCJjb29yZGluYXRlc1wiLCBjb29yZGluYXRlcyk7XG4gIGlmIChjb29yZGluYXRlcy5sZW5ndGggPCAyIHx8IGNvb3JkaW5hdGVzLmxlbmd0aCAlIDIgIT09IDApIHtcbiAgICB0aHJvdyBuZXcgRGV2ZWxvcGVyRXJyb3IoXG4gICAgICBcInRoZSBudW1iZXIgb2YgY29vcmRpbmF0ZXMgbXVzdCBiZSBhIG11bHRpcGxlIG9mIDIgYW5kIGF0IGxlYXN0IDJcIlxuICAgICk7XG4gIH1cbiAgLy8+PmluY2x1ZGVFbmQoJ2RlYnVnJyk7XG5cbiAgdmFyIGxlbmd0aCA9IGNvb3JkaW5hdGVzLmxlbmd0aDtcbiAgaWYgKCFkZWZpbmVkKHJlc3VsdCkpIHtcbiAgICByZXN1bHQgPSBuZXcgQXJyYXkobGVuZ3RoIC8gMik7XG4gIH0gZWxzZSB7XG4gICAgcmVzdWx0Lmxlbmd0aCA9IGxlbmd0aCAvIDI7XG4gIH1cblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSArPSAyKSB7XG4gICAgdmFyIGxvbmdpdHVkZSA9IGNvb3JkaW5hdGVzW2ldO1xuICAgIHZhciBsYXRpdHVkZSA9IGNvb3JkaW5hdGVzW2kgKyAxXTtcbiAgICB2YXIgaW5kZXggPSBpIC8gMjtcbiAgICByZXN1bHRbaW5kZXhdID0gQ2FydGVzaWFuMy5mcm9tUmFkaWFucyhcbiAgICAgIGxvbmdpdHVkZSxcbiAgICAgIGxhdGl0dWRlLFxuICAgICAgMCxcbiAgICAgIGVsbGlwc29pZCxcbiAgICAgIHJlc3VsdFtpbmRleF1cbiAgICApO1xuICB9XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbi8qKlxuICogUmV0dXJucyBhbiBhcnJheSBvZiBDYXJ0ZXNpYW4zIHBvc2l0aW9ucyBnaXZlbiBhbiBhcnJheSBvZiBsb25naXR1ZGUsIGxhdGl0dWRlIGFuZCBoZWlnaHQgdmFsdWVzIHdoZXJlIGxvbmdpdHVkZSBhbmQgbGF0aXR1ZGUgYXJlIGdpdmVuIGluIGRlZ3JlZXMuXG4gKlxuICogQHBhcmFtIHtOdW1iZXJbXX0gY29vcmRpbmF0ZXMgQSBsaXN0IG9mIGxvbmdpdHVkZSwgbGF0aXR1ZGUgYW5kIGhlaWdodCB2YWx1ZXMuIFZhbHVlcyBhbHRlcm5hdGUgW2xvbmdpdHVkZSwgbGF0aXR1ZGUsIGhlaWdodCwgbG9uZ2l0dWRlLCBsYXRpdHVkZSwgaGVpZ2h0Li4uXS5cbiAqIEBwYXJhbSB7RWxsaXBzb2lkfSBbZWxsaXBzb2lkPUVsbGlwc29pZC5XR1M4NF0gVGhlIGVsbGlwc29pZCBvbiB3aGljaCB0aGUgcG9zaXRpb24gbGllcy5cbiAqIEBwYXJhbSB7Q2FydGVzaWFuM1tdfSBbcmVzdWx0XSBBbiBhcnJheSBvZiBDYXJ0ZXNpYW4zIG9iamVjdHMgdG8gc3RvcmUgdGhlIHJlc3VsdC5cbiAqIEByZXR1cm5zIHtDYXJ0ZXNpYW4zW119IFRoZSBhcnJheSBvZiBwb3NpdGlvbnMuXG4gKlxuICogQGV4YW1wbGVcbiAqIHZhciBwb3NpdGlvbnMgPSBDZXNpdW0uQ2FydGVzaWFuMy5mcm9tRGVncmVlc0FycmF5SGVpZ2h0cyhbLTExNS4wLCAzNy4wLCAxMDAwMDAuMCwgLTEwNy4wLCAzMy4wLCAxNTAwMDAuMF0pO1xuICovXG5DYXJ0ZXNpYW4zLmZyb21EZWdyZWVzQXJyYXlIZWlnaHRzID0gZnVuY3Rpb24gKGNvb3JkaW5hdGVzLCBlbGxpcHNvaWQsIHJlc3VsdCkge1xuICAvLz4+aW5jbHVkZVN0YXJ0KCdkZWJ1ZycsIHByYWdtYXMuZGVidWcpO1xuICBDaGVjay5kZWZpbmVkKFwiY29vcmRpbmF0ZXNcIiwgY29vcmRpbmF0ZXMpO1xuICBpZiAoY29vcmRpbmF0ZXMubGVuZ3RoIDwgMyB8fCBjb29yZGluYXRlcy5sZW5ndGggJSAzICE9PSAwKSB7XG4gICAgdGhyb3cgbmV3IERldmVsb3BlckVycm9yKFxuICAgICAgXCJ0aGUgbnVtYmVyIG9mIGNvb3JkaW5hdGVzIG11c3QgYmUgYSBtdWx0aXBsZSBvZiAzIGFuZCBhdCBsZWFzdCAzXCJcbiAgICApO1xuICB9XG4gIC8vPj5pbmNsdWRlRW5kKCdkZWJ1ZycpO1xuXG4gIHZhciBsZW5ndGggPSBjb29yZGluYXRlcy5sZW5ndGg7XG4gIGlmICghZGVmaW5lZChyZXN1bHQpKSB7XG4gICAgcmVzdWx0ID0gbmV3IEFycmF5KGxlbmd0aCAvIDMpO1xuICB9IGVsc2Uge1xuICAgIHJlc3VsdC5sZW5ndGggPSBsZW5ndGggLyAzO1xuICB9XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkgKz0gMykge1xuICAgIHZhciBsb25naXR1ZGUgPSBjb29yZGluYXRlc1tpXTtcbiAgICB2YXIgbGF0aXR1ZGUgPSBjb29yZGluYXRlc1tpICsgMV07XG4gICAgdmFyIGhlaWdodCA9IGNvb3JkaW5hdGVzW2kgKyAyXTtcbiAgICB2YXIgaW5kZXggPSBpIC8gMztcbiAgICByZXN1bHRbaW5kZXhdID0gQ2FydGVzaWFuMy5mcm9tRGVncmVlcyhcbiAgICAgIGxvbmdpdHVkZSxcbiAgICAgIGxhdGl0dWRlLFxuICAgICAgaGVpZ2h0LFxuICAgICAgZWxsaXBzb2lkLFxuICAgICAgcmVzdWx0W2luZGV4XVxuICAgICk7XG4gIH1cblxuICByZXR1cm4gcmVzdWx0O1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIGFuIGFycmF5IG9mIENhcnRlc2lhbjMgcG9zaXRpb25zIGdpdmVuIGFuIGFycmF5IG9mIGxvbmdpdHVkZSwgbGF0aXR1ZGUgYW5kIGhlaWdodCB2YWx1ZXMgd2hlcmUgbG9uZ2l0dWRlIGFuZCBsYXRpdHVkZSBhcmUgZ2l2ZW4gaW4gcmFkaWFucy5cbiAqXG4gKiBAcGFyYW0ge051bWJlcltdfSBjb29yZGluYXRlcyBBIGxpc3Qgb2YgbG9uZ2l0dWRlLCBsYXRpdHVkZSBhbmQgaGVpZ2h0IHZhbHVlcy4gVmFsdWVzIGFsdGVybmF0ZSBbbG9uZ2l0dWRlLCBsYXRpdHVkZSwgaGVpZ2h0LCBsb25naXR1ZGUsIGxhdGl0dWRlLCBoZWlnaHQuLi5dLlxuICogQHBhcmFtIHtFbGxpcHNvaWR9IFtlbGxpcHNvaWQ9RWxsaXBzb2lkLldHUzg0XSBUaGUgZWxsaXBzb2lkIG9uIHdoaWNoIHRoZSBwb3NpdGlvbiBsaWVzLlxuICogQHBhcmFtIHtDYXJ0ZXNpYW4zW119IFtyZXN1bHRdIEFuIGFycmF5IG9mIENhcnRlc2lhbjMgb2JqZWN0cyB0byBzdG9yZSB0aGUgcmVzdWx0LlxuICogQHJldHVybnMge0NhcnRlc2lhbjNbXX0gVGhlIGFycmF5IG9mIHBvc2l0aW9ucy5cbiAqXG4gKiBAZXhhbXBsZVxuICogdmFyIHBvc2l0aW9ucyA9IENlc2l1bS5DYXJ0ZXNpYW4zLmZyb21SYWRpYW5zQXJyYXlIZWlnaHRzKFstMi4wMDcsIDAuNjQ1LCAxMDAwMDAuMCwgLTEuODY3LCAuNTc1LCAxNTAwMDAuMF0pO1xuICovXG5DYXJ0ZXNpYW4zLmZyb21SYWRpYW5zQXJyYXlIZWlnaHRzID0gZnVuY3Rpb24gKGNvb3JkaW5hdGVzLCBlbGxpcHNvaWQsIHJlc3VsdCkge1xuICAvLz4+aW5jbHVkZVN0YXJ0KCdkZWJ1ZycsIHByYWdtYXMuZGVidWcpO1xuICBDaGVjay5kZWZpbmVkKFwiY29vcmRpbmF0ZXNcIiwgY29vcmRpbmF0ZXMpO1xuICBpZiAoY29vcmRpbmF0ZXMubGVuZ3RoIDwgMyB8fCBjb29yZGluYXRlcy5sZW5ndGggJSAzICE9PSAwKSB7XG4gICAgdGhyb3cgbmV3IERldmVsb3BlckVycm9yKFxuICAgICAgXCJ0aGUgbnVtYmVyIG9mIGNvb3JkaW5hdGVzIG11c3QgYmUgYSBtdWx0aXBsZSBvZiAzIGFuZCBhdCBsZWFzdCAzXCJcbiAgICApO1xuICB9XG4gIC8vPj5pbmNsdWRlRW5kKCdkZWJ1ZycpO1xuXG4gIHZhciBsZW5ndGggPSBjb29yZGluYXRlcy5sZW5ndGg7XG4gIGlmICghZGVmaW5lZChyZXN1bHQpKSB7XG4gICAgcmVzdWx0ID0gbmV3IEFycmF5KGxlbmd0aCAvIDMpO1xuICB9IGVsc2Uge1xuICAgIHJlc3VsdC5sZW5ndGggPSBsZW5ndGggLyAzO1xuICB9XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkgKz0gMykge1xuICAgIHZhciBsb25naXR1ZGUgPSBjb29yZGluYXRlc1tpXTtcbiAgICB2YXIgbGF0aXR1ZGUgPSBjb29yZGluYXRlc1tpICsgMV07XG4gICAgdmFyIGhlaWdodCA9IGNvb3JkaW5hdGVzW2kgKyAyXTtcbiAgICB2YXIgaW5kZXggPSBpIC8gMztcbiAgICByZXN1bHRbaW5kZXhdID0gQ2FydGVzaWFuMy5mcm9tUmFkaWFucyhcbiAgICAgIGxvbmdpdHVkZSxcbiAgICAgIGxhdGl0dWRlLFxuICAgICAgaGVpZ2h0LFxuICAgICAgZWxsaXBzb2lkLFxuICAgICAgcmVzdWx0W2luZGV4XVxuICAgICk7XG4gIH1cblxuICByZXR1cm4gcmVzdWx0O1xufTtcblxuLyoqXG4gKiBBbiBpbW11dGFibGUgQ2FydGVzaWFuMyBpbnN0YW5jZSBpbml0aWFsaXplZCB0byAoMC4wLCAwLjAsIDAuMCkuXG4gKlxuICogQHR5cGUge0NhcnRlc2lhbjN9XG4gKiBAY29uc3RhbnRcbiAqL1xuQ2FydGVzaWFuMy5aRVJPID0gT2JqZWN0LmZyZWV6ZShuZXcgQ2FydGVzaWFuMygwLjAsIDAuMCwgMC4wKSk7XG5cbi8qKlxuICogQW4gaW1tdXRhYmxlIENhcnRlc2lhbjMgaW5zdGFuY2UgaW5pdGlhbGl6ZWQgdG8gKDEuMCwgMS4wLCAxLjApLlxuICpcbiAqIEB0eXBlIHtDYXJ0ZXNpYW4zfVxuICogQGNvbnN0YW50XG4gKi9cbkNhcnRlc2lhbjMuT05FID0gT2JqZWN0LmZyZWV6ZShuZXcgQ2FydGVzaWFuMygxLjAsIDEuMCwgMS4wKSk7XG5cbi8qKlxuICogQW4gaW1tdXRhYmxlIENhcnRlc2lhbjMgaW5zdGFuY2UgaW5pdGlhbGl6ZWQgdG8gKDEuMCwgMC4wLCAwLjApLlxuICpcbiAqIEB0eXBlIHtDYXJ0ZXNpYW4zfVxuICogQGNvbnN0YW50XG4gKi9cbkNhcnRlc2lhbjMuVU5JVF9YID0gT2JqZWN0LmZyZWV6ZShuZXcgQ2FydGVzaWFuMygxLjAsIDAuMCwgMC4wKSk7XG5cbi8qKlxuICogQW4gaW1tdXRhYmxlIENhcnRlc2lhbjMgaW5zdGFuY2UgaW5pdGlhbGl6ZWQgdG8gKDAuMCwgMS4wLCAwLjApLlxuICpcbiAqIEB0eXBlIHtDYXJ0ZXNpYW4zfVxuICogQGNvbnN0YW50XG4gKi9cbkNhcnRlc2lhbjMuVU5JVF9ZID0gT2JqZWN0LmZyZWV6ZShuZXcgQ2FydGVzaWFuMygwLjAsIDEuMCwgMC4wKSk7XG5cbi8qKlxuICogQW4gaW1tdXRhYmxlIENhcnRlc2lhbjMgaW5zdGFuY2UgaW5pdGlhbGl6ZWQgdG8gKDAuMCwgMC4wLCAxLjApLlxuICpcbiAqIEB0eXBlIHtDYXJ0ZXNpYW4zfVxuICogQGNvbnN0YW50XG4gKi9cbkNhcnRlc2lhbjMuVU5JVF9aID0gT2JqZWN0LmZyZWV6ZShuZXcgQ2FydGVzaWFuMygwLjAsIDAuMCwgMS4wKSk7XG5cbi8qKlxuICogRHVwbGljYXRlcyB0aGlzIENhcnRlc2lhbjMgaW5zdGFuY2UuXG4gKlxuICogQHBhcmFtIHtDYXJ0ZXNpYW4zfSBbcmVzdWx0XSBUaGUgb2JqZWN0IG9udG8gd2hpY2ggdG8gc3RvcmUgdGhlIHJlc3VsdC5cbiAqIEByZXR1cm5zIHtDYXJ0ZXNpYW4zfSBUaGUgbW9kaWZpZWQgcmVzdWx0IHBhcmFtZXRlciBvciBhIG5ldyBDYXJ0ZXNpYW4zIGluc3RhbmNlIGlmIG9uZSB3YXMgbm90IHByb3ZpZGVkLlxuICovXG5DYXJ0ZXNpYW4zLnByb3RvdHlwZS5jbG9uZSA9IGZ1bmN0aW9uIChyZXN1bHQpIHtcbiAgcmV0dXJuIENhcnRlc2lhbjMuY2xvbmUodGhpcywgcmVzdWx0KTtcbn07XG5cbi8qKlxuICogQ29tcGFyZXMgdGhpcyBDYXJ0ZXNpYW4gYWdhaW5zdCB0aGUgcHJvdmlkZWQgQ2FydGVzaWFuIGNvbXBvbmVudHdpc2UgYW5kIHJldHVybnNcbiAqIDxjb2RlPnRydWU8L2NvZGU+IGlmIHRoZXkgYXJlIGVxdWFsLCA8Y29kZT5mYWxzZTwvY29kZT4gb3RoZXJ3aXNlLlxuICpcbiAqIEBwYXJhbSB7Q2FydGVzaWFuM30gW3JpZ2h0XSBUaGUgcmlnaHQgaGFuZCBzaWRlIENhcnRlc2lhbi5cbiAqIEByZXR1cm5zIHtCb29sZWFufSA8Y29kZT50cnVlPC9jb2RlPiBpZiB0aGV5IGFyZSBlcXVhbCwgPGNvZGU+ZmFsc2U8L2NvZGU+IG90aGVyd2lzZS5cbiAqL1xuQ2FydGVzaWFuMy5wcm90b3R5cGUuZXF1YWxzID0gZnVuY3Rpb24gKHJpZ2h0KSB7XG4gIHJldHVybiBDYXJ0ZXNpYW4zLmVxdWFscyh0aGlzLCByaWdodCk7XG59O1xuXG4vKipcbiAqIENvbXBhcmVzIHRoaXMgQ2FydGVzaWFuIGFnYWluc3QgdGhlIHByb3ZpZGVkIENhcnRlc2lhbiBjb21wb25lbnR3aXNlIGFuZCByZXR1cm5zXG4gKiA8Y29kZT50cnVlPC9jb2RlPiBpZiB0aGV5IHBhc3MgYW4gYWJzb2x1dGUgb3IgcmVsYXRpdmUgdG9sZXJhbmNlIHRlc3QsXG4gKiA8Y29kZT5mYWxzZTwvY29kZT4gb3RoZXJ3aXNlLlxuICpcbiAqIEBwYXJhbSB7Q2FydGVzaWFuM30gW3JpZ2h0XSBUaGUgcmlnaHQgaGFuZCBzaWRlIENhcnRlc2lhbi5cbiAqIEBwYXJhbSB7TnVtYmVyfSBbcmVsYXRpdmVFcHNpbG9uPTBdIFRoZSByZWxhdGl2ZSBlcHNpbG9uIHRvbGVyYW5jZSB0byB1c2UgZm9yIGVxdWFsaXR5IHRlc3RpbmcuXG4gKiBAcGFyYW0ge051bWJlcn0gW2Fic29sdXRlRXBzaWxvbj1yZWxhdGl2ZUVwc2lsb25dIFRoZSBhYnNvbHV0ZSBlcHNpbG9uIHRvbGVyYW5jZSB0byB1c2UgZm9yIGVxdWFsaXR5IHRlc3RpbmcuXG4gKiBAcmV0dXJucyB7Qm9vbGVhbn0gPGNvZGU+dHJ1ZTwvY29kZT4gaWYgdGhleSBhcmUgd2l0aGluIHRoZSBwcm92aWRlZCBlcHNpbG9uLCA8Y29kZT5mYWxzZTwvY29kZT4gb3RoZXJ3aXNlLlxuICovXG5DYXJ0ZXNpYW4zLnByb3RvdHlwZS5lcXVhbHNFcHNpbG9uID0gZnVuY3Rpb24gKFxuICByaWdodCxcbiAgcmVsYXRpdmVFcHNpbG9uLFxuICBhYnNvbHV0ZUVwc2lsb25cbikge1xuICByZXR1cm4gQ2FydGVzaWFuMy5lcXVhbHNFcHNpbG9uKFxuICAgIHRoaXMsXG4gICAgcmlnaHQsXG4gICAgcmVsYXRpdmVFcHNpbG9uLFxuICAgIGFic29sdXRlRXBzaWxvblxuICApO1xufTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgc3RyaW5nIHJlcHJlc2VudGluZyB0aGlzIENhcnRlc2lhbiBpbiB0aGUgZm9ybWF0ICcoeCwgeSwgeiknLlxuICpcbiAqIEByZXR1cm5zIHtTdHJpbmd9IEEgc3RyaW5nIHJlcHJlc2VudGluZyB0aGlzIENhcnRlc2lhbiBpbiB0aGUgZm9ybWF0ICcoeCwgeSwgeiknLlxuICovXG5DYXJ0ZXNpYW4zLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIFwiKFwiICsgdGhpcy54ICsgXCIsIFwiICsgdGhpcy55ICsgXCIsIFwiICsgdGhpcy56ICsgXCIpXCI7XG59O1xuZXhwb3J0IGRlZmF1bHQgQ2FydGVzaWFuMztcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///60216\n')},63367:function(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__){eval('/* harmony import */ var _Check_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(66553);\n/* harmony import */ var _defaultValue_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(62200);\n/* harmony import */ var _defined_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(82982);\n/* harmony import */ var _DeveloperError_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(12572);\n/* harmony import */ var _Math_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(99417);\n\n\n\n\n\n\n/**\n * A 4D Cartesian point.\n * @alias Cartesian4\n * @constructor\n *\n * @param {Number} [x=0.0] The X component.\n * @param {Number} [y=0.0] The Y component.\n * @param {Number} [z=0.0] The Z component.\n * @param {Number} [w=0.0] The W component.\n *\n * @see Cartesian2\n * @see Cartesian3\n * @see Packable\n */\nfunction Cartesian4(x, y, z, w) {\n  /**\n   * The X component.\n   * @type {Number}\n   * @default 0.0\n   */\n  this.x = (0,_defaultValue_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .Z)(x, 0.0);\n\n  /**\n   * The Y component.\n   * @type {Number}\n   * @default 0.0\n   */\n  this.y = (0,_defaultValue_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .Z)(y, 0.0);\n\n  /**\n   * The Z component.\n   * @type {Number}\n   * @default 0.0\n   */\n  this.z = (0,_defaultValue_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .Z)(z, 0.0);\n\n  /**\n   * The W component.\n   * @type {Number}\n   * @default 0.0\n   */\n  this.w = (0,_defaultValue_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .Z)(w, 0.0);\n}\n\n/**\n * Creates a Cartesian4 instance from x, y, z and w coordinates.\n *\n * @param {Number} x The x coordinate.\n * @param {Number} y The y coordinate.\n * @param {Number} z The z coordinate.\n * @param {Number} w The w coordinate.\n * @param {Cartesian4} [result] The object onto which to store the result.\n * @returns {Cartesian4} The modified result parameter or a new Cartesian4 instance if one was not provided.\n */\nCartesian4.fromElements = function (x, y, z, w, result) {\n  if (!(0,_defined_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .Z)(result)) {\n    return new Cartesian4(x, y, z, w);\n  }\n\n  result.x = x;\n  result.y = y;\n  result.z = z;\n  result.w = w;\n  return result;\n};\n\n/**\n * Creates a Cartesian4 instance from a {@link Color}. <code>red</code>, <code>green</code>, <code>blue</code>,\n * and <code>alpha</code> map to <code>x</code>, <code>y</code>, <code>z</code>, and <code>w</code>, respectively.\n *\n * @param {Color} color The source color.\n * @param {Cartesian4} [result] The object onto which to store the result.\n * @returns {Cartesian4} The modified result parameter or a new Cartesian4 instance if one was not provided.\n */\nCartesian4.fromColor = function (color, result) {\n  //>>includeStart(\'debug\', pragmas.debug);\n  _Check_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].typeOf.object */ .Z.typeOf.object("color", color);\n  //>>includeEnd(\'debug\');\n  if (!(0,_defined_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .Z)(result)) {\n    return new Cartesian4(color.red, color.green, color.blue, color.alpha);\n  }\n\n  result.x = color.red;\n  result.y = color.green;\n  result.z = color.blue;\n  result.w = color.alpha;\n  return result;\n};\n\n/**\n * Duplicates a Cartesian4 instance.\n *\n * @param {Cartesian4} cartesian The Cartesian to duplicate.\n * @param {Cartesian4} [result] The object onto which to store the result.\n * @returns {Cartesian4} The modified result parameter or a new Cartesian4 instance if one was not provided. (Returns undefined if cartesian is undefined)\n */\nCartesian4.clone = function (cartesian, result) {\n  if (!(0,_defined_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .Z)(cartesian)) {\n    return undefined;\n  }\n\n  if (!(0,_defined_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .Z)(result)) {\n    return new Cartesian4(cartesian.x, cartesian.y, cartesian.z, cartesian.w);\n  }\n\n  result.x = cartesian.x;\n  result.y = cartesian.y;\n  result.z = cartesian.z;\n  result.w = cartesian.w;\n  return result;\n};\n\n/**\n * The number of elements used to pack the object into an array.\n * @type {Number}\n */\nCartesian4.packedLength = 4;\n\n/**\n * Stores the provided instance into the provided array.\n *\n * @param {Cartesian4} value The value to pack.\n * @param {Number[]} array The array to pack into.\n * @param {Number} [startingIndex=0] The index into the array at which to start packing the elements.\n *\n * @returns {Number[]} The array that was packed into\n */\nCartesian4.pack = function (value, array, startingIndex) {\n  //>>includeStart(\'debug\', pragmas.debug);\n  _Check_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].typeOf.object */ .Z.typeOf.object("value", value);\n  _Check_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].defined */ .Z.defined("array", array);\n  //>>includeEnd(\'debug\');\n\n  startingIndex = (0,_defaultValue_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .Z)(startingIndex, 0);\n\n  array[startingIndex++] = value.x;\n  array[startingIndex++] = value.y;\n  array[startingIndex++] = value.z;\n  array[startingIndex] = value.w;\n\n  return array;\n};\n\n/**\n * Retrieves an instance from a packed array.\n *\n * @param {Number[]} array The packed array.\n * @param {Number} [startingIndex=0] The starting index of the element to be unpacked.\n * @param {Cartesian4} [result] The object into which to store the result.\n * @returns {Cartesian4}  The modified result parameter or a new Cartesian4 instance if one was not provided.\n */\nCartesian4.unpack = function (array, startingIndex, result) {\n  //>>includeStart(\'debug\', pragmas.debug);\n  _Check_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].defined */ .Z.defined("array", array);\n  //>>includeEnd(\'debug\');\n\n  startingIndex = (0,_defaultValue_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .Z)(startingIndex, 0);\n\n  if (!(0,_defined_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .Z)(result)) {\n    result = new Cartesian4();\n  }\n  result.x = array[startingIndex++];\n  result.y = array[startingIndex++];\n  result.z = array[startingIndex++];\n  result.w = array[startingIndex];\n  return result;\n};\n\n/**\n     * Flattens an array of Cartesian4s into and array of components.\n     *\n     * @param {Cartesian4[]} array The array of cartesians to pack.\n     * @param {Number[]} [result] The array onto which to store the result. If this is a typed array, it must have array.length * 4 components, else a {@link DeveloperError} will be thrown. If it is a regular array, it will be resized to have (array.length * 4) elements.\n\n     * @returns {Number[]} The packed array.\n     */\nCartesian4.packArray = function (array, result) {\n  //>>includeStart(\'debug\', pragmas.debug);\n  _Check_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].defined */ .Z.defined("array", array);\n  //>>includeEnd(\'debug\');\n\n  var length = array.length;\n  var resultLength = length * 4;\n  if (!(0,_defined_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .Z)(result)) {\n    result = new Array(resultLength);\n  } else if (!Array.isArray(result) && result.length !== resultLength) {\n    throw new _DeveloperError_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"] */ .Z(\n      "If result is a typed array, it must have exactly array.length * 4 elements"\n    );\n  } else if (result.length !== resultLength) {\n    result.length = resultLength;\n  }\n\n  for (var i = 0; i < length; ++i) {\n    Cartesian4.pack(array[i], result, i * 4);\n  }\n  return result;\n};\n\n/**\n * Unpacks an array of cartesian components into and array of Cartesian4s.\n *\n * @param {Number[]} array The array of components to unpack.\n * @param {Cartesian4[]} [result] The array onto which to store the result.\n * @returns {Cartesian4[]} The unpacked array.\n */\nCartesian4.unpackArray = function (array, result) {\n  //>>includeStart(\'debug\', pragmas.debug);\n  _Check_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].defined */ .Z.defined("array", array);\n  _Check_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].typeOf.number.greaterThanOrEquals */ .Z.typeOf.number.greaterThanOrEquals("array.length", array.length, 4);\n  if (array.length % 4 !== 0) {\n    throw new _DeveloperError_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"] */ .Z("array length must be a multiple of 4.");\n  }\n  //>>includeEnd(\'debug\');\n\n  var length = array.length;\n  if (!(0,_defined_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .Z)(result)) {\n    result = new Array(length / 4);\n  } else {\n    result.length = length / 4;\n  }\n\n  for (var i = 0; i < length; i += 4) {\n    var index = i / 4;\n    result[index] = Cartesian4.unpack(array, i, result[index]);\n  }\n  return result;\n};\n\n/**\n * Creates a Cartesian4 from four consecutive elements in an array.\n * @function\n *\n * @param {Number[]} array The array whose four consecutive elements correspond to the x, y, z, and w components, respectively.\n * @param {Number} [startingIndex=0] The offset into the array of the first element, which corresponds to the x component.\n * @param {Cartesian4} [result] The object onto which to store the result.\n * @returns {Cartesian4}  The modified result parameter or a new Cartesian4 instance if one was not provided.\n *\n * @example\n * // Create a Cartesian4 with (1.0, 2.0, 3.0, 4.0)\n * var v = [1.0, 2.0, 3.0, 4.0];\n * var p = Cesium.Cartesian4.fromArray(v);\n *\n * // Create a Cartesian4 with (1.0, 2.0, 3.0, 4.0) using an offset into an array\n * var v2 = [0.0, 0.0, 1.0, 2.0, 3.0, 4.0];\n * var p2 = Cesium.Cartesian4.fromArray(v2, 2);\n */\nCartesian4.fromArray = Cartesian4.unpack;\n\n/**\n * Computes the value of the maximum component for the supplied Cartesian.\n *\n * @param {Cartesian4} cartesian The cartesian to use.\n * @returns {Number} The value of the maximum component.\n */\nCartesian4.maximumComponent = function (cartesian) {\n  //>>includeStart(\'debug\', pragmas.debug);\n  _Check_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].typeOf.object */ .Z.typeOf.object("cartesian", cartesian);\n  //>>includeEnd(\'debug\');\n\n  return Math.max(cartesian.x, cartesian.y, cartesian.z, cartesian.w);\n};\n\n/**\n * Computes the value of the minimum component for the supplied Cartesian.\n *\n * @param {Cartesian4} cartesian The cartesian to use.\n * @returns {Number} The value of the minimum component.\n */\nCartesian4.minimumComponent = function (cartesian) {\n  //>>includeStart(\'debug\', pragmas.debug);\n  _Check_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].typeOf.object */ .Z.typeOf.object("cartesian", cartesian);\n  //>>includeEnd(\'debug\');\n\n  return Math.min(cartesian.x, cartesian.y, cartesian.z, cartesian.w);\n};\n\n/**\n * Compares two Cartesians and computes a Cartesian which contains the minimum components of the supplied Cartesians.\n *\n * @param {Cartesian4} first A cartesian to compare.\n * @param {Cartesian4} second A cartesian to compare.\n * @param {Cartesian4} result The object into which to store the result.\n * @returns {Cartesian4} A cartesian with the minimum components.\n */\nCartesian4.minimumByComponent = function (first, second, result) {\n  //>>includeStart(\'debug\', pragmas.debug);\n  _Check_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].typeOf.object */ .Z.typeOf.object("first", first);\n  _Check_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].typeOf.object */ .Z.typeOf.object("second", second);\n  _Check_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].typeOf.object */ .Z.typeOf.object("result", result);\n  //>>includeEnd(\'debug\');\n\n  result.x = Math.min(first.x, second.x);\n  result.y = Math.min(first.y, second.y);\n  result.z = Math.min(first.z, second.z);\n  result.w = Math.min(first.w, second.w);\n\n  return result;\n};\n\n/**\n * Compares two Cartesians and computes a Cartesian which contains the maximum components of the supplied Cartesians.\n *\n * @param {Cartesian4} first A cartesian to compare.\n * @param {Cartesian4} second A cartesian to compare.\n * @param {Cartesian4} result The object into which to store the result.\n * @returns {Cartesian4} A cartesian with the maximum components.\n */\nCartesian4.maximumByComponent = function (first, second, result) {\n  //>>includeStart(\'debug\', pragmas.debug);\n  _Check_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].typeOf.object */ .Z.typeOf.object("first", first);\n  _Check_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].typeOf.object */ .Z.typeOf.object("second", second);\n  _Check_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].typeOf.object */ .Z.typeOf.object("result", result);\n  //>>includeEnd(\'debug\');\n\n  result.x = Math.max(first.x, second.x);\n  result.y = Math.max(first.y, second.y);\n  result.z = Math.max(first.z, second.z);\n  result.w = Math.max(first.w, second.w);\n\n  return result;\n};\n\n/**\n * Computes the provided Cartesian\'s squared magnitude.\n *\n * @param {Cartesian4} cartesian The Cartesian instance whose squared magnitude is to be computed.\n * @returns {Number} The squared magnitude.\n */\nCartesian4.magnitudeSquared = function (cartesian) {\n  //>>includeStart(\'debug\', pragmas.debug);\n  _Check_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].typeOf.object */ .Z.typeOf.object("cartesian", cartesian);\n  //>>includeEnd(\'debug\');\n\n  return (\n    cartesian.x * cartesian.x +\n    cartesian.y * cartesian.y +\n    cartesian.z * cartesian.z +\n    cartesian.w * cartesian.w\n  );\n};\n\n/**\n * Computes the Cartesian\'s magnitude (length).\n *\n * @param {Cartesian4} cartesian The Cartesian instance whose magnitude is to be computed.\n * @returns {Number} The magnitude.\n */\nCartesian4.magnitude = function (cartesian) {\n  return Math.sqrt(Cartesian4.magnitudeSquared(cartesian));\n};\n\nvar distanceScratch = new Cartesian4();\n\n/**\n * Computes the 4-space distance between two points.\n *\n * @param {Cartesian4} left The first point to compute the distance from.\n * @param {Cartesian4} right The second point to compute the distance to.\n * @returns {Number} The distance between two points.\n *\n * @example\n * // Returns 1.0\n * var d = Cesium.Cartesian4.distance(\n *   new Cesium.Cartesian4(1.0, 0.0, 0.0, 0.0),\n *   new Cesium.Cartesian4(2.0, 0.0, 0.0, 0.0));\n */\nCartesian4.distance = function (left, right) {\n  //>>includeStart(\'debug\', pragmas.debug);\n  _Check_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].typeOf.object */ .Z.typeOf.object("left", left);\n  _Check_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].typeOf.object */ .Z.typeOf.object("right", right);\n  //>>includeEnd(\'debug\');\n\n  Cartesian4.subtract(left, right, distanceScratch);\n  return Cartesian4.magnitude(distanceScratch);\n};\n\n/**\n * Computes the squared distance between two points.  Comparing squared distances\n * using this function is more efficient than comparing distances using {@link Cartesian4#distance}.\n *\n * @param {Cartesian4} left The first point to compute the distance from.\n * @param {Cartesian4} right The second point to compute the distance to.\n * @returns {Number} The distance between two points.\n *\n * @example\n * // Returns 4.0, not 2.0\n * var d = Cesium.Cartesian4.distance(\n *   new Cesium.Cartesian4(1.0, 0.0, 0.0, 0.0),\n *   new Cesium.Cartesian4(3.0, 0.0, 0.0, 0.0));\n */\nCartesian4.distanceSquared = function (left, right) {\n  //>>includeStart(\'debug\', pragmas.debug);\n  _Check_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].typeOf.object */ .Z.typeOf.object("left", left);\n  _Check_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].typeOf.object */ .Z.typeOf.object("right", right);\n  //>>includeEnd(\'debug\');\n\n  Cartesian4.subtract(left, right, distanceScratch);\n  return Cartesian4.magnitudeSquared(distanceScratch);\n};\n\n/**\n * Computes the normalized form of the supplied Cartesian.\n *\n * @param {Cartesian4} cartesian The Cartesian to be normalized.\n * @param {Cartesian4} result The object onto which to store the result.\n * @returns {Cartesian4} The modified result parameter.\n */\nCartesian4.normalize = function (cartesian, result) {\n  //>>includeStart(\'debug\', pragmas.debug);\n  _Check_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].typeOf.object */ .Z.typeOf.object("cartesian", cartesian);\n  _Check_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].typeOf.object */ .Z.typeOf.object("result", result);\n  //>>includeEnd(\'debug\');\n\n  var magnitude = Cartesian4.magnitude(cartesian);\n\n  result.x = cartesian.x / magnitude;\n  result.y = cartesian.y / magnitude;\n  result.z = cartesian.z / magnitude;\n  result.w = cartesian.w / magnitude;\n\n  //>>includeStart(\'debug\', pragmas.debug);\n  if (\n    isNaN(result.x) ||\n    isNaN(result.y) ||\n    isNaN(result.z) ||\n    isNaN(result.w)\n  ) {\n    throw new _DeveloperError_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"] */ .Z("normalized result is not a number");\n  }\n  //>>includeEnd(\'debug\');\n\n  return result;\n};\n\n/**\n * Computes the dot (scalar) product of two Cartesians.\n *\n * @param {Cartesian4} left The first Cartesian.\n * @param {Cartesian4} right The second Cartesian.\n * @returns {Number} The dot product.\n */\nCartesian4.dot = function (left, right) {\n  //>>includeStart(\'debug\', pragmas.debug);\n  _Check_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].typeOf.object */ .Z.typeOf.object("left", left);\n  _Check_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].typeOf.object */ .Z.typeOf.object("right", right);\n  //>>includeEnd(\'debug\');\n\n  return (\n    left.x * right.x + left.y * right.y + left.z * right.z + left.w * right.w\n  );\n};\n\n/**\n * Computes the componentwise product of two Cartesians.\n *\n * @param {Cartesian4} left The first Cartesian.\n * @param {Cartesian4} right The second Cartesian.\n * @param {Cartesian4} result The object onto which to store the result.\n * @returns {Cartesian4} The modified result parameter.\n */\nCartesian4.multiplyComponents = function (left, right, result) {\n  //>>includeStart(\'debug\', pragmas.debug);\n  _Check_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].typeOf.object */ .Z.typeOf.object("left", left);\n  _Check_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].typeOf.object */ .Z.typeOf.object("right", right);\n  _Check_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].typeOf.object */ .Z.typeOf.object("result", result);\n  //>>includeEnd(\'debug\');\n\n  result.x = left.x * right.x;\n  result.y = left.y * right.y;\n  result.z = left.z * right.z;\n  result.w = left.w * right.w;\n  return result;\n};\n\n/**\n * Computes the componentwise quotient of two Cartesians.\n *\n * @param {Cartesian4} left The first Cartesian.\n * @param {Cartesian4} right The second Cartesian.\n * @param {Cartesian4} result The object onto which to store the result.\n * @returns {Cartesian4} The modified result parameter.\n */\nCartesian4.divideComponents = function (left, right, result) {\n  //>>includeStart(\'debug\', pragmas.debug);\n  _Check_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].typeOf.object */ .Z.typeOf.object("left", left);\n  _Check_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].typeOf.object */ .Z.typeOf.object("right", right);\n  _Check_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].typeOf.object */ .Z.typeOf.object("result", result);\n  //>>includeEnd(\'debug\');\n\n  result.x = left.x / right.x;\n  result.y = left.y / right.y;\n  result.z = left.z / right.z;\n  result.w = left.w / right.w;\n  return result;\n};\n\n/**\n * Computes the componentwise sum of two Cartesians.\n *\n * @param {Cartesian4} left The first Cartesian.\n * @param {Cartesian4} right The second Cartesian.\n * @param {Cartesian4} result The object onto which to store the result.\n * @returns {Cartesian4} The modified result parameter.\n */\nCartesian4.add = function (left, right, result) {\n  //>>includeStart(\'debug\', pragmas.debug);\n  _Check_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].typeOf.object */ .Z.typeOf.object("left", left);\n  _Check_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].typeOf.object */ .Z.typeOf.object("right", right);\n  _Check_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].typeOf.object */ .Z.typeOf.object("result", result);\n  //>>includeEnd(\'debug\');\n\n  result.x = left.x + right.x;\n  result.y = left.y + right.y;\n  result.z = left.z + right.z;\n  result.w = left.w + right.w;\n  return result;\n};\n\n/**\n * Computes the componentwise difference of two Cartesians.\n *\n * @param {Cartesian4} left The first Cartesian.\n * @param {Cartesian4} right The second Cartesian.\n * @param {Cartesian4} result The object onto which to store the result.\n * @returns {Cartesian4} The modified result parameter.\n */\nCartesian4.subtract = function (left, right, result) {\n  //>>includeStart(\'debug\', pragmas.debug);\n  _Check_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].typeOf.object */ .Z.typeOf.object("left", left);\n  _Check_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].typeOf.object */ .Z.typeOf.object("right", right);\n  _Check_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].typeOf.object */ .Z.typeOf.object("result", result);\n  //>>includeEnd(\'debug\');\n\n  result.x = left.x - right.x;\n  result.y = left.y - right.y;\n  result.z = left.z - right.z;\n  result.w = left.w - right.w;\n  return result;\n};\n\n/**\n * Multiplies the provided Cartesian componentwise by the provided scalar.\n *\n * @param {Cartesian4} cartesian The Cartesian to be scaled.\n * @param {Number} scalar The scalar to multiply with.\n * @param {Cartesian4} result The object onto which to store the result.\n * @returns {Cartesian4} The modified result parameter.\n */\nCartesian4.multiplyByScalar = function (cartesian, scalar, result) {\n  //>>includeStart(\'debug\', pragmas.debug);\n  _Check_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].typeOf.object */ .Z.typeOf.object("cartesian", cartesian);\n  _Check_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].typeOf.number */ .Z.typeOf.number("scalar", scalar);\n  _Check_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].typeOf.object */ .Z.typeOf.object("result", result);\n  //>>includeEnd(\'debug\');\n\n  result.x = cartesian.x * scalar;\n  result.y = cartesian.y * scalar;\n  result.z = cartesian.z * scalar;\n  result.w = cartesian.w * scalar;\n  return result;\n};\n\n/**\n * Divides the provided Cartesian componentwise by the provided scalar.\n *\n * @param {Cartesian4} cartesian The Cartesian to be divided.\n * @param {Number} scalar The scalar to divide by.\n * @param {Cartesian4} result The object onto which to store the result.\n * @returns {Cartesian4} The modified result parameter.\n */\nCartesian4.divideByScalar = function (cartesian, scalar, result) {\n  //>>includeStart(\'debug\', pragmas.debug);\n  _Check_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].typeOf.object */ .Z.typeOf.object("cartesian", cartesian);\n  _Check_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].typeOf.number */ .Z.typeOf.number("scalar", scalar);\n  _Check_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].typeOf.object */ .Z.typeOf.object("result", result);\n  //>>includeEnd(\'debug\');\n\n  result.x = cartesian.x / scalar;\n  result.y = cartesian.y / scalar;\n  result.z = cartesian.z / scalar;\n  result.w = cartesian.w / scalar;\n  return result;\n};\n\n/**\n * Negates the provided Cartesian.\n *\n * @param {Cartesian4} cartesian The Cartesian to be negated.\n * @param {Cartesian4} result The object onto which to store the result.\n * @returns {Cartesian4} The modified result parameter.\n */\nCartesian4.negate = function (cartesian, result) {\n  //>>includeStart(\'debug\', pragmas.debug);\n  _Check_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].typeOf.object */ .Z.typeOf.object("cartesian", cartesian);\n  _Check_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].typeOf.object */ .Z.typeOf.object("result", result);\n  //>>includeEnd(\'debug\');\n\n  result.x = -cartesian.x;\n  result.y = -cartesian.y;\n  result.z = -cartesian.z;\n  result.w = -cartesian.w;\n  return result;\n};\n\n/**\n * Computes the absolute value of the provided Cartesian.\n *\n * @param {Cartesian4} cartesian The Cartesian whose absolute value is to be computed.\n * @param {Cartesian4} result The object onto which to store the result.\n * @returns {Cartesian4} The modified result parameter.\n */\nCartesian4.abs = function (cartesian, result) {\n  //>>includeStart(\'debug\', pragmas.debug);\n  _Check_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].typeOf.object */ .Z.typeOf.object("cartesian", cartesian);\n  _Check_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].typeOf.object */ .Z.typeOf.object("result", result);\n  //>>includeEnd(\'debug\');\n\n  result.x = Math.abs(cartesian.x);\n  result.y = Math.abs(cartesian.y);\n  result.z = Math.abs(cartesian.z);\n  result.w = Math.abs(cartesian.w);\n  return result;\n};\n\nvar lerpScratch = new Cartesian4();\n/**\n * Computes the linear interpolation or extrapolation at t using the provided cartesians.\n *\n * @param {Cartesian4} start The value corresponding to t at 0.0.\n * @param {Cartesian4}end The value corresponding to t at 1.0.\n * @param {Number} t The point along t at which to interpolate.\n * @param {Cartesian4} result The object onto which to store the result.\n * @returns {Cartesian4} The modified result parameter.\n */\nCartesian4.lerp = function (start, end, t, result) {\n  //>>includeStart(\'debug\', pragmas.debug);\n  _Check_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].typeOf.object */ .Z.typeOf.object("start", start);\n  _Check_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].typeOf.object */ .Z.typeOf.object("end", end);\n  _Check_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].typeOf.number */ .Z.typeOf.number("t", t);\n  _Check_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].typeOf.object */ .Z.typeOf.object("result", result);\n  //>>includeEnd(\'debug\');\n\n  Cartesian4.multiplyByScalar(end, t, lerpScratch);\n  result = Cartesian4.multiplyByScalar(start, 1.0 - t, result);\n  return Cartesian4.add(lerpScratch, result, result);\n};\n\nvar mostOrthogonalAxisScratch = new Cartesian4();\n/**\n * Returns the axis that is most orthogonal to the provided Cartesian.\n *\n * @param {Cartesian4} cartesian The Cartesian on which to find the most orthogonal axis.\n * @param {Cartesian4} result The object onto which to store the result.\n * @returns {Cartesian4} The most orthogonal axis.\n */\nCartesian4.mostOrthogonalAxis = function (cartesian, result) {\n  //>>includeStart(\'debug\', pragmas.debug);\n  _Check_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].typeOf.object */ .Z.typeOf.object("cartesian", cartesian);\n  _Check_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].typeOf.object */ .Z.typeOf.object("result", result);\n  //>>includeEnd(\'debug\');\n\n  var f = Cartesian4.normalize(cartesian, mostOrthogonalAxisScratch);\n  Cartesian4.abs(f, f);\n\n  if (f.x <= f.y) {\n    if (f.x <= f.z) {\n      if (f.x <= f.w) {\n        result = Cartesian4.clone(Cartesian4.UNIT_X, result);\n      } else {\n        result = Cartesian4.clone(Cartesian4.UNIT_W, result);\n      }\n    } else if (f.z <= f.w) {\n      result = Cartesian4.clone(Cartesian4.UNIT_Z, result);\n    } else {\n      result = Cartesian4.clone(Cartesian4.UNIT_W, result);\n    }\n  } else if (f.y <= f.z) {\n    if (f.y <= f.w) {\n      result = Cartesian4.clone(Cartesian4.UNIT_Y, result);\n    } else {\n      result = Cartesian4.clone(Cartesian4.UNIT_W, result);\n    }\n  } else if (f.z <= f.w) {\n    result = Cartesian4.clone(Cartesian4.UNIT_Z, result);\n  } else {\n    result = Cartesian4.clone(Cartesian4.UNIT_W, result);\n  }\n\n  return result;\n};\n\n/**\n * Compares the provided Cartesians componentwise and returns\n * <code>true</code> if they are equal, <code>false</code> otherwise.\n *\n * @param {Cartesian4} [left] The first Cartesian.\n * @param {Cartesian4} [right] The second Cartesian.\n * @returns {Boolean} <code>true</code> if left and right are equal, <code>false</code> otherwise.\n */\nCartesian4.equals = function (left, right) {\n  return (\n    left === right ||\n    ((0,_defined_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .Z)(left) &&\n      (0,_defined_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .Z)(right) &&\n      left.x === right.x &&\n      left.y === right.y &&\n      left.z === right.z &&\n      left.w === right.w)\n  );\n};\n\n/**\n * @private\n */\nCartesian4.equalsArray = function (cartesian, array, offset) {\n  return (\n    cartesian.x === array[offset] &&\n    cartesian.y === array[offset + 1] &&\n    cartesian.z === array[offset + 2] &&\n    cartesian.w === array[offset + 3]\n  );\n};\n\n/**\n * Compares the provided Cartesians componentwise and returns\n * <code>true</code> if they pass an absolute or relative tolerance test,\n * <code>false</code> otherwise.\n *\n * @param {Cartesian4} [left] The first Cartesian.\n * @param {Cartesian4} [right] The second Cartesian.\n * @param {Number} [relativeEpsilon=0] The relative epsilon tolerance to use for equality testing.\n * @param {Number} [absoluteEpsilon=relativeEpsilon] The absolute epsilon tolerance to use for equality testing.\n * @returns {Boolean} <code>true</code> if left and right are within the provided epsilon, <code>false</code> otherwise.\n */\nCartesian4.equalsEpsilon = function (\n  left,\n  right,\n  relativeEpsilon,\n  absoluteEpsilon\n) {\n  return (\n    left === right ||\n    ((0,_defined_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .Z)(left) &&\n      (0,_defined_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .Z)(right) &&\n      _Math_js__WEBPACK_IMPORTED_MODULE_3__/* ["default"].equalsEpsilon */ .Z.equalsEpsilon(\n        left.x,\n        right.x,\n        relativeEpsilon,\n        absoluteEpsilon\n      ) &&\n      _Math_js__WEBPACK_IMPORTED_MODULE_3__/* ["default"].equalsEpsilon */ .Z.equalsEpsilon(\n        left.y,\n        right.y,\n        relativeEpsilon,\n        absoluteEpsilon\n      ) &&\n      _Math_js__WEBPACK_IMPORTED_MODULE_3__/* ["default"].equalsEpsilon */ .Z.equalsEpsilon(\n        left.z,\n        right.z,\n        relativeEpsilon,\n        absoluteEpsilon\n      ) &&\n      _Math_js__WEBPACK_IMPORTED_MODULE_3__/* ["default"].equalsEpsilon */ .Z.equalsEpsilon(\n        left.w,\n        right.w,\n        relativeEpsilon,\n        absoluteEpsilon\n      ))\n  );\n};\n\n/**\n * An immutable Cartesian4 instance initialized to (0.0, 0.0, 0.0, 0.0).\n *\n * @type {Cartesian4}\n * @constant\n */\nCartesian4.ZERO = Object.freeze(new Cartesian4(0.0, 0.0, 0.0, 0.0));\n\n/**\n * An immutable Cartesian4 instance initialized to (1.0, 1.0, 1.0, 1.0).\n *\n * @type {Cartesian4}\n * @constant\n */\nCartesian4.ONE = Object.freeze(new Cartesian4(1.0, 1.0, 1.0, 1.0));\n\n/**\n * An immutable Cartesian4 instance initialized to (1.0, 0.0, 0.0, 0.0).\n *\n * @type {Cartesian4}\n * @constant\n */\nCartesian4.UNIT_X = Object.freeze(new Cartesian4(1.0, 0.0, 0.0, 0.0));\n\n/**\n * An immutable Cartesian4 instance initialized to (0.0, 1.0, 0.0, 0.0).\n *\n * @type {Cartesian4}\n * @constant\n */\nCartesian4.UNIT_Y = Object.freeze(new Cartesian4(0.0, 1.0, 0.0, 0.0));\n\n/**\n * An immutable Cartesian4 instance initialized to (0.0, 0.0, 1.0, 0.0).\n *\n * @type {Cartesian4}\n * @constant\n */\nCartesian4.UNIT_Z = Object.freeze(new Cartesian4(0.0, 0.0, 1.0, 0.0));\n\n/**\n * An immutable Cartesian4 instance initialized to (0.0, 0.0, 0.0, 1.0).\n *\n * @type {Cartesian4}\n * @constant\n */\nCartesian4.UNIT_W = Object.freeze(new Cartesian4(0.0, 0.0, 0.0, 1.0));\n\n/**\n * Duplicates this Cartesian4 instance.\n *\n * @param {Cartesian4} [result] The object onto which to store the result.\n * @returns {Cartesian4} The modified result parameter or a new Cartesian4 instance if one was not provided.\n */\nCartesian4.prototype.clone = function (result) {\n  return Cartesian4.clone(this, result);\n};\n\n/**\n * Compares this Cartesian against the provided Cartesian componentwise and returns\n * <code>true</code> if they are equal, <code>false</code> otherwise.\n *\n * @param {Cartesian4} [right] The right hand side Cartesian.\n * @returns {Boolean} <code>true</code> if they are equal, <code>false</code> otherwise.\n */\nCartesian4.prototype.equals = function (right) {\n  return Cartesian4.equals(this, right);\n};\n\n/**\n * Compares this Cartesian against the provided Cartesian componentwise and returns\n * <code>true</code> if they pass an absolute or relative tolerance test,\n * <code>false</code> otherwise.\n *\n * @param {Cartesian4} [right] The right hand side Cartesian.\n * @param {Number} [relativeEpsilon=0] The relative epsilon tolerance to use for equality testing.\n * @param {Number} [absoluteEpsilon=relativeEpsilon] The absolute epsilon tolerance to use for equality testing.\n * @returns {Boolean} <code>true</code> if they are within the provided epsilon, <code>false</code> otherwise.\n */\nCartesian4.prototype.equalsEpsilon = function (\n  right,\n  relativeEpsilon,\n  absoluteEpsilon\n) {\n  return Cartesian4.equalsEpsilon(\n    this,\n    right,\n    relativeEpsilon,\n    absoluteEpsilon\n  );\n};\n\n/**\n * Creates a string representing this Cartesian in the format \'(x, y, z, w)\'.\n *\n * @returns {String} A string representing the provided Cartesian in the format \'(x, y, z, w)\'.\n */\nCartesian4.prototype.toString = function () {\n  return "(" + this.x + ", " + this.y + ", " + this.z + ", " + this.w + ")";\n};\n\n// scratchU8Array and scratchF32Array are views into the same buffer\nvar scratchF32Array = new Float32Array(1);\nvar scratchU8Array = new Uint8Array(scratchF32Array.buffer);\n\nvar testU32 = new Uint32Array([0x11223344]);\nvar testU8 = new Uint8Array(testU32.buffer);\nvar littleEndian = testU8[0] === 0x44;\n\n/**\n * Packs an arbitrary floating point value to 4 values representable using uint8.\n *\n * @param {Number} value A floating point number.\n * @param {Cartesian4} [result] The Cartesian4 that will contain the packed float.\n * @returns {Cartesian4} A Cartesian4 representing the float packed to values in x, y, z, and w.\n */\nCartesian4.packFloat = function (value, result) {\n  //>>includeStart(\'debug\', pragmas.debug);\n  _Check_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].typeOf.number */ .Z.typeOf.number("value", value);\n  //>>includeEnd(\'debug\');\n\n  if (!(0,_defined_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .Z)(result)) {\n    result = new Cartesian4();\n  }\n\n  // scratchU8Array and scratchF32Array are views into the same buffer\n  scratchF32Array[0] = value;\n\n  if (littleEndian) {\n    result.x = scratchU8Array[0];\n    result.y = scratchU8Array[1];\n    result.z = scratchU8Array[2];\n    result.w = scratchU8Array[3];\n  } else {\n    // convert from big-endian to little-endian\n    result.x = scratchU8Array[3];\n    result.y = scratchU8Array[2];\n    result.z = scratchU8Array[1];\n    result.w = scratchU8Array[0];\n  }\n  return result;\n};\n\n/**\n * Unpacks a float packed using Cartesian4.packFloat.\n *\n * @param {Cartesian4} packedFloat A Cartesian4 containing a float packed to 4 values representable using uint8.\n * @returns {Number} The unpacked float.\n * @private\n */\nCartesian4.unpackFloat = function (packedFloat) {\n  //>>includeStart(\'debug\', pragmas.debug);\n  _Check_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].typeOf.object */ .Z.typeOf.object("packedFloat", packedFloat);\n  //>>includeEnd(\'debug\');\n\n  // scratchU8Array and scratchF32Array are views into the same buffer\n  if (littleEndian) {\n    scratchU8Array[0] = packedFloat.x;\n    scratchU8Array[1] = packedFloat.y;\n    scratchU8Array[2] = packedFloat.z;\n    scratchU8Array[3] = packedFloat.w;\n  } else {\n    // convert from little-endian to big-endian\n    scratchU8Array[0] = packedFloat.w;\n    scratchU8Array[1] = packedFloat.z;\n    scratchU8Array[2] = packedFloat.y;\n    scratchU8Array[3] = packedFloat.x;\n  }\n  return scratchF32Array[0];\n};\n/* harmony default export */ __webpack_exports__["Z"] = (Cartesian4);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNjMzNjcuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBK0I7QUFDYztBQUNWO0FBQ2M7QUFDZDs7QUFFbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQSxXQUFXLHFFQUFZOztBQUV2QjtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQSxXQUFXLHFFQUFZOztBQUV2QjtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQSxXQUFXLHFFQUFZOztBQUV2QjtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQSxXQUFXLHFFQUFZO0FBQ3ZCOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFlBQVk7QUFDdkIsYUFBYSxZQUFZO0FBQ3pCO0FBQ0E7QUFDQSxPQUFPLGdFQUFPO0FBQ2Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx5Q0FBeUMsWUFBWTtBQUNyRDtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsWUFBWTtBQUN2QixhQUFhLFlBQVk7QUFDekI7QUFDQTtBQUNBO0FBQ0EsRUFBRSxzRkFBbUI7QUFDckI7QUFDQSxPQUFPLGdFQUFPO0FBQ2Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxZQUFZO0FBQ3ZCLFdBQVcsWUFBWTtBQUN2QixhQUFhLFlBQVk7QUFDekI7QUFDQTtBQUNBLE9BQU8sZ0VBQU87QUFDZDtBQUNBOztBQUVBLE9BQU8sZ0VBQU87QUFDZDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxZQUFZO0FBQ3ZCLFdBQVcsVUFBVTtBQUNyQixXQUFXLFFBQVE7QUFDbkI7QUFDQSxhQUFhLFVBQVU7QUFDdkI7QUFDQTtBQUNBO0FBQ0EsRUFBRSxzRkFBbUI7QUFDckIsRUFBRSwwRUFBYTtBQUNmOztBQUVBLGtCQUFrQixxRUFBWTs7QUFFOUI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFVBQVU7QUFDckIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsWUFBWTtBQUN2QixhQUFhLGFBQWE7QUFDMUI7QUFDQTtBQUNBO0FBQ0EsRUFBRSwwRUFBYTtBQUNmOztBQUVBLGtCQUFrQixxRUFBWTs7QUFFOUIsT0FBTyxnRUFBTztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZUFBZSxjQUFjO0FBQzdCLGVBQWUsVUFBVSwrSEFBK0gsc0JBQXNCOztBQUU5SyxpQkFBaUIsVUFBVTtBQUMzQjtBQUNBO0FBQ0E7QUFDQSxFQUFFLDBFQUFhO0FBQ2Y7O0FBRUE7QUFDQTtBQUNBLE9BQU8sZ0VBQU87QUFDZDtBQUNBLElBQUk7QUFDSixjQUFjLG1FQUFjO0FBQzVCO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQSxrQkFBa0IsWUFBWTtBQUM5QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFVBQVU7QUFDckIsV0FBVyxjQUFjO0FBQ3pCLGFBQWEsY0FBYztBQUMzQjtBQUNBO0FBQ0E7QUFDQSxFQUFFLDBFQUFhO0FBQ2YsRUFBRSw4SEFBdUM7QUFDekM7QUFDQSxjQUFjLG1FQUFjO0FBQzVCO0FBQ0E7O0FBRUE7QUFDQSxPQUFPLGdFQUFPO0FBQ2Q7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQSxrQkFBa0IsWUFBWTtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxVQUFVO0FBQ3JCLFdBQVcsUUFBUTtBQUNuQixXQUFXLFlBQVk7QUFDdkIsYUFBYSxhQUFhO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxZQUFZO0FBQ3ZCLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQSxFQUFFLHNGQUFtQjtBQUNyQjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsWUFBWTtBQUN2QixhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0EsRUFBRSxzRkFBbUI7QUFDckI7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFlBQVk7QUFDdkIsV0FBVyxZQUFZO0FBQ3ZCLFdBQVcsWUFBWTtBQUN2QixhQUFhLFlBQVk7QUFDekI7QUFDQTtBQUNBO0FBQ0EsRUFBRSxzRkFBbUI7QUFDckIsRUFBRSxzRkFBbUI7QUFDckIsRUFBRSxzRkFBbUI7QUFDckI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFlBQVk7QUFDdkIsV0FBVyxZQUFZO0FBQ3ZCLFdBQVcsWUFBWTtBQUN2QixhQUFhLFlBQVk7QUFDekI7QUFDQTtBQUNBO0FBQ0EsRUFBRSxzRkFBbUI7QUFDckIsRUFBRSxzRkFBbUI7QUFDckIsRUFBRSxzRkFBbUI7QUFDckI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFlBQVk7QUFDdkIsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBLEVBQUUsc0ZBQW1CO0FBQ3JCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsWUFBWTtBQUN2QixhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxZQUFZO0FBQ3ZCLFdBQVcsWUFBWTtBQUN2QixhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRSxzRkFBbUI7QUFDckIsRUFBRSxzRkFBbUI7QUFDckI7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx5RUFBeUUsMEJBQTBCO0FBQ25HO0FBQ0EsV0FBVyxZQUFZO0FBQ3ZCLFdBQVcsWUFBWTtBQUN2QixhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRSxzRkFBbUI7QUFDckIsRUFBRSxzRkFBbUI7QUFDckI7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsWUFBWTtBQUN2QixXQUFXLFlBQVk7QUFDdkIsYUFBYSxZQUFZO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBLEVBQUUsc0ZBQW1CO0FBQ3JCLEVBQUUsc0ZBQW1CO0FBQ3JCOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxtRUFBYztBQUM1QjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxZQUFZO0FBQ3ZCLFdBQVcsWUFBWTtBQUN2QixhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0EsRUFBRSxzRkFBbUI7QUFDckIsRUFBRSxzRkFBbUI7QUFDckI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxZQUFZO0FBQ3ZCLFdBQVcsWUFBWTtBQUN2QixXQUFXLFlBQVk7QUFDdkIsYUFBYSxZQUFZO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBLEVBQUUsc0ZBQW1CO0FBQ3JCLEVBQUUsc0ZBQW1CO0FBQ3JCLEVBQUUsc0ZBQW1CO0FBQ3JCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFlBQVk7QUFDdkIsV0FBVyxZQUFZO0FBQ3ZCLFdBQVcsWUFBWTtBQUN2QixhQUFhLFlBQVk7QUFDekI7QUFDQTtBQUNBO0FBQ0EsRUFBRSxzRkFBbUI7QUFDckIsRUFBRSxzRkFBbUI7QUFDckIsRUFBRSxzRkFBbUI7QUFDckI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsWUFBWTtBQUN2QixXQUFXLFlBQVk7QUFDdkIsV0FBVyxZQUFZO0FBQ3ZCLGFBQWEsWUFBWTtBQUN6QjtBQUNBO0FBQ0E7QUFDQSxFQUFFLHNGQUFtQjtBQUNyQixFQUFFLHNGQUFtQjtBQUNyQixFQUFFLHNGQUFtQjtBQUNyQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxZQUFZO0FBQ3ZCLFdBQVcsWUFBWTtBQUN2QixXQUFXLFlBQVk7QUFDdkIsYUFBYSxZQUFZO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBLEVBQUUsc0ZBQW1CO0FBQ3JCLEVBQUUsc0ZBQW1CO0FBQ3JCLEVBQUUsc0ZBQW1CO0FBQ3JCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFlBQVk7QUFDdkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsWUFBWTtBQUN2QixhQUFhLFlBQVk7QUFDekI7QUFDQTtBQUNBO0FBQ0EsRUFBRSxzRkFBbUI7QUFDckIsRUFBRSxzRkFBbUI7QUFDckIsRUFBRSxzRkFBbUI7QUFDckI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsWUFBWTtBQUN2QixXQUFXLFFBQVE7QUFDbkIsV0FBVyxZQUFZO0FBQ3ZCLGFBQWEsWUFBWTtBQUN6QjtBQUNBO0FBQ0E7QUFDQSxFQUFFLHNGQUFtQjtBQUNyQixFQUFFLHNGQUFtQjtBQUNyQixFQUFFLHNGQUFtQjtBQUNyQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxZQUFZO0FBQ3ZCLFdBQVcsWUFBWTtBQUN2QixhQUFhLFlBQVk7QUFDekI7QUFDQTtBQUNBO0FBQ0EsRUFBRSxzRkFBbUI7QUFDckIsRUFBRSxzRkFBbUI7QUFDckI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsWUFBWTtBQUN2QixXQUFXLFlBQVk7QUFDdkIsYUFBYSxZQUFZO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBLEVBQUUsc0ZBQW1CO0FBQ3JCLEVBQUUsc0ZBQW1CO0FBQ3JCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsWUFBWTtBQUN2QixXQUFXLFdBQVc7QUFDdEIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsWUFBWTtBQUN2QixhQUFhLFlBQVk7QUFDekI7QUFDQTtBQUNBO0FBQ0EsRUFBRSxzRkFBbUI7QUFDckIsRUFBRSxzRkFBbUI7QUFDckIsRUFBRSxzRkFBbUI7QUFDckIsRUFBRSxzRkFBbUI7QUFDckI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFlBQVk7QUFDdkIsV0FBVyxZQUFZO0FBQ3ZCLGFBQWEsWUFBWTtBQUN6QjtBQUNBO0FBQ0E7QUFDQSxFQUFFLHNGQUFtQjtBQUNyQixFQUFFLHNGQUFtQjtBQUNyQjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxZQUFZO0FBQ3ZCLFdBQVcsWUFBWTtBQUN2QixhQUFhLFNBQVM7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLLGdFQUFPO0FBQ1osTUFBTSxnRUFBTztBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFlBQVk7QUFDdkIsV0FBVyxZQUFZO0FBQ3ZCLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsYUFBYSxTQUFTO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUssZ0VBQU87QUFDWixNQUFNLGdFQUFPO0FBQ2IsTUFBTSxxRkFBd0I7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU0scUZBQXdCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNLHFGQUF3QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTSxxRkFBd0I7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxZQUFZO0FBQ3ZCLGFBQWEsWUFBWTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsWUFBWTtBQUN2QixhQUFhLFNBQVM7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsWUFBWTtBQUN2QixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLGFBQWEsU0FBUztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxZQUFZO0FBQ3ZCLGFBQWEsWUFBWTtBQUN6QjtBQUNBO0FBQ0E7QUFDQSxFQUFFLHNGQUFtQjtBQUNyQjs7QUFFQSxPQUFPLGdFQUFPO0FBQ2Q7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFlBQVk7QUFDdkIsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRSxzRkFBbUI7QUFDckI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5REFBZSxVQUFVLEVBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly92dWUzLXdlYnBhY2s1Ly4vbm9kZV9tb2R1bGVzL2Nlc2l1bS9Tb3VyY2UvQ29yZS9DYXJ0ZXNpYW40LmpzP2I3NmUiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IENoZWNrIGZyb20gXCIuL0NoZWNrLmpzXCI7XG5pbXBvcnQgZGVmYXVsdFZhbHVlIGZyb20gXCIuL2RlZmF1bHRWYWx1ZS5qc1wiO1xuaW1wb3J0IGRlZmluZWQgZnJvbSBcIi4vZGVmaW5lZC5qc1wiO1xuaW1wb3J0IERldmVsb3BlckVycm9yIGZyb20gXCIuL0RldmVsb3BlckVycm9yLmpzXCI7XG5pbXBvcnQgQ2VzaXVtTWF0aCBmcm9tIFwiLi9NYXRoLmpzXCI7XG5cbi8qKlxuICogQSA0RCBDYXJ0ZXNpYW4gcG9pbnQuXG4gKiBAYWxpYXMgQ2FydGVzaWFuNFxuICogQGNvbnN0cnVjdG9yXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IFt4PTAuMF0gVGhlIFggY29tcG9uZW50LlxuICogQHBhcmFtIHtOdW1iZXJ9IFt5PTAuMF0gVGhlIFkgY29tcG9uZW50LlxuICogQHBhcmFtIHtOdW1iZXJ9IFt6PTAuMF0gVGhlIFogY29tcG9uZW50LlxuICogQHBhcmFtIHtOdW1iZXJ9IFt3PTAuMF0gVGhlIFcgY29tcG9uZW50LlxuICpcbiAqIEBzZWUgQ2FydGVzaWFuMlxuICogQHNlZSBDYXJ0ZXNpYW4zXG4gKiBAc2VlIFBhY2thYmxlXG4gKi9cbmZ1bmN0aW9uIENhcnRlc2lhbjQoeCwgeSwgeiwgdykge1xuICAvKipcbiAgICogVGhlIFggY29tcG9uZW50LlxuICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgKiBAZGVmYXVsdCAwLjBcbiAgICovXG4gIHRoaXMueCA9IGRlZmF1bHRWYWx1ZSh4LCAwLjApO1xuXG4gIC8qKlxuICAgKiBUaGUgWSBjb21wb25lbnQuXG4gICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAqIEBkZWZhdWx0IDAuMFxuICAgKi9cbiAgdGhpcy55ID0gZGVmYXVsdFZhbHVlKHksIDAuMCk7XG5cbiAgLyoqXG4gICAqIFRoZSBaIGNvbXBvbmVudC5cbiAgICogQHR5cGUge051bWJlcn1cbiAgICogQGRlZmF1bHQgMC4wXG4gICAqL1xuICB0aGlzLnogPSBkZWZhdWx0VmFsdWUoeiwgMC4wKTtcblxuICAvKipcbiAgICogVGhlIFcgY29tcG9uZW50LlxuICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgKiBAZGVmYXVsdCAwLjBcbiAgICovXG4gIHRoaXMudyA9IGRlZmF1bHRWYWx1ZSh3LCAwLjApO1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYSBDYXJ0ZXNpYW40IGluc3RhbmNlIGZyb20geCwgeSwgeiBhbmQgdyBjb29yZGluYXRlcy5cbiAqXG4gKiBAcGFyYW0ge051bWJlcn0geCBUaGUgeCBjb29yZGluYXRlLlxuICogQHBhcmFtIHtOdW1iZXJ9IHkgVGhlIHkgY29vcmRpbmF0ZS5cbiAqIEBwYXJhbSB7TnVtYmVyfSB6IFRoZSB6IGNvb3JkaW5hdGUuXG4gKiBAcGFyYW0ge051bWJlcn0gdyBUaGUgdyBjb29yZGluYXRlLlxuICogQHBhcmFtIHtDYXJ0ZXNpYW40fSBbcmVzdWx0XSBUaGUgb2JqZWN0IG9udG8gd2hpY2ggdG8gc3RvcmUgdGhlIHJlc3VsdC5cbiAqIEByZXR1cm5zIHtDYXJ0ZXNpYW40fSBUaGUgbW9kaWZpZWQgcmVzdWx0IHBhcmFtZXRlciBvciBhIG5ldyBDYXJ0ZXNpYW40IGluc3RhbmNlIGlmIG9uZSB3YXMgbm90IHByb3ZpZGVkLlxuICovXG5DYXJ0ZXNpYW40LmZyb21FbGVtZW50cyA9IGZ1bmN0aW9uICh4LCB5LCB6LCB3LCByZXN1bHQpIHtcbiAgaWYgKCFkZWZpbmVkKHJlc3VsdCkpIHtcbiAgICByZXR1cm4gbmV3IENhcnRlc2lhbjQoeCwgeSwgeiwgdyk7XG4gIH1cblxuICByZXN1bHQueCA9IHg7XG4gIHJlc3VsdC55ID0geTtcbiAgcmVzdWx0LnogPSB6O1xuICByZXN1bHQudyA9IHc7XG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG4vKipcbiAqIENyZWF0ZXMgYSBDYXJ0ZXNpYW40IGluc3RhbmNlIGZyb20gYSB7QGxpbmsgQ29sb3J9LiA8Y29kZT5yZWQ8L2NvZGU+LCA8Y29kZT5ncmVlbjwvY29kZT4sIDxjb2RlPmJsdWU8L2NvZGU+LFxuICogYW5kIDxjb2RlPmFscGhhPC9jb2RlPiBtYXAgdG8gPGNvZGU+eDwvY29kZT4sIDxjb2RlPnk8L2NvZGU+LCA8Y29kZT56PC9jb2RlPiwgYW5kIDxjb2RlPnc8L2NvZGU+LCByZXNwZWN0aXZlbHkuXG4gKlxuICogQHBhcmFtIHtDb2xvcn0gY29sb3IgVGhlIHNvdXJjZSBjb2xvci5cbiAqIEBwYXJhbSB7Q2FydGVzaWFuNH0gW3Jlc3VsdF0gVGhlIG9iamVjdCBvbnRvIHdoaWNoIHRvIHN0b3JlIHRoZSByZXN1bHQuXG4gKiBAcmV0dXJucyB7Q2FydGVzaWFuNH0gVGhlIG1vZGlmaWVkIHJlc3VsdCBwYXJhbWV0ZXIgb3IgYSBuZXcgQ2FydGVzaWFuNCBpbnN0YW5jZSBpZiBvbmUgd2FzIG5vdCBwcm92aWRlZC5cbiAqL1xuQ2FydGVzaWFuNC5mcm9tQ29sb3IgPSBmdW5jdGlvbiAoY29sb3IsIHJlc3VsdCkge1xuICAvLz4+aW5jbHVkZVN0YXJ0KCdkZWJ1ZycsIHByYWdtYXMuZGVidWcpO1xuICBDaGVjay50eXBlT2Yub2JqZWN0KFwiY29sb3JcIiwgY29sb3IpO1xuICAvLz4+aW5jbHVkZUVuZCgnZGVidWcnKTtcbiAgaWYgKCFkZWZpbmVkKHJlc3VsdCkpIHtcbiAgICByZXR1cm4gbmV3IENhcnRlc2lhbjQoY29sb3IucmVkLCBjb2xvci5ncmVlbiwgY29sb3IuYmx1ZSwgY29sb3IuYWxwaGEpO1xuICB9XG5cbiAgcmVzdWx0LnggPSBjb2xvci5yZWQ7XG4gIHJlc3VsdC55ID0gY29sb3IuZ3JlZW47XG4gIHJlc3VsdC56ID0gY29sb3IuYmx1ZTtcbiAgcmVzdWx0LncgPSBjb2xvci5hbHBoYTtcbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbi8qKlxuICogRHVwbGljYXRlcyBhIENhcnRlc2lhbjQgaW5zdGFuY2UuXG4gKlxuICogQHBhcmFtIHtDYXJ0ZXNpYW40fSBjYXJ0ZXNpYW4gVGhlIENhcnRlc2lhbiB0byBkdXBsaWNhdGUuXG4gKiBAcGFyYW0ge0NhcnRlc2lhbjR9IFtyZXN1bHRdIFRoZSBvYmplY3Qgb250byB3aGljaCB0byBzdG9yZSB0aGUgcmVzdWx0LlxuICogQHJldHVybnMge0NhcnRlc2lhbjR9IFRoZSBtb2RpZmllZCByZXN1bHQgcGFyYW1ldGVyIG9yIGEgbmV3IENhcnRlc2lhbjQgaW5zdGFuY2UgaWYgb25lIHdhcyBub3QgcHJvdmlkZWQuIChSZXR1cm5zIHVuZGVmaW5lZCBpZiBjYXJ0ZXNpYW4gaXMgdW5kZWZpbmVkKVxuICovXG5DYXJ0ZXNpYW40LmNsb25lID0gZnVuY3Rpb24gKGNhcnRlc2lhbiwgcmVzdWx0KSB7XG4gIGlmICghZGVmaW5lZChjYXJ0ZXNpYW4pKSB7XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxuXG4gIGlmICghZGVmaW5lZChyZXN1bHQpKSB7XG4gICAgcmV0dXJuIG5ldyBDYXJ0ZXNpYW40KGNhcnRlc2lhbi54LCBjYXJ0ZXNpYW4ueSwgY2FydGVzaWFuLnosIGNhcnRlc2lhbi53KTtcbiAgfVxuXG4gIHJlc3VsdC54ID0gY2FydGVzaWFuLng7XG4gIHJlc3VsdC55ID0gY2FydGVzaWFuLnk7XG4gIHJlc3VsdC56ID0gY2FydGVzaWFuLno7XG4gIHJlc3VsdC53ID0gY2FydGVzaWFuLnc7XG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG4vKipcbiAqIFRoZSBudW1iZXIgb2YgZWxlbWVudHMgdXNlZCB0byBwYWNrIHRoZSBvYmplY3QgaW50byBhbiBhcnJheS5cbiAqIEB0eXBlIHtOdW1iZXJ9XG4gKi9cbkNhcnRlc2lhbjQucGFja2VkTGVuZ3RoID0gNDtcblxuLyoqXG4gKiBTdG9yZXMgdGhlIHByb3ZpZGVkIGluc3RhbmNlIGludG8gdGhlIHByb3ZpZGVkIGFycmF5LlxuICpcbiAqIEBwYXJhbSB7Q2FydGVzaWFuNH0gdmFsdWUgVGhlIHZhbHVlIHRvIHBhY2suXG4gKiBAcGFyYW0ge051bWJlcltdfSBhcnJheSBUaGUgYXJyYXkgdG8gcGFjayBpbnRvLlxuICogQHBhcmFtIHtOdW1iZXJ9IFtzdGFydGluZ0luZGV4PTBdIFRoZSBpbmRleCBpbnRvIHRoZSBhcnJheSBhdCB3aGljaCB0byBzdGFydCBwYWNraW5nIHRoZSBlbGVtZW50cy5cbiAqXG4gKiBAcmV0dXJucyB7TnVtYmVyW119IFRoZSBhcnJheSB0aGF0IHdhcyBwYWNrZWQgaW50b1xuICovXG5DYXJ0ZXNpYW40LnBhY2sgPSBmdW5jdGlvbiAodmFsdWUsIGFycmF5LCBzdGFydGluZ0luZGV4KSB7XG4gIC8vPj5pbmNsdWRlU3RhcnQoJ2RlYnVnJywgcHJhZ21hcy5kZWJ1Zyk7XG4gIENoZWNrLnR5cGVPZi5vYmplY3QoXCJ2YWx1ZVwiLCB2YWx1ZSk7XG4gIENoZWNrLmRlZmluZWQoXCJhcnJheVwiLCBhcnJheSk7XG4gIC8vPj5pbmNsdWRlRW5kKCdkZWJ1ZycpO1xuXG4gIHN0YXJ0aW5nSW5kZXggPSBkZWZhdWx0VmFsdWUoc3RhcnRpbmdJbmRleCwgMCk7XG5cbiAgYXJyYXlbc3RhcnRpbmdJbmRleCsrXSA9IHZhbHVlLng7XG4gIGFycmF5W3N0YXJ0aW5nSW5kZXgrK10gPSB2YWx1ZS55O1xuICBhcnJheVtzdGFydGluZ0luZGV4KytdID0gdmFsdWUuejtcbiAgYXJyYXlbc3RhcnRpbmdJbmRleF0gPSB2YWx1ZS53O1xuXG4gIHJldHVybiBhcnJheTtcbn07XG5cbi8qKlxuICogUmV0cmlldmVzIGFuIGluc3RhbmNlIGZyb20gYSBwYWNrZWQgYXJyYXkuXG4gKlxuICogQHBhcmFtIHtOdW1iZXJbXX0gYXJyYXkgVGhlIHBhY2tlZCBhcnJheS5cbiAqIEBwYXJhbSB7TnVtYmVyfSBbc3RhcnRpbmdJbmRleD0wXSBUaGUgc3RhcnRpbmcgaW5kZXggb2YgdGhlIGVsZW1lbnQgdG8gYmUgdW5wYWNrZWQuXG4gKiBAcGFyYW0ge0NhcnRlc2lhbjR9IFtyZXN1bHRdIFRoZSBvYmplY3QgaW50byB3aGljaCB0byBzdG9yZSB0aGUgcmVzdWx0LlxuICogQHJldHVybnMge0NhcnRlc2lhbjR9ICBUaGUgbW9kaWZpZWQgcmVzdWx0IHBhcmFtZXRlciBvciBhIG5ldyBDYXJ0ZXNpYW40IGluc3RhbmNlIGlmIG9uZSB3YXMgbm90IHByb3ZpZGVkLlxuICovXG5DYXJ0ZXNpYW40LnVucGFjayA9IGZ1bmN0aW9uIChhcnJheSwgc3RhcnRpbmdJbmRleCwgcmVzdWx0KSB7XG4gIC8vPj5pbmNsdWRlU3RhcnQoJ2RlYnVnJywgcHJhZ21hcy5kZWJ1Zyk7XG4gIENoZWNrLmRlZmluZWQoXCJhcnJheVwiLCBhcnJheSk7XG4gIC8vPj5pbmNsdWRlRW5kKCdkZWJ1ZycpO1xuXG4gIHN0YXJ0aW5nSW5kZXggPSBkZWZhdWx0VmFsdWUoc3RhcnRpbmdJbmRleCwgMCk7XG5cbiAgaWYgKCFkZWZpbmVkKHJlc3VsdCkpIHtcbiAgICByZXN1bHQgPSBuZXcgQ2FydGVzaWFuNCgpO1xuICB9XG4gIHJlc3VsdC54ID0gYXJyYXlbc3RhcnRpbmdJbmRleCsrXTtcbiAgcmVzdWx0LnkgPSBhcnJheVtzdGFydGluZ0luZGV4KytdO1xuICByZXN1bHQueiA9IGFycmF5W3N0YXJ0aW5nSW5kZXgrK107XG4gIHJlc3VsdC53ID0gYXJyYXlbc3RhcnRpbmdJbmRleF07XG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG4vKipcbiAgICAgKiBGbGF0dGVucyBhbiBhcnJheSBvZiBDYXJ0ZXNpYW40cyBpbnRvIGFuZCBhcnJheSBvZiBjb21wb25lbnRzLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtDYXJ0ZXNpYW40W119IGFycmF5IFRoZSBhcnJheSBvZiBjYXJ0ZXNpYW5zIHRvIHBhY2suXG4gICAgICogQHBhcmFtIHtOdW1iZXJbXX0gW3Jlc3VsdF0gVGhlIGFycmF5IG9udG8gd2hpY2ggdG8gc3RvcmUgdGhlIHJlc3VsdC4gSWYgdGhpcyBpcyBhIHR5cGVkIGFycmF5LCBpdCBtdXN0IGhhdmUgYXJyYXkubGVuZ3RoICogNCBjb21wb25lbnRzLCBlbHNlIGEge0BsaW5rIERldmVsb3BlckVycm9yfSB3aWxsIGJlIHRocm93bi4gSWYgaXQgaXMgYSByZWd1bGFyIGFycmF5LCBpdCB3aWxsIGJlIHJlc2l6ZWQgdG8gaGF2ZSAoYXJyYXkubGVuZ3RoICogNCkgZWxlbWVudHMuXG5cbiAgICAgKiBAcmV0dXJucyB7TnVtYmVyW119IFRoZSBwYWNrZWQgYXJyYXkuXG4gICAgICovXG5DYXJ0ZXNpYW40LnBhY2tBcnJheSA9IGZ1bmN0aW9uIChhcnJheSwgcmVzdWx0KSB7XG4gIC8vPj5pbmNsdWRlU3RhcnQoJ2RlYnVnJywgcHJhZ21hcy5kZWJ1Zyk7XG4gIENoZWNrLmRlZmluZWQoXCJhcnJheVwiLCBhcnJheSk7XG4gIC8vPj5pbmNsdWRlRW5kKCdkZWJ1ZycpO1xuXG4gIHZhciBsZW5ndGggPSBhcnJheS5sZW5ndGg7XG4gIHZhciByZXN1bHRMZW5ndGggPSBsZW5ndGggKiA0O1xuICBpZiAoIWRlZmluZWQocmVzdWx0KSkge1xuICAgIHJlc3VsdCA9IG5ldyBBcnJheShyZXN1bHRMZW5ndGgpO1xuICB9IGVsc2UgaWYgKCFBcnJheS5pc0FycmF5KHJlc3VsdCkgJiYgcmVzdWx0Lmxlbmd0aCAhPT0gcmVzdWx0TGVuZ3RoKSB7XG4gICAgdGhyb3cgbmV3IERldmVsb3BlckVycm9yKFxuICAgICAgXCJJZiByZXN1bHQgaXMgYSB0eXBlZCBhcnJheSwgaXQgbXVzdCBoYXZlIGV4YWN0bHkgYXJyYXkubGVuZ3RoICogNCBlbGVtZW50c1wiXG4gICAgKTtcbiAgfSBlbHNlIGlmIChyZXN1bHQubGVuZ3RoICE9PSByZXN1bHRMZW5ndGgpIHtcbiAgICByZXN1bHQubGVuZ3RoID0gcmVzdWx0TGVuZ3RoO1xuICB9XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7ICsraSkge1xuICAgIENhcnRlc2lhbjQucGFjayhhcnJheVtpXSwgcmVzdWx0LCBpICogNCk7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbi8qKlxuICogVW5wYWNrcyBhbiBhcnJheSBvZiBjYXJ0ZXNpYW4gY29tcG9uZW50cyBpbnRvIGFuZCBhcnJheSBvZiBDYXJ0ZXNpYW40cy5cbiAqXG4gKiBAcGFyYW0ge051bWJlcltdfSBhcnJheSBUaGUgYXJyYXkgb2YgY29tcG9uZW50cyB0byB1bnBhY2suXG4gKiBAcGFyYW0ge0NhcnRlc2lhbjRbXX0gW3Jlc3VsdF0gVGhlIGFycmF5IG9udG8gd2hpY2ggdG8gc3RvcmUgdGhlIHJlc3VsdC5cbiAqIEByZXR1cm5zIHtDYXJ0ZXNpYW40W119IFRoZSB1bnBhY2tlZCBhcnJheS5cbiAqL1xuQ2FydGVzaWFuNC51bnBhY2tBcnJheSA9IGZ1bmN0aW9uIChhcnJheSwgcmVzdWx0KSB7XG4gIC8vPj5pbmNsdWRlU3RhcnQoJ2RlYnVnJywgcHJhZ21hcy5kZWJ1Zyk7XG4gIENoZWNrLmRlZmluZWQoXCJhcnJheVwiLCBhcnJheSk7XG4gIENoZWNrLnR5cGVPZi5udW1iZXIuZ3JlYXRlclRoYW5PckVxdWFscyhcImFycmF5Lmxlbmd0aFwiLCBhcnJheS5sZW5ndGgsIDQpO1xuICBpZiAoYXJyYXkubGVuZ3RoICUgNCAhPT0gMCkge1xuICAgIHRocm93IG5ldyBEZXZlbG9wZXJFcnJvcihcImFycmF5IGxlbmd0aCBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgNC5cIik7XG4gIH1cbiAgLy8+PmluY2x1ZGVFbmQoJ2RlYnVnJyk7XG5cbiAgdmFyIGxlbmd0aCA9IGFycmF5Lmxlbmd0aDtcbiAgaWYgKCFkZWZpbmVkKHJlc3VsdCkpIHtcbiAgICByZXN1bHQgPSBuZXcgQXJyYXkobGVuZ3RoIC8gNCk7XG4gIH0gZWxzZSB7XG4gICAgcmVzdWx0Lmxlbmd0aCA9IGxlbmd0aCAvIDQ7XG4gIH1cblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSArPSA0KSB7XG4gICAgdmFyIGluZGV4ID0gaSAvIDQ7XG4gICAgcmVzdWx0W2luZGV4XSA9IENhcnRlc2lhbjQudW5wYWNrKGFycmF5LCBpLCByZXN1bHRbaW5kZXhdKTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgQ2FydGVzaWFuNCBmcm9tIGZvdXIgY29uc2VjdXRpdmUgZWxlbWVudHMgaW4gYW4gYXJyYXkuXG4gKiBAZnVuY3Rpb25cbiAqXG4gKiBAcGFyYW0ge051bWJlcltdfSBhcnJheSBUaGUgYXJyYXkgd2hvc2UgZm91ciBjb25zZWN1dGl2ZSBlbGVtZW50cyBjb3JyZXNwb25kIHRvIHRoZSB4LCB5LCB6LCBhbmQgdyBjb21wb25lbnRzLCByZXNwZWN0aXZlbHkuXG4gKiBAcGFyYW0ge051bWJlcn0gW3N0YXJ0aW5nSW5kZXg9MF0gVGhlIG9mZnNldCBpbnRvIHRoZSBhcnJheSBvZiB0aGUgZmlyc3QgZWxlbWVudCwgd2hpY2ggY29ycmVzcG9uZHMgdG8gdGhlIHggY29tcG9uZW50LlxuICogQHBhcmFtIHtDYXJ0ZXNpYW40fSBbcmVzdWx0XSBUaGUgb2JqZWN0IG9udG8gd2hpY2ggdG8gc3RvcmUgdGhlIHJlc3VsdC5cbiAqIEByZXR1cm5zIHtDYXJ0ZXNpYW40fSAgVGhlIG1vZGlmaWVkIHJlc3VsdCBwYXJhbWV0ZXIgb3IgYSBuZXcgQ2FydGVzaWFuNCBpbnN0YW5jZSBpZiBvbmUgd2FzIG5vdCBwcm92aWRlZC5cbiAqXG4gKiBAZXhhbXBsZVxuICogLy8gQ3JlYXRlIGEgQ2FydGVzaWFuNCB3aXRoICgxLjAsIDIuMCwgMy4wLCA0LjApXG4gKiB2YXIgdiA9IFsxLjAsIDIuMCwgMy4wLCA0LjBdO1xuICogdmFyIHAgPSBDZXNpdW0uQ2FydGVzaWFuNC5mcm9tQXJyYXkodik7XG4gKlxuICogLy8gQ3JlYXRlIGEgQ2FydGVzaWFuNCB3aXRoICgxLjAsIDIuMCwgMy4wLCA0LjApIHVzaW5nIGFuIG9mZnNldCBpbnRvIGFuIGFycmF5XG4gKiB2YXIgdjIgPSBbMC4wLCAwLjAsIDEuMCwgMi4wLCAzLjAsIDQuMF07XG4gKiB2YXIgcDIgPSBDZXNpdW0uQ2FydGVzaWFuNC5mcm9tQXJyYXkodjIsIDIpO1xuICovXG5DYXJ0ZXNpYW40LmZyb21BcnJheSA9IENhcnRlc2lhbjQudW5wYWNrO1xuXG4vKipcbiAqIENvbXB1dGVzIHRoZSB2YWx1ZSBvZiB0aGUgbWF4aW11bSBjb21wb25lbnQgZm9yIHRoZSBzdXBwbGllZCBDYXJ0ZXNpYW4uXG4gKlxuICogQHBhcmFtIHtDYXJ0ZXNpYW40fSBjYXJ0ZXNpYW4gVGhlIGNhcnRlc2lhbiB0byB1c2UuXG4gKiBAcmV0dXJucyB7TnVtYmVyfSBUaGUgdmFsdWUgb2YgdGhlIG1heGltdW0gY29tcG9uZW50LlxuICovXG5DYXJ0ZXNpYW40Lm1heGltdW1Db21wb25lbnQgPSBmdW5jdGlvbiAoY2FydGVzaWFuKSB7XG4gIC8vPj5pbmNsdWRlU3RhcnQoJ2RlYnVnJywgcHJhZ21hcy5kZWJ1Zyk7XG4gIENoZWNrLnR5cGVPZi5vYmplY3QoXCJjYXJ0ZXNpYW5cIiwgY2FydGVzaWFuKTtcbiAgLy8+PmluY2x1ZGVFbmQoJ2RlYnVnJyk7XG5cbiAgcmV0dXJuIE1hdGgubWF4KGNhcnRlc2lhbi54LCBjYXJ0ZXNpYW4ueSwgY2FydGVzaWFuLnosIGNhcnRlc2lhbi53KTtcbn07XG5cbi8qKlxuICogQ29tcHV0ZXMgdGhlIHZhbHVlIG9mIHRoZSBtaW5pbXVtIGNvbXBvbmVudCBmb3IgdGhlIHN1cHBsaWVkIENhcnRlc2lhbi5cbiAqXG4gKiBAcGFyYW0ge0NhcnRlc2lhbjR9IGNhcnRlc2lhbiBUaGUgY2FydGVzaWFuIHRvIHVzZS5cbiAqIEByZXR1cm5zIHtOdW1iZXJ9IFRoZSB2YWx1ZSBvZiB0aGUgbWluaW11bSBjb21wb25lbnQuXG4gKi9cbkNhcnRlc2lhbjQubWluaW11bUNvbXBvbmVudCA9IGZ1bmN0aW9uIChjYXJ0ZXNpYW4pIHtcbiAgLy8+PmluY2x1ZGVTdGFydCgnZGVidWcnLCBwcmFnbWFzLmRlYnVnKTtcbiAgQ2hlY2sudHlwZU9mLm9iamVjdChcImNhcnRlc2lhblwiLCBjYXJ0ZXNpYW4pO1xuICAvLz4+aW5jbHVkZUVuZCgnZGVidWcnKTtcblxuICByZXR1cm4gTWF0aC5taW4oY2FydGVzaWFuLngsIGNhcnRlc2lhbi55LCBjYXJ0ZXNpYW4ueiwgY2FydGVzaWFuLncpO1xufTtcblxuLyoqXG4gKiBDb21wYXJlcyB0d28gQ2FydGVzaWFucyBhbmQgY29tcHV0ZXMgYSBDYXJ0ZXNpYW4gd2hpY2ggY29udGFpbnMgdGhlIG1pbmltdW0gY29tcG9uZW50cyBvZiB0aGUgc3VwcGxpZWQgQ2FydGVzaWFucy5cbiAqXG4gKiBAcGFyYW0ge0NhcnRlc2lhbjR9IGZpcnN0IEEgY2FydGVzaWFuIHRvIGNvbXBhcmUuXG4gKiBAcGFyYW0ge0NhcnRlc2lhbjR9IHNlY29uZCBBIGNhcnRlc2lhbiB0byBjb21wYXJlLlxuICogQHBhcmFtIHtDYXJ0ZXNpYW40fSByZXN1bHQgVGhlIG9iamVjdCBpbnRvIHdoaWNoIHRvIHN0b3JlIHRoZSByZXN1bHQuXG4gKiBAcmV0dXJucyB7Q2FydGVzaWFuNH0gQSBjYXJ0ZXNpYW4gd2l0aCB0aGUgbWluaW11bSBjb21wb25lbnRzLlxuICovXG5DYXJ0ZXNpYW40Lm1pbmltdW1CeUNvbXBvbmVudCA9IGZ1bmN0aW9uIChmaXJzdCwgc2Vjb25kLCByZXN1bHQpIHtcbiAgLy8+PmluY2x1ZGVTdGFydCgnZGVidWcnLCBwcmFnbWFzLmRlYnVnKTtcbiAgQ2hlY2sudHlwZU9mLm9iamVjdChcImZpcnN0XCIsIGZpcnN0KTtcbiAgQ2hlY2sudHlwZU9mLm9iamVjdChcInNlY29uZFwiLCBzZWNvbmQpO1xuICBDaGVjay50eXBlT2Yub2JqZWN0KFwicmVzdWx0XCIsIHJlc3VsdCk7XG4gIC8vPj5pbmNsdWRlRW5kKCdkZWJ1ZycpO1xuXG4gIHJlc3VsdC54ID0gTWF0aC5taW4oZmlyc3QueCwgc2Vjb25kLngpO1xuICByZXN1bHQueSA9IE1hdGgubWluKGZpcnN0LnksIHNlY29uZC55KTtcbiAgcmVzdWx0LnogPSBNYXRoLm1pbihmaXJzdC56LCBzZWNvbmQueik7XG4gIHJlc3VsdC53ID0gTWF0aC5taW4oZmlyc3Qudywgc2Vjb25kLncpO1xuXG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG4vKipcbiAqIENvbXBhcmVzIHR3byBDYXJ0ZXNpYW5zIGFuZCBjb21wdXRlcyBhIENhcnRlc2lhbiB3aGljaCBjb250YWlucyB0aGUgbWF4aW11bSBjb21wb25lbnRzIG9mIHRoZSBzdXBwbGllZCBDYXJ0ZXNpYW5zLlxuICpcbiAqIEBwYXJhbSB7Q2FydGVzaWFuNH0gZmlyc3QgQSBjYXJ0ZXNpYW4gdG8gY29tcGFyZS5cbiAqIEBwYXJhbSB7Q2FydGVzaWFuNH0gc2Vjb25kIEEgY2FydGVzaWFuIHRvIGNvbXBhcmUuXG4gKiBAcGFyYW0ge0NhcnRlc2lhbjR9IHJlc3VsdCBUaGUgb2JqZWN0IGludG8gd2hpY2ggdG8gc3RvcmUgdGhlIHJlc3VsdC5cbiAqIEByZXR1cm5zIHtDYXJ0ZXNpYW40fSBBIGNhcnRlc2lhbiB3aXRoIHRoZSBtYXhpbXVtIGNvbXBvbmVudHMuXG4gKi9cbkNhcnRlc2lhbjQubWF4aW11bUJ5Q29tcG9uZW50ID0gZnVuY3Rpb24gKGZpcnN0LCBzZWNvbmQsIHJlc3VsdCkge1xuICAvLz4+aW5jbHVkZVN0YXJ0KCdkZWJ1ZycsIHByYWdtYXMuZGVidWcpO1xuICBDaGVjay50eXBlT2Yub2JqZWN0KFwiZmlyc3RcIiwgZmlyc3QpO1xuICBDaGVjay50eXBlT2Yub2JqZWN0KFwic2Vjb25kXCIsIHNlY29uZCk7XG4gIENoZWNrLnR5cGVPZi5vYmplY3QoXCJyZXN1bHRcIiwgcmVzdWx0KTtcbiAgLy8+PmluY2x1ZGVFbmQoJ2RlYnVnJyk7XG5cbiAgcmVzdWx0LnggPSBNYXRoLm1heChmaXJzdC54LCBzZWNvbmQueCk7XG4gIHJlc3VsdC55ID0gTWF0aC5tYXgoZmlyc3QueSwgc2Vjb25kLnkpO1xuICByZXN1bHQueiA9IE1hdGgubWF4KGZpcnN0LnosIHNlY29uZC56KTtcbiAgcmVzdWx0LncgPSBNYXRoLm1heChmaXJzdC53LCBzZWNvbmQudyk7XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbi8qKlxuICogQ29tcHV0ZXMgdGhlIHByb3ZpZGVkIENhcnRlc2lhbidzIHNxdWFyZWQgbWFnbml0dWRlLlxuICpcbiAqIEBwYXJhbSB7Q2FydGVzaWFuNH0gY2FydGVzaWFuIFRoZSBDYXJ0ZXNpYW4gaW5zdGFuY2Ugd2hvc2Ugc3F1YXJlZCBtYWduaXR1ZGUgaXMgdG8gYmUgY29tcHV0ZWQuXG4gKiBAcmV0dXJucyB7TnVtYmVyfSBUaGUgc3F1YXJlZCBtYWduaXR1ZGUuXG4gKi9cbkNhcnRlc2lhbjQubWFnbml0dWRlU3F1YXJlZCA9IGZ1bmN0aW9uIChjYXJ0ZXNpYW4pIHtcbiAgLy8+PmluY2x1ZGVTdGFydCgnZGVidWcnLCBwcmFnbWFzLmRlYnVnKTtcbiAgQ2hlY2sudHlwZU9mLm9iamVjdChcImNhcnRlc2lhblwiLCBjYXJ0ZXNpYW4pO1xuICAvLz4+aW5jbHVkZUVuZCgnZGVidWcnKTtcblxuICByZXR1cm4gKFxuICAgIGNhcnRlc2lhbi54ICogY2FydGVzaWFuLnggK1xuICAgIGNhcnRlc2lhbi55ICogY2FydGVzaWFuLnkgK1xuICAgIGNhcnRlc2lhbi56ICogY2FydGVzaWFuLnogK1xuICAgIGNhcnRlc2lhbi53ICogY2FydGVzaWFuLndcbiAgKTtcbn07XG5cbi8qKlxuICogQ29tcHV0ZXMgdGhlIENhcnRlc2lhbidzIG1hZ25pdHVkZSAobGVuZ3RoKS5cbiAqXG4gKiBAcGFyYW0ge0NhcnRlc2lhbjR9IGNhcnRlc2lhbiBUaGUgQ2FydGVzaWFuIGluc3RhbmNlIHdob3NlIG1hZ25pdHVkZSBpcyB0byBiZSBjb21wdXRlZC5cbiAqIEByZXR1cm5zIHtOdW1iZXJ9IFRoZSBtYWduaXR1ZGUuXG4gKi9cbkNhcnRlc2lhbjQubWFnbml0dWRlID0gZnVuY3Rpb24gKGNhcnRlc2lhbikge1xuICByZXR1cm4gTWF0aC5zcXJ0KENhcnRlc2lhbjQubWFnbml0dWRlU3F1YXJlZChjYXJ0ZXNpYW4pKTtcbn07XG5cbnZhciBkaXN0YW5jZVNjcmF0Y2ggPSBuZXcgQ2FydGVzaWFuNCgpO1xuXG4vKipcbiAqIENvbXB1dGVzIHRoZSA0LXNwYWNlIGRpc3RhbmNlIGJldHdlZW4gdHdvIHBvaW50cy5cbiAqXG4gKiBAcGFyYW0ge0NhcnRlc2lhbjR9IGxlZnQgVGhlIGZpcnN0IHBvaW50IHRvIGNvbXB1dGUgdGhlIGRpc3RhbmNlIGZyb20uXG4gKiBAcGFyYW0ge0NhcnRlc2lhbjR9IHJpZ2h0IFRoZSBzZWNvbmQgcG9pbnQgdG8gY29tcHV0ZSB0aGUgZGlzdGFuY2UgdG8uXG4gKiBAcmV0dXJucyB7TnVtYmVyfSBUaGUgZGlzdGFuY2UgYmV0d2VlbiB0d28gcG9pbnRzLlxuICpcbiAqIEBleGFtcGxlXG4gKiAvLyBSZXR1cm5zIDEuMFxuICogdmFyIGQgPSBDZXNpdW0uQ2FydGVzaWFuNC5kaXN0YW5jZShcbiAqICAgbmV3IENlc2l1bS5DYXJ0ZXNpYW40KDEuMCwgMC4wLCAwLjAsIDAuMCksXG4gKiAgIG5ldyBDZXNpdW0uQ2FydGVzaWFuNCgyLjAsIDAuMCwgMC4wLCAwLjApKTtcbiAqL1xuQ2FydGVzaWFuNC5kaXN0YW5jZSA9IGZ1bmN0aW9uIChsZWZ0LCByaWdodCkge1xuICAvLz4+aW5jbHVkZVN0YXJ0KCdkZWJ1ZycsIHByYWdtYXMuZGVidWcpO1xuICBDaGVjay50eXBlT2Yub2JqZWN0KFwibGVmdFwiLCBsZWZ0KTtcbiAgQ2hlY2sudHlwZU9mLm9iamVjdChcInJpZ2h0XCIsIHJpZ2h0KTtcbiAgLy8+PmluY2x1ZGVFbmQoJ2RlYnVnJyk7XG5cbiAgQ2FydGVzaWFuNC5zdWJ0cmFjdChsZWZ0LCByaWdodCwgZGlzdGFuY2VTY3JhdGNoKTtcbiAgcmV0dXJuIENhcnRlc2lhbjQubWFnbml0dWRlKGRpc3RhbmNlU2NyYXRjaCk7XG59O1xuXG4vKipcbiAqIENvbXB1dGVzIHRoZSBzcXVhcmVkIGRpc3RhbmNlIGJldHdlZW4gdHdvIHBvaW50cy4gIENvbXBhcmluZyBzcXVhcmVkIGRpc3RhbmNlc1xuICogdXNpbmcgdGhpcyBmdW5jdGlvbiBpcyBtb3JlIGVmZmljaWVudCB0aGFuIGNvbXBhcmluZyBkaXN0YW5jZXMgdXNpbmcge0BsaW5rIENhcnRlc2lhbjQjZGlzdGFuY2V9LlxuICpcbiAqIEBwYXJhbSB7Q2FydGVzaWFuNH0gbGVmdCBUaGUgZmlyc3QgcG9pbnQgdG8gY29tcHV0ZSB0aGUgZGlzdGFuY2UgZnJvbS5cbiAqIEBwYXJhbSB7Q2FydGVzaWFuNH0gcmlnaHQgVGhlIHNlY29uZCBwb2ludCB0byBjb21wdXRlIHRoZSBkaXN0YW5jZSB0by5cbiAqIEByZXR1cm5zIHtOdW1iZXJ9IFRoZSBkaXN0YW5jZSBiZXR3ZWVuIHR3byBwb2ludHMuXG4gKlxuICogQGV4YW1wbGVcbiAqIC8vIFJldHVybnMgNC4wLCBub3QgMi4wXG4gKiB2YXIgZCA9IENlc2l1bS5DYXJ0ZXNpYW40LmRpc3RhbmNlKFxuICogICBuZXcgQ2VzaXVtLkNhcnRlc2lhbjQoMS4wLCAwLjAsIDAuMCwgMC4wKSxcbiAqICAgbmV3IENlc2l1bS5DYXJ0ZXNpYW40KDMuMCwgMC4wLCAwLjAsIDAuMCkpO1xuICovXG5DYXJ0ZXNpYW40LmRpc3RhbmNlU3F1YXJlZCA9IGZ1bmN0aW9uIChsZWZ0LCByaWdodCkge1xuICAvLz4+aW5jbHVkZVN0YXJ0KCdkZWJ1ZycsIHByYWdtYXMuZGVidWcpO1xuICBDaGVjay50eXBlT2Yub2JqZWN0KFwibGVmdFwiLCBsZWZ0KTtcbiAgQ2hlY2sudHlwZU9mLm9iamVjdChcInJpZ2h0XCIsIHJpZ2h0KTtcbiAgLy8+PmluY2x1ZGVFbmQoJ2RlYnVnJyk7XG5cbiAgQ2FydGVzaWFuNC5zdWJ0cmFjdChsZWZ0LCByaWdodCwgZGlzdGFuY2VTY3JhdGNoKTtcbiAgcmV0dXJuIENhcnRlc2lhbjQubWFnbml0dWRlU3F1YXJlZChkaXN0YW5jZVNjcmF0Y2gpO1xufTtcblxuLyoqXG4gKiBDb21wdXRlcyB0aGUgbm9ybWFsaXplZCBmb3JtIG9mIHRoZSBzdXBwbGllZCBDYXJ0ZXNpYW4uXG4gKlxuICogQHBhcmFtIHtDYXJ0ZXNpYW40fSBjYXJ0ZXNpYW4gVGhlIENhcnRlc2lhbiB0byBiZSBub3JtYWxpemVkLlxuICogQHBhcmFtIHtDYXJ0ZXNpYW40fSByZXN1bHQgVGhlIG9iamVjdCBvbnRvIHdoaWNoIHRvIHN0b3JlIHRoZSByZXN1bHQuXG4gKiBAcmV0dXJucyB7Q2FydGVzaWFuNH0gVGhlIG1vZGlmaWVkIHJlc3VsdCBwYXJhbWV0ZXIuXG4gKi9cbkNhcnRlc2lhbjQubm9ybWFsaXplID0gZnVuY3Rpb24gKGNhcnRlc2lhbiwgcmVzdWx0KSB7XG4gIC8vPj5pbmNsdWRlU3RhcnQoJ2RlYnVnJywgcHJhZ21hcy5kZWJ1Zyk7XG4gIENoZWNrLnR5cGVPZi5vYmplY3QoXCJjYXJ0ZXNpYW5cIiwgY2FydGVzaWFuKTtcbiAgQ2hlY2sudHlwZU9mLm9iamVjdChcInJlc3VsdFwiLCByZXN1bHQpO1xuICAvLz4+aW5jbHVkZUVuZCgnZGVidWcnKTtcblxuICB2YXIgbWFnbml0dWRlID0gQ2FydGVzaWFuNC5tYWduaXR1ZGUoY2FydGVzaWFuKTtcblxuICByZXN1bHQueCA9IGNhcnRlc2lhbi54IC8gbWFnbml0dWRlO1xuICByZXN1bHQueSA9IGNhcnRlc2lhbi55IC8gbWFnbml0dWRlO1xuICByZXN1bHQueiA9IGNhcnRlc2lhbi56IC8gbWFnbml0dWRlO1xuICByZXN1bHQudyA9IGNhcnRlc2lhbi53IC8gbWFnbml0dWRlO1xuXG4gIC8vPj5pbmNsdWRlU3RhcnQoJ2RlYnVnJywgcHJhZ21hcy5kZWJ1Zyk7XG4gIGlmIChcbiAgICBpc05hTihyZXN1bHQueCkgfHxcbiAgICBpc05hTihyZXN1bHQueSkgfHxcbiAgICBpc05hTihyZXN1bHQueikgfHxcbiAgICBpc05hTihyZXN1bHQudylcbiAgKSB7XG4gICAgdGhyb3cgbmV3IERldmVsb3BlckVycm9yKFwibm9ybWFsaXplZCByZXN1bHQgaXMgbm90IGEgbnVtYmVyXCIpO1xuICB9XG4gIC8vPj5pbmNsdWRlRW5kKCdkZWJ1ZycpO1xuXG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG4vKipcbiAqIENvbXB1dGVzIHRoZSBkb3QgKHNjYWxhcikgcHJvZHVjdCBvZiB0d28gQ2FydGVzaWFucy5cbiAqXG4gKiBAcGFyYW0ge0NhcnRlc2lhbjR9IGxlZnQgVGhlIGZpcnN0IENhcnRlc2lhbi5cbiAqIEBwYXJhbSB7Q2FydGVzaWFuNH0gcmlnaHQgVGhlIHNlY29uZCBDYXJ0ZXNpYW4uXG4gKiBAcmV0dXJucyB7TnVtYmVyfSBUaGUgZG90IHByb2R1Y3QuXG4gKi9cbkNhcnRlc2lhbjQuZG90ID0gZnVuY3Rpb24gKGxlZnQsIHJpZ2h0KSB7XG4gIC8vPj5pbmNsdWRlU3RhcnQoJ2RlYnVnJywgcHJhZ21hcy5kZWJ1Zyk7XG4gIENoZWNrLnR5cGVPZi5vYmplY3QoXCJsZWZ0XCIsIGxlZnQpO1xuICBDaGVjay50eXBlT2Yub2JqZWN0KFwicmlnaHRcIiwgcmlnaHQpO1xuICAvLz4+aW5jbHVkZUVuZCgnZGVidWcnKTtcblxuICByZXR1cm4gKFxuICAgIGxlZnQueCAqIHJpZ2h0LnggKyBsZWZ0LnkgKiByaWdodC55ICsgbGVmdC56ICogcmlnaHQueiArIGxlZnQudyAqIHJpZ2h0LndcbiAgKTtcbn07XG5cbi8qKlxuICogQ29tcHV0ZXMgdGhlIGNvbXBvbmVudHdpc2UgcHJvZHVjdCBvZiB0d28gQ2FydGVzaWFucy5cbiAqXG4gKiBAcGFyYW0ge0NhcnRlc2lhbjR9IGxlZnQgVGhlIGZpcnN0IENhcnRlc2lhbi5cbiAqIEBwYXJhbSB7Q2FydGVzaWFuNH0gcmlnaHQgVGhlIHNlY29uZCBDYXJ0ZXNpYW4uXG4gKiBAcGFyYW0ge0NhcnRlc2lhbjR9IHJlc3VsdCBUaGUgb2JqZWN0IG9udG8gd2hpY2ggdG8gc3RvcmUgdGhlIHJlc3VsdC5cbiAqIEByZXR1cm5zIHtDYXJ0ZXNpYW40fSBUaGUgbW9kaWZpZWQgcmVzdWx0IHBhcmFtZXRlci5cbiAqL1xuQ2FydGVzaWFuNC5tdWx0aXBseUNvbXBvbmVudHMgPSBmdW5jdGlvbiAobGVmdCwgcmlnaHQsIHJlc3VsdCkge1xuICAvLz4+aW5jbHVkZVN0YXJ0KCdkZWJ1ZycsIHByYWdtYXMuZGVidWcpO1xuICBDaGVjay50eXBlT2Yub2JqZWN0KFwibGVmdFwiLCBsZWZ0KTtcbiAgQ2hlY2sudHlwZU9mLm9iamVjdChcInJpZ2h0XCIsIHJpZ2h0KTtcbiAgQ2hlY2sudHlwZU9mLm9iamVjdChcInJlc3VsdFwiLCByZXN1bHQpO1xuICAvLz4+aW5jbHVkZUVuZCgnZGVidWcnKTtcblxuICByZXN1bHQueCA9IGxlZnQueCAqIHJpZ2h0Lng7XG4gIHJlc3VsdC55ID0gbGVmdC55ICogcmlnaHQueTtcbiAgcmVzdWx0LnogPSBsZWZ0LnogKiByaWdodC56O1xuICByZXN1bHQudyA9IGxlZnQudyAqIHJpZ2h0Lnc7XG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG4vKipcbiAqIENvbXB1dGVzIHRoZSBjb21wb25lbnR3aXNlIHF1b3RpZW50IG9mIHR3byBDYXJ0ZXNpYW5zLlxuICpcbiAqIEBwYXJhbSB7Q2FydGVzaWFuNH0gbGVmdCBUaGUgZmlyc3QgQ2FydGVzaWFuLlxuICogQHBhcmFtIHtDYXJ0ZXNpYW40fSByaWdodCBUaGUgc2Vjb25kIENhcnRlc2lhbi5cbiAqIEBwYXJhbSB7Q2FydGVzaWFuNH0gcmVzdWx0IFRoZSBvYmplY3Qgb250byB3aGljaCB0byBzdG9yZSB0aGUgcmVzdWx0LlxuICogQHJldHVybnMge0NhcnRlc2lhbjR9IFRoZSBtb2RpZmllZCByZXN1bHQgcGFyYW1ldGVyLlxuICovXG5DYXJ0ZXNpYW40LmRpdmlkZUNvbXBvbmVudHMgPSBmdW5jdGlvbiAobGVmdCwgcmlnaHQsIHJlc3VsdCkge1xuICAvLz4+aW5jbHVkZVN0YXJ0KCdkZWJ1ZycsIHByYWdtYXMuZGVidWcpO1xuICBDaGVjay50eXBlT2Yub2JqZWN0KFwibGVmdFwiLCBsZWZ0KTtcbiAgQ2hlY2sudHlwZU9mLm9iamVjdChcInJpZ2h0XCIsIHJpZ2h0KTtcbiAgQ2hlY2sudHlwZU9mLm9iamVjdChcInJlc3VsdFwiLCByZXN1bHQpO1xuICAvLz4+aW5jbHVkZUVuZCgnZGVidWcnKTtcblxuICByZXN1bHQueCA9IGxlZnQueCAvIHJpZ2h0Lng7XG4gIHJlc3VsdC55ID0gbGVmdC55IC8gcmlnaHQueTtcbiAgcmVzdWx0LnogPSBsZWZ0LnogLyByaWdodC56O1xuICByZXN1bHQudyA9IGxlZnQudyAvIHJpZ2h0Lnc7XG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG4vKipcbiAqIENvbXB1dGVzIHRoZSBjb21wb25lbnR3aXNlIHN1bSBvZiB0d28gQ2FydGVzaWFucy5cbiAqXG4gKiBAcGFyYW0ge0NhcnRlc2lhbjR9IGxlZnQgVGhlIGZpcnN0IENhcnRlc2lhbi5cbiAqIEBwYXJhbSB7Q2FydGVzaWFuNH0gcmlnaHQgVGhlIHNlY29uZCBDYXJ0ZXNpYW4uXG4gKiBAcGFyYW0ge0NhcnRlc2lhbjR9IHJlc3VsdCBUaGUgb2JqZWN0IG9udG8gd2hpY2ggdG8gc3RvcmUgdGhlIHJlc3VsdC5cbiAqIEByZXR1cm5zIHtDYXJ0ZXNpYW40fSBUaGUgbW9kaWZpZWQgcmVzdWx0IHBhcmFtZXRlci5cbiAqL1xuQ2FydGVzaWFuNC5hZGQgPSBmdW5jdGlvbiAobGVmdCwgcmlnaHQsIHJlc3VsdCkge1xuICAvLz4+aW5jbHVkZVN0YXJ0KCdkZWJ1ZycsIHByYWdtYXMuZGVidWcpO1xuICBDaGVjay50eXBlT2Yub2JqZWN0KFwibGVmdFwiLCBsZWZ0KTtcbiAgQ2hlY2sudHlwZU9mLm9iamVjdChcInJpZ2h0XCIsIHJpZ2h0KTtcbiAgQ2hlY2sudHlwZU9mLm9iamVjdChcInJlc3VsdFwiLCByZXN1bHQpO1xuICAvLz4+aW5jbHVkZUVuZCgnZGVidWcnKTtcblxuICByZXN1bHQueCA9IGxlZnQueCArIHJpZ2h0Lng7XG4gIHJlc3VsdC55ID0gbGVmdC55ICsgcmlnaHQueTtcbiAgcmVzdWx0LnogPSBsZWZ0LnogKyByaWdodC56O1xuICByZXN1bHQudyA9IGxlZnQudyArIHJpZ2h0Lnc7XG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG4vKipcbiAqIENvbXB1dGVzIHRoZSBjb21wb25lbnR3aXNlIGRpZmZlcmVuY2Ugb2YgdHdvIENhcnRlc2lhbnMuXG4gKlxuICogQHBhcmFtIHtDYXJ0ZXNpYW40fSBsZWZ0IFRoZSBmaXJzdCBDYXJ0ZXNpYW4uXG4gKiBAcGFyYW0ge0NhcnRlc2lhbjR9IHJpZ2h0IFRoZSBzZWNvbmQgQ2FydGVzaWFuLlxuICogQHBhcmFtIHtDYXJ0ZXNpYW40fSByZXN1bHQgVGhlIG9iamVjdCBvbnRvIHdoaWNoIHRvIHN0b3JlIHRoZSByZXN1bHQuXG4gKiBAcmV0dXJucyB7Q2FydGVzaWFuNH0gVGhlIG1vZGlmaWVkIHJlc3VsdCBwYXJhbWV0ZXIuXG4gKi9cbkNhcnRlc2lhbjQuc3VidHJhY3QgPSBmdW5jdGlvbiAobGVmdCwgcmlnaHQsIHJlc3VsdCkge1xuICAvLz4+aW5jbHVkZVN0YXJ0KCdkZWJ1ZycsIHByYWdtYXMuZGVidWcpO1xuICBDaGVjay50eXBlT2Yub2JqZWN0KFwibGVmdFwiLCBsZWZ0KTtcbiAgQ2hlY2sudHlwZU9mLm9iamVjdChcInJpZ2h0XCIsIHJpZ2h0KTtcbiAgQ2hlY2sudHlwZU9mLm9iamVjdChcInJlc3VsdFwiLCByZXN1bHQpO1xuICAvLz4+aW5jbHVkZUVuZCgnZGVidWcnKTtcblxuICByZXN1bHQueCA9IGxlZnQueCAtIHJpZ2h0Lng7XG4gIHJlc3VsdC55ID0gbGVmdC55IC0gcmlnaHQueTtcbiAgcmVzdWx0LnogPSBsZWZ0LnogLSByaWdodC56O1xuICByZXN1bHQudyA9IGxlZnQudyAtIHJpZ2h0Lnc7XG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG4vKipcbiAqIE11bHRpcGxpZXMgdGhlIHByb3ZpZGVkIENhcnRlc2lhbiBjb21wb25lbnR3aXNlIGJ5IHRoZSBwcm92aWRlZCBzY2FsYXIuXG4gKlxuICogQHBhcmFtIHtDYXJ0ZXNpYW40fSBjYXJ0ZXNpYW4gVGhlIENhcnRlc2lhbiB0byBiZSBzY2FsZWQuXG4gKiBAcGFyYW0ge051bWJlcn0gc2NhbGFyIFRoZSBzY2FsYXIgdG8gbXVsdGlwbHkgd2l0aC5cbiAqIEBwYXJhbSB7Q2FydGVzaWFuNH0gcmVzdWx0IFRoZSBvYmplY3Qgb250byB3aGljaCB0byBzdG9yZSB0aGUgcmVzdWx0LlxuICogQHJldHVybnMge0NhcnRlc2lhbjR9IFRoZSBtb2RpZmllZCByZXN1bHQgcGFyYW1ldGVyLlxuICovXG5DYXJ0ZXNpYW40Lm11bHRpcGx5QnlTY2FsYXIgPSBmdW5jdGlvbiAoY2FydGVzaWFuLCBzY2FsYXIsIHJlc3VsdCkge1xuICAvLz4+aW5jbHVkZVN0YXJ0KCdkZWJ1ZycsIHByYWdtYXMuZGVidWcpO1xuICBDaGVjay50eXBlT2Yub2JqZWN0KFwiY2FydGVzaWFuXCIsIGNhcnRlc2lhbik7XG4gIENoZWNrLnR5cGVPZi5udW1iZXIoXCJzY2FsYXJcIiwgc2NhbGFyKTtcbiAgQ2hlY2sudHlwZU9mLm9iamVjdChcInJlc3VsdFwiLCByZXN1bHQpO1xuICAvLz4+aW5jbHVkZUVuZCgnZGVidWcnKTtcblxuICByZXN1bHQueCA9IGNhcnRlc2lhbi54ICogc2NhbGFyO1xuICByZXN1bHQueSA9IGNhcnRlc2lhbi55ICogc2NhbGFyO1xuICByZXN1bHQueiA9IGNhcnRlc2lhbi56ICogc2NhbGFyO1xuICByZXN1bHQudyA9IGNhcnRlc2lhbi53ICogc2NhbGFyO1xuICByZXR1cm4gcmVzdWx0O1xufTtcblxuLyoqXG4gKiBEaXZpZGVzIHRoZSBwcm92aWRlZCBDYXJ0ZXNpYW4gY29tcG9uZW50d2lzZSBieSB0aGUgcHJvdmlkZWQgc2NhbGFyLlxuICpcbiAqIEBwYXJhbSB7Q2FydGVzaWFuNH0gY2FydGVzaWFuIFRoZSBDYXJ0ZXNpYW4gdG8gYmUgZGl2aWRlZC5cbiAqIEBwYXJhbSB7TnVtYmVyfSBzY2FsYXIgVGhlIHNjYWxhciB0byBkaXZpZGUgYnkuXG4gKiBAcGFyYW0ge0NhcnRlc2lhbjR9IHJlc3VsdCBUaGUgb2JqZWN0IG9udG8gd2hpY2ggdG8gc3RvcmUgdGhlIHJlc3VsdC5cbiAqIEByZXR1cm5zIHtDYXJ0ZXNpYW40fSBUaGUgbW9kaWZpZWQgcmVzdWx0IHBhcmFtZXRlci5cbiAqL1xuQ2FydGVzaWFuNC5kaXZpZGVCeVNjYWxhciA9IGZ1bmN0aW9uIChjYXJ0ZXNpYW4sIHNjYWxhciwgcmVzdWx0KSB7XG4gIC8vPj5pbmNsdWRlU3RhcnQoJ2RlYnVnJywgcHJhZ21hcy5kZWJ1Zyk7XG4gIENoZWNrLnR5cGVPZi5vYmplY3QoXCJjYXJ0ZXNpYW5cIiwgY2FydGVzaWFuKTtcbiAgQ2hlY2sudHlwZU9mLm51bWJlcihcInNjYWxhclwiLCBzY2FsYXIpO1xuICBDaGVjay50eXBlT2Yub2JqZWN0KFwicmVzdWx0XCIsIHJlc3VsdCk7XG4gIC8vPj5pbmNsdWRlRW5kKCdkZWJ1ZycpO1xuXG4gIHJlc3VsdC54ID0gY2FydGVzaWFuLnggLyBzY2FsYXI7XG4gIHJlc3VsdC55ID0gY2FydGVzaWFuLnkgLyBzY2FsYXI7XG4gIHJlc3VsdC56ID0gY2FydGVzaWFuLnogLyBzY2FsYXI7XG4gIHJlc3VsdC53ID0gY2FydGVzaWFuLncgLyBzY2FsYXI7XG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG4vKipcbiAqIE5lZ2F0ZXMgdGhlIHByb3ZpZGVkIENhcnRlc2lhbi5cbiAqXG4gKiBAcGFyYW0ge0NhcnRlc2lhbjR9IGNhcnRlc2lhbiBUaGUgQ2FydGVzaWFuIHRvIGJlIG5lZ2F0ZWQuXG4gKiBAcGFyYW0ge0NhcnRlc2lhbjR9IHJlc3VsdCBUaGUgb2JqZWN0IG9udG8gd2hpY2ggdG8gc3RvcmUgdGhlIHJlc3VsdC5cbiAqIEByZXR1cm5zIHtDYXJ0ZXNpYW40fSBUaGUgbW9kaWZpZWQgcmVzdWx0IHBhcmFtZXRlci5cbiAqL1xuQ2FydGVzaWFuNC5uZWdhdGUgPSBmdW5jdGlvbiAoY2FydGVzaWFuLCByZXN1bHQpIHtcbiAgLy8+PmluY2x1ZGVTdGFydCgnZGVidWcnLCBwcmFnbWFzLmRlYnVnKTtcbiAgQ2hlY2sudHlwZU9mLm9iamVjdChcImNhcnRlc2lhblwiLCBjYXJ0ZXNpYW4pO1xuICBDaGVjay50eXBlT2Yub2JqZWN0KFwicmVzdWx0XCIsIHJlc3VsdCk7XG4gIC8vPj5pbmNsdWRlRW5kKCdkZWJ1ZycpO1xuXG4gIHJlc3VsdC54ID0gLWNhcnRlc2lhbi54O1xuICByZXN1bHQueSA9IC1jYXJ0ZXNpYW4ueTtcbiAgcmVzdWx0LnogPSAtY2FydGVzaWFuLno7XG4gIHJlc3VsdC53ID0gLWNhcnRlc2lhbi53O1xuICByZXR1cm4gcmVzdWx0O1xufTtcblxuLyoqXG4gKiBDb21wdXRlcyB0aGUgYWJzb2x1dGUgdmFsdWUgb2YgdGhlIHByb3ZpZGVkIENhcnRlc2lhbi5cbiAqXG4gKiBAcGFyYW0ge0NhcnRlc2lhbjR9IGNhcnRlc2lhbiBUaGUgQ2FydGVzaWFuIHdob3NlIGFic29sdXRlIHZhbHVlIGlzIHRvIGJlIGNvbXB1dGVkLlxuICogQHBhcmFtIHtDYXJ0ZXNpYW40fSByZXN1bHQgVGhlIG9iamVjdCBvbnRvIHdoaWNoIHRvIHN0b3JlIHRoZSByZXN1bHQuXG4gKiBAcmV0dXJucyB7Q2FydGVzaWFuNH0gVGhlIG1vZGlmaWVkIHJlc3VsdCBwYXJhbWV0ZXIuXG4gKi9cbkNhcnRlc2lhbjQuYWJzID0gZnVuY3Rpb24gKGNhcnRlc2lhbiwgcmVzdWx0KSB7XG4gIC8vPj5pbmNsdWRlU3RhcnQoJ2RlYnVnJywgcHJhZ21hcy5kZWJ1Zyk7XG4gIENoZWNrLnR5cGVPZi5vYmplY3QoXCJjYXJ0ZXNpYW5cIiwgY2FydGVzaWFuKTtcbiAgQ2hlY2sudHlwZU9mLm9iamVjdChcInJlc3VsdFwiLCByZXN1bHQpO1xuICAvLz4+aW5jbHVkZUVuZCgnZGVidWcnKTtcblxuICByZXN1bHQueCA9IE1hdGguYWJzKGNhcnRlc2lhbi54KTtcbiAgcmVzdWx0LnkgPSBNYXRoLmFicyhjYXJ0ZXNpYW4ueSk7XG4gIHJlc3VsdC56ID0gTWF0aC5hYnMoY2FydGVzaWFuLnopO1xuICByZXN1bHQudyA9IE1hdGguYWJzKGNhcnRlc2lhbi53KTtcbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbnZhciBsZXJwU2NyYXRjaCA9IG5ldyBDYXJ0ZXNpYW40KCk7XG4vKipcbiAqIENvbXB1dGVzIHRoZSBsaW5lYXIgaW50ZXJwb2xhdGlvbiBvciBleHRyYXBvbGF0aW9uIGF0IHQgdXNpbmcgdGhlIHByb3ZpZGVkIGNhcnRlc2lhbnMuXG4gKlxuICogQHBhcmFtIHtDYXJ0ZXNpYW40fSBzdGFydCBUaGUgdmFsdWUgY29ycmVzcG9uZGluZyB0byB0IGF0IDAuMC5cbiAqIEBwYXJhbSB7Q2FydGVzaWFuNH1lbmQgVGhlIHZhbHVlIGNvcnJlc3BvbmRpbmcgdG8gdCBhdCAxLjAuXG4gKiBAcGFyYW0ge051bWJlcn0gdCBUaGUgcG9pbnQgYWxvbmcgdCBhdCB3aGljaCB0byBpbnRlcnBvbGF0ZS5cbiAqIEBwYXJhbSB7Q2FydGVzaWFuNH0gcmVzdWx0IFRoZSBvYmplY3Qgb250byB3aGljaCB0byBzdG9yZSB0aGUgcmVzdWx0LlxuICogQHJldHVybnMge0NhcnRlc2lhbjR9IFRoZSBtb2RpZmllZCByZXN1bHQgcGFyYW1ldGVyLlxuICovXG5DYXJ0ZXNpYW40LmxlcnAgPSBmdW5jdGlvbiAoc3RhcnQsIGVuZCwgdCwgcmVzdWx0KSB7XG4gIC8vPj5pbmNsdWRlU3RhcnQoJ2RlYnVnJywgcHJhZ21hcy5kZWJ1Zyk7XG4gIENoZWNrLnR5cGVPZi5vYmplY3QoXCJzdGFydFwiLCBzdGFydCk7XG4gIENoZWNrLnR5cGVPZi5vYmplY3QoXCJlbmRcIiwgZW5kKTtcbiAgQ2hlY2sudHlwZU9mLm51bWJlcihcInRcIiwgdCk7XG4gIENoZWNrLnR5cGVPZi5vYmplY3QoXCJyZXN1bHRcIiwgcmVzdWx0KTtcbiAgLy8+PmluY2x1ZGVFbmQoJ2RlYnVnJyk7XG5cbiAgQ2FydGVzaWFuNC5tdWx0aXBseUJ5U2NhbGFyKGVuZCwgdCwgbGVycFNjcmF0Y2gpO1xuICByZXN1bHQgPSBDYXJ0ZXNpYW40Lm11bHRpcGx5QnlTY2FsYXIoc3RhcnQsIDEuMCAtIHQsIHJlc3VsdCk7XG4gIHJldHVybiBDYXJ0ZXNpYW40LmFkZChsZXJwU2NyYXRjaCwgcmVzdWx0LCByZXN1bHQpO1xufTtcblxudmFyIG1vc3RPcnRob2dvbmFsQXhpc1NjcmF0Y2ggPSBuZXcgQ2FydGVzaWFuNCgpO1xuLyoqXG4gKiBSZXR1cm5zIHRoZSBheGlzIHRoYXQgaXMgbW9zdCBvcnRob2dvbmFsIHRvIHRoZSBwcm92aWRlZCBDYXJ0ZXNpYW4uXG4gKlxuICogQHBhcmFtIHtDYXJ0ZXNpYW40fSBjYXJ0ZXNpYW4gVGhlIENhcnRlc2lhbiBvbiB3aGljaCB0byBmaW5kIHRoZSBtb3N0IG9ydGhvZ29uYWwgYXhpcy5cbiAqIEBwYXJhbSB7Q2FydGVzaWFuNH0gcmVzdWx0IFRoZSBvYmplY3Qgb250byB3aGljaCB0byBzdG9yZSB0aGUgcmVzdWx0LlxuICogQHJldHVybnMge0NhcnRlc2lhbjR9IFRoZSBtb3N0IG9ydGhvZ29uYWwgYXhpcy5cbiAqL1xuQ2FydGVzaWFuNC5tb3N0T3J0aG9nb25hbEF4aXMgPSBmdW5jdGlvbiAoY2FydGVzaWFuLCByZXN1bHQpIHtcbiAgLy8+PmluY2x1ZGVTdGFydCgnZGVidWcnLCBwcmFnbWFzLmRlYnVnKTtcbiAgQ2hlY2sudHlwZU9mLm9iamVjdChcImNhcnRlc2lhblwiLCBjYXJ0ZXNpYW4pO1xuICBDaGVjay50eXBlT2Yub2JqZWN0KFwicmVzdWx0XCIsIHJlc3VsdCk7XG4gIC8vPj5pbmNsdWRlRW5kKCdkZWJ1ZycpO1xuXG4gIHZhciBmID0gQ2FydGVzaWFuNC5ub3JtYWxpemUoY2FydGVzaWFuLCBtb3N0T3J0aG9nb25hbEF4aXNTY3JhdGNoKTtcbiAgQ2FydGVzaWFuNC5hYnMoZiwgZik7XG5cbiAgaWYgKGYueCA8PSBmLnkpIHtcbiAgICBpZiAoZi54IDw9IGYueikge1xuICAgICAgaWYgKGYueCA8PSBmLncpIHtcbiAgICAgICAgcmVzdWx0ID0gQ2FydGVzaWFuNC5jbG9uZShDYXJ0ZXNpYW40LlVOSVRfWCwgcmVzdWx0KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlc3VsdCA9IENhcnRlc2lhbjQuY2xvbmUoQ2FydGVzaWFuNC5VTklUX1csIHJlc3VsdCk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChmLnogPD0gZi53KSB7XG4gICAgICByZXN1bHQgPSBDYXJ0ZXNpYW40LmNsb25lKENhcnRlc2lhbjQuVU5JVF9aLCByZXN1bHQpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXN1bHQgPSBDYXJ0ZXNpYW40LmNsb25lKENhcnRlc2lhbjQuVU5JVF9XLCByZXN1bHQpO1xuICAgIH1cbiAgfSBlbHNlIGlmIChmLnkgPD0gZi56KSB7XG4gICAgaWYgKGYueSA8PSBmLncpIHtcbiAgICAgIHJlc3VsdCA9IENhcnRlc2lhbjQuY2xvbmUoQ2FydGVzaWFuNC5VTklUX1ksIHJlc3VsdCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlc3VsdCA9IENhcnRlc2lhbjQuY2xvbmUoQ2FydGVzaWFuNC5VTklUX1csIHJlc3VsdCk7XG4gICAgfVxuICB9IGVsc2UgaWYgKGYueiA8PSBmLncpIHtcbiAgICByZXN1bHQgPSBDYXJ0ZXNpYW40LmNsb25lKENhcnRlc2lhbjQuVU5JVF9aLCByZXN1bHQpO1xuICB9IGVsc2Uge1xuICAgIHJlc3VsdCA9IENhcnRlc2lhbjQuY2xvbmUoQ2FydGVzaWFuNC5VTklUX1csIHJlc3VsdCk7XG4gIH1cblxuICByZXR1cm4gcmVzdWx0O1xufTtcblxuLyoqXG4gKiBDb21wYXJlcyB0aGUgcHJvdmlkZWQgQ2FydGVzaWFucyBjb21wb25lbnR3aXNlIGFuZCByZXR1cm5zXG4gKiA8Y29kZT50cnVlPC9jb2RlPiBpZiB0aGV5IGFyZSBlcXVhbCwgPGNvZGU+ZmFsc2U8L2NvZGU+IG90aGVyd2lzZS5cbiAqXG4gKiBAcGFyYW0ge0NhcnRlc2lhbjR9IFtsZWZ0XSBUaGUgZmlyc3QgQ2FydGVzaWFuLlxuICogQHBhcmFtIHtDYXJ0ZXNpYW40fSBbcmlnaHRdIFRoZSBzZWNvbmQgQ2FydGVzaWFuLlxuICogQHJldHVybnMge0Jvb2xlYW59IDxjb2RlPnRydWU8L2NvZGU+IGlmIGxlZnQgYW5kIHJpZ2h0IGFyZSBlcXVhbCwgPGNvZGU+ZmFsc2U8L2NvZGU+IG90aGVyd2lzZS5cbiAqL1xuQ2FydGVzaWFuNC5lcXVhbHMgPSBmdW5jdGlvbiAobGVmdCwgcmlnaHQpIHtcbiAgcmV0dXJuIChcbiAgICBsZWZ0ID09PSByaWdodCB8fFxuICAgIChkZWZpbmVkKGxlZnQpICYmXG4gICAgICBkZWZpbmVkKHJpZ2h0KSAmJlxuICAgICAgbGVmdC54ID09PSByaWdodC54ICYmXG4gICAgICBsZWZ0LnkgPT09IHJpZ2h0LnkgJiZcbiAgICAgIGxlZnQueiA9PT0gcmlnaHQueiAmJlxuICAgICAgbGVmdC53ID09PSByaWdodC53KVxuICApO1xufTtcblxuLyoqXG4gKiBAcHJpdmF0ZVxuICovXG5DYXJ0ZXNpYW40LmVxdWFsc0FycmF5ID0gZnVuY3Rpb24gKGNhcnRlc2lhbiwgYXJyYXksIG9mZnNldCkge1xuICByZXR1cm4gKFxuICAgIGNhcnRlc2lhbi54ID09PSBhcnJheVtvZmZzZXRdICYmXG4gICAgY2FydGVzaWFuLnkgPT09IGFycmF5W29mZnNldCArIDFdICYmXG4gICAgY2FydGVzaWFuLnogPT09IGFycmF5W29mZnNldCArIDJdICYmXG4gICAgY2FydGVzaWFuLncgPT09IGFycmF5W29mZnNldCArIDNdXG4gICk7XG59O1xuXG4vKipcbiAqIENvbXBhcmVzIHRoZSBwcm92aWRlZCBDYXJ0ZXNpYW5zIGNvbXBvbmVudHdpc2UgYW5kIHJldHVybnNcbiAqIDxjb2RlPnRydWU8L2NvZGU+IGlmIHRoZXkgcGFzcyBhbiBhYnNvbHV0ZSBvciByZWxhdGl2ZSB0b2xlcmFuY2UgdGVzdCxcbiAqIDxjb2RlPmZhbHNlPC9jb2RlPiBvdGhlcndpc2UuXG4gKlxuICogQHBhcmFtIHtDYXJ0ZXNpYW40fSBbbGVmdF0gVGhlIGZpcnN0IENhcnRlc2lhbi5cbiAqIEBwYXJhbSB7Q2FydGVzaWFuNH0gW3JpZ2h0XSBUaGUgc2Vjb25kIENhcnRlc2lhbi5cbiAqIEBwYXJhbSB7TnVtYmVyfSBbcmVsYXRpdmVFcHNpbG9uPTBdIFRoZSByZWxhdGl2ZSBlcHNpbG9uIHRvbGVyYW5jZSB0byB1c2UgZm9yIGVxdWFsaXR5IHRlc3RpbmcuXG4gKiBAcGFyYW0ge051bWJlcn0gW2Fic29sdXRlRXBzaWxvbj1yZWxhdGl2ZUVwc2lsb25dIFRoZSBhYnNvbHV0ZSBlcHNpbG9uIHRvbGVyYW5jZSB0byB1c2UgZm9yIGVxdWFsaXR5IHRlc3RpbmcuXG4gKiBAcmV0dXJucyB7Qm9vbGVhbn0gPGNvZGU+dHJ1ZTwvY29kZT4gaWYgbGVmdCBhbmQgcmlnaHQgYXJlIHdpdGhpbiB0aGUgcHJvdmlkZWQgZXBzaWxvbiwgPGNvZGU+ZmFsc2U8L2NvZGU+IG90aGVyd2lzZS5cbiAqL1xuQ2FydGVzaWFuNC5lcXVhbHNFcHNpbG9uID0gZnVuY3Rpb24gKFxuICBsZWZ0LFxuICByaWdodCxcbiAgcmVsYXRpdmVFcHNpbG9uLFxuICBhYnNvbHV0ZUVwc2lsb25cbikge1xuICByZXR1cm4gKFxuICAgIGxlZnQgPT09IHJpZ2h0IHx8XG4gICAgKGRlZmluZWQobGVmdCkgJiZcbiAgICAgIGRlZmluZWQocmlnaHQpICYmXG4gICAgICBDZXNpdW1NYXRoLmVxdWFsc0Vwc2lsb24oXG4gICAgICAgIGxlZnQueCxcbiAgICAgICAgcmlnaHQueCxcbiAgICAgICAgcmVsYXRpdmVFcHNpbG9uLFxuICAgICAgICBhYnNvbHV0ZUVwc2lsb25cbiAgICAgICkgJiZcbiAgICAgIENlc2l1bU1hdGguZXF1YWxzRXBzaWxvbihcbiAgICAgICAgbGVmdC55LFxuICAgICAgICByaWdodC55LFxuICAgICAgICByZWxhdGl2ZUVwc2lsb24sXG4gICAgICAgIGFic29sdXRlRXBzaWxvblxuICAgICAgKSAmJlxuICAgICAgQ2VzaXVtTWF0aC5lcXVhbHNFcHNpbG9uKFxuICAgICAgICBsZWZ0LnosXG4gICAgICAgIHJpZ2h0LnosXG4gICAgICAgIHJlbGF0aXZlRXBzaWxvbixcbiAgICAgICAgYWJzb2x1dGVFcHNpbG9uXG4gICAgICApICYmXG4gICAgICBDZXNpdW1NYXRoLmVxdWFsc0Vwc2lsb24oXG4gICAgICAgIGxlZnQudyxcbiAgICAgICAgcmlnaHQudyxcbiAgICAgICAgcmVsYXRpdmVFcHNpbG9uLFxuICAgICAgICBhYnNvbHV0ZUVwc2lsb25cbiAgICAgICkpXG4gICk7XG59O1xuXG4vKipcbiAqIEFuIGltbXV0YWJsZSBDYXJ0ZXNpYW40IGluc3RhbmNlIGluaXRpYWxpemVkIHRvICgwLjAsIDAuMCwgMC4wLCAwLjApLlxuICpcbiAqIEB0eXBlIHtDYXJ0ZXNpYW40fVxuICogQGNvbnN0YW50XG4gKi9cbkNhcnRlc2lhbjQuWkVSTyA9IE9iamVjdC5mcmVlemUobmV3IENhcnRlc2lhbjQoMC4wLCAwLjAsIDAuMCwgMC4wKSk7XG5cbi8qKlxuICogQW4gaW1tdXRhYmxlIENhcnRlc2lhbjQgaW5zdGFuY2UgaW5pdGlhbGl6ZWQgdG8gKDEuMCwgMS4wLCAxLjAsIDEuMCkuXG4gKlxuICogQHR5cGUge0NhcnRlc2lhbjR9XG4gKiBAY29uc3RhbnRcbiAqL1xuQ2FydGVzaWFuNC5PTkUgPSBPYmplY3QuZnJlZXplKG5ldyBDYXJ0ZXNpYW40KDEuMCwgMS4wLCAxLjAsIDEuMCkpO1xuXG4vKipcbiAqIEFuIGltbXV0YWJsZSBDYXJ0ZXNpYW40IGluc3RhbmNlIGluaXRpYWxpemVkIHRvICgxLjAsIDAuMCwgMC4wLCAwLjApLlxuICpcbiAqIEB0eXBlIHtDYXJ0ZXNpYW40fVxuICogQGNvbnN0YW50XG4gKi9cbkNhcnRlc2lhbjQuVU5JVF9YID0gT2JqZWN0LmZyZWV6ZShuZXcgQ2FydGVzaWFuNCgxLjAsIDAuMCwgMC4wLCAwLjApKTtcblxuLyoqXG4gKiBBbiBpbW11dGFibGUgQ2FydGVzaWFuNCBpbnN0YW5jZSBpbml0aWFsaXplZCB0byAoMC4wLCAxLjAsIDAuMCwgMC4wKS5cbiAqXG4gKiBAdHlwZSB7Q2FydGVzaWFuNH1cbiAqIEBjb25zdGFudFxuICovXG5DYXJ0ZXNpYW40LlVOSVRfWSA9IE9iamVjdC5mcmVlemUobmV3IENhcnRlc2lhbjQoMC4wLCAxLjAsIDAuMCwgMC4wKSk7XG5cbi8qKlxuICogQW4gaW1tdXRhYmxlIENhcnRlc2lhbjQgaW5zdGFuY2UgaW5pdGlhbGl6ZWQgdG8gKDAuMCwgMC4wLCAxLjAsIDAuMCkuXG4gKlxuICogQHR5cGUge0NhcnRlc2lhbjR9XG4gKiBAY29uc3RhbnRcbiAqL1xuQ2FydGVzaWFuNC5VTklUX1ogPSBPYmplY3QuZnJlZXplKG5ldyBDYXJ0ZXNpYW40KDAuMCwgMC4wLCAxLjAsIDAuMCkpO1xuXG4vKipcbiAqIEFuIGltbXV0YWJsZSBDYXJ0ZXNpYW40IGluc3RhbmNlIGluaXRpYWxpemVkIHRvICgwLjAsIDAuMCwgMC4wLCAxLjApLlxuICpcbiAqIEB0eXBlIHtDYXJ0ZXNpYW40fVxuICogQGNvbnN0YW50XG4gKi9cbkNhcnRlc2lhbjQuVU5JVF9XID0gT2JqZWN0LmZyZWV6ZShuZXcgQ2FydGVzaWFuNCgwLjAsIDAuMCwgMC4wLCAxLjApKTtcblxuLyoqXG4gKiBEdXBsaWNhdGVzIHRoaXMgQ2FydGVzaWFuNCBpbnN0YW5jZS5cbiAqXG4gKiBAcGFyYW0ge0NhcnRlc2lhbjR9IFtyZXN1bHRdIFRoZSBvYmplY3Qgb250byB3aGljaCB0byBzdG9yZSB0aGUgcmVzdWx0LlxuICogQHJldHVybnMge0NhcnRlc2lhbjR9IFRoZSBtb2RpZmllZCByZXN1bHQgcGFyYW1ldGVyIG9yIGEgbmV3IENhcnRlc2lhbjQgaW5zdGFuY2UgaWYgb25lIHdhcyBub3QgcHJvdmlkZWQuXG4gKi9cbkNhcnRlc2lhbjQucHJvdG90eXBlLmNsb25lID0gZnVuY3Rpb24gKHJlc3VsdCkge1xuICByZXR1cm4gQ2FydGVzaWFuNC5jbG9uZSh0aGlzLCByZXN1bHQpO1xufTtcblxuLyoqXG4gKiBDb21wYXJlcyB0aGlzIENhcnRlc2lhbiBhZ2FpbnN0IHRoZSBwcm92aWRlZCBDYXJ0ZXNpYW4gY29tcG9uZW50d2lzZSBhbmQgcmV0dXJuc1xuICogPGNvZGU+dHJ1ZTwvY29kZT4gaWYgdGhleSBhcmUgZXF1YWwsIDxjb2RlPmZhbHNlPC9jb2RlPiBvdGhlcndpc2UuXG4gKlxuICogQHBhcmFtIHtDYXJ0ZXNpYW40fSBbcmlnaHRdIFRoZSByaWdodCBoYW5kIHNpZGUgQ2FydGVzaWFuLlxuICogQHJldHVybnMge0Jvb2xlYW59IDxjb2RlPnRydWU8L2NvZGU+IGlmIHRoZXkgYXJlIGVxdWFsLCA8Y29kZT5mYWxzZTwvY29kZT4gb3RoZXJ3aXNlLlxuICovXG5DYXJ0ZXNpYW40LnByb3RvdHlwZS5lcXVhbHMgPSBmdW5jdGlvbiAocmlnaHQpIHtcbiAgcmV0dXJuIENhcnRlc2lhbjQuZXF1YWxzKHRoaXMsIHJpZ2h0KTtcbn07XG5cbi8qKlxuICogQ29tcGFyZXMgdGhpcyBDYXJ0ZXNpYW4gYWdhaW5zdCB0aGUgcHJvdmlkZWQgQ2FydGVzaWFuIGNvbXBvbmVudHdpc2UgYW5kIHJldHVybnNcbiAqIDxjb2RlPnRydWU8L2NvZGU+IGlmIHRoZXkgcGFzcyBhbiBhYnNvbHV0ZSBvciByZWxhdGl2ZSB0b2xlcmFuY2UgdGVzdCxcbiAqIDxjb2RlPmZhbHNlPC9jb2RlPiBvdGhlcndpc2UuXG4gKlxuICogQHBhcmFtIHtDYXJ0ZXNpYW40fSBbcmlnaHRdIFRoZSByaWdodCBoYW5kIHNpZGUgQ2FydGVzaWFuLlxuICogQHBhcmFtIHtOdW1iZXJ9IFtyZWxhdGl2ZUVwc2lsb249MF0gVGhlIHJlbGF0aXZlIGVwc2lsb24gdG9sZXJhbmNlIHRvIHVzZSBmb3IgZXF1YWxpdHkgdGVzdGluZy5cbiAqIEBwYXJhbSB7TnVtYmVyfSBbYWJzb2x1dGVFcHNpbG9uPXJlbGF0aXZlRXBzaWxvbl0gVGhlIGFic29sdXRlIGVwc2lsb24gdG9sZXJhbmNlIHRvIHVzZSBmb3IgZXF1YWxpdHkgdGVzdGluZy5cbiAqIEByZXR1cm5zIHtCb29sZWFufSA8Y29kZT50cnVlPC9jb2RlPiBpZiB0aGV5IGFyZSB3aXRoaW4gdGhlIHByb3ZpZGVkIGVwc2lsb24sIDxjb2RlPmZhbHNlPC9jb2RlPiBvdGhlcndpc2UuXG4gKi9cbkNhcnRlc2lhbjQucHJvdG90eXBlLmVxdWFsc0Vwc2lsb24gPSBmdW5jdGlvbiAoXG4gIHJpZ2h0LFxuICByZWxhdGl2ZUVwc2lsb24sXG4gIGFic29sdXRlRXBzaWxvblxuKSB7XG4gIHJldHVybiBDYXJ0ZXNpYW40LmVxdWFsc0Vwc2lsb24oXG4gICAgdGhpcyxcbiAgICByaWdodCxcbiAgICByZWxhdGl2ZUVwc2lsb24sXG4gICAgYWJzb2x1dGVFcHNpbG9uXG4gICk7XG59O1xuXG4vKipcbiAqIENyZWF0ZXMgYSBzdHJpbmcgcmVwcmVzZW50aW5nIHRoaXMgQ2FydGVzaWFuIGluIHRoZSBmb3JtYXQgJyh4LCB5LCB6LCB3KScuXG4gKlxuICogQHJldHVybnMge1N0cmluZ30gQSBzdHJpbmcgcmVwcmVzZW50aW5nIHRoZSBwcm92aWRlZCBDYXJ0ZXNpYW4gaW4gdGhlIGZvcm1hdCAnKHgsIHksIHosIHcpJy5cbiAqL1xuQ2FydGVzaWFuNC5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiBcIihcIiArIHRoaXMueCArIFwiLCBcIiArIHRoaXMueSArIFwiLCBcIiArIHRoaXMueiArIFwiLCBcIiArIHRoaXMudyArIFwiKVwiO1xufTtcblxuLy8gc2NyYXRjaFU4QXJyYXkgYW5kIHNjcmF0Y2hGMzJBcnJheSBhcmUgdmlld3MgaW50byB0aGUgc2FtZSBidWZmZXJcbnZhciBzY3JhdGNoRjMyQXJyYXkgPSBuZXcgRmxvYXQzMkFycmF5KDEpO1xudmFyIHNjcmF0Y2hVOEFycmF5ID0gbmV3IFVpbnQ4QXJyYXkoc2NyYXRjaEYzMkFycmF5LmJ1ZmZlcik7XG5cbnZhciB0ZXN0VTMyID0gbmV3IFVpbnQzMkFycmF5KFsweDExMjIzMzQ0XSk7XG52YXIgdGVzdFU4ID0gbmV3IFVpbnQ4QXJyYXkodGVzdFUzMi5idWZmZXIpO1xudmFyIGxpdHRsZUVuZGlhbiA9IHRlc3RVOFswXSA9PT0gMHg0NDtcblxuLyoqXG4gKiBQYWNrcyBhbiBhcmJpdHJhcnkgZmxvYXRpbmcgcG9pbnQgdmFsdWUgdG8gNCB2YWx1ZXMgcmVwcmVzZW50YWJsZSB1c2luZyB1aW50OC5cbiAqXG4gKiBAcGFyYW0ge051bWJlcn0gdmFsdWUgQSBmbG9hdGluZyBwb2ludCBudW1iZXIuXG4gKiBAcGFyYW0ge0NhcnRlc2lhbjR9IFtyZXN1bHRdIFRoZSBDYXJ0ZXNpYW40IHRoYXQgd2lsbCBjb250YWluIHRoZSBwYWNrZWQgZmxvYXQuXG4gKiBAcmV0dXJucyB7Q2FydGVzaWFuNH0gQSBDYXJ0ZXNpYW40IHJlcHJlc2VudGluZyB0aGUgZmxvYXQgcGFja2VkIHRvIHZhbHVlcyBpbiB4LCB5LCB6LCBhbmQgdy5cbiAqL1xuQ2FydGVzaWFuNC5wYWNrRmxvYXQgPSBmdW5jdGlvbiAodmFsdWUsIHJlc3VsdCkge1xuICAvLz4+aW5jbHVkZVN0YXJ0KCdkZWJ1ZycsIHByYWdtYXMuZGVidWcpO1xuICBDaGVjay50eXBlT2YubnVtYmVyKFwidmFsdWVcIiwgdmFsdWUpO1xuICAvLz4+aW5jbHVkZUVuZCgnZGVidWcnKTtcblxuICBpZiAoIWRlZmluZWQocmVzdWx0KSkge1xuICAgIHJlc3VsdCA9IG5ldyBDYXJ0ZXNpYW40KCk7XG4gIH1cblxuICAvLyBzY3JhdGNoVThBcnJheSBhbmQgc2NyYXRjaEYzMkFycmF5IGFyZSB2aWV3cyBpbnRvIHRoZSBzYW1lIGJ1ZmZlclxuICBzY3JhdGNoRjMyQXJyYXlbMF0gPSB2YWx1ZTtcblxuICBpZiAobGl0dGxlRW5kaWFuKSB7XG4gICAgcmVzdWx0LnggPSBzY3JhdGNoVThBcnJheVswXTtcbiAgICByZXN1bHQueSA9IHNjcmF0Y2hVOEFycmF5WzFdO1xuICAgIHJlc3VsdC56ID0gc2NyYXRjaFU4QXJyYXlbMl07XG4gICAgcmVzdWx0LncgPSBzY3JhdGNoVThBcnJheVszXTtcbiAgfSBlbHNlIHtcbiAgICAvLyBjb252ZXJ0IGZyb20gYmlnLWVuZGlhbiB0byBsaXR0bGUtZW5kaWFuXG4gICAgcmVzdWx0LnggPSBzY3JhdGNoVThBcnJheVszXTtcbiAgICByZXN1bHQueSA9IHNjcmF0Y2hVOEFycmF5WzJdO1xuICAgIHJlc3VsdC56ID0gc2NyYXRjaFU4QXJyYXlbMV07XG4gICAgcmVzdWx0LncgPSBzY3JhdGNoVThBcnJheVswXTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufTtcblxuLyoqXG4gKiBVbnBhY2tzIGEgZmxvYXQgcGFja2VkIHVzaW5nIENhcnRlc2lhbjQucGFja0Zsb2F0LlxuICpcbiAqIEBwYXJhbSB7Q2FydGVzaWFuNH0gcGFja2VkRmxvYXQgQSBDYXJ0ZXNpYW40IGNvbnRhaW5pbmcgYSBmbG9hdCBwYWNrZWQgdG8gNCB2YWx1ZXMgcmVwcmVzZW50YWJsZSB1c2luZyB1aW50OC5cbiAqIEByZXR1cm5zIHtOdW1iZXJ9IFRoZSB1bnBhY2tlZCBmbG9hdC5cbiAqIEBwcml2YXRlXG4gKi9cbkNhcnRlc2lhbjQudW5wYWNrRmxvYXQgPSBmdW5jdGlvbiAocGFja2VkRmxvYXQpIHtcbiAgLy8+PmluY2x1ZGVTdGFydCgnZGVidWcnLCBwcmFnbWFzLmRlYnVnKTtcbiAgQ2hlY2sudHlwZU9mLm9iamVjdChcInBhY2tlZEZsb2F0XCIsIHBhY2tlZEZsb2F0KTtcbiAgLy8+PmluY2x1ZGVFbmQoJ2RlYnVnJyk7XG5cbiAgLy8gc2NyYXRjaFU4QXJyYXkgYW5kIHNjcmF0Y2hGMzJBcnJheSBhcmUgdmlld3MgaW50byB0aGUgc2FtZSBidWZmZXJcbiAgaWYgKGxpdHRsZUVuZGlhbikge1xuICAgIHNjcmF0Y2hVOEFycmF5WzBdID0gcGFja2VkRmxvYXQueDtcbiAgICBzY3JhdGNoVThBcnJheVsxXSA9IHBhY2tlZEZsb2F0Lnk7XG4gICAgc2NyYXRjaFU4QXJyYXlbMl0gPSBwYWNrZWRGbG9hdC56O1xuICAgIHNjcmF0Y2hVOEFycmF5WzNdID0gcGFja2VkRmxvYXQudztcbiAgfSBlbHNlIHtcbiAgICAvLyBjb252ZXJ0IGZyb20gbGl0dGxlLWVuZGlhbiB0byBiaWctZW5kaWFuXG4gICAgc2NyYXRjaFU4QXJyYXlbMF0gPSBwYWNrZWRGbG9hdC53O1xuICAgIHNjcmF0Y2hVOEFycmF5WzFdID0gcGFja2VkRmxvYXQuejtcbiAgICBzY3JhdGNoVThBcnJheVsyXSA9IHBhY2tlZEZsb2F0Lnk7XG4gICAgc2NyYXRjaFU4QXJyYXlbM10gPSBwYWNrZWRGbG9hdC54O1xuICB9XG4gIHJldHVybiBzY3JhdGNoRjMyQXJyYXlbMF07XG59O1xuZXhwb3J0IGRlZmF1bHQgQ2FydGVzaWFuNDtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///63367\n')},51688:function(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__){eval('/* harmony import */ var _Cartesian3_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(60216);\n/* harmony import */ var _Check_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(66553);\n/* harmony import */ var _defaultValue_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(62200);\n/* harmony import */ var _defined_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(82982);\n/* harmony import */ var _Math_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(99417);\n/* harmony import */ var _scaleToGeodeticSurface_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(97);\n\n\n\n\n\n\n\n/**\n * A position defined by longitude, latitude, and height.\n * @alias Cartographic\n * @constructor\n *\n * @param {Number} [longitude=0.0] The longitude, in radians.\n * @param {Number} [latitude=0.0] The latitude, in radians.\n * @param {Number} [height=0.0] The height, in meters, above the ellipsoid.\n *\n * @see Ellipsoid\n */\nfunction Cartographic(longitude, latitude, height) {\n  /**\n   * The longitude, in radians.\n   * @type {Number}\n   * @default 0.0\n   */\n  this.longitude = (0,_defaultValue_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"] */ .Z)(longitude, 0.0);\n\n  /**\n   * The latitude, in radians.\n   * @type {Number}\n   * @default 0.0\n   */\n  this.latitude = (0,_defaultValue_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"] */ .Z)(latitude, 0.0);\n\n  /**\n   * The height, in meters, above the ellipsoid.\n   * @type {Number}\n   * @default 0.0\n   */\n  this.height = (0,_defaultValue_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"] */ .Z)(height, 0.0);\n}\n\n/**\n * Creates a new Cartographic instance from longitude and latitude\n * specified in radians.\n *\n * @param {Number} longitude The longitude, in radians.\n * @param {Number} latitude The latitude, in radians.\n * @param {Number} [height=0.0] The height, in meters, above the ellipsoid.\n * @param {Cartographic} [result] The object onto which to store the result.\n * @returns {Cartographic} The modified result parameter or a new Cartographic instance if one was not provided.\n */\nCartographic.fromRadians = function (longitude, latitude, height, result) {\n  //>>includeStart(\'debug\', pragmas.debug);\n  _Check_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"].typeOf.number */ .Z.typeOf.number("longitude", longitude);\n  _Check_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"].typeOf.number */ .Z.typeOf.number("latitude", latitude);\n  //>>includeEnd(\'debug\');\n\n  height = (0,_defaultValue_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"] */ .Z)(height, 0.0);\n\n  if (!(0,_defined_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"] */ .Z)(result)) {\n    return new Cartographic(longitude, latitude, height);\n  }\n\n  result.longitude = longitude;\n  result.latitude = latitude;\n  result.height = height;\n  return result;\n};\n\n/**\n * Creates a new Cartographic instance from longitude and latitude\n * specified in degrees.  The values in the resulting object will\n * be in radians.\n *\n * @param {Number} longitude The longitude, in degrees.\n * @param {Number} latitude The latitude, in degrees.\n * @param {Number} [height=0.0] The height, in meters, above the ellipsoid.\n * @param {Cartographic} [result] The object onto which to store the result.\n * @returns {Cartographic} The modified result parameter or a new Cartographic instance if one was not provided.\n */\nCartographic.fromDegrees = function (longitude, latitude, height, result) {\n  //>>includeStart(\'debug\', pragmas.debug);\n  _Check_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"].typeOf.number */ .Z.typeOf.number("longitude", longitude);\n  _Check_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"].typeOf.number */ .Z.typeOf.number("latitude", latitude);\n  //>>includeEnd(\'debug\');\n  longitude = _Math_js__WEBPACK_IMPORTED_MODULE_3__/* ["default"].toRadians */ .Z.toRadians(longitude);\n  latitude = _Math_js__WEBPACK_IMPORTED_MODULE_3__/* ["default"].toRadians */ .Z.toRadians(latitude);\n\n  return Cartographic.fromRadians(longitude, latitude, height, result);\n};\n\nvar cartesianToCartographicN = new _Cartesian3_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .Z();\nvar cartesianToCartographicP = new _Cartesian3_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .Z();\nvar cartesianToCartographicH = new _Cartesian3_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .Z();\nvar wgs84OneOverRadii = new _Cartesian3_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .Z(\n  1.0 / 6378137.0,\n  1.0 / 6378137.0,\n  1.0 / 6356752.3142451793\n);\nvar wgs84OneOverRadiiSquared = new _Cartesian3_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .Z(\n  1.0 / (6378137.0 * 6378137.0),\n  1.0 / (6378137.0 * 6378137.0),\n  1.0 / (6356752.3142451793 * 6356752.3142451793)\n);\nvar wgs84CenterToleranceSquared = _Math_js__WEBPACK_IMPORTED_MODULE_3__/* ["default"].EPSILON1 */ .Z.EPSILON1;\n\n/**\n * Creates a new Cartographic instance from a Cartesian position. The values in the\n * resulting object will be in radians.\n *\n * @param {Cartesian3} cartesian The Cartesian position to convert to cartographic representation.\n * @param {Ellipsoid} [ellipsoid=Ellipsoid.WGS84] The ellipsoid on which the position lies.\n * @param {Cartographic} [result] The object onto which to store the result.\n * @returns {Cartographic} The modified result parameter, new Cartographic instance if none was provided, or undefined if the cartesian is at the center of the ellipsoid.\n */\nCartographic.fromCartesian = function (cartesian, ellipsoid, result) {\n  var oneOverRadii = (0,_defined_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"] */ .Z)(ellipsoid)\n    ? ellipsoid.oneOverRadii\n    : wgs84OneOverRadii;\n  var oneOverRadiiSquared = (0,_defined_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"] */ .Z)(ellipsoid)\n    ? ellipsoid.oneOverRadiiSquared\n    : wgs84OneOverRadiiSquared;\n  var centerToleranceSquared = (0,_defined_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"] */ .Z)(ellipsoid)\n    ? ellipsoid._centerToleranceSquared\n    : wgs84CenterToleranceSquared;\n\n  //`cartesian is required.` is thrown from scaleToGeodeticSurface\n  var p = (0,_scaleToGeodeticSurface_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .Z)(\n    cartesian,\n    oneOverRadii,\n    oneOverRadiiSquared,\n    centerToleranceSquared,\n    cartesianToCartographicP\n  );\n\n  if (!(0,_defined_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"] */ .Z)(p)) {\n    return undefined;\n  }\n\n  var n = _Cartesian3_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].multiplyComponents */ .Z.multiplyComponents(\n    p,\n    oneOverRadiiSquared,\n    cartesianToCartographicN\n  );\n  n = _Cartesian3_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].normalize */ .Z.normalize(n, n);\n\n  var h = _Cartesian3_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].subtract */ .Z.subtract(cartesian, p, cartesianToCartographicH);\n\n  var longitude = Math.atan2(n.y, n.x);\n  var latitude = Math.asin(n.z);\n  var height =\n    _Math_js__WEBPACK_IMPORTED_MODULE_3__/* ["default"].sign */ .Z.sign(_Cartesian3_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].dot */ .Z.dot(h, cartesian)) * _Cartesian3_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].magnitude */ .Z.magnitude(h);\n\n  if (!(0,_defined_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"] */ .Z)(result)) {\n    return new Cartographic(longitude, latitude, height);\n  }\n  result.longitude = longitude;\n  result.latitude = latitude;\n  result.height = height;\n  return result;\n};\n\n/**\n * Creates a new Cartesian3 instance from a Cartographic input. The values in the inputted\n * object should be in radians.\n *\n * @param {Cartographic} cartographic Input to be converted into a Cartesian3 output.\n * @param {Ellipsoid} [ellipsoid=Ellipsoid.WGS84] The ellipsoid on which the position lies.\n * @param {Cartesian3} [result] The object onto which to store the result.\n * @returns {Cartesian3} The position\n */\nCartographic.toCartesian = function (cartographic, ellipsoid, result) {\n  //>>includeStart(\'debug\', pragmas.debug);\n  _Check_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"].defined */ .Z.defined("cartographic", cartographic);\n  //>>includeEnd(\'debug\');\n\n  return _Cartesian3_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].fromRadians */ .Z.fromRadians(\n    cartographic.longitude,\n    cartographic.latitude,\n    cartographic.height,\n    ellipsoid,\n    result\n  );\n};\n\n/**\n * Duplicates a Cartographic instance.\n *\n * @param {Cartographic} cartographic The cartographic to duplicate.\n * @param {Cartographic} [result] The object onto which to store the result.\n * @returns {Cartographic} The modified result parameter or a new Cartographic instance if one was not provided. (Returns undefined if cartographic is undefined)\n */\nCartographic.clone = function (cartographic, result) {\n  if (!(0,_defined_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"] */ .Z)(cartographic)) {\n    return undefined;\n  }\n  if (!(0,_defined_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"] */ .Z)(result)) {\n    return new Cartographic(\n      cartographic.longitude,\n      cartographic.latitude,\n      cartographic.height\n    );\n  }\n  result.longitude = cartographic.longitude;\n  result.latitude = cartographic.latitude;\n  result.height = cartographic.height;\n  return result;\n};\n\n/**\n * Compares the provided cartographics componentwise and returns\n * <code>true</code> if they are equal, <code>false</code> otherwise.\n *\n * @param {Cartographic} [left] The first cartographic.\n * @param {Cartographic} [right] The second cartographic.\n * @returns {Boolean} <code>true</code> if left and right are equal, <code>false</code> otherwise.\n */\nCartographic.equals = function (left, right) {\n  return (\n    left === right ||\n    ((0,_defined_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"] */ .Z)(left) &&\n      (0,_defined_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"] */ .Z)(right) &&\n      left.longitude === right.longitude &&\n      left.latitude === right.latitude &&\n      left.height === right.height)\n  );\n};\n\n/**\n * Compares the provided cartographics componentwise and returns\n * <code>true</code> if they are within the provided epsilon,\n * <code>false</code> otherwise.\n *\n * @param {Cartographic} [left] The first cartographic.\n * @param {Cartographic} [right] The second cartographic.\n * @param {Number} [epsilon=0] The epsilon to use for equality testing.\n * @returns {Boolean} <code>true</code> if left and right are within the provided epsilon, <code>false</code> otherwise.\n */\nCartographic.equalsEpsilon = function (left, right, epsilon) {\n  epsilon = (0,_defaultValue_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"] */ .Z)(epsilon, 0);\n\n  return (\n    left === right ||\n    ((0,_defined_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"] */ .Z)(left) &&\n      (0,_defined_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"] */ .Z)(right) &&\n      Math.abs(left.longitude - right.longitude) <= epsilon &&\n      Math.abs(left.latitude - right.latitude) <= epsilon &&\n      Math.abs(left.height - right.height) <= epsilon)\n  );\n};\n\n/**\n * An immutable Cartographic instance initialized to (0.0, 0.0, 0.0).\n *\n * @type {Cartographic}\n * @constant\n */\nCartographic.ZERO = Object.freeze(new Cartographic(0.0, 0.0, 0.0));\n\n/**\n * Duplicates this instance.\n *\n * @param {Cartographic} [result] The object onto which to store the result.\n * @returns {Cartographic} The modified result parameter or a new Cartographic instance if one was not provided.\n */\nCartographic.prototype.clone = function (result) {\n  return Cartographic.clone(this, result);\n};\n\n/**\n * Compares the provided against this cartographic componentwise and returns\n * <code>true</code> if they are equal, <code>false</code> otherwise.\n *\n * @param {Cartographic} [right] The second cartographic.\n * @returns {Boolean} <code>true</code> if left and right are equal, <code>false</code> otherwise.\n */\nCartographic.prototype.equals = function (right) {\n  return Cartographic.equals(this, right);\n};\n\n/**\n * Compares the provided against this cartographic componentwise and returns\n * <code>true</code> if they are within the provided epsilon,\n * <code>false</code> otherwise.\n *\n * @param {Cartographic} [right] The second cartographic.\n * @param {Number} [epsilon=0] The epsilon to use for equality testing.\n * @returns {Boolean} <code>true</code> if left and right are within the provided epsilon, <code>false</code> otherwise.\n */\nCartographic.prototype.equalsEpsilon = function (right, epsilon) {\n  return Cartographic.equalsEpsilon(this, right, epsilon);\n};\n\n/**\n * Creates a string representing this cartographic in the format \'(longitude, latitude, height)\'.\n *\n * @returns {String} A string representing the provided cartographic in the format \'(longitude, latitude, height)\'.\n */\nCartographic.prototype.toString = function () {\n  return "(" + this.longitude + ", " + this.latitude + ", " + this.height + ")";\n};\n/* harmony default export */ __webpack_exports__["Z"] = (Cartographic);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QTtBQUNBO0FBQ0EsS0FBSyxnRUFBTztBQUNaLE1BQU0sZ0VBQU87QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGNBQWM7QUFDekIsV0FBVyxjQUFjO0FBQ3pCLFdBQVcsUUFBUTtBQUNuQixhQUFhLFNBQVM7QUFDdEI7QUFDQTtBQUNBLFlBQVkscUVBQVk7O0FBRXhCO0FBQ0E7QUFDQSxLQUFLLGdFQUFPO0FBQ1osTUFBTSxnRUFBTztBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGNBQWM7QUFDekIsYUFBYSxjQUFjO0FBQzNCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxjQUFjO0FBQ3pCLGFBQWEsU0FBUztBQUN0QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxjQUFjO0FBQ3pCLFdBQVcsUUFBUTtBQUNuQixhQUFhLFNBQVM7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseURBQWUsWUFBWSxFQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdnVlMy13ZWJwYWNrNS8uL25vZGVfbW9kdWxlcy9jZXNpdW0vU291cmNlL0NvcmUvQ2FydG9ncmFwaGljLmpzPzhiMTgiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IENhcnRlc2lhbjMgZnJvbSBcIi4vQ2FydGVzaWFuMy5qc1wiO1xuaW1wb3J0IENoZWNrIGZyb20gXCIuL0NoZWNrLmpzXCI7XG5pbXBvcnQgZGVmYXVsdFZhbHVlIGZyb20gXCIuL2RlZmF1bHRWYWx1ZS5qc1wiO1xuaW1wb3J0IGRlZmluZWQgZnJvbSBcIi4vZGVmaW5lZC5qc1wiO1xuaW1wb3J0IENlc2l1bU1hdGggZnJvbSBcIi4vTWF0aC5qc1wiO1xuaW1wb3J0IHNjYWxlVG9HZW9kZXRpY1N1cmZhY2UgZnJvbSBcIi4vc2NhbGVUb0dlb2RldGljU3VyZmFjZS5qc1wiO1xuXG4vKipcbiAqIEEgcG9zaXRpb24gZGVmaW5lZCBieSBsb25naXR1ZGUsIGxhdGl0dWRlLCBhbmQgaGVpZ2h0LlxuICogQGFsaWFzIENhcnRvZ3JhcGhpY1xuICogQGNvbnN0cnVjdG9yXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IFtsb25naXR1ZGU9MC4wXSBUaGUgbG9uZ2l0dWRlLCBpbiByYWRpYW5zLlxuICogQHBhcmFtIHtOdW1iZXJ9IFtsYXRpdHVkZT0wLjBdIFRoZSBsYXRpdHVkZSwgaW4gcmFkaWFucy5cbiAqIEBwYXJhbSB7TnVtYmVyfSBbaGVpZ2h0PTAuMF0gVGhlIGhlaWdodCwgaW4gbWV0ZXJzLCBhYm92ZSB0aGUgZWxsaXBzb2lkLlxuICpcbiAqIEBzZWUgRWxsaXBzb2lkXG4gKi9cbmZ1bmN0aW9uIENhcnRvZ3JhcGhpYyhsb25naXR1ZGUsIGxhdGl0dWRlLCBoZWlnaHQpIHtcbiAgLyoqXG4gICAqIFRoZSBsb25naXR1ZGUsIGluIHJhZGlhbnMuXG4gICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAqIEBkZWZhdWx0IDAuMFxuICAgKi9cbiAgdGhpcy5sb25naXR1ZGUgPSBkZWZhdWx0VmFsdWUobG9uZ2l0dWRlLCAwLjApO1xuXG4gIC8qKlxuICAgKiBUaGUgbGF0aXR1ZGUsIGluIHJhZGlhbnMuXG4gICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAqIEBkZWZhdWx0IDAuMFxuICAgKi9cbiAgdGhpcy5sYXRpdHVkZSA9IGRlZmF1bHRWYWx1ZShsYXRpdHVkZSwgMC4wKTtcblxuICAvKipcbiAgICogVGhlIGhlaWdodCwgaW4gbWV0ZXJzLCBhYm92ZSB0aGUgZWxsaXBzb2lkLlxuICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgKiBAZGVmYXVsdCAwLjBcbiAgICovXG4gIHRoaXMuaGVpZ2h0ID0gZGVmYXVsdFZhbHVlKGhlaWdodCwgMC4wKTtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IENhcnRvZ3JhcGhpYyBpbnN0YW5jZSBmcm9tIGxvbmdpdHVkZSBhbmQgbGF0aXR1ZGVcbiAqIHNwZWNpZmllZCBpbiByYWRpYW5zLlxuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSBsb25naXR1ZGUgVGhlIGxvbmdpdHVkZSwgaW4gcmFkaWFucy5cbiAqIEBwYXJhbSB7TnVtYmVyfSBsYXRpdHVkZSBUaGUgbGF0aXR1ZGUsIGluIHJhZGlhbnMuXG4gKiBAcGFyYW0ge051bWJlcn0gW2hlaWdodD0wLjBdIFRoZSBoZWlnaHQsIGluIG1ldGVycywgYWJvdmUgdGhlIGVsbGlwc29pZC5cbiAqIEBwYXJhbSB7Q2FydG9ncmFwaGljfSBbcmVzdWx0XSBUaGUgb2JqZWN0IG9udG8gd2hpY2ggdG8gc3RvcmUgdGhlIHJlc3VsdC5cbiAqIEByZXR1cm5zIHtDYXJ0b2dyYXBoaWN9IFRoZSBtb2RpZmllZCByZXN1bHQgcGFyYW1ldGVyIG9yIGEgbmV3IENhcnRvZ3JhcGhpYyBpbnN0YW5jZSBpZiBvbmUgd2FzIG5vdCBwcm92aWRlZC5cbiAqL1xuQ2FydG9ncmFwaGljLmZyb21SYWRpYW5zID0gZnVuY3Rpb24gKGxvbmdpdHVkZSwgbGF0aXR1ZGUsIGhlaWdodCwgcmVzdWx0KSB7XG4gIC8vPj5pbmNsdWRlU3RhcnQoJ2RlYnVnJywgcHJhZ21hcy5kZWJ1Zyk7XG4gIENoZWNrLnR5cGVPZi5udW1iZXIoXCJsb25naXR1ZGVcIiwgbG9uZ2l0dWRlKTtcbiAgQ2hlY2sudHlwZU9mLm51bWJlcihcImxhdGl0dWRlXCIsIGxhdGl0dWRlKTtcbiAgLy8+PmluY2x1ZGVFbmQoJ2RlYnVnJyk7XG5cbiAgaGVpZ2h0ID0gZGVmYXVsdFZhbHVlKGhlaWdodCwgMC4wKTtcblxuICBpZiAoIWRlZmluZWQocmVzdWx0KSkge1xuICAgIHJldHVybiBuZXcgQ2FydG9ncmFwaGljKGxvbmdpdHVkZSwgbGF0aXR1ZGUsIGhlaWdodCk7XG4gIH1cblxuICByZXN1bHQubG9uZ2l0dWRlID0gbG9uZ2l0dWRlO1xuICByZXN1bHQubGF0aXR1ZGUgPSBsYXRpdHVkZTtcbiAgcmVzdWx0LmhlaWdodCA9IGhlaWdodDtcbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyBDYXJ0b2dyYXBoaWMgaW5zdGFuY2UgZnJvbSBsb25naXR1ZGUgYW5kIGxhdGl0dWRlXG4gKiBzcGVjaWZpZWQgaW4gZGVncmVlcy4gIFRoZSB2YWx1ZXMgaW4gdGhlIHJlc3VsdGluZyBvYmplY3Qgd2lsbFxuICogYmUgaW4gcmFkaWFucy5cbiAqXG4gKiBAcGFyYW0ge051bWJlcn0gbG9uZ2l0dWRlIFRoZSBsb25naXR1ZGUsIGluIGRlZ3JlZXMuXG4gKiBAcGFyYW0ge051bWJlcn0gbGF0aXR1ZGUgVGhlIGxhdGl0dWRlLCBpbiBkZWdyZWVzLlxuICogQHBhcmFtIHtOdW1iZXJ9IFtoZWlnaHQ9MC4wXSBUaGUgaGVpZ2h0LCBpbiBtZXRlcnMsIGFib3ZlIHRoZSBlbGxpcHNvaWQuXG4gKiBAcGFyYW0ge0NhcnRvZ3JhcGhpY30gW3Jlc3VsdF0gVGhlIG9iamVjdCBvbnRvIHdoaWNoIHRvIHN0b3JlIHRoZSByZXN1bHQuXG4gKiBAcmV0dXJucyB7Q2FydG9ncmFwaGljfSBUaGUgbW9kaWZpZWQgcmVzdWx0IHBhcmFtZXRlciBvciBhIG5ldyBDYXJ0b2dyYXBoaWMgaW5zdGFuY2UgaWYgb25lIHdhcyBub3QgcHJvdmlkZWQuXG4gKi9cbkNhcnRvZ3JhcGhpYy5mcm9tRGVncmVlcyA9IGZ1bmN0aW9uIChsb25naXR1ZGUsIGxhdGl0dWRlLCBoZWlnaHQsIHJlc3VsdCkge1xuICAvLz4+aW5jbHVkZVN0YXJ0KCdkZWJ1ZycsIHByYWdtYXMuZGVidWcpO1xuICBDaGVjay50eXBlT2YubnVtYmVyKFwibG9uZ2l0dWRlXCIsIGxvbmdpdHVkZSk7XG4gIENoZWNrLnR5cGVPZi5udW1iZXIoXCJsYXRpdHVkZVwiLCBsYXRpdHVkZSk7XG4gIC8vPj5pbmNsdWRlRW5kKCdkZWJ1ZycpO1xuICBsb25naXR1ZGUgPSBDZXNpdW1NYXRoLnRvUmFkaWFucyhsb25naXR1ZGUpO1xuICBsYXRpdHVkZSA9IENlc2l1bU1hdGgudG9SYWRpYW5zKGxhdGl0dWRlKTtcblxuICByZXR1cm4gQ2FydG9ncmFwaGljLmZyb21SYWRpYW5zKGxvbmdpdHVkZSwgbGF0aXR1ZGUsIGhlaWdodCwgcmVzdWx0KTtcbn07XG5cbnZhciBjYXJ0ZXNpYW5Ub0NhcnRvZ3JhcGhpY04gPSBuZXcgQ2FydGVzaWFuMygpO1xudmFyIGNhcnRlc2lhblRvQ2FydG9ncmFwaGljUCA9IG5ldyBDYXJ0ZXNpYW4zKCk7XG52YXIgY2FydGVzaWFuVG9DYXJ0b2dyYXBoaWNIID0gbmV3IENhcnRlc2lhbjMoKTtcbnZhciB3Z3M4NE9uZU92ZXJSYWRpaSA9IG5ldyBDYXJ0ZXNpYW4zKFxuICAxLjAgLyA2Mzc4MTM3LjAsXG4gIDEuMCAvIDYzNzgxMzcuMCxcbiAgMS4wIC8gNjM1Njc1Mi4zMTQyNDUxNzkzXG4pO1xudmFyIHdnczg0T25lT3ZlclJhZGlpU3F1YXJlZCA9IG5ldyBDYXJ0ZXNpYW4zKFxuICAxLjAgLyAoNjM3ODEzNy4wICogNjM3ODEzNy4wKSxcbiAgMS4wIC8gKDYzNzgxMzcuMCAqIDYzNzgxMzcuMCksXG4gIDEuMCAvICg2MzU2NzUyLjMxNDI0NTE3OTMgKiA2MzU2NzUyLjMxNDI0NTE3OTMpXG4pO1xudmFyIHdnczg0Q2VudGVyVG9sZXJhbmNlU3F1YXJlZCA9IENlc2l1bU1hdGguRVBTSUxPTjE7XG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyBDYXJ0b2dyYXBoaWMgaW5zdGFuY2UgZnJvbSBhIENhcnRlc2lhbiBwb3NpdGlvbi4gVGhlIHZhbHVlcyBpbiB0aGVcbiAqIHJlc3VsdGluZyBvYmplY3Qgd2lsbCBiZSBpbiByYWRpYW5zLlxuICpcbiAqIEBwYXJhbSB7Q2FydGVzaWFuM30gY2FydGVzaWFuIFRoZSBDYXJ0ZXNpYW4gcG9zaXRpb24gdG8gY29udmVydCB0byBjYXJ0b2dyYXBoaWMgcmVwcmVzZW50YXRpb24uXG4gKiBAcGFyYW0ge0VsbGlwc29pZH0gW2VsbGlwc29pZD1FbGxpcHNvaWQuV0dTODRdIFRoZSBlbGxpcHNvaWQgb24gd2hpY2ggdGhlIHBvc2l0aW9uIGxpZXMuXG4gKiBAcGFyYW0ge0NhcnRvZ3JhcGhpY30gW3Jlc3VsdF0gVGhlIG9iamVjdCBvbnRvIHdoaWNoIHRvIHN0b3JlIHRoZSByZXN1bHQuXG4gKiBAcmV0dXJucyB7Q2FydG9ncmFwaGljfSBUaGUgbW9kaWZpZWQgcmVzdWx0IHBhcmFtZXRlciwgbmV3IENhcnRvZ3JhcGhpYyBpbnN0YW5jZSBpZiBub25lIHdhcyBwcm92aWRlZCwgb3IgdW5kZWZpbmVkIGlmIHRoZSBjYXJ0ZXNpYW4gaXMgYXQgdGhlIGNlbnRlciBvZiB0aGUgZWxsaXBzb2lkLlxuICovXG5DYXJ0b2dyYXBoaWMuZnJvbUNhcnRlc2lhbiA9IGZ1bmN0aW9uIChjYXJ0ZXNpYW4sIGVsbGlwc29pZCwgcmVzdWx0KSB7XG4gIHZhciBvbmVPdmVyUmFkaWkgPSBkZWZpbmVkKGVsbGlwc29pZClcbiAgICA/IGVsbGlwc29pZC5vbmVPdmVyUmFkaWlcbiAgICA6IHdnczg0T25lT3ZlclJhZGlpO1xuICB2YXIgb25lT3ZlclJhZGlpU3F1YXJlZCA9IGRlZmluZWQoZWxsaXBzb2lkKVxuICAgID8gZWxsaXBzb2lkLm9uZU92ZXJSYWRpaVNxdWFyZWRcbiAgICA6IHdnczg0T25lT3ZlclJhZGlpU3F1YXJlZDtcbiAgdmFyIGNlbnRlclRvbGVyYW5jZVNxdWFyZWQgPSBkZWZpbmVkKGVsbGlwc29pZClcbiAgICA/IGVsbGlwc29pZC5fY2VudGVyVG9sZXJhbmNlU3F1YXJlZFxuICAgIDogd2dzODRDZW50ZXJUb2xlcmFuY2VTcXVhcmVkO1xuXG4gIC8vYGNhcnRlc2lhbiBpcyByZXF1aXJlZC5gIGlzIHRocm93biBmcm9tIHNjYWxlVG9HZW9kZXRpY1N1cmZhY2VcbiAgdmFyIHAgPSBzY2FsZVRvR2VvZGV0aWNTdXJmYWNlKFxuICAgIGNhcnRlc2lhbixcbiAgICBvbmVPdmVyUmFkaWksXG4gICAgb25lT3ZlclJhZGlpU3F1YXJlZCxcbiAgICBjZW50ZXJUb2xlcmFuY2VTcXVhcmVkLFxuICAgIGNhcnRlc2lhblRvQ2FydG9ncmFwaGljUFxuICApO1xuXG4gIGlmICghZGVmaW5lZChwKSkge1xuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cblxuICB2YXIgbiA9IENhcnRlc2lhbjMubXVsdGlwbHlDb21wb25lbnRzKFxuICAgIHAsXG4gICAgb25lT3ZlclJhZGlpU3F1YXJlZCxcbiAgICBjYXJ0ZXNpYW5Ub0NhcnRvZ3JhcGhpY05cbiAgKTtcbiAgbiA9IENhcnRlc2lhbjMubm9ybWFsaXplKG4sIG4pO1xuXG4gIHZhciBoID0gQ2FydGVzaWFuMy5zdWJ0cmFjdChjYXJ0ZXNpYW4sIHAsIGNhcnRlc2lhblRvQ2FydG9ncmFwaGljSCk7XG5cbiAgdmFyIGxvbmdpdHVkZSA9IE1hdGguYXRhbjIobi55LCBuLngpO1xuICB2YXIgbGF0aXR1ZGUgPSBNYXRoLmFzaW4obi56KTtcbiAgdmFyIGhlaWdodCA9XG4gICAgQ2VzaXVtTWF0aC5zaWduKENhcnRlc2lhbjMuZG90KGgsIGNhcnRlc2lhbikpICogQ2FydGVzaWFuMy5tYWduaXR1ZGUoaCk7XG5cbiAgaWYgKCFkZWZpbmVkKHJlc3VsdCkpIHtcbiAgICByZXR1cm4gbmV3IENhcnRvZ3JhcGhpYyhsb25naXR1ZGUsIGxhdGl0dWRlLCBoZWlnaHQpO1xuICB9XG4gIHJlc3VsdC5sb25naXR1ZGUgPSBsb25naXR1ZGU7XG4gIHJlc3VsdC5sYXRpdHVkZSA9IGxhdGl0dWRlO1xuICByZXN1bHQuaGVpZ2h0ID0gaGVpZ2h0O1xuICByZXR1cm4gcmVzdWx0O1xufTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IENhcnRlc2lhbjMgaW5zdGFuY2UgZnJvbSBhIENhcnRvZ3JhcGhpYyBpbnB1dC4gVGhlIHZhbHVlcyBpbiB0aGUgaW5wdXR0ZWRcbiAqIG9iamVjdCBzaG91bGQgYmUgaW4gcmFkaWFucy5cbiAqXG4gKiBAcGFyYW0ge0NhcnRvZ3JhcGhpY30gY2FydG9ncmFwaGljIElucHV0IHRvIGJlIGNvbnZlcnRlZCBpbnRvIGEgQ2FydGVzaWFuMyBvdXRwdXQuXG4gKiBAcGFyYW0ge0VsbGlwc29pZH0gW2VsbGlwc29pZD1FbGxpcHNvaWQuV0dTODRdIFRoZSBlbGxpcHNvaWQgb24gd2hpY2ggdGhlIHBvc2l0aW9uIGxpZXMuXG4gKiBAcGFyYW0ge0NhcnRlc2lhbjN9IFtyZXN1bHRdIFRoZSBvYmplY3Qgb250byB3aGljaCB0byBzdG9yZSB0aGUgcmVzdWx0LlxuICogQHJldHVybnMge0NhcnRlc2lhbjN9IFRoZSBwb3NpdGlvblxuICovXG5DYXJ0b2dyYXBoaWMudG9DYXJ0ZXNpYW4gPSBmdW5jdGlvbiAoY2FydG9ncmFwaGljLCBlbGxpcHNvaWQsIHJlc3VsdCkge1xuICAvLz4+aW5jbHVkZVN0YXJ0KCdkZWJ1ZycsIHByYWdtYXMuZGVidWcpO1xuICBDaGVjay5kZWZpbmVkKFwiY2FydG9ncmFwaGljXCIsIGNhcnRvZ3JhcGhpYyk7XG4gIC8vPj5pbmNsdWRlRW5kKCdkZWJ1ZycpO1xuXG4gIHJldHVybiBDYXJ0ZXNpYW4zLmZyb21SYWRpYW5zKFxuICAgIGNhcnRvZ3JhcGhpYy5sb25naXR1ZGUsXG4gICAgY2FydG9ncmFwaGljLmxhdGl0dWRlLFxuICAgIGNhcnRvZ3JhcGhpYy5oZWlnaHQsXG4gICAgZWxsaXBzb2lkLFxuICAgIHJlc3VsdFxuICApO1xufTtcblxuLyoqXG4gKiBEdXBsaWNhdGVzIGEgQ2FydG9ncmFwaGljIGluc3RhbmNlLlxuICpcbiAqIEBwYXJhbSB7Q2FydG9ncmFwaGljfSBjYXJ0b2dyYXBoaWMgVGhlIGNhcnRvZ3JhcGhpYyB0byBkdXBsaWNhdGUuXG4gKiBAcGFyYW0ge0NhcnRvZ3JhcGhpY30gW3Jlc3VsdF0gVGhlIG9iamVjdCBvbnRvIHdoaWNoIHRvIHN0b3JlIHRoZSByZXN1bHQuXG4gKiBAcmV0dXJucyB7Q2FydG9ncmFwaGljfSBUaGUgbW9kaWZpZWQgcmVzdWx0IHBhcmFtZXRlciBvciBhIG5ldyBDYXJ0b2dyYXBoaWMgaW5zdGFuY2UgaWYgb25lIHdhcyBub3QgcHJvdmlkZWQuIChSZXR1cm5zIHVuZGVmaW5lZCBpZiBjYXJ0b2dyYXBoaWMgaXMgdW5kZWZpbmVkKVxuICovXG5DYXJ0b2dyYXBoaWMuY2xvbmUgPSBmdW5jdGlvbiAoY2FydG9ncmFwaGljLCByZXN1bHQpIHtcbiAgaWYgKCFkZWZpbmVkKGNhcnRvZ3JhcGhpYykpIHtcbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG4gIGlmICghZGVmaW5lZChyZXN1bHQpKSB7XG4gICAgcmV0dXJuIG5ldyBDYXJ0b2dyYXBoaWMoXG4gICAgICBjYXJ0b2dyYXBoaWMubG9uZ2l0dWRlLFxuICAgICAgY2FydG9ncmFwaGljLmxhdGl0dWRlLFxuICAgICAgY2FydG9ncmFwaGljLmhlaWdodFxuICAgICk7XG4gIH1cbiAgcmVzdWx0LmxvbmdpdHVkZSA9IGNhcnRvZ3JhcGhpYy5sb25naXR1ZGU7XG4gIHJlc3VsdC5sYXRpdHVkZSA9IGNhcnRvZ3JhcGhpYy5sYXRpdHVkZTtcbiAgcmVzdWx0LmhlaWdodCA9IGNhcnRvZ3JhcGhpYy5oZWlnaHQ7XG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG4vKipcbiAqIENvbXBhcmVzIHRoZSBwcm92aWRlZCBjYXJ0b2dyYXBoaWNzIGNvbXBvbmVudHdpc2UgYW5kIHJldHVybnNcbiAqIDxjb2RlPnRydWU8L2NvZGU+IGlmIHRoZXkgYXJlIGVxdWFsLCA8Y29kZT5mYWxzZTwvY29kZT4gb3RoZXJ3aXNlLlxuICpcbiAqIEBwYXJhbSB7Q2FydG9ncmFwaGljfSBbbGVmdF0gVGhlIGZpcnN0IGNhcnRvZ3JhcGhpYy5cbiAqIEBwYXJhbSB7Q2FydG9ncmFwaGljfSBbcmlnaHRdIFRoZSBzZWNvbmQgY2FydG9ncmFwaGljLlxuICogQHJldHVybnMge0Jvb2xlYW59IDxjb2RlPnRydWU8L2NvZGU+IGlmIGxlZnQgYW5kIHJpZ2h0IGFyZSBlcXVhbCwgPGNvZGU+ZmFsc2U8L2NvZGU+IG90aGVyd2lzZS5cbiAqL1xuQ2FydG9ncmFwaGljLmVxdWFscyA9IGZ1bmN0aW9uIChsZWZ0LCByaWdodCkge1xuICByZXR1cm4gKFxuICAgIGxlZnQgPT09IHJpZ2h0IHx8XG4gICAgKGRlZmluZWQobGVmdCkgJiZcbiAgICAgIGRlZmluZWQocmlnaHQpICYmXG4gICAgICBsZWZ0LmxvbmdpdHVkZSA9PT0gcmlnaHQubG9uZ2l0dWRlICYmXG4gICAgICBsZWZ0LmxhdGl0dWRlID09PSByaWdodC5sYXRpdHVkZSAmJlxuICAgICAgbGVmdC5oZWlnaHQgPT09IHJpZ2h0LmhlaWdodClcbiAgKTtcbn07XG5cbi8qKlxuICogQ29tcGFyZXMgdGhlIHByb3ZpZGVkIGNhcnRvZ3JhcGhpY3MgY29tcG9uZW50d2lzZSBhbmQgcmV0dXJuc1xuICogPGNvZGU+dHJ1ZTwvY29kZT4gaWYgdGhleSBhcmUgd2l0aGluIHRoZSBwcm92aWRlZCBlcHNpbG9uLFxuICogPGNvZGU+ZmFsc2U8L2NvZGU+IG90aGVyd2lzZS5cbiAqXG4gKiBAcGFyYW0ge0NhcnRvZ3JhcGhpY30gW2xlZnRdIFRoZSBmaXJzdCBjYXJ0b2dyYXBoaWMuXG4gKiBAcGFyYW0ge0NhcnRvZ3JhcGhpY30gW3JpZ2h0XSBUaGUgc2Vjb25kIGNhcnRvZ3JhcGhpYy5cbiAqIEBwYXJhbSB7TnVtYmVyfSBbZXBzaWxvbj0wXSBUaGUgZXBzaWxvbiB0byB1c2UgZm9yIGVxdWFsaXR5IHRlc3RpbmcuXG4gKiBAcmV0dXJucyB7Qm9vbGVhbn0gPGNvZGU+dHJ1ZTwvY29kZT4gaWYgbGVmdCBhbmQgcmlnaHQgYXJlIHdpdGhpbiB0aGUgcHJvdmlkZWQgZXBzaWxvbiwgPGNvZGU+ZmFsc2U8L2NvZGU+IG90aGVyd2lzZS5cbiAqL1xuQ2FydG9ncmFwaGljLmVxdWFsc0Vwc2lsb24gPSBmdW5jdGlvbiAobGVmdCwgcmlnaHQsIGVwc2lsb24pIHtcbiAgZXBzaWxvbiA9IGRlZmF1bHRWYWx1ZShlcHNpbG9uLCAwKTtcblxuICByZXR1cm4gKFxuICAgIGxlZnQgPT09IHJpZ2h0IHx8XG4gICAgKGRlZmluZWQobGVmdCkgJiZcbiAgICAgIGRlZmluZWQocmlnaHQpICYmXG4gICAgICBNYXRoLmFicyhsZWZ0LmxvbmdpdHVkZSAtIHJpZ2h0LmxvbmdpdHVkZSkgPD0gZXBzaWxvbiAmJlxuICAgICAgTWF0aC5hYnMobGVmdC5sYXRpdHVkZSAtIHJpZ2h0LmxhdGl0dWRlKSA8PSBlcHNpbG9uICYmXG4gICAgICBNYXRoLmFicyhsZWZ0LmhlaWdodCAtIHJpZ2h0LmhlaWdodCkgPD0gZXBzaWxvbilcbiAgKTtcbn07XG5cbi8qKlxuICogQW4gaW1tdXRhYmxlIENhcnRvZ3JhcGhpYyBpbnN0YW5jZSBpbml0aWFsaXplZCB0byAoMC4wLCAwLjAsIDAuMCkuXG4gKlxuICogQHR5cGUge0NhcnRvZ3JhcGhpY31cbiAqIEBjb25zdGFudFxuICovXG5DYXJ0b2dyYXBoaWMuWkVSTyA9IE9iamVjdC5mcmVlemUobmV3IENhcnRvZ3JhcGhpYygwLjAsIDAuMCwgMC4wKSk7XG5cbi8qKlxuICogRHVwbGljYXRlcyB0aGlzIGluc3RhbmNlLlxuICpcbiAqIEBwYXJhbSB7Q2FydG9ncmFwaGljfSBbcmVzdWx0XSBUaGUgb2JqZWN0IG9udG8gd2hpY2ggdG8gc3RvcmUgdGhlIHJlc3VsdC5cbiAqIEByZXR1cm5zIHtDYXJ0b2dyYXBoaWN9IFRoZSBtb2RpZmllZCByZXN1bHQgcGFyYW1ldGVyIG9yIGEgbmV3IENhcnRvZ3JhcGhpYyBpbnN0YW5jZSBpZiBvbmUgd2FzIG5vdCBwcm92aWRlZC5cbiAqL1xuQ2FydG9ncmFwaGljLnByb3RvdHlwZS5jbG9uZSA9IGZ1bmN0aW9uIChyZXN1bHQpIHtcbiAgcmV0dXJuIENhcnRvZ3JhcGhpYy5jbG9uZSh0aGlzLCByZXN1bHQpO1xufTtcblxuLyoqXG4gKiBDb21wYXJlcyB0aGUgcHJvdmlkZWQgYWdhaW5zdCB0aGlzIGNhcnRvZ3JhcGhpYyBjb21wb25lbnR3aXNlIGFuZCByZXR1cm5zXG4gKiA8Y29kZT50cnVlPC9jb2RlPiBpZiB0aGV5IGFyZSBlcXVhbCwgPGNvZGU+ZmFsc2U8L2NvZGU+IG90aGVyd2lzZS5cbiAqXG4gKiBAcGFyYW0ge0NhcnRvZ3JhcGhpY30gW3JpZ2h0XSBUaGUgc2Vjb25kIGNhcnRvZ3JhcGhpYy5cbiAqIEByZXR1cm5zIHtCb29sZWFufSA8Y29kZT50cnVlPC9jb2RlPiBpZiBsZWZ0IGFuZCByaWdodCBhcmUgZXF1YWwsIDxjb2RlPmZhbHNlPC9jb2RlPiBvdGhlcndpc2UuXG4gKi9cbkNhcnRvZ3JhcGhpYy5wcm90b3R5cGUuZXF1YWxzID0gZnVuY3Rpb24gKHJpZ2h0KSB7XG4gIHJldHVybiBDYXJ0b2dyYXBoaWMuZXF1YWxzKHRoaXMsIHJpZ2h0KTtcbn07XG5cbi8qKlxuICogQ29tcGFyZXMgdGhlIHByb3ZpZGVkIGFnYWluc3QgdGhpcyBjYXJ0b2dyYXBoaWMgY29tcG9uZW50d2lzZSBhbmQgcmV0dXJuc1xuICogPGNvZGU+dHJ1ZTwvY29kZT4gaWYgdGhleSBhcmUgd2l0aGluIHRoZSBwcm92aWRlZCBlcHNpbG9uLFxuICogPGNvZGU+ZmFsc2U8L2NvZGU+IG90aGVyd2lzZS5cbiAqXG4gKiBAcGFyYW0ge0NhcnRvZ3JhcGhpY30gW3JpZ2h0XSBUaGUgc2Vjb25kIGNhcnRvZ3JhcGhpYy5cbiAqIEBwYXJhbSB7TnVtYmVyfSBbZXBzaWxvbj0wXSBUaGUgZXBzaWxvbiB0byB1c2UgZm9yIGVxdWFsaXR5IHRlc3RpbmcuXG4gKiBAcmV0dXJucyB7Qm9vbGVhbn0gPGNvZGU+dHJ1ZTwvY29kZT4gaWYgbGVmdCBhbmQgcmlnaHQgYXJlIHdpdGhpbiB0aGUgcHJvdmlkZWQgZXBzaWxvbiwgPGNvZGU+ZmFsc2U8L2NvZGU+IG90aGVyd2lzZS5cbiAqL1xuQ2FydG9ncmFwaGljLnByb3RvdHlwZS5lcXVhbHNFcHNpbG9uID0gZnVuY3Rpb24gKHJpZ2h0LCBlcHNpbG9uKSB7XG4gIHJldHVybiBDYXJ0b2dyYXBoaWMuZXF1YWxzRXBzaWxvbih0aGlzLCByaWdodCwgZXBzaWxvbik7XG59O1xuXG4vKipcbiAqIENyZWF0ZXMgYSBzdHJpbmcgcmVwcmVzZW50aW5nIHRoaXMgY2FydG9ncmFwaGljIGluIHRoZSBmb3JtYXQgJyhsb25naXR1ZGUsIGxhdGl0dWRlLCBoZWlnaHQpJy5cbiAqXG4gKiBAcmV0dXJucyB7U3RyaW5nfSBBIHN0cmluZyByZXByZXNlbnRpbmcgdGhlIHByb3ZpZGVkIGNhcnRvZ3JhcGhpYyBpbiB0aGUgZm9ybWF0ICcobG9uZ2l0dWRlLCBsYXRpdHVkZSwgaGVpZ2h0KScuXG4gKi9cbkNhcnRvZ3JhcGhpYy5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiBcIihcIiArIHRoaXMubG9uZ2l0dWRlICsgXCIsIFwiICsgdGhpcy5sYXRpdHVkZSArIFwiLCBcIiArIHRoaXMuaGVpZ2h0ICsgXCIpXCI7XG59O1xuZXhwb3J0IGRlZmF1bHQgQ2FydG9ncmFwaGljO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///51688\n')},13129:function(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__){eval('/* harmony import */ var _ThirdParty_when_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(13222);\n/* harmony import */ var _Cartesian3_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(60216);\n/* harmony import */ var _Check_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(66553);\n\n\n\n\n/**\n * Geocodes queries containing longitude and latitude coordinates and an optional height.\n * Query format: `longitude latitude (height)` with longitude/latitude in degrees and height in meters.\n *\n * @alias CartographicGeocoderService\n * @constructor\n */\nfunction CartographicGeocoderService() {}\n\n/**\n * @function\n *\n * @param {String} query The query to be sent to the geocoder service\n * @returns {Promise<GeocoderService.Result[]>}\n */\nCartographicGeocoderService.prototype.geocode = function (query) {\n  //>>includeStart(\'debug\', pragmas.debug);\n  _Check_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"].typeOf.string */ .Z.typeOf.string("query", query);\n  //>>includeEnd(\'debug\');\n\n  var splitQuery = query.match(/[^\\s,\\n]+/g);\n  if (splitQuery.length === 2 || splitQuery.length === 3) {\n    var longitude = +splitQuery[0];\n    var latitude = +splitQuery[1];\n    var height = splitQuery.length === 3 ? +splitQuery[2] : 300.0;\n\n    if (isNaN(longitude) && isNaN(latitude)) {\n      var coordTest = /^(\\d+.?\\d*)([nsew])/i;\n      for (var i = 0; i < splitQuery.length; ++i) {\n        var splitCoord = splitQuery[i].match(coordTest);\n        if (coordTest.test(splitQuery[i]) && splitCoord.length === 3) {\n          if (/^[ns]/i.test(splitCoord[2])) {\n            latitude = /^[n]/i.test(splitCoord[2])\n              ? +splitCoord[1]\n              : -splitCoord[1];\n          } else if (/^[ew]/i.test(splitCoord[2])) {\n            longitude = /^[e]/i.test(splitCoord[2])\n              ? +splitCoord[1]\n              : -splitCoord[1];\n          }\n        }\n      }\n    }\n\n    if (!isNaN(longitude) && !isNaN(latitude) && !isNaN(height)) {\n      var result = {\n        displayName: query,\n        destination: _Cartesian3_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"].fromDegrees */ .Z.fromDegrees(longitude, latitude, height),\n      };\n      return _ThirdParty_when_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].resolve */ .Z.resolve([result]);\n    }\n  }\n  return _ThirdParty_when_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].resolve */ .Z.resolve([]);\n};\n/* harmony default export */ __webpack_exports__["Z"] = (CartographicGeocoderService);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTMxMjkuanMiLCJtYXBwaW5ncyI6Ijs7O0FBQXlDO0FBQ0E7QUFDVjs7QUFFL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLEVBQUUsc0ZBQW1CO0FBQ3JCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHNCQUFzQix1QkFBdUI7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQix1RkFBc0I7QUFDM0M7QUFDQSxhQUFhLG9GQUFZO0FBQ3pCO0FBQ0E7QUFDQSxTQUFTLG9GQUFZO0FBQ3JCO0FBQ0EseURBQWUsMkJBQTJCLEVBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly92dWUzLXdlYnBhY2s1Ly4vbm9kZV9tb2R1bGVzL2Nlc2l1bS9Tb3VyY2UvQ29yZS9DYXJ0b2dyYXBoaWNHZW9jb2RlclNlcnZpY2UuanM/NDM2MiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgd2hlbiBmcm9tIFwiLi4vVGhpcmRQYXJ0eS93aGVuLmpzXCI7XG5pbXBvcnQgQ2FydGVzaWFuMyBmcm9tIFwiLi9DYXJ0ZXNpYW4zLmpzXCI7XG5pbXBvcnQgQ2hlY2sgZnJvbSBcIi4vQ2hlY2suanNcIjtcblxuLyoqXG4gKiBHZW9jb2RlcyBxdWVyaWVzIGNvbnRhaW5pbmcgbG9uZ2l0dWRlIGFuZCBsYXRpdHVkZSBjb29yZGluYXRlcyBhbmQgYW4gb3B0aW9uYWwgaGVpZ2h0LlxuICogUXVlcnkgZm9ybWF0OiBgbG9uZ2l0dWRlIGxhdGl0dWRlIChoZWlnaHQpYCB3aXRoIGxvbmdpdHVkZS9sYXRpdHVkZSBpbiBkZWdyZWVzIGFuZCBoZWlnaHQgaW4gbWV0ZXJzLlxuICpcbiAqIEBhbGlhcyBDYXJ0b2dyYXBoaWNHZW9jb2RlclNlcnZpY2VcbiAqIEBjb25zdHJ1Y3RvclxuICovXG5mdW5jdGlvbiBDYXJ0b2dyYXBoaWNHZW9jb2RlclNlcnZpY2UoKSB7fVxuXG4vKipcbiAqIEBmdW5jdGlvblxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBxdWVyeSBUaGUgcXVlcnkgdG8gYmUgc2VudCB0byB0aGUgZ2VvY29kZXIgc2VydmljZVxuICogQHJldHVybnMge1Byb21pc2U8R2VvY29kZXJTZXJ2aWNlLlJlc3VsdFtdPn1cbiAqL1xuQ2FydG9ncmFwaGljR2VvY29kZXJTZXJ2aWNlLnByb3RvdHlwZS5nZW9jb2RlID0gZnVuY3Rpb24gKHF1ZXJ5KSB7XG4gIC8vPj5pbmNsdWRlU3RhcnQoJ2RlYnVnJywgcHJhZ21hcy5kZWJ1Zyk7XG4gIENoZWNrLnR5cGVPZi5zdHJpbmcoXCJxdWVyeVwiLCBxdWVyeSk7XG4gIC8vPj5pbmNsdWRlRW5kKCdkZWJ1ZycpO1xuXG4gIHZhciBzcGxpdFF1ZXJ5ID0gcXVlcnkubWF0Y2goL1teXFxzLFxcbl0rL2cpO1xuICBpZiAoc3BsaXRRdWVyeS5sZW5ndGggPT09IDIgfHwgc3BsaXRRdWVyeS5sZW5ndGggPT09IDMpIHtcbiAgICB2YXIgbG9uZ2l0dWRlID0gK3NwbGl0UXVlcnlbMF07XG4gICAgdmFyIGxhdGl0dWRlID0gK3NwbGl0UXVlcnlbMV07XG4gICAgdmFyIGhlaWdodCA9IHNwbGl0UXVlcnkubGVuZ3RoID09PSAzID8gK3NwbGl0UXVlcnlbMl0gOiAzMDAuMDtcblxuICAgIGlmIChpc05hTihsb25naXR1ZGUpICYmIGlzTmFOKGxhdGl0dWRlKSkge1xuICAgICAgdmFyIGNvb3JkVGVzdCA9IC9eKFxcZCsuP1xcZCopKFtuc2V3XSkvaTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc3BsaXRRdWVyeS5sZW5ndGg7ICsraSkge1xuICAgICAgICB2YXIgc3BsaXRDb29yZCA9IHNwbGl0UXVlcnlbaV0ubWF0Y2goY29vcmRUZXN0KTtcbiAgICAgICAgaWYgKGNvb3JkVGVzdC50ZXN0KHNwbGl0UXVlcnlbaV0pICYmIHNwbGl0Q29vcmQubGVuZ3RoID09PSAzKSB7XG4gICAgICAgICAgaWYgKC9eW25zXS9pLnRlc3Qoc3BsaXRDb29yZFsyXSkpIHtcbiAgICAgICAgICAgIGxhdGl0dWRlID0gL15bbl0vaS50ZXN0KHNwbGl0Q29vcmRbMl0pXG4gICAgICAgICAgICAgID8gK3NwbGl0Q29vcmRbMV1cbiAgICAgICAgICAgICAgOiAtc3BsaXRDb29yZFsxXTtcbiAgICAgICAgICB9IGVsc2UgaWYgKC9eW2V3XS9pLnRlc3Qoc3BsaXRDb29yZFsyXSkpIHtcbiAgICAgICAgICAgIGxvbmdpdHVkZSA9IC9eW2VdL2kudGVzdChzcGxpdENvb3JkWzJdKVxuICAgICAgICAgICAgICA/ICtzcGxpdENvb3JkWzFdXG4gICAgICAgICAgICAgIDogLXNwbGl0Q29vcmRbMV07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKCFpc05hTihsb25naXR1ZGUpICYmICFpc05hTihsYXRpdHVkZSkgJiYgIWlzTmFOKGhlaWdodCkpIHtcbiAgICAgIHZhciByZXN1bHQgPSB7XG4gICAgICAgIGRpc3BsYXlOYW1lOiBxdWVyeSxcbiAgICAgICAgZGVzdGluYXRpb246IENhcnRlc2lhbjMuZnJvbURlZ3JlZXMobG9uZ2l0dWRlLCBsYXRpdHVkZSwgaGVpZ2h0KSxcbiAgICAgIH07XG4gICAgICByZXR1cm4gd2hlbi5yZXNvbHZlKFtyZXN1bHRdKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHdoZW4ucmVzb2x2ZShbXSk7XG59O1xuZXhwb3J0IGRlZmF1bHQgQ2FydG9ncmFwaGljR2VvY29kZXJTZXJ2aWNlO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///13129\n')},9887:function(__unused_webpack___webpack_module__,__unused_webpack___webpack_exports__,__webpack_require__){eval('/* harmony import */ var _Cartesian3_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(60216);\n/* harmony import */ var _Cartesian4_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(63367);\n/* harmony import */ var _Check_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(66553);\n/* harmony import */ var _defaultValue_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(62200);\n/* harmony import */ var _defined_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(82982);\n/* harmony import */ var _HermiteSpline_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(41399);\n/* harmony import */ var _Matrix4_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(72248);\n/* harmony import */ var _Spline_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(84543);\n\n\n\n\n\n\n\n\n\nvar scratchTimeVec = new _Cartesian4_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .Z();\nvar scratchTemp0 = new _Cartesian3_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .Z();\nvar scratchTemp1 = new _Cartesian3_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .Z();\n\nfunction createEvaluateFunction(spline) {\n  var points = spline.points;\n  var times = spline.times;\n\n  if (points.length < 3) {\n    var t0 = times[0];\n    var invSpan = 1.0 / (times[1] - t0);\n\n    var p0 = points[0];\n    var p1 = points[1];\n\n    return function (time, result) {\n      if (!(0,_defined_js__WEBPACK_IMPORTED_MODULE_7__/* ["default"] */ .Z)(result)) {\n        result = new _Cartesian3_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .Z();\n      }\n      var u = (time - t0) * invSpan;\n      return _Cartesian3_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].lerp */ .Z.lerp(p0, p1, u, result);\n    };\n  }\n\n  return function (time, result) {\n    if (!(0,_defined_js__WEBPACK_IMPORTED_MODULE_7__/* ["default"] */ .Z)(result)) {\n      result = new _Cartesian3_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .Z();\n    }\n    var i = (spline._lastTimeIndex = spline.findTimeInterval(\n      time,\n      spline._lastTimeIndex\n    ));\n    var u = (time - times[i]) / (times[i + 1] - times[i]);\n\n    var timeVec = scratchTimeVec;\n    timeVec.z = u;\n    timeVec.y = u * u;\n    timeVec.x = timeVec.y * u;\n    timeVec.w = 1.0;\n\n    var p0;\n    var p1;\n    var p2;\n    var p3;\n    var coefs;\n\n    if (i === 0) {\n      p0 = points[0];\n      p1 = points[1];\n      p2 = spline.firstTangent;\n\n      p3 = _Cartesian3_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].subtract */ .Z.subtract(points[2], p0, scratchTemp0);\n      _Cartesian3_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].multiplyByScalar */ .Z.multiplyByScalar(p3, 0.5, p3);\n\n      coefs = _Matrix4_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"].multiplyByVector */ .Z.multiplyByVector(\n        _HermiteSpline_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"].hermiteCoefficientMatrix */ .Z.hermiteCoefficientMatrix,\n        timeVec,\n        timeVec\n      );\n    } else if (i === points.length - 2) {\n      p0 = points[i];\n      p1 = points[i + 1];\n      p3 = spline.lastTangent;\n\n      p2 = _Cartesian3_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].subtract */ .Z.subtract(p1, points[i - 1], scratchTemp0);\n      _Cartesian3_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].multiplyByScalar */ .Z.multiplyByScalar(p2, 0.5, p2);\n\n      coefs = _Matrix4_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"].multiplyByVector */ .Z.multiplyByVector(\n        _HermiteSpline_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"].hermiteCoefficientMatrix */ .Z.hermiteCoefficientMatrix,\n        timeVec,\n        timeVec\n      );\n    } else {\n      p0 = points[i - 1];\n      p1 = points[i];\n      p2 = points[i + 1];\n      p3 = points[i + 2];\n      coefs = _Matrix4_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"].multiplyByVector */ .Z.multiplyByVector(\n        CatmullRomSpline.catmullRomCoefficientMatrix,\n        timeVec,\n        timeVec\n      );\n    }\n    result = _Cartesian3_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].multiplyByScalar */ .Z.multiplyByScalar(p0, coefs.x, result);\n    _Cartesian3_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].multiplyByScalar */ .Z.multiplyByScalar(p1, coefs.y, scratchTemp1);\n    _Cartesian3_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].add */ .Z.add(result, scratchTemp1, result);\n    _Cartesian3_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].multiplyByScalar */ .Z.multiplyByScalar(p2, coefs.z, scratchTemp1);\n    _Cartesian3_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].add */ .Z.add(result, scratchTemp1, result);\n    _Cartesian3_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].multiplyByScalar */ .Z.multiplyByScalar(p3, coefs.w, scratchTemp1);\n    return _Cartesian3_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].add */ .Z.add(result, scratchTemp1, result);\n  };\n}\n\nvar firstTangentScratch = new _Cartesian3_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .Z();\nvar lastTangentScratch = new _Cartesian3_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .Z();\n\n/**\n * A Catmull-Rom spline is a cubic spline where the tangent at control points,\n * except the first and last, are computed using the previous and next control points.\n * Catmull-Rom splines are in the class C<sup>1</sup>.\n *\n * @alias CatmullRomSpline\n * @constructor\n *\n * @param {Object} options Object with the following properties:\n * @param {Number[]} options.times An array of strictly increasing, unit-less, floating-point times at each point.\n *                The values are in no way connected to the clock time. They are the parameterization for the curve.\n * @param {Cartesian3[]} options.points The array of {@link Cartesian3} control points.\n * @param {Cartesian3} [options.firstTangent] The tangent of the curve at the first control point.\n *                     If the tangent is not given, it will be estimated.\n * @param {Cartesian3} [options.lastTangent] The tangent of the curve at the last control point.\n *                     If the tangent is not given, it will be estimated.\n *\n * @exception {DeveloperError} points.length must be greater than or equal to 2.\n * @exception {DeveloperError} times.length must be equal to points.length.\n *\n *\n * @example\n * // spline above the earth from Philadelphia to Los Angeles\n * var spline = new Cesium.CatmullRomSpline({\n *     times : [ 0.0, 1.5, 3.0, 4.5, 6.0 ],\n *     points : [\n *         new Cesium.Cartesian3(1235398.0, -4810983.0, 4146266.0),\n *         new Cesium.Cartesian3(1372574.0, -5345182.0, 4606657.0),\n *         new Cesium.Cartesian3(-757983.0, -5542796.0, 4514323.0),\n *         new Cesium.Cartesian3(-2821260.0, -5248423.0, 4021290.0),\n *         new Cesium.Cartesian3(-2539788.0, -4724797.0, 3620093.0)\n *     ]\n * });\n *\n * var p0 = spline.evaluate(times[i]);         // equal to positions[i]\n * var p1 = spline.evaluate(times[i] + delta); // interpolated value when delta < times[i + 1] - times[i]\n *\n * @see HermiteSpline\n * @see LinearSpline\n * @see QuaternionSpline\n * @see WeightSpline\n */\nfunction CatmullRomSpline(options) {\n  options = (0,_defaultValue_js__WEBPACK_IMPORTED_MODULE_3__/* ["default"] */ .Z)(options, _defaultValue_js__WEBPACK_IMPORTED_MODULE_3__/* ["default"].EMPTY_OBJECT */ .Z.EMPTY_OBJECT);\n\n  var points = options.points;\n  var times = options.times;\n  var firstTangent = options.firstTangent;\n  var lastTangent = options.lastTangent;\n\n  //>>includeStart(\'debug\', pragmas.debug);\n  _Check_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"].defined */ .Z.defined("points", points);\n  _Check_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"].defined */ .Z.defined("times", times);\n  _Check_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"].typeOf.number.greaterThanOrEquals */ .Z.typeOf.number.greaterThanOrEquals("points.length", points.length, 2);\n  _Check_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"].typeOf.number.equals */ .Z.typeOf.number.equals(\n    "times.length",\n    "points.length",\n    times.length,\n    points.length\n  );\n  //>>includeEnd(\'debug\');\n\n  if (points.length > 2) {\n    if (!(0,_defined_js__WEBPACK_IMPORTED_MODULE_7__/* ["default"] */ .Z)(firstTangent)) {\n      firstTangent = firstTangentScratch;\n      _Cartesian3_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].multiplyByScalar */ .Z.multiplyByScalar(points[1], 2.0, firstTangent);\n      _Cartesian3_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].subtract */ .Z.subtract(firstTangent, points[2], firstTangent);\n      _Cartesian3_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].subtract */ .Z.subtract(firstTangent, points[0], firstTangent);\n      _Cartesian3_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].multiplyByScalar */ .Z.multiplyByScalar(firstTangent, 0.5, firstTangent);\n    }\n\n    if (!(0,_defined_js__WEBPACK_IMPORTED_MODULE_7__/* ["default"] */ .Z)(lastTangent)) {\n      var n = points.length - 1;\n      lastTangent = lastTangentScratch;\n      _Cartesian3_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].multiplyByScalar */ .Z.multiplyByScalar(points[n - 1], 2.0, lastTangent);\n      _Cartesian3_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].subtract */ .Z.subtract(points[n], lastTangent, lastTangent);\n      _Cartesian3_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].add */ .Z.add(lastTangent, points[n - 2], lastTangent);\n      _Cartesian3_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].multiplyByScalar */ .Z.multiplyByScalar(lastTangent, 0.5, lastTangent);\n    }\n  }\n\n  this._times = times;\n  this._points = points;\n  this._firstTangent = _Cartesian3_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].clone */ .Z.clone(firstTangent);\n  this._lastTangent = _Cartesian3_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].clone */ .Z.clone(lastTangent);\n\n  this._evaluateFunction = createEvaluateFunction(this);\n  this._lastTimeIndex = 0;\n}\n\nObject.defineProperties(CatmullRomSpline.prototype, {\n  /**\n   * An array of times for the control points.\n   *\n   * @memberof CatmullRomSpline.prototype\n   *\n   * @type {Number[]}\n   * @readonly\n   */\n  times: {\n    get: function () {\n      return this._times;\n    },\n  },\n\n  /**\n   * An array of {@link Cartesian3} control points.\n   *\n   * @memberof CatmullRomSpline.prototype\n   *\n   * @type {Cartesian3[]}\n   * @readonly\n   */\n  points: {\n    get: function () {\n      return this._points;\n    },\n  },\n\n  /**\n   * The tangent at the first control point.\n   *\n   * @memberof CatmullRomSpline.prototype\n   *\n   * @type {Cartesian3}\n   * @readonly\n   */\n  firstTangent: {\n    get: function () {\n      return this._firstTangent;\n    },\n  },\n\n  /**\n   * The tangent at the last control point.\n   *\n   * @memberof CatmullRomSpline.prototype\n   *\n   * @type {Cartesian3}\n   * @readonly\n   */\n  lastTangent: {\n    get: function () {\n      return this._lastTangent;\n    },\n  },\n});\n\n/**\n * @private\n */\nCatmullRomSpline.catmullRomCoefficientMatrix = new _Matrix4_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"] */ .Z(\n  -0.5,\n  1.0,\n  -0.5,\n  0.0,\n  1.5,\n  -2.5,\n  0.0,\n  1.0,\n  -1.5,\n  2.0,\n  0.5,\n  0.0,\n  0.5,\n  -0.5,\n  0.0,\n  0.0\n);\n\n/**\n * Finds an index <code>i</code> in <code>times</code> such that the parameter\n * <code>time</code> is in the interval <code>[times[i], times[i + 1]]</code>.\n * @function\n *\n * @param {Number} time The time.\n * @returns {Number} The index for the element at the start of the interval.\n *\n * @exception {DeveloperError} time must be in the range <code>[t<sub>0</sub>, t<sub>n</sub>]</code>, where <code>t<sub>0</sub></code>\n *                             is the first element in the array <code>times</code> and <code>t<sub>n</sub></code> is the last element\n *                             in the array <code>times</code>.\n */\nCatmullRomSpline.prototype.findTimeInterval = _Spline_js__WEBPACK_IMPORTED_MODULE_6__/* ["default"].prototype.findTimeInterval */ .Z.prototype.findTimeInterval;\n\n/**\n * Wraps the given time to the period covered by the spline.\n * @function\n *\n * @param {Number} time The time.\n * @return {Number} The time, wrapped around to the updated animation.\n */\nCatmullRomSpline.prototype.wrapTime = _Spline_js__WEBPACK_IMPORTED_MODULE_6__/* ["default"].prototype.wrapTime */ .Z.prototype.wrapTime;\n\n/**\n * Clamps the given time to the period covered by the spline.\n * @function\n *\n * @param {Number} time The time.\n * @return {Number} The time, clamped to the animation period.\n */\nCatmullRomSpline.prototype.clampTime = _Spline_js__WEBPACK_IMPORTED_MODULE_6__/* ["default"].prototype.clampTime */ .Z.prototype.clampTime;\n\n/**\n * Evaluates the curve at a given time.\n *\n * @param {Number} time The time at which to evaluate the curve.\n * @param {Cartesian3} [result] The object onto which to store the result.\n * @returns {Cartesian3} The modified result parameter or a new instance of the point on the curve at the given time.\n *\n * @exception {DeveloperError} time must be in the range <code>[t<sub>0</sub>, t<sub>n</sub>]</code>, where <code>t<sub>0</sub></code>\n *                             is the first element in the array <code>times</code> and <code>t<sub>n</sub></code> is the last element\n *                             in the array <code>times</code>.\n */\nCatmullRomSpline.prototype.evaluate = function (time, result) {\n  return this._evaluateFunction(time, result);\n};\n/* unused harmony default export */ var __WEBPACK_DEFAULT_EXPORT__ = ((/* unused pure expression or super */ null && (CatmullRomSpline)));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QUFLO0FBQ0wsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNILENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0EsbURBQW1ELDREQUFPO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixhQUFhLFFBQVE7QUFDckI7QUFDQSxlQUFlLGdCQUFnQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsaUhBQWlDOztBQUUvRTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixZQUFZLFFBQVE7QUFDcEI7QUFDQSxzQ0FBc0MsaUdBQXlCOztBQUUvRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixZQUFZLFFBQVE7QUFDcEI7QUFDQSx1Q0FBdUMsbUdBQTBCOztBQUVqRTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxZQUFZO0FBQ3ZCLGFBQWEsWUFBWTtBQUN6QjtBQUNBLGVBQWUsZ0JBQWdCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNFQUFlLGdFQUFnQixJQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdnVlMy13ZWJwYWNrNS8uL25vZGVfbW9kdWxlcy9jZXNpdW0vU291cmNlL0NvcmUvQ2F0bXVsbFJvbVNwbGluZS5qcz8yZDM3Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBDYXJ0ZXNpYW4zIGZyb20gXCIuL0NhcnRlc2lhbjMuanNcIjtcbmltcG9ydCBDYXJ0ZXNpYW40IGZyb20gXCIuL0NhcnRlc2lhbjQuanNcIjtcbmltcG9ydCBDaGVjayBmcm9tIFwiLi9DaGVjay5qc1wiO1xuaW1wb3J0IGRlZmF1bHRWYWx1ZSBmcm9tIFwiLi9kZWZhdWx0VmFsdWUuanNcIjtcbmltcG9ydCBkZWZpbmVkIGZyb20gXCIuL2RlZmluZWQuanNcIjtcbmltcG9ydCBIZXJtaXRlU3BsaW5lIGZyb20gXCIuL0hlcm1pdGVTcGxpbmUuanNcIjtcbmltcG9ydCBNYXRyaXg0IGZyb20gXCIuL01hdHJpeDQuanNcIjtcbmltcG9ydCBTcGxpbmUgZnJvbSBcIi4vU3BsaW5lLmpzXCI7XG5cbnZhciBzY3JhdGNoVGltZVZlYyA9IG5ldyBDYXJ0ZXNpYW40KCk7XG52YXIgc2NyYXRjaFRlbXAwID0gbmV3IENhcnRlc2lhbjMoKTtcbnZhciBzY3JhdGNoVGVtcDEgPSBuZXcgQ2FydGVzaWFuMygpO1xuXG5mdW5jdGlvbiBjcmVhdGVFdmFsdWF0ZUZ1bmN0aW9uKHNwbGluZSkge1xuICB2YXIgcG9pbnRzID0gc3BsaW5lLnBvaW50cztcbiAgdmFyIHRpbWVzID0gc3BsaW5lLnRpbWVzO1xuXG4gIGlmIChwb2ludHMubGVuZ3RoIDwgMykge1xuICAgIHZhciB0MCA9IHRpbWVzWzBdO1xuICAgIHZhciBpbnZTcGFuID0gMS4wIC8gKHRpbWVzWzFdIC0gdDApO1xuXG4gICAgdmFyIHAwID0gcG9pbnRzWzBdO1xuICAgIHZhciBwMSA9IHBvaW50c1sxXTtcblxuICAgIHJldHVybiBmdW5jdGlvbiAodGltZSwgcmVzdWx0KSB7XG4gICAgICBpZiAoIWRlZmluZWQocmVzdWx0KSkge1xuICAgICAgICByZXN1bHQgPSBuZXcgQ2FydGVzaWFuMygpO1xuICAgICAgfVxuICAgICAgdmFyIHUgPSAodGltZSAtIHQwKSAqIGludlNwYW47XG4gICAgICByZXR1cm4gQ2FydGVzaWFuMy5sZXJwKHAwLCBwMSwgdSwgcmVzdWx0KTtcbiAgICB9O1xuICB9XG5cbiAgcmV0dXJuIGZ1bmN0aW9uICh0aW1lLCByZXN1bHQpIHtcbiAgICBpZiAoIWRlZmluZWQocmVzdWx0KSkge1xuICAgICAgcmVzdWx0ID0gbmV3IENhcnRlc2lhbjMoKTtcbiAgICB9XG4gICAgdmFyIGkgPSAoc3BsaW5lLl9sYXN0VGltZUluZGV4ID0gc3BsaW5lLmZpbmRUaW1lSW50ZXJ2YWwoXG4gICAgICB0aW1lLFxuICAgICAgc3BsaW5lLl9sYXN0VGltZUluZGV4XG4gICAgKSk7XG4gICAgdmFyIHUgPSAodGltZSAtIHRpbWVzW2ldKSAvICh0aW1lc1tpICsgMV0gLSB0aW1lc1tpXSk7XG5cbiAgICB2YXIgdGltZVZlYyA9IHNjcmF0Y2hUaW1lVmVjO1xuICAgIHRpbWVWZWMueiA9IHU7XG4gICAgdGltZVZlYy55ID0gdSAqIHU7XG4gICAgdGltZVZlYy54ID0gdGltZVZlYy55ICogdTtcbiAgICB0aW1lVmVjLncgPSAxLjA7XG5cbiAgICB2YXIgcDA7XG4gICAgdmFyIHAxO1xuICAgIHZhciBwMjtcbiAgICB2YXIgcDM7XG4gICAgdmFyIGNvZWZzO1xuXG4gICAgaWYgKGkgPT09IDApIHtcbiAgICAgIHAwID0gcG9pbnRzWzBdO1xuICAgICAgcDEgPSBwb2ludHNbMV07XG4gICAgICBwMiA9IHNwbGluZS5maXJzdFRhbmdlbnQ7XG5cbiAgICAgIHAzID0gQ2FydGVzaWFuMy5zdWJ0cmFjdChwb2ludHNbMl0sIHAwLCBzY3JhdGNoVGVtcDApO1xuICAgICAgQ2FydGVzaWFuMy5tdWx0aXBseUJ5U2NhbGFyKHAzLCAwLjUsIHAzKTtcblxuICAgICAgY29lZnMgPSBNYXRyaXg0Lm11bHRpcGx5QnlWZWN0b3IoXG4gICAgICAgIEhlcm1pdGVTcGxpbmUuaGVybWl0ZUNvZWZmaWNpZW50TWF0cml4LFxuICAgICAgICB0aW1lVmVjLFxuICAgICAgICB0aW1lVmVjXG4gICAgICApO1xuICAgIH0gZWxzZSBpZiAoaSA9PT0gcG9pbnRzLmxlbmd0aCAtIDIpIHtcbiAgICAgIHAwID0gcG9pbnRzW2ldO1xuICAgICAgcDEgPSBwb2ludHNbaSArIDFdO1xuICAgICAgcDMgPSBzcGxpbmUubGFzdFRhbmdlbnQ7XG5cbiAgICAgIHAyID0gQ2FydGVzaWFuMy5zdWJ0cmFjdChwMSwgcG9pbnRzW2kgLSAxXSwgc2NyYXRjaFRlbXAwKTtcbiAgICAgIENhcnRlc2lhbjMubXVsdGlwbHlCeVNjYWxhcihwMiwgMC41LCBwMik7XG5cbiAgICAgIGNvZWZzID0gTWF0cml4NC5tdWx0aXBseUJ5VmVjdG9yKFxuICAgICAgICBIZXJtaXRlU3BsaW5lLmhlcm1pdGVDb2VmZmljaWVudE1hdHJpeCxcbiAgICAgICAgdGltZVZlYyxcbiAgICAgICAgdGltZVZlY1xuICAgICAgKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcDAgPSBwb2ludHNbaSAtIDFdO1xuICAgICAgcDEgPSBwb2ludHNbaV07XG4gICAgICBwMiA9IHBvaW50c1tpICsgMV07XG4gICAgICBwMyA9IHBvaW50c1tpICsgMl07XG4gICAgICBjb2VmcyA9IE1hdHJpeDQubXVsdGlwbHlCeVZlY3RvcihcbiAgICAgICAgQ2F0bXVsbFJvbVNwbGluZS5jYXRtdWxsUm9tQ29lZmZpY2llbnRNYXRyaXgsXG4gICAgICAgIHRpbWVWZWMsXG4gICAgICAgIHRpbWVWZWNcbiAgICAgICk7XG4gICAgfVxuICAgIHJlc3VsdCA9IENhcnRlc2lhbjMubXVsdGlwbHlCeVNjYWxhcihwMCwgY29lZnMueCwgcmVzdWx0KTtcbiAgICBDYXJ0ZXNpYW4zLm11bHRpcGx5QnlTY2FsYXIocDEsIGNvZWZzLnksIHNjcmF0Y2hUZW1wMSk7XG4gICAgQ2FydGVzaWFuMy5hZGQocmVzdWx0LCBzY3JhdGNoVGVtcDEsIHJlc3VsdCk7XG4gICAgQ2FydGVzaWFuMy5tdWx0aXBseUJ5U2NhbGFyKHAyLCBjb2Vmcy56LCBzY3JhdGNoVGVtcDEpO1xuICAgIENhcnRlc2lhbjMuYWRkKHJlc3VsdCwgc2NyYXRjaFRlbXAxLCByZXN1bHQpO1xuICAgIENhcnRlc2lhbjMubXVsdGlwbHlCeVNjYWxhcihwMywgY29lZnMudywgc2NyYXRjaFRlbXAxKTtcbiAgICByZXR1cm4gQ2FydGVzaWFuMy5hZGQocmVzdWx0LCBzY3JhdGNoVGVtcDEsIHJlc3VsdCk7XG4gIH07XG59XG5cbnZhciBmaXJzdFRhbmdlbnRTY3JhdGNoID0gbmV3IENhcnRlc2lhbjMoKTtcbnZhciBsYXN0VGFuZ2VudFNjcmF0Y2ggPSBuZXcgQ2FydGVzaWFuMygpO1xuXG4vKipcbiAqIEEgQ2F0bXVsbC1Sb20gc3BsaW5lIGlzIGEgY3ViaWMgc3BsaW5lIHdoZXJlIHRoZSB0YW5nZW50IGF0IGNvbnRyb2wgcG9pbnRzLFxuICogZXhjZXB0IHRoZSBmaXJzdCBhbmQgbGFzdCwgYXJlIGNvbXB1dGVkIHVzaW5nIHRoZSBwcmV2aW91cyBhbmQgbmV4dCBjb250cm9sIHBvaW50cy5cbiAqIENhdG11bGwtUm9tIHNwbGluZXMgYXJlIGluIHRoZSBjbGFzcyBDPHN1cD4xPC9zdXA+LlxuICpcbiAqIEBhbGlhcyBDYXRtdWxsUm9tU3BsaW5lXG4gKiBAY29uc3RydWN0b3JcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyBPYmplY3Qgd2l0aCB0aGUgZm9sbG93aW5nIHByb3BlcnRpZXM6XG4gKiBAcGFyYW0ge051bWJlcltdfSBvcHRpb25zLnRpbWVzIEFuIGFycmF5IG9mIHN0cmljdGx5IGluY3JlYXNpbmcsIHVuaXQtbGVzcywgZmxvYXRpbmctcG9pbnQgdGltZXMgYXQgZWFjaCBwb2ludC5cbiAqICAgICAgICAgICAgICAgIFRoZSB2YWx1ZXMgYXJlIGluIG5vIHdheSBjb25uZWN0ZWQgdG8gdGhlIGNsb2NrIHRpbWUuIFRoZXkgYXJlIHRoZSBwYXJhbWV0ZXJpemF0aW9uIGZvciB0aGUgY3VydmUuXG4gKiBAcGFyYW0ge0NhcnRlc2lhbjNbXX0gb3B0aW9ucy5wb2ludHMgVGhlIGFycmF5IG9mIHtAbGluayBDYXJ0ZXNpYW4zfSBjb250cm9sIHBvaW50cy5cbiAqIEBwYXJhbSB7Q2FydGVzaWFuM30gW29wdGlvbnMuZmlyc3RUYW5nZW50XSBUaGUgdGFuZ2VudCBvZiB0aGUgY3VydmUgYXQgdGhlIGZpcnN0IGNvbnRyb2wgcG9pbnQuXG4gKiAgICAgICAgICAgICAgICAgICAgIElmIHRoZSB0YW5nZW50IGlzIG5vdCBnaXZlbiwgaXQgd2lsbCBiZSBlc3RpbWF0ZWQuXG4gKiBAcGFyYW0ge0NhcnRlc2lhbjN9IFtvcHRpb25zLmxhc3RUYW5nZW50XSBUaGUgdGFuZ2VudCBvZiB0aGUgY3VydmUgYXQgdGhlIGxhc3QgY29udHJvbCBwb2ludC5cbiAqICAgICAgICAgICAgICAgICAgICAgSWYgdGhlIHRhbmdlbnQgaXMgbm90IGdpdmVuLCBpdCB3aWxsIGJlIGVzdGltYXRlZC5cbiAqXG4gKiBAZXhjZXB0aW9uIHtEZXZlbG9wZXJFcnJvcn0gcG9pbnRzLmxlbmd0aCBtdXN0IGJlIGdyZWF0ZXIgdGhhbiBvciBlcXVhbCB0byAyLlxuICogQGV4Y2VwdGlvbiB7RGV2ZWxvcGVyRXJyb3J9IHRpbWVzLmxlbmd0aCBtdXN0IGJlIGVxdWFsIHRvIHBvaW50cy5sZW5ndGguXG4gKlxuICpcbiAqIEBleGFtcGxlXG4gKiAvLyBzcGxpbmUgYWJvdmUgdGhlIGVhcnRoIGZyb20gUGhpbGFkZWxwaGlhIHRvIExvcyBBbmdlbGVzXG4gKiB2YXIgc3BsaW5lID0gbmV3IENlc2l1bS5DYXRtdWxsUm9tU3BsaW5lKHtcbiAqICAgICB0aW1lcyA6IFsgMC4wLCAxLjUsIDMuMCwgNC41LCA2LjAgXSxcbiAqICAgICBwb2ludHMgOiBbXG4gKiAgICAgICAgIG5ldyBDZXNpdW0uQ2FydGVzaWFuMygxMjM1Mzk4LjAsIC00ODEwOTgzLjAsIDQxNDYyNjYuMCksXG4gKiAgICAgICAgIG5ldyBDZXNpdW0uQ2FydGVzaWFuMygxMzcyNTc0LjAsIC01MzQ1MTgyLjAsIDQ2MDY2NTcuMCksXG4gKiAgICAgICAgIG5ldyBDZXNpdW0uQ2FydGVzaWFuMygtNzU3OTgzLjAsIC01NTQyNzk2LjAsIDQ1MTQzMjMuMCksXG4gKiAgICAgICAgIG5ldyBDZXNpdW0uQ2FydGVzaWFuMygtMjgyMTI2MC4wLCAtNTI0ODQyMy4wLCA0MDIxMjkwLjApLFxuICogICAgICAgICBuZXcgQ2VzaXVtLkNhcnRlc2lhbjMoLTI1Mzk3ODguMCwgLTQ3MjQ3OTcuMCwgMzYyMDA5My4wKVxuICogICAgIF1cbiAqIH0pO1xuICpcbiAqIHZhciBwMCA9IHNwbGluZS5ldmFsdWF0ZSh0aW1lc1tpXSk7ICAgICAgICAgLy8gZXF1YWwgdG8gcG9zaXRpb25zW2ldXG4gKiB2YXIgcDEgPSBzcGxpbmUuZXZhbHVhdGUodGltZXNbaV0gKyBkZWx0YSk7IC8vIGludGVycG9sYXRlZCB2YWx1ZSB3aGVuIGRlbHRhIDwgdGltZXNbaSArIDFdIC0gdGltZXNbaV1cbiAqXG4gKiBAc2VlIEhlcm1pdGVTcGxpbmVcbiAqIEBzZWUgTGluZWFyU3BsaW5lXG4gKiBAc2VlIFF1YXRlcm5pb25TcGxpbmVcbiAqIEBzZWUgV2VpZ2h0U3BsaW5lXG4gKi9cbmZ1bmN0aW9uIENhdG11bGxSb21TcGxpbmUob3B0aW9ucykge1xuICBvcHRpb25zID0gZGVmYXVsdFZhbHVlKG9wdGlvbnMsIGRlZmF1bHRWYWx1ZS5FTVBUWV9PQkpFQ1QpO1xuXG4gIHZhciBwb2ludHMgPSBvcHRpb25zLnBvaW50cztcbiAgdmFyIHRpbWVzID0gb3B0aW9ucy50aW1lcztcbiAgdmFyIGZpcnN0VGFuZ2VudCA9IG9wdGlvbnMuZmlyc3RUYW5nZW50O1xuICB2YXIgbGFzdFRhbmdlbnQgPSBvcHRpb25zLmxhc3RUYW5nZW50O1xuXG4gIC8vPj5pbmNsdWRlU3RhcnQoJ2RlYnVnJywgcHJhZ21hcy5kZWJ1Zyk7XG4gIENoZWNrLmRlZmluZWQoXCJwb2ludHNcIiwgcG9pbnRzKTtcbiAgQ2hlY2suZGVmaW5lZChcInRpbWVzXCIsIHRpbWVzKTtcbiAgQ2hlY2sudHlwZU9mLm51bWJlci5ncmVhdGVyVGhhbk9yRXF1YWxzKFwicG9pbnRzLmxlbmd0aFwiLCBwb2ludHMubGVuZ3RoLCAyKTtcbiAgQ2hlY2sudHlwZU9mLm51bWJlci5lcXVhbHMoXG4gICAgXCJ0aW1lcy5sZW5ndGhcIixcbiAgICBcInBvaW50cy5sZW5ndGhcIixcbiAgICB0aW1lcy5sZW5ndGgsXG4gICAgcG9pbnRzLmxlbmd0aFxuICApO1xuICAvLz4+aW5jbHVkZUVuZCgnZGVidWcnKTtcblxuICBpZiAocG9pbnRzLmxlbmd0aCA+IDIpIHtcbiAgICBpZiAoIWRlZmluZWQoZmlyc3RUYW5nZW50KSkge1xuICAgICAgZmlyc3RUYW5nZW50ID0gZmlyc3RUYW5nZW50U2NyYXRjaDtcbiAgICAgIENhcnRlc2lhbjMubXVsdGlwbHlCeVNjYWxhcihwb2ludHNbMV0sIDIuMCwgZmlyc3RUYW5nZW50KTtcbiAgICAgIENhcnRlc2lhbjMuc3VidHJhY3QoZmlyc3RUYW5nZW50LCBwb2ludHNbMl0sIGZpcnN0VGFuZ2VudCk7XG4gICAgICBDYXJ0ZXNpYW4zLnN1YnRyYWN0KGZpcnN0VGFuZ2VudCwgcG9pbnRzWzBdLCBmaXJzdFRhbmdlbnQpO1xuICAgICAgQ2FydGVzaWFuMy5tdWx0aXBseUJ5U2NhbGFyKGZpcnN0VGFuZ2VudCwgMC41LCBmaXJzdFRhbmdlbnQpO1xuICAgIH1cblxuICAgIGlmICghZGVmaW5lZChsYXN0VGFuZ2VudCkpIHtcbiAgICAgIHZhciBuID0gcG9pbnRzLmxlbmd0aCAtIDE7XG4gICAgICBsYXN0VGFuZ2VudCA9IGxhc3RUYW5nZW50U2NyYXRjaDtcbiAgICAgIENhcnRlc2lhbjMubXVsdGlwbHlCeVNjYWxhcihwb2ludHNbbiAtIDFdLCAyLjAsIGxhc3RUYW5nZW50KTtcbiAgICAgIENhcnRlc2lhbjMuc3VidHJhY3QocG9pbnRzW25dLCBsYXN0VGFuZ2VudCwgbGFzdFRhbmdlbnQpO1xuICAgICAgQ2FydGVzaWFuMy5hZGQobGFzdFRhbmdlbnQsIHBvaW50c1tuIC0gMl0sIGxhc3RUYW5nZW50KTtcbiAgICAgIENhcnRlc2lhbjMubXVsdGlwbHlCeVNjYWxhcihsYXN0VGFuZ2VudCwgMC41LCBsYXN0VGFuZ2VudCk7XG4gICAgfVxuICB9XG5cbiAgdGhpcy5fdGltZXMgPSB0aW1lcztcbiAgdGhpcy5fcG9pbnRzID0gcG9pbnRzO1xuICB0aGlzLl9maXJzdFRhbmdlbnQgPSBDYXJ0ZXNpYW4zLmNsb25lKGZpcnN0VGFuZ2VudCk7XG4gIHRoaXMuX2xhc3RUYW5nZW50ID0gQ2FydGVzaWFuMy5jbG9uZShsYXN0VGFuZ2VudCk7XG5cbiAgdGhpcy5fZXZhbHVhdGVGdW5jdGlvbiA9IGNyZWF0ZUV2YWx1YXRlRnVuY3Rpb24odGhpcyk7XG4gIHRoaXMuX2xhc3RUaW1lSW5kZXggPSAwO1xufVxuXG5PYmplY3QuZGVmaW5lUHJvcGVydGllcyhDYXRtdWxsUm9tU3BsaW5lLnByb3RvdHlwZSwge1xuICAvKipcbiAgICogQW4gYXJyYXkgb2YgdGltZXMgZm9yIHRoZSBjb250cm9sIHBvaW50cy5cbiAgICpcbiAgICogQG1lbWJlcm9mIENhdG11bGxSb21TcGxpbmUucHJvdG90eXBlXG4gICAqXG4gICAqIEB0eXBlIHtOdW1iZXJbXX1cbiAgICogQHJlYWRvbmx5XG4gICAqL1xuICB0aW1lczoge1xuICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX3RpbWVzO1xuICAgIH0sXG4gIH0sXG5cbiAgLyoqXG4gICAqIEFuIGFycmF5IG9mIHtAbGluayBDYXJ0ZXNpYW4zfSBjb250cm9sIHBvaW50cy5cbiAgICpcbiAgICogQG1lbWJlcm9mIENhdG11bGxSb21TcGxpbmUucHJvdG90eXBlXG4gICAqXG4gICAqIEB0eXBlIHtDYXJ0ZXNpYW4zW119XG4gICAqIEByZWFkb25seVxuICAgKi9cbiAgcG9pbnRzOiB7XG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fcG9pbnRzO1xuICAgIH0sXG4gIH0sXG5cbiAgLyoqXG4gICAqIFRoZSB0YW5nZW50IGF0IHRoZSBmaXJzdCBjb250cm9sIHBvaW50LlxuICAgKlxuICAgKiBAbWVtYmVyb2YgQ2F0bXVsbFJvbVNwbGluZS5wcm90b3R5cGVcbiAgICpcbiAgICogQHR5cGUge0NhcnRlc2lhbjN9XG4gICAqIEByZWFkb25seVxuICAgKi9cbiAgZmlyc3RUYW5nZW50OiB7XG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fZmlyc3RUYW5nZW50O1xuICAgIH0sXG4gIH0sXG5cbiAgLyoqXG4gICAqIFRoZSB0YW5nZW50IGF0IHRoZSBsYXN0IGNvbnRyb2wgcG9pbnQuXG4gICAqXG4gICAqIEBtZW1iZXJvZiBDYXRtdWxsUm9tU3BsaW5lLnByb3RvdHlwZVxuICAgKlxuICAgKiBAdHlwZSB7Q2FydGVzaWFuM31cbiAgICogQHJlYWRvbmx5XG4gICAqL1xuICBsYXN0VGFuZ2VudDoge1xuICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX2xhc3RUYW5nZW50O1xuICAgIH0sXG4gIH0sXG59KTtcblxuLyoqXG4gKiBAcHJpdmF0ZVxuICovXG5DYXRtdWxsUm9tU3BsaW5lLmNhdG11bGxSb21Db2VmZmljaWVudE1hdHJpeCA9IG5ldyBNYXRyaXg0KFxuICAtMC41LFxuICAxLjAsXG4gIC0wLjUsXG4gIDAuMCxcbiAgMS41LFxuICAtMi41LFxuICAwLjAsXG4gIDEuMCxcbiAgLTEuNSxcbiAgMi4wLFxuICAwLjUsXG4gIDAuMCxcbiAgMC41LFxuICAtMC41LFxuICAwLjAsXG4gIDAuMFxuKTtcblxuLyoqXG4gKiBGaW5kcyBhbiBpbmRleCA8Y29kZT5pPC9jb2RlPiBpbiA8Y29kZT50aW1lczwvY29kZT4gc3VjaCB0aGF0IHRoZSBwYXJhbWV0ZXJcbiAqIDxjb2RlPnRpbWU8L2NvZGU+IGlzIGluIHRoZSBpbnRlcnZhbCA8Y29kZT5bdGltZXNbaV0sIHRpbWVzW2kgKyAxXV08L2NvZGU+LlxuICogQGZ1bmN0aW9uXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IHRpbWUgVGhlIHRpbWUuXG4gKiBAcmV0dXJucyB7TnVtYmVyfSBUaGUgaW5kZXggZm9yIHRoZSBlbGVtZW50IGF0IHRoZSBzdGFydCBvZiB0aGUgaW50ZXJ2YWwuXG4gKlxuICogQGV4Y2VwdGlvbiB7RGV2ZWxvcGVyRXJyb3J9IHRpbWUgbXVzdCBiZSBpbiB0aGUgcmFuZ2UgPGNvZGU+W3Q8c3ViPjA8L3N1Yj4sIHQ8c3ViPm48L3N1Yj5dPC9jb2RlPiwgd2hlcmUgPGNvZGU+dDxzdWI+MDwvc3ViPjwvY29kZT5cbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpcyB0aGUgZmlyc3QgZWxlbWVudCBpbiB0aGUgYXJyYXkgPGNvZGU+dGltZXM8L2NvZGU+IGFuZCA8Y29kZT50PHN1Yj5uPC9zdWI+PC9jb2RlPiBpcyB0aGUgbGFzdCBlbGVtZW50XG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW4gdGhlIGFycmF5IDxjb2RlPnRpbWVzPC9jb2RlPi5cbiAqL1xuQ2F0bXVsbFJvbVNwbGluZS5wcm90b3R5cGUuZmluZFRpbWVJbnRlcnZhbCA9IFNwbGluZS5wcm90b3R5cGUuZmluZFRpbWVJbnRlcnZhbDtcblxuLyoqXG4gKiBXcmFwcyB0aGUgZ2l2ZW4gdGltZSB0byB0aGUgcGVyaW9kIGNvdmVyZWQgYnkgdGhlIHNwbGluZS5cbiAqIEBmdW5jdGlvblxuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSB0aW1lIFRoZSB0aW1lLlxuICogQHJldHVybiB7TnVtYmVyfSBUaGUgdGltZSwgd3JhcHBlZCBhcm91bmQgdG8gdGhlIHVwZGF0ZWQgYW5pbWF0aW9uLlxuICovXG5DYXRtdWxsUm9tU3BsaW5lLnByb3RvdHlwZS53cmFwVGltZSA9IFNwbGluZS5wcm90b3R5cGUud3JhcFRpbWU7XG5cbi8qKlxuICogQ2xhbXBzIHRoZSBnaXZlbiB0aW1lIHRvIHRoZSBwZXJpb2QgY292ZXJlZCBieSB0aGUgc3BsaW5lLlxuICogQGZ1bmN0aW9uXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IHRpbWUgVGhlIHRpbWUuXG4gKiBAcmV0dXJuIHtOdW1iZXJ9IFRoZSB0aW1lLCBjbGFtcGVkIHRvIHRoZSBhbmltYXRpb24gcGVyaW9kLlxuICovXG5DYXRtdWxsUm9tU3BsaW5lLnByb3RvdHlwZS5jbGFtcFRpbWUgPSBTcGxpbmUucHJvdG90eXBlLmNsYW1wVGltZTtcblxuLyoqXG4gKiBFdmFsdWF0ZXMgdGhlIGN1cnZlIGF0IGEgZ2l2ZW4gdGltZS5cbiAqXG4gKiBAcGFyYW0ge051bWJlcn0gdGltZSBUaGUgdGltZSBhdCB3aGljaCB0byBldmFsdWF0ZSB0aGUgY3VydmUuXG4gKiBAcGFyYW0ge0NhcnRlc2lhbjN9IFtyZXN1bHRdIFRoZSBvYmplY3Qgb250byB3aGljaCB0byBzdG9yZSB0aGUgcmVzdWx0LlxuICogQHJldHVybnMge0NhcnRlc2lhbjN9IFRoZSBtb2RpZmllZCByZXN1bHQgcGFyYW1ldGVyIG9yIGEgbmV3IGluc3RhbmNlIG9mIHRoZSBwb2ludCBvbiB0aGUgY3VydmUgYXQgdGhlIGdpdmVuIHRpbWUuXG4gKlxuICogQGV4Y2VwdGlvbiB7RGV2ZWxvcGVyRXJyb3J9IHRpbWUgbXVzdCBiZSBpbiB0aGUgcmFuZ2UgPGNvZGU+W3Q8c3ViPjA8L3N1Yj4sIHQ8c3ViPm48L3N1Yj5dPC9jb2RlPiwgd2hlcmUgPGNvZGU+dDxzdWI+MDwvc3ViPjwvY29kZT5cbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpcyB0aGUgZmlyc3QgZWxlbWVudCBpbiB0aGUgYXJyYXkgPGNvZGU+dGltZXM8L2NvZGU+IGFuZCA8Y29kZT50PHN1Yj5uPC9zdWI+PC9jb2RlPiBpcyB0aGUgbGFzdCBlbGVtZW50XG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW4gdGhlIGFycmF5IDxjb2RlPnRpbWVzPC9jb2RlPi5cbiAqL1xuQ2F0bXVsbFJvbVNwbGluZS5wcm90b3R5cGUuZXZhbHVhdGUgPSBmdW5jdGlvbiAodGltZSwgcmVzdWx0KSB7XG4gIHJldHVybiB0aGlzLl9ldmFsdWF0ZUZ1bmN0aW9uKHRpbWUsIHJlc3VsdCk7XG59O1xuZXhwb3J0IGRlZmF1bHQgQ2F0bXVsbFJvbVNwbGluZTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///9887\n')},65987:function(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__){eval('/* harmony import */ var _ThirdParty_when_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(13222);\n/* harmony import */ var _AttributeCompression_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(52323);\n/* harmony import */ var _BoundingSphere_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(48243);\n/* harmony import */ var _Cartesian3_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(60216);\n/* harmony import */ var _Credit_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(52975);\n/* harmony import */ var _defaultValue_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(62200);\n/* harmony import */ var _defined_js__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(82982);\n/* harmony import */ var _DeveloperError_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(12572);\n/* harmony import */ var _Event_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(14459);\n/* harmony import */ var _GeographicTilingScheme_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(71351);\n/* harmony import */ var _WebMercatorTilingScheme_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(42423);\n/* harmony import */ var _getJsonFromTypedArray_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(12540);\n/* harmony import */ var _HeightmapTerrainData_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(57134);\n/* harmony import */ var _IndexDatatype_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(22832);\n/* harmony import */ var _OrientedBoundingBox_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(25405);\n/* harmony import */ var _QuantizedMeshTerrainData_js__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(38036);\n/* harmony import */ var _Request_js__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(22426);\n/* harmony import */ var _RequestType_js__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(82968);\n/* harmony import */ var _Resource_js__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(68985);\n/* harmony import */ var _RuntimeError_js__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(9407);\n/* harmony import */ var _TerrainProvider_js__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(1497);\n/* harmony import */ var _TileAvailability_js__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(25707);\n/* harmony import */ var _TileProviderError_js__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(9121);\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunction LayerInformation(layer) {\n  this.resource = layer.resource;\n  this.version = layer.version;\n  this.isHeightmap = layer.isHeightmap;\n  this.tileUrlTemplates = layer.tileUrlTemplates;\n  this.availability = layer.availability;\n  this.hasVertexNormals = layer.hasVertexNormals;\n  this.hasWaterMask = layer.hasWaterMask;\n  this.hasMetadata = layer.hasMetadata;\n  this.availabilityLevels = layer.availabilityLevels;\n  this.availabilityTilesLoaded = layer.availabilityTilesLoaded;\n  this.littleEndianExtensionSize = layer.littleEndianExtensionSize;\n  this.availabilityPromiseCache = {};\n}\n\n/**\n * A {@link TerrainProvider} that accesses terrain data in a Cesium terrain format.\n *\n * @alias CesiumTerrainProvider\n * @constructor\n *\n * @param {Object} options Object with the following properties:\n * @param {Resource|String|Promise<Resource>|Promise<String>} options.url The URL of the Cesium terrain server.\n * @param {Boolean} [options.requestVertexNormals=false] Flag that indicates if the client should request additional lighting information from the server, in the form of per vertex normals if available.\n * @param {Boolean} [options.requestWaterMask=false] Flag that indicates if the client should request per tile water masks from the server,  if available.\n * @param {Boolean} [options.requestMetadata=true] Flag that indicates if the client should request per tile metadata from the server, if available.\n * @param {Ellipsoid} [options.ellipsoid] The ellipsoid.  If not specified, the WGS84 ellipsoid is used.\n * @param {Credit|String} [options.credit] A credit for the data source, which is displayed on the canvas.\n *\n *\n * @example\n * // Create Arctic DEM terrain with normals.\n * var viewer = new Cesium.Viewer(\'cesiumContainer\', {\n *     terrainProvider : new Cesium.CesiumTerrainProvider({\n *         url : Cesium.IonResource.fromAssetId(3956),\n *         requestVertexNormals : true\n *     })\n * });\n *\n * @see createWorldTerrain\n * @see TerrainProvider\n */\nfunction CesiumTerrainProvider(options) {\n  //>>includeStart(\'debug\', pragmas.debug)\n  if (!(0,_defined_js__WEBPACK_IMPORTED_MODULE_22__/* ["default"] */ .Z)(options) || !(0,_defined_js__WEBPACK_IMPORTED_MODULE_22__/* ["default"] */ .Z)(options.url)) {\n    throw new _DeveloperError_js__WEBPACK_IMPORTED_MODULE_6__/* ["default"] */ .Z("options.url is required.");\n  }\n  //>>includeEnd(\'debug\');\n\n  this._heightmapWidth = 65;\n  this._heightmapStructure = undefined;\n  this._hasWaterMask = false;\n  this._hasVertexNormals = false;\n  this._ellipsoid = options.ellipsoid;\n\n  /**\n   * Boolean flag that indicates if the client should request vertex normals from the server.\n   * @type {Boolean}\n   * @default false\n   * @private\n   */\n  this._requestVertexNormals = (0,_defaultValue_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"] */ .Z)(\n    options.requestVertexNormals,\n    false\n  );\n\n  /**\n   * Boolean flag that indicates if the client should request tile watermasks from the server.\n   * @type {Boolean}\n   * @default false\n   * @private\n   */\n  this._requestWaterMask = (0,_defaultValue_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"] */ .Z)(options.requestWaterMask, false);\n\n  /**\n   * Boolean flag that indicates if the client should request tile metadata from the server.\n   * @type {Boolean}\n   * @default true\n   * @private\n   */\n  this._requestMetadata = (0,_defaultValue_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"] */ .Z)(options.requestMetadata, true);\n\n  this._errorEvent = new _Event_js__WEBPACK_IMPORTED_MODULE_7__/* ["default"] */ .Z();\n\n  var credit = options.credit;\n  if (typeof credit === "string") {\n    credit = new _Credit_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .Z(credit);\n  }\n  this._credit = credit;\n\n  this._availability = undefined;\n\n  var deferred = _ThirdParty_when_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].defer */ .Z.defer();\n  this._ready = false;\n  this._readyPromise = deferred;\n  this._tileCredits = undefined;\n\n  var that = this;\n  var lastResource;\n  var layerJsonResource;\n  var metadataError;\n\n  var layers = (this._layers = []);\n  var attribution = "";\n  var overallAvailability = [];\n  var overallMaxZoom = 0;\n  (0,_ThirdParty_when_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .Z)(options.url)\n    .then(function (url) {\n      var resource = _Resource_js__WEBPACK_IMPORTED_MODULE_17__/* ["default"].createIfNeeded */ .Z.createIfNeeded(url);\n      resource.appendForwardSlash();\n      lastResource = resource;\n      layerJsonResource = lastResource.getDerivedResource({\n        url: "layer.json",\n      });\n\n      // ion resources have a credits property we can use for additional attribution.\n      that._tileCredits = resource.credits;\n\n      requestLayerJson();\n    })\n    .otherwise(function (e) {\n      deferred.reject(e);\n    });\n\n  function parseMetadataSuccess(data) {\n    var message;\n\n    if (!data.format) {\n      message = "The tile format is not specified in the layer.json file.";\n      metadataError = _TileProviderError_js__WEBPACK_IMPORTED_MODULE_21__/* ["default"].handleError */ .Z.handleError(\n        metadataError,\n        that,\n        that._errorEvent,\n        message,\n        undefined,\n        undefined,\n        undefined,\n        requestLayerJson\n      );\n      return;\n    }\n\n    if (!data.tiles || data.tiles.length === 0) {\n      message = "The layer.json file does not specify any tile URL templates.";\n      metadataError = _TileProviderError_js__WEBPACK_IMPORTED_MODULE_21__/* ["default"].handleError */ .Z.handleError(\n        metadataError,\n        that,\n        that._errorEvent,\n        message,\n        undefined,\n        undefined,\n        undefined,\n        requestLayerJson\n      );\n      return;\n    }\n\n    var hasVertexNormals = false;\n    var hasWaterMask = false;\n    var hasMetadata = false;\n    var littleEndianExtensionSize = true;\n    var isHeightmap = false;\n    if (data.format === "heightmap-1.0") {\n      isHeightmap = true;\n      if (!(0,_defined_js__WEBPACK_IMPORTED_MODULE_22__/* ["default"] */ .Z)(that._heightmapStructure)) {\n        that._heightmapStructure = {\n          heightScale: 1.0 / 5.0,\n          heightOffset: -1000.0,\n          elementsPerHeight: 1,\n          stride: 1,\n          elementMultiplier: 256.0,\n          isBigEndian: false,\n          lowestEncodedHeight: 0,\n          highestEncodedHeight: 256 * 256 - 1,\n        };\n      }\n      hasWaterMask = true;\n      that._requestWaterMask = true;\n    } else if (data.format.indexOf("quantized-mesh-1.") !== 0) {\n      message =\n        \'The tile format "\' + data.format + \'" is invalid or not supported.\';\n      metadataError = _TileProviderError_js__WEBPACK_IMPORTED_MODULE_21__/* ["default"].handleError */ .Z.handleError(\n        metadataError,\n        that,\n        that._errorEvent,\n        message,\n        undefined,\n        undefined,\n        undefined,\n        requestLayerJson\n      );\n      return;\n    }\n\n    var tileUrlTemplates = data.tiles;\n\n    var maxZoom = data.maxzoom;\n    overallMaxZoom = Math.max(overallMaxZoom, maxZoom);\n    // Keeps track of which of the availablity containing tiles have been loaded\n\n    if (!data.projection || data.projection === "EPSG:4326") {\n      that._tilingScheme = new _GeographicTilingScheme_js__WEBPACK_IMPORTED_MODULE_8__/* ["default"] */ .Z({\n        numberOfLevelZeroTilesX: 2,\n        numberOfLevelZeroTilesY: 1,\n        ellipsoid: that._ellipsoid,\n      });\n    } else if (data.projection === "EPSG:3857") {\n      that._tilingScheme = new _WebMercatorTilingScheme_js__WEBPACK_IMPORTED_MODULE_9__/* ["default"] */ .Z({\n        numberOfLevelZeroTilesX: 1,\n        numberOfLevelZeroTilesY: 1,\n        ellipsoid: that._ellipsoid,\n      });\n    } else {\n      message =\n        \'The projection "\' + data.projection + \'" is invalid or not supported.\';\n      metadataError = _TileProviderError_js__WEBPACK_IMPORTED_MODULE_21__/* ["default"].handleError */ .Z.handleError(\n        metadataError,\n        that,\n        that._errorEvent,\n        message,\n        undefined,\n        undefined,\n        undefined,\n        requestLayerJson\n      );\n      return;\n    }\n\n    that._levelZeroMaximumGeometricError = _TerrainProvider_js__WEBPACK_IMPORTED_MODULE_19__/* ["default"].getEstimatedLevelZeroGeometricErrorForAHeightmap */ .Z.getEstimatedLevelZeroGeometricErrorForAHeightmap(\n      that._tilingScheme.ellipsoid,\n      that._heightmapWidth,\n      that._tilingScheme.getNumberOfXTilesAtLevel(0)\n    );\n    if (!data.scheme || data.scheme === "tms" || data.scheme === "slippyMap") {\n      that._scheme = data.scheme;\n    } else {\n      message = \'The scheme "\' + data.scheme + \'" is invalid or not supported.\';\n      metadataError = _TileProviderError_js__WEBPACK_IMPORTED_MODULE_21__/* ["default"].handleError */ .Z.handleError(\n        metadataError,\n        that,\n        that._errorEvent,\n        message,\n        undefined,\n        undefined,\n        undefined,\n        requestLayerJson\n      );\n      return;\n    }\n\n    var availabilityTilesLoaded;\n\n    // The vertex normals defined in the \'octvertexnormals\' extension is identical to the original\n    // contents of the original \'vertexnormals\' extension.  \'vertexnormals\' extension is now\n    // deprecated, as the extensionLength for this extension was incorrectly using big endian.\n    // We maintain backwards compatibility with the legacy \'vertexnormal\' implementation\n    // by setting the _littleEndianExtensionSize to false. Always prefer \'octvertexnormals\'\n    // over \'vertexnormals\' if both extensions are supported by the server.\n    if (\n      (0,_defined_js__WEBPACK_IMPORTED_MODULE_22__/* ["default"] */ .Z)(data.extensions) &&\n      data.extensions.indexOf("octvertexnormals") !== -1\n    ) {\n      hasVertexNormals = true;\n    } else if (\n      (0,_defined_js__WEBPACK_IMPORTED_MODULE_22__/* ["default"] */ .Z)(data.extensions) &&\n      data.extensions.indexOf("vertexnormals") !== -1\n    ) {\n      hasVertexNormals = true;\n      littleEndianExtensionSize = false;\n    }\n    if (\n      (0,_defined_js__WEBPACK_IMPORTED_MODULE_22__/* ["default"] */ .Z)(data.extensions) &&\n      data.extensions.indexOf("watermask") !== -1\n    ) {\n      hasWaterMask = true;\n    }\n    if (\n      (0,_defined_js__WEBPACK_IMPORTED_MODULE_22__/* ["default"] */ .Z)(data.extensions) &&\n      data.extensions.indexOf("metadata") !== -1\n    ) {\n      hasMetadata = true;\n    }\n\n    var availabilityLevels = data.metadataAvailability;\n    var availableTiles = data.available;\n    var availability;\n    if ((0,_defined_js__WEBPACK_IMPORTED_MODULE_22__/* ["default"] */ .Z)(availableTiles) && !(0,_defined_js__WEBPACK_IMPORTED_MODULE_22__/* ["default"] */ .Z)(availabilityLevels)) {\n      availability = new _TileAvailability_js__WEBPACK_IMPORTED_MODULE_20__/* ["default"] */ .Z(\n        that._tilingScheme,\n        availableTiles.length\n      );\n      for (var level = 0; level < availableTiles.length; ++level) {\n        var rangesAtLevel = availableTiles[level];\n        var yTiles = that._tilingScheme.getNumberOfYTilesAtLevel(level);\n        if (!(0,_defined_js__WEBPACK_IMPORTED_MODULE_22__/* ["default"] */ .Z)(overallAvailability[level])) {\n          overallAvailability[level] = [];\n        }\n\n        for (\n          var rangeIndex = 0;\n          rangeIndex < rangesAtLevel.length;\n          ++rangeIndex\n        ) {\n          var range = rangesAtLevel[rangeIndex];\n          var yStart = yTiles - range.endY - 1;\n          var yEnd = yTiles - range.startY - 1;\n          overallAvailability[level].push([\n            range.startX,\n            yStart,\n            range.endX,\n            yEnd,\n          ]);\n          availability.addAvailableTileRange(\n            level,\n            range.startX,\n            yStart,\n            range.endX,\n            yEnd\n          );\n        }\n      }\n    } else if ((0,_defined_js__WEBPACK_IMPORTED_MODULE_22__/* ["default"] */ .Z)(availabilityLevels)) {\n      availabilityTilesLoaded = new _TileAvailability_js__WEBPACK_IMPORTED_MODULE_20__/* ["default"] */ .Z(\n        that._tilingScheme,\n        maxZoom\n      );\n      availability = new _TileAvailability_js__WEBPACK_IMPORTED_MODULE_20__/* ["default"] */ .Z(that._tilingScheme, maxZoom);\n      overallAvailability[0] = [[0, 0, 1, 0]];\n      availability.addAvailableTileRange(0, 0, 0, 1, 0);\n    }\n\n    that._hasWaterMask = that._hasWaterMask || hasWaterMask;\n    that._hasVertexNormals = that._hasVertexNormals || hasVertexNormals;\n    that._hasMetadata = that._hasMetadata || hasMetadata;\n    if ((0,_defined_js__WEBPACK_IMPORTED_MODULE_22__/* ["default"] */ .Z)(data.attribution)) {\n      if (attribution.length > 0) {\n        attribution += " ";\n      }\n      attribution += data.attribution;\n    }\n\n    layers.push(\n      new LayerInformation({\n        resource: lastResource,\n        version: data.version,\n        isHeightmap: isHeightmap,\n        tileUrlTemplates: tileUrlTemplates,\n        availability: availability,\n        hasVertexNormals: hasVertexNormals,\n        hasWaterMask: hasWaterMask,\n        hasMetadata: hasMetadata,\n        availabilityLevels: availabilityLevels,\n        availabilityTilesLoaded: availabilityTilesLoaded,\n        littleEndianExtensionSize: littleEndianExtensionSize,\n      })\n    );\n\n    var parentUrl = data.parentUrl;\n    if ((0,_defined_js__WEBPACK_IMPORTED_MODULE_22__/* ["default"] */ .Z)(parentUrl)) {\n      if (!(0,_defined_js__WEBPACK_IMPORTED_MODULE_22__/* ["default"] */ .Z)(availability)) {\n        console.log(\n          "A layer.json can\'t have a parentUrl if it does\'t have an available array."\n        );\n        return _ThirdParty_when_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].resolve */ .Z.resolve();\n      }\n      lastResource = lastResource.getDerivedResource({\n        url: parentUrl,\n      });\n      lastResource.appendForwardSlash(); // Terrain always expects a directory\n      layerJsonResource = lastResource.getDerivedResource({\n        url: "layer.json",\n      });\n      var parentMetadata = layerJsonResource.fetchJson();\n      return (0,_ThirdParty_when_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .Z)(parentMetadata, parseMetadataSuccess, parseMetadataFailure);\n    }\n\n    return _ThirdParty_when_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].resolve */ .Z.resolve();\n  }\n\n  function parseMetadataFailure(data) {\n    var message =\n      "An error occurred while accessing " + layerJsonResource.url + ".";\n    metadataError = _TileProviderError_js__WEBPACK_IMPORTED_MODULE_21__/* ["default"].handleError */ .Z.handleError(\n      metadataError,\n      that,\n      that._errorEvent,\n      message,\n      undefined,\n      undefined,\n      undefined,\n      requestLayerJson\n    );\n  }\n\n  function metadataSuccess(data) {\n    parseMetadataSuccess(data).then(function () {\n      if ((0,_defined_js__WEBPACK_IMPORTED_MODULE_22__/* ["default"] */ .Z)(metadataError)) {\n        return;\n      }\n\n      var length = overallAvailability.length;\n      if (length > 0) {\n        var availability = (that._availability = new _TileAvailability_js__WEBPACK_IMPORTED_MODULE_20__/* ["default"] */ .Z(\n          that._tilingScheme,\n          overallMaxZoom\n        ));\n        for (var level = 0; level < length; ++level) {\n          var levelRanges = overallAvailability[level];\n          for (var i = 0; i < levelRanges.length; ++i) {\n            var range = levelRanges[i];\n            availability.addAvailableTileRange(\n              level,\n              range[0],\n              range[1],\n              range[2],\n              range[3]\n            );\n          }\n        }\n      }\n\n      if (attribution.length > 0) {\n        var layerJsonCredit = new _Credit_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .Z(attribution);\n\n        if ((0,_defined_js__WEBPACK_IMPORTED_MODULE_22__/* ["default"] */ .Z)(that._tileCredits)) {\n          that._tileCredits.push(layerJsonCredit);\n        } else {\n          that._tileCredits = [layerJsonCredit];\n        }\n      }\n\n      that._ready = true;\n      that._readyPromise.resolve(true);\n    });\n  }\n\n  function metadataFailure(data) {\n    // If the metadata is not found, assume this is a pre-metadata heightmap tileset.\n    if ((0,_defined_js__WEBPACK_IMPORTED_MODULE_22__/* ["default"] */ .Z)(data) && data.statusCode === 404) {\n      metadataSuccess({\n        tilejson: "2.1.0",\n        format: "heightmap-1.0",\n        version: "1.0.0",\n        scheme: "tms",\n        tiles: ["{z}/{x}/{y}.terrain?v={version}"],\n      });\n      return;\n    }\n    parseMetadataFailure(data);\n  }\n\n  function requestLayerJson() {\n    (0,_ThirdParty_when_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .Z)(layerJsonResource.fetchJson())\n      .then(metadataSuccess)\n      .otherwise(metadataFailure);\n  }\n}\n\n/**\n * When using the Quantized-Mesh format, a tile may be returned that includes additional extensions, such as PerVertexNormals, watermask, etc.\n * This enumeration defines the unique identifiers for each type of extension data that has been appended to the standard mesh data.\n *\n * @namespace QuantizedMeshExtensionIds\n * @see CesiumTerrainProvider\n * @private\n */\nvar QuantizedMeshExtensionIds = {\n  /**\n   * Oct-Encoded Per-Vertex Normals are included as an extension to the tile mesh\n   *\n   * @type {Number}\n   * @constant\n   * @default 1\n   */\n  OCT_VERTEX_NORMALS: 1,\n  /**\n   * A watermask is included as an extension to the tile mesh\n   *\n   * @type {Number}\n   * @constant\n   * @default 2\n   */\n  WATER_MASK: 2,\n  /**\n   * A json object contain metadata about the tile\n   *\n   * @type {Number}\n   * @constant\n   * @default 4\n   */\n  METADATA: 4,\n};\n\nfunction getRequestHeader(extensionsList) {\n  if (!(0,_defined_js__WEBPACK_IMPORTED_MODULE_22__/* ["default"] */ .Z)(extensionsList) || extensionsList.length === 0) {\n    return {\n      Accept:\n        "application/vnd.quantized-mesh,application/octet-stream;q=0.9,*/*;q=0.01",\n    };\n  }\n  var extensions = extensionsList.join("-");\n  return {\n    Accept:\n      "application/vnd.quantized-mesh;extensions=" +\n      extensions +\n      ",application/octet-stream;q=0.9,*/*;q=0.01",\n  };\n}\n\nfunction createHeightmapTerrainData(provider, buffer, level, x, y) {\n  var heightBuffer = new Uint16Array(\n    buffer,\n    0,\n    provider._heightmapWidth * provider._heightmapWidth\n  );\n  return new _HeightmapTerrainData_js__WEBPACK_IMPORTED_MODULE_11__/* ["default"] */ .Z({\n    buffer: heightBuffer,\n    childTileMask: new Uint8Array(buffer, heightBuffer.byteLength, 1)[0],\n    waterMask: new Uint8Array(\n      buffer,\n      heightBuffer.byteLength + 1,\n      buffer.byteLength - heightBuffer.byteLength - 1\n    ),\n    width: provider._heightmapWidth,\n    height: provider._heightmapWidth,\n    structure: provider._heightmapStructure,\n    credits: provider._tileCredits,\n  });\n}\n\nfunction createQuantizedMeshTerrainData(provider, buffer, level, x, y, layer) {\n  var littleEndianExtensionSize = layer.littleEndianExtensionSize;\n  var pos = 0;\n  var cartesian3Elements = 3;\n  var boundingSphereElements = cartesian3Elements + 1;\n  var cartesian3Length = Float64Array.BYTES_PER_ELEMENT * cartesian3Elements;\n  var boundingSphereLength =\n    Float64Array.BYTES_PER_ELEMENT * boundingSphereElements;\n  var encodedVertexElements = 3;\n  var encodedVertexLength =\n    Uint16Array.BYTES_PER_ELEMENT * encodedVertexElements;\n  var triangleElements = 3;\n  var bytesPerIndex = Uint16Array.BYTES_PER_ELEMENT;\n  var triangleLength = bytesPerIndex * triangleElements;\n\n  var view = new DataView(buffer);\n  var center = new _Cartesian3_js__WEBPACK_IMPORTED_MODULE_3__/* ["default"] */ .Z(\n    view.getFloat64(pos, true),\n    view.getFloat64(pos + 8, true),\n    view.getFloat64(pos + 16, true)\n  );\n  pos += cartesian3Length;\n\n  var minimumHeight = view.getFloat32(pos, true);\n  pos += Float32Array.BYTES_PER_ELEMENT;\n  var maximumHeight = view.getFloat32(pos, true);\n  pos += Float32Array.BYTES_PER_ELEMENT;\n\n  var boundingSphere = new _BoundingSphere_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"] */ .Z(\n    new _Cartesian3_js__WEBPACK_IMPORTED_MODULE_3__/* ["default"] */ .Z(\n      view.getFloat64(pos, true),\n      view.getFloat64(pos + 8, true),\n      view.getFloat64(pos + 16, true)\n    ),\n    view.getFloat64(pos + cartesian3Length, true)\n  );\n  pos += boundingSphereLength;\n\n  var horizonOcclusionPoint = new _Cartesian3_js__WEBPACK_IMPORTED_MODULE_3__/* ["default"] */ .Z(\n    view.getFloat64(pos, true),\n    view.getFloat64(pos + 8, true),\n    view.getFloat64(pos + 16, true)\n  );\n  pos += cartesian3Length;\n\n  var vertexCount = view.getUint32(pos, true);\n  pos += Uint32Array.BYTES_PER_ELEMENT;\n  var encodedVertexBuffer = new Uint16Array(buffer, pos, vertexCount * 3);\n  pos += vertexCount * encodedVertexLength;\n\n  if (vertexCount > 64 * 1024) {\n    // More than 64k vertices, so indices are 32-bit.\n    bytesPerIndex = Uint32Array.BYTES_PER_ELEMENT;\n    triangleLength = bytesPerIndex * triangleElements;\n  }\n\n  // Decode the vertex buffer.\n  var uBuffer = encodedVertexBuffer.subarray(0, vertexCount);\n  var vBuffer = encodedVertexBuffer.subarray(vertexCount, 2 * vertexCount);\n  var heightBuffer = encodedVertexBuffer.subarray(\n    vertexCount * 2,\n    3 * vertexCount\n  );\n\n  _AttributeCompression_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"].zigZagDeltaDecode */ .Z.zigZagDeltaDecode(uBuffer, vBuffer, heightBuffer);\n\n  // skip over any additional padding that was added for 2/4 byte alignment\n  if (pos % bytesPerIndex !== 0) {\n    pos += bytesPerIndex - (pos % bytesPerIndex);\n  }\n\n  var triangleCount = view.getUint32(pos, true);\n  pos += Uint32Array.BYTES_PER_ELEMENT;\n  var indices = _IndexDatatype_js__WEBPACK_IMPORTED_MODULE_12__/* ["default"].createTypedArrayFromArrayBuffer */ .Z.createTypedArrayFromArrayBuffer(\n    vertexCount,\n    buffer,\n    pos,\n    triangleCount * triangleElements\n  );\n  pos += triangleCount * triangleLength;\n\n  // High water mark decoding based on decompressIndices_ in webgl-loader\'s loader.js.\n  // https://code.google.com/p/webgl-loader/source/browse/trunk/samples/loader.js?r=99#55\n  // Copyright 2012 Google Inc., Apache 2.0 license.\n  var highest = 0;\n  var length = indices.length;\n  for (var i = 0; i < length; ++i) {\n    var code = indices[i];\n    indices[i] = highest - code;\n    if (code === 0) {\n      ++highest;\n    }\n  }\n\n  var westVertexCount = view.getUint32(pos, true);\n  pos += Uint32Array.BYTES_PER_ELEMENT;\n  var westIndices = _IndexDatatype_js__WEBPACK_IMPORTED_MODULE_12__/* ["default"].createTypedArrayFromArrayBuffer */ .Z.createTypedArrayFromArrayBuffer(\n    vertexCount,\n    buffer,\n    pos,\n    westVertexCount\n  );\n  pos += westVertexCount * bytesPerIndex;\n\n  var southVertexCount = view.getUint32(pos, true);\n  pos += Uint32Array.BYTES_PER_ELEMENT;\n  var southIndices = _IndexDatatype_js__WEBPACK_IMPORTED_MODULE_12__/* ["default"].createTypedArrayFromArrayBuffer */ .Z.createTypedArrayFromArrayBuffer(\n    vertexCount,\n    buffer,\n    pos,\n    southVertexCount\n  );\n  pos += southVertexCount * bytesPerIndex;\n\n  var eastVertexCount = view.getUint32(pos, true);\n  pos += Uint32Array.BYTES_PER_ELEMENT;\n  var eastIndices = _IndexDatatype_js__WEBPACK_IMPORTED_MODULE_12__/* ["default"].createTypedArrayFromArrayBuffer */ .Z.createTypedArrayFromArrayBuffer(\n    vertexCount,\n    buffer,\n    pos,\n    eastVertexCount\n  );\n  pos += eastVertexCount * bytesPerIndex;\n\n  var northVertexCount = view.getUint32(pos, true);\n  pos += Uint32Array.BYTES_PER_ELEMENT;\n  var northIndices = _IndexDatatype_js__WEBPACK_IMPORTED_MODULE_12__/* ["default"].createTypedArrayFromArrayBuffer */ .Z.createTypedArrayFromArrayBuffer(\n    vertexCount,\n    buffer,\n    pos,\n    northVertexCount\n  );\n  pos += northVertexCount * bytesPerIndex;\n\n  var encodedNormalBuffer;\n  var waterMaskBuffer;\n  while (pos < view.byteLength) {\n    var extensionId = view.getUint8(pos, true);\n    pos += Uint8Array.BYTES_PER_ELEMENT;\n    var extensionLength = view.getUint32(pos, littleEndianExtensionSize);\n    pos += Uint32Array.BYTES_PER_ELEMENT;\n\n    if (\n      extensionId === QuantizedMeshExtensionIds.OCT_VERTEX_NORMALS &&\n      provider._requestVertexNormals\n    ) {\n      encodedNormalBuffer = new Uint8Array(buffer, pos, vertexCount * 2);\n    } else if (\n      extensionId === QuantizedMeshExtensionIds.WATER_MASK &&\n      provider._requestWaterMask\n    ) {\n      waterMaskBuffer = new Uint8Array(buffer, pos, extensionLength);\n    } else if (\n      extensionId === QuantizedMeshExtensionIds.METADATA &&\n      provider._requestMetadata\n    ) {\n      var stringLength = view.getUint32(pos, true);\n      if (stringLength > 0) {\n        var metadata = (0,_getJsonFromTypedArray_js__WEBPACK_IMPORTED_MODULE_10__/* ["default"] */ .Z)(\n          new Uint8Array(buffer),\n          pos + Uint32Array.BYTES_PER_ELEMENT,\n          stringLength\n        );\n        var availableTiles = metadata.available;\n        if ((0,_defined_js__WEBPACK_IMPORTED_MODULE_22__/* ["default"] */ .Z)(availableTiles)) {\n          for (var offset = 0; offset < availableTiles.length; ++offset) {\n            var availableLevel = level + offset + 1;\n            var rangesAtLevel = availableTiles[offset];\n            var yTiles = provider._tilingScheme.getNumberOfYTilesAtLevel(\n              availableLevel\n            );\n\n            for (\n              var rangeIndex = 0;\n              rangeIndex < rangesAtLevel.length;\n              ++rangeIndex\n            ) {\n              var range = rangesAtLevel[rangeIndex];\n              var yStart = yTiles - range.endY - 1;\n              var yEnd = yTiles - range.startY - 1;\n              provider.availability.addAvailableTileRange(\n                availableLevel,\n                range.startX,\n                yStart,\n                range.endX,\n                yEnd\n              );\n              layer.availability.addAvailableTileRange(\n                availableLevel,\n                range.startX,\n                yStart,\n                range.endX,\n                yEnd\n              );\n            }\n          }\n        }\n      }\n      layer.availabilityTilesLoaded.addAvailableTileRange(level, x, y, x, y);\n    }\n    pos += extensionLength;\n  }\n\n  var skirtHeight = provider.getLevelMaximumGeometricError(level) * 5.0;\n\n  // The skirt is not included in the OBB computation. If this ever\n  // causes any rendering artifacts (cracks), they are expected to be\n  // minor and in the corners of the screen. It\'s possible that this\n  // might need to be changed - just change to `minimumHeight - skirtHeight`\n  // A similar change might also be needed in `upsampleQuantizedTerrainMesh.js`.\n  var rectangle = provider._tilingScheme.tileXYToRectangle(x, y, level);\n  var orientedBoundingBox = _OrientedBoundingBox_js__WEBPACK_IMPORTED_MODULE_13__/* ["default"].fromRectangle */ .Z.fromRectangle(\n    rectangle,\n    minimumHeight,\n    maximumHeight,\n    provider._tilingScheme.ellipsoid\n  );\n\n  return new _QuantizedMeshTerrainData_js__WEBPACK_IMPORTED_MODULE_14__/* ["default"] */ .Z({\n    center: center,\n    minimumHeight: minimumHeight,\n    maximumHeight: maximumHeight,\n    boundingSphere: boundingSphere,\n    orientedBoundingBox: orientedBoundingBox,\n    horizonOcclusionPoint: horizonOcclusionPoint,\n    quantizedVertices: encodedVertexBuffer,\n    encodedNormals: encodedNormalBuffer,\n    indices: indices,\n    westIndices: westIndices,\n    southIndices: southIndices,\n    eastIndices: eastIndices,\n    northIndices: northIndices,\n    westSkirtHeight: skirtHeight,\n    southSkirtHeight: skirtHeight,\n    eastSkirtHeight: skirtHeight,\n    northSkirtHeight: skirtHeight,\n    childTileMask: provider.availability.computeChildMaskForTile(level, x, y),\n    waterMask: waterMaskBuffer,\n    credits: provider._tileCredits,\n  });\n}\n\n/**\n * Requests the geometry for a given tile.  This function should not be called before\n * {@link CesiumTerrainProvider#ready} returns true.  The result must include terrain data and\n * may optionally include a water mask and an indication of which child tiles are available.\n *\n * @param {Number} x The X coordinate of the tile for which to request geometry.\n * @param {Number} y The Y coordinate of the tile for which to request geometry.\n * @param {Number} level The level of the tile for which to request geometry.\n * @param {Request} [request] The request object. Intended for internal use only.\n *\n * @returns {Promise.<TerrainData>|undefined} A promise for the requested geometry.  If this method\n *          returns undefined instead of a promise, it is an indication that too many requests are already\n *          pending and the request will be retried later.\n *\n * @exception {DeveloperError} This function must not be called before {@link CesiumTerrainProvider#ready}\n *            returns true.\n */\nCesiumTerrainProvider.prototype.requestTileGeometry = function (\n  x,\n  y,\n  level,\n  request\n) {\n  //>>includeStart(\'debug\', pragmas.debug)\n  if (!this._ready) {\n    throw new _DeveloperError_js__WEBPACK_IMPORTED_MODULE_6__/* ["default"] */ .Z(\n      "requestTileGeometry must not be called before the terrain provider is ready."\n    );\n  }\n  //>>includeEnd(\'debug\');\n\n  var layers = this._layers;\n  var layerToUse;\n  var layerCount = layers.length;\n\n  if (layerCount === 1) {\n    // Optimized path for single layers\n    layerToUse = layers[0];\n  } else {\n    for (var i = 0; i < layerCount; ++i) {\n      var layer = layers[i];\n      if (\n        !(0,_defined_js__WEBPACK_IMPORTED_MODULE_22__/* ["default"] */ .Z)(layer.availability) ||\n        layer.availability.isTileAvailable(level, x, y)\n      ) {\n        layerToUse = layer;\n        break;\n      }\n    }\n  }\n\n  return requestTileGeometry(this, x, y, level, layerToUse, request);\n};\n\nfunction requestTileGeometry(provider, x, y, level, layerToUse, request) {\n  if (!(0,_defined_js__WEBPACK_IMPORTED_MODULE_22__/* ["default"] */ .Z)(layerToUse)) {\n    return _ThirdParty_when_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].reject */ .Z.reject(new _RuntimeError_js__WEBPACK_IMPORTED_MODULE_18__/* ["default"] */ .Z("Terrain tile doesn\'t exist"));\n  }\n\n  var urlTemplates = layerToUse.tileUrlTemplates;\n  if (urlTemplates.length === 0) {\n    return undefined;\n  }\n\n  // The TileMapService scheme counts from the bottom left\n  var terrainY;\n  if (!provider._scheme || provider._scheme === "tms") {\n    var yTiles = provider._tilingScheme.getNumberOfYTilesAtLevel(level);\n    terrainY = yTiles - y - 1;\n  } else {\n    terrainY = y;\n  }\n\n  var extensionList = [];\n  if (provider._requestVertexNormals && layerToUse.hasVertexNormals) {\n    extensionList.push(\n      layerToUse.littleEndianExtensionSize\n        ? "octvertexnormals"\n        : "vertexnormals"\n    );\n  }\n  if (provider._requestWaterMask && layerToUse.hasWaterMask) {\n    extensionList.push("watermask");\n  }\n  if (provider._requestMetadata && layerToUse.hasMetadata) {\n    extensionList.push("metadata");\n  }\n\n  var headers;\n  var query;\n  var url = urlTemplates[(x + terrainY + level) % urlTemplates.length];\n\n  var resource = layerToUse.resource;\n  if (\n    (0,_defined_js__WEBPACK_IMPORTED_MODULE_22__/* ["default"] */ .Z)(resource._ionEndpoint) &&\n    !(0,_defined_js__WEBPACK_IMPORTED_MODULE_22__/* ["default"] */ .Z)(resource._ionEndpoint.externalType)\n  ) {\n    // ion uses query paremeters to request extensions\n    if (extensionList.length !== 0) {\n      query = { extensions: extensionList.join("-") };\n    }\n    headers = getRequestHeader(undefined);\n  } else {\n    //All other terrain servers\n    headers = getRequestHeader(extensionList);\n  }\n\n  var promise = resource\n    .getDerivedResource({\n      url: url,\n      templateValues: {\n        version: layerToUse.version,\n        z: level,\n        x: x,\n        y: terrainY,\n      },\n      queryParameters: query,\n      headers: headers,\n      request: request,\n    })\n    .fetchArrayBuffer();\n\n  if (!(0,_defined_js__WEBPACK_IMPORTED_MODULE_22__/* ["default"] */ .Z)(promise)) {\n    return undefined;\n  }\n\n  return promise.then(function (buffer) {\n    if ((0,_defined_js__WEBPACK_IMPORTED_MODULE_22__/* ["default"] */ .Z)(provider._heightmapStructure)) {\n      return createHeightmapTerrainData(provider, buffer, level, x, y);\n    }\n    return createQuantizedMeshTerrainData(\n      provider,\n      buffer,\n      level,\n      x,\n      y,\n      layerToUse\n    );\n  });\n}\n\nObject.defineProperties(CesiumTerrainProvider.prototype, {\n  /**\n   * Gets an event that is raised when the terrain provider encounters an asynchronous error.  By subscribing\n   * to the event, you will be notified of the error and can potentially recover from it.  Event listeners\n   * are passed an instance of {@link TileProviderError}.\n   * @memberof CesiumTerrainProvider.prototype\n   * @type {Event}\n   * @readonly\n   */\n  errorEvent: {\n    get: function () {\n      return this._errorEvent;\n    },\n  },\n\n  /**\n   * Gets the credit to display when this terrain provider is active.  Typically this is used to credit\n   * the source of the terrain.  This function should not be called before {@link CesiumTerrainProvider#ready} returns true.\n   * @memberof CesiumTerrainProvider.prototype\n   * @type {Credit}\n   * @readonly\n   */\n  credit: {\n    get: function () {\n      //>>includeStart(\'debug\', pragmas.debug)\n      if (!this._ready) {\n        throw new _DeveloperError_js__WEBPACK_IMPORTED_MODULE_6__/* ["default"] */ .Z(\n          "credit must not be called before the terrain provider is ready."\n        );\n      }\n      //>>includeEnd(\'debug\');\n\n      return this._credit;\n    },\n  },\n\n  /**\n   * Gets the tiling scheme used by this provider.  This function should\n   * not be called before {@link CesiumTerrainProvider#ready} returns true.\n   * @memberof CesiumTerrainProvider.prototype\n   * @type {GeographicTilingScheme}\n   * @readonly\n   */\n  tilingScheme: {\n    get: function () {\n      //>>includeStart(\'debug\', pragmas.debug)\n      if (!this._ready) {\n        throw new _DeveloperError_js__WEBPACK_IMPORTED_MODULE_6__/* ["default"] */ .Z(\n          "tilingScheme must not be called before the terrain provider is ready."\n        );\n      }\n      //>>includeEnd(\'debug\');\n\n      return this._tilingScheme;\n    },\n  },\n\n  /**\n   * Gets a value indicating whether or not the provider is ready for use.\n   * @memberof CesiumTerrainProvider.prototype\n   * @type {Boolean}\n   * @readonly\n   */\n  ready: {\n    get: function () {\n      return this._ready;\n    },\n  },\n\n  /**\n   * Gets a promise that resolves to true when the provider is ready for use.\n   * @memberof CesiumTerrainProvider.prototype\n   * @type {Promise.<Boolean>}\n   * @readonly\n   */\n  readyPromise: {\n    get: function () {\n      return this._readyPromise.promise;\n    },\n  },\n\n  /**\n   * Gets a value indicating whether or not the provider includes a water mask.  The water mask\n   * indicates which areas of the globe are water rather than land, so they can be rendered\n   * as a reflective surface with animated waves.  This function should not be\n   * called before {@link CesiumTerrainProvider#ready} returns true.\n   * @memberof CesiumTerrainProvider.prototype\n   * @type {Boolean}\n   * @readonly\n   * @exception {DeveloperError} This property must not be called before {@link CesiumTerrainProvider#ready}\n   */\n  hasWaterMask: {\n    get: function () {\n      //>>includeStart(\'debug\', pragmas.debug)\n      if (!this._ready) {\n        throw new _DeveloperError_js__WEBPACK_IMPORTED_MODULE_6__/* ["default"] */ .Z(\n          "hasWaterMask must not be called before the terrain provider is ready."\n        );\n      }\n      //>>includeEnd(\'debug\');\n\n      return this._hasWaterMask && this._requestWaterMask;\n    },\n  },\n\n  /**\n   * Gets a value indicating whether or not the requested tiles include vertex normals.\n   * This function should not be called before {@link CesiumTerrainProvider#ready} returns true.\n   * @memberof CesiumTerrainProvider.prototype\n   * @type {Boolean}\n   * @readonly\n   * @exception {DeveloperError} This property must not be called before {@link CesiumTerrainProvider#ready}\n   */\n  hasVertexNormals: {\n    get: function () {\n      //>>includeStart(\'debug\', pragmas.debug)\n      if (!this._ready) {\n        throw new _DeveloperError_js__WEBPACK_IMPORTED_MODULE_6__/* ["default"] */ .Z(\n          "hasVertexNormals must not be called before the terrain provider is ready."\n        );\n      }\n      //>>includeEnd(\'debug\');\n\n      // returns true if we can request vertex normals from the server\n      return this._hasVertexNormals && this._requestVertexNormals;\n    },\n  },\n\n  /**\n   * Gets a value indicating whether or not the requested tiles include metadata.\n   * This function should not be called before {@link CesiumTerrainProvider#ready} returns true.\n   * @memberof CesiumTerrainProvider.prototype\n   * @type {Boolean}\n   * @readonly\n   * @exception {DeveloperError} This property must not be called before {@link CesiumTerrainProvider#ready}\n   */\n  hasMetadata: {\n    get: function () {\n      //>>includeStart(\'debug\', pragmas.debug)\n      if (!this._ready) {\n        throw new _DeveloperError_js__WEBPACK_IMPORTED_MODULE_6__/* ["default"] */ .Z(\n          "hasMetadata must not be called before the terrain provider is ready."\n        );\n      }\n      //>>includeEnd(\'debug\');\n\n      // returns true if we can request metadata from the server\n      return this._hasMetadata && this._requestMetadata;\n    },\n  },\n\n  /**\n   * Boolean flag that indicates if the client should request vertex normals from the server.\n   * Vertex normals data is appended to the standard tile mesh data only if the client requests the vertex normals and\n   * if the server provides vertex normals.\n   * @memberof CesiumTerrainProvider.prototype\n   * @type {Boolean}\n   * @readonly\n   */\n  requestVertexNormals: {\n    get: function () {\n      return this._requestVertexNormals;\n    },\n  },\n\n  /**\n   * Boolean flag that indicates if the client should request a watermask from the server.\n   * Watermask data is appended to the standard tile mesh data only if the client requests the watermask and\n   * if the server provides a watermask.\n   * @memberof CesiumTerrainProvider.prototype\n   * @type {Boolean}\n   * @readonly\n   */\n  requestWaterMask: {\n    get: function () {\n      return this._requestWaterMask;\n    },\n  },\n\n  /**\n   * Boolean flag that indicates if the client should request metadata from the server.\n   * Metadata is appended to the standard tile mesh data only if the client requests the metadata and\n   * if the server provides a metadata.\n   * @memberof CesiumTerrainProvider.prototype\n   * @type {Boolean}\n   * @readonly\n   */\n  requestMetadata: {\n    get: function () {\n      return this._requestMetadata;\n    },\n  },\n\n  /**\n   * Gets an object that can be used to determine availability of terrain from this provider, such as\n   * at points and in rectangles.  This function should not be called before\n   * {@link CesiumTerrainProvider#ready} returns true.  This property may be undefined if availability\n   * information is not available. Note that this reflects tiles that are known to be available currently.\n   * Additional tiles may be discovered to be available in the future, e.g. if availability information\n   * exists deeper in the tree rather than it all being discoverable at the root. However, a tile that\n   * is available now will not become unavailable in the future.\n   * @memberof CesiumTerrainProvider.prototype\n   * @type {TileAvailability}\n   * @readonly\n   */\n  availability: {\n    get: function () {\n      //>>includeStart(\'debug\', pragmas.debug)\n      if (!this._ready) {\n        throw new _DeveloperError_js__WEBPACK_IMPORTED_MODULE_6__/* ["default"] */ .Z(\n          "availability must not be called before the terrain provider is ready."\n        );\n      }\n      //>>includeEnd(\'debug\');\n      return this._availability;\n    },\n  },\n});\n\n/**\n * Gets the maximum geometric error allowed in a tile at a given level.\n *\n * @param {Number} level The tile level for which to get the maximum geometric error.\n * @returns {Number} The maximum geometric error.\n */\nCesiumTerrainProvider.prototype.getLevelMaximumGeometricError = function (\n  level\n) {\n  return this._levelZeroMaximumGeometricError / (1 << level);\n};\n\n/**\n * Determines whether data for a tile is available to be loaded.\n *\n * @param {Number} x The X coordinate of the tile for which to request geometry.\n * @param {Number} y The Y coordinate of the tile for which to request geometry.\n * @param {Number} level The level of the tile for which to request geometry.\n * @returns {Boolean|undefined} Undefined if not supported or availability is unknown, otherwise true or false.\n */\nCesiumTerrainProvider.prototype.getTileDataAvailable = function (x, y, level) {\n  if (!(0,_defined_js__WEBPACK_IMPORTED_MODULE_22__/* ["default"] */ .Z)(this._availability)) {\n    return undefined;\n  }\n  if (level > this._availability._maximumLevel) {\n    return false;\n  }\n\n  if (this._availability.isTileAvailable(level, x, y)) {\n    // If the tile is listed as available, then we are done\n    return true;\n  }\n  if (!this._hasMetadata) {\n    // If we don\'t have any layers with the metadata extension then we don\'t have this tile\n    return false;\n  }\n\n  var layers = this._layers;\n  var count = layers.length;\n  for (var i = 0; i < count; ++i) {\n    var layerResult = checkLayer(this, x, y, level, layers[i], i === 0);\n    if (layerResult.result) {\n      // There is a layer that may or may not have the tile\n      return undefined;\n    }\n  }\n\n  return false;\n};\n\n/**\n * Makes sure we load availability data for a tile\n *\n * @param {Number} x The X coordinate of the tile for which to request geometry.\n * @param {Number} y The Y coordinate of the tile for which to request geometry.\n * @param {Number} level The level of the tile for which to request geometry.\n * @returns {undefined|Promise<void>} Undefined if nothing need to be loaded or a Promise that resolves when all required tiles are loaded\n */\nCesiumTerrainProvider.prototype.loadTileDataAvailability = function (\n  x,\n  y,\n  level\n) {\n  if (\n    !(0,_defined_js__WEBPACK_IMPORTED_MODULE_22__/* ["default"] */ .Z)(this._availability) ||\n    level > this._availability._maximumLevel ||\n    this._availability.isTileAvailable(level, x, y) ||\n    !this._hasMetadata\n  ) {\n    // We know the tile is either available or not available so nothing to wait on\n    return undefined;\n  }\n\n  var layers = this._layers;\n  var count = layers.length;\n  for (var i = 0; i < count; ++i) {\n    var layerResult = checkLayer(this, x, y, level, layers[i], i === 0);\n    if ((0,_defined_js__WEBPACK_IMPORTED_MODULE_22__/* ["default"] */ .Z)(layerResult.promise)) {\n      return layerResult.promise;\n    }\n  }\n};\n\nfunction getAvailabilityTile(layer, x, y, level) {\n  if (level === 0) {\n    return;\n  }\n\n  var availabilityLevels = layer.availabilityLevels;\n  var parentLevel =\n    level % availabilityLevels === 0\n      ? level - availabilityLevels\n      : ((level / availabilityLevels) | 0) * availabilityLevels;\n  var divisor = 1 << (level - parentLevel);\n  var parentX = (x / divisor) | 0;\n  var parentY = (y / divisor) | 0;\n\n  return {\n    level: parentLevel,\n    x: parentX,\n    y: parentY,\n  };\n}\n\nfunction checkLayer(provider, x, y, level, layer, topLayer) {\n  if (!(0,_defined_js__WEBPACK_IMPORTED_MODULE_22__/* ["default"] */ .Z)(layer.availabilityLevels)) {\n    // It\'s definitely not in this layer\n    return {\n      result: false,\n    };\n  }\n\n  var cacheKey;\n  var deleteFromCache = function () {\n    delete layer.availabilityPromiseCache[cacheKey];\n  };\n  var availabilityTilesLoaded = layer.availabilityTilesLoaded;\n  var availability = layer.availability;\n\n  var tile = getAvailabilityTile(layer, x, y, level);\n  while ((0,_defined_js__WEBPACK_IMPORTED_MODULE_22__/* ["default"] */ .Z)(tile)) {\n    if (\n      availability.isTileAvailable(tile.level, tile.x, tile.y) &&\n      !availabilityTilesLoaded.isTileAvailable(tile.level, tile.x, tile.y)\n    ) {\n      var requestPromise;\n      if (!topLayer) {\n        cacheKey = tile.level + "-" + tile.x + "-" + tile.y;\n        requestPromise = layer.availabilityPromiseCache[cacheKey];\n        if (!(0,_defined_js__WEBPACK_IMPORTED_MODULE_22__/* ["default"] */ .Z)(requestPromise)) {\n          // For cutout terrain, if this isn\'t the top layer the availability tiles\n          //  may never get loaded, so request it here.\n          var request = new _Request_js__WEBPACK_IMPORTED_MODULE_15__/* ["default"] */ .Z({\n            throttle: false,\n            throttleByServer: true,\n            type: _RequestType_js__WEBPACK_IMPORTED_MODULE_16__/* ["default"].TERRAIN */ .Z.TERRAIN,\n          });\n          requestPromise = requestTileGeometry(\n            provider,\n            tile.x,\n            tile.y,\n            tile.level,\n            layer,\n            request\n          );\n          if ((0,_defined_js__WEBPACK_IMPORTED_MODULE_22__/* ["default"] */ .Z)(requestPromise)) {\n            layer.availabilityPromiseCache[cacheKey] = requestPromise;\n            requestPromise.then(deleteFromCache);\n          }\n        }\n      }\n\n      // The availability tile is available, but not loaded, so there\n      //  is still a chance that it may become available at some point\n      return {\n        result: true,\n        promise: requestPromise,\n      };\n    }\n\n    tile = getAvailabilityTile(layer, tile.x, tile.y, tile.level);\n  }\n\n  return {\n    result: false,\n  };\n}\n\n// Used for testing\nCesiumTerrainProvider._getAvailabilityTile = getAvailabilityTile;\n/* harmony default export */ __webpack_exports__["Z"] = (CesiumTerrainProvider);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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TztBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxpRUFBTztBQUNwQjtBQUNBO0FBQ0EsNEJBQTRCLDZEQUFPO0FBQ25DO0FBQ0E7QUFDQSxrQkFBa0IsaUZBQW1CO0FBQ3JDLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxpRUFBTztBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHlEQUFlLHFCQUFxQixFQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdnVlMy13ZWJwYWNrNS8uL25vZGVfbW9kdWxlcy9jZXNpdW0vU291cmNlL0NvcmUvQ2VzaXVtVGVycmFpblByb3ZpZGVyLmpzPzhhZWUiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHdoZW4gZnJvbSBcIi4uL1RoaXJkUGFydHkvd2hlbi5qc1wiO1xuaW1wb3J0IEF0dHJpYnV0ZUNvbXByZXNzaW9uIGZyb20gXCIuL0F0dHJpYnV0ZUNvbXByZXNzaW9uLmpzXCI7XG5pbXBvcnQgQm91bmRpbmdTcGhlcmUgZnJvbSBcIi4vQm91bmRpbmdTcGhlcmUuanNcIjtcbmltcG9ydCBDYXJ0ZXNpYW4zIGZyb20gXCIuL0NhcnRlc2lhbjMuanNcIjtcbmltcG9ydCBDcmVkaXQgZnJvbSBcIi4vQ3JlZGl0LmpzXCI7XG5pbXBvcnQgZGVmYXVsdFZhbHVlIGZyb20gXCIuL2RlZmF1bHRWYWx1ZS5qc1wiO1xuaW1wb3J0IGRlZmluZWQgZnJvbSBcIi4vZGVmaW5lZC5qc1wiO1xuaW1wb3J0IERldmVsb3BlckVycm9yIGZyb20gXCIuL0RldmVsb3BlckVycm9yLmpzXCI7XG5pbXBvcnQgRXZlbnQgZnJvbSBcIi4vRXZlbnQuanNcIjtcbmltcG9ydCBHZW9ncmFwaGljVGlsaW5nU2NoZW1lIGZyb20gXCIuL0dlb2dyYXBoaWNUaWxpbmdTY2hlbWUuanNcIjtcbmltcG9ydCBXZWJNZXJjYXRvclRpbGluZ1NjaGVtZSBmcm9tIFwiLi9XZWJNZXJjYXRvclRpbGluZ1NjaGVtZS5qc1wiO1xuaW1wb3J0IGdldEpzb25Gcm9tVHlwZWRBcnJheSBmcm9tIFwiLi9nZXRKc29uRnJvbVR5cGVkQXJyYXkuanNcIjtcbmltcG9ydCBIZWlnaHRtYXBUZXJyYWluRGF0YSBmcm9tIFwiLi9IZWlnaHRtYXBUZXJyYWluRGF0YS5qc1wiO1xuaW1wb3J0IEluZGV4RGF0YXR5cGUgZnJvbSBcIi4vSW5kZXhEYXRhdHlwZS5qc1wiO1xuaW1wb3J0IE9yaWVudGVkQm91bmRpbmdCb3ggZnJvbSBcIi4vT3JpZW50ZWRCb3VuZGluZ0JveC5qc1wiO1xuaW1wb3J0IFF1YW50aXplZE1lc2hUZXJyYWluRGF0YSBmcm9tIFwiLi9RdWFudGl6ZWRNZXNoVGVycmFpbkRhdGEuanNcIjtcbmltcG9ydCBSZXF1ZXN0IGZyb20gXCIuL1JlcXVlc3QuanNcIjtcbmltcG9ydCBSZXF1ZXN0VHlwZSBmcm9tIFwiLi9SZXF1ZXN0VHlwZS5qc1wiO1xuaW1wb3J0IFJlc291cmNlIGZyb20gXCIuL1Jlc291cmNlLmpzXCI7XG5pbXBvcnQgUnVudGltZUVycm9yIGZyb20gXCIuL1J1bnRpbWVFcnJvci5qc1wiO1xuaW1wb3J0IFRlcnJhaW5Qcm92aWRlciBmcm9tIFwiLi9UZXJyYWluUHJvdmlkZXIuanNcIjtcbmltcG9ydCBUaWxlQXZhaWxhYmlsaXR5IGZyb20gXCIuL1RpbGVBdmFpbGFiaWxpdHkuanNcIjtcbmltcG9ydCBUaWxlUHJvdmlkZXJFcnJvciBmcm9tIFwiLi9UaWxlUHJvdmlkZXJFcnJvci5qc1wiO1xuXG5mdW5jdGlvbiBMYXllckluZm9ybWF0aW9uKGxheWVyKSB7XG4gIHRoaXMucmVzb3VyY2UgPSBsYXllci5yZXNvdXJjZTtcbiAgdGhpcy52ZXJzaW9uID0gbGF5ZXIudmVyc2lvbjtcbiAgdGhpcy5pc0hlaWdodG1hcCA9IGxheWVyLmlzSGVpZ2h0bWFwO1xuICB0aGlzLnRpbGVVcmxUZW1wbGF0ZXMgPSBsYXllci50aWxlVXJsVGVtcGxhdGVzO1xuICB0aGlzLmF2YWlsYWJpbGl0eSA9IGxheWVyLmF2YWlsYWJpbGl0eTtcbiAgdGhpcy5oYXNWZXJ0ZXhOb3JtYWxzID0gbGF5ZXIuaGFzVmVydGV4Tm9ybWFscztcbiAgdGhpcy5oYXNXYXRlck1hc2sgPSBsYXllci5oYXNXYXRlck1hc2s7XG4gIHRoaXMuaGFzTWV0YWRhdGEgPSBsYXllci5oYXNNZXRhZGF0YTtcbiAgdGhpcy5hdmFpbGFiaWxpdHlMZXZlbHMgPSBsYXllci5hdmFpbGFiaWxpdHlMZXZlbHM7XG4gIHRoaXMuYXZhaWxhYmlsaXR5VGlsZXNMb2FkZWQgPSBsYXllci5hdmFpbGFiaWxpdHlUaWxlc0xvYWRlZDtcbiAgdGhpcy5saXR0bGVFbmRpYW5FeHRlbnNpb25TaXplID0gbGF5ZXIubGl0dGxlRW5kaWFuRXh0ZW5zaW9uU2l6ZTtcbiAgdGhpcy5hdmFpbGFiaWxpdHlQcm9taXNlQ2FjaGUgPSB7fTtcbn1cblxuLyoqXG4gKiBBIHtAbGluayBUZXJyYWluUHJvdmlkZXJ9IHRoYXQgYWNjZXNzZXMgdGVycmFpbiBkYXRhIGluIGEgQ2VzaXVtIHRlcnJhaW4gZm9ybWF0LlxuICpcbiAqIEBhbGlhcyBDZXNpdW1UZXJyYWluUHJvdmlkZXJcbiAqIEBjb25zdHJ1Y3RvclxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIE9iamVjdCB3aXRoIHRoZSBmb2xsb3dpbmcgcHJvcGVydGllczpcbiAqIEBwYXJhbSB7UmVzb3VyY2V8U3RyaW5nfFByb21pc2U8UmVzb3VyY2U+fFByb21pc2U8U3RyaW5nPn0gb3B0aW9ucy51cmwgVGhlIFVSTCBvZiB0aGUgQ2VzaXVtIHRlcnJhaW4gc2VydmVyLlxuICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5yZXF1ZXN0VmVydGV4Tm9ybWFscz1mYWxzZV0gRmxhZyB0aGF0IGluZGljYXRlcyBpZiB0aGUgY2xpZW50IHNob3VsZCByZXF1ZXN0IGFkZGl0aW9uYWwgbGlnaHRpbmcgaW5mb3JtYXRpb24gZnJvbSB0aGUgc2VydmVyLCBpbiB0aGUgZm9ybSBvZiBwZXIgdmVydGV4IG5vcm1hbHMgaWYgYXZhaWxhYmxlLlxuICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5yZXF1ZXN0V2F0ZXJNYXNrPWZhbHNlXSBGbGFnIHRoYXQgaW5kaWNhdGVzIGlmIHRoZSBjbGllbnQgc2hvdWxkIHJlcXVlc3QgcGVyIHRpbGUgd2F0ZXIgbWFza3MgZnJvbSB0aGUgc2VydmVyLCAgaWYgYXZhaWxhYmxlLlxuICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5yZXF1ZXN0TWV0YWRhdGE9dHJ1ZV0gRmxhZyB0aGF0IGluZGljYXRlcyBpZiB0aGUgY2xpZW50IHNob3VsZCByZXF1ZXN0IHBlciB0aWxlIG1ldGFkYXRhIGZyb20gdGhlIHNlcnZlciwgaWYgYXZhaWxhYmxlLlxuICogQHBhcmFtIHtFbGxpcHNvaWR9IFtvcHRpb25zLmVsbGlwc29pZF0gVGhlIGVsbGlwc29pZC4gIElmIG5vdCBzcGVjaWZpZWQsIHRoZSBXR1M4NCBlbGxpcHNvaWQgaXMgdXNlZC5cbiAqIEBwYXJhbSB7Q3JlZGl0fFN0cmluZ30gW29wdGlvbnMuY3JlZGl0XSBBIGNyZWRpdCBmb3IgdGhlIGRhdGEgc291cmNlLCB3aGljaCBpcyBkaXNwbGF5ZWQgb24gdGhlIGNhbnZhcy5cbiAqXG4gKlxuICogQGV4YW1wbGVcbiAqIC8vIENyZWF0ZSBBcmN0aWMgREVNIHRlcnJhaW4gd2l0aCBub3JtYWxzLlxuICogdmFyIHZpZXdlciA9IG5ldyBDZXNpdW0uVmlld2VyKCdjZXNpdW1Db250YWluZXInLCB7XG4gKiAgICAgdGVycmFpblByb3ZpZGVyIDogbmV3IENlc2l1bS5DZXNpdW1UZXJyYWluUHJvdmlkZXIoe1xuICogICAgICAgICB1cmwgOiBDZXNpdW0uSW9uUmVzb3VyY2UuZnJvbUFzc2V0SWQoMzk1NiksXG4gKiAgICAgICAgIHJlcXVlc3RWZXJ0ZXhOb3JtYWxzIDogdHJ1ZVxuICogICAgIH0pXG4gKiB9KTtcbiAqXG4gKiBAc2VlIGNyZWF0ZVdvcmxkVGVycmFpblxuICogQHNlZSBUZXJyYWluUHJvdmlkZXJcbiAqL1xuZnVuY3Rpb24gQ2VzaXVtVGVycmFpblByb3ZpZGVyKG9wdGlvbnMpIHtcbiAgLy8+PmluY2x1ZGVTdGFydCgnZGVidWcnLCBwcmFnbWFzLmRlYnVnKVxuICBpZiAoIWRlZmluZWQob3B0aW9ucykgfHwgIWRlZmluZWQob3B0aW9ucy51cmwpKSB7XG4gICAgdGhyb3cgbmV3IERldmVsb3BlckVycm9yKFwib3B0aW9ucy51cmwgaXMgcmVxdWlyZWQuXCIpO1xuICB9XG4gIC8vPj5pbmNsdWRlRW5kKCdkZWJ1ZycpO1xuXG4gIHRoaXMuX2hlaWdodG1hcFdpZHRoID0gNjU7XG4gIHRoaXMuX2hlaWdodG1hcFN0cnVjdHVyZSA9IHVuZGVmaW5lZDtcbiAgdGhpcy5faGFzV2F0ZXJNYXNrID0gZmFsc2U7XG4gIHRoaXMuX2hhc1ZlcnRleE5vcm1hbHMgPSBmYWxzZTtcbiAgdGhpcy5fZWxsaXBzb2lkID0gb3B0aW9ucy5lbGxpcHNvaWQ7XG5cbiAgLyoqXG4gICAqIEJvb2xlYW4gZmxhZyB0aGF0IGluZGljYXRlcyBpZiB0aGUgY2xpZW50IHNob3VsZCByZXF1ZXN0IHZlcnRleCBub3JtYWxzIGZyb20gdGhlIHNlcnZlci5cbiAgICogQHR5cGUge0Jvb2xlYW59XG4gICAqIEBkZWZhdWx0IGZhbHNlXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICB0aGlzLl9yZXF1ZXN0VmVydGV4Tm9ybWFscyA9IGRlZmF1bHRWYWx1ZShcbiAgICBvcHRpb25zLnJlcXVlc3RWZXJ0ZXhOb3JtYWxzLFxuICAgIGZhbHNlXG4gICk7XG5cbiAgLyoqXG4gICAqIEJvb2xlYW4gZmxhZyB0aGF0IGluZGljYXRlcyBpZiB0aGUgY2xpZW50IHNob3VsZCByZXF1ZXN0IHRpbGUgd2F0ZXJtYXNrcyBmcm9tIHRoZSBzZXJ2ZXIuXG4gICAqIEB0eXBlIHtCb29sZWFufVxuICAgKiBAZGVmYXVsdCBmYWxzZVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgdGhpcy5fcmVxdWVzdFdhdGVyTWFzayA9IGRlZmF1bHRWYWx1ZShvcHRpb25zLnJlcXVlc3RXYXRlck1hc2ssIGZhbHNlKTtcblxuICAvKipcbiAgICogQm9vbGVhbiBmbGFnIHRoYXQgaW5kaWNhdGVzIGlmIHRoZSBjbGllbnQgc2hvdWxkIHJlcXVlc3QgdGlsZSBtZXRhZGF0YSBmcm9tIHRoZSBzZXJ2ZXIuXG4gICAqIEB0eXBlIHtCb29sZWFufVxuICAgKiBAZGVmYXVsdCB0cnVlXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICB0aGlzLl9yZXF1ZXN0TWV0YWRhdGEgPSBkZWZhdWx0VmFsdWUob3B0aW9ucy5yZXF1ZXN0TWV0YWRhdGEsIHRydWUpO1xuXG4gIHRoaXMuX2Vycm9yRXZlbnQgPSBuZXcgRXZlbnQoKTtcblxuICB2YXIgY3JlZGl0ID0gb3B0aW9ucy5jcmVkaXQ7XG4gIGlmICh0eXBlb2YgY3JlZGl0ID09PSBcInN0cmluZ1wiKSB7XG4gICAgY3JlZGl0ID0gbmV3IENyZWRpdChjcmVkaXQpO1xuICB9XG4gIHRoaXMuX2NyZWRpdCA9IGNyZWRpdDtcblxuICB0aGlzLl9hdmFpbGFiaWxpdHkgPSB1bmRlZmluZWQ7XG5cbiAgdmFyIGRlZmVycmVkID0gd2hlbi5kZWZlcigpO1xuICB0aGlzLl9yZWFkeSA9IGZhbHNlO1xuICB0aGlzLl9yZWFkeVByb21pc2UgPSBkZWZlcnJlZDtcbiAgdGhpcy5fdGlsZUNyZWRpdHMgPSB1bmRlZmluZWQ7XG5cbiAgdmFyIHRoYXQgPSB0aGlzO1xuICB2YXIgbGFzdFJlc291cmNlO1xuICB2YXIgbGF5ZXJKc29uUmVzb3VyY2U7XG4gIHZhciBtZXRhZGF0YUVycm9yO1xuXG4gIHZhciBsYXllcnMgPSAodGhpcy5fbGF5ZXJzID0gW10pO1xuICB2YXIgYXR0cmlidXRpb24gPSBcIlwiO1xuICB2YXIgb3ZlcmFsbEF2YWlsYWJpbGl0eSA9IFtdO1xuICB2YXIgb3ZlcmFsbE1heFpvb20gPSAwO1xuICB3aGVuKG9wdGlvbnMudXJsKVxuICAgIC50aGVuKGZ1bmN0aW9uICh1cmwpIHtcbiAgICAgIHZhciByZXNvdXJjZSA9IFJlc291cmNlLmNyZWF0ZUlmTmVlZGVkKHVybCk7XG4gICAgICByZXNvdXJjZS5hcHBlbmRGb3J3YXJkU2xhc2goKTtcbiAgICAgIGxhc3RSZXNvdXJjZSA9IHJlc291cmNlO1xuICAgICAgbGF5ZXJKc29uUmVzb3VyY2UgPSBsYXN0UmVzb3VyY2UuZ2V0RGVyaXZlZFJlc291cmNlKHtcbiAgICAgICAgdXJsOiBcImxheWVyLmpzb25cIixcbiAgICAgIH0pO1xuXG4gICAgICAvLyBpb24gcmVzb3VyY2VzIGhhdmUgYSBjcmVkaXRzIHByb3BlcnR5IHdlIGNhbiB1c2UgZm9yIGFkZGl0aW9uYWwgYXR0cmlidXRpb24uXG4gICAgICB0aGF0Ll90aWxlQ3JlZGl0cyA9IHJlc291cmNlLmNyZWRpdHM7XG5cbiAgICAgIHJlcXVlc3RMYXllckpzb24oKTtcbiAgICB9KVxuICAgIC5vdGhlcndpc2UoZnVuY3Rpb24gKGUpIHtcbiAgICAgIGRlZmVycmVkLnJlamVjdChlKTtcbiAgICB9KTtcblxuICBmdW5jdGlvbiBwYXJzZU1ldGFkYXRhU3VjY2VzcyhkYXRhKSB7XG4gICAgdmFyIG1lc3NhZ2U7XG5cbiAgICBpZiAoIWRhdGEuZm9ybWF0KSB7XG4gICAgICBtZXNzYWdlID0gXCJUaGUgdGlsZSBmb3JtYXQgaXMgbm90IHNwZWNpZmllZCBpbiB0aGUgbGF5ZXIuanNvbiBmaWxlLlwiO1xuICAgICAgbWV0YWRhdGFFcnJvciA9IFRpbGVQcm92aWRlckVycm9yLmhhbmRsZUVycm9yKFxuICAgICAgICBtZXRhZGF0YUVycm9yLFxuICAgICAgICB0aGF0LFxuICAgICAgICB0aGF0Ll9lcnJvckV2ZW50LFxuICAgICAgICBtZXNzYWdlLFxuICAgICAgICB1bmRlZmluZWQsXG4gICAgICAgIHVuZGVmaW5lZCxcbiAgICAgICAgdW5kZWZpbmVkLFxuICAgICAgICByZXF1ZXN0TGF5ZXJKc29uXG4gICAgICApO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmICghZGF0YS50aWxlcyB8fCBkYXRhLnRpbGVzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgbWVzc2FnZSA9IFwiVGhlIGxheWVyLmpzb24gZmlsZSBkb2VzIG5vdCBzcGVjaWZ5IGFueSB0aWxlIFVSTCB0ZW1wbGF0ZXMuXCI7XG4gICAgICBtZXRhZGF0YUVycm9yID0gVGlsZVByb3ZpZGVyRXJyb3IuaGFuZGxlRXJyb3IoXG4gICAgICAgIG1ldGFkYXRhRXJyb3IsXG4gICAgICAgIHRoYXQsXG4gICAgICAgIHRoYXQuX2Vycm9yRXZlbnQsXG4gICAgICAgIG1lc3NhZ2UsXG4gICAgICAgIHVuZGVmaW5lZCxcbiAgICAgICAgdW5kZWZpbmVkLFxuICAgICAgICB1bmRlZmluZWQsXG4gICAgICAgIHJlcXVlc3RMYXllckpzb25cbiAgICAgICk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIGhhc1ZlcnRleE5vcm1hbHMgPSBmYWxzZTtcbiAgICB2YXIgaGFzV2F0ZXJNYXNrID0gZmFsc2U7XG4gICAgdmFyIGhhc01ldGFkYXRhID0gZmFsc2U7XG4gICAgdmFyIGxpdHRsZUVuZGlhbkV4dGVuc2lvblNpemUgPSB0cnVlO1xuICAgIHZhciBpc0hlaWdodG1hcCA9IGZhbHNlO1xuICAgIGlmIChkYXRhLmZvcm1hdCA9PT0gXCJoZWlnaHRtYXAtMS4wXCIpIHtcbiAgICAgIGlzSGVpZ2h0bWFwID0gdHJ1ZTtcbiAgICAgIGlmICghZGVmaW5lZCh0aGF0Ll9oZWlnaHRtYXBTdHJ1Y3R1cmUpKSB7XG4gICAgICAgIHRoYXQuX2hlaWdodG1hcFN0cnVjdHVyZSA9IHtcbiAgICAgICAgICBoZWlnaHRTY2FsZTogMS4wIC8gNS4wLFxuICAgICAgICAgIGhlaWdodE9mZnNldDogLTEwMDAuMCxcbiAgICAgICAgICBlbGVtZW50c1BlckhlaWdodDogMSxcbiAgICAgICAgICBzdHJpZGU6IDEsXG4gICAgICAgICAgZWxlbWVudE11bHRpcGxpZXI6IDI1Ni4wLFxuICAgICAgICAgIGlzQmlnRW5kaWFuOiBmYWxzZSxcbiAgICAgICAgICBsb3dlc3RFbmNvZGVkSGVpZ2h0OiAwLFxuICAgICAgICAgIGhpZ2hlc3RFbmNvZGVkSGVpZ2h0OiAyNTYgKiAyNTYgLSAxLFxuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgaGFzV2F0ZXJNYXNrID0gdHJ1ZTtcbiAgICAgIHRoYXQuX3JlcXVlc3RXYXRlck1hc2sgPSB0cnVlO1xuICAgIH0gZWxzZSBpZiAoZGF0YS5mb3JtYXQuaW5kZXhPZihcInF1YW50aXplZC1tZXNoLTEuXCIpICE9PSAwKSB7XG4gICAgICBtZXNzYWdlID1cbiAgICAgICAgJ1RoZSB0aWxlIGZvcm1hdCBcIicgKyBkYXRhLmZvcm1hdCArICdcIiBpcyBpbnZhbGlkIG9yIG5vdCBzdXBwb3J0ZWQuJztcbiAgICAgIG1ldGFkYXRhRXJyb3IgPSBUaWxlUHJvdmlkZXJFcnJvci5oYW5kbGVFcnJvcihcbiAgICAgICAgbWV0YWRhdGFFcnJvcixcbiAgICAgICAgdGhhdCxcbiAgICAgICAgdGhhdC5fZXJyb3JFdmVudCxcbiAgICAgICAgbWVzc2FnZSxcbiAgICAgICAgdW5kZWZpbmVkLFxuICAgICAgICB1bmRlZmluZWQsXG4gICAgICAgIHVuZGVmaW5lZCxcbiAgICAgICAgcmVxdWVzdExheWVySnNvblxuICAgICAgKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgdGlsZVVybFRlbXBsYXRlcyA9IGRhdGEudGlsZXM7XG5cbiAgICB2YXIgbWF4Wm9vbSA9IGRhdGEubWF4em9vbTtcbiAgICBvdmVyYWxsTWF4Wm9vbSA9IE1hdGgubWF4KG92ZXJhbGxNYXhab29tLCBtYXhab29tKTtcbiAgICAvLyBLZWVwcyB0cmFjayBvZiB3aGljaCBvZiB0aGUgYXZhaWxhYmxpdHkgY29udGFpbmluZyB0aWxlcyBoYXZlIGJlZW4gbG9hZGVkXG5cbiAgICBpZiAoIWRhdGEucHJvamVjdGlvbiB8fCBkYXRhLnByb2plY3Rpb24gPT09IFwiRVBTRzo0MzI2XCIpIHtcbiAgICAgIHRoYXQuX3RpbGluZ1NjaGVtZSA9IG5ldyBHZW9ncmFwaGljVGlsaW5nU2NoZW1lKHtcbiAgICAgICAgbnVtYmVyT2ZMZXZlbFplcm9UaWxlc1g6IDIsXG4gICAgICAgIG51bWJlck9mTGV2ZWxaZXJvVGlsZXNZOiAxLFxuICAgICAgICBlbGxpcHNvaWQ6IHRoYXQuX2VsbGlwc29pZCxcbiAgICAgIH0pO1xuICAgIH0gZWxzZSBpZiAoZGF0YS5wcm9qZWN0aW9uID09PSBcIkVQU0c6Mzg1N1wiKSB7XG4gICAgICB0aGF0Ll90aWxpbmdTY2hlbWUgPSBuZXcgV2ViTWVyY2F0b3JUaWxpbmdTY2hlbWUoe1xuICAgICAgICBudW1iZXJPZkxldmVsWmVyb1RpbGVzWDogMSxcbiAgICAgICAgbnVtYmVyT2ZMZXZlbFplcm9UaWxlc1k6IDEsXG4gICAgICAgIGVsbGlwc29pZDogdGhhdC5fZWxsaXBzb2lkLFxuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG1lc3NhZ2UgPVxuICAgICAgICAnVGhlIHByb2plY3Rpb24gXCInICsgZGF0YS5wcm9qZWN0aW9uICsgJ1wiIGlzIGludmFsaWQgb3Igbm90IHN1cHBvcnRlZC4nO1xuICAgICAgbWV0YWRhdGFFcnJvciA9IFRpbGVQcm92aWRlckVycm9yLmhhbmRsZUVycm9yKFxuICAgICAgICBtZXRhZGF0YUVycm9yLFxuICAgICAgICB0aGF0LFxuICAgICAgICB0aGF0Ll9lcnJvckV2ZW50LFxuICAgICAgICBtZXNzYWdlLFxuICAgICAgICB1bmRlZmluZWQsXG4gICAgICAgIHVuZGVmaW5lZCxcbiAgICAgICAgdW5kZWZpbmVkLFxuICAgICAgICByZXF1ZXN0TGF5ZXJKc29uXG4gICAgICApO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoYXQuX2xldmVsWmVyb01heGltdW1HZW9tZXRyaWNFcnJvciA9IFRlcnJhaW5Qcm92aWRlci5nZXRFc3RpbWF0ZWRMZXZlbFplcm9HZW9tZXRyaWNFcnJvckZvckFIZWlnaHRtYXAoXG4gICAgICB0aGF0Ll90aWxpbmdTY2hlbWUuZWxsaXBzb2lkLFxuICAgICAgdGhhdC5faGVpZ2h0bWFwV2lkdGgsXG4gICAgICB0aGF0Ll90aWxpbmdTY2hlbWUuZ2V0TnVtYmVyT2ZYVGlsZXNBdExldmVsKDApXG4gICAgKTtcbiAgICBpZiAoIWRhdGEuc2NoZW1lIHx8IGRhdGEuc2NoZW1lID09PSBcInRtc1wiIHx8IGRhdGEuc2NoZW1lID09PSBcInNsaXBweU1hcFwiKSB7XG4gICAgICB0aGF0Ll9zY2hlbWUgPSBkYXRhLnNjaGVtZTtcbiAgICB9IGVsc2Uge1xuICAgICAgbWVzc2FnZSA9ICdUaGUgc2NoZW1lIFwiJyArIGRhdGEuc2NoZW1lICsgJ1wiIGlzIGludmFsaWQgb3Igbm90IHN1cHBvcnRlZC4nO1xuICAgICAgbWV0YWRhdGFFcnJvciA9IFRpbGVQcm92aWRlckVycm9yLmhhbmRsZUVycm9yKFxuICAgICAgICBtZXRhZGF0YUVycm9yLFxuICAgICAgICB0aGF0LFxuICAgICAgICB0aGF0Ll9lcnJvckV2ZW50LFxuICAgICAgICBtZXNzYWdlLFxuICAgICAgICB1bmRlZmluZWQsXG4gICAgICAgIHVuZGVmaW5lZCxcbiAgICAgICAgdW5kZWZpbmVkLFxuICAgICAgICByZXF1ZXN0TGF5ZXJKc29uXG4gICAgICApO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBhdmFpbGFiaWxpdHlUaWxlc0xvYWRlZDtcblxuICAgIC8vIFRoZSB2ZXJ0ZXggbm9ybWFscyBkZWZpbmVkIGluIHRoZSAnb2N0dmVydGV4bm9ybWFscycgZXh0ZW5zaW9uIGlzIGlkZW50aWNhbCB0byB0aGUgb3JpZ2luYWxcbiAgICAvLyBjb250ZW50cyBvZiB0aGUgb3JpZ2luYWwgJ3ZlcnRleG5vcm1hbHMnIGV4dGVuc2lvbi4gICd2ZXJ0ZXhub3JtYWxzJyBleHRlbnNpb24gaXMgbm93XG4gICAgLy8gZGVwcmVjYXRlZCwgYXMgdGhlIGV4dGVuc2lvbkxlbmd0aCBmb3IgdGhpcyBleHRlbnNpb24gd2FzIGluY29ycmVjdGx5IHVzaW5nIGJpZyBlbmRpYW4uXG4gICAgLy8gV2UgbWFpbnRhaW4gYmFja3dhcmRzIGNvbXBhdGliaWxpdHkgd2l0aCB0aGUgbGVnYWN5ICd2ZXJ0ZXhub3JtYWwnIGltcGxlbWVudGF0aW9uXG4gICAgLy8gYnkgc2V0dGluZyB0aGUgX2xpdHRsZUVuZGlhbkV4dGVuc2lvblNpemUgdG8gZmFsc2UuIEFsd2F5cyBwcmVmZXIgJ29jdHZlcnRleG5vcm1hbHMnXG4gICAgLy8gb3ZlciAndmVydGV4bm9ybWFscycgaWYgYm90aCBleHRlbnNpb25zIGFyZSBzdXBwb3J0ZWQgYnkgdGhlIHNlcnZlci5cbiAgICBpZiAoXG4gICAgICBkZWZpbmVkKGRhdGEuZXh0ZW5zaW9ucykgJiZcbiAgICAgIGRhdGEuZXh0ZW5zaW9ucy5pbmRleE9mKFwib2N0dmVydGV4bm9ybWFsc1wiKSAhPT0gLTFcbiAgICApIHtcbiAgICAgIGhhc1ZlcnRleE5vcm1hbHMgPSB0cnVlO1xuICAgIH0gZWxzZSBpZiAoXG4gICAgICBkZWZpbmVkKGRhdGEuZXh0ZW5zaW9ucykgJiZcbiAgICAgIGRhdGEuZXh0ZW5zaW9ucy5pbmRleE9mKFwidmVydGV4bm9ybWFsc1wiKSAhPT0gLTFcbiAgICApIHtcbiAgICAgIGhhc1ZlcnRleE5vcm1hbHMgPSB0cnVlO1xuICAgICAgbGl0dGxlRW5kaWFuRXh0ZW5zaW9uU2l6ZSA9IGZhbHNlO1xuICAgIH1cbiAgICBpZiAoXG4gICAgICBkZWZpbmVkKGRhdGEuZXh0ZW5zaW9ucykgJiZcbiAgICAgIGRhdGEuZXh0ZW5zaW9ucy5pbmRleE9mKFwid2F0ZXJtYXNrXCIpICE9PSAtMVxuICAgICkge1xuICAgICAgaGFzV2F0ZXJNYXNrID0gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKFxuICAgICAgZGVmaW5lZChkYXRhLmV4dGVuc2lvbnMpICYmXG4gICAgICBkYXRhLmV4dGVuc2lvbnMuaW5kZXhPZihcIm1ldGFkYXRhXCIpICE9PSAtMVxuICAgICkge1xuICAgICAgaGFzTWV0YWRhdGEgPSB0cnVlO1xuICAgIH1cblxuICAgIHZhciBhdmFpbGFiaWxpdHlMZXZlbHMgPSBkYXRhLm1ldGFkYXRhQXZhaWxhYmlsaXR5O1xuICAgIHZhciBhdmFpbGFibGVUaWxlcyA9IGRhdGEuYXZhaWxhYmxlO1xuICAgIHZhciBhdmFpbGFiaWxpdHk7XG4gICAgaWYgKGRlZmluZWQoYXZhaWxhYmxlVGlsZXMpICYmICFkZWZpbmVkKGF2YWlsYWJpbGl0eUxldmVscykpIHtcbiAgICAgIGF2YWlsYWJpbGl0eSA9IG5ldyBUaWxlQXZhaWxhYmlsaXR5KFxuICAgICAgICB0aGF0Ll90aWxpbmdTY2hlbWUsXG4gICAgICAgIGF2YWlsYWJsZVRpbGVzLmxlbmd0aFxuICAgICAgKTtcbiAgICAgIGZvciAodmFyIGxldmVsID0gMDsgbGV2ZWwgPCBhdmFpbGFibGVUaWxlcy5sZW5ndGg7ICsrbGV2ZWwpIHtcbiAgICAgICAgdmFyIHJhbmdlc0F0TGV2ZWwgPSBhdmFpbGFibGVUaWxlc1tsZXZlbF07XG4gICAgICAgIHZhciB5VGlsZXMgPSB0aGF0Ll90aWxpbmdTY2hlbWUuZ2V0TnVtYmVyT2ZZVGlsZXNBdExldmVsKGxldmVsKTtcbiAgICAgICAgaWYgKCFkZWZpbmVkKG92ZXJhbGxBdmFpbGFiaWxpdHlbbGV2ZWxdKSkge1xuICAgICAgICAgIG92ZXJhbGxBdmFpbGFiaWxpdHlbbGV2ZWxdID0gW107XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKFxuICAgICAgICAgIHZhciByYW5nZUluZGV4ID0gMDtcbiAgICAgICAgICByYW5nZUluZGV4IDwgcmFuZ2VzQXRMZXZlbC5sZW5ndGg7XG4gICAgICAgICAgKytyYW5nZUluZGV4XG4gICAgICAgICkge1xuICAgICAgICAgIHZhciByYW5nZSA9IHJhbmdlc0F0TGV2ZWxbcmFuZ2VJbmRleF07XG4gICAgICAgICAgdmFyIHlTdGFydCA9IHlUaWxlcyAtIHJhbmdlLmVuZFkgLSAxO1xuICAgICAgICAgIHZhciB5RW5kID0geVRpbGVzIC0gcmFuZ2Uuc3RhcnRZIC0gMTtcbiAgICAgICAgICBvdmVyYWxsQXZhaWxhYmlsaXR5W2xldmVsXS5wdXNoKFtcbiAgICAgICAgICAgIHJhbmdlLnN0YXJ0WCxcbiAgICAgICAgICAgIHlTdGFydCxcbiAgICAgICAgICAgIHJhbmdlLmVuZFgsXG4gICAgICAgICAgICB5RW5kLFxuICAgICAgICAgIF0pO1xuICAgICAgICAgIGF2YWlsYWJpbGl0eS5hZGRBdmFpbGFibGVUaWxlUmFuZ2UoXG4gICAgICAgICAgICBsZXZlbCxcbiAgICAgICAgICAgIHJhbmdlLnN0YXJ0WCxcbiAgICAgICAgICAgIHlTdGFydCxcbiAgICAgICAgICAgIHJhbmdlLmVuZFgsXG4gICAgICAgICAgICB5RW5kXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoZGVmaW5lZChhdmFpbGFiaWxpdHlMZXZlbHMpKSB7XG4gICAgICBhdmFpbGFiaWxpdHlUaWxlc0xvYWRlZCA9IG5ldyBUaWxlQXZhaWxhYmlsaXR5KFxuICAgICAgICB0aGF0Ll90aWxpbmdTY2hlbWUsXG4gICAgICAgIG1heFpvb21cbiAgICAgICk7XG4gICAgICBhdmFpbGFiaWxpdHkgPSBuZXcgVGlsZUF2YWlsYWJpbGl0eSh0aGF0Ll90aWxpbmdTY2hlbWUsIG1heFpvb20pO1xuICAgICAgb3ZlcmFsbEF2YWlsYWJpbGl0eVswXSA9IFtbMCwgMCwgMSwgMF1dO1xuICAgICAgYXZhaWxhYmlsaXR5LmFkZEF2YWlsYWJsZVRpbGVSYW5nZSgwLCAwLCAwLCAxLCAwKTtcbiAgICB9XG5cbiAgICB0aGF0Ll9oYXNXYXRlck1hc2sgPSB0aGF0Ll9oYXNXYXRlck1hc2sgfHwgaGFzV2F0ZXJNYXNrO1xuICAgIHRoYXQuX2hhc1ZlcnRleE5vcm1hbHMgPSB0aGF0Ll9oYXNWZXJ0ZXhOb3JtYWxzIHx8IGhhc1ZlcnRleE5vcm1hbHM7XG4gICAgdGhhdC5faGFzTWV0YWRhdGEgPSB0aGF0Ll9oYXNNZXRhZGF0YSB8fCBoYXNNZXRhZGF0YTtcbiAgICBpZiAoZGVmaW5lZChkYXRhLmF0dHJpYnV0aW9uKSkge1xuICAgICAgaWYgKGF0dHJpYnV0aW9uLmxlbmd0aCA+IDApIHtcbiAgICAgICAgYXR0cmlidXRpb24gKz0gXCIgXCI7XG4gICAgICB9XG4gICAgICBhdHRyaWJ1dGlvbiArPSBkYXRhLmF0dHJpYnV0aW9uO1xuICAgIH1cblxuICAgIGxheWVycy5wdXNoKFxuICAgICAgbmV3IExheWVySW5mb3JtYXRpb24oe1xuICAgICAgICByZXNvdXJjZTogbGFzdFJlc291cmNlLFxuICAgICAgICB2ZXJzaW9uOiBkYXRhLnZlcnNpb24sXG4gICAgICAgIGlzSGVpZ2h0bWFwOiBpc0hlaWdodG1hcCxcbiAgICAgICAgdGlsZVVybFRlbXBsYXRlczogdGlsZVVybFRlbXBsYXRlcyxcbiAgICAgICAgYXZhaWxhYmlsaXR5OiBhdmFpbGFiaWxpdHksXG4gICAgICAgIGhhc1ZlcnRleE5vcm1hbHM6IGhhc1ZlcnRleE5vcm1hbHMsXG4gICAgICAgIGhhc1dhdGVyTWFzazogaGFzV2F0ZXJNYXNrLFxuICAgICAgICBoYXNNZXRhZGF0YTogaGFzTWV0YWRhdGEsXG4gICAgICAgIGF2YWlsYWJpbGl0eUxldmVsczogYXZhaWxhYmlsaXR5TGV2ZWxzLFxuICAgICAgICBhdmFpbGFiaWxpdHlUaWxlc0xvYWRlZDogYXZhaWxhYmlsaXR5VGlsZXNMb2FkZWQsXG4gICAgICAgIGxpdHRsZUVuZGlhbkV4dGVuc2lvblNpemU6IGxpdHRsZUVuZGlhbkV4dGVuc2lvblNpemUsXG4gICAgICB9KVxuICAgICk7XG5cbiAgICB2YXIgcGFyZW50VXJsID0gZGF0YS5wYXJlbnRVcmw7XG4gICAgaWYgKGRlZmluZWQocGFyZW50VXJsKSkge1xuICAgICAgaWYgKCFkZWZpbmVkKGF2YWlsYWJpbGl0eSkpIHtcbiAgICAgICAgY29uc29sZS5sb2coXG4gICAgICAgICAgXCJBIGxheWVyLmpzb24gY2FuJ3QgaGF2ZSBhIHBhcmVudFVybCBpZiBpdCBkb2VzJ3QgaGF2ZSBhbiBhdmFpbGFibGUgYXJyYXkuXCJcbiAgICAgICAgKTtcbiAgICAgICAgcmV0dXJuIHdoZW4ucmVzb2x2ZSgpO1xuICAgICAgfVxuICAgICAgbGFzdFJlc291cmNlID0gbGFzdFJlc291cmNlLmdldERlcml2ZWRSZXNvdXJjZSh7XG4gICAgICAgIHVybDogcGFyZW50VXJsLFxuICAgICAgfSk7XG4gICAgICBsYXN0UmVzb3VyY2UuYXBwZW5kRm9yd2FyZFNsYXNoKCk7IC8vIFRlcnJhaW4gYWx3YXlzIGV4cGVjdHMgYSBkaXJlY3RvcnlcbiAgICAgIGxheWVySnNvblJlc291cmNlID0gbGFzdFJlc291cmNlLmdldERlcml2ZWRSZXNvdXJjZSh7XG4gICAgICAgIHVybDogXCJsYXllci5qc29uXCIsXG4gICAgICB9KTtcbiAgICAgIHZhciBwYXJlbnRNZXRhZGF0YSA9IGxheWVySnNvblJlc291cmNlLmZldGNoSnNvbigpO1xuICAgICAgcmV0dXJuIHdoZW4ocGFyZW50TWV0YWRhdGEsIHBhcnNlTWV0YWRhdGFTdWNjZXNzLCBwYXJzZU1ldGFkYXRhRmFpbHVyZSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHdoZW4ucmVzb2x2ZSgpO1xuICB9XG5cbiAgZnVuY3Rpb24gcGFyc2VNZXRhZGF0YUZhaWx1cmUoZGF0YSkge1xuICAgIHZhciBtZXNzYWdlID1cbiAgICAgIFwiQW4gZXJyb3Igb2NjdXJyZWQgd2hpbGUgYWNjZXNzaW5nIFwiICsgbGF5ZXJKc29uUmVzb3VyY2UudXJsICsgXCIuXCI7XG4gICAgbWV0YWRhdGFFcnJvciA9IFRpbGVQcm92aWRlckVycm9yLmhhbmRsZUVycm9yKFxuICAgICAgbWV0YWRhdGFFcnJvcixcbiAgICAgIHRoYXQsXG4gICAgICB0aGF0Ll9lcnJvckV2ZW50LFxuICAgICAgbWVzc2FnZSxcbiAgICAgIHVuZGVmaW5lZCxcbiAgICAgIHVuZGVmaW5lZCxcbiAgICAgIHVuZGVmaW5lZCxcbiAgICAgIHJlcXVlc3RMYXllckpzb25cbiAgICApO1xuICB9XG5cbiAgZnVuY3Rpb24gbWV0YWRhdGFTdWNjZXNzKGRhdGEpIHtcbiAgICBwYXJzZU1ldGFkYXRhU3VjY2VzcyhkYXRhKS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmIChkZWZpbmVkKG1ldGFkYXRhRXJyb3IpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdmFyIGxlbmd0aCA9IG92ZXJhbGxBdmFpbGFiaWxpdHkubGVuZ3RoO1xuICAgICAgaWYgKGxlbmd0aCA+IDApIHtcbiAgICAgICAgdmFyIGF2YWlsYWJpbGl0eSA9ICh0aGF0Ll9hdmFpbGFiaWxpdHkgPSBuZXcgVGlsZUF2YWlsYWJpbGl0eShcbiAgICAgICAgICB0aGF0Ll90aWxpbmdTY2hlbWUsXG4gICAgICAgICAgb3ZlcmFsbE1heFpvb21cbiAgICAgICAgKSk7XG4gICAgICAgIGZvciAodmFyIGxldmVsID0gMDsgbGV2ZWwgPCBsZW5ndGg7ICsrbGV2ZWwpIHtcbiAgICAgICAgICB2YXIgbGV2ZWxSYW5nZXMgPSBvdmVyYWxsQXZhaWxhYmlsaXR5W2xldmVsXTtcbiAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxldmVsUmFuZ2VzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICB2YXIgcmFuZ2UgPSBsZXZlbFJhbmdlc1tpXTtcbiAgICAgICAgICAgIGF2YWlsYWJpbGl0eS5hZGRBdmFpbGFibGVUaWxlUmFuZ2UoXG4gICAgICAgICAgICAgIGxldmVsLFxuICAgICAgICAgICAgICByYW5nZVswXSxcbiAgICAgICAgICAgICAgcmFuZ2VbMV0sXG4gICAgICAgICAgICAgIHJhbmdlWzJdLFxuICAgICAgICAgICAgICByYW5nZVszXVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKGF0dHJpYnV0aW9uLmxlbmd0aCA+IDApIHtcbiAgICAgICAgdmFyIGxheWVySnNvbkNyZWRpdCA9IG5ldyBDcmVkaXQoYXR0cmlidXRpb24pO1xuXG4gICAgICAgIGlmIChkZWZpbmVkKHRoYXQuX3RpbGVDcmVkaXRzKSkge1xuICAgICAgICAgIHRoYXQuX3RpbGVDcmVkaXRzLnB1c2gobGF5ZXJKc29uQ3JlZGl0KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGF0Ll90aWxlQ3JlZGl0cyA9IFtsYXllckpzb25DcmVkaXRdO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHRoYXQuX3JlYWR5ID0gdHJ1ZTtcbiAgICAgIHRoYXQuX3JlYWR5UHJvbWlzZS5yZXNvbHZlKHRydWUpO1xuICAgIH0pO1xuICB9XG5cbiAgZnVuY3Rpb24gbWV0YWRhdGFGYWlsdXJlKGRhdGEpIHtcbiAgICAvLyBJZiB0aGUgbWV0YWRhdGEgaXMgbm90IGZvdW5kLCBhc3N1bWUgdGhpcyBpcyBhIHByZS1tZXRhZGF0YSBoZWlnaHRtYXAgdGlsZXNldC5cbiAgICBpZiAoZGVmaW5lZChkYXRhKSAmJiBkYXRhLnN0YXR1c0NvZGUgPT09IDQwNCkge1xuICAgICAgbWV0YWRhdGFTdWNjZXNzKHtcbiAgICAgICAgdGlsZWpzb246IFwiMi4xLjBcIixcbiAgICAgICAgZm9ybWF0OiBcImhlaWdodG1hcC0xLjBcIixcbiAgICAgICAgdmVyc2lvbjogXCIxLjAuMFwiLFxuICAgICAgICBzY2hlbWU6IFwidG1zXCIsXG4gICAgICAgIHRpbGVzOiBbXCJ7en0ve3h9L3t5fS50ZXJyYWluP3Y9e3ZlcnNpb259XCJdLFxuICAgICAgfSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHBhcnNlTWV0YWRhdGFGYWlsdXJlKGRhdGEpO1xuICB9XG5cbiAgZnVuY3Rpb24gcmVxdWVzdExheWVySnNvbigpIHtcbiAgICB3aGVuKGxheWVySnNvblJlc291cmNlLmZldGNoSnNvbigpKVxuICAgICAgLnRoZW4obWV0YWRhdGFTdWNjZXNzKVxuICAgICAgLm90aGVyd2lzZShtZXRhZGF0YUZhaWx1cmUpO1xuICB9XG59XG5cbi8qKlxuICogV2hlbiB1c2luZyB0aGUgUXVhbnRpemVkLU1lc2ggZm9ybWF0LCBhIHRpbGUgbWF5IGJlIHJldHVybmVkIHRoYXQgaW5jbHVkZXMgYWRkaXRpb25hbCBleHRlbnNpb25zLCBzdWNoIGFzIFBlclZlcnRleE5vcm1hbHMsIHdhdGVybWFzaywgZXRjLlxuICogVGhpcyBlbnVtZXJhdGlvbiBkZWZpbmVzIHRoZSB1bmlxdWUgaWRlbnRpZmllcnMgZm9yIGVhY2ggdHlwZSBvZiBleHRlbnNpb24gZGF0YSB0aGF0IGhhcyBiZWVuIGFwcGVuZGVkIHRvIHRoZSBzdGFuZGFyZCBtZXNoIGRhdGEuXG4gKlxuICogQG5hbWVzcGFjZSBRdWFudGl6ZWRNZXNoRXh0ZW5zaW9uSWRzXG4gKiBAc2VlIENlc2l1bVRlcnJhaW5Qcm92aWRlclxuICogQHByaXZhdGVcbiAqL1xudmFyIFF1YW50aXplZE1lc2hFeHRlbnNpb25JZHMgPSB7XG4gIC8qKlxuICAgKiBPY3QtRW5jb2RlZCBQZXItVmVydGV4IE5vcm1hbHMgYXJlIGluY2x1ZGVkIGFzIGFuIGV4dGVuc2lvbiB0byB0aGUgdGlsZSBtZXNoXG4gICAqXG4gICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAqIEBjb25zdGFudFxuICAgKiBAZGVmYXVsdCAxXG4gICAqL1xuICBPQ1RfVkVSVEVYX05PUk1BTFM6IDEsXG4gIC8qKlxuICAgKiBBIHdhdGVybWFzayBpcyBpbmNsdWRlZCBhcyBhbiBleHRlbnNpb24gdG8gdGhlIHRpbGUgbWVzaFxuICAgKlxuICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgKiBAY29uc3RhbnRcbiAgICogQGRlZmF1bHQgMlxuICAgKi9cbiAgV0FURVJfTUFTSzogMixcbiAgLyoqXG4gICAqIEEganNvbiBvYmplY3QgY29udGFpbiBtZXRhZGF0YSBhYm91dCB0aGUgdGlsZVxuICAgKlxuICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgKiBAY29uc3RhbnRcbiAgICogQGRlZmF1bHQgNFxuICAgKi9cbiAgTUVUQURBVEE6IDQsXG59O1xuXG5mdW5jdGlvbiBnZXRSZXF1ZXN0SGVhZGVyKGV4dGVuc2lvbnNMaXN0KSB7XG4gIGlmICghZGVmaW5lZChleHRlbnNpb25zTGlzdCkgfHwgZXh0ZW5zaW9uc0xpc3QubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIEFjY2VwdDpcbiAgICAgICAgXCJhcHBsaWNhdGlvbi92bmQucXVhbnRpemVkLW1lc2gsYXBwbGljYXRpb24vb2N0ZXQtc3RyZWFtO3E9MC45LCovKjtxPTAuMDFcIixcbiAgICB9O1xuICB9XG4gIHZhciBleHRlbnNpb25zID0gZXh0ZW5zaW9uc0xpc3Quam9pbihcIi1cIik7XG4gIHJldHVybiB7XG4gICAgQWNjZXB0OlxuICAgICAgXCJhcHBsaWNhdGlvbi92bmQucXVhbnRpemVkLW1lc2g7ZXh0ZW5zaW9ucz1cIiArXG4gICAgICBleHRlbnNpb25zICtcbiAgICAgIFwiLGFwcGxpY2F0aW9uL29jdGV0LXN0cmVhbTtxPTAuOSwqLyo7cT0wLjAxXCIsXG4gIH07XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUhlaWdodG1hcFRlcnJhaW5EYXRhKHByb3ZpZGVyLCBidWZmZXIsIGxldmVsLCB4LCB5KSB7XG4gIHZhciBoZWlnaHRCdWZmZXIgPSBuZXcgVWludDE2QXJyYXkoXG4gICAgYnVmZmVyLFxuICAgIDAsXG4gICAgcHJvdmlkZXIuX2hlaWdodG1hcFdpZHRoICogcHJvdmlkZXIuX2hlaWdodG1hcFdpZHRoXG4gICk7XG4gIHJldHVybiBuZXcgSGVpZ2h0bWFwVGVycmFpbkRhdGEoe1xuICAgIGJ1ZmZlcjogaGVpZ2h0QnVmZmVyLFxuICAgIGNoaWxkVGlsZU1hc2s6IG5ldyBVaW50OEFycmF5KGJ1ZmZlciwgaGVpZ2h0QnVmZmVyLmJ5dGVMZW5ndGgsIDEpWzBdLFxuICAgIHdhdGVyTWFzazogbmV3IFVpbnQ4QXJyYXkoXG4gICAgICBidWZmZXIsXG4gICAgICBoZWlnaHRCdWZmZXIuYnl0ZUxlbmd0aCArIDEsXG4gICAgICBidWZmZXIuYnl0ZUxlbmd0aCAtIGhlaWdodEJ1ZmZlci5ieXRlTGVuZ3RoIC0gMVxuICAgICksXG4gICAgd2lkdGg6IHByb3ZpZGVyLl9oZWlnaHRtYXBXaWR0aCxcbiAgICBoZWlnaHQ6IHByb3ZpZGVyLl9oZWlnaHRtYXBXaWR0aCxcbiAgICBzdHJ1Y3R1cmU6IHByb3ZpZGVyLl9oZWlnaHRtYXBTdHJ1Y3R1cmUsXG4gICAgY3JlZGl0czogcHJvdmlkZXIuX3RpbGVDcmVkaXRzLFxuICB9KTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlUXVhbnRpemVkTWVzaFRlcnJhaW5EYXRhKHByb3ZpZGVyLCBidWZmZXIsIGxldmVsLCB4LCB5LCBsYXllcikge1xuICB2YXIgbGl0dGxlRW5kaWFuRXh0ZW5zaW9uU2l6ZSA9IGxheWVyLmxpdHRsZUVuZGlhbkV4dGVuc2lvblNpemU7XG4gIHZhciBwb3MgPSAwO1xuICB2YXIgY2FydGVzaWFuM0VsZW1lbnRzID0gMztcbiAgdmFyIGJvdW5kaW5nU3BoZXJlRWxlbWVudHMgPSBjYXJ0ZXNpYW4zRWxlbWVudHMgKyAxO1xuICB2YXIgY2FydGVzaWFuM0xlbmd0aCA9IEZsb2F0NjRBcnJheS5CWVRFU19QRVJfRUxFTUVOVCAqIGNhcnRlc2lhbjNFbGVtZW50cztcbiAgdmFyIGJvdW5kaW5nU3BoZXJlTGVuZ3RoID1cbiAgICBGbG9hdDY0QXJyYXkuQllURVNfUEVSX0VMRU1FTlQgKiBib3VuZGluZ1NwaGVyZUVsZW1lbnRzO1xuICB2YXIgZW5jb2RlZFZlcnRleEVsZW1lbnRzID0gMztcbiAgdmFyIGVuY29kZWRWZXJ0ZXhMZW5ndGggPVxuICAgIFVpbnQxNkFycmF5LkJZVEVTX1BFUl9FTEVNRU5UICogZW5jb2RlZFZlcnRleEVsZW1lbnRzO1xuICB2YXIgdHJpYW5nbGVFbGVtZW50cyA9IDM7XG4gIHZhciBieXRlc1BlckluZGV4ID0gVWludDE2QXJyYXkuQllURVNfUEVSX0VMRU1FTlQ7XG4gIHZhciB0cmlhbmdsZUxlbmd0aCA9IGJ5dGVzUGVySW5kZXggKiB0cmlhbmdsZUVsZW1lbnRzO1xuXG4gIHZhciB2aWV3ID0gbmV3IERhdGFWaWV3KGJ1ZmZlcik7XG4gIHZhciBjZW50ZXIgPSBuZXcgQ2FydGVzaWFuMyhcbiAgICB2aWV3LmdldEZsb2F0NjQocG9zLCB0cnVlKSxcbiAgICB2aWV3LmdldEZsb2F0NjQocG9zICsgOCwgdHJ1ZSksXG4gICAgdmlldy5nZXRGbG9hdDY0KHBvcyArIDE2LCB0cnVlKVxuICApO1xuICBwb3MgKz0gY2FydGVzaWFuM0xlbmd0aDtcblxuICB2YXIgbWluaW11bUhlaWdodCA9IHZpZXcuZ2V0RmxvYXQzMihwb3MsIHRydWUpO1xuICBwb3MgKz0gRmxvYXQzMkFycmF5LkJZVEVTX1BFUl9FTEVNRU5UO1xuICB2YXIgbWF4aW11bUhlaWdodCA9IHZpZXcuZ2V0RmxvYXQzMihwb3MsIHRydWUpO1xuICBwb3MgKz0gRmxvYXQzMkFycmF5LkJZVEVTX1BFUl9FTEVNRU5UO1xuXG4gIHZhciBib3VuZGluZ1NwaGVyZSA9IG5ldyBCb3VuZGluZ1NwaGVyZShcbiAgICBuZXcgQ2FydGVzaWFuMyhcbiAgICAgIHZpZXcuZ2V0RmxvYXQ2NChwb3MsIHRydWUpLFxuICAgICAgdmlldy5nZXRGbG9hdDY0KHBvcyArIDgsIHRydWUpLFxuICAgICAgdmlldy5nZXRGbG9hdDY0KHBvcyArIDE2LCB0cnVlKVxuICAgICksXG4gICAgdmlldy5nZXRGbG9hdDY0KHBvcyArIGNhcnRlc2lhbjNMZW5ndGgsIHRydWUpXG4gICk7XG4gIHBvcyArPSBib3VuZGluZ1NwaGVyZUxlbmd0aDtcblxuICB2YXIgaG9yaXpvbk9jY2x1c2lvblBvaW50ID0gbmV3IENhcnRlc2lhbjMoXG4gICAgdmlldy5nZXRGbG9hdDY0KHBvcywgdHJ1ZSksXG4gICAgdmlldy5nZXRGbG9hdDY0KHBvcyArIDgsIHRydWUpLFxuICAgIHZpZXcuZ2V0RmxvYXQ2NChwb3MgKyAxNiwgdHJ1ZSlcbiAgKTtcbiAgcG9zICs9IGNhcnRlc2lhbjNMZW5ndGg7XG5cbiAgdmFyIHZlcnRleENvdW50ID0gdmlldy5nZXRVaW50MzIocG9zLCB0cnVlKTtcbiAgcG9zICs9IFVpbnQzMkFycmF5LkJZVEVTX1BFUl9FTEVNRU5UO1xuICB2YXIgZW5jb2RlZFZlcnRleEJ1ZmZlciA9IG5ldyBVaW50MTZBcnJheShidWZmZXIsIHBvcywgdmVydGV4Q291bnQgKiAzKTtcbiAgcG9zICs9IHZlcnRleENvdW50ICogZW5jb2RlZFZlcnRleExlbmd0aDtcblxuICBpZiAodmVydGV4Q291bnQgPiA2NCAqIDEwMjQpIHtcbiAgICAvLyBNb3JlIHRoYW4gNjRrIHZlcnRpY2VzLCBzbyBpbmRpY2VzIGFyZSAzMi1iaXQuXG4gICAgYnl0ZXNQZXJJbmRleCA9IFVpbnQzMkFycmF5LkJZVEVTX1BFUl9FTEVNRU5UO1xuICAgIHRyaWFuZ2xlTGVuZ3RoID0gYnl0ZXNQZXJJbmRleCAqIHRyaWFuZ2xlRWxlbWVudHM7XG4gIH1cblxuICAvLyBEZWNvZGUgdGhlIHZlcnRleCBidWZmZXIuXG4gIHZhciB1QnVmZmVyID0gZW5jb2RlZFZlcnRleEJ1ZmZlci5zdWJhcnJheSgwLCB2ZXJ0ZXhDb3VudCk7XG4gIHZhciB2QnVmZmVyID0gZW5jb2RlZFZlcnRleEJ1ZmZlci5zdWJhcnJheSh2ZXJ0ZXhDb3VudCwgMiAqIHZlcnRleENvdW50KTtcbiAgdmFyIGhlaWdodEJ1ZmZlciA9IGVuY29kZWRWZXJ0ZXhCdWZmZXIuc3ViYXJyYXkoXG4gICAgdmVydGV4Q291bnQgKiAyLFxuICAgIDMgKiB2ZXJ0ZXhDb3VudFxuICApO1xuXG4gIEF0dHJpYnV0ZUNvbXByZXNzaW9uLnppZ1phZ0RlbHRhRGVjb2RlKHVCdWZmZXIsIHZCdWZmZXIsIGhlaWdodEJ1ZmZlcik7XG5cbiAgLy8gc2tpcCBvdmVyIGFueSBhZGRpdGlvbmFsIHBhZGRpbmcgdGhhdCB3YXMgYWRkZWQgZm9yIDIvNCBieXRlIGFsaWdubWVudFxuICBpZiAocG9zICUgYnl0ZXNQZXJJbmRleCAhPT0gMCkge1xuICAgIHBvcyArPSBieXRlc1BlckluZGV4IC0gKHBvcyAlIGJ5dGVzUGVySW5kZXgpO1xuICB9XG5cbiAgdmFyIHRyaWFuZ2xlQ291bnQgPSB2aWV3LmdldFVpbnQzMihwb3MsIHRydWUpO1xuICBwb3MgKz0gVWludDMyQXJyYXkuQllURVNfUEVSX0VMRU1FTlQ7XG4gIHZhciBpbmRpY2VzID0gSW5kZXhEYXRhdHlwZS5jcmVhdGVUeXBlZEFycmF5RnJvbUFycmF5QnVmZmVyKFxuICAgIHZlcnRleENvdW50LFxuICAgIGJ1ZmZlcixcbiAgICBwb3MsXG4gICAgdHJpYW5nbGVDb3VudCAqIHRyaWFuZ2xlRWxlbWVudHNcbiAgKTtcbiAgcG9zICs9IHRyaWFuZ2xlQ291bnQgKiB0cmlhbmdsZUxlbmd0aDtcblxuICAvLyBIaWdoIHdhdGVyIG1hcmsgZGVjb2RpbmcgYmFzZWQgb24gZGVjb21wcmVzc0luZGljZXNfIGluIHdlYmdsLWxvYWRlcidzIGxvYWRlci5qcy5cbiAgLy8gaHR0cHM6Ly9jb2RlLmdvb2dsZS5jb20vcC93ZWJnbC1sb2FkZXIvc291cmNlL2Jyb3dzZS90cnVuay9zYW1wbGVzL2xvYWRlci5qcz9yPTk5IzU1XG4gIC8vIENvcHlyaWdodCAyMDEyIEdvb2dsZSBJbmMuLCBBcGFjaGUgMi4wIGxpY2Vuc2UuXG4gIHZhciBoaWdoZXN0ID0gMDtcbiAgdmFyIGxlbmd0aCA9IGluZGljZXMubGVuZ3RoO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgKytpKSB7XG4gICAgdmFyIGNvZGUgPSBpbmRpY2VzW2ldO1xuICAgIGluZGljZXNbaV0gPSBoaWdoZXN0IC0gY29kZTtcbiAgICBpZiAoY29kZSA9PT0gMCkge1xuICAgICAgKytoaWdoZXN0O1xuICAgIH1cbiAgfVxuXG4gIHZhciB3ZXN0VmVydGV4Q291bnQgPSB2aWV3LmdldFVpbnQzMihwb3MsIHRydWUpO1xuICBwb3MgKz0gVWludDMyQXJyYXkuQllURVNfUEVSX0VMRU1FTlQ7XG4gIHZhciB3ZXN0SW5kaWNlcyA9IEluZGV4RGF0YXR5cGUuY3JlYXRlVHlwZWRBcnJheUZyb21BcnJheUJ1ZmZlcihcbiAgICB2ZXJ0ZXhDb3VudCxcbiAgICBidWZmZXIsXG4gICAgcG9zLFxuICAgIHdlc3RWZXJ0ZXhDb3VudFxuICApO1xuICBwb3MgKz0gd2VzdFZlcnRleENvdW50ICogYnl0ZXNQZXJJbmRleDtcblxuICB2YXIgc291dGhWZXJ0ZXhDb3VudCA9IHZpZXcuZ2V0VWludDMyKHBvcywgdHJ1ZSk7XG4gIHBvcyArPSBVaW50MzJBcnJheS5CWVRFU19QRVJfRUxFTUVOVDtcbiAgdmFyIHNvdXRoSW5kaWNlcyA9IEluZGV4RGF0YXR5cGUuY3JlYXRlVHlwZWRBcnJheUZyb21BcnJheUJ1ZmZlcihcbiAgICB2ZXJ0ZXhDb3VudCxcbiAgICBidWZmZXIsXG4gICAgcG9zLFxuICAgIHNvdXRoVmVydGV4Q291bnRcbiAgKTtcbiAgcG9zICs9IHNvdXRoVmVydGV4Q291bnQgKiBieXRlc1BlckluZGV4O1xuXG4gIHZhciBlYXN0VmVydGV4Q291bnQgPSB2aWV3LmdldFVpbnQzMihwb3MsIHRydWUpO1xuICBwb3MgKz0gVWludDMyQXJyYXkuQllURVNfUEVSX0VMRU1FTlQ7XG4gIHZhciBlYXN0SW5kaWNlcyA9IEluZGV4RGF0YXR5cGUuY3JlYXRlVHlwZWRBcnJheUZyb21BcnJheUJ1ZmZlcihcbiAgICB2ZXJ0ZXhDb3VudCxcbiAgICBidWZmZXIsXG4gICAgcG9zLFxuICAgIGVhc3RWZXJ0ZXhDb3VudFxuICApO1xuICBwb3MgKz0gZWFzdFZlcnRleENvdW50ICogYnl0ZXNQZXJJbmRleDtcblxuICB2YXIgbm9ydGhWZXJ0ZXhDb3VudCA9IHZpZXcuZ2V0VWludDMyKHBvcywgdHJ1ZSk7XG4gIHBvcyArPSBVaW50MzJBcnJheS5CWVRFU19QRVJfRUxFTUVOVDtcbiAgdmFyIG5vcnRoSW5kaWNlcyA9IEluZGV4RGF0YXR5cGUuY3JlYXRlVHlwZWRBcnJheUZyb21BcnJheUJ1ZmZlcihcbiAgICB2ZXJ0ZXhDb3VudCxcbiAgICBidWZmZXIsXG4gICAgcG9zLFxuICAgIG5vcnRoVmVydGV4Q291bnRcbiAgKTtcbiAgcG9zICs9IG5vcnRoVmVydGV4Q291bnQgKiBieXRlc1BlckluZGV4O1xuXG4gIHZhciBlbmNvZGVkTm9ybWFsQnVmZmVyO1xuICB2YXIgd2F0ZXJNYXNrQnVmZmVyO1xuICB3aGlsZSAocG9zIDwgdmlldy5ieXRlTGVuZ3RoKSB7XG4gICAgdmFyIGV4dGVuc2lvbklkID0gdmlldy5nZXRVaW50OChwb3MsIHRydWUpO1xuICAgIHBvcyArPSBVaW50OEFycmF5LkJZVEVTX1BFUl9FTEVNRU5UO1xuICAgIHZhciBleHRlbnNpb25MZW5ndGggPSB2aWV3LmdldFVpbnQzMihwb3MsIGxpdHRsZUVuZGlhbkV4dGVuc2lvblNpemUpO1xuICAgIHBvcyArPSBVaW50MzJBcnJheS5CWVRFU19QRVJfRUxFTUVOVDtcblxuICAgIGlmIChcbiAgICAgIGV4dGVuc2lvbklkID09PSBRdWFudGl6ZWRNZXNoRXh0ZW5zaW9uSWRzLk9DVF9WRVJURVhfTk9STUFMUyAmJlxuICAgICAgcHJvdmlkZXIuX3JlcXVlc3RWZXJ0ZXhOb3JtYWxzXG4gICAgKSB7XG4gICAgICBlbmNvZGVkTm9ybWFsQnVmZmVyID0gbmV3IFVpbnQ4QXJyYXkoYnVmZmVyLCBwb3MsIHZlcnRleENvdW50ICogMik7XG4gICAgfSBlbHNlIGlmIChcbiAgICAgIGV4dGVuc2lvbklkID09PSBRdWFudGl6ZWRNZXNoRXh0ZW5zaW9uSWRzLldBVEVSX01BU0sgJiZcbiAgICAgIHByb3ZpZGVyLl9yZXF1ZXN0V2F0ZXJNYXNrXG4gICAgKSB7XG4gICAgICB3YXRlck1hc2tCdWZmZXIgPSBuZXcgVWludDhBcnJheShidWZmZXIsIHBvcywgZXh0ZW5zaW9uTGVuZ3RoKTtcbiAgICB9IGVsc2UgaWYgKFxuICAgICAgZXh0ZW5zaW9uSWQgPT09IFF1YW50aXplZE1lc2hFeHRlbnNpb25JZHMuTUVUQURBVEEgJiZcbiAgICAgIHByb3ZpZGVyLl9yZXF1ZXN0TWV0YWRhdGFcbiAgICApIHtcbiAgICAgIHZhciBzdHJpbmdMZW5ndGggPSB2aWV3LmdldFVpbnQzMihwb3MsIHRydWUpO1xuICAgICAgaWYgKHN0cmluZ0xlbmd0aCA+IDApIHtcbiAgICAgICAgdmFyIG1ldGFkYXRhID0gZ2V0SnNvbkZyb21UeXBlZEFycmF5KFxuICAgICAgICAgIG5ldyBVaW50OEFycmF5KGJ1ZmZlciksXG4gICAgICAgICAgcG9zICsgVWludDMyQXJyYXkuQllURVNfUEVSX0VMRU1FTlQsXG4gICAgICAgICAgc3RyaW5nTGVuZ3RoXG4gICAgICAgICk7XG4gICAgICAgIHZhciBhdmFpbGFibGVUaWxlcyA9IG1ldGFkYXRhLmF2YWlsYWJsZTtcbiAgICAgICAgaWYgKGRlZmluZWQoYXZhaWxhYmxlVGlsZXMpKSB7XG4gICAgICAgICAgZm9yICh2YXIgb2Zmc2V0ID0gMDsgb2Zmc2V0IDwgYXZhaWxhYmxlVGlsZXMubGVuZ3RoOyArK29mZnNldCkge1xuICAgICAgICAgICAgdmFyIGF2YWlsYWJsZUxldmVsID0gbGV2ZWwgKyBvZmZzZXQgKyAxO1xuICAgICAgICAgICAgdmFyIHJhbmdlc0F0TGV2ZWwgPSBhdmFpbGFibGVUaWxlc1tvZmZzZXRdO1xuICAgICAgICAgICAgdmFyIHlUaWxlcyA9IHByb3ZpZGVyLl90aWxpbmdTY2hlbWUuZ2V0TnVtYmVyT2ZZVGlsZXNBdExldmVsKFxuICAgICAgICAgICAgICBhdmFpbGFibGVMZXZlbFxuICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgZm9yIChcbiAgICAgICAgICAgICAgdmFyIHJhbmdlSW5kZXggPSAwO1xuICAgICAgICAgICAgICByYW5nZUluZGV4IDwgcmFuZ2VzQXRMZXZlbC5sZW5ndGg7XG4gICAgICAgICAgICAgICsrcmFuZ2VJbmRleFxuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgIHZhciByYW5nZSA9IHJhbmdlc0F0TGV2ZWxbcmFuZ2VJbmRleF07XG4gICAgICAgICAgICAgIHZhciB5U3RhcnQgPSB5VGlsZXMgLSByYW5nZS5lbmRZIC0gMTtcbiAgICAgICAgICAgICAgdmFyIHlFbmQgPSB5VGlsZXMgLSByYW5nZS5zdGFydFkgLSAxO1xuICAgICAgICAgICAgICBwcm92aWRlci5hdmFpbGFiaWxpdHkuYWRkQXZhaWxhYmxlVGlsZVJhbmdlKFxuICAgICAgICAgICAgICAgIGF2YWlsYWJsZUxldmVsLFxuICAgICAgICAgICAgICAgIHJhbmdlLnN0YXJ0WCxcbiAgICAgICAgICAgICAgICB5U3RhcnQsXG4gICAgICAgICAgICAgICAgcmFuZ2UuZW5kWCxcbiAgICAgICAgICAgICAgICB5RW5kXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgIGxheWVyLmF2YWlsYWJpbGl0eS5hZGRBdmFpbGFibGVUaWxlUmFuZ2UoXG4gICAgICAgICAgICAgICAgYXZhaWxhYmxlTGV2ZWwsXG4gICAgICAgICAgICAgICAgcmFuZ2Uuc3RhcnRYLFxuICAgICAgICAgICAgICAgIHlTdGFydCxcbiAgICAgICAgICAgICAgICByYW5nZS5lbmRYLFxuICAgICAgICAgICAgICAgIHlFbmRcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGxheWVyLmF2YWlsYWJpbGl0eVRpbGVzTG9hZGVkLmFkZEF2YWlsYWJsZVRpbGVSYW5nZShsZXZlbCwgeCwgeSwgeCwgeSk7XG4gICAgfVxuICAgIHBvcyArPSBleHRlbnNpb25MZW5ndGg7XG4gIH1cblxuICB2YXIgc2tpcnRIZWlnaHQgPSBwcm92aWRlci5nZXRMZXZlbE1heGltdW1HZW9tZXRyaWNFcnJvcihsZXZlbCkgKiA1LjA7XG5cbiAgLy8gVGhlIHNraXJ0IGlzIG5vdCBpbmNsdWRlZCBpbiB0aGUgT0JCIGNvbXB1dGF0aW9uLiBJZiB0aGlzIGV2ZXJcbiAgLy8gY2F1c2VzIGFueSByZW5kZXJpbmcgYXJ0aWZhY3RzIChjcmFja3MpLCB0aGV5IGFyZSBleHBlY3RlZCB0byBiZVxuICAvLyBtaW5vciBhbmQgaW4gdGhlIGNvcm5lcnMgb2YgdGhlIHNjcmVlbi4gSXQncyBwb3NzaWJsZSB0aGF0IHRoaXNcbiAgLy8gbWlnaHQgbmVlZCB0byBiZSBjaGFuZ2VkIC0ganVzdCBjaGFuZ2UgdG8gYG1pbmltdW1IZWlnaHQgLSBza2lydEhlaWdodGBcbiAgLy8gQSBzaW1pbGFyIGNoYW5nZSBtaWdodCBhbHNvIGJlIG5lZWRlZCBpbiBgdXBzYW1wbGVRdWFudGl6ZWRUZXJyYWluTWVzaC5qc2AuXG4gIHZhciByZWN0YW5nbGUgPSBwcm92aWRlci5fdGlsaW5nU2NoZW1lLnRpbGVYWVRvUmVjdGFuZ2xlKHgsIHksIGxldmVsKTtcbiAgdmFyIG9yaWVudGVkQm91bmRpbmdCb3ggPSBPcmllbnRlZEJvdW5kaW5nQm94LmZyb21SZWN0YW5nbGUoXG4gICAgcmVjdGFuZ2xlLFxuICAgIG1pbmltdW1IZWlnaHQsXG4gICAgbWF4aW11bUhlaWdodCxcbiAgICBwcm92aWRlci5fdGlsaW5nU2NoZW1lLmVsbGlwc29pZFxuICApO1xuXG4gIHJldHVybiBuZXcgUXVhbnRpemVkTWVzaFRlcnJhaW5EYXRhKHtcbiAgICBjZW50ZXI6IGNlbnRlcixcbiAgICBtaW5pbXVtSGVpZ2h0OiBtaW5pbXVtSGVpZ2h0LFxuICAgIG1heGltdW1IZWlnaHQ6IG1heGltdW1IZWlnaHQsXG4gICAgYm91bmRpbmdTcGhlcmU6IGJvdW5kaW5nU3BoZXJlLFxuICAgIG9yaWVudGVkQm91bmRpbmdCb3g6IG9yaWVudGVkQm91bmRpbmdCb3gsXG4gICAgaG9yaXpvbk9jY2x1c2lvblBvaW50OiBob3Jpem9uT2NjbHVzaW9uUG9pbnQsXG4gICAgcXVhbnRpemVkVmVydGljZXM6IGVuY29kZWRWZXJ0ZXhCdWZmZXIsXG4gICAgZW5jb2RlZE5vcm1hbHM6IGVuY29kZWROb3JtYWxCdWZmZXIsXG4gICAgaW5kaWNlczogaW5kaWNlcyxcbiAgICB3ZXN0SW5kaWNlczogd2VzdEluZGljZXMsXG4gICAgc291dGhJbmRpY2VzOiBzb3V0aEluZGljZXMsXG4gICAgZWFzdEluZGljZXM6IGVhc3RJbmRpY2VzLFxuICAgIG5vcnRoSW5kaWNlczogbm9ydGhJbmRpY2VzLFxuICAgIHdlc3RTa2lydEhlaWdodDogc2tpcnRIZWlnaHQsXG4gICAgc291dGhTa2lydEhlaWdodDogc2tpcnRIZWlnaHQsXG4gICAgZWFzdFNraXJ0SGVpZ2h0OiBza2lydEhlaWdodCxcbiAgICBub3J0aFNraXJ0SGVpZ2h0OiBza2lydEhlaWdodCxcbiAgICBjaGlsZFRpbGVNYXNrOiBwcm92aWRlci5hdmFpbGFiaWxpdHkuY29tcHV0ZUNoaWxkTWFza0ZvclRpbGUobGV2ZWwsIHgsIHkpLFxuICAgIHdhdGVyTWFzazogd2F0ZXJNYXNrQnVmZmVyLFxuICAgIGNyZWRpdHM6IHByb3ZpZGVyLl90aWxlQ3JlZGl0cyxcbiAgfSk7XG59XG5cbi8qKlxuICogUmVxdWVzdHMgdGhlIGdlb21ldHJ5IGZvciBhIGdpdmVuIHRpbGUuICBUaGlzIGZ1bmN0aW9uIHNob3VsZCBub3QgYmUgY2FsbGVkIGJlZm9yZVxuICoge0BsaW5rIENlc2l1bVRlcnJhaW5Qcm92aWRlciNyZWFkeX0gcmV0dXJucyB0cnVlLiAgVGhlIHJlc3VsdCBtdXN0IGluY2x1ZGUgdGVycmFpbiBkYXRhIGFuZFxuICogbWF5IG9wdGlvbmFsbHkgaW5jbHVkZSBhIHdhdGVyIG1hc2sgYW5kIGFuIGluZGljYXRpb24gb2Ygd2hpY2ggY2hpbGQgdGlsZXMgYXJlIGF2YWlsYWJsZS5cbiAqXG4gKiBAcGFyYW0ge051bWJlcn0geCBUaGUgWCBjb29yZGluYXRlIG9mIHRoZSB0aWxlIGZvciB3aGljaCB0byByZXF1ZXN0IGdlb21ldHJ5LlxuICogQHBhcmFtIHtOdW1iZXJ9IHkgVGhlIFkgY29vcmRpbmF0ZSBvZiB0aGUgdGlsZSBmb3Igd2hpY2ggdG8gcmVxdWVzdCBnZW9tZXRyeS5cbiAqIEBwYXJhbSB7TnVtYmVyfSBsZXZlbCBUaGUgbGV2ZWwgb2YgdGhlIHRpbGUgZm9yIHdoaWNoIHRvIHJlcXVlc3QgZ2VvbWV0cnkuXG4gKiBAcGFyYW0ge1JlcXVlc3R9IFtyZXF1ZXN0XSBUaGUgcmVxdWVzdCBvYmplY3QuIEludGVuZGVkIGZvciBpbnRlcm5hbCB1c2Ugb25seS5cbiAqXG4gKiBAcmV0dXJucyB7UHJvbWlzZS48VGVycmFpbkRhdGE+fHVuZGVmaW5lZH0gQSBwcm9taXNlIGZvciB0aGUgcmVxdWVzdGVkIGdlb21ldHJ5LiAgSWYgdGhpcyBtZXRob2RcbiAqICAgICAgICAgIHJldHVybnMgdW5kZWZpbmVkIGluc3RlYWQgb2YgYSBwcm9taXNlLCBpdCBpcyBhbiBpbmRpY2F0aW9uIHRoYXQgdG9vIG1hbnkgcmVxdWVzdHMgYXJlIGFscmVhZHlcbiAqICAgICAgICAgIHBlbmRpbmcgYW5kIHRoZSByZXF1ZXN0IHdpbGwgYmUgcmV0cmllZCBsYXRlci5cbiAqXG4gKiBAZXhjZXB0aW9uIHtEZXZlbG9wZXJFcnJvcn0gVGhpcyBmdW5jdGlvbiBtdXN0IG5vdCBiZSBjYWxsZWQgYmVmb3JlIHtAbGluayBDZXNpdW1UZXJyYWluUHJvdmlkZXIjcmVhZHl9XG4gKiAgICAgICAgICAgIHJldHVybnMgdHJ1ZS5cbiAqL1xuQ2VzaXVtVGVycmFpblByb3ZpZGVyLnByb3RvdHlwZS5yZXF1ZXN0VGlsZUdlb21ldHJ5ID0gZnVuY3Rpb24gKFxuICB4LFxuICB5LFxuICBsZXZlbCxcbiAgcmVxdWVzdFxuKSB7XG4gIC8vPj5pbmNsdWRlU3RhcnQoJ2RlYnVnJywgcHJhZ21hcy5kZWJ1ZylcbiAgaWYgKCF0aGlzLl9yZWFkeSkge1xuICAgIHRocm93IG5ldyBEZXZlbG9wZXJFcnJvcihcbiAgICAgIFwicmVxdWVzdFRpbGVHZW9tZXRyeSBtdXN0IG5vdCBiZSBjYWxsZWQgYmVmb3JlIHRoZSB0ZXJyYWluIHByb3ZpZGVyIGlzIHJlYWR5LlwiXG4gICAgKTtcbiAgfVxuICAvLz4+aW5jbHVkZUVuZCgnZGVidWcnKTtcblxuICB2YXIgbGF5ZXJzID0gdGhpcy5fbGF5ZXJzO1xuICB2YXIgbGF5ZXJUb1VzZTtcbiAgdmFyIGxheWVyQ291bnQgPSBsYXllcnMubGVuZ3RoO1xuXG4gIGlmIChsYXllckNvdW50ID09PSAxKSB7XG4gICAgLy8gT3B0aW1pemVkIHBhdGggZm9yIHNpbmdsZSBsYXllcnNcbiAgICBsYXllclRvVXNlID0gbGF5ZXJzWzBdO1xuICB9IGVsc2Uge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGF5ZXJDb3VudDsgKytpKSB7XG4gICAgICB2YXIgbGF5ZXIgPSBsYXllcnNbaV07XG4gICAgICBpZiAoXG4gICAgICAgICFkZWZpbmVkKGxheWVyLmF2YWlsYWJpbGl0eSkgfHxcbiAgICAgICAgbGF5ZXIuYXZhaWxhYmlsaXR5LmlzVGlsZUF2YWlsYWJsZShsZXZlbCwgeCwgeSlcbiAgICAgICkge1xuICAgICAgICBsYXllclRvVXNlID0gbGF5ZXI7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiByZXF1ZXN0VGlsZUdlb21ldHJ5KHRoaXMsIHgsIHksIGxldmVsLCBsYXllclRvVXNlLCByZXF1ZXN0KTtcbn07XG5cbmZ1bmN0aW9uIHJlcXVlc3RUaWxlR2VvbWV0cnkocHJvdmlkZXIsIHgsIHksIGxldmVsLCBsYXllclRvVXNlLCByZXF1ZXN0KSB7XG4gIGlmICghZGVmaW5lZChsYXllclRvVXNlKSkge1xuICAgIHJldHVybiB3aGVuLnJlamVjdChuZXcgUnVudGltZUVycm9yKFwiVGVycmFpbiB0aWxlIGRvZXNuJ3QgZXhpc3RcIikpO1xuICB9XG5cbiAgdmFyIHVybFRlbXBsYXRlcyA9IGxheWVyVG9Vc2UudGlsZVVybFRlbXBsYXRlcztcbiAgaWYgKHVybFRlbXBsYXRlcy5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG5cbiAgLy8gVGhlIFRpbGVNYXBTZXJ2aWNlIHNjaGVtZSBjb3VudHMgZnJvbSB0aGUgYm90dG9tIGxlZnRcbiAgdmFyIHRlcnJhaW5ZO1xuICBpZiAoIXByb3ZpZGVyLl9zY2hlbWUgfHwgcHJvdmlkZXIuX3NjaGVtZSA9PT0gXCJ0bXNcIikge1xuICAgIHZhciB5VGlsZXMgPSBwcm92aWRlci5fdGlsaW5nU2NoZW1lLmdldE51bWJlck9mWVRpbGVzQXRMZXZlbChsZXZlbCk7XG4gICAgdGVycmFpblkgPSB5VGlsZXMgLSB5IC0gMTtcbiAgfSBlbHNlIHtcbiAgICB0ZXJyYWluWSA9IHk7XG4gIH1cblxuICB2YXIgZXh0ZW5zaW9uTGlzdCA9IFtdO1xuICBpZiAocHJvdmlkZXIuX3JlcXVlc3RWZXJ0ZXhOb3JtYWxzICYmIGxheWVyVG9Vc2UuaGFzVmVydGV4Tm9ybWFscykge1xuICAgIGV4dGVuc2lvbkxpc3QucHVzaChcbiAgICAgIGxheWVyVG9Vc2UubGl0dGxlRW5kaWFuRXh0ZW5zaW9uU2l6ZVxuICAgICAgICA/IFwib2N0dmVydGV4bm9ybWFsc1wiXG4gICAgICAgIDogXCJ2ZXJ0ZXhub3JtYWxzXCJcbiAgICApO1xuICB9XG4gIGlmIChwcm92aWRlci5fcmVxdWVzdFdhdGVyTWFzayAmJiBsYXllclRvVXNlLmhhc1dhdGVyTWFzaykge1xuICAgIGV4dGVuc2lvbkxpc3QucHVzaChcIndhdGVybWFza1wiKTtcbiAgfVxuICBpZiAocHJvdmlkZXIuX3JlcXVlc3RNZXRhZGF0YSAmJiBsYXllclRvVXNlLmhhc01ldGFkYXRhKSB7XG4gICAgZXh0ZW5zaW9uTGlzdC5wdXNoKFwibWV0YWRhdGFcIik7XG4gIH1cblxuICB2YXIgaGVhZGVycztcbiAgdmFyIHF1ZXJ5O1xuICB2YXIgdXJsID0gdXJsVGVtcGxhdGVzWyh4ICsgdGVycmFpblkgKyBsZXZlbCkgJSB1cmxUZW1wbGF0ZXMubGVuZ3RoXTtcblxuICB2YXIgcmVzb3VyY2UgPSBsYXllclRvVXNlLnJlc291cmNlO1xuICBpZiAoXG4gICAgZGVmaW5lZChyZXNvdXJjZS5faW9uRW5kcG9pbnQpICYmXG4gICAgIWRlZmluZWQocmVzb3VyY2UuX2lvbkVuZHBvaW50LmV4dGVybmFsVHlwZSlcbiAgKSB7XG4gICAgLy8gaW9uIHVzZXMgcXVlcnkgcGFyZW1ldGVycyB0byByZXF1ZXN0IGV4dGVuc2lvbnNcbiAgICBpZiAoZXh0ZW5zaW9uTGlzdC5sZW5ndGggIT09IDApIHtcbiAgICAgIHF1ZXJ5ID0geyBleHRlbnNpb25zOiBleHRlbnNpb25MaXN0LmpvaW4oXCItXCIpIH07XG4gICAgfVxuICAgIGhlYWRlcnMgPSBnZXRSZXF1ZXN0SGVhZGVyKHVuZGVmaW5lZCk7XG4gIH0gZWxzZSB7XG4gICAgLy9BbGwgb3RoZXIgdGVycmFpbiBzZXJ2ZXJzXG4gICAgaGVhZGVycyA9IGdldFJlcXVlc3RIZWFkZXIoZXh0ZW5zaW9uTGlzdCk7XG4gIH1cblxuICB2YXIgcHJvbWlzZSA9IHJlc291cmNlXG4gICAgLmdldERlcml2ZWRSZXNvdXJjZSh7XG4gICAgICB1cmw6IHVybCxcbiAgICAgIHRlbXBsYXRlVmFsdWVzOiB7XG4gICAgICAgIHZlcnNpb246IGxheWVyVG9Vc2UudmVyc2lvbixcbiAgICAgICAgejogbGV2ZWwsXG4gICAgICAgIHg6IHgsXG4gICAgICAgIHk6IHRlcnJhaW5ZLFxuICAgICAgfSxcbiAgICAgIHF1ZXJ5UGFyYW1ldGVyczogcXVlcnksXG4gICAgICBoZWFkZXJzOiBoZWFkZXJzLFxuICAgICAgcmVxdWVzdDogcmVxdWVzdCxcbiAgICB9KVxuICAgIC5mZXRjaEFycmF5QnVmZmVyKCk7XG5cbiAgaWYgKCFkZWZpbmVkKHByb21pc2UpKSB7XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxuXG4gIHJldHVybiBwcm9taXNlLnRoZW4oZnVuY3Rpb24gKGJ1ZmZlcikge1xuICAgIGlmIChkZWZpbmVkKHByb3ZpZGVyLl9oZWlnaHRtYXBTdHJ1Y3R1cmUpKSB7XG4gICAgICByZXR1cm4gY3JlYXRlSGVpZ2h0bWFwVGVycmFpbkRhdGEocHJvdmlkZXIsIGJ1ZmZlciwgbGV2ZWwsIHgsIHkpO1xuICAgIH1cbiAgICByZXR1cm4gY3JlYXRlUXVhbnRpemVkTWVzaFRlcnJhaW5EYXRhKFxuICAgICAgcHJvdmlkZXIsXG4gICAgICBidWZmZXIsXG4gICAgICBsZXZlbCxcbiAgICAgIHgsXG4gICAgICB5LFxuICAgICAgbGF5ZXJUb1VzZVxuICAgICk7XG4gIH0pO1xufVxuXG5PYmplY3QuZGVmaW5lUHJvcGVydGllcyhDZXNpdW1UZXJyYWluUHJvdmlkZXIucHJvdG90eXBlLCB7XG4gIC8qKlxuICAgKiBHZXRzIGFuIGV2ZW50IHRoYXQgaXMgcmFpc2VkIHdoZW4gdGhlIHRlcnJhaW4gcHJvdmlkZXIgZW5jb3VudGVycyBhbiBhc3luY2hyb25vdXMgZXJyb3IuICBCeSBzdWJzY3JpYmluZ1xuICAgKiB0byB0aGUgZXZlbnQsIHlvdSB3aWxsIGJlIG5vdGlmaWVkIG9mIHRoZSBlcnJvciBhbmQgY2FuIHBvdGVudGlhbGx5IHJlY292ZXIgZnJvbSBpdC4gIEV2ZW50IGxpc3RlbmVyc1xuICAgKiBhcmUgcGFzc2VkIGFuIGluc3RhbmNlIG9mIHtAbGluayBUaWxlUHJvdmlkZXJFcnJvcn0uXG4gICAqIEBtZW1iZXJvZiBDZXNpdW1UZXJyYWluUHJvdmlkZXIucHJvdG90eXBlXG4gICAqIEB0eXBlIHtFdmVudH1cbiAgICogQHJlYWRvbmx5XG4gICAqL1xuICBlcnJvckV2ZW50OiB7XG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fZXJyb3JFdmVudDtcbiAgICB9LFxuICB9LFxuXG4gIC8qKlxuICAgKiBHZXRzIHRoZSBjcmVkaXQgdG8gZGlzcGxheSB3aGVuIHRoaXMgdGVycmFpbiBwcm92aWRlciBpcyBhY3RpdmUuICBUeXBpY2FsbHkgdGhpcyBpcyB1c2VkIHRvIGNyZWRpdFxuICAgKiB0aGUgc291cmNlIG9mIHRoZSB0ZXJyYWluLiAgVGhpcyBmdW5jdGlvbiBzaG91bGQgbm90IGJlIGNhbGxlZCBiZWZvcmUge0BsaW5rIENlc2l1bVRlcnJhaW5Qcm92aWRlciNyZWFkeX0gcmV0dXJucyB0cnVlLlxuICAgKiBAbWVtYmVyb2YgQ2VzaXVtVGVycmFpblByb3ZpZGVyLnByb3RvdHlwZVxuICAgKiBAdHlwZSB7Q3JlZGl0fVxuICAgKiBAcmVhZG9ubHlcbiAgICovXG4gIGNyZWRpdDoge1xuICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgLy8+PmluY2x1ZGVTdGFydCgnZGVidWcnLCBwcmFnbWFzLmRlYnVnKVxuICAgICAgaWYgKCF0aGlzLl9yZWFkeSkge1xuICAgICAgICB0aHJvdyBuZXcgRGV2ZWxvcGVyRXJyb3IoXG4gICAgICAgICAgXCJjcmVkaXQgbXVzdCBub3QgYmUgY2FsbGVkIGJlZm9yZSB0aGUgdGVycmFpbiBwcm92aWRlciBpcyByZWFkeS5cIlxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgLy8+PmluY2x1ZGVFbmQoJ2RlYnVnJyk7XG5cbiAgICAgIHJldHVybiB0aGlzLl9jcmVkaXQ7XG4gICAgfSxcbiAgfSxcblxuICAvKipcbiAgICogR2V0cyB0aGUgdGlsaW5nIHNjaGVtZSB1c2VkIGJ5IHRoaXMgcHJvdmlkZXIuICBUaGlzIGZ1bmN0aW9uIHNob3VsZFxuICAgKiBub3QgYmUgY2FsbGVkIGJlZm9yZSB7QGxpbmsgQ2VzaXVtVGVycmFpblByb3ZpZGVyI3JlYWR5fSByZXR1cm5zIHRydWUuXG4gICAqIEBtZW1iZXJvZiBDZXNpdW1UZXJyYWluUHJvdmlkZXIucHJvdG90eXBlXG4gICAqIEB0eXBlIHtHZW9ncmFwaGljVGlsaW5nU2NoZW1lfVxuICAgKiBAcmVhZG9ubHlcbiAgICovXG4gIHRpbGluZ1NjaGVtZToge1xuICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgLy8+PmluY2x1ZGVTdGFydCgnZGVidWcnLCBwcmFnbWFzLmRlYnVnKVxuICAgICAgaWYgKCF0aGlzLl9yZWFkeSkge1xuICAgICAgICB0aHJvdyBuZXcgRGV2ZWxvcGVyRXJyb3IoXG4gICAgICAgICAgXCJ0aWxpbmdTY2hlbWUgbXVzdCBub3QgYmUgY2FsbGVkIGJlZm9yZSB0aGUgdGVycmFpbiBwcm92aWRlciBpcyByZWFkeS5cIlxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgLy8+PmluY2x1ZGVFbmQoJ2RlYnVnJyk7XG5cbiAgICAgIHJldHVybiB0aGlzLl90aWxpbmdTY2hlbWU7XG4gICAgfSxcbiAgfSxcblxuICAvKipcbiAgICogR2V0cyBhIHZhbHVlIGluZGljYXRpbmcgd2hldGhlciBvciBub3QgdGhlIHByb3ZpZGVyIGlzIHJlYWR5IGZvciB1c2UuXG4gICAqIEBtZW1iZXJvZiBDZXNpdW1UZXJyYWluUHJvdmlkZXIucHJvdG90eXBlXG4gICAqIEB0eXBlIHtCb29sZWFufVxuICAgKiBAcmVhZG9ubHlcbiAgICovXG4gIHJlYWR5OiB7XG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fcmVhZHk7XG4gICAgfSxcbiAgfSxcblxuICAvKipcbiAgICogR2V0cyBhIHByb21pc2UgdGhhdCByZXNvbHZlcyB0byB0cnVlIHdoZW4gdGhlIHByb3ZpZGVyIGlzIHJlYWR5IGZvciB1c2UuXG4gICAqIEBtZW1iZXJvZiBDZXNpdW1UZXJyYWluUHJvdmlkZXIucHJvdG90eXBlXG4gICAqIEB0eXBlIHtQcm9taXNlLjxCb29sZWFuPn1cbiAgICogQHJlYWRvbmx5XG4gICAqL1xuICByZWFkeVByb21pc2U6IHtcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9yZWFkeVByb21pc2UucHJvbWlzZTtcbiAgICB9LFxuICB9LFxuXG4gIC8qKlxuICAgKiBHZXRzIGEgdmFsdWUgaW5kaWNhdGluZyB3aGV0aGVyIG9yIG5vdCB0aGUgcHJvdmlkZXIgaW5jbHVkZXMgYSB3YXRlciBtYXNrLiAgVGhlIHdhdGVyIG1hc2tcbiAgICogaW5kaWNhdGVzIHdoaWNoIGFyZWFzIG9mIHRoZSBnbG9iZSBhcmUgd2F0ZXIgcmF0aGVyIHRoYW4gbGFuZCwgc28gdGhleSBjYW4gYmUgcmVuZGVyZWRcbiAgICogYXMgYSByZWZsZWN0aXZlIHN1cmZhY2Ugd2l0aCBhbmltYXRlZCB3YXZlcy4gIFRoaXMgZnVuY3Rpb24gc2hvdWxkIG5vdCBiZVxuICAgKiBjYWxsZWQgYmVmb3JlIHtAbGluayBDZXNpdW1UZXJyYWluUHJvdmlkZXIjcmVhZHl9IHJldHVybnMgdHJ1ZS5cbiAgICogQG1lbWJlcm9mIENlc2l1bVRlcnJhaW5Qcm92aWRlci5wcm90b3R5cGVcbiAgICogQHR5cGUge0Jvb2xlYW59XG4gICAqIEByZWFkb25seVxuICAgKiBAZXhjZXB0aW9uIHtEZXZlbG9wZXJFcnJvcn0gVGhpcyBwcm9wZXJ0eSBtdXN0IG5vdCBiZSBjYWxsZWQgYmVmb3JlIHtAbGluayBDZXNpdW1UZXJyYWluUHJvdmlkZXIjcmVhZHl9XG4gICAqL1xuICBoYXNXYXRlck1hc2s6IHtcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIC8vPj5pbmNsdWRlU3RhcnQoJ2RlYnVnJywgcHJhZ21hcy5kZWJ1ZylcbiAgICAgIGlmICghdGhpcy5fcmVhZHkpIHtcbiAgICAgICAgdGhyb3cgbmV3IERldmVsb3BlckVycm9yKFxuICAgICAgICAgIFwiaGFzV2F0ZXJNYXNrIG11c3Qgbm90IGJlIGNhbGxlZCBiZWZvcmUgdGhlIHRlcnJhaW4gcHJvdmlkZXIgaXMgcmVhZHkuXCJcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIC8vPj5pbmNsdWRlRW5kKCdkZWJ1ZycpO1xuXG4gICAgICByZXR1cm4gdGhpcy5faGFzV2F0ZXJNYXNrICYmIHRoaXMuX3JlcXVlc3RXYXRlck1hc2s7XG4gICAgfSxcbiAgfSxcblxuICAvKipcbiAgICogR2V0cyBhIHZhbHVlIGluZGljYXRpbmcgd2hldGhlciBvciBub3QgdGhlIHJlcXVlc3RlZCB0aWxlcyBpbmNsdWRlIHZlcnRleCBub3JtYWxzLlxuICAgKiBUaGlzIGZ1bmN0aW9uIHNob3VsZCBub3QgYmUgY2FsbGVkIGJlZm9yZSB7QGxpbmsgQ2VzaXVtVGVycmFpblByb3ZpZGVyI3JlYWR5fSByZXR1cm5zIHRydWUuXG4gICAqIEBtZW1iZXJvZiBDZXNpdW1UZXJyYWluUHJvdmlkZXIucHJvdG90eXBlXG4gICAqIEB0eXBlIHtCb29sZWFufVxuICAgKiBAcmVhZG9ubHlcbiAgICogQGV4Y2VwdGlvbiB7RGV2ZWxvcGVyRXJyb3J9IFRoaXMgcHJvcGVydHkgbXVzdCBub3QgYmUgY2FsbGVkIGJlZm9yZSB7QGxpbmsgQ2VzaXVtVGVycmFpblByb3ZpZGVyI3JlYWR5fVxuICAgKi9cbiAgaGFzVmVydGV4Tm9ybWFsczoge1xuICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgLy8+PmluY2x1ZGVTdGFydCgnZGVidWcnLCBwcmFnbWFzLmRlYnVnKVxuICAgICAgaWYgKCF0aGlzLl9yZWFkeSkge1xuICAgICAgICB0aHJvdyBuZXcgRGV2ZWxvcGVyRXJyb3IoXG4gICAgICAgICAgXCJoYXNWZXJ0ZXhOb3JtYWxzIG11c3Qgbm90IGJlIGNhbGxlZCBiZWZvcmUgdGhlIHRlcnJhaW4gcHJvdmlkZXIgaXMgcmVhZHkuXCJcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIC8vPj5pbmNsdWRlRW5kKCdkZWJ1ZycpO1xuXG4gICAgICAvLyByZXR1cm5zIHRydWUgaWYgd2UgY2FuIHJlcXVlc3QgdmVydGV4IG5vcm1hbHMgZnJvbSB0aGUgc2VydmVyXG4gICAgICByZXR1cm4gdGhpcy5faGFzVmVydGV4Tm9ybWFscyAmJiB0aGlzLl9yZXF1ZXN0VmVydGV4Tm9ybWFscztcbiAgICB9LFxuICB9LFxuXG4gIC8qKlxuICAgKiBHZXRzIGEgdmFsdWUgaW5kaWNhdGluZyB3aGV0aGVyIG9yIG5vdCB0aGUgcmVxdWVzdGVkIHRpbGVzIGluY2x1ZGUgbWV0YWRhdGEuXG4gICAqIFRoaXMgZnVuY3Rpb24gc2hvdWxkIG5vdCBiZSBjYWxsZWQgYmVmb3JlIHtAbGluayBDZXNpdW1UZXJyYWluUHJvdmlkZXIjcmVhZHl9IHJldHVybnMgdHJ1ZS5cbiAgICogQG1lbWJlcm9mIENlc2l1bVRlcnJhaW5Qcm92aWRlci5wcm90b3R5cGVcbiAgICogQHR5cGUge0Jvb2xlYW59XG4gICAqIEByZWFkb25seVxuICAgKiBAZXhjZXB0aW9uIHtEZXZlbG9wZXJFcnJvcn0gVGhpcyBwcm9wZXJ0eSBtdXN0IG5vdCBiZSBjYWxsZWQgYmVmb3JlIHtAbGluayBDZXNpdW1UZXJyYWluUHJvdmlkZXIjcmVhZHl9XG4gICAqL1xuICBoYXNNZXRhZGF0YToge1xuICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgLy8+PmluY2x1ZGVTdGFydCgnZGVidWcnLCBwcmFnbWFzLmRlYnVnKVxuICAgICAgaWYgKCF0aGlzLl9yZWFkeSkge1xuICAgICAgICB0aHJvdyBuZXcgRGV2ZWxvcGVyRXJyb3IoXG4gICAgICAgICAgXCJoYXNNZXRhZGF0YSBtdXN0IG5vdCBiZSBjYWxsZWQgYmVmb3JlIHRoZSB0ZXJyYWluIHByb3ZpZGVyIGlzIHJlYWR5LlwiXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICAvLz4+aW5jbHVkZUVuZCgnZGVidWcnKTtcblxuICAgICAgLy8gcmV0dXJucyB0cnVlIGlmIHdlIGNhbiByZXF1ZXN0IG1ldGFkYXRhIGZyb20gdGhlIHNlcnZlclxuICAgICAgcmV0dXJuIHRoaXMuX2hhc01ldGFkYXRhICYmIHRoaXMuX3JlcXVlc3RNZXRhZGF0YTtcbiAgICB9LFxuICB9LFxuXG4gIC8qKlxuICAgKiBCb29sZWFuIGZsYWcgdGhhdCBpbmRpY2F0ZXMgaWYgdGhlIGNsaWVudCBzaG91bGQgcmVxdWVzdCB2ZXJ0ZXggbm9ybWFscyBmcm9tIHRoZSBzZXJ2ZXIuXG4gICAqIFZlcnRleCBub3JtYWxzIGRhdGEgaXMgYXBwZW5kZWQgdG8gdGhlIHN0YW5kYXJkIHRpbGUgbWVzaCBkYXRhIG9ubHkgaWYgdGhlIGNsaWVudCByZXF1ZXN0cyB0aGUgdmVydGV4IG5vcm1hbHMgYW5kXG4gICAqIGlmIHRoZSBzZXJ2ZXIgcHJvdmlkZXMgdmVydGV4IG5vcm1hbHMuXG4gICAqIEBtZW1iZXJvZiBDZXNpdW1UZXJyYWluUHJvdmlkZXIucHJvdG90eXBlXG4gICAqIEB0eXBlIHtCb29sZWFufVxuICAgKiBAcmVhZG9ubHlcbiAgICovXG4gIHJlcXVlc3RWZXJ0ZXhOb3JtYWxzOiB7XG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fcmVxdWVzdFZlcnRleE5vcm1hbHM7XG4gICAgfSxcbiAgfSxcblxuICAvKipcbiAgICogQm9vbGVhbiBmbGFnIHRoYXQgaW5kaWNhdGVzIGlmIHRoZSBjbGllbnQgc2hvdWxkIHJlcXVlc3QgYSB3YXRlcm1hc2sgZnJvbSB0aGUgc2VydmVyLlxuICAgKiBXYXRlcm1hc2sgZGF0YSBpcyBhcHBlbmRlZCB0byB0aGUgc3RhbmRhcmQgdGlsZSBtZXNoIGRhdGEgb25seSBpZiB0aGUgY2xpZW50IHJlcXVlc3RzIHRoZSB3YXRlcm1hc2sgYW5kXG4gICAqIGlmIHRoZSBzZXJ2ZXIgcHJvdmlkZXMgYSB3YXRlcm1hc2suXG4gICAqIEBtZW1iZXJvZiBDZXNpdW1UZXJyYWluUHJvdmlkZXIucHJvdG90eXBlXG4gICAqIEB0eXBlIHtCb29sZWFufVxuICAgKiBAcmVhZG9ubHlcbiAgICovXG4gIHJlcXVlc3RXYXRlck1hc2s6IHtcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9yZXF1ZXN0V2F0ZXJNYXNrO1xuICAgIH0sXG4gIH0sXG5cbiAgLyoqXG4gICAqIEJvb2xlYW4gZmxhZyB0aGF0IGluZGljYXRlcyBpZiB0aGUgY2xpZW50IHNob3VsZCByZXF1ZXN0IG1ldGFkYXRhIGZyb20gdGhlIHNlcnZlci5cbiAgICogTWV0YWRhdGEgaXMgYXBwZW5kZWQgdG8gdGhlIHN0YW5kYXJkIHRpbGUgbWVzaCBkYXRhIG9ubHkgaWYgdGhlIGNsaWVudCByZXF1ZXN0cyB0aGUgbWV0YWRhdGEgYW5kXG4gICAqIGlmIHRoZSBzZXJ2ZXIgcHJvdmlkZXMgYSBtZXRhZGF0YS5cbiAgICogQG1lbWJlcm9mIENlc2l1bVRlcnJhaW5Qcm92aWRlci5wcm90b3R5cGVcbiAgICogQHR5cGUge0Jvb2xlYW59XG4gICAqIEByZWFkb25seVxuICAgKi9cbiAgcmVxdWVzdE1ldGFkYXRhOiB7XG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fcmVxdWVzdE1ldGFkYXRhO1xuICAgIH0sXG4gIH0sXG5cbiAgLyoqXG4gICAqIEdldHMgYW4gb2JqZWN0IHRoYXQgY2FuIGJlIHVzZWQgdG8gZGV0ZXJtaW5lIGF2YWlsYWJpbGl0eSBvZiB0ZXJyYWluIGZyb20gdGhpcyBwcm92aWRlciwgc3VjaCBhc1xuICAgKiBhdCBwb2ludHMgYW5kIGluIHJlY3RhbmdsZXMuICBUaGlzIGZ1bmN0aW9uIHNob3VsZCBub3QgYmUgY2FsbGVkIGJlZm9yZVxuICAgKiB7QGxpbmsgQ2VzaXVtVGVycmFpblByb3ZpZGVyI3JlYWR5fSByZXR1cm5zIHRydWUuICBUaGlzIHByb3BlcnR5IG1heSBiZSB1bmRlZmluZWQgaWYgYXZhaWxhYmlsaXR5XG4gICAqIGluZm9ybWF0aW9uIGlzIG5vdCBhdmFpbGFibGUuIE5vdGUgdGhhdCB0aGlzIHJlZmxlY3RzIHRpbGVzIHRoYXQgYXJlIGtub3duIHRvIGJlIGF2YWlsYWJsZSBjdXJyZW50bHkuXG4gICAqIEFkZGl0aW9uYWwgdGlsZXMgbWF5IGJlIGRpc2NvdmVyZWQgdG8gYmUgYXZhaWxhYmxlIGluIHRoZSBmdXR1cmUsIGUuZy4gaWYgYXZhaWxhYmlsaXR5IGluZm9ybWF0aW9uXG4gICAqIGV4aXN0cyBkZWVwZXIgaW4gdGhlIHRyZWUgcmF0aGVyIHRoYW4gaXQgYWxsIGJlaW5nIGRpc2NvdmVyYWJsZSBhdCB0aGUgcm9vdC4gSG93ZXZlciwgYSB0aWxlIHRoYXRcbiAgICogaXMgYXZhaWxhYmxlIG5vdyB3aWxsIG5vdCBiZWNvbWUgdW5hdmFpbGFibGUgaW4gdGhlIGZ1dHVyZS5cbiAgICogQG1lbWJlcm9mIENlc2l1bVRlcnJhaW5Qcm92aWRlci5wcm90b3R5cGVcbiAgICogQHR5cGUge1RpbGVBdmFpbGFiaWxpdHl9XG4gICAqIEByZWFkb25seVxuICAgKi9cbiAgYXZhaWxhYmlsaXR5OiB7XG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAvLz4+aW5jbHVkZVN0YXJ0KCdkZWJ1ZycsIHByYWdtYXMuZGVidWcpXG4gICAgICBpZiAoIXRoaXMuX3JlYWR5KSB7XG4gICAgICAgIHRocm93IG5ldyBEZXZlbG9wZXJFcnJvcihcbiAgICAgICAgICBcImF2YWlsYWJpbGl0eSBtdXN0IG5vdCBiZSBjYWxsZWQgYmVmb3JlIHRoZSB0ZXJyYWluIHByb3ZpZGVyIGlzIHJlYWR5LlwiXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICAvLz4+aW5jbHVkZUVuZCgnZGVidWcnKTtcbiAgICAgIHJldHVybiB0aGlzLl9hdmFpbGFiaWxpdHk7XG4gICAgfSxcbiAgfSxcbn0pO1xuXG4vKipcbiAqIEdldHMgdGhlIG1heGltdW0gZ2VvbWV0cmljIGVycm9yIGFsbG93ZWQgaW4gYSB0aWxlIGF0IGEgZ2l2ZW4gbGV2ZWwuXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IGxldmVsIFRoZSB0aWxlIGxldmVsIGZvciB3aGljaCB0byBnZXQgdGhlIG1heGltdW0gZ2VvbWV0cmljIGVycm9yLlxuICogQHJldHVybnMge051bWJlcn0gVGhlIG1heGltdW0gZ2VvbWV0cmljIGVycm9yLlxuICovXG5DZXNpdW1UZXJyYWluUHJvdmlkZXIucHJvdG90eXBlLmdldExldmVsTWF4aW11bUdlb21ldHJpY0Vycm9yID0gZnVuY3Rpb24gKFxuICBsZXZlbFxuKSB7XG4gIHJldHVybiB0aGlzLl9sZXZlbFplcm9NYXhpbXVtR2VvbWV0cmljRXJyb3IgLyAoMSA8PCBsZXZlbCk7XG59O1xuXG4vKipcbiAqIERldGVybWluZXMgd2hldGhlciBkYXRhIGZvciBhIHRpbGUgaXMgYXZhaWxhYmxlIHRvIGJlIGxvYWRlZC5cbiAqXG4gKiBAcGFyYW0ge051bWJlcn0geCBUaGUgWCBjb29yZGluYXRlIG9mIHRoZSB0aWxlIGZvciB3aGljaCB0byByZXF1ZXN0IGdlb21ldHJ5LlxuICogQHBhcmFtIHtOdW1iZXJ9IHkgVGhlIFkgY29vcmRpbmF0ZSBvZiB0aGUgdGlsZSBmb3Igd2hpY2ggdG8gcmVxdWVzdCBnZW9tZXRyeS5cbiAqIEBwYXJhbSB7TnVtYmVyfSBsZXZlbCBUaGUgbGV2ZWwgb2YgdGhlIHRpbGUgZm9yIHdoaWNoIHRvIHJlcXVlc3QgZ2VvbWV0cnkuXG4gKiBAcmV0dXJucyB7Qm9vbGVhbnx1bmRlZmluZWR9IFVuZGVmaW5lZCBpZiBub3Qgc3VwcG9ydGVkIG9yIGF2YWlsYWJpbGl0eSBpcyB1bmtub3duLCBvdGhlcndpc2UgdHJ1ZSBvciBmYWxzZS5cbiAqL1xuQ2VzaXVtVGVycmFpblByb3ZpZGVyLnByb3RvdHlwZS5nZXRUaWxlRGF0YUF2YWlsYWJsZSA9IGZ1bmN0aW9uICh4LCB5LCBsZXZlbCkge1xuICBpZiAoIWRlZmluZWQodGhpcy5fYXZhaWxhYmlsaXR5KSkge1xuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cbiAgaWYgKGxldmVsID4gdGhpcy5fYXZhaWxhYmlsaXR5Ll9tYXhpbXVtTGV2ZWwpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBpZiAodGhpcy5fYXZhaWxhYmlsaXR5LmlzVGlsZUF2YWlsYWJsZShsZXZlbCwgeCwgeSkpIHtcbiAgICAvLyBJZiB0aGUgdGlsZSBpcyBsaXN0ZWQgYXMgYXZhaWxhYmxlLCB0aGVuIHdlIGFyZSBkb25lXG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgaWYgKCF0aGlzLl9oYXNNZXRhZGF0YSkge1xuICAgIC8vIElmIHdlIGRvbid0IGhhdmUgYW55IGxheWVycyB3aXRoIHRoZSBtZXRhZGF0YSBleHRlbnNpb24gdGhlbiB3ZSBkb24ndCBoYXZlIHRoaXMgdGlsZVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHZhciBsYXllcnMgPSB0aGlzLl9sYXllcnM7XG4gIHZhciBjb3VudCA9IGxheWVycy5sZW5ndGg7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgY291bnQ7ICsraSkge1xuICAgIHZhciBsYXllclJlc3VsdCA9IGNoZWNrTGF5ZXIodGhpcywgeCwgeSwgbGV2ZWwsIGxheWVyc1tpXSwgaSA9PT0gMCk7XG4gICAgaWYgKGxheWVyUmVzdWx0LnJlc3VsdCkge1xuICAgICAgLy8gVGhlcmUgaXMgYSBsYXllciB0aGF0IG1heSBvciBtYXkgbm90IGhhdmUgdGhlIHRpbGVcbiAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufTtcblxuLyoqXG4gKiBNYWtlcyBzdXJlIHdlIGxvYWQgYXZhaWxhYmlsaXR5IGRhdGEgZm9yIGEgdGlsZVxuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSB4IFRoZSBYIGNvb3JkaW5hdGUgb2YgdGhlIHRpbGUgZm9yIHdoaWNoIHRvIHJlcXVlc3QgZ2VvbWV0cnkuXG4gKiBAcGFyYW0ge051bWJlcn0geSBUaGUgWSBjb29yZGluYXRlIG9mIHRoZSB0aWxlIGZvciB3aGljaCB0byByZXF1ZXN0IGdlb21ldHJ5LlxuICogQHBhcmFtIHtOdW1iZXJ9IGxldmVsIFRoZSBsZXZlbCBvZiB0aGUgdGlsZSBmb3Igd2hpY2ggdG8gcmVxdWVzdCBnZW9tZXRyeS5cbiAqIEByZXR1cm5zIHt1bmRlZmluZWR8UHJvbWlzZTx2b2lkPn0gVW5kZWZpbmVkIGlmIG5vdGhpbmcgbmVlZCB0byBiZSBsb2FkZWQgb3IgYSBQcm9taXNlIHRoYXQgcmVzb2x2ZXMgd2hlbiBhbGwgcmVxdWlyZWQgdGlsZXMgYXJlIGxvYWRlZFxuICovXG5DZXNpdW1UZXJyYWluUHJvdmlkZXIucHJvdG90eXBlLmxvYWRUaWxlRGF0YUF2YWlsYWJpbGl0eSA9IGZ1bmN0aW9uIChcbiAgeCxcbiAgeSxcbiAgbGV2ZWxcbikge1xuICBpZiAoXG4gICAgIWRlZmluZWQodGhpcy5fYXZhaWxhYmlsaXR5KSB8fFxuICAgIGxldmVsID4gdGhpcy5fYXZhaWxhYmlsaXR5Ll9tYXhpbXVtTGV2ZWwgfHxcbiAgICB0aGlzLl9hdmFpbGFiaWxpdHkuaXNUaWxlQXZhaWxhYmxlKGxldmVsLCB4LCB5KSB8fFxuICAgICF0aGlzLl9oYXNNZXRhZGF0YVxuICApIHtcbiAgICAvLyBXZSBrbm93IHRoZSB0aWxlIGlzIGVpdGhlciBhdmFpbGFibGUgb3Igbm90IGF2YWlsYWJsZSBzbyBub3RoaW5nIHRvIHdhaXQgb25cbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG5cbiAgdmFyIGxheWVycyA9IHRoaXMuX2xheWVycztcbiAgdmFyIGNvdW50ID0gbGF5ZXJzLmxlbmd0aDtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb3VudDsgKytpKSB7XG4gICAgdmFyIGxheWVyUmVzdWx0ID0gY2hlY2tMYXllcih0aGlzLCB4LCB5LCBsZXZlbCwgbGF5ZXJzW2ldLCBpID09PSAwKTtcbiAgICBpZiAoZGVmaW5lZChsYXllclJlc3VsdC5wcm9taXNlKSkge1xuICAgICAgcmV0dXJuIGxheWVyUmVzdWx0LnByb21pc2U7XG4gICAgfVxuICB9XG59O1xuXG5mdW5jdGlvbiBnZXRBdmFpbGFiaWxpdHlUaWxlKGxheWVyLCB4LCB5LCBsZXZlbCkge1xuICBpZiAobGV2ZWwgPT09IDApIHtcbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgYXZhaWxhYmlsaXR5TGV2ZWxzID0gbGF5ZXIuYXZhaWxhYmlsaXR5TGV2ZWxzO1xuICB2YXIgcGFyZW50TGV2ZWwgPVxuICAgIGxldmVsICUgYXZhaWxhYmlsaXR5TGV2ZWxzID09PSAwXG4gICAgICA/IGxldmVsIC0gYXZhaWxhYmlsaXR5TGV2ZWxzXG4gICAgICA6ICgobGV2ZWwgLyBhdmFpbGFiaWxpdHlMZXZlbHMpIHwgMCkgKiBhdmFpbGFiaWxpdHlMZXZlbHM7XG4gIHZhciBkaXZpc29yID0gMSA8PCAobGV2ZWwgLSBwYXJlbnRMZXZlbCk7XG4gIHZhciBwYXJlbnRYID0gKHggLyBkaXZpc29yKSB8IDA7XG4gIHZhciBwYXJlbnRZID0gKHkgLyBkaXZpc29yKSB8IDA7XG5cbiAgcmV0dXJuIHtcbiAgICBsZXZlbDogcGFyZW50TGV2ZWwsXG4gICAgeDogcGFyZW50WCxcbiAgICB5OiBwYXJlbnRZLFxuICB9O1xufVxuXG5mdW5jdGlvbiBjaGVja0xheWVyKHByb3ZpZGVyLCB4LCB5LCBsZXZlbCwgbGF5ZXIsIHRvcExheWVyKSB7XG4gIGlmICghZGVmaW5lZChsYXllci5hdmFpbGFiaWxpdHlMZXZlbHMpKSB7XG4gICAgLy8gSXQncyBkZWZpbml0ZWx5IG5vdCBpbiB0aGlzIGxheWVyXG4gICAgcmV0dXJuIHtcbiAgICAgIHJlc3VsdDogZmFsc2UsXG4gICAgfTtcbiAgfVxuXG4gIHZhciBjYWNoZUtleTtcbiAgdmFyIGRlbGV0ZUZyb21DYWNoZSA9IGZ1bmN0aW9uICgpIHtcbiAgICBkZWxldGUgbGF5ZXIuYXZhaWxhYmlsaXR5UHJvbWlzZUNhY2hlW2NhY2hlS2V5XTtcbiAgfTtcbiAgdmFyIGF2YWlsYWJpbGl0eVRpbGVzTG9hZGVkID0gbGF5ZXIuYXZhaWxhYmlsaXR5VGlsZXNMb2FkZWQ7XG4gIHZhciBhdmFpbGFiaWxpdHkgPSBsYXllci5hdmFpbGFiaWxpdHk7XG5cbiAgdmFyIHRpbGUgPSBnZXRBdmFpbGFiaWxpdHlUaWxlKGxheWVyLCB4LCB5LCBsZXZlbCk7XG4gIHdoaWxlIChkZWZpbmVkKHRpbGUpKSB7XG4gICAgaWYgKFxuICAgICAgYXZhaWxhYmlsaXR5LmlzVGlsZUF2YWlsYWJsZSh0aWxlLmxldmVsLCB0aWxlLngsIHRpbGUueSkgJiZcbiAgICAgICFhdmFpbGFiaWxpdHlUaWxlc0xvYWRlZC5pc1RpbGVBdmFpbGFibGUodGlsZS5sZXZlbCwgdGlsZS54LCB0aWxlLnkpXG4gICAgKSB7XG4gICAgICB2YXIgcmVxdWVzdFByb21pc2U7XG4gICAgICBpZiAoIXRvcExheWVyKSB7XG4gICAgICAgIGNhY2hlS2V5ID0gdGlsZS5sZXZlbCArIFwiLVwiICsgdGlsZS54ICsgXCItXCIgKyB0aWxlLnk7XG4gICAgICAgIHJlcXVlc3RQcm9taXNlID0gbGF5ZXIuYXZhaWxhYmlsaXR5UHJvbWlzZUNhY2hlW2NhY2hlS2V5XTtcbiAgICAgICAgaWYgKCFkZWZpbmVkKHJlcXVlc3RQcm9taXNlKSkge1xuICAgICAgICAgIC8vIEZvciBjdXRvdXQgdGVycmFpbiwgaWYgdGhpcyBpc24ndCB0aGUgdG9wIGxheWVyIHRoZSBhdmFpbGFiaWxpdHkgdGlsZXNcbiAgICAgICAgICAvLyAgbWF5IG5ldmVyIGdldCBsb2FkZWQsIHNvIHJlcXVlc3QgaXQgaGVyZS5cbiAgICAgICAgICB2YXIgcmVxdWVzdCA9IG5ldyBSZXF1ZXN0KHtcbiAgICAgICAgICAgIHRocm90dGxlOiBmYWxzZSxcbiAgICAgICAgICAgIHRocm90dGxlQnlTZXJ2ZXI6IHRydWUsXG4gICAgICAgICAgICB0eXBlOiBSZXF1ZXN0VHlwZS5URVJSQUlOLFxuICAgICAgICAgIH0pO1xuICAgICAgICAgIHJlcXVlc3RQcm9taXNlID0gcmVxdWVzdFRpbGVHZW9tZXRyeShcbiAgICAgICAgICAgIHByb3ZpZGVyLFxuICAgICAgICAgICAgdGlsZS54LFxuICAgICAgICAgICAgdGlsZS55LFxuICAgICAgICAgICAgdGlsZS5sZXZlbCxcbiAgICAgICAgICAgIGxheWVyLFxuICAgICAgICAgICAgcmVxdWVzdFxuICAgICAgICAgICk7XG4gICAgICAgICAgaWYgKGRlZmluZWQocmVxdWVzdFByb21pc2UpKSB7XG4gICAgICAgICAgICBsYXllci5hdmFpbGFiaWxpdHlQcm9taXNlQ2FjaGVbY2FjaGVLZXldID0gcmVxdWVzdFByb21pc2U7XG4gICAgICAgICAgICByZXF1ZXN0UHJvbWlzZS50aGVuKGRlbGV0ZUZyb21DYWNoZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIFRoZSBhdmFpbGFiaWxpdHkgdGlsZSBpcyBhdmFpbGFibGUsIGJ1dCBub3QgbG9hZGVkLCBzbyB0aGVyZVxuICAgICAgLy8gIGlzIHN0aWxsIGEgY2hhbmNlIHRoYXQgaXQgbWF5IGJlY29tZSBhdmFpbGFibGUgYXQgc29tZSBwb2ludFxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgcmVzdWx0OiB0cnVlLFxuICAgICAgICBwcm9taXNlOiByZXF1ZXN0UHJvbWlzZSxcbiAgICAgIH07XG4gICAgfVxuXG4gICAgdGlsZSA9IGdldEF2YWlsYWJpbGl0eVRpbGUobGF5ZXIsIHRpbGUueCwgdGlsZS55LCB0aWxlLmxldmVsKTtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgcmVzdWx0OiBmYWxzZSxcbiAgfTtcbn1cblxuLy8gVXNlZCBmb3IgdGVzdGluZ1xuQ2VzaXVtVGVycmFpblByb3ZpZGVyLl9nZXRBdmFpbGFiaWxpdHlUaWxlID0gZ2V0QXZhaWxhYmlsaXR5VGlsZTtcbmV4cG9ydCBkZWZhdWx0IENlc2l1bVRlcnJhaW5Qcm92aWRlcjtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///65987\n')}}]);