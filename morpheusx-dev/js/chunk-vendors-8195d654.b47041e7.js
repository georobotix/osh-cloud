"use strict";(self["webpackChunkvue3_webpack5"]=self["webpackChunkvue3_webpack5"]||[]).push([[7218],{63803:function(__unused_webpack_module,__webpack_exports__,__webpack_require__){eval('/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "Z": function() { return /* binding */ debug; },\n/* harmony export */   "z": function() { return /* binding */ register; }\n/* harmony export */ });\n/* harmony import */ var _utils_log__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(80744);\n\n\nlet loggers = {};\n\nif (false) {}\n\nfunction register(handlers) {\n  loggers = handlers;\n}\nfunction debug(eventType, arg1, arg2, arg3) {\n  if (_utils_log__WEBPACK_IMPORTED_MODULE_0__/* ["default"].level */ .Z.level > 0 && loggers[eventType]) {\n    loggers[eventType].call(null, arg1, arg2, arg3);\n  }\n}\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNjM4MDMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBbUM7QUFDSTtBQUN2Qzs7QUFFQSxJQUFJLEtBQXFDLEVBQUUsRUFFMUM7O0FBRU07QUFDUDtBQUNBO0FBQ2U7QUFDZixNQUFNLHVFQUFhO0FBQ25CO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdnVlMy13ZWJwYWNrNS8uL25vZGVfbW9kdWxlcy9AZGVjay5nbC9jb3JlL2Rpc3QvZXNtL2RlYnVnL2luZGV4LmpzP2NkYjciXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IGRlY2tMb2cgZnJvbSAnLi4vdXRpbHMvbG9nJztcbmltcG9ydCB7IGdldExvZ2dlcnMgfSBmcm9tICcuL2xvZ2dlcnMnO1xubGV0IGxvZ2dlcnMgPSB7fTtcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgbG9nZ2VycyA9IGdldExvZ2dlcnMoZGVja0xvZyk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiByZWdpc3RlcihoYW5kbGVycykge1xuICBsb2dnZXJzID0gaGFuZGxlcnM7XG59XG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBkZWJ1ZyhldmVudFR5cGUsIGFyZzEsIGFyZzIsIGFyZzMpIHtcbiAgaWYgKGRlY2tMb2cubGV2ZWwgPiAwICYmIGxvZ2dlcnNbZXZlbnRUeXBlXSkge1xuICAgIGxvZ2dlcnNbZXZlbnRUeXBlXS5jYWxsKG51bGwsIGFyZzEsIGFyZzIsIGFyZzMpO1xuICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///63803\n')},91619:function(__unused_webpack_module,__webpack_exports__,__webpack_require__){eval('/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "AQ": function() { return /* binding */ getSourceBufferAttribute; },\n/* harmony export */   "DY": function() { return /* binding */ cycleBuffers; },\n/* harmony export */   "IV": function() { return /* binding */ padBuffer; },\n/* harmony export */   "M0": function() { return /* binding */ normalizeTransitionSettings; },\n/* harmony export */   "pi": function() { return /* binding */ getAttributeBufferLength; },\n/* harmony export */   "w": function() { return /* binding */ getAttributeTypeFromSize; }\n/* harmony export */ });\n/* harmony import */ var _utils_array_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(49440);\n\nconst DEFAULT_TRANSITION_SETTINGS = {\n  interpolation: {\n    duration: 0,\n    easing: t => t\n  },\n  spring: {\n    stiffness: 0.05,\n    damping: 0.5\n  }\n};\nfunction normalizeTransitionSettings(userSettings, layerSettings) {\n  if (!userSettings) {\n    return null;\n  }\n\n  if (Number.isFinite(userSettings)) {\n    userSettings = {\n      type: \'interpolation\',\n      duration: userSettings\n    };\n  }\n\n  const type = userSettings.type || \'interpolation\';\n  return { ...DEFAULT_TRANSITION_SETTINGS[type],\n    ...layerSettings,\n    ...userSettings,\n    type\n  };\n}\nfunction getSourceBufferAttribute(gl, attribute) {\n  const buffer = attribute.getBuffer();\n\n  if (buffer) {\n    return [buffer, {\n      divisor: 0,\n      size: attribute.size,\n      normalized: attribute.settings.normalized\n    }];\n  }\n\n  return attribute.value;\n}\nfunction getAttributeTypeFromSize(size) {\n  switch (size) {\n    case 1:\n      return \'float\';\n\n    case 2:\n      return \'vec2\';\n\n    case 3:\n      return \'vec3\';\n\n    case 4:\n      return \'vec4\';\n\n    default:\n      throw new Error("No defined attribute type for size \\"".concat(size, "\\""));\n  }\n}\nfunction cycleBuffers(buffers) {\n  buffers.push(buffers.shift());\n}\nfunction getAttributeBufferLength(attribute, numInstances) {\n  const {\n    doublePrecision,\n    settings,\n    value,\n    size\n  } = attribute;\n  const multiplier = doublePrecision && value instanceof Float64Array ? 2 : 1;\n  return (settings.noAlloc ? value.length : numInstances * size) * multiplier;\n}\nfunction padBuffer({\n  buffer,\n  numInstances,\n  attribute,\n  fromLength,\n  fromStartIndices,\n  getData = x => x\n}) {\n  const precisionMultiplier = attribute.doublePrecision && attribute.value instanceof Float64Array ? 2 : 1;\n  const size = attribute.size * precisionMultiplier;\n  const byteOffset = attribute.byteOffset;\n  const toStartIndices = attribute.startIndices;\n  const hasStartIndices = fromStartIndices && toStartIndices;\n  const toLength = getAttributeBufferLength(attribute, numInstances);\n  const isConstant = attribute.isConstant;\n\n  if (!hasStartIndices && fromLength >= toLength) {\n    return;\n  }\n\n  const toData = isConstant ? attribute.value : attribute.getBuffer().getData({\n    srcByteOffset: byteOffset\n  });\n\n  if (attribute.settings.normalized && !isConstant) {\n    const getter = getData;\n\n    getData = (value, chunk) => attribute.normalizeConstant(getter(value, chunk));\n  }\n\n  const getMissingData = isConstant ? (i, chunk) => getData(toData, chunk) : (i, chunk) => getData(toData.subarray(i, i + size), chunk);\n  const source = buffer.getData({\n    length: fromLength\n  });\n  const data = new Float32Array(toLength);\n  (0,_utils_array_utils__WEBPACK_IMPORTED_MODULE_0__/* .padArray */ .T)({\n    source,\n    target: data,\n    sourceStartIndices: fromStartIndices,\n    targetStartIndices: toStartIndices,\n    size,\n    getData: getMissingData\n  });\n\n  if (buffer.byteLength < data.byteLength + byteOffset) {\n    buffer.reallocate(data.byteLength + byteOffset);\n  }\n\n  buffer.subData({\n    data,\n    offset: byteOffset\n  });\n}\n//# sourceMappingURL=attribute-transition-utils.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiOTE2MTkuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBQW1EO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxFQUFFLHFFQUFRO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly92dWUzLXdlYnBhY2s1Ly4vbm9kZV9tb2R1bGVzL0BkZWNrLmdsL2NvcmUvZGlzdC9lc20vbGliL2F0dHJpYnV0ZS9hdHRyaWJ1dGUtdHJhbnNpdGlvbi11dGlscy5qcz83NGZjIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IHBhZEFycmF5IH0gZnJvbSAnLi4vLi4vdXRpbHMvYXJyYXktdXRpbHMnO1xuY29uc3QgREVGQVVMVF9UUkFOU0lUSU9OX1NFVFRJTkdTID0ge1xuICBpbnRlcnBvbGF0aW9uOiB7XG4gICAgZHVyYXRpb246IDAsXG4gICAgZWFzaW5nOiB0ID0+IHRcbiAgfSxcbiAgc3ByaW5nOiB7XG4gICAgc3RpZmZuZXNzOiAwLjA1LFxuICAgIGRhbXBpbmc6IDAuNVxuICB9XG59O1xuZXhwb3J0IGZ1bmN0aW9uIG5vcm1hbGl6ZVRyYW5zaXRpb25TZXR0aW5ncyh1c2VyU2V0dGluZ3MsIGxheWVyU2V0dGluZ3MpIHtcbiAgaWYgKCF1c2VyU2V0dGluZ3MpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIGlmIChOdW1iZXIuaXNGaW5pdGUodXNlclNldHRpbmdzKSkge1xuICAgIHVzZXJTZXR0aW5ncyA9IHtcbiAgICAgIHR5cGU6ICdpbnRlcnBvbGF0aW9uJyxcbiAgICAgIGR1cmF0aW9uOiB1c2VyU2V0dGluZ3NcbiAgICB9O1xuICB9XG5cbiAgY29uc3QgdHlwZSA9IHVzZXJTZXR0aW5ncy50eXBlIHx8ICdpbnRlcnBvbGF0aW9uJztcbiAgcmV0dXJuIHsgLi4uREVGQVVMVF9UUkFOU0lUSU9OX1NFVFRJTkdTW3R5cGVdLFxuICAgIC4uLmxheWVyU2V0dGluZ3MsXG4gICAgLi4udXNlclNldHRpbmdzLFxuICAgIHR5cGVcbiAgfTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBnZXRTb3VyY2VCdWZmZXJBdHRyaWJ1dGUoZ2wsIGF0dHJpYnV0ZSkge1xuICBjb25zdCBidWZmZXIgPSBhdHRyaWJ1dGUuZ2V0QnVmZmVyKCk7XG5cbiAgaWYgKGJ1ZmZlcikge1xuICAgIHJldHVybiBbYnVmZmVyLCB7XG4gICAgICBkaXZpc29yOiAwLFxuICAgICAgc2l6ZTogYXR0cmlidXRlLnNpemUsXG4gICAgICBub3JtYWxpemVkOiBhdHRyaWJ1dGUuc2V0dGluZ3Mubm9ybWFsaXplZFxuICAgIH1dO1xuICB9XG5cbiAgcmV0dXJuIGF0dHJpYnV0ZS52YWx1ZTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBnZXRBdHRyaWJ1dGVUeXBlRnJvbVNpemUoc2l6ZSkge1xuICBzd2l0Y2ggKHNpemUpIHtcbiAgICBjYXNlIDE6XG4gICAgICByZXR1cm4gJ2Zsb2F0JztcblxuICAgIGNhc2UgMjpcbiAgICAgIHJldHVybiAndmVjMic7XG5cbiAgICBjYXNlIDM6XG4gICAgICByZXR1cm4gJ3ZlYzMnO1xuXG4gICAgY2FzZSA0OlxuICAgICAgcmV0dXJuICd2ZWM0JztcblxuICAgIGRlZmF1bHQ6XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJObyBkZWZpbmVkIGF0dHJpYnV0ZSB0eXBlIGZvciBzaXplIFxcXCJcIi5jb25jYXQoc2l6ZSwgXCJcXFwiXCIpKTtcbiAgfVxufVxuZXhwb3J0IGZ1bmN0aW9uIGN5Y2xlQnVmZmVycyhidWZmZXJzKSB7XG4gIGJ1ZmZlcnMucHVzaChidWZmZXJzLnNoaWZ0KCkpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGdldEF0dHJpYnV0ZUJ1ZmZlckxlbmd0aChhdHRyaWJ1dGUsIG51bUluc3RhbmNlcykge1xuICBjb25zdCB7XG4gICAgZG91YmxlUHJlY2lzaW9uLFxuICAgIHNldHRpbmdzLFxuICAgIHZhbHVlLFxuICAgIHNpemVcbiAgfSA9IGF0dHJpYnV0ZTtcbiAgY29uc3QgbXVsdGlwbGllciA9IGRvdWJsZVByZWNpc2lvbiAmJiB2YWx1ZSBpbnN0YW5jZW9mIEZsb2F0NjRBcnJheSA/IDIgOiAxO1xuICByZXR1cm4gKHNldHRpbmdzLm5vQWxsb2MgPyB2YWx1ZS5sZW5ndGggOiBudW1JbnN0YW5jZXMgKiBzaXplKSAqIG11bHRpcGxpZXI7XG59XG5leHBvcnQgZnVuY3Rpb24gcGFkQnVmZmVyKHtcbiAgYnVmZmVyLFxuICBudW1JbnN0YW5jZXMsXG4gIGF0dHJpYnV0ZSxcbiAgZnJvbUxlbmd0aCxcbiAgZnJvbVN0YXJ0SW5kaWNlcyxcbiAgZ2V0RGF0YSA9IHggPT4geFxufSkge1xuICBjb25zdCBwcmVjaXNpb25NdWx0aXBsaWVyID0gYXR0cmlidXRlLmRvdWJsZVByZWNpc2lvbiAmJiBhdHRyaWJ1dGUudmFsdWUgaW5zdGFuY2VvZiBGbG9hdDY0QXJyYXkgPyAyIDogMTtcbiAgY29uc3Qgc2l6ZSA9IGF0dHJpYnV0ZS5zaXplICogcHJlY2lzaW9uTXVsdGlwbGllcjtcbiAgY29uc3QgYnl0ZU9mZnNldCA9IGF0dHJpYnV0ZS5ieXRlT2Zmc2V0O1xuICBjb25zdCB0b1N0YXJ0SW5kaWNlcyA9IGF0dHJpYnV0ZS5zdGFydEluZGljZXM7XG4gIGNvbnN0IGhhc1N0YXJ0SW5kaWNlcyA9IGZyb21TdGFydEluZGljZXMgJiYgdG9TdGFydEluZGljZXM7XG4gIGNvbnN0IHRvTGVuZ3RoID0gZ2V0QXR0cmlidXRlQnVmZmVyTGVuZ3RoKGF0dHJpYnV0ZSwgbnVtSW5zdGFuY2VzKTtcbiAgY29uc3QgaXNDb25zdGFudCA9IGF0dHJpYnV0ZS5pc0NvbnN0YW50O1xuXG4gIGlmICghaGFzU3RhcnRJbmRpY2VzICYmIGZyb21MZW5ndGggPj0gdG9MZW5ndGgpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBjb25zdCB0b0RhdGEgPSBpc0NvbnN0YW50ID8gYXR0cmlidXRlLnZhbHVlIDogYXR0cmlidXRlLmdldEJ1ZmZlcigpLmdldERhdGEoe1xuICAgIHNyY0J5dGVPZmZzZXQ6IGJ5dGVPZmZzZXRcbiAgfSk7XG5cbiAgaWYgKGF0dHJpYnV0ZS5zZXR0aW5ncy5ub3JtYWxpemVkICYmICFpc0NvbnN0YW50KSB7XG4gICAgY29uc3QgZ2V0dGVyID0gZ2V0RGF0YTtcblxuICAgIGdldERhdGEgPSAodmFsdWUsIGNodW5rKSA9PiBhdHRyaWJ1dGUubm9ybWFsaXplQ29uc3RhbnQoZ2V0dGVyKHZhbHVlLCBjaHVuaykpO1xuICB9XG5cbiAgY29uc3QgZ2V0TWlzc2luZ0RhdGEgPSBpc0NvbnN0YW50ID8gKGksIGNodW5rKSA9PiBnZXREYXRhKHRvRGF0YSwgY2h1bmspIDogKGksIGNodW5rKSA9PiBnZXREYXRhKHRvRGF0YS5zdWJhcnJheShpLCBpICsgc2l6ZSksIGNodW5rKTtcbiAgY29uc3Qgc291cmNlID0gYnVmZmVyLmdldERhdGEoe1xuICAgIGxlbmd0aDogZnJvbUxlbmd0aFxuICB9KTtcbiAgY29uc3QgZGF0YSA9IG5ldyBGbG9hdDMyQXJyYXkodG9MZW5ndGgpO1xuICBwYWRBcnJheSh7XG4gICAgc291cmNlLFxuICAgIHRhcmdldDogZGF0YSxcbiAgICBzb3VyY2VTdGFydEluZGljZXM6IGZyb21TdGFydEluZGljZXMsXG4gICAgdGFyZ2V0U3RhcnRJbmRpY2VzOiB0b1N0YXJ0SW5kaWNlcyxcbiAgICBzaXplLFxuICAgIGdldERhdGE6IGdldE1pc3NpbmdEYXRhXG4gIH0pO1xuXG4gIGlmIChidWZmZXIuYnl0ZUxlbmd0aCA8IGRhdGEuYnl0ZUxlbmd0aCArIGJ5dGVPZmZzZXQpIHtcbiAgICBidWZmZXIucmVhbGxvY2F0ZShkYXRhLmJ5dGVMZW5ndGggKyBieXRlT2Zmc2V0KTtcbiAgfVxuXG4gIGJ1ZmZlci5zdWJEYXRhKHtcbiAgICBkYXRhLFxuICAgIG9mZnNldDogYnl0ZU9mZnNldFxuICB9KTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWF0dHJpYnV0ZS10cmFuc2l0aW9uLXV0aWxzLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///91619\n')},13906:function(__unused_webpack_module,__webpack_exports__,__webpack_require__){eval('\n// EXPORTS\n__webpack_require__.d(__webpack_exports__, {\n  "Z": function() { return /* binding */ Attribute; }\n});\n\n// EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/esm/defineProperty.js\nvar defineProperty = __webpack_require__(82482);\n// EXTERNAL MODULE: ./node_modules/@luma.gl/webgl/dist/esm/features/features.js\nvar features = __webpack_require__(44211);\n// EXTERNAL MODULE: ./node_modules/@luma.gl/webgl/dist/esm/features/webgl-features-table.js\nvar webgl_features_table = __webpack_require__(6948);\n// EXTERNAL MODULE: ./node_modules/@luma.gl/webgl/dist/esm/classes/buffer.js\nvar buffer = __webpack_require__(53478);\n;// CONCATENATED MODULE: ./node_modules/@deck.gl/core/dist/esm/lib/attribute/shader-attribute.js\n\nclass ShaderAttribute {\n  constructor(dataColumn, opts) {\n    (0,defineProperty/* default */.Z)(this, "opts", void 0);\n\n    (0,defineProperty/* default */.Z)(this, "source", void 0);\n\n    this.opts = opts;\n    this.source = dataColumn;\n  }\n\n  get value() {\n    return this.source.value;\n  }\n\n  getValue() {\n    const buffer = this.source.getBuffer();\n    const accessor = this.getAccessor();\n\n    if (buffer) {\n      return [buffer, accessor];\n    }\n\n    const {\n      value\n    } = this.source;\n    const {\n      size\n    } = accessor;\n    let constantValue = value;\n\n    if (value && value.length !== size) {\n      constantValue = new Float32Array(size);\n      const index = accessor.elementOffset || 0;\n\n      for (let i = 0; i < size; ++i) {\n        constantValue[i] = value[index + i];\n      }\n    }\n\n    return constantValue;\n  }\n\n  getAccessor() {\n    return { ...this.source.getAccessor(),\n      ...this.opts\n    };\n  }\n\n}\n//# sourceMappingURL=shader-attribute.js.map\n;// CONCATENATED MODULE: ./node_modules/@deck.gl/core/dist/esm/lib/attribute/gl-utils.js\nfunction glArrayFromType(glType) {\n  switch (glType) {\n    case 5126:\n      return Float32Array;\n\n    case 5130:\n      return Float64Array;\n\n    case 5123:\n    case 33635:\n    case 32819:\n    case 32820:\n      return Uint16Array;\n\n    case 5125:\n      return Uint32Array;\n\n    case 5121:\n      return Uint8ClampedArray;\n\n    case 5120:\n      return Int8Array;\n\n    case 5122:\n      return Int16Array;\n\n    case 5124:\n      return Int32Array;\n\n    default:\n      throw new Error(\'Unknown GL type\');\n  }\n}\n//# sourceMappingURL=gl-utils.js.map\n// EXTERNAL MODULE: ./node_modules/@deck.gl/core/dist/esm/utils/typed-array-manager.js\nvar typed_array_manager = __webpack_require__(36610);\n// EXTERNAL MODULE: ./node_modules/@deck.gl/core/dist/esm/utils/math-utils.js\nvar math_utils = __webpack_require__(75126);\n// EXTERNAL MODULE: ./node_modules/@deck.gl/core/dist/esm/utils/log.js\nvar log = __webpack_require__(80744);\n;// CONCATENATED MODULE: ./node_modules/@deck.gl/core/dist/esm/lib/attribute/data-column.js\n\n\n\n\n\n\n\n\nfunction getStride(accessor) {\n  return accessor.stride || accessor.size * accessor.bytesPerElement;\n}\n\nfunction resolveShaderAttribute(baseAccessor, shaderAttributeOptions) {\n  if (shaderAttributeOptions.offset) {\n    log/* default.removed */.Z.removed(\'shaderAttribute.offset\', \'vertexOffset, elementOffset\')();\n  }\n\n  const stride = getStride(baseAccessor);\n  const vertexOffset = shaderAttributeOptions.vertexOffset !== undefined ? shaderAttributeOptions.vertexOffset : baseAccessor.vertexOffset || 0;\n  const elementOffset = shaderAttributeOptions.elementOffset || 0;\n  const offset = vertexOffset * stride + elementOffset * baseAccessor.bytesPerElement + (baseAccessor.offset || 0);\n  return { ...shaderAttributeOptions,\n    offset,\n    stride\n  };\n}\n\nfunction resolveDoublePrecisionShaderAttributes(baseAccessor, shaderAttributeOptions) {\n  const resolvedOptions = resolveShaderAttribute(baseAccessor, shaderAttributeOptions);\n  return {\n    high: resolvedOptions,\n    low: { ...resolvedOptions,\n      offset: resolvedOptions.offset + baseAccessor.size * 4\n    }\n  };\n}\n\nclass DataColumn {\n  constructor(gl, opts, state) {\n    (0,defineProperty/* default */.Z)(this, "gl", void 0);\n\n    (0,defineProperty/* default */.Z)(this, "id", void 0);\n\n    (0,defineProperty/* default */.Z)(this, "size", void 0);\n\n    (0,defineProperty/* default */.Z)(this, "settings", void 0);\n\n    (0,defineProperty/* default */.Z)(this, "value", void 0);\n\n    (0,defineProperty/* default */.Z)(this, "doublePrecision", void 0);\n\n    (0,defineProperty/* default */.Z)(this, "_buffer", void 0);\n\n    (0,defineProperty/* default */.Z)(this, "state", void 0);\n\n    this.gl = gl;\n    this.id = opts.id || \'\';\n    this.size = opts.size || 1;\n    const logicalType = opts.logicalType || opts.type;\n    const doublePrecision = logicalType === 5130;\n    let {\n      defaultValue\n    } = opts;\n    defaultValue = Number.isFinite(defaultValue) ? [defaultValue] : defaultValue || new Array(this.size).fill(0);\n    let bufferType;\n\n    if (doublePrecision) {\n      bufferType = 5126;\n    } else if (!logicalType && opts.isIndexed) {\n      bufferType = gl && (0,features/* hasFeature */.U6)(gl, webgl_features_table/* FEATURES.ELEMENT_INDEX_UINT32 */.h.ELEMENT_INDEX_UINT32) ? 5125 : 5123;\n    } else {\n      bufferType = logicalType || 5126;\n    }\n\n    let defaultType = glArrayFromType(logicalType || bufferType || 5126);\n    this.doublePrecision = doublePrecision;\n\n    if (doublePrecision && opts.fp64 === false) {\n      defaultType = Float32Array;\n    }\n\n    this.value = null;\n    this.settings = { ...opts,\n      defaultType,\n      defaultValue: defaultValue,\n      logicalType,\n      type: bufferType,\n      size: this.size,\n      bytesPerElement: defaultType.BYTES_PER_ELEMENT\n    };\n    this.state = { ...state,\n      externalBuffer: null,\n      bufferAccessor: this.settings,\n      allocatedValue: null,\n      numInstances: 0,\n      bounds: null,\n      constant: false\n    };\n    this._buffer = null;\n  }\n\n  get isConstant() {\n    return this.state.constant;\n  }\n\n  get buffer() {\n    if (!this._buffer) {\n      const {\n        isIndexed,\n        type\n      } = this.settings;\n      this._buffer = new buffer/* default */.Z(this.gl, {\n        id: this.id,\n        target: isIndexed ? 34963 : 34962,\n        accessor: {\n          type\n        }\n      });\n    }\n\n    return this._buffer;\n  }\n\n  get byteOffset() {\n    const accessor = this.getAccessor();\n\n    if (accessor.vertexOffset) {\n      return accessor.vertexOffset * getStride(accessor);\n    }\n\n    return 0;\n  }\n\n  get numInstances() {\n    return this.state.numInstances;\n  }\n\n  set numInstances(n) {\n    this.state.numInstances = n;\n  }\n\n  delete() {\n    if (this._buffer) {\n      this._buffer.delete();\n\n      this._buffer = null;\n    }\n\n    typed_array_manager/* default.release */.Z.release(this.state.allocatedValue);\n  }\n\n  getShaderAttributes(id, options) {\n    if (this.doublePrecision) {\n      const shaderAttributes = {};\n      const isBuffer64Bit = this.value instanceof Float64Array;\n      const doubleShaderAttributeDefs = resolveDoublePrecisionShaderAttributes(this.getAccessor(), options || {});\n      shaderAttributes[id] = new ShaderAttribute(this, doubleShaderAttributeDefs.high);\n      shaderAttributes["".concat(id, "64Low")] = isBuffer64Bit ? new ShaderAttribute(this, doubleShaderAttributeDefs.low) : new Float32Array(this.size);\n      return shaderAttributes;\n    }\n\n    if (options) {\n      const shaderAttributeDef = resolveShaderAttribute(this.getAccessor(), options);\n      return {\n        [id]: new ShaderAttribute(this, shaderAttributeDef)\n      };\n    }\n\n    return {\n      [id]: this\n    };\n  }\n\n  getBuffer() {\n    if (this.state.constant) {\n      return null;\n    }\n\n    return this.state.externalBuffer || this._buffer;\n  }\n\n  getValue() {\n    if (this.state.constant) {\n      return this.value;\n    }\n\n    return [this.getBuffer(), this.getAccessor()];\n  }\n\n  getAccessor() {\n    return this.state.bufferAccessor;\n  }\n\n  getBounds() {\n    if (this.state.bounds) {\n      return this.state.bounds;\n    }\n\n    let result = null;\n\n    if (this.state.constant && this.value) {\n      const min = Array.from(this.value);\n      result = [min, min];\n    } else {\n      const {\n        value,\n        numInstances,\n        size\n      } = this;\n      const len = numInstances * size;\n\n      if (value && len && value.length >= len) {\n        const min = new Array(size).fill(Infinity);\n        const max = new Array(size).fill(-Infinity);\n\n        for (let i = 0; i < len;) {\n          for (let j = 0; j < size; j++) {\n            const v = value[i++];\n            if (v < min[j]) min[j] = v;\n            if (v > max[j]) max[j] = v;\n          }\n        }\n\n        result = [min, max];\n      }\n    }\n\n    this.state.bounds = result;\n    return result;\n  }\n\n  setData(data) {\n    const {\n      state\n    } = this;\n    let opts;\n\n    if (ArrayBuffer.isView(data)) {\n      opts = {\n        value: data\n      };\n    } else if (data instanceof buffer/* default */.Z) {\n      opts = {\n        buffer: data\n      };\n    } else {\n      opts = data;\n    }\n\n    const accessor = { ...this.settings,\n      ...opts\n    };\n    state.bufferAccessor = accessor;\n    state.bounds = null;\n\n    if (opts.constant) {\n      let value = opts.value;\n      value = this._normalizeValue(value, [], 0);\n\n      if (this.settings.normalized) {\n        value = this.normalizeConstant(value);\n      }\n\n      const hasChanged = !state.constant || !this._areValuesEqual(value, this.value);\n\n      if (!hasChanged) {\n        return false;\n      }\n\n      state.externalBuffer = null;\n      state.constant = true;\n      this.value = value;\n    } else if (opts.buffer) {\n      const buffer = opts.buffer;\n      state.externalBuffer = buffer;\n      state.constant = false;\n      this.value = opts.value || null;\n      const isBuffer64Bit = opts.value instanceof Float64Array;\n      accessor.type = opts.type || buffer.accessor.type;\n      accessor.bytesPerElement = buffer.accessor.BYTES_PER_ELEMENT * (isBuffer64Bit ? 2 : 1);\n      accessor.stride = getStride(accessor);\n    } else if (opts.value) {\n      this._checkExternalBuffer(opts);\n\n      let value = opts.value;\n      state.externalBuffer = null;\n      state.constant = false;\n      this.value = value;\n      accessor.bytesPerElement = value.BYTES_PER_ELEMENT;\n      accessor.stride = getStride(accessor);\n      const {\n        buffer,\n        byteOffset\n      } = this;\n\n      if (this.doublePrecision && value instanceof Float64Array) {\n        value = (0,math_utils/* toDoublePrecisionArray */.TK)(value, accessor);\n      }\n\n      const requiredBufferSize = value.byteLength + byteOffset + accessor.stride * 2;\n\n      if (buffer.byteLength < requiredBufferSize) {\n        buffer.reallocate(requiredBufferSize);\n      }\n\n      buffer.setAccessor(null);\n      buffer.subData({\n        data: value,\n        offset: byteOffset\n      });\n      accessor.type = opts.type || buffer.accessor.type;\n    }\n\n    return true;\n  }\n\n  updateSubBuffer(opts = {}) {\n    this.state.bounds = null;\n    const value = this.value;\n    const {\n      startOffset = 0,\n      endOffset\n    } = opts;\n    this.buffer.subData({\n      data: this.doublePrecision && value instanceof Float64Array ? (0,math_utils/* toDoublePrecisionArray */.TK)(value, {\n        size: this.size,\n        startIndex: startOffset,\n        endIndex: endOffset\n      }) : value.subarray(startOffset, endOffset),\n      offset: startOffset * value.BYTES_PER_ELEMENT + this.byteOffset\n    });\n  }\n\n  allocate(numInstances, copy = false) {\n    const {\n      state\n    } = this;\n    const oldValue = state.allocatedValue;\n    const value = typed_array_manager/* default.allocate */.Z.allocate(oldValue, numInstances + 1, {\n      size: this.size,\n      type: this.settings.defaultType,\n      copy\n    });\n    this.value = value;\n    const {\n      buffer,\n      byteOffset\n    } = this;\n\n    if (buffer.byteLength < value.byteLength + byteOffset) {\n      buffer.reallocate(value.byteLength + byteOffset);\n\n      if (copy && oldValue) {\n        buffer.subData({\n          data: oldValue instanceof Float64Array ? (0,math_utils/* toDoublePrecisionArray */.TK)(oldValue, this) : oldValue,\n          offset: byteOffset\n        });\n      }\n    }\n\n    state.allocatedValue = value;\n    state.constant = false;\n    state.externalBuffer = null;\n    state.bufferAccessor = this.settings;\n    return true;\n  }\n\n  _checkExternalBuffer(opts) {\n    const {\n      value\n    } = opts;\n\n    if (!ArrayBuffer.isView(value)) {\n      throw new Error("Attribute ".concat(this.id, " value is not TypedArray"));\n    }\n\n    const ArrayType = this.settings.defaultType;\n    let illegalArrayType = false;\n\n    if (this.doublePrecision) {\n      illegalArrayType = value.BYTES_PER_ELEMENT < 4;\n    }\n\n    if (illegalArrayType) {\n      throw new Error("Attribute ".concat(this.id, " does not support ").concat(value.constructor.name));\n    }\n\n    if (!(value instanceof ArrayType) && this.settings.normalized && !(\'normalized\' in opts)) {\n      log/* default.warn */.Z.warn("Attribute ".concat(this.id, " is normalized"))();\n    }\n  }\n\n  normalizeConstant(value) {\n    switch (this.settings.type) {\n      case 5120:\n        return new Float32Array(value).map(x => (x + 128) / 255 * 2 - 1);\n\n      case 5122:\n        return new Float32Array(value).map(x => (x + 32768) / 65535 * 2 - 1);\n\n      case 5121:\n        return new Float32Array(value).map(x => x / 255);\n\n      case 5123:\n        return new Float32Array(value).map(x => x / 65535);\n\n      default:\n        return value;\n    }\n  }\n\n  _normalizeValue(value, out, start) {\n    const {\n      defaultValue,\n      size\n    } = this.settings;\n\n    if (Number.isFinite(value)) {\n      out[start] = value;\n      return out;\n    }\n\n    if (!value) {\n      let i = size;\n\n      while (--i >= 0) {\n        out[start + i] = defaultValue[i];\n      }\n\n      return out;\n    }\n\n    switch (size) {\n      case 4:\n        out[start + 3] = Number.isFinite(value[3]) ? value[3] : defaultValue[3];\n\n      case 3:\n        out[start + 2] = Number.isFinite(value[2]) ? value[2] : defaultValue[2];\n\n      case 2:\n        out[start + 1] = Number.isFinite(value[1]) ? value[1] : defaultValue[1];\n\n      case 1:\n        out[start + 0] = Number.isFinite(value[0]) ? value[0] : defaultValue[0];\n        break;\n\n      default:\n        let i = size;\n\n        while (--i >= 0) {\n          out[start + i] = Number.isFinite(value[i]) ? value[i] : defaultValue[i];\n        }\n\n    }\n\n    return out;\n  }\n\n  _areValuesEqual(value1, value2) {\n    if (!value1 || !value2) {\n      return false;\n    }\n\n    const {\n      size\n    } = this;\n\n    for (let i = 0; i < size; i++) {\n      if (value1[i] !== value2[i]) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n}\n//# sourceMappingURL=data-column.js.map\n// EXTERNAL MODULE: ./node_modules/@deck.gl/core/dist/esm/utils/assert.js\nvar assert = __webpack_require__(75304);\n// EXTERNAL MODULE: ./node_modules/@deck.gl/core/dist/esm/utils/iterable-utils.js\nvar iterable_utils = __webpack_require__(38550);\n// EXTERNAL MODULE: ./node_modules/@deck.gl/core/dist/esm/utils/flatten.js\nvar flatten = __webpack_require__(61855);\n// EXTERNAL MODULE: ./node_modules/@deck.gl/core/dist/esm/utils/range.js\nvar range = __webpack_require__(47586);\n// EXTERNAL MODULE: ./node_modules/@deck.gl/core/dist/esm/lib/attribute/attribute-transition-utils.js\nvar attribute_transition_utils = __webpack_require__(91619);\n;// CONCATENATED MODULE: ./node_modules/@deck.gl/core/dist/esm/lib/attribute/attribute.js\n\n\n\n\n\n\n\nclass Attribute extends DataColumn {\n  constructor(gl, opts) {\n    super(gl, opts, {\n      startIndices: null,\n      lastExternalBuffer: null,\n      binaryValue: null,\n      binaryAccessor: null,\n      needsUpdate: true,\n      needsRedraw: false,\n      updateRanges: range/* FULL */.KO\n    });\n\n    (0,defineProperty/* default */.Z)(this, "constant", false);\n\n    this.settings.update = opts.update || (opts.accessor ? this._autoUpdater : undefined);\n    Object.seal(this.settings);\n    Object.seal(this.state);\n\n    this._validateAttributeUpdaters();\n  }\n\n  get startIndices() {\n    return this.state.startIndices;\n  }\n\n  set startIndices(layout) {\n    this.state.startIndices = layout;\n  }\n\n  needsUpdate() {\n    return this.state.needsUpdate;\n  }\n\n  needsRedraw({\n    clearChangedFlags = false\n  } = {}) {\n    const needsRedraw = this.state.needsRedraw;\n    this.state.needsRedraw = needsRedraw && !clearChangedFlags;\n    return needsRedraw;\n  }\n\n  getUpdateTriggers() {\n    const {\n      accessor\n    } = this.settings;\n    return [this.id].concat(typeof accessor !== \'function\' && accessor || []);\n  }\n\n  supportsTransition() {\n    return Boolean(this.settings.transition);\n  }\n\n  getTransitionSetting(opts) {\n    if (!opts || !this.supportsTransition()) {\n      return null;\n    }\n\n    const {\n      accessor\n    } = this.settings;\n    const layerSettings = this.settings.transition;\n    const userSettings = Array.isArray(accessor) ? opts[accessor.find(a => opts[a])] : opts[accessor];\n    return (0,attribute_transition_utils/* normalizeTransitionSettings */.M0)(userSettings, layerSettings);\n  }\n\n  setNeedsUpdate(reason = this.id, dataRange) {\n    this.state.needsUpdate = this.state.needsUpdate || reason;\n    this.setNeedsRedraw(reason);\n\n    if (dataRange) {\n      const {\n        startRow = 0,\n        endRow = Infinity\n      } = dataRange;\n      this.state.updateRanges = range/* add */.IH(this.state.updateRanges, [startRow, endRow]);\n    } else {\n      this.state.updateRanges = range/* FULL */.KO;\n    }\n  }\n\n  clearNeedsUpdate() {\n    this.state.needsUpdate = false;\n    this.state.updateRanges = range/* EMPTY */.E_;\n  }\n\n  setNeedsRedraw(reason = this.id) {\n    this.state.needsRedraw = this.state.needsRedraw || reason;\n  }\n\n  allocate(numInstances) {\n    const {\n      state,\n      settings\n    } = this;\n\n    if (settings.noAlloc) {\n      return false;\n    }\n\n    if (settings.update) {\n      super.allocate(numInstances, state.updateRanges !== range/* FULL */.KO);\n      return true;\n    }\n\n    return false;\n  }\n\n  updateBuffer({\n    numInstances,\n    data,\n    props,\n    context\n  }) {\n    if (!this.needsUpdate()) {\n      return false;\n    }\n\n    const {\n      state: {\n        updateRanges\n      },\n      settings: {\n        update,\n        noAlloc\n      }\n    } = this;\n    let updated = true;\n\n    if (update) {\n      for (const [startRow, endRow] of updateRanges) {\n        update.call(context, this, {\n          data,\n          startRow,\n          endRow,\n          props,\n          numInstances\n        });\n      }\n\n      if (!this.value) {} else if (this.constant || this.buffer.byteLength < this.value.byteLength + this.byteOffset) {\n        this.setData({\n          value: this.value,\n          constant: this.constant\n        });\n        this.constant = false;\n      } else {\n        for (const [startRow, endRow] of updateRanges) {\n          const startOffset = Number.isFinite(startRow) ? this.getVertexOffset(startRow) : 0;\n          const endOffset = Number.isFinite(endRow) ? this.getVertexOffset(endRow) : noAlloc || !Number.isFinite(numInstances) ? this.value.length : numInstances * this.size;\n          super.updateSubBuffer({\n            startOffset,\n            endOffset\n          });\n        }\n      }\n\n      this._checkAttributeArray();\n    } else {\n      updated = false;\n    }\n\n    this.clearNeedsUpdate();\n    this.setNeedsRedraw();\n    return updated;\n  }\n\n  setConstantValue(value) {\n    if (value === undefined || typeof value === \'function\') {\n      return false;\n    }\n\n    const hasChanged = this.setData({\n      constant: true,\n      value\n    });\n\n    if (hasChanged) {\n      this.setNeedsRedraw();\n    }\n\n    this.clearNeedsUpdate();\n    return true;\n  }\n\n  setExternalBuffer(buffer) {\n    const {\n      state\n    } = this;\n\n    if (!buffer) {\n      state.lastExternalBuffer = null;\n      return false;\n    }\n\n    this.clearNeedsUpdate();\n\n    if (state.lastExternalBuffer === buffer) {\n      return true;\n    }\n\n    state.lastExternalBuffer = buffer;\n    this.setNeedsRedraw();\n    this.setData(buffer);\n    return true;\n  }\n\n  setBinaryValue(buffer, startIndices = null) {\n    const {\n      state,\n      settings\n    } = this;\n\n    if (!buffer) {\n      state.binaryValue = null;\n      state.binaryAccessor = null;\n      return false;\n    }\n\n    if (settings.noAlloc) {\n      return false;\n    }\n\n    if (state.binaryValue === buffer) {\n      this.clearNeedsUpdate();\n      return true;\n    }\n\n    state.binaryValue = buffer;\n    this.setNeedsRedraw();\n    const needsUpdate = settings.transform || startIndices !== this.startIndices;\n\n    if (needsUpdate) {\n      if (ArrayBuffer.isView(buffer)) {\n        buffer = {\n          value: buffer\n        };\n      }\n\n      const binaryValue = buffer;\n      (0,assert/* default */.Z)(ArrayBuffer.isView(binaryValue.value), "invalid ".concat(settings.accessor));\n      const needsNormalize = Boolean(binaryValue.size) && binaryValue.size !== this.size;\n      state.binaryAccessor = (0,iterable_utils/* getAccessorFromBuffer */.jr)(binaryValue.value, {\n        size: binaryValue.size || this.size,\n        stride: binaryValue.stride,\n        offset: binaryValue.offset,\n        startIndices: startIndices,\n        nested: needsNormalize\n      });\n      return false;\n    }\n\n    this.clearNeedsUpdate();\n    this.setData(buffer);\n    return true;\n  }\n\n  getVertexOffset(row) {\n    const {\n      startIndices\n    } = this;\n    const vertexIndex = startIndices ? row < startIndices.length ? startIndices[row] : this.numInstances : row;\n    return vertexIndex * this.size;\n  }\n\n  getShaderAttributes() {\n    const shaderAttributeDefs = this.settings.shaderAttributes || {\n      [this.id]: null\n    };\n    const shaderAttributes = {};\n\n    for (const shaderAttributeName in shaderAttributeDefs) {\n      Object.assign(shaderAttributes, super.getShaderAttributes(shaderAttributeName, shaderAttributeDefs[shaderAttributeName]));\n    }\n\n    return shaderAttributes;\n  }\n\n  _autoUpdater(attribute, {\n    data,\n    startRow,\n    endRow,\n    props,\n    numInstances\n  }) {\n    if (attribute.constant) {\n      return;\n    }\n\n    const {\n      settings,\n      state,\n      value,\n      size,\n      startIndices\n    } = attribute;\n    const {\n      accessor,\n      transform\n    } = settings;\n    const accessorFunc = state.binaryAccessor || (typeof accessor === \'function\' ? accessor : props[accessor]);\n    (0,assert/* default */.Z)(typeof accessorFunc === \'function\', "accessor \\"".concat(accessor, "\\" is not a function"));\n    let i = attribute.getVertexOffset(startRow);\n    const {\n      iterable,\n      objectInfo\n    } = (0,iterable_utils/* createIterable */.jB)(data, startRow, endRow);\n\n    for (const object of iterable) {\n      objectInfo.index++;\n      let objectValue = accessorFunc(object, objectInfo);\n\n      if (transform) {\n        objectValue = transform.call(this, objectValue);\n      }\n\n      if (startIndices) {\n        const numVertices = (objectInfo.index < startIndices.length - 1 ? startIndices[objectInfo.index + 1] : numInstances) - startIndices[objectInfo.index];\n\n        if (objectValue && Array.isArray(objectValue[0])) {\n          let startIndex = i;\n\n          for (const item of objectValue) {\n            attribute._normalizeValue(item, value, startIndex);\n\n            startIndex += size;\n          }\n        } else if (objectValue && objectValue.length > size) {\n          value.set(objectValue, i);\n        } else {\n          attribute._normalizeValue(objectValue, objectInfo.target, 0);\n\n          (0,flatten/* fillArray */.k)({\n            target: value,\n            source: objectInfo.target,\n            start: i,\n            count: numVertices\n          });\n        }\n\n        i += numVertices * size;\n      } else {\n        attribute._normalizeValue(objectValue, value, i);\n\n        i += size;\n      }\n    }\n  }\n\n  _validateAttributeUpdaters() {\n    const {\n      settings\n    } = this;\n    const hasUpdater = settings.noAlloc || typeof settings.update === \'function\';\n\n    if (!hasUpdater) {\n      throw new Error("Attribute ".concat(this.id, " missing update or accessor"));\n    }\n  }\n\n  _checkAttributeArray() {\n    const {\n      value\n    } = this;\n    const limit = Math.min(4, this.size);\n\n    if (value && value.length >= limit) {\n      let valid = true;\n\n      switch (limit) {\n        case 4:\n          valid = valid && Number.isFinite(value[3]);\n\n        case 3:\n          valid = valid && Number.isFinite(value[2]);\n\n        case 2:\n          valid = valid && Number.isFinite(value[1]);\n\n        case 1:\n          valid = valid && Number.isFinite(value[0]);\n          break;\n\n        default:\n          valid = false;\n      }\n\n      if (!valid) {\n        throw new Error("Illegal attribute generated for ".concat(this.id));\n      }\n    }\n  }\n\n}\n//# sourceMappingURL=attribute.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QUNBLE1BQU07O0FBRU47QUFDQTtBQUNBOztBQUVBO0FBQ0EsMERBQTBELGtCQUFVO0FBQ3BFO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBOztBQUVBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07O0FBRU47QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNOztBQUVOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxNQUFNLHlCQUFNO0FBQ1o7QUFDQSw2QkFBNkIsZ0RBQXFCO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsSUFBSSx5QkFBTTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTSxFQUFFLHlDQUFjOztBQUV0QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxVQUFVO0FBQ1Y7O0FBRUEsVUFBVSw0QkFBUztBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDs7QUFFQTtBQUNBLFFBQVE7QUFDUjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3Z1ZTMtd2VicGFjazUvLi9ub2RlX21vZHVsZXMvQGRlY2suZ2wvY29yZS9kaXN0L2VzbS9saWIvYXR0cmlidXRlL3NoYWRlci1hdHRyaWJ1dGUuanM/NTIzZiIsIndlYnBhY2s6Ly92dWUzLXdlYnBhY2s1Ly4vbm9kZV9tb2R1bGVzL0BkZWNrLmdsL2NvcmUvZGlzdC9lc20vbGliL2F0dHJpYnV0ZS9nbC11dGlscy5qcz8xN2FkIiwid2VicGFjazovL3Z1ZTMtd2VicGFjazUvLi9ub2RlX21vZHVsZXMvQGRlY2suZ2wvY29yZS9kaXN0L2VzbS9saWIvYXR0cmlidXRlL2RhdGEtY29sdW1uLmpzPzc5N2MiLCJ3ZWJwYWNrOi8vdnVlMy13ZWJwYWNrNS8uL25vZGVfbW9kdWxlcy9AZGVjay5nbC9jb3JlL2Rpc3QvZXNtL2xpYi9hdHRyaWJ1dGUvYXR0cmlidXRlLmpzPzQxNWQiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IF9kZWZpbmVQcm9wZXJ0eSBmcm9tIFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vZGVmaW5lUHJvcGVydHlcIjtcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFNoYWRlckF0dHJpYnV0ZSB7XG4gIGNvbnN0cnVjdG9yKGRhdGFDb2x1bW4sIG9wdHMpIHtcbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJvcHRzXCIsIHZvaWQgMCk7XG5cbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJzb3VyY2VcIiwgdm9pZCAwKTtcblxuICAgIHRoaXMub3B0cyA9IG9wdHM7XG4gICAgdGhpcy5zb3VyY2UgPSBkYXRhQ29sdW1uO1xuICB9XG5cbiAgZ2V0IHZhbHVlKCkge1xuICAgIHJldHVybiB0aGlzLnNvdXJjZS52YWx1ZTtcbiAgfVxuXG4gIGdldFZhbHVlKCkge1xuICAgIGNvbnN0IGJ1ZmZlciA9IHRoaXMuc291cmNlLmdldEJ1ZmZlcigpO1xuICAgIGNvbnN0IGFjY2Vzc29yID0gdGhpcy5nZXRBY2Nlc3NvcigpO1xuXG4gICAgaWYgKGJ1ZmZlcikge1xuICAgICAgcmV0dXJuIFtidWZmZXIsIGFjY2Vzc29yXTtcbiAgICB9XG5cbiAgICBjb25zdCB7XG4gICAgICB2YWx1ZVxuICAgIH0gPSB0aGlzLnNvdXJjZTtcbiAgICBjb25zdCB7XG4gICAgICBzaXplXG4gICAgfSA9IGFjY2Vzc29yO1xuICAgIGxldCBjb25zdGFudFZhbHVlID0gdmFsdWU7XG5cbiAgICBpZiAodmFsdWUgJiYgdmFsdWUubGVuZ3RoICE9PSBzaXplKSB7XG4gICAgICBjb25zdGFudFZhbHVlID0gbmV3IEZsb2F0MzJBcnJheShzaXplKTtcbiAgICAgIGNvbnN0IGluZGV4ID0gYWNjZXNzb3IuZWxlbWVudE9mZnNldCB8fCAwO1xuXG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNpemU7ICsraSkge1xuICAgICAgICBjb25zdGFudFZhbHVlW2ldID0gdmFsdWVbaW5kZXggKyBpXTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gY29uc3RhbnRWYWx1ZTtcbiAgfVxuXG4gIGdldEFjY2Vzc29yKCkge1xuICAgIHJldHVybiB7IC4uLnRoaXMuc291cmNlLmdldEFjY2Vzc29yKCksXG4gICAgICAuLi50aGlzLm9wdHNcbiAgICB9O1xuICB9XG5cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXNoYWRlci1hdHRyaWJ1dGUuanMubWFwIiwiZXhwb3J0IGZ1bmN0aW9uIGdsQXJyYXlGcm9tVHlwZShnbFR5cGUpIHtcbiAgc3dpdGNoIChnbFR5cGUpIHtcbiAgICBjYXNlIDUxMjY6XG4gICAgICByZXR1cm4gRmxvYXQzMkFycmF5O1xuXG4gICAgY2FzZSA1MTMwOlxuICAgICAgcmV0dXJuIEZsb2F0NjRBcnJheTtcblxuICAgIGNhc2UgNTEyMzpcbiAgICBjYXNlIDMzNjM1OlxuICAgIGNhc2UgMzI4MTk6XG4gICAgY2FzZSAzMjgyMDpcbiAgICAgIHJldHVybiBVaW50MTZBcnJheTtcblxuICAgIGNhc2UgNTEyNTpcbiAgICAgIHJldHVybiBVaW50MzJBcnJheTtcblxuICAgIGNhc2UgNTEyMTpcbiAgICAgIHJldHVybiBVaW50OENsYW1wZWRBcnJheTtcblxuICAgIGNhc2UgNTEyMDpcbiAgICAgIHJldHVybiBJbnQ4QXJyYXk7XG5cbiAgICBjYXNlIDUxMjI6XG4gICAgICByZXR1cm4gSW50MTZBcnJheTtcblxuICAgIGNhc2UgNTEyNDpcbiAgICAgIHJldHVybiBJbnQzMkFycmF5O1xuXG4gICAgZGVmYXVsdDpcbiAgICAgIHRocm93IG5ldyBFcnJvcignVW5rbm93biBHTCB0eXBlJyk7XG4gIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWdsLXV0aWxzLmpzLm1hcCIsImltcG9ydCBfZGVmaW5lUHJvcGVydHkgZnJvbSBcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL2RlZmluZVByb3BlcnR5XCI7XG5pbXBvcnQgeyBoYXNGZWF0dXJlLCBGRUFUVVJFUywgQnVmZmVyIH0gZnJvbSAnQGx1bWEuZ2wvY29yZSc7XG5pbXBvcnQgU2hhZGVyQXR0cmlidXRlIGZyb20gJy4vc2hhZGVyLWF0dHJpYnV0ZSc7XG5pbXBvcnQgeyBnbEFycmF5RnJvbVR5cGUgfSBmcm9tICcuL2dsLXV0aWxzJztcbmltcG9ydCB0eXBlZEFycmF5TWFuYWdlciBmcm9tICcuLi8uLi91dGlscy90eXBlZC1hcnJheS1tYW5hZ2VyJztcbmltcG9ydCB7IHRvRG91YmxlUHJlY2lzaW9uQXJyYXkgfSBmcm9tICcuLi8uLi91dGlscy9tYXRoLXV0aWxzJztcbmltcG9ydCBsb2cgZnJvbSAnLi4vLi4vdXRpbHMvbG9nJztcblxuZnVuY3Rpb24gZ2V0U3RyaWRlKGFjY2Vzc29yKSB7XG4gIHJldHVybiBhY2Nlc3Nvci5zdHJpZGUgfHwgYWNjZXNzb3Iuc2l6ZSAqIGFjY2Vzc29yLmJ5dGVzUGVyRWxlbWVudDtcbn1cblxuZnVuY3Rpb24gcmVzb2x2ZVNoYWRlckF0dHJpYnV0ZShiYXNlQWNjZXNzb3IsIHNoYWRlckF0dHJpYnV0ZU9wdGlvbnMpIHtcbiAgaWYgKHNoYWRlckF0dHJpYnV0ZU9wdGlvbnMub2Zmc2V0KSB7XG4gICAgbG9nLnJlbW92ZWQoJ3NoYWRlckF0dHJpYnV0ZS5vZmZzZXQnLCAndmVydGV4T2Zmc2V0LCBlbGVtZW50T2Zmc2V0JykoKTtcbiAgfVxuXG4gIGNvbnN0IHN0cmlkZSA9IGdldFN0cmlkZShiYXNlQWNjZXNzb3IpO1xuICBjb25zdCB2ZXJ0ZXhPZmZzZXQgPSBzaGFkZXJBdHRyaWJ1dGVPcHRpb25zLnZlcnRleE9mZnNldCAhPT0gdW5kZWZpbmVkID8gc2hhZGVyQXR0cmlidXRlT3B0aW9ucy52ZXJ0ZXhPZmZzZXQgOiBiYXNlQWNjZXNzb3IudmVydGV4T2Zmc2V0IHx8IDA7XG4gIGNvbnN0IGVsZW1lbnRPZmZzZXQgPSBzaGFkZXJBdHRyaWJ1dGVPcHRpb25zLmVsZW1lbnRPZmZzZXQgfHwgMDtcbiAgY29uc3Qgb2Zmc2V0ID0gdmVydGV4T2Zmc2V0ICogc3RyaWRlICsgZWxlbWVudE9mZnNldCAqIGJhc2VBY2Nlc3Nvci5ieXRlc1BlckVsZW1lbnQgKyAoYmFzZUFjY2Vzc29yLm9mZnNldCB8fCAwKTtcbiAgcmV0dXJuIHsgLi4uc2hhZGVyQXR0cmlidXRlT3B0aW9ucyxcbiAgICBvZmZzZXQsXG4gICAgc3RyaWRlXG4gIH07XG59XG5cbmZ1bmN0aW9uIHJlc29sdmVEb3VibGVQcmVjaXNpb25TaGFkZXJBdHRyaWJ1dGVzKGJhc2VBY2Nlc3Nvciwgc2hhZGVyQXR0cmlidXRlT3B0aW9ucykge1xuICBjb25zdCByZXNvbHZlZE9wdGlvbnMgPSByZXNvbHZlU2hhZGVyQXR0cmlidXRlKGJhc2VBY2Nlc3Nvciwgc2hhZGVyQXR0cmlidXRlT3B0aW9ucyk7XG4gIHJldHVybiB7XG4gICAgaGlnaDogcmVzb2x2ZWRPcHRpb25zLFxuICAgIGxvdzogeyAuLi5yZXNvbHZlZE9wdGlvbnMsXG4gICAgICBvZmZzZXQ6IHJlc29sdmVkT3B0aW9ucy5vZmZzZXQgKyBiYXNlQWNjZXNzb3Iuc2l6ZSAqIDRcbiAgICB9XG4gIH07XG59XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIERhdGFDb2x1bW4ge1xuICBjb25zdHJ1Y3RvcihnbCwgb3B0cywgc3RhdGUpIHtcbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJnbFwiLCB2b2lkIDApO1xuXG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwiaWRcIiwgdm9pZCAwKTtcblxuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInNpemVcIiwgdm9pZCAwKTtcblxuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInNldHRpbmdzXCIsIHZvaWQgMCk7XG5cbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJ2YWx1ZVwiLCB2b2lkIDApO1xuXG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwiZG91YmxlUHJlY2lzaW9uXCIsIHZvaWQgMCk7XG5cbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJfYnVmZmVyXCIsIHZvaWQgMCk7XG5cbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJzdGF0ZVwiLCB2b2lkIDApO1xuXG4gICAgdGhpcy5nbCA9IGdsO1xuICAgIHRoaXMuaWQgPSBvcHRzLmlkIHx8ICcnO1xuICAgIHRoaXMuc2l6ZSA9IG9wdHMuc2l6ZSB8fCAxO1xuICAgIGNvbnN0IGxvZ2ljYWxUeXBlID0gb3B0cy5sb2dpY2FsVHlwZSB8fCBvcHRzLnR5cGU7XG4gICAgY29uc3QgZG91YmxlUHJlY2lzaW9uID0gbG9naWNhbFR5cGUgPT09IDUxMzA7XG4gICAgbGV0IHtcbiAgICAgIGRlZmF1bHRWYWx1ZVxuICAgIH0gPSBvcHRzO1xuICAgIGRlZmF1bHRWYWx1ZSA9IE51bWJlci5pc0Zpbml0ZShkZWZhdWx0VmFsdWUpID8gW2RlZmF1bHRWYWx1ZV0gOiBkZWZhdWx0VmFsdWUgfHwgbmV3IEFycmF5KHRoaXMuc2l6ZSkuZmlsbCgwKTtcbiAgICBsZXQgYnVmZmVyVHlwZTtcblxuICAgIGlmIChkb3VibGVQcmVjaXNpb24pIHtcbiAgICAgIGJ1ZmZlclR5cGUgPSA1MTI2O1xuICAgIH0gZWxzZSBpZiAoIWxvZ2ljYWxUeXBlICYmIG9wdHMuaXNJbmRleGVkKSB7XG4gICAgICBidWZmZXJUeXBlID0gZ2wgJiYgaGFzRmVhdHVyZShnbCwgRkVBVFVSRVMuRUxFTUVOVF9JTkRFWF9VSU5UMzIpID8gNTEyNSA6IDUxMjM7XG4gICAgfSBlbHNlIHtcbiAgICAgIGJ1ZmZlclR5cGUgPSBsb2dpY2FsVHlwZSB8fCA1MTI2O1xuICAgIH1cblxuICAgIGxldCBkZWZhdWx0VHlwZSA9IGdsQXJyYXlGcm9tVHlwZShsb2dpY2FsVHlwZSB8fCBidWZmZXJUeXBlIHx8IDUxMjYpO1xuICAgIHRoaXMuZG91YmxlUHJlY2lzaW9uID0gZG91YmxlUHJlY2lzaW9uO1xuXG4gICAgaWYgKGRvdWJsZVByZWNpc2lvbiAmJiBvcHRzLmZwNjQgPT09IGZhbHNlKSB7XG4gICAgICBkZWZhdWx0VHlwZSA9IEZsb2F0MzJBcnJheTtcbiAgICB9XG5cbiAgICB0aGlzLnZhbHVlID0gbnVsbDtcbiAgICB0aGlzLnNldHRpbmdzID0geyAuLi5vcHRzLFxuICAgICAgZGVmYXVsdFR5cGUsXG4gICAgICBkZWZhdWx0VmFsdWU6IGRlZmF1bHRWYWx1ZSxcbiAgICAgIGxvZ2ljYWxUeXBlLFxuICAgICAgdHlwZTogYnVmZmVyVHlwZSxcbiAgICAgIHNpemU6IHRoaXMuc2l6ZSxcbiAgICAgIGJ5dGVzUGVyRWxlbWVudDogZGVmYXVsdFR5cGUuQllURVNfUEVSX0VMRU1FTlRcbiAgICB9O1xuICAgIHRoaXMuc3RhdGUgPSB7IC4uLnN0YXRlLFxuICAgICAgZXh0ZXJuYWxCdWZmZXI6IG51bGwsXG4gICAgICBidWZmZXJBY2Nlc3NvcjogdGhpcy5zZXR0aW5ncyxcbiAgICAgIGFsbG9jYXRlZFZhbHVlOiBudWxsLFxuICAgICAgbnVtSW5zdGFuY2VzOiAwLFxuICAgICAgYm91bmRzOiBudWxsLFxuICAgICAgY29uc3RhbnQ6IGZhbHNlXG4gICAgfTtcbiAgICB0aGlzLl9idWZmZXIgPSBudWxsO1xuICB9XG5cbiAgZ2V0IGlzQ29uc3RhbnQoKSB7XG4gICAgcmV0dXJuIHRoaXMuc3RhdGUuY29uc3RhbnQ7XG4gIH1cblxuICBnZXQgYnVmZmVyKCkge1xuICAgIGlmICghdGhpcy5fYnVmZmVyKSB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIGlzSW5kZXhlZCxcbiAgICAgICAgdHlwZVxuICAgICAgfSA9IHRoaXMuc2V0dGluZ3M7XG4gICAgICB0aGlzLl9idWZmZXIgPSBuZXcgQnVmZmVyKHRoaXMuZ2wsIHtcbiAgICAgICAgaWQ6IHRoaXMuaWQsXG4gICAgICAgIHRhcmdldDogaXNJbmRleGVkID8gMzQ5NjMgOiAzNDk2MixcbiAgICAgICAgYWNjZXNzb3I6IHtcbiAgICAgICAgICB0eXBlXG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLl9idWZmZXI7XG4gIH1cblxuICBnZXQgYnl0ZU9mZnNldCgpIHtcbiAgICBjb25zdCBhY2Nlc3NvciA9IHRoaXMuZ2V0QWNjZXNzb3IoKTtcblxuICAgIGlmIChhY2Nlc3Nvci52ZXJ0ZXhPZmZzZXQpIHtcbiAgICAgIHJldHVybiBhY2Nlc3Nvci52ZXJ0ZXhPZmZzZXQgKiBnZXRTdHJpZGUoYWNjZXNzb3IpO1xuICAgIH1cblxuICAgIHJldHVybiAwO1xuICB9XG5cbiAgZ2V0IG51bUluc3RhbmNlcygpIHtcbiAgICByZXR1cm4gdGhpcy5zdGF0ZS5udW1JbnN0YW5jZXM7XG4gIH1cblxuICBzZXQgbnVtSW5zdGFuY2VzKG4pIHtcbiAgICB0aGlzLnN0YXRlLm51bUluc3RhbmNlcyA9IG47XG4gIH1cblxuICBkZWxldGUoKSB7XG4gICAgaWYgKHRoaXMuX2J1ZmZlcikge1xuICAgICAgdGhpcy5fYnVmZmVyLmRlbGV0ZSgpO1xuXG4gICAgICB0aGlzLl9idWZmZXIgPSBudWxsO1xuICAgIH1cblxuICAgIHR5cGVkQXJyYXlNYW5hZ2VyLnJlbGVhc2UodGhpcy5zdGF0ZS5hbGxvY2F0ZWRWYWx1ZSk7XG4gIH1cblxuICBnZXRTaGFkZXJBdHRyaWJ1dGVzKGlkLCBvcHRpb25zKSB7XG4gICAgaWYgKHRoaXMuZG91YmxlUHJlY2lzaW9uKSB7XG4gICAgICBjb25zdCBzaGFkZXJBdHRyaWJ1dGVzID0ge307XG4gICAgICBjb25zdCBpc0J1ZmZlcjY0Qml0ID0gdGhpcy52YWx1ZSBpbnN0YW5jZW9mIEZsb2F0NjRBcnJheTtcbiAgICAgIGNvbnN0IGRvdWJsZVNoYWRlckF0dHJpYnV0ZURlZnMgPSByZXNvbHZlRG91YmxlUHJlY2lzaW9uU2hhZGVyQXR0cmlidXRlcyh0aGlzLmdldEFjY2Vzc29yKCksIG9wdGlvbnMgfHwge30pO1xuICAgICAgc2hhZGVyQXR0cmlidXRlc1tpZF0gPSBuZXcgU2hhZGVyQXR0cmlidXRlKHRoaXMsIGRvdWJsZVNoYWRlckF0dHJpYnV0ZURlZnMuaGlnaCk7XG4gICAgICBzaGFkZXJBdHRyaWJ1dGVzW1wiXCIuY29uY2F0KGlkLCBcIjY0TG93XCIpXSA9IGlzQnVmZmVyNjRCaXQgPyBuZXcgU2hhZGVyQXR0cmlidXRlKHRoaXMsIGRvdWJsZVNoYWRlckF0dHJpYnV0ZURlZnMubG93KSA6IG5ldyBGbG9hdDMyQXJyYXkodGhpcy5zaXplKTtcbiAgICAgIHJldHVybiBzaGFkZXJBdHRyaWJ1dGVzO1xuICAgIH1cblxuICAgIGlmIChvcHRpb25zKSB7XG4gICAgICBjb25zdCBzaGFkZXJBdHRyaWJ1dGVEZWYgPSByZXNvbHZlU2hhZGVyQXR0cmlidXRlKHRoaXMuZ2V0QWNjZXNzb3IoKSwgb3B0aW9ucyk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBbaWRdOiBuZXcgU2hhZGVyQXR0cmlidXRlKHRoaXMsIHNoYWRlckF0dHJpYnV0ZURlZilcbiAgICAgIH07XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIFtpZF06IHRoaXNcbiAgICB9O1xuICB9XG5cbiAgZ2V0QnVmZmVyKCkge1xuICAgIGlmICh0aGlzLnN0YXRlLmNvbnN0YW50KSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5zdGF0ZS5leHRlcm5hbEJ1ZmZlciB8fCB0aGlzLl9idWZmZXI7XG4gIH1cblxuICBnZXRWYWx1ZSgpIHtcbiAgICBpZiAodGhpcy5zdGF0ZS5jb25zdGFudCkge1xuICAgICAgcmV0dXJuIHRoaXMudmFsdWU7XG4gICAgfVxuXG4gICAgcmV0dXJuIFt0aGlzLmdldEJ1ZmZlcigpLCB0aGlzLmdldEFjY2Vzc29yKCldO1xuICB9XG5cbiAgZ2V0QWNjZXNzb3IoKSB7XG4gICAgcmV0dXJuIHRoaXMuc3RhdGUuYnVmZmVyQWNjZXNzb3I7XG4gIH1cblxuICBnZXRCb3VuZHMoKSB7XG4gICAgaWYgKHRoaXMuc3RhdGUuYm91bmRzKSB7XG4gICAgICByZXR1cm4gdGhpcy5zdGF0ZS5ib3VuZHM7XG4gICAgfVxuXG4gICAgbGV0IHJlc3VsdCA9IG51bGw7XG5cbiAgICBpZiAodGhpcy5zdGF0ZS5jb25zdGFudCAmJiB0aGlzLnZhbHVlKSB7XG4gICAgICBjb25zdCBtaW4gPSBBcnJheS5mcm9tKHRoaXMudmFsdWUpO1xuICAgICAgcmVzdWx0ID0gW21pbiwgbWluXTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3Qge1xuICAgICAgICB2YWx1ZSxcbiAgICAgICAgbnVtSW5zdGFuY2VzLFxuICAgICAgICBzaXplXG4gICAgICB9ID0gdGhpcztcbiAgICAgIGNvbnN0IGxlbiA9IG51bUluc3RhbmNlcyAqIHNpemU7XG5cbiAgICAgIGlmICh2YWx1ZSAmJiBsZW4gJiYgdmFsdWUubGVuZ3RoID49IGxlbikge1xuICAgICAgICBjb25zdCBtaW4gPSBuZXcgQXJyYXkoc2l6ZSkuZmlsbChJbmZpbml0eSk7XG4gICAgICAgIGNvbnN0IG1heCA9IG5ldyBBcnJheShzaXplKS5maWxsKC1JbmZpbml0eSk7XG5cbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW47KSB7XG4gICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBzaXplOyBqKyspIHtcbiAgICAgICAgICAgIGNvbnN0IHYgPSB2YWx1ZVtpKytdO1xuICAgICAgICAgICAgaWYgKHYgPCBtaW5bal0pIG1pbltqXSA9IHY7XG4gICAgICAgICAgICBpZiAodiA+IG1heFtqXSkgbWF4W2pdID0gdjtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXN1bHQgPSBbbWluLCBtYXhdO1xuICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMuc3RhdGUuYm91bmRzID0gcmVzdWx0O1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICBzZXREYXRhKGRhdGEpIHtcbiAgICBjb25zdCB7XG4gICAgICBzdGF0ZVxuICAgIH0gPSB0aGlzO1xuICAgIGxldCBvcHRzO1xuXG4gICAgaWYgKEFycmF5QnVmZmVyLmlzVmlldyhkYXRhKSkge1xuICAgICAgb3B0cyA9IHtcbiAgICAgICAgdmFsdWU6IGRhdGFcbiAgICAgIH07XG4gICAgfSBlbHNlIGlmIChkYXRhIGluc3RhbmNlb2YgQnVmZmVyKSB7XG4gICAgICBvcHRzID0ge1xuICAgICAgICBidWZmZXI6IGRhdGFcbiAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIG9wdHMgPSBkYXRhO1xuICAgIH1cblxuICAgIGNvbnN0IGFjY2Vzc29yID0geyAuLi50aGlzLnNldHRpbmdzLFxuICAgICAgLi4ub3B0c1xuICAgIH07XG4gICAgc3RhdGUuYnVmZmVyQWNjZXNzb3IgPSBhY2Nlc3NvcjtcbiAgICBzdGF0ZS5ib3VuZHMgPSBudWxsO1xuXG4gICAgaWYgKG9wdHMuY29uc3RhbnQpIHtcbiAgICAgIGxldCB2YWx1ZSA9IG9wdHMudmFsdWU7XG4gICAgICB2YWx1ZSA9IHRoaXMuX25vcm1hbGl6ZVZhbHVlKHZhbHVlLCBbXSwgMCk7XG5cbiAgICAgIGlmICh0aGlzLnNldHRpbmdzLm5vcm1hbGl6ZWQpIHtcbiAgICAgICAgdmFsdWUgPSB0aGlzLm5vcm1hbGl6ZUNvbnN0YW50KHZhbHVlKTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgaGFzQ2hhbmdlZCA9ICFzdGF0ZS5jb25zdGFudCB8fCAhdGhpcy5fYXJlVmFsdWVzRXF1YWwodmFsdWUsIHRoaXMudmFsdWUpO1xuXG4gICAgICBpZiAoIWhhc0NoYW5nZWQpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuXG4gICAgICBzdGF0ZS5leHRlcm5hbEJ1ZmZlciA9IG51bGw7XG4gICAgICBzdGF0ZS5jb25zdGFudCA9IHRydWU7XG4gICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgfSBlbHNlIGlmIChvcHRzLmJ1ZmZlcikge1xuICAgICAgY29uc3QgYnVmZmVyID0gb3B0cy5idWZmZXI7XG4gICAgICBzdGF0ZS5leHRlcm5hbEJ1ZmZlciA9IGJ1ZmZlcjtcbiAgICAgIHN0YXRlLmNvbnN0YW50ID0gZmFsc2U7XG4gICAgICB0aGlzLnZhbHVlID0gb3B0cy52YWx1ZSB8fCBudWxsO1xuICAgICAgY29uc3QgaXNCdWZmZXI2NEJpdCA9IG9wdHMudmFsdWUgaW5zdGFuY2VvZiBGbG9hdDY0QXJyYXk7XG4gICAgICBhY2Nlc3Nvci50eXBlID0gb3B0cy50eXBlIHx8IGJ1ZmZlci5hY2Nlc3Nvci50eXBlO1xuICAgICAgYWNjZXNzb3IuYnl0ZXNQZXJFbGVtZW50ID0gYnVmZmVyLmFjY2Vzc29yLkJZVEVTX1BFUl9FTEVNRU5UICogKGlzQnVmZmVyNjRCaXQgPyAyIDogMSk7XG4gICAgICBhY2Nlc3Nvci5zdHJpZGUgPSBnZXRTdHJpZGUoYWNjZXNzb3IpO1xuICAgIH0gZWxzZSBpZiAob3B0cy52YWx1ZSkge1xuICAgICAgdGhpcy5fY2hlY2tFeHRlcm5hbEJ1ZmZlcihvcHRzKTtcblxuICAgICAgbGV0IHZhbHVlID0gb3B0cy52YWx1ZTtcbiAgICAgIHN0YXRlLmV4dGVybmFsQnVmZmVyID0gbnVsbDtcbiAgICAgIHN0YXRlLmNvbnN0YW50ID0gZmFsc2U7XG4gICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgICBhY2Nlc3Nvci5ieXRlc1BlckVsZW1lbnQgPSB2YWx1ZS5CWVRFU19QRVJfRUxFTUVOVDtcbiAgICAgIGFjY2Vzc29yLnN0cmlkZSA9IGdldFN0cmlkZShhY2Nlc3Nvcik7XG4gICAgICBjb25zdCB7XG4gICAgICAgIGJ1ZmZlcixcbiAgICAgICAgYnl0ZU9mZnNldFxuICAgICAgfSA9IHRoaXM7XG5cbiAgICAgIGlmICh0aGlzLmRvdWJsZVByZWNpc2lvbiAmJiB2YWx1ZSBpbnN0YW5jZW9mIEZsb2F0NjRBcnJheSkge1xuICAgICAgICB2YWx1ZSA9IHRvRG91YmxlUHJlY2lzaW9uQXJyYXkodmFsdWUsIGFjY2Vzc29yKTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgcmVxdWlyZWRCdWZmZXJTaXplID0gdmFsdWUuYnl0ZUxlbmd0aCArIGJ5dGVPZmZzZXQgKyBhY2Nlc3Nvci5zdHJpZGUgKiAyO1xuXG4gICAgICBpZiAoYnVmZmVyLmJ5dGVMZW5ndGggPCByZXF1aXJlZEJ1ZmZlclNpemUpIHtcbiAgICAgICAgYnVmZmVyLnJlYWxsb2NhdGUocmVxdWlyZWRCdWZmZXJTaXplKTtcbiAgICAgIH1cblxuICAgICAgYnVmZmVyLnNldEFjY2Vzc29yKG51bGwpO1xuICAgICAgYnVmZmVyLnN1YkRhdGEoe1xuICAgICAgICBkYXRhOiB2YWx1ZSxcbiAgICAgICAgb2Zmc2V0OiBieXRlT2Zmc2V0XG4gICAgICB9KTtcbiAgICAgIGFjY2Vzc29yLnR5cGUgPSBvcHRzLnR5cGUgfHwgYnVmZmVyLmFjY2Vzc29yLnR5cGU7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICB1cGRhdGVTdWJCdWZmZXIob3B0cyA9IHt9KSB7XG4gICAgdGhpcy5zdGF0ZS5ib3VuZHMgPSBudWxsO1xuICAgIGNvbnN0IHZhbHVlID0gdGhpcy52YWx1ZTtcbiAgICBjb25zdCB7XG4gICAgICBzdGFydE9mZnNldCA9IDAsXG4gICAgICBlbmRPZmZzZXRcbiAgICB9ID0gb3B0cztcbiAgICB0aGlzLmJ1ZmZlci5zdWJEYXRhKHtcbiAgICAgIGRhdGE6IHRoaXMuZG91YmxlUHJlY2lzaW9uICYmIHZhbHVlIGluc3RhbmNlb2YgRmxvYXQ2NEFycmF5ID8gdG9Eb3VibGVQcmVjaXNpb25BcnJheSh2YWx1ZSwge1xuICAgICAgICBzaXplOiB0aGlzLnNpemUsXG4gICAgICAgIHN0YXJ0SW5kZXg6IHN0YXJ0T2Zmc2V0LFxuICAgICAgICBlbmRJbmRleDogZW5kT2Zmc2V0XG4gICAgICB9KSA6IHZhbHVlLnN1YmFycmF5KHN0YXJ0T2Zmc2V0LCBlbmRPZmZzZXQpLFxuICAgICAgb2Zmc2V0OiBzdGFydE9mZnNldCAqIHZhbHVlLkJZVEVTX1BFUl9FTEVNRU5UICsgdGhpcy5ieXRlT2Zmc2V0XG4gICAgfSk7XG4gIH1cblxuICBhbGxvY2F0ZShudW1JbnN0YW5jZXMsIGNvcHkgPSBmYWxzZSkge1xuICAgIGNvbnN0IHtcbiAgICAgIHN0YXRlXG4gICAgfSA9IHRoaXM7XG4gICAgY29uc3Qgb2xkVmFsdWUgPSBzdGF0ZS5hbGxvY2F0ZWRWYWx1ZTtcbiAgICBjb25zdCB2YWx1ZSA9IHR5cGVkQXJyYXlNYW5hZ2VyLmFsbG9jYXRlKG9sZFZhbHVlLCBudW1JbnN0YW5jZXMgKyAxLCB7XG4gICAgICBzaXplOiB0aGlzLnNpemUsXG4gICAgICB0eXBlOiB0aGlzLnNldHRpbmdzLmRlZmF1bHRUeXBlLFxuICAgICAgY29weVxuICAgIH0pO1xuICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICBjb25zdCB7XG4gICAgICBidWZmZXIsXG4gICAgICBieXRlT2Zmc2V0XG4gICAgfSA9IHRoaXM7XG5cbiAgICBpZiAoYnVmZmVyLmJ5dGVMZW5ndGggPCB2YWx1ZS5ieXRlTGVuZ3RoICsgYnl0ZU9mZnNldCkge1xuICAgICAgYnVmZmVyLnJlYWxsb2NhdGUodmFsdWUuYnl0ZUxlbmd0aCArIGJ5dGVPZmZzZXQpO1xuXG4gICAgICBpZiAoY29weSAmJiBvbGRWYWx1ZSkge1xuICAgICAgICBidWZmZXIuc3ViRGF0YSh7XG4gICAgICAgICAgZGF0YTogb2xkVmFsdWUgaW5zdGFuY2VvZiBGbG9hdDY0QXJyYXkgPyB0b0RvdWJsZVByZWNpc2lvbkFycmF5KG9sZFZhbHVlLCB0aGlzKSA6IG9sZFZhbHVlLFxuICAgICAgICAgIG9mZnNldDogYnl0ZU9mZnNldFxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBzdGF0ZS5hbGxvY2F0ZWRWYWx1ZSA9IHZhbHVlO1xuICAgIHN0YXRlLmNvbnN0YW50ID0gZmFsc2U7XG4gICAgc3RhdGUuZXh0ZXJuYWxCdWZmZXIgPSBudWxsO1xuICAgIHN0YXRlLmJ1ZmZlckFjY2Vzc29yID0gdGhpcy5zZXR0aW5ncztcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIF9jaGVja0V4dGVybmFsQnVmZmVyKG9wdHMpIHtcbiAgICBjb25zdCB7XG4gICAgICB2YWx1ZVxuICAgIH0gPSBvcHRzO1xuXG4gICAgaWYgKCFBcnJheUJ1ZmZlci5pc1ZpZXcodmFsdWUpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJBdHRyaWJ1dGUgXCIuY29uY2F0KHRoaXMuaWQsIFwiIHZhbHVlIGlzIG5vdCBUeXBlZEFycmF5XCIpKTtcbiAgICB9XG5cbiAgICBjb25zdCBBcnJheVR5cGUgPSB0aGlzLnNldHRpbmdzLmRlZmF1bHRUeXBlO1xuICAgIGxldCBpbGxlZ2FsQXJyYXlUeXBlID0gZmFsc2U7XG5cbiAgICBpZiAodGhpcy5kb3VibGVQcmVjaXNpb24pIHtcbiAgICAgIGlsbGVnYWxBcnJheVR5cGUgPSB2YWx1ZS5CWVRFU19QRVJfRUxFTUVOVCA8IDQ7XG4gICAgfVxuXG4gICAgaWYgKGlsbGVnYWxBcnJheVR5cGUpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkF0dHJpYnV0ZSBcIi5jb25jYXQodGhpcy5pZCwgXCIgZG9lcyBub3Qgc3VwcG9ydCBcIikuY29uY2F0KHZhbHVlLmNvbnN0cnVjdG9yLm5hbWUpKTtcbiAgICB9XG5cbiAgICBpZiAoISh2YWx1ZSBpbnN0YW5jZW9mIEFycmF5VHlwZSkgJiYgdGhpcy5zZXR0aW5ncy5ub3JtYWxpemVkICYmICEoJ25vcm1hbGl6ZWQnIGluIG9wdHMpKSB7XG4gICAgICBsb2cud2FybihcIkF0dHJpYnV0ZSBcIi5jb25jYXQodGhpcy5pZCwgXCIgaXMgbm9ybWFsaXplZFwiKSkoKTtcbiAgICB9XG4gIH1cblxuICBub3JtYWxpemVDb25zdGFudCh2YWx1ZSkge1xuICAgIHN3aXRjaCAodGhpcy5zZXR0aW5ncy50eXBlKSB7XG4gICAgICBjYXNlIDUxMjA6XG4gICAgICAgIHJldHVybiBuZXcgRmxvYXQzMkFycmF5KHZhbHVlKS5tYXAoeCA9PiAoeCArIDEyOCkgLyAyNTUgKiAyIC0gMSk7XG5cbiAgICAgIGNhc2UgNTEyMjpcbiAgICAgICAgcmV0dXJuIG5ldyBGbG9hdDMyQXJyYXkodmFsdWUpLm1hcCh4ID0+ICh4ICsgMzI3NjgpIC8gNjU1MzUgKiAyIC0gMSk7XG5cbiAgICAgIGNhc2UgNTEyMTpcbiAgICAgICAgcmV0dXJuIG5ldyBGbG9hdDMyQXJyYXkodmFsdWUpLm1hcCh4ID0+IHggLyAyNTUpO1xuXG4gICAgICBjYXNlIDUxMjM6XG4gICAgICAgIHJldHVybiBuZXcgRmxvYXQzMkFycmF5KHZhbHVlKS5tYXAoeCA9PiB4IC8gNjU1MzUpO1xuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuICB9XG5cbiAgX25vcm1hbGl6ZVZhbHVlKHZhbHVlLCBvdXQsIHN0YXJ0KSB7XG4gICAgY29uc3Qge1xuICAgICAgZGVmYXVsdFZhbHVlLFxuICAgICAgc2l6ZVxuICAgIH0gPSB0aGlzLnNldHRpbmdzO1xuXG4gICAgaWYgKE51bWJlci5pc0Zpbml0ZSh2YWx1ZSkpIHtcbiAgICAgIG91dFtzdGFydF0gPSB2YWx1ZTtcbiAgICAgIHJldHVybiBvdXQ7XG4gICAgfVxuXG4gICAgaWYgKCF2YWx1ZSkge1xuICAgICAgbGV0IGkgPSBzaXplO1xuXG4gICAgICB3aGlsZSAoLS1pID49IDApIHtcbiAgICAgICAgb3V0W3N0YXJ0ICsgaV0gPSBkZWZhdWx0VmFsdWVbaV07XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBvdXQ7XG4gICAgfVxuXG4gICAgc3dpdGNoIChzaXplKSB7XG4gICAgICBjYXNlIDQ6XG4gICAgICAgIG91dFtzdGFydCArIDNdID0gTnVtYmVyLmlzRmluaXRlKHZhbHVlWzNdKSA/IHZhbHVlWzNdIDogZGVmYXVsdFZhbHVlWzNdO1xuXG4gICAgICBjYXNlIDM6XG4gICAgICAgIG91dFtzdGFydCArIDJdID0gTnVtYmVyLmlzRmluaXRlKHZhbHVlWzJdKSA/IHZhbHVlWzJdIDogZGVmYXVsdFZhbHVlWzJdO1xuXG4gICAgICBjYXNlIDI6XG4gICAgICAgIG91dFtzdGFydCArIDFdID0gTnVtYmVyLmlzRmluaXRlKHZhbHVlWzFdKSA/IHZhbHVlWzFdIDogZGVmYXVsdFZhbHVlWzFdO1xuXG4gICAgICBjYXNlIDE6XG4gICAgICAgIG91dFtzdGFydCArIDBdID0gTnVtYmVyLmlzRmluaXRlKHZhbHVlWzBdKSA/IHZhbHVlWzBdIDogZGVmYXVsdFZhbHVlWzBdO1xuICAgICAgICBicmVhaztcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgbGV0IGkgPSBzaXplO1xuXG4gICAgICAgIHdoaWxlICgtLWkgPj0gMCkge1xuICAgICAgICAgIG91dFtzdGFydCArIGldID0gTnVtYmVyLmlzRmluaXRlKHZhbHVlW2ldKSA/IHZhbHVlW2ldIDogZGVmYXVsdFZhbHVlW2ldO1xuICAgICAgICB9XG5cbiAgICB9XG5cbiAgICByZXR1cm4gb3V0O1xuICB9XG5cbiAgX2FyZVZhbHVlc0VxdWFsKHZhbHVlMSwgdmFsdWUyKSB7XG4gICAgaWYgKCF2YWx1ZTEgfHwgIXZhbHVlMikge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGNvbnN0IHtcbiAgICAgIHNpemVcbiAgICB9ID0gdGhpcztcblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc2l6ZTsgaSsrKSB7XG4gICAgICBpZiAodmFsdWUxW2ldICE9PSB2YWx1ZTJbaV0pIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRhdGEtY29sdW1uLmpzLm1hcCIsImltcG9ydCBfZGVmaW5lUHJvcGVydHkgZnJvbSBcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL2RlZmluZVByb3BlcnR5XCI7XG5pbXBvcnQgRGF0YUNvbHVtbiBmcm9tICcuL2RhdGEtY29sdW1uJztcbmltcG9ydCBhc3NlcnQgZnJvbSAnLi4vLi4vdXRpbHMvYXNzZXJ0JztcbmltcG9ydCB7IGNyZWF0ZUl0ZXJhYmxlLCBnZXRBY2Nlc3NvckZyb21CdWZmZXIgfSBmcm9tICcuLi8uLi91dGlscy9pdGVyYWJsZS11dGlscyc7XG5pbXBvcnQgeyBmaWxsQXJyYXkgfSBmcm9tICcuLi8uLi91dGlscy9mbGF0dGVuJztcbmltcG9ydCAqIGFzIHJhbmdlIGZyb20gJy4uLy4uL3V0aWxzL3JhbmdlJztcbmltcG9ydCB7IG5vcm1hbGl6ZVRyYW5zaXRpb25TZXR0aW5ncyB9IGZyb20gJy4vYXR0cmlidXRlLXRyYW5zaXRpb24tdXRpbHMnO1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQXR0cmlidXRlIGV4dGVuZHMgRGF0YUNvbHVtbiB7XG4gIGNvbnN0cnVjdG9yKGdsLCBvcHRzKSB7XG4gICAgc3VwZXIoZ2wsIG9wdHMsIHtcbiAgICAgIHN0YXJ0SW5kaWNlczogbnVsbCxcbiAgICAgIGxhc3RFeHRlcm5hbEJ1ZmZlcjogbnVsbCxcbiAgICAgIGJpbmFyeVZhbHVlOiBudWxsLFxuICAgICAgYmluYXJ5QWNjZXNzb3I6IG51bGwsXG4gICAgICBuZWVkc1VwZGF0ZTogdHJ1ZSxcbiAgICAgIG5lZWRzUmVkcmF3OiBmYWxzZSxcbiAgICAgIHVwZGF0ZVJhbmdlczogcmFuZ2UuRlVMTFxuICAgIH0pO1xuXG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwiY29uc3RhbnRcIiwgZmFsc2UpO1xuXG4gICAgdGhpcy5zZXR0aW5ncy51cGRhdGUgPSBvcHRzLnVwZGF0ZSB8fCAob3B0cy5hY2Nlc3NvciA/IHRoaXMuX2F1dG9VcGRhdGVyIDogdW5kZWZpbmVkKTtcbiAgICBPYmplY3Quc2VhbCh0aGlzLnNldHRpbmdzKTtcbiAgICBPYmplY3Quc2VhbCh0aGlzLnN0YXRlKTtcblxuICAgIHRoaXMuX3ZhbGlkYXRlQXR0cmlidXRlVXBkYXRlcnMoKTtcbiAgfVxuXG4gIGdldCBzdGFydEluZGljZXMoKSB7XG4gICAgcmV0dXJuIHRoaXMuc3RhdGUuc3RhcnRJbmRpY2VzO1xuICB9XG5cbiAgc2V0IHN0YXJ0SW5kaWNlcyhsYXlvdXQpIHtcbiAgICB0aGlzLnN0YXRlLnN0YXJ0SW5kaWNlcyA9IGxheW91dDtcbiAgfVxuXG4gIG5lZWRzVXBkYXRlKCkge1xuICAgIHJldHVybiB0aGlzLnN0YXRlLm5lZWRzVXBkYXRlO1xuICB9XG5cbiAgbmVlZHNSZWRyYXcoe1xuICAgIGNsZWFyQ2hhbmdlZEZsYWdzID0gZmFsc2VcbiAgfSA9IHt9KSB7XG4gICAgY29uc3QgbmVlZHNSZWRyYXcgPSB0aGlzLnN0YXRlLm5lZWRzUmVkcmF3O1xuICAgIHRoaXMuc3RhdGUubmVlZHNSZWRyYXcgPSBuZWVkc1JlZHJhdyAmJiAhY2xlYXJDaGFuZ2VkRmxhZ3M7XG4gICAgcmV0dXJuIG5lZWRzUmVkcmF3O1xuICB9XG5cbiAgZ2V0VXBkYXRlVHJpZ2dlcnMoKSB7XG4gICAgY29uc3Qge1xuICAgICAgYWNjZXNzb3JcbiAgICB9ID0gdGhpcy5zZXR0aW5ncztcbiAgICByZXR1cm4gW3RoaXMuaWRdLmNvbmNhdCh0eXBlb2YgYWNjZXNzb3IgIT09ICdmdW5jdGlvbicgJiYgYWNjZXNzb3IgfHwgW10pO1xuICB9XG5cbiAgc3VwcG9ydHNUcmFuc2l0aW9uKCkge1xuICAgIHJldHVybiBCb29sZWFuKHRoaXMuc2V0dGluZ3MudHJhbnNpdGlvbik7XG4gIH1cblxuICBnZXRUcmFuc2l0aW9uU2V0dGluZyhvcHRzKSB7XG4gICAgaWYgKCFvcHRzIHx8ICF0aGlzLnN1cHBvcnRzVHJhbnNpdGlvbigpKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICBjb25zdCB7XG4gICAgICBhY2Nlc3NvclxuICAgIH0gPSB0aGlzLnNldHRpbmdzO1xuICAgIGNvbnN0IGxheWVyU2V0dGluZ3MgPSB0aGlzLnNldHRpbmdzLnRyYW5zaXRpb247XG4gICAgY29uc3QgdXNlclNldHRpbmdzID0gQXJyYXkuaXNBcnJheShhY2Nlc3NvcikgPyBvcHRzW2FjY2Vzc29yLmZpbmQoYSA9PiBvcHRzW2FdKV0gOiBvcHRzW2FjY2Vzc29yXTtcbiAgICByZXR1cm4gbm9ybWFsaXplVHJhbnNpdGlvblNldHRpbmdzKHVzZXJTZXR0aW5ncywgbGF5ZXJTZXR0aW5ncyk7XG4gIH1cblxuICBzZXROZWVkc1VwZGF0ZShyZWFzb24gPSB0aGlzLmlkLCBkYXRhUmFuZ2UpIHtcbiAgICB0aGlzLnN0YXRlLm5lZWRzVXBkYXRlID0gdGhpcy5zdGF0ZS5uZWVkc1VwZGF0ZSB8fCByZWFzb247XG4gICAgdGhpcy5zZXROZWVkc1JlZHJhdyhyZWFzb24pO1xuXG4gICAgaWYgKGRhdGFSYW5nZSkge1xuICAgICAgY29uc3Qge1xuICAgICAgICBzdGFydFJvdyA9IDAsXG4gICAgICAgIGVuZFJvdyA9IEluZmluaXR5XG4gICAgICB9ID0gZGF0YVJhbmdlO1xuICAgICAgdGhpcy5zdGF0ZS51cGRhdGVSYW5nZXMgPSByYW5nZS5hZGQodGhpcy5zdGF0ZS51cGRhdGVSYW5nZXMsIFtzdGFydFJvdywgZW5kUm93XSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuc3RhdGUudXBkYXRlUmFuZ2VzID0gcmFuZ2UuRlVMTDtcbiAgICB9XG4gIH1cblxuICBjbGVhck5lZWRzVXBkYXRlKCkge1xuICAgIHRoaXMuc3RhdGUubmVlZHNVcGRhdGUgPSBmYWxzZTtcbiAgICB0aGlzLnN0YXRlLnVwZGF0ZVJhbmdlcyA9IHJhbmdlLkVNUFRZO1xuICB9XG5cbiAgc2V0TmVlZHNSZWRyYXcocmVhc29uID0gdGhpcy5pZCkge1xuICAgIHRoaXMuc3RhdGUubmVlZHNSZWRyYXcgPSB0aGlzLnN0YXRlLm5lZWRzUmVkcmF3IHx8IHJlYXNvbjtcbiAgfVxuXG4gIGFsbG9jYXRlKG51bUluc3RhbmNlcykge1xuICAgIGNvbnN0IHtcbiAgICAgIHN0YXRlLFxuICAgICAgc2V0dGluZ3NcbiAgICB9ID0gdGhpcztcblxuICAgIGlmIChzZXR0aW5ncy5ub0FsbG9jKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgaWYgKHNldHRpbmdzLnVwZGF0ZSkge1xuICAgICAgc3VwZXIuYWxsb2NhdGUobnVtSW5zdGFuY2VzLCBzdGF0ZS51cGRhdGVSYW5nZXMgIT09IHJhbmdlLkZVTEwpO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgdXBkYXRlQnVmZmVyKHtcbiAgICBudW1JbnN0YW5jZXMsXG4gICAgZGF0YSxcbiAgICBwcm9wcyxcbiAgICBjb250ZXh0XG4gIH0pIHtcbiAgICBpZiAoIXRoaXMubmVlZHNVcGRhdGUoKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGNvbnN0IHtcbiAgICAgIHN0YXRlOiB7XG4gICAgICAgIHVwZGF0ZVJhbmdlc1xuICAgICAgfSxcbiAgICAgIHNldHRpbmdzOiB7XG4gICAgICAgIHVwZGF0ZSxcbiAgICAgICAgbm9BbGxvY1xuICAgICAgfVxuICAgIH0gPSB0aGlzO1xuICAgIGxldCB1cGRhdGVkID0gdHJ1ZTtcblxuICAgIGlmICh1cGRhdGUpIHtcbiAgICAgIGZvciAoY29uc3QgW3N0YXJ0Um93LCBlbmRSb3ddIG9mIHVwZGF0ZVJhbmdlcykge1xuICAgICAgICB1cGRhdGUuY2FsbChjb250ZXh0LCB0aGlzLCB7XG4gICAgICAgICAgZGF0YSxcbiAgICAgICAgICBzdGFydFJvdyxcbiAgICAgICAgICBlbmRSb3csXG4gICAgICAgICAgcHJvcHMsXG4gICAgICAgICAgbnVtSW5zdGFuY2VzXG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICBpZiAoIXRoaXMudmFsdWUpIHt9IGVsc2UgaWYgKHRoaXMuY29uc3RhbnQgfHwgdGhpcy5idWZmZXIuYnl0ZUxlbmd0aCA8IHRoaXMudmFsdWUuYnl0ZUxlbmd0aCArIHRoaXMuYnl0ZU9mZnNldCkge1xuICAgICAgICB0aGlzLnNldERhdGEoe1xuICAgICAgICAgIHZhbHVlOiB0aGlzLnZhbHVlLFxuICAgICAgICAgIGNvbnN0YW50OiB0aGlzLmNvbnN0YW50XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmNvbnN0YW50ID0gZmFsc2U7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBmb3IgKGNvbnN0IFtzdGFydFJvdywgZW5kUm93XSBvZiB1cGRhdGVSYW5nZXMpIHtcbiAgICAgICAgICBjb25zdCBzdGFydE9mZnNldCA9IE51bWJlci5pc0Zpbml0ZShzdGFydFJvdykgPyB0aGlzLmdldFZlcnRleE9mZnNldChzdGFydFJvdykgOiAwO1xuICAgICAgICAgIGNvbnN0IGVuZE9mZnNldCA9IE51bWJlci5pc0Zpbml0ZShlbmRSb3cpID8gdGhpcy5nZXRWZXJ0ZXhPZmZzZXQoZW5kUm93KSA6IG5vQWxsb2MgfHwgIU51bWJlci5pc0Zpbml0ZShudW1JbnN0YW5jZXMpID8gdGhpcy52YWx1ZS5sZW5ndGggOiBudW1JbnN0YW5jZXMgKiB0aGlzLnNpemU7XG4gICAgICAgICAgc3VwZXIudXBkYXRlU3ViQnVmZmVyKHtcbiAgICAgICAgICAgIHN0YXJ0T2Zmc2V0LFxuICAgICAgICAgICAgZW5kT2Zmc2V0XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdGhpcy5fY2hlY2tBdHRyaWJ1dGVBcnJheSgpO1xuICAgIH0gZWxzZSB7XG4gICAgICB1cGRhdGVkID0gZmFsc2U7XG4gICAgfVxuXG4gICAgdGhpcy5jbGVhck5lZWRzVXBkYXRlKCk7XG4gICAgdGhpcy5zZXROZWVkc1JlZHJhdygpO1xuICAgIHJldHVybiB1cGRhdGVkO1xuICB9XG5cbiAgc2V0Q29uc3RhbnRWYWx1ZSh2YWx1ZSkge1xuICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkIHx8IHR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGNvbnN0IGhhc0NoYW5nZWQgPSB0aGlzLnNldERhdGEoe1xuICAgICAgY29uc3RhbnQ6IHRydWUsXG4gICAgICB2YWx1ZVxuICAgIH0pO1xuXG4gICAgaWYgKGhhc0NoYW5nZWQpIHtcbiAgICAgIHRoaXMuc2V0TmVlZHNSZWRyYXcoKTtcbiAgICB9XG5cbiAgICB0aGlzLmNsZWFyTmVlZHNVcGRhdGUoKTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIHNldEV4dGVybmFsQnVmZmVyKGJ1ZmZlcikge1xuICAgIGNvbnN0IHtcbiAgICAgIHN0YXRlXG4gICAgfSA9IHRoaXM7XG5cbiAgICBpZiAoIWJ1ZmZlcikge1xuICAgICAgc3RhdGUubGFzdEV4dGVybmFsQnVmZmVyID0gbnVsbDtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICB0aGlzLmNsZWFyTmVlZHNVcGRhdGUoKTtcblxuICAgIGlmIChzdGF0ZS5sYXN0RXh0ZXJuYWxCdWZmZXIgPT09IGJ1ZmZlcikge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgc3RhdGUubGFzdEV4dGVybmFsQnVmZmVyID0gYnVmZmVyO1xuICAgIHRoaXMuc2V0TmVlZHNSZWRyYXcoKTtcbiAgICB0aGlzLnNldERhdGEoYnVmZmVyKTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIHNldEJpbmFyeVZhbHVlKGJ1ZmZlciwgc3RhcnRJbmRpY2VzID0gbnVsbCkge1xuICAgIGNvbnN0IHtcbiAgICAgIHN0YXRlLFxuICAgICAgc2V0dGluZ3NcbiAgICB9ID0gdGhpcztcblxuICAgIGlmICghYnVmZmVyKSB7XG4gICAgICBzdGF0ZS5iaW5hcnlWYWx1ZSA9IG51bGw7XG4gICAgICBzdGF0ZS5iaW5hcnlBY2Nlc3NvciA9IG51bGw7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgaWYgKHNldHRpbmdzLm5vQWxsb2MpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBpZiAoc3RhdGUuYmluYXJ5VmFsdWUgPT09IGJ1ZmZlcikge1xuICAgICAgdGhpcy5jbGVhck5lZWRzVXBkYXRlKCk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICBzdGF0ZS5iaW5hcnlWYWx1ZSA9IGJ1ZmZlcjtcbiAgICB0aGlzLnNldE5lZWRzUmVkcmF3KCk7XG4gICAgY29uc3QgbmVlZHNVcGRhdGUgPSBzZXR0aW5ncy50cmFuc2Zvcm0gfHwgc3RhcnRJbmRpY2VzICE9PSB0aGlzLnN0YXJ0SW5kaWNlcztcblxuICAgIGlmIChuZWVkc1VwZGF0ZSkge1xuICAgICAgaWYgKEFycmF5QnVmZmVyLmlzVmlldyhidWZmZXIpKSB7XG4gICAgICAgIGJ1ZmZlciA9IHtcbiAgICAgICAgICB2YWx1ZTogYnVmZmVyXG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGJpbmFyeVZhbHVlID0gYnVmZmVyO1xuICAgICAgYXNzZXJ0KEFycmF5QnVmZmVyLmlzVmlldyhiaW5hcnlWYWx1ZS52YWx1ZSksIFwiaW52YWxpZCBcIi5jb25jYXQoc2V0dGluZ3MuYWNjZXNzb3IpKTtcbiAgICAgIGNvbnN0IG5lZWRzTm9ybWFsaXplID0gQm9vbGVhbihiaW5hcnlWYWx1ZS5zaXplKSAmJiBiaW5hcnlWYWx1ZS5zaXplICE9PSB0aGlzLnNpemU7XG4gICAgICBzdGF0ZS5iaW5hcnlBY2Nlc3NvciA9IGdldEFjY2Vzc29yRnJvbUJ1ZmZlcihiaW5hcnlWYWx1ZS52YWx1ZSwge1xuICAgICAgICBzaXplOiBiaW5hcnlWYWx1ZS5zaXplIHx8IHRoaXMuc2l6ZSxcbiAgICAgICAgc3RyaWRlOiBiaW5hcnlWYWx1ZS5zdHJpZGUsXG4gICAgICAgIG9mZnNldDogYmluYXJ5VmFsdWUub2Zmc2V0LFxuICAgICAgICBzdGFydEluZGljZXM6IHN0YXJ0SW5kaWNlcyxcbiAgICAgICAgbmVzdGVkOiBuZWVkc05vcm1hbGl6ZVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgdGhpcy5jbGVhck5lZWRzVXBkYXRlKCk7XG4gICAgdGhpcy5zZXREYXRhKGJ1ZmZlcik7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICBnZXRWZXJ0ZXhPZmZzZXQocm93KSB7XG4gICAgY29uc3Qge1xuICAgICAgc3RhcnRJbmRpY2VzXG4gICAgfSA9IHRoaXM7XG4gICAgY29uc3QgdmVydGV4SW5kZXggPSBzdGFydEluZGljZXMgPyByb3cgPCBzdGFydEluZGljZXMubGVuZ3RoID8gc3RhcnRJbmRpY2VzW3Jvd10gOiB0aGlzLm51bUluc3RhbmNlcyA6IHJvdztcbiAgICByZXR1cm4gdmVydGV4SW5kZXggKiB0aGlzLnNpemU7XG4gIH1cblxuICBnZXRTaGFkZXJBdHRyaWJ1dGVzKCkge1xuICAgIGNvbnN0IHNoYWRlckF0dHJpYnV0ZURlZnMgPSB0aGlzLnNldHRpbmdzLnNoYWRlckF0dHJpYnV0ZXMgfHwge1xuICAgICAgW3RoaXMuaWRdOiBudWxsXG4gICAgfTtcbiAgICBjb25zdCBzaGFkZXJBdHRyaWJ1dGVzID0ge307XG5cbiAgICBmb3IgKGNvbnN0IHNoYWRlckF0dHJpYnV0ZU5hbWUgaW4gc2hhZGVyQXR0cmlidXRlRGVmcykge1xuICAgICAgT2JqZWN0LmFzc2lnbihzaGFkZXJBdHRyaWJ1dGVzLCBzdXBlci5nZXRTaGFkZXJBdHRyaWJ1dGVzKHNoYWRlckF0dHJpYnV0ZU5hbWUsIHNoYWRlckF0dHJpYnV0ZURlZnNbc2hhZGVyQXR0cmlidXRlTmFtZV0pKTtcbiAgICB9XG5cbiAgICByZXR1cm4gc2hhZGVyQXR0cmlidXRlcztcbiAgfVxuXG4gIF9hdXRvVXBkYXRlcihhdHRyaWJ1dGUsIHtcbiAgICBkYXRhLFxuICAgIHN0YXJ0Um93LFxuICAgIGVuZFJvdyxcbiAgICBwcm9wcyxcbiAgICBudW1JbnN0YW5jZXNcbiAgfSkge1xuICAgIGlmIChhdHRyaWJ1dGUuY29uc3RhbnQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCB7XG4gICAgICBzZXR0aW5ncyxcbiAgICAgIHN0YXRlLFxuICAgICAgdmFsdWUsXG4gICAgICBzaXplLFxuICAgICAgc3RhcnRJbmRpY2VzXG4gICAgfSA9IGF0dHJpYnV0ZTtcbiAgICBjb25zdCB7XG4gICAgICBhY2Nlc3NvcixcbiAgICAgIHRyYW5zZm9ybVxuICAgIH0gPSBzZXR0aW5ncztcbiAgICBjb25zdCBhY2Nlc3NvckZ1bmMgPSBzdGF0ZS5iaW5hcnlBY2Nlc3NvciB8fCAodHlwZW9mIGFjY2Vzc29yID09PSAnZnVuY3Rpb24nID8gYWNjZXNzb3IgOiBwcm9wc1thY2Nlc3Nvcl0pO1xuICAgIGFzc2VydCh0eXBlb2YgYWNjZXNzb3JGdW5jID09PSAnZnVuY3Rpb24nLCBcImFjY2Vzc29yIFxcXCJcIi5jb25jYXQoYWNjZXNzb3IsIFwiXFxcIiBpcyBub3QgYSBmdW5jdGlvblwiKSk7XG4gICAgbGV0IGkgPSBhdHRyaWJ1dGUuZ2V0VmVydGV4T2Zmc2V0KHN0YXJ0Um93KTtcbiAgICBjb25zdCB7XG4gICAgICBpdGVyYWJsZSxcbiAgICAgIG9iamVjdEluZm9cbiAgICB9ID0gY3JlYXRlSXRlcmFibGUoZGF0YSwgc3RhcnRSb3csIGVuZFJvdyk7XG5cbiAgICBmb3IgKGNvbnN0IG9iamVjdCBvZiBpdGVyYWJsZSkge1xuICAgICAgb2JqZWN0SW5mby5pbmRleCsrO1xuICAgICAgbGV0IG9iamVjdFZhbHVlID0gYWNjZXNzb3JGdW5jKG9iamVjdCwgb2JqZWN0SW5mbyk7XG5cbiAgICAgIGlmICh0cmFuc2Zvcm0pIHtcbiAgICAgICAgb2JqZWN0VmFsdWUgPSB0cmFuc2Zvcm0uY2FsbCh0aGlzLCBvYmplY3RWYWx1ZSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChzdGFydEluZGljZXMpIHtcbiAgICAgICAgY29uc3QgbnVtVmVydGljZXMgPSAob2JqZWN0SW5mby5pbmRleCA8IHN0YXJ0SW5kaWNlcy5sZW5ndGggLSAxID8gc3RhcnRJbmRpY2VzW29iamVjdEluZm8uaW5kZXggKyAxXSA6IG51bUluc3RhbmNlcykgLSBzdGFydEluZGljZXNbb2JqZWN0SW5mby5pbmRleF07XG5cbiAgICAgICAgaWYgKG9iamVjdFZhbHVlICYmIEFycmF5LmlzQXJyYXkob2JqZWN0VmFsdWVbMF0pKSB7XG4gICAgICAgICAgbGV0IHN0YXJ0SW5kZXggPSBpO1xuXG4gICAgICAgICAgZm9yIChjb25zdCBpdGVtIG9mIG9iamVjdFZhbHVlKSB7XG4gICAgICAgICAgICBhdHRyaWJ1dGUuX25vcm1hbGl6ZVZhbHVlKGl0ZW0sIHZhbHVlLCBzdGFydEluZGV4KTtcblxuICAgICAgICAgICAgc3RhcnRJbmRleCArPSBzaXplO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChvYmplY3RWYWx1ZSAmJiBvYmplY3RWYWx1ZS5sZW5ndGggPiBzaXplKSB7XG4gICAgICAgICAgdmFsdWUuc2V0KG9iamVjdFZhbHVlLCBpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBhdHRyaWJ1dGUuX25vcm1hbGl6ZVZhbHVlKG9iamVjdFZhbHVlLCBvYmplY3RJbmZvLnRhcmdldCwgMCk7XG5cbiAgICAgICAgICBmaWxsQXJyYXkoe1xuICAgICAgICAgICAgdGFyZ2V0OiB2YWx1ZSxcbiAgICAgICAgICAgIHNvdXJjZTogb2JqZWN0SW5mby50YXJnZXQsXG4gICAgICAgICAgICBzdGFydDogaSxcbiAgICAgICAgICAgIGNvdW50OiBudW1WZXJ0aWNlc1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgaSArPSBudW1WZXJ0aWNlcyAqIHNpemU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBhdHRyaWJ1dGUuX25vcm1hbGl6ZVZhbHVlKG9iamVjdFZhbHVlLCB2YWx1ZSwgaSk7XG5cbiAgICAgICAgaSArPSBzaXplO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIF92YWxpZGF0ZUF0dHJpYnV0ZVVwZGF0ZXJzKCkge1xuICAgIGNvbnN0IHtcbiAgICAgIHNldHRpbmdzXG4gICAgfSA9IHRoaXM7XG4gICAgY29uc3QgaGFzVXBkYXRlciA9IHNldHRpbmdzLm5vQWxsb2MgfHwgdHlwZW9mIHNldHRpbmdzLnVwZGF0ZSA9PT0gJ2Z1bmN0aW9uJztcblxuICAgIGlmICghaGFzVXBkYXRlcikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQXR0cmlidXRlIFwiLmNvbmNhdCh0aGlzLmlkLCBcIiBtaXNzaW5nIHVwZGF0ZSBvciBhY2Nlc3NvclwiKSk7XG4gICAgfVxuICB9XG5cbiAgX2NoZWNrQXR0cmlidXRlQXJyYXkoKSB7XG4gICAgY29uc3Qge1xuICAgICAgdmFsdWVcbiAgICB9ID0gdGhpcztcbiAgICBjb25zdCBsaW1pdCA9IE1hdGgubWluKDQsIHRoaXMuc2l6ZSk7XG5cbiAgICBpZiAodmFsdWUgJiYgdmFsdWUubGVuZ3RoID49IGxpbWl0KSB7XG4gICAgICBsZXQgdmFsaWQgPSB0cnVlO1xuXG4gICAgICBzd2l0Y2ggKGxpbWl0KSB7XG4gICAgICAgIGNhc2UgNDpcbiAgICAgICAgICB2YWxpZCA9IHZhbGlkICYmIE51bWJlci5pc0Zpbml0ZSh2YWx1ZVszXSk7XG5cbiAgICAgICAgY2FzZSAzOlxuICAgICAgICAgIHZhbGlkID0gdmFsaWQgJiYgTnVtYmVyLmlzRmluaXRlKHZhbHVlWzJdKTtcblxuICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgdmFsaWQgPSB2YWxpZCAmJiBOdW1iZXIuaXNGaW5pdGUodmFsdWVbMV0pO1xuXG4gICAgICAgIGNhc2UgMTpcbiAgICAgICAgICB2YWxpZCA9IHZhbGlkICYmIE51bWJlci5pc0Zpbml0ZSh2YWx1ZVswXSk7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICB2YWxpZCA9IGZhbHNlO1xuICAgICAgfVxuXG4gICAgICBpZiAoIXZhbGlkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIklsbGVnYWwgYXR0cmlidXRlIGdlbmVyYXRlZCBmb3IgXCIuY29uY2F0KHRoaXMuaWQpKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YXR0cmlidXRlLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///13906\n')},78918:function(__unused_webpack_module,__webpack_exports__,__webpack_require__){eval('/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "Z": function() { return /* binding */ CompositeLayer; }\n/* harmony export */ });\n/* harmony import */ var _babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(82482);\n/* harmony import */ var _layer__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(52447);\n/* harmony import */ var _debug__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(63803);\n/* harmony import */ var _utils_flatten__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(61855);\n/* harmony import */ var _lifecycle_constants__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(85409);\n\n\n\n\n\nconst TRACE_RENDER_LAYERS = \'compositeLayer.renderLayers\';\nclass CompositeLayer extends _layer__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .Z {\n  get isComposite() {\n    return true;\n  }\n\n  get isLoaded() {\n    return super.isLoaded && this.getSubLayers().every(layer => layer.isLoaded);\n  }\n\n  getSubLayers() {\n    return this.internalState && this.internalState.subLayers || [];\n  }\n\n  initializeState(context) {}\n\n  setState(updateObject) {\n    super.setState(updateObject);\n    this.setNeedsUpdate();\n  }\n\n  getPickingInfo({\n    info\n  }) {\n    const {\n      object\n    } = info;\n    const isDataWrapped = object && object.__source && object.__source.parent && object.__source.parent.id === this.id;\n\n    if (!isDataWrapped) {\n      return info;\n    }\n\n    info.object = object.__source.object;\n    info.index = object.__source.index;\n    return info;\n  }\n\n  filterSubLayer(context) {\n    return true;\n  }\n\n  shouldRenderSubLayer(subLayerId, data) {\n    return data && data.length;\n  }\n\n  getSubLayerClass(subLayerId, DefaultLayerClass) {\n    const {\n      _subLayerProps: overridingProps\n    } = this.props;\n    return overridingProps && overridingProps[subLayerId] && overridingProps[subLayerId].type || DefaultLayerClass;\n  }\n\n  getSubLayerRow(row, sourceObject, sourceObjectIndex) {\n    row.__source = {\n      parent: this,\n      object: sourceObject,\n      index: sourceObjectIndex\n    };\n    return row;\n  }\n\n  getSubLayerAccessor(accessor) {\n    if (typeof accessor === \'function\') {\n      const objectInfo = {\n        index: -1,\n        data: this.props.data,\n        target: []\n      };\n      return (x, i) => {\n        if (x && x.__source) {\n          objectInfo.index = x.__source.index;\n          return accessor(x.__source.object, objectInfo);\n        }\n\n        return accessor(x, i);\n      };\n    }\n\n    return accessor;\n  }\n\n  getSubLayerProps(sublayerProps = {}) {\n    var _this$props$updateTri;\n\n    const {\n      opacity,\n      pickable,\n      visible,\n      parameters,\n      getPolygonOffset,\n      highlightedObjectIndex,\n      autoHighlight,\n      highlightColor,\n      coordinateSystem,\n      coordinateOrigin,\n      wrapLongitude,\n      positionFormat,\n      modelMatrix,\n      extensions,\n      fetch,\n      operation,\n      _subLayerProps: overridingProps\n    } = this.props;\n    const newProps = {\n      id: \'\',\n      updateTriggers: {},\n      opacity,\n      pickable,\n      visible,\n      parameters,\n      getPolygonOffset,\n      highlightedObjectIndex,\n      autoHighlight,\n      highlightColor,\n      coordinateSystem,\n      coordinateOrigin,\n      wrapLongitude,\n      positionFormat,\n      modelMatrix,\n      extensions,\n      fetch,\n      operation\n    };\n    const overridingSublayerProps = overridingProps && sublayerProps.id && overridingProps[sublayerProps.id];\n    const overridingSublayerTriggers = overridingSublayerProps && overridingSublayerProps.updateTriggers;\n    const sublayerId = sublayerProps.id || \'sublayer\';\n\n    if (overridingSublayerProps) {\n      const propTypes = this.props[_lifecycle_constants__WEBPACK_IMPORTED_MODULE_1__/* .PROP_TYPES_SYMBOL */ .Wb];\n      const subLayerPropTypes = sublayerProps.type ? sublayerProps.type._propTypes : {};\n\n      for (const key in overridingSublayerProps) {\n        const propType = subLayerPropTypes[key] || propTypes[key];\n\n        if (propType && propType.type === \'accessor\') {\n          overridingSublayerProps[key] = this.getSubLayerAccessor(overridingSublayerProps[key]);\n        }\n      }\n    }\n\n    Object.assign(newProps, sublayerProps, overridingSublayerProps);\n    newProps.id = "".concat(this.props.id, "-").concat(sublayerId);\n    newProps.updateTriggers = {\n      all: (_this$props$updateTri = this.props.updateTriggers) === null || _this$props$updateTri === void 0 ? void 0 : _this$props$updateTri.all,\n      ...sublayerProps.updateTriggers,\n      ...overridingSublayerTriggers\n    };\n\n    for (const extension of extensions) {\n      const passThroughProps = extension.getSubLayerProps.call(this, extension);\n\n      if (passThroughProps) {\n        Object.assign(newProps, passThroughProps, {\n          updateTriggers: Object.assign(newProps.updateTriggers, passThroughProps.updateTriggers)\n        });\n      }\n    }\n\n    return newProps;\n  }\n\n  _updateAutoHighlight(info) {\n    for (const layer of this.getSubLayers()) {\n      layer.updateAutoHighlight(info);\n    }\n  }\n\n  _getAttributeManager() {\n    return null;\n  }\n\n  _postUpdate(updateParams, forceUpdate) {\n    let subLayers = this.internalState.subLayers;\n    const shouldUpdate = !subLayers || this.needsUpdate();\n\n    if (shouldUpdate) {\n      const subLayersList = this.renderLayers();\n      subLayers = (0,_utils_flatten__WEBPACK_IMPORTED_MODULE_2__/* .flatten */ .x)(subLayersList, Boolean);\n      this.internalState.subLayers = subLayers;\n    }\n\n    (0,_debug__WEBPACK_IMPORTED_MODULE_3__/* ["default"] */ .Z)(TRACE_RENDER_LAYERS, this, shouldUpdate, subLayers);\n\n    for (const layer of subLayers) {\n      layer.parent = this;\n    }\n  }\n\n}\n\n(0,_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .Z)(CompositeLayer, "layerName", \'CompositeLayer\');\n//# sourceMappingURL=composite-layer.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNzg5MTguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFBd0U7QUFDNUM7QUFDQztBQUNjO0FBQ2dCO0FBQzNEO0FBQ2UsNkJBQTZCLHVEQUFLO0FBQ2pEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLE1BQU07QUFDTjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxxQ0FBcUM7QUFDckM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG1DQUFtQyw2RUFBaUI7QUFDcEQ7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGtCQUFrQixnRUFBTztBQUN6QjtBQUNBOztBQUVBLElBQUksMkRBQUs7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsOEZBQWU7QUFDZiIsInNvdXJjZXMiOlsid2VicGFjazovL3Z1ZTMtd2VicGFjazUvLi9ub2RlX21vZHVsZXMvQGRlY2suZ2wvY29yZS9kaXN0L2VzbS9saWIvY29tcG9zaXRlLWxheWVyLmpzPzgyNTQiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IF9kZWZpbmVQcm9wZXJ0eSBmcm9tIFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vZGVmaW5lUHJvcGVydHlcIjtcbmltcG9ydCBMYXllciBmcm9tICcuL2xheWVyJztcbmltcG9ydCBkZWJ1ZyBmcm9tICcuLi9kZWJ1Zyc7XG5pbXBvcnQgeyBmbGF0dGVuIH0gZnJvbSAnLi4vdXRpbHMvZmxhdHRlbic7XG5pbXBvcnQgeyBQUk9QX1RZUEVTX1NZTUJPTCB9IGZyb20gJy4uL2xpZmVjeWNsZS9jb25zdGFudHMnO1xuY29uc3QgVFJBQ0VfUkVOREVSX0xBWUVSUyA9ICdjb21wb3NpdGVMYXllci5yZW5kZXJMYXllcnMnO1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQ29tcG9zaXRlTGF5ZXIgZXh0ZW5kcyBMYXllciB7XG4gIGdldCBpc0NvbXBvc2l0ZSgpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIGdldCBpc0xvYWRlZCgpIHtcbiAgICByZXR1cm4gc3VwZXIuaXNMb2FkZWQgJiYgdGhpcy5nZXRTdWJMYXllcnMoKS5ldmVyeShsYXllciA9PiBsYXllci5pc0xvYWRlZCk7XG4gIH1cblxuICBnZXRTdWJMYXllcnMoKSB7XG4gICAgcmV0dXJuIHRoaXMuaW50ZXJuYWxTdGF0ZSAmJiB0aGlzLmludGVybmFsU3RhdGUuc3ViTGF5ZXJzIHx8IFtdO1xuICB9XG5cbiAgaW5pdGlhbGl6ZVN0YXRlKGNvbnRleHQpIHt9XG5cbiAgc2V0U3RhdGUodXBkYXRlT2JqZWN0KSB7XG4gICAgc3VwZXIuc2V0U3RhdGUodXBkYXRlT2JqZWN0KTtcbiAgICB0aGlzLnNldE5lZWRzVXBkYXRlKCk7XG4gIH1cblxuICBnZXRQaWNraW5nSW5mbyh7XG4gICAgaW5mb1xuICB9KSB7XG4gICAgY29uc3Qge1xuICAgICAgb2JqZWN0XG4gICAgfSA9IGluZm87XG4gICAgY29uc3QgaXNEYXRhV3JhcHBlZCA9IG9iamVjdCAmJiBvYmplY3QuX19zb3VyY2UgJiYgb2JqZWN0Ll9fc291cmNlLnBhcmVudCAmJiBvYmplY3QuX19zb3VyY2UucGFyZW50LmlkID09PSB0aGlzLmlkO1xuXG4gICAgaWYgKCFpc0RhdGFXcmFwcGVkKSB7XG4gICAgICByZXR1cm4gaW5mbztcbiAgICB9XG5cbiAgICBpbmZvLm9iamVjdCA9IG9iamVjdC5fX3NvdXJjZS5vYmplY3Q7XG4gICAgaW5mby5pbmRleCA9IG9iamVjdC5fX3NvdXJjZS5pbmRleDtcbiAgICByZXR1cm4gaW5mbztcbiAgfVxuXG4gIGZpbHRlclN1YkxheWVyKGNvbnRleHQpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIHNob3VsZFJlbmRlclN1YkxheWVyKHN1YkxheWVySWQsIGRhdGEpIHtcbiAgICByZXR1cm4gZGF0YSAmJiBkYXRhLmxlbmd0aDtcbiAgfVxuXG4gIGdldFN1YkxheWVyQ2xhc3Moc3ViTGF5ZXJJZCwgRGVmYXVsdExheWVyQ2xhc3MpIHtcbiAgICBjb25zdCB7XG4gICAgICBfc3ViTGF5ZXJQcm9wczogb3ZlcnJpZGluZ1Byb3BzXG4gICAgfSA9IHRoaXMucHJvcHM7XG4gICAgcmV0dXJuIG92ZXJyaWRpbmdQcm9wcyAmJiBvdmVycmlkaW5nUHJvcHNbc3ViTGF5ZXJJZF0gJiYgb3ZlcnJpZGluZ1Byb3BzW3N1YkxheWVySWRdLnR5cGUgfHwgRGVmYXVsdExheWVyQ2xhc3M7XG4gIH1cblxuICBnZXRTdWJMYXllclJvdyhyb3csIHNvdXJjZU9iamVjdCwgc291cmNlT2JqZWN0SW5kZXgpIHtcbiAgICByb3cuX19zb3VyY2UgPSB7XG4gICAgICBwYXJlbnQ6IHRoaXMsXG4gICAgICBvYmplY3Q6IHNvdXJjZU9iamVjdCxcbiAgICAgIGluZGV4OiBzb3VyY2VPYmplY3RJbmRleFxuICAgIH07XG4gICAgcmV0dXJuIHJvdztcbiAgfVxuXG4gIGdldFN1YkxheWVyQWNjZXNzb3IoYWNjZXNzb3IpIHtcbiAgICBpZiAodHlwZW9mIGFjY2Vzc29yID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBjb25zdCBvYmplY3RJbmZvID0ge1xuICAgICAgICBpbmRleDogLTEsXG4gICAgICAgIGRhdGE6IHRoaXMucHJvcHMuZGF0YSxcbiAgICAgICAgdGFyZ2V0OiBbXVxuICAgICAgfTtcbiAgICAgIHJldHVybiAoeCwgaSkgPT4ge1xuICAgICAgICBpZiAoeCAmJiB4Ll9fc291cmNlKSB7XG4gICAgICAgICAgb2JqZWN0SW5mby5pbmRleCA9IHguX19zb3VyY2UuaW5kZXg7XG4gICAgICAgICAgcmV0dXJuIGFjY2Vzc29yKHguX19zb3VyY2Uub2JqZWN0LCBvYmplY3RJbmZvKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBhY2Nlc3Nvcih4LCBpKTtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgcmV0dXJuIGFjY2Vzc29yO1xuICB9XG5cbiAgZ2V0U3ViTGF5ZXJQcm9wcyhzdWJsYXllclByb3BzID0ge30pIHtcbiAgICB2YXIgX3RoaXMkcHJvcHMkdXBkYXRlVHJpO1xuXG4gICAgY29uc3Qge1xuICAgICAgb3BhY2l0eSxcbiAgICAgIHBpY2thYmxlLFxuICAgICAgdmlzaWJsZSxcbiAgICAgIHBhcmFtZXRlcnMsXG4gICAgICBnZXRQb2x5Z29uT2Zmc2V0LFxuICAgICAgaGlnaGxpZ2h0ZWRPYmplY3RJbmRleCxcbiAgICAgIGF1dG9IaWdobGlnaHQsXG4gICAgICBoaWdobGlnaHRDb2xvcixcbiAgICAgIGNvb3JkaW5hdGVTeXN0ZW0sXG4gICAgICBjb29yZGluYXRlT3JpZ2luLFxuICAgICAgd3JhcExvbmdpdHVkZSxcbiAgICAgIHBvc2l0aW9uRm9ybWF0LFxuICAgICAgbW9kZWxNYXRyaXgsXG4gICAgICBleHRlbnNpb25zLFxuICAgICAgZmV0Y2gsXG4gICAgICBvcGVyYXRpb24sXG4gICAgICBfc3ViTGF5ZXJQcm9wczogb3ZlcnJpZGluZ1Byb3BzXG4gICAgfSA9IHRoaXMucHJvcHM7XG4gICAgY29uc3QgbmV3UHJvcHMgPSB7XG4gICAgICBpZDogJycsXG4gICAgICB1cGRhdGVUcmlnZ2Vyczoge30sXG4gICAgICBvcGFjaXR5LFxuICAgICAgcGlja2FibGUsXG4gICAgICB2aXNpYmxlLFxuICAgICAgcGFyYW1ldGVycyxcbiAgICAgIGdldFBvbHlnb25PZmZzZXQsXG4gICAgICBoaWdobGlnaHRlZE9iamVjdEluZGV4LFxuICAgICAgYXV0b0hpZ2hsaWdodCxcbiAgICAgIGhpZ2hsaWdodENvbG9yLFxuICAgICAgY29vcmRpbmF0ZVN5c3RlbSxcbiAgICAgIGNvb3JkaW5hdGVPcmlnaW4sXG4gICAgICB3cmFwTG9uZ2l0dWRlLFxuICAgICAgcG9zaXRpb25Gb3JtYXQsXG4gICAgICBtb2RlbE1hdHJpeCxcbiAgICAgIGV4dGVuc2lvbnMsXG4gICAgICBmZXRjaCxcbiAgICAgIG9wZXJhdGlvblxuICAgIH07XG4gICAgY29uc3Qgb3ZlcnJpZGluZ1N1YmxheWVyUHJvcHMgPSBvdmVycmlkaW5nUHJvcHMgJiYgc3VibGF5ZXJQcm9wcy5pZCAmJiBvdmVycmlkaW5nUHJvcHNbc3VibGF5ZXJQcm9wcy5pZF07XG4gICAgY29uc3Qgb3ZlcnJpZGluZ1N1YmxheWVyVHJpZ2dlcnMgPSBvdmVycmlkaW5nU3VibGF5ZXJQcm9wcyAmJiBvdmVycmlkaW5nU3VibGF5ZXJQcm9wcy51cGRhdGVUcmlnZ2VycztcbiAgICBjb25zdCBzdWJsYXllcklkID0gc3VibGF5ZXJQcm9wcy5pZCB8fCAnc3VibGF5ZXInO1xuXG4gICAgaWYgKG92ZXJyaWRpbmdTdWJsYXllclByb3BzKSB7XG4gICAgICBjb25zdCBwcm9wVHlwZXMgPSB0aGlzLnByb3BzW1BST1BfVFlQRVNfU1lNQk9MXTtcbiAgICAgIGNvbnN0IHN1YkxheWVyUHJvcFR5cGVzID0gc3VibGF5ZXJQcm9wcy50eXBlID8gc3VibGF5ZXJQcm9wcy50eXBlLl9wcm9wVHlwZXMgOiB7fTtcblxuICAgICAgZm9yIChjb25zdCBrZXkgaW4gb3ZlcnJpZGluZ1N1YmxheWVyUHJvcHMpIHtcbiAgICAgICAgY29uc3QgcHJvcFR5cGUgPSBzdWJMYXllclByb3BUeXBlc1trZXldIHx8IHByb3BUeXBlc1trZXldO1xuXG4gICAgICAgIGlmIChwcm9wVHlwZSAmJiBwcm9wVHlwZS50eXBlID09PSAnYWNjZXNzb3InKSB7XG4gICAgICAgICAgb3ZlcnJpZGluZ1N1YmxheWVyUHJvcHNba2V5XSA9IHRoaXMuZ2V0U3ViTGF5ZXJBY2Nlc3NvcihvdmVycmlkaW5nU3VibGF5ZXJQcm9wc1trZXldKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIE9iamVjdC5hc3NpZ24obmV3UHJvcHMsIHN1YmxheWVyUHJvcHMsIG92ZXJyaWRpbmdTdWJsYXllclByb3BzKTtcbiAgICBuZXdQcm9wcy5pZCA9IFwiXCIuY29uY2F0KHRoaXMucHJvcHMuaWQsIFwiLVwiKS5jb25jYXQoc3VibGF5ZXJJZCk7XG4gICAgbmV3UHJvcHMudXBkYXRlVHJpZ2dlcnMgPSB7XG4gICAgICBhbGw6IChfdGhpcyRwcm9wcyR1cGRhdGVUcmkgPSB0aGlzLnByb3BzLnVwZGF0ZVRyaWdnZXJzKSA9PT0gbnVsbCB8fCBfdGhpcyRwcm9wcyR1cGRhdGVUcmkgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF90aGlzJHByb3BzJHVwZGF0ZVRyaS5hbGwsXG4gICAgICAuLi5zdWJsYXllclByb3BzLnVwZGF0ZVRyaWdnZXJzLFxuICAgICAgLi4ub3ZlcnJpZGluZ1N1YmxheWVyVHJpZ2dlcnNcbiAgICB9O1xuXG4gICAgZm9yIChjb25zdCBleHRlbnNpb24gb2YgZXh0ZW5zaW9ucykge1xuICAgICAgY29uc3QgcGFzc1Rocm91Z2hQcm9wcyA9IGV4dGVuc2lvbi5nZXRTdWJMYXllclByb3BzLmNhbGwodGhpcywgZXh0ZW5zaW9uKTtcblxuICAgICAgaWYgKHBhc3NUaHJvdWdoUHJvcHMpIHtcbiAgICAgICAgT2JqZWN0LmFzc2lnbihuZXdQcm9wcywgcGFzc1Rocm91Z2hQcm9wcywge1xuICAgICAgICAgIHVwZGF0ZVRyaWdnZXJzOiBPYmplY3QuYXNzaWduKG5ld1Byb3BzLnVwZGF0ZVRyaWdnZXJzLCBwYXNzVGhyb3VnaFByb3BzLnVwZGF0ZVRyaWdnZXJzKVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gbmV3UHJvcHM7XG4gIH1cblxuICBfdXBkYXRlQXV0b0hpZ2hsaWdodChpbmZvKSB7XG4gICAgZm9yIChjb25zdCBsYXllciBvZiB0aGlzLmdldFN1YkxheWVycygpKSB7XG4gICAgICBsYXllci51cGRhdGVBdXRvSGlnaGxpZ2h0KGluZm8pO1xuICAgIH1cbiAgfVxuXG4gIF9nZXRBdHRyaWJ1dGVNYW5hZ2VyKCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgX3Bvc3RVcGRhdGUodXBkYXRlUGFyYW1zLCBmb3JjZVVwZGF0ZSkge1xuICAgIGxldCBzdWJMYXllcnMgPSB0aGlzLmludGVybmFsU3RhdGUuc3ViTGF5ZXJzO1xuICAgIGNvbnN0IHNob3VsZFVwZGF0ZSA9ICFzdWJMYXllcnMgfHwgdGhpcy5uZWVkc1VwZGF0ZSgpO1xuXG4gICAgaWYgKHNob3VsZFVwZGF0ZSkge1xuICAgICAgY29uc3Qgc3ViTGF5ZXJzTGlzdCA9IHRoaXMucmVuZGVyTGF5ZXJzKCk7XG4gICAgICBzdWJMYXllcnMgPSBmbGF0dGVuKHN1YkxheWVyc0xpc3QsIEJvb2xlYW4pO1xuICAgICAgdGhpcy5pbnRlcm5hbFN0YXRlLnN1YkxheWVycyA9IHN1YkxheWVycztcbiAgICB9XG5cbiAgICBkZWJ1ZyhUUkFDRV9SRU5ERVJfTEFZRVJTLCB0aGlzLCBzaG91bGRVcGRhdGUsIHN1YkxheWVycyk7XG5cbiAgICBmb3IgKGNvbnN0IGxheWVyIG9mIHN1YkxheWVycykge1xuICAgICAgbGF5ZXIucGFyZW50ID0gdGhpcztcbiAgICB9XG4gIH1cblxufVxuXG5fZGVmaW5lUHJvcGVydHkoQ29tcG9zaXRlTGF5ZXIsIFwibGF5ZXJOYW1lXCIsICdDb21wb3NpdGVMYXllcicpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y29tcG9zaXRlLWxheWVyLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///78918\n')},24088:function(__unused_webpack_module,__webpack_exports__,__webpack_require__){eval("/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Df\": function() { return /* binding */ COORDINATE_SYSTEM; },\n/* harmony export */   \"FP\": function() { return /* binding */ EVENTS; },\n/* harmony export */   \"iI\": function() { return /* binding */ UNIT; },\n/* harmony export */   \"zG\": function() { return /* binding */ PROJECTION_MODE; }\n/* harmony export */ });\n/* unused harmony export OPERATION */\n/* harmony import */ var _utils_log__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(80744);\n\nconst COORDINATE_SYSTEM = {\n  DEFAULT: -1,\n  LNGLAT: 1,\n  METER_OFFSETS: 2,\n  LNGLAT_OFFSETS: 3,\n  CARTESIAN: 0\n};\nObject.defineProperty(COORDINATE_SYSTEM, 'IDENTITY', {\n  get: () => {\n    _utils_log__WEBPACK_IMPORTED_MODULE_0__/* [\"default\"].deprecated */ .Z.deprecated('COORDINATE_SYSTEM.IDENTITY', 'COORDINATE_SYSTEM.CARTESIAN')();\n    return 0;\n  }\n});\nconst PROJECTION_MODE = {\n  WEB_MERCATOR: 1,\n  GLOBE: 2,\n  WEB_MERCATOR_AUTO_OFFSET: 4,\n  IDENTITY: 0\n};\nconst UNIT = {\n  common: 0,\n  meters: 1,\n  pixels: 2\n};\nconst EVENTS = {\n  click: {\n    handler: 'onClick'\n  },\n  panstart: {\n    handler: 'onDragStart'\n  },\n  panmove: {\n    handler: 'onDrag'\n  },\n  panend: {\n    handler: 'onDragEnd'\n  }\n};\nconst OPERATION = {\n  DRAW: 'draw',\n  MASK: 'mask',\n  TERRAIN: 'terrain'\n};\n//# sourceMappingURL=constants.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjQwODguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFBK0I7QUFDeEI7QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSxpRkFBYztBQUNsQjtBQUNBO0FBQ0EsQ0FBQztBQUNNO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdnVlMy13ZWJwYWNrNS8uL25vZGVfbW9kdWxlcy9AZGVjay5nbC9jb3JlL2Rpc3QvZXNtL2xpYi9jb25zdGFudHMuanM/MmM1MSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgbG9nIGZyb20gJy4uL3V0aWxzL2xvZyc7XG5leHBvcnQgY29uc3QgQ09PUkRJTkFURV9TWVNURU0gPSB7XG4gIERFRkFVTFQ6IC0xLFxuICBMTkdMQVQ6IDEsXG4gIE1FVEVSX09GRlNFVFM6IDIsXG4gIExOR0xBVF9PRkZTRVRTOiAzLFxuICBDQVJURVNJQU46IDBcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoQ09PUkRJTkFURV9TWVNURU0sICdJREVOVElUWScsIHtcbiAgZ2V0OiAoKSA9PiB7XG4gICAgbG9nLmRlcHJlY2F0ZWQoJ0NPT1JESU5BVEVfU1lTVEVNLklERU5USVRZJywgJ0NPT1JESU5BVEVfU1lTVEVNLkNBUlRFU0lBTicpKCk7XG4gICAgcmV0dXJuIDA7XG4gIH1cbn0pO1xuZXhwb3J0IGNvbnN0IFBST0pFQ1RJT05fTU9ERSA9IHtcbiAgV0VCX01FUkNBVE9SOiAxLFxuICBHTE9CRTogMixcbiAgV0VCX01FUkNBVE9SX0FVVE9fT0ZGU0VUOiA0LFxuICBJREVOVElUWTogMFxufTtcbmV4cG9ydCBjb25zdCBVTklUID0ge1xuICBjb21tb246IDAsXG4gIG1ldGVyczogMSxcbiAgcGl4ZWxzOiAyXG59O1xuZXhwb3J0IGNvbnN0IEVWRU5UUyA9IHtcbiAgY2xpY2s6IHtcbiAgICBoYW5kbGVyOiAnb25DbGljaydcbiAgfSxcbiAgcGFuc3RhcnQ6IHtcbiAgICBoYW5kbGVyOiAnb25EcmFnU3RhcnQnXG4gIH0sXG4gIHBhbm1vdmU6IHtcbiAgICBoYW5kbGVyOiAnb25EcmFnJ1xuICB9LFxuICBwYW5lbmQ6IHtcbiAgICBoYW5kbGVyOiAnb25EcmFnRW5kJ1xuICB9XG59O1xuZXhwb3J0IGNvbnN0IE9QRVJBVElPTiA9IHtcbiAgRFJBVzogJ2RyYXcnLFxuICBNQVNLOiAnbWFzaycsXG4gIFRFUlJBSU46ICd0ZXJyYWluJ1xufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNvbnN0YW50cy5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///24088\n")},68315:function(__unused_webpack_module,__webpack_exports__,__webpack_require__){eval('\n// EXPORTS\n__webpack_require__.d(__webpack_exports__, {\n  "Z": function() { return /* binding */ Deck; }\n});\n\n// EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/esm/defineProperty.js\nvar defineProperty = __webpack_require__(82482);\n// EXTERNAL MODULE: ./node_modules/@luma.gl/engine/dist/esm/animation/timeline.js\nvar animation_timeline = __webpack_require__(48055);\n// EXTERNAL MODULE: ./node_modules/@deck.gl/core/dist/esm/lifecycle/constants.js\nvar constants = __webpack_require__(85409);\n// EXTERNAL MODULE: ./node_modules/@deck.gl/core/dist/esm/utils/log.js\nvar log = __webpack_require__(80744);\n// EXTERNAL MODULE: ./node_modules/@deck.gl/core/dist/esm/debug/index.js\nvar debug = __webpack_require__(63803);\n// EXTERNAL MODULE: ./node_modules/@deck.gl/core/dist/esm/utils/flatten.js\nvar flatten = __webpack_require__(61855);\n// EXTERNAL MODULE: ./node_modules/@probe.gl/stats/dist/esm/lib/stats.js + 2 modules\nvar lib_stats = __webpack_require__(23881);\n// EXTERNAL MODULE: ./node_modules/@deck.gl/core/dist/esm/lib/resource/resource-manager.js + 1 modules\nvar resource_manager = __webpack_require__(50007);\n// EXTERNAL MODULE: ./node_modules/@deck.gl/core/dist/esm/viewports/viewport.js\nvar viewport = __webpack_require__(7013);\n// EXTERNAL MODULE: ./node_modules/@deck.gl/core/dist/esm/shaderlib/index.js\nvar shaderlib = __webpack_require__(15621);\n;// CONCATENATED MODULE: ./node_modules/@deck.gl/core/dist/esm/lib/layer-manager.js\n\n\n\n\n\n\n\n\n\n\nconst TRACE_SET_LAYERS = \'layerManager.setLayers\';\nconst TRACE_ACTIVATE_VIEWPORT = \'layerManager.activateViewport\';\nclass LayerManager {\n  constructor(gl, {\n    deck,\n    stats,\n    viewport: _viewport,\n    timeline\n  } = {}) {\n    (0,defineProperty/* default */.Z)(this, "layers", void 0);\n\n    (0,defineProperty/* default */.Z)(this, "context", void 0);\n\n    (0,defineProperty/* default */.Z)(this, "resourceManager", void 0);\n\n    (0,defineProperty/* default */.Z)(this, "_lastRenderedLayers", []);\n\n    (0,defineProperty/* default */.Z)(this, "_needsRedraw", false);\n\n    (0,defineProperty/* default */.Z)(this, "_needsUpdate", false);\n\n    (0,defineProperty/* default */.Z)(this, "_nextLayers", null);\n\n    (0,defineProperty/* default */.Z)(this, "_debug", false);\n\n    (0,defineProperty/* default */.Z)(this, "activateViewport", viewport => {\n      (0,debug/* default */.Z)(TRACE_ACTIVATE_VIEWPORT, this, viewport);\n\n      if (viewport) {\n        this.context.viewport = viewport;\n      }\n    });\n\n    this.layers = [];\n    this.resourceManager = new resource_manager/* default */.Z({\n      gl,\n      protocol: \'deck://\'\n    });\n    this.context = {\n      mousePosition: null,\n      userData: {},\n      layerManager: this,\n      gl,\n      deck,\n      programManager: gl && (0,shaderlib/* createProgramManager */.bs)(gl),\n      stats: stats || new lib_stats/* default */.Z({\n        id: \'deck.gl\'\n      }),\n      viewport: _viewport || new viewport/* default */.Z({\n        id: \'DEFAULT-INITIAL-VIEWPORT\'\n      }),\n      timeline: timeline || new animation_timeline/* Timeline */.T(),\n      resourceManager: this.resourceManager,\n      onError: undefined\n    };\n    Object.seal(this);\n  }\n\n  finalize() {\n    this.resourceManager.finalize();\n\n    for (const layer of this.layers) {\n      this._finalizeLayer(layer);\n    }\n  }\n\n  needsRedraw(opts = {\n    clearRedrawFlags: false\n  }) {\n    let redraw = this._needsRedraw;\n\n    if (opts.clearRedrawFlags) {\n      this._needsRedraw = false;\n    }\n\n    for (const layer of this.layers) {\n      const layerNeedsRedraw = layer.getNeedsRedraw(opts);\n      redraw = redraw || layerNeedsRedraw;\n    }\n\n    return redraw;\n  }\n\n  needsUpdate() {\n    if (this._nextLayers && this._nextLayers !== this._lastRenderedLayers) {\n      return \'layers changed\';\n    }\n\n    return this._needsUpdate;\n  }\n\n  setNeedsRedraw(reason) {\n    this._needsRedraw = this._needsRedraw || reason;\n  }\n\n  setNeedsUpdate(reason) {\n    this._needsUpdate = this._needsUpdate || reason;\n  }\n\n  getLayers({\n    layerIds\n  } = {}) {\n    return layerIds ? this.layers.filter(layer => layerIds.find(layerId => layer.id.indexOf(layerId) === 0)) : this.layers;\n  }\n\n  setProps(props) {\n    if (\'debug\' in props) {\n      this._debug = props.debug;\n    }\n\n    if (\'userData\' in props) {\n      this.context.userData = props.userData;\n    }\n\n    if (\'layers\' in props) {\n      this._nextLayers = props.layers;\n    }\n\n    if (\'onError\' in props) {\n      this.context.onError = props.onError;\n    }\n  }\n\n  setLayers(newLayers, reason) {\n    (0,debug/* default */.Z)(TRACE_SET_LAYERS, this, reason, newLayers);\n    this._lastRenderedLayers = newLayers;\n    const flatLayers = (0,flatten/* flatten */.x)(newLayers, Boolean);\n\n    for (const layer of flatLayers) {\n      layer.context = this.context;\n    }\n\n    this._updateLayers(this.layers, flatLayers);\n  }\n\n  updateLayers() {\n    const reason = this.needsUpdate();\n\n    if (reason) {\n      this.setNeedsRedraw("updating layers: ".concat(reason));\n      this.setLayers(this._nextLayers || this._lastRenderedLayers, reason);\n    }\n\n    this._nextLayers = null;\n  }\n\n  _handleError(stage, error, layer) {\n    layer.raiseError(error, "".concat(stage, " of ").concat(layer));\n  }\n\n  _updateLayers(oldLayers, newLayers) {\n    const oldLayerMap = {};\n\n    for (const oldLayer of oldLayers) {\n      if (oldLayerMap[oldLayer.id]) {\n        log/* default.warn */.Z.warn("Multiple old layers with same id ".concat(oldLayer.id))();\n      } else {\n        oldLayerMap[oldLayer.id] = oldLayer;\n      }\n    }\n\n    const generatedLayers = [];\n\n    this._updateSublayersRecursively(newLayers, oldLayerMap, generatedLayers);\n\n    this._finalizeOldLayers(oldLayerMap);\n\n    let needsUpdate = false;\n\n    for (const layer of generatedLayers) {\n      if (layer.hasUniformTransition()) {\n        needsUpdate = "Uniform transition in ".concat(layer);\n        break;\n      }\n    }\n\n    this._needsUpdate = needsUpdate;\n    this.layers = generatedLayers;\n  }\n\n  _updateSublayersRecursively(newLayers, oldLayerMap, generatedLayers) {\n    for (const newLayer of newLayers) {\n      newLayer.context = this.context;\n      const oldLayer = oldLayerMap[newLayer.id];\n\n      if (oldLayer === null) {\n        log/* default.warn */.Z.warn("Multiple new layers with same id ".concat(newLayer.id))();\n      }\n\n      oldLayerMap[newLayer.id] = null;\n      let sublayers = null;\n\n      try {\n        if (this._debug && oldLayer !== newLayer) {\n          newLayer.validateProps();\n        }\n\n        if (!oldLayer) {\n          this._initializeLayer(newLayer);\n        } else {\n          this._transferLayerState(oldLayer, newLayer);\n\n          this._updateLayer(newLayer);\n        }\n\n        generatedLayers.push(newLayer);\n        sublayers = newLayer.isComposite ? newLayer.getSubLayers() : null;\n      } catch (err) {\n        this._handleError(\'matching\', err, newLayer);\n      }\n\n      if (sublayers) {\n        this._updateSublayersRecursively(sublayers, oldLayerMap, generatedLayers);\n      }\n    }\n  }\n\n  _finalizeOldLayers(oldLayerMap) {\n    for (const layerId in oldLayerMap) {\n      const layer = oldLayerMap[layerId];\n\n      if (layer) {\n        this._finalizeLayer(layer);\n      }\n    }\n  }\n\n  _initializeLayer(layer) {\n    try {\n      layer._initialize();\n\n      layer.lifecycle = constants/* LIFECYCLE.INITIALIZED */.dt.INITIALIZED;\n    } catch (err) {\n      this._handleError(\'initialization\', err, layer);\n    }\n  }\n\n  _transferLayerState(oldLayer, newLayer) {\n    newLayer._transferState(oldLayer);\n\n    newLayer.lifecycle = constants/* LIFECYCLE.MATCHED */.dt.MATCHED;\n\n    if (newLayer !== oldLayer) {\n      oldLayer.lifecycle = constants/* LIFECYCLE.AWAITING_GC */.dt.AWAITING_GC;\n    }\n  }\n\n  _updateLayer(layer) {\n    try {\n      layer._update();\n    } catch (err) {\n      this._handleError(\'update\', err, layer);\n    }\n  }\n\n  _finalizeLayer(layer) {\n    this._needsRedraw = this._needsRedraw || "finalized ".concat(layer);\n    layer.lifecycle = constants/* LIFECYCLE.AWAITING_FINALIZATION */.dt.AWAITING_FINALIZATION;\n\n    try {\n      layer._finalize();\n\n      layer.lifecycle = constants/* LIFECYCLE.FINALIZED */.dt.FINALIZED;\n    } catch (err) {\n      this._handleError(\'finalization\', err, layer);\n    }\n  }\n\n}\n//# sourceMappingURL=layer-manager.js.map\n// EXTERNAL MODULE: ./node_modules/@deck.gl/core/dist/esm/lib/view-manager.js\nvar view_manager = __webpack_require__(34779);\n// EXTERNAL MODULE: ./node_modules/@deck.gl/core/dist/esm/views/map-view.js + 2 modules\nvar map_view = __webpack_require__(56602);\n// EXTERNAL MODULE: ./node_modules/@deck.gl/core/dist/esm/utils/deep-equal.js\nvar deep_equal = __webpack_require__(46871);\n// EXTERNAL MODULE: ./node_modules/@luma.gl/engine/dist/esm/lib/program-manager.js + 8 modules\nvar program_manager = __webpack_require__(43426);\n// EXTERNAL MODULE: ./node_modules/@luma.gl/webgl/dist/esm/classes/texture-2d.js + 1 modules\nvar texture_2d = __webpack_require__(51621);\n;// CONCATENATED MODULE: ./node_modules/@deck.gl/core/dist/esm/effects/lighting/ambient-light.js\n\nconst DEFAULT_LIGHT_COLOR = [255, 255, 255];\nconst DEFAULT_LIGHT_INTENSITY = 1.0;\nlet idCount = 0;\nclass AmbientLight {\n  constructor(props = {}) {\n    (0,defineProperty/* default */.Z)(this, "id", void 0);\n\n    (0,defineProperty/* default */.Z)(this, "color", void 0);\n\n    (0,defineProperty/* default */.Z)(this, "intensity", void 0);\n\n    (0,defineProperty/* default */.Z)(this, "type", \'ambient\');\n\n    const {\n      color = DEFAULT_LIGHT_COLOR\n    } = props;\n    const {\n      intensity = DEFAULT_LIGHT_INTENSITY\n    } = props;\n    this.id = props.id || "ambient-".concat(idCount++);\n    this.color = color;\n    this.intensity = intensity;\n  }\n\n}\n//# sourceMappingURL=ambient-light.js.map\n// EXTERNAL MODULE: ./node_modules/@math.gl/core/dist/esm/classes/vector3.js\nvar vector3 = __webpack_require__(43855);\n;// CONCATENATED MODULE: ./node_modules/@deck.gl/core/dist/esm/effects/lighting/directional-light.js\n\n\nconst directional_light_DEFAULT_LIGHT_COLOR = [255, 255, 255];\nconst directional_light_DEFAULT_LIGHT_INTENSITY = 1.0;\nconst DEFAULT_LIGHT_DIRECTION = [0.0, 0.0, -1.0];\nlet directional_light_idCount = 0;\nclass DirectionalLight {\n  constructor(props = {}) {\n    (0,defineProperty/* default */.Z)(this, "id", void 0);\n\n    (0,defineProperty/* default */.Z)(this, "color", void 0);\n\n    (0,defineProperty/* default */.Z)(this, "intensity", void 0);\n\n    (0,defineProperty/* default */.Z)(this, "type", \'directional\');\n\n    (0,defineProperty/* default */.Z)(this, "direction", void 0);\n\n    (0,defineProperty/* default */.Z)(this, "shadow", void 0);\n\n    const {\n      color = directional_light_DEFAULT_LIGHT_COLOR\n    } = props;\n    const {\n      intensity = directional_light_DEFAULT_LIGHT_INTENSITY\n    } = props;\n    const {\n      direction = DEFAULT_LIGHT_DIRECTION\n    } = props;\n    const {\n      _shadow = false\n    } = props;\n    this.id = props.id || "directional-".concat(directional_light_idCount++);\n    this.color = color;\n    this.intensity = intensity;\n    this.type = \'directional\';\n    this.direction = new vector3/* default */.Z(direction).normalize().toArray();\n    this.shadow = _shadow;\n  }\n\n  getProjectedLight(opts) {\n    return this;\n  }\n\n}\n//# sourceMappingURL=directional-light.js.map\n// EXTERNAL MODULE: ./node_modules/@math.gl/core/dist/esm/classes/matrix4.js\nvar matrix4 = __webpack_require__(85451);\n// EXTERNAL MODULE: ./node_modules/@deck.gl/core/dist/esm/passes/shadow-pass.js\nvar shadow_pass = __webpack_require__(22944);\n// EXTERNAL MODULE: ./node_modules/@deck.gl/core/dist/esm/shaderlib/shadow/shadow.js\nvar shadow = __webpack_require__(33115);\n;// CONCATENATED MODULE: ./node_modules/@deck.gl/core/dist/esm/effects/lighting/lighting-effect.js\n\n\n\n\n\n\n\nconst DEFAULT_AMBIENT_LIGHT_PROPS = {\n  color: [255, 255, 255],\n  intensity: 1.0\n};\nconst DEFAULT_DIRECTIONAL_LIGHT_PROPS = [{\n  color: [255, 255, 255],\n  intensity: 1.0,\n  direction: [-1, 3, -1]\n}, {\n  color: [255, 255, 255],\n  intensity: 0.9,\n  direction: [1, -8, -2.5]\n}];\nconst DEFAULT_SHADOW_COLOR = [0, 0, 0, 200 / 255];\nclass LightingEffect {\n  constructor(props = {}) {\n    (0,defineProperty/* default */.Z)(this, "id", \'lighting-effect\');\n\n    (0,defineProperty/* default */.Z)(this, "props", void 0);\n\n    (0,defineProperty/* default */.Z)(this, "shadowColor", DEFAULT_SHADOW_COLOR);\n\n    (0,defineProperty/* default */.Z)(this, "shadow", void 0);\n\n    (0,defineProperty/* default */.Z)(this, "ambientLight", void 0);\n\n    (0,defineProperty/* default */.Z)(this, "directionalLights", void 0);\n\n    (0,defineProperty/* default */.Z)(this, "pointLights", void 0);\n\n    (0,defineProperty/* default */.Z)(this, "shadowPasses", []);\n\n    (0,defineProperty/* default */.Z)(this, "shadowMaps", []);\n\n    (0,defineProperty/* default */.Z)(this, "dummyShadowMap", null);\n\n    (0,defineProperty/* default */.Z)(this, "programManager", void 0);\n\n    (0,defineProperty/* default */.Z)(this, "shadowMatrices", void 0);\n\n    this.setProps(props);\n  }\n\n  setProps(props) {\n    this.ambientLight = null;\n    this.directionalLights = [];\n    this.pointLights = [];\n\n    for (const key in props) {\n      const lightSource = props[key];\n\n      switch (lightSource.type) {\n        case \'ambient\':\n          this.ambientLight = lightSource;\n          break;\n\n        case \'directional\':\n          this.directionalLights.push(lightSource);\n          break;\n\n        case \'point\':\n          this.pointLights.push(lightSource);\n          break;\n\n        default:\n      }\n    }\n\n    this._applyDefaultLights();\n\n    this.shadow = this.directionalLights.some(light => light.shadow);\n    this.props = props;\n  }\n\n  preRender(gl, {\n    layers,\n    layerFilter,\n    viewports,\n    onViewportActive,\n    views\n  }) {\n    if (!this.shadow) return;\n    this.shadowMatrices = this._calculateMatrices();\n\n    if (this.shadowPasses.length === 0) {\n      this._createShadowPasses(gl);\n    }\n\n    if (!this.programManager) {\n      this.programManager = program_manager/* default.getDefaultProgramManager */.Z.getDefaultProgramManager(gl);\n\n      if (shadow/* default */.Z) {\n        this.programManager.addDefaultModule(shadow/* default */.Z);\n      }\n    }\n\n    if (!this.dummyShadowMap) {\n      this.dummyShadowMap = new texture_2d/* default */.Z(gl, {\n        width: 1,\n        height: 1\n      });\n    }\n\n    for (let i = 0; i < this.shadowPasses.length; i++) {\n      const shadowPass = this.shadowPasses[i];\n      shadowPass.render({\n        layers,\n        layerFilter,\n        viewports,\n        onViewportActive,\n        views,\n        moduleParameters: {\n          shadowLightId: i,\n          dummyShadowMap: this.dummyShadowMap,\n          shadowMatrices: this.shadowMatrices\n        }\n      });\n    }\n  }\n\n  getModuleParameters(layer) {\n    const parameters = this.shadow ? {\n      shadowMaps: this.shadowMaps,\n      dummyShadowMap: this.dummyShadowMap,\n      shadowColor: this.shadowColor,\n      shadowMatrices: this.shadowMatrices\n    } : {};\n    parameters.lightSources = {\n      ambientLight: this.ambientLight,\n      directionalLights: this.directionalLights.map(directionalLight => directionalLight.getProjectedLight({\n        layer\n      })),\n      pointLights: this.pointLights.map(pointLight => pointLight.getProjectedLight({\n        layer\n      }))\n    };\n    return parameters;\n  }\n\n  cleanup() {\n    for (const shadowPass of this.shadowPasses) {\n      shadowPass.delete();\n    }\n\n    this.shadowPasses.length = 0;\n    this.shadowMaps.length = 0;\n\n    if (this.dummyShadowMap) {\n      this.dummyShadowMap.delete();\n      this.dummyShadowMap = null;\n    }\n\n    if (this.shadow && this.programManager) {\n      this.programManager.removeDefaultModule(shadow/* default */.Z);\n      this.programManager = null;\n    }\n  }\n\n  _calculateMatrices() {\n    const lightMatrices = [];\n\n    for (const light of this.directionalLights) {\n      const viewMatrix = new matrix4/* default */.Z().lookAt({\n        eye: new vector3/* default */.Z(light.direction).negate()\n      });\n      lightMatrices.push(viewMatrix);\n    }\n\n    return lightMatrices;\n  }\n\n  _createShadowPasses(gl) {\n    for (let i = 0; i < this.directionalLights.length; i++) {\n      const shadowPass = new shadow_pass/* default */.Z(gl);\n      this.shadowPasses[i] = shadowPass;\n      this.shadowMaps[i] = shadowPass.shadowMap;\n    }\n  }\n\n  _applyDefaultLights() {\n    const {\n      ambientLight,\n      pointLights,\n      directionalLights\n    } = this;\n\n    if (!ambientLight && pointLights.length === 0 && directionalLights.length === 0) {\n      this.ambientLight = new AmbientLight(DEFAULT_AMBIENT_LIGHT_PROPS);\n      this.directionalLights.push(new DirectionalLight(DEFAULT_DIRECTIONAL_LIGHT_PROPS[0]), new DirectionalLight(DEFAULT_DIRECTIONAL_LIGHT_PROPS[1]));\n    }\n  }\n\n}\n//# sourceMappingURL=lighting-effect.js.map\n;// CONCATENATED MODULE: ./node_modules/@deck.gl/core/dist/esm/lib/effect-manager.js\n\n\n\nconst DEFAULT_LIGHTING_EFFECT = new LightingEffect();\n\nfunction compareEffects(e1, e2) {\n  var _e1$order, _e2$order;\n\n  const o1 = (_e1$order = e1.order) !== null && _e1$order !== void 0 ? _e1$order : Infinity;\n  const o2 = (_e2$order = e2.order) !== null && _e2$order !== void 0 ? _e2$order : Infinity;\n  return o1 - o2;\n}\n\nclass EffectManager {\n  constructor() {\n    (0,defineProperty/* default */.Z)(this, "effects", void 0);\n\n    (0,defineProperty/* default */.Z)(this, "_resolvedEffects", []);\n\n    (0,defineProperty/* default */.Z)(this, "_defaultEffects", []);\n\n    (0,defineProperty/* default */.Z)(this, "_needsRedraw", void 0);\n\n    this.effects = [];\n    this._needsRedraw = \'Initial render\';\n\n    this._setEffects([]);\n  }\n\n  addDefaultEffect(effect) {\n    const defaultEffects = this._defaultEffects;\n\n    if (!defaultEffects.find(e => e.id === effect.id)) {\n      const index = defaultEffects.findIndex(e => compareEffects(e, effect) > 0);\n\n      if (index < 0) {\n        defaultEffects.push(effect);\n      } else {\n        defaultEffects.splice(index, 0, effect);\n      }\n\n      this._setEffects(this.effects);\n    }\n  }\n\n  setProps(props) {\n    if (\'effects\' in props) {\n      if (!(0,deep_equal/* deepEqual */.v)(props.effects, this.effects, 1)) {\n        this._setEffects(props.effects);\n      }\n    }\n  }\n\n  needsRedraw(opts = {\n    clearRedrawFlags: false\n  }) {\n    const redraw = this._needsRedraw;\n\n    if (opts.clearRedrawFlags) {\n      this._needsRedraw = false;\n    }\n\n    return redraw;\n  }\n\n  getEffects() {\n    return this._resolvedEffects;\n  }\n\n  _setEffects(effects) {\n    const oldEffectsMap = {};\n\n    for (const effect of this.effects) {\n      oldEffectsMap[effect.id] = effect;\n    }\n\n    const nextEffects = [];\n\n    for (const effect of effects) {\n      const oldEffect = oldEffectsMap[effect.id];\n\n      if (oldEffect && oldEffect !== effect) {\n        if (oldEffect.setProps) {\n          oldEffect.setProps(effect.props);\n          nextEffects.push(oldEffect);\n        } else {\n          oldEffect.cleanup();\n          nextEffects.push(effect);\n        }\n      } else {\n        nextEffects.push(effect);\n      }\n\n      delete oldEffectsMap[effect.id];\n    }\n\n    for (const removedEffectId in oldEffectsMap) {\n      oldEffectsMap[removedEffectId].cleanup();\n    }\n\n    this.effects = nextEffects;\n    this._resolvedEffects = nextEffects.concat(this._defaultEffects);\n\n    if (!effects.some(effect => effect instanceof LightingEffect)) {\n      this._resolvedEffects.push(DEFAULT_LIGHTING_EFFECT);\n    }\n\n    this._needsRedraw = \'effects changed\';\n  }\n\n  finalize() {\n    for (const effect of this._resolvedEffects) {\n      effect.cleanup();\n    }\n\n    this.effects.length = 0;\n    this._resolvedEffects.length = 0;\n    this._defaultEffects.length = 0;\n  }\n\n}\n//# sourceMappingURL=effect-manager.js.map\n// EXTERNAL MODULE: ./node_modules/@deck.gl/core/dist/esm/passes/draw-layers-pass.js\nvar draw_layers_pass = __webpack_require__(13169);\n// EXTERNAL MODULE: ./node_modules/@deck.gl/core/dist/esm/passes/pick-layers-pass.js\nvar pick_layers_pass = __webpack_require__(70930);\n// EXTERNAL MODULE: ./node_modules/@luma.gl/webgl/dist/esm/classes/framebuffer.js\nvar framebuffer = __webpack_require__(53849);\n;// CONCATENATED MODULE: ./node_modules/@deck.gl/core/dist/esm/lib/deck-renderer.js\n\n\n\n\n\nconst TRACE_RENDER_LAYERS = \'deckRenderer.renderLayers\';\nclass DeckRenderer {\n  constructor(gl) {\n    (0,defineProperty/* default */.Z)(this, "gl", void 0);\n\n    (0,defineProperty/* default */.Z)(this, "layerFilter", void 0);\n\n    (0,defineProperty/* default */.Z)(this, "drawPickingColors", void 0);\n\n    (0,defineProperty/* default */.Z)(this, "drawLayersPass", void 0);\n\n    (0,defineProperty/* default */.Z)(this, "pickLayersPass", void 0);\n\n    (0,defineProperty/* default */.Z)(this, "renderCount", void 0);\n\n    (0,defineProperty/* default */.Z)(this, "_needsRedraw", void 0);\n\n    (0,defineProperty/* default */.Z)(this, "renderBuffers", void 0);\n\n    (0,defineProperty/* default */.Z)(this, "lastPostProcessEffect", void 0);\n\n    this.gl = gl;\n    this.layerFilter = null;\n    this.drawPickingColors = false;\n    this.drawLayersPass = new draw_layers_pass/* default */.Z(gl);\n    this.pickLayersPass = new pick_layers_pass/* default */.Z(gl);\n    this.renderCount = 0;\n    this._needsRedraw = \'Initial render\';\n    this.renderBuffers = [];\n    this.lastPostProcessEffect = null;\n  }\n\n  setProps(props) {\n    if (this.layerFilter !== props.layerFilter) {\n      this.layerFilter = props.layerFilter;\n      this._needsRedraw = \'layerFilter changed\';\n    }\n\n    if (this.drawPickingColors !== props.drawPickingColors) {\n      this.drawPickingColors = props.drawPickingColors;\n      this._needsRedraw = \'drawPickingColors changed\';\n    }\n  }\n\n  renderLayers(opts) {\n    const layerPass = this.drawPickingColors ? this.pickLayersPass : this.drawLayersPass;\n    const renderOpts = {\n      layerFilter: this.layerFilter,\n      isPicking: this.drawPickingColors,\n      ...opts,\n      target: opts.target || framebuffer/* default.getDefaultFramebuffer */.Z.getDefaultFramebuffer(this.gl)\n    };\n\n    if (renderOpts.effects) {\n      this._preRender(renderOpts.effects, renderOpts);\n    }\n\n    const outputBuffer = this.lastPostProcessEffect ? this.renderBuffers[0] : renderOpts.target;\n    const renderStats = layerPass.render({ ...renderOpts,\n      target: outputBuffer\n    });\n\n    if (renderOpts.effects) {\n      this._postRender(renderOpts.effects, renderOpts);\n    }\n\n    this.renderCount++;\n    (0,debug/* default */.Z)(TRACE_RENDER_LAYERS, this, renderStats, opts);\n  }\n\n  needsRedraw(opts = {\n    clearRedrawFlags: false\n  }) {\n    const redraw = this._needsRedraw;\n\n    if (opts.clearRedrawFlags) {\n      this._needsRedraw = false;\n    }\n\n    return redraw;\n  }\n\n  finalize() {\n    const {\n      renderBuffers\n    } = this;\n\n    for (const buffer of renderBuffers) {\n      buffer.delete();\n    }\n\n    renderBuffers.length = 0;\n  }\n\n  _preRender(effects, opts) {\n    this.lastPostProcessEffect = null;\n    opts.preRenderStats = opts.preRenderStats || {};\n\n    for (const effect of effects) {\n      opts.preRenderStats[effect.id] = effect.preRender(this.gl, opts);\n\n      if (effect.postRender) {\n        this.lastPostProcessEffect = effect.id;\n      }\n    }\n\n    if (this.lastPostProcessEffect) {\n      this._resizeRenderBuffers();\n    }\n  }\n\n  _resizeRenderBuffers() {\n    const {\n      renderBuffers\n    } = this;\n\n    if (renderBuffers.length === 0) {\n      renderBuffers.push(new framebuffer/* default */.Z(this.gl), new framebuffer/* default */.Z(this.gl));\n    }\n\n    for (const buffer of renderBuffers) {\n      buffer.resize();\n    }\n  }\n\n  _postRender(effects, opts) {\n    const {\n      renderBuffers\n    } = this;\n    const params = { ...opts,\n      inputBuffer: renderBuffers[0],\n      swapBuffer: renderBuffers[1],\n      target: null\n    };\n\n    for (const effect of effects) {\n      if (effect.postRender) {\n        if (effect.id === this.lastPostProcessEffect) {\n          params.target = opts.target;\n          effect.postRender(this.gl, params);\n          break;\n        }\n\n        const buffer = effect.postRender(this.gl, params);\n        params.inputBuffer = buffer;\n        params.swapBuffer = buffer === renderBuffers[0] ? renderBuffers[1] : renderBuffers[0];\n      }\n    }\n  }\n\n}\n//# sourceMappingURL=deck-renderer.js.map\n// EXTERNAL MODULE: ./node_modules/@luma.gl/gltools/dist/esm/index.js + 13 modules\nvar esm = __webpack_require__(1418);\n// EXTERNAL MODULE: ./node_modules/@luma.gl/webgl/dist/esm/classes/copy-and-blit.js + 1 modules\nvar copy_and_blit = __webpack_require__(81913);\n// EXTERNAL MODULE: ./node_modules/@deck.gl/core/dist/esm/lib/picking/query-object.js\nvar query_object = __webpack_require__(96941);\n// EXTERNAL MODULE: ./node_modules/@deck.gl/core/dist/esm/lib/picking/pick-info.js\nvar pick_info = __webpack_require__(87838);\n;// CONCATENATED MODULE: ./node_modules/@deck.gl/core/dist/esm/lib/deck-picker.js\n\n\n\n\n\nclass DeckPicker {\n  constructor(gl) {\n    (0,defineProperty/* default */.Z)(this, "gl", void 0);\n\n    (0,defineProperty/* default */.Z)(this, "pickingFBO", void 0);\n\n    (0,defineProperty/* default */.Z)(this, "depthFBO", void 0);\n\n    (0,defineProperty/* default */.Z)(this, "pickLayersPass", void 0);\n\n    (0,defineProperty/* default */.Z)(this, "layerFilter", void 0);\n\n    (0,defineProperty/* default */.Z)(this, "lastPickedInfo", void 0);\n\n    (0,defineProperty/* default */.Z)(this, "_pickable", true);\n\n    this.gl = gl;\n    this.pickLayersPass = new pick_layers_pass/* default */.Z(gl);\n    this.lastPickedInfo = {\n      index: -1,\n      layerId: null,\n      info: null\n    };\n  }\n\n  setProps(props) {\n    if (\'layerFilter\' in props) {\n      this.layerFilter = props.layerFilter;\n    }\n\n    if (\'_pickable\' in props) {\n      this._pickable = props._pickable;\n    }\n  }\n\n  finalize() {\n    if (this.pickingFBO) {\n      this.pickingFBO.delete();\n    }\n\n    if (this.depthFBO) {\n      this.depthFBO.color.delete();\n      this.depthFBO.delete();\n    }\n  }\n\n  pickObject(opts) {\n    return this._pickClosestObject(opts);\n  }\n\n  pickObjects(opts) {\n    return this._pickVisibleObjects(opts);\n  }\n\n  getLastPickedObject({\n    x,\n    y,\n    layers,\n    viewports\n  }, lastPickedInfo = this.lastPickedInfo.info) {\n    const lastPickedLayerId = lastPickedInfo && lastPickedInfo.layer && lastPickedInfo.layer.id;\n    const lastPickedViewportId = lastPickedInfo && lastPickedInfo.viewport && lastPickedInfo.viewport.id;\n    const layer = lastPickedLayerId ? layers.find(l => l.id === lastPickedLayerId) : null;\n    const viewport = lastPickedViewportId && viewports.find(v => v.id === lastPickedViewportId) || viewports[0];\n    const coordinate = viewport && viewport.unproject([x - viewport.x, y - viewport.y]);\n    const info = {\n      x,\n      y,\n      viewport,\n      coordinate,\n      layer\n    };\n    return { ...lastPickedInfo,\n      ...info\n    };\n  }\n\n  _resizeBuffer() {\n    var _this$pickingFBO, _this$depthFBO;\n\n    const {\n      gl\n    } = this;\n\n    if (!this.pickingFBO) {\n      this.pickingFBO = new framebuffer/* default */.Z(gl);\n\n      if (framebuffer/* default.isSupported */.Z.isSupported(gl, {\n        colorBufferFloat: true\n      })) {\n        const depthFBO = new framebuffer/* default */.Z(gl);\n        depthFBO.attach({\n          [36064]: new texture_2d/* default */.Z(gl, {\n            format: (0,esm/* isWebGL2 */.D0)(gl) ? 34836 : 6408,\n            type: 5126\n          })\n        });\n        this.depthFBO = depthFBO;\n      }\n    }\n\n    (_this$pickingFBO = this.pickingFBO) === null || _this$pickingFBO === void 0 ? void 0 : _this$pickingFBO.resize({\n      width: gl.canvas.width,\n      height: gl.canvas.height\n    });\n    (_this$depthFBO = this.depthFBO) === null || _this$depthFBO === void 0 ? void 0 : _this$depthFBO.resize({\n      width: gl.canvas.width,\n      height: gl.canvas.height\n    });\n  }\n\n  _getPickable(layers) {\n    if (this._pickable === false) {\n      return null;\n    }\n\n    const pickableLayers = layers.filter(layer => this.pickLayersPass.shouldDrawLayer(layer) && !layer.isComposite);\n    return pickableLayers.length ? pickableLayers : null;\n  }\n\n  _pickClosestObject({\n    layers,\n    views,\n    viewports,\n    x,\n    y,\n    radius = 0,\n    depth = 1,\n    mode = \'query\',\n    unproject3D,\n    onViewportActive,\n    effects\n  }) {\n    const pickableLayers = this._getPickable(layers);\n\n    const pixelRatio = (0,esm/* cssToDeviceRatio */.w)(this.gl);\n\n    if (!pickableLayers) {\n      return {\n        result: [],\n        emptyInfo: (0,pick_info/* getEmptyPickingInfo */.wy)({\n          viewports,\n          x,\n          y,\n          pixelRatio\n        })\n      };\n    }\n\n    this._resizeBuffer();\n\n    const devicePixelRange = (0,esm/* cssToDevicePixels */.JY)(this.gl, [x, y], true);\n    const devicePixel = [devicePixelRange.x + Math.floor(devicePixelRange.width / 2), devicePixelRange.y + Math.floor(devicePixelRange.height / 2)];\n    const deviceRadius = Math.round(radius * pixelRatio);\n    const {\n      width,\n      height\n    } = this.pickingFBO;\n\n    const deviceRect = this._getPickingRect({\n      deviceX: devicePixel[0],\n      deviceY: devicePixel[1],\n      deviceRadius,\n      deviceWidth: width,\n      deviceHeight: height\n    });\n\n    const cullRect = {\n      x: x - radius,\n      y: y - radius,\n      width: radius * 2 + 1,\n      height: radius * 2 + 1\n    };\n    let infos;\n    const result = [];\n    const affectedLayers = new Set();\n\n    for (let i = 0; i < depth; i++) {\n      let pickInfo;\n\n      if (deviceRect) {\n        const pickedResult = this._drawAndSample({\n          layers: pickableLayers,\n          views,\n          viewports,\n          onViewportActive,\n          deviceRect,\n          cullRect,\n          effects,\n          pass: "picking:".concat(mode)\n        });\n\n        pickInfo = (0,query_object/* getClosestObject */.T)({ ...pickedResult,\n          deviceX: devicePixel[0],\n          deviceY: devicePixel[1],\n          deviceRadius,\n          deviceRect\n        });\n      } else {\n        pickInfo = {\n          pickedColor: null,\n          pickedObjectIndex: -1\n        };\n      }\n\n      let z;\n\n      if (pickInfo.pickedLayer && unproject3D && this.depthFBO) {\n        const {\n          pickedColors: pickedColors2\n        } = this._drawAndSample({\n          layers: [pickInfo.pickedLayer],\n          views,\n          viewports,\n          onViewportActive,\n          deviceRect: {\n            x: pickInfo.pickedX,\n            y: pickInfo.pickedY,\n            width: 1,\n            height: 1\n          },\n          cullRect,\n          effects,\n          pass: "picking:".concat(mode, ":z")\n        }, true);\n\n        if (pickedColors2[3]) {\n          z = pickedColors2[0];\n        }\n      }\n\n      if (pickInfo.pickedLayer && i + 1 < depth) {\n        affectedLayers.add(pickInfo.pickedLayer);\n        pickInfo.pickedLayer.disablePickingIndex(pickInfo.pickedObjectIndex);\n      }\n\n      infos = (0,pick_info/* processPickInfo */.I5)({\n        pickInfo,\n        lastPickedInfo: this.lastPickedInfo,\n        mode,\n        layers: pickableLayers,\n        viewports,\n        x,\n        y,\n        z,\n        pixelRatio\n      });\n\n      for (const info of infos.values()) {\n        if (info.layer) {\n          result.push(info);\n        }\n      }\n\n      if (!pickInfo.pickedColor) {\n        break;\n      }\n    }\n\n    for (const layer of affectedLayers) {\n      layer.restorePickingColors();\n    }\n\n    return {\n      result,\n      emptyInfo: infos.get(null)\n    };\n  }\n\n  _pickVisibleObjects({\n    layers,\n    views,\n    viewports,\n    x,\n    y,\n    width = 1,\n    height = 1,\n    mode = \'query\',\n    maxObjects = null,\n    onViewportActive,\n    effects\n  }) {\n    const pickableLayers = this._getPickable(layers);\n\n    if (!pickableLayers) {\n      return [];\n    }\n\n    this._resizeBuffer();\n\n    const pixelRatio = (0,esm/* cssToDeviceRatio */.w)(this.gl);\n    const leftTop = (0,esm/* cssToDevicePixels */.JY)(this.gl, [x, y], true);\n    const deviceLeft = leftTop.x;\n    const deviceTop = leftTop.y + leftTop.height;\n    const rightBottom = (0,esm/* cssToDevicePixels */.JY)(this.gl, [x + width, y + height], true);\n    const deviceRight = rightBottom.x + rightBottom.width;\n    const deviceBottom = rightBottom.y;\n    const deviceRect = {\n      x: deviceLeft,\n      y: deviceBottom,\n      width: deviceRight - deviceLeft,\n      height: deviceTop - deviceBottom\n    };\n\n    const pickedResult = this._drawAndSample({\n      layers: pickableLayers,\n      views,\n      viewports,\n      onViewportActive,\n      deviceRect,\n      cullRect: {\n        x,\n        y,\n        width,\n        height\n      },\n      effects,\n      pass: "picking:".concat(mode)\n    });\n\n    const pickInfos = (0,query_object/* getUniqueObjects */.K)(pickedResult);\n    const uniqueInfos = new Map();\n    const isMaxObjects = Number.isFinite(maxObjects);\n\n    for (let i = 0; i < pickInfos.length; i++) {\n      if (isMaxObjects && maxObjects && uniqueInfos.size >= maxObjects) {\n        break;\n      }\n\n      const pickInfo = pickInfos[i];\n      let info = {\n        color: pickInfo.pickedColor,\n        layer: null,\n        index: pickInfo.pickedObjectIndex,\n        picked: true,\n        x,\n        y,\n        pixelRatio\n      };\n      info = (0,pick_info/* getLayerPickingInfo */.iD)({\n        layer: pickInfo.pickedLayer,\n        info,\n        mode\n      });\n\n      if (!uniqueInfos.has(info.object)) {\n        uniqueInfos.set(info.object, info);\n      }\n    }\n\n    return Array.from(uniqueInfos.values());\n  }\n\n  _drawAndSample({\n    layers,\n    views,\n    viewports,\n    onViewportActive,\n    deviceRect,\n    cullRect,\n    effects,\n    pass\n  }, pickZ = false) {\n    const pickingFBO = pickZ ? this.depthFBO : this.pickingFBO;\n    const opts = {\n      layers,\n      layerFilter: this.layerFilter,\n      views,\n      viewports,\n      onViewportActive,\n      pickingFBO,\n      deviceRect,\n      cullRect,\n      effects,\n      pass,\n      pickZ,\n      preRenderStats: {}\n    };\n\n    for (const effect of effects) {\n      if (effect.useInPicking) {\n        opts.preRenderStats[effect.id] = effect.preRender(this.gl, opts);\n      }\n    }\n\n    const {\n      decodePickingColor\n    } = this.pickLayersPass.render(opts);\n    const {\n      x,\n      y,\n      width,\n      height\n    } = deviceRect;\n    const pickedColors = new (pickZ ? Float32Array : Uint8Array)(width * height * 4);\n    (0,copy_and_blit/* readPixelsToArray */.z6)(pickingFBO, {\n      sourceX: x,\n      sourceY: y,\n      sourceWidth: width,\n      sourceHeight: height,\n      target: pickedColors\n    });\n    return {\n      pickedColors,\n      decodePickingColor\n    };\n  }\n\n  _getPickingRect({\n    deviceX,\n    deviceY,\n    deviceRadius,\n    deviceWidth,\n    deviceHeight\n  }) {\n    const x = Math.max(0, deviceX - deviceRadius);\n    const y = Math.max(0, deviceY - deviceRadius);\n    const width = Math.min(deviceWidth, deviceX + deviceRadius + 1) - x;\n    const height = Math.min(deviceHeight, deviceY + deviceRadius + 1) - y;\n\n    if (width <= 0 || height <= 0) {\n      return null;\n    }\n\n    return {\n      x,\n      y,\n      width,\n      height\n    };\n  }\n\n}\n//# sourceMappingURL=deck-picker.js.map\n// EXTERNAL MODULE: ./node_modules/@deck.gl/core/dist/esm/lib/tooltip.js\nvar tooltip = __webpack_require__(81862);\n// EXTERNAL MODULE: ./node_modules/@deck.gl/core/dist/esm/utils/typed-array-manager.js\nvar typed_array_manager = __webpack_require__(36610);\n// EXTERNAL MODULE: ./node_modules/@loaders.gl/core/dist/esm/lib/api/register-loaders.js\nvar register_loaders = __webpack_require__(6228);\n// EXTERNAL MODULE: ./node_modules/@loaders.gl/images/dist/esm/image-loader.js + 8 modules\nvar image_loader = __webpack_require__(54022);\n// EXTERNAL MODULE: ./node_modules/@deck.gl/core/dist/esm/utils/json-loader.js\nvar json_loader = __webpack_require__(6610);\n;// CONCATENATED MODULE: ./node_modules/@deck.gl/core/dist/esm/lib/init.js\n\n\n\n\n\n\nfunction checkVersion() {\n  const version =  true ? "8.9.4" : 0;\n  const existingVersion = globalThis.deck && globalThis.deck.VERSION;\n\n  if (existingVersion && existingVersion !== version) {\n    throw new Error("deck.gl - multiple versions detected: ".concat(existingVersion, " vs ").concat(version));\n  }\n\n  if (!existingVersion) {\n    log/* default.log */.Z.log(1, "deck.gl ".concat(version))();\n    globalThis.deck = { ...globalThis.deck,\n      VERSION: version,\n      version,\n      log: log/* default */.Z,\n      _registerLoggers: debug/* register */.z\n    };\n    (0,register_loaders/* registerLoaders */.fh)([json_loader/* default */.Z, [image_loader/* ImageLoader */.S, {\n      imagebitmap: {\n        premultiplyAlpha: \'none\'\n      }\n    }]]);\n  }\n\n  return version;\n}\n\nconst VERSION = checkVersion();\n//# sourceMappingURL=init.js.map\n// EXTERNAL MODULE: ./node_modules/@probe.gl/env/dist/esm/lib/get-browser.js\nvar get_browser = __webpack_require__(3485);\n// EXTERNAL MODULE: ./node_modules/@luma.gl/engine/dist/esm/lib/animation-loop.js\nvar animation_loop = __webpack_require__(16816);\n// EXTERNAL MODULE: ./node_modules/@luma.gl/webgl/dist/esm/init.js\nvar init = __webpack_require__(49835);\n// EXTERNAL MODULE: ./node_modules/mjolnir.js/dist/esm/index.js + 12 modules\nvar dist_esm = __webpack_require__(12798);\n// EXTERNAL MODULE: ./node_modules/@deck.gl/core/dist/esm/utils/assert.js\nvar assert = __webpack_require__(75304);\n// EXTERNAL MODULE: ./node_modules/@deck.gl/core/dist/esm/lib/constants.js\nvar lib_constants = __webpack_require__(24088);\n;// CONCATENATED MODULE: ./node_modules/@deck.gl/core/dist/esm/lib/deck.js\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunction noop() {}\n\nconst getCursor = ({\n  isDragging\n}) => isDragging ? \'grabbing\' : \'grab\';\n\nconst defaultProps = {\n  id: \'\',\n  width: \'100%\',\n  height: \'100%\',\n  style: null,\n  viewState: null,\n  initialViewState: null,\n  pickingRadius: 0,\n  layerFilter: null,\n  glOptions: {},\n  parameters: {},\n  parent: null,\n  gl: null,\n  canvas: null,\n  layers: [],\n  effects: [],\n  views: null,\n  controller: null,\n  useDevicePixels: true,\n  touchAction: \'none\',\n  eventRecognizerOptions: {},\n  _framebuffer: null,\n  _animate: false,\n  _pickable: true,\n  _typedArrayManagerProps: {},\n  _customRender: null,\n  onWebGLInitialized: noop,\n  onResize: noop,\n  onViewStateChange: noop,\n  onInteractionStateChange: noop,\n  onBeforeRender: noop,\n  onAfterRender: noop,\n  onLoad: noop,\n  onError: error => log/* default.error */.Z.error(error.message)(),\n  onHover: null,\n  onClick: null,\n  onDragStart: null,\n  onDrag: null,\n  onDragEnd: null,\n  _onMetrics: null,\n  getCursor,\n  getTooltip: null,\n  debug: false,\n  drawPickingColors: false\n};\nclass Deck {\n  constructor(props) {\n    (0,defineProperty/* default */.Z)(this, "props", void 0);\n\n    (0,defineProperty/* default */.Z)(this, "width", 0);\n\n    (0,defineProperty/* default */.Z)(this, "height", 0);\n\n    (0,defineProperty/* default */.Z)(this, "userData", {});\n\n    (0,defineProperty/* default */.Z)(this, "canvas", null);\n\n    (0,defineProperty/* default */.Z)(this, "viewManager", null);\n\n    (0,defineProperty/* default */.Z)(this, "layerManager", null);\n\n    (0,defineProperty/* default */.Z)(this, "effectManager", null);\n\n    (0,defineProperty/* default */.Z)(this, "deckRenderer", null);\n\n    (0,defineProperty/* default */.Z)(this, "deckPicker", null);\n\n    (0,defineProperty/* default */.Z)(this, "eventManager", null);\n\n    (0,defineProperty/* default */.Z)(this, "tooltip", null);\n\n    (0,defineProperty/* default */.Z)(this, "metrics", void 0);\n\n    (0,defineProperty/* default */.Z)(this, "animationLoop", void 0);\n\n    (0,defineProperty/* default */.Z)(this, "stats", void 0);\n\n    (0,defineProperty/* default */.Z)(this, "viewState", void 0);\n\n    (0,defineProperty/* default */.Z)(this, "cursorState", void 0);\n\n    (0,defineProperty/* default */.Z)(this, "_needsRedraw", void 0);\n\n    (0,defineProperty/* default */.Z)(this, "_pickRequest", void 0);\n\n    (0,defineProperty/* default */.Z)(this, "_lastPointerDownInfo", null);\n\n    (0,defineProperty/* default */.Z)(this, "_metricsCounter", void 0);\n\n    (0,defineProperty/* default */.Z)(this, "_onPointerMove", event => {\n      const {\n        _pickRequest\n      } = this;\n\n      if (event.type === \'pointerleave\') {\n        _pickRequest.x = -1;\n        _pickRequest.y = -1;\n        _pickRequest.radius = 0;\n      } else if (event.leftButton || event.rightButton) {\n        return;\n      } else {\n        const pos = event.offsetCenter;\n\n        if (!pos) {\n          return;\n        }\n\n        _pickRequest.x = pos.x;\n        _pickRequest.y = pos.y;\n        _pickRequest.radius = this.props.pickingRadius;\n      }\n\n      if (this.layerManager) {\n        this.layerManager.context.mousePosition = {\n          x: _pickRequest.x,\n          y: _pickRequest.y\n        };\n      }\n\n      _pickRequest.event = event;\n    });\n\n    (0,defineProperty/* default */.Z)(this, "_onEvent", event => {\n      const eventOptions = lib_constants/* EVENTS */.FP[event.type];\n      const pos = event.offsetCenter;\n\n      if (!eventOptions || !pos || !this.layerManager) {\n        return;\n      }\n\n      const layers = this.layerManager.getLayers();\n      const info = this.deckPicker.getLastPickedObject({\n        x: pos.x,\n        y: pos.y,\n        layers,\n        viewports: this.getViewports(pos)\n      }, this._lastPointerDownInfo);\n      const {\n        layer\n      } = info;\n      const layerHandler = layer && (layer[eventOptions.handler] || layer.props[eventOptions.handler]);\n      const rootHandler = this.props[eventOptions.handler];\n      let handled = false;\n\n      if (layerHandler) {\n        handled = layerHandler.call(layer, info, event);\n      }\n\n      if (!handled && rootHandler) {\n        rootHandler(info, event);\n      }\n    });\n\n    (0,defineProperty/* default */.Z)(this, "_onPointerDown", event => {\n      const pos = event.offsetCenter;\n\n      const pickedInfo = this._pick(\'pickObject\', \'pickObject Time\', {\n        x: pos.x,\n        y: pos.y,\n        radius: this.props.pickingRadius\n      });\n\n      this._lastPointerDownInfo = pickedInfo.result[0] || pickedInfo.emptyInfo;\n    });\n\n    this.props = { ...defaultProps,\n      ...props\n    };\n    props = this.props;\n    this._needsRedraw = \'Initial render\';\n    this._pickRequest = {\n      mode: \'hover\',\n      x: -1,\n      y: -1,\n      radius: 0,\n      event: null\n    };\n    this.cursorState = {\n      isHovering: false,\n      isDragging: false\n    };\n\n    if (props.viewState && props.initialViewState) {\n      log/* default.warn */.Z.warn(\'View state tracking is disabled. Use either `initialViewState` for auto update or `viewState` for manual update.\')();\n    }\n\n    if ((0,get_browser/* default */.Z)() === \'IE\') {\n      log/* default.warn */.Z.warn(\'IE 11 is not supported\')();\n    }\n\n    this.viewState = props.initialViewState;\n\n    if (!props.gl) {\n      if (typeof document !== \'undefined\') {\n        this.canvas = this._createCanvas(props);\n      }\n    }\n\n    this.animationLoop = this._createAnimationLoop(props);\n    this.stats = new lib_stats/* default */.Z({\n      id: \'deck.gl\'\n    });\n    this.metrics = {\n      fps: 0,\n      setPropsTime: 0,\n      updateAttributesTime: 0,\n      framesRedrawn: 0,\n      pickTime: 0,\n      pickCount: 0,\n      gpuTime: 0,\n      gpuTimePerFrame: 0,\n      cpuTime: 0,\n      cpuTimePerFrame: 0,\n      bufferMemory: 0,\n      textureMemory: 0,\n      renderbufferMemory: 0,\n      gpuMemory: 0\n    };\n    this._metricsCounter = 0;\n    this.setProps(props);\n\n    if (props._typedArrayManagerProps) {\n      typed_array_manager/* default.setOptions */.Z.setOptions(props._typedArrayManagerProps);\n    }\n\n    this.animationLoop.start();\n  }\n\n  finalize() {\n    var _this$layerManager, _this$viewManager, _this$effectManager, _this$deckRenderer, _this$deckPicker, _this$eventManager, _this$tooltip;\n\n    this.animationLoop.stop();\n    this.animationLoop = null;\n    this._lastPointerDownInfo = null;\n    (_this$layerManager = this.layerManager) === null || _this$layerManager === void 0 ? void 0 : _this$layerManager.finalize();\n    this.layerManager = null;\n    (_this$viewManager = this.viewManager) === null || _this$viewManager === void 0 ? void 0 : _this$viewManager.finalize();\n    this.viewManager = null;\n    (_this$effectManager = this.effectManager) === null || _this$effectManager === void 0 ? void 0 : _this$effectManager.finalize();\n    this.effectManager = null;\n    (_this$deckRenderer = this.deckRenderer) === null || _this$deckRenderer === void 0 ? void 0 : _this$deckRenderer.finalize();\n    this.deckRenderer = null;\n    (_this$deckPicker = this.deckPicker) === null || _this$deckPicker === void 0 ? void 0 : _this$deckPicker.finalize();\n    this.deckPicker = null;\n    (_this$eventManager = this.eventManager) === null || _this$eventManager === void 0 ? void 0 : _this$eventManager.destroy();\n    this.eventManager = null;\n    (_this$tooltip = this.tooltip) === null || _this$tooltip === void 0 ? void 0 : _this$tooltip.remove();\n    this.tooltip = null;\n\n    if (!this.props.canvas && !this.props.gl && this.canvas) {\n      var _this$canvas$parentEl;\n\n      (_this$canvas$parentEl = this.canvas.parentElement) === null || _this$canvas$parentEl === void 0 ? void 0 : _this$canvas$parentEl.removeChild(this.canvas);\n      this.canvas = null;\n    }\n  }\n\n  setProps(props) {\n    this.stats.get(\'setProps Time\').timeStart();\n\n    if (\'onLayerHover\' in props) {\n      log/* default.removed */.Z.removed(\'onLayerHover\', \'onHover\')();\n    }\n\n    if (\'onLayerClick\' in props) {\n      log/* default.removed */.Z.removed(\'onLayerClick\', \'onClick\')();\n    }\n\n    if (props.initialViewState && !(0,deep_equal/* deepEqual */.v)(this.props.initialViewState, props.initialViewState, 3)) {\n      this.viewState = props.initialViewState;\n    }\n\n    Object.assign(this.props, props);\n\n    this._setCanvasSize(this.props);\n\n    const resolvedProps = Object.create(this.props);\n    Object.assign(resolvedProps, {\n      views: this._getViews(),\n      width: this.width,\n      height: this.height,\n      viewState: this._getViewState()\n    });\n    this.animationLoop.setProps(resolvedProps);\n\n    if (this.layerManager) {\n      this.viewManager.setProps(resolvedProps);\n      this.layerManager.activateViewport(this.getViewports()[0]);\n      this.layerManager.setProps(resolvedProps);\n      this.effectManager.setProps(resolvedProps);\n      this.deckRenderer.setProps(resolvedProps);\n      this.deckPicker.setProps(resolvedProps);\n    }\n\n    this.stats.get(\'setProps Time\').timeEnd();\n  }\n\n  needsRedraw(opts = {\n    clearRedrawFlags: false\n  }) {\n    if (!this.layerManager) {\n      return false;\n    }\n\n    if (this.props._animate) {\n      return \'Deck._animate\';\n    }\n\n    let redraw = this._needsRedraw;\n\n    if (opts.clearRedrawFlags) {\n      this._needsRedraw = false;\n    }\n\n    const viewManagerNeedsRedraw = this.viewManager.needsRedraw(opts);\n    const layerManagerNeedsRedraw = this.layerManager.needsRedraw(opts);\n    const effectManagerNeedsRedraw = this.effectManager.needsRedraw(opts);\n    const deckRendererNeedsRedraw = this.deckRenderer.needsRedraw(opts);\n    redraw = redraw || viewManagerNeedsRedraw || layerManagerNeedsRedraw || effectManagerNeedsRedraw || deckRendererNeedsRedraw;\n    return redraw;\n  }\n\n  redraw(reason) {\n    if (!this.layerManager) {\n      return;\n    }\n\n    let redrawReason = this.needsRedraw({\n      clearRedrawFlags: true\n    });\n    redrawReason = reason || redrawReason;\n\n    if (!redrawReason) {\n      return;\n    }\n\n    this.stats.get(\'Redraw Count\').incrementCount();\n\n    if (this.props._customRender) {\n      this.props._customRender(redrawReason);\n    } else {\n      this._drawLayers(redrawReason);\n    }\n  }\n\n  get isInitialized() {\n    return this.viewManager !== null;\n  }\n\n  getViews() {\n    (0,assert/* default */.Z)(this.viewManager);\n    return this.viewManager.views;\n  }\n\n  getViewports(rect) {\n    (0,assert/* default */.Z)(this.viewManager);\n    return this.viewManager.getViewports(rect);\n  }\n\n  pickObject(opts) {\n    const infos = this._pick(\'pickObject\', \'pickObject Time\', opts).result;\n\n    return infos.length ? infos[0] : null;\n  }\n\n  pickMultipleObjects(opts) {\n    opts.depth = opts.depth || 10;\n    return this._pick(\'pickObject\', \'pickMultipleObjects Time\', opts).result;\n  }\n\n  pickObjects(opts) {\n    return this._pick(\'pickObjects\', \'pickObjects Time\', opts);\n  }\n\n  _addResources(resources, forceUpdate = false) {\n    for (const id in resources) {\n      this.layerManager.resourceManager.add({\n        resourceId: id,\n        data: resources[id],\n        forceUpdate\n      });\n    }\n  }\n\n  _removeResources(resourceIds) {\n    for (const id of resourceIds) {\n      this.layerManager.resourceManager.remove(id);\n    }\n  }\n\n  _addDefaultEffect(effect) {\n    this.effectManager.addDefaultEffect(effect);\n  }\n\n  _pick(method, statKey, opts) {\n    (0,assert/* default */.Z)(this.deckPicker);\n    const {\n      stats\n    } = this;\n    stats.get(\'Pick Count\').incrementCount();\n    stats.get(statKey).timeStart();\n    const infos = this.deckPicker[method]({\n      layers: this.layerManager.getLayers(opts),\n      views: this.viewManager.getViews(),\n      viewports: this.getViewports(opts),\n      onViewportActive: this.layerManager.activateViewport,\n      effects: this.effectManager.getEffects(),\n      ...opts\n    });\n    stats.get(statKey).timeEnd();\n    return infos;\n  }\n\n  _createCanvas(props) {\n    let canvas = props.canvas;\n\n    if (typeof canvas === \'string\') {\n      canvas = document.getElementById(canvas);\n      (0,assert/* default */.Z)(canvas);\n    }\n\n    if (!canvas) {\n      canvas = document.createElement(\'canvas\');\n      canvas.id = props.id || \'deckgl-overlay\';\n      const parent = props.parent || document.body;\n      parent.appendChild(canvas);\n    }\n\n    Object.assign(canvas.style, props.style);\n    return canvas;\n  }\n\n  _setCanvasSize(props) {\n    if (!this.canvas) {\n      return;\n    }\n\n    const {\n      width,\n      height\n    } = props;\n\n    if (width || width === 0) {\n      const cssWidth = Number.isFinite(width) ? "".concat(width, "px") : width;\n      this.canvas.style.width = cssWidth;\n    }\n\n    if (height || height === 0) {\n      var _props$style;\n\n      const cssHeight = Number.isFinite(height) ? "".concat(height, "px") : height;\n      this.canvas.style.position = ((_props$style = props.style) === null || _props$style === void 0 ? void 0 : _props$style.position) || \'absolute\';\n      this.canvas.style.height = cssHeight;\n    }\n  }\n\n  _updateCanvasSize() {\n    const {\n      canvas\n    } = this;\n\n    if (!canvas) {\n      return;\n    }\n\n    const newWidth = canvas.clientWidth || canvas.width;\n    const newHeight = canvas.clientHeight || canvas.height;\n\n    if (newWidth !== this.width || newHeight !== this.height) {\n      var _this$viewManager2;\n\n      this.width = newWidth;\n      this.height = newHeight;\n      (_this$viewManager2 = this.viewManager) === null || _this$viewManager2 === void 0 ? void 0 : _this$viewManager2.setProps({\n        width: newWidth,\n        height: newHeight\n      });\n      this.props.onResize({\n        width: newWidth,\n        height: newHeight\n      });\n    }\n  }\n\n  _createAnimationLoop(props) {\n    const {\n      width,\n      height,\n      gl,\n      glOptions,\n      debug,\n      onError,\n      onBeforeRender,\n      onAfterRender,\n      useDevicePixels\n    } = props;\n    return new animation_loop/* default */.Z({\n      width,\n      height,\n      useDevicePixels,\n      autoResizeViewport: false,\n      gl,\n      onCreateContext: opts => (0,esm/* createGLContext */.s9)({ ...glOptions,\n        ...opts,\n        canvas: this.canvas,\n        debug,\n        onContextLost: () => this._onContextLost()\n      }),\n      onInitialize: context => this._setGLContext(context.gl),\n      onRender: this._onRenderFrame.bind(this),\n      onBeforeRender,\n      onAfterRender,\n      onError\n    });\n  }\n\n  _getViewState() {\n    return this.props.viewState || this.viewState;\n  }\n\n  _getViews() {\n    let views = this.props.views || [new map_view/* default */.Z({\n      id: \'default-view\'\n    })];\n    views = Array.isArray(views) ? views : [views];\n\n    if (views.length && this.props.controller) {\n      views[0].props.controller = this.props.controller;\n    }\n\n    return views;\n  }\n\n  _onContextLost() {\n    const {\n      onError\n    } = this.props;\n\n    if (this.animationLoop && onError) {\n      onError(new Error(\'WebGL context is lost\'));\n    }\n  }\n\n  _pickAndCallback() {\n    const {\n      _pickRequest\n    } = this;\n\n    if (_pickRequest.event) {\n      const {\n        result,\n        emptyInfo\n      } = this._pick(\'pickObject\', \'pickObject Time\', _pickRequest);\n\n      this.cursorState.isHovering = result.length > 0;\n      let pickedInfo = emptyInfo;\n      let handled = false;\n\n      for (const info of result) {\n        var _info$layer;\n\n        pickedInfo = info;\n        handled = ((_info$layer = info.layer) === null || _info$layer === void 0 ? void 0 : _info$layer.onHover(info, _pickRequest.event)) || handled;\n      }\n\n      if (!handled && this.props.onHover) {\n        this.props.onHover(pickedInfo, _pickRequest.event);\n      }\n\n      if (this.props.getTooltip && this.tooltip) {\n        const displayInfo = this.props.getTooltip(pickedInfo);\n        this.tooltip.setTooltip(displayInfo, pickedInfo.x, pickedInfo.y);\n      }\n\n      _pickRequest.event = null;\n    }\n  }\n\n  _updateCursor() {\n    const container = this.props.parent || this.canvas;\n\n    if (container) {\n      container.style.cursor = this.props.getCursor(this.cursorState);\n    }\n  }\n\n  _setGLContext(gl) {\n    if (this.layerManager) {\n      return;\n    }\n\n    if (!this.canvas) {\n      this.canvas = gl.canvas;\n      (0,esm/* instrumentGLContext */.yW)(gl, {\n        enable: true,\n        copyState: true\n      });\n    }\n\n    this.tooltip = new tooltip/* default */.Z(this.canvas);\n    (0,esm/* setParameters */.dR)(gl, {\n      blend: true,\n      blendFunc: [770, 771, 1, 771],\n      polygonOffsetFill: true,\n      depthTest: true,\n      depthFunc: 515\n    });\n    this.props.onWebGLInitialized(gl);\n    const timeline = new animation_timeline/* Timeline */.T();\n    timeline.play();\n    this.animationLoop.attachTimeline(timeline);\n    this.eventManager = new dist_esm/* EventManager */.Q(this.props.parent || gl.canvas, {\n      touchAction: this.props.touchAction,\n      recognizerOptions: this.props.eventRecognizerOptions,\n      events: {\n        pointerdown: this._onPointerDown,\n        pointermove: this._onPointerMove,\n        pointerleave: this._onPointerMove\n      }\n    });\n\n    for (const eventType in lib_constants/* EVENTS */.FP) {\n      this.eventManager.on(eventType, this._onEvent);\n    }\n\n    this.viewManager = new view_manager/* default */.Z({\n      timeline,\n      eventManager: this.eventManager,\n      onViewStateChange: this._onViewStateChange.bind(this),\n      onInteractionStateChange: this._onInteractionStateChange.bind(this),\n      views: this._getViews(),\n      viewState: this._getViewState(),\n      width: this.width,\n      height: this.height\n    });\n    const viewport = this.viewManager.getViewports()[0];\n    this.layerManager = new LayerManager(gl, {\n      deck: this,\n      stats: this.stats,\n      viewport,\n      timeline\n    });\n    this.effectManager = new EffectManager();\n    this.deckRenderer = new DeckRenderer(gl);\n    this.deckPicker = new DeckPicker(gl);\n    this.setProps(this.props);\n\n    this._updateCanvasSize();\n\n    this.props.onLoad();\n  }\n\n  _drawLayers(redrawReason, renderOptions) {\n    const {\n      gl\n    } = this.layerManager.context;\n    (0,esm/* setParameters */.dR)(gl, this.props.parameters);\n    this.props.onBeforeRender({\n      gl\n    });\n    this.deckRenderer.renderLayers({\n      target: this.props._framebuffer,\n      layers: this.layerManager.getLayers(),\n      viewports: this.viewManager.getViewports(),\n      onViewportActive: this.layerManager.activateViewport,\n      views: this.viewManager.getViews(),\n      pass: \'screen\',\n      effects: this.effectManager.getEffects(),\n      ...renderOptions\n    });\n    this.props.onAfterRender({\n      gl\n    });\n  }\n\n  _onRenderFrame(animationProps) {\n    this._getFrameStats();\n\n    if (this._metricsCounter++ % 60 === 0) {\n      this._getMetrics();\n\n      this.stats.reset();\n      log/* default.table */.Z.table(4, this.metrics)();\n\n      if (this.props._onMetrics) {\n        this.props._onMetrics(this.metrics);\n      }\n    }\n\n    this._updateCanvasSize();\n\n    this._updateCursor();\n\n    if (this.tooltip.isVisible && this.viewManager.needsRedraw()) {\n      this.tooltip.setTooltip(null);\n    }\n\n    this.layerManager.updateLayers();\n\n    this._pickAndCallback();\n\n    this.redraw();\n\n    if (this.viewManager) {\n      this.viewManager.updateViewStates();\n    }\n  }\n\n  _onViewStateChange(params) {\n    const viewState = this.props.onViewStateChange(params) || params.viewState;\n\n    if (this.viewState) {\n      this.viewState = { ...this.viewState,\n        [params.viewId]: viewState\n      };\n\n      if (!this.props.viewState) {\n        if (this.viewManager) {\n          this.viewManager.setProps({\n            viewState: this.viewState\n          });\n        }\n      }\n    }\n  }\n\n  _onInteractionStateChange(interactionState) {\n    this.cursorState.isDragging = interactionState.isDragging || false;\n    this.props.onInteractionStateChange(interactionState);\n  }\n\n  _getFrameStats() {\n    const {\n      stats\n    } = this;\n    stats.get(\'frameRate\').timeEnd();\n    stats.get(\'frameRate\').timeStart();\n    const animationLoopStats = this.animationLoop.stats;\n    stats.get(\'GPU Time\').addTime(animationLoopStats.get(\'GPU Time\').lastTiming);\n    stats.get(\'CPU Time\').addTime(animationLoopStats.get(\'CPU Time\').lastTiming);\n  }\n\n  _getMetrics() {\n    const {\n      metrics,\n      stats\n    } = this;\n    metrics.fps = stats.get(\'frameRate\').getHz();\n    metrics.setPropsTime = stats.get(\'setProps Time\').time;\n    metrics.updateAttributesTime = stats.get(\'Update Attributes\').time;\n    metrics.framesRedrawn = stats.get(\'Redraw Count\').count;\n    metrics.pickTime = stats.get(\'pickObject Time\').time + stats.get(\'pickMultipleObjects Time\').time + stats.get(\'pickObjects Time\').time;\n    metrics.pickCount = stats.get(\'Pick Count\').count;\n    metrics.gpuTime = stats.get(\'GPU Time\').time;\n    metrics.cpuTime = stats.get(\'CPU Time\').time;\n    metrics.gpuTimePerFrame = stats.get(\'GPU Time\').getAverageTime();\n    metrics.cpuTimePerFrame = stats.get(\'CPU Time\').getAverageTime();\n    const memoryStats = init/* lumaStats.get */.lR.get(\'Memory Usage\');\n    metrics.bufferMemory = memoryStats.get(\'Buffer Memory\').count;\n    metrics.textureMemory = memoryStats.get(\'Texture Memory\').count;\n    metrics.renderbufferMemory = memoryStats.get(\'Renderbuffer Memory\').count;\n    metrics.gpuMemory = memoryStats.get(\'GPU Memory\').count;\n  }\n\n}\n\n(0,defineProperty/* default */.Z)(Deck, "defaultProps", defaultProps);\n\n(0,defineProperty/* default */.Z)(Deck, "VERSION", VERSION);\n//# sourceMappingURL=deck.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsTUFBTSw0QkFBUTtBQUNkOztBQUVBLFFBQVEsOEJBQVU7QUFDbEIsTUFBTSw0QkFBUTtBQUNkOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxxQkFBcUIsd0JBQUs7QUFDMUI7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsTUFBTSx3REFBNEI7QUFDbEM7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsTUFBTSxrQ0FBVztBQUNqQjs7QUFFQTtBQUNBLE1BQU0sa0NBQVc7QUFDakI7O0FBRUEsbUNBQW1DLCtCQUFTO0FBQzVDO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLElBQUks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Q0E7O0FBRUE7QUFDQSxNQUFNLDhCQUFTOztBQUVmO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3Qiw4QkFBYTtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLGlDQUFlOztBQUVmLGlDQUFlLGtCQUFrQixPQUFPO0FBQ3hDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdnVlMy13ZWJwYWNrNS8uL25vZGVfbW9kdWxlcy9AZGVjay5nbC9jb3JlL2Rpc3QvZXNtL2xpYi9sYXllci1tYW5hZ2VyLmpzP2YwNGIiLCJ3ZWJwYWNrOi8vdnVlMy13ZWJwYWNrNS8uL25vZGVfbW9kdWxlcy9AZGVjay5nbC9jb3JlL2Rpc3QvZXNtL2VmZmVjdHMvbGlnaHRpbmcvYW1iaWVudC1saWdodC5qcz9iNDdlIiwid2VicGFjazovL3Z1ZTMtd2VicGFjazUvLi9ub2RlX21vZHVsZXMvQGRlY2suZ2wvY29yZS9kaXN0L2VzbS9lZmZlY3RzL2xpZ2h0aW5nL2RpcmVjdGlvbmFsLWxpZ2h0LmpzPzUxNGUiLCJ3ZWJwYWNrOi8vdnVlMy13ZWJwYWNrNS8uL25vZGVfbW9kdWxlcy9AZGVjay5nbC9jb3JlL2Rpc3QvZXNtL2VmZmVjdHMvbGlnaHRpbmcvbGlnaHRpbmctZWZmZWN0LmpzPzVhZWYiLCJ3ZWJwYWNrOi8vdnVlMy13ZWJwYWNrNS8uL25vZGVfbW9kdWxlcy9AZGVjay5nbC9jb3JlL2Rpc3QvZXNtL2xpYi9lZmZlY3QtbWFuYWdlci5qcz85YWRjIiwid2VicGFjazovL3Z1ZTMtd2VicGFjazUvLi9ub2RlX21vZHVsZXMvQGRlY2suZ2wvY29yZS9kaXN0L2VzbS9saWIvZGVjay1yZW5kZXJlci5qcz8zMWI5Iiwid2VicGFjazovL3Z1ZTMtd2VicGFjazUvLi9ub2RlX21vZHVsZXMvQGRlY2suZ2wvY29yZS9kaXN0L2VzbS9saWIvZGVjay1waWNrZXIuanM/ODRmNyIsIndlYnBhY2s6Ly92dWUzLXdlYnBhY2s1Ly4vbm9kZV9tb2R1bGVzL0BkZWNrLmdsL2NvcmUvZGlzdC9lc20vbGliL2luaXQuanM/ZWVjYiIsIndlYnBhY2s6Ly92dWUzLXdlYnBhY2s1Ly4vbm9kZV9tb2R1bGVzL0BkZWNrLmdsL2NvcmUvZGlzdC9lc20vbGliL2RlY2suanM/ZjUxZSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgX2RlZmluZVByb3BlcnR5IGZyb20gXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9kZWZpbmVQcm9wZXJ0eVwiO1xuaW1wb3J0IHsgVGltZWxpbmUgfSBmcm9tICdAbHVtYS5nbC9jb3JlJztcbmltcG9ydCB7IExJRkVDWUNMRSB9IGZyb20gJy4uL2xpZmVjeWNsZS9jb25zdGFudHMnO1xuaW1wb3J0IGxvZyBmcm9tICcuLi91dGlscy9sb2cnO1xuaW1wb3J0IGRlYnVnIGZyb20gJy4uL2RlYnVnJztcbmltcG9ydCB7IGZsYXR0ZW4gfSBmcm9tICcuLi91dGlscy9mbGF0dGVuJztcbmltcG9ydCB7IFN0YXRzIH0gZnJvbSAnQHByb2JlLmdsL3N0YXRzJztcbmltcG9ydCBSZXNvdXJjZU1hbmFnZXIgZnJvbSAnLi9yZXNvdXJjZS9yZXNvdXJjZS1tYW5hZ2VyJztcbmltcG9ydCBWaWV3cG9ydCBmcm9tICcuLi92aWV3cG9ydHMvdmlld3BvcnQnO1xuaW1wb3J0IHsgY3JlYXRlUHJvZ3JhbU1hbmFnZXIgfSBmcm9tICcuLi9zaGFkZXJsaWInO1xuY29uc3QgVFJBQ0VfU0VUX0xBWUVSUyA9ICdsYXllck1hbmFnZXIuc2V0TGF5ZXJzJztcbmNvbnN0IFRSQUNFX0FDVElWQVRFX1ZJRVdQT1JUID0gJ2xheWVyTWFuYWdlci5hY3RpdmF0ZVZpZXdwb3J0JztcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIExheWVyTWFuYWdlciB7XG4gIGNvbnN0cnVjdG9yKGdsLCB7XG4gICAgZGVjayxcbiAgICBzdGF0cyxcbiAgICB2aWV3cG9ydDogX3ZpZXdwb3J0LFxuICAgIHRpbWVsaW5lXG4gIH0gPSB7fSkge1xuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImxheWVyc1wiLCB2b2lkIDApO1xuXG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwiY29udGV4dFwiLCB2b2lkIDApO1xuXG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwicmVzb3VyY2VNYW5hZ2VyXCIsIHZvaWQgMCk7XG5cbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJfbGFzdFJlbmRlcmVkTGF5ZXJzXCIsIFtdKTtcblxuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIl9uZWVkc1JlZHJhd1wiLCBmYWxzZSk7XG5cbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJfbmVlZHNVcGRhdGVcIiwgZmFsc2UpO1xuXG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwiX25leHRMYXllcnNcIiwgbnVsbCk7XG5cbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJfZGVidWdcIiwgZmFsc2UpO1xuXG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwiYWN0aXZhdGVWaWV3cG9ydFwiLCB2aWV3cG9ydCA9PiB7XG4gICAgICBkZWJ1ZyhUUkFDRV9BQ1RJVkFURV9WSUVXUE9SVCwgdGhpcywgdmlld3BvcnQpO1xuXG4gICAgICBpZiAodmlld3BvcnQpIHtcbiAgICAgICAgdGhpcy5jb250ZXh0LnZpZXdwb3J0ID0gdmlld3BvcnQ7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICB0aGlzLmxheWVycyA9IFtdO1xuICAgIHRoaXMucmVzb3VyY2VNYW5hZ2VyID0gbmV3IFJlc291cmNlTWFuYWdlcih7XG4gICAgICBnbCxcbiAgICAgIHByb3RvY29sOiAnZGVjazovLydcbiAgICB9KTtcbiAgICB0aGlzLmNvbnRleHQgPSB7XG4gICAgICBtb3VzZVBvc2l0aW9uOiBudWxsLFxuICAgICAgdXNlckRhdGE6IHt9LFxuICAgICAgbGF5ZXJNYW5hZ2VyOiB0aGlzLFxuICAgICAgZ2wsXG4gICAgICBkZWNrLFxuICAgICAgcHJvZ3JhbU1hbmFnZXI6IGdsICYmIGNyZWF0ZVByb2dyYW1NYW5hZ2VyKGdsKSxcbiAgICAgIHN0YXRzOiBzdGF0cyB8fCBuZXcgU3RhdHMoe1xuICAgICAgICBpZDogJ2RlY2suZ2wnXG4gICAgICB9KSxcbiAgICAgIHZpZXdwb3J0OiBfdmlld3BvcnQgfHwgbmV3IFZpZXdwb3J0KHtcbiAgICAgICAgaWQ6ICdERUZBVUxULUlOSVRJQUwtVklFV1BPUlQnXG4gICAgICB9KSxcbiAgICAgIHRpbWVsaW5lOiB0aW1lbGluZSB8fCBuZXcgVGltZWxpbmUoKSxcbiAgICAgIHJlc291cmNlTWFuYWdlcjogdGhpcy5yZXNvdXJjZU1hbmFnZXIsXG4gICAgICBvbkVycm9yOiB1bmRlZmluZWRcbiAgICB9O1xuICAgIE9iamVjdC5zZWFsKHRoaXMpO1xuICB9XG5cbiAgZmluYWxpemUoKSB7XG4gICAgdGhpcy5yZXNvdXJjZU1hbmFnZXIuZmluYWxpemUoKTtcblxuICAgIGZvciAoY29uc3QgbGF5ZXIgb2YgdGhpcy5sYXllcnMpIHtcbiAgICAgIHRoaXMuX2ZpbmFsaXplTGF5ZXIobGF5ZXIpO1xuICAgIH1cbiAgfVxuXG4gIG5lZWRzUmVkcmF3KG9wdHMgPSB7XG4gICAgY2xlYXJSZWRyYXdGbGFnczogZmFsc2VcbiAgfSkge1xuICAgIGxldCByZWRyYXcgPSB0aGlzLl9uZWVkc1JlZHJhdztcblxuICAgIGlmIChvcHRzLmNsZWFyUmVkcmF3RmxhZ3MpIHtcbiAgICAgIHRoaXMuX25lZWRzUmVkcmF3ID0gZmFsc2U7XG4gICAgfVxuXG4gICAgZm9yIChjb25zdCBsYXllciBvZiB0aGlzLmxheWVycykge1xuICAgICAgY29uc3QgbGF5ZXJOZWVkc1JlZHJhdyA9IGxheWVyLmdldE5lZWRzUmVkcmF3KG9wdHMpO1xuICAgICAgcmVkcmF3ID0gcmVkcmF3IHx8IGxheWVyTmVlZHNSZWRyYXc7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlZHJhdztcbiAgfVxuXG4gIG5lZWRzVXBkYXRlKCkge1xuICAgIGlmICh0aGlzLl9uZXh0TGF5ZXJzICYmIHRoaXMuX25leHRMYXllcnMgIT09IHRoaXMuX2xhc3RSZW5kZXJlZExheWVycykge1xuICAgICAgcmV0dXJuICdsYXllcnMgY2hhbmdlZCc7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuX25lZWRzVXBkYXRlO1xuICB9XG5cbiAgc2V0TmVlZHNSZWRyYXcocmVhc29uKSB7XG4gICAgdGhpcy5fbmVlZHNSZWRyYXcgPSB0aGlzLl9uZWVkc1JlZHJhdyB8fCByZWFzb247XG4gIH1cblxuICBzZXROZWVkc1VwZGF0ZShyZWFzb24pIHtcbiAgICB0aGlzLl9uZWVkc1VwZGF0ZSA9IHRoaXMuX25lZWRzVXBkYXRlIHx8IHJlYXNvbjtcbiAgfVxuXG4gIGdldExheWVycyh7XG4gICAgbGF5ZXJJZHNcbiAgfSA9IHt9KSB7XG4gICAgcmV0dXJuIGxheWVySWRzID8gdGhpcy5sYXllcnMuZmlsdGVyKGxheWVyID0+IGxheWVySWRzLmZpbmQobGF5ZXJJZCA9PiBsYXllci5pZC5pbmRleE9mKGxheWVySWQpID09PSAwKSkgOiB0aGlzLmxheWVycztcbiAgfVxuXG4gIHNldFByb3BzKHByb3BzKSB7XG4gICAgaWYgKCdkZWJ1ZycgaW4gcHJvcHMpIHtcbiAgICAgIHRoaXMuX2RlYnVnID0gcHJvcHMuZGVidWc7XG4gICAgfVxuXG4gICAgaWYgKCd1c2VyRGF0YScgaW4gcHJvcHMpIHtcbiAgICAgIHRoaXMuY29udGV4dC51c2VyRGF0YSA9IHByb3BzLnVzZXJEYXRhO1xuICAgIH1cblxuICAgIGlmICgnbGF5ZXJzJyBpbiBwcm9wcykge1xuICAgICAgdGhpcy5fbmV4dExheWVycyA9IHByb3BzLmxheWVycztcbiAgICB9XG5cbiAgICBpZiAoJ29uRXJyb3InIGluIHByb3BzKSB7XG4gICAgICB0aGlzLmNvbnRleHQub25FcnJvciA9IHByb3BzLm9uRXJyb3I7XG4gICAgfVxuICB9XG5cbiAgc2V0TGF5ZXJzKG5ld0xheWVycywgcmVhc29uKSB7XG4gICAgZGVidWcoVFJBQ0VfU0VUX0xBWUVSUywgdGhpcywgcmVhc29uLCBuZXdMYXllcnMpO1xuICAgIHRoaXMuX2xhc3RSZW5kZXJlZExheWVycyA9IG5ld0xheWVycztcbiAgICBjb25zdCBmbGF0TGF5ZXJzID0gZmxhdHRlbihuZXdMYXllcnMsIEJvb2xlYW4pO1xuXG4gICAgZm9yIChjb25zdCBsYXllciBvZiBmbGF0TGF5ZXJzKSB7XG4gICAgICBsYXllci5jb250ZXh0ID0gdGhpcy5jb250ZXh0O1xuICAgIH1cblxuICAgIHRoaXMuX3VwZGF0ZUxheWVycyh0aGlzLmxheWVycywgZmxhdExheWVycyk7XG4gIH1cblxuICB1cGRhdGVMYXllcnMoKSB7XG4gICAgY29uc3QgcmVhc29uID0gdGhpcy5uZWVkc1VwZGF0ZSgpO1xuXG4gICAgaWYgKHJlYXNvbikge1xuICAgICAgdGhpcy5zZXROZWVkc1JlZHJhdyhcInVwZGF0aW5nIGxheWVyczogXCIuY29uY2F0KHJlYXNvbikpO1xuICAgICAgdGhpcy5zZXRMYXllcnModGhpcy5fbmV4dExheWVycyB8fCB0aGlzLl9sYXN0UmVuZGVyZWRMYXllcnMsIHJlYXNvbik7XG4gICAgfVxuXG4gICAgdGhpcy5fbmV4dExheWVycyA9IG51bGw7XG4gIH1cblxuICBfaGFuZGxlRXJyb3Ioc3RhZ2UsIGVycm9yLCBsYXllcikge1xuICAgIGxheWVyLnJhaXNlRXJyb3IoZXJyb3IsIFwiXCIuY29uY2F0KHN0YWdlLCBcIiBvZiBcIikuY29uY2F0KGxheWVyKSk7XG4gIH1cblxuICBfdXBkYXRlTGF5ZXJzKG9sZExheWVycywgbmV3TGF5ZXJzKSB7XG4gICAgY29uc3Qgb2xkTGF5ZXJNYXAgPSB7fTtcblxuICAgIGZvciAoY29uc3Qgb2xkTGF5ZXIgb2Ygb2xkTGF5ZXJzKSB7XG4gICAgICBpZiAob2xkTGF5ZXJNYXBbb2xkTGF5ZXIuaWRdKSB7XG4gICAgICAgIGxvZy53YXJuKFwiTXVsdGlwbGUgb2xkIGxheWVycyB3aXRoIHNhbWUgaWQgXCIuY29uY2F0KG9sZExheWVyLmlkKSkoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG9sZExheWVyTWFwW29sZExheWVyLmlkXSA9IG9sZExheWVyO1xuICAgICAgfVxuICAgIH1cblxuICAgIGNvbnN0IGdlbmVyYXRlZExheWVycyA9IFtdO1xuXG4gICAgdGhpcy5fdXBkYXRlU3VibGF5ZXJzUmVjdXJzaXZlbHkobmV3TGF5ZXJzLCBvbGRMYXllck1hcCwgZ2VuZXJhdGVkTGF5ZXJzKTtcblxuICAgIHRoaXMuX2ZpbmFsaXplT2xkTGF5ZXJzKG9sZExheWVyTWFwKTtcblxuICAgIGxldCBuZWVkc1VwZGF0ZSA9IGZhbHNlO1xuXG4gICAgZm9yIChjb25zdCBsYXllciBvZiBnZW5lcmF0ZWRMYXllcnMpIHtcbiAgICAgIGlmIChsYXllci5oYXNVbmlmb3JtVHJhbnNpdGlvbigpKSB7XG4gICAgICAgIG5lZWRzVXBkYXRlID0gXCJVbmlmb3JtIHRyYW5zaXRpb24gaW4gXCIuY29uY2F0KGxheWVyKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy5fbmVlZHNVcGRhdGUgPSBuZWVkc1VwZGF0ZTtcbiAgICB0aGlzLmxheWVycyA9IGdlbmVyYXRlZExheWVycztcbiAgfVxuXG4gIF91cGRhdGVTdWJsYXllcnNSZWN1cnNpdmVseShuZXdMYXllcnMsIG9sZExheWVyTWFwLCBnZW5lcmF0ZWRMYXllcnMpIHtcbiAgICBmb3IgKGNvbnN0IG5ld0xheWVyIG9mIG5ld0xheWVycykge1xuICAgICAgbmV3TGF5ZXIuY29udGV4dCA9IHRoaXMuY29udGV4dDtcbiAgICAgIGNvbnN0IG9sZExheWVyID0gb2xkTGF5ZXJNYXBbbmV3TGF5ZXIuaWRdO1xuXG4gICAgICBpZiAob2xkTGF5ZXIgPT09IG51bGwpIHtcbiAgICAgICAgbG9nLndhcm4oXCJNdWx0aXBsZSBuZXcgbGF5ZXJzIHdpdGggc2FtZSBpZCBcIi5jb25jYXQobmV3TGF5ZXIuaWQpKSgpO1xuICAgICAgfVxuXG4gICAgICBvbGRMYXllck1hcFtuZXdMYXllci5pZF0gPSBudWxsO1xuICAgICAgbGV0IHN1YmxheWVycyA9IG51bGw7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIGlmICh0aGlzLl9kZWJ1ZyAmJiBvbGRMYXllciAhPT0gbmV3TGF5ZXIpIHtcbiAgICAgICAgICBuZXdMYXllci52YWxpZGF0ZVByb3BzKCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIW9sZExheWVyKSB7XG4gICAgICAgICAgdGhpcy5faW5pdGlhbGl6ZUxheWVyKG5ld0xheWVyKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLl90cmFuc2ZlckxheWVyU3RhdGUob2xkTGF5ZXIsIG5ld0xheWVyKTtcblxuICAgICAgICAgIHRoaXMuX3VwZGF0ZUxheWVyKG5ld0xheWVyKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGdlbmVyYXRlZExheWVycy5wdXNoKG5ld0xheWVyKTtcbiAgICAgICAgc3VibGF5ZXJzID0gbmV3TGF5ZXIuaXNDb21wb3NpdGUgPyBuZXdMYXllci5nZXRTdWJMYXllcnMoKSA6IG51bGw7XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgdGhpcy5faGFuZGxlRXJyb3IoJ21hdGNoaW5nJywgZXJyLCBuZXdMYXllcik7XG4gICAgICB9XG5cbiAgICAgIGlmIChzdWJsYXllcnMpIHtcbiAgICAgICAgdGhpcy5fdXBkYXRlU3VibGF5ZXJzUmVjdXJzaXZlbHkoc3VibGF5ZXJzLCBvbGRMYXllck1hcCwgZ2VuZXJhdGVkTGF5ZXJzKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBfZmluYWxpemVPbGRMYXllcnMob2xkTGF5ZXJNYXApIHtcbiAgICBmb3IgKGNvbnN0IGxheWVySWQgaW4gb2xkTGF5ZXJNYXApIHtcbiAgICAgIGNvbnN0IGxheWVyID0gb2xkTGF5ZXJNYXBbbGF5ZXJJZF07XG5cbiAgICAgIGlmIChsYXllcikge1xuICAgICAgICB0aGlzLl9maW5hbGl6ZUxheWVyKGxheWVyKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBfaW5pdGlhbGl6ZUxheWVyKGxheWVyKSB7XG4gICAgdHJ5IHtcbiAgICAgIGxheWVyLl9pbml0aWFsaXplKCk7XG5cbiAgICAgIGxheWVyLmxpZmVjeWNsZSA9IExJRkVDWUNMRS5JTklUSUFMSVpFRDtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIHRoaXMuX2hhbmRsZUVycm9yKCdpbml0aWFsaXphdGlvbicsIGVyciwgbGF5ZXIpO1xuICAgIH1cbiAgfVxuXG4gIF90cmFuc2ZlckxheWVyU3RhdGUob2xkTGF5ZXIsIG5ld0xheWVyKSB7XG4gICAgbmV3TGF5ZXIuX3RyYW5zZmVyU3RhdGUob2xkTGF5ZXIpO1xuXG4gICAgbmV3TGF5ZXIubGlmZWN5Y2xlID0gTElGRUNZQ0xFLk1BVENIRUQ7XG5cbiAgICBpZiAobmV3TGF5ZXIgIT09IG9sZExheWVyKSB7XG4gICAgICBvbGRMYXllci5saWZlY3ljbGUgPSBMSUZFQ1lDTEUuQVdBSVRJTkdfR0M7XG4gICAgfVxuICB9XG5cbiAgX3VwZGF0ZUxheWVyKGxheWVyKSB7XG4gICAgdHJ5IHtcbiAgICAgIGxheWVyLl91cGRhdGUoKTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIHRoaXMuX2hhbmRsZUVycm9yKCd1cGRhdGUnLCBlcnIsIGxheWVyKTtcbiAgICB9XG4gIH1cblxuICBfZmluYWxpemVMYXllcihsYXllcikge1xuICAgIHRoaXMuX25lZWRzUmVkcmF3ID0gdGhpcy5fbmVlZHNSZWRyYXcgfHwgXCJmaW5hbGl6ZWQgXCIuY29uY2F0KGxheWVyKTtcbiAgICBsYXllci5saWZlY3ljbGUgPSBMSUZFQ1lDTEUuQVdBSVRJTkdfRklOQUxJWkFUSU9OO1xuXG4gICAgdHJ5IHtcbiAgICAgIGxheWVyLl9maW5hbGl6ZSgpO1xuXG4gICAgICBsYXllci5saWZlY3ljbGUgPSBMSUZFQ1lDTEUuRklOQUxJWkVEO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgdGhpcy5faGFuZGxlRXJyb3IoJ2ZpbmFsaXphdGlvbicsIGVyciwgbGF5ZXIpO1xuICAgIH1cbiAgfVxuXG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1sYXllci1tYW5hZ2VyLmpzLm1hcCIsImltcG9ydCBfZGVmaW5lUHJvcGVydHkgZnJvbSBcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL2RlZmluZVByb3BlcnR5XCI7XG5jb25zdCBERUZBVUxUX0xJR0hUX0NPTE9SID0gWzI1NSwgMjU1LCAyNTVdO1xuY29uc3QgREVGQVVMVF9MSUdIVF9JTlRFTlNJVFkgPSAxLjA7XG5sZXQgaWRDb3VudCA9IDA7XG5leHBvcnQgY2xhc3MgQW1iaWVudExpZ2h0IHtcbiAgY29uc3RydWN0b3IocHJvcHMgPSB7fSkge1xuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImlkXCIsIHZvaWQgMCk7XG5cbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJjb2xvclwiLCB2b2lkIDApO1xuXG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwiaW50ZW5zaXR5XCIsIHZvaWQgMCk7XG5cbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJ0eXBlXCIsICdhbWJpZW50Jyk7XG5cbiAgICBjb25zdCB7XG4gICAgICBjb2xvciA9IERFRkFVTFRfTElHSFRfQ09MT1JcbiAgICB9ID0gcHJvcHM7XG4gICAgY29uc3Qge1xuICAgICAgaW50ZW5zaXR5ID0gREVGQVVMVF9MSUdIVF9JTlRFTlNJVFlcbiAgICB9ID0gcHJvcHM7XG4gICAgdGhpcy5pZCA9IHByb3BzLmlkIHx8IFwiYW1iaWVudC1cIi5jb25jYXQoaWRDb3VudCsrKTtcbiAgICB0aGlzLmNvbG9yID0gY29sb3I7XG4gICAgdGhpcy5pbnRlbnNpdHkgPSBpbnRlbnNpdHk7XG4gIH1cblxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YW1iaWVudC1saWdodC5qcy5tYXAiLCJpbXBvcnQgX2RlZmluZVByb3BlcnR5IGZyb20gXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9kZWZpbmVQcm9wZXJ0eVwiO1xuaW1wb3J0IHsgVmVjdG9yMyB9IGZyb20gJ0BtYXRoLmdsL2NvcmUnO1xuY29uc3QgREVGQVVMVF9MSUdIVF9DT0xPUiA9IFsyNTUsIDI1NSwgMjU1XTtcbmNvbnN0IERFRkFVTFRfTElHSFRfSU5URU5TSVRZID0gMS4wO1xuY29uc3QgREVGQVVMVF9MSUdIVF9ESVJFQ1RJT04gPSBbMC4wLCAwLjAsIC0xLjBdO1xubGV0IGlkQ291bnQgPSAwO1xuZXhwb3J0IGNsYXNzIERpcmVjdGlvbmFsTGlnaHQge1xuICBjb25zdHJ1Y3Rvcihwcm9wcyA9IHt9KSB7XG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwiaWRcIiwgdm9pZCAwKTtcblxuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImNvbG9yXCIsIHZvaWQgMCk7XG5cbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJpbnRlbnNpdHlcIiwgdm9pZCAwKTtcblxuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInR5cGVcIiwgJ2RpcmVjdGlvbmFsJyk7XG5cbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJkaXJlY3Rpb25cIiwgdm9pZCAwKTtcblxuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInNoYWRvd1wiLCB2b2lkIDApO1xuXG4gICAgY29uc3Qge1xuICAgICAgY29sb3IgPSBERUZBVUxUX0xJR0hUX0NPTE9SXG4gICAgfSA9IHByb3BzO1xuICAgIGNvbnN0IHtcbiAgICAgIGludGVuc2l0eSA9IERFRkFVTFRfTElHSFRfSU5URU5TSVRZXG4gICAgfSA9IHByb3BzO1xuICAgIGNvbnN0IHtcbiAgICAgIGRpcmVjdGlvbiA9IERFRkFVTFRfTElHSFRfRElSRUNUSU9OXG4gICAgfSA9IHByb3BzO1xuICAgIGNvbnN0IHtcbiAgICAgIF9zaGFkb3cgPSBmYWxzZVxuICAgIH0gPSBwcm9wcztcbiAgICB0aGlzLmlkID0gcHJvcHMuaWQgfHwgXCJkaXJlY3Rpb25hbC1cIi5jb25jYXQoaWRDb3VudCsrKTtcbiAgICB0aGlzLmNvbG9yID0gY29sb3I7XG4gICAgdGhpcy5pbnRlbnNpdHkgPSBpbnRlbnNpdHk7XG4gICAgdGhpcy50eXBlID0gJ2RpcmVjdGlvbmFsJztcbiAgICB0aGlzLmRpcmVjdGlvbiA9IG5ldyBWZWN0b3IzKGRpcmVjdGlvbikubm9ybWFsaXplKCkudG9BcnJheSgpO1xuICAgIHRoaXMuc2hhZG93ID0gX3NoYWRvdztcbiAgfVxuXG4gIGdldFByb2plY3RlZExpZ2h0KG9wdHMpIHtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1kaXJlY3Rpb25hbC1saWdodC5qcy5tYXAiLCJpbXBvcnQgX2RlZmluZVByb3BlcnR5IGZyb20gXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9kZWZpbmVQcm9wZXJ0eVwiO1xuaW1wb3J0IHsgVGV4dHVyZTJELCBQcm9ncmFtTWFuYWdlciB9IGZyb20gJ0BsdW1hLmdsL2NvcmUnO1xuaW1wb3J0IHsgQW1iaWVudExpZ2h0IH0gZnJvbSAnLi9hbWJpZW50LWxpZ2h0JztcbmltcG9ydCB7IERpcmVjdGlvbmFsTGlnaHQgfSBmcm9tICcuL2RpcmVjdGlvbmFsLWxpZ2h0JztcbmltcG9ydCB7IE1hdHJpeDQsIFZlY3RvcjMgfSBmcm9tICdAbWF0aC5nbC9jb3JlJztcbmltcG9ydCBTaGFkb3dQYXNzIGZyb20gJy4uLy4uL3Bhc3Nlcy9zaGFkb3ctcGFzcyc7XG5pbXBvcnQgc2hhZG93IGZyb20gJy4uLy4uL3NoYWRlcmxpYi9zaGFkb3cvc2hhZG93JztcbmNvbnN0IERFRkFVTFRfQU1CSUVOVF9MSUdIVF9QUk9QUyA9IHtcbiAgY29sb3I6IFsyNTUsIDI1NSwgMjU1XSxcbiAgaW50ZW5zaXR5OiAxLjBcbn07XG5jb25zdCBERUZBVUxUX0RJUkVDVElPTkFMX0xJR0hUX1BST1BTID0gW3tcbiAgY29sb3I6IFsyNTUsIDI1NSwgMjU1XSxcbiAgaW50ZW5zaXR5OiAxLjAsXG4gIGRpcmVjdGlvbjogWy0xLCAzLCAtMV1cbn0sIHtcbiAgY29sb3I6IFsyNTUsIDI1NSwgMjU1XSxcbiAgaW50ZW5zaXR5OiAwLjksXG4gIGRpcmVjdGlvbjogWzEsIC04LCAtMi41XVxufV07XG5jb25zdCBERUZBVUxUX1NIQURPV19DT0xPUiA9IFswLCAwLCAwLCAyMDAgLyAyNTVdO1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgTGlnaHRpbmdFZmZlY3Qge1xuICBjb25zdHJ1Y3Rvcihwcm9wcyA9IHt9KSB7XG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwiaWRcIiwgJ2xpZ2h0aW5nLWVmZmVjdCcpO1xuXG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwicHJvcHNcIiwgdm9pZCAwKTtcblxuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInNoYWRvd0NvbG9yXCIsIERFRkFVTFRfU0hBRE9XX0NPTE9SKTtcblxuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInNoYWRvd1wiLCB2b2lkIDApO1xuXG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwiYW1iaWVudExpZ2h0XCIsIHZvaWQgMCk7XG5cbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJkaXJlY3Rpb25hbExpZ2h0c1wiLCB2b2lkIDApO1xuXG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwicG9pbnRMaWdodHNcIiwgdm9pZCAwKTtcblxuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInNoYWRvd1Bhc3Nlc1wiLCBbXSk7XG5cbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJzaGFkb3dNYXBzXCIsIFtdKTtcblxuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImR1bW15U2hhZG93TWFwXCIsIG51bGwpO1xuXG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwicHJvZ3JhbU1hbmFnZXJcIiwgdm9pZCAwKTtcblxuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInNoYWRvd01hdHJpY2VzXCIsIHZvaWQgMCk7XG5cbiAgICB0aGlzLnNldFByb3BzKHByb3BzKTtcbiAgfVxuXG4gIHNldFByb3BzKHByb3BzKSB7XG4gICAgdGhpcy5hbWJpZW50TGlnaHQgPSBudWxsO1xuICAgIHRoaXMuZGlyZWN0aW9uYWxMaWdodHMgPSBbXTtcbiAgICB0aGlzLnBvaW50TGlnaHRzID0gW107XG5cbiAgICBmb3IgKGNvbnN0IGtleSBpbiBwcm9wcykge1xuICAgICAgY29uc3QgbGlnaHRTb3VyY2UgPSBwcm9wc1trZXldO1xuXG4gICAgICBzd2l0Y2ggKGxpZ2h0U291cmNlLnR5cGUpIHtcbiAgICAgICAgY2FzZSAnYW1iaWVudCc6XG4gICAgICAgICAgdGhpcy5hbWJpZW50TGlnaHQgPSBsaWdodFNvdXJjZTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICdkaXJlY3Rpb25hbCc6XG4gICAgICAgICAgdGhpcy5kaXJlY3Rpb25hbExpZ2h0cy5wdXNoKGxpZ2h0U291cmNlKTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICdwb2ludCc6XG4gICAgICAgICAgdGhpcy5wb2ludExpZ2h0cy5wdXNoKGxpZ2h0U291cmNlKTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBkZWZhdWx0OlxuICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMuX2FwcGx5RGVmYXVsdExpZ2h0cygpO1xuXG4gICAgdGhpcy5zaGFkb3cgPSB0aGlzLmRpcmVjdGlvbmFsTGlnaHRzLnNvbWUobGlnaHQgPT4gbGlnaHQuc2hhZG93KTtcbiAgICB0aGlzLnByb3BzID0gcHJvcHM7XG4gIH1cblxuICBwcmVSZW5kZXIoZ2wsIHtcbiAgICBsYXllcnMsXG4gICAgbGF5ZXJGaWx0ZXIsXG4gICAgdmlld3BvcnRzLFxuICAgIG9uVmlld3BvcnRBY3RpdmUsXG4gICAgdmlld3NcbiAgfSkge1xuICAgIGlmICghdGhpcy5zaGFkb3cpIHJldHVybjtcbiAgICB0aGlzLnNoYWRvd01hdHJpY2VzID0gdGhpcy5fY2FsY3VsYXRlTWF0cmljZXMoKTtcblxuICAgIGlmICh0aGlzLnNoYWRvd1Bhc3Nlcy5sZW5ndGggPT09IDApIHtcbiAgICAgIHRoaXMuX2NyZWF0ZVNoYWRvd1Bhc3NlcyhnbCk7XG4gICAgfVxuXG4gICAgaWYgKCF0aGlzLnByb2dyYW1NYW5hZ2VyKSB7XG4gICAgICB0aGlzLnByb2dyYW1NYW5hZ2VyID0gUHJvZ3JhbU1hbmFnZXIuZ2V0RGVmYXVsdFByb2dyYW1NYW5hZ2VyKGdsKTtcblxuICAgICAgaWYgKHNoYWRvdykge1xuICAgICAgICB0aGlzLnByb2dyYW1NYW5hZ2VyLmFkZERlZmF1bHRNb2R1bGUoc2hhZG93KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoIXRoaXMuZHVtbXlTaGFkb3dNYXApIHtcbiAgICAgIHRoaXMuZHVtbXlTaGFkb3dNYXAgPSBuZXcgVGV4dHVyZTJEKGdsLCB7XG4gICAgICAgIHdpZHRoOiAxLFxuICAgICAgICBoZWlnaHQ6IDFcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5zaGFkb3dQYXNzZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IHNoYWRvd1Bhc3MgPSB0aGlzLnNoYWRvd1Bhc3Nlc1tpXTtcbiAgICAgIHNoYWRvd1Bhc3MucmVuZGVyKHtcbiAgICAgICAgbGF5ZXJzLFxuICAgICAgICBsYXllckZpbHRlcixcbiAgICAgICAgdmlld3BvcnRzLFxuICAgICAgICBvblZpZXdwb3J0QWN0aXZlLFxuICAgICAgICB2aWV3cyxcbiAgICAgICAgbW9kdWxlUGFyYW1ldGVyczoge1xuICAgICAgICAgIHNoYWRvd0xpZ2h0SWQ6IGksXG4gICAgICAgICAgZHVtbXlTaGFkb3dNYXA6IHRoaXMuZHVtbXlTaGFkb3dNYXAsXG4gICAgICAgICAgc2hhZG93TWF0cmljZXM6IHRoaXMuc2hhZG93TWF0cmljZXNcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgZ2V0TW9kdWxlUGFyYW1ldGVycyhsYXllcikge1xuICAgIGNvbnN0IHBhcmFtZXRlcnMgPSB0aGlzLnNoYWRvdyA/IHtcbiAgICAgIHNoYWRvd01hcHM6IHRoaXMuc2hhZG93TWFwcyxcbiAgICAgIGR1bW15U2hhZG93TWFwOiB0aGlzLmR1bW15U2hhZG93TWFwLFxuICAgICAgc2hhZG93Q29sb3I6IHRoaXMuc2hhZG93Q29sb3IsXG4gICAgICBzaGFkb3dNYXRyaWNlczogdGhpcy5zaGFkb3dNYXRyaWNlc1xuICAgIH0gOiB7fTtcbiAgICBwYXJhbWV0ZXJzLmxpZ2h0U291cmNlcyA9IHtcbiAgICAgIGFtYmllbnRMaWdodDogdGhpcy5hbWJpZW50TGlnaHQsXG4gICAgICBkaXJlY3Rpb25hbExpZ2h0czogdGhpcy5kaXJlY3Rpb25hbExpZ2h0cy5tYXAoZGlyZWN0aW9uYWxMaWdodCA9PiBkaXJlY3Rpb25hbExpZ2h0LmdldFByb2plY3RlZExpZ2h0KHtcbiAgICAgICAgbGF5ZXJcbiAgICAgIH0pKSxcbiAgICAgIHBvaW50TGlnaHRzOiB0aGlzLnBvaW50TGlnaHRzLm1hcChwb2ludExpZ2h0ID0+IHBvaW50TGlnaHQuZ2V0UHJvamVjdGVkTGlnaHQoe1xuICAgICAgICBsYXllclxuICAgICAgfSkpXG4gICAgfTtcbiAgICByZXR1cm4gcGFyYW1ldGVycztcbiAgfVxuXG4gIGNsZWFudXAoKSB7XG4gICAgZm9yIChjb25zdCBzaGFkb3dQYXNzIG9mIHRoaXMuc2hhZG93UGFzc2VzKSB7XG4gICAgICBzaGFkb3dQYXNzLmRlbGV0ZSgpO1xuICAgIH1cblxuICAgIHRoaXMuc2hhZG93UGFzc2VzLmxlbmd0aCA9IDA7XG4gICAgdGhpcy5zaGFkb3dNYXBzLmxlbmd0aCA9IDA7XG5cbiAgICBpZiAodGhpcy5kdW1teVNoYWRvd01hcCkge1xuICAgICAgdGhpcy5kdW1teVNoYWRvd01hcC5kZWxldGUoKTtcbiAgICAgIHRoaXMuZHVtbXlTaGFkb3dNYXAgPSBudWxsO1xuICAgIH1cblxuICAgIGlmICh0aGlzLnNoYWRvdyAmJiB0aGlzLnByb2dyYW1NYW5hZ2VyKSB7XG4gICAgICB0aGlzLnByb2dyYW1NYW5hZ2VyLnJlbW92ZURlZmF1bHRNb2R1bGUoc2hhZG93KTtcbiAgICAgIHRoaXMucHJvZ3JhbU1hbmFnZXIgPSBudWxsO1xuICAgIH1cbiAgfVxuXG4gIF9jYWxjdWxhdGVNYXRyaWNlcygpIHtcbiAgICBjb25zdCBsaWdodE1hdHJpY2VzID0gW107XG5cbiAgICBmb3IgKGNvbnN0IGxpZ2h0IG9mIHRoaXMuZGlyZWN0aW9uYWxMaWdodHMpIHtcbiAgICAgIGNvbnN0IHZpZXdNYXRyaXggPSBuZXcgTWF0cml4NCgpLmxvb2tBdCh7XG4gICAgICAgIGV5ZTogbmV3IFZlY3RvcjMobGlnaHQuZGlyZWN0aW9uKS5uZWdhdGUoKVxuICAgICAgfSk7XG4gICAgICBsaWdodE1hdHJpY2VzLnB1c2godmlld01hdHJpeCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGxpZ2h0TWF0cmljZXM7XG4gIH1cblxuICBfY3JlYXRlU2hhZG93UGFzc2VzKGdsKSB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmRpcmVjdGlvbmFsTGlnaHRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBzaGFkb3dQYXNzID0gbmV3IFNoYWRvd1Bhc3MoZ2wpO1xuICAgICAgdGhpcy5zaGFkb3dQYXNzZXNbaV0gPSBzaGFkb3dQYXNzO1xuICAgICAgdGhpcy5zaGFkb3dNYXBzW2ldID0gc2hhZG93UGFzcy5zaGFkb3dNYXA7XG4gICAgfVxuICB9XG5cbiAgX2FwcGx5RGVmYXVsdExpZ2h0cygpIHtcbiAgICBjb25zdCB7XG4gICAgICBhbWJpZW50TGlnaHQsXG4gICAgICBwb2ludExpZ2h0cyxcbiAgICAgIGRpcmVjdGlvbmFsTGlnaHRzXG4gICAgfSA9IHRoaXM7XG5cbiAgICBpZiAoIWFtYmllbnRMaWdodCAmJiBwb2ludExpZ2h0cy5sZW5ndGggPT09IDAgJiYgZGlyZWN0aW9uYWxMaWdodHMubGVuZ3RoID09PSAwKSB7XG4gICAgICB0aGlzLmFtYmllbnRMaWdodCA9IG5ldyBBbWJpZW50TGlnaHQoREVGQVVMVF9BTUJJRU5UX0xJR0hUX1BST1BTKTtcbiAgICAgIHRoaXMuZGlyZWN0aW9uYWxMaWdodHMucHVzaChuZXcgRGlyZWN0aW9uYWxMaWdodChERUZBVUxUX0RJUkVDVElPTkFMX0xJR0hUX1BST1BTWzBdKSwgbmV3IERpcmVjdGlvbmFsTGlnaHQoREVGQVVMVF9ESVJFQ1RJT05BTF9MSUdIVF9QUk9QU1sxXSkpO1xuICAgIH1cbiAgfVxuXG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1saWdodGluZy1lZmZlY3QuanMubWFwIiwiaW1wb3J0IF9kZWZpbmVQcm9wZXJ0eSBmcm9tIFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vZGVmaW5lUHJvcGVydHlcIjtcbmltcG9ydCB7IGRlZXBFcXVhbCB9IGZyb20gJy4uL3V0aWxzL2RlZXAtZXF1YWwnO1xuaW1wb3J0IExpZ2h0aW5nRWZmZWN0IGZyb20gJy4uL2VmZmVjdHMvbGlnaHRpbmcvbGlnaHRpbmctZWZmZWN0JztcbmNvbnN0IERFRkFVTFRfTElHSFRJTkdfRUZGRUNUID0gbmV3IExpZ2h0aW5nRWZmZWN0KCk7XG5cbmZ1bmN0aW9uIGNvbXBhcmVFZmZlY3RzKGUxLCBlMikge1xuICB2YXIgX2UxJG9yZGVyLCBfZTIkb3JkZXI7XG5cbiAgY29uc3QgbzEgPSAoX2UxJG9yZGVyID0gZTEub3JkZXIpICE9PSBudWxsICYmIF9lMSRvcmRlciAhPT0gdm9pZCAwID8gX2UxJG9yZGVyIDogSW5maW5pdHk7XG4gIGNvbnN0IG8yID0gKF9lMiRvcmRlciA9IGUyLm9yZGVyKSAhPT0gbnVsbCAmJiBfZTIkb3JkZXIgIT09IHZvaWQgMCA/IF9lMiRvcmRlciA6IEluZmluaXR5O1xuICByZXR1cm4gbzEgLSBvMjtcbn1cblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgRWZmZWN0TWFuYWdlciB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImVmZmVjdHNcIiwgdm9pZCAwKTtcblxuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIl9yZXNvbHZlZEVmZmVjdHNcIiwgW10pO1xuXG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwiX2RlZmF1bHRFZmZlY3RzXCIsIFtdKTtcblxuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIl9uZWVkc1JlZHJhd1wiLCB2b2lkIDApO1xuXG4gICAgdGhpcy5lZmZlY3RzID0gW107XG4gICAgdGhpcy5fbmVlZHNSZWRyYXcgPSAnSW5pdGlhbCByZW5kZXInO1xuXG4gICAgdGhpcy5fc2V0RWZmZWN0cyhbXSk7XG4gIH1cblxuICBhZGREZWZhdWx0RWZmZWN0KGVmZmVjdCkge1xuICAgIGNvbnN0IGRlZmF1bHRFZmZlY3RzID0gdGhpcy5fZGVmYXVsdEVmZmVjdHM7XG5cbiAgICBpZiAoIWRlZmF1bHRFZmZlY3RzLmZpbmQoZSA9PiBlLmlkID09PSBlZmZlY3QuaWQpKSB7XG4gICAgICBjb25zdCBpbmRleCA9IGRlZmF1bHRFZmZlY3RzLmZpbmRJbmRleChlID0+IGNvbXBhcmVFZmZlY3RzKGUsIGVmZmVjdCkgPiAwKTtcblxuICAgICAgaWYgKGluZGV4IDwgMCkge1xuICAgICAgICBkZWZhdWx0RWZmZWN0cy5wdXNoKGVmZmVjdCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkZWZhdWx0RWZmZWN0cy5zcGxpY2UoaW5kZXgsIDAsIGVmZmVjdCk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuX3NldEVmZmVjdHModGhpcy5lZmZlY3RzKTtcbiAgICB9XG4gIH1cblxuICBzZXRQcm9wcyhwcm9wcykge1xuICAgIGlmICgnZWZmZWN0cycgaW4gcHJvcHMpIHtcbiAgICAgIGlmICghZGVlcEVxdWFsKHByb3BzLmVmZmVjdHMsIHRoaXMuZWZmZWN0cywgMSkpIHtcbiAgICAgICAgdGhpcy5fc2V0RWZmZWN0cyhwcm9wcy5lZmZlY3RzKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBuZWVkc1JlZHJhdyhvcHRzID0ge1xuICAgIGNsZWFyUmVkcmF3RmxhZ3M6IGZhbHNlXG4gIH0pIHtcbiAgICBjb25zdCByZWRyYXcgPSB0aGlzLl9uZWVkc1JlZHJhdztcblxuICAgIGlmIChvcHRzLmNsZWFyUmVkcmF3RmxhZ3MpIHtcbiAgICAgIHRoaXMuX25lZWRzUmVkcmF3ID0gZmFsc2U7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlZHJhdztcbiAgfVxuXG4gIGdldEVmZmVjdHMoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3Jlc29sdmVkRWZmZWN0cztcbiAgfVxuXG4gIF9zZXRFZmZlY3RzKGVmZmVjdHMpIHtcbiAgICBjb25zdCBvbGRFZmZlY3RzTWFwID0ge307XG5cbiAgICBmb3IgKGNvbnN0IGVmZmVjdCBvZiB0aGlzLmVmZmVjdHMpIHtcbiAgICAgIG9sZEVmZmVjdHNNYXBbZWZmZWN0LmlkXSA9IGVmZmVjdDtcbiAgICB9XG5cbiAgICBjb25zdCBuZXh0RWZmZWN0cyA9IFtdO1xuXG4gICAgZm9yIChjb25zdCBlZmZlY3Qgb2YgZWZmZWN0cykge1xuICAgICAgY29uc3Qgb2xkRWZmZWN0ID0gb2xkRWZmZWN0c01hcFtlZmZlY3QuaWRdO1xuXG4gICAgICBpZiAob2xkRWZmZWN0ICYmIG9sZEVmZmVjdCAhPT0gZWZmZWN0KSB7XG4gICAgICAgIGlmIChvbGRFZmZlY3Quc2V0UHJvcHMpIHtcbiAgICAgICAgICBvbGRFZmZlY3Quc2V0UHJvcHMoZWZmZWN0LnByb3BzKTtcbiAgICAgICAgICBuZXh0RWZmZWN0cy5wdXNoKG9sZEVmZmVjdCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgb2xkRWZmZWN0LmNsZWFudXAoKTtcbiAgICAgICAgICBuZXh0RWZmZWN0cy5wdXNoKGVmZmVjdCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG5leHRFZmZlY3RzLnB1c2goZWZmZWN0KTtcbiAgICAgIH1cblxuICAgICAgZGVsZXRlIG9sZEVmZmVjdHNNYXBbZWZmZWN0LmlkXTtcbiAgICB9XG5cbiAgICBmb3IgKGNvbnN0IHJlbW92ZWRFZmZlY3RJZCBpbiBvbGRFZmZlY3RzTWFwKSB7XG4gICAgICBvbGRFZmZlY3RzTWFwW3JlbW92ZWRFZmZlY3RJZF0uY2xlYW51cCgpO1xuICAgIH1cblxuICAgIHRoaXMuZWZmZWN0cyA9IG5leHRFZmZlY3RzO1xuICAgIHRoaXMuX3Jlc29sdmVkRWZmZWN0cyA9IG5leHRFZmZlY3RzLmNvbmNhdCh0aGlzLl9kZWZhdWx0RWZmZWN0cyk7XG5cbiAgICBpZiAoIWVmZmVjdHMuc29tZShlZmZlY3QgPT4gZWZmZWN0IGluc3RhbmNlb2YgTGlnaHRpbmdFZmZlY3QpKSB7XG4gICAgICB0aGlzLl9yZXNvbHZlZEVmZmVjdHMucHVzaChERUZBVUxUX0xJR0hUSU5HX0VGRkVDVCk7XG4gICAgfVxuXG4gICAgdGhpcy5fbmVlZHNSZWRyYXcgPSAnZWZmZWN0cyBjaGFuZ2VkJztcbiAgfVxuXG4gIGZpbmFsaXplKCkge1xuICAgIGZvciAoY29uc3QgZWZmZWN0IG9mIHRoaXMuX3Jlc29sdmVkRWZmZWN0cykge1xuICAgICAgZWZmZWN0LmNsZWFudXAoKTtcbiAgICB9XG5cbiAgICB0aGlzLmVmZmVjdHMubGVuZ3RoID0gMDtcbiAgICB0aGlzLl9yZXNvbHZlZEVmZmVjdHMubGVuZ3RoID0gMDtcbiAgICB0aGlzLl9kZWZhdWx0RWZmZWN0cy5sZW5ndGggPSAwO1xuICB9XG5cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWVmZmVjdC1tYW5hZ2VyLmpzLm1hcCIsImltcG9ydCBfZGVmaW5lUHJvcGVydHkgZnJvbSBcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL2RlZmluZVByb3BlcnR5XCI7XG5pbXBvcnQgZGVidWcgZnJvbSAnLi4vZGVidWcnO1xuaW1wb3J0IERyYXdMYXllcnNQYXNzIGZyb20gJy4uL3Bhc3Nlcy9kcmF3LWxheWVycy1wYXNzJztcbmltcG9ydCBQaWNrTGF5ZXJzUGFzcyBmcm9tICcuLi9wYXNzZXMvcGljay1sYXllcnMtcGFzcyc7XG5pbXBvcnQgeyBGcmFtZWJ1ZmZlciB9IGZyb20gJ0BsdW1hLmdsL2NvcmUnO1xuY29uc3QgVFJBQ0VfUkVOREVSX0xBWUVSUyA9ICdkZWNrUmVuZGVyZXIucmVuZGVyTGF5ZXJzJztcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIERlY2tSZW5kZXJlciB7XG4gIGNvbnN0cnVjdG9yKGdsKSB7XG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwiZ2xcIiwgdm9pZCAwKTtcblxuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImxheWVyRmlsdGVyXCIsIHZvaWQgMCk7XG5cbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJkcmF3UGlja2luZ0NvbG9yc1wiLCB2b2lkIDApO1xuXG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwiZHJhd0xheWVyc1Bhc3NcIiwgdm9pZCAwKTtcblxuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInBpY2tMYXllcnNQYXNzXCIsIHZvaWQgMCk7XG5cbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJyZW5kZXJDb3VudFwiLCB2b2lkIDApO1xuXG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwiX25lZWRzUmVkcmF3XCIsIHZvaWQgMCk7XG5cbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJyZW5kZXJCdWZmZXJzXCIsIHZvaWQgMCk7XG5cbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJsYXN0UG9zdFByb2Nlc3NFZmZlY3RcIiwgdm9pZCAwKTtcblxuICAgIHRoaXMuZ2wgPSBnbDtcbiAgICB0aGlzLmxheWVyRmlsdGVyID0gbnVsbDtcbiAgICB0aGlzLmRyYXdQaWNraW5nQ29sb3JzID0gZmFsc2U7XG4gICAgdGhpcy5kcmF3TGF5ZXJzUGFzcyA9IG5ldyBEcmF3TGF5ZXJzUGFzcyhnbCk7XG4gICAgdGhpcy5waWNrTGF5ZXJzUGFzcyA9IG5ldyBQaWNrTGF5ZXJzUGFzcyhnbCk7XG4gICAgdGhpcy5yZW5kZXJDb3VudCA9IDA7XG4gICAgdGhpcy5fbmVlZHNSZWRyYXcgPSAnSW5pdGlhbCByZW5kZXInO1xuICAgIHRoaXMucmVuZGVyQnVmZmVycyA9IFtdO1xuICAgIHRoaXMubGFzdFBvc3RQcm9jZXNzRWZmZWN0ID0gbnVsbDtcbiAgfVxuXG4gIHNldFByb3BzKHByb3BzKSB7XG4gICAgaWYgKHRoaXMubGF5ZXJGaWx0ZXIgIT09IHByb3BzLmxheWVyRmlsdGVyKSB7XG4gICAgICB0aGlzLmxheWVyRmlsdGVyID0gcHJvcHMubGF5ZXJGaWx0ZXI7XG4gICAgICB0aGlzLl9uZWVkc1JlZHJhdyA9ICdsYXllckZpbHRlciBjaGFuZ2VkJztcbiAgICB9XG5cbiAgICBpZiAodGhpcy5kcmF3UGlja2luZ0NvbG9ycyAhPT0gcHJvcHMuZHJhd1BpY2tpbmdDb2xvcnMpIHtcbiAgICAgIHRoaXMuZHJhd1BpY2tpbmdDb2xvcnMgPSBwcm9wcy5kcmF3UGlja2luZ0NvbG9ycztcbiAgICAgIHRoaXMuX25lZWRzUmVkcmF3ID0gJ2RyYXdQaWNraW5nQ29sb3JzIGNoYW5nZWQnO1xuICAgIH1cbiAgfVxuXG4gIHJlbmRlckxheWVycyhvcHRzKSB7XG4gICAgY29uc3QgbGF5ZXJQYXNzID0gdGhpcy5kcmF3UGlja2luZ0NvbG9ycyA/IHRoaXMucGlja0xheWVyc1Bhc3MgOiB0aGlzLmRyYXdMYXllcnNQYXNzO1xuICAgIGNvbnN0IHJlbmRlck9wdHMgPSB7XG4gICAgICBsYXllckZpbHRlcjogdGhpcy5sYXllckZpbHRlcixcbiAgICAgIGlzUGlja2luZzogdGhpcy5kcmF3UGlja2luZ0NvbG9ycyxcbiAgICAgIC4uLm9wdHMsXG4gICAgICB0YXJnZXQ6IG9wdHMudGFyZ2V0IHx8IEZyYW1lYnVmZmVyLmdldERlZmF1bHRGcmFtZWJ1ZmZlcih0aGlzLmdsKVxuICAgIH07XG5cbiAgICBpZiAocmVuZGVyT3B0cy5lZmZlY3RzKSB7XG4gICAgICB0aGlzLl9wcmVSZW5kZXIocmVuZGVyT3B0cy5lZmZlY3RzLCByZW5kZXJPcHRzKTtcbiAgICB9XG5cbiAgICBjb25zdCBvdXRwdXRCdWZmZXIgPSB0aGlzLmxhc3RQb3N0UHJvY2Vzc0VmZmVjdCA/IHRoaXMucmVuZGVyQnVmZmVyc1swXSA6IHJlbmRlck9wdHMudGFyZ2V0O1xuICAgIGNvbnN0IHJlbmRlclN0YXRzID0gbGF5ZXJQYXNzLnJlbmRlcih7IC4uLnJlbmRlck9wdHMsXG4gICAgICB0YXJnZXQ6IG91dHB1dEJ1ZmZlclxuICAgIH0pO1xuXG4gICAgaWYgKHJlbmRlck9wdHMuZWZmZWN0cykge1xuICAgICAgdGhpcy5fcG9zdFJlbmRlcihyZW5kZXJPcHRzLmVmZmVjdHMsIHJlbmRlck9wdHMpO1xuICAgIH1cblxuICAgIHRoaXMucmVuZGVyQ291bnQrKztcbiAgICBkZWJ1ZyhUUkFDRV9SRU5ERVJfTEFZRVJTLCB0aGlzLCByZW5kZXJTdGF0cywgb3B0cyk7XG4gIH1cblxuICBuZWVkc1JlZHJhdyhvcHRzID0ge1xuICAgIGNsZWFyUmVkcmF3RmxhZ3M6IGZhbHNlXG4gIH0pIHtcbiAgICBjb25zdCByZWRyYXcgPSB0aGlzLl9uZWVkc1JlZHJhdztcblxuICAgIGlmIChvcHRzLmNsZWFyUmVkcmF3RmxhZ3MpIHtcbiAgICAgIHRoaXMuX25lZWRzUmVkcmF3ID0gZmFsc2U7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlZHJhdztcbiAgfVxuXG4gIGZpbmFsaXplKCkge1xuICAgIGNvbnN0IHtcbiAgICAgIHJlbmRlckJ1ZmZlcnNcbiAgICB9ID0gdGhpcztcblxuICAgIGZvciAoY29uc3QgYnVmZmVyIG9mIHJlbmRlckJ1ZmZlcnMpIHtcbiAgICAgIGJ1ZmZlci5kZWxldGUoKTtcbiAgICB9XG5cbiAgICByZW5kZXJCdWZmZXJzLmxlbmd0aCA9IDA7XG4gIH1cblxuICBfcHJlUmVuZGVyKGVmZmVjdHMsIG9wdHMpIHtcbiAgICB0aGlzLmxhc3RQb3N0UHJvY2Vzc0VmZmVjdCA9IG51bGw7XG4gICAgb3B0cy5wcmVSZW5kZXJTdGF0cyA9IG9wdHMucHJlUmVuZGVyU3RhdHMgfHwge307XG5cbiAgICBmb3IgKGNvbnN0IGVmZmVjdCBvZiBlZmZlY3RzKSB7XG4gICAgICBvcHRzLnByZVJlbmRlclN0YXRzW2VmZmVjdC5pZF0gPSBlZmZlY3QucHJlUmVuZGVyKHRoaXMuZ2wsIG9wdHMpO1xuXG4gICAgICBpZiAoZWZmZWN0LnBvc3RSZW5kZXIpIHtcbiAgICAgICAgdGhpcy5sYXN0UG9zdFByb2Nlc3NFZmZlY3QgPSBlZmZlY3QuaWQ7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHRoaXMubGFzdFBvc3RQcm9jZXNzRWZmZWN0KSB7XG4gICAgICB0aGlzLl9yZXNpemVSZW5kZXJCdWZmZXJzKCk7XG4gICAgfVxuICB9XG5cbiAgX3Jlc2l6ZVJlbmRlckJ1ZmZlcnMoKSB7XG4gICAgY29uc3Qge1xuICAgICAgcmVuZGVyQnVmZmVyc1xuICAgIH0gPSB0aGlzO1xuXG4gICAgaWYgKHJlbmRlckJ1ZmZlcnMubGVuZ3RoID09PSAwKSB7XG4gICAgICByZW5kZXJCdWZmZXJzLnB1c2gobmV3IEZyYW1lYnVmZmVyKHRoaXMuZ2wpLCBuZXcgRnJhbWVidWZmZXIodGhpcy5nbCkpO1xuICAgIH1cblxuICAgIGZvciAoY29uc3QgYnVmZmVyIG9mIHJlbmRlckJ1ZmZlcnMpIHtcbiAgICAgIGJ1ZmZlci5yZXNpemUoKTtcbiAgICB9XG4gIH1cblxuICBfcG9zdFJlbmRlcihlZmZlY3RzLCBvcHRzKSB7XG4gICAgY29uc3Qge1xuICAgICAgcmVuZGVyQnVmZmVyc1xuICAgIH0gPSB0aGlzO1xuICAgIGNvbnN0IHBhcmFtcyA9IHsgLi4ub3B0cyxcbiAgICAgIGlucHV0QnVmZmVyOiByZW5kZXJCdWZmZXJzWzBdLFxuICAgICAgc3dhcEJ1ZmZlcjogcmVuZGVyQnVmZmVyc1sxXSxcbiAgICAgIHRhcmdldDogbnVsbFxuICAgIH07XG5cbiAgICBmb3IgKGNvbnN0IGVmZmVjdCBvZiBlZmZlY3RzKSB7XG4gICAgICBpZiAoZWZmZWN0LnBvc3RSZW5kZXIpIHtcbiAgICAgICAgaWYgKGVmZmVjdC5pZCA9PT0gdGhpcy5sYXN0UG9zdFByb2Nlc3NFZmZlY3QpIHtcbiAgICAgICAgICBwYXJhbXMudGFyZ2V0ID0gb3B0cy50YXJnZXQ7XG4gICAgICAgICAgZWZmZWN0LnBvc3RSZW5kZXIodGhpcy5nbCwgcGFyYW1zKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGJ1ZmZlciA9IGVmZmVjdC5wb3N0UmVuZGVyKHRoaXMuZ2wsIHBhcmFtcyk7XG4gICAgICAgIHBhcmFtcy5pbnB1dEJ1ZmZlciA9IGJ1ZmZlcjtcbiAgICAgICAgcGFyYW1zLnN3YXBCdWZmZXIgPSBidWZmZXIgPT09IHJlbmRlckJ1ZmZlcnNbMF0gPyByZW5kZXJCdWZmZXJzWzFdIDogcmVuZGVyQnVmZmVyc1swXTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGVjay1yZW5kZXJlci5qcy5tYXAiLCJpbXBvcnQgX2RlZmluZVByb3BlcnR5IGZyb20gXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9kZWZpbmVQcm9wZXJ0eVwiO1xuaW1wb3J0IHsgRnJhbWVidWZmZXIsIFRleHR1cmUyRCwgaXNXZWJHTDIsIHJlYWRQaXhlbHNUb0FycmF5LCBjc3NUb0RldmljZVJhdGlvLCBjc3NUb0RldmljZVBpeGVscyB9IGZyb20gJ0BsdW1hLmdsL2NvcmUnO1xuaW1wb3J0IFBpY2tMYXllcnNQYXNzIGZyb20gJy4uL3Bhc3Nlcy9waWNrLWxheWVycy1wYXNzJztcbmltcG9ydCB7IGdldENsb3Nlc3RPYmplY3QsIGdldFVuaXF1ZU9iamVjdHMgfSBmcm9tICcuL3BpY2tpbmcvcXVlcnktb2JqZWN0JztcbmltcG9ydCB7IHByb2Nlc3NQaWNrSW5mbywgZ2V0TGF5ZXJQaWNraW5nSW5mbywgZ2V0RW1wdHlQaWNraW5nSW5mbyB9IGZyb20gJy4vcGlja2luZy9waWNrLWluZm8nO1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgRGVja1BpY2tlciB7XG4gIGNvbnN0cnVjdG9yKGdsKSB7XG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwiZ2xcIiwgdm9pZCAwKTtcblxuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInBpY2tpbmdGQk9cIiwgdm9pZCAwKTtcblxuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImRlcHRoRkJPXCIsIHZvaWQgMCk7XG5cbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJwaWNrTGF5ZXJzUGFzc1wiLCB2b2lkIDApO1xuXG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwibGF5ZXJGaWx0ZXJcIiwgdm9pZCAwKTtcblxuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImxhc3RQaWNrZWRJbmZvXCIsIHZvaWQgMCk7XG5cbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJfcGlja2FibGVcIiwgdHJ1ZSk7XG5cbiAgICB0aGlzLmdsID0gZ2w7XG4gICAgdGhpcy5waWNrTGF5ZXJzUGFzcyA9IG5ldyBQaWNrTGF5ZXJzUGFzcyhnbCk7XG4gICAgdGhpcy5sYXN0UGlja2VkSW5mbyA9IHtcbiAgICAgIGluZGV4OiAtMSxcbiAgICAgIGxheWVySWQ6IG51bGwsXG4gICAgICBpbmZvOiBudWxsXG4gICAgfTtcbiAgfVxuXG4gIHNldFByb3BzKHByb3BzKSB7XG4gICAgaWYgKCdsYXllckZpbHRlcicgaW4gcHJvcHMpIHtcbiAgICAgIHRoaXMubGF5ZXJGaWx0ZXIgPSBwcm9wcy5sYXllckZpbHRlcjtcbiAgICB9XG5cbiAgICBpZiAoJ19waWNrYWJsZScgaW4gcHJvcHMpIHtcbiAgICAgIHRoaXMuX3BpY2thYmxlID0gcHJvcHMuX3BpY2thYmxlO1xuICAgIH1cbiAgfVxuXG4gIGZpbmFsaXplKCkge1xuICAgIGlmICh0aGlzLnBpY2tpbmdGQk8pIHtcbiAgICAgIHRoaXMucGlja2luZ0ZCTy5kZWxldGUoKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5kZXB0aEZCTykge1xuICAgICAgdGhpcy5kZXB0aEZCTy5jb2xvci5kZWxldGUoKTtcbiAgICAgIHRoaXMuZGVwdGhGQk8uZGVsZXRlKCk7XG4gICAgfVxuICB9XG5cbiAgcGlja09iamVjdChvcHRzKSB7XG4gICAgcmV0dXJuIHRoaXMuX3BpY2tDbG9zZXN0T2JqZWN0KG9wdHMpO1xuICB9XG5cbiAgcGlja09iamVjdHMob3B0cykge1xuICAgIHJldHVybiB0aGlzLl9waWNrVmlzaWJsZU9iamVjdHMob3B0cyk7XG4gIH1cblxuICBnZXRMYXN0UGlja2VkT2JqZWN0KHtcbiAgICB4LFxuICAgIHksXG4gICAgbGF5ZXJzLFxuICAgIHZpZXdwb3J0c1xuICB9LCBsYXN0UGlja2VkSW5mbyA9IHRoaXMubGFzdFBpY2tlZEluZm8uaW5mbykge1xuICAgIGNvbnN0IGxhc3RQaWNrZWRMYXllcklkID0gbGFzdFBpY2tlZEluZm8gJiYgbGFzdFBpY2tlZEluZm8ubGF5ZXIgJiYgbGFzdFBpY2tlZEluZm8ubGF5ZXIuaWQ7XG4gICAgY29uc3QgbGFzdFBpY2tlZFZpZXdwb3J0SWQgPSBsYXN0UGlja2VkSW5mbyAmJiBsYXN0UGlja2VkSW5mby52aWV3cG9ydCAmJiBsYXN0UGlja2VkSW5mby52aWV3cG9ydC5pZDtcbiAgICBjb25zdCBsYXllciA9IGxhc3RQaWNrZWRMYXllcklkID8gbGF5ZXJzLmZpbmQobCA9PiBsLmlkID09PSBsYXN0UGlja2VkTGF5ZXJJZCkgOiBudWxsO1xuICAgIGNvbnN0IHZpZXdwb3J0ID0gbGFzdFBpY2tlZFZpZXdwb3J0SWQgJiYgdmlld3BvcnRzLmZpbmQodiA9PiB2LmlkID09PSBsYXN0UGlja2VkVmlld3BvcnRJZCkgfHwgdmlld3BvcnRzWzBdO1xuICAgIGNvbnN0IGNvb3JkaW5hdGUgPSB2aWV3cG9ydCAmJiB2aWV3cG9ydC51bnByb2plY3QoW3ggLSB2aWV3cG9ydC54LCB5IC0gdmlld3BvcnQueV0pO1xuICAgIGNvbnN0IGluZm8gPSB7XG4gICAgICB4LFxuICAgICAgeSxcbiAgICAgIHZpZXdwb3J0LFxuICAgICAgY29vcmRpbmF0ZSxcbiAgICAgIGxheWVyXG4gICAgfTtcbiAgICByZXR1cm4geyAuLi5sYXN0UGlja2VkSW5mbyxcbiAgICAgIC4uLmluZm9cbiAgICB9O1xuICB9XG5cbiAgX3Jlc2l6ZUJ1ZmZlcigpIHtcbiAgICB2YXIgX3RoaXMkcGlja2luZ0ZCTywgX3RoaXMkZGVwdGhGQk87XG5cbiAgICBjb25zdCB7XG4gICAgICBnbFxuICAgIH0gPSB0aGlzO1xuXG4gICAgaWYgKCF0aGlzLnBpY2tpbmdGQk8pIHtcbiAgICAgIHRoaXMucGlja2luZ0ZCTyA9IG5ldyBGcmFtZWJ1ZmZlcihnbCk7XG5cbiAgICAgIGlmIChGcmFtZWJ1ZmZlci5pc1N1cHBvcnRlZChnbCwge1xuICAgICAgICBjb2xvckJ1ZmZlckZsb2F0OiB0cnVlXG4gICAgICB9KSkge1xuICAgICAgICBjb25zdCBkZXB0aEZCTyA9IG5ldyBGcmFtZWJ1ZmZlcihnbCk7XG4gICAgICAgIGRlcHRoRkJPLmF0dGFjaCh7XG4gICAgICAgICAgWzM2MDY0XTogbmV3IFRleHR1cmUyRChnbCwge1xuICAgICAgICAgICAgZm9ybWF0OiBpc1dlYkdMMihnbCkgPyAzNDgzNiA6IDY0MDgsXG4gICAgICAgICAgICB0eXBlOiA1MTI2XG4gICAgICAgICAgfSlcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuZGVwdGhGQk8gPSBkZXB0aEZCTztcbiAgICAgIH1cbiAgICB9XG5cbiAgICAoX3RoaXMkcGlja2luZ0ZCTyA9IHRoaXMucGlja2luZ0ZCTykgPT09IG51bGwgfHwgX3RoaXMkcGlja2luZ0ZCTyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX3RoaXMkcGlja2luZ0ZCTy5yZXNpemUoe1xuICAgICAgd2lkdGg6IGdsLmNhbnZhcy53aWR0aCxcbiAgICAgIGhlaWdodDogZ2wuY2FudmFzLmhlaWdodFxuICAgIH0pO1xuICAgIChfdGhpcyRkZXB0aEZCTyA9IHRoaXMuZGVwdGhGQk8pID09PSBudWxsIHx8IF90aGlzJGRlcHRoRkJPID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfdGhpcyRkZXB0aEZCTy5yZXNpemUoe1xuICAgICAgd2lkdGg6IGdsLmNhbnZhcy53aWR0aCxcbiAgICAgIGhlaWdodDogZ2wuY2FudmFzLmhlaWdodFxuICAgIH0pO1xuICB9XG5cbiAgX2dldFBpY2thYmxlKGxheWVycykge1xuICAgIGlmICh0aGlzLl9waWNrYWJsZSA9PT0gZmFsc2UpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIGNvbnN0IHBpY2thYmxlTGF5ZXJzID0gbGF5ZXJzLmZpbHRlcihsYXllciA9PiB0aGlzLnBpY2tMYXllcnNQYXNzLnNob3VsZERyYXdMYXllcihsYXllcikgJiYgIWxheWVyLmlzQ29tcG9zaXRlKTtcbiAgICByZXR1cm4gcGlja2FibGVMYXllcnMubGVuZ3RoID8gcGlja2FibGVMYXllcnMgOiBudWxsO1xuICB9XG5cbiAgX3BpY2tDbG9zZXN0T2JqZWN0KHtcbiAgICBsYXllcnMsXG4gICAgdmlld3MsXG4gICAgdmlld3BvcnRzLFxuICAgIHgsXG4gICAgeSxcbiAgICByYWRpdXMgPSAwLFxuICAgIGRlcHRoID0gMSxcbiAgICBtb2RlID0gJ3F1ZXJ5JyxcbiAgICB1bnByb2plY3QzRCxcbiAgICBvblZpZXdwb3J0QWN0aXZlLFxuICAgIGVmZmVjdHNcbiAgfSkge1xuICAgIGNvbnN0IHBpY2thYmxlTGF5ZXJzID0gdGhpcy5fZ2V0UGlja2FibGUobGF5ZXJzKTtcblxuICAgIGNvbnN0IHBpeGVsUmF0aW8gPSBjc3NUb0RldmljZVJhdGlvKHRoaXMuZ2wpO1xuXG4gICAgaWYgKCFwaWNrYWJsZUxheWVycykge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgcmVzdWx0OiBbXSxcbiAgICAgICAgZW1wdHlJbmZvOiBnZXRFbXB0eVBpY2tpbmdJbmZvKHtcbiAgICAgICAgICB2aWV3cG9ydHMsXG4gICAgICAgICAgeCxcbiAgICAgICAgICB5LFxuICAgICAgICAgIHBpeGVsUmF0aW9cbiAgICAgICAgfSlcbiAgICAgIH07XG4gICAgfVxuXG4gICAgdGhpcy5fcmVzaXplQnVmZmVyKCk7XG5cbiAgICBjb25zdCBkZXZpY2VQaXhlbFJhbmdlID0gY3NzVG9EZXZpY2VQaXhlbHModGhpcy5nbCwgW3gsIHldLCB0cnVlKTtcbiAgICBjb25zdCBkZXZpY2VQaXhlbCA9IFtkZXZpY2VQaXhlbFJhbmdlLnggKyBNYXRoLmZsb29yKGRldmljZVBpeGVsUmFuZ2Uud2lkdGggLyAyKSwgZGV2aWNlUGl4ZWxSYW5nZS55ICsgTWF0aC5mbG9vcihkZXZpY2VQaXhlbFJhbmdlLmhlaWdodCAvIDIpXTtcbiAgICBjb25zdCBkZXZpY2VSYWRpdXMgPSBNYXRoLnJvdW5kKHJhZGl1cyAqIHBpeGVsUmF0aW8pO1xuICAgIGNvbnN0IHtcbiAgICAgIHdpZHRoLFxuICAgICAgaGVpZ2h0XG4gICAgfSA9IHRoaXMucGlja2luZ0ZCTztcblxuICAgIGNvbnN0IGRldmljZVJlY3QgPSB0aGlzLl9nZXRQaWNraW5nUmVjdCh7XG4gICAgICBkZXZpY2VYOiBkZXZpY2VQaXhlbFswXSxcbiAgICAgIGRldmljZVk6IGRldmljZVBpeGVsWzFdLFxuICAgICAgZGV2aWNlUmFkaXVzLFxuICAgICAgZGV2aWNlV2lkdGg6IHdpZHRoLFxuICAgICAgZGV2aWNlSGVpZ2h0OiBoZWlnaHRcbiAgICB9KTtcblxuICAgIGNvbnN0IGN1bGxSZWN0ID0ge1xuICAgICAgeDogeCAtIHJhZGl1cyxcbiAgICAgIHk6IHkgLSByYWRpdXMsXG4gICAgICB3aWR0aDogcmFkaXVzICogMiArIDEsXG4gICAgICBoZWlnaHQ6IHJhZGl1cyAqIDIgKyAxXG4gICAgfTtcbiAgICBsZXQgaW5mb3M7XG4gICAgY29uc3QgcmVzdWx0ID0gW107XG4gICAgY29uc3QgYWZmZWN0ZWRMYXllcnMgPSBuZXcgU2V0KCk7XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGRlcHRoOyBpKyspIHtcbiAgICAgIGxldCBwaWNrSW5mbztcblxuICAgICAgaWYgKGRldmljZVJlY3QpIHtcbiAgICAgICAgY29uc3QgcGlja2VkUmVzdWx0ID0gdGhpcy5fZHJhd0FuZFNhbXBsZSh7XG4gICAgICAgICAgbGF5ZXJzOiBwaWNrYWJsZUxheWVycyxcbiAgICAgICAgICB2aWV3cyxcbiAgICAgICAgICB2aWV3cG9ydHMsXG4gICAgICAgICAgb25WaWV3cG9ydEFjdGl2ZSxcbiAgICAgICAgICBkZXZpY2VSZWN0LFxuICAgICAgICAgIGN1bGxSZWN0LFxuICAgICAgICAgIGVmZmVjdHMsXG4gICAgICAgICAgcGFzczogXCJwaWNraW5nOlwiLmNvbmNhdChtb2RlKVxuICAgICAgICB9KTtcblxuICAgICAgICBwaWNrSW5mbyA9IGdldENsb3Nlc3RPYmplY3QoeyAuLi5waWNrZWRSZXN1bHQsXG4gICAgICAgICAgZGV2aWNlWDogZGV2aWNlUGl4ZWxbMF0sXG4gICAgICAgICAgZGV2aWNlWTogZGV2aWNlUGl4ZWxbMV0sXG4gICAgICAgICAgZGV2aWNlUmFkaXVzLFxuICAgICAgICAgIGRldmljZVJlY3RcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwaWNrSW5mbyA9IHtcbiAgICAgICAgICBwaWNrZWRDb2xvcjogbnVsbCxcbiAgICAgICAgICBwaWNrZWRPYmplY3RJbmRleDogLTFcbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgbGV0IHo7XG5cbiAgICAgIGlmIChwaWNrSW5mby5waWNrZWRMYXllciAmJiB1bnByb2plY3QzRCAmJiB0aGlzLmRlcHRoRkJPKSB7XG4gICAgICAgIGNvbnN0IHtcbiAgICAgICAgICBwaWNrZWRDb2xvcnM6IHBpY2tlZENvbG9yczJcbiAgICAgICAgfSA9IHRoaXMuX2RyYXdBbmRTYW1wbGUoe1xuICAgICAgICAgIGxheWVyczogW3BpY2tJbmZvLnBpY2tlZExheWVyXSxcbiAgICAgICAgICB2aWV3cyxcbiAgICAgICAgICB2aWV3cG9ydHMsXG4gICAgICAgICAgb25WaWV3cG9ydEFjdGl2ZSxcbiAgICAgICAgICBkZXZpY2VSZWN0OiB7XG4gICAgICAgICAgICB4OiBwaWNrSW5mby5waWNrZWRYLFxuICAgICAgICAgICAgeTogcGlja0luZm8ucGlja2VkWSxcbiAgICAgICAgICAgIHdpZHRoOiAxLFxuICAgICAgICAgICAgaGVpZ2h0OiAxXG4gICAgICAgICAgfSxcbiAgICAgICAgICBjdWxsUmVjdCxcbiAgICAgICAgICBlZmZlY3RzLFxuICAgICAgICAgIHBhc3M6IFwicGlja2luZzpcIi5jb25jYXQobW9kZSwgXCI6elwiKVxuICAgICAgICB9LCB0cnVlKTtcblxuICAgICAgICBpZiAocGlja2VkQ29sb3JzMlszXSkge1xuICAgICAgICAgIHogPSBwaWNrZWRDb2xvcnMyWzBdO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChwaWNrSW5mby5waWNrZWRMYXllciAmJiBpICsgMSA8IGRlcHRoKSB7XG4gICAgICAgIGFmZmVjdGVkTGF5ZXJzLmFkZChwaWNrSW5mby5waWNrZWRMYXllcik7XG4gICAgICAgIHBpY2tJbmZvLnBpY2tlZExheWVyLmRpc2FibGVQaWNraW5nSW5kZXgocGlja0luZm8ucGlja2VkT2JqZWN0SW5kZXgpO1xuICAgICAgfVxuXG4gICAgICBpbmZvcyA9IHByb2Nlc3NQaWNrSW5mbyh7XG4gICAgICAgIHBpY2tJbmZvLFxuICAgICAgICBsYXN0UGlja2VkSW5mbzogdGhpcy5sYXN0UGlja2VkSW5mbyxcbiAgICAgICAgbW9kZSxcbiAgICAgICAgbGF5ZXJzOiBwaWNrYWJsZUxheWVycyxcbiAgICAgICAgdmlld3BvcnRzLFxuICAgICAgICB4LFxuICAgICAgICB5LFxuICAgICAgICB6LFxuICAgICAgICBwaXhlbFJhdGlvXG4gICAgICB9KTtcblxuICAgICAgZm9yIChjb25zdCBpbmZvIG9mIGluZm9zLnZhbHVlcygpKSB7XG4gICAgICAgIGlmIChpbmZvLmxheWVyKSB7XG4gICAgICAgICAgcmVzdWx0LnB1c2goaW5mbyk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKCFwaWNrSW5mby5waWNrZWRDb2xvcikge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmb3IgKGNvbnN0IGxheWVyIG9mIGFmZmVjdGVkTGF5ZXJzKSB7XG4gICAgICBsYXllci5yZXN0b3JlUGlja2luZ0NvbG9ycygpO1xuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICByZXN1bHQsXG4gICAgICBlbXB0eUluZm86IGluZm9zLmdldChudWxsKVxuICAgIH07XG4gIH1cblxuICBfcGlja1Zpc2libGVPYmplY3RzKHtcbiAgICBsYXllcnMsXG4gICAgdmlld3MsXG4gICAgdmlld3BvcnRzLFxuICAgIHgsXG4gICAgeSxcbiAgICB3aWR0aCA9IDEsXG4gICAgaGVpZ2h0ID0gMSxcbiAgICBtb2RlID0gJ3F1ZXJ5JyxcbiAgICBtYXhPYmplY3RzID0gbnVsbCxcbiAgICBvblZpZXdwb3J0QWN0aXZlLFxuICAgIGVmZmVjdHNcbiAgfSkge1xuICAgIGNvbnN0IHBpY2thYmxlTGF5ZXJzID0gdGhpcy5fZ2V0UGlja2FibGUobGF5ZXJzKTtcblxuICAgIGlmICghcGlja2FibGVMYXllcnMpIHtcbiAgICAgIHJldHVybiBbXTtcbiAgICB9XG5cbiAgICB0aGlzLl9yZXNpemVCdWZmZXIoKTtcblxuICAgIGNvbnN0IHBpeGVsUmF0aW8gPSBjc3NUb0RldmljZVJhdGlvKHRoaXMuZ2wpO1xuICAgIGNvbnN0IGxlZnRUb3AgPSBjc3NUb0RldmljZVBpeGVscyh0aGlzLmdsLCBbeCwgeV0sIHRydWUpO1xuICAgIGNvbnN0IGRldmljZUxlZnQgPSBsZWZ0VG9wLng7XG4gICAgY29uc3QgZGV2aWNlVG9wID0gbGVmdFRvcC55ICsgbGVmdFRvcC5oZWlnaHQ7XG4gICAgY29uc3QgcmlnaHRCb3R0b20gPSBjc3NUb0RldmljZVBpeGVscyh0aGlzLmdsLCBbeCArIHdpZHRoLCB5ICsgaGVpZ2h0XSwgdHJ1ZSk7XG4gICAgY29uc3QgZGV2aWNlUmlnaHQgPSByaWdodEJvdHRvbS54ICsgcmlnaHRCb3R0b20ud2lkdGg7XG4gICAgY29uc3QgZGV2aWNlQm90dG9tID0gcmlnaHRCb3R0b20ueTtcbiAgICBjb25zdCBkZXZpY2VSZWN0ID0ge1xuICAgICAgeDogZGV2aWNlTGVmdCxcbiAgICAgIHk6IGRldmljZUJvdHRvbSxcbiAgICAgIHdpZHRoOiBkZXZpY2VSaWdodCAtIGRldmljZUxlZnQsXG4gICAgICBoZWlnaHQ6IGRldmljZVRvcCAtIGRldmljZUJvdHRvbVxuICAgIH07XG5cbiAgICBjb25zdCBwaWNrZWRSZXN1bHQgPSB0aGlzLl9kcmF3QW5kU2FtcGxlKHtcbiAgICAgIGxheWVyczogcGlja2FibGVMYXllcnMsXG4gICAgICB2aWV3cyxcbiAgICAgIHZpZXdwb3J0cyxcbiAgICAgIG9uVmlld3BvcnRBY3RpdmUsXG4gICAgICBkZXZpY2VSZWN0LFxuICAgICAgY3VsbFJlY3Q6IHtcbiAgICAgICAgeCxcbiAgICAgICAgeSxcbiAgICAgICAgd2lkdGgsXG4gICAgICAgIGhlaWdodFxuICAgICAgfSxcbiAgICAgIGVmZmVjdHMsXG4gICAgICBwYXNzOiBcInBpY2tpbmc6XCIuY29uY2F0KG1vZGUpXG4gICAgfSk7XG5cbiAgICBjb25zdCBwaWNrSW5mb3MgPSBnZXRVbmlxdWVPYmplY3RzKHBpY2tlZFJlc3VsdCk7XG4gICAgY29uc3QgdW5pcXVlSW5mb3MgPSBuZXcgTWFwKCk7XG4gICAgY29uc3QgaXNNYXhPYmplY3RzID0gTnVtYmVyLmlzRmluaXRlKG1heE9iamVjdHMpO1xuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwaWNrSW5mb3MubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmIChpc01heE9iamVjdHMgJiYgbWF4T2JqZWN0cyAmJiB1bmlxdWVJbmZvcy5zaXplID49IG1heE9iamVjdHMpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHBpY2tJbmZvID0gcGlja0luZm9zW2ldO1xuICAgICAgbGV0IGluZm8gPSB7XG4gICAgICAgIGNvbG9yOiBwaWNrSW5mby5waWNrZWRDb2xvcixcbiAgICAgICAgbGF5ZXI6IG51bGwsXG4gICAgICAgIGluZGV4OiBwaWNrSW5mby5waWNrZWRPYmplY3RJbmRleCxcbiAgICAgICAgcGlja2VkOiB0cnVlLFxuICAgICAgICB4LFxuICAgICAgICB5LFxuICAgICAgICBwaXhlbFJhdGlvXG4gICAgICB9O1xuICAgICAgaW5mbyA9IGdldExheWVyUGlja2luZ0luZm8oe1xuICAgICAgICBsYXllcjogcGlja0luZm8ucGlja2VkTGF5ZXIsXG4gICAgICAgIGluZm8sXG4gICAgICAgIG1vZGVcbiAgICAgIH0pO1xuXG4gICAgICBpZiAoIXVuaXF1ZUluZm9zLmhhcyhpbmZvLm9iamVjdCkpIHtcbiAgICAgICAgdW5pcXVlSW5mb3Muc2V0KGluZm8ub2JqZWN0LCBpbmZvKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gQXJyYXkuZnJvbSh1bmlxdWVJbmZvcy52YWx1ZXMoKSk7XG4gIH1cblxuICBfZHJhd0FuZFNhbXBsZSh7XG4gICAgbGF5ZXJzLFxuICAgIHZpZXdzLFxuICAgIHZpZXdwb3J0cyxcbiAgICBvblZpZXdwb3J0QWN0aXZlLFxuICAgIGRldmljZVJlY3QsXG4gICAgY3VsbFJlY3QsXG4gICAgZWZmZWN0cyxcbiAgICBwYXNzXG4gIH0sIHBpY2taID0gZmFsc2UpIHtcbiAgICBjb25zdCBwaWNraW5nRkJPID0gcGlja1ogPyB0aGlzLmRlcHRoRkJPIDogdGhpcy5waWNraW5nRkJPO1xuICAgIGNvbnN0IG9wdHMgPSB7XG4gICAgICBsYXllcnMsXG4gICAgICBsYXllckZpbHRlcjogdGhpcy5sYXllckZpbHRlcixcbiAgICAgIHZpZXdzLFxuICAgICAgdmlld3BvcnRzLFxuICAgICAgb25WaWV3cG9ydEFjdGl2ZSxcbiAgICAgIHBpY2tpbmdGQk8sXG4gICAgICBkZXZpY2VSZWN0LFxuICAgICAgY3VsbFJlY3QsXG4gICAgICBlZmZlY3RzLFxuICAgICAgcGFzcyxcbiAgICAgIHBpY2taLFxuICAgICAgcHJlUmVuZGVyU3RhdHM6IHt9XG4gICAgfTtcblxuICAgIGZvciAoY29uc3QgZWZmZWN0IG9mIGVmZmVjdHMpIHtcbiAgICAgIGlmIChlZmZlY3QudXNlSW5QaWNraW5nKSB7XG4gICAgICAgIG9wdHMucHJlUmVuZGVyU3RhdHNbZWZmZWN0LmlkXSA9IGVmZmVjdC5wcmVSZW5kZXIodGhpcy5nbCwgb3B0cyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgY29uc3Qge1xuICAgICAgZGVjb2RlUGlja2luZ0NvbG9yXG4gICAgfSA9IHRoaXMucGlja0xheWVyc1Bhc3MucmVuZGVyKG9wdHMpO1xuICAgIGNvbnN0IHtcbiAgICAgIHgsXG4gICAgICB5LFxuICAgICAgd2lkdGgsXG4gICAgICBoZWlnaHRcbiAgICB9ID0gZGV2aWNlUmVjdDtcbiAgICBjb25zdCBwaWNrZWRDb2xvcnMgPSBuZXcgKHBpY2taID8gRmxvYXQzMkFycmF5IDogVWludDhBcnJheSkod2lkdGggKiBoZWlnaHQgKiA0KTtcbiAgICByZWFkUGl4ZWxzVG9BcnJheShwaWNraW5nRkJPLCB7XG4gICAgICBzb3VyY2VYOiB4LFxuICAgICAgc291cmNlWTogeSxcbiAgICAgIHNvdXJjZVdpZHRoOiB3aWR0aCxcbiAgICAgIHNvdXJjZUhlaWdodDogaGVpZ2h0LFxuICAgICAgdGFyZ2V0OiBwaWNrZWRDb2xvcnNcbiAgICB9KTtcbiAgICByZXR1cm4ge1xuICAgICAgcGlja2VkQ29sb3JzLFxuICAgICAgZGVjb2RlUGlja2luZ0NvbG9yXG4gICAgfTtcbiAgfVxuXG4gIF9nZXRQaWNraW5nUmVjdCh7XG4gICAgZGV2aWNlWCxcbiAgICBkZXZpY2VZLFxuICAgIGRldmljZVJhZGl1cyxcbiAgICBkZXZpY2VXaWR0aCxcbiAgICBkZXZpY2VIZWlnaHRcbiAgfSkge1xuICAgIGNvbnN0IHggPSBNYXRoLm1heCgwLCBkZXZpY2VYIC0gZGV2aWNlUmFkaXVzKTtcbiAgICBjb25zdCB5ID0gTWF0aC5tYXgoMCwgZGV2aWNlWSAtIGRldmljZVJhZGl1cyk7XG4gICAgY29uc3Qgd2lkdGggPSBNYXRoLm1pbihkZXZpY2VXaWR0aCwgZGV2aWNlWCArIGRldmljZVJhZGl1cyArIDEpIC0geDtcbiAgICBjb25zdCBoZWlnaHQgPSBNYXRoLm1pbihkZXZpY2VIZWlnaHQsIGRldmljZVkgKyBkZXZpY2VSYWRpdXMgKyAxKSAtIHk7XG5cbiAgICBpZiAod2lkdGggPD0gMCB8fCBoZWlnaHQgPD0gMCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIHgsXG4gICAgICB5LFxuICAgICAgd2lkdGgsXG4gICAgICBoZWlnaHRcbiAgICB9O1xuICB9XG5cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRlY2stcGlja2VyLmpzLm1hcCIsImltcG9ydCB7IHJlZ2lzdGVyTG9hZGVycyB9IGZyb20gJ0Bsb2FkZXJzLmdsL2NvcmUnO1xuaW1wb3J0IHsgSW1hZ2VMb2FkZXIgfSBmcm9tICdAbG9hZGVycy5nbC9pbWFnZXMnO1xuaW1wb3J0IGxvZyBmcm9tICcuLi91dGlscy9sb2cnO1xuaW1wb3J0IHsgcmVnaXN0ZXIgfSBmcm9tICcuLi9kZWJ1Zyc7XG5pbXBvcnQganNvbkxvYWRlciBmcm9tICcuLi91dGlscy9qc29uLWxvYWRlcic7XG5cbmZ1bmN0aW9uIGNoZWNrVmVyc2lvbigpIHtcbiAgY29uc3QgdmVyc2lvbiA9IHR5cGVvZiBcIjguOS40XCIgIT09ICd1bmRlZmluZWQnID8gXCI4LjkuNFwiIDogZ2xvYmFsVGhpcy5ERUNLX1ZFUlNJT04gfHwgJ3VudHJhbnNwaWxlZCBzb3VyY2UnO1xuICBjb25zdCBleGlzdGluZ1ZlcnNpb24gPSBnbG9iYWxUaGlzLmRlY2sgJiYgZ2xvYmFsVGhpcy5kZWNrLlZFUlNJT047XG5cbiAgaWYgKGV4aXN0aW5nVmVyc2lvbiAmJiBleGlzdGluZ1ZlcnNpb24gIT09IHZlcnNpb24pIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJkZWNrLmdsIC0gbXVsdGlwbGUgdmVyc2lvbnMgZGV0ZWN0ZWQ6IFwiLmNvbmNhdChleGlzdGluZ1ZlcnNpb24sIFwiIHZzIFwiKS5jb25jYXQodmVyc2lvbikpO1xuICB9XG5cbiAgaWYgKCFleGlzdGluZ1ZlcnNpb24pIHtcbiAgICBsb2cubG9nKDEsIFwiZGVjay5nbCBcIi5jb25jYXQodmVyc2lvbikpKCk7XG4gICAgZ2xvYmFsVGhpcy5kZWNrID0geyAuLi5nbG9iYWxUaGlzLmRlY2ssXG4gICAgICBWRVJTSU9OOiB2ZXJzaW9uLFxuICAgICAgdmVyc2lvbixcbiAgICAgIGxvZyxcbiAgICAgIF9yZWdpc3RlckxvZ2dlcnM6IHJlZ2lzdGVyXG4gICAgfTtcbiAgICByZWdpc3RlckxvYWRlcnMoW2pzb25Mb2FkZXIsIFtJbWFnZUxvYWRlciwge1xuICAgICAgaW1hZ2ViaXRtYXA6IHtcbiAgICAgICAgcHJlbXVsdGlwbHlBbHBoYTogJ25vbmUnXG4gICAgICB9XG4gICAgfV1dKTtcbiAgfVxuXG4gIHJldHVybiB2ZXJzaW9uO1xufVxuXG5leHBvcnQgY29uc3QgVkVSU0lPTiA9IGNoZWNrVmVyc2lvbigpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5pdC5qcy5tYXAiLCJpbXBvcnQgX2RlZmluZVByb3BlcnR5IGZyb20gXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9kZWZpbmVQcm9wZXJ0eVwiO1xuaW1wb3J0IExheWVyTWFuYWdlciBmcm9tICcuL2xheWVyLW1hbmFnZXInO1xuaW1wb3J0IFZpZXdNYW5hZ2VyIGZyb20gJy4vdmlldy1tYW5hZ2VyJztcbmltcG9ydCBNYXBWaWV3IGZyb20gJy4uL3ZpZXdzL21hcC12aWV3JztcbmltcG9ydCBFZmZlY3RNYW5hZ2VyIGZyb20gJy4vZWZmZWN0LW1hbmFnZXInO1xuaW1wb3J0IERlY2tSZW5kZXJlciBmcm9tICcuL2RlY2stcmVuZGVyZXInO1xuaW1wb3J0IERlY2tQaWNrZXIgZnJvbSAnLi9kZWNrLXBpY2tlcic7XG5pbXBvcnQgVG9vbHRpcCBmcm9tICcuL3Rvb2x0aXAnO1xuaW1wb3J0IGxvZyBmcm9tICcuLi91dGlscy9sb2cnO1xuaW1wb3J0IHsgZGVlcEVxdWFsIH0gZnJvbSAnLi4vdXRpbHMvZGVlcC1lcXVhbCc7XG5pbXBvcnQgdHlwZWRBcnJheU1hbmFnZXIgZnJvbSAnLi4vdXRpbHMvdHlwZWQtYXJyYXktbWFuYWdlcic7XG5pbXBvcnQgeyBWRVJTSU9OIH0gZnJvbSAnLi9pbml0JztcbmltcG9ydCB7IGdldEJyb3dzZXIgfSBmcm9tICdAcHJvYmUuZ2wvZW52JztcbmltcG9ydCB7IEFuaW1hdGlvbkxvb3AsIGNyZWF0ZUdMQ29udGV4dCwgaW5zdHJ1bWVudEdMQ29udGV4dCwgc2V0UGFyYW1ldGVycywgVGltZWxpbmUsIGx1bWFTdGF0cyB9IGZyb20gJ0BsdW1hLmdsL2NvcmUnO1xuaW1wb3J0IHsgU3RhdHMgfSBmcm9tICdAcHJvYmUuZ2wvc3RhdHMnO1xuaW1wb3J0IHsgRXZlbnRNYW5hZ2VyIH0gZnJvbSAnbWpvbG5pci5qcyc7XG5pbXBvcnQgYXNzZXJ0IGZyb20gJy4uL3V0aWxzL2Fzc2VydCc7XG5pbXBvcnQgeyBFVkVOVFMgfSBmcm9tICcuL2NvbnN0YW50cyc7XG5cbmZ1bmN0aW9uIG5vb3AoKSB7fVxuXG5jb25zdCBnZXRDdXJzb3IgPSAoe1xuICBpc0RyYWdnaW5nXG59KSA9PiBpc0RyYWdnaW5nID8gJ2dyYWJiaW5nJyA6ICdncmFiJztcblxuY29uc3QgZGVmYXVsdFByb3BzID0ge1xuICBpZDogJycsXG4gIHdpZHRoOiAnMTAwJScsXG4gIGhlaWdodDogJzEwMCUnLFxuICBzdHlsZTogbnVsbCxcbiAgdmlld1N0YXRlOiBudWxsLFxuICBpbml0aWFsVmlld1N0YXRlOiBudWxsLFxuICBwaWNraW5nUmFkaXVzOiAwLFxuICBsYXllckZpbHRlcjogbnVsbCxcbiAgZ2xPcHRpb25zOiB7fSxcbiAgcGFyYW1ldGVyczoge30sXG4gIHBhcmVudDogbnVsbCxcbiAgZ2w6IG51bGwsXG4gIGNhbnZhczogbnVsbCxcbiAgbGF5ZXJzOiBbXSxcbiAgZWZmZWN0czogW10sXG4gIHZpZXdzOiBudWxsLFxuICBjb250cm9sbGVyOiBudWxsLFxuICB1c2VEZXZpY2VQaXhlbHM6IHRydWUsXG4gIHRvdWNoQWN0aW9uOiAnbm9uZScsXG4gIGV2ZW50UmVjb2duaXplck9wdGlvbnM6IHt9LFxuICBfZnJhbWVidWZmZXI6IG51bGwsXG4gIF9hbmltYXRlOiBmYWxzZSxcbiAgX3BpY2thYmxlOiB0cnVlLFxuICBfdHlwZWRBcnJheU1hbmFnZXJQcm9wczoge30sXG4gIF9jdXN0b21SZW5kZXI6IG51bGwsXG4gIG9uV2ViR0xJbml0aWFsaXplZDogbm9vcCxcbiAgb25SZXNpemU6IG5vb3AsXG4gIG9uVmlld1N0YXRlQ2hhbmdlOiBub29wLFxuICBvbkludGVyYWN0aW9uU3RhdGVDaGFuZ2U6IG5vb3AsXG4gIG9uQmVmb3JlUmVuZGVyOiBub29wLFxuICBvbkFmdGVyUmVuZGVyOiBub29wLFxuICBvbkxvYWQ6IG5vb3AsXG4gIG9uRXJyb3I6IGVycm9yID0+IGxvZy5lcnJvcihlcnJvci5tZXNzYWdlKSgpLFxuICBvbkhvdmVyOiBudWxsLFxuICBvbkNsaWNrOiBudWxsLFxuICBvbkRyYWdTdGFydDogbnVsbCxcbiAgb25EcmFnOiBudWxsLFxuICBvbkRyYWdFbmQ6IG51bGwsXG4gIF9vbk1ldHJpY3M6IG51bGwsXG4gIGdldEN1cnNvcixcbiAgZ2V0VG9vbHRpcDogbnVsbCxcbiAgZGVidWc6IGZhbHNlLFxuICBkcmF3UGlja2luZ0NvbG9yczogZmFsc2Vcbn07XG5leHBvcnQgZGVmYXVsdCBjbGFzcyBEZWNrIHtcbiAgY29uc3RydWN0b3IocHJvcHMpIHtcbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJwcm9wc1wiLCB2b2lkIDApO1xuXG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwid2lkdGhcIiwgMCk7XG5cbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJoZWlnaHRcIiwgMCk7XG5cbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJ1c2VyRGF0YVwiLCB7fSk7XG5cbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJjYW52YXNcIiwgbnVsbCk7XG5cbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJ2aWV3TWFuYWdlclwiLCBudWxsKTtcblxuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImxheWVyTWFuYWdlclwiLCBudWxsKTtcblxuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImVmZmVjdE1hbmFnZXJcIiwgbnVsbCk7XG5cbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJkZWNrUmVuZGVyZXJcIiwgbnVsbCk7XG5cbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJkZWNrUGlja2VyXCIsIG51bGwpO1xuXG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwiZXZlbnRNYW5hZ2VyXCIsIG51bGwpO1xuXG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwidG9vbHRpcFwiLCBudWxsKTtcblxuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIm1ldHJpY3NcIiwgdm9pZCAwKTtcblxuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImFuaW1hdGlvbkxvb3BcIiwgdm9pZCAwKTtcblxuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInN0YXRzXCIsIHZvaWQgMCk7XG5cbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJ2aWV3U3RhdGVcIiwgdm9pZCAwKTtcblxuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImN1cnNvclN0YXRlXCIsIHZvaWQgMCk7XG5cbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJfbmVlZHNSZWRyYXdcIiwgdm9pZCAwKTtcblxuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIl9waWNrUmVxdWVzdFwiLCB2b2lkIDApO1xuXG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwiX2xhc3RQb2ludGVyRG93bkluZm9cIiwgbnVsbCk7XG5cbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJfbWV0cmljc0NvdW50ZXJcIiwgdm9pZCAwKTtcblxuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIl9vblBvaW50ZXJNb3ZlXCIsIGV2ZW50ID0+IHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgX3BpY2tSZXF1ZXN0XG4gICAgICB9ID0gdGhpcztcblxuICAgICAgaWYgKGV2ZW50LnR5cGUgPT09ICdwb2ludGVybGVhdmUnKSB7XG4gICAgICAgIF9waWNrUmVxdWVzdC54ID0gLTE7XG4gICAgICAgIF9waWNrUmVxdWVzdC55ID0gLTE7XG4gICAgICAgIF9waWNrUmVxdWVzdC5yYWRpdXMgPSAwO1xuICAgICAgfSBlbHNlIGlmIChldmVudC5sZWZ0QnV0dG9uIHx8IGV2ZW50LnJpZ2h0QnV0dG9uKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IHBvcyA9IGV2ZW50Lm9mZnNldENlbnRlcjtcblxuICAgICAgICBpZiAoIXBvcykge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIF9waWNrUmVxdWVzdC54ID0gcG9zLng7XG4gICAgICAgIF9waWNrUmVxdWVzdC55ID0gcG9zLnk7XG4gICAgICAgIF9waWNrUmVxdWVzdC5yYWRpdXMgPSB0aGlzLnByb3BzLnBpY2tpbmdSYWRpdXM7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLmxheWVyTWFuYWdlcikge1xuICAgICAgICB0aGlzLmxheWVyTWFuYWdlci5jb250ZXh0Lm1vdXNlUG9zaXRpb24gPSB7XG4gICAgICAgICAgeDogX3BpY2tSZXF1ZXN0LngsXG4gICAgICAgICAgeTogX3BpY2tSZXF1ZXN0LnlcbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgX3BpY2tSZXF1ZXN0LmV2ZW50ID0gZXZlbnQ7XG4gICAgfSk7XG5cbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJfb25FdmVudFwiLCBldmVudCA9PiB7XG4gICAgICBjb25zdCBldmVudE9wdGlvbnMgPSBFVkVOVFNbZXZlbnQudHlwZV07XG4gICAgICBjb25zdCBwb3MgPSBldmVudC5vZmZzZXRDZW50ZXI7XG5cbiAgICAgIGlmICghZXZlbnRPcHRpb25zIHx8ICFwb3MgfHwgIXRoaXMubGF5ZXJNYW5hZ2VyKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgY29uc3QgbGF5ZXJzID0gdGhpcy5sYXllck1hbmFnZXIuZ2V0TGF5ZXJzKCk7XG4gICAgICBjb25zdCBpbmZvID0gdGhpcy5kZWNrUGlja2VyLmdldExhc3RQaWNrZWRPYmplY3Qoe1xuICAgICAgICB4OiBwb3MueCxcbiAgICAgICAgeTogcG9zLnksXG4gICAgICAgIGxheWVycyxcbiAgICAgICAgdmlld3BvcnRzOiB0aGlzLmdldFZpZXdwb3J0cyhwb3MpXG4gICAgICB9LCB0aGlzLl9sYXN0UG9pbnRlckRvd25JbmZvKTtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgbGF5ZXJcbiAgICAgIH0gPSBpbmZvO1xuICAgICAgY29uc3QgbGF5ZXJIYW5kbGVyID0gbGF5ZXIgJiYgKGxheWVyW2V2ZW50T3B0aW9ucy5oYW5kbGVyXSB8fCBsYXllci5wcm9wc1tldmVudE9wdGlvbnMuaGFuZGxlcl0pO1xuICAgICAgY29uc3Qgcm9vdEhhbmRsZXIgPSB0aGlzLnByb3BzW2V2ZW50T3B0aW9ucy5oYW5kbGVyXTtcbiAgICAgIGxldCBoYW5kbGVkID0gZmFsc2U7XG5cbiAgICAgIGlmIChsYXllckhhbmRsZXIpIHtcbiAgICAgICAgaGFuZGxlZCA9IGxheWVySGFuZGxlci5jYWxsKGxheWVyLCBpbmZvLCBldmVudCk7XG4gICAgICB9XG5cbiAgICAgIGlmICghaGFuZGxlZCAmJiByb290SGFuZGxlcikge1xuICAgICAgICByb290SGFuZGxlcihpbmZvLCBldmVudCk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJfb25Qb2ludGVyRG93blwiLCBldmVudCA9PiB7XG4gICAgICBjb25zdCBwb3MgPSBldmVudC5vZmZzZXRDZW50ZXI7XG5cbiAgICAgIGNvbnN0IHBpY2tlZEluZm8gPSB0aGlzLl9waWNrKCdwaWNrT2JqZWN0JywgJ3BpY2tPYmplY3QgVGltZScsIHtcbiAgICAgICAgeDogcG9zLngsXG4gICAgICAgIHk6IHBvcy55LFxuICAgICAgICByYWRpdXM6IHRoaXMucHJvcHMucGlja2luZ1JhZGl1c1xuICAgICAgfSk7XG5cbiAgICAgIHRoaXMuX2xhc3RQb2ludGVyRG93bkluZm8gPSBwaWNrZWRJbmZvLnJlc3VsdFswXSB8fCBwaWNrZWRJbmZvLmVtcHR5SW5mbztcbiAgICB9KTtcblxuICAgIHRoaXMucHJvcHMgPSB7IC4uLmRlZmF1bHRQcm9wcyxcbiAgICAgIC4uLnByb3BzXG4gICAgfTtcbiAgICBwcm9wcyA9IHRoaXMucHJvcHM7XG4gICAgdGhpcy5fbmVlZHNSZWRyYXcgPSAnSW5pdGlhbCByZW5kZXInO1xuICAgIHRoaXMuX3BpY2tSZXF1ZXN0ID0ge1xuICAgICAgbW9kZTogJ2hvdmVyJyxcbiAgICAgIHg6IC0xLFxuICAgICAgeTogLTEsXG4gICAgICByYWRpdXM6IDAsXG4gICAgICBldmVudDogbnVsbFxuICAgIH07XG4gICAgdGhpcy5jdXJzb3JTdGF0ZSA9IHtcbiAgICAgIGlzSG92ZXJpbmc6IGZhbHNlLFxuICAgICAgaXNEcmFnZ2luZzogZmFsc2VcbiAgICB9O1xuXG4gICAgaWYgKHByb3BzLnZpZXdTdGF0ZSAmJiBwcm9wcy5pbml0aWFsVmlld1N0YXRlKSB7XG4gICAgICBsb2cud2FybignVmlldyBzdGF0ZSB0cmFja2luZyBpcyBkaXNhYmxlZC4gVXNlIGVpdGhlciBgaW5pdGlhbFZpZXdTdGF0ZWAgZm9yIGF1dG8gdXBkYXRlIG9yIGB2aWV3U3RhdGVgIGZvciBtYW51YWwgdXBkYXRlLicpKCk7XG4gICAgfVxuXG4gICAgaWYgKGdldEJyb3dzZXIoKSA9PT0gJ0lFJykge1xuICAgICAgbG9nLndhcm4oJ0lFIDExIGlzIG5vdCBzdXBwb3J0ZWQnKSgpO1xuICAgIH1cblxuICAgIHRoaXMudmlld1N0YXRlID0gcHJvcHMuaW5pdGlhbFZpZXdTdGF0ZTtcblxuICAgIGlmICghcHJvcHMuZ2wpIHtcbiAgICAgIGlmICh0eXBlb2YgZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHRoaXMuY2FudmFzID0gdGhpcy5fY3JlYXRlQ2FudmFzKHByb3BzKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLmFuaW1hdGlvbkxvb3AgPSB0aGlzLl9jcmVhdGVBbmltYXRpb25Mb29wKHByb3BzKTtcbiAgICB0aGlzLnN0YXRzID0gbmV3IFN0YXRzKHtcbiAgICAgIGlkOiAnZGVjay5nbCdcbiAgICB9KTtcbiAgICB0aGlzLm1ldHJpY3MgPSB7XG4gICAgICBmcHM6IDAsXG4gICAgICBzZXRQcm9wc1RpbWU6IDAsXG4gICAgICB1cGRhdGVBdHRyaWJ1dGVzVGltZTogMCxcbiAgICAgIGZyYW1lc1JlZHJhd246IDAsXG4gICAgICBwaWNrVGltZTogMCxcbiAgICAgIHBpY2tDb3VudDogMCxcbiAgICAgIGdwdVRpbWU6IDAsXG4gICAgICBncHVUaW1lUGVyRnJhbWU6IDAsXG4gICAgICBjcHVUaW1lOiAwLFxuICAgICAgY3B1VGltZVBlckZyYW1lOiAwLFxuICAgICAgYnVmZmVyTWVtb3J5OiAwLFxuICAgICAgdGV4dHVyZU1lbW9yeTogMCxcbiAgICAgIHJlbmRlcmJ1ZmZlck1lbW9yeTogMCxcbiAgICAgIGdwdU1lbW9yeTogMFxuICAgIH07XG4gICAgdGhpcy5fbWV0cmljc0NvdW50ZXIgPSAwO1xuICAgIHRoaXMuc2V0UHJvcHMocHJvcHMpO1xuXG4gICAgaWYgKHByb3BzLl90eXBlZEFycmF5TWFuYWdlclByb3BzKSB7XG4gICAgICB0eXBlZEFycmF5TWFuYWdlci5zZXRPcHRpb25zKHByb3BzLl90eXBlZEFycmF5TWFuYWdlclByb3BzKTtcbiAgICB9XG5cbiAgICB0aGlzLmFuaW1hdGlvbkxvb3Auc3RhcnQoKTtcbiAgfVxuXG4gIGZpbmFsaXplKCkge1xuICAgIHZhciBfdGhpcyRsYXllck1hbmFnZXIsIF90aGlzJHZpZXdNYW5hZ2VyLCBfdGhpcyRlZmZlY3RNYW5hZ2VyLCBfdGhpcyRkZWNrUmVuZGVyZXIsIF90aGlzJGRlY2tQaWNrZXIsIF90aGlzJGV2ZW50TWFuYWdlciwgX3RoaXMkdG9vbHRpcDtcblxuICAgIHRoaXMuYW5pbWF0aW9uTG9vcC5zdG9wKCk7XG4gICAgdGhpcy5hbmltYXRpb25Mb29wID0gbnVsbDtcbiAgICB0aGlzLl9sYXN0UG9pbnRlckRvd25JbmZvID0gbnVsbDtcbiAgICAoX3RoaXMkbGF5ZXJNYW5hZ2VyID0gdGhpcy5sYXllck1hbmFnZXIpID09PSBudWxsIHx8IF90aGlzJGxheWVyTWFuYWdlciA9PT0gdm9pZCAwID8gdm9pZCAwIDogX3RoaXMkbGF5ZXJNYW5hZ2VyLmZpbmFsaXplKCk7XG4gICAgdGhpcy5sYXllck1hbmFnZXIgPSBudWxsO1xuICAgIChfdGhpcyR2aWV3TWFuYWdlciA9IHRoaXMudmlld01hbmFnZXIpID09PSBudWxsIHx8IF90aGlzJHZpZXdNYW5hZ2VyID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfdGhpcyR2aWV3TWFuYWdlci5maW5hbGl6ZSgpO1xuICAgIHRoaXMudmlld01hbmFnZXIgPSBudWxsO1xuICAgIChfdGhpcyRlZmZlY3RNYW5hZ2VyID0gdGhpcy5lZmZlY3RNYW5hZ2VyKSA9PT0gbnVsbCB8fCBfdGhpcyRlZmZlY3RNYW5hZ2VyID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfdGhpcyRlZmZlY3RNYW5hZ2VyLmZpbmFsaXplKCk7XG4gICAgdGhpcy5lZmZlY3RNYW5hZ2VyID0gbnVsbDtcbiAgICAoX3RoaXMkZGVja1JlbmRlcmVyID0gdGhpcy5kZWNrUmVuZGVyZXIpID09PSBudWxsIHx8IF90aGlzJGRlY2tSZW5kZXJlciA9PT0gdm9pZCAwID8gdm9pZCAwIDogX3RoaXMkZGVja1JlbmRlcmVyLmZpbmFsaXplKCk7XG4gICAgdGhpcy5kZWNrUmVuZGVyZXIgPSBudWxsO1xuICAgIChfdGhpcyRkZWNrUGlja2VyID0gdGhpcy5kZWNrUGlja2VyKSA9PT0gbnVsbCB8fCBfdGhpcyRkZWNrUGlja2VyID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfdGhpcyRkZWNrUGlja2VyLmZpbmFsaXplKCk7XG4gICAgdGhpcy5kZWNrUGlja2VyID0gbnVsbDtcbiAgICAoX3RoaXMkZXZlbnRNYW5hZ2VyID0gdGhpcy5ldmVudE1hbmFnZXIpID09PSBudWxsIHx8IF90aGlzJGV2ZW50TWFuYWdlciA9PT0gdm9pZCAwID8gdm9pZCAwIDogX3RoaXMkZXZlbnRNYW5hZ2VyLmRlc3Ryb3koKTtcbiAgICB0aGlzLmV2ZW50TWFuYWdlciA9IG51bGw7XG4gICAgKF90aGlzJHRvb2x0aXAgPSB0aGlzLnRvb2x0aXApID09PSBudWxsIHx8IF90aGlzJHRvb2x0aXAgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF90aGlzJHRvb2x0aXAucmVtb3ZlKCk7XG4gICAgdGhpcy50b29sdGlwID0gbnVsbDtcblxuICAgIGlmICghdGhpcy5wcm9wcy5jYW52YXMgJiYgIXRoaXMucHJvcHMuZ2wgJiYgdGhpcy5jYW52YXMpIHtcbiAgICAgIHZhciBfdGhpcyRjYW52YXMkcGFyZW50RWw7XG5cbiAgICAgIChfdGhpcyRjYW52YXMkcGFyZW50RWwgPSB0aGlzLmNhbnZhcy5wYXJlbnRFbGVtZW50KSA9PT0gbnVsbCB8fCBfdGhpcyRjYW52YXMkcGFyZW50RWwgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF90aGlzJGNhbnZhcyRwYXJlbnRFbC5yZW1vdmVDaGlsZCh0aGlzLmNhbnZhcyk7XG4gICAgICB0aGlzLmNhbnZhcyA9IG51bGw7XG4gICAgfVxuICB9XG5cbiAgc2V0UHJvcHMocHJvcHMpIHtcbiAgICB0aGlzLnN0YXRzLmdldCgnc2V0UHJvcHMgVGltZScpLnRpbWVTdGFydCgpO1xuXG4gICAgaWYgKCdvbkxheWVySG92ZXInIGluIHByb3BzKSB7XG4gICAgICBsb2cucmVtb3ZlZCgnb25MYXllckhvdmVyJywgJ29uSG92ZXInKSgpO1xuICAgIH1cblxuICAgIGlmICgnb25MYXllckNsaWNrJyBpbiBwcm9wcykge1xuICAgICAgbG9nLnJlbW92ZWQoJ29uTGF5ZXJDbGljaycsICdvbkNsaWNrJykoKTtcbiAgICB9XG5cbiAgICBpZiAocHJvcHMuaW5pdGlhbFZpZXdTdGF0ZSAmJiAhZGVlcEVxdWFsKHRoaXMucHJvcHMuaW5pdGlhbFZpZXdTdGF0ZSwgcHJvcHMuaW5pdGlhbFZpZXdTdGF0ZSwgMykpIHtcbiAgICAgIHRoaXMudmlld1N0YXRlID0gcHJvcHMuaW5pdGlhbFZpZXdTdGF0ZTtcbiAgICB9XG5cbiAgICBPYmplY3QuYXNzaWduKHRoaXMucHJvcHMsIHByb3BzKTtcblxuICAgIHRoaXMuX3NldENhbnZhc1NpemUodGhpcy5wcm9wcyk7XG5cbiAgICBjb25zdCByZXNvbHZlZFByb3BzID0gT2JqZWN0LmNyZWF0ZSh0aGlzLnByb3BzKTtcbiAgICBPYmplY3QuYXNzaWduKHJlc29sdmVkUHJvcHMsIHtcbiAgICAgIHZpZXdzOiB0aGlzLl9nZXRWaWV3cygpLFxuICAgICAgd2lkdGg6IHRoaXMud2lkdGgsXG4gICAgICBoZWlnaHQ6IHRoaXMuaGVpZ2h0LFxuICAgICAgdmlld1N0YXRlOiB0aGlzLl9nZXRWaWV3U3RhdGUoKVxuICAgIH0pO1xuICAgIHRoaXMuYW5pbWF0aW9uTG9vcC5zZXRQcm9wcyhyZXNvbHZlZFByb3BzKTtcblxuICAgIGlmICh0aGlzLmxheWVyTWFuYWdlcikge1xuICAgICAgdGhpcy52aWV3TWFuYWdlci5zZXRQcm9wcyhyZXNvbHZlZFByb3BzKTtcbiAgICAgIHRoaXMubGF5ZXJNYW5hZ2VyLmFjdGl2YXRlVmlld3BvcnQodGhpcy5nZXRWaWV3cG9ydHMoKVswXSk7XG4gICAgICB0aGlzLmxheWVyTWFuYWdlci5zZXRQcm9wcyhyZXNvbHZlZFByb3BzKTtcbiAgICAgIHRoaXMuZWZmZWN0TWFuYWdlci5zZXRQcm9wcyhyZXNvbHZlZFByb3BzKTtcbiAgICAgIHRoaXMuZGVja1JlbmRlcmVyLnNldFByb3BzKHJlc29sdmVkUHJvcHMpO1xuICAgICAgdGhpcy5kZWNrUGlja2VyLnNldFByb3BzKHJlc29sdmVkUHJvcHMpO1xuICAgIH1cblxuICAgIHRoaXMuc3RhdHMuZ2V0KCdzZXRQcm9wcyBUaW1lJykudGltZUVuZCgpO1xuICB9XG5cbiAgbmVlZHNSZWRyYXcob3B0cyA9IHtcbiAgICBjbGVhclJlZHJhd0ZsYWdzOiBmYWxzZVxuICB9KSB7XG4gICAgaWYgKCF0aGlzLmxheWVyTWFuYWdlcikge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGlmICh0aGlzLnByb3BzLl9hbmltYXRlKSB7XG4gICAgICByZXR1cm4gJ0RlY2suX2FuaW1hdGUnO1xuICAgIH1cblxuICAgIGxldCByZWRyYXcgPSB0aGlzLl9uZWVkc1JlZHJhdztcblxuICAgIGlmIChvcHRzLmNsZWFyUmVkcmF3RmxhZ3MpIHtcbiAgICAgIHRoaXMuX25lZWRzUmVkcmF3ID0gZmFsc2U7XG4gICAgfVxuXG4gICAgY29uc3Qgdmlld01hbmFnZXJOZWVkc1JlZHJhdyA9IHRoaXMudmlld01hbmFnZXIubmVlZHNSZWRyYXcob3B0cyk7XG4gICAgY29uc3QgbGF5ZXJNYW5hZ2VyTmVlZHNSZWRyYXcgPSB0aGlzLmxheWVyTWFuYWdlci5uZWVkc1JlZHJhdyhvcHRzKTtcbiAgICBjb25zdCBlZmZlY3RNYW5hZ2VyTmVlZHNSZWRyYXcgPSB0aGlzLmVmZmVjdE1hbmFnZXIubmVlZHNSZWRyYXcob3B0cyk7XG4gICAgY29uc3QgZGVja1JlbmRlcmVyTmVlZHNSZWRyYXcgPSB0aGlzLmRlY2tSZW5kZXJlci5uZWVkc1JlZHJhdyhvcHRzKTtcbiAgICByZWRyYXcgPSByZWRyYXcgfHwgdmlld01hbmFnZXJOZWVkc1JlZHJhdyB8fCBsYXllck1hbmFnZXJOZWVkc1JlZHJhdyB8fCBlZmZlY3RNYW5hZ2VyTmVlZHNSZWRyYXcgfHwgZGVja1JlbmRlcmVyTmVlZHNSZWRyYXc7XG4gICAgcmV0dXJuIHJlZHJhdztcbiAgfVxuXG4gIHJlZHJhdyhyZWFzb24pIHtcbiAgICBpZiAoIXRoaXMubGF5ZXJNYW5hZ2VyKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgbGV0IHJlZHJhd1JlYXNvbiA9IHRoaXMubmVlZHNSZWRyYXcoe1xuICAgICAgY2xlYXJSZWRyYXdGbGFnczogdHJ1ZVxuICAgIH0pO1xuICAgIHJlZHJhd1JlYXNvbiA9IHJlYXNvbiB8fCByZWRyYXdSZWFzb247XG5cbiAgICBpZiAoIXJlZHJhd1JlYXNvbikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMuc3RhdHMuZ2V0KCdSZWRyYXcgQ291bnQnKS5pbmNyZW1lbnRDb3VudCgpO1xuXG4gICAgaWYgKHRoaXMucHJvcHMuX2N1c3RvbVJlbmRlcikge1xuICAgICAgdGhpcy5wcm9wcy5fY3VzdG9tUmVuZGVyKHJlZHJhd1JlYXNvbik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX2RyYXdMYXllcnMocmVkcmF3UmVhc29uKTtcbiAgICB9XG4gIH1cblxuICBnZXQgaXNJbml0aWFsaXplZCgpIHtcbiAgICByZXR1cm4gdGhpcy52aWV3TWFuYWdlciAhPT0gbnVsbDtcbiAgfVxuXG4gIGdldFZpZXdzKCkge1xuICAgIGFzc2VydCh0aGlzLnZpZXdNYW5hZ2VyKTtcbiAgICByZXR1cm4gdGhpcy52aWV3TWFuYWdlci52aWV3cztcbiAgfVxuXG4gIGdldFZpZXdwb3J0cyhyZWN0KSB7XG4gICAgYXNzZXJ0KHRoaXMudmlld01hbmFnZXIpO1xuICAgIHJldHVybiB0aGlzLnZpZXdNYW5hZ2VyLmdldFZpZXdwb3J0cyhyZWN0KTtcbiAgfVxuXG4gIHBpY2tPYmplY3Qob3B0cykge1xuICAgIGNvbnN0IGluZm9zID0gdGhpcy5fcGljaygncGlja09iamVjdCcsICdwaWNrT2JqZWN0IFRpbWUnLCBvcHRzKS5yZXN1bHQ7XG5cbiAgICByZXR1cm4gaW5mb3MubGVuZ3RoID8gaW5mb3NbMF0gOiBudWxsO1xuICB9XG5cbiAgcGlja011bHRpcGxlT2JqZWN0cyhvcHRzKSB7XG4gICAgb3B0cy5kZXB0aCA9IG9wdHMuZGVwdGggfHwgMTA7XG4gICAgcmV0dXJuIHRoaXMuX3BpY2soJ3BpY2tPYmplY3QnLCAncGlja011bHRpcGxlT2JqZWN0cyBUaW1lJywgb3B0cykucmVzdWx0O1xuICB9XG5cbiAgcGlja09iamVjdHMob3B0cykge1xuICAgIHJldHVybiB0aGlzLl9waWNrKCdwaWNrT2JqZWN0cycsICdwaWNrT2JqZWN0cyBUaW1lJywgb3B0cyk7XG4gIH1cblxuICBfYWRkUmVzb3VyY2VzKHJlc291cmNlcywgZm9yY2VVcGRhdGUgPSBmYWxzZSkge1xuICAgIGZvciAoY29uc3QgaWQgaW4gcmVzb3VyY2VzKSB7XG4gICAgICB0aGlzLmxheWVyTWFuYWdlci5yZXNvdXJjZU1hbmFnZXIuYWRkKHtcbiAgICAgICAgcmVzb3VyY2VJZDogaWQsXG4gICAgICAgIGRhdGE6IHJlc291cmNlc1tpZF0sXG4gICAgICAgIGZvcmNlVXBkYXRlXG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICBfcmVtb3ZlUmVzb3VyY2VzKHJlc291cmNlSWRzKSB7XG4gICAgZm9yIChjb25zdCBpZCBvZiByZXNvdXJjZUlkcykge1xuICAgICAgdGhpcy5sYXllck1hbmFnZXIucmVzb3VyY2VNYW5hZ2VyLnJlbW92ZShpZCk7XG4gICAgfVxuICB9XG5cbiAgX2FkZERlZmF1bHRFZmZlY3QoZWZmZWN0KSB7XG4gICAgdGhpcy5lZmZlY3RNYW5hZ2VyLmFkZERlZmF1bHRFZmZlY3QoZWZmZWN0KTtcbiAgfVxuXG4gIF9waWNrKG1ldGhvZCwgc3RhdEtleSwgb3B0cykge1xuICAgIGFzc2VydCh0aGlzLmRlY2tQaWNrZXIpO1xuICAgIGNvbnN0IHtcbiAgICAgIHN0YXRzXG4gICAgfSA9IHRoaXM7XG4gICAgc3RhdHMuZ2V0KCdQaWNrIENvdW50JykuaW5jcmVtZW50Q291bnQoKTtcbiAgICBzdGF0cy5nZXQoc3RhdEtleSkudGltZVN0YXJ0KCk7XG4gICAgY29uc3QgaW5mb3MgPSB0aGlzLmRlY2tQaWNrZXJbbWV0aG9kXSh7XG4gICAgICBsYXllcnM6IHRoaXMubGF5ZXJNYW5hZ2VyLmdldExheWVycyhvcHRzKSxcbiAgICAgIHZpZXdzOiB0aGlzLnZpZXdNYW5hZ2VyLmdldFZpZXdzKCksXG4gICAgICB2aWV3cG9ydHM6IHRoaXMuZ2V0Vmlld3BvcnRzKG9wdHMpLFxuICAgICAgb25WaWV3cG9ydEFjdGl2ZTogdGhpcy5sYXllck1hbmFnZXIuYWN0aXZhdGVWaWV3cG9ydCxcbiAgICAgIGVmZmVjdHM6IHRoaXMuZWZmZWN0TWFuYWdlci5nZXRFZmZlY3RzKCksXG4gICAgICAuLi5vcHRzXG4gICAgfSk7XG4gICAgc3RhdHMuZ2V0KHN0YXRLZXkpLnRpbWVFbmQoKTtcbiAgICByZXR1cm4gaW5mb3M7XG4gIH1cblxuICBfY3JlYXRlQ2FudmFzKHByb3BzKSB7XG4gICAgbGV0IGNhbnZhcyA9IHByb3BzLmNhbnZhcztcblxuICAgIGlmICh0eXBlb2YgY2FudmFzID09PSAnc3RyaW5nJykge1xuICAgICAgY2FudmFzID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoY2FudmFzKTtcbiAgICAgIGFzc2VydChjYW52YXMpO1xuICAgIH1cblxuICAgIGlmICghY2FudmFzKSB7XG4gICAgICBjYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKTtcbiAgICAgIGNhbnZhcy5pZCA9IHByb3BzLmlkIHx8ICdkZWNrZ2wtb3ZlcmxheSc7XG4gICAgICBjb25zdCBwYXJlbnQgPSBwcm9wcy5wYXJlbnQgfHwgZG9jdW1lbnQuYm9keTtcbiAgICAgIHBhcmVudC5hcHBlbmRDaGlsZChjYW52YXMpO1xuICAgIH1cblxuICAgIE9iamVjdC5hc3NpZ24oY2FudmFzLnN0eWxlLCBwcm9wcy5zdHlsZSk7XG4gICAgcmV0dXJuIGNhbnZhcztcbiAgfVxuXG4gIF9zZXRDYW52YXNTaXplKHByb3BzKSB7XG4gICAgaWYgKCF0aGlzLmNhbnZhcykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IHtcbiAgICAgIHdpZHRoLFxuICAgICAgaGVpZ2h0XG4gICAgfSA9IHByb3BzO1xuXG4gICAgaWYgKHdpZHRoIHx8IHdpZHRoID09PSAwKSB7XG4gICAgICBjb25zdCBjc3NXaWR0aCA9IE51bWJlci5pc0Zpbml0ZSh3aWR0aCkgPyBcIlwiLmNvbmNhdCh3aWR0aCwgXCJweFwiKSA6IHdpZHRoO1xuICAgICAgdGhpcy5jYW52YXMuc3R5bGUud2lkdGggPSBjc3NXaWR0aDtcbiAgICB9XG5cbiAgICBpZiAoaGVpZ2h0IHx8IGhlaWdodCA9PT0gMCkge1xuICAgICAgdmFyIF9wcm9wcyRzdHlsZTtcblxuICAgICAgY29uc3QgY3NzSGVpZ2h0ID0gTnVtYmVyLmlzRmluaXRlKGhlaWdodCkgPyBcIlwiLmNvbmNhdChoZWlnaHQsIFwicHhcIikgOiBoZWlnaHQ7XG4gICAgICB0aGlzLmNhbnZhcy5zdHlsZS5wb3NpdGlvbiA9ICgoX3Byb3BzJHN0eWxlID0gcHJvcHMuc3R5bGUpID09PSBudWxsIHx8IF9wcm9wcyRzdHlsZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX3Byb3BzJHN0eWxlLnBvc2l0aW9uKSB8fCAnYWJzb2x1dGUnO1xuICAgICAgdGhpcy5jYW52YXMuc3R5bGUuaGVpZ2h0ID0gY3NzSGVpZ2h0O1xuICAgIH1cbiAgfVxuXG4gIF91cGRhdGVDYW52YXNTaXplKCkge1xuICAgIGNvbnN0IHtcbiAgICAgIGNhbnZhc1xuICAgIH0gPSB0aGlzO1xuXG4gICAgaWYgKCFjYW52YXMpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCBuZXdXaWR0aCA9IGNhbnZhcy5jbGllbnRXaWR0aCB8fCBjYW52YXMud2lkdGg7XG4gICAgY29uc3QgbmV3SGVpZ2h0ID0gY2FudmFzLmNsaWVudEhlaWdodCB8fCBjYW52YXMuaGVpZ2h0O1xuXG4gICAgaWYgKG5ld1dpZHRoICE9PSB0aGlzLndpZHRoIHx8IG5ld0hlaWdodCAhPT0gdGhpcy5oZWlnaHQpIHtcbiAgICAgIHZhciBfdGhpcyR2aWV3TWFuYWdlcjI7XG5cbiAgICAgIHRoaXMud2lkdGggPSBuZXdXaWR0aDtcbiAgICAgIHRoaXMuaGVpZ2h0ID0gbmV3SGVpZ2h0O1xuICAgICAgKF90aGlzJHZpZXdNYW5hZ2VyMiA9IHRoaXMudmlld01hbmFnZXIpID09PSBudWxsIHx8IF90aGlzJHZpZXdNYW5hZ2VyMiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX3RoaXMkdmlld01hbmFnZXIyLnNldFByb3BzKHtcbiAgICAgICAgd2lkdGg6IG5ld1dpZHRoLFxuICAgICAgICBoZWlnaHQ6IG5ld0hlaWdodFxuICAgICAgfSk7XG4gICAgICB0aGlzLnByb3BzLm9uUmVzaXplKHtcbiAgICAgICAgd2lkdGg6IG5ld1dpZHRoLFxuICAgICAgICBoZWlnaHQ6IG5ld0hlaWdodFxuICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgX2NyZWF0ZUFuaW1hdGlvbkxvb3AocHJvcHMpIHtcbiAgICBjb25zdCB7XG4gICAgICB3aWR0aCxcbiAgICAgIGhlaWdodCxcbiAgICAgIGdsLFxuICAgICAgZ2xPcHRpb25zLFxuICAgICAgZGVidWcsXG4gICAgICBvbkVycm9yLFxuICAgICAgb25CZWZvcmVSZW5kZXIsXG4gICAgICBvbkFmdGVyUmVuZGVyLFxuICAgICAgdXNlRGV2aWNlUGl4ZWxzXG4gICAgfSA9IHByb3BzO1xuICAgIHJldHVybiBuZXcgQW5pbWF0aW9uTG9vcCh7XG4gICAgICB3aWR0aCxcbiAgICAgIGhlaWdodCxcbiAgICAgIHVzZURldmljZVBpeGVscyxcbiAgICAgIGF1dG9SZXNpemVWaWV3cG9ydDogZmFsc2UsXG4gICAgICBnbCxcbiAgICAgIG9uQ3JlYXRlQ29udGV4dDogb3B0cyA9PiBjcmVhdGVHTENvbnRleHQoeyAuLi5nbE9wdGlvbnMsXG4gICAgICAgIC4uLm9wdHMsXG4gICAgICAgIGNhbnZhczogdGhpcy5jYW52YXMsXG4gICAgICAgIGRlYnVnLFxuICAgICAgICBvbkNvbnRleHRMb3N0OiAoKSA9PiB0aGlzLl9vbkNvbnRleHRMb3N0KClcbiAgICAgIH0pLFxuICAgICAgb25Jbml0aWFsaXplOiBjb250ZXh0ID0+IHRoaXMuX3NldEdMQ29udGV4dChjb250ZXh0LmdsKSxcbiAgICAgIG9uUmVuZGVyOiB0aGlzLl9vblJlbmRlckZyYW1lLmJpbmQodGhpcyksXG4gICAgICBvbkJlZm9yZVJlbmRlcixcbiAgICAgIG9uQWZ0ZXJSZW5kZXIsXG4gICAgICBvbkVycm9yXG4gICAgfSk7XG4gIH1cblxuICBfZ2V0Vmlld1N0YXRlKCkge1xuICAgIHJldHVybiB0aGlzLnByb3BzLnZpZXdTdGF0ZSB8fCB0aGlzLnZpZXdTdGF0ZTtcbiAgfVxuXG4gIF9nZXRWaWV3cygpIHtcbiAgICBsZXQgdmlld3MgPSB0aGlzLnByb3BzLnZpZXdzIHx8IFtuZXcgTWFwVmlldyh7XG4gICAgICBpZDogJ2RlZmF1bHQtdmlldydcbiAgICB9KV07XG4gICAgdmlld3MgPSBBcnJheS5pc0FycmF5KHZpZXdzKSA/IHZpZXdzIDogW3ZpZXdzXTtcblxuICAgIGlmICh2aWV3cy5sZW5ndGggJiYgdGhpcy5wcm9wcy5jb250cm9sbGVyKSB7XG4gICAgICB2aWV3c1swXS5wcm9wcy5jb250cm9sbGVyID0gdGhpcy5wcm9wcy5jb250cm9sbGVyO1xuICAgIH1cblxuICAgIHJldHVybiB2aWV3cztcbiAgfVxuXG4gIF9vbkNvbnRleHRMb3N0KCkge1xuICAgIGNvbnN0IHtcbiAgICAgIG9uRXJyb3JcbiAgICB9ID0gdGhpcy5wcm9wcztcblxuICAgIGlmICh0aGlzLmFuaW1hdGlvbkxvb3AgJiYgb25FcnJvcikge1xuICAgICAgb25FcnJvcihuZXcgRXJyb3IoJ1dlYkdMIGNvbnRleHQgaXMgbG9zdCcpKTtcbiAgICB9XG4gIH1cblxuICBfcGlja0FuZENhbGxiYWNrKCkge1xuICAgIGNvbnN0IHtcbiAgICAgIF9waWNrUmVxdWVzdFxuICAgIH0gPSB0aGlzO1xuXG4gICAgaWYgKF9waWNrUmVxdWVzdC5ldmVudCkge1xuICAgICAgY29uc3Qge1xuICAgICAgICByZXN1bHQsXG4gICAgICAgIGVtcHR5SW5mb1xuICAgICAgfSA9IHRoaXMuX3BpY2soJ3BpY2tPYmplY3QnLCAncGlja09iamVjdCBUaW1lJywgX3BpY2tSZXF1ZXN0KTtcblxuICAgICAgdGhpcy5jdXJzb3JTdGF0ZS5pc0hvdmVyaW5nID0gcmVzdWx0Lmxlbmd0aCA+IDA7XG4gICAgICBsZXQgcGlja2VkSW5mbyA9IGVtcHR5SW5mbztcbiAgICAgIGxldCBoYW5kbGVkID0gZmFsc2U7XG5cbiAgICAgIGZvciAoY29uc3QgaW5mbyBvZiByZXN1bHQpIHtcbiAgICAgICAgdmFyIF9pbmZvJGxheWVyO1xuXG4gICAgICAgIHBpY2tlZEluZm8gPSBpbmZvO1xuICAgICAgICBoYW5kbGVkID0gKChfaW5mbyRsYXllciA9IGluZm8ubGF5ZXIpID09PSBudWxsIHx8IF9pbmZvJGxheWVyID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfaW5mbyRsYXllci5vbkhvdmVyKGluZm8sIF9waWNrUmVxdWVzdC5ldmVudCkpIHx8IGhhbmRsZWQ7XG4gICAgICB9XG5cbiAgICAgIGlmICghaGFuZGxlZCAmJiB0aGlzLnByb3BzLm9uSG92ZXIpIHtcbiAgICAgICAgdGhpcy5wcm9wcy5vbkhvdmVyKHBpY2tlZEluZm8sIF9waWNrUmVxdWVzdC5ldmVudCk7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLnByb3BzLmdldFRvb2x0aXAgJiYgdGhpcy50b29sdGlwKSB7XG4gICAgICAgIGNvbnN0IGRpc3BsYXlJbmZvID0gdGhpcy5wcm9wcy5nZXRUb29sdGlwKHBpY2tlZEluZm8pO1xuICAgICAgICB0aGlzLnRvb2x0aXAuc2V0VG9vbHRpcChkaXNwbGF5SW5mbywgcGlja2VkSW5mby54LCBwaWNrZWRJbmZvLnkpO1xuICAgICAgfVxuXG4gICAgICBfcGlja1JlcXVlc3QuZXZlbnQgPSBudWxsO1xuICAgIH1cbiAgfVxuXG4gIF91cGRhdGVDdXJzb3IoKSB7XG4gICAgY29uc3QgY29udGFpbmVyID0gdGhpcy5wcm9wcy5wYXJlbnQgfHwgdGhpcy5jYW52YXM7XG5cbiAgICBpZiAoY29udGFpbmVyKSB7XG4gICAgICBjb250YWluZXIuc3R5bGUuY3Vyc29yID0gdGhpcy5wcm9wcy5nZXRDdXJzb3IodGhpcy5jdXJzb3JTdGF0ZSk7XG4gICAgfVxuICB9XG5cbiAgX3NldEdMQ29udGV4dChnbCkge1xuICAgIGlmICh0aGlzLmxheWVyTWFuYWdlcikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmICghdGhpcy5jYW52YXMpIHtcbiAgICAgIHRoaXMuY2FudmFzID0gZ2wuY2FudmFzO1xuICAgICAgaW5zdHJ1bWVudEdMQ29udGV4dChnbCwge1xuICAgICAgICBlbmFibGU6IHRydWUsXG4gICAgICAgIGNvcHlTdGF0ZTogdHJ1ZVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgdGhpcy50b29sdGlwID0gbmV3IFRvb2x0aXAodGhpcy5jYW52YXMpO1xuICAgIHNldFBhcmFtZXRlcnMoZ2wsIHtcbiAgICAgIGJsZW5kOiB0cnVlLFxuICAgICAgYmxlbmRGdW5jOiBbNzcwLCA3NzEsIDEsIDc3MV0sXG4gICAgICBwb2x5Z29uT2Zmc2V0RmlsbDogdHJ1ZSxcbiAgICAgIGRlcHRoVGVzdDogdHJ1ZSxcbiAgICAgIGRlcHRoRnVuYzogNTE1XG4gICAgfSk7XG4gICAgdGhpcy5wcm9wcy5vbldlYkdMSW5pdGlhbGl6ZWQoZ2wpO1xuICAgIGNvbnN0IHRpbWVsaW5lID0gbmV3IFRpbWVsaW5lKCk7XG4gICAgdGltZWxpbmUucGxheSgpO1xuICAgIHRoaXMuYW5pbWF0aW9uTG9vcC5hdHRhY2hUaW1lbGluZSh0aW1lbGluZSk7XG4gICAgdGhpcy5ldmVudE1hbmFnZXIgPSBuZXcgRXZlbnRNYW5hZ2VyKHRoaXMucHJvcHMucGFyZW50IHx8IGdsLmNhbnZhcywge1xuICAgICAgdG91Y2hBY3Rpb246IHRoaXMucHJvcHMudG91Y2hBY3Rpb24sXG4gICAgICByZWNvZ25pemVyT3B0aW9uczogdGhpcy5wcm9wcy5ldmVudFJlY29nbml6ZXJPcHRpb25zLFxuICAgICAgZXZlbnRzOiB7XG4gICAgICAgIHBvaW50ZXJkb3duOiB0aGlzLl9vblBvaW50ZXJEb3duLFxuICAgICAgICBwb2ludGVybW92ZTogdGhpcy5fb25Qb2ludGVyTW92ZSxcbiAgICAgICAgcG9pbnRlcmxlYXZlOiB0aGlzLl9vblBvaW50ZXJNb3ZlXG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBmb3IgKGNvbnN0IGV2ZW50VHlwZSBpbiBFVkVOVFMpIHtcbiAgICAgIHRoaXMuZXZlbnRNYW5hZ2VyLm9uKGV2ZW50VHlwZSwgdGhpcy5fb25FdmVudCk7XG4gICAgfVxuXG4gICAgdGhpcy52aWV3TWFuYWdlciA9IG5ldyBWaWV3TWFuYWdlcih7XG4gICAgICB0aW1lbGluZSxcbiAgICAgIGV2ZW50TWFuYWdlcjogdGhpcy5ldmVudE1hbmFnZXIsXG4gICAgICBvblZpZXdTdGF0ZUNoYW5nZTogdGhpcy5fb25WaWV3U3RhdGVDaGFuZ2UuYmluZCh0aGlzKSxcbiAgICAgIG9uSW50ZXJhY3Rpb25TdGF0ZUNoYW5nZTogdGhpcy5fb25JbnRlcmFjdGlvblN0YXRlQ2hhbmdlLmJpbmQodGhpcyksXG4gICAgICB2aWV3czogdGhpcy5fZ2V0Vmlld3MoKSxcbiAgICAgIHZpZXdTdGF0ZTogdGhpcy5fZ2V0Vmlld1N0YXRlKCksXG4gICAgICB3aWR0aDogdGhpcy53aWR0aCxcbiAgICAgIGhlaWdodDogdGhpcy5oZWlnaHRcbiAgICB9KTtcbiAgICBjb25zdCB2aWV3cG9ydCA9IHRoaXMudmlld01hbmFnZXIuZ2V0Vmlld3BvcnRzKClbMF07XG4gICAgdGhpcy5sYXllck1hbmFnZXIgPSBuZXcgTGF5ZXJNYW5hZ2VyKGdsLCB7XG4gICAgICBkZWNrOiB0aGlzLFxuICAgICAgc3RhdHM6IHRoaXMuc3RhdHMsXG4gICAgICB2aWV3cG9ydCxcbiAgICAgIHRpbWVsaW5lXG4gICAgfSk7XG4gICAgdGhpcy5lZmZlY3RNYW5hZ2VyID0gbmV3IEVmZmVjdE1hbmFnZXIoKTtcbiAgICB0aGlzLmRlY2tSZW5kZXJlciA9IG5ldyBEZWNrUmVuZGVyZXIoZ2wpO1xuICAgIHRoaXMuZGVja1BpY2tlciA9IG5ldyBEZWNrUGlja2VyKGdsKTtcbiAgICB0aGlzLnNldFByb3BzKHRoaXMucHJvcHMpO1xuXG4gICAgdGhpcy5fdXBkYXRlQ2FudmFzU2l6ZSgpO1xuXG4gICAgdGhpcy5wcm9wcy5vbkxvYWQoKTtcbiAgfVxuXG4gIF9kcmF3TGF5ZXJzKHJlZHJhd1JlYXNvbiwgcmVuZGVyT3B0aW9ucykge1xuICAgIGNvbnN0IHtcbiAgICAgIGdsXG4gICAgfSA9IHRoaXMubGF5ZXJNYW5hZ2VyLmNvbnRleHQ7XG4gICAgc2V0UGFyYW1ldGVycyhnbCwgdGhpcy5wcm9wcy5wYXJhbWV0ZXJzKTtcbiAgICB0aGlzLnByb3BzLm9uQmVmb3JlUmVuZGVyKHtcbiAgICAgIGdsXG4gICAgfSk7XG4gICAgdGhpcy5kZWNrUmVuZGVyZXIucmVuZGVyTGF5ZXJzKHtcbiAgICAgIHRhcmdldDogdGhpcy5wcm9wcy5fZnJhbWVidWZmZXIsXG4gICAgICBsYXllcnM6IHRoaXMubGF5ZXJNYW5hZ2VyLmdldExheWVycygpLFxuICAgICAgdmlld3BvcnRzOiB0aGlzLnZpZXdNYW5hZ2VyLmdldFZpZXdwb3J0cygpLFxuICAgICAgb25WaWV3cG9ydEFjdGl2ZTogdGhpcy5sYXllck1hbmFnZXIuYWN0aXZhdGVWaWV3cG9ydCxcbiAgICAgIHZpZXdzOiB0aGlzLnZpZXdNYW5hZ2VyLmdldFZpZXdzKCksXG4gICAgICBwYXNzOiAnc2NyZWVuJyxcbiAgICAgIGVmZmVjdHM6IHRoaXMuZWZmZWN0TWFuYWdlci5nZXRFZmZlY3RzKCksXG4gICAgICAuLi5yZW5kZXJPcHRpb25zXG4gICAgfSk7XG4gICAgdGhpcy5wcm9wcy5vbkFmdGVyUmVuZGVyKHtcbiAgICAgIGdsXG4gICAgfSk7XG4gIH1cblxuICBfb25SZW5kZXJGcmFtZShhbmltYXRpb25Qcm9wcykge1xuICAgIHRoaXMuX2dldEZyYW1lU3RhdHMoKTtcblxuICAgIGlmICh0aGlzLl9tZXRyaWNzQ291bnRlcisrICUgNjAgPT09IDApIHtcbiAgICAgIHRoaXMuX2dldE1ldHJpY3MoKTtcblxuICAgICAgdGhpcy5zdGF0cy5yZXNldCgpO1xuICAgICAgbG9nLnRhYmxlKDQsIHRoaXMubWV0cmljcykoKTtcblxuICAgICAgaWYgKHRoaXMucHJvcHMuX29uTWV0cmljcykge1xuICAgICAgICB0aGlzLnByb3BzLl9vbk1ldHJpY3ModGhpcy5tZXRyaWNzKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLl91cGRhdGVDYW52YXNTaXplKCk7XG5cbiAgICB0aGlzLl91cGRhdGVDdXJzb3IoKTtcblxuICAgIGlmICh0aGlzLnRvb2x0aXAuaXNWaXNpYmxlICYmIHRoaXMudmlld01hbmFnZXIubmVlZHNSZWRyYXcoKSkge1xuICAgICAgdGhpcy50b29sdGlwLnNldFRvb2x0aXAobnVsbCk7XG4gICAgfVxuXG4gICAgdGhpcy5sYXllck1hbmFnZXIudXBkYXRlTGF5ZXJzKCk7XG5cbiAgICB0aGlzLl9waWNrQW5kQ2FsbGJhY2soKTtcblxuICAgIHRoaXMucmVkcmF3KCk7XG5cbiAgICBpZiAodGhpcy52aWV3TWFuYWdlcikge1xuICAgICAgdGhpcy52aWV3TWFuYWdlci51cGRhdGVWaWV3U3RhdGVzKCk7XG4gICAgfVxuICB9XG5cbiAgX29uVmlld1N0YXRlQ2hhbmdlKHBhcmFtcykge1xuICAgIGNvbnN0IHZpZXdTdGF0ZSA9IHRoaXMucHJvcHMub25WaWV3U3RhdGVDaGFuZ2UocGFyYW1zKSB8fCBwYXJhbXMudmlld1N0YXRlO1xuXG4gICAgaWYgKHRoaXMudmlld1N0YXRlKSB7XG4gICAgICB0aGlzLnZpZXdTdGF0ZSA9IHsgLi4udGhpcy52aWV3U3RhdGUsXG4gICAgICAgIFtwYXJhbXMudmlld0lkXTogdmlld1N0YXRlXG4gICAgICB9O1xuXG4gICAgICBpZiAoIXRoaXMucHJvcHMudmlld1N0YXRlKSB7XG4gICAgICAgIGlmICh0aGlzLnZpZXdNYW5hZ2VyKSB7XG4gICAgICAgICAgdGhpcy52aWV3TWFuYWdlci5zZXRQcm9wcyh7XG4gICAgICAgICAgICB2aWV3U3RhdGU6IHRoaXMudmlld1N0YXRlXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBfb25JbnRlcmFjdGlvblN0YXRlQ2hhbmdlKGludGVyYWN0aW9uU3RhdGUpIHtcbiAgICB0aGlzLmN1cnNvclN0YXRlLmlzRHJhZ2dpbmcgPSBpbnRlcmFjdGlvblN0YXRlLmlzRHJhZ2dpbmcgfHwgZmFsc2U7XG4gICAgdGhpcy5wcm9wcy5vbkludGVyYWN0aW9uU3RhdGVDaGFuZ2UoaW50ZXJhY3Rpb25TdGF0ZSk7XG4gIH1cblxuICBfZ2V0RnJhbWVTdGF0cygpIHtcbiAgICBjb25zdCB7XG4gICAgICBzdGF0c1xuICAgIH0gPSB0aGlzO1xuICAgIHN0YXRzLmdldCgnZnJhbWVSYXRlJykudGltZUVuZCgpO1xuICAgIHN0YXRzLmdldCgnZnJhbWVSYXRlJykudGltZVN0YXJ0KCk7XG4gICAgY29uc3QgYW5pbWF0aW9uTG9vcFN0YXRzID0gdGhpcy5hbmltYXRpb25Mb29wLnN0YXRzO1xuICAgIHN0YXRzLmdldCgnR1BVIFRpbWUnKS5hZGRUaW1lKGFuaW1hdGlvbkxvb3BTdGF0cy5nZXQoJ0dQVSBUaW1lJykubGFzdFRpbWluZyk7XG4gICAgc3RhdHMuZ2V0KCdDUFUgVGltZScpLmFkZFRpbWUoYW5pbWF0aW9uTG9vcFN0YXRzLmdldCgnQ1BVIFRpbWUnKS5sYXN0VGltaW5nKTtcbiAgfVxuXG4gIF9nZXRNZXRyaWNzKCkge1xuICAgIGNvbnN0IHtcbiAgICAgIG1ldHJpY3MsXG4gICAgICBzdGF0c1xuICAgIH0gPSB0aGlzO1xuICAgIG1ldHJpY3MuZnBzID0gc3RhdHMuZ2V0KCdmcmFtZVJhdGUnKS5nZXRIeigpO1xuICAgIG1ldHJpY3Muc2V0UHJvcHNUaW1lID0gc3RhdHMuZ2V0KCdzZXRQcm9wcyBUaW1lJykudGltZTtcbiAgICBtZXRyaWNzLnVwZGF0ZUF0dHJpYnV0ZXNUaW1lID0gc3RhdHMuZ2V0KCdVcGRhdGUgQXR0cmlidXRlcycpLnRpbWU7XG4gICAgbWV0cmljcy5mcmFtZXNSZWRyYXduID0gc3RhdHMuZ2V0KCdSZWRyYXcgQ291bnQnKS5jb3VudDtcbiAgICBtZXRyaWNzLnBpY2tUaW1lID0gc3RhdHMuZ2V0KCdwaWNrT2JqZWN0IFRpbWUnKS50aW1lICsgc3RhdHMuZ2V0KCdwaWNrTXVsdGlwbGVPYmplY3RzIFRpbWUnKS50aW1lICsgc3RhdHMuZ2V0KCdwaWNrT2JqZWN0cyBUaW1lJykudGltZTtcbiAgICBtZXRyaWNzLnBpY2tDb3VudCA9IHN0YXRzLmdldCgnUGljayBDb3VudCcpLmNvdW50O1xuICAgIG1ldHJpY3MuZ3B1VGltZSA9IHN0YXRzLmdldCgnR1BVIFRpbWUnKS50aW1lO1xuICAgIG1ldHJpY3MuY3B1VGltZSA9IHN0YXRzLmdldCgnQ1BVIFRpbWUnKS50aW1lO1xuICAgIG1ldHJpY3MuZ3B1VGltZVBlckZyYW1lID0gc3RhdHMuZ2V0KCdHUFUgVGltZScpLmdldEF2ZXJhZ2VUaW1lKCk7XG4gICAgbWV0cmljcy5jcHVUaW1lUGVyRnJhbWUgPSBzdGF0cy5nZXQoJ0NQVSBUaW1lJykuZ2V0QXZlcmFnZVRpbWUoKTtcbiAgICBjb25zdCBtZW1vcnlTdGF0cyA9IGx1bWFTdGF0cy5nZXQoJ01lbW9yeSBVc2FnZScpO1xuICAgIG1ldHJpY3MuYnVmZmVyTWVtb3J5ID0gbWVtb3J5U3RhdHMuZ2V0KCdCdWZmZXIgTWVtb3J5JykuY291bnQ7XG4gICAgbWV0cmljcy50ZXh0dXJlTWVtb3J5ID0gbWVtb3J5U3RhdHMuZ2V0KCdUZXh0dXJlIE1lbW9yeScpLmNvdW50O1xuICAgIG1ldHJpY3MucmVuZGVyYnVmZmVyTWVtb3J5ID0gbWVtb3J5U3RhdHMuZ2V0KCdSZW5kZXJidWZmZXIgTWVtb3J5JykuY291bnQ7XG4gICAgbWV0cmljcy5ncHVNZW1vcnkgPSBtZW1vcnlTdGF0cy5nZXQoJ0dQVSBNZW1vcnknKS5jb3VudDtcbiAgfVxuXG59XG5cbl9kZWZpbmVQcm9wZXJ0eShEZWNrLCBcImRlZmF1bHRQcm9wc1wiLCBkZWZhdWx0UHJvcHMpO1xuXG5fZGVmaW5lUHJvcGVydHkoRGVjaywgXCJWRVJTSU9OXCIsIFZFUlNJT04pO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGVjay5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///68315\n')},52447:function(__unused_webpack_module,__webpack_exports__,__webpack_require__){eval("\n// EXPORTS\n__webpack_require__.d(__webpack_exports__, {\n  \"Z\": function() { return /* binding */ Layer; }\n});\n\n// EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/esm/defineProperty.js\nvar defineProperty = __webpack_require__(82482);\n// EXTERNAL MODULE: ./node_modules/@deck.gl/core/dist/esm/lib/constants.js\nvar constants = __webpack_require__(24088);\n// EXTERNAL MODULE: ./node_modules/@deck.gl/core/dist/esm/lib/attribute/attribute.js + 3 modules\nvar attribute_attribute = __webpack_require__(13906);\n// EXTERNAL MODULE: ./node_modules/@deck.gl/core/dist/esm/utils/log.js\nvar log = __webpack_require__(80744);\n// EXTERNAL MODULE: ./node_modules/@deck.gl/core/dist/esm/utils/memoize.js\nvar memoize = __webpack_require__(88177);\n// EXTERNAL MODULE: ./node_modules/@deck.gl/core/dist/esm/utils/math-utils.js\nvar math_utils = __webpack_require__(75126);\n// EXTERNAL MODULE: ./node_modules/@deck.gl/core/dist/esm/debug/index.js\nvar debug = __webpack_require__(63803);\n// EXTERNAL MODULE: ./node_modules/@luma.gl/engine/dist/esm/transform/transform.js + 5 modules\nvar transform = __webpack_require__(19718);\n// EXTERNAL MODULE: ./node_modules/@deck.gl/core/dist/esm/transitions/gpu-interpolation-transition.js\nvar gpu_interpolation_transition = __webpack_require__(20198);\n// EXTERNAL MODULE: ./node_modules/@deck.gl/core/dist/esm/transitions/gpu-spring-transition.js\nvar gpu_spring_transition = __webpack_require__(7563);\n;// CONCATENATED MODULE: ./node_modules/@deck.gl/core/dist/esm/lib/attribute/attribute-transition-manager.js\n\n\n\n\n\nconst TRANSITION_TYPES = {\n  interpolation: gpu_interpolation_transition/* default */.Z,\n  spring: gpu_spring_transition/* default */.Z\n};\nclass AttributeTransitionManager {\n  constructor(gl, {\n    id,\n    timeline\n  }) {\n    (0,defineProperty/* default */.Z)(this, \"id\", void 0);\n\n    (0,defineProperty/* default */.Z)(this, \"isSupported\", void 0);\n\n    (0,defineProperty/* default */.Z)(this, \"gl\", void 0);\n\n    (0,defineProperty/* default */.Z)(this, \"timeline\", void 0);\n\n    (0,defineProperty/* default */.Z)(this, \"transitions\", void 0);\n\n    (0,defineProperty/* default */.Z)(this, \"needsRedraw\", void 0);\n\n    (0,defineProperty/* default */.Z)(this, \"numInstances\", void 0);\n\n    this.id = id;\n    this.gl = gl;\n    this.timeline = timeline;\n    this.transitions = {};\n    this.needsRedraw = false;\n    this.numInstances = 1;\n    this.isSupported = transform/* default.isSupported */.Z.isSupported(gl);\n  }\n\n  finalize() {\n    for (const attributeName in this.transitions) {\n      this._removeTransition(attributeName);\n    }\n  }\n\n  update({\n    attributes,\n    transitions,\n    numInstances\n  }) {\n    this.numInstances = numInstances || 1;\n\n    for (const attributeName in attributes) {\n      const attribute = attributes[attributeName];\n      const settings = attribute.getTransitionSetting(transitions);\n      if (!settings) continue;\n\n      this._updateAttribute(attributeName, attribute, settings);\n    }\n\n    for (const attributeName in this.transitions) {\n      const attribute = attributes[attributeName];\n\n      if (!attribute || !attribute.getTransitionSetting(transitions)) {\n        this._removeTransition(attributeName);\n      }\n    }\n  }\n\n  hasAttribute(attributeName) {\n    const transition = this.transitions[attributeName];\n    return transition && transition.inProgress;\n  }\n\n  getAttributes() {\n    const animatedAttributes = {};\n\n    for (const attributeName in this.transitions) {\n      const transition = this.transitions[attributeName];\n\n      if (transition.inProgress) {\n        animatedAttributes[attributeName] = transition.attributeInTransition;\n      }\n    }\n\n    return animatedAttributes;\n  }\n\n  run() {\n    if (!this.isSupported || this.numInstances === 0) {\n      return false;\n    }\n\n    for (const attributeName in this.transitions) {\n      const updated = this.transitions[attributeName].update();\n\n      if (updated) {\n        this.needsRedraw = true;\n      }\n    }\n\n    const needsRedraw = this.needsRedraw;\n    this.needsRedraw = false;\n    return needsRedraw;\n  }\n\n  _removeTransition(attributeName) {\n    this.transitions[attributeName].cancel();\n    delete this.transitions[attributeName];\n  }\n\n  _updateAttribute(attributeName, attribute, settings) {\n    const transition = this.transitions[attributeName];\n    let isNew = !transition || transition.type !== settings.type;\n\n    if (isNew) {\n      if (!this.isSupported) {\n        log/* default.warn */.Z.warn(\"WebGL2 not supported by this browser. Transition for \".concat(attributeName, \" is disabled.\"))();\n        return;\n      }\n\n      if (transition) {\n        this._removeTransition(attributeName);\n      }\n\n      const TransitionType = TRANSITION_TYPES[settings.type];\n\n      if (TransitionType) {\n        this.transitions[attributeName] = new TransitionType({\n          attribute,\n          timeline: this.timeline,\n          gl: this.gl\n        });\n      } else {\n        log/* default.error */.Z.error(\"unsupported transition type '\".concat(settings.type, \"'\"))();\n        isNew = false;\n      }\n    }\n\n    if (isNew || attribute.needsRedraw()) {\n      this.needsRedraw = true;\n      this.transitions[attributeName].start(settings, this.numInstances);\n    }\n  }\n\n}\n//# sourceMappingURL=attribute-transition-manager.js.map\n;// CONCATENATED MODULE: ./node_modules/@deck.gl/core/dist/esm/lib/attribute/attribute-manager.js\n\n\n\n\n\n\n\nconst TRACE_INVALIDATE = 'attributeManager.invalidate';\nconst TRACE_UPDATE_START = 'attributeManager.updateStart';\nconst TRACE_UPDATE_END = 'attributeManager.updateEnd';\nconst TRACE_ATTRIBUTE_UPDATE_START = 'attribute.updateStart';\nconst TRACE_ATTRIBUTE_ALLOCATE = 'attribute.allocate';\nconst TRACE_ATTRIBUTE_UPDATE_END = 'attribute.updateEnd';\nclass AttributeManager {\n  constructor(gl, {\n    id = 'attribute-manager',\n    stats,\n    timeline\n  } = {}) {\n    (0,defineProperty/* default */.Z)(this, \"id\", void 0);\n\n    (0,defineProperty/* default */.Z)(this, \"gl\", void 0);\n\n    (0,defineProperty/* default */.Z)(this, \"attributes\", void 0);\n\n    (0,defineProperty/* default */.Z)(this, \"updateTriggers\", void 0);\n\n    (0,defineProperty/* default */.Z)(this, \"needsRedraw\", void 0);\n\n    (0,defineProperty/* default */.Z)(this, \"userData\", void 0);\n\n    (0,defineProperty/* default */.Z)(this, \"stats\", void 0);\n\n    (0,defineProperty/* default */.Z)(this, \"attributeTransitionManager\", void 0);\n\n    (0,defineProperty/* default */.Z)(this, \"mergeBoundsMemoized\", (0,memoize/* default */.Z)(math_utils/* mergeBounds */.cc));\n\n    this.id = id;\n    this.gl = gl;\n    this.attributes = {};\n    this.updateTriggers = {};\n    this.needsRedraw = true;\n    this.userData = {};\n    this.stats = stats;\n    this.attributeTransitionManager = new AttributeTransitionManager(gl, {\n      id: \"\".concat(id, \"-transitions\"),\n      timeline\n    });\n    Object.seal(this);\n  }\n\n  finalize() {\n    for (const attributeName in this.attributes) {\n      this.attributes[attributeName].delete();\n    }\n\n    this.attributeTransitionManager.finalize();\n  }\n\n  getNeedsRedraw(opts = {\n    clearRedrawFlags: false\n  }) {\n    const redraw = this.needsRedraw;\n    this.needsRedraw = this.needsRedraw && !opts.clearRedrawFlags;\n    return redraw && this.id;\n  }\n\n  setNeedsRedraw() {\n    this.needsRedraw = true;\n  }\n\n  add(attributes) {\n    this._add(attributes);\n  }\n\n  addInstanced(attributes) {\n    this._add(attributes, {\n      instanced: 1\n    });\n  }\n\n  remove(attributeNameArray) {\n    for (const name of attributeNameArray) {\n      if (this.attributes[name] !== undefined) {\n        this.attributes[name].delete();\n        delete this.attributes[name];\n      }\n    }\n  }\n\n  invalidate(triggerName, dataRange) {\n    const invalidatedAttributes = this._invalidateTrigger(triggerName, dataRange);\n\n    (0,debug/* default */.Z)(TRACE_INVALIDATE, this, triggerName, invalidatedAttributes);\n  }\n\n  invalidateAll(dataRange) {\n    for (const attributeName in this.attributes) {\n      this.attributes[attributeName].setNeedsUpdate(attributeName, dataRange);\n    }\n\n    (0,debug/* default */.Z)(TRACE_INVALIDATE, this, 'all');\n  }\n\n  update({\n    data,\n    numInstances,\n    startIndices = null,\n    transitions,\n    props = {},\n    buffers = {},\n    context = {}\n  }) {\n    let updated = false;\n    (0,debug/* default */.Z)(TRACE_UPDATE_START, this);\n\n    if (this.stats) {\n      this.stats.get('Update Attributes').timeStart();\n    }\n\n    for (const attributeName in this.attributes) {\n      const attribute = this.attributes[attributeName];\n      const accessorName = attribute.settings.accessor;\n      attribute.startIndices = startIndices;\n      attribute.numInstances = numInstances;\n\n      if (props[attributeName]) {\n        log/* default.removed */.Z.removed(\"props.\".concat(attributeName), \"data.attributes.\".concat(attributeName))();\n      }\n\n      if (attribute.setExternalBuffer(buffers[attributeName])) {} else if (attribute.setBinaryValue(typeof accessorName === 'string' ? buffers[accessorName] : undefined, data.startIndices)) {} else if (typeof accessorName === 'string' && !buffers[accessorName] && attribute.setConstantValue(props[accessorName])) {} else if (attribute.needsUpdate()) {\n        updated = true;\n\n        this._updateAttribute({\n          attribute,\n          numInstances,\n          data,\n          props,\n          context\n        });\n      }\n\n      this.needsRedraw = this.needsRedraw || attribute.needsRedraw();\n    }\n\n    if (updated) {\n      (0,debug/* default */.Z)(TRACE_UPDATE_END, this, numInstances);\n    }\n\n    if (this.stats) {\n      this.stats.get('Update Attributes').timeEnd();\n    }\n\n    this.attributeTransitionManager.update({\n      attributes: this.attributes,\n      numInstances,\n      transitions\n    });\n  }\n\n  updateTransition() {\n    const {\n      attributeTransitionManager\n    } = this;\n    const transitionUpdated = attributeTransitionManager.run();\n    this.needsRedraw = this.needsRedraw || transitionUpdated;\n    return transitionUpdated;\n  }\n\n  getAttributes() {\n    return this.attributes;\n  }\n\n  getBounds(attributeNames) {\n    const bounds = attributeNames.map(attributeName => {\n      var _this$attributes$attr;\n\n      return (_this$attributes$attr = this.attributes[attributeName]) === null || _this$attributes$attr === void 0 ? void 0 : _this$attributes$attr.getBounds();\n    });\n    return this.mergeBoundsMemoized(bounds);\n  }\n\n  getChangedAttributes(opts = {\n    clearChangedFlags: false\n  }) {\n    const {\n      attributes,\n      attributeTransitionManager\n    } = this;\n    const changedAttributes = { ...attributeTransitionManager.getAttributes()\n    };\n\n    for (const attributeName in attributes) {\n      const attribute = attributes[attributeName];\n\n      if (attribute.needsRedraw(opts) && !attributeTransitionManager.hasAttribute(attributeName)) {\n        changedAttributes[attributeName] = attribute;\n      }\n    }\n\n    return changedAttributes;\n  }\n\n  getShaderAttributes(attributes, excludeAttributes = {}) {\n    if (!attributes) {\n      attributes = this.getAttributes();\n    }\n\n    const shaderAttributes = {};\n\n    for (const attributeName in attributes) {\n      if (!excludeAttributes[attributeName]) {\n        Object.assign(shaderAttributes, attributes[attributeName].getShaderAttributes());\n      }\n    }\n\n    return shaderAttributes;\n  }\n\n  _add(attributes, extraProps = {}) {\n    for (const attributeName in attributes) {\n      const attribute = attributes[attributeName];\n      this.attributes[attributeName] = this._createAttribute(attributeName, attribute, extraProps);\n    }\n\n    this._mapUpdateTriggersToAttributes();\n  }\n\n  _createAttribute(name, attribute, extraProps) {\n    const props = { ...attribute,\n      id: name,\n      size: attribute.isIndexed && 1 || attribute.size || 1,\n      divisor: extraProps.instanced ? 1 : attribute.divisor || 0\n    };\n    return new attribute_attribute/* default */.Z(this.gl, props);\n  }\n\n  _mapUpdateTriggersToAttributes() {\n    const triggers = {};\n\n    for (const attributeName in this.attributes) {\n      const attribute = this.attributes[attributeName];\n      attribute.getUpdateTriggers().forEach(triggerName => {\n        if (!triggers[triggerName]) {\n          triggers[triggerName] = [];\n        }\n\n        triggers[triggerName].push(attributeName);\n      });\n    }\n\n    this.updateTriggers = triggers;\n  }\n\n  _invalidateTrigger(triggerName, dataRange) {\n    const {\n      attributes,\n      updateTriggers\n    } = this;\n    const invalidatedAttributes = updateTriggers[triggerName];\n\n    if (invalidatedAttributes) {\n      invalidatedAttributes.forEach(name => {\n        const attribute = attributes[name];\n\n        if (attribute) {\n          attribute.setNeedsUpdate(attribute.id, dataRange);\n        }\n      });\n    }\n\n    return invalidatedAttributes;\n  }\n\n  _updateAttribute(opts) {\n    const {\n      attribute,\n      numInstances\n    } = opts;\n    (0,debug/* default */.Z)(TRACE_ATTRIBUTE_UPDATE_START, attribute);\n\n    if (attribute.constant) {\n      attribute.setConstantValue(attribute.value);\n      return;\n    }\n\n    if (attribute.allocate(numInstances)) {\n      (0,debug/* default */.Z)(TRACE_ATTRIBUTE_ALLOCATE, attribute, numInstances);\n    }\n\n    const updated = attribute.updateBuffer(opts);\n\n    if (updated) {\n      this.needsRedraw = true;\n      (0,debug/* default */.Z)(TRACE_ATTRIBUTE_UPDATE_END, attribute, numInstances);\n    }\n  }\n\n}\n//# sourceMappingURL=attribute-manager.js.map\n// EXTERNAL MODULE: ./node_modules/@deck.gl/core/dist/esm/lib/uniform-transition-manager.js + 2 modules\nvar uniform_transition_manager = __webpack_require__(52413);\n// EXTERNAL MODULE: ./node_modules/@deck.gl/core/dist/esm/lifecycle/props.js\nvar props = __webpack_require__(71761);\n// EXTERNAL MODULE: ./node_modules/@deck.gl/core/dist/esm/lifecycle/constants.js\nvar lifecycle_constants = __webpack_require__(85409);\n// EXTERNAL MODULE: ./node_modules/@deck.gl/core/dist/esm/utils/count.js\nvar count = __webpack_require__(75015);\n// EXTERNAL MODULE: ./node_modules/@luma.gl/gltools/dist/esm/index.js + 13 modules\nvar esm = __webpack_require__(1418);\n// EXTERNAL MODULE: ./node_modules/@deck.gl/core/dist/esm/utils/assert.js\nvar assert = __webpack_require__(75304);\n// EXTERNAL MODULE: ./node_modules/@deck.gl/core/dist/esm/utils/shader.js\nvar shader = __webpack_require__(27870);\n// EXTERNAL MODULE: ./node_modules/@deck.gl/core/dist/esm/shaderlib/project/project-functions.js\nvar project_functions = __webpack_require__(18547);\n// EXTERNAL MODULE: ./node_modules/@deck.gl/core/dist/esm/utils/typed-array-manager.js\nvar typed_array_manager = __webpack_require__(36610);\n// EXTERNAL MODULE: ./node_modules/@deck.gl/core/dist/esm/lifecycle/component.js + 3 modules\nvar component = __webpack_require__(85089);\n// EXTERNAL MODULE: ./node_modules/@deck.gl/core/dist/esm/lifecycle/component-state.js\nvar component_state = __webpack_require__(88018);\n;// CONCATENATED MODULE: ./node_modules/@deck.gl/core/dist/esm/lib/layer-state.js\n\n\nclass LayerState extends component_state/* default */.Z {\n  constructor({\n    attributeManager,\n    layer\n  }) {\n    super(layer);\n\n    (0,defineProperty/* default */.Z)(this, \"attributeManager\", void 0);\n\n    (0,defineProperty/* default */.Z)(this, \"needsRedraw\", void 0);\n\n    (0,defineProperty/* default */.Z)(this, \"needsUpdate\", void 0);\n\n    (0,defineProperty/* default */.Z)(this, \"subLayers\", void 0);\n\n    (0,defineProperty/* default */.Z)(this, \"usesPickingColorCache\", void 0);\n\n    (0,defineProperty/* default */.Z)(this, \"hasPickingBuffer\", void 0);\n\n    (0,defineProperty/* default */.Z)(this, \"changeFlags\", void 0);\n\n    (0,defineProperty/* default */.Z)(this, \"viewport\", void 0);\n\n    (0,defineProperty/* default */.Z)(this, \"uniformTransitions\", void 0);\n\n    (0,defineProperty/* default */.Z)(this, \"propsInTransition\", void 0);\n\n    this.attributeManager = attributeManager;\n    this.needsRedraw = true;\n    this.needsUpdate = true;\n    this.subLayers = null;\n    this.usesPickingColorCache = false;\n  }\n\n  get layer() {\n    return this.component;\n  }\n\n  _fetch(propName, url) {\n    const layer = this.layer;\n    const fetch = layer === null || layer === void 0 ? void 0 : layer.props.fetch;\n\n    if (fetch) {\n      return fetch(url, {\n        propName,\n        layer\n      });\n    }\n\n    return super._fetch(propName, url);\n  }\n\n  _onResolve(propName, value) {\n    const layer = this.layer;\n\n    if (layer) {\n      const onDataLoad = layer.props.onDataLoad;\n\n      if (propName === 'data' && onDataLoad) {\n        onDataLoad(value, {\n          propName,\n          layer\n        });\n      }\n    }\n  }\n\n  _onError(propName, error) {\n    const layer = this.layer;\n\n    if (layer) {\n      layer.raiseError(error, \"loading \".concat(propName, \" of \").concat(this.layer));\n    }\n  }\n\n}\n//# sourceMappingURL=layer-state.js.map\n// EXTERNAL MODULE: ./node_modules/@math.gl/web-mercator/dist/esm/index.js + 8 modules\nvar dist_esm = __webpack_require__(78866);\n// EXTERNAL MODULE: ./node_modules/@loaders.gl/core/dist/esm/lib/api/load.js + 24 modules\nvar load = __webpack_require__(44534);\n;// CONCATENATED MODULE: ./node_modules/@deck.gl/core/dist/esm/lib/layer.js\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nconst TRACE_CHANGE_FLAG = 'layer.changeFlag';\nconst TRACE_INITIALIZE = 'layer.initialize';\nconst TRACE_UPDATE = 'layer.update';\nconst TRACE_FINALIZE = 'layer.finalize';\nconst TRACE_MATCHED = 'layer.matched';\nconst MAX_PICKING_COLOR_CACHE_SIZE = 2 ** 24 - 1;\nconst EMPTY_ARRAY = Object.freeze([]);\nconst areViewportsEqual = (0,memoize/* default */.Z)(({\n  oldViewport,\n  viewport\n}) => {\n  return oldViewport.equals(viewport);\n});\nlet pickingColorCache = new Uint8ClampedArray(0);\nconst defaultProps = {\n  data: {\n    type: 'data',\n    value: EMPTY_ARRAY,\n    async: true\n  },\n  dataComparator: {\n    type: 'function',\n    value: null,\n    optional: true\n  },\n  _dataDiff: {\n    type: 'function',\n    value: data => data && data.__diff,\n    optional: true\n  },\n  dataTransform: {\n    type: 'function',\n    value: null,\n    optional: true\n  },\n  onDataLoad: {\n    type: 'function',\n    value: null,\n    optional: true\n  },\n  onError: {\n    type: 'function',\n    value: null,\n    optional: true\n  },\n  fetch: {\n    type: 'function',\n    value: (url, {\n      propName,\n      layer,\n      loaders,\n      loadOptions,\n      signal\n    }) => {\n      const {\n        resourceManager\n      } = layer.context;\n      loadOptions = loadOptions || layer.getLoadOptions();\n      loaders = loaders || layer.props.loaders;\n\n      if (signal) {\n        var _loadOptions;\n\n        loadOptions = { ...loadOptions,\n          fetch: { ...((_loadOptions = loadOptions) === null || _loadOptions === void 0 ? void 0 : _loadOptions.fetch),\n            signal\n          }\n        };\n      }\n\n      let inResourceManager = resourceManager.contains(url);\n\n      if (!inResourceManager && !loadOptions) {\n        resourceManager.add({\n          resourceId: url,\n          data: (0,load/* load */.z)(url, loaders),\n          persistent: false\n        });\n        inResourceManager = true;\n      }\n\n      if (inResourceManager) {\n        return resourceManager.subscribe({\n          resourceId: url,\n          onChange: data => {\n            var _layer$internalState;\n\n            return (_layer$internalState = layer.internalState) === null || _layer$internalState === void 0 ? void 0 : _layer$internalState.reloadAsyncProp(propName, data);\n          },\n          consumerId: layer.id,\n          requestId: propName\n        });\n      }\n\n      return (0,load/* load */.z)(url, loaders, loadOptions);\n    }\n  },\n  updateTriggers: {},\n  visible: true,\n  pickable: false,\n  opacity: {\n    type: 'number',\n    min: 0,\n    max: 1,\n    value: 1\n  },\n  operation: 'draw',\n  onHover: {\n    type: 'function',\n    value: null,\n    optional: true\n  },\n  onClick: {\n    type: 'function',\n    value: null,\n    optional: true\n  },\n  onDragStart: {\n    type: 'function',\n    value: null,\n    optional: true\n  },\n  onDrag: {\n    type: 'function',\n    value: null,\n    optional: true\n  },\n  onDragEnd: {\n    type: 'function',\n    value: null,\n    optional: true\n  },\n  coordinateSystem: constants/* COORDINATE_SYSTEM.DEFAULT */.Df.DEFAULT,\n  coordinateOrigin: {\n    type: 'array',\n    value: [0, 0, 0],\n    compare: true\n  },\n  modelMatrix: {\n    type: 'array',\n    value: null,\n    compare: true,\n    optional: true\n  },\n  wrapLongitude: false,\n  positionFormat: 'XYZ',\n  colorFormat: 'RGBA',\n  parameters: {\n    type: 'object',\n    value: {},\n    optional: true,\n    compare: 2\n  },\n  loadOptions: {\n    type: 'object',\n    value: null,\n    optional: true,\n    ignore: true\n  },\n  transitions: null,\n  extensions: [],\n  loaders: {\n    type: 'array',\n    value: [],\n    optional: true,\n    ignore: true\n  },\n  getPolygonOffset: {\n    type: 'function',\n    value: ({\n      layerIndex\n    }) => [0, -layerIndex * 100]\n  },\n  highlightedObjectIndex: null,\n  autoHighlight: false,\n  highlightColor: {\n    type: 'accessor',\n    value: [0, 0, 128, 128]\n  }\n};\nclass Layer extends component/* default */.Z {\n  constructor(...args) {\n    super(...args);\n\n    (0,defineProperty/* default */.Z)(this, \"internalState\", null);\n\n    (0,defineProperty/* default */.Z)(this, \"lifecycle\", lifecycle_constants/* LIFECYCLE.NO_STATE */.dt.NO_STATE);\n\n    (0,defineProperty/* default */.Z)(this, \"context\", void 0);\n\n    (0,defineProperty/* default */.Z)(this, \"state\", void 0);\n\n    (0,defineProperty/* default */.Z)(this, \"parent\", null);\n  }\n\n  get root() {\n    let layer = this;\n\n    while (layer.parent) {\n      layer = layer.parent;\n    }\n\n    return layer;\n  }\n\n  toString() {\n    const className = this.constructor.layerName || this.constructor.name;\n    return \"\".concat(className, \"({id: '\").concat(this.props.id, \"'})\");\n  }\n\n  project(xyz) {\n    (0,assert/* default */.Z)(this.internalState);\n    const viewport = this.internalState.viewport || this.context.viewport;\n    const worldPosition = (0,project_functions/* getWorldPosition */.T)(xyz, {\n      viewport,\n      modelMatrix: this.props.modelMatrix,\n      coordinateOrigin: this.props.coordinateOrigin,\n      coordinateSystem: this.props.coordinateSystem\n    });\n    const [x, y, z] = (0,dist_esm/* worldToPixels */.aW)(worldPosition, viewport.pixelProjectionMatrix);\n    return xyz.length === 2 ? [x, y] : [x, y, z];\n  }\n\n  unproject(xy) {\n    (0,assert/* default */.Z)(this.internalState);\n    const viewport = this.internalState.viewport || this.context.viewport;\n    return viewport.unproject(xy);\n  }\n\n  projectPosition(xyz, params) {\n    (0,assert/* default */.Z)(this.internalState);\n    const viewport = this.internalState.viewport || this.context.viewport;\n    return (0,project_functions/* projectPosition */.D)(xyz, {\n      viewport,\n      modelMatrix: this.props.modelMatrix,\n      coordinateOrigin: this.props.coordinateOrigin,\n      coordinateSystem: this.props.coordinateSystem,\n      ...params\n    });\n  }\n\n  get isComposite() {\n    return false;\n  }\n\n  setState(partialState) {\n    this.setChangeFlags({\n      stateChanged: true\n    });\n    Object.assign(this.state, partialState);\n    this.setNeedsRedraw();\n  }\n\n  setNeedsRedraw() {\n    if (this.internalState) {\n      this.internalState.needsRedraw = true;\n    }\n  }\n\n  setNeedsUpdate() {\n    if (this.internalState) {\n      this.context.layerManager.setNeedsUpdate(String(this));\n      this.internalState.needsUpdate = true;\n    }\n  }\n\n  get isLoaded() {\n    return this.internalState ? !this.internalState.isAsyncPropLoading() : false;\n  }\n\n  get wrapLongitude() {\n    return this.props.wrapLongitude;\n  }\n\n  isPickable() {\n    return this.props.pickable && this.props.visible;\n  }\n\n  getModels() {\n    return this.state && (this.state.models || this.state.model && [this.state.model]) || [];\n  }\n\n  setModuleParameters(moduleParameters) {\n    for (const model of this.getModels()) {\n      model.updateModuleSettings(moduleParameters);\n    }\n  }\n\n  getAttributeManager() {\n    return this.internalState && this.internalState.attributeManager;\n  }\n\n  getCurrentLayer() {\n    return this.internalState && this.internalState.layer;\n  }\n\n  getLoadOptions() {\n    return this.props.loadOptions;\n  }\n\n  use64bitPositions() {\n    const {\n      coordinateSystem\n    } = this.props;\n    return coordinateSystem === constants/* COORDINATE_SYSTEM.DEFAULT */.Df.DEFAULT || coordinateSystem === constants/* COORDINATE_SYSTEM.LNGLAT */.Df.LNGLAT || coordinateSystem === constants/* COORDINATE_SYSTEM.CARTESIAN */.Df.CARTESIAN;\n  }\n\n  onHover(info, pickingEvent) {\n    if (this.props.onHover) {\n      return this.props.onHover(info, pickingEvent) || false;\n    }\n\n    return false;\n  }\n\n  onClick(info, pickingEvent) {\n    if (this.props.onClick) {\n      return this.props.onClick(info, pickingEvent) || false;\n    }\n\n    return false;\n  }\n\n  nullPickingColor() {\n    return [0, 0, 0];\n  }\n\n  encodePickingColor(i, target = []) {\n    target[0] = i + 1 & 255;\n    target[1] = i + 1 >> 8 & 255;\n    target[2] = i + 1 >> 8 >> 8 & 255;\n    return target;\n  }\n\n  decodePickingColor(color) {\n    (0,assert/* default */.Z)(color instanceof Uint8Array);\n    const [i1, i2, i3] = color;\n    const index = i1 + i2 * 256 + i3 * 65536 - 1;\n    return index;\n  }\n\n  getNumInstances() {\n    if (Number.isFinite(this.props.numInstances)) {\n      return this.props.numInstances;\n    }\n\n    if (this.state && this.state.numInstances !== undefined) {\n      return this.state.numInstances;\n    }\n\n    return (0,count/* count */.Q)(this.props.data);\n  }\n\n  getStartIndices() {\n    if (this.props.startIndices) {\n      return this.props.startIndices;\n    }\n\n    if (this.state && this.state.startIndices) {\n      return this.state.startIndices;\n    }\n\n    return null;\n  }\n\n  getBounds() {\n    var _this$getAttributeMan;\n\n    return (_this$getAttributeMan = this.getAttributeManager()) === null || _this$getAttributeMan === void 0 ? void 0 : _this$getAttributeMan.getBounds(['positions', 'instancePositions']);\n  }\n\n  getShaders(shaders) {\n    for (const extension of this.props.extensions) {\n      shaders = (0,shader/* mergeShaders */.l)(shaders, extension.getShaders.call(this, extension));\n    }\n\n    return shaders;\n  }\n\n  shouldUpdateState(params) {\n    return params.changeFlags.propsOrDataChanged;\n  }\n\n  updateState(params) {\n    const attributeManager = this.getAttributeManager();\n    const {\n      dataChanged\n    } = params.changeFlags;\n\n    if (dataChanged && attributeManager) {\n      if (Array.isArray(dataChanged)) {\n        for (const dataRange of dataChanged) {\n          attributeManager.invalidateAll(dataRange);\n        }\n      } else {\n        attributeManager.invalidateAll();\n      }\n    }\n\n    if (attributeManager) {\n      const {\n        props\n      } = params;\n      const hasPickingBuffer = this.internalState.hasPickingBuffer;\n      const needsPickingBuffer = Number.isInteger(props.highlightedObjectIndex) || props.pickable || props.extensions.some(extension => extension.getNeedsPickingBuffer.call(this, extension));\n\n      if (hasPickingBuffer !== needsPickingBuffer) {\n        this.internalState.hasPickingBuffer = needsPickingBuffer;\n        const {\n          pickingColors,\n          instancePickingColors\n        } = attributeManager.attributes;\n        const pickingColorsAttribute = pickingColors || instancePickingColors;\n\n        if (pickingColorsAttribute) {\n          if (needsPickingBuffer && pickingColorsAttribute.constant) {\n            pickingColorsAttribute.constant = false;\n            attributeManager.invalidate(pickingColorsAttribute.id);\n          }\n\n          if (!pickingColorsAttribute.value && !needsPickingBuffer) {\n            pickingColorsAttribute.constant = true;\n            pickingColorsAttribute.value = [0, 0, 0];\n          }\n        }\n      }\n    }\n  }\n\n  finalizeState(context) {\n    for (const model of this.getModels()) {\n      model.delete();\n    }\n\n    const attributeManager = this.getAttributeManager();\n\n    if (attributeManager) {\n      attributeManager.finalize();\n    }\n\n    if (this.context) {\n      this.context.resourceManager.unsubscribe({\n        consumerId: this.id\n      });\n    }\n\n    if (this.internalState) {\n      this.internalState.uniformTransitions.clear();\n      this.internalState.finalize();\n    }\n  }\n\n  draw(opts) {\n    for (const model of this.getModels()) {\n      model.draw(opts);\n    }\n  }\n\n  getPickingInfo({\n    info,\n    mode,\n    sourceLayer\n  }) {\n    const {\n      index\n    } = info;\n\n    if (index >= 0) {\n      if (Array.isArray(this.props.data)) {\n        info.object = this.props.data[index];\n      }\n    }\n\n    return info;\n  }\n\n  raiseError(error, message) {\n    var _this$props$onError, _this$props;\n\n    if (message) {\n      error.message = \"\".concat(message, \": \").concat(error.message);\n    }\n\n    if (!((_this$props$onError = (_this$props = this.props).onError) !== null && _this$props$onError !== void 0 && _this$props$onError.call(_this$props, error))) {\n      var _this$context, _this$context$onError;\n\n      (_this$context = this.context) === null || _this$context === void 0 ? void 0 : (_this$context$onError = _this$context.onError) === null || _this$context$onError === void 0 ? void 0 : _this$context$onError.call(_this$context, error, this);\n    }\n  }\n\n  getNeedsRedraw(opts = {\n    clearRedrawFlags: false\n  }) {\n    return this._getNeedsRedraw(opts);\n  }\n\n  needsUpdate() {\n    if (!this.internalState) {\n      return false;\n    }\n\n    return this.internalState.needsUpdate || this.hasUniformTransition() || this.shouldUpdateState(this._getUpdateParams());\n  }\n\n  hasUniformTransition() {\n    var _this$internalState;\n\n    return ((_this$internalState = this.internalState) === null || _this$internalState === void 0 ? void 0 : _this$internalState.uniformTransitions.active) || false;\n  }\n\n  activateViewport(viewport) {\n    if (!this.internalState) {\n      return;\n    }\n\n    const oldViewport = this.internalState.viewport;\n    this.internalState.viewport = viewport;\n\n    if (!oldViewport || !areViewportsEqual({\n      oldViewport,\n      viewport\n    })) {\n      this.setChangeFlags({\n        viewportChanged: true\n      });\n\n      if (this.isComposite) {\n        if (this.needsUpdate()) {\n          this.setNeedsUpdate();\n        }\n      } else {\n        this._update();\n      }\n    }\n  }\n\n  invalidateAttribute(name = 'all') {\n    const attributeManager = this.getAttributeManager();\n\n    if (!attributeManager) {\n      return;\n    }\n\n    if (name === 'all') {\n      attributeManager.invalidateAll();\n    } else {\n      attributeManager.invalidate(name);\n    }\n  }\n\n  updateAttributes(changedAttributes) {\n    for (const model of this.getModels()) {\n      this._setModelAttributes(model, changedAttributes);\n    }\n  }\n\n  _updateAttributes() {\n    const attributeManager = this.getAttributeManager();\n\n    if (!attributeManager) {\n      return;\n    }\n\n    const props = this.props;\n    const numInstances = this.getNumInstances();\n    const startIndices = this.getStartIndices();\n    attributeManager.update({\n      data: props.data,\n      numInstances,\n      startIndices,\n      props,\n      transitions: props.transitions,\n      buffers: props.data.attributes,\n      context: this\n    });\n    const changedAttributes = attributeManager.getChangedAttributes({\n      clearChangedFlags: true\n    });\n    this.updateAttributes(changedAttributes);\n  }\n\n  _updateAttributeTransition() {\n    const attributeManager = this.getAttributeManager();\n\n    if (attributeManager) {\n      attributeManager.updateTransition();\n    }\n  }\n\n  _updateUniformTransition() {\n    const {\n      uniformTransitions\n    } = this.internalState;\n\n    if (uniformTransitions.active) {\n      const propsInTransition = uniformTransitions.update();\n      const props = Object.create(this.props);\n\n      for (const key in propsInTransition) {\n        Object.defineProperty(props, key, {\n          value: propsInTransition[key]\n        });\n      }\n\n      return props;\n    }\n\n    return this.props;\n  }\n\n  calculateInstancePickingColors(attribute, {\n    numInstances\n  }) {\n    if (attribute.constant) {\n      return;\n    }\n\n    const cacheSize = Math.floor(pickingColorCache.length / 3);\n    this.internalState.usesPickingColorCache = true;\n\n    if (cacheSize < numInstances) {\n      if (numInstances > MAX_PICKING_COLOR_CACHE_SIZE) {\n        log/* default.warn */.Z.warn('Layer has too many data objects. Picking might not be able to distinguish all objects.')();\n      }\n\n      pickingColorCache = typed_array_manager/* default.allocate */.Z.allocate(pickingColorCache, numInstances, {\n        size: 3,\n        copy: true,\n        maxCount: Math.max(numInstances, MAX_PICKING_COLOR_CACHE_SIZE)\n      });\n      const newCacheSize = Math.floor(pickingColorCache.length / 3);\n      const pickingColor = [];\n\n      for (let i = cacheSize; i < newCacheSize; i++) {\n        this.encodePickingColor(i, pickingColor);\n        pickingColorCache[i * 3 + 0] = pickingColor[0];\n        pickingColorCache[i * 3 + 1] = pickingColor[1];\n        pickingColorCache[i * 3 + 2] = pickingColor[2];\n      }\n    }\n\n    attribute.value = pickingColorCache.subarray(0, numInstances * 3);\n  }\n\n  _setModelAttributes(model, changedAttributes) {\n    const attributeManager = this.getAttributeManager();\n    const excludeAttributes = model.userData.excludeAttributes || {};\n    const shaderAttributes = attributeManager.getShaderAttributes(changedAttributes, excludeAttributes);\n    model.setAttributes(shaderAttributes);\n  }\n\n  disablePickingIndex(objectIndex) {\n    this._disablePickingIndex(objectIndex);\n  }\n\n  _disablePickingIndex(objectIndex) {\n    const {\n      pickingColors,\n      instancePickingColors\n    } = this.getAttributeManager().attributes;\n    const colors = pickingColors || instancePickingColors;\n\n    if (!colors) {\n      return;\n    }\n\n    const start = colors.getVertexOffset(objectIndex);\n    const end = colors.getVertexOffset(objectIndex + 1);\n    colors.buffer.subData({\n      data: new Uint8Array(end - start),\n      offset: start\n    });\n  }\n\n  restorePickingColors() {\n    const {\n      pickingColors,\n      instancePickingColors\n    } = this.getAttributeManager().attributes;\n    const colors = pickingColors || instancePickingColors;\n\n    if (!colors) {\n      return;\n    }\n\n    if (this.internalState.usesPickingColorCache && colors.value.buffer !== pickingColorCache.buffer) {\n      colors.value = pickingColorCache.subarray(0, colors.value.length);\n    }\n\n    colors.updateSubBuffer({\n      startOffset: 0\n    });\n  }\n\n  _initialize() {\n    (0,assert/* default */.Z)(!this.internalState);\n    (0,assert/* default */.Z)(Number.isFinite(this.props.coordinateSystem));\n    (0,debug/* default */.Z)(TRACE_INITIALIZE, this);\n\n    const attributeManager = this._getAttributeManager();\n\n    if (attributeManager) {\n      attributeManager.addInstanced({\n        instancePickingColors: {\n          type: 5121,\n          size: 3,\n          noAlloc: true,\n          update: this.calculateInstancePickingColors\n        }\n      });\n    }\n\n    this.internalState = new LayerState({\n      attributeManager,\n      layer: this\n    });\n\n    this._clearChangeFlags();\n\n    this.state = {};\n    Object.defineProperty(this.state, 'attributeManager', {\n      get: () => {\n        log/* default.deprecated */.Z.deprecated('layer.state.attributeManager', 'layer.getAttributeManager()')();\n        return attributeManager;\n      }\n    });\n    this.internalState.uniformTransitions = new uniform_transition_manager/* default */.Z(this.context.timeline);\n    this.internalState.onAsyncPropUpdated = this._onAsyncPropUpdated.bind(this);\n    this.internalState.setAsyncProps(this.props);\n    this.initializeState(this.context);\n\n    for (const extension of this.props.extensions) {\n      extension.initializeState.call(this, this.context, extension);\n    }\n\n    this.setChangeFlags({\n      dataChanged: 'init',\n      propsChanged: 'init',\n      viewportChanged: true,\n      extensionsChanged: true\n    });\n\n    this._update();\n  }\n\n  _transferState(oldLayer) {\n    (0,debug/* default */.Z)(TRACE_MATCHED, this, this === oldLayer);\n    const {\n      state,\n      internalState\n    } = oldLayer;\n\n    if (this === oldLayer) {\n      return;\n    }\n\n    this.internalState = internalState;\n    this.state = state;\n    this.internalState.setAsyncProps(this.props);\n\n    this._diffProps(this.props, this.internalState.getOldProps());\n  }\n\n  _update() {\n    const stateNeedsUpdate = this.needsUpdate();\n    (0,debug/* default */.Z)(TRACE_UPDATE, this, stateNeedsUpdate);\n\n    if (!stateNeedsUpdate) {\n      return;\n    }\n\n    const currentProps = this.props;\n    const context = this.context;\n    const internalState = this.internalState;\n    const currentViewport = context.viewport;\n\n    const propsInTransition = this._updateUniformTransition();\n\n    internalState.propsInTransition = propsInTransition;\n    context.viewport = internalState.viewport || currentViewport;\n    this.props = propsInTransition;\n\n    try {\n      const updateParams = this._getUpdateParams();\n\n      const oldModels = this.getModels();\n\n      if (context.gl) {\n        this.updateState(updateParams);\n      } else {\n        try {\n          this.updateState(updateParams);\n        } catch (error) {}\n      }\n\n      for (const extension of this.props.extensions) {\n        extension.updateState.call(this, updateParams, extension);\n      }\n\n      const modelChanged = this.getModels()[0] !== oldModels[0];\n\n      this._postUpdate(updateParams, modelChanged);\n    } finally {\n      context.viewport = currentViewport;\n      this.props = currentProps;\n\n      this._clearChangeFlags();\n\n      internalState.needsUpdate = false;\n      internalState.resetOldProps();\n    }\n  }\n\n  _finalize() {\n    (0,debug/* default */.Z)(TRACE_FINALIZE, this);\n    this.finalizeState(this.context);\n\n    for (const extension of this.props.extensions) {\n      extension.finalizeState.call(this, this.context, extension);\n    }\n  }\n\n  _drawLayer({\n    moduleParameters = null,\n    uniforms = {},\n    parameters = {}\n  }) {\n    this._updateAttributeTransition();\n\n    const currentProps = this.props;\n    const context = this.context;\n    this.props = this.internalState.propsInTransition || currentProps;\n    const opacity = this.props.opacity;\n    uniforms.opacity = Math.pow(opacity, 1 / 2.2);\n\n    try {\n      if (moduleParameters) {\n        this.setModuleParameters(moduleParameters);\n      }\n\n      const {\n        getPolygonOffset\n      } = this.props;\n      const offsets = getPolygonOffset && getPolygonOffset(uniforms) || [0, 0];\n      (0,esm/* setParameters */.dR)(context.gl, {\n        polygonOffset: offsets\n      });\n      (0,esm/* withParameters */.s8)(context.gl, parameters, () => {\n        const opts = {\n          moduleParameters,\n          uniforms,\n          parameters,\n          context\n        };\n\n        for (const extension of this.props.extensions) {\n          extension.draw.call(this, opts, extension);\n        }\n\n        this.draw(opts);\n      });\n    } finally {\n      this.props = currentProps;\n    }\n  }\n\n  getChangeFlags() {\n    var _this$internalState2;\n\n    return (_this$internalState2 = this.internalState) === null || _this$internalState2 === void 0 ? void 0 : _this$internalState2.changeFlags;\n  }\n\n  setChangeFlags(flags) {\n    if (!this.internalState) {\n      return;\n    }\n\n    const {\n      changeFlags\n    } = this.internalState;\n\n    for (const key in flags) {\n      if (flags[key]) {\n        let flagChanged = false;\n\n        switch (key) {\n          case 'dataChanged':\n            const dataChangedReason = flags[key];\n            const prevDataChangedReason = changeFlags[key];\n\n            if (dataChangedReason && Array.isArray(prevDataChangedReason)) {\n              changeFlags.dataChanged = Array.isArray(dataChangedReason) ? prevDataChangedReason.concat(dataChangedReason) : dataChangedReason;\n              flagChanged = true;\n            }\n\n          default:\n            if (!changeFlags[key]) {\n              changeFlags[key] = flags[key];\n              flagChanged = true;\n            }\n\n        }\n\n        if (flagChanged) {\n          (0,debug/* default */.Z)(TRACE_CHANGE_FLAG, this, key, flags);\n        }\n      }\n    }\n\n    const propsOrDataChanged = Boolean(changeFlags.dataChanged || changeFlags.updateTriggersChanged || changeFlags.propsChanged || changeFlags.extensionsChanged);\n    changeFlags.propsOrDataChanged = propsOrDataChanged;\n    changeFlags.somethingChanged = propsOrDataChanged || changeFlags.viewportChanged || changeFlags.stateChanged;\n  }\n\n  _clearChangeFlags() {\n    this.internalState.changeFlags = {\n      dataChanged: false,\n      propsChanged: false,\n      updateTriggersChanged: false,\n      viewportChanged: false,\n      stateChanged: false,\n      extensionsChanged: false,\n      propsOrDataChanged: false,\n      somethingChanged: false\n    };\n  }\n\n  _diffProps(newProps, oldProps) {\n    const changeFlags = (0,props/* diffProps */.Yt)(newProps, oldProps);\n\n    if (changeFlags.updateTriggersChanged) {\n      for (const key in changeFlags.updateTriggersChanged) {\n        if (changeFlags.updateTriggersChanged[key]) {\n          this.invalidateAttribute(key);\n        }\n      }\n    }\n\n    if (changeFlags.transitionsChanged) {\n      for (const key in changeFlags.transitionsChanged) {\n        var _newProps$transitions;\n\n        this.internalState.uniformTransitions.add(key, oldProps[key], newProps[key], (_newProps$transitions = newProps.transitions) === null || _newProps$transitions === void 0 ? void 0 : _newProps$transitions[key]);\n      }\n    }\n\n    return this.setChangeFlags(changeFlags);\n  }\n\n  validateProps() {\n    (0,props/* validateProps */.eQ)(this.props);\n  }\n\n  updateAutoHighlight(info) {\n    if (this.props.autoHighlight && !Number.isInteger(this.props.highlightedObjectIndex)) {\n      this._updateAutoHighlight(info);\n    }\n  }\n\n  _updateAutoHighlight(info) {\n    const pickingModuleParameters = {\n      pickingSelectedColor: info.picked ? info.color : null\n    };\n    const {\n      highlightColor\n    } = this.props;\n\n    if (info.picked && typeof highlightColor === 'function') {\n      pickingModuleParameters.pickingHighlightColor = highlightColor(info);\n    }\n\n    this.setModuleParameters(pickingModuleParameters);\n    this.setNeedsRedraw();\n  }\n\n  _getAttributeManager() {\n    const context = this.context;\n    return new AttributeManager(context.gl, {\n      id: this.props.id,\n      stats: context.stats,\n      timeline: context.timeline\n    });\n  }\n\n  _postUpdate(updateParams, forceUpdate) {\n    const {\n      props,\n      oldProps\n    } = updateParams;\n    this.setNeedsRedraw();\n\n    this._updateAttributes();\n\n    const {\n      model\n    } = this.state;\n    model === null || model === void 0 ? void 0 : model.setInstanceCount(this.getNumInstances());\n    const {\n      autoHighlight,\n      highlightedObjectIndex,\n      highlightColor\n    } = props;\n\n    if (forceUpdate || oldProps.autoHighlight !== autoHighlight || oldProps.highlightedObjectIndex !== highlightedObjectIndex || oldProps.highlightColor !== highlightColor) {\n      const parameters = {};\n\n      if (!autoHighlight) {\n        parameters.pickingSelectedColor = null;\n      }\n\n      if (Array.isArray(highlightColor)) {\n        parameters.pickingHighlightColor = highlightColor;\n      }\n\n      if (forceUpdate || highlightedObjectIndex !== oldProps.highlightedObjectIndex) {\n        parameters.pickingSelectedColor = Number.isFinite(highlightedObjectIndex) && highlightedObjectIndex >= 0 ? this.encodePickingColor(highlightedObjectIndex) : null;\n      }\n\n      this.setModuleParameters(parameters);\n    }\n  }\n\n  _getUpdateParams() {\n    return {\n      props: this.props,\n      oldProps: this.internalState.getOldProps(),\n      context: this.context,\n      changeFlags: this.internalState.changeFlags\n    };\n  }\n\n  _getNeedsRedraw(opts) {\n    if (!this.internalState) {\n      return false;\n    }\n\n    let redraw = false;\n    redraw = redraw || this.internalState.needsRedraw && this.id;\n    const attributeManager = this.getAttributeManager();\n    const attributeManagerNeedsRedraw = attributeManager ? attributeManager.getNeedsRedraw(opts) : false;\n    redraw = redraw || attributeManagerNeedsRedraw;\n\n    if (redraw) {\n      for (const extension of this.props.extensions) {\n        extension.onNeedsRedraw.call(this, extension);\n      }\n    }\n\n    this.internalState.needsRedraw = this.internalState.needsRedraw && !opts.clearRedrawFlags;\n    return redraw;\n  }\n\n  _onAsyncPropUpdated() {\n    this._diffProps(this.props, this.internalState.getOldProps());\n\n    this.setNeedsUpdate();\n  }\n\n}\n\n(0,defineProperty/* default */.Z)(Layer, \"defaultProps\", defaultProps);\n\n(0,defineProperty/* default */.Z)(Layer, \"layerName\", 'Layer');\n//# sourceMappingURL=layer.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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Q0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsTUFBTTs7QUFFTjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxN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QUVBO0FBQ0E7O0FBRUE7QUFDQSxJQUFJLCtCQUFhO0FBQ2pCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTs7QUFFTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFlLGdCQUFnQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047O0FBRUE7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTs7QUFFTjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBLGlDQUFlOztBQUVmLGlDQUFlO0FBQ2YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly92dWUzLXdlYnBhY2s1Ly4vbm9kZV9tb2R1bGVzL0BkZWNrLmdsL2NvcmUvZGlzdC9lc20vbGliL2F0dHJpYnV0ZS9hdHRyaWJ1dGUtdHJhbnNpdGlvbi1tYW5hZ2VyLmpzPzIwMmYiLCJ3ZWJwYWNrOi8vdnVlMy13ZWJwYWNrNS8uL25vZGVfbW9kdWxlcy9AZGVjay5nbC9jb3JlL2Rpc3QvZXNtL2xpYi9hdHRyaWJ1dGUvYXR0cmlidXRlLW1hbmFnZXIuanM/MmJlMyIsIndlYnBhY2s6Ly92dWUzLXdlYnBhY2s1Ly4vbm9kZV9tb2R1bGVzL0BkZWNrLmdsL2NvcmUvZGlzdC9lc20vbGliL2xheWVyLXN0YXRlLmpzPzkzOWUiLCJ3ZWJwYWNrOi8vdnVlMy13ZWJwYWNrNS8uL25vZGVfbW9kdWxlcy9AZGVjay5nbC9jb3JlL2Rpc3QvZXNtL2xpYi9sYXllci5qcz8xODA4Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBfZGVmaW5lUHJvcGVydHkgZnJvbSBcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL2RlZmluZVByb3BlcnR5XCI7XG5pbXBvcnQgeyBUcmFuc2Zvcm0gfSBmcm9tICdAbHVtYS5nbC9jb3JlJztcbmltcG9ydCBHUFVJbnRlcnBvbGF0aW9uVHJhbnNpdGlvbiBmcm9tICcuLi8uLi90cmFuc2l0aW9ucy9ncHUtaW50ZXJwb2xhdGlvbi10cmFuc2l0aW9uJztcbmltcG9ydCBHUFVTcHJpbmdUcmFuc2l0aW9uIGZyb20gJy4uLy4uL3RyYW5zaXRpb25zL2dwdS1zcHJpbmctdHJhbnNpdGlvbic7XG5pbXBvcnQgbG9nIGZyb20gJy4uLy4uL3V0aWxzL2xvZyc7XG5jb25zdCBUUkFOU0lUSU9OX1RZUEVTID0ge1xuICBpbnRlcnBvbGF0aW9uOiBHUFVJbnRlcnBvbGF0aW9uVHJhbnNpdGlvbixcbiAgc3ByaW5nOiBHUFVTcHJpbmdUcmFuc2l0aW9uXG59O1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQXR0cmlidXRlVHJhbnNpdGlvbk1hbmFnZXIge1xuICBjb25zdHJ1Y3RvcihnbCwge1xuICAgIGlkLFxuICAgIHRpbWVsaW5lXG4gIH0pIHtcbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJpZFwiLCB2b2lkIDApO1xuXG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwiaXNTdXBwb3J0ZWRcIiwgdm9pZCAwKTtcblxuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImdsXCIsIHZvaWQgMCk7XG5cbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJ0aW1lbGluZVwiLCB2b2lkIDApO1xuXG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwidHJhbnNpdGlvbnNcIiwgdm9pZCAwKTtcblxuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIm5lZWRzUmVkcmF3XCIsIHZvaWQgMCk7XG5cbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJudW1JbnN0YW5jZXNcIiwgdm9pZCAwKTtcblxuICAgIHRoaXMuaWQgPSBpZDtcbiAgICB0aGlzLmdsID0gZ2w7XG4gICAgdGhpcy50aW1lbGluZSA9IHRpbWVsaW5lO1xuICAgIHRoaXMudHJhbnNpdGlvbnMgPSB7fTtcbiAgICB0aGlzLm5lZWRzUmVkcmF3ID0gZmFsc2U7XG4gICAgdGhpcy5udW1JbnN0YW5jZXMgPSAxO1xuICAgIHRoaXMuaXNTdXBwb3J0ZWQgPSBUcmFuc2Zvcm0uaXNTdXBwb3J0ZWQoZ2wpO1xuICB9XG5cbiAgZmluYWxpemUoKSB7XG4gICAgZm9yIChjb25zdCBhdHRyaWJ1dGVOYW1lIGluIHRoaXMudHJhbnNpdGlvbnMpIHtcbiAgICAgIHRoaXMuX3JlbW92ZVRyYW5zaXRpb24oYXR0cmlidXRlTmFtZSk7XG4gICAgfVxuICB9XG5cbiAgdXBkYXRlKHtcbiAgICBhdHRyaWJ1dGVzLFxuICAgIHRyYW5zaXRpb25zLFxuICAgIG51bUluc3RhbmNlc1xuICB9KSB7XG4gICAgdGhpcy5udW1JbnN0YW5jZXMgPSBudW1JbnN0YW5jZXMgfHwgMTtcblxuICAgIGZvciAoY29uc3QgYXR0cmlidXRlTmFtZSBpbiBhdHRyaWJ1dGVzKSB7XG4gICAgICBjb25zdCBhdHRyaWJ1dGUgPSBhdHRyaWJ1dGVzW2F0dHJpYnV0ZU5hbWVdO1xuICAgICAgY29uc3Qgc2V0dGluZ3MgPSBhdHRyaWJ1dGUuZ2V0VHJhbnNpdGlvblNldHRpbmcodHJhbnNpdGlvbnMpO1xuICAgICAgaWYgKCFzZXR0aW5ncykgY29udGludWU7XG5cbiAgICAgIHRoaXMuX3VwZGF0ZUF0dHJpYnV0ZShhdHRyaWJ1dGVOYW1lLCBhdHRyaWJ1dGUsIHNldHRpbmdzKTtcbiAgICB9XG5cbiAgICBmb3IgKGNvbnN0IGF0dHJpYnV0ZU5hbWUgaW4gdGhpcy50cmFuc2l0aW9ucykge1xuICAgICAgY29uc3QgYXR0cmlidXRlID0gYXR0cmlidXRlc1thdHRyaWJ1dGVOYW1lXTtcblxuICAgICAgaWYgKCFhdHRyaWJ1dGUgfHwgIWF0dHJpYnV0ZS5nZXRUcmFuc2l0aW9uU2V0dGluZyh0cmFuc2l0aW9ucykpIHtcbiAgICAgICAgdGhpcy5fcmVtb3ZlVHJhbnNpdGlvbihhdHRyaWJ1dGVOYW1lKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBoYXNBdHRyaWJ1dGUoYXR0cmlidXRlTmFtZSkge1xuICAgIGNvbnN0IHRyYW5zaXRpb24gPSB0aGlzLnRyYW5zaXRpb25zW2F0dHJpYnV0ZU5hbWVdO1xuICAgIHJldHVybiB0cmFuc2l0aW9uICYmIHRyYW5zaXRpb24uaW5Qcm9ncmVzcztcbiAgfVxuXG4gIGdldEF0dHJpYnV0ZXMoKSB7XG4gICAgY29uc3QgYW5pbWF0ZWRBdHRyaWJ1dGVzID0ge307XG5cbiAgICBmb3IgKGNvbnN0IGF0dHJpYnV0ZU5hbWUgaW4gdGhpcy50cmFuc2l0aW9ucykge1xuICAgICAgY29uc3QgdHJhbnNpdGlvbiA9IHRoaXMudHJhbnNpdGlvbnNbYXR0cmlidXRlTmFtZV07XG5cbiAgICAgIGlmICh0cmFuc2l0aW9uLmluUHJvZ3Jlc3MpIHtcbiAgICAgICAgYW5pbWF0ZWRBdHRyaWJ1dGVzW2F0dHJpYnV0ZU5hbWVdID0gdHJhbnNpdGlvbi5hdHRyaWJ1dGVJblRyYW5zaXRpb247XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGFuaW1hdGVkQXR0cmlidXRlcztcbiAgfVxuXG4gIHJ1bigpIHtcbiAgICBpZiAoIXRoaXMuaXNTdXBwb3J0ZWQgfHwgdGhpcy5udW1JbnN0YW5jZXMgPT09IDApIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBmb3IgKGNvbnN0IGF0dHJpYnV0ZU5hbWUgaW4gdGhpcy50cmFuc2l0aW9ucykge1xuICAgICAgY29uc3QgdXBkYXRlZCA9IHRoaXMudHJhbnNpdGlvbnNbYXR0cmlidXRlTmFtZV0udXBkYXRlKCk7XG5cbiAgICAgIGlmICh1cGRhdGVkKSB7XG4gICAgICAgIHRoaXMubmVlZHNSZWRyYXcgPSB0cnVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIGNvbnN0IG5lZWRzUmVkcmF3ID0gdGhpcy5uZWVkc1JlZHJhdztcbiAgICB0aGlzLm5lZWRzUmVkcmF3ID0gZmFsc2U7XG4gICAgcmV0dXJuIG5lZWRzUmVkcmF3O1xuICB9XG5cbiAgX3JlbW92ZVRyYW5zaXRpb24oYXR0cmlidXRlTmFtZSkge1xuICAgIHRoaXMudHJhbnNpdGlvbnNbYXR0cmlidXRlTmFtZV0uY2FuY2VsKCk7XG4gICAgZGVsZXRlIHRoaXMudHJhbnNpdGlvbnNbYXR0cmlidXRlTmFtZV07XG4gIH1cblxuICBfdXBkYXRlQXR0cmlidXRlKGF0dHJpYnV0ZU5hbWUsIGF0dHJpYnV0ZSwgc2V0dGluZ3MpIHtcbiAgICBjb25zdCB0cmFuc2l0aW9uID0gdGhpcy50cmFuc2l0aW9uc1thdHRyaWJ1dGVOYW1lXTtcbiAgICBsZXQgaXNOZXcgPSAhdHJhbnNpdGlvbiB8fCB0cmFuc2l0aW9uLnR5cGUgIT09IHNldHRpbmdzLnR5cGU7XG5cbiAgICBpZiAoaXNOZXcpIHtcbiAgICAgIGlmICghdGhpcy5pc1N1cHBvcnRlZCkge1xuICAgICAgICBsb2cud2FybihcIldlYkdMMiBub3Qgc3VwcG9ydGVkIGJ5IHRoaXMgYnJvd3Nlci4gVHJhbnNpdGlvbiBmb3IgXCIuY29uY2F0KGF0dHJpYnV0ZU5hbWUsIFwiIGlzIGRpc2FibGVkLlwiKSkoKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiAodHJhbnNpdGlvbikge1xuICAgICAgICB0aGlzLl9yZW1vdmVUcmFuc2l0aW9uKGF0dHJpYnV0ZU5hbWUpO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBUcmFuc2l0aW9uVHlwZSA9IFRSQU5TSVRJT05fVFlQRVNbc2V0dGluZ3MudHlwZV07XG5cbiAgICAgIGlmIChUcmFuc2l0aW9uVHlwZSkge1xuICAgICAgICB0aGlzLnRyYW5zaXRpb25zW2F0dHJpYnV0ZU5hbWVdID0gbmV3IFRyYW5zaXRpb25UeXBlKHtcbiAgICAgICAgICBhdHRyaWJ1dGUsXG4gICAgICAgICAgdGltZWxpbmU6IHRoaXMudGltZWxpbmUsXG4gICAgICAgICAgZ2w6IHRoaXMuZ2xcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsb2cuZXJyb3IoXCJ1bnN1cHBvcnRlZCB0cmFuc2l0aW9uIHR5cGUgJ1wiLmNvbmNhdChzZXR0aW5ncy50eXBlLCBcIidcIikpKCk7XG4gICAgICAgIGlzTmV3ID0gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGlzTmV3IHx8IGF0dHJpYnV0ZS5uZWVkc1JlZHJhdygpKSB7XG4gICAgICB0aGlzLm5lZWRzUmVkcmF3ID0gdHJ1ZTtcbiAgICAgIHRoaXMudHJhbnNpdGlvbnNbYXR0cmlidXRlTmFtZV0uc3RhcnQoc2V0dGluZ3MsIHRoaXMubnVtSW5zdGFuY2VzKTtcbiAgICB9XG4gIH1cblxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YXR0cmlidXRlLXRyYW5zaXRpb24tbWFuYWdlci5qcy5tYXAiLCJpbXBvcnQgX2RlZmluZVByb3BlcnR5IGZyb20gXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9kZWZpbmVQcm9wZXJ0eVwiO1xuaW1wb3J0IEF0dHJpYnV0ZSBmcm9tICcuL2F0dHJpYnV0ZSc7XG5pbXBvcnQgbG9nIGZyb20gJy4uLy4uL3V0aWxzL2xvZyc7XG5pbXBvcnQgbWVtb2l6ZSBmcm9tICcuLi8uLi91dGlscy9tZW1vaXplJztcbmltcG9ydCB7IG1lcmdlQm91bmRzIH0gZnJvbSAnLi4vLi4vdXRpbHMvbWF0aC11dGlscyc7XG5pbXBvcnQgZGVidWcgZnJvbSAnLi4vLi4vZGVidWcnO1xuaW1wb3J0IEF0dHJpYnV0ZVRyYW5zaXRpb25NYW5hZ2VyIGZyb20gJy4vYXR0cmlidXRlLXRyYW5zaXRpb24tbWFuYWdlcic7XG5jb25zdCBUUkFDRV9JTlZBTElEQVRFID0gJ2F0dHJpYnV0ZU1hbmFnZXIuaW52YWxpZGF0ZSc7XG5jb25zdCBUUkFDRV9VUERBVEVfU1RBUlQgPSAnYXR0cmlidXRlTWFuYWdlci51cGRhdGVTdGFydCc7XG5jb25zdCBUUkFDRV9VUERBVEVfRU5EID0gJ2F0dHJpYnV0ZU1hbmFnZXIudXBkYXRlRW5kJztcbmNvbnN0IFRSQUNFX0FUVFJJQlVURV9VUERBVEVfU1RBUlQgPSAnYXR0cmlidXRlLnVwZGF0ZVN0YXJ0JztcbmNvbnN0IFRSQUNFX0FUVFJJQlVURV9BTExPQ0FURSA9ICdhdHRyaWJ1dGUuYWxsb2NhdGUnO1xuY29uc3QgVFJBQ0VfQVRUUklCVVRFX1VQREFURV9FTkQgPSAnYXR0cmlidXRlLnVwZGF0ZUVuZCc7XG5leHBvcnQgZGVmYXVsdCBjbGFzcyBBdHRyaWJ1dGVNYW5hZ2VyIHtcbiAgY29uc3RydWN0b3IoZ2wsIHtcbiAgICBpZCA9ICdhdHRyaWJ1dGUtbWFuYWdlcicsXG4gICAgc3RhdHMsXG4gICAgdGltZWxpbmVcbiAgfSA9IHt9KSB7XG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwiaWRcIiwgdm9pZCAwKTtcblxuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImdsXCIsIHZvaWQgMCk7XG5cbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJhdHRyaWJ1dGVzXCIsIHZvaWQgMCk7XG5cbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJ1cGRhdGVUcmlnZ2Vyc1wiLCB2b2lkIDApO1xuXG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwibmVlZHNSZWRyYXdcIiwgdm9pZCAwKTtcblxuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInVzZXJEYXRhXCIsIHZvaWQgMCk7XG5cbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJzdGF0c1wiLCB2b2lkIDApO1xuXG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwiYXR0cmlidXRlVHJhbnNpdGlvbk1hbmFnZXJcIiwgdm9pZCAwKTtcblxuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIm1lcmdlQm91bmRzTWVtb2l6ZWRcIiwgbWVtb2l6ZShtZXJnZUJvdW5kcykpO1xuXG4gICAgdGhpcy5pZCA9IGlkO1xuICAgIHRoaXMuZ2wgPSBnbDtcbiAgICB0aGlzLmF0dHJpYnV0ZXMgPSB7fTtcbiAgICB0aGlzLnVwZGF0ZVRyaWdnZXJzID0ge307XG4gICAgdGhpcy5uZWVkc1JlZHJhdyA9IHRydWU7XG4gICAgdGhpcy51c2VyRGF0YSA9IHt9O1xuICAgIHRoaXMuc3RhdHMgPSBzdGF0cztcbiAgICB0aGlzLmF0dHJpYnV0ZVRyYW5zaXRpb25NYW5hZ2VyID0gbmV3IEF0dHJpYnV0ZVRyYW5zaXRpb25NYW5hZ2VyKGdsLCB7XG4gICAgICBpZDogXCJcIi5jb25jYXQoaWQsIFwiLXRyYW5zaXRpb25zXCIpLFxuICAgICAgdGltZWxpbmVcbiAgICB9KTtcbiAgICBPYmplY3Quc2VhbCh0aGlzKTtcbiAgfVxuXG4gIGZpbmFsaXplKCkge1xuICAgIGZvciAoY29uc3QgYXR0cmlidXRlTmFtZSBpbiB0aGlzLmF0dHJpYnV0ZXMpIHtcbiAgICAgIHRoaXMuYXR0cmlidXRlc1thdHRyaWJ1dGVOYW1lXS5kZWxldGUoKTtcbiAgICB9XG5cbiAgICB0aGlzLmF0dHJpYnV0ZVRyYW5zaXRpb25NYW5hZ2VyLmZpbmFsaXplKCk7XG4gIH1cblxuICBnZXROZWVkc1JlZHJhdyhvcHRzID0ge1xuICAgIGNsZWFyUmVkcmF3RmxhZ3M6IGZhbHNlXG4gIH0pIHtcbiAgICBjb25zdCByZWRyYXcgPSB0aGlzLm5lZWRzUmVkcmF3O1xuICAgIHRoaXMubmVlZHNSZWRyYXcgPSB0aGlzLm5lZWRzUmVkcmF3ICYmICFvcHRzLmNsZWFyUmVkcmF3RmxhZ3M7XG4gICAgcmV0dXJuIHJlZHJhdyAmJiB0aGlzLmlkO1xuICB9XG5cbiAgc2V0TmVlZHNSZWRyYXcoKSB7XG4gICAgdGhpcy5uZWVkc1JlZHJhdyA9IHRydWU7XG4gIH1cblxuICBhZGQoYXR0cmlidXRlcykge1xuICAgIHRoaXMuX2FkZChhdHRyaWJ1dGVzKTtcbiAgfVxuXG4gIGFkZEluc3RhbmNlZChhdHRyaWJ1dGVzKSB7XG4gICAgdGhpcy5fYWRkKGF0dHJpYnV0ZXMsIHtcbiAgICAgIGluc3RhbmNlZDogMVxuICAgIH0pO1xuICB9XG5cbiAgcmVtb3ZlKGF0dHJpYnV0ZU5hbWVBcnJheSkge1xuICAgIGZvciAoY29uc3QgbmFtZSBvZiBhdHRyaWJ1dGVOYW1lQXJyYXkpIHtcbiAgICAgIGlmICh0aGlzLmF0dHJpYnV0ZXNbbmFtZV0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aGlzLmF0dHJpYnV0ZXNbbmFtZV0uZGVsZXRlKCk7XG4gICAgICAgIGRlbGV0ZSB0aGlzLmF0dHJpYnV0ZXNbbmFtZV07XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgaW52YWxpZGF0ZSh0cmlnZ2VyTmFtZSwgZGF0YVJhbmdlKSB7XG4gICAgY29uc3QgaW52YWxpZGF0ZWRBdHRyaWJ1dGVzID0gdGhpcy5faW52YWxpZGF0ZVRyaWdnZXIodHJpZ2dlck5hbWUsIGRhdGFSYW5nZSk7XG5cbiAgICBkZWJ1ZyhUUkFDRV9JTlZBTElEQVRFLCB0aGlzLCB0cmlnZ2VyTmFtZSwgaW52YWxpZGF0ZWRBdHRyaWJ1dGVzKTtcbiAgfVxuXG4gIGludmFsaWRhdGVBbGwoZGF0YVJhbmdlKSB7XG4gICAgZm9yIChjb25zdCBhdHRyaWJ1dGVOYW1lIGluIHRoaXMuYXR0cmlidXRlcykge1xuICAgICAgdGhpcy5hdHRyaWJ1dGVzW2F0dHJpYnV0ZU5hbWVdLnNldE5lZWRzVXBkYXRlKGF0dHJpYnV0ZU5hbWUsIGRhdGFSYW5nZSk7XG4gICAgfVxuXG4gICAgZGVidWcoVFJBQ0VfSU5WQUxJREFURSwgdGhpcywgJ2FsbCcpO1xuICB9XG5cbiAgdXBkYXRlKHtcbiAgICBkYXRhLFxuICAgIG51bUluc3RhbmNlcyxcbiAgICBzdGFydEluZGljZXMgPSBudWxsLFxuICAgIHRyYW5zaXRpb25zLFxuICAgIHByb3BzID0ge30sXG4gICAgYnVmZmVycyA9IHt9LFxuICAgIGNvbnRleHQgPSB7fVxuICB9KSB7XG4gICAgbGV0IHVwZGF0ZWQgPSBmYWxzZTtcbiAgICBkZWJ1ZyhUUkFDRV9VUERBVEVfU1RBUlQsIHRoaXMpO1xuXG4gICAgaWYgKHRoaXMuc3RhdHMpIHtcbiAgICAgIHRoaXMuc3RhdHMuZ2V0KCdVcGRhdGUgQXR0cmlidXRlcycpLnRpbWVTdGFydCgpO1xuICAgIH1cblxuICAgIGZvciAoY29uc3QgYXR0cmlidXRlTmFtZSBpbiB0aGlzLmF0dHJpYnV0ZXMpIHtcbiAgICAgIGNvbnN0IGF0dHJpYnV0ZSA9IHRoaXMuYXR0cmlidXRlc1thdHRyaWJ1dGVOYW1lXTtcbiAgICAgIGNvbnN0IGFjY2Vzc29yTmFtZSA9IGF0dHJpYnV0ZS5zZXR0aW5ncy5hY2Nlc3NvcjtcbiAgICAgIGF0dHJpYnV0ZS5zdGFydEluZGljZXMgPSBzdGFydEluZGljZXM7XG4gICAgICBhdHRyaWJ1dGUubnVtSW5zdGFuY2VzID0gbnVtSW5zdGFuY2VzO1xuXG4gICAgICBpZiAocHJvcHNbYXR0cmlidXRlTmFtZV0pIHtcbiAgICAgICAgbG9nLnJlbW92ZWQoXCJwcm9wcy5cIi5jb25jYXQoYXR0cmlidXRlTmFtZSksIFwiZGF0YS5hdHRyaWJ1dGVzLlwiLmNvbmNhdChhdHRyaWJ1dGVOYW1lKSkoKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGF0dHJpYnV0ZS5zZXRFeHRlcm5hbEJ1ZmZlcihidWZmZXJzW2F0dHJpYnV0ZU5hbWVdKSkge30gZWxzZSBpZiAoYXR0cmlidXRlLnNldEJpbmFyeVZhbHVlKHR5cGVvZiBhY2Nlc3Nvck5hbWUgPT09ICdzdHJpbmcnID8gYnVmZmVyc1thY2Nlc3Nvck5hbWVdIDogdW5kZWZpbmVkLCBkYXRhLnN0YXJ0SW5kaWNlcykpIHt9IGVsc2UgaWYgKHR5cGVvZiBhY2Nlc3Nvck5hbWUgPT09ICdzdHJpbmcnICYmICFidWZmZXJzW2FjY2Vzc29yTmFtZV0gJiYgYXR0cmlidXRlLnNldENvbnN0YW50VmFsdWUocHJvcHNbYWNjZXNzb3JOYW1lXSkpIHt9IGVsc2UgaWYgKGF0dHJpYnV0ZS5uZWVkc1VwZGF0ZSgpKSB7XG4gICAgICAgIHVwZGF0ZWQgPSB0cnVlO1xuXG4gICAgICAgIHRoaXMuX3VwZGF0ZUF0dHJpYnV0ZSh7XG4gICAgICAgICAgYXR0cmlidXRlLFxuICAgICAgICAgIG51bUluc3RhbmNlcyxcbiAgICAgICAgICBkYXRhLFxuICAgICAgICAgIHByb3BzLFxuICAgICAgICAgIGNvbnRleHRcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMubmVlZHNSZWRyYXcgPSB0aGlzLm5lZWRzUmVkcmF3IHx8IGF0dHJpYnV0ZS5uZWVkc1JlZHJhdygpO1xuICAgIH1cblxuICAgIGlmICh1cGRhdGVkKSB7XG4gICAgICBkZWJ1ZyhUUkFDRV9VUERBVEVfRU5ELCB0aGlzLCBudW1JbnN0YW5jZXMpO1xuICAgIH1cblxuICAgIGlmICh0aGlzLnN0YXRzKSB7XG4gICAgICB0aGlzLnN0YXRzLmdldCgnVXBkYXRlIEF0dHJpYnV0ZXMnKS50aW1lRW5kKCk7XG4gICAgfVxuXG4gICAgdGhpcy5hdHRyaWJ1dGVUcmFuc2l0aW9uTWFuYWdlci51cGRhdGUoe1xuICAgICAgYXR0cmlidXRlczogdGhpcy5hdHRyaWJ1dGVzLFxuICAgICAgbnVtSW5zdGFuY2VzLFxuICAgICAgdHJhbnNpdGlvbnNcbiAgICB9KTtcbiAgfVxuXG4gIHVwZGF0ZVRyYW5zaXRpb24oKSB7XG4gICAgY29uc3Qge1xuICAgICAgYXR0cmlidXRlVHJhbnNpdGlvbk1hbmFnZXJcbiAgICB9ID0gdGhpcztcbiAgICBjb25zdCB0cmFuc2l0aW9uVXBkYXRlZCA9IGF0dHJpYnV0ZVRyYW5zaXRpb25NYW5hZ2VyLnJ1bigpO1xuICAgIHRoaXMubmVlZHNSZWRyYXcgPSB0aGlzLm5lZWRzUmVkcmF3IHx8IHRyYW5zaXRpb25VcGRhdGVkO1xuICAgIHJldHVybiB0cmFuc2l0aW9uVXBkYXRlZDtcbiAgfVxuXG4gIGdldEF0dHJpYnV0ZXMoKSB7XG4gICAgcmV0dXJuIHRoaXMuYXR0cmlidXRlcztcbiAgfVxuXG4gIGdldEJvdW5kcyhhdHRyaWJ1dGVOYW1lcykge1xuICAgIGNvbnN0IGJvdW5kcyA9IGF0dHJpYnV0ZU5hbWVzLm1hcChhdHRyaWJ1dGVOYW1lID0+IHtcbiAgICAgIHZhciBfdGhpcyRhdHRyaWJ1dGVzJGF0dHI7XG5cbiAgICAgIHJldHVybiAoX3RoaXMkYXR0cmlidXRlcyRhdHRyID0gdGhpcy5hdHRyaWJ1dGVzW2F0dHJpYnV0ZU5hbWVdKSA9PT0gbnVsbCB8fCBfdGhpcyRhdHRyaWJ1dGVzJGF0dHIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF90aGlzJGF0dHJpYnV0ZXMkYXR0ci5nZXRCb3VuZHMoKTtcbiAgICB9KTtcbiAgICByZXR1cm4gdGhpcy5tZXJnZUJvdW5kc01lbW9pemVkKGJvdW5kcyk7XG4gIH1cblxuICBnZXRDaGFuZ2VkQXR0cmlidXRlcyhvcHRzID0ge1xuICAgIGNsZWFyQ2hhbmdlZEZsYWdzOiBmYWxzZVxuICB9KSB7XG4gICAgY29uc3Qge1xuICAgICAgYXR0cmlidXRlcyxcbiAgICAgIGF0dHJpYnV0ZVRyYW5zaXRpb25NYW5hZ2VyXG4gICAgfSA9IHRoaXM7XG4gICAgY29uc3QgY2hhbmdlZEF0dHJpYnV0ZXMgPSB7IC4uLmF0dHJpYnV0ZVRyYW5zaXRpb25NYW5hZ2VyLmdldEF0dHJpYnV0ZXMoKVxuICAgIH07XG5cbiAgICBmb3IgKGNvbnN0IGF0dHJpYnV0ZU5hbWUgaW4gYXR0cmlidXRlcykge1xuICAgICAgY29uc3QgYXR0cmlidXRlID0gYXR0cmlidXRlc1thdHRyaWJ1dGVOYW1lXTtcblxuICAgICAgaWYgKGF0dHJpYnV0ZS5uZWVkc1JlZHJhdyhvcHRzKSAmJiAhYXR0cmlidXRlVHJhbnNpdGlvbk1hbmFnZXIuaGFzQXR0cmlidXRlKGF0dHJpYnV0ZU5hbWUpKSB7XG4gICAgICAgIGNoYW5nZWRBdHRyaWJ1dGVzW2F0dHJpYnV0ZU5hbWVdID0gYXR0cmlidXRlO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBjaGFuZ2VkQXR0cmlidXRlcztcbiAgfVxuXG4gIGdldFNoYWRlckF0dHJpYnV0ZXMoYXR0cmlidXRlcywgZXhjbHVkZUF0dHJpYnV0ZXMgPSB7fSkge1xuICAgIGlmICghYXR0cmlidXRlcykge1xuICAgICAgYXR0cmlidXRlcyA9IHRoaXMuZ2V0QXR0cmlidXRlcygpO1xuICAgIH1cblxuICAgIGNvbnN0IHNoYWRlckF0dHJpYnV0ZXMgPSB7fTtcblxuICAgIGZvciAoY29uc3QgYXR0cmlidXRlTmFtZSBpbiBhdHRyaWJ1dGVzKSB7XG4gICAgICBpZiAoIWV4Y2x1ZGVBdHRyaWJ1dGVzW2F0dHJpYnV0ZU5hbWVdKSB7XG4gICAgICAgIE9iamVjdC5hc3NpZ24oc2hhZGVyQXR0cmlidXRlcywgYXR0cmlidXRlc1thdHRyaWJ1dGVOYW1lXS5nZXRTaGFkZXJBdHRyaWJ1dGVzKCkpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBzaGFkZXJBdHRyaWJ1dGVzO1xuICB9XG5cbiAgX2FkZChhdHRyaWJ1dGVzLCBleHRyYVByb3BzID0ge30pIHtcbiAgICBmb3IgKGNvbnN0IGF0dHJpYnV0ZU5hbWUgaW4gYXR0cmlidXRlcykge1xuICAgICAgY29uc3QgYXR0cmlidXRlID0gYXR0cmlidXRlc1thdHRyaWJ1dGVOYW1lXTtcbiAgICAgIHRoaXMuYXR0cmlidXRlc1thdHRyaWJ1dGVOYW1lXSA9IHRoaXMuX2NyZWF0ZUF0dHJpYnV0ZShhdHRyaWJ1dGVOYW1lLCBhdHRyaWJ1dGUsIGV4dHJhUHJvcHMpO1xuICAgIH1cblxuICAgIHRoaXMuX21hcFVwZGF0ZVRyaWdnZXJzVG9BdHRyaWJ1dGVzKCk7XG4gIH1cblxuICBfY3JlYXRlQXR0cmlidXRlKG5hbWUsIGF0dHJpYnV0ZSwgZXh0cmFQcm9wcykge1xuICAgIGNvbnN0IHByb3BzID0geyAuLi5hdHRyaWJ1dGUsXG4gICAgICBpZDogbmFtZSxcbiAgICAgIHNpemU6IGF0dHJpYnV0ZS5pc0luZGV4ZWQgJiYgMSB8fCBhdHRyaWJ1dGUuc2l6ZSB8fCAxLFxuICAgICAgZGl2aXNvcjogZXh0cmFQcm9wcy5pbnN0YW5jZWQgPyAxIDogYXR0cmlidXRlLmRpdmlzb3IgfHwgMFxuICAgIH07XG4gICAgcmV0dXJuIG5ldyBBdHRyaWJ1dGUodGhpcy5nbCwgcHJvcHMpO1xuICB9XG5cbiAgX21hcFVwZGF0ZVRyaWdnZXJzVG9BdHRyaWJ1dGVzKCkge1xuICAgIGNvbnN0IHRyaWdnZXJzID0ge307XG5cbiAgICBmb3IgKGNvbnN0IGF0dHJpYnV0ZU5hbWUgaW4gdGhpcy5hdHRyaWJ1dGVzKSB7XG4gICAgICBjb25zdCBhdHRyaWJ1dGUgPSB0aGlzLmF0dHJpYnV0ZXNbYXR0cmlidXRlTmFtZV07XG4gICAgICBhdHRyaWJ1dGUuZ2V0VXBkYXRlVHJpZ2dlcnMoKS5mb3JFYWNoKHRyaWdnZXJOYW1lID0+IHtcbiAgICAgICAgaWYgKCF0cmlnZ2Vyc1t0cmlnZ2VyTmFtZV0pIHtcbiAgICAgICAgICB0cmlnZ2Vyc1t0cmlnZ2VyTmFtZV0gPSBbXTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRyaWdnZXJzW3RyaWdnZXJOYW1lXS5wdXNoKGF0dHJpYnV0ZU5hbWUpO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgdGhpcy51cGRhdGVUcmlnZ2VycyA9IHRyaWdnZXJzO1xuICB9XG5cbiAgX2ludmFsaWRhdGVUcmlnZ2VyKHRyaWdnZXJOYW1lLCBkYXRhUmFuZ2UpIHtcbiAgICBjb25zdCB7XG4gICAgICBhdHRyaWJ1dGVzLFxuICAgICAgdXBkYXRlVHJpZ2dlcnNcbiAgICB9ID0gdGhpcztcbiAgICBjb25zdCBpbnZhbGlkYXRlZEF0dHJpYnV0ZXMgPSB1cGRhdGVUcmlnZ2Vyc1t0cmlnZ2VyTmFtZV07XG5cbiAgICBpZiAoaW52YWxpZGF0ZWRBdHRyaWJ1dGVzKSB7XG4gICAgICBpbnZhbGlkYXRlZEF0dHJpYnV0ZXMuZm9yRWFjaChuYW1lID0+IHtcbiAgICAgICAgY29uc3QgYXR0cmlidXRlID0gYXR0cmlidXRlc1tuYW1lXTtcblxuICAgICAgICBpZiAoYXR0cmlidXRlKSB7XG4gICAgICAgICAgYXR0cmlidXRlLnNldE5lZWRzVXBkYXRlKGF0dHJpYnV0ZS5pZCwgZGF0YVJhbmdlKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGludmFsaWRhdGVkQXR0cmlidXRlcztcbiAgfVxuXG4gIF91cGRhdGVBdHRyaWJ1dGUob3B0cykge1xuICAgIGNvbnN0IHtcbiAgICAgIGF0dHJpYnV0ZSxcbiAgICAgIG51bUluc3RhbmNlc1xuICAgIH0gPSBvcHRzO1xuICAgIGRlYnVnKFRSQUNFX0FUVFJJQlVURV9VUERBVEVfU1RBUlQsIGF0dHJpYnV0ZSk7XG5cbiAgICBpZiAoYXR0cmlidXRlLmNvbnN0YW50KSB7XG4gICAgICBhdHRyaWJ1dGUuc2V0Q29uc3RhbnRWYWx1ZShhdHRyaWJ1dGUudmFsdWUpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChhdHRyaWJ1dGUuYWxsb2NhdGUobnVtSW5zdGFuY2VzKSkge1xuICAgICAgZGVidWcoVFJBQ0VfQVRUUklCVVRFX0FMTE9DQVRFLCBhdHRyaWJ1dGUsIG51bUluc3RhbmNlcyk7XG4gICAgfVxuXG4gICAgY29uc3QgdXBkYXRlZCA9IGF0dHJpYnV0ZS51cGRhdGVCdWZmZXIob3B0cyk7XG5cbiAgICBpZiAodXBkYXRlZCkge1xuICAgICAgdGhpcy5uZWVkc1JlZHJhdyA9IHRydWU7XG4gICAgICBkZWJ1ZyhUUkFDRV9BVFRSSUJVVEVfVVBEQVRFX0VORCwgYXR0cmlidXRlLCBudW1JbnN0YW5jZXMpO1xuICAgIH1cbiAgfVxuXG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1hdHRyaWJ1dGUtbWFuYWdlci5qcy5tYXAiLCJpbXBvcnQgX2RlZmluZVByb3BlcnR5IGZyb20gXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9kZWZpbmVQcm9wZXJ0eVwiO1xuaW1wb3J0IENvbXBvbmVudFN0YXRlIGZyb20gJy4uL2xpZmVjeWNsZS9jb21wb25lbnQtc3RhdGUnO1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgTGF5ZXJTdGF0ZSBleHRlbmRzIENvbXBvbmVudFN0YXRlIHtcbiAgY29uc3RydWN0b3Ioe1xuICAgIGF0dHJpYnV0ZU1hbmFnZXIsXG4gICAgbGF5ZXJcbiAgfSkge1xuICAgIHN1cGVyKGxheWVyKTtcblxuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImF0dHJpYnV0ZU1hbmFnZXJcIiwgdm9pZCAwKTtcblxuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIm5lZWRzUmVkcmF3XCIsIHZvaWQgMCk7XG5cbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJuZWVkc1VwZGF0ZVwiLCB2b2lkIDApO1xuXG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwic3ViTGF5ZXJzXCIsIHZvaWQgMCk7XG5cbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJ1c2VzUGlja2luZ0NvbG9yQ2FjaGVcIiwgdm9pZCAwKTtcblxuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImhhc1BpY2tpbmdCdWZmZXJcIiwgdm9pZCAwKTtcblxuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImNoYW5nZUZsYWdzXCIsIHZvaWQgMCk7XG5cbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJ2aWV3cG9ydFwiLCB2b2lkIDApO1xuXG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwidW5pZm9ybVRyYW5zaXRpb25zXCIsIHZvaWQgMCk7XG5cbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJwcm9wc0luVHJhbnNpdGlvblwiLCB2b2lkIDApO1xuXG4gICAgdGhpcy5hdHRyaWJ1dGVNYW5hZ2VyID0gYXR0cmlidXRlTWFuYWdlcjtcbiAgICB0aGlzLm5lZWRzUmVkcmF3ID0gdHJ1ZTtcbiAgICB0aGlzLm5lZWRzVXBkYXRlID0gdHJ1ZTtcbiAgICB0aGlzLnN1YkxheWVycyA9IG51bGw7XG4gICAgdGhpcy51c2VzUGlja2luZ0NvbG9yQ2FjaGUgPSBmYWxzZTtcbiAgfVxuXG4gIGdldCBsYXllcigpIHtcbiAgICByZXR1cm4gdGhpcy5jb21wb25lbnQ7XG4gIH1cblxuICBfZmV0Y2gocHJvcE5hbWUsIHVybCkge1xuICAgIGNvbnN0IGxheWVyID0gdGhpcy5sYXllcjtcbiAgICBjb25zdCBmZXRjaCA9IGxheWVyID09PSBudWxsIHx8IGxheWVyID09PSB2b2lkIDAgPyB2b2lkIDAgOiBsYXllci5wcm9wcy5mZXRjaDtcblxuICAgIGlmIChmZXRjaCkge1xuICAgICAgcmV0dXJuIGZldGNoKHVybCwge1xuICAgICAgICBwcm9wTmFtZSxcbiAgICAgICAgbGF5ZXJcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHJldHVybiBzdXBlci5fZmV0Y2gocHJvcE5hbWUsIHVybCk7XG4gIH1cblxuICBfb25SZXNvbHZlKHByb3BOYW1lLCB2YWx1ZSkge1xuICAgIGNvbnN0IGxheWVyID0gdGhpcy5sYXllcjtcblxuICAgIGlmIChsYXllcikge1xuICAgICAgY29uc3Qgb25EYXRhTG9hZCA9IGxheWVyLnByb3BzLm9uRGF0YUxvYWQ7XG5cbiAgICAgIGlmIChwcm9wTmFtZSA9PT0gJ2RhdGEnICYmIG9uRGF0YUxvYWQpIHtcbiAgICAgICAgb25EYXRhTG9hZCh2YWx1ZSwge1xuICAgICAgICAgIHByb3BOYW1lLFxuICAgICAgICAgIGxheWVyXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIF9vbkVycm9yKHByb3BOYW1lLCBlcnJvcikge1xuICAgIGNvbnN0IGxheWVyID0gdGhpcy5sYXllcjtcblxuICAgIGlmIChsYXllcikge1xuICAgICAgbGF5ZXIucmFpc2VFcnJvcihlcnJvciwgXCJsb2FkaW5nIFwiLmNvbmNhdChwcm9wTmFtZSwgXCIgb2YgXCIpLmNvbmNhdCh0aGlzLmxheWVyKSk7XG4gICAgfVxuICB9XG5cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWxheWVyLXN0YXRlLmpzLm1hcCIsImltcG9ydCBfZGVmaW5lUHJvcGVydHkgZnJvbSBcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL2RlZmluZVByb3BlcnR5XCI7XG5pbXBvcnQgeyBDT09SRElOQVRFX1NZU1RFTSB9IGZyb20gJy4vY29uc3RhbnRzJztcbmltcG9ydCBBdHRyaWJ1dGVNYW5hZ2VyIGZyb20gJy4vYXR0cmlidXRlL2F0dHJpYnV0ZS1tYW5hZ2VyJztcbmltcG9ydCBVbmlmb3JtVHJhbnNpdGlvbk1hbmFnZXIgZnJvbSAnLi91bmlmb3JtLXRyYW5zaXRpb24tbWFuYWdlcic7XG5pbXBvcnQgeyBkaWZmUHJvcHMsIHZhbGlkYXRlUHJvcHMgfSBmcm9tICcuLi9saWZlY3ljbGUvcHJvcHMnO1xuaW1wb3J0IHsgTElGRUNZQ0xFIH0gZnJvbSAnLi4vbGlmZWN5Y2xlL2NvbnN0YW50cyc7XG5pbXBvcnQgeyBjb3VudCB9IGZyb20gJy4uL3V0aWxzL2NvdW50JztcbmltcG9ydCBsb2cgZnJvbSAnLi4vdXRpbHMvbG9nJztcbmltcG9ydCBkZWJ1ZyBmcm9tICcuLi9kZWJ1Zyc7XG5pbXBvcnQgeyB3aXRoUGFyYW1ldGVycywgc2V0UGFyYW1ldGVycyB9IGZyb20gJ0BsdW1hLmdsL2NvcmUnO1xuaW1wb3J0IGFzc2VydCBmcm9tICcuLi91dGlscy9hc3NlcnQnO1xuaW1wb3J0IG1lbW9pemUgZnJvbSAnLi4vdXRpbHMvbWVtb2l6ZSc7XG5pbXBvcnQgeyBtZXJnZVNoYWRlcnMgfSBmcm9tICcuLi91dGlscy9zaGFkZXInO1xuaW1wb3J0IHsgcHJvamVjdFBvc2l0aW9uLCBnZXRXb3JsZFBvc2l0aW9uIH0gZnJvbSAnLi4vc2hhZGVybGliL3Byb2plY3QvcHJvamVjdC1mdW5jdGlvbnMnO1xuaW1wb3J0IHR5cGVkQXJyYXlNYW5hZ2VyIGZyb20gJy4uL3V0aWxzL3R5cGVkLWFycmF5LW1hbmFnZXInO1xuaW1wb3J0IENvbXBvbmVudCBmcm9tICcuLi9saWZlY3ljbGUvY29tcG9uZW50JztcbmltcG9ydCBMYXllclN0YXRlIGZyb20gJy4vbGF5ZXItc3RhdGUnO1xuaW1wb3J0IHsgd29ybGRUb1BpeGVscyB9IGZyb20gJ0BtYXRoLmdsL3dlYi1tZXJjYXRvcic7XG5pbXBvcnQgeyBsb2FkIH0gZnJvbSAnQGxvYWRlcnMuZ2wvY29yZSc7XG5jb25zdCBUUkFDRV9DSEFOR0VfRkxBRyA9ICdsYXllci5jaGFuZ2VGbGFnJztcbmNvbnN0IFRSQUNFX0lOSVRJQUxJWkUgPSAnbGF5ZXIuaW5pdGlhbGl6ZSc7XG5jb25zdCBUUkFDRV9VUERBVEUgPSAnbGF5ZXIudXBkYXRlJztcbmNvbnN0IFRSQUNFX0ZJTkFMSVpFID0gJ2xheWVyLmZpbmFsaXplJztcbmNvbnN0IFRSQUNFX01BVENIRUQgPSAnbGF5ZXIubWF0Y2hlZCc7XG5jb25zdCBNQVhfUElDS0lOR19DT0xPUl9DQUNIRV9TSVpFID0gMiAqKiAyNCAtIDE7XG5jb25zdCBFTVBUWV9BUlJBWSA9IE9iamVjdC5mcmVlemUoW10pO1xuY29uc3QgYXJlVmlld3BvcnRzRXF1YWwgPSBtZW1vaXplKCh7XG4gIG9sZFZpZXdwb3J0LFxuICB2aWV3cG9ydFxufSkgPT4ge1xuICByZXR1cm4gb2xkVmlld3BvcnQuZXF1YWxzKHZpZXdwb3J0KTtcbn0pO1xubGV0IHBpY2tpbmdDb2xvckNhY2hlID0gbmV3IFVpbnQ4Q2xhbXBlZEFycmF5KDApO1xuY29uc3QgZGVmYXVsdFByb3BzID0ge1xuICBkYXRhOiB7XG4gICAgdHlwZTogJ2RhdGEnLFxuICAgIHZhbHVlOiBFTVBUWV9BUlJBWSxcbiAgICBhc3luYzogdHJ1ZVxuICB9LFxuICBkYXRhQ29tcGFyYXRvcjoge1xuICAgIHR5cGU6ICdmdW5jdGlvbicsXG4gICAgdmFsdWU6IG51bGwsXG4gICAgb3B0aW9uYWw6IHRydWVcbiAgfSxcbiAgX2RhdGFEaWZmOiB7XG4gICAgdHlwZTogJ2Z1bmN0aW9uJyxcbiAgICB2YWx1ZTogZGF0YSA9PiBkYXRhICYmIGRhdGEuX19kaWZmLFxuICAgIG9wdGlvbmFsOiB0cnVlXG4gIH0sXG4gIGRhdGFUcmFuc2Zvcm06IHtcbiAgICB0eXBlOiAnZnVuY3Rpb24nLFxuICAgIHZhbHVlOiBudWxsLFxuICAgIG9wdGlvbmFsOiB0cnVlXG4gIH0sXG4gIG9uRGF0YUxvYWQ6IHtcbiAgICB0eXBlOiAnZnVuY3Rpb24nLFxuICAgIHZhbHVlOiBudWxsLFxuICAgIG9wdGlvbmFsOiB0cnVlXG4gIH0sXG4gIG9uRXJyb3I6IHtcbiAgICB0eXBlOiAnZnVuY3Rpb24nLFxuICAgIHZhbHVlOiBudWxsLFxuICAgIG9wdGlvbmFsOiB0cnVlXG4gIH0sXG4gIGZldGNoOiB7XG4gICAgdHlwZTogJ2Z1bmN0aW9uJyxcbiAgICB2YWx1ZTogKHVybCwge1xuICAgICAgcHJvcE5hbWUsXG4gICAgICBsYXllcixcbiAgICAgIGxvYWRlcnMsXG4gICAgICBsb2FkT3B0aW9ucyxcbiAgICAgIHNpZ25hbFxuICAgIH0pID0+IHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgcmVzb3VyY2VNYW5hZ2VyXG4gICAgICB9ID0gbGF5ZXIuY29udGV4dDtcbiAgICAgIGxvYWRPcHRpb25zID0gbG9hZE9wdGlvbnMgfHwgbGF5ZXIuZ2V0TG9hZE9wdGlvbnMoKTtcbiAgICAgIGxvYWRlcnMgPSBsb2FkZXJzIHx8IGxheWVyLnByb3BzLmxvYWRlcnM7XG5cbiAgICAgIGlmIChzaWduYWwpIHtcbiAgICAgICAgdmFyIF9sb2FkT3B0aW9ucztcblxuICAgICAgICBsb2FkT3B0aW9ucyA9IHsgLi4ubG9hZE9wdGlvbnMsXG4gICAgICAgICAgZmV0Y2g6IHsgLi4uKChfbG9hZE9wdGlvbnMgPSBsb2FkT3B0aW9ucykgPT09IG51bGwgfHwgX2xvYWRPcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfbG9hZE9wdGlvbnMuZmV0Y2gpLFxuICAgICAgICAgICAgc2lnbmFsXG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgICBsZXQgaW5SZXNvdXJjZU1hbmFnZXIgPSByZXNvdXJjZU1hbmFnZXIuY29udGFpbnModXJsKTtcblxuICAgICAgaWYgKCFpblJlc291cmNlTWFuYWdlciAmJiAhbG9hZE9wdGlvbnMpIHtcbiAgICAgICAgcmVzb3VyY2VNYW5hZ2VyLmFkZCh7XG4gICAgICAgICAgcmVzb3VyY2VJZDogdXJsLFxuICAgICAgICAgIGRhdGE6IGxvYWQodXJsLCBsb2FkZXJzKSxcbiAgICAgICAgICBwZXJzaXN0ZW50OiBmYWxzZVxuICAgICAgICB9KTtcbiAgICAgICAgaW5SZXNvdXJjZU1hbmFnZXIgPSB0cnVlO1xuICAgICAgfVxuXG4gICAgICBpZiAoaW5SZXNvdXJjZU1hbmFnZXIpIHtcbiAgICAgICAgcmV0dXJuIHJlc291cmNlTWFuYWdlci5zdWJzY3JpYmUoe1xuICAgICAgICAgIHJlc291cmNlSWQ6IHVybCxcbiAgICAgICAgICBvbkNoYW5nZTogZGF0YSA9PiB7XG4gICAgICAgICAgICB2YXIgX2xheWVyJGludGVybmFsU3RhdGU7XG5cbiAgICAgICAgICAgIHJldHVybiAoX2xheWVyJGludGVybmFsU3RhdGUgPSBsYXllci5pbnRlcm5hbFN0YXRlKSA9PT0gbnVsbCB8fCBfbGF5ZXIkaW50ZXJuYWxTdGF0ZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2xheWVyJGludGVybmFsU3RhdGUucmVsb2FkQXN5bmNQcm9wKHByb3BOYW1lLCBkYXRhKTtcbiAgICAgICAgICB9LFxuICAgICAgICAgIGNvbnN1bWVySWQ6IGxheWVyLmlkLFxuICAgICAgICAgIHJlcXVlc3RJZDogcHJvcE5hbWVcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBsb2FkKHVybCwgbG9hZGVycywgbG9hZE9wdGlvbnMpO1xuICAgIH1cbiAgfSxcbiAgdXBkYXRlVHJpZ2dlcnM6IHt9LFxuICB2aXNpYmxlOiB0cnVlLFxuICBwaWNrYWJsZTogZmFsc2UsXG4gIG9wYWNpdHk6IHtcbiAgICB0eXBlOiAnbnVtYmVyJyxcbiAgICBtaW46IDAsXG4gICAgbWF4OiAxLFxuICAgIHZhbHVlOiAxXG4gIH0sXG4gIG9wZXJhdGlvbjogJ2RyYXcnLFxuICBvbkhvdmVyOiB7XG4gICAgdHlwZTogJ2Z1bmN0aW9uJyxcbiAgICB2YWx1ZTogbnVsbCxcbiAgICBvcHRpb25hbDogdHJ1ZVxuICB9LFxuICBvbkNsaWNrOiB7XG4gICAgdHlwZTogJ2Z1bmN0aW9uJyxcbiAgICB2YWx1ZTogbnVsbCxcbiAgICBvcHRpb25hbDogdHJ1ZVxuICB9LFxuICBvbkRyYWdTdGFydDoge1xuICAgIHR5cGU6ICdmdW5jdGlvbicsXG4gICAgdmFsdWU6IG51bGwsXG4gICAgb3B0aW9uYWw6IHRydWVcbiAgfSxcbiAgb25EcmFnOiB7XG4gICAgdHlwZTogJ2Z1bmN0aW9uJyxcbiAgICB2YWx1ZTogbnVsbCxcbiAgICBvcHRpb25hbDogdHJ1ZVxuICB9LFxuICBvbkRyYWdFbmQ6IHtcbiAgICB0eXBlOiAnZnVuY3Rpb24nLFxuICAgIHZhbHVlOiBudWxsLFxuICAgIG9wdGlvbmFsOiB0cnVlXG4gIH0sXG4gIGNvb3JkaW5hdGVTeXN0ZW06IENPT1JESU5BVEVfU1lTVEVNLkRFRkFVTFQsXG4gIGNvb3JkaW5hdGVPcmlnaW46IHtcbiAgICB0eXBlOiAnYXJyYXknLFxuICAgIHZhbHVlOiBbMCwgMCwgMF0sXG4gICAgY29tcGFyZTogdHJ1ZVxuICB9LFxuICBtb2RlbE1hdHJpeDoge1xuICAgIHR5cGU6ICdhcnJheScsXG4gICAgdmFsdWU6IG51bGwsXG4gICAgY29tcGFyZTogdHJ1ZSxcbiAgICBvcHRpb25hbDogdHJ1ZVxuICB9LFxuICB3cmFwTG9uZ2l0dWRlOiBmYWxzZSxcbiAgcG9zaXRpb25Gb3JtYXQ6ICdYWVonLFxuICBjb2xvckZvcm1hdDogJ1JHQkEnLFxuICBwYXJhbWV0ZXJzOiB7XG4gICAgdHlwZTogJ29iamVjdCcsXG4gICAgdmFsdWU6IHt9LFxuICAgIG9wdGlvbmFsOiB0cnVlLFxuICAgIGNvbXBhcmU6IDJcbiAgfSxcbiAgbG9hZE9wdGlvbnM6IHtcbiAgICB0eXBlOiAnb2JqZWN0JyxcbiAgICB2YWx1ZTogbnVsbCxcbiAgICBvcHRpb25hbDogdHJ1ZSxcbiAgICBpZ25vcmU6IHRydWVcbiAgfSxcbiAgdHJhbnNpdGlvbnM6IG51bGwsXG4gIGV4dGVuc2lvbnM6IFtdLFxuICBsb2FkZXJzOiB7XG4gICAgdHlwZTogJ2FycmF5JyxcbiAgICB2YWx1ZTogW10sXG4gICAgb3B0aW9uYWw6IHRydWUsXG4gICAgaWdub3JlOiB0cnVlXG4gIH0sXG4gIGdldFBvbHlnb25PZmZzZXQ6IHtcbiAgICB0eXBlOiAnZnVuY3Rpb24nLFxuICAgIHZhbHVlOiAoe1xuICAgICAgbGF5ZXJJbmRleFxuICAgIH0pID0+IFswLCAtbGF5ZXJJbmRleCAqIDEwMF1cbiAgfSxcbiAgaGlnaGxpZ2h0ZWRPYmplY3RJbmRleDogbnVsbCxcbiAgYXV0b0hpZ2hsaWdodDogZmFsc2UsXG4gIGhpZ2hsaWdodENvbG9yOiB7XG4gICAgdHlwZTogJ2FjY2Vzc29yJyxcbiAgICB2YWx1ZTogWzAsIDAsIDEyOCwgMTI4XVxuICB9XG59O1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgTGF5ZXIgZXh0ZW5kcyBDb21wb25lbnQge1xuICBjb25zdHJ1Y3RvciguLi5hcmdzKSB7XG4gICAgc3VwZXIoLi4uYXJncyk7XG5cbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJpbnRlcm5hbFN0YXRlXCIsIG51bGwpO1xuXG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwibGlmZWN5Y2xlXCIsIExJRkVDWUNMRS5OT19TVEFURSk7XG5cbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJjb250ZXh0XCIsIHZvaWQgMCk7XG5cbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJzdGF0ZVwiLCB2b2lkIDApO1xuXG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwicGFyZW50XCIsIG51bGwpO1xuICB9XG5cbiAgZ2V0IHJvb3QoKSB7XG4gICAgbGV0IGxheWVyID0gdGhpcztcblxuICAgIHdoaWxlIChsYXllci5wYXJlbnQpIHtcbiAgICAgIGxheWVyID0gbGF5ZXIucGFyZW50O1xuICAgIH1cblxuICAgIHJldHVybiBsYXllcjtcbiAgfVxuXG4gIHRvU3RyaW5nKCkge1xuICAgIGNvbnN0IGNsYXNzTmFtZSA9IHRoaXMuY29uc3RydWN0b3IubGF5ZXJOYW1lIHx8IHRoaXMuY29uc3RydWN0b3IubmFtZTtcbiAgICByZXR1cm4gXCJcIi5jb25jYXQoY2xhc3NOYW1lLCBcIih7aWQ6ICdcIikuY29uY2F0KHRoaXMucHJvcHMuaWQsIFwiJ30pXCIpO1xuICB9XG5cbiAgcHJvamVjdCh4eXopIHtcbiAgICBhc3NlcnQodGhpcy5pbnRlcm5hbFN0YXRlKTtcbiAgICBjb25zdCB2aWV3cG9ydCA9IHRoaXMuaW50ZXJuYWxTdGF0ZS52aWV3cG9ydCB8fCB0aGlzLmNvbnRleHQudmlld3BvcnQ7XG4gICAgY29uc3Qgd29ybGRQb3NpdGlvbiA9IGdldFdvcmxkUG9zaXRpb24oeHl6LCB7XG4gICAgICB2aWV3cG9ydCxcbiAgICAgIG1vZGVsTWF0cml4OiB0aGlzLnByb3BzLm1vZGVsTWF0cml4LFxuICAgICAgY29vcmRpbmF0ZU9yaWdpbjogdGhpcy5wcm9wcy5jb29yZGluYXRlT3JpZ2luLFxuICAgICAgY29vcmRpbmF0ZVN5c3RlbTogdGhpcy5wcm9wcy5jb29yZGluYXRlU3lzdGVtXG4gICAgfSk7XG4gICAgY29uc3QgW3gsIHksIHpdID0gd29ybGRUb1BpeGVscyh3b3JsZFBvc2l0aW9uLCB2aWV3cG9ydC5waXhlbFByb2plY3Rpb25NYXRyaXgpO1xuICAgIHJldHVybiB4eXoubGVuZ3RoID09PSAyID8gW3gsIHldIDogW3gsIHksIHpdO1xuICB9XG5cbiAgdW5wcm9qZWN0KHh5KSB7XG4gICAgYXNzZXJ0KHRoaXMuaW50ZXJuYWxTdGF0ZSk7XG4gICAgY29uc3Qgdmlld3BvcnQgPSB0aGlzLmludGVybmFsU3RhdGUudmlld3BvcnQgfHwgdGhpcy5jb250ZXh0LnZpZXdwb3J0O1xuICAgIHJldHVybiB2aWV3cG9ydC51bnByb2plY3QoeHkpO1xuICB9XG5cbiAgcHJvamVjdFBvc2l0aW9uKHh5eiwgcGFyYW1zKSB7XG4gICAgYXNzZXJ0KHRoaXMuaW50ZXJuYWxTdGF0ZSk7XG4gICAgY29uc3Qgdmlld3BvcnQgPSB0aGlzLmludGVybmFsU3RhdGUudmlld3BvcnQgfHwgdGhpcy5jb250ZXh0LnZpZXdwb3J0O1xuICAgIHJldHVybiBwcm9qZWN0UG9zaXRpb24oeHl6LCB7XG4gICAgICB2aWV3cG9ydCxcbiAgICAgIG1vZGVsTWF0cml4OiB0aGlzLnByb3BzLm1vZGVsTWF0cml4LFxuICAgICAgY29vcmRpbmF0ZU9yaWdpbjogdGhpcy5wcm9wcy5jb29yZGluYXRlT3JpZ2luLFxuICAgICAgY29vcmRpbmF0ZVN5c3RlbTogdGhpcy5wcm9wcy5jb29yZGluYXRlU3lzdGVtLFxuICAgICAgLi4ucGFyYW1zXG4gICAgfSk7XG4gIH1cblxuICBnZXQgaXNDb21wb3NpdGUoKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgc2V0U3RhdGUocGFydGlhbFN0YXRlKSB7XG4gICAgdGhpcy5zZXRDaGFuZ2VGbGFncyh7XG4gICAgICBzdGF0ZUNoYW5nZWQ6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuYXNzaWduKHRoaXMuc3RhdGUsIHBhcnRpYWxTdGF0ZSk7XG4gICAgdGhpcy5zZXROZWVkc1JlZHJhdygpO1xuICB9XG5cbiAgc2V0TmVlZHNSZWRyYXcoKSB7XG4gICAgaWYgKHRoaXMuaW50ZXJuYWxTdGF0ZSkge1xuICAgICAgdGhpcy5pbnRlcm5hbFN0YXRlLm5lZWRzUmVkcmF3ID0gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICBzZXROZWVkc1VwZGF0ZSgpIHtcbiAgICBpZiAodGhpcy5pbnRlcm5hbFN0YXRlKSB7XG4gICAgICB0aGlzLmNvbnRleHQubGF5ZXJNYW5hZ2VyLnNldE5lZWRzVXBkYXRlKFN0cmluZyh0aGlzKSk7XG4gICAgICB0aGlzLmludGVybmFsU3RhdGUubmVlZHNVcGRhdGUgPSB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIGdldCBpc0xvYWRlZCgpIHtcbiAgICByZXR1cm4gdGhpcy5pbnRlcm5hbFN0YXRlID8gIXRoaXMuaW50ZXJuYWxTdGF0ZS5pc0FzeW5jUHJvcExvYWRpbmcoKSA6IGZhbHNlO1xuICB9XG5cbiAgZ2V0IHdyYXBMb25naXR1ZGUoKSB7XG4gICAgcmV0dXJuIHRoaXMucHJvcHMud3JhcExvbmdpdHVkZTtcbiAgfVxuXG4gIGlzUGlja2FibGUoKSB7XG4gICAgcmV0dXJuIHRoaXMucHJvcHMucGlja2FibGUgJiYgdGhpcy5wcm9wcy52aXNpYmxlO1xuICB9XG5cbiAgZ2V0TW9kZWxzKCkge1xuICAgIHJldHVybiB0aGlzLnN0YXRlICYmICh0aGlzLnN0YXRlLm1vZGVscyB8fCB0aGlzLnN0YXRlLm1vZGVsICYmIFt0aGlzLnN0YXRlLm1vZGVsXSkgfHwgW107XG4gIH1cblxuICBzZXRNb2R1bGVQYXJhbWV0ZXJzKG1vZHVsZVBhcmFtZXRlcnMpIHtcbiAgICBmb3IgKGNvbnN0IG1vZGVsIG9mIHRoaXMuZ2V0TW9kZWxzKCkpIHtcbiAgICAgIG1vZGVsLnVwZGF0ZU1vZHVsZVNldHRpbmdzKG1vZHVsZVBhcmFtZXRlcnMpO1xuICAgIH1cbiAgfVxuXG4gIGdldEF0dHJpYnV0ZU1hbmFnZXIoKSB7XG4gICAgcmV0dXJuIHRoaXMuaW50ZXJuYWxTdGF0ZSAmJiB0aGlzLmludGVybmFsU3RhdGUuYXR0cmlidXRlTWFuYWdlcjtcbiAgfVxuXG4gIGdldEN1cnJlbnRMYXllcigpIHtcbiAgICByZXR1cm4gdGhpcy5pbnRlcm5hbFN0YXRlICYmIHRoaXMuaW50ZXJuYWxTdGF0ZS5sYXllcjtcbiAgfVxuXG4gIGdldExvYWRPcHRpb25zKCkge1xuICAgIHJldHVybiB0aGlzLnByb3BzLmxvYWRPcHRpb25zO1xuICB9XG5cbiAgdXNlNjRiaXRQb3NpdGlvbnMoKSB7XG4gICAgY29uc3Qge1xuICAgICAgY29vcmRpbmF0ZVN5c3RlbVxuICAgIH0gPSB0aGlzLnByb3BzO1xuICAgIHJldHVybiBjb29yZGluYXRlU3lzdGVtID09PSBDT09SRElOQVRFX1NZU1RFTS5ERUZBVUxUIHx8IGNvb3JkaW5hdGVTeXN0ZW0gPT09IENPT1JESU5BVEVfU1lTVEVNLkxOR0xBVCB8fCBjb29yZGluYXRlU3lzdGVtID09PSBDT09SRElOQVRFX1NZU1RFTS5DQVJURVNJQU47XG4gIH1cblxuICBvbkhvdmVyKGluZm8sIHBpY2tpbmdFdmVudCkge1xuICAgIGlmICh0aGlzLnByb3BzLm9uSG92ZXIpIHtcbiAgICAgIHJldHVybiB0aGlzLnByb3BzLm9uSG92ZXIoaW5mbywgcGlja2luZ0V2ZW50KSB8fCBmYWxzZTtcbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBvbkNsaWNrKGluZm8sIHBpY2tpbmdFdmVudCkge1xuICAgIGlmICh0aGlzLnByb3BzLm9uQ2xpY2spIHtcbiAgICAgIHJldHVybiB0aGlzLnByb3BzLm9uQ2xpY2soaW5mbywgcGlja2luZ0V2ZW50KSB8fCBmYWxzZTtcbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBudWxsUGlja2luZ0NvbG9yKCkge1xuICAgIHJldHVybiBbMCwgMCwgMF07XG4gIH1cblxuICBlbmNvZGVQaWNraW5nQ29sb3IoaSwgdGFyZ2V0ID0gW10pIHtcbiAgICB0YXJnZXRbMF0gPSBpICsgMSAmIDI1NTtcbiAgICB0YXJnZXRbMV0gPSBpICsgMSA+PiA4ICYgMjU1O1xuICAgIHRhcmdldFsyXSA9IGkgKyAxID4+IDggPj4gOCAmIDI1NTtcbiAgICByZXR1cm4gdGFyZ2V0O1xuICB9XG5cbiAgZGVjb2RlUGlja2luZ0NvbG9yKGNvbG9yKSB7XG4gICAgYXNzZXJ0KGNvbG9yIGluc3RhbmNlb2YgVWludDhBcnJheSk7XG4gICAgY29uc3QgW2kxLCBpMiwgaTNdID0gY29sb3I7XG4gICAgY29uc3QgaW5kZXggPSBpMSArIGkyICogMjU2ICsgaTMgKiA2NTUzNiAtIDE7XG4gICAgcmV0dXJuIGluZGV4O1xuICB9XG5cbiAgZ2V0TnVtSW5zdGFuY2VzKCkge1xuICAgIGlmIChOdW1iZXIuaXNGaW5pdGUodGhpcy5wcm9wcy5udW1JbnN0YW5jZXMpKSB7XG4gICAgICByZXR1cm4gdGhpcy5wcm9wcy5udW1JbnN0YW5jZXM7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuc3RhdGUgJiYgdGhpcy5zdGF0ZS5udW1JbnN0YW5jZXMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIHRoaXMuc3RhdGUubnVtSW5zdGFuY2VzO1xuICAgIH1cblxuICAgIHJldHVybiBjb3VudCh0aGlzLnByb3BzLmRhdGEpO1xuICB9XG5cbiAgZ2V0U3RhcnRJbmRpY2VzKCkge1xuICAgIGlmICh0aGlzLnByb3BzLnN0YXJ0SW5kaWNlcykge1xuICAgICAgcmV0dXJuIHRoaXMucHJvcHMuc3RhcnRJbmRpY2VzO1xuICAgIH1cblxuICAgIGlmICh0aGlzLnN0YXRlICYmIHRoaXMuc3RhdGUuc3RhcnRJbmRpY2VzKSB7XG4gICAgICByZXR1cm4gdGhpcy5zdGF0ZS5zdGFydEluZGljZXM7XG4gICAgfVxuXG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBnZXRCb3VuZHMoKSB7XG4gICAgdmFyIF90aGlzJGdldEF0dHJpYnV0ZU1hbjtcblxuICAgIHJldHVybiAoX3RoaXMkZ2V0QXR0cmlidXRlTWFuID0gdGhpcy5nZXRBdHRyaWJ1dGVNYW5hZ2VyKCkpID09PSBudWxsIHx8IF90aGlzJGdldEF0dHJpYnV0ZU1hbiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX3RoaXMkZ2V0QXR0cmlidXRlTWFuLmdldEJvdW5kcyhbJ3Bvc2l0aW9ucycsICdpbnN0YW5jZVBvc2l0aW9ucyddKTtcbiAgfVxuXG4gIGdldFNoYWRlcnMoc2hhZGVycykge1xuICAgIGZvciAoY29uc3QgZXh0ZW5zaW9uIG9mIHRoaXMucHJvcHMuZXh0ZW5zaW9ucykge1xuICAgICAgc2hhZGVycyA9IG1lcmdlU2hhZGVycyhzaGFkZXJzLCBleHRlbnNpb24uZ2V0U2hhZGVycy5jYWxsKHRoaXMsIGV4dGVuc2lvbikpO1xuICAgIH1cblxuICAgIHJldHVybiBzaGFkZXJzO1xuICB9XG5cbiAgc2hvdWxkVXBkYXRlU3RhdGUocGFyYW1zKSB7XG4gICAgcmV0dXJuIHBhcmFtcy5jaGFuZ2VGbGFncy5wcm9wc09yRGF0YUNoYW5nZWQ7XG4gIH1cblxuICB1cGRhdGVTdGF0ZShwYXJhbXMpIHtcbiAgICBjb25zdCBhdHRyaWJ1dGVNYW5hZ2VyID0gdGhpcy5nZXRBdHRyaWJ1dGVNYW5hZ2VyKCk7XG4gICAgY29uc3Qge1xuICAgICAgZGF0YUNoYW5nZWRcbiAgICB9ID0gcGFyYW1zLmNoYW5nZUZsYWdzO1xuXG4gICAgaWYgKGRhdGFDaGFuZ2VkICYmIGF0dHJpYnV0ZU1hbmFnZXIpIHtcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KGRhdGFDaGFuZ2VkKSkge1xuICAgICAgICBmb3IgKGNvbnN0IGRhdGFSYW5nZSBvZiBkYXRhQ2hhbmdlZCkge1xuICAgICAgICAgIGF0dHJpYnV0ZU1hbmFnZXIuaW52YWxpZGF0ZUFsbChkYXRhUmFuZ2UpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBhdHRyaWJ1dGVNYW5hZ2VyLmludmFsaWRhdGVBbGwoKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoYXR0cmlidXRlTWFuYWdlcikge1xuICAgICAgY29uc3Qge1xuICAgICAgICBwcm9wc1xuICAgICAgfSA9IHBhcmFtcztcbiAgICAgIGNvbnN0IGhhc1BpY2tpbmdCdWZmZXIgPSB0aGlzLmludGVybmFsU3RhdGUuaGFzUGlja2luZ0J1ZmZlcjtcbiAgICAgIGNvbnN0IG5lZWRzUGlja2luZ0J1ZmZlciA9IE51bWJlci5pc0ludGVnZXIocHJvcHMuaGlnaGxpZ2h0ZWRPYmplY3RJbmRleCkgfHwgcHJvcHMucGlja2FibGUgfHwgcHJvcHMuZXh0ZW5zaW9ucy5zb21lKGV4dGVuc2lvbiA9PiBleHRlbnNpb24uZ2V0TmVlZHNQaWNraW5nQnVmZmVyLmNhbGwodGhpcywgZXh0ZW5zaW9uKSk7XG5cbiAgICAgIGlmIChoYXNQaWNraW5nQnVmZmVyICE9PSBuZWVkc1BpY2tpbmdCdWZmZXIpIHtcbiAgICAgICAgdGhpcy5pbnRlcm5hbFN0YXRlLmhhc1BpY2tpbmdCdWZmZXIgPSBuZWVkc1BpY2tpbmdCdWZmZXI7XG4gICAgICAgIGNvbnN0IHtcbiAgICAgICAgICBwaWNraW5nQ29sb3JzLFxuICAgICAgICAgIGluc3RhbmNlUGlja2luZ0NvbG9yc1xuICAgICAgICB9ID0gYXR0cmlidXRlTWFuYWdlci5hdHRyaWJ1dGVzO1xuICAgICAgICBjb25zdCBwaWNraW5nQ29sb3JzQXR0cmlidXRlID0gcGlja2luZ0NvbG9ycyB8fCBpbnN0YW5jZVBpY2tpbmdDb2xvcnM7XG5cbiAgICAgICAgaWYgKHBpY2tpbmdDb2xvcnNBdHRyaWJ1dGUpIHtcbiAgICAgICAgICBpZiAobmVlZHNQaWNraW5nQnVmZmVyICYmIHBpY2tpbmdDb2xvcnNBdHRyaWJ1dGUuY29uc3RhbnQpIHtcbiAgICAgICAgICAgIHBpY2tpbmdDb2xvcnNBdHRyaWJ1dGUuY29uc3RhbnQgPSBmYWxzZTtcbiAgICAgICAgICAgIGF0dHJpYnV0ZU1hbmFnZXIuaW52YWxpZGF0ZShwaWNraW5nQ29sb3JzQXR0cmlidXRlLmlkKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoIXBpY2tpbmdDb2xvcnNBdHRyaWJ1dGUudmFsdWUgJiYgIW5lZWRzUGlja2luZ0J1ZmZlcikge1xuICAgICAgICAgICAgcGlja2luZ0NvbG9yc0F0dHJpYnV0ZS5jb25zdGFudCA9IHRydWU7XG4gICAgICAgICAgICBwaWNraW5nQ29sb3JzQXR0cmlidXRlLnZhbHVlID0gWzAsIDAsIDBdO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZpbmFsaXplU3RhdGUoY29udGV4dCkge1xuICAgIGZvciAoY29uc3QgbW9kZWwgb2YgdGhpcy5nZXRNb2RlbHMoKSkge1xuICAgICAgbW9kZWwuZGVsZXRlKCk7XG4gICAgfVxuXG4gICAgY29uc3QgYXR0cmlidXRlTWFuYWdlciA9IHRoaXMuZ2V0QXR0cmlidXRlTWFuYWdlcigpO1xuXG4gICAgaWYgKGF0dHJpYnV0ZU1hbmFnZXIpIHtcbiAgICAgIGF0dHJpYnV0ZU1hbmFnZXIuZmluYWxpemUoKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5jb250ZXh0KSB7XG4gICAgICB0aGlzLmNvbnRleHQucmVzb3VyY2VNYW5hZ2VyLnVuc3Vic2NyaWJlKHtcbiAgICAgICAgY29uc3VtZXJJZDogdGhpcy5pZFxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuaW50ZXJuYWxTdGF0ZSkge1xuICAgICAgdGhpcy5pbnRlcm5hbFN0YXRlLnVuaWZvcm1UcmFuc2l0aW9ucy5jbGVhcigpO1xuICAgICAgdGhpcy5pbnRlcm5hbFN0YXRlLmZpbmFsaXplKCk7XG4gICAgfVxuICB9XG5cbiAgZHJhdyhvcHRzKSB7XG4gICAgZm9yIChjb25zdCBtb2RlbCBvZiB0aGlzLmdldE1vZGVscygpKSB7XG4gICAgICBtb2RlbC5kcmF3KG9wdHMpO1xuICAgIH1cbiAgfVxuXG4gIGdldFBpY2tpbmdJbmZvKHtcbiAgICBpbmZvLFxuICAgIG1vZGUsXG4gICAgc291cmNlTGF5ZXJcbiAgfSkge1xuICAgIGNvbnN0IHtcbiAgICAgIGluZGV4XG4gICAgfSA9IGluZm87XG5cbiAgICBpZiAoaW5kZXggPj0gMCkge1xuICAgICAgaWYgKEFycmF5LmlzQXJyYXkodGhpcy5wcm9wcy5kYXRhKSkge1xuICAgICAgICBpbmZvLm9iamVjdCA9IHRoaXMucHJvcHMuZGF0YVtpbmRleF07XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGluZm87XG4gIH1cblxuICByYWlzZUVycm9yKGVycm9yLCBtZXNzYWdlKSB7XG4gICAgdmFyIF90aGlzJHByb3BzJG9uRXJyb3IsIF90aGlzJHByb3BzO1xuXG4gICAgaWYgKG1lc3NhZ2UpIHtcbiAgICAgIGVycm9yLm1lc3NhZ2UgPSBcIlwiLmNvbmNhdChtZXNzYWdlLCBcIjogXCIpLmNvbmNhdChlcnJvci5tZXNzYWdlKTtcbiAgICB9XG5cbiAgICBpZiAoISgoX3RoaXMkcHJvcHMkb25FcnJvciA9IChfdGhpcyRwcm9wcyA9IHRoaXMucHJvcHMpLm9uRXJyb3IpICE9PSBudWxsICYmIF90aGlzJHByb3BzJG9uRXJyb3IgIT09IHZvaWQgMCAmJiBfdGhpcyRwcm9wcyRvbkVycm9yLmNhbGwoX3RoaXMkcHJvcHMsIGVycm9yKSkpIHtcbiAgICAgIHZhciBfdGhpcyRjb250ZXh0LCBfdGhpcyRjb250ZXh0JG9uRXJyb3I7XG5cbiAgICAgIChfdGhpcyRjb250ZXh0ID0gdGhpcy5jb250ZXh0KSA9PT0gbnVsbCB8fCBfdGhpcyRjb250ZXh0ID09PSB2b2lkIDAgPyB2b2lkIDAgOiAoX3RoaXMkY29udGV4dCRvbkVycm9yID0gX3RoaXMkY29udGV4dC5vbkVycm9yKSA9PT0gbnVsbCB8fCBfdGhpcyRjb250ZXh0JG9uRXJyb3IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF90aGlzJGNvbnRleHQkb25FcnJvci5jYWxsKF90aGlzJGNvbnRleHQsIGVycm9yLCB0aGlzKTtcbiAgICB9XG4gIH1cblxuICBnZXROZWVkc1JlZHJhdyhvcHRzID0ge1xuICAgIGNsZWFyUmVkcmF3RmxhZ3M6IGZhbHNlXG4gIH0pIHtcbiAgICByZXR1cm4gdGhpcy5fZ2V0TmVlZHNSZWRyYXcob3B0cyk7XG4gIH1cblxuICBuZWVkc1VwZGF0ZSgpIHtcbiAgICBpZiAoIXRoaXMuaW50ZXJuYWxTdGF0ZSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLmludGVybmFsU3RhdGUubmVlZHNVcGRhdGUgfHwgdGhpcy5oYXNVbmlmb3JtVHJhbnNpdGlvbigpIHx8IHRoaXMuc2hvdWxkVXBkYXRlU3RhdGUodGhpcy5fZ2V0VXBkYXRlUGFyYW1zKCkpO1xuICB9XG5cbiAgaGFzVW5pZm9ybVRyYW5zaXRpb24oKSB7XG4gICAgdmFyIF90aGlzJGludGVybmFsU3RhdGU7XG5cbiAgICByZXR1cm4gKChfdGhpcyRpbnRlcm5hbFN0YXRlID0gdGhpcy5pbnRlcm5hbFN0YXRlKSA9PT0gbnVsbCB8fCBfdGhpcyRpbnRlcm5hbFN0YXRlID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfdGhpcyRpbnRlcm5hbFN0YXRlLnVuaWZvcm1UcmFuc2l0aW9ucy5hY3RpdmUpIHx8IGZhbHNlO1xuICB9XG5cbiAgYWN0aXZhdGVWaWV3cG9ydCh2aWV3cG9ydCkge1xuICAgIGlmICghdGhpcy5pbnRlcm5hbFN0YXRlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3Qgb2xkVmlld3BvcnQgPSB0aGlzLmludGVybmFsU3RhdGUudmlld3BvcnQ7XG4gICAgdGhpcy5pbnRlcm5hbFN0YXRlLnZpZXdwb3J0ID0gdmlld3BvcnQ7XG5cbiAgICBpZiAoIW9sZFZpZXdwb3J0IHx8ICFhcmVWaWV3cG9ydHNFcXVhbCh7XG4gICAgICBvbGRWaWV3cG9ydCxcbiAgICAgIHZpZXdwb3J0XG4gICAgfSkpIHtcbiAgICAgIHRoaXMuc2V0Q2hhbmdlRmxhZ3Moe1xuICAgICAgICB2aWV3cG9ydENoYW5nZWQ6IHRydWVcbiAgICAgIH0pO1xuXG4gICAgICBpZiAodGhpcy5pc0NvbXBvc2l0ZSkge1xuICAgICAgICBpZiAodGhpcy5uZWVkc1VwZGF0ZSgpKSB7XG4gICAgICAgICAgdGhpcy5zZXROZWVkc1VwZGF0ZSgpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl91cGRhdGUoKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBpbnZhbGlkYXRlQXR0cmlidXRlKG5hbWUgPSAnYWxsJykge1xuICAgIGNvbnN0IGF0dHJpYnV0ZU1hbmFnZXIgPSB0aGlzLmdldEF0dHJpYnV0ZU1hbmFnZXIoKTtcblxuICAgIGlmICghYXR0cmlidXRlTWFuYWdlcikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChuYW1lID09PSAnYWxsJykge1xuICAgICAgYXR0cmlidXRlTWFuYWdlci5pbnZhbGlkYXRlQWxsKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGF0dHJpYnV0ZU1hbmFnZXIuaW52YWxpZGF0ZShuYW1lKTtcbiAgICB9XG4gIH1cblxuICB1cGRhdGVBdHRyaWJ1dGVzKGNoYW5nZWRBdHRyaWJ1dGVzKSB7XG4gICAgZm9yIChjb25zdCBtb2RlbCBvZiB0aGlzLmdldE1vZGVscygpKSB7XG4gICAgICB0aGlzLl9zZXRNb2RlbEF0dHJpYnV0ZXMobW9kZWwsIGNoYW5nZWRBdHRyaWJ1dGVzKTtcbiAgICB9XG4gIH1cblxuICBfdXBkYXRlQXR0cmlidXRlcygpIHtcbiAgICBjb25zdCBhdHRyaWJ1dGVNYW5hZ2VyID0gdGhpcy5nZXRBdHRyaWJ1dGVNYW5hZ2VyKCk7XG5cbiAgICBpZiAoIWF0dHJpYnV0ZU1hbmFnZXIpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCBwcm9wcyA9IHRoaXMucHJvcHM7XG4gICAgY29uc3QgbnVtSW5zdGFuY2VzID0gdGhpcy5nZXROdW1JbnN0YW5jZXMoKTtcbiAgICBjb25zdCBzdGFydEluZGljZXMgPSB0aGlzLmdldFN0YXJ0SW5kaWNlcygpO1xuICAgIGF0dHJpYnV0ZU1hbmFnZXIudXBkYXRlKHtcbiAgICAgIGRhdGE6IHByb3BzLmRhdGEsXG4gICAgICBudW1JbnN0YW5jZXMsXG4gICAgICBzdGFydEluZGljZXMsXG4gICAgICBwcm9wcyxcbiAgICAgIHRyYW5zaXRpb25zOiBwcm9wcy50cmFuc2l0aW9ucyxcbiAgICAgIGJ1ZmZlcnM6IHByb3BzLmRhdGEuYXR0cmlidXRlcyxcbiAgICAgIGNvbnRleHQ6IHRoaXNcbiAgICB9KTtcbiAgICBjb25zdCBjaGFuZ2VkQXR0cmlidXRlcyA9IGF0dHJpYnV0ZU1hbmFnZXIuZ2V0Q2hhbmdlZEF0dHJpYnV0ZXMoe1xuICAgICAgY2xlYXJDaGFuZ2VkRmxhZ3M6IHRydWVcbiAgICB9KTtcbiAgICB0aGlzLnVwZGF0ZUF0dHJpYnV0ZXMoY2hhbmdlZEF0dHJpYnV0ZXMpO1xuICB9XG5cbiAgX3VwZGF0ZUF0dHJpYnV0ZVRyYW5zaXRpb24oKSB7XG4gICAgY29uc3QgYXR0cmlidXRlTWFuYWdlciA9IHRoaXMuZ2V0QXR0cmlidXRlTWFuYWdlcigpO1xuXG4gICAgaWYgKGF0dHJpYnV0ZU1hbmFnZXIpIHtcbiAgICAgIGF0dHJpYnV0ZU1hbmFnZXIudXBkYXRlVHJhbnNpdGlvbigpO1xuICAgIH1cbiAgfVxuXG4gIF91cGRhdGVVbmlmb3JtVHJhbnNpdGlvbigpIHtcbiAgICBjb25zdCB7XG4gICAgICB1bmlmb3JtVHJhbnNpdGlvbnNcbiAgICB9ID0gdGhpcy5pbnRlcm5hbFN0YXRlO1xuXG4gICAgaWYgKHVuaWZvcm1UcmFuc2l0aW9ucy5hY3RpdmUpIHtcbiAgICAgIGNvbnN0IHByb3BzSW5UcmFuc2l0aW9uID0gdW5pZm9ybVRyYW5zaXRpb25zLnVwZGF0ZSgpO1xuICAgICAgY29uc3QgcHJvcHMgPSBPYmplY3QuY3JlYXRlKHRoaXMucHJvcHMpO1xuXG4gICAgICBmb3IgKGNvbnN0IGtleSBpbiBwcm9wc0luVHJhbnNpdGlvbikge1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkocHJvcHMsIGtleSwge1xuICAgICAgICAgIHZhbHVlOiBwcm9wc0luVHJhbnNpdGlvbltrZXldXG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcHJvcHM7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMucHJvcHM7XG4gIH1cblxuICBjYWxjdWxhdGVJbnN0YW5jZVBpY2tpbmdDb2xvcnMoYXR0cmlidXRlLCB7XG4gICAgbnVtSW5zdGFuY2VzXG4gIH0pIHtcbiAgICBpZiAoYXR0cmlidXRlLmNvbnN0YW50KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3QgY2FjaGVTaXplID0gTWF0aC5mbG9vcihwaWNraW5nQ29sb3JDYWNoZS5sZW5ndGggLyAzKTtcbiAgICB0aGlzLmludGVybmFsU3RhdGUudXNlc1BpY2tpbmdDb2xvckNhY2hlID0gdHJ1ZTtcblxuICAgIGlmIChjYWNoZVNpemUgPCBudW1JbnN0YW5jZXMpIHtcbiAgICAgIGlmIChudW1JbnN0YW5jZXMgPiBNQVhfUElDS0lOR19DT0xPUl9DQUNIRV9TSVpFKSB7XG4gICAgICAgIGxvZy53YXJuKCdMYXllciBoYXMgdG9vIG1hbnkgZGF0YSBvYmplY3RzLiBQaWNraW5nIG1pZ2h0IG5vdCBiZSBhYmxlIHRvIGRpc3Rpbmd1aXNoIGFsbCBvYmplY3RzLicpKCk7XG4gICAgICB9XG5cbiAgICAgIHBpY2tpbmdDb2xvckNhY2hlID0gdHlwZWRBcnJheU1hbmFnZXIuYWxsb2NhdGUocGlja2luZ0NvbG9yQ2FjaGUsIG51bUluc3RhbmNlcywge1xuICAgICAgICBzaXplOiAzLFxuICAgICAgICBjb3B5OiB0cnVlLFxuICAgICAgICBtYXhDb3VudDogTWF0aC5tYXgobnVtSW5zdGFuY2VzLCBNQVhfUElDS0lOR19DT0xPUl9DQUNIRV9TSVpFKVxuICAgICAgfSk7XG4gICAgICBjb25zdCBuZXdDYWNoZVNpemUgPSBNYXRoLmZsb29yKHBpY2tpbmdDb2xvckNhY2hlLmxlbmd0aCAvIDMpO1xuICAgICAgY29uc3QgcGlja2luZ0NvbG9yID0gW107XG5cbiAgICAgIGZvciAobGV0IGkgPSBjYWNoZVNpemU7IGkgPCBuZXdDYWNoZVNpemU7IGkrKykge1xuICAgICAgICB0aGlzLmVuY29kZVBpY2tpbmdDb2xvcihpLCBwaWNraW5nQ29sb3IpO1xuICAgICAgICBwaWNraW5nQ29sb3JDYWNoZVtpICogMyArIDBdID0gcGlja2luZ0NvbG9yWzBdO1xuICAgICAgICBwaWNraW5nQ29sb3JDYWNoZVtpICogMyArIDFdID0gcGlja2luZ0NvbG9yWzFdO1xuICAgICAgICBwaWNraW5nQ29sb3JDYWNoZVtpICogMyArIDJdID0gcGlja2luZ0NvbG9yWzJdO1xuICAgICAgfVxuICAgIH1cblxuICAgIGF0dHJpYnV0ZS52YWx1ZSA9IHBpY2tpbmdDb2xvckNhY2hlLnN1YmFycmF5KDAsIG51bUluc3RhbmNlcyAqIDMpO1xuICB9XG5cbiAgX3NldE1vZGVsQXR0cmlidXRlcyhtb2RlbCwgY2hhbmdlZEF0dHJpYnV0ZXMpIHtcbiAgICBjb25zdCBhdHRyaWJ1dGVNYW5hZ2VyID0gdGhpcy5nZXRBdHRyaWJ1dGVNYW5hZ2VyKCk7XG4gICAgY29uc3QgZXhjbHVkZUF0dHJpYnV0ZXMgPSBtb2RlbC51c2VyRGF0YS5leGNsdWRlQXR0cmlidXRlcyB8fCB7fTtcbiAgICBjb25zdCBzaGFkZXJBdHRyaWJ1dGVzID0gYXR0cmlidXRlTWFuYWdlci5nZXRTaGFkZXJBdHRyaWJ1dGVzKGNoYW5nZWRBdHRyaWJ1dGVzLCBleGNsdWRlQXR0cmlidXRlcyk7XG4gICAgbW9kZWwuc2V0QXR0cmlidXRlcyhzaGFkZXJBdHRyaWJ1dGVzKTtcbiAgfVxuXG4gIGRpc2FibGVQaWNraW5nSW5kZXgob2JqZWN0SW5kZXgpIHtcbiAgICB0aGlzLl9kaXNhYmxlUGlja2luZ0luZGV4KG9iamVjdEluZGV4KTtcbiAgfVxuXG4gIF9kaXNhYmxlUGlja2luZ0luZGV4KG9iamVjdEluZGV4KSB7XG4gICAgY29uc3Qge1xuICAgICAgcGlja2luZ0NvbG9ycyxcbiAgICAgIGluc3RhbmNlUGlja2luZ0NvbG9yc1xuICAgIH0gPSB0aGlzLmdldEF0dHJpYnV0ZU1hbmFnZXIoKS5hdHRyaWJ1dGVzO1xuICAgIGNvbnN0IGNvbG9ycyA9IHBpY2tpbmdDb2xvcnMgfHwgaW5zdGFuY2VQaWNraW5nQ29sb3JzO1xuXG4gICAgaWYgKCFjb2xvcnMpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCBzdGFydCA9IGNvbG9ycy5nZXRWZXJ0ZXhPZmZzZXQob2JqZWN0SW5kZXgpO1xuICAgIGNvbnN0IGVuZCA9IGNvbG9ycy5nZXRWZXJ0ZXhPZmZzZXQob2JqZWN0SW5kZXggKyAxKTtcbiAgICBjb2xvcnMuYnVmZmVyLnN1YkRhdGEoe1xuICAgICAgZGF0YTogbmV3IFVpbnQ4QXJyYXkoZW5kIC0gc3RhcnQpLFxuICAgICAgb2Zmc2V0OiBzdGFydFxuICAgIH0pO1xuICB9XG5cbiAgcmVzdG9yZVBpY2tpbmdDb2xvcnMoKSB7XG4gICAgY29uc3Qge1xuICAgICAgcGlja2luZ0NvbG9ycyxcbiAgICAgIGluc3RhbmNlUGlja2luZ0NvbG9yc1xuICAgIH0gPSB0aGlzLmdldEF0dHJpYnV0ZU1hbmFnZXIoKS5hdHRyaWJ1dGVzO1xuICAgIGNvbnN0IGNvbG9ycyA9IHBpY2tpbmdDb2xvcnMgfHwgaW5zdGFuY2VQaWNraW5nQ29sb3JzO1xuXG4gICAgaWYgKCFjb2xvcnMpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5pbnRlcm5hbFN0YXRlLnVzZXNQaWNraW5nQ29sb3JDYWNoZSAmJiBjb2xvcnMudmFsdWUuYnVmZmVyICE9PSBwaWNraW5nQ29sb3JDYWNoZS5idWZmZXIpIHtcbiAgICAgIGNvbG9ycy52YWx1ZSA9IHBpY2tpbmdDb2xvckNhY2hlLnN1YmFycmF5KDAsIGNvbG9ycy52YWx1ZS5sZW5ndGgpO1xuICAgIH1cblxuICAgIGNvbG9ycy51cGRhdGVTdWJCdWZmZXIoe1xuICAgICAgc3RhcnRPZmZzZXQ6IDBcbiAgICB9KTtcbiAgfVxuXG4gIF9pbml0aWFsaXplKCkge1xuICAgIGFzc2VydCghdGhpcy5pbnRlcm5hbFN0YXRlKTtcbiAgICBhc3NlcnQoTnVtYmVyLmlzRmluaXRlKHRoaXMucHJvcHMuY29vcmRpbmF0ZVN5c3RlbSkpO1xuICAgIGRlYnVnKFRSQUNFX0lOSVRJQUxJWkUsIHRoaXMpO1xuXG4gICAgY29uc3QgYXR0cmlidXRlTWFuYWdlciA9IHRoaXMuX2dldEF0dHJpYnV0ZU1hbmFnZXIoKTtcblxuICAgIGlmIChhdHRyaWJ1dGVNYW5hZ2VyKSB7XG4gICAgICBhdHRyaWJ1dGVNYW5hZ2VyLmFkZEluc3RhbmNlZCh7XG4gICAgICAgIGluc3RhbmNlUGlja2luZ0NvbG9yczoge1xuICAgICAgICAgIHR5cGU6IDUxMjEsXG4gICAgICAgICAgc2l6ZTogMyxcbiAgICAgICAgICBub0FsbG9jOiB0cnVlLFxuICAgICAgICAgIHVwZGF0ZTogdGhpcy5jYWxjdWxhdGVJbnN0YW5jZVBpY2tpbmdDb2xvcnNcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgdGhpcy5pbnRlcm5hbFN0YXRlID0gbmV3IExheWVyU3RhdGUoe1xuICAgICAgYXR0cmlidXRlTWFuYWdlcixcbiAgICAgIGxheWVyOiB0aGlzXG4gICAgfSk7XG5cbiAgICB0aGlzLl9jbGVhckNoYW5nZUZsYWdzKCk7XG5cbiAgICB0aGlzLnN0YXRlID0ge307XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMuc3RhdGUsICdhdHRyaWJ1dGVNYW5hZ2VyJywge1xuICAgICAgZ2V0OiAoKSA9PiB7XG4gICAgICAgIGxvZy5kZXByZWNhdGVkKCdsYXllci5zdGF0ZS5hdHRyaWJ1dGVNYW5hZ2VyJywgJ2xheWVyLmdldEF0dHJpYnV0ZU1hbmFnZXIoKScpKCk7XG4gICAgICAgIHJldHVybiBhdHRyaWJ1dGVNYW5hZ2VyO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHRoaXMuaW50ZXJuYWxTdGF0ZS51bmlmb3JtVHJhbnNpdGlvbnMgPSBuZXcgVW5pZm9ybVRyYW5zaXRpb25NYW5hZ2VyKHRoaXMuY29udGV4dC50aW1lbGluZSk7XG4gICAgdGhpcy5pbnRlcm5hbFN0YXRlLm9uQXN5bmNQcm9wVXBkYXRlZCA9IHRoaXMuX29uQXN5bmNQcm9wVXBkYXRlZC5iaW5kKHRoaXMpO1xuICAgIHRoaXMuaW50ZXJuYWxTdGF0ZS5zZXRBc3luY1Byb3BzKHRoaXMucHJvcHMpO1xuICAgIHRoaXMuaW5pdGlhbGl6ZVN0YXRlKHRoaXMuY29udGV4dCk7XG5cbiAgICBmb3IgKGNvbnN0IGV4dGVuc2lvbiBvZiB0aGlzLnByb3BzLmV4dGVuc2lvbnMpIHtcbiAgICAgIGV4dGVuc2lvbi5pbml0aWFsaXplU3RhdGUuY2FsbCh0aGlzLCB0aGlzLmNvbnRleHQsIGV4dGVuc2lvbik7XG4gICAgfVxuXG4gICAgdGhpcy5zZXRDaGFuZ2VGbGFncyh7XG4gICAgICBkYXRhQ2hhbmdlZDogJ2luaXQnLFxuICAgICAgcHJvcHNDaGFuZ2VkOiAnaW5pdCcsXG4gICAgICB2aWV3cG9ydENoYW5nZWQ6IHRydWUsXG4gICAgICBleHRlbnNpb25zQ2hhbmdlZDogdHJ1ZVxuICAgIH0pO1xuXG4gICAgdGhpcy5fdXBkYXRlKCk7XG4gIH1cblxuICBfdHJhbnNmZXJTdGF0ZShvbGRMYXllcikge1xuICAgIGRlYnVnKFRSQUNFX01BVENIRUQsIHRoaXMsIHRoaXMgPT09IG9sZExheWVyKTtcbiAgICBjb25zdCB7XG4gICAgICBzdGF0ZSxcbiAgICAgIGludGVybmFsU3RhdGVcbiAgICB9ID0gb2xkTGF5ZXI7XG5cbiAgICBpZiAodGhpcyA9PT0gb2xkTGF5ZXIpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLmludGVybmFsU3RhdGUgPSBpbnRlcm5hbFN0YXRlO1xuICAgIHRoaXMuc3RhdGUgPSBzdGF0ZTtcbiAgICB0aGlzLmludGVybmFsU3RhdGUuc2V0QXN5bmNQcm9wcyh0aGlzLnByb3BzKTtcblxuICAgIHRoaXMuX2RpZmZQcm9wcyh0aGlzLnByb3BzLCB0aGlzLmludGVybmFsU3RhdGUuZ2V0T2xkUHJvcHMoKSk7XG4gIH1cblxuICBfdXBkYXRlKCkge1xuICAgIGNvbnN0IHN0YXRlTmVlZHNVcGRhdGUgPSB0aGlzLm5lZWRzVXBkYXRlKCk7XG4gICAgZGVidWcoVFJBQ0VfVVBEQVRFLCB0aGlzLCBzdGF0ZU5lZWRzVXBkYXRlKTtcblxuICAgIGlmICghc3RhdGVOZWVkc1VwZGF0ZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IGN1cnJlbnRQcm9wcyA9IHRoaXMucHJvcHM7XG4gICAgY29uc3QgY29udGV4dCA9IHRoaXMuY29udGV4dDtcbiAgICBjb25zdCBpbnRlcm5hbFN0YXRlID0gdGhpcy5pbnRlcm5hbFN0YXRlO1xuICAgIGNvbnN0IGN1cnJlbnRWaWV3cG9ydCA9IGNvbnRleHQudmlld3BvcnQ7XG5cbiAgICBjb25zdCBwcm9wc0luVHJhbnNpdGlvbiA9IHRoaXMuX3VwZGF0ZVVuaWZvcm1UcmFuc2l0aW9uKCk7XG5cbiAgICBpbnRlcm5hbFN0YXRlLnByb3BzSW5UcmFuc2l0aW9uID0gcHJvcHNJblRyYW5zaXRpb247XG4gICAgY29udGV4dC52aWV3cG9ydCA9IGludGVybmFsU3RhdGUudmlld3BvcnQgfHwgY3VycmVudFZpZXdwb3J0O1xuICAgIHRoaXMucHJvcHMgPSBwcm9wc0luVHJhbnNpdGlvbjtcblxuICAgIHRyeSB7XG4gICAgICBjb25zdCB1cGRhdGVQYXJhbXMgPSB0aGlzLl9nZXRVcGRhdGVQYXJhbXMoKTtcblxuICAgICAgY29uc3Qgb2xkTW9kZWxzID0gdGhpcy5nZXRNb2RlbHMoKTtcblxuICAgICAgaWYgKGNvbnRleHQuZ2wpIHtcbiAgICAgICAgdGhpcy51cGRhdGVTdGF0ZSh1cGRhdGVQYXJhbXMpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICB0aGlzLnVwZGF0ZVN0YXRlKHVwZGF0ZVBhcmFtcyk7XG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7fVxuICAgICAgfVxuXG4gICAgICBmb3IgKGNvbnN0IGV4dGVuc2lvbiBvZiB0aGlzLnByb3BzLmV4dGVuc2lvbnMpIHtcbiAgICAgICAgZXh0ZW5zaW9uLnVwZGF0ZVN0YXRlLmNhbGwodGhpcywgdXBkYXRlUGFyYW1zLCBleHRlbnNpb24pO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBtb2RlbENoYW5nZWQgPSB0aGlzLmdldE1vZGVscygpWzBdICE9PSBvbGRNb2RlbHNbMF07XG5cbiAgICAgIHRoaXMuX3Bvc3RVcGRhdGUodXBkYXRlUGFyYW1zLCBtb2RlbENoYW5nZWQpO1xuICAgIH0gZmluYWxseSB7XG4gICAgICBjb250ZXh0LnZpZXdwb3J0ID0gY3VycmVudFZpZXdwb3J0O1xuICAgICAgdGhpcy5wcm9wcyA9IGN1cnJlbnRQcm9wcztcblxuICAgICAgdGhpcy5fY2xlYXJDaGFuZ2VGbGFncygpO1xuXG4gICAgICBpbnRlcm5hbFN0YXRlLm5lZWRzVXBkYXRlID0gZmFsc2U7XG4gICAgICBpbnRlcm5hbFN0YXRlLnJlc2V0T2xkUHJvcHMoKTtcbiAgICB9XG4gIH1cblxuICBfZmluYWxpemUoKSB7XG4gICAgZGVidWcoVFJBQ0VfRklOQUxJWkUsIHRoaXMpO1xuICAgIHRoaXMuZmluYWxpemVTdGF0ZSh0aGlzLmNvbnRleHQpO1xuXG4gICAgZm9yIChjb25zdCBleHRlbnNpb24gb2YgdGhpcy5wcm9wcy5leHRlbnNpb25zKSB7XG4gICAgICBleHRlbnNpb24uZmluYWxpemVTdGF0ZS5jYWxsKHRoaXMsIHRoaXMuY29udGV4dCwgZXh0ZW5zaW9uKTtcbiAgICB9XG4gIH1cblxuICBfZHJhd0xheWVyKHtcbiAgICBtb2R1bGVQYXJhbWV0ZXJzID0gbnVsbCxcbiAgICB1bmlmb3JtcyA9IHt9LFxuICAgIHBhcmFtZXRlcnMgPSB7fVxuICB9KSB7XG4gICAgdGhpcy5fdXBkYXRlQXR0cmlidXRlVHJhbnNpdGlvbigpO1xuXG4gICAgY29uc3QgY3VycmVudFByb3BzID0gdGhpcy5wcm9wcztcbiAgICBjb25zdCBjb250ZXh0ID0gdGhpcy5jb250ZXh0O1xuICAgIHRoaXMucHJvcHMgPSB0aGlzLmludGVybmFsU3RhdGUucHJvcHNJblRyYW5zaXRpb24gfHwgY3VycmVudFByb3BzO1xuICAgIGNvbnN0IG9wYWNpdHkgPSB0aGlzLnByb3BzLm9wYWNpdHk7XG4gICAgdW5pZm9ybXMub3BhY2l0eSA9IE1hdGgucG93KG9wYWNpdHksIDEgLyAyLjIpO1xuXG4gICAgdHJ5IHtcbiAgICAgIGlmIChtb2R1bGVQYXJhbWV0ZXJzKSB7XG4gICAgICAgIHRoaXMuc2V0TW9kdWxlUGFyYW1ldGVycyhtb2R1bGVQYXJhbWV0ZXJzKTtcbiAgICAgIH1cblxuICAgICAgY29uc3Qge1xuICAgICAgICBnZXRQb2x5Z29uT2Zmc2V0XG4gICAgICB9ID0gdGhpcy5wcm9wcztcbiAgICAgIGNvbnN0IG9mZnNldHMgPSBnZXRQb2x5Z29uT2Zmc2V0ICYmIGdldFBvbHlnb25PZmZzZXQodW5pZm9ybXMpIHx8IFswLCAwXTtcbiAgICAgIHNldFBhcmFtZXRlcnMoY29udGV4dC5nbCwge1xuICAgICAgICBwb2x5Z29uT2Zmc2V0OiBvZmZzZXRzXG4gICAgICB9KTtcbiAgICAgIHdpdGhQYXJhbWV0ZXJzKGNvbnRleHQuZ2wsIHBhcmFtZXRlcnMsICgpID0+IHtcbiAgICAgICAgY29uc3Qgb3B0cyA9IHtcbiAgICAgICAgICBtb2R1bGVQYXJhbWV0ZXJzLFxuICAgICAgICAgIHVuaWZvcm1zLFxuICAgICAgICAgIHBhcmFtZXRlcnMsXG4gICAgICAgICAgY29udGV4dFxuICAgICAgICB9O1xuXG4gICAgICAgIGZvciAoY29uc3QgZXh0ZW5zaW9uIG9mIHRoaXMucHJvcHMuZXh0ZW5zaW9ucykge1xuICAgICAgICAgIGV4dGVuc2lvbi5kcmF3LmNhbGwodGhpcywgb3B0cywgZXh0ZW5zaW9uKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuZHJhdyhvcHRzKTtcbiAgICAgIH0pO1xuICAgIH0gZmluYWxseSB7XG4gICAgICB0aGlzLnByb3BzID0gY3VycmVudFByb3BzO1xuICAgIH1cbiAgfVxuXG4gIGdldENoYW5nZUZsYWdzKCkge1xuICAgIHZhciBfdGhpcyRpbnRlcm5hbFN0YXRlMjtcblxuICAgIHJldHVybiAoX3RoaXMkaW50ZXJuYWxTdGF0ZTIgPSB0aGlzLmludGVybmFsU3RhdGUpID09PSBudWxsIHx8IF90aGlzJGludGVybmFsU3RhdGUyID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfdGhpcyRpbnRlcm5hbFN0YXRlMi5jaGFuZ2VGbGFncztcbiAgfVxuXG4gIHNldENoYW5nZUZsYWdzKGZsYWdzKSB7XG4gICAgaWYgKCF0aGlzLmludGVybmFsU3RhdGUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCB7XG4gICAgICBjaGFuZ2VGbGFnc1xuICAgIH0gPSB0aGlzLmludGVybmFsU3RhdGU7XG5cbiAgICBmb3IgKGNvbnN0IGtleSBpbiBmbGFncykge1xuICAgICAgaWYgKGZsYWdzW2tleV0pIHtcbiAgICAgICAgbGV0IGZsYWdDaGFuZ2VkID0gZmFsc2U7XG5cbiAgICAgICAgc3dpdGNoIChrZXkpIHtcbiAgICAgICAgICBjYXNlICdkYXRhQ2hhbmdlZCc6XG4gICAgICAgICAgICBjb25zdCBkYXRhQ2hhbmdlZFJlYXNvbiA9IGZsYWdzW2tleV07XG4gICAgICAgICAgICBjb25zdCBwcmV2RGF0YUNoYW5nZWRSZWFzb24gPSBjaGFuZ2VGbGFnc1trZXldO1xuXG4gICAgICAgICAgICBpZiAoZGF0YUNoYW5nZWRSZWFzb24gJiYgQXJyYXkuaXNBcnJheShwcmV2RGF0YUNoYW5nZWRSZWFzb24pKSB7XG4gICAgICAgICAgICAgIGNoYW5nZUZsYWdzLmRhdGFDaGFuZ2VkID0gQXJyYXkuaXNBcnJheShkYXRhQ2hhbmdlZFJlYXNvbikgPyBwcmV2RGF0YUNoYW5nZWRSZWFzb24uY29uY2F0KGRhdGFDaGFuZ2VkUmVhc29uKSA6IGRhdGFDaGFuZ2VkUmVhc29uO1xuICAgICAgICAgICAgICBmbGFnQ2hhbmdlZCA9IHRydWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgaWYgKCFjaGFuZ2VGbGFnc1trZXldKSB7XG4gICAgICAgICAgICAgIGNoYW5nZUZsYWdzW2tleV0gPSBmbGFnc1trZXldO1xuICAgICAgICAgICAgICBmbGFnQ2hhbmdlZCA9IHRydWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChmbGFnQ2hhbmdlZCkge1xuICAgICAgICAgIGRlYnVnKFRSQUNFX0NIQU5HRV9GTEFHLCB0aGlzLCBrZXksIGZsYWdzKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGNvbnN0IHByb3BzT3JEYXRhQ2hhbmdlZCA9IEJvb2xlYW4oY2hhbmdlRmxhZ3MuZGF0YUNoYW5nZWQgfHwgY2hhbmdlRmxhZ3MudXBkYXRlVHJpZ2dlcnNDaGFuZ2VkIHx8IGNoYW5nZUZsYWdzLnByb3BzQ2hhbmdlZCB8fCBjaGFuZ2VGbGFncy5leHRlbnNpb25zQ2hhbmdlZCk7XG4gICAgY2hhbmdlRmxhZ3MucHJvcHNPckRhdGFDaGFuZ2VkID0gcHJvcHNPckRhdGFDaGFuZ2VkO1xuICAgIGNoYW5nZUZsYWdzLnNvbWV0aGluZ0NoYW5nZWQgPSBwcm9wc09yRGF0YUNoYW5nZWQgfHwgY2hhbmdlRmxhZ3Mudmlld3BvcnRDaGFuZ2VkIHx8IGNoYW5nZUZsYWdzLnN0YXRlQ2hhbmdlZDtcbiAgfVxuXG4gIF9jbGVhckNoYW5nZUZsYWdzKCkge1xuICAgIHRoaXMuaW50ZXJuYWxTdGF0ZS5jaGFuZ2VGbGFncyA9IHtcbiAgICAgIGRhdGFDaGFuZ2VkOiBmYWxzZSxcbiAgICAgIHByb3BzQ2hhbmdlZDogZmFsc2UsXG4gICAgICB1cGRhdGVUcmlnZ2Vyc0NoYW5nZWQ6IGZhbHNlLFxuICAgICAgdmlld3BvcnRDaGFuZ2VkOiBmYWxzZSxcbiAgICAgIHN0YXRlQ2hhbmdlZDogZmFsc2UsXG4gICAgICBleHRlbnNpb25zQ2hhbmdlZDogZmFsc2UsXG4gICAgICBwcm9wc09yRGF0YUNoYW5nZWQ6IGZhbHNlLFxuICAgICAgc29tZXRoaW5nQ2hhbmdlZDogZmFsc2VcbiAgICB9O1xuICB9XG5cbiAgX2RpZmZQcm9wcyhuZXdQcm9wcywgb2xkUHJvcHMpIHtcbiAgICBjb25zdCBjaGFuZ2VGbGFncyA9IGRpZmZQcm9wcyhuZXdQcm9wcywgb2xkUHJvcHMpO1xuXG4gICAgaWYgKGNoYW5nZUZsYWdzLnVwZGF0ZVRyaWdnZXJzQ2hhbmdlZCkge1xuICAgICAgZm9yIChjb25zdCBrZXkgaW4gY2hhbmdlRmxhZ3MudXBkYXRlVHJpZ2dlcnNDaGFuZ2VkKSB7XG4gICAgICAgIGlmIChjaGFuZ2VGbGFncy51cGRhdGVUcmlnZ2Vyc0NoYW5nZWRba2V5XSkge1xuICAgICAgICAgIHRoaXMuaW52YWxpZGF0ZUF0dHJpYnV0ZShrZXkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGNoYW5nZUZsYWdzLnRyYW5zaXRpb25zQ2hhbmdlZCkge1xuICAgICAgZm9yIChjb25zdCBrZXkgaW4gY2hhbmdlRmxhZ3MudHJhbnNpdGlvbnNDaGFuZ2VkKSB7XG4gICAgICAgIHZhciBfbmV3UHJvcHMkdHJhbnNpdGlvbnM7XG5cbiAgICAgICAgdGhpcy5pbnRlcm5hbFN0YXRlLnVuaWZvcm1UcmFuc2l0aW9ucy5hZGQoa2V5LCBvbGRQcm9wc1trZXldLCBuZXdQcm9wc1trZXldLCAoX25ld1Byb3BzJHRyYW5zaXRpb25zID0gbmV3UHJvcHMudHJhbnNpdGlvbnMpID09PSBudWxsIHx8IF9uZXdQcm9wcyR0cmFuc2l0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX25ld1Byb3BzJHRyYW5zaXRpb25zW2tleV0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0aGlzLnNldENoYW5nZUZsYWdzKGNoYW5nZUZsYWdzKTtcbiAgfVxuXG4gIHZhbGlkYXRlUHJvcHMoKSB7XG4gICAgdmFsaWRhdGVQcm9wcyh0aGlzLnByb3BzKTtcbiAgfVxuXG4gIHVwZGF0ZUF1dG9IaWdobGlnaHQoaW5mbykge1xuICAgIGlmICh0aGlzLnByb3BzLmF1dG9IaWdobGlnaHQgJiYgIU51bWJlci5pc0ludGVnZXIodGhpcy5wcm9wcy5oaWdobGlnaHRlZE9iamVjdEluZGV4KSkge1xuICAgICAgdGhpcy5fdXBkYXRlQXV0b0hpZ2hsaWdodChpbmZvKTtcbiAgICB9XG4gIH1cblxuICBfdXBkYXRlQXV0b0hpZ2hsaWdodChpbmZvKSB7XG4gICAgY29uc3QgcGlja2luZ01vZHVsZVBhcmFtZXRlcnMgPSB7XG4gICAgICBwaWNraW5nU2VsZWN0ZWRDb2xvcjogaW5mby5waWNrZWQgPyBpbmZvLmNvbG9yIDogbnVsbFxuICAgIH07XG4gICAgY29uc3Qge1xuICAgICAgaGlnaGxpZ2h0Q29sb3JcbiAgICB9ID0gdGhpcy5wcm9wcztcblxuICAgIGlmIChpbmZvLnBpY2tlZCAmJiB0eXBlb2YgaGlnaGxpZ2h0Q29sb3IgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHBpY2tpbmdNb2R1bGVQYXJhbWV0ZXJzLnBpY2tpbmdIaWdobGlnaHRDb2xvciA9IGhpZ2hsaWdodENvbG9yKGluZm8pO1xuICAgIH1cblxuICAgIHRoaXMuc2V0TW9kdWxlUGFyYW1ldGVycyhwaWNraW5nTW9kdWxlUGFyYW1ldGVycyk7XG4gICAgdGhpcy5zZXROZWVkc1JlZHJhdygpO1xuICB9XG5cbiAgX2dldEF0dHJpYnV0ZU1hbmFnZXIoKSB7XG4gICAgY29uc3QgY29udGV4dCA9IHRoaXMuY29udGV4dDtcbiAgICByZXR1cm4gbmV3IEF0dHJpYnV0ZU1hbmFnZXIoY29udGV4dC5nbCwge1xuICAgICAgaWQ6IHRoaXMucHJvcHMuaWQsXG4gICAgICBzdGF0czogY29udGV4dC5zdGF0cyxcbiAgICAgIHRpbWVsaW5lOiBjb250ZXh0LnRpbWVsaW5lXG4gICAgfSk7XG4gIH1cblxuICBfcG9zdFVwZGF0ZSh1cGRhdGVQYXJhbXMsIGZvcmNlVXBkYXRlKSB7XG4gICAgY29uc3Qge1xuICAgICAgcHJvcHMsXG4gICAgICBvbGRQcm9wc1xuICAgIH0gPSB1cGRhdGVQYXJhbXM7XG4gICAgdGhpcy5zZXROZWVkc1JlZHJhdygpO1xuXG4gICAgdGhpcy5fdXBkYXRlQXR0cmlidXRlcygpO1xuXG4gICAgY29uc3Qge1xuICAgICAgbW9kZWxcbiAgICB9ID0gdGhpcy5zdGF0ZTtcbiAgICBtb2RlbCA9PT0gbnVsbCB8fCBtb2RlbCA9PT0gdm9pZCAwID8gdm9pZCAwIDogbW9kZWwuc2V0SW5zdGFuY2VDb3VudCh0aGlzLmdldE51bUluc3RhbmNlcygpKTtcbiAgICBjb25zdCB7XG4gICAgICBhdXRvSGlnaGxpZ2h0LFxuICAgICAgaGlnaGxpZ2h0ZWRPYmplY3RJbmRleCxcbiAgICAgIGhpZ2hsaWdodENvbG9yXG4gICAgfSA9IHByb3BzO1xuXG4gICAgaWYgKGZvcmNlVXBkYXRlIHx8IG9sZFByb3BzLmF1dG9IaWdobGlnaHQgIT09IGF1dG9IaWdobGlnaHQgfHwgb2xkUHJvcHMuaGlnaGxpZ2h0ZWRPYmplY3RJbmRleCAhPT0gaGlnaGxpZ2h0ZWRPYmplY3RJbmRleCB8fCBvbGRQcm9wcy5oaWdobGlnaHRDb2xvciAhPT0gaGlnaGxpZ2h0Q29sb3IpIHtcbiAgICAgIGNvbnN0IHBhcmFtZXRlcnMgPSB7fTtcblxuICAgICAgaWYgKCFhdXRvSGlnaGxpZ2h0KSB7XG4gICAgICAgIHBhcmFtZXRlcnMucGlja2luZ1NlbGVjdGVkQ29sb3IgPSBudWxsO1xuICAgICAgfVxuXG4gICAgICBpZiAoQXJyYXkuaXNBcnJheShoaWdobGlnaHRDb2xvcikpIHtcbiAgICAgICAgcGFyYW1ldGVycy5waWNraW5nSGlnaGxpZ2h0Q29sb3IgPSBoaWdobGlnaHRDb2xvcjtcbiAgICAgIH1cblxuICAgICAgaWYgKGZvcmNlVXBkYXRlIHx8IGhpZ2hsaWdodGVkT2JqZWN0SW5kZXggIT09IG9sZFByb3BzLmhpZ2hsaWdodGVkT2JqZWN0SW5kZXgpIHtcbiAgICAgICAgcGFyYW1ldGVycy5waWNraW5nU2VsZWN0ZWRDb2xvciA9IE51bWJlci5pc0Zpbml0ZShoaWdobGlnaHRlZE9iamVjdEluZGV4KSAmJiBoaWdobGlnaHRlZE9iamVjdEluZGV4ID49IDAgPyB0aGlzLmVuY29kZVBpY2tpbmdDb2xvcihoaWdobGlnaHRlZE9iamVjdEluZGV4KSA6IG51bGw7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuc2V0TW9kdWxlUGFyYW1ldGVycyhwYXJhbWV0ZXJzKTtcbiAgICB9XG4gIH1cblxuICBfZ2V0VXBkYXRlUGFyYW1zKCkge1xuICAgIHJldHVybiB7XG4gICAgICBwcm9wczogdGhpcy5wcm9wcyxcbiAgICAgIG9sZFByb3BzOiB0aGlzLmludGVybmFsU3RhdGUuZ2V0T2xkUHJvcHMoKSxcbiAgICAgIGNvbnRleHQ6IHRoaXMuY29udGV4dCxcbiAgICAgIGNoYW5nZUZsYWdzOiB0aGlzLmludGVybmFsU3RhdGUuY2hhbmdlRmxhZ3NcbiAgICB9O1xuICB9XG5cbiAgX2dldE5lZWRzUmVkcmF3KG9wdHMpIHtcbiAgICBpZiAoIXRoaXMuaW50ZXJuYWxTdGF0ZSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGxldCByZWRyYXcgPSBmYWxzZTtcbiAgICByZWRyYXcgPSByZWRyYXcgfHwgdGhpcy5pbnRlcm5hbFN0YXRlLm5lZWRzUmVkcmF3ICYmIHRoaXMuaWQ7XG4gICAgY29uc3QgYXR0cmlidXRlTWFuYWdlciA9IHRoaXMuZ2V0QXR0cmlidXRlTWFuYWdlcigpO1xuICAgIGNvbnN0IGF0dHJpYnV0ZU1hbmFnZXJOZWVkc1JlZHJhdyA9IGF0dHJpYnV0ZU1hbmFnZXIgPyBhdHRyaWJ1dGVNYW5hZ2VyLmdldE5lZWRzUmVkcmF3KG9wdHMpIDogZmFsc2U7XG4gICAgcmVkcmF3ID0gcmVkcmF3IHx8IGF0dHJpYnV0ZU1hbmFnZXJOZWVkc1JlZHJhdztcblxuICAgIGlmIChyZWRyYXcpIHtcbiAgICAgIGZvciAoY29uc3QgZXh0ZW5zaW9uIG9mIHRoaXMucHJvcHMuZXh0ZW5zaW9ucykge1xuICAgICAgICBleHRlbnNpb24ub25OZWVkc1JlZHJhdy5jYWxsKHRoaXMsIGV4dGVuc2lvbik7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy5pbnRlcm5hbFN0YXRlLm5lZWRzUmVkcmF3ID0gdGhpcy5pbnRlcm5hbFN0YXRlLm5lZWRzUmVkcmF3ICYmICFvcHRzLmNsZWFyUmVkcmF3RmxhZ3M7XG4gICAgcmV0dXJuIHJlZHJhdztcbiAgfVxuXG4gIF9vbkFzeW5jUHJvcFVwZGF0ZWQoKSB7XG4gICAgdGhpcy5fZGlmZlByb3BzKHRoaXMucHJvcHMsIHRoaXMuaW50ZXJuYWxTdGF0ZS5nZXRPbGRQcm9wcygpKTtcblxuICAgIHRoaXMuc2V0TmVlZHNVcGRhdGUoKTtcbiAgfVxuXG59XG5cbl9kZWZpbmVQcm9wZXJ0eShMYXllciwgXCJkZWZhdWx0UHJvcHNcIiwgZGVmYXVsdFByb3BzKTtcblxuX2RlZmluZVByb3BlcnR5KExheWVyLCBcImxheWVyTmFtZVwiLCAnTGF5ZXInKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWxheWVyLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///52447\n")}}]);