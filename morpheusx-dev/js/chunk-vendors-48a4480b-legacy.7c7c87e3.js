"use strict";(self["webpackChunkvue3_webpack5"]=self["webpackChunkvue3_webpack5"]||[]).push([[1537],{2819:function(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__){eval('/* harmony import */ var _ThirdParty_Uri_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(93922);\n/* harmony import */ var _ThirdParty_when_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(13222);\n/* harmony import */ var _buildModuleUrl_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(72000);\n/* harmony import */ var _defaultValue_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(62200);\n/* harmony import */ var _defined_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(82982);\n/* harmony import */ var _destroyObject_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(86511);\n/* harmony import */ var _DeveloperError_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(12572);\n/* harmony import */ var _Event_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(14459);\n/* harmony import */ var _FeatureDetection_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(96037);\n/* harmony import */ var _isCrossOriginUrl_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(77850);\n/* harmony import */ var _Resource_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(68985);\n/* harmony import */ var _RuntimeError_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(9407);\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunction canTransferArrayBuffer() {\n  if (!(0,_defined_js__WEBPACK_IMPORTED_MODULE_10__/* ["default"] */ .Z)(TaskProcessor._canTransferArrayBuffer)) {\n    var worker = new Worker(getWorkerUrl("Workers/transferTypedArrayTest.js"));\n    worker.postMessage = (0,_defaultValue_js__WEBPACK_IMPORTED_MODULE_3__/* ["default"] */ .Z)(\n      worker.webkitPostMessage,\n      worker.postMessage\n    );\n\n    var value = 99;\n    var array = new Int8Array([value]);\n\n    try {\n      // postMessage might fail with a DataCloneError\n      // if transferring array buffers is not supported.\n      worker.postMessage(\n        {\n          array: array,\n        },\n        [array.buffer]\n      );\n    } catch (e) {\n      TaskProcessor._canTransferArrayBuffer = false;\n      return TaskProcessor._canTransferArrayBuffer;\n    }\n\n    var deferred = _ThirdParty_when_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"].defer */ .Z.defer();\n\n    worker.onmessage = function (event) {\n      var array = event.data.array;\n\n      // some versions of Firefox silently fail to transfer typed arrays.\n      // https://bugzilla.mozilla.org/show_bug.cgi?id=841904\n      // Check to make sure the value round-trips successfully.\n      var result = (0,_defined_js__WEBPACK_IMPORTED_MODULE_10__/* ["default"] */ .Z)(array) && array[0] === value;\n      deferred.resolve(result);\n\n      worker.terminate();\n\n      TaskProcessor._canTransferArrayBuffer = result;\n    };\n\n    TaskProcessor._canTransferArrayBuffer = deferred.promise;\n  }\n\n  return TaskProcessor._canTransferArrayBuffer;\n}\n\nvar taskCompletedEvent = new _Event_js__WEBPACK_IMPORTED_MODULE_6__/* ["default"] */ .Z();\n\nfunction completeTask(processor, data) {\n  --processor._activeTasks;\n\n  var id = data.id;\n  if (!(0,_defined_js__WEBPACK_IMPORTED_MODULE_10__/* ["default"] */ .Z)(id)) {\n    // This is not one of ours.\n    return;\n  }\n\n  var deferreds = processor._deferreds;\n  var deferred = deferreds[id];\n\n  if ((0,_defined_js__WEBPACK_IMPORTED_MODULE_10__/* ["default"] */ .Z)(data.error)) {\n    var error = data.error;\n    if (error.name === "RuntimeError") {\n      error = new _RuntimeError_js__WEBPACK_IMPORTED_MODULE_9__/* ["default"] */ .Z(data.error.message);\n      error.stack = data.error.stack;\n    } else if (error.name === "DeveloperError") {\n      error = new _DeveloperError_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"] */ .Z(data.error.message);\n      error.stack = data.error.stack;\n    }\n    taskCompletedEvent.raiseEvent(error);\n    deferred.reject(error);\n  } else {\n    taskCompletedEvent.raiseEvent();\n    deferred.resolve(data.result);\n  }\n\n  delete deferreds[id];\n}\n\nfunction getWorkerUrl(moduleID) {\n  var url = (0,_buildModuleUrl_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"] */ .Z)(moduleID);\n\n  if ((0,_isCrossOriginUrl_js__WEBPACK_IMPORTED_MODULE_11__/* ["default"] */ .Z)(url)) {\n    //to load cross-origin, create a shim worker from a blob URL\n    var script = \'importScripts("\' + url + \'");\';\n\n    var blob;\n    try {\n      blob = new Blob([script], {\n        type: "application/javascript",\n      });\n    } catch (e) {\n      var BlobBuilder =\n        window.BlobBuilder ||\n        window.WebKitBlobBuilder ||\n        window.MozBlobBuilder ||\n        window.MSBlobBuilder;\n      var blobBuilder = new BlobBuilder();\n      blobBuilder.append(script);\n      blob = blobBuilder.getBlob("application/javascript");\n    }\n\n    var URL = window.URL || window.webkitURL;\n    url = URL.createObjectURL(blob);\n  }\n\n  return url;\n}\n\nvar bootstrapperUrlResult;\nfunction getBootstrapperUrl() {\n  if (!(0,_defined_js__WEBPACK_IMPORTED_MODULE_10__/* ["default"] */ .Z)(bootstrapperUrlResult)) {\n    bootstrapperUrlResult = getWorkerUrl("Workers/cesiumWorkerBootstrapper.js");\n  }\n  return bootstrapperUrlResult;\n}\n\nfunction createWorker(processor) {\n  var worker = new Worker(getBootstrapperUrl());\n  worker.postMessage = (0,_defaultValue_js__WEBPACK_IMPORTED_MODULE_3__/* ["default"] */ .Z)(\n    worker.webkitPostMessage,\n    worker.postMessage\n  );\n\n  var bootstrapMessage = {\n    loaderConfig: {\n      paths: {\n        Workers: (0,_buildModuleUrl_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"] */ .Z)("Workers"),\n      },\n      baseUrl: _buildModuleUrl_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"].getCesiumBaseUrl */ .Z.getCesiumBaseUrl().url,\n    },\n    workerModule: processor._workerPath,\n  };\n\n  worker.postMessage(bootstrapMessage);\n  worker.onmessage = function (event) {\n    completeTask(processor, event.data);\n  };\n\n  return worker;\n}\n\nfunction getWebAssemblyLoaderConfig(processor, wasmOptions) {\n  var config = {\n    modulePath: undefined,\n    wasmBinaryFile: undefined,\n    wasmBinary: undefined,\n  };\n\n  // Web assembly not supported, use fallback js module if provided\n  if (!_FeatureDetection_js__WEBPACK_IMPORTED_MODULE_7__/* ["default"].supportsWebAssembly */ .Z.supportsWebAssembly()) {\n    if (!(0,_defined_js__WEBPACK_IMPORTED_MODULE_10__/* ["default"] */ .Z)(wasmOptions.fallbackModulePath)) {\n      throw new _RuntimeError_js__WEBPACK_IMPORTED_MODULE_9__/* ["default"] */ .Z(\n        "This browser does not support Web Assembly, and no backup module was provided for " +\n          processor._workerPath\n      );\n    }\n\n    config.modulePath = (0,_buildModuleUrl_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"] */ .Z)(wasmOptions.fallbackModulePath);\n    return _ThirdParty_when_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"].resolve */ .Z.resolve(config);\n  }\n\n  config.modulePath = (0,_buildModuleUrl_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"] */ .Z)(wasmOptions.modulePath);\n  config.wasmBinaryFile = (0,_buildModuleUrl_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"] */ .Z)(wasmOptions.wasmBinaryFile);\n\n  return _Resource_js__WEBPACK_IMPORTED_MODULE_8__/* ["default"].fetchArrayBuffer */ .Z.fetchArrayBuffer({\n    url: config.wasmBinaryFile,\n  }).then(function (arrayBuffer) {\n    config.wasmBinary = arrayBuffer;\n    return config;\n  });\n}\n\n/**\n * A wrapper around a web worker that allows scheduling tasks for a given worker,\n * returning results asynchronously via a promise.\n *\n * The Worker is not constructed until a task is scheduled.\n *\n * @alias TaskProcessor\n * @constructor\n *\n * @param {String} workerPath The Url to the worker. This can either be an absolute path or relative to the Cesium Workers folder.\n * @param {Number} [maximumActiveTasks=Number.POSITIVE_INFINITY] The maximum number of active tasks.  Once exceeded,\n *                                        scheduleTask will not queue any more tasks, allowing\n *                                        work to be rescheduled in future frames.\n */\nfunction TaskProcessor(workerPath, maximumActiveTasks) {\n  var uri = new _ThirdParty_Uri_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .Z(workerPath);\n  this._workerPath =\n    uri.scheme().length !== 0 && uri.fragment().length === 0\n      ? workerPath\n      : TaskProcessor._workerModulePrefix + workerPath;\n  this._maximumActiveTasks = (0,_defaultValue_js__WEBPACK_IMPORTED_MODULE_3__/* ["default"] */ .Z)(\n    maximumActiveTasks,\n    Number.POSITIVE_INFINITY\n  );\n  this._activeTasks = 0;\n  this._deferreds = {};\n  this._nextID = 0;\n}\n\nvar emptyTransferableObjectArray = [];\n\n/**\n * Schedule a task to be processed by the web worker asynchronously.  If there are currently more\n * tasks active than the maximum set by the constructor, will immediately return undefined.\n * Otherwise, returns a promise that will resolve to the result posted back by the worker when\n * finished.\n *\n * @param {Object} parameters Any input data that will be posted to the worker.\n * @param {Object[]} [transferableObjects] An array of objects contained in parameters that should be\n *                                      transferred to the worker instead of copied.\n * @returns {Promise.<Object>|undefined} Either a promise that will resolve to the result when available, or undefined\n *                    if there are too many active tasks,\n *\n * @example\n * var taskProcessor = new Cesium.TaskProcessor(\'myWorkerPath\');\n * var promise = taskProcessor.scheduleTask({\n *     someParameter : true,\n *     another : \'hello\'\n * });\n * if (!Cesium.defined(promise)) {\n *     // too many active tasks - try again later\n * } else {\n *     Cesium.when(promise, function(result) {\n *         // use the result of the task\n *     });\n * }\n */\nTaskProcessor.prototype.scheduleTask = function (\n  parameters,\n  transferableObjects\n) {\n  if (!(0,_defined_js__WEBPACK_IMPORTED_MODULE_10__/* ["default"] */ .Z)(this._worker)) {\n    this._worker = createWorker(this);\n  }\n\n  if (this._activeTasks >= this._maximumActiveTasks) {\n    return undefined;\n  }\n\n  ++this._activeTasks;\n\n  var processor = this;\n  return (0,_ThirdParty_when_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .Z)(canTransferArrayBuffer(), function (canTransferArrayBuffer) {\n    if (!(0,_defined_js__WEBPACK_IMPORTED_MODULE_10__/* ["default"] */ .Z)(transferableObjects)) {\n      transferableObjects = emptyTransferableObjectArray;\n    } else if (!canTransferArrayBuffer) {\n      transferableObjects.length = 0;\n    }\n\n    var id = processor._nextID++;\n    var deferred = _ThirdParty_when_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"].defer */ .Z.defer();\n    processor._deferreds[id] = deferred;\n\n    processor._worker.postMessage(\n      {\n        id: id,\n        parameters: parameters,\n        canTransferArrayBuffer: canTransferArrayBuffer,\n      },\n      transferableObjects\n    );\n\n    return deferred.promise;\n  });\n};\n\n/**\n * Posts a message to a web worker with configuration to initialize loading\n * and compiling a web assembly module asychronously, as well as an optional\n * fallback JavaScript module to use if Web Assembly is not supported.\n *\n * @param {Object} [webAssemblyOptions] An object with the following properties:\n * @param {String} [webAssemblyOptions.modulePath] The path of the web assembly JavaScript wrapper module.\n * @param {String} [webAssemblyOptions.wasmBinaryFile] The path of the web assembly binary file.\n * @param {String} [webAssemblyOptions.fallbackModulePath] The path of the fallback JavaScript module to use if web assembly is not supported.\n * @returns {Promise.<Object>} A promise that resolves to the result when the web worker has loaded and compiled the web assembly module and is ready to process tasks.\n */\nTaskProcessor.prototype.initWebAssemblyModule = function (webAssemblyOptions) {\n  if (!(0,_defined_js__WEBPACK_IMPORTED_MODULE_10__/* ["default"] */ .Z)(this._worker)) {\n    this._worker = createWorker(this);\n  }\n\n  var deferred = _ThirdParty_when_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"].defer */ .Z.defer();\n  var processor = this;\n  var worker = this._worker;\n  getWebAssemblyLoaderConfig(this, webAssemblyOptions).then(function (\n    wasmConfig\n  ) {\n    return (0,_ThirdParty_when_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .Z)(canTransferArrayBuffer(), function (canTransferArrayBuffer) {\n      var transferableObjects;\n      var binary = wasmConfig.wasmBinary;\n      if ((0,_defined_js__WEBPACK_IMPORTED_MODULE_10__/* ["default"] */ .Z)(binary) && canTransferArrayBuffer) {\n        transferableObjects = [binary];\n      }\n\n      worker.onmessage = function (event) {\n        worker.onmessage = function (event) {\n          completeTask(processor, event.data);\n        };\n\n        deferred.resolve(event.data);\n      };\n\n      worker.postMessage(\n        { webAssemblyConfig: wasmConfig },\n        transferableObjects\n      );\n    });\n  });\n\n  return deferred;\n};\n\n/**\n * Returns true if this object was destroyed; otherwise, false.\n * <br /><br />\n * If this object was destroyed, it should not be used; calling any function other than\n * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.\n *\n * @returns {Boolean} True if this object was destroyed; otherwise, false.\n *\n * @see TaskProcessor#destroy\n */\nTaskProcessor.prototype.isDestroyed = function () {\n  return false;\n};\n\n/**\n * Destroys this object.  This will immediately terminate the Worker.\n * <br /><br />\n * Once an object is destroyed, it should not be used; calling any function other than\n * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.\n */\nTaskProcessor.prototype.destroy = function () {\n  if ((0,_defined_js__WEBPACK_IMPORTED_MODULE_10__/* ["default"] */ .Z)(this._worker)) {\n    this._worker.terminate();\n  }\n  return (0,_destroyObject_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .Z)(this);\n};\n\n/**\n * An event that\'s raised when a task is completed successfully.  Event handlers are passed\n * the error object is a task fails.\n *\n * @type {Event}\n *\n * @private\n */\nTaskProcessor.taskCompletedEvent = taskCompletedEvent;\n\n// exposed for testing purposes\nTaskProcessor._defaultWorkerModulePrefix = "Workers/";\nTaskProcessor._workerModulePrefix = TaskProcessor._defaultWorkerModulePrefix;\nTaskProcessor._canTransferArrayBuffer = undefined;\n/* harmony default export */ __webpack_exports__["Z"] = (TaskProcessor);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QUNQO0FBQ0E7O0FBRUE7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixhQUFhLGtCQUFrQjtBQUMvQjtBQUNBO0FBQ0EsT0FBTyxpRUFBTztBQUNkO0FBQ0E7O0FBRUEsaUJBQWlCLGdGQUFVO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLHdFQUFJO0FBQ2Y7QUFDQTtBQUNBLFVBQVUsaUVBQU87QUFDakI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsVUFBVSwrQkFBK0I7QUFDekM7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHOztBQUVIO0FBQ0E7O0FBRUE7QUFDQSw4Q0FBOEM7QUFDOUM7QUFDQSx3REFBd0Q7QUFDeEQsOENBQThDLHNCQUFzQjtBQUNwRTtBQUNBLGFBQWEsU0FBUyxtQ0FBbUM7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHVEQUF1RDtBQUN2RCw4Q0FBOEMsc0JBQXNCO0FBQ3BFO0FBQ0E7QUFDQSxNQUFNLGlFQUFPO0FBQ2I7QUFDQTtBQUNBLFNBQVMsc0VBQWE7QUFDdEI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5REFBZSxhQUFhLEVBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly92dWUzLXdlYnBhY2s1Ly4vbm9kZV9tb2R1bGVzL2Nlc2l1bS9Tb3VyY2UvQ29yZS9UYXNrUHJvY2Vzc29yLmpzP2QyNDEiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IFVyaSBmcm9tIFwiLi4vVGhpcmRQYXJ0eS9VcmkuanNcIjtcbmltcG9ydCB3aGVuIGZyb20gXCIuLi9UaGlyZFBhcnR5L3doZW4uanNcIjtcbmltcG9ydCBidWlsZE1vZHVsZVVybCBmcm9tIFwiLi9idWlsZE1vZHVsZVVybC5qc1wiO1xuaW1wb3J0IGRlZmF1bHRWYWx1ZSBmcm9tIFwiLi9kZWZhdWx0VmFsdWUuanNcIjtcbmltcG9ydCBkZWZpbmVkIGZyb20gXCIuL2RlZmluZWQuanNcIjtcbmltcG9ydCBkZXN0cm95T2JqZWN0IGZyb20gXCIuL2Rlc3Ryb3lPYmplY3QuanNcIjtcbmltcG9ydCBEZXZlbG9wZXJFcnJvciBmcm9tIFwiLi9EZXZlbG9wZXJFcnJvci5qc1wiO1xuaW1wb3J0IEV2ZW50IGZyb20gXCIuL0V2ZW50LmpzXCI7XG5pbXBvcnQgRmVhdHVyZURldGVjdGlvbiBmcm9tIFwiLi9GZWF0dXJlRGV0ZWN0aW9uLmpzXCI7XG5pbXBvcnQgaXNDcm9zc09yaWdpblVybCBmcm9tIFwiLi9pc0Nyb3NzT3JpZ2luVXJsLmpzXCI7XG5pbXBvcnQgUmVzb3VyY2UgZnJvbSBcIi4vUmVzb3VyY2UuanNcIjtcbmltcG9ydCBSdW50aW1lRXJyb3IgZnJvbSBcIi4vUnVudGltZUVycm9yLmpzXCI7XG5cbmZ1bmN0aW9uIGNhblRyYW5zZmVyQXJyYXlCdWZmZXIoKSB7XG4gIGlmICghZGVmaW5lZChUYXNrUHJvY2Vzc29yLl9jYW5UcmFuc2ZlckFycmF5QnVmZmVyKSkge1xuICAgIHZhciB3b3JrZXIgPSBuZXcgV29ya2VyKGdldFdvcmtlclVybChcIldvcmtlcnMvdHJhbnNmZXJUeXBlZEFycmF5VGVzdC5qc1wiKSk7XG4gICAgd29ya2VyLnBvc3RNZXNzYWdlID0gZGVmYXVsdFZhbHVlKFxuICAgICAgd29ya2VyLndlYmtpdFBvc3RNZXNzYWdlLFxuICAgICAgd29ya2VyLnBvc3RNZXNzYWdlXG4gICAgKTtcblxuICAgIHZhciB2YWx1ZSA9IDk5O1xuICAgIHZhciBhcnJheSA9IG5ldyBJbnQ4QXJyYXkoW3ZhbHVlXSk7XG5cbiAgICB0cnkge1xuICAgICAgLy8gcG9zdE1lc3NhZ2UgbWlnaHQgZmFpbCB3aXRoIGEgRGF0YUNsb25lRXJyb3JcbiAgICAgIC8vIGlmIHRyYW5zZmVycmluZyBhcnJheSBidWZmZXJzIGlzIG5vdCBzdXBwb3J0ZWQuXG4gICAgICB3b3JrZXIucG9zdE1lc3NhZ2UoXG4gICAgICAgIHtcbiAgICAgICAgICBhcnJheTogYXJyYXksXG4gICAgICAgIH0sXG4gICAgICAgIFthcnJheS5idWZmZXJdXG4gICAgICApO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIFRhc2tQcm9jZXNzb3IuX2NhblRyYW5zZmVyQXJyYXlCdWZmZXIgPSBmYWxzZTtcbiAgICAgIHJldHVybiBUYXNrUHJvY2Vzc29yLl9jYW5UcmFuc2ZlckFycmF5QnVmZmVyO1xuICAgIH1cblxuICAgIHZhciBkZWZlcnJlZCA9IHdoZW4uZGVmZXIoKTtcblxuICAgIHdvcmtlci5vbm1lc3NhZ2UgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgIHZhciBhcnJheSA9IGV2ZW50LmRhdGEuYXJyYXk7XG5cbiAgICAgIC8vIHNvbWUgdmVyc2lvbnMgb2YgRmlyZWZveCBzaWxlbnRseSBmYWlsIHRvIHRyYW5zZmVyIHR5cGVkIGFycmF5cy5cbiAgICAgIC8vIGh0dHBzOi8vYnVnemlsbGEubW96aWxsYS5vcmcvc2hvd19idWcuY2dpP2lkPTg0MTkwNFxuICAgICAgLy8gQ2hlY2sgdG8gbWFrZSBzdXJlIHRoZSB2YWx1ZSByb3VuZC10cmlwcyBzdWNjZXNzZnVsbHkuXG4gICAgICB2YXIgcmVzdWx0ID0gZGVmaW5lZChhcnJheSkgJiYgYXJyYXlbMF0gPT09IHZhbHVlO1xuICAgICAgZGVmZXJyZWQucmVzb2x2ZShyZXN1bHQpO1xuXG4gICAgICB3b3JrZXIudGVybWluYXRlKCk7XG5cbiAgICAgIFRhc2tQcm9jZXNzb3IuX2NhblRyYW5zZmVyQXJyYXlCdWZmZXIgPSByZXN1bHQ7XG4gICAgfTtcblxuICAgIFRhc2tQcm9jZXNzb3IuX2NhblRyYW5zZmVyQXJyYXlCdWZmZXIgPSBkZWZlcnJlZC5wcm9taXNlO1xuICB9XG5cbiAgcmV0dXJuIFRhc2tQcm9jZXNzb3IuX2NhblRyYW5zZmVyQXJyYXlCdWZmZXI7XG59XG5cbnZhciB0YXNrQ29tcGxldGVkRXZlbnQgPSBuZXcgRXZlbnQoKTtcblxuZnVuY3Rpb24gY29tcGxldGVUYXNrKHByb2Nlc3NvciwgZGF0YSkge1xuICAtLXByb2Nlc3Nvci5fYWN0aXZlVGFza3M7XG5cbiAgdmFyIGlkID0gZGF0YS5pZDtcbiAgaWYgKCFkZWZpbmVkKGlkKSkge1xuICAgIC8vIFRoaXMgaXMgbm90IG9uZSBvZiBvdXJzLlxuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciBkZWZlcnJlZHMgPSBwcm9jZXNzb3IuX2RlZmVycmVkcztcbiAgdmFyIGRlZmVycmVkID0gZGVmZXJyZWRzW2lkXTtcblxuICBpZiAoZGVmaW5lZChkYXRhLmVycm9yKSkge1xuICAgIHZhciBlcnJvciA9IGRhdGEuZXJyb3I7XG4gICAgaWYgKGVycm9yLm5hbWUgPT09IFwiUnVudGltZUVycm9yXCIpIHtcbiAgICAgIGVycm9yID0gbmV3IFJ1bnRpbWVFcnJvcihkYXRhLmVycm9yLm1lc3NhZ2UpO1xuICAgICAgZXJyb3Iuc3RhY2sgPSBkYXRhLmVycm9yLnN0YWNrO1xuICAgIH0gZWxzZSBpZiAoZXJyb3IubmFtZSA9PT0gXCJEZXZlbG9wZXJFcnJvclwiKSB7XG4gICAgICBlcnJvciA9IG5ldyBEZXZlbG9wZXJFcnJvcihkYXRhLmVycm9yLm1lc3NhZ2UpO1xuICAgICAgZXJyb3Iuc3RhY2sgPSBkYXRhLmVycm9yLnN0YWNrO1xuICAgIH1cbiAgICB0YXNrQ29tcGxldGVkRXZlbnQucmFpc2VFdmVudChlcnJvcik7XG4gICAgZGVmZXJyZWQucmVqZWN0KGVycm9yKTtcbiAgfSBlbHNlIHtcbiAgICB0YXNrQ29tcGxldGVkRXZlbnQucmFpc2VFdmVudCgpO1xuICAgIGRlZmVycmVkLnJlc29sdmUoZGF0YS5yZXN1bHQpO1xuICB9XG5cbiAgZGVsZXRlIGRlZmVycmVkc1tpZF07XG59XG5cbmZ1bmN0aW9uIGdldFdvcmtlclVybChtb2R1bGVJRCkge1xuICB2YXIgdXJsID0gYnVpbGRNb2R1bGVVcmwobW9kdWxlSUQpO1xuXG4gIGlmIChpc0Nyb3NzT3JpZ2luVXJsKHVybCkpIHtcbiAgICAvL3RvIGxvYWQgY3Jvc3Mtb3JpZ2luLCBjcmVhdGUgYSBzaGltIHdvcmtlciBmcm9tIGEgYmxvYiBVUkxcbiAgICB2YXIgc2NyaXB0ID0gJ2ltcG9ydFNjcmlwdHMoXCInICsgdXJsICsgJ1wiKTsnO1xuXG4gICAgdmFyIGJsb2I7XG4gICAgdHJ5IHtcbiAgICAgIGJsb2IgPSBuZXcgQmxvYihbc2NyaXB0XSwge1xuICAgICAgICB0eXBlOiBcImFwcGxpY2F0aW9uL2phdmFzY3JpcHRcIixcbiAgICAgIH0pO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHZhciBCbG9iQnVpbGRlciA9XG4gICAgICAgIHdpbmRvdy5CbG9iQnVpbGRlciB8fFxuICAgICAgICB3aW5kb3cuV2ViS2l0QmxvYkJ1aWxkZXIgfHxcbiAgICAgICAgd2luZG93Lk1vekJsb2JCdWlsZGVyIHx8XG4gICAgICAgIHdpbmRvdy5NU0Jsb2JCdWlsZGVyO1xuICAgICAgdmFyIGJsb2JCdWlsZGVyID0gbmV3IEJsb2JCdWlsZGVyKCk7XG4gICAgICBibG9iQnVpbGRlci5hcHBlbmQoc2NyaXB0KTtcbiAgICAgIGJsb2IgPSBibG9iQnVpbGRlci5nZXRCbG9iKFwiYXBwbGljYXRpb24vamF2YXNjcmlwdFwiKTtcbiAgICB9XG5cbiAgICB2YXIgVVJMID0gd2luZG93LlVSTCB8fCB3aW5kb3cud2Via2l0VVJMO1xuICAgIHVybCA9IFVSTC5jcmVhdGVPYmplY3RVUkwoYmxvYik7XG4gIH1cblxuICByZXR1cm4gdXJsO1xufVxuXG52YXIgYm9vdHN0cmFwcGVyVXJsUmVzdWx0O1xuZnVuY3Rpb24gZ2V0Qm9vdHN0cmFwcGVyVXJsKCkge1xuICBpZiAoIWRlZmluZWQoYm9vdHN0cmFwcGVyVXJsUmVzdWx0KSkge1xuICAgIGJvb3RzdHJhcHBlclVybFJlc3VsdCA9IGdldFdvcmtlclVybChcIldvcmtlcnMvY2VzaXVtV29ya2VyQm9vdHN0cmFwcGVyLmpzXCIpO1xuICB9XG4gIHJldHVybiBib290c3RyYXBwZXJVcmxSZXN1bHQ7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVdvcmtlcihwcm9jZXNzb3IpIHtcbiAgdmFyIHdvcmtlciA9IG5ldyBXb3JrZXIoZ2V0Qm9vdHN0cmFwcGVyVXJsKCkpO1xuICB3b3JrZXIucG9zdE1lc3NhZ2UgPSBkZWZhdWx0VmFsdWUoXG4gICAgd29ya2VyLndlYmtpdFBvc3RNZXNzYWdlLFxuICAgIHdvcmtlci5wb3N0TWVzc2FnZVxuICApO1xuXG4gIHZhciBib290c3RyYXBNZXNzYWdlID0ge1xuICAgIGxvYWRlckNvbmZpZzoge1xuICAgICAgcGF0aHM6IHtcbiAgICAgICAgV29ya2VyczogYnVpbGRNb2R1bGVVcmwoXCJXb3JrZXJzXCIpLFxuICAgICAgfSxcbiAgICAgIGJhc2VVcmw6IGJ1aWxkTW9kdWxlVXJsLmdldENlc2l1bUJhc2VVcmwoKS51cmwsXG4gICAgfSxcbiAgICB3b3JrZXJNb2R1bGU6IHByb2Nlc3Nvci5fd29ya2VyUGF0aCxcbiAgfTtcblxuICB3b3JrZXIucG9zdE1lc3NhZ2UoYm9vdHN0cmFwTWVzc2FnZSk7XG4gIHdvcmtlci5vbm1lc3NhZ2UgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICBjb21wbGV0ZVRhc2socHJvY2Vzc29yLCBldmVudC5kYXRhKTtcbiAgfTtcblxuICByZXR1cm4gd29ya2VyO1xufVxuXG5mdW5jdGlvbiBnZXRXZWJBc3NlbWJseUxvYWRlckNvbmZpZyhwcm9jZXNzb3IsIHdhc21PcHRpb25zKSB7XG4gIHZhciBjb25maWcgPSB7XG4gICAgbW9kdWxlUGF0aDogdW5kZWZpbmVkLFxuICAgIHdhc21CaW5hcnlGaWxlOiB1bmRlZmluZWQsXG4gICAgd2FzbUJpbmFyeTogdW5kZWZpbmVkLFxuICB9O1xuXG4gIC8vIFdlYiBhc3NlbWJseSBub3Qgc3VwcG9ydGVkLCB1c2UgZmFsbGJhY2sganMgbW9kdWxlIGlmIHByb3ZpZGVkXG4gIGlmICghRmVhdHVyZURldGVjdGlvbi5zdXBwb3J0c1dlYkFzc2VtYmx5KCkpIHtcbiAgICBpZiAoIWRlZmluZWQod2FzbU9wdGlvbnMuZmFsbGJhY2tNb2R1bGVQYXRoKSkge1xuICAgICAgdGhyb3cgbmV3IFJ1bnRpbWVFcnJvcihcbiAgICAgICAgXCJUaGlzIGJyb3dzZXIgZG9lcyBub3Qgc3VwcG9ydCBXZWIgQXNzZW1ibHksIGFuZCBubyBiYWNrdXAgbW9kdWxlIHdhcyBwcm92aWRlZCBmb3IgXCIgK1xuICAgICAgICAgIHByb2Nlc3Nvci5fd29ya2VyUGF0aFxuICAgICAgKTtcbiAgICB9XG5cbiAgICBjb25maWcubW9kdWxlUGF0aCA9IGJ1aWxkTW9kdWxlVXJsKHdhc21PcHRpb25zLmZhbGxiYWNrTW9kdWxlUGF0aCk7XG4gICAgcmV0dXJuIHdoZW4ucmVzb2x2ZShjb25maWcpO1xuICB9XG5cbiAgY29uZmlnLm1vZHVsZVBhdGggPSBidWlsZE1vZHVsZVVybCh3YXNtT3B0aW9ucy5tb2R1bGVQYXRoKTtcbiAgY29uZmlnLndhc21CaW5hcnlGaWxlID0gYnVpbGRNb2R1bGVVcmwod2FzbU9wdGlvbnMud2FzbUJpbmFyeUZpbGUpO1xuXG4gIHJldHVybiBSZXNvdXJjZS5mZXRjaEFycmF5QnVmZmVyKHtcbiAgICB1cmw6IGNvbmZpZy53YXNtQmluYXJ5RmlsZSxcbiAgfSkudGhlbihmdW5jdGlvbiAoYXJyYXlCdWZmZXIpIHtcbiAgICBjb25maWcud2FzbUJpbmFyeSA9IGFycmF5QnVmZmVyO1xuICAgIHJldHVybiBjb25maWc7XG4gIH0pO1xufVxuXG4vKipcbiAqIEEgd3JhcHBlciBhcm91bmQgYSB3ZWIgd29ya2VyIHRoYXQgYWxsb3dzIHNjaGVkdWxpbmcgdGFza3MgZm9yIGEgZ2l2ZW4gd29ya2VyLFxuICogcmV0dXJuaW5nIHJlc3VsdHMgYXN5bmNocm9ub3VzbHkgdmlhIGEgcHJvbWlzZS5cbiAqXG4gKiBUaGUgV29ya2VyIGlzIG5vdCBjb25zdHJ1Y3RlZCB1bnRpbCBhIHRhc2sgaXMgc2NoZWR1bGVkLlxuICpcbiAqIEBhbGlhcyBUYXNrUHJvY2Vzc29yXG4gKiBAY29uc3RydWN0b3JcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gd29ya2VyUGF0aCBUaGUgVXJsIHRvIHRoZSB3b3JrZXIuIFRoaXMgY2FuIGVpdGhlciBiZSBhbiBhYnNvbHV0ZSBwYXRoIG9yIHJlbGF0aXZlIHRvIHRoZSBDZXNpdW0gV29ya2VycyBmb2xkZXIuXG4gKiBAcGFyYW0ge051bWJlcn0gW21heGltdW1BY3RpdmVUYXNrcz1OdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFldIFRoZSBtYXhpbXVtIG51bWJlciBvZiBhY3RpdmUgdGFza3MuICBPbmNlIGV4Y2VlZGVkLFxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2NoZWR1bGVUYXNrIHdpbGwgbm90IHF1ZXVlIGFueSBtb3JlIHRhc2tzLCBhbGxvd2luZ1xuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd29yayB0byBiZSByZXNjaGVkdWxlZCBpbiBmdXR1cmUgZnJhbWVzLlxuICovXG5mdW5jdGlvbiBUYXNrUHJvY2Vzc29yKHdvcmtlclBhdGgsIG1heGltdW1BY3RpdmVUYXNrcykge1xuICB2YXIgdXJpID0gbmV3IFVyaSh3b3JrZXJQYXRoKTtcbiAgdGhpcy5fd29ya2VyUGF0aCA9XG4gICAgdXJpLnNjaGVtZSgpLmxlbmd0aCAhPT0gMCAmJiB1cmkuZnJhZ21lbnQoKS5sZW5ndGggPT09IDBcbiAgICAgID8gd29ya2VyUGF0aFxuICAgICAgOiBUYXNrUHJvY2Vzc29yLl93b3JrZXJNb2R1bGVQcmVmaXggKyB3b3JrZXJQYXRoO1xuICB0aGlzLl9tYXhpbXVtQWN0aXZlVGFza3MgPSBkZWZhdWx0VmFsdWUoXG4gICAgbWF4aW11bUFjdGl2ZVRhc2tzLFxuICAgIE51bWJlci5QT1NJVElWRV9JTkZJTklUWVxuICApO1xuICB0aGlzLl9hY3RpdmVUYXNrcyA9IDA7XG4gIHRoaXMuX2RlZmVycmVkcyA9IHt9O1xuICB0aGlzLl9uZXh0SUQgPSAwO1xufVxuXG52YXIgZW1wdHlUcmFuc2ZlcmFibGVPYmplY3RBcnJheSA9IFtdO1xuXG4vKipcbiAqIFNjaGVkdWxlIGEgdGFzayB0byBiZSBwcm9jZXNzZWQgYnkgdGhlIHdlYiB3b3JrZXIgYXN5bmNocm9ub3VzbHkuICBJZiB0aGVyZSBhcmUgY3VycmVudGx5IG1vcmVcbiAqIHRhc2tzIGFjdGl2ZSB0aGFuIHRoZSBtYXhpbXVtIHNldCBieSB0aGUgY29uc3RydWN0b3IsIHdpbGwgaW1tZWRpYXRlbHkgcmV0dXJuIHVuZGVmaW5lZC5cbiAqIE90aGVyd2lzZSwgcmV0dXJucyBhIHByb21pc2UgdGhhdCB3aWxsIHJlc29sdmUgdG8gdGhlIHJlc3VsdCBwb3N0ZWQgYmFjayBieSB0aGUgd29ya2VyIHdoZW5cbiAqIGZpbmlzaGVkLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBwYXJhbWV0ZXJzIEFueSBpbnB1dCBkYXRhIHRoYXQgd2lsbCBiZSBwb3N0ZWQgdG8gdGhlIHdvcmtlci5cbiAqIEBwYXJhbSB7T2JqZWN0W119IFt0cmFuc2ZlcmFibGVPYmplY3RzXSBBbiBhcnJheSBvZiBvYmplY3RzIGNvbnRhaW5lZCBpbiBwYXJhbWV0ZXJzIHRoYXQgc2hvdWxkIGJlXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJhbnNmZXJyZWQgdG8gdGhlIHdvcmtlciBpbnN0ZWFkIG9mIGNvcGllZC5cbiAqIEByZXR1cm5zIHtQcm9taXNlLjxPYmplY3Q+fHVuZGVmaW5lZH0gRWl0aGVyIGEgcHJvbWlzZSB0aGF0IHdpbGwgcmVzb2x2ZSB0byB0aGUgcmVzdWx0IHdoZW4gYXZhaWxhYmxlLCBvciB1bmRlZmluZWRcbiAqICAgICAgICAgICAgICAgICAgICBpZiB0aGVyZSBhcmUgdG9vIG1hbnkgYWN0aXZlIHRhc2tzLFxuICpcbiAqIEBleGFtcGxlXG4gKiB2YXIgdGFza1Byb2Nlc3NvciA9IG5ldyBDZXNpdW0uVGFza1Byb2Nlc3NvcignbXlXb3JrZXJQYXRoJyk7XG4gKiB2YXIgcHJvbWlzZSA9IHRhc2tQcm9jZXNzb3Iuc2NoZWR1bGVUYXNrKHtcbiAqICAgICBzb21lUGFyYW1ldGVyIDogdHJ1ZSxcbiAqICAgICBhbm90aGVyIDogJ2hlbGxvJ1xuICogfSk7XG4gKiBpZiAoIUNlc2l1bS5kZWZpbmVkKHByb21pc2UpKSB7XG4gKiAgICAgLy8gdG9vIG1hbnkgYWN0aXZlIHRhc2tzIC0gdHJ5IGFnYWluIGxhdGVyXG4gKiB9IGVsc2Uge1xuICogICAgIENlc2l1bS53aGVuKHByb21pc2UsIGZ1bmN0aW9uKHJlc3VsdCkge1xuICogICAgICAgICAvLyB1c2UgdGhlIHJlc3VsdCBvZiB0aGUgdGFza1xuICogICAgIH0pO1xuICogfVxuICovXG5UYXNrUHJvY2Vzc29yLnByb3RvdHlwZS5zY2hlZHVsZVRhc2sgPSBmdW5jdGlvbiAoXG4gIHBhcmFtZXRlcnMsXG4gIHRyYW5zZmVyYWJsZU9iamVjdHNcbikge1xuICBpZiAoIWRlZmluZWQodGhpcy5fd29ya2VyKSkge1xuICAgIHRoaXMuX3dvcmtlciA9IGNyZWF0ZVdvcmtlcih0aGlzKTtcbiAgfVxuXG4gIGlmICh0aGlzLl9hY3RpdmVUYXNrcyA+PSB0aGlzLl9tYXhpbXVtQWN0aXZlVGFza3MpIHtcbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG5cbiAgKyt0aGlzLl9hY3RpdmVUYXNrcztcblxuICB2YXIgcHJvY2Vzc29yID0gdGhpcztcbiAgcmV0dXJuIHdoZW4oY2FuVHJhbnNmZXJBcnJheUJ1ZmZlcigpLCBmdW5jdGlvbiAoY2FuVHJhbnNmZXJBcnJheUJ1ZmZlcikge1xuICAgIGlmICghZGVmaW5lZCh0cmFuc2ZlcmFibGVPYmplY3RzKSkge1xuICAgICAgdHJhbnNmZXJhYmxlT2JqZWN0cyA9IGVtcHR5VHJhbnNmZXJhYmxlT2JqZWN0QXJyYXk7XG4gICAgfSBlbHNlIGlmICghY2FuVHJhbnNmZXJBcnJheUJ1ZmZlcikge1xuICAgICAgdHJhbnNmZXJhYmxlT2JqZWN0cy5sZW5ndGggPSAwO1xuICAgIH1cblxuICAgIHZhciBpZCA9IHByb2Nlc3Nvci5fbmV4dElEKys7XG4gICAgdmFyIGRlZmVycmVkID0gd2hlbi5kZWZlcigpO1xuICAgIHByb2Nlc3Nvci5fZGVmZXJyZWRzW2lkXSA9IGRlZmVycmVkO1xuXG4gICAgcHJvY2Vzc29yLl93b3JrZXIucG9zdE1lc3NhZ2UoXG4gICAgICB7XG4gICAgICAgIGlkOiBpZCxcbiAgICAgICAgcGFyYW1ldGVyczogcGFyYW1ldGVycyxcbiAgICAgICAgY2FuVHJhbnNmZXJBcnJheUJ1ZmZlcjogY2FuVHJhbnNmZXJBcnJheUJ1ZmZlcixcbiAgICAgIH0sXG4gICAgICB0cmFuc2ZlcmFibGVPYmplY3RzXG4gICAgKTtcblxuICAgIHJldHVybiBkZWZlcnJlZC5wcm9taXNlO1xuICB9KTtcbn07XG5cbi8qKlxuICogUG9zdHMgYSBtZXNzYWdlIHRvIGEgd2ViIHdvcmtlciB3aXRoIGNvbmZpZ3VyYXRpb24gdG8gaW5pdGlhbGl6ZSBsb2FkaW5nXG4gKiBhbmQgY29tcGlsaW5nIGEgd2ViIGFzc2VtYmx5IG1vZHVsZSBhc3ljaHJvbm91c2x5LCBhcyB3ZWxsIGFzIGFuIG9wdGlvbmFsXG4gKiBmYWxsYmFjayBKYXZhU2NyaXB0IG1vZHVsZSB0byB1c2UgaWYgV2ViIEFzc2VtYmx5IGlzIG5vdCBzdXBwb3J0ZWQuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IFt3ZWJBc3NlbWJseU9wdGlvbnNdIEFuIG9iamVjdCB3aXRoIHRoZSBmb2xsb3dpbmcgcHJvcGVydGllczpcbiAqIEBwYXJhbSB7U3RyaW5nfSBbd2ViQXNzZW1ibHlPcHRpb25zLm1vZHVsZVBhdGhdIFRoZSBwYXRoIG9mIHRoZSB3ZWIgYXNzZW1ibHkgSmF2YVNjcmlwdCB3cmFwcGVyIG1vZHVsZS5cbiAqIEBwYXJhbSB7U3RyaW5nfSBbd2ViQXNzZW1ibHlPcHRpb25zLndhc21CaW5hcnlGaWxlXSBUaGUgcGF0aCBvZiB0aGUgd2ViIGFzc2VtYmx5IGJpbmFyeSBmaWxlLlxuICogQHBhcmFtIHtTdHJpbmd9IFt3ZWJBc3NlbWJseU9wdGlvbnMuZmFsbGJhY2tNb2R1bGVQYXRoXSBUaGUgcGF0aCBvZiB0aGUgZmFsbGJhY2sgSmF2YVNjcmlwdCBtb2R1bGUgdG8gdXNlIGlmIHdlYiBhc3NlbWJseSBpcyBub3Qgc3VwcG9ydGVkLlxuICogQHJldHVybnMge1Byb21pc2UuPE9iamVjdD59IEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIHRoZSByZXN1bHQgd2hlbiB0aGUgd2ViIHdvcmtlciBoYXMgbG9hZGVkIGFuZCBjb21waWxlZCB0aGUgd2ViIGFzc2VtYmx5IG1vZHVsZSBhbmQgaXMgcmVhZHkgdG8gcHJvY2VzcyB0YXNrcy5cbiAqL1xuVGFza1Byb2Nlc3Nvci5wcm90b3R5cGUuaW5pdFdlYkFzc2VtYmx5TW9kdWxlID0gZnVuY3Rpb24gKHdlYkFzc2VtYmx5T3B0aW9ucykge1xuICBpZiAoIWRlZmluZWQodGhpcy5fd29ya2VyKSkge1xuICAgIHRoaXMuX3dvcmtlciA9IGNyZWF0ZVdvcmtlcih0aGlzKTtcbiAgfVxuXG4gIHZhciBkZWZlcnJlZCA9IHdoZW4uZGVmZXIoKTtcbiAgdmFyIHByb2Nlc3NvciA9IHRoaXM7XG4gIHZhciB3b3JrZXIgPSB0aGlzLl93b3JrZXI7XG4gIGdldFdlYkFzc2VtYmx5TG9hZGVyQ29uZmlnKHRoaXMsIHdlYkFzc2VtYmx5T3B0aW9ucykudGhlbihmdW5jdGlvbiAoXG4gICAgd2FzbUNvbmZpZ1xuICApIHtcbiAgICByZXR1cm4gd2hlbihjYW5UcmFuc2ZlckFycmF5QnVmZmVyKCksIGZ1bmN0aW9uIChjYW5UcmFuc2ZlckFycmF5QnVmZmVyKSB7XG4gICAgICB2YXIgdHJhbnNmZXJhYmxlT2JqZWN0cztcbiAgICAgIHZhciBiaW5hcnkgPSB3YXNtQ29uZmlnLndhc21CaW5hcnk7XG4gICAgICBpZiAoZGVmaW5lZChiaW5hcnkpICYmIGNhblRyYW5zZmVyQXJyYXlCdWZmZXIpIHtcbiAgICAgICAgdHJhbnNmZXJhYmxlT2JqZWN0cyA9IFtiaW5hcnldO1xuICAgICAgfVxuXG4gICAgICB3b3JrZXIub25tZXNzYWdlID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgIHdvcmtlci5vbm1lc3NhZ2UgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgICBjb21wbGV0ZVRhc2socHJvY2Vzc29yLCBldmVudC5kYXRhKTtcbiAgICAgICAgfTtcblxuICAgICAgICBkZWZlcnJlZC5yZXNvbHZlKGV2ZW50LmRhdGEpO1xuICAgICAgfTtcblxuICAgICAgd29ya2VyLnBvc3RNZXNzYWdlKFxuICAgICAgICB7IHdlYkFzc2VtYmx5Q29uZmlnOiB3YXNtQ29uZmlnIH0sXG4gICAgICAgIHRyYW5zZmVyYWJsZU9iamVjdHNcbiAgICAgICk7XG4gICAgfSk7XG4gIH0pO1xuXG4gIHJldHVybiBkZWZlcnJlZDtcbn07XG5cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIHRoaXMgb2JqZWN0IHdhcyBkZXN0cm95ZWQ7IG90aGVyd2lzZSwgZmFsc2UuXG4gKiA8YnIgLz48YnIgLz5cbiAqIElmIHRoaXMgb2JqZWN0IHdhcyBkZXN0cm95ZWQsIGl0IHNob3VsZCBub3QgYmUgdXNlZDsgY2FsbGluZyBhbnkgZnVuY3Rpb24gb3RoZXIgdGhhblxuICogPGNvZGU+aXNEZXN0cm95ZWQ8L2NvZGU+IHdpbGwgcmVzdWx0IGluIGEge0BsaW5rIERldmVsb3BlckVycm9yfSBleGNlcHRpb24uXG4gKlxuICogQHJldHVybnMge0Jvb2xlYW59IFRydWUgaWYgdGhpcyBvYmplY3Qgd2FzIGRlc3Ryb3llZDsgb3RoZXJ3aXNlLCBmYWxzZS5cbiAqXG4gKiBAc2VlIFRhc2tQcm9jZXNzb3IjZGVzdHJveVxuICovXG5UYXNrUHJvY2Vzc29yLnByb3RvdHlwZS5pc0Rlc3Ryb3llZCA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIGZhbHNlO1xufTtcblxuLyoqXG4gKiBEZXN0cm95cyB0aGlzIG9iamVjdC4gIFRoaXMgd2lsbCBpbW1lZGlhdGVseSB0ZXJtaW5hdGUgdGhlIFdvcmtlci5cbiAqIDxiciAvPjxiciAvPlxuICogT25jZSBhbiBvYmplY3QgaXMgZGVzdHJveWVkLCBpdCBzaG91bGQgbm90IGJlIHVzZWQ7IGNhbGxpbmcgYW55IGZ1bmN0aW9uIG90aGVyIHRoYW5cbiAqIDxjb2RlPmlzRGVzdHJveWVkPC9jb2RlPiB3aWxsIHJlc3VsdCBpbiBhIHtAbGluayBEZXZlbG9wZXJFcnJvcn0gZXhjZXB0aW9uLlxuICovXG5UYXNrUHJvY2Vzc29yLnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24gKCkge1xuICBpZiAoZGVmaW5lZCh0aGlzLl93b3JrZXIpKSB7XG4gICAgdGhpcy5fd29ya2VyLnRlcm1pbmF0ZSgpO1xuICB9XG4gIHJldHVybiBkZXN0cm95T2JqZWN0KHRoaXMpO1xufTtcblxuLyoqXG4gKiBBbiBldmVudCB0aGF0J3MgcmFpc2VkIHdoZW4gYSB0YXNrIGlzIGNvbXBsZXRlZCBzdWNjZXNzZnVsbHkuICBFdmVudCBoYW5kbGVycyBhcmUgcGFzc2VkXG4gKiB0aGUgZXJyb3Igb2JqZWN0IGlzIGEgdGFzayBmYWlscy5cbiAqXG4gKiBAdHlwZSB7RXZlbnR9XG4gKlxuICogQHByaXZhdGVcbiAqL1xuVGFza1Byb2Nlc3Nvci50YXNrQ29tcGxldGVkRXZlbnQgPSB0YXNrQ29tcGxldGVkRXZlbnQ7XG5cbi8vIGV4cG9zZWQgZm9yIHRlc3RpbmcgcHVycG9zZXNcblRhc2tQcm9jZXNzb3IuX2RlZmF1bHRXb3JrZXJNb2R1bGVQcmVmaXggPSBcIldvcmtlcnMvXCI7XG5UYXNrUHJvY2Vzc29yLl93b3JrZXJNb2R1bGVQcmVmaXggPSBUYXNrUHJvY2Vzc29yLl9kZWZhdWx0V29ya2VyTW9kdWxlUHJlZml4O1xuVGFza1Byb2Nlc3Nvci5fY2FuVHJhbnNmZXJBcnJheUJ1ZmZlciA9IHVuZGVmaW5lZDtcbmV4cG9ydCBkZWZhdWx0IFRhc2tQcm9jZXNzb3I7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///2819\n')},99978:function(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__){eval('/* harmony import */ var _DeveloperError_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(12572);\n\n\n/**\n * Terrain data for a single tile.  This type describes an\n * interface and is not intended to be instantiated directly.\n *\n * @alias TerrainData\n * @constructor\n *\n * @see HeightmapTerrainData\n * @see QuantizedMeshTerrainData\n * @see GoogleEarthEnterpriseTerrainData\n */\nfunction TerrainData() {\n  _DeveloperError_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].throwInstantiationError */ .Z.throwInstantiationError();\n}\n\nObject.defineProperties(TerrainData.prototype, {\n  /**\n   * An array of credits for this tile.\n   * @memberof TerrainData.prototype\n   * @type {Credit[]}\n   */\n  credits: {\n    get: _DeveloperError_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].throwInstantiationError */ .Z.throwInstantiationError,\n  },\n  /**\n   * The water mask included in this terrain data, if any.  A water mask is a rectangular\n   * Uint8Array or image where a value of 255 indicates water and a value of 0 indicates land.\n   * Values in between 0 and 255 are allowed as well to smoothly blend between land and water.\n   * @memberof TerrainData.prototype\n   * @type {Uint8Array|HTMLImageElement|HTMLCanvasElement}\n   */\n  waterMask: {\n    get: _DeveloperError_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].throwInstantiationError */ .Z.throwInstantiationError,\n  },\n});\n\n/**\n * Computes the terrain height at a specified longitude and latitude.\n * @function\n *\n * @param {Rectangle} rectangle The rectangle covered by this terrain data.\n * @param {Number} longitude The longitude in radians.\n * @param {Number} latitude The latitude in radians.\n * @returns {Number} The terrain height at the specified position.  If the position\n *          is outside the rectangle, this method will extrapolate the height, which is likely to be wildly\n *          incorrect for positions far outside the rectangle.\n */\nTerrainData.prototype.interpolateHeight =\n  _DeveloperError_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].throwInstantiationError */ .Z.throwInstantiationError;\n\n/**\n * Determines if a given child tile is available, based on the\n * {@link TerrainData#childTileMask}.  The given child tile coordinates are assumed\n * to be one of the four children of this tile.  If non-child tile coordinates are\n * given, the availability of the southeast child tile is returned.\n * @function\n *\n * @param {Number} thisX The tile X coordinate of this (the parent) tile.\n * @param {Number} thisY The tile Y coordinate of this (the parent) tile.\n * @param {Number} childX The tile X coordinate of the child tile to check for availability.\n * @param {Number} childY The tile Y coordinate of the child tile to check for availability.\n * @returns {Boolean} True if the child tile is available; otherwise, false.\n */\nTerrainData.prototype.isChildAvailable = _DeveloperError_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].throwInstantiationError */ .Z.throwInstantiationError;\n\n/**\n * Creates a {@link TerrainMesh} from this terrain data.\n * @function\n *\n * @private\n *\n * @param {Object} options Object with the following properties:\n * @param {TilingScheme} options.tilingScheme The tiling scheme to which this tile belongs.\n * @param {Number} options.x The X coordinate of the tile for which to create the terrain data.\n * @param {Number} options.y The Y coordinate of the tile for which to create the terrain data.\n * @param {Number} options.level The level of the tile for which to create the terrain data.\n * @param {Number} [options.exaggeration=1.0] The scale used to exaggerate the terrain.\n * @param {Number} [options.exaggerationRelativeHeight=0.0] The height relative to which terrain is exaggerated.\n * @param {Boolean} [options.throttle=true] If true, indicates that this operation will need to be retried if too many asynchronous mesh creations are already in progress.\n * @returns {Promise.<TerrainMesh>|undefined} A promise for the terrain mesh, or undefined if too many\n *          asynchronous mesh creations are already in progress and the operation should\n *          be retried later.\n */\nTerrainData.prototype.createMesh = _DeveloperError_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].throwInstantiationError */ .Z.throwInstantiationError;\n\n/**\n * Upsamples this terrain data for use by a descendant tile.\n * @function\n *\n * @param {TilingScheme} tilingScheme The tiling scheme of this terrain data.\n * @param {Number} thisX The X coordinate of this tile in the tiling scheme.\n * @param {Number} thisY The Y coordinate of this tile in the tiling scheme.\n * @param {Number} thisLevel The level of this tile in the tiling scheme.\n * @param {Number} descendantX The X coordinate within the tiling scheme of the descendant tile for which we are upsampling.\n * @param {Number} descendantY The Y coordinate within the tiling scheme of the descendant tile for which we are upsampling.\n * @param {Number} descendantLevel The level within the tiling scheme of the descendant tile for which we are upsampling.\n * @returns {Promise.<TerrainData>|undefined} A promise for upsampled terrain data for the descendant tile,\n *          or undefined if too many asynchronous upsample operations are in progress and the request has been\n *          deferred.\n */\nTerrainData.prototype.upsample = _DeveloperError_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].throwInstantiationError */ .Z.throwInstantiationError;\n\n/**\n * Gets a value indicating whether or not this terrain data was created by upsampling lower resolution\n * terrain data.  If this value is false, the data was obtained from some other source, such\n * as by downloading it from a remote server.  This method should return true for instances\n * returned from a call to {@link TerrainData#upsample}.\n * @function\n *\n * @returns {Boolean} True if this instance was created by upsampling; otherwise, false.\n */\nTerrainData.prototype.wasCreatedByUpsampling =\n  _DeveloperError_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].throwInstantiationError */ .Z.throwInstantiationError;\n\n/**\n * The maximum number of asynchronous tasks used for terrain processing.\n *\n * @type {Number}\n * @private\n */\nTerrainData.maximumAsynchronousTasks = 5;\n\n/* harmony default export */ __webpack_exports__["Z"] = (TerrainData);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiOTk5NzguanMiLCJtYXBwaW5ncyI6IjtBQUFpRDs7QUFFakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRSxtSEFBc0M7QUFDeEM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBLFNBQVMsbUhBQXNDO0FBQy9DLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQSxTQUFTLG1IQUFzQztBQUMvQyxHQUFHO0FBQ0gsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsV0FBVztBQUN0QixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUUsbUhBQXNDOztBQUV4QztBQUNBO0FBQ0EsSUFBSSxnQ0FBZ0M7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsYUFBYSxTQUFTLHFDQUFxQztBQUMzRDtBQUNBLHlDQUF5QyxtSEFBc0M7O0FBRS9FO0FBQ0EsY0FBYyxtQkFBbUI7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxjQUFjO0FBQ3pCLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxTQUFTO0FBQ3BCLGFBQWEsaUNBQWlDO0FBQzlDO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyxtSEFBc0M7O0FBRXpFO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxjQUFjO0FBQ3pCLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLGFBQWEsaUNBQWlDO0FBQzlDO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxtSEFBc0M7O0FBRXZFO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLDJCQUEyQjtBQUN2RDtBQUNBO0FBQ0EsYUFBYSxTQUFTLGlEQUFpRDtBQUN2RTtBQUNBO0FBQ0EsRUFBRSxtSEFBc0M7O0FBRXhDO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7O0FBRUEseURBQWUsV0FBVyxFQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdnVlMy13ZWJwYWNrNS8uL25vZGVfbW9kdWxlcy9jZXNpdW0vU291cmNlL0NvcmUvVGVycmFpbkRhdGEuanM/MTY2ZSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgRGV2ZWxvcGVyRXJyb3IgZnJvbSBcIi4vRGV2ZWxvcGVyRXJyb3IuanNcIjtcblxuLyoqXG4gKiBUZXJyYWluIGRhdGEgZm9yIGEgc2luZ2xlIHRpbGUuICBUaGlzIHR5cGUgZGVzY3JpYmVzIGFuXG4gKiBpbnRlcmZhY2UgYW5kIGlzIG5vdCBpbnRlbmRlZCB0byBiZSBpbnN0YW50aWF0ZWQgZGlyZWN0bHkuXG4gKlxuICogQGFsaWFzIFRlcnJhaW5EYXRhXG4gKiBAY29uc3RydWN0b3JcbiAqXG4gKiBAc2VlIEhlaWdodG1hcFRlcnJhaW5EYXRhXG4gKiBAc2VlIFF1YW50aXplZE1lc2hUZXJyYWluRGF0YVxuICogQHNlZSBHb29nbGVFYXJ0aEVudGVycHJpc2VUZXJyYWluRGF0YVxuICovXG5mdW5jdGlvbiBUZXJyYWluRGF0YSgpIHtcbiAgRGV2ZWxvcGVyRXJyb3IudGhyb3dJbnN0YW50aWF0aW9uRXJyb3IoKTtcbn1cblxuT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoVGVycmFpbkRhdGEucHJvdG90eXBlLCB7XG4gIC8qKlxuICAgKiBBbiBhcnJheSBvZiBjcmVkaXRzIGZvciB0aGlzIHRpbGUuXG4gICAqIEBtZW1iZXJvZiBUZXJyYWluRGF0YS5wcm90b3R5cGVcbiAgICogQHR5cGUge0NyZWRpdFtdfVxuICAgKi9cbiAgY3JlZGl0czoge1xuICAgIGdldDogRGV2ZWxvcGVyRXJyb3IudGhyb3dJbnN0YW50aWF0aW9uRXJyb3IsXG4gIH0sXG4gIC8qKlxuICAgKiBUaGUgd2F0ZXIgbWFzayBpbmNsdWRlZCBpbiB0aGlzIHRlcnJhaW4gZGF0YSwgaWYgYW55LiAgQSB3YXRlciBtYXNrIGlzIGEgcmVjdGFuZ3VsYXJcbiAgICogVWludDhBcnJheSBvciBpbWFnZSB3aGVyZSBhIHZhbHVlIG9mIDI1NSBpbmRpY2F0ZXMgd2F0ZXIgYW5kIGEgdmFsdWUgb2YgMCBpbmRpY2F0ZXMgbGFuZC5cbiAgICogVmFsdWVzIGluIGJldHdlZW4gMCBhbmQgMjU1IGFyZSBhbGxvd2VkIGFzIHdlbGwgdG8gc21vb3RobHkgYmxlbmQgYmV0d2VlbiBsYW5kIGFuZCB3YXRlci5cbiAgICogQG1lbWJlcm9mIFRlcnJhaW5EYXRhLnByb3RvdHlwZVxuICAgKiBAdHlwZSB7VWludDhBcnJheXxIVE1MSW1hZ2VFbGVtZW50fEhUTUxDYW52YXNFbGVtZW50fVxuICAgKi9cbiAgd2F0ZXJNYXNrOiB7XG4gICAgZ2V0OiBEZXZlbG9wZXJFcnJvci50aHJvd0luc3RhbnRpYXRpb25FcnJvcixcbiAgfSxcbn0pO1xuXG4vKipcbiAqIENvbXB1dGVzIHRoZSB0ZXJyYWluIGhlaWdodCBhdCBhIHNwZWNpZmllZCBsb25naXR1ZGUgYW5kIGxhdGl0dWRlLlxuICogQGZ1bmN0aW9uXG4gKlxuICogQHBhcmFtIHtSZWN0YW5nbGV9IHJlY3RhbmdsZSBUaGUgcmVjdGFuZ2xlIGNvdmVyZWQgYnkgdGhpcyB0ZXJyYWluIGRhdGEuXG4gKiBAcGFyYW0ge051bWJlcn0gbG9uZ2l0dWRlIFRoZSBsb25naXR1ZGUgaW4gcmFkaWFucy5cbiAqIEBwYXJhbSB7TnVtYmVyfSBsYXRpdHVkZSBUaGUgbGF0aXR1ZGUgaW4gcmFkaWFucy5cbiAqIEByZXR1cm5zIHtOdW1iZXJ9IFRoZSB0ZXJyYWluIGhlaWdodCBhdCB0aGUgc3BlY2lmaWVkIHBvc2l0aW9uLiAgSWYgdGhlIHBvc2l0aW9uXG4gKiAgICAgICAgICBpcyBvdXRzaWRlIHRoZSByZWN0YW5nbGUsIHRoaXMgbWV0aG9kIHdpbGwgZXh0cmFwb2xhdGUgdGhlIGhlaWdodCwgd2hpY2ggaXMgbGlrZWx5IHRvIGJlIHdpbGRseVxuICogICAgICAgICAgaW5jb3JyZWN0IGZvciBwb3NpdGlvbnMgZmFyIG91dHNpZGUgdGhlIHJlY3RhbmdsZS5cbiAqL1xuVGVycmFpbkRhdGEucHJvdG90eXBlLmludGVycG9sYXRlSGVpZ2h0ID1cbiAgRGV2ZWxvcGVyRXJyb3IudGhyb3dJbnN0YW50aWF0aW9uRXJyb3I7XG5cbi8qKlxuICogRGV0ZXJtaW5lcyBpZiBhIGdpdmVuIGNoaWxkIHRpbGUgaXMgYXZhaWxhYmxlLCBiYXNlZCBvbiB0aGVcbiAqIHtAbGluayBUZXJyYWluRGF0YSNjaGlsZFRpbGVNYXNrfS4gIFRoZSBnaXZlbiBjaGlsZCB0aWxlIGNvb3JkaW5hdGVzIGFyZSBhc3N1bWVkXG4gKiB0byBiZSBvbmUgb2YgdGhlIGZvdXIgY2hpbGRyZW4gb2YgdGhpcyB0aWxlLiAgSWYgbm9uLWNoaWxkIHRpbGUgY29vcmRpbmF0ZXMgYXJlXG4gKiBnaXZlbiwgdGhlIGF2YWlsYWJpbGl0eSBvZiB0aGUgc291dGhlYXN0IGNoaWxkIHRpbGUgaXMgcmV0dXJuZWQuXG4gKiBAZnVuY3Rpb25cbiAqXG4gKiBAcGFyYW0ge051bWJlcn0gdGhpc1ggVGhlIHRpbGUgWCBjb29yZGluYXRlIG9mIHRoaXMgKHRoZSBwYXJlbnQpIHRpbGUuXG4gKiBAcGFyYW0ge051bWJlcn0gdGhpc1kgVGhlIHRpbGUgWSBjb29yZGluYXRlIG9mIHRoaXMgKHRoZSBwYXJlbnQpIHRpbGUuXG4gKiBAcGFyYW0ge051bWJlcn0gY2hpbGRYIFRoZSB0aWxlIFggY29vcmRpbmF0ZSBvZiB0aGUgY2hpbGQgdGlsZSB0byBjaGVjayBmb3IgYXZhaWxhYmlsaXR5LlxuICogQHBhcmFtIHtOdW1iZXJ9IGNoaWxkWSBUaGUgdGlsZSBZIGNvb3JkaW5hdGUgb2YgdGhlIGNoaWxkIHRpbGUgdG8gY2hlY2sgZm9yIGF2YWlsYWJpbGl0eS5cbiAqIEByZXR1cm5zIHtCb29sZWFufSBUcnVlIGlmIHRoZSBjaGlsZCB0aWxlIGlzIGF2YWlsYWJsZTsgb3RoZXJ3aXNlLCBmYWxzZS5cbiAqL1xuVGVycmFpbkRhdGEucHJvdG90eXBlLmlzQ2hpbGRBdmFpbGFibGUgPSBEZXZlbG9wZXJFcnJvci50aHJvd0luc3RhbnRpYXRpb25FcnJvcjtcblxuLyoqXG4gKiBDcmVhdGVzIGEge0BsaW5rIFRlcnJhaW5NZXNofSBmcm9tIHRoaXMgdGVycmFpbiBkYXRhLlxuICogQGZ1bmN0aW9uXG4gKlxuICogQHByaXZhdGVcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyBPYmplY3Qgd2l0aCB0aGUgZm9sbG93aW5nIHByb3BlcnRpZXM6XG4gKiBAcGFyYW0ge1RpbGluZ1NjaGVtZX0gb3B0aW9ucy50aWxpbmdTY2hlbWUgVGhlIHRpbGluZyBzY2hlbWUgdG8gd2hpY2ggdGhpcyB0aWxlIGJlbG9uZ3MuXG4gKiBAcGFyYW0ge051bWJlcn0gb3B0aW9ucy54IFRoZSBYIGNvb3JkaW5hdGUgb2YgdGhlIHRpbGUgZm9yIHdoaWNoIHRvIGNyZWF0ZSB0aGUgdGVycmFpbiBkYXRhLlxuICogQHBhcmFtIHtOdW1iZXJ9IG9wdGlvbnMueSBUaGUgWSBjb29yZGluYXRlIG9mIHRoZSB0aWxlIGZvciB3aGljaCB0byBjcmVhdGUgdGhlIHRlcnJhaW4gZGF0YS5cbiAqIEBwYXJhbSB7TnVtYmVyfSBvcHRpb25zLmxldmVsIFRoZSBsZXZlbCBvZiB0aGUgdGlsZSBmb3Igd2hpY2ggdG8gY3JlYXRlIHRoZSB0ZXJyYWluIGRhdGEuXG4gKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMuZXhhZ2dlcmF0aW9uPTEuMF0gVGhlIHNjYWxlIHVzZWQgdG8gZXhhZ2dlcmF0ZSB0aGUgdGVycmFpbi5cbiAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5leGFnZ2VyYXRpb25SZWxhdGl2ZUhlaWdodD0wLjBdIFRoZSBoZWlnaHQgcmVsYXRpdmUgdG8gd2hpY2ggdGVycmFpbiBpcyBleGFnZ2VyYXRlZC5cbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMudGhyb3R0bGU9dHJ1ZV0gSWYgdHJ1ZSwgaW5kaWNhdGVzIHRoYXQgdGhpcyBvcGVyYXRpb24gd2lsbCBuZWVkIHRvIGJlIHJldHJpZWQgaWYgdG9vIG1hbnkgYXN5bmNocm9ub3VzIG1lc2ggY3JlYXRpb25zIGFyZSBhbHJlYWR5IGluIHByb2dyZXNzLlxuICogQHJldHVybnMge1Byb21pc2UuPFRlcnJhaW5NZXNoPnx1bmRlZmluZWR9IEEgcHJvbWlzZSBmb3IgdGhlIHRlcnJhaW4gbWVzaCwgb3IgdW5kZWZpbmVkIGlmIHRvbyBtYW55XG4gKiAgICAgICAgICBhc3luY2hyb25vdXMgbWVzaCBjcmVhdGlvbnMgYXJlIGFscmVhZHkgaW4gcHJvZ3Jlc3MgYW5kIHRoZSBvcGVyYXRpb24gc2hvdWxkXG4gKiAgICAgICAgICBiZSByZXRyaWVkIGxhdGVyLlxuICovXG5UZXJyYWluRGF0YS5wcm90b3R5cGUuY3JlYXRlTWVzaCA9IERldmVsb3BlckVycm9yLnRocm93SW5zdGFudGlhdGlvbkVycm9yO1xuXG4vKipcbiAqIFVwc2FtcGxlcyB0aGlzIHRlcnJhaW4gZGF0YSBmb3IgdXNlIGJ5IGEgZGVzY2VuZGFudCB0aWxlLlxuICogQGZ1bmN0aW9uXG4gKlxuICogQHBhcmFtIHtUaWxpbmdTY2hlbWV9IHRpbGluZ1NjaGVtZSBUaGUgdGlsaW5nIHNjaGVtZSBvZiB0aGlzIHRlcnJhaW4gZGF0YS5cbiAqIEBwYXJhbSB7TnVtYmVyfSB0aGlzWCBUaGUgWCBjb29yZGluYXRlIG9mIHRoaXMgdGlsZSBpbiB0aGUgdGlsaW5nIHNjaGVtZS5cbiAqIEBwYXJhbSB7TnVtYmVyfSB0aGlzWSBUaGUgWSBjb29yZGluYXRlIG9mIHRoaXMgdGlsZSBpbiB0aGUgdGlsaW5nIHNjaGVtZS5cbiAqIEBwYXJhbSB7TnVtYmVyfSB0aGlzTGV2ZWwgVGhlIGxldmVsIG9mIHRoaXMgdGlsZSBpbiB0aGUgdGlsaW5nIHNjaGVtZS5cbiAqIEBwYXJhbSB7TnVtYmVyfSBkZXNjZW5kYW50WCBUaGUgWCBjb29yZGluYXRlIHdpdGhpbiB0aGUgdGlsaW5nIHNjaGVtZSBvZiB0aGUgZGVzY2VuZGFudCB0aWxlIGZvciB3aGljaCB3ZSBhcmUgdXBzYW1wbGluZy5cbiAqIEBwYXJhbSB7TnVtYmVyfSBkZXNjZW5kYW50WSBUaGUgWSBjb29yZGluYXRlIHdpdGhpbiB0aGUgdGlsaW5nIHNjaGVtZSBvZiB0aGUgZGVzY2VuZGFudCB0aWxlIGZvciB3aGljaCB3ZSBhcmUgdXBzYW1wbGluZy5cbiAqIEBwYXJhbSB7TnVtYmVyfSBkZXNjZW5kYW50TGV2ZWwgVGhlIGxldmVsIHdpdGhpbiB0aGUgdGlsaW5nIHNjaGVtZSBvZiB0aGUgZGVzY2VuZGFudCB0aWxlIGZvciB3aGljaCB3ZSBhcmUgdXBzYW1wbGluZy5cbiAqIEByZXR1cm5zIHtQcm9taXNlLjxUZXJyYWluRGF0YT58dW5kZWZpbmVkfSBBIHByb21pc2UgZm9yIHVwc2FtcGxlZCB0ZXJyYWluIGRhdGEgZm9yIHRoZSBkZXNjZW5kYW50IHRpbGUsXG4gKiAgICAgICAgICBvciB1bmRlZmluZWQgaWYgdG9vIG1hbnkgYXN5bmNocm9ub3VzIHVwc2FtcGxlIG9wZXJhdGlvbnMgYXJlIGluIHByb2dyZXNzIGFuZCB0aGUgcmVxdWVzdCBoYXMgYmVlblxuICogICAgICAgICAgZGVmZXJyZWQuXG4gKi9cblRlcnJhaW5EYXRhLnByb3RvdHlwZS51cHNhbXBsZSA9IERldmVsb3BlckVycm9yLnRocm93SW5zdGFudGlhdGlvbkVycm9yO1xuXG4vKipcbiAqIEdldHMgYSB2YWx1ZSBpbmRpY2F0aW5nIHdoZXRoZXIgb3Igbm90IHRoaXMgdGVycmFpbiBkYXRhIHdhcyBjcmVhdGVkIGJ5IHVwc2FtcGxpbmcgbG93ZXIgcmVzb2x1dGlvblxuICogdGVycmFpbiBkYXRhLiAgSWYgdGhpcyB2YWx1ZSBpcyBmYWxzZSwgdGhlIGRhdGEgd2FzIG9idGFpbmVkIGZyb20gc29tZSBvdGhlciBzb3VyY2UsIHN1Y2hcbiAqIGFzIGJ5IGRvd25sb2FkaW5nIGl0IGZyb20gYSByZW1vdGUgc2VydmVyLiAgVGhpcyBtZXRob2Qgc2hvdWxkIHJldHVybiB0cnVlIGZvciBpbnN0YW5jZXNcbiAqIHJldHVybmVkIGZyb20gYSBjYWxsIHRvIHtAbGluayBUZXJyYWluRGF0YSN1cHNhbXBsZX0uXG4gKiBAZnVuY3Rpb25cbiAqXG4gKiBAcmV0dXJucyB7Qm9vbGVhbn0gVHJ1ZSBpZiB0aGlzIGluc3RhbmNlIHdhcyBjcmVhdGVkIGJ5IHVwc2FtcGxpbmc7IG90aGVyd2lzZSwgZmFsc2UuXG4gKi9cblRlcnJhaW5EYXRhLnByb3RvdHlwZS53YXNDcmVhdGVkQnlVcHNhbXBsaW5nID1cbiAgRGV2ZWxvcGVyRXJyb3IudGhyb3dJbnN0YW50aWF0aW9uRXJyb3I7XG5cbi8qKlxuICogVGhlIG1heGltdW0gbnVtYmVyIG9mIGFzeW5jaHJvbm91cyB0YXNrcyB1c2VkIGZvciB0ZXJyYWluIHByb2Nlc3NpbmcuXG4gKlxuICogQHR5cGUge051bWJlcn1cbiAqIEBwcml2YXRlXG4gKi9cblRlcnJhaW5EYXRhLm1heGltdW1Bc3luY2hyb25vdXNUYXNrcyA9IDU7XG5cbmV4cG9ydCBkZWZhdWx0IFRlcnJhaW5EYXRhO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///99978\n')},41782:function(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__){eval('/* harmony import */ var _AttributeCompression_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(52323);\n/* harmony import */ var _Cartesian2_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(60838);\n/* harmony import */ var _Cartesian3_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(60216);\n/* harmony import */ var _ComponentDatatype_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(84828);\n/* harmony import */ var _defaultValue_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(62200);\n/* harmony import */ var _defined_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(82982);\n/* harmony import */ var _Math_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(99417);\n/* harmony import */ var _Matrix4_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(72248);\n/* harmony import */ var _TerrainExaggeration_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(78257);\n/* harmony import */ var _TerrainQuantization_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(735);\n\n\n\n\n\n\n\n\n\n\n\nvar cartesian3Scratch = new _Cartesian3_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"] */ .Z();\nvar cartesian3DimScratch = new _Cartesian3_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"] */ .Z();\nvar cartesian2Scratch = new _Cartesian2_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .Z();\nvar matrix4Scratch = new _Matrix4_js__WEBPACK_IMPORTED_MODULE_6__/* ["default"] */ .Z();\nvar matrix4Scratch2 = new _Matrix4_js__WEBPACK_IMPORTED_MODULE_6__/* ["default"] */ .Z();\n\nvar SHIFT_LEFT_12 = Math.pow(2.0, 12.0);\n\n/**\n * Data used to quantize and pack the terrain mesh. The position can be unpacked for picking and all attributes\n * are unpacked in the vertex shader.\n *\n * @alias TerrainEncoding\n * @constructor\n *\n * @param {Cartesian3} center The center point of the vertices.\n * @param {AxisAlignedBoundingBox} axisAlignedBoundingBox The bounds of the tile in the east-north-up coordinates at the tiles center.\n * @param {Number} minimumHeight The minimum height.\n * @param {Number} maximumHeight The maximum height.\n * @param {Matrix4} fromENU The east-north-up to fixed frame matrix at the center of the terrain mesh.\n * @param {Boolean} hasVertexNormals If the mesh has vertex normals.\n * @param {Boolean} [hasWebMercatorT=false] true if the terrain data includes a Web Mercator texture coordinate; otherwise, false.\n * @param {Boolean} [hasGeodeticSurfaceNormals=false] true if the terrain data includes geodetic surface normals; otherwise, false.\n * @param {Number} [exaggeration=1.0] A scalar used to exaggerate terrain.\n * @param {Number} [exaggerationRelativeHeight=0.0] The relative height from which terrain is exaggerated.\n *\n * @private\n */\nfunction TerrainEncoding(\n  center,\n  axisAlignedBoundingBox,\n  minimumHeight,\n  maximumHeight,\n  fromENU,\n  hasVertexNormals,\n  hasWebMercatorT,\n  hasGeodeticSurfaceNormals,\n  exaggeration,\n  exaggerationRelativeHeight\n) {\n  var quantization = _TerrainQuantization_js__WEBPACK_IMPORTED_MODULE_8__/* ["default"].NONE */ .Z.NONE;\n  var toENU;\n  var matrix;\n\n  if (\n    (0,_defined_js__WEBPACK_IMPORTED_MODULE_9__/* ["default"] */ .Z)(axisAlignedBoundingBox) &&\n    (0,_defined_js__WEBPACK_IMPORTED_MODULE_9__/* ["default"] */ .Z)(minimumHeight) &&\n    (0,_defined_js__WEBPACK_IMPORTED_MODULE_9__/* ["default"] */ .Z)(maximumHeight) &&\n    (0,_defined_js__WEBPACK_IMPORTED_MODULE_9__/* ["default"] */ .Z)(fromENU)\n  ) {\n    var minimum = axisAlignedBoundingBox.minimum;\n    var maximum = axisAlignedBoundingBox.maximum;\n\n    var dimensions = _Cartesian3_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"].subtract */ .Z.subtract(\n      maximum,\n      minimum,\n      cartesian3DimScratch\n    );\n    var hDim = maximumHeight - minimumHeight;\n    var maxDim = Math.max(_Cartesian3_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"].maximumComponent */ .Z.maximumComponent(dimensions), hDim);\n\n    if (maxDim < SHIFT_LEFT_12 - 1.0) {\n      quantization = _TerrainQuantization_js__WEBPACK_IMPORTED_MODULE_8__/* ["default"].BITS12 */ .Z.BITS12;\n    } else {\n      quantization = _TerrainQuantization_js__WEBPACK_IMPORTED_MODULE_8__/* ["default"].NONE */ .Z.NONE;\n    }\n\n    toENU = _Matrix4_js__WEBPACK_IMPORTED_MODULE_6__/* ["default"].inverseTransformation */ .Z.inverseTransformation(fromENU, new _Matrix4_js__WEBPACK_IMPORTED_MODULE_6__/* ["default"] */ .Z());\n\n    var translation = _Cartesian3_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"].negate */ .Z.negate(minimum, cartesian3Scratch);\n    _Matrix4_js__WEBPACK_IMPORTED_MODULE_6__/* ["default"].multiply */ .Z.multiply(\n      _Matrix4_js__WEBPACK_IMPORTED_MODULE_6__/* ["default"].fromTranslation */ .Z.fromTranslation(translation, matrix4Scratch),\n      toENU,\n      toENU\n    );\n\n    var scale = cartesian3Scratch;\n    scale.x = 1.0 / dimensions.x;\n    scale.y = 1.0 / dimensions.y;\n    scale.z = 1.0 / dimensions.z;\n    _Matrix4_js__WEBPACK_IMPORTED_MODULE_6__/* ["default"].multiply */ .Z.multiply(_Matrix4_js__WEBPACK_IMPORTED_MODULE_6__/* ["default"].fromScale */ .Z.fromScale(scale, matrix4Scratch), toENU, toENU);\n\n    matrix = _Matrix4_js__WEBPACK_IMPORTED_MODULE_6__/* ["default"].clone */ .Z.clone(fromENU);\n    _Matrix4_js__WEBPACK_IMPORTED_MODULE_6__/* ["default"].setTranslation */ .Z.setTranslation(matrix, _Cartesian3_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"].ZERO */ .Z.ZERO, matrix);\n\n    fromENU = _Matrix4_js__WEBPACK_IMPORTED_MODULE_6__/* ["default"].clone */ .Z.clone(fromENU, new _Matrix4_js__WEBPACK_IMPORTED_MODULE_6__/* ["default"] */ .Z());\n\n    var translationMatrix = _Matrix4_js__WEBPACK_IMPORTED_MODULE_6__/* ["default"].fromTranslation */ .Z.fromTranslation(minimum, matrix4Scratch);\n    var scaleMatrix = _Matrix4_js__WEBPACK_IMPORTED_MODULE_6__/* ["default"].fromScale */ .Z.fromScale(dimensions, matrix4Scratch2);\n    var st = _Matrix4_js__WEBPACK_IMPORTED_MODULE_6__/* ["default"].multiply */ .Z.multiply(translationMatrix, scaleMatrix, matrix4Scratch);\n\n    _Matrix4_js__WEBPACK_IMPORTED_MODULE_6__/* ["default"].multiply */ .Z.multiply(fromENU, st, fromENU);\n    _Matrix4_js__WEBPACK_IMPORTED_MODULE_6__/* ["default"].multiply */ .Z.multiply(matrix, st, matrix);\n  }\n\n  /**\n   * How the vertices of the mesh were compressed.\n   * @type {TerrainQuantization}\n   */\n  this.quantization = quantization;\n\n  /**\n   * The minimum height of the tile including the skirts.\n   * @type {Number}\n   */\n  this.minimumHeight = minimumHeight;\n\n  /**\n   * The maximum height of the tile.\n   * @type {Number}\n   */\n  this.maximumHeight = maximumHeight;\n\n  /**\n   * The center of the tile.\n   * @type {Cartesian3}\n   */\n  this.center = _Cartesian3_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"].clone */ .Z.clone(center);\n\n  /**\n   * A matrix that takes a vertex from the tile, transforms it to east-north-up at the center and scales\n   * it so each component is in the [0, 1] range.\n   * @type {Matrix4}\n   */\n  this.toScaledENU = toENU;\n\n  /**\n   * A matrix that restores a vertex transformed with toScaledENU back to the earth fixed reference frame\n   * @type {Matrix4}\n   */\n  this.fromScaledENU = fromENU;\n\n  /**\n   * The matrix used to decompress the terrain vertices in the shader for RTE rendering.\n   * @type {Matrix4}\n   */\n  this.matrix = matrix;\n\n  /**\n   * The terrain mesh contains normals.\n   * @type {Boolean}\n   */\n  this.hasVertexNormals = hasVertexNormals;\n\n  /**\n   * The terrain mesh contains a vertical texture coordinate following the Web Mercator projection.\n   * @type {Boolean}\n   */\n  this.hasWebMercatorT = (0,_defaultValue_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .Z)(hasWebMercatorT, false);\n\n  /**\n   * The terrain mesh contains geodetic surface normals, used for terrain exaggeration.\n   * @type {Boolean}\n   */\n  this.hasGeodeticSurfaceNormals = (0,_defaultValue_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .Z)(\n    hasGeodeticSurfaceNormals,\n    false\n  );\n\n  /**\n   * A scalar used to exaggerate terrain.\n   * @type {Number}\n   */\n  this.exaggeration = (0,_defaultValue_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .Z)(exaggeration, 1.0);\n\n  /**\n   * The relative height from which terrain is exaggerated.\n   */\n  this.exaggerationRelativeHeight = (0,_defaultValue_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .Z)(\n    exaggerationRelativeHeight,\n    0.0\n  );\n\n  /**\n   * The number of components in each vertex. This value can differ with different quantizations.\n   * @type {Number}\n   */\n  this.stride = 0;\n\n  this._offsetGeodeticSurfaceNormal = 0;\n  this._offsetVertexNormal = 0;\n\n  // Calculate the stride and offsets declared above\n  this._calculateStrideAndOffsets();\n}\n\nTerrainEncoding.prototype.encode = function (\n  vertexBuffer,\n  bufferIndex,\n  position,\n  uv,\n  height,\n  normalToPack,\n  webMercatorT,\n  geodeticSurfaceNormal\n) {\n  var u = uv.x;\n  var v = uv.y;\n\n  if (this.quantization === _TerrainQuantization_js__WEBPACK_IMPORTED_MODULE_8__/* ["default"].BITS12 */ .Z.BITS12) {\n    position = _Matrix4_js__WEBPACK_IMPORTED_MODULE_6__/* ["default"].multiplyByPoint */ .Z.multiplyByPoint(\n      this.toScaledENU,\n      position,\n      cartesian3Scratch\n    );\n\n    position.x = _Math_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"].clamp */ .Z.clamp(position.x, 0.0, 1.0);\n    position.y = _Math_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"].clamp */ .Z.clamp(position.y, 0.0, 1.0);\n    position.z = _Math_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"].clamp */ .Z.clamp(position.z, 0.0, 1.0);\n\n    var hDim = this.maximumHeight - this.minimumHeight;\n    var h = _Math_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"].clamp */ .Z.clamp((height - this.minimumHeight) / hDim, 0.0, 1.0);\n\n    _Cartesian2_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"].fromElements */ .Z.fromElements(position.x, position.y, cartesian2Scratch);\n    var compressed0 = _AttributeCompression_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].compressTextureCoordinates */ .Z.compressTextureCoordinates(\n      cartesian2Scratch\n    );\n\n    _Cartesian2_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"].fromElements */ .Z.fromElements(position.z, h, cartesian2Scratch);\n    var compressed1 = _AttributeCompression_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].compressTextureCoordinates */ .Z.compressTextureCoordinates(\n      cartesian2Scratch\n    );\n\n    _Cartesian2_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"].fromElements */ .Z.fromElements(u, v, cartesian2Scratch);\n    var compressed2 = _AttributeCompression_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].compressTextureCoordinates */ .Z.compressTextureCoordinates(\n      cartesian2Scratch\n    );\n\n    vertexBuffer[bufferIndex++] = compressed0;\n    vertexBuffer[bufferIndex++] = compressed1;\n    vertexBuffer[bufferIndex++] = compressed2;\n\n    if (this.hasWebMercatorT) {\n      _Cartesian2_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"].fromElements */ .Z.fromElements(webMercatorT, 0.0, cartesian2Scratch);\n      var compressed3 = _AttributeCompression_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].compressTextureCoordinates */ .Z.compressTextureCoordinates(\n        cartesian2Scratch\n      );\n      vertexBuffer[bufferIndex++] = compressed3;\n    }\n  } else {\n    _Cartesian3_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"].subtract */ .Z.subtract(position, this.center, cartesian3Scratch);\n\n    vertexBuffer[bufferIndex++] = cartesian3Scratch.x;\n    vertexBuffer[bufferIndex++] = cartesian3Scratch.y;\n    vertexBuffer[bufferIndex++] = cartesian3Scratch.z;\n    vertexBuffer[bufferIndex++] = height;\n    vertexBuffer[bufferIndex++] = u;\n    vertexBuffer[bufferIndex++] = v;\n\n    if (this.hasWebMercatorT) {\n      vertexBuffer[bufferIndex++] = webMercatorT;\n    }\n  }\n\n  if (this.hasVertexNormals) {\n    vertexBuffer[bufferIndex++] = _AttributeCompression_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].octPackFloat */ .Z.octPackFloat(\n      normalToPack\n    );\n  }\n\n  if (this.hasGeodeticSurfaceNormals) {\n    vertexBuffer[bufferIndex++] = geodeticSurfaceNormal.x;\n    vertexBuffer[bufferIndex++] = geodeticSurfaceNormal.y;\n    vertexBuffer[bufferIndex++] = geodeticSurfaceNormal.z;\n  }\n\n  return bufferIndex;\n};\n\nvar scratchPosition = new _Cartesian3_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"] */ .Z();\nvar scratchGeodeticSurfaceNormal = new _Cartesian3_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"] */ .Z();\n\nTerrainEncoding.prototype.addGeodeticSurfaceNormals = function (\n  oldBuffer,\n  newBuffer,\n  ellipsoid\n) {\n  if (this.hasGeodeticSurfaceNormals) {\n    return;\n  }\n\n  var oldStride = this.stride;\n  var vertexCount = oldBuffer.length / oldStride;\n  this.hasGeodeticSurfaceNormals = true;\n  this._calculateStrideAndOffsets();\n  var newStride = this.stride;\n\n  for (var index = 0; index < vertexCount; index++) {\n    for (var offset = 0; offset < oldStride; offset++) {\n      var oldIndex = index * oldStride + offset;\n      var newIndex = index * newStride + offset;\n      newBuffer[newIndex] = oldBuffer[oldIndex];\n    }\n    var position = this.decodePosition(newBuffer, index, scratchPosition);\n    var geodeticSurfaceNormal = ellipsoid.geodeticSurfaceNormal(\n      position,\n      scratchGeodeticSurfaceNormal\n    );\n\n    var bufferIndex = index * newStride + this._offsetGeodeticSurfaceNormal;\n    newBuffer[bufferIndex] = geodeticSurfaceNormal.x;\n    newBuffer[bufferIndex + 1] = geodeticSurfaceNormal.y;\n    newBuffer[bufferIndex + 2] = geodeticSurfaceNormal.z;\n  }\n};\n\nTerrainEncoding.prototype.removeGeodeticSurfaceNormals = function (\n  oldBuffer,\n  newBuffer\n) {\n  if (!this.hasGeodeticSurfaceNormals) {\n    return;\n  }\n\n  var oldStride = this.stride;\n  var vertexCount = oldBuffer.length / oldStride;\n  this.hasGeodeticSurfaceNormals = false;\n  this._calculateStrideAndOffsets();\n  var newStride = this.stride;\n\n  for (var index = 0; index < vertexCount; index++) {\n    for (var offset = 0; offset < newStride; offset++) {\n      var oldIndex = index * oldStride + offset;\n      var newIndex = index * newStride + offset;\n      newBuffer[newIndex] = oldBuffer[oldIndex];\n    }\n  }\n};\n\nTerrainEncoding.prototype.decodePosition = function (buffer, index, result) {\n  if (!(0,_defined_js__WEBPACK_IMPORTED_MODULE_9__/* ["default"] */ .Z)(result)) {\n    result = new _Cartesian3_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"] */ .Z();\n  }\n\n  index *= this.stride;\n\n  if (this.quantization === _TerrainQuantization_js__WEBPACK_IMPORTED_MODULE_8__/* ["default"].BITS12 */ .Z.BITS12) {\n    var xy = _AttributeCompression_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].decompressTextureCoordinates */ .Z.decompressTextureCoordinates(\n      buffer[index],\n      cartesian2Scratch\n    );\n    result.x = xy.x;\n    result.y = xy.y;\n\n    var zh = _AttributeCompression_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].decompressTextureCoordinates */ .Z.decompressTextureCoordinates(\n      buffer[index + 1],\n      cartesian2Scratch\n    );\n    result.z = zh.x;\n\n    return _Matrix4_js__WEBPACK_IMPORTED_MODULE_6__/* ["default"].multiplyByPoint */ .Z.multiplyByPoint(this.fromScaledENU, result, result);\n  }\n\n  result.x = buffer[index];\n  result.y = buffer[index + 1];\n  result.z = buffer[index + 2];\n  return _Cartesian3_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"].add */ .Z.add(result, this.center, result);\n};\n\nTerrainEncoding.prototype.getExaggeratedPosition = function (\n  buffer,\n  index,\n  result\n) {\n  result = this.decodePosition(buffer, index, result);\n\n  var exaggeration = this.exaggeration;\n  var exaggerationRelativeHeight = this.exaggerationRelativeHeight;\n  var hasExaggeration = exaggeration !== 1.0;\n  if (hasExaggeration && this.hasGeodeticSurfaceNormals) {\n    var geodeticSurfaceNormal = this.decodeGeodeticSurfaceNormal(\n      buffer,\n      index,\n      scratchGeodeticSurfaceNormal\n    );\n    var rawHeight = this.decodeHeight(buffer, index);\n    var heightDifference =\n      _TerrainExaggeration_js__WEBPACK_IMPORTED_MODULE_7__/* ["default"].getHeight */ .Z.getHeight(\n        rawHeight,\n        exaggeration,\n        exaggerationRelativeHeight\n      ) - rawHeight;\n\n    // some math is unrolled for better performance\n    result.x += geodeticSurfaceNormal.x * heightDifference;\n    result.y += geodeticSurfaceNormal.y * heightDifference;\n    result.z += geodeticSurfaceNormal.z * heightDifference;\n  }\n\n  return result;\n};\n\nTerrainEncoding.prototype.decodeTextureCoordinates = function (\n  buffer,\n  index,\n  result\n) {\n  if (!(0,_defined_js__WEBPACK_IMPORTED_MODULE_9__/* ["default"] */ .Z)(result)) {\n    result = new _Cartesian2_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .Z();\n  }\n\n  index *= this.stride;\n\n  if (this.quantization === _TerrainQuantization_js__WEBPACK_IMPORTED_MODULE_8__/* ["default"].BITS12 */ .Z.BITS12) {\n    return _AttributeCompression_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].decompressTextureCoordinates */ .Z.decompressTextureCoordinates(\n      buffer[index + 2],\n      result\n    );\n  }\n\n  return _Cartesian2_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"].fromElements */ .Z.fromElements(buffer[index + 4], buffer[index + 5], result);\n};\n\nTerrainEncoding.prototype.decodeHeight = function (buffer, index) {\n  index *= this.stride;\n\n  if (this.quantization === _TerrainQuantization_js__WEBPACK_IMPORTED_MODULE_8__/* ["default"].BITS12 */ .Z.BITS12) {\n    var zh = _AttributeCompression_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].decompressTextureCoordinates */ .Z.decompressTextureCoordinates(\n      buffer[index + 1],\n      cartesian2Scratch\n    );\n    return (\n      zh.y * (this.maximumHeight - this.minimumHeight) + this.minimumHeight\n    );\n  }\n\n  return buffer[index + 3];\n};\n\nTerrainEncoding.prototype.decodeWebMercatorT = function (buffer, index) {\n  index *= this.stride;\n\n  if (this.quantization === _TerrainQuantization_js__WEBPACK_IMPORTED_MODULE_8__/* ["default"].BITS12 */ .Z.BITS12) {\n    return _AttributeCompression_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].decompressTextureCoordinates */ .Z.decompressTextureCoordinates(\n      buffer[index + 3],\n      cartesian2Scratch\n    ).x;\n  }\n\n  return buffer[index + 6];\n};\n\nTerrainEncoding.prototype.getOctEncodedNormal = function (\n  buffer,\n  index,\n  result\n) {\n  index = index * this.stride + this._offsetVertexNormal;\n\n  var temp = buffer[index] / 256.0;\n  var x = Math.floor(temp);\n  var y = (temp - x) * 256.0;\n\n  return _Cartesian2_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"].fromElements */ .Z.fromElements(x, y, result);\n};\n\nTerrainEncoding.prototype.decodeGeodeticSurfaceNormal = function (\n  buffer,\n  index,\n  result\n) {\n  index = index * this.stride + this._offsetGeodeticSurfaceNormal;\n\n  result.x = buffer[index];\n  result.y = buffer[index + 1];\n  result.z = buffer[index + 2];\n  return result;\n};\n\nTerrainEncoding.prototype._calculateStrideAndOffsets = function () {\n  var vertexStride = 0;\n\n  switch (this.quantization) {\n    case _TerrainQuantization_js__WEBPACK_IMPORTED_MODULE_8__/* ["default"].BITS12 */ .Z.BITS12:\n      vertexStride += 3;\n      break;\n    default:\n      vertexStride += 6;\n  }\n  if (this.hasWebMercatorT) {\n    vertexStride += 1;\n  }\n  if (this.hasVertexNormals) {\n    this._offsetVertexNormal = vertexStride;\n    vertexStride += 1;\n  }\n  if (this.hasGeodeticSurfaceNormals) {\n    this._offsetGeodeticSurfaceNormal = vertexStride;\n    vertexStride += 3;\n  }\n\n  this.stride = vertexStride;\n};\n\nvar attributesIndicesNone = {\n  position3DAndHeight: 0,\n  textureCoordAndEncodedNormals: 1,\n  geodeticSurfaceNormal: 2,\n};\nvar attributesIndicesBits12 = {\n  compressed0: 0,\n  compressed1: 1,\n  geodeticSurfaceNormal: 2,\n};\n\nTerrainEncoding.prototype.getAttributes = function (buffer) {\n  var datatype = _ComponentDatatype_js__WEBPACK_IMPORTED_MODULE_3__/* ["default"].FLOAT */ .Z.FLOAT;\n  var sizeInBytes = _ComponentDatatype_js__WEBPACK_IMPORTED_MODULE_3__/* ["default"].getSizeInBytes */ .Z.getSizeInBytes(datatype);\n  var strideInBytes = this.stride * sizeInBytes;\n  var offsetInBytes = 0;\n\n  var attributes = [];\n  function addAttribute(index, componentsPerAttribute) {\n    attributes.push({\n      index: index,\n      vertexBuffer: buffer,\n      componentDatatype: datatype,\n      componentsPerAttribute: componentsPerAttribute,\n      offsetInBytes: offsetInBytes,\n      strideInBytes: strideInBytes,\n    });\n    offsetInBytes += componentsPerAttribute * sizeInBytes;\n  }\n\n  if (this.quantization === _TerrainQuantization_js__WEBPACK_IMPORTED_MODULE_8__/* ["default"].NONE */ .Z.NONE) {\n    addAttribute(attributesIndicesNone.position3DAndHeight, 4);\n\n    var componentsTexCoordAndNormals = 2;\n    componentsTexCoordAndNormals += this.hasWebMercatorT ? 1 : 0;\n    componentsTexCoordAndNormals += this.hasVertexNormals ? 1 : 0;\n    addAttribute(\n      attributesIndicesNone.textureCoordAndEncodedNormals,\n      componentsTexCoordAndNormals\n    );\n\n    if (this.hasGeodeticSurfaceNormals) {\n      addAttribute(attributesIndicesNone.geodeticSurfaceNormal, 3);\n    }\n  } else {\n    // When there is no webMercatorT or vertex normals, the attribute only needs 3 components: x/y, z/h, u/v.\n    // WebMercatorT and vertex normals each take up one component, so if only one of them is present the first\n    // attribute gets a 4th component. If both are present, we need an additional attribute that has 1 component.\n    var usingAttribute0Component4 =\n      this.hasWebMercatorT || this.hasVertexNormals;\n    var usingAttribute1Component1 =\n      this.hasWebMercatorT && this.hasVertexNormals;\n    addAttribute(\n      attributesIndicesBits12.compressed0,\n      usingAttribute0Component4 ? 4 : 3\n    );\n\n    if (usingAttribute1Component1) {\n      addAttribute(attributesIndicesBits12.compressed1, 1);\n    }\n\n    if (this.hasGeodeticSurfaceNormals) {\n      addAttribute(attributesIndicesBits12.geodeticSurfaceNormal, 3);\n    }\n  }\n\n  return attributes;\n};\n\nTerrainEncoding.prototype.getAttributeLocations = function () {\n  if (this.quantization === _TerrainQuantization_js__WEBPACK_IMPORTED_MODULE_8__/* ["default"].NONE */ .Z.NONE) {\n    return attributesIndicesNone;\n  }\n  return attributesIndicesBits12;\n};\n\nTerrainEncoding.clone = function (encoding, result) {\n  if (!(0,_defined_js__WEBPACK_IMPORTED_MODULE_9__/* ["default"] */ .Z)(encoding)) {\n    return undefined;\n  }\n  if (!(0,_defined_js__WEBPACK_IMPORTED_MODULE_9__/* ["default"] */ .Z)(result)) {\n    result = new TerrainEncoding();\n  }\n\n  result.quantization = encoding.quantization;\n  result.minimumHeight = encoding.minimumHeight;\n  result.maximumHeight = encoding.maximumHeight;\n  result.center = _Cartesian3_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"].clone */ .Z.clone(encoding.center);\n  result.toScaledENU = _Matrix4_js__WEBPACK_IMPORTED_MODULE_6__/* ["default"].clone */ .Z.clone(encoding.toScaledENU);\n  result.fromScaledENU = _Matrix4_js__WEBPACK_IMPORTED_MODULE_6__/* ["default"].clone */ .Z.clone(encoding.fromScaledENU);\n  result.matrix = _Matrix4_js__WEBPACK_IMPORTED_MODULE_6__/* ["default"].clone */ .Z.clone(encoding.matrix);\n  result.hasVertexNormals = encoding.hasVertexNormals;\n  result.hasWebMercatorT = encoding.hasWebMercatorT;\n  result.hasGeodeticSurfaceNormals = encoding.hasGeodeticSurfaceNormals;\n  result.exaggeration = encoding.exaggeration;\n  result.exaggerationRelativeHeight = encoding.exaggerationRelativeHeight;\n\n  result._calculateStrideAndOffsets();\n\n  return result;\n};\n/* harmony default export */ __webpack_exports__["Z"] = (TerrainEncoding);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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O0FBQ3BEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUEsNEJBQTRCLGtGQUF3QjtBQUNwRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLDRCQUE0QixrRkFBd0I7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxPQUFPLGdFQUFPO0FBQ2Q7QUFDQTtBQUNBLE9BQU8sZ0VBQU87QUFDZDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQiwyRUFBZ0I7QUFDbEMsdUJBQXVCLHdFQUFhO0FBQ3BDLHlCQUF5Qix3RUFBYTtBQUN0QyxrQkFBa0Isd0VBQWE7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EseURBQWUsZUFBZSxFQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdnVlMy13ZWJwYWNrNS8uL25vZGVfbW9kdWxlcy9jZXNpdW0vU291cmNlL0NvcmUvVGVycmFpbkVuY29kaW5nLmpzPzE0MDciXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IEF0dHJpYnV0ZUNvbXByZXNzaW9uIGZyb20gXCIuL0F0dHJpYnV0ZUNvbXByZXNzaW9uLmpzXCI7XG5pbXBvcnQgQ2FydGVzaWFuMiBmcm9tIFwiLi9DYXJ0ZXNpYW4yLmpzXCI7XG5pbXBvcnQgQ2FydGVzaWFuMyBmcm9tIFwiLi9DYXJ0ZXNpYW4zLmpzXCI7XG5pbXBvcnQgQ29tcG9uZW50RGF0YXR5cGUgZnJvbSBcIi4vQ29tcG9uZW50RGF0YXR5cGUuanNcIjtcbmltcG9ydCBkZWZhdWx0VmFsdWUgZnJvbSBcIi4vZGVmYXVsdFZhbHVlLmpzXCI7XG5pbXBvcnQgZGVmaW5lZCBmcm9tIFwiLi9kZWZpbmVkLmpzXCI7XG5pbXBvcnQgQ2VzaXVtTWF0aCBmcm9tIFwiLi9NYXRoLmpzXCI7XG5pbXBvcnQgTWF0cml4NCBmcm9tIFwiLi9NYXRyaXg0LmpzXCI7XG5pbXBvcnQgVGVycmFpbkV4YWdnZXJhdGlvbiBmcm9tIFwiLi9UZXJyYWluRXhhZ2dlcmF0aW9uLmpzXCI7XG5pbXBvcnQgVGVycmFpblF1YW50aXphdGlvbiBmcm9tIFwiLi9UZXJyYWluUXVhbnRpemF0aW9uLmpzXCI7XG5cbnZhciBjYXJ0ZXNpYW4zU2NyYXRjaCA9IG5ldyBDYXJ0ZXNpYW4zKCk7XG52YXIgY2FydGVzaWFuM0RpbVNjcmF0Y2ggPSBuZXcgQ2FydGVzaWFuMygpO1xudmFyIGNhcnRlc2lhbjJTY3JhdGNoID0gbmV3IENhcnRlc2lhbjIoKTtcbnZhciBtYXRyaXg0U2NyYXRjaCA9IG5ldyBNYXRyaXg0KCk7XG52YXIgbWF0cml4NFNjcmF0Y2gyID0gbmV3IE1hdHJpeDQoKTtcblxudmFyIFNISUZUX0xFRlRfMTIgPSBNYXRoLnBvdygyLjAsIDEyLjApO1xuXG4vKipcbiAqIERhdGEgdXNlZCB0byBxdWFudGl6ZSBhbmQgcGFjayB0aGUgdGVycmFpbiBtZXNoLiBUaGUgcG9zaXRpb24gY2FuIGJlIHVucGFja2VkIGZvciBwaWNraW5nIGFuZCBhbGwgYXR0cmlidXRlc1xuICogYXJlIHVucGFja2VkIGluIHRoZSB2ZXJ0ZXggc2hhZGVyLlxuICpcbiAqIEBhbGlhcyBUZXJyYWluRW5jb2RpbmdcbiAqIEBjb25zdHJ1Y3RvclxuICpcbiAqIEBwYXJhbSB7Q2FydGVzaWFuM30gY2VudGVyIFRoZSBjZW50ZXIgcG9pbnQgb2YgdGhlIHZlcnRpY2VzLlxuICogQHBhcmFtIHtBeGlzQWxpZ25lZEJvdW5kaW5nQm94fSBheGlzQWxpZ25lZEJvdW5kaW5nQm94IFRoZSBib3VuZHMgb2YgdGhlIHRpbGUgaW4gdGhlIGVhc3Qtbm9ydGgtdXAgY29vcmRpbmF0ZXMgYXQgdGhlIHRpbGVzIGNlbnRlci5cbiAqIEBwYXJhbSB7TnVtYmVyfSBtaW5pbXVtSGVpZ2h0IFRoZSBtaW5pbXVtIGhlaWdodC5cbiAqIEBwYXJhbSB7TnVtYmVyfSBtYXhpbXVtSGVpZ2h0IFRoZSBtYXhpbXVtIGhlaWdodC5cbiAqIEBwYXJhbSB7TWF0cml4NH0gZnJvbUVOVSBUaGUgZWFzdC1ub3J0aC11cCB0byBmaXhlZCBmcmFtZSBtYXRyaXggYXQgdGhlIGNlbnRlciBvZiB0aGUgdGVycmFpbiBtZXNoLlxuICogQHBhcmFtIHtCb29sZWFufSBoYXNWZXJ0ZXhOb3JtYWxzIElmIHRoZSBtZXNoIGhhcyB2ZXJ0ZXggbm9ybWFscy5cbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW2hhc1dlYk1lcmNhdG9yVD1mYWxzZV0gdHJ1ZSBpZiB0aGUgdGVycmFpbiBkYXRhIGluY2x1ZGVzIGEgV2ViIE1lcmNhdG9yIHRleHR1cmUgY29vcmRpbmF0ZTsgb3RoZXJ3aXNlLCBmYWxzZS5cbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW2hhc0dlb2RldGljU3VyZmFjZU5vcm1hbHM9ZmFsc2VdIHRydWUgaWYgdGhlIHRlcnJhaW4gZGF0YSBpbmNsdWRlcyBnZW9kZXRpYyBzdXJmYWNlIG5vcm1hbHM7IG90aGVyd2lzZSwgZmFsc2UuXG4gKiBAcGFyYW0ge051bWJlcn0gW2V4YWdnZXJhdGlvbj0xLjBdIEEgc2NhbGFyIHVzZWQgdG8gZXhhZ2dlcmF0ZSB0ZXJyYWluLlxuICogQHBhcmFtIHtOdW1iZXJ9IFtleGFnZ2VyYXRpb25SZWxhdGl2ZUhlaWdodD0wLjBdIFRoZSByZWxhdGl2ZSBoZWlnaHQgZnJvbSB3aGljaCB0ZXJyYWluIGlzIGV4YWdnZXJhdGVkLlxuICpcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIFRlcnJhaW5FbmNvZGluZyhcbiAgY2VudGVyLFxuICBheGlzQWxpZ25lZEJvdW5kaW5nQm94LFxuICBtaW5pbXVtSGVpZ2h0LFxuICBtYXhpbXVtSGVpZ2h0LFxuICBmcm9tRU5VLFxuICBoYXNWZXJ0ZXhOb3JtYWxzLFxuICBoYXNXZWJNZXJjYXRvclQsXG4gIGhhc0dlb2RldGljU3VyZmFjZU5vcm1hbHMsXG4gIGV4YWdnZXJhdGlvbixcbiAgZXhhZ2dlcmF0aW9uUmVsYXRpdmVIZWlnaHRcbikge1xuICB2YXIgcXVhbnRpemF0aW9uID0gVGVycmFpblF1YW50aXphdGlvbi5OT05FO1xuICB2YXIgdG9FTlU7XG4gIHZhciBtYXRyaXg7XG5cbiAgaWYgKFxuICAgIGRlZmluZWQoYXhpc0FsaWduZWRCb3VuZGluZ0JveCkgJiZcbiAgICBkZWZpbmVkKG1pbmltdW1IZWlnaHQpICYmXG4gICAgZGVmaW5lZChtYXhpbXVtSGVpZ2h0KSAmJlxuICAgIGRlZmluZWQoZnJvbUVOVSlcbiAgKSB7XG4gICAgdmFyIG1pbmltdW0gPSBheGlzQWxpZ25lZEJvdW5kaW5nQm94Lm1pbmltdW07XG4gICAgdmFyIG1heGltdW0gPSBheGlzQWxpZ25lZEJvdW5kaW5nQm94Lm1heGltdW07XG5cbiAgICB2YXIgZGltZW5zaW9ucyA9IENhcnRlc2lhbjMuc3VidHJhY3QoXG4gICAgICBtYXhpbXVtLFxuICAgICAgbWluaW11bSxcbiAgICAgIGNhcnRlc2lhbjNEaW1TY3JhdGNoXG4gICAgKTtcbiAgICB2YXIgaERpbSA9IG1heGltdW1IZWlnaHQgLSBtaW5pbXVtSGVpZ2h0O1xuICAgIHZhciBtYXhEaW0gPSBNYXRoLm1heChDYXJ0ZXNpYW4zLm1heGltdW1Db21wb25lbnQoZGltZW5zaW9ucyksIGhEaW0pO1xuXG4gICAgaWYgKG1heERpbSA8IFNISUZUX0xFRlRfMTIgLSAxLjApIHtcbiAgICAgIHF1YW50aXphdGlvbiA9IFRlcnJhaW5RdWFudGl6YXRpb24uQklUUzEyO1xuICAgIH0gZWxzZSB7XG4gICAgICBxdWFudGl6YXRpb24gPSBUZXJyYWluUXVhbnRpemF0aW9uLk5PTkU7XG4gICAgfVxuXG4gICAgdG9FTlUgPSBNYXRyaXg0LmludmVyc2VUcmFuc2Zvcm1hdGlvbihmcm9tRU5VLCBuZXcgTWF0cml4NCgpKTtcblxuICAgIHZhciB0cmFuc2xhdGlvbiA9IENhcnRlc2lhbjMubmVnYXRlKG1pbmltdW0sIGNhcnRlc2lhbjNTY3JhdGNoKTtcbiAgICBNYXRyaXg0Lm11bHRpcGx5KFxuICAgICAgTWF0cml4NC5mcm9tVHJhbnNsYXRpb24odHJhbnNsYXRpb24sIG1hdHJpeDRTY3JhdGNoKSxcbiAgICAgIHRvRU5VLFxuICAgICAgdG9FTlVcbiAgICApO1xuXG4gICAgdmFyIHNjYWxlID0gY2FydGVzaWFuM1NjcmF0Y2g7XG4gICAgc2NhbGUueCA9IDEuMCAvIGRpbWVuc2lvbnMueDtcbiAgICBzY2FsZS55ID0gMS4wIC8gZGltZW5zaW9ucy55O1xuICAgIHNjYWxlLnogPSAxLjAgLyBkaW1lbnNpb25zLno7XG4gICAgTWF0cml4NC5tdWx0aXBseShNYXRyaXg0LmZyb21TY2FsZShzY2FsZSwgbWF0cml4NFNjcmF0Y2gpLCB0b0VOVSwgdG9FTlUpO1xuXG4gICAgbWF0cml4ID0gTWF0cml4NC5jbG9uZShmcm9tRU5VKTtcbiAgICBNYXRyaXg0LnNldFRyYW5zbGF0aW9uKG1hdHJpeCwgQ2FydGVzaWFuMy5aRVJPLCBtYXRyaXgpO1xuXG4gICAgZnJvbUVOVSA9IE1hdHJpeDQuY2xvbmUoZnJvbUVOVSwgbmV3IE1hdHJpeDQoKSk7XG5cbiAgICB2YXIgdHJhbnNsYXRpb25NYXRyaXggPSBNYXRyaXg0LmZyb21UcmFuc2xhdGlvbihtaW5pbXVtLCBtYXRyaXg0U2NyYXRjaCk7XG4gICAgdmFyIHNjYWxlTWF0cml4ID0gTWF0cml4NC5mcm9tU2NhbGUoZGltZW5zaW9ucywgbWF0cml4NFNjcmF0Y2gyKTtcbiAgICB2YXIgc3QgPSBNYXRyaXg0Lm11bHRpcGx5KHRyYW5zbGF0aW9uTWF0cml4LCBzY2FsZU1hdHJpeCwgbWF0cml4NFNjcmF0Y2gpO1xuXG4gICAgTWF0cml4NC5tdWx0aXBseShmcm9tRU5VLCBzdCwgZnJvbUVOVSk7XG4gICAgTWF0cml4NC5tdWx0aXBseShtYXRyaXgsIHN0LCBtYXRyaXgpO1xuICB9XG5cbiAgLyoqXG4gICAqIEhvdyB0aGUgdmVydGljZXMgb2YgdGhlIG1lc2ggd2VyZSBjb21wcmVzc2VkLlxuICAgKiBAdHlwZSB7VGVycmFpblF1YW50aXphdGlvbn1cbiAgICovXG4gIHRoaXMucXVhbnRpemF0aW9uID0gcXVhbnRpemF0aW9uO1xuXG4gIC8qKlxuICAgKiBUaGUgbWluaW11bSBoZWlnaHQgb2YgdGhlIHRpbGUgaW5jbHVkaW5nIHRoZSBza2lydHMuXG4gICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAqL1xuICB0aGlzLm1pbmltdW1IZWlnaHQgPSBtaW5pbXVtSGVpZ2h0O1xuXG4gIC8qKlxuICAgKiBUaGUgbWF4aW11bSBoZWlnaHQgb2YgdGhlIHRpbGUuXG4gICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAqL1xuICB0aGlzLm1heGltdW1IZWlnaHQgPSBtYXhpbXVtSGVpZ2h0O1xuXG4gIC8qKlxuICAgKiBUaGUgY2VudGVyIG9mIHRoZSB0aWxlLlxuICAgKiBAdHlwZSB7Q2FydGVzaWFuM31cbiAgICovXG4gIHRoaXMuY2VudGVyID0gQ2FydGVzaWFuMy5jbG9uZShjZW50ZXIpO1xuXG4gIC8qKlxuICAgKiBBIG1hdHJpeCB0aGF0IHRha2VzIGEgdmVydGV4IGZyb20gdGhlIHRpbGUsIHRyYW5zZm9ybXMgaXQgdG8gZWFzdC1ub3J0aC11cCBhdCB0aGUgY2VudGVyIGFuZCBzY2FsZXNcbiAgICogaXQgc28gZWFjaCBjb21wb25lbnQgaXMgaW4gdGhlIFswLCAxXSByYW5nZS5cbiAgICogQHR5cGUge01hdHJpeDR9XG4gICAqL1xuICB0aGlzLnRvU2NhbGVkRU5VID0gdG9FTlU7XG5cbiAgLyoqXG4gICAqIEEgbWF0cml4IHRoYXQgcmVzdG9yZXMgYSB2ZXJ0ZXggdHJhbnNmb3JtZWQgd2l0aCB0b1NjYWxlZEVOVSBiYWNrIHRvIHRoZSBlYXJ0aCBmaXhlZCByZWZlcmVuY2UgZnJhbWVcbiAgICogQHR5cGUge01hdHJpeDR9XG4gICAqL1xuICB0aGlzLmZyb21TY2FsZWRFTlUgPSBmcm9tRU5VO1xuXG4gIC8qKlxuICAgKiBUaGUgbWF0cml4IHVzZWQgdG8gZGVjb21wcmVzcyB0aGUgdGVycmFpbiB2ZXJ0aWNlcyBpbiB0aGUgc2hhZGVyIGZvciBSVEUgcmVuZGVyaW5nLlxuICAgKiBAdHlwZSB7TWF0cml4NH1cbiAgICovXG4gIHRoaXMubWF0cml4ID0gbWF0cml4O1xuXG4gIC8qKlxuICAgKiBUaGUgdGVycmFpbiBtZXNoIGNvbnRhaW5zIG5vcm1hbHMuXG4gICAqIEB0eXBlIHtCb29sZWFufVxuICAgKi9cbiAgdGhpcy5oYXNWZXJ0ZXhOb3JtYWxzID0gaGFzVmVydGV4Tm9ybWFscztcblxuICAvKipcbiAgICogVGhlIHRlcnJhaW4gbWVzaCBjb250YWlucyBhIHZlcnRpY2FsIHRleHR1cmUgY29vcmRpbmF0ZSBmb2xsb3dpbmcgdGhlIFdlYiBNZXJjYXRvciBwcm9qZWN0aW9uLlxuICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICovXG4gIHRoaXMuaGFzV2ViTWVyY2F0b3JUID0gZGVmYXVsdFZhbHVlKGhhc1dlYk1lcmNhdG9yVCwgZmFsc2UpO1xuXG4gIC8qKlxuICAgKiBUaGUgdGVycmFpbiBtZXNoIGNvbnRhaW5zIGdlb2RldGljIHN1cmZhY2Ugbm9ybWFscywgdXNlZCBmb3IgdGVycmFpbiBleGFnZ2VyYXRpb24uXG4gICAqIEB0eXBlIHtCb29sZWFufVxuICAgKi9cbiAgdGhpcy5oYXNHZW9kZXRpY1N1cmZhY2VOb3JtYWxzID0gZGVmYXVsdFZhbHVlKFxuICAgIGhhc0dlb2RldGljU3VyZmFjZU5vcm1hbHMsXG4gICAgZmFsc2VcbiAgKTtcblxuICAvKipcbiAgICogQSBzY2FsYXIgdXNlZCB0byBleGFnZ2VyYXRlIHRlcnJhaW4uXG4gICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAqL1xuICB0aGlzLmV4YWdnZXJhdGlvbiA9IGRlZmF1bHRWYWx1ZShleGFnZ2VyYXRpb24sIDEuMCk7XG5cbiAgLyoqXG4gICAqIFRoZSByZWxhdGl2ZSBoZWlnaHQgZnJvbSB3aGljaCB0ZXJyYWluIGlzIGV4YWdnZXJhdGVkLlxuICAgKi9cbiAgdGhpcy5leGFnZ2VyYXRpb25SZWxhdGl2ZUhlaWdodCA9IGRlZmF1bHRWYWx1ZShcbiAgICBleGFnZ2VyYXRpb25SZWxhdGl2ZUhlaWdodCxcbiAgICAwLjBcbiAgKTtcblxuICAvKipcbiAgICogVGhlIG51bWJlciBvZiBjb21wb25lbnRzIGluIGVhY2ggdmVydGV4LiBUaGlzIHZhbHVlIGNhbiBkaWZmZXIgd2l0aCBkaWZmZXJlbnQgcXVhbnRpemF0aW9ucy5cbiAgICogQHR5cGUge051bWJlcn1cbiAgICovXG4gIHRoaXMuc3RyaWRlID0gMDtcblxuICB0aGlzLl9vZmZzZXRHZW9kZXRpY1N1cmZhY2VOb3JtYWwgPSAwO1xuICB0aGlzLl9vZmZzZXRWZXJ0ZXhOb3JtYWwgPSAwO1xuXG4gIC8vIENhbGN1bGF0ZSB0aGUgc3RyaWRlIGFuZCBvZmZzZXRzIGRlY2xhcmVkIGFib3ZlXG4gIHRoaXMuX2NhbGN1bGF0ZVN0cmlkZUFuZE9mZnNldHMoKTtcbn1cblxuVGVycmFpbkVuY29kaW5nLnByb3RvdHlwZS5lbmNvZGUgPSBmdW5jdGlvbiAoXG4gIHZlcnRleEJ1ZmZlcixcbiAgYnVmZmVySW5kZXgsXG4gIHBvc2l0aW9uLFxuICB1dixcbiAgaGVpZ2h0LFxuICBub3JtYWxUb1BhY2ssXG4gIHdlYk1lcmNhdG9yVCxcbiAgZ2VvZGV0aWNTdXJmYWNlTm9ybWFsXG4pIHtcbiAgdmFyIHUgPSB1di54O1xuICB2YXIgdiA9IHV2Lnk7XG5cbiAgaWYgKHRoaXMucXVhbnRpemF0aW9uID09PSBUZXJyYWluUXVhbnRpemF0aW9uLkJJVFMxMikge1xuICAgIHBvc2l0aW9uID0gTWF0cml4NC5tdWx0aXBseUJ5UG9pbnQoXG4gICAgICB0aGlzLnRvU2NhbGVkRU5VLFxuICAgICAgcG9zaXRpb24sXG4gICAgICBjYXJ0ZXNpYW4zU2NyYXRjaFxuICAgICk7XG5cbiAgICBwb3NpdGlvbi54ID0gQ2VzaXVtTWF0aC5jbGFtcChwb3NpdGlvbi54LCAwLjAsIDEuMCk7XG4gICAgcG9zaXRpb24ueSA9IENlc2l1bU1hdGguY2xhbXAocG9zaXRpb24ueSwgMC4wLCAxLjApO1xuICAgIHBvc2l0aW9uLnogPSBDZXNpdW1NYXRoLmNsYW1wKHBvc2l0aW9uLnosIDAuMCwgMS4wKTtcblxuICAgIHZhciBoRGltID0gdGhpcy5tYXhpbXVtSGVpZ2h0IC0gdGhpcy5taW5pbXVtSGVpZ2h0O1xuICAgIHZhciBoID0gQ2VzaXVtTWF0aC5jbGFtcCgoaGVpZ2h0IC0gdGhpcy5taW5pbXVtSGVpZ2h0KSAvIGhEaW0sIDAuMCwgMS4wKTtcblxuICAgIENhcnRlc2lhbjIuZnJvbUVsZW1lbnRzKHBvc2l0aW9uLngsIHBvc2l0aW9uLnksIGNhcnRlc2lhbjJTY3JhdGNoKTtcbiAgICB2YXIgY29tcHJlc3NlZDAgPSBBdHRyaWJ1dGVDb21wcmVzc2lvbi5jb21wcmVzc1RleHR1cmVDb29yZGluYXRlcyhcbiAgICAgIGNhcnRlc2lhbjJTY3JhdGNoXG4gICAgKTtcblxuICAgIENhcnRlc2lhbjIuZnJvbUVsZW1lbnRzKHBvc2l0aW9uLnosIGgsIGNhcnRlc2lhbjJTY3JhdGNoKTtcbiAgICB2YXIgY29tcHJlc3NlZDEgPSBBdHRyaWJ1dGVDb21wcmVzc2lvbi5jb21wcmVzc1RleHR1cmVDb29yZGluYXRlcyhcbiAgICAgIGNhcnRlc2lhbjJTY3JhdGNoXG4gICAgKTtcblxuICAgIENhcnRlc2lhbjIuZnJvbUVsZW1lbnRzKHUsIHYsIGNhcnRlc2lhbjJTY3JhdGNoKTtcbiAgICB2YXIgY29tcHJlc3NlZDIgPSBBdHRyaWJ1dGVDb21wcmVzc2lvbi5jb21wcmVzc1RleHR1cmVDb29yZGluYXRlcyhcbiAgICAgIGNhcnRlc2lhbjJTY3JhdGNoXG4gICAgKTtcblxuICAgIHZlcnRleEJ1ZmZlcltidWZmZXJJbmRleCsrXSA9IGNvbXByZXNzZWQwO1xuICAgIHZlcnRleEJ1ZmZlcltidWZmZXJJbmRleCsrXSA9IGNvbXByZXNzZWQxO1xuICAgIHZlcnRleEJ1ZmZlcltidWZmZXJJbmRleCsrXSA9IGNvbXByZXNzZWQyO1xuXG4gICAgaWYgKHRoaXMuaGFzV2ViTWVyY2F0b3JUKSB7XG4gICAgICBDYXJ0ZXNpYW4yLmZyb21FbGVtZW50cyh3ZWJNZXJjYXRvclQsIDAuMCwgY2FydGVzaWFuMlNjcmF0Y2gpO1xuICAgICAgdmFyIGNvbXByZXNzZWQzID0gQXR0cmlidXRlQ29tcHJlc3Npb24uY29tcHJlc3NUZXh0dXJlQ29vcmRpbmF0ZXMoXG4gICAgICAgIGNhcnRlc2lhbjJTY3JhdGNoXG4gICAgICApO1xuICAgICAgdmVydGV4QnVmZmVyW2J1ZmZlckluZGV4KytdID0gY29tcHJlc3NlZDM7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIENhcnRlc2lhbjMuc3VidHJhY3QocG9zaXRpb24sIHRoaXMuY2VudGVyLCBjYXJ0ZXNpYW4zU2NyYXRjaCk7XG5cbiAgICB2ZXJ0ZXhCdWZmZXJbYnVmZmVySW5kZXgrK10gPSBjYXJ0ZXNpYW4zU2NyYXRjaC54O1xuICAgIHZlcnRleEJ1ZmZlcltidWZmZXJJbmRleCsrXSA9IGNhcnRlc2lhbjNTY3JhdGNoLnk7XG4gICAgdmVydGV4QnVmZmVyW2J1ZmZlckluZGV4KytdID0gY2FydGVzaWFuM1NjcmF0Y2guejtcbiAgICB2ZXJ0ZXhCdWZmZXJbYnVmZmVySW5kZXgrK10gPSBoZWlnaHQ7XG4gICAgdmVydGV4QnVmZmVyW2J1ZmZlckluZGV4KytdID0gdTtcbiAgICB2ZXJ0ZXhCdWZmZXJbYnVmZmVySW5kZXgrK10gPSB2O1xuXG4gICAgaWYgKHRoaXMuaGFzV2ViTWVyY2F0b3JUKSB7XG4gICAgICB2ZXJ0ZXhCdWZmZXJbYnVmZmVySW5kZXgrK10gPSB3ZWJNZXJjYXRvclQ7XG4gICAgfVxuICB9XG5cbiAgaWYgKHRoaXMuaGFzVmVydGV4Tm9ybWFscykge1xuICAgIHZlcnRleEJ1ZmZlcltidWZmZXJJbmRleCsrXSA9IEF0dHJpYnV0ZUNvbXByZXNzaW9uLm9jdFBhY2tGbG9hdChcbiAgICAgIG5vcm1hbFRvUGFja1xuICAgICk7XG4gIH1cblxuICBpZiAodGhpcy5oYXNHZW9kZXRpY1N1cmZhY2VOb3JtYWxzKSB7XG4gICAgdmVydGV4QnVmZmVyW2J1ZmZlckluZGV4KytdID0gZ2VvZGV0aWNTdXJmYWNlTm9ybWFsLng7XG4gICAgdmVydGV4QnVmZmVyW2J1ZmZlckluZGV4KytdID0gZ2VvZGV0aWNTdXJmYWNlTm9ybWFsLnk7XG4gICAgdmVydGV4QnVmZmVyW2J1ZmZlckluZGV4KytdID0gZ2VvZGV0aWNTdXJmYWNlTm9ybWFsLno7XG4gIH1cblxuICByZXR1cm4gYnVmZmVySW5kZXg7XG59O1xuXG52YXIgc2NyYXRjaFBvc2l0aW9uID0gbmV3IENhcnRlc2lhbjMoKTtcbnZhciBzY3JhdGNoR2VvZGV0aWNTdXJmYWNlTm9ybWFsID0gbmV3IENhcnRlc2lhbjMoKTtcblxuVGVycmFpbkVuY29kaW5nLnByb3RvdHlwZS5hZGRHZW9kZXRpY1N1cmZhY2VOb3JtYWxzID0gZnVuY3Rpb24gKFxuICBvbGRCdWZmZXIsXG4gIG5ld0J1ZmZlcixcbiAgZWxsaXBzb2lkXG4pIHtcbiAgaWYgKHRoaXMuaGFzR2VvZGV0aWNTdXJmYWNlTm9ybWFscykge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciBvbGRTdHJpZGUgPSB0aGlzLnN0cmlkZTtcbiAgdmFyIHZlcnRleENvdW50ID0gb2xkQnVmZmVyLmxlbmd0aCAvIG9sZFN0cmlkZTtcbiAgdGhpcy5oYXNHZW9kZXRpY1N1cmZhY2VOb3JtYWxzID0gdHJ1ZTtcbiAgdGhpcy5fY2FsY3VsYXRlU3RyaWRlQW5kT2Zmc2V0cygpO1xuICB2YXIgbmV3U3RyaWRlID0gdGhpcy5zdHJpZGU7XG5cbiAgZm9yICh2YXIgaW5kZXggPSAwOyBpbmRleCA8IHZlcnRleENvdW50OyBpbmRleCsrKSB7XG4gICAgZm9yICh2YXIgb2Zmc2V0ID0gMDsgb2Zmc2V0IDwgb2xkU3RyaWRlOyBvZmZzZXQrKykge1xuICAgICAgdmFyIG9sZEluZGV4ID0gaW5kZXggKiBvbGRTdHJpZGUgKyBvZmZzZXQ7XG4gICAgICB2YXIgbmV3SW5kZXggPSBpbmRleCAqIG5ld1N0cmlkZSArIG9mZnNldDtcbiAgICAgIG5ld0J1ZmZlcltuZXdJbmRleF0gPSBvbGRCdWZmZXJbb2xkSW5kZXhdO1xuICAgIH1cbiAgICB2YXIgcG9zaXRpb24gPSB0aGlzLmRlY29kZVBvc2l0aW9uKG5ld0J1ZmZlciwgaW5kZXgsIHNjcmF0Y2hQb3NpdGlvbik7XG4gICAgdmFyIGdlb2RldGljU3VyZmFjZU5vcm1hbCA9IGVsbGlwc29pZC5nZW9kZXRpY1N1cmZhY2VOb3JtYWwoXG4gICAgICBwb3NpdGlvbixcbiAgICAgIHNjcmF0Y2hHZW9kZXRpY1N1cmZhY2VOb3JtYWxcbiAgICApO1xuXG4gICAgdmFyIGJ1ZmZlckluZGV4ID0gaW5kZXggKiBuZXdTdHJpZGUgKyB0aGlzLl9vZmZzZXRHZW9kZXRpY1N1cmZhY2VOb3JtYWw7XG4gICAgbmV3QnVmZmVyW2J1ZmZlckluZGV4XSA9IGdlb2RldGljU3VyZmFjZU5vcm1hbC54O1xuICAgIG5ld0J1ZmZlcltidWZmZXJJbmRleCArIDFdID0gZ2VvZGV0aWNTdXJmYWNlTm9ybWFsLnk7XG4gICAgbmV3QnVmZmVyW2J1ZmZlckluZGV4ICsgMl0gPSBnZW9kZXRpY1N1cmZhY2VOb3JtYWwuejtcbiAgfVxufTtcblxuVGVycmFpbkVuY29kaW5nLnByb3RvdHlwZS5yZW1vdmVHZW9kZXRpY1N1cmZhY2VOb3JtYWxzID0gZnVuY3Rpb24gKFxuICBvbGRCdWZmZXIsXG4gIG5ld0J1ZmZlclxuKSB7XG4gIGlmICghdGhpcy5oYXNHZW9kZXRpY1N1cmZhY2VOb3JtYWxzKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIG9sZFN0cmlkZSA9IHRoaXMuc3RyaWRlO1xuICB2YXIgdmVydGV4Q291bnQgPSBvbGRCdWZmZXIubGVuZ3RoIC8gb2xkU3RyaWRlO1xuICB0aGlzLmhhc0dlb2RldGljU3VyZmFjZU5vcm1hbHMgPSBmYWxzZTtcbiAgdGhpcy5fY2FsY3VsYXRlU3RyaWRlQW5kT2Zmc2V0cygpO1xuICB2YXIgbmV3U3RyaWRlID0gdGhpcy5zdHJpZGU7XG5cbiAgZm9yICh2YXIgaW5kZXggPSAwOyBpbmRleCA8IHZlcnRleENvdW50OyBpbmRleCsrKSB7XG4gICAgZm9yICh2YXIgb2Zmc2V0ID0gMDsgb2Zmc2V0IDwgbmV3U3RyaWRlOyBvZmZzZXQrKykge1xuICAgICAgdmFyIG9sZEluZGV4ID0gaW5kZXggKiBvbGRTdHJpZGUgKyBvZmZzZXQ7XG4gICAgICB2YXIgbmV3SW5kZXggPSBpbmRleCAqIG5ld1N0cmlkZSArIG9mZnNldDtcbiAgICAgIG5ld0J1ZmZlcltuZXdJbmRleF0gPSBvbGRCdWZmZXJbb2xkSW5kZXhdO1xuICAgIH1cbiAgfVxufTtcblxuVGVycmFpbkVuY29kaW5nLnByb3RvdHlwZS5kZWNvZGVQb3NpdGlvbiA9IGZ1bmN0aW9uIChidWZmZXIsIGluZGV4LCByZXN1bHQpIHtcbiAgaWYgKCFkZWZpbmVkKHJlc3VsdCkpIHtcbiAgICByZXN1bHQgPSBuZXcgQ2FydGVzaWFuMygpO1xuICB9XG5cbiAgaW5kZXggKj0gdGhpcy5zdHJpZGU7XG5cbiAgaWYgKHRoaXMucXVhbnRpemF0aW9uID09PSBUZXJyYWluUXVhbnRpemF0aW9uLkJJVFMxMikge1xuICAgIHZhciB4eSA9IEF0dHJpYnV0ZUNvbXByZXNzaW9uLmRlY29tcHJlc3NUZXh0dXJlQ29vcmRpbmF0ZXMoXG4gICAgICBidWZmZXJbaW5kZXhdLFxuICAgICAgY2FydGVzaWFuMlNjcmF0Y2hcbiAgICApO1xuICAgIHJlc3VsdC54ID0geHkueDtcbiAgICByZXN1bHQueSA9IHh5Lnk7XG5cbiAgICB2YXIgemggPSBBdHRyaWJ1dGVDb21wcmVzc2lvbi5kZWNvbXByZXNzVGV4dHVyZUNvb3JkaW5hdGVzKFxuICAgICAgYnVmZmVyW2luZGV4ICsgMV0sXG4gICAgICBjYXJ0ZXNpYW4yU2NyYXRjaFxuICAgICk7XG4gICAgcmVzdWx0LnogPSB6aC54O1xuXG4gICAgcmV0dXJuIE1hdHJpeDQubXVsdGlwbHlCeVBvaW50KHRoaXMuZnJvbVNjYWxlZEVOVSwgcmVzdWx0LCByZXN1bHQpO1xuICB9XG5cbiAgcmVzdWx0LnggPSBidWZmZXJbaW5kZXhdO1xuICByZXN1bHQueSA9IGJ1ZmZlcltpbmRleCArIDFdO1xuICByZXN1bHQueiA9IGJ1ZmZlcltpbmRleCArIDJdO1xuICByZXR1cm4gQ2FydGVzaWFuMy5hZGQocmVzdWx0LCB0aGlzLmNlbnRlciwgcmVzdWx0KTtcbn07XG5cblRlcnJhaW5FbmNvZGluZy5wcm90b3R5cGUuZ2V0RXhhZ2dlcmF0ZWRQb3NpdGlvbiA9IGZ1bmN0aW9uIChcbiAgYnVmZmVyLFxuICBpbmRleCxcbiAgcmVzdWx0XG4pIHtcbiAgcmVzdWx0ID0gdGhpcy5kZWNvZGVQb3NpdGlvbihidWZmZXIsIGluZGV4LCByZXN1bHQpO1xuXG4gIHZhciBleGFnZ2VyYXRpb24gPSB0aGlzLmV4YWdnZXJhdGlvbjtcbiAgdmFyIGV4YWdnZXJhdGlvblJlbGF0aXZlSGVpZ2h0ID0gdGhpcy5leGFnZ2VyYXRpb25SZWxhdGl2ZUhlaWdodDtcbiAgdmFyIGhhc0V4YWdnZXJhdGlvbiA9IGV4YWdnZXJhdGlvbiAhPT0gMS4wO1xuICBpZiAoaGFzRXhhZ2dlcmF0aW9uICYmIHRoaXMuaGFzR2VvZGV0aWNTdXJmYWNlTm9ybWFscykge1xuICAgIHZhciBnZW9kZXRpY1N1cmZhY2VOb3JtYWwgPSB0aGlzLmRlY29kZUdlb2RldGljU3VyZmFjZU5vcm1hbChcbiAgICAgIGJ1ZmZlcixcbiAgICAgIGluZGV4LFxuICAgICAgc2NyYXRjaEdlb2RldGljU3VyZmFjZU5vcm1hbFxuICAgICk7XG4gICAgdmFyIHJhd0hlaWdodCA9IHRoaXMuZGVjb2RlSGVpZ2h0KGJ1ZmZlciwgaW5kZXgpO1xuICAgIHZhciBoZWlnaHREaWZmZXJlbmNlID1cbiAgICAgIFRlcnJhaW5FeGFnZ2VyYXRpb24uZ2V0SGVpZ2h0KFxuICAgICAgICByYXdIZWlnaHQsXG4gICAgICAgIGV4YWdnZXJhdGlvbixcbiAgICAgICAgZXhhZ2dlcmF0aW9uUmVsYXRpdmVIZWlnaHRcbiAgICAgICkgLSByYXdIZWlnaHQ7XG5cbiAgICAvLyBzb21lIG1hdGggaXMgdW5yb2xsZWQgZm9yIGJldHRlciBwZXJmb3JtYW5jZVxuICAgIHJlc3VsdC54ICs9IGdlb2RldGljU3VyZmFjZU5vcm1hbC54ICogaGVpZ2h0RGlmZmVyZW5jZTtcbiAgICByZXN1bHQueSArPSBnZW9kZXRpY1N1cmZhY2VOb3JtYWwueSAqIGhlaWdodERpZmZlcmVuY2U7XG4gICAgcmVzdWx0LnogKz0gZ2VvZGV0aWNTdXJmYWNlTm9ybWFsLnogKiBoZWlnaHREaWZmZXJlbmNlO1xuICB9XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cblRlcnJhaW5FbmNvZGluZy5wcm90b3R5cGUuZGVjb2RlVGV4dHVyZUNvb3JkaW5hdGVzID0gZnVuY3Rpb24gKFxuICBidWZmZXIsXG4gIGluZGV4LFxuICByZXN1bHRcbikge1xuICBpZiAoIWRlZmluZWQocmVzdWx0KSkge1xuICAgIHJlc3VsdCA9IG5ldyBDYXJ0ZXNpYW4yKCk7XG4gIH1cblxuICBpbmRleCAqPSB0aGlzLnN0cmlkZTtcblxuICBpZiAodGhpcy5xdWFudGl6YXRpb24gPT09IFRlcnJhaW5RdWFudGl6YXRpb24uQklUUzEyKSB7XG4gICAgcmV0dXJuIEF0dHJpYnV0ZUNvbXByZXNzaW9uLmRlY29tcHJlc3NUZXh0dXJlQ29vcmRpbmF0ZXMoXG4gICAgICBidWZmZXJbaW5kZXggKyAyXSxcbiAgICAgIHJlc3VsdFxuICAgICk7XG4gIH1cblxuICByZXR1cm4gQ2FydGVzaWFuMi5mcm9tRWxlbWVudHMoYnVmZmVyW2luZGV4ICsgNF0sIGJ1ZmZlcltpbmRleCArIDVdLCByZXN1bHQpO1xufTtcblxuVGVycmFpbkVuY29kaW5nLnByb3RvdHlwZS5kZWNvZGVIZWlnaHQgPSBmdW5jdGlvbiAoYnVmZmVyLCBpbmRleCkge1xuICBpbmRleCAqPSB0aGlzLnN0cmlkZTtcblxuICBpZiAodGhpcy5xdWFudGl6YXRpb24gPT09IFRlcnJhaW5RdWFudGl6YXRpb24uQklUUzEyKSB7XG4gICAgdmFyIHpoID0gQXR0cmlidXRlQ29tcHJlc3Npb24uZGVjb21wcmVzc1RleHR1cmVDb29yZGluYXRlcyhcbiAgICAgIGJ1ZmZlcltpbmRleCArIDFdLFxuICAgICAgY2FydGVzaWFuMlNjcmF0Y2hcbiAgICApO1xuICAgIHJldHVybiAoXG4gICAgICB6aC55ICogKHRoaXMubWF4aW11bUhlaWdodCAtIHRoaXMubWluaW11bUhlaWdodCkgKyB0aGlzLm1pbmltdW1IZWlnaHRcbiAgICApO1xuICB9XG5cbiAgcmV0dXJuIGJ1ZmZlcltpbmRleCArIDNdO1xufTtcblxuVGVycmFpbkVuY29kaW5nLnByb3RvdHlwZS5kZWNvZGVXZWJNZXJjYXRvclQgPSBmdW5jdGlvbiAoYnVmZmVyLCBpbmRleCkge1xuICBpbmRleCAqPSB0aGlzLnN0cmlkZTtcblxuICBpZiAodGhpcy5xdWFudGl6YXRpb24gPT09IFRlcnJhaW5RdWFudGl6YXRpb24uQklUUzEyKSB7XG4gICAgcmV0dXJuIEF0dHJpYnV0ZUNvbXByZXNzaW9uLmRlY29tcHJlc3NUZXh0dXJlQ29vcmRpbmF0ZXMoXG4gICAgICBidWZmZXJbaW5kZXggKyAzXSxcbiAgICAgIGNhcnRlc2lhbjJTY3JhdGNoXG4gICAgKS54O1xuICB9XG5cbiAgcmV0dXJuIGJ1ZmZlcltpbmRleCArIDZdO1xufTtcblxuVGVycmFpbkVuY29kaW5nLnByb3RvdHlwZS5nZXRPY3RFbmNvZGVkTm9ybWFsID0gZnVuY3Rpb24gKFxuICBidWZmZXIsXG4gIGluZGV4LFxuICByZXN1bHRcbikge1xuICBpbmRleCA9IGluZGV4ICogdGhpcy5zdHJpZGUgKyB0aGlzLl9vZmZzZXRWZXJ0ZXhOb3JtYWw7XG5cbiAgdmFyIHRlbXAgPSBidWZmZXJbaW5kZXhdIC8gMjU2LjA7XG4gIHZhciB4ID0gTWF0aC5mbG9vcih0ZW1wKTtcbiAgdmFyIHkgPSAodGVtcCAtIHgpICogMjU2LjA7XG5cbiAgcmV0dXJuIENhcnRlc2lhbjIuZnJvbUVsZW1lbnRzKHgsIHksIHJlc3VsdCk7XG59O1xuXG5UZXJyYWluRW5jb2RpbmcucHJvdG90eXBlLmRlY29kZUdlb2RldGljU3VyZmFjZU5vcm1hbCA9IGZ1bmN0aW9uIChcbiAgYnVmZmVyLFxuICBpbmRleCxcbiAgcmVzdWx0XG4pIHtcbiAgaW5kZXggPSBpbmRleCAqIHRoaXMuc3RyaWRlICsgdGhpcy5fb2Zmc2V0R2VvZGV0aWNTdXJmYWNlTm9ybWFsO1xuXG4gIHJlc3VsdC54ID0gYnVmZmVyW2luZGV4XTtcbiAgcmVzdWx0LnkgPSBidWZmZXJbaW5kZXggKyAxXTtcbiAgcmVzdWx0LnogPSBidWZmZXJbaW5kZXggKyAyXTtcbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cblRlcnJhaW5FbmNvZGluZy5wcm90b3R5cGUuX2NhbGN1bGF0ZVN0cmlkZUFuZE9mZnNldHMgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciB2ZXJ0ZXhTdHJpZGUgPSAwO1xuXG4gIHN3aXRjaCAodGhpcy5xdWFudGl6YXRpb24pIHtcbiAgICBjYXNlIFRlcnJhaW5RdWFudGl6YXRpb24uQklUUzEyOlxuICAgICAgdmVydGV4U3RyaWRlICs9IDM7XG4gICAgICBicmVhaztcbiAgICBkZWZhdWx0OlxuICAgICAgdmVydGV4U3RyaWRlICs9IDY7XG4gIH1cbiAgaWYgKHRoaXMuaGFzV2ViTWVyY2F0b3JUKSB7XG4gICAgdmVydGV4U3RyaWRlICs9IDE7XG4gIH1cbiAgaWYgKHRoaXMuaGFzVmVydGV4Tm9ybWFscykge1xuICAgIHRoaXMuX29mZnNldFZlcnRleE5vcm1hbCA9IHZlcnRleFN0cmlkZTtcbiAgICB2ZXJ0ZXhTdHJpZGUgKz0gMTtcbiAgfVxuICBpZiAodGhpcy5oYXNHZW9kZXRpY1N1cmZhY2VOb3JtYWxzKSB7XG4gICAgdGhpcy5fb2Zmc2V0R2VvZGV0aWNTdXJmYWNlTm9ybWFsID0gdmVydGV4U3RyaWRlO1xuICAgIHZlcnRleFN0cmlkZSArPSAzO1xuICB9XG5cbiAgdGhpcy5zdHJpZGUgPSB2ZXJ0ZXhTdHJpZGU7XG59O1xuXG52YXIgYXR0cmlidXRlc0luZGljZXNOb25lID0ge1xuICBwb3NpdGlvbjNEQW5kSGVpZ2h0OiAwLFxuICB0ZXh0dXJlQ29vcmRBbmRFbmNvZGVkTm9ybWFsczogMSxcbiAgZ2VvZGV0aWNTdXJmYWNlTm9ybWFsOiAyLFxufTtcbnZhciBhdHRyaWJ1dGVzSW5kaWNlc0JpdHMxMiA9IHtcbiAgY29tcHJlc3NlZDA6IDAsXG4gIGNvbXByZXNzZWQxOiAxLFxuICBnZW9kZXRpY1N1cmZhY2VOb3JtYWw6IDIsXG59O1xuXG5UZXJyYWluRW5jb2RpbmcucHJvdG90eXBlLmdldEF0dHJpYnV0ZXMgPSBmdW5jdGlvbiAoYnVmZmVyKSB7XG4gIHZhciBkYXRhdHlwZSA9IENvbXBvbmVudERhdGF0eXBlLkZMT0FUO1xuICB2YXIgc2l6ZUluQnl0ZXMgPSBDb21wb25lbnREYXRhdHlwZS5nZXRTaXplSW5CeXRlcyhkYXRhdHlwZSk7XG4gIHZhciBzdHJpZGVJbkJ5dGVzID0gdGhpcy5zdHJpZGUgKiBzaXplSW5CeXRlcztcbiAgdmFyIG9mZnNldEluQnl0ZXMgPSAwO1xuXG4gIHZhciBhdHRyaWJ1dGVzID0gW107XG4gIGZ1bmN0aW9uIGFkZEF0dHJpYnV0ZShpbmRleCwgY29tcG9uZW50c1BlckF0dHJpYnV0ZSkge1xuICAgIGF0dHJpYnV0ZXMucHVzaCh7XG4gICAgICBpbmRleDogaW5kZXgsXG4gICAgICB2ZXJ0ZXhCdWZmZXI6IGJ1ZmZlcixcbiAgICAgIGNvbXBvbmVudERhdGF0eXBlOiBkYXRhdHlwZSxcbiAgICAgIGNvbXBvbmVudHNQZXJBdHRyaWJ1dGU6IGNvbXBvbmVudHNQZXJBdHRyaWJ1dGUsXG4gICAgICBvZmZzZXRJbkJ5dGVzOiBvZmZzZXRJbkJ5dGVzLFxuICAgICAgc3RyaWRlSW5CeXRlczogc3RyaWRlSW5CeXRlcyxcbiAgICB9KTtcbiAgICBvZmZzZXRJbkJ5dGVzICs9IGNvbXBvbmVudHNQZXJBdHRyaWJ1dGUgKiBzaXplSW5CeXRlcztcbiAgfVxuXG4gIGlmICh0aGlzLnF1YW50aXphdGlvbiA9PT0gVGVycmFpblF1YW50aXphdGlvbi5OT05FKSB7XG4gICAgYWRkQXR0cmlidXRlKGF0dHJpYnV0ZXNJbmRpY2VzTm9uZS5wb3NpdGlvbjNEQW5kSGVpZ2h0LCA0KTtcblxuICAgIHZhciBjb21wb25lbnRzVGV4Q29vcmRBbmROb3JtYWxzID0gMjtcbiAgICBjb21wb25lbnRzVGV4Q29vcmRBbmROb3JtYWxzICs9IHRoaXMuaGFzV2ViTWVyY2F0b3JUID8gMSA6IDA7XG4gICAgY29tcG9uZW50c1RleENvb3JkQW5kTm9ybWFscyArPSB0aGlzLmhhc1ZlcnRleE5vcm1hbHMgPyAxIDogMDtcbiAgICBhZGRBdHRyaWJ1dGUoXG4gICAgICBhdHRyaWJ1dGVzSW5kaWNlc05vbmUudGV4dHVyZUNvb3JkQW5kRW5jb2RlZE5vcm1hbHMsXG4gICAgICBjb21wb25lbnRzVGV4Q29vcmRBbmROb3JtYWxzXG4gICAgKTtcblxuICAgIGlmICh0aGlzLmhhc0dlb2RldGljU3VyZmFjZU5vcm1hbHMpIHtcbiAgICAgIGFkZEF0dHJpYnV0ZShhdHRyaWJ1dGVzSW5kaWNlc05vbmUuZ2VvZGV0aWNTdXJmYWNlTm9ybWFsLCAzKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgLy8gV2hlbiB0aGVyZSBpcyBubyB3ZWJNZXJjYXRvclQgb3IgdmVydGV4IG5vcm1hbHMsIHRoZSBhdHRyaWJ1dGUgb25seSBuZWVkcyAzIGNvbXBvbmVudHM6IHgveSwgei9oLCB1L3YuXG4gICAgLy8gV2ViTWVyY2F0b3JUIGFuZCB2ZXJ0ZXggbm9ybWFscyBlYWNoIHRha2UgdXAgb25lIGNvbXBvbmVudCwgc28gaWYgb25seSBvbmUgb2YgdGhlbSBpcyBwcmVzZW50IHRoZSBmaXJzdFxuICAgIC8vIGF0dHJpYnV0ZSBnZXRzIGEgNHRoIGNvbXBvbmVudC4gSWYgYm90aCBhcmUgcHJlc2VudCwgd2UgbmVlZCBhbiBhZGRpdGlvbmFsIGF0dHJpYnV0ZSB0aGF0IGhhcyAxIGNvbXBvbmVudC5cbiAgICB2YXIgdXNpbmdBdHRyaWJ1dGUwQ29tcG9uZW50NCA9XG4gICAgICB0aGlzLmhhc1dlYk1lcmNhdG9yVCB8fCB0aGlzLmhhc1ZlcnRleE5vcm1hbHM7XG4gICAgdmFyIHVzaW5nQXR0cmlidXRlMUNvbXBvbmVudDEgPVxuICAgICAgdGhpcy5oYXNXZWJNZXJjYXRvclQgJiYgdGhpcy5oYXNWZXJ0ZXhOb3JtYWxzO1xuICAgIGFkZEF0dHJpYnV0ZShcbiAgICAgIGF0dHJpYnV0ZXNJbmRpY2VzQml0czEyLmNvbXByZXNzZWQwLFxuICAgICAgdXNpbmdBdHRyaWJ1dGUwQ29tcG9uZW50NCA/IDQgOiAzXG4gICAgKTtcblxuICAgIGlmICh1c2luZ0F0dHJpYnV0ZTFDb21wb25lbnQxKSB7XG4gICAgICBhZGRBdHRyaWJ1dGUoYXR0cmlidXRlc0luZGljZXNCaXRzMTIuY29tcHJlc3NlZDEsIDEpO1xuICAgIH1cblxuICAgIGlmICh0aGlzLmhhc0dlb2RldGljU3VyZmFjZU5vcm1hbHMpIHtcbiAgICAgIGFkZEF0dHJpYnV0ZShhdHRyaWJ1dGVzSW5kaWNlc0JpdHMxMi5nZW9kZXRpY1N1cmZhY2VOb3JtYWwsIDMpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBhdHRyaWJ1dGVzO1xufTtcblxuVGVycmFpbkVuY29kaW5nLnByb3RvdHlwZS5nZXRBdHRyaWJ1dGVMb2NhdGlvbnMgPSBmdW5jdGlvbiAoKSB7XG4gIGlmICh0aGlzLnF1YW50aXphdGlvbiA9PT0gVGVycmFpblF1YW50aXphdGlvbi5OT05FKSB7XG4gICAgcmV0dXJuIGF0dHJpYnV0ZXNJbmRpY2VzTm9uZTtcbiAgfVxuICByZXR1cm4gYXR0cmlidXRlc0luZGljZXNCaXRzMTI7XG59O1xuXG5UZXJyYWluRW5jb2RpbmcuY2xvbmUgPSBmdW5jdGlvbiAoZW5jb2RpbmcsIHJlc3VsdCkge1xuICBpZiAoIWRlZmluZWQoZW5jb2RpbmcpKSB7XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxuICBpZiAoIWRlZmluZWQocmVzdWx0KSkge1xuICAgIHJlc3VsdCA9IG5ldyBUZXJyYWluRW5jb2RpbmcoKTtcbiAgfVxuXG4gIHJlc3VsdC5xdWFudGl6YXRpb24gPSBlbmNvZGluZy5xdWFudGl6YXRpb247XG4gIHJlc3VsdC5taW5pbXVtSGVpZ2h0ID0gZW5jb2RpbmcubWluaW11bUhlaWdodDtcbiAgcmVzdWx0Lm1heGltdW1IZWlnaHQgPSBlbmNvZGluZy5tYXhpbXVtSGVpZ2h0O1xuICByZXN1bHQuY2VudGVyID0gQ2FydGVzaWFuMy5jbG9uZShlbmNvZGluZy5jZW50ZXIpO1xuICByZXN1bHQudG9TY2FsZWRFTlUgPSBNYXRyaXg0LmNsb25lKGVuY29kaW5nLnRvU2NhbGVkRU5VKTtcbiAgcmVzdWx0LmZyb21TY2FsZWRFTlUgPSBNYXRyaXg0LmNsb25lKGVuY29kaW5nLmZyb21TY2FsZWRFTlUpO1xuICByZXN1bHQubWF0cml4ID0gTWF0cml4NC5jbG9uZShlbmNvZGluZy5tYXRyaXgpO1xuICByZXN1bHQuaGFzVmVydGV4Tm9ybWFscyA9IGVuY29kaW5nLmhhc1ZlcnRleE5vcm1hbHM7XG4gIHJlc3VsdC5oYXNXZWJNZXJjYXRvclQgPSBlbmNvZGluZy5oYXNXZWJNZXJjYXRvclQ7XG4gIHJlc3VsdC5oYXNHZW9kZXRpY1N1cmZhY2VOb3JtYWxzID0gZW5jb2RpbmcuaGFzR2VvZGV0aWNTdXJmYWNlTm9ybWFscztcbiAgcmVzdWx0LmV4YWdnZXJhdGlvbiA9IGVuY29kaW5nLmV4YWdnZXJhdGlvbjtcbiAgcmVzdWx0LmV4YWdnZXJhdGlvblJlbGF0aXZlSGVpZ2h0ID0gZW5jb2RpbmcuZXhhZ2dlcmF0aW9uUmVsYXRpdmVIZWlnaHQ7XG5cbiAgcmVzdWx0Ll9jYWxjdWxhdGVTdHJpZGVBbmRPZmZzZXRzKCk7XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5leHBvcnQgZGVmYXVsdCBUZXJyYWluRW5jb2Rpbmc7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///41782\n')},78257:function(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__){eval('/* harmony import */ var _Cartesian3_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(60216);\n\n\n/**\n * @private\n */\nvar TerrainExaggeration = {};\n\n/**\n * Scales a height relative to an offset.\n *\n * @param {Number} height The height.\n * @param {Number} scale A scalar used to exaggerate the terrain. If the value is 1.0 there will be no effect.\n * @param {Number} relativeHeight The height relative to which terrain is exaggerated. If the value is 0.0 terrain will be exaggerated relative to the ellipsoid surface.\n */\nTerrainExaggeration.getHeight = function (height, scale, relativeHeight) {\n  return (height - relativeHeight) * scale + relativeHeight;\n};\n\nvar scratchCartographic = new _Cartesian3_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .Z();\n\n/**\n * Scales a position by exaggeration.\n */\nTerrainExaggeration.getPosition = function (\n  position,\n  ellipsoid,\n  terrainExaggeration,\n  terrainExaggerationRelativeHeight,\n  result\n) {\n  var cartographic = ellipsoid.cartesianToCartographic(\n    position,\n    scratchCartographic\n  );\n  var newHeight = TerrainExaggeration.getHeight(\n    cartographic.height,\n    terrainExaggeration,\n    terrainExaggerationRelativeHeight\n  );\n  return _Cartesian3_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].fromRadians */ .Z.fromRadians(\n    cartographic.longitude,\n    cartographic.latitude,\n    newHeight,\n    ellipsoid,\n    result\n  );\n};\n\n/* harmony default export */ __webpack_exports__["Z"] = (TerrainExaggeration);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNzgyNTcuanMiLCJtYXBwaW5ncyI6IjtBQUF5Qzs7QUFFekM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsOEJBQThCLCtEQUFVOztBQUV4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVMsdUZBQXNCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHlEQUFlLG1CQUFtQixFQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdnVlMy13ZWJwYWNrNS8uL25vZGVfbW9kdWxlcy9jZXNpdW0vU291cmNlL0NvcmUvVGVycmFpbkV4YWdnZXJhdGlvbi5qcz82NmZhIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBDYXJ0ZXNpYW4zIGZyb20gXCIuL0NhcnRlc2lhbjMuanNcIjtcblxuLyoqXG4gKiBAcHJpdmF0ZVxuICovXG52YXIgVGVycmFpbkV4YWdnZXJhdGlvbiA9IHt9O1xuXG4vKipcbiAqIFNjYWxlcyBhIGhlaWdodCByZWxhdGl2ZSB0byBhbiBvZmZzZXQuXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IGhlaWdodCBUaGUgaGVpZ2h0LlxuICogQHBhcmFtIHtOdW1iZXJ9IHNjYWxlIEEgc2NhbGFyIHVzZWQgdG8gZXhhZ2dlcmF0ZSB0aGUgdGVycmFpbi4gSWYgdGhlIHZhbHVlIGlzIDEuMCB0aGVyZSB3aWxsIGJlIG5vIGVmZmVjdC5cbiAqIEBwYXJhbSB7TnVtYmVyfSByZWxhdGl2ZUhlaWdodCBUaGUgaGVpZ2h0IHJlbGF0aXZlIHRvIHdoaWNoIHRlcnJhaW4gaXMgZXhhZ2dlcmF0ZWQuIElmIHRoZSB2YWx1ZSBpcyAwLjAgdGVycmFpbiB3aWxsIGJlIGV4YWdnZXJhdGVkIHJlbGF0aXZlIHRvIHRoZSBlbGxpcHNvaWQgc3VyZmFjZS5cbiAqL1xuVGVycmFpbkV4YWdnZXJhdGlvbi5nZXRIZWlnaHQgPSBmdW5jdGlvbiAoaGVpZ2h0LCBzY2FsZSwgcmVsYXRpdmVIZWlnaHQpIHtcbiAgcmV0dXJuIChoZWlnaHQgLSByZWxhdGl2ZUhlaWdodCkgKiBzY2FsZSArIHJlbGF0aXZlSGVpZ2h0O1xufTtcblxudmFyIHNjcmF0Y2hDYXJ0b2dyYXBoaWMgPSBuZXcgQ2FydGVzaWFuMygpO1xuXG4vKipcbiAqIFNjYWxlcyBhIHBvc2l0aW9uIGJ5IGV4YWdnZXJhdGlvbi5cbiAqL1xuVGVycmFpbkV4YWdnZXJhdGlvbi5nZXRQb3NpdGlvbiA9IGZ1bmN0aW9uIChcbiAgcG9zaXRpb24sXG4gIGVsbGlwc29pZCxcbiAgdGVycmFpbkV4YWdnZXJhdGlvbixcbiAgdGVycmFpbkV4YWdnZXJhdGlvblJlbGF0aXZlSGVpZ2h0LFxuICByZXN1bHRcbikge1xuICB2YXIgY2FydG9ncmFwaGljID0gZWxsaXBzb2lkLmNhcnRlc2lhblRvQ2FydG9ncmFwaGljKFxuICAgIHBvc2l0aW9uLFxuICAgIHNjcmF0Y2hDYXJ0b2dyYXBoaWNcbiAgKTtcbiAgdmFyIG5ld0hlaWdodCA9IFRlcnJhaW5FeGFnZ2VyYXRpb24uZ2V0SGVpZ2h0KFxuICAgIGNhcnRvZ3JhcGhpYy5oZWlnaHQsXG4gICAgdGVycmFpbkV4YWdnZXJhdGlvbixcbiAgICB0ZXJyYWluRXhhZ2dlcmF0aW9uUmVsYXRpdmVIZWlnaHRcbiAgKTtcbiAgcmV0dXJuIENhcnRlc2lhbjMuZnJvbVJhZGlhbnMoXG4gICAgY2FydG9ncmFwaGljLmxvbmdpdHVkZSxcbiAgICBjYXJ0b2dyYXBoaWMubGF0aXR1ZGUsXG4gICAgbmV3SGVpZ2h0LFxuICAgIGVsbGlwc29pZCxcbiAgICByZXN1bHRcbiAgKTtcbn07XG5cbmV4cG9ydCBkZWZhdWx0IFRlcnJhaW5FeGFnZ2VyYXRpb247XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///78257\n')},13758:function(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__){eval('/* harmony import */ var _defaultValue_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(62200);\n\n\n/**\n * A mesh plus related metadata for a single tile of terrain.  Instances of this type are\n * usually created from raw {@link TerrainData}.\n *\n * @alias TerrainMesh\n * @constructor\n *\n * @param {Cartesian3} center The center of the tile.  Vertex positions are specified relative to this center.\n * @param {Float32Array} vertices The vertex data, including positions, texture coordinates, and heights.\n *                       The vertex data is in the order [X, Y, Z, H, U, V], where X, Y, and Z represent\n *                       the Cartesian position of the vertex, H is the height above the ellipsoid, and\n *                       U and V are the texture coordinates.\n * @param {Uint8Array|Uint16Array|Uint32Array} indices The indices describing how the vertices are connected to form triangles.\n * @param {Number} indexCountWithoutSkirts The index count of the mesh not including skirts.\n * @param {Number} vertexCountWithoutSkirts The vertex count of the mesh not including skirts.\n * @param {Number} minimumHeight The lowest height in the tile, in meters above the ellipsoid.\n * @param {Number} maximumHeight The highest height in the tile, in meters above the ellipsoid.\n * @param {BoundingSphere} boundingSphere3D A bounding sphere that completely contains the tile.\n * @param {Cartesian3} occludeePointInScaledSpace The occludee point of the tile, represented in ellipsoid-\n *                     scaled space, and used for horizon culling.  If this point is below the horizon,\n *                     the tile is considered to be entirely below the horizon.\n * @param {Number} [vertexStride=6] The number of components in each vertex.\n * @param {OrientedBoundingBox} [orientedBoundingBox] A bounding box that completely contains the tile.\n * @param {TerrainEncoding} encoding Information used to decode the mesh.\n * @param {Number[]} westIndicesSouthToNorth The indices of the vertices on the Western edge of the tile, ordered from South to North (clockwise).\n * @param {Number[]} southIndicesEastToWest The indices of the vertices on the Southern edge of the tile, ordered from East to West (clockwise).\n * @param {Number[]} eastIndicesNorthToSouth The indices of the vertices on the Eastern edge of the tile, ordered from North to South (clockwise).\n * @param {Number[]} northIndicesWestToEast The indices of the vertices on the Northern edge of the tile, ordered from West to East (clockwise).\n *\n * @private\n */\nfunction TerrainMesh(\n  center,\n  vertices,\n  indices,\n  indexCountWithoutSkirts,\n  vertexCountWithoutSkirts,\n  minimumHeight,\n  maximumHeight,\n  boundingSphere3D,\n  occludeePointInScaledSpace,\n  vertexStride,\n  orientedBoundingBox,\n  encoding,\n  westIndicesSouthToNorth,\n  southIndicesEastToWest,\n  eastIndicesNorthToSouth,\n  northIndicesWestToEast\n) {\n  /**\n   * The center of the tile.  Vertex positions are specified relative to this center.\n   * @type {Cartesian3}\n   */\n  this.center = center;\n\n  /**\n   * The vertex data, including positions, texture coordinates, and heights.\n   * The vertex data is in the order [X, Y, Z, H, U, V], where X, Y, and Z represent\n   * the Cartesian position of the vertex, H is the height above the ellipsoid, and\n   * U and V are the texture coordinates.  The vertex data may have additional attributes after those\n   * mentioned above when the {@link TerrainMesh#stride} is greater than 6.\n   * @type {Float32Array}\n   */\n  this.vertices = vertices;\n\n  /**\n   * The number of components in each vertex.  Typically this is 6 for the 6 components\n   * [X, Y, Z, H, U, V], but if each vertex has additional data (such as a vertex normal), this value\n   * may be higher.\n   * @type {Number}\n   */\n  this.stride = (0,_defaultValue_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .Z)(vertexStride, 6);\n\n  /**\n   * The indices describing how the vertices are connected to form triangles.\n   * @type {Uint8Array|Uint16Array|Uint32Array}\n   */\n  this.indices = indices;\n\n  /**\n   * The index count of the mesh not including skirts.\n   * @type {Number}\n   */\n  this.indexCountWithoutSkirts = indexCountWithoutSkirts;\n\n  /**\n   * The vertex count of the mesh not including skirts.\n   * @type {Number}\n   */\n  this.vertexCountWithoutSkirts = vertexCountWithoutSkirts;\n\n  /**\n   * The lowest height in the tile, in meters above the ellipsoid.\n   * @type {Number}\n   */\n  this.minimumHeight = minimumHeight;\n\n  /**\n   * The highest height in the tile, in meters above the ellipsoid.\n   * @type {Number}\n   */\n  this.maximumHeight = maximumHeight;\n\n  /**\n   * A bounding sphere that completely contains the tile.\n   * @type {BoundingSphere}\n   */\n  this.boundingSphere3D = boundingSphere3D;\n\n  /**\n   * The occludee point of the tile, represented in ellipsoid-\n   * scaled space, and used for horizon culling.  If this point is below the horizon,\n   * the tile is considered to be entirely below the horizon.\n   * @type {Cartesian3}\n   */\n  this.occludeePointInScaledSpace = occludeePointInScaledSpace;\n\n  /**\n   * A bounding box that completely contains the tile.\n   * @type {OrientedBoundingBox}\n   */\n  this.orientedBoundingBox = orientedBoundingBox;\n\n  /**\n   * Information for decoding the mesh vertices.\n   * @type {TerrainEncoding}\n   */\n  this.encoding = encoding;\n\n  /**\n   * The indices of the vertices on the Western edge of the tile, ordered from South to North (clockwise).\n   * @type {Number[]}\n   */\n  this.westIndicesSouthToNorth = westIndicesSouthToNorth;\n\n  /**\n   * The indices of the vertices on the Southern edge of the tile, ordered from East to West (clockwise).\n   * @type {Number[]}\n   */\n  this.southIndicesEastToWest = southIndicesEastToWest;\n\n  /**\n   * The indices of the vertices on the Eastern edge of the tile, ordered from North to South (clockwise).\n   * @type {Number[]}\n   */\n  this.eastIndicesNorthToSouth = eastIndicesNorthToSouth;\n\n  /**\n   * The indices of the vertices on the Northern edge of the tile, ordered from West to East (clockwise).\n   * @type {Number[]}\n   */\n  this.northIndicesWestToEast = northIndicesWestToEast;\n}\n/* harmony default export */ __webpack_exports__["Z"] = (TerrainMesh);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTM3NTguanMiLCJtYXBwaW5ncyI6IjtBQUE2Qzs7QUFFN0M7QUFDQTtBQUNBLDZCQUE2QixrQkFBa0I7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFlBQVk7QUFDdkIsV0FBVyxjQUFjO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBLFdBQVcsb0NBQW9DO0FBQy9DLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLGdCQUFnQjtBQUMzQixXQUFXLFlBQVk7QUFDdkI7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLHFCQUFxQjtBQUNoQyxXQUFXLGlCQUFpQjtBQUM1QixXQUFXLFVBQVU7QUFDckIsV0FBVyxVQUFVO0FBQ3JCLFdBQVcsVUFBVTtBQUNyQixXQUFXLFVBQVU7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsMEJBQTBCO0FBQ3pELFlBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0EsZ0JBQWdCLHFFQUFZOztBQUU1QjtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQSx5REFBZSxXQUFXLEVBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly92dWUzLXdlYnBhY2s1Ly4vbm9kZV9tb2R1bGVzL2Nlc2l1bS9Tb3VyY2UvQ29yZS9UZXJyYWluTWVzaC5qcz8yMGY5Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBkZWZhdWx0VmFsdWUgZnJvbSBcIi4vZGVmYXVsdFZhbHVlLmpzXCI7XG5cbi8qKlxuICogQSBtZXNoIHBsdXMgcmVsYXRlZCBtZXRhZGF0YSBmb3IgYSBzaW5nbGUgdGlsZSBvZiB0ZXJyYWluLiAgSW5zdGFuY2VzIG9mIHRoaXMgdHlwZSBhcmVcbiAqIHVzdWFsbHkgY3JlYXRlZCBmcm9tIHJhdyB7QGxpbmsgVGVycmFpbkRhdGF9LlxuICpcbiAqIEBhbGlhcyBUZXJyYWluTWVzaFxuICogQGNvbnN0cnVjdG9yXG4gKlxuICogQHBhcmFtIHtDYXJ0ZXNpYW4zfSBjZW50ZXIgVGhlIGNlbnRlciBvZiB0aGUgdGlsZS4gIFZlcnRleCBwb3NpdGlvbnMgYXJlIHNwZWNpZmllZCByZWxhdGl2ZSB0byB0aGlzIGNlbnRlci5cbiAqIEBwYXJhbSB7RmxvYXQzMkFycmF5fSB2ZXJ0aWNlcyBUaGUgdmVydGV4IGRhdGEsIGluY2x1ZGluZyBwb3NpdGlvbnMsIHRleHR1cmUgY29vcmRpbmF0ZXMsIGFuZCBoZWlnaHRzLlxuICogICAgICAgICAgICAgICAgICAgICAgIFRoZSB2ZXJ0ZXggZGF0YSBpcyBpbiB0aGUgb3JkZXIgW1gsIFksIFosIEgsIFUsIFZdLCB3aGVyZSBYLCBZLCBhbmQgWiByZXByZXNlbnRcbiAqICAgICAgICAgICAgICAgICAgICAgICB0aGUgQ2FydGVzaWFuIHBvc2l0aW9uIG9mIHRoZSB2ZXJ0ZXgsIEggaXMgdGhlIGhlaWdodCBhYm92ZSB0aGUgZWxsaXBzb2lkLCBhbmRcbiAqICAgICAgICAgICAgICAgICAgICAgICBVIGFuZCBWIGFyZSB0aGUgdGV4dHVyZSBjb29yZGluYXRlcy5cbiAqIEBwYXJhbSB7VWludDhBcnJheXxVaW50MTZBcnJheXxVaW50MzJBcnJheX0gaW5kaWNlcyBUaGUgaW5kaWNlcyBkZXNjcmliaW5nIGhvdyB0aGUgdmVydGljZXMgYXJlIGNvbm5lY3RlZCB0byBmb3JtIHRyaWFuZ2xlcy5cbiAqIEBwYXJhbSB7TnVtYmVyfSBpbmRleENvdW50V2l0aG91dFNraXJ0cyBUaGUgaW5kZXggY291bnQgb2YgdGhlIG1lc2ggbm90IGluY2x1ZGluZyBza2lydHMuXG4gKiBAcGFyYW0ge051bWJlcn0gdmVydGV4Q291bnRXaXRob3V0U2tpcnRzIFRoZSB2ZXJ0ZXggY291bnQgb2YgdGhlIG1lc2ggbm90IGluY2x1ZGluZyBza2lydHMuXG4gKiBAcGFyYW0ge051bWJlcn0gbWluaW11bUhlaWdodCBUaGUgbG93ZXN0IGhlaWdodCBpbiB0aGUgdGlsZSwgaW4gbWV0ZXJzIGFib3ZlIHRoZSBlbGxpcHNvaWQuXG4gKiBAcGFyYW0ge051bWJlcn0gbWF4aW11bUhlaWdodCBUaGUgaGlnaGVzdCBoZWlnaHQgaW4gdGhlIHRpbGUsIGluIG1ldGVycyBhYm92ZSB0aGUgZWxsaXBzb2lkLlxuICogQHBhcmFtIHtCb3VuZGluZ1NwaGVyZX0gYm91bmRpbmdTcGhlcmUzRCBBIGJvdW5kaW5nIHNwaGVyZSB0aGF0IGNvbXBsZXRlbHkgY29udGFpbnMgdGhlIHRpbGUuXG4gKiBAcGFyYW0ge0NhcnRlc2lhbjN9IG9jY2x1ZGVlUG9pbnRJblNjYWxlZFNwYWNlIFRoZSBvY2NsdWRlZSBwb2ludCBvZiB0aGUgdGlsZSwgcmVwcmVzZW50ZWQgaW4gZWxsaXBzb2lkLVxuICogICAgICAgICAgICAgICAgICAgICBzY2FsZWQgc3BhY2UsIGFuZCB1c2VkIGZvciBob3Jpem9uIGN1bGxpbmcuICBJZiB0aGlzIHBvaW50IGlzIGJlbG93IHRoZSBob3Jpem9uLFxuICogICAgICAgICAgICAgICAgICAgICB0aGUgdGlsZSBpcyBjb25zaWRlcmVkIHRvIGJlIGVudGlyZWx5IGJlbG93IHRoZSBob3Jpem9uLlxuICogQHBhcmFtIHtOdW1iZXJ9IFt2ZXJ0ZXhTdHJpZGU9Nl0gVGhlIG51bWJlciBvZiBjb21wb25lbnRzIGluIGVhY2ggdmVydGV4LlxuICogQHBhcmFtIHtPcmllbnRlZEJvdW5kaW5nQm94fSBbb3JpZW50ZWRCb3VuZGluZ0JveF0gQSBib3VuZGluZyBib3ggdGhhdCBjb21wbGV0ZWx5IGNvbnRhaW5zIHRoZSB0aWxlLlxuICogQHBhcmFtIHtUZXJyYWluRW5jb2Rpbmd9IGVuY29kaW5nIEluZm9ybWF0aW9uIHVzZWQgdG8gZGVjb2RlIHRoZSBtZXNoLlxuICogQHBhcmFtIHtOdW1iZXJbXX0gd2VzdEluZGljZXNTb3V0aFRvTm9ydGggVGhlIGluZGljZXMgb2YgdGhlIHZlcnRpY2VzIG9uIHRoZSBXZXN0ZXJuIGVkZ2Ugb2YgdGhlIHRpbGUsIG9yZGVyZWQgZnJvbSBTb3V0aCB0byBOb3J0aCAoY2xvY2t3aXNlKS5cbiAqIEBwYXJhbSB7TnVtYmVyW119IHNvdXRoSW5kaWNlc0Vhc3RUb1dlc3QgVGhlIGluZGljZXMgb2YgdGhlIHZlcnRpY2VzIG9uIHRoZSBTb3V0aGVybiBlZGdlIG9mIHRoZSB0aWxlLCBvcmRlcmVkIGZyb20gRWFzdCB0byBXZXN0IChjbG9ja3dpc2UpLlxuICogQHBhcmFtIHtOdW1iZXJbXX0gZWFzdEluZGljZXNOb3J0aFRvU291dGggVGhlIGluZGljZXMgb2YgdGhlIHZlcnRpY2VzIG9uIHRoZSBFYXN0ZXJuIGVkZ2Ugb2YgdGhlIHRpbGUsIG9yZGVyZWQgZnJvbSBOb3J0aCB0byBTb3V0aCAoY2xvY2t3aXNlKS5cbiAqIEBwYXJhbSB7TnVtYmVyW119IG5vcnRoSW5kaWNlc1dlc3RUb0Vhc3QgVGhlIGluZGljZXMgb2YgdGhlIHZlcnRpY2VzIG9uIHRoZSBOb3J0aGVybiBlZGdlIG9mIHRoZSB0aWxlLCBvcmRlcmVkIGZyb20gV2VzdCB0byBFYXN0IChjbG9ja3dpc2UpLlxuICpcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIFRlcnJhaW5NZXNoKFxuICBjZW50ZXIsXG4gIHZlcnRpY2VzLFxuICBpbmRpY2VzLFxuICBpbmRleENvdW50V2l0aG91dFNraXJ0cyxcbiAgdmVydGV4Q291bnRXaXRob3V0U2tpcnRzLFxuICBtaW5pbXVtSGVpZ2h0LFxuICBtYXhpbXVtSGVpZ2h0LFxuICBib3VuZGluZ1NwaGVyZTNELFxuICBvY2NsdWRlZVBvaW50SW5TY2FsZWRTcGFjZSxcbiAgdmVydGV4U3RyaWRlLFxuICBvcmllbnRlZEJvdW5kaW5nQm94LFxuICBlbmNvZGluZyxcbiAgd2VzdEluZGljZXNTb3V0aFRvTm9ydGgsXG4gIHNvdXRoSW5kaWNlc0Vhc3RUb1dlc3QsXG4gIGVhc3RJbmRpY2VzTm9ydGhUb1NvdXRoLFxuICBub3J0aEluZGljZXNXZXN0VG9FYXN0XG4pIHtcbiAgLyoqXG4gICAqIFRoZSBjZW50ZXIgb2YgdGhlIHRpbGUuICBWZXJ0ZXggcG9zaXRpb25zIGFyZSBzcGVjaWZpZWQgcmVsYXRpdmUgdG8gdGhpcyBjZW50ZXIuXG4gICAqIEB0eXBlIHtDYXJ0ZXNpYW4zfVxuICAgKi9cbiAgdGhpcy5jZW50ZXIgPSBjZW50ZXI7XG5cbiAgLyoqXG4gICAqIFRoZSB2ZXJ0ZXggZGF0YSwgaW5jbHVkaW5nIHBvc2l0aW9ucywgdGV4dHVyZSBjb29yZGluYXRlcywgYW5kIGhlaWdodHMuXG4gICAqIFRoZSB2ZXJ0ZXggZGF0YSBpcyBpbiB0aGUgb3JkZXIgW1gsIFksIFosIEgsIFUsIFZdLCB3aGVyZSBYLCBZLCBhbmQgWiByZXByZXNlbnRcbiAgICogdGhlIENhcnRlc2lhbiBwb3NpdGlvbiBvZiB0aGUgdmVydGV4LCBIIGlzIHRoZSBoZWlnaHQgYWJvdmUgdGhlIGVsbGlwc29pZCwgYW5kXG4gICAqIFUgYW5kIFYgYXJlIHRoZSB0ZXh0dXJlIGNvb3JkaW5hdGVzLiAgVGhlIHZlcnRleCBkYXRhIG1heSBoYXZlIGFkZGl0aW9uYWwgYXR0cmlidXRlcyBhZnRlciB0aG9zZVxuICAgKiBtZW50aW9uZWQgYWJvdmUgd2hlbiB0aGUge0BsaW5rIFRlcnJhaW5NZXNoI3N0cmlkZX0gaXMgZ3JlYXRlciB0aGFuIDYuXG4gICAqIEB0eXBlIHtGbG9hdDMyQXJyYXl9XG4gICAqL1xuICB0aGlzLnZlcnRpY2VzID0gdmVydGljZXM7XG5cbiAgLyoqXG4gICAqIFRoZSBudW1iZXIgb2YgY29tcG9uZW50cyBpbiBlYWNoIHZlcnRleC4gIFR5cGljYWxseSB0aGlzIGlzIDYgZm9yIHRoZSA2IGNvbXBvbmVudHNcbiAgICogW1gsIFksIFosIEgsIFUsIFZdLCBidXQgaWYgZWFjaCB2ZXJ0ZXggaGFzIGFkZGl0aW9uYWwgZGF0YSAoc3VjaCBhcyBhIHZlcnRleCBub3JtYWwpLCB0aGlzIHZhbHVlXG4gICAqIG1heSBiZSBoaWdoZXIuXG4gICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAqL1xuICB0aGlzLnN0cmlkZSA9IGRlZmF1bHRWYWx1ZSh2ZXJ0ZXhTdHJpZGUsIDYpO1xuXG4gIC8qKlxuICAgKiBUaGUgaW5kaWNlcyBkZXNjcmliaW5nIGhvdyB0aGUgdmVydGljZXMgYXJlIGNvbm5lY3RlZCB0byBmb3JtIHRyaWFuZ2xlcy5cbiAgICogQHR5cGUge1VpbnQ4QXJyYXl8VWludDE2QXJyYXl8VWludDMyQXJyYXl9XG4gICAqL1xuICB0aGlzLmluZGljZXMgPSBpbmRpY2VzO1xuXG4gIC8qKlxuICAgKiBUaGUgaW5kZXggY291bnQgb2YgdGhlIG1lc2ggbm90IGluY2x1ZGluZyBza2lydHMuXG4gICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAqL1xuICB0aGlzLmluZGV4Q291bnRXaXRob3V0U2tpcnRzID0gaW5kZXhDb3VudFdpdGhvdXRTa2lydHM7XG5cbiAgLyoqXG4gICAqIFRoZSB2ZXJ0ZXggY291bnQgb2YgdGhlIG1lc2ggbm90IGluY2x1ZGluZyBza2lydHMuXG4gICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAqL1xuICB0aGlzLnZlcnRleENvdW50V2l0aG91dFNraXJ0cyA9IHZlcnRleENvdW50V2l0aG91dFNraXJ0cztcblxuICAvKipcbiAgICogVGhlIGxvd2VzdCBoZWlnaHQgaW4gdGhlIHRpbGUsIGluIG1ldGVycyBhYm92ZSB0aGUgZWxsaXBzb2lkLlxuICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgKi9cbiAgdGhpcy5taW5pbXVtSGVpZ2h0ID0gbWluaW11bUhlaWdodDtcblxuICAvKipcbiAgICogVGhlIGhpZ2hlc3QgaGVpZ2h0IGluIHRoZSB0aWxlLCBpbiBtZXRlcnMgYWJvdmUgdGhlIGVsbGlwc29pZC5cbiAgICogQHR5cGUge051bWJlcn1cbiAgICovXG4gIHRoaXMubWF4aW11bUhlaWdodCA9IG1heGltdW1IZWlnaHQ7XG5cbiAgLyoqXG4gICAqIEEgYm91bmRpbmcgc3BoZXJlIHRoYXQgY29tcGxldGVseSBjb250YWlucyB0aGUgdGlsZS5cbiAgICogQHR5cGUge0JvdW5kaW5nU3BoZXJlfVxuICAgKi9cbiAgdGhpcy5ib3VuZGluZ1NwaGVyZTNEID0gYm91bmRpbmdTcGhlcmUzRDtcblxuICAvKipcbiAgICogVGhlIG9jY2x1ZGVlIHBvaW50IG9mIHRoZSB0aWxlLCByZXByZXNlbnRlZCBpbiBlbGxpcHNvaWQtXG4gICAqIHNjYWxlZCBzcGFjZSwgYW5kIHVzZWQgZm9yIGhvcml6b24gY3VsbGluZy4gIElmIHRoaXMgcG9pbnQgaXMgYmVsb3cgdGhlIGhvcml6b24sXG4gICAqIHRoZSB0aWxlIGlzIGNvbnNpZGVyZWQgdG8gYmUgZW50aXJlbHkgYmVsb3cgdGhlIGhvcml6b24uXG4gICAqIEB0eXBlIHtDYXJ0ZXNpYW4zfVxuICAgKi9cbiAgdGhpcy5vY2NsdWRlZVBvaW50SW5TY2FsZWRTcGFjZSA9IG9jY2x1ZGVlUG9pbnRJblNjYWxlZFNwYWNlO1xuXG4gIC8qKlxuICAgKiBBIGJvdW5kaW5nIGJveCB0aGF0IGNvbXBsZXRlbHkgY29udGFpbnMgdGhlIHRpbGUuXG4gICAqIEB0eXBlIHtPcmllbnRlZEJvdW5kaW5nQm94fVxuICAgKi9cbiAgdGhpcy5vcmllbnRlZEJvdW5kaW5nQm94ID0gb3JpZW50ZWRCb3VuZGluZ0JveDtcblxuICAvKipcbiAgICogSW5mb3JtYXRpb24gZm9yIGRlY29kaW5nIHRoZSBtZXNoIHZlcnRpY2VzLlxuICAgKiBAdHlwZSB7VGVycmFpbkVuY29kaW5nfVxuICAgKi9cbiAgdGhpcy5lbmNvZGluZyA9IGVuY29kaW5nO1xuXG4gIC8qKlxuICAgKiBUaGUgaW5kaWNlcyBvZiB0aGUgdmVydGljZXMgb24gdGhlIFdlc3Rlcm4gZWRnZSBvZiB0aGUgdGlsZSwgb3JkZXJlZCBmcm9tIFNvdXRoIHRvIE5vcnRoIChjbG9ja3dpc2UpLlxuICAgKiBAdHlwZSB7TnVtYmVyW119XG4gICAqL1xuICB0aGlzLndlc3RJbmRpY2VzU291dGhUb05vcnRoID0gd2VzdEluZGljZXNTb3V0aFRvTm9ydGg7XG5cbiAgLyoqXG4gICAqIFRoZSBpbmRpY2VzIG9mIHRoZSB2ZXJ0aWNlcyBvbiB0aGUgU291dGhlcm4gZWRnZSBvZiB0aGUgdGlsZSwgb3JkZXJlZCBmcm9tIEVhc3QgdG8gV2VzdCAoY2xvY2t3aXNlKS5cbiAgICogQHR5cGUge051bWJlcltdfVxuICAgKi9cbiAgdGhpcy5zb3V0aEluZGljZXNFYXN0VG9XZXN0ID0gc291dGhJbmRpY2VzRWFzdFRvV2VzdDtcblxuICAvKipcbiAgICogVGhlIGluZGljZXMgb2YgdGhlIHZlcnRpY2VzIG9uIHRoZSBFYXN0ZXJuIGVkZ2Ugb2YgdGhlIHRpbGUsIG9yZGVyZWQgZnJvbSBOb3J0aCB0byBTb3V0aCAoY2xvY2t3aXNlKS5cbiAgICogQHR5cGUge051bWJlcltdfVxuICAgKi9cbiAgdGhpcy5lYXN0SW5kaWNlc05vcnRoVG9Tb3V0aCA9IGVhc3RJbmRpY2VzTm9ydGhUb1NvdXRoO1xuXG4gIC8qKlxuICAgKiBUaGUgaW5kaWNlcyBvZiB0aGUgdmVydGljZXMgb24gdGhlIE5vcnRoZXJuIGVkZ2Ugb2YgdGhlIHRpbGUsIG9yZGVyZWQgZnJvbSBXZXN0IHRvIEVhc3QgKGNsb2Nrd2lzZSkuXG4gICAqIEB0eXBlIHtOdW1iZXJbXX1cbiAgICovXG4gIHRoaXMubm9ydGhJbmRpY2VzV2VzdFRvRWFzdCA9IG5vcnRoSW5kaWNlc1dlc3RUb0Vhc3Q7XG59XG5leHBvcnQgZGVmYXVsdCBUZXJyYWluTWVzaDtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///13758\n')},1497:function(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__){eval('/* harmony import */ var _defined_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(82982);\n/* harmony import */ var _DeveloperError_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(12572);\n/* harmony import */ var _IndexDatatype_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(22832);\n/* harmony import */ var _Math_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(99417);\n\n\n\n\n\n/**\n * Provides terrain or other geometry for the surface of an ellipsoid.  The surface geometry is\n * organized into a pyramid of tiles according to a {@link TilingScheme}.  This type describes an\n * interface and is not intended to be instantiated directly.\n *\n * @alias TerrainProvider\n * @constructor\n *\n * @see EllipsoidTerrainProvider\n * @see CesiumTerrainProvider\n * @see VRTheWorldTerrainProvider\n * @see GoogleEarthEnterpriseTerrainProvider\n */\nfunction TerrainProvider() {\n  _DeveloperError_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].throwInstantiationError */ .Z.throwInstantiationError();\n}\n\nObject.defineProperties(TerrainProvider.prototype, {\n  /**\n   * Gets an event that is raised when the terrain provider encounters an asynchronous error..  By subscribing\n   * to the event, you will be notified of the error and can potentially recover from it.  Event listeners\n   * are passed an instance of {@link TileProviderError}.\n   * @memberof TerrainProvider.prototype\n   * @type {Event}\n   * @readonly\n   */\n  errorEvent: {\n    get: _DeveloperError_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].throwInstantiationError */ .Z.throwInstantiationError,\n  },\n\n  /**\n   * Gets the credit to display when this terrain provider is active.  Typically this is used to credit\n   * the source of the terrain. This function should\n   * not be called before {@link TerrainProvider#ready} returns true.\n   * @memberof TerrainProvider.prototype\n   * @type {Credit}\n   * @readonly\n   */\n  credit: {\n    get: _DeveloperError_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].throwInstantiationError */ .Z.throwInstantiationError,\n  },\n\n  /**\n   * Gets the tiling scheme used by the provider.  This function should\n   * not be called before {@link TerrainProvider#ready} returns true.\n   * @memberof TerrainProvider.prototype\n   * @type {TilingScheme}\n   * @readonly\n   */\n  tilingScheme: {\n    get: _DeveloperError_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].throwInstantiationError */ .Z.throwInstantiationError,\n  },\n\n  /**\n   * Gets a value indicating whether or not the provider is ready for use.\n   * @memberof TerrainProvider.prototype\n   * @type {Boolean}\n   * @readonly\n   */\n  ready: {\n    get: _DeveloperError_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].throwInstantiationError */ .Z.throwInstantiationError,\n  },\n\n  /**\n   * Gets a promise that resolves to true when the provider is ready for use.\n   * @memberof TerrainProvider.prototype\n   * @type {Promise.<Boolean>}\n   * @readonly\n   */\n  readyPromise: {\n    get: _DeveloperError_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].throwInstantiationError */ .Z.throwInstantiationError,\n  },\n\n  /**\n   * Gets a value indicating whether or not the provider includes a water mask.  The water mask\n   * indicates which areas of the globe are water rather than land, so they can be rendered\n   * as a reflective surface with animated waves.  This function should not be\n   * called before {@link TerrainProvider#ready} returns true.\n   * @memberof TerrainProvider.prototype\n   * @type {Boolean}\n   * @readonly\n   */\n  hasWaterMask: {\n    get: _DeveloperError_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].throwInstantiationError */ .Z.throwInstantiationError,\n  },\n\n  /**\n   * Gets a value indicating whether or not the requested tiles include vertex normals.\n   * This function should not be called before {@link TerrainProvider#ready} returns true.\n   * @memberof TerrainProvider.prototype\n   * @type {Boolean}\n   * @readonly\n   */\n  hasVertexNormals: {\n    get: _DeveloperError_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].throwInstantiationError */ .Z.throwInstantiationError,\n  },\n\n  /**\n   * Gets an object that can be used to determine availability of terrain from this provider, such as\n   * at points and in rectangles.  This function should not be called before\n   * {@link TerrainProvider#ready} returns true.  This property may be undefined if availability\n   * information is not available.\n   * @memberof TerrainProvider.prototype\n   * @type {TileAvailability}\n   * @readonly\n   */\n  availability: {\n    get: _DeveloperError_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].throwInstantiationError */ .Z.throwInstantiationError,\n  },\n});\n\nvar regularGridIndicesCache = [];\n\n/**\n * Gets a list of indices for a triangle mesh representing a regular grid.  Calling\n * this function multiple times with the same grid width and height returns the\n * same list of indices.  The total number of vertices must be less than or equal\n * to 65536.\n *\n * @param {Number} width The number of vertices in the regular grid in the horizontal direction.\n * @param {Number} height The number of vertices in the regular grid in the vertical direction.\n * @returns {Uint16Array|Uint32Array} The list of indices. Uint16Array gets returned for 64KB or less and Uint32Array for 4GB or less.\n */\nTerrainProvider.getRegularGridIndices = function (width, height) {\n  //>>includeStart(\'debug\', pragmas.debug);\n  if (width * height >= _Math_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"].FOUR_GIGABYTES */ .Z.FOUR_GIGABYTES) {\n    throw new _DeveloperError_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .Z(\n      "The total number of vertices (width * height) must be less than 4,294,967,296."\n    );\n  }\n  //>>includeEnd(\'debug\');\n\n  var byWidth = regularGridIndicesCache[width];\n  if (!(0,_defined_js__WEBPACK_IMPORTED_MODULE_3__/* ["default"] */ .Z)(byWidth)) {\n    regularGridIndicesCache[width] = byWidth = [];\n  }\n\n  var indices = byWidth[height];\n  if (!(0,_defined_js__WEBPACK_IMPORTED_MODULE_3__/* ["default"] */ .Z)(indices)) {\n    if (width * height < _Math_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"].SIXTY_FOUR_KILOBYTES */ .Z.SIXTY_FOUR_KILOBYTES) {\n      indices = byWidth[height] = new Uint16Array(\n        (width - 1) * (height - 1) * 6\n      );\n    } else {\n      indices = byWidth[height] = new Uint32Array(\n        (width - 1) * (height - 1) * 6\n      );\n    }\n    addRegularGridIndices(width, height, indices, 0);\n  }\n\n  return indices;\n};\n\nvar regularGridAndEdgeIndicesCache = [];\n\n/**\n * @private\n */\nTerrainProvider.getRegularGridIndicesAndEdgeIndices = function (width, height) {\n  //>>includeStart(\'debug\', pragmas.debug);\n  if (width * height >= _Math_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"].FOUR_GIGABYTES */ .Z.FOUR_GIGABYTES) {\n    throw new _DeveloperError_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .Z(\n      "The total number of vertices (width * height) must be less than 4,294,967,296."\n    );\n  }\n  //>>includeEnd(\'debug\');\n\n  var byWidth = regularGridAndEdgeIndicesCache[width];\n  if (!(0,_defined_js__WEBPACK_IMPORTED_MODULE_3__/* ["default"] */ .Z)(byWidth)) {\n    regularGridAndEdgeIndicesCache[width] = byWidth = [];\n  }\n\n  var indicesAndEdges = byWidth[height];\n  if (!(0,_defined_js__WEBPACK_IMPORTED_MODULE_3__/* ["default"] */ .Z)(indicesAndEdges)) {\n    var indices = TerrainProvider.getRegularGridIndices(width, height);\n\n    var edgeIndices = getEdgeIndices(width, height);\n    var westIndicesSouthToNorth = edgeIndices.westIndicesSouthToNorth;\n    var southIndicesEastToWest = edgeIndices.southIndicesEastToWest;\n    var eastIndicesNorthToSouth = edgeIndices.eastIndicesNorthToSouth;\n    var northIndicesWestToEast = edgeIndices.northIndicesWestToEast;\n\n    indicesAndEdges = byWidth[height] = {\n      indices: indices,\n      westIndicesSouthToNorth: westIndicesSouthToNorth,\n      southIndicesEastToWest: southIndicesEastToWest,\n      eastIndicesNorthToSouth: eastIndicesNorthToSouth,\n      northIndicesWestToEast: northIndicesWestToEast,\n    };\n  }\n\n  return indicesAndEdges;\n};\n\nvar regularGridAndSkirtAndEdgeIndicesCache = [];\n\n/**\n * @private\n */\nTerrainProvider.getRegularGridAndSkirtIndicesAndEdgeIndices = function (\n  width,\n  height\n) {\n  //>>includeStart(\'debug\', pragmas.debug);\n  if (width * height >= _Math_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"].FOUR_GIGABYTES */ .Z.FOUR_GIGABYTES) {\n    throw new _DeveloperError_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .Z(\n      "The total number of vertices (width * height) must be less than 4,294,967,296."\n    );\n  }\n  //>>includeEnd(\'debug\');\n\n  var byWidth = regularGridAndSkirtAndEdgeIndicesCache[width];\n  if (!(0,_defined_js__WEBPACK_IMPORTED_MODULE_3__/* ["default"] */ .Z)(byWidth)) {\n    regularGridAndSkirtAndEdgeIndicesCache[width] = byWidth = [];\n  }\n\n  var indicesAndEdges = byWidth[height];\n  if (!(0,_defined_js__WEBPACK_IMPORTED_MODULE_3__/* ["default"] */ .Z)(indicesAndEdges)) {\n    var gridVertexCount = width * height;\n    var gridIndexCount = (width - 1) * (height - 1) * 6;\n    var edgeVertexCount = width * 2 + height * 2;\n    var edgeIndexCount = Math.max(0, edgeVertexCount - 4) * 6;\n    var vertexCount = gridVertexCount + edgeVertexCount;\n    var indexCount = gridIndexCount + edgeIndexCount;\n\n    var edgeIndices = getEdgeIndices(width, height);\n    var westIndicesSouthToNorth = edgeIndices.westIndicesSouthToNorth;\n    var southIndicesEastToWest = edgeIndices.southIndicesEastToWest;\n    var eastIndicesNorthToSouth = edgeIndices.eastIndicesNorthToSouth;\n    var northIndicesWestToEast = edgeIndices.northIndicesWestToEast;\n\n    var indices = _IndexDatatype_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"].createTypedArray */ .Z.createTypedArray(vertexCount, indexCount);\n    addRegularGridIndices(width, height, indices, 0);\n    TerrainProvider.addSkirtIndices(\n      westIndicesSouthToNorth,\n      southIndicesEastToWest,\n      eastIndicesNorthToSouth,\n      northIndicesWestToEast,\n      gridVertexCount,\n      indices,\n      gridIndexCount\n    );\n\n    indicesAndEdges = byWidth[height] = {\n      indices: indices,\n      westIndicesSouthToNorth: westIndicesSouthToNorth,\n      southIndicesEastToWest: southIndicesEastToWest,\n      eastIndicesNorthToSouth: eastIndicesNorthToSouth,\n      northIndicesWestToEast: northIndicesWestToEast,\n      indexCountWithoutSkirts: gridIndexCount,\n    };\n  }\n\n  return indicesAndEdges;\n};\n\n/**\n * @private\n */\nTerrainProvider.addSkirtIndices = function (\n  westIndicesSouthToNorth,\n  southIndicesEastToWest,\n  eastIndicesNorthToSouth,\n  northIndicesWestToEast,\n  vertexCount,\n  indices,\n  offset\n) {\n  var vertexIndex = vertexCount;\n  offset = addSkirtIndices(\n    westIndicesSouthToNorth,\n    vertexIndex,\n    indices,\n    offset\n  );\n  vertexIndex += westIndicesSouthToNorth.length;\n  offset = addSkirtIndices(\n    southIndicesEastToWest,\n    vertexIndex,\n    indices,\n    offset\n  );\n  vertexIndex += southIndicesEastToWest.length;\n  offset = addSkirtIndices(\n    eastIndicesNorthToSouth,\n    vertexIndex,\n    indices,\n    offset\n  );\n  vertexIndex += eastIndicesNorthToSouth.length;\n  addSkirtIndices(northIndicesWestToEast, vertexIndex, indices, offset);\n};\n\nfunction getEdgeIndices(width, height) {\n  var westIndicesSouthToNorth = new Array(height);\n  var southIndicesEastToWest = new Array(width);\n  var eastIndicesNorthToSouth = new Array(height);\n  var northIndicesWestToEast = new Array(width);\n\n  var i;\n  for (i = 0; i < width; ++i) {\n    northIndicesWestToEast[i] = i;\n    southIndicesEastToWest[i] = width * height - 1 - i;\n  }\n\n  for (i = 0; i < height; ++i) {\n    eastIndicesNorthToSouth[i] = (i + 1) * width - 1;\n    westIndicesSouthToNorth[i] = (height - i - 1) * width;\n  }\n\n  return {\n    westIndicesSouthToNorth: westIndicesSouthToNorth,\n    southIndicesEastToWest: southIndicesEastToWest,\n    eastIndicesNorthToSouth: eastIndicesNorthToSouth,\n    northIndicesWestToEast: northIndicesWestToEast,\n  };\n}\n\nfunction addRegularGridIndices(width, height, indices, offset) {\n  var index = 0;\n  for (var j = 0; j < height - 1; ++j) {\n    for (var i = 0; i < width - 1; ++i) {\n      var upperLeft = index;\n      var lowerLeft = upperLeft + width;\n      var lowerRight = lowerLeft + 1;\n      var upperRight = upperLeft + 1;\n\n      indices[offset++] = upperLeft;\n      indices[offset++] = lowerLeft;\n      indices[offset++] = upperRight;\n      indices[offset++] = upperRight;\n      indices[offset++] = lowerLeft;\n      indices[offset++] = lowerRight;\n\n      ++index;\n    }\n    ++index;\n  }\n}\n\nfunction addSkirtIndices(edgeIndices, vertexIndex, indices, offset) {\n  var previousIndex = edgeIndices[0];\n\n  var length = edgeIndices.length;\n  for (var i = 1; i < length; ++i) {\n    var index = edgeIndices[i];\n\n    indices[offset++] = previousIndex;\n    indices[offset++] = index;\n    indices[offset++] = vertexIndex;\n\n    indices[offset++] = vertexIndex;\n    indices[offset++] = index;\n    indices[offset++] = vertexIndex + 1;\n\n    previousIndex = index;\n    ++vertexIndex;\n  }\n\n  return offset;\n}\n\n/**\n * Specifies the quality of terrain created from heightmaps.  A value of 1.0 will\n * ensure that adjacent heightmap vertices are separated by no more than\n * {@link Globe.maximumScreenSpaceError} screen pixels and will probably go very slowly.\n * A value of 0.5 will cut the estimated level zero geometric error in half, allowing twice the\n * screen pixels between adjacent heightmap vertices and thus rendering more quickly.\n * @type {Number}\n */\nTerrainProvider.heightmapTerrainQuality = 0.25;\n\n/**\n * Determines an appropriate geometric error estimate when the geometry comes from a heightmap.\n *\n * @param {Ellipsoid} ellipsoid The ellipsoid to which the terrain is attached.\n * @param {Number} tileImageWidth The width, in pixels, of the heightmap associated with a single tile.\n * @param {Number} numberOfTilesAtLevelZero The number of tiles in the horizontal direction at tile level zero.\n * @returns {Number} An estimated geometric error.\n */\nTerrainProvider.getEstimatedLevelZeroGeometricErrorForAHeightmap = function (\n  ellipsoid,\n  tileImageWidth,\n  numberOfTilesAtLevelZero\n) {\n  return (\n    (ellipsoid.maximumRadius *\n      2 *\n      Math.PI *\n      TerrainProvider.heightmapTerrainQuality) /\n    (tileImageWidth * numberOfTilesAtLevelZero)\n  );\n};\n\n/**\n * Requests the geometry for a given tile.  This function should not be called before\n * {@link TerrainProvider#ready} returns true.  The result must include terrain data and\n * may optionally include a water mask and an indication of which child tiles are available.\n * @function\n *\n * @param {Number} x The X coordinate of the tile for which to request geometry.\n * @param {Number} y The Y coordinate of the tile for which to request geometry.\n * @param {Number} level The level of the tile for which to request geometry.\n * @param {Request} [request] The request object. Intended for internal use only.\n *\n * @returns {Promise.<TerrainData>|undefined} A promise for the requested geometry.  If this method\n *          returns undefined instead of a promise, it is an indication that too many requests are already\n *          pending and the request will be retried later.\n */\nTerrainProvider.prototype.requestTileGeometry =\n  _DeveloperError_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].throwInstantiationError */ .Z.throwInstantiationError;\n\n/**\n * Gets the maximum geometric error allowed in a tile at a given level.  This function should not be\n * called before {@link TerrainProvider#ready} returns true.\n * @function\n *\n * @param {Number} level The tile level for which to get the maximum geometric error.\n * @returns {Number} The maximum geometric error.\n */\nTerrainProvider.prototype.getLevelMaximumGeometricError =\n  _DeveloperError_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].throwInstantiationError */ .Z.throwInstantiationError;\n\n/**\n * Determines whether data for a tile is available to be loaded.\n * @function\n *\n * @param {Number} x The X coordinate of the tile for which to request geometry.\n * @param {Number} y The Y coordinate of the tile for which to request geometry.\n * @param {Number} level The level of the tile for which to request geometry.\n * @returns {Boolean|undefined} Undefined if not supported by the terrain provider, otherwise true or false.\n */\nTerrainProvider.prototype.getTileDataAvailable =\n  _DeveloperError_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].throwInstantiationError */ .Z.throwInstantiationError;\n\n/**\n * Makes sure we load availability data for a tile\n * @function\n *\n * @param {Number} x The X coordinate of the tile for which to request geometry.\n * @param {Number} y The Y coordinate of the tile for which to request geometry.\n * @param {Number} level The level of the tile for which to request geometry.\n * @returns {undefined|Promise<void>} Undefined if nothing need to be loaded or a Promise that resolves when all required tiles are loaded\n */\nTerrainProvider.prototype.loadTileDataAvailability =\n  _DeveloperError_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].throwInstantiationError */ .Z.throwInstantiationError;\n/* harmony default export */ __webpack_exports__["Z"] = (TerrainProvider);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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Qiw2QkFBNkI7QUFDL0M7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBLEVBQUUsbUhBQXNDOztBQUV4QztBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLGFBQWEsbUJBQW1CO0FBQ2hDO0FBQ0E7QUFDQSxFQUFFLG1IQUFzQzs7QUFFeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixhQUFhLHlCQUF5QjtBQUN0QztBQUNBO0FBQ0EsRUFBRSxtSEFBc0M7QUFDeEMseURBQWUsZUFBZSxFQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdnVlMy13ZWJwYWNrNS8uL25vZGVfbW9kdWxlcy9jZXNpdW0vU291cmNlL0NvcmUvVGVycmFpblByb3ZpZGVyLmpzPzUzNzgiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IGRlZmluZWQgZnJvbSBcIi4vZGVmaW5lZC5qc1wiO1xuaW1wb3J0IERldmVsb3BlckVycm9yIGZyb20gXCIuL0RldmVsb3BlckVycm9yLmpzXCI7XG5pbXBvcnQgSW5kZXhEYXRhdHlwZSBmcm9tIFwiLi9JbmRleERhdGF0eXBlLmpzXCI7XG5pbXBvcnQgQ2VzaXVtTWF0aCBmcm9tIFwiLi9NYXRoLmpzXCI7XG5cbi8qKlxuICogUHJvdmlkZXMgdGVycmFpbiBvciBvdGhlciBnZW9tZXRyeSBmb3IgdGhlIHN1cmZhY2Ugb2YgYW4gZWxsaXBzb2lkLiAgVGhlIHN1cmZhY2UgZ2VvbWV0cnkgaXNcbiAqIG9yZ2FuaXplZCBpbnRvIGEgcHlyYW1pZCBvZiB0aWxlcyBhY2NvcmRpbmcgdG8gYSB7QGxpbmsgVGlsaW5nU2NoZW1lfS4gIFRoaXMgdHlwZSBkZXNjcmliZXMgYW5cbiAqIGludGVyZmFjZSBhbmQgaXMgbm90IGludGVuZGVkIHRvIGJlIGluc3RhbnRpYXRlZCBkaXJlY3RseS5cbiAqXG4gKiBAYWxpYXMgVGVycmFpblByb3ZpZGVyXG4gKiBAY29uc3RydWN0b3JcbiAqXG4gKiBAc2VlIEVsbGlwc29pZFRlcnJhaW5Qcm92aWRlclxuICogQHNlZSBDZXNpdW1UZXJyYWluUHJvdmlkZXJcbiAqIEBzZWUgVlJUaGVXb3JsZFRlcnJhaW5Qcm92aWRlclxuICogQHNlZSBHb29nbGVFYXJ0aEVudGVycHJpc2VUZXJyYWluUHJvdmlkZXJcbiAqL1xuZnVuY3Rpb24gVGVycmFpblByb3ZpZGVyKCkge1xuICBEZXZlbG9wZXJFcnJvci50aHJvd0luc3RhbnRpYXRpb25FcnJvcigpO1xufVxuXG5PYmplY3QuZGVmaW5lUHJvcGVydGllcyhUZXJyYWluUHJvdmlkZXIucHJvdG90eXBlLCB7XG4gIC8qKlxuICAgKiBHZXRzIGFuIGV2ZW50IHRoYXQgaXMgcmFpc2VkIHdoZW4gdGhlIHRlcnJhaW4gcHJvdmlkZXIgZW5jb3VudGVycyBhbiBhc3luY2hyb25vdXMgZXJyb3IuLiAgQnkgc3Vic2NyaWJpbmdcbiAgICogdG8gdGhlIGV2ZW50LCB5b3Ugd2lsbCBiZSBub3RpZmllZCBvZiB0aGUgZXJyb3IgYW5kIGNhbiBwb3RlbnRpYWxseSByZWNvdmVyIGZyb20gaXQuICBFdmVudCBsaXN0ZW5lcnNcbiAgICogYXJlIHBhc3NlZCBhbiBpbnN0YW5jZSBvZiB7QGxpbmsgVGlsZVByb3ZpZGVyRXJyb3J9LlxuICAgKiBAbWVtYmVyb2YgVGVycmFpblByb3ZpZGVyLnByb3RvdHlwZVxuICAgKiBAdHlwZSB7RXZlbnR9XG4gICAqIEByZWFkb25seVxuICAgKi9cbiAgZXJyb3JFdmVudDoge1xuICAgIGdldDogRGV2ZWxvcGVyRXJyb3IudGhyb3dJbnN0YW50aWF0aW9uRXJyb3IsXG4gIH0sXG5cbiAgLyoqXG4gICAqIEdldHMgdGhlIGNyZWRpdCB0byBkaXNwbGF5IHdoZW4gdGhpcyB0ZXJyYWluIHByb3ZpZGVyIGlzIGFjdGl2ZS4gIFR5cGljYWxseSB0aGlzIGlzIHVzZWQgdG8gY3JlZGl0XG4gICAqIHRoZSBzb3VyY2Ugb2YgdGhlIHRlcnJhaW4uIFRoaXMgZnVuY3Rpb24gc2hvdWxkXG4gICAqIG5vdCBiZSBjYWxsZWQgYmVmb3JlIHtAbGluayBUZXJyYWluUHJvdmlkZXIjcmVhZHl9IHJldHVybnMgdHJ1ZS5cbiAgICogQG1lbWJlcm9mIFRlcnJhaW5Qcm92aWRlci5wcm90b3R5cGVcbiAgICogQHR5cGUge0NyZWRpdH1cbiAgICogQHJlYWRvbmx5XG4gICAqL1xuICBjcmVkaXQ6IHtcbiAgICBnZXQ6IERldmVsb3BlckVycm9yLnRocm93SW5zdGFudGlhdGlvbkVycm9yLFxuICB9LFxuXG4gIC8qKlxuICAgKiBHZXRzIHRoZSB0aWxpbmcgc2NoZW1lIHVzZWQgYnkgdGhlIHByb3ZpZGVyLiAgVGhpcyBmdW5jdGlvbiBzaG91bGRcbiAgICogbm90IGJlIGNhbGxlZCBiZWZvcmUge0BsaW5rIFRlcnJhaW5Qcm92aWRlciNyZWFkeX0gcmV0dXJucyB0cnVlLlxuICAgKiBAbWVtYmVyb2YgVGVycmFpblByb3ZpZGVyLnByb3RvdHlwZVxuICAgKiBAdHlwZSB7VGlsaW5nU2NoZW1lfVxuICAgKiBAcmVhZG9ubHlcbiAgICovXG4gIHRpbGluZ1NjaGVtZToge1xuICAgIGdldDogRGV2ZWxvcGVyRXJyb3IudGhyb3dJbnN0YW50aWF0aW9uRXJyb3IsXG4gIH0sXG5cbiAgLyoqXG4gICAqIEdldHMgYSB2YWx1ZSBpbmRpY2F0aW5nIHdoZXRoZXIgb3Igbm90IHRoZSBwcm92aWRlciBpcyByZWFkeSBmb3IgdXNlLlxuICAgKiBAbWVtYmVyb2YgVGVycmFpblByb3ZpZGVyLnByb3RvdHlwZVxuICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICogQHJlYWRvbmx5XG4gICAqL1xuICByZWFkeToge1xuICAgIGdldDogRGV2ZWxvcGVyRXJyb3IudGhyb3dJbnN0YW50aWF0aW9uRXJyb3IsXG4gIH0sXG5cbiAgLyoqXG4gICAqIEdldHMgYSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gdHJ1ZSB3aGVuIHRoZSBwcm92aWRlciBpcyByZWFkeSBmb3IgdXNlLlxuICAgKiBAbWVtYmVyb2YgVGVycmFpblByb3ZpZGVyLnByb3RvdHlwZVxuICAgKiBAdHlwZSB7UHJvbWlzZS48Qm9vbGVhbj59XG4gICAqIEByZWFkb25seVxuICAgKi9cbiAgcmVhZHlQcm9taXNlOiB7XG4gICAgZ2V0OiBEZXZlbG9wZXJFcnJvci50aHJvd0luc3RhbnRpYXRpb25FcnJvcixcbiAgfSxcblxuICAvKipcbiAgICogR2V0cyBhIHZhbHVlIGluZGljYXRpbmcgd2hldGhlciBvciBub3QgdGhlIHByb3ZpZGVyIGluY2x1ZGVzIGEgd2F0ZXIgbWFzay4gIFRoZSB3YXRlciBtYXNrXG4gICAqIGluZGljYXRlcyB3aGljaCBhcmVhcyBvZiB0aGUgZ2xvYmUgYXJlIHdhdGVyIHJhdGhlciB0aGFuIGxhbmQsIHNvIHRoZXkgY2FuIGJlIHJlbmRlcmVkXG4gICAqIGFzIGEgcmVmbGVjdGl2ZSBzdXJmYWNlIHdpdGggYW5pbWF0ZWQgd2F2ZXMuICBUaGlzIGZ1bmN0aW9uIHNob3VsZCBub3QgYmVcbiAgICogY2FsbGVkIGJlZm9yZSB7QGxpbmsgVGVycmFpblByb3ZpZGVyI3JlYWR5fSByZXR1cm5zIHRydWUuXG4gICAqIEBtZW1iZXJvZiBUZXJyYWluUHJvdmlkZXIucHJvdG90eXBlXG4gICAqIEB0eXBlIHtCb29sZWFufVxuICAgKiBAcmVhZG9ubHlcbiAgICovXG4gIGhhc1dhdGVyTWFzazoge1xuICAgIGdldDogRGV2ZWxvcGVyRXJyb3IudGhyb3dJbnN0YW50aWF0aW9uRXJyb3IsXG4gIH0sXG5cbiAgLyoqXG4gICAqIEdldHMgYSB2YWx1ZSBpbmRpY2F0aW5nIHdoZXRoZXIgb3Igbm90IHRoZSByZXF1ZXN0ZWQgdGlsZXMgaW5jbHVkZSB2ZXJ0ZXggbm9ybWFscy5cbiAgICogVGhpcyBmdW5jdGlvbiBzaG91bGQgbm90IGJlIGNhbGxlZCBiZWZvcmUge0BsaW5rIFRlcnJhaW5Qcm92aWRlciNyZWFkeX0gcmV0dXJucyB0cnVlLlxuICAgKiBAbWVtYmVyb2YgVGVycmFpblByb3ZpZGVyLnByb3RvdHlwZVxuICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICogQHJlYWRvbmx5XG4gICAqL1xuICBoYXNWZXJ0ZXhOb3JtYWxzOiB7XG4gICAgZ2V0OiBEZXZlbG9wZXJFcnJvci50aHJvd0luc3RhbnRpYXRpb25FcnJvcixcbiAgfSxcblxuICAvKipcbiAgICogR2V0cyBhbiBvYmplY3QgdGhhdCBjYW4gYmUgdXNlZCB0byBkZXRlcm1pbmUgYXZhaWxhYmlsaXR5IG9mIHRlcnJhaW4gZnJvbSB0aGlzIHByb3ZpZGVyLCBzdWNoIGFzXG4gICAqIGF0IHBvaW50cyBhbmQgaW4gcmVjdGFuZ2xlcy4gIFRoaXMgZnVuY3Rpb24gc2hvdWxkIG5vdCBiZSBjYWxsZWQgYmVmb3JlXG4gICAqIHtAbGluayBUZXJyYWluUHJvdmlkZXIjcmVhZHl9IHJldHVybnMgdHJ1ZS4gIFRoaXMgcHJvcGVydHkgbWF5IGJlIHVuZGVmaW5lZCBpZiBhdmFpbGFiaWxpdHlcbiAgICogaW5mb3JtYXRpb24gaXMgbm90IGF2YWlsYWJsZS5cbiAgICogQG1lbWJlcm9mIFRlcnJhaW5Qcm92aWRlci5wcm90b3R5cGVcbiAgICogQHR5cGUge1RpbGVBdmFpbGFiaWxpdHl9XG4gICAqIEByZWFkb25seVxuICAgKi9cbiAgYXZhaWxhYmlsaXR5OiB7XG4gICAgZ2V0OiBEZXZlbG9wZXJFcnJvci50aHJvd0luc3RhbnRpYXRpb25FcnJvcixcbiAgfSxcbn0pO1xuXG52YXIgcmVndWxhckdyaWRJbmRpY2VzQ2FjaGUgPSBbXTtcblxuLyoqXG4gKiBHZXRzIGEgbGlzdCBvZiBpbmRpY2VzIGZvciBhIHRyaWFuZ2xlIG1lc2ggcmVwcmVzZW50aW5nIGEgcmVndWxhciBncmlkLiAgQ2FsbGluZ1xuICogdGhpcyBmdW5jdGlvbiBtdWx0aXBsZSB0aW1lcyB3aXRoIHRoZSBzYW1lIGdyaWQgd2lkdGggYW5kIGhlaWdodCByZXR1cm5zIHRoZVxuICogc2FtZSBsaXN0IG9mIGluZGljZXMuICBUaGUgdG90YWwgbnVtYmVyIG9mIHZlcnRpY2VzIG11c3QgYmUgbGVzcyB0aGFuIG9yIGVxdWFsXG4gKiB0byA2NTUzNi5cbiAqXG4gKiBAcGFyYW0ge051bWJlcn0gd2lkdGggVGhlIG51bWJlciBvZiB2ZXJ0aWNlcyBpbiB0aGUgcmVndWxhciBncmlkIGluIHRoZSBob3Jpem9udGFsIGRpcmVjdGlvbi5cbiAqIEBwYXJhbSB7TnVtYmVyfSBoZWlnaHQgVGhlIG51bWJlciBvZiB2ZXJ0aWNlcyBpbiB0aGUgcmVndWxhciBncmlkIGluIHRoZSB2ZXJ0aWNhbCBkaXJlY3Rpb24uXG4gKiBAcmV0dXJucyB7VWludDE2QXJyYXl8VWludDMyQXJyYXl9IFRoZSBsaXN0IG9mIGluZGljZXMuIFVpbnQxNkFycmF5IGdldHMgcmV0dXJuZWQgZm9yIDY0S0Igb3IgbGVzcyBhbmQgVWludDMyQXJyYXkgZm9yIDRHQiBvciBsZXNzLlxuICovXG5UZXJyYWluUHJvdmlkZXIuZ2V0UmVndWxhckdyaWRJbmRpY2VzID0gZnVuY3Rpb24gKHdpZHRoLCBoZWlnaHQpIHtcbiAgLy8+PmluY2x1ZGVTdGFydCgnZGVidWcnLCBwcmFnbWFzLmRlYnVnKTtcbiAgaWYgKHdpZHRoICogaGVpZ2h0ID49IENlc2l1bU1hdGguRk9VUl9HSUdBQllURVMpIHtcbiAgICB0aHJvdyBuZXcgRGV2ZWxvcGVyRXJyb3IoXG4gICAgICBcIlRoZSB0b3RhbCBudW1iZXIgb2YgdmVydGljZXMgKHdpZHRoICogaGVpZ2h0KSBtdXN0IGJlIGxlc3MgdGhhbiA0LDI5NCw5NjcsMjk2LlwiXG4gICAgKTtcbiAgfVxuICAvLz4+aW5jbHVkZUVuZCgnZGVidWcnKTtcblxuICB2YXIgYnlXaWR0aCA9IHJlZ3VsYXJHcmlkSW5kaWNlc0NhY2hlW3dpZHRoXTtcbiAgaWYgKCFkZWZpbmVkKGJ5V2lkdGgpKSB7XG4gICAgcmVndWxhckdyaWRJbmRpY2VzQ2FjaGVbd2lkdGhdID0gYnlXaWR0aCA9IFtdO1xuICB9XG5cbiAgdmFyIGluZGljZXMgPSBieVdpZHRoW2hlaWdodF07XG4gIGlmICghZGVmaW5lZChpbmRpY2VzKSkge1xuICAgIGlmICh3aWR0aCAqIGhlaWdodCA8IENlc2l1bU1hdGguU0lYVFlfRk9VUl9LSUxPQllURVMpIHtcbiAgICAgIGluZGljZXMgPSBieVdpZHRoW2hlaWdodF0gPSBuZXcgVWludDE2QXJyYXkoXG4gICAgICAgICh3aWR0aCAtIDEpICogKGhlaWdodCAtIDEpICogNlxuICAgICAgKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaW5kaWNlcyA9IGJ5V2lkdGhbaGVpZ2h0XSA9IG5ldyBVaW50MzJBcnJheShcbiAgICAgICAgKHdpZHRoIC0gMSkgKiAoaGVpZ2h0IC0gMSkgKiA2XG4gICAgICApO1xuICAgIH1cbiAgICBhZGRSZWd1bGFyR3JpZEluZGljZXMod2lkdGgsIGhlaWdodCwgaW5kaWNlcywgMCk7XG4gIH1cblxuICByZXR1cm4gaW5kaWNlcztcbn07XG5cbnZhciByZWd1bGFyR3JpZEFuZEVkZ2VJbmRpY2VzQ2FjaGUgPSBbXTtcblxuLyoqXG4gKiBAcHJpdmF0ZVxuICovXG5UZXJyYWluUHJvdmlkZXIuZ2V0UmVndWxhckdyaWRJbmRpY2VzQW5kRWRnZUluZGljZXMgPSBmdW5jdGlvbiAod2lkdGgsIGhlaWdodCkge1xuICAvLz4+aW5jbHVkZVN0YXJ0KCdkZWJ1ZycsIHByYWdtYXMuZGVidWcpO1xuICBpZiAod2lkdGggKiBoZWlnaHQgPj0gQ2VzaXVtTWF0aC5GT1VSX0dJR0FCWVRFUykge1xuICAgIHRocm93IG5ldyBEZXZlbG9wZXJFcnJvcihcbiAgICAgIFwiVGhlIHRvdGFsIG51bWJlciBvZiB2ZXJ0aWNlcyAod2lkdGggKiBoZWlnaHQpIG11c3QgYmUgbGVzcyB0aGFuIDQsMjk0LDk2NywyOTYuXCJcbiAgICApO1xuICB9XG4gIC8vPj5pbmNsdWRlRW5kKCdkZWJ1ZycpO1xuXG4gIHZhciBieVdpZHRoID0gcmVndWxhckdyaWRBbmRFZGdlSW5kaWNlc0NhY2hlW3dpZHRoXTtcbiAgaWYgKCFkZWZpbmVkKGJ5V2lkdGgpKSB7XG4gICAgcmVndWxhckdyaWRBbmRFZGdlSW5kaWNlc0NhY2hlW3dpZHRoXSA9IGJ5V2lkdGggPSBbXTtcbiAgfVxuXG4gIHZhciBpbmRpY2VzQW5kRWRnZXMgPSBieVdpZHRoW2hlaWdodF07XG4gIGlmICghZGVmaW5lZChpbmRpY2VzQW5kRWRnZXMpKSB7XG4gICAgdmFyIGluZGljZXMgPSBUZXJyYWluUHJvdmlkZXIuZ2V0UmVndWxhckdyaWRJbmRpY2VzKHdpZHRoLCBoZWlnaHQpO1xuXG4gICAgdmFyIGVkZ2VJbmRpY2VzID0gZ2V0RWRnZUluZGljZXMod2lkdGgsIGhlaWdodCk7XG4gICAgdmFyIHdlc3RJbmRpY2VzU291dGhUb05vcnRoID0gZWRnZUluZGljZXMud2VzdEluZGljZXNTb3V0aFRvTm9ydGg7XG4gICAgdmFyIHNvdXRoSW5kaWNlc0Vhc3RUb1dlc3QgPSBlZGdlSW5kaWNlcy5zb3V0aEluZGljZXNFYXN0VG9XZXN0O1xuICAgIHZhciBlYXN0SW5kaWNlc05vcnRoVG9Tb3V0aCA9IGVkZ2VJbmRpY2VzLmVhc3RJbmRpY2VzTm9ydGhUb1NvdXRoO1xuICAgIHZhciBub3J0aEluZGljZXNXZXN0VG9FYXN0ID0gZWRnZUluZGljZXMubm9ydGhJbmRpY2VzV2VzdFRvRWFzdDtcblxuICAgIGluZGljZXNBbmRFZGdlcyA9IGJ5V2lkdGhbaGVpZ2h0XSA9IHtcbiAgICAgIGluZGljZXM6IGluZGljZXMsXG4gICAgICB3ZXN0SW5kaWNlc1NvdXRoVG9Ob3J0aDogd2VzdEluZGljZXNTb3V0aFRvTm9ydGgsXG4gICAgICBzb3V0aEluZGljZXNFYXN0VG9XZXN0OiBzb3V0aEluZGljZXNFYXN0VG9XZXN0LFxuICAgICAgZWFzdEluZGljZXNOb3J0aFRvU291dGg6IGVhc3RJbmRpY2VzTm9ydGhUb1NvdXRoLFxuICAgICAgbm9ydGhJbmRpY2VzV2VzdFRvRWFzdDogbm9ydGhJbmRpY2VzV2VzdFRvRWFzdCxcbiAgICB9O1xuICB9XG5cbiAgcmV0dXJuIGluZGljZXNBbmRFZGdlcztcbn07XG5cbnZhciByZWd1bGFyR3JpZEFuZFNraXJ0QW5kRWRnZUluZGljZXNDYWNoZSA9IFtdO1xuXG4vKipcbiAqIEBwcml2YXRlXG4gKi9cblRlcnJhaW5Qcm92aWRlci5nZXRSZWd1bGFyR3JpZEFuZFNraXJ0SW5kaWNlc0FuZEVkZ2VJbmRpY2VzID0gZnVuY3Rpb24gKFxuICB3aWR0aCxcbiAgaGVpZ2h0XG4pIHtcbiAgLy8+PmluY2x1ZGVTdGFydCgnZGVidWcnLCBwcmFnbWFzLmRlYnVnKTtcbiAgaWYgKHdpZHRoICogaGVpZ2h0ID49IENlc2l1bU1hdGguRk9VUl9HSUdBQllURVMpIHtcbiAgICB0aHJvdyBuZXcgRGV2ZWxvcGVyRXJyb3IoXG4gICAgICBcIlRoZSB0b3RhbCBudW1iZXIgb2YgdmVydGljZXMgKHdpZHRoICogaGVpZ2h0KSBtdXN0IGJlIGxlc3MgdGhhbiA0LDI5NCw5NjcsMjk2LlwiXG4gICAgKTtcbiAgfVxuICAvLz4+aW5jbHVkZUVuZCgnZGVidWcnKTtcblxuICB2YXIgYnlXaWR0aCA9IHJlZ3VsYXJHcmlkQW5kU2tpcnRBbmRFZGdlSW5kaWNlc0NhY2hlW3dpZHRoXTtcbiAgaWYgKCFkZWZpbmVkKGJ5V2lkdGgpKSB7XG4gICAgcmVndWxhckdyaWRBbmRTa2lydEFuZEVkZ2VJbmRpY2VzQ2FjaGVbd2lkdGhdID0gYnlXaWR0aCA9IFtdO1xuICB9XG5cbiAgdmFyIGluZGljZXNBbmRFZGdlcyA9IGJ5V2lkdGhbaGVpZ2h0XTtcbiAgaWYgKCFkZWZpbmVkKGluZGljZXNBbmRFZGdlcykpIHtcbiAgICB2YXIgZ3JpZFZlcnRleENvdW50ID0gd2lkdGggKiBoZWlnaHQ7XG4gICAgdmFyIGdyaWRJbmRleENvdW50ID0gKHdpZHRoIC0gMSkgKiAoaGVpZ2h0IC0gMSkgKiA2O1xuICAgIHZhciBlZGdlVmVydGV4Q291bnQgPSB3aWR0aCAqIDIgKyBoZWlnaHQgKiAyO1xuICAgIHZhciBlZGdlSW5kZXhDb3VudCA9IE1hdGgubWF4KDAsIGVkZ2VWZXJ0ZXhDb3VudCAtIDQpICogNjtcbiAgICB2YXIgdmVydGV4Q291bnQgPSBncmlkVmVydGV4Q291bnQgKyBlZGdlVmVydGV4Q291bnQ7XG4gICAgdmFyIGluZGV4Q291bnQgPSBncmlkSW5kZXhDb3VudCArIGVkZ2VJbmRleENvdW50O1xuXG4gICAgdmFyIGVkZ2VJbmRpY2VzID0gZ2V0RWRnZUluZGljZXMod2lkdGgsIGhlaWdodCk7XG4gICAgdmFyIHdlc3RJbmRpY2VzU291dGhUb05vcnRoID0gZWRnZUluZGljZXMud2VzdEluZGljZXNTb3V0aFRvTm9ydGg7XG4gICAgdmFyIHNvdXRoSW5kaWNlc0Vhc3RUb1dlc3QgPSBlZGdlSW5kaWNlcy5zb3V0aEluZGljZXNFYXN0VG9XZXN0O1xuICAgIHZhciBlYXN0SW5kaWNlc05vcnRoVG9Tb3V0aCA9IGVkZ2VJbmRpY2VzLmVhc3RJbmRpY2VzTm9ydGhUb1NvdXRoO1xuICAgIHZhciBub3J0aEluZGljZXNXZXN0VG9FYXN0ID0gZWRnZUluZGljZXMubm9ydGhJbmRpY2VzV2VzdFRvRWFzdDtcblxuICAgIHZhciBpbmRpY2VzID0gSW5kZXhEYXRhdHlwZS5jcmVhdGVUeXBlZEFycmF5KHZlcnRleENvdW50LCBpbmRleENvdW50KTtcbiAgICBhZGRSZWd1bGFyR3JpZEluZGljZXMod2lkdGgsIGhlaWdodCwgaW5kaWNlcywgMCk7XG4gICAgVGVycmFpblByb3ZpZGVyLmFkZFNraXJ0SW5kaWNlcyhcbiAgICAgIHdlc3RJbmRpY2VzU291dGhUb05vcnRoLFxuICAgICAgc291dGhJbmRpY2VzRWFzdFRvV2VzdCxcbiAgICAgIGVhc3RJbmRpY2VzTm9ydGhUb1NvdXRoLFxuICAgICAgbm9ydGhJbmRpY2VzV2VzdFRvRWFzdCxcbiAgICAgIGdyaWRWZXJ0ZXhDb3VudCxcbiAgICAgIGluZGljZXMsXG4gICAgICBncmlkSW5kZXhDb3VudFxuICAgICk7XG5cbiAgICBpbmRpY2VzQW5kRWRnZXMgPSBieVdpZHRoW2hlaWdodF0gPSB7XG4gICAgICBpbmRpY2VzOiBpbmRpY2VzLFxuICAgICAgd2VzdEluZGljZXNTb3V0aFRvTm9ydGg6IHdlc3RJbmRpY2VzU291dGhUb05vcnRoLFxuICAgICAgc291dGhJbmRpY2VzRWFzdFRvV2VzdDogc291dGhJbmRpY2VzRWFzdFRvV2VzdCxcbiAgICAgIGVhc3RJbmRpY2VzTm9ydGhUb1NvdXRoOiBlYXN0SW5kaWNlc05vcnRoVG9Tb3V0aCxcbiAgICAgIG5vcnRoSW5kaWNlc1dlc3RUb0Vhc3Q6IG5vcnRoSW5kaWNlc1dlc3RUb0Vhc3QsXG4gICAgICBpbmRleENvdW50V2l0aG91dFNraXJ0czogZ3JpZEluZGV4Q291bnQsXG4gICAgfTtcbiAgfVxuXG4gIHJldHVybiBpbmRpY2VzQW5kRWRnZXM7XG59O1xuXG4vKipcbiAqIEBwcml2YXRlXG4gKi9cblRlcnJhaW5Qcm92aWRlci5hZGRTa2lydEluZGljZXMgPSBmdW5jdGlvbiAoXG4gIHdlc3RJbmRpY2VzU291dGhUb05vcnRoLFxuICBzb3V0aEluZGljZXNFYXN0VG9XZXN0LFxuICBlYXN0SW5kaWNlc05vcnRoVG9Tb3V0aCxcbiAgbm9ydGhJbmRpY2VzV2VzdFRvRWFzdCxcbiAgdmVydGV4Q291bnQsXG4gIGluZGljZXMsXG4gIG9mZnNldFxuKSB7XG4gIHZhciB2ZXJ0ZXhJbmRleCA9IHZlcnRleENvdW50O1xuICBvZmZzZXQgPSBhZGRTa2lydEluZGljZXMoXG4gICAgd2VzdEluZGljZXNTb3V0aFRvTm9ydGgsXG4gICAgdmVydGV4SW5kZXgsXG4gICAgaW5kaWNlcyxcbiAgICBvZmZzZXRcbiAgKTtcbiAgdmVydGV4SW5kZXggKz0gd2VzdEluZGljZXNTb3V0aFRvTm9ydGgubGVuZ3RoO1xuICBvZmZzZXQgPSBhZGRTa2lydEluZGljZXMoXG4gICAgc291dGhJbmRpY2VzRWFzdFRvV2VzdCxcbiAgICB2ZXJ0ZXhJbmRleCxcbiAgICBpbmRpY2VzLFxuICAgIG9mZnNldFxuICApO1xuICB2ZXJ0ZXhJbmRleCArPSBzb3V0aEluZGljZXNFYXN0VG9XZXN0Lmxlbmd0aDtcbiAgb2Zmc2V0ID0gYWRkU2tpcnRJbmRpY2VzKFxuICAgIGVhc3RJbmRpY2VzTm9ydGhUb1NvdXRoLFxuICAgIHZlcnRleEluZGV4LFxuICAgIGluZGljZXMsXG4gICAgb2Zmc2V0XG4gICk7XG4gIHZlcnRleEluZGV4ICs9IGVhc3RJbmRpY2VzTm9ydGhUb1NvdXRoLmxlbmd0aDtcbiAgYWRkU2tpcnRJbmRpY2VzKG5vcnRoSW5kaWNlc1dlc3RUb0Vhc3QsIHZlcnRleEluZGV4LCBpbmRpY2VzLCBvZmZzZXQpO1xufTtcblxuZnVuY3Rpb24gZ2V0RWRnZUluZGljZXMod2lkdGgsIGhlaWdodCkge1xuICB2YXIgd2VzdEluZGljZXNTb3V0aFRvTm9ydGggPSBuZXcgQXJyYXkoaGVpZ2h0KTtcbiAgdmFyIHNvdXRoSW5kaWNlc0Vhc3RUb1dlc3QgPSBuZXcgQXJyYXkod2lkdGgpO1xuICB2YXIgZWFzdEluZGljZXNOb3J0aFRvU291dGggPSBuZXcgQXJyYXkoaGVpZ2h0KTtcbiAgdmFyIG5vcnRoSW5kaWNlc1dlc3RUb0Vhc3QgPSBuZXcgQXJyYXkod2lkdGgpO1xuXG4gIHZhciBpO1xuICBmb3IgKGkgPSAwOyBpIDwgd2lkdGg7ICsraSkge1xuICAgIG5vcnRoSW5kaWNlc1dlc3RUb0Vhc3RbaV0gPSBpO1xuICAgIHNvdXRoSW5kaWNlc0Vhc3RUb1dlc3RbaV0gPSB3aWR0aCAqIGhlaWdodCAtIDEgLSBpO1xuICB9XG5cbiAgZm9yIChpID0gMDsgaSA8IGhlaWdodDsgKytpKSB7XG4gICAgZWFzdEluZGljZXNOb3J0aFRvU291dGhbaV0gPSAoaSArIDEpICogd2lkdGggLSAxO1xuICAgIHdlc3RJbmRpY2VzU291dGhUb05vcnRoW2ldID0gKGhlaWdodCAtIGkgLSAxKSAqIHdpZHRoO1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICB3ZXN0SW5kaWNlc1NvdXRoVG9Ob3J0aDogd2VzdEluZGljZXNTb3V0aFRvTm9ydGgsXG4gICAgc291dGhJbmRpY2VzRWFzdFRvV2VzdDogc291dGhJbmRpY2VzRWFzdFRvV2VzdCxcbiAgICBlYXN0SW5kaWNlc05vcnRoVG9Tb3V0aDogZWFzdEluZGljZXNOb3J0aFRvU291dGgsXG4gICAgbm9ydGhJbmRpY2VzV2VzdFRvRWFzdDogbm9ydGhJbmRpY2VzV2VzdFRvRWFzdCxcbiAgfTtcbn1cblxuZnVuY3Rpb24gYWRkUmVndWxhckdyaWRJbmRpY2VzKHdpZHRoLCBoZWlnaHQsIGluZGljZXMsIG9mZnNldCkge1xuICB2YXIgaW5kZXggPSAwO1xuICBmb3IgKHZhciBqID0gMDsgaiA8IGhlaWdodCAtIDE7ICsraikge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgd2lkdGggLSAxOyArK2kpIHtcbiAgICAgIHZhciB1cHBlckxlZnQgPSBpbmRleDtcbiAgICAgIHZhciBsb3dlckxlZnQgPSB1cHBlckxlZnQgKyB3aWR0aDtcbiAgICAgIHZhciBsb3dlclJpZ2h0ID0gbG93ZXJMZWZ0ICsgMTtcbiAgICAgIHZhciB1cHBlclJpZ2h0ID0gdXBwZXJMZWZ0ICsgMTtcblxuICAgICAgaW5kaWNlc1tvZmZzZXQrK10gPSB1cHBlckxlZnQ7XG4gICAgICBpbmRpY2VzW29mZnNldCsrXSA9IGxvd2VyTGVmdDtcbiAgICAgIGluZGljZXNbb2Zmc2V0KytdID0gdXBwZXJSaWdodDtcbiAgICAgIGluZGljZXNbb2Zmc2V0KytdID0gdXBwZXJSaWdodDtcbiAgICAgIGluZGljZXNbb2Zmc2V0KytdID0gbG93ZXJMZWZ0O1xuICAgICAgaW5kaWNlc1tvZmZzZXQrK10gPSBsb3dlclJpZ2h0O1xuXG4gICAgICArK2luZGV4O1xuICAgIH1cbiAgICArK2luZGV4O1xuICB9XG59XG5cbmZ1bmN0aW9uIGFkZFNraXJ0SW5kaWNlcyhlZGdlSW5kaWNlcywgdmVydGV4SW5kZXgsIGluZGljZXMsIG9mZnNldCkge1xuICB2YXIgcHJldmlvdXNJbmRleCA9IGVkZ2VJbmRpY2VzWzBdO1xuXG4gIHZhciBsZW5ndGggPSBlZGdlSW5kaWNlcy5sZW5ndGg7XG4gIGZvciAodmFyIGkgPSAxOyBpIDwgbGVuZ3RoOyArK2kpIHtcbiAgICB2YXIgaW5kZXggPSBlZGdlSW5kaWNlc1tpXTtcblxuICAgIGluZGljZXNbb2Zmc2V0KytdID0gcHJldmlvdXNJbmRleDtcbiAgICBpbmRpY2VzW29mZnNldCsrXSA9IGluZGV4O1xuICAgIGluZGljZXNbb2Zmc2V0KytdID0gdmVydGV4SW5kZXg7XG5cbiAgICBpbmRpY2VzW29mZnNldCsrXSA9IHZlcnRleEluZGV4O1xuICAgIGluZGljZXNbb2Zmc2V0KytdID0gaW5kZXg7XG4gICAgaW5kaWNlc1tvZmZzZXQrK10gPSB2ZXJ0ZXhJbmRleCArIDE7XG5cbiAgICBwcmV2aW91c0luZGV4ID0gaW5kZXg7XG4gICAgKyt2ZXJ0ZXhJbmRleDtcbiAgfVxuXG4gIHJldHVybiBvZmZzZXQ7XG59XG5cbi8qKlxuICogU3BlY2lmaWVzIHRoZSBxdWFsaXR5IG9mIHRlcnJhaW4gY3JlYXRlZCBmcm9tIGhlaWdodG1hcHMuICBBIHZhbHVlIG9mIDEuMCB3aWxsXG4gKiBlbnN1cmUgdGhhdCBhZGphY2VudCBoZWlnaHRtYXAgdmVydGljZXMgYXJlIHNlcGFyYXRlZCBieSBubyBtb3JlIHRoYW5cbiAqIHtAbGluayBHbG9iZS5tYXhpbXVtU2NyZWVuU3BhY2VFcnJvcn0gc2NyZWVuIHBpeGVscyBhbmQgd2lsbCBwcm9iYWJseSBnbyB2ZXJ5IHNsb3dseS5cbiAqIEEgdmFsdWUgb2YgMC41IHdpbGwgY3V0IHRoZSBlc3RpbWF0ZWQgbGV2ZWwgemVybyBnZW9tZXRyaWMgZXJyb3IgaW4gaGFsZiwgYWxsb3dpbmcgdHdpY2UgdGhlXG4gKiBzY3JlZW4gcGl4ZWxzIGJldHdlZW4gYWRqYWNlbnQgaGVpZ2h0bWFwIHZlcnRpY2VzIGFuZCB0aHVzIHJlbmRlcmluZyBtb3JlIHF1aWNrbHkuXG4gKiBAdHlwZSB7TnVtYmVyfVxuICovXG5UZXJyYWluUHJvdmlkZXIuaGVpZ2h0bWFwVGVycmFpblF1YWxpdHkgPSAwLjI1O1xuXG4vKipcbiAqIERldGVybWluZXMgYW4gYXBwcm9wcmlhdGUgZ2VvbWV0cmljIGVycm9yIGVzdGltYXRlIHdoZW4gdGhlIGdlb21ldHJ5IGNvbWVzIGZyb20gYSBoZWlnaHRtYXAuXG4gKlxuICogQHBhcmFtIHtFbGxpcHNvaWR9IGVsbGlwc29pZCBUaGUgZWxsaXBzb2lkIHRvIHdoaWNoIHRoZSB0ZXJyYWluIGlzIGF0dGFjaGVkLlxuICogQHBhcmFtIHtOdW1iZXJ9IHRpbGVJbWFnZVdpZHRoIFRoZSB3aWR0aCwgaW4gcGl4ZWxzLCBvZiB0aGUgaGVpZ2h0bWFwIGFzc29jaWF0ZWQgd2l0aCBhIHNpbmdsZSB0aWxlLlxuICogQHBhcmFtIHtOdW1iZXJ9IG51bWJlck9mVGlsZXNBdExldmVsWmVybyBUaGUgbnVtYmVyIG9mIHRpbGVzIGluIHRoZSBob3Jpem9udGFsIGRpcmVjdGlvbiBhdCB0aWxlIGxldmVsIHplcm8uXG4gKiBAcmV0dXJucyB7TnVtYmVyfSBBbiBlc3RpbWF0ZWQgZ2VvbWV0cmljIGVycm9yLlxuICovXG5UZXJyYWluUHJvdmlkZXIuZ2V0RXN0aW1hdGVkTGV2ZWxaZXJvR2VvbWV0cmljRXJyb3JGb3JBSGVpZ2h0bWFwID0gZnVuY3Rpb24gKFxuICBlbGxpcHNvaWQsXG4gIHRpbGVJbWFnZVdpZHRoLFxuICBudW1iZXJPZlRpbGVzQXRMZXZlbFplcm9cbikge1xuICByZXR1cm4gKFxuICAgIChlbGxpcHNvaWQubWF4aW11bVJhZGl1cyAqXG4gICAgICAyICpcbiAgICAgIE1hdGguUEkgKlxuICAgICAgVGVycmFpblByb3ZpZGVyLmhlaWdodG1hcFRlcnJhaW5RdWFsaXR5KSAvXG4gICAgKHRpbGVJbWFnZVdpZHRoICogbnVtYmVyT2ZUaWxlc0F0TGV2ZWxaZXJvKVxuICApO1xufTtcblxuLyoqXG4gKiBSZXF1ZXN0cyB0aGUgZ2VvbWV0cnkgZm9yIGEgZ2l2ZW4gdGlsZS4gIFRoaXMgZnVuY3Rpb24gc2hvdWxkIG5vdCBiZSBjYWxsZWQgYmVmb3JlXG4gKiB7QGxpbmsgVGVycmFpblByb3ZpZGVyI3JlYWR5fSByZXR1cm5zIHRydWUuICBUaGUgcmVzdWx0IG11c3QgaW5jbHVkZSB0ZXJyYWluIGRhdGEgYW5kXG4gKiBtYXkgb3B0aW9uYWxseSBpbmNsdWRlIGEgd2F0ZXIgbWFzayBhbmQgYW4gaW5kaWNhdGlvbiBvZiB3aGljaCBjaGlsZCB0aWxlcyBhcmUgYXZhaWxhYmxlLlxuICogQGZ1bmN0aW9uXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IHggVGhlIFggY29vcmRpbmF0ZSBvZiB0aGUgdGlsZSBmb3Igd2hpY2ggdG8gcmVxdWVzdCBnZW9tZXRyeS5cbiAqIEBwYXJhbSB7TnVtYmVyfSB5IFRoZSBZIGNvb3JkaW5hdGUgb2YgdGhlIHRpbGUgZm9yIHdoaWNoIHRvIHJlcXVlc3QgZ2VvbWV0cnkuXG4gKiBAcGFyYW0ge051bWJlcn0gbGV2ZWwgVGhlIGxldmVsIG9mIHRoZSB0aWxlIGZvciB3aGljaCB0byByZXF1ZXN0IGdlb21ldHJ5LlxuICogQHBhcmFtIHtSZXF1ZXN0fSBbcmVxdWVzdF0gVGhlIHJlcXVlc3Qgb2JqZWN0LiBJbnRlbmRlZCBmb3IgaW50ZXJuYWwgdXNlIG9ubHkuXG4gKlxuICogQHJldHVybnMge1Byb21pc2UuPFRlcnJhaW5EYXRhPnx1bmRlZmluZWR9IEEgcHJvbWlzZSBmb3IgdGhlIHJlcXVlc3RlZCBnZW9tZXRyeS4gIElmIHRoaXMgbWV0aG9kXG4gKiAgICAgICAgICByZXR1cm5zIHVuZGVmaW5lZCBpbnN0ZWFkIG9mIGEgcHJvbWlzZSwgaXQgaXMgYW4gaW5kaWNhdGlvbiB0aGF0IHRvbyBtYW55IHJlcXVlc3RzIGFyZSBhbHJlYWR5XG4gKiAgICAgICAgICBwZW5kaW5nIGFuZCB0aGUgcmVxdWVzdCB3aWxsIGJlIHJldHJpZWQgbGF0ZXIuXG4gKi9cblRlcnJhaW5Qcm92aWRlci5wcm90b3R5cGUucmVxdWVzdFRpbGVHZW9tZXRyeSA9XG4gIERldmVsb3BlckVycm9yLnRocm93SW5zdGFudGlhdGlvbkVycm9yO1xuXG4vKipcbiAqIEdldHMgdGhlIG1heGltdW0gZ2VvbWV0cmljIGVycm9yIGFsbG93ZWQgaW4gYSB0aWxlIGF0IGEgZ2l2ZW4gbGV2ZWwuICBUaGlzIGZ1bmN0aW9uIHNob3VsZCBub3QgYmVcbiAqIGNhbGxlZCBiZWZvcmUge0BsaW5rIFRlcnJhaW5Qcm92aWRlciNyZWFkeX0gcmV0dXJucyB0cnVlLlxuICogQGZ1bmN0aW9uXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IGxldmVsIFRoZSB0aWxlIGxldmVsIGZvciB3aGljaCB0byBnZXQgdGhlIG1heGltdW0gZ2VvbWV0cmljIGVycm9yLlxuICogQHJldHVybnMge051bWJlcn0gVGhlIG1heGltdW0gZ2VvbWV0cmljIGVycm9yLlxuICovXG5UZXJyYWluUHJvdmlkZXIucHJvdG90eXBlLmdldExldmVsTWF4aW11bUdlb21ldHJpY0Vycm9yID1cbiAgRGV2ZWxvcGVyRXJyb3IudGhyb3dJbnN0YW50aWF0aW9uRXJyb3I7XG5cbi8qKlxuICogRGV0ZXJtaW5lcyB3aGV0aGVyIGRhdGEgZm9yIGEgdGlsZSBpcyBhdmFpbGFibGUgdG8gYmUgbG9hZGVkLlxuICogQGZ1bmN0aW9uXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IHggVGhlIFggY29vcmRpbmF0ZSBvZiB0aGUgdGlsZSBmb3Igd2hpY2ggdG8gcmVxdWVzdCBnZW9tZXRyeS5cbiAqIEBwYXJhbSB7TnVtYmVyfSB5IFRoZSBZIGNvb3JkaW5hdGUgb2YgdGhlIHRpbGUgZm9yIHdoaWNoIHRvIHJlcXVlc3QgZ2VvbWV0cnkuXG4gKiBAcGFyYW0ge051bWJlcn0gbGV2ZWwgVGhlIGxldmVsIG9mIHRoZSB0aWxlIGZvciB3aGljaCB0byByZXF1ZXN0IGdlb21ldHJ5LlxuICogQHJldHVybnMge0Jvb2xlYW58dW5kZWZpbmVkfSBVbmRlZmluZWQgaWYgbm90IHN1cHBvcnRlZCBieSB0aGUgdGVycmFpbiBwcm92aWRlciwgb3RoZXJ3aXNlIHRydWUgb3IgZmFsc2UuXG4gKi9cblRlcnJhaW5Qcm92aWRlci5wcm90b3R5cGUuZ2V0VGlsZURhdGFBdmFpbGFibGUgPVxuICBEZXZlbG9wZXJFcnJvci50aHJvd0luc3RhbnRpYXRpb25FcnJvcjtcblxuLyoqXG4gKiBNYWtlcyBzdXJlIHdlIGxvYWQgYXZhaWxhYmlsaXR5IGRhdGEgZm9yIGEgdGlsZVxuICogQGZ1bmN0aW9uXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IHggVGhlIFggY29vcmRpbmF0ZSBvZiB0aGUgdGlsZSBmb3Igd2hpY2ggdG8gcmVxdWVzdCBnZW9tZXRyeS5cbiAqIEBwYXJhbSB7TnVtYmVyfSB5IFRoZSBZIGNvb3JkaW5hdGUgb2YgdGhlIHRpbGUgZm9yIHdoaWNoIHRvIHJlcXVlc3QgZ2VvbWV0cnkuXG4gKiBAcGFyYW0ge051bWJlcn0gbGV2ZWwgVGhlIGxldmVsIG9mIHRoZSB0aWxlIGZvciB3aGljaCB0byByZXF1ZXN0IGdlb21ldHJ5LlxuICogQHJldHVybnMge3VuZGVmaW5lZHxQcm9taXNlPHZvaWQ+fSBVbmRlZmluZWQgaWYgbm90aGluZyBuZWVkIHRvIGJlIGxvYWRlZCBvciBhIFByb21pc2UgdGhhdCByZXNvbHZlcyB3aGVuIGFsbCByZXF1aXJlZCB0aWxlcyBhcmUgbG9hZGVkXG4gKi9cblRlcnJhaW5Qcm92aWRlci5wcm90b3R5cGUubG9hZFRpbGVEYXRhQXZhaWxhYmlsaXR5ID1cbiAgRGV2ZWxvcGVyRXJyb3IudGhyb3dJbnN0YW50aWF0aW9uRXJyb3I7XG5leHBvcnQgZGVmYXVsdCBUZXJyYWluUHJvdmlkZXI7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///1497\n')},735:function(__unused_webpack___webpack_module__,__webpack_exports__){eval('/**\n * This enumerated type is used to determine how the vertices of the terrain mesh are compressed.\n *\n * @enum {Number}\n *\n * @private\n */\nvar TerrainQuantization = {\n  /**\n   * The vertices are not compressed.\n   *\n   * @type {Number}\n   * @constant\n   */\n  NONE: 0,\n\n  /**\n   * The vertices are compressed to 12 bits.\n   *\n   * @type {Number}\n   * @constant\n   */\n  BITS12: 1,\n};\n/* harmony default export */ __webpack_exports__["Z"] = (Object.freeze(TerrainQuantization));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNzM1LmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseURBQWUsa0NBQWtDLEVBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly92dWUzLXdlYnBhY2s1Ly4vbm9kZV9tb2R1bGVzL2Nlc2l1bS9Tb3VyY2UvQ29yZS9UZXJyYWluUXVhbnRpemF0aW9uLmpzP2Q1M2UiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBUaGlzIGVudW1lcmF0ZWQgdHlwZSBpcyB1c2VkIHRvIGRldGVybWluZSBob3cgdGhlIHZlcnRpY2VzIG9mIHRoZSB0ZXJyYWluIG1lc2ggYXJlIGNvbXByZXNzZWQuXG4gKlxuICogQGVudW0ge051bWJlcn1cbiAqXG4gKiBAcHJpdmF0ZVxuICovXG52YXIgVGVycmFpblF1YW50aXphdGlvbiA9IHtcbiAgLyoqXG4gICAqIFRoZSB2ZXJ0aWNlcyBhcmUgbm90IGNvbXByZXNzZWQuXG4gICAqXG4gICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAqIEBjb25zdGFudFxuICAgKi9cbiAgTk9ORTogMCxcblxuICAvKipcbiAgICogVGhlIHZlcnRpY2VzIGFyZSBjb21wcmVzc2VkIHRvIDEyIGJpdHMuXG4gICAqXG4gICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAqIEBjb25zdGFudFxuICAgKi9cbiAgQklUUzEyOiAxLFxufTtcbmV4cG9ydCBkZWZhdWx0IE9iamVjdC5mcmVlemUoVGVycmFpblF1YW50aXphdGlvbik7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///735\n')},25707:function(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__){eval('/* harmony import */ var _binarySearch_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(377);\n/* harmony import */ var _Cartographic_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(51688);\n/* harmony import */ var _defined_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(82982);\n/* harmony import */ var _Rectangle_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(96190);\n\n\n\n\n\n/**\n * Reports the availability of tiles in a {@link TilingScheme}.\n *\n * @alias TileAvailability\n * @constructor\n *\n * @param {TilingScheme} tilingScheme The tiling scheme in which to report availability.\n * @param {Number} maximumLevel The maximum tile level that is potentially available.\n */\nfunction TileAvailability(tilingScheme, maximumLevel) {\n  this._tilingScheme = tilingScheme;\n  this._maximumLevel = maximumLevel;\n\n  this._rootNodes = [];\n}\n\nvar rectangleScratch = new _Rectangle_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"] */ .Z();\n\nfunction findNode(level, x, y, nodes) {\n  var count = nodes.length;\n  for (var i = 0; i < count; ++i) {\n    var node = nodes[i];\n    if (node.x === x && node.y === y && node.level === level) {\n      return true;\n    }\n  }\n\n  return false;\n}\n\n/**\n * Marks a rectangular range of tiles in a particular level as being available.  For best performance,\n * add your ranges in order of increasing level.\n *\n * @param {Number} level The level.\n * @param {Number} startX The X coordinate of the first available tiles at the level.\n * @param {Number} startY The Y coordinate of the first available tiles at the level.\n * @param {Number} endX The X coordinate of the last available tiles at the level.\n * @param {Number} endY The Y coordinate of the last available tiles at the level.\n */\nTileAvailability.prototype.addAvailableTileRange = function (\n  level,\n  startX,\n  startY,\n  endX,\n  endY\n) {\n  var tilingScheme = this._tilingScheme;\n\n  var rootNodes = this._rootNodes;\n  if (level === 0) {\n    for (var y = startY; y <= endY; ++y) {\n      for (var x = startX; x <= endX; ++x) {\n        if (!findNode(level, x, y, rootNodes)) {\n          rootNodes.push(new QuadtreeNode(tilingScheme, undefined, 0, x, y));\n        }\n      }\n    }\n  }\n\n  tilingScheme.tileXYToRectangle(startX, startY, level, rectangleScratch);\n  var west = rectangleScratch.west;\n  var north = rectangleScratch.north;\n\n  tilingScheme.tileXYToRectangle(endX, endY, level, rectangleScratch);\n  var east = rectangleScratch.east;\n  var south = rectangleScratch.south;\n\n  var rectangleWithLevel = new RectangleWithLevel(\n    level,\n    west,\n    south,\n    east,\n    north\n  );\n\n  for (var i = 0; i < rootNodes.length; ++i) {\n    var rootNode = rootNodes[i];\n    if (rectanglesOverlap(rootNode.extent, rectangleWithLevel)) {\n      putRectangleInQuadtree(this._maximumLevel, rootNode, rectangleWithLevel);\n    }\n  }\n};\n\n/**\n * Determines the level of the most detailed tile covering the position.  This function\n * usually completes in time logarithmic to the number of rectangles added with\n * {@link TileAvailability#addAvailableTileRange}.\n *\n * @param {Cartographic} position The position for which to determine the maximum available level.  The height component is ignored.\n * @return {Number} The level of the most detailed tile covering the position.\n * @throws {DeveloperError} If position is outside any tile according to the tiling scheme.\n */\nTileAvailability.prototype.computeMaximumLevelAtPosition = function (position) {\n  // Find the root node that contains this position.\n  var node;\n  for (var nodeIndex = 0; nodeIndex < this._rootNodes.length; ++nodeIndex) {\n    var rootNode = this._rootNodes[nodeIndex];\n    if (rectangleContainsPosition(rootNode.extent, position)) {\n      node = rootNode;\n      break;\n    }\n  }\n\n  if (!(0,_defined_js__WEBPACK_IMPORTED_MODULE_3__/* ["default"] */ .Z)(node)) {\n    return -1;\n  }\n\n  return findMaxLevelFromNode(undefined, node, position);\n};\n\nvar rectanglesScratch = [];\nvar remainingToCoverByLevelScratch = [];\nvar westScratch = new _Rectangle_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"] */ .Z();\nvar eastScratch = new _Rectangle_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"] */ .Z();\n\n/**\n * Finds the most detailed level that is available _everywhere_ within a given rectangle.  More detailed\n * tiles may be available in parts of the rectangle, but not the whole thing.  The return value of this\n * function may be safely passed to {@link sampleTerrain} for any position within the rectangle.  This function\n * usually completes in time logarithmic to the number of rectangles added with\n * {@link TileAvailability#addAvailableTileRange}.\n *\n * @param {Rectangle} rectangle The rectangle.\n * @return {Number} The best available level for the entire rectangle.\n */\nTileAvailability.prototype.computeBestAvailableLevelOverRectangle = function (\n  rectangle\n) {\n  var rectangles = rectanglesScratch;\n  rectangles.length = 0;\n\n  if (rectangle.east < rectangle.west) {\n    // Rectangle crosses the IDL, make it two rectangles.\n    rectangles.push(\n      _Rectangle_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"].fromRadians */ .Z.fromRadians(\n        -Math.PI,\n        rectangle.south,\n        rectangle.east,\n        rectangle.north,\n        westScratch\n      )\n    );\n    rectangles.push(\n      _Rectangle_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"].fromRadians */ .Z.fromRadians(\n        rectangle.west,\n        rectangle.south,\n        Math.PI,\n        rectangle.north,\n        eastScratch\n      )\n    );\n  } else {\n    rectangles.push(rectangle);\n  }\n\n  var remainingToCoverByLevel = remainingToCoverByLevelScratch;\n  remainingToCoverByLevel.length = 0;\n\n  var i;\n  for (i = 0; i < this._rootNodes.length; ++i) {\n    updateCoverageWithNode(\n      remainingToCoverByLevel,\n      this._rootNodes[i],\n      rectangles\n    );\n  }\n\n  for (i = remainingToCoverByLevel.length - 1; i >= 0; --i) {\n    if (\n      (0,_defined_js__WEBPACK_IMPORTED_MODULE_3__/* ["default"] */ .Z)(remainingToCoverByLevel[i]) &&\n      remainingToCoverByLevel[i].length === 0\n    ) {\n      return i;\n    }\n  }\n\n  return 0;\n};\n\nvar cartographicScratch = new _Cartographic_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .Z();\n\n/**\n * Determines if a particular tile is available.\n * @param {Number} level The tile level to check.\n * @param {Number} x The X coordinate of the tile to check.\n * @param {Number} y The Y coordinate of the tile to check.\n * @return {Boolean} True if the tile is available; otherwise, false.\n */\nTileAvailability.prototype.isTileAvailable = function (level, x, y) {\n  // Get the center of the tile and find the maximum level at that position.\n  // Because availability is by tile, if the level is available at that point, it\n  // is sure to be available for the whole tile.  We assume that if a tile at level n exists,\n  // then all its parent tiles back to level 0 exist too.  This isn\'t really enforced\n  // anywhere, but Cesium would never load a tile for which this is not true.\n  var rectangle = this._tilingScheme.tileXYToRectangle(\n    x,\n    y,\n    level,\n    rectangleScratch\n  );\n  _Rectangle_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"].center */ .Z.center(rectangle, cartographicScratch);\n  return this.computeMaximumLevelAtPosition(cartographicScratch) >= level;\n};\n\n/**\n * Computes a bit mask indicating which of a tile\'s four children exist.\n * If a child\'s bit is set, a tile is available for that child.  If it is cleared,\n * the tile is not available.  The bit values are as follows:\n * <table>\n *     <tr><th>Bit Position</th><th>Bit Value</th><th>Child Tile</th></tr>\n *     <tr><td>0</td><td>1</td><td>Southwest</td></tr>\n *     <tr><td>1</td><td>2</td><td>Southeast</td></tr>\n *     <tr><td>2</td><td>4</td><td>Northwest</td></tr>\n *     <tr><td>3</td><td>8</td><td>Northeast</td></tr>\n * </table>\n *\n * @param {Number} level The level of the parent tile.\n * @param {Number} x The X coordinate of the parent tile.\n * @param {Number} y The Y coordinate of the parent tile.\n * @return {Number} The bit mask indicating child availability.\n */\nTileAvailability.prototype.computeChildMaskForTile = function (level, x, y) {\n  var childLevel = level + 1;\n  if (childLevel >= this._maximumLevel) {\n    return 0;\n  }\n\n  var mask = 0;\n\n  mask |= this.isTileAvailable(childLevel, 2 * x, 2 * y + 1) ? 1 : 0;\n  mask |= this.isTileAvailable(childLevel, 2 * x + 1, 2 * y + 1) ? 2 : 0;\n  mask |= this.isTileAvailable(childLevel, 2 * x, 2 * y) ? 4 : 0;\n  mask |= this.isTileAvailable(childLevel, 2 * x + 1, 2 * y) ? 8 : 0;\n\n  return mask;\n};\n\nfunction QuadtreeNode(tilingScheme, parent, level, x, y) {\n  this.tilingScheme = tilingScheme;\n  this.parent = parent;\n  this.level = level;\n  this.x = x;\n  this.y = y;\n  this.extent = tilingScheme.tileXYToRectangle(x, y, level);\n\n  this.rectangles = [];\n  this._sw = undefined;\n  this._se = undefined;\n  this._nw = undefined;\n  this._ne = undefined;\n}\n\nObject.defineProperties(QuadtreeNode.prototype, {\n  nw: {\n    get: function () {\n      if (!this._nw) {\n        this._nw = new QuadtreeNode(\n          this.tilingScheme,\n          this,\n          this.level + 1,\n          this.x * 2,\n          this.y * 2\n        );\n      }\n      return this._nw;\n    },\n  },\n\n  ne: {\n    get: function () {\n      if (!this._ne) {\n        this._ne = new QuadtreeNode(\n          this.tilingScheme,\n          this,\n          this.level + 1,\n          this.x * 2 + 1,\n          this.y * 2\n        );\n      }\n      return this._ne;\n    },\n  },\n\n  sw: {\n    get: function () {\n      if (!this._sw) {\n        this._sw = new QuadtreeNode(\n          this.tilingScheme,\n          this,\n          this.level + 1,\n          this.x * 2,\n          this.y * 2 + 1\n        );\n      }\n      return this._sw;\n    },\n  },\n\n  se: {\n    get: function () {\n      if (!this._se) {\n        this._se = new QuadtreeNode(\n          this.tilingScheme,\n          this,\n          this.level + 1,\n          this.x * 2 + 1,\n          this.y * 2 + 1\n        );\n      }\n      return this._se;\n    },\n  },\n});\n\nfunction RectangleWithLevel(level, west, south, east, north) {\n  this.level = level;\n  this.west = west;\n  this.south = south;\n  this.east = east;\n  this.north = north;\n}\n\nfunction rectanglesOverlap(rectangle1, rectangle2) {\n  var west = Math.max(rectangle1.west, rectangle2.west);\n  var south = Math.max(rectangle1.south, rectangle2.south);\n  var east = Math.min(rectangle1.east, rectangle2.east);\n  var north = Math.min(rectangle1.north, rectangle2.north);\n  return south < north && west < east;\n}\n\nfunction putRectangleInQuadtree(maxDepth, node, rectangle) {\n  while (node.level < maxDepth) {\n    if (rectangleFullyContainsRectangle(node.nw.extent, rectangle)) {\n      node = node.nw;\n    } else if (rectangleFullyContainsRectangle(node.ne.extent, rectangle)) {\n      node = node.ne;\n    } else if (rectangleFullyContainsRectangle(node.sw.extent, rectangle)) {\n      node = node.sw;\n    } else if (rectangleFullyContainsRectangle(node.se.extent, rectangle)) {\n      node = node.se;\n    } else {\n      break;\n    }\n  }\n\n  if (\n    node.rectangles.length === 0 ||\n    node.rectangles[node.rectangles.length - 1].level <= rectangle.level\n  ) {\n    node.rectangles.push(rectangle);\n  } else {\n    // Maintain ordering by level when inserting.\n    var index = (0,_binarySearch_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .Z)(\n      node.rectangles,\n      rectangle.level,\n      rectangleLevelComparator\n    );\n    if (index < 0) {\n      index = ~index;\n    }\n    node.rectangles.splice(index, 0, rectangle);\n  }\n}\n\nfunction rectangleLevelComparator(a, b) {\n  return a.level - b;\n}\n\nfunction rectangleFullyContainsRectangle(potentialContainer, rectangleToTest) {\n  return (\n    rectangleToTest.west >= potentialContainer.west &&\n    rectangleToTest.east <= potentialContainer.east &&\n    rectangleToTest.south >= potentialContainer.south &&\n    rectangleToTest.north <= potentialContainer.north\n  );\n}\n\nfunction rectangleContainsPosition(potentialContainer, positionToTest) {\n  return (\n    positionToTest.longitude >= potentialContainer.west &&\n    positionToTest.longitude <= potentialContainer.east &&\n    positionToTest.latitude >= potentialContainer.south &&\n    positionToTest.latitude <= potentialContainer.north\n  );\n}\n\nfunction findMaxLevelFromNode(stopNode, node, position) {\n  var maxLevel = 0;\n\n  // Find the deepest quadtree node containing this point.\n  var found = false;\n  while (!found) {\n    var nw = node._nw && rectangleContainsPosition(node._nw.extent, position);\n    var ne = node._ne && rectangleContainsPosition(node._ne.extent, position);\n    var sw = node._sw && rectangleContainsPosition(node._sw.extent, position);\n    var se = node._se && rectangleContainsPosition(node._se.extent, position);\n\n    // The common scenario is that the point is in only one quadrant and we can simply\n    // iterate down the tree.  But if the point is on a boundary between tiles, it is\n    // in multiple tiles and we need to check all of them, so use recursion.\n    if (nw + ne + sw + se > 1) {\n      if (nw) {\n        maxLevel = Math.max(\n          maxLevel,\n          findMaxLevelFromNode(node, node._nw, position)\n        );\n      }\n      if (ne) {\n        maxLevel = Math.max(\n          maxLevel,\n          findMaxLevelFromNode(node, node._ne, position)\n        );\n      }\n      if (sw) {\n        maxLevel = Math.max(\n          maxLevel,\n          findMaxLevelFromNode(node, node._sw, position)\n        );\n      }\n      if (se) {\n        maxLevel = Math.max(\n          maxLevel,\n          findMaxLevelFromNode(node, node._se, position)\n        );\n      }\n      break;\n    } else if (nw) {\n      node = node._nw;\n    } else if (ne) {\n      node = node._ne;\n    } else if (sw) {\n      node = node._sw;\n    } else if (se) {\n      node = node._se;\n    } else {\n      found = true;\n    }\n  }\n\n  // Work up the tree until we find a rectangle that contains this point.\n  while (node !== stopNode) {\n    var rectangles = node.rectangles;\n\n    // Rectangles are sorted by level, lowest first.\n    for (\n      var i = rectangles.length - 1;\n      i >= 0 && rectangles[i].level > maxLevel;\n      --i\n    ) {\n      var rectangle = rectangles[i];\n      if (rectangleContainsPosition(rectangle, position)) {\n        maxLevel = rectangle.level;\n      }\n    }\n\n    node = node.parent;\n  }\n\n  return maxLevel;\n}\n\nfunction updateCoverageWithNode(\n  remainingToCoverByLevel,\n  node,\n  rectanglesToCover\n) {\n  if (!node) {\n    return;\n  }\n\n  var i;\n  var anyOverlap = false;\n  for (i = 0; i < rectanglesToCover.length; ++i) {\n    anyOverlap =\n      anyOverlap || rectanglesOverlap(node.extent, rectanglesToCover[i]);\n  }\n\n  if (!anyOverlap) {\n    // This node is not applicable to the rectangle(s).\n    return;\n  }\n\n  var rectangles = node.rectangles;\n  for (i = 0; i < rectangles.length; ++i) {\n    var rectangle = rectangles[i];\n\n    if (!remainingToCoverByLevel[rectangle.level]) {\n      remainingToCoverByLevel[rectangle.level] = rectanglesToCover;\n    }\n\n    remainingToCoverByLevel[rectangle.level] = subtractRectangle(\n      remainingToCoverByLevel[rectangle.level],\n      rectangle\n    );\n  }\n\n  // Update with child nodes.\n  updateCoverageWithNode(remainingToCoverByLevel, node._nw, rectanglesToCover);\n  updateCoverageWithNode(remainingToCoverByLevel, node._ne, rectanglesToCover);\n  updateCoverageWithNode(remainingToCoverByLevel, node._sw, rectanglesToCover);\n  updateCoverageWithNode(remainingToCoverByLevel, node._se, rectanglesToCover);\n}\n\nfunction subtractRectangle(rectangleList, rectangleToSubtract) {\n  var result = [];\n  for (var i = 0; i < rectangleList.length; ++i) {\n    var rectangle = rectangleList[i];\n    if (!rectanglesOverlap(rectangle, rectangleToSubtract)) {\n      // Disjoint rectangles.  Original rectangle is unmodified.\n      result.push(rectangle);\n    } else {\n      // rectangleToSubtract partially or completely overlaps rectangle.\n      if (rectangle.west < rectangleToSubtract.west) {\n        result.push(\n          new _Rectangle_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"] */ .Z(\n            rectangle.west,\n            rectangle.south,\n            rectangleToSubtract.west,\n            rectangle.north\n          )\n        );\n      }\n      if (rectangle.east > rectangleToSubtract.east) {\n        result.push(\n          new _Rectangle_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"] */ .Z(\n            rectangleToSubtract.east,\n            rectangle.south,\n            rectangle.east,\n            rectangle.north\n          )\n        );\n      }\n      if (rectangle.south < rectangleToSubtract.south) {\n        result.push(\n          new _Rectangle_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"] */ .Z(\n            Math.max(rectangleToSubtract.west, rectangle.west),\n            rectangle.south,\n            Math.min(rectangleToSubtract.east, rectangle.east),\n            rectangleToSubtract.south\n          )\n        );\n      }\n      if (rectangle.north > rectangleToSubtract.north) {\n        result.push(\n          new _Rectangle_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"] */ .Z(\n            Math.max(rectangleToSubtract.west, rectangle.west),\n            rectangleToSubtract.north,\n            Math.min(rectangleToSubtract.east, rectangle.east),\n            rectangle.north\n          )\n        );\n      }\n    }\n  }\n\n  return result;\n}\n/* harmony default export */ __webpack_exports__["Z"] = (TileAvailability);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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LEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSCxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsZ0JBQWdCLHFFQUFZO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsY0FBYyw4QkFBOEI7QUFDNUM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsY0FBYyx1QkFBdUI7QUFDckM7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxrQkFBa0IsMEJBQTBCO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLGNBQWMsOERBQVM7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyw4REFBUztBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLDhEQUFTO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsOERBQVM7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx5REFBZSxnQkFBZ0IsRUFBQyIsInNvdXJjZXMiOlsid2VicGFjazovL3Z1ZTMtd2VicGFjazUvLi9ub2RlX21vZHVsZXMvY2VzaXVtL1NvdXJjZS9Db3JlL1RpbGVBdmFpbGFiaWxpdHkuanM/NGQ4ZiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgYmluYXJ5U2VhcmNoIGZyb20gXCIuL2JpbmFyeVNlYXJjaC5qc1wiO1xuaW1wb3J0IENhcnRvZ3JhcGhpYyBmcm9tIFwiLi9DYXJ0b2dyYXBoaWMuanNcIjtcbmltcG9ydCBkZWZpbmVkIGZyb20gXCIuL2RlZmluZWQuanNcIjtcbmltcG9ydCBSZWN0YW5nbGUgZnJvbSBcIi4vUmVjdGFuZ2xlLmpzXCI7XG5cbi8qKlxuICogUmVwb3J0cyB0aGUgYXZhaWxhYmlsaXR5IG9mIHRpbGVzIGluIGEge0BsaW5rIFRpbGluZ1NjaGVtZX0uXG4gKlxuICogQGFsaWFzIFRpbGVBdmFpbGFiaWxpdHlcbiAqIEBjb25zdHJ1Y3RvclxuICpcbiAqIEBwYXJhbSB7VGlsaW5nU2NoZW1lfSB0aWxpbmdTY2hlbWUgVGhlIHRpbGluZyBzY2hlbWUgaW4gd2hpY2ggdG8gcmVwb3J0IGF2YWlsYWJpbGl0eS5cbiAqIEBwYXJhbSB7TnVtYmVyfSBtYXhpbXVtTGV2ZWwgVGhlIG1heGltdW0gdGlsZSBsZXZlbCB0aGF0IGlzIHBvdGVudGlhbGx5IGF2YWlsYWJsZS5cbiAqL1xuZnVuY3Rpb24gVGlsZUF2YWlsYWJpbGl0eSh0aWxpbmdTY2hlbWUsIG1heGltdW1MZXZlbCkge1xuICB0aGlzLl90aWxpbmdTY2hlbWUgPSB0aWxpbmdTY2hlbWU7XG4gIHRoaXMuX21heGltdW1MZXZlbCA9IG1heGltdW1MZXZlbDtcblxuICB0aGlzLl9yb290Tm9kZXMgPSBbXTtcbn1cblxudmFyIHJlY3RhbmdsZVNjcmF0Y2ggPSBuZXcgUmVjdGFuZ2xlKCk7XG5cbmZ1bmN0aW9uIGZpbmROb2RlKGxldmVsLCB4LCB5LCBub2Rlcykge1xuICB2YXIgY291bnQgPSBub2Rlcy5sZW5ndGg7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgY291bnQ7ICsraSkge1xuICAgIHZhciBub2RlID0gbm9kZXNbaV07XG4gICAgaWYgKG5vZGUueCA9PT0geCAmJiBub2RlLnkgPT09IHkgJiYgbm9kZS5sZXZlbCA9PT0gbGV2ZWwpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuLyoqXG4gKiBNYXJrcyBhIHJlY3Rhbmd1bGFyIHJhbmdlIG9mIHRpbGVzIGluIGEgcGFydGljdWxhciBsZXZlbCBhcyBiZWluZyBhdmFpbGFibGUuICBGb3IgYmVzdCBwZXJmb3JtYW5jZSxcbiAqIGFkZCB5b3VyIHJhbmdlcyBpbiBvcmRlciBvZiBpbmNyZWFzaW5nIGxldmVsLlxuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSBsZXZlbCBUaGUgbGV2ZWwuXG4gKiBAcGFyYW0ge051bWJlcn0gc3RhcnRYIFRoZSBYIGNvb3JkaW5hdGUgb2YgdGhlIGZpcnN0IGF2YWlsYWJsZSB0aWxlcyBhdCB0aGUgbGV2ZWwuXG4gKiBAcGFyYW0ge051bWJlcn0gc3RhcnRZIFRoZSBZIGNvb3JkaW5hdGUgb2YgdGhlIGZpcnN0IGF2YWlsYWJsZSB0aWxlcyBhdCB0aGUgbGV2ZWwuXG4gKiBAcGFyYW0ge051bWJlcn0gZW5kWCBUaGUgWCBjb29yZGluYXRlIG9mIHRoZSBsYXN0IGF2YWlsYWJsZSB0aWxlcyBhdCB0aGUgbGV2ZWwuXG4gKiBAcGFyYW0ge051bWJlcn0gZW5kWSBUaGUgWSBjb29yZGluYXRlIG9mIHRoZSBsYXN0IGF2YWlsYWJsZSB0aWxlcyBhdCB0aGUgbGV2ZWwuXG4gKi9cblRpbGVBdmFpbGFiaWxpdHkucHJvdG90eXBlLmFkZEF2YWlsYWJsZVRpbGVSYW5nZSA9IGZ1bmN0aW9uIChcbiAgbGV2ZWwsXG4gIHN0YXJ0WCxcbiAgc3RhcnRZLFxuICBlbmRYLFxuICBlbmRZXG4pIHtcbiAgdmFyIHRpbGluZ1NjaGVtZSA9IHRoaXMuX3RpbGluZ1NjaGVtZTtcblxuICB2YXIgcm9vdE5vZGVzID0gdGhpcy5fcm9vdE5vZGVzO1xuICBpZiAobGV2ZWwgPT09IDApIHtcbiAgICBmb3IgKHZhciB5ID0gc3RhcnRZOyB5IDw9IGVuZFk7ICsreSkge1xuICAgICAgZm9yICh2YXIgeCA9IHN0YXJ0WDsgeCA8PSBlbmRYOyArK3gpIHtcbiAgICAgICAgaWYgKCFmaW5kTm9kZShsZXZlbCwgeCwgeSwgcm9vdE5vZGVzKSkge1xuICAgICAgICAgIHJvb3ROb2Rlcy5wdXNoKG5ldyBRdWFkdHJlZU5vZGUodGlsaW5nU2NoZW1lLCB1bmRlZmluZWQsIDAsIHgsIHkpKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHRpbGluZ1NjaGVtZS50aWxlWFlUb1JlY3RhbmdsZShzdGFydFgsIHN0YXJ0WSwgbGV2ZWwsIHJlY3RhbmdsZVNjcmF0Y2gpO1xuICB2YXIgd2VzdCA9IHJlY3RhbmdsZVNjcmF0Y2gud2VzdDtcbiAgdmFyIG5vcnRoID0gcmVjdGFuZ2xlU2NyYXRjaC5ub3J0aDtcblxuICB0aWxpbmdTY2hlbWUudGlsZVhZVG9SZWN0YW5nbGUoZW5kWCwgZW5kWSwgbGV2ZWwsIHJlY3RhbmdsZVNjcmF0Y2gpO1xuICB2YXIgZWFzdCA9IHJlY3RhbmdsZVNjcmF0Y2guZWFzdDtcbiAgdmFyIHNvdXRoID0gcmVjdGFuZ2xlU2NyYXRjaC5zb3V0aDtcblxuICB2YXIgcmVjdGFuZ2xlV2l0aExldmVsID0gbmV3IFJlY3RhbmdsZVdpdGhMZXZlbChcbiAgICBsZXZlbCxcbiAgICB3ZXN0LFxuICAgIHNvdXRoLFxuICAgIGVhc3QsXG4gICAgbm9ydGhcbiAgKTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IHJvb3ROb2Rlcy5sZW5ndGg7ICsraSkge1xuICAgIHZhciByb290Tm9kZSA9IHJvb3ROb2Rlc1tpXTtcbiAgICBpZiAocmVjdGFuZ2xlc092ZXJsYXAocm9vdE5vZGUuZXh0ZW50LCByZWN0YW5nbGVXaXRoTGV2ZWwpKSB7XG4gICAgICBwdXRSZWN0YW5nbGVJblF1YWR0cmVlKHRoaXMuX21heGltdW1MZXZlbCwgcm9vdE5vZGUsIHJlY3RhbmdsZVdpdGhMZXZlbCk7XG4gICAgfVxuICB9XG59O1xuXG4vKipcbiAqIERldGVybWluZXMgdGhlIGxldmVsIG9mIHRoZSBtb3N0IGRldGFpbGVkIHRpbGUgY292ZXJpbmcgdGhlIHBvc2l0aW9uLiAgVGhpcyBmdW5jdGlvblxuICogdXN1YWxseSBjb21wbGV0ZXMgaW4gdGltZSBsb2dhcml0aG1pYyB0byB0aGUgbnVtYmVyIG9mIHJlY3RhbmdsZXMgYWRkZWQgd2l0aFxuICoge0BsaW5rIFRpbGVBdmFpbGFiaWxpdHkjYWRkQXZhaWxhYmxlVGlsZVJhbmdlfS5cbiAqXG4gKiBAcGFyYW0ge0NhcnRvZ3JhcGhpY30gcG9zaXRpb24gVGhlIHBvc2l0aW9uIGZvciB3aGljaCB0byBkZXRlcm1pbmUgdGhlIG1heGltdW0gYXZhaWxhYmxlIGxldmVsLiAgVGhlIGhlaWdodCBjb21wb25lbnQgaXMgaWdub3JlZC5cbiAqIEByZXR1cm4ge051bWJlcn0gVGhlIGxldmVsIG9mIHRoZSBtb3N0IGRldGFpbGVkIHRpbGUgY292ZXJpbmcgdGhlIHBvc2l0aW9uLlxuICogQHRocm93cyB7RGV2ZWxvcGVyRXJyb3J9IElmIHBvc2l0aW9uIGlzIG91dHNpZGUgYW55IHRpbGUgYWNjb3JkaW5nIHRvIHRoZSB0aWxpbmcgc2NoZW1lLlxuICovXG5UaWxlQXZhaWxhYmlsaXR5LnByb3RvdHlwZS5jb21wdXRlTWF4aW11bUxldmVsQXRQb3NpdGlvbiA9IGZ1bmN0aW9uIChwb3NpdGlvbikge1xuICAvLyBGaW5kIHRoZSByb290IG5vZGUgdGhhdCBjb250YWlucyB0aGlzIHBvc2l0aW9uLlxuICB2YXIgbm9kZTtcbiAgZm9yICh2YXIgbm9kZUluZGV4ID0gMDsgbm9kZUluZGV4IDwgdGhpcy5fcm9vdE5vZGVzLmxlbmd0aDsgKytub2RlSW5kZXgpIHtcbiAgICB2YXIgcm9vdE5vZGUgPSB0aGlzLl9yb290Tm9kZXNbbm9kZUluZGV4XTtcbiAgICBpZiAocmVjdGFuZ2xlQ29udGFpbnNQb3NpdGlvbihyb290Tm9kZS5leHRlbnQsIHBvc2l0aW9uKSkge1xuICAgICAgbm9kZSA9IHJvb3ROb2RlO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG5cbiAgaWYgKCFkZWZpbmVkKG5vZGUpKSB7XG4gICAgcmV0dXJuIC0xO1xuICB9XG5cbiAgcmV0dXJuIGZpbmRNYXhMZXZlbEZyb21Ob2RlKHVuZGVmaW5lZCwgbm9kZSwgcG9zaXRpb24pO1xufTtcblxudmFyIHJlY3RhbmdsZXNTY3JhdGNoID0gW107XG52YXIgcmVtYWluaW5nVG9Db3ZlckJ5TGV2ZWxTY3JhdGNoID0gW107XG52YXIgd2VzdFNjcmF0Y2ggPSBuZXcgUmVjdGFuZ2xlKCk7XG52YXIgZWFzdFNjcmF0Y2ggPSBuZXcgUmVjdGFuZ2xlKCk7XG5cbi8qKlxuICogRmluZHMgdGhlIG1vc3QgZGV0YWlsZWQgbGV2ZWwgdGhhdCBpcyBhdmFpbGFibGUgX2V2ZXJ5d2hlcmVfIHdpdGhpbiBhIGdpdmVuIHJlY3RhbmdsZS4gIE1vcmUgZGV0YWlsZWRcbiAqIHRpbGVzIG1heSBiZSBhdmFpbGFibGUgaW4gcGFydHMgb2YgdGhlIHJlY3RhbmdsZSwgYnV0IG5vdCB0aGUgd2hvbGUgdGhpbmcuICBUaGUgcmV0dXJuIHZhbHVlIG9mIHRoaXNcbiAqIGZ1bmN0aW9uIG1heSBiZSBzYWZlbHkgcGFzc2VkIHRvIHtAbGluayBzYW1wbGVUZXJyYWlufSBmb3IgYW55IHBvc2l0aW9uIHdpdGhpbiB0aGUgcmVjdGFuZ2xlLiAgVGhpcyBmdW5jdGlvblxuICogdXN1YWxseSBjb21wbGV0ZXMgaW4gdGltZSBsb2dhcml0aG1pYyB0byB0aGUgbnVtYmVyIG9mIHJlY3RhbmdsZXMgYWRkZWQgd2l0aFxuICoge0BsaW5rIFRpbGVBdmFpbGFiaWxpdHkjYWRkQXZhaWxhYmxlVGlsZVJhbmdlfS5cbiAqXG4gKiBAcGFyYW0ge1JlY3RhbmdsZX0gcmVjdGFuZ2xlIFRoZSByZWN0YW5nbGUuXG4gKiBAcmV0dXJuIHtOdW1iZXJ9IFRoZSBiZXN0IGF2YWlsYWJsZSBsZXZlbCBmb3IgdGhlIGVudGlyZSByZWN0YW5nbGUuXG4gKi9cblRpbGVBdmFpbGFiaWxpdHkucHJvdG90eXBlLmNvbXB1dGVCZXN0QXZhaWxhYmxlTGV2ZWxPdmVyUmVjdGFuZ2xlID0gZnVuY3Rpb24gKFxuICByZWN0YW5nbGVcbikge1xuICB2YXIgcmVjdGFuZ2xlcyA9IHJlY3RhbmdsZXNTY3JhdGNoO1xuICByZWN0YW5nbGVzLmxlbmd0aCA9IDA7XG5cbiAgaWYgKHJlY3RhbmdsZS5lYXN0IDwgcmVjdGFuZ2xlLndlc3QpIHtcbiAgICAvLyBSZWN0YW5nbGUgY3Jvc3NlcyB0aGUgSURMLCBtYWtlIGl0IHR3byByZWN0YW5nbGVzLlxuICAgIHJlY3RhbmdsZXMucHVzaChcbiAgICAgIFJlY3RhbmdsZS5mcm9tUmFkaWFucyhcbiAgICAgICAgLU1hdGguUEksXG4gICAgICAgIHJlY3RhbmdsZS5zb3V0aCxcbiAgICAgICAgcmVjdGFuZ2xlLmVhc3QsXG4gICAgICAgIHJlY3RhbmdsZS5ub3J0aCxcbiAgICAgICAgd2VzdFNjcmF0Y2hcbiAgICAgIClcbiAgICApO1xuICAgIHJlY3RhbmdsZXMucHVzaChcbiAgICAgIFJlY3RhbmdsZS5mcm9tUmFkaWFucyhcbiAgICAgICAgcmVjdGFuZ2xlLndlc3QsXG4gICAgICAgIHJlY3RhbmdsZS5zb3V0aCxcbiAgICAgICAgTWF0aC5QSSxcbiAgICAgICAgcmVjdGFuZ2xlLm5vcnRoLFxuICAgICAgICBlYXN0U2NyYXRjaFxuICAgICAgKVxuICAgICk7XG4gIH0gZWxzZSB7XG4gICAgcmVjdGFuZ2xlcy5wdXNoKHJlY3RhbmdsZSk7XG4gIH1cblxuICB2YXIgcmVtYWluaW5nVG9Db3ZlckJ5TGV2ZWwgPSByZW1haW5pbmdUb0NvdmVyQnlMZXZlbFNjcmF0Y2g7XG4gIHJlbWFpbmluZ1RvQ292ZXJCeUxldmVsLmxlbmd0aCA9IDA7XG5cbiAgdmFyIGk7XG4gIGZvciAoaSA9IDA7IGkgPCB0aGlzLl9yb290Tm9kZXMubGVuZ3RoOyArK2kpIHtcbiAgICB1cGRhdGVDb3ZlcmFnZVdpdGhOb2RlKFxuICAgICAgcmVtYWluaW5nVG9Db3ZlckJ5TGV2ZWwsXG4gICAgICB0aGlzLl9yb290Tm9kZXNbaV0sXG4gICAgICByZWN0YW5nbGVzXG4gICAgKTtcbiAgfVxuXG4gIGZvciAoaSA9IHJlbWFpbmluZ1RvQ292ZXJCeUxldmVsLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgaWYgKFxuICAgICAgZGVmaW5lZChyZW1haW5pbmdUb0NvdmVyQnlMZXZlbFtpXSkgJiZcbiAgICAgIHJlbWFpbmluZ1RvQ292ZXJCeUxldmVsW2ldLmxlbmd0aCA9PT0gMFxuICAgICkge1xuICAgICAgcmV0dXJuIGk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIDA7XG59O1xuXG52YXIgY2FydG9ncmFwaGljU2NyYXRjaCA9IG5ldyBDYXJ0b2dyYXBoaWMoKTtcblxuLyoqXG4gKiBEZXRlcm1pbmVzIGlmIGEgcGFydGljdWxhciB0aWxlIGlzIGF2YWlsYWJsZS5cbiAqIEBwYXJhbSB7TnVtYmVyfSBsZXZlbCBUaGUgdGlsZSBsZXZlbCB0byBjaGVjay5cbiAqIEBwYXJhbSB7TnVtYmVyfSB4IFRoZSBYIGNvb3JkaW5hdGUgb2YgdGhlIHRpbGUgdG8gY2hlY2suXG4gKiBAcGFyYW0ge051bWJlcn0geSBUaGUgWSBjb29yZGluYXRlIG9mIHRoZSB0aWxlIHRvIGNoZWNrLlxuICogQHJldHVybiB7Qm9vbGVhbn0gVHJ1ZSBpZiB0aGUgdGlsZSBpcyBhdmFpbGFibGU7IG90aGVyd2lzZSwgZmFsc2UuXG4gKi9cblRpbGVBdmFpbGFiaWxpdHkucHJvdG90eXBlLmlzVGlsZUF2YWlsYWJsZSA9IGZ1bmN0aW9uIChsZXZlbCwgeCwgeSkge1xuICAvLyBHZXQgdGhlIGNlbnRlciBvZiB0aGUgdGlsZSBhbmQgZmluZCB0aGUgbWF4aW11bSBsZXZlbCBhdCB0aGF0IHBvc2l0aW9uLlxuICAvLyBCZWNhdXNlIGF2YWlsYWJpbGl0eSBpcyBieSB0aWxlLCBpZiB0aGUgbGV2ZWwgaXMgYXZhaWxhYmxlIGF0IHRoYXQgcG9pbnQsIGl0XG4gIC8vIGlzIHN1cmUgdG8gYmUgYXZhaWxhYmxlIGZvciB0aGUgd2hvbGUgdGlsZS4gIFdlIGFzc3VtZSB0aGF0IGlmIGEgdGlsZSBhdCBsZXZlbCBuIGV4aXN0cyxcbiAgLy8gdGhlbiBhbGwgaXRzIHBhcmVudCB0aWxlcyBiYWNrIHRvIGxldmVsIDAgZXhpc3QgdG9vLiAgVGhpcyBpc24ndCByZWFsbHkgZW5mb3JjZWRcbiAgLy8gYW55d2hlcmUsIGJ1dCBDZXNpdW0gd291bGQgbmV2ZXIgbG9hZCBhIHRpbGUgZm9yIHdoaWNoIHRoaXMgaXMgbm90IHRydWUuXG4gIHZhciByZWN0YW5nbGUgPSB0aGlzLl90aWxpbmdTY2hlbWUudGlsZVhZVG9SZWN0YW5nbGUoXG4gICAgeCxcbiAgICB5LFxuICAgIGxldmVsLFxuICAgIHJlY3RhbmdsZVNjcmF0Y2hcbiAgKTtcbiAgUmVjdGFuZ2xlLmNlbnRlcihyZWN0YW5nbGUsIGNhcnRvZ3JhcGhpY1NjcmF0Y2gpO1xuICByZXR1cm4gdGhpcy5jb21wdXRlTWF4aW11bUxldmVsQXRQb3NpdGlvbihjYXJ0b2dyYXBoaWNTY3JhdGNoKSA+PSBsZXZlbDtcbn07XG5cbi8qKlxuICogQ29tcHV0ZXMgYSBiaXQgbWFzayBpbmRpY2F0aW5nIHdoaWNoIG9mIGEgdGlsZSdzIGZvdXIgY2hpbGRyZW4gZXhpc3QuXG4gKiBJZiBhIGNoaWxkJ3MgYml0IGlzIHNldCwgYSB0aWxlIGlzIGF2YWlsYWJsZSBmb3IgdGhhdCBjaGlsZC4gIElmIGl0IGlzIGNsZWFyZWQsXG4gKiB0aGUgdGlsZSBpcyBub3QgYXZhaWxhYmxlLiAgVGhlIGJpdCB2YWx1ZXMgYXJlIGFzIGZvbGxvd3M6XG4gKiA8dGFibGU+XG4gKiAgICAgPHRyPjx0aD5CaXQgUG9zaXRpb248L3RoPjx0aD5CaXQgVmFsdWU8L3RoPjx0aD5DaGlsZCBUaWxlPC90aD48L3RyPlxuICogICAgIDx0cj48dGQ+MDwvdGQ+PHRkPjE8L3RkPjx0ZD5Tb3V0aHdlc3Q8L3RkPjwvdHI+XG4gKiAgICAgPHRyPjx0ZD4xPC90ZD48dGQ+MjwvdGQ+PHRkPlNvdXRoZWFzdDwvdGQ+PC90cj5cbiAqICAgICA8dHI+PHRkPjI8L3RkPjx0ZD40PC90ZD48dGQ+Tm9ydGh3ZXN0PC90ZD48L3RyPlxuICogICAgIDx0cj48dGQ+MzwvdGQ+PHRkPjg8L3RkPjx0ZD5Ob3J0aGVhc3Q8L3RkPjwvdHI+XG4gKiA8L3RhYmxlPlxuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSBsZXZlbCBUaGUgbGV2ZWwgb2YgdGhlIHBhcmVudCB0aWxlLlxuICogQHBhcmFtIHtOdW1iZXJ9IHggVGhlIFggY29vcmRpbmF0ZSBvZiB0aGUgcGFyZW50IHRpbGUuXG4gKiBAcGFyYW0ge051bWJlcn0geSBUaGUgWSBjb29yZGluYXRlIG9mIHRoZSBwYXJlbnQgdGlsZS5cbiAqIEByZXR1cm4ge051bWJlcn0gVGhlIGJpdCBtYXNrIGluZGljYXRpbmcgY2hpbGQgYXZhaWxhYmlsaXR5LlxuICovXG5UaWxlQXZhaWxhYmlsaXR5LnByb3RvdHlwZS5jb21wdXRlQ2hpbGRNYXNrRm9yVGlsZSA9IGZ1bmN0aW9uIChsZXZlbCwgeCwgeSkge1xuICB2YXIgY2hpbGRMZXZlbCA9IGxldmVsICsgMTtcbiAgaWYgKGNoaWxkTGV2ZWwgPj0gdGhpcy5fbWF4aW11bUxldmVsKSB7XG4gICAgcmV0dXJuIDA7XG4gIH1cblxuICB2YXIgbWFzayA9IDA7XG5cbiAgbWFzayB8PSB0aGlzLmlzVGlsZUF2YWlsYWJsZShjaGlsZExldmVsLCAyICogeCwgMiAqIHkgKyAxKSA/IDEgOiAwO1xuICBtYXNrIHw9IHRoaXMuaXNUaWxlQXZhaWxhYmxlKGNoaWxkTGV2ZWwsIDIgKiB4ICsgMSwgMiAqIHkgKyAxKSA/IDIgOiAwO1xuICBtYXNrIHw9IHRoaXMuaXNUaWxlQXZhaWxhYmxlKGNoaWxkTGV2ZWwsIDIgKiB4LCAyICogeSkgPyA0IDogMDtcbiAgbWFzayB8PSB0aGlzLmlzVGlsZUF2YWlsYWJsZShjaGlsZExldmVsLCAyICogeCArIDEsIDIgKiB5KSA/IDggOiAwO1xuXG4gIHJldHVybiBtYXNrO1xufTtcblxuZnVuY3Rpb24gUXVhZHRyZWVOb2RlKHRpbGluZ1NjaGVtZSwgcGFyZW50LCBsZXZlbCwgeCwgeSkge1xuICB0aGlzLnRpbGluZ1NjaGVtZSA9IHRpbGluZ1NjaGVtZTtcbiAgdGhpcy5wYXJlbnQgPSBwYXJlbnQ7XG4gIHRoaXMubGV2ZWwgPSBsZXZlbDtcbiAgdGhpcy54ID0geDtcbiAgdGhpcy55ID0geTtcbiAgdGhpcy5leHRlbnQgPSB0aWxpbmdTY2hlbWUudGlsZVhZVG9SZWN0YW5nbGUoeCwgeSwgbGV2ZWwpO1xuXG4gIHRoaXMucmVjdGFuZ2xlcyA9IFtdO1xuICB0aGlzLl9zdyA9IHVuZGVmaW5lZDtcbiAgdGhpcy5fc2UgPSB1bmRlZmluZWQ7XG4gIHRoaXMuX253ID0gdW5kZWZpbmVkO1xuICB0aGlzLl9uZSA9IHVuZGVmaW5lZDtcbn1cblxuT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoUXVhZHRyZWVOb2RlLnByb3RvdHlwZSwge1xuICBudzoge1xuICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKCF0aGlzLl9udykge1xuICAgICAgICB0aGlzLl9udyA9IG5ldyBRdWFkdHJlZU5vZGUoXG4gICAgICAgICAgdGhpcy50aWxpbmdTY2hlbWUsXG4gICAgICAgICAgdGhpcyxcbiAgICAgICAgICB0aGlzLmxldmVsICsgMSxcbiAgICAgICAgICB0aGlzLnggKiAyLFxuICAgICAgICAgIHRoaXMueSAqIDJcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLl9udztcbiAgICB9LFxuICB9LFxuXG4gIG5lOiB7XG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAoIXRoaXMuX25lKSB7XG4gICAgICAgIHRoaXMuX25lID0gbmV3IFF1YWR0cmVlTm9kZShcbiAgICAgICAgICB0aGlzLnRpbGluZ1NjaGVtZSxcbiAgICAgICAgICB0aGlzLFxuICAgICAgICAgIHRoaXMubGV2ZWwgKyAxLFxuICAgICAgICAgIHRoaXMueCAqIDIgKyAxLFxuICAgICAgICAgIHRoaXMueSAqIDJcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLl9uZTtcbiAgICB9LFxuICB9LFxuXG4gIHN3OiB7XG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAoIXRoaXMuX3N3KSB7XG4gICAgICAgIHRoaXMuX3N3ID0gbmV3IFF1YWR0cmVlTm9kZShcbiAgICAgICAgICB0aGlzLnRpbGluZ1NjaGVtZSxcbiAgICAgICAgICB0aGlzLFxuICAgICAgICAgIHRoaXMubGV2ZWwgKyAxLFxuICAgICAgICAgIHRoaXMueCAqIDIsXG4gICAgICAgICAgdGhpcy55ICogMiArIDFcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLl9zdztcbiAgICB9LFxuICB9LFxuXG4gIHNlOiB7XG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAoIXRoaXMuX3NlKSB7XG4gICAgICAgIHRoaXMuX3NlID0gbmV3IFF1YWR0cmVlTm9kZShcbiAgICAgICAgICB0aGlzLnRpbGluZ1NjaGVtZSxcbiAgICAgICAgICB0aGlzLFxuICAgICAgICAgIHRoaXMubGV2ZWwgKyAxLFxuICAgICAgICAgIHRoaXMueCAqIDIgKyAxLFxuICAgICAgICAgIHRoaXMueSAqIDIgKyAxXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy5fc2U7XG4gICAgfSxcbiAgfSxcbn0pO1xuXG5mdW5jdGlvbiBSZWN0YW5nbGVXaXRoTGV2ZWwobGV2ZWwsIHdlc3QsIHNvdXRoLCBlYXN0LCBub3J0aCkge1xuICB0aGlzLmxldmVsID0gbGV2ZWw7XG4gIHRoaXMud2VzdCA9IHdlc3Q7XG4gIHRoaXMuc291dGggPSBzb3V0aDtcbiAgdGhpcy5lYXN0ID0gZWFzdDtcbiAgdGhpcy5ub3J0aCA9IG5vcnRoO1xufVxuXG5mdW5jdGlvbiByZWN0YW5nbGVzT3ZlcmxhcChyZWN0YW5nbGUxLCByZWN0YW5nbGUyKSB7XG4gIHZhciB3ZXN0ID0gTWF0aC5tYXgocmVjdGFuZ2xlMS53ZXN0LCByZWN0YW5nbGUyLndlc3QpO1xuICB2YXIgc291dGggPSBNYXRoLm1heChyZWN0YW5nbGUxLnNvdXRoLCByZWN0YW5nbGUyLnNvdXRoKTtcbiAgdmFyIGVhc3QgPSBNYXRoLm1pbihyZWN0YW5nbGUxLmVhc3QsIHJlY3RhbmdsZTIuZWFzdCk7XG4gIHZhciBub3J0aCA9IE1hdGgubWluKHJlY3RhbmdsZTEubm9ydGgsIHJlY3RhbmdsZTIubm9ydGgpO1xuICByZXR1cm4gc291dGggPCBub3J0aCAmJiB3ZXN0IDwgZWFzdDtcbn1cblxuZnVuY3Rpb24gcHV0UmVjdGFuZ2xlSW5RdWFkdHJlZShtYXhEZXB0aCwgbm9kZSwgcmVjdGFuZ2xlKSB7XG4gIHdoaWxlIChub2RlLmxldmVsIDwgbWF4RGVwdGgpIHtcbiAgICBpZiAocmVjdGFuZ2xlRnVsbHlDb250YWluc1JlY3RhbmdsZShub2RlLm53LmV4dGVudCwgcmVjdGFuZ2xlKSkge1xuICAgICAgbm9kZSA9IG5vZGUubnc7XG4gICAgfSBlbHNlIGlmIChyZWN0YW5nbGVGdWxseUNvbnRhaW5zUmVjdGFuZ2xlKG5vZGUubmUuZXh0ZW50LCByZWN0YW5nbGUpKSB7XG4gICAgICBub2RlID0gbm9kZS5uZTtcbiAgICB9IGVsc2UgaWYgKHJlY3RhbmdsZUZ1bGx5Q29udGFpbnNSZWN0YW5nbGUobm9kZS5zdy5leHRlbnQsIHJlY3RhbmdsZSkpIHtcbiAgICAgIG5vZGUgPSBub2RlLnN3O1xuICAgIH0gZWxzZSBpZiAocmVjdGFuZ2xlRnVsbHlDb250YWluc1JlY3RhbmdsZShub2RlLnNlLmV4dGVudCwgcmVjdGFuZ2xlKSkge1xuICAgICAgbm9kZSA9IG5vZGUuc2U7XG4gICAgfSBlbHNlIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIGlmIChcbiAgICBub2RlLnJlY3RhbmdsZXMubGVuZ3RoID09PSAwIHx8XG4gICAgbm9kZS5yZWN0YW5nbGVzW25vZGUucmVjdGFuZ2xlcy5sZW5ndGggLSAxXS5sZXZlbCA8PSByZWN0YW5nbGUubGV2ZWxcbiAgKSB7XG4gICAgbm9kZS5yZWN0YW5nbGVzLnB1c2gocmVjdGFuZ2xlKTtcbiAgfSBlbHNlIHtcbiAgICAvLyBNYWludGFpbiBvcmRlcmluZyBieSBsZXZlbCB3aGVuIGluc2VydGluZy5cbiAgICB2YXIgaW5kZXggPSBiaW5hcnlTZWFyY2goXG4gICAgICBub2RlLnJlY3RhbmdsZXMsXG4gICAgICByZWN0YW5nbGUubGV2ZWwsXG4gICAgICByZWN0YW5nbGVMZXZlbENvbXBhcmF0b3JcbiAgICApO1xuICAgIGlmIChpbmRleCA8IDApIHtcbiAgICAgIGluZGV4ID0gfmluZGV4O1xuICAgIH1cbiAgICBub2RlLnJlY3RhbmdsZXMuc3BsaWNlKGluZGV4LCAwLCByZWN0YW5nbGUpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHJlY3RhbmdsZUxldmVsQ29tcGFyYXRvcihhLCBiKSB7XG4gIHJldHVybiBhLmxldmVsIC0gYjtcbn1cblxuZnVuY3Rpb24gcmVjdGFuZ2xlRnVsbHlDb250YWluc1JlY3RhbmdsZShwb3RlbnRpYWxDb250YWluZXIsIHJlY3RhbmdsZVRvVGVzdCkge1xuICByZXR1cm4gKFxuICAgIHJlY3RhbmdsZVRvVGVzdC53ZXN0ID49IHBvdGVudGlhbENvbnRhaW5lci53ZXN0ICYmXG4gICAgcmVjdGFuZ2xlVG9UZXN0LmVhc3QgPD0gcG90ZW50aWFsQ29udGFpbmVyLmVhc3QgJiZcbiAgICByZWN0YW5nbGVUb1Rlc3Quc291dGggPj0gcG90ZW50aWFsQ29udGFpbmVyLnNvdXRoICYmXG4gICAgcmVjdGFuZ2xlVG9UZXN0Lm5vcnRoIDw9IHBvdGVudGlhbENvbnRhaW5lci5ub3J0aFxuICApO1xufVxuXG5mdW5jdGlvbiByZWN0YW5nbGVDb250YWluc1Bvc2l0aW9uKHBvdGVudGlhbENvbnRhaW5lciwgcG9zaXRpb25Ub1Rlc3QpIHtcbiAgcmV0dXJuIChcbiAgICBwb3NpdGlvblRvVGVzdC5sb25naXR1ZGUgPj0gcG90ZW50aWFsQ29udGFpbmVyLndlc3QgJiZcbiAgICBwb3NpdGlvblRvVGVzdC5sb25naXR1ZGUgPD0gcG90ZW50aWFsQ29udGFpbmVyLmVhc3QgJiZcbiAgICBwb3NpdGlvblRvVGVzdC5sYXRpdHVkZSA+PSBwb3RlbnRpYWxDb250YWluZXIuc291dGggJiZcbiAgICBwb3NpdGlvblRvVGVzdC5sYXRpdHVkZSA8PSBwb3RlbnRpYWxDb250YWluZXIubm9ydGhcbiAgKTtcbn1cblxuZnVuY3Rpb24gZmluZE1heExldmVsRnJvbU5vZGUoc3RvcE5vZGUsIG5vZGUsIHBvc2l0aW9uKSB7XG4gIHZhciBtYXhMZXZlbCA9IDA7XG5cbiAgLy8gRmluZCB0aGUgZGVlcGVzdCBxdWFkdHJlZSBub2RlIGNvbnRhaW5pbmcgdGhpcyBwb2ludC5cbiAgdmFyIGZvdW5kID0gZmFsc2U7XG4gIHdoaWxlICghZm91bmQpIHtcbiAgICB2YXIgbncgPSBub2RlLl9udyAmJiByZWN0YW5nbGVDb250YWluc1Bvc2l0aW9uKG5vZGUuX253LmV4dGVudCwgcG9zaXRpb24pO1xuICAgIHZhciBuZSA9IG5vZGUuX25lICYmIHJlY3RhbmdsZUNvbnRhaW5zUG9zaXRpb24obm9kZS5fbmUuZXh0ZW50LCBwb3NpdGlvbik7XG4gICAgdmFyIHN3ID0gbm9kZS5fc3cgJiYgcmVjdGFuZ2xlQ29udGFpbnNQb3NpdGlvbihub2RlLl9zdy5leHRlbnQsIHBvc2l0aW9uKTtcbiAgICB2YXIgc2UgPSBub2RlLl9zZSAmJiByZWN0YW5nbGVDb250YWluc1Bvc2l0aW9uKG5vZGUuX3NlLmV4dGVudCwgcG9zaXRpb24pO1xuXG4gICAgLy8gVGhlIGNvbW1vbiBzY2VuYXJpbyBpcyB0aGF0IHRoZSBwb2ludCBpcyBpbiBvbmx5IG9uZSBxdWFkcmFudCBhbmQgd2UgY2FuIHNpbXBseVxuICAgIC8vIGl0ZXJhdGUgZG93biB0aGUgdHJlZS4gIEJ1dCBpZiB0aGUgcG9pbnQgaXMgb24gYSBib3VuZGFyeSBiZXR3ZWVuIHRpbGVzLCBpdCBpc1xuICAgIC8vIGluIG11bHRpcGxlIHRpbGVzIGFuZCB3ZSBuZWVkIHRvIGNoZWNrIGFsbCBvZiB0aGVtLCBzbyB1c2UgcmVjdXJzaW9uLlxuICAgIGlmIChudyArIG5lICsgc3cgKyBzZSA+IDEpIHtcbiAgICAgIGlmIChudykge1xuICAgICAgICBtYXhMZXZlbCA9IE1hdGgubWF4KFxuICAgICAgICAgIG1heExldmVsLFxuICAgICAgICAgIGZpbmRNYXhMZXZlbEZyb21Ob2RlKG5vZGUsIG5vZGUuX253LCBwb3NpdGlvbilcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIGlmIChuZSkge1xuICAgICAgICBtYXhMZXZlbCA9IE1hdGgubWF4KFxuICAgICAgICAgIG1heExldmVsLFxuICAgICAgICAgIGZpbmRNYXhMZXZlbEZyb21Ob2RlKG5vZGUsIG5vZGUuX25lLCBwb3NpdGlvbilcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIGlmIChzdykge1xuICAgICAgICBtYXhMZXZlbCA9IE1hdGgubWF4KFxuICAgICAgICAgIG1heExldmVsLFxuICAgICAgICAgIGZpbmRNYXhMZXZlbEZyb21Ob2RlKG5vZGUsIG5vZGUuX3N3LCBwb3NpdGlvbilcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIGlmIChzZSkge1xuICAgICAgICBtYXhMZXZlbCA9IE1hdGgubWF4KFxuICAgICAgICAgIG1heExldmVsLFxuICAgICAgICAgIGZpbmRNYXhMZXZlbEZyb21Ob2RlKG5vZGUsIG5vZGUuX3NlLCBwb3NpdGlvbilcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICAgIH0gZWxzZSBpZiAobncpIHtcbiAgICAgIG5vZGUgPSBub2RlLl9udztcbiAgICB9IGVsc2UgaWYgKG5lKSB7XG4gICAgICBub2RlID0gbm9kZS5fbmU7XG4gICAgfSBlbHNlIGlmIChzdykge1xuICAgICAgbm9kZSA9IG5vZGUuX3N3O1xuICAgIH0gZWxzZSBpZiAoc2UpIHtcbiAgICAgIG5vZGUgPSBub2RlLl9zZTtcbiAgICB9IGVsc2Uge1xuICAgICAgZm91bmQgPSB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIC8vIFdvcmsgdXAgdGhlIHRyZWUgdW50aWwgd2UgZmluZCBhIHJlY3RhbmdsZSB0aGF0IGNvbnRhaW5zIHRoaXMgcG9pbnQuXG4gIHdoaWxlIChub2RlICE9PSBzdG9wTm9kZSkge1xuICAgIHZhciByZWN0YW5nbGVzID0gbm9kZS5yZWN0YW5nbGVzO1xuXG4gICAgLy8gUmVjdGFuZ2xlcyBhcmUgc29ydGVkIGJ5IGxldmVsLCBsb3dlc3QgZmlyc3QuXG4gICAgZm9yIChcbiAgICAgIHZhciBpID0gcmVjdGFuZ2xlcy5sZW5ndGggLSAxO1xuICAgICAgaSA+PSAwICYmIHJlY3RhbmdsZXNbaV0ubGV2ZWwgPiBtYXhMZXZlbDtcbiAgICAgIC0taVxuICAgICkge1xuICAgICAgdmFyIHJlY3RhbmdsZSA9IHJlY3RhbmdsZXNbaV07XG4gICAgICBpZiAocmVjdGFuZ2xlQ29udGFpbnNQb3NpdGlvbihyZWN0YW5nbGUsIHBvc2l0aW9uKSkge1xuICAgICAgICBtYXhMZXZlbCA9IHJlY3RhbmdsZS5sZXZlbDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBub2RlID0gbm9kZS5wYXJlbnQ7XG4gIH1cblxuICByZXR1cm4gbWF4TGV2ZWw7XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZUNvdmVyYWdlV2l0aE5vZGUoXG4gIHJlbWFpbmluZ1RvQ292ZXJCeUxldmVsLFxuICBub2RlLFxuICByZWN0YW5nbGVzVG9Db3ZlclxuKSB7XG4gIGlmICghbm9kZSkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciBpO1xuICB2YXIgYW55T3ZlcmxhcCA9IGZhbHNlO1xuICBmb3IgKGkgPSAwOyBpIDwgcmVjdGFuZ2xlc1RvQ292ZXIubGVuZ3RoOyArK2kpIHtcbiAgICBhbnlPdmVybGFwID1cbiAgICAgIGFueU92ZXJsYXAgfHwgcmVjdGFuZ2xlc092ZXJsYXAobm9kZS5leHRlbnQsIHJlY3RhbmdsZXNUb0NvdmVyW2ldKTtcbiAgfVxuXG4gIGlmICghYW55T3ZlcmxhcCkge1xuICAgIC8vIFRoaXMgbm9kZSBpcyBub3QgYXBwbGljYWJsZSB0byB0aGUgcmVjdGFuZ2xlKHMpLlxuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciByZWN0YW5nbGVzID0gbm9kZS5yZWN0YW5nbGVzO1xuICBmb3IgKGkgPSAwOyBpIDwgcmVjdGFuZ2xlcy5sZW5ndGg7ICsraSkge1xuICAgIHZhciByZWN0YW5nbGUgPSByZWN0YW5nbGVzW2ldO1xuXG4gICAgaWYgKCFyZW1haW5pbmdUb0NvdmVyQnlMZXZlbFtyZWN0YW5nbGUubGV2ZWxdKSB7XG4gICAgICByZW1haW5pbmdUb0NvdmVyQnlMZXZlbFtyZWN0YW5nbGUubGV2ZWxdID0gcmVjdGFuZ2xlc1RvQ292ZXI7XG4gICAgfVxuXG4gICAgcmVtYWluaW5nVG9Db3ZlckJ5TGV2ZWxbcmVjdGFuZ2xlLmxldmVsXSA9IHN1YnRyYWN0UmVjdGFuZ2xlKFxuICAgICAgcmVtYWluaW5nVG9Db3ZlckJ5TGV2ZWxbcmVjdGFuZ2xlLmxldmVsXSxcbiAgICAgIHJlY3RhbmdsZVxuICAgICk7XG4gIH1cblxuICAvLyBVcGRhdGUgd2l0aCBjaGlsZCBub2Rlcy5cbiAgdXBkYXRlQ292ZXJhZ2VXaXRoTm9kZShyZW1haW5pbmdUb0NvdmVyQnlMZXZlbCwgbm9kZS5fbncsIHJlY3RhbmdsZXNUb0NvdmVyKTtcbiAgdXBkYXRlQ292ZXJhZ2VXaXRoTm9kZShyZW1haW5pbmdUb0NvdmVyQnlMZXZlbCwgbm9kZS5fbmUsIHJlY3RhbmdsZXNUb0NvdmVyKTtcbiAgdXBkYXRlQ292ZXJhZ2VXaXRoTm9kZShyZW1haW5pbmdUb0NvdmVyQnlMZXZlbCwgbm9kZS5fc3csIHJlY3RhbmdsZXNUb0NvdmVyKTtcbiAgdXBkYXRlQ292ZXJhZ2VXaXRoTm9kZShyZW1haW5pbmdUb0NvdmVyQnlMZXZlbCwgbm9kZS5fc2UsIHJlY3RhbmdsZXNUb0NvdmVyKTtcbn1cblxuZnVuY3Rpb24gc3VidHJhY3RSZWN0YW5nbGUocmVjdGFuZ2xlTGlzdCwgcmVjdGFuZ2xlVG9TdWJ0cmFjdCkge1xuICB2YXIgcmVzdWx0ID0gW107XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcmVjdGFuZ2xlTGlzdC5sZW5ndGg7ICsraSkge1xuICAgIHZhciByZWN0YW5nbGUgPSByZWN0YW5nbGVMaXN0W2ldO1xuICAgIGlmICghcmVjdGFuZ2xlc092ZXJsYXAocmVjdGFuZ2xlLCByZWN0YW5nbGVUb1N1YnRyYWN0KSkge1xuICAgICAgLy8gRGlzam9pbnQgcmVjdGFuZ2xlcy4gIE9yaWdpbmFsIHJlY3RhbmdsZSBpcyB1bm1vZGlmaWVkLlxuICAgICAgcmVzdWx0LnB1c2gocmVjdGFuZ2xlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gcmVjdGFuZ2xlVG9TdWJ0cmFjdCBwYXJ0aWFsbHkgb3IgY29tcGxldGVseSBvdmVybGFwcyByZWN0YW5nbGUuXG4gICAgICBpZiAocmVjdGFuZ2xlLndlc3QgPCByZWN0YW5nbGVUb1N1YnRyYWN0Lndlc3QpIHtcbiAgICAgICAgcmVzdWx0LnB1c2goXG4gICAgICAgICAgbmV3IFJlY3RhbmdsZShcbiAgICAgICAgICAgIHJlY3RhbmdsZS53ZXN0LFxuICAgICAgICAgICAgcmVjdGFuZ2xlLnNvdXRoLFxuICAgICAgICAgICAgcmVjdGFuZ2xlVG9TdWJ0cmFjdC53ZXN0LFxuICAgICAgICAgICAgcmVjdGFuZ2xlLm5vcnRoXG4gICAgICAgICAgKVxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgaWYgKHJlY3RhbmdsZS5lYXN0ID4gcmVjdGFuZ2xlVG9TdWJ0cmFjdC5lYXN0KSB7XG4gICAgICAgIHJlc3VsdC5wdXNoKFxuICAgICAgICAgIG5ldyBSZWN0YW5nbGUoXG4gICAgICAgICAgICByZWN0YW5nbGVUb1N1YnRyYWN0LmVhc3QsXG4gICAgICAgICAgICByZWN0YW5nbGUuc291dGgsXG4gICAgICAgICAgICByZWN0YW5nbGUuZWFzdCxcbiAgICAgICAgICAgIHJlY3RhbmdsZS5ub3J0aFxuICAgICAgICAgIClcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIGlmIChyZWN0YW5nbGUuc291dGggPCByZWN0YW5nbGVUb1N1YnRyYWN0LnNvdXRoKSB7XG4gICAgICAgIHJlc3VsdC5wdXNoKFxuICAgICAgICAgIG5ldyBSZWN0YW5nbGUoXG4gICAgICAgICAgICBNYXRoLm1heChyZWN0YW5nbGVUb1N1YnRyYWN0Lndlc3QsIHJlY3RhbmdsZS53ZXN0KSxcbiAgICAgICAgICAgIHJlY3RhbmdsZS5zb3V0aCxcbiAgICAgICAgICAgIE1hdGgubWluKHJlY3RhbmdsZVRvU3VidHJhY3QuZWFzdCwgcmVjdGFuZ2xlLmVhc3QpLFxuICAgICAgICAgICAgcmVjdGFuZ2xlVG9TdWJ0cmFjdC5zb3V0aFxuICAgICAgICAgIClcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIGlmIChyZWN0YW5nbGUubm9ydGggPiByZWN0YW5nbGVUb1N1YnRyYWN0Lm5vcnRoKSB7XG4gICAgICAgIHJlc3VsdC5wdXNoKFxuICAgICAgICAgIG5ldyBSZWN0YW5nbGUoXG4gICAgICAgICAgICBNYXRoLm1heChyZWN0YW5nbGVUb1N1YnRyYWN0Lndlc3QsIHJlY3RhbmdsZS53ZXN0KSxcbiAgICAgICAgICAgIHJlY3RhbmdsZVRvU3VidHJhY3Qubm9ydGgsXG4gICAgICAgICAgICBNYXRoLm1pbihyZWN0YW5nbGVUb1N1YnRyYWN0LmVhc3QsIHJlY3RhbmdsZS5lYXN0KSxcbiAgICAgICAgICAgIHJlY3RhbmdsZS5ub3J0aFxuICAgICAgICAgIClcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gcmVzdWx0O1xufVxuZXhwb3J0IGRlZmF1bHQgVGlsZUF2YWlsYWJpbGl0eTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///25707\n')},41534:function(__unused_webpack___webpack_module__,__webpack_exports__){eval('/**\n * @private\n */\nvar TileEdge = {\n  WEST: 0,\n  NORTH: 1,\n  EAST: 2,\n  SOUTH: 3,\n  NORTHWEST: 4,\n  NORTHEAST: 5,\n  SOUTHWEST: 6,\n  SOUTHEAST: 7,\n};\n/* harmony default export */ __webpack_exports__["Z"] = (TileEdge);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNDE1MzQuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5REFBZSxRQUFRLEVBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly92dWUzLXdlYnBhY2s1Ly4vbm9kZV9tb2R1bGVzL2Nlc2l1bS9Tb3VyY2UvQ29yZS9UaWxlRWRnZS5qcz80OWIyIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQHByaXZhdGVcbiAqL1xudmFyIFRpbGVFZGdlID0ge1xuICBXRVNUOiAwLFxuICBOT1JUSDogMSxcbiAgRUFTVDogMixcbiAgU09VVEg6IDMsXG4gIE5PUlRIV0VTVDogNCxcbiAgTk9SVEhFQVNUOiA1LFxuICBTT1VUSFdFU1Q6IDYsXG4gIFNPVVRIRUFTVDogNyxcbn07XG5leHBvcnQgZGVmYXVsdCBUaWxlRWRnZTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///41534\n')},9121:function(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__){eval('/* harmony import */ var _defaultValue_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(62200);\n/* harmony import */ var _defined_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(82982);\n/* harmony import */ var _formatError_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(74771);\n\n\n\n\n/**\n * Provides details about an error that occurred in an {@link ImageryProvider} or a {@link TerrainProvider}.\n *\n * @alias TileProviderError\n * @constructor\n *\n * @param {ImageryProvider|TerrainProvider} provider The imagery or terrain provider that experienced the error.\n * @param {String} message A message describing the error.\n * @param {Number} [x] The X coordinate of the tile that experienced the error, or undefined if the error\n *        is not specific to a particular tile.\n * @param {Number} [y] The Y coordinate of the tile that experienced the error, or undefined if the error\n *        is not specific to a particular tile.\n * @param {Number} [level] The level of the tile that experienced the error, or undefined if the error\n *        is not specific to a particular tile.\n * @param {Number} [timesRetried=0] The number of times this operation has been retried.\n * @param {Error} [error] The error or exception that occurred, if any.\n */\nfunction TileProviderError(\n  provider,\n  message,\n  x,\n  y,\n  level,\n  timesRetried,\n  error\n) {\n  /**\n   * The {@link ImageryProvider} or {@link TerrainProvider} that experienced the error.\n   * @type {ImageryProvider|TerrainProvider}\n   */\n  this.provider = provider;\n\n  /**\n   * The message describing the error.\n   * @type {String}\n   */\n  this.message = message;\n\n  /**\n   * The X coordinate of the tile that experienced the error.  If the error is not specific\n   * to a particular tile, this property will be undefined.\n   * @type {Number}\n   */\n  this.x = x;\n\n  /**\n   * The Y coordinate of the tile that experienced the error.  If the error is not specific\n   * to a particular tile, this property will be undefined.\n   * @type {Number}\n   */\n  this.y = y;\n\n  /**\n   * The level-of-detail of the tile that experienced the error.  If the error is not specific\n   * to a particular tile, this property will be undefined.\n   * @type {Number}\n   */\n  this.level = level;\n\n  /**\n   * The number of times this operation has been retried.\n   * @type {Number}\n   * @default 0\n   */\n  this.timesRetried = (0,_defaultValue_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .Z)(timesRetried, 0);\n\n  /**\n   * True if the failed operation should be retried; otherwise, false.  The imagery or terrain provider\n   * will set the initial value of this property before raising the event, but any listeners\n   * can change it.  The value after the last listener is invoked will be acted upon.\n   * @type {Boolean}\n   * @default false\n   */\n  this.retry = false;\n\n  /**\n   * The error or exception that occurred, if any.\n   * @type {Error}\n   */\n  this.error = error;\n}\n\n/**\n * Handles an error in an {@link ImageryProvider} or {@link TerrainProvider} by raising an event if it has any listeners, or by\n * logging the error to the console if the event has no listeners.  This method also tracks the number\n * of times the operation has been retried and will automatically retry if requested to do so by the\n * event listeners.\n *\n * @param {TileProviderError} previousError The error instance returned by this function the last\n *        time it was called for this error, or undefined if this is the first time this error has\n *        occurred.\n * @param {ImageryProvider|TerrainProvider} provider The imagery or terrain provider that encountered the error.\n * @param {Event} event The event to raise to inform listeners of the error.\n * @param {String} message The message describing the error.\n * @param {Number} x The X coordinate of the tile that experienced the error, or undefined if the\n *        error is not specific to a particular tile.\n * @param {Number} y The Y coordinate of the tile that experienced the error, or undefined if the\n *        error is not specific to a particular tile.\n * @param {Number} level The level-of-detail of the tile that experienced the error, or undefined if the\n *        error is not specific to a particular tile.\n * @param {TileProviderError.RetryFunction} retryFunction The function to call to retry the operation.  If undefined, the\n *        operation will not be retried.\n * @param {Error} [errorDetails] The error or exception that occurred, if any.\n * @returns {TileProviderError} The error instance that was passed to the event listeners and that\n *          should be passed to this function the next time it is called for the same error in order\n *          to track retry counts.\n */\nTileProviderError.handleError = function (\n  previousError,\n  provider,\n  event,\n  message,\n  x,\n  y,\n  level,\n  retryFunction,\n  errorDetails\n) {\n  var error = previousError;\n  if (!(0,_defined_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .Z)(previousError)) {\n    error = new TileProviderError(\n      provider,\n      message,\n      x,\n      y,\n      level,\n      0,\n      errorDetails\n    );\n  } else {\n    error.provider = provider;\n    error.message = message;\n    error.x = x;\n    error.y = y;\n    error.level = level;\n    error.retry = false;\n    error.error = errorDetails;\n    ++error.timesRetried;\n  }\n\n  if (event.numberOfListeners > 0) {\n    event.raiseEvent(error);\n  } else {\n    console.log(\n      \'An error occurred in "\' +\n        provider.constructor.name +\n        \'": \' +\n        (0,_formatError_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"] */ .Z)(message)\n    );\n  }\n\n  if (error.retry && (0,_defined_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .Z)(retryFunction)) {\n    retryFunction();\n  }\n\n  return error;\n};\n\n/**\n * Handles success of an operation by resetting the retry count of a previous error, if any.  This way,\n * if the error occurs again in the future, the listeners will be informed that it has not yet been retried.\n *\n * @param {TileProviderError} previousError The previous error, or undefined if this operation has\n *        not previously resulted in an error.\n */\nTileProviderError.handleSuccess = function (previousError) {\n  if ((0,_defined_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .Z)(previousError)) {\n    previousError.timesRetried = -1;\n  }\n};\n\n/**\n * A function that will be called to retry the operation.\n * @callback TileProviderError.RetryFunction\n */\n/* harmony default export */ __webpack_exports__["Z"] = (TileProviderError);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiOTEyMS5qcyIsIm1hcHBpbmdzIjoiOzs7QUFBNkM7QUFDVjtBQUNROztBQUUzQztBQUNBLHdEQUF3RCx1QkFBdUIsTUFBTSxzQkFBc0I7QUFDM0c7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGlDQUFpQztBQUM1QyxXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CO0FBQ0EsV0FBVyxRQUFRO0FBQ25CO0FBQ0EsV0FBVyxRQUFRO0FBQ25CO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsT0FBTztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSx1QkFBdUIsSUFBSSx1QkFBdUI7QUFDNUQsWUFBWTtBQUNaO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBLHNCQUFzQixxRUFBWTs7QUFFbEM7QUFDQSxxREFBcUQ7QUFDckQ7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwyQkFBMkIsdUJBQXVCLElBQUksdUJBQXVCO0FBQzdFO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxtQkFBbUI7QUFDOUI7QUFDQTtBQUNBLFdBQVcsaUNBQWlDO0FBQzVDLFdBQVcsT0FBTztBQUNsQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CO0FBQ0EsV0FBVyxRQUFRO0FBQ25CO0FBQ0EsV0FBVyxRQUFRO0FBQ25CO0FBQ0EsV0FBVyxpQ0FBaUM7QUFDNUM7QUFDQSxXQUFXLE9BQU87QUFDbEIsYUFBYSxtQkFBbUI7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTyxnRUFBTztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsb0VBQVc7QUFDbkI7QUFDQTs7QUFFQSxxQkFBcUIsZ0VBQU87QUFDNUI7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxtQkFBbUI7QUFDOUI7QUFDQTtBQUNBO0FBQ0EsTUFBTSxnRUFBTztBQUNiO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlEQUFlLGlCQUFpQixFQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdnVlMy13ZWJwYWNrNS8uL25vZGVfbW9kdWxlcy9jZXNpdW0vU291cmNlL0NvcmUvVGlsZVByb3ZpZGVyRXJyb3IuanM/ZDQxOCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgZGVmYXVsdFZhbHVlIGZyb20gXCIuL2RlZmF1bHRWYWx1ZS5qc1wiO1xuaW1wb3J0IGRlZmluZWQgZnJvbSBcIi4vZGVmaW5lZC5qc1wiO1xuaW1wb3J0IGZvcm1hdEVycm9yIGZyb20gXCIuL2Zvcm1hdEVycm9yLmpzXCI7XG5cbi8qKlxuICogUHJvdmlkZXMgZGV0YWlscyBhYm91dCBhbiBlcnJvciB0aGF0IG9jY3VycmVkIGluIGFuIHtAbGluayBJbWFnZXJ5UHJvdmlkZXJ9IG9yIGEge0BsaW5rIFRlcnJhaW5Qcm92aWRlcn0uXG4gKlxuICogQGFsaWFzIFRpbGVQcm92aWRlckVycm9yXG4gKiBAY29uc3RydWN0b3JcbiAqXG4gKiBAcGFyYW0ge0ltYWdlcnlQcm92aWRlcnxUZXJyYWluUHJvdmlkZXJ9IHByb3ZpZGVyIFRoZSBpbWFnZXJ5IG9yIHRlcnJhaW4gcHJvdmlkZXIgdGhhdCBleHBlcmllbmNlZCB0aGUgZXJyb3IuXG4gKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZSBBIG1lc3NhZ2UgZGVzY3JpYmluZyB0aGUgZXJyb3IuXG4gKiBAcGFyYW0ge051bWJlcn0gW3hdIFRoZSBYIGNvb3JkaW5hdGUgb2YgdGhlIHRpbGUgdGhhdCBleHBlcmllbmNlZCB0aGUgZXJyb3IsIG9yIHVuZGVmaW5lZCBpZiB0aGUgZXJyb3JcbiAqICAgICAgICBpcyBub3Qgc3BlY2lmaWMgdG8gYSBwYXJ0aWN1bGFyIHRpbGUuXG4gKiBAcGFyYW0ge051bWJlcn0gW3ldIFRoZSBZIGNvb3JkaW5hdGUgb2YgdGhlIHRpbGUgdGhhdCBleHBlcmllbmNlZCB0aGUgZXJyb3IsIG9yIHVuZGVmaW5lZCBpZiB0aGUgZXJyb3JcbiAqICAgICAgICBpcyBub3Qgc3BlY2lmaWMgdG8gYSBwYXJ0aWN1bGFyIHRpbGUuXG4gKiBAcGFyYW0ge051bWJlcn0gW2xldmVsXSBUaGUgbGV2ZWwgb2YgdGhlIHRpbGUgdGhhdCBleHBlcmllbmNlZCB0aGUgZXJyb3IsIG9yIHVuZGVmaW5lZCBpZiB0aGUgZXJyb3JcbiAqICAgICAgICBpcyBub3Qgc3BlY2lmaWMgdG8gYSBwYXJ0aWN1bGFyIHRpbGUuXG4gKiBAcGFyYW0ge051bWJlcn0gW3RpbWVzUmV0cmllZD0wXSBUaGUgbnVtYmVyIG9mIHRpbWVzIHRoaXMgb3BlcmF0aW9uIGhhcyBiZWVuIHJldHJpZWQuXG4gKiBAcGFyYW0ge0Vycm9yfSBbZXJyb3JdIFRoZSBlcnJvciBvciBleGNlcHRpb24gdGhhdCBvY2N1cnJlZCwgaWYgYW55LlxuICovXG5mdW5jdGlvbiBUaWxlUHJvdmlkZXJFcnJvcihcbiAgcHJvdmlkZXIsXG4gIG1lc3NhZ2UsXG4gIHgsXG4gIHksXG4gIGxldmVsLFxuICB0aW1lc1JldHJpZWQsXG4gIGVycm9yXG4pIHtcbiAgLyoqXG4gICAqIFRoZSB7QGxpbmsgSW1hZ2VyeVByb3ZpZGVyfSBvciB7QGxpbmsgVGVycmFpblByb3ZpZGVyfSB0aGF0IGV4cGVyaWVuY2VkIHRoZSBlcnJvci5cbiAgICogQHR5cGUge0ltYWdlcnlQcm92aWRlcnxUZXJyYWluUHJvdmlkZXJ9XG4gICAqL1xuICB0aGlzLnByb3ZpZGVyID0gcHJvdmlkZXI7XG5cbiAgLyoqXG4gICAqIFRoZSBtZXNzYWdlIGRlc2NyaWJpbmcgdGhlIGVycm9yLlxuICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgKi9cbiAgdGhpcy5tZXNzYWdlID0gbWVzc2FnZTtcblxuICAvKipcbiAgICogVGhlIFggY29vcmRpbmF0ZSBvZiB0aGUgdGlsZSB0aGF0IGV4cGVyaWVuY2VkIHRoZSBlcnJvci4gIElmIHRoZSBlcnJvciBpcyBub3Qgc3BlY2lmaWNcbiAgICogdG8gYSBwYXJ0aWN1bGFyIHRpbGUsIHRoaXMgcHJvcGVydHkgd2lsbCBiZSB1bmRlZmluZWQuXG4gICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAqL1xuICB0aGlzLnggPSB4O1xuXG4gIC8qKlxuICAgKiBUaGUgWSBjb29yZGluYXRlIG9mIHRoZSB0aWxlIHRoYXQgZXhwZXJpZW5jZWQgdGhlIGVycm9yLiAgSWYgdGhlIGVycm9yIGlzIG5vdCBzcGVjaWZpY1xuICAgKiB0byBhIHBhcnRpY3VsYXIgdGlsZSwgdGhpcyBwcm9wZXJ0eSB3aWxsIGJlIHVuZGVmaW5lZC5cbiAgICogQHR5cGUge051bWJlcn1cbiAgICovXG4gIHRoaXMueSA9IHk7XG5cbiAgLyoqXG4gICAqIFRoZSBsZXZlbC1vZi1kZXRhaWwgb2YgdGhlIHRpbGUgdGhhdCBleHBlcmllbmNlZCB0aGUgZXJyb3IuICBJZiB0aGUgZXJyb3IgaXMgbm90IHNwZWNpZmljXG4gICAqIHRvIGEgcGFydGljdWxhciB0aWxlLCB0aGlzIHByb3BlcnR5IHdpbGwgYmUgdW5kZWZpbmVkLlxuICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgKi9cbiAgdGhpcy5sZXZlbCA9IGxldmVsO1xuXG4gIC8qKlxuICAgKiBUaGUgbnVtYmVyIG9mIHRpbWVzIHRoaXMgb3BlcmF0aW9uIGhhcyBiZWVuIHJldHJpZWQuXG4gICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAqIEBkZWZhdWx0IDBcbiAgICovXG4gIHRoaXMudGltZXNSZXRyaWVkID0gZGVmYXVsdFZhbHVlKHRpbWVzUmV0cmllZCwgMCk7XG5cbiAgLyoqXG4gICAqIFRydWUgaWYgdGhlIGZhaWxlZCBvcGVyYXRpb24gc2hvdWxkIGJlIHJldHJpZWQ7IG90aGVyd2lzZSwgZmFsc2UuICBUaGUgaW1hZ2VyeSBvciB0ZXJyYWluIHByb3ZpZGVyXG4gICAqIHdpbGwgc2V0IHRoZSBpbml0aWFsIHZhbHVlIG9mIHRoaXMgcHJvcGVydHkgYmVmb3JlIHJhaXNpbmcgdGhlIGV2ZW50LCBidXQgYW55IGxpc3RlbmVyc1xuICAgKiBjYW4gY2hhbmdlIGl0LiAgVGhlIHZhbHVlIGFmdGVyIHRoZSBsYXN0IGxpc3RlbmVyIGlzIGludm9rZWQgd2lsbCBiZSBhY3RlZCB1cG9uLlxuICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICogQGRlZmF1bHQgZmFsc2VcbiAgICovXG4gIHRoaXMucmV0cnkgPSBmYWxzZTtcblxuICAvKipcbiAgICogVGhlIGVycm9yIG9yIGV4Y2VwdGlvbiB0aGF0IG9jY3VycmVkLCBpZiBhbnkuXG4gICAqIEB0eXBlIHtFcnJvcn1cbiAgICovXG4gIHRoaXMuZXJyb3IgPSBlcnJvcjtcbn1cblxuLyoqXG4gKiBIYW5kbGVzIGFuIGVycm9yIGluIGFuIHtAbGluayBJbWFnZXJ5UHJvdmlkZXJ9IG9yIHtAbGluayBUZXJyYWluUHJvdmlkZXJ9IGJ5IHJhaXNpbmcgYW4gZXZlbnQgaWYgaXQgaGFzIGFueSBsaXN0ZW5lcnMsIG9yIGJ5XG4gKiBsb2dnaW5nIHRoZSBlcnJvciB0byB0aGUgY29uc29sZSBpZiB0aGUgZXZlbnQgaGFzIG5vIGxpc3RlbmVycy4gIFRoaXMgbWV0aG9kIGFsc28gdHJhY2tzIHRoZSBudW1iZXJcbiAqIG9mIHRpbWVzIHRoZSBvcGVyYXRpb24gaGFzIGJlZW4gcmV0cmllZCBhbmQgd2lsbCBhdXRvbWF0aWNhbGx5IHJldHJ5IGlmIHJlcXVlc3RlZCB0byBkbyBzbyBieSB0aGVcbiAqIGV2ZW50IGxpc3RlbmVycy5cbiAqXG4gKiBAcGFyYW0ge1RpbGVQcm92aWRlckVycm9yfSBwcmV2aW91c0Vycm9yIFRoZSBlcnJvciBpbnN0YW5jZSByZXR1cm5lZCBieSB0aGlzIGZ1bmN0aW9uIHRoZSBsYXN0XG4gKiAgICAgICAgdGltZSBpdCB3YXMgY2FsbGVkIGZvciB0aGlzIGVycm9yLCBvciB1bmRlZmluZWQgaWYgdGhpcyBpcyB0aGUgZmlyc3QgdGltZSB0aGlzIGVycm9yIGhhc1xuICogICAgICAgIG9jY3VycmVkLlxuICogQHBhcmFtIHtJbWFnZXJ5UHJvdmlkZXJ8VGVycmFpblByb3ZpZGVyfSBwcm92aWRlciBUaGUgaW1hZ2VyeSBvciB0ZXJyYWluIHByb3ZpZGVyIHRoYXQgZW5jb3VudGVyZWQgdGhlIGVycm9yLlxuICogQHBhcmFtIHtFdmVudH0gZXZlbnQgVGhlIGV2ZW50IHRvIHJhaXNlIHRvIGluZm9ybSBsaXN0ZW5lcnMgb2YgdGhlIGVycm9yLlxuICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2UgVGhlIG1lc3NhZ2UgZGVzY3JpYmluZyB0aGUgZXJyb3IuXG4gKiBAcGFyYW0ge051bWJlcn0geCBUaGUgWCBjb29yZGluYXRlIG9mIHRoZSB0aWxlIHRoYXQgZXhwZXJpZW5jZWQgdGhlIGVycm9yLCBvciB1bmRlZmluZWQgaWYgdGhlXG4gKiAgICAgICAgZXJyb3IgaXMgbm90IHNwZWNpZmljIHRvIGEgcGFydGljdWxhciB0aWxlLlxuICogQHBhcmFtIHtOdW1iZXJ9IHkgVGhlIFkgY29vcmRpbmF0ZSBvZiB0aGUgdGlsZSB0aGF0IGV4cGVyaWVuY2VkIHRoZSBlcnJvciwgb3IgdW5kZWZpbmVkIGlmIHRoZVxuICogICAgICAgIGVycm9yIGlzIG5vdCBzcGVjaWZpYyB0byBhIHBhcnRpY3VsYXIgdGlsZS5cbiAqIEBwYXJhbSB7TnVtYmVyfSBsZXZlbCBUaGUgbGV2ZWwtb2YtZGV0YWlsIG9mIHRoZSB0aWxlIHRoYXQgZXhwZXJpZW5jZWQgdGhlIGVycm9yLCBvciB1bmRlZmluZWQgaWYgdGhlXG4gKiAgICAgICAgZXJyb3IgaXMgbm90IHNwZWNpZmljIHRvIGEgcGFydGljdWxhciB0aWxlLlxuICogQHBhcmFtIHtUaWxlUHJvdmlkZXJFcnJvci5SZXRyeUZ1bmN0aW9ufSByZXRyeUZ1bmN0aW9uIFRoZSBmdW5jdGlvbiB0byBjYWxsIHRvIHJldHJ5IHRoZSBvcGVyYXRpb24uICBJZiB1bmRlZmluZWQsIHRoZVxuICogICAgICAgIG9wZXJhdGlvbiB3aWxsIG5vdCBiZSByZXRyaWVkLlxuICogQHBhcmFtIHtFcnJvcn0gW2Vycm9yRGV0YWlsc10gVGhlIGVycm9yIG9yIGV4Y2VwdGlvbiB0aGF0IG9jY3VycmVkLCBpZiBhbnkuXG4gKiBAcmV0dXJucyB7VGlsZVByb3ZpZGVyRXJyb3J9IFRoZSBlcnJvciBpbnN0YW5jZSB0aGF0IHdhcyBwYXNzZWQgdG8gdGhlIGV2ZW50IGxpc3RlbmVycyBhbmQgdGhhdFxuICogICAgICAgICAgc2hvdWxkIGJlIHBhc3NlZCB0byB0aGlzIGZ1bmN0aW9uIHRoZSBuZXh0IHRpbWUgaXQgaXMgY2FsbGVkIGZvciB0aGUgc2FtZSBlcnJvciBpbiBvcmRlclxuICogICAgICAgICAgdG8gdHJhY2sgcmV0cnkgY291bnRzLlxuICovXG5UaWxlUHJvdmlkZXJFcnJvci5oYW5kbGVFcnJvciA9IGZ1bmN0aW9uIChcbiAgcHJldmlvdXNFcnJvcixcbiAgcHJvdmlkZXIsXG4gIGV2ZW50LFxuICBtZXNzYWdlLFxuICB4LFxuICB5LFxuICBsZXZlbCxcbiAgcmV0cnlGdW5jdGlvbixcbiAgZXJyb3JEZXRhaWxzXG4pIHtcbiAgdmFyIGVycm9yID0gcHJldmlvdXNFcnJvcjtcbiAgaWYgKCFkZWZpbmVkKHByZXZpb3VzRXJyb3IpKSB7XG4gICAgZXJyb3IgPSBuZXcgVGlsZVByb3ZpZGVyRXJyb3IoXG4gICAgICBwcm92aWRlcixcbiAgICAgIG1lc3NhZ2UsXG4gICAgICB4LFxuICAgICAgeSxcbiAgICAgIGxldmVsLFxuICAgICAgMCxcbiAgICAgIGVycm9yRGV0YWlsc1xuICAgICk7XG4gIH0gZWxzZSB7XG4gICAgZXJyb3IucHJvdmlkZXIgPSBwcm92aWRlcjtcbiAgICBlcnJvci5tZXNzYWdlID0gbWVzc2FnZTtcbiAgICBlcnJvci54ID0geDtcbiAgICBlcnJvci55ID0geTtcbiAgICBlcnJvci5sZXZlbCA9IGxldmVsO1xuICAgIGVycm9yLnJldHJ5ID0gZmFsc2U7XG4gICAgZXJyb3IuZXJyb3IgPSBlcnJvckRldGFpbHM7XG4gICAgKytlcnJvci50aW1lc1JldHJpZWQ7XG4gIH1cblxuICBpZiAoZXZlbnQubnVtYmVyT2ZMaXN0ZW5lcnMgPiAwKSB7XG4gICAgZXZlbnQucmFpc2VFdmVudChlcnJvcik7XG4gIH0gZWxzZSB7XG4gICAgY29uc29sZS5sb2coXG4gICAgICAnQW4gZXJyb3Igb2NjdXJyZWQgaW4gXCInICtcbiAgICAgICAgcHJvdmlkZXIuY29uc3RydWN0b3IubmFtZSArXG4gICAgICAgICdcIjogJyArXG4gICAgICAgIGZvcm1hdEVycm9yKG1lc3NhZ2UpXG4gICAgKTtcbiAgfVxuXG4gIGlmIChlcnJvci5yZXRyeSAmJiBkZWZpbmVkKHJldHJ5RnVuY3Rpb24pKSB7XG4gICAgcmV0cnlGdW5jdGlvbigpO1xuICB9XG5cbiAgcmV0dXJuIGVycm9yO1xufTtcblxuLyoqXG4gKiBIYW5kbGVzIHN1Y2Nlc3Mgb2YgYW4gb3BlcmF0aW9uIGJ5IHJlc2V0dGluZyB0aGUgcmV0cnkgY291bnQgb2YgYSBwcmV2aW91cyBlcnJvciwgaWYgYW55LiAgVGhpcyB3YXksXG4gKiBpZiB0aGUgZXJyb3Igb2NjdXJzIGFnYWluIGluIHRoZSBmdXR1cmUsIHRoZSBsaXN0ZW5lcnMgd2lsbCBiZSBpbmZvcm1lZCB0aGF0IGl0IGhhcyBub3QgeWV0IGJlZW4gcmV0cmllZC5cbiAqXG4gKiBAcGFyYW0ge1RpbGVQcm92aWRlckVycm9yfSBwcmV2aW91c0Vycm9yIFRoZSBwcmV2aW91cyBlcnJvciwgb3IgdW5kZWZpbmVkIGlmIHRoaXMgb3BlcmF0aW9uIGhhc1xuICogICAgICAgIG5vdCBwcmV2aW91c2x5IHJlc3VsdGVkIGluIGFuIGVycm9yLlxuICovXG5UaWxlUHJvdmlkZXJFcnJvci5oYW5kbGVTdWNjZXNzID0gZnVuY3Rpb24gKHByZXZpb3VzRXJyb3IpIHtcbiAgaWYgKGRlZmluZWQocHJldmlvdXNFcnJvcikpIHtcbiAgICBwcmV2aW91c0Vycm9yLnRpbWVzUmV0cmllZCA9IC0xO1xuICB9XG59O1xuXG4vKipcbiAqIEEgZnVuY3Rpb24gdGhhdCB3aWxsIGJlIGNhbGxlZCB0byByZXRyeSB0aGUgb3BlcmF0aW9uLlxuICogQGNhbGxiYWNrIFRpbGVQcm92aWRlckVycm9yLlJldHJ5RnVuY3Rpb25cbiAqL1xuZXhwb3J0IGRlZmF1bHQgVGlsZVByb3ZpZGVyRXJyb3I7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///9121\n')},13829:function(__unused_webpack___webpack_module__,__unused_webpack___webpack_exports__,__webpack_require__){eval('/* harmony import */ var _DeveloperError_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(12572);\n\n\n/**\n * A tiling scheme for geometry or imagery on the surface of an ellipsoid.  At level-of-detail zero,\n * the coarsest, least-detailed level, the number of tiles is configurable.\n * At level of detail one, each of the level zero tiles has four children, two in each direction.\n * At level of detail two, each of the level one tiles has four children, two in each direction.\n * This continues for as many levels as are present in the geometry or imagery source.\n *\n * @alias TilingScheme\n * @constructor\n *\n * @see WebMercatorTilingScheme\n * @see GeographicTilingScheme\n */\nfunction TilingScheme(options) {\n  //>>includeStart(\'debug\', pragmas.debug);\n  throw new _DeveloperError_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .Z(\n    "This type should not be instantiated directly.  Instead, use WebMercatorTilingScheme or GeographicTilingScheme."\n  );\n  //>>includeEnd(\'debug\');\n}\n\nObject.defineProperties(TilingScheme.prototype, {\n  /**\n   * Gets the ellipsoid that is tiled by the tiling scheme.\n   * @memberof TilingScheme.prototype\n   * @type {Ellipsoid}\n   */\n  ellipsoid: {\n    get: _DeveloperError_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].throwInstantiationError */ .Z.throwInstantiationError,\n  },\n\n  /**\n   * Gets the rectangle, in radians, covered by this tiling scheme.\n   * @memberof TilingScheme.prototype\n   * @type {Rectangle}\n   */\n  rectangle: {\n    get: _DeveloperError_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].throwInstantiationError */ .Z.throwInstantiationError,\n  },\n\n  /**\n   * Gets the map projection used by the tiling scheme.\n   * @memberof TilingScheme.prototype\n   * @type {MapProjection}\n   */\n  projection: {\n    get: _DeveloperError_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].throwInstantiationError */ .Z.throwInstantiationError,\n  },\n});\n\n/**\n * Gets the total number of tiles in the X direction at a specified level-of-detail.\n * @function\n *\n * @param {Number} level The level-of-detail.\n * @returns {Number} The number of tiles in the X direction at the given level.\n */\nTilingScheme.prototype.getNumberOfXTilesAtLevel =\n  _DeveloperError_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].throwInstantiationError */ .Z.throwInstantiationError;\n\n/**\n * Gets the total number of tiles in the Y direction at a specified level-of-detail.\n * @function\n *\n * @param {Number} level The level-of-detail.\n * @returns {Number} The number of tiles in the Y direction at the given level.\n */\nTilingScheme.prototype.getNumberOfYTilesAtLevel =\n  _DeveloperError_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].throwInstantiationError */ .Z.throwInstantiationError;\n\n/**\n * Transforms a rectangle specified in geodetic radians to the native coordinate system\n * of this tiling scheme.\n * @function\n *\n * @param {Rectangle} rectangle The rectangle to transform.\n * @param {Rectangle} [result] The instance to which to copy the result, or undefined if a new instance\n *        should be created.\n * @returns {Rectangle} The specified \'result\', or a new object containing the native rectangle if \'result\'\n *          is undefined.\n */\nTilingScheme.prototype.rectangleToNativeRectangle =\n  _DeveloperError_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].throwInstantiationError */ .Z.throwInstantiationError;\n\n/**\n * Converts tile x, y coordinates and level to a rectangle expressed in the native coordinates\n * of the tiling scheme.\n * @function\n *\n * @param {Number} x The integer x coordinate of the tile.\n * @param {Number} y The integer y coordinate of the tile.\n * @param {Number} level The tile level-of-detail.  Zero is the least detailed.\n * @param {Object} [result] The instance to which to copy the result, or undefined if a new instance\n *        should be created.\n * @returns {Rectangle} The specified \'result\', or a new object containing the rectangle\n *          if \'result\' is undefined.\n */\nTilingScheme.prototype.tileXYToNativeRectangle =\n  _DeveloperError_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].throwInstantiationError */ .Z.throwInstantiationError;\n\n/**\n * Converts tile x, y coordinates and level to a cartographic rectangle in radians.\n * @function\n *\n * @param {Number} x The integer x coordinate of the tile.\n * @param {Number} y The integer y coordinate of the tile.\n * @param {Number} level The tile level-of-detail.  Zero is the least detailed.\n * @param {Object} [result] The instance to which to copy the result, or undefined if a new instance\n *        should be created.\n * @returns {Rectangle} The specified \'result\', or a new object containing the rectangle\n *          if \'result\' is undefined.\n */\nTilingScheme.prototype.tileXYToRectangle =\n  _DeveloperError_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].throwInstantiationError */ .Z.throwInstantiationError;\n\n/**\n * Calculates the tile x, y coordinates of the tile containing\n * a given cartographic position.\n * @function\n *\n * @param {Cartographic} position The position.\n * @param {Number} level The tile level-of-detail.  Zero is the least detailed.\n * @param {Cartesian2} [result] The instance to which to copy the result, or undefined if a new instance\n *        should be created.\n * @returns {Cartesian2} The specified \'result\', or a new object containing the tile x, y coordinates\n *          if \'result\' is undefined.\n */\nTilingScheme.prototype.positionToTileXY =\n  _DeveloperError_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].throwInstantiationError */ .Z.throwInstantiationError;\n/* unused harmony default export */ var __WEBPACK_DEFAULT_EXPORT__ = ((/* unused pure expression or super */ null && (TilingScheme)));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTM4MjkuanMiLCJtYXBwaW5ncyI6IjtBQUFpRDs7QUFFakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxtRUFBYztBQUMxQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0EsU0FBUyxtSEFBc0M7QUFDL0MsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBLFNBQVMsbUhBQXNDO0FBQy9DLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQSxTQUFTLG1IQUFzQztBQUMvQyxHQUFHO0FBQ0gsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBLEVBQUUsbUhBQXNDOztBQUV4QztBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBLEVBQUUsbUhBQXNDOztBQUV4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxXQUFXO0FBQ3RCLFdBQVcsV0FBVztBQUN0QjtBQUNBLGFBQWEsV0FBVztBQUN4QjtBQUNBO0FBQ0E7QUFDQSxFQUFFLG1IQUFzQzs7QUFFeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQjtBQUNBLGFBQWEsV0FBVztBQUN4QjtBQUNBO0FBQ0E7QUFDQSxFQUFFLG1IQUFzQzs7QUFFeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkI7QUFDQSxhQUFhLFdBQVc7QUFDeEI7QUFDQTtBQUNBO0FBQ0EsRUFBRSxtSEFBc0M7O0FBRXhDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGNBQWM7QUFDekIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsWUFBWTtBQUN2QjtBQUNBLGFBQWEsWUFBWTtBQUN6QjtBQUNBO0FBQ0E7QUFDQSxFQUFFLG1IQUFzQztBQUN4QyxzRUFBZSw0REFBWSxJQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdnVlMy13ZWJwYWNrNS8uL25vZGVfbW9kdWxlcy9jZXNpdW0vU291cmNlL0NvcmUvVGlsaW5nU2NoZW1lLmpzP2IwOWIiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IERldmVsb3BlckVycm9yIGZyb20gXCIuL0RldmVsb3BlckVycm9yLmpzXCI7XG5cbi8qKlxuICogQSB0aWxpbmcgc2NoZW1lIGZvciBnZW9tZXRyeSBvciBpbWFnZXJ5IG9uIHRoZSBzdXJmYWNlIG9mIGFuIGVsbGlwc29pZC4gIEF0IGxldmVsLW9mLWRldGFpbCB6ZXJvLFxuICogdGhlIGNvYXJzZXN0LCBsZWFzdC1kZXRhaWxlZCBsZXZlbCwgdGhlIG51bWJlciBvZiB0aWxlcyBpcyBjb25maWd1cmFibGUuXG4gKiBBdCBsZXZlbCBvZiBkZXRhaWwgb25lLCBlYWNoIG9mIHRoZSBsZXZlbCB6ZXJvIHRpbGVzIGhhcyBmb3VyIGNoaWxkcmVuLCB0d28gaW4gZWFjaCBkaXJlY3Rpb24uXG4gKiBBdCBsZXZlbCBvZiBkZXRhaWwgdHdvLCBlYWNoIG9mIHRoZSBsZXZlbCBvbmUgdGlsZXMgaGFzIGZvdXIgY2hpbGRyZW4sIHR3byBpbiBlYWNoIGRpcmVjdGlvbi5cbiAqIFRoaXMgY29udGludWVzIGZvciBhcyBtYW55IGxldmVscyBhcyBhcmUgcHJlc2VudCBpbiB0aGUgZ2VvbWV0cnkgb3IgaW1hZ2VyeSBzb3VyY2UuXG4gKlxuICogQGFsaWFzIFRpbGluZ1NjaGVtZVxuICogQGNvbnN0cnVjdG9yXG4gKlxuICogQHNlZSBXZWJNZXJjYXRvclRpbGluZ1NjaGVtZVxuICogQHNlZSBHZW9ncmFwaGljVGlsaW5nU2NoZW1lXG4gKi9cbmZ1bmN0aW9uIFRpbGluZ1NjaGVtZShvcHRpb25zKSB7XG4gIC8vPj5pbmNsdWRlU3RhcnQoJ2RlYnVnJywgcHJhZ21hcy5kZWJ1Zyk7XG4gIHRocm93IG5ldyBEZXZlbG9wZXJFcnJvcihcbiAgICBcIlRoaXMgdHlwZSBzaG91bGQgbm90IGJlIGluc3RhbnRpYXRlZCBkaXJlY3RseS4gIEluc3RlYWQsIHVzZSBXZWJNZXJjYXRvclRpbGluZ1NjaGVtZSBvciBHZW9ncmFwaGljVGlsaW5nU2NoZW1lLlwiXG4gICk7XG4gIC8vPj5pbmNsdWRlRW5kKCdkZWJ1ZycpO1xufVxuXG5PYmplY3QuZGVmaW5lUHJvcGVydGllcyhUaWxpbmdTY2hlbWUucHJvdG90eXBlLCB7XG4gIC8qKlxuICAgKiBHZXRzIHRoZSBlbGxpcHNvaWQgdGhhdCBpcyB0aWxlZCBieSB0aGUgdGlsaW5nIHNjaGVtZS5cbiAgICogQG1lbWJlcm9mIFRpbGluZ1NjaGVtZS5wcm90b3R5cGVcbiAgICogQHR5cGUge0VsbGlwc29pZH1cbiAgICovXG4gIGVsbGlwc29pZDoge1xuICAgIGdldDogRGV2ZWxvcGVyRXJyb3IudGhyb3dJbnN0YW50aWF0aW9uRXJyb3IsXG4gIH0sXG5cbiAgLyoqXG4gICAqIEdldHMgdGhlIHJlY3RhbmdsZSwgaW4gcmFkaWFucywgY292ZXJlZCBieSB0aGlzIHRpbGluZyBzY2hlbWUuXG4gICAqIEBtZW1iZXJvZiBUaWxpbmdTY2hlbWUucHJvdG90eXBlXG4gICAqIEB0eXBlIHtSZWN0YW5nbGV9XG4gICAqL1xuICByZWN0YW5nbGU6IHtcbiAgICBnZXQ6IERldmVsb3BlckVycm9yLnRocm93SW5zdGFudGlhdGlvbkVycm9yLFxuICB9LFxuXG4gIC8qKlxuICAgKiBHZXRzIHRoZSBtYXAgcHJvamVjdGlvbiB1c2VkIGJ5IHRoZSB0aWxpbmcgc2NoZW1lLlxuICAgKiBAbWVtYmVyb2YgVGlsaW5nU2NoZW1lLnByb3RvdHlwZVxuICAgKiBAdHlwZSB7TWFwUHJvamVjdGlvbn1cbiAgICovXG4gIHByb2plY3Rpb246IHtcbiAgICBnZXQ6IERldmVsb3BlckVycm9yLnRocm93SW5zdGFudGlhdGlvbkVycm9yLFxuICB9LFxufSk7XG5cbi8qKlxuICogR2V0cyB0aGUgdG90YWwgbnVtYmVyIG9mIHRpbGVzIGluIHRoZSBYIGRpcmVjdGlvbiBhdCBhIHNwZWNpZmllZCBsZXZlbC1vZi1kZXRhaWwuXG4gKiBAZnVuY3Rpb25cbiAqXG4gKiBAcGFyYW0ge051bWJlcn0gbGV2ZWwgVGhlIGxldmVsLW9mLWRldGFpbC5cbiAqIEByZXR1cm5zIHtOdW1iZXJ9IFRoZSBudW1iZXIgb2YgdGlsZXMgaW4gdGhlIFggZGlyZWN0aW9uIGF0IHRoZSBnaXZlbiBsZXZlbC5cbiAqL1xuVGlsaW5nU2NoZW1lLnByb3RvdHlwZS5nZXROdW1iZXJPZlhUaWxlc0F0TGV2ZWwgPVxuICBEZXZlbG9wZXJFcnJvci50aHJvd0luc3RhbnRpYXRpb25FcnJvcjtcblxuLyoqXG4gKiBHZXRzIHRoZSB0b3RhbCBudW1iZXIgb2YgdGlsZXMgaW4gdGhlIFkgZGlyZWN0aW9uIGF0IGEgc3BlY2lmaWVkIGxldmVsLW9mLWRldGFpbC5cbiAqIEBmdW5jdGlvblxuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSBsZXZlbCBUaGUgbGV2ZWwtb2YtZGV0YWlsLlxuICogQHJldHVybnMge051bWJlcn0gVGhlIG51bWJlciBvZiB0aWxlcyBpbiB0aGUgWSBkaXJlY3Rpb24gYXQgdGhlIGdpdmVuIGxldmVsLlxuICovXG5UaWxpbmdTY2hlbWUucHJvdG90eXBlLmdldE51bWJlck9mWVRpbGVzQXRMZXZlbCA9XG4gIERldmVsb3BlckVycm9yLnRocm93SW5zdGFudGlhdGlvbkVycm9yO1xuXG4vKipcbiAqIFRyYW5zZm9ybXMgYSByZWN0YW5nbGUgc3BlY2lmaWVkIGluIGdlb2RldGljIHJhZGlhbnMgdG8gdGhlIG5hdGl2ZSBjb29yZGluYXRlIHN5c3RlbVxuICogb2YgdGhpcyB0aWxpbmcgc2NoZW1lLlxuICogQGZ1bmN0aW9uXG4gKlxuICogQHBhcmFtIHtSZWN0YW5nbGV9IHJlY3RhbmdsZSBUaGUgcmVjdGFuZ2xlIHRvIHRyYW5zZm9ybS5cbiAqIEBwYXJhbSB7UmVjdGFuZ2xlfSBbcmVzdWx0XSBUaGUgaW5zdGFuY2UgdG8gd2hpY2ggdG8gY29weSB0aGUgcmVzdWx0LCBvciB1bmRlZmluZWQgaWYgYSBuZXcgaW5zdGFuY2VcbiAqICAgICAgICBzaG91bGQgYmUgY3JlYXRlZC5cbiAqIEByZXR1cm5zIHtSZWN0YW5nbGV9IFRoZSBzcGVjaWZpZWQgJ3Jlc3VsdCcsIG9yIGEgbmV3IG9iamVjdCBjb250YWluaW5nIHRoZSBuYXRpdmUgcmVjdGFuZ2xlIGlmICdyZXN1bHQnXG4gKiAgICAgICAgICBpcyB1bmRlZmluZWQuXG4gKi9cblRpbGluZ1NjaGVtZS5wcm90b3R5cGUucmVjdGFuZ2xlVG9OYXRpdmVSZWN0YW5nbGUgPVxuICBEZXZlbG9wZXJFcnJvci50aHJvd0luc3RhbnRpYXRpb25FcnJvcjtcblxuLyoqXG4gKiBDb252ZXJ0cyB0aWxlIHgsIHkgY29vcmRpbmF0ZXMgYW5kIGxldmVsIHRvIGEgcmVjdGFuZ2xlIGV4cHJlc3NlZCBpbiB0aGUgbmF0aXZlIGNvb3JkaW5hdGVzXG4gKiBvZiB0aGUgdGlsaW5nIHNjaGVtZS5cbiAqIEBmdW5jdGlvblxuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSB4IFRoZSBpbnRlZ2VyIHggY29vcmRpbmF0ZSBvZiB0aGUgdGlsZS5cbiAqIEBwYXJhbSB7TnVtYmVyfSB5IFRoZSBpbnRlZ2VyIHkgY29vcmRpbmF0ZSBvZiB0aGUgdGlsZS5cbiAqIEBwYXJhbSB7TnVtYmVyfSBsZXZlbCBUaGUgdGlsZSBsZXZlbC1vZi1kZXRhaWwuICBaZXJvIGlzIHRoZSBsZWFzdCBkZXRhaWxlZC5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbcmVzdWx0XSBUaGUgaW5zdGFuY2UgdG8gd2hpY2ggdG8gY29weSB0aGUgcmVzdWx0LCBvciB1bmRlZmluZWQgaWYgYSBuZXcgaW5zdGFuY2VcbiAqICAgICAgICBzaG91bGQgYmUgY3JlYXRlZC5cbiAqIEByZXR1cm5zIHtSZWN0YW5nbGV9IFRoZSBzcGVjaWZpZWQgJ3Jlc3VsdCcsIG9yIGEgbmV3IG9iamVjdCBjb250YWluaW5nIHRoZSByZWN0YW5nbGVcbiAqICAgICAgICAgIGlmICdyZXN1bHQnIGlzIHVuZGVmaW5lZC5cbiAqL1xuVGlsaW5nU2NoZW1lLnByb3RvdHlwZS50aWxlWFlUb05hdGl2ZVJlY3RhbmdsZSA9XG4gIERldmVsb3BlckVycm9yLnRocm93SW5zdGFudGlhdGlvbkVycm9yO1xuXG4vKipcbiAqIENvbnZlcnRzIHRpbGUgeCwgeSBjb29yZGluYXRlcyBhbmQgbGV2ZWwgdG8gYSBjYXJ0b2dyYXBoaWMgcmVjdGFuZ2xlIGluIHJhZGlhbnMuXG4gKiBAZnVuY3Rpb25cbiAqXG4gKiBAcGFyYW0ge051bWJlcn0geCBUaGUgaW50ZWdlciB4IGNvb3JkaW5hdGUgb2YgdGhlIHRpbGUuXG4gKiBAcGFyYW0ge051bWJlcn0geSBUaGUgaW50ZWdlciB5IGNvb3JkaW5hdGUgb2YgdGhlIHRpbGUuXG4gKiBAcGFyYW0ge051bWJlcn0gbGV2ZWwgVGhlIHRpbGUgbGV2ZWwtb2YtZGV0YWlsLiAgWmVybyBpcyB0aGUgbGVhc3QgZGV0YWlsZWQuXG4gKiBAcGFyYW0ge09iamVjdH0gW3Jlc3VsdF0gVGhlIGluc3RhbmNlIHRvIHdoaWNoIHRvIGNvcHkgdGhlIHJlc3VsdCwgb3IgdW5kZWZpbmVkIGlmIGEgbmV3IGluc3RhbmNlXG4gKiAgICAgICAgc2hvdWxkIGJlIGNyZWF0ZWQuXG4gKiBAcmV0dXJucyB7UmVjdGFuZ2xlfSBUaGUgc3BlY2lmaWVkICdyZXN1bHQnLCBvciBhIG5ldyBvYmplY3QgY29udGFpbmluZyB0aGUgcmVjdGFuZ2xlXG4gKiAgICAgICAgICBpZiAncmVzdWx0JyBpcyB1bmRlZmluZWQuXG4gKi9cblRpbGluZ1NjaGVtZS5wcm90b3R5cGUudGlsZVhZVG9SZWN0YW5nbGUgPVxuICBEZXZlbG9wZXJFcnJvci50aHJvd0luc3RhbnRpYXRpb25FcnJvcjtcblxuLyoqXG4gKiBDYWxjdWxhdGVzIHRoZSB0aWxlIHgsIHkgY29vcmRpbmF0ZXMgb2YgdGhlIHRpbGUgY29udGFpbmluZ1xuICogYSBnaXZlbiBjYXJ0b2dyYXBoaWMgcG9zaXRpb24uXG4gKiBAZnVuY3Rpb25cbiAqXG4gKiBAcGFyYW0ge0NhcnRvZ3JhcGhpY30gcG9zaXRpb24gVGhlIHBvc2l0aW9uLlxuICogQHBhcmFtIHtOdW1iZXJ9IGxldmVsIFRoZSB0aWxlIGxldmVsLW9mLWRldGFpbC4gIFplcm8gaXMgdGhlIGxlYXN0IGRldGFpbGVkLlxuICogQHBhcmFtIHtDYXJ0ZXNpYW4yfSBbcmVzdWx0XSBUaGUgaW5zdGFuY2UgdG8gd2hpY2ggdG8gY29weSB0aGUgcmVzdWx0LCBvciB1bmRlZmluZWQgaWYgYSBuZXcgaW5zdGFuY2VcbiAqICAgICAgICBzaG91bGQgYmUgY3JlYXRlZC5cbiAqIEByZXR1cm5zIHtDYXJ0ZXNpYW4yfSBUaGUgc3BlY2lmaWVkICdyZXN1bHQnLCBvciBhIG5ldyBvYmplY3QgY29udGFpbmluZyB0aGUgdGlsZSB4LCB5IGNvb3JkaW5hdGVzXG4gKiAgICAgICAgICBpZiAncmVzdWx0JyBpcyB1bmRlZmluZWQuXG4gKi9cblRpbGluZ1NjaGVtZS5wcm90b3R5cGUucG9zaXRpb25Ub1RpbGVYWSA9XG4gIERldmVsb3BlckVycm9yLnRocm93SW5zdGFudGlhdGlvbkVycm9yO1xuZXhwb3J0IGRlZmF1bHQgVGlsaW5nU2NoZW1lO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///13829\n')},4877:function(__unused_webpack___webpack_module__,__webpack_exports__){eval('/**\n * Constants for time conversions like those done by {@link JulianDate}.\n *\n * @namespace TimeConstants\n *\n * @see JulianDate\n *\n * @private\n */\nvar TimeConstants = {\n  /**\n   * The number of seconds in one millisecond: <code>0.001</code>\n   * @type {Number}\n   * @constant\n   */\n  SECONDS_PER_MILLISECOND: 0.001,\n\n  /**\n   * The number of seconds in one minute: <code>60</code>.\n   * @type {Number}\n   * @constant\n   */\n  SECONDS_PER_MINUTE: 60.0,\n\n  /**\n   * The number of minutes in one hour: <code>60</code>.\n   * @type {Number}\n   * @constant\n   */\n  MINUTES_PER_HOUR: 60.0,\n\n  /**\n   * The number of hours in one day: <code>24</code>.\n   * @type {Number}\n   * @constant\n   */\n  HOURS_PER_DAY: 24.0,\n\n  /**\n   * The number of seconds in one hour: <code>3600</code>.\n   * @type {Number}\n   * @constant\n   */\n  SECONDS_PER_HOUR: 3600.0,\n\n  /**\n   * The number of minutes in one day: <code>1440</code>.\n   * @type {Number}\n   * @constant\n   */\n  MINUTES_PER_DAY: 1440.0,\n\n  /**\n   * The number of seconds in one day, ignoring leap seconds: <code>86400</code>.\n   * @type {Number}\n   * @constant\n   */\n  SECONDS_PER_DAY: 86400.0,\n\n  /**\n   * The number of days in one Julian century: <code>36525</code>.\n   * @type {Number}\n   * @constant\n   */\n  DAYS_PER_JULIAN_CENTURY: 36525.0,\n\n  /**\n   * One trillionth of a second.\n   * @type {Number}\n   * @constant\n   */\n  PICOSECOND: 0.000000001,\n\n  /**\n   * The number of days to subtract from a Julian date to determine the\n   * modified Julian date, which gives the number of days since midnight\n   * on November 17, 1858.\n   * @type {Number}\n   * @constant\n   */\n  MODIFIED_JULIAN_DATE_DIFFERENCE: 2400000.5,\n};\n/* harmony default export */ __webpack_exports__["Z"] = (Object.freeze(TimeConstants));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNDg3Ny5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBLHNEQUFzRCxpQkFBaUI7QUFDdkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseURBQWUsNEJBQTRCLEVBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly92dWUzLXdlYnBhY2s1Ly4vbm9kZV9tb2R1bGVzL2Nlc2l1bS9Tb3VyY2UvQ29yZS9UaW1lQ29uc3RhbnRzLmpzPzRlMjEiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBDb25zdGFudHMgZm9yIHRpbWUgY29udmVyc2lvbnMgbGlrZSB0aG9zZSBkb25lIGJ5IHtAbGluayBKdWxpYW5EYXRlfS5cbiAqXG4gKiBAbmFtZXNwYWNlIFRpbWVDb25zdGFudHNcbiAqXG4gKiBAc2VlIEp1bGlhbkRhdGVcbiAqXG4gKiBAcHJpdmF0ZVxuICovXG52YXIgVGltZUNvbnN0YW50cyA9IHtcbiAgLyoqXG4gICAqIFRoZSBudW1iZXIgb2Ygc2Vjb25kcyBpbiBvbmUgbWlsbGlzZWNvbmQ6IDxjb2RlPjAuMDAxPC9jb2RlPlxuICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgKiBAY29uc3RhbnRcbiAgICovXG4gIFNFQ09ORFNfUEVSX01JTExJU0VDT05EOiAwLjAwMSxcblxuICAvKipcbiAgICogVGhlIG51bWJlciBvZiBzZWNvbmRzIGluIG9uZSBtaW51dGU6IDxjb2RlPjYwPC9jb2RlPi5cbiAgICogQHR5cGUge051bWJlcn1cbiAgICogQGNvbnN0YW50XG4gICAqL1xuICBTRUNPTkRTX1BFUl9NSU5VVEU6IDYwLjAsXG5cbiAgLyoqXG4gICAqIFRoZSBudW1iZXIgb2YgbWludXRlcyBpbiBvbmUgaG91cjogPGNvZGU+NjA8L2NvZGU+LlxuICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgKiBAY29uc3RhbnRcbiAgICovXG4gIE1JTlVURVNfUEVSX0hPVVI6IDYwLjAsXG5cbiAgLyoqXG4gICAqIFRoZSBudW1iZXIgb2YgaG91cnMgaW4gb25lIGRheTogPGNvZGU+MjQ8L2NvZGU+LlxuICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgKiBAY29uc3RhbnRcbiAgICovXG4gIEhPVVJTX1BFUl9EQVk6IDI0LjAsXG5cbiAgLyoqXG4gICAqIFRoZSBudW1iZXIgb2Ygc2Vjb25kcyBpbiBvbmUgaG91cjogPGNvZGU+MzYwMDwvY29kZT4uXG4gICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAqIEBjb25zdGFudFxuICAgKi9cbiAgU0VDT05EU19QRVJfSE9VUjogMzYwMC4wLFxuXG4gIC8qKlxuICAgKiBUaGUgbnVtYmVyIG9mIG1pbnV0ZXMgaW4gb25lIGRheTogPGNvZGU+MTQ0MDwvY29kZT4uXG4gICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAqIEBjb25zdGFudFxuICAgKi9cbiAgTUlOVVRFU19QRVJfREFZOiAxNDQwLjAsXG5cbiAgLyoqXG4gICAqIFRoZSBudW1iZXIgb2Ygc2Vjb25kcyBpbiBvbmUgZGF5LCBpZ25vcmluZyBsZWFwIHNlY29uZHM6IDxjb2RlPjg2NDAwPC9jb2RlPi5cbiAgICogQHR5cGUge051bWJlcn1cbiAgICogQGNvbnN0YW50XG4gICAqL1xuICBTRUNPTkRTX1BFUl9EQVk6IDg2NDAwLjAsXG5cbiAgLyoqXG4gICAqIFRoZSBudW1iZXIgb2YgZGF5cyBpbiBvbmUgSnVsaWFuIGNlbnR1cnk6IDxjb2RlPjM2NTI1PC9jb2RlPi5cbiAgICogQHR5cGUge051bWJlcn1cbiAgICogQGNvbnN0YW50XG4gICAqL1xuICBEQVlTX1BFUl9KVUxJQU5fQ0VOVFVSWTogMzY1MjUuMCxcblxuICAvKipcbiAgICogT25lIHRyaWxsaW9udGggb2YgYSBzZWNvbmQuXG4gICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAqIEBjb25zdGFudFxuICAgKi9cbiAgUElDT1NFQ09ORDogMC4wMDAwMDAwMDEsXG5cbiAgLyoqXG4gICAqIFRoZSBudW1iZXIgb2YgZGF5cyB0byBzdWJ0cmFjdCBmcm9tIGEgSnVsaWFuIGRhdGUgdG8gZGV0ZXJtaW5lIHRoZVxuICAgKiBtb2RpZmllZCBKdWxpYW4gZGF0ZSwgd2hpY2ggZ2l2ZXMgdGhlIG51bWJlciBvZiBkYXlzIHNpbmNlIG1pZG5pZ2h0XG4gICAqIG9uIE5vdmVtYmVyIDE3LCAxODU4LlxuICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgKiBAY29uc3RhbnRcbiAgICovXG4gIE1PRElGSUVEX0pVTElBTl9EQVRFX0RJRkZFUkVOQ0U6IDI0MDAwMDAuNSxcbn07XG5leHBvcnQgZGVmYXVsdCBPYmplY3QuZnJlZXplKFRpbWVDb25zdGFudHMpO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///4877\n')},77808:function(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__){eval('/* harmony import */ var _Check_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(66553);\n/* harmony import */ var _defaultValue_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(62200);\n/* harmony import */ var _defined_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(82982);\n/* harmony import */ var _DeveloperError_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(12572);\n/* harmony import */ var _JulianDate_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(55293);\n\n\n\n\n\n\n/**\n * An interval defined by a start and a stop time; optionally including those times as part of the interval.\n * Arbitrary data can optionally be associated with each instance for used with {@link TimeIntervalCollection}.\n *\n * @alias TimeInterval\n * @constructor\n *\n * @param {Object} [options] Object with the following properties:\n * @param {JulianDate} [options.start=new JulianDate()] The start time of the interval.\n * @param {JulianDate} [options.stop=new JulianDate()] The stop time of the interval.\n * @param {Boolean} [options.isStartIncluded=true] <code>true</code> if <code>options.start</code> is included in the interval, <code>false</code> otherwise.\n * @param {Boolean} [options.isStopIncluded=true] <code>true</code> if <code>options.stop</code> is included in the interval, <code>false</code> otherwise.\n * @param {Object} [options.data] Arbitrary data associated with this interval.\n *\n * @example\n * // Create an instance that spans August 1st, 1980 and is associated\n * // with a Cartesian position.\n * var timeInterval = new Cesium.TimeInterval({\n *     start : Cesium.JulianDate.fromIso8601(\'1980-08-01T00:00:00Z\'),\n *     stop : Cesium.JulianDate.fromIso8601(\'1980-08-02T00:00:00Z\'),\n *     isStartIncluded : true,\n *     isStopIncluded : false,\n *     data : Cesium.Cartesian3.fromDegrees(39.921037, -75.170082)\n * });\n *\n * @example\n * // Create two instances from ISO 8601 intervals with associated numeric data\n * // then compute their intersection, summing the data they contain.\n * var left = Cesium.TimeInterval.fromIso8601({\n *     iso8601 : \'2000/2010\',\n *     data : 2\n * });\n *\n * var right = Cesium.TimeInterval.fromIso8601({\n *     iso8601 : \'1995/2005\',\n *     data : 3\n * });\n *\n * //The result of the below intersection will be an interval equivalent to\n * //var intersection = Cesium.TimeInterval.fromIso8601({\n * //  iso8601 : \'2000/2005\',\n * //  data : 5\n * //});\n * var intersection = new Cesium.TimeInterval();\n * Cesium.TimeInterval.intersect(left, right, intersection, function(leftData, rightData) {\n *     return leftData + rightData;\n * });\n *\n * @example\n * // Check if an interval contains a specific time.\n * var dateToCheck = Cesium.JulianDate.fromIso8601(\'1982-09-08T11:30:00Z\');\n * var containsDate = Cesium.TimeInterval.contains(timeInterval, dateToCheck);\n */\nfunction TimeInterval(options) {\n  options = (0,_defaultValue_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .Z)(options, _defaultValue_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"].EMPTY_OBJECT */ .Z.EMPTY_OBJECT);\n  /**\n   * Gets or sets the start time of this interval.\n   * @type {JulianDate}\n   */\n  this.start = (0,_defined_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .Z)(options.start)\n    ? _JulianDate_js__WEBPACK_IMPORTED_MODULE_3__/* ["default"].clone */ .Z.clone(options.start)\n    : new _JulianDate_js__WEBPACK_IMPORTED_MODULE_3__/* ["default"] */ .Z();\n\n  /**\n   * Gets or sets the stop time of this interval.\n   * @type {JulianDate}\n   */\n  this.stop = (0,_defined_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .Z)(options.stop)\n    ? _JulianDate_js__WEBPACK_IMPORTED_MODULE_3__/* ["default"].clone */ .Z.clone(options.stop)\n    : new _JulianDate_js__WEBPACK_IMPORTED_MODULE_3__/* ["default"] */ .Z();\n\n  /**\n   * Gets or sets the data associated with this interval.\n   * @type {*}\n   */\n  this.data = options.data;\n\n  /**\n   * Gets or sets whether or not the start time is included in this interval.\n   * @type {Boolean}\n   * @default true\n   */\n  this.isStartIncluded = (0,_defaultValue_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .Z)(options.isStartIncluded, true);\n\n  /**\n   * Gets or sets whether or not the stop time is included in this interval.\n   * @type {Boolean}\n   * @default true\n   */\n  this.isStopIncluded = (0,_defaultValue_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .Z)(options.isStopIncluded, true);\n}\n\nObject.defineProperties(TimeInterval.prototype, {\n  /**\n   * Gets whether or not this interval is empty.\n   * @memberof TimeInterval.prototype\n   * @type {Boolean}\n   * @readonly\n   */\n  isEmpty: {\n    get: function () {\n      var stopComparedToStart = _JulianDate_js__WEBPACK_IMPORTED_MODULE_3__/* ["default"].compare */ .Z.compare(this.stop, this.start);\n      return (\n        stopComparedToStart < 0 ||\n        (stopComparedToStart === 0 &&\n          (!this.isStartIncluded || !this.isStopIncluded))\n      );\n    },\n  },\n});\n\nvar scratchInterval = {\n  start: undefined,\n  stop: undefined,\n  isStartIncluded: undefined,\n  isStopIncluded: undefined,\n  data: undefined,\n};\n\n/**\n * Creates a new instance from a {@link http://en.wikipedia.org/wiki/ISO_8601|ISO 8601} interval.\n *\n * @throws DeveloperError if options.iso8601 does not match proper formatting.\n *\n * @param {Object} options Object with the following properties:\n * @param {String} options.iso8601 An ISO 8601 interval.\n * @param {Boolean} [options.isStartIncluded=true] <code>true</code> if <code>options.start</code> is included in the interval, <code>false</code> otherwise.\n * @param {Boolean} [options.isStopIncluded=true] <code>true</code> if <code>options.stop</code> is included in the interval, <code>false</code> otherwise.\n * @param {Object} [options.data] Arbitrary data associated with this interval.\n * @param {TimeInterval} [result] An existing instance to use for the result.\n * @returns {TimeInterval} The modified result parameter or a new instance if none was provided.\n */\nTimeInterval.fromIso8601 = function (options, result) {\n  //>>includeStart(\'debug\', pragmas.debug);\n  _Check_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].typeOf.object */ .Z.typeOf.object("options", options);\n  _Check_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].typeOf.string */ .Z.typeOf.string("options.iso8601", options.iso8601);\n  //>>includeEnd(\'debug\');\n\n  var dates = options.iso8601.split("/");\n  if (dates.length !== 2) {\n    throw new _DeveloperError_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"] */ .Z(\n      "options.iso8601 is an invalid ISO 8601 interval."\n    );\n  }\n  var start = _JulianDate_js__WEBPACK_IMPORTED_MODULE_3__/* ["default"].fromIso8601 */ .Z.fromIso8601(dates[0]);\n  var stop = _JulianDate_js__WEBPACK_IMPORTED_MODULE_3__/* ["default"].fromIso8601 */ .Z.fromIso8601(dates[1]);\n  var isStartIncluded = (0,_defaultValue_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .Z)(options.isStartIncluded, true);\n  var isStopIncluded = (0,_defaultValue_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .Z)(options.isStopIncluded, true);\n  var data = options.data;\n\n  if (!(0,_defined_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .Z)(result)) {\n    scratchInterval.start = start;\n    scratchInterval.stop = stop;\n    scratchInterval.isStartIncluded = isStartIncluded;\n    scratchInterval.isStopIncluded = isStopIncluded;\n    scratchInterval.data = data;\n    return new TimeInterval(scratchInterval);\n  }\n\n  result.start = start;\n  result.stop = stop;\n  result.isStartIncluded = isStartIncluded;\n  result.isStopIncluded = isStopIncluded;\n  result.data = data;\n  return result;\n};\n\n/**\n * Creates an ISO8601 representation of the provided interval.\n *\n * @param {TimeInterval} timeInterval The interval to be converted.\n * @param {Number} [precision] The number of fractional digits used to represent the seconds component.  By default, the most precise representation is used.\n * @returns {String} The ISO8601 representation of the provided interval.\n */\nTimeInterval.toIso8601 = function (timeInterval, precision) {\n  //>>includeStart(\'debug\', pragmas.debug);\n  _Check_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].typeOf.object */ .Z.typeOf.object("timeInterval", timeInterval);\n  //>>includeEnd(\'debug\');\n\n  return (\n    _JulianDate_js__WEBPACK_IMPORTED_MODULE_3__/* ["default"].toIso8601 */ .Z.toIso8601(timeInterval.start, precision) +\n    "/" +\n    _JulianDate_js__WEBPACK_IMPORTED_MODULE_3__/* ["default"].toIso8601 */ .Z.toIso8601(timeInterval.stop, precision)\n  );\n};\n\n/**\n * Duplicates the provided instance.\n *\n * @param {TimeInterval} [timeInterval] The instance to clone.\n * @param {TimeInterval} [result] An existing instance to use for the result.\n * @returns {TimeInterval} The modified result parameter or a new instance if none was provided.\n */\nTimeInterval.clone = function (timeInterval, result) {\n  if (!(0,_defined_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .Z)(timeInterval)) {\n    return undefined;\n  }\n  if (!(0,_defined_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .Z)(result)) {\n    return new TimeInterval(timeInterval);\n  }\n  result.start = timeInterval.start;\n  result.stop = timeInterval.stop;\n  result.isStartIncluded = timeInterval.isStartIncluded;\n  result.isStopIncluded = timeInterval.isStopIncluded;\n  result.data = timeInterval.data;\n  return result;\n};\n\n/**\n * Compares two instances and returns <code>true</code> if they are equal, <code>false</code> otherwise.\n *\n * @param {TimeInterval} [left] The first instance.\n * @param {TimeInterval} [right] The second instance.\n * @param {TimeInterval.DataComparer} [dataComparer] A function which compares the data of the two intervals.  If omitted, reference equality is used.\n * @returns {Boolean} <code>true</code> if the dates are equal; otherwise, <code>false</code>.\n */\nTimeInterval.equals = function (left, right, dataComparer) {\n  return (\n    left === right ||\n    ((0,_defined_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .Z)(left) &&\n      (0,_defined_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .Z)(right) &&\n      ((left.isEmpty && right.isEmpty) ||\n        (left.isStartIncluded === right.isStartIncluded &&\n          left.isStopIncluded === right.isStopIncluded &&\n          _JulianDate_js__WEBPACK_IMPORTED_MODULE_3__/* ["default"].equals */ .Z.equals(left.start, right.start) &&\n          _JulianDate_js__WEBPACK_IMPORTED_MODULE_3__/* ["default"].equals */ .Z.equals(left.stop, right.stop) &&\n          (left.data === right.data ||\n            ((0,_defined_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .Z)(dataComparer) && dataComparer(left.data, right.data))))))\n  );\n};\n\n/**\n * Compares two instances and returns <code>true</code> if they are within <code>epsilon</code> seconds of\n * each other.  That is, in order for the dates to be considered equal (and for\n * this function to return <code>true</code>), the absolute value of the difference between them, in\n * seconds, must be less than <code>epsilon</code>.\n *\n * @param {TimeInterval} [left] The first instance.\n * @param {TimeInterval} [right] The second instance.\n * @param {Number} [epsilon=0] The maximum number of seconds that should separate the two instances.\n * @param {TimeInterval.DataComparer} [dataComparer] A function which compares the data of the two intervals.  If omitted, reference equality is used.\n * @returns {Boolean} <code>true</code> if the two dates are within <code>epsilon</code> seconds of each other; otherwise <code>false</code>.\n */\nTimeInterval.equalsEpsilon = function (left, right, epsilon, dataComparer) {\n  epsilon = (0,_defaultValue_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .Z)(epsilon, 0);\n\n  return (\n    left === right ||\n    ((0,_defined_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .Z)(left) &&\n      (0,_defined_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .Z)(right) &&\n      ((left.isEmpty && right.isEmpty) ||\n        (left.isStartIncluded === right.isStartIncluded &&\n          left.isStopIncluded === right.isStopIncluded &&\n          _JulianDate_js__WEBPACK_IMPORTED_MODULE_3__/* ["default"].equalsEpsilon */ .Z.equalsEpsilon(left.start, right.start, epsilon) &&\n          _JulianDate_js__WEBPACK_IMPORTED_MODULE_3__/* ["default"].equalsEpsilon */ .Z.equalsEpsilon(left.stop, right.stop, epsilon) &&\n          (left.data === right.data ||\n            ((0,_defined_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .Z)(dataComparer) && dataComparer(left.data, right.data))))))\n  );\n};\n\n/**\n * Computes the intersection of two intervals, optionally merging their data.\n *\n * @param {TimeInterval} left The first interval.\n * @param {TimeInterval} [right] The second interval.\n * @param {TimeInterval} [result] An existing instance to use for the result.\n * @param {TimeInterval.MergeCallback} [mergeCallback] A function which merges the data of the two intervals. If omitted, the data from the left interval will be used.\n * @returns {TimeInterval} The modified result parameter.\n */\nTimeInterval.intersect = function (left, right, result, mergeCallback) {\n  //>>includeStart(\'debug\', pragmas.debug);\n  _Check_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].typeOf.object */ .Z.typeOf.object("left", left);\n  //>>includeEnd(\'debug\');\n\n  if (!(0,_defined_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .Z)(right)) {\n    return TimeInterval.clone(TimeInterval.EMPTY, result);\n  }\n\n  var leftStart = left.start;\n  var leftStop = left.stop;\n\n  var rightStart = right.start;\n  var rightStop = right.stop;\n\n  var intersectsStartRight =\n    _JulianDate_js__WEBPACK_IMPORTED_MODULE_3__/* ["default"].greaterThanOrEquals */ .Z.greaterThanOrEquals(rightStart, leftStart) &&\n    _JulianDate_js__WEBPACK_IMPORTED_MODULE_3__/* ["default"].greaterThanOrEquals */ .Z.greaterThanOrEquals(leftStop, rightStart);\n  var intersectsStartLeft =\n    !intersectsStartRight &&\n    _JulianDate_js__WEBPACK_IMPORTED_MODULE_3__/* ["default"].lessThanOrEquals */ .Z.lessThanOrEquals(rightStart, leftStart) &&\n    _JulianDate_js__WEBPACK_IMPORTED_MODULE_3__/* ["default"].lessThanOrEquals */ .Z.lessThanOrEquals(leftStart, rightStop);\n\n  if (!intersectsStartRight && !intersectsStartLeft) {\n    return TimeInterval.clone(TimeInterval.EMPTY, result);\n  }\n\n  var leftIsStartIncluded = left.isStartIncluded;\n  var leftIsStopIncluded = left.isStopIncluded;\n  var rightIsStartIncluded = right.isStartIncluded;\n  var rightIsStopIncluded = right.isStopIncluded;\n  var leftLessThanRight = _JulianDate_js__WEBPACK_IMPORTED_MODULE_3__/* ["default"].lessThan */ .Z.lessThan(leftStop, rightStop);\n\n  if (!(0,_defined_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .Z)(result)) {\n    result = new TimeInterval();\n  }\n\n  result.start = intersectsStartRight ? rightStart : leftStart;\n  result.isStartIncluded =\n    (leftIsStartIncluded && rightIsStartIncluded) ||\n    (!_JulianDate_js__WEBPACK_IMPORTED_MODULE_3__/* ["default"].equals */ .Z.equals(rightStart, leftStart) &&\n      ((intersectsStartRight && rightIsStartIncluded) ||\n        (intersectsStartLeft && leftIsStartIncluded)));\n  result.stop = leftLessThanRight ? leftStop : rightStop;\n  result.isStopIncluded = leftLessThanRight\n    ? leftIsStopIncluded\n    : (leftIsStopIncluded && rightIsStopIncluded) ||\n      (!_JulianDate_js__WEBPACK_IMPORTED_MODULE_3__/* ["default"].equals */ .Z.equals(rightStop, leftStop) && rightIsStopIncluded);\n  result.data = (0,_defined_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .Z)(mergeCallback)\n    ? mergeCallback(left.data, right.data)\n    : left.data;\n  return result;\n};\n\n/**\n * Checks if the specified date is inside the provided interval.\n *\n * @param {TimeInterval} timeInterval The interval.\n * @param {JulianDate} julianDate The date to check.\n * @returns {Boolean} <code>true</code> if the interval contains the specified date, <code>false</code> otherwise.\n */\nTimeInterval.contains = function (timeInterval, julianDate) {\n  //>>includeStart(\'debug\', pragmas.debug);\n  _Check_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].typeOf.object */ .Z.typeOf.object("timeInterval", timeInterval);\n  _Check_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].typeOf.object */ .Z.typeOf.object("julianDate", julianDate);\n  //>>includeEnd(\'debug\');\n\n  if (timeInterval.isEmpty) {\n    return false;\n  }\n\n  var startComparedToDate = _JulianDate_js__WEBPACK_IMPORTED_MODULE_3__/* ["default"].compare */ .Z.compare(timeInterval.start, julianDate);\n  if (startComparedToDate === 0) {\n    return timeInterval.isStartIncluded;\n  }\n\n  var dateComparedToStop = _JulianDate_js__WEBPACK_IMPORTED_MODULE_3__/* ["default"].compare */ .Z.compare(julianDate, timeInterval.stop);\n  if (dateComparedToStop === 0) {\n    return timeInterval.isStopIncluded;\n  }\n\n  return startComparedToDate < 0 && dateComparedToStop < 0;\n};\n\n/**\n * Duplicates this instance.\n *\n * @param {TimeInterval} [result] An existing instance to use for the result.\n * @returns {TimeInterval} The modified result parameter or a new instance if none was provided.\n */\nTimeInterval.prototype.clone = function (result) {\n  return TimeInterval.clone(this, result);\n};\n\n/**\n * Compares this instance against the provided instance componentwise and returns\n * <code>true</code> if they are equal, <code>false</code> otherwise.\n *\n * @param {TimeInterval} [right] The right hand side interval.\n * @param {TimeInterval.DataComparer} [dataComparer] A function which compares the data of the two intervals.  If omitted, reference equality is used.\n * @returns {Boolean} <code>true</code> if they are equal, <code>false</code> otherwise.\n */\nTimeInterval.prototype.equals = function (right, dataComparer) {\n  return TimeInterval.equals(this, right, dataComparer);\n};\n\n/**\n * Compares this instance against the provided instance componentwise and returns\n * <code>true</code> if they are within the provided epsilon,\n * <code>false</code> otherwise.\n *\n * @param {TimeInterval} [right] The right hand side interval.\n * @param {Number} [epsilon=0] The epsilon to use for equality testing.\n * @param {TimeInterval.DataComparer} [dataComparer] A function which compares the data of the two intervals.  If omitted, reference equality is used.\n * @returns {Boolean} <code>true</code> if they are within the provided epsilon, <code>false</code> otherwise.\n */\nTimeInterval.prototype.equalsEpsilon = function (right, epsilon, dataComparer) {\n  return TimeInterval.equalsEpsilon(this, right, epsilon, dataComparer);\n};\n\n/**\n * Creates a string representing this TimeInterval in ISO8601 format.\n *\n * @returns {String} A string representing this TimeInterval in ISO8601 format.\n */\nTimeInterval.prototype.toString = function () {\n  return TimeInterval.toIso8601(this);\n};\n\n/**\n * An immutable empty interval.\n *\n * @type {TimeInterval}\n * @constant\n */\nTimeInterval.EMPTY = Object.freeze(\n  new TimeInterval({\n    start: new _JulianDate_js__WEBPACK_IMPORTED_MODULE_3__/* ["default"] */ .Z(),\n    stop: new _JulianDate_js__WEBPACK_IMPORTED_MODULE_3__/* ["default"] */ .Z(),\n    isStartIncluded: false,\n    isStopIncluded: false,\n  })\n);\n\n/**\n * Function interface for merging interval data.\n * @callback TimeInterval.MergeCallback\n *\n * @param {*} leftData The first data instance.\n * @param {*} rightData The second data instance.\n * @returns {*} The result of merging the two data instances.\n */\n\n/**\n * Function interface for comparing interval data.\n * @callback TimeInterval.DataComparer\n * @param {*} leftData The first data instance.\n * @param {*} rightData The second data instance.\n * @returns {Boolean} <code>true</code> if the provided instances are equal, <code>false</code> otherwise.\n */\n/* harmony default export */ __webpack_exports__["Z"] = (TimeInterval);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QVk7QUFDdkIsYUFBYSxTQUFTO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBLEVBQUUsc0ZBQW1CO0FBQ3JCLEVBQUUsc0ZBQW1CO0FBQ3JCOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSw0QkFBNEIsK0VBQWtCO0FBQzlDO0FBQ0E7QUFDQTs7QUFFQSwyQkFBMkIsK0VBQWtCO0FBQzdDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsY0FBYztBQUN6QixhQUFhLGNBQWM7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGNBQWM7QUFDekIsV0FBVywyQkFBMkI7QUFDdEMsYUFBYSxTQUFTO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGNBQWM7QUFDekIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsMkJBQTJCO0FBQ3RDLGFBQWEsU0FBUztBQUN0QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSwrREFBVTtBQUN6QixjQUFjLCtEQUFVO0FBQ3hCO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEdBQUc7QUFDZCxXQUFXLEdBQUc7QUFDZCxhQUFhLEdBQUc7QUFDaEI7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxHQUFHO0FBQ2QsV0FBVyxHQUFHO0FBQ2QsYUFBYSxTQUFTO0FBQ3RCO0FBQ0EseURBQWUsWUFBWSxFQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdnVlMy13ZWJwYWNrNS8uL25vZGVfbW9kdWxlcy9jZXNpdW0vU291cmNlL0NvcmUvVGltZUludGVydmFsLmpzP2E0ODIiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IENoZWNrIGZyb20gXCIuL0NoZWNrLmpzXCI7XG5pbXBvcnQgZGVmYXVsdFZhbHVlIGZyb20gXCIuL2RlZmF1bHRWYWx1ZS5qc1wiO1xuaW1wb3J0IGRlZmluZWQgZnJvbSBcIi4vZGVmaW5lZC5qc1wiO1xuaW1wb3J0IERldmVsb3BlckVycm9yIGZyb20gXCIuL0RldmVsb3BlckVycm9yLmpzXCI7XG5pbXBvcnQgSnVsaWFuRGF0ZSBmcm9tIFwiLi9KdWxpYW5EYXRlLmpzXCI7XG5cbi8qKlxuICogQW4gaW50ZXJ2YWwgZGVmaW5lZCBieSBhIHN0YXJ0IGFuZCBhIHN0b3AgdGltZTsgb3B0aW9uYWxseSBpbmNsdWRpbmcgdGhvc2UgdGltZXMgYXMgcGFydCBvZiB0aGUgaW50ZXJ2YWwuXG4gKiBBcmJpdHJhcnkgZGF0YSBjYW4gb3B0aW9uYWxseSBiZSBhc3NvY2lhdGVkIHdpdGggZWFjaCBpbnN0YW5jZSBmb3IgdXNlZCB3aXRoIHtAbGluayBUaW1lSW50ZXJ2YWxDb2xsZWN0aW9ufS5cbiAqXG4gKiBAYWxpYXMgVGltZUludGVydmFsXG4gKiBAY29uc3RydWN0b3JcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIE9iamVjdCB3aXRoIHRoZSBmb2xsb3dpbmcgcHJvcGVydGllczpcbiAqIEBwYXJhbSB7SnVsaWFuRGF0ZX0gW29wdGlvbnMuc3RhcnQ9bmV3IEp1bGlhbkRhdGUoKV0gVGhlIHN0YXJ0IHRpbWUgb2YgdGhlIGludGVydmFsLlxuICogQHBhcmFtIHtKdWxpYW5EYXRlfSBbb3B0aW9ucy5zdG9wPW5ldyBKdWxpYW5EYXRlKCldIFRoZSBzdG9wIHRpbWUgb2YgdGhlIGludGVydmFsLlxuICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5pc1N0YXJ0SW5jbHVkZWQ9dHJ1ZV0gPGNvZGU+dHJ1ZTwvY29kZT4gaWYgPGNvZGU+b3B0aW9ucy5zdGFydDwvY29kZT4gaXMgaW5jbHVkZWQgaW4gdGhlIGludGVydmFsLCA8Y29kZT5mYWxzZTwvY29kZT4gb3RoZXJ3aXNlLlxuICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5pc1N0b3BJbmNsdWRlZD10cnVlXSA8Y29kZT50cnVlPC9jb2RlPiBpZiA8Y29kZT5vcHRpb25zLnN0b3A8L2NvZGU+IGlzIGluY2x1ZGVkIGluIHRoZSBpbnRlcnZhbCwgPGNvZGU+ZmFsc2U8L2NvZGU+IG90aGVyd2lzZS5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9ucy5kYXRhXSBBcmJpdHJhcnkgZGF0YSBhc3NvY2lhdGVkIHdpdGggdGhpcyBpbnRlcnZhbC5cbiAqXG4gKiBAZXhhbXBsZVxuICogLy8gQ3JlYXRlIGFuIGluc3RhbmNlIHRoYXQgc3BhbnMgQXVndXN0IDFzdCwgMTk4MCBhbmQgaXMgYXNzb2NpYXRlZFxuICogLy8gd2l0aCBhIENhcnRlc2lhbiBwb3NpdGlvbi5cbiAqIHZhciB0aW1lSW50ZXJ2YWwgPSBuZXcgQ2VzaXVtLlRpbWVJbnRlcnZhbCh7XG4gKiAgICAgc3RhcnQgOiBDZXNpdW0uSnVsaWFuRGF0ZS5mcm9tSXNvODYwMSgnMTk4MC0wOC0wMVQwMDowMDowMFonKSxcbiAqICAgICBzdG9wIDogQ2VzaXVtLkp1bGlhbkRhdGUuZnJvbUlzbzg2MDEoJzE5ODAtMDgtMDJUMDA6MDA6MDBaJyksXG4gKiAgICAgaXNTdGFydEluY2x1ZGVkIDogdHJ1ZSxcbiAqICAgICBpc1N0b3BJbmNsdWRlZCA6IGZhbHNlLFxuICogICAgIGRhdGEgOiBDZXNpdW0uQ2FydGVzaWFuMy5mcm9tRGVncmVlcygzOS45MjEwMzcsIC03NS4xNzAwODIpXG4gKiB9KTtcbiAqXG4gKiBAZXhhbXBsZVxuICogLy8gQ3JlYXRlIHR3byBpbnN0YW5jZXMgZnJvbSBJU08gODYwMSBpbnRlcnZhbHMgd2l0aCBhc3NvY2lhdGVkIG51bWVyaWMgZGF0YVxuICogLy8gdGhlbiBjb21wdXRlIHRoZWlyIGludGVyc2VjdGlvbiwgc3VtbWluZyB0aGUgZGF0YSB0aGV5IGNvbnRhaW4uXG4gKiB2YXIgbGVmdCA9IENlc2l1bS5UaW1lSW50ZXJ2YWwuZnJvbUlzbzg2MDEoe1xuICogICAgIGlzbzg2MDEgOiAnMjAwMC8yMDEwJyxcbiAqICAgICBkYXRhIDogMlxuICogfSk7XG4gKlxuICogdmFyIHJpZ2h0ID0gQ2VzaXVtLlRpbWVJbnRlcnZhbC5mcm9tSXNvODYwMSh7XG4gKiAgICAgaXNvODYwMSA6ICcxOTk1LzIwMDUnLFxuICogICAgIGRhdGEgOiAzXG4gKiB9KTtcbiAqXG4gKiAvL1RoZSByZXN1bHQgb2YgdGhlIGJlbG93IGludGVyc2VjdGlvbiB3aWxsIGJlIGFuIGludGVydmFsIGVxdWl2YWxlbnQgdG9cbiAqIC8vdmFyIGludGVyc2VjdGlvbiA9IENlc2l1bS5UaW1lSW50ZXJ2YWwuZnJvbUlzbzg2MDEoe1xuICogLy8gIGlzbzg2MDEgOiAnMjAwMC8yMDA1JyxcbiAqIC8vICBkYXRhIDogNVxuICogLy99KTtcbiAqIHZhciBpbnRlcnNlY3Rpb24gPSBuZXcgQ2VzaXVtLlRpbWVJbnRlcnZhbCgpO1xuICogQ2VzaXVtLlRpbWVJbnRlcnZhbC5pbnRlcnNlY3QobGVmdCwgcmlnaHQsIGludGVyc2VjdGlvbiwgZnVuY3Rpb24obGVmdERhdGEsIHJpZ2h0RGF0YSkge1xuICogICAgIHJldHVybiBsZWZ0RGF0YSArIHJpZ2h0RGF0YTtcbiAqIH0pO1xuICpcbiAqIEBleGFtcGxlXG4gKiAvLyBDaGVjayBpZiBhbiBpbnRlcnZhbCBjb250YWlucyBhIHNwZWNpZmljIHRpbWUuXG4gKiB2YXIgZGF0ZVRvQ2hlY2sgPSBDZXNpdW0uSnVsaWFuRGF0ZS5mcm9tSXNvODYwMSgnMTk4Mi0wOS0wOFQxMTozMDowMFonKTtcbiAqIHZhciBjb250YWluc0RhdGUgPSBDZXNpdW0uVGltZUludGVydmFsLmNvbnRhaW5zKHRpbWVJbnRlcnZhbCwgZGF0ZVRvQ2hlY2spO1xuICovXG5mdW5jdGlvbiBUaW1lSW50ZXJ2YWwob3B0aW9ucykge1xuICBvcHRpb25zID0gZGVmYXVsdFZhbHVlKG9wdGlvbnMsIGRlZmF1bHRWYWx1ZS5FTVBUWV9PQkpFQ1QpO1xuICAvKipcbiAgICogR2V0cyBvciBzZXRzIHRoZSBzdGFydCB0aW1lIG9mIHRoaXMgaW50ZXJ2YWwuXG4gICAqIEB0eXBlIHtKdWxpYW5EYXRlfVxuICAgKi9cbiAgdGhpcy5zdGFydCA9IGRlZmluZWQob3B0aW9ucy5zdGFydClcbiAgICA/IEp1bGlhbkRhdGUuY2xvbmUob3B0aW9ucy5zdGFydClcbiAgICA6IG5ldyBKdWxpYW5EYXRlKCk7XG5cbiAgLyoqXG4gICAqIEdldHMgb3Igc2V0cyB0aGUgc3RvcCB0aW1lIG9mIHRoaXMgaW50ZXJ2YWwuXG4gICAqIEB0eXBlIHtKdWxpYW5EYXRlfVxuICAgKi9cbiAgdGhpcy5zdG9wID0gZGVmaW5lZChvcHRpb25zLnN0b3ApXG4gICAgPyBKdWxpYW5EYXRlLmNsb25lKG9wdGlvbnMuc3RvcClcbiAgICA6IG5ldyBKdWxpYW5EYXRlKCk7XG5cbiAgLyoqXG4gICAqIEdldHMgb3Igc2V0cyB0aGUgZGF0YSBhc3NvY2lhdGVkIHdpdGggdGhpcyBpbnRlcnZhbC5cbiAgICogQHR5cGUgeyp9XG4gICAqL1xuICB0aGlzLmRhdGEgPSBvcHRpb25zLmRhdGE7XG5cbiAgLyoqXG4gICAqIEdldHMgb3Igc2V0cyB3aGV0aGVyIG9yIG5vdCB0aGUgc3RhcnQgdGltZSBpcyBpbmNsdWRlZCBpbiB0aGlzIGludGVydmFsLlxuICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICogQGRlZmF1bHQgdHJ1ZVxuICAgKi9cbiAgdGhpcy5pc1N0YXJ0SW5jbHVkZWQgPSBkZWZhdWx0VmFsdWUob3B0aW9ucy5pc1N0YXJ0SW5jbHVkZWQsIHRydWUpO1xuXG4gIC8qKlxuICAgKiBHZXRzIG9yIHNldHMgd2hldGhlciBvciBub3QgdGhlIHN0b3AgdGltZSBpcyBpbmNsdWRlZCBpbiB0aGlzIGludGVydmFsLlxuICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICogQGRlZmF1bHQgdHJ1ZVxuICAgKi9cbiAgdGhpcy5pc1N0b3BJbmNsdWRlZCA9IGRlZmF1bHRWYWx1ZShvcHRpb25zLmlzU3RvcEluY2x1ZGVkLCB0cnVlKTtcbn1cblxuT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoVGltZUludGVydmFsLnByb3RvdHlwZSwge1xuICAvKipcbiAgICogR2V0cyB3aGV0aGVyIG9yIG5vdCB0aGlzIGludGVydmFsIGlzIGVtcHR5LlxuICAgKiBAbWVtYmVyb2YgVGltZUludGVydmFsLnByb3RvdHlwZVxuICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICogQHJlYWRvbmx5XG4gICAqL1xuICBpc0VtcHR5OiB7XG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgc3RvcENvbXBhcmVkVG9TdGFydCA9IEp1bGlhbkRhdGUuY29tcGFyZSh0aGlzLnN0b3AsIHRoaXMuc3RhcnQpO1xuICAgICAgcmV0dXJuIChcbiAgICAgICAgc3RvcENvbXBhcmVkVG9TdGFydCA8IDAgfHxcbiAgICAgICAgKHN0b3BDb21wYXJlZFRvU3RhcnQgPT09IDAgJiZcbiAgICAgICAgICAoIXRoaXMuaXNTdGFydEluY2x1ZGVkIHx8ICF0aGlzLmlzU3RvcEluY2x1ZGVkKSlcbiAgICAgICk7XG4gICAgfSxcbiAgfSxcbn0pO1xuXG52YXIgc2NyYXRjaEludGVydmFsID0ge1xuICBzdGFydDogdW5kZWZpbmVkLFxuICBzdG9wOiB1bmRlZmluZWQsXG4gIGlzU3RhcnRJbmNsdWRlZDogdW5kZWZpbmVkLFxuICBpc1N0b3BJbmNsdWRlZDogdW5kZWZpbmVkLFxuICBkYXRhOiB1bmRlZmluZWQsXG59O1xuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgaW5zdGFuY2UgZnJvbSBhIHtAbGluayBodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0lTT184NjAxfElTTyA4NjAxfSBpbnRlcnZhbC5cbiAqXG4gKiBAdGhyb3dzIERldmVsb3BlckVycm9yIGlmIG9wdGlvbnMuaXNvODYwMSBkb2VzIG5vdCBtYXRjaCBwcm9wZXIgZm9ybWF0dGluZy5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyBPYmplY3Qgd2l0aCB0aGUgZm9sbG93aW5nIHByb3BlcnRpZXM6XG4gKiBAcGFyYW0ge1N0cmluZ30gb3B0aW9ucy5pc284NjAxIEFuIElTTyA4NjAxIGludGVydmFsLlxuICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5pc1N0YXJ0SW5jbHVkZWQ9dHJ1ZV0gPGNvZGU+dHJ1ZTwvY29kZT4gaWYgPGNvZGU+b3B0aW9ucy5zdGFydDwvY29kZT4gaXMgaW5jbHVkZWQgaW4gdGhlIGludGVydmFsLCA8Y29kZT5mYWxzZTwvY29kZT4gb3RoZXJ3aXNlLlxuICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5pc1N0b3BJbmNsdWRlZD10cnVlXSA8Y29kZT50cnVlPC9jb2RlPiBpZiA8Y29kZT5vcHRpb25zLnN0b3A8L2NvZGU+IGlzIGluY2x1ZGVkIGluIHRoZSBpbnRlcnZhbCwgPGNvZGU+ZmFsc2U8L2NvZGU+IG90aGVyd2lzZS5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9ucy5kYXRhXSBBcmJpdHJhcnkgZGF0YSBhc3NvY2lhdGVkIHdpdGggdGhpcyBpbnRlcnZhbC5cbiAqIEBwYXJhbSB7VGltZUludGVydmFsfSBbcmVzdWx0XSBBbiBleGlzdGluZyBpbnN0YW5jZSB0byB1c2UgZm9yIHRoZSByZXN1bHQuXG4gKiBAcmV0dXJucyB7VGltZUludGVydmFsfSBUaGUgbW9kaWZpZWQgcmVzdWx0IHBhcmFtZXRlciBvciBhIG5ldyBpbnN0YW5jZSBpZiBub25lIHdhcyBwcm92aWRlZC5cbiAqL1xuVGltZUludGVydmFsLmZyb21Jc284NjAxID0gZnVuY3Rpb24gKG9wdGlvbnMsIHJlc3VsdCkge1xuICAvLz4+aW5jbHVkZVN0YXJ0KCdkZWJ1ZycsIHByYWdtYXMuZGVidWcpO1xuICBDaGVjay50eXBlT2Yub2JqZWN0KFwib3B0aW9uc1wiLCBvcHRpb25zKTtcbiAgQ2hlY2sudHlwZU9mLnN0cmluZyhcIm9wdGlvbnMuaXNvODYwMVwiLCBvcHRpb25zLmlzbzg2MDEpO1xuICAvLz4+aW5jbHVkZUVuZCgnZGVidWcnKTtcblxuICB2YXIgZGF0ZXMgPSBvcHRpb25zLmlzbzg2MDEuc3BsaXQoXCIvXCIpO1xuICBpZiAoZGF0ZXMubGVuZ3RoICE9PSAyKSB7XG4gICAgdGhyb3cgbmV3IERldmVsb3BlckVycm9yKFxuICAgICAgXCJvcHRpb25zLmlzbzg2MDEgaXMgYW4gaW52YWxpZCBJU08gODYwMSBpbnRlcnZhbC5cIlxuICAgICk7XG4gIH1cbiAgdmFyIHN0YXJ0ID0gSnVsaWFuRGF0ZS5mcm9tSXNvODYwMShkYXRlc1swXSk7XG4gIHZhciBzdG9wID0gSnVsaWFuRGF0ZS5mcm9tSXNvODYwMShkYXRlc1sxXSk7XG4gIHZhciBpc1N0YXJ0SW5jbHVkZWQgPSBkZWZhdWx0VmFsdWUob3B0aW9ucy5pc1N0YXJ0SW5jbHVkZWQsIHRydWUpO1xuICB2YXIgaXNTdG9wSW5jbHVkZWQgPSBkZWZhdWx0VmFsdWUob3B0aW9ucy5pc1N0b3BJbmNsdWRlZCwgdHJ1ZSk7XG4gIHZhciBkYXRhID0gb3B0aW9ucy5kYXRhO1xuXG4gIGlmICghZGVmaW5lZChyZXN1bHQpKSB7XG4gICAgc2NyYXRjaEludGVydmFsLnN0YXJ0ID0gc3RhcnQ7XG4gICAgc2NyYXRjaEludGVydmFsLnN0b3AgPSBzdG9wO1xuICAgIHNjcmF0Y2hJbnRlcnZhbC5pc1N0YXJ0SW5jbHVkZWQgPSBpc1N0YXJ0SW5jbHVkZWQ7XG4gICAgc2NyYXRjaEludGVydmFsLmlzU3RvcEluY2x1ZGVkID0gaXNTdG9wSW5jbHVkZWQ7XG4gICAgc2NyYXRjaEludGVydmFsLmRhdGEgPSBkYXRhO1xuICAgIHJldHVybiBuZXcgVGltZUludGVydmFsKHNjcmF0Y2hJbnRlcnZhbCk7XG4gIH1cblxuICByZXN1bHQuc3RhcnQgPSBzdGFydDtcbiAgcmVzdWx0LnN0b3AgPSBzdG9wO1xuICByZXN1bHQuaXNTdGFydEluY2x1ZGVkID0gaXNTdGFydEluY2x1ZGVkO1xuICByZXN1bHQuaXNTdG9wSW5jbHVkZWQgPSBpc1N0b3BJbmNsdWRlZDtcbiAgcmVzdWx0LmRhdGEgPSBkYXRhO1xuICByZXR1cm4gcmVzdWx0O1xufTtcblxuLyoqXG4gKiBDcmVhdGVzIGFuIElTTzg2MDEgcmVwcmVzZW50YXRpb24gb2YgdGhlIHByb3ZpZGVkIGludGVydmFsLlxuICpcbiAqIEBwYXJhbSB7VGltZUludGVydmFsfSB0aW1lSW50ZXJ2YWwgVGhlIGludGVydmFsIHRvIGJlIGNvbnZlcnRlZC5cbiAqIEBwYXJhbSB7TnVtYmVyfSBbcHJlY2lzaW9uXSBUaGUgbnVtYmVyIG9mIGZyYWN0aW9uYWwgZGlnaXRzIHVzZWQgdG8gcmVwcmVzZW50IHRoZSBzZWNvbmRzIGNvbXBvbmVudC4gIEJ5IGRlZmF1bHQsIHRoZSBtb3N0IHByZWNpc2UgcmVwcmVzZW50YXRpb24gaXMgdXNlZC5cbiAqIEByZXR1cm5zIHtTdHJpbmd9IFRoZSBJU084NjAxIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBwcm92aWRlZCBpbnRlcnZhbC5cbiAqL1xuVGltZUludGVydmFsLnRvSXNvODYwMSA9IGZ1bmN0aW9uICh0aW1lSW50ZXJ2YWwsIHByZWNpc2lvbikge1xuICAvLz4+aW5jbHVkZVN0YXJ0KCdkZWJ1ZycsIHByYWdtYXMuZGVidWcpO1xuICBDaGVjay50eXBlT2Yub2JqZWN0KFwidGltZUludGVydmFsXCIsIHRpbWVJbnRlcnZhbCk7XG4gIC8vPj5pbmNsdWRlRW5kKCdkZWJ1ZycpO1xuXG4gIHJldHVybiAoXG4gICAgSnVsaWFuRGF0ZS50b0lzbzg2MDEodGltZUludGVydmFsLnN0YXJ0LCBwcmVjaXNpb24pICtcbiAgICBcIi9cIiArXG4gICAgSnVsaWFuRGF0ZS50b0lzbzg2MDEodGltZUludGVydmFsLnN0b3AsIHByZWNpc2lvbilcbiAgKTtcbn07XG5cbi8qKlxuICogRHVwbGljYXRlcyB0aGUgcHJvdmlkZWQgaW5zdGFuY2UuXG4gKlxuICogQHBhcmFtIHtUaW1lSW50ZXJ2YWx9IFt0aW1lSW50ZXJ2YWxdIFRoZSBpbnN0YW5jZSB0byBjbG9uZS5cbiAqIEBwYXJhbSB7VGltZUludGVydmFsfSBbcmVzdWx0XSBBbiBleGlzdGluZyBpbnN0YW5jZSB0byB1c2UgZm9yIHRoZSByZXN1bHQuXG4gKiBAcmV0dXJucyB7VGltZUludGVydmFsfSBUaGUgbW9kaWZpZWQgcmVzdWx0IHBhcmFtZXRlciBvciBhIG5ldyBpbnN0YW5jZSBpZiBub25lIHdhcyBwcm92aWRlZC5cbiAqL1xuVGltZUludGVydmFsLmNsb25lID0gZnVuY3Rpb24gKHRpbWVJbnRlcnZhbCwgcmVzdWx0KSB7XG4gIGlmICghZGVmaW5lZCh0aW1lSW50ZXJ2YWwpKSB7XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxuICBpZiAoIWRlZmluZWQocmVzdWx0KSkge1xuICAgIHJldHVybiBuZXcgVGltZUludGVydmFsKHRpbWVJbnRlcnZhbCk7XG4gIH1cbiAgcmVzdWx0LnN0YXJ0ID0gdGltZUludGVydmFsLnN0YXJ0O1xuICByZXN1bHQuc3RvcCA9IHRpbWVJbnRlcnZhbC5zdG9wO1xuICByZXN1bHQuaXNTdGFydEluY2x1ZGVkID0gdGltZUludGVydmFsLmlzU3RhcnRJbmNsdWRlZDtcbiAgcmVzdWx0LmlzU3RvcEluY2x1ZGVkID0gdGltZUludGVydmFsLmlzU3RvcEluY2x1ZGVkO1xuICByZXN1bHQuZGF0YSA9IHRpbWVJbnRlcnZhbC5kYXRhO1xuICByZXR1cm4gcmVzdWx0O1xufTtcblxuLyoqXG4gKiBDb21wYXJlcyB0d28gaW5zdGFuY2VzIGFuZCByZXR1cm5zIDxjb2RlPnRydWU8L2NvZGU+IGlmIHRoZXkgYXJlIGVxdWFsLCA8Y29kZT5mYWxzZTwvY29kZT4gb3RoZXJ3aXNlLlxuICpcbiAqIEBwYXJhbSB7VGltZUludGVydmFsfSBbbGVmdF0gVGhlIGZpcnN0IGluc3RhbmNlLlxuICogQHBhcmFtIHtUaW1lSW50ZXJ2YWx9IFtyaWdodF0gVGhlIHNlY29uZCBpbnN0YW5jZS5cbiAqIEBwYXJhbSB7VGltZUludGVydmFsLkRhdGFDb21wYXJlcn0gW2RhdGFDb21wYXJlcl0gQSBmdW5jdGlvbiB3aGljaCBjb21wYXJlcyB0aGUgZGF0YSBvZiB0aGUgdHdvIGludGVydmFscy4gIElmIG9taXR0ZWQsIHJlZmVyZW5jZSBlcXVhbGl0eSBpcyB1c2VkLlxuICogQHJldHVybnMge0Jvb2xlYW59IDxjb2RlPnRydWU8L2NvZGU+IGlmIHRoZSBkYXRlcyBhcmUgZXF1YWw7IG90aGVyd2lzZSwgPGNvZGU+ZmFsc2U8L2NvZGU+LlxuICovXG5UaW1lSW50ZXJ2YWwuZXF1YWxzID0gZnVuY3Rpb24gKGxlZnQsIHJpZ2h0LCBkYXRhQ29tcGFyZXIpIHtcbiAgcmV0dXJuIChcbiAgICBsZWZ0ID09PSByaWdodCB8fFxuICAgIChkZWZpbmVkKGxlZnQpICYmXG4gICAgICBkZWZpbmVkKHJpZ2h0KSAmJlxuICAgICAgKChsZWZ0LmlzRW1wdHkgJiYgcmlnaHQuaXNFbXB0eSkgfHxcbiAgICAgICAgKGxlZnQuaXNTdGFydEluY2x1ZGVkID09PSByaWdodC5pc1N0YXJ0SW5jbHVkZWQgJiZcbiAgICAgICAgICBsZWZ0LmlzU3RvcEluY2x1ZGVkID09PSByaWdodC5pc1N0b3BJbmNsdWRlZCAmJlxuICAgICAgICAgIEp1bGlhbkRhdGUuZXF1YWxzKGxlZnQuc3RhcnQsIHJpZ2h0LnN0YXJ0KSAmJlxuICAgICAgICAgIEp1bGlhbkRhdGUuZXF1YWxzKGxlZnQuc3RvcCwgcmlnaHQuc3RvcCkgJiZcbiAgICAgICAgICAobGVmdC5kYXRhID09PSByaWdodC5kYXRhIHx8XG4gICAgICAgICAgICAoZGVmaW5lZChkYXRhQ29tcGFyZXIpICYmIGRhdGFDb21wYXJlcihsZWZ0LmRhdGEsIHJpZ2h0LmRhdGEpKSkpKSlcbiAgKTtcbn07XG5cbi8qKlxuICogQ29tcGFyZXMgdHdvIGluc3RhbmNlcyBhbmQgcmV0dXJucyA8Y29kZT50cnVlPC9jb2RlPiBpZiB0aGV5IGFyZSB3aXRoaW4gPGNvZGU+ZXBzaWxvbjwvY29kZT4gc2Vjb25kcyBvZlxuICogZWFjaCBvdGhlci4gIFRoYXQgaXMsIGluIG9yZGVyIGZvciB0aGUgZGF0ZXMgdG8gYmUgY29uc2lkZXJlZCBlcXVhbCAoYW5kIGZvclxuICogdGhpcyBmdW5jdGlvbiB0byByZXR1cm4gPGNvZGU+dHJ1ZTwvY29kZT4pLCB0aGUgYWJzb2x1dGUgdmFsdWUgb2YgdGhlIGRpZmZlcmVuY2UgYmV0d2VlbiB0aGVtLCBpblxuICogc2Vjb25kcywgbXVzdCBiZSBsZXNzIHRoYW4gPGNvZGU+ZXBzaWxvbjwvY29kZT4uXG4gKlxuICogQHBhcmFtIHtUaW1lSW50ZXJ2YWx9IFtsZWZ0XSBUaGUgZmlyc3QgaW5zdGFuY2UuXG4gKiBAcGFyYW0ge1RpbWVJbnRlcnZhbH0gW3JpZ2h0XSBUaGUgc2Vjb25kIGluc3RhbmNlLlxuICogQHBhcmFtIHtOdW1iZXJ9IFtlcHNpbG9uPTBdIFRoZSBtYXhpbXVtIG51bWJlciBvZiBzZWNvbmRzIHRoYXQgc2hvdWxkIHNlcGFyYXRlIHRoZSB0d28gaW5zdGFuY2VzLlxuICogQHBhcmFtIHtUaW1lSW50ZXJ2YWwuRGF0YUNvbXBhcmVyfSBbZGF0YUNvbXBhcmVyXSBBIGZ1bmN0aW9uIHdoaWNoIGNvbXBhcmVzIHRoZSBkYXRhIG9mIHRoZSB0d28gaW50ZXJ2YWxzLiAgSWYgb21pdHRlZCwgcmVmZXJlbmNlIGVxdWFsaXR5IGlzIHVzZWQuXG4gKiBAcmV0dXJucyB7Qm9vbGVhbn0gPGNvZGU+dHJ1ZTwvY29kZT4gaWYgdGhlIHR3byBkYXRlcyBhcmUgd2l0aGluIDxjb2RlPmVwc2lsb248L2NvZGU+IHNlY29uZHMgb2YgZWFjaCBvdGhlcjsgb3RoZXJ3aXNlIDxjb2RlPmZhbHNlPC9jb2RlPi5cbiAqL1xuVGltZUludGVydmFsLmVxdWFsc0Vwc2lsb24gPSBmdW5jdGlvbiAobGVmdCwgcmlnaHQsIGVwc2lsb24sIGRhdGFDb21wYXJlcikge1xuICBlcHNpbG9uID0gZGVmYXVsdFZhbHVlKGVwc2lsb24sIDApO1xuXG4gIHJldHVybiAoXG4gICAgbGVmdCA9PT0gcmlnaHQgfHxcbiAgICAoZGVmaW5lZChsZWZ0KSAmJlxuICAgICAgZGVmaW5lZChyaWdodCkgJiZcbiAgICAgICgobGVmdC5pc0VtcHR5ICYmIHJpZ2h0LmlzRW1wdHkpIHx8XG4gICAgICAgIChsZWZ0LmlzU3RhcnRJbmNsdWRlZCA9PT0gcmlnaHQuaXNTdGFydEluY2x1ZGVkICYmXG4gICAgICAgICAgbGVmdC5pc1N0b3BJbmNsdWRlZCA9PT0gcmlnaHQuaXNTdG9wSW5jbHVkZWQgJiZcbiAgICAgICAgICBKdWxpYW5EYXRlLmVxdWFsc0Vwc2lsb24obGVmdC5zdGFydCwgcmlnaHQuc3RhcnQsIGVwc2lsb24pICYmXG4gICAgICAgICAgSnVsaWFuRGF0ZS5lcXVhbHNFcHNpbG9uKGxlZnQuc3RvcCwgcmlnaHQuc3RvcCwgZXBzaWxvbikgJiZcbiAgICAgICAgICAobGVmdC5kYXRhID09PSByaWdodC5kYXRhIHx8XG4gICAgICAgICAgICAoZGVmaW5lZChkYXRhQ29tcGFyZXIpICYmIGRhdGFDb21wYXJlcihsZWZ0LmRhdGEsIHJpZ2h0LmRhdGEpKSkpKSlcbiAgKTtcbn07XG5cbi8qKlxuICogQ29tcHV0ZXMgdGhlIGludGVyc2VjdGlvbiBvZiB0d28gaW50ZXJ2YWxzLCBvcHRpb25hbGx5IG1lcmdpbmcgdGhlaXIgZGF0YS5cbiAqXG4gKiBAcGFyYW0ge1RpbWVJbnRlcnZhbH0gbGVmdCBUaGUgZmlyc3QgaW50ZXJ2YWwuXG4gKiBAcGFyYW0ge1RpbWVJbnRlcnZhbH0gW3JpZ2h0XSBUaGUgc2Vjb25kIGludGVydmFsLlxuICogQHBhcmFtIHtUaW1lSW50ZXJ2YWx9IFtyZXN1bHRdIEFuIGV4aXN0aW5nIGluc3RhbmNlIHRvIHVzZSBmb3IgdGhlIHJlc3VsdC5cbiAqIEBwYXJhbSB7VGltZUludGVydmFsLk1lcmdlQ2FsbGJhY2t9IFttZXJnZUNhbGxiYWNrXSBBIGZ1bmN0aW9uIHdoaWNoIG1lcmdlcyB0aGUgZGF0YSBvZiB0aGUgdHdvIGludGVydmFscy4gSWYgb21pdHRlZCwgdGhlIGRhdGEgZnJvbSB0aGUgbGVmdCBpbnRlcnZhbCB3aWxsIGJlIHVzZWQuXG4gKiBAcmV0dXJucyB7VGltZUludGVydmFsfSBUaGUgbW9kaWZpZWQgcmVzdWx0IHBhcmFtZXRlci5cbiAqL1xuVGltZUludGVydmFsLmludGVyc2VjdCA9IGZ1bmN0aW9uIChsZWZ0LCByaWdodCwgcmVzdWx0LCBtZXJnZUNhbGxiYWNrKSB7XG4gIC8vPj5pbmNsdWRlU3RhcnQoJ2RlYnVnJywgcHJhZ21hcy5kZWJ1Zyk7XG4gIENoZWNrLnR5cGVPZi5vYmplY3QoXCJsZWZ0XCIsIGxlZnQpO1xuICAvLz4+aW5jbHVkZUVuZCgnZGVidWcnKTtcblxuICBpZiAoIWRlZmluZWQocmlnaHQpKSB7XG4gICAgcmV0dXJuIFRpbWVJbnRlcnZhbC5jbG9uZShUaW1lSW50ZXJ2YWwuRU1QVFksIHJlc3VsdCk7XG4gIH1cblxuICB2YXIgbGVmdFN0YXJ0ID0gbGVmdC5zdGFydDtcbiAgdmFyIGxlZnRTdG9wID0gbGVmdC5zdG9wO1xuXG4gIHZhciByaWdodFN0YXJ0ID0gcmlnaHQuc3RhcnQ7XG4gIHZhciByaWdodFN0b3AgPSByaWdodC5zdG9wO1xuXG4gIHZhciBpbnRlcnNlY3RzU3RhcnRSaWdodCA9XG4gICAgSnVsaWFuRGF0ZS5ncmVhdGVyVGhhbk9yRXF1YWxzKHJpZ2h0U3RhcnQsIGxlZnRTdGFydCkgJiZcbiAgICBKdWxpYW5EYXRlLmdyZWF0ZXJUaGFuT3JFcXVhbHMobGVmdFN0b3AsIHJpZ2h0U3RhcnQpO1xuICB2YXIgaW50ZXJzZWN0c1N0YXJ0TGVmdCA9XG4gICAgIWludGVyc2VjdHNTdGFydFJpZ2h0ICYmXG4gICAgSnVsaWFuRGF0ZS5sZXNzVGhhbk9yRXF1YWxzKHJpZ2h0U3RhcnQsIGxlZnRTdGFydCkgJiZcbiAgICBKdWxpYW5EYXRlLmxlc3NUaGFuT3JFcXVhbHMobGVmdFN0YXJ0LCByaWdodFN0b3ApO1xuXG4gIGlmICghaW50ZXJzZWN0c1N0YXJ0UmlnaHQgJiYgIWludGVyc2VjdHNTdGFydExlZnQpIHtcbiAgICByZXR1cm4gVGltZUludGVydmFsLmNsb25lKFRpbWVJbnRlcnZhbC5FTVBUWSwgcmVzdWx0KTtcbiAgfVxuXG4gIHZhciBsZWZ0SXNTdGFydEluY2x1ZGVkID0gbGVmdC5pc1N0YXJ0SW5jbHVkZWQ7XG4gIHZhciBsZWZ0SXNTdG9wSW5jbHVkZWQgPSBsZWZ0LmlzU3RvcEluY2x1ZGVkO1xuICB2YXIgcmlnaHRJc1N0YXJ0SW5jbHVkZWQgPSByaWdodC5pc1N0YXJ0SW5jbHVkZWQ7XG4gIHZhciByaWdodElzU3RvcEluY2x1ZGVkID0gcmlnaHQuaXNTdG9wSW5jbHVkZWQ7XG4gIHZhciBsZWZ0TGVzc1RoYW5SaWdodCA9IEp1bGlhbkRhdGUubGVzc1RoYW4obGVmdFN0b3AsIHJpZ2h0U3RvcCk7XG5cbiAgaWYgKCFkZWZpbmVkKHJlc3VsdCkpIHtcbiAgICByZXN1bHQgPSBuZXcgVGltZUludGVydmFsKCk7XG4gIH1cblxuICByZXN1bHQuc3RhcnQgPSBpbnRlcnNlY3RzU3RhcnRSaWdodCA/IHJpZ2h0U3RhcnQgOiBsZWZ0U3RhcnQ7XG4gIHJlc3VsdC5pc1N0YXJ0SW5jbHVkZWQgPVxuICAgIChsZWZ0SXNTdGFydEluY2x1ZGVkICYmIHJpZ2h0SXNTdGFydEluY2x1ZGVkKSB8fFxuICAgICghSnVsaWFuRGF0ZS5lcXVhbHMocmlnaHRTdGFydCwgbGVmdFN0YXJ0KSAmJlxuICAgICAgKChpbnRlcnNlY3RzU3RhcnRSaWdodCAmJiByaWdodElzU3RhcnRJbmNsdWRlZCkgfHxcbiAgICAgICAgKGludGVyc2VjdHNTdGFydExlZnQgJiYgbGVmdElzU3RhcnRJbmNsdWRlZCkpKTtcbiAgcmVzdWx0LnN0b3AgPSBsZWZ0TGVzc1RoYW5SaWdodCA/IGxlZnRTdG9wIDogcmlnaHRTdG9wO1xuICByZXN1bHQuaXNTdG9wSW5jbHVkZWQgPSBsZWZ0TGVzc1RoYW5SaWdodFxuICAgID8gbGVmdElzU3RvcEluY2x1ZGVkXG4gICAgOiAobGVmdElzU3RvcEluY2x1ZGVkICYmIHJpZ2h0SXNTdG9wSW5jbHVkZWQpIHx8XG4gICAgICAoIUp1bGlhbkRhdGUuZXF1YWxzKHJpZ2h0U3RvcCwgbGVmdFN0b3ApICYmIHJpZ2h0SXNTdG9wSW5jbHVkZWQpO1xuICByZXN1bHQuZGF0YSA9IGRlZmluZWQobWVyZ2VDYWxsYmFjaylcbiAgICA/IG1lcmdlQ2FsbGJhY2sobGVmdC5kYXRhLCByaWdodC5kYXRhKVxuICAgIDogbGVmdC5kYXRhO1xuICByZXR1cm4gcmVzdWx0O1xufTtcblxuLyoqXG4gKiBDaGVja3MgaWYgdGhlIHNwZWNpZmllZCBkYXRlIGlzIGluc2lkZSB0aGUgcHJvdmlkZWQgaW50ZXJ2YWwuXG4gKlxuICogQHBhcmFtIHtUaW1lSW50ZXJ2YWx9IHRpbWVJbnRlcnZhbCBUaGUgaW50ZXJ2YWwuXG4gKiBAcGFyYW0ge0p1bGlhbkRhdGV9IGp1bGlhbkRhdGUgVGhlIGRhdGUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Qm9vbGVhbn0gPGNvZGU+dHJ1ZTwvY29kZT4gaWYgdGhlIGludGVydmFsIGNvbnRhaW5zIHRoZSBzcGVjaWZpZWQgZGF0ZSwgPGNvZGU+ZmFsc2U8L2NvZGU+IG90aGVyd2lzZS5cbiAqL1xuVGltZUludGVydmFsLmNvbnRhaW5zID0gZnVuY3Rpb24gKHRpbWVJbnRlcnZhbCwganVsaWFuRGF0ZSkge1xuICAvLz4+aW5jbHVkZVN0YXJ0KCdkZWJ1ZycsIHByYWdtYXMuZGVidWcpO1xuICBDaGVjay50eXBlT2Yub2JqZWN0KFwidGltZUludGVydmFsXCIsIHRpbWVJbnRlcnZhbCk7XG4gIENoZWNrLnR5cGVPZi5vYmplY3QoXCJqdWxpYW5EYXRlXCIsIGp1bGlhbkRhdGUpO1xuICAvLz4+aW5jbHVkZUVuZCgnZGVidWcnKTtcblxuICBpZiAodGltZUludGVydmFsLmlzRW1wdHkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICB2YXIgc3RhcnRDb21wYXJlZFRvRGF0ZSA9IEp1bGlhbkRhdGUuY29tcGFyZSh0aW1lSW50ZXJ2YWwuc3RhcnQsIGp1bGlhbkRhdGUpO1xuICBpZiAoc3RhcnRDb21wYXJlZFRvRGF0ZSA9PT0gMCkge1xuICAgIHJldHVybiB0aW1lSW50ZXJ2YWwuaXNTdGFydEluY2x1ZGVkO1xuICB9XG5cbiAgdmFyIGRhdGVDb21wYXJlZFRvU3RvcCA9IEp1bGlhbkRhdGUuY29tcGFyZShqdWxpYW5EYXRlLCB0aW1lSW50ZXJ2YWwuc3RvcCk7XG4gIGlmIChkYXRlQ29tcGFyZWRUb1N0b3AgPT09IDApIHtcbiAgICByZXR1cm4gdGltZUludGVydmFsLmlzU3RvcEluY2x1ZGVkO1xuICB9XG5cbiAgcmV0dXJuIHN0YXJ0Q29tcGFyZWRUb0RhdGUgPCAwICYmIGRhdGVDb21wYXJlZFRvU3RvcCA8IDA7XG59O1xuXG4vKipcbiAqIER1cGxpY2F0ZXMgdGhpcyBpbnN0YW5jZS5cbiAqXG4gKiBAcGFyYW0ge1RpbWVJbnRlcnZhbH0gW3Jlc3VsdF0gQW4gZXhpc3RpbmcgaW5zdGFuY2UgdG8gdXNlIGZvciB0aGUgcmVzdWx0LlxuICogQHJldHVybnMge1RpbWVJbnRlcnZhbH0gVGhlIG1vZGlmaWVkIHJlc3VsdCBwYXJhbWV0ZXIgb3IgYSBuZXcgaW5zdGFuY2UgaWYgbm9uZSB3YXMgcHJvdmlkZWQuXG4gKi9cblRpbWVJbnRlcnZhbC5wcm90b3R5cGUuY2xvbmUgPSBmdW5jdGlvbiAocmVzdWx0KSB7XG4gIHJldHVybiBUaW1lSW50ZXJ2YWwuY2xvbmUodGhpcywgcmVzdWx0KTtcbn07XG5cbi8qKlxuICogQ29tcGFyZXMgdGhpcyBpbnN0YW5jZSBhZ2FpbnN0IHRoZSBwcm92aWRlZCBpbnN0YW5jZSBjb21wb25lbnR3aXNlIGFuZCByZXR1cm5zXG4gKiA8Y29kZT50cnVlPC9jb2RlPiBpZiB0aGV5IGFyZSBlcXVhbCwgPGNvZGU+ZmFsc2U8L2NvZGU+IG90aGVyd2lzZS5cbiAqXG4gKiBAcGFyYW0ge1RpbWVJbnRlcnZhbH0gW3JpZ2h0XSBUaGUgcmlnaHQgaGFuZCBzaWRlIGludGVydmFsLlxuICogQHBhcmFtIHtUaW1lSW50ZXJ2YWwuRGF0YUNvbXBhcmVyfSBbZGF0YUNvbXBhcmVyXSBBIGZ1bmN0aW9uIHdoaWNoIGNvbXBhcmVzIHRoZSBkYXRhIG9mIHRoZSB0d28gaW50ZXJ2YWxzLiAgSWYgb21pdHRlZCwgcmVmZXJlbmNlIGVxdWFsaXR5IGlzIHVzZWQuXG4gKiBAcmV0dXJucyB7Qm9vbGVhbn0gPGNvZGU+dHJ1ZTwvY29kZT4gaWYgdGhleSBhcmUgZXF1YWwsIDxjb2RlPmZhbHNlPC9jb2RlPiBvdGhlcndpc2UuXG4gKi9cblRpbWVJbnRlcnZhbC5wcm90b3R5cGUuZXF1YWxzID0gZnVuY3Rpb24gKHJpZ2h0LCBkYXRhQ29tcGFyZXIpIHtcbiAgcmV0dXJuIFRpbWVJbnRlcnZhbC5lcXVhbHModGhpcywgcmlnaHQsIGRhdGFDb21wYXJlcik7XG59O1xuXG4vKipcbiAqIENvbXBhcmVzIHRoaXMgaW5zdGFuY2UgYWdhaW5zdCB0aGUgcHJvdmlkZWQgaW5zdGFuY2UgY29tcG9uZW50d2lzZSBhbmQgcmV0dXJuc1xuICogPGNvZGU+dHJ1ZTwvY29kZT4gaWYgdGhleSBhcmUgd2l0aGluIHRoZSBwcm92aWRlZCBlcHNpbG9uLFxuICogPGNvZGU+ZmFsc2U8L2NvZGU+IG90aGVyd2lzZS5cbiAqXG4gKiBAcGFyYW0ge1RpbWVJbnRlcnZhbH0gW3JpZ2h0XSBUaGUgcmlnaHQgaGFuZCBzaWRlIGludGVydmFsLlxuICogQHBhcmFtIHtOdW1iZXJ9IFtlcHNpbG9uPTBdIFRoZSBlcHNpbG9uIHRvIHVzZSBmb3IgZXF1YWxpdHkgdGVzdGluZy5cbiAqIEBwYXJhbSB7VGltZUludGVydmFsLkRhdGFDb21wYXJlcn0gW2RhdGFDb21wYXJlcl0gQSBmdW5jdGlvbiB3aGljaCBjb21wYXJlcyB0aGUgZGF0YSBvZiB0aGUgdHdvIGludGVydmFscy4gIElmIG9taXR0ZWQsIHJlZmVyZW5jZSBlcXVhbGl0eSBpcyB1c2VkLlxuICogQHJldHVybnMge0Jvb2xlYW59IDxjb2RlPnRydWU8L2NvZGU+IGlmIHRoZXkgYXJlIHdpdGhpbiB0aGUgcHJvdmlkZWQgZXBzaWxvbiwgPGNvZGU+ZmFsc2U8L2NvZGU+IG90aGVyd2lzZS5cbiAqL1xuVGltZUludGVydmFsLnByb3RvdHlwZS5lcXVhbHNFcHNpbG9uID0gZnVuY3Rpb24gKHJpZ2h0LCBlcHNpbG9uLCBkYXRhQ29tcGFyZXIpIHtcbiAgcmV0dXJuIFRpbWVJbnRlcnZhbC5lcXVhbHNFcHNpbG9uKHRoaXMsIHJpZ2h0LCBlcHNpbG9uLCBkYXRhQ29tcGFyZXIpO1xufTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgc3RyaW5nIHJlcHJlc2VudGluZyB0aGlzIFRpbWVJbnRlcnZhbCBpbiBJU084NjAxIGZvcm1hdC5cbiAqXG4gKiBAcmV0dXJucyB7U3RyaW5nfSBBIHN0cmluZyByZXByZXNlbnRpbmcgdGhpcyBUaW1lSW50ZXJ2YWwgaW4gSVNPODYwMSBmb3JtYXQuXG4gKi9cblRpbWVJbnRlcnZhbC5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiBUaW1lSW50ZXJ2YWwudG9Jc284NjAxKHRoaXMpO1xufTtcblxuLyoqXG4gKiBBbiBpbW11dGFibGUgZW1wdHkgaW50ZXJ2YWwuXG4gKlxuICogQHR5cGUge1RpbWVJbnRlcnZhbH1cbiAqIEBjb25zdGFudFxuICovXG5UaW1lSW50ZXJ2YWwuRU1QVFkgPSBPYmplY3QuZnJlZXplKFxuICBuZXcgVGltZUludGVydmFsKHtcbiAgICBzdGFydDogbmV3IEp1bGlhbkRhdGUoKSxcbiAgICBzdG9wOiBuZXcgSnVsaWFuRGF0ZSgpLFxuICAgIGlzU3RhcnRJbmNsdWRlZDogZmFsc2UsXG4gICAgaXNTdG9wSW5jbHVkZWQ6IGZhbHNlLFxuICB9KVxuKTtcblxuLyoqXG4gKiBGdW5jdGlvbiBpbnRlcmZhY2UgZm9yIG1lcmdpbmcgaW50ZXJ2YWwgZGF0YS5cbiAqIEBjYWxsYmFjayBUaW1lSW50ZXJ2YWwuTWVyZ2VDYWxsYmFja1xuICpcbiAqIEBwYXJhbSB7Kn0gbGVmdERhdGEgVGhlIGZpcnN0IGRhdGEgaW5zdGFuY2UuXG4gKiBAcGFyYW0geyp9IHJpZ2h0RGF0YSBUaGUgc2Vjb25kIGRhdGEgaW5zdGFuY2UuXG4gKiBAcmV0dXJucyB7Kn0gVGhlIHJlc3VsdCBvZiBtZXJnaW5nIHRoZSB0d28gZGF0YSBpbnN0YW5jZXMuXG4gKi9cblxuLyoqXG4gKiBGdW5jdGlvbiBpbnRlcmZhY2UgZm9yIGNvbXBhcmluZyBpbnRlcnZhbCBkYXRhLlxuICogQGNhbGxiYWNrIFRpbWVJbnRlcnZhbC5EYXRhQ29tcGFyZXJcbiAqIEBwYXJhbSB7Kn0gbGVmdERhdGEgVGhlIGZpcnN0IGRhdGEgaW5zdGFuY2UuXG4gKiBAcGFyYW0geyp9IHJpZ2h0RGF0YSBUaGUgc2Vjb25kIGRhdGEgaW5zdGFuY2UuXG4gKiBAcmV0dXJucyB7Qm9vbGVhbn0gPGNvZGU+dHJ1ZTwvY29kZT4gaWYgdGhlIHByb3ZpZGVkIGluc3RhbmNlcyBhcmUgZXF1YWwsIDxjb2RlPmZhbHNlPC9jb2RlPiBvdGhlcndpc2UuXG4gKi9cbmV4cG9ydCBkZWZhdWx0IFRpbWVJbnRlcnZhbDtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///77808\n')},46026:function(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__){eval('/* harmony import */ var _binarySearch_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(377);\n/* harmony import */ var _defaultValue_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(62200);\n/* harmony import */ var _defined_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(82982);\n/* harmony import */ var _DeveloperError_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(12572);\n/* harmony import */ var _Event_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(14459);\n/* harmony import */ var _GregorianDate_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(98648);\n/* harmony import */ var _isLeapYear_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(55706);\n/* harmony import */ var _Iso8601_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(22841);\n/* harmony import */ var _JulianDate_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(55293);\n/* harmony import */ var _TimeInterval_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(77808);\n\n\n\n\n\n\n\n\n\n\n\nfunction compareIntervalStartTimes(left, right) {\n  return _JulianDate_js__WEBPACK_IMPORTED_MODULE_6__/* ["default"].compare */ .Z.compare(left.start, right.start);\n}\n\n/**\n * A non-overlapping collection of {@link TimeInterval} instances sorted by start time.\n * @alias TimeIntervalCollection\n * @constructor\n *\n * @param {TimeInterval[]} [intervals] An array of intervals to add to the collection.\n */\nfunction TimeIntervalCollection(intervals) {\n  this._intervals = [];\n  this._changedEvent = new _Event_js__WEBPACK_IMPORTED_MODULE_3__/* ["default"] */ .Z();\n\n  if ((0,_defined_js__WEBPACK_IMPORTED_MODULE_8__/* ["default"] */ .Z)(intervals)) {\n    var length = intervals.length;\n    for (var i = 0; i < length; i++) {\n      this.addInterval(intervals[i]);\n    }\n  }\n}\n\nObject.defineProperties(TimeIntervalCollection.prototype, {\n  /**\n   * Gets an event that is raised whenever the collection of intervals change.\n   * @memberof TimeIntervalCollection.prototype\n   * @type {Event}\n   * @readonly\n   */\n  changedEvent: {\n    get: function () {\n      return this._changedEvent;\n    },\n  },\n\n  /**\n   * Gets the start time of the collection.\n   * @memberof TimeIntervalCollection.prototype\n   * @type {JulianDate}\n   * @readonly\n   */\n  start: {\n    get: function () {\n      var intervals = this._intervals;\n      return intervals.length === 0 ? undefined : intervals[0].start;\n    },\n  },\n\n  /**\n   * Gets whether or not the start time is included in the collection.\n   * @memberof TimeIntervalCollection.prototype\n   * @type {Boolean}\n   * @readonly\n   */\n  isStartIncluded: {\n    get: function () {\n      var intervals = this._intervals;\n      return intervals.length === 0 ? false : intervals[0].isStartIncluded;\n    },\n  },\n\n  /**\n   * Gets the stop time of the collection.\n   * @memberof TimeIntervalCollection.prototype\n   * @type {JulianDate}\n   * @readonly\n   */\n  stop: {\n    get: function () {\n      var intervals = this._intervals;\n      var length = intervals.length;\n      return length === 0 ? undefined : intervals[length - 1].stop;\n    },\n  },\n\n  /**\n   * Gets whether or not the stop time is included in the collection.\n   * @memberof TimeIntervalCollection.prototype\n   * @type {Boolean}\n   * @readonly\n   */\n  isStopIncluded: {\n    get: function () {\n      var intervals = this._intervals;\n      var length = intervals.length;\n      return length === 0 ? false : intervals[length - 1].isStopIncluded;\n    },\n  },\n\n  /**\n   * Gets the number of intervals in the collection.\n   * @memberof TimeIntervalCollection.prototype\n   * @type {Number}\n   * @readonly\n   */\n  length: {\n    get: function () {\n      return this._intervals.length;\n    },\n  },\n\n  /**\n   * Gets whether or not the collection is empty.\n   * @memberof TimeIntervalCollection.prototype\n   * @type {Boolean}\n   * @readonly\n   */\n  isEmpty: {\n    get: function () {\n      return this._intervals.length === 0;\n    },\n  },\n});\n\n/**\n * Compares this instance against the provided instance componentwise and returns\n * <code>true</code> if they are equal, <code>false</code> otherwise.\n *\n * @param {TimeIntervalCollection} [right] The right hand side collection.\n * @param {TimeInterval.DataComparer} [dataComparer] A function which compares the data of the two intervals.  If omitted, reference equality is used.\n * @returns {Boolean} <code>true</code> if they are equal, <code>false</code> otherwise.\n */\nTimeIntervalCollection.prototype.equals = function (right, dataComparer) {\n  if (this === right) {\n    return true;\n  }\n  if (!(right instanceof TimeIntervalCollection)) {\n    return false;\n  }\n  var intervals = this._intervals;\n  var rightIntervals = right._intervals;\n  var length = intervals.length;\n  if (length !== rightIntervals.length) {\n    return false;\n  }\n  for (var i = 0; i < length; i++) {\n    if (!_TimeInterval_js__WEBPACK_IMPORTED_MODULE_7__/* ["default"].equals */ .Z.equals(intervals[i], rightIntervals[i], dataComparer)) {\n      return false;\n    }\n  }\n  return true;\n};\n\n/**\n * Gets the interval at the specified index.\n *\n * @param {Number} index The index of the interval to retrieve.\n * @returns {TimeInterval|undefined} The interval at the specified index, or <code>undefined</code> if no interval exists as that index.\n */\nTimeIntervalCollection.prototype.get = function (index) {\n  //>>includeStart(\'debug\', pragmas.debug);\n  if (!(0,_defined_js__WEBPACK_IMPORTED_MODULE_8__/* ["default"] */ .Z)(index)) {\n    throw new _DeveloperError_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"] */ .Z("index is required.");\n  }\n  //>>includeEnd(\'debug\');\n\n  return this._intervals[index];\n};\n\n/**\n * Removes all intervals from the collection.\n */\nTimeIntervalCollection.prototype.removeAll = function () {\n  if (this._intervals.length > 0) {\n    this._intervals.length = 0;\n    this._changedEvent.raiseEvent(this);\n  }\n};\n\n/**\n * Finds and returns the interval that contains the specified date.\n *\n * @param {JulianDate} date The date to search for.\n * @returns {TimeInterval|undefined} The interval containing the specified date, <code>undefined</code> if no such interval exists.\n */\nTimeIntervalCollection.prototype.findIntervalContainingDate = function (date) {\n  var index = this.indexOf(date);\n  return index >= 0 ? this._intervals[index] : undefined;\n};\n\n/**\n * Finds and returns the data for the interval that contains the specified date.\n *\n * @param {JulianDate} date The date to search for.\n * @returns {Object} The data for the interval containing the specified date, or <code>undefined</code> if no such interval exists.\n */\nTimeIntervalCollection.prototype.findDataForIntervalContainingDate = function (\n  date\n) {\n  var index = this.indexOf(date);\n  return index >= 0 ? this._intervals[index].data : undefined;\n};\n\n/**\n * Checks if the specified date is inside this collection.\n *\n * @param {JulianDate} julianDate The date to check.\n * @returns {Boolean} <code>true</code> if the collection contains the specified date, <code>false</code> otherwise.\n */\nTimeIntervalCollection.prototype.contains = function (julianDate) {\n  return this.indexOf(julianDate) >= 0;\n};\n\nvar indexOfScratch = new _TimeInterval_js__WEBPACK_IMPORTED_MODULE_7__/* ["default"] */ .Z();\n\n/**\n * Finds and returns the index of the interval in the collection that contains the specified date.\n *\n * @param {JulianDate} date The date to search for.\n * @returns {Number} The index of the interval that contains the specified date, if no such interval exists,\n * it returns a negative number which is the bitwise complement of the index of the next interval that\n * starts after the date, or if no interval starts after the specified date, the bitwise complement of\n * the length of the collection.\n */\nTimeIntervalCollection.prototype.indexOf = function (date) {\n  //>>includeStart(\'debug\', pragmas.debug);\n  if (!(0,_defined_js__WEBPACK_IMPORTED_MODULE_8__/* ["default"] */ .Z)(date)) {\n    throw new _DeveloperError_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"] */ .Z("date is required");\n  }\n  //>>includeEnd(\'debug\');\n\n  var intervals = this._intervals;\n  indexOfScratch.start = date;\n  indexOfScratch.stop = date;\n  var index = (0,_binarySearch_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .Z)(\n    intervals,\n    indexOfScratch,\n    compareIntervalStartTimes\n  );\n  if (index >= 0) {\n    if (intervals[index].isStartIncluded) {\n      return index;\n    }\n\n    if (\n      index > 0 &&\n      intervals[index - 1].stop.equals(date) &&\n      intervals[index - 1].isStopIncluded\n    ) {\n      return index - 1;\n    }\n    return ~index;\n  }\n\n  index = ~index;\n  if (\n    index > 0 &&\n    index - 1 < intervals.length &&\n    _TimeInterval_js__WEBPACK_IMPORTED_MODULE_7__/* ["default"].contains */ .Z.contains(intervals[index - 1], date)\n  ) {\n    return index - 1;\n  }\n  return ~index;\n};\n\n/**\n * Returns the first interval in the collection that matches the specified parameters.\n * All parameters are optional and <code>undefined</code> parameters are treated as a don\'t care condition.\n *\n * @param {Object} [options] Object with the following properties:\n * @param {JulianDate} [options.start] The start time of the interval.\n * @param {JulianDate} [options.stop] The stop time of the interval.\n * @param {Boolean} [options.isStartIncluded] <code>true</code> if <code>options.start</code> is included in the interval, <code>false</code> otherwise.\n * @param {Boolean} [options.isStopIncluded] <code>true</code> if <code>options.stop</code> is included in the interval, <code>false</code> otherwise.\n * @returns {TimeInterval|undefined} The first interval in the collection that matches the specified parameters.\n */\nTimeIntervalCollection.prototype.findInterval = function (options) {\n  options = (0,_defaultValue_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .Z)(options, _defaultValue_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"].EMPTY_OBJECT */ .Z.EMPTY_OBJECT);\n  var start = options.start;\n  var stop = options.stop;\n  var isStartIncluded = options.isStartIncluded;\n  var isStopIncluded = options.isStopIncluded;\n\n  var intervals = this._intervals;\n  for (var i = 0, len = intervals.length; i < len; i++) {\n    var interval = intervals[i];\n    if (\n      (!(0,_defined_js__WEBPACK_IMPORTED_MODULE_8__/* ["default"] */ .Z)(start) || interval.start.equals(start)) &&\n      (!(0,_defined_js__WEBPACK_IMPORTED_MODULE_8__/* ["default"] */ .Z)(stop) || interval.stop.equals(stop)) &&\n      (!(0,_defined_js__WEBPACK_IMPORTED_MODULE_8__/* ["default"] */ .Z)(isStartIncluded) ||\n        interval.isStartIncluded === isStartIncluded) &&\n      (!(0,_defined_js__WEBPACK_IMPORTED_MODULE_8__/* ["default"] */ .Z)(isStopIncluded) || interval.isStopIncluded === isStopIncluded)\n    ) {\n      return intervals[i];\n    }\n  }\n  return undefined;\n};\n\n/**\n * Adds an interval to the collection, merging intervals that contain the same data and\n * splitting intervals of different data as needed in order to maintain a non-overlapping collection.\n * The data in the new interval takes precedence over any existing intervals in the collection.\n *\n * @param {TimeInterval} interval The interval to add.\n * @param {TimeInterval.DataComparer} [dataComparer] A function which compares the data of the two intervals.  If omitted, reference equality is used.\n */\nTimeIntervalCollection.prototype.addInterval = function (\n  interval,\n  dataComparer\n) {\n  //>>includeStart(\'debug\', pragmas.debug);\n  if (!(0,_defined_js__WEBPACK_IMPORTED_MODULE_8__/* ["default"] */ .Z)(interval)) {\n    throw new _DeveloperError_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"] */ .Z("interval is required");\n  }\n  //>>includeEnd(\'debug\');\n\n  if (interval.isEmpty) {\n    return;\n  }\n\n  var intervals = this._intervals;\n\n  // Handle the common case quickly: we\'re adding a new interval which is after all existing intervals.\n  if (\n    intervals.length === 0 ||\n    _JulianDate_js__WEBPACK_IMPORTED_MODULE_6__/* ["default"].greaterThan */ .Z.greaterThan(interval.start, intervals[intervals.length - 1].stop)\n  ) {\n    intervals.push(interval);\n    this._changedEvent.raiseEvent(this);\n    return;\n  }\n\n  // Keep the list sorted by the start date\n  var index = (0,_binarySearch_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .Z)(intervals, interval, compareIntervalStartTimes);\n  if (index < 0) {\n    index = ~index;\n  } else {\n    // interval\'s start date exactly equals the start date of at least one interval in the collection.\n    // It could actually equal the start date of two intervals if one of them does not actually\n    // include the date.  In that case, the binary search could have found either.  We need to\n    // look at the surrounding intervals and their IsStartIncluded properties in order to make sure\n    // we\'re working with the correct interval.\n\n    // eslint-disable-next-line no-lonely-if\n    if (\n      index > 0 &&\n      interval.isStartIncluded &&\n      intervals[index - 1].isStartIncluded &&\n      intervals[index - 1].start.equals(interval.start)\n    ) {\n      --index;\n    } else if (\n      index < intervals.length &&\n      !interval.isStartIncluded &&\n      intervals[index].isStartIncluded &&\n      intervals[index].start.equals(interval.start)\n    ) {\n      ++index;\n    }\n  }\n\n  var comparison;\n  if (index > 0) {\n    // Not the first thing in the list, so see if the interval before this one\n    // overlaps this one.\n\n    comparison = _JulianDate_js__WEBPACK_IMPORTED_MODULE_6__/* ["default"].compare */ .Z.compare(intervals[index - 1].stop, interval.start);\n    if (\n      comparison > 0 ||\n      (comparison === 0 &&\n        (intervals[index - 1].isStopIncluded || interval.isStartIncluded))\n    ) {\n      // There is an overlap\n      if (\n        (0,_defined_js__WEBPACK_IMPORTED_MODULE_8__/* ["default"] */ .Z)(dataComparer)\n          ? dataComparer(intervals[index - 1].data, interval.data)\n          : intervals[index - 1].data === interval.data\n      ) {\n        // Overlapping intervals have the same data, so combine them\n        if (_JulianDate_js__WEBPACK_IMPORTED_MODULE_6__/* ["default"].greaterThan */ .Z.greaterThan(interval.stop, intervals[index - 1].stop)) {\n          interval = new _TimeInterval_js__WEBPACK_IMPORTED_MODULE_7__/* ["default"] */ .Z({\n            start: intervals[index - 1].start,\n            stop: interval.stop,\n            isStartIncluded: intervals[index - 1].isStartIncluded,\n            isStopIncluded: interval.isStopIncluded,\n            data: interval.data,\n          });\n        } else {\n          interval = new _TimeInterval_js__WEBPACK_IMPORTED_MODULE_7__/* ["default"] */ .Z({\n            start: intervals[index - 1].start,\n            stop: intervals[index - 1].stop,\n            isStartIncluded: intervals[index - 1].isStartIncluded,\n            isStopIncluded:\n              intervals[index - 1].isStopIncluded ||\n              (interval.stop.equals(intervals[index - 1].stop) &&\n                interval.isStopIncluded),\n            data: interval.data,\n          });\n        }\n        intervals.splice(index - 1, 1);\n        --index;\n      } else {\n        // Overlapping intervals have different data.  The new interval\n        // being added \'wins\' so truncate the previous interval.\n        // If the existing interval extends past the end of the new one,\n        // split the existing interval into two intervals.\n        comparison = _JulianDate_js__WEBPACK_IMPORTED_MODULE_6__/* ["default"].compare */ .Z.compare(\n          intervals[index - 1].stop,\n          interval.stop\n        );\n        if (\n          comparison > 0 ||\n          (comparison === 0 &&\n            intervals[index - 1].isStopIncluded &&\n            !interval.isStopIncluded)\n        ) {\n          intervals.splice(\n            index,\n            0,\n            new _TimeInterval_js__WEBPACK_IMPORTED_MODULE_7__/* ["default"] */ .Z({\n              start: interval.stop,\n              stop: intervals[index - 1].stop,\n              isStartIncluded: !interval.isStopIncluded,\n              isStopIncluded: intervals[index - 1].isStopIncluded,\n              data: intervals[index - 1].data,\n            })\n          );\n        }\n        intervals[index - 1] = new _TimeInterval_js__WEBPACK_IMPORTED_MODULE_7__/* ["default"] */ .Z({\n          start: intervals[index - 1].start,\n          stop: interval.start,\n          isStartIncluded: intervals[index - 1].isStartIncluded,\n          isStopIncluded: !interval.isStartIncluded,\n          data: intervals[index - 1].data,\n        });\n      }\n    }\n  }\n\n  while (index < intervals.length) {\n    // Not the last thing in the list, so see if the intervals after this one overlap this one.\n    comparison = _JulianDate_js__WEBPACK_IMPORTED_MODULE_6__/* ["default"].compare */ .Z.compare(interval.stop, intervals[index].start);\n    if (\n      comparison > 0 ||\n      (comparison === 0 &&\n        (interval.isStopIncluded || intervals[index].isStartIncluded))\n    ) {\n      // There is an overlap\n      if (\n        (0,_defined_js__WEBPACK_IMPORTED_MODULE_8__/* ["default"] */ .Z)(dataComparer)\n          ? dataComparer(intervals[index].data, interval.data)\n          : intervals[index].data === interval.data\n      ) {\n        // Overlapping intervals have the same data, so combine them\n        interval = new _TimeInterval_js__WEBPACK_IMPORTED_MODULE_7__/* ["default"] */ .Z({\n          start: interval.start,\n          stop: _JulianDate_js__WEBPACK_IMPORTED_MODULE_6__/* ["default"].greaterThan */ .Z.greaterThan(intervals[index].stop, interval.stop)\n            ? intervals[index].stop\n            : interval.stop,\n          isStartIncluded: interval.isStartIncluded,\n          isStopIncluded: _JulianDate_js__WEBPACK_IMPORTED_MODULE_6__/* ["default"].greaterThan */ .Z.greaterThan(\n            intervals[index].stop,\n            interval.stop\n          )\n            ? intervals[index].isStopIncluded\n            : interval.isStopIncluded,\n          data: interval.data,\n        });\n        intervals.splice(index, 1);\n      } else {\n        // Overlapping intervals have different data.  The new interval\n        // being added \'wins\' so truncate the next interval.\n        intervals[index] = new _TimeInterval_js__WEBPACK_IMPORTED_MODULE_7__/* ["default"] */ .Z({\n          start: interval.stop,\n          stop: intervals[index].stop,\n          isStartIncluded: !interval.isStopIncluded,\n          isStopIncluded: intervals[index].isStopIncluded,\n          data: intervals[index].data,\n        });\n\n        if (intervals[index].isEmpty) {\n          intervals.splice(index, 1);\n        } else {\n          // Found a partial span, so it is not possible for the next\n          // interval to be spanned at all.  Stop looking.\n          break;\n        }\n      }\n    } else {\n      // Found the last one we\'re spanning, so stop looking.\n      break;\n    }\n  }\n\n  // Add the new interval\n  intervals.splice(index, 0, interval);\n  this._changedEvent.raiseEvent(this);\n};\n\n/**\n * Removes the specified interval from this interval collection, creating a hole over the specified interval.\n * The data property of the input interval is ignored.\n *\n * @param {TimeInterval} interval The interval to remove.\n * @returns {Boolean} <code>true</code> if the interval was removed, <code>false</code> if no part of the interval was in the collection.\n */\nTimeIntervalCollection.prototype.removeInterval = function (interval) {\n  //>>includeStart(\'debug\', pragmas.debug);\n  if (!(0,_defined_js__WEBPACK_IMPORTED_MODULE_8__/* ["default"] */ .Z)(interval)) {\n    throw new _DeveloperError_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"] */ .Z("interval is required");\n  }\n  //>>includeEnd(\'debug\');\n\n  if (interval.isEmpty) {\n    return false;\n  }\n\n  var intervals = this._intervals;\n\n  var index = (0,_binarySearch_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .Z)(intervals, interval, compareIntervalStartTimes);\n  if (index < 0) {\n    index = ~index;\n  }\n\n  var result = false;\n\n  // Check for truncation of the end of the previous interval.\n  if (\n    index > 0 &&\n    (_JulianDate_js__WEBPACK_IMPORTED_MODULE_6__/* ["default"].greaterThan */ .Z.greaterThan(intervals[index - 1].stop, interval.start) ||\n      (intervals[index - 1].stop.equals(interval.start) &&\n        intervals[index - 1].isStopIncluded &&\n        interval.isStartIncluded))\n  ) {\n    result = true;\n\n    if (\n      _JulianDate_js__WEBPACK_IMPORTED_MODULE_6__/* ["default"].greaterThan */ .Z.greaterThan(intervals[index - 1].stop, interval.stop) ||\n      (intervals[index - 1].isStopIncluded &&\n        !interval.isStopIncluded &&\n        intervals[index - 1].stop.equals(interval.stop))\n    ) {\n      // Break the existing interval into two pieces\n      intervals.splice(\n        index,\n        0,\n        new _TimeInterval_js__WEBPACK_IMPORTED_MODULE_7__/* ["default"] */ .Z({\n          start: interval.stop,\n          stop: intervals[index - 1].stop,\n          isStartIncluded: !interval.isStopIncluded,\n          isStopIncluded: intervals[index - 1].isStopIncluded,\n          data: intervals[index - 1].data,\n        })\n      );\n    }\n    intervals[index - 1] = new _TimeInterval_js__WEBPACK_IMPORTED_MODULE_7__/* ["default"] */ .Z({\n      start: intervals[index - 1].start,\n      stop: interval.start,\n      isStartIncluded: intervals[index - 1].isStartIncluded,\n      isStopIncluded: !interval.isStartIncluded,\n      data: intervals[index - 1].data,\n    });\n  }\n\n  // Check if the Start of the current interval should remain because interval.start is the same but\n  // it is not included.\n  if (\n    index < intervals.length &&\n    !interval.isStartIncluded &&\n    intervals[index].isStartIncluded &&\n    interval.start.equals(intervals[index].start)\n  ) {\n    result = true;\n\n    intervals.splice(\n      index,\n      0,\n      new _TimeInterval_js__WEBPACK_IMPORTED_MODULE_7__/* ["default"] */ .Z({\n        start: intervals[index].start,\n        stop: intervals[index].start,\n        isStartIncluded: true,\n        isStopIncluded: true,\n        data: intervals[index].data,\n      })\n    );\n    ++index;\n  }\n\n  // Remove any intervals that are completely overlapped by the input interval.\n  while (\n    index < intervals.length &&\n    _JulianDate_js__WEBPACK_IMPORTED_MODULE_6__/* ["default"].greaterThan */ .Z.greaterThan(interval.stop, intervals[index].stop)\n  ) {\n    result = true;\n    intervals.splice(index, 1);\n  }\n\n  // Check for the case where the input interval ends on the same date\n  // as an existing interval.\n  if (index < intervals.length && interval.stop.equals(intervals[index].stop)) {\n    result = true;\n\n    if (!interval.isStopIncluded && intervals[index].isStopIncluded) {\n      // Last point of interval should remain because the stop date is included in\n      // the existing interval but is not included in the input interval.\n      if (\n        index + 1 < intervals.length &&\n        intervals[index + 1].start.equals(interval.stop) &&\n        intervals[index].data === intervals[index + 1].data\n      ) {\n        // Combine single point with the next interval\n        intervals.splice(index, 1);\n        intervals[index] = new _TimeInterval_js__WEBPACK_IMPORTED_MODULE_7__/* ["default"] */ .Z({\n          start: intervals[index].start,\n          stop: intervals[index].stop,\n          isStartIncluded: true,\n          isStopIncluded: intervals[index].isStopIncluded,\n          data: intervals[index].data,\n        });\n      } else {\n        intervals[index] = new _TimeInterval_js__WEBPACK_IMPORTED_MODULE_7__/* ["default"] */ .Z({\n          start: interval.stop,\n          stop: interval.stop,\n          isStartIncluded: true,\n          isStopIncluded: true,\n          data: intervals[index].data,\n        });\n      }\n    } else {\n      // Interval is completely overlapped\n      intervals.splice(index, 1);\n    }\n  }\n\n  // Truncate any partially-overlapped intervals.\n  if (\n    index < intervals.length &&\n    (_JulianDate_js__WEBPACK_IMPORTED_MODULE_6__/* ["default"].greaterThan */ .Z.greaterThan(interval.stop, intervals[index].start) ||\n      (interval.stop.equals(intervals[index].start) &&\n        interval.isStopIncluded &&\n        intervals[index].isStartIncluded))\n  ) {\n    result = true;\n    intervals[index] = new _TimeInterval_js__WEBPACK_IMPORTED_MODULE_7__/* ["default"] */ .Z({\n      start: interval.stop,\n      stop: intervals[index].stop,\n      isStartIncluded: !interval.isStopIncluded,\n      isStopIncluded: intervals[index].isStopIncluded,\n      data: intervals[index].data,\n    });\n  }\n\n  if (result) {\n    this._changedEvent.raiseEvent(this);\n  }\n\n  return result;\n};\n\n/**\n * Creates a new instance that is the intersection of this collection and the provided collection.\n *\n * @param {TimeIntervalCollection} other The collection to intersect with.\n * @param {TimeInterval.DataComparer} [dataComparer] A function which compares the data of the two intervals.  If omitted, reference equality is used.\n * @param {TimeInterval.MergeCallback} [mergeCallback] A function which merges the data of the two intervals. If omitted, the data from the left interval will be used.\n * @returns {TimeIntervalCollection} A new TimeIntervalCollection which is the intersection of this collection and the provided collection.\n */\nTimeIntervalCollection.prototype.intersect = function (\n  other,\n  dataComparer,\n  mergeCallback\n) {\n  //>>includeStart(\'debug\', pragmas.debug);\n  if (!(0,_defined_js__WEBPACK_IMPORTED_MODULE_8__/* ["default"] */ .Z)(other)) {\n    throw new _DeveloperError_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"] */ .Z("other is required.");\n  }\n  //>>includeEnd(\'debug\');\n\n  var result = new TimeIntervalCollection();\n  var left = 0;\n  var right = 0;\n  var intervals = this._intervals;\n  var otherIntervals = other._intervals;\n\n  while (left < intervals.length && right < otherIntervals.length) {\n    var leftInterval = intervals[left];\n    var rightInterval = otherIntervals[right];\n    if (_JulianDate_js__WEBPACK_IMPORTED_MODULE_6__/* ["default"].lessThan */ .Z.lessThan(leftInterval.stop, rightInterval.start)) {\n      ++left;\n    } else if (_JulianDate_js__WEBPACK_IMPORTED_MODULE_6__/* ["default"].lessThan */ .Z.lessThan(rightInterval.stop, leftInterval.start)) {\n      ++right;\n    } else {\n      // The following will return an intersection whose data is \'merged\' if the callback is defined\n      if (\n        (0,_defined_js__WEBPACK_IMPORTED_MODULE_8__/* ["default"] */ .Z)(mergeCallback) ||\n        ((0,_defined_js__WEBPACK_IMPORTED_MODULE_8__/* ["default"] */ .Z)(dataComparer) &&\n          dataComparer(leftInterval.data, rightInterval.data)) ||\n        (!(0,_defined_js__WEBPACK_IMPORTED_MODULE_8__/* ["default"] */ .Z)(dataComparer) && rightInterval.data === leftInterval.data)\n      ) {\n        var intersection = _TimeInterval_js__WEBPACK_IMPORTED_MODULE_7__/* ["default"].intersect */ .Z.intersect(\n          leftInterval,\n          rightInterval,\n          new _TimeInterval_js__WEBPACK_IMPORTED_MODULE_7__/* ["default"] */ .Z(),\n          mergeCallback\n        );\n        if (!intersection.isEmpty) {\n          // Since we start with an empty collection for \'result\', and there are no overlapping intervals in \'this\' (as a rule),\n          // the \'intersection\' will never overlap with a previous interval in \'result\'.  So, no need to do any additional \'merging\'.\n          result.addInterval(intersection, dataComparer);\n        }\n      }\n\n      if (\n        _JulianDate_js__WEBPACK_IMPORTED_MODULE_6__/* ["default"].lessThan */ .Z.lessThan(leftInterval.stop, rightInterval.stop) ||\n        (leftInterval.stop.equals(rightInterval.stop) &&\n          !leftInterval.isStopIncluded &&\n          rightInterval.isStopIncluded)\n      ) {\n        ++left;\n      } else {\n        ++right;\n      }\n    }\n  }\n  return result;\n};\n\n/**\n * Creates a new instance from a JulianDate array.\n *\n * @param {Object} options Object with the following properties:\n * @param {JulianDate[]} options.julianDates An array of ISO 8601 dates.\n * @param {Boolean} [options.isStartIncluded=true] <code>true</code> if start time is included in the interval, <code>false</code> otherwise.\n * @param {Boolean} [options.isStopIncluded=true] <code>true</code> if stop time is included in the interval, <code>false</code> otherwise.\n * @param {Boolean} [options.leadingInterval=false] <code>true</code> if you want to add a interval from Iso8601.MINIMUM_VALUE to start time,  <code>false</code> otherwise.\n * @param {Boolean} [options.trailingInterval=false] <code>true</code> if you want to add a interval from stop time to Iso8601.MAXIMUM_VALUE,  <code>false</code> otherwise.\n * @param {Function} [options.dataCallback] A function that will be return the data that is called with each interval before it is added to the collection. If unspecified, the data will be the index in the collection.\n * @param {TimeIntervalCollection} [result] An existing instance to use for the result.\n * @returns {TimeIntervalCollection} The modified result parameter or a new instance if none was provided.\n */\nTimeIntervalCollection.fromJulianDateArray = function (options, result) {\n  //>>includeStart(\'debug\', pragmas.debug);\n  if (!(0,_defined_js__WEBPACK_IMPORTED_MODULE_8__/* ["default"] */ .Z)(options)) {\n    throw new _DeveloperError_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"] */ .Z("options is required.");\n  }\n  if (!(0,_defined_js__WEBPACK_IMPORTED_MODULE_8__/* ["default"] */ .Z)(options.julianDates)) {\n    throw new _DeveloperError_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"] */ .Z("options.iso8601Array is required.");\n  }\n  //>>includeEnd(\'debug\');\n\n  if (!(0,_defined_js__WEBPACK_IMPORTED_MODULE_8__/* ["default"] */ .Z)(result)) {\n    result = new TimeIntervalCollection();\n  }\n\n  var julianDates = options.julianDates;\n  var length = julianDates.length;\n  var dataCallback = options.dataCallback;\n\n  var isStartIncluded = (0,_defaultValue_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .Z)(options.isStartIncluded, true);\n  var isStopIncluded = (0,_defaultValue_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .Z)(options.isStopIncluded, true);\n  var leadingInterval = (0,_defaultValue_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .Z)(options.leadingInterval, false);\n  var trailingInterval = (0,_defaultValue_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .Z)(options.trailingInterval, false);\n  var interval;\n\n  // Add a default interval, which will only end up being used up to first interval\n  var startIndex = 0;\n  if (leadingInterval) {\n    ++startIndex;\n    interval = new _TimeInterval_js__WEBPACK_IMPORTED_MODULE_7__/* ["default"] */ .Z({\n      start: _Iso8601_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"].MINIMUM_VALUE */ .Z.MINIMUM_VALUE,\n      stop: julianDates[0],\n      isStartIncluded: true,\n      isStopIncluded: !isStartIncluded,\n    });\n    interval.data = (0,_defined_js__WEBPACK_IMPORTED_MODULE_8__/* ["default"] */ .Z)(dataCallback)\n      ? dataCallback(interval, result.length)\n      : result.length;\n    result.addInterval(interval);\n  }\n\n  for (var i = 0; i < length - 1; ++i) {\n    var startDate = julianDates[i];\n    var endDate = julianDates[i + 1];\n\n    interval = new _TimeInterval_js__WEBPACK_IMPORTED_MODULE_7__/* ["default"] */ .Z({\n      start: startDate,\n      stop: endDate,\n      isStartIncluded: result.length === startIndex ? isStartIncluded : true,\n      isStopIncluded: i === length - 2 ? isStopIncluded : false,\n    });\n    interval.data = (0,_defined_js__WEBPACK_IMPORTED_MODULE_8__/* ["default"] */ .Z)(dataCallback)\n      ? dataCallback(interval, result.length)\n      : result.length;\n    result.addInterval(interval);\n\n    startDate = endDate;\n  }\n\n  if (trailingInterval) {\n    interval = new _TimeInterval_js__WEBPACK_IMPORTED_MODULE_7__/* ["default"] */ .Z({\n      start: julianDates[length - 1],\n      stop: _Iso8601_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"].MAXIMUM_VALUE */ .Z.MAXIMUM_VALUE,\n      isStartIncluded: !isStopIncluded,\n      isStopIncluded: true,\n    });\n    interval.data = (0,_defined_js__WEBPACK_IMPORTED_MODULE_8__/* ["default"] */ .Z)(dataCallback)\n      ? dataCallback(interval, result.length)\n      : result.length;\n    result.addInterval(interval);\n  }\n\n  return result;\n};\n\nvar scratchGregorianDate = new _GregorianDate_js__WEBPACK_IMPORTED_MODULE_9__/* ["default"] */ .Z();\nvar monthLengths = [0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];\n\n/**\n * Adds duration represented as a GregorianDate to a JulianDate\n *\n * @param {JulianDate} julianDate The date.\n * @param {GregorianDate} duration An duration represented as a GregorianDate.\n * @param {JulianDate} result An existing instance to use for the result.\n * @returns {JulianDate} The modified result parameter.\n *\n * @private\n */\nfunction addToDate(julianDate, duration, result) {\n  if (!(0,_defined_js__WEBPACK_IMPORTED_MODULE_8__/* ["default"] */ .Z)(result)) {\n    result = new _JulianDate_js__WEBPACK_IMPORTED_MODULE_6__/* ["default"] */ .Z();\n  }\n  _JulianDate_js__WEBPACK_IMPORTED_MODULE_6__/* ["default"].toGregorianDate */ .Z.toGregorianDate(julianDate, scratchGregorianDate);\n\n  var millisecond = scratchGregorianDate.millisecond + duration.millisecond;\n  var second = scratchGregorianDate.second + duration.second;\n  var minute = scratchGregorianDate.minute + duration.minute;\n  var hour = scratchGregorianDate.hour + duration.hour;\n  var day = scratchGregorianDate.day + duration.day;\n  var month = scratchGregorianDate.month + duration.month;\n  var year = scratchGregorianDate.year + duration.year;\n\n  if (millisecond >= 1000) {\n    second += Math.floor(millisecond / 1000);\n    millisecond = millisecond % 1000;\n  }\n\n  if (second >= 60) {\n    minute += Math.floor(second / 60);\n    second = second % 60;\n  }\n\n  if (minute >= 60) {\n    hour += Math.floor(minute / 60);\n    minute = minute % 60;\n  }\n\n  if (hour >= 24) {\n    day += Math.floor(hour / 24);\n    hour = hour % 24;\n  }\n\n  // If days is greater than the month\'s length we need to remove those number of days,\n  //  readjust month and year and repeat until days is less than the month\'s length.\n  monthLengths[2] = (0,_isLeapYear_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .Z)(year) ? 29 : 28;\n  while (day > monthLengths[month] || month >= 13) {\n    if (day > monthLengths[month]) {\n      day -= monthLengths[month];\n      ++month;\n    }\n\n    if (month >= 13) {\n      --month;\n      year += Math.floor(month / 12);\n      month = month % 12;\n      ++month;\n    }\n\n    monthLengths[2] = (0,_isLeapYear_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .Z)(year) ? 29 : 28;\n  }\n\n  scratchGregorianDate.millisecond = millisecond;\n  scratchGregorianDate.second = second;\n  scratchGregorianDate.minute = minute;\n  scratchGregorianDate.hour = hour;\n  scratchGregorianDate.day = day;\n  scratchGregorianDate.month = month;\n  scratchGregorianDate.year = year;\n\n  return _JulianDate_js__WEBPACK_IMPORTED_MODULE_6__/* ["default"].fromGregorianDate */ .Z.fromGregorianDate(scratchGregorianDate, result);\n}\n\nvar scratchJulianDate = new _JulianDate_js__WEBPACK_IMPORTED_MODULE_6__/* ["default"] */ .Z();\nvar durationRegex = /P(?:([\\d.,]+)Y)?(?:([\\d.,]+)M)?(?:([\\d.,]+)W)?(?:([\\d.,]+)D)?(?:T(?:([\\d.,]+)H)?(?:([\\d.,]+)M)?(?:([\\d.,]+)S)?)?/;\n\n/**\n * Parses ISO8601 duration string\n *\n * @param {String} iso8601 An ISO 8601 duration.\n * @param {GregorianDate} result An existing instance to use for the result.\n * @returns {Boolean} True is parsing succeeded, false otherwise\n *\n * @private\n */\nfunction parseDuration(iso8601, result) {\n  if (!(0,_defined_js__WEBPACK_IMPORTED_MODULE_8__/* ["default"] */ .Z)(iso8601) || iso8601.length === 0) {\n    return false;\n  }\n\n  // Reset object\n  result.year = 0;\n  result.month = 0;\n  result.day = 0;\n  result.hour = 0;\n  result.minute = 0;\n  result.second = 0;\n  result.millisecond = 0;\n\n  if (iso8601[0] === "P") {\n    var matches = iso8601.match(durationRegex);\n    if (!(0,_defined_js__WEBPACK_IMPORTED_MODULE_8__/* ["default"] */ .Z)(matches)) {\n      return false;\n    }\n    if ((0,_defined_js__WEBPACK_IMPORTED_MODULE_8__/* ["default"] */ .Z)(matches[1])) {\n      // Years\n      result.year = Number(matches[1].replace(",", "."));\n    }\n    if ((0,_defined_js__WEBPACK_IMPORTED_MODULE_8__/* ["default"] */ .Z)(matches[2])) {\n      // Months\n      result.month = Number(matches[2].replace(",", "."));\n    }\n    if ((0,_defined_js__WEBPACK_IMPORTED_MODULE_8__/* ["default"] */ .Z)(matches[3])) {\n      // Weeks\n      result.day = Number(matches[3].replace(",", ".")) * 7;\n    }\n    if ((0,_defined_js__WEBPACK_IMPORTED_MODULE_8__/* ["default"] */ .Z)(matches[4])) {\n      // Days\n      result.day += Number(matches[4].replace(",", "."));\n    }\n    if ((0,_defined_js__WEBPACK_IMPORTED_MODULE_8__/* ["default"] */ .Z)(matches[5])) {\n      // Hours\n      result.hour = Number(matches[5].replace(",", "."));\n    }\n    if ((0,_defined_js__WEBPACK_IMPORTED_MODULE_8__/* ["default"] */ .Z)(matches[6])) {\n      // Weeks\n      result.minute = Number(matches[6].replace(",", "."));\n    }\n    if ((0,_defined_js__WEBPACK_IMPORTED_MODULE_8__/* ["default"] */ .Z)(matches[7])) {\n      // Seconds\n      var seconds = Number(matches[7].replace(",", "."));\n      result.second = Math.floor(seconds);\n      result.millisecond = (seconds % 1) * 1000;\n    }\n  } else {\n    // They can technically specify the duration as a normal date with some caveats. Try our best to load it.\n    if (iso8601[iso8601.length - 1] !== "Z") {\n      // It\'s not a date, its a duration, so it always has to be UTC\n      iso8601 += "Z";\n    }\n    _JulianDate_js__WEBPACK_IMPORTED_MODULE_6__/* ["default"].toGregorianDate */ .Z.toGregorianDate(\n      _JulianDate_js__WEBPACK_IMPORTED_MODULE_6__/* ["default"].fromIso8601 */ .Z.fromIso8601(iso8601, scratchJulianDate),\n      result\n    );\n  }\n\n  // A duration of 0 will cause an infinite loop, so just make sure something is non-zero\n  return (\n    result.year ||\n    result.month ||\n    result.day ||\n    result.hour ||\n    result.minute ||\n    result.second ||\n    result.millisecond\n  );\n}\n\nvar scratchDuration = new _GregorianDate_js__WEBPACK_IMPORTED_MODULE_9__/* ["default"] */ .Z();\n/**\n * Creates a new instance from an {@link http://en.wikipedia.org/wiki/ISO_8601|ISO 8601} time interval (start/end/duration).\n *\n * @param {Object} options Object with the following properties:\n * @param {String} options.iso8601 An ISO 8601 interval.\n * @param {Boolean} [options.isStartIncluded=true] <code>true</code> if start time is included in the interval, <code>false</code> otherwise.\n * @param {Boolean} [options.isStopIncluded=true] <code>true</code> if stop time is included in the interval, <code>false</code> otherwise.\n * @param {Boolean} [options.leadingInterval=false] <code>true</code> if you want to add a interval from Iso8601.MINIMUM_VALUE to start time,  <code>false</code> otherwise.\n * @param {Boolean} [options.trailingInterval=false] <code>true</code> if you want to add a interval from stop time to Iso8601.MAXIMUM_VALUE,  <code>false</code> otherwise.\n * @param {Function} [options.dataCallback] A function that will be return the data that is called with each interval before it is added to the collection. If unspecified, the data will be the index in the collection.\n * @param {TimeIntervalCollection} [result] An existing instance to use for the result.\n * @returns {TimeIntervalCollection} The modified result parameter or a new instance if none was provided.\n */\nTimeIntervalCollection.fromIso8601 = function (options, result) {\n  //>>includeStart(\'debug\', pragmas.debug);\n  if (!(0,_defined_js__WEBPACK_IMPORTED_MODULE_8__/* ["default"] */ .Z)(options)) {\n    throw new _DeveloperError_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"] */ .Z("options is required.");\n  }\n  if (!(0,_defined_js__WEBPACK_IMPORTED_MODULE_8__/* ["default"] */ .Z)(options.iso8601)) {\n    throw new _DeveloperError_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"] */ .Z("options.iso8601 is required.");\n  }\n  //>>includeEnd(\'debug\');\n\n  var dates = options.iso8601.split("/");\n  var start = _JulianDate_js__WEBPACK_IMPORTED_MODULE_6__/* ["default"].fromIso8601 */ .Z.fromIso8601(dates[0]);\n  var stop = _JulianDate_js__WEBPACK_IMPORTED_MODULE_6__/* ["default"].fromIso8601 */ .Z.fromIso8601(dates[1]);\n  var julianDates = [];\n\n  if (!parseDuration(dates[2], scratchDuration)) {\n    julianDates.push(start, stop);\n  } else {\n    var date = _JulianDate_js__WEBPACK_IMPORTED_MODULE_6__/* ["default"].clone */ .Z.clone(start);\n    julianDates.push(date);\n    while (_JulianDate_js__WEBPACK_IMPORTED_MODULE_6__/* ["default"].compare */ .Z.compare(date, stop) < 0) {\n      date = addToDate(date, scratchDuration);\n      var afterStop = _JulianDate_js__WEBPACK_IMPORTED_MODULE_6__/* ["default"].compare */ .Z.compare(stop, date) <= 0;\n      if (afterStop) {\n        _JulianDate_js__WEBPACK_IMPORTED_MODULE_6__/* ["default"].clone */ .Z.clone(stop, date);\n      }\n\n      julianDates.push(date);\n    }\n  }\n\n  return TimeIntervalCollection.fromJulianDateArray(\n    {\n      julianDates: julianDates,\n      isStartIncluded: options.isStartIncluded,\n      isStopIncluded: options.isStopIncluded,\n      leadingInterval: options.leadingInterval,\n      trailingInterval: options.trailingInterval,\n      dataCallback: options.dataCallback,\n    },\n    result\n  );\n};\n\n/**\n * Creates a new instance from a {@link http://en.wikipedia.org/wiki/ISO_8601|ISO 8601} date array.\n *\n * @param {Object} options Object with the following properties:\n * @param {String[]} options.iso8601Dates An array of ISO 8601 dates.\n * @param {Boolean} [options.isStartIncluded=true] <code>true</code> if start time is included in the interval, <code>false</code> otherwise.\n * @param {Boolean} [options.isStopIncluded=true] <code>true</code> if stop time is included in the interval, <code>false</code> otherwise.\n * @param {Boolean} [options.leadingInterval=false] <code>true</code> if you want to add a interval from Iso8601.MINIMUM_VALUE to start time,  <code>false</code> otherwise.\n * @param {Boolean} [options.trailingInterval=false] <code>true</code> if you want to add a interval from stop time to Iso8601.MAXIMUM_VALUE,  <code>false</code> otherwise.\n * @param {Function} [options.dataCallback] A function that will be return the data that is called with each interval before it is added to the collection. If unspecified, the data will be the index in the collection.\n * @param {TimeIntervalCollection} [result] An existing instance to use for the result.\n * @returns {TimeIntervalCollection} The modified result parameter or a new instance if none was provided.\n */\nTimeIntervalCollection.fromIso8601DateArray = function (options, result) {\n  //>>includeStart(\'debug\', pragmas.debug);\n  if (!(0,_defined_js__WEBPACK_IMPORTED_MODULE_8__/* ["default"] */ .Z)(options)) {\n    throw new _DeveloperError_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"] */ .Z("options is required.");\n  }\n  if (!(0,_defined_js__WEBPACK_IMPORTED_MODULE_8__/* ["default"] */ .Z)(options.iso8601Dates)) {\n    throw new _DeveloperError_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"] */ .Z("options.iso8601Dates is required.");\n  }\n  //>>includeEnd(\'debug\');\n\n  return TimeIntervalCollection.fromJulianDateArray(\n    {\n      julianDates: options.iso8601Dates.map(function (date) {\n        return _JulianDate_js__WEBPACK_IMPORTED_MODULE_6__/* ["default"].fromIso8601 */ .Z.fromIso8601(date);\n      }),\n      isStartIncluded: options.isStartIncluded,\n      isStopIncluded: options.isStopIncluded,\n      leadingInterval: options.leadingInterval,\n      trailingInterval: options.trailingInterval,\n      dataCallback: options.dataCallback,\n    },\n    result\n  );\n};\n\n/**\n * Creates a new instance from a {@link http://en.wikipedia.org/wiki/ISO_8601|ISO 8601} duration array.\n *\n * @param {Object} options Object with the following properties:\n * @param {JulianDate} options.epoch An date that the durations are relative to.\n * @param {String} options.iso8601Durations An array of ISO 8601 durations.\n * @param {Boolean} [options.relativeToPrevious=false] <code>true</code> if durations are relative to previous date, <code>false</code> if always relative to the epoch.\n * @param {Boolean} [options.isStartIncluded=true] <code>true</code> if start time is included in the interval, <code>false</code> otherwise.\n * @param {Boolean} [options.isStopIncluded=true] <code>true</code> if stop time is included in the interval, <code>false</code> otherwise.\n * @param {Boolean} [options.leadingInterval=false] <code>true</code> if you want to add a interval from Iso8601.MINIMUM_VALUE to start time,  <code>false</code> otherwise.\n * @param {Boolean} [options.trailingInterval=false] <code>true</code> if you want to add a interval from stop time to Iso8601.MAXIMUM_VALUE,  <code>false</code> otherwise.\n * @param {Function} [options.dataCallback] A function that will be return the data that is called with each interval before it is added to the collection. If unspecified, the data will be the index in the collection.\n * @param {TimeIntervalCollection} [result] An existing instance to use for the result.\n * @returns {TimeIntervalCollection} The modified result parameter or a new instance if none was provided.\n */\nTimeIntervalCollection.fromIso8601DurationArray = function (options, result) {\n  //>>includeStart(\'debug\', pragmas.debug);\n  if (!(0,_defined_js__WEBPACK_IMPORTED_MODULE_8__/* ["default"] */ .Z)(options)) {\n    throw new _DeveloperError_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"] */ .Z("options is required.");\n  }\n  if (!(0,_defined_js__WEBPACK_IMPORTED_MODULE_8__/* ["default"] */ .Z)(options.epoch)) {\n    throw new _DeveloperError_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"] */ .Z("options.epoch is required.");\n  }\n  if (!(0,_defined_js__WEBPACK_IMPORTED_MODULE_8__/* ["default"] */ .Z)(options.iso8601Durations)) {\n    throw new _DeveloperError_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"] */ .Z("options.iso8601Durations is required.");\n  }\n  //>>includeEnd(\'debug\');\n\n  var epoch = options.epoch;\n  var iso8601Durations = options.iso8601Durations;\n  var relativeToPrevious = (0,_defaultValue_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .Z)(options.relativeToPrevious, false);\n  var julianDates = [];\n  var date, previousDate;\n\n  var length = iso8601Durations.length;\n  for (var i = 0; i < length; ++i) {\n    // Allow a duration of 0 on the first iteration, because then it is just the epoch\n    if (parseDuration(iso8601Durations[i], scratchDuration) || i === 0) {\n      if (relativeToPrevious && (0,_defined_js__WEBPACK_IMPORTED_MODULE_8__/* ["default"] */ .Z)(previousDate)) {\n        date = addToDate(previousDate, scratchDuration);\n      } else {\n        date = addToDate(epoch, scratchDuration);\n      }\n      julianDates.push(date);\n      previousDate = date;\n    }\n  }\n\n  return TimeIntervalCollection.fromJulianDateArray(\n    {\n      julianDates: julianDates,\n      isStartIncluded: options.isStartIncluded,\n      isStopIncluded: options.isStopIncluded,\n      leadingInterval: options.leadingInterval,\n      trailingInterval: options.trailingInterval,\n      dataCallback: options.dataCallback,\n    },\n    result\n  );\n};\n/* harmony default export */ __webpack_exports__["Z"] = (TimeIntervalCollection);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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O0FBQ0EseURBQWUsc0JBQXNCLEVBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly92dWUzLXdlYnBhY2s1Ly4vbm9kZV9tb2R1bGVzL2Nlc2l1bS9Tb3VyY2UvQ29yZS9UaW1lSW50ZXJ2YWxDb2xsZWN0aW9uLmpzP2JmZmEiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IGJpbmFyeVNlYXJjaCBmcm9tIFwiLi9iaW5hcnlTZWFyY2guanNcIjtcbmltcG9ydCBkZWZhdWx0VmFsdWUgZnJvbSBcIi4vZGVmYXVsdFZhbHVlLmpzXCI7XG5pbXBvcnQgZGVmaW5lZCBmcm9tIFwiLi9kZWZpbmVkLmpzXCI7XG5pbXBvcnQgRGV2ZWxvcGVyRXJyb3IgZnJvbSBcIi4vRGV2ZWxvcGVyRXJyb3IuanNcIjtcbmltcG9ydCBFdmVudCBmcm9tIFwiLi9FdmVudC5qc1wiO1xuaW1wb3J0IEdyZWdvcmlhbkRhdGUgZnJvbSBcIi4vR3JlZ29yaWFuRGF0ZS5qc1wiO1xuaW1wb3J0IGlzTGVhcFllYXIgZnJvbSBcIi4vaXNMZWFwWWVhci5qc1wiO1xuaW1wb3J0IElzbzg2MDEgZnJvbSBcIi4vSXNvODYwMS5qc1wiO1xuaW1wb3J0IEp1bGlhbkRhdGUgZnJvbSBcIi4vSnVsaWFuRGF0ZS5qc1wiO1xuaW1wb3J0IFRpbWVJbnRlcnZhbCBmcm9tIFwiLi9UaW1lSW50ZXJ2YWwuanNcIjtcblxuZnVuY3Rpb24gY29tcGFyZUludGVydmFsU3RhcnRUaW1lcyhsZWZ0LCByaWdodCkge1xuICByZXR1cm4gSnVsaWFuRGF0ZS5jb21wYXJlKGxlZnQuc3RhcnQsIHJpZ2h0LnN0YXJ0KTtcbn1cblxuLyoqXG4gKiBBIG5vbi1vdmVybGFwcGluZyBjb2xsZWN0aW9uIG9mIHtAbGluayBUaW1lSW50ZXJ2YWx9IGluc3RhbmNlcyBzb3J0ZWQgYnkgc3RhcnQgdGltZS5cbiAqIEBhbGlhcyBUaW1lSW50ZXJ2YWxDb2xsZWN0aW9uXG4gKiBAY29uc3RydWN0b3JcbiAqXG4gKiBAcGFyYW0ge1RpbWVJbnRlcnZhbFtdfSBbaW50ZXJ2YWxzXSBBbiBhcnJheSBvZiBpbnRlcnZhbHMgdG8gYWRkIHRvIHRoZSBjb2xsZWN0aW9uLlxuICovXG5mdW5jdGlvbiBUaW1lSW50ZXJ2YWxDb2xsZWN0aW9uKGludGVydmFscykge1xuICB0aGlzLl9pbnRlcnZhbHMgPSBbXTtcbiAgdGhpcy5fY2hhbmdlZEV2ZW50ID0gbmV3IEV2ZW50KCk7XG5cbiAgaWYgKGRlZmluZWQoaW50ZXJ2YWxzKSkge1xuICAgIHZhciBsZW5ndGggPSBpbnRlcnZhbHMubGVuZ3RoO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgIHRoaXMuYWRkSW50ZXJ2YWwoaW50ZXJ2YWxzW2ldKTtcbiAgICB9XG4gIH1cbn1cblxuT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoVGltZUludGVydmFsQ29sbGVjdGlvbi5wcm90b3R5cGUsIHtcbiAgLyoqXG4gICAqIEdldHMgYW4gZXZlbnQgdGhhdCBpcyByYWlzZWQgd2hlbmV2ZXIgdGhlIGNvbGxlY3Rpb24gb2YgaW50ZXJ2YWxzIGNoYW5nZS5cbiAgICogQG1lbWJlcm9mIFRpbWVJbnRlcnZhbENvbGxlY3Rpb24ucHJvdG90eXBlXG4gICAqIEB0eXBlIHtFdmVudH1cbiAgICogQHJlYWRvbmx5XG4gICAqL1xuICBjaGFuZ2VkRXZlbnQ6IHtcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9jaGFuZ2VkRXZlbnQ7XG4gICAgfSxcbiAgfSxcblxuICAvKipcbiAgICogR2V0cyB0aGUgc3RhcnQgdGltZSBvZiB0aGUgY29sbGVjdGlvbi5cbiAgICogQG1lbWJlcm9mIFRpbWVJbnRlcnZhbENvbGxlY3Rpb24ucHJvdG90eXBlXG4gICAqIEB0eXBlIHtKdWxpYW5EYXRlfVxuICAgKiBAcmVhZG9ubHlcbiAgICovXG4gIHN0YXJ0OiB7XG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgaW50ZXJ2YWxzID0gdGhpcy5faW50ZXJ2YWxzO1xuICAgICAgcmV0dXJuIGludGVydmFscy5sZW5ndGggPT09IDAgPyB1bmRlZmluZWQgOiBpbnRlcnZhbHNbMF0uc3RhcnQ7XG4gICAgfSxcbiAgfSxcblxuICAvKipcbiAgICogR2V0cyB3aGV0aGVyIG9yIG5vdCB0aGUgc3RhcnQgdGltZSBpcyBpbmNsdWRlZCBpbiB0aGUgY29sbGVjdGlvbi5cbiAgICogQG1lbWJlcm9mIFRpbWVJbnRlcnZhbENvbGxlY3Rpb24ucHJvdG90eXBlXG4gICAqIEB0eXBlIHtCb29sZWFufVxuICAgKiBAcmVhZG9ubHlcbiAgICovXG4gIGlzU3RhcnRJbmNsdWRlZDoge1xuICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIGludGVydmFscyA9IHRoaXMuX2ludGVydmFscztcbiAgICAgIHJldHVybiBpbnRlcnZhbHMubGVuZ3RoID09PSAwID8gZmFsc2UgOiBpbnRlcnZhbHNbMF0uaXNTdGFydEluY2x1ZGVkO1xuICAgIH0sXG4gIH0sXG5cbiAgLyoqXG4gICAqIEdldHMgdGhlIHN0b3AgdGltZSBvZiB0aGUgY29sbGVjdGlvbi5cbiAgICogQG1lbWJlcm9mIFRpbWVJbnRlcnZhbENvbGxlY3Rpb24ucHJvdG90eXBlXG4gICAqIEB0eXBlIHtKdWxpYW5EYXRlfVxuICAgKiBAcmVhZG9ubHlcbiAgICovXG4gIHN0b3A6IHtcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBpbnRlcnZhbHMgPSB0aGlzLl9pbnRlcnZhbHM7XG4gICAgICB2YXIgbGVuZ3RoID0gaW50ZXJ2YWxzLmxlbmd0aDtcbiAgICAgIHJldHVybiBsZW5ndGggPT09IDAgPyB1bmRlZmluZWQgOiBpbnRlcnZhbHNbbGVuZ3RoIC0gMV0uc3RvcDtcbiAgICB9LFxuICB9LFxuXG4gIC8qKlxuICAgKiBHZXRzIHdoZXRoZXIgb3Igbm90IHRoZSBzdG9wIHRpbWUgaXMgaW5jbHVkZWQgaW4gdGhlIGNvbGxlY3Rpb24uXG4gICAqIEBtZW1iZXJvZiBUaW1lSW50ZXJ2YWxDb2xsZWN0aW9uLnByb3RvdHlwZVxuICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICogQHJlYWRvbmx5XG4gICAqL1xuICBpc1N0b3BJbmNsdWRlZDoge1xuICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIGludGVydmFscyA9IHRoaXMuX2ludGVydmFscztcbiAgICAgIHZhciBsZW5ndGggPSBpbnRlcnZhbHMubGVuZ3RoO1xuICAgICAgcmV0dXJuIGxlbmd0aCA9PT0gMCA/IGZhbHNlIDogaW50ZXJ2YWxzW2xlbmd0aCAtIDFdLmlzU3RvcEluY2x1ZGVkO1xuICAgIH0sXG4gIH0sXG5cbiAgLyoqXG4gICAqIEdldHMgdGhlIG51bWJlciBvZiBpbnRlcnZhbHMgaW4gdGhlIGNvbGxlY3Rpb24uXG4gICAqIEBtZW1iZXJvZiBUaW1lSW50ZXJ2YWxDb2xsZWN0aW9uLnByb3RvdHlwZVxuICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgKiBAcmVhZG9ubHlcbiAgICovXG4gIGxlbmd0aDoge1xuICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX2ludGVydmFscy5sZW5ndGg7XG4gICAgfSxcbiAgfSxcblxuICAvKipcbiAgICogR2V0cyB3aGV0aGVyIG9yIG5vdCB0aGUgY29sbGVjdGlvbiBpcyBlbXB0eS5cbiAgICogQG1lbWJlcm9mIFRpbWVJbnRlcnZhbENvbGxlY3Rpb24ucHJvdG90eXBlXG4gICAqIEB0eXBlIHtCb29sZWFufVxuICAgKiBAcmVhZG9ubHlcbiAgICovXG4gIGlzRW1wdHk6IHtcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9pbnRlcnZhbHMubGVuZ3RoID09PSAwO1xuICAgIH0sXG4gIH0sXG59KTtcblxuLyoqXG4gKiBDb21wYXJlcyB0aGlzIGluc3RhbmNlIGFnYWluc3QgdGhlIHByb3ZpZGVkIGluc3RhbmNlIGNvbXBvbmVudHdpc2UgYW5kIHJldHVybnNcbiAqIDxjb2RlPnRydWU8L2NvZGU+IGlmIHRoZXkgYXJlIGVxdWFsLCA8Y29kZT5mYWxzZTwvY29kZT4gb3RoZXJ3aXNlLlxuICpcbiAqIEBwYXJhbSB7VGltZUludGVydmFsQ29sbGVjdGlvbn0gW3JpZ2h0XSBUaGUgcmlnaHQgaGFuZCBzaWRlIGNvbGxlY3Rpb24uXG4gKiBAcGFyYW0ge1RpbWVJbnRlcnZhbC5EYXRhQ29tcGFyZXJ9IFtkYXRhQ29tcGFyZXJdIEEgZnVuY3Rpb24gd2hpY2ggY29tcGFyZXMgdGhlIGRhdGEgb2YgdGhlIHR3byBpbnRlcnZhbHMuICBJZiBvbWl0dGVkLCByZWZlcmVuY2UgZXF1YWxpdHkgaXMgdXNlZC5cbiAqIEByZXR1cm5zIHtCb29sZWFufSA8Y29kZT50cnVlPC9jb2RlPiBpZiB0aGV5IGFyZSBlcXVhbCwgPGNvZGU+ZmFsc2U8L2NvZGU+IG90aGVyd2lzZS5cbiAqL1xuVGltZUludGVydmFsQ29sbGVjdGlvbi5wcm90b3R5cGUuZXF1YWxzID0gZnVuY3Rpb24gKHJpZ2h0LCBkYXRhQ29tcGFyZXIpIHtcbiAgaWYgKHRoaXMgPT09IHJpZ2h0KSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgaWYgKCEocmlnaHQgaW5zdGFuY2VvZiBUaW1lSW50ZXJ2YWxDb2xsZWN0aW9uKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICB2YXIgaW50ZXJ2YWxzID0gdGhpcy5faW50ZXJ2YWxzO1xuICB2YXIgcmlnaHRJbnRlcnZhbHMgPSByaWdodC5faW50ZXJ2YWxzO1xuICB2YXIgbGVuZ3RoID0gaW50ZXJ2YWxzLmxlbmd0aDtcbiAgaWYgKGxlbmd0aCAhPT0gcmlnaHRJbnRlcnZhbHMubGVuZ3RoKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICBpZiAoIVRpbWVJbnRlcnZhbC5lcXVhbHMoaW50ZXJ2YWxzW2ldLCByaWdodEludGVydmFsc1tpXSwgZGF0YUNvbXBhcmVyKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn07XG5cbi8qKlxuICogR2V0cyB0aGUgaW50ZXJ2YWwgYXQgdGhlIHNwZWNpZmllZCBpbmRleC5cbiAqXG4gKiBAcGFyYW0ge051bWJlcn0gaW5kZXggVGhlIGluZGV4IG9mIHRoZSBpbnRlcnZhbCB0byByZXRyaWV2ZS5cbiAqIEByZXR1cm5zIHtUaW1lSW50ZXJ2YWx8dW5kZWZpbmVkfSBUaGUgaW50ZXJ2YWwgYXQgdGhlIHNwZWNpZmllZCBpbmRleCwgb3IgPGNvZGU+dW5kZWZpbmVkPC9jb2RlPiBpZiBubyBpbnRlcnZhbCBleGlzdHMgYXMgdGhhdCBpbmRleC5cbiAqL1xuVGltZUludGVydmFsQ29sbGVjdGlvbi5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gKGluZGV4KSB7XG4gIC8vPj5pbmNsdWRlU3RhcnQoJ2RlYnVnJywgcHJhZ21hcy5kZWJ1Zyk7XG4gIGlmICghZGVmaW5lZChpbmRleCkpIHtcbiAgICB0aHJvdyBuZXcgRGV2ZWxvcGVyRXJyb3IoXCJpbmRleCBpcyByZXF1aXJlZC5cIik7XG4gIH1cbiAgLy8+PmluY2x1ZGVFbmQoJ2RlYnVnJyk7XG5cbiAgcmV0dXJuIHRoaXMuX2ludGVydmFsc1tpbmRleF07XG59O1xuXG4vKipcbiAqIFJlbW92ZXMgYWxsIGludGVydmFscyBmcm9tIHRoZSBjb2xsZWN0aW9uLlxuICovXG5UaW1lSW50ZXJ2YWxDb2xsZWN0aW9uLnByb3RvdHlwZS5yZW1vdmVBbGwgPSBmdW5jdGlvbiAoKSB7XG4gIGlmICh0aGlzLl9pbnRlcnZhbHMubGVuZ3RoID4gMCkge1xuICAgIHRoaXMuX2ludGVydmFscy5sZW5ndGggPSAwO1xuICAgIHRoaXMuX2NoYW5nZWRFdmVudC5yYWlzZUV2ZW50KHRoaXMpO1xuICB9XG59O1xuXG4vKipcbiAqIEZpbmRzIGFuZCByZXR1cm5zIHRoZSBpbnRlcnZhbCB0aGF0IGNvbnRhaW5zIHRoZSBzcGVjaWZpZWQgZGF0ZS5cbiAqXG4gKiBAcGFyYW0ge0p1bGlhbkRhdGV9IGRhdGUgVGhlIGRhdGUgdG8gc2VhcmNoIGZvci5cbiAqIEByZXR1cm5zIHtUaW1lSW50ZXJ2YWx8dW5kZWZpbmVkfSBUaGUgaW50ZXJ2YWwgY29udGFpbmluZyB0aGUgc3BlY2lmaWVkIGRhdGUsIDxjb2RlPnVuZGVmaW5lZDwvY29kZT4gaWYgbm8gc3VjaCBpbnRlcnZhbCBleGlzdHMuXG4gKi9cblRpbWVJbnRlcnZhbENvbGxlY3Rpb24ucHJvdG90eXBlLmZpbmRJbnRlcnZhbENvbnRhaW5pbmdEYXRlID0gZnVuY3Rpb24gKGRhdGUpIHtcbiAgdmFyIGluZGV4ID0gdGhpcy5pbmRleE9mKGRhdGUpO1xuICByZXR1cm4gaW5kZXggPj0gMCA/IHRoaXMuX2ludGVydmFsc1tpbmRleF0gOiB1bmRlZmluZWQ7XG59O1xuXG4vKipcbiAqIEZpbmRzIGFuZCByZXR1cm5zIHRoZSBkYXRhIGZvciB0aGUgaW50ZXJ2YWwgdGhhdCBjb250YWlucyB0aGUgc3BlY2lmaWVkIGRhdGUuXG4gKlxuICogQHBhcmFtIHtKdWxpYW5EYXRlfSBkYXRlIFRoZSBkYXRlIHRvIHNlYXJjaCBmb3IuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBUaGUgZGF0YSBmb3IgdGhlIGludGVydmFsIGNvbnRhaW5pbmcgdGhlIHNwZWNpZmllZCBkYXRlLCBvciA8Y29kZT51bmRlZmluZWQ8L2NvZGU+IGlmIG5vIHN1Y2ggaW50ZXJ2YWwgZXhpc3RzLlxuICovXG5UaW1lSW50ZXJ2YWxDb2xsZWN0aW9uLnByb3RvdHlwZS5maW5kRGF0YUZvckludGVydmFsQ29udGFpbmluZ0RhdGUgPSBmdW5jdGlvbiAoXG4gIGRhdGVcbikge1xuICB2YXIgaW5kZXggPSB0aGlzLmluZGV4T2YoZGF0ZSk7XG4gIHJldHVybiBpbmRleCA+PSAwID8gdGhpcy5faW50ZXJ2YWxzW2luZGV4XS5kYXRhIDogdW5kZWZpbmVkO1xufTtcblxuLyoqXG4gKiBDaGVja3MgaWYgdGhlIHNwZWNpZmllZCBkYXRlIGlzIGluc2lkZSB0aGlzIGNvbGxlY3Rpb24uXG4gKlxuICogQHBhcmFtIHtKdWxpYW5EYXRlfSBqdWxpYW5EYXRlIFRoZSBkYXRlIHRvIGNoZWNrLlxuICogQHJldHVybnMge0Jvb2xlYW59IDxjb2RlPnRydWU8L2NvZGU+IGlmIHRoZSBjb2xsZWN0aW9uIGNvbnRhaW5zIHRoZSBzcGVjaWZpZWQgZGF0ZSwgPGNvZGU+ZmFsc2U8L2NvZGU+IG90aGVyd2lzZS5cbiAqL1xuVGltZUludGVydmFsQ29sbGVjdGlvbi5wcm90b3R5cGUuY29udGFpbnMgPSBmdW5jdGlvbiAoanVsaWFuRGF0ZSkge1xuICByZXR1cm4gdGhpcy5pbmRleE9mKGp1bGlhbkRhdGUpID49IDA7XG59O1xuXG52YXIgaW5kZXhPZlNjcmF0Y2ggPSBuZXcgVGltZUludGVydmFsKCk7XG5cbi8qKlxuICogRmluZHMgYW5kIHJldHVybnMgdGhlIGluZGV4IG9mIHRoZSBpbnRlcnZhbCBpbiB0aGUgY29sbGVjdGlvbiB0aGF0IGNvbnRhaW5zIHRoZSBzcGVjaWZpZWQgZGF0ZS5cbiAqXG4gKiBAcGFyYW0ge0p1bGlhbkRhdGV9IGRhdGUgVGhlIGRhdGUgdG8gc2VhcmNoIGZvci5cbiAqIEByZXR1cm5zIHtOdW1iZXJ9IFRoZSBpbmRleCBvZiB0aGUgaW50ZXJ2YWwgdGhhdCBjb250YWlucyB0aGUgc3BlY2lmaWVkIGRhdGUsIGlmIG5vIHN1Y2ggaW50ZXJ2YWwgZXhpc3RzLFxuICogaXQgcmV0dXJucyBhIG5lZ2F0aXZlIG51bWJlciB3aGljaCBpcyB0aGUgYml0d2lzZSBjb21wbGVtZW50IG9mIHRoZSBpbmRleCBvZiB0aGUgbmV4dCBpbnRlcnZhbCB0aGF0XG4gKiBzdGFydHMgYWZ0ZXIgdGhlIGRhdGUsIG9yIGlmIG5vIGludGVydmFsIHN0YXJ0cyBhZnRlciB0aGUgc3BlY2lmaWVkIGRhdGUsIHRoZSBiaXR3aXNlIGNvbXBsZW1lbnQgb2ZcbiAqIHRoZSBsZW5ndGggb2YgdGhlIGNvbGxlY3Rpb24uXG4gKi9cblRpbWVJbnRlcnZhbENvbGxlY3Rpb24ucHJvdG90eXBlLmluZGV4T2YgPSBmdW5jdGlvbiAoZGF0ZSkge1xuICAvLz4+aW5jbHVkZVN0YXJ0KCdkZWJ1ZycsIHByYWdtYXMuZGVidWcpO1xuICBpZiAoIWRlZmluZWQoZGF0ZSkpIHtcbiAgICB0aHJvdyBuZXcgRGV2ZWxvcGVyRXJyb3IoXCJkYXRlIGlzIHJlcXVpcmVkXCIpO1xuICB9XG4gIC8vPj5pbmNsdWRlRW5kKCdkZWJ1ZycpO1xuXG4gIHZhciBpbnRlcnZhbHMgPSB0aGlzLl9pbnRlcnZhbHM7XG4gIGluZGV4T2ZTY3JhdGNoLnN0YXJ0ID0gZGF0ZTtcbiAgaW5kZXhPZlNjcmF0Y2guc3RvcCA9IGRhdGU7XG4gIHZhciBpbmRleCA9IGJpbmFyeVNlYXJjaChcbiAgICBpbnRlcnZhbHMsXG4gICAgaW5kZXhPZlNjcmF0Y2gsXG4gICAgY29tcGFyZUludGVydmFsU3RhcnRUaW1lc1xuICApO1xuICBpZiAoaW5kZXggPj0gMCkge1xuICAgIGlmIChpbnRlcnZhbHNbaW5kZXhdLmlzU3RhcnRJbmNsdWRlZCkge1xuICAgICAgcmV0dXJuIGluZGV4O1xuICAgIH1cblxuICAgIGlmIChcbiAgICAgIGluZGV4ID4gMCAmJlxuICAgICAgaW50ZXJ2YWxzW2luZGV4IC0gMV0uc3RvcC5lcXVhbHMoZGF0ZSkgJiZcbiAgICAgIGludGVydmFsc1tpbmRleCAtIDFdLmlzU3RvcEluY2x1ZGVkXG4gICAgKSB7XG4gICAgICByZXR1cm4gaW5kZXggLSAxO1xuICAgIH1cbiAgICByZXR1cm4gfmluZGV4O1xuICB9XG5cbiAgaW5kZXggPSB+aW5kZXg7XG4gIGlmIChcbiAgICBpbmRleCA+IDAgJiZcbiAgICBpbmRleCAtIDEgPCBpbnRlcnZhbHMubGVuZ3RoICYmXG4gICAgVGltZUludGVydmFsLmNvbnRhaW5zKGludGVydmFsc1tpbmRleCAtIDFdLCBkYXRlKVxuICApIHtcbiAgICByZXR1cm4gaW5kZXggLSAxO1xuICB9XG4gIHJldHVybiB+aW5kZXg7XG59O1xuXG4vKipcbiAqIFJldHVybnMgdGhlIGZpcnN0IGludGVydmFsIGluIHRoZSBjb2xsZWN0aW9uIHRoYXQgbWF0Y2hlcyB0aGUgc3BlY2lmaWVkIHBhcmFtZXRlcnMuXG4gKiBBbGwgcGFyYW1ldGVycyBhcmUgb3B0aW9uYWwgYW5kIDxjb2RlPnVuZGVmaW5lZDwvY29kZT4gcGFyYW1ldGVycyBhcmUgdHJlYXRlZCBhcyBhIGRvbid0IGNhcmUgY29uZGl0aW9uLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gT2JqZWN0IHdpdGggdGhlIGZvbGxvd2luZyBwcm9wZXJ0aWVzOlxuICogQHBhcmFtIHtKdWxpYW5EYXRlfSBbb3B0aW9ucy5zdGFydF0gVGhlIHN0YXJ0IHRpbWUgb2YgdGhlIGludGVydmFsLlxuICogQHBhcmFtIHtKdWxpYW5EYXRlfSBbb3B0aW9ucy5zdG9wXSBUaGUgc3RvcCB0aW1lIG9mIHRoZSBpbnRlcnZhbC5cbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMuaXNTdGFydEluY2x1ZGVkXSA8Y29kZT50cnVlPC9jb2RlPiBpZiA8Y29kZT5vcHRpb25zLnN0YXJ0PC9jb2RlPiBpcyBpbmNsdWRlZCBpbiB0aGUgaW50ZXJ2YWwsIDxjb2RlPmZhbHNlPC9jb2RlPiBvdGhlcndpc2UuXG4gKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLmlzU3RvcEluY2x1ZGVkXSA8Y29kZT50cnVlPC9jb2RlPiBpZiA8Y29kZT5vcHRpb25zLnN0b3A8L2NvZGU+IGlzIGluY2x1ZGVkIGluIHRoZSBpbnRlcnZhbCwgPGNvZGU+ZmFsc2U8L2NvZGU+IG90aGVyd2lzZS5cbiAqIEByZXR1cm5zIHtUaW1lSW50ZXJ2YWx8dW5kZWZpbmVkfSBUaGUgZmlyc3QgaW50ZXJ2YWwgaW4gdGhlIGNvbGxlY3Rpb24gdGhhdCBtYXRjaGVzIHRoZSBzcGVjaWZpZWQgcGFyYW1ldGVycy5cbiAqL1xuVGltZUludGVydmFsQ29sbGVjdGlvbi5wcm90b3R5cGUuZmluZEludGVydmFsID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgb3B0aW9ucyA9IGRlZmF1bHRWYWx1ZShvcHRpb25zLCBkZWZhdWx0VmFsdWUuRU1QVFlfT0JKRUNUKTtcbiAgdmFyIHN0YXJ0ID0gb3B0aW9ucy5zdGFydDtcbiAgdmFyIHN0b3AgPSBvcHRpb25zLnN0b3A7XG4gIHZhciBpc1N0YXJ0SW5jbHVkZWQgPSBvcHRpb25zLmlzU3RhcnRJbmNsdWRlZDtcbiAgdmFyIGlzU3RvcEluY2x1ZGVkID0gb3B0aW9ucy5pc1N0b3BJbmNsdWRlZDtcblxuICB2YXIgaW50ZXJ2YWxzID0gdGhpcy5faW50ZXJ2YWxzO1xuICBmb3IgKHZhciBpID0gMCwgbGVuID0gaW50ZXJ2YWxzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgdmFyIGludGVydmFsID0gaW50ZXJ2YWxzW2ldO1xuICAgIGlmIChcbiAgICAgICghZGVmaW5lZChzdGFydCkgfHwgaW50ZXJ2YWwuc3RhcnQuZXF1YWxzKHN0YXJ0KSkgJiZcbiAgICAgICghZGVmaW5lZChzdG9wKSB8fCBpbnRlcnZhbC5zdG9wLmVxdWFscyhzdG9wKSkgJiZcbiAgICAgICghZGVmaW5lZChpc1N0YXJ0SW5jbHVkZWQpIHx8XG4gICAgICAgIGludGVydmFsLmlzU3RhcnRJbmNsdWRlZCA9PT0gaXNTdGFydEluY2x1ZGVkKSAmJlxuICAgICAgKCFkZWZpbmVkKGlzU3RvcEluY2x1ZGVkKSB8fCBpbnRlcnZhbC5pc1N0b3BJbmNsdWRlZCA9PT0gaXNTdG9wSW5jbHVkZWQpXG4gICAgKSB7XG4gICAgICByZXR1cm4gaW50ZXJ2YWxzW2ldO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdW5kZWZpbmVkO1xufTtcblxuLyoqXG4gKiBBZGRzIGFuIGludGVydmFsIHRvIHRoZSBjb2xsZWN0aW9uLCBtZXJnaW5nIGludGVydmFscyB0aGF0IGNvbnRhaW4gdGhlIHNhbWUgZGF0YSBhbmRcbiAqIHNwbGl0dGluZyBpbnRlcnZhbHMgb2YgZGlmZmVyZW50IGRhdGEgYXMgbmVlZGVkIGluIG9yZGVyIHRvIG1haW50YWluIGEgbm9uLW92ZXJsYXBwaW5nIGNvbGxlY3Rpb24uXG4gKiBUaGUgZGF0YSBpbiB0aGUgbmV3IGludGVydmFsIHRha2VzIHByZWNlZGVuY2Ugb3ZlciBhbnkgZXhpc3RpbmcgaW50ZXJ2YWxzIGluIHRoZSBjb2xsZWN0aW9uLlxuICpcbiAqIEBwYXJhbSB7VGltZUludGVydmFsfSBpbnRlcnZhbCBUaGUgaW50ZXJ2YWwgdG8gYWRkLlxuICogQHBhcmFtIHtUaW1lSW50ZXJ2YWwuRGF0YUNvbXBhcmVyfSBbZGF0YUNvbXBhcmVyXSBBIGZ1bmN0aW9uIHdoaWNoIGNvbXBhcmVzIHRoZSBkYXRhIG9mIHRoZSB0d28gaW50ZXJ2YWxzLiAgSWYgb21pdHRlZCwgcmVmZXJlbmNlIGVxdWFsaXR5IGlzIHVzZWQuXG4gKi9cblRpbWVJbnRlcnZhbENvbGxlY3Rpb24ucHJvdG90eXBlLmFkZEludGVydmFsID0gZnVuY3Rpb24gKFxuICBpbnRlcnZhbCxcbiAgZGF0YUNvbXBhcmVyXG4pIHtcbiAgLy8+PmluY2x1ZGVTdGFydCgnZGVidWcnLCBwcmFnbWFzLmRlYnVnKTtcbiAgaWYgKCFkZWZpbmVkKGludGVydmFsKSkge1xuICAgIHRocm93IG5ldyBEZXZlbG9wZXJFcnJvcihcImludGVydmFsIGlzIHJlcXVpcmVkXCIpO1xuICB9XG4gIC8vPj5pbmNsdWRlRW5kKCdkZWJ1ZycpO1xuXG4gIGlmIChpbnRlcnZhbC5pc0VtcHR5KSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIGludGVydmFscyA9IHRoaXMuX2ludGVydmFscztcblxuICAvLyBIYW5kbGUgdGhlIGNvbW1vbiBjYXNlIHF1aWNrbHk6IHdlJ3JlIGFkZGluZyBhIG5ldyBpbnRlcnZhbCB3aGljaCBpcyBhZnRlciBhbGwgZXhpc3RpbmcgaW50ZXJ2YWxzLlxuICBpZiAoXG4gICAgaW50ZXJ2YWxzLmxlbmd0aCA9PT0gMCB8fFxuICAgIEp1bGlhbkRhdGUuZ3JlYXRlclRoYW4oaW50ZXJ2YWwuc3RhcnQsIGludGVydmFsc1tpbnRlcnZhbHMubGVuZ3RoIC0gMV0uc3RvcClcbiAgKSB7XG4gICAgaW50ZXJ2YWxzLnB1c2goaW50ZXJ2YWwpO1xuICAgIHRoaXMuX2NoYW5nZWRFdmVudC5yYWlzZUV2ZW50KHRoaXMpO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIC8vIEtlZXAgdGhlIGxpc3Qgc29ydGVkIGJ5IHRoZSBzdGFydCBkYXRlXG4gIHZhciBpbmRleCA9IGJpbmFyeVNlYXJjaChpbnRlcnZhbHMsIGludGVydmFsLCBjb21wYXJlSW50ZXJ2YWxTdGFydFRpbWVzKTtcbiAgaWYgKGluZGV4IDwgMCkge1xuICAgIGluZGV4ID0gfmluZGV4O1xuICB9IGVsc2Uge1xuICAgIC8vIGludGVydmFsJ3Mgc3RhcnQgZGF0ZSBleGFjdGx5IGVxdWFscyB0aGUgc3RhcnQgZGF0ZSBvZiBhdCBsZWFzdCBvbmUgaW50ZXJ2YWwgaW4gdGhlIGNvbGxlY3Rpb24uXG4gICAgLy8gSXQgY291bGQgYWN0dWFsbHkgZXF1YWwgdGhlIHN0YXJ0IGRhdGUgb2YgdHdvIGludGVydmFscyBpZiBvbmUgb2YgdGhlbSBkb2VzIG5vdCBhY3R1YWxseVxuICAgIC8vIGluY2x1ZGUgdGhlIGRhdGUuICBJbiB0aGF0IGNhc2UsIHRoZSBiaW5hcnkgc2VhcmNoIGNvdWxkIGhhdmUgZm91bmQgZWl0aGVyLiAgV2UgbmVlZCB0b1xuICAgIC8vIGxvb2sgYXQgdGhlIHN1cnJvdW5kaW5nIGludGVydmFscyBhbmQgdGhlaXIgSXNTdGFydEluY2x1ZGVkIHByb3BlcnRpZXMgaW4gb3JkZXIgdG8gbWFrZSBzdXJlXG4gICAgLy8gd2UncmUgd29ya2luZyB3aXRoIHRoZSBjb3JyZWN0IGludGVydmFsLlxuXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWxvbmVseS1pZlxuICAgIGlmIChcbiAgICAgIGluZGV4ID4gMCAmJlxuICAgICAgaW50ZXJ2YWwuaXNTdGFydEluY2x1ZGVkICYmXG4gICAgICBpbnRlcnZhbHNbaW5kZXggLSAxXS5pc1N0YXJ0SW5jbHVkZWQgJiZcbiAgICAgIGludGVydmFsc1tpbmRleCAtIDFdLnN0YXJ0LmVxdWFscyhpbnRlcnZhbC5zdGFydClcbiAgICApIHtcbiAgICAgIC0taW5kZXg7XG4gICAgfSBlbHNlIGlmIChcbiAgICAgIGluZGV4IDwgaW50ZXJ2YWxzLmxlbmd0aCAmJlxuICAgICAgIWludGVydmFsLmlzU3RhcnRJbmNsdWRlZCAmJlxuICAgICAgaW50ZXJ2YWxzW2luZGV4XS5pc1N0YXJ0SW5jbHVkZWQgJiZcbiAgICAgIGludGVydmFsc1tpbmRleF0uc3RhcnQuZXF1YWxzKGludGVydmFsLnN0YXJ0KVxuICAgICkge1xuICAgICAgKytpbmRleDtcbiAgICB9XG4gIH1cblxuICB2YXIgY29tcGFyaXNvbjtcbiAgaWYgKGluZGV4ID4gMCkge1xuICAgIC8vIE5vdCB0aGUgZmlyc3QgdGhpbmcgaW4gdGhlIGxpc3QsIHNvIHNlZSBpZiB0aGUgaW50ZXJ2YWwgYmVmb3JlIHRoaXMgb25lXG4gICAgLy8gb3ZlcmxhcHMgdGhpcyBvbmUuXG5cbiAgICBjb21wYXJpc29uID0gSnVsaWFuRGF0ZS5jb21wYXJlKGludGVydmFsc1tpbmRleCAtIDFdLnN0b3AsIGludGVydmFsLnN0YXJ0KTtcbiAgICBpZiAoXG4gICAgICBjb21wYXJpc29uID4gMCB8fFxuICAgICAgKGNvbXBhcmlzb24gPT09IDAgJiZcbiAgICAgICAgKGludGVydmFsc1tpbmRleCAtIDFdLmlzU3RvcEluY2x1ZGVkIHx8IGludGVydmFsLmlzU3RhcnRJbmNsdWRlZCkpXG4gICAgKSB7XG4gICAgICAvLyBUaGVyZSBpcyBhbiBvdmVybGFwXG4gICAgICBpZiAoXG4gICAgICAgIGRlZmluZWQoZGF0YUNvbXBhcmVyKVxuICAgICAgICAgID8gZGF0YUNvbXBhcmVyKGludGVydmFsc1tpbmRleCAtIDFdLmRhdGEsIGludGVydmFsLmRhdGEpXG4gICAgICAgICAgOiBpbnRlcnZhbHNbaW5kZXggLSAxXS5kYXRhID09PSBpbnRlcnZhbC5kYXRhXG4gICAgICApIHtcbiAgICAgICAgLy8gT3ZlcmxhcHBpbmcgaW50ZXJ2YWxzIGhhdmUgdGhlIHNhbWUgZGF0YSwgc28gY29tYmluZSB0aGVtXG4gICAgICAgIGlmIChKdWxpYW5EYXRlLmdyZWF0ZXJUaGFuKGludGVydmFsLnN0b3AsIGludGVydmFsc1tpbmRleCAtIDFdLnN0b3ApKSB7XG4gICAgICAgICAgaW50ZXJ2YWwgPSBuZXcgVGltZUludGVydmFsKHtcbiAgICAgICAgICAgIHN0YXJ0OiBpbnRlcnZhbHNbaW5kZXggLSAxXS5zdGFydCxcbiAgICAgICAgICAgIHN0b3A6IGludGVydmFsLnN0b3AsXG4gICAgICAgICAgICBpc1N0YXJ0SW5jbHVkZWQ6IGludGVydmFsc1tpbmRleCAtIDFdLmlzU3RhcnRJbmNsdWRlZCxcbiAgICAgICAgICAgIGlzU3RvcEluY2x1ZGVkOiBpbnRlcnZhbC5pc1N0b3BJbmNsdWRlZCxcbiAgICAgICAgICAgIGRhdGE6IGludGVydmFsLmRhdGEsXG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaW50ZXJ2YWwgPSBuZXcgVGltZUludGVydmFsKHtcbiAgICAgICAgICAgIHN0YXJ0OiBpbnRlcnZhbHNbaW5kZXggLSAxXS5zdGFydCxcbiAgICAgICAgICAgIHN0b3A6IGludGVydmFsc1tpbmRleCAtIDFdLnN0b3AsXG4gICAgICAgICAgICBpc1N0YXJ0SW5jbHVkZWQ6IGludGVydmFsc1tpbmRleCAtIDFdLmlzU3RhcnRJbmNsdWRlZCxcbiAgICAgICAgICAgIGlzU3RvcEluY2x1ZGVkOlxuICAgICAgICAgICAgICBpbnRlcnZhbHNbaW5kZXggLSAxXS5pc1N0b3BJbmNsdWRlZCB8fFxuICAgICAgICAgICAgICAoaW50ZXJ2YWwuc3RvcC5lcXVhbHMoaW50ZXJ2YWxzW2luZGV4IC0gMV0uc3RvcCkgJiZcbiAgICAgICAgICAgICAgICBpbnRlcnZhbC5pc1N0b3BJbmNsdWRlZCksXG4gICAgICAgICAgICBkYXRhOiBpbnRlcnZhbC5kYXRhLFxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGludGVydmFscy5zcGxpY2UoaW5kZXggLSAxLCAxKTtcbiAgICAgICAgLS1pbmRleDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIE92ZXJsYXBwaW5nIGludGVydmFscyBoYXZlIGRpZmZlcmVudCBkYXRhLiAgVGhlIG5ldyBpbnRlcnZhbFxuICAgICAgICAvLyBiZWluZyBhZGRlZCAnd2lucycgc28gdHJ1bmNhdGUgdGhlIHByZXZpb3VzIGludGVydmFsLlxuICAgICAgICAvLyBJZiB0aGUgZXhpc3RpbmcgaW50ZXJ2YWwgZXh0ZW5kcyBwYXN0IHRoZSBlbmQgb2YgdGhlIG5ldyBvbmUsXG4gICAgICAgIC8vIHNwbGl0IHRoZSBleGlzdGluZyBpbnRlcnZhbCBpbnRvIHR3byBpbnRlcnZhbHMuXG4gICAgICAgIGNvbXBhcmlzb24gPSBKdWxpYW5EYXRlLmNvbXBhcmUoXG4gICAgICAgICAgaW50ZXJ2YWxzW2luZGV4IC0gMV0uc3RvcCxcbiAgICAgICAgICBpbnRlcnZhbC5zdG9wXG4gICAgICAgICk7XG4gICAgICAgIGlmIChcbiAgICAgICAgICBjb21wYXJpc29uID4gMCB8fFxuICAgICAgICAgIChjb21wYXJpc29uID09PSAwICYmXG4gICAgICAgICAgICBpbnRlcnZhbHNbaW5kZXggLSAxXS5pc1N0b3BJbmNsdWRlZCAmJlxuICAgICAgICAgICAgIWludGVydmFsLmlzU3RvcEluY2x1ZGVkKVxuICAgICAgICApIHtcbiAgICAgICAgICBpbnRlcnZhbHMuc3BsaWNlKFxuICAgICAgICAgICAgaW5kZXgsXG4gICAgICAgICAgICAwLFxuICAgICAgICAgICAgbmV3IFRpbWVJbnRlcnZhbCh7XG4gICAgICAgICAgICAgIHN0YXJ0OiBpbnRlcnZhbC5zdG9wLFxuICAgICAgICAgICAgICBzdG9wOiBpbnRlcnZhbHNbaW5kZXggLSAxXS5zdG9wLFxuICAgICAgICAgICAgICBpc1N0YXJ0SW5jbHVkZWQ6ICFpbnRlcnZhbC5pc1N0b3BJbmNsdWRlZCxcbiAgICAgICAgICAgICAgaXNTdG9wSW5jbHVkZWQ6IGludGVydmFsc1tpbmRleCAtIDFdLmlzU3RvcEluY2x1ZGVkLFxuICAgICAgICAgICAgICBkYXRhOiBpbnRlcnZhbHNbaW5kZXggLSAxXS5kYXRhLFxuICAgICAgICAgICAgfSlcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIGludGVydmFsc1tpbmRleCAtIDFdID0gbmV3IFRpbWVJbnRlcnZhbCh7XG4gICAgICAgICAgc3RhcnQ6IGludGVydmFsc1tpbmRleCAtIDFdLnN0YXJ0LFxuICAgICAgICAgIHN0b3A6IGludGVydmFsLnN0YXJ0LFxuICAgICAgICAgIGlzU3RhcnRJbmNsdWRlZDogaW50ZXJ2YWxzW2luZGV4IC0gMV0uaXNTdGFydEluY2x1ZGVkLFxuICAgICAgICAgIGlzU3RvcEluY2x1ZGVkOiAhaW50ZXJ2YWwuaXNTdGFydEluY2x1ZGVkLFxuICAgICAgICAgIGRhdGE6IGludGVydmFsc1tpbmRleCAtIDFdLmRhdGEsXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHdoaWxlIChpbmRleCA8IGludGVydmFscy5sZW5ndGgpIHtcbiAgICAvLyBOb3QgdGhlIGxhc3QgdGhpbmcgaW4gdGhlIGxpc3QsIHNvIHNlZSBpZiB0aGUgaW50ZXJ2YWxzIGFmdGVyIHRoaXMgb25lIG92ZXJsYXAgdGhpcyBvbmUuXG4gICAgY29tcGFyaXNvbiA9IEp1bGlhbkRhdGUuY29tcGFyZShpbnRlcnZhbC5zdG9wLCBpbnRlcnZhbHNbaW5kZXhdLnN0YXJ0KTtcbiAgICBpZiAoXG4gICAgICBjb21wYXJpc29uID4gMCB8fFxuICAgICAgKGNvbXBhcmlzb24gPT09IDAgJiZcbiAgICAgICAgKGludGVydmFsLmlzU3RvcEluY2x1ZGVkIHx8IGludGVydmFsc1tpbmRleF0uaXNTdGFydEluY2x1ZGVkKSlcbiAgICApIHtcbiAgICAgIC8vIFRoZXJlIGlzIGFuIG92ZXJsYXBcbiAgICAgIGlmIChcbiAgICAgICAgZGVmaW5lZChkYXRhQ29tcGFyZXIpXG4gICAgICAgICAgPyBkYXRhQ29tcGFyZXIoaW50ZXJ2YWxzW2luZGV4XS5kYXRhLCBpbnRlcnZhbC5kYXRhKVxuICAgICAgICAgIDogaW50ZXJ2YWxzW2luZGV4XS5kYXRhID09PSBpbnRlcnZhbC5kYXRhXG4gICAgICApIHtcbiAgICAgICAgLy8gT3ZlcmxhcHBpbmcgaW50ZXJ2YWxzIGhhdmUgdGhlIHNhbWUgZGF0YSwgc28gY29tYmluZSB0aGVtXG4gICAgICAgIGludGVydmFsID0gbmV3IFRpbWVJbnRlcnZhbCh7XG4gICAgICAgICAgc3RhcnQ6IGludGVydmFsLnN0YXJ0LFxuICAgICAgICAgIHN0b3A6IEp1bGlhbkRhdGUuZ3JlYXRlclRoYW4oaW50ZXJ2YWxzW2luZGV4XS5zdG9wLCBpbnRlcnZhbC5zdG9wKVxuICAgICAgICAgICAgPyBpbnRlcnZhbHNbaW5kZXhdLnN0b3BcbiAgICAgICAgICAgIDogaW50ZXJ2YWwuc3RvcCxcbiAgICAgICAgICBpc1N0YXJ0SW5jbHVkZWQ6IGludGVydmFsLmlzU3RhcnRJbmNsdWRlZCxcbiAgICAgICAgICBpc1N0b3BJbmNsdWRlZDogSnVsaWFuRGF0ZS5ncmVhdGVyVGhhbihcbiAgICAgICAgICAgIGludGVydmFsc1tpbmRleF0uc3RvcCxcbiAgICAgICAgICAgIGludGVydmFsLnN0b3BcbiAgICAgICAgICApXG4gICAgICAgICAgICA/IGludGVydmFsc1tpbmRleF0uaXNTdG9wSW5jbHVkZWRcbiAgICAgICAgICAgIDogaW50ZXJ2YWwuaXNTdG9wSW5jbHVkZWQsXG4gICAgICAgICAgZGF0YTogaW50ZXJ2YWwuZGF0YSxcbiAgICAgICAgfSk7XG4gICAgICAgIGludGVydmFscy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gT3ZlcmxhcHBpbmcgaW50ZXJ2YWxzIGhhdmUgZGlmZmVyZW50IGRhdGEuICBUaGUgbmV3IGludGVydmFsXG4gICAgICAgIC8vIGJlaW5nIGFkZGVkICd3aW5zJyBzbyB0cnVuY2F0ZSB0aGUgbmV4dCBpbnRlcnZhbC5cbiAgICAgICAgaW50ZXJ2YWxzW2luZGV4XSA9IG5ldyBUaW1lSW50ZXJ2YWwoe1xuICAgICAgICAgIHN0YXJ0OiBpbnRlcnZhbC5zdG9wLFxuICAgICAgICAgIHN0b3A6IGludGVydmFsc1tpbmRleF0uc3RvcCxcbiAgICAgICAgICBpc1N0YXJ0SW5jbHVkZWQ6ICFpbnRlcnZhbC5pc1N0b3BJbmNsdWRlZCxcbiAgICAgICAgICBpc1N0b3BJbmNsdWRlZDogaW50ZXJ2YWxzW2luZGV4XS5pc1N0b3BJbmNsdWRlZCxcbiAgICAgICAgICBkYXRhOiBpbnRlcnZhbHNbaW5kZXhdLmRhdGEsXG4gICAgICAgIH0pO1xuXG4gICAgICAgIGlmIChpbnRlcnZhbHNbaW5kZXhdLmlzRW1wdHkpIHtcbiAgICAgICAgICBpbnRlcnZhbHMuc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBGb3VuZCBhIHBhcnRpYWwgc3Bhbiwgc28gaXQgaXMgbm90IHBvc3NpYmxlIGZvciB0aGUgbmV4dFxuICAgICAgICAgIC8vIGludGVydmFsIHRvIGJlIHNwYW5uZWQgYXQgYWxsLiAgU3RvcCBsb29raW5nLlxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIEZvdW5kIHRoZSBsYXN0IG9uZSB3ZSdyZSBzcGFubmluZywgc28gc3RvcCBsb29raW5nLlxuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG5cbiAgLy8gQWRkIHRoZSBuZXcgaW50ZXJ2YWxcbiAgaW50ZXJ2YWxzLnNwbGljZShpbmRleCwgMCwgaW50ZXJ2YWwpO1xuICB0aGlzLl9jaGFuZ2VkRXZlbnQucmFpc2VFdmVudCh0aGlzKTtcbn07XG5cbi8qKlxuICogUmVtb3ZlcyB0aGUgc3BlY2lmaWVkIGludGVydmFsIGZyb20gdGhpcyBpbnRlcnZhbCBjb2xsZWN0aW9uLCBjcmVhdGluZyBhIGhvbGUgb3ZlciB0aGUgc3BlY2lmaWVkIGludGVydmFsLlxuICogVGhlIGRhdGEgcHJvcGVydHkgb2YgdGhlIGlucHV0IGludGVydmFsIGlzIGlnbm9yZWQuXG4gKlxuICogQHBhcmFtIHtUaW1lSW50ZXJ2YWx9IGludGVydmFsIFRoZSBpbnRlcnZhbCB0byByZW1vdmUuXG4gKiBAcmV0dXJucyB7Qm9vbGVhbn0gPGNvZGU+dHJ1ZTwvY29kZT4gaWYgdGhlIGludGVydmFsIHdhcyByZW1vdmVkLCA8Y29kZT5mYWxzZTwvY29kZT4gaWYgbm8gcGFydCBvZiB0aGUgaW50ZXJ2YWwgd2FzIGluIHRoZSBjb2xsZWN0aW9uLlxuICovXG5UaW1lSW50ZXJ2YWxDb2xsZWN0aW9uLnByb3RvdHlwZS5yZW1vdmVJbnRlcnZhbCA9IGZ1bmN0aW9uIChpbnRlcnZhbCkge1xuICAvLz4+aW5jbHVkZVN0YXJ0KCdkZWJ1ZycsIHByYWdtYXMuZGVidWcpO1xuICBpZiAoIWRlZmluZWQoaW50ZXJ2YWwpKSB7XG4gICAgdGhyb3cgbmV3IERldmVsb3BlckVycm9yKFwiaW50ZXJ2YWwgaXMgcmVxdWlyZWRcIik7XG4gIH1cbiAgLy8+PmluY2x1ZGVFbmQoJ2RlYnVnJyk7XG5cbiAgaWYgKGludGVydmFsLmlzRW1wdHkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICB2YXIgaW50ZXJ2YWxzID0gdGhpcy5faW50ZXJ2YWxzO1xuXG4gIHZhciBpbmRleCA9IGJpbmFyeVNlYXJjaChpbnRlcnZhbHMsIGludGVydmFsLCBjb21wYXJlSW50ZXJ2YWxTdGFydFRpbWVzKTtcbiAgaWYgKGluZGV4IDwgMCkge1xuICAgIGluZGV4ID0gfmluZGV4O1xuICB9XG5cbiAgdmFyIHJlc3VsdCA9IGZhbHNlO1xuXG4gIC8vIENoZWNrIGZvciB0cnVuY2F0aW9uIG9mIHRoZSBlbmQgb2YgdGhlIHByZXZpb3VzIGludGVydmFsLlxuICBpZiAoXG4gICAgaW5kZXggPiAwICYmXG4gICAgKEp1bGlhbkRhdGUuZ3JlYXRlclRoYW4oaW50ZXJ2YWxzW2luZGV4IC0gMV0uc3RvcCwgaW50ZXJ2YWwuc3RhcnQpIHx8XG4gICAgICAoaW50ZXJ2YWxzW2luZGV4IC0gMV0uc3RvcC5lcXVhbHMoaW50ZXJ2YWwuc3RhcnQpICYmXG4gICAgICAgIGludGVydmFsc1tpbmRleCAtIDFdLmlzU3RvcEluY2x1ZGVkICYmXG4gICAgICAgIGludGVydmFsLmlzU3RhcnRJbmNsdWRlZCkpXG4gICkge1xuICAgIHJlc3VsdCA9IHRydWU7XG5cbiAgICBpZiAoXG4gICAgICBKdWxpYW5EYXRlLmdyZWF0ZXJUaGFuKGludGVydmFsc1tpbmRleCAtIDFdLnN0b3AsIGludGVydmFsLnN0b3ApIHx8XG4gICAgICAoaW50ZXJ2YWxzW2luZGV4IC0gMV0uaXNTdG9wSW5jbHVkZWQgJiZcbiAgICAgICAgIWludGVydmFsLmlzU3RvcEluY2x1ZGVkICYmXG4gICAgICAgIGludGVydmFsc1tpbmRleCAtIDFdLnN0b3AuZXF1YWxzKGludGVydmFsLnN0b3ApKVxuICAgICkge1xuICAgICAgLy8gQnJlYWsgdGhlIGV4aXN0aW5nIGludGVydmFsIGludG8gdHdvIHBpZWNlc1xuICAgICAgaW50ZXJ2YWxzLnNwbGljZShcbiAgICAgICAgaW5kZXgsXG4gICAgICAgIDAsXG4gICAgICAgIG5ldyBUaW1lSW50ZXJ2YWwoe1xuICAgICAgICAgIHN0YXJ0OiBpbnRlcnZhbC5zdG9wLFxuICAgICAgICAgIHN0b3A6IGludGVydmFsc1tpbmRleCAtIDFdLnN0b3AsXG4gICAgICAgICAgaXNTdGFydEluY2x1ZGVkOiAhaW50ZXJ2YWwuaXNTdG9wSW5jbHVkZWQsXG4gICAgICAgICAgaXNTdG9wSW5jbHVkZWQ6IGludGVydmFsc1tpbmRleCAtIDFdLmlzU3RvcEluY2x1ZGVkLFxuICAgICAgICAgIGRhdGE6IGludGVydmFsc1tpbmRleCAtIDFdLmRhdGEsXG4gICAgICAgIH0pXG4gICAgICApO1xuICAgIH1cbiAgICBpbnRlcnZhbHNbaW5kZXggLSAxXSA9IG5ldyBUaW1lSW50ZXJ2YWwoe1xuICAgICAgc3RhcnQ6IGludGVydmFsc1tpbmRleCAtIDFdLnN0YXJ0LFxuICAgICAgc3RvcDogaW50ZXJ2YWwuc3RhcnQsXG4gICAgICBpc1N0YXJ0SW5jbHVkZWQ6IGludGVydmFsc1tpbmRleCAtIDFdLmlzU3RhcnRJbmNsdWRlZCxcbiAgICAgIGlzU3RvcEluY2x1ZGVkOiAhaW50ZXJ2YWwuaXNTdGFydEluY2x1ZGVkLFxuICAgICAgZGF0YTogaW50ZXJ2YWxzW2luZGV4IC0gMV0uZGF0YSxcbiAgICB9KTtcbiAgfVxuXG4gIC8vIENoZWNrIGlmIHRoZSBTdGFydCBvZiB0aGUgY3VycmVudCBpbnRlcnZhbCBzaG91bGQgcmVtYWluIGJlY2F1c2UgaW50ZXJ2YWwuc3RhcnQgaXMgdGhlIHNhbWUgYnV0XG4gIC8vIGl0IGlzIG5vdCBpbmNsdWRlZC5cbiAgaWYgKFxuICAgIGluZGV4IDwgaW50ZXJ2YWxzLmxlbmd0aCAmJlxuICAgICFpbnRlcnZhbC5pc1N0YXJ0SW5jbHVkZWQgJiZcbiAgICBpbnRlcnZhbHNbaW5kZXhdLmlzU3RhcnRJbmNsdWRlZCAmJlxuICAgIGludGVydmFsLnN0YXJ0LmVxdWFscyhpbnRlcnZhbHNbaW5kZXhdLnN0YXJ0KVxuICApIHtcbiAgICByZXN1bHQgPSB0cnVlO1xuXG4gICAgaW50ZXJ2YWxzLnNwbGljZShcbiAgICAgIGluZGV4LFxuICAgICAgMCxcbiAgICAgIG5ldyBUaW1lSW50ZXJ2YWwoe1xuICAgICAgICBzdGFydDogaW50ZXJ2YWxzW2luZGV4XS5zdGFydCxcbiAgICAgICAgc3RvcDogaW50ZXJ2YWxzW2luZGV4XS5zdGFydCxcbiAgICAgICAgaXNTdGFydEluY2x1ZGVkOiB0cnVlLFxuICAgICAgICBpc1N0b3BJbmNsdWRlZDogdHJ1ZSxcbiAgICAgICAgZGF0YTogaW50ZXJ2YWxzW2luZGV4XS5kYXRhLFxuICAgICAgfSlcbiAgICApO1xuICAgICsraW5kZXg7XG4gIH1cblxuICAvLyBSZW1vdmUgYW55IGludGVydmFscyB0aGF0IGFyZSBjb21wbGV0ZWx5IG92ZXJsYXBwZWQgYnkgdGhlIGlucHV0IGludGVydmFsLlxuICB3aGlsZSAoXG4gICAgaW5kZXggPCBpbnRlcnZhbHMubGVuZ3RoICYmXG4gICAgSnVsaWFuRGF0ZS5ncmVhdGVyVGhhbihpbnRlcnZhbC5zdG9wLCBpbnRlcnZhbHNbaW5kZXhdLnN0b3ApXG4gICkge1xuICAgIHJlc3VsdCA9IHRydWU7XG4gICAgaW50ZXJ2YWxzLnNwbGljZShpbmRleCwgMSk7XG4gIH1cblxuICAvLyBDaGVjayBmb3IgdGhlIGNhc2Ugd2hlcmUgdGhlIGlucHV0IGludGVydmFsIGVuZHMgb24gdGhlIHNhbWUgZGF0ZVxuICAvLyBhcyBhbiBleGlzdGluZyBpbnRlcnZhbC5cbiAgaWYgKGluZGV4IDwgaW50ZXJ2YWxzLmxlbmd0aCAmJiBpbnRlcnZhbC5zdG9wLmVxdWFscyhpbnRlcnZhbHNbaW5kZXhdLnN0b3ApKSB7XG4gICAgcmVzdWx0ID0gdHJ1ZTtcblxuICAgIGlmICghaW50ZXJ2YWwuaXNTdG9wSW5jbHVkZWQgJiYgaW50ZXJ2YWxzW2luZGV4XS5pc1N0b3BJbmNsdWRlZCkge1xuICAgICAgLy8gTGFzdCBwb2ludCBvZiBpbnRlcnZhbCBzaG91bGQgcmVtYWluIGJlY2F1c2UgdGhlIHN0b3AgZGF0ZSBpcyBpbmNsdWRlZCBpblxuICAgICAgLy8gdGhlIGV4aXN0aW5nIGludGVydmFsIGJ1dCBpcyBub3QgaW5jbHVkZWQgaW4gdGhlIGlucHV0IGludGVydmFsLlxuICAgICAgaWYgKFxuICAgICAgICBpbmRleCArIDEgPCBpbnRlcnZhbHMubGVuZ3RoICYmXG4gICAgICAgIGludGVydmFsc1tpbmRleCArIDFdLnN0YXJ0LmVxdWFscyhpbnRlcnZhbC5zdG9wKSAmJlxuICAgICAgICBpbnRlcnZhbHNbaW5kZXhdLmRhdGEgPT09IGludGVydmFsc1tpbmRleCArIDFdLmRhdGFcbiAgICAgICkge1xuICAgICAgICAvLyBDb21iaW5lIHNpbmdsZSBwb2ludCB3aXRoIHRoZSBuZXh0IGludGVydmFsXG4gICAgICAgIGludGVydmFscy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICBpbnRlcnZhbHNbaW5kZXhdID0gbmV3IFRpbWVJbnRlcnZhbCh7XG4gICAgICAgICAgc3RhcnQ6IGludGVydmFsc1tpbmRleF0uc3RhcnQsXG4gICAgICAgICAgc3RvcDogaW50ZXJ2YWxzW2luZGV4XS5zdG9wLFxuICAgICAgICAgIGlzU3RhcnRJbmNsdWRlZDogdHJ1ZSxcbiAgICAgICAgICBpc1N0b3BJbmNsdWRlZDogaW50ZXJ2YWxzW2luZGV4XS5pc1N0b3BJbmNsdWRlZCxcbiAgICAgICAgICBkYXRhOiBpbnRlcnZhbHNbaW5kZXhdLmRhdGEsXG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaW50ZXJ2YWxzW2luZGV4XSA9IG5ldyBUaW1lSW50ZXJ2YWwoe1xuICAgICAgICAgIHN0YXJ0OiBpbnRlcnZhbC5zdG9wLFxuICAgICAgICAgIHN0b3A6IGludGVydmFsLnN0b3AsXG4gICAgICAgICAgaXNTdGFydEluY2x1ZGVkOiB0cnVlLFxuICAgICAgICAgIGlzU3RvcEluY2x1ZGVkOiB0cnVlLFxuICAgICAgICAgIGRhdGE6IGludGVydmFsc1tpbmRleF0uZGF0YSxcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIEludGVydmFsIGlzIGNvbXBsZXRlbHkgb3ZlcmxhcHBlZFxuICAgICAgaW50ZXJ2YWxzLnNwbGljZShpbmRleCwgMSk7XG4gICAgfVxuICB9XG5cbiAgLy8gVHJ1bmNhdGUgYW55IHBhcnRpYWxseS1vdmVybGFwcGVkIGludGVydmFscy5cbiAgaWYgKFxuICAgIGluZGV4IDwgaW50ZXJ2YWxzLmxlbmd0aCAmJlxuICAgIChKdWxpYW5EYXRlLmdyZWF0ZXJUaGFuKGludGVydmFsLnN0b3AsIGludGVydmFsc1tpbmRleF0uc3RhcnQpIHx8XG4gICAgICAoaW50ZXJ2YWwuc3RvcC5lcXVhbHMoaW50ZXJ2YWxzW2luZGV4XS5zdGFydCkgJiZcbiAgICAgICAgaW50ZXJ2YWwuaXNTdG9wSW5jbHVkZWQgJiZcbiAgICAgICAgaW50ZXJ2YWxzW2luZGV4XS5pc1N0YXJ0SW5jbHVkZWQpKVxuICApIHtcbiAgICByZXN1bHQgPSB0cnVlO1xuICAgIGludGVydmFsc1tpbmRleF0gPSBuZXcgVGltZUludGVydmFsKHtcbiAgICAgIHN0YXJ0OiBpbnRlcnZhbC5zdG9wLFxuICAgICAgc3RvcDogaW50ZXJ2YWxzW2luZGV4XS5zdG9wLFxuICAgICAgaXNTdGFydEluY2x1ZGVkOiAhaW50ZXJ2YWwuaXNTdG9wSW5jbHVkZWQsXG4gICAgICBpc1N0b3BJbmNsdWRlZDogaW50ZXJ2YWxzW2luZGV4XS5pc1N0b3BJbmNsdWRlZCxcbiAgICAgIGRhdGE6IGludGVydmFsc1tpbmRleF0uZGF0YSxcbiAgICB9KTtcbiAgfVxuXG4gIGlmIChyZXN1bHQpIHtcbiAgICB0aGlzLl9jaGFuZ2VkRXZlbnQucmFpc2VFdmVudCh0aGlzKTtcbiAgfVxuXG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgaW5zdGFuY2UgdGhhdCBpcyB0aGUgaW50ZXJzZWN0aW9uIG9mIHRoaXMgY29sbGVjdGlvbiBhbmQgdGhlIHByb3ZpZGVkIGNvbGxlY3Rpb24uXG4gKlxuICogQHBhcmFtIHtUaW1lSW50ZXJ2YWxDb2xsZWN0aW9ufSBvdGhlciBUaGUgY29sbGVjdGlvbiB0byBpbnRlcnNlY3Qgd2l0aC5cbiAqIEBwYXJhbSB7VGltZUludGVydmFsLkRhdGFDb21wYXJlcn0gW2RhdGFDb21wYXJlcl0gQSBmdW5jdGlvbiB3aGljaCBjb21wYXJlcyB0aGUgZGF0YSBvZiB0aGUgdHdvIGludGVydmFscy4gIElmIG9taXR0ZWQsIHJlZmVyZW5jZSBlcXVhbGl0eSBpcyB1c2VkLlxuICogQHBhcmFtIHtUaW1lSW50ZXJ2YWwuTWVyZ2VDYWxsYmFja30gW21lcmdlQ2FsbGJhY2tdIEEgZnVuY3Rpb24gd2hpY2ggbWVyZ2VzIHRoZSBkYXRhIG9mIHRoZSB0d28gaW50ZXJ2YWxzLiBJZiBvbWl0dGVkLCB0aGUgZGF0YSBmcm9tIHRoZSBsZWZ0IGludGVydmFsIHdpbGwgYmUgdXNlZC5cbiAqIEByZXR1cm5zIHtUaW1lSW50ZXJ2YWxDb2xsZWN0aW9ufSBBIG5ldyBUaW1lSW50ZXJ2YWxDb2xsZWN0aW9uIHdoaWNoIGlzIHRoZSBpbnRlcnNlY3Rpb24gb2YgdGhpcyBjb2xsZWN0aW9uIGFuZCB0aGUgcHJvdmlkZWQgY29sbGVjdGlvbi5cbiAqL1xuVGltZUludGVydmFsQ29sbGVjdGlvbi5wcm90b3R5cGUuaW50ZXJzZWN0ID0gZnVuY3Rpb24gKFxuICBvdGhlcixcbiAgZGF0YUNvbXBhcmVyLFxuICBtZXJnZUNhbGxiYWNrXG4pIHtcbiAgLy8+PmluY2x1ZGVTdGFydCgnZGVidWcnLCBwcmFnbWFzLmRlYnVnKTtcbiAgaWYgKCFkZWZpbmVkKG90aGVyKSkge1xuICAgIHRocm93IG5ldyBEZXZlbG9wZXJFcnJvcihcIm90aGVyIGlzIHJlcXVpcmVkLlwiKTtcbiAgfVxuICAvLz4+aW5jbHVkZUVuZCgnZGVidWcnKTtcblxuICB2YXIgcmVzdWx0ID0gbmV3IFRpbWVJbnRlcnZhbENvbGxlY3Rpb24oKTtcbiAgdmFyIGxlZnQgPSAwO1xuICB2YXIgcmlnaHQgPSAwO1xuICB2YXIgaW50ZXJ2YWxzID0gdGhpcy5faW50ZXJ2YWxzO1xuICB2YXIgb3RoZXJJbnRlcnZhbHMgPSBvdGhlci5faW50ZXJ2YWxzO1xuXG4gIHdoaWxlIChsZWZ0IDwgaW50ZXJ2YWxzLmxlbmd0aCAmJiByaWdodCA8IG90aGVySW50ZXJ2YWxzLmxlbmd0aCkge1xuICAgIHZhciBsZWZ0SW50ZXJ2YWwgPSBpbnRlcnZhbHNbbGVmdF07XG4gICAgdmFyIHJpZ2h0SW50ZXJ2YWwgPSBvdGhlckludGVydmFsc1tyaWdodF07XG4gICAgaWYgKEp1bGlhbkRhdGUubGVzc1RoYW4obGVmdEludGVydmFsLnN0b3AsIHJpZ2h0SW50ZXJ2YWwuc3RhcnQpKSB7XG4gICAgICArK2xlZnQ7XG4gICAgfSBlbHNlIGlmIChKdWxpYW5EYXRlLmxlc3NUaGFuKHJpZ2h0SW50ZXJ2YWwuc3RvcCwgbGVmdEludGVydmFsLnN0YXJ0KSkge1xuICAgICAgKytyaWdodDtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gVGhlIGZvbGxvd2luZyB3aWxsIHJldHVybiBhbiBpbnRlcnNlY3Rpb24gd2hvc2UgZGF0YSBpcyAnbWVyZ2VkJyBpZiB0aGUgY2FsbGJhY2sgaXMgZGVmaW5lZFxuICAgICAgaWYgKFxuICAgICAgICBkZWZpbmVkKG1lcmdlQ2FsbGJhY2spIHx8XG4gICAgICAgIChkZWZpbmVkKGRhdGFDb21wYXJlcikgJiZcbiAgICAgICAgICBkYXRhQ29tcGFyZXIobGVmdEludGVydmFsLmRhdGEsIHJpZ2h0SW50ZXJ2YWwuZGF0YSkpIHx8XG4gICAgICAgICghZGVmaW5lZChkYXRhQ29tcGFyZXIpICYmIHJpZ2h0SW50ZXJ2YWwuZGF0YSA9PT0gbGVmdEludGVydmFsLmRhdGEpXG4gICAgICApIHtcbiAgICAgICAgdmFyIGludGVyc2VjdGlvbiA9IFRpbWVJbnRlcnZhbC5pbnRlcnNlY3QoXG4gICAgICAgICAgbGVmdEludGVydmFsLFxuICAgICAgICAgIHJpZ2h0SW50ZXJ2YWwsXG4gICAgICAgICAgbmV3IFRpbWVJbnRlcnZhbCgpLFxuICAgICAgICAgIG1lcmdlQ2FsbGJhY2tcbiAgICAgICAgKTtcbiAgICAgICAgaWYgKCFpbnRlcnNlY3Rpb24uaXNFbXB0eSkge1xuICAgICAgICAgIC8vIFNpbmNlIHdlIHN0YXJ0IHdpdGggYW4gZW1wdHkgY29sbGVjdGlvbiBmb3IgJ3Jlc3VsdCcsIGFuZCB0aGVyZSBhcmUgbm8gb3ZlcmxhcHBpbmcgaW50ZXJ2YWxzIGluICd0aGlzJyAoYXMgYSBydWxlKSxcbiAgICAgICAgICAvLyB0aGUgJ2ludGVyc2VjdGlvbicgd2lsbCBuZXZlciBvdmVybGFwIHdpdGggYSBwcmV2aW91cyBpbnRlcnZhbCBpbiAncmVzdWx0Jy4gIFNvLCBubyBuZWVkIHRvIGRvIGFueSBhZGRpdGlvbmFsICdtZXJnaW5nJy5cbiAgICAgICAgICByZXN1bHQuYWRkSW50ZXJ2YWwoaW50ZXJzZWN0aW9uLCBkYXRhQ29tcGFyZXIpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChcbiAgICAgICAgSnVsaWFuRGF0ZS5sZXNzVGhhbihsZWZ0SW50ZXJ2YWwuc3RvcCwgcmlnaHRJbnRlcnZhbC5zdG9wKSB8fFxuICAgICAgICAobGVmdEludGVydmFsLnN0b3AuZXF1YWxzKHJpZ2h0SW50ZXJ2YWwuc3RvcCkgJiZcbiAgICAgICAgICAhbGVmdEludGVydmFsLmlzU3RvcEluY2x1ZGVkICYmXG4gICAgICAgICAgcmlnaHRJbnRlcnZhbC5pc1N0b3BJbmNsdWRlZClcbiAgICAgICkge1xuICAgICAgICArK2xlZnQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICArK3JpZ2h0O1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IGluc3RhbmNlIGZyb20gYSBKdWxpYW5EYXRlIGFycmF5LlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIE9iamVjdCB3aXRoIHRoZSBmb2xsb3dpbmcgcHJvcGVydGllczpcbiAqIEBwYXJhbSB7SnVsaWFuRGF0ZVtdfSBvcHRpb25zLmp1bGlhbkRhdGVzIEFuIGFycmF5IG9mIElTTyA4NjAxIGRhdGVzLlxuICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5pc1N0YXJ0SW5jbHVkZWQ9dHJ1ZV0gPGNvZGU+dHJ1ZTwvY29kZT4gaWYgc3RhcnQgdGltZSBpcyBpbmNsdWRlZCBpbiB0aGUgaW50ZXJ2YWwsIDxjb2RlPmZhbHNlPC9jb2RlPiBvdGhlcndpc2UuXG4gKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLmlzU3RvcEluY2x1ZGVkPXRydWVdIDxjb2RlPnRydWU8L2NvZGU+IGlmIHN0b3AgdGltZSBpcyBpbmNsdWRlZCBpbiB0aGUgaW50ZXJ2YWwsIDxjb2RlPmZhbHNlPC9jb2RlPiBvdGhlcndpc2UuXG4gKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLmxlYWRpbmdJbnRlcnZhbD1mYWxzZV0gPGNvZGU+dHJ1ZTwvY29kZT4gaWYgeW91IHdhbnQgdG8gYWRkIGEgaW50ZXJ2YWwgZnJvbSBJc284NjAxLk1JTklNVU1fVkFMVUUgdG8gc3RhcnQgdGltZSwgIDxjb2RlPmZhbHNlPC9jb2RlPiBvdGhlcndpc2UuXG4gKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLnRyYWlsaW5nSW50ZXJ2YWw9ZmFsc2VdIDxjb2RlPnRydWU8L2NvZGU+IGlmIHlvdSB3YW50IHRvIGFkZCBhIGludGVydmFsIGZyb20gc3RvcCB0aW1lIHRvIElzbzg2MDEuTUFYSU1VTV9WQUxVRSwgIDxjb2RlPmZhbHNlPC9jb2RlPiBvdGhlcndpc2UuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbb3B0aW9ucy5kYXRhQ2FsbGJhY2tdIEEgZnVuY3Rpb24gdGhhdCB3aWxsIGJlIHJldHVybiB0aGUgZGF0YSB0aGF0IGlzIGNhbGxlZCB3aXRoIGVhY2ggaW50ZXJ2YWwgYmVmb3JlIGl0IGlzIGFkZGVkIHRvIHRoZSBjb2xsZWN0aW9uLiBJZiB1bnNwZWNpZmllZCwgdGhlIGRhdGEgd2lsbCBiZSB0aGUgaW5kZXggaW4gdGhlIGNvbGxlY3Rpb24uXG4gKiBAcGFyYW0ge1RpbWVJbnRlcnZhbENvbGxlY3Rpb259IFtyZXN1bHRdIEFuIGV4aXN0aW5nIGluc3RhbmNlIHRvIHVzZSBmb3IgdGhlIHJlc3VsdC5cbiAqIEByZXR1cm5zIHtUaW1lSW50ZXJ2YWxDb2xsZWN0aW9ufSBUaGUgbW9kaWZpZWQgcmVzdWx0IHBhcmFtZXRlciBvciBhIG5ldyBpbnN0YW5jZSBpZiBub25lIHdhcyBwcm92aWRlZC5cbiAqL1xuVGltZUludGVydmFsQ29sbGVjdGlvbi5mcm9tSnVsaWFuRGF0ZUFycmF5ID0gZnVuY3Rpb24gKG9wdGlvbnMsIHJlc3VsdCkge1xuICAvLz4+aW5jbHVkZVN0YXJ0KCdkZWJ1ZycsIHByYWdtYXMuZGVidWcpO1xuICBpZiAoIWRlZmluZWQob3B0aW9ucykpIHtcbiAgICB0aHJvdyBuZXcgRGV2ZWxvcGVyRXJyb3IoXCJvcHRpb25zIGlzIHJlcXVpcmVkLlwiKTtcbiAgfVxuICBpZiAoIWRlZmluZWQob3B0aW9ucy5qdWxpYW5EYXRlcykpIHtcbiAgICB0aHJvdyBuZXcgRGV2ZWxvcGVyRXJyb3IoXCJvcHRpb25zLmlzbzg2MDFBcnJheSBpcyByZXF1aXJlZC5cIik7XG4gIH1cbiAgLy8+PmluY2x1ZGVFbmQoJ2RlYnVnJyk7XG5cbiAgaWYgKCFkZWZpbmVkKHJlc3VsdCkpIHtcbiAgICByZXN1bHQgPSBuZXcgVGltZUludGVydmFsQ29sbGVjdGlvbigpO1xuICB9XG5cbiAgdmFyIGp1bGlhbkRhdGVzID0gb3B0aW9ucy5qdWxpYW5EYXRlcztcbiAgdmFyIGxlbmd0aCA9IGp1bGlhbkRhdGVzLmxlbmd0aDtcbiAgdmFyIGRhdGFDYWxsYmFjayA9IG9wdGlvbnMuZGF0YUNhbGxiYWNrO1xuXG4gIHZhciBpc1N0YXJ0SW5jbHVkZWQgPSBkZWZhdWx0VmFsdWUob3B0aW9ucy5pc1N0YXJ0SW5jbHVkZWQsIHRydWUpO1xuICB2YXIgaXNTdG9wSW5jbHVkZWQgPSBkZWZhdWx0VmFsdWUob3B0aW9ucy5pc1N0b3BJbmNsdWRlZCwgdHJ1ZSk7XG4gIHZhciBsZWFkaW5nSW50ZXJ2YWwgPSBkZWZhdWx0VmFsdWUob3B0aW9ucy5sZWFkaW5nSW50ZXJ2YWwsIGZhbHNlKTtcbiAgdmFyIHRyYWlsaW5nSW50ZXJ2YWwgPSBkZWZhdWx0VmFsdWUob3B0aW9ucy50cmFpbGluZ0ludGVydmFsLCBmYWxzZSk7XG4gIHZhciBpbnRlcnZhbDtcblxuICAvLyBBZGQgYSBkZWZhdWx0IGludGVydmFsLCB3aGljaCB3aWxsIG9ubHkgZW5kIHVwIGJlaW5nIHVzZWQgdXAgdG8gZmlyc3QgaW50ZXJ2YWxcbiAgdmFyIHN0YXJ0SW5kZXggPSAwO1xuICBpZiAobGVhZGluZ0ludGVydmFsKSB7XG4gICAgKytzdGFydEluZGV4O1xuICAgIGludGVydmFsID0gbmV3IFRpbWVJbnRlcnZhbCh7XG4gICAgICBzdGFydDogSXNvODYwMS5NSU5JTVVNX1ZBTFVFLFxuICAgICAgc3RvcDoganVsaWFuRGF0ZXNbMF0sXG4gICAgICBpc1N0YXJ0SW5jbHVkZWQ6IHRydWUsXG4gICAgICBpc1N0b3BJbmNsdWRlZDogIWlzU3RhcnRJbmNsdWRlZCxcbiAgICB9KTtcbiAgICBpbnRlcnZhbC5kYXRhID0gZGVmaW5lZChkYXRhQ2FsbGJhY2spXG4gICAgICA/IGRhdGFDYWxsYmFjayhpbnRlcnZhbCwgcmVzdWx0Lmxlbmd0aClcbiAgICAgIDogcmVzdWx0Lmxlbmd0aDtcbiAgICByZXN1bHQuYWRkSW50ZXJ2YWwoaW50ZXJ2YWwpO1xuICB9XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGggLSAxOyArK2kpIHtcbiAgICB2YXIgc3RhcnREYXRlID0ganVsaWFuRGF0ZXNbaV07XG4gICAgdmFyIGVuZERhdGUgPSBqdWxpYW5EYXRlc1tpICsgMV07XG5cbiAgICBpbnRlcnZhbCA9IG5ldyBUaW1lSW50ZXJ2YWwoe1xuICAgICAgc3RhcnQ6IHN0YXJ0RGF0ZSxcbiAgICAgIHN0b3A6IGVuZERhdGUsXG4gICAgICBpc1N0YXJ0SW5jbHVkZWQ6IHJlc3VsdC5sZW5ndGggPT09IHN0YXJ0SW5kZXggPyBpc1N0YXJ0SW5jbHVkZWQgOiB0cnVlLFxuICAgICAgaXNTdG9wSW5jbHVkZWQ6IGkgPT09IGxlbmd0aCAtIDIgPyBpc1N0b3BJbmNsdWRlZCA6IGZhbHNlLFxuICAgIH0pO1xuICAgIGludGVydmFsLmRhdGEgPSBkZWZpbmVkKGRhdGFDYWxsYmFjaylcbiAgICAgID8gZGF0YUNhbGxiYWNrKGludGVydmFsLCByZXN1bHQubGVuZ3RoKVxuICAgICAgOiByZXN1bHQubGVuZ3RoO1xuICAgIHJlc3VsdC5hZGRJbnRlcnZhbChpbnRlcnZhbCk7XG5cbiAgICBzdGFydERhdGUgPSBlbmREYXRlO1xuICB9XG5cbiAgaWYgKHRyYWlsaW5nSW50ZXJ2YWwpIHtcbiAgICBpbnRlcnZhbCA9IG5ldyBUaW1lSW50ZXJ2YWwoe1xuICAgICAgc3RhcnQ6IGp1bGlhbkRhdGVzW2xlbmd0aCAtIDFdLFxuICAgICAgc3RvcDogSXNvODYwMS5NQVhJTVVNX1ZBTFVFLFxuICAgICAgaXNTdGFydEluY2x1ZGVkOiAhaXNTdG9wSW5jbHVkZWQsXG4gICAgICBpc1N0b3BJbmNsdWRlZDogdHJ1ZSxcbiAgICB9KTtcbiAgICBpbnRlcnZhbC5kYXRhID0gZGVmaW5lZChkYXRhQ2FsbGJhY2spXG4gICAgICA/IGRhdGFDYWxsYmFjayhpbnRlcnZhbCwgcmVzdWx0Lmxlbmd0aClcbiAgICAgIDogcmVzdWx0Lmxlbmd0aDtcbiAgICByZXN1bHQuYWRkSW50ZXJ2YWwoaW50ZXJ2YWwpO1xuICB9XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbnZhciBzY3JhdGNoR3JlZ29yaWFuRGF0ZSA9IG5ldyBHcmVnb3JpYW5EYXRlKCk7XG52YXIgbW9udGhMZW5ndGhzID0gWzAsIDMxLCAyOCwgMzEsIDMwLCAzMSwgMzAsIDMxLCAzMSwgMzAsIDMxLCAzMCwgMzFdO1xuXG4vKipcbiAqIEFkZHMgZHVyYXRpb24gcmVwcmVzZW50ZWQgYXMgYSBHcmVnb3JpYW5EYXRlIHRvIGEgSnVsaWFuRGF0ZVxuICpcbiAqIEBwYXJhbSB7SnVsaWFuRGF0ZX0ganVsaWFuRGF0ZSBUaGUgZGF0ZS5cbiAqIEBwYXJhbSB7R3JlZ29yaWFuRGF0ZX0gZHVyYXRpb24gQW4gZHVyYXRpb24gcmVwcmVzZW50ZWQgYXMgYSBHcmVnb3JpYW5EYXRlLlxuICogQHBhcmFtIHtKdWxpYW5EYXRlfSByZXN1bHQgQW4gZXhpc3RpbmcgaW5zdGFuY2UgdG8gdXNlIGZvciB0aGUgcmVzdWx0LlxuICogQHJldHVybnMge0p1bGlhbkRhdGV9IFRoZSBtb2RpZmllZCByZXN1bHQgcGFyYW1ldGVyLlxuICpcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGFkZFRvRGF0ZShqdWxpYW5EYXRlLCBkdXJhdGlvbiwgcmVzdWx0KSB7XG4gIGlmICghZGVmaW5lZChyZXN1bHQpKSB7XG4gICAgcmVzdWx0ID0gbmV3IEp1bGlhbkRhdGUoKTtcbiAgfVxuICBKdWxpYW5EYXRlLnRvR3JlZ29yaWFuRGF0ZShqdWxpYW5EYXRlLCBzY3JhdGNoR3JlZ29yaWFuRGF0ZSk7XG5cbiAgdmFyIG1pbGxpc2Vjb25kID0gc2NyYXRjaEdyZWdvcmlhbkRhdGUubWlsbGlzZWNvbmQgKyBkdXJhdGlvbi5taWxsaXNlY29uZDtcbiAgdmFyIHNlY29uZCA9IHNjcmF0Y2hHcmVnb3JpYW5EYXRlLnNlY29uZCArIGR1cmF0aW9uLnNlY29uZDtcbiAgdmFyIG1pbnV0ZSA9IHNjcmF0Y2hHcmVnb3JpYW5EYXRlLm1pbnV0ZSArIGR1cmF0aW9uLm1pbnV0ZTtcbiAgdmFyIGhvdXIgPSBzY3JhdGNoR3JlZ29yaWFuRGF0ZS5ob3VyICsgZHVyYXRpb24uaG91cjtcbiAgdmFyIGRheSA9IHNjcmF0Y2hHcmVnb3JpYW5EYXRlLmRheSArIGR1cmF0aW9uLmRheTtcbiAgdmFyIG1vbnRoID0gc2NyYXRjaEdyZWdvcmlhbkRhdGUubW9udGggKyBkdXJhdGlvbi5tb250aDtcbiAgdmFyIHllYXIgPSBzY3JhdGNoR3JlZ29yaWFuRGF0ZS55ZWFyICsgZHVyYXRpb24ueWVhcjtcblxuICBpZiAobWlsbGlzZWNvbmQgPj0gMTAwMCkge1xuICAgIHNlY29uZCArPSBNYXRoLmZsb29yKG1pbGxpc2Vjb25kIC8gMTAwMCk7XG4gICAgbWlsbGlzZWNvbmQgPSBtaWxsaXNlY29uZCAlIDEwMDA7XG4gIH1cblxuICBpZiAoc2Vjb25kID49IDYwKSB7XG4gICAgbWludXRlICs9IE1hdGguZmxvb3Ioc2Vjb25kIC8gNjApO1xuICAgIHNlY29uZCA9IHNlY29uZCAlIDYwO1xuICB9XG5cbiAgaWYgKG1pbnV0ZSA+PSA2MCkge1xuICAgIGhvdXIgKz0gTWF0aC5mbG9vcihtaW51dGUgLyA2MCk7XG4gICAgbWludXRlID0gbWludXRlICUgNjA7XG4gIH1cblxuICBpZiAoaG91ciA+PSAyNCkge1xuICAgIGRheSArPSBNYXRoLmZsb29yKGhvdXIgLyAyNCk7XG4gICAgaG91ciA9IGhvdXIgJSAyNDtcbiAgfVxuXG4gIC8vIElmIGRheXMgaXMgZ3JlYXRlciB0aGFuIHRoZSBtb250aCdzIGxlbmd0aCB3ZSBuZWVkIHRvIHJlbW92ZSB0aG9zZSBudW1iZXIgb2YgZGF5cyxcbiAgLy8gIHJlYWRqdXN0IG1vbnRoIGFuZCB5ZWFyIGFuZCByZXBlYXQgdW50aWwgZGF5cyBpcyBsZXNzIHRoYW4gdGhlIG1vbnRoJ3MgbGVuZ3RoLlxuICBtb250aExlbmd0aHNbMl0gPSBpc0xlYXBZZWFyKHllYXIpID8gMjkgOiAyODtcbiAgd2hpbGUgKGRheSA+IG1vbnRoTGVuZ3Roc1ttb250aF0gfHwgbW9udGggPj0gMTMpIHtcbiAgICBpZiAoZGF5ID4gbW9udGhMZW5ndGhzW21vbnRoXSkge1xuICAgICAgZGF5IC09IG1vbnRoTGVuZ3Roc1ttb250aF07XG4gICAgICArK21vbnRoO1xuICAgIH1cblxuICAgIGlmIChtb250aCA+PSAxMykge1xuICAgICAgLS1tb250aDtcbiAgICAgIHllYXIgKz0gTWF0aC5mbG9vcihtb250aCAvIDEyKTtcbiAgICAgIG1vbnRoID0gbW9udGggJSAxMjtcbiAgICAgICsrbW9udGg7XG4gICAgfVxuXG4gICAgbW9udGhMZW5ndGhzWzJdID0gaXNMZWFwWWVhcih5ZWFyKSA/IDI5IDogMjg7XG4gIH1cblxuICBzY3JhdGNoR3JlZ29yaWFuRGF0ZS5taWxsaXNlY29uZCA9IG1pbGxpc2Vjb25kO1xuICBzY3JhdGNoR3JlZ29yaWFuRGF0ZS5zZWNvbmQgPSBzZWNvbmQ7XG4gIHNjcmF0Y2hHcmVnb3JpYW5EYXRlLm1pbnV0ZSA9IG1pbnV0ZTtcbiAgc2NyYXRjaEdyZWdvcmlhbkRhdGUuaG91ciA9IGhvdXI7XG4gIHNjcmF0Y2hHcmVnb3JpYW5EYXRlLmRheSA9IGRheTtcbiAgc2NyYXRjaEdyZWdvcmlhbkRhdGUubW9udGggPSBtb250aDtcbiAgc2NyYXRjaEdyZWdvcmlhbkRhdGUueWVhciA9IHllYXI7XG5cbiAgcmV0dXJuIEp1bGlhbkRhdGUuZnJvbUdyZWdvcmlhbkRhdGUoc2NyYXRjaEdyZWdvcmlhbkRhdGUsIHJlc3VsdCk7XG59XG5cbnZhciBzY3JhdGNoSnVsaWFuRGF0ZSA9IG5ldyBKdWxpYW5EYXRlKCk7XG52YXIgZHVyYXRpb25SZWdleCA9IC9QKD86KFtcXGQuLF0rKVkpPyg/OihbXFxkLixdKylNKT8oPzooW1xcZC4sXSspVyk/KD86KFtcXGQuLF0rKUQpPyg/OlQoPzooW1xcZC4sXSspSCk/KD86KFtcXGQuLF0rKU0pPyg/OihbXFxkLixdKylTKT8pPy87XG5cbi8qKlxuICogUGFyc2VzIElTTzg2MDEgZHVyYXRpb24gc3RyaW5nXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGlzbzg2MDEgQW4gSVNPIDg2MDEgZHVyYXRpb24uXG4gKiBAcGFyYW0ge0dyZWdvcmlhbkRhdGV9IHJlc3VsdCBBbiBleGlzdGluZyBpbnN0YW5jZSB0byB1c2UgZm9yIHRoZSByZXN1bHQuXG4gKiBAcmV0dXJucyB7Qm9vbGVhbn0gVHJ1ZSBpcyBwYXJzaW5nIHN1Y2NlZWRlZCwgZmFsc2Ugb3RoZXJ3aXNlXG4gKlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gcGFyc2VEdXJhdGlvbihpc284NjAxLCByZXN1bHQpIHtcbiAgaWYgKCFkZWZpbmVkKGlzbzg2MDEpIHx8IGlzbzg2MDEubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgLy8gUmVzZXQgb2JqZWN0XG4gIHJlc3VsdC55ZWFyID0gMDtcbiAgcmVzdWx0Lm1vbnRoID0gMDtcbiAgcmVzdWx0LmRheSA9IDA7XG4gIHJlc3VsdC5ob3VyID0gMDtcbiAgcmVzdWx0Lm1pbnV0ZSA9IDA7XG4gIHJlc3VsdC5zZWNvbmQgPSAwO1xuICByZXN1bHQubWlsbGlzZWNvbmQgPSAwO1xuXG4gIGlmIChpc284NjAxWzBdID09PSBcIlBcIikge1xuICAgIHZhciBtYXRjaGVzID0gaXNvODYwMS5tYXRjaChkdXJhdGlvblJlZ2V4KTtcbiAgICBpZiAoIWRlZmluZWQobWF0Y2hlcykpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWYgKGRlZmluZWQobWF0Y2hlc1sxXSkpIHtcbiAgICAgIC8vIFllYXJzXG4gICAgICByZXN1bHQueWVhciA9IE51bWJlcihtYXRjaGVzWzFdLnJlcGxhY2UoXCIsXCIsIFwiLlwiKSk7XG4gICAgfVxuICAgIGlmIChkZWZpbmVkKG1hdGNoZXNbMl0pKSB7XG4gICAgICAvLyBNb250aHNcbiAgICAgIHJlc3VsdC5tb250aCA9IE51bWJlcihtYXRjaGVzWzJdLnJlcGxhY2UoXCIsXCIsIFwiLlwiKSk7XG4gICAgfVxuICAgIGlmIChkZWZpbmVkKG1hdGNoZXNbM10pKSB7XG4gICAgICAvLyBXZWVrc1xuICAgICAgcmVzdWx0LmRheSA9IE51bWJlcihtYXRjaGVzWzNdLnJlcGxhY2UoXCIsXCIsIFwiLlwiKSkgKiA3O1xuICAgIH1cbiAgICBpZiAoZGVmaW5lZChtYXRjaGVzWzRdKSkge1xuICAgICAgLy8gRGF5c1xuICAgICAgcmVzdWx0LmRheSArPSBOdW1iZXIobWF0Y2hlc1s0XS5yZXBsYWNlKFwiLFwiLCBcIi5cIikpO1xuICAgIH1cbiAgICBpZiAoZGVmaW5lZChtYXRjaGVzWzVdKSkge1xuICAgICAgLy8gSG91cnNcbiAgICAgIHJlc3VsdC5ob3VyID0gTnVtYmVyKG1hdGNoZXNbNV0ucmVwbGFjZShcIixcIiwgXCIuXCIpKTtcbiAgICB9XG4gICAgaWYgKGRlZmluZWQobWF0Y2hlc1s2XSkpIHtcbiAgICAgIC8vIFdlZWtzXG4gICAgICByZXN1bHQubWludXRlID0gTnVtYmVyKG1hdGNoZXNbNl0ucmVwbGFjZShcIixcIiwgXCIuXCIpKTtcbiAgICB9XG4gICAgaWYgKGRlZmluZWQobWF0Y2hlc1s3XSkpIHtcbiAgICAgIC8vIFNlY29uZHNcbiAgICAgIHZhciBzZWNvbmRzID0gTnVtYmVyKG1hdGNoZXNbN10ucmVwbGFjZShcIixcIiwgXCIuXCIpKTtcbiAgICAgIHJlc3VsdC5zZWNvbmQgPSBNYXRoLmZsb29yKHNlY29uZHMpO1xuICAgICAgcmVzdWx0Lm1pbGxpc2Vjb25kID0gKHNlY29uZHMgJSAxKSAqIDEwMDA7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIC8vIFRoZXkgY2FuIHRlY2huaWNhbGx5IHNwZWNpZnkgdGhlIGR1cmF0aW9uIGFzIGEgbm9ybWFsIGRhdGUgd2l0aCBzb21lIGNhdmVhdHMuIFRyeSBvdXIgYmVzdCB0byBsb2FkIGl0LlxuICAgIGlmIChpc284NjAxW2lzbzg2MDEubGVuZ3RoIC0gMV0gIT09IFwiWlwiKSB7XG4gICAgICAvLyBJdCdzIG5vdCBhIGRhdGUsIGl0cyBhIGR1cmF0aW9uLCBzbyBpdCBhbHdheXMgaGFzIHRvIGJlIFVUQ1xuICAgICAgaXNvODYwMSArPSBcIlpcIjtcbiAgICB9XG4gICAgSnVsaWFuRGF0ZS50b0dyZWdvcmlhbkRhdGUoXG4gICAgICBKdWxpYW5EYXRlLmZyb21Jc284NjAxKGlzbzg2MDEsIHNjcmF0Y2hKdWxpYW5EYXRlKSxcbiAgICAgIHJlc3VsdFxuICAgICk7XG4gIH1cblxuICAvLyBBIGR1cmF0aW9uIG9mIDAgd2lsbCBjYXVzZSBhbiBpbmZpbml0ZSBsb29wLCBzbyBqdXN0IG1ha2Ugc3VyZSBzb21ldGhpbmcgaXMgbm9uLXplcm9cbiAgcmV0dXJuIChcbiAgICByZXN1bHQueWVhciB8fFxuICAgIHJlc3VsdC5tb250aCB8fFxuICAgIHJlc3VsdC5kYXkgfHxcbiAgICByZXN1bHQuaG91ciB8fFxuICAgIHJlc3VsdC5taW51dGUgfHxcbiAgICByZXN1bHQuc2Vjb25kIHx8XG4gICAgcmVzdWx0Lm1pbGxpc2Vjb25kXG4gICk7XG59XG5cbnZhciBzY3JhdGNoRHVyYXRpb24gPSBuZXcgR3JlZ29yaWFuRGF0ZSgpO1xuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IGluc3RhbmNlIGZyb20gYW4ge0BsaW5rIGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvSVNPXzg2MDF8SVNPIDg2MDF9IHRpbWUgaW50ZXJ2YWwgKHN0YXJ0L2VuZC9kdXJhdGlvbikuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgT2JqZWN0IHdpdGggdGhlIGZvbGxvd2luZyBwcm9wZXJ0aWVzOlxuICogQHBhcmFtIHtTdHJpbmd9IG9wdGlvbnMuaXNvODYwMSBBbiBJU08gODYwMSBpbnRlcnZhbC5cbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMuaXNTdGFydEluY2x1ZGVkPXRydWVdIDxjb2RlPnRydWU8L2NvZGU+IGlmIHN0YXJ0IHRpbWUgaXMgaW5jbHVkZWQgaW4gdGhlIGludGVydmFsLCA8Y29kZT5mYWxzZTwvY29kZT4gb3RoZXJ3aXNlLlxuICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5pc1N0b3BJbmNsdWRlZD10cnVlXSA8Y29kZT50cnVlPC9jb2RlPiBpZiBzdG9wIHRpbWUgaXMgaW5jbHVkZWQgaW4gdGhlIGludGVydmFsLCA8Y29kZT5mYWxzZTwvY29kZT4gb3RoZXJ3aXNlLlxuICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5sZWFkaW5nSW50ZXJ2YWw9ZmFsc2VdIDxjb2RlPnRydWU8L2NvZGU+IGlmIHlvdSB3YW50IHRvIGFkZCBhIGludGVydmFsIGZyb20gSXNvODYwMS5NSU5JTVVNX1ZBTFVFIHRvIHN0YXJ0IHRpbWUsICA8Y29kZT5mYWxzZTwvY29kZT4gb3RoZXJ3aXNlLlxuICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy50cmFpbGluZ0ludGVydmFsPWZhbHNlXSA8Y29kZT50cnVlPC9jb2RlPiBpZiB5b3Ugd2FudCB0byBhZGQgYSBpbnRlcnZhbCBmcm9tIHN0b3AgdGltZSB0byBJc284NjAxLk1BWElNVU1fVkFMVUUsICA8Y29kZT5mYWxzZTwvY29kZT4gb3RoZXJ3aXNlLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW29wdGlvbnMuZGF0YUNhbGxiYWNrXSBBIGZ1bmN0aW9uIHRoYXQgd2lsbCBiZSByZXR1cm4gdGhlIGRhdGEgdGhhdCBpcyBjYWxsZWQgd2l0aCBlYWNoIGludGVydmFsIGJlZm9yZSBpdCBpcyBhZGRlZCB0byB0aGUgY29sbGVjdGlvbi4gSWYgdW5zcGVjaWZpZWQsIHRoZSBkYXRhIHdpbGwgYmUgdGhlIGluZGV4IGluIHRoZSBjb2xsZWN0aW9uLlxuICogQHBhcmFtIHtUaW1lSW50ZXJ2YWxDb2xsZWN0aW9ufSBbcmVzdWx0XSBBbiBleGlzdGluZyBpbnN0YW5jZSB0byB1c2UgZm9yIHRoZSByZXN1bHQuXG4gKiBAcmV0dXJucyB7VGltZUludGVydmFsQ29sbGVjdGlvbn0gVGhlIG1vZGlmaWVkIHJlc3VsdCBwYXJhbWV0ZXIgb3IgYSBuZXcgaW5zdGFuY2UgaWYgbm9uZSB3YXMgcHJvdmlkZWQuXG4gKi9cblRpbWVJbnRlcnZhbENvbGxlY3Rpb24uZnJvbUlzbzg2MDEgPSBmdW5jdGlvbiAob3B0aW9ucywgcmVzdWx0KSB7XG4gIC8vPj5pbmNsdWRlU3RhcnQoJ2RlYnVnJywgcHJhZ21hcy5kZWJ1Zyk7XG4gIGlmICghZGVmaW5lZChvcHRpb25zKSkge1xuICAgIHRocm93IG5ldyBEZXZlbG9wZXJFcnJvcihcIm9wdGlvbnMgaXMgcmVxdWlyZWQuXCIpO1xuICB9XG4gIGlmICghZGVmaW5lZChvcHRpb25zLmlzbzg2MDEpKSB7XG4gICAgdGhyb3cgbmV3IERldmVsb3BlckVycm9yKFwib3B0aW9ucy5pc284NjAxIGlzIHJlcXVpcmVkLlwiKTtcbiAgfVxuICAvLz4+aW5jbHVkZUVuZCgnZGVidWcnKTtcblxuICB2YXIgZGF0ZXMgPSBvcHRpb25zLmlzbzg2MDEuc3BsaXQoXCIvXCIpO1xuICB2YXIgc3RhcnQgPSBKdWxpYW5EYXRlLmZyb21Jc284NjAxKGRhdGVzWzBdKTtcbiAgdmFyIHN0b3AgPSBKdWxpYW5EYXRlLmZyb21Jc284NjAxKGRhdGVzWzFdKTtcbiAgdmFyIGp1bGlhbkRhdGVzID0gW107XG5cbiAgaWYgKCFwYXJzZUR1cmF0aW9uKGRhdGVzWzJdLCBzY3JhdGNoRHVyYXRpb24pKSB7XG4gICAganVsaWFuRGF0ZXMucHVzaChzdGFydCwgc3RvcCk7XG4gIH0gZWxzZSB7XG4gICAgdmFyIGRhdGUgPSBKdWxpYW5EYXRlLmNsb25lKHN0YXJ0KTtcbiAgICBqdWxpYW5EYXRlcy5wdXNoKGRhdGUpO1xuICAgIHdoaWxlIChKdWxpYW5EYXRlLmNvbXBhcmUoZGF0ZSwgc3RvcCkgPCAwKSB7XG4gICAgICBkYXRlID0gYWRkVG9EYXRlKGRhdGUsIHNjcmF0Y2hEdXJhdGlvbik7XG4gICAgICB2YXIgYWZ0ZXJTdG9wID0gSnVsaWFuRGF0ZS5jb21wYXJlKHN0b3AsIGRhdGUpIDw9IDA7XG4gICAgICBpZiAoYWZ0ZXJTdG9wKSB7XG4gICAgICAgIEp1bGlhbkRhdGUuY2xvbmUoc3RvcCwgZGF0ZSk7XG4gICAgICB9XG5cbiAgICAgIGp1bGlhbkRhdGVzLnB1c2goZGF0ZSk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIFRpbWVJbnRlcnZhbENvbGxlY3Rpb24uZnJvbUp1bGlhbkRhdGVBcnJheShcbiAgICB7XG4gICAgICBqdWxpYW5EYXRlczoganVsaWFuRGF0ZXMsXG4gICAgICBpc1N0YXJ0SW5jbHVkZWQ6IG9wdGlvbnMuaXNTdGFydEluY2x1ZGVkLFxuICAgICAgaXNTdG9wSW5jbHVkZWQ6IG9wdGlvbnMuaXNTdG9wSW5jbHVkZWQsXG4gICAgICBsZWFkaW5nSW50ZXJ2YWw6IG9wdGlvbnMubGVhZGluZ0ludGVydmFsLFxuICAgICAgdHJhaWxpbmdJbnRlcnZhbDogb3B0aW9ucy50cmFpbGluZ0ludGVydmFsLFxuICAgICAgZGF0YUNhbGxiYWNrOiBvcHRpb25zLmRhdGFDYWxsYmFjayxcbiAgICB9LFxuICAgIHJlc3VsdFxuICApO1xufTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IGluc3RhbmNlIGZyb20gYSB7QGxpbmsgaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9JU09fODYwMXxJU08gODYwMX0gZGF0ZSBhcnJheS5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyBPYmplY3Qgd2l0aCB0aGUgZm9sbG93aW5nIHByb3BlcnRpZXM6XG4gKiBAcGFyYW0ge1N0cmluZ1tdfSBvcHRpb25zLmlzbzg2MDFEYXRlcyBBbiBhcnJheSBvZiBJU08gODYwMSBkYXRlcy5cbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMuaXNTdGFydEluY2x1ZGVkPXRydWVdIDxjb2RlPnRydWU8L2NvZGU+IGlmIHN0YXJ0IHRpbWUgaXMgaW5jbHVkZWQgaW4gdGhlIGludGVydmFsLCA8Y29kZT5mYWxzZTwvY29kZT4gb3RoZXJ3aXNlLlxuICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5pc1N0b3BJbmNsdWRlZD10cnVlXSA8Y29kZT50cnVlPC9jb2RlPiBpZiBzdG9wIHRpbWUgaXMgaW5jbHVkZWQgaW4gdGhlIGludGVydmFsLCA8Y29kZT5mYWxzZTwvY29kZT4gb3RoZXJ3aXNlLlxuICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5sZWFkaW5nSW50ZXJ2YWw9ZmFsc2VdIDxjb2RlPnRydWU8L2NvZGU+IGlmIHlvdSB3YW50IHRvIGFkZCBhIGludGVydmFsIGZyb20gSXNvODYwMS5NSU5JTVVNX1ZBTFVFIHRvIHN0YXJ0IHRpbWUsICA8Y29kZT5mYWxzZTwvY29kZT4gb3RoZXJ3aXNlLlxuICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy50cmFpbGluZ0ludGVydmFsPWZhbHNlXSA8Y29kZT50cnVlPC9jb2RlPiBpZiB5b3Ugd2FudCB0byBhZGQgYSBpbnRlcnZhbCBmcm9tIHN0b3AgdGltZSB0byBJc284NjAxLk1BWElNVU1fVkFMVUUsICA8Y29kZT5mYWxzZTwvY29kZT4gb3RoZXJ3aXNlLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW29wdGlvbnMuZGF0YUNhbGxiYWNrXSBBIGZ1bmN0aW9uIHRoYXQgd2lsbCBiZSByZXR1cm4gdGhlIGRhdGEgdGhhdCBpcyBjYWxsZWQgd2l0aCBlYWNoIGludGVydmFsIGJlZm9yZSBpdCBpcyBhZGRlZCB0byB0aGUgY29sbGVjdGlvbi4gSWYgdW5zcGVjaWZpZWQsIHRoZSBkYXRhIHdpbGwgYmUgdGhlIGluZGV4IGluIHRoZSBjb2xsZWN0aW9uLlxuICogQHBhcmFtIHtUaW1lSW50ZXJ2YWxDb2xsZWN0aW9ufSBbcmVzdWx0XSBBbiBleGlzdGluZyBpbnN0YW5jZSB0byB1c2UgZm9yIHRoZSByZXN1bHQuXG4gKiBAcmV0dXJucyB7VGltZUludGVydmFsQ29sbGVjdGlvbn0gVGhlIG1vZGlmaWVkIHJlc3VsdCBwYXJhbWV0ZXIgb3IgYSBuZXcgaW5zdGFuY2UgaWYgbm9uZSB3YXMgcHJvdmlkZWQuXG4gKi9cblRpbWVJbnRlcnZhbENvbGxlY3Rpb24uZnJvbUlzbzg2MDFEYXRlQXJyYXkgPSBmdW5jdGlvbiAob3B0aW9ucywgcmVzdWx0KSB7XG4gIC8vPj5pbmNsdWRlU3RhcnQoJ2RlYnVnJywgcHJhZ21hcy5kZWJ1Zyk7XG4gIGlmICghZGVmaW5lZChvcHRpb25zKSkge1xuICAgIHRocm93IG5ldyBEZXZlbG9wZXJFcnJvcihcIm9wdGlvbnMgaXMgcmVxdWlyZWQuXCIpO1xuICB9XG4gIGlmICghZGVmaW5lZChvcHRpb25zLmlzbzg2MDFEYXRlcykpIHtcbiAgICB0aHJvdyBuZXcgRGV2ZWxvcGVyRXJyb3IoXCJvcHRpb25zLmlzbzg2MDFEYXRlcyBpcyByZXF1aXJlZC5cIik7XG4gIH1cbiAgLy8+PmluY2x1ZGVFbmQoJ2RlYnVnJyk7XG5cbiAgcmV0dXJuIFRpbWVJbnRlcnZhbENvbGxlY3Rpb24uZnJvbUp1bGlhbkRhdGVBcnJheShcbiAgICB7XG4gICAgICBqdWxpYW5EYXRlczogb3B0aW9ucy5pc284NjAxRGF0ZXMubWFwKGZ1bmN0aW9uIChkYXRlKSB7XG4gICAgICAgIHJldHVybiBKdWxpYW5EYXRlLmZyb21Jc284NjAxKGRhdGUpO1xuICAgICAgfSksXG4gICAgICBpc1N0YXJ0SW5jbHVkZWQ6IG9wdGlvbnMuaXNTdGFydEluY2x1ZGVkLFxuICAgICAgaXNTdG9wSW5jbHVkZWQ6IG9wdGlvbnMuaXNTdG9wSW5jbHVkZWQsXG4gICAgICBsZWFkaW5nSW50ZXJ2YWw6IG9wdGlvbnMubGVhZGluZ0ludGVydmFsLFxuICAgICAgdHJhaWxpbmdJbnRlcnZhbDogb3B0aW9ucy50cmFpbGluZ0ludGVydmFsLFxuICAgICAgZGF0YUNhbGxiYWNrOiBvcHRpb25zLmRhdGFDYWxsYmFjayxcbiAgICB9LFxuICAgIHJlc3VsdFxuICApO1xufTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IGluc3RhbmNlIGZyb20gYSB7QGxpbmsgaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9JU09fODYwMXxJU08gODYwMX0gZHVyYXRpb24gYXJyYXkuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgT2JqZWN0IHdpdGggdGhlIGZvbGxvd2luZyBwcm9wZXJ0aWVzOlxuICogQHBhcmFtIHtKdWxpYW5EYXRlfSBvcHRpb25zLmVwb2NoIEFuIGRhdGUgdGhhdCB0aGUgZHVyYXRpb25zIGFyZSByZWxhdGl2ZSB0by5cbiAqIEBwYXJhbSB7U3RyaW5nfSBvcHRpb25zLmlzbzg2MDFEdXJhdGlvbnMgQW4gYXJyYXkgb2YgSVNPIDg2MDEgZHVyYXRpb25zLlxuICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5yZWxhdGl2ZVRvUHJldmlvdXM9ZmFsc2VdIDxjb2RlPnRydWU8L2NvZGU+IGlmIGR1cmF0aW9ucyBhcmUgcmVsYXRpdmUgdG8gcHJldmlvdXMgZGF0ZSwgPGNvZGU+ZmFsc2U8L2NvZGU+IGlmIGFsd2F5cyByZWxhdGl2ZSB0byB0aGUgZXBvY2guXG4gKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLmlzU3RhcnRJbmNsdWRlZD10cnVlXSA8Y29kZT50cnVlPC9jb2RlPiBpZiBzdGFydCB0aW1lIGlzIGluY2x1ZGVkIGluIHRoZSBpbnRlcnZhbCwgPGNvZGU+ZmFsc2U8L2NvZGU+IG90aGVyd2lzZS5cbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMuaXNTdG9wSW5jbHVkZWQ9dHJ1ZV0gPGNvZGU+dHJ1ZTwvY29kZT4gaWYgc3RvcCB0aW1lIGlzIGluY2x1ZGVkIGluIHRoZSBpbnRlcnZhbCwgPGNvZGU+ZmFsc2U8L2NvZGU+IG90aGVyd2lzZS5cbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMubGVhZGluZ0ludGVydmFsPWZhbHNlXSA8Y29kZT50cnVlPC9jb2RlPiBpZiB5b3Ugd2FudCB0byBhZGQgYSBpbnRlcnZhbCBmcm9tIElzbzg2MDEuTUlOSU1VTV9WQUxVRSB0byBzdGFydCB0aW1lLCAgPGNvZGU+ZmFsc2U8L2NvZGU+IG90aGVyd2lzZS5cbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMudHJhaWxpbmdJbnRlcnZhbD1mYWxzZV0gPGNvZGU+dHJ1ZTwvY29kZT4gaWYgeW91IHdhbnQgdG8gYWRkIGEgaW50ZXJ2YWwgZnJvbSBzdG9wIHRpbWUgdG8gSXNvODYwMS5NQVhJTVVNX1ZBTFVFLCAgPGNvZGU+ZmFsc2U8L2NvZGU+IG90aGVyd2lzZS5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtvcHRpb25zLmRhdGFDYWxsYmFja10gQSBmdW5jdGlvbiB0aGF0IHdpbGwgYmUgcmV0dXJuIHRoZSBkYXRhIHRoYXQgaXMgY2FsbGVkIHdpdGggZWFjaCBpbnRlcnZhbCBiZWZvcmUgaXQgaXMgYWRkZWQgdG8gdGhlIGNvbGxlY3Rpb24uIElmIHVuc3BlY2lmaWVkLCB0aGUgZGF0YSB3aWxsIGJlIHRoZSBpbmRleCBpbiB0aGUgY29sbGVjdGlvbi5cbiAqIEBwYXJhbSB7VGltZUludGVydmFsQ29sbGVjdGlvbn0gW3Jlc3VsdF0gQW4gZXhpc3RpbmcgaW5zdGFuY2UgdG8gdXNlIGZvciB0aGUgcmVzdWx0LlxuICogQHJldHVybnMge1RpbWVJbnRlcnZhbENvbGxlY3Rpb259IFRoZSBtb2RpZmllZCByZXN1bHQgcGFyYW1ldGVyIG9yIGEgbmV3IGluc3RhbmNlIGlmIG5vbmUgd2FzIHByb3ZpZGVkLlxuICovXG5UaW1lSW50ZXJ2YWxDb2xsZWN0aW9uLmZyb21Jc284NjAxRHVyYXRpb25BcnJheSA9IGZ1bmN0aW9uIChvcHRpb25zLCByZXN1bHQpIHtcbiAgLy8+PmluY2x1ZGVTdGFydCgnZGVidWcnLCBwcmFnbWFzLmRlYnVnKTtcbiAgaWYgKCFkZWZpbmVkKG9wdGlvbnMpKSB7XG4gICAgdGhyb3cgbmV3IERldmVsb3BlckVycm9yKFwib3B0aW9ucyBpcyByZXF1aXJlZC5cIik7XG4gIH1cbiAgaWYgKCFkZWZpbmVkKG9wdGlvbnMuZXBvY2gpKSB7XG4gICAgdGhyb3cgbmV3IERldmVsb3BlckVycm9yKFwib3B0aW9ucy5lcG9jaCBpcyByZXF1aXJlZC5cIik7XG4gIH1cbiAgaWYgKCFkZWZpbmVkKG9wdGlvbnMuaXNvODYwMUR1cmF0aW9ucykpIHtcbiAgICB0aHJvdyBuZXcgRGV2ZWxvcGVyRXJyb3IoXCJvcHRpb25zLmlzbzg2MDFEdXJhdGlvbnMgaXMgcmVxdWlyZWQuXCIpO1xuICB9XG4gIC8vPj5pbmNsdWRlRW5kKCdkZWJ1ZycpO1xuXG4gIHZhciBlcG9jaCA9IG9wdGlvbnMuZXBvY2g7XG4gIHZhciBpc284NjAxRHVyYXRpb25zID0gb3B0aW9ucy5pc284NjAxRHVyYXRpb25zO1xuICB2YXIgcmVsYXRpdmVUb1ByZXZpb3VzID0gZGVmYXVsdFZhbHVlKG9wdGlvbnMucmVsYXRpdmVUb1ByZXZpb3VzLCBmYWxzZSk7XG4gIHZhciBqdWxpYW5EYXRlcyA9IFtdO1xuICB2YXIgZGF0ZSwgcHJldmlvdXNEYXRlO1xuXG4gIHZhciBsZW5ndGggPSBpc284NjAxRHVyYXRpb25zLmxlbmd0aDtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7ICsraSkge1xuICAgIC8vIEFsbG93IGEgZHVyYXRpb24gb2YgMCBvbiB0aGUgZmlyc3QgaXRlcmF0aW9uLCBiZWNhdXNlIHRoZW4gaXQgaXMganVzdCB0aGUgZXBvY2hcbiAgICBpZiAocGFyc2VEdXJhdGlvbihpc284NjAxRHVyYXRpb25zW2ldLCBzY3JhdGNoRHVyYXRpb24pIHx8IGkgPT09IDApIHtcbiAgICAgIGlmIChyZWxhdGl2ZVRvUHJldmlvdXMgJiYgZGVmaW5lZChwcmV2aW91c0RhdGUpKSB7XG4gICAgICAgIGRhdGUgPSBhZGRUb0RhdGUocHJldmlvdXNEYXRlLCBzY3JhdGNoRHVyYXRpb24pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZGF0ZSA9IGFkZFRvRGF0ZShlcG9jaCwgc2NyYXRjaER1cmF0aW9uKTtcbiAgICAgIH1cbiAgICAgIGp1bGlhbkRhdGVzLnB1c2goZGF0ZSk7XG4gICAgICBwcmV2aW91c0RhdGUgPSBkYXRlO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBUaW1lSW50ZXJ2YWxDb2xsZWN0aW9uLmZyb21KdWxpYW5EYXRlQXJyYXkoXG4gICAge1xuICAgICAganVsaWFuRGF0ZXM6IGp1bGlhbkRhdGVzLFxuICAgICAgaXNTdGFydEluY2x1ZGVkOiBvcHRpb25zLmlzU3RhcnRJbmNsdWRlZCxcbiAgICAgIGlzU3RvcEluY2x1ZGVkOiBvcHRpb25zLmlzU3RvcEluY2x1ZGVkLFxuICAgICAgbGVhZGluZ0ludGVydmFsOiBvcHRpb25zLmxlYWRpbmdJbnRlcnZhbCxcbiAgICAgIHRyYWlsaW5nSW50ZXJ2YWw6IG9wdGlvbnMudHJhaWxpbmdJbnRlcnZhbCxcbiAgICAgIGRhdGFDYWxsYmFjazogb3B0aW9ucy5kYXRhQ2FsbGJhY2ssXG4gICAgfSxcbiAgICByZXN1bHRcbiAgKTtcbn07XG5leHBvcnQgZGVmYXVsdCBUaW1lSW50ZXJ2YWxDb2xsZWN0aW9uO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///46026\n')},13098:function(__unused_webpack___webpack_module__,__webpack_exports__){eval('/**\n * Provides the type of time standards which JulianDate can take as input.\n *\n * @enum {Number}\n *\n * @see JulianDate\n */\nvar TimeStandard = {\n  /**\n   * Represents the coordinated Universal Time (UTC) time standard.\n   *\n   * UTC is related to TAI according to the relationship\n   * <code>UTC = TAI - deltaT</code> where <code>deltaT</code> is the number of leap\n   * seconds which have been introduced as of the time in TAI.\n   *\n   * @type {Number}\n   * @constant\n   */\n  UTC: 0,\n\n  /**\n   * Represents the International Atomic Time (TAI) time standard.\n   * TAI is the principal time standard to which the other time standards are related.\n   *\n   * @type {Number}\n   * @constant\n   */\n  TAI: 1,\n};\n/* harmony default export */ __webpack_exports__["Z"] = (Object.freeze(TimeStandard));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTMwOTguanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseURBQWUsMkJBQTJCLEVBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly92dWUzLXdlYnBhY2s1Ly4vbm9kZV9tb2R1bGVzL2Nlc2l1bS9Tb3VyY2UvQ29yZS9UaW1lU3RhbmRhcmQuanM/NDE1OCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIFByb3ZpZGVzIHRoZSB0eXBlIG9mIHRpbWUgc3RhbmRhcmRzIHdoaWNoIEp1bGlhbkRhdGUgY2FuIHRha2UgYXMgaW5wdXQuXG4gKlxuICogQGVudW0ge051bWJlcn1cbiAqXG4gKiBAc2VlIEp1bGlhbkRhdGVcbiAqL1xudmFyIFRpbWVTdGFuZGFyZCA9IHtcbiAgLyoqXG4gICAqIFJlcHJlc2VudHMgdGhlIGNvb3JkaW5hdGVkIFVuaXZlcnNhbCBUaW1lIChVVEMpIHRpbWUgc3RhbmRhcmQuXG4gICAqXG4gICAqIFVUQyBpcyByZWxhdGVkIHRvIFRBSSBhY2NvcmRpbmcgdG8gdGhlIHJlbGF0aW9uc2hpcFxuICAgKiA8Y29kZT5VVEMgPSBUQUkgLSBkZWx0YVQ8L2NvZGU+IHdoZXJlIDxjb2RlPmRlbHRhVDwvY29kZT4gaXMgdGhlIG51bWJlciBvZiBsZWFwXG4gICAqIHNlY29uZHMgd2hpY2ggaGF2ZSBiZWVuIGludHJvZHVjZWQgYXMgb2YgdGhlIHRpbWUgaW4gVEFJLlxuICAgKlxuICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgKiBAY29uc3RhbnRcbiAgICovXG4gIFVUQzogMCxcblxuICAvKipcbiAgICogUmVwcmVzZW50cyB0aGUgSW50ZXJuYXRpb25hbCBBdG9taWMgVGltZSAoVEFJKSB0aW1lIHN0YW5kYXJkLlxuICAgKiBUQUkgaXMgdGhlIHByaW5jaXBhbCB0aW1lIHN0YW5kYXJkIHRvIHdoaWNoIHRoZSBvdGhlciB0aW1lIHN0YW5kYXJkcyBhcmUgcmVsYXRlZC5cbiAgICpcbiAgICogQHR5cGUge051bWJlcn1cbiAgICogQGNvbnN0YW50XG4gICAqL1xuICBUQUk6IDEsXG59O1xuZXhwb3J0IGRlZmF1bHQgT2JqZWN0LmZyZWV6ZShUaW1lU3RhbmRhcmQpO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///13098\n')},66965:function(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__){eval('/* harmony import */ var _defaultValue_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(62200);\n/* harmony import */ var _defined_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(82982);\n/* harmony import */ var _DeveloperError_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(12572);\n\n\n\n\n/**\n * Encapsulates an algorithm to optimize triangles for the post\n * vertex-shader cache.  This is based on the 2007 SIGGRAPH paper\n * \'Fast Triangle Reordering for Vertex Locality and Reduced Overdraw.\'\n * The runtime is linear but several passes are made.\n *\n * @namespace Tipsify\n *\n * @see <a href=\'http://gfx.cs.princeton.edu/pubs/Sander_2007_%3ETR/tipsy.pdf\'>\n * Fast Triangle Reordering for Vertex Locality and Reduced Overdraw</a>\n * by Sander, Nehab, and Barczak\n *\n * @private\n */\nvar Tipsify = {};\n\n/**\n * Calculates the average cache miss ratio (ACMR) for a given set of indices.\n *\n * @param {Object} options Object with the following properties:\n * @param {Number[]} options.indices Lists triads of numbers corresponding to the indices of the vertices\n *                        in the vertex buffer that define the geometry\'s triangles.\n * @param {Number} [options.maximumIndex] The maximum value of the elements in <code>args.indices</code>.\n *                                     If not supplied, this value will be computed.\n * @param {Number} [options.cacheSize=24] The number of vertices that can be stored in the cache at any one time.\n * @returns {Number} The average cache miss ratio (ACMR).\n *\n * @exception {DeveloperError} indices length must be a multiple of three.\n * @exception {DeveloperError} cacheSize must be greater than two.\n *\n * @example\n * var indices = [0, 1, 2, 3, 4, 5];\n * var maxIndex = 5;\n * var cacheSize = 3;\n * var acmr = Cesium.Tipsify.calculateACMR({indices : indices, maxIndex : maxIndex, cacheSize : cacheSize});\n */\nTipsify.calculateACMR = function (options) {\n  options = (0,_defaultValue_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .Z)(options, _defaultValue_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].EMPTY_OBJECT */ .Z.EMPTY_OBJECT);\n  var indices = options.indices;\n  var maximumIndex = options.maximumIndex;\n  var cacheSize = (0,_defaultValue_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .Z)(options.cacheSize, 24);\n\n  //>>includeStart(\'debug\', pragmas.debug);\n  if (!(0,_defined_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"] */ .Z)(indices)) {\n    throw new _DeveloperError_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .Z("indices is required.");\n  }\n  //>>includeEnd(\'debug\');\n\n  var numIndices = indices.length;\n\n  //>>includeStart(\'debug\', pragmas.debug);\n  if (numIndices < 3 || numIndices % 3 !== 0) {\n    throw new _DeveloperError_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .Z("indices length must be a multiple of three.");\n  }\n  if (maximumIndex <= 0) {\n    throw new _DeveloperError_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .Z("maximumIndex must be greater than zero.");\n  }\n  if (cacheSize < 3) {\n    throw new _DeveloperError_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .Z("cacheSize must be greater than two.");\n  }\n  //>>includeEnd(\'debug\');\n\n  // Compute the maximumIndex if not given\n  if (!(0,_defined_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"] */ .Z)(maximumIndex)) {\n    maximumIndex = 0;\n    var currentIndex = 0;\n    var intoIndices = indices[currentIndex];\n    while (currentIndex < numIndices) {\n      if (intoIndices > maximumIndex) {\n        maximumIndex = intoIndices;\n      }\n      ++currentIndex;\n      intoIndices = indices[currentIndex];\n    }\n  }\n\n  // Vertex time stamps\n  var vertexTimeStamps = [];\n  for (var i = 0; i < maximumIndex + 1; i++) {\n    vertexTimeStamps[i] = 0;\n  }\n\n  // Cache processing\n  var s = cacheSize + 1;\n  for (var j = 0; j < numIndices; ++j) {\n    if (s - vertexTimeStamps[indices[j]] > cacheSize) {\n      vertexTimeStamps[indices[j]] = s;\n      ++s;\n    }\n  }\n\n  return (s - cacheSize + 1) / (numIndices / 3);\n};\n\n/**\n * Optimizes triangles for the post-vertex shader cache.\n *\n * @param {Object} options Object with the following properties:\n * @param {Number[]} options.indices Lists triads of numbers corresponding to the indices of the vertices\n *                        in the vertex buffer that define the geometry\'s triangles.\n * @param {Number} [options.maximumIndex] The maximum value of the elements in <code>args.indices</code>.\n *                                     If not supplied, this value will be computed.\n * @param {Number} [options.cacheSize=24] The number of vertices that can be stored in the cache at any one time.\n * @returns {Number[]} A list of the input indices in an optimized order.\n *\n * @exception {DeveloperError} indices length must be a multiple of three.\n * @exception {DeveloperError} cacheSize must be greater than two.\n *\n * @example\n * var indices = [0, 1, 2, 3, 4, 5];\n * var maxIndex = 5;\n * var cacheSize = 3;\n * var reorderedIndices = Cesium.Tipsify.tipsify({indices : indices, maxIndex : maxIndex, cacheSize : cacheSize});\n */\nTipsify.tipsify = function (options) {\n  options = (0,_defaultValue_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .Z)(options, _defaultValue_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].EMPTY_OBJECT */ .Z.EMPTY_OBJECT);\n  var indices = options.indices;\n  var maximumIndex = options.maximumIndex;\n  var cacheSize = (0,_defaultValue_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .Z)(options.cacheSize, 24);\n\n  var cursor;\n\n  function skipDeadEnd(vertices, deadEnd, indices, maximumIndexPlusOne) {\n    while (deadEnd.length >= 1) {\n      // while the stack is not empty\n      var d = deadEnd[deadEnd.length - 1]; // top of the stack\n      deadEnd.splice(deadEnd.length - 1, 1); // pop the stack\n\n      if (vertices[d].numLiveTriangles > 0) {\n        return d;\n      }\n    }\n\n    while (cursor < maximumIndexPlusOne) {\n      if (vertices[cursor].numLiveTriangles > 0) {\n        ++cursor;\n        return cursor - 1;\n      }\n      ++cursor;\n    }\n    return -1;\n  }\n\n  function getNextVertex(\n    indices,\n    cacheSize,\n    oneRing,\n    vertices,\n    s,\n    deadEnd,\n    maximumIndexPlusOne\n  ) {\n    var n = -1;\n    var p;\n    var m = -1;\n    var itOneRing = 0;\n    while (itOneRing < oneRing.length) {\n      var index = oneRing[itOneRing];\n      if (vertices[index].numLiveTriangles) {\n        p = 0;\n        if (\n          s -\n            vertices[index].timeStamp +\n            2 * vertices[index].numLiveTriangles <=\n          cacheSize\n        ) {\n          p = s - vertices[index].timeStamp;\n        }\n        if (p > m || m === -1) {\n          m = p;\n          n = index;\n        }\n      }\n      ++itOneRing;\n    }\n    if (n === -1) {\n      return skipDeadEnd(vertices, deadEnd, indices, maximumIndexPlusOne);\n    }\n    return n;\n  }\n\n  //>>includeStart(\'debug\', pragmas.debug);\n  if (!(0,_defined_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"] */ .Z)(indices)) {\n    throw new _DeveloperError_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .Z("indices is required.");\n  }\n  //>>includeEnd(\'debug\');\n\n  var numIndices = indices.length;\n\n  //>>includeStart(\'debug\', pragmas.debug);\n  if (numIndices < 3 || numIndices % 3 !== 0) {\n    throw new _DeveloperError_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .Z("indices length must be a multiple of three.");\n  }\n  if (maximumIndex <= 0) {\n    throw new _DeveloperError_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .Z("maximumIndex must be greater than zero.");\n  }\n  if (cacheSize < 3) {\n    throw new _DeveloperError_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .Z("cacheSize must be greater than two.");\n  }\n  //>>includeEnd(\'debug\');\n\n  // Determine maximum index\n  var maximumIndexPlusOne = 0;\n  var currentIndex = 0;\n  var intoIndices = indices[currentIndex];\n  var endIndex = numIndices;\n  if ((0,_defined_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"] */ .Z)(maximumIndex)) {\n    maximumIndexPlusOne = maximumIndex + 1;\n  } else {\n    while (currentIndex < endIndex) {\n      if (intoIndices > maximumIndexPlusOne) {\n        maximumIndexPlusOne = intoIndices;\n      }\n      ++currentIndex;\n      intoIndices = indices[currentIndex];\n    }\n    if (maximumIndexPlusOne === -1) {\n      return 0;\n    }\n    ++maximumIndexPlusOne;\n  }\n\n  // Vertices\n  var vertices = [];\n  var i;\n  for (i = 0; i < maximumIndexPlusOne; i++) {\n    vertices[i] = {\n      numLiveTriangles: 0,\n      timeStamp: 0,\n      vertexTriangles: [],\n    };\n  }\n  currentIndex = 0;\n  var triangle = 0;\n  while (currentIndex < endIndex) {\n    vertices[indices[currentIndex]].vertexTriangles.push(triangle);\n    ++vertices[indices[currentIndex]].numLiveTriangles;\n    vertices[indices[currentIndex + 1]].vertexTriangles.push(triangle);\n    ++vertices[indices[currentIndex + 1]].numLiveTriangles;\n    vertices[indices[currentIndex + 2]].vertexTriangles.push(triangle);\n    ++vertices[indices[currentIndex + 2]].numLiveTriangles;\n    ++triangle;\n    currentIndex += 3;\n  }\n\n  // Starting index\n  var f = 0;\n\n  // Time Stamp\n  var s = cacheSize + 1;\n  cursor = 1;\n\n  // Process\n  var oneRing = [];\n  var deadEnd = []; //Stack\n  var vertex;\n  var intoVertices;\n  var currentOutputIndex = 0;\n  var outputIndices = [];\n  var numTriangles = numIndices / 3;\n  var triangleEmitted = [];\n  for (i = 0; i < numTriangles; i++) {\n    triangleEmitted[i] = false;\n  }\n  var index;\n  var limit;\n  while (f !== -1) {\n    oneRing = [];\n    intoVertices = vertices[f];\n    limit = intoVertices.vertexTriangles.length;\n    for (var k = 0; k < limit; ++k) {\n      triangle = intoVertices.vertexTriangles[k];\n      if (!triangleEmitted[triangle]) {\n        triangleEmitted[triangle] = true;\n        currentIndex = triangle + triangle + triangle;\n        for (var j = 0; j < 3; ++j) {\n          // Set this index as a possible next index\n          index = indices[currentIndex];\n          oneRing.push(index);\n          deadEnd.push(index);\n\n          // Output index\n          outputIndices[currentOutputIndex] = index;\n          ++currentOutputIndex;\n\n          // Cache processing\n          vertex = vertices[index];\n          --vertex.numLiveTriangles;\n          if (s - vertex.timeStamp > cacheSize) {\n            vertex.timeStamp = s;\n            ++s;\n          }\n          ++currentIndex;\n        }\n      }\n    }\n    f = getNextVertex(\n      indices,\n      cacheSize,\n      oneRing,\n      vertices,\n      s,\n      deadEnd,\n      maximumIndexPlusOne\n    );\n  }\n\n  return outputIndices;\n};\n/* harmony default export */ __webpack_exports__["Z"] = (Tipsify);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFdBQVc7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsT0FBTztBQUMvQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx5REFBZSxPQUFPLEVBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly92dWUzLXdlYnBhY2s1Ly4vbm9kZV9tb2R1bGVzL2Nlc2l1bS9Tb3VyY2UvQ29yZS9UaXBzaWZ5LmpzPzBlNTYiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IGRlZmF1bHRWYWx1ZSBmcm9tIFwiLi9kZWZhdWx0VmFsdWUuanNcIjtcbmltcG9ydCBkZWZpbmVkIGZyb20gXCIuL2RlZmluZWQuanNcIjtcbmltcG9ydCBEZXZlbG9wZXJFcnJvciBmcm9tIFwiLi9EZXZlbG9wZXJFcnJvci5qc1wiO1xuXG4vKipcbiAqIEVuY2Fwc3VsYXRlcyBhbiBhbGdvcml0aG0gdG8gb3B0aW1pemUgdHJpYW5nbGVzIGZvciB0aGUgcG9zdFxuICogdmVydGV4LXNoYWRlciBjYWNoZS4gIFRoaXMgaXMgYmFzZWQgb24gdGhlIDIwMDcgU0lHR1JBUEggcGFwZXJcbiAqICdGYXN0IFRyaWFuZ2xlIFJlb3JkZXJpbmcgZm9yIFZlcnRleCBMb2NhbGl0eSBhbmQgUmVkdWNlZCBPdmVyZHJhdy4nXG4gKiBUaGUgcnVudGltZSBpcyBsaW5lYXIgYnV0IHNldmVyYWwgcGFzc2VzIGFyZSBtYWRlLlxuICpcbiAqIEBuYW1lc3BhY2UgVGlwc2lmeVxuICpcbiAqIEBzZWUgPGEgaHJlZj0naHR0cDovL2dmeC5jcy5wcmluY2V0b24uZWR1L3B1YnMvU2FuZGVyXzIwMDdfJTNFVFIvdGlwc3kucGRmJz5cbiAqIEZhc3QgVHJpYW5nbGUgUmVvcmRlcmluZyBmb3IgVmVydGV4IExvY2FsaXR5IGFuZCBSZWR1Y2VkIE92ZXJkcmF3PC9hPlxuICogYnkgU2FuZGVyLCBOZWhhYiwgYW5kIEJhcmN6YWtcbiAqXG4gKiBAcHJpdmF0ZVxuICovXG52YXIgVGlwc2lmeSA9IHt9O1xuXG4vKipcbiAqIENhbGN1bGF0ZXMgdGhlIGF2ZXJhZ2UgY2FjaGUgbWlzcyByYXRpbyAoQUNNUikgZm9yIGEgZ2l2ZW4gc2V0IG9mIGluZGljZXMuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgT2JqZWN0IHdpdGggdGhlIGZvbGxvd2luZyBwcm9wZXJ0aWVzOlxuICogQHBhcmFtIHtOdW1iZXJbXX0gb3B0aW9ucy5pbmRpY2VzIExpc3RzIHRyaWFkcyBvZiBudW1iZXJzIGNvcnJlc3BvbmRpbmcgdG8gdGhlIGluZGljZXMgb2YgdGhlIHZlcnRpY2VzXG4gKiAgICAgICAgICAgICAgICAgICAgICAgIGluIHRoZSB2ZXJ0ZXggYnVmZmVyIHRoYXQgZGVmaW5lIHRoZSBnZW9tZXRyeSdzIHRyaWFuZ2xlcy5cbiAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5tYXhpbXVtSW5kZXhdIFRoZSBtYXhpbXVtIHZhbHVlIG9mIHRoZSBlbGVtZW50cyBpbiA8Y29kZT5hcmdzLmluZGljZXM8L2NvZGU+LlxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgSWYgbm90IHN1cHBsaWVkLCB0aGlzIHZhbHVlIHdpbGwgYmUgY29tcHV0ZWQuXG4gKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMuY2FjaGVTaXplPTI0XSBUaGUgbnVtYmVyIG9mIHZlcnRpY2VzIHRoYXQgY2FuIGJlIHN0b3JlZCBpbiB0aGUgY2FjaGUgYXQgYW55IG9uZSB0aW1lLlxuICogQHJldHVybnMge051bWJlcn0gVGhlIGF2ZXJhZ2UgY2FjaGUgbWlzcyByYXRpbyAoQUNNUikuXG4gKlxuICogQGV4Y2VwdGlvbiB7RGV2ZWxvcGVyRXJyb3J9IGluZGljZXMgbGVuZ3RoIG11c3QgYmUgYSBtdWx0aXBsZSBvZiB0aHJlZS5cbiAqIEBleGNlcHRpb24ge0RldmVsb3BlckVycm9yfSBjYWNoZVNpemUgbXVzdCBiZSBncmVhdGVyIHRoYW4gdHdvLlxuICpcbiAqIEBleGFtcGxlXG4gKiB2YXIgaW5kaWNlcyA9IFswLCAxLCAyLCAzLCA0LCA1XTtcbiAqIHZhciBtYXhJbmRleCA9IDU7XG4gKiB2YXIgY2FjaGVTaXplID0gMztcbiAqIHZhciBhY21yID0gQ2VzaXVtLlRpcHNpZnkuY2FsY3VsYXRlQUNNUih7aW5kaWNlcyA6IGluZGljZXMsIG1heEluZGV4IDogbWF4SW5kZXgsIGNhY2hlU2l6ZSA6IGNhY2hlU2l6ZX0pO1xuICovXG5UaXBzaWZ5LmNhbGN1bGF0ZUFDTVIgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICBvcHRpb25zID0gZGVmYXVsdFZhbHVlKG9wdGlvbnMsIGRlZmF1bHRWYWx1ZS5FTVBUWV9PQkpFQ1QpO1xuICB2YXIgaW5kaWNlcyA9IG9wdGlvbnMuaW5kaWNlcztcbiAgdmFyIG1heGltdW1JbmRleCA9IG9wdGlvbnMubWF4aW11bUluZGV4O1xuICB2YXIgY2FjaGVTaXplID0gZGVmYXVsdFZhbHVlKG9wdGlvbnMuY2FjaGVTaXplLCAyNCk7XG5cbiAgLy8+PmluY2x1ZGVTdGFydCgnZGVidWcnLCBwcmFnbWFzLmRlYnVnKTtcbiAgaWYgKCFkZWZpbmVkKGluZGljZXMpKSB7XG4gICAgdGhyb3cgbmV3IERldmVsb3BlckVycm9yKFwiaW5kaWNlcyBpcyByZXF1aXJlZC5cIik7XG4gIH1cbiAgLy8+PmluY2x1ZGVFbmQoJ2RlYnVnJyk7XG5cbiAgdmFyIG51bUluZGljZXMgPSBpbmRpY2VzLmxlbmd0aDtcblxuICAvLz4+aW5jbHVkZVN0YXJ0KCdkZWJ1ZycsIHByYWdtYXMuZGVidWcpO1xuICBpZiAobnVtSW5kaWNlcyA8IDMgfHwgbnVtSW5kaWNlcyAlIDMgIT09IDApIHtcbiAgICB0aHJvdyBuZXcgRGV2ZWxvcGVyRXJyb3IoXCJpbmRpY2VzIGxlbmd0aCBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgdGhyZWUuXCIpO1xuICB9XG4gIGlmIChtYXhpbXVtSW5kZXggPD0gMCkge1xuICAgIHRocm93IG5ldyBEZXZlbG9wZXJFcnJvcihcIm1heGltdW1JbmRleCBtdXN0IGJlIGdyZWF0ZXIgdGhhbiB6ZXJvLlwiKTtcbiAgfVxuICBpZiAoY2FjaGVTaXplIDwgMykge1xuICAgIHRocm93IG5ldyBEZXZlbG9wZXJFcnJvcihcImNhY2hlU2l6ZSBtdXN0IGJlIGdyZWF0ZXIgdGhhbiB0d28uXCIpO1xuICB9XG4gIC8vPj5pbmNsdWRlRW5kKCdkZWJ1ZycpO1xuXG4gIC8vIENvbXB1dGUgdGhlIG1heGltdW1JbmRleCBpZiBub3QgZ2l2ZW5cbiAgaWYgKCFkZWZpbmVkKG1heGltdW1JbmRleCkpIHtcbiAgICBtYXhpbXVtSW5kZXggPSAwO1xuICAgIHZhciBjdXJyZW50SW5kZXggPSAwO1xuICAgIHZhciBpbnRvSW5kaWNlcyA9IGluZGljZXNbY3VycmVudEluZGV4XTtcbiAgICB3aGlsZSAoY3VycmVudEluZGV4IDwgbnVtSW5kaWNlcykge1xuICAgICAgaWYgKGludG9JbmRpY2VzID4gbWF4aW11bUluZGV4KSB7XG4gICAgICAgIG1heGltdW1JbmRleCA9IGludG9JbmRpY2VzO1xuICAgICAgfVxuICAgICAgKytjdXJyZW50SW5kZXg7XG4gICAgICBpbnRvSW5kaWNlcyA9IGluZGljZXNbY3VycmVudEluZGV4XTtcbiAgICB9XG4gIH1cblxuICAvLyBWZXJ0ZXggdGltZSBzdGFtcHNcbiAgdmFyIHZlcnRleFRpbWVTdGFtcHMgPSBbXTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBtYXhpbXVtSW5kZXggKyAxOyBpKyspIHtcbiAgICB2ZXJ0ZXhUaW1lU3RhbXBzW2ldID0gMDtcbiAgfVxuXG4gIC8vIENhY2hlIHByb2Nlc3NpbmdcbiAgdmFyIHMgPSBjYWNoZVNpemUgKyAxO1xuICBmb3IgKHZhciBqID0gMDsgaiA8IG51bUluZGljZXM7ICsraikge1xuICAgIGlmIChzIC0gdmVydGV4VGltZVN0YW1wc1tpbmRpY2VzW2pdXSA+IGNhY2hlU2l6ZSkge1xuICAgICAgdmVydGV4VGltZVN0YW1wc1tpbmRpY2VzW2pdXSA9IHM7XG4gICAgICArK3M7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIChzIC0gY2FjaGVTaXplICsgMSkgLyAobnVtSW5kaWNlcyAvIDMpO1xufTtcblxuLyoqXG4gKiBPcHRpbWl6ZXMgdHJpYW5nbGVzIGZvciB0aGUgcG9zdC12ZXJ0ZXggc2hhZGVyIGNhY2hlLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIE9iamVjdCB3aXRoIHRoZSBmb2xsb3dpbmcgcHJvcGVydGllczpcbiAqIEBwYXJhbSB7TnVtYmVyW119IG9wdGlvbnMuaW5kaWNlcyBMaXN0cyB0cmlhZHMgb2YgbnVtYmVycyBjb3JyZXNwb25kaW5nIHRvIHRoZSBpbmRpY2VzIG9mIHRoZSB2ZXJ0aWNlc1xuICogICAgICAgICAgICAgICAgICAgICAgICBpbiB0aGUgdmVydGV4IGJ1ZmZlciB0aGF0IGRlZmluZSB0aGUgZ2VvbWV0cnkncyB0cmlhbmdsZXMuXG4gKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMubWF4aW11bUluZGV4XSBUaGUgbWF4aW11bSB2YWx1ZSBvZiB0aGUgZWxlbWVudHMgaW4gPGNvZGU+YXJncy5pbmRpY2VzPC9jb2RlPi5cbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIElmIG5vdCBzdXBwbGllZCwgdGhpcyB2YWx1ZSB3aWxsIGJlIGNvbXB1dGVkLlxuICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLmNhY2hlU2l6ZT0yNF0gVGhlIG51bWJlciBvZiB2ZXJ0aWNlcyB0aGF0IGNhbiBiZSBzdG9yZWQgaW4gdGhlIGNhY2hlIGF0IGFueSBvbmUgdGltZS5cbiAqIEByZXR1cm5zIHtOdW1iZXJbXX0gQSBsaXN0IG9mIHRoZSBpbnB1dCBpbmRpY2VzIGluIGFuIG9wdGltaXplZCBvcmRlci5cbiAqXG4gKiBAZXhjZXB0aW9uIHtEZXZlbG9wZXJFcnJvcn0gaW5kaWNlcyBsZW5ndGggbXVzdCBiZSBhIG11bHRpcGxlIG9mIHRocmVlLlxuICogQGV4Y2VwdGlvbiB7RGV2ZWxvcGVyRXJyb3J9IGNhY2hlU2l6ZSBtdXN0IGJlIGdyZWF0ZXIgdGhhbiB0d28uXG4gKlxuICogQGV4YW1wbGVcbiAqIHZhciBpbmRpY2VzID0gWzAsIDEsIDIsIDMsIDQsIDVdO1xuICogdmFyIG1heEluZGV4ID0gNTtcbiAqIHZhciBjYWNoZVNpemUgPSAzO1xuICogdmFyIHJlb3JkZXJlZEluZGljZXMgPSBDZXNpdW0uVGlwc2lmeS50aXBzaWZ5KHtpbmRpY2VzIDogaW5kaWNlcywgbWF4SW5kZXggOiBtYXhJbmRleCwgY2FjaGVTaXplIDogY2FjaGVTaXplfSk7XG4gKi9cblRpcHNpZnkudGlwc2lmeSA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gIG9wdGlvbnMgPSBkZWZhdWx0VmFsdWUob3B0aW9ucywgZGVmYXVsdFZhbHVlLkVNUFRZX09CSkVDVCk7XG4gIHZhciBpbmRpY2VzID0gb3B0aW9ucy5pbmRpY2VzO1xuICB2YXIgbWF4aW11bUluZGV4ID0gb3B0aW9ucy5tYXhpbXVtSW5kZXg7XG4gIHZhciBjYWNoZVNpemUgPSBkZWZhdWx0VmFsdWUob3B0aW9ucy5jYWNoZVNpemUsIDI0KTtcblxuICB2YXIgY3Vyc29yO1xuXG4gIGZ1bmN0aW9uIHNraXBEZWFkRW5kKHZlcnRpY2VzLCBkZWFkRW5kLCBpbmRpY2VzLCBtYXhpbXVtSW5kZXhQbHVzT25lKSB7XG4gICAgd2hpbGUgKGRlYWRFbmQubGVuZ3RoID49IDEpIHtcbiAgICAgIC8vIHdoaWxlIHRoZSBzdGFjayBpcyBub3QgZW1wdHlcbiAgICAgIHZhciBkID0gZGVhZEVuZFtkZWFkRW5kLmxlbmd0aCAtIDFdOyAvLyB0b3Agb2YgdGhlIHN0YWNrXG4gICAgICBkZWFkRW5kLnNwbGljZShkZWFkRW5kLmxlbmd0aCAtIDEsIDEpOyAvLyBwb3AgdGhlIHN0YWNrXG5cbiAgICAgIGlmICh2ZXJ0aWNlc1tkXS5udW1MaXZlVHJpYW5nbGVzID4gMCkge1xuICAgICAgICByZXR1cm4gZDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB3aGlsZSAoY3Vyc29yIDwgbWF4aW11bUluZGV4UGx1c09uZSkge1xuICAgICAgaWYgKHZlcnRpY2VzW2N1cnNvcl0ubnVtTGl2ZVRyaWFuZ2xlcyA+IDApIHtcbiAgICAgICAgKytjdXJzb3I7XG4gICAgICAgIHJldHVybiBjdXJzb3IgLSAxO1xuICAgICAgfVxuICAgICAgKytjdXJzb3I7XG4gICAgfVxuICAgIHJldHVybiAtMTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGdldE5leHRWZXJ0ZXgoXG4gICAgaW5kaWNlcyxcbiAgICBjYWNoZVNpemUsXG4gICAgb25lUmluZyxcbiAgICB2ZXJ0aWNlcyxcbiAgICBzLFxuICAgIGRlYWRFbmQsXG4gICAgbWF4aW11bUluZGV4UGx1c09uZVxuICApIHtcbiAgICB2YXIgbiA9IC0xO1xuICAgIHZhciBwO1xuICAgIHZhciBtID0gLTE7XG4gICAgdmFyIGl0T25lUmluZyA9IDA7XG4gICAgd2hpbGUgKGl0T25lUmluZyA8IG9uZVJpbmcubGVuZ3RoKSB7XG4gICAgICB2YXIgaW5kZXggPSBvbmVSaW5nW2l0T25lUmluZ107XG4gICAgICBpZiAodmVydGljZXNbaW5kZXhdLm51bUxpdmVUcmlhbmdsZXMpIHtcbiAgICAgICAgcCA9IDA7XG4gICAgICAgIGlmIChcbiAgICAgICAgICBzIC1cbiAgICAgICAgICAgIHZlcnRpY2VzW2luZGV4XS50aW1lU3RhbXAgK1xuICAgICAgICAgICAgMiAqIHZlcnRpY2VzW2luZGV4XS5udW1MaXZlVHJpYW5nbGVzIDw9XG4gICAgICAgICAgY2FjaGVTaXplXG4gICAgICAgICkge1xuICAgICAgICAgIHAgPSBzIC0gdmVydGljZXNbaW5kZXhdLnRpbWVTdGFtcDtcbiAgICAgICAgfVxuICAgICAgICBpZiAocCA+IG0gfHwgbSA9PT0gLTEpIHtcbiAgICAgICAgICBtID0gcDtcbiAgICAgICAgICBuID0gaW5kZXg7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgICsraXRPbmVSaW5nO1xuICAgIH1cbiAgICBpZiAobiA9PT0gLTEpIHtcbiAgICAgIHJldHVybiBza2lwRGVhZEVuZCh2ZXJ0aWNlcywgZGVhZEVuZCwgaW5kaWNlcywgbWF4aW11bUluZGV4UGx1c09uZSk7XG4gICAgfVxuICAgIHJldHVybiBuO1xuICB9XG5cbiAgLy8+PmluY2x1ZGVTdGFydCgnZGVidWcnLCBwcmFnbWFzLmRlYnVnKTtcbiAgaWYgKCFkZWZpbmVkKGluZGljZXMpKSB7XG4gICAgdGhyb3cgbmV3IERldmVsb3BlckVycm9yKFwiaW5kaWNlcyBpcyByZXF1aXJlZC5cIik7XG4gIH1cbiAgLy8+PmluY2x1ZGVFbmQoJ2RlYnVnJyk7XG5cbiAgdmFyIG51bUluZGljZXMgPSBpbmRpY2VzLmxlbmd0aDtcblxuICAvLz4+aW5jbHVkZVN0YXJ0KCdkZWJ1ZycsIHByYWdtYXMuZGVidWcpO1xuICBpZiAobnVtSW5kaWNlcyA8IDMgfHwgbnVtSW5kaWNlcyAlIDMgIT09IDApIHtcbiAgICB0aHJvdyBuZXcgRGV2ZWxvcGVyRXJyb3IoXCJpbmRpY2VzIGxlbmd0aCBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgdGhyZWUuXCIpO1xuICB9XG4gIGlmIChtYXhpbXVtSW5kZXggPD0gMCkge1xuICAgIHRocm93IG5ldyBEZXZlbG9wZXJFcnJvcihcIm1heGltdW1JbmRleCBtdXN0IGJlIGdyZWF0ZXIgdGhhbiB6ZXJvLlwiKTtcbiAgfVxuICBpZiAoY2FjaGVTaXplIDwgMykge1xuICAgIHRocm93IG5ldyBEZXZlbG9wZXJFcnJvcihcImNhY2hlU2l6ZSBtdXN0IGJlIGdyZWF0ZXIgdGhhbiB0d28uXCIpO1xuICB9XG4gIC8vPj5pbmNsdWRlRW5kKCdkZWJ1ZycpO1xuXG4gIC8vIERldGVybWluZSBtYXhpbXVtIGluZGV4XG4gIHZhciBtYXhpbXVtSW5kZXhQbHVzT25lID0gMDtcbiAgdmFyIGN1cnJlbnRJbmRleCA9IDA7XG4gIHZhciBpbnRvSW5kaWNlcyA9IGluZGljZXNbY3VycmVudEluZGV4XTtcbiAgdmFyIGVuZEluZGV4ID0gbnVtSW5kaWNlcztcbiAgaWYgKGRlZmluZWQobWF4aW11bUluZGV4KSkge1xuICAgIG1heGltdW1JbmRleFBsdXNPbmUgPSBtYXhpbXVtSW5kZXggKyAxO1xuICB9IGVsc2Uge1xuICAgIHdoaWxlIChjdXJyZW50SW5kZXggPCBlbmRJbmRleCkge1xuICAgICAgaWYgKGludG9JbmRpY2VzID4gbWF4aW11bUluZGV4UGx1c09uZSkge1xuICAgICAgICBtYXhpbXVtSW5kZXhQbHVzT25lID0gaW50b0luZGljZXM7XG4gICAgICB9XG4gICAgICArK2N1cnJlbnRJbmRleDtcbiAgICAgIGludG9JbmRpY2VzID0gaW5kaWNlc1tjdXJyZW50SW5kZXhdO1xuICAgIH1cbiAgICBpZiAobWF4aW11bUluZGV4UGx1c09uZSA9PT0gLTEpIHtcbiAgICAgIHJldHVybiAwO1xuICAgIH1cbiAgICArK21heGltdW1JbmRleFBsdXNPbmU7XG4gIH1cblxuICAvLyBWZXJ0aWNlc1xuICB2YXIgdmVydGljZXMgPSBbXTtcbiAgdmFyIGk7XG4gIGZvciAoaSA9IDA7IGkgPCBtYXhpbXVtSW5kZXhQbHVzT25lOyBpKyspIHtcbiAgICB2ZXJ0aWNlc1tpXSA9IHtcbiAgICAgIG51bUxpdmVUcmlhbmdsZXM6IDAsXG4gICAgICB0aW1lU3RhbXA6IDAsXG4gICAgICB2ZXJ0ZXhUcmlhbmdsZXM6IFtdLFxuICAgIH07XG4gIH1cbiAgY3VycmVudEluZGV4ID0gMDtcbiAgdmFyIHRyaWFuZ2xlID0gMDtcbiAgd2hpbGUgKGN1cnJlbnRJbmRleCA8IGVuZEluZGV4KSB7XG4gICAgdmVydGljZXNbaW5kaWNlc1tjdXJyZW50SW5kZXhdXS52ZXJ0ZXhUcmlhbmdsZXMucHVzaCh0cmlhbmdsZSk7XG4gICAgKyt2ZXJ0aWNlc1tpbmRpY2VzW2N1cnJlbnRJbmRleF1dLm51bUxpdmVUcmlhbmdsZXM7XG4gICAgdmVydGljZXNbaW5kaWNlc1tjdXJyZW50SW5kZXggKyAxXV0udmVydGV4VHJpYW5nbGVzLnB1c2godHJpYW5nbGUpO1xuICAgICsrdmVydGljZXNbaW5kaWNlc1tjdXJyZW50SW5kZXggKyAxXV0ubnVtTGl2ZVRyaWFuZ2xlcztcbiAgICB2ZXJ0aWNlc1tpbmRpY2VzW2N1cnJlbnRJbmRleCArIDJdXS52ZXJ0ZXhUcmlhbmdsZXMucHVzaCh0cmlhbmdsZSk7XG4gICAgKyt2ZXJ0aWNlc1tpbmRpY2VzW2N1cnJlbnRJbmRleCArIDJdXS5udW1MaXZlVHJpYW5nbGVzO1xuICAgICsrdHJpYW5nbGU7XG4gICAgY3VycmVudEluZGV4ICs9IDM7XG4gIH1cblxuICAvLyBTdGFydGluZyBpbmRleFxuICB2YXIgZiA9IDA7XG5cbiAgLy8gVGltZSBTdGFtcFxuICB2YXIgcyA9IGNhY2hlU2l6ZSArIDE7XG4gIGN1cnNvciA9IDE7XG5cbiAgLy8gUHJvY2Vzc1xuICB2YXIgb25lUmluZyA9IFtdO1xuICB2YXIgZGVhZEVuZCA9IFtdOyAvL1N0YWNrXG4gIHZhciB2ZXJ0ZXg7XG4gIHZhciBpbnRvVmVydGljZXM7XG4gIHZhciBjdXJyZW50T3V0cHV0SW5kZXggPSAwO1xuICB2YXIgb3V0cHV0SW5kaWNlcyA9IFtdO1xuICB2YXIgbnVtVHJpYW5nbGVzID0gbnVtSW5kaWNlcyAvIDM7XG4gIHZhciB0cmlhbmdsZUVtaXR0ZWQgPSBbXTtcbiAgZm9yIChpID0gMDsgaSA8IG51bVRyaWFuZ2xlczsgaSsrKSB7XG4gICAgdHJpYW5nbGVFbWl0dGVkW2ldID0gZmFsc2U7XG4gIH1cbiAgdmFyIGluZGV4O1xuICB2YXIgbGltaXQ7XG4gIHdoaWxlIChmICE9PSAtMSkge1xuICAgIG9uZVJpbmcgPSBbXTtcbiAgICBpbnRvVmVydGljZXMgPSB2ZXJ0aWNlc1tmXTtcbiAgICBsaW1pdCA9IGludG9WZXJ0aWNlcy52ZXJ0ZXhUcmlhbmdsZXMubGVuZ3RoO1xuICAgIGZvciAodmFyIGsgPSAwOyBrIDwgbGltaXQ7ICsraykge1xuICAgICAgdHJpYW5nbGUgPSBpbnRvVmVydGljZXMudmVydGV4VHJpYW5nbGVzW2tdO1xuICAgICAgaWYgKCF0cmlhbmdsZUVtaXR0ZWRbdHJpYW5nbGVdKSB7XG4gICAgICAgIHRyaWFuZ2xlRW1pdHRlZFt0cmlhbmdsZV0gPSB0cnVlO1xuICAgICAgICBjdXJyZW50SW5kZXggPSB0cmlhbmdsZSArIHRyaWFuZ2xlICsgdHJpYW5nbGU7XG4gICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgMzsgKytqKSB7XG4gICAgICAgICAgLy8gU2V0IHRoaXMgaW5kZXggYXMgYSBwb3NzaWJsZSBuZXh0IGluZGV4XG4gICAgICAgICAgaW5kZXggPSBpbmRpY2VzW2N1cnJlbnRJbmRleF07XG4gICAgICAgICAgb25lUmluZy5wdXNoKGluZGV4KTtcbiAgICAgICAgICBkZWFkRW5kLnB1c2goaW5kZXgpO1xuXG4gICAgICAgICAgLy8gT3V0cHV0IGluZGV4XG4gICAgICAgICAgb3V0cHV0SW5kaWNlc1tjdXJyZW50T3V0cHV0SW5kZXhdID0gaW5kZXg7XG4gICAgICAgICAgKytjdXJyZW50T3V0cHV0SW5kZXg7XG5cbiAgICAgICAgICAvLyBDYWNoZSBwcm9jZXNzaW5nXG4gICAgICAgICAgdmVydGV4ID0gdmVydGljZXNbaW5kZXhdO1xuICAgICAgICAgIC0tdmVydGV4Lm51bUxpdmVUcmlhbmdsZXM7XG4gICAgICAgICAgaWYgKHMgLSB2ZXJ0ZXgudGltZVN0YW1wID4gY2FjaGVTaXplKSB7XG4gICAgICAgICAgICB2ZXJ0ZXgudGltZVN0YW1wID0gcztcbiAgICAgICAgICAgICsrcztcbiAgICAgICAgICB9XG4gICAgICAgICAgKytjdXJyZW50SW5kZXg7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgZiA9IGdldE5leHRWZXJ0ZXgoXG4gICAgICBpbmRpY2VzLFxuICAgICAgY2FjaGVTaXplLFxuICAgICAgb25lUmluZyxcbiAgICAgIHZlcnRpY2VzLFxuICAgICAgcyxcbiAgICAgIGRlYWRFbmQsXG4gICAgICBtYXhpbXVtSW5kZXhQbHVzT25lXG4gICAgKTtcbiAgfVxuXG4gIHJldHVybiBvdXRwdXRJbmRpY2VzO1xufTtcbmV4cG9ydCBkZWZhdWx0IFRpcHNpZnk7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///66965\n')},95555:function(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__){eval('/* harmony import */ var _ThirdParty_when_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(13222);\n/* harmony import */ var _Cartesian2_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(60838);\n/* harmony import */ var _Cartesian3_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(60216);\n/* harmony import */ var _Cartesian4_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(63367);\n/* harmony import */ var _Cartographic_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(51688);\n/* harmony import */ var _Check_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(66553);\n/* harmony import */ var _defaultValue_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(62200);\n/* harmony import */ var _defined_js__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(82982);\n/* harmony import */ var _DeveloperError_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(12572);\n/* harmony import */ var _EarthOrientationParameters_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(13730);\n/* harmony import */ var _EarthOrientationParametersSample_js__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(22518);\n/* harmony import */ var _Ellipsoid_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(50491);\n/* harmony import */ var _HeadingPitchRoll_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(57674);\n/* harmony import */ var _Iau2006XysData_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(27846);\n/* harmony import */ var _Iau2006XysSample_js__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(50048);\n/* harmony import */ var _JulianDate_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(55293);\n/* harmony import */ var _Math_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(99417);\n/* harmony import */ var _Matrix3_js__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(68201);\n/* harmony import */ var _Matrix4_js__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(72248);\n/* harmony import */ var _Quaternion_js__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(87811);\n/* harmony import */ var _TimeConstants_js__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(4877);\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n/**\n * Contains functions for transforming positions to various reference frames.\n *\n * @namespace Transforms\n */\nvar Transforms = {};\n\nvar vectorProductLocalFrame = {\n  up: {\n    south: "east",\n    north: "west",\n    west: "south",\n    east: "north",\n  },\n  down: {\n    south: "west",\n    north: "east",\n    west: "north",\n    east: "south",\n  },\n  south: {\n    up: "west",\n    down: "east",\n    west: "down",\n    east: "up",\n  },\n  north: {\n    up: "east",\n    down: "west",\n    west: "up",\n    east: "down",\n  },\n  west: {\n    up: "north",\n    down: "south",\n    north: "down",\n    south: "up",\n  },\n  east: {\n    up: "south",\n    down: "north",\n    north: "up",\n    south: "down",\n  },\n};\n\nvar degeneratePositionLocalFrame = {\n  north: [-1, 0, 0],\n  east: [0, 1, 0],\n  up: [0, 0, 1],\n  south: [1, 0, 0],\n  west: [0, -1, 0],\n  down: [0, 0, -1],\n};\n\nvar localFrameToFixedFrameCache = {};\n\nvar scratchCalculateCartesian = {\n  east: new _Cartesian3_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"] */ .Z(),\n  north: new _Cartesian3_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"] */ .Z(),\n  up: new _Cartesian3_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"] */ .Z(),\n  west: new _Cartesian3_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"] */ .Z(),\n  south: new _Cartesian3_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"] */ .Z(),\n  down: new _Cartesian3_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"] */ .Z(),\n};\nvar scratchFirstCartesian = new _Cartesian3_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"] */ .Z();\nvar scratchSecondCartesian = new _Cartesian3_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"] */ .Z();\nvar scratchThirdCartesian = new _Cartesian3_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"] */ .Z();\n/**\n * Generates a function that computes a 4x4 transformation matrix from a reference frame\n * centered at the provided origin to the provided ellipsoid\'s fixed reference frame.\n * @param  {String} firstAxis  name of the first axis of the local reference frame. Must be\n *  \'east\', \'north\', \'up\', \'west\', \'south\' or \'down\'.\n * @param  {String} secondAxis  name of the second axis of the local reference frame. Must be\n *  \'east\', \'north\', \'up\', \'west\', \'south\' or \'down\'.\n * @return {Transforms.LocalFrameToFixedFrame} The function that will computes a\n * 4x4 transformation matrix from a reference frame, with first axis and second axis compliant with the parameters,\n */\nTransforms.localFrameToFixedFrameGenerator = function (firstAxis, secondAxis) {\n  if (\n    !vectorProductLocalFrame.hasOwnProperty(firstAxis) ||\n    !vectorProductLocalFrame[firstAxis].hasOwnProperty(secondAxis)\n  ) {\n    throw new _DeveloperError_js__WEBPACK_IMPORTED_MODULE_7__/* ["default"] */ .Z(\n      "firstAxis and secondAxis must be east, north, up, west, south or down."\n    );\n  }\n  var thirdAxis = vectorProductLocalFrame[firstAxis][secondAxis];\n\n  /**\n   * Computes a 4x4 transformation matrix from a reference frame\n   * centered at the provided origin to the provided ellipsoid\'s fixed reference frame.\n   * @callback Transforms.LocalFrameToFixedFrame\n   * @param {Cartesian3} origin The center point of the local reference frame.\n   * @param {Ellipsoid} [ellipsoid=Ellipsoid.WGS84] The ellipsoid whose fixed frame is used in the transformation.\n   * @param {Matrix4} [result] The object onto which to store the result.\n   * @returns {Matrix4} The modified result parameter or a new Matrix4 instance if none was provided.\n   */\n  var resultat;\n  var hashAxis = firstAxis + secondAxis;\n  if ((0,_defined_js__WEBPACK_IMPORTED_MODULE_18__/* ["default"] */ .Z)(localFrameToFixedFrameCache[hashAxis])) {\n    resultat = localFrameToFixedFrameCache[hashAxis];\n  } else {\n    resultat = function (origin, ellipsoid, result) {\n      //>>includeStart(\'debug\', pragmas.debug);\n      if (!(0,_defined_js__WEBPACK_IMPORTED_MODULE_18__/* ["default"] */ .Z)(origin)) {\n        throw new _DeveloperError_js__WEBPACK_IMPORTED_MODULE_7__/* ["default"] */ .Z("origin is required.");\n      }\n      //>>includeEnd(\'debug\');\n      if (!(0,_defined_js__WEBPACK_IMPORTED_MODULE_18__/* ["default"] */ .Z)(result)) {\n        result = new _Matrix4_js__WEBPACK_IMPORTED_MODULE_15__/* ["default"] */ .Z();\n      }\n      if (\n        _Cartesian3_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"].equalsEpsilon */ .Z.equalsEpsilon(origin, _Cartesian3_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"].ZERO */ .Z.ZERO, _Math_js__WEBPACK_IMPORTED_MODULE_13__/* ["default"].EPSILON14 */ .Z.EPSILON14)\n      ) {\n        // If x, y, and z are zero, use the degenerate local frame, which is a special case\n        _Cartesian3_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"].unpack */ .Z.unpack(\n          degeneratePositionLocalFrame[firstAxis],\n          0,\n          scratchFirstCartesian\n        );\n        _Cartesian3_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"].unpack */ .Z.unpack(\n          degeneratePositionLocalFrame[secondAxis],\n          0,\n          scratchSecondCartesian\n        );\n        _Cartesian3_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"].unpack */ .Z.unpack(\n          degeneratePositionLocalFrame[thirdAxis],\n          0,\n          scratchThirdCartesian\n        );\n      } else if (\n        _Math_js__WEBPACK_IMPORTED_MODULE_13__/* ["default"].equalsEpsilon */ .Z.equalsEpsilon(origin.x, 0.0, _Math_js__WEBPACK_IMPORTED_MODULE_13__/* ["default"].EPSILON14 */ .Z.EPSILON14) &&\n        _Math_js__WEBPACK_IMPORTED_MODULE_13__/* ["default"].equalsEpsilon */ .Z.equalsEpsilon(origin.y, 0.0, _Math_js__WEBPACK_IMPORTED_MODULE_13__/* ["default"].EPSILON14 */ .Z.EPSILON14)\n      ) {\n        // If x and y are zero, assume origin is at a pole, which is a special case.\n        var sign = _Math_js__WEBPACK_IMPORTED_MODULE_13__/* ["default"].sign */ .Z.sign(origin.z);\n\n        _Cartesian3_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"].unpack */ .Z.unpack(\n          degeneratePositionLocalFrame[firstAxis],\n          0,\n          scratchFirstCartesian\n        );\n        if (firstAxis !== "east" && firstAxis !== "west") {\n          _Cartesian3_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"].multiplyByScalar */ .Z.multiplyByScalar(\n            scratchFirstCartesian,\n            sign,\n            scratchFirstCartesian\n          );\n        }\n\n        _Cartesian3_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"].unpack */ .Z.unpack(\n          degeneratePositionLocalFrame[secondAxis],\n          0,\n          scratchSecondCartesian\n        );\n        if (secondAxis !== "east" && secondAxis !== "west") {\n          _Cartesian3_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"].multiplyByScalar */ .Z.multiplyByScalar(\n            scratchSecondCartesian,\n            sign,\n            scratchSecondCartesian\n          );\n        }\n\n        _Cartesian3_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"].unpack */ .Z.unpack(\n          degeneratePositionLocalFrame[thirdAxis],\n          0,\n          scratchThirdCartesian\n        );\n        if (thirdAxis !== "east" && thirdAxis !== "west") {\n          _Cartesian3_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"].multiplyByScalar */ .Z.multiplyByScalar(\n            scratchThirdCartesian,\n            sign,\n            scratchThirdCartesian\n          );\n        }\n      } else {\n        ellipsoid = (0,_defaultValue_js__WEBPACK_IMPORTED_MODULE_6__/* ["default"] */ .Z)(ellipsoid, _Ellipsoid_js__WEBPACK_IMPORTED_MODULE_9__/* ["default"].WGS84 */ .Z.WGS84);\n        ellipsoid.geodeticSurfaceNormal(origin, scratchCalculateCartesian.up);\n\n        var up = scratchCalculateCartesian.up;\n        var east = scratchCalculateCartesian.east;\n        east.x = -origin.y;\n        east.y = origin.x;\n        east.z = 0.0;\n        _Cartesian3_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"].normalize */ .Z.normalize(east, scratchCalculateCartesian.east);\n        _Cartesian3_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"].cross */ .Z.cross(up, east, scratchCalculateCartesian.north);\n\n        _Cartesian3_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"].multiplyByScalar */ .Z.multiplyByScalar(\n          scratchCalculateCartesian.up,\n          -1,\n          scratchCalculateCartesian.down\n        );\n        _Cartesian3_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"].multiplyByScalar */ .Z.multiplyByScalar(\n          scratchCalculateCartesian.east,\n          -1,\n          scratchCalculateCartesian.west\n        );\n        _Cartesian3_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"].multiplyByScalar */ .Z.multiplyByScalar(\n          scratchCalculateCartesian.north,\n          -1,\n          scratchCalculateCartesian.south\n        );\n\n        scratchFirstCartesian = scratchCalculateCartesian[firstAxis];\n        scratchSecondCartesian = scratchCalculateCartesian[secondAxis];\n        scratchThirdCartesian = scratchCalculateCartesian[thirdAxis];\n      }\n      result[0] = scratchFirstCartesian.x;\n      result[1] = scratchFirstCartesian.y;\n      result[2] = scratchFirstCartesian.z;\n      result[3] = 0.0;\n      result[4] = scratchSecondCartesian.x;\n      result[5] = scratchSecondCartesian.y;\n      result[6] = scratchSecondCartesian.z;\n      result[7] = 0.0;\n      result[8] = scratchThirdCartesian.x;\n      result[9] = scratchThirdCartesian.y;\n      result[10] = scratchThirdCartesian.z;\n      result[11] = 0.0;\n      result[12] = origin.x;\n      result[13] = origin.y;\n      result[14] = origin.z;\n      result[15] = 1.0;\n      return result;\n    };\n    localFrameToFixedFrameCache[hashAxis] = resultat;\n  }\n  return resultat;\n};\n\n/**\n * Computes a 4x4 transformation matrix from a reference frame with an east-north-up axes\n * centered at the provided origin to the provided ellipsoid\'s fixed reference frame.\n * The local axes are defined as:\n * <ul>\n * <li>The <code>x</code> axis points in the local east direction.</li>\n * <li>The <code>y</code> axis points in the local north direction.</li>\n * <li>The <code>z</code> axis points in the direction of the ellipsoid surface normal which passes through the position.</li>\n * </ul>\n *\n * @function\n * @param {Cartesian3} origin The center point of the local reference frame.\n * @param {Ellipsoid} [ellipsoid=Ellipsoid.WGS84] The ellipsoid whose fixed frame is used in the transformation.\n * @param {Matrix4} [result] The object onto which to store the result.\n * @returns {Matrix4} The modified result parameter or a new Matrix4 instance if none was provided.\n *\n * @example\n * // Get the transform from local east-north-up at cartographic (0.0, 0.0) to Earth\'s fixed frame.\n * var center = Cesium.Cartesian3.fromDegrees(0.0, 0.0);\n * var transform = Cesium.Transforms.eastNorthUpToFixedFrame(center);\n */\nTransforms.eastNorthUpToFixedFrame = Transforms.localFrameToFixedFrameGenerator(\n  "east",\n  "north"\n);\n\n/**\n * Computes a 4x4 transformation matrix from a reference frame with an north-east-down axes\n * centered at the provided origin to the provided ellipsoid\'s fixed reference frame.\n * The local axes are defined as:\n * <ul>\n * <li>The <code>x</code> axis points in the local north direction.</li>\n * <li>The <code>y</code> axis points in the local east direction.</li>\n * <li>The <code>z</code> axis points in the opposite direction of the ellipsoid surface normal which passes through the position.</li>\n * </ul>\n *\n * @function\n * @param {Cartesian3} origin The center point of the local reference frame.\n * @param {Ellipsoid} [ellipsoid=Ellipsoid.WGS84] The ellipsoid whose fixed frame is used in the transformation.\n * @param {Matrix4} [result] The object onto which to store the result.\n * @returns {Matrix4} The modified result parameter or a new Matrix4 instance if none was provided.\n *\n * @example\n * // Get the transform from local north-east-down at cartographic (0.0, 0.0) to Earth\'s fixed frame.\n * var center = Cesium.Cartesian3.fromDegrees(0.0, 0.0);\n * var transform = Cesium.Transforms.northEastDownToFixedFrame(center);\n */\nTransforms.northEastDownToFixedFrame = Transforms.localFrameToFixedFrameGenerator(\n  "north",\n  "east"\n);\n\n/**\n * Computes a 4x4 transformation matrix from a reference frame with an north-up-east axes\n * centered at the provided origin to the provided ellipsoid\'s fixed reference frame.\n * The local axes are defined as:\n * <ul>\n * <li>The <code>x</code> axis points in the local north direction.</li>\n * <li>The <code>y</code> axis points in the direction of the ellipsoid surface normal which passes through the position.</li>\n * <li>The <code>z</code> axis points in the local east direction.</li>\n * </ul>\n *\n * @function\n * @param {Cartesian3} origin The center point of the local reference frame.\n * @param {Ellipsoid} [ellipsoid=Ellipsoid.WGS84] The ellipsoid whose fixed frame is used in the transformation.\n * @param {Matrix4} [result] The object onto which to store the result.\n * @returns {Matrix4} The modified result parameter or a new Matrix4 instance if none was provided.\n *\n * @example\n * // Get the transform from local north-up-east at cartographic (0.0, 0.0) to Earth\'s fixed frame.\n * var center = Cesium.Cartesian3.fromDegrees(0.0, 0.0);\n * var transform = Cesium.Transforms.northUpEastToFixedFrame(center);\n */\nTransforms.northUpEastToFixedFrame = Transforms.localFrameToFixedFrameGenerator(\n  "north",\n  "up"\n);\n\n/**\n * Computes a 4x4 transformation matrix from a reference frame with an north-west-up axes\n * centered at the provided origin to the provided ellipsoid\'s fixed reference frame.\n * The local axes are defined as:\n * <ul>\n * <li>The <code>x</code> axis points in the local north direction.</li>\n * <li>The <code>y</code> axis points in the local west direction.</li>\n * <li>The <code>z</code> axis points in the direction of the ellipsoid surface normal which passes through the position.</li>\n * </ul>\n *\n * @function\n * @param {Cartesian3} origin The center point of the local reference frame.\n * @param {Ellipsoid} [ellipsoid=Ellipsoid.WGS84] The ellipsoid whose fixed frame is used in the transformation.\n * @param {Matrix4} [result] The object onto which to store the result.\n * @returns {Matrix4} The modified result parameter or a new Matrix4 instance if none was provided.\n *\n * @example\n * // Get the transform from local north-West-Up at cartographic (0.0, 0.0) to Earth\'s fixed frame.\n * var center = Cesium.Cartesian3.fromDegrees(0.0, 0.0);\n * var transform = Cesium.Transforms.northWestUpToFixedFrame(center);\n */\nTransforms.northWestUpToFixedFrame = Transforms.localFrameToFixedFrameGenerator(\n  "north",\n  "west"\n);\n\nvar scratchHPRQuaternion = new _Quaternion_js__WEBPACK_IMPORTED_MODULE_16__/* ["default"] */ .Z();\nvar scratchScale = new _Cartesian3_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"] */ .Z(1.0, 1.0, 1.0);\nvar scratchHPRMatrix4 = new _Matrix4_js__WEBPACK_IMPORTED_MODULE_15__/* ["default"] */ .Z();\n\n/**\n * Computes a 4x4 transformation matrix from a reference frame with axes computed from the heading-pitch-roll angles\n * centered at the provided origin to the provided ellipsoid\'s fixed reference frame. Heading is the rotation from the local north\n * direction where a positive angle is increasing eastward. Pitch is the rotation from the local east-north plane. Positive pitch angles\n * are above the plane. Negative pitch angles are below the plane. Roll is the first rotation applied about the local east axis.\n *\n * @param {Cartesian3} origin The center point of the local reference frame.\n * @param {HeadingPitchRoll} headingPitchRoll The heading, pitch, and roll.\n * @param {Ellipsoid} [ellipsoid=Ellipsoid.WGS84] The ellipsoid whose fixed frame is used in the transformation.\n * @param {Transforms.LocalFrameToFixedFrame} [fixedFrameTransform=Transforms.eastNorthUpToFixedFrame] A 4x4 transformation\n *  matrix from a reference frame to the provided ellipsoid\'s fixed reference frame\n * @param {Matrix4} [result] The object onto which to store the result.\n * @returns {Matrix4} The modified result parameter or a new Matrix4 instance if none was provided.\n *\n * @example\n * // Get the transform from local heading-pitch-roll at cartographic (0.0, 0.0) to Earth\'s fixed frame.\n * var center = Cesium.Cartesian3.fromDegrees(0.0, 0.0);\n * var heading = -Cesium.Math.PI_OVER_TWO;\n * var pitch = Cesium.Math.PI_OVER_FOUR;\n * var roll = 0.0;\n * var hpr = new Cesium.HeadingPitchRoll(heading, pitch, roll);\n * var transform = Cesium.Transforms.headingPitchRollToFixedFrame(center, hpr);\n */\nTransforms.headingPitchRollToFixedFrame = function (\n  origin,\n  headingPitchRoll,\n  ellipsoid,\n  fixedFrameTransform,\n  result\n) {\n  //>>includeStart(\'debug\', pragmas.debug);\n  _Check_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"].typeOf.object */ .Z.typeOf.object("HeadingPitchRoll", headingPitchRoll);\n  //>>includeEnd(\'debug\');\n\n  fixedFrameTransform = (0,_defaultValue_js__WEBPACK_IMPORTED_MODULE_6__/* ["default"] */ .Z)(\n    fixedFrameTransform,\n    Transforms.eastNorthUpToFixedFrame\n  );\n  var hprQuaternion = _Quaternion_js__WEBPACK_IMPORTED_MODULE_16__/* ["default"].fromHeadingPitchRoll */ .Z.fromHeadingPitchRoll(\n    headingPitchRoll,\n    scratchHPRQuaternion\n  );\n  var hprMatrix = _Matrix4_js__WEBPACK_IMPORTED_MODULE_15__/* ["default"].fromTranslationQuaternionRotationScale */ .Z.fromTranslationQuaternionRotationScale(\n    _Cartesian3_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"].ZERO */ .Z.ZERO,\n    hprQuaternion,\n    scratchScale,\n    scratchHPRMatrix4\n  );\n  result = fixedFrameTransform(origin, ellipsoid, result);\n  return _Matrix4_js__WEBPACK_IMPORTED_MODULE_15__/* ["default"].multiply */ .Z.multiply(result, hprMatrix, result);\n};\n\nvar scratchENUMatrix4 = new _Matrix4_js__WEBPACK_IMPORTED_MODULE_15__/* ["default"] */ .Z();\nvar scratchHPRMatrix3 = new _Matrix3_js__WEBPACK_IMPORTED_MODULE_14__/* ["default"] */ .Z();\n\n/**\n * Computes a quaternion from a reference frame with axes computed from the heading-pitch-roll angles\n * centered at the provided origin. Heading is the rotation from the local north\n * direction where a positive angle is increasing eastward. Pitch is the rotation from the local east-north plane. Positive pitch angles\n * are above the plane. Negative pitch angles are below the plane. Roll is the first rotation applied about the local east axis.\n *\n * @param {Cartesian3} origin The center point of the local reference frame.\n * @param {HeadingPitchRoll} headingPitchRoll The heading, pitch, and roll.\n * @param {Ellipsoid} [ellipsoid=Ellipsoid.WGS84] The ellipsoid whose fixed frame is used in the transformation.\n * @param {Transforms.LocalFrameToFixedFrame} [fixedFrameTransform=Transforms.eastNorthUpToFixedFrame] A 4x4 transformation\n *  matrix from a reference frame to the provided ellipsoid\'s fixed reference frame\n * @param {Quaternion} [result] The object onto which to store the result.\n * @returns {Quaternion} The modified result parameter or a new Quaternion instance if none was provided.\n *\n * @example\n * // Get the quaternion from local heading-pitch-roll at cartographic (0.0, 0.0) to Earth\'s fixed frame.\n * var center = Cesium.Cartesian3.fromDegrees(0.0, 0.0);\n * var heading = -Cesium.Math.PI_OVER_TWO;\n * var pitch = Cesium.Math.PI_OVER_FOUR;\n * var roll = 0.0;\n * var hpr = new HeadingPitchRoll(heading, pitch, roll);\n * var quaternion = Cesium.Transforms.headingPitchRollQuaternion(center, hpr);\n */\nTransforms.headingPitchRollQuaternion = function (\n  origin,\n  headingPitchRoll,\n  ellipsoid,\n  fixedFrameTransform,\n  result\n) {\n  //>>includeStart(\'debug\', pragmas.debug);\n  _Check_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"].typeOf.object */ .Z.typeOf.object("HeadingPitchRoll", headingPitchRoll);\n  //>>includeEnd(\'debug\');\n\n  var transform = Transforms.headingPitchRollToFixedFrame(\n    origin,\n    headingPitchRoll,\n    ellipsoid,\n    fixedFrameTransform,\n    scratchENUMatrix4\n  );\n  var rotation = _Matrix4_js__WEBPACK_IMPORTED_MODULE_15__/* ["default"].getMatrix3 */ .Z.getMatrix3(transform, scratchHPRMatrix3);\n  return _Quaternion_js__WEBPACK_IMPORTED_MODULE_16__/* ["default"].fromRotationMatrix */ .Z.fromRotationMatrix(rotation, result);\n};\n\nvar noScale = new _Cartesian3_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"] */ .Z(1.0, 1.0, 1.0);\nvar hprCenterScratch = new _Cartesian3_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"] */ .Z();\nvar ffScratch = new _Matrix4_js__WEBPACK_IMPORTED_MODULE_15__/* ["default"] */ .Z();\nvar hprTransformScratch = new _Matrix4_js__WEBPACK_IMPORTED_MODULE_15__/* ["default"] */ .Z();\nvar hprRotationScratch = new _Matrix3_js__WEBPACK_IMPORTED_MODULE_14__/* ["default"] */ .Z();\nvar hprQuaternionScratch = new _Quaternion_js__WEBPACK_IMPORTED_MODULE_16__/* ["default"] */ .Z();\n/**\n * Computes heading-pitch-roll angles from a transform in a particular reference frame. Heading is the rotation from the local north\n * direction where a positive angle is increasing eastward. Pitch is the rotation from the local east-north plane. Positive pitch angles\n * are above the plane. Negative pitch angles are below the plane. Roll is the first rotation applied about the local east axis.\n *\n * @param {Matrix4} transform The transform\n * @param {Ellipsoid} [ellipsoid=Ellipsoid.WGS84] The ellipsoid whose fixed frame is used in the transformation.\n * @param {Transforms.LocalFrameToFixedFrame} [fixedFrameTransform=Transforms.eastNorthUpToFixedFrame] A 4x4 transformation\n *  matrix from a reference frame to the provided ellipsoid\'s fixed reference frame\n * @param {HeadingPitchRoll} [result] The object onto which to store the result.\n * @returns {HeadingPitchRoll} The modified result parameter or a new HeadingPitchRoll instance if none was provided.\n */\nTransforms.fixedFrameToHeadingPitchRoll = function (\n  transform,\n  ellipsoid,\n  fixedFrameTransform,\n  result\n) {\n  //>>includeStart(\'debug\', pragmas.debug);\n  _Check_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"].defined */ .Z.defined("transform", transform);\n  //>>includeEnd(\'debug\');\n\n  ellipsoid = (0,_defaultValue_js__WEBPACK_IMPORTED_MODULE_6__/* ["default"] */ .Z)(ellipsoid, _Ellipsoid_js__WEBPACK_IMPORTED_MODULE_9__/* ["default"].WGS84 */ .Z.WGS84);\n  fixedFrameTransform = (0,_defaultValue_js__WEBPACK_IMPORTED_MODULE_6__/* ["default"] */ .Z)(\n    fixedFrameTransform,\n    Transforms.eastNorthUpToFixedFrame\n  );\n  if (!(0,_defined_js__WEBPACK_IMPORTED_MODULE_18__/* ["default"] */ .Z)(result)) {\n    result = new _HeadingPitchRoll_js__WEBPACK_IMPORTED_MODULE_10__/* ["default"] */ .Z();\n  }\n\n  var center = _Matrix4_js__WEBPACK_IMPORTED_MODULE_15__/* ["default"].getTranslation */ .Z.getTranslation(transform, hprCenterScratch);\n  if (_Cartesian3_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"].equals */ .Z.equals(center, _Cartesian3_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"].ZERO */ .Z.ZERO)) {\n    result.heading = 0;\n    result.pitch = 0;\n    result.roll = 0;\n    return result;\n  }\n  var toFixedFrame = _Matrix4_js__WEBPACK_IMPORTED_MODULE_15__/* ["default"].inverseTransformation */ .Z.inverseTransformation(\n    fixedFrameTransform(center, ellipsoid, ffScratch),\n    ffScratch\n  );\n  var transformCopy = _Matrix4_js__WEBPACK_IMPORTED_MODULE_15__/* ["default"].setScale */ .Z.setScale(transform, noScale, hprTransformScratch);\n  transformCopy = _Matrix4_js__WEBPACK_IMPORTED_MODULE_15__/* ["default"].setTranslation */ .Z.setTranslation(\n    transformCopy,\n    _Cartesian3_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"].ZERO */ .Z.ZERO,\n    transformCopy\n  );\n\n  toFixedFrame = _Matrix4_js__WEBPACK_IMPORTED_MODULE_15__/* ["default"].multiply */ .Z.multiply(toFixedFrame, transformCopy, toFixedFrame);\n  var quaternionRotation = _Quaternion_js__WEBPACK_IMPORTED_MODULE_16__/* ["default"].fromRotationMatrix */ .Z.fromRotationMatrix(\n    _Matrix4_js__WEBPACK_IMPORTED_MODULE_15__/* ["default"].getMatrix3 */ .Z.getMatrix3(toFixedFrame, hprRotationScratch),\n    hprQuaternionScratch\n  );\n  quaternionRotation = _Quaternion_js__WEBPACK_IMPORTED_MODULE_16__/* ["default"].normalize */ .Z.normalize(\n    quaternionRotation,\n    quaternionRotation\n  );\n\n  return _HeadingPitchRoll_js__WEBPACK_IMPORTED_MODULE_10__/* ["default"].fromQuaternion */ .Z.fromQuaternion(quaternionRotation, result);\n};\n\nvar gmstConstant0 = 6 * 3600 + 41 * 60 + 50.54841;\nvar gmstConstant1 = 8640184.812866;\nvar gmstConstant2 = 0.093104;\nvar gmstConstant3 = -6.2e-6;\nvar rateCoef = 1.1772758384668e-19;\nvar wgs84WRPrecessing = 7.2921158553e-5;\nvar twoPiOverSecondsInDay = _Math_js__WEBPACK_IMPORTED_MODULE_13__/* ["default"].TWO_PI */ .Z.TWO_PI / 86400.0;\nvar dateInUtc = new _JulianDate_js__WEBPACK_IMPORTED_MODULE_12__/* ["default"] */ .Z();\n\n/**\n * Computes a rotation matrix to transform a point or vector from True Equator Mean Equinox (TEME) axes to the\n * pseudo-fixed axes at a given time.  This method treats the UT1 time standard as equivalent to UTC.\n *\n * @param {JulianDate} date The time at which to compute the rotation matrix.\n * @param {Matrix3} [result] The object onto which to store the result.\n * @returns {Matrix3} The modified result parameter or a new Matrix3 instance if none was provided.\n *\n * @example\n * //Set the view to the inertial frame.\n * scene.postUpdate.addEventListener(function(scene, time) {\n *    var now = Cesium.JulianDate.now();\n *    var offset = Cesium.Matrix4.multiplyByPoint(camera.transform, camera.position, new Cesium.Cartesian3());\n *    var transform = Cesium.Matrix4.fromRotationTranslation(Cesium.Transforms.computeTemeToPseudoFixedMatrix(now));\n *    var inverseTransform = Cesium.Matrix4.inverseTransformation(transform, new Cesium.Matrix4());\n *    Cesium.Matrix4.multiplyByPoint(inverseTransform, offset, offset);\n *    camera.lookAtTransform(transform, offset);\n * });\n */\nTransforms.computeTemeToPseudoFixedMatrix = function (date, result) {\n  //>>includeStart(\'debug\', pragmas.debug);\n  if (!(0,_defined_js__WEBPACK_IMPORTED_MODULE_18__/* ["default"] */ .Z)(date)) {\n    throw new _DeveloperError_js__WEBPACK_IMPORTED_MODULE_7__/* ["default"] */ .Z("date is required.");\n  }\n  //>>includeEnd(\'debug\');\n\n  // GMST is actually computed using UT1.  We\'re using UTC as an approximation of UT1.\n  // We do not want to use the function like convertTaiToUtc in JulianDate because\n  // we explicitly do not want to fail when inside the leap second.\n\n  dateInUtc = _JulianDate_js__WEBPACK_IMPORTED_MODULE_12__/* ["default"].addSeconds */ .Z.addSeconds(\n    date,\n    -_JulianDate_js__WEBPACK_IMPORTED_MODULE_12__/* ["default"].computeTaiMinusUtc */ .Z.computeTaiMinusUtc(date),\n    dateInUtc\n  );\n  var utcDayNumber = dateInUtc.dayNumber;\n  var utcSecondsIntoDay = dateInUtc.secondsOfDay;\n\n  var t;\n  var diffDays = utcDayNumber - 2451545;\n  if (utcSecondsIntoDay >= 43200.0) {\n    t = (diffDays + 0.5) / _TimeConstants_js__WEBPACK_IMPORTED_MODULE_17__/* ["default"].DAYS_PER_JULIAN_CENTURY */ .Z.DAYS_PER_JULIAN_CENTURY;\n  } else {\n    t = (diffDays - 0.5) / _TimeConstants_js__WEBPACK_IMPORTED_MODULE_17__/* ["default"].DAYS_PER_JULIAN_CENTURY */ .Z.DAYS_PER_JULIAN_CENTURY;\n  }\n\n  var gmst0 =\n    gmstConstant0 +\n    t * (gmstConstant1 + t * (gmstConstant2 + t * gmstConstant3));\n  var angle = (gmst0 * twoPiOverSecondsInDay) % _Math_js__WEBPACK_IMPORTED_MODULE_13__/* ["default"].TWO_PI */ .Z.TWO_PI;\n  var ratio = wgs84WRPrecessing + rateCoef * (utcDayNumber - 2451545.5);\n  var secondsSinceMidnight =\n    (utcSecondsIntoDay + _TimeConstants_js__WEBPACK_IMPORTED_MODULE_17__/* ["default"].SECONDS_PER_DAY */ .Z.SECONDS_PER_DAY * 0.5) %\n    _TimeConstants_js__WEBPACK_IMPORTED_MODULE_17__/* ["default"].SECONDS_PER_DAY */ .Z.SECONDS_PER_DAY;\n  var gha = angle + ratio * secondsSinceMidnight;\n  var cosGha = Math.cos(gha);\n  var sinGha = Math.sin(gha);\n\n  if (!(0,_defined_js__WEBPACK_IMPORTED_MODULE_18__/* ["default"] */ .Z)(result)) {\n    return new _Matrix3_js__WEBPACK_IMPORTED_MODULE_14__/* ["default"] */ .Z(\n      cosGha,\n      sinGha,\n      0.0,\n      -sinGha,\n      cosGha,\n      0.0,\n      0.0,\n      0.0,\n      1.0\n    );\n  }\n  result[0] = cosGha;\n  result[1] = -sinGha;\n  result[2] = 0.0;\n  result[3] = sinGha;\n  result[4] = cosGha;\n  result[5] = 0.0;\n  result[6] = 0.0;\n  result[7] = 0.0;\n  result[8] = 1.0;\n  return result;\n};\n\n/**\n * The source of IAU 2006 XYS data, used for computing the transformation between the\n * Fixed and ICRF axes.\n * @type {Iau2006XysData}\n *\n * @see Transforms.computeIcrfToFixedMatrix\n * @see Transforms.computeFixedToIcrfMatrix\n *\n * @private\n */\nTransforms.iau2006XysData = new _Iau2006XysData_js__WEBPACK_IMPORTED_MODULE_11__/* ["default"] */ .Z();\n\n/**\n * The source of Earth Orientation Parameters (EOP) data, used for computing the transformation\n * between the Fixed and ICRF axes.  By default, zero values are used for all EOP values,\n * yielding a reasonable but not completely accurate representation of the ICRF axes.\n * @type {EarthOrientationParameters}\n *\n * @see Transforms.computeIcrfToFixedMatrix\n * @see Transforms.computeFixedToIcrfMatrix\n *\n * @private\n */\nTransforms.earthOrientationParameters = _EarthOrientationParameters_js__WEBPACK_IMPORTED_MODULE_8__/* ["default"].NONE */ .Z.NONE;\n\nvar ttMinusTai = 32.184;\nvar j2000ttDays = 2451545.0;\n\n/**\n * Preloads the data necessary to transform between the ICRF and Fixed axes, in either\n * direction, over a given interval.  This function returns a promise that, when resolved,\n * indicates that the preload has completed.\n *\n * @param {TimeInterval} timeInterval The interval to preload.\n * @returns {Promise<void>} A promise that, when resolved, indicates that the preload has completed\n *          and evaluation of the transformation between the fixed and ICRF axes will\n *          no longer return undefined for a time inside the interval.\n *\n *\n * @example\n * var interval = new Cesium.TimeInterval(...);\n * when(Cesium.Transforms.preloadIcrfFixed(interval), function() {\n *     // the data is now loaded\n * });\n *\n * @see Transforms.computeIcrfToFixedMatrix\n * @see Transforms.computeFixedToIcrfMatrix\n * @see when\n */\nTransforms.preloadIcrfFixed = function (timeInterval) {\n  var startDayTT = timeInterval.start.dayNumber;\n  var startSecondTT = timeInterval.start.secondsOfDay + ttMinusTai;\n  var stopDayTT = timeInterval.stop.dayNumber;\n  var stopSecondTT = timeInterval.stop.secondsOfDay + ttMinusTai;\n\n  var xysPromise = Transforms.iau2006XysData.preload(\n    startDayTT,\n    startSecondTT,\n    stopDayTT,\n    stopSecondTT\n  );\n  var eopPromise = Transforms.earthOrientationParameters.getPromiseToLoad();\n\n  return _ThirdParty_when_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].all */ .Z.all([xysPromise, eopPromise]);\n};\n\n/**\n * Computes a rotation matrix to transform a point or vector from the International Celestial\n * Reference Frame (GCRF/ICRF) inertial frame axes to the Earth-Fixed frame axes (ITRF)\n * at a given time.  This function may return undefined if the data necessary to\n * do the transformation is not yet loaded.\n *\n * @param {JulianDate} date The time at which to compute the rotation matrix.\n * @param {Matrix3} [result] The object onto which to store the result.  If this parameter is\n *                  not specified, a new instance is created and returned.\n * @returns {Matrix3} The rotation matrix, or undefined if the data necessary to do the\n *                   transformation is not yet loaded.\n *\n *\n * @example\n * scene.postUpdate.addEventListener(function(scene, time) {\n *   // View in ICRF.\n *   var icrfToFixed = Cesium.Transforms.computeIcrfToFixedMatrix(time);\n *   if (Cesium.defined(icrfToFixed)) {\n *     var offset = Cesium.Cartesian3.clone(camera.position);\n *     var transform = Cesium.Matrix4.fromRotationTranslation(icrfToFixed);\n *     camera.lookAtTransform(transform, offset);\n *   }\n * });\n *\n * @see Transforms.preloadIcrfFixed\n */\nTransforms.computeIcrfToFixedMatrix = function (date, result) {\n  //>>includeStart(\'debug\', pragmas.debug);\n  if (!(0,_defined_js__WEBPACK_IMPORTED_MODULE_18__/* ["default"] */ .Z)(date)) {\n    throw new _DeveloperError_js__WEBPACK_IMPORTED_MODULE_7__/* ["default"] */ .Z("date is required.");\n  }\n  //>>includeEnd(\'debug\');\n  if (!(0,_defined_js__WEBPACK_IMPORTED_MODULE_18__/* ["default"] */ .Z)(result)) {\n    result = new _Matrix3_js__WEBPACK_IMPORTED_MODULE_14__/* ["default"] */ .Z();\n  }\n\n  var fixedToIcrfMtx = Transforms.computeFixedToIcrfMatrix(date, result);\n  if (!(0,_defined_js__WEBPACK_IMPORTED_MODULE_18__/* ["default"] */ .Z)(fixedToIcrfMtx)) {\n    return undefined;\n  }\n\n  return _Matrix3_js__WEBPACK_IMPORTED_MODULE_14__/* ["default"].transpose */ .Z.transpose(fixedToIcrfMtx, result);\n};\n\nvar xysScratch = new _Iau2006XysSample_js__WEBPACK_IMPORTED_MODULE_19__/* ["default"] */ .Z(0.0, 0.0, 0.0);\nvar eopScratch = new _EarthOrientationParametersSample_js__WEBPACK_IMPORTED_MODULE_20__/* ["default"] */ .Z(\n  0.0,\n  0.0,\n  0.0,\n  0.0,\n  0.0,\n  0.0\n);\nvar rotation1Scratch = new _Matrix3_js__WEBPACK_IMPORTED_MODULE_14__/* ["default"] */ .Z();\nvar rotation2Scratch = new _Matrix3_js__WEBPACK_IMPORTED_MODULE_14__/* ["default"] */ .Z();\n\n/**\n * Computes a rotation matrix to transform a point or vector from the Earth-Fixed frame axes (ITRF)\n * to the International Celestial Reference Frame (GCRF/ICRF) inertial frame axes\n * at a given time.  This function may return undefined if the data necessary to\n * do the transformation is not yet loaded.\n *\n * @param {JulianDate} date The time at which to compute the rotation matrix.\n * @param {Matrix3} [result] The object onto which to store the result.  If this parameter is\n *                  not specified, a new instance is created and returned.\n * @returns {Matrix3} The rotation matrix, or undefined if the data necessary to do the\n *                   transformation is not yet loaded.\n *\n *\n * @example\n * // Transform a point from the ICRF axes to the Fixed axes.\n * var now = Cesium.JulianDate.now();\n * var pointInFixed = Cesium.Cartesian3.fromDegrees(0.0, 0.0);\n * var fixedToIcrf = Cesium.Transforms.computeIcrfToFixedMatrix(now);\n * var pointInInertial = new Cesium.Cartesian3();\n * if (Cesium.defined(fixedToIcrf)) {\n *     pointInInertial = Cesium.Matrix3.multiplyByVector(fixedToIcrf, pointInFixed, pointInInertial);\n * }\n *\n * @see Transforms.preloadIcrfFixed\n */\nTransforms.computeFixedToIcrfMatrix = function (date, result) {\n  //>>includeStart(\'debug\', pragmas.debug);\n  if (!(0,_defined_js__WEBPACK_IMPORTED_MODULE_18__/* ["default"] */ .Z)(date)) {\n    throw new _DeveloperError_js__WEBPACK_IMPORTED_MODULE_7__/* ["default"] */ .Z("date is required.");\n  }\n  //>>includeEnd(\'debug\');\n\n  if (!(0,_defined_js__WEBPACK_IMPORTED_MODULE_18__/* ["default"] */ .Z)(result)) {\n    result = new _Matrix3_js__WEBPACK_IMPORTED_MODULE_14__/* ["default"] */ .Z();\n  }\n\n  // Compute pole wander\n  var eop = Transforms.earthOrientationParameters.compute(date, eopScratch);\n  if (!(0,_defined_js__WEBPACK_IMPORTED_MODULE_18__/* ["default"] */ .Z)(eop)) {\n    return undefined;\n  }\n\n  // There is no external conversion to Terrestrial Time (TT).\n  // So use International Atomic Time (TAI) and convert using offsets.\n  // Here we are assuming that dayTT and secondTT are positive\n  var dayTT = date.dayNumber;\n  // It\'s possible here that secondTT could roll over 86400\n  // This does not seem to affect the precision (unit tests check for this)\n  var secondTT = date.secondsOfDay + ttMinusTai;\n\n  var xys = Transforms.iau2006XysData.computeXysRadians(\n    dayTT,\n    secondTT,\n    xysScratch\n  );\n  if (!(0,_defined_js__WEBPACK_IMPORTED_MODULE_18__/* ["default"] */ .Z)(xys)) {\n    return undefined;\n  }\n\n  var x = xys.x + eop.xPoleOffset;\n  var y = xys.y + eop.yPoleOffset;\n\n  // Compute XYS rotation\n  var a = 1.0 / (1.0 + Math.sqrt(1.0 - x * x - y * y));\n\n  var rotation1 = rotation1Scratch;\n  rotation1[0] = 1.0 - a * x * x;\n  rotation1[3] = -a * x * y;\n  rotation1[6] = x;\n  rotation1[1] = -a * x * y;\n  rotation1[4] = 1 - a * y * y;\n  rotation1[7] = y;\n  rotation1[2] = -x;\n  rotation1[5] = -y;\n  rotation1[8] = 1 - a * (x * x + y * y);\n\n  var rotation2 = _Matrix3_js__WEBPACK_IMPORTED_MODULE_14__/* ["default"].fromRotationZ */ .Z.fromRotationZ(-xys.s, rotation2Scratch);\n  var matrixQ = _Matrix3_js__WEBPACK_IMPORTED_MODULE_14__/* ["default"].multiply */ .Z.multiply(rotation1, rotation2, rotation1Scratch);\n\n  // Similar to TT conversions above\n  // It\'s possible here that secondTT could roll over 86400\n  // This does not seem to affect the precision (unit tests check for this)\n  var dateUt1day = date.dayNumber;\n  var dateUt1sec =\n    date.secondsOfDay - _JulianDate_js__WEBPACK_IMPORTED_MODULE_12__/* ["default"].computeTaiMinusUtc */ .Z.computeTaiMinusUtc(date) + eop.ut1MinusUtc;\n\n  // Compute Earth rotation angle\n  // The IERS standard for era is\n  //    era = 0.7790572732640 + 1.00273781191135448 * Tu\n  // where\n  //    Tu = JulianDateInUt1 - 2451545.0\n  // However, you get much more precision if you make the following simplification\n  //    era = a + (1 + b) * (JulianDayNumber + FractionOfDay - 2451545)\n  //    era = a + (JulianDayNumber - 2451545) + FractionOfDay + b (JulianDayNumber - 2451545 + FractionOfDay)\n  //    era = a + FractionOfDay + b (JulianDayNumber - 2451545 + FractionOfDay)\n  // since (JulianDayNumber - 2451545) represents an integer number of revolutions which will be discarded anyway.\n  var daysSinceJ2000 = dateUt1day - 2451545;\n  var fractionOfDay = dateUt1sec / _TimeConstants_js__WEBPACK_IMPORTED_MODULE_17__/* ["default"].SECONDS_PER_DAY */ .Z.SECONDS_PER_DAY;\n  var era =\n    0.779057273264 +\n    fractionOfDay +\n    0.00273781191135448 * (daysSinceJ2000 + fractionOfDay);\n  era = (era % 1.0) * _Math_js__WEBPACK_IMPORTED_MODULE_13__/* ["default"].TWO_PI */ .Z.TWO_PI;\n\n  var earthRotation = _Matrix3_js__WEBPACK_IMPORTED_MODULE_14__/* ["default"].fromRotationZ */ .Z.fromRotationZ(era, rotation2Scratch);\n\n  // pseudoFixed to ICRF\n  var pfToIcrf = _Matrix3_js__WEBPACK_IMPORTED_MODULE_14__/* ["default"].multiply */ .Z.multiply(matrixQ, earthRotation, rotation1Scratch);\n\n  // Compute pole wander matrix\n  var cosxp = Math.cos(eop.xPoleWander);\n  var cosyp = Math.cos(eop.yPoleWander);\n  var sinxp = Math.sin(eop.xPoleWander);\n  var sinyp = Math.sin(eop.yPoleWander);\n\n  var ttt = dayTT - j2000ttDays + secondTT / _TimeConstants_js__WEBPACK_IMPORTED_MODULE_17__/* ["default"].SECONDS_PER_DAY */ .Z.SECONDS_PER_DAY;\n  ttt /= 36525.0;\n\n  // approximate sp value in rad\n  var sp = (-47.0e-6 * ttt * _Math_js__WEBPACK_IMPORTED_MODULE_13__/* ["default"].RADIANS_PER_DEGREE */ .Z.RADIANS_PER_DEGREE) / 3600.0;\n  var cossp = Math.cos(sp);\n  var sinsp = Math.sin(sp);\n\n  var fToPfMtx = rotation2Scratch;\n  fToPfMtx[0] = cosxp * cossp;\n  fToPfMtx[1] = cosxp * sinsp;\n  fToPfMtx[2] = sinxp;\n  fToPfMtx[3] = -cosyp * sinsp + sinyp * sinxp * cossp;\n  fToPfMtx[4] = cosyp * cossp + sinyp * sinxp * sinsp;\n  fToPfMtx[5] = -sinyp * cosxp;\n  fToPfMtx[6] = -sinyp * sinsp - cosyp * sinxp * cossp;\n  fToPfMtx[7] = sinyp * cossp - cosyp * sinxp * sinsp;\n  fToPfMtx[8] = cosyp * cosxp;\n\n  return _Matrix3_js__WEBPACK_IMPORTED_MODULE_14__/* ["default"].multiply */ .Z.multiply(pfToIcrf, fToPfMtx, result);\n};\n\nvar pointToWindowCoordinatesTemp = new _Cartesian4_js__WEBPACK_IMPORTED_MODULE_3__/* ["default"] */ .Z();\n\n/**\n * Transform a point from model coordinates to window coordinates.\n *\n * @param {Matrix4} modelViewProjectionMatrix The 4x4 model-view-projection matrix.\n * @param {Matrix4} viewportTransformation The 4x4 viewport transformation.\n * @param {Cartesian3} point The point to transform.\n * @param {Cartesian2} [result] The object onto which to store the result.\n * @returns {Cartesian2} The modified result parameter or a new Cartesian2 instance if none was provided.\n */\nTransforms.pointToWindowCoordinates = function (\n  modelViewProjectionMatrix,\n  viewportTransformation,\n  point,\n  result\n) {\n  result = Transforms.pointToGLWindowCoordinates(\n    modelViewProjectionMatrix,\n    viewportTransformation,\n    point,\n    result\n  );\n  result.y = 2.0 * viewportTransformation[5] - result.y;\n  return result;\n};\n\n/**\n * @private\n */\nTransforms.pointToGLWindowCoordinates = function (\n  modelViewProjectionMatrix,\n  viewportTransformation,\n  point,\n  result\n) {\n  //>>includeStart(\'debug\', pragmas.debug);\n  if (!(0,_defined_js__WEBPACK_IMPORTED_MODULE_18__/* ["default"] */ .Z)(modelViewProjectionMatrix)) {\n    throw new _DeveloperError_js__WEBPACK_IMPORTED_MODULE_7__/* ["default"] */ .Z("modelViewProjectionMatrix is required.");\n  }\n\n  if (!(0,_defined_js__WEBPACK_IMPORTED_MODULE_18__/* ["default"] */ .Z)(viewportTransformation)) {\n    throw new _DeveloperError_js__WEBPACK_IMPORTED_MODULE_7__/* ["default"] */ .Z("viewportTransformation is required.");\n  }\n\n  if (!(0,_defined_js__WEBPACK_IMPORTED_MODULE_18__/* ["default"] */ .Z)(point)) {\n    throw new _DeveloperError_js__WEBPACK_IMPORTED_MODULE_7__/* ["default"] */ .Z("point is required.");\n  }\n  //>>includeEnd(\'debug\');\n\n  if (!(0,_defined_js__WEBPACK_IMPORTED_MODULE_18__/* ["default"] */ .Z)(result)) {\n    result = new _Cartesian2_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .Z();\n  }\n\n  var tmp = pointToWindowCoordinatesTemp;\n\n  _Matrix4_js__WEBPACK_IMPORTED_MODULE_15__/* ["default"].multiplyByVector */ .Z.multiplyByVector(\n    modelViewProjectionMatrix,\n    _Cartesian4_js__WEBPACK_IMPORTED_MODULE_3__/* ["default"].fromElements */ .Z.fromElements(point.x, point.y, point.z, 1, tmp),\n    tmp\n  );\n  _Cartesian4_js__WEBPACK_IMPORTED_MODULE_3__/* ["default"].multiplyByScalar */ .Z.multiplyByScalar(tmp, 1.0 / tmp.w, tmp);\n  _Matrix4_js__WEBPACK_IMPORTED_MODULE_15__/* ["default"].multiplyByVector */ .Z.multiplyByVector(viewportTransformation, tmp, tmp);\n  return _Cartesian2_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"].fromCartesian4 */ .Z.fromCartesian4(tmp, result);\n};\n\nvar normalScratch = new _Cartesian3_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"] */ .Z();\nvar rightScratch = new _Cartesian3_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"] */ .Z();\nvar upScratch = new _Cartesian3_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"] */ .Z();\n\n/**\n * Transform a position and velocity to a rotation matrix.\n *\n * @param {Cartesian3} position The position to transform.\n * @param {Cartesian3} velocity The velocity vector to transform.\n * @param {Ellipsoid} [ellipsoid=Ellipsoid.WGS84] The ellipsoid whose fixed frame is used in the transformation.\n * @param {Matrix3} [result] The object onto which to store the result.\n * @returns {Matrix3} The modified result parameter or a new Matrix3 instance if none was provided.\n */\nTransforms.rotationMatrixFromPositionVelocity = function (\n  position,\n  velocity,\n  ellipsoid,\n  result\n) {\n  //>>includeStart(\'debug\', pragmas.debug);\n  if (!(0,_defined_js__WEBPACK_IMPORTED_MODULE_18__/* ["default"] */ .Z)(position)) {\n    throw new _DeveloperError_js__WEBPACK_IMPORTED_MODULE_7__/* ["default"] */ .Z("position is required.");\n  }\n\n  if (!(0,_defined_js__WEBPACK_IMPORTED_MODULE_18__/* ["default"] */ .Z)(velocity)) {\n    throw new _DeveloperError_js__WEBPACK_IMPORTED_MODULE_7__/* ["default"] */ .Z("velocity is required.");\n  }\n  //>>includeEnd(\'debug\');\n\n  var normal = (0,_defaultValue_js__WEBPACK_IMPORTED_MODULE_6__/* ["default"] */ .Z)(ellipsoid, _Ellipsoid_js__WEBPACK_IMPORTED_MODULE_9__/* ["default"].WGS84 */ .Z.WGS84).geodeticSurfaceNormal(\n    position,\n    normalScratch\n  );\n  var right = _Cartesian3_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"].cross */ .Z.cross(velocity, normal, rightScratch);\n\n  if (_Cartesian3_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"].equalsEpsilon */ .Z.equalsEpsilon(right, _Cartesian3_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"].ZERO */ .Z.ZERO, _Math_js__WEBPACK_IMPORTED_MODULE_13__/* ["default"].EPSILON6 */ .Z.EPSILON6)) {\n    right = _Cartesian3_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"].clone */ .Z.clone(_Cartesian3_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"].UNIT_X */ .Z.UNIT_X, right);\n  }\n\n  var up = _Cartesian3_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"].cross */ .Z.cross(right, velocity, upScratch);\n  _Cartesian3_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"].normalize */ .Z.normalize(up, up);\n  _Cartesian3_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"].cross */ .Z.cross(velocity, up, right);\n  _Cartesian3_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"].negate */ .Z.negate(right, right);\n  _Cartesian3_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"].normalize */ .Z.normalize(right, right);\n\n  if (!(0,_defined_js__WEBPACK_IMPORTED_MODULE_18__/* ["default"] */ .Z)(result)) {\n    result = new _Matrix3_js__WEBPACK_IMPORTED_MODULE_14__/* ["default"] */ .Z();\n  }\n\n  result[0] = velocity.x;\n  result[1] = velocity.y;\n  result[2] = velocity.z;\n  result[3] = right.x;\n  result[4] = right.y;\n  result[5] = right.z;\n  result[6] = up.x;\n  result[7] = up.y;\n  result[8] = up.z;\n\n  return result;\n};\n\nvar swizzleMatrix = new _Matrix4_js__WEBPACK_IMPORTED_MODULE_15__/* ["default"] */ .Z(\n  0.0,\n  0.0,\n  1.0,\n  0.0,\n  1.0,\n  0.0,\n  0.0,\n  0.0,\n  0.0,\n  1.0,\n  0.0,\n  0.0,\n  0.0,\n  0.0,\n  0.0,\n  1.0\n);\n\nvar scratchCartographic = new _Cartographic_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .Z();\nvar scratchCartesian3Projection = new _Cartesian3_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"] */ .Z();\nvar scratchCenter = new _Cartesian3_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"] */ .Z();\nvar scratchRotation = new _Matrix3_js__WEBPACK_IMPORTED_MODULE_14__/* ["default"] */ .Z();\nvar scratchFromENU = new _Matrix4_js__WEBPACK_IMPORTED_MODULE_15__/* ["default"] */ .Z();\nvar scratchToENU = new _Matrix4_js__WEBPACK_IMPORTED_MODULE_15__/* ["default"] */ .Z();\n\n/**\n * @private\n */\nTransforms.basisTo2D = function (projection, matrix, result) {\n  //>>includeStart(\'debug\', pragmas.debug);\n  if (!(0,_defined_js__WEBPACK_IMPORTED_MODULE_18__/* ["default"] */ .Z)(projection)) {\n    throw new _DeveloperError_js__WEBPACK_IMPORTED_MODULE_7__/* ["default"] */ .Z("projection is required.");\n  }\n  if (!(0,_defined_js__WEBPACK_IMPORTED_MODULE_18__/* ["default"] */ .Z)(matrix)) {\n    throw new _DeveloperError_js__WEBPACK_IMPORTED_MODULE_7__/* ["default"] */ .Z("matrix is required.");\n  }\n  if (!(0,_defined_js__WEBPACK_IMPORTED_MODULE_18__/* ["default"] */ .Z)(result)) {\n    throw new _DeveloperError_js__WEBPACK_IMPORTED_MODULE_7__/* ["default"] */ .Z("result is required.");\n  }\n  //>>includeEnd(\'debug\');\n\n  var rtcCenter = _Matrix4_js__WEBPACK_IMPORTED_MODULE_15__/* ["default"].getTranslation */ .Z.getTranslation(matrix, scratchCenter);\n  var ellipsoid = projection.ellipsoid;\n\n  // Get the 2D Center\n  var cartographic = ellipsoid.cartesianToCartographic(\n    rtcCenter,\n    scratchCartographic\n  );\n  var projectedPosition = projection.project(\n    cartographic,\n    scratchCartesian3Projection\n  );\n  _Cartesian3_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"].fromElements */ .Z.fromElements(\n    projectedPosition.z,\n    projectedPosition.x,\n    projectedPosition.y,\n    projectedPosition\n  );\n\n  // Assuming the instance are positioned in WGS84, invert the WGS84 transform to get the local transform and then convert to 2D\n  var fromENU = Transforms.eastNorthUpToFixedFrame(\n    rtcCenter,\n    ellipsoid,\n    scratchFromENU\n  );\n  var toENU = _Matrix4_js__WEBPACK_IMPORTED_MODULE_15__/* ["default"].inverseTransformation */ .Z.inverseTransformation(fromENU, scratchToENU);\n  var rotation = _Matrix4_js__WEBPACK_IMPORTED_MODULE_15__/* ["default"].getMatrix3 */ .Z.getMatrix3(matrix, scratchRotation);\n  var local = _Matrix4_js__WEBPACK_IMPORTED_MODULE_15__/* ["default"].multiplyByMatrix3 */ .Z.multiplyByMatrix3(toENU, rotation, result);\n  _Matrix4_js__WEBPACK_IMPORTED_MODULE_15__/* ["default"].multiply */ .Z.multiply(swizzleMatrix, local, result); // Swap x, y, z for 2D\n  _Matrix4_js__WEBPACK_IMPORTED_MODULE_15__/* ["default"].setTranslation */ .Z.setTranslation(result, projectedPosition, result); // Use the projected center\n\n  return result;\n};\n\n/**\n * @private\n */\nTransforms.wgs84To2DModelMatrix = function (projection, center, result) {\n  //>>includeStart(\'debug\', pragmas.debug);\n  if (!(0,_defined_js__WEBPACK_IMPORTED_MODULE_18__/* ["default"] */ .Z)(projection)) {\n    throw new _DeveloperError_js__WEBPACK_IMPORTED_MODULE_7__/* ["default"] */ .Z("projection is required.");\n  }\n  if (!(0,_defined_js__WEBPACK_IMPORTED_MODULE_18__/* ["default"] */ .Z)(center)) {\n    throw new _DeveloperError_js__WEBPACK_IMPORTED_MODULE_7__/* ["default"] */ .Z("center is required.");\n  }\n  if (!(0,_defined_js__WEBPACK_IMPORTED_MODULE_18__/* ["default"] */ .Z)(result)) {\n    throw new _DeveloperError_js__WEBPACK_IMPORTED_MODULE_7__/* ["default"] */ .Z("result is required.");\n  }\n  //>>includeEnd(\'debug\');\n\n  var ellipsoid = projection.ellipsoid;\n\n  var fromENU = Transforms.eastNorthUpToFixedFrame(\n    center,\n    ellipsoid,\n    scratchFromENU\n  );\n  var toENU = _Matrix4_js__WEBPACK_IMPORTED_MODULE_15__/* ["default"].inverseTransformation */ .Z.inverseTransformation(fromENU, scratchToENU);\n\n  var cartographic = ellipsoid.cartesianToCartographic(\n    center,\n    scratchCartographic\n  );\n  var projectedPosition = projection.project(\n    cartographic,\n    scratchCartesian3Projection\n  );\n  _Cartesian3_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"].fromElements */ .Z.fromElements(\n    projectedPosition.z,\n    projectedPosition.x,\n    projectedPosition.y,\n    projectedPosition\n  );\n\n  var translation = _Matrix4_js__WEBPACK_IMPORTED_MODULE_15__/* ["default"].fromTranslation */ .Z.fromTranslation(projectedPosition, scratchFromENU);\n  _Matrix4_js__WEBPACK_IMPORTED_MODULE_15__/* ["default"].multiply */ .Z.multiply(swizzleMatrix, toENU, result);\n  _Matrix4_js__WEBPACK_IMPORTED_MODULE_15__/* ["default"].multiply */ .Z.multiply(translation, result, result);\n\n  return result;\n};\n/* harmony default export */ __webpack_exports__["Z"] = (Transforms);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QTZCO0FBQzNDLGlCQUFpQixtRkFBa0I7QUFDbkMsY0FBYyxpR0FBeUI7QUFDdkMsRUFBRSwrRUFBZ0IsZ0NBQWdDO0FBQ2xELEVBQUUsMkZBQXNCLHFDQUFxQzs7QUFFN0Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTyxpRUFBTztBQUNkLGNBQWMsbUVBQWM7QUFDNUI7QUFDQSxPQUFPLGlFQUFPO0FBQ2QsY0FBYyxtRUFBYztBQUM1QjtBQUNBLE9BQU8saUVBQU87QUFDZCxjQUFjLG1FQUFjO0FBQzVCO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMseUdBQTZCOztBQUUzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRSx5RkFBdUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxvQkFBb0IsNkZBQXVCO0FBQzNDLEVBQUUsK0VBQWdCO0FBQ2xCLEVBQUUsK0VBQWdCOztBQUVsQjtBQUNBO0FBQ0EseURBQWUsVUFBVSxFQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdnVlMy13ZWJwYWNrNS8uL25vZGVfbW9kdWxlcy9jZXNpdW0vU291cmNlL0NvcmUvVHJhbnNmb3Jtcy5qcz9iZWJjIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB3aGVuIGZyb20gXCIuLi9UaGlyZFBhcnR5L3doZW4uanNcIjtcbmltcG9ydCBDYXJ0ZXNpYW4yIGZyb20gXCIuL0NhcnRlc2lhbjIuanNcIjtcbmltcG9ydCBDYXJ0ZXNpYW4zIGZyb20gXCIuL0NhcnRlc2lhbjMuanNcIjtcbmltcG9ydCBDYXJ0ZXNpYW40IGZyb20gXCIuL0NhcnRlc2lhbjQuanNcIjtcbmltcG9ydCBDYXJ0b2dyYXBoaWMgZnJvbSBcIi4vQ2FydG9ncmFwaGljLmpzXCI7XG5pbXBvcnQgQ2hlY2sgZnJvbSBcIi4vQ2hlY2suanNcIjtcbmltcG9ydCBkZWZhdWx0VmFsdWUgZnJvbSBcIi4vZGVmYXVsdFZhbHVlLmpzXCI7XG5pbXBvcnQgZGVmaW5lZCBmcm9tIFwiLi9kZWZpbmVkLmpzXCI7XG5pbXBvcnQgRGV2ZWxvcGVyRXJyb3IgZnJvbSBcIi4vRGV2ZWxvcGVyRXJyb3IuanNcIjtcbmltcG9ydCBFYXJ0aE9yaWVudGF0aW9uUGFyYW1ldGVycyBmcm9tIFwiLi9FYXJ0aE9yaWVudGF0aW9uUGFyYW1ldGVycy5qc1wiO1xuaW1wb3J0IEVhcnRoT3JpZW50YXRpb25QYXJhbWV0ZXJzU2FtcGxlIGZyb20gXCIuL0VhcnRoT3JpZW50YXRpb25QYXJhbWV0ZXJzU2FtcGxlLmpzXCI7XG5pbXBvcnQgRWxsaXBzb2lkIGZyb20gXCIuL0VsbGlwc29pZC5qc1wiO1xuaW1wb3J0IEhlYWRpbmdQaXRjaFJvbGwgZnJvbSBcIi4vSGVhZGluZ1BpdGNoUm9sbC5qc1wiO1xuaW1wb3J0IElhdTIwMDZYeXNEYXRhIGZyb20gXCIuL0lhdTIwMDZYeXNEYXRhLmpzXCI7XG5pbXBvcnQgSWF1MjAwNlh5c1NhbXBsZSBmcm9tIFwiLi9JYXUyMDA2WHlzU2FtcGxlLmpzXCI7XG5pbXBvcnQgSnVsaWFuRGF0ZSBmcm9tIFwiLi9KdWxpYW5EYXRlLmpzXCI7XG5pbXBvcnQgQ2VzaXVtTWF0aCBmcm9tIFwiLi9NYXRoLmpzXCI7XG5pbXBvcnQgTWF0cml4MyBmcm9tIFwiLi9NYXRyaXgzLmpzXCI7XG5pbXBvcnQgTWF0cml4NCBmcm9tIFwiLi9NYXRyaXg0LmpzXCI7XG5pbXBvcnQgUXVhdGVybmlvbiBmcm9tIFwiLi9RdWF0ZXJuaW9uLmpzXCI7XG5pbXBvcnQgVGltZUNvbnN0YW50cyBmcm9tIFwiLi9UaW1lQ29uc3RhbnRzLmpzXCI7XG5cbi8qKlxuICogQ29udGFpbnMgZnVuY3Rpb25zIGZvciB0cmFuc2Zvcm1pbmcgcG9zaXRpb25zIHRvIHZhcmlvdXMgcmVmZXJlbmNlIGZyYW1lcy5cbiAqXG4gKiBAbmFtZXNwYWNlIFRyYW5zZm9ybXNcbiAqL1xudmFyIFRyYW5zZm9ybXMgPSB7fTtcblxudmFyIHZlY3RvclByb2R1Y3RMb2NhbEZyYW1lID0ge1xuICB1cDoge1xuICAgIHNvdXRoOiBcImVhc3RcIixcbiAgICBub3J0aDogXCJ3ZXN0XCIsXG4gICAgd2VzdDogXCJzb3V0aFwiLFxuICAgIGVhc3Q6IFwibm9ydGhcIixcbiAgfSxcbiAgZG93bjoge1xuICAgIHNvdXRoOiBcIndlc3RcIixcbiAgICBub3J0aDogXCJlYXN0XCIsXG4gICAgd2VzdDogXCJub3J0aFwiLFxuICAgIGVhc3Q6IFwic291dGhcIixcbiAgfSxcbiAgc291dGg6IHtcbiAgICB1cDogXCJ3ZXN0XCIsXG4gICAgZG93bjogXCJlYXN0XCIsXG4gICAgd2VzdDogXCJkb3duXCIsXG4gICAgZWFzdDogXCJ1cFwiLFxuICB9LFxuICBub3J0aDoge1xuICAgIHVwOiBcImVhc3RcIixcbiAgICBkb3duOiBcIndlc3RcIixcbiAgICB3ZXN0OiBcInVwXCIsXG4gICAgZWFzdDogXCJkb3duXCIsXG4gIH0sXG4gIHdlc3Q6IHtcbiAgICB1cDogXCJub3J0aFwiLFxuICAgIGRvd246IFwic291dGhcIixcbiAgICBub3J0aDogXCJkb3duXCIsXG4gICAgc291dGg6IFwidXBcIixcbiAgfSxcbiAgZWFzdDoge1xuICAgIHVwOiBcInNvdXRoXCIsXG4gICAgZG93bjogXCJub3J0aFwiLFxuICAgIG5vcnRoOiBcInVwXCIsXG4gICAgc291dGg6IFwiZG93blwiLFxuICB9LFxufTtcblxudmFyIGRlZ2VuZXJhdGVQb3NpdGlvbkxvY2FsRnJhbWUgPSB7XG4gIG5vcnRoOiBbLTEsIDAsIDBdLFxuICBlYXN0OiBbMCwgMSwgMF0sXG4gIHVwOiBbMCwgMCwgMV0sXG4gIHNvdXRoOiBbMSwgMCwgMF0sXG4gIHdlc3Q6IFswLCAtMSwgMF0sXG4gIGRvd246IFswLCAwLCAtMV0sXG59O1xuXG52YXIgbG9jYWxGcmFtZVRvRml4ZWRGcmFtZUNhY2hlID0ge307XG5cbnZhciBzY3JhdGNoQ2FsY3VsYXRlQ2FydGVzaWFuID0ge1xuICBlYXN0OiBuZXcgQ2FydGVzaWFuMygpLFxuICBub3J0aDogbmV3IENhcnRlc2lhbjMoKSxcbiAgdXA6IG5ldyBDYXJ0ZXNpYW4zKCksXG4gIHdlc3Q6IG5ldyBDYXJ0ZXNpYW4zKCksXG4gIHNvdXRoOiBuZXcgQ2FydGVzaWFuMygpLFxuICBkb3duOiBuZXcgQ2FydGVzaWFuMygpLFxufTtcbnZhciBzY3JhdGNoRmlyc3RDYXJ0ZXNpYW4gPSBuZXcgQ2FydGVzaWFuMygpO1xudmFyIHNjcmF0Y2hTZWNvbmRDYXJ0ZXNpYW4gPSBuZXcgQ2FydGVzaWFuMygpO1xudmFyIHNjcmF0Y2hUaGlyZENhcnRlc2lhbiA9IG5ldyBDYXJ0ZXNpYW4zKCk7XG4vKipcbiAqIEdlbmVyYXRlcyBhIGZ1bmN0aW9uIHRoYXQgY29tcHV0ZXMgYSA0eDQgdHJhbnNmb3JtYXRpb24gbWF0cml4IGZyb20gYSByZWZlcmVuY2UgZnJhbWVcbiAqIGNlbnRlcmVkIGF0IHRoZSBwcm92aWRlZCBvcmlnaW4gdG8gdGhlIHByb3ZpZGVkIGVsbGlwc29pZCdzIGZpeGVkIHJlZmVyZW5jZSBmcmFtZS5cbiAqIEBwYXJhbSAge1N0cmluZ30gZmlyc3RBeGlzICBuYW1lIG9mIHRoZSBmaXJzdCBheGlzIG9mIHRoZSBsb2NhbCByZWZlcmVuY2UgZnJhbWUuIE11c3QgYmVcbiAqICAnZWFzdCcsICdub3J0aCcsICd1cCcsICd3ZXN0JywgJ3NvdXRoJyBvciAnZG93bicuXG4gKiBAcGFyYW0gIHtTdHJpbmd9IHNlY29uZEF4aXMgIG5hbWUgb2YgdGhlIHNlY29uZCBheGlzIG9mIHRoZSBsb2NhbCByZWZlcmVuY2UgZnJhbWUuIE11c3QgYmVcbiAqICAnZWFzdCcsICdub3J0aCcsICd1cCcsICd3ZXN0JywgJ3NvdXRoJyBvciAnZG93bicuXG4gKiBAcmV0dXJuIHtUcmFuc2Zvcm1zLkxvY2FsRnJhbWVUb0ZpeGVkRnJhbWV9IFRoZSBmdW5jdGlvbiB0aGF0IHdpbGwgY29tcHV0ZXMgYVxuICogNHg0IHRyYW5zZm9ybWF0aW9uIG1hdHJpeCBmcm9tIGEgcmVmZXJlbmNlIGZyYW1lLCB3aXRoIGZpcnN0IGF4aXMgYW5kIHNlY29uZCBheGlzIGNvbXBsaWFudCB3aXRoIHRoZSBwYXJhbWV0ZXJzLFxuICovXG5UcmFuc2Zvcm1zLmxvY2FsRnJhbWVUb0ZpeGVkRnJhbWVHZW5lcmF0b3IgPSBmdW5jdGlvbiAoZmlyc3RBeGlzLCBzZWNvbmRBeGlzKSB7XG4gIGlmIChcbiAgICAhdmVjdG9yUHJvZHVjdExvY2FsRnJhbWUuaGFzT3duUHJvcGVydHkoZmlyc3RBeGlzKSB8fFxuICAgICF2ZWN0b3JQcm9kdWN0TG9jYWxGcmFtZVtmaXJzdEF4aXNdLmhhc093blByb3BlcnR5KHNlY29uZEF4aXMpXG4gICkge1xuICAgIHRocm93IG5ldyBEZXZlbG9wZXJFcnJvcihcbiAgICAgIFwiZmlyc3RBeGlzIGFuZCBzZWNvbmRBeGlzIG11c3QgYmUgZWFzdCwgbm9ydGgsIHVwLCB3ZXN0LCBzb3V0aCBvciBkb3duLlwiXG4gICAgKTtcbiAgfVxuICB2YXIgdGhpcmRBeGlzID0gdmVjdG9yUHJvZHVjdExvY2FsRnJhbWVbZmlyc3RBeGlzXVtzZWNvbmRBeGlzXTtcblxuICAvKipcbiAgICogQ29tcHV0ZXMgYSA0eDQgdHJhbnNmb3JtYXRpb24gbWF0cml4IGZyb20gYSByZWZlcmVuY2UgZnJhbWVcbiAgICogY2VudGVyZWQgYXQgdGhlIHByb3ZpZGVkIG9yaWdpbiB0byB0aGUgcHJvdmlkZWQgZWxsaXBzb2lkJ3MgZml4ZWQgcmVmZXJlbmNlIGZyYW1lLlxuICAgKiBAY2FsbGJhY2sgVHJhbnNmb3Jtcy5Mb2NhbEZyYW1lVG9GaXhlZEZyYW1lXG4gICAqIEBwYXJhbSB7Q2FydGVzaWFuM30gb3JpZ2luIFRoZSBjZW50ZXIgcG9pbnQgb2YgdGhlIGxvY2FsIHJlZmVyZW5jZSBmcmFtZS5cbiAgICogQHBhcmFtIHtFbGxpcHNvaWR9IFtlbGxpcHNvaWQ9RWxsaXBzb2lkLldHUzg0XSBUaGUgZWxsaXBzb2lkIHdob3NlIGZpeGVkIGZyYW1lIGlzIHVzZWQgaW4gdGhlIHRyYW5zZm9ybWF0aW9uLlxuICAgKiBAcGFyYW0ge01hdHJpeDR9IFtyZXN1bHRdIFRoZSBvYmplY3Qgb250byB3aGljaCB0byBzdG9yZSB0aGUgcmVzdWx0LlxuICAgKiBAcmV0dXJucyB7TWF0cml4NH0gVGhlIG1vZGlmaWVkIHJlc3VsdCBwYXJhbWV0ZXIgb3IgYSBuZXcgTWF0cml4NCBpbnN0YW5jZSBpZiBub25lIHdhcyBwcm92aWRlZC5cbiAgICovXG4gIHZhciByZXN1bHRhdDtcbiAgdmFyIGhhc2hBeGlzID0gZmlyc3RBeGlzICsgc2Vjb25kQXhpcztcbiAgaWYgKGRlZmluZWQobG9jYWxGcmFtZVRvRml4ZWRGcmFtZUNhY2hlW2hhc2hBeGlzXSkpIHtcbiAgICByZXN1bHRhdCA9IGxvY2FsRnJhbWVUb0ZpeGVkRnJhbWVDYWNoZVtoYXNoQXhpc107XG4gIH0gZWxzZSB7XG4gICAgcmVzdWx0YXQgPSBmdW5jdGlvbiAob3JpZ2luLCBlbGxpcHNvaWQsIHJlc3VsdCkge1xuICAgICAgLy8+PmluY2x1ZGVTdGFydCgnZGVidWcnLCBwcmFnbWFzLmRlYnVnKTtcbiAgICAgIGlmICghZGVmaW5lZChvcmlnaW4pKSB7XG4gICAgICAgIHRocm93IG5ldyBEZXZlbG9wZXJFcnJvcihcIm9yaWdpbiBpcyByZXF1aXJlZC5cIik7XG4gICAgICB9XG4gICAgICAvLz4+aW5jbHVkZUVuZCgnZGVidWcnKTtcbiAgICAgIGlmICghZGVmaW5lZChyZXN1bHQpKSB7XG4gICAgICAgIHJlc3VsdCA9IG5ldyBNYXRyaXg0KCk7XG4gICAgICB9XG4gICAgICBpZiAoXG4gICAgICAgIENhcnRlc2lhbjMuZXF1YWxzRXBzaWxvbihvcmlnaW4sIENhcnRlc2lhbjMuWkVSTywgQ2VzaXVtTWF0aC5FUFNJTE9OMTQpXG4gICAgICApIHtcbiAgICAgICAgLy8gSWYgeCwgeSwgYW5kIHogYXJlIHplcm8sIHVzZSB0aGUgZGVnZW5lcmF0ZSBsb2NhbCBmcmFtZSwgd2hpY2ggaXMgYSBzcGVjaWFsIGNhc2VcbiAgICAgICAgQ2FydGVzaWFuMy51bnBhY2soXG4gICAgICAgICAgZGVnZW5lcmF0ZVBvc2l0aW9uTG9jYWxGcmFtZVtmaXJzdEF4aXNdLFxuICAgICAgICAgIDAsXG4gICAgICAgICAgc2NyYXRjaEZpcnN0Q2FydGVzaWFuXG4gICAgICAgICk7XG4gICAgICAgIENhcnRlc2lhbjMudW5wYWNrKFxuICAgICAgICAgIGRlZ2VuZXJhdGVQb3NpdGlvbkxvY2FsRnJhbWVbc2Vjb25kQXhpc10sXG4gICAgICAgICAgMCxcbiAgICAgICAgICBzY3JhdGNoU2Vjb25kQ2FydGVzaWFuXG4gICAgICAgICk7XG4gICAgICAgIENhcnRlc2lhbjMudW5wYWNrKFxuICAgICAgICAgIGRlZ2VuZXJhdGVQb3NpdGlvbkxvY2FsRnJhbWVbdGhpcmRBeGlzXSxcbiAgICAgICAgICAwLFxuICAgICAgICAgIHNjcmF0Y2hUaGlyZENhcnRlc2lhblxuICAgICAgICApO1xuICAgICAgfSBlbHNlIGlmIChcbiAgICAgICAgQ2VzaXVtTWF0aC5lcXVhbHNFcHNpbG9uKG9yaWdpbi54LCAwLjAsIENlc2l1bU1hdGguRVBTSUxPTjE0KSAmJlxuICAgICAgICBDZXNpdW1NYXRoLmVxdWFsc0Vwc2lsb24ob3JpZ2luLnksIDAuMCwgQ2VzaXVtTWF0aC5FUFNJTE9OMTQpXG4gICAgICApIHtcbiAgICAgICAgLy8gSWYgeCBhbmQgeSBhcmUgemVybywgYXNzdW1lIG9yaWdpbiBpcyBhdCBhIHBvbGUsIHdoaWNoIGlzIGEgc3BlY2lhbCBjYXNlLlxuICAgICAgICB2YXIgc2lnbiA9IENlc2l1bU1hdGguc2lnbihvcmlnaW4ueik7XG5cbiAgICAgICAgQ2FydGVzaWFuMy51bnBhY2soXG4gICAgICAgICAgZGVnZW5lcmF0ZVBvc2l0aW9uTG9jYWxGcmFtZVtmaXJzdEF4aXNdLFxuICAgICAgICAgIDAsXG4gICAgICAgICAgc2NyYXRjaEZpcnN0Q2FydGVzaWFuXG4gICAgICAgICk7XG4gICAgICAgIGlmIChmaXJzdEF4aXMgIT09IFwiZWFzdFwiICYmIGZpcnN0QXhpcyAhPT0gXCJ3ZXN0XCIpIHtcbiAgICAgICAgICBDYXJ0ZXNpYW4zLm11bHRpcGx5QnlTY2FsYXIoXG4gICAgICAgICAgICBzY3JhdGNoRmlyc3RDYXJ0ZXNpYW4sXG4gICAgICAgICAgICBzaWduLFxuICAgICAgICAgICAgc2NyYXRjaEZpcnN0Q2FydGVzaWFuXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIENhcnRlc2lhbjMudW5wYWNrKFxuICAgICAgICAgIGRlZ2VuZXJhdGVQb3NpdGlvbkxvY2FsRnJhbWVbc2Vjb25kQXhpc10sXG4gICAgICAgICAgMCxcbiAgICAgICAgICBzY3JhdGNoU2Vjb25kQ2FydGVzaWFuXG4gICAgICAgICk7XG4gICAgICAgIGlmIChzZWNvbmRBeGlzICE9PSBcImVhc3RcIiAmJiBzZWNvbmRBeGlzICE9PSBcIndlc3RcIikge1xuICAgICAgICAgIENhcnRlc2lhbjMubXVsdGlwbHlCeVNjYWxhcihcbiAgICAgICAgICAgIHNjcmF0Y2hTZWNvbmRDYXJ0ZXNpYW4sXG4gICAgICAgICAgICBzaWduLFxuICAgICAgICAgICAgc2NyYXRjaFNlY29uZENhcnRlc2lhblxuICAgICAgICAgICk7XG4gICAgICAgIH1cblxuICAgICAgICBDYXJ0ZXNpYW4zLnVucGFjayhcbiAgICAgICAgICBkZWdlbmVyYXRlUG9zaXRpb25Mb2NhbEZyYW1lW3RoaXJkQXhpc10sXG4gICAgICAgICAgMCxcbiAgICAgICAgICBzY3JhdGNoVGhpcmRDYXJ0ZXNpYW5cbiAgICAgICAgKTtcbiAgICAgICAgaWYgKHRoaXJkQXhpcyAhPT0gXCJlYXN0XCIgJiYgdGhpcmRBeGlzICE9PSBcIndlc3RcIikge1xuICAgICAgICAgIENhcnRlc2lhbjMubXVsdGlwbHlCeVNjYWxhcihcbiAgICAgICAgICAgIHNjcmF0Y2hUaGlyZENhcnRlc2lhbixcbiAgICAgICAgICAgIHNpZ24sXG4gICAgICAgICAgICBzY3JhdGNoVGhpcmRDYXJ0ZXNpYW5cbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBlbGxpcHNvaWQgPSBkZWZhdWx0VmFsdWUoZWxsaXBzb2lkLCBFbGxpcHNvaWQuV0dTODQpO1xuICAgICAgICBlbGxpcHNvaWQuZ2VvZGV0aWNTdXJmYWNlTm9ybWFsKG9yaWdpbiwgc2NyYXRjaENhbGN1bGF0ZUNhcnRlc2lhbi51cCk7XG5cbiAgICAgICAgdmFyIHVwID0gc2NyYXRjaENhbGN1bGF0ZUNhcnRlc2lhbi51cDtcbiAgICAgICAgdmFyIGVhc3QgPSBzY3JhdGNoQ2FsY3VsYXRlQ2FydGVzaWFuLmVhc3Q7XG4gICAgICAgIGVhc3QueCA9IC1vcmlnaW4ueTtcbiAgICAgICAgZWFzdC55ID0gb3JpZ2luLng7XG4gICAgICAgIGVhc3QueiA9IDAuMDtcbiAgICAgICAgQ2FydGVzaWFuMy5ub3JtYWxpemUoZWFzdCwgc2NyYXRjaENhbGN1bGF0ZUNhcnRlc2lhbi5lYXN0KTtcbiAgICAgICAgQ2FydGVzaWFuMy5jcm9zcyh1cCwgZWFzdCwgc2NyYXRjaENhbGN1bGF0ZUNhcnRlc2lhbi5ub3J0aCk7XG5cbiAgICAgICAgQ2FydGVzaWFuMy5tdWx0aXBseUJ5U2NhbGFyKFxuICAgICAgICAgIHNjcmF0Y2hDYWxjdWxhdGVDYXJ0ZXNpYW4udXAsXG4gICAgICAgICAgLTEsXG4gICAgICAgICAgc2NyYXRjaENhbGN1bGF0ZUNhcnRlc2lhbi5kb3duXG4gICAgICAgICk7XG4gICAgICAgIENhcnRlc2lhbjMubXVsdGlwbHlCeVNjYWxhcihcbiAgICAgICAgICBzY3JhdGNoQ2FsY3VsYXRlQ2FydGVzaWFuLmVhc3QsXG4gICAgICAgICAgLTEsXG4gICAgICAgICAgc2NyYXRjaENhbGN1bGF0ZUNhcnRlc2lhbi53ZXN0XG4gICAgICAgICk7XG4gICAgICAgIENhcnRlc2lhbjMubXVsdGlwbHlCeVNjYWxhcihcbiAgICAgICAgICBzY3JhdGNoQ2FsY3VsYXRlQ2FydGVzaWFuLm5vcnRoLFxuICAgICAgICAgIC0xLFxuICAgICAgICAgIHNjcmF0Y2hDYWxjdWxhdGVDYXJ0ZXNpYW4uc291dGhcbiAgICAgICAgKTtcblxuICAgICAgICBzY3JhdGNoRmlyc3RDYXJ0ZXNpYW4gPSBzY3JhdGNoQ2FsY3VsYXRlQ2FydGVzaWFuW2ZpcnN0QXhpc107XG4gICAgICAgIHNjcmF0Y2hTZWNvbmRDYXJ0ZXNpYW4gPSBzY3JhdGNoQ2FsY3VsYXRlQ2FydGVzaWFuW3NlY29uZEF4aXNdO1xuICAgICAgICBzY3JhdGNoVGhpcmRDYXJ0ZXNpYW4gPSBzY3JhdGNoQ2FsY3VsYXRlQ2FydGVzaWFuW3RoaXJkQXhpc107XG4gICAgICB9XG4gICAgICByZXN1bHRbMF0gPSBzY3JhdGNoRmlyc3RDYXJ0ZXNpYW4ueDtcbiAgICAgIHJlc3VsdFsxXSA9IHNjcmF0Y2hGaXJzdENhcnRlc2lhbi55O1xuICAgICAgcmVzdWx0WzJdID0gc2NyYXRjaEZpcnN0Q2FydGVzaWFuLno7XG4gICAgICByZXN1bHRbM10gPSAwLjA7XG4gICAgICByZXN1bHRbNF0gPSBzY3JhdGNoU2Vjb25kQ2FydGVzaWFuLng7XG4gICAgICByZXN1bHRbNV0gPSBzY3JhdGNoU2Vjb25kQ2FydGVzaWFuLnk7XG4gICAgICByZXN1bHRbNl0gPSBzY3JhdGNoU2Vjb25kQ2FydGVzaWFuLno7XG4gICAgICByZXN1bHRbN10gPSAwLjA7XG4gICAgICByZXN1bHRbOF0gPSBzY3JhdGNoVGhpcmRDYXJ0ZXNpYW4ueDtcbiAgICAgIHJlc3VsdFs5XSA9IHNjcmF0Y2hUaGlyZENhcnRlc2lhbi55O1xuICAgICAgcmVzdWx0WzEwXSA9IHNjcmF0Y2hUaGlyZENhcnRlc2lhbi56O1xuICAgICAgcmVzdWx0WzExXSA9IDAuMDtcbiAgICAgIHJlc3VsdFsxMl0gPSBvcmlnaW4ueDtcbiAgICAgIHJlc3VsdFsxM10gPSBvcmlnaW4ueTtcbiAgICAgIHJlc3VsdFsxNF0gPSBvcmlnaW4uejtcbiAgICAgIHJlc3VsdFsxNV0gPSAxLjA7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG4gICAgbG9jYWxGcmFtZVRvRml4ZWRGcmFtZUNhY2hlW2hhc2hBeGlzXSA9IHJlc3VsdGF0O1xuICB9XG4gIHJldHVybiByZXN1bHRhdDtcbn07XG5cbi8qKlxuICogQ29tcHV0ZXMgYSA0eDQgdHJhbnNmb3JtYXRpb24gbWF0cml4IGZyb20gYSByZWZlcmVuY2UgZnJhbWUgd2l0aCBhbiBlYXN0LW5vcnRoLXVwIGF4ZXNcbiAqIGNlbnRlcmVkIGF0IHRoZSBwcm92aWRlZCBvcmlnaW4gdG8gdGhlIHByb3ZpZGVkIGVsbGlwc29pZCdzIGZpeGVkIHJlZmVyZW5jZSBmcmFtZS5cbiAqIFRoZSBsb2NhbCBheGVzIGFyZSBkZWZpbmVkIGFzOlxuICogPHVsPlxuICogPGxpPlRoZSA8Y29kZT54PC9jb2RlPiBheGlzIHBvaW50cyBpbiB0aGUgbG9jYWwgZWFzdCBkaXJlY3Rpb24uPC9saT5cbiAqIDxsaT5UaGUgPGNvZGU+eTwvY29kZT4gYXhpcyBwb2ludHMgaW4gdGhlIGxvY2FsIG5vcnRoIGRpcmVjdGlvbi48L2xpPlxuICogPGxpPlRoZSA8Y29kZT56PC9jb2RlPiBheGlzIHBvaW50cyBpbiB0aGUgZGlyZWN0aW9uIG9mIHRoZSBlbGxpcHNvaWQgc3VyZmFjZSBub3JtYWwgd2hpY2ggcGFzc2VzIHRocm91Z2ggdGhlIHBvc2l0aW9uLjwvbGk+XG4gKiA8L3VsPlxuICpcbiAqIEBmdW5jdGlvblxuICogQHBhcmFtIHtDYXJ0ZXNpYW4zfSBvcmlnaW4gVGhlIGNlbnRlciBwb2ludCBvZiB0aGUgbG9jYWwgcmVmZXJlbmNlIGZyYW1lLlxuICogQHBhcmFtIHtFbGxpcHNvaWR9IFtlbGxpcHNvaWQ9RWxsaXBzb2lkLldHUzg0XSBUaGUgZWxsaXBzb2lkIHdob3NlIGZpeGVkIGZyYW1lIGlzIHVzZWQgaW4gdGhlIHRyYW5zZm9ybWF0aW9uLlxuICogQHBhcmFtIHtNYXRyaXg0fSBbcmVzdWx0XSBUaGUgb2JqZWN0IG9udG8gd2hpY2ggdG8gc3RvcmUgdGhlIHJlc3VsdC5cbiAqIEByZXR1cm5zIHtNYXRyaXg0fSBUaGUgbW9kaWZpZWQgcmVzdWx0IHBhcmFtZXRlciBvciBhIG5ldyBNYXRyaXg0IGluc3RhbmNlIGlmIG5vbmUgd2FzIHByb3ZpZGVkLlxuICpcbiAqIEBleGFtcGxlXG4gKiAvLyBHZXQgdGhlIHRyYW5zZm9ybSBmcm9tIGxvY2FsIGVhc3Qtbm9ydGgtdXAgYXQgY2FydG9ncmFwaGljICgwLjAsIDAuMCkgdG8gRWFydGgncyBmaXhlZCBmcmFtZS5cbiAqIHZhciBjZW50ZXIgPSBDZXNpdW0uQ2FydGVzaWFuMy5mcm9tRGVncmVlcygwLjAsIDAuMCk7XG4gKiB2YXIgdHJhbnNmb3JtID0gQ2VzaXVtLlRyYW5zZm9ybXMuZWFzdE5vcnRoVXBUb0ZpeGVkRnJhbWUoY2VudGVyKTtcbiAqL1xuVHJhbnNmb3Jtcy5lYXN0Tm9ydGhVcFRvRml4ZWRGcmFtZSA9IFRyYW5zZm9ybXMubG9jYWxGcmFtZVRvRml4ZWRGcmFtZUdlbmVyYXRvcihcbiAgXCJlYXN0XCIsXG4gIFwibm9ydGhcIlxuKTtcblxuLyoqXG4gKiBDb21wdXRlcyBhIDR4NCB0cmFuc2Zvcm1hdGlvbiBtYXRyaXggZnJvbSBhIHJlZmVyZW5jZSBmcmFtZSB3aXRoIGFuIG5vcnRoLWVhc3QtZG93biBheGVzXG4gKiBjZW50ZXJlZCBhdCB0aGUgcHJvdmlkZWQgb3JpZ2luIHRvIHRoZSBwcm92aWRlZCBlbGxpcHNvaWQncyBmaXhlZCByZWZlcmVuY2UgZnJhbWUuXG4gKiBUaGUgbG9jYWwgYXhlcyBhcmUgZGVmaW5lZCBhczpcbiAqIDx1bD5cbiAqIDxsaT5UaGUgPGNvZGU+eDwvY29kZT4gYXhpcyBwb2ludHMgaW4gdGhlIGxvY2FsIG5vcnRoIGRpcmVjdGlvbi48L2xpPlxuICogPGxpPlRoZSA8Y29kZT55PC9jb2RlPiBheGlzIHBvaW50cyBpbiB0aGUgbG9jYWwgZWFzdCBkaXJlY3Rpb24uPC9saT5cbiAqIDxsaT5UaGUgPGNvZGU+ejwvY29kZT4gYXhpcyBwb2ludHMgaW4gdGhlIG9wcG9zaXRlIGRpcmVjdGlvbiBvZiB0aGUgZWxsaXBzb2lkIHN1cmZhY2Ugbm9ybWFsIHdoaWNoIHBhc3NlcyB0aHJvdWdoIHRoZSBwb3NpdGlvbi48L2xpPlxuICogPC91bD5cbiAqXG4gKiBAZnVuY3Rpb25cbiAqIEBwYXJhbSB7Q2FydGVzaWFuM30gb3JpZ2luIFRoZSBjZW50ZXIgcG9pbnQgb2YgdGhlIGxvY2FsIHJlZmVyZW5jZSBmcmFtZS5cbiAqIEBwYXJhbSB7RWxsaXBzb2lkfSBbZWxsaXBzb2lkPUVsbGlwc29pZC5XR1M4NF0gVGhlIGVsbGlwc29pZCB3aG9zZSBmaXhlZCBmcmFtZSBpcyB1c2VkIGluIHRoZSB0cmFuc2Zvcm1hdGlvbi5cbiAqIEBwYXJhbSB7TWF0cml4NH0gW3Jlc3VsdF0gVGhlIG9iamVjdCBvbnRvIHdoaWNoIHRvIHN0b3JlIHRoZSByZXN1bHQuXG4gKiBAcmV0dXJucyB7TWF0cml4NH0gVGhlIG1vZGlmaWVkIHJlc3VsdCBwYXJhbWV0ZXIgb3IgYSBuZXcgTWF0cml4NCBpbnN0YW5jZSBpZiBub25lIHdhcyBwcm92aWRlZC5cbiAqXG4gKiBAZXhhbXBsZVxuICogLy8gR2V0IHRoZSB0cmFuc2Zvcm0gZnJvbSBsb2NhbCBub3J0aC1lYXN0LWRvd24gYXQgY2FydG9ncmFwaGljICgwLjAsIDAuMCkgdG8gRWFydGgncyBmaXhlZCBmcmFtZS5cbiAqIHZhciBjZW50ZXIgPSBDZXNpdW0uQ2FydGVzaWFuMy5mcm9tRGVncmVlcygwLjAsIDAuMCk7XG4gKiB2YXIgdHJhbnNmb3JtID0gQ2VzaXVtLlRyYW5zZm9ybXMubm9ydGhFYXN0RG93blRvRml4ZWRGcmFtZShjZW50ZXIpO1xuICovXG5UcmFuc2Zvcm1zLm5vcnRoRWFzdERvd25Ub0ZpeGVkRnJhbWUgPSBUcmFuc2Zvcm1zLmxvY2FsRnJhbWVUb0ZpeGVkRnJhbWVHZW5lcmF0b3IoXG4gIFwibm9ydGhcIixcbiAgXCJlYXN0XCJcbik7XG5cbi8qKlxuICogQ29tcHV0ZXMgYSA0eDQgdHJhbnNmb3JtYXRpb24gbWF0cml4IGZyb20gYSByZWZlcmVuY2UgZnJhbWUgd2l0aCBhbiBub3J0aC11cC1lYXN0IGF4ZXNcbiAqIGNlbnRlcmVkIGF0IHRoZSBwcm92aWRlZCBvcmlnaW4gdG8gdGhlIHByb3ZpZGVkIGVsbGlwc29pZCdzIGZpeGVkIHJlZmVyZW5jZSBmcmFtZS5cbiAqIFRoZSBsb2NhbCBheGVzIGFyZSBkZWZpbmVkIGFzOlxuICogPHVsPlxuICogPGxpPlRoZSA8Y29kZT54PC9jb2RlPiBheGlzIHBvaW50cyBpbiB0aGUgbG9jYWwgbm9ydGggZGlyZWN0aW9uLjwvbGk+XG4gKiA8bGk+VGhlIDxjb2RlPnk8L2NvZGU+IGF4aXMgcG9pbnRzIGluIHRoZSBkaXJlY3Rpb24gb2YgdGhlIGVsbGlwc29pZCBzdXJmYWNlIG5vcm1hbCB3aGljaCBwYXNzZXMgdGhyb3VnaCB0aGUgcG9zaXRpb24uPC9saT5cbiAqIDxsaT5UaGUgPGNvZGU+ejwvY29kZT4gYXhpcyBwb2ludHMgaW4gdGhlIGxvY2FsIGVhc3QgZGlyZWN0aW9uLjwvbGk+XG4gKiA8L3VsPlxuICpcbiAqIEBmdW5jdGlvblxuICogQHBhcmFtIHtDYXJ0ZXNpYW4zfSBvcmlnaW4gVGhlIGNlbnRlciBwb2ludCBvZiB0aGUgbG9jYWwgcmVmZXJlbmNlIGZyYW1lLlxuICogQHBhcmFtIHtFbGxpcHNvaWR9IFtlbGxpcHNvaWQ9RWxsaXBzb2lkLldHUzg0XSBUaGUgZWxsaXBzb2lkIHdob3NlIGZpeGVkIGZyYW1lIGlzIHVzZWQgaW4gdGhlIHRyYW5zZm9ybWF0aW9uLlxuICogQHBhcmFtIHtNYXRyaXg0fSBbcmVzdWx0XSBUaGUgb2JqZWN0IG9udG8gd2hpY2ggdG8gc3RvcmUgdGhlIHJlc3VsdC5cbiAqIEByZXR1cm5zIHtNYXRyaXg0fSBUaGUgbW9kaWZpZWQgcmVzdWx0IHBhcmFtZXRlciBvciBhIG5ldyBNYXRyaXg0IGluc3RhbmNlIGlmIG5vbmUgd2FzIHByb3ZpZGVkLlxuICpcbiAqIEBleGFtcGxlXG4gKiAvLyBHZXQgdGhlIHRyYW5zZm9ybSBmcm9tIGxvY2FsIG5vcnRoLXVwLWVhc3QgYXQgY2FydG9ncmFwaGljICgwLjAsIDAuMCkgdG8gRWFydGgncyBmaXhlZCBmcmFtZS5cbiAqIHZhciBjZW50ZXIgPSBDZXNpdW0uQ2FydGVzaWFuMy5mcm9tRGVncmVlcygwLjAsIDAuMCk7XG4gKiB2YXIgdHJhbnNmb3JtID0gQ2VzaXVtLlRyYW5zZm9ybXMubm9ydGhVcEVhc3RUb0ZpeGVkRnJhbWUoY2VudGVyKTtcbiAqL1xuVHJhbnNmb3Jtcy5ub3J0aFVwRWFzdFRvRml4ZWRGcmFtZSA9IFRyYW5zZm9ybXMubG9jYWxGcmFtZVRvRml4ZWRGcmFtZUdlbmVyYXRvcihcbiAgXCJub3J0aFwiLFxuICBcInVwXCJcbik7XG5cbi8qKlxuICogQ29tcHV0ZXMgYSA0eDQgdHJhbnNmb3JtYXRpb24gbWF0cml4IGZyb20gYSByZWZlcmVuY2UgZnJhbWUgd2l0aCBhbiBub3J0aC13ZXN0LXVwIGF4ZXNcbiAqIGNlbnRlcmVkIGF0IHRoZSBwcm92aWRlZCBvcmlnaW4gdG8gdGhlIHByb3ZpZGVkIGVsbGlwc29pZCdzIGZpeGVkIHJlZmVyZW5jZSBmcmFtZS5cbiAqIFRoZSBsb2NhbCBheGVzIGFyZSBkZWZpbmVkIGFzOlxuICogPHVsPlxuICogPGxpPlRoZSA8Y29kZT54PC9jb2RlPiBheGlzIHBvaW50cyBpbiB0aGUgbG9jYWwgbm9ydGggZGlyZWN0aW9uLjwvbGk+XG4gKiA8bGk+VGhlIDxjb2RlPnk8L2NvZGU+IGF4aXMgcG9pbnRzIGluIHRoZSBsb2NhbCB3ZXN0IGRpcmVjdGlvbi48L2xpPlxuICogPGxpPlRoZSA8Y29kZT56PC9jb2RlPiBheGlzIHBvaW50cyBpbiB0aGUgZGlyZWN0aW9uIG9mIHRoZSBlbGxpcHNvaWQgc3VyZmFjZSBub3JtYWwgd2hpY2ggcGFzc2VzIHRocm91Z2ggdGhlIHBvc2l0aW9uLjwvbGk+XG4gKiA8L3VsPlxuICpcbiAqIEBmdW5jdGlvblxuICogQHBhcmFtIHtDYXJ0ZXNpYW4zfSBvcmlnaW4gVGhlIGNlbnRlciBwb2ludCBvZiB0aGUgbG9jYWwgcmVmZXJlbmNlIGZyYW1lLlxuICogQHBhcmFtIHtFbGxpcHNvaWR9IFtlbGxpcHNvaWQ9RWxsaXBzb2lkLldHUzg0XSBUaGUgZWxsaXBzb2lkIHdob3NlIGZpeGVkIGZyYW1lIGlzIHVzZWQgaW4gdGhlIHRyYW5zZm9ybWF0aW9uLlxuICogQHBhcmFtIHtNYXRyaXg0fSBbcmVzdWx0XSBUaGUgb2JqZWN0IG9udG8gd2hpY2ggdG8gc3RvcmUgdGhlIHJlc3VsdC5cbiAqIEByZXR1cm5zIHtNYXRyaXg0fSBUaGUgbW9kaWZpZWQgcmVzdWx0IHBhcmFtZXRlciBvciBhIG5ldyBNYXRyaXg0IGluc3RhbmNlIGlmIG5vbmUgd2FzIHByb3ZpZGVkLlxuICpcbiAqIEBleGFtcGxlXG4gKiAvLyBHZXQgdGhlIHRyYW5zZm9ybSBmcm9tIGxvY2FsIG5vcnRoLVdlc3QtVXAgYXQgY2FydG9ncmFwaGljICgwLjAsIDAuMCkgdG8gRWFydGgncyBmaXhlZCBmcmFtZS5cbiAqIHZhciBjZW50ZXIgPSBDZXNpdW0uQ2FydGVzaWFuMy5mcm9tRGVncmVlcygwLjAsIDAuMCk7XG4gKiB2YXIgdHJhbnNmb3JtID0gQ2VzaXVtLlRyYW5zZm9ybXMubm9ydGhXZXN0VXBUb0ZpeGVkRnJhbWUoY2VudGVyKTtcbiAqL1xuVHJhbnNmb3Jtcy5ub3J0aFdlc3RVcFRvRml4ZWRGcmFtZSA9IFRyYW5zZm9ybXMubG9jYWxGcmFtZVRvRml4ZWRGcmFtZUdlbmVyYXRvcihcbiAgXCJub3J0aFwiLFxuICBcIndlc3RcIlxuKTtcblxudmFyIHNjcmF0Y2hIUFJRdWF0ZXJuaW9uID0gbmV3IFF1YXRlcm5pb24oKTtcbnZhciBzY3JhdGNoU2NhbGUgPSBuZXcgQ2FydGVzaWFuMygxLjAsIDEuMCwgMS4wKTtcbnZhciBzY3JhdGNoSFBSTWF0cml4NCA9IG5ldyBNYXRyaXg0KCk7XG5cbi8qKlxuICogQ29tcHV0ZXMgYSA0eDQgdHJhbnNmb3JtYXRpb24gbWF0cml4IGZyb20gYSByZWZlcmVuY2UgZnJhbWUgd2l0aCBheGVzIGNvbXB1dGVkIGZyb20gdGhlIGhlYWRpbmctcGl0Y2gtcm9sbCBhbmdsZXNcbiAqIGNlbnRlcmVkIGF0IHRoZSBwcm92aWRlZCBvcmlnaW4gdG8gdGhlIHByb3ZpZGVkIGVsbGlwc29pZCdzIGZpeGVkIHJlZmVyZW5jZSBmcmFtZS4gSGVhZGluZyBpcyB0aGUgcm90YXRpb24gZnJvbSB0aGUgbG9jYWwgbm9ydGhcbiAqIGRpcmVjdGlvbiB3aGVyZSBhIHBvc2l0aXZlIGFuZ2xlIGlzIGluY3JlYXNpbmcgZWFzdHdhcmQuIFBpdGNoIGlzIHRoZSByb3RhdGlvbiBmcm9tIHRoZSBsb2NhbCBlYXN0LW5vcnRoIHBsYW5lLiBQb3NpdGl2ZSBwaXRjaCBhbmdsZXNcbiAqIGFyZSBhYm92ZSB0aGUgcGxhbmUuIE5lZ2F0aXZlIHBpdGNoIGFuZ2xlcyBhcmUgYmVsb3cgdGhlIHBsYW5lLiBSb2xsIGlzIHRoZSBmaXJzdCByb3RhdGlvbiBhcHBsaWVkIGFib3V0IHRoZSBsb2NhbCBlYXN0IGF4aXMuXG4gKlxuICogQHBhcmFtIHtDYXJ0ZXNpYW4zfSBvcmlnaW4gVGhlIGNlbnRlciBwb2ludCBvZiB0aGUgbG9jYWwgcmVmZXJlbmNlIGZyYW1lLlxuICogQHBhcmFtIHtIZWFkaW5nUGl0Y2hSb2xsfSBoZWFkaW5nUGl0Y2hSb2xsIFRoZSBoZWFkaW5nLCBwaXRjaCwgYW5kIHJvbGwuXG4gKiBAcGFyYW0ge0VsbGlwc29pZH0gW2VsbGlwc29pZD1FbGxpcHNvaWQuV0dTODRdIFRoZSBlbGxpcHNvaWQgd2hvc2UgZml4ZWQgZnJhbWUgaXMgdXNlZCBpbiB0aGUgdHJhbnNmb3JtYXRpb24uXG4gKiBAcGFyYW0ge1RyYW5zZm9ybXMuTG9jYWxGcmFtZVRvRml4ZWRGcmFtZX0gW2ZpeGVkRnJhbWVUcmFuc2Zvcm09VHJhbnNmb3Jtcy5lYXN0Tm9ydGhVcFRvRml4ZWRGcmFtZV0gQSA0eDQgdHJhbnNmb3JtYXRpb25cbiAqICBtYXRyaXggZnJvbSBhIHJlZmVyZW5jZSBmcmFtZSB0byB0aGUgcHJvdmlkZWQgZWxsaXBzb2lkJ3MgZml4ZWQgcmVmZXJlbmNlIGZyYW1lXG4gKiBAcGFyYW0ge01hdHJpeDR9IFtyZXN1bHRdIFRoZSBvYmplY3Qgb250byB3aGljaCB0byBzdG9yZSB0aGUgcmVzdWx0LlxuICogQHJldHVybnMge01hdHJpeDR9IFRoZSBtb2RpZmllZCByZXN1bHQgcGFyYW1ldGVyIG9yIGEgbmV3IE1hdHJpeDQgaW5zdGFuY2UgaWYgbm9uZSB3YXMgcHJvdmlkZWQuXG4gKlxuICogQGV4YW1wbGVcbiAqIC8vIEdldCB0aGUgdHJhbnNmb3JtIGZyb20gbG9jYWwgaGVhZGluZy1waXRjaC1yb2xsIGF0IGNhcnRvZ3JhcGhpYyAoMC4wLCAwLjApIHRvIEVhcnRoJ3MgZml4ZWQgZnJhbWUuXG4gKiB2YXIgY2VudGVyID0gQ2VzaXVtLkNhcnRlc2lhbjMuZnJvbURlZ3JlZXMoMC4wLCAwLjApO1xuICogdmFyIGhlYWRpbmcgPSAtQ2VzaXVtLk1hdGguUElfT1ZFUl9UV087XG4gKiB2YXIgcGl0Y2ggPSBDZXNpdW0uTWF0aC5QSV9PVkVSX0ZPVVI7XG4gKiB2YXIgcm9sbCA9IDAuMDtcbiAqIHZhciBocHIgPSBuZXcgQ2VzaXVtLkhlYWRpbmdQaXRjaFJvbGwoaGVhZGluZywgcGl0Y2gsIHJvbGwpO1xuICogdmFyIHRyYW5zZm9ybSA9IENlc2l1bS5UcmFuc2Zvcm1zLmhlYWRpbmdQaXRjaFJvbGxUb0ZpeGVkRnJhbWUoY2VudGVyLCBocHIpO1xuICovXG5UcmFuc2Zvcm1zLmhlYWRpbmdQaXRjaFJvbGxUb0ZpeGVkRnJhbWUgPSBmdW5jdGlvbiAoXG4gIG9yaWdpbixcbiAgaGVhZGluZ1BpdGNoUm9sbCxcbiAgZWxsaXBzb2lkLFxuICBmaXhlZEZyYW1lVHJhbnNmb3JtLFxuICByZXN1bHRcbikge1xuICAvLz4+aW5jbHVkZVN0YXJ0KCdkZWJ1ZycsIHByYWdtYXMuZGVidWcpO1xuICBDaGVjay50eXBlT2Yub2JqZWN0KFwiSGVhZGluZ1BpdGNoUm9sbFwiLCBoZWFkaW5nUGl0Y2hSb2xsKTtcbiAgLy8+PmluY2x1ZGVFbmQoJ2RlYnVnJyk7XG5cbiAgZml4ZWRGcmFtZVRyYW5zZm9ybSA9IGRlZmF1bHRWYWx1ZShcbiAgICBmaXhlZEZyYW1lVHJhbnNmb3JtLFxuICAgIFRyYW5zZm9ybXMuZWFzdE5vcnRoVXBUb0ZpeGVkRnJhbWVcbiAgKTtcbiAgdmFyIGhwclF1YXRlcm5pb24gPSBRdWF0ZXJuaW9uLmZyb21IZWFkaW5nUGl0Y2hSb2xsKFxuICAgIGhlYWRpbmdQaXRjaFJvbGwsXG4gICAgc2NyYXRjaEhQUlF1YXRlcm5pb25cbiAgKTtcbiAgdmFyIGhwck1hdHJpeCA9IE1hdHJpeDQuZnJvbVRyYW5zbGF0aW9uUXVhdGVybmlvblJvdGF0aW9uU2NhbGUoXG4gICAgQ2FydGVzaWFuMy5aRVJPLFxuICAgIGhwclF1YXRlcm5pb24sXG4gICAgc2NyYXRjaFNjYWxlLFxuICAgIHNjcmF0Y2hIUFJNYXRyaXg0XG4gICk7XG4gIHJlc3VsdCA9IGZpeGVkRnJhbWVUcmFuc2Zvcm0ob3JpZ2luLCBlbGxpcHNvaWQsIHJlc3VsdCk7XG4gIHJldHVybiBNYXRyaXg0Lm11bHRpcGx5KHJlc3VsdCwgaHByTWF0cml4LCByZXN1bHQpO1xufTtcblxudmFyIHNjcmF0Y2hFTlVNYXRyaXg0ID0gbmV3IE1hdHJpeDQoKTtcbnZhciBzY3JhdGNoSFBSTWF0cml4MyA9IG5ldyBNYXRyaXgzKCk7XG5cbi8qKlxuICogQ29tcHV0ZXMgYSBxdWF0ZXJuaW9uIGZyb20gYSByZWZlcmVuY2UgZnJhbWUgd2l0aCBheGVzIGNvbXB1dGVkIGZyb20gdGhlIGhlYWRpbmctcGl0Y2gtcm9sbCBhbmdsZXNcbiAqIGNlbnRlcmVkIGF0IHRoZSBwcm92aWRlZCBvcmlnaW4uIEhlYWRpbmcgaXMgdGhlIHJvdGF0aW9uIGZyb20gdGhlIGxvY2FsIG5vcnRoXG4gKiBkaXJlY3Rpb24gd2hlcmUgYSBwb3NpdGl2ZSBhbmdsZSBpcyBpbmNyZWFzaW5nIGVhc3R3YXJkLiBQaXRjaCBpcyB0aGUgcm90YXRpb24gZnJvbSB0aGUgbG9jYWwgZWFzdC1ub3J0aCBwbGFuZS4gUG9zaXRpdmUgcGl0Y2ggYW5nbGVzXG4gKiBhcmUgYWJvdmUgdGhlIHBsYW5lLiBOZWdhdGl2ZSBwaXRjaCBhbmdsZXMgYXJlIGJlbG93IHRoZSBwbGFuZS4gUm9sbCBpcyB0aGUgZmlyc3Qgcm90YXRpb24gYXBwbGllZCBhYm91dCB0aGUgbG9jYWwgZWFzdCBheGlzLlxuICpcbiAqIEBwYXJhbSB7Q2FydGVzaWFuM30gb3JpZ2luIFRoZSBjZW50ZXIgcG9pbnQgb2YgdGhlIGxvY2FsIHJlZmVyZW5jZSBmcmFtZS5cbiAqIEBwYXJhbSB7SGVhZGluZ1BpdGNoUm9sbH0gaGVhZGluZ1BpdGNoUm9sbCBUaGUgaGVhZGluZywgcGl0Y2gsIGFuZCByb2xsLlxuICogQHBhcmFtIHtFbGxpcHNvaWR9IFtlbGxpcHNvaWQ9RWxsaXBzb2lkLldHUzg0XSBUaGUgZWxsaXBzb2lkIHdob3NlIGZpeGVkIGZyYW1lIGlzIHVzZWQgaW4gdGhlIHRyYW5zZm9ybWF0aW9uLlxuICogQHBhcmFtIHtUcmFuc2Zvcm1zLkxvY2FsRnJhbWVUb0ZpeGVkRnJhbWV9IFtmaXhlZEZyYW1lVHJhbnNmb3JtPVRyYW5zZm9ybXMuZWFzdE5vcnRoVXBUb0ZpeGVkRnJhbWVdIEEgNHg0IHRyYW5zZm9ybWF0aW9uXG4gKiAgbWF0cml4IGZyb20gYSByZWZlcmVuY2UgZnJhbWUgdG8gdGhlIHByb3ZpZGVkIGVsbGlwc29pZCdzIGZpeGVkIHJlZmVyZW5jZSBmcmFtZVxuICogQHBhcmFtIHtRdWF0ZXJuaW9ufSBbcmVzdWx0XSBUaGUgb2JqZWN0IG9udG8gd2hpY2ggdG8gc3RvcmUgdGhlIHJlc3VsdC5cbiAqIEByZXR1cm5zIHtRdWF0ZXJuaW9ufSBUaGUgbW9kaWZpZWQgcmVzdWx0IHBhcmFtZXRlciBvciBhIG5ldyBRdWF0ZXJuaW9uIGluc3RhbmNlIGlmIG5vbmUgd2FzIHByb3ZpZGVkLlxuICpcbiAqIEBleGFtcGxlXG4gKiAvLyBHZXQgdGhlIHF1YXRlcm5pb24gZnJvbSBsb2NhbCBoZWFkaW5nLXBpdGNoLXJvbGwgYXQgY2FydG9ncmFwaGljICgwLjAsIDAuMCkgdG8gRWFydGgncyBmaXhlZCBmcmFtZS5cbiAqIHZhciBjZW50ZXIgPSBDZXNpdW0uQ2FydGVzaWFuMy5mcm9tRGVncmVlcygwLjAsIDAuMCk7XG4gKiB2YXIgaGVhZGluZyA9IC1DZXNpdW0uTWF0aC5QSV9PVkVSX1RXTztcbiAqIHZhciBwaXRjaCA9IENlc2l1bS5NYXRoLlBJX09WRVJfRk9VUjtcbiAqIHZhciByb2xsID0gMC4wO1xuICogdmFyIGhwciA9IG5ldyBIZWFkaW5nUGl0Y2hSb2xsKGhlYWRpbmcsIHBpdGNoLCByb2xsKTtcbiAqIHZhciBxdWF0ZXJuaW9uID0gQ2VzaXVtLlRyYW5zZm9ybXMuaGVhZGluZ1BpdGNoUm9sbFF1YXRlcm5pb24oY2VudGVyLCBocHIpO1xuICovXG5UcmFuc2Zvcm1zLmhlYWRpbmdQaXRjaFJvbGxRdWF0ZXJuaW9uID0gZnVuY3Rpb24gKFxuICBvcmlnaW4sXG4gIGhlYWRpbmdQaXRjaFJvbGwsXG4gIGVsbGlwc29pZCxcbiAgZml4ZWRGcmFtZVRyYW5zZm9ybSxcbiAgcmVzdWx0XG4pIHtcbiAgLy8+PmluY2x1ZGVTdGFydCgnZGVidWcnLCBwcmFnbWFzLmRlYnVnKTtcbiAgQ2hlY2sudHlwZU9mLm9iamVjdChcIkhlYWRpbmdQaXRjaFJvbGxcIiwgaGVhZGluZ1BpdGNoUm9sbCk7XG4gIC8vPj5pbmNsdWRlRW5kKCdkZWJ1ZycpO1xuXG4gIHZhciB0cmFuc2Zvcm0gPSBUcmFuc2Zvcm1zLmhlYWRpbmdQaXRjaFJvbGxUb0ZpeGVkRnJhbWUoXG4gICAgb3JpZ2luLFxuICAgIGhlYWRpbmdQaXRjaFJvbGwsXG4gICAgZWxsaXBzb2lkLFxuICAgIGZpeGVkRnJhbWVUcmFuc2Zvcm0sXG4gICAgc2NyYXRjaEVOVU1hdHJpeDRcbiAgKTtcbiAgdmFyIHJvdGF0aW9uID0gTWF0cml4NC5nZXRNYXRyaXgzKHRyYW5zZm9ybSwgc2NyYXRjaEhQUk1hdHJpeDMpO1xuICByZXR1cm4gUXVhdGVybmlvbi5mcm9tUm90YXRpb25NYXRyaXgocm90YXRpb24sIHJlc3VsdCk7XG59O1xuXG52YXIgbm9TY2FsZSA9IG5ldyBDYXJ0ZXNpYW4zKDEuMCwgMS4wLCAxLjApO1xudmFyIGhwckNlbnRlclNjcmF0Y2ggPSBuZXcgQ2FydGVzaWFuMygpO1xudmFyIGZmU2NyYXRjaCA9IG5ldyBNYXRyaXg0KCk7XG52YXIgaHByVHJhbnNmb3JtU2NyYXRjaCA9IG5ldyBNYXRyaXg0KCk7XG52YXIgaHByUm90YXRpb25TY3JhdGNoID0gbmV3IE1hdHJpeDMoKTtcbnZhciBocHJRdWF0ZXJuaW9uU2NyYXRjaCA9IG5ldyBRdWF0ZXJuaW9uKCk7XG4vKipcbiAqIENvbXB1dGVzIGhlYWRpbmctcGl0Y2gtcm9sbCBhbmdsZXMgZnJvbSBhIHRyYW5zZm9ybSBpbiBhIHBhcnRpY3VsYXIgcmVmZXJlbmNlIGZyYW1lLiBIZWFkaW5nIGlzIHRoZSByb3RhdGlvbiBmcm9tIHRoZSBsb2NhbCBub3J0aFxuICogZGlyZWN0aW9uIHdoZXJlIGEgcG9zaXRpdmUgYW5nbGUgaXMgaW5jcmVhc2luZyBlYXN0d2FyZC4gUGl0Y2ggaXMgdGhlIHJvdGF0aW9uIGZyb20gdGhlIGxvY2FsIGVhc3Qtbm9ydGggcGxhbmUuIFBvc2l0aXZlIHBpdGNoIGFuZ2xlc1xuICogYXJlIGFib3ZlIHRoZSBwbGFuZS4gTmVnYXRpdmUgcGl0Y2ggYW5nbGVzIGFyZSBiZWxvdyB0aGUgcGxhbmUuIFJvbGwgaXMgdGhlIGZpcnN0IHJvdGF0aW9uIGFwcGxpZWQgYWJvdXQgdGhlIGxvY2FsIGVhc3QgYXhpcy5cbiAqXG4gKiBAcGFyYW0ge01hdHJpeDR9IHRyYW5zZm9ybSBUaGUgdHJhbnNmb3JtXG4gKiBAcGFyYW0ge0VsbGlwc29pZH0gW2VsbGlwc29pZD1FbGxpcHNvaWQuV0dTODRdIFRoZSBlbGxpcHNvaWQgd2hvc2UgZml4ZWQgZnJhbWUgaXMgdXNlZCBpbiB0aGUgdHJhbnNmb3JtYXRpb24uXG4gKiBAcGFyYW0ge1RyYW5zZm9ybXMuTG9jYWxGcmFtZVRvRml4ZWRGcmFtZX0gW2ZpeGVkRnJhbWVUcmFuc2Zvcm09VHJhbnNmb3Jtcy5lYXN0Tm9ydGhVcFRvRml4ZWRGcmFtZV0gQSA0eDQgdHJhbnNmb3JtYXRpb25cbiAqICBtYXRyaXggZnJvbSBhIHJlZmVyZW5jZSBmcmFtZSB0byB0aGUgcHJvdmlkZWQgZWxsaXBzb2lkJ3MgZml4ZWQgcmVmZXJlbmNlIGZyYW1lXG4gKiBAcGFyYW0ge0hlYWRpbmdQaXRjaFJvbGx9IFtyZXN1bHRdIFRoZSBvYmplY3Qgb250byB3aGljaCB0byBzdG9yZSB0aGUgcmVzdWx0LlxuICogQHJldHVybnMge0hlYWRpbmdQaXRjaFJvbGx9IFRoZSBtb2RpZmllZCByZXN1bHQgcGFyYW1ldGVyIG9yIGEgbmV3IEhlYWRpbmdQaXRjaFJvbGwgaW5zdGFuY2UgaWYgbm9uZSB3YXMgcHJvdmlkZWQuXG4gKi9cblRyYW5zZm9ybXMuZml4ZWRGcmFtZVRvSGVhZGluZ1BpdGNoUm9sbCA9IGZ1bmN0aW9uIChcbiAgdHJhbnNmb3JtLFxuICBlbGxpcHNvaWQsXG4gIGZpeGVkRnJhbWVUcmFuc2Zvcm0sXG4gIHJlc3VsdFxuKSB7XG4gIC8vPj5pbmNsdWRlU3RhcnQoJ2RlYnVnJywgcHJhZ21hcy5kZWJ1Zyk7XG4gIENoZWNrLmRlZmluZWQoXCJ0cmFuc2Zvcm1cIiwgdHJhbnNmb3JtKTtcbiAgLy8+PmluY2x1ZGVFbmQoJ2RlYnVnJyk7XG5cbiAgZWxsaXBzb2lkID0gZGVmYXVsdFZhbHVlKGVsbGlwc29pZCwgRWxsaXBzb2lkLldHUzg0KTtcbiAgZml4ZWRGcmFtZVRyYW5zZm9ybSA9IGRlZmF1bHRWYWx1ZShcbiAgICBmaXhlZEZyYW1lVHJhbnNmb3JtLFxuICAgIFRyYW5zZm9ybXMuZWFzdE5vcnRoVXBUb0ZpeGVkRnJhbWVcbiAgKTtcbiAgaWYgKCFkZWZpbmVkKHJlc3VsdCkpIHtcbiAgICByZXN1bHQgPSBuZXcgSGVhZGluZ1BpdGNoUm9sbCgpO1xuICB9XG5cbiAgdmFyIGNlbnRlciA9IE1hdHJpeDQuZ2V0VHJhbnNsYXRpb24odHJhbnNmb3JtLCBocHJDZW50ZXJTY3JhdGNoKTtcbiAgaWYgKENhcnRlc2lhbjMuZXF1YWxzKGNlbnRlciwgQ2FydGVzaWFuMy5aRVJPKSkge1xuICAgIHJlc3VsdC5oZWFkaW5nID0gMDtcbiAgICByZXN1bHQucGl0Y2ggPSAwO1xuICAgIHJlc3VsdC5yb2xsID0gMDtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG4gIHZhciB0b0ZpeGVkRnJhbWUgPSBNYXRyaXg0LmludmVyc2VUcmFuc2Zvcm1hdGlvbihcbiAgICBmaXhlZEZyYW1lVHJhbnNmb3JtKGNlbnRlciwgZWxsaXBzb2lkLCBmZlNjcmF0Y2gpLFxuICAgIGZmU2NyYXRjaFxuICApO1xuICB2YXIgdHJhbnNmb3JtQ29weSA9IE1hdHJpeDQuc2V0U2NhbGUodHJhbnNmb3JtLCBub1NjYWxlLCBocHJUcmFuc2Zvcm1TY3JhdGNoKTtcbiAgdHJhbnNmb3JtQ29weSA9IE1hdHJpeDQuc2V0VHJhbnNsYXRpb24oXG4gICAgdHJhbnNmb3JtQ29weSxcbiAgICBDYXJ0ZXNpYW4zLlpFUk8sXG4gICAgdHJhbnNmb3JtQ29weVxuICApO1xuXG4gIHRvRml4ZWRGcmFtZSA9IE1hdHJpeDQubXVsdGlwbHkodG9GaXhlZEZyYW1lLCB0cmFuc2Zvcm1Db3B5LCB0b0ZpeGVkRnJhbWUpO1xuICB2YXIgcXVhdGVybmlvblJvdGF0aW9uID0gUXVhdGVybmlvbi5mcm9tUm90YXRpb25NYXRyaXgoXG4gICAgTWF0cml4NC5nZXRNYXRyaXgzKHRvRml4ZWRGcmFtZSwgaHByUm90YXRpb25TY3JhdGNoKSxcbiAgICBocHJRdWF0ZXJuaW9uU2NyYXRjaFxuICApO1xuICBxdWF0ZXJuaW9uUm90YXRpb24gPSBRdWF0ZXJuaW9uLm5vcm1hbGl6ZShcbiAgICBxdWF0ZXJuaW9uUm90YXRpb24sXG4gICAgcXVhdGVybmlvblJvdGF0aW9uXG4gICk7XG5cbiAgcmV0dXJuIEhlYWRpbmdQaXRjaFJvbGwuZnJvbVF1YXRlcm5pb24ocXVhdGVybmlvblJvdGF0aW9uLCByZXN1bHQpO1xufTtcblxudmFyIGdtc3RDb25zdGFudDAgPSA2ICogMzYwMCArIDQxICogNjAgKyA1MC41NDg0MTtcbnZhciBnbXN0Q29uc3RhbnQxID0gODY0MDE4NC44MTI4NjY7XG52YXIgZ21zdENvbnN0YW50MiA9IDAuMDkzMTA0O1xudmFyIGdtc3RDb25zdGFudDMgPSAtNi4yZS02O1xudmFyIHJhdGVDb2VmID0gMS4xNzcyNzU4Mzg0NjY4ZS0xOTtcbnZhciB3Z3M4NFdSUHJlY2Vzc2luZyA9IDcuMjkyMTE1ODU1M2UtNTtcbnZhciB0d29QaU92ZXJTZWNvbmRzSW5EYXkgPSBDZXNpdW1NYXRoLlRXT19QSSAvIDg2NDAwLjA7XG52YXIgZGF0ZUluVXRjID0gbmV3IEp1bGlhbkRhdGUoKTtcblxuLyoqXG4gKiBDb21wdXRlcyBhIHJvdGF0aW9uIG1hdHJpeCB0byB0cmFuc2Zvcm0gYSBwb2ludCBvciB2ZWN0b3IgZnJvbSBUcnVlIEVxdWF0b3IgTWVhbiBFcXVpbm94IChURU1FKSBheGVzIHRvIHRoZVxuICogcHNldWRvLWZpeGVkIGF4ZXMgYXQgYSBnaXZlbiB0aW1lLiAgVGhpcyBtZXRob2QgdHJlYXRzIHRoZSBVVDEgdGltZSBzdGFuZGFyZCBhcyBlcXVpdmFsZW50IHRvIFVUQy5cbiAqXG4gKiBAcGFyYW0ge0p1bGlhbkRhdGV9IGRhdGUgVGhlIHRpbWUgYXQgd2hpY2ggdG8gY29tcHV0ZSB0aGUgcm90YXRpb24gbWF0cml4LlxuICogQHBhcmFtIHtNYXRyaXgzfSBbcmVzdWx0XSBUaGUgb2JqZWN0IG9udG8gd2hpY2ggdG8gc3RvcmUgdGhlIHJlc3VsdC5cbiAqIEByZXR1cm5zIHtNYXRyaXgzfSBUaGUgbW9kaWZpZWQgcmVzdWx0IHBhcmFtZXRlciBvciBhIG5ldyBNYXRyaXgzIGluc3RhbmNlIGlmIG5vbmUgd2FzIHByb3ZpZGVkLlxuICpcbiAqIEBleGFtcGxlXG4gKiAvL1NldCB0aGUgdmlldyB0byB0aGUgaW5lcnRpYWwgZnJhbWUuXG4gKiBzY2VuZS5wb3N0VXBkYXRlLmFkZEV2ZW50TGlzdGVuZXIoZnVuY3Rpb24oc2NlbmUsIHRpbWUpIHtcbiAqICAgIHZhciBub3cgPSBDZXNpdW0uSnVsaWFuRGF0ZS5ub3coKTtcbiAqICAgIHZhciBvZmZzZXQgPSBDZXNpdW0uTWF0cml4NC5tdWx0aXBseUJ5UG9pbnQoY2FtZXJhLnRyYW5zZm9ybSwgY2FtZXJhLnBvc2l0aW9uLCBuZXcgQ2VzaXVtLkNhcnRlc2lhbjMoKSk7XG4gKiAgICB2YXIgdHJhbnNmb3JtID0gQ2VzaXVtLk1hdHJpeDQuZnJvbVJvdGF0aW9uVHJhbnNsYXRpb24oQ2VzaXVtLlRyYW5zZm9ybXMuY29tcHV0ZVRlbWVUb1BzZXVkb0ZpeGVkTWF0cml4KG5vdykpO1xuICogICAgdmFyIGludmVyc2VUcmFuc2Zvcm0gPSBDZXNpdW0uTWF0cml4NC5pbnZlcnNlVHJhbnNmb3JtYXRpb24odHJhbnNmb3JtLCBuZXcgQ2VzaXVtLk1hdHJpeDQoKSk7XG4gKiAgICBDZXNpdW0uTWF0cml4NC5tdWx0aXBseUJ5UG9pbnQoaW52ZXJzZVRyYW5zZm9ybSwgb2Zmc2V0LCBvZmZzZXQpO1xuICogICAgY2FtZXJhLmxvb2tBdFRyYW5zZm9ybSh0cmFuc2Zvcm0sIG9mZnNldCk7XG4gKiB9KTtcbiAqL1xuVHJhbnNmb3Jtcy5jb21wdXRlVGVtZVRvUHNldWRvRml4ZWRNYXRyaXggPSBmdW5jdGlvbiAoZGF0ZSwgcmVzdWx0KSB7XG4gIC8vPj5pbmNsdWRlU3RhcnQoJ2RlYnVnJywgcHJhZ21hcy5kZWJ1Zyk7XG4gIGlmICghZGVmaW5lZChkYXRlKSkge1xuICAgIHRocm93IG5ldyBEZXZlbG9wZXJFcnJvcihcImRhdGUgaXMgcmVxdWlyZWQuXCIpO1xuICB9XG4gIC8vPj5pbmNsdWRlRW5kKCdkZWJ1ZycpO1xuXG4gIC8vIEdNU1QgaXMgYWN0dWFsbHkgY29tcHV0ZWQgdXNpbmcgVVQxLiAgV2UncmUgdXNpbmcgVVRDIGFzIGFuIGFwcHJveGltYXRpb24gb2YgVVQxLlxuICAvLyBXZSBkbyBub3Qgd2FudCB0byB1c2UgdGhlIGZ1bmN0aW9uIGxpa2UgY29udmVydFRhaVRvVXRjIGluIEp1bGlhbkRhdGUgYmVjYXVzZVxuICAvLyB3ZSBleHBsaWNpdGx5IGRvIG5vdCB3YW50IHRvIGZhaWwgd2hlbiBpbnNpZGUgdGhlIGxlYXAgc2Vjb25kLlxuXG4gIGRhdGVJblV0YyA9IEp1bGlhbkRhdGUuYWRkU2Vjb25kcyhcbiAgICBkYXRlLFxuICAgIC1KdWxpYW5EYXRlLmNvbXB1dGVUYWlNaW51c1V0YyhkYXRlKSxcbiAgICBkYXRlSW5VdGNcbiAgKTtcbiAgdmFyIHV0Y0RheU51bWJlciA9IGRhdGVJblV0Yy5kYXlOdW1iZXI7XG4gIHZhciB1dGNTZWNvbmRzSW50b0RheSA9IGRhdGVJblV0Yy5zZWNvbmRzT2ZEYXk7XG5cbiAgdmFyIHQ7XG4gIHZhciBkaWZmRGF5cyA9IHV0Y0RheU51bWJlciAtIDI0NTE1NDU7XG4gIGlmICh1dGNTZWNvbmRzSW50b0RheSA+PSA0MzIwMC4wKSB7XG4gICAgdCA9IChkaWZmRGF5cyArIDAuNSkgLyBUaW1lQ29uc3RhbnRzLkRBWVNfUEVSX0pVTElBTl9DRU5UVVJZO1xuICB9IGVsc2Uge1xuICAgIHQgPSAoZGlmZkRheXMgLSAwLjUpIC8gVGltZUNvbnN0YW50cy5EQVlTX1BFUl9KVUxJQU5fQ0VOVFVSWTtcbiAgfVxuXG4gIHZhciBnbXN0MCA9XG4gICAgZ21zdENvbnN0YW50MCArXG4gICAgdCAqIChnbXN0Q29uc3RhbnQxICsgdCAqIChnbXN0Q29uc3RhbnQyICsgdCAqIGdtc3RDb25zdGFudDMpKTtcbiAgdmFyIGFuZ2xlID0gKGdtc3QwICogdHdvUGlPdmVyU2Vjb25kc0luRGF5KSAlIENlc2l1bU1hdGguVFdPX1BJO1xuICB2YXIgcmF0aW8gPSB3Z3M4NFdSUHJlY2Vzc2luZyArIHJhdGVDb2VmICogKHV0Y0RheU51bWJlciAtIDI0NTE1NDUuNSk7XG4gIHZhciBzZWNvbmRzU2luY2VNaWRuaWdodCA9XG4gICAgKHV0Y1NlY29uZHNJbnRvRGF5ICsgVGltZUNvbnN0YW50cy5TRUNPTkRTX1BFUl9EQVkgKiAwLjUpICVcbiAgICBUaW1lQ29uc3RhbnRzLlNFQ09ORFNfUEVSX0RBWTtcbiAgdmFyIGdoYSA9IGFuZ2xlICsgcmF0aW8gKiBzZWNvbmRzU2luY2VNaWRuaWdodDtcbiAgdmFyIGNvc0doYSA9IE1hdGguY29zKGdoYSk7XG4gIHZhciBzaW5HaGEgPSBNYXRoLnNpbihnaGEpO1xuXG4gIGlmICghZGVmaW5lZChyZXN1bHQpKSB7XG4gICAgcmV0dXJuIG5ldyBNYXRyaXgzKFxuICAgICAgY29zR2hhLFxuICAgICAgc2luR2hhLFxuICAgICAgMC4wLFxuICAgICAgLXNpbkdoYSxcbiAgICAgIGNvc0doYSxcbiAgICAgIDAuMCxcbiAgICAgIDAuMCxcbiAgICAgIDAuMCxcbiAgICAgIDEuMFxuICAgICk7XG4gIH1cbiAgcmVzdWx0WzBdID0gY29zR2hhO1xuICByZXN1bHRbMV0gPSAtc2luR2hhO1xuICByZXN1bHRbMl0gPSAwLjA7XG4gIHJlc3VsdFszXSA9IHNpbkdoYTtcbiAgcmVzdWx0WzRdID0gY29zR2hhO1xuICByZXN1bHRbNV0gPSAwLjA7XG4gIHJlc3VsdFs2XSA9IDAuMDtcbiAgcmVzdWx0WzddID0gMC4wO1xuICByZXN1bHRbOF0gPSAxLjA7XG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG4vKipcbiAqIFRoZSBzb3VyY2Ugb2YgSUFVIDIwMDYgWFlTIGRhdGEsIHVzZWQgZm9yIGNvbXB1dGluZyB0aGUgdHJhbnNmb3JtYXRpb24gYmV0d2VlbiB0aGVcbiAqIEZpeGVkIGFuZCBJQ1JGIGF4ZXMuXG4gKiBAdHlwZSB7SWF1MjAwNlh5c0RhdGF9XG4gKlxuICogQHNlZSBUcmFuc2Zvcm1zLmNvbXB1dGVJY3JmVG9GaXhlZE1hdHJpeFxuICogQHNlZSBUcmFuc2Zvcm1zLmNvbXB1dGVGaXhlZFRvSWNyZk1hdHJpeFxuICpcbiAqIEBwcml2YXRlXG4gKi9cblRyYW5zZm9ybXMuaWF1MjAwNlh5c0RhdGEgPSBuZXcgSWF1MjAwNlh5c0RhdGEoKTtcblxuLyoqXG4gKiBUaGUgc291cmNlIG9mIEVhcnRoIE9yaWVudGF0aW9uIFBhcmFtZXRlcnMgKEVPUCkgZGF0YSwgdXNlZCBmb3IgY29tcHV0aW5nIHRoZSB0cmFuc2Zvcm1hdGlvblxuICogYmV0d2VlbiB0aGUgRml4ZWQgYW5kIElDUkYgYXhlcy4gIEJ5IGRlZmF1bHQsIHplcm8gdmFsdWVzIGFyZSB1c2VkIGZvciBhbGwgRU9QIHZhbHVlcyxcbiAqIHlpZWxkaW5nIGEgcmVhc29uYWJsZSBidXQgbm90IGNvbXBsZXRlbHkgYWNjdXJhdGUgcmVwcmVzZW50YXRpb24gb2YgdGhlIElDUkYgYXhlcy5cbiAqIEB0eXBlIHtFYXJ0aE9yaWVudGF0aW9uUGFyYW1ldGVyc31cbiAqXG4gKiBAc2VlIFRyYW5zZm9ybXMuY29tcHV0ZUljcmZUb0ZpeGVkTWF0cml4XG4gKiBAc2VlIFRyYW5zZm9ybXMuY29tcHV0ZUZpeGVkVG9JY3JmTWF0cml4XG4gKlxuICogQHByaXZhdGVcbiAqL1xuVHJhbnNmb3Jtcy5lYXJ0aE9yaWVudGF0aW9uUGFyYW1ldGVycyA9IEVhcnRoT3JpZW50YXRpb25QYXJhbWV0ZXJzLk5PTkU7XG5cbnZhciB0dE1pbnVzVGFpID0gMzIuMTg0O1xudmFyIGoyMDAwdHREYXlzID0gMjQ1MTU0NS4wO1xuXG4vKipcbiAqIFByZWxvYWRzIHRoZSBkYXRhIG5lY2Vzc2FyeSB0byB0cmFuc2Zvcm0gYmV0d2VlbiB0aGUgSUNSRiBhbmQgRml4ZWQgYXhlcywgaW4gZWl0aGVyXG4gKiBkaXJlY3Rpb24sIG92ZXIgYSBnaXZlbiBpbnRlcnZhbC4gIFRoaXMgZnVuY3Rpb24gcmV0dXJucyBhIHByb21pc2UgdGhhdCwgd2hlbiByZXNvbHZlZCxcbiAqIGluZGljYXRlcyB0aGF0IHRoZSBwcmVsb2FkIGhhcyBjb21wbGV0ZWQuXG4gKlxuICogQHBhcmFtIHtUaW1lSW50ZXJ2YWx9IHRpbWVJbnRlcnZhbCBUaGUgaW50ZXJ2YWwgdG8gcHJlbG9hZC5cbiAqIEByZXR1cm5zIHtQcm9taXNlPHZvaWQ+fSBBIHByb21pc2UgdGhhdCwgd2hlbiByZXNvbHZlZCwgaW5kaWNhdGVzIHRoYXQgdGhlIHByZWxvYWQgaGFzIGNvbXBsZXRlZFxuICogICAgICAgICAgYW5kIGV2YWx1YXRpb24gb2YgdGhlIHRyYW5zZm9ybWF0aW9uIGJldHdlZW4gdGhlIGZpeGVkIGFuZCBJQ1JGIGF4ZXMgd2lsbFxuICogICAgICAgICAgbm8gbG9uZ2VyIHJldHVybiB1bmRlZmluZWQgZm9yIGEgdGltZSBpbnNpZGUgdGhlIGludGVydmFsLlxuICpcbiAqXG4gKiBAZXhhbXBsZVxuICogdmFyIGludGVydmFsID0gbmV3IENlc2l1bS5UaW1lSW50ZXJ2YWwoLi4uKTtcbiAqIHdoZW4oQ2VzaXVtLlRyYW5zZm9ybXMucHJlbG9hZEljcmZGaXhlZChpbnRlcnZhbCksIGZ1bmN0aW9uKCkge1xuICogICAgIC8vIHRoZSBkYXRhIGlzIG5vdyBsb2FkZWRcbiAqIH0pO1xuICpcbiAqIEBzZWUgVHJhbnNmb3Jtcy5jb21wdXRlSWNyZlRvRml4ZWRNYXRyaXhcbiAqIEBzZWUgVHJhbnNmb3Jtcy5jb21wdXRlRml4ZWRUb0ljcmZNYXRyaXhcbiAqIEBzZWUgd2hlblxuICovXG5UcmFuc2Zvcm1zLnByZWxvYWRJY3JmRml4ZWQgPSBmdW5jdGlvbiAodGltZUludGVydmFsKSB7XG4gIHZhciBzdGFydERheVRUID0gdGltZUludGVydmFsLnN0YXJ0LmRheU51bWJlcjtcbiAgdmFyIHN0YXJ0U2Vjb25kVFQgPSB0aW1lSW50ZXJ2YWwuc3RhcnQuc2Vjb25kc09mRGF5ICsgdHRNaW51c1RhaTtcbiAgdmFyIHN0b3BEYXlUVCA9IHRpbWVJbnRlcnZhbC5zdG9wLmRheU51bWJlcjtcbiAgdmFyIHN0b3BTZWNvbmRUVCA9IHRpbWVJbnRlcnZhbC5zdG9wLnNlY29uZHNPZkRheSArIHR0TWludXNUYWk7XG5cbiAgdmFyIHh5c1Byb21pc2UgPSBUcmFuc2Zvcm1zLmlhdTIwMDZYeXNEYXRhLnByZWxvYWQoXG4gICAgc3RhcnREYXlUVCxcbiAgICBzdGFydFNlY29uZFRULFxuICAgIHN0b3BEYXlUVCxcbiAgICBzdG9wU2Vjb25kVFRcbiAgKTtcbiAgdmFyIGVvcFByb21pc2UgPSBUcmFuc2Zvcm1zLmVhcnRoT3JpZW50YXRpb25QYXJhbWV0ZXJzLmdldFByb21pc2VUb0xvYWQoKTtcblxuICByZXR1cm4gd2hlbi5hbGwoW3h5c1Byb21pc2UsIGVvcFByb21pc2VdKTtcbn07XG5cbi8qKlxuICogQ29tcHV0ZXMgYSByb3RhdGlvbiBtYXRyaXggdG8gdHJhbnNmb3JtIGEgcG9pbnQgb3IgdmVjdG9yIGZyb20gdGhlIEludGVybmF0aW9uYWwgQ2VsZXN0aWFsXG4gKiBSZWZlcmVuY2UgRnJhbWUgKEdDUkYvSUNSRikgaW5lcnRpYWwgZnJhbWUgYXhlcyB0byB0aGUgRWFydGgtRml4ZWQgZnJhbWUgYXhlcyAoSVRSRilcbiAqIGF0IGEgZ2l2ZW4gdGltZS4gIFRoaXMgZnVuY3Rpb24gbWF5IHJldHVybiB1bmRlZmluZWQgaWYgdGhlIGRhdGEgbmVjZXNzYXJ5IHRvXG4gKiBkbyB0aGUgdHJhbnNmb3JtYXRpb24gaXMgbm90IHlldCBsb2FkZWQuXG4gKlxuICogQHBhcmFtIHtKdWxpYW5EYXRlfSBkYXRlIFRoZSB0aW1lIGF0IHdoaWNoIHRvIGNvbXB1dGUgdGhlIHJvdGF0aW9uIG1hdHJpeC5cbiAqIEBwYXJhbSB7TWF0cml4M30gW3Jlc3VsdF0gVGhlIG9iamVjdCBvbnRvIHdoaWNoIHRvIHN0b3JlIHRoZSByZXN1bHQuICBJZiB0aGlzIHBhcmFtZXRlciBpc1xuICogICAgICAgICAgICAgICAgICBub3Qgc3BlY2lmaWVkLCBhIG5ldyBpbnN0YW5jZSBpcyBjcmVhdGVkIGFuZCByZXR1cm5lZC5cbiAqIEByZXR1cm5zIHtNYXRyaXgzfSBUaGUgcm90YXRpb24gbWF0cml4LCBvciB1bmRlZmluZWQgaWYgdGhlIGRhdGEgbmVjZXNzYXJ5IHRvIGRvIHRoZVxuICogICAgICAgICAgICAgICAgICAgdHJhbnNmb3JtYXRpb24gaXMgbm90IHlldCBsb2FkZWQuXG4gKlxuICpcbiAqIEBleGFtcGxlXG4gKiBzY2VuZS5wb3N0VXBkYXRlLmFkZEV2ZW50TGlzdGVuZXIoZnVuY3Rpb24oc2NlbmUsIHRpbWUpIHtcbiAqICAgLy8gVmlldyBpbiBJQ1JGLlxuICogICB2YXIgaWNyZlRvRml4ZWQgPSBDZXNpdW0uVHJhbnNmb3Jtcy5jb21wdXRlSWNyZlRvRml4ZWRNYXRyaXgodGltZSk7XG4gKiAgIGlmIChDZXNpdW0uZGVmaW5lZChpY3JmVG9GaXhlZCkpIHtcbiAqICAgICB2YXIgb2Zmc2V0ID0gQ2VzaXVtLkNhcnRlc2lhbjMuY2xvbmUoY2FtZXJhLnBvc2l0aW9uKTtcbiAqICAgICB2YXIgdHJhbnNmb3JtID0gQ2VzaXVtLk1hdHJpeDQuZnJvbVJvdGF0aW9uVHJhbnNsYXRpb24oaWNyZlRvRml4ZWQpO1xuICogICAgIGNhbWVyYS5sb29rQXRUcmFuc2Zvcm0odHJhbnNmb3JtLCBvZmZzZXQpO1xuICogICB9XG4gKiB9KTtcbiAqXG4gKiBAc2VlIFRyYW5zZm9ybXMucHJlbG9hZEljcmZGaXhlZFxuICovXG5UcmFuc2Zvcm1zLmNvbXB1dGVJY3JmVG9GaXhlZE1hdHJpeCA9IGZ1bmN0aW9uIChkYXRlLCByZXN1bHQpIHtcbiAgLy8+PmluY2x1ZGVTdGFydCgnZGVidWcnLCBwcmFnbWFzLmRlYnVnKTtcbiAgaWYgKCFkZWZpbmVkKGRhdGUpKSB7XG4gICAgdGhyb3cgbmV3IERldmVsb3BlckVycm9yKFwiZGF0ZSBpcyByZXF1aXJlZC5cIik7XG4gIH1cbiAgLy8+PmluY2x1ZGVFbmQoJ2RlYnVnJyk7XG4gIGlmICghZGVmaW5lZChyZXN1bHQpKSB7XG4gICAgcmVzdWx0ID0gbmV3IE1hdHJpeDMoKTtcbiAgfVxuXG4gIHZhciBmaXhlZFRvSWNyZk10eCA9IFRyYW5zZm9ybXMuY29tcHV0ZUZpeGVkVG9JY3JmTWF0cml4KGRhdGUsIHJlc3VsdCk7XG4gIGlmICghZGVmaW5lZChmaXhlZFRvSWNyZk10eCkpIHtcbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG5cbiAgcmV0dXJuIE1hdHJpeDMudHJhbnNwb3NlKGZpeGVkVG9JY3JmTXR4LCByZXN1bHQpO1xufTtcblxudmFyIHh5c1NjcmF0Y2ggPSBuZXcgSWF1MjAwNlh5c1NhbXBsZSgwLjAsIDAuMCwgMC4wKTtcbnZhciBlb3BTY3JhdGNoID0gbmV3IEVhcnRoT3JpZW50YXRpb25QYXJhbWV0ZXJzU2FtcGxlKFxuICAwLjAsXG4gIDAuMCxcbiAgMC4wLFxuICAwLjAsXG4gIDAuMCxcbiAgMC4wXG4pO1xudmFyIHJvdGF0aW9uMVNjcmF0Y2ggPSBuZXcgTWF0cml4MygpO1xudmFyIHJvdGF0aW9uMlNjcmF0Y2ggPSBuZXcgTWF0cml4MygpO1xuXG4vKipcbiAqIENvbXB1dGVzIGEgcm90YXRpb24gbWF0cml4IHRvIHRyYW5zZm9ybSBhIHBvaW50IG9yIHZlY3RvciBmcm9tIHRoZSBFYXJ0aC1GaXhlZCBmcmFtZSBheGVzIChJVFJGKVxuICogdG8gdGhlIEludGVybmF0aW9uYWwgQ2VsZXN0aWFsIFJlZmVyZW5jZSBGcmFtZSAoR0NSRi9JQ1JGKSBpbmVydGlhbCBmcmFtZSBheGVzXG4gKiBhdCBhIGdpdmVuIHRpbWUuICBUaGlzIGZ1bmN0aW9uIG1heSByZXR1cm4gdW5kZWZpbmVkIGlmIHRoZSBkYXRhIG5lY2Vzc2FyeSB0b1xuICogZG8gdGhlIHRyYW5zZm9ybWF0aW9uIGlzIG5vdCB5ZXQgbG9hZGVkLlxuICpcbiAqIEBwYXJhbSB7SnVsaWFuRGF0ZX0gZGF0ZSBUaGUgdGltZSBhdCB3aGljaCB0byBjb21wdXRlIHRoZSByb3RhdGlvbiBtYXRyaXguXG4gKiBAcGFyYW0ge01hdHJpeDN9IFtyZXN1bHRdIFRoZSBvYmplY3Qgb250byB3aGljaCB0byBzdG9yZSB0aGUgcmVzdWx0LiAgSWYgdGhpcyBwYXJhbWV0ZXIgaXNcbiAqICAgICAgICAgICAgICAgICAgbm90IHNwZWNpZmllZCwgYSBuZXcgaW5zdGFuY2UgaXMgY3JlYXRlZCBhbmQgcmV0dXJuZWQuXG4gKiBAcmV0dXJucyB7TWF0cml4M30gVGhlIHJvdGF0aW9uIG1hdHJpeCwgb3IgdW5kZWZpbmVkIGlmIHRoZSBkYXRhIG5lY2Vzc2FyeSB0byBkbyB0aGVcbiAqICAgICAgICAgICAgICAgICAgIHRyYW5zZm9ybWF0aW9uIGlzIG5vdCB5ZXQgbG9hZGVkLlxuICpcbiAqXG4gKiBAZXhhbXBsZVxuICogLy8gVHJhbnNmb3JtIGEgcG9pbnQgZnJvbSB0aGUgSUNSRiBheGVzIHRvIHRoZSBGaXhlZCBheGVzLlxuICogdmFyIG5vdyA9IENlc2l1bS5KdWxpYW5EYXRlLm5vdygpO1xuICogdmFyIHBvaW50SW5GaXhlZCA9IENlc2l1bS5DYXJ0ZXNpYW4zLmZyb21EZWdyZWVzKDAuMCwgMC4wKTtcbiAqIHZhciBmaXhlZFRvSWNyZiA9IENlc2l1bS5UcmFuc2Zvcm1zLmNvbXB1dGVJY3JmVG9GaXhlZE1hdHJpeChub3cpO1xuICogdmFyIHBvaW50SW5JbmVydGlhbCA9IG5ldyBDZXNpdW0uQ2FydGVzaWFuMygpO1xuICogaWYgKENlc2l1bS5kZWZpbmVkKGZpeGVkVG9JY3JmKSkge1xuICogICAgIHBvaW50SW5JbmVydGlhbCA9IENlc2l1bS5NYXRyaXgzLm11bHRpcGx5QnlWZWN0b3IoZml4ZWRUb0ljcmYsIHBvaW50SW5GaXhlZCwgcG9pbnRJbkluZXJ0aWFsKTtcbiAqIH1cbiAqXG4gKiBAc2VlIFRyYW5zZm9ybXMucHJlbG9hZEljcmZGaXhlZFxuICovXG5UcmFuc2Zvcm1zLmNvbXB1dGVGaXhlZFRvSWNyZk1hdHJpeCA9IGZ1bmN0aW9uIChkYXRlLCByZXN1bHQpIHtcbiAgLy8+PmluY2x1ZGVTdGFydCgnZGVidWcnLCBwcmFnbWFzLmRlYnVnKTtcbiAgaWYgKCFkZWZpbmVkKGRhdGUpKSB7XG4gICAgdGhyb3cgbmV3IERldmVsb3BlckVycm9yKFwiZGF0ZSBpcyByZXF1aXJlZC5cIik7XG4gIH1cbiAgLy8+PmluY2x1ZGVFbmQoJ2RlYnVnJyk7XG5cbiAgaWYgKCFkZWZpbmVkKHJlc3VsdCkpIHtcbiAgICByZXN1bHQgPSBuZXcgTWF0cml4MygpO1xuICB9XG5cbiAgLy8gQ29tcHV0ZSBwb2xlIHdhbmRlclxuICB2YXIgZW9wID0gVHJhbnNmb3Jtcy5lYXJ0aE9yaWVudGF0aW9uUGFyYW1ldGVycy5jb21wdXRlKGRhdGUsIGVvcFNjcmF0Y2gpO1xuICBpZiAoIWRlZmluZWQoZW9wKSkge1xuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cblxuICAvLyBUaGVyZSBpcyBubyBleHRlcm5hbCBjb252ZXJzaW9uIHRvIFRlcnJlc3RyaWFsIFRpbWUgKFRUKS5cbiAgLy8gU28gdXNlIEludGVybmF0aW9uYWwgQXRvbWljIFRpbWUgKFRBSSkgYW5kIGNvbnZlcnQgdXNpbmcgb2Zmc2V0cy5cbiAgLy8gSGVyZSB3ZSBhcmUgYXNzdW1pbmcgdGhhdCBkYXlUVCBhbmQgc2Vjb25kVFQgYXJlIHBvc2l0aXZlXG4gIHZhciBkYXlUVCA9IGRhdGUuZGF5TnVtYmVyO1xuICAvLyBJdCdzIHBvc3NpYmxlIGhlcmUgdGhhdCBzZWNvbmRUVCBjb3VsZCByb2xsIG92ZXIgODY0MDBcbiAgLy8gVGhpcyBkb2VzIG5vdCBzZWVtIHRvIGFmZmVjdCB0aGUgcHJlY2lzaW9uICh1bml0IHRlc3RzIGNoZWNrIGZvciB0aGlzKVxuICB2YXIgc2Vjb25kVFQgPSBkYXRlLnNlY29uZHNPZkRheSArIHR0TWludXNUYWk7XG5cbiAgdmFyIHh5cyA9IFRyYW5zZm9ybXMuaWF1MjAwNlh5c0RhdGEuY29tcHV0ZVh5c1JhZGlhbnMoXG4gICAgZGF5VFQsXG4gICAgc2Vjb25kVFQsXG4gICAgeHlzU2NyYXRjaFxuICApO1xuICBpZiAoIWRlZmluZWQoeHlzKSkge1xuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cblxuICB2YXIgeCA9IHh5cy54ICsgZW9wLnhQb2xlT2Zmc2V0O1xuICB2YXIgeSA9IHh5cy55ICsgZW9wLnlQb2xlT2Zmc2V0O1xuXG4gIC8vIENvbXB1dGUgWFlTIHJvdGF0aW9uXG4gIHZhciBhID0gMS4wIC8gKDEuMCArIE1hdGguc3FydCgxLjAgLSB4ICogeCAtIHkgKiB5KSk7XG5cbiAgdmFyIHJvdGF0aW9uMSA9IHJvdGF0aW9uMVNjcmF0Y2g7XG4gIHJvdGF0aW9uMVswXSA9IDEuMCAtIGEgKiB4ICogeDtcbiAgcm90YXRpb24xWzNdID0gLWEgKiB4ICogeTtcbiAgcm90YXRpb24xWzZdID0geDtcbiAgcm90YXRpb24xWzFdID0gLWEgKiB4ICogeTtcbiAgcm90YXRpb24xWzRdID0gMSAtIGEgKiB5ICogeTtcbiAgcm90YXRpb24xWzddID0geTtcbiAgcm90YXRpb24xWzJdID0gLXg7XG4gIHJvdGF0aW9uMVs1XSA9IC15O1xuICByb3RhdGlvbjFbOF0gPSAxIC0gYSAqICh4ICogeCArIHkgKiB5KTtcblxuICB2YXIgcm90YXRpb24yID0gTWF0cml4My5mcm9tUm90YXRpb25aKC14eXMucywgcm90YXRpb24yU2NyYXRjaCk7XG4gIHZhciBtYXRyaXhRID0gTWF0cml4My5tdWx0aXBseShyb3RhdGlvbjEsIHJvdGF0aW9uMiwgcm90YXRpb24xU2NyYXRjaCk7XG5cbiAgLy8gU2ltaWxhciB0byBUVCBjb252ZXJzaW9ucyBhYm92ZVxuICAvLyBJdCdzIHBvc3NpYmxlIGhlcmUgdGhhdCBzZWNvbmRUVCBjb3VsZCByb2xsIG92ZXIgODY0MDBcbiAgLy8gVGhpcyBkb2VzIG5vdCBzZWVtIHRvIGFmZmVjdCB0aGUgcHJlY2lzaW9uICh1bml0IHRlc3RzIGNoZWNrIGZvciB0aGlzKVxuICB2YXIgZGF0ZVV0MWRheSA9IGRhdGUuZGF5TnVtYmVyO1xuICB2YXIgZGF0ZVV0MXNlYyA9XG4gICAgZGF0ZS5zZWNvbmRzT2ZEYXkgLSBKdWxpYW5EYXRlLmNvbXB1dGVUYWlNaW51c1V0YyhkYXRlKSArIGVvcC51dDFNaW51c1V0YztcblxuICAvLyBDb21wdXRlIEVhcnRoIHJvdGF0aW9uIGFuZ2xlXG4gIC8vIFRoZSBJRVJTIHN0YW5kYXJkIGZvciBlcmEgaXNcbiAgLy8gICAgZXJhID0gMC43NzkwNTcyNzMyNjQwICsgMS4wMDI3Mzc4MTE5MTEzNTQ0OCAqIFR1XG4gIC8vIHdoZXJlXG4gIC8vICAgIFR1ID0gSnVsaWFuRGF0ZUluVXQxIC0gMjQ1MTU0NS4wXG4gIC8vIEhvd2V2ZXIsIHlvdSBnZXQgbXVjaCBtb3JlIHByZWNpc2lvbiBpZiB5b3UgbWFrZSB0aGUgZm9sbG93aW5nIHNpbXBsaWZpY2F0aW9uXG4gIC8vICAgIGVyYSA9IGEgKyAoMSArIGIpICogKEp1bGlhbkRheU51bWJlciArIEZyYWN0aW9uT2ZEYXkgLSAyNDUxNTQ1KVxuICAvLyAgICBlcmEgPSBhICsgKEp1bGlhbkRheU51bWJlciAtIDI0NTE1NDUpICsgRnJhY3Rpb25PZkRheSArIGIgKEp1bGlhbkRheU51bWJlciAtIDI0NTE1NDUgKyBGcmFjdGlvbk9mRGF5KVxuICAvLyAgICBlcmEgPSBhICsgRnJhY3Rpb25PZkRheSArIGIgKEp1bGlhbkRheU51bWJlciAtIDI0NTE1NDUgKyBGcmFjdGlvbk9mRGF5KVxuICAvLyBzaW5jZSAoSnVsaWFuRGF5TnVtYmVyIC0gMjQ1MTU0NSkgcmVwcmVzZW50cyBhbiBpbnRlZ2VyIG51bWJlciBvZiByZXZvbHV0aW9ucyB3aGljaCB3aWxsIGJlIGRpc2NhcmRlZCBhbnl3YXkuXG4gIHZhciBkYXlzU2luY2VKMjAwMCA9IGRhdGVVdDFkYXkgLSAyNDUxNTQ1O1xuICB2YXIgZnJhY3Rpb25PZkRheSA9IGRhdGVVdDFzZWMgLyBUaW1lQ29uc3RhbnRzLlNFQ09ORFNfUEVSX0RBWTtcbiAgdmFyIGVyYSA9XG4gICAgMC43NzkwNTcyNzMyNjQgK1xuICAgIGZyYWN0aW9uT2ZEYXkgK1xuICAgIDAuMDAyNzM3ODExOTExMzU0NDggKiAoZGF5c1NpbmNlSjIwMDAgKyBmcmFjdGlvbk9mRGF5KTtcbiAgZXJhID0gKGVyYSAlIDEuMCkgKiBDZXNpdW1NYXRoLlRXT19QSTtcblxuICB2YXIgZWFydGhSb3RhdGlvbiA9IE1hdHJpeDMuZnJvbVJvdGF0aW9uWihlcmEsIHJvdGF0aW9uMlNjcmF0Y2gpO1xuXG4gIC8vIHBzZXVkb0ZpeGVkIHRvIElDUkZcbiAgdmFyIHBmVG9JY3JmID0gTWF0cml4My5tdWx0aXBseShtYXRyaXhRLCBlYXJ0aFJvdGF0aW9uLCByb3RhdGlvbjFTY3JhdGNoKTtcblxuICAvLyBDb21wdXRlIHBvbGUgd2FuZGVyIG1hdHJpeFxuICB2YXIgY29zeHAgPSBNYXRoLmNvcyhlb3AueFBvbGVXYW5kZXIpO1xuICB2YXIgY29zeXAgPSBNYXRoLmNvcyhlb3AueVBvbGVXYW5kZXIpO1xuICB2YXIgc2lueHAgPSBNYXRoLnNpbihlb3AueFBvbGVXYW5kZXIpO1xuICB2YXIgc2lueXAgPSBNYXRoLnNpbihlb3AueVBvbGVXYW5kZXIpO1xuXG4gIHZhciB0dHQgPSBkYXlUVCAtIGoyMDAwdHREYXlzICsgc2Vjb25kVFQgLyBUaW1lQ29uc3RhbnRzLlNFQ09ORFNfUEVSX0RBWTtcbiAgdHR0IC89IDM2NTI1LjA7XG5cbiAgLy8gYXBwcm94aW1hdGUgc3AgdmFsdWUgaW4gcmFkXG4gIHZhciBzcCA9ICgtNDcuMGUtNiAqIHR0dCAqIENlc2l1bU1hdGguUkFESUFOU19QRVJfREVHUkVFKSAvIDM2MDAuMDtcbiAgdmFyIGNvc3NwID0gTWF0aC5jb3Moc3ApO1xuICB2YXIgc2luc3AgPSBNYXRoLnNpbihzcCk7XG5cbiAgdmFyIGZUb1BmTXR4ID0gcm90YXRpb24yU2NyYXRjaDtcbiAgZlRvUGZNdHhbMF0gPSBjb3N4cCAqIGNvc3NwO1xuICBmVG9QZk10eFsxXSA9IGNvc3hwICogc2luc3A7XG4gIGZUb1BmTXR4WzJdID0gc2lueHA7XG4gIGZUb1BmTXR4WzNdID0gLWNvc3lwICogc2luc3AgKyBzaW55cCAqIHNpbnhwICogY29zc3A7XG4gIGZUb1BmTXR4WzRdID0gY29zeXAgKiBjb3NzcCArIHNpbnlwICogc2lueHAgKiBzaW5zcDtcbiAgZlRvUGZNdHhbNV0gPSAtc2lueXAgKiBjb3N4cDtcbiAgZlRvUGZNdHhbNl0gPSAtc2lueXAgKiBzaW5zcCAtIGNvc3lwICogc2lueHAgKiBjb3NzcDtcbiAgZlRvUGZNdHhbN10gPSBzaW55cCAqIGNvc3NwIC0gY29zeXAgKiBzaW54cCAqIHNpbnNwO1xuICBmVG9QZk10eFs4XSA9IGNvc3lwICogY29zeHA7XG5cbiAgcmV0dXJuIE1hdHJpeDMubXVsdGlwbHkocGZUb0ljcmYsIGZUb1BmTXR4LCByZXN1bHQpO1xufTtcblxudmFyIHBvaW50VG9XaW5kb3dDb29yZGluYXRlc1RlbXAgPSBuZXcgQ2FydGVzaWFuNCgpO1xuXG4vKipcbiAqIFRyYW5zZm9ybSBhIHBvaW50IGZyb20gbW9kZWwgY29vcmRpbmF0ZXMgdG8gd2luZG93IGNvb3JkaW5hdGVzLlxuICpcbiAqIEBwYXJhbSB7TWF0cml4NH0gbW9kZWxWaWV3UHJvamVjdGlvbk1hdHJpeCBUaGUgNHg0IG1vZGVsLXZpZXctcHJvamVjdGlvbiBtYXRyaXguXG4gKiBAcGFyYW0ge01hdHJpeDR9IHZpZXdwb3J0VHJhbnNmb3JtYXRpb24gVGhlIDR4NCB2aWV3cG9ydCB0cmFuc2Zvcm1hdGlvbi5cbiAqIEBwYXJhbSB7Q2FydGVzaWFuM30gcG9pbnQgVGhlIHBvaW50IHRvIHRyYW5zZm9ybS5cbiAqIEBwYXJhbSB7Q2FydGVzaWFuMn0gW3Jlc3VsdF0gVGhlIG9iamVjdCBvbnRvIHdoaWNoIHRvIHN0b3JlIHRoZSByZXN1bHQuXG4gKiBAcmV0dXJucyB7Q2FydGVzaWFuMn0gVGhlIG1vZGlmaWVkIHJlc3VsdCBwYXJhbWV0ZXIgb3IgYSBuZXcgQ2FydGVzaWFuMiBpbnN0YW5jZSBpZiBub25lIHdhcyBwcm92aWRlZC5cbiAqL1xuVHJhbnNmb3Jtcy5wb2ludFRvV2luZG93Q29vcmRpbmF0ZXMgPSBmdW5jdGlvbiAoXG4gIG1vZGVsVmlld1Byb2plY3Rpb25NYXRyaXgsXG4gIHZpZXdwb3J0VHJhbnNmb3JtYXRpb24sXG4gIHBvaW50LFxuICByZXN1bHRcbikge1xuICByZXN1bHQgPSBUcmFuc2Zvcm1zLnBvaW50VG9HTFdpbmRvd0Nvb3JkaW5hdGVzKFxuICAgIG1vZGVsVmlld1Byb2plY3Rpb25NYXRyaXgsXG4gICAgdmlld3BvcnRUcmFuc2Zvcm1hdGlvbixcbiAgICBwb2ludCxcbiAgICByZXN1bHRcbiAgKTtcbiAgcmVzdWx0LnkgPSAyLjAgKiB2aWV3cG9ydFRyYW5zZm9ybWF0aW9uWzVdIC0gcmVzdWx0Lnk7XG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG4vKipcbiAqIEBwcml2YXRlXG4gKi9cblRyYW5zZm9ybXMucG9pbnRUb0dMV2luZG93Q29vcmRpbmF0ZXMgPSBmdW5jdGlvbiAoXG4gIG1vZGVsVmlld1Byb2plY3Rpb25NYXRyaXgsXG4gIHZpZXdwb3J0VHJhbnNmb3JtYXRpb24sXG4gIHBvaW50LFxuICByZXN1bHRcbikge1xuICAvLz4+aW5jbHVkZVN0YXJ0KCdkZWJ1ZycsIHByYWdtYXMuZGVidWcpO1xuICBpZiAoIWRlZmluZWQobW9kZWxWaWV3UHJvamVjdGlvbk1hdHJpeCkpIHtcbiAgICB0aHJvdyBuZXcgRGV2ZWxvcGVyRXJyb3IoXCJtb2RlbFZpZXdQcm9qZWN0aW9uTWF0cml4IGlzIHJlcXVpcmVkLlwiKTtcbiAgfVxuXG4gIGlmICghZGVmaW5lZCh2aWV3cG9ydFRyYW5zZm9ybWF0aW9uKSkge1xuICAgIHRocm93IG5ldyBEZXZlbG9wZXJFcnJvcihcInZpZXdwb3J0VHJhbnNmb3JtYXRpb24gaXMgcmVxdWlyZWQuXCIpO1xuICB9XG5cbiAgaWYgKCFkZWZpbmVkKHBvaW50KSkge1xuICAgIHRocm93IG5ldyBEZXZlbG9wZXJFcnJvcihcInBvaW50IGlzIHJlcXVpcmVkLlwiKTtcbiAgfVxuICAvLz4+aW5jbHVkZUVuZCgnZGVidWcnKTtcblxuICBpZiAoIWRlZmluZWQocmVzdWx0KSkge1xuICAgIHJlc3VsdCA9IG5ldyBDYXJ0ZXNpYW4yKCk7XG4gIH1cblxuICB2YXIgdG1wID0gcG9pbnRUb1dpbmRvd0Nvb3JkaW5hdGVzVGVtcDtcblxuICBNYXRyaXg0Lm11bHRpcGx5QnlWZWN0b3IoXG4gICAgbW9kZWxWaWV3UHJvamVjdGlvbk1hdHJpeCxcbiAgICBDYXJ0ZXNpYW40LmZyb21FbGVtZW50cyhwb2ludC54LCBwb2ludC55LCBwb2ludC56LCAxLCB0bXApLFxuICAgIHRtcFxuICApO1xuICBDYXJ0ZXNpYW40Lm11bHRpcGx5QnlTY2FsYXIodG1wLCAxLjAgLyB0bXAudywgdG1wKTtcbiAgTWF0cml4NC5tdWx0aXBseUJ5VmVjdG9yKHZpZXdwb3J0VHJhbnNmb3JtYXRpb24sIHRtcCwgdG1wKTtcbiAgcmV0dXJuIENhcnRlc2lhbjIuZnJvbUNhcnRlc2lhbjQodG1wLCByZXN1bHQpO1xufTtcblxudmFyIG5vcm1hbFNjcmF0Y2ggPSBuZXcgQ2FydGVzaWFuMygpO1xudmFyIHJpZ2h0U2NyYXRjaCA9IG5ldyBDYXJ0ZXNpYW4zKCk7XG52YXIgdXBTY3JhdGNoID0gbmV3IENhcnRlc2lhbjMoKTtcblxuLyoqXG4gKiBUcmFuc2Zvcm0gYSBwb3NpdGlvbiBhbmQgdmVsb2NpdHkgdG8gYSByb3RhdGlvbiBtYXRyaXguXG4gKlxuICogQHBhcmFtIHtDYXJ0ZXNpYW4zfSBwb3NpdGlvbiBUaGUgcG9zaXRpb24gdG8gdHJhbnNmb3JtLlxuICogQHBhcmFtIHtDYXJ0ZXNpYW4zfSB2ZWxvY2l0eSBUaGUgdmVsb2NpdHkgdmVjdG9yIHRvIHRyYW5zZm9ybS5cbiAqIEBwYXJhbSB7RWxsaXBzb2lkfSBbZWxsaXBzb2lkPUVsbGlwc29pZC5XR1M4NF0gVGhlIGVsbGlwc29pZCB3aG9zZSBmaXhlZCBmcmFtZSBpcyB1c2VkIGluIHRoZSB0cmFuc2Zvcm1hdGlvbi5cbiAqIEBwYXJhbSB7TWF0cml4M30gW3Jlc3VsdF0gVGhlIG9iamVjdCBvbnRvIHdoaWNoIHRvIHN0b3JlIHRoZSByZXN1bHQuXG4gKiBAcmV0dXJucyB7TWF0cml4M30gVGhlIG1vZGlmaWVkIHJlc3VsdCBwYXJhbWV0ZXIgb3IgYSBuZXcgTWF0cml4MyBpbnN0YW5jZSBpZiBub25lIHdhcyBwcm92aWRlZC5cbiAqL1xuVHJhbnNmb3Jtcy5yb3RhdGlvbk1hdHJpeEZyb21Qb3NpdGlvblZlbG9jaXR5ID0gZnVuY3Rpb24gKFxuICBwb3NpdGlvbixcbiAgdmVsb2NpdHksXG4gIGVsbGlwc29pZCxcbiAgcmVzdWx0XG4pIHtcbiAgLy8+PmluY2x1ZGVTdGFydCgnZGVidWcnLCBwcmFnbWFzLmRlYnVnKTtcbiAgaWYgKCFkZWZpbmVkKHBvc2l0aW9uKSkge1xuICAgIHRocm93IG5ldyBEZXZlbG9wZXJFcnJvcihcInBvc2l0aW9uIGlzIHJlcXVpcmVkLlwiKTtcbiAgfVxuXG4gIGlmICghZGVmaW5lZCh2ZWxvY2l0eSkpIHtcbiAgICB0aHJvdyBuZXcgRGV2ZWxvcGVyRXJyb3IoXCJ2ZWxvY2l0eSBpcyByZXF1aXJlZC5cIik7XG4gIH1cbiAgLy8+PmluY2x1ZGVFbmQoJ2RlYnVnJyk7XG5cbiAgdmFyIG5vcm1hbCA9IGRlZmF1bHRWYWx1ZShlbGxpcHNvaWQsIEVsbGlwc29pZC5XR1M4NCkuZ2VvZGV0aWNTdXJmYWNlTm9ybWFsKFxuICAgIHBvc2l0aW9uLFxuICAgIG5vcm1hbFNjcmF0Y2hcbiAgKTtcbiAgdmFyIHJpZ2h0ID0gQ2FydGVzaWFuMy5jcm9zcyh2ZWxvY2l0eSwgbm9ybWFsLCByaWdodFNjcmF0Y2gpO1xuXG4gIGlmIChDYXJ0ZXNpYW4zLmVxdWFsc0Vwc2lsb24ocmlnaHQsIENhcnRlc2lhbjMuWkVSTywgQ2VzaXVtTWF0aC5FUFNJTE9ONikpIHtcbiAgICByaWdodCA9IENhcnRlc2lhbjMuY2xvbmUoQ2FydGVzaWFuMy5VTklUX1gsIHJpZ2h0KTtcbiAgfVxuXG4gIHZhciB1cCA9IENhcnRlc2lhbjMuY3Jvc3MocmlnaHQsIHZlbG9jaXR5LCB1cFNjcmF0Y2gpO1xuICBDYXJ0ZXNpYW4zLm5vcm1hbGl6ZSh1cCwgdXApO1xuICBDYXJ0ZXNpYW4zLmNyb3NzKHZlbG9jaXR5LCB1cCwgcmlnaHQpO1xuICBDYXJ0ZXNpYW4zLm5lZ2F0ZShyaWdodCwgcmlnaHQpO1xuICBDYXJ0ZXNpYW4zLm5vcm1hbGl6ZShyaWdodCwgcmlnaHQpO1xuXG4gIGlmICghZGVmaW5lZChyZXN1bHQpKSB7XG4gICAgcmVzdWx0ID0gbmV3IE1hdHJpeDMoKTtcbiAgfVxuXG4gIHJlc3VsdFswXSA9IHZlbG9jaXR5Lng7XG4gIHJlc3VsdFsxXSA9IHZlbG9jaXR5Lnk7XG4gIHJlc3VsdFsyXSA9IHZlbG9jaXR5Lno7XG4gIHJlc3VsdFszXSA9IHJpZ2h0Lng7XG4gIHJlc3VsdFs0XSA9IHJpZ2h0Lnk7XG4gIHJlc3VsdFs1XSA9IHJpZ2h0Lno7XG4gIHJlc3VsdFs2XSA9IHVwLng7XG4gIHJlc3VsdFs3XSA9IHVwLnk7XG4gIHJlc3VsdFs4XSA9IHVwLno7XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbnZhciBzd2l6emxlTWF0cml4ID0gbmV3IE1hdHJpeDQoXG4gIDAuMCxcbiAgMC4wLFxuICAxLjAsXG4gIDAuMCxcbiAgMS4wLFxuICAwLjAsXG4gIDAuMCxcbiAgMC4wLFxuICAwLjAsXG4gIDEuMCxcbiAgMC4wLFxuICAwLjAsXG4gIDAuMCxcbiAgMC4wLFxuICAwLjAsXG4gIDEuMFxuKTtcblxudmFyIHNjcmF0Y2hDYXJ0b2dyYXBoaWMgPSBuZXcgQ2FydG9ncmFwaGljKCk7XG52YXIgc2NyYXRjaENhcnRlc2lhbjNQcm9qZWN0aW9uID0gbmV3IENhcnRlc2lhbjMoKTtcbnZhciBzY3JhdGNoQ2VudGVyID0gbmV3IENhcnRlc2lhbjMoKTtcbnZhciBzY3JhdGNoUm90YXRpb24gPSBuZXcgTWF0cml4MygpO1xudmFyIHNjcmF0Y2hGcm9tRU5VID0gbmV3IE1hdHJpeDQoKTtcbnZhciBzY3JhdGNoVG9FTlUgPSBuZXcgTWF0cml4NCgpO1xuXG4vKipcbiAqIEBwcml2YXRlXG4gKi9cblRyYW5zZm9ybXMuYmFzaXNUbzJEID0gZnVuY3Rpb24gKHByb2plY3Rpb24sIG1hdHJpeCwgcmVzdWx0KSB7XG4gIC8vPj5pbmNsdWRlU3RhcnQoJ2RlYnVnJywgcHJhZ21hcy5kZWJ1Zyk7XG4gIGlmICghZGVmaW5lZChwcm9qZWN0aW9uKSkge1xuICAgIHRocm93IG5ldyBEZXZlbG9wZXJFcnJvcihcInByb2plY3Rpb24gaXMgcmVxdWlyZWQuXCIpO1xuICB9XG4gIGlmICghZGVmaW5lZChtYXRyaXgpKSB7XG4gICAgdGhyb3cgbmV3IERldmVsb3BlckVycm9yKFwibWF0cml4IGlzIHJlcXVpcmVkLlwiKTtcbiAgfVxuICBpZiAoIWRlZmluZWQocmVzdWx0KSkge1xuICAgIHRocm93IG5ldyBEZXZlbG9wZXJFcnJvcihcInJlc3VsdCBpcyByZXF1aXJlZC5cIik7XG4gIH1cbiAgLy8+PmluY2x1ZGVFbmQoJ2RlYnVnJyk7XG5cbiAgdmFyIHJ0Y0NlbnRlciA9IE1hdHJpeDQuZ2V0VHJhbnNsYXRpb24obWF0cml4LCBzY3JhdGNoQ2VudGVyKTtcbiAgdmFyIGVsbGlwc29pZCA9IHByb2plY3Rpb24uZWxsaXBzb2lkO1xuXG4gIC8vIEdldCB0aGUgMkQgQ2VudGVyXG4gIHZhciBjYXJ0b2dyYXBoaWMgPSBlbGxpcHNvaWQuY2FydGVzaWFuVG9DYXJ0b2dyYXBoaWMoXG4gICAgcnRjQ2VudGVyLFxuICAgIHNjcmF0Y2hDYXJ0b2dyYXBoaWNcbiAgKTtcbiAgdmFyIHByb2plY3RlZFBvc2l0aW9uID0gcHJvamVjdGlvbi5wcm9qZWN0KFxuICAgIGNhcnRvZ3JhcGhpYyxcbiAgICBzY3JhdGNoQ2FydGVzaWFuM1Byb2plY3Rpb25cbiAgKTtcbiAgQ2FydGVzaWFuMy5mcm9tRWxlbWVudHMoXG4gICAgcHJvamVjdGVkUG9zaXRpb24ueixcbiAgICBwcm9qZWN0ZWRQb3NpdGlvbi54LFxuICAgIHByb2plY3RlZFBvc2l0aW9uLnksXG4gICAgcHJvamVjdGVkUG9zaXRpb25cbiAgKTtcblxuICAvLyBBc3N1bWluZyB0aGUgaW5zdGFuY2UgYXJlIHBvc2l0aW9uZWQgaW4gV0dTODQsIGludmVydCB0aGUgV0dTODQgdHJhbnNmb3JtIHRvIGdldCB0aGUgbG9jYWwgdHJhbnNmb3JtIGFuZCB0aGVuIGNvbnZlcnQgdG8gMkRcbiAgdmFyIGZyb21FTlUgPSBUcmFuc2Zvcm1zLmVhc3ROb3J0aFVwVG9GaXhlZEZyYW1lKFxuICAgIHJ0Y0NlbnRlcixcbiAgICBlbGxpcHNvaWQsXG4gICAgc2NyYXRjaEZyb21FTlVcbiAgKTtcbiAgdmFyIHRvRU5VID0gTWF0cml4NC5pbnZlcnNlVHJhbnNmb3JtYXRpb24oZnJvbUVOVSwgc2NyYXRjaFRvRU5VKTtcbiAgdmFyIHJvdGF0aW9uID0gTWF0cml4NC5nZXRNYXRyaXgzKG1hdHJpeCwgc2NyYXRjaFJvdGF0aW9uKTtcbiAgdmFyIGxvY2FsID0gTWF0cml4NC5tdWx0aXBseUJ5TWF0cml4Myh0b0VOVSwgcm90YXRpb24sIHJlc3VsdCk7XG4gIE1hdHJpeDQubXVsdGlwbHkoc3dpenpsZU1hdHJpeCwgbG9jYWwsIHJlc3VsdCk7IC8vIFN3YXAgeCwgeSwgeiBmb3IgMkRcbiAgTWF0cml4NC5zZXRUcmFuc2xhdGlvbihyZXN1bHQsIHByb2plY3RlZFBvc2l0aW9uLCByZXN1bHQpOyAvLyBVc2UgdGhlIHByb2plY3RlZCBjZW50ZXJcblxuICByZXR1cm4gcmVzdWx0O1xufTtcblxuLyoqXG4gKiBAcHJpdmF0ZVxuICovXG5UcmFuc2Zvcm1zLndnczg0VG8yRE1vZGVsTWF0cml4ID0gZnVuY3Rpb24gKHByb2plY3Rpb24sIGNlbnRlciwgcmVzdWx0KSB7XG4gIC8vPj5pbmNsdWRlU3RhcnQoJ2RlYnVnJywgcHJhZ21hcy5kZWJ1Zyk7XG4gIGlmICghZGVmaW5lZChwcm9qZWN0aW9uKSkge1xuICAgIHRocm93IG5ldyBEZXZlbG9wZXJFcnJvcihcInByb2plY3Rpb24gaXMgcmVxdWlyZWQuXCIpO1xuICB9XG4gIGlmICghZGVmaW5lZChjZW50ZXIpKSB7XG4gICAgdGhyb3cgbmV3IERldmVsb3BlckVycm9yKFwiY2VudGVyIGlzIHJlcXVpcmVkLlwiKTtcbiAgfVxuICBpZiAoIWRlZmluZWQocmVzdWx0KSkge1xuICAgIHRocm93IG5ldyBEZXZlbG9wZXJFcnJvcihcInJlc3VsdCBpcyByZXF1aXJlZC5cIik7XG4gIH1cbiAgLy8+PmluY2x1ZGVFbmQoJ2RlYnVnJyk7XG5cbiAgdmFyIGVsbGlwc29pZCA9IHByb2plY3Rpb24uZWxsaXBzb2lkO1xuXG4gIHZhciBmcm9tRU5VID0gVHJhbnNmb3Jtcy5lYXN0Tm9ydGhVcFRvRml4ZWRGcmFtZShcbiAgICBjZW50ZXIsXG4gICAgZWxsaXBzb2lkLFxuICAgIHNjcmF0Y2hGcm9tRU5VXG4gICk7XG4gIHZhciB0b0VOVSA9IE1hdHJpeDQuaW52ZXJzZVRyYW5zZm9ybWF0aW9uKGZyb21FTlUsIHNjcmF0Y2hUb0VOVSk7XG5cbiAgdmFyIGNhcnRvZ3JhcGhpYyA9IGVsbGlwc29pZC5jYXJ0ZXNpYW5Ub0NhcnRvZ3JhcGhpYyhcbiAgICBjZW50ZXIsXG4gICAgc2NyYXRjaENhcnRvZ3JhcGhpY1xuICApO1xuICB2YXIgcHJvamVjdGVkUG9zaXRpb24gPSBwcm9qZWN0aW9uLnByb2plY3QoXG4gICAgY2FydG9ncmFwaGljLFxuICAgIHNjcmF0Y2hDYXJ0ZXNpYW4zUHJvamVjdGlvblxuICApO1xuICBDYXJ0ZXNpYW4zLmZyb21FbGVtZW50cyhcbiAgICBwcm9qZWN0ZWRQb3NpdGlvbi56LFxuICAgIHByb2plY3RlZFBvc2l0aW9uLngsXG4gICAgcHJvamVjdGVkUG9zaXRpb24ueSxcbiAgICBwcm9qZWN0ZWRQb3NpdGlvblxuICApO1xuXG4gIHZhciB0cmFuc2xhdGlvbiA9IE1hdHJpeDQuZnJvbVRyYW5zbGF0aW9uKHByb2plY3RlZFBvc2l0aW9uLCBzY3JhdGNoRnJvbUVOVSk7XG4gIE1hdHJpeDQubXVsdGlwbHkoc3dpenpsZU1hdHJpeCwgdG9FTlUsIHJlc3VsdCk7XG4gIE1hdHJpeDQubXVsdGlwbHkodHJhbnNsYXRpb24sIHJlc3VsdCwgcmVzdWx0KTtcblxuICByZXR1cm4gcmVzdWx0O1xufTtcbmV4cG9ydCBkZWZhdWx0IFRyYW5zZm9ybXM7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///95555\n')},72043:function(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__){eval('/* harmony import */ var _Cartesian3_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(60216);\n/* harmony import */ var _defaultValue_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(62200);\n/* harmony import */ var _defined_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(82982);\n/* harmony import */ var _Quaternion_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(87811);\n\n\n\n\n\nvar defaultScale = new _Cartesian3_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .Z(1.0, 1.0, 1.0);\nvar defaultTranslation = _Cartesian3_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].ZERO */ .Z.ZERO;\nvar defaultRotation = _Quaternion_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"].IDENTITY */ .Z.IDENTITY;\n\n/**\n * An affine transformation defined by a translation, rotation, and scale.\n * @alias TranslationRotationScale\n * @constructor\n *\n * @param {Cartesian3} [translation=Cartesian3.ZERO] A {@link Cartesian3} specifying the (x, y, z) translation to apply to the node.\n * @param {Quaternion} [rotation=Quaternion.IDENTITY] A {@link Quaternion} specifying the (x, y, z, w) rotation to apply to the node.\n * @param {Cartesian3} [scale=new Cartesian3(1.0, 1.0, 1.0)] A {@link Cartesian3} specifying the (x, y, z) scaling to apply to the node.\n */\nfunction TranslationRotationScale(translation, rotation, scale) {\n  /**\n   * Gets or sets the (x, y, z) translation to apply to the node.\n   * @type {Cartesian3}\n   * @default Cartesian3.ZERO\n   */\n  this.translation = _Cartesian3_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].clone */ .Z.clone(\n    (0,_defaultValue_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .Z)(translation, defaultTranslation)\n  );\n\n  /**\n   * Gets or sets the (x, y, z, w) rotation to apply to the node.\n   * @type {Quaternion}\n   * @default Quaternion.IDENTITY\n   */\n  this.rotation = _Quaternion_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"].clone */ .Z.clone((0,_defaultValue_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .Z)(rotation, defaultRotation));\n\n  /**\n   * Gets or sets the (x, y, z) scaling to apply to the node.\n   * @type {Cartesian3}\n   * @default new Cartesian3(1.0, 1.0, 1.0)\n   */\n  this.scale = _Cartesian3_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].clone */ .Z.clone((0,_defaultValue_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .Z)(scale, defaultScale));\n}\n\n/**\n * Compares this instance against the provided instance and returns\n * <code>true</code> if they are equal, <code>false</code> otherwise.\n *\n * @param {TranslationRotationScale} [right] The right hand side TranslationRotationScale.\n * @returns {Boolean} <code>true</code> if they are equal, <code>false</code> otherwise.\n */\nTranslationRotationScale.prototype.equals = function (right) {\n  return (\n    this === right ||\n    ((0,_defined_js__WEBPACK_IMPORTED_MODULE_3__/* ["default"] */ .Z)(right) &&\n      _Cartesian3_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].equals */ .Z.equals(this.translation, right.translation) &&\n      _Quaternion_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"].equals */ .Z.equals(this.rotation, right.rotation) &&\n      _Cartesian3_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].equals */ .Z.equals(this.scale, right.scale))\n  );\n};\n/* harmony default export */ __webpack_exports__["Z"] = (TranslationRotationScale);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNzIwNDMuanMiLCJtYXBwaW5ncyI6Ijs7OztBQUF5QztBQUNJO0FBQ1Y7QUFDTTs7QUFFekMsdUJBQXVCLCtEQUFVO0FBQ2pDLHlCQUF5Qix5RUFBZTtBQUN4QyxzQkFBc0IsaUZBQW1COztBQUV6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxZQUFZLGlDQUFpQyxrQkFBa0I7QUFDMUUsV0FBVyxZQUFZLGtDQUFrQyxrQkFBa0I7QUFDM0UsV0FBVyxZQUFZLHlDQUF5QyxrQkFBa0I7QUFDbEY7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBLHFCQUFxQiwyRUFBZ0I7QUFDckMsSUFBSSxxRUFBWTtBQUNoQjs7QUFFQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQSxrQkFBa0IsMkVBQWdCLENBQUMscUVBQVk7O0FBRS9DO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBLGVBQWUsMkVBQWdCLENBQUMscUVBQVk7QUFDNUM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLDBCQUEwQjtBQUNyQyxhQUFhLFNBQVM7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLLGdFQUFPO0FBQ1osTUFBTSw2RUFBaUI7QUFDdkIsTUFBTSw2RUFBaUI7QUFDdkIsTUFBTSw2RUFBaUI7QUFDdkI7QUFDQTtBQUNBLHlEQUFlLHdCQUF3QixFQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdnVlMy13ZWJwYWNrNS8uL25vZGVfbW9kdWxlcy9jZXNpdW0vU291cmNlL0NvcmUvVHJhbnNsYXRpb25Sb3RhdGlvblNjYWxlLmpzP2Q3ZjMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IENhcnRlc2lhbjMgZnJvbSBcIi4vQ2FydGVzaWFuMy5qc1wiO1xuaW1wb3J0IGRlZmF1bHRWYWx1ZSBmcm9tIFwiLi9kZWZhdWx0VmFsdWUuanNcIjtcbmltcG9ydCBkZWZpbmVkIGZyb20gXCIuL2RlZmluZWQuanNcIjtcbmltcG9ydCBRdWF0ZXJuaW9uIGZyb20gXCIuL1F1YXRlcm5pb24uanNcIjtcblxudmFyIGRlZmF1bHRTY2FsZSA9IG5ldyBDYXJ0ZXNpYW4zKDEuMCwgMS4wLCAxLjApO1xudmFyIGRlZmF1bHRUcmFuc2xhdGlvbiA9IENhcnRlc2lhbjMuWkVSTztcbnZhciBkZWZhdWx0Um90YXRpb24gPSBRdWF0ZXJuaW9uLklERU5USVRZO1xuXG4vKipcbiAqIEFuIGFmZmluZSB0cmFuc2Zvcm1hdGlvbiBkZWZpbmVkIGJ5IGEgdHJhbnNsYXRpb24sIHJvdGF0aW9uLCBhbmQgc2NhbGUuXG4gKiBAYWxpYXMgVHJhbnNsYXRpb25Sb3RhdGlvblNjYWxlXG4gKiBAY29uc3RydWN0b3JcbiAqXG4gKiBAcGFyYW0ge0NhcnRlc2lhbjN9IFt0cmFuc2xhdGlvbj1DYXJ0ZXNpYW4zLlpFUk9dIEEge0BsaW5rIENhcnRlc2lhbjN9IHNwZWNpZnlpbmcgdGhlICh4LCB5LCB6KSB0cmFuc2xhdGlvbiB0byBhcHBseSB0byB0aGUgbm9kZS5cbiAqIEBwYXJhbSB7UXVhdGVybmlvbn0gW3JvdGF0aW9uPVF1YXRlcm5pb24uSURFTlRJVFldIEEge0BsaW5rIFF1YXRlcm5pb259IHNwZWNpZnlpbmcgdGhlICh4LCB5LCB6LCB3KSByb3RhdGlvbiB0byBhcHBseSB0byB0aGUgbm9kZS5cbiAqIEBwYXJhbSB7Q2FydGVzaWFuM30gW3NjYWxlPW5ldyBDYXJ0ZXNpYW4zKDEuMCwgMS4wLCAxLjApXSBBIHtAbGluayBDYXJ0ZXNpYW4zfSBzcGVjaWZ5aW5nIHRoZSAoeCwgeSwgeikgc2NhbGluZyB0byBhcHBseSB0byB0aGUgbm9kZS5cbiAqL1xuZnVuY3Rpb24gVHJhbnNsYXRpb25Sb3RhdGlvblNjYWxlKHRyYW5zbGF0aW9uLCByb3RhdGlvbiwgc2NhbGUpIHtcbiAgLyoqXG4gICAqIEdldHMgb3Igc2V0cyB0aGUgKHgsIHksIHopIHRyYW5zbGF0aW9uIHRvIGFwcGx5IHRvIHRoZSBub2RlLlxuICAgKiBAdHlwZSB7Q2FydGVzaWFuM31cbiAgICogQGRlZmF1bHQgQ2FydGVzaWFuMy5aRVJPXG4gICAqL1xuICB0aGlzLnRyYW5zbGF0aW9uID0gQ2FydGVzaWFuMy5jbG9uZShcbiAgICBkZWZhdWx0VmFsdWUodHJhbnNsYXRpb24sIGRlZmF1bHRUcmFuc2xhdGlvbilcbiAgKTtcblxuICAvKipcbiAgICogR2V0cyBvciBzZXRzIHRoZSAoeCwgeSwgeiwgdykgcm90YXRpb24gdG8gYXBwbHkgdG8gdGhlIG5vZGUuXG4gICAqIEB0eXBlIHtRdWF0ZXJuaW9ufVxuICAgKiBAZGVmYXVsdCBRdWF0ZXJuaW9uLklERU5USVRZXG4gICAqL1xuICB0aGlzLnJvdGF0aW9uID0gUXVhdGVybmlvbi5jbG9uZShkZWZhdWx0VmFsdWUocm90YXRpb24sIGRlZmF1bHRSb3RhdGlvbikpO1xuXG4gIC8qKlxuICAgKiBHZXRzIG9yIHNldHMgdGhlICh4LCB5LCB6KSBzY2FsaW5nIHRvIGFwcGx5IHRvIHRoZSBub2RlLlxuICAgKiBAdHlwZSB7Q2FydGVzaWFuM31cbiAgICogQGRlZmF1bHQgbmV3IENhcnRlc2lhbjMoMS4wLCAxLjAsIDEuMClcbiAgICovXG4gIHRoaXMuc2NhbGUgPSBDYXJ0ZXNpYW4zLmNsb25lKGRlZmF1bHRWYWx1ZShzY2FsZSwgZGVmYXVsdFNjYWxlKSk7XG59XG5cbi8qKlxuICogQ29tcGFyZXMgdGhpcyBpbnN0YW5jZSBhZ2FpbnN0IHRoZSBwcm92aWRlZCBpbnN0YW5jZSBhbmQgcmV0dXJuc1xuICogPGNvZGU+dHJ1ZTwvY29kZT4gaWYgdGhleSBhcmUgZXF1YWwsIDxjb2RlPmZhbHNlPC9jb2RlPiBvdGhlcndpc2UuXG4gKlxuICogQHBhcmFtIHtUcmFuc2xhdGlvblJvdGF0aW9uU2NhbGV9IFtyaWdodF0gVGhlIHJpZ2h0IGhhbmQgc2lkZSBUcmFuc2xhdGlvblJvdGF0aW9uU2NhbGUuXG4gKiBAcmV0dXJucyB7Qm9vbGVhbn0gPGNvZGU+dHJ1ZTwvY29kZT4gaWYgdGhleSBhcmUgZXF1YWwsIDxjb2RlPmZhbHNlPC9jb2RlPiBvdGhlcndpc2UuXG4gKi9cblRyYW5zbGF0aW9uUm90YXRpb25TY2FsZS5wcm90b3R5cGUuZXF1YWxzID0gZnVuY3Rpb24gKHJpZ2h0KSB7XG4gIHJldHVybiAoXG4gICAgdGhpcyA9PT0gcmlnaHQgfHxcbiAgICAoZGVmaW5lZChyaWdodCkgJiZcbiAgICAgIENhcnRlc2lhbjMuZXF1YWxzKHRoaXMudHJhbnNsYXRpb24sIHJpZ2h0LnRyYW5zbGF0aW9uKSAmJlxuICAgICAgUXVhdGVybmlvbi5lcXVhbHModGhpcy5yb3RhdGlvbiwgcmlnaHQucm90YXRpb24pICYmXG4gICAgICBDYXJ0ZXNpYW4zLmVxdWFscyh0aGlzLnNjYWxlLCByaWdodC5zY2FsZSkpXG4gICk7XG59O1xuZXhwb3J0IGRlZmF1bHQgVHJhbnNsYXRpb25Sb3RhdGlvblNjYWxlO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///72043\n')},72579:function(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__){eval('/* harmony import */ var _Cartesian3_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(60216);\n/* harmony import */ var _defined_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(82982);\n/* harmony import */ var _DeveloperError_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(12572);\n\n\n\n\n/**\n * Uses the Tridiagonal Matrix Algorithm, also known as the Thomas Algorithm, to solve\n * a system of linear equations where the coefficient matrix is a tridiagonal matrix.\n *\n * @namespace TridiagonalSystemSolver\n */\nvar TridiagonalSystemSolver = {};\n\n/**\n * Solves a tridiagonal system of linear equations.\n *\n * @param {Number[]} diagonal An array with length <code>n</code> that contains the diagonal of the coefficient matrix.\n * @param {Number[]} lower An array with length <code>n - 1</code> that contains the lower diagonal of the coefficient matrix.\n * @param {Number[]} upper An array with length <code>n - 1</code> that contains the upper diagonal of the coefficient matrix.\n * @param {Cartesian3[]} right An array of Cartesians with length <code>n</code> that is the right side of the system of equations.\n *\n * @exception {DeveloperError} diagonal and right must have the same lengths.\n * @exception {DeveloperError} lower and upper must have the same lengths.\n * @exception {DeveloperError} lower and upper must be one less than the length of diagonal.\n *\n * @performance Linear time.\n *\n * @example\n * var lowerDiagonal = [1.0, 1.0, 1.0, 1.0];\n * var diagonal = [2.0, 4.0, 4.0, 4.0, 2.0];\n * var upperDiagonal = [1.0, 1.0, 1.0, 1.0];\n * var rightHandSide = [\n *     new Cesium.Cartesian3(410757.0, -1595711.0, 1375302.0),\n *     new Cesium.Cartesian3(-5986705.0, -2190640.0, 1099600.0),\n *     new Cesium.Cartesian3(-12593180.0, 288588.0, -1755549.0),\n *     new Cesium.Cartesian3(-5349898.0, 2457005.0, -2685438.0),\n *     new Cesium.Cartesian3(845820.0, 1573488.0, -1205591.0)\n * ];\n *\n * var solution = Cesium.TridiagonalSystemSolver.solve(lowerDiagonal, diagonal, upperDiagonal, rightHandSide);\n *\n * @returns {Cartesian3[]} An array of Cartesians with length <code>n</code> that is the solution to the tridiagonal system of equations.\n */\nTridiagonalSystemSolver.solve = function (lower, diagonal, upper, right) {\n  //>>includeStart(\'debug\', pragmas.debug);\n  if (!(0,_defined_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"] */ .Z)(lower) || !(lower instanceof Array)) {\n    throw new _DeveloperError_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .Z("The array lower is required.");\n  }\n  if (!(0,_defined_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"] */ .Z)(diagonal) || !(diagonal instanceof Array)) {\n    throw new _DeveloperError_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .Z("The array diagonal is required.");\n  }\n  if (!(0,_defined_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"] */ .Z)(upper) || !(upper instanceof Array)) {\n    throw new _DeveloperError_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .Z("The array upper is required.");\n  }\n  if (!(0,_defined_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"] */ .Z)(right) || !(right instanceof Array)) {\n    throw new _DeveloperError_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .Z("The array right is required.");\n  }\n  if (diagonal.length !== right.length) {\n    throw new _DeveloperError_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .Z("diagonal and right must have the same lengths.");\n  }\n  if (lower.length !== upper.length) {\n    throw new _DeveloperError_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .Z("lower and upper must have the same lengths.");\n  } else if (lower.length !== diagonal.length - 1) {\n    throw new _DeveloperError_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .Z(\n      "lower and upper must be one less than the length of diagonal."\n    );\n  }\n  //>>includeEnd(\'debug\');\n\n  var c = new Array(upper.length);\n  var d = new Array(right.length);\n  var x = new Array(right.length);\n\n  var i;\n  for (i = 0; i < d.length; i++) {\n    d[i] = new _Cartesian3_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .Z();\n    x[i] = new _Cartesian3_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .Z();\n  }\n\n  c[0] = upper[0] / diagonal[0];\n  d[0] = _Cartesian3_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].multiplyByScalar */ .Z.multiplyByScalar(right[0], 1.0 / diagonal[0], d[0]);\n\n  var scalar;\n  for (i = 1; i < c.length; ++i) {\n    scalar = 1.0 / (diagonal[i] - c[i - 1] * lower[i - 1]);\n    c[i] = upper[i] * scalar;\n    d[i] = _Cartesian3_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].subtract */ .Z.subtract(\n      right[i],\n      _Cartesian3_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].multiplyByScalar */ .Z.multiplyByScalar(d[i - 1], lower[i - 1], d[i]),\n      d[i]\n    );\n    d[i] = _Cartesian3_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].multiplyByScalar */ .Z.multiplyByScalar(d[i], scalar, d[i]);\n  }\n\n  scalar = 1.0 / (diagonal[i] - c[i - 1] * lower[i - 1]);\n  d[i] = _Cartesian3_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].subtract */ .Z.subtract(\n    right[i],\n    _Cartesian3_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].multiplyByScalar */ .Z.multiplyByScalar(d[i - 1], lower[i - 1], d[i]),\n    d[i]\n  );\n  d[i] = _Cartesian3_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].multiplyByScalar */ .Z.multiplyByScalar(d[i], scalar, d[i]);\n\n  x[x.length - 1] = d[d.length - 1];\n  for (i = x.length - 2; i >= 0; --i) {\n    x[i] = _Cartesian3_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].subtract */ .Z.subtract(\n      d[i],\n      _Cartesian3_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].multiplyByScalar */ .Z.multiplyByScalar(x[i + 1], c[i], x[i]),\n      x[i]\n    );\n  }\n\n  return x;\n};\n/* harmony default export */ __webpack_exports__["Z"] = (TridiagonalSystemSolver);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNzI1NzkuanMiLCJtYXBwaW5ncyI6Ijs7O0FBQXlDO0FBQ047QUFDYzs7QUFFakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxVQUFVO0FBQ3JCLFdBQVcsVUFBVTtBQUNyQixXQUFXLFVBQVU7QUFDckIsV0FBVyxjQUFjO0FBQ3pCO0FBQ0EsZUFBZSxnQkFBZ0I7QUFDL0IsZUFBZSxnQkFBZ0I7QUFDL0IsZUFBZSxnQkFBZ0I7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsY0FBYztBQUMzQjtBQUNBO0FBQ0E7QUFDQSxPQUFPLGdFQUFPO0FBQ2QsY0FBYyxtRUFBYztBQUM1QjtBQUNBLE9BQU8sZ0VBQU87QUFDZCxjQUFjLG1FQUFjO0FBQzVCO0FBQ0EsT0FBTyxnRUFBTztBQUNkLGNBQWMsbUVBQWM7QUFDNUI7QUFDQSxPQUFPLGdFQUFPO0FBQ2QsY0FBYyxtRUFBYztBQUM1QjtBQUNBO0FBQ0EsY0FBYyxtRUFBYztBQUM1QjtBQUNBO0FBQ0EsY0FBYyxtRUFBYztBQUM1QixJQUFJO0FBQ0osY0FBYyxtRUFBYztBQUM1QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxjQUFjLGNBQWM7QUFDNUIsZUFBZSwrREFBVTtBQUN6QixlQUFlLCtEQUFVO0FBQ3pCOztBQUVBO0FBQ0EsU0FBUyxpR0FBMkI7O0FBRXBDO0FBQ0EsY0FBYyxjQUFjO0FBQzVCO0FBQ0E7QUFDQSxXQUFXLGlGQUFtQjtBQUM5QjtBQUNBLE1BQU0saUdBQTJCO0FBQ2pDO0FBQ0E7QUFDQSxXQUFXLGlHQUEyQjtBQUN0Qzs7QUFFQTtBQUNBLFNBQVMsaUZBQW1CO0FBQzVCO0FBQ0EsSUFBSSxpR0FBMkI7QUFDL0I7QUFDQTtBQUNBLFNBQVMsaUdBQTJCOztBQUVwQztBQUNBLHlCQUF5QixRQUFRO0FBQ2pDLFdBQVcsaUZBQW1CO0FBQzlCO0FBQ0EsTUFBTSxpR0FBMkI7QUFDakM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx5REFBZSx1QkFBdUIsRUFBQyIsInNvdXJjZXMiOlsid2VicGFjazovL3Z1ZTMtd2VicGFjazUvLi9ub2RlX21vZHVsZXMvY2VzaXVtL1NvdXJjZS9Db3JlL1RyaWRpYWdvbmFsU3lzdGVtU29sdmVyLmpzPzU0ZWIiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IENhcnRlc2lhbjMgZnJvbSBcIi4vQ2FydGVzaWFuMy5qc1wiO1xuaW1wb3J0IGRlZmluZWQgZnJvbSBcIi4vZGVmaW5lZC5qc1wiO1xuaW1wb3J0IERldmVsb3BlckVycm9yIGZyb20gXCIuL0RldmVsb3BlckVycm9yLmpzXCI7XG5cbi8qKlxuICogVXNlcyB0aGUgVHJpZGlhZ29uYWwgTWF0cml4IEFsZ29yaXRobSwgYWxzbyBrbm93biBhcyB0aGUgVGhvbWFzIEFsZ29yaXRobSwgdG8gc29sdmVcbiAqIGEgc3lzdGVtIG9mIGxpbmVhciBlcXVhdGlvbnMgd2hlcmUgdGhlIGNvZWZmaWNpZW50IG1hdHJpeCBpcyBhIHRyaWRpYWdvbmFsIG1hdHJpeC5cbiAqXG4gKiBAbmFtZXNwYWNlIFRyaWRpYWdvbmFsU3lzdGVtU29sdmVyXG4gKi9cbnZhciBUcmlkaWFnb25hbFN5c3RlbVNvbHZlciA9IHt9O1xuXG4vKipcbiAqIFNvbHZlcyBhIHRyaWRpYWdvbmFsIHN5c3RlbSBvZiBsaW5lYXIgZXF1YXRpb25zLlxuICpcbiAqIEBwYXJhbSB7TnVtYmVyW119IGRpYWdvbmFsIEFuIGFycmF5IHdpdGggbGVuZ3RoIDxjb2RlPm48L2NvZGU+IHRoYXQgY29udGFpbnMgdGhlIGRpYWdvbmFsIG9mIHRoZSBjb2VmZmljaWVudCBtYXRyaXguXG4gKiBAcGFyYW0ge051bWJlcltdfSBsb3dlciBBbiBhcnJheSB3aXRoIGxlbmd0aCA8Y29kZT5uIC0gMTwvY29kZT4gdGhhdCBjb250YWlucyB0aGUgbG93ZXIgZGlhZ29uYWwgb2YgdGhlIGNvZWZmaWNpZW50IG1hdHJpeC5cbiAqIEBwYXJhbSB7TnVtYmVyW119IHVwcGVyIEFuIGFycmF5IHdpdGggbGVuZ3RoIDxjb2RlPm4gLSAxPC9jb2RlPiB0aGF0IGNvbnRhaW5zIHRoZSB1cHBlciBkaWFnb25hbCBvZiB0aGUgY29lZmZpY2llbnQgbWF0cml4LlxuICogQHBhcmFtIHtDYXJ0ZXNpYW4zW119IHJpZ2h0IEFuIGFycmF5IG9mIENhcnRlc2lhbnMgd2l0aCBsZW5ndGggPGNvZGU+bjwvY29kZT4gdGhhdCBpcyB0aGUgcmlnaHQgc2lkZSBvZiB0aGUgc3lzdGVtIG9mIGVxdWF0aW9ucy5cbiAqXG4gKiBAZXhjZXB0aW9uIHtEZXZlbG9wZXJFcnJvcn0gZGlhZ29uYWwgYW5kIHJpZ2h0IG11c3QgaGF2ZSB0aGUgc2FtZSBsZW5ndGhzLlxuICogQGV4Y2VwdGlvbiB7RGV2ZWxvcGVyRXJyb3J9IGxvd2VyIGFuZCB1cHBlciBtdXN0IGhhdmUgdGhlIHNhbWUgbGVuZ3Rocy5cbiAqIEBleGNlcHRpb24ge0RldmVsb3BlckVycm9yfSBsb3dlciBhbmQgdXBwZXIgbXVzdCBiZSBvbmUgbGVzcyB0aGFuIHRoZSBsZW5ndGggb2YgZGlhZ29uYWwuXG4gKlxuICogQHBlcmZvcm1hbmNlIExpbmVhciB0aW1lLlxuICpcbiAqIEBleGFtcGxlXG4gKiB2YXIgbG93ZXJEaWFnb25hbCA9IFsxLjAsIDEuMCwgMS4wLCAxLjBdO1xuICogdmFyIGRpYWdvbmFsID0gWzIuMCwgNC4wLCA0LjAsIDQuMCwgMi4wXTtcbiAqIHZhciB1cHBlckRpYWdvbmFsID0gWzEuMCwgMS4wLCAxLjAsIDEuMF07XG4gKiB2YXIgcmlnaHRIYW5kU2lkZSA9IFtcbiAqICAgICBuZXcgQ2VzaXVtLkNhcnRlc2lhbjMoNDEwNzU3LjAsIC0xNTk1NzExLjAsIDEzNzUzMDIuMCksXG4gKiAgICAgbmV3IENlc2l1bS5DYXJ0ZXNpYW4zKC01OTg2NzA1LjAsIC0yMTkwNjQwLjAsIDEwOTk2MDAuMCksXG4gKiAgICAgbmV3IENlc2l1bS5DYXJ0ZXNpYW4zKC0xMjU5MzE4MC4wLCAyODg1ODguMCwgLTE3NTU1NDkuMCksXG4gKiAgICAgbmV3IENlc2l1bS5DYXJ0ZXNpYW4zKC01MzQ5ODk4LjAsIDI0NTcwMDUuMCwgLTI2ODU0MzguMCksXG4gKiAgICAgbmV3IENlc2l1bS5DYXJ0ZXNpYW4zKDg0NTgyMC4wLCAxNTczNDg4LjAsIC0xMjA1NTkxLjApXG4gKiBdO1xuICpcbiAqIHZhciBzb2x1dGlvbiA9IENlc2l1bS5UcmlkaWFnb25hbFN5c3RlbVNvbHZlci5zb2x2ZShsb3dlckRpYWdvbmFsLCBkaWFnb25hbCwgdXBwZXJEaWFnb25hbCwgcmlnaHRIYW5kU2lkZSk7XG4gKlxuICogQHJldHVybnMge0NhcnRlc2lhbjNbXX0gQW4gYXJyYXkgb2YgQ2FydGVzaWFucyB3aXRoIGxlbmd0aCA8Y29kZT5uPC9jb2RlPiB0aGF0IGlzIHRoZSBzb2x1dGlvbiB0byB0aGUgdHJpZGlhZ29uYWwgc3lzdGVtIG9mIGVxdWF0aW9ucy5cbiAqL1xuVHJpZGlhZ29uYWxTeXN0ZW1Tb2x2ZXIuc29sdmUgPSBmdW5jdGlvbiAobG93ZXIsIGRpYWdvbmFsLCB1cHBlciwgcmlnaHQpIHtcbiAgLy8+PmluY2x1ZGVTdGFydCgnZGVidWcnLCBwcmFnbWFzLmRlYnVnKTtcbiAgaWYgKCFkZWZpbmVkKGxvd2VyKSB8fCAhKGxvd2VyIGluc3RhbmNlb2YgQXJyYXkpKSB7XG4gICAgdGhyb3cgbmV3IERldmVsb3BlckVycm9yKFwiVGhlIGFycmF5IGxvd2VyIGlzIHJlcXVpcmVkLlwiKTtcbiAgfVxuICBpZiAoIWRlZmluZWQoZGlhZ29uYWwpIHx8ICEoZGlhZ29uYWwgaW5zdGFuY2VvZiBBcnJheSkpIHtcbiAgICB0aHJvdyBuZXcgRGV2ZWxvcGVyRXJyb3IoXCJUaGUgYXJyYXkgZGlhZ29uYWwgaXMgcmVxdWlyZWQuXCIpO1xuICB9XG4gIGlmICghZGVmaW5lZCh1cHBlcikgfHwgISh1cHBlciBpbnN0YW5jZW9mIEFycmF5KSkge1xuICAgIHRocm93IG5ldyBEZXZlbG9wZXJFcnJvcihcIlRoZSBhcnJheSB1cHBlciBpcyByZXF1aXJlZC5cIik7XG4gIH1cbiAgaWYgKCFkZWZpbmVkKHJpZ2h0KSB8fCAhKHJpZ2h0IGluc3RhbmNlb2YgQXJyYXkpKSB7XG4gICAgdGhyb3cgbmV3IERldmVsb3BlckVycm9yKFwiVGhlIGFycmF5IHJpZ2h0IGlzIHJlcXVpcmVkLlwiKTtcbiAgfVxuICBpZiAoZGlhZ29uYWwubGVuZ3RoICE9PSByaWdodC5sZW5ndGgpIHtcbiAgICB0aHJvdyBuZXcgRGV2ZWxvcGVyRXJyb3IoXCJkaWFnb25hbCBhbmQgcmlnaHQgbXVzdCBoYXZlIHRoZSBzYW1lIGxlbmd0aHMuXCIpO1xuICB9XG4gIGlmIChsb3dlci5sZW5ndGggIT09IHVwcGVyLmxlbmd0aCkge1xuICAgIHRocm93IG5ldyBEZXZlbG9wZXJFcnJvcihcImxvd2VyIGFuZCB1cHBlciBtdXN0IGhhdmUgdGhlIHNhbWUgbGVuZ3Rocy5cIik7XG4gIH0gZWxzZSBpZiAobG93ZXIubGVuZ3RoICE9PSBkaWFnb25hbC5sZW5ndGggLSAxKSB7XG4gICAgdGhyb3cgbmV3IERldmVsb3BlckVycm9yKFxuICAgICAgXCJsb3dlciBhbmQgdXBwZXIgbXVzdCBiZSBvbmUgbGVzcyB0aGFuIHRoZSBsZW5ndGggb2YgZGlhZ29uYWwuXCJcbiAgICApO1xuICB9XG4gIC8vPj5pbmNsdWRlRW5kKCdkZWJ1ZycpO1xuXG4gIHZhciBjID0gbmV3IEFycmF5KHVwcGVyLmxlbmd0aCk7XG4gIHZhciBkID0gbmV3IEFycmF5KHJpZ2h0Lmxlbmd0aCk7XG4gIHZhciB4ID0gbmV3IEFycmF5KHJpZ2h0Lmxlbmd0aCk7XG5cbiAgdmFyIGk7XG4gIGZvciAoaSA9IDA7IGkgPCBkLmxlbmd0aDsgaSsrKSB7XG4gICAgZFtpXSA9IG5ldyBDYXJ0ZXNpYW4zKCk7XG4gICAgeFtpXSA9IG5ldyBDYXJ0ZXNpYW4zKCk7XG4gIH1cblxuICBjWzBdID0gdXBwZXJbMF0gLyBkaWFnb25hbFswXTtcbiAgZFswXSA9IENhcnRlc2lhbjMubXVsdGlwbHlCeVNjYWxhcihyaWdodFswXSwgMS4wIC8gZGlhZ29uYWxbMF0sIGRbMF0pO1xuXG4gIHZhciBzY2FsYXI7XG4gIGZvciAoaSA9IDE7IGkgPCBjLmxlbmd0aDsgKytpKSB7XG4gICAgc2NhbGFyID0gMS4wIC8gKGRpYWdvbmFsW2ldIC0gY1tpIC0gMV0gKiBsb3dlcltpIC0gMV0pO1xuICAgIGNbaV0gPSB1cHBlcltpXSAqIHNjYWxhcjtcbiAgICBkW2ldID0gQ2FydGVzaWFuMy5zdWJ0cmFjdChcbiAgICAgIHJpZ2h0W2ldLFxuICAgICAgQ2FydGVzaWFuMy5tdWx0aXBseUJ5U2NhbGFyKGRbaSAtIDFdLCBsb3dlcltpIC0gMV0sIGRbaV0pLFxuICAgICAgZFtpXVxuICAgICk7XG4gICAgZFtpXSA9IENhcnRlc2lhbjMubXVsdGlwbHlCeVNjYWxhcihkW2ldLCBzY2FsYXIsIGRbaV0pO1xuICB9XG5cbiAgc2NhbGFyID0gMS4wIC8gKGRpYWdvbmFsW2ldIC0gY1tpIC0gMV0gKiBsb3dlcltpIC0gMV0pO1xuICBkW2ldID0gQ2FydGVzaWFuMy5zdWJ0cmFjdChcbiAgICByaWdodFtpXSxcbiAgICBDYXJ0ZXNpYW4zLm11bHRpcGx5QnlTY2FsYXIoZFtpIC0gMV0sIGxvd2VyW2kgLSAxXSwgZFtpXSksXG4gICAgZFtpXVxuICApO1xuICBkW2ldID0gQ2FydGVzaWFuMy5tdWx0aXBseUJ5U2NhbGFyKGRbaV0sIHNjYWxhciwgZFtpXSk7XG5cbiAgeFt4Lmxlbmd0aCAtIDFdID0gZFtkLmxlbmd0aCAtIDFdO1xuICBmb3IgKGkgPSB4Lmxlbmd0aCAtIDI7IGkgPj0gMDsgLS1pKSB7XG4gICAgeFtpXSA9IENhcnRlc2lhbjMuc3VidHJhY3QoXG4gICAgICBkW2ldLFxuICAgICAgQ2FydGVzaWFuMy5tdWx0aXBseUJ5U2NhbGFyKHhbaSArIDFdLCBjW2ldLCB4W2ldKSxcbiAgICAgIHhbaV1cbiAgICApO1xuICB9XG5cbiAgcmV0dXJuIHg7XG59O1xuZXhwb3J0IGRlZmF1bHQgVHJpZGlhZ29uYWxTeXN0ZW1Tb2x2ZXI7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///72579\n')},84862:function(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__){eval('/* harmony import */ var _ThirdParty_Uri_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(93922);\n/* harmony import */ var _defined_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(82982);\n/* harmony import */ var _DeveloperError_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(12572);\n\n\n\n\n/**\n * A singleton that contains all of the servers that are trusted. Credentials will be sent with\n * any requests to these servers.\n *\n * @namespace TrustedServers\n *\n * @see {@link http://www.w3.org/TR/cors/|Cross-Origin Resource Sharing}\n */\nvar TrustedServers = {};\nvar _servers = {};\n\n/**\n * Adds a trusted server to the registry\n *\n * @param {String} host The host to be added.\n * @param {Number} port The port used to access the host.\n *\n * @example\n * // Add a trusted server\n * TrustedServers.add(\'my.server.com\', 80);\n */\nTrustedServers.add = function (host, port) {\n  //>>includeStart(\'debug\', pragmas.debug);\n  if (!(0,_defined_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"] */ .Z)(host)) {\n    throw new _DeveloperError_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .Z("host is required.");\n  }\n  if (!(0,_defined_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"] */ .Z)(port) || port <= 0) {\n    throw new _DeveloperError_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .Z("port is required to be greater than 0.");\n  }\n  //>>includeEnd(\'debug\');\n\n  var authority = host.toLowerCase() + ":" + port;\n  if (!(0,_defined_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"] */ .Z)(_servers[authority])) {\n    _servers[authority] = true;\n  }\n};\n\n/**\n * Removes a trusted server from the registry\n *\n * @param {String} host The host to be removed.\n * @param {Number} port The port used to access the host.\n *\n * @example\n * // Remove a trusted server\n * TrustedServers.remove(\'my.server.com\', 80);\n */\nTrustedServers.remove = function (host, port) {\n  //>>includeStart(\'debug\', pragmas.debug);\n  if (!(0,_defined_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"] */ .Z)(host)) {\n    throw new _DeveloperError_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .Z("host is required.");\n  }\n  if (!(0,_defined_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"] */ .Z)(port) || port <= 0) {\n    throw new _DeveloperError_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .Z("port is required to be greater than 0.");\n  }\n  //>>includeEnd(\'debug\');\n\n  var authority = host.toLowerCase() + ":" + port;\n  if ((0,_defined_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"] */ .Z)(_servers[authority])) {\n    delete _servers[authority];\n  }\n};\n\nfunction getAuthority(url) {\n  var uri = new _ThirdParty_Uri_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .Z(url);\n  uri.normalize();\n\n  // Removes username:password@ so we just have host[:port]\n  var authority = uri.authority();\n  if (authority.length === 0) {\n    return undefined; // Relative URL\n  }\n  uri.authority(authority);\n\n  if (authority.indexOf("@") !== -1) {\n    var parts = authority.split("@");\n    authority = parts[1];\n  }\n\n  // If the port is missing add one based on the scheme\n  if (authority.indexOf(":") === -1) {\n    var scheme = uri.scheme();\n    if (scheme.length === 0) {\n      scheme = window.location.protocol;\n      scheme = scheme.substring(0, scheme.length - 1);\n    }\n    if (scheme === "http") {\n      authority += ":80";\n    } else if (scheme === "https") {\n      authority += ":443";\n    } else {\n      return undefined;\n    }\n  }\n\n  return authority;\n}\n\n/**\n * Tests whether a server is trusted or not. The server must have been added with the port if it is included in the url.\n *\n * @param {String} url The url to be tested against the trusted list\n *\n * @returns {boolean} Returns true if url is trusted, false otherwise.\n *\n * @example\n * // Add server\n * TrustedServers.add(\'my.server.com\', 81);\n *\n * // Check if server is trusted\n * if (TrustedServers.contains(\'https://my.server.com:81/path/to/file.png\')) {\n *     // my.server.com:81 is trusted\n * }\n * if (TrustedServers.contains(\'https://my.server.com/path/to/file.png\')) {\n *     // my.server.com isn\'t trusted\n * }\n */\nTrustedServers.contains = function (url) {\n  //>>includeStart(\'debug\', pragmas.debug);\n  if (!(0,_defined_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"] */ .Z)(url)) {\n    throw new _DeveloperError_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .Z("url is required.");\n  }\n  //>>includeEnd(\'debug\');\n  var authority = getAuthority(url);\n  if ((0,_defined_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"] */ .Z)(authority) && (0,_defined_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"] */ .Z)(_servers[authority])) {\n    return true;\n  }\n\n  return false;\n};\n\n/**\n * Clears the registry\n *\n * @example\n * // Remove a trusted server\n * TrustedServers.clear();\n */\nTrustedServers.clear = function () {\n  _servers = {};\n};\n/* harmony default export */ __webpack_exports__["Z"] = (TrustedServers);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiODQ4NjIuanMiLCJtYXBwaW5ncyI6Ijs7O0FBQXVDO0FBQ0o7QUFDYzs7QUFFakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTyxnRUFBTztBQUNkLGNBQWMsbUVBQWM7QUFDNUI7QUFDQSxPQUFPLGdFQUFPO0FBQ2QsY0FBYyxtRUFBYztBQUM1QjtBQUNBOztBQUVBO0FBQ0EsT0FBTyxnRUFBTztBQUNkO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTyxnRUFBTztBQUNkLGNBQWMsbUVBQWM7QUFDNUI7QUFDQSxPQUFPLGdFQUFPO0FBQ2QsY0FBYyxtRUFBYztBQUM1QjtBQUNBOztBQUVBO0FBQ0EsTUFBTSxnRUFBTztBQUNiO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGdCQUFnQixtRUFBRztBQUNuQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CO0FBQ0EsYUFBYSxTQUFTO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU8sZ0VBQU87QUFDZCxjQUFjLG1FQUFjO0FBQzVCO0FBQ0E7QUFDQTtBQUNBLE1BQU0sZ0VBQU8sZUFBZSxnRUFBTztBQUNuQztBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5REFBZSxjQUFjLEVBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly92dWUzLXdlYnBhY2s1Ly4vbm9kZV9tb2R1bGVzL2Nlc2l1bS9Tb3VyY2UvQ29yZS9UcnVzdGVkU2VydmVycy5qcz9hNTI0Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBVcmkgZnJvbSBcIi4uL1RoaXJkUGFydHkvVXJpLmpzXCI7XG5pbXBvcnQgZGVmaW5lZCBmcm9tIFwiLi9kZWZpbmVkLmpzXCI7XG5pbXBvcnQgRGV2ZWxvcGVyRXJyb3IgZnJvbSBcIi4vRGV2ZWxvcGVyRXJyb3IuanNcIjtcblxuLyoqXG4gKiBBIHNpbmdsZXRvbiB0aGF0IGNvbnRhaW5zIGFsbCBvZiB0aGUgc2VydmVycyB0aGF0IGFyZSB0cnVzdGVkLiBDcmVkZW50aWFscyB3aWxsIGJlIHNlbnQgd2l0aFxuICogYW55IHJlcXVlc3RzIHRvIHRoZXNlIHNlcnZlcnMuXG4gKlxuICogQG5hbWVzcGFjZSBUcnVzdGVkU2VydmVyc1xuICpcbiAqIEBzZWUge0BsaW5rIGh0dHA6Ly93d3cudzMub3JnL1RSL2NvcnMvfENyb3NzLU9yaWdpbiBSZXNvdXJjZSBTaGFyaW5nfVxuICovXG52YXIgVHJ1c3RlZFNlcnZlcnMgPSB7fTtcbnZhciBfc2VydmVycyA9IHt9O1xuXG4vKipcbiAqIEFkZHMgYSB0cnVzdGVkIHNlcnZlciB0byB0aGUgcmVnaXN0cnlcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gaG9zdCBUaGUgaG9zdCB0byBiZSBhZGRlZC5cbiAqIEBwYXJhbSB7TnVtYmVyfSBwb3J0IFRoZSBwb3J0IHVzZWQgdG8gYWNjZXNzIHRoZSBob3N0LlxuICpcbiAqIEBleGFtcGxlXG4gKiAvLyBBZGQgYSB0cnVzdGVkIHNlcnZlclxuICogVHJ1c3RlZFNlcnZlcnMuYWRkKCdteS5zZXJ2ZXIuY29tJywgODApO1xuICovXG5UcnVzdGVkU2VydmVycy5hZGQgPSBmdW5jdGlvbiAoaG9zdCwgcG9ydCkge1xuICAvLz4+aW5jbHVkZVN0YXJ0KCdkZWJ1ZycsIHByYWdtYXMuZGVidWcpO1xuICBpZiAoIWRlZmluZWQoaG9zdCkpIHtcbiAgICB0aHJvdyBuZXcgRGV2ZWxvcGVyRXJyb3IoXCJob3N0IGlzIHJlcXVpcmVkLlwiKTtcbiAgfVxuICBpZiAoIWRlZmluZWQocG9ydCkgfHwgcG9ydCA8PSAwKSB7XG4gICAgdGhyb3cgbmV3IERldmVsb3BlckVycm9yKFwicG9ydCBpcyByZXF1aXJlZCB0byBiZSBncmVhdGVyIHRoYW4gMC5cIik7XG4gIH1cbiAgLy8+PmluY2x1ZGVFbmQoJ2RlYnVnJyk7XG5cbiAgdmFyIGF1dGhvcml0eSA9IGhvc3QudG9Mb3dlckNhc2UoKSArIFwiOlwiICsgcG9ydDtcbiAgaWYgKCFkZWZpbmVkKF9zZXJ2ZXJzW2F1dGhvcml0eV0pKSB7XG4gICAgX3NlcnZlcnNbYXV0aG9yaXR5XSA9IHRydWU7XG4gIH1cbn07XG5cbi8qKlxuICogUmVtb3ZlcyBhIHRydXN0ZWQgc2VydmVyIGZyb20gdGhlIHJlZ2lzdHJ5XG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGhvc3QgVGhlIGhvc3QgdG8gYmUgcmVtb3ZlZC5cbiAqIEBwYXJhbSB7TnVtYmVyfSBwb3J0IFRoZSBwb3J0IHVzZWQgdG8gYWNjZXNzIHRoZSBob3N0LlxuICpcbiAqIEBleGFtcGxlXG4gKiAvLyBSZW1vdmUgYSB0cnVzdGVkIHNlcnZlclxuICogVHJ1c3RlZFNlcnZlcnMucmVtb3ZlKCdteS5zZXJ2ZXIuY29tJywgODApO1xuICovXG5UcnVzdGVkU2VydmVycy5yZW1vdmUgPSBmdW5jdGlvbiAoaG9zdCwgcG9ydCkge1xuICAvLz4+aW5jbHVkZVN0YXJ0KCdkZWJ1ZycsIHByYWdtYXMuZGVidWcpO1xuICBpZiAoIWRlZmluZWQoaG9zdCkpIHtcbiAgICB0aHJvdyBuZXcgRGV2ZWxvcGVyRXJyb3IoXCJob3N0IGlzIHJlcXVpcmVkLlwiKTtcbiAgfVxuICBpZiAoIWRlZmluZWQocG9ydCkgfHwgcG9ydCA8PSAwKSB7XG4gICAgdGhyb3cgbmV3IERldmVsb3BlckVycm9yKFwicG9ydCBpcyByZXF1aXJlZCB0byBiZSBncmVhdGVyIHRoYW4gMC5cIik7XG4gIH1cbiAgLy8+PmluY2x1ZGVFbmQoJ2RlYnVnJyk7XG5cbiAgdmFyIGF1dGhvcml0eSA9IGhvc3QudG9Mb3dlckNhc2UoKSArIFwiOlwiICsgcG9ydDtcbiAgaWYgKGRlZmluZWQoX3NlcnZlcnNbYXV0aG9yaXR5XSkpIHtcbiAgICBkZWxldGUgX3NlcnZlcnNbYXV0aG9yaXR5XTtcbiAgfVxufTtcblxuZnVuY3Rpb24gZ2V0QXV0aG9yaXR5KHVybCkge1xuICB2YXIgdXJpID0gbmV3IFVyaSh1cmwpO1xuICB1cmkubm9ybWFsaXplKCk7XG5cbiAgLy8gUmVtb3ZlcyB1c2VybmFtZTpwYXNzd29yZEAgc28gd2UganVzdCBoYXZlIGhvc3RbOnBvcnRdXG4gIHZhciBhdXRob3JpdHkgPSB1cmkuYXV0aG9yaXR5KCk7XG4gIGlmIChhdXRob3JpdHkubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIHVuZGVmaW5lZDsgLy8gUmVsYXRpdmUgVVJMXG4gIH1cbiAgdXJpLmF1dGhvcml0eShhdXRob3JpdHkpO1xuXG4gIGlmIChhdXRob3JpdHkuaW5kZXhPZihcIkBcIikgIT09IC0xKSB7XG4gICAgdmFyIHBhcnRzID0gYXV0aG9yaXR5LnNwbGl0KFwiQFwiKTtcbiAgICBhdXRob3JpdHkgPSBwYXJ0c1sxXTtcbiAgfVxuXG4gIC8vIElmIHRoZSBwb3J0IGlzIG1pc3NpbmcgYWRkIG9uZSBiYXNlZCBvbiB0aGUgc2NoZW1lXG4gIGlmIChhdXRob3JpdHkuaW5kZXhPZihcIjpcIikgPT09IC0xKSB7XG4gICAgdmFyIHNjaGVtZSA9IHVyaS5zY2hlbWUoKTtcbiAgICBpZiAoc2NoZW1lLmxlbmd0aCA9PT0gMCkge1xuICAgICAgc2NoZW1lID0gd2luZG93LmxvY2F0aW9uLnByb3RvY29sO1xuICAgICAgc2NoZW1lID0gc2NoZW1lLnN1YnN0cmluZygwLCBzY2hlbWUubGVuZ3RoIC0gMSk7XG4gICAgfVxuICAgIGlmIChzY2hlbWUgPT09IFwiaHR0cFwiKSB7XG4gICAgICBhdXRob3JpdHkgKz0gXCI6ODBcIjtcbiAgICB9IGVsc2UgaWYgKHNjaGVtZSA9PT0gXCJodHRwc1wiKSB7XG4gICAgICBhdXRob3JpdHkgKz0gXCI6NDQzXCI7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGF1dGhvcml0eTtcbn1cblxuLyoqXG4gKiBUZXN0cyB3aGV0aGVyIGEgc2VydmVyIGlzIHRydXN0ZWQgb3Igbm90LiBUaGUgc2VydmVyIG11c3QgaGF2ZSBiZWVuIGFkZGVkIHdpdGggdGhlIHBvcnQgaWYgaXQgaXMgaW5jbHVkZWQgaW4gdGhlIHVybC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gdXJsIFRoZSB1cmwgdG8gYmUgdGVzdGVkIGFnYWluc3QgdGhlIHRydXN0ZWQgbGlzdFxuICpcbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIHRydWUgaWYgdXJsIGlzIHRydXN0ZWQsIGZhbHNlIG90aGVyd2lzZS5cbiAqXG4gKiBAZXhhbXBsZVxuICogLy8gQWRkIHNlcnZlclxuICogVHJ1c3RlZFNlcnZlcnMuYWRkKCdteS5zZXJ2ZXIuY29tJywgODEpO1xuICpcbiAqIC8vIENoZWNrIGlmIHNlcnZlciBpcyB0cnVzdGVkXG4gKiBpZiAoVHJ1c3RlZFNlcnZlcnMuY29udGFpbnMoJ2h0dHBzOi8vbXkuc2VydmVyLmNvbTo4MS9wYXRoL3RvL2ZpbGUucG5nJykpIHtcbiAqICAgICAvLyBteS5zZXJ2ZXIuY29tOjgxIGlzIHRydXN0ZWRcbiAqIH1cbiAqIGlmIChUcnVzdGVkU2VydmVycy5jb250YWlucygnaHR0cHM6Ly9teS5zZXJ2ZXIuY29tL3BhdGgvdG8vZmlsZS5wbmcnKSkge1xuICogICAgIC8vIG15LnNlcnZlci5jb20gaXNuJ3QgdHJ1c3RlZFxuICogfVxuICovXG5UcnVzdGVkU2VydmVycy5jb250YWlucyA9IGZ1bmN0aW9uICh1cmwpIHtcbiAgLy8+PmluY2x1ZGVTdGFydCgnZGVidWcnLCBwcmFnbWFzLmRlYnVnKTtcbiAgaWYgKCFkZWZpbmVkKHVybCkpIHtcbiAgICB0aHJvdyBuZXcgRGV2ZWxvcGVyRXJyb3IoXCJ1cmwgaXMgcmVxdWlyZWQuXCIpO1xuICB9XG4gIC8vPj5pbmNsdWRlRW5kKCdkZWJ1ZycpO1xuICB2YXIgYXV0aG9yaXR5ID0gZ2V0QXV0aG9yaXR5KHVybCk7XG4gIGlmIChkZWZpbmVkKGF1dGhvcml0eSkgJiYgZGVmaW5lZChfc2VydmVyc1thdXRob3JpdHldKSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufTtcblxuLyoqXG4gKiBDbGVhcnMgdGhlIHJlZ2lzdHJ5XG4gKlxuICogQGV4YW1wbGVcbiAqIC8vIFJlbW92ZSBhIHRydXN0ZWQgc2VydmVyXG4gKiBUcnVzdGVkU2VydmVycy5jbGVhcigpO1xuICovXG5UcnVzdGVkU2VydmVycy5jbGVhciA9IGZ1bmN0aW9uICgpIHtcbiAgX3NlcnZlcnMgPSB7fTtcbn07XG5leHBvcnQgZGVmYXVsdCBUcnVzdGVkU2VydmVycztcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///84862\n')},15243:function(__unused_webpack___webpack_module__,__unused_webpack___webpack_exports__,__webpack_require__){eval('/* harmony import */ var _ThirdParty_when_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(13222);\n/* harmony import */ var _Credit_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(52975);\n/* harmony import */ var _defaultValue_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(62200);\n/* harmony import */ var _defined_js__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(82982);\n/* harmony import */ var _DeveloperError_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(12572);\n/* harmony import */ var _Ellipsoid_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(50491);\n/* harmony import */ var _Event_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(14459);\n/* harmony import */ var _GeographicTilingScheme_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(71351);\n/* harmony import */ var _getImagePixels_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(81544);\n/* harmony import */ var _HeightmapTerrainData_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(57134);\n/* harmony import */ var _Math_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(99417);\n/* harmony import */ var _Rectangle_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(96190);\n/* harmony import */ var _Resource_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(68985);\n/* harmony import */ var _TerrainProvider_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(1497);\n/* harmony import */ var _TileProviderError_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(9121);\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunction DataRectangle(rectangle, maxLevel) {\n  this.rectangle = rectangle;\n  this.maxLevel = maxLevel;\n}\n\n/**\n * A {@link TerrainProvider} that produces terrain geometry by tessellating height maps\n * retrieved from a {@link http://vr-theworld.com/|VT MÄK VR-TheWorld server}.\n *\n * @alias VRTheWorldTerrainProvider\n * @constructor\n *\n * @param {Object} options Object with the following properties:\n * @param {Resource|String} options.url The URL of the VR-TheWorld TileMap.\n * @param {Ellipsoid} [options.ellipsoid=Ellipsoid.WGS84] The ellipsoid.  If this parameter is not\n *                    specified, the WGS84 ellipsoid is used.\n * @param {Credit|String} [options.credit] A credit for the data source, which is displayed on the canvas.\n *\n *\n * @example\n * var terrainProvider = new Cesium.VRTheWorldTerrainProvider({\n *   url : \'https://www.vr-theworld.com/vr-theworld/tiles1.0.0/73/\'\n * });\n * viewer.terrainProvider = terrainProvider;\n *\n * @see TerrainProvider\n */\nfunction VRTheWorldTerrainProvider(options) {\n  options = (0,_defaultValue_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"] */ .Z)(options, _defaultValue_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"].EMPTY_OBJECT */ .Z.EMPTY_OBJECT);\n  //>>includeStart(\'debug\', pragmas.debug);\n  if (!(0,_defined_js__WEBPACK_IMPORTED_MODULE_14__/* ["default"] */ .Z)(options.url)) {\n    throw new _DeveloperError_js__WEBPACK_IMPORTED_MODULE_3__/* ["default"] */ .Z("options.url is required.");\n  }\n  //>>includeEnd(\'debug\');\n\n  var resource = _Resource_js__WEBPACK_IMPORTED_MODULE_11__/* ["default"].createIfNeeded */ .Z.createIfNeeded(options.url);\n\n  this._resource = resource;\n\n  this._errorEvent = new _Event_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"] */ .Z();\n  this._ready = false;\n  this._readyPromise = _ThirdParty_when_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].defer */ .Z.defer();\n\n  this._terrainDataStructure = {\n    heightScale: 1.0 / 1000.0,\n    heightOffset: -1000.0,\n    elementsPerHeight: 3,\n    stride: 4,\n    elementMultiplier: 256.0,\n    isBigEndian: true,\n    lowestEncodedHeight: 0,\n    highestEncodedHeight: 256 * 256 * 256 - 1,\n  };\n\n  var credit = options.credit;\n  if (typeof credit === "string") {\n    credit = new _Credit_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .Z(credit);\n  }\n  this._credit = credit;\n\n  this._tilingScheme = undefined;\n  this._rectangles = [];\n\n  var that = this;\n  var metadataError;\n  var ellipsoid = (0,_defaultValue_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"] */ .Z)(options.ellipsoid, _Ellipsoid_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"].WGS84 */ .Z.WGS84);\n\n  function metadataSuccess(xml) {\n    var srs = xml.getElementsByTagName("SRS")[0].textContent;\n    if (srs === "EPSG:4326") {\n      that._tilingScheme = new _GeographicTilingScheme_js__WEBPACK_IMPORTED_MODULE_6__/* ["default"] */ .Z({ ellipsoid: ellipsoid });\n    } else {\n      metadataFailure("SRS " + srs + " is not supported.");\n      return;\n    }\n\n    var tileFormat = xml.getElementsByTagName("TileFormat")[0];\n    that._heightmapWidth = parseInt(tileFormat.getAttribute("width"), 10);\n    that._heightmapHeight = parseInt(tileFormat.getAttribute("height"), 10);\n    that._levelZeroMaximumGeometricError = _TerrainProvider_js__WEBPACK_IMPORTED_MODULE_12__/* ["default"].getEstimatedLevelZeroGeometricErrorForAHeightmap */ .Z.getEstimatedLevelZeroGeometricErrorForAHeightmap(\n      ellipsoid,\n      Math.min(that._heightmapWidth, that._heightmapHeight),\n      that._tilingScheme.getNumberOfXTilesAtLevel(0)\n    );\n\n    var dataRectangles = xml.getElementsByTagName("DataExtent");\n\n    for (var i = 0; i < dataRectangles.length; ++i) {\n      var dataRectangle = dataRectangles[i];\n\n      var west = _Math_js__WEBPACK_IMPORTED_MODULE_9__/* ["default"].toRadians */ .Z.toRadians(\n        parseFloat(dataRectangle.getAttribute("minx"))\n      );\n      var south = _Math_js__WEBPACK_IMPORTED_MODULE_9__/* ["default"].toRadians */ .Z.toRadians(\n        parseFloat(dataRectangle.getAttribute("miny"))\n      );\n      var east = _Math_js__WEBPACK_IMPORTED_MODULE_9__/* ["default"].toRadians */ .Z.toRadians(\n        parseFloat(dataRectangle.getAttribute("maxx"))\n      );\n      var north = _Math_js__WEBPACK_IMPORTED_MODULE_9__/* ["default"].toRadians */ .Z.toRadians(\n        parseFloat(dataRectangle.getAttribute("maxy"))\n      );\n      var maxLevel = parseInt(dataRectangle.getAttribute("maxlevel"), 10);\n\n      that._rectangles.push(\n        new DataRectangle(new _Rectangle_js__WEBPACK_IMPORTED_MODULE_10__/* ["default"] */ .Z(west, south, east, north), maxLevel)\n      );\n    }\n\n    that._ready = true;\n    that._readyPromise.resolve(true);\n  }\n\n  function metadataFailure(e) {\n    var message = (0,_defaultValue_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"] */ .Z)(\n      e,\n      "An error occurred while accessing " + that._resource.url + "."\n    );\n    metadataError = _TileProviderError_js__WEBPACK_IMPORTED_MODULE_13__/* ["default"].handleError */ .Z.handleError(\n      metadataError,\n      that,\n      that._errorEvent,\n      message,\n      undefined,\n      undefined,\n      undefined,\n      requestMetadata\n    );\n  }\n\n  function requestMetadata() {\n    (0,_ThirdParty_when_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .Z)(that._resource.fetchXML(), metadataSuccess, metadataFailure);\n  }\n\n  requestMetadata();\n}\n\nObject.defineProperties(VRTheWorldTerrainProvider.prototype, {\n  /**\n   * Gets an event that is raised when the terrain provider encounters an asynchronous error.  By subscribing\n   * to the event, you will be notified of the error and can potentially recover from it.  Event listeners\n   * are passed an instance of {@link TileProviderError}.\n   * @memberof VRTheWorldTerrainProvider.prototype\n   * @type {Event}\n   * @readonly\n   */\n  errorEvent: {\n    get: function () {\n      return this._errorEvent;\n    },\n  },\n\n  /**\n   * Gets the credit to display when this terrain provider is active.  Typically this is used to credit\n   * the source of the terrain.  This function should not be called before {@link VRTheWorldTerrainProvider#ready} returns true.\n   * @memberof VRTheWorldTerrainProvider.prototype\n   * @type {Credit}\n   * @readonly\n   */\n  credit: {\n    get: function () {\n      return this._credit;\n    },\n  },\n\n  /**\n   * Gets the tiling scheme used by this provider.  This function should\n   * not be called before {@link VRTheWorldTerrainProvider#ready} returns true.\n   * @memberof VRTheWorldTerrainProvider.prototype\n   * @type {GeographicTilingScheme}\n   * @readonly\n   */\n  tilingScheme: {\n    get: function () {\n      //>>includeStart(\'debug\', pragmas.debug);\n      if (!this.ready) {\n        throw new _DeveloperError_js__WEBPACK_IMPORTED_MODULE_3__/* ["default"] */ .Z(\n          "requestTileGeometry must not be called before ready returns true."\n        );\n      }\n      //>>includeEnd(\'debug\');\n\n      return this._tilingScheme;\n    },\n  },\n\n  /**\n   * Gets a value indicating whether or not the provider is ready for use.\n   * @memberof VRTheWorldTerrainProvider.prototype\n   * @type {Boolean}\n   * @readonly\n   */\n  ready: {\n    get: function () {\n      return this._ready;\n    },\n  },\n\n  /**\n   * Gets a promise that resolves to true when the provider is ready for use.\n   * @memberof VRTheWorldTerrainProvider.prototype\n   * @type {Promise.<Boolean>}\n   * @readonly\n   */\n  readyPromise: {\n    get: function () {\n      return this._readyPromise.promise;\n    },\n  },\n\n  /**\n   * Gets a value indicating whether or not the provider includes a water mask.  The water mask\n   * indicates which areas of the globe are water rather than land, so they can be rendered\n   * as a reflective surface with animated waves.  This function should not be\n   * called before {@link VRTheWorldTerrainProvider#ready} returns true.\n   * @memberof VRTheWorldTerrainProvider.prototype\n   * @type {Boolean}\n   * @readonly\n   */\n  hasWaterMask: {\n    get: function () {\n      return false;\n    },\n  },\n\n  /**\n   * Gets a value indicating whether or not the requested tiles include vertex normals.\n   * This function should not be called before {@link VRTheWorldTerrainProvider#ready} returns true.\n   * @memberof VRTheWorldTerrainProvider.prototype\n   * @type {Boolean}\n   * @readonly\n   */\n  hasVertexNormals: {\n    get: function () {\n      return false;\n    },\n  },\n  /**\n   * Gets an object that can be used to determine availability of terrain from this provider, such as\n   * at points and in rectangles.  This function should not be called before\n   * {@link TerrainProvider#ready} returns true.  This property may be undefined if availability\n   * information is not available.\n   * @memberof VRTheWorldTerrainProvider.prototype\n   * @type {TileAvailability}\n   * @readonly\n   */\n  availability: {\n    get: function () {\n      return undefined;\n    },\n  },\n});\n\n/**\n * Requests the geometry for a given tile.  This function should not be called before\n * {@link VRTheWorldTerrainProvider#ready} returns true.  The result includes terrain\n * data and indicates that all child tiles are available.\n *\n * @param {Number} x The X coordinate of the tile for which to request geometry.\n * @param {Number} y The Y coordinate of the tile for which to request geometry.\n * @param {Number} level The level of the tile for which to request geometry.\n * @param {Request} [request] The request object. Intended for internal use only.\n * @returns {Promise.<TerrainData>|undefined} A promise for the requested geometry.  If this method\n *          returns undefined instead of a promise, it is an indication that too many requests are already\n *          pending and the request will be retried later.\n */\nVRTheWorldTerrainProvider.prototype.requestTileGeometry = function (\n  x,\n  y,\n  level,\n  request\n) {\n  //>>includeStart(\'debug\', pragmas.debug);\n  if (!this.ready) {\n    throw new _DeveloperError_js__WEBPACK_IMPORTED_MODULE_3__/* ["default"] */ .Z(\n      "requestTileGeometry must not be called before ready returns true."\n    );\n  }\n  //>>includeEnd(\'debug\');\n\n  var yTiles = this._tilingScheme.getNumberOfYTilesAtLevel(level);\n  var resource = this._resource.getDerivedResource({\n    url: level + "/" + x + "/" + (yTiles - y - 1) + ".tif",\n    queryParameters: {\n      cesium: true,\n    },\n    request: request,\n  });\n  var promise = resource.fetchImage({\n    preferImageBitmap: true,\n  });\n  if (!(0,_defined_js__WEBPACK_IMPORTED_MODULE_14__/* ["default"] */ .Z)(promise)) {\n    return undefined;\n  }\n\n  var that = this;\n  return (0,_ThirdParty_when_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .Z)(promise).then(function (image) {\n    return new _HeightmapTerrainData_js__WEBPACK_IMPORTED_MODULE_8__/* ["default"] */ .Z({\n      buffer: (0,_getImagePixels_js__WEBPACK_IMPORTED_MODULE_7__/* ["default"] */ .Z)(image),\n      width: that._heightmapWidth,\n      height: that._heightmapHeight,\n      childTileMask: getChildMask(that, x, y, level),\n      structure: that._terrainDataStructure,\n    });\n  });\n};\n\n/**\n * Gets the maximum geometric error allowed in a tile at a given level.\n *\n * @param {Number} level The tile level for which to get the maximum geometric error.\n * @returns {Number} The maximum geometric error.\n */\nVRTheWorldTerrainProvider.prototype.getLevelMaximumGeometricError = function (\n  level\n) {\n  //>>includeStart(\'debug\', pragmas.debug);\n  if (!this.ready) {\n    throw new _DeveloperError_js__WEBPACK_IMPORTED_MODULE_3__/* ["default"] */ .Z(\n      "requestTileGeometry must not be called before ready returns true."\n    );\n  }\n  //>>includeEnd(\'debug\');\n  return this._levelZeroMaximumGeometricError / (1 << level);\n};\n\nvar rectangleScratch = new _Rectangle_js__WEBPACK_IMPORTED_MODULE_10__/* ["default"] */ .Z();\n\nfunction getChildMask(provider, x, y, level) {\n  var tilingScheme = provider._tilingScheme;\n  var rectangles = provider._rectangles;\n  var parentRectangle = tilingScheme.tileXYToRectangle(x, y, level);\n\n  var childMask = 0;\n\n  for (var i = 0; i < rectangles.length && childMask !== 15; ++i) {\n    var rectangle = rectangles[i];\n    if (rectangle.maxLevel <= level) {\n      continue;\n    }\n\n    var testRectangle = rectangle.rectangle;\n\n    var intersection = _Rectangle_js__WEBPACK_IMPORTED_MODULE_10__/* ["default"].intersection */ .Z.intersection(\n      testRectangle,\n      parentRectangle,\n      rectangleScratch\n    );\n    if ((0,_defined_js__WEBPACK_IMPORTED_MODULE_14__/* ["default"] */ .Z)(intersection)) {\n      // Parent tile is inside this rectangle, so at least one child is, too.\n      if (\n        isTileInRectangle(tilingScheme, testRectangle, x * 2, y * 2, level + 1)\n      ) {\n        childMask |= 4; // northwest\n      }\n      if (\n        isTileInRectangle(\n          tilingScheme,\n          testRectangle,\n          x * 2 + 1,\n          y * 2,\n          level + 1\n        )\n      ) {\n        childMask |= 8; // northeast\n      }\n      if (\n        isTileInRectangle(\n          tilingScheme,\n          testRectangle,\n          x * 2,\n          y * 2 + 1,\n          level + 1\n        )\n      ) {\n        childMask |= 1; // southwest\n      }\n      if (\n        isTileInRectangle(\n          tilingScheme,\n          testRectangle,\n          x * 2 + 1,\n          y * 2 + 1,\n          level + 1\n        )\n      ) {\n        childMask |= 2; // southeast\n      }\n    }\n  }\n\n  return childMask;\n}\n\nfunction isTileInRectangle(tilingScheme, rectangle, x, y, level) {\n  var tileRectangle = tilingScheme.tileXYToRectangle(x, y, level);\n  return (0,_defined_js__WEBPACK_IMPORTED_MODULE_14__/* ["default"] */ .Z)(\n    _Rectangle_js__WEBPACK_IMPORTED_MODULE_10__/* ["default"].intersection */ .Z.intersection(tileRectangle, rectangle, rectangleScratch)\n  );\n}\n\n/**\n * Determines whether data for a tile is available to be loaded.\n *\n * @param {Number} x The X coordinate of the tile for which to request geometry.\n * @param {Number} y The Y coordinate of the tile for which to request geometry.\n * @param {Number} level The level of the tile for which to request geometry.\n * @returns {Boolean|undefined} Undefined if not supported, otherwise true or false.\n */\nVRTheWorldTerrainProvider.prototype.getTileDataAvailable = function (\n  x,\n  y,\n  level\n) {\n  return undefined;\n};\n\n/**\n * Makes sure we load availability data for a tile\n *\n * @param {Number} x The X coordinate of the tile for which to request geometry.\n * @param {Number} y The Y coordinate of the tile for which to request geometry.\n * @param {Number} level The level of the tile for which to request geometry.\n * @returns {undefined|Promise<void>} Undefined if nothing need to be loaded or a Promise that resolves when all required tiles are loaded\n */\nVRTheWorldTerrainProvider.prototype.loadTileDataAvailability = function (\n  x,\n  y,\n  level\n) {\n  return undefined;\n};\n/* unused harmony default export */ var __WEBPACK_DEFAULT_EXPORT__ = ((/* unused pure expression or super */ null && (VRTheWorldTerrainProvider)));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFNBQVMsaUVBQU87QUFDaEIsSUFBSSx5RkFBc0I7QUFDMUI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixhQUFhLG1CQUFtQjtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLGFBQWEseUJBQXlCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzRUFBZSx5RUFBeUIsSUFBQyIsInNvdXJjZXMiOlsid2VicGFjazovL3Z1ZTMtd2VicGFjazUvLi9ub2RlX21vZHVsZXMvY2VzaXVtL1NvdXJjZS9Db3JlL1ZSVGhlV29ybGRUZXJyYWluUHJvdmlkZXIuanM/NWRhNiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgd2hlbiBmcm9tIFwiLi4vVGhpcmRQYXJ0eS93aGVuLmpzXCI7XG5pbXBvcnQgQ3JlZGl0IGZyb20gXCIuL0NyZWRpdC5qc1wiO1xuaW1wb3J0IGRlZmF1bHRWYWx1ZSBmcm9tIFwiLi9kZWZhdWx0VmFsdWUuanNcIjtcbmltcG9ydCBkZWZpbmVkIGZyb20gXCIuL2RlZmluZWQuanNcIjtcbmltcG9ydCBEZXZlbG9wZXJFcnJvciBmcm9tIFwiLi9EZXZlbG9wZXJFcnJvci5qc1wiO1xuaW1wb3J0IEVsbGlwc29pZCBmcm9tIFwiLi9FbGxpcHNvaWQuanNcIjtcbmltcG9ydCBFdmVudCBmcm9tIFwiLi9FdmVudC5qc1wiO1xuaW1wb3J0IEdlb2dyYXBoaWNUaWxpbmdTY2hlbWUgZnJvbSBcIi4vR2VvZ3JhcGhpY1RpbGluZ1NjaGVtZS5qc1wiO1xuaW1wb3J0IGdldEltYWdlUGl4ZWxzIGZyb20gXCIuL2dldEltYWdlUGl4ZWxzLmpzXCI7XG5pbXBvcnQgSGVpZ2h0bWFwVGVycmFpbkRhdGEgZnJvbSBcIi4vSGVpZ2h0bWFwVGVycmFpbkRhdGEuanNcIjtcbmltcG9ydCBDZXNpdW1NYXRoIGZyb20gXCIuL01hdGguanNcIjtcbmltcG9ydCBSZWN0YW5nbGUgZnJvbSBcIi4vUmVjdGFuZ2xlLmpzXCI7XG5pbXBvcnQgUmVzb3VyY2UgZnJvbSBcIi4vUmVzb3VyY2UuanNcIjtcbmltcG9ydCBUZXJyYWluUHJvdmlkZXIgZnJvbSBcIi4vVGVycmFpblByb3ZpZGVyLmpzXCI7XG5pbXBvcnQgVGlsZVByb3ZpZGVyRXJyb3IgZnJvbSBcIi4vVGlsZVByb3ZpZGVyRXJyb3IuanNcIjtcblxuZnVuY3Rpb24gRGF0YVJlY3RhbmdsZShyZWN0YW5nbGUsIG1heExldmVsKSB7XG4gIHRoaXMucmVjdGFuZ2xlID0gcmVjdGFuZ2xlO1xuICB0aGlzLm1heExldmVsID0gbWF4TGV2ZWw7XG59XG5cbi8qKlxuICogQSB7QGxpbmsgVGVycmFpblByb3ZpZGVyfSB0aGF0IHByb2R1Y2VzIHRlcnJhaW4gZ2VvbWV0cnkgYnkgdGVzc2VsbGF0aW5nIGhlaWdodCBtYXBzXG4gKiByZXRyaWV2ZWQgZnJvbSBhIHtAbGluayBodHRwOi8vdnItdGhld29ybGQuY29tL3xWVCBNw4RLIFZSLVRoZVdvcmxkIHNlcnZlcn0uXG4gKlxuICogQGFsaWFzIFZSVGhlV29ybGRUZXJyYWluUHJvdmlkZXJcbiAqIEBjb25zdHJ1Y3RvclxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIE9iamVjdCB3aXRoIHRoZSBmb2xsb3dpbmcgcHJvcGVydGllczpcbiAqIEBwYXJhbSB7UmVzb3VyY2V8U3RyaW5nfSBvcHRpb25zLnVybCBUaGUgVVJMIG9mIHRoZSBWUi1UaGVXb3JsZCBUaWxlTWFwLlxuICogQHBhcmFtIHtFbGxpcHNvaWR9IFtvcHRpb25zLmVsbGlwc29pZD1FbGxpcHNvaWQuV0dTODRdIFRoZSBlbGxpcHNvaWQuICBJZiB0aGlzIHBhcmFtZXRlciBpcyBub3RcbiAqICAgICAgICAgICAgICAgICAgICBzcGVjaWZpZWQsIHRoZSBXR1M4NCBlbGxpcHNvaWQgaXMgdXNlZC5cbiAqIEBwYXJhbSB7Q3JlZGl0fFN0cmluZ30gW29wdGlvbnMuY3JlZGl0XSBBIGNyZWRpdCBmb3IgdGhlIGRhdGEgc291cmNlLCB3aGljaCBpcyBkaXNwbGF5ZWQgb24gdGhlIGNhbnZhcy5cbiAqXG4gKlxuICogQGV4YW1wbGVcbiAqIHZhciB0ZXJyYWluUHJvdmlkZXIgPSBuZXcgQ2VzaXVtLlZSVGhlV29ybGRUZXJyYWluUHJvdmlkZXIoe1xuICogICB1cmwgOiAnaHR0cHM6Ly93d3cudnItdGhld29ybGQuY29tL3ZyLXRoZXdvcmxkL3RpbGVzMS4wLjAvNzMvJ1xuICogfSk7XG4gKiB2aWV3ZXIudGVycmFpblByb3ZpZGVyID0gdGVycmFpblByb3ZpZGVyO1xuICpcbiAqIEBzZWUgVGVycmFpblByb3ZpZGVyXG4gKi9cbmZ1bmN0aW9uIFZSVGhlV29ybGRUZXJyYWluUHJvdmlkZXIob3B0aW9ucykge1xuICBvcHRpb25zID0gZGVmYXVsdFZhbHVlKG9wdGlvbnMsIGRlZmF1bHRWYWx1ZS5FTVBUWV9PQkpFQ1QpO1xuICAvLz4+aW5jbHVkZVN0YXJ0KCdkZWJ1ZycsIHByYWdtYXMuZGVidWcpO1xuICBpZiAoIWRlZmluZWQob3B0aW9ucy51cmwpKSB7XG4gICAgdGhyb3cgbmV3IERldmVsb3BlckVycm9yKFwib3B0aW9ucy51cmwgaXMgcmVxdWlyZWQuXCIpO1xuICB9XG4gIC8vPj5pbmNsdWRlRW5kKCdkZWJ1ZycpO1xuXG4gIHZhciByZXNvdXJjZSA9IFJlc291cmNlLmNyZWF0ZUlmTmVlZGVkKG9wdGlvbnMudXJsKTtcblxuICB0aGlzLl9yZXNvdXJjZSA9IHJlc291cmNlO1xuXG4gIHRoaXMuX2Vycm9yRXZlbnQgPSBuZXcgRXZlbnQoKTtcbiAgdGhpcy5fcmVhZHkgPSBmYWxzZTtcbiAgdGhpcy5fcmVhZHlQcm9taXNlID0gd2hlbi5kZWZlcigpO1xuXG4gIHRoaXMuX3RlcnJhaW5EYXRhU3RydWN0dXJlID0ge1xuICAgIGhlaWdodFNjYWxlOiAxLjAgLyAxMDAwLjAsXG4gICAgaGVpZ2h0T2Zmc2V0OiAtMTAwMC4wLFxuICAgIGVsZW1lbnRzUGVySGVpZ2h0OiAzLFxuICAgIHN0cmlkZTogNCxcbiAgICBlbGVtZW50TXVsdGlwbGllcjogMjU2LjAsXG4gICAgaXNCaWdFbmRpYW46IHRydWUsXG4gICAgbG93ZXN0RW5jb2RlZEhlaWdodDogMCxcbiAgICBoaWdoZXN0RW5jb2RlZEhlaWdodDogMjU2ICogMjU2ICogMjU2IC0gMSxcbiAgfTtcblxuICB2YXIgY3JlZGl0ID0gb3B0aW9ucy5jcmVkaXQ7XG4gIGlmICh0eXBlb2YgY3JlZGl0ID09PSBcInN0cmluZ1wiKSB7XG4gICAgY3JlZGl0ID0gbmV3IENyZWRpdChjcmVkaXQpO1xuICB9XG4gIHRoaXMuX2NyZWRpdCA9IGNyZWRpdDtcblxuICB0aGlzLl90aWxpbmdTY2hlbWUgPSB1bmRlZmluZWQ7XG4gIHRoaXMuX3JlY3RhbmdsZXMgPSBbXTtcblxuICB2YXIgdGhhdCA9IHRoaXM7XG4gIHZhciBtZXRhZGF0YUVycm9yO1xuICB2YXIgZWxsaXBzb2lkID0gZGVmYXVsdFZhbHVlKG9wdGlvbnMuZWxsaXBzb2lkLCBFbGxpcHNvaWQuV0dTODQpO1xuXG4gIGZ1bmN0aW9uIG1ldGFkYXRhU3VjY2Vzcyh4bWwpIHtcbiAgICB2YXIgc3JzID0geG1sLmdldEVsZW1lbnRzQnlUYWdOYW1lKFwiU1JTXCIpWzBdLnRleHRDb250ZW50O1xuICAgIGlmIChzcnMgPT09IFwiRVBTRzo0MzI2XCIpIHtcbiAgICAgIHRoYXQuX3RpbGluZ1NjaGVtZSA9IG5ldyBHZW9ncmFwaGljVGlsaW5nU2NoZW1lKHsgZWxsaXBzb2lkOiBlbGxpcHNvaWQgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG1ldGFkYXRhRmFpbHVyZShcIlNSUyBcIiArIHNycyArIFwiIGlzIG5vdCBzdXBwb3J0ZWQuXCIpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciB0aWxlRm9ybWF0ID0geG1sLmdldEVsZW1lbnRzQnlUYWdOYW1lKFwiVGlsZUZvcm1hdFwiKVswXTtcbiAgICB0aGF0Ll9oZWlnaHRtYXBXaWR0aCA9IHBhcnNlSW50KHRpbGVGb3JtYXQuZ2V0QXR0cmlidXRlKFwid2lkdGhcIiksIDEwKTtcbiAgICB0aGF0Ll9oZWlnaHRtYXBIZWlnaHQgPSBwYXJzZUludCh0aWxlRm9ybWF0LmdldEF0dHJpYnV0ZShcImhlaWdodFwiKSwgMTApO1xuICAgIHRoYXQuX2xldmVsWmVyb01heGltdW1HZW9tZXRyaWNFcnJvciA9IFRlcnJhaW5Qcm92aWRlci5nZXRFc3RpbWF0ZWRMZXZlbFplcm9HZW9tZXRyaWNFcnJvckZvckFIZWlnaHRtYXAoXG4gICAgICBlbGxpcHNvaWQsXG4gICAgICBNYXRoLm1pbih0aGF0Ll9oZWlnaHRtYXBXaWR0aCwgdGhhdC5faGVpZ2h0bWFwSGVpZ2h0KSxcbiAgICAgIHRoYXQuX3RpbGluZ1NjaGVtZS5nZXROdW1iZXJPZlhUaWxlc0F0TGV2ZWwoMClcbiAgICApO1xuXG4gICAgdmFyIGRhdGFSZWN0YW5nbGVzID0geG1sLmdldEVsZW1lbnRzQnlUYWdOYW1lKFwiRGF0YUV4dGVudFwiKTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZGF0YVJlY3RhbmdsZXMubGVuZ3RoOyArK2kpIHtcbiAgICAgIHZhciBkYXRhUmVjdGFuZ2xlID0gZGF0YVJlY3RhbmdsZXNbaV07XG5cbiAgICAgIHZhciB3ZXN0ID0gQ2VzaXVtTWF0aC50b1JhZGlhbnMoXG4gICAgICAgIHBhcnNlRmxvYXQoZGF0YVJlY3RhbmdsZS5nZXRBdHRyaWJ1dGUoXCJtaW54XCIpKVxuICAgICAgKTtcbiAgICAgIHZhciBzb3V0aCA9IENlc2l1bU1hdGgudG9SYWRpYW5zKFxuICAgICAgICBwYXJzZUZsb2F0KGRhdGFSZWN0YW5nbGUuZ2V0QXR0cmlidXRlKFwibWlueVwiKSlcbiAgICAgICk7XG4gICAgICB2YXIgZWFzdCA9IENlc2l1bU1hdGgudG9SYWRpYW5zKFxuICAgICAgICBwYXJzZUZsb2F0KGRhdGFSZWN0YW5nbGUuZ2V0QXR0cmlidXRlKFwibWF4eFwiKSlcbiAgICAgICk7XG4gICAgICB2YXIgbm9ydGggPSBDZXNpdW1NYXRoLnRvUmFkaWFucyhcbiAgICAgICAgcGFyc2VGbG9hdChkYXRhUmVjdGFuZ2xlLmdldEF0dHJpYnV0ZShcIm1heHlcIikpXG4gICAgICApO1xuICAgICAgdmFyIG1heExldmVsID0gcGFyc2VJbnQoZGF0YVJlY3RhbmdsZS5nZXRBdHRyaWJ1dGUoXCJtYXhsZXZlbFwiKSwgMTApO1xuXG4gICAgICB0aGF0Ll9yZWN0YW5nbGVzLnB1c2goXG4gICAgICAgIG5ldyBEYXRhUmVjdGFuZ2xlKG5ldyBSZWN0YW5nbGUod2VzdCwgc291dGgsIGVhc3QsIG5vcnRoKSwgbWF4TGV2ZWwpXG4gICAgICApO1xuICAgIH1cblxuICAgIHRoYXQuX3JlYWR5ID0gdHJ1ZTtcbiAgICB0aGF0Ll9yZWFkeVByb21pc2UucmVzb2x2ZSh0cnVlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIG1ldGFkYXRhRmFpbHVyZShlKSB7XG4gICAgdmFyIG1lc3NhZ2UgPSBkZWZhdWx0VmFsdWUoXG4gICAgICBlLFxuICAgICAgXCJBbiBlcnJvciBvY2N1cnJlZCB3aGlsZSBhY2Nlc3NpbmcgXCIgKyB0aGF0Ll9yZXNvdXJjZS51cmwgKyBcIi5cIlxuICAgICk7XG4gICAgbWV0YWRhdGFFcnJvciA9IFRpbGVQcm92aWRlckVycm9yLmhhbmRsZUVycm9yKFxuICAgICAgbWV0YWRhdGFFcnJvcixcbiAgICAgIHRoYXQsXG4gICAgICB0aGF0Ll9lcnJvckV2ZW50LFxuICAgICAgbWVzc2FnZSxcbiAgICAgIHVuZGVmaW5lZCxcbiAgICAgIHVuZGVmaW5lZCxcbiAgICAgIHVuZGVmaW5lZCxcbiAgICAgIHJlcXVlc3RNZXRhZGF0YVxuICAgICk7XG4gIH1cblxuICBmdW5jdGlvbiByZXF1ZXN0TWV0YWRhdGEoKSB7XG4gICAgd2hlbih0aGF0Ll9yZXNvdXJjZS5mZXRjaFhNTCgpLCBtZXRhZGF0YVN1Y2Nlc3MsIG1ldGFkYXRhRmFpbHVyZSk7XG4gIH1cblxuICByZXF1ZXN0TWV0YWRhdGEoKTtcbn1cblxuT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoVlJUaGVXb3JsZFRlcnJhaW5Qcm92aWRlci5wcm90b3R5cGUsIHtcbiAgLyoqXG4gICAqIEdldHMgYW4gZXZlbnQgdGhhdCBpcyByYWlzZWQgd2hlbiB0aGUgdGVycmFpbiBwcm92aWRlciBlbmNvdW50ZXJzIGFuIGFzeW5jaHJvbm91cyBlcnJvci4gIEJ5IHN1YnNjcmliaW5nXG4gICAqIHRvIHRoZSBldmVudCwgeW91IHdpbGwgYmUgbm90aWZpZWQgb2YgdGhlIGVycm9yIGFuZCBjYW4gcG90ZW50aWFsbHkgcmVjb3ZlciBmcm9tIGl0LiAgRXZlbnQgbGlzdGVuZXJzXG4gICAqIGFyZSBwYXNzZWQgYW4gaW5zdGFuY2Ugb2Yge0BsaW5rIFRpbGVQcm92aWRlckVycm9yfS5cbiAgICogQG1lbWJlcm9mIFZSVGhlV29ybGRUZXJyYWluUHJvdmlkZXIucHJvdG90eXBlXG4gICAqIEB0eXBlIHtFdmVudH1cbiAgICogQHJlYWRvbmx5XG4gICAqL1xuICBlcnJvckV2ZW50OiB7XG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fZXJyb3JFdmVudDtcbiAgICB9LFxuICB9LFxuXG4gIC8qKlxuICAgKiBHZXRzIHRoZSBjcmVkaXQgdG8gZGlzcGxheSB3aGVuIHRoaXMgdGVycmFpbiBwcm92aWRlciBpcyBhY3RpdmUuICBUeXBpY2FsbHkgdGhpcyBpcyB1c2VkIHRvIGNyZWRpdFxuICAgKiB0aGUgc291cmNlIG9mIHRoZSB0ZXJyYWluLiAgVGhpcyBmdW5jdGlvbiBzaG91bGQgbm90IGJlIGNhbGxlZCBiZWZvcmUge0BsaW5rIFZSVGhlV29ybGRUZXJyYWluUHJvdmlkZXIjcmVhZHl9IHJldHVybnMgdHJ1ZS5cbiAgICogQG1lbWJlcm9mIFZSVGhlV29ybGRUZXJyYWluUHJvdmlkZXIucHJvdG90eXBlXG4gICAqIEB0eXBlIHtDcmVkaXR9XG4gICAqIEByZWFkb25seVxuICAgKi9cbiAgY3JlZGl0OiB7XG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fY3JlZGl0O1xuICAgIH0sXG4gIH0sXG5cbiAgLyoqXG4gICAqIEdldHMgdGhlIHRpbGluZyBzY2hlbWUgdXNlZCBieSB0aGlzIHByb3ZpZGVyLiAgVGhpcyBmdW5jdGlvbiBzaG91bGRcbiAgICogbm90IGJlIGNhbGxlZCBiZWZvcmUge0BsaW5rIFZSVGhlV29ybGRUZXJyYWluUHJvdmlkZXIjcmVhZHl9IHJldHVybnMgdHJ1ZS5cbiAgICogQG1lbWJlcm9mIFZSVGhlV29ybGRUZXJyYWluUHJvdmlkZXIucHJvdG90eXBlXG4gICAqIEB0eXBlIHtHZW9ncmFwaGljVGlsaW5nU2NoZW1lfVxuICAgKiBAcmVhZG9ubHlcbiAgICovXG4gIHRpbGluZ1NjaGVtZToge1xuICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgLy8+PmluY2x1ZGVTdGFydCgnZGVidWcnLCBwcmFnbWFzLmRlYnVnKTtcbiAgICAgIGlmICghdGhpcy5yZWFkeSkge1xuICAgICAgICB0aHJvdyBuZXcgRGV2ZWxvcGVyRXJyb3IoXG4gICAgICAgICAgXCJyZXF1ZXN0VGlsZUdlb21ldHJ5IG11c3Qgbm90IGJlIGNhbGxlZCBiZWZvcmUgcmVhZHkgcmV0dXJucyB0cnVlLlwiXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICAvLz4+aW5jbHVkZUVuZCgnZGVidWcnKTtcblxuICAgICAgcmV0dXJuIHRoaXMuX3RpbGluZ1NjaGVtZTtcbiAgICB9LFxuICB9LFxuXG4gIC8qKlxuICAgKiBHZXRzIGEgdmFsdWUgaW5kaWNhdGluZyB3aGV0aGVyIG9yIG5vdCB0aGUgcHJvdmlkZXIgaXMgcmVhZHkgZm9yIHVzZS5cbiAgICogQG1lbWJlcm9mIFZSVGhlV29ybGRUZXJyYWluUHJvdmlkZXIucHJvdG90eXBlXG4gICAqIEB0eXBlIHtCb29sZWFufVxuICAgKiBAcmVhZG9ubHlcbiAgICovXG4gIHJlYWR5OiB7XG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fcmVhZHk7XG4gICAgfSxcbiAgfSxcblxuICAvKipcbiAgICogR2V0cyBhIHByb21pc2UgdGhhdCByZXNvbHZlcyB0byB0cnVlIHdoZW4gdGhlIHByb3ZpZGVyIGlzIHJlYWR5IGZvciB1c2UuXG4gICAqIEBtZW1iZXJvZiBWUlRoZVdvcmxkVGVycmFpblByb3ZpZGVyLnByb3RvdHlwZVxuICAgKiBAdHlwZSB7UHJvbWlzZS48Qm9vbGVhbj59XG4gICAqIEByZWFkb25seVxuICAgKi9cbiAgcmVhZHlQcm9taXNlOiB7XG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fcmVhZHlQcm9taXNlLnByb21pc2U7XG4gICAgfSxcbiAgfSxcblxuICAvKipcbiAgICogR2V0cyBhIHZhbHVlIGluZGljYXRpbmcgd2hldGhlciBvciBub3QgdGhlIHByb3ZpZGVyIGluY2x1ZGVzIGEgd2F0ZXIgbWFzay4gIFRoZSB3YXRlciBtYXNrXG4gICAqIGluZGljYXRlcyB3aGljaCBhcmVhcyBvZiB0aGUgZ2xvYmUgYXJlIHdhdGVyIHJhdGhlciB0aGFuIGxhbmQsIHNvIHRoZXkgY2FuIGJlIHJlbmRlcmVkXG4gICAqIGFzIGEgcmVmbGVjdGl2ZSBzdXJmYWNlIHdpdGggYW5pbWF0ZWQgd2F2ZXMuICBUaGlzIGZ1bmN0aW9uIHNob3VsZCBub3QgYmVcbiAgICogY2FsbGVkIGJlZm9yZSB7QGxpbmsgVlJUaGVXb3JsZFRlcnJhaW5Qcm92aWRlciNyZWFkeX0gcmV0dXJucyB0cnVlLlxuICAgKiBAbWVtYmVyb2YgVlJUaGVXb3JsZFRlcnJhaW5Qcm92aWRlci5wcm90b3R5cGVcbiAgICogQHR5cGUge0Jvb2xlYW59XG4gICAqIEByZWFkb25seVxuICAgKi9cbiAgaGFzV2F0ZXJNYXNrOiB7XG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSxcbiAgfSxcblxuICAvKipcbiAgICogR2V0cyBhIHZhbHVlIGluZGljYXRpbmcgd2hldGhlciBvciBub3QgdGhlIHJlcXVlc3RlZCB0aWxlcyBpbmNsdWRlIHZlcnRleCBub3JtYWxzLlxuICAgKiBUaGlzIGZ1bmN0aW9uIHNob3VsZCBub3QgYmUgY2FsbGVkIGJlZm9yZSB7QGxpbmsgVlJUaGVXb3JsZFRlcnJhaW5Qcm92aWRlciNyZWFkeX0gcmV0dXJucyB0cnVlLlxuICAgKiBAbWVtYmVyb2YgVlJUaGVXb3JsZFRlcnJhaW5Qcm92aWRlci5wcm90b3R5cGVcbiAgICogQHR5cGUge0Jvb2xlYW59XG4gICAqIEByZWFkb25seVxuICAgKi9cbiAgaGFzVmVydGV4Tm9ybWFsczoge1xuICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0sXG4gIH0sXG4gIC8qKlxuICAgKiBHZXRzIGFuIG9iamVjdCB0aGF0IGNhbiBiZSB1c2VkIHRvIGRldGVybWluZSBhdmFpbGFiaWxpdHkgb2YgdGVycmFpbiBmcm9tIHRoaXMgcHJvdmlkZXIsIHN1Y2ggYXNcbiAgICogYXQgcG9pbnRzIGFuZCBpbiByZWN0YW5nbGVzLiAgVGhpcyBmdW5jdGlvbiBzaG91bGQgbm90IGJlIGNhbGxlZCBiZWZvcmVcbiAgICoge0BsaW5rIFRlcnJhaW5Qcm92aWRlciNyZWFkeX0gcmV0dXJucyB0cnVlLiAgVGhpcyBwcm9wZXJ0eSBtYXkgYmUgdW5kZWZpbmVkIGlmIGF2YWlsYWJpbGl0eVxuICAgKiBpbmZvcm1hdGlvbiBpcyBub3QgYXZhaWxhYmxlLlxuICAgKiBAbWVtYmVyb2YgVlJUaGVXb3JsZFRlcnJhaW5Qcm92aWRlci5wcm90b3R5cGVcbiAgICogQHR5cGUge1RpbGVBdmFpbGFiaWxpdHl9XG4gICAqIEByZWFkb25seVxuICAgKi9cbiAgYXZhaWxhYmlsaXR5OiB7XG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH0sXG4gIH0sXG59KTtcblxuLyoqXG4gKiBSZXF1ZXN0cyB0aGUgZ2VvbWV0cnkgZm9yIGEgZ2l2ZW4gdGlsZS4gIFRoaXMgZnVuY3Rpb24gc2hvdWxkIG5vdCBiZSBjYWxsZWQgYmVmb3JlXG4gKiB7QGxpbmsgVlJUaGVXb3JsZFRlcnJhaW5Qcm92aWRlciNyZWFkeX0gcmV0dXJucyB0cnVlLiAgVGhlIHJlc3VsdCBpbmNsdWRlcyB0ZXJyYWluXG4gKiBkYXRhIGFuZCBpbmRpY2F0ZXMgdGhhdCBhbGwgY2hpbGQgdGlsZXMgYXJlIGF2YWlsYWJsZS5cbiAqXG4gKiBAcGFyYW0ge051bWJlcn0geCBUaGUgWCBjb29yZGluYXRlIG9mIHRoZSB0aWxlIGZvciB3aGljaCB0byByZXF1ZXN0IGdlb21ldHJ5LlxuICogQHBhcmFtIHtOdW1iZXJ9IHkgVGhlIFkgY29vcmRpbmF0ZSBvZiB0aGUgdGlsZSBmb3Igd2hpY2ggdG8gcmVxdWVzdCBnZW9tZXRyeS5cbiAqIEBwYXJhbSB7TnVtYmVyfSBsZXZlbCBUaGUgbGV2ZWwgb2YgdGhlIHRpbGUgZm9yIHdoaWNoIHRvIHJlcXVlc3QgZ2VvbWV0cnkuXG4gKiBAcGFyYW0ge1JlcXVlc3R9IFtyZXF1ZXN0XSBUaGUgcmVxdWVzdCBvYmplY3QuIEludGVuZGVkIGZvciBpbnRlcm5hbCB1c2Ugb25seS5cbiAqIEByZXR1cm5zIHtQcm9taXNlLjxUZXJyYWluRGF0YT58dW5kZWZpbmVkfSBBIHByb21pc2UgZm9yIHRoZSByZXF1ZXN0ZWQgZ2VvbWV0cnkuICBJZiB0aGlzIG1ldGhvZFxuICogICAgICAgICAgcmV0dXJucyB1bmRlZmluZWQgaW5zdGVhZCBvZiBhIHByb21pc2UsIGl0IGlzIGFuIGluZGljYXRpb24gdGhhdCB0b28gbWFueSByZXF1ZXN0cyBhcmUgYWxyZWFkeVxuICogICAgICAgICAgcGVuZGluZyBhbmQgdGhlIHJlcXVlc3Qgd2lsbCBiZSByZXRyaWVkIGxhdGVyLlxuICovXG5WUlRoZVdvcmxkVGVycmFpblByb3ZpZGVyLnByb3RvdHlwZS5yZXF1ZXN0VGlsZUdlb21ldHJ5ID0gZnVuY3Rpb24gKFxuICB4LFxuICB5LFxuICBsZXZlbCxcbiAgcmVxdWVzdFxuKSB7XG4gIC8vPj5pbmNsdWRlU3RhcnQoJ2RlYnVnJywgcHJhZ21hcy5kZWJ1Zyk7XG4gIGlmICghdGhpcy5yZWFkeSkge1xuICAgIHRocm93IG5ldyBEZXZlbG9wZXJFcnJvcihcbiAgICAgIFwicmVxdWVzdFRpbGVHZW9tZXRyeSBtdXN0IG5vdCBiZSBjYWxsZWQgYmVmb3JlIHJlYWR5IHJldHVybnMgdHJ1ZS5cIlxuICAgICk7XG4gIH1cbiAgLy8+PmluY2x1ZGVFbmQoJ2RlYnVnJyk7XG5cbiAgdmFyIHlUaWxlcyA9IHRoaXMuX3RpbGluZ1NjaGVtZS5nZXROdW1iZXJPZllUaWxlc0F0TGV2ZWwobGV2ZWwpO1xuICB2YXIgcmVzb3VyY2UgPSB0aGlzLl9yZXNvdXJjZS5nZXREZXJpdmVkUmVzb3VyY2Uoe1xuICAgIHVybDogbGV2ZWwgKyBcIi9cIiArIHggKyBcIi9cIiArICh5VGlsZXMgLSB5IC0gMSkgKyBcIi50aWZcIixcbiAgICBxdWVyeVBhcmFtZXRlcnM6IHtcbiAgICAgIGNlc2l1bTogdHJ1ZSxcbiAgICB9LFxuICAgIHJlcXVlc3Q6IHJlcXVlc3QsXG4gIH0pO1xuICB2YXIgcHJvbWlzZSA9IHJlc291cmNlLmZldGNoSW1hZ2Uoe1xuICAgIHByZWZlckltYWdlQml0bWFwOiB0cnVlLFxuICB9KTtcbiAgaWYgKCFkZWZpbmVkKHByb21pc2UpKSB7XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxuXG4gIHZhciB0aGF0ID0gdGhpcztcbiAgcmV0dXJuIHdoZW4ocHJvbWlzZSkudGhlbihmdW5jdGlvbiAoaW1hZ2UpIHtcbiAgICByZXR1cm4gbmV3IEhlaWdodG1hcFRlcnJhaW5EYXRhKHtcbiAgICAgIGJ1ZmZlcjogZ2V0SW1hZ2VQaXhlbHMoaW1hZ2UpLFxuICAgICAgd2lkdGg6IHRoYXQuX2hlaWdodG1hcFdpZHRoLFxuICAgICAgaGVpZ2h0OiB0aGF0Ll9oZWlnaHRtYXBIZWlnaHQsXG4gICAgICBjaGlsZFRpbGVNYXNrOiBnZXRDaGlsZE1hc2sodGhhdCwgeCwgeSwgbGV2ZWwpLFxuICAgICAgc3RydWN0dXJlOiB0aGF0Ll90ZXJyYWluRGF0YVN0cnVjdHVyZSxcbiAgICB9KTtcbiAgfSk7XG59O1xuXG4vKipcbiAqIEdldHMgdGhlIG1heGltdW0gZ2VvbWV0cmljIGVycm9yIGFsbG93ZWQgaW4gYSB0aWxlIGF0IGEgZ2l2ZW4gbGV2ZWwuXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IGxldmVsIFRoZSB0aWxlIGxldmVsIGZvciB3aGljaCB0byBnZXQgdGhlIG1heGltdW0gZ2VvbWV0cmljIGVycm9yLlxuICogQHJldHVybnMge051bWJlcn0gVGhlIG1heGltdW0gZ2VvbWV0cmljIGVycm9yLlxuICovXG5WUlRoZVdvcmxkVGVycmFpblByb3ZpZGVyLnByb3RvdHlwZS5nZXRMZXZlbE1heGltdW1HZW9tZXRyaWNFcnJvciA9IGZ1bmN0aW9uIChcbiAgbGV2ZWxcbikge1xuICAvLz4+aW5jbHVkZVN0YXJ0KCdkZWJ1ZycsIHByYWdtYXMuZGVidWcpO1xuICBpZiAoIXRoaXMucmVhZHkpIHtcbiAgICB0aHJvdyBuZXcgRGV2ZWxvcGVyRXJyb3IoXG4gICAgICBcInJlcXVlc3RUaWxlR2VvbWV0cnkgbXVzdCBub3QgYmUgY2FsbGVkIGJlZm9yZSByZWFkeSByZXR1cm5zIHRydWUuXCJcbiAgICApO1xuICB9XG4gIC8vPj5pbmNsdWRlRW5kKCdkZWJ1ZycpO1xuICByZXR1cm4gdGhpcy5fbGV2ZWxaZXJvTWF4aW11bUdlb21ldHJpY0Vycm9yIC8gKDEgPDwgbGV2ZWwpO1xufTtcblxudmFyIHJlY3RhbmdsZVNjcmF0Y2ggPSBuZXcgUmVjdGFuZ2xlKCk7XG5cbmZ1bmN0aW9uIGdldENoaWxkTWFzayhwcm92aWRlciwgeCwgeSwgbGV2ZWwpIHtcbiAgdmFyIHRpbGluZ1NjaGVtZSA9IHByb3ZpZGVyLl90aWxpbmdTY2hlbWU7XG4gIHZhciByZWN0YW5nbGVzID0gcHJvdmlkZXIuX3JlY3RhbmdsZXM7XG4gIHZhciBwYXJlbnRSZWN0YW5nbGUgPSB0aWxpbmdTY2hlbWUudGlsZVhZVG9SZWN0YW5nbGUoeCwgeSwgbGV2ZWwpO1xuXG4gIHZhciBjaGlsZE1hc2sgPSAwO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcmVjdGFuZ2xlcy5sZW5ndGggJiYgY2hpbGRNYXNrICE9PSAxNTsgKytpKSB7XG4gICAgdmFyIHJlY3RhbmdsZSA9IHJlY3RhbmdsZXNbaV07XG4gICAgaWYgKHJlY3RhbmdsZS5tYXhMZXZlbCA8PSBsZXZlbCkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgdmFyIHRlc3RSZWN0YW5nbGUgPSByZWN0YW5nbGUucmVjdGFuZ2xlO1xuXG4gICAgdmFyIGludGVyc2VjdGlvbiA9IFJlY3RhbmdsZS5pbnRlcnNlY3Rpb24oXG4gICAgICB0ZXN0UmVjdGFuZ2xlLFxuICAgICAgcGFyZW50UmVjdGFuZ2xlLFxuICAgICAgcmVjdGFuZ2xlU2NyYXRjaFxuICAgICk7XG4gICAgaWYgKGRlZmluZWQoaW50ZXJzZWN0aW9uKSkge1xuICAgICAgLy8gUGFyZW50IHRpbGUgaXMgaW5zaWRlIHRoaXMgcmVjdGFuZ2xlLCBzbyBhdCBsZWFzdCBvbmUgY2hpbGQgaXMsIHRvby5cbiAgICAgIGlmIChcbiAgICAgICAgaXNUaWxlSW5SZWN0YW5nbGUodGlsaW5nU2NoZW1lLCB0ZXN0UmVjdGFuZ2xlLCB4ICogMiwgeSAqIDIsIGxldmVsICsgMSlcbiAgICAgICkge1xuICAgICAgICBjaGlsZE1hc2sgfD0gNDsgLy8gbm9ydGh3ZXN0XG4gICAgICB9XG4gICAgICBpZiAoXG4gICAgICAgIGlzVGlsZUluUmVjdGFuZ2xlKFxuICAgICAgICAgIHRpbGluZ1NjaGVtZSxcbiAgICAgICAgICB0ZXN0UmVjdGFuZ2xlLFxuICAgICAgICAgIHggKiAyICsgMSxcbiAgICAgICAgICB5ICogMixcbiAgICAgICAgICBsZXZlbCArIDFcbiAgICAgICAgKVxuICAgICAgKSB7XG4gICAgICAgIGNoaWxkTWFzayB8PSA4OyAvLyBub3J0aGVhc3RcbiAgICAgIH1cbiAgICAgIGlmIChcbiAgICAgICAgaXNUaWxlSW5SZWN0YW5nbGUoXG4gICAgICAgICAgdGlsaW5nU2NoZW1lLFxuICAgICAgICAgIHRlc3RSZWN0YW5nbGUsXG4gICAgICAgICAgeCAqIDIsXG4gICAgICAgICAgeSAqIDIgKyAxLFxuICAgICAgICAgIGxldmVsICsgMVxuICAgICAgICApXG4gICAgICApIHtcbiAgICAgICAgY2hpbGRNYXNrIHw9IDE7IC8vIHNvdXRod2VzdFxuICAgICAgfVxuICAgICAgaWYgKFxuICAgICAgICBpc1RpbGVJblJlY3RhbmdsZShcbiAgICAgICAgICB0aWxpbmdTY2hlbWUsXG4gICAgICAgICAgdGVzdFJlY3RhbmdsZSxcbiAgICAgICAgICB4ICogMiArIDEsXG4gICAgICAgICAgeSAqIDIgKyAxLFxuICAgICAgICAgIGxldmVsICsgMVxuICAgICAgICApXG4gICAgICApIHtcbiAgICAgICAgY2hpbGRNYXNrIHw9IDI7IC8vIHNvdXRoZWFzdFxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBjaGlsZE1hc2s7XG59XG5cbmZ1bmN0aW9uIGlzVGlsZUluUmVjdGFuZ2xlKHRpbGluZ1NjaGVtZSwgcmVjdGFuZ2xlLCB4LCB5LCBsZXZlbCkge1xuICB2YXIgdGlsZVJlY3RhbmdsZSA9IHRpbGluZ1NjaGVtZS50aWxlWFlUb1JlY3RhbmdsZSh4LCB5LCBsZXZlbCk7XG4gIHJldHVybiBkZWZpbmVkKFxuICAgIFJlY3RhbmdsZS5pbnRlcnNlY3Rpb24odGlsZVJlY3RhbmdsZSwgcmVjdGFuZ2xlLCByZWN0YW5nbGVTY3JhdGNoKVxuICApO1xufVxuXG4vKipcbiAqIERldGVybWluZXMgd2hldGhlciBkYXRhIGZvciBhIHRpbGUgaXMgYXZhaWxhYmxlIHRvIGJlIGxvYWRlZC5cbiAqXG4gKiBAcGFyYW0ge051bWJlcn0geCBUaGUgWCBjb29yZGluYXRlIG9mIHRoZSB0aWxlIGZvciB3aGljaCB0byByZXF1ZXN0IGdlb21ldHJ5LlxuICogQHBhcmFtIHtOdW1iZXJ9IHkgVGhlIFkgY29vcmRpbmF0ZSBvZiB0aGUgdGlsZSBmb3Igd2hpY2ggdG8gcmVxdWVzdCBnZW9tZXRyeS5cbiAqIEBwYXJhbSB7TnVtYmVyfSBsZXZlbCBUaGUgbGV2ZWwgb2YgdGhlIHRpbGUgZm9yIHdoaWNoIHRvIHJlcXVlc3QgZ2VvbWV0cnkuXG4gKiBAcmV0dXJucyB7Qm9vbGVhbnx1bmRlZmluZWR9IFVuZGVmaW5lZCBpZiBub3Qgc3VwcG9ydGVkLCBvdGhlcndpc2UgdHJ1ZSBvciBmYWxzZS5cbiAqL1xuVlJUaGVXb3JsZFRlcnJhaW5Qcm92aWRlci5wcm90b3R5cGUuZ2V0VGlsZURhdGFBdmFpbGFibGUgPSBmdW5jdGlvbiAoXG4gIHgsXG4gIHksXG4gIGxldmVsXG4pIHtcbiAgcmV0dXJuIHVuZGVmaW5lZDtcbn07XG5cbi8qKlxuICogTWFrZXMgc3VyZSB3ZSBsb2FkIGF2YWlsYWJpbGl0eSBkYXRhIGZvciBhIHRpbGVcbiAqXG4gKiBAcGFyYW0ge051bWJlcn0geCBUaGUgWCBjb29yZGluYXRlIG9mIHRoZSB0aWxlIGZvciB3aGljaCB0byByZXF1ZXN0IGdlb21ldHJ5LlxuICogQHBhcmFtIHtOdW1iZXJ9IHkgVGhlIFkgY29vcmRpbmF0ZSBvZiB0aGUgdGlsZSBmb3Igd2hpY2ggdG8gcmVxdWVzdCBnZW9tZXRyeS5cbiAqIEBwYXJhbSB7TnVtYmVyfSBsZXZlbCBUaGUgbGV2ZWwgb2YgdGhlIHRpbGUgZm9yIHdoaWNoIHRvIHJlcXVlc3QgZ2VvbWV0cnkuXG4gKiBAcmV0dXJucyB7dW5kZWZpbmVkfFByb21pc2U8dm9pZD59IFVuZGVmaW5lZCBpZiBub3RoaW5nIG5lZWQgdG8gYmUgbG9hZGVkIG9yIGEgUHJvbWlzZSB0aGF0IHJlc29sdmVzIHdoZW4gYWxsIHJlcXVpcmVkIHRpbGVzIGFyZSBsb2FkZWRcbiAqL1xuVlJUaGVXb3JsZFRlcnJhaW5Qcm92aWRlci5wcm90b3R5cGUubG9hZFRpbGVEYXRhQXZhaWxhYmlsaXR5ID0gZnVuY3Rpb24gKFxuICB4LFxuICB5LFxuICBsZXZlbFxuKSB7XG4gIHJldHVybiB1bmRlZmluZWQ7XG59O1xuZXhwb3J0IGRlZmF1bHQgVlJUaGVXb3JsZFRlcnJhaW5Qcm92aWRlcjtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///15243\n')},67252:function(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__){eval('/* harmony import */ var _defaultValue_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(62200);\n/* harmony import */ var _defined_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(82982);\n/* harmony import */ var _DeveloperError_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(12572);\n\n\n\n\n/**\n * A vertex format defines what attributes make up a vertex.  A VertexFormat can be provided\n * to a {@link Geometry} to request that certain properties be computed, e.g., just position,\n * position and normal, etc.\n *\n * @param {Object} [options] An object with boolean properties corresponding to VertexFormat properties as shown in the code example.\n *\n * @alias VertexFormat\n * @constructor\n *\n * @example\n * // Create a vertex format with position and 2D texture coordinate attributes.\n * var format = new Cesium.VertexFormat({\n *   position : true,\n *   st : true\n * });\n *\n * @see Geometry#attributes\n * @see Packable\n */\nfunction VertexFormat(options) {\n  options = (0,_defaultValue_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .Z)(options, _defaultValue_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].EMPTY_OBJECT */ .Z.EMPTY_OBJECT);\n\n  /**\n   * When <code>true</code>, the vertex has a 3D position attribute.\n   * <p>\n   * 64-bit floating-point (for precision).  3 components per attribute.\n   * </p>\n   *\n   * @type Boolean\n   *\n   * @default false\n   */\n  this.position = (0,_defaultValue_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .Z)(options.position, false);\n\n  /**\n   * When <code>true</code>, the vertex has a normal attribute (normalized), which is commonly used for lighting.\n   * <p>\n   * 32-bit floating-point.  3 components per attribute.\n   * </p>\n   *\n   * @type Boolean\n   *\n   * @default false\n   */\n  this.normal = (0,_defaultValue_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .Z)(options.normal, false);\n\n  /**\n   * When <code>true</code>, the vertex has a 2D texture coordinate attribute.\n   * <p>\n   * 32-bit floating-point.  2 components per attribute\n   * </p>\n   *\n   * @type Boolean\n   *\n   * @default false\n   */\n  this.st = (0,_defaultValue_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .Z)(options.st, false);\n\n  /**\n   * When <code>true</code>, the vertex has a bitangent attribute (normalized), which is used for tangent-space effects like bump mapping.\n   * <p>\n   * 32-bit floating-point.  3 components per attribute.\n   * </p>\n   *\n   * @type Boolean\n   *\n   * @default false\n   */\n  this.bitangent = (0,_defaultValue_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .Z)(options.bitangent, false);\n\n  /**\n   * When <code>true</code>, the vertex has a tangent attribute (normalized), which is used for tangent-space effects like bump mapping.\n   * <p>\n   * 32-bit floating-point.  3 components per attribute.\n   * </p>\n   *\n   * @type Boolean\n   *\n   * @default false\n   */\n  this.tangent = (0,_defaultValue_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .Z)(options.tangent, false);\n\n  /**\n   * When <code>true</code>, the vertex has an RGB color attribute.\n   * <p>\n   * 8-bit unsigned byte.  3 components per attribute.\n   * </p>\n   *\n   * @type Boolean\n   *\n   * @default false\n   */\n  this.color = (0,_defaultValue_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .Z)(options.color, false);\n}\n\n/**\n * An immutable vertex format with only a position attribute.\n *\n * @type {VertexFormat}\n * @constant\n *\n * @see VertexFormat#position\n */\nVertexFormat.POSITION_ONLY = Object.freeze(\n  new VertexFormat({\n    position: true,\n  })\n);\n\n/**\n * An immutable vertex format with position and normal attributes.\n * This is compatible with per-instance color appearances like {@link PerInstanceColorAppearance}.\n *\n * @type {VertexFormat}\n * @constant\n *\n * @see VertexFormat#position\n * @see VertexFormat#normal\n */\nVertexFormat.POSITION_AND_NORMAL = Object.freeze(\n  new VertexFormat({\n    position: true,\n    normal: true,\n  })\n);\n\n/**\n * An immutable vertex format with position, normal, and st attributes.\n * This is compatible with {@link MaterialAppearance} when {@link MaterialAppearance#materialSupport}\n * is <code>TEXTURED/code>.\n *\n * @type {VertexFormat}\n * @constant\n *\n * @see VertexFormat#position\n * @see VertexFormat#normal\n * @see VertexFormat#st\n */\nVertexFormat.POSITION_NORMAL_AND_ST = Object.freeze(\n  new VertexFormat({\n    position: true,\n    normal: true,\n    st: true,\n  })\n);\n\n/**\n * An immutable vertex format with position and st attributes.\n * This is compatible with {@link EllipsoidSurfaceAppearance}.\n *\n * @type {VertexFormat}\n * @constant\n *\n * @see VertexFormat#position\n * @see VertexFormat#st\n */\nVertexFormat.POSITION_AND_ST = Object.freeze(\n  new VertexFormat({\n    position: true,\n    st: true,\n  })\n);\n\n/**\n * An immutable vertex format with position and color attributes.\n *\n * @type {VertexFormat}\n * @constant\n *\n * @see VertexFormat#position\n * @see VertexFormat#color\n */\nVertexFormat.POSITION_AND_COLOR = Object.freeze(\n  new VertexFormat({\n    position: true,\n    color: true,\n  })\n);\n\n/**\n * An immutable vertex format with well-known attributes: position, normal, st, tangent, and bitangent.\n *\n * @type {VertexFormat}\n * @constant\n *\n * @see VertexFormat#position\n * @see VertexFormat#normal\n * @see VertexFormat#st\n * @see VertexFormat#tangent\n * @see VertexFormat#bitangent\n */\nVertexFormat.ALL = Object.freeze(\n  new VertexFormat({\n    position: true,\n    normal: true,\n    st: true,\n    tangent: true,\n    bitangent: true,\n  })\n);\n\n/**\n * An immutable vertex format with position, normal, and st attributes.\n * This is compatible with most appearances and materials; however\n * normal and st attributes are not always required.  When this is\n * known in advance, another <code>VertexFormat</code> should be used.\n *\n * @type {VertexFormat}\n * @constant\n *\n * @see VertexFormat#position\n * @see VertexFormat#normal\n */\nVertexFormat.DEFAULT = VertexFormat.POSITION_NORMAL_AND_ST;\n\n/**\n * The number of elements used to pack the object into an array.\n * @type {Number}\n */\nVertexFormat.packedLength = 6;\n\n/**\n * Stores the provided instance into the provided array.\n *\n * @param {VertexFormat} value The value to pack.\n * @param {Number[]} array The array to pack into.\n * @param {Number} [startingIndex=0] The index into the array at which to start packing the elements.\n *\n * @returns {Number[]} The array that was packed into\n */\nVertexFormat.pack = function (value, array, startingIndex) {\n  //>>includeStart(\'debug\', pragmas.debug);\n  if (!(0,_defined_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"] */ .Z)(value)) {\n    throw new _DeveloperError_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .Z("value is required");\n  }\n  if (!(0,_defined_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"] */ .Z)(array)) {\n    throw new _DeveloperError_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .Z("array is required");\n  }\n  //>>includeEnd(\'debug\');\n\n  startingIndex = (0,_defaultValue_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .Z)(startingIndex, 0);\n\n  array[startingIndex++] = value.position ? 1.0 : 0.0;\n  array[startingIndex++] = value.normal ? 1.0 : 0.0;\n  array[startingIndex++] = value.st ? 1.0 : 0.0;\n  array[startingIndex++] = value.tangent ? 1.0 : 0.0;\n  array[startingIndex++] = value.bitangent ? 1.0 : 0.0;\n  array[startingIndex] = value.color ? 1.0 : 0.0;\n\n  return array;\n};\n\n/**\n * Retrieves an instance from a packed array.\n *\n * @param {Number[]} array The packed array.\n * @param {Number} [startingIndex=0] The starting index of the element to be unpacked.\n * @param {VertexFormat} [result] The object into which to store the result.\n * @returns {VertexFormat} The modified result parameter or a new VertexFormat instance if one was not provided.\n */\nVertexFormat.unpack = function (array, startingIndex, result) {\n  //>>includeStart(\'debug\', pragmas.debug);\n  if (!(0,_defined_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"] */ .Z)(array)) {\n    throw new _DeveloperError_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .Z("array is required");\n  }\n  //>>includeEnd(\'debug\');\n\n  startingIndex = (0,_defaultValue_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .Z)(startingIndex, 0);\n\n  if (!(0,_defined_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"] */ .Z)(result)) {\n    result = new VertexFormat();\n  }\n\n  result.position = array[startingIndex++] === 1.0;\n  result.normal = array[startingIndex++] === 1.0;\n  result.st = array[startingIndex++] === 1.0;\n  result.tangent = array[startingIndex++] === 1.0;\n  result.bitangent = array[startingIndex++] === 1.0;\n  result.color = array[startingIndex] === 1.0;\n  return result;\n};\n\n/**\n * Duplicates a VertexFormat instance.\n *\n * @param {VertexFormat} vertexFormat The vertex format to duplicate.\n * @param {VertexFormat} [result] The object onto which to store the result.\n * @returns {VertexFormat} The modified result parameter or a new VertexFormat instance if one was not provided. (Returns undefined if vertexFormat is undefined)\n */\nVertexFormat.clone = function (vertexFormat, result) {\n  if (!(0,_defined_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"] */ .Z)(vertexFormat)) {\n    return undefined;\n  }\n  if (!(0,_defined_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"] */ .Z)(result)) {\n    result = new VertexFormat();\n  }\n\n  result.position = vertexFormat.position;\n  result.normal = vertexFormat.normal;\n  result.st = vertexFormat.st;\n  result.tangent = vertexFormat.tangent;\n  result.bitangent = vertexFormat.bitangent;\n  result.color = vertexFormat.color;\n  return result;\n};\n/* harmony default export */ __webpack_exports__["Z"] = (VertexFormat);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsY0FBYztBQUN6QixXQUFXLGNBQWM7QUFDekIsYUFBYSxjQUFjO0FBQzNCO0FBQ0E7QUFDQSxPQUFPLGdFQUFPO0FBQ2Q7QUFDQTtBQUNBLE9BQU8sZ0VBQU87QUFDZDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5REFBZSxZQUFZLEVBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly92dWUzLXdlYnBhY2s1Ly4vbm9kZV9tb2R1bGVzL2Nlc2l1bS9Tb3VyY2UvQ29yZS9WZXJ0ZXhGb3JtYXQuanM/MTA5OSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgZGVmYXVsdFZhbHVlIGZyb20gXCIuL2RlZmF1bHRWYWx1ZS5qc1wiO1xuaW1wb3J0IGRlZmluZWQgZnJvbSBcIi4vZGVmaW5lZC5qc1wiO1xuaW1wb3J0IERldmVsb3BlckVycm9yIGZyb20gXCIuL0RldmVsb3BlckVycm9yLmpzXCI7XG5cbi8qKlxuICogQSB2ZXJ0ZXggZm9ybWF0IGRlZmluZXMgd2hhdCBhdHRyaWJ1dGVzIG1ha2UgdXAgYSB2ZXJ0ZXguICBBIFZlcnRleEZvcm1hdCBjYW4gYmUgcHJvdmlkZWRcbiAqIHRvIGEge0BsaW5rIEdlb21ldHJ5fSB0byByZXF1ZXN0IHRoYXQgY2VydGFpbiBwcm9wZXJ0aWVzIGJlIGNvbXB1dGVkLCBlLmcuLCBqdXN0IHBvc2l0aW9uLFxuICogcG9zaXRpb24gYW5kIG5vcm1hbCwgZXRjLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gQW4gb2JqZWN0IHdpdGggYm9vbGVhbiBwcm9wZXJ0aWVzIGNvcnJlc3BvbmRpbmcgdG8gVmVydGV4Rm9ybWF0IHByb3BlcnRpZXMgYXMgc2hvd24gaW4gdGhlIGNvZGUgZXhhbXBsZS5cbiAqXG4gKiBAYWxpYXMgVmVydGV4Rm9ybWF0XG4gKiBAY29uc3RydWN0b3JcbiAqXG4gKiBAZXhhbXBsZVxuICogLy8gQ3JlYXRlIGEgdmVydGV4IGZvcm1hdCB3aXRoIHBvc2l0aW9uIGFuZCAyRCB0ZXh0dXJlIGNvb3JkaW5hdGUgYXR0cmlidXRlcy5cbiAqIHZhciBmb3JtYXQgPSBuZXcgQ2VzaXVtLlZlcnRleEZvcm1hdCh7XG4gKiAgIHBvc2l0aW9uIDogdHJ1ZSxcbiAqICAgc3QgOiB0cnVlXG4gKiB9KTtcbiAqXG4gKiBAc2VlIEdlb21ldHJ5I2F0dHJpYnV0ZXNcbiAqIEBzZWUgUGFja2FibGVcbiAqL1xuZnVuY3Rpb24gVmVydGV4Rm9ybWF0KG9wdGlvbnMpIHtcbiAgb3B0aW9ucyA9IGRlZmF1bHRWYWx1ZShvcHRpb25zLCBkZWZhdWx0VmFsdWUuRU1QVFlfT0JKRUNUKTtcblxuICAvKipcbiAgICogV2hlbiA8Y29kZT50cnVlPC9jb2RlPiwgdGhlIHZlcnRleCBoYXMgYSAzRCBwb3NpdGlvbiBhdHRyaWJ1dGUuXG4gICAqIDxwPlxuICAgKiA2NC1iaXQgZmxvYXRpbmctcG9pbnQgKGZvciBwcmVjaXNpb24pLiAgMyBjb21wb25lbnRzIHBlciBhdHRyaWJ1dGUuXG4gICAqIDwvcD5cbiAgICpcbiAgICogQHR5cGUgQm9vbGVhblxuICAgKlxuICAgKiBAZGVmYXVsdCBmYWxzZVxuICAgKi9cbiAgdGhpcy5wb3NpdGlvbiA9IGRlZmF1bHRWYWx1ZShvcHRpb25zLnBvc2l0aW9uLCBmYWxzZSk7XG5cbiAgLyoqXG4gICAqIFdoZW4gPGNvZGU+dHJ1ZTwvY29kZT4sIHRoZSB2ZXJ0ZXggaGFzIGEgbm9ybWFsIGF0dHJpYnV0ZSAobm9ybWFsaXplZCksIHdoaWNoIGlzIGNvbW1vbmx5IHVzZWQgZm9yIGxpZ2h0aW5nLlxuICAgKiA8cD5cbiAgICogMzItYml0IGZsb2F0aW5nLXBvaW50LiAgMyBjb21wb25lbnRzIHBlciBhdHRyaWJ1dGUuXG4gICAqIDwvcD5cbiAgICpcbiAgICogQHR5cGUgQm9vbGVhblxuICAgKlxuICAgKiBAZGVmYXVsdCBmYWxzZVxuICAgKi9cbiAgdGhpcy5ub3JtYWwgPSBkZWZhdWx0VmFsdWUob3B0aW9ucy5ub3JtYWwsIGZhbHNlKTtcblxuICAvKipcbiAgICogV2hlbiA8Y29kZT50cnVlPC9jb2RlPiwgdGhlIHZlcnRleCBoYXMgYSAyRCB0ZXh0dXJlIGNvb3JkaW5hdGUgYXR0cmlidXRlLlxuICAgKiA8cD5cbiAgICogMzItYml0IGZsb2F0aW5nLXBvaW50LiAgMiBjb21wb25lbnRzIHBlciBhdHRyaWJ1dGVcbiAgICogPC9wPlxuICAgKlxuICAgKiBAdHlwZSBCb29sZWFuXG4gICAqXG4gICAqIEBkZWZhdWx0IGZhbHNlXG4gICAqL1xuICB0aGlzLnN0ID0gZGVmYXVsdFZhbHVlKG9wdGlvbnMuc3QsIGZhbHNlKTtcblxuICAvKipcbiAgICogV2hlbiA8Y29kZT50cnVlPC9jb2RlPiwgdGhlIHZlcnRleCBoYXMgYSBiaXRhbmdlbnQgYXR0cmlidXRlIChub3JtYWxpemVkKSwgd2hpY2ggaXMgdXNlZCBmb3IgdGFuZ2VudC1zcGFjZSBlZmZlY3RzIGxpa2UgYnVtcCBtYXBwaW5nLlxuICAgKiA8cD5cbiAgICogMzItYml0IGZsb2F0aW5nLXBvaW50LiAgMyBjb21wb25lbnRzIHBlciBhdHRyaWJ1dGUuXG4gICAqIDwvcD5cbiAgICpcbiAgICogQHR5cGUgQm9vbGVhblxuICAgKlxuICAgKiBAZGVmYXVsdCBmYWxzZVxuICAgKi9cbiAgdGhpcy5iaXRhbmdlbnQgPSBkZWZhdWx0VmFsdWUob3B0aW9ucy5iaXRhbmdlbnQsIGZhbHNlKTtcblxuICAvKipcbiAgICogV2hlbiA8Y29kZT50cnVlPC9jb2RlPiwgdGhlIHZlcnRleCBoYXMgYSB0YW5nZW50IGF0dHJpYnV0ZSAobm9ybWFsaXplZCksIHdoaWNoIGlzIHVzZWQgZm9yIHRhbmdlbnQtc3BhY2UgZWZmZWN0cyBsaWtlIGJ1bXAgbWFwcGluZy5cbiAgICogPHA+XG4gICAqIDMyLWJpdCBmbG9hdGluZy1wb2ludC4gIDMgY29tcG9uZW50cyBwZXIgYXR0cmlidXRlLlxuICAgKiA8L3A+XG4gICAqXG4gICAqIEB0eXBlIEJvb2xlYW5cbiAgICpcbiAgICogQGRlZmF1bHQgZmFsc2VcbiAgICovXG4gIHRoaXMudGFuZ2VudCA9IGRlZmF1bHRWYWx1ZShvcHRpb25zLnRhbmdlbnQsIGZhbHNlKTtcblxuICAvKipcbiAgICogV2hlbiA8Y29kZT50cnVlPC9jb2RlPiwgdGhlIHZlcnRleCBoYXMgYW4gUkdCIGNvbG9yIGF0dHJpYnV0ZS5cbiAgICogPHA+XG4gICAqIDgtYml0IHVuc2lnbmVkIGJ5dGUuICAzIGNvbXBvbmVudHMgcGVyIGF0dHJpYnV0ZS5cbiAgICogPC9wPlxuICAgKlxuICAgKiBAdHlwZSBCb29sZWFuXG4gICAqXG4gICAqIEBkZWZhdWx0IGZhbHNlXG4gICAqL1xuICB0aGlzLmNvbG9yID0gZGVmYXVsdFZhbHVlKG9wdGlvbnMuY29sb3IsIGZhbHNlKTtcbn1cblxuLyoqXG4gKiBBbiBpbW11dGFibGUgdmVydGV4IGZvcm1hdCB3aXRoIG9ubHkgYSBwb3NpdGlvbiBhdHRyaWJ1dGUuXG4gKlxuICogQHR5cGUge1ZlcnRleEZvcm1hdH1cbiAqIEBjb25zdGFudFxuICpcbiAqIEBzZWUgVmVydGV4Rm9ybWF0I3Bvc2l0aW9uXG4gKi9cblZlcnRleEZvcm1hdC5QT1NJVElPTl9PTkxZID0gT2JqZWN0LmZyZWV6ZShcbiAgbmV3IFZlcnRleEZvcm1hdCh7XG4gICAgcG9zaXRpb246IHRydWUsXG4gIH0pXG4pO1xuXG4vKipcbiAqIEFuIGltbXV0YWJsZSB2ZXJ0ZXggZm9ybWF0IHdpdGggcG9zaXRpb24gYW5kIG5vcm1hbCBhdHRyaWJ1dGVzLlxuICogVGhpcyBpcyBjb21wYXRpYmxlIHdpdGggcGVyLWluc3RhbmNlIGNvbG9yIGFwcGVhcmFuY2VzIGxpa2Uge0BsaW5rIFBlckluc3RhbmNlQ29sb3JBcHBlYXJhbmNlfS5cbiAqXG4gKiBAdHlwZSB7VmVydGV4Rm9ybWF0fVxuICogQGNvbnN0YW50XG4gKlxuICogQHNlZSBWZXJ0ZXhGb3JtYXQjcG9zaXRpb25cbiAqIEBzZWUgVmVydGV4Rm9ybWF0I25vcm1hbFxuICovXG5WZXJ0ZXhGb3JtYXQuUE9TSVRJT05fQU5EX05PUk1BTCA9IE9iamVjdC5mcmVlemUoXG4gIG5ldyBWZXJ0ZXhGb3JtYXQoe1xuICAgIHBvc2l0aW9uOiB0cnVlLFxuICAgIG5vcm1hbDogdHJ1ZSxcbiAgfSlcbik7XG5cbi8qKlxuICogQW4gaW1tdXRhYmxlIHZlcnRleCBmb3JtYXQgd2l0aCBwb3NpdGlvbiwgbm9ybWFsLCBhbmQgc3QgYXR0cmlidXRlcy5cbiAqIFRoaXMgaXMgY29tcGF0aWJsZSB3aXRoIHtAbGluayBNYXRlcmlhbEFwcGVhcmFuY2V9IHdoZW4ge0BsaW5rIE1hdGVyaWFsQXBwZWFyYW5jZSNtYXRlcmlhbFN1cHBvcnR9XG4gKiBpcyA8Y29kZT5URVhUVVJFRC9jb2RlPi5cbiAqXG4gKiBAdHlwZSB7VmVydGV4Rm9ybWF0fVxuICogQGNvbnN0YW50XG4gKlxuICogQHNlZSBWZXJ0ZXhGb3JtYXQjcG9zaXRpb25cbiAqIEBzZWUgVmVydGV4Rm9ybWF0I25vcm1hbFxuICogQHNlZSBWZXJ0ZXhGb3JtYXQjc3RcbiAqL1xuVmVydGV4Rm9ybWF0LlBPU0lUSU9OX05PUk1BTF9BTkRfU1QgPSBPYmplY3QuZnJlZXplKFxuICBuZXcgVmVydGV4Rm9ybWF0KHtcbiAgICBwb3NpdGlvbjogdHJ1ZSxcbiAgICBub3JtYWw6IHRydWUsXG4gICAgc3Q6IHRydWUsXG4gIH0pXG4pO1xuXG4vKipcbiAqIEFuIGltbXV0YWJsZSB2ZXJ0ZXggZm9ybWF0IHdpdGggcG9zaXRpb24gYW5kIHN0IGF0dHJpYnV0ZXMuXG4gKiBUaGlzIGlzIGNvbXBhdGlibGUgd2l0aCB7QGxpbmsgRWxsaXBzb2lkU3VyZmFjZUFwcGVhcmFuY2V9LlxuICpcbiAqIEB0eXBlIHtWZXJ0ZXhGb3JtYXR9XG4gKiBAY29uc3RhbnRcbiAqXG4gKiBAc2VlIFZlcnRleEZvcm1hdCNwb3NpdGlvblxuICogQHNlZSBWZXJ0ZXhGb3JtYXQjc3RcbiAqL1xuVmVydGV4Rm9ybWF0LlBPU0lUSU9OX0FORF9TVCA9IE9iamVjdC5mcmVlemUoXG4gIG5ldyBWZXJ0ZXhGb3JtYXQoe1xuICAgIHBvc2l0aW9uOiB0cnVlLFxuICAgIHN0OiB0cnVlLFxuICB9KVxuKTtcblxuLyoqXG4gKiBBbiBpbW11dGFibGUgdmVydGV4IGZvcm1hdCB3aXRoIHBvc2l0aW9uIGFuZCBjb2xvciBhdHRyaWJ1dGVzLlxuICpcbiAqIEB0eXBlIHtWZXJ0ZXhGb3JtYXR9XG4gKiBAY29uc3RhbnRcbiAqXG4gKiBAc2VlIFZlcnRleEZvcm1hdCNwb3NpdGlvblxuICogQHNlZSBWZXJ0ZXhGb3JtYXQjY29sb3JcbiAqL1xuVmVydGV4Rm9ybWF0LlBPU0lUSU9OX0FORF9DT0xPUiA9IE9iamVjdC5mcmVlemUoXG4gIG5ldyBWZXJ0ZXhGb3JtYXQoe1xuICAgIHBvc2l0aW9uOiB0cnVlLFxuICAgIGNvbG9yOiB0cnVlLFxuICB9KVxuKTtcblxuLyoqXG4gKiBBbiBpbW11dGFibGUgdmVydGV4IGZvcm1hdCB3aXRoIHdlbGwta25vd24gYXR0cmlidXRlczogcG9zaXRpb24sIG5vcm1hbCwgc3QsIHRhbmdlbnQsIGFuZCBiaXRhbmdlbnQuXG4gKlxuICogQHR5cGUge1ZlcnRleEZvcm1hdH1cbiAqIEBjb25zdGFudFxuICpcbiAqIEBzZWUgVmVydGV4Rm9ybWF0I3Bvc2l0aW9uXG4gKiBAc2VlIFZlcnRleEZvcm1hdCNub3JtYWxcbiAqIEBzZWUgVmVydGV4Rm9ybWF0I3N0XG4gKiBAc2VlIFZlcnRleEZvcm1hdCN0YW5nZW50XG4gKiBAc2VlIFZlcnRleEZvcm1hdCNiaXRhbmdlbnRcbiAqL1xuVmVydGV4Rm9ybWF0LkFMTCA9IE9iamVjdC5mcmVlemUoXG4gIG5ldyBWZXJ0ZXhGb3JtYXQoe1xuICAgIHBvc2l0aW9uOiB0cnVlLFxuICAgIG5vcm1hbDogdHJ1ZSxcbiAgICBzdDogdHJ1ZSxcbiAgICB0YW5nZW50OiB0cnVlLFxuICAgIGJpdGFuZ2VudDogdHJ1ZSxcbiAgfSlcbik7XG5cbi8qKlxuICogQW4gaW1tdXRhYmxlIHZlcnRleCBmb3JtYXQgd2l0aCBwb3NpdGlvbiwgbm9ybWFsLCBhbmQgc3QgYXR0cmlidXRlcy5cbiAqIFRoaXMgaXMgY29tcGF0aWJsZSB3aXRoIG1vc3QgYXBwZWFyYW5jZXMgYW5kIG1hdGVyaWFsczsgaG93ZXZlclxuICogbm9ybWFsIGFuZCBzdCBhdHRyaWJ1dGVzIGFyZSBub3QgYWx3YXlzIHJlcXVpcmVkLiAgV2hlbiB0aGlzIGlzXG4gKiBrbm93biBpbiBhZHZhbmNlLCBhbm90aGVyIDxjb2RlPlZlcnRleEZvcm1hdDwvY29kZT4gc2hvdWxkIGJlIHVzZWQuXG4gKlxuICogQHR5cGUge1ZlcnRleEZvcm1hdH1cbiAqIEBjb25zdGFudFxuICpcbiAqIEBzZWUgVmVydGV4Rm9ybWF0I3Bvc2l0aW9uXG4gKiBAc2VlIFZlcnRleEZvcm1hdCNub3JtYWxcbiAqL1xuVmVydGV4Rm9ybWF0LkRFRkFVTFQgPSBWZXJ0ZXhGb3JtYXQuUE9TSVRJT05fTk9STUFMX0FORF9TVDtcblxuLyoqXG4gKiBUaGUgbnVtYmVyIG9mIGVsZW1lbnRzIHVzZWQgdG8gcGFjayB0aGUgb2JqZWN0IGludG8gYW4gYXJyYXkuXG4gKiBAdHlwZSB7TnVtYmVyfVxuICovXG5WZXJ0ZXhGb3JtYXQucGFja2VkTGVuZ3RoID0gNjtcblxuLyoqXG4gKiBTdG9yZXMgdGhlIHByb3ZpZGVkIGluc3RhbmNlIGludG8gdGhlIHByb3ZpZGVkIGFycmF5LlxuICpcbiAqIEBwYXJhbSB7VmVydGV4Rm9ybWF0fSB2YWx1ZSBUaGUgdmFsdWUgdG8gcGFjay5cbiAqIEBwYXJhbSB7TnVtYmVyW119IGFycmF5IFRoZSBhcnJheSB0byBwYWNrIGludG8uXG4gKiBAcGFyYW0ge051bWJlcn0gW3N0YXJ0aW5nSW5kZXg9MF0gVGhlIGluZGV4IGludG8gdGhlIGFycmF5IGF0IHdoaWNoIHRvIHN0YXJ0IHBhY2tpbmcgdGhlIGVsZW1lbnRzLlxuICpcbiAqIEByZXR1cm5zIHtOdW1iZXJbXX0gVGhlIGFycmF5IHRoYXQgd2FzIHBhY2tlZCBpbnRvXG4gKi9cblZlcnRleEZvcm1hdC5wYWNrID0gZnVuY3Rpb24gKHZhbHVlLCBhcnJheSwgc3RhcnRpbmdJbmRleCkge1xuICAvLz4+aW5jbHVkZVN0YXJ0KCdkZWJ1ZycsIHByYWdtYXMuZGVidWcpO1xuICBpZiAoIWRlZmluZWQodmFsdWUpKSB7XG4gICAgdGhyb3cgbmV3IERldmVsb3BlckVycm9yKFwidmFsdWUgaXMgcmVxdWlyZWRcIik7XG4gIH1cbiAgaWYgKCFkZWZpbmVkKGFycmF5KSkge1xuICAgIHRocm93IG5ldyBEZXZlbG9wZXJFcnJvcihcImFycmF5IGlzIHJlcXVpcmVkXCIpO1xuICB9XG4gIC8vPj5pbmNsdWRlRW5kKCdkZWJ1ZycpO1xuXG4gIHN0YXJ0aW5nSW5kZXggPSBkZWZhdWx0VmFsdWUoc3RhcnRpbmdJbmRleCwgMCk7XG5cbiAgYXJyYXlbc3RhcnRpbmdJbmRleCsrXSA9IHZhbHVlLnBvc2l0aW9uID8gMS4wIDogMC4wO1xuICBhcnJheVtzdGFydGluZ0luZGV4KytdID0gdmFsdWUubm9ybWFsID8gMS4wIDogMC4wO1xuICBhcnJheVtzdGFydGluZ0luZGV4KytdID0gdmFsdWUuc3QgPyAxLjAgOiAwLjA7XG4gIGFycmF5W3N0YXJ0aW5nSW5kZXgrK10gPSB2YWx1ZS50YW5nZW50ID8gMS4wIDogMC4wO1xuICBhcnJheVtzdGFydGluZ0luZGV4KytdID0gdmFsdWUuYml0YW5nZW50ID8gMS4wIDogMC4wO1xuICBhcnJheVtzdGFydGluZ0luZGV4XSA9IHZhbHVlLmNvbG9yID8gMS4wIDogMC4wO1xuXG4gIHJldHVybiBhcnJheTtcbn07XG5cbi8qKlxuICogUmV0cmlldmVzIGFuIGluc3RhbmNlIGZyb20gYSBwYWNrZWQgYXJyYXkuXG4gKlxuICogQHBhcmFtIHtOdW1iZXJbXX0gYXJyYXkgVGhlIHBhY2tlZCBhcnJheS5cbiAqIEBwYXJhbSB7TnVtYmVyfSBbc3RhcnRpbmdJbmRleD0wXSBUaGUgc3RhcnRpbmcgaW5kZXggb2YgdGhlIGVsZW1lbnQgdG8gYmUgdW5wYWNrZWQuXG4gKiBAcGFyYW0ge1ZlcnRleEZvcm1hdH0gW3Jlc3VsdF0gVGhlIG9iamVjdCBpbnRvIHdoaWNoIHRvIHN0b3JlIHRoZSByZXN1bHQuXG4gKiBAcmV0dXJucyB7VmVydGV4Rm9ybWF0fSBUaGUgbW9kaWZpZWQgcmVzdWx0IHBhcmFtZXRlciBvciBhIG5ldyBWZXJ0ZXhGb3JtYXQgaW5zdGFuY2UgaWYgb25lIHdhcyBub3QgcHJvdmlkZWQuXG4gKi9cblZlcnRleEZvcm1hdC51bnBhY2sgPSBmdW5jdGlvbiAoYXJyYXksIHN0YXJ0aW5nSW5kZXgsIHJlc3VsdCkge1xuICAvLz4+aW5jbHVkZVN0YXJ0KCdkZWJ1ZycsIHByYWdtYXMuZGVidWcpO1xuICBpZiAoIWRlZmluZWQoYXJyYXkpKSB7XG4gICAgdGhyb3cgbmV3IERldmVsb3BlckVycm9yKFwiYXJyYXkgaXMgcmVxdWlyZWRcIik7XG4gIH1cbiAgLy8+PmluY2x1ZGVFbmQoJ2RlYnVnJyk7XG5cbiAgc3RhcnRpbmdJbmRleCA9IGRlZmF1bHRWYWx1ZShzdGFydGluZ0luZGV4LCAwKTtcblxuICBpZiAoIWRlZmluZWQocmVzdWx0KSkge1xuICAgIHJlc3VsdCA9IG5ldyBWZXJ0ZXhGb3JtYXQoKTtcbiAgfVxuXG4gIHJlc3VsdC5wb3NpdGlvbiA9IGFycmF5W3N0YXJ0aW5nSW5kZXgrK10gPT09IDEuMDtcbiAgcmVzdWx0Lm5vcm1hbCA9IGFycmF5W3N0YXJ0aW5nSW5kZXgrK10gPT09IDEuMDtcbiAgcmVzdWx0LnN0ID0gYXJyYXlbc3RhcnRpbmdJbmRleCsrXSA9PT0gMS4wO1xuICByZXN1bHQudGFuZ2VudCA9IGFycmF5W3N0YXJ0aW5nSW5kZXgrK10gPT09IDEuMDtcbiAgcmVzdWx0LmJpdGFuZ2VudCA9IGFycmF5W3N0YXJ0aW5nSW5kZXgrK10gPT09IDEuMDtcbiAgcmVzdWx0LmNvbG9yID0gYXJyYXlbc3RhcnRpbmdJbmRleF0gPT09IDEuMDtcbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbi8qKlxuICogRHVwbGljYXRlcyBhIFZlcnRleEZvcm1hdCBpbnN0YW5jZS5cbiAqXG4gKiBAcGFyYW0ge1ZlcnRleEZvcm1hdH0gdmVydGV4Rm9ybWF0IFRoZSB2ZXJ0ZXggZm9ybWF0IHRvIGR1cGxpY2F0ZS5cbiAqIEBwYXJhbSB7VmVydGV4Rm9ybWF0fSBbcmVzdWx0XSBUaGUgb2JqZWN0IG9udG8gd2hpY2ggdG8gc3RvcmUgdGhlIHJlc3VsdC5cbiAqIEByZXR1cm5zIHtWZXJ0ZXhGb3JtYXR9IFRoZSBtb2RpZmllZCByZXN1bHQgcGFyYW1ldGVyIG9yIGEgbmV3IFZlcnRleEZvcm1hdCBpbnN0YW5jZSBpZiBvbmUgd2FzIG5vdCBwcm92aWRlZC4gKFJldHVybnMgdW5kZWZpbmVkIGlmIHZlcnRleEZvcm1hdCBpcyB1bmRlZmluZWQpXG4gKi9cblZlcnRleEZvcm1hdC5jbG9uZSA9IGZ1bmN0aW9uICh2ZXJ0ZXhGb3JtYXQsIHJlc3VsdCkge1xuICBpZiAoIWRlZmluZWQodmVydGV4Rm9ybWF0KSkge1xuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cbiAgaWYgKCFkZWZpbmVkKHJlc3VsdCkpIHtcbiAgICByZXN1bHQgPSBuZXcgVmVydGV4Rm9ybWF0KCk7XG4gIH1cblxuICByZXN1bHQucG9zaXRpb24gPSB2ZXJ0ZXhGb3JtYXQucG9zaXRpb247XG4gIHJlc3VsdC5ub3JtYWwgPSB2ZXJ0ZXhGb3JtYXQubm9ybWFsO1xuICByZXN1bHQuc3QgPSB2ZXJ0ZXhGb3JtYXQuc3Q7XG4gIHJlc3VsdC50YW5nZW50ID0gdmVydGV4Rm9ybWF0LnRhbmdlbnQ7XG4gIHJlc3VsdC5iaXRhbmdlbnQgPSB2ZXJ0ZXhGb3JtYXQuYml0YW5nZW50O1xuICByZXN1bHQuY29sb3IgPSB2ZXJ0ZXhGb3JtYXQuY29sb3I7XG4gIHJldHVybiByZXN1bHQ7XG59O1xuZXhwb3J0IGRlZmF1bHQgVmVydGV4Rm9ybWF0O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///67252\n')},36999:function(__unused_webpack___webpack_module__,__unused_webpack___webpack_exports__,__webpack_require__){eval('/* harmony import */ var _defaultValue_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(62200);\n/* harmony import */ var _defined_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(82982);\n/* harmony import */ var _destroyObject_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(86511);\n/* harmony import */ var _Iso8601_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(22841);\n/* harmony import */ var _JulianDate_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(55293);\n\n\n\n\n\n\n/**\n * Synchronizes a video element with a simulation clock.\n *\n * @alias VideoSynchronizer\n * @constructor\n *\n * @param {Object} [options] Object with the following properties:\n * @param {Clock} [options.clock] The clock instance used to drive the video.\n * @param {HTMLVideoElement} [options.element] The video element to be synchronized.\n * @param {JulianDate} [options.epoch=Iso8601.MINIMUM_VALUE] The simulation time that marks the start of the video.\n * @param {Number} [options.tolerance=1.0] The maximum amount of time, in seconds, that the clock and video can diverge.\n *\n * @demo {@link https://sandcastle.cesium.com/index.html?src=Video.html|Video Material Demo}\n */\nfunction VideoSynchronizer(options) {\n  options = (0,_defaultValue_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .Z)(options, _defaultValue_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].EMPTY_OBJECT */ .Z.EMPTY_OBJECT);\n\n  this._clock = undefined;\n  this._element = undefined;\n  this._clockSubscription = undefined;\n  this._seekFunction = undefined;\n  this._lastPlaybackRate = undefined;\n\n  this.clock = options.clock;\n  this.element = options.element;\n\n  /**\n   * Gets or sets the simulation time that marks the start of the video.\n   * @type {JulianDate}\n   * @default Iso8601.MINIMUM_VALUE\n   */\n  this.epoch = (0,_defaultValue_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .Z)(options.epoch, _Iso8601_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"].MINIMUM_VALUE */ .Z.MINIMUM_VALUE);\n\n  /**\n   * Gets or sets the amount of time in seconds the video\'s currentTime\n   * and the clock\'s currentTime can diverge before a video seek is performed.\n   * Lower values make the synchronization more accurate but video\n   * performance might suffer.  Higher values provide better performance\n   * but at the cost of accuracy.\n   * @type {Number}\n   * @default 1.0\n   */\n  this.tolerance = (0,_defaultValue_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .Z)(options.tolerance, 1.0);\n\n  this._seeking = false;\n  this._seekFunction = undefined;\n  this._firstTickAfterSeek = false;\n}\n\nObject.defineProperties(VideoSynchronizer.prototype, {\n  /**\n   * Gets or sets the clock used to drive the video element.\n   *\n   * @memberof VideoSynchronizer.prototype\n   * @type {Clock}\n   */\n  clock: {\n    get: function () {\n      return this._clock;\n    },\n    set: function (value) {\n      var oldValue = this._clock;\n\n      if (oldValue === value) {\n        return;\n      }\n\n      if ((0,_defined_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .Z)(oldValue)) {\n        this._clockSubscription();\n        this._clockSubscription = undefined;\n      }\n\n      if ((0,_defined_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .Z)(value)) {\n        this._clockSubscription = value.onTick.addEventListener(\n          VideoSynchronizer.prototype._onTick,\n          this\n        );\n      }\n\n      this._clock = value;\n    },\n  },\n  /**\n   * Gets or sets the video element to synchronize.\n   *\n   * @memberof VideoSynchronizer.prototype\n   * @type {HTMLVideoElement}\n   */\n  element: {\n    get: function () {\n      return this._element;\n    },\n    set: function (value) {\n      var oldValue = this._element;\n\n      if (oldValue === value) {\n        return;\n      }\n\n      if ((0,_defined_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .Z)(oldValue)) {\n        oldValue.removeEventListener("seeked", this._seekFunction, false);\n      }\n\n      if ((0,_defined_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .Z)(value)) {\n        this._seeking = false;\n        this._seekFunction = createSeekFunction(this);\n        value.addEventListener("seeked", this._seekFunction, false);\n      }\n\n      this._element = value;\n      this._seeking = false;\n      this._firstTickAfterSeek = false;\n    },\n  },\n});\n\n/**\n * Destroys and resources used by the object.  Once an object is destroyed, it should not be used.\n *\n * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.\n */\nVideoSynchronizer.prototype.destroy = function () {\n  this.element = undefined;\n  this.clock = undefined;\n  return (0,_destroyObject_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .Z)(this);\n};\n\n/**\n * Returns true if this object was destroyed; otherwise, false.\n *\n * @returns {Boolean} True if this object was destroyed; otherwise, false.\n */\nVideoSynchronizer.prototype.isDestroyed = function () {\n  return false;\n};\n\nVideoSynchronizer.prototype._trySetPlaybackRate = function (clock) {\n  if (this._lastPlaybackRate === clock.multiplier) {\n    return;\n  }\n\n  var element = this._element;\n  try {\n    element.playbackRate = clock.multiplier;\n  } catch (error) {\n    // Seek manually for unsupported playbackRates.\n    element.playbackRate = 0.0;\n  }\n  this._lastPlaybackRate = clock.multiplier;\n};\n\nVideoSynchronizer.prototype._onTick = function (clock) {\n  var element = this._element;\n  if (!(0,_defined_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .Z)(element) || element.readyState < 2) {\n    return;\n  }\n\n  var paused = element.paused;\n  var shouldAnimate = clock.shouldAnimate;\n  if (shouldAnimate === paused) {\n    if (shouldAnimate) {\n      element.play();\n    } else {\n      element.pause();\n    }\n  }\n\n  //We need to avoid constant seeking or the video will\n  //never contain a complete frame for us to render.\n  //So don\'t do anything if we\'re seeing or on the first\n  //tick after a seek (the latter of which allows the frame\n  //to actually be rendered.\n  if (this._seeking || this._firstTickAfterSeek) {\n    this._firstTickAfterSeek = false;\n    return;\n  }\n\n  this._trySetPlaybackRate(clock);\n\n  var clockTime = clock.currentTime;\n  var epoch = (0,_defaultValue_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .Z)(this.epoch, _Iso8601_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"].MINIMUM_VALUE */ .Z.MINIMUM_VALUE);\n  var videoTime = _JulianDate_js__WEBPACK_IMPORTED_MODULE_3__/* ["default"].secondsDifference */ .Z.secondsDifference(clockTime, epoch);\n\n  var duration = element.duration;\n  var desiredTime;\n  var currentTime = element.currentTime;\n  if (element.loop) {\n    videoTime = videoTime % duration;\n    if (videoTime < 0.0) {\n      videoTime = duration - videoTime;\n    }\n    desiredTime = videoTime;\n  } else if (videoTime > duration) {\n    desiredTime = duration;\n  } else if (videoTime < 0.0) {\n    desiredTime = 0.0;\n  } else {\n    desiredTime = videoTime;\n  }\n\n  //If the playing video\'s time and the scene\'s clock time\n  //ever drift too far apart, we want to set the video to match\n  var tolerance = shouldAnimate ? (0,_defaultValue_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .Z)(this.tolerance, 1.0) : 0.001;\n  if (Math.abs(desiredTime - currentTime) > tolerance) {\n    this._seeking = true;\n    element.currentTime = desiredTime;\n  }\n};\n\nfunction createSeekFunction(that) {\n  return function () {\n    that._seeking = false;\n    that._firstTickAfterSeek = true;\n  };\n}\n/* unused harmony default export */ var __WEBPACK_DEFAULT_EXPORT__ = ((/* unused pure expression or super */ null && (VideoSynchronizer)));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMzY5OTkuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBNkM7QUFDVjtBQUNZO0FBQ1o7QUFDTTs7QUFFekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsT0FBTztBQUNsQixXQUFXLGtCQUFrQjtBQUM3QixXQUFXLFlBQVk7QUFDdkIsV0FBVyxRQUFRO0FBQ25CO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxZQUFZLHFFQUFZLFVBQVUsMkZBQXlCOztBQUUzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0EsZUFBZSxxRUFBWSxnQkFBZ0Isd0ZBQXFCOztBQUVoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBLG1CQUFtQixxRUFBWTs7QUFFL0I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxVQUFVLGdFQUFPO0FBQ2pCO0FBQ0E7QUFDQTs7QUFFQSxVQUFVLGdFQUFPO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLFVBQVUsZ0VBQU87QUFDakI7QUFDQTs7QUFFQSxVQUFVLGdFQUFPO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0gsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQSxlQUFlLGdCQUFnQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVMsc0VBQWE7QUFDdEI7O0FBRUE7QUFDQSw4Q0FBOEM7QUFDOUM7QUFDQSxhQUFhLFNBQVMsbUNBQW1DO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPLGdFQUFPO0FBQ2Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxjQUFjLHFFQUFZLGFBQWEsd0ZBQXFCO0FBQzVELGtCQUFrQixtR0FBNEI7O0FBRTlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxrQ0FBa0MscUVBQVk7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzRUFBZSxpRUFBaUIsSUFBQyIsInNvdXJjZXMiOlsid2VicGFjazovL3Z1ZTMtd2VicGFjazUvLi9ub2RlX21vZHVsZXMvY2VzaXVtL1NvdXJjZS9Db3JlL1ZpZGVvU3luY2hyb25pemVyLmpzP2IwZjYiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IGRlZmF1bHRWYWx1ZSBmcm9tIFwiLi9kZWZhdWx0VmFsdWUuanNcIjtcbmltcG9ydCBkZWZpbmVkIGZyb20gXCIuL2RlZmluZWQuanNcIjtcbmltcG9ydCBkZXN0cm95T2JqZWN0IGZyb20gXCIuL2Rlc3Ryb3lPYmplY3QuanNcIjtcbmltcG9ydCBJc284NjAxIGZyb20gXCIuL0lzbzg2MDEuanNcIjtcbmltcG9ydCBKdWxpYW5EYXRlIGZyb20gXCIuL0p1bGlhbkRhdGUuanNcIjtcblxuLyoqXG4gKiBTeW5jaHJvbml6ZXMgYSB2aWRlbyBlbGVtZW50IHdpdGggYSBzaW11bGF0aW9uIGNsb2NrLlxuICpcbiAqIEBhbGlhcyBWaWRlb1N5bmNocm9uaXplclxuICogQGNvbnN0cnVjdG9yXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSBPYmplY3Qgd2l0aCB0aGUgZm9sbG93aW5nIHByb3BlcnRpZXM6XG4gKiBAcGFyYW0ge0Nsb2NrfSBbb3B0aW9ucy5jbG9ja10gVGhlIGNsb2NrIGluc3RhbmNlIHVzZWQgdG8gZHJpdmUgdGhlIHZpZGVvLlxuICogQHBhcmFtIHtIVE1MVmlkZW9FbGVtZW50fSBbb3B0aW9ucy5lbGVtZW50XSBUaGUgdmlkZW8gZWxlbWVudCB0byBiZSBzeW5jaHJvbml6ZWQuXG4gKiBAcGFyYW0ge0p1bGlhbkRhdGV9IFtvcHRpb25zLmVwb2NoPUlzbzg2MDEuTUlOSU1VTV9WQUxVRV0gVGhlIHNpbXVsYXRpb24gdGltZSB0aGF0IG1hcmtzIHRoZSBzdGFydCBvZiB0aGUgdmlkZW8uXG4gKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMudG9sZXJhbmNlPTEuMF0gVGhlIG1heGltdW0gYW1vdW50IG9mIHRpbWUsIGluIHNlY29uZHMsIHRoYXQgdGhlIGNsb2NrIGFuZCB2aWRlbyBjYW4gZGl2ZXJnZS5cbiAqXG4gKiBAZGVtbyB7QGxpbmsgaHR0cHM6Ly9zYW5kY2FzdGxlLmNlc2l1bS5jb20vaW5kZXguaHRtbD9zcmM9VmlkZW8uaHRtbHxWaWRlbyBNYXRlcmlhbCBEZW1vfVxuICovXG5mdW5jdGlvbiBWaWRlb1N5bmNocm9uaXplcihvcHRpb25zKSB7XG4gIG9wdGlvbnMgPSBkZWZhdWx0VmFsdWUob3B0aW9ucywgZGVmYXVsdFZhbHVlLkVNUFRZX09CSkVDVCk7XG5cbiAgdGhpcy5fY2xvY2sgPSB1bmRlZmluZWQ7XG4gIHRoaXMuX2VsZW1lbnQgPSB1bmRlZmluZWQ7XG4gIHRoaXMuX2Nsb2NrU3Vic2NyaXB0aW9uID0gdW5kZWZpbmVkO1xuICB0aGlzLl9zZWVrRnVuY3Rpb24gPSB1bmRlZmluZWQ7XG4gIHRoaXMuX2xhc3RQbGF5YmFja1JhdGUgPSB1bmRlZmluZWQ7XG5cbiAgdGhpcy5jbG9jayA9IG9wdGlvbnMuY2xvY2s7XG4gIHRoaXMuZWxlbWVudCA9IG9wdGlvbnMuZWxlbWVudDtcblxuICAvKipcbiAgICogR2V0cyBvciBzZXRzIHRoZSBzaW11bGF0aW9uIHRpbWUgdGhhdCBtYXJrcyB0aGUgc3RhcnQgb2YgdGhlIHZpZGVvLlxuICAgKiBAdHlwZSB7SnVsaWFuRGF0ZX1cbiAgICogQGRlZmF1bHQgSXNvODYwMS5NSU5JTVVNX1ZBTFVFXG4gICAqL1xuICB0aGlzLmVwb2NoID0gZGVmYXVsdFZhbHVlKG9wdGlvbnMuZXBvY2gsIElzbzg2MDEuTUlOSU1VTV9WQUxVRSk7XG5cbiAgLyoqXG4gICAqIEdldHMgb3Igc2V0cyB0aGUgYW1vdW50IG9mIHRpbWUgaW4gc2Vjb25kcyB0aGUgdmlkZW8ncyBjdXJyZW50VGltZVxuICAgKiBhbmQgdGhlIGNsb2NrJ3MgY3VycmVudFRpbWUgY2FuIGRpdmVyZ2UgYmVmb3JlIGEgdmlkZW8gc2VlayBpcyBwZXJmb3JtZWQuXG4gICAqIExvd2VyIHZhbHVlcyBtYWtlIHRoZSBzeW5jaHJvbml6YXRpb24gbW9yZSBhY2N1cmF0ZSBidXQgdmlkZW9cbiAgICogcGVyZm9ybWFuY2UgbWlnaHQgc3VmZmVyLiAgSGlnaGVyIHZhbHVlcyBwcm92aWRlIGJldHRlciBwZXJmb3JtYW5jZVxuICAgKiBidXQgYXQgdGhlIGNvc3Qgb2YgYWNjdXJhY3kuXG4gICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAqIEBkZWZhdWx0IDEuMFxuICAgKi9cbiAgdGhpcy50b2xlcmFuY2UgPSBkZWZhdWx0VmFsdWUob3B0aW9ucy50b2xlcmFuY2UsIDEuMCk7XG5cbiAgdGhpcy5fc2Vla2luZyA9IGZhbHNlO1xuICB0aGlzLl9zZWVrRnVuY3Rpb24gPSB1bmRlZmluZWQ7XG4gIHRoaXMuX2ZpcnN0VGlja0FmdGVyU2VlayA9IGZhbHNlO1xufVxuXG5PYmplY3QuZGVmaW5lUHJvcGVydGllcyhWaWRlb1N5bmNocm9uaXplci5wcm90b3R5cGUsIHtcbiAgLyoqXG4gICAqIEdldHMgb3Igc2V0cyB0aGUgY2xvY2sgdXNlZCB0byBkcml2ZSB0aGUgdmlkZW8gZWxlbWVudC5cbiAgICpcbiAgICogQG1lbWJlcm9mIFZpZGVvU3luY2hyb25pemVyLnByb3RvdHlwZVxuICAgKiBAdHlwZSB7Q2xvY2t9XG4gICAqL1xuICBjbG9jazoge1xuICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX2Nsb2NrO1xuICAgIH0sXG4gICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgIHZhciBvbGRWYWx1ZSA9IHRoaXMuX2Nsb2NrO1xuXG4gICAgICBpZiAob2xkVmFsdWUgPT09IHZhbHVlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaWYgKGRlZmluZWQob2xkVmFsdWUpKSB7XG4gICAgICAgIHRoaXMuX2Nsb2NrU3Vic2NyaXB0aW9uKCk7XG4gICAgICAgIHRoaXMuX2Nsb2NrU3Vic2NyaXB0aW9uID0gdW5kZWZpbmVkO1xuICAgICAgfVxuXG4gICAgICBpZiAoZGVmaW5lZCh2YWx1ZSkpIHtcbiAgICAgICAgdGhpcy5fY2xvY2tTdWJzY3JpcHRpb24gPSB2YWx1ZS5vblRpY2suYWRkRXZlbnRMaXN0ZW5lcihcbiAgICAgICAgICBWaWRlb1N5bmNocm9uaXplci5wcm90b3R5cGUuX29uVGljayxcbiAgICAgICAgICB0aGlzXG4gICAgICAgICk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuX2Nsb2NrID0gdmFsdWU7XG4gICAgfSxcbiAgfSxcbiAgLyoqXG4gICAqIEdldHMgb3Igc2V0cyB0aGUgdmlkZW8gZWxlbWVudCB0byBzeW5jaHJvbml6ZS5cbiAgICpcbiAgICogQG1lbWJlcm9mIFZpZGVvU3luY2hyb25pemVyLnByb3RvdHlwZVxuICAgKiBAdHlwZSB7SFRNTFZpZGVvRWxlbWVudH1cbiAgICovXG4gIGVsZW1lbnQ6IHtcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9lbGVtZW50O1xuICAgIH0sXG4gICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgIHZhciBvbGRWYWx1ZSA9IHRoaXMuX2VsZW1lbnQ7XG5cbiAgICAgIGlmIChvbGRWYWx1ZSA9PT0gdmFsdWUpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiAoZGVmaW5lZChvbGRWYWx1ZSkpIHtcbiAgICAgICAgb2xkVmFsdWUucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInNlZWtlZFwiLCB0aGlzLl9zZWVrRnVuY3Rpb24sIGZhbHNlKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGRlZmluZWQodmFsdWUpKSB7XG4gICAgICAgIHRoaXMuX3NlZWtpbmcgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5fc2Vla0Z1bmN0aW9uID0gY3JlYXRlU2Vla0Z1bmN0aW9uKHRoaXMpO1xuICAgICAgICB2YWx1ZS5hZGRFdmVudExpc3RlbmVyKFwic2Vla2VkXCIsIHRoaXMuX3NlZWtGdW5jdGlvbiwgZmFsc2UpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLl9lbGVtZW50ID0gdmFsdWU7XG4gICAgICB0aGlzLl9zZWVraW5nID0gZmFsc2U7XG4gICAgICB0aGlzLl9maXJzdFRpY2tBZnRlclNlZWsgPSBmYWxzZTtcbiAgICB9LFxuICB9LFxufSk7XG5cbi8qKlxuICogRGVzdHJveXMgYW5kIHJlc291cmNlcyB1c2VkIGJ5IHRoZSBvYmplY3QuICBPbmNlIGFuIG9iamVjdCBpcyBkZXN0cm95ZWQsIGl0IHNob3VsZCBub3QgYmUgdXNlZC5cbiAqXG4gKiBAZXhjZXB0aW9uIHtEZXZlbG9wZXJFcnJvcn0gVGhpcyBvYmplY3Qgd2FzIGRlc3Ryb3llZCwgaS5lLiwgZGVzdHJveSgpIHdhcyBjYWxsZWQuXG4gKi9cblZpZGVvU3luY2hyb25pemVyLnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24gKCkge1xuICB0aGlzLmVsZW1lbnQgPSB1bmRlZmluZWQ7XG4gIHRoaXMuY2xvY2sgPSB1bmRlZmluZWQ7XG4gIHJldHVybiBkZXN0cm95T2JqZWN0KHRoaXMpO1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgdGhpcyBvYmplY3Qgd2FzIGRlc3Ryb3llZDsgb3RoZXJ3aXNlLCBmYWxzZS5cbiAqXG4gKiBAcmV0dXJucyB7Qm9vbGVhbn0gVHJ1ZSBpZiB0aGlzIG9iamVjdCB3YXMgZGVzdHJveWVkOyBvdGhlcndpc2UsIGZhbHNlLlxuICovXG5WaWRlb1N5bmNocm9uaXplci5wcm90b3R5cGUuaXNEZXN0cm95ZWQgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiBmYWxzZTtcbn07XG5cblZpZGVvU3luY2hyb25pemVyLnByb3RvdHlwZS5fdHJ5U2V0UGxheWJhY2tSYXRlID0gZnVuY3Rpb24gKGNsb2NrKSB7XG4gIGlmICh0aGlzLl9sYXN0UGxheWJhY2tSYXRlID09PSBjbG9jay5tdWx0aXBsaWVyKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIGVsZW1lbnQgPSB0aGlzLl9lbGVtZW50O1xuICB0cnkge1xuICAgIGVsZW1lbnQucGxheWJhY2tSYXRlID0gY2xvY2subXVsdGlwbGllcjtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAvLyBTZWVrIG1hbnVhbGx5IGZvciB1bnN1cHBvcnRlZCBwbGF5YmFja1JhdGVzLlxuICAgIGVsZW1lbnQucGxheWJhY2tSYXRlID0gMC4wO1xuICB9XG4gIHRoaXMuX2xhc3RQbGF5YmFja1JhdGUgPSBjbG9jay5tdWx0aXBsaWVyO1xufTtcblxuVmlkZW9TeW5jaHJvbml6ZXIucHJvdG90eXBlLl9vblRpY2sgPSBmdW5jdGlvbiAoY2xvY2spIHtcbiAgdmFyIGVsZW1lbnQgPSB0aGlzLl9lbGVtZW50O1xuICBpZiAoIWRlZmluZWQoZWxlbWVudCkgfHwgZWxlbWVudC5yZWFkeVN0YXRlIDwgMikge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciBwYXVzZWQgPSBlbGVtZW50LnBhdXNlZDtcbiAgdmFyIHNob3VsZEFuaW1hdGUgPSBjbG9jay5zaG91bGRBbmltYXRlO1xuICBpZiAoc2hvdWxkQW5pbWF0ZSA9PT0gcGF1c2VkKSB7XG4gICAgaWYgKHNob3VsZEFuaW1hdGUpIHtcbiAgICAgIGVsZW1lbnQucGxheSgpO1xuICAgIH0gZWxzZSB7XG4gICAgICBlbGVtZW50LnBhdXNlKCk7XG4gICAgfVxuICB9XG5cbiAgLy9XZSBuZWVkIHRvIGF2b2lkIGNvbnN0YW50IHNlZWtpbmcgb3IgdGhlIHZpZGVvIHdpbGxcbiAgLy9uZXZlciBjb250YWluIGEgY29tcGxldGUgZnJhbWUgZm9yIHVzIHRvIHJlbmRlci5cbiAgLy9TbyBkb24ndCBkbyBhbnl0aGluZyBpZiB3ZSdyZSBzZWVpbmcgb3Igb24gdGhlIGZpcnN0XG4gIC8vdGljayBhZnRlciBhIHNlZWsgKHRoZSBsYXR0ZXIgb2Ygd2hpY2ggYWxsb3dzIHRoZSBmcmFtZVxuICAvL3RvIGFjdHVhbGx5IGJlIHJlbmRlcmVkLlxuICBpZiAodGhpcy5fc2Vla2luZyB8fCB0aGlzLl9maXJzdFRpY2tBZnRlclNlZWspIHtcbiAgICB0aGlzLl9maXJzdFRpY2tBZnRlclNlZWsgPSBmYWxzZTtcbiAgICByZXR1cm47XG4gIH1cblxuICB0aGlzLl90cnlTZXRQbGF5YmFja1JhdGUoY2xvY2spO1xuXG4gIHZhciBjbG9ja1RpbWUgPSBjbG9jay5jdXJyZW50VGltZTtcbiAgdmFyIGVwb2NoID0gZGVmYXVsdFZhbHVlKHRoaXMuZXBvY2gsIElzbzg2MDEuTUlOSU1VTV9WQUxVRSk7XG4gIHZhciB2aWRlb1RpbWUgPSBKdWxpYW5EYXRlLnNlY29uZHNEaWZmZXJlbmNlKGNsb2NrVGltZSwgZXBvY2gpO1xuXG4gIHZhciBkdXJhdGlvbiA9IGVsZW1lbnQuZHVyYXRpb247XG4gIHZhciBkZXNpcmVkVGltZTtcbiAgdmFyIGN1cnJlbnRUaW1lID0gZWxlbWVudC5jdXJyZW50VGltZTtcbiAgaWYgKGVsZW1lbnQubG9vcCkge1xuICAgIHZpZGVvVGltZSA9IHZpZGVvVGltZSAlIGR1cmF0aW9uO1xuICAgIGlmICh2aWRlb1RpbWUgPCAwLjApIHtcbiAgICAgIHZpZGVvVGltZSA9IGR1cmF0aW9uIC0gdmlkZW9UaW1lO1xuICAgIH1cbiAgICBkZXNpcmVkVGltZSA9IHZpZGVvVGltZTtcbiAgfSBlbHNlIGlmICh2aWRlb1RpbWUgPiBkdXJhdGlvbikge1xuICAgIGRlc2lyZWRUaW1lID0gZHVyYXRpb247XG4gIH0gZWxzZSBpZiAodmlkZW9UaW1lIDwgMC4wKSB7XG4gICAgZGVzaXJlZFRpbWUgPSAwLjA7XG4gIH0gZWxzZSB7XG4gICAgZGVzaXJlZFRpbWUgPSB2aWRlb1RpbWU7XG4gIH1cblxuICAvL0lmIHRoZSBwbGF5aW5nIHZpZGVvJ3MgdGltZSBhbmQgdGhlIHNjZW5lJ3MgY2xvY2sgdGltZVxuICAvL2V2ZXIgZHJpZnQgdG9vIGZhciBhcGFydCwgd2Ugd2FudCB0byBzZXQgdGhlIHZpZGVvIHRvIG1hdGNoXG4gIHZhciB0b2xlcmFuY2UgPSBzaG91bGRBbmltYXRlID8gZGVmYXVsdFZhbHVlKHRoaXMudG9sZXJhbmNlLCAxLjApIDogMC4wMDE7XG4gIGlmIChNYXRoLmFicyhkZXNpcmVkVGltZSAtIGN1cnJlbnRUaW1lKSA+IHRvbGVyYW5jZSkge1xuICAgIHRoaXMuX3NlZWtpbmcgPSB0cnVlO1xuICAgIGVsZW1lbnQuY3VycmVudFRpbWUgPSBkZXNpcmVkVGltZTtcbiAgfVxufTtcblxuZnVuY3Rpb24gY3JlYXRlU2Vla0Z1bmN0aW9uKHRoYXQpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICB0aGF0Ll9zZWVraW5nID0gZmFsc2U7XG4gICAgdGhhdC5fZmlyc3RUaWNrQWZ0ZXJTZWVrID0gdHJ1ZTtcbiAgfTtcbn1cbmV4cG9ydCBkZWZhdWx0IFZpZGVvU3luY2hyb25pemVyO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///36999\n')}}]);