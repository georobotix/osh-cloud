"use strict";(self["webpackChunkvue3_webpack5"]=self["webpackChunkvue3_webpack5"]||[]).push([[7678],{36255:function(__unused_webpack_module,__webpack_exports__,__webpack_require__){eval("/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"D0\": function() { return /* binding */ isAsyncIterable; },\n/* harmony export */   \"Ew\": function() { return /* binding */ isResponse; },\n/* harmony export */   \"Kn\": function() { return /* binding */ isObject; },\n/* harmony export */   \"Lj\": function() { return /* binding */ isBlob; },\n/* harmony export */   \"Os\": function() { return /* binding */ isReadableStream; },\n/* harmony export */   \"Ss\": function() { return /* binding */ isPureObject; },\n/* harmony export */   \"TW\": function() { return /* binding */ isIterable; },\n/* harmony export */   \"zH\": function() { return /* binding */ isBuffer; }\n/* harmony export */ });\n/* unused harmony exports isPromise, isIterator, isFile, isWritableDOMStream, isReadableDOMStream, isWritableNodeStream, isReadableNodeStream, isWritableStream */\n\n\nconst isBoolean = x => typeof x === 'boolean';\nconst isFunction = x => typeof x === 'function';\nconst isObject = x => x !== null && typeof x === 'object';\nconst isPureObject = x => isObject(x) && x.constructor === {}.constructor;\nconst isPromise = x => isObject(x) && isFunction(x.then);\nconst isIterable = x => x && typeof x[Symbol.iterator] === 'function';\nconst isAsyncIterable = x => x && typeof x[Symbol.asyncIterator] === 'function';\nconst isIterator = x => x && isFunction(x.next);\nconst isResponse = x => typeof Response !== 'undefined' && x instanceof Response || x && x.arrayBuffer && x.text && x.json;\nconst isFile = x => typeof File !== 'undefined' && x instanceof File;\nconst isBlob = x => typeof Blob !== 'undefined' && x instanceof Blob;\n\nconst isBuffer = x => x && typeof x === 'object' && x.isBuffer;\nconst isWritableDOMStream = x => isObject(x) && isFunction(x.abort) && isFunction(x.getWriter);\nconst isReadableDOMStream = x => typeof ReadableStream !== 'undefined' && x instanceof ReadableStream || isObject(x) && isFunction(x.tee) && isFunction(x.cancel) && isFunction(x.getReader);\n\nconst isWritableNodeStream = x => isObject(x) && isFunction(x.end) && isFunction(x.write) && isBoolean(x.writable);\nconst isReadableNodeStream = x => isObject(x) && isFunction(x.read) && isFunction(x.pipe) && isBoolean(x.readable);\nconst isReadableStream = x => isReadableDOMStream(x) || isReadableNodeStream(x);\nconst isWritableStream = x => isWritableDOMStream(x) || isWritableNodeStream(x);\n//# sourceMappingURL=is-type.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMzYyNTUuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7OztBQUVBO0FBQ0E7QUFDTztBQUNBLDZEQUE2RDtBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDUCIsInNvdXJjZXMiOlsid2VicGFjazovL3Z1ZTMtd2VicGFjazUvLi9ub2RlX21vZHVsZXMvQGxvYWRlcnMuZ2wvY29yZS9kaXN0L2VzbS9qYXZhc2NyaXB0LXV0aWxzL2lzLXR5cGUuanM/NzM4YSJdLCJzb3VyY2VzQ29udGVudCI6WyJcblxuY29uc3QgaXNCb29sZWFuID0geCA9PiB0eXBlb2YgeCA9PT0gJ2Jvb2xlYW4nO1xuY29uc3QgaXNGdW5jdGlvbiA9IHggPT4gdHlwZW9mIHggPT09ICdmdW5jdGlvbic7XG5leHBvcnQgY29uc3QgaXNPYmplY3QgPSB4ID0+IHggIT09IG51bGwgJiYgdHlwZW9mIHggPT09ICdvYmplY3QnO1xuZXhwb3J0IGNvbnN0IGlzUHVyZU9iamVjdCA9IHggPT4gaXNPYmplY3QoeCkgJiYgeC5jb25zdHJ1Y3RvciA9PT0ge30uY29uc3RydWN0b3I7XG5leHBvcnQgY29uc3QgaXNQcm9taXNlID0geCA9PiBpc09iamVjdCh4KSAmJiBpc0Z1bmN0aW9uKHgudGhlbik7XG5leHBvcnQgY29uc3QgaXNJdGVyYWJsZSA9IHggPT4geCAmJiB0eXBlb2YgeFtTeW1ib2wuaXRlcmF0b3JdID09PSAnZnVuY3Rpb24nO1xuZXhwb3J0IGNvbnN0IGlzQXN5bmNJdGVyYWJsZSA9IHggPT4geCAmJiB0eXBlb2YgeFtTeW1ib2wuYXN5bmNJdGVyYXRvcl0gPT09ICdmdW5jdGlvbic7XG5leHBvcnQgY29uc3QgaXNJdGVyYXRvciA9IHggPT4geCAmJiBpc0Z1bmN0aW9uKHgubmV4dCk7XG5leHBvcnQgY29uc3QgaXNSZXNwb25zZSA9IHggPT4gdHlwZW9mIFJlc3BvbnNlICE9PSAndW5kZWZpbmVkJyAmJiB4IGluc3RhbmNlb2YgUmVzcG9uc2UgfHwgeCAmJiB4LmFycmF5QnVmZmVyICYmIHgudGV4dCAmJiB4Lmpzb247XG5leHBvcnQgY29uc3QgaXNGaWxlID0geCA9PiB0eXBlb2YgRmlsZSAhPT0gJ3VuZGVmaW5lZCcgJiYgeCBpbnN0YW5jZW9mIEZpbGU7XG5leHBvcnQgY29uc3QgaXNCbG9iID0geCA9PiB0eXBlb2YgQmxvYiAhPT0gJ3VuZGVmaW5lZCcgJiYgeCBpbnN0YW5jZW9mIEJsb2I7XG5cbmV4cG9ydCBjb25zdCBpc0J1ZmZlciA9IHggPT4geCAmJiB0eXBlb2YgeCA9PT0gJ29iamVjdCcgJiYgeC5pc0J1ZmZlcjtcbmV4cG9ydCBjb25zdCBpc1dyaXRhYmxlRE9NU3RyZWFtID0geCA9PiBpc09iamVjdCh4KSAmJiBpc0Z1bmN0aW9uKHguYWJvcnQpICYmIGlzRnVuY3Rpb24oeC5nZXRXcml0ZXIpO1xuZXhwb3J0IGNvbnN0IGlzUmVhZGFibGVET01TdHJlYW0gPSB4ID0+IHR5cGVvZiBSZWFkYWJsZVN0cmVhbSAhPT0gJ3VuZGVmaW5lZCcgJiYgeCBpbnN0YW5jZW9mIFJlYWRhYmxlU3RyZWFtIHx8IGlzT2JqZWN0KHgpICYmIGlzRnVuY3Rpb24oeC50ZWUpICYmIGlzRnVuY3Rpb24oeC5jYW5jZWwpICYmIGlzRnVuY3Rpb24oeC5nZXRSZWFkZXIpO1xuXG5leHBvcnQgY29uc3QgaXNXcml0YWJsZU5vZGVTdHJlYW0gPSB4ID0+IGlzT2JqZWN0KHgpICYmIGlzRnVuY3Rpb24oeC5lbmQpICYmIGlzRnVuY3Rpb24oeC53cml0ZSkgJiYgaXNCb29sZWFuKHgud3JpdGFibGUpO1xuZXhwb3J0IGNvbnN0IGlzUmVhZGFibGVOb2RlU3RyZWFtID0geCA9PiBpc09iamVjdCh4KSAmJiBpc0Z1bmN0aW9uKHgucmVhZCkgJiYgaXNGdW5jdGlvbih4LnBpcGUpICYmIGlzQm9vbGVhbih4LnJlYWRhYmxlKTtcbmV4cG9ydCBjb25zdCBpc1JlYWRhYmxlU3RyZWFtID0geCA9PiBpc1JlYWRhYmxlRE9NU3RyZWFtKHgpIHx8IGlzUmVhZGFibGVOb2RlU3RyZWFtKHgpO1xuZXhwb3J0IGNvbnN0IGlzV3JpdGFibGVTdHJlYW0gPSB4ID0+IGlzV3JpdGFibGVET01TdHJlYW0oeCkgfHwgaXNXcml0YWJsZU5vZGVTdHJlYW0oeCk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pcy10eXBlLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///36255\n")},44534:function(__unused_webpack_module,__webpack_exports__,__webpack_require__){eval("\n// EXPORTS\n__webpack_require__.d(__webpack_exports__, {\n  \"z\": function() { return /* binding */ load; }\n});\n\n// EXTERNAL MODULE: ./node_modules/@loaders.gl/core/dist/esm/javascript-utils/is-type.js\nvar is_type = __webpack_require__(36255);\n// EXTERNAL MODULE: ./node_modules/@loaders.gl/core/dist/esm/lib/loader-utils/normalize-loader.js\nvar normalize_loader = __webpack_require__(52033);\n// EXTERNAL MODULE: ./node_modules/@loaders.gl/core/dist/esm/lib/loader-utils/option-utils.js + 4 modules\nvar option_utils = __webpack_require__(99597);\n// EXTERNAL MODULE: ./node_modules/@loaders.gl/worker-utils/dist/esm/lib/env-utils/assert.js\nvar assert = __webpack_require__(96040);\n;// CONCATENATED MODULE: ./node_modules/@loaders.gl/worker-utils/dist/esm/lib/env-utils/version.js\n\n\nconst DEFAULT_VERSION = 'beta';\nconst VERSION =  true ? \"3.3.1\" : 0;\nif (false) {}\n//# sourceMappingURL=version.js.map\n;// CONCATENATED MODULE: ./node_modules/@loaders.gl/worker-utils/dist/esm/lib/worker-api/validate-worker-version.js\n\n\n\nfunction validateWorkerVersion(worker) {\n  let coreVersion = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : VERSION;\n  (0,assert/* assert */.h)(worker, 'no worker provided');\n  const workerVersion = worker.version;\n  if (!coreVersion || !workerVersion) {\n    return false;\n  }\n\n  return true;\n}\n\nfunction parseVersion(version) {\n  const parts = version.split('.').map(Number);\n  return {\n    major: parts[0],\n    minor: parts[1]\n  };\n}\n//# sourceMappingURL=validate-worker-version.js.map\n// EXTERNAL MODULE: ./node_modules/@loaders.gl/worker-utils/dist/esm/lib/env-utils/globals.js\nvar globals = __webpack_require__(96013);\n// EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/esm/defineProperty.js\nvar defineProperty = __webpack_require__(82482);\n;// CONCATENATED MODULE: ./node_modules/@loaders.gl/worker-utils/dist/esm/lib/node/worker_threads-browser.js\n\nclass worker_threads_browser_Worker {\n  terminate() {}\n}\n\n\nconst parentPort = null;\n//# sourceMappingURL=worker_threads-browser.js.map\n;// CONCATENATED MODULE: ./node_modules/@loaders.gl/worker-utils/dist/esm/lib/worker-utils/get-loadable-worker-url.js\n\nconst workerURLCache = new Map();\n\nfunction getLoadableWorkerURL(props) {\n  (0,assert/* assert */.h)(props.source && !props.url || !props.source && props.url);\n\n  let workerURL = workerURLCache.get(props.source || props.url);\n  if (!workerURL) {\n    if (props.url) {\n      workerURL = getLoadableWorkerURLFromURL(props.url);\n      workerURLCache.set(props.url, workerURL);\n    }\n    if (props.source) {\n      workerURL = getLoadableWorkerURLFromSource(props.source);\n      workerURLCache.set(props.source, workerURL);\n    }\n  }\n  (0,assert/* assert */.h)(workerURL);\n  return workerURL;\n}\n\nfunction getLoadableWorkerURLFromURL(url) {\n  if (!url.startsWith('http')) {\n    return url;\n  }\n\n  const workerSource = buildScriptSource(url);\n  return getLoadableWorkerURLFromSource(workerSource);\n}\n\nfunction getLoadableWorkerURLFromSource(workerSource) {\n  const blob = new Blob([workerSource], {\n    type: 'application/javascript'\n  });\n  return URL.createObjectURL(blob);\n}\n\nfunction buildScriptSource(workerUrl) {\n  return \"try {\\n  importScripts('\".concat(workerUrl, \"');\\n} catch (error) {\\n  console.error(error);\\n  throw error;\\n}\");\n}\n//# sourceMappingURL=get-loadable-worker-url.js.map\n;// CONCATENATED MODULE: ./node_modules/@loaders.gl/worker-utils/dist/esm/lib/worker-utils/get-transfer-list.js\n\n\nfunction getTransferList(object) {\n  let recursive = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n  let transfers = arguments.length > 2 ? arguments[2] : undefined;\n  const transfersSet = transfers || new Set();\n  if (!object) {\n  } else if (isTransferable(object)) {\n    transfersSet.add(object);\n  } else if (isTransferable(object.buffer)) {\n    transfersSet.add(object.buffer);\n  } else if (ArrayBuffer.isView(object)) {\n  } else if (recursive && typeof object === 'object') {\n    for (const key in object) {\n      getTransferList(object[key], recursive, transfersSet);\n    }\n  }\n\n  return transfers === undefined ? Array.from(transfersSet) : [];\n}\n\nfunction isTransferable(object) {\n  if (!object) {\n    return false;\n  }\n  if (object instanceof ArrayBuffer) {\n    return true;\n  }\n  if (typeof MessagePort !== 'undefined' && object instanceof MessagePort) {\n    return true;\n  }\n  if (typeof ImageBitmap !== 'undefined' && object instanceof ImageBitmap) {\n    return true;\n  }\n  if (typeof OffscreenCanvas !== 'undefined' && object instanceof OffscreenCanvas) {\n    return true;\n  }\n  return false;\n}\n\nfunction getTransferListForWriter(object) {\n  if (object === null) {\n    return {};\n  }\n  const clone = Object.assign({}, object);\n  Object.keys(clone).forEach(key => {\n    if (typeof object[key] === 'object' && !ArrayBuffer.isView(object[key]) && !(object[key] instanceof Array)) {\n      clone[key] = getTransferListForWriter(object[key]);\n    } else if (typeof clone[key] === 'function' || clone[key] instanceof RegExp) {\n      clone[key] = {};\n    } else {\n      clone[key] = object[key];\n    }\n  });\n  return clone;\n}\n//# sourceMappingURL=get-transfer-list.js.map\n;// CONCATENATED MODULE: ./node_modules/@loaders.gl/worker-utils/dist/esm/lib/worker-farm/worker-thread.js\n\n\n\n\n\n\n\nconst NOOP = () => {};\nclass WorkerThread {\n  static isSupported() {\n    return typeof Worker !== 'undefined' && globals/* isBrowser */.jU || typeof worker_threads_browser_Worker !== 'undefined' && !globals/* isBrowser */.jU;\n  }\n  constructor(props) {\n    (0,defineProperty/* default */.Z)(this, \"name\", void 0);\n    (0,defineProperty/* default */.Z)(this, \"source\", void 0);\n    (0,defineProperty/* default */.Z)(this, \"url\", void 0);\n    (0,defineProperty/* default */.Z)(this, \"terminated\", false);\n    (0,defineProperty/* default */.Z)(this, \"worker\", void 0);\n    (0,defineProperty/* default */.Z)(this, \"onMessage\", void 0);\n    (0,defineProperty/* default */.Z)(this, \"onError\", void 0);\n    (0,defineProperty/* default */.Z)(this, \"_loadableURL\", '');\n    const {\n      name,\n      source,\n      url\n    } = props;\n    (0,assert/* assert */.h)(source || url);\n    this.name = name;\n    this.source = source;\n    this.url = url;\n    this.onMessage = NOOP;\n    this.onError = error => console.log(error);\n\n    this.worker = globals/* isBrowser */.jU ? this._createBrowserWorker() : this._createNodeWorker();\n  }\n\n  destroy() {\n    this.onMessage = NOOP;\n    this.onError = NOOP;\n    this.worker.terminate();\n    this.terminated = true;\n  }\n  get isRunning() {\n    return Boolean(this.onMessage);\n  }\n\n  postMessage(data, transferList) {\n    transferList = transferList || getTransferList(data);\n    this.worker.postMessage(data, transferList);\n  }\n\n  _getErrorFromErrorEvent(event) {\n    let message = 'Failed to load ';\n    message += \"worker \".concat(this.name, \" from \").concat(this.url, \". \");\n    if (event.message) {\n      message += \"\".concat(event.message, \" in \");\n    }\n    if (event.lineno) {\n      message += \":\".concat(event.lineno, \":\").concat(event.colno);\n    }\n    return new Error(message);\n  }\n\n  _createBrowserWorker() {\n    this._loadableURL = getLoadableWorkerURL({\n      source: this.source,\n      url: this.url\n    });\n    const worker = new Worker(this._loadableURL, {\n      name: this.name\n    });\n    worker.onmessage = event => {\n      if (!event.data) {\n        this.onError(new Error('No data received'));\n      } else {\n        this.onMessage(event.data);\n      }\n    };\n    worker.onerror = error => {\n      this.onError(this._getErrorFromErrorEvent(error));\n      this.terminated = true;\n    };\n    worker.onmessageerror = event => console.error(event);\n\n    return worker;\n  }\n\n  _createNodeWorker() {\n    let worker;\n    if (this.url) {\n      const absolute = this.url.includes(':/') || this.url.startsWith('/');\n      const url = absolute ? this.url : \"./\".concat(this.url);\n      worker = new worker_threads_browser_Worker(url, {\n        eval: false\n      });\n    } else if (this.source) {\n      worker = new worker_threads_browser_Worker(this.source, {\n        eval: true\n      });\n    } else {\n      throw new Error('no worker');\n    }\n    worker.on('message', data => {\n      this.onMessage(data);\n    });\n    worker.on('error', error => {\n      this.onError(error);\n    });\n    worker.on('exit', code => {\n    });\n    return worker;\n  }\n}\n//# sourceMappingURL=worker-thread.js.map\n;// CONCATENATED MODULE: ./node_modules/@loaders.gl/worker-utils/dist/esm/lib/worker-farm/worker-job.js\n\n\n\nclass WorkerJob {\n\n  constructor(jobName, workerThread) {\n    (0,defineProperty/* default */.Z)(this, \"name\", void 0);\n    (0,defineProperty/* default */.Z)(this, \"workerThread\", void 0);\n    (0,defineProperty/* default */.Z)(this, \"isRunning\", true);\n    (0,defineProperty/* default */.Z)(this, \"result\", void 0);\n    (0,defineProperty/* default */.Z)(this, \"_resolve\", () => {});\n    (0,defineProperty/* default */.Z)(this, \"_reject\", () => {});\n    this.name = jobName;\n    this.workerThread = workerThread;\n    this.result = new Promise((resolve, reject) => {\n      this._resolve = resolve;\n      this._reject = reject;\n    });\n  }\n\n  postMessage(type, payload) {\n    this.workerThread.postMessage({\n      source: 'loaders.gl',\n      type,\n      payload\n    });\n  }\n\n  done(value) {\n    (0,assert/* assert */.h)(this.isRunning);\n    this.isRunning = false;\n    this._resolve(value);\n  }\n\n  error(error) {\n    (0,assert/* assert */.h)(this.isRunning);\n    this.isRunning = false;\n    this._reject(error);\n  }\n}\n//# sourceMappingURL=worker-job.js.map\n;// CONCATENATED MODULE: ./node_modules/@loaders.gl/worker-utils/dist/esm/lib/worker-farm/worker-pool.js\n\n\n\n\n\nclass WorkerPool {\n\n  static isSupported() {\n    return WorkerThread.isSupported();\n  }\n\n  constructor(props) {\n    (0,defineProperty/* default */.Z)(this, \"name\", 'unnamed');\n    (0,defineProperty/* default */.Z)(this, \"source\", void 0);\n    (0,defineProperty/* default */.Z)(this, \"url\", void 0);\n    (0,defineProperty/* default */.Z)(this, \"maxConcurrency\", 1);\n    (0,defineProperty/* default */.Z)(this, \"maxMobileConcurrency\", 1);\n    (0,defineProperty/* default */.Z)(this, \"onDebug\", () => {});\n    (0,defineProperty/* default */.Z)(this, \"reuseWorkers\", true);\n    (0,defineProperty/* default */.Z)(this, \"props\", {});\n    (0,defineProperty/* default */.Z)(this, \"jobQueue\", []);\n    (0,defineProperty/* default */.Z)(this, \"idleQueue\", []);\n    (0,defineProperty/* default */.Z)(this, \"count\", 0);\n    (0,defineProperty/* default */.Z)(this, \"isDestroyed\", false);\n    this.source = props.source;\n    this.url = props.url;\n    this.setProps(props);\n  }\n\n  destroy() {\n    this.idleQueue.forEach(worker => worker.destroy());\n    this.isDestroyed = true;\n  }\n  setProps(props) {\n    this.props = {\n      ...this.props,\n      ...props\n    };\n    if (props.name !== undefined) {\n      this.name = props.name;\n    }\n    if (props.maxConcurrency !== undefined) {\n      this.maxConcurrency = props.maxConcurrency;\n    }\n    if (props.maxMobileConcurrency !== undefined) {\n      this.maxMobileConcurrency = props.maxMobileConcurrency;\n    }\n    if (props.reuseWorkers !== undefined) {\n      this.reuseWorkers = props.reuseWorkers;\n    }\n    if (props.onDebug !== undefined) {\n      this.onDebug = props.onDebug;\n    }\n  }\n  async startJob(name) {\n    let onMessage = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : (job, type, data) => job.done(data);\n    let onError = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : (job, error) => job.error(error);\n    const startPromise = new Promise(onStart => {\n      this.jobQueue.push({\n        name,\n        onMessage,\n        onError,\n        onStart\n      });\n      return this;\n    });\n    this._startQueuedJob();\n    return await startPromise;\n  }\n\n  async _startQueuedJob() {\n    if (!this.jobQueue.length) {\n      return;\n    }\n    const workerThread = this._getAvailableWorker();\n    if (!workerThread) {\n      return;\n    }\n\n    const queuedJob = this.jobQueue.shift();\n    if (queuedJob) {\n      this.onDebug({\n        message: 'Starting job',\n        name: queuedJob.name,\n        workerThread,\n        backlog: this.jobQueue.length\n      });\n\n      const job = new WorkerJob(queuedJob.name, workerThread);\n\n      workerThread.onMessage = data => queuedJob.onMessage(job, data.type, data.payload);\n      workerThread.onError = error => queuedJob.onError(job, error);\n\n      queuedJob.onStart(job);\n\n      try {\n        await job.result;\n      } finally {\n        this.returnWorkerToQueue(workerThread);\n      }\n    }\n  }\n\n  returnWorkerToQueue(worker) {\n    const shouldDestroyWorker = this.isDestroyed || !this.reuseWorkers || this.count > this._getMaxConcurrency();\n    if (shouldDestroyWorker) {\n      worker.destroy();\n      this.count--;\n    } else {\n      this.idleQueue.push(worker);\n    }\n    if (!this.isDestroyed) {\n      this._startQueuedJob();\n    }\n  }\n\n  _getAvailableWorker() {\n    if (this.idleQueue.length > 0) {\n      return this.idleQueue.shift() || null;\n    }\n\n    if (this.count < this._getMaxConcurrency()) {\n      this.count++;\n      const name = \"\".concat(this.name.toLowerCase(), \" (#\").concat(this.count, \" of \").concat(this.maxConcurrency, \")\");\n      return new WorkerThread({\n        name,\n        source: this.source,\n        url: this.url\n      });\n    }\n\n    return null;\n  }\n  _getMaxConcurrency() {\n    return globals/* isMobile */.tq ? this.maxMobileConcurrency : this.maxConcurrency;\n  }\n}\n//# sourceMappingURL=worker-pool.js.map\n;// CONCATENATED MODULE: ./node_modules/@loaders.gl/worker-utils/dist/esm/lib/worker-farm/worker-farm.js\n\n\n\n\nconst DEFAULT_PROPS = {\n  maxConcurrency: 3,\n  maxMobileConcurrency: 1,\n  reuseWorkers: true,\n  onDebug: () => {}\n};\n\nclass WorkerFarm {\n\n  static isSupported() {\n    return WorkerThread.isSupported();\n  }\n\n  static getWorkerFarm() {\n    let props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    WorkerFarm._workerFarm = WorkerFarm._workerFarm || new WorkerFarm({});\n    WorkerFarm._workerFarm.setProps(props);\n    return WorkerFarm._workerFarm;\n  }\n\n  constructor(props) {\n    (0,defineProperty/* default */.Z)(this, \"props\", void 0);\n    (0,defineProperty/* default */.Z)(this, \"workerPools\", new Map());\n    this.props = {\n      ...DEFAULT_PROPS\n    };\n    this.setProps(props);\n    this.workerPools = new Map();\n  }\n\n  destroy() {\n    for (const workerPool of this.workerPools.values()) {\n      workerPool.destroy();\n    }\n    this.workerPools = new Map();\n  }\n\n  setProps(props) {\n    this.props = {\n      ...this.props,\n      ...props\n    };\n    for (const workerPool of this.workerPools.values()) {\n      workerPool.setProps(this._getWorkerPoolProps());\n    }\n  }\n\n  getWorkerPool(options) {\n    const {\n      name,\n      source,\n      url\n    } = options;\n    let workerPool = this.workerPools.get(name);\n    if (!workerPool) {\n      workerPool = new WorkerPool({\n        name,\n        source,\n        url\n      });\n      workerPool.setProps(this._getWorkerPoolProps());\n      this.workerPools.set(name, workerPool);\n    }\n    return workerPool;\n  }\n  _getWorkerPoolProps() {\n    return {\n      maxConcurrency: this.props.maxConcurrency,\n      maxMobileConcurrency: this.props.maxMobileConcurrency,\n      reuseWorkers: this.props.reuseWorkers,\n      onDebug: this.props.onDebug\n    };\n  }\n}\n(0,defineProperty/* default */.Z)(WorkerFarm, \"_workerFarm\", void 0);\n//# sourceMappingURL=worker-farm.js.map\n;// CONCATENATED MODULE: ./node_modules/@loaders.gl/worker-utils/dist/esm/lib/worker-api/get-worker-url.js\n\n\n\n\nconst NPM_TAG = 'latest';\nconst get_worker_url_VERSION = (/* unused pure expression or super */ null && ( true ? \"3.3.1\" : 0));\n\nfunction getWorkerName(worker) {\n  const warning = worker.version !== get_worker_url_VERSION ? \" (worker-utils@\".concat(get_worker_url_VERSION, \")\") : '';\n  return \"\".concat(worker.name, \"@\").concat(worker.version).concat(warning);\n}\n\nfunction getWorkerURL(worker) {\n  let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  const workerOptions = options[worker.id] || {};\n  const workerFile = \"\".concat(worker.id, \"-worker.js\");\n  let url = workerOptions.workerUrl;\n\n  if (!url && worker.id === 'compression') {\n    url = options.workerUrl;\n  }\n\n  if (options._workerType === 'test') {\n    url = \"modules/\".concat(worker.module, \"/dist/\").concat(workerFile);\n  }\n\n  if (!url) {\n    let version = worker.version;\n    if (version === 'latest') {\n      version = NPM_TAG;\n    }\n    const versionTag = version ? \"@\".concat(version) : '';\n    url = \"https://unpkg.com/@loaders.gl/\".concat(worker.module).concat(versionTag, \"/dist/\").concat(workerFile);\n  }\n  (0,assert/* assert */.h)(url);\n\n  return url;\n}\n//# sourceMappingURL=get-worker-url.js.map\n;// CONCATENATED MODULE: ./node_modules/@loaders.gl/loader-utils/dist/esm/lib/worker-loader-utils/parse-with-worker.js\n\n\n\nfunction canParseWithWorker(loader, options) {\n  if (!WorkerFarm.isSupported()) {\n    return false;\n  }\n\n  if (!globals/* isBrowser */.jU && !(options !== null && options !== void 0 && options._nodeWorkers)) {\n    return false;\n  }\n  return loader.worker && (options === null || options === void 0 ? void 0 : options.worker);\n}\n\nasync function parseWithWorker(loader, data, options, context, parseOnMainThread) {\n  const name = loader.id;\n  const url = getWorkerURL(loader, options);\n  const workerFarm = WorkerFarm.getWorkerFarm(options);\n  const workerPool = workerFarm.getWorkerPool({\n    name,\n    url\n  });\n\n  options = JSON.parse(JSON.stringify(options));\n  context = JSON.parse(JSON.stringify(context || {}));\n  const job = await workerPool.startJob('process-on-worker',\n  onMessage.bind(null, parseOnMainThread));\n\n  job.postMessage('process', {\n    input: data,\n    options,\n    context\n  });\n  const result = await job.result;\n  return await result.result;\n}\n\nasync function onMessage(parseOnMainThread, job, type, payload) {\n  switch (type) {\n    case 'done':\n      job.done(payload);\n      break;\n    case 'error':\n      job.error(new Error(payload.error));\n      break;\n    case 'process':\n      const {\n        id,\n        input,\n        options\n      } = payload;\n      try {\n        const result = await parseOnMainThread(input, options);\n        job.postMessage('done', {\n          id,\n          result\n        });\n      } catch (error) {\n        const message = error instanceof Error ? error.message : 'unknown error';\n        job.postMessage('error', {\n          id,\n          error: message\n        });\n      }\n      break;\n    default:\n      console.warn(\"parse-with-worker unknown message \".concat(type));\n  }\n}\n//# sourceMappingURL=parse-with-worker.js.map\n// EXTERNAL MODULE: ./node_modules/@loaders.gl/loader-utils/dist/esm/lib/binary-utils/array-buffer-utils.js\nvar array_buffer_utils = __webpack_require__(74609);\n;// CONCATENATED MODULE: ./node_modules/@loaders.gl/loader-utils/dist/esm/lib/iterators/async-iteration.js\n\n\nasync function forEach(iterator, visitor) {\n  while (true) {\n    const {\n      done,\n      value\n    } = await iterator.next();\n    if (done) {\n      iterator.return();\n      return;\n    }\n    const cancel = visitor(value);\n    if (cancel) {\n      return;\n    }\n  }\n}\n\nasync function concatenateArrayBuffersAsync(asyncIterator) {\n  const arrayBuffers = [];\n  for await (const chunk of asyncIterator) {\n    arrayBuffers.push(chunk);\n  }\n  return (0,array_buffer_utils/* concatenateArrayBuffers */.JY)(...arrayBuffers);\n}\nasync function concatenateStringsAsync(asyncIterator) {\n  const strings = [];\n  for await (const chunk of asyncIterator) {\n    strings.push(chunk);\n  }\n  return strings.join('');\n}\n//# sourceMappingURL=async-iteration.js.map\n;// CONCATENATED MODULE: ./node_modules/@loaders.gl/core/dist/esm/iterators/make-iterator/make-string-iterator.js\nconst DEFAULT_CHUNK_SIZE = 256 * 1024;\n\nfunction* makeStringIterator(string, options) {\n  const chunkSize = (options === null || options === void 0 ? void 0 : options.chunkSize) || DEFAULT_CHUNK_SIZE;\n  let offset = 0;\n  const textEncoder = new TextEncoder();\n  while (offset < string.length) {\n    const chunkLength = Math.min(string.length - offset, chunkSize);\n    const chunk = string.slice(offset, offset + chunkLength);\n    offset += chunkLength;\n\n    yield textEncoder.encode(chunk);\n  }\n}\n//# sourceMappingURL=make-string-iterator.js.map\n;// CONCATENATED MODULE: ./node_modules/@loaders.gl/core/dist/esm/iterators/make-iterator/make-array-buffer-iterator.js\nconst make_array_buffer_iterator_DEFAULT_CHUNK_SIZE = 256 * 1024;\n\nfunction* makeArrayBufferIterator(arrayBuffer) {\n  let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  const {\n    chunkSize = make_array_buffer_iterator_DEFAULT_CHUNK_SIZE\n  } = options;\n  let byteOffset = 0;\n  while (byteOffset < arrayBuffer.byteLength) {\n    const chunkByteLength = Math.min(arrayBuffer.byteLength - byteOffset, chunkSize);\n    const chunk = new ArrayBuffer(chunkByteLength);\n\n    const sourceArray = new Uint8Array(arrayBuffer, byteOffset, chunkByteLength);\n    const chunkArray = new Uint8Array(chunk);\n    chunkArray.set(sourceArray);\n\n    byteOffset += chunkByteLength;\n    yield chunk;\n  }\n}\n//# sourceMappingURL=make-array-buffer-iterator.js.map\n;// CONCATENATED MODULE: ./node_modules/@loaders.gl/core/dist/esm/iterators/make-iterator/make-blob-iterator.js\nconst make_blob_iterator_DEFAULT_CHUNK_SIZE = 1024 * 1024;\n\nasync function* makeBlobIterator(blob, options) {\n  const chunkSize = (options === null || options === void 0 ? void 0 : options.chunkSize) || make_blob_iterator_DEFAULT_CHUNK_SIZE;\n  let offset = 0;\n  while (offset < blob.size) {\n    const end = offset + chunkSize;\n    const chunk = await blob.slice(offset, end).arrayBuffer();\n    offset = end;\n    yield chunk;\n  }\n}\n//# sourceMappingURL=make-blob-iterator.js.map\n// EXTERNAL MODULE: ./node_modules/@loaders.gl/loader-utils/dist/esm/lib/env-utils/globals.js\nvar env_utils_globals = __webpack_require__(84959);\n// EXTERNAL MODULE: ../node/buffer (ignored)\nvar buffer_ignored_ = __webpack_require__(9521);\n;// CONCATENATED MODULE: ./node_modules/@loaders.gl/loader-utils/dist/esm/lib/binary-utils/memory-conversion-utils.js\n\n\n\n\nfunction isBuffer(value) {\n  return value && typeof value === 'object' && value.isBuffer;\n}\n\nfunction toBuffer(data) {\n  return node.toBuffer ? node.toBuffer(data) : data;\n}\n\nfunction toArrayBuffer(data) {\n  if (isBuffer(data)) {\n    return buffer_ignored_.toArrayBuffer(data);\n  }\n  if (data instanceof ArrayBuffer) {\n    return data;\n  }\n\n  if (ArrayBuffer.isView(data)) {\n    if (data.byteOffset === 0 && data.byteLength === data.buffer.byteLength) {\n      return data.buffer;\n    }\n    return data.buffer.slice(data.byteOffset, data.byteOffset + data.byteLength);\n  }\n  if (typeof data === 'string') {\n    const text = data;\n    const uint8Array = new TextEncoder().encode(text);\n    return uint8Array.buffer;\n  }\n\n  if (data && typeof data === 'object' && data._toArrayBuffer) {\n    return data._toArrayBuffer();\n  }\n  throw new Error('toArrayBuffer');\n}\n//# sourceMappingURL=memory-conversion-utils.js.map\n;// CONCATENATED MODULE: ./node_modules/@loaders.gl/core/dist/esm/iterators/make-iterator/make-stream-iterator.js\n\nfunction makeStreamIterator(stream, options) {\n  return env_utils_globals/* isBrowser */.jU ? makeBrowserStreamIterator(stream, options) : makeNodeStreamIterator(stream, options);\n}\n\nasync function* makeBrowserStreamIterator(stream, options) {\n\n  const reader = stream.getReader();\n  let nextBatchPromise;\n  try {\n    while (true) {\n      const currentBatchPromise = nextBatchPromise || reader.read();\n      if (options !== null && options !== void 0 && options._streamReadAhead) {\n        nextBatchPromise = reader.read();\n      }\n      const {\n        done,\n        value\n      } = await currentBatchPromise;\n      if (done) {\n        return;\n      }\n      yield toArrayBuffer(value);\n    }\n  } catch (error) {\n    reader.releaseLock();\n  }\n}\n\nasync function* makeNodeStreamIterator(stream, options) {\n  for await (const chunk of stream) {\n    yield toArrayBuffer(chunk);\n  }\n}\n//# sourceMappingURL=make-stream-iterator.js.map\n;// CONCATENATED MODULE: ./node_modules/@loaders.gl/core/dist/esm/iterators/make-iterator/make-iterator.js\n\n\n\n\n\n\nfunction make_iterator_makeIterator(data, options) {\n  if (typeof data === 'string') {\n    return makeStringIterator(data, options);\n  }\n  if (data instanceof ArrayBuffer) {\n    return makeArrayBufferIterator(data, options);\n  }\n  if ((0,is_type/* isBlob */.Lj)(data)) {\n    return makeBlobIterator(data, options);\n  }\n  if ((0,is_type/* isReadableStream */.Os)(data)) {\n    return makeStreamIterator(data, options);\n  }\n  if ((0,is_type/* isResponse */.Ew)(data)) {\n    const response = data;\n    return makeStreamIterator(response.body, options);\n  }\n  throw new Error('makeIterator');\n}\n//# sourceMappingURL=make-iterator.js.map\n// EXTERNAL MODULE: ./node_modules/@loaders.gl/core/dist/esm/lib/utils/response-utils.js\nvar response_utils = __webpack_require__(17927);\n;// CONCATENATED MODULE: ./node_modules/@loaders.gl/core/dist/esm/lib/loader-utils/get-data.js\n\n\n\n\nconst ERR_DATA = 'Cannot convert supplied data type';\n\nfunction getArrayBufferOrStringFromDataSync(data, loader, options) {\n  if (loader.text && typeof data === 'string') {\n    return data;\n  }\n  if ((0,is_type/* isBuffer */.zH)(data)) {\n    data = data.buffer;\n  }\n  if (data instanceof ArrayBuffer) {\n    const arrayBuffer = data;\n    if (loader.text && !loader.binary) {\n      const textDecoder = new TextDecoder('utf8');\n      return textDecoder.decode(arrayBuffer);\n    }\n    return arrayBuffer;\n  }\n\n  if (ArrayBuffer.isView(data)) {\n    if (loader.text && !loader.binary) {\n      const textDecoder = new TextDecoder('utf8');\n      return textDecoder.decode(data);\n    }\n    let arrayBuffer = data.buffer;\n\n    const byteLength = data.byteLength || data.length;\n    if (data.byteOffset !== 0 || byteLength !== arrayBuffer.byteLength) {\n      arrayBuffer = arrayBuffer.slice(data.byteOffset, data.byteOffset + byteLength);\n    }\n    return arrayBuffer;\n  }\n  throw new Error(ERR_DATA);\n}\n\nasync function getArrayBufferOrStringFromData(data, loader, options) {\n  const isArrayBuffer = data instanceof ArrayBuffer || ArrayBuffer.isView(data);\n  if (typeof data === 'string' || isArrayBuffer) {\n    return getArrayBufferOrStringFromDataSync(data, loader, options);\n  }\n\n  if ((0,is_type/* isBlob */.Lj)(data)) {\n    data = await (0,response_utils/* makeResponse */.L1)(data);\n  }\n  if ((0,is_type/* isResponse */.Ew)(data)) {\n    const response = data;\n    await (0,response_utils/* checkResponse */.mm)(response);\n    return loader.binary ? await response.arrayBuffer() : await response.text();\n  }\n  if ((0,is_type/* isReadableStream */.Os)(data)) {\n    data = make_iterator_makeIterator(data, options);\n  }\n  if ((0,is_type/* isIterable */.TW)(data) || (0,is_type/* isAsyncIterable */.D0)(data)) {\n    return concatenateArrayBuffersAsync(data);\n  }\n  throw new Error(ERR_DATA);\n}\nasync function getAsyncIterableFromData(data, options) {\n  if (isIterator(data)) {\n    return data;\n  }\n  if (isResponse(data)) {\n    const response = data;\n    await checkResponse(response);\n    const body = await response.body;\n    return makeIterator(body, options);\n  }\n  if (isBlob(data) || isReadableStream(data)) {\n    return makeIterator(data, options);\n  }\n  if (isAsyncIterable(data)) {\n    return data[Symbol.asyncIterator]();\n  }\n  return getIterableFromData(data);\n}\nasync function getReadableStream(data) {\n  if (isReadableStream(data)) {\n    return data;\n  }\n  if (isResponse(data)) {\n    return data.body;\n  }\n  const response = await makeResponse(data);\n  return response.body;\n}\n\nfunction getIterableFromData(data) {\n  if (ArrayBuffer.isView(data)) {\n    return function* oneChunk() {\n      yield data.buffer;\n    }();\n  }\n  if (data instanceof ArrayBuffer) {\n    return function* oneChunk() {\n      yield data;\n    }();\n  }\n  if (isIterator(data)) {\n    return data;\n  }\n  if (isIterable(data)) {\n    return data[Symbol.iterator]();\n  }\n  throw new Error(ERR_DATA);\n}\n//# sourceMappingURL=get-data.js.map\n;// CONCATENATED MODULE: ./node_modules/@loaders.gl/core/dist/esm/lib/loader-utils/loader-context.js\n\n\nfunction getLoaderContext(context, options) {\n  let previousContext = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n  if (previousContext) {\n    return previousContext;\n  }\n  const resolvedContext = {\n    fetch: (0,option_utils/* getFetchFunction */.bV)(options, context),\n    ...context\n  };\n\n  if (!Array.isArray(resolvedContext.loaders)) {\n    resolvedContext.loaders = null;\n  }\n  return resolvedContext;\n}\n\nfunction getLoadersFromContext(loaders, context) {\n  if (!context && loaders && !Array.isArray(loaders)) {\n    return loaders;\n  }\n\n  let candidateLoaders;\n  if (loaders) {\n    candidateLoaders = Array.isArray(loaders) ? loaders : [loaders];\n  }\n  if (context && context.loaders) {\n    const contextLoaders = Array.isArray(context.loaders) ? context.loaders : [context.loaders];\n    candidateLoaders = candidateLoaders ? [...candidateLoaders, ...contextLoaders] : contextLoaders;\n  }\n  return candidateLoaders && candidateLoaders.length ? candidateLoaders : null;\n}\n//# sourceMappingURL=loader-context.js.map\n// EXTERNAL MODULE: ./node_modules/@loaders.gl/core/dist/esm/lib/utils/resource-utils.js + 1 modules\nvar resource_utils = __webpack_require__(74642);\n;// CONCATENATED MODULE: ./node_modules/@loaders.gl/loader-utils/dist/esm/lib/path-utils/path.js\n\n\nfunction filename(url) {\n  const slashIndex = url && url.lastIndexOf('/');\n  return slashIndex >= 0 ? url.substr(slashIndex + 1) : '';\n}\n\nfunction dirname(url) {\n  const slashIndex = url && url.lastIndexOf('/');\n  return slashIndex >= 0 ? url.substr(0, slashIndex) : '';\n}\n\nfunction join() {\n  for (var _len = arguments.length, parts = new Array(_len), _key = 0; _key < _len; _key++) {\n    parts[_key] = arguments[_key];\n  }\n  const separator = '/';\n  parts = parts.map((part, index) => {\n    if (index) {\n      part = part.replace(new RegExp(\"^\".concat(separator)), '');\n    }\n    if (index !== parts.length - 1) {\n      part = part.replace(new RegExp(\"\".concat(separator, \"$\")), '');\n    }\n    return part;\n  });\n  return parts.join(separator);\n}\n//# sourceMappingURL=path.js.map\n// EXTERNAL MODULE: ./node_modules/@probe.gl/log/dist/esm/log.js + 8 modules\nvar log = __webpack_require__(56426);\n;// CONCATENATED MODULE: ./node_modules/@loaders.gl/core/dist/esm/lib/utils/log.js\n\n\nconst log_log = new log/* Log */.Z({\n  id: 'loaders.gl'\n});\n//# sourceMappingURL=log.js.map\n// EXTERNAL MODULE: ./node_modules/@loaders.gl/core/dist/esm/lib/api/register-loaders.js\nvar register_loaders = __webpack_require__(6228);\n;// CONCATENATED MODULE: ./node_modules/@loaders.gl/core/dist/esm/lib/api/select-loader.js\n\n\n\n\n\n\nconst EXT_PATTERN = /\\.([^.]+)$/;\n\nasync function selectLoader(data) {\n  let loaders = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n  let options = arguments.length > 2 ? arguments[2] : undefined;\n  let context = arguments.length > 3 ? arguments[3] : undefined;\n  if (!validHTTPResponse(data)) {\n    return null;\n  }\n\n  let loader = selectLoaderSync(data, loaders, {\n    ...options,\n    nothrow: true\n  }, context);\n  if (loader) {\n    return loader;\n  }\n\n  if ((0,is_type/* isBlob */.Lj)(data)) {\n    data = await data.slice(0, 10).arrayBuffer();\n    loader = selectLoaderSync(data, loaders, options, context);\n  }\n\n  if (!loader && !(options !== null && options !== void 0 && options.nothrow)) {\n    throw new Error(getNoValidLoaderMessage(data));\n  }\n  return loader;\n}\n\nfunction selectLoaderSync(data) {\n  let loaders = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n  let options = arguments.length > 2 ? arguments[2] : undefined;\n  let context = arguments.length > 3 ? arguments[3] : undefined;\n  if (!validHTTPResponse(data)) {\n    return null;\n  }\n\n  if (loaders && !Array.isArray(loaders)) {\n    return (0,normalize_loader/* normalizeLoader */.T)(loaders);\n  }\n\n  let candidateLoaders = [];\n  if (loaders) {\n    candidateLoaders = candidateLoaders.concat(loaders);\n  }\n  if (!(options !== null && options !== void 0 && options.ignoreRegisteredLoaders)) {\n    candidateLoaders.push(...(0,register_loaders/* getRegisteredLoaders */.kO)());\n  }\n\n  normalizeLoaders(candidateLoaders);\n  const loader = selectLoaderInternal(data, candidateLoaders, options, context);\n\n  if (!loader && !(options !== null && options !== void 0 && options.nothrow)) {\n    throw new Error(getNoValidLoaderMessage(data));\n  }\n  return loader;\n}\n\nfunction selectLoaderInternal(data, loaders, options, context) {\n  const {\n    url,\n    type\n  } = (0,resource_utils/* getResourceUrlAndType */.l)(data);\n  const testUrl = url || (context === null || context === void 0 ? void 0 : context.url);\n  let loader = null;\n  let reason = '';\n\n  if (options !== null && options !== void 0 && options.mimeType) {\n    loader = findLoaderByMIMEType(loaders, options === null || options === void 0 ? void 0 : options.mimeType);\n    reason = \"match forced by supplied MIME type \".concat(options === null || options === void 0 ? void 0 : options.mimeType);\n  }\n\n  loader = loader || findLoaderByUrl(loaders, testUrl);\n  reason = reason || (loader ? \"matched url \".concat(testUrl) : '');\n\n  loader = loader || findLoaderByMIMEType(loaders, type);\n  reason = reason || (loader ? \"matched MIME type \".concat(type) : '');\n\n  loader = loader || findLoaderByInitialBytes(loaders, data);\n  reason = reason || (loader ? \"matched initial data \".concat(getFirstCharacters(data)) : '');\n\n  loader = loader || findLoaderByMIMEType(loaders, options === null || options === void 0 ? void 0 : options.fallbackMimeType);\n  reason = reason || (loader ? \"matched fallback MIME type \".concat(type) : '');\n  if (reason) {\n    var _loader;\n    log_log.log(1, \"selectLoader selected \".concat((_loader = loader) === null || _loader === void 0 ? void 0 : _loader.name, \": \").concat(reason, \".\"));\n  }\n  return loader;\n}\n\nfunction validHTTPResponse(data) {\n  if (data instanceof Response) {\n    if (data.status === 204) {\n      return false;\n    }\n  }\n  return true;\n}\n\nfunction getNoValidLoaderMessage(data) {\n  const {\n    url,\n    type\n  } = (0,resource_utils/* getResourceUrlAndType */.l)(data);\n  let message = 'No valid loader found (';\n  message += url ? \"\".concat(filename(url), \", \") : 'no url provided, ';\n  message += \"MIME type: \".concat(type ? \"\\\"\".concat(type, \"\\\"\") : 'not provided', \", \");\n  const firstCharacters = data ? getFirstCharacters(data) : '';\n  message += firstCharacters ? \" first bytes: \\\"\".concat(firstCharacters, \"\\\"\") : 'first bytes: not available';\n  message += ')';\n  return message;\n}\nfunction normalizeLoaders(loaders) {\n  for (const loader of loaders) {\n    (0,normalize_loader/* normalizeLoader */.T)(loader);\n  }\n}\n\nfunction findLoaderByUrl(loaders, url) {\n  const match = url && EXT_PATTERN.exec(url);\n  const extension = match && match[1];\n  return extension ? findLoaderByExtension(loaders, extension) : null;\n}\nfunction findLoaderByExtension(loaders, extension) {\n  extension = extension.toLowerCase();\n  for (const loader of loaders) {\n    for (const loaderExtension of loader.extensions) {\n      if (loaderExtension.toLowerCase() === extension) {\n        return loader;\n      }\n    }\n  }\n  return null;\n}\nfunction findLoaderByMIMEType(loaders, mimeType) {\n  for (const loader of loaders) {\n    if (loader.mimeTypes && loader.mimeTypes.includes(mimeType)) {\n      return loader;\n    }\n\n    if (mimeType === \"application/x.\".concat(loader.id)) {\n      return loader;\n    }\n  }\n  return null;\n}\nfunction findLoaderByInitialBytes(loaders, data) {\n  if (!data) {\n    return null;\n  }\n  for (const loader of loaders) {\n    if (typeof data === 'string') {\n      if (testDataAgainstText(data, loader)) {\n        return loader;\n      }\n    } else if (ArrayBuffer.isView(data)) {\n      if (testDataAgainstBinary(data.buffer, data.byteOffset, loader)) {\n        return loader;\n      }\n    } else if (data instanceof ArrayBuffer) {\n      const byteOffset = 0;\n      if (testDataAgainstBinary(data, byteOffset, loader)) {\n        return loader;\n      }\n    }\n  }\n\n  return null;\n}\nfunction testDataAgainstText(data, loader) {\n  if (loader.testText) {\n    return loader.testText(data);\n  }\n  const tests = Array.isArray(loader.tests) ? loader.tests : [loader.tests];\n  return tests.some(test => data.startsWith(test));\n}\nfunction testDataAgainstBinary(data, byteOffset, loader) {\n  const tests = Array.isArray(loader.tests) ? loader.tests : [loader.tests];\n  return tests.some(test => testBinary(data, byteOffset, loader, test));\n}\nfunction testBinary(data, byteOffset, loader, test) {\n  if (test instanceof ArrayBuffer) {\n    return (0,array_buffer_utils/* compareArrayBuffers */.Xq)(test, data, test.byteLength);\n  }\n  switch (typeof test) {\n    case 'function':\n      return test(data, loader);\n    case 'string':\n      const magic = getMagicString(data, byteOffset, test.length);\n      return test === magic;\n    default:\n      return false;\n  }\n}\nfunction getFirstCharacters(data) {\n  let length = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 5;\n  if (typeof data === 'string') {\n    return data.slice(0, length);\n  } else if (ArrayBuffer.isView(data)) {\n    return getMagicString(data.buffer, data.byteOffset, length);\n  } else if (data instanceof ArrayBuffer) {\n    const byteOffset = 0;\n    return getMagicString(data, byteOffset, length);\n  }\n  return '';\n}\nfunction getMagicString(arrayBuffer, byteOffset, length) {\n  if (arrayBuffer.byteLength < byteOffset + length) {\n    return '';\n  }\n  const dataView = new DataView(arrayBuffer);\n  let magic = '';\n  for (let i = 0; i < length; i++) {\n    magic += String.fromCharCode(dataView.getUint8(byteOffset + i));\n  }\n  return magic;\n}\n//# sourceMappingURL=select-loader.js.map\n;// CONCATENATED MODULE: ./node_modules/@loaders.gl/core/dist/esm/lib/api/parse.js\n\n\n\n\n\n\n\n\n\n\nasync function parse(data, loaders, options, context) {\n  (0,assert/* assert */.h)(!context || typeof context === 'object');\n\n  if (loaders && !Array.isArray(loaders) && !(0,normalize_loader/* isLoaderObject */.C)(loaders)) {\n    context = undefined;\n    options = loaders;\n    loaders = undefined;\n  }\n  data = await data;\n  options = options || {};\n\n  const {\n    url\n  } = (0,resource_utils/* getResourceUrlAndType */.l)(data);\n\n  const typedLoaders = loaders;\n  const candidateLoaders = getLoadersFromContext(typedLoaders, context);\n  const loader = await selectLoader(data, candidateLoaders, options);\n  if (!loader) {\n    return null;\n  }\n\n  options = (0,option_utils/* normalizeOptions */.GR)(options, loader, candidateLoaders, url);\n\n  context = getLoaderContext({\n    url,\n    parse,\n    loaders: candidateLoaders\n  }, options, context);\n  return await parseWithLoader(loader, data, options, context);\n}\n\nasync function parseWithLoader(loader, data, options, context) {\n  validateWorkerVersion(loader);\n  if ((0,is_type/* isResponse */.Ew)(data)) {\n    const response = data;\n    const {\n      ok,\n      redirected,\n      status,\n      statusText,\n      type,\n      url\n    } = response;\n    const headers = Object.fromEntries(response.headers.entries());\n    context.response = {\n      headers,\n      ok,\n      redirected,\n      status,\n      statusText,\n      type,\n      url\n    };\n  }\n  data = await getArrayBufferOrStringFromData(data, loader, options);\n\n  if (loader.parseTextSync && typeof data === 'string') {\n    options.dataType = 'text';\n    return loader.parseTextSync(data, options, context, loader);\n  }\n\n  if (canParseWithWorker(loader, options)) {\n    return await parseWithWorker(loader, data, options, context, parse);\n  }\n\n  if (loader.parseText && typeof data === 'string') {\n    return await loader.parseText(data, options, context, loader);\n  }\n  if (loader.parse) {\n    return await loader.parse(data, options, context, loader);\n  }\n\n  (0,assert/* assert */.h)(!loader.parseSync);\n\n  throw new Error(\"\".concat(loader.id, \" loader - no parser found and worker is disabled\"));\n}\n//# sourceMappingURL=parse.js.map\n;// CONCATENATED MODULE: ./node_modules/@loaders.gl/core/dist/esm/lib/api/load.js\n\n\n\n\n\nasync function load(url, loaders, options, context) {\n  if (!Array.isArray(loaders) && !(0,normalize_loader/* isLoaderObject */.C)(loaders)) {\n    context = undefined;\n    options = loaders;\n    loaders = undefined;\n  }\n\n  const fetch = (0,option_utils/* getFetchFunction */.bV)(options);\n\n  let data = url;\n  if (typeof url === 'string') {\n    data = await fetch(url);\n  }\n\n  if ((0,is_type/* isBlob */.Lj)(url)) {\n    data = await fetch(url);\n  }\n\n  return await parse(data, loaders, options);\n}\n//# sourceMappingURL=load.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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RUEsTUFBTSwwQkFBTTtBQUNaO0FBQ0E7O0FBRUEsZUFBZSxLQUFLO0FBQ3BCO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly92dWUzLXdlYnBhY2s1Ly4vbm9kZV9tb2R1bGVzL0Bsb2FkZXJzLmdsL3dvcmtlci11dGlscy9kaXN0L2VzbS9saWIvZW52LXV0aWxzL3ZlcnNpb24uanM/Y2Q0ZSIsIndlYnBhY2s6Ly92dWUzLXdlYnBhY2s1Ly4vbm9kZV9tb2R1bGVzL0Bsb2FkZXJzLmdsL3dvcmtlci11dGlscy9kaXN0L2VzbS9saWIvd29ya2VyLWFwaS92YWxpZGF0ZS13b3JrZXItdmVyc2lvbi5qcz83MjFkIiwid2VicGFjazovL3Z1ZTMtd2VicGFjazUvLi9ub2RlX21vZHVsZXMvQGxvYWRlcnMuZ2wvd29ya2VyLXV0aWxzL2Rpc3QvZXNtL2xpYi9ub2RlL3dvcmtlcl90aHJlYWRzLWJyb3dzZXIuanM/MTNmOCIsIndlYnBhY2s6Ly92dWUzLXdlYnBhY2s1Ly4vbm9kZV9tb2R1bGVzL0Bsb2FkZXJzLmdsL3dvcmtlci11dGlscy9kaXN0L2VzbS9saWIvd29ya2VyLXV0aWxzL2dldC1sb2FkYWJsZS13b3JrZXItdXJsLmpzPzc2NjIiLCJ3ZWJwYWNrOi8vdnVlMy13ZWJwYWNrNS8uL25vZGVfbW9kdWxlcy9AbG9hZGVycy5nbC93b3JrZXItdXRpbHMvZGlzdC9lc20vbGliL3dvcmtlci11dGlscy9nZXQtdHJhbnNmZXItbGlzdC5qcz9mZWEyIiwid2VicGFjazovL3Z1ZTMtd2VicGFjazUvLi9ub2RlX21vZHVsZXMvQGxvYWRlcnMuZ2wvd29ya2VyLXV0aWxzL2Rpc3QvZXNtL2xpYi93b3JrZXItZmFybS93b3JrZXItdGhyZWFkLmpzPzQzYzQiLCJ3ZWJwYWNrOi8vdnVlMy13ZWJwYWNrNS8uL25vZGVfbW9kdWxlcy9AbG9hZGVycy5nbC93b3JrZXItdXRpbHMvZGlzdC9lc20vbGliL3dvcmtlci1mYXJtL3dvcmtlci1qb2IuanM/ZDk3OCIsIndlYnBhY2s6Ly92dWUzLXdlYnBhY2s1Ly4vbm9kZV9tb2R1bGVzL0Bsb2FkZXJzLmdsL3dvcmtlci11dGlscy9kaXN0L2VzbS9saWIvd29ya2VyLWZhcm0vd29ya2VyLXBvb2wuanM/YjYxMiIsIndlYnBhY2s6Ly92dWUzLXdlYnBhY2s1Ly4vbm9kZV9tb2R1bGVzL0Bsb2FkZXJzLmdsL3dvcmtlci11dGlscy9kaXN0L2VzbS9saWIvd29ya2VyLWZhcm0vd29ya2VyLWZhcm0uanM/ZGJlNyIsIndlYnBhY2s6Ly92dWUzLXdlYnBhY2s1Ly4vbm9kZV9tb2R1bGVzL0Bsb2FkZXJzLmdsL3dvcmtlci11dGlscy9kaXN0L2VzbS9saWIvd29ya2VyLWFwaS9nZXQtd29ya2VyLXVybC5qcz9mYTI5Iiwid2VicGFjazovL3Z1ZTMtd2VicGFjazUvLi9ub2RlX21vZHVsZXMvQGxvYWRlcnMuZ2wvbG9hZGVyLXV0aWxzL2Rpc3QvZXNtL2xpYi93b3JrZXItbG9hZGVyLXV0aWxzL3BhcnNlLXdpdGgtd29ya2VyLmpzP2Y2MDIiLCJ3ZWJwYWNrOi8vdnVlMy13ZWJwYWNrNS8uL25vZGVfbW9kdWxlcy9AbG9hZGVycy5nbC9sb2FkZXItdXRpbHMvZGlzdC9lc20vbGliL2l0ZXJhdG9ycy9hc3luYy1pdGVyYXRpb24uanM/MzZkNSIsIndlYnBhY2s6Ly92dWUzLXdlYnBhY2s1Ly4vbm9kZV9tb2R1bGVzL0Bsb2FkZXJzLmdsL2NvcmUvZGlzdC9lc20vaXRlcmF0b3JzL21ha2UtaXRlcmF0b3IvbWFrZS1zdHJpbmctaXRlcmF0b3IuanM/NjBjZCIsIndlYnBhY2s6Ly92dWUzLXdlYnBhY2s1Ly4vbm9kZV9tb2R1bGVzL0Bsb2FkZXJzLmdsL2NvcmUvZGlzdC9lc20vaXRlcmF0b3JzL21ha2UtaXRlcmF0b3IvbWFrZS1hcnJheS1idWZmZXItaXRlcmF0b3IuanM/Mzc2NiIsIndlYnBhY2s6Ly92dWUzLXdlYnBhY2s1Ly4vbm9kZV9tb2R1bGVzL0Bsb2FkZXJzLmdsL2NvcmUvZGlzdC9lc20vaXRlcmF0b3JzL21ha2UtaXRlcmF0b3IvbWFrZS1ibG9iLWl0ZXJhdG9yLmpzPzc0ODkiLCJ3ZWJwYWNrOi8vdnVlMy13ZWJwYWNrNS8uL25vZGVfbW9kdWxlcy9AbG9hZGVycy5nbC9sb2FkZXItdXRpbHMvZGlzdC9lc20vbGliL2JpbmFyeS11dGlscy9tZW1vcnktY29udmVyc2lvbi11dGlscy5qcz9kM2IzIiwid2VicGFjazovL3Z1ZTMtd2VicGFjazUvLi9ub2RlX21vZHVsZXMvQGxvYWRlcnMuZ2wvY29yZS9kaXN0L2VzbS9pdGVyYXRvcnMvbWFrZS1pdGVyYXRvci9tYWtlLXN0cmVhbS1pdGVyYXRvci5qcz82ZGNhIiwid2VicGFjazovL3Z1ZTMtd2VicGFjazUvLi9ub2RlX21vZHVsZXMvQGxvYWRlcnMuZ2wvY29yZS9kaXN0L2VzbS9pdGVyYXRvcnMvbWFrZS1pdGVyYXRvci9tYWtlLWl0ZXJhdG9yLmpzPzEyZTMiLCJ3ZWJwYWNrOi8vdnVlMy13ZWJwYWNrNS8uL25vZGVfbW9kdWxlcy9AbG9hZGVycy5nbC9jb3JlL2Rpc3QvZXNtL2xpYi9sb2FkZXItdXRpbHMvZ2V0LWRhdGEuanM/ZmZlYyIsIndlYnBhY2s6Ly92dWUzLXdlYnBhY2s1Ly4vbm9kZV9tb2R1bGVzL0Bsb2FkZXJzLmdsL2NvcmUvZGlzdC9lc20vbGliL2xvYWRlci11dGlscy9sb2FkZXItY29udGV4dC5qcz84OGU2Iiwid2VicGFjazovL3Z1ZTMtd2VicGFjazUvLi9ub2RlX21vZHVsZXMvQGxvYWRlcnMuZ2wvbG9hZGVyLXV0aWxzL2Rpc3QvZXNtL2xpYi9wYXRoLXV0aWxzL3BhdGguanM/NzIwZSIsIndlYnBhY2s6Ly92dWUzLXdlYnBhY2s1Ly4vbm9kZV9tb2R1bGVzL0Bsb2FkZXJzLmdsL2NvcmUvZGlzdC9lc20vbGliL3V0aWxzL2xvZy5qcz9jYjc0Iiwid2VicGFjazovL3Z1ZTMtd2VicGFjazUvLi9ub2RlX21vZHVsZXMvQGxvYWRlcnMuZ2wvY29yZS9kaXN0L2VzbS9saWIvYXBpL3NlbGVjdC1sb2FkZXIuanM/ODIxNCIsIndlYnBhY2s6Ly92dWUzLXdlYnBhY2s1Ly4vbm9kZV9tb2R1bGVzL0Bsb2FkZXJzLmdsL2NvcmUvZGlzdC9lc20vbGliL2FwaS9wYXJzZS5qcz9kMTdhIiwid2VicGFjazovL3Z1ZTMtd2VicGFjazUvLi9ub2RlX21vZHVsZXMvQGxvYWRlcnMuZ2wvY29yZS9kaXN0L2VzbS9saWIvYXBpL2xvYWQuanM/MDY5MiJdLCJzb3VyY2VzQ29udGVudCI6WyJcblxuY29uc3QgREVGQVVMVF9WRVJTSU9OID0gJ2JldGEnO1xuZXhwb3J0IGNvbnN0IFZFUlNJT04gPSB0eXBlb2YgXCIzLjMuMVwiICE9PSAndW5kZWZpbmVkJyA/IFwiMy4zLjFcIiA6IERFRkFVTFRfVkVSU0lPTjtcbmlmICh0eXBlb2YgXCIzLjMuMVwiID09PSAndW5kZWZpbmVkJykge1xuICBjb25zb2xlLmVycm9yKCdsb2FkZXJzLmdsOiBUaGUgX19WRVJTSU9OX18gdmFyaWFibGUgaXMgbm90IGluamVjdGVkIHVzaW5nIGJhYmVsIHBsdWdpbi4gTGF0ZXN0IHVuc3RhYmxlIHdvcmtlcnMgd291bGQgYmUgZmV0Y2hlZCBmcm9tIHRoZSBDRE4uJyk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD12ZXJzaW9uLmpzLm1hcCIsImltcG9ydCB7IGFzc2VydCB9IGZyb20gJy4uL2Vudi11dGlscy9hc3NlcnQnO1xuaW1wb3J0IHsgVkVSU0lPTiB9IGZyb20gJy4uL2Vudi11dGlscy92ZXJzaW9uJztcblxuZXhwb3J0IGZ1bmN0aW9uIHZhbGlkYXRlV29ya2VyVmVyc2lvbih3b3JrZXIpIHtcbiAgbGV0IGNvcmVWZXJzaW9uID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiBWRVJTSU9OO1xuICBhc3NlcnQod29ya2VyLCAnbm8gd29ya2VyIHByb3ZpZGVkJyk7XG4gIGNvbnN0IHdvcmtlclZlcnNpb24gPSB3b3JrZXIudmVyc2lvbjtcbiAgaWYgKCFjb3JlVmVyc2lvbiB8fCAhd29ya2VyVmVyc2lvbikge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufVxuXG5mdW5jdGlvbiBwYXJzZVZlcnNpb24odmVyc2lvbikge1xuICBjb25zdCBwYXJ0cyA9IHZlcnNpb24uc3BsaXQoJy4nKS5tYXAoTnVtYmVyKTtcbiAgcmV0dXJuIHtcbiAgICBtYWpvcjogcGFydHNbMF0sXG4gICAgbWlub3I6IHBhcnRzWzFdXG4gIH07XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD12YWxpZGF0ZS13b3JrZXItdmVyc2lvbi5qcy5tYXAiLCJcbmV4cG9ydCBjbGFzcyBXb3JrZXIge1xuICB0ZXJtaW5hdGUoKSB7fVxufVxuZXhwb3J0IHsgV29ya2VyIGFzIE5vZGVXb3JrZXIgfTtcbmV4cG9ydCB7IFdvcmtlciBhcyBOb2RlV29ya2VyVHlwZSB9O1xuZXhwb3J0IGNvbnN0IHBhcmVudFBvcnQgPSBudWxsO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9d29ya2VyX3RocmVhZHMtYnJvd3Nlci5qcy5tYXAiLCJpbXBvcnQgeyBhc3NlcnQgfSBmcm9tICcuLi9lbnYtdXRpbHMvYXNzZXJ0JztcbmNvbnN0IHdvcmtlclVSTENhY2hlID0gbmV3IE1hcCgpO1xuXG5leHBvcnQgZnVuY3Rpb24gZ2V0TG9hZGFibGVXb3JrZXJVUkwocHJvcHMpIHtcbiAgYXNzZXJ0KHByb3BzLnNvdXJjZSAmJiAhcHJvcHMudXJsIHx8ICFwcm9wcy5zb3VyY2UgJiYgcHJvcHMudXJsKTtcblxuICBsZXQgd29ya2VyVVJMID0gd29ya2VyVVJMQ2FjaGUuZ2V0KHByb3BzLnNvdXJjZSB8fCBwcm9wcy51cmwpO1xuICBpZiAoIXdvcmtlclVSTCkge1xuICAgIGlmIChwcm9wcy51cmwpIHtcbiAgICAgIHdvcmtlclVSTCA9IGdldExvYWRhYmxlV29ya2VyVVJMRnJvbVVSTChwcm9wcy51cmwpO1xuICAgICAgd29ya2VyVVJMQ2FjaGUuc2V0KHByb3BzLnVybCwgd29ya2VyVVJMKTtcbiAgICB9XG4gICAgaWYgKHByb3BzLnNvdXJjZSkge1xuICAgICAgd29ya2VyVVJMID0gZ2V0TG9hZGFibGVXb3JrZXJVUkxGcm9tU291cmNlKHByb3BzLnNvdXJjZSk7XG4gICAgICB3b3JrZXJVUkxDYWNoZS5zZXQocHJvcHMuc291cmNlLCB3b3JrZXJVUkwpO1xuICAgIH1cbiAgfVxuICBhc3NlcnQod29ya2VyVVJMKTtcbiAgcmV0dXJuIHdvcmtlclVSTDtcbn1cblxuZnVuY3Rpb24gZ2V0TG9hZGFibGVXb3JrZXJVUkxGcm9tVVJMKHVybCkge1xuICBpZiAoIXVybC5zdGFydHNXaXRoKCdodHRwJykpIHtcbiAgICByZXR1cm4gdXJsO1xuICB9XG5cbiAgY29uc3Qgd29ya2VyU291cmNlID0gYnVpbGRTY3JpcHRTb3VyY2UodXJsKTtcbiAgcmV0dXJuIGdldExvYWRhYmxlV29ya2VyVVJMRnJvbVNvdXJjZSh3b3JrZXJTb3VyY2UpO1xufVxuXG5mdW5jdGlvbiBnZXRMb2FkYWJsZVdvcmtlclVSTEZyb21Tb3VyY2Uod29ya2VyU291cmNlKSB7XG4gIGNvbnN0IGJsb2IgPSBuZXcgQmxvYihbd29ya2VyU291cmNlXSwge1xuICAgIHR5cGU6ICdhcHBsaWNhdGlvbi9qYXZhc2NyaXB0J1xuICB9KTtcbiAgcmV0dXJuIFVSTC5jcmVhdGVPYmplY3RVUkwoYmxvYik7XG59XG5cbmZ1bmN0aW9uIGJ1aWxkU2NyaXB0U291cmNlKHdvcmtlclVybCkge1xuICByZXR1cm4gXCJ0cnkge1xcbiAgaW1wb3J0U2NyaXB0cygnXCIuY29uY2F0KHdvcmtlclVybCwgXCInKTtcXG59IGNhdGNoIChlcnJvcikge1xcbiAgY29uc29sZS5lcnJvcihlcnJvcik7XFxuICB0aHJvdyBlcnJvcjtcXG59XCIpO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Z2V0LWxvYWRhYmxlLXdvcmtlci11cmwuanMubWFwIiwiXG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRUcmFuc2Zlckxpc3Qob2JqZWN0KSB7XG4gIGxldCByZWN1cnNpdmUgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHRydWU7XG4gIGxldCB0cmFuc2ZlcnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMiA/IGFyZ3VtZW50c1syXSA6IHVuZGVmaW5lZDtcbiAgY29uc3QgdHJhbnNmZXJzU2V0ID0gdHJhbnNmZXJzIHx8IG5ldyBTZXQoKTtcbiAgaWYgKCFvYmplY3QpIHtcbiAgfSBlbHNlIGlmIChpc1RyYW5zZmVyYWJsZShvYmplY3QpKSB7XG4gICAgdHJhbnNmZXJzU2V0LmFkZChvYmplY3QpO1xuICB9IGVsc2UgaWYgKGlzVHJhbnNmZXJhYmxlKG9iamVjdC5idWZmZXIpKSB7XG4gICAgdHJhbnNmZXJzU2V0LmFkZChvYmplY3QuYnVmZmVyKTtcbiAgfSBlbHNlIGlmIChBcnJheUJ1ZmZlci5pc1ZpZXcob2JqZWN0KSkge1xuICB9IGVsc2UgaWYgKHJlY3Vyc2l2ZSAmJiB0eXBlb2Ygb2JqZWN0ID09PSAnb2JqZWN0Jykge1xuICAgIGZvciAoY29uc3Qga2V5IGluIG9iamVjdCkge1xuICAgICAgZ2V0VHJhbnNmZXJMaXN0KG9iamVjdFtrZXldLCByZWN1cnNpdmUsIHRyYW5zZmVyc1NldCk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRyYW5zZmVycyA9PT0gdW5kZWZpbmVkID8gQXJyYXkuZnJvbSh0cmFuc2ZlcnNTZXQpIDogW107XG59XG5cbmZ1bmN0aW9uIGlzVHJhbnNmZXJhYmxlKG9iamVjdCkge1xuICBpZiAoIW9iamVjdCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBpZiAob2JqZWN0IGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBpZiAodHlwZW9mIE1lc3NhZ2VQb3J0ICE9PSAndW5kZWZpbmVkJyAmJiBvYmplY3QgaW5zdGFuY2VvZiBNZXNzYWdlUG9ydCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGlmICh0eXBlb2YgSW1hZ2VCaXRtYXAgIT09ICd1bmRlZmluZWQnICYmIG9iamVjdCBpbnN0YW5jZW9mIEltYWdlQml0bWFwKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgaWYgKHR5cGVvZiBPZmZzY3JlZW5DYW52YXMgIT09ICd1bmRlZmluZWQnICYmIG9iamVjdCBpbnN0YW5jZW9mIE9mZnNjcmVlbkNhbnZhcykge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdldFRyYW5zZmVyTGlzdEZvcldyaXRlcihvYmplY3QpIHtcbiAgaWYgKG9iamVjdCA9PT0gbnVsbCkge1xuICAgIHJldHVybiB7fTtcbiAgfVxuICBjb25zdCBjbG9uZSA9IE9iamVjdC5hc3NpZ24oe30sIG9iamVjdCk7XG4gIE9iamVjdC5rZXlzKGNsb25lKS5mb3JFYWNoKGtleSA9PiB7XG4gICAgaWYgKHR5cGVvZiBvYmplY3Rba2V5XSA9PT0gJ29iamVjdCcgJiYgIUFycmF5QnVmZmVyLmlzVmlldyhvYmplY3Rba2V5XSkgJiYgIShvYmplY3Rba2V5XSBpbnN0YW5jZW9mIEFycmF5KSkge1xuICAgICAgY2xvbmVba2V5XSA9IGdldFRyYW5zZmVyTGlzdEZvcldyaXRlcihvYmplY3Rba2V5XSk7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgY2xvbmVba2V5XSA9PT0gJ2Z1bmN0aW9uJyB8fCBjbG9uZVtrZXldIGluc3RhbmNlb2YgUmVnRXhwKSB7XG4gICAgICBjbG9uZVtrZXldID0ge307XG4gICAgfSBlbHNlIHtcbiAgICAgIGNsb25lW2tleV0gPSBvYmplY3Rba2V5XTtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gY2xvbmU7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1nZXQtdHJhbnNmZXItbGlzdC5qcy5tYXAiLCJpbXBvcnQgX2RlZmluZVByb3BlcnR5IGZyb20gXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9kZWZpbmVQcm9wZXJ0eVwiO1xuXG5pbXBvcnQgeyBOb2RlV29ya2VyIH0gZnJvbSAnLi4vbm9kZS93b3JrZXJfdGhyZWFkcyc7XG5pbXBvcnQgeyBpc0Jyb3dzZXIgfSBmcm9tICcuLi9lbnYtdXRpbHMvZ2xvYmFscyc7XG5pbXBvcnQgeyBhc3NlcnQgfSBmcm9tICcuLi9lbnYtdXRpbHMvYXNzZXJ0JztcbmltcG9ydCB7IGdldExvYWRhYmxlV29ya2VyVVJMIH0gZnJvbSAnLi4vd29ya2VyLXV0aWxzL2dldC1sb2FkYWJsZS13b3JrZXItdXJsJztcbmltcG9ydCB7IGdldFRyYW5zZmVyTGlzdCB9IGZyb20gJy4uL3dvcmtlci11dGlscy9nZXQtdHJhbnNmZXItbGlzdCc7XG5jb25zdCBOT09QID0gKCkgPT4ge307XG5leHBvcnQgZGVmYXVsdCBjbGFzcyBXb3JrZXJUaHJlYWQge1xuICBzdGF0aWMgaXNTdXBwb3J0ZWQoKSB7XG4gICAgcmV0dXJuIHR5cGVvZiBXb3JrZXIgIT09ICd1bmRlZmluZWQnICYmIGlzQnJvd3NlciB8fCB0eXBlb2YgTm9kZVdvcmtlciAhPT0gJ3VuZGVmaW5lZCcgJiYgIWlzQnJvd3NlcjtcbiAgfVxuICBjb25zdHJ1Y3Rvcihwcm9wcykge1xuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIm5hbWVcIiwgdm9pZCAwKTtcbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJzb3VyY2VcIiwgdm9pZCAwKTtcbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJ1cmxcIiwgdm9pZCAwKTtcbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJ0ZXJtaW5hdGVkXCIsIGZhbHNlKTtcbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJ3b3JrZXJcIiwgdm9pZCAwKTtcbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJvbk1lc3NhZ2VcIiwgdm9pZCAwKTtcbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJvbkVycm9yXCIsIHZvaWQgMCk7XG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwiX2xvYWRhYmxlVVJMXCIsICcnKTtcbiAgICBjb25zdCB7XG4gICAgICBuYW1lLFxuICAgICAgc291cmNlLFxuICAgICAgdXJsXG4gICAgfSA9IHByb3BzO1xuICAgIGFzc2VydChzb3VyY2UgfHwgdXJsKTtcbiAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgIHRoaXMuc291cmNlID0gc291cmNlO1xuICAgIHRoaXMudXJsID0gdXJsO1xuICAgIHRoaXMub25NZXNzYWdlID0gTk9PUDtcbiAgICB0aGlzLm9uRXJyb3IgPSBlcnJvciA9PiBjb25zb2xlLmxvZyhlcnJvcik7XG5cbiAgICB0aGlzLndvcmtlciA9IGlzQnJvd3NlciA/IHRoaXMuX2NyZWF0ZUJyb3dzZXJXb3JrZXIoKSA6IHRoaXMuX2NyZWF0ZU5vZGVXb3JrZXIoKTtcbiAgfVxuXG4gIGRlc3Ryb3koKSB7XG4gICAgdGhpcy5vbk1lc3NhZ2UgPSBOT09QO1xuICAgIHRoaXMub25FcnJvciA9IE5PT1A7XG4gICAgdGhpcy53b3JrZXIudGVybWluYXRlKCk7XG4gICAgdGhpcy50ZXJtaW5hdGVkID0gdHJ1ZTtcbiAgfVxuICBnZXQgaXNSdW5uaW5nKCkge1xuICAgIHJldHVybiBCb29sZWFuKHRoaXMub25NZXNzYWdlKTtcbiAgfVxuXG4gIHBvc3RNZXNzYWdlKGRhdGEsIHRyYW5zZmVyTGlzdCkge1xuICAgIHRyYW5zZmVyTGlzdCA9IHRyYW5zZmVyTGlzdCB8fCBnZXRUcmFuc2Zlckxpc3QoZGF0YSk7XG4gICAgdGhpcy53b3JrZXIucG9zdE1lc3NhZ2UoZGF0YSwgdHJhbnNmZXJMaXN0KTtcbiAgfVxuXG4gIF9nZXRFcnJvckZyb21FcnJvckV2ZW50KGV2ZW50KSB7XG4gICAgbGV0IG1lc3NhZ2UgPSAnRmFpbGVkIHRvIGxvYWQgJztcbiAgICBtZXNzYWdlICs9IFwid29ya2VyIFwiLmNvbmNhdCh0aGlzLm5hbWUsIFwiIGZyb20gXCIpLmNvbmNhdCh0aGlzLnVybCwgXCIuIFwiKTtcbiAgICBpZiAoZXZlbnQubWVzc2FnZSkge1xuICAgICAgbWVzc2FnZSArPSBcIlwiLmNvbmNhdChldmVudC5tZXNzYWdlLCBcIiBpbiBcIik7XG4gICAgfVxuICAgIGlmIChldmVudC5saW5lbm8pIHtcbiAgICAgIG1lc3NhZ2UgKz0gXCI6XCIuY29uY2F0KGV2ZW50LmxpbmVubywgXCI6XCIpLmNvbmNhdChldmVudC5jb2xubyk7XG4gICAgfVxuICAgIHJldHVybiBuZXcgRXJyb3IobWVzc2FnZSk7XG4gIH1cblxuICBfY3JlYXRlQnJvd3NlcldvcmtlcigpIHtcbiAgICB0aGlzLl9sb2FkYWJsZVVSTCA9IGdldExvYWRhYmxlV29ya2VyVVJMKHtcbiAgICAgIHNvdXJjZTogdGhpcy5zb3VyY2UsXG4gICAgICB1cmw6IHRoaXMudXJsXG4gICAgfSk7XG4gICAgY29uc3Qgd29ya2VyID0gbmV3IFdvcmtlcih0aGlzLl9sb2FkYWJsZVVSTCwge1xuICAgICAgbmFtZTogdGhpcy5uYW1lXG4gICAgfSk7XG4gICAgd29ya2VyLm9ubWVzc2FnZSA9IGV2ZW50ID0+IHtcbiAgICAgIGlmICghZXZlbnQuZGF0YSkge1xuICAgICAgICB0aGlzLm9uRXJyb3IobmV3IEVycm9yKCdObyBkYXRhIHJlY2VpdmVkJykpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5vbk1lc3NhZ2UoZXZlbnQuZGF0YSk7XG4gICAgICB9XG4gICAgfTtcbiAgICB3b3JrZXIub25lcnJvciA9IGVycm9yID0+IHtcbiAgICAgIHRoaXMub25FcnJvcih0aGlzLl9nZXRFcnJvckZyb21FcnJvckV2ZW50KGVycm9yKSk7XG4gICAgICB0aGlzLnRlcm1pbmF0ZWQgPSB0cnVlO1xuICAgIH07XG4gICAgd29ya2VyLm9ubWVzc2FnZWVycm9yID0gZXZlbnQgPT4gY29uc29sZS5lcnJvcihldmVudCk7XG5cbiAgICByZXR1cm4gd29ya2VyO1xuICB9XG5cbiAgX2NyZWF0ZU5vZGVXb3JrZXIoKSB7XG4gICAgbGV0IHdvcmtlcjtcbiAgICBpZiAodGhpcy51cmwpIHtcbiAgICAgIGNvbnN0IGFic29sdXRlID0gdGhpcy51cmwuaW5jbHVkZXMoJzovJykgfHwgdGhpcy51cmwuc3RhcnRzV2l0aCgnLycpO1xuICAgICAgY29uc3QgdXJsID0gYWJzb2x1dGUgPyB0aGlzLnVybCA6IFwiLi9cIi5jb25jYXQodGhpcy51cmwpO1xuICAgICAgd29ya2VyID0gbmV3IE5vZGVXb3JrZXIodXJsLCB7XG4gICAgICAgIGV2YWw6IGZhbHNlXG4gICAgICB9KTtcbiAgICB9IGVsc2UgaWYgKHRoaXMuc291cmNlKSB7XG4gICAgICB3b3JrZXIgPSBuZXcgTm9kZVdvcmtlcih0aGlzLnNvdXJjZSwge1xuICAgICAgICBldmFsOiB0cnVlXG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdubyB3b3JrZXInKTtcbiAgICB9XG4gICAgd29ya2VyLm9uKCdtZXNzYWdlJywgZGF0YSA9PiB7XG4gICAgICB0aGlzLm9uTWVzc2FnZShkYXRhKTtcbiAgICB9KTtcbiAgICB3b3JrZXIub24oJ2Vycm9yJywgZXJyb3IgPT4ge1xuICAgICAgdGhpcy5vbkVycm9yKGVycm9yKTtcbiAgICB9KTtcbiAgICB3b3JrZXIub24oJ2V4aXQnLCBjb2RlID0+IHtcbiAgICB9KTtcbiAgICByZXR1cm4gd29ya2VyO1xuICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD13b3JrZXItdGhyZWFkLmpzLm1hcCIsImltcG9ydCBfZGVmaW5lUHJvcGVydHkgZnJvbSBcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL2RlZmluZVByb3BlcnR5XCI7XG5pbXBvcnQgeyBhc3NlcnQgfSBmcm9tICcuLi9lbnYtdXRpbHMvYXNzZXJ0JztcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgV29ya2VySm9iIHtcblxuICBjb25zdHJ1Y3Rvcihqb2JOYW1lLCB3b3JrZXJUaHJlYWQpIHtcbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJuYW1lXCIsIHZvaWQgMCk7XG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwid29ya2VyVGhyZWFkXCIsIHZvaWQgMCk7XG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwiaXNSdW5uaW5nXCIsIHRydWUpO1xuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInJlc3VsdFwiLCB2b2lkIDApO1xuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIl9yZXNvbHZlXCIsICgpID0+IHt9KTtcbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJfcmVqZWN0XCIsICgpID0+IHt9KTtcbiAgICB0aGlzLm5hbWUgPSBqb2JOYW1lO1xuICAgIHRoaXMud29ya2VyVGhyZWFkID0gd29ya2VyVGhyZWFkO1xuICAgIHRoaXMucmVzdWx0ID0gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgdGhpcy5fcmVzb2x2ZSA9IHJlc29sdmU7XG4gICAgICB0aGlzLl9yZWplY3QgPSByZWplY3Q7XG4gICAgfSk7XG4gIH1cblxuICBwb3N0TWVzc2FnZSh0eXBlLCBwYXlsb2FkKSB7XG4gICAgdGhpcy53b3JrZXJUaHJlYWQucG9zdE1lc3NhZ2Uoe1xuICAgICAgc291cmNlOiAnbG9hZGVycy5nbCcsXG4gICAgICB0eXBlLFxuICAgICAgcGF5bG9hZFxuICAgIH0pO1xuICB9XG5cbiAgZG9uZSh2YWx1ZSkge1xuICAgIGFzc2VydCh0aGlzLmlzUnVubmluZyk7XG4gICAgdGhpcy5pc1J1bm5pbmcgPSBmYWxzZTtcbiAgICB0aGlzLl9yZXNvbHZlKHZhbHVlKTtcbiAgfVxuXG4gIGVycm9yKGVycm9yKSB7XG4gICAgYXNzZXJ0KHRoaXMuaXNSdW5uaW5nKTtcbiAgICB0aGlzLmlzUnVubmluZyA9IGZhbHNlO1xuICAgIHRoaXMuX3JlamVjdChlcnJvcik7XG4gIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXdvcmtlci1qb2IuanMubWFwIiwiaW1wb3J0IF9kZWZpbmVQcm9wZXJ0eSBmcm9tIFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vZGVmaW5lUHJvcGVydHlcIjtcbmltcG9ydCB7IGlzTW9iaWxlIH0gZnJvbSAnLi4vZW52LXV0aWxzL2dsb2JhbHMnO1xuaW1wb3J0IFdvcmtlclRocmVhZCBmcm9tICcuL3dvcmtlci10aHJlYWQnO1xuaW1wb3J0IFdvcmtlckpvYiBmcm9tICcuL3dvcmtlci1qb2InO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBXb3JrZXJQb29sIHtcblxuICBzdGF0aWMgaXNTdXBwb3J0ZWQoKSB7XG4gICAgcmV0dXJuIFdvcmtlclRocmVhZC5pc1N1cHBvcnRlZCgpO1xuICB9XG5cbiAgY29uc3RydWN0b3IocHJvcHMpIHtcbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJuYW1lXCIsICd1bm5hbWVkJyk7XG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwic291cmNlXCIsIHZvaWQgMCk7XG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwidXJsXCIsIHZvaWQgMCk7XG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwibWF4Q29uY3VycmVuY3lcIiwgMSk7XG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwibWF4TW9iaWxlQ29uY3VycmVuY3lcIiwgMSk7XG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwib25EZWJ1Z1wiLCAoKSA9PiB7fSk7XG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwicmV1c2VXb3JrZXJzXCIsIHRydWUpO1xuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInByb3BzXCIsIHt9KTtcbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJqb2JRdWV1ZVwiLCBbXSk7XG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwiaWRsZVF1ZXVlXCIsIFtdKTtcbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJjb3VudFwiLCAwKTtcbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJpc0Rlc3Ryb3llZFwiLCBmYWxzZSk7XG4gICAgdGhpcy5zb3VyY2UgPSBwcm9wcy5zb3VyY2U7XG4gICAgdGhpcy51cmwgPSBwcm9wcy51cmw7XG4gICAgdGhpcy5zZXRQcm9wcyhwcm9wcyk7XG4gIH1cblxuICBkZXN0cm95KCkge1xuICAgIHRoaXMuaWRsZVF1ZXVlLmZvckVhY2god29ya2VyID0+IHdvcmtlci5kZXN0cm95KCkpO1xuICAgIHRoaXMuaXNEZXN0cm95ZWQgPSB0cnVlO1xuICB9XG4gIHNldFByb3BzKHByb3BzKSB7XG4gICAgdGhpcy5wcm9wcyA9IHtcbiAgICAgIC4uLnRoaXMucHJvcHMsXG4gICAgICAuLi5wcm9wc1xuICAgIH07XG4gICAgaWYgKHByb3BzLm5hbWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhpcy5uYW1lID0gcHJvcHMubmFtZTtcbiAgICB9XG4gICAgaWYgKHByb3BzLm1heENvbmN1cnJlbmN5ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHRoaXMubWF4Q29uY3VycmVuY3kgPSBwcm9wcy5tYXhDb25jdXJyZW5jeTtcbiAgICB9XG4gICAgaWYgKHByb3BzLm1heE1vYmlsZUNvbmN1cnJlbmN5ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHRoaXMubWF4TW9iaWxlQ29uY3VycmVuY3kgPSBwcm9wcy5tYXhNb2JpbGVDb25jdXJyZW5jeTtcbiAgICB9XG4gICAgaWYgKHByb3BzLnJldXNlV29ya2VycyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aGlzLnJldXNlV29ya2VycyA9IHByb3BzLnJldXNlV29ya2VycztcbiAgICB9XG4gICAgaWYgKHByb3BzLm9uRGVidWcgIT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhpcy5vbkRlYnVnID0gcHJvcHMub25EZWJ1ZztcbiAgICB9XG4gIH1cbiAgYXN5bmMgc3RhcnRKb2IobmFtZSkge1xuICAgIGxldCBvbk1lc3NhZ2UgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IChqb2IsIHR5cGUsIGRhdGEpID0+IGpvYi5kb25lKGRhdGEpO1xuICAgIGxldCBvbkVycm9yID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiAoam9iLCBlcnJvcikgPT4gam9iLmVycm9yKGVycm9yKTtcbiAgICBjb25zdCBzdGFydFByb21pc2UgPSBuZXcgUHJvbWlzZShvblN0YXJ0ID0+IHtcbiAgICAgIHRoaXMuam9iUXVldWUucHVzaCh7XG4gICAgICAgIG5hbWUsXG4gICAgICAgIG9uTWVzc2FnZSxcbiAgICAgICAgb25FcnJvcixcbiAgICAgICAgb25TdGFydFxuICAgICAgfSk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9KTtcbiAgICB0aGlzLl9zdGFydFF1ZXVlZEpvYigpO1xuICAgIHJldHVybiBhd2FpdCBzdGFydFByb21pc2U7XG4gIH1cblxuICBhc3luYyBfc3RhcnRRdWV1ZWRKb2IoKSB7XG4gICAgaWYgKCF0aGlzLmpvYlF1ZXVlLmxlbmd0aCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCB3b3JrZXJUaHJlYWQgPSB0aGlzLl9nZXRBdmFpbGFibGVXb3JrZXIoKTtcbiAgICBpZiAoIXdvcmtlclRocmVhZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IHF1ZXVlZEpvYiA9IHRoaXMuam9iUXVldWUuc2hpZnQoKTtcbiAgICBpZiAocXVldWVkSm9iKSB7XG4gICAgICB0aGlzLm9uRGVidWcoe1xuICAgICAgICBtZXNzYWdlOiAnU3RhcnRpbmcgam9iJyxcbiAgICAgICAgbmFtZTogcXVldWVkSm9iLm5hbWUsXG4gICAgICAgIHdvcmtlclRocmVhZCxcbiAgICAgICAgYmFja2xvZzogdGhpcy5qb2JRdWV1ZS5sZW5ndGhcbiAgICAgIH0pO1xuXG4gICAgICBjb25zdCBqb2IgPSBuZXcgV29ya2VySm9iKHF1ZXVlZEpvYi5uYW1lLCB3b3JrZXJUaHJlYWQpO1xuXG4gICAgICB3b3JrZXJUaHJlYWQub25NZXNzYWdlID0gZGF0YSA9PiBxdWV1ZWRKb2Iub25NZXNzYWdlKGpvYiwgZGF0YS50eXBlLCBkYXRhLnBheWxvYWQpO1xuICAgICAgd29ya2VyVGhyZWFkLm9uRXJyb3IgPSBlcnJvciA9PiBxdWV1ZWRKb2Iub25FcnJvcihqb2IsIGVycm9yKTtcblxuICAgICAgcXVldWVkSm9iLm9uU3RhcnQoam9iKTtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgYXdhaXQgam9iLnJlc3VsdDtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIHRoaXMucmV0dXJuV29ya2VyVG9RdWV1ZSh3b3JrZXJUaHJlYWQpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybldvcmtlclRvUXVldWUod29ya2VyKSB7XG4gICAgY29uc3Qgc2hvdWxkRGVzdHJveVdvcmtlciA9IHRoaXMuaXNEZXN0cm95ZWQgfHwgIXRoaXMucmV1c2VXb3JrZXJzIHx8IHRoaXMuY291bnQgPiB0aGlzLl9nZXRNYXhDb25jdXJyZW5jeSgpO1xuICAgIGlmIChzaG91bGREZXN0cm95V29ya2VyKSB7XG4gICAgICB3b3JrZXIuZGVzdHJveSgpO1xuICAgICAgdGhpcy5jb3VudC0tO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmlkbGVRdWV1ZS5wdXNoKHdvcmtlcik7XG4gICAgfVxuICAgIGlmICghdGhpcy5pc0Rlc3Ryb3llZCkge1xuICAgICAgdGhpcy5fc3RhcnRRdWV1ZWRKb2IoKTtcbiAgICB9XG4gIH1cblxuICBfZ2V0QXZhaWxhYmxlV29ya2VyKCkge1xuICAgIGlmICh0aGlzLmlkbGVRdWV1ZS5sZW5ndGggPiAwKSB7XG4gICAgICByZXR1cm4gdGhpcy5pZGxlUXVldWUuc2hpZnQoKSB8fCBudWxsO1xuICAgIH1cblxuICAgIGlmICh0aGlzLmNvdW50IDwgdGhpcy5fZ2V0TWF4Q29uY3VycmVuY3koKSkge1xuICAgICAgdGhpcy5jb3VudCsrO1xuICAgICAgY29uc3QgbmFtZSA9IFwiXCIuY29uY2F0KHRoaXMubmFtZS50b0xvd2VyQ2FzZSgpLCBcIiAoI1wiKS5jb25jYXQodGhpcy5jb3VudCwgXCIgb2YgXCIpLmNvbmNhdCh0aGlzLm1heENvbmN1cnJlbmN5LCBcIilcIik7XG4gICAgICByZXR1cm4gbmV3IFdvcmtlclRocmVhZCh7XG4gICAgICAgIG5hbWUsXG4gICAgICAgIHNvdXJjZTogdGhpcy5zb3VyY2UsXG4gICAgICAgIHVybDogdGhpcy51cmxcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHJldHVybiBudWxsO1xuICB9XG4gIF9nZXRNYXhDb25jdXJyZW5jeSgpIHtcbiAgICByZXR1cm4gaXNNb2JpbGUgPyB0aGlzLm1heE1vYmlsZUNvbmN1cnJlbmN5IDogdGhpcy5tYXhDb25jdXJyZW5jeTtcbiAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9d29ya2VyLXBvb2wuanMubWFwIiwiaW1wb3J0IF9kZWZpbmVQcm9wZXJ0eSBmcm9tIFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vZGVmaW5lUHJvcGVydHlcIjtcbmltcG9ydCBXb3JrZXJQb29sIGZyb20gJy4vd29ya2VyLXBvb2wnO1xuaW1wb3J0IFdvcmtlclRocmVhZCBmcm9tICcuL3dvcmtlci10aHJlYWQnO1xuXG5jb25zdCBERUZBVUxUX1BST1BTID0ge1xuICBtYXhDb25jdXJyZW5jeTogMyxcbiAgbWF4TW9iaWxlQ29uY3VycmVuY3k6IDEsXG4gIHJldXNlV29ya2VyczogdHJ1ZSxcbiAgb25EZWJ1ZzogKCkgPT4ge31cbn07XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFdvcmtlckZhcm0ge1xuXG4gIHN0YXRpYyBpc1N1cHBvcnRlZCgpIHtcbiAgICByZXR1cm4gV29ya2VyVGhyZWFkLmlzU3VwcG9ydGVkKCk7XG4gIH1cblxuICBzdGF0aWMgZ2V0V29ya2VyRmFybSgpIHtcbiAgICBsZXQgcHJvcHMgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHt9O1xuICAgIFdvcmtlckZhcm0uX3dvcmtlckZhcm0gPSBXb3JrZXJGYXJtLl93b3JrZXJGYXJtIHx8IG5ldyBXb3JrZXJGYXJtKHt9KTtcbiAgICBXb3JrZXJGYXJtLl93b3JrZXJGYXJtLnNldFByb3BzKHByb3BzKTtcbiAgICByZXR1cm4gV29ya2VyRmFybS5fd29ya2VyRmFybTtcbiAgfVxuXG4gIGNvbnN0cnVjdG9yKHByb3BzKSB7XG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwicHJvcHNcIiwgdm9pZCAwKTtcbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJ3b3JrZXJQb29sc1wiLCBuZXcgTWFwKCkpO1xuICAgIHRoaXMucHJvcHMgPSB7XG4gICAgICAuLi5ERUZBVUxUX1BST1BTXG4gICAgfTtcbiAgICB0aGlzLnNldFByb3BzKHByb3BzKTtcbiAgICB0aGlzLndvcmtlclBvb2xzID0gbmV3IE1hcCgpO1xuICB9XG5cbiAgZGVzdHJveSgpIHtcbiAgICBmb3IgKGNvbnN0IHdvcmtlclBvb2wgb2YgdGhpcy53b3JrZXJQb29scy52YWx1ZXMoKSkge1xuICAgICAgd29ya2VyUG9vbC5kZXN0cm95KCk7XG4gICAgfVxuICAgIHRoaXMud29ya2VyUG9vbHMgPSBuZXcgTWFwKCk7XG4gIH1cblxuICBzZXRQcm9wcyhwcm9wcykge1xuICAgIHRoaXMucHJvcHMgPSB7XG4gICAgICAuLi50aGlzLnByb3BzLFxuICAgICAgLi4ucHJvcHNcbiAgICB9O1xuICAgIGZvciAoY29uc3Qgd29ya2VyUG9vbCBvZiB0aGlzLndvcmtlclBvb2xzLnZhbHVlcygpKSB7XG4gICAgICB3b3JrZXJQb29sLnNldFByb3BzKHRoaXMuX2dldFdvcmtlclBvb2xQcm9wcygpKTtcbiAgICB9XG4gIH1cblxuICBnZXRXb3JrZXJQb29sKG9wdGlvbnMpIHtcbiAgICBjb25zdCB7XG4gICAgICBuYW1lLFxuICAgICAgc291cmNlLFxuICAgICAgdXJsXG4gICAgfSA9IG9wdGlvbnM7XG4gICAgbGV0IHdvcmtlclBvb2wgPSB0aGlzLndvcmtlclBvb2xzLmdldChuYW1lKTtcbiAgICBpZiAoIXdvcmtlclBvb2wpIHtcbiAgICAgIHdvcmtlclBvb2wgPSBuZXcgV29ya2VyUG9vbCh7XG4gICAgICAgIG5hbWUsXG4gICAgICAgIHNvdXJjZSxcbiAgICAgICAgdXJsXG4gICAgICB9KTtcbiAgICAgIHdvcmtlclBvb2wuc2V0UHJvcHModGhpcy5fZ2V0V29ya2VyUG9vbFByb3BzKCkpO1xuICAgICAgdGhpcy53b3JrZXJQb29scy5zZXQobmFtZSwgd29ya2VyUG9vbCk7XG4gICAgfVxuICAgIHJldHVybiB3b3JrZXJQb29sO1xuICB9XG4gIF9nZXRXb3JrZXJQb29sUHJvcHMoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIG1heENvbmN1cnJlbmN5OiB0aGlzLnByb3BzLm1heENvbmN1cnJlbmN5LFxuICAgICAgbWF4TW9iaWxlQ29uY3VycmVuY3k6IHRoaXMucHJvcHMubWF4TW9iaWxlQ29uY3VycmVuY3ksXG4gICAgICByZXVzZVdvcmtlcnM6IHRoaXMucHJvcHMucmV1c2VXb3JrZXJzLFxuICAgICAgb25EZWJ1ZzogdGhpcy5wcm9wcy5vbkRlYnVnXG4gICAgfTtcbiAgfVxufVxuX2RlZmluZVByb3BlcnR5KFdvcmtlckZhcm0sIFwiX3dvcmtlckZhcm1cIiwgdm9pZCAwKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXdvcmtlci1mYXJtLmpzLm1hcCIsIlxuXG5pbXBvcnQgeyBhc3NlcnQgfSBmcm9tICcuLi9lbnYtdXRpbHMvYXNzZXJ0JztcbmltcG9ydCB7IFZFUlNJT04gYXMgX19WRVJTSU9OX18gfSBmcm9tICcuLi9lbnYtdXRpbHMvdmVyc2lvbic7XG5jb25zdCBOUE1fVEFHID0gJ2xhdGVzdCc7XG5jb25zdCBWRVJTSU9OID0gdHlwZW9mIFwiMy4zLjFcIiAhPT0gJ3VuZGVmaW5lZCcgPyBcIjMuMy4xXCIgOiBOUE1fVEFHO1xuXG5leHBvcnQgZnVuY3Rpb24gZ2V0V29ya2VyTmFtZSh3b3JrZXIpIHtcbiAgY29uc3Qgd2FybmluZyA9IHdvcmtlci52ZXJzaW9uICE9PSBWRVJTSU9OID8gXCIgKHdvcmtlci11dGlsc0BcIi5jb25jYXQoVkVSU0lPTiwgXCIpXCIpIDogJyc7XG4gIHJldHVybiBcIlwiLmNvbmNhdCh3b3JrZXIubmFtZSwgXCJAXCIpLmNvbmNhdCh3b3JrZXIudmVyc2lvbikuY29uY2F0KHdhcm5pbmcpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0V29ya2VyVVJMKHdvcmtlcikge1xuICBsZXQgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG4gIGNvbnN0IHdvcmtlck9wdGlvbnMgPSBvcHRpb25zW3dvcmtlci5pZF0gfHwge307XG4gIGNvbnN0IHdvcmtlckZpbGUgPSBcIlwiLmNvbmNhdCh3b3JrZXIuaWQsIFwiLXdvcmtlci5qc1wiKTtcbiAgbGV0IHVybCA9IHdvcmtlck9wdGlvbnMud29ya2VyVXJsO1xuXG4gIGlmICghdXJsICYmIHdvcmtlci5pZCA9PT0gJ2NvbXByZXNzaW9uJykge1xuICAgIHVybCA9IG9wdGlvbnMud29ya2VyVXJsO1xuICB9XG5cbiAgaWYgKG9wdGlvbnMuX3dvcmtlclR5cGUgPT09ICd0ZXN0Jykge1xuICAgIHVybCA9IFwibW9kdWxlcy9cIi5jb25jYXQod29ya2VyLm1vZHVsZSwgXCIvZGlzdC9cIikuY29uY2F0KHdvcmtlckZpbGUpO1xuICB9XG5cbiAgaWYgKCF1cmwpIHtcbiAgICBsZXQgdmVyc2lvbiA9IHdvcmtlci52ZXJzaW9uO1xuICAgIGlmICh2ZXJzaW9uID09PSAnbGF0ZXN0Jykge1xuICAgICAgdmVyc2lvbiA9IE5QTV9UQUc7XG4gICAgfVxuICAgIGNvbnN0IHZlcnNpb25UYWcgPSB2ZXJzaW9uID8gXCJAXCIuY29uY2F0KHZlcnNpb24pIDogJyc7XG4gICAgdXJsID0gXCJodHRwczovL3VucGtnLmNvbS9AbG9hZGVycy5nbC9cIi5jb25jYXQod29ya2VyLm1vZHVsZSkuY29uY2F0KHZlcnNpb25UYWcsIFwiL2Rpc3QvXCIpLmNvbmNhdCh3b3JrZXJGaWxlKTtcbiAgfVxuICBhc3NlcnQodXJsKTtcblxuICByZXR1cm4gdXJsO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Z2V0LXdvcmtlci11cmwuanMubWFwIiwiaW1wb3J0IHsgaXNCcm93c2VyIH0gZnJvbSAnQGxvYWRlcnMuZ2wvd29ya2VyLXV0aWxzJztcbmltcG9ydCB7IFdvcmtlckZhcm0sIGdldFdvcmtlclVSTCB9IGZyb20gJ0Bsb2FkZXJzLmdsL3dvcmtlci11dGlscyc7XG5cbmV4cG9ydCBmdW5jdGlvbiBjYW5QYXJzZVdpdGhXb3JrZXIobG9hZGVyLCBvcHRpb25zKSB7XG4gIGlmICghV29ya2VyRmFybS5pc1N1cHBvcnRlZCgpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgaWYgKCFpc0Jyb3dzZXIgJiYgIShvcHRpb25zICE9PSBudWxsICYmIG9wdGlvbnMgIT09IHZvaWQgMCAmJiBvcHRpb25zLl9ub2RlV29ya2VycykpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIGxvYWRlci53b3JrZXIgJiYgKG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy53b3JrZXIpO1xufVxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gcGFyc2VXaXRoV29ya2VyKGxvYWRlciwgZGF0YSwgb3B0aW9ucywgY29udGV4dCwgcGFyc2VPbk1haW5UaHJlYWQpIHtcbiAgY29uc3QgbmFtZSA9IGxvYWRlci5pZDtcbiAgY29uc3QgdXJsID0gZ2V0V29ya2VyVVJMKGxvYWRlciwgb3B0aW9ucyk7XG4gIGNvbnN0IHdvcmtlckZhcm0gPSBXb3JrZXJGYXJtLmdldFdvcmtlckZhcm0ob3B0aW9ucyk7XG4gIGNvbnN0IHdvcmtlclBvb2wgPSB3b3JrZXJGYXJtLmdldFdvcmtlclBvb2woe1xuICAgIG5hbWUsXG4gICAgdXJsXG4gIH0pO1xuXG4gIG9wdGlvbnMgPSBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KG9wdGlvbnMpKTtcbiAgY29udGV4dCA9IEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkoY29udGV4dCB8fCB7fSkpO1xuICBjb25zdCBqb2IgPSBhd2FpdCB3b3JrZXJQb29sLnN0YXJ0Sm9iKCdwcm9jZXNzLW9uLXdvcmtlcicsXG4gIG9uTWVzc2FnZS5iaW5kKG51bGwsIHBhcnNlT25NYWluVGhyZWFkKSk7XG5cbiAgam9iLnBvc3RNZXNzYWdlKCdwcm9jZXNzJywge1xuICAgIGlucHV0OiBkYXRhLFxuICAgIG9wdGlvbnMsXG4gICAgY29udGV4dFxuICB9KTtcbiAgY29uc3QgcmVzdWx0ID0gYXdhaXQgam9iLnJlc3VsdDtcbiAgcmV0dXJuIGF3YWl0IHJlc3VsdC5yZXN1bHQ7XG59XG5cbmFzeW5jIGZ1bmN0aW9uIG9uTWVzc2FnZShwYXJzZU9uTWFpblRocmVhZCwgam9iLCB0eXBlLCBwYXlsb2FkKSB7XG4gIHN3aXRjaCAodHlwZSkge1xuICAgIGNhc2UgJ2RvbmUnOlxuICAgICAgam9iLmRvbmUocGF5bG9hZCk7XG4gICAgICBicmVhaztcbiAgICBjYXNlICdlcnJvcic6XG4gICAgICBqb2IuZXJyb3IobmV3IEVycm9yKHBheWxvYWQuZXJyb3IpKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ3Byb2Nlc3MnOlxuICAgICAgY29uc3Qge1xuICAgICAgICBpZCxcbiAgICAgICAgaW5wdXQsXG4gICAgICAgIG9wdGlvbnNcbiAgICAgIH0gPSBwYXlsb2FkO1xuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgcGFyc2VPbk1haW5UaHJlYWQoaW5wdXQsIG9wdGlvbnMpO1xuICAgICAgICBqb2IucG9zdE1lc3NhZ2UoJ2RvbmUnLCB7XG4gICAgICAgICAgaWQsXG4gICAgICAgICAgcmVzdWx0XG4gICAgICAgIH0pO1xuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGVycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBlcnJvci5tZXNzYWdlIDogJ3Vua25vd24gZXJyb3InO1xuICAgICAgICBqb2IucG9zdE1lc3NhZ2UoJ2Vycm9yJywge1xuICAgICAgICAgIGlkLFxuICAgICAgICAgIGVycm9yOiBtZXNzYWdlXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgYnJlYWs7XG4gICAgZGVmYXVsdDpcbiAgICAgIGNvbnNvbGUud2FybihcInBhcnNlLXdpdGgtd29ya2VyIHVua25vd24gbWVzc2FnZSBcIi5jb25jYXQodHlwZSkpO1xuICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1wYXJzZS13aXRoLXdvcmtlci5qcy5tYXAiLCJpbXBvcnQgeyBjb25jYXRlbmF0ZUFycmF5QnVmZmVycyB9IGZyb20gJy4uL2JpbmFyeS11dGlscy9hcnJheS1idWZmZXItdXRpbHMnO1xuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZm9yRWFjaChpdGVyYXRvciwgdmlzaXRvcikge1xuICB3aGlsZSAodHJ1ZSkge1xuICAgIGNvbnN0IHtcbiAgICAgIGRvbmUsXG4gICAgICB2YWx1ZVxuICAgIH0gPSBhd2FpdCBpdGVyYXRvci5uZXh0KCk7XG4gICAgaWYgKGRvbmUpIHtcbiAgICAgIGl0ZXJhdG9yLnJldHVybigpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBjYW5jZWwgPSB2aXNpdG9yKHZhbHVlKTtcbiAgICBpZiAoY2FuY2VsKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBjb25jYXRlbmF0ZUFycmF5QnVmZmVyc0FzeW5jKGFzeW5jSXRlcmF0b3IpIHtcbiAgY29uc3QgYXJyYXlCdWZmZXJzID0gW107XG4gIGZvciBhd2FpdCAoY29uc3QgY2h1bmsgb2YgYXN5bmNJdGVyYXRvcikge1xuICAgIGFycmF5QnVmZmVycy5wdXNoKGNodW5rKTtcbiAgfVxuICByZXR1cm4gY29uY2F0ZW5hdGVBcnJheUJ1ZmZlcnMoLi4uYXJyYXlCdWZmZXJzKTtcbn1cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBjb25jYXRlbmF0ZVN0cmluZ3NBc3luYyhhc3luY0l0ZXJhdG9yKSB7XG4gIGNvbnN0IHN0cmluZ3MgPSBbXTtcbiAgZm9yIGF3YWl0IChjb25zdCBjaHVuayBvZiBhc3luY0l0ZXJhdG9yKSB7XG4gICAgc3RyaW5ncy5wdXNoKGNodW5rKTtcbiAgfVxuICByZXR1cm4gc3RyaW5ncy5qb2luKCcnKTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWFzeW5jLWl0ZXJhdGlvbi5qcy5tYXAiLCJjb25zdCBERUZBVUxUX0NIVU5LX1NJWkUgPSAyNTYgKiAxMDI0O1xuXG5leHBvcnQgZnVuY3Rpb24qIG1ha2VTdHJpbmdJdGVyYXRvcihzdHJpbmcsIG9wdGlvbnMpIHtcbiAgY29uc3QgY2h1bmtTaXplID0gKG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5jaHVua1NpemUpIHx8IERFRkFVTFRfQ0hVTktfU0laRTtcbiAgbGV0IG9mZnNldCA9IDA7XG4gIGNvbnN0IHRleHRFbmNvZGVyID0gbmV3IFRleHRFbmNvZGVyKCk7XG4gIHdoaWxlIChvZmZzZXQgPCBzdHJpbmcubGVuZ3RoKSB7XG4gICAgY29uc3QgY2h1bmtMZW5ndGggPSBNYXRoLm1pbihzdHJpbmcubGVuZ3RoIC0gb2Zmc2V0LCBjaHVua1NpemUpO1xuICAgIGNvbnN0IGNodW5rID0gc3RyaW5nLnNsaWNlKG9mZnNldCwgb2Zmc2V0ICsgY2h1bmtMZW5ndGgpO1xuICAgIG9mZnNldCArPSBjaHVua0xlbmd0aDtcblxuICAgIHlpZWxkIHRleHRFbmNvZGVyLmVuY29kZShjaHVuayk7XG4gIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW1ha2Utc3RyaW5nLWl0ZXJhdG9yLmpzLm1hcCIsImNvbnN0IERFRkFVTFRfQ0hVTktfU0laRSA9IDI1NiAqIDEwMjQ7XG5cbmV4cG9ydCBmdW5jdGlvbiogbWFrZUFycmF5QnVmZmVySXRlcmF0b3IoYXJyYXlCdWZmZXIpIHtcbiAgbGV0IG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuICBjb25zdCB7XG4gICAgY2h1bmtTaXplID0gREVGQVVMVF9DSFVOS19TSVpFXG4gIH0gPSBvcHRpb25zO1xuICBsZXQgYnl0ZU9mZnNldCA9IDA7XG4gIHdoaWxlIChieXRlT2Zmc2V0IDwgYXJyYXlCdWZmZXIuYnl0ZUxlbmd0aCkge1xuICAgIGNvbnN0IGNodW5rQnl0ZUxlbmd0aCA9IE1hdGgubWluKGFycmF5QnVmZmVyLmJ5dGVMZW5ndGggLSBieXRlT2Zmc2V0LCBjaHVua1NpemUpO1xuICAgIGNvbnN0IGNodW5rID0gbmV3IEFycmF5QnVmZmVyKGNodW5rQnl0ZUxlbmd0aCk7XG5cbiAgICBjb25zdCBzb3VyY2VBcnJheSA9IG5ldyBVaW50OEFycmF5KGFycmF5QnVmZmVyLCBieXRlT2Zmc2V0LCBjaHVua0J5dGVMZW5ndGgpO1xuICAgIGNvbnN0IGNodW5rQXJyYXkgPSBuZXcgVWludDhBcnJheShjaHVuayk7XG4gICAgY2h1bmtBcnJheS5zZXQoc291cmNlQXJyYXkpO1xuXG4gICAgYnl0ZU9mZnNldCArPSBjaHVua0J5dGVMZW5ndGg7XG4gICAgeWllbGQgY2h1bms7XG4gIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW1ha2UtYXJyYXktYnVmZmVyLWl0ZXJhdG9yLmpzLm1hcCIsImNvbnN0IERFRkFVTFRfQ0hVTktfU0laRSA9IDEwMjQgKiAxMDI0O1xuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24qIG1ha2VCbG9iSXRlcmF0b3IoYmxvYiwgb3B0aW9ucykge1xuICBjb25zdCBjaHVua1NpemUgPSAob3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLmNodW5rU2l6ZSkgfHwgREVGQVVMVF9DSFVOS19TSVpFO1xuICBsZXQgb2Zmc2V0ID0gMDtcbiAgd2hpbGUgKG9mZnNldCA8IGJsb2Iuc2l6ZSkge1xuICAgIGNvbnN0IGVuZCA9IG9mZnNldCArIGNodW5rU2l6ZTtcbiAgICBjb25zdCBjaHVuayA9IGF3YWl0IGJsb2Iuc2xpY2Uob2Zmc2V0LCBlbmQpLmFycmF5QnVmZmVyKCk7XG4gICAgb2Zmc2V0ID0gZW5kO1xuICAgIHlpZWxkIGNodW5rO1xuICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1tYWtlLWJsb2ItaXRlcmF0b3IuanMubWFwIiwiXG5cbmltcG9ydCAqIGFzIG5vZGUgZnJvbSAnLi4vbm9kZS9idWZmZXInO1xuXG5leHBvcnQgZnVuY3Rpb24gaXNCdWZmZXIodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlICYmIHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgJiYgdmFsdWUuaXNCdWZmZXI7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB0b0J1ZmZlcihkYXRhKSB7XG4gIHJldHVybiBub2RlLnRvQnVmZmVyID8gbm9kZS50b0J1ZmZlcihkYXRhKSA6IGRhdGE7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB0b0FycmF5QnVmZmVyKGRhdGEpIHtcbiAgaWYgKGlzQnVmZmVyKGRhdGEpKSB7XG4gICAgcmV0dXJuIG5vZGUudG9BcnJheUJ1ZmZlcihkYXRhKTtcbiAgfVxuICBpZiAoZGF0YSBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSB7XG4gICAgcmV0dXJuIGRhdGE7XG4gIH1cblxuICBpZiAoQXJyYXlCdWZmZXIuaXNWaWV3KGRhdGEpKSB7XG4gICAgaWYgKGRhdGEuYnl0ZU9mZnNldCA9PT0gMCAmJiBkYXRhLmJ5dGVMZW5ndGggPT09IGRhdGEuYnVmZmVyLmJ5dGVMZW5ndGgpIHtcbiAgICAgIHJldHVybiBkYXRhLmJ1ZmZlcjtcbiAgICB9XG4gICAgcmV0dXJuIGRhdGEuYnVmZmVyLnNsaWNlKGRhdGEuYnl0ZU9mZnNldCwgZGF0YS5ieXRlT2Zmc2V0ICsgZGF0YS5ieXRlTGVuZ3RoKTtcbiAgfVxuICBpZiAodHlwZW9mIGRhdGEgPT09ICdzdHJpbmcnKSB7XG4gICAgY29uc3QgdGV4dCA9IGRhdGE7XG4gICAgY29uc3QgdWludDhBcnJheSA9IG5ldyBUZXh0RW5jb2RlcigpLmVuY29kZSh0ZXh0KTtcbiAgICByZXR1cm4gdWludDhBcnJheS5idWZmZXI7XG4gIH1cblxuICBpZiAoZGF0YSAmJiB0eXBlb2YgZGF0YSA9PT0gJ29iamVjdCcgJiYgZGF0YS5fdG9BcnJheUJ1ZmZlcikge1xuICAgIHJldHVybiBkYXRhLl90b0FycmF5QnVmZmVyKCk7XG4gIH1cbiAgdGhyb3cgbmV3IEVycm9yKCd0b0FycmF5QnVmZmVyJyk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1tZW1vcnktY29udmVyc2lvbi11dGlscy5qcy5tYXAiLCJpbXBvcnQgeyBpc0Jyb3dzZXIsIHRvQXJyYXlCdWZmZXIgfSBmcm9tICdAbG9hZGVycy5nbC9sb2FkZXItdXRpbHMnO1xuZXhwb3J0IGZ1bmN0aW9uIG1ha2VTdHJlYW1JdGVyYXRvcihzdHJlYW0sIG9wdGlvbnMpIHtcbiAgcmV0dXJuIGlzQnJvd3NlciA/IG1ha2VCcm93c2VyU3RyZWFtSXRlcmF0b3Ioc3RyZWFtLCBvcHRpb25zKSA6IG1ha2VOb2RlU3RyZWFtSXRlcmF0b3Ioc3RyZWFtLCBvcHRpb25zKTtcbn1cblxuYXN5bmMgZnVuY3Rpb24qIG1ha2VCcm93c2VyU3RyZWFtSXRlcmF0b3Ioc3RyZWFtLCBvcHRpb25zKSB7XG5cbiAgY29uc3QgcmVhZGVyID0gc3RyZWFtLmdldFJlYWRlcigpO1xuICBsZXQgbmV4dEJhdGNoUHJvbWlzZTtcbiAgdHJ5IHtcbiAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgY29uc3QgY3VycmVudEJhdGNoUHJvbWlzZSA9IG5leHRCYXRjaFByb21pc2UgfHwgcmVhZGVyLnJlYWQoKTtcbiAgICAgIGlmIChvcHRpb25zICE9PSBudWxsICYmIG9wdGlvbnMgIT09IHZvaWQgMCAmJiBvcHRpb25zLl9zdHJlYW1SZWFkQWhlYWQpIHtcbiAgICAgICAgbmV4dEJhdGNoUHJvbWlzZSA9IHJlYWRlci5yZWFkKCk7XG4gICAgICB9XG4gICAgICBjb25zdCB7XG4gICAgICAgIGRvbmUsXG4gICAgICAgIHZhbHVlXG4gICAgICB9ID0gYXdhaXQgY3VycmVudEJhdGNoUHJvbWlzZTtcbiAgICAgIGlmIChkb25lKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHlpZWxkIHRvQXJyYXlCdWZmZXIodmFsdWUpO1xuICAgIH1cbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICByZWFkZXIucmVsZWFzZUxvY2soKTtcbiAgfVxufVxuXG5hc3luYyBmdW5jdGlvbiogbWFrZU5vZGVTdHJlYW1JdGVyYXRvcihzdHJlYW0sIG9wdGlvbnMpIHtcbiAgZm9yIGF3YWl0IChjb25zdCBjaHVuayBvZiBzdHJlYW0pIHtcbiAgICB5aWVsZCB0b0FycmF5QnVmZmVyKGNodW5rKTtcbiAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bWFrZS1zdHJlYW0taXRlcmF0b3IuanMubWFwIiwiaW1wb3J0IHsgbWFrZVN0cmluZ0l0ZXJhdG9yIH0gZnJvbSAnLi9tYWtlLXN0cmluZy1pdGVyYXRvcic7XG5pbXBvcnQgeyBtYWtlQXJyYXlCdWZmZXJJdGVyYXRvciB9IGZyb20gJy4vbWFrZS1hcnJheS1idWZmZXItaXRlcmF0b3InO1xuaW1wb3J0IHsgbWFrZUJsb2JJdGVyYXRvciB9IGZyb20gJy4vbWFrZS1ibG9iLWl0ZXJhdG9yJztcbmltcG9ydCB7IG1ha2VTdHJlYW1JdGVyYXRvciB9IGZyb20gJy4vbWFrZS1zdHJlYW0taXRlcmF0b3InO1xuaW1wb3J0IHsgaXNCbG9iLCBpc1JlYWRhYmxlU3RyZWFtLCBpc1Jlc3BvbnNlIH0gZnJvbSAnLi4vLi4vamF2YXNjcmlwdC11dGlscy9pcy10eXBlJztcblxuZXhwb3J0IGZ1bmN0aW9uIG1ha2VJdGVyYXRvcihkYXRhLCBvcHRpb25zKSB7XG4gIGlmICh0eXBlb2YgZGF0YSA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gbWFrZVN0cmluZ0l0ZXJhdG9yKGRhdGEsIG9wdGlvbnMpO1xuICB9XG4gIGlmIChkYXRhIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpIHtcbiAgICByZXR1cm4gbWFrZUFycmF5QnVmZmVySXRlcmF0b3IoZGF0YSwgb3B0aW9ucyk7XG4gIH1cbiAgaWYgKGlzQmxvYihkYXRhKSkge1xuICAgIHJldHVybiBtYWtlQmxvYkl0ZXJhdG9yKGRhdGEsIG9wdGlvbnMpO1xuICB9XG4gIGlmIChpc1JlYWRhYmxlU3RyZWFtKGRhdGEpKSB7XG4gICAgcmV0dXJuIG1ha2VTdHJlYW1JdGVyYXRvcihkYXRhLCBvcHRpb25zKTtcbiAgfVxuICBpZiAoaXNSZXNwb25zZShkYXRhKSkge1xuICAgIGNvbnN0IHJlc3BvbnNlID0gZGF0YTtcbiAgICByZXR1cm4gbWFrZVN0cmVhbUl0ZXJhdG9yKHJlc3BvbnNlLmJvZHksIG9wdGlvbnMpO1xuICB9XG4gIHRocm93IG5ldyBFcnJvcignbWFrZUl0ZXJhdG9yJyk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1tYWtlLWl0ZXJhdG9yLmpzLm1hcCIsImltcG9ydCB7IGNvbmNhdGVuYXRlQXJyYXlCdWZmZXJzQXN5bmMgfSBmcm9tICdAbG9hZGVycy5nbC9sb2FkZXItdXRpbHMnO1xuaW1wb3J0IHsgaXNSZXNwb25zZSwgaXNSZWFkYWJsZVN0cmVhbSwgaXNBc3luY0l0ZXJhYmxlLCBpc0l0ZXJhYmxlLCBpc0l0ZXJhdG9yLCBpc0Jsb2IsIGlzQnVmZmVyIH0gZnJvbSAnLi4vLi4vamF2YXNjcmlwdC11dGlscy9pcy10eXBlJztcbmltcG9ydCB7IG1ha2VJdGVyYXRvciB9IGZyb20gJy4uLy4uL2l0ZXJhdG9ycy9tYWtlLWl0ZXJhdG9yL21ha2UtaXRlcmF0b3InO1xuaW1wb3J0IHsgY2hlY2tSZXNwb25zZSwgbWFrZVJlc3BvbnNlIH0gZnJvbSAnLi4vdXRpbHMvcmVzcG9uc2UtdXRpbHMnO1xuY29uc3QgRVJSX0RBVEEgPSAnQ2Fubm90IGNvbnZlcnQgc3VwcGxpZWQgZGF0YSB0eXBlJztcblxuZXhwb3J0IGZ1bmN0aW9uIGdldEFycmF5QnVmZmVyT3JTdHJpbmdGcm9tRGF0YVN5bmMoZGF0YSwgbG9hZGVyLCBvcHRpb25zKSB7XG4gIGlmIChsb2FkZXIudGV4dCAmJiB0eXBlb2YgZGF0YSA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gZGF0YTtcbiAgfVxuICBpZiAoaXNCdWZmZXIoZGF0YSkpIHtcbiAgICBkYXRhID0gZGF0YS5idWZmZXI7XG4gIH1cbiAgaWYgKGRhdGEgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikge1xuICAgIGNvbnN0IGFycmF5QnVmZmVyID0gZGF0YTtcbiAgICBpZiAobG9hZGVyLnRleHQgJiYgIWxvYWRlci5iaW5hcnkpIHtcbiAgICAgIGNvbnN0IHRleHREZWNvZGVyID0gbmV3IFRleHREZWNvZGVyKCd1dGY4Jyk7XG4gICAgICByZXR1cm4gdGV4dERlY29kZXIuZGVjb2RlKGFycmF5QnVmZmVyKTtcbiAgICB9XG4gICAgcmV0dXJuIGFycmF5QnVmZmVyO1xuICB9XG5cbiAgaWYgKEFycmF5QnVmZmVyLmlzVmlldyhkYXRhKSkge1xuICAgIGlmIChsb2FkZXIudGV4dCAmJiAhbG9hZGVyLmJpbmFyeSkge1xuICAgICAgY29uc3QgdGV4dERlY29kZXIgPSBuZXcgVGV4dERlY29kZXIoJ3V0ZjgnKTtcbiAgICAgIHJldHVybiB0ZXh0RGVjb2Rlci5kZWNvZGUoZGF0YSk7XG4gICAgfVxuICAgIGxldCBhcnJheUJ1ZmZlciA9IGRhdGEuYnVmZmVyO1xuXG4gICAgY29uc3QgYnl0ZUxlbmd0aCA9IGRhdGEuYnl0ZUxlbmd0aCB8fCBkYXRhLmxlbmd0aDtcbiAgICBpZiAoZGF0YS5ieXRlT2Zmc2V0ICE9PSAwIHx8IGJ5dGVMZW5ndGggIT09IGFycmF5QnVmZmVyLmJ5dGVMZW5ndGgpIHtcbiAgICAgIGFycmF5QnVmZmVyID0gYXJyYXlCdWZmZXIuc2xpY2UoZGF0YS5ieXRlT2Zmc2V0LCBkYXRhLmJ5dGVPZmZzZXQgKyBieXRlTGVuZ3RoKTtcbiAgICB9XG4gICAgcmV0dXJuIGFycmF5QnVmZmVyO1xuICB9XG4gIHRocm93IG5ldyBFcnJvcihFUlJfREFUQSk7XG59XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBnZXRBcnJheUJ1ZmZlck9yU3RyaW5nRnJvbURhdGEoZGF0YSwgbG9hZGVyLCBvcHRpb25zKSB7XG4gIGNvbnN0IGlzQXJyYXlCdWZmZXIgPSBkYXRhIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIgfHwgQXJyYXlCdWZmZXIuaXNWaWV3KGRhdGEpO1xuICBpZiAodHlwZW9mIGRhdGEgPT09ICdzdHJpbmcnIHx8IGlzQXJyYXlCdWZmZXIpIHtcbiAgICByZXR1cm4gZ2V0QXJyYXlCdWZmZXJPclN0cmluZ0Zyb21EYXRhU3luYyhkYXRhLCBsb2FkZXIsIG9wdGlvbnMpO1xuICB9XG5cbiAgaWYgKGlzQmxvYihkYXRhKSkge1xuICAgIGRhdGEgPSBhd2FpdCBtYWtlUmVzcG9uc2UoZGF0YSk7XG4gIH1cbiAgaWYgKGlzUmVzcG9uc2UoZGF0YSkpIHtcbiAgICBjb25zdCByZXNwb25zZSA9IGRhdGE7XG4gICAgYXdhaXQgY2hlY2tSZXNwb25zZShyZXNwb25zZSk7XG4gICAgcmV0dXJuIGxvYWRlci5iaW5hcnkgPyBhd2FpdCByZXNwb25zZS5hcnJheUJ1ZmZlcigpIDogYXdhaXQgcmVzcG9uc2UudGV4dCgpO1xuICB9XG4gIGlmIChpc1JlYWRhYmxlU3RyZWFtKGRhdGEpKSB7XG4gICAgZGF0YSA9IG1ha2VJdGVyYXRvcihkYXRhLCBvcHRpb25zKTtcbiAgfVxuICBpZiAoaXNJdGVyYWJsZShkYXRhKSB8fCBpc0FzeW5jSXRlcmFibGUoZGF0YSkpIHtcbiAgICByZXR1cm4gY29uY2F0ZW5hdGVBcnJheUJ1ZmZlcnNBc3luYyhkYXRhKTtcbiAgfVxuICB0aHJvdyBuZXcgRXJyb3IoRVJSX0RBVEEpO1xufVxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGdldEFzeW5jSXRlcmFibGVGcm9tRGF0YShkYXRhLCBvcHRpb25zKSB7XG4gIGlmIChpc0l0ZXJhdG9yKGRhdGEpKSB7XG4gICAgcmV0dXJuIGRhdGE7XG4gIH1cbiAgaWYgKGlzUmVzcG9uc2UoZGF0YSkpIHtcbiAgICBjb25zdCByZXNwb25zZSA9IGRhdGE7XG4gICAgYXdhaXQgY2hlY2tSZXNwb25zZShyZXNwb25zZSk7XG4gICAgY29uc3QgYm9keSA9IGF3YWl0IHJlc3BvbnNlLmJvZHk7XG4gICAgcmV0dXJuIG1ha2VJdGVyYXRvcihib2R5LCBvcHRpb25zKTtcbiAgfVxuICBpZiAoaXNCbG9iKGRhdGEpIHx8IGlzUmVhZGFibGVTdHJlYW0oZGF0YSkpIHtcbiAgICByZXR1cm4gbWFrZUl0ZXJhdG9yKGRhdGEsIG9wdGlvbnMpO1xuICB9XG4gIGlmIChpc0FzeW5jSXRlcmFibGUoZGF0YSkpIHtcbiAgICByZXR1cm4gZGF0YVtTeW1ib2wuYXN5bmNJdGVyYXRvcl0oKTtcbiAgfVxuICByZXR1cm4gZ2V0SXRlcmFibGVGcm9tRGF0YShkYXRhKTtcbn1cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBnZXRSZWFkYWJsZVN0cmVhbShkYXRhKSB7XG4gIGlmIChpc1JlYWRhYmxlU3RyZWFtKGRhdGEpKSB7XG4gICAgcmV0dXJuIGRhdGE7XG4gIH1cbiAgaWYgKGlzUmVzcG9uc2UoZGF0YSkpIHtcbiAgICByZXR1cm4gZGF0YS5ib2R5O1xuICB9XG4gIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgbWFrZVJlc3BvbnNlKGRhdGEpO1xuICByZXR1cm4gcmVzcG9uc2UuYm9keTtcbn1cblxuZnVuY3Rpb24gZ2V0SXRlcmFibGVGcm9tRGF0YShkYXRhKSB7XG4gIGlmIChBcnJheUJ1ZmZlci5pc1ZpZXcoZGF0YSkpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24qIG9uZUNodW5rKCkge1xuICAgICAgeWllbGQgZGF0YS5idWZmZXI7XG4gICAgfSgpO1xuICB9XG4gIGlmIChkYXRhIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24qIG9uZUNodW5rKCkge1xuICAgICAgeWllbGQgZGF0YTtcbiAgICB9KCk7XG4gIH1cbiAgaWYgKGlzSXRlcmF0b3IoZGF0YSkpIHtcbiAgICByZXR1cm4gZGF0YTtcbiAgfVxuICBpZiAoaXNJdGVyYWJsZShkYXRhKSkge1xuICAgIHJldHVybiBkYXRhW1N5bWJvbC5pdGVyYXRvcl0oKTtcbiAgfVxuICB0aHJvdyBuZXcgRXJyb3IoRVJSX0RBVEEpO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Z2V0LWRhdGEuanMubWFwIiwiaW1wb3J0IHsgZ2V0RmV0Y2hGdW5jdGlvbiB9IGZyb20gJy4vb3B0aW9uLXV0aWxzJztcblxuZXhwb3J0IGZ1bmN0aW9uIGdldExvYWRlckNvbnRleHQoY29udGV4dCwgb3B0aW9ucykge1xuICBsZXQgcHJldmlvdXNDb250ZXh0ID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiBudWxsO1xuICBpZiAocHJldmlvdXNDb250ZXh0KSB7XG4gICAgcmV0dXJuIHByZXZpb3VzQ29udGV4dDtcbiAgfVxuICBjb25zdCByZXNvbHZlZENvbnRleHQgPSB7XG4gICAgZmV0Y2g6IGdldEZldGNoRnVuY3Rpb24ob3B0aW9ucywgY29udGV4dCksXG4gICAgLi4uY29udGV4dFxuICB9O1xuXG4gIGlmICghQXJyYXkuaXNBcnJheShyZXNvbHZlZENvbnRleHQubG9hZGVycykpIHtcbiAgICByZXNvbHZlZENvbnRleHQubG9hZGVycyA9IG51bGw7XG4gIH1cbiAgcmV0dXJuIHJlc29sdmVkQ29udGV4dDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdldExvYWRlcnNGcm9tQ29udGV4dChsb2FkZXJzLCBjb250ZXh0KSB7XG4gIGlmICghY29udGV4dCAmJiBsb2FkZXJzICYmICFBcnJheS5pc0FycmF5KGxvYWRlcnMpKSB7XG4gICAgcmV0dXJuIGxvYWRlcnM7XG4gIH1cblxuICBsZXQgY2FuZGlkYXRlTG9hZGVycztcbiAgaWYgKGxvYWRlcnMpIHtcbiAgICBjYW5kaWRhdGVMb2FkZXJzID0gQXJyYXkuaXNBcnJheShsb2FkZXJzKSA/IGxvYWRlcnMgOiBbbG9hZGVyc107XG4gIH1cbiAgaWYgKGNvbnRleHQgJiYgY29udGV4dC5sb2FkZXJzKSB7XG4gICAgY29uc3QgY29udGV4dExvYWRlcnMgPSBBcnJheS5pc0FycmF5KGNvbnRleHQubG9hZGVycykgPyBjb250ZXh0LmxvYWRlcnMgOiBbY29udGV4dC5sb2FkZXJzXTtcbiAgICBjYW5kaWRhdGVMb2FkZXJzID0gY2FuZGlkYXRlTG9hZGVycyA/IFsuLi5jYW5kaWRhdGVMb2FkZXJzLCAuLi5jb250ZXh0TG9hZGVyc10gOiBjb250ZXh0TG9hZGVycztcbiAgfVxuICByZXR1cm4gY2FuZGlkYXRlTG9hZGVycyAmJiBjYW5kaWRhdGVMb2FkZXJzLmxlbmd0aCA/IGNhbmRpZGF0ZUxvYWRlcnMgOiBudWxsO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bG9hZGVyLWNvbnRleHQuanMubWFwIiwiXG5cbmV4cG9ydCBmdW5jdGlvbiBmaWxlbmFtZSh1cmwpIHtcbiAgY29uc3Qgc2xhc2hJbmRleCA9IHVybCAmJiB1cmwubGFzdEluZGV4T2YoJy8nKTtcbiAgcmV0dXJuIHNsYXNoSW5kZXggPj0gMCA/IHVybC5zdWJzdHIoc2xhc2hJbmRleCArIDEpIDogJyc7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBkaXJuYW1lKHVybCkge1xuICBjb25zdCBzbGFzaEluZGV4ID0gdXJsICYmIHVybC5sYXN0SW5kZXhPZignLycpO1xuICByZXR1cm4gc2xhc2hJbmRleCA+PSAwID8gdXJsLnN1YnN0cigwLCBzbGFzaEluZGV4KSA6ICcnO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gam9pbigpIHtcbiAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIHBhcnRzID0gbmV3IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgIHBhcnRzW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICB9XG4gIGNvbnN0IHNlcGFyYXRvciA9ICcvJztcbiAgcGFydHMgPSBwYXJ0cy5tYXAoKHBhcnQsIGluZGV4KSA9PiB7XG4gICAgaWYgKGluZGV4KSB7XG4gICAgICBwYXJ0ID0gcGFydC5yZXBsYWNlKG5ldyBSZWdFeHAoXCJeXCIuY29uY2F0KHNlcGFyYXRvcikpLCAnJyk7XG4gICAgfVxuICAgIGlmIChpbmRleCAhPT0gcGFydHMubGVuZ3RoIC0gMSkge1xuICAgICAgcGFydCA9IHBhcnQucmVwbGFjZShuZXcgUmVnRXhwKFwiXCIuY29uY2F0KHNlcGFyYXRvciwgXCIkXCIpKSwgJycpO1xuICAgIH1cbiAgICByZXR1cm4gcGFydDtcbiAgfSk7XG4gIHJldHVybiBwYXJ0cy5qb2luKHNlcGFyYXRvcik7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1wYXRoLmpzLm1hcCIsIlxuaW1wb3J0IHsgTG9nIH0gZnJvbSAnQHByb2JlLmdsL2xvZyc7XG5leHBvcnQgY29uc3QgbG9nID0gbmV3IExvZyh7XG4gIGlkOiAnbG9hZGVycy5nbCdcbn0pO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bG9nLmpzLm1hcCIsImltcG9ydCB7IGNvbXBhcmVBcnJheUJ1ZmZlcnMsIHBhdGggfSBmcm9tICdAbG9hZGVycy5nbC9sb2FkZXItdXRpbHMnO1xuaW1wb3J0IHsgbm9ybWFsaXplTG9hZGVyIH0gZnJvbSAnLi4vbG9hZGVyLXV0aWxzL25vcm1hbGl6ZS1sb2FkZXInO1xuaW1wb3J0IHsgbG9nIH0gZnJvbSAnLi4vdXRpbHMvbG9nJztcbmltcG9ydCB7IGdldFJlc291cmNlVXJsQW5kVHlwZSB9IGZyb20gJy4uL3V0aWxzL3Jlc291cmNlLXV0aWxzJztcbmltcG9ydCB7IGdldFJlZ2lzdGVyZWRMb2FkZXJzIH0gZnJvbSAnLi9yZWdpc3Rlci1sb2FkZXJzJztcbmltcG9ydCB7IGlzQmxvYiB9IGZyb20gJy4uLy4uL2phdmFzY3JpcHQtdXRpbHMvaXMtdHlwZSc7XG5jb25zdCBFWFRfUEFUVEVSTiA9IC9cXC4oW14uXSspJC87XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBzZWxlY3RMb2FkZXIoZGF0YSkge1xuICBsZXQgbG9hZGVycyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogW107XG4gIGxldCBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgPyBhcmd1bWVudHNbMl0gOiB1bmRlZmluZWQ7XG4gIGxldCBjb250ZXh0ID0gYXJndW1lbnRzLmxlbmd0aCA+IDMgPyBhcmd1bWVudHNbM10gOiB1bmRlZmluZWQ7XG4gIGlmICghdmFsaWRIVFRQUmVzcG9uc2UoZGF0YSkpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIGxldCBsb2FkZXIgPSBzZWxlY3RMb2FkZXJTeW5jKGRhdGEsIGxvYWRlcnMsIHtcbiAgICAuLi5vcHRpb25zLFxuICAgIG5vdGhyb3c6IHRydWVcbiAgfSwgY29udGV4dCk7XG4gIGlmIChsb2FkZXIpIHtcbiAgICByZXR1cm4gbG9hZGVyO1xuICB9XG5cbiAgaWYgKGlzQmxvYihkYXRhKSkge1xuICAgIGRhdGEgPSBhd2FpdCBkYXRhLnNsaWNlKDAsIDEwKS5hcnJheUJ1ZmZlcigpO1xuICAgIGxvYWRlciA9IHNlbGVjdExvYWRlclN5bmMoZGF0YSwgbG9hZGVycywgb3B0aW9ucywgY29udGV4dCk7XG4gIH1cblxuICBpZiAoIWxvYWRlciAmJiAhKG9wdGlvbnMgIT09IG51bGwgJiYgb3B0aW9ucyAhPT0gdm9pZCAwICYmIG9wdGlvbnMubm90aHJvdykpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoZ2V0Tm9WYWxpZExvYWRlck1lc3NhZ2UoZGF0YSkpO1xuICB9XG4gIHJldHVybiBsb2FkZXI7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBzZWxlY3RMb2FkZXJTeW5jKGRhdGEpIHtcbiAgbGV0IGxvYWRlcnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IFtdO1xuICBsZXQgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAyID8gYXJndW1lbnRzWzJdIDogdW5kZWZpbmVkO1xuICBsZXQgY29udGV4dCA9IGFyZ3VtZW50cy5sZW5ndGggPiAzID8gYXJndW1lbnRzWzNdIDogdW5kZWZpbmVkO1xuICBpZiAoIXZhbGlkSFRUUFJlc3BvbnNlKGRhdGEpKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBpZiAobG9hZGVycyAmJiAhQXJyYXkuaXNBcnJheShsb2FkZXJzKSkge1xuICAgIHJldHVybiBub3JtYWxpemVMb2FkZXIobG9hZGVycyk7XG4gIH1cblxuICBsZXQgY2FuZGlkYXRlTG9hZGVycyA9IFtdO1xuICBpZiAobG9hZGVycykge1xuICAgIGNhbmRpZGF0ZUxvYWRlcnMgPSBjYW5kaWRhdGVMb2FkZXJzLmNvbmNhdChsb2FkZXJzKTtcbiAgfVxuICBpZiAoIShvcHRpb25zICE9PSBudWxsICYmIG9wdGlvbnMgIT09IHZvaWQgMCAmJiBvcHRpb25zLmlnbm9yZVJlZ2lzdGVyZWRMb2FkZXJzKSkge1xuICAgIGNhbmRpZGF0ZUxvYWRlcnMucHVzaCguLi5nZXRSZWdpc3RlcmVkTG9hZGVycygpKTtcbiAgfVxuXG4gIG5vcm1hbGl6ZUxvYWRlcnMoY2FuZGlkYXRlTG9hZGVycyk7XG4gIGNvbnN0IGxvYWRlciA9IHNlbGVjdExvYWRlckludGVybmFsKGRhdGEsIGNhbmRpZGF0ZUxvYWRlcnMsIG9wdGlvbnMsIGNvbnRleHQpO1xuXG4gIGlmICghbG9hZGVyICYmICEob3B0aW9ucyAhPT0gbnVsbCAmJiBvcHRpb25zICE9PSB2b2lkIDAgJiYgb3B0aW9ucy5ub3Rocm93KSkge1xuICAgIHRocm93IG5ldyBFcnJvcihnZXROb1ZhbGlkTG9hZGVyTWVzc2FnZShkYXRhKSk7XG4gIH1cbiAgcmV0dXJuIGxvYWRlcjtcbn1cblxuZnVuY3Rpb24gc2VsZWN0TG9hZGVySW50ZXJuYWwoZGF0YSwgbG9hZGVycywgb3B0aW9ucywgY29udGV4dCkge1xuICBjb25zdCB7XG4gICAgdXJsLFxuICAgIHR5cGVcbiAgfSA9IGdldFJlc291cmNlVXJsQW5kVHlwZShkYXRhKTtcbiAgY29uc3QgdGVzdFVybCA9IHVybCB8fCAoY29udGV4dCA9PT0gbnVsbCB8fCBjb250ZXh0ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjb250ZXh0LnVybCk7XG4gIGxldCBsb2FkZXIgPSBudWxsO1xuICBsZXQgcmVhc29uID0gJyc7XG5cbiAgaWYgKG9wdGlvbnMgIT09IG51bGwgJiYgb3B0aW9ucyAhPT0gdm9pZCAwICYmIG9wdGlvbnMubWltZVR5cGUpIHtcbiAgICBsb2FkZXIgPSBmaW5kTG9hZGVyQnlNSU1FVHlwZShsb2FkZXJzLCBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMubWltZVR5cGUpO1xuICAgIHJlYXNvbiA9IFwibWF0Y2ggZm9yY2VkIGJ5IHN1cHBsaWVkIE1JTUUgdHlwZSBcIi5jb25jYXQob3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLm1pbWVUeXBlKTtcbiAgfVxuXG4gIGxvYWRlciA9IGxvYWRlciB8fCBmaW5kTG9hZGVyQnlVcmwobG9hZGVycywgdGVzdFVybCk7XG4gIHJlYXNvbiA9IHJlYXNvbiB8fCAobG9hZGVyID8gXCJtYXRjaGVkIHVybCBcIi5jb25jYXQodGVzdFVybCkgOiAnJyk7XG5cbiAgbG9hZGVyID0gbG9hZGVyIHx8IGZpbmRMb2FkZXJCeU1JTUVUeXBlKGxvYWRlcnMsIHR5cGUpO1xuICByZWFzb24gPSByZWFzb24gfHwgKGxvYWRlciA/IFwibWF0Y2hlZCBNSU1FIHR5cGUgXCIuY29uY2F0KHR5cGUpIDogJycpO1xuXG4gIGxvYWRlciA9IGxvYWRlciB8fCBmaW5kTG9hZGVyQnlJbml0aWFsQnl0ZXMobG9hZGVycywgZGF0YSk7XG4gIHJlYXNvbiA9IHJlYXNvbiB8fCAobG9hZGVyID8gXCJtYXRjaGVkIGluaXRpYWwgZGF0YSBcIi5jb25jYXQoZ2V0Rmlyc3RDaGFyYWN0ZXJzKGRhdGEpKSA6ICcnKTtcblxuICBsb2FkZXIgPSBsb2FkZXIgfHwgZmluZExvYWRlckJ5TUlNRVR5cGUobG9hZGVycywgb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLmZhbGxiYWNrTWltZVR5cGUpO1xuICByZWFzb24gPSByZWFzb24gfHwgKGxvYWRlciA/IFwibWF0Y2hlZCBmYWxsYmFjayBNSU1FIHR5cGUgXCIuY29uY2F0KHR5cGUpIDogJycpO1xuICBpZiAocmVhc29uKSB7XG4gICAgdmFyIF9sb2FkZXI7XG4gICAgbG9nLmxvZygxLCBcInNlbGVjdExvYWRlciBzZWxlY3RlZCBcIi5jb25jYXQoKF9sb2FkZXIgPSBsb2FkZXIpID09PSBudWxsIHx8IF9sb2FkZXIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9sb2FkZXIubmFtZSwgXCI6IFwiKS5jb25jYXQocmVhc29uLCBcIi5cIikpO1xuICB9XG4gIHJldHVybiBsb2FkZXI7XG59XG5cbmZ1bmN0aW9uIHZhbGlkSFRUUFJlc3BvbnNlKGRhdGEpIHtcbiAgaWYgKGRhdGEgaW5zdGFuY2VvZiBSZXNwb25zZSkge1xuICAgIGlmIChkYXRhLnN0YXR1cyA9PT0gMjA0KSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG4gIHJldHVybiB0cnVlO1xufVxuXG5mdW5jdGlvbiBnZXROb1ZhbGlkTG9hZGVyTWVzc2FnZShkYXRhKSB7XG4gIGNvbnN0IHtcbiAgICB1cmwsXG4gICAgdHlwZVxuICB9ID0gZ2V0UmVzb3VyY2VVcmxBbmRUeXBlKGRhdGEpO1xuICBsZXQgbWVzc2FnZSA9ICdObyB2YWxpZCBsb2FkZXIgZm91bmQgKCc7XG4gIG1lc3NhZ2UgKz0gdXJsID8gXCJcIi5jb25jYXQocGF0aC5maWxlbmFtZSh1cmwpLCBcIiwgXCIpIDogJ25vIHVybCBwcm92aWRlZCwgJztcbiAgbWVzc2FnZSArPSBcIk1JTUUgdHlwZTogXCIuY29uY2F0KHR5cGUgPyBcIlxcXCJcIi5jb25jYXQodHlwZSwgXCJcXFwiXCIpIDogJ25vdCBwcm92aWRlZCcsIFwiLCBcIik7XG4gIGNvbnN0IGZpcnN0Q2hhcmFjdGVycyA9IGRhdGEgPyBnZXRGaXJzdENoYXJhY3RlcnMoZGF0YSkgOiAnJztcbiAgbWVzc2FnZSArPSBmaXJzdENoYXJhY3RlcnMgPyBcIiBmaXJzdCBieXRlczogXFxcIlwiLmNvbmNhdChmaXJzdENoYXJhY3RlcnMsIFwiXFxcIlwiKSA6ICdmaXJzdCBieXRlczogbm90IGF2YWlsYWJsZSc7XG4gIG1lc3NhZ2UgKz0gJyknO1xuICByZXR1cm4gbWVzc2FnZTtcbn1cbmZ1bmN0aW9uIG5vcm1hbGl6ZUxvYWRlcnMobG9hZGVycykge1xuICBmb3IgKGNvbnN0IGxvYWRlciBvZiBsb2FkZXJzKSB7XG4gICAgbm9ybWFsaXplTG9hZGVyKGxvYWRlcik7XG4gIH1cbn1cblxuZnVuY3Rpb24gZmluZExvYWRlckJ5VXJsKGxvYWRlcnMsIHVybCkge1xuICBjb25zdCBtYXRjaCA9IHVybCAmJiBFWFRfUEFUVEVSTi5leGVjKHVybCk7XG4gIGNvbnN0IGV4dGVuc2lvbiA9IG1hdGNoICYmIG1hdGNoWzFdO1xuICByZXR1cm4gZXh0ZW5zaW9uID8gZmluZExvYWRlckJ5RXh0ZW5zaW9uKGxvYWRlcnMsIGV4dGVuc2lvbikgOiBudWxsO1xufVxuZnVuY3Rpb24gZmluZExvYWRlckJ5RXh0ZW5zaW9uKGxvYWRlcnMsIGV4dGVuc2lvbikge1xuICBleHRlbnNpb24gPSBleHRlbnNpb24udG9Mb3dlckNhc2UoKTtcbiAgZm9yIChjb25zdCBsb2FkZXIgb2YgbG9hZGVycykge1xuICAgIGZvciAoY29uc3QgbG9hZGVyRXh0ZW5zaW9uIG9mIGxvYWRlci5leHRlbnNpb25zKSB7XG4gICAgICBpZiAobG9hZGVyRXh0ZW5zaW9uLnRvTG93ZXJDYXNlKCkgPT09IGV4dGVuc2lvbikge1xuICAgICAgICByZXR1cm4gbG9hZGVyO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gbnVsbDtcbn1cbmZ1bmN0aW9uIGZpbmRMb2FkZXJCeU1JTUVUeXBlKGxvYWRlcnMsIG1pbWVUeXBlKSB7XG4gIGZvciAoY29uc3QgbG9hZGVyIG9mIGxvYWRlcnMpIHtcbiAgICBpZiAobG9hZGVyLm1pbWVUeXBlcyAmJiBsb2FkZXIubWltZVR5cGVzLmluY2x1ZGVzKG1pbWVUeXBlKSkge1xuICAgICAgcmV0dXJuIGxvYWRlcjtcbiAgICB9XG5cbiAgICBpZiAobWltZVR5cGUgPT09IFwiYXBwbGljYXRpb24veC5cIi5jb25jYXQobG9hZGVyLmlkKSkge1xuICAgICAgcmV0dXJuIGxvYWRlcjtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59XG5mdW5jdGlvbiBmaW5kTG9hZGVyQnlJbml0aWFsQnl0ZXMobG9hZGVycywgZGF0YSkge1xuICBpZiAoIWRhdGEpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBmb3IgKGNvbnN0IGxvYWRlciBvZiBsb2FkZXJzKSB7XG4gICAgaWYgKHR5cGVvZiBkYXRhID09PSAnc3RyaW5nJykge1xuICAgICAgaWYgKHRlc3REYXRhQWdhaW5zdFRleHQoZGF0YSwgbG9hZGVyKSkge1xuICAgICAgICByZXR1cm4gbG9hZGVyO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoQXJyYXlCdWZmZXIuaXNWaWV3KGRhdGEpKSB7XG4gICAgICBpZiAodGVzdERhdGFBZ2FpbnN0QmluYXJ5KGRhdGEuYnVmZmVyLCBkYXRhLmJ5dGVPZmZzZXQsIGxvYWRlcikpIHtcbiAgICAgICAgcmV0dXJuIGxvYWRlcjtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGRhdGEgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikge1xuICAgICAgY29uc3QgYnl0ZU9mZnNldCA9IDA7XG4gICAgICBpZiAodGVzdERhdGFBZ2FpbnN0QmluYXJ5KGRhdGEsIGJ5dGVPZmZzZXQsIGxvYWRlcikpIHtcbiAgICAgICAgcmV0dXJuIGxvYWRlcjtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gbnVsbDtcbn1cbmZ1bmN0aW9uIHRlc3REYXRhQWdhaW5zdFRleHQoZGF0YSwgbG9hZGVyKSB7XG4gIGlmIChsb2FkZXIudGVzdFRleHQpIHtcbiAgICByZXR1cm4gbG9hZGVyLnRlc3RUZXh0KGRhdGEpO1xuICB9XG4gIGNvbnN0IHRlc3RzID0gQXJyYXkuaXNBcnJheShsb2FkZXIudGVzdHMpID8gbG9hZGVyLnRlc3RzIDogW2xvYWRlci50ZXN0c107XG4gIHJldHVybiB0ZXN0cy5zb21lKHRlc3QgPT4gZGF0YS5zdGFydHNXaXRoKHRlc3QpKTtcbn1cbmZ1bmN0aW9uIHRlc3REYXRhQWdhaW5zdEJpbmFyeShkYXRhLCBieXRlT2Zmc2V0LCBsb2FkZXIpIHtcbiAgY29uc3QgdGVzdHMgPSBBcnJheS5pc0FycmF5KGxvYWRlci50ZXN0cykgPyBsb2FkZXIudGVzdHMgOiBbbG9hZGVyLnRlc3RzXTtcbiAgcmV0dXJuIHRlc3RzLnNvbWUodGVzdCA9PiB0ZXN0QmluYXJ5KGRhdGEsIGJ5dGVPZmZzZXQsIGxvYWRlciwgdGVzdCkpO1xufVxuZnVuY3Rpb24gdGVzdEJpbmFyeShkYXRhLCBieXRlT2Zmc2V0LCBsb2FkZXIsIHRlc3QpIHtcbiAgaWYgKHRlc3QgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikge1xuICAgIHJldHVybiBjb21wYXJlQXJyYXlCdWZmZXJzKHRlc3QsIGRhdGEsIHRlc3QuYnl0ZUxlbmd0aCk7XG4gIH1cbiAgc3dpdGNoICh0eXBlb2YgdGVzdCkge1xuICAgIGNhc2UgJ2Z1bmN0aW9uJzpcbiAgICAgIHJldHVybiB0ZXN0KGRhdGEsIGxvYWRlcik7XG4gICAgY2FzZSAnc3RyaW5nJzpcbiAgICAgIGNvbnN0IG1hZ2ljID0gZ2V0TWFnaWNTdHJpbmcoZGF0YSwgYnl0ZU9mZnNldCwgdGVzdC5sZW5ndGgpO1xuICAgICAgcmV0dXJuIHRlc3QgPT09IG1hZ2ljO1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn1cbmZ1bmN0aW9uIGdldEZpcnN0Q2hhcmFjdGVycyhkYXRhKSB7XG4gIGxldCBsZW5ndGggPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IDU7XG4gIGlmICh0eXBlb2YgZGF0YSA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gZGF0YS5zbGljZSgwLCBsZW5ndGgpO1xuICB9IGVsc2UgaWYgKEFycmF5QnVmZmVyLmlzVmlldyhkYXRhKSkge1xuICAgIHJldHVybiBnZXRNYWdpY1N0cmluZyhkYXRhLmJ1ZmZlciwgZGF0YS5ieXRlT2Zmc2V0LCBsZW5ndGgpO1xuICB9IGVsc2UgaWYgKGRhdGEgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikge1xuICAgIGNvbnN0IGJ5dGVPZmZzZXQgPSAwO1xuICAgIHJldHVybiBnZXRNYWdpY1N0cmluZyhkYXRhLCBieXRlT2Zmc2V0LCBsZW5ndGgpO1xuICB9XG4gIHJldHVybiAnJztcbn1cbmZ1bmN0aW9uIGdldE1hZ2ljU3RyaW5nKGFycmF5QnVmZmVyLCBieXRlT2Zmc2V0LCBsZW5ndGgpIHtcbiAgaWYgKGFycmF5QnVmZmVyLmJ5dGVMZW5ndGggPCBieXRlT2Zmc2V0ICsgbGVuZ3RoKSB7XG4gICAgcmV0dXJuICcnO1xuICB9XG4gIGNvbnN0IGRhdGFWaWV3ID0gbmV3IERhdGFWaWV3KGFycmF5QnVmZmVyKTtcbiAgbGV0IG1hZ2ljID0gJyc7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICBtYWdpYyArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGRhdGFWaWV3LmdldFVpbnQ4KGJ5dGVPZmZzZXQgKyBpKSk7XG4gIH1cbiAgcmV0dXJuIG1hZ2ljO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c2VsZWN0LWxvYWRlci5qcy5tYXAiLCJpbXBvcnQgeyBhc3NlcnQsIHZhbGlkYXRlV29ya2VyVmVyc2lvbiB9IGZyb20gJ0Bsb2FkZXJzLmdsL3dvcmtlci11dGlscyc7XG5pbXBvcnQgeyBwYXJzZVdpdGhXb3JrZXIsIGNhblBhcnNlV2l0aFdvcmtlciB9IGZyb20gJ0Bsb2FkZXJzLmdsL2xvYWRlci11dGlscyc7XG5pbXBvcnQgeyBpc0xvYWRlck9iamVjdCB9IGZyb20gJy4uL2xvYWRlci11dGlscy9ub3JtYWxpemUtbG9hZGVyJztcbmltcG9ydCB7IGlzUmVzcG9uc2UgfSBmcm9tICcuLi8uLi9qYXZhc2NyaXB0LXV0aWxzL2lzLXR5cGUnO1xuaW1wb3J0IHsgbm9ybWFsaXplT3B0aW9ucyB9IGZyb20gJy4uL2xvYWRlci11dGlscy9vcHRpb24tdXRpbHMnO1xuaW1wb3J0IHsgZ2V0QXJyYXlCdWZmZXJPclN0cmluZ0Zyb21EYXRhIH0gZnJvbSAnLi4vbG9hZGVyLXV0aWxzL2dldC1kYXRhJztcbmltcG9ydCB7IGdldExvYWRlckNvbnRleHQsIGdldExvYWRlcnNGcm9tQ29udGV4dCB9IGZyb20gJy4uL2xvYWRlci11dGlscy9sb2FkZXItY29udGV4dCc7XG5pbXBvcnQgeyBnZXRSZXNvdXJjZVVybEFuZFR5cGUgfSBmcm9tICcuLi91dGlscy9yZXNvdXJjZS11dGlscyc7XG5pbXBvcnQgeyBzZWxlY3RMb2FkZXIgfSBmcm9tICcuL3NlbGVjdC1sb2FkZXInO1xuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gcGFyc2UoZGF0YSwgbG9hZGVycywgb3B0aW9ucywgY29udGV4dCkge1xuICBhc3NlcnQoIWNvbnRleHQgfHwgdHlwZW9mIGNvbnRleHQgPT09ICdvYmplY3QnKTtcblxuICBpZiAobG9hZGVycyAmJiAhQXJyYXkuaXNBcnJheShsb2FkZXJzKSAmJiAhaXNMb2FkZXJPYmplY3QobG9hZGVycykpIHtcbiAgICBjb250ZXh0ID0gdW5kZWZpbmVkO1xuICAgIG9wdGlvbnMgPSBsb2FkZXJzO1xuICAgIGxvYWRlcnMgPSB1bmRlZmluZWQ7XG4gIH1cbiAgZGF0YSA9IGF3YWl0IGRhdGE7XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gIGNvbnN0IHtcbiAgICB1cmxcbiAgfSA9IGdldFJlc291cmNlVXJsQW5kVHlwZShkYXRhKTtcblxuICBjb25zdCB0eXBlZExvYWRlcnMgPSBsb2FkZXJzO1xuICBjb25zdCBjYW5kaWRhdGVMb2FkZXJzID0gZ2V0TG9hZGVyc0Zyb21Db250ZXh0KHR5cGVkTG9hZGVycywgY29udGV4dCk7XG4gIGNvbnN0IGxvYWRlciA9IGF3YWl0IHNlbGVjdExvYWRlcihkYXRhLCBjYW5kaWRhdGVMb2FkZXJzLCBvcHRpb25zKTtcbiAgaWYgKCFsb2FkZXIpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIG9wdGlvbnMgPSBub3JtYWxpemVPcHRpb25zKG9wdGlvbnMsIGxvYWRlciwgY2FuZGlkYXRlTG9hZGVycywgdXJsKTtcblxuICBjb250ZXh0ID0gZ2V0TG9hZGVyQ29udGV4dCh7XG4gICAgdXJsLFxuICAgIHBhcnNlLFxuICAgIGxvYWRlcnM6IGNhbmRpZGF0ZUxvYWRlcnNcbiAgfSwgb3B0aW9ucywgY29udGV4dCk7XG4gIHJldHVybiBhd2FpdCBwYXJzZVdpdGhMb2FkZXIobG9hZGVyLCBkYXRhLCBvcHRpb25zLCBjb250ZXh0KTtcbn1cblxuYXN5bmMgZnVuY3Rpb24gcGFyc2VXaXRoTG9hZGVyKGxvYWRlciwgZGF0YSwgb3B0aW9ucywgY29udGV4dCkge1xuICB2YWxpZGF0ZVdvcmtlclZlcnNpb24obG9hZGVyKTtcbiAgaWYgKGlzUmVzcG9uc2UoZGF0YSkpIHtcbiAgICBjb25zdCByZXNwb25zZSA9IGRhdGE7XG4gICAgY29uc3Qge1xuICAgICAgb2ssXG4gICAgICByZWRpcmVjdGVkLFxuICAgICAgc3RhdHVzLFxuICAgICAgc3RhdHVzVGV4dCxcbiAgICAgIHR5cGUsXG4gICAgICB1cmxcbiAgICB9ID0gcmVzcG9uc2U7XG4gICAgY29uc3QgaGVhZGVycyA9IE9iamVjdC5mcm9tRW50cmllcyhyZXNwb25zZS5oZWFkZXJzLmVudHJpZXMoKSk7XG4gICAgY29udGV4dC5yZXNwb25zZSA9IHtcbiAgICAgIGhlYWRlcnMsXG4gICAgICBvayxcbiAgICAgIHJlZGlyZWN0ZWQsXG4gICAgICBzdGF0dXMsXG4gICAgICBzdGF0dXNUZXh0LFxuICAgICAgdHlwZSxcbiAgICAgIHVybFxuICAgIH07XG4gIH1cbiAgZGF0YSA9IGF3YWl0IGdldEFycmF5QnVmZmVyT3JTdHJpbmdGcm9tRGF0YShkYXRhLCBsb2FkZXIsIG9wdGlvbnMpO1xuXG4gIGlmIChsb2FkZXIucGFyc2VUZXh0U3luYyAmJiB0eXBlb2YgZGF0YSA9PT0gJ3N0cmluZycpIHtcbiAgICBvcHRpb25zLmRhdGFUeXBlID0gJ3RleHQnO1xuICAgIHJldHVybiBsb2FkZXIucGFyc2VUZXh0U3luYyhkYXRhLCBvcHRpb25zLCBjb250ZXh0LCBsb2FkZXIpO1xuICB9XG5cbiAgaWYgKGNhblBhcnNlV2l0aFdvcmtlcihsb2FkZXIsIG9wdGlvbnMpKSB7XG4gICAgcmV0dXJuIGF3YWl0IHBhcnNlV2l0aFdvcmtlcihsb2FkZXIsIGRhdGEsIG9wdGlvbnMsIGNvbnRleHQsIHBhcnNlKTtcbiAgfVxuXG4gIGlmIChsb2FkZXIucGFyc2VUZXh0ICYmIHR5cGVvZiBkYXRhID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiBhd2FpdCBsb2FkZXIucGFyc2VUZXh0KGRhdGEsIG9wdGlvbnMsIGNvbnRleHQsIGxvYWRlcik7XG4gIH1cbiAgaWYgKGxvYWRlci5wYXJzZSkge1xuICAgIHJldHVybiBhd2FpdCBsb2FkZXIucGFyc2UoZGF0YSwgb3B0aW9ucywgY29udGV4dCwgbG9hZGVyKTtcbiAgfVxuXG4gIGFzc2VydCghbG9hZGVyLnBhcnNlU3luYyk7XG5cbiAgdGhyb3cgbmV3IEVycm9yKFwiXCIuY29uY2F0KGxvYWRlci5pZCwgXCIgbG9hZGVyIC0gbm8gcGFyc2VyIGZvdW5kIGFuZCB3b3JrZXIgaXMgZGlzYWJsZWRcIikpO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cGFyc2UuanMubWFwIiwiaW1wb3J0IHsgaXNCbG9iIH0gZnJvbSAnLi4vLi4vamF2YXNjcmlwdC11dGlscy9pcy10eXBlJztcbmltcG9ydCB7IGlzTG9hZGVyT2JqZWN0IH0gZnJvbSAnLi4vbG9hZGVyLXV0aWxzL25vcm1hbGl6ZS1sb2FkZXInO1xuaW1wb3J0IHsgZ2V0RmV0Y2hGdW5jdGlvbiB9IGZyb20gJy4uL2xvYWRlci11dGlscy9vcHRpb24tdXRpbHMnO1xuaW1wb3J0IHsgcGFyc2UgfSBmcm9tICcuL3BhcnNlJztcblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGxvYWQodXJsLCBsb2FkZXJzLCBvcHRpb25zLCBjb250ZXh0KSB7XG4gIGlmICghQXJyYXkuaXNBcnJheShsb2FkZXJzKSAmJiAhaXNMb2FkZXJPYmplY3QobG9hZGVycykpIHtcbiAgICBjb250ZXh0ID0gdW5kZWZpbmVkO1xuICAgIG9wdGlvbnMgPSBsb2FkZXJzO1xuICAgIGxvYWRlcnMgPSB1bmRlZmluZWQ7XG4gIH1cblxuICBjb25zdCBmZXRjaCA9IGdldEZldGNoRnVuY3Rpb24ob3B0aW9ucyk7XG5cbiAgbGV0IGRhdGEgPSB1cmw7XG4gIGlmICh0eXBlb2YgdXJsID09PSAnc3RyaW5nJykge1xuICAgIGRhdGEgPSBhd2FpdCBmZXRjaCh1cmwpO1xuICB9XG5cbiAgaWYgKGlzQmxvYih1cmwpKSB7XG4gICAgZGF0YSA9IGF3YWl0IGZldGNoKHVybCk7XG4gIH1cblxuICByZXR1cm4gYXdhaXQgcGFyc2UoZGF0YSwgbG9hZGVycywgb3B0aW9ucyk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1sb2FkLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///44534\n")},6228:function(__unused_webpack_module,__webpack_exports__,__webpack_require__){eval('/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "fh": function() { return /* binding */ registerLoaders; },\n/* harmony export */   "kO": function() { return /* binding */ getRegisteredLoaders; }\n/* harmony export */ });\n/* unused harmony export _unregisterLoaders */\n/* harmony import */ var _loader_utils_normalize_loader__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(52033);\n/* harmony import */ var _loader_utils_option_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(99597);\n\n\n\nconst getGlobalLoaderRegistry = () => {\n  const state = (0,_loader_utils_option_utils__WEBPACK_IMPORTED_MODULE_0__/* .getGlobalLoaderState */ .rx)();\n  state.loaderRegistry = state.loaderRegistry || [];\n  return state.loaderRegistry;\n};\n\nfunction registerLoaders(loaders) {\n  const loaderRegistry = getGlobalLoaderRegistry();\n  loaders = Array.isArray(loaders) ? loaders : [loaders];\n  for (const loader of loaders) {\n    const normalizedLoader = (0,_loader_utils_normalize_loader__WEBPACK_IMPORTED_MODULE_1__/* .normalizeLoader */ .T)(loader);\n    if (!loaderRegistry.find(registeredLoader => normalizedLoader === registeredLoader)) {\n      loaderRegistry.unshift(normalizedLoader);\n    }\n  }\n}\nfunction getRegisteredLoaders() {\n  return getGlobalLoaderRegistry();\n}\n\nfunction _unregisterLoaders() {\n  const state = getGlobalLoaderState();\n  state.loaderRegistry = [];\n}\n//# sourceMappingURL=register-loaders.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNjIyOC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQW1FO0FBQ0M7O0FBRXBFO0FBQ0EsZ0JBQWdCLDBGQUFvQjtBQUNwQztBQUNBO0FBQ0E7O0FBRU87QUFDUDtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsd0ZBQWU7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTs7QUFFTztBQUNQO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdnVlMy13ZWJwYWNrNS8uL25vZGVfbW9kdWxlcy9AbG9hZGVycy5nbC9jb3JlL2Rpc3QvZXNtL2xpYi9hcGkvcmVnaXN0ZXItbG9hZGVycy5qcz8zZTg4Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IG5vcm1hbGl6ZUxvYWRlciB9IGZyb20gJy4uL2xvYWRlci11dGlscy9ub3JtYWxpemUtbG9hZGVyJztcbmltcG9ydCB7IGdldEdsb2JhbExvYWRlclN0YXRlIH0gZnJvbSAnLi4vbG9hZGVyLXV0aWxzL29wdGlvbi11dGlscyc7XG5cbmNvbnN0IGdldEdsb2JhbExvYWRlclJlZ2lzdHJ5ID0gKCkgPT4ge1xuICBjb25zdCBzdGF0ZSA9IGdldEdsb2JhbExvYWRlclN0YXRlKCk7XG4gIHN0YXRlLmxvYWRlclJlZ2lzdHJ5ID0gc3RhdGUubG9hZGVyUmVnaXN0cnkgfHwgW107XG4gIHJldHVybiBzdGF0ZS5sb2FkZXJSZWdpc3RyeTtcbn07XG5cbmV4cG9ydCBmdW5jdGlvbiByZWdpc3RlckxvYWRlcnMobG9hZGVycykge1xuICBjb25zdCBsb2FkZXJSZWdpc3RyeSA9IGdldEdsb2JhbExvYWRlclJlZ2lzdHJ5KCk7XG4gIGxvYWRlcnMgPSBBcnJheS5pc0FycmF5KGxvYWRlcnMpID8gbG9hZGVycyA6IFtsb2FkZXJzXTtcbiAgZm9yIChjb25zdCBsb2FkZXIgb2YgbG9hZGVycykge1xuICAgIGNvbnN0IG5vcm1hbGl6ZWRMb2FkZXIgPSBub3JtYWxpemVMb2FkZXIobG9hZGVyKTtcbiAgICBpZiAoIWxvYWRlclJlZ2lzdHJ5LmZpbmQocmVnaXN0ZXJlZExvYWRlciA9PiBub3JtYWxpemVkTG9hZGVyID09PSByZWdpc3RlcmVkTG9hZGVyKSkge1xuICAgICAgbG9hZGVyUmVnaXN0cnkudW5zaGlmdChub3JtYWxpemVkTG9hZGVyKTtcbiAgICB9XG4gIH1cbn1cbmV4cG9ydCBmdW5jdGlvbiBnZXRSZWdpc3RlcmVkTG9hZGVycygpIHtcbiAgcmV0dXJuIGdldEdsb2JhbExvYWRlclJlZ2lzdHJ5KCk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBfdW5yZWdpc3RlckxvYWRlcnMoKSB7XG4gIGNvbnN0IHN0YXRlID0gZ2V0R2xvYmFsTG9hZGVyU3RhdGUoKTtcbiAgc3RhdGUubG9hZGVyUmVnaXN0cnkgPSBbXTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXJlZ2lzdGVyLWxvYWRlcnMuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///6228\n')},52033:function(__unused_webpack_module,__webpack_exports__,__webpack_require__){eval("/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"C\": function() { return /* binding */ isLoaderObject; },\n/* harmony export */   \"T\": function() { return /* binding */ normalizeLoader; }\n/* harmony export */ });\n/* harmony import */ var _loaders_gl_loader_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(16269);\n\nfunction isLoaderObject(loader) {\n  var _loader;\n  if (!loader) {\n    return false;\n  }\n  if (Array.isArray(loader)) {\n    loader = loader[0];\n  }\n  const hasExtensions = Array.isArray((_loader = loader) === null || _loader === void 0 ? void 0 : _loader.extensions);\n\n  return hasExtensions;\n}\nfunction normalizeLoader(loader) {\n  var _loader2, _loader3;\n  (0,_loaders_gl_loader_utils__WEBPACK_IMPORTED_MODULE_0__/* .assert */ .h)(loader, 'null loader');\n  (0,_loaders_gl_loader_utils__WEBPACK_IMPORTED_MODULE_0__/* .assert */ .h)(isLoaderObject(loader), 'invalid loader');\n\n  let options;\n  if (Array.isArray(loader)) {\n    options = loader[1];\n    loader = loader[0];\n    loader = {\n      ...loader,\n      options: {\n        ...loader.options,\n        ...options\n      }\n    };\n  }\n\n  if ((_loader2 = loader) !== null && _loader2 !== void 0 && _loader2.parseTextSync || (_loader3 = loader) !== null && _loader3 !== void 0 && _loader3.parseText) {\n    loader.text = true;\n  }\n  if (!loader.text) {\n    loader.binary = true;\n  }\n  return loader;\n}\n//# sourceMappingURL=normalize-loader.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNTIwMzMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBa0Q7QUFDM0M7QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDTztBQUNQO0FBQ0EsRUFBRSx5RUFBTTtBQUNSLEVBQUUseUVBQU07O0FBRVI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3Z1ZTMtd2VicGFjazUvLi9ub2RlX21vZHVsZXMvQGxvYWRlcnMuZ2wvY29yZS9kaXN0L2VzbS9saWIvbG9hZGVyLXV0aWxzL25vcm1hbGl6ZS1sb2FkZXIuanM/ZGNhNiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBhc3NlcnQgfSBmcm9tICdAbG9hZGVycy5nbC9sb2FkZXItdXRpbHMnO1xuZXhwb3J0IGZ1bmN0aW9uIGlzTG9hZGVyT2JqZWN0KGxvYWRlcikge1xuICB2YXIgX2xvYWRlcjtcbiAgaWYgKCFsb2FkZXIpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgaWYgKEFycmF5LmlzQXJyYXkobG9hZGVyKSkge1xuICAgIGxvYWRlciA9IGxvYWRlclswXTtcbiAgfVxuICBjb25zdCBoYXNFeHRlbnNpb25zID0gQXJyYXkuaXNBcnJheSgoX2xvYWRlciA9IGxvYWRlcikgPT09IG51bGwgfHwgX2xvYWRlciA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2xvYWRlci5leHRlbnNpb25zKTtcblxuICByZXR1cm4gaGFzRXh0ZW5zaW9ucztcbn1cbmV4cG9ydCBmdW5jdGlvbiBub3JtYWxpemVMb2FkZXIobG9hZGVyKSB7XG4gIHZhciBfbG9hZGVyMiwgX2xvYWRlcjM7XG4gIGFzc2VydChsb2FkZXIsICdudWxsIGxvYWRlcicpO1xuICBhc3NlcnQoaXNMb2FkZXJPYmplY3QobG9hZGVyKSwgJ2ludmFsaWQgbG9hZGVyJyk7XG5cbiAgbGV0IG9wdGlvbnM7XG4gIGlmIChBcnJheS5pc0FycmF5KGxvYWRlcikpIHtcbiAgICBvcHRpb25zID0gbG9hZGVyWzFdO1xuICAgIGxvYWRlciA9IGxvYWRlclswXTtcbiAgICBsb2FkZXIgPSB7XG4gICAgICAuLi5sb2FkZXIsXG4gICAgICBvcHRpb25zOiB7XG4gICAgICAgIC4uLmxvYWRlci5vcHRpb25zLFxuICAgICAgICAuLi5vcHRpb25zXG4gICAgICB9XG4gICAgfTtcbiAgfVxuXG4gIGlmICgoX2xvYWRlcjIgPSBsb2FkZXIpICE9PSBudWxsICYmIF9sb2FkZXIyICE9PSB2b2lkIDAgJiYgX2xvYWRlcjIucGFyc2VUZXh0U3luYyB8fCAoX2xvYWRlcjMgPSBsb2FkZXIpICE9PSBudWxsICYmIF9sb2FkZXIzICE9PSB2b2lkIDAgJiYgX2xvYWRlcjMucGFyc2VUZXh0KSB7XG4gICAgbG9hZGVyLnRleHQgPSB0cnVlO1xuICB9XG4gIGlmICghbG9hZGVyLnRleHQpIHtcbiAgICBsb2FkZXIuYmluYXJ5ID0gdHJ1ZTtcbiAgfVxuICByZXR1cm4gbG9hZGVyO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bm9ybWFsaXplLWxvYWRlci5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///52033\n")},99597:function(__unused_webpack_module,__webpack_exports__,__webpack_require__){eval("\n// EXPORTS\n__webpack_require__.d(__webpack_exports__, {\n  \"bV\": function() { return /* binding */ getFetchFunction; },\n  \"rx\": function() { return /* binding */ getGlobalLoaderState; },\n  \"GR\": function() { return /* binding */ normalizeOptions; }\n});\n\n// UNUSED EXPORTS: getGlobalLoaderOptions, setGlobalOptions\n\n// EXTERNAL MODULE: ./node_modules/@loaders.gl/core/dist/esm/javascript-utils/is-type.js\nvar is_type = __webpack_require__(36255);\n;// CONCATENATED MODULE: ./node_modules/@loaders.gl/loader-utils/dist/esm/lib/path-utils/file-aliases.js\n\n\nlet pathPrefix = '';\nconst fileAliases = {};\n\nfunction setPathPrefix(prefix) {\n  pathPrefix = prefix;\n}\n\nfunction getPathPrefix() {\n  return pathPrefix;\n}\n\nfunction addAliases(aliases) {\n  Object.assign(fileAliases, aliases);\n}\n\nfunction resolvePath(filename) {\n  for (const alias in fileAliases) {\n    if (filename.startsWith(alias)) {\n      const replacement = fileAliases[alias];\n      filename = filename.replace(alias, replacement);\n    }\n  }\n  if (!filename.startsWith('http://') && !filename.startsWith('https://')) {\n    filename = \"\".concat(pathPrefix).concat(filename);\n  }\n  return filename;\n}\n//# sourceMappingURL=file-aliases.js.map\n// EXTERNAL MODULE: ./node_modules/@loaders.gl/core/dist/esm/lib/utils/response-utils.js\nvar response_utils = __webpack_require__(17927);\n;// CONCATENATED MODULE: ./node_modules/@loaders.gl/core/dist/esm/lib/fetch/fetch-file.js\n\n\n\nasync function fetchFile(url, options) {\n  if (typeof url === 'string') {\n    url = resolvePath(url);\n    let fetchOptions = options;\n    if (options !== null && options !== void 0 && options.fetch && typeof (options === null || options === void 0 ? void 0 : options.fetch) !== 'function') {\n      fetchOptions = options.fetch;\n    }\n    return await fetch(url, fetchOptions);\n  }\n  return await (0,response_utils/* makeResponse */.L1)(url);\n}\n//# sourceMappingURL=fetch-file.js.map\n// EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/esm/defineProperty.js\nvar defineProperty = __webpack_require__(82482);\n// EXTERNAL MODULE: ./node_modules/@probe.gl/log/dist/esm/log.js + 8 modules\nvar log = __webpack_require__(56426);\n;// CONCATENATED MODULE: ./node_modules/@loaders.gl/core/dist/esm/lib/loader-utils/loggers.js\n\n\nconst probeLog = new log/* Log */.Z({\n  id: 'loaders.gl'\n});\n\nclass NullLog {\n  log() {\n    return () => {};\n  }\n  info() {\n    return () => {};\n  }\n  warn() {\n    return () => {};\n  }\n  error() {\n    return () => {};\n  }\n}\n\nclass ConsoleLog {\n  constructor() {\n    (0,defineProperty/* default */.Z)(this, \"console\", void 0);\n    this.console = console;\n  }\n\n  log() {\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n    return this.console.log.bind(this.console, ...args);\n  }\n  info() {\n    for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n      args[_key2] = arguments[_key2];\n    }\n    return this.console.info.bind(this.console, ...args);\n  }\n  warn() {\n    for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {\n      args[_key3] = arguments[_key3];\n    }\n    return this.console.warn.bind(this.console, ...args);\n  }\n  error() {\n    for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {\n      args[_key4] = arguments[_key4];\n    }\n    return this.console.error.bind(this.console, ...args);\n  }\n}\n//# sourceMappingURL=loggers.js.map\n// EXTERNAL MODULE: ./node_modules/@loaders.gl/loader-utils/dist/esm/lib/env-utils/globals.js\nvar globals = __webpack_require__(84959);\n;// CONCATENATED MODULE: ./node_modules/@loaders.gl/core/dist/esm/lib/loader-utils/option-defaults.js\n\n\nconst DEFAULT_LOADER_OPTIONS = {\n  fetch: null,\n  mimeType: undefined,\n  nothrow: false,\n  log: new ConsoleLog(),\n\n  CDN: 'https://unpkg.com/@loaders.gl',\n  worker: true,\n  maxConcurrency: 3,\n  maxMobileConcurrency: 1,\n  reuseWorkers: globals/* isBrowser */.jU,\n  _nodeWorkers: false,\n  _workerType: '',\n\n  limit: 0,\n  _limitMB: 0,\n  batchSize: 'auto',\n  batchDebounceMs: 0,\n  metadata: false,\n  transforms: []\n};\nconst REMOVED_LOADER_OPTIONS = {\n  throws: 'nothrow',\n  dataType: '(no longer used)',\n  uri: 'baseUri',\n  method: 'fetch.method',\n  headers: 'fetch.headers',\n  body: 'fetch.body',\n  mode: 'fetch.mode',\n  credentials: 'fetch.credentials',\n  cache: 'fetch.cache',\n  redirect: 'fetch.redirect',\n  referrer: 'fetch.referrer',\n  referrerPolicy: 'fetch.referrerPolicy',\n  integrity: 'fetch.integrity',\n  keepalive: 'fetch.keepalive',\n  signal: 'fetch.signal'\n};\n//# sourceMappingURL=option-defaults.js.map\n;// CONCATENATED MODULE: ./node_modules/@loaders.gl/core/dist/esm/lib/loader-utils/option-utils.js\n\n\n\n\n\nfunction getGlobalLoaderState() {\n  globalThis.loaders = globalThis.loaders || {};\n  const {\n    loaders\n  } = globalThis;\n\n  loaders._state = loaders._state || {};\n  return loaders._state;\n}\n\nconst getGlobalLoaderOptions = () => {\n  const state = getGlobalLoaderState();\n  state.globalOptions = state.globalOptions || {\n    ...DEFAULT_LOADER_OPTIONS\n  };\n  return state.globalOptions;\n};\n\nfunction setGlobalOptions(options) {\n  const state = getGlobalLoaderState();\n  const globalOptions = getGlobalLoaderOptions();\n  state.globalOptions = normalizeOptionsInternal(globalOptions, options);\n}\n\nfunction normalizeOptions(options, loader, loaders, url) {\n  loaders = loaders || [];\n  loaders = Array.isArray(loaders) ? loaders : [loaders];\n  validateOptions(options, loaders);\n  return normalizeOptionsInternal(loader, options, url);\n}\n\nfunction getFetchFunction(options, context) {\n  const globalOptions = getGlobalLoaderOptions();\n  const fetchOptions = options || globalOptions;\n\n  if (typeof fetchOptions.fetch === 'function') {\n    return fetchOptions.fetch;\n  }\n\n  if ((0,is_type/* isObject */.Kn)(fetchOptions.fetch)) {\n    return url => fetchFile(url, fetchOptions);\n  }\n\n  if (context !== null && context !== void 0 && context.fetch) {\n    return context === null || context === void 0 ? void 0 : context.fetch;\n  }\n\n  return fetchFile;\n}\n\nfunction validateOptions(options, loaders) {\n  validateOptionsObject(options, null, DEFAULT_LOADER_OPTIONS, REMOVED_LOADER_OPTIONS, loaders);\n  for (const loader of loaders) {\n    const idOptions = options && options[loader.id] || {};\n\n    const loaderOptions = loader.options && loader.options[loader.id] || {};\n    const deprecatedOptions = loader.deprecatedOptions && loader.deprecatedOptions[loader.id] || {};\n\n    validateOptionsObject(idOptions, loader.id, loaderOptions, deprecatedOptions, loaders);\n  }\n}\n\nfunction validateOptionsObject(options, id, defaultOptions, deprecatedOptions, loaders) {\n  const loaderName = id || 'Top level';\n  const prefix = id ? \"\".concat(id, \".\") : '';\n  for (const key in options) {\n    const isSubOptions = !id && (0,is_type/* isObject */.Kn)(options[key]);\n    const isBaseUriOption = key === 'baseUri' && !id;\n    const isWorkerUrlOption = key === 'workerUrl' && id;\n    if (!(key in defaultOptions) && !isBaseUriOption && !isWorkerUrlOption) {\n      if (key in deprecatedOptions) {\n        probeLog.warn(\"\".concat(loaderName, \" loader option '\").concat(prefix).concat(key, \"' no longer supported, use '\").concat(deprecatedOptions[key], \"'\"))();\n      } else if (!isSubOptions) {\n        const suggestion = findSimilarOption(key, loaders);\n        probeLog.warn(\"\".concat(loaderName, \" loader option '\").concat(prefix).concat(key, \"' not recognized. \").concat(suggestion))();\n      }\n    }\n  }\n}\nfunction findSimilarOption(optionKey, loaders) {\n  const lowerCaseOptionKey = optionKey.toLowerCase();\n  let bestSuggestion = '';\n  for (const loader of loaders) {\n    for (const key in loader.options) {\n      if (optionKey === key) {\n        return \"Did you mean '\".concat(loader.id, \".\").concat(key, \"'?\");\n      }\n      const lowerCaseKey = key.toLowerCase();\n      const isPartialMatch = lowerCaseOptionKey.startsWith(lowerCaseKey) || lowerCaseKey.startsWith(lowerCaseOptionKey);\n      if (isPartialMatch) {\n        bestSuggestion = bestSuggestion || \"Did you mean '\".concat(loader.id, \".\").concat(key, \"'?\");\n      }\n    }\n  }\n  return bestSuggestion;\n}\nfunction normalizeOptionsInternal(loader, options, url) {\n  const loaderDefaultOptions = loader.options || {};\n  const mergedOptions = {\n    ...loaderDefaultOptions\n  };\n  addUrlOptions(mergedOptions, url);\n\n  if (mergedOptions.log === null) {\n    mergedOptions.log = new NullLog();\n  }\n  mergeNestedFields(mergedOptions, getGlobalLoaderOptions());\n  mergeNestedFields(mergedOptions, options);\n  return mergedOptions;\n}\n\nfunction mergeNestedFields(mergedOptions, options) {\n  for (const key in options) {\n    if (key in options) {\n      const value = options[key];\n      if ((0,is_type/* isPureObject */.Ss)(value) && (0,is_type/* isPureObject */.Ss)(mergedOptions[key])) {\n        mergedOptions[key] = {\n          ...mergedOptions[key],\n          ...options[key]\n        };\n      } else {\n        mergedOptions[key] = options[key];\n      }\n    }\n  }\n}\n\nfunction addUrlOptions(options, url) {\n  if (url && !('baseUri' in options)) {\n    options.baseUri = url;\n  }\n}\n//# sourceMappingURL=option-utils.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiOTk1OTcuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7O0FBRUE7QUFDQTs7QUFFTztBQUNQO0FBQ0E7O0FBRU87QUFDUDtBQUNBOztBQUVPO0FBQ1A7QUFDQTs7QUFFTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Qzs7OztBQzdCdUQ7QUFDQTs7QUFFaEQ7QUFDUDtBQUNBLFVBQVUsV0FBVztBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLHVDQUFZO0FBQzNCO0FBQ0Esc0M7Ozs7OztBQ2R3RTtBQUNwQztBQUM3QixxQkFBcUIsY0FBRztBQUMvQjtBQUNBLENBQUM7O0FBRU07QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFTztBQUNQO0FBQ0EsSUFBSSxpQ0FBZTtBQUNuQjtBQUNBOztBQUVBO0FBQ0Esd0VBQXdFLGFBQWE7QUFDckY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJFQUEyRSxlQUFlO0FBQzFGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyRUFBMkUsZUFBZTtBQUMxRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkVBQTJFLGVBQWU7QUFDMUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DOzs7O0FDcERxRDtBQUNkO0FBQ2hDO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsV0FBVyxVQUFVOztBQUVyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQix5QkFBUztBQUN6QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDOztBQ3hDd0U7QUFDeEI7QUFDRjtBQUNxQzs7QUFFNUU7QUFDUDtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTs7QUFFTztBQUNQO0FBQ0E7QUFDQSxPQUFPLHNCQUFzQjtBQUM3QjtBQUNBO0FBQ0E7O0FBRU87QUFDUDtBQUNBO0FBQ0E7QUFDQTs7QUFFTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxNQUFNLDRCQUFRO0FBQ2Qsa0JBQWtCLFNBQVM7QUFDM0I7O0FBRUE7QUFDQTtBQUNBOztBQUVBLFNBQVMsU0FBUztBQUNsQjs7QUFFQTtBQUNBLHVDQUF1QyxzQkFBc0IsRUFBRSxzQkFBc0I7QUFDckY7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyw0QkFBUTtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsYUFBYTtBQUNyQixRQUFRO0FBQ1I7QUFDQSxRQUFRLGFBQWE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsNEJBQTRCLE9BQU87QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsZ0NBQVksV0FBVyxnQ0FBWTtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3Z1ZTMtd2VicGFjazUvLi9ub2RlX21vZHVsZXMvQGxvYWRlcnMuZ2wvbG9hZGVyLXV0aWxzL2Rpc3QvZXNtL2xpYi9wYXRoLXV0aWxzL2ZpbGUtYWxpYXNlcy5qcz83NzY5Iiwid2VicGFjazovL3Z1ZTMtd2VicGFjazUvLi9ub2RlX21vZHVsZXMvQGxvYWRlcnMuZ2wvY29yZS9kaXN0L2VzbS9saWIvZmV0Y2gvZmV0Y2gtZmlsZS5qcz83Y2Q4Iiwid2VicGFjazovL3Z1ZTMtd2VicGFjazUvLi9ub2RlX21vZHVsZXMvQGxvYWRlcnMuZ2wvY29yZS9kaXN0L2VzbS9saWIvbG9hZGVyLXV0aWxzL2xvZ2dlcnMuanM/ZDgxOSIsIndlYnBhY2s6Ly92dWUzLXdlYnBhY2s1Ly4vbm9kZV9tb2R1bGVzL0Bsb2FkZXJzLmdsL2NvcmUvZGlzdC9lc20vbGliL2xvYWRlci11dGlscy9vcHRpb24tZGVmYXVsdHMuanM/MTVkMiIsIndlYnBhY2s6Ly92dWUzLXdlYnBhY2s1Ly4vbm9kZV9tb2R1bGVzL0Bsb2FkZXJzLmdsL2NvcmUvZGlzdC9lc20vbGliL2xvYWRlci11dGlscy9vcHRpb24tdXRpbHMuanM/MGNiMyJdLCJzb3VyY2VzQ29udGVudCI6WyJcblxubGV0IHBhdGhQcmVmaXggPSAnJztcbmNvbnN0IGZpbGVBbGlhc2VzID0ge307XG5cbmV4cG9ydCBmdW5jdGlvbiBzZXRQYXRoUHJlZml4KHByZWZpeCkge1xuICBwYXRoUHJlZml4ID0gcHJlZml4O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0UGF0aFByZWZpeCgpIHtcbiAgcmV0dXJuIHBhdGhQcmVmaXg7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBhZGRBbGlhc2VzKGFsaWFzZXMpIHtcbiAgT2JqZWN0LmFzc2lnbihmaWxlQWxpYXNlcywgYWxpYXNlcyk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiByZXNvbHZlUGF0aChmaWxlbmFtZSkge1xuICBmb3IgKGNvbnN0IGFsaWFzIGluIGZpbGVBbGlhc2VzKSB7XG4gICAgaWYgKGZpbGVuYW1lLnN0YXJ0c1dpdGgoYWxpYXMpKSB7XG4gICAgICBjb25zdCByZXBsYWNlbWVudCA9IGZpbGVBbGlhc2VzW2FsaWFzXTtcbiAgICAgIGZpbGVuYW1lID0gZmlsZW5hbWUucmVwbGFjZShhbGlhcywgcmVwbGFjZW1lbnQpO1xuICAgIH1cbiAgfVxuICBpZiAoIWZpbGVuYW1lLnN0YXJ0c1dpdGgoJ2h0dHA6Ly8nKSAmJiAhZmlsZW5hbWUuc3RhcnRzV2l0aCgnaHR0cHM6Ly8nKSkge1xuICAgIGZpbGVuYW1lID0gXCJcIi5jb25jYXQocGF0aFByZWZpeCkuY29uY2F0KGZpbGVuYW1lKTtcbiAgfVxuICByZXR1cm4gZmlsZW5hbWU7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1maWxlLWFsaWFzZXMuanMubWFwIiwiaW1wb3J0IHsgcmVzb2x2ZVBhdGggfSBmcm9tICdAbG9hZGVycy5nbC9sb2FkZXItdXRpbHMnO1xuaW1wb3J0IHsgbWFrZVJlc3BvbnNlIH0gZnJvbSAnLi4vdXRpbHMvcmVzcG9uc2UtdXRpbHMnO1xuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZmV0Y2hGaWxlKHVybCwgb3B0aW9ucykge1xuICBpZiAodHlwZW9mIHVybCA9PT0gJ3N0cmluZycpIHtcbiAgICB1cmwgPSByZXNvbHZlUGF0aCh1cmwpO1xuICAgIGxldCBmZXRjaE9wdGlvbnMgPSBvcHRpb25zO1xuICAgIGlmIChvcHRpb25zICE9PSBudWxsICYmIG9wdGlvbnMgIT09IHZvaWQgMCAmJiBvcHRpb25zLmZldGNoICYmIHR5cGVvZiAob3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLmZldGNoKSAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgZmV0Y2hPcHRpb25zID0gb3B0aW9ucy5mZXRjaDtcbiAgICB9XG4gICAgcmV0dXJuIGF3YWl0IGZldGNoKHVybCwgZmV0Y2hPcHRpb25zKTtcbiAgfVxuICByZXR1cm4gYXdhaXQgbWFrZVJlc3BvbnNlKHVybCk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1mZXRjaC1maWxlLmpzLm1hcCIsImltcG9ydCBfZGVmaW5lUHJvcGVydHkgZnJvbSBcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL2RlZmluZVByb3BlcnR5XCI7XG5pbXBvcnQgeyBMb2cgfSBmcm9tICdAcHJvYmUuZ2wvbG9nJztcbmV4cG9ydCBjb25zdCBwcm9iZUxvZyA9IG5ldyBMb2coe1xuICBpZDogJ2xvYWRlcnMuZ2wnXG59KTtcblxuZXhwb3J0IGNsYXNzIE51bGxMb2cge1xuICBsb2coKSB7XG4gICAgcmV0dXJuICgpID0+IHt9O1xuICB9XG4gIGluZm8oKSB7XG4gICAgcmV0dXJuICgpID0+IHt9O1xuICB9XG4gIHdhcm4oKSB7XG4gICAgcmV0dXJuICgpID0+IHt9O1xuICB9XG4gIGVycm9yKCkge1xuICAgIHJldHVybiAoKSA9PiB7fTtcbiAgfVxufVxuXG5leHBvcnQgY2xhc3MgQ29uc29sZUxvZyB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImNvbnNvbGVcIiwgdm9pZCAwKTtcbiAgICB0aGlzLmNvbnNvbGUgPSBjb25zb2xlO1xuICB9XG5cbiAgbG9nKCkge1xuICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgICAgYXJnc1tfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuY29uc29sZS5sb2cuYmluZCh0aGlzLmNvbnNvbGUsIC4uLmFyZ3MpO1xuICB9XG4gIGluZm8oKSB7XG4gICAgZm9yICh2YXIgX2xlbjIgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4yKSwgX2tleTIgPSAwOyBfa2V5MiA8IF9sZW4yOyBfa2V5MisrKSB7XG4gICAgICBhcmdzW19rZXkyXSA9IGFyZ3VtZW50c1tfa2V5Ml07XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmNvbnNvbGUuaW5mby5iaW5kKHRoaXMuY29uc29sZSwgLi4uYXJncyk7XG4gIH1cbiAgd2FybigpIHtcbiAgICBmb3IgKHZhciBfbGVuMyA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbjMpLCBfa2V5MyA9IDA7IF9rZXkzIDwgX2xlbjM7IF9rZXkzKyspIHtcbiAgICAgIGFyZ3NbX2tleTNdID0gYXJndW1lbnRzW19rZXkzXTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuY29uc29sZS53YXJuLmJpbmQodGhpcy5jb25zb2xlLCAuLi5hcmdzKTtcbiAgfVxuICBlcnJvcigpIHtcbiAgICBmb3IgKHZhciBfbGVuNCA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbjQpLCBfa2V5NCA9IDA7IF9rZXk0IDwgX2xlbjQ7IF9rZXk0KyspIHtcbiAgICAgIGFyZ3NbX2tleTRdID0gYXJndW1lbnRzW19rZXk0XTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuY29uc29sZS5lcnJvci5iaW5kKHRoaXMuY29uc29sZSwgLi4uYXJncyk7XG4gIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWxvZ2dlcnMuanMubWFwIiwiaW1wb3J0IHsgaXNCcm93c2VyIH0gZnJvbSAnQGxvYWRlcnMuZ2wvbG9hZGVyLXV0aWxzJztcbmltcG9ydCB7IENvbnNvbGVMb2cgfSBmcm9tICcuL2xvZ2dlcnMnO1xuZXhwb3J0IGNvbnN0IERFRkFVTFRfTE9BREVSX09QVElPTlMgPSB7XG4gIGZldGNoOiBudWxsLFxuICBtaW1lVHlwZTogdW5kZWZpbmVkLFxuICBub3Rocm93OiBmYWxzZSxcbiAgbG9nOiBuZXcgQ29uc29sZUxvZygpLFxuXG4gIENETjogJ2h0dHBzOi8vdW5wa2cuY29tL0Bsb2FkZXJzLmdsJyxcbiAgd29ya2VyOiB0cnVlLFxuICBtYXhDb25jdXJyZW5jeTogMyxcbiAgbWF4TW9iaWxlQ29uY3VycmVuY3k6IDEsXG4gIHJldXNlV29ya2VyczogaXNCcm93c2VyLFxuICBfbm9kZVdvcmtlcnM6IGZhbHNlLFxuICBfd29ya2VyVHlwZTogJycsXG5cbiAgbGltaXQ6IDAsXG4gIF9saW1pdE1COiAwLFxuICBiYXRjaFNpemU6ICdhdXRvJyxcbiAgYmF0Y2hEZWJvdW5jZU1zOiAwLFxuICBtZXRhZGF0YTogZmFsc2UsXG4gIHRyYW5zZm9ybXM6IFtdXG59O1xuZXhwb3J0IGNvbnN0IFJFTU9WRURfTE9BREVSX09QVElPTlMgPSB7XG4gIHRocm93czogJ25vdGhyb3cnLFxuICBkYXRhVHlwZTogJyhubyBsb25nZXIgdXNlZCknLFxuICB1cmk6ICdiYXNlVXJpJyxcbiAgbWV0aG9kOiAnZmV0Y2gubWV0aG9kJyxcbiAgaGVhZGVyczogJ2ZldGNoLmhlYWRlcnMnLFxuICBib2R5OiAnZmV0Y2guYm9keScsXG4gIG1vZGU6ICdmZXRjaC5tb2RlJyxcbiAgY3JlZGVudGlhbHM6ICdmZXRjaC5jcmVkZW50aWFscycsXG4gIGNhY2hlOiAnZmV0Y2guY2FjaGUnLFxuICByZWRpcmVjdDogJ2ZldGNoLnJlZGlyZWN0JyxcbiAgcmVmZXJyZXI6ICdmZXRjaC5yZWZlcnJlcicsXG4gIHJlZmVycmVyUG9saWN5OiAnZmV0Y2gucmVmZXJyZXJQb2xpY3knLFxuICBpbnRlZ3JpdHk6ICdmZXRjaC5pbnRlZ3JpdHknLFxuICBrZWVwYWxpdmU6ICdmZXRjaC5rZWVwYWxpdmUnLFxuICBzaWduYWw6ICdmZXRjaC5zaWduYWwnXG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9b3B0aW9uLWRlZmF1bHRzLmpzLm1hcCIsImltcG9ydCB7IGlzUHVyZU9iamVjdCwgaXNPYmplY3QgfSBmcm9tICcuLi8uLi9qYXZhc2NyaXB0LXV0aWxzL2lzLXR5cGUnO1xuaW1wb3J0IHsgZmV0Y2hGaWxlIH0gZnJvbSAnLi4vZmV0Y2gvZmV0Y2gtZmlsZSc7XG5pbXBvcnQgeyBwcm9iZUxvZywgTnVsbExvZyB9IGZyb20gJy4vbG9nZ2Vycyc7XG5pbXBvcnQgeyBERUZBVUxUX0xPQURFUl9PUFRJT05TLCBSRU1PVkVEX0xPQURFUl9PUFRJT05TIH0gZnJvbSAnLi9vcHRpb24tZGVmYXVsdHMnO1xuXG5leHBvcnQgZnVuY3Rpb24gZ2V0R2xvYmFsTG9hZGVyU3RhdGUoKSB7XG4gIGdsb2JhbFRoaXMubG9hZGVycyA9IGdsb2JhbFRoaXMubG9hZGVycyB8fCB7fTtcbiAgY29uc3Qge1xuICAgIGxvYWRlcnNcbiAgfSA9IGdsb2JhbFRoaXM7XG5cbiAgbG9hZGVycy5fc3RhdGUgPSBsb2FkZXJzLl9zdGF0ZSB8fCB7fTtcbiAgcmV0dXJuIGxvYWRlcnMuX3N0YXRlO1xufVxuXG5leHBvcnQgY29uc3QgZ2V0R2xvYmFsTG9hZGVyT3B0aW9ucyA9ICgpID0+IHtcbiAgY29uc3Qgc3RhdGUgPSBnZXRHbG9iYWxMb2FkZXJTdGF0ZSgpO1xuICBzdGF0ZS5nbG9iYWxPcHRpb25zID0gc3RhdGUuZ2xvYmFsT3B0aW9ucyB8fCB7XG4gICAgLi4uREVGQVVMVF9MT0FERVJfT1BUSU9OU1xuICB9O1xuICByZXR1cm4gc3RhdGUuZ2xvYmFsT3B0aW9ucztcbn07XG5cbmV4cG9ydCBmdW5jdGlvbiBzZXRHbG9iYWxPcHRpb25zKG9wdGlvbnMpIHtcbiAgY29uc3Qgc3RhdGUgPSBnZXRHbG9iYWxMb2FkZXJTdGF0ZSgpO1xuICBjb25zdCBnbG9iYWxPcHRpb25zID0gZ2V0R2xvYmFsTG9hZGVyT3B0aW9ucygpO1xuICBzdGF0ZS5nbG9iYWxPcHRpb25zID0gbm9ybWFsaXplT3B0aW9uc0ludGVybmFsKGdsb2JhbE9wdGlvbnMsIG9wdGlvbnMpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gbm9ybWFsaXplT3B0aW9ucyhvcHRpb25zLCBsb2FkZXIsIGxvYWRlcnMsIHVybCkge1xuICBsb2FkZXJzID0gbG9hZGVycyB8fCBbXTtcbiAgbG9hZGVycyA9IEFycmF5LmlzQXJyYXkobG9hZGVycykgPyBsb2FkZXJzIDogW2xvYWRlcnNdO1xuICB2YWxpZGF0ZU9wdGlvbnMob3B0aW9ucywgbG9hZGVycyk7XG4gIHJldHVybiBub3JtYWxpemVPcHRpb25zSW50ZXJuYWwobG9hZGVyLCBvcHRpb25zLCB1cmwpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0RmV0Y2hGdW5jdGlvbihvcHRpb25zLCBjb250ZXh0KSB7XG4gIGNvbnN0IGdsb2JhbE9wdGlvbnMgPSBnZXRHbG9iYWxMb2FkZXJPcHRpb25zKCk7XG4gIGNvbnN0IGZldGNoT3B0aW9ucyA9IG9wdGlvbnMgfHwgZ2xvYmFsT3B0aW9ucztcblxuICBpZiAodHlwZW9mIGZldGNoT3B0aW9ucy5mZXRjaCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiBmZXRjaE9wdGlvbnMuZmV0Y2g7XG4gIH1cblxuICBpZiAoaXNPYmplY3QoZmV0Y2hPcHRpb25zLmZldGNoKSkge1xuICAgIHJldHVybiB1cmwgPT4gZmV0Y2hGaWxlKHVybCwgZmV0Y2hPcHRpb25zKTtcbiAgfVxuXG4gIGlmIChjb250ZXh0ICE9PSBudWxsICYmIGNvbnRleHQgIT09IHZvaWQgMCAmJiBjb250ZXh0LmZldGNoKSB7XG4gICAgcmV0dXJuIGNvbnRleHQgPT09IG51bGwgfHwgY29udGV4dCA9PT0gdm9pZCAwID8gdm9pZCAwIDogY29udGV4dC5mZXRjaDtcbiAgfVxuXG4gIHJldHVybiBmZXRjaEZpbGU7XG59XG5cbmZ1bmN0aW9uIHZhbGlkYXRlT3B0aW9ucyhvcHRpb25zLCBsb2FkZXJzKSB7XG4gIHZhbGlkYXRlT3B0aW9uc09iamVjdChvcHRpb25zLCBudWxsLCBERUZBVUxUX0xPQURFUl9PUFRJT05TLCBSRU1PVkVEX0xPQURFUl9PUFRJT05TLCBsb2FkZXJzKTtcbiAgZm9yIChjb25zdCBsb2FkZXIgb2YgbG9hZGVycykge1xuICAgIGNvbnN0IGlkT3B0aW9ucyA9IG9wdGlvbnMgJiYgb3B0aW9uc1tsb2FkZXIuaWRdIHx8IHt9O1xuXG4gICAgY29uc3QgbG9hZGVyT3B0aW9ucyA9IGxvYWRlci5vcHRpb25zICYmIGxvYWRlci5vcHRpb25zW2xvYWRlci5pZF0gfHwge307XG4gICAgY29uc3QgZGVwcmVjYXRlZE9wdGlvbnMgPSBsb2FkZXIuZGVwcmVjYXRlZE9wdGlvbnMgJiYgbG9hZGVyLmRlcHJlY2F0ZWRPcHRpb25zW2xvYWRlci5pZF0gfHwge307XG5cbiAgICB2YWxpZGF0ZU9wdGlvbnNPYmplY3QoaWRPcHRpb25zLCBsb2FkZXIuaWQsIGxvYWRlck9wdGlvbnMsIGRlcHJlY2F0ZWRPcHRpb25zLCBsb2FkZXJzKTtcbiAgfVxufVxuXG5mdW5jdGlvbiB2YWxpZGF0ZU9wdGlvbnNPYmplY3Qob3B0aW9ucywgaWQsIGRlZmF1bHRPcHRpb25zLCBkZXByZWNhdGVkT3B0aW9ucywgbG9hZGVycykge1xuICBjb25zdCBsb2FkZXJOYW1lID0gaWQgfHwgJ1RvcCBsZXZlbCc7XG4gIGNvbnN0IHByZWZpeCA9IGlkID8gXCJcIi5jb25jYXQoaWQsIFwiLlwiKSA6ICcnO1xuICBmb3IgKGNvbnN0IGtleSBpbiBvcHRpb25zKSB7XG4gICAgY29uc3QgaXNTdWJPcHRpb25zID0gIWlkICYmIGlzT2JqZWN0KG9wdGlvbnNba2V5XSk7XG4gICAgY29uc3QgaXNCYXNlVXJpT3B0aW9uID0ga2V5ID09PSAnYmFzZVVyaScgJiYgIWlkO1xuICAgIGNvbnN0IGlzV29ya2VyVXJsT3B0aW9uID0ga2V5ID09PSAnd29ya2VyVXJsJyAmJiBpZDtcbiAgICBpZiAoIShrZXkgaW4gZGVmYXVsdE9wdGlvbnMpICYmICFpc0Jhc2VVcmlPcHRpb24gJiYgIWlzV29ya2VyVXJsT3B0aW9uKSB7XG4gICAgICBpZiAoa2V5IGluIGRlcHJlY2F0ZWRPcHRpb25zKSB7XG4gICAgICAgIHByb2JlTG9nLndhcm4oXCJcIi5jb25jYXQobG9hZGVyTmFtZSwgXCIgbG9hZGVyIG9wdGlvbiAnXCIpLmNvbmNhdChwcmVmaXgpLmNvbmNhdChrZXksIFwiJyBubyBsb25nZXIgc3VwcG9ydGVkLCB1c2UgJ1wiKS5jb25jYXQoZGVwcmVjYXRlZE9wdGlvbnNba2V5XSwgXCInXCIpKSgpO1xuICAgICAgfSBlbHNlIGlmICghaXNTdWJPcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IHN1Z2dlc3Rpb24gPSBmaW5kU2ltaWxhck9wdGlvbihrZXksIGxvYWRlcnMpO1xuICAgICAgICBwcm9iZUxvZy53YXJuKFwiXCIuY29uY2F0KGxvYWRlck5hbWUsIFwiIGxvYWRlciBvcHRpb24gJ1wiKS5jb25jYXQocHJlZml4KS5jb25jYXQoa2V5LCBcIicgbm90IHJlY29nbml6ZWQuIFwiKS5jb25jYXQoc3VnZ2VzdGlvbikpKCk7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBmaW5kU2ltaWxhck9wdGlvbihvcHRpb25LZXksIGxvYWRlcnMpIHtcbiAgY29uc3QgbG93ZXJDYXNlT3B0aW9uS2V5ID0gb3B0aW9uS2V5LnRvTG93ZXJDYXNlKCk7XG4gIGxldCBiZXN0U3VnZ2VzdGlvbiA9ICcnO1xuICBmb3IgKGNvbnN0IGxvYWRlciBvZiBsb2FkZXJzKSB7XG4gICAgZm9yIChjb25zdCBrZXkgaW4gbG9hZGVyLm9wdGlvbnMpIHtcbiAgICAgIGlmIChvcHRpb25LZXkgPT09IGtleSkge1xuICAgICAgICByZXR1cm4gXCJEaWQgeW91IG1lYW4gJ1wiLmNvbmNhdChsb2FkZXIuaWQsIFwiLlwiKS5jb25jYXQoa2V5LCBcIic/XCIpO1xuICAgICAgfVxuICAgICAgY29uc3QgbG93ZXJDYXNlS2V5ID0ga2V5LnRvTG93ZXJDYXNlKCk7XG4gICAgICBjb25zdCBpc1BhcnRpYWxNYXRjaCA9IGxvd2VyQ2FzZU9wdGlvbktleS5zdGFydHNXaXRoKGxvd2VyQ2FzZUtleSkgfHwgbG93ZXJDYXNlS2V5LnN0YXJ0c1dpdGgobG93ZXJDYXNlT3B0aW9uS2V5KTtcbiAgICAgIGlmIChpc1BhcnRpYWxNYXRjaCkge1xuICAgICAgICBiZXN0U3VnZ2VzdGlvbiA9IGJlc3RTdWdnZXN0aW9uIHx8IFwiRGlkIHlvdSBtZWFuICdcIi5jb25jYXQobG9hZGVyLmlkLCBcIi5cIikuY29uY2F0KGtleSwgXCInP1wiKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIGJlc3RTdWdnZXN0aW9uO1xufVxuZnVuY3Rpb24gbm9ybWFsaXplT3B0aW9uc0ludGVybmFsKGxvYWRlciwgb3B0aW9ucywgdXJsKSB7XG4gIGNvbnN0IGxvYWRlckRlZmF1bHRPcHRpb25zID0gbG9hZGVyLm9wdGlvbnMgfHwge307XG4gIGNvbnN0IG1lcmdlZE9wdGlvbnMgPSB7XG4gICAgLi4ubG9hZGVyRGVmYXVsdE9wdGlvbnNcbiAgfTtcbiAgYWRkVXJsT3B0aW9ucyhtZXJnZWRPcHRpb25zLCB1cmwpO1xuXG4gIGlmIChtZXJnZWRPcHRpb25zLmxvZyA9PT0gbnVsbCkge1xuICAgIG1lcmdlZE9wdGlvbnMubG9nID0gbmV3IE51bGxMb2coKTtcbiAgfVxuICBtZXJnZU5lc3RlZEZpZWxkcyhtZXJnZWRPcHRpb25zLCBnZXRHbG9iYWxMb2FkZXJPcHRpb25zKCkpO1xuICBtZXJnZU5lc3RlZEZpZWxkcyhtZXJnZWRPcHRpb25zLCBvcHRpb25zKTtcbiAgcmV0dXJuIG1lcmdlZE9wdGlvbnM7XG59XG5cbmZ1bmN0aW9uIG1lcmdlTmVzdGVkRmllbGRzKG1lcmdlZE9wdGlvbnMsIG9wdGlvbnMpIHtcbiAgZm9yIChjb25zdCBrZXkgaW4gb3B0aW9ucykge1xuICAgIGlmIChrZXkgaW4gb3B0aW9ucykge1xuICAgICAgY29uc3QgdmFsdWUgPSBvcHRpb25zW2tleV07XG4gICAgICBpZiAoaXNQdXJlT2JqZWN0KHZhbHVlKSAmJiBpc1B1cmVPYmplY3QobWVyZ2VkT3B0aW9uc1trZXldKSkge1xuICAgICAgICBtZXJnZWRPcHRpb25zW2tleV0gPSB7XG4gICAgICAgICAgLi4ubWVyZ2VkT3B0aW9uc1trZXldLFxuICAgICAgICAgIC4uLm9wdGlvbnNba2V5XVxuICAgICAgICB9O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbWVyZ2VkT3B0aW9uc1trZXldID0gb3B0aW9uc1trZXldO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBhZGRVcmxPcHRpb25zKG9wdGlvbnMsIHVybCkge1xuICBpZiAodXJsICYmICEoJ2Jhc2VVcmknIGluIG9wdGlvbnMpKSB7XG4gICAgb3B0aW9ucy5iYXNlVXJpID0gdXJsO1xuICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1vcHRpb24tdXRpbHMuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///99597\n")},74642:function(__unused_webpack_module,__webpack_exports__,__webpack_require__){eval("\n// EXPORTS\n__webpack_require__.d(__webpack_exports__, {\n  \"C\": function() { return /* binding */ getResourceContentLength; },\n  \"l\": function() { return /* binding */ getResourceUrlAndType; }\n});\n\n// EXTERNAL MODULE: ./node_modules/@loaders.gl/core/dist/esm/javascript-utils/is-type.js\nvar is_type = __webpack_require__(36255);\n;// CONCATENATED MODULE: ./node_modules/@loaders.gl/core/dist/esm/lib/utils/mime-type-utils.js\n\n\nconst DATA_URL_PATTERN = /^data:([-\\w.]+\\/[-\\w.+]+)(;|,)/;\nconst MIME_TYPE_PATTERN = /^([-\\w.]+\\/[-\\w.+]+)/;\n\nfunction parseMIMEType(mimeString) {\n  const matches = MIME_TYPE_PATTERN.exec(mimeString);\n  if (matches) {\n    return matches[1];\n  }\n  return mimeString;\n}\n\nfunction parseMIMETypeFromURL(url) {\n  const matches = DATA_URL_PATTERN.exec(url);\n  if (matches) {\n    return matches[1];\n  }\n  return '';\n}\n//# sourceMappingURL=mime-type-utils.js.map\n;// CONCATENATED MODULE: ./node_modules/@loaders.gl/core/dist/esm/lib/utils/resource-utils.js\n\n\nconst QUERY_STRING_PATTERN = /\\?.*/;\n\nfunction getResourceUrlAndType(resource) {\n  if ((0,is_type/* isResponse */.Ew)(resource)) {\n    const url = stripQueryString(resource.url || '');\n    const contentTypeHeader = resource.headers.get('content-type') || '';\n    return {\n      url,\n      type: parseMIMEType(contentTypeHeader) || parseMIMETypeFromURL(url)\n    };\n  }\n\n  if ((0,is_type/* isBlob */.Lj)(resource)) {\n    return {\n      url: stripQueryString(resource.name || ''),\n      type: resource.type || ''\n    };\n  }\n  if (typeof resource === 'string') {\n    return {\n      url: stripQueryString(resource),\n      type: parseMIMETypeFromURL(resource)\n    };\n  }\n\n  return {\n    url: '',\n    type: ''\n  };\n}\n\nfunction getResourceContentLength(resource) {\n  if ((0,is_type/* isResponse */.Ew)(resource)) {\n    return resource.headers['content-length'] || -1;\n  }\n  if ((0,is_type/* isBlob */.Lj)(resource)) {\n    return resource.size;\n  }\n  if (typeof resource === 'string') {\n    return resource.length;\n  }\n  if (resource instanceof ArrayBuffer) {\n    return resource.byteLength;\n  }\n  if (ArrayBuffer.isView(resource)) {\n    return resource.byteLength;\n  }\n  return -1;\n}\nfunction stripQueryString(url) {\n  return url.replace(QUERY_STRING_PATTERN, '');\n}\n//# sourceMappingURL=resource-utils.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNzQ2NDIuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7O0FBRUEscURBQXFEO0FBQ3JEOztBQUVPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkM7O0FDcEJvRTtBQUNJO0FBQ3hFOztBQUVPO0FBQ1AsTUFBTSw4QkFBVTtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksYUFBYSx1QkFBdUIsb0JBQW9CO0FBQ3BFO0FBQ0E7O0FBRUEsTUFBTSwwQkFBTTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLG9CQUFvQjtBQUNoQztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRU87QUFDUCxNQUFNLDhCQUFVO0FBQ2hCO0FBQ0E7QUFDQSxNQUFNLDBCQUFNO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3Z1ZTMtd2VicGFjazUvLi9ub2RlX21vZHVsZXMvQGxvYWRlcnMuZ2wvY29yZS9kaXN0L2VzbS9saWIvdXRpbHMvbWltZS10eXBlLXV0aWxzLmpzP2E1ZTgiLCJ3ZWJwYWNrOi8vdnVlMy13ZWJwYWNrNS8uL25vZGVfbW9kdWxlcy9AbG9hZGVycy5nbC9jb3JlL2Rpc3QvZXNtL2xpYi91dGlscy9yZXNvdXJjZS11dGlscy5qcz9kZDBhIl0sInNvdXJjZXNDb250ZW50IjpbIlxuXG5jb25zdCBEQVRBX1VSTF9QQVRURVJOID0gL15kYXRhOihbLVxcdy5dK1xcL1stXFx3LitdKykoO3wsKS87XG5jb25zdCBNSU1FX1RZUEVfUEFUVEVSTiA9IC9eKFstXFx3Ll0rXFwvWy1cXHcuK10rKS87XG5cbmV4cG9ydCBmdW5jdGlvbiBwYXJzZU1JTUVUeXBlKG1pbWVTdHJpbmcpIHtcbiAgY29uc3QgbWF0Y2hlcyA9IE1JTUVfVFlQRV9QQVRURVJOLmV4ZWMobWltZVN0cmluZyk7XG4gIGlmIChtYXRjaGVzKSB7XG4gICAgcmV0dXJuIG1hdGNoZXNbMV07XG4gIH1cbiAgcmV0dXJuIG1pbWVTdHJpbmc7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBwYXJzZU1JTUVUeXBlRnJvbVVSTCh1cmwpIHtcbiAgY29uc3QgbWF0Y2hlcyA9IERBVEFfVVJMX1BBVFRFUk4uZXhlYyh1cmwpO1xuICBpZiAobWF0Y2hlcykge1xuICAgIHJldHVybiBtYXRjaGVzWzFdO1xuICB9XG4gIHJldHVybiAnJztcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW1pbWUtdHlwZS11dGlscy5qcy5tYXAiLCJpbXBvcnQgeyBpc1Jlc3BvbnNlLCBpc0Jsb2IgfSBmcm9tICcuLi8uLi9qYXZhc2NyaXB0LXV0aWxzL2lzLXR5cGUnO1xuaW1wb3J0IHsgcGFyc2VNSU1FVHlwZSwgcGFyc2VNSU1FVHlwZUZyb21VUkwgfSBmcm9tICcuL21pbWUtdHlwZS11dGlscyc7XG5jb25zdCBRVUVSWV9TVFJJTkdfUEFUVEVSTiA9IC9cXD8uKi87XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRSZXNvdXJjZVVybEFuZFR5cGUocmVzb3VyY2UpIHtcbiAgaWYgKGlzUmVzcG9uc2UocmVzb3VyY2UpKSB7XG4gICAgY29uc3QgdXJsID0gc3RyaXBRdWVyeVN0cmluZyhyZXNvdXJjZS51cmwgfHwgJycpO1xuICAgIGNvbnN0IGNvbnRlbnRUeXBlSGVhZGVyID0gcmVzb3VyY2UuaGVhZGVycy5nZXQoJ2NvbnRlbnQtdHlwZScpIHx8ICcnO1xuICAgIHJldHVybiB7XG4gICAgICB1cmwsXG4gICAgICB0eXBlOiBwYXJzZU1JTUVUeXBlKGNvbnRlbnRUeXBlSGVhZGVyKSB8fCBwYXJzZU1JTUVUeXBlRnJvbVVSTCh1cmwpXG4gICAgfTtcbiAgfVxuXG4gIGlmIChpc0Jsb2IocmVzb3VyY2UpKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHVybDogc3RyaXBRdWVyeVN0cmluZyhyZXNvdXJjZS5uYW1lIHx8ICcnKSxcbiAgICAgIHR5cGU6IHJlc291cmNlLnR5cGUgfHwgJydcbiAgICB9O1xuICB9XG4gIGlmICh0eXBlb2YgcmVzb3VyY2UgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHVybDogc3RyaXBRdWVyeVN0cmluZyhyZXNvdXJjZSksXG4gICAgICB0eXBlOiBwYXJzZU1JTUVUeXBlRnJvbVVSTChyZXNvdXJjZSlcbiAgICB9O1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICB1cmw6ICcnLFxuICAgIHR5cGU6ICcnXG4gIH07XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRSZXNvdXJjZUNvbnRlbnRMZW5ndGgocmVzb3VyY2UpIHtcbiAgaWYgKGlzUmVzcG9uc2UocmVzb3VyY2UpKSB7XG4gICAgcmV0dXJuIHJlc291cmNlLmhlYWRlcnNbJ2NvbnRlbnQtbGVuZ3RoJ10gfHwgLTE7XG4gIH1cbiAgaWYgKGlzQmxvYihyZXNvdXJjZSkpIHtcbiAgICByZXR1cm4gcmVzb3VyY2Uuc2l6ZTtcbiAgfVxuICBpZiAodHlwZW9mIHJlc291cmNlID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiByZXNvdXJjZS5sZW5ndGg7XG4gIH1cbiAgaWYgKHJlc291cmNlIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpIHtcbiAgICByZXR1cm4gcmVzb3VyY2UuYnl0ZUxlbmd0aDtcbiAgfVxuICBpZiAoQXJyYXlCdWZmZXIuaXNWaWV3KHJlc291cmNlKSkge1xuICAgIHJldHVybiByZXNvdXJjZS5ieXRlTGVuZ3RoO1xuICB9XG4gIHJldHVybiAtMTtcbn1cbmZ1bmN0aW9uIHN0cmlwUXVlcnlTdHJpbmcodXJsKSB7XG4gIHJldHVybiB1cmwucmVwbGFjZShRVUVSWV9TVFJJTkdfUEFUVEVSTiwgJycpO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cmVzb3VyY2UtdXRpbHMuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///74642\n")},17927:function(__unused_webpack_module,__webpack_exports__,__webpack_require__){eval('/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "L1": function() { return /* binding */ makeResponse; },\n/* harmony export */   "mm": function() { return /* binding */ checkResponse; }\n/* harmony export */ });\n/* unused harmony export checkResponseSync */\n/* harmony import */ var _javascript_utils_is_type__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(36255);\n/* harmony import */ var _resource_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(74642);\n\n\n\nasync function makeResponse(resource) {\n  if ((0,_javascript_utils_is_type__WEBPACK_IMPORTED_MODULE_0__/* .isResponse */ .Ew)(resource)) {\n    return resource;\n  }\n\n  const headers = {};\n  const contentLength = (0,_resource_utils__WEBPACK_IMPORTED_MODULE_1__/* .getResourceContentLength */ .C)(resource);\n  if (contentLength >= 0) {\n    headers[\'content-length\'] = String(contentLength);\n  }\n\n  const {\n    url,\n    type\n  } = (0,_resource_utils__WEBPACK_IMPORTED_MODULE_1__/* .getResourceUrlAndType */ .l)(resource);\n  if (type) {\n    headers[\'content-type\'] = type;\n  }\n\n  const initialDataUrl = await getInitialDataUrl(resource);\n  if (initialDataUrl) {\n    headers[\'x-first-bytes\'] = initialDataUrl;\n  }\n\n  if (typeof resource === \'string\') {\n    resource = new TextEncoder().encode(resource);\n  }\n\n  const response = new Response(resource, {\n    headers\n  });\n  Object.defineProperty(response, \'url\', {\n    value: url\n  });\n  return response;\n}\n\nasync function checkResponse(response) {\n  if (!response.ok) {\n    const message = await getResponseError(response);\n    throw new Error(message);\n  }\n}\n\nfunction checkResponseSync(response) {\n  if (!response.ok) {\n    let message = "".concat(response.status, " ").concat(response.statusText);\n    message = message.length > 60 ? "".concat(message.slice(0, 60), "...") : message;\n    throw new Error(message);\n  }\n}\n\nasync function getResponseError(response) {\n  let message = "Failed to fetch resource ".concat(response.url, " (").concat(response.status, "): ");\n  try {\n    const contentType = response.headers.get(\'Content-Type\');\n    let text = response.statusText;\n    if (contentType.includes(\'application/json\')) {\n      text += " ".concat(await response.text());\n    }\n    message += text;\n    message = message.length > 60 ? "".concat(message.slice(0, 60), "...") : message;\n  } catch (error) {\n  }\n  return message;\n}\nasync function getInitialDataUrl(resource) {\n  const INITIAL_DATA_LENGTH = 5;\n  if (typeof resource === \'string\') {\n    return "data:,".concat(resource.slice(0, INITIAL_DATA_LENGTH));\n  }\n  if (resource instanceof Blob) {\n    const blobSlice = resource.slice(0, 5);\n    return await new Promise(resolve => {\n      const reader = new FileReader();\n      reader.onload = event => {\n        var _event$target;\n        return resolve(event === null || event === void 0 ? void 0 : (_event$target = event.target) === null || _event$target === void 0 ? void 0 : _event$target.result);\n      };\n      reader.readAsDataURL(blobSlice);\n    });\n  }\n  if (resource instanceof ArrayBuffer) {\n    const slice = resource.slice(0, INITIAL_DATA_LENGTH);\n    const base64 = arrayBufferToBase64(slice);\n    return "data:base64,".concat(base64);\n  }\n  return null;\n}\n\nfunction arrayBufferToBase64(buffer) {\n  let binary = \'\';\n  const bytes = new Uint8Array(buffer);\n  for (let i = 0; i < bytes.byteLength; i++) {\n    binary += String.fromCharCode(bytes[i]);\n  }\n  return btoa(binary);\n}\n//# sourceMappingURL=response-utils.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTc5MjcuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUE0RDtBQUN1Qjs7QUFFNUU7QUFDUCxNQUFNLCtFQUFVO0FBQ2hCO0FBQ0E7O0FBRUE7QUFDQSx3QkFBd0Isa0ZBQXdCO0FBQ2hEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLEVBQUUsK0VBQXFCO0FBQzNCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0Isc0JBQXNCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly92dWUzLXdlYnBhY2s1Ly4vbm9kZV9tb2R1bGVzL0Bsb2FkZXJzLmdsL2NvcmUvZGlzdC9lc20vbGliL3V0aWxzL3Jlc3BvbnNlLXV0aWxzLmpzPzg0ZTMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgaXNSZXNwb25zZSB9IGZyb20gJy4uLy4uL2phdmFzY3JpcHQtdXRpbHMvaXMtdHlwZSc7XG5pbXBvcnQgeyBnZXRSZXNvdXJjZUNvbnRlbnRMZW5ndGgsIGdldFJlc291cmNlVXJsQW5kVHlwZSB9IGZyb20gJy4vcmVzb3VyY2UtdXRpbHMnO1xuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gbWFrZVJlc3BvbnNlKHJlc291cmNlKSB7XG4gIGlmIChpc1Jlc3BvbnNlKHJlc291cmNlKSkge1xuICAgIHJldHVybiByZXNvdXJjZTtcbiAgfVxuXG4gIGNvbnN0IGhlYWRlcnMgPSB7fTtcbiAgY29uc3QgY29udGVudExlbmd0aCA9IGdldFJlc291cmNlQ29udGVudExlbmd0aChyZXNvdXJjZSk7XG4gIGlmIChjb250ZW50TGVuZ3RoID49IDApIHtcbiAgICBoZWFkZXJzWydjb250ZW50LWxlbmd0aCddID0gU3RyaW5nKGNvbnRlbnRMZW5ndGgpO1xuICB9XG5cbiAgY29uc3Qge1xuICAgIHVybCxcbiAgICB0eXBlXG4gIH0gPSBnZXRSZXNvdXJjZVVybEFuZFR5cGUocmVzb3VyY2UpO1xuICBpZiAodHlwZSkge1xuICAgIGhlYWRlcnNbJ2NvbnRlbnQtdHlwZSddID0gdHlwZTtcbiAgfVxuXG4gIGNvbnN0IGluaXRpYWxEYXRhVXJsID0gYXdhaXQgZ2V0SW5pdGlhbERhdGFVcmwocmVzb3VyY2UpO1xuICBpZiAoaW5pdGlhbERhdGFVcmwpIHtcbiAgICBoZWFkZXJzWyd4LWZpcnN0LWJ5dGVzJ10gPSBpbml0aWFsRGF0YVVybDtcbiAgfVxuXG4gIGlmICh0eXBlb2YgcmVzb3VyY2UgPT09ICdzdHJpbmcnKSB7XG4gICAgcmVzb3VyY2UgPSBuZXcgVGV4dEVuY29kZXIoKS5lbmNvZGUocmVzb3VyY2UpO1xuICB9XG5cbiAgY29uc3QgcmVzcG9uc2UgPSBuZXcgUmVzcG9uc2UocmVzb3VyY2UsIHtcbiAgICBoZWFkZXJzXG4gIH0pO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkocmVzcG9uc2UsICd1cmwnLCB7XG4gICAgdmFsdWU6IHVybFxuICB9KTtcbiAgcmV0dXJuIHJlc3BvbnNlO1xufVxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gY2hlY2tSZXNwb25zZShyZXNwb25zZSkge1xuICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgY29uc3QgbWVzc2FnZSA9IGF3YWl0IGdldFJlc3BvbnNlRXJyb3IocmVzcG9uc2UpO1xuICAgIHRocm93IG5ldyBFcnJvcihtZXNzYWdlKTtcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gY2hlY2tSZXNwb25zZVN5bmMocmVzcG9uc2UpIHtcbiAgaWYgKCFyZXNwb25zZS5vaykge1xuICAgIGxldCBtZXNzYWdlID0gXCJcIi5jb25jYXQocmVzcG9uc2Uuc3RhdHVzLCBcIiBcIikuY29uY2F0KHJlc3BvbnNlLnN0YXR1c1RleHQpO1xuICAgIG1lc3NhZ2UgPSBtZXNzYWdlLmxlbmd0aCA+IDYwID8gXCJcIi5jb25jYXQobWVzc2FnZS5zbGljZSgwLCA2MCksIFwiLi4uXCIpIDogbWVzc2FnZTtcbiAgICB0aHJvdyBuZXcgRXJyb3IobWVzc2FnZSk7XG4gIH1cbn1cblxuYXN5bmMgZnVuY3Rpb24gZ2V0UmVzcG9uc2VFcnJvcihyZXNwb25zZSkge1xuICBsZXQgbWVzc2FnZSA9IFwiRmFpbGVkIHRvIGZldGNoIHJlc291cmNlIFwiLmNvbmNhdChyZXNwb25zZS51cmwsIFwiIChcIikuY29uY2F0KHJlc3BvbnNlLnN0YXR1cywgXCIpOiBcIik7XG4gIHRyeSB7XG4gICAgY29uc3QgY29udGVudFR5cGUgPSByZXNwb25zZS5oZWFkZXJzLmdldCgnQ29udGVudC1UeXBlJyk7XG4gICAgbGV0IHRleHQgPSByZXNwb25zZS5zdGF0dXNUZXh0O1xuICAgIGlmIChjb250ZW50VHlwZS5pbmNsdWRlcygnYXBwbGljYXRpb24vanNvbicpKSB7XG4gICAgICB0ZXh0ICs9IFwiIFwiLmNvbmNhdChhd2FpdCByZXNwb25zZS50ZXh0KCkpO1xuICAgIH1cbiAgICBtZXNzYWdlICs9IHRleHQ7XG4gICAgbWVzc2FnZSA9IG1lc3NhZ2UubGVuZ3RoID4gNjAgPyBcIlwiLmNvbmNhdChtZXNzYWdlLnNsaWNlKDAsIDYwKSwgXCIuLi5cIikgOiBtZXNzYWdlO1xuICB9IGNhdGNoIChlcnJvcikge1xuICB9XG4gIHJldHVybiBtZXNzYWdlO1xufVxuYXN5bmMgZnVuY3Rpb24gZ2V0SW5pdGlhbERhdGFVcmwocmVzb3VyY2UpIHtcbiAgY29uc3QgSU5JVElBTF9EQVRBX0xFTkdUSCA9IDU7XG4gIGlmICh0eXBlb2YgcmVzb3VyY2UgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIFwiZGF0YTosXCIuY29uY2F0KHJlc291cmNlLnNsaWNlKDAsIElOSVRJQUxfREFUQV9MRU5HVEgpKTtcbiAgfVxuICBpZiAocmVzb3VyY2UgaW5zdGFuY2VvZiBCbG9iKSB7XG4gICAgY29uc3QgYmxvYlNsaWNlID0gcmVzb3VyY2Uuc2xpY2UoMCwgNSk7XG4gICAgcmV0dXJuIGF3YWl0IG5ldyBQcm9taXNlKHJlc29sdmUgPT4ge1xuICAgICAgY29uc3QgcmVhZGVyID0gbmV3IEZpbGVSZWFkZXIoKTtcbiAgICAgIHJlYWRlci5vbmxvYWQgPSBldmVudCA9PiB7XG4gICAgICAgIHZhciBfZXZlbnQkdGFyZ2V0O1xuICAgICAgICByZXR1cm4gcmVzb2x2ZShldmVudCA9PT0gbnVsbCB8fCBldmVudCA9PT0gdm9pZCAwID8gdm9pZCAwIDogKF9ldmVudCR0YXJnZXQgPSBldmVudC50YXJnZXQpID09PSBudWxsIHx8IF9ldmVudCR0YXJnZXQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9ldmVudCR0YXJnZXQucmVzdWx0KTtcbiAgICAgIH07XG4gICAgICByZWFkZXIucmVhZEFzRGF0YVVSTChibG9iU2xpY2UpO1xuICAgIH0pO1xuICB9XG4gIGlmIChyZXNvdXJjZSBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSB7XG4gICAgY29uc3Qgc2xpY2UgPSByZXNvdXJjZS5zbGljZSgwLCBJTklUSUFMX0RBVEFfTEVOR1RIKTtcbiAgICBjb25zdCBiYXNlNjQgPSBhcnJheUJ1ZmZlclRvQmFzZTY0KHNsaWNlKTtcbiAgICByZXR1cm4gXCJkYXRhOmJhc2U2NCxcIi5jb25jYXQoYmFzZTY0KTtcbiAgfVxuICByZXR1cm4gbnVsbDtcbn1cblxuZnVuY3Rpb24gYXJyYXlCdWZmZXJUb0Jhc2U2NChidWZmZXIpIHtcbiAgbGV0IGJpbmFyeSA9ICcnO1xuICBjb25zdCBieXRlcyA9IG5ldyBVaW50OEFycmF5KGJ1ZmZlcik7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgYnl0ZXMuYnl0ZUxlbmd0aDsgaSsrKSB7XG4gICAgYmluYXJ5ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoYnl0ZXNbaV0pO1xuICB9XG4gIHJldHVybiBidG9hKGJpbmFyeSk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1yZXNwb25zZS11dGlscy5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///17927\n')},52462:function(__unused_webpack_module,__webpack_exports__,__webpack_require__){eval("\n// EXPORTS\n__webpack_require__.d(__webpack_exports__, {\n  \"E\": function() { return /* binding */ GLTFLoader; }\n});\n\n// UNUSED EXPORTS: parse\n\n// NAMESPACE OBJECT: ./node_modules/@loaders.gl/gltf/dist/esm/lib/extensions/EXT_meshopt_compression.js\nvar EXT_meshopt_compression_namespaceObject = {};\n__webpack_require__.r(EXT_meshopt_compression_namespaceObject);\n__webpack_require__.d(EXT_meshopt_compression_namespaceObject, {\n  \"decode\": function() { return EXT_meshopt_compression_decode; },\n  \"name\": function() { return EXT_meshopt_compression_name; }\n});\n\n// NAMESPACE OBJECT: ./node_modules/@loaders.gl/gltf/dist/esm/lib/extensions/EXT_texture_webp.js\nvar EXT_texture_webp_namespaceObject = {};\n__webpack_require__.r(EXT_texture_webp_namespaceObject);\n__webpack_require__.d(EXT_texture_webp_namespaceObject, {\n  \"name\": function() { return EXT_texture_webp_name; },\n  \"preprocess\": function() { return preprocess; }\n});\n\n// NAMESPACE OBJECT: ./node_modules/@loaders.gl/gltf/dist/esm/lib/extensions/KHR_texture_basisu.js\nvar KHR_texture_basisu_namespaceObject = {};\n__webpack_require__.r(KHR_texture_basisu_namespaceObject);\n__webpack_require__.d(KHR_texture_basisu_namespaceObject, {\n  \"name\": function() { return KHR_texture_basisu_name; },\n  \"preprocess\": function() { return KHR_texture_basisu_preprocess; }\n});\n\n// NAMESPACE OBJECT: ./node_modules/@loaders.gl/gltf/dist/esm/lib/extensions/KHR_draco_mesh_compression.js\nvar KHR_draco_mesh_compression_namespaceObject = {};\n__webpack_require__.r(KHR_draco_mesh_compression_namespaceObject);\n__webpack_require__.d(KHR_draco_mesh_compression_namespaceObject, {\n  \"decode\": function() { return KHR_draco_mesh_compression_decode; },\n  \"encode\": function() { return encode; },\n  \"name\": function() { return KHR_draco_mesh_compression_name; },\n  \"preprocess\": function() { return KHR_draco_mesh_compression_preprocess; }\n});\n\n// NAMESPACE OBJECT: ./node_modules/@loaders.gl/gltf/dist/esm/lib/extensions/KHR_texture_transform.js\nvar KHR_texture_transform_namespaceObject = {};\n__webpack_require__.r(KHR_texture_transform_namespaceObject);\n__webpack_require__.d(KHR_texture_transform_namespaceObject, {\n  \"decode\": function() { return KHR_texture_transform_decode; },\n  \"name\": function() { return KHR_texture_transform_name; }\n});\n\n// NAMESPACE OBJECT: ./node_modules/@loaders.gl/gltf/dist/esm/lib/extensions/deprecated/KHR_lights_punctual.js\nvar KHR_lights_punctual_namespaceObject = {};\n__webpack_require__.r(KHR_lights_punctual_namespaceObject);\n__webpack_require__.d(KHR_lights_punctual_namespaceObject, {\n  \"decode\": function() { return KHR_lights_punctual_decode; },\n  \"encode\": function() { return KHR_lights_punctual_encode; },\n  \"name\": function() { return KHR_lights_punctual_name; }\n});\n\n// NAMESPACE OBJECT: ./node_modules/@loaders.gl/gltf/dist/esm/lib/extensions/deprecated/KHR_materials_unlit.js\nvar KHR_materials_unlit_namespaceObject = {};\n__webpack_require__.r(KHR_materials_unlit_namespaceObject);\n__webpack_require__.d(KHR_materials_unlit_namespaceObject, {\n  \"decode\": function() { return KHR_materials_unlit_decode; },\n  \"encode\": function() { return KHR_materials_unlit_encode; },\n  \"name\": function() { return KHR_materials_unlit_name; }\n});\n\n// NAMESPACE OBJECT: ./node_modules/@loaders.gl/gltf/dist/esm/lib/extensions/deprecated/KHR_techniques_webgl.js\nvar KHR_techniques_webgl_namespaceObject = {};\n__webpack_require__.r(KHR_techniques_webgl_namespaceObject);\n__webpack_require__.d(KHR_techniques_webgl_namespaceObject, {\n  \"decode\": function() { return KHR_techniques_webgl_decode; },\n  \"encode\": function() { return KHR_techniques_webgl_encode; },\n  \"name\": function() { return KHR_techniques_webgl_name; }\n});\n\n// NAMESPACE OBJECT: ./node_modules/@loaders.gl/gltf/dist/esm/lib/extensions/deprecated/EXT_feature_metadata.js\nvar EXT_feature_metadata_namespaceObject = {};\n__webpack_require__.r(EXT_feature_metadata_namespaceObject);\n__webpack_require__.d(EXT_feature_metadata_namespaceObject, {\n  \"decode\": function() { return EXT_feature_metadata_decode; },\n  \"name\": function() { return EXT_feature_metadata_name; }\n});\n\n;// CONCATENATED MODULE: ./node_modules/@loaders.gl/gltf/dist/esm/lib/utils/version.js\n\nconst VERSION =  true ? \"3.3.1\" : 0;\n//# sourceMappingURL=version.js.map\n// EXTERNAL MODULE: ./node_modules/@loaders.gl/worker-utils/dist/esm/lib/env-utils/globals.js\nvar globals = __webpack_require__(96013);\n;// CONCATENATED MODULE: ./node_modules/@loaders.gl/textures/dist/esm/lib/utils/version.js\n\nconst version_VERSION =  true ? \"3.3.1\" : 0;\n//# sourceMappingURL=version.js.map\n// EXTERNAL MODULE: ../node/require-utils.node (ignored)\nvar require_utils_ignored_ = __webpack_require__(49125);\n// EXTERNAL MODULE: ./node_modules/@loaders.gl/worker-utils/dist/esm/lib/env-utils/assert.js\nvar assert = __webpack_require__(96040);\n;// CONCATENATED MODULE: ./node_modules/@loaders.gl/worker-utils/dist/esm/lib/library-utils/library-utils.js\n\n\n\n\n\n\nconst LATEST = 'latest';\nconst library_utils_VERSION =  true ? \"3.3.1\" : 0;\nconst loadLibraryPromises = {};\n\nasync function library_utils_loadLibrary(libraryUrl) {\n  let moduleName = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n  let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  if (moduleName) {\n    libraryUrl = getLibraryUrl(libraryUrl, moduleName, options);\n  }\n\n  loadLibraryPromises[libraryUrl] =\n  loadLibraryPromises[libraryUrl] || loadLibraryFromFile(libraryUrl);\n  return await loadLibraryPromises[libraryUrl];\n}\n\nfunction getLibraryUrl(library, moduleName, options) {\n  if (library.startsWith('http')) {\n    return library;\n  }\n\n  const modules = options.modules || {};\n  if (modules[library]) {\n    return modules[library];\n  }\n\n  if (!globals/* isBrowser */.jU) {\n    return \"modules/\".concat(moduleName, \"/dist/libs/\").concat(library);\n  }\n\n  if (options.CDN) {\n    (0,assert/* assert */.h)(options.CDN.startsWith('http'));\n    return \"\".concat(options.CDN, \"/\").concat(moduleName, \"@\").concat(library_utils_VERSION, \"/dist/libs/\").concat(library);\n  }\n\n  if (globals/* isWorker */.hJ) {\n    return \"../src/libs/\".concat(library);\n  }\n  return \"modules/\".concat(moduleName, \"/src/libs/\").concat(library);\n}\nasync function loadLibraryFromFile(libraryUrl) {\n  if (libraryUrl.endsWith('wasm')) {\n    const response = await fetch(libraryUrl);\n    return await response.arrayBuffer();\n  }\n  if (!globals/* isBrowser */.jU) {\n    try {\n      return require_utils_ignored_ && require_utils_ignored_.requireFromFile && (await require_utils_ignored_.requireFromFile(libraryUrl));\n    } catch {\n      return null;\n    }\n  }\n  if (globals/* isWorker */.hJ) {\n    return importScripts(libraryUrl);\n  }\n\n  const response = await fetch(libraryUrl);\n  const scriptSource = await response.text();\n  return loadLibraryFromString(scriptSource, libraryUrl);\n}\n\nfunction loadLibraryFromString(scriptSource, id) {\n  if (!globals/* isBrowser */.jU) {\n    return require_utils_ignored_.requireFromString && require_utils_ignored_.requireFromString(scriptSource, id);\n  }\n  if (globals/* isWorker */.hJ) {\n    eval.call(globals/* global */.CO, scriptSource);\n    return null;\n  }\n  const script = document.createElement('script');\n  script.id = id;\n  try {\n    script.appendChild(document.createTextNode(scriptSource));\n  } catch (e) {\n    script.text = scriptSource;\n  }\n  document.body.appendChild(script);\n  return null;\n}\n//# sourceMappingURL=library-utils.js.map\n;// CONCATENATED MODULE: ./node_modules/@loaders.gl/textures/dist/esm/lib/parsers/basis-module-loader.js\n\nconst basis_module_loader_VERSION =  true ? \"3.3.1\" : 0;\n\n\nconst BASIS_CDN_ENCODER_WASM = \"https://unpkg.com/@loaders.gl/textures@\".concat(basis_module_loader_VERSION, \"/dist/libs/basis_encoder.wasm\");\nconst BASIS_CDN_ENCODER_JS = \"https://unpkg.com/@loaders.gl/textures@\".concat(basis_module_loader_VERSION, \"/dist/libs/basis_encoder.js\");\nlet loadBasisTranscoderPromise;\n\nasync function loadBasisTrascoderModule(options) {\n  const modules = options.modules || {};\n  if (modules.basis) {\n    return modules.basis;\n  }\n  loadBasisTranscoderPromise = loadBasisTranscoderPromise || loadBasisTrascoder(options);\n  return await loadBasisTranscoderPromise;\n}\n\nasync function loadBasisTrascoder(options) {\n  let BASIS = null;\n  let wasmBinary = null;\n  [BASIS, wasmBinary] = await Promise.all([await library_utils_loadLibrary('basis_transcoder.js', 'textures', options), await library_utils_loadLibrary('basis_transcoder.wasm', 'textures', options)]);\n\n  BASIS = BASIS || globalThis.BASIS;\n  return await initializeBasisTrascoderModule(BASIS, wasmBinary);\n}\n\nfunction initializeBasisTrascoderModule(BasisModule, wasmBinary) {\n  const options = {};\n  if (wasmBinary) {\n    options.wasmBinary = wasmBinary;\n  }\n  return new Promise(resolve => {\n    BasisModule(options).then(module => {\n      const {\n        BasisFile,\n        initializeBasis\n      } = module;\n      initializeBasis();\n      resolve({\n        BasisFile\n      });\n    });\n  });\n}\nlet loadBasisEncoderPromise;\n\nasync function loadBasisEncoderModule(options) {\n  const modules = options.modules || {};\n  if (modules.basisEncoder) {\n    return modules.basisEncoder;\n  }\n  loadBasisEncoderPromise = loadBasisEncoderPromise || loadBasisEncoder(options);\n  return await loadBasisEncoderPromise;\n}\n\nasync function loadBasisEncoder(options) {\n  let BASIS_ENCODER = null;\n  let wasmBinary = null;\n  [BASIS_ENCODER, wasmBinary] = await Promise.all([await library_utils_loadLibrary(BASIS_CDN_ENCODER_JS, 'textures', options), await library_utils_loadLibrary(BASIS_CDN_ENCODER_WASM, 'textures', options)]);\n\n  BASIS_ENCODER = BASIS_ENCODER || globalThis.BASIS;\n  return await initializeBasisEncoderModule(BASIS_ENCODER, wasmBinary);\n}\n\nfunction initializeBasisEncoderModule(BasisEncoderModule, wasmBinary) {\n  const options = {};\n  if (wasmBinary) {\n    options.wasmBinary = wasmBinary;\n  }\n  return new Promise(resolve => {\n    BasisEncoderModule(options).then(module => {\n      const {\n        BasisFile,\n        KTX2File,\n        initializeBasis,\n        BasisEncoder\n      } = module;\n      initializeBasis();\n      resolve({\n        BasisFile,\n        KTX2File,\n        BasisEncoder\n      });\n    });\n  });\n}\n//# sourceMappingURL=basis-module-loader.js.map\n;// CONCATENATED MODULE: ./node_modules/@loaders.gl/textures/dist/esm/lib/gl-extensions.js\n\nconst GL_EXTENSIONS_CONSTANTS = {\n\n  COMPRESSED_RGB_S3TC_DXT1_EXT: 0x83f0,\n  COMPRESSED_RGBA_S3TC_DXT1_EXT: 0x83f1,\n  COMPRESSED_RGBA_S3TC_DXT3_EXT: 0x83f2,\n  COMPRESSED_RGBA_S3TC_DXT5_EXT: 0x83f3,\n\n  COMPRESSED_R11_EAC: 0x9270,\n  COMPRESSED_SIGNED_R11_EAC: 0x9271,\n  COMPRESSED_RG11_EAC: 0x9272,\n  COMPRESSED_SIGNED_RG11_EAC: 0x9273,\n  COMPRESSED_RGB8_ETC2: 0x9274,\n  COMPRESSED_RGBA8_ETC2_EAC: 0x9275,\n  COMPRESSED_SRGB8_ETC2: 0x9276,\n  COMPRESSED_SRGB8_ALPHA8_ETC2_EAC: 0x9277,\n  COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2: 0x9278,\n  COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2: 0x9279,\n\n  COMPRESSED_RGB_PVRTC_4BPPV1_IMG: 0x8c00,\n  COMPRESSED_RGBA_PVRTC_4BPPV1_IMG: 0x8c02,\n  COMPRESSED_RGB_PVRTC_2BPPV1_IMG: 0x8c01,\n  COMPRESSED_RGBA_PVRTC_2BPPV1_IMG: 0x8c03,\n\n  COMPRESSED_RGB_ETC1_WEBGL: 0x8d64,\n\n  COMPRESSED_RGB_ATC_WEBGL: 0x8c92,\n  COMPRESSED_RGBA_ATC_EXPLICIT_ALPHA_WEBGL: 0x8c93,\n  COMPRESSED_RGBA_ATC_INTERPOLATED_ALPHA_WEBGL: 0x87ee,\n\n  COMPRESSED_RGBA_ASTC_4X4_KHR: 0x93b0,\n  COMPRESSED_RGBA_ASTC_5X4_KHR: 0x93b1,\n  COMPRESSED_RGBA_ASTC_5X5_KHR: 0x93b2,\n  COMPRESSED_RGBA_ASTC_6X5_KHR: 0x93b3,\n  COMPRESSED_RGBA_ASTC_6X6_KHR: 0x93b4,\n  COMPRESSED_RGBA_ASTC_8X5_KHR: 0x93b5,\n  COMPRESSED_RGBA_ASTC_8X6_KHR: 0x93b6,\n  COMPRESSED_RGBA_ASTC_8X8_KHR: 0x93b7,\n  COMPRESSED_RGBA_ASTC_10X5_KHR: 0x93b8,\n  COMPRESSED_RGBA_ASTC_10X6_KHR: 0x93b9,\n  COMPRESSED_RGBA_ASTC_10X8_KHR: 0x93ba,\n  COMPRESSED_RGBA_ASTC_10X10_KHR: 0x93bb,\n  COMPRESSED_RGBA_ASTC_12X10_KHR: 0x93bc,\n  COMPRESSED_RGBA_ASTC_12X12_KHR: 0x93bd,\n  COMPRESSED_SRGB8_ALPHA8_ASTC_4X4_KHR: 0x93d0,\n  COMPRESSED_SRGB8_ALPHA8_ASTC_5X4_KHR: 0x93d1,\n  COMPRESSED_SRGB8_ALPHA8_ASTC_5X5_KHR: 0x93d2,\n  COMPRESSED_SRGB8_ALPHA8_ASTC_6X5_KHR: 0x93d3,\n  COMPRESSED_SRGB8_ALPHA8_ASTC_6X6_KHR: 0x93d4,\n  COMPRESSED_SRGB8_ALPHA8_ASTC_8X5_KHR: 0x93d5,\n  COMPRESSED_SRGB8_ALPHA8_ASTC_8X6_KHR: 0x93d6,\n  COMPRESSED_SRGB8_ALPHA8_ASTC_8X8_KHR: 0x93d7,\n  COMPRESSED_SRGB8_ALPHA8_ASTC_10X5_KHR: 0x93d8,\n  COMPRESSED_SRGB8_ALPHA8_ASTC_10X6_KHR: 0x93d9,\n  COMPRESSED_SRGB8_ALPHA8_ASTC_10X8_KHR: 0x93da,\n  COMPRESSED_SRGB8_ALPHA8_ASTC_10X10_KHR: 0x93db,\n  COMPRESSED_SRGB8_ALPHA8_ASTC_12X10_KHR: 0x93dc,\n  COMPRESSED_SRGB8_ALPHA8_ASTC_12X12_KHR: 0x93dd,\n\n  COMPRESSED_RED_RGTC1_EXT: 0x8dbb,\n  COMPRESSED_SIGNED_RED_RGTC1_EXT: 0x8dbc,\n  COMPRESSED_RED_GREEN_RGTC2_EXT: 0x8dbd,\n  COMPRESSED_SIGNED_RED_GREEN_RGTC2_EXT: 0x8dbe,\n\n  COMPRESSED_SRGB_S3TC_DXT1_EXT: 0x8c4c,\n  COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT: 0x8c4d,\n  COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT: 0x8c4e,\n  COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT: 0x8c4f\n};\n//# sourceMappingURL=gl-extensions.js.map\n;// CONCATENATED MODULE: ./node_modules/@loaders.gl/textures/dist/esm/lib/utils/texture-formats.js\nconst BROWSER_PREFIXES = ['', 'WEBKIT_', 'MOZ_'];\nconst WEBGL_EXTENSIONS = {\n  WEBGL_compressed_texture_s3tc: 'dxt',\n  WEBGL_compressed_texture_s3tc_srgb: 'dxt-srgb',\n  WEBGL_compressed_texture_etc1: 'etc1',\n  WEBGL_compressed_texture_etc: 'etc2',\n  WEBGL_compressed_texture_pvrtc: 'pvrtc',\n  WEBGL_compressed_texture_atc: 'atc',\n  WEBGL_compressed_texture_astc: 'astc',\n  EXT_texture_compression_rgtc: 'rgtc'\n};\n\nlet formats = null;\n\nfunction getSupportedGPUTextureFormats(gl) {\n  if (!formats) {\n    gl = gl || getWebGLContext() || undefined;\n    formats = new Set();\n    for (const prefix of BROWSER_PREFIXES) {\n      for (const extension in WEBGL_EXTENSIONS) {\n        if (gl && gl.getExtension(\"\".concat(prefix).concat(extension))) {\n          const gpuTextureFormat = WEBGL_EXTENSIONS[extension];\n          formats.add(gpuTextureFormat);\n        }\n      }\n    }\n  }\n  return formats;\n}\n\nfunction getWebGLContext() {\n  try {\n    const canvas = document.createElement('canvas');\n    return canvas.getContext('webgl');\n  } catch (error) {\n    return null;\n  }\n}\n//# sourceMappingURL=texture-formats.js.map\n// EXTERNAL MODULE: ./node_modules/ktx-parse/dist/ktx-parse.modern.js\nvar ktx_parse_modern = __webpack_require__(31029);\n;// CONCATENATED MODULE: ./node_modules/@loaders.gl/textures/dist/esm/lib/parsers/parse-ktx.js\n\n\n\nconst KTX2_ID = [\n0xab, 0x4b, 0x54, 0x58, 0x20, 0x32, 0x30, 0xbb, 0x0d, 0x0a, 0x1a, 0x0a];\n\nfunction isKTX(data) {\n  const id = new Uint8Array(data);\n  const notKTX = id.byteLength < KTX2_ID.length || id[0] !== KTX2_ID[0] ||\n  id[1] !== KTX2_ID[1] ||\n  id[2] !== KTX2_ID[2] ||\n  id[3] !== KTX2_ID[3] ||\n  id[4] !== KTX2_ID[4] ||\n  id[5] !== KTX2_ID[5] ||\n  id[6] !== KTX2_ID[6] ||\n  id[7] !== KTX2_ID[7] ||\n  id[8] !== KTX2_ID[8] ||\n  id[9] !== KTX2_ID[9] ||\n  id[10] !== KTX2_ID[10] ||\n  id[11] !== KTX2_ID[11];\n\n  return !notKTX;\n}\nfunction parseKTX(arrayBuffer) {\n  const uint8Array = new Uint8Array(arrayBuffer);\n  const ktx = read(uint8Array);\n  const mipMapLevels = Math.max(1, ktx.levels.length);\n  const width = ktx.pixelWidth;\n  const height = ktx.pixelHeight;\n  const internalFormat = mapVkFormatToWebGL(ktx.vkFormat);\n  return extractMipmapImages(ktx.levels, {\n    mipMapLevels,\n    width,\n    height,\n    sizeFunction: level => level.uncompressedByteLength,\n    internalFormat\n  });\n}\n//# sourceMappingURL=parse-ktx.js.map\n;// CONCATENATED MODULE: ./node_modules/@loaders.gl/textures/dist/esm/lib/parsers/parse-basis.js\n\n\n\n\n\n\nconst OutputFormat = {\n  etc1: {\n    basisFormat: 0,\n    compressed: true,\n    format: GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGB_ETC1_WEBGL\n  },\n  etc2: {\n    basisFormat: 1,\n    compressed: true\n  },\n  bc1: {\n    basisFormat: 2,\n    compressed: true,\n    format: GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGB_S3TC_DXT1_EXT\n  },\n  bc3: {\n    basisFormat: 3,\n    compressed: true,\n    format: GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGBA_S3TC_DXT5_EXT\n  },\n  bc4: {\n    basisFormat: 4,\n    compressed: true\n  },\n  bc5: {\n    basisFormat: 5,\n    compressed: true\n  },\n  'bc7-m6-opaque-only': {\n    basisFormat: 6,\n    compressed: true\n  },\n  'bc7-m5': {\n    basisFormat: 7,\n    compressed: true\n  },\n  'pvrtc1-4-rgb': {\n    basisFormat: 8,\n    compressed: true,\n    format: GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGB_PVRTC_4BPPV1_IMG\n  },\n  'pvrtc1-4-rgba': {\n    basisFormat: 9,\n    compressed: true,\n    format: GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG\n  },\n  'astc-4x4': {\n    basisFormat: 10,\n    compressed: true,\n    format: GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGBA_ASTC_4X4_KHR\n  },\n  'atc-rgb': {\n    basisFormat: 11,\n    compressed: true\n  },\n  'atc-rgba-interpolated-alpha': {\n    basisFormat: 12,\n    compressed: true\n  },\n  rgba32: {\n    basisFormat: 13,\n    compressed: false\n  },\n  rgb565: {\n    basisFormat: 14,\n    compressed: false\n  },\n  bgr565: {\n    basisFormat: 15,\n    compressed: false\n  },\n  rgba4444: {\n    basisFormat: 16,\n    compressed: false\n  }\n};\n\nasync function parseBasis(data, options) {\n  if (options.basis.containerFormat === 'auto') {\n    if (isKTX(data)) {\n      const fileConstructors = await loadBasisEncoderModule(options);\n      return parseKTX2File(fileConstructors.KTX2File, data, options);\n    }\n    const {\n      BasisFile\n    } = await loadBasisTrascoderModule(options);\n    return parseBasisFile(BasisFile, data, options);\n  }\n  switch (options.basis.module) {\n    case 'encoder':\n      const fileConstructors = await loadBasisEncoderModule(options);\n      switch (options.basis.containerFormat) {\n        case 'ktx2':\n          return parseKTX2File(fileConstructors.KTX2File, data, options);\n        case 'basis':\n        default:\n          return parseBasisFile(fileConstructors.BasisFile, data, options);\n      }\n    case 'transcoder':\n    default:\n      const {\n        BasisFile\n      } = await loadBasisTrascoderModule(options);\n      return parseBasisFile(BasisFile, data, options);\n  }\n}\n\nfunction parseBasisFile(BasisFile, data, options) {\n  const basisFile = new BasisFile(new Uint8Array(data));\n  try {\n    if (!basisFile.startTranscoding()) {\n      throw new Error('Failed to start basis transcoding');\n    }\n    const imageCount = basisFile.getNumImages();\n    const images = [];\n    for (let imageIndex = 0; imageIndex < imageCount; imageIndex++) {\n      const levelsCount = basisFile.getNumLevels(imageIndex);\n      const levels = [];\n      for (let levelIndex = 0; levelIndex < levelsCount; levelIndex++) {\n        levels.push(transcodeImage(basisFile, imageIndex, levelIndex, options));\n      }\n      images.push(levels);\n    }\n    return images;\n  } finally {\n    basisFile.close();\n    basisFile.delete();\n  }\n}\n\nfunction transcodeImage(basisFile, imageIndex, levelIndex, options) {\n  const width = basisFile.getImageWidth(imageIndex, levelIndex);\n  const height = basisFile.getImageHeight(imageIndex, levelIndex);\n\n  const hasAlpha = basisFile.getHasAlpha();\n\n  const {\n    compressed,\n    format,\n    basisFormat\n  } = getBasisOptions(options, hasAlpha);\n  const decodedSize = basisFile.getImageTranscodedSizeInBytes(imageIndex, levelIndex, basisFormat);\n  const decodedData = new Uint8Array(decodedSize);\n  if (!basisFile.transcodeImage(decodedData, imageIndex, levelIndex, basisFormat, 0, 0)) {\n    throw new Error('failed to start Basis transcoding');\n  }\n  return {\n    width,\n    height,\n    data: decodedData,\n    compressed,\n    format,\n    hasAlpha\n  };\n}\n\nfunction parseKTX2File(KTX2File, data, options) {\n  const ktx2File = new KTX2File(new Uint8Array(data));\n  try {\n    if (!ktx2File.startTranscoding()) {\n      throw new Error('failed to start KTX2 transcoding');\n    }\n    const levelsCount = ktx2File.getLevels();\n    const levels = [];\n    for (let levelIndex = 0; levelIndex < levelsCount; levelIndex++) {\n      levels.push(transcodeKTX2Image(ktx2File, levelIndex, options));\n      break;\n    }\n\n    return [levels];\n  } finally {\n    ktx2File.close();\n    ktx2File.delete();\n  }\n}\n\nfunction transcodeKTX2Image(ktx2File, levelIndex, options) {\n  const {\n    alphaFlag,\n    height,\n    width\n  } = ktx2File.getImageLevelInfo(levelIndex, 0, 0);\n\n  const {\n    compressed,\n    format,\n    basisFormat\n  } = getBasisOptions(options, alphaFlag);\n  const decodedSize = ktx2File.getImageTranscodedSizeInBytes(levelIndex, 0, 0, basisFormat);\n  const decodedData = new Uint8Array(decodedSize);\n  if (!ktx2File.transcodeImage(decodedData, levelIndex, 0, 0, basisFormat, 0, -1, -1)) {\n    throw new Error('Failed to transcode KTX2 image');\n  }\n  return {\n    width,\n    height,\n    data: decodedData,\n    compressed,\n    levelSize: decodedSize,\n    hasAlpha: alphaFlag,\n    format\n  };\n}\n\nfunction getBasisOptions(options, hasAlpha) {\n  let format = options && options.basis && options.basis.format;\n  if (format === 'auto') {\n    format = selectSupportedBasisFormat();\n  }\n  if (typeof format === 'object') {\n    format = hasAlpha ? format.alpha : format.noAlpha;\n  }\n  format = format.toLowerCase();\n  return OutputFormat[format];\n}\n\nfunction selectSupportedBasisFormat() {\n  const supportedFormats = getSupportedGPUTextureFormats();\n  if (supportedFormats.has('astc')) {\n    return 'astc-4x4';\n  } else if (supportedFormats.has('dxt')) {\n    return {\n      alpha: 'bc3',\n      noAlpha: 'bc1'\n    };\n  } else if (supportedFormats.has('pvrtc')) {\n    return {\n      alpha: 'pvrtc1-4-rgba',\n      noAlpha: 'pvrtc1-4-rgb'\n    };\n  } else if (supportedFormats.has('etc1')) {\n    return 'etc1';\n  } else if (supportedFormats.has('etc2')) {\n    return 'etc2';\n  }\n  return 'rgb565';\n}\n//# sourceMappingURL=parse-basis.js.map\n;// CONCATENATED MODULE: ./node_modules/@loaders.gl/textures/dist/esm/basis-loader.js\n\n\n\n\nconst BasisWorkerLoader = {\n  name: 'Basis',\n  id: globals/* isBrowser */.jU ? 'basis' : 'basis-nodejs',\n  module: 'textures',\n  version: version_VERSION,\n  worker: true,\n  extensions: ['basis', 'ktx2'],\n  mimeTypes: ['application/octet-stream', 'image/ktx2'],\n  tests: ['sB'],\n  binary: true,\n  options: {\n    basis: {\n      format: 'auto',\n      libraryPath: 'libs/',\n      containerFormat: 'auto',\n      module: 'transcoder'\n    }\n  }\n};\n\nconst BasisLoader = {\n  ...BasisWorkerLoader,\n  parse: parseBasis\n};\n\nconst _TypecheckBasisWorkerLoader = (/* unused pure expression or super */ null && (BasisWorkerLoader));\nconst _TypecheckBasisLoader = (/* unused pure expression or super */ null && (BasisLoader));\n//# sourceMappingURL=basis-loader.js.map\n// EXTERNAL MODULE: ./node_modules/@loaders.gl/images/dist/esm/image-loader.js + 8 modules\nvar image_loader = __webpack_require__(54022);\n;// CONCATENATED MODULE: ./node_modules/@loaders.gl/loader-utils/dist/esm/lib/binary-utils/get-first-characters.js\n\n\nfunction getFirstCharacters(data) {\n  let length = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 5;\n  if (typeof data === 'string') {\n    return data.slice(0, length);\n  } else if (ArrayBuffer.isView(data)) {\n    return getMagicString(data.buffer, data.byteOffset, length);\n  } else if (data instanceof ArrayBuffer) {\n    const byteOffset = 0;\n    return getMagicString(data, byteOffset, length);\n  }\n  return '';\n}\n\nfunction getMagicString(arrayBuffer, byteOffset, length) {\n  if (arrayBuffer.byteLength <= byteOffset + length) {\n    return '';\n  }\n  const dataView = new DataView(arrayBuffer);\n  let magic = '';\n  for (let i = 0; i < length; i++) {\n    magic += String.fromCharCode(dataView.getUint8(byteOffset + i));\n  }\n  return magic;\n}\n//# sourceMappingURL=get-first-characters.js.map\n;// CONCATENATED MODULE: ./node_modules/@loaders.gl/loader-utils/dist/esm/lib/parser-utils/parse-json.js\n\n\nfunction parseJSON(string) {\n  try {\n    return JSON.parse(string);\n  } catch (_) {\n    throw new Error(\"Failed to parse JSON from data starting with \\\"\".concat(getFirstCharacters(string), \"\\\"\"));\n  }\n}\n//# sourceMappingURL=parse-json.js.map\n// EXTERNAL MODULE: ./node_modules/@loaders.gl/loader-utils/dist/esm/lib/binary-utils/array-buffer-utils.js\nvar array_buffer_utils = __webpack_require__(74609);\n;// CONCATENATED MODULE: ./node_modules/@loaders.gl/gltf/dist/esm/lib/utils/assert.js\n\nfunction assert_assert(condition, message) {\n  if (!condition) {\n    throw new Error(message || 'assert failed: gltf');\n  }\n}\n//# sourceMappingURL=assert.js.map\n;// CONCATENATED MODULE: ./node_modules/@loaders.gl/gltf/dist/esm/lib/gltf-utils/resolve-url.js\n\nfunction resolveUrl(url, options) {\n  const absolute = url.startsWith('data:') || url.startsWith('http:') || url.startsWith('https:');\n  if (absolute) {\n    return url;\n  }\n  const baseUrl = options.baseUri || options.uri;\n  if (!baseUrl) {\n    throw new Error(\"'baseUri' must be provided to resolve relative url \".concat(url));\n  }\n  return baseUrl.substr(0, baseUrl.lastIndexOf('/') + 1) + url;\n}\n//# sourceMappingURL=resolve-url.js.map\n;// CONCATENATED MODULE: ./node_modules/@loaders.gl/gltf/dist/esm/lib/gltf-utils/get-typed-array.js\n\n\n\nfunction getTypedArrayForBufferView(json, buffers, bufferViewIndex) {\n  const bufferView = json.bufferViews[bufferViewIndex];\n  assert_assert(bufferView);\n\n  const bufferIndex = bufferView.buffer;\n  const binChunk = buffers[bufferIndex];\n  assert_assert(binChunk);\n  const byteOffset = (bufferView.byteOffset || 0) + binChunk.byteOffset;\n  return new Uint8Array(binChunk.arrayBuffer, byteOffset, bufferView.byteLength);\n}\n\nfunction getTypedArrayForImageData(json, buffers, imageIndex) {\n  const image = json.images[imageIndex];\n  const bufferViewIndex = json.bufferViews[image.bufferView];\n  return getTypedArrayForBufferView(json, buffers, bufferViewIndex);\n}\n//# sourceMappingURL=get-typed-array.js.map\n// EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/esm/defineProperty.js\nvar defineProperty = __webpack_require__(82482);\n// EXTERNAL MODULE: ./node_modules/@loaders.gl/images/dist/esm/lib/category-api/binary-image-api.js\nvar binary_image_api = __webpack_require__(39105);\n// EXTERNAL MODULE: ./node_modules/@loaders.gl/loader-utils/dist/esm/lib/env-utils/assert.js\nvar env_utils_assert = __webpack_require__(16269);\n;// CONCATENATED MODULE: ./node_modules/@loaders.gl/loader-utils/dist/esm/lib/binary-utils/memory-copy-utils.js\n\n\nfunction padToNBytes(byteLength, padding) {\n  (0,env_utils_assert/* assert */.h)(byteLength >= 0);\n  (0,env_utils_assert/* assert */.h)(padding > 0);\n  return byteLength + (padding - 1) & ~(padding - 1);\n}\n\nfunction copyArrayBuffer(targetBuffer, sourceBuffer, byteOffset) {\n  let byteLength = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : sourceBuffer.byteLength;\n  const targetArray = new Uint8Array(targetBuffer, byteOffset, byteLength);\n  const sourceArray = new Uint8Array(sourceBuffer);\n  targetArray.set(sourceArray);\n  return targetBuffer;\n}\n\nfunction copyToArray(source, target, targetOffset) {\n  let sourceArray;\n  if (source instanceof ArrayBuffer) {\n    sourceArray = new Uint8Array(source);\n  } else {\n    const srcByteOffset = source.byteOffset;\n    const srcByteLength = source.byteLength;\n    sourceArray = new Uint8Array(source.buffer || source.arrayBuffer, srcByteOffset, srcByteLength);\n  }\n\n  target.set(sourceArray, targetOffset);\n  return targetOffset + padToNBytes(sourceArray.byteLength, 4);\n}\n//# sourceMappingURL=memory-copy-utils.js.map\n;// CONCATENATED MODULE: ./node_modules/@loaders.gl/gltf/dist/esm/lib/gltf-utils/gltf-utils.js\n\nconst TYPES = ['SCALAR', 'VEC2', 'VEC3', 'VEC4'];\nconst ARRAY_CONSTRUCTOR_TO_WEBGL_CONSTANT = [[Int8Array, 5120], [Uint8Array, 5121], [Int16Array, 5122], [Uint16Array, 5123], [Uint32Array, 5125], [Float32Array, 5126], [Float64Array, 5130]];\nconst ARRAY_TO_COMPONENT_TYPE = new Map(ARRAY_CONSTRUCTOR_TO_WEBGL_CONSTANT);\nconst ATTRIBUTE_TYPE_TO_COMPONENTS = {\n  SCALAR: 1,\n  VEC2: 2,\n  VEC3: 3,\n  VEC4: 4,\n  MAT2: 4,\n  MAT3: 9,\n  MAT4: 16\n};\nconst ATTRIBUTE_COMPONENT_TYPE_TO_BYTE_SIZE = {\n  5120: 1,\n  5121: 1,\n  5122: 2,\n  5123: 2,\n  5125: 4,\n  5126: 4\n};\nconst ATTRIBUTE_COMPONENT_TYPE_TO_ARRAY = {\n  5120: Int8Array,\n  5121: Uint8Array,\n  5122: Int16Array,\n  5123: Uint16Array,\n  5125: Uint32Array,\n  5126: Float32Array\n};\nfunction getAccessorTypeFromSize(size) {\n  const type = TYPES[size - 1];\n  return type || TYPES[0];\n}\nfunction getComponentTypeFromArray(typedArray) {\n  const componentType = ARRAY_TO_COMPONENT_TYPE.get(typedArray.constructor);\n  if (!componentType) {\n    throw new Error('Illegal typed array');\n  }\n  return componentType;\n}\nfunction getAccessorArrayTypeAndLength(accessor, bufferView) {\n  const ArrayType = ATTRIBUTE_COMPONENT_TYPE_TO_ARRAY[accessor.componentType];\n  const components = ATTRIBUTE_TYPE_TO_COMPONENTS[accessor.type];\n  const bytesPerComponent = ATTRIBUTE_COMPONENT_TYPE_TO_BYTE_SIZE[accessor.componentType];\n  const length = accessor.count * components;\n  const byteLength = accessor.count * components * bytesPerComponent;\n  assert_assert(byteLength >= 0 && byteLength <= bufferView.byteLength);\n  return {\n    ArrayType,\n    length,\n    byteLength\n  };\n}\n//# sourceMappingURL=gltf-utils.js.map\n;// CONCATENATED MODULE: ./node_modules/@loaders.gl/gltf/dist/esm/lib/api/gltf-scenegraph.js\n\n\n\n\n\nconst DEFAULT_GLTF_JSON = {\n  asset: {\n    version: '2.0',\n    generator: 'loaders.gl'\n  },\n  buffers: []\n};\nclass GLTFScenegraph {\n\n  constructor(gltf) {\n    (0,defineProperty/* default */.Z)(this, \"gltf\", void 0);\n    (0,defineProperty/* default */.Z)(this, \"sourceBuffers\", void 0);\n    (0,defineProperty/* default */.Z)(this, \"byteLength\", void 0);\n    this.gltf = gltf || {\n      json: {\n        ...DEFAULT_GLTF_JSON\n      },\n      buffers: []\n    };\n    this.sourceBuffers = [];\n    this.byteLength = 0;\n\n    if (this.gltf.buffers && this.gltf.buffers[0]) {\n      this.byteLength = this.gltf.buffers[0].byteLength;\n      this.sourceBuffers = [this.gltf.buffers[0]];\n    }\n  }\n\n  get json() {\n    return this.gltf.json;\n  }\n  getApplicationData(key) {\n    const data = this.json[key];\n    return data;\n  }\n  getExtraData(key) {\n    const extras = this.json.extras || {};\n    return extras[key];\n  }\n  getExtension(extensionName) {\n    const isExtension = this.getUsedExtensions().find(name => name === extensionName);\n    const extensions = this.json.extensions || {};\n    return isExtension ? extensions[extensionName] || true : null;\n  }\n  getRequiredExtension(extensionName) {\n    const isRequired = this.getRequiredExtensions().find(name => name === extensionName);\n    return isRequired ? this.getExtension(extensionName) : null;\n  }\n  getRequiredExtensions() {\n    return this.json.extensionsRequired || [];\n  }\n  getUsedExtensions() {\n    return this.json.extensionsUsed || [];\n  }\n  getRemovedExtensions() {\n    return this.json.extensionsRemoved || [];\n  }\n  getObjectExtension(object, extensionName) {\n    const extensions = object.extensions || {};\n    return extensions[extensionName];\n  }\n  getScene(index) {\n    return this.getObject('scenes', index);\n  }\n  getNode(index) {\n    return this.getObject('nodes', index);\n  }\n  getSkin(index) {\n    return this.getObject('skins', index);\n  }\n  getMesh(index) {\n    return this.getObject('meshes', index);\n  }\n  getMaterial(index) {\n    return this.getObject('materials', index);\n  }\n  getAccessor(index) {\n    return this.getObject('accessors', index);\n  }\n\n  getTexture(index) {\n    return this.getObject('textures', index);\n  }\n  getSampler(index) {\n    return this.getObject('samplers', index);\n  }\n  getImage(index) {\n    return this.getObject('images', index);\n  }\n  getBufferView(index) {\n    return this.getObject('bufferViews', index);\n  }\n  getBuffer(index) {\n    return this.getObject('buffers', index);\n  }\n  getObject(array, index) {\n    if (typeof index === 'object') {\n      return index;\n    }\n    const object = this.json[array] && this.json[array][index];\n    if (!object) {\n      throw new Error(\"glTF file error: Could not find \".concat(array, \"[\").concat(index, \"]\"));\n    }\n\n    return object;\n  }\n\n  getTypedArrayForBufferView(bufferView) {\n    bufferView = this.getBufferView(bufferView);\n    const bufferIndex = bufferView.buffer;\n\n    const binChunk = this.gltf.buffers[bufferIndex];\n    assert_assert(binChunk);\n\n    const byteOffset = (bufferView.byteOffset || 0) + binChunk.byteOffset;\n    return new Uint8Array(binChunk.arrayBuffer, byteOffset, bufferView.byteLength);\n  }\n\n  getTypedArrayForAccessor(accessor) {\n    accessor = this.getAccessor(accessor);\n    const bufferView = this.getBufferView(accessor.bufferView);\n    const buffer = this.getBuffer(bufferView.buffer);\n    const arrayBuffer = buffer.data;\n\n    const {\n      ArrayType,\n      length\n    } = getAccessorArrayTypeAndLength(accessor, bufferView);\n    const byteOffset = bufferView.byteOffset + accessor.byteOffset;\n    return new ArrayType(arrayBuffer, byteOffset, length);\n  }\n\n  getTypedArrayForImageData(image) {\n    image = this.getAccessor(image);\n    const bufferView = this.getBufferView(image.bufferView);\n    const buffer = this.getBuffer(bufferView.buffer);\n    const arrayBuffer = buffer.data;\n    const byteOffset = bufferView.byteOffset || 0;\n    return new Uint8Array(arrayBuffer, byteOffset, bufferView.byteLength);\n  }\n\n  addApplicationData(key, data) {\n    this.json[key] = data;\n    return this;\n  }\n\n  addExtraData(key, data) {\n    this.json.extras = this.json.extras || {};\n    this.json.extras[key] = data;\n    return this;\n  }\n  addObjectExtension(object, extensionName, data) {\n    object.extensions = object.extensions || {};\n    object.extensions[extensionName] = data;\n    this.registerUsedExtension(extensionName);\n    return this;\n  }\n  setObjectExtension(object, extensionName, data) {\n    const extensions = object.extensions || {};\n    extensions[extensionName] = data;\n  }\n\n  removeObjectExtension(object, extensionName) {\n    const extensions = object.extensions || {};\n    const extension = extensions[extensionName];\n    delete extensions[extensionName];\n    return extension;\n  }\n\n  addExtension(extensionName) {\n    let extensionData = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    assert_assert(extensionData);\n    this.json.extensions = this.json.extensions || {};\n    this.json.extensions[extensionName] = extensionData;\n    this.registerUsedExtension(extensionName);\n    return extensionData;\n  }\n\n  addRequiredExtension(extensionName) {\n    let extensionData = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    assert_assert(extensionData);\n    this.addExtension(extensionName, extensionData);\n    this.registerRequiredExtension(extensionName);\n    return extensionData;\n  }\n\n  registerUsedExtension(extensionName) {\n    this.json.extensionsUsed = this.json.extensionsUsed || [];\n    if (!this.json.extensionsUsed.find(ext => ext === extensionName)) {\n      this.json.extensionsUsed.push(extensionName);\n    }\n  }\n\n  registerRequiredExtension(extensionName) {\n    this.registerUsedExtension(extensionName);\n    this.json.extensionsRequired = this.json.extensionsRequired || [];\n    if (!this.json.extensionsRequired.find(ext => ext === extensionName)) {\n      this.json.extensionsRequired.push(extensionName);\n    }\n  }\n\n  removeExtension(extensionName) {\n    if (!this.getExtension(extensionName)) {\n      return;\n    }\n    if (this.json.extensionsRequired) {\n      this._removeStringFromArray(this.json.extensionsRequired, extensionName);\n    }\n    if (this.json.extensionsUsed) {\n      this._removeStringFromArray(this.json.extensionsUsed, extensionName);\n    }\n    if (this.json.extensions) {\n      delete this.json.extensions[extensionName];\n    }\n    if (!Array.isArray(this.json.extensionsRemoved)) {\n      this.json.extensionsRemoved = [];\n    }\n    const extensionsRemoved = this.json.extensionsRemoved;\n    if (!extensionsRemoved.includes(extensionName)) {\n      extensionsRemoved.push(extensionName);\n    }\n  }\n\n  setDefaultScene(sceneIndex) {\n    this.json.scene = sceneIndex;\n  }\n\n  addScene(scene) {\n    const {\n      nodeIndices\n    } = scene;\n    this.json.scenes = this.json.scenes || [];\n    this.json.scenes.push({\n      nodes: nodeIndices\n    });\n    return this.json.scenes.length - 1;\n  }\n\n  addNode(node) {\n    const {\n      meshIndex,\n      matrix\n    } = node;\n    this.json.nodes = this.json.nodes || [];\n    const nodeData = {\n      mesh: meshIndex\n    };\n    if (matrix) {\n      nodeData.matrix = matrix;\n    }\n    this.json.nodes.push(nodeData);\n    return this.json.nodes.length - 1;\n  }\n\n  addMesh(mesh) {\n    const {\n      attributes,\n      indices,\n      material,\n      mode = 4\n    } = mesh;\n    const accessors = this._addAttributes(attributes);\n    const glTFMesh = {\n      primitives: [{\n        attributes: accessors,\n        mode\n      }]\n    };\n    if (indices) {\n      const indicesAccessor = this._addIndices(indices);\n      glTFMesh.primitives[0].indices = indicesAccessor;\n    }\n    if (Number.isFinite(material)) {\n      glTFMesh.primitives[0].material = material;\n    }\n    this.json.meshes = this.json.meshes || [];\n    this.json.meshes.push(glTFMesh);\n    return this.json.meshes.length - 1;\n  }\n  addPointCloud(attributes) {\n    const accessorIndices = this._addAttributes(attributes);\n    const glTFMesh = {\n      primitives: [{\n        attributes: accessorIndices,\n        mode: 0\n      }]\n    };\n\n    this.json.meshes = this.json.meshes || [];\n    this.json.meshes.push(glTFMesh);\n    return this.json.meshes.length - 1;\n  }\n\n  addImage(imageData, mimeTypeOpt) {\n    const metadata = (0,binary_image_api/* getBinaryImageMetadata */.I)(imageData);\n    const mimeType = mimeTypeOpt || (metadata === null || metadata === void 0 ? void 0 : metadata.mimeType);\n    const bufferViewIndex = this.addBufferView(imageData);\n    const glTFImage = {\n      bufferView: bufferViewIndex,\n      mimeType\n    };\n    this.json.images = this.json.images || [];\n    this.json.images.push(glTFImage);\n    return this.json.images.length - 1;\n  }\n\n  addBufferView(buffer) {\n    const byteLength = buffer.byteLength;\n    assert_assert(Number.isFinite(byteLength));\n\n    this.sourceBuffers = this.sourceBuffers || [];\n    this.sourceBuffers.push(buffer);\n    const glTFBufferView = {\n      buffer: 0,\n      byteOffset: this.byteLength,\n      byteLength\n    };\n\n    this.byteLength += padToNBytes(byteLength, 4);\n\n    this.json.bufferViews = this.json.bufferViews || [];\n    this.json.bufferViews.push(glTFBufferView);\n    return this.json.bufferViews.length - 1;\n  }\n\n  addAccessor(bufferViewIndex, accessor) {\n    const glTFAccessor = {\n      bufferView: bufferViewIndex,\n      type: getAccessorTypeFromSize(accessor.size),\n      componentType: accessor.componentType,\n      count: accessor.count,\n      max: accessor.max,\n      min: accessor.min\n    };\n    this.json.accessors = this.json.accessors || [];\n    this.json.accessors.push(glTFAccessor);\n    return this.json.accessors.length - 1;\n  }\n\n  addBinaryBuffer(sourceBuffer) {\n    let accessor = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {\n      size: 3\n    };\n    const bufferViewIndex = this.addBufferView(sourceBuffer);\n    let minMax = {\n      min: accessor.min,\n      max: accessor.max\n    };\n    if (!minMax.min || !minMax.max) {\n      minMax = this._getAccessorMinMax(sourceBuffer, accessor.size);\n    }\n    const accessorDefaults = {\n      size: accessor.size,\n      componentType: getComponentTypeFromArray(sourceBuffer),\n      count: Math.round(sourceBuffer.length / accessor.size),\n      min: minMax.min,\n      max: minMax.max\n    };\n    return this.addAccessor(bufferViewIndex, Object.assign(accessorDefaults, accessor));\n  }\n\n  addTexture(texture) {\n    const {\n      imageIndex\n    } = texture;\n    const glTFTexture = {\n      source: imageIndex\n    };\n    this.json.textures = this.json.textures || [];\n    this.json.textures.push(glTFTexture);\n    return this.json.textures.length - 1;\n  }\n\n  addMaterial(pbrMaterialInfo) {\n    this.json.materials = this.json.materials || [];\n    this.json.materials.push(pbrMaterialInfo);\n    return this.json.materials.length - 1;\n  }\n\n  createBinaryChunk() {\n    var _this$json, _this$json$buffers;\n    this.gltf.buffers = [];\n\n    const totalByteLength = this.byteLength;\n    const arrayBuffer = new ArrayBuffer(totalByteLength);\n    const targetArray = new Uint8Array(arrayBuffer);\n\n    let dstByteOffset = 0;\n    for (const sourceBuffer of this.sourceBuffers || []) {\n      dstByteOffset = copyToArray(sourceBuffer, targetArray, dstByteOffset);\n    }\n\n    if ((_this$json = this.json) !== null && _this$json !== void 0 && (_this$json$buffers = _this$json.buffers) !== null && _this$json$buffers !== void 0 && _this$json$buffers[0]) {\n      this.json.buffers[0].byteLength = totalByteLength;\n    } else {\n      this.json.buffers = [{\n        byteLength: totalByteLength\n      }];\n    }\n\n    this.gltf.binary = arrayBuffer;\n\n    this.sourceBuffers = [arrayBuffer];\n  }\n\n  _removeStringFromArray(array, string) {\n    let found = true;\n    while (found) {\n      const index = array.indexOf(string);\n      if (index > -1) {\n        array.splice(index, 1);\n      } else {\n        found = false;\n      }\n    }\n  }\n\n  _addAttributes() {\n    let attributes = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    const result = {};\n    for (const attributeKey in attributes) {\n      const attributeData = attributes[attributeKey];\n      const attrName = this._getGltfAttributeName(attributeKey);\n      const accessor = this.addBinaryBuffer(attributeData.value, attributeData);\n      result[attrName] = accessor;\n    }\n    return result;\n  }\n\n  _addIndices(indices) {\n    return this.addBinaryBuffer(indices, {\n      size: 1\n    });\n  }\n\n  _getGltfAttributeName(attributeName) {\n    switch (attributeName.toLowerCase()) {\n      case 'position':\n      case 'positions':\n      case 'vertices':\n        return 'POSITION';\n      case 'normal':\n      case 'normals':\n        return 'NORMAL';\n      case 'color':\n      case 'colors':\n        return 'COLOR_0';\n      case 'texcoord':\n      case 'texcoords':\n        return 'TEXCOORD_0';\n      default:\n        return attributeName;\n    }\n  }\n\n  _getAccessorMinMax(buffer, size) {\n    const result = {\n      min: null,\n      max: null\n    };\n    if (buffer.length < size) {\n      return result;\n    }\n    result.min = [];\n    result.max = [];\n    const initValues = buffer.subarray(0, size);\n    for (const value of initValues) {\n      result.min.push(value);\n      result.max.push(value);\n    }\n    for (let index = size; index < buffer.length; index += size) {\n      for (let componentIndex = 0; componentIndex < size; componentIndex++) {\n        result.min[0 + componentIndex] = Math.min(\n        result.min[0 + componentIndex], buffer[index + componentIndex]);\n        result.max[0 + componentIndex] = Math.max(\n        result.max[0 + componentIndex], buffer[index + componentIndex]);\n      }\n    }\n    return result;\n  }\n}\n//# sourceMappingURL=gltf-scenegraph.js.map\n;// CONCATENATED MODULE: ./node_modules/@loaders.gl/gltf/dist/esm/meshopt/meshopt-decoder.js\n\n\nconst isWebAssemblySupported = typeof WebAssembly !== 'object';\n\nconst wasm_base = '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';\nconst wasm_simd = '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';\n\nconst detector = new Uint8Array([0, 97, 115, 109, 1, 0, 0, 0, 1, 4, 1, 96, 0, 0, 3, 3, 2, 0, 0, 5, 3, 1, 0, 1, 12, 1, 0, 10, 22, 2, 12, 0, 65, 0, 65, 0, 65, 0, 252, 10, 0, 0, 11, 7, 0, 65, 0, 253, 15, 26, 11]);\n\nconst wasmpack = new Uint8Array([32, 0, 65, 253, 3, 1, 2, 34, 4, 106, 6, 5, 11, 8, 7, 20, 13, 33, 12, 16, 128, 9, 116, 64, 19, 113, 127, 15, 10, 21, 22, 14, 255, 66, 24, 54, 136, 107, 18, 23, 192, 26, 114, 118, 132, 17, 77, 101, 130, 144, 27, 87, 131, 44, 45, 74, 156, 154, 70, 167]);\nconst FILTERS = {\n  0: '',\n  1: 'meshopt_decodeFilterOct',\n  2: 'meshopt_decodeFilterQuat',\n  3: 'meshopt_decodeFilterExp',\n  NONE: '',\n  OCTAHEDRAL: 'meshopt_decodeFilterOct',\n  QUATERNION: 'meshopt_decodeFilterQuat',\n  EXPONENTIAL: 'meshopt_decodeFilterExp'\n};\nconst DECODERS = {\n  0: 'meshopt_decodeVertexBuffer',\n  1: 'meshopt_decodeIndexBuffer',\n  2: 'meshopt_decodeIndexSequence',\n  ATTRIBUTES: 'meshopt_decodeVertexBuffer',\n  TRIANGLES: 'meshopt_decodeIndexBuffer',\n  INDICES: 'meshopt_decodeIndexSequence'\n};\nfunction isMeshoptSupported() {\n  return isWebAssemblySupported;\n}\nasync function meshoptDecodeVertexBuffer(target, count, size, source) {\n  let filter = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 'NONE';\n  const instance = await loadWasmInstance();\n  decode(instance, instance.exports.meshopt_decodeVertexBuffer, target, count, size, source, instance.exports[FILTERS[filter]]);\n}\nasync function meshoptDecodeIndexBuffer(target, count, size, source) {\n  const instance = await loadWasmInstance();\n  decode(instance, instance.exports.meshopt_decodeIndexBuffer, target, count, size, source);\n}\nasync function meshoptDecodeIndexSequence(target, count, size, source) {\n  const instance = await loadWasmInstance();\n  decode(instance, instance.exports.meshopt_decodeIndexSequence, target, count, size, source);\n}\n\nasync function meshoptDecodeGltfBuffer(target, count, size, source, mode) {\n  let filter = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 'NONE';\n  const instance = await loadWasmInstance();\n  decode(instance, instance.exports[DECODERS[mode]], target, count, size, source, instance.exports[FILTERS[filter || 'NONE']]);\n}\nlet wasmPromise;\nasync function loadWasmInstance() {\n  if (!wasmPromise) {\n    wasmPromise = loadWasmModule();\n  }\n  return wasmPromise;\n}\nasync function loadWasmModule() {\n  let wasm = wasm_base;\n  if (WebAssembly.validate(detector)) {\n    wasm = wasm_simd;\n\n    console.log('Warning: meshopt_decoder is using experimental SIMD support');\n  }\n  const result = await WebAssembly.instantiate(unpack(wasm), {});\n  await result.instance.exports.__wasm_call_ctors();\n  return result.instance;\n}\nfunction unpack(data) {\n  const result = new Uint8Array(data.length);\n  for (let i = 0; i < data.length; ++i) {\n    const ch = data.charCodeAt(i);\n    result[i] = ch > 96 ? ch - 71 : ch > 64 ? ch - 65 : ch > 47 ? ch + 4 : ch > 46 ? 63 : 62;\n  }\n  let write = 0;\n  for (let i = 0; i < data.length; ++i) {\n    result[write++] = result[i] < 60 ? wasmpack[result[i]] : (result[i] - 60) * 64 + result[++i];\n  }\n  return result.buffer.slice(0, write);\n}\n\nfunction decode(instance, fun, target, count, size, source, filter) {\n  const sbrk = instance.exports.sbrk;\n  const count4 = count + 3 & ~3;\n  const tp = sbrk(count4 * size);\n  const sp = sbrk(source.length);\n  const heap = new Uint8Array(instance.exports.memory.buffer);\n  heap.set(source, sp);\n  const res = fun(tp, count, size, sp, source.length);\n  if (res === 0 && filter) {\n    filter(tp, count4, size);\n  }\n  target.set(heap.subarray(tp, tp + count * size));\n  sbrk(tp - sbrk(0));\n  if (res !== 0) {\n    throw new Error(\"Malformed buffer data: \".concat(res));\n  }\n}\n//# sourceMappingURL=meshopt-decoder.js.map\n;// CONCATENATED MODULE: ./node_modules/@loaders.gl/gltf/dist/esm/lib/extensions/EXT_meshopt_compression.js\n\n\n\n\n\nconst DEFAULT_MESHOPT_OPTIONS = {\n  byteOffset: 0,\n  filter: 'NONE'\n};\n\nconst EXT_MESHOPT_COMPRESSION = 'EXT_meshopt_compression';\nconst EXT_meshopt_compression_name = EXT_MESHOPT_COMPRESSION;\nasync function EXT_meshopt_compression_decode(gltfData, options) {\n  var _options$gltf;\n  const scenegraph = new GLTFScenegraph(gltfData);\n  if (!(options !== null && options !== void 0 && (_options$gltf = options.gltf) !== null && _options$gltf !== void 0 && _options$gltf.decompressMeshes)) {\n    return;\n  }\n  const promises = [];\n  for (const bufferViewIndex of gltfData.json.bufferViews || []) {\n    promises.push(decodeMeshoptBufferView(scenegraph, bufferViewIndex));\n  }\n\n  await Promise.all(promises);\n\n  scenegraph.removeExtension(EXT_MESHOPT_COMPRESSION);\n}\n\nasync function decodeMeshoptBufferView(scenegraph, bufferView) {\n  const meshoptExtension = scenegraph.getObjectExtension(bufferView, EXT_MESHOPT_COMPRESSION);\n  if (meshoptExtension) {\n    const {\n      byteOffset = 0,\n      byteLength = 0,\n      byteStride,\n      count,\n      mode,\n      filter = 'NONE',\n      buffer: bufferIndex\n    } = meshoptExtension;\n    const buffer = scenegraph.gltf.buffers[bufferIndex];\n    const source = new Uint8Array(buffer.arrayBuffer, buffer.byteOffset + byteOffset, byteLength);\n    const result = new Uint8Array(scenegraph.gltf.buffers[bufferView.buffer].arrayBuffer, bufferView.byteOffset, bufferView.byteLength);\n    await meshoptDecodeGltfBuffer(result, count, byteStride, source, mode, filter);\n    return result;\n  }\n  return null;\n}\n//# sourceMappingURL=EXT_meshopt_compression.js.map\n// EXTERNAL MODULE: ./node_modules/@loaders.gl/loader-utils/dist/esm/lib/env-utils/globals.js\nvar env_utils_globals = __webpack_require__(84959);\n;// CONCATENATED MODULE: ./node_modules/@loaders.gl/images/dist/esm/lib/category-api/image-format.js\n\n\nconst NODE_FORMAT_SUPPORT = ['image/png', 'image/jpeg', 'image/gif'];\n\nconst mimeTypeSupported = {};\n\nfunction _isImageFormatSupported(mimeType) {\n  if (mimeTypeSupported[mimeType] === undefined) {\n    mimeTypeSupported[mimeType] = checkFormatSupport(mimeType);\n  }\n  return mimeTypeSupported[mimeType];\n}\n\nfunction checkFormatSupport(mimeType) {\n  switch (mimeType) {\n    case 'image/webp':\n      return checkWebPSupport();\n    case 'image/svg':\n      return env_utils_globals/* isBrowser */.jU;\n    default:\n      if (!env_utils_globals/* isBrowser */.jU) {\n        const {\n          _parseImageNode\n        } = globalThis;\n        return Boolean(_parseImageNode) && NODE_FORMAT_SUPPORT.includes(mimeType);\n      }\n      return true;\n  }\n}\n\nfunction checkWebPSupport() {\n  if (!env_utils_globals/* isBrowser */.jU) {\n    return false;\n  }\n  try {\n    const element = document.createElement('canvas');\n    return element.toDataURL('image/webp').indexOf('data:image/webp') === 0;\n  } catch {\n    return false;\n  }\n}\n//# sourceMappingURL=image-format.js.map\n;// CONCATENATED MODULE: ./node_modules/@loaders.gl/gltf/dist/esm/lib/extensions/EXT_texture_webp.js\n\n\n\n\nconst EXT_TEXTURE_WEBP = 'EXT_texture_webp';\n\nconst EXT_texture_webp_name = EXT_TEXTURE_WEBP;\n\nfunction preprocess(gltfData, options) {\n  const scenegraph = new GLTFScenegraph(gltfData);\n  if (!_isImageFormatSupported('image/webp')) {\n    if (scenegraph.getRequiredExtensions().includes(EXT_TEXTURE_WEBP)) {\n      throw new Error(\"gltf: Required extension \".concat(EXT_TEXTURE_WEBP, \" not supported by browser\"));\n    }\n    return;\n  }\n  const {\n    json\n  } = scenegraph;\n  for (const texture of json.textures || []) {\n    const extension = scenegraph.getObjectExtension(texture, EXT_TEXTURE_WEBP);\n    if (extension) {\n      texture.source = extension.source;\n    }\n    scenegraph.removeObjectExtension(texture, EXT_TEXTURE_WEBP);\n  }\n\n  scenegraph.removeExtension(EXT_TEXTURE_WEBP);\n}\n//# sourceMappingURL=EXT_texture_webp.js.map\n;// CONCATENATED MODULE: ./node_modules/@loaders.gl/gltf/dist/esm/lib/extensions/KHR_texture_basisu.js\n\n\n\nconst KHR_TEXTURE_BASISU = 'KHR_texture_basisu';\n\nconst KHR_texture_basisu_name = KHR_TEXTURE_BASISU;\n\nfunction KHR_texture_basisu_preprocess(gltfData, options) {\n  const scene = new GLTFScenegraph(gltfData);\n  const {\n    json\n  } = scene;\n  for (const texture of json.textures || []) {\n    const extension = scene.getObjectExtension(texture, KHR_TEXTURE_BASISU);\n    if (extension) {\n      texture.source = extension.source;\n    }\n    scene.removeObjectExtension(texture, KHR_TEXTURE_BASISU);\n  }\n\n  scene.removeExtension(KHR_TEXTURE_BASISU);\n}\n//# sourceMappingURL=KHR_texture_basisu.js.map\n;// CONCATENATED MODULE: ./node_modules/@loaders.gl/draco/dist/esm/lib/utils/version.js\n\nconst utils_version_VERSION =  true ? \"3.3.1\" : 0;\n//# sourceMappingURL=version.js.map\n;// CONCATENATED MODULE: ./node_modules/@loaders.gl/draco/dist/esm/draco-loader.js\n\n\nconst DEFAULT_DRACO_OPTIONS = {\n  draco: {\n    decoderType: typeof WebAssembly === 'object' ? 'wasm' : 'js',\n    libraryPath: 'libs/',\n    extraAttributes: {},\n    attributeNameEntry: undefined\n  }\n};\n\nconst DracoLoader = {\n  name: 'Draco',\n  id: globals/* isBrowser */.jU ? 'draco' : 'draco-nodejs',\n  module: 'draco',\n  shapes: ['mesh'],\n  version: utils_version_VERSION,\n  worker: true,\n  extensions: ['drc'],\n  mimeTypes: ['application/octet-stream'],\n  binary: true,\n  tests: ['DRACO'],\n  options: DEFAULT_DRACO_OPTIONS\n};\nconst _TypecheckDracoLoader = (/* unused pure expression or super */ null && (DracoLoader));\n//# sourceMappingURL=draco-loader.js.map\n;// CONCATENATED MODULE: ./node_modules/@loaders.gl/schema/dist/esm/category/mesh/mesh-utils.js\n\n\nfunction getMeshSize(attributes) {\n  let size = 0;\n  for (const attributeName in attributes) {\n    const attribute = attributes[attributeName];\n    if (ArrayBuffer.isView(attribute)) {\n      size += attribute.byteLength * attribute.BYTES_PER_ELEMENT;\n    }\n  }\n  return size;\n}\n\nfunction getMeshBoundingBox(attributes) {\n  let minX = Infinity;\n  let minY = Infinity;\n  let minZ = Infinity;\n  let maxX = -Infinity;\n  let maxY = -Infinity;\n  let maxZ = -Infinity;\n  const positions = attributes.POSITION ? attributes.POSITION.value : [];\n  const len = positions && positions.length;\n  for (let i = 0; i < len; i += 3) {\n    const x = positions[i];\n    const y = positions[i + 1];\n    const z = positions[i + 2];\n    minX = x < minX ? x : minX;\n    minY = y < minY ? y : minY;\n    minZ = z < minZ ? z : minZ;\n    maxX = x > maxX ? x : maxX;\n    maxY = y > maxY ? y : maxY;\n    maxZ = z > maxZ ? z : maxZ;\n  }\n  return [[minX, minY, minZ], [maxX, maxY, maxZ]];\n}\n//# sourceMappingURL=mesh-utils.js.map\n;// CONCATENATED MODULE: ./node_modules/@loaders.gl/schema/dist/esm/lib/schema/impl/field.js\n\nclass Field {\n  constructor(name, type) {\n    let nullable = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n    let metadata = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : new Map();\n    (0,defineProperty/* default */.Z)(this, \"name\", void 0);\n    (0,defineProperty/* default */.Z)(this, \"type\", void 0);\n    (0,defineProperty/* default */.Z)(this, \"nullable\", void 0);\n    (0,defineProperty/* default */.Z)(this, \"metadata\", void 0);\n    this.name = name;\n    this.type = type;\n    this.nullable = nullable;\n    this.metadata = metadata;\n  }\n  get typeId() {\n    return this.type && this.type.typeId;\n  }\n  clone() {\n    return new Field(this.name, this.type, this.nullable, this.metadata);\n  }\n  compareTo(other) {\n    return this.name === other.name && this.type === other.type && this.nullable === other.nullable && this.metadata === other.metadata;\n  }\n  toString() {\n    return \"\".concat(this.type).concat(this.nullable ? ', nullable' : '').concat(this.metadata ? \", metadata: \".concat(this.metadata) : '');\n  }\n}\n//# sourceMappingURL=field.js.map\n;// CONCATENATED MODULE: ./node_modules/@loaders.gl/schema/dist/esm/lib/schema/impl/enum.js\n\n\nlet enum_Type;\n(function (Type) {\n  Type[Type[\"NONE\"] = 0] = \"NONE\";\n  Type[Type[\"Null\"] = 1] = \"Null\";\n  Type[Type[\"Int\"] = 2] = \"Int\";\n  Type[Type[\"Float\"] = 3] = \"Float\";\n  Type[Type[\"Binary\"] = 4] = \"Binary\";\n  Type[Type[\"Utf8\"] = 5] = \"Utf8\";\n  Type[Type[\"Bool\"] = 6] = \"Bool\";\n  Type[Type[\"Decimal\"] = 7] = \"Decimal\";\n  Type[Type[\"Date\"] = 8] = \"Date\";\n  Type[Type[\"Time\"] = 9] = \"Time\";\n  Type[Type[\"Timestamp\"] = 10] = \"Timestamp\";\n  Type[Type[\"Interval\"] = 11] = \"Interval\";\n  Type[Type[\"List\"] = 12] = \"List\";\n  Type[Type[\"Struct\"] = 13] = \"Struct\";\n  Type[Type[\"Union\"] = 14] = \"Union\";\n  Type[Type[\"FixedSizeBinary\"] = 15] = \"FixedSizeBinary\";\n  Type[Type[\"FixedSizeList\"] = 16] = \"FixedSizeList\";\n  Type[Type[\"Map\"] = 17] = \"Map\";\n  Type[Type[\"Dictionary\"] = -1] = \"Dictionary\";\n  Type[Type[\"Int8\"] = -2] = \"Int8\";\n  Type[Type[\"Int16\"] = -3] = \"Int16\";\n  Type[Type[\"Int32\"] = -4] = \"Int32\";\n  Type[Type[\"Int64\"] = -5] = \"Int64\";\n  Type[Type[\"Uint8\"] = -6] = \"Uint8\";\n  Type[Type[\"Uint16\"] = -7] = \"Uint16\";\n  Type[Type[\"Uint32\"] = -8] = \"Uint32\";\n  Type[Type[\"Uint64\"] = -9] = \"Uint64\";\n  Type[Type[\"Float16\"] = -10] = \"Float16\";\n  Type[Type[\"Float32\"] = -11] = \"Float32\";\n  Type[Type[\"Float64\"] = -12] = \"Float64\";\n  Type[Type[\"DateDay\"] = -13] = \"DateDay\";\n  Type[Type[\"DateMillisecond\"] = -14] = \"DateMillisecond\";\n  Type[Type[\"TimestampSecond\"] = -15] = \"TimestampSecond\";\n  Type[Type[\"TimestampMillisecond\"] = -16] = \"TimestampMillisecond\";\n  Type[Type[\"TimestampMicrosecond\"] = -17] = \"TimestampMicrosecond\";\n  Type[Type[\"TimestampNanosecond\"] = -18] = \"TimestampNanosecond\";\n  Type[Type[\"TimeSecond\"] = -19] = \"TimeSecond\";\n  Type[Type[\"TimeMillisecond\"] = -20] = \"TimeMillisecond\";\n  Type[Type[\"TimeMicrosecond\"] = -21] = \"TimeMicrosecond\";\n  Type[Type[\"TimeNanosecond\"] = -22] = \"TimeNanosecond\";\n  Type[Type[\"DenseUnion\"] = -23] = \"DenseUnion\";\n  Type[Type[\"SparseUnion\"] = -24] = \"SparseUnion\";\n  Type[Type[\"IntervalDayTime\"] = -25] = \"IntervalDayTime\";\n  Type[Type[\"IntervalYearMonth\"] = -26] = \"IntervalYearMonth\";\n})(enum_Type || (enum_Type = {}));\n//# sourceMappingURL=enum.js.map\n;// CONCATENATED MODULE: ./node_modules/@loaders.gl/schema/dist/esm/lib/schema/impl/type.js\n\nlet _Symbol$toStringTag, _Symbol$toStringTag2, _Symbol$toStringTag3, _Symbol$toStringTag4, _Symbol$toStringTag5, _Symbol$toStringTag6, _Symbol$toStringTag7, _Symbol$toStringTag8;\n\n\n\nclass DataType {\n  static isNull(x) {\n    return x && x.typeId === enum_Type.Null;\n  }\n  static isInt(x) {\n    return x && x.typeId === enum_Type.Int;\n  }\n  static isFloat(x) {\n    return x && x.typeId === enum_Type.Float;\n  }\n  static isBinary(x) {\n    return x && x.typeId === enum_Type.Binary;\n  }\n  static isUtf8(x) {\n    return x && x.typeId === enum_Type.Utf8;\n  }\n  static isBool(x) {\n    return x && x.typeId === enum_Type.Bool;\n  }\n  static isDecimal(x) {\n    return x && x.typeId === enum_Type.Decimal;\n  }\n  static isDate(x) {\n    return x && x.typeId === enum_Type.Date;\n  }\n  static isTime(x) {\n    return x && x.typeId === enum_Type.Time;\n  }\n  static isTimestamp(x) {\n    return x && x.typeId === enum_Type.Timestamp;\n  }\n  static isInterval(x) {\n    return x && x.typeId === enum_Type.Interval;\n  }\n  static isList(x) {\n    return x && x.typeId === enum_Type.List;\n  }\n  static isStruct(x) {\n    return x && x.typeId === enum_Type.Struct;\n  }\n  static isUnion(x) {\n    return x && x.typeId === enum_Type.Union;\n  }\n  static isFixedSizeBinary(x) {\n    return x && x.typeId === enum_Type.FixedSizeBinary;\n  }\n  static isFixedSizeList(x) {\n    return x && x.typeId === enum_Type.FixedSizeList;\n  }\n  static isMap(x) {\n    return x && x.typeId === enum_Type.Map;\n  }\n  static isDictionary(x) {\n    return x && x.typeId === enum_Type.Dictionary;\n  }\n  get typeId() {\n    return enum_Type.NONE;\n  }\n\n  compareTo(other) {\n    return this === other;\n  }\n}\n\nclass Null extends (/* unused pure expression or super */ null && (DataType)) {\n  get typeId() {\n    return Type.Null;\n  }\n  get [Symbol.toStringTag]() {\n    return 'Null';\n  }\n  toString() {\n    return 'Null';\n  }\n}\n\nclass Bool extends (/* unused pure expression or super */ null && (DataType)) {\n  get typeId() {\n    return Type.Bool;\n  }\n  get [Symbol.toStringTag]() {\n    return 'Bool';\n  }\n  toString() {\n    return 'Bool';\n  }\n}\n\n_Symbol$toStringTag = Symbol.toStringTag;\n\nclass Int extends DataType {\n  constructor(isSigned, bitWidth) {\n    super();\n    (0,defineProperty/* default */.Z)(this, \"isSigned\", void 0);\n    (0,defineProperty/* default */.Z)(this, \"bitWidth\", void 0);\n    this.isSigned = isSigned;\n    this.bitWidth = bitWidth;\n  }\n  get typeId() {\n    return enum_Type.Int;\n  }\n  get [_Symbol$toStringTag]() {\n    return 'Int';\n  }\n  toString() {\n    return \"\".concat(this.isSigned ? 'I' : 'Ui', \"nt\").concat(this.bitWidth);\n  }\n}\nclass Int8 extends Int {\n  constructor() {\n    super(true, 8);\n  }\n}\nclass Int16 extends Int {\n  constructor() {\n    super(true, 16);\n  }\n}\nclass Int32 extends Int {\n  constructor() {\n    super(true, 32);\n  }\n}\nclass Int64 extends (/* unused pure expression or super */ null && (Int)) {\n  constructor() {\n    super(true, 64);\n  }\n}\nclass Uint8 extends Int {\n  constructor() {\n    super(false, 8);\n  }\n}\nclass Uint16 extends Int {\n  constructor() {\n    super(false, 16);\n  }\n}\nclass Uint32 extends Int {\n  constructor() {\n    super(false, 32);\n  }\n}\nclass Uint64 extends (/* unused pure expression or super */ null && (Int)) {\n  constructor() {\n    super(false, 64);\n  }\n}\n\nconst Precision = {\n  HALF: 16,\n  SINGLE: 32,\n  DOUBLE: 64\n};\n_Symbol$toStringTag2 = Symbol.toStringTag;\nclass Float extends DataType {\n  constructor(precision) {\n    super();\n    (0,defineProperty/* default */.Z)(this, \"precision\", void 0);\n    this.precision = precision;\n  }\n  get typeId() {\n    return enum_Type.Float;\n  }\n  get [_Symbol$toStringTag2]() {\n    return 'Float';\n  }\n  toString() {\n    return \"Float\".concat(this.precision);\n  }\n}\nclass Float16 extends (/* unused pure expression or super */ null && (Float)) {\n  constructor() {\n    super(Precision.HALF);\n  }\n}\nclass Float32 extends Float {\n  constructor() {\n    super(Precision.SINGLE);\n  }\n}\nclass Float64 extends Float {\n  constructor() {\n    super(Precision.DOUBLE);\n  }\n}\nclass Binary extends (/* unused pure expression or super */ null && (DataType)) {\n  constructor() {\n    super();\n  }\n  get typeId() {\n    return Type.Binary;\n  }\n  toString() {\n    return 'Binary';\n  }\n  get [Symbol.toStringTag]() {\n    return 'Binary';\n  }\n}\n\nclass Utf8 extends (/* unused pure expression or super */ null && (DataType)) {\n  get typeId() {\n    return Type.Utf8;\n  }\n  get [Symbol.toStringTag]() {\n    return 'Utf8';\n  }\n  toString() {\n    return 'Utf8';\n  }\n}\n\nconst DateUnit = {\n  DAY: 0,\n  MILLISECOND: 1\n};\n_Symbol$toStringTag3 = Symbol.toStringTag;\nclass type_Date extends (/* unused pure expression or super */ null && (DataType)) {\n  constructor(unit) {\n    super();\n    _defineProperty(this, \"unit\", void 0);\n    this.unit = unit;\n  }\n  get typeId() {\n    return Type.Date;\n  }\n  get [_Symbol$toStringTag3]() {\n    return 'Date';\n  }\n  toString() {\n    return \"Date\".concat((this.unit + 1) * 32, \"<\").concat(DateUnit[this.unit], \">\");\n  }\n}\nclass DateDay extends (/* unused pure expression or super */ null && (type_Date)) {\n  constructor() {\n    super(DateUnit.DAY);\n  }\n}\nclass DateMillisecond extends (/* unused pure expression or super */ null && (type_Date)) {\n  constructor() {\n    super(DateUnit.MILLISECOND);\n  }\n}\nconst TimeUnit = {\n  SECOND: 1,\n  MILLISECOND: 1e3,\n  MICROSECOND: 1e6,\n  NANOSECOND: 1e9\n};\n_Symbol$toStringTag4 = Symbol.toStringTag;\nclass Time extends (/* unused pure expression or super */ null && (DataType)) {\n  constructor(unit, bitWidth) {\n    super();\n    _defineProperty(this, \"unit\", void 0);\n    _defineProperty(this, \"bitWidth\", void 0);\n    this.unit = unit;\n    this.bitWidth = bitWidth;\n  }\n  get typeId() {\n    return Type.Time;\n  }\n  toString() {\n    return \"Time\".concat(this.bitWidth, \"<\").concat(TimeUnit[this.unit], \">\");\n  }\n  get [_Symbol$toStringTag4]() {\n    return 'Time';\n  }\n}\n\nclass TimeSecond extends (/* unused pure expression or super */ null && (Time)) {\n  constructor() {\n    super(TimeUnit.SECOND, 32);\n  }\n}\nclass TimeMillisecond extends (/* unused pure expression or super */ null && (Time)) {\n  constructor() {\n    super(TimeUnit.MILLISECOND, 32);\n  }\n}\n_Symbol$toStringTag5 = Symbol.toStringTag;\n\nclass Timestamp extends (/* unused pure expression or super */ null && (DataType)) {\n  constructor(unit) {\n    let timezone = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n    super();\n    _defineProperty(this, \"unit\", void 0);\n    _defineProperty(this, \"timezone\", void 0);\n    this.unit = unit;\n    this.timezone = timezone;\n  }\n  get typeId() {\n    return Type.Timestamp;\n  }\n  get [_Symbol$toStringTag5]() {\n    return 'Timestamp';\n  }\n  toString() {\n    return \"Timestamp<\".concat(TimeUnit[this.unit]).concat(this.timezone ? \", \".concat(this.timezone) : '', \">\");\n  }\n}\nclass TimestampSecond extends (/* unused pure expression or super */ null && (Timestamp)) {\n  constructor() {\n    let timezone = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n    super(TimeUnit.SECOND, timezone);\n  }\n}\nclass TimestampMillisecond extends (/* unused pure expression or super */ null && (Timestamp)) {\n  constructor() {\n    let timezone = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n    super(TimeUnit.MILLISECOND, timezone);\n  }\n}\nclass TimestampMicrosecond extends (/* unused pure expression or super */ null && (Timestamp)) {\n  constructor() {\n    let timezone = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n    super(TimeUnit.MICROSECOND, timezone);\n  }\n}\nclass TimestampNanosecond extends (/* unused pure expression or super */ null && (Timestamp)) {\n  constructor() {\n    let timezone = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n    super(TimeUnit.NANOSECOND, timezone);\n  }\n}\nconst IntervalUnit = {\n  DAY_TIME: 0,\n  YEAR_MONTH: 1\n};\n_Symbol$toStringTag6 = Symbol.toStringTag;\nclass Interval extends (/* unused pure expression or super */ null && (DataType)) {\n  constructor(unit) {\n    super();\n    _defineProperty(this, \"unit\", void 0);\n    this.unit = unit;\n  }\n  get typeId() {\n    return Type.Interval;\n  }\n  get [_Symbol$toStringTag6]() {\n    return 'Interval';\n  }\n  toString() {\n    return \"Interval<\".concat(IntervalUnit[this.unit], \">\");\n  }\n}\nclass IntervalDayTime extends (/* unused pure expression or super */ null && (Interval)) {\n  constructor() {\n    super(IntervalUnit.DAY_TIME);\n  }\n}\nclass IntervalYearMonth extends (/* unused pure expression or super */ null && (Interval)) {\n  constructor() {\n    super(IntervalUnit.YEAR_MONTH);\n  }\n}\n_Symbol$toStringTag7 = Symbol.toStringTag;\nclass FixedSizeList extends DataType {\n  constructor(listSize, child) {\n    super();\n    (0,defineProperty/* default */.Z)(this, \"listSize\", void 0);\n    (0,defineProperty/* default */.Z)(this, \"children\", void 0);\n    this.listSize = listSize;\n    this.children = [child];\n  }\n  get typeId() {\n    return enum_Type.FixedSizeList;\n  }\n  get valueType() {\n    return this.children[0].type;\n  }\n  get valueField() {\n    return this.children[0];\n  }\n  get [_Symbol$toStringTag7]() {\n    return 'FixedSizeList';\n  }\n  toString() {\n    return \"FixedSizeList[\".concat(this.listSize, \"]<\").concat(this.valueType, \">\");\n  }\n}\n_Symbol$toStringTag8 = Symbol.toStringTag;\nclass Struct extends (/* unused pure expression or super */ null && (DataType)) {\n  constructor(children) {\n    super();\n    _defineProperty(this, \"children\", void 0);\n    this.children = children;\n  }\n  get typeId() {\n    return Type.Struct;\n  }\n  toString() {\n    return \"Struct<{\".concat(this.children.map(f => \"\".concat(f.name, \":\").concat(f.type)).join(', '), \"}>\");\n  }\n  get [_Symbol$toStringTag8]() {\n    return 'Struct';\n  }\n}\n//# sourceMappingURL=type.js.map\n;// CONCATENATED MODULE: ./node_modules/@loaders.gl/schema/dist/esm/lib/arrow/arrow-like-type-utils.js\n\nfunction getArrowTypeFromTypedArray(array) {\n  switch (array.constructor) {\n    case Int8Array:\n      return new Int8();\n    case Uint8Array:\n      return new Uint8();\n    case Int16Array:\n      return new Int16();\n    case Uint16Array:\n      return new Uint16();\n    case Int32Array:\n      return new Int32();\n    case Uint32Array:\n      return new Uint32();\n    case Float32Array:\n      return new Float32();\n    case Float64Array:\n      return new Float64();\n    default:\n      throw new Error('array type not supported');\n  }\n}\n//# sourceMappingURL=arrow-like-type-utils.js.map\n;// CONCATENATED MODULE: ./node_modules/@loaders.gl/schema/dist/esm/category/mesh/deduce-mesh-schema.js\n\n\n\nfunction deduceMeshSchema(attributes, metadata) {\n  const fields = deduceMeshFields(attributes);\n  return new Schema(fields, metadata);\n}\n\nfunction deduceMeshField(attributeName, attribute, optionalMetadata) {\n  const type = getArrowTypeFromTypedArray(attribute.value);\n  const metadata = optionalMetadata ? optionalMetadata : makeMeshAttributeMetadata(attribute);\n  const field = new Field(attributeName, new FixedSizeList(attribute.size, new Field('value', type)), false, metadata);\n  return field;\n}\n\nfunction deduceMeshFields(attributes) {\n  const fields = [];\n  for (const attributeName in attributes) {\n    const attribute = attributes[attributeName];\n    fields.push(deduceMeshField(attributeName, attribute));\n  }\n  return fields;\n}\n\nfunction makeMeshAttributeMetadata(attribute) {\n  const result = new Map();\n  if ('byteOffset' in attribute) {\n    result.set('byteOffset', attribute.byteOffset.toString(10));\n  }\n  if ('byteStride' in attribute) {\n    result.set('byteStride', attribute.byteStride.toString(10));\n  }\n  if ('normalized' in attribute) {\n    result.set('normalized', attribute.normalized.toString());\n  }\n  return result;\n}\n//# sourceMappingURL=deduce-mesh-schema.js.map\n;// CONCATENATED MODULE: ./node_modules/@loaders.gl/schema/dist/esm/lib/utils/assert.js\n\nfunction utils_assert_assert(condition, message) {\n  if (!condition) {\n    throw new Error(message || 'loader assertion failed.');\n  }\n}\n//# sourceMappingURL=assert.js.map\n;// CONCATENATED MODULE: ./node_modules/@loaders.gl/schema/dist/esm/lib/schema/impl/schema.js\n\n\nclass schema_Schema {\n\n  constructor(fields, metadata) {\n    (0,defineProperty/* default */.Z)(this, \"fields\", void 0);\n    (0,defineProperty/* default */.Z)(this, \"metadata\", void 0);\n    utils_assert_assert(Array.isArray(fields));\n    checkNames(fields);\n    this.fields = fields;\n    this.metadata = metadata || new Map();\n  }\n\n  compareTo(other) {\n    if (this.metadata !== other.metadata) {\n      return false;\n    }\n    if (this.fields.length !== other.fields.length) {\n      return false;\n    }\n    for (let i = 0; i < this.fields.length; ++i) {\n      if (!this.fields[i].compareTo(other.fields[i])) {\n        return false;\n      }\n    }\n    return true;\n  }\n  select() {\n    const nameMap = Object.create(null);\n    for (var _len = arguments.length, columnNames = new Array(_len), _key = 0; _key < _len; _key++) {\n      columnNames[_key] = arguments[_key];\n    }\n    for (const name of columnNames) {\n      nameMap[name] = true;\n    }\n    const selectedFields = this.fields.filter(field => nameMap[field.name]);\n    return new schema_Schema(selectedFields, this.metadata);\n  }\n  selectAt() {\n    for (var _len2 = arguments.length, columnIndices = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n      columnIndices[_key2] = arguments[_key2];\n    }\n    const selectedFields = columnIndices.map(index => this.fields[index]).filter(Boolean);\n    return new schema_Schema(selectedFields, this.metadata);\n  }\n  assign(schemaOrFields) {\n    let fields;\n    let metadata = this.metadata;\n    if (schemaOrFields instanceof schema_Schema) {\n      const otherSchema = schemaOrFields;\n      fields = otherSchema.fields;\n      metadata = mergeMaps(mergeMaps(new Map(), this.metadata), otherSchema.metadata);\n    } else {\n      fields = schemaOrFields;\n    }\n\n    const fieldMap = Object.create(null);\n    for (const field of this.fields) {\n      fieldMap[field.name] = field;\n    }\n    for (const field of fields) {\n      fieldMap[field.name] = field;\n    }\n    const mergedFields = Object.values(fieldMap);\n    return new schema_Schema(mergedFields, metadata);\n  }\n}\n\nfunction checkNames(fields) {\n  const usedNames = {};\n  for (const field of fields) {\n    if (usedNames[field.name]) {\n      console.warn('Schema: duplicated field name', field.name, field);\n    }\n    usedNames[field.name] = true;\n  }\n}\nfunction mergeMaps(m1, m2) {\n  return new Map([...(m1 || new Map()), ...(m2 || new Map())]);\n}\n//# sourceMappingURL=schema.js.map\n;// CONCATENATED MODULE: ./node_modules/@loaders.gl/draco/dist/esm/lib/utils/get-draco-schema.js\n\n\nfunction getDracoSchema(attributes, loaderData, indices) {\n  const metadataMap = makeMetadata(loaderData.metadata);\n  const fields = [];\n  const namedLoaderDataAttributes = transformAttributesLoaderData(loaderData.attributes);\n  for (const attributeName in attributes) {\n    const attribute = attributes[attributeName];\n    const field = getArrowFieldFromAttribute(attributeName, attribute, namedLoaderDataAttributes[attributeName]);\n    fields.push(field);\n  }\n  if (indices) {\n    const indicesField = getArrowFieldFromAttribute('indices', indices);\n    fields.push(indicesField);\n  }\n  return new schema_Schema(fields, metadataMap);\n}\nfunction transformAttributesLoaderData(loaderData) {\n  const result = {};\n  for (const key in loaderData) {\n    const dracoAttribute = loaderData[key];\n    result[dracoAttribute.name || 'undefined'] = dracoAttribute;\n  }\n  return result;\n}\nfunction getArrowFieldFromAttribute(attributeName, attribute, loaderData) {\n  const metadataMap = loaderData ? makeMetadata(loaderData.metadata) : undefined;\n  const field = deduceMeshField(attributeName, attribute, metadataMap);\n  return field;\n}\nfunction makeMetadata(metadata) {\n  const metadataMap = new Map();\n  for (const key in metadata) {\n    metadataMap.set(\"\".concat(key, \".string\"), JSON.stringify(metadata[key]));\n  }\n  return metadataMap;\n}\n//# sourceMappingURL=get-draco-schema.js.map\n;// CONCATENATED MODULE: ./node_modules/@loaders.gl/draco/dist/esm/lib/draco-parser.js\n\n\n\n\n\nconst GEOMETRY_TYPE = {\n  TRIANGULAR_MESH: 0,\n  POINT_CLOUD: 1\n};\n\nconst DRACO_TO_GLTF_ATTRIBUTE_NAME_MAP = {\n  POSITION: 'POSITION',\n  NORMAL: 'NORMAL',\n  COLOR: 'COLOR_0',\n  TEX_COORD: 'TEXCOORD_0'\n};\nconst DRACO_DATA_TYPE_TO_TYPED_ARRAY_MAP = {\n  1: Int8Array,\n  2: Uint8Array,\n  3: Int16Array,\n  4: Uint16Array,\n  5: Int32Array,\n  6: Uint32Array,\n  9: Float32Array\n};\nconst INDEX_ITEM_SIZE = 4;\nclass DracoParser {\n  constructor(draco) {\n    (0,defineProperty/* default */.Z)(this, \"draco\", void 0);\n    (0,defineProperty/* default */.Z)(this, \"decoder\", void 0);\n    (0,defineProperty/* default */.Z)(this, \"metadataQuerier\", void 0);\n    this.draco = draco;\n    this.decoder = new this.draco.Decoder();\n    this.metadataQuerier = new this.draco.MetadataQuerier();\n  }\n\n  destroy() {\n    this.draco.destroy(this.decoder);\n    this.draco.destroy(this.metadataQuerier);\n  }\n\n  parseSync(arrayBuffer) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    const buffer = new this.draco.DecoderBuffer();\n    buffer.Init(new Int8Array(arrayBuffer), arrayBuffer.byteLength);\n    this._disableAttributeTransforms(options);\n    const geometry_type = this.decoder.GetEncodedGeometryType(buffer);\n    const dracoGeometry = geometry_type === this.draco.TRIANGULAR_MESH ? new this.draco.Mesh() : new this.draco.PointCloud();\n    try {\n      let dracoStatus;\n      switch (geometry_type) {\n        case this.draco.TRIANGULAR_MESH:\n          dracoStatus = this.decoder.DecodeBufferToMesh(buffer, dracoGeometry);\n          break;\n        case this.draco.POINT_CLOUD:\n          dracoStatus = this.decoder.DecodeBufferToPointCloud(buffer, dracoGeometry);\n          break;\n        default:\n          throw new Error('DRACO: Unknown geometry type.');\n      }\n      if (!dracoStatus.ok() || !dracoGeometry.ptr) {\n        const message = \"DRACO decompression failed: \".concat(dracoStatus.error_msg());\n        throw new Error(message);\n      }\n      const loaderData = this._getDracoLoaderData(dracoGeometry, geometry_type, options);\n      const geometry = this._getMeshData(dracoGeometry, loaderData, options);\n      const boundingBox = getMeshBoundingBox(geometry.attributes);\n      const schema = getDracoSchema(geometry.attributes, loaderData, geometry.indices);\n      const data = {\n        loader: 'draco',\n        loaderData,\n        header: {\n          vertexCount: dracoGeometry.num_points(),\n          boundingBox\n        },\n        ...geometry,\n        schema\n      };\n      return data;\n    } finally {\n      this.draco.destroy(buffer);\n      if (dracoGeometry) {\n        this.draco.destroy(dracoGeometry);\n      }\n    }\n  }\n\n  _getDracoLoaderData(dracoGeometry, geometry_type, options) {\n    const metadata = this._getTopLevelMetadata(dracoGeometry);\n    const attributes = this._getDracoAttributes(dracoGeometry, options);\n    return {\n      geometry_type,\n      num_attributes: dracoGeometry.num_attributes(),\n      num_points: dracoGeometry.num_points(),\n      num_faces: dracoGeometry instanceof this.draco.Mesh ? dracoGeometry.num_faces() : 0,\n      metadata,\n      attributes\n    };\n  }\n\n  _getDracoAttributes(dracoGeometry, options) {\n    const dracoAttributes = {};\n    for (let attributeId = 0; attributeId < dracoGeometry.num_attributes(); attributeId++) {\n      const dracoAttribute = this.decoder.GetAttribute(dracoGeometry, attributeId);\n      const metadata = this._getAttributeMetadata(dracoGeometry, attributeId);\n      dracoAttributes[dracoAttribute.unique_id()] = {\n        unique_id: dracoAttribute.unique_id(),\n        attribute_type: dracoAttribute.attribute_type(),\n        data_type: dracoAttribute.data_type(),\n        num_components: dracoAttribute.num_components(),\n        byte_offset: dracoAttribute.byte_offset(),\n        byte_stride: dracoAttribute.byte_stride(),\n        normalized: dracoAttribute.normalized(),\n        attribute_index: attributeId,\n        metadata\n      };\n\n      const quantization = this._getQuantizationTransform(dracoAttribute, options);\n      if (quantization) {\n        dracoAttributes[dracoAttribute.unique_id()].quantization_transform = quantization;\n      }\n      const octahedron = this._getOctahedronTransform(dracoAttribute, options);\n      if (octahedron) {\n        dracoAttributes[dracoAttribute.unique_id()].octahedron_transform = octahedron;\n      }\n    }\n    return dracoAttributes;\n  }\n\n  _getMeshData(dracoGeometry, loaderData, options) {\n    const attributes = this._getMeshAttributes(loaderData, dracoGeometry, options);\n    const positionAttribute = attributes.POSITION;\n    if (!positionAttribute) {\n      throw new Error('DRACO: No position attribute found.');\n    }\n\n    if (dracoGeometry instanceof this.draco.Mesh) {\n      switch (options.topology) {\n        case 'triangle-strip':\n          return {\n            topology: 'triangle-strip',\n            mode: 4,\n            attributes,\n            indices: {\n              value: this._getTriangleStripIndices(dracoGeometry),\n              size: 1\n            }\n          };\n        case 'triangle-list':\n        default:\n          return {\n            topology: 'triangle-list',\n            mode: 5,\n            attributes,\n            indices: {\n              value: this._getTriangleListIndices(dracoGeometry),\n              size: 1\n            }\n          };\n      }\n    }\n\n    return {\n      topology: 'point-list',\n      mode: 0,\n      attributes\n    };\n  }\n  _getMeshAttributes(loaderData, dracoGeometry, options) {\n    const attributes = {};\n    for (const loaderAttribute of Object.values(loaderData.attributes)) {\n      const attributeName = this._deduceAttributeName(loaderAttribute, options);\n      loaderAttribute.name = attributeName;\n      const {\n        value,\n        size\n      } = this._getAttributeValues(dracoGeometry, loaderAttribute);\n      attributes[attributeName] = {\n        value,\n        size,\n        byteOffset: loaderAttribute.byte_offset,\n        byteStride: loaderAttribute.byte_stride,\n        normalized: loaderAttribute.normalized\n      };\n    }\n    return attributes;\n  }\n\n  _getTriangleListIndices(dracoGeometry) {\n    const numFaces = dracoGeometry.num_faces();\n    const numIndices = numFaces * 3;\n    const byteLength = numIndices * INDEX_ITEM_SIZE;\n    const ptr = this.draco._malloc(byteLength);\n    try {\n      this.decoder.GetTrianglesUInt32Array(dracoGeometry, byteLength, ptr);\n      return new Uint32Array(this.draco.HEAPF32.buffer, ptr, numIndices).slice();\n    } finally {\n      this.draco._free(ptr);\n    }\n  }\n\n  _getTriangleStripIndices(dracoGeometry) {\n    const dracoArray = new this.draco.DracoInt32Array();\n    try {\n      this.decoder.GetTriangleStripsFromMesh(dracoGeometry, dracoArray);\n      return getUint32Array(dracoArray);\n    } finally {\n      this.draco.destroy(dracoArray);\n    }\n  }\n\n  _getAttributeValues(dracoGeometry, attribute) {\n    const TypedArrayCtor = DRACO_DATA_TYPE_TO_TYPED_ARRAY_MAP[attribute.data_type];\n    const numComponents = attribute.num_components;\n    const numPoints = dracoGeometry.num_points();\n    const numValues = numPoints * numComponents;\n    const byteLength = numValues * TypedArrayCtor.BYTES_PER_ELEMENT;\n    const dataType = getDracoDataType(this.draco, TypedArrayCtor);\n    let value;\n    const ptr = this.draco._malloc(byteLength);\n    try {\n      const dracoAttribute = this.decoder.GetAttribute(dracoGeometry, attribute.attribute_index);\n      this.decoder.GetAttributeDataArrayForAllPoints(dracoGeometry, dracoAttribute, dataType, byteLength, ptr);\n      value = new TypedArrayCtor(this.draco.HEAPF32.buffer, ptr, numValues).slice();\n    } finally {\n      this.draco._free(ptr);\n    }\n    return {\n      value,\n      size: numComponents\n    };\n  }\n\n  _deduceAttributeName(attribute, options) {\n    const uniqueId = attribute.unique_id;\n    for (const [attributeName, attributeUniqueId] of Object.entries(options.extraAttributes || {})) {\n      if (attributeUniqueId === uniqueId) {\n        return attributeName;\n      }\n    }\n\n    const thisAttributeType = attribute.attribute_type;\n    for (const dracoAttributeConstant in DRACO_TO_GLTF_ATTRIBUTE_NAME_MAP) {\n      const attributeType = this.draco[dracoAttributeConstant];\n      if (attributeType === thisAttributeType) {\n        return DRACO_TO_GLTF_ATTRIBUTE_NAME_MAP[dracoAttributeConstant];\n      }\n    }\n\n    const entryName = options.attributeNameEntry || 'name';\n    if (attribute.metadata[entryName]) {\n      return attribute.metadata[entryName].string;\n    }\n\n    return \"CUSTOM_ATTRIBUTE_\".concat(uniqueId);\n  }\n\n  _getTopLevelMetadata(dracoGeometry) {\n    const dracoMetadata = this.decoder.GetMetadata(dracoGeometry);\n    return this._getDracoMetadata(dracoMetadata);\n  }\n\n  _getAttributeMetadata(dracoGeometry, attributeId) {\n    const dracoMetadata = this.decoder.GetAttributeMetadata(dracoGeometry, attributeId);\n    return this._getDracoMetadata(dracoMetadata);\n  }\n\n  _getDracoMetadata(dracoMetadata) {\n    if (!dracoMetadata || !dracoMetadata.ptr) {\n      return {};\n    }\n    const result = {};\n    const numEntries = this.metadataQuerier.NumEntries(dracoMetadata);\n    for (let entryIndex = 0; entryIndex < numEntries; entryIndex++) {\n      const entryName = this.metadataQuerier.GetEntryName(dracoMetadata, entryIndex);\n      result[entryName] = this._getDracoMetadataField(dracoMetadata, entryName);\n    }\n    return result;\n  }\n\n  _getDracoMetadataField(dracoMetadata, entryName) {\n    const dracoArray = new this.draco.DracoInt32Array();\n    try {\n      this.metadataQuerier.GetIntEntryArray(dracoMetadata, entryName, dracoArray);\n      const intArray = getInt32Array(dracoArray);\n      return {\n        int: this.metadataQuerier.GetIntEntry(dracoMetadata, entryName),\n        string: this.metadataQuerier.GetStringEntry(dracoMetadata, entryName),\n        double: this.metadataQuerier.GetDoubleEntry(dracoMetadata, entryName),\n        intArray\n      };\n    } finally {\n      this.draco.destroy(dracoArray);\n    }\n  }\n\n  _disableAttributeTransforms(options) {\n    const {\n      quantizedAttributes = [],\n      octahedronAttributes = []\n    } = options;\n    const skipAttributes = [...quantizedAttributes, ...octahedronAttributes];\n    for (const dracoAttributeName of skipAttributes) {\n      this.decoder.SkipAttributeTransform(this.draco[dracoAttributeName]);\n    }\n  }\n\n  _getQuantizationTransform(dracoAttribute, options) {\n    const {\n      quantizedAttributes = []\n    } = options;\n    const attribute_type = dracoAttribute.attribute_type();\n    const skip = quantizedAttributes.map(type => this.decoder[type]).includes(attribute_type);\n    if (skip) {\n      const transform = new this.draco.AttributeQuantizationTransform();\n      try {\n        if (transform.InitFromAttribute(dracoAttribute)) {\n          return {\n            quantization_bits: transform.quantization_bits(),\n            range: transform.range(),\n            min_values: new Float32Array([1, 2, 3]).map(i => transform.min_value(i))\n          };\n        }\n      } finally {\n        this.draco.destroy(transform);\n      }\n    }\n    return null;\n  }\n  _getOctahedronTransform(dracoAttribute, options) {\n    const {\n      octahedronAttributes = []\n    } = options;\n    const attribute_type = dracoAttribute.attribute_type();\n    const octahedron = octahedronAttributes.map(type => this.decoder[type]).includes(attribute_type);\n    if (octahedron) {\n      const transform = new this.draco.AttributeQuantizationTransform();\n      try {\n        if (transform.InitFromAttribute(dracoAttribute)) {\n          return {\n            quantization_bits: transform.quantization_bits()\n          };\n        }\n      } finally {\n        this.draco.destroy(transform);\n      }\n    }\n    return null;\n  }\n\n}\n\nfunction getDracoDataType(draco, attributeType) {\n  switch (attributeType) {\n    case Float32Array:\n      return draco.DT_FLOAT32;\n    case Int8Array:\n      return draco.DT_INT8;\n    case Int16Array:\n      return draco.DT_INT16;\n    case Int32Array:\n      return draco.DT_INT32;\n    case Uint8Array:\n      return draco.DT_UINT8;\n    case Uint16Array:\n      return draco.DT_UINT16;\n    case Uint32Array:\n      return draco.DT_UINT32;\n    default:\n      return draco.DT_INVALID;\n  }\n}\n\nfunction getInt32Array(dracoArray) {\n  const numValues = dracoArray.size();\n  const intArray = new Int32Array(numValues);\n  for (let i = 0; i < numValues; i++) {\n    intArray[i] = dracoArray.GetValue(i);\n  }\n  return intArray;\n}\n\nfunction getUint32Array(dracoArray) {\n  const numValues = dracoArray.size();\n  const intArray = new Int32Array(numValues);\n  for (let i = 0; i < numValues; i++) {\n    intArray[i] = dracoArray.GetValue(i);\n  }\n  return intArray;\n}\n//# sourceMappingURL=draco-parser.js.map\n;// CONCATENATED MODULE: ./node_modules/@loaders.gl/draco/dist/esm/lib/draco-module-loader.js\n\n\n\nconst DRACO_DECODER_VERSION = '1.5.5';\nconst DRACO_ENCODER_VERSION = '1.4.1';\nconst STATIC_DECODER_URL = \"https://www.gstatic.com/draco/versioned/decoders/\".concat(DRACO_DECODER_VERSION);\nconst DRACO_JS_DECODER_URL = \"\".concat(STATIC_DECODER_URL, \"/draco_decoder.js\");\nconst DRACO_WASM_WRAPPER_URL = \"\".concat(STATIC_DECODER_URL, \"/draco_wasm_wrapper.js\");\nconst DRACO_WASM_DECODER_URL = \"\".concat(STATIC_DECODER_URL, \"/draco_decoder.wasm\");\nconst DRACO_ENCODER_URL = \"https://raw.githubusercontent.com/google/draco/\".concat(DRACO_ENCODER_VERSION, \"/javascript/draco_encoder.js\");\nlet loadDecoderPromise;\nlet loadEncoderPromise;\nasync function loadDracoDecoderModule(options) {\n  const modules = options.modules || {};\n\n  if (modules.draco3d) {\n    loadDecoderPromise = loadDecoderPromise || modules.draco3d.createDecoderModule({}).then(draco => {\n      return {\n        draco\n      };\n    });\n  } else {\n    loadDecoderPromise = loadDecoderPromise || loadDracoDecoder(options);\n  }\n  return await loadDecoderPromise;\n}\nasync function loadDracoEncoderModule(options) {\n  const modules = options.modules || {};\n\n  if (modules.draco3d) {\n    loadEncoderPromise = loadEncoderPromise || modules.draco3d.createEncoderModule({}).then(draco => {\n      return {\n        draco\n      };\n    });\n  } else {\n    loadEncoderPromise = loadEncoderPromise || loadDracoEncoder(options);\n  }\n  return await loadEncoderPromise;\n}\n\nasync function loadDracoDecoder(options) {\n  let DracoDecoderModule;\n  let wasmBinary;\n  switch (options.draco && options.draco.decoderType) {\n    case 'js':\n      DracoDecoderModule = await library_utils_loadLibrary(DRACO_JS_DECODER_URL, 'draco', options);\n      break;\n    case 'wasm':\n    default:\n      [DracoDecoderModule, wasmBinary] = await Promise.all([await library_utils_loadLibrary(DRACO_WASM_WRAPPER_URL, 'draco', options), await library_utils_loadLibrary(DRACO_WASM_DECODER_URL, 'draco', options)]);\n  }\n  DracoDecoderModule = DracoDecoderModule || globalThis.DracoDecoderModule;\n  return await initializeDracoDecoder(DracoDecoderModule, wasmBinary);\n}\nfunction initializeDracoDecoder(DracoDecoderModule, wasmBinary) {\n  const options = {};\n  if (wasmBinary) {\n    options.wasmBinary = wasmBinary;\n  }\n  return new Promise(resolve => {\n    DracoDecoderModule({\n      ...options,\n      onModuleLoaded: draco => resolve({\n        draco\n      })\n    });\n  });\n}\n\nasync function loadDracoEncoder(options) {\n  let DracoEncoderModule = await loadLibrary(DRACO_ENCODER_URL, 'draco', options);\n  DracoEncoderModule = DracoEncoderModule || globalThis.DracoEncoderModule;\n  return new Promise(resolve => {\n    DracoEncoderModule({\n      onModuleLoaded: draco => resolve({\n        draco\n      })\n    });\n  });\n}\n//# sourceMappingURL=draco-module-loader.js.map\n;// CONCATENATED MODULE: ./node_modules/@loaders.gl/draco/dist/esm/index.js\n\n\n\n\n\n\n\n\nconst DracoWriterWorker = {\n  id: globals/* isBrowser */.jU ? 'draco-writer' : 'draco-writer-nodejs',\n  name: 'Draco compressed geometry writer',\n  module: 'draco',\n  version: utils_version_VERSION,\n  worker: true,\n  options: {\n    draco: {},\n    source: null\n  }\n};\n\n\n\nconst esm_DracoLoader = {\n  ...DracoLoader,\n  parse\n};\nasync function parse(arrayBuffer, options) {\n  const {\n    draco\n  } = await loadDracoDecoderModule(options);\n  const dracoParser = new DracoParser(draco);\n  try {\n    return dracoParser.parseSync(arrayBuffer, options === null || options === void 0 ? void 0 : options.draco);\n  } finally {\n    dracoParser.destroy();\n  }\n}\n\nconst esm_TypecheckDracoLoader = (/* unused pure expression or super */ null && (esm_DracoLoader));\n//# sourceMappingURL=index.js.map\n;// CONCATENATED MODULE: ./node_modules/@loaders.gl/gltf/dist/esm/lib/gltf-utils/gltf-attribute-utils.js\n\n\n\n\nfunction getGLTFAccessors(attributes) {\n  const accessors = {};\n  for (const name in attributes) {\n    const attribute = attributes[name];\n    if (name !== 'indices') {\n      const glTFAccessor = getGLTFAccessor(attribute);\n      accessors[name] = glTFAccessor;\n    }\n  }\n  return accessors;\n}\n\nfunction getGLTFAccessor(attribute) {\n  const {\n    buffer,\n    size,\n    count\n  } = getAccessorData(attribute);\n  const glTFAccessor = {\n    value: buffer,\n    size,\n\n    byteOffset: 0,\n    count,\n    type: getAccessorTypeFromSize(size),\n    componentType: getComponentTypeFromArray(buffer)\n  };\n  return glTFAccessor;\n}\n\nfunction getAccessorData(attribute) {\n  let buffer = attribute;\n  let size = 1;\n  let count = 0;\n  if (attribute && attribute.value) {\n    buffer = attribute.value;\n    size = attribute.size || 1;\n  }\n  if (buffer) {\n    if (!ArrayBuffer.isView(buffer)) {\n      buffer = toTypedArray(buffer, Float32Array);\n    }\n    count = buffer.length / size;\n  }\n  return {\n    buffer,\n    size,\n    count\n  };\n}\n\nfunction toTypedArray(array, ArrayType) {\n  let convertTypedArrays = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n  if (!array) {\n    return null;\n  }\n  if (Array.isArray(array)) {\n    return new ArrayType(array);\n  }\n  if (convertTypedArrays && !(array instanceof ArrayType)) {\n    return new ArrayType(array);\n  }\n  return array;\n}\n//# sourceMappingURL=gltf-attribute-utils.js.map\n;// CONCATENATED MODULE: ./node_modules/@loaders.gl/gltf/dist/esm/lib/extensions/KHR_draco_mesh_compression.js\n\n\n\n\n\n\nconst KHR_DRACO_MESH_COMPRESSION = 'KHR_draco_mesh_compression';\n\nconst KHR_draco_mesh_compression_name = KHR_DRACO_MESH_COMPRESSION;\nfunction KHR_draco_mesh_compression_preprocess(gltfData, options, context) {\n  const scenegraph = new GLTFScenegraph(gltfData);\n  for (const primitive of makeMeshPrimitiveIterator(scenegraph)) {\n    if (scenegraph.getObjectExtension(primitive, KHR_DRACO_MESH_COMPRESSION)) {\n    }\n  }\n}\nasync function KHR_draco_mesh_compression_decode(gltfData, options, context) {\n  var _options$gltf;\n  if (!(options !== null && options !== void 0 && (_options$gltf = options.gltf) !== null && _options$gltf !== void 0 && _options$gltf.decompressMeshes)) {\n    return;\n  }\n  const scenegraph = new GLTFScenegraph(gltfData);\n  const promises = [];\n  for (const primitive of makeMeshPrimitiveIterator(scenegraph)) {\n    if (scenegraph.getObjectExtension(primitive, KHR_DRACO_MESH_COMPRESSION)) {\n      promises.push(decompressPrimitive(scenegraph, primitive, options, context));\n    }\n  }\n\n  await Promise.all(promises);\n\n  scenegraph.removeExtension(KHR_DRACO_MESH_COMPRESSION);\n}\nfunction encode(gltfData) {\n  let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  const scenegraph = new GLTFScenegraph(gltfData);\n  for (const mesh of scenegraph.json.meshes || []) {\n    compressMesh(mesh, options);\n    scenegraph.addRequiredExtension(KHR_DRACO_MESH_COMPRESSION);\n  }\n}\n\nasync function decompressPrimitive(scenegraph, primitive, options, context) {\n  const dracoExtension = scenegraph.getObjectExtension(primitive, KHR_DRACO_MESH_COMPRESSION);\n  if (!dracoExtension) {\n    return;\n  }\n  const buffer = scenegraph.getTypedArrayForBufferView(dracoExtension.bufferView);\n  const bufferCopy = (0,array_buffer_utils/* sliceArrayBuffer */.qv)(buffer.buffer, buffer.byteOffset);\n\n  const {\n    parse\n  } = context;\n  const dracoOptions = {\n    ...options\n  };\n\n  delete dracoOptions['3d-tiles'];\n  const decodedData = await parse(bufferCopy, esm_DracoLoader, dracoOptions, context);\n  const decodedAttributes = getGLTFAccessors(decodedData.attributes);\n\n  for (const [attributeName, decodedAttribute] of Object.entries(decodedAttributes)) {\n    if (attributeName in primitive.attributes) {\n      const accessorIndex = primitive.attributes[attributeName];\n      const accessor = scenegraph.getAccessor(accessorIndex);\n      if (accessor !== null && accessor !== void 0 && accessor.min && accessor !== null && accessor !== void 0 && accessor.max) {\n        decodedAttribute.min = accessor.min;\n        decodedAttribute.max = accessor.max;\n      }\n    }\n  }\n\n  primitive.attributes = decodedAttributes;\n  if (decodedData.indices) {\n    primitive.indices = getGLTFAccessor(decodedData.indices);\n  }\n\n  checkPrimitive(primitive);\n}\n\nfunction compressMesh(attributes, indices) {\n  var _context$parseSync;\n  let mode = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 4;\n  let options = arguments.length > 3 ? arguments[3] : undefined;\n  let context = arguments.length > 4 ? arguments[4] : undefined;\n  if (!options.DracoWriter) {\n    throw new Error('options.gltf.DracoWriter not provided');\n  }\n\n  const compressedData = options.DracoWriter.encodeSync({\n    attributes\n  });\n\n  const decodedData = context === null || context === void 0 ? void 0 : (_context$parseSync = context.parseSync) === null || _context$parseSync === void 0 ? void 0 : _context$parseSync.call(context, {\n    attributes\n  });\n  const fauxAccessors = options._addFauxAttributes(decodedData.attributes);\n  const bufferViewIndex = options.addBufferView(compressedData);\n  const glTFMesh = {\n    primitives: [{\n      attributes: fauxAccessors,\n      mode,\n      extensions: {\n        [KHR_DRACO_MESH_COMPRESSION]: {\n          bufferView: bufferViewIndex,\n          attributes: fauxAccessors\n        }\n      }\n    }]\n  };\n\n  return glTFMesh;\n}\n\nfunction checkPrimitive(primitive) {\n  if (!primitive.attributes && Object.keys(primitive.attributes).length > 0) {\n    throw new Error('glTF: Empty primitive detected: Draco decompression failure?');\n  }\n}\nfunction* makeMeshPrimitiveIterator(scenegraph) {\n  for (const mesh of scenegraph.json.meshes || []) {\n    for (const primitive of mesh.primitives) {\n      yield primitive;\n    }\n  }\n}\n//# sourceMappingURL=KHR_draco_mesh_compression.js.map\n// EXTERNAL MODULE: ./node_modules/@math.gl/core/dist/esm/classes/vector3.js\nvar vector3 = __webpack_require__(43855);\n// EXTERNAL MODULE: ./node_modules/@math.gl/core/dist/esm/classes/matrix3.js\nvar matrix3 = __webpack_require__(80540);\n;// CONCATENATED MODULE: ./node_modules/@loaders.gl/gltf/dist/esm/lib/gltf-utils/gltf-constants.js\nconst COMPONENTS = {\n  SCALAR: 1,\n  VEC2: 2,\n  VEC3: 3,\n  VEC4: 4,\n  MAT2: 4,\n  MAT3: 9,\n  MAT4: 16\n};\nconst BYTES = {\n  5120: 1,\n  5121: 1,\n  5122: 2,\n  5123: 2,\n  5125: 4,\n  5126: 4\n};\n\nfunction getBytesFromComponentType(componentType) {\n  return BYTES[componentType];\n}\nfunction getSizeFromAccessorType(type) {\n  return COMPONENTS[type];\n}\nfunction getGLEnumFromSamplerParameter(parameter) {\n  const GL_TEXTURE_MAG_FILTER = 0x2800;\n  const GL_TEXTURE_MIN_FILTER = 0x2801;\n  const GL_TEXTURE_WRAP_S = 0x2802;\n  const GL_TEXTURE_WRAP_T = 0x2803;\n  const PARAMETER_MAP = {\n    magFilter: GL_TEXTURE_MAG_FILTER,\n    minFilter: GL_TEXTURE_MIN_FILTER,\n    wrapS: GL_TEXTURE_WRAP_S,\n    wrapT: GL_TEXTURE_WRAP_T\n  };\n  return PARAMETER_MAP[parameter];\n}\n//# sourceMappingURL=gltf-constants.js.map\n;// CONCATENATED MODULE: ./node_modules/@loaders.gl/gltf/dist/esm/lib/extensions/KHR_texture_transform.js\n\n\n\n\n\n\n\nconst EXT_MESHOPT_TRANSFORM = 'KHR_texture_transform';\nconst KHR_texture_transform_name = EXT_MESHOPT_TRANSFORM;\nconst scratchVector = new vector3/* default */.Z();\nconst scratchRotationMatrix = new matrix3/* default */.Z();\nconst scratchScaleMatrix = new matrix3/* default */.Z();\n\nasync function KHR_texture_transform_decode(gltfData, options) {\n  const gltfScenegraph = new GLTFScenegraph(gltfData);\n  const extension = gltfScenegraph.getExtension(EXT_MESHOPT_TRANSFORM);\n  if (!extension) {\n    return;\n  }\n  const materials = gltfData.json.materials || [];\n  for (let i = 0; i < materials.length; i++) {\n    transformTexCoords(i, gltfData);\n  }\n}\n\nfunction transformTexCoords(materialIndex, gltfData) {\n  var _gltfData$json$materi, _material$pbrMetallic, _material$pbrMetallic2;\n  const processedTexCoords = [];\n  const material = (_gltfData$json$materi = gltfData.json.materials) === null || _gltfData$json$materi === void 0 ? void 0 : _gltfData$json$materi[materialIndex];\n  const baseColorTexture = material === null || material === void 0 ? void 0 : (_material$pbrMetallic = material.pbrMetallicRoughness) === null || _material$pbrMetallic === void 0 ? void 0 : _material$pbrMetallic.baseColorTexture;\n  if (baseColorTexture) {\n    transformPrimitives(gltfData, materialIndex, baseColorTexture, processedTexCoords);\n  }\n  const emisiveTexture = material === null || material === void 0 ? void 0 : material.emissiveTexture;\n  if (emisiveTexture) {\n    transformPrimitives(gltfData, materialIndex, emisiveTexture, processedTexCoords);\n  }\n  const normalTexture = material === null || material === void 0 ? void 0 : material.normalTexture;\n  if (normalTexture) {\n    transformPrimitives(gltfData, materialIndex, normalTexture, processedTexCoords);\n  }\n  const occlusionTexture = material === null || material === void 0 ? void 0 : material.occlusionTexture;\n  if (occlusionTexture) {\n    transformPrimitives(gltfData, materialIndex, occlusionTexture, processedTexCoords);\n  }\n  const metallicRoughnessTexture = material === null || material === void 0 ? void 0 : (_material$pbrMetallic2 = material.pbrMetallicRoughness) === null || _material$pbrMetallic2 === void 0 ? void 0 : _material$pbrMetallic2.metallicRoughnessTexture;\n  if (metallicRoughnessTexture) {\n    transformPrimitives(gltfData, materialIndex, metallicRoughnessTexture, processedTexCoords);\n  }\n}\n\nfunction transformPrimitives(gltfData, materialIndex, texture, processedTexCoords) {\n  const transformParameters = getTransformParameters(texture, processedTexCoords);\n  if (!transformParameters) {\n    return;\n  }\n  const meshes = gltfData.json.meshes || [];\n  for (const mesh of meshes) {\n    for (const primitive of mesh.primitives) {\n      const material = primitive.material;\n      if (Number.isFinite(material) && materialIndex === material) {\n        transformPrimitive(gltfData, primitive, transformParameters);\n      }\n    }\n  }\n}\n\nfunction getTransformParameters(texture, processedTexCoords) {\n  var _texture$extensions;\n  const textureInfo = (_texture$extensions = texture.extensions) === null || _texture$extensions === void 0 ? void 0 : _texture$extensions[EXT_MESHOPT_TRANSFORM];\n  const {\n    texCoord: originalTexCoord = 0\n  } = texture;\n  const {\n    texCoord = originalTexCoord\n  } = textureInfo;\n  const isProcessed = processedTexCoords.findIndex(_ref => {\n    let [original, newTexCoord] = _ref;\n    return original === originalTexCoord && newTexCoord === texCoord;\n  }) !== -1;\n  if (!isProcessed) {\n    const matrix = makeTransformationMatrix(textureInfo);\n    if (originalTexCoord !== texCoord) {\n      texture.texCoord = texCoord;\n    }\n    processedTexCoords.push([originalTexCoord, texCoord]);\n    return {\n      originalTexCoord,\n      texCoord,\n      matrix\n    };\n  }\n  return null;\n}\n\nfunction transformPrimitive(gltfData, primitive, transformParameters) {\n  const {\n    originalTexCoord,\n    texCoord,\n    matrix\n  } = transformParameters;\n  const texCoordAccessor = primitive.attributes[\"TEXCOORD_\".concat(originalTexCoord)];\n  if (Number.isFinite(texCoordAccessor)) {\n    var _gltfData$json$access;\n    const accessor = (_gltfData$json$access = gltfData.json.accessors) === null || _gltfData$json$access === void 0 ? void 0 : _gltfData$json$access[texCoordAccessor];\n    if (accessor && accessor.bufferView) {\n      var _gltfData$json$buffer;\n      const bufferView = (_gltfData$json$buffer = gltfData.json.bufferViews) === null || _gltfData$json$buffer === void 0 ? void 0 : _gltfData$json$buffer[accessor.bufferView];\n      if (bufferView) {\n        const {\n          arrayBuffer,\n          byteOffset: bufferByteOffset\n        } = gltfData.buffers[bufferView.buffer];\n        const byteOffset = (bufferByteOffset || 0) + (accessor.byteOffset || 0) + (bufferView.byteOffset || 0);\n        const {\n          ArrayType,\n          length\n        } = getAccessorArrayTypeAndLength(accessor, bufferView);\n        const bytes = BYTES[accessor.componentType];\n        const components = COMPONENTS[accessor.type];\n        const elementAddressScale = bufferView.byteStride || bytes * components;\n        const result = new Float32Array(length);\n        for (let i = 0; i < accessor.count; i++) {\n          const uv = new ArrayType(arrayBuffer, byteOffset + i * elementAddressScale, 2);\n          scratchVector.set(uv[0], uv[1], 1);\n          scratchVector.transformByMatrix3(matrix);\n          result.set([scratchVector[0], scratchVector[1]], i * components);\n        }\n        if (originalTexCoord === texCoord) {\n          updateGltf(accessor, bufferView, gltfData.buffers, result);\n        } else {\n          createAttribute(texCoord, accessor, primitive, gltfData, result);\n        }\n      }\n    }\n  }\n}\n\nfunction updateGltf(accessor, bufferView, buffers, newTexCoordArray) {\n  accessor.componentType = 5126;\n  buffers.push({\n    arrayBuffer: newTexCoordArray.buffer,\n    byteOffset: 0,\n    byteLength: newTexCoordArray.buffer.byteLength\n  });\n  bufferView.buffer = buffers.length - 1;\n  bufferView.byteLength = newTexCoordArray.buffer.byteLength;\n  bufferView.byteOffset = 0;\n  delete bufferView.byteStride;\n}\n\nfunction createAttribute(newTexCoord, originalAccessor, primitive, gltfData, newTexCoordArray) {\n  gltfData.buffers.push({\n    arrayBuffer: newTexCoordArray.buffer,\n    byteOffset: 0,\n    byteLength: newTexCoordArray.buffer.byteLength\n  });\n  const bufferViews = gltfData.json.bufferViews;\n  if (!bufferViews) {\n    return;\n  }\n  bufferViews.push({\n    buffer: gltfData.buffers.length - 1,\n    byteLength: newTexCoordArray.buffer.byteLength,\n    byteOffset: 0\n  });\n  const accessors = gltfData.json.accessors;\n  if (!accessors) {\n    return;\n  }\n  accessors.push({\n    bufferView: (bufferViews === null || bufferViews === void 0 ? void 0 : bufferViews.length) - 1,\n    byteOffset: 0,\n    componentType: 5126,\n    count: originalAccessor.count,\n    type: 'VEC2'\n  });\n  primitive.attributes[\"TEXCOORD_\".concat(newTexCoord)] = accessors.length - 1;\n}\n\nfunction makeTransformationMatrix(extensionData) {\n  const {\n    offset = [0, 0],\n    rotation = 0,\n    scale = [1, 1]\n  } = extensionData;\n  const translationMatirx = new matrix3/* default */.Z().set(1, 0, 0, 0, 1, 0, offset[0], offset[1], 1);\n  const rotationMatirx = scratchRotationMatrix.set(Math.cos(rotation), Math.sin(rotation), 0, -Math.sin(rotation), Math.cos(rotation), 0, 0, 0, 1);\n  const scaleMatrix = scratchScaleMatrix.set(scale[0], 0, 0, 0, scale[1], 0, 0, 0, 1);\n  return translationMatirx.multiplyRight(rotationMatirx).multiplyRight(scaleMatrix);\n}\n//# sourceMappingURL=KHR_texture_transform.js.map\n;// CONCATENATED MODULE: ./node_modules/@loaders.gl/gltf/dist/esm/lib/extensions/deprecated/KHR_lights_punctual.js\n\n\n\n\nconst KHR_LIGHTS_PUNCTUAL = 'KHR_lights_punctual';\nconst KHR_lights_punctual_name = KHR_LIGHTS_PUNCTUAL;\nasync function KHR_lights_punctual_decode(gltfData) {\n  const gltfScenegraph = new GLTFScenegraph(gltfData);\n  const {\n    json\n  } = gltfScenegraph;\n\n  const extension = gltfScenegraph.getExtension(KHR_LIGHTS_PUNCTUAL);\n  if (extension) {\n    gltfScenegraph.json.lights = extension.lights;\n    gltfScenegraph.removeExtension(KHR_LIGHTS_PUNCTUAL);\n  }\n\n  for (const node of json.nodes || []) {\n    const nodeExtension = gltfScenegraph.getObjectExtension(node, KHR_LIGHTS_PUNCTUAL);\n    if (nodeExtension) {\n      node.light = nodeExtension.light;\n    }\n    gltfScenegraph.removeObjectExtension(node, KHR_LIGHTS_PUNCTUAL);\n  }\n}\n\nasync function KHR_lights_punctual_encode(gltfData) {\n  const gltfScenegraph = new GLTFScenegraph(gltfData);\n  const {\n    json\n  } = gltfScenegraph;\n\n  if (json.lights) {\n    const extension = gltfScenegraph.addExtension(KHR_LIGHTS_PUNCTUAL);\n    assert_assert(!extension.lights);\n    extension.lights = json.lights;\n    delete json.lights;\n  }\n\n  if (gltfScenegraph.json.lights) {\n    for (const light of gltfScenegraph.json.lights) {\n      const node = light.node;\n      gltfScenegraph.addObjectExtension(node, KHR_LIGHTS_PUNCTUAL, light);\n    }\n    delete gltfScenegraph.json.lights;\n  }\n}\n//# sourceMappingURL=KHR_lights_punctual.js.map\n;// CONCATENATED MODULE: ./node_modules/@loaders.gl/gltf/dist/esm/lib/extensions/deprecated/KHR_materials_unlit.js\n\n\n\nconst KHR_MATERIALS_UNLIT = 'KHR_materials_unlit';\nconst KHR_materials_unlit_name = KHR_MATERIALS_UNLIT;\nasync function KHR_materials_unlit_decode(gltfData) {\n  const gltfScenegraph = new GLTFScenegraph(gltfData);\n  const {\n    json\n  } = gltfScenegraph;\n\n  for (const material of json.materials || []) {\n    const extension = material.extensions && material.extensions.KHR_materials_unlit;\n    if (extension) {\n      material.unlit = true;\n    }\n    gltfScenegraph.removeObjectExtension(material, KHR_MATERIALS_UNLIT);\n  }\n\n  gltfScenegraph.removeExtension(KHR_MATERIALS_UNLIT);\n}\nfunction KHR_materials_unlit_encode(gltfData) {\n  const gltfScenegraph = new GLTFScenegraph(gltfData);\n  const {\n    json\n  } = gltfScenegraph;\n\n  if (gltfScenegraph.materials) {\n    for (const material of json.materials || []) {\n      if (material.unlit) {\n        delete material.unlit;\n        gltfScenegraph.addObjectExtension(material, KHR_MATERIALS_UNLIT, {});\n        gltfScenegraph.addExtension(KHR_MATERIALS_UNLIT);\n      }\n    }\n  }\n}\n//# sourceMappingURL=KHR_materials_unlit.js.map\n;// CONCATENATED MODULE: ./node_modules/@loaders.gl/gltf/dist/esm/lib/extensions/deprecated/KHR_techniques_webgl.js\n\n\n\nconst KHR_TECHNIQUES_WEBGL = 'KHR_techniques_webgl';\nconst KHR_techniques_webgl_name = KHR_TECHNIQUES_WEBGL;\nasync function KHR_techniques_webgl_decode(gltfData) {\n  const gltfScenegraph = new GLTFScenegraph(gltfData);\n  const {\n    json\n  } = gltfScenegraph;\n  const extension = gltfScenegraph.getExtension(KHR_TECHNIQUES_WEBGL);\n  if (extension) {\n    const techniques = resolveTechniques(extension, gltfScenegraph);\n    for (const material of json.materials || []) {\n      const materialExtension = gltfScenegraph.getObjectExtension(material, KHR_TECHNIQUES_WEBGL);\n      if (materialExtension) {\n        material.technique = Object.assign({}, materialExtension,\n        techniques[materialExtension.technique]);\n        material.technique.values = resolveValues(material.technique, gltfScenegraph);\n      }\n      gltfScenegraph.removeObjectExtension(material, KHR_TECHNIQUES_WEBGL);\n    }\n\n    gltfScenegraph.removeExtension(KHR_TECHNIQUES_WEBGL);\n  }\n}\nasync function KHR_techniques_webgl_encode(gltfData, options) {\n}\nfunction resolveTechniques(techniquesExtension,\ngltfScenegraph) {\n  const {\n    programs = [],\n    shaders = [],\n    techniques = []\n  } = techniquesExtension;\n  const textDecoder = new TextDecoder();\n  shaders.forEach(shader => {\n    if (Number.isFinite(shader.bufferView)) {\n      shader.code = textDecoder.decode(gltfScenegraph.getTypedArrayForBufferView(shader.bufferView));\n    } else {\n      throw new Error('KHR_techniques_webgl: no shader code');\n    }\n  });\n  programs.forEach(program => {\n    program.fragmentShader = shaders[program.fragmentShader];\n    program.vertexShader = shaders[program.vertexShader];\n  });\n  techniques.forEach(technique => {\n    technique.program = programs[technique.program];\n  });\n  return techniques;\n}\nfunction resolveValues(technique, gltfScenegraph) {\n  const values = Object.assign({}, technique.values);\n\n  Object.keys(technique.uniforms || {}).forEach(uniform => {\n    if (technique.uniforms[uniform].value && !(uniform in values)) {\n      values[uniform] = technique.uniforms[uniform].value;\n    }\n  });\n\n  Object.keys(values).forEach(uniform => {\n    if (typeof values[uniform] === 'object' && values[uniform].index !== undefined) {\n      values[uniform].texture = gltfScenegraph.getTexture(values[uniform].index);\n    }\n  });\n  return values;\n}\n//# sourceMappingURL=KHR_techniques_webgl.js.map\n;// CONCATENATED MODULE: ./node_modules/@loaders.gl/gltf/dist/esm/lib/extensions/deprecated/EXT_feature_metadata.js\n\n\n\nconst EXT_FEATURE_METADATA = 'EXT_feature_metadata';\nconst EXT_feature_metadata_name = EXT_FEATURE_METADATA;\nasync function EXT_feature_metadata_decode(gltfData) {\n  const scenegraph = new GLTFScenegraph(gltfData);\n  decodeExtFeatureMetadata(scenegraph);\n}\n\nfunction decodeExtFeatureMetadata(scenegraph) {\n  var _extension$schema;\n  const extension = scenegraph.getExtension(EXT_FEATURE_METADATA);\n  const schemaClasses = extension === null || extension === void 0 ? void 0 : (_extension$schema = extension.schema) === null || _extension$schema === void 0 ? void 0 : _extension$schema.classes;\n  const featureTables = extension === null || extension === void 0 ? void 0 : extension.featureTables;\n  const featureTextures = extension === null || extension === void 0 ? void 0 : extension.featureTextures;\n  if (featureTextures) {\n    console.warn('featureTextures is not yet supported in the \"EXT_feature_metadata\" extension.');\n  }\n  if (schemaClasses && featureTables) {\n    for (const schemaName in schemaClasses) {\n      const schemaClass = schemaClasses[schemaName];\n      const featureTable = findFeatureTableByName(featureTables, schemaName);\n      if (featureTable) {\n        handleFeatureTableProperties(scenegraph, featureTable, schemaClass);\n      }\n    }\n  }\n}\n\nfunction handleFeatureTableProperties(scenegraph, featureTable, schemaClass) {\n  for (const propertyName in schemaClass.properties) {\n    var _featureTable$propert;\n    const schemaProperty = schemaClass.properties[propertyName];\n    const featureTableProperty = featureTable === null || featureTable === void 0 ? void 0 : (_featureTable$propert = featureTable.properties) === null || _featureTable$propert === void 0 ? void 0 : _featureTable$propert[propertyName];\n    const numberOfFeatures = featureTable.count;\n    if (featureTableProperty) {\n      const data = getPropertyDataFromBinarySource(scenegraph, schemaProperty, numberOfFeatures, featureTableProperty);\n      featureTableProperty.data = data;\n    }\n  }\n}\n\nfunction getPropertyDataFromBinarySource(scenegraph, schemaProperty, numberOfFeatures, featureTableProperty) {\n  const bufferView = featureTableProperty.bufferView;\n  let data = scenegraph.getTypedArrayForBufferView(bufferView);\n  switch (schemaProperty.type) {\n    case 'STRING':\n      {\n        const stringOffsetBufferView = featureTableProperty.stringOffsetBufferView;\n        const offsetsData = scenegraph.getTypedArrayForBufferView(stringOffsetBufferView);\n        data = getStringAttributes(data, offsetsData, numberOfFeatures);\n        break;\n      }\n    default:\n  }\n  return data;\n}\n\nfunction findFeatureTableByName(featureTables, schemaClassName) {\n  for (const featureTableName in featureTables) {\n    const featureTable = featureTables[featureTableName];\n    if (featureTable.class === schemaClassName) {\n      return featureTable;\n    }\n  }\n  return null;\n}\n\nfunction getStringAttributes(data, offsetsData, stringsCount) {\n  const stringsArray = [];\n  const textDecoder = new TextDecoder('utf8');\n  let stringOffset = 0;\n  const bytesPerStringSize = 4;\n  for (let index = 0; index < stringsCount; index++) {\n    const stringByteSize = offsetsData[(index + 1) * bytesPerStringSize] - offsetsData[index * bytesPerStringSize];\n    const stringData = data.subarray(stringOffset, stringByteSize + stringOffset);\n    const stringAttribute = textDecoder.decode(stringData);\n    stringsArray.push(stringAttribute);\n    stringOffset += stringByteSize;\n  }\n  return stringsArray;\n}\n//# sourceMappingURL=EXT_feature_metadata.js.map\n;// CONCATENATED MODULE: ./node_modules/@loaders.gl/gltf/dist/esm/lib/api/gltf-extensions.js\n\n\n\n\n\n\n\n\n\n\n\n\n\nconst EXTENSIONS = [\n\nEXT_meshopt_compression_namespaceObject, EXT_texture_webp_namespaceObject,\nKHR_texture_basisu_namespaceObject, KHR_draco_mesh_compression_namespaceObject, KHR_lights_punctual_namespaceObject, KHR_materials_unlit_namespaceObject, KHR_techniques_webgl_namespaceObject, KHR_texture_transform_namespaceObject, EXT_feature_metadata_namespaceObject];\n\nfunction preprocessExtensions(gltf) {\n  let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  let context = arguments.length > 2 ? arguments[2] : undefined;\n  const extensions = EXTENSIONS.filter(extension => useExtension(extension.name, options));\n  for (const extension of extensions) {\n    var _extension$preprocess;\n    (_extension$preprocess = extension.preprocess) === null || _extension$preprocess === void 0 ? void 0 : _extension$preprocess.call(extension, gltf, options, context);\n  }\n}\n\nasync function decodeExtensions(gltf) {\n  let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  let context = arguments.length > 2 ? arguments[2] : undefined;\n  const extensions = EXTENSIONS.filter(extension => useExtension(extension.name, options));\n  for (const extension of extensions) {\n    var _extension$decode;\n    await ((_extension$decode = extension.decode) === null || _extension$decode === void 0 ? void 0 : _extension$decode.call(extension, gltf, options, context));\n  }\n}\nfunction useExtension(extensionName, options) {\n  var _options$gltf;\n  const excludes = (options === null || options === void 0 ? void 0 : (_options$gltf = options.gltf) === null || _options$gltf === void 0 ? void 0 : _options$gltf.excludeExtensions) || {};\n  const exclude = extensionName in excludes && !excludes[extensionName];\n  return !exclude;\n}\n//# sourceMappingURL=gltf-extensions.js.map\n;// CONCATENATED MODULE: ./node_modules/@loaders.gl/gltf/dist/esm/lib/extensions/KHR_binary_gltf.js\n\n\n\nconst KHR_BINARY_GLTF = 'KHR_binary_glTF';\n\nconst KHR_binary_gltf_name = (/* unused pure expression or super */ null && (KHR_BINARY_GLTF));\nfunction KHR_binary_gltf_preprocess(gltfData) {\n  const gltfScenegraph = new GLTFScenegraph(gltfData);\n  const {\n    json\n  } = gltfScenegraph;\n\n  for (const image of json.images || []) {\n    const extension = gltfScenegraph.getObjectExtension(image, KHR_BINARY_GLTF);\n    if (extension) {\n      Object.assign(image, extension);\n    }\n    gltfScenegraph.removeObjectExtension(image, KHR_BINARY_GLTF);\n  }\n\n  if (json.buffers && json.buffers[0]) {\n    delete json.buffers[0].uri;\n  }\n\n  gltfScenegraph.removeExtension(KHR_BINARY_GLTF);\n}\n//# sourceMappingURL=KHR_binary_gltf.js.map\n;// CONCATENATED MODULE: ./node_modules/@loaders.gl/gltf/dist/esm/lib/api/normalize-gltf-v1.js\n\n\n\nconst GLTF_ARRAYS = {\n  accessors: 'accessor',\n  animations: 'animation',\n  buffers: 'buffer',\n  bufferViews: 'bufferView',\n  images: 'image',\n  materials: 'material',\n  meshes: 'mesh',\n  nodes: 'node',\n  samplers: 'sampler',\n  scenes: 'scene',\n  skins: 'skin',\n  textures: 'texture'\n};\nconst GLTF_KEYS = {\n  accessor: 'accessors',\n  animations: 'animation',\n  buffer: 'buffers',\n  bufferView: 'bufferViews',\n  image: 'images',\n  material: 'materials',\n  mesh: 'meshes',\n  node: 'nodes',\n  sampler: 'samplers',\n  scene: 'scenes',\n  skin: 'skins',\n  texture: 'textures'\n};\n\nclass GLTFV1Normalizer {\n  constructor() {\n    (0,defineProperty/* default */.Z)(this, \"idToIndexMap\", {\n      animations: {},\n      accessors: {},\n      buffers: {},\n      bufferViews: {},\n      images: {},\n      materials: {},\n      meshes: {},\n      nodes: {},\n      samplers: {},\n      scenes: {},\n      skins: {},\n      textures: {}\n    });\n    (0,defineProperty/* default */.Z)(this, \"json\", void 0);\n  }\n\n  normalize(gltf, options) {\n    this.json = gltf.json;\n    const json = gltf.json;\n\n    switch (json.asset && json.asset.version) {\n      case '2.0':\n        return;\n\n      case undefined:\n      case '1.0':\n        break;\n      default:\n        console.warn(\"glTF: Unknown version \".concat(json.asset.version));\n        return;\n    }\n    if (!options.normalize) {\n      throw new Error('glTF v1 is not supported.');\n    }\n\n    console.warn('Converting glTF v1 to glTF v2 format. This is experimental and may fail.');\n    this._addAsset(json);\n\n    this._convertTopLevelObjectsToArrays(json);\n\n    KHR_binary_gltf_preprocess(gltf);\n\n    this._convertObjectIdsToArrayIndices(json);\n    this._updateObjects(json);\n    this._updateMaterial(json);\n  }\n\n  _addAsset(json) {\n    json.asset = json.asset || {};\n    json.asset.version = '2.0';\n    json.asset.generator = json.asset.generator || 'Normalized to glTF 2.0 by loaders.gl';\n  }\n  _convertTopLevelObjectsToArrays(json) {\n    for (const arrayName in GLTF_ARRAYS) {\n      this._convertTopLevelObjectToArray(json, arrayName);\n    }\n  }\n\n  _convertTopLevelObjectToArray(json, mapName) {\n    const objectMap = json[mapName];\n    if (!objectMap || Array.isArray(objectMap)) {\n      return;\n    }\n\n    json[mapName] = [];\n    for (const id in objectMap) {\n      const object = objectMap[id];\n      object.id = object.id || id;\n      const index = json[mapName].length;\n      json[mapName].push(object);\n      this.idToIndexMap[mapName][id] = index;\n    }\n  }\n\n  _convertObjectIdsToArrayIndices(json) {\n    for (const arrayName in GLTF_ARRAYS) {\n      this._convertIdsToIndices(json, arrayName);\n    }\n    if ('scene' in json) {\n      json.scene = this._convertIdToIndex(json.scene, 'scene');\n    }\n\n    for (const texture of json.textures) {\n      this._convertTextureIds(texture);\n    }\n    for (const mesh of json.meshes) {\n      this._convertMeshIds(mesh);\n    }\n    for (const node of json.nodes) {\n      this._convertNodeIds(node);\n    }\n    for (const node of json.scenes) {\n      this._convertSceneIds(node);\n    }\n  }\n  _convertTextureIds(texture) {\n    if (texture.source) {\n      texture.source = this._convertIdToIndex(texture.source, 'image');\n    }\n  }\n  _convertMeshIds(mesh) {\n    for (const primitive of mesh.primitives) {\n      const {\n        attributes,\n        indices,\n        material\n      } = primitive;\n      for (const attributeName in attributes) {\n        attributes[attributeName] = this._convertIdToIndex(attributes[attributeName], 'accessor');\n      }\n      if (indices) {\n        primitive.indices = this._convertIdToIndex(indices, 'accessor');\n      }\n      if (material) {\n        primitive.material = this._convertIdToIndex(material, 'material');\n      }\n    }\n  }\n  _convertNodeIds(node) {\n    if (node.children) {\n      node.children = node.children.map(child => this._convertIdToIndex(child, 'node'));\n    }\n    if (node.meshes) {\n      node.meshes = node.meshes.map(mesh => this._convertIdToIndex(mesh, 'mesh'));\n    }\n  }\n  _convertSceneIds(scene) {\n    if (scene.nodes) {\n      scene.nodes = scene.nodes.map(node => this._convertIdToIndex(node, 'node'));\n    }\n  }\n\n  _convertIdsToIndices(json, topLevelArrayName) {\n    if (!json[topLevelArrayName]) {\n      console.warn(\"gltf v1: json doesn't contain attribute \".concat(topLevelArrayName));\n      json[topLevelArrayName] = [];\n    }\n    for (const object of json[topLevelArrayName]) {\n      for (const key in object) {\n        const id = object[key];\n        const index = this._convertIdToIndex(id, key);\n        object[key] = index;\n      }\n    }\n  }\n  _convertIdToIndex(id, key) {\n    const arrayName = GLTF_KEYS[key];\n    if (arrayName in this.idToIndexMap) {\n      const index = this.idToIndexMap[arrayName][id];\n      if (!Number.isFinite(index)) {\n        throw new Error(\"gltf v1: failed to resolve \".concat(key, \" with id \").concat(id));\n      }\n      return index;\n    }\n    return id;\n  }\n\n  _updateObjects(json) {\n    for (const buffer of this.json.buffers) {\n      delete buffer.type;\n    }\n  }\n\n  _updateMaterial(json) {\n    for (const material of json.materials) {\n      var _material$values, _material$values2, _material$values3;\n      material.pbrMetallicRoughness = {\n        baseColorFactor: [1, 1, 1, 1],\n        metallicFactor: 1,\n        roughnessFactor: 1\n      };\n      const textureId = ((_material$values = material.values) === null || _material$values === void 0 ? void 0 : _material$values.tex) || ((_material$values2 = material.values) === null || _material$values2 === void 0 ? void 0 : _material$values2.texture2d_0) || ((_material$values3 = material.values) === null || _material$values3 === void 0 ? void 0 : _material$values3.diffuseTex);\n      const textureIndex = json.textures.findIndex(texture => texture.id === textureId);\n      if (textureIndex !== -1) {\n        material.pbrMetallicRoughness.baseColorTexture = {\n          index: textureIndex\n        };\n      }\n    }\n  }\n}\nfunction normalizeGLTFV1(gltf) {\n  let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  return new GLTFV1Normalizer().normalize(gltf, options);\n}\n//# sourceMappingURL=normalize-gltf-v1.js.map\n;// CONCATENATED MODULE: ./node_modules/@loaders.gl/gltf/dist/esm/lib/api/post-process-gltf.js\n\n\n\n\nconst post_process_gltf_COMPONENTS = {\n  SCALAR: 1,\n  VEC2: 2,\n  VEC3: 3,\n  VEC4: 4,\n  MAT2: 4,\n  MAT3: 9,\n  MAT4: 16\n};\nconst post_process_gltf_BYTES = {\n  5120: 1,\n  5121: 1,\n  5122: 2,\n  5123: 2,\n  5125: 4,\n  5126: 4\n};\n\nconst GL_SAMPLER = {\n  TEXTURE_MAG_FILTER: 0x2800,\n  TEXTURE_MIN_FILTER: 0x2801,\n  TEXTURE_WRAP_S: 0x2802,\n  TEXTURE_WRAP_T: 0x2803,\n  REPEAT: 0x2901,\n  LINEAR: 0x2601,\n  NEAREST_MIPMAP_LINEAR: 0x2702\n};\nconst SAMPLER_PARAMETER_GLTF_TO_GL = {\n  magFilter: GL_SAMPLER.TEXTURE_MAG_FILTER,\n  minFilter: GL_SAMPLER.TEXTURE_MIN_FILTER,\n  wrapS: GL_SAMPLER.TEXTURE_WRAP_S,\n  wrapT: GL_SAMPLER.TEXTURE_WRAP_T\n};\n\nconst DEFAULT_SAMPLER = {\n  [GL_SAMPLER.TEXTURE_MAG_FILTER]: GL_SAMPLER.LINEAR,\n  [GL_SAMPLER.TEXTURE_MIN_FILTER]: GL_SAMPLER.NEAREST_MIPMAP_LINEAR,\n  [GL_SAMPLER.TEXTURE_WRAP_S]: GL_SAMPLER.REPEAT,\n  [GL_SAMPLER.TEXTURE_WRAP_T]: GL_SAMPLER.REPEAT\n};\nfunction post_process_gltf_getBytesFromComponentType(componentType) {\n  return post_process_gltf_BYTES[componentType];\n}\nfunction post_process_gltf_getSizeFromAccessorType(type) {\n  return post_process_gltf_COMPONENTS[type];\n}\nclass GLTFPostProcessor {\n  constructor() {\n    (0,defineProperty/* default */.Z)(this, \"baseUri\", '');\n    (0,defineProperty/* default */.Z)(this, \"json\", {});\n    (0,defineProperty/* default */.Z)(this, \"buffers\", []);\n    (0,defineProperty/* default */.Z)(this, \"images\", []);\n  }\n  postProcess(gltf) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    const {\n      json,\n      buffers = [],\n      images = [],\n      baseUri = ''\n    } = gltf;\n    assert_assert(json);\n    this.baseUri = baseUri;\n    this.json = json;\n    this.buffers = buffers;\n    this.images = images;\n    this._resolveTree(this.json, options);\n    return this.json;\n  }\n\n  _resolveTree(json) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    if (json.bufferViews) {\n      json.bufferViews = json.bufferViews.map((bufView, i) => this._resolveBufferView(bufView, i));\n    }\n    if (json.images) {\n      json.images = json.images.map((image, i) => this._resolveImage(image, i));\n    }\n    if (json.samplers) {\n      json.samplers = json.samplers.map((sampler, i) => this._resolveSampler(sampler, i));\n    }\n    if (json.textures) {\n      json.textures = json.textures.map((texture, i) => this._resolveTexture(texture, i));\n    }\n    if (json.accessors) {\n      json.accessors = json.accessors.map((accessor, i) => this._resolveAccessor(accessor, i));\n    }\n    if (json.materials) {\n      json.materials = json.materials.map((material, i) => this._resolveMaterial(material, i));\n    }\n    if (json.meshes) {\n      json.meshes = json.meshes.map((mesh, i) => this._resolveMesh(mesh, i));\n    }\n    if (json.nodes) {\n      json.nodes = json.nodes.map((node, i) => this._resolveNode(node, i));\n    }\n    if (json.skins) {\n      json.skins = json.skins.map((skin, i) => this._resolveSkin(skin, i));\n    }\n    if (json.scenes) {\n      json.scenes = json.scenes.map((scene, i) => this._resolveScene(scene, i));\n    }\n    if (json.scene !== undefined) {\n      json.scene = json.scenes[this.json.scene];\n    }\n  }\n  getScene(index) {\n    return this._get('scenes', index);\n  }\n  getNode(index) {\n    return this._get('nodes', index);\n  }\n  getSkin(index) {\n    return this._get('skins', index);\n  }\n  getMesh(index) {\n    return this._get('meshes', index);\n  }\n  getMaterial(index) {\n    return this._get('materials', index);\n  }\n  getAccessor(index) {\n    return this._get('accessors', index);\n  }\n  getCamera(index) {\n    return null;\n  }\n\n  getTexture(index) {\n    return this._get('textures', index);\n  }\n  getSampler(index) {\n    return this._get('samplers', index);\n  }\n  getImage(index) {\n    return this._get('images', index);\n  }\n  getBufferView(index) {\n    return this._get('bufferViews', index);\n  }\n  getBuffer(index) {\n    return this._get('buffers', index);\n  }\n  _get(array, index) {\n    if (typeof index === 'object') {\n      return index;\n    }\n    const object = this.json[array] && this.json[array][index];\n    if (!object) {\n      console.warn(\"glTF file error: Could not find \".concat(array, \"[\").concat(index, \"]\"));\n    }\n\n    return object;\n  }\n\n  _resolveScene(scene, index) {\n    scene.id = scene.id || \"scene-\".concat(index);\n    scene.nodes = (scene.nodes || []).map(node => this.getNode(node));\n    return scene;\n  }\n  _resolveNode(node, index) {\n    node.id = node.id || \"node-\".concat(index);\n    if (node.children) {\n      node.children = node.children.map(child => this.getNode(child));\n    }\n    if (node.mesh !== undefined) {\n      node.mesh = this.getMesh(node.mesh);\n    } else if (node.meshes !== undefined && node.meshes.length) {\n      node.mesh = node.meshes.reduce((accum, meshIndex) => {\n        const mesh = this.getMesh(meshIndex);\n        accum.id = mesh.id;\n        accum.primitives = accum.primitives.concat(mesh.primitives);\n        return accum;\n      }, {\n        primitives: []\n      });\n    }\n    if (node.camera !== undefined) {\n      node.camera = this.getCamera(node.camera);\n    }\n    if (node.skin !== undefined) {\n      node.skin = this.getSkin(node.skin);\n    }\n    return node;\n  }\n  _resolveSkin(skin, index) {\n    skin.id = skin.id || \"skin-\".concat(index);\n    skin.inverseBindMatrices = this.getAccessor(skin.inverseBindMatrices);\n    return skin;\n  }\n  _resolveMesh(mesh, index) {\n    mesh.id = mesh.id || \"mesh-\".concat(index);\n    if (mesh.primitives) {\n      mesh.primitives = mesh.primitives.map(primitive => {\n        primitive = {\n          ...primitive\n        };\n        const attributes = primitive.attributes;\n        primitive.attributes = {};\n        for (const attribute in attributes) {\n          primitive.attributes[attribute] = this.getAccessor(attributes[attribute]);\n        }\n        if (primitive.indices !== undefined) {\n          primitive.indices = this.getAccessor(primitive.indices);\n        }\n        if (primitive.material !== undefined) {\n          primitive.material = this.getMaterial(primitive.material);\n        }\n        return primitive;\n      });\n    }\n    return mesh;\n  }\n  _resolveMaterial(material, index) {\n    material.id = material.id || \"material-\".concat(index);\n    if (material.normalTexture) {\n      material.normalTexture = {\n        ...material.normalTexture\n      };\n      material.normalTexture.texture = this.getTexture(material.normalTexture.index);\n    }\n    if (material.occlusionTexture) {\n      material.occlustionTexture = {\n        ...material.occlustionTexture\n      };\n      material.occlusionTexture.texture = this.getTexture(material.occlusionTexture.index);\n    }\n    if (material.emissiveTexture) {\n      material.emmisiveTexture = {\n        ...material.emmisiveTexture\n      };\n      material.emissiveTexture.texture = this.getTexture(material.emissiveTexture.index);\n    }\n    if (!material.emissiveFactor) {\n      material.emissiveFactor = material.emmisiveTexture ? [1, 1, 1] : [0, 0, 0];\n    }\n    if (material.pbrMetallicRoughness) {\n      material.pbrMetallicRoughness = {\n        ...material.pbrMetallicRoughness\n      };\n      const mr = material.pbrMetallicRoughness;\n      if (mr.baseColorTexture) {\n        mr.baseColorTexture = {\n          ...mr.baseColorTexture\n        };\n        mr.baseColorTexture.texture = this.getTexture(mr.baseColorTexture.index);\n      }\n      if (mr.metallicRoughnessTexture) {\n        mr.metallicRoughnessTexture = {\n          ...mr.metallicRoughnessTexture\n        };\n        mr.metallicRoughnessTexture.texture = this.getTexture(mr.metallicRoughnessTexture.index);\n      }\n    }\n    return material;\n  }\n  _resolveAccessor(accessor, index) {\n    accessor.id = accessor.id || \"accessor-\".concat(index);\n    if (accessor.bufferView !== undefined) {\n      accessor.bufferView = this.getBufferView(accessor.bufferView);\n    }\n\n    accessor.bytesPerComponent = post_process_gltf_getBytesFromComponentType(accessor.componentType);\n    accessor.components = post_process_gltf_getSizeFromAccessorType(accessor.type);\n    accessor.bytesPerElement = accessor.bytesPerComponent * accessor.components;\n\n    if (accessor.bufferView) {\n      const buffer = accessor.bufferView.buffer;\n      const {\n        ArrayType,\n        byteLength\n      } = getAccessorArrayTypeAndLength(accessor, accessor.bufferView);\n      const byteOffset = (accessor.bufferView.byteOffset || 0) + (accessor.byteOffset || 0) + buffer.byteOffset;\n      let cutBuffer = buffer.arrayBuffer.slice(byteOffset, byteOffset + byteLength);\n      if (accessor.bufferView.byteStride) {\n        cutBuffer = this._getValueFromInterleavedBuffer(buffer, byteOffset, accessor.bufferView.byteStride, accessor.bytesPerElement, accessor.count);\n      }\n      accessor.value = new ArrayType(cutBuffer);\n    }\n    return accessor;\n  }\n\n  _getValueFromInterleavedBuffer(buffer, byteOffset, byteStride, bytesPerElement, count) {\n    const result = new Uint8Array(count * bytesPerElement);\n    for (let i = 0; i < count; i++) {\n      const elementOffset = byteOffset + i * byteStride;\n      result.set(new Uint8Array(buffer.arrayBuffer.slice(elementOffset, elementOffset + bytesPerElement)), i * bytesPerElement);\n    }\n    return result.buffer;\n  }\n  _resolveTexture(texture, index) {\n    texture.id = texture.id || \"texture-\".concat(index);\n    texture.sampler = 'sampler' in texture ? this.getSampler(texture.sampler) : DEFAULT_SAMPLER;\n    texture.source = this.getImage(texture.source);\n    return texture;\n  }\n  _resolveSampler(sampler, index) {\n    sampler.id = sampler.id || \"sampler-\".concat(index);\n    sampler.parameters = {};\n    for (const key in sampler) {\n      const glEnum = this._enumSamplerParameter(key);\n      if (glEnum !== undefined) {\n        sampler.parameters[glEnum] = sampler[key];\n      }\n    }\n    return sampler;\n  }\n  _enumSamplerParameter(key) {\n    return SAMPLER_PARAMETER_GLTF_TO_GL[key];\n  }\n  _resolveImage(image, index) {\n    image.id = image.id || \"image-\".concat(index);\n    if (image.bufferView !== undefined) {\n      image.bufferView = this.getBufferView(image.bufferView);\n    }\n\n    const preloadedImage = this.images[index];\n    if (preloadedImage) {\n      image.image = preloadedImage;\n    }\n    return image;\n  }\n  _resolveBufferView(bufferView, index) {\n    const bufferIndex = bufferView.buffer;\n    const result = {\n      id: \"bufferView-\".concat(index),\n      ...bufferView,\n      buffer: this.buffers[bufferIndex]\n    };\n\n    const arrayBuffer = this.buffers[bufferIndex].arrayBuffer;\n    let byteOffset = this.buffers[bufferIndex].byteOffset || 0;\n    if ('byteOffset' in bufferView) {\n      byteOffset += bufferView.byteOffset;\n    }\n    result.data = new Uint8Array(arrayBuffer, byteOffset, bufferView.byteLength);\n    return result;\n  }\n  _resolveCamera(camera, index) {\n    camera.id = camera.id || \"camera-\".concat(index);\n    if (camera.perspective) {\n    }\n    if (camera.orthographic) {\n    }\n    return camera;\n  }\n}\nfunction postProcessGLTF(gltf, options) {\n  return new GLTFPostProcessor().postProcess(gltf, options);\n}\n//# sourceMappingURL=post-process-gltf.js.map\n;// CONCATENATED MODULE: ./node_modules/@loaders.gl/gltf/dist/esm/lib/parsers/parse-glb.js\n\n\n\nconst MAGIC_glTF = 0x676c5446;\n\nconst GLB_FILE_HEADER_SIZE = 12;\nconst GLB_CHUNK_HEADER_SIZE = 8;\nconst GLB_CHUNK_TYPE_JSON = 0x4e4f534a;\nconst GLB_CHUNK_TYPE_BIN = 0x004e4942;\nconst GLB_CHUNK_TYPE_JSON_XVIZ_DEPRECATED = 0;\nconst GLB_CHUNK_TYPE_BIX_XVIZ_DEPRECATED = 1;\n\nconst GLB_V1_CONTENT_FORMAT_JSON = 0x0;\nconst LE = true;\n\nfunction parse_glb_getMagicString(dataView) {\n  let byteOffset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n  return \"\".concat(String.fromCharCode(dataView.getUint8(byteOffset + 0))).concat(String.fromCharCode(dataView.getUint8(byteOffset + 1))).concat(String.fromCharCode(dataView.getUint8(byteOffset + 2))).concat(String.fromCharCode(dataView.getUint8(byteOffset + 3)));\n}\n\nfunction parse_glb_isGLB(arrayBuffer) {\n  let byteOffset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n  let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  const dataView = new DataView(arrayBuffer);\n  const {\n    magic = MAGIC_glTF\n  } = options;\n  const magic1 = dataView.getUint32(byteOffset, false);\n  return magic1 === magic || magic1 === MAGIC_glTF;\n}\nfunction parseGLBSync(glb, arrayBuffer) {\n  let byteOffset = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n  let options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n  const dataView = new DataView(arrayBuffer);\n\n  const type = parse_glb_getMagicString(dataView, byteOffset + 0);\n  const version = dataView.getUint32(byteOffset + 4, LE);\n  const byteLength = dataView.getUint32(byteOffset + 8, LE);\n\n  Object.assign(glb, {\n    header: {\n      byteOffset,\n      byteLength,\n      hasBinChunk: false\n    },\n    type,\n    version,\n    json: {},\n    binChunks: []\n  });\n  byteOffset += GLB_FILE_HEADER_SIZE;\n  switch (glb.version) {\n    case 1:\n      return parseGLBV1(glb, dataView, byteOffset);\n    case 2:\n      return parseGLBV2(glb, dataView, byteOffset, options = {});\n    default:\n      throw new Error(\"Invalid GLB version \".concat(glb.version, \". Only supports v1 and v2.\"));\n  }\n}\nfunction parseGLBV1(glb, dataView, byteOffset) {\n  (0,env_utils_assert/* assert */.h)(glb.header.byteLength > GLB_FILE_HEADER_SIZE + GLB_CHUNK_HEADER_SIZE);\n\n  const contentLength = dataView.getUint32(byteOffset + 0, LE);\n  const contentFormat = dataView.getUint32(byteOffset + 4, LE);\n  byteOffset += GLB_CHUNK_HEADER_SIZE;\n\n  (0,env_utils_assert/* assert */.h)(contentFormat === GLB_V1_CONTENT_FORMAT_JSON);\n  parseJSONChunk(glb, dataView, byteOffset, contentLength);\n  byteOffset += contentLength;\n  byteOffset += parseBINChunk(glb, dataView, byteOffset, glb.header.byteLength);\n  return byteOffset;\n}\nfunction parseGLBV2(glb, dataView, byteOffset, options) {\n  (0,env_utils_assert/* assert */.h)(glb.header.byteLength > GLB_FILE_HEADER_SIZE + GLB_CHUNK_HEADER_SIZE);\n  parseGLBChunksSync(glb, dataView, byteOffset, options);\n  return byteOffset + glb.header.byteLength;\n}\nfunction parseGLBChunksSync(glb, dataView, byteOffset, options) {\n  while (byteOffset + 8 <= glb.header.byteLength) {\n    const chunkLength = dataView.getUint32(byteOffset + 0, LE);\n    const chunkFormat = dataView.getUint32(byteOffset + 4, LE);\n    byteOffset += GLB_CHUNK_HEADER_SIZE;\n\n    switch (chunkFormat) {\n      case GLB_CHUNK_TYPE_JSON:\n        parseJSONChunk(glb, dataView, byteOffset, chunkLength);\n        break;\n      case GLB_CHUNK_TYPE_BIN:\n        parseBINChunk(glb, dataView, byteOffset, chunkLength);\n        break;\n\n      case GLB_CHUNK_TYPE_JSON_XVIZ_DEPRECATED:\n        if (!options.strict) {\n          parseJSONChunk(glb, dataView, byteOffset, chunkLength);\n        }\n        break;\n      case GLB_CHUNK_TYPE_BIX_XVIZ_DEPRECATED:\n        if (!options.strict) {\n          parseBINChunk(glb, dataView, byteOffset, chunkLength);\n        }\n        break;\n      default:\n        break;\n    }\n    byteOffset += padToNBytes(chunkLength, 4);\n  }\n  return byteOffset;\n}\n\nfunction parseJSONChunk(glb, dataView, byteOffset, chunkLength) {\n  const jsonChunk = new Uint8Array(dataView.buffer, byteOffset, chunkLength);\n\n  const textDecoder = new TextDecoder('utf8');\n  const jsonText = textDecoder.decode(jsonChunk);\n\n  glb.json = JSON.parse(jsonText);\n  return padToNBytes(chunkLength, 4);\n}\n\nfunction parseBINChunk(glb, dataView, byteOffset, chunkLength) {\n  glb.header.hasBinChunk = true;\n  glb.binChunks.push({\n    byteOffset,\n    byteLength: chunkLength,\n    arrayBuffer: dataView.buffer\n  });\n\n  return padToNBytes(chunkLength, 4);\n}\n//# sourceMappingURL=parse-glb.js.map\n;// CONCATENATED MODULE: ./node_modules/@loaders.gl/gltf/dist/esm/lib/parsers/parse-gltf.js\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunction isGLTF(arrayBuffer, options) {\n  const byteOffset = 0;\n  return isGLB(arrayBuffer, byteOffset, options);\n}\nasync function parseGLTF(gltf, arrayBufferOrString) {\n  var _options$gltf, _options$gltf2, _options$gltf3, _options$gltf4;\n  let byteOffset = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n  let options = arguments.length > 3 ? arguments[3] : undefined;\n  let context = arguments.length > 4 ? arguments[4] : undefined;\n  parseGLTFContainerSync(gltf, arrayBufferOrString, byteOffset, options);\n  normalizeGLTFV1(gltf, {\n    normalize: options === null || options === void 0 ? void 0 : (_options$gltf = options.gltf) === null || _options$gltf === void 0 ? void 0 : _options$gltf.normalize\n  });\n  preprocessExtensions(gltf, options, context);\n  const promises = [];\n\n  if (options !== null && options !== void 0 && (_options$gltf2 = options.gltf) !== null && _options$gltf2 !== void 0 && _options$gltf2.loadBuffers && gltf.json.buffers) {\n    await loadBuffers(gltf, options, context);\n  }\n  if (options !== null && options !== void 0 && (_options$gltf3 = options.gltf) !== null && _options$gltf3 !== void 0 && _options$gltf3.loadImages) {\n    const promise = loadImages(gltf, options, context);\n    promises.push(promise);\n  }\n  const promise = decodeExtensions(gltf, options, context);\n  promises.push(promise);\n\n  await Promise.all(promises);\n\n  return options !== null && options !== void 0 && (_options$gltf4 = options.gltf) !== null && _options$gltf4 !== void 0 && _options$gltf4.postProcess ? postProcessGLTF(gltf, options) : gltf;\n}\n\nfunction parseGLTFContainerSync(gltf, data, byteOffset, options) {\n  if (options.uri) {\n    gltf.baseUri = options.uri;\n  }\n\n  if (data instanceof ArrayBuffer && !parse_glb_isGLB(data, byteOffset, options)) {\n    const textDecoder = new TextDecoder();\n    data = textDecoder.decode(data);\n  }\n  if (typeof data === 'string') {\n    gltf.json = parseJSON(data);\n  } else if (data instanceof ArrayBuffer) {\n    const glb = {};\n    byteOffset = parseGLBSync(glb, data, byteOffset, options.glb);\n    assert_assert(glb.type === 'glTF', \"Invalid GLB magic string \".concat(glb.type));\n    gltf._glb = glb;\n    gltf.json = glb.json;\n  } else {\n    assert_assert(false, 'GLTF: must be ArrayBuffer or string');\n  }\n\n  const buffers = gltf.json.buffers || [];\n  gltf.buffers = new Array(buffers.length).fill(null);\n\n  if (gltf._glb && gltf._glb.header.hasBinChunk) {\n    const {\n      binChunks\n    } = gltf._glb;\n    gltf.buffers[0] = {\n      arrayBuffer: binChunks[0].arrayBuffer,\n      byteOffset: binChunks[0].byteOffset,\n      byteLength: binChunks[0].byteLength\n    };\n\n  }\n\n  const images = gltf.json.images || [];\n  gltf.images = new Array(images.length).fill({});\n}\n\nasync function loadBuffers(gltf, options, context) {\n  const buffers = gltf.json.buffers || [];\n  for (let i = 0; i < buffers.length; ++i) {\n    const buffer = buffers[i];\n    if (buffer.uri) {\n      var _context$fetch, _response$arrayBuffer;\n      const {\n        fetch\n      } = context;\n      assert_assert(fetch);\n      const uri = resolveUrl(buffer.uri, options);\n      const response = await (context === null || context === void 0 ? void 0 : (_context$fetch = context.fetch) === null || _context$fetch === void 0 ? void 0 : _context$fetch.call(context, uri));\n      const arrayBuffer = await (response === null || response === void 0 ? void 0 : (_response$arrayBuffer = response.arrayBuffer) === null || _response$arrayBuffer === void 0 ? void 0 : _response$arrayBuffer.call(response));\n      gltf.buffers[i] = {\n        arrayBuffer,\n        byteOffset: 0,\n        byteLength: arrayBuffer.byteLength\n      };\n      delete buffer.uri;\n    } else if (gltf.buffers[i] === null) {\n      gltf.buffers[i] = {\n        arrayBuffer: new ArrayBuffer(buffer.byteLength),\n        byteOffset: 0,\n        byteLength: buffer.byteLength\n      };\n    }\n  }\n}\n\nasync function loadImages(gltf, options, context) {\n  const imageIndices = getReferencesImageIndices(gltf);\n  const images = gltf.json.images || [];\n  const promises = [];\n  for (const imageIndex of imageIndices) {\n    promises.push(loadImage(gltf, images[imageIndex], imageIndex, options, context));\n  }\n  return await Promise.all(promises);\n}\n\nfunction getReferencesImageIndices(gltf) {\n  const imageIndices = new Set();\n  const textures = gltf.json.textures || [];\n  for (const texture of textures) {\n    if (texture.source !== undefined) {\n      imageIndices.add(texture.source);\n    }\n  }\n  return Array.from(imageIndices).sort();\n}\n\nasync function loadImage(gltf, image, index, options, context) {\n  const {\n    fetch,\n    parse\n  } = context;\n  let arrayBuffer;\n  if (image.uri && !image.hasOwnProperty('bufferView')) {\n    const uri = resolveUrl(image.uri, options);\n    const response = await fetch(uri);\n    arrayBuffer = await response.arrayBuffer();\n    image.bufferView = {\n      data: arrayBuffer\n    };\n  }\n  if (Number.isFinite(image.bufferView)) {\n    const array = getTypedArrayForBufferView(gltf.json, gltf.buffers, image.bufferView);\n    arrayBuffer = (0,array_buffer_utils/* sliceArrayBuffer */.qv)(array.buffer, array.byteOffset, array.byteLength);\n  }\n  assert_assert(arrayBuffer, 'glTF image has no data');\n\n  let parsedImage = await parse(arrayBuffer, [image_loader/* ImageLoader */.S, BasisLoader], {\n    mimeType: image.mimeType,\n    basis: options.basis || {\n      format: selectSupportedBasisFormat()\n    }\n  }, context);\n  if (parsedImage && parsedImage[0]) {\n    parsedImage = {\n      compressed: true,\n      mipmaps: false,\n      width: parsedImage[0].width,\n      height: parsedImage[0].height,\n      data: parsedImage[0]\n    };\n  }\n\n  gltf.images = gltf.images || [];\n  gltf.images[index] = parsedImage;\n}\n//# sourceMappingURL=parse-gltf.js.map\n;// CONCATENATED MODULE: ./node_modules/@loaders.gl/gltf/dist/esm/gltf-loader.js\n\n\nconst GLTFLoader = {\n  name: 'glTF',\n  id: 'gltf',\n  module: 'gltf',\n  version: VERSION,\n  extensions: ['gltf', 'glb'],\n  mimeTypes: ['model/gltf+json', 'model/gltf-binary'],\n  text: true,\n  binary: true,\n  tests: ['glTF'],\n  parse: gltf_loader_parse,\n  options: {\n    gltf: {\n      normalize: true,\n      loadBuffers: true,\n      loadImages: true,\n      decompressMeshes: true,\n      postProcess: true\n    },\n\n    log: console\n  },\n\n  deprecatedOptions: {\n    fetchImages: 'gltf.loadImages',\n    createImages: 'gltf.loadImages',\n    decompress: 'gltf.decompressMeshes',\n    postProcess: 'gltf.postProcess',\n    gltf: {\n      decompress: 'gltf.decompressMeshes'\n    }\n  }\n};\nasync function gltf_loader_parse(arrayBuffer) {\n  let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  let context = arguments.length > 2 ? arguments[2] : undefined;\n  options = {\n    ...GLTFLoader.options,\n    ...options\n  };\n  options.gltf = {\n    ...GLTFLoader.options.gltf,\n    ...options.gltf\n  };\n  const {\n    byteOffset = 0\n  } = options;\n  const gltf = {};\n  return await parseGLTF(gltf, arrayBuffer, byteOffset, options, context);\n}\n//# sourceMappingURL=gltf-loader.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNTI0NjIuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQ08sZ0JBQWdCLEtBQThCLGFBQWEsQ0FBUTtBQUMxRSxtQzs7Ozs7QUNETyxNQUFNLGVBQU8sR0FBRyxLQUE4QixhQUFhLENBQU07QUFDeEUsbUM7Ozs7Ozs7QUNEbUU7QUFDaEI7QUFDTjtBQUNpQjs7QUFFOUQ7QUFDQSxNQUFNLHFCQUFPLEdBQUcsS0FBOEIsYUFBYSxDQUFNO0FBQ2pFOztBQUVPLGVBQWUseUJBQVc7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxPQUFPLHlCQUFTO0FBQ2hCO0FBQ0E7O0FBRUE7QUFDQSxJQUFJLHdCQUFNO0FBQ1Ysc0VBQXNFLHFCQUFPO0FBQzdFOztBQUVBLE1BQU0sd0JBQVE7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPLHlCQUFTO0FBQ2hCO0FBQ0EsYUFBYSxzQkFBSSxJQUFJLHNDQUFvQixXQUFXLHNDQUFvQjtBQUN4RSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsTUFBTSx3QkFBUTtBQUNkO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxPQUFPLHlCQUFTO0FBQ2hCLFdBQVcsd0NBQXNCLElBQUksd0NBQXNCO0FBQzNEO0FBQ0EsTUFBTSx3QkFBUTtBQUNkLGNBQWMsc0JBQU07QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Qzs7O0FDcEZBLE1BQU0sMkJBQU8sR0FBRyxLQUE4QixhQUFhLENBQU07O0FBRVY7QUFDdkQsZ0ZBQWdGLDJCQUFPO0FBQ3ZGLDhFQUE4RSwyQkFBTztBQUNyRjs7QUFFTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRCx5QkFBVyxvREFBb0QseUJBQVc7O0FBRTNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBOztBQUVPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EseURBQXlELHlCQUFXLG1EQUFtRCx5QkFBVzs7QUFFbEk7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQSwrQzs7O0FDckZPOztBQUVQO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUM7O0FDckVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLDJDOzs7O0FDdENpQztBQUNvQztBQUNMO0FBQ2hFO0FBQ0E7O0FBRU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxxQzs7OztBQ3BDeUY7QUFDOUI7QUFDYztBQUNyQztBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksaURBQWlEO0FBQzdELEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsWUFBWSxvREFBb0Q7QUFDaEUsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLFlBQVkscURBQXFEO0FBQ2pFLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsWUFBWSx1REFBdUQ7QUFDbkUsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLFlBQVksd0RBQXdEO0FBQ3BFLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxZQUFZLG9EQUFvRDtBQUNoRSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVlO0FBQ2Y7QUFDQSxRQUFRLEtBQUs7QUFDYixxQ0FBcUMsc0JBQXNCO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTSxRQUFRLHdCQUF3QjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQyxzQkFBc0I7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsUUFBUSx3QkFBd0I7QUFDeEM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIseUJBQXlCO0FBQ3REO0FBQ0E7QUFDQSwrQkFBK0IsMEJBQTBCO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QiwwQkFBMEI7QUFDdkQ7QUFDQTtBQUNBOztBQUVBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVPO0FBQ1AsMkJBQTJCLDZCQUE2QjtBQUN4RDtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUM7O0FDblBxRDtBQUNQO0FBQ0s7O0FBRTVDO0FBQ1A7QUFDQSxNQUFNLHlCQUFTO0FBQ2Y7QUFDQSxXQUFXLGVBQU87QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFTztBQUNQO0FBQ0EsU0FBUyxVQUFVO0FBQ25COztBQUVPLG9DQUFvQyxpRUFBaUI7QUFDckQsOEJBQThCLDJEQUFXO0FBQ2hELHdDOzs7Ozs7QUM3Qk87QUFDUDtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsWUFBWTtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEOztBQzFCMEU7O0FBRW5FO0FBQ1A7QUFDQTtBQUNBLElBQUk7QUFDSiw2RUFBNkUsa0JBQWtCO0FBQy9GO0FBQ0E7QUFDQSxzQzs7Ozs7QUNSTyxTQUFTLGFBQU07QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQzs7O0FDTE87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDOzs7QUNYeUM7O0FBRWxDO0FBQ1A7QUFDQSxFQUFFLGFBQU07O0FBRVI7QUFDQTtBQUNBLEVBQUUsYUFBTTtBQUNSO0FBQ0E7QUFDQTs7QUFFTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkM7Ozs7Ozs7O0FDbkI2Qzs7QUFFdEM7QUFDUCxFQUFFLGtDQUFNO0FBQ1IsRUFBRSxrQ0FBTTtBQUNSO0FBQ0E7O0FBRU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsNkM7O0FDN0J5QztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFLGFBQU07QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQzs7QUNyRHdFO0FBQ1o7QUFDUTtBQUMzQjtBQUNvRjtBQUM3SDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ2U7O0FBRWY7QUFDQSxJQUFJLGlDQUFlO0FBQ25CLElBQUksaUNBQWU7QUFDbkIsSUFBSSxpQ0FBZTtBQUNuQjtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLElBQUksYUFBTTs7QUFFVjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNLEVBQUUsNkJBQTZCO0FBQ3JDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUksYUFBTTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUksYUFBTTtBQUNWO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxxQkFBcUIsa0RBQXNCO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJLGFBQU07O0FBRVY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsdUJBQXVCLFdBQVc7O0FBRWxDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVksdUJBQXVCO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLHlCQUF5QjtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esc0JBQXNCLFdBQVc7QUFDakM7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQix1QkFBdUI7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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGlHQUFpRztBQUNqRztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2Qix5QkFBeUI7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxpQ0FBaUMsMkNBQXlCO0FBQzFELDBCQUEwQix5Q0FBdUI7QUFDakQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsRUFBRSw2QkFBNkI7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxvQkFBb0IsV0FBVztBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBLDZDOzs7O0FDaFcrRDtBQUMvRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxTQUFTLHdCQUFjO0FBQ3ZCO0FBQ0E7QUFDQTs7QUFFTyxTQUFTLGVBQUs7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDZTtBQUNmO0FBQ0E7QUFDQTs7QUFFQSxlQUFlLHdCQUFjO0FBQzdCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrREFBK0Q7QUFDL0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUUsa0NBQU07O0FBRVI7QUFDQTtBQUNBOztBQUVBLEVBQUUsa0NBQU07QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFLGtDQUFNO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixXQUFXO0FBQzdCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxTQUFTLFdBQVc7QUFDcEI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSCxTQUFTLFdBQVc7QUFDcEI7QUFDQSxxQzs7OztBQ2hJK0U7QUFDOUI7QUFDc0I7QUFDOUI7QUFDYztBQUNvQjtBQUNLO0FBQ3JCO0FBQ0E7QUFDVDs7QUFFM0M7QUFDUDtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFLGVBQWU7QUFDakI7QUFDQSxHQUFHO0FBQ0gsRUFBRSxvQkFBb0I7QUFDdEI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsZ0JBQWdCO0FBQ2xDOztBQUVBOztBQUVBLHlKQUF5SixlQUFlO0FBQ3hLOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHNDQUFzQyxlQUFLO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLFNBQVM7QUFDekIsSUFBSTtBQUNKO0FBQ0EsaUJBQWlCLFlBQVk7QUFDN0IsSUFBSSxhQUFNO0FBQ1Y7QUFDQTtBQUNBLElBQUk7QUFDSixJQUFJLGFBQU07QUFDVjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsZ0RBQWdEO0FBQ2hEOztBQUVBO0FBQ0E7QUFDQSxrQkFBa0Isb0JBQW9CO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1IsTUFBTSxhQUFNO0FBQ1osa0JBQWtCLFVBQVU7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsZ0JBQWdCLFVBQVU7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsMEJBQTBCO0FBQzVDLGtCQUFrQiwrQ0FBZ0I7QUFDbEM7QUFDQSxFQUFFLGFBQU07O0FBRVIsOENBQThDLCtCQUFXLEVBQUUsV0FBVztBQUN0RTtBQUNBO0FBQ0EsY0FBYywwQkFBMEI7QUFDeEM7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHNDOztBQzdLOEM7QUFDTztBQUM5QztBQUNQO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTyxlQUFlLGlCQUFLO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLGVBQWUsU0FBUztBQUN4QjtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdnVlMy13ZWJwYWNrNS8uL25vZGVfbW9kdWxlcy9AbG9hZGVycy5nbC9nbHRmL2Rpc3QvZXNtL2xpYi91dGlscy92ZXJzaW9uLmpzP2Y4ZjkiLCJ3ZWJwYWNrOi8vdnVlMy13ZWJwYWNrNS8uL25vZGVfbW9kdWxlcy9AbG9hZGVycy5nbC90ZXh0dXJlcy9kaXN0L2VzbS9saWIvdXRpbHMvdmVyc2lvbi5qcz80M2VjIiwid2VicGFjazovL3Z1ZTMtd2VicGFjazUvLi9ub2RlX21vZHVsZXMvQGxvYWRlcnMuZ2wvd29ya2VyLXV0aWxzL2Rpc3QvZXNtL2xpYi9saWJyYXJ5LXV0aWxzL2xpYnJhcnktdXRpbHMuanM/ZTM0OCIsIndlYnBhY2s6Ly92dWUzLXdlYnBhY2s1Ly4vbm9kZV9tb2R1bGVzL0Bsb2FkZXJzLmdsL3RleHR1cmVzL2Rpc3QvZXNtL2xpYi9wYXJzZXJzL2Jhc2lzLW1vZHVsZS1sb2FkZXIuanM/Y2RlOCIsIndlYnBhY2s6Ly92dWUzLXdlYnBhY2s1Ly4vbm9kZV9tb2R1bGVzL0Bsb2FkZXJzLmdsL3RleHR1cmVzL2Rpc3QvZXNtL2xpYi9nbC1leHRlbnNpb25zLmpzPzFhNzIiLCJ3ZWJwYWNrOi8vdnVlMy13ZWJwYWNrNS8uL25vZGVfbW9kdWxlcy9AbG9hZGVycy5nbC90ZXh0dXJlcy9kaXN0L2VzbS9saWIvdXRpbHMvdGV4dHVyZS1mb3JtYXRzLmpzP2IzNzAiLCJ3ZWJwYWNrOi8vdnVlMy13ZWJwYWNrNS8uL25vZGVfbW9kdWxlcy9AbG9hZGVycy5nbC90ZXh0dXJlcy9kaXN0L2VzbS9saWIvcGFyc2Vycy9wYXJzZS1rdHguanM/ZjEzOCIsIndlYnBhY2s6Ly92dWUzLXdlYnBhY2s1Ly4vbm9kZV9tb2R1bGVzL0Bsb2FkZXJzLmdsL3RleHR1cmVzL2Rpc3QvZXNtL2xpYi9wYXJzZXJzL3BhcnNlLWJhc2lzLmpzPzY3ODQiLCJ3ZWJwYWNrOi8vdnVlMy13ZWJwYWNrNS8uL25vZGVfbW9kdWxlcy9AbG9hZGVycy5nbC90ZXh0dXJlcy9kaXN0L2VzbS9iYXNpcy1sb2FkZXIuanM/MThmYyIsIndlYnBhY2s6Ly92dWUzLXdlYnBhY2s1Ly4vbm9kZV9tb2R1bGVzL0Bsb2FkZXJzLmdsL2xvYWRlci11dGlscy9kaXN0L2VzbS9saWIvYmluYXJ5LXV0aWxzL2dldC1maXJzdC1jaGFyYWN0ZXJzLmpzPzNhNDUiLCJ3ZWJwYWNrOi8vdnVlMy13ZWJwYWNrNS8uL25vZGVfbW9kdWxlcy9AbG9hZGVycy5nbC9sb2FkZXItdXRpbHMvZGlzdC9lc20vbGliL3BhcnNlci11dGlscy9wYXJzZS1qc29uLmpzPzI2ZDYiLCJ3ZWJwYWNrOi8vdnVlMy13ZWJwYWNrNS8uL25vZGVfbW9kdWxlcy9AbG9hZGVycy5nbC9nbHRmL2Rpc3QvZXNtL2xpYi91dGlscy9hc3NlcnQuanM/NGMzZSIsIndlYnBhY2s6Ly92dWUzLXdlYnBhY2s1Ly4vbm9kZV9tb2R1bGVzL0Bsb2FkZXJzLmdsL2dsdGYvZGlzdC9lc20vbGliL2dsdGYtdXRpbHMvcmVzb2x2ZS11cmwuanM/ZWY2MyIsIndlYnBhY2s6Ly92dWUzLXdlYnBhY2s1Ly4vbm9kZV9tb2R1bGVzL0Bsb2FkZXJzLmdsL2dsdGYvZGlzdC9lc20vbGliL2dsdGYtdXRpbHMvZ2V0LXR5cGVkLWFycmF5LmpzPzUzNDciLCJ3ZWJwYWNrOi8vdnVlMy13ZWJwYWNrNS8uL25vZGVfbW9kdWxlcy9AbG9hZGVycy5nbC9sb2FkZXItdXRpbHMvZGlzdC9lc20vbGliL2JpbmFyeS11dGlscy9tZW1vcnktY29weS11dGlscy5qcz9hNDkwIiwid2VicGFjazovL3Z1ZTMtd2VicGFjazUvLi9ub2RlX21vZHVsZXMvQGxvYWRlcnMuZ2wvZ2x0Zi9kaXN0L2VzbS9saWIvZ2x0Zi11dGlscy9nbHRmLXV0aWxzLmpzPzIxN2EiLCJ3ZWJwYWNrOi8vdnVlMy13ZWJwYWNrNS8uL25vZGVfbW9kdWxlcy9AbG9hZGVycy5nbC9nbHRmL2Rpc3QvZXNtL2xpYi9hcGkvZ2x0Zi1zY2VuZWdyYXBoLmpzPzA3NDUiLCJ3ZWJwYWNrOi8vdnVlMy13ZWJwYWNrNS8uL25vZGVfbW9kdWxlcy9AbG9hZGVycy5nbC9nbHRmL2Rpc3QvZXNtL21lc2hvcHQvbWVzaG9wdC1kZWNvZGVyLmpzPzU1ZWUiLCJ3ZWJwYWNrOi8vdnVlMy13ZWJwYWNrNS8uL25vZGVfbW9kdWxlcy9AbG9hZGVycy5nbC9nbHRmL2Rpc3QvZXNtL2xpYi9leHRlbnNpb25zL0VYVF9tZXNob3B0X2NvbXByZXNzaW9uLmpzPzE0ZTMiLCJ3ZWJwYWNrOi8vdnVlMy13ZWJwYWNrNS8uL25vZGVfbW9kdWxlcy9AbG9hZGVycy5nbC9pbWFnZXMvZGlzdC9lc20vbGliL2NhdGVnb3J5LWFwaS9pbWFnZS1mb3JtYXQuanM/ZTY5YyIsIndlYnBhY2s6Ly92dWUzLXdlYnBhY2s1Ly4vbm9kZV9tb2R1bGVzL0Bsb2FkZXJzLmdsL2dsdGYvZGlzdC9lc20vbGliL2V4dGVuc2lvbnMvRVhUX3RleHR1cmVfd2VicC5qcz82MjA3Iiwid2VicGFjazovL3Z1ZTMtd2VicGFjazUvLi9ub2RlX21vZHVsZXMvQGxvYWRlcnMuZ2wvZ2x0Zi9kaXN0L2VzbS9saWIvZXh0ZW5zaW9ucy9LSFJfdGV4dHVyZV9iYXNpc3UuanM/YjhjMyIsIndlYnBhY2s6Ly92dWUzLXdlYnBhY2s1Ly4vbm9kZV9tb2R1bGVzL0Bsb2FkZXJzLmdsL2RyYWNvL2Rpc3QvZXNtL2xpYi91dGlscy92ZXJzaW9uLmpzP2IwNWUiLCJ3ZWJwYWNrOi8vdnVlMy13ZWJwYWNrNS8uL25vZGVfbW9kdWxlcy9AbG9hZGVycy5nbC9kcmFjby9kaXN0L2VzbS9kcmFjby1sb2FkZXIuanM/Zjc3NyIsIndlYnBhY2s6Ly92dWUzLXdlYnBhY2s1Ly4vbm9kZV9tb2R1bGVzL0Bsb2FkZXJzLmdsL3NjaGVtYS9kaXN0L2VzbS9jYXRlZ29yeS9tZXNoL21lc2gtdXRpbHMuanM/ZWFlZiIsIndlYnBhY2s6Ly92dWUzLXdlYnBhY2s1Ly4vbm9kZV9tb2R1bGVzL0Bsb2FkZXJzLmdsL3NjaGVtYS9kaXN0L2VzbS9saWIvc2NoZW1hL2ltcGwvZmllbGQuanM/MTJlNiIsIndlYnBhY2s6Ly92dWUzLXdlYnBhY2s1Ly4vbm9kZV9tb2R1bGVzL0Bsb2FkZXJzLmdsL3NjaGVtYS9kaXN0L2VzbS9saWIvc2NoZW1hL2ltcGwvZW51bS5qcz81ZjFjIiwid2VicGFjazovL3Z1ZTMtd2VicGFjazUvLi9ub2RlX21vZHVsZXMvQGxvYWRlcnMuZ2wvc2NoZW1hL2Rpc3QvZXNtL2xpYi9zY2hlbWEvaW1wbC90eXBlLmpzPzFhMGEiLCJ3ZWJwYWNrOi8vdnVlMy13ZWJwYWNrNS8uL25vZGVfbW9kdWxlcy9AbG9hZGVycy5nbC9zY2hlbWEvZGlzdC9lc20vbGliL2Fycm93L2Fycm93LWxpa2UtdHlwZS11dGlscy5qcz8wMTZiIiwid2VicGFjazovL3Z1ZTMtd2VicGFjazUvLi9ub2RlX21vZHVsZXMvQGxvYWRlcnMuZ2wvc2NoZW1hL2Rpc3QvZXNtL2NhdGVnb3J5L21lc2gvZGVkdWNlLW1lc2gtc2NoZW1hLmpzP2UzZjgiLCJ3ZWJwYWNrOi8vdnVlMy13ZWJwYWNrNS8uL25vZGVfbW9kdWxlcy9AbG9hZGVycy5nbC9zY2hlbWEvZGlzdC9lc20vbGliL3V0aWxzL2Fzc2VydC5qcz9iOGJiIiwid2VicGFjazovL3Z1ZTMtd2VicGFjazUvLi9ub2RlX21vZHVsZXMvQGxvYWRlcnMuZ2wvc2NoZW1hL2Rpc3QvZXNtL2xpYi9zY2hlbWEvaW1wbC9zY2hlbWEuanM/NzljYSIsIndlYnBhY2s6Ly92dWUzLXdlYnBhY2s1Ly4vbm9kZV9tb2R1bGVzL0Bsb2FkZXJzLmdsL2RyYWNvL2Rpc3QvZXNtL2xpYi91dGlscy9nZXQtZHJhY28tc2NoZW1hLmpzPzEwMGQiLCJ3ZWJwYWNrOi8vdnVlMy13ZWJwYWNrNS8uL25vZGVfbW9kdWxlcy9AbG9hZGVycy5nbC9kcmFjby9kaXN0L2VzbS9saWIvZHJhY28tcGFyc2VyLmpzPzk0ZGYiLCJ3ZWJwYWNrOi8vdnVlMy13ZWJwYWNrNS8uL25vZGVfbW9kdWxlcy9AbG9hZGVycy5nbC9kcmFjby9kaXN0L2VzbS9saWIvZHJhY28tbW9kdWxlLWxvYWRlci5qcz80NzliIiwid2VicGFjazovL3Z1ZTMtd2VicGFjazUvLi9ub2RlX21vZHVsZXMvQGxvYWRlcnMuZ2wvZHJhY28vZGlzdC9lc20vaW5kZXguanM/ZWY3YiIsIndlYnBhY2s6Ly92dWUzLXdlYnBhY2s1Ly4vbm9kZV9tb2R1bGVzL0Bsb2FkZXJzLmdsL2dsdGYvZGlzdC9lc20vbGliL2dsdGYtdXRpbHMvZ2x0Zi1hdHRyaWJ1dGUtdXRpbHMuanM/YTRmOSIsIndlYnBhY2s6Ly92dWUzLXdlYnBhY2s1Ly4vbm9kZV9tb2R1bGVzL0Bsb2FkZXJzLmdsL2dsdGYvZGlzdC9lc20vbGliL2V4dGVuc2lvbnMvS0hSX2RyYWNvX21lc2hfY29tcHJlc3Npb24uanM/Njc3YiIsIndlYnBhY2s6Ly92dWUzLXdlYnBhY2s1Ly4vbm9kZV9tb2R1bGVzL0Bsb2FkZXJzLmdsL2dsdGYvZGlzdC9lc20vbGliL2dsdGYtdXRpbHMvZ2x0Zi1jb25zdGFudHMuanM/MDBkMyIsIndlYnBhY2s6Ly92dWUzLXdlYnBhY2s1Ly4vbm9kZV9tb2R1bGVzL0Bsb2FkZXJzLmdsL2dsdGYvZGlzdC9lc20vbGliL2V4dGVuc2lvbnMvS0hSX3RleHR1cmVfdHJhbnNmb3JtLmpzP2U2ODYiLCJ3ZWJwYWNrOi8vdnVlMy13ZWJwYWNrNS8uL25vZGVfbW9kdWxlcy9AbG9hZGVycy5nbC9nbHRmL2Rpc3QvZXNtL2xpYi9leHRlbnNpb25zL2RlcHJlY2F0ZWQvS0hSX2xpZ2h0c19wdW5jdHVhbC5qcz85MTcxIiwid2VicGFjazovL3Z1ZTMtd2VicGFjazUvLi9ub2RlX21vZHVsZXMvQGxvYWRlcnMuZ2wvZ2x0Zi9kaXN0L2VzbS9saWIvZXh0ZW5zaW9ucy9kZXByZWNhdGVkL0tIUl9tYXRlcmlhbHNfdW5saXQuanM/OTBmZCIsIndlYnBhY2s6Ly92dWUzLXdlYnBhY2s1Ly4vbm9kZV9tb2R1bGVzL0Bsb2FkZXJzLmdsL2dsdGYvZGlzdC9lc20vbGliL2V4dGVuc2lvbnMvZGVwcmVjYXRlZC9LSFJfdGVjaG5pcXVlc193ZWJnbC5qcz83YjdhIiwid2VicGFjazovL3Z1ZTMtd2VicGFjazUvLi9ub2RlX21vZHVsZXMvQGxvYWRlcnMuZ2wvZ2x0Zi9kaXN0L2VzbS9saWIvZXh0ZW5zaW9ucy9kZXByZWNhdGVkL0VYVF9mZWF0dXJlX21ldGFkYXRhLmpzPzU1NGMiLCJ3ZWJwYWNrOi8vdnVlMy13ZWJwYWNrNS8uL25vZGVfbW9kdWxlcy9AbG9hZGVycy5nbC9nbHRmL2Rpc3QvZXNtL2xpYi9hcGkvZ2x0Zi1leHRlbnNpb25zLmpzPzk4ODAiLCJ3ZWJwYWNrOi8vdnVlMy13ZWJwYWNrNS8uL25vZGVfbW9kdWxlcy9AbG9hZGVycy5nbC9nbHRmL2Rpc3QvZXNtL2xpYi9leHRlbnNpb25zL0tIUl9iaW5hcnlfZ2x0Zi5qcz85MDlmIiwid2VicGFjazovL3Z1ZTMtd2VicGFjazUvLi9ub2RlX21vZHVsZXMvQGxvYWRlcnMuZ2wvZ2x0Zi9kaXN0L2VzbS9saWIvYXBpL25vcm1hbGl6ZS1nbHRmLXYxLmpzP2E2ZmYiLCJ3ZWJwYWNrOi8vdnVlMy13ZWJwYWNrNS8uL25vZGVfbW9kdWxlcy9AbG9hZGVycy5nbC9nbHRmL2Rpc3QvZXNtL2xpYi9hcGkvcG9zdC1wcm9jZXNzLWdsdGYuanM/NGVhZiIsIndlYnBhY2s6Ly92dWUzLXdlYnBhY2s1Ly4vbm9kZV9tb2R1bGVzL0Bsb2FkZXJzLmdsL2dsdGYvZGlzdC9lc20vbGliL3BhcnNlcnMvcGFyc2UtZ2xiLmpzPzc4OWQiLCJ3ZWJwYWNrOi8vdnVlMy13ZWJwYWNrNS8uL25vZGVfbW9kdWxlcy9AbG9hZGVycy5nbC9nbHRmL2Rpc3QvZXNtL2xpYi9wYXJzZXJzL3BhcnNlLWdsdGYuanM/NTMyZCIsIndlYnBhY2s6Ly92dWUzLXdlYnBhY2s1Ly4vbm9kZV9tb2R1bGVzL0Bsb2FkZXJzLmdsL2dsdGYvZGlzdC9lc20vZ2x0Zi1sb2FkZXIuanM/MGZjYiJdLCJzb3VyY2VzQ29udGVudCI6WyJcbmV4cG9ydCBjb25zdCBWRVJTSU9OID0gdHlwZW9mIFwiMy4zLjFcIiAhPT0gJ3VuZGVmaW5lZCcgPyBcIjMuMy4xXCIgOiAnbGF0ZXN0Jztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXZlcnNpb24uanMubWFwIiwiXG5leHBvcnQgY29uc3QgVkVSU0lPTiA9IHR5cGVvZiBcIjMuMy4xXCIgIT09ICd1bmRlZmluZWQnID8gXCIzLjMuMVwiIDogJ2JldGEnO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dmVyc2lvbi5qcy5tYXAiLCJcbmltcG9ydCB7IGdsb2JhbCwgaXNCcm93c2VyLCBpc1dvcmtlciB9IGZyb20gJy4uL2Vudi11dGlscy9nbG9iYWxzJztcbmltcG9ydCAqIGFzIG5vZGUgZnJvbSAnLi4vbm9kZS9yZXF1aXJlLXV0aWxzLm5vZGUnO1xuaW1wb3J0IHsgYXNzZXJ0IH0gZnJvbSAnLi4vZW52LXV0aWxzL2Fzc2VydCc7XG5pbXBvcnQgeyBWRVJTSU9OIGFzIF9fVkVSU0lPTl9fIH0gZnJvbSAnLi4vZW52LXV0aWxzL3ZlcnNpb24nO1xuXG5jb25zdCBMQVRFU1QgPSAnbGF0ZXN0JztcbmNvbnN0IFZFUlNJT04gPSB0eXBlb2YgXCIzLjMuMVwiICE9PSAndW5kZWZpbmVkJyA/IFwiMy4zLjFcIiA6IExBVEVTVDtcbmNvbnN0IGxvYWRMaWJyYXJ5UHJvbWlzZXMgPSB7fTtcblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGxvYWRMaWJyYXJ5KGxpYnJhcnlVcmwpIHtcbiAgbGV0IG1vZHVsZU5hbWUgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IG51bGw7XG4gIGxldCBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiB7fTtcbiAgaWYgKG1vZHVsZU5hbWUpIHtcbiAgICBsaWJyYXJ5VXJsID0gZ2V0TGlicmFyeVVybChsaWJyYXJ5VXJsLCBtb2R1bGVOYW1lLCBvcHRpb25zKTtcbiAgfVxuXG4gIGxvYWRMaWJyYXJ5UHJvbWlzZXNbbGlicmFyeVVybF0gPVxuICBsb2FkTGlicmFyeVByb21pc2VzW2xpYnJhcnlVcmxdIHx8IGxvYWRMaWJyYXJ5RnJvbUZpbGUobGlicmFyeVVybCk7XG4gIHJldHVybiBhd2FpdCBsb2FkTGlicmFyeVByb21pc2VzW2xpYnJhcnlVcmxdO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0TGlicmFyeVVybChsaWJyYXJ5LCBtb2R1bGVOYW1lLCBvcHRpb25zKSB7XG4gIGlmIChsaWJyYXJ5LnN0YXJ0c1dpdGgoJ2h0dHAnKSkge1xuICAgIHJldHVybiBsaWJyYXJ5O1xuICB9XG5cbiAgY29uc3QgbW9kdWxlcyA9IG9wdGlvbnMubW9kdWxlcyB8fCB7fTtcbiAgaWYgKG1vZHVsZXNbbGlicmFyeV0pIHtcbiAgICByZXR1cm4gbW9kdWxlc1tsaWJyYXJ5XTtcbiAgfVxuXG4gIGlmICghaXNCcm93c2VyKSB7XG4gICAgcmV0dXJuIFwibW9kdWxlcy9cIi5jb25jYXQobW9kdWxlTmFtZSwgXCIvZGlzdC9saWJzL1wiKS5jb25jYXQobGlicmFyeSk7XG4gIH1cblxuICBpZiAob3B0aW9ucy5DRE4pIHtcbiAgICBhc3NlcnQob3B0aW9ucy5DRE4uc3RhcnRzV2l0aCgnaHR0cCcpKTtcbiAgICByZXR1cm4gXCJcIi5jb25jYXQob3B0aW9ucy5DRE4sIFwiL1wiKS5jb25jYXQobW9kdWxlTmFtZSwgXCJAXCIpLmNvbmNhdChWRVJTSU9OLCBcIi9kaXN0L2xpYnMvXCIpLmNvbmNhdChsaWJyYXJ5KTtcbiAgfVxuXG4gIGlmIChpc1dvcmtlcikge1xuICAgIHJldHVybiBcIi4uL3NyYy9saWJzL1wiLmNvbmNhdChsaWJyYXJ5KTtcbiAgfVxuICByZXR1cm4gXCJtb2R1bGVzL1wiLmNvbmNhdChtb2R1bGVOYW1lLCBcIi9zcmMvbGlicy9cIikuY29uY2F0KGxpYnJhcnkpO1xufVxuYXN5bmMgZnVuY3Rpb24gbG9hZExpYnJhcnlGcm9tRmlsZShsaWJyYXJ5VXJsKSB7XG4gIGlmIChsaWJyYXJ5VXJsLmVuZHNXaXRoKCd3YXNtJykpIHtcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKGxpYnJhcnlVcmwpO1xuICAgIHJldHVybiBhd2FpdCByZXNwb25zZS5hcnJheUJ1ZmZlcigpO1xuICB9XG4gIGlmICghaXNCcm93c2VyKSB7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBub2RlICYmIG5vZGUucmVxdWlyZUZyb21GaWxlICYmIChhd2FpdCBub2RlLnJlcXVpcmVGcm9tRmlsZShsaWJyYXJ5VXJsKSk7XG4gICAgfSBjYXRjaCB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gIH1cbiAgaWYgKGlzV29ya2VyKSB7XG4gICAgcmV0dXJuIGltcG9ydFNjcmlwdHMobGlicmFyeVVybCk7XG4gIH1cblxuICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKGxpYnJhcnlVcmwpO1xuICBjb25zdCBzY3JpcHRTb3VyY2UgPSBhd2FpdCByZXNwb25zZS50ZXh0KCk7XG4gIHJldHVybiBsb2FkTGlicmFyeUZyb21TdHJpbmcoc2NyaXB0U291cmNlLCBsaWJyYXJ5VXJsKTtcbn1cblxuZnVuY3Rpb24gbG9hZExpYnJhcnlGcm9tU3RyaW5nKHNjcmlwdFNvdXJjZSwgaWQpIHtcbiAgaWYgKCFpc0Jyb3dzZXIpIHtcbiAgICByZXR1cm4gbm9kZS5yZXF1aXJlRnJvbVN0cmluZyAmJiBub2RlLnJlcXVpcmVGcm9tU3RyaW5nKHNjcmlwdFNvdXJjZSwgaWQpO1xuICB9XG4gIGlmIChpc1dvcmtlcikge1xuICAgIGV2YWwuY2FsbChnbG9iYWwsIHNjcmlwdFNvdXJjZSk7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgY29uc3Qgc2NyaXB0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc2NyaXB0Jyk7XG4gIHNjcmlwdC5pZCA9IGlkO1xuICB0cnkge1xuICAgIHNjcmlwdC5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShzY3JpcHRTb3VyY2UpKTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHNjcmlwdC50ZXh0ID0gc2NyaXB0U291cmNlO1xuICB9XG4gIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoc2NyaXB0KTtcbiAgcmV0dXJuIG51bGw7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1saWJyYXJ5LXV0aWxzLmpzLm1hcCIsIlxuY29uc3QgVkVSU0lPTiA9IHR5cGVvZiBcIjMuMy4xXCIgIT09ICd1bmRlZmluZWQnID8gXCIzLjMuMVwiIDogJ2JldGEnO1xuXG5pbXBvcnQgeyBsb2FkTGlicmFyeSB9IGZyb20gJ0Bsb2FkZXJzLmdsL3dvcmtlci11dGlscyc7XG5jb25zdCBCQVNJU19DRE5fRU5DT0RFUl9XQVNNID0gXCJodHRwczovL3VucGtnLmNvbS9AbG9hZGVycy5nbC90ZXh0dXJlc0BcIi5jb25jYXQoVkVSU0lPTiwgXCIvZGlzdC9saWJzL2Jhc2lzX2VuY29kZXIud2FzbVwiKTtcbmNvbnN0IEJBU0lTX0NETl9FTkNPREVSX0pTID0gXCJodHRwczovL3VucGtnLmNvbS9AbG9hZGVycy5nbC90ZXh0dXJlc0BcIi5jb25jYXQoVkVSU0lPTiwgXCIvZGlzdC9saWJzL2Jhc2lzX2VuY29kZXIuanNcIik7XG5sZXQgbG9hZEJhc2lzVHJhbnNjb2RlclByb21pc2U7XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBsb2FkQmFzaXNUcmFzY29kZXJNb2R1bGUob3B0aW9ucykge1xuICBjb25zdCBtb2R1bGVzID0gb3B0aW9ucy5tb2R1bGVzIHx8IHt9O1xuICBpZiAobW9kdWxlcy5iYXNpcykge1xuICAgIHJldHVybiBtb2R1bGVzLmJhc2lzO1xuICB9XG4gIGxvYWRCYXNpc1RyYW5zY29kZXJQcm9taXNlID0gbG9hZEJhc2lzVHJhbnNjb2RlclByb21pc2UgfHwgbG9hZEJhc2lzVHJhc2NvZGVyKG9wdGlvbnMpO1xuICByZXR1cm4gYXdhaXQgbG9hZEJhc2lzVHJhbnNjb2RlclByb21pc2U7XG59XG5cbmFzeW5jIGZ1bmN0aW9uIGxvYWRCYXNpc1RyYXNjb2RlcihvcHRpb25zKSB7XG4gIGxldCBCQVNJUyA9IG51bGw7XG4gIGxldCB3YXNtQmluYXJ5ID0gbnVsbDtcbiAgW0JBU0lTLCB3YXNtQmluYXJ5XSA9IGF3YWl0IFByb21pc2UuYWxsKFthd2FpdCBsb2FkTGlicmFyeSgnYmFzaXNfdHJhbnNjb2Rlci5qcycsICd0ZXh0dXJlcycsIG9wdGlvbnMpLCBhd2FpdCBsb2FkTGlicmFyeSgnYmFzaXNfdHJhbnNjb2Rlci53YXNtJywgJ3RleHR1cmVzJywgb3B0aW9ucyldKTtcblxuICBCQVNJUyA9IEJBU0lTIHx8IGdsb2JhbFRoaXMuQkFTSVM7XG4gIHJldHVybiBhd2FpdCBpbml0aWFsaXplQmFzaXNUcmFzY29kZXJNb2R1bGUoQkFTSVMsIHdhc21CaW5hcnkpO1xufVxuXG5mdW5jdGlvbiBpbml0aWFsaXplQmFzaXNUcmFzY29kZXJNb2R1bGUoQmFzaXNNb2R1bGUsIHdhc21CaW5hcnkpIHtcbiAgY29uc3Qgb3B0aW9ucyA9IHt9O1xuICBpZiAod2FzbUJpbmFyeSkge1xuICAgIG9wdGlvbnMud2FzbUJpbmFyeSA9IHdhc21CaW5hcnk7XG4gIH1cbiAgcmV0dXJuIG5ldyBQcm9taXNlKHJlc29sdmUgPT4ge1xuICAgIEJhc2lzTW9kdWxlKG9wdGlvbnMpLnRoZW4obW9kdWxlID0+IHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgQmFzaXNGaWxlLFxuICAgICAgICBpbml0aWFsaXplQmFzaXNcbiAgICAgIH0gPSBtb2R1bGU7XG4gICAgICBpbml0aWFsaXplQmFzaXMoKTtcbiAgICAgIHJlc29sdmUoe1xuICAgICAgICBCYXNpc0ZpbGVcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9KTtcbn1cbmxldCBsb2FkQmFzaXNFbmNvZGVyUHJvbWlzZTtcblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGxvYWRCYXNpc0VuY29kZXJNb2R1bGUob3B0aW9ucykge1xuICBjb25zdCBtb2R1bGVzID0gb3B0aW9ucy5tb2R1bGVzIHx8IHt9O1xuICBpZiAobW9kdWxlcy5iYXNpc0VuY29kZXIpIHtcbiAgICByZXR1cm4gbW9kdWxlcy5iYXNpc0VuY29kZXI7XG4gIH1cbiAgbG9hZEJhc2lzRW5jb2RlclByb21pc2UgPSBsb2FkQmFzaXNFbmNvZGVyUHJvbWlzZSB8fCBsb2FkQmFzaXNFbmNvZGVyKG9wdGlvbnMpO1xuICByZXR1cm4gYXdhaXQgbG9hZEJhc2lzRW5jb2RlclByb21pc2U7XG59XG5cbmFzeW5jIGZ1bmN0aW9uIGxvYWRCYXNpc0VuY29kZXIob3B0aW9ucykge1xuICBsZXQgQkFTSVNfRU5DT0RFUiA9IG51bGw7XG4gIGxldCB3YXNtQmluYXJ5ID0gbnVsbDtcbiAgW0JBU0lTX0VOQ09ERVIsIHdhc21CaW5hcnldID0gYXdhaXQgUHJvbWlzZS5hbGwoW2F3YWl0IGxvYWRMaWJyYXJ5KEJBU0lTX0NETl9FTkNPREVSX0pTLCAndGV4dHVyZXMnLCBvcHRpb25zKSwgYXdhaXQgbG9hZExpYnJhcnkoQkFTSVNfQ0ROX0VOQ09ERVJfV0FTTSwgJ3RleHR1cmVzJywgb3B0aW9ucyldKTtcblxuICBCQVNJU19FTkNPREVSID0gQkFTSVNfRU5DT0RFUiB8fCBnbG9iYWxUaGlzLkJBU0lTO1xuICByZXR1cm4gYXdhaXQgaW5pdGlhbGl6ZUJhc2lzRW5jb2Rlck1vZHVsZShCQVNJU19FTkNPREVSLCB3YXNtQmluYXJ5KTtcbn1cblxuZnVuY3Rpb24gaW5pdGlhbGl6ZUJhc2lzRW5jb2Rlck1vZHVsZShCYXNpc0VuY29kZXJNb2R1bGUsIHdhc21CaW5hcnkpIHtcbiAgY29uc3Qgb3B0aW9ucyA9IHt9O1xuICBpZiAod2FzbUJpbmFyeSkge1xuICAgIG9wdGlvbnMud2FzbUJpbmFyeSA9IHdhc21CaW5hcnk7XG4gIH1cbiAgcmV0dXJuIG5ldyBQcm9taXNlKHJlc29sdmUgPT4ge1xuICAgIEJhc2lzRW5jb2Rlck1vZHVsZShvcHRpb25zKS50aGVuKG1vZHVsZSA9PiB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIEJhc2lzRmlsZSxcbiAgICAgICAgS1RYMkZpbGUsXG4gICAgICAgIGluaXRpYWxpemVCYXNpcyxcbiAgICAgICAgQmFzaXNFbmNvZGVyXG4gICAgICB9ID0gbW9kdWxlO1xuICAgICAgaW5pdGlhbGl6ZUJhc2lzKCk7XG4gICAgICByZXNvbHZlKHtcbiAgICAgICAgQmFzaXNGaWxlLFxuICAgICAgICBLVFgyRmlsZSxcbiAgICAgICAgQmFzaXNFbmNvZGVyXG4gICAgICB9KTtcbiAgICB9KTtcbiAgfSk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1iYXNpcy1tb2R1bGUtbG9hZGVyLmpzLm1hcCIsIlxuZXhwb3J0IGNvbnN0IEdMX0VYVEVOU0lPTlNfQ09OU1RBTlRTID0ge1xuXG4gIENPTVBSRVNTRURfUkdCX1MzVENfRFhUMV9FWFQ6IDB4ODNmMCxcbiAgQ09NUFJFU1NFRF9SR0JBX1MzVENfRFhUMV9FWFQ6IDB4ODNmMSxcbiAgQ09NUFJFU1NFRF9SR0JBX1MzVENfRFhUM19FWFQ6IDB4ODNmMixcbiAgQ09NUFJFU1NFRF9SR0JBX1MzVENfRFhUNV9FWFQ6IDB4ODNmMyxcblxuICBDT01QUkVTU0VEX1IxMV9FQUM6IDB4OTI3MCxcbiAgQ09NUFJFU1NFRF9TSUdORURfUjExX0VBQzogMHg5MjcxLFxuICBDT01QUkVTU0VEX1JHMTFfRUFDOiAweDkyNzIsXG4gIENPTVBSRVNTRURfU0lHTkVEX1JHMTFfRUFDOiAweDkyNzMsXG4gIENPTVBSRVNTRURfUkdCOF9FVEMyOiAweDkyNzQsXG4gIENPTVBSRVNTRURfUkdCQThfRVRDMl9FQUM6IDB4OTI3NSxcbiAgQ09NUFJFU1NFRF9TUkdCOF9FVEMyOiAweDkyNzYsXG4gIENPTVBSRVNTRURfU1JHQjhfQUxQSEE4X0VUQzJfRUFDOiAweDkyNzcsXG4gIENPTVBSRVNTRURfUkdCOF9QVU5DSFRIUk9VR0hfQUxQSEExX0VUQzI6IDB4OTI3OCxcbiAgQ09NUFJFU1NFRF9TUkdCOF9QVU5DSFRIUk9VR0hfQUxQSEExX0VUQzI6IDB4OTI3OSxcblxuICBDT01QUkVTU0VEX1JHQl9QVlJUQ180QlBQVjFfSU1HOiAweDhjMDAsXG4gIENPTVBSRVNTRURfUkdCQV9QVlJUQ180QlBQVjFfSU1HOiAweDhjMDIsXG4gIENPTVBSRVNTRURfUkdCX1BWUlRDXzJCUFBWMV9JTUc6IDB4OGMwMSxcbiAgQ09NUFJFU1NFRF9SR0JBX1BWUlRDXzJCUFBWMV9JTUc6IDB4OGMwMyxcblxuICBDT01QUkVTU0VEX1JHQl9FVEMxX1dFQkdMOiAweDhkNjQsXG5cbiAgQ09NUFJFU1NFRF9SR0JfQVRDX1dFQkdMOiAweDhjOTIsXG4gIENPTVBSRVNTRURfUkdCQV9BVENfRVhQTElDSVRfQUxQSEFfV0VCR0w6IDB4OGM5MyxcbiAgQ09NUFJFU1NFRF9SR0JBX0FUQ19JTlRFUlBPTEFURURfQUxQSEFfV0VCR0w6IDB4ODdlZSxcblxuICBDT01QUkVTU0VEX1JHQkFfQVNUQ180WDRfS0hSOiAweDkzYjAsXG4gIENPTVBSRVNTRURfUkdCQV9BU1RDXzVYNF9LSFI6IDB4OTNiMSxcbiAgQ09NUFJFU1NFRF9SR0JBX0FTVENfNVg1X0tIUjogMHg5M2IyLFxuICBDT01QUkVTU0VEX1JHQkFfQVNUQ182WDVfS0hSOiAweDkzYjMsXG4gIENPTVBSRVNTRURfUkdCQV9BU1RDXzZYNl9LSFI6IDB4OTNiNCxcbiAgQ09NUFJFU1NFRF9SR0JBX0FTVENfOFg1X0tIUjogMHg5M2I1LFxuICBDT01QUkVTU0VEX1JHQkFfQVNUQ184WDZfS0hSOiAweDkzYjYsXG4gIENPTVBSRVNTRURfUkdCQV9BU1RDXzhYOF9LSFI6IDB4OTNiNyxcbiAgQ09NUFJFU1NFRF9SR0JBX0FTVENfMTBYNV9LSFI6IDB4OTNiOCxcbiAgQ09NUFJFU1NFRF9SR0JBX0FTVENfMTBYNl9LSFI6IDB4OTNiOSxcbiAgQ09NUFJFU1NFRF9SR0JBX0FTVENfMTBYOF9LSFI6IDB4OTNiYSxcbiAgQ09NUFJFU1NFRF9SR0JBX0FTVENfMTBYMTBfS0hSOiAweDkzYmIsXG4gIENPTVBSRVNTRURfUkdCQV9BU1RDXzEyWDEwX0tIUjogMHg5M2JjLFxuICBDT01QUkVTU0VEX1JHQkFfQVNUQ18xMlgxMl9LSFI6IDB4OTNiZCxcbiAgQ09NUFJFU1NFRF9TUkdCOF9BTFBIQThfQVNUQ180WDRfS0hSOiAweDkzZDAsXG4gIENPTVBSRVNTRURfU1JHQjhfQUxQSEE4X0FTVENfNVg0X0tIUjogMHg5M2QxLFxuICBDT01QUkVTU0VEX1NSR0I4X0FMUEhBOF9BU1RDXzVYNV9LSFI6IDB4OTNkMixcbiAgQ09NUFJFU1NFRF9TUkdCOF9BTFBIQThfQVNUQ182WDVfS0hSOiAweDkzZDMsXG4gIENPTVBSRVNTRURfU1JHQjhfQUxQSEE4X0FTVENfNlg2X0tIUjogMHg5M2Q0LFxuICBDT01QUkVTU0VEX1NSR0I4X0FMUEhBOF9BU1RDXzhYNV9LSFI6IDB4OTNkNSxcbiAgQ09NUFJFU1NFRF9TUkdCOF9BTFBIQThfQVNUQ184WDZfS0hSOiAweDkzZDYsXG4gIENPTVBSRVNTRURfU1JHQjhfQUxQSEE4X0FTVENfOFg4X0tIUjogMHg5M2Q3LFxuICBDT01QUkVTU0VEX1NSR0I4X0FMUEhBOF9BU1RDXzEwWDVfS0hSOiAweDkzZDgsXG4gIENPTVBSRVNTRURfU1JHQjhfQUxQSEE4X0FTVENfMTBYNl9LSFI6IDB4OTNkOSxcbiAgQ09NUFJFU1NFRF9TUkdCOF9BTFBIQThfQVNUQ18xMFg4X0tIUjogMHg5M2RhLFxuICBDT01QUkVTU0VEX1NSR0I4X0FMUEhBOF9BU1RDXzEwWDEwX0tIUjogMHg5M2RiLFxuICBDT01QUkVTU0VEX1NSR0I4X0FMUEhBOF9BU1RDXzEyWDEwX0tIUjogMHg5M2RjLFxuICBDT01QUkVTU0VEX1NSR0I4X0FMUEhBOF9BU1RDXzEyWDEyX0tIUjogMHg5M2RkLFxuXG4gIENPTVBSRVNTRURfUkVEX1JHVEMxX0VYVDogMHg4ZGJiLFxuICBDT01QUkVTU0VEX1NJR05FRF9SRURfUkdUQzFfRVhUOiAweDhkYmMsXG4gIENPTVBSRVNTRURfUkVEX0dSRUVOX1JHVEMyX0VYVDogMHg4ZGJkLFxuICBDT01QUkVTU0VEX1NJR05FRF9SRURfR1JFRU5fUkdUQzJfRVhUOiAweDhkYmUsXG5cbiAgQ09NUFJFU1NFRF9TUkdCX1MzVENfRFhUMV9FWFQ6IDB4OGM0YyxcbiAgQ09NUFJFU1NFRF9TUkdCX0FMUEhBX1MzVENfRFhUMV9FWFQ6IDB4OGM0ZCxcbiAgQ09NUFJFU1NFRF9TUkdCX0FMUEhBX1MzVENfRFhUM19FWFQ6IDB4OGM0ZSxcbiAgQ09NUFJFU1NFRF9TUkdCX0FMUEhBX1MzVENfRFhUNV9FWFQ6IDB4OGM0ZlxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWdsLWV4dGVuc2lvbnMuanMubWFwIiwiY29uc3QgQlJPV1NFUl9QUkVGSVhFUyA9IFsnJywgJ1dFQktJVF8nLCAnTU9aXyddO1xuY29uc3QgV0VCR0xfRVhURU5TSU9OUyA9IHtcbiAgV0VCR0xfY29tcHJlc3NlZF90ZXh0dXJlX3MzdGM6ICdkeHQnLFxuICBXRUJHTF9jb21wcmVzc2VkX3RleHR1cmVfczN0Y19zcmdiOiAnZHh0LXNyZ2InLFxuICBXRUJHTF9jb21wcmVzc2VkX3RleHR1cmVfZXRjMTogJ2V0YzEnLFxuICBXRUJHTF9jb21wcmVzc2VkX3RleHR1cmVfZXRjOiAnZXRjMicsXG4gIFdFQkdMX2NvbXByZXNzZWRfdGV4dHVyZV9wdnJ0YzogJ3B2cnRjJyxcbiAgV0VCR0xfY29tcHJlc3NlZF90ZXh0dXJlX2F0YzogJ2F0YycsXG4gIFdFQkdMX2NvbXByZXNzZWRfdGV4dHVyZV9hc3RjOiAnYXN0YycsXG4gIEVYVF90ZXh0dXJlX2NvbXByZXNzaW9uX3JndGM6ICdyZ3RjJ1xufTtcblxubGV0IGZvcm1hdHMgPSBudWxsO1xuXG5leHBvcnQgZnVuY3Rpb24gZ2V0U3VwcG9ydGVkR1BVVGV4dHVyZUZvcm1hdHMoZ2wpIHtcbiAgaWYgKCFmb3JtYXRzKSB7XG4gICAgZ2wgPSBnbCB8fCBnZXRXZWJHTENvbnRleHQoKSB8fCB1bmRlZmluZWQ7XG4gICAgZm9ybWF0cyA9IG5ldyBTZXQoKTtcbiAgICBmb3IgKGNvbnN0IHByZWZpeCBvZiBCUk9XU0VSX1BSRUZJWEVTKSB7XG4gICAgICBmb3IgKGNvbnN0IGV4dGVuc2lvbiBpbiBXRUJHTF9FWFRFTlNJT05TKSB7XG4gICAgICAgIGlmIChnbCAmJiBnbC5nZXRFeHRlbnNpb24oXCJcIi5jb25jYXQocHJlZml4KS5jb25jYXQoZXh0ZW5zaW9uKSkpIHtcbiAgICAgICAgICBjb25zdCBncHVUZXh0dXJlRm9ybWF0ID0gV0VCR0xfRVhURU5TSU9OU1tleHRlbnNpb25dO1xuICAgICAgICAgIGZvcm1hdHMuYWRkKGdwdVRleHR1cmVGb3JtYXQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBmb3JtYXRzO1xufVxuXG5mdW5jdGlvbiBnZXRXZWJHTENvbnRleHQoKSB7XG4gIHRyeSB7XG4gICAgY29uc3QgY2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyk7XG4gICAgcmV0dXJuIGNhbnZhcy5nZXRDb250ZXh0KCd3ZWJnbCcpO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIHJldHVybiBudWxsO1xuICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD10ZXh0dXJlLWZvcm1hdHMuanMubWFwIiwiaW1wb3J0IHsgcmVhZCB9IGZyb20gJ2t0eC1wYXJzZSc7XG5pbXBvcnQgeyBleHRyYWN0TWlwbWFwSW1hZ2VzIH0gZnJvbSAnLi4vdXRpbHMvZXh0cmFjdC1taXBtYXAtaW1hZ2VzJztcbmltcG9ydCB7IG1hcFZrRm9ybWF0VG9XZWJHTCB9IGZyb20gJy4uL3V0aWxzL2t0eC1mb3JtYXQtaGVscGVyJztcbmNvbnN0IEtUWDJfSUQgPSBbXG4weGFiLCAweDRiLCAweDU0LCAweDU4LCAweDIwLCAweDMyLCAweDMwLCAweGJiLCAweDBkLCAweDBhLCAweDFhLCAweDBhXTtcblxuZXhwb3J0IGZ1bmN0aW9uIGlzS1RYKGRhdGEpIHtcbiAgY29uc3QgaWQgPSBuZXcgVWludDhBcnJheShkYXRhKTtcbiAgY29uc3Qgbm90S1RYID0gaWQuYnl0ZUxlbmd0aCA8IEtUWDJfSUQubGVuZ3RoIHx8IGlkWzBdICE9PSBLVFgyX0lEWzBdIHx8XG4gIGlkWzFdICE9PSBLVFgyX0lEWzFdIHx8XG4gIGlkWzJdICE9PSBLVFgyX0lEWzJdIHx8XG4gIGlkWzNdICE9PSBLVFgyX0lEWzNdIHx8XG4gIGlkWzRdICE9PSBLVFgyX0lEWzRdIHx8XG4gIGlkWzVdICE9PSBLVFgyX0lEWzVdIHx8XG4gIGlkWzZdICE9PSBLVFgyX0lEWzZdIHx8XG4gIGlkWzddICE9PSBLVFgyX0lEWzddIHx8XG4gIGlkWzhdICE9PSBLVFgyX0lEWzhdIHx8XG4gIGlkWzldICE9PSBLVFgyX0lEWzldIHx8XG4gIGlkWzEwXSAhPT0gS1RYMl9JRFsxMF0gfHxcbiAgaWRbMTFdICE9PSBLVFgyX0lEWzExXTtcblxuICByZXR1cm4gIW5vdEtUWDtcbn1cbmV4cG9ydCBmdW5jdGlvbiBwYXJzZUtUWChhcnJheUJ1ZmZlcikge1xuICBjb25zdCB1aW50OEFycmF5ID0gbmV3IFVpbnQ4QXJyYXkoYXJyYXlCdWZmZXIpO1xuICBjb25zdCBrdHggPSByZWFkKHVpbnQ4QXJyYXkpO1xuICBjb25zdCBtaXBNYXBMZXZlbHMgPSBNYXRoLm1heCgxLCBrdHgubGV2ZWxzLmxlbmd0aCk7XG4gIGNvbnN0IHdpZHRoID0ga3R4LnBpeGVsV2lkdGg7XG4gIGNvbnN0IGhlaWdodCA9IGt0eC5waXhlbEhlaWdodDtcbiAgY29uc3QgaW50ZXJuYWxGb3JtYXQgPSBtYXBWa0Zvcm1hdFRvV2ViR0woa3R4LnZrRm9ybWF0KTtcbiAgcmV0dXJuIGV4dHJhY3RNaXBtYXBJbWFnZXMoa3R4LmxldmVscywge1xuICAgIG1pcE1hcExldmVscyxcbiAgICB3aWR0aCxcbiAgICBoZWlnaHQsXG4gICAgc2l6ZUZ1bmN0aW9uOiBsZXZlbCA9PiBsZXZlbC51bmNvbXByZXNzZWRCeXRlTGVuZ3RoLFxuICAgIGludGVybmFsRm9ybWF0XG4gIH0pO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cGFyc2Uta3R4LmpzLm1hcCIsIlxuXG5pbXBvcnQgeyBsb2FkQmFzaXNFbmNvZGVyTW9kdWxlLCBsb2FkQmFzaXNUcmFzY29kZXJNb2R1bGUgfSBmcm9tICcuL2Jhc2lzLW1vZHVsZS1sb2FkZXInO1xuaW1wb3J0IHsgR0xfRVhURU5TSU9OU19DT05TVEFOVFMgfSBmcm9tICcuLi9nbC1leHRlbnNpb25zJztcbmltcG9ydCB7IGdldFN1cHBvcnRlZEdQVVRleHR1cmVGb3JtYXRzIH0gZnJvbSAnLi4vdXRpbHMvdGV4dHVyZS1mb3JtYXRzJztcbmltcG9ydCB7IGlzS1RYIH0gZnJvbSAnLi9wYXJzZS1rdHgnO1xuY29uc3QgT3V0cHV0Rm9ybWF0ID0ge1xuICBldGMxOiB7XG4gICAgYmFzaXNGb3JtYXQ6IDAsXG4gICAgY29tcHJlc3NlZDogdHJ1ZSxcbiAgICBmb3JtYXQ6IEdMX0VYVEVOU0lPTlNfQ09OU1RBTlRTLkNPTVBSRVNTRURfUkdCX0VUQzFfV0VCR0xcbiAgfSxcbiAgZXRjMjoge1xuICAgIGJhc2lzRm9ybWF0OiAxLFxuICAgIGNvbXByZXNzZWQ6IHRydWVcbiAgfSxcbiAgYmMxOiB7XG4gICAgYmFzaXNGb3JtYXQ6IDIsXG4gICAgY29tcHJlc3NlZDogdHJ1ZSxcbiAgICBmb3JtYXQ6IEdMX0VYVEVOU0lPTlNfQ09OU1RBTlRTLkNPTVBSRVNTRURfUkdCX1MzVENfRFhUMV9FWFRcbiAgfSxcbiAgYmMzOiB7XG4gICAgYmFzaXNGb3JtYXQ6IDMsXG4gICAgY29tcHJlc3NlZDogdHJ1ZSxcbiAgICBmb3JtYXQ6IEdMX0VYVEVOU0lPTlNfQ09OU1RBTlRTLkNPTVBSRVNTRURfUkdCQV9TM1RDX0RYVDVfRVhUXG4gIH0sXG4gIGJjNDoge1xuICAgIGJhc2lzRm9ybWF0OiA0LFxuICAgIGNvbXByZXNzZWQ6IHRydWVcbiAgfSxcbiAgYmM1OiB7XG4gICAgYmFzaXNGb3JtYXQ6IDUsXG4gICAgY29tcHJlc3NlZDogdHJ1ZVxuICB9LFxuICAnYmM3LW02LW9wYXF1ZS1vbmx5Jzoge1xuICAgIGJhc2lzRm9ybWF0OiA2LFxuICAgIGNvbXByZXNzZWQ6IHRydWVcbiAgfSxcbiAgJ2JjNy1tNSc6IHtcbiAgICBiYXNpc0Zvcm1hdDogNyxcbiAgICBjb21wcmVzc2VkOiB0cnVlXG4gIH0sXG4gICdwdnJ0YzEtNC1yZ2InOiB7XG4gICAgYmFzaXNGb3JtYXQ6IDgsXG4gICAgY29tcHJlc3NlZDogdHJ1ZSxcbiAgICBmb3JtYXQ6IEdMX0VYVEVOU0lPTlNfQ09OU1RBTlRTLkNPTVBSRVNTRURfUkdCX1BWUlRDXzRCUFBWMV9JTUdcbiAgfSxcbiAgJ3B2cnRjMS00LXJnYmEnOiB7XG4gICAgYmFzaXNGb3JtYXQ6IDksXG4gICAgY29tcHJlc3NlZDogdHJ1ZSxcbiAgICBmb3JtYXQ6IEdMX0VYVEVOU0lPTlNfQ09OU1RBTlRTLkNPTVBSRVNTRURfUkdCQV9QVlJUQ180QlBQVjFfSU1HXG4gIH0sXG4gICdhc3RjLTR4NCc6IHtcbiAgICBiYXNpc0Zvcm1hdDogMTAsXG4gICAgY29tcHJlc3NlZDogdHJ1ZSxcbiAgICBmb3JtYXQ6IEdMX0VYVEVOU0lPTlNfQ09OU1RBTlRTLkNPTVBSRVNTRURfUkdCQV9BU1RDXzRYNF9LSFJcbiAgfSxcbiAgJ2F0Yy1yZ2InOiB7XG4gICAgYmFzaXNGb3JtYXQ6IDExLFxuICAgIGNvbXByZXNzZWQ6IHRydWVcbiAgfSxcbiAgJ2F0Yy1yZ2JhLWludGVycG9sYXRlZC1hbHBoYSc6IHtcbiAgICBiYXNpc0Zvcm1hdDogMTIsXG4gICAgY29tcHJlc3NlZDogdHJ1ZVxuICB9LFxuICByZ2JhMzI6IHtcbiAgICBiYXNpc0Zvcm1hdDogMTMsXG4gICAgY29tcHJlc3NlZDogZmFsc2VcbiAgfSxcbiAgcmdiNTY1OiB7XG4gICAgYmFzaXNGb3JtYXQ6IDE0LFxuICAgIGNvbXByZXNzZWQ6IGZhbHNlXG4gIH0sXG4gIGJncjU2NToge1xuICAgIGJhc2lzRm9ybWF0OiAxNSxcbiAgICBjb21wcmVzc2VkOiBmYWxzZVxuICB9LFxuICByZ2JhNDQ0NDoge1xuICAgIGJhc2lzRm9ybWF0OiAxNixcbiAgICBjb21wcmVzc2VkOiBmYWxzZVxuICB9XG59O1xuXG5leHBvcnQgZGVmYXVsdCBhc3luYyBmdW5jdGlvbiBwYXJzZUJhc2lzKGRhdGEsIG9wdGlvbnMpIHtcbiAgaWYgKG9wdGlvbnMuYmFzaXMuY29udGFpbmVyRm9ybWF0ID09PSAnYXV0bycpIHtcbiAgICBpZiAoaXNLVFgoZGF0YSkpIHtcbiAgICAgIGNvbnN0IGZpbGVDb25zdHJ1Y3RvcnMgPSBhd2FpdCBsb2FkQmFzaXNFbmNvZGVyTW9kdWxlKG9wdGlvbnMpO1xuICAgICAgcmV0dXJuIHBhcnNlS1RYMkZpbGUoZmlsZUNvbnN0cnVjdG9ycy5LVFgyRmlsZSwgZGF0YSwgb3B0aW9ucyk7XG4gICAgfVxuICAgIGNvbnN0IHtcbiAgICAgIEJhc2lzRmlsZVxuICAgIH0gPSBhd2FpdCBsb2FkQmFzaXNUcmFzY29kZXJNb2R1bGUob3B0aW9ucyk7XG4gICAgcmV0dXJuIHBhcnNlQmFzaXNGaWxlKEJhc2lzRmlsZSwgZGF0YSwgb3B0aW9ucyk7XG4gIH1cbiAgc3dpdGNoIChvcHRpb25zLmJhc2lzLm1vZHVsZSkge1xuICAgIGNhc2UgJ2VuY29kZXInOlxuICAgICAgY29uc3QgZmlsZUNvbnN0cnVjdG9ycyA9IGF3YWl0IGxvYWRCYXNpc0VuY29kZXJNb2R1bGUob3B0aW9ucyk7XG4gICAgICBzd2l0Y2ggKG9wdGlvbnMuYmFzaXMuY29udGFpbmVyRm9ybWF0KSB7XG4gICAgICAgIGNhc2UgJ2t0eDInOlxuICAgICAgICAgIHJldHVybiBwYXJzZUtUWDJGaWxlKGZpbGVDb25zdHJ1Y3RvcnMuS1RYMkZpbGUsIGRhdGEsIG9wdGlvbnMpO1xuICAgICAgICBjYXNlICdiYXNpcyc6XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgcmV0dXJuIHBhcnNlQmFzaXNGaWxlKGZpbGVDb25zdHJ1Y3RvcnMuQmFzaXNGaWxlLCBkYXRhLCBvcHRpb25zKTtcbiAgICAgIH1cbiAgICBjYXNlICd0cmFuc2NvZGVyJzpcbiAgICBkZWZhdWx0OlxuICAgICAgY29uc3Qge1xuICAgICAgICBCYXNpc0ZpbGVcbiAgICAgIH0gPSBhd2FpdCBsb2FkQmFzaXNUcmFzY29kZXJNb2R1bGUob3B0aW9ucyk7XG4gICAgICByZXR1cm4gcGFyc2VCYXNpc0ZpbGUoQmFzaXNGaWxlLCBkYXRhLCBvcHRpb25zKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBwYXJzZUJhc2lzRmlsZShCYXNpc0ZpbGUsIGRhdGEsIG9wdGlvbnMpIHtcbiAgY29uc3QgYmFzaXNGaWxlID0gbmV3IEJhc2lzRmlsZShuZXcgVWludDhBcnJheShkYXRhKSk7XG4gIHRyeSB7XG4gICAgaWYgKCFiYXNpc0ZpbGUuc3RhcnRUcmFuc2NvZGluZygpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZhaWxlZCB0byBzdGFydCBiYXNpcyB0cmFuc2NvZGluZycpO1xuICAgIH1cbiAgICBjb25zdCBpbWFnZUNvdW50ID0gYmFzaXNGaWxlLmdldE51bUltYWdlcygpO1xuICAgIGNvbnN0IGltYWdlcyA9IFtdO1xuICAgIGZvciAobGV0IGltYWdlSW5kZXggPSAwOyBpbWFnZUluZGV4IDwgaW1hZ2VDb3VudDsgaW1hZ2VJbmRleCsrKSB7XG4gICAgICBjb25zdCBsZXZlbHNDb3VudCA9IGJhc2lzRmlsZS5nZXROdW1MZXZlbHMoaW1hZ2VJbmRleCk7XG4gICAgICBjb25zdCBsZXZlbHMgPSBbXTtcbiAgICAgIGZvciAobGV0IGxldmVsSW5kZXggPSAwOyBsZXZlbEluZGV4IDwgbGV2ZWxzQ291bnQ7IGxldmVsSW5kZXgrKykge1xuICAgICAgICBsZXZlbHMucHVzaCh0cmFuc2NvZGVJbWFnZShiYXNpc0ZpbGUsIGltYWdlSW5kZXgsIGxldmVsSW5kZXgsIG9wdGlvbnMpKTtcbiAgICAgIH1cbiAgICAgIGltYWdlcy5wdXNoKGxldmVscyk7XG4gICAgfVxuICAgIHJldHVybiBpbWFnZXM7XG4gIH0gZmluYWxseSB7XG4gICAgYmFzaXNGaWxlLmNsb3NlKCk7XG4gICAgYmFzaXNGaWxlLmRlbGV0ZSgpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHRyYW5zY29kZUltYWdlKGJhc2lzRmlsZSwgaW1hZ2VJbmRleCwgbGV2ZWxJbmRleCwgb3B0aW9ucykge1xuICBjb25zdCB3aWR0aCA9IGJhc2lzRmlsZS5nZXRJbWFnZVdpZHRoKGltYWdlSW5kZXgsIGxldmVsSW5kZXgpO1xuICBjb25zdCBoZWlnaHQgPSBiYXNpc0ZpbGUuZ2V0SW1hZ2VIZWlnaHQoaW1hZ2VJbmRleCwgbGV2ZWxJbmRleCk7XG5cbiAgY29uc3QgaGFzQWxwaGEgPSBiYXNpc0ZpbGUuZ2V0SGFzQWxwaGEoKTtcblxuICBjb25zdCB7XG4gICAgY29tcHJlc3NlZCxcbiAgICBmb3JtYXQsXG4gICAgYmFzaXNGb3JtYXRcbiAgfSA9IGdldEJhc2lzT3B0aW9ucyhvcHRpb25zLCBoYXNBbHBoYSk7XG4gIGNvbnN0IGRlY29kZWRTaXplID0gYmFzaXNGaWxlLmdldEltYWdlVHJhbnNjb2RlZFNpemVJbkJ5dGVzKGltYWdlSW5kZXgsIGxldmVsSW5kZXgsIGJhc2lzRm9ybWF0KTtcbiAgY29uc3QgZGVjb2RlZERhdGEgPSBuZXcgVWludDhBcnJheShkZWNvZGVkU2l6ZSk7XG4gIGlmICghYmFzaXNGaWxlLnRyYW5zY29kZUltYWdlKGRlY29kZWREYXRhLCBpbWFnZUluZGV4LCBsZXZlbEluZGV4LCBiYXNpc0Zvcm1hdCwgMCwgMCkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2ZhaWxlZCB0byBzdGFydCBCYXNpcyB0cmFuc2NvZGluZycpO1xuICB9XG4gIHJldHVybiB7XG4gICAgd2lkdGgsXG4gICAgaGVpZ2h0LFxuICAgIGRhdGE6IGRlY29kZWREYXRhLFxuICAgIGNvbXByZXNzZWQsXG4gICAgZm9ybWF0LFxuICAgIGhhc0FscGhhXG4gIH07XG59XG5cbmZ1bmN0aW9uIHBhcnNlS1RYMkZpbGUoS1RYMkZpbGUsIGRhdGEsIG9wdGlvbnMpIHtcbiAgY29uc3Qga3R4MkZpbGUgPSBuZXcgS1RYMkZpbGUobmV3IFVpbnQ4QXJyYXkoZGF0YSkpO1xuICB0cnkge1xuICAgIGlmICgha3R4MkZpbGUuc3RhcnRUcmFuc2NvZGluZygpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ZhaWxlZCB0byBzdGFydCBLVFgyIHRyYW5zY29kaW5nJyk7XG4gICAgfVxuICAgIGNvbnN0IGxldmVsc0NvdW50ID0ga3R4MkZpbGUuZ2V0TGV2ZWxzKCk7XG4gICAgY29uc3QgbGV2ZWxzID0gW107XG4gICAgZm9yIChsZXQgbGV2ZWxJbmRleCA9IDA7IGxldmVsSW5kZXggPCBsZXZlbHNDb3VudDsgbGV2ZWxJbmRleCsrKSB7XG4gICAgICBsZXZlbHMucHVzaCh0cmFuc2NvZGVLVFgySW1hZ2Uoa3R4MkZpbGUsIGxldmVsSW5kZXgsIG9wdGlvbnMpKTtcbiAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIHJldHVybiBbbGV2ZWxzXTtcbiAgfSBmaW5hbGx5IHtcbiAgICBrdHgyRmlsZS5jbG9zZSgpO1xuICAgIGt0eDJGaWxlLmRlbGV0ZSgpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHRyYW5zY29kZUtUWDJJbWFnZShrdHgyRmlsZSwgbGV2ZWxJbmRleCwgb3B0aW9ucykge1xuICBjb25zdCB7XG4gICAgYWxwaGFGbGFnLFxuICAgIGhlaWdodCxcbiAgICB3aWR0aFxuICB9ID0ga3R4MkZpbGUuZ2V0SW1hZ2VMZXZlbEluZm8obGV2ZWxJbmRleCwgMCwgMCk7XG5cbiAgY29uc3Qge1xuICAgIGNvbXByZXNzZWQsXG4gICAgZm9ybWF0LFxuICAgIGJhc2lzRm9ybWF0XG4gIH0gPSBnZXRCYXNpc09wdGlvbnMob3B0aW9ucywgYWxwaGFGbGFnKTtcbiAgY29uc3QgZGVjb2RlZFNpemUgPSBrdHgyRmlsZS5nZXRJbWFnZVRyYW5zY29kZWRTaXplSW5CeXRlcyhsZXZlbEluZGV4LCAwLCAwLCBiYXNpc0Zvcm1hdCk7XG4gIGNvbnN0IGRlY29kZWREYXRhID0gbmV3IFVpbnQ4QXJyYXkoZGVjb2RlZFNpemUpO1xuICBpZiAoIWt0eDJGaWxlLnRyYW5zY29kZUltYWdlKGRlY29kZWREYXRhLCBsZXZlbEluZGV4LCAwLCAwLCBiYXNpc0Zvcm1hdCwgMCwgLTEsIC0xKSkge1xuICAgIHRocm93IG5ldyBFcnJvcignRmFpbGVkIHRvIHRyYW5zY29kZSBLVFgyIGltYWdlJyk7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICB3aWR0aCxcbiAgICBoZWlnaHQsXG4gICAgZGF0YTogZGVjb2RlZERhdGEsXG4gICAgY29tcHJlc3NlZCxcbiAgICBsZXZlbFNpemU6IGRlY29kZWRTaXplLFxuICAgIGhhc0FscGhhOiBhbHBoYUZsYWcsXG4gICAgZm9ybWF0XG4gIH07XG59XG5cbmZ1bmN0aW9uIGdldEJhc2lzT3B0aW9ucyhvcHRpb25zLCBoYXNBbHBoYSkge1xuICBsZXQgZm9ybWF0ID0gb3B0aW9ucyAmJiBvcHRpb25zLmJhc2lzICYmIG9wdGlvbnMuYmFzaXMuZm9ybWF0O1xuICBpZiAoZm9ybWF0ID09PSAnYXV0bycpIHtcbiAgICBmb3JtYXQgPSBzZWxlY3RTdXBwb3J0ZWRCYXNpc0Zvcm1hdCgpO1xuICB9XG4gIGlmICh0eXBlb2YgZm9ybWF0ID09PSAnb2JqZWN0Jykge1xuICAgIGZvcm1hdCA9IGhhc0FscGhhID8gZm9ybWF0LmFscGhhIDogZm9ybWF0Lm5vQWxwaGE7XG4gIH1cbiAgZm9ybWF0ID0gZm9ybWF0LnRvTG93ZXJDYXNlKCk7XG4gIHJldHVybiBPdXRwdXRGb3JtYXRbZm9ybWF0XTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHNlbGVjdFN1cHBvcnRlZEJhc2lzRm9ybWF0KCkge1xuICBjb25zdCBzdXBwb3J0ZWRGb3JtYXRzID0gZ2V0U3VwcG9ydGVkR1BVVGV4dHVyZUZvcm1hdHMoKTtcbiAgaWYgKHN1cHBvcnRlZEZvcm1hdHMuaGFzKCdhc3RjJykpIHtcbiAgICByZXR1cm4gJ2FzdGMtNHg0JztcbiAgfSBlbHNlIGlmIChzdXBwb3J0ZWRGb3JtYXRzLmhhcygnZHh0JykpIHtcbiAgICByZXR1cm4ge1xuICAgICAgYWxwaGE6ICdiYzMnLFxuICAgICAgbm9BbHBoYTogJ2JjMSdcbiAgICB9O1xuICB9IGVsc2UgaWYgKHN1cHBvcnRlZEZvcm1hdHMuaGFzKCdwdnJ0YycpKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGFscGhhOiAncHZydGMxLTQtcmdiYScsXG4gICAgICBub0FscGhhOiAncHZydGMxLTQtcmdiJ1xuICAgIH07XG4gIH0gZWxzZSBpZiAoc3VwcG9ydGVkRm9ybWF0cy5oYXMoJ2V0YzEnKSkge1xuICAgIHJldHVybiAnZXRjMSc7XG4gIH0gZWxzZSBpZiAoc3VwcG9ydGVkRm9ybWF0cy5oYXMoJ2V0YzInKSkge1xuICAgIHJldHVybiAnZXRjMic7XG4gIH1cbiAgcmV0dXJuICdyZ2I1NjUnO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cGFyc2UtYmFzaXMuanMubWFwIiwiaW1wb3J0IHsgaXNCcm93c2VyIH0gZnJvbSAnQGxvYWRlcnMuZ2wvd29ya2VyLXV0aWxzJztcbmltcG9ydCB7IFZFUlNJT04gfSBmcm9tICcuL2xpYi91dGlscy92ZXJzaW9uJztcbmltcG9ydCBwYXJzZUJhc2lzIGZyb20gJy4vbGliL3BhcnNlcnMvcGFyc2UtYmFzaXMnO1xuXG5leHBvcnQgY29uc3QgQmFzaXNXb3JrZXJMb2FkZXIgPSB7XG4gIG5hbWU6ICdCYXNpcycsXG4gIGlkOiBpc0Jyb3dzZXIgPyAnYmFzaXMnIDogJ2Jhc2lzLW5vZGVqcycsXG4gIG1vZHVsZTogJ3RleHR1cmVzJyxcbiAgdmVyc2lvbjogVkVSU0lPTixcbiAgd29ya2VyOiB0cnVlLFxuICBleHRlbnNpb25zOiBbJ2Jhc2lzJywgJ2t0eDInXSxcbiAgbWltZVR5cGVzOiBbJ2FwcGxpY2F0aW9uL29jdGV0LXN0cmVhbScsICdpbWFnZS9rdHgyJ10sXG4gIHRlc3RzOiBbJ3NCJ10sXG4gIGJpbmFyeTogdHJ1ZSxcbiAgb3B0aW9uczoge1xuICAgIGJhc2lzOiB7XG4gICAgICBmb3JtYXQ6ICdhdXRvJyxcbiAgICAgIGxpYnJhcnlQYXRoOiAnbGlicy8nLFxuICAgICAgY29udGFpbmVyRm9ybWF0OiAnYXV0bycsXG4gICAgICBtb2R1bGU6ICd0cmFuc2NvZGVyJ1xuICAgIH1cbiAgfVxufTtcblxuZXhwb3J0IGNvbnN0IEJhc2lzTG9hZGVyID0ge1xuICAuLi5CYXNpc1dvcmtlckxvYWRlcixcbiAgcGFyc2U6IHBhcnNlQmFzaXNcbn07XG5cbmV4cG9ydCBjb25zdCBfVHlwZWNoZWNrQmFzaXNXb3JrZXJMb2FkZXIgPSBCYXNpc1dvcmtlckxvYWRlcjtcbmV4cG9ydCBjb25zdCBfVHlwZWNoZWNrQmFzaXNMb2FkZXIgPSBCYXNpc0xvYWRlcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWJhc2lzLWxvYWRlci5qcy5tYXAiLCJcblxuZXhwb3J0IGZ1bmN0aW9uIGdldEZpcnN0Q2hhcmFjdGVycyhkYXRhKSB7XG4gIGxldCBsZW5ndGggPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IDU7XG4gIGlmICh0eXBlb2YgZGF0YSA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gZGF0YS5zbGljZSgwLCBsZW5ndGgpO1xuICB9IGVsc2UgaWYgKEFycmF5QnVmZmVyLmlzVmlldyhkYXRhKSkge1xuICAgIHJldHVybiBnZXRNYWdpY1N0cmluZyhkYXRhLmJ1ZmZlciwgZGF0YS5ieXRlT2Zmc2V0LCBsZW5ndGgpO1xuICB9IGVsc2UgaWYgKGRhdGEgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikge1xuICAgIGNvbnN0IGJ5dGVPZmZzZXQgPSAwO1xuICAgIHJldHVybiBnZXRNYWdpY1N0cmluZyhkYXRhLCBieXRlT2Zmc2V0LCBsZW5ndGgpO1xuICB9XG4gIHJldHVybiAnJztcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdldE1hZ2ljU3RyaW5nKGFycmF5QnVmZmVyLCBieXRlT2Zmc2V0LCBsZW5ndGgpIHtcbiAgaWYgKGFycmF5QnVmZmVyLmJ5dGVMZW5ndGggPD0gYnl0ZU9mZnNldCArIGxlbmd0aCkge1xuICAgIHJldHVybiAnJztcbiAgfVxuICBjb25zdCBkYXRhVmlldyA9IG5ldyBEYXRhVmlldyhhcnJheUJ1ZmZlcik7XG4gIGxldCBtYWdpYyA9ICcnO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgbWFnaWMgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShkYXRhVmlldy5nZXRVaW50OChieXRlT2Zmc2V0ICsgaSkpO1xuICB9XG4gIHJldHVybiBtYWdpYztcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWdldC1maXJzdC1jaGFyYWN0ZXJzLmpzLm1hcCIsImltcG9ydCB7IGdldEZpcnN0Q2hhcmFjdGVycyB9IGZyb20gJy4uL2JpbmFyeS11dGlscy9nZXQtZmlyc3QtY2hhcmFjdGVycyc7XG5cbmV4cG9ydCBmdW5jdGlvbiBwYXJzZUpTT04oc3RyaW5nKSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIEpTT04ucGFyc2Uoc3RyaW5nKTtcbiAgfSBjYXRjaCAoXykge1xuICAgIHRocm93IG5ldyBFcnJvcihcIkZhaWxlZCB0byBwYXJzZSBKU09OIGZyb20gZGF0YSBzdGFydGluZyB3aXRoIFxcXCJcIi5jb25jYXQoZ2V0Rmlyc3RDaGFyYWN0ZXJzKHN0cmluZyksIFwiXFxcIlwiKSk7XG4gIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXBhcnNlLWpzb24uanMubWFwIiwiXG5leHBvcnQgZnVuY3Rpb24gYXNzZXJ0KGNvbmRpdGlvbiwgbWVzc2FnZSkge1xuICBpZiAoIWNvbmRpdGlvbikge1xuICAgIHRocm93IG5ldyBFcnJvcihtZXNzYWdlIHx8ICdhc3NlcnQgZmFpbGVkOiBnbHRmJyk7XG4gIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWFzc2VydC5qcy5tYXAiLCJcbmV4cG9ydCBmdW5jdGlvbiByZXNvbHZlVXJsKHVybCwgb3B0aW9ucykge1xuICBjb25zdCBhYnNvbHV0ZSA9IHVybC5zdGFydHNXaXRoKCdkYXRhOicpIHx8IHVybC5zdGFydHNXaXRoKCdodHRwOicpIHx8IHVybC5zdGFydHNXaXRoKCdodHRwczonKTtcbiAgaWYgKGFic29sdXRlKSB7XG4gICAgcmV0dXJuIHVybDtcbiAgfVxuICBjb25zdCBiYXNlVXJsID0gb3B0aW9ucy5iYXNlVXJpIHx8IG9wdGlvbnMudXJpO1xuICBpZiAoIWJhc2VVcmwpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCInYmFzZVVyaScgbXVzdCBiZSBwcm92aWRlZCB0byByZXNvbHZlIHJlbGF0aXZlIHVybCBcIi5jb25jYXQodXJsKSk7XG4gIH1cbiAgcmV0dXJuIGJhc2VVcmwuc3Vic3RyKDAsIGJhc2VVcmwubGFzdEluZGV4T2YoJy8nKSArIDEpICsgdXJsO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cmVzb2x2ZS11cmwuanMubWFwIiwiXG5pbXBvcnQgeyBhc3NlcnQgfSBmcm9tICcuLi91dGlscy9hc3NlcnQnO1xuXG5leHBvcnQgZnVuY3Rpb24gZ2V0VHlwZWRBcnJheUZvckJ1ZmZlclZpZXcoanNvbiwgYnVmZmVycywgYnVmZmVyVmlld0luZGV4KSB7XG4gIGNvbnN0IGJ1ZmZlclZpZXcgPSBqc29uLmJ1ZmZlclZpZXdzW2J1ZmZlclZpZXdJbmRleF07XG4gIGFzc2VydChidWZmZXJWaWV3KTtcblxuICBjb25zdCBidWZmZXJJbmRleCA9IGJ1ZmZlclZpZXcuYnVmZmVyO1xuICBjb25zdCBiaW5DaHVuayA9IGJ1ZmZlcnNbYnVmZmVySW5kZXhdO1xuICBhc3NlcnQoYmluQ2h1bmspO1xuICBjb25zdCBieXRlT2Zmc2V0ID0gKGJ1ZmZlclZpZXcuYnl0ZU9mZnNldCB8fCAwKSArIGJpbkNodW5rLmJ5dGVPZmZzZXQ7XG4gIHJldHVybiBuZXcgVWludDhBcnJheShiaW5DaHVuay5hcnJheUJ1ZmZlciwgYnl0ZU9mZnNldCwgYnVmZmVyVmlldy5ieXRlTGVuZ3RoKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdldFR5cGVkQXJyYXlGb3JJbWFnZURhdGEoanNvbiwgYnVmZmVycywgaW1hZ2VJbmRleCkge1xuICBjb25zdCBpbWFnZSA9IGpzb24uaW1hZ2VzW2ltYWdlSW5kZXhdO1xuICBjb25zdCBidWZmZXJWaWV3SW5kZXggPSBqc29uLmJ1ZmZlclZpZXdzW2ltYWdlLmJ1ZmZlclZpZXddO1xuICByZXR1cm4gZ2V0VHlwZWRBcnJheUZvckJ1ZmZlclZpZXcoanNvbiwgYnVmZmVycywgYnVmZmVyVmlld0luZGV4KTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWdldC10eXBlZC1hcnJheS5qcy5tYXAiLCJpbXBvcnQgeyBhc3NlcnQgfSBmcm9tICcuLi9lbnYtdXRpbHMvYXNzZXJ0JztcblxuZXhwb3J0IGZ1bmN0aW9uIHBhZFRvTkJ5dGVzKGJ5dGVMZW5ndGgsIHBhZGRpbmcpIHtcbiAgYXNzZXJ0KGJ5dGVMZW5ndGggPj0gMCk7XG4gIGFzc2VydChwYWRkaW5nID4gMCk7XG4gIHJldHVybiBieXRlTGVuZ3RoICsgKHBhZGRpbmcgLSAxKSAmIH4ocGFkZGluZyAtIDEpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gY29weUFycmF5QnVmZmVyKHRhcmdldEJ1ZmZlciwgc291cmNlQnVmZmVyLCBieXRlT2Zmc2V0KSB7XG4gIGxldCBieXRlTGVuZ3RoID0gYXJndW1lbnRzLmxlbmd0aCA+IDMgJiYgYXJndW1lbnRzWzNdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbM10gOiBzb3VyY2VCdWZmZXIuYnl0ZUxlbmd0aDtcbiAgY29uc3QgdGFyZ2V0QXJyYXkgPSBuZXcgVWludDhBcnJheSh0YXJnZXRCdWZmZXIsIGJ5dGVPZmZzZXQsIGJ5dGVMZW5ndGgpO1xuICBjb25zdCBzb3VyY2VBcnJheSA9IG5ldyBVaW50OEFycmF5KHNvdXJjZUJ1ZmZlcik7XG4gIHRhcmdldEFycmF5LnNldChzb3VyY2VBcnJheSk7XG4gIHJldHVybiB0YXJnZXRCdWZmZXI7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjb3B5VG9BcnJheShzb3VyY2UsIHRhcmdldCwgdGFyZ2V0T2Zmc2V0KSB7XG4gIGxldCBzb3VyY2VBcnJheTtcbiAgaWYgKHNvdXJjZSBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSB7XG4gICAgc291cmNlQXJyYXkgPSBuZXcgVWludDhBcnJheShzb3VyY2UpO1xuICB9IGVsc2Uge1xuICAgIGNvbnN0IHNyY0J5dGVPZmZzZXQgPSBzb3VyY2UuYnl0ZU9mZnNldDtcbiAgICBjb25zdCBzcmNCeXRlTGVuZ3RoID0gc291cmNlLmJ5dGVMZW5ndGg7XG4gICAgc291cmNlQXJyYXkgPSBuZXcgVWludDhBcnJheShzb3VyY2UuYnVmZmVyIHx8IHNvdXJjZS5hcnJheUJ1ZmZlciwgc3JjQnl0ZU9mZnNldCwgc3JjQnl0ZUxlbmd0aCk7XG4gIH1cblxuICB0YXJnZXQuc2V0KHNvdXJjZUFycmF5LCB0YXJnZXRPZmZzZXQpO1xuICByZXR1cm4gdGFyZ2V0T2Zmc2V0ICsgcGFkVG9OQnl0ZXMoc291cmNlQXJyYXkuYnl0ZUxlbmd0aCwgNCk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1tZW1vcnktY29weS11dGlscy5qcy5tYXAiLCJpbXBvcnQgeyBhc3NlcnQgfSBmcm9tICcuLi91dGlscy9hc3NlcnQnO1xuY29uc3QgVFlQRVMgPSBbJ1NDQUxBUicsICdWRUMyJywgJ1ZFQzMnLCAnVkVDNCddO1xuY29uc3QgQVJSQVlfQ09OU1RSVUNUT1JfVE9fV0VCR0xfQ09OU1RBTlQgPSBbW0ludDhBcnJheSwgNTEyMF0sIFtVaW50OEFycmF5LCA1MTIxXSwgW0ludDE2QXJyYXksIDUxMjJdLCBbVWludDE2QXJyYXksIDUxMjNdLCBbVWludDMyQXJyYXksIDUxMjVdLCBbRmxvYXQzMkFycmF5LCA1MTI2XSwgW0Zsb2F0NjRBcnJheSwgNTEzMF1dO1xuY29uc3QgQVJSQVlfVE9fQ09NUE9ORU5UX1RZUEUgPSBuZXcgTWFwKEFSUkFZX0NPTlNUUlVDVE9SX1RPX1dFQkdMX0NPTlNUQU5UKTtcbmNvbnN0IEFUVFJJQlVURV9UWVBFX1RPX0NPTVBPTkVOVFMgPSB7XG4gIFNDQUxBUjogMSxcbiAgVkVDMjogMixcbiAgVkVDMzogMyxcbiAgVkVDNDogNCxcbiAgTUFUMjogNCxcbiAgTUFUMzogOSxcbiAgTUFUNDogMTZcbn07XG5jb25zdCBBVFRSSUJVVEVfQ09NUE9ORU5UX1RZUEVfVE9fQllURV9TSVpFID0ge1xuICA1MTIwOiAxLFxuICA1MTIxOiAxLFxuICA1MTIyOiAyLFxuICA1MTIzOiAyLFxuICA1MTI1OiA0LFxuICA1MTI2OiA0XG59O1xuY29uc3QgQVRUUklCVVRFX0NPTVBPTkVOVF9UWVBFX1RPX0FSUkFZID0ge1xuICA1MTIwOiBJbnQ4QXJyYXksXG4gIDUxMjE6IFVpbnQ4QXJyYXksXG4gIDUxMjI6IEludDE2QXJyYXksXG4gIDUxMjM6IFVpbnQxNkFycmF5LFxuICA1MTI1OiBVaW50MzJBcnJheSxcbiAgNTEyNjogRmxvYXQzMkFycmF5XG59O1xuZXhwb3J0IGZ1bmN0aW9uIGdldEFjY2Vzc29yVHlwZUZyb21TaXplKHNpemUpIHtcbiAgY29uc3QgdHlwZSA9IFRZUEVTW3NpemUgLSAxXTtcbiAgcmV0dXJuIHR5cGUgfHwgVFlQRVNbMF07XG59XG5leHBvcnQgZnVuY3Rpb24gZ2V0Q29tcG9uZW50VHlwZUZyb21BcnJheSh0eXBlZEFycmF5KSB7XG4gIGNvbnN0IGNvbXBvbmVudFR5cGUgPSBBUlJBWV9UT19DT01QT05FTlRfVFlQRS5nZXQodHlwZWRBcnJheS5jb25zdHJ1Y3Rvcik7XG4gIGlmICghY29tcG9uZW50VHlwZSkge1xuICAgIHRocm93IG5ldyBFcnJvcignSWxsZWdhbCB0eXBlZCBhcnJheScpO1xuICB9XG4gIHJldHVybiBjb21wb25lbnRUeXBlO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGdldEFjY2Vzc29yQXJyYXlUeXBlQW5kTGVuZ3RoKGFjY2Vzc29yLCBidWZmZXJWaWV3KSB7XG4gIGNvbnN0IEFycmF5VHlwZSA9IEFUVFJJQlVURV9DT01QT05FTlRfVFlQRV9UT19BUlJBWVthY2Nlc3Nvci5jb21wb25lbnRUeXBlXTtcbiAgY29uc3QgY29tcG9uZW50cyA9IEFUVFJJQlVURV9UWVBFX1RPX0NPTVBPTkVOVFNbYWNjZXNzb3IudHlwZV07XG4gIGNvbnN0IGJ5dGVzUGVyQ29tcG9uZW50ID0gQVRUUklCVVRFX0NPTVBPTkVOVF9UWVBFX1RPX0JZVEVfU0laRVthY2Nlc3Nvci5jb21wb25lbnRUeXBlXTtcbiAgY29uc3QgbGVuZ3RoID0gYWNjZXNzb3IuY291bnQgKiBjb21wb25lbnRzO1xuICBjb25zdCBieXRlTGVuZ3RoID0gYWNjZXNzb3IuY291bnQgKiBjb21wb25lbnRzICogYnl0ZXNQZXJDb21wb25lbnQ7XG4gIGFzc2VydChieXRlTGVuZ3RoID49IDAgJiYgYnl0ZUxlbmd0aCA8PSBidWZmZXJWaWV3LmJ5dGVMZW5ndGgpO1xuICByZXR1cm4ge1xuICAgIEFycmF5VHlwZSxcbiAgICBsZW5ndGgsXG4gICAgYnl0ZUxlbmd0aFxuICB9O1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Z2x0Zi11dGlscy5qcy5tYXAiLCJpbXBvcnQgX2RlZmluZVByb3BlcnR5IGZyb20gXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9kZWZpbmVQcm9wZXJ0eVwiO1xuaW1wb3J0IHsgZ2V0QmluYXJ5SW1hZ2VNZXRhZGF0YSB9IGZyb20gJ0Bsb2FkZXJzLmdsL2ltYWdlcyc7XG5pbXBvcnQgeyBwYWRUb05CeXRlcywgY29weVRvQXJyYXkgfSBmcm9tICdAbG9hZGVycy5nbC9sb2FkZXItdXRpbHMnO1xuaW1wb3J0IHsgYXNzZXJ0IH0gZnJvbSAnLi4vdXRpbHMvYXNzZXJ0JztcbmltcG9ydCB7IGdldEFjY2Vzc29yQXJyYXlUeXBlQW5kTGVuZ3RoLCBnZXRBY2Nlc3NvclR5cGVGcm9tU2l6ZSwgZ2V0Q29tcG9uZW50VHlwZUZyb21BcnJheSB9IGZyb20gJy4uL2dsdGYtdXRpbHMvZ2x0Zi11dGlscyc7XG5jb25zdCBERUZBVUxUX0dMVEZfSlNPTiA9IHtcbiAgYXNzZXQ6IHtcbiAgICB2ZXJzaW9uOiAnMi4wJyxcbiAgICBnZW5lcmF0b3I6ICdsb2FkZXJzLmdsJ1xuICB9LFxuICBidWZmZXJzOiBbXVxufTtcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEdMVEZTY2VuZWdyYXBoIHtcblxuICBjb25zdHJ1Y3RvcihnbHRmKSB7XG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwiZ2x0ZlwiLCB2b2lkIDApO1xuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInNvdXJjZUJ1ZmZlcnNcIiwgdm9pZCAwKTtcbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJieXRlTGVuZ3RoXCIsIHZvaWQgMCk7XG4gICAgdGhpcy5nbHRmID0gZ2x0ZiB8fCB7XG4gICAgICBqc29uOiB7XG4gICAgICAgIC4uLkRFRkFVTFRfR0xURl9KU09OXG4gICAgICB9LFxuICAgICAgYnVmZmVyczogW11cbiAgICB9O1xuICAgIHRoaXMuc291cmNlQnVmZmVycyA9IFtdO1xuICAgIHRoaXMuYnl0ZUxlbmd0aCA9IDA7XG5cbiAgICBpZiAodGhpcy5nbHRmLmJ1ZmZlcnMgJiYgdGhpcy5nbHRmLmJ1ZmZlcnNbMF0pIHtcbiAgICAgIHRoaXMuYnl0ZUxlbmd0aCA9IHRoaXMuZ2x0Zi5idWZmZXJzWzBdLmJ5dGVMZW5ndGg7XG4gICAgICB0aGlzLnNvdXJjZUJ1ZmZlcnMgPSBbdGhpcy5nbHRmLmJ1ZmZlcnNbMF1dO1xuICAgIH1cbiAgfVxuXG4gIGdldCBqc29uKCkge1xuICAgIHJldHVybiB0aGlzLmdsdGYuanNvbjtcbiAgfVxuICBnZXRBcHBsaWNhdGlvbkRhdGEoa2V5KSB7XG4gICAgY29uc3QgZGF0YSA9IHRoaXMuanNvbltrZXldO1xuICAgIHJldHVybiBkYXRhO1xuICB9XG4gIGdldEV4dHJhRGF0YShrZXkpIHtcbiAgICBjb25zdCBleHRyYXMgPSB0aGlzLmpzb24uZXh0cmFzIHx8IHt9O1xuICAgIHJldHVybiBleHRyYXNba2V5XTtcbiAgfVxuICBnZXRFeHRlbnNpb24oZXh0ZW5zaW9uTmFtZSkge1xuICAgIGNvbnN0IGlzRXh0ZW5zaW9uID0gdGhpcy5nZXRVc2VkRXh0ZW5zaW9ucygpLmZpbmQobmFtZSA9PiBuYW1lID09PSBleHRlbnNpb25OYW1lKTtcbiAgICBjb25zdCBleHRlbnNpb25zID0gdGhpcy5qc29uLmV4dGVuc2lvbnMgfHwge307XG4gICAgcmV0dXJuIGlzRXh0ZW5zaW9uID8gZXh0ZW5zaW9uc1tleHRlbnNpb25OYW1lXSB8fCB0cnVlIDogbnVsbDtcbiAgfVxuICBnZXRSZXF1aXJlZEV4dGVuc2lvbihleHRlbnNpb25OYW1lKSB7XG4gICAgY29uc3QgaXNSZXF1aXJlZCA9IHRoaXMuZ2V0UmVxdWlyZWRFeHRlbnNpb25zKCkuZmluZChuYW1lID0+IG5hbWUgPT09IGV4dGVuc2lvbk5hbWUpO1xuICAgIHJldHVybiBpc1JlcXVpcmVkID8gdGhpcy5nZXRFeHRlbnNpb24oZXh0ZW5zaW9uTmFtZSkgOiBudWxsO1xuICB9XG4gIGdldFJlcXVpcmVkRXh0ZW5zaW9ucygpIHtcbiAgICByZXR1cm4gdGhpcy5qc29uLmV4dGVuc2lvbnNSZXF1aXJlZCB8fCBbXTtcbiAgfVxuICBnZXRVc2VkRXh0ZW5zaW9ucygpIHtcbiAgICByZXR1cm4gdGhpcy5qc29uLmV4dGVuc2lvbnNVc2VkIHx8IFtdO1xuICB9XG4gIGdldFJlbW92ZWRFeHRlbnNpb25zKCkge1xuICAgIHJldHVybiB0aGlzLmpzb24uZXh0ZW5zaW9uc1JlbW92ZWQgfHwgW107XG4gIH1cbiAgZ2V0T2JqZWN0RXh0ZW5zaW9uKG9iamVjdCwgZXh0ZW5zaW9uTmFtZSkge1xuICAgIGNvbnN0IGV4dGVuc2lvbnMgPSBvYmplY3QuZXh0ZW5zaW9ucyB8fCB7fTtcbiAgICByZXR1cm4gZXh0ZW5zaW9uc1tleHRlbnNpb25OYW1lXTtcbiAgfVxuICBnZXRTY2VuZShpbmRleCkge1xuICAgIHJldHVybiB0aGlzLmdldE9iamVjdCgnc2NlbmVzJywgaW5kZXgpO1xuICB9XG4gIGdldE5vZGUoaW5kZXgpIHtcbiAgICByZXR1cm4gdGhpcy5nZXRPYmplY3QoJ25vZGVzJywgaW5kZXgpO1xuICB9XG4gIGdldFNraW4oaW5kZXgpIHtcbiAgICByZXR1cm4gdGhpcy5nZXRPYmplY3QoJ3NraW5zJywgaW5kZXgpO1xuICB9XG4gIGdldE1lc2goaW5kZXgpIHtcbiAgICByZXR1cm4gdGhpcy5nZXRPYmplY3QoJ21lc2hlcycsIGluZGV4KTtcbiAgfVxuICBnZXRNYXRlcmlhbChpbmRleCkge1xuICAgIHJldHVybiB0aGlzLmdldE9iamVjdCgnbWF0ZXJpYWxzJywgaW5kZXgpO1xuICB9XG4gIGdldEFjY2Vzc29yKGluZGV4KSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0T2JqZWN0KCdhY2Nlc3NvcnMnLCBpbmRleCk7XG4gIH1cblxuICBnZXRUZXh0dXJlKGluZGV4KSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0T2JqZWN0KCd0ZXh0dXJlcycsIGluZGV4KTtcbiAgfVxuICBnZXRTYW1wbGVyKGluZGV4KSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0T2JqZWN0KCdzYW1wbGVycycsIGluZGV4KTtcbiAgfVxuICBnZXRJbWFnZShpbmRleCkge1xuICAgIHJldHVybiB0aGlzLmdldE9iamVjdCgnaW1hZ2VzJywgaW5kZXgpO1xuICB9XG4gIGdldEJ1ZmZlclZpZXcoaW5kZXgpIHtcbiAgICByZXR1cm4gdGhpcy5nZXRPYmplY3QoJ2J1ZmZlclZpZXdzJywgaW5kZXgpO1xuICB9XG4gIGdldEJ1ZmZlcihpbmRleCkge1xuICAgIHJldHVybiB0aGlzLmdldE9iamVjdCgnYnVmZmVycycsIGluZGV4KTtcbiAgfVxuICBnZXRPYmplY3QoYXJyYXksIGluZGV4KSB7XG4gICAgaWYgKHR5cGVvZiBpbmRleCA9PT0gJ29iamVjdCcpIHtcbiAgICAgIHJldHVybiBpbmRleDtcbiAgICB9XG4gICAgY29uc3Qgb2JqZWN0ID0gdGhpcy5qc29uW2FycmF5XSAmJiB0aGlzLmpzb25bYXJyYXldW2luZGV4XTtcbiAgICBpZiAoIW9iamVjdCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiZ2xURiBmaWxlIGVycm9yOiBDb3VsZCBub3QgZmluZCBcIi5jb25jYXQoYXJyYXksIFwiW1wiKS5jb25jYXQoaW5kZXgsIFwiXVwiKSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG9iamVjdDtcbiAgfVxuXG4gIGdldFR5cGVkQXJyYXlGb3JCdWZmZXJWaWV3KGJ1ZmZlclZpZXcpIHtcbiAgICBidWZmZXJWaWV3ID0gdGhpcy5nZXRCdWZmZXJWaWV3KGJ1ZmZlclZpZXcpO1xuICAgIGNvbnN0IGJ1ZmZlckluZGV4ID0gYnVmZmVyVmlldy5idWZmZXI7XG5cbiAgICBjb25zdCBiaW5DaHVuayA9IHRoaXMuZ2x0Zi5idWZmZXJzW2J1ZmZlckluZGV4XTtcbiAgICBhc3NlcnQoYmluQ2h1bmspO1xuXG4gICAgY29uc3QgYnl0ZU9mZnNldCA9IChidWZmZXJWaWV3LmJ5dGVPZmZzZXQgfHwgMCkgKyBiaW5DaHVuay5ieXRlT2Zmc2V0O1xuICAgIHJldHVybiBuZXcgVWludDhBcnJheShiaW5DaHVuay5hcnJheUJ1ZmZlciwgYnl0ZU9mZnNldCwgYnVmZmVyVmlldy5ieXRlTGVuZ3RoKTtcbiAgfVxuXG4gIGdldFR5cGVkQXJyYXlGb3JBY2Nlc3NvcihhY2Nlc3Nvcikge1xuICAgIGFjY2Vzc29yID0gdGhpcy5nZXRBY2Nlc3NvcihhY2Nlc3Nvcik7XG4gICAgY29uc3QgYnVmZmVyVmlldyA9IHRoaXMuZ2V0QnVmZmVyVmlldyhhY2Nlc3Nvci5idWZmZXJWaWV3KTtcbiAgICBjb25zdCBidWZmZXIgPSB0aGlzLmdldEJ1ZmZlcihidWZmZXJWaWV3LmJ1ZmZlcik7XG4gICAgY29uc3QgYXJyYXlCdWZmZXIgPSBidWZmZXIuZGF0YTtcblxuICAgIGNvbnN0IHtcbiAgICAgIEFycmF5VHlwZSxcbiAgICAgIGxlbmd0aFxuICAgIH0gPSBnZXRBY2Nlc3NvckFycmF5VHlwZUFuZExlbmd0aChhY2Nlc3NvciwgYnVmZmVyVmlldyk7XG4gICAgY29uc3QgYnl0ZU9mZnNldCA9IGJ1ZmZlclZpZXcuYnl0ZU9mZnNldCArIGFjY2Vzc29yLmJ5dGVPZmZzZXQ7XG4gICAgcmV0dXJuIG5ldyBBcnJheVR5cGUoYXJyYXlCdWZmZXIsIGJ5dGVPZmZzZXQsIGxlbmd0aCk7XG4gIH1cblxuICBnZXRUeXBlZEFycmF5Rm9ySW1hZ2VEYXRhKGltYWdlKSB7XG4gICAgaW1hZ2UgPSB0aGlzLmdldEFjY2Vzc29yKGltYWdlKTtcbiAgICBjb25zdCBidWZmZXJWaWV3ID0gdGhpcy5nZXRCdWZmZXJWaWV3KGltYWdlLmJ1ZmZlclZpZXcpO1xuICAgIGNvbnN0IGJ1ZmZlciA9IHRoaXMuZ2V0QnVmZmVyKGJ1ZmZlclZpZXcuYnVmZmVyKTtcbiAgICBjb25zdCBhcnJheUJ1ZmZlciA9IGJ1ZmZlci5kYXRhO1xuICAgIGNvbnN0IGJ5dGVPZmZzZXQgPSBidWZmZXJWaWV3LmJ5dGVPZmZzZXQgfHwgMDtcbiAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoYXJyYXlCdWZmZXIsIGJ5dGVPZmZzZXQsIGJ1ZmZlclZpZXcuYnl0ZUxlbmd0aCk7XG4gIH1cblxuICBhZGRBcHBsaWNhdGlvbkRhdGEoa2V5LCBkYXRhKSB7XG4gICAgdGhpcy5qc29uW2tleV0gPSBkYXRhO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgYWRkRXh0cmFEYXRhKGtleSwgZGF0YSkge1xuICAgIHRoaXMuanNvbi5leHRyYXMgPSB0aGlzLmpzb24uZXh0cmFzIHx8IHt9O1xuICAgIHRoaXMuanNvbi5leHRyYXNba2V5XSA9IGRhdGE7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgYWRkT2JqZWN0RXh0ZW5zaW9uKG9iamVjdCwgZXh0ZW5zaW9uTmFtZSwgZGF0YSkge1xuICAgIG9iamVjdC5leHRlbnNpb25zID0gb2JqZWN0LmV4dGVuc2lvbnMgfHwge307XG4gICAgb2JqZWN0LmV4dGVuc2lvbnNbZXh0ZW5zaW9uTmFtZV0gPSBkYXRhO1xuICAgIHRoaXMucmVnaXN0ZXJVc2VkRXh0ZW5zaW9uKGV4dGVuc2lvbk5hbWUpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIHNldE9iamVjdEV4dGVuc2lvbihvYmplY3QsIGV4dGVuc2lvbk5hbWUsIGRhdGEpIHtcbiAgICBjb25zdCBleHRlbnNpb25zID0gb2JqZWN0LmV4dGVuc2lvbnMgfHwge307XG4gICAgZXh0ZW5zaW9uc1tleHRlbnNpb25OYW1lXSA9IGRhdGE7XG4gIH1cblxuICByZW1vdmVPYmplY3RFeHRlbnNpb24ob2JqZWN0LCBleHRlbnNpb25OYW1lKSB7XG4gICAgY29uc3QgZXh0ZW5zaW9ucyA9IG9iamVjdC5leHRlbnNpb25zIHx8IHt9O1xuICAgIGNvbnN0IGV4dGVuc2lvbiA9IGV4dGVuc2lvbnNbZXh0ZW5zaW9uTmFtZV07XG4gICAgZGVsZXRlIGV4dGVuc2lvbnNbZXh0ZW5zaW9uTmFtZV07XG4gICAgcmV0dXJuIGV4dGVuc2lvbjtcbiAgfVxuXG4gIGFkZEV4dGVuc2lvbihleHRlbnNpb25OYW1lKSB7XG4gICAgbGV0IGV4dGVuc2lvbkRhdGEgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuICAgIGFzc2VydChleHRlbnNpb25EYXRhKTtcbiAgICB0aGlzLmpzb24uZXh0ZW5zaW9ucyA9IHRoaXMuanNvbi5leHRlbnNpb25zIHx8IHt9O1xuICAgIHRoaXMuanNvbi5leHRlbnNpb25zW2V4dGVuc2lvbk5hbWVdID0gZXh0ZW5zaW9uRGF0YTtcbiAgICB0aGlzLnJlZ2lzdGVyVXNlZEV4dGVuc2lvbihleHRlbnNpb25OYW1lKTtcbiAgICByZXR1cm4gZXh0ZW5zaW9uRGF0YTtcbiAgfVxuXG4gIGFkZFJlcXVpcmVkRXh0ZW5zaW9uKGV4dGVuc2lvbk5hbWUpIHtcbiAgICBsZXQgZXh0ZW5zaW9uRGF0YSA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG4gICAgYXNzZXJ0KGV4dGVuc2lvbkRhdGEpO1xuICAgIHRoaXMuYWRkRXh0ZW5zaW9uKGV4dGVuc2lvbk5hbWUsIGV4dGVuc2lvbkRhdGEpO1xuICAgIHRoaXMucmVnaXN0ZXJSZXF1aXJlZEV4dGVuc2lvbihleHRlbnNpb25OYW1lKTtcbiAgICByZXR1cm4gZXh0ZW5zaW9uRGF0YTtcbiAgfVxuXG4gIHJlZ2lzdGVyVXNlZEV4dGVuc2lvbihleHRlbnNpb25OYW1lKSB7XG4gICAgdGhpcy5qc29uLmV4dGVuc2lvbnNVc2VkID0gdGhpcy5qc29uLmV4dGVuc2lvbnNVc2VkIHx8IFtdO1xuICAgIGlmICghdGhpcy5qc29uLmV4dGVuc2lvbnNVc2VkLmZpbmQoZXh0ID0+IGV4dCA9PT0gZXh0ZW5zaW9uTmFtZSkpIHtcbiAgICAgIHRoaXMuanNvbi5leHRlbnNpb25zVXNlZC5wdXNoKGV4dGVuc2lvbk5hbWUpO1xuICAgIH1cbiAgfVxuXG4gIHJlZ2lzdGVyUmVxdWlyZWRFeHRlbnNpb24oZXh0ZW5zaW9uTmFtZSkge1xuICAgIHRoaXMucmVnaXN0ZXJVc2VkRXh0ZW5zaW9uKGV4dGVuc2lvbk5hbWUpO1xuICAgIHRoaXMuanNvbi5leHRlbnNpb25zUmVxdWlyZWQgPSB0aGlzLmpzb24uZXh0ZW5zaW9uc1JlcXVpcmVkIHx8IFtdO1xuICAgIGlmICghdGhpcy5qc29uLmV4dGVuc2lvbnNSZXF1aXJlZC5maW5kKGV4dCA9PiBleHQgPT09IGV4dGVuc2lvbk5hbWUpKSB7XG4gICAgICB0aGlzLmpzb24uZXh0ZW5zaW9uc1JlcXVpcmVkLnB1c2goZXh0ZW5zaW9uTmFtZSk7XG4gICAgfVxuICB9XG5cbiAgcmVtb3ZlRXh0ZW5zaW9uKGV4dGVuc2lvbk5hbWUpIHtcbiAgICBpZiAoIXRoaXMuZ2V0RXh0ZW5zaW9uKGV4dGVuc2lvbk5hbWUpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICh0aGlzLmpzb24uZXh0ZW5zaW9uc1JlcXVpcmVkKSB7XG4gICAgICB0aGlzLl9yZW1vdmVTdHJpbmdGcm9tQXJyYXkodGhpcy5qc29uLmV4dGVuc2lvbnNSZXF1aXJlZCwgZXh0ZW5zaW9uTmFtZSk7XG4gICAgfVxuICAgIGlmICh0aGlzLmpzb24uZXh0ZW5zaW9uc1VzZWQpIHtcbiAgICAgIHRoaXMuX3JlbW92ZVN0cmluZ0Zyb21BcnJheSh0aGlzLmpzb24uZXh0ZW5zaW9uc1VzZWQsIGV4dGVuc2lvbk5hbWUpO1xuICAgIH1cbiAgICBpZiAodGhpcy5qc29uLmV4dGVuc2lvbnMpIHtcbiAgICAgIGRlbGV0ZSB0aGlzLmpzb24uZXh0ZW5zaW9uc1tleHRlbnNpb25OYW1lXTtcbiAgICB9XG4gICAgaWYgKCFBcnJheS5pc0FycmF5KHRoaXMuanNvbi5leHRlbnNpb25zUmVtb3ZlZCkpIHtcbiAgICAgIHRoaXMuanNvbi5leHRlbnNpb25zUmVtb3ZlZCA9IFtdO1xuICAgIH1cbiAgICBjb25zdCBleHRlbnNpb25zUmVtb3ZlZCA9IHRoaXMuanNvbi5leHRlbnNpb25zUmVtb3ZlZDtcbiAgICBpZiAoIWV4dGVuc2lvbnNSZW1vdmVkLmluY2x1ZGVzKGV4dGVuc2lvbk5hbWUpKSB7XG4gICAgICBleHRlbnNpb25zUmVtb3ZlZC5wdXNoKGV4dGVuc2lvbk5hbWUpO1xuICAgIH1cbiAgfVxuXG4gIHNldERlZmF1bHRTY2VuZShzY2VuZUluZGV4KSB7XG4gICAgdGhpcy5qc29uLnNjZW5lID0gc2NlbmVJbmRleDtcbiAgfVxuXG4gIGFkZFNjZW5lKHNjZW5lKSB7XG4gICAgY29uc3Qge1xuICAgICAgbm9kZUluZGljZXNcbiAgICB9ID0gc2NlbmU7XG4gICAgdGhpcy5qc29uLnNjZW5lcyA9IHRoaXMuanNvbi5zY2VuZXMgfHwgW107XG4gICAgdGhpcy5qc29uLnNjZW5lcy5wdXNoKHtcbiAgICAgIG5vZGVzOiBub2RlSW5kaWNlc1xuICAgIH0pO1xuICAgIHJldHVybiB0aGlzLmpzb24uc2NlbmVzLmxlbmd0aCAtIDE7XG4gIH1cblxuICBhZGROb2RlKG5vZGUpIHtcbiAgICBjb25zdCB7XG4gICAgICBtZXNoSW5kZXgsXG4gICAgICBtYXRyaXhcbiAgICB9ID0gbm9kZTtcbiAgICB0aGlzLmpzb24ubm9kZXMgPSB0aGlzLmpzb24ubm9kZXMgfHwgW107XG4gICAgY29uc3Qgbm9kZURhdGEgPSB7XG4gICAgICBtZXNoOiBtZXNoSW5kZXhcbiAgICB9O1xuICAgIGlmIChtYXRyaXgpIHtcbiAgICAgIG5vZGVEYXRhLm1hdHJpeCA9IG1hdHJpeDtcbiAgICB9XG4gICAgdGhpcy5qc29uLm5vZGVzLnB1c2gobm9kZURhdGEpO1xuICAgIHJldHVybiB0aGlzLmpzb24ubm9kZXMubGVuZ3RoIC0gMTtcbiAgfVxuXG4gIGFkZE1lc2gobWVzaCkge1xuICAgIGNvbnN0IHtcbiAgICAgIGF0dHJpYnV0ZXMsXG4gICAgICBpbmRpY2VzLFxuICAgICAgbWF0ZXJpYWwsXG4gICAgICBtb2RlID0gNFxuICAgIH0gPSBtZXNoO1xuICAgIGNvbnN0IGFjY2Vzc29ycyA9IHRoaXMuX2FkZEF0dHJpYnV0ZXMoYXR0cmlidXRlcyk7XG4gICAgY29uc3QgZ2xURk1lc2ggPSB7XG4gICAgICBwcmltaXRpdmVzOiBbe1xuICAgICAgICBhdHRyaWJ1dGVzOiBhY2Nlc3NvcnMsXG4gICAgICAgIG1vZGVcbiAgICAgIH1dXG4gICAgfTtcbiAgICBpZiAoaW5kaWNlcykge1xuICAgICAgY29uc3QgaW5kaWNlc0FjY2Vzc29yID0gdGhpcy5fYWRkSW5kaWNlcyhpbmRpY2VzKTtcbiAgICAgIGdsVEZNZXNoLnByaW1pdGl2ZXNbMF0uaW5kaWNlcyA9IGluZGljZXNBY2Nlc3NvcjtcbiAgICB9XG4gICAgaWYgKE51bWJlci5pc0Zpbml0ZShtYXRlcmlhbCkpIHtcbiAgICAgIGdsVEZNZXNoLnByaW1pdGl2ZXNbMF0ubWF0ZXJpYWwgPSBtYXRlcmlhbDtcbiAgICB9XG4gICAgdGhpcy5qc29uLm1lc2hlcyA9IHRoaXMuanNvbi5tZXNoZXMgfHwgW107XG4gICAgdGhpcy5qc29uLm1lc2hlcy5wdXNoKGdsVEZNZXNoKTtcbiAgICByZXR1cm4gdGhpcy5qc29uLm1lc2hlcy5sZW5ndGggLSAxO1xuICB9XG4gIGFkZFBvaW50Q2xvdWQoYXR0cmlidXRlcykge1xuICAgIGNvbnN0IGFjY2Vzc29ySW5kaWNlcyA9IHRoaXMuX2FkZEF0dHJpYnV0ZXMoYXR0cmlidXRlcyk7XG4gICAgY29uc3QgZ2xURk1lc2ggPSB7XG4gICAgICBwcmltaXRpdmVzOiBbe1xuICAgICAgICBhdHRyaWJ1dGVzOiBhY2Nlc3NvckluZGljZXMsXG4gICAgICAgIG1vZGU6IDBcbiAgICAgIH1dXG4gICAgfTtcblxuICAgIHRoaXMuanNvbi5tZXNoZXMgPSB0aGlzLmpzb24ubWVzaGVzIHx8IFtdO1xuICAgIHRoaXMuanNvbi5tZXNoZXMucHVzaChnbFRGTWVzaCk7XG4gICAgcmV0dXJuIHRoaXMuanNvbi5tZXNoZXMubGVuZ3RoIC0gMTtcbiAgfVxuXG4gIGFkZEltYWdlKGltYWdlRGF0YSwgbWltZVR5cGVPcHQpIHtcbiAgICBjb25zdCBtZXRhZGF0YSA9IGdldEJpbmFyeUltYWdlTWV0YWRhdGEoaW1hZ2VEYXRhKTtcbiAgICBjb25zdCBtaW1lVHlwZSA9IG1pbWVUeXBlT3B0IHx8IChtZXRhZGF0YSA9PT0gbnVsbCB8fCBtZXRhZGF0YSA9PT0gdm9pZCAwID8gdm9pZCAwIDogbWV0YWRhdGEubWltZVR5cGUpO1xuICAgIGNvbnN0IGJ1ZmZlclZpZXdJbmRleCA9IHRoaXMuYWRkQnVmZmVyVmlldyhpbWFnZURhdGEpO1xuICAgIGNvbnN0IGdsVEZJbWFnZSA9IHtcbiAgICAgIGJ1ZmZlclZpZXc6IGJ1ZmZlclZpZXdJbmRleCxcbiAgICAgIG1pbWVUeXBlXG4gICAgfTtcbiAgICB0aGlzLmpzb24uaW1hZ2VzID0gdGhpcy5qc29uLmltYWdlcyB8fCBbXTtcbiAgICB0aGlzLmpzb24uaW1hZ2VzLnB1c2goZ2xURkltYWdlKTtcbiAgICByZXR1cm4gdGhpcy5qc29uLmltYWdlcy5sZW5ndGggLSAxO1xuICB9XG5cbiAgYWRkQnVmZmVyVmlldyhidWZmZXIpIHtcbiAgICBjb25zdCBieXRlTGVuZ3RoID0gYnVmZmVyLmJ5dGVMZW5ndGg7XG4gICAgYXNzZXJ0KE51bWJlci5pc0Zpbml0ZShieXRlTGVuZ3RoKSk7XG5cbiAgICB0aGlzLnNvdXJjZUJ1ZmZlcnMgPSB0aGlzLnNvdXJjZUJ1ZmZlcnMgfHwgW107XG4gICAgdGhpcy5zb3VyY2VCdWZmZXJzLnB1c2goYnVmZmVyKTtcbiAgICBjb25zdCBnbFRGQnVmZmVyVmlldyA9IHtcbiAgICAgIGJ1ZmZlcjogMCxcbiAgICAgIGJ5dGVPZmZzZXQ6IHRoaXMuYnl0ZUxlbmd0aCxcbiAgICAgIGJ5dGVMZW5ndGhcbiAgICB9O1xuXG4gICAgdGhpcy5ieXRlTGVuZ3RoICs9IHBhZFRvTkJ5dGVzKGJ5dGVMZW5ndGgsIDQpO1xuXG4gICAgdGhpcy5qc29uLmJ1ZmZlclZpZXdzID0gdGhpcy5qc29uLmJ1ZmZlclZpZXdzIHx8IFtdO1xuICAgIHRoaXMuanNvbi5idWZmZXJWaWV3cy5wdXNoKGdsVEZCdWZmZXJWaWV3KTtcbiAgICByZXR1cm4gdGhpcy5qc29uLmJ1ZmZlclZpZXdzLmxlbmd0aCAtIDE7XG4gIH1cblxuICBhZGRBY2Nlc3NvcihidWZmZXJWaWV3SW5kZXgsIGFjY2Vzc29yKSB7XG4gICAgY29uc3QgZ2xURkFjY2Vzc29yID0ge1xuICAgICAgYnVmZmVyVmlldzogYnVmZmVyVmlld0luZGV4LFxuICAgICAgdHlwZTogZ2V0QWNjZXNzb3JUeXBlRnJvbVNpemUoYWNjZXNzb3Iuc2l6ZSksXG4gICAgICBjb21wb25lbnRUeXBlOiBhY2Nlc3Nvci5jb21wb25lbnRUeXBlLFxuICAgICAgY291bnQ6IGFjY2Vzc29yLmNvdW50LFxuICAgICAgbWF4OiBhY2Nlc3Nvci5tYXgsXG4gICAgICBtaW46IGFjY2Vzc29yLm1pblxuICAgIH07XG4gICAgdGhpcy5qc29uLmFjY2Vzc29ycyA9IHRoaXMuanNvbi5hY2Nlc3NvcnMgfHwgW107XG4gICAgdGhpcy5qc29uLmFjY2Vzc29ycy5wdXNoKGdsVEZBY2Nlc3Nvcik7XG4gICAgcmV0dXJuIHRoaXMuanNvbi5hY2Nlc3NvcnMubGVuZ3RoIC0gMTtcbiAgfVxuXG4gIGFkZEJpbmFyeUJ1ZmZlcihzb3VyY2VCdWZmZXIpIHtcbiAgICBsZXQgYWNjZXNzb3IgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHtcbiAgICAgIHNpemU6IDNcbiAgICB9O1xuICAgIGNvbnN0IGJ1ZmZlclZpZXdJbmRleCA9IHRoaXMuYWRkQnVmZmVyVmlldyhzb3VyY2VCdWZmZXIpO1xuICAgIGxldCBtaW5NYXggPSB7XG4gICAgICBtaW46IGFjY2Vzc29yLm1pbixcbiAgICAgIG1heDogYWNjZXNzb3IubWF4XG4gICAgfTtcbiAgICBpZiAoIW1pbk1heC5taW4gfHwgIW1pbk1heC5tYXgpIHtcbiAgICAgIG1pbk1heCA9IHRoaXMuX2dldEFjY2Vzc29yTWluTWF4KHNvdXJjZUJ1ZmZlciwgYWNjZXNzb3Iuc2l6ZSk7XG4gICAgfVxuICAgIGNvbnN0IGFjY2Vzc29yRGVmYXVsdHMgPSB7XG4gICAgICBzaXplOiBhY2Nlc3Nvci5zaXplLFxuICAgICAgY29tcG9uZW50VHlwZTogZ2V0Q29tcG9uZW50VHlwZUZyb21BcnJheShzb3VyY2VCdWZmZXIpLFxuICAgICAgY291bnQ6IE1hdGgucm91bmQoc291cmNlQnVmZmVyLmxlbmd0aCAvIGFjY2Vzc29yLnNpemUpLFxuICAgICAgbWluOiBtaW5NYXgubWluLFxuICAgICAgbWF4OiBtaW5NYXgubWF4XG4gICAgfTtcbiAgICByZXR1cm4gdGhpcy5hZGRBY2Nlc3NvcihidWZmZXJWaWV3SW5kZXgsIE9iamVjdC5hc3NpZ24oYWNjZXNzb3JEZWZhdWx0cywgYWNjZXNzb3IpKTtcbiAgfVxuXG4gIGFkZFRleHR1cmUodGV4dHVyZSkge1xuICAgIGNvbnN0IHtcbiAgICAgIGltYWdlSW5kZXhcbiAgICB9ID0gdGV4dHVyZTtcbiAgICBjb25zdCBnbFRGVGV4dHVyZSA9IHtcbiAgICAgIHNvdXJjZTogaW1hZ2VJbmRleFxuICAgIH07XG4gICAgdGhpcy5qc29uLnRleHR1cmVzID0gdGhpcy5qc29uLnRleHR1cmVzIHx8IFtdO1xuICAgIHRoaXMuanNvbi50ZXh0dXJlcy5wdXNoKGdsVEZUZXh0dXJlKTtcbiAgICByZXR1cm4gdGhpcy5qc29uLnRleHR1cmVzLmxlbmd0aCAtIDE7XG4gIH1cblxuICBhZGRNYXRlcmlhbChwYnJNYXRlcmlhbEluZm8pIHtcbiAgICB0aGlzLmpzb24ubWF0ZXJpYWxzID0gdGhpcy5qc29uLm1hdGVyaWFscyB8fCBbXTtcbiAgICB0aGlzLmpzb24ubWF0ZXJpYWxzLnB1c2gocGJyTWF0ZXJpYWxJbmZvKTtcbiAgICByZXR1cm4gdGhpcy5qc29uLm1hdGVyaWFscy5sZW5ndGggLSAxO1xuICB9XG5cbiAgY3JlYXRlQmluYXJ5Q2h1bmsoKSB7XG4gICAgdmFyIF90aGlzJGpzb24sIF90aGlzJGpzb24kYnVmZmVycztcbiAgICB0aGlzLmdsdGYuYnVmZmVycyA9IFtdO1xuXG4gICAgY29uc3QgdG90YWxCeXRlTGVuZ3RoID0gdGhpcy5ieXRlTGVuZ3RoO1xuICAgIGNvbnN0IGFycmF5QnVmZmVyID0gbmV3IEFycmF5QnVmZmVyKHRvdGFsQnl0ZUxlbmd0aCk7XG4gICAgY29uc3QgdGFyZ2V0QXJyYXkgPSBuZXcgVWludDhBcnJheShhcnJheUJ1ZmZlcik7XG5cbiAgICBsZXQgZHN0Qnl0ZU9mZnNldCA9IDA7XG4gICAgZm9yIChjb25zdCBzb3VyY2VCdWZmZXIgb2YgdGhpcy5zb3VyY2VCdWZmZXJzIHx8IFtdKSB7XG4gICAgICBkc3RCeXRlT2Zmc2V0ID0gY29weVRvQXJyYXkoc291cmNlQnVmZmVyLCB0YXJnZXRBcnJheSwgZHN0Qnl0ZU9mZnNldCk7XG4gICAgfVxuXG4gICAgaWYgKChfdGhpcyRqc29uID0gdGhpcy5qc29uKSAhPT0gbnVsbCAmJiBfdGhpcyRqc29uICE9PSB2b2lkIDAgJiYgKF90aGlzJGpzb24kYnVmZmVycyA9IF90aGlzJGpzb24uYnVmZmVycykgIT09IG51bGwgJiYgX3RoaXMkanNvbiRidWZmZXJzICE9PSB2b2lkIDAgJiYgX3RoaXMkanNvbiRidWZmZXJzWzBdKSB7XG4gICAgICB0aGlzLmpzb24uYnVmZmVyc1swXS5ieXRlTGVuZ3RoID0gdG90YWxCeXRlTGVuZ3RoO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmpzb24uYnVmZmVycyA9IFt7XG4gICAgICAgIGJ5dGVMZW5ndGg6IHRvdGFsQnl0ZUxlbmd0aFxuICAgICAgfV07XG4gICAgfVxuXG4gICAgdGhpcy5nbHRmLmJpbmFyeSA9IGFycmF5QnVmZmVyO1xuXG4gICAgdGhpcy5zb3VyY2VCdWZmZXJzID0gW2FycmF5QnVmZmVyXTtcbiAgfVxuXG4gIF9yZW1vdmVTdHJpbmdGcm9tQXJyYXkoYXJyYXksIHN0cmluZykge1xuICAgIGxldCBmb3VuZCA9IHRydWU7XG4gICAgd2hpbGUgKGZvdW5kKSB7XG4gICAgICBjb25zdCBpbmRleCA9IGFycmF5LmluZGV4T2Yoc3RyaW5nKTtcbiAgICAgIGlmIChpbmRleCA+IC0xKSB7XG4gICAgICAgIGFycmF5LnNwbGljZShpbmRleCwgMSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBmb3VuZCA9IGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIF9hZGRBdHRyaWJ1dGVzKCkge1xuICAgIGxldCBhdHRyaWJ1dGVzID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fTtcbiAgICBjb25zdCByZXN1bHQgPSB7fTtcbiAgICBmb3IgKGNvbnN0IGF0dHJpYnV0ZUtleSBpbiBhdHRyaWJ1dGVzKSB7XG4gICAgICBjb25zdCBhdHRyaWJ1dGVEYXRhID0gYXR0cmlidXRlc1thdHRyaWJ1dGVLZXldO1xuICAgICAgY29uc3QgYXR0ck5hbWUgPSB0aGlzLl9nZXRHbHRmQXR0cmlidXRlTmFtZShhdHRyaWJ1dGVLZXkpO1xuICAgICAgY29uc3QgYWNjZXNzb3IgPSB0aGlzLmFkZEJpbmFyeUJ1ZmZlcihhdHRyaWJ1dGVEYXRhLnZhbHVlLCBhdHRyaWJ1dGVEYXRhKTtcbiAgICAgIHJlc3VsdFthdHRyTmFtZV0gPSBhY2Nlc3NvcjtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIF9hZGRJbmRpY2VzKGluZGljZXMpIHtcbiAgICByZXR1cm4gdGhpcy5hZGRCaW5hcnlCdWZmZXIoaW5kaWNlcywge1xuICAgICAgc2l6ZTogMVxuICAgIH0pO1xuICB9XG5cbiAgX2dldEdsdGZBdHRyaWJ1dGVOYW1lKGF0dHJpYnV0ZU5hbWUpIHtcbiAgICBzd2l0Y2ggKGF0dHJpYnV0ZU5hbWUudG9Mb3dlckNhc2UoKSkge1xuICAgICAgY2FzZSAncG9zaXRpb24nOlxuICAgICAgY2FzZSAncG9zaXRpb25zJzpcbiAgICAgIGNhc2UgJ3ZlcnRpY2VzJzpcbiAgICAgICAgcmV0dXJuICdQT1NJVElPTic7XG4gICAgICBjYXNlICdub3JtYWwnOlxuICAgICAgY2FzZSAnbm9ybWFscyc6XG4gICAgICAgIHJldHVybiAnTk9STUFMJztcbiAgICAgIGNhc2UgJ2NvbG9yJzpcbiAgICAgIGNhc2UgJ2NvbG9ycyc6XG4gICAgICAgIHJldHVybiAnQ09MT1JfMCc7XG4gICAgICBjYXNlICd0ZXhjb29yZCc6XG4gICAgICBjYXNlICd0ZXhjb29yZHMnOlxuICAgICAgICByZXR1cm4gJ1RFWENPT1JEXzAnO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIGF0dHJpYnV0ZU5hbWU7XG4gICAgfVxuICB9XG5cbiAgX2dldEFjY2Vzc29yTWluTWF4KGJ1ZmZlciwgc2l6ZSkge1xuICAgIGNvbnN0IHJlc3VsdCA9IHtcbiAgICAgIG1pbjogbnVsbCxcbiAgICAgIG1heDogbnVsbFxuICAgIH07XG4gICAgaWYgKGJ1ZmZlci5sZW5ndGggPCBzaXplKSB7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICByZXN1bHQubWluID0gW107XG4gICAgcmVzdWx0Lm1heCA9IFtdO1xuICAgIGNvbnN0IGluaXRWYWx1ZXMgPSBidWZmZXIuc3ViYXJyYXkoMCwgc2l6ZSk7XG4gICAgZm9yIChjb25zdCB2YWx1ZSBvZiBpbml0VmFsdWVzKSB7XG4gICAgICByZXN1bHQubWluLnB1c2godmFsdWUpO1xuICAgICAgcmVzdWx0Lm1heC5wdXNoKHZhbHVlKTtcbiAgICB9XG4gICAgZm9yIChsZXQgaW5kZXggPSBzaXplOyBpbmRleCA8IGJ1ZmZlci5sZW5ndGg7IGluZGV4ICs9IHNpemUpIHtcbiAgICAgIGZvciAobGV0IGNvbXBvbmVudEluZGV4ID0gMDsgY29tcG9uZW50SW5kZXggPCBzaXplOyBjb21wb25lbnRJbmRleCsrKSB7XG4gICAgICAgIHJlc3VsdC5taW5bMCArIGNvbXBvbmVudEluZGV4XSA9IE1hdGgubWluKFxuICAgICAgICByZXN1bHQubWluWzAgKyBjb21wb25lbnRJbmRleF0sIGJ1ZmZlcltpbmRleCArIGNvbXBvbmVudEluZGV4XSk7XG4gICAgICAgIHJlc3VsdC5tYXhbMCArIGNvbXBvbmVudEluZGV4XSA9IE1hdGgubWF4KFxuICAgICAgICByZXN1bHQubWF4WzAgKyBjb21wb25lbnRJbmRleF0sIGJ1ZmZlcltpbmRleCArIGNvbXBvbmVudEluZGV4XSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWdsdGYtc2NlbmVncmFwaC5qcy5tYXAiLCJcblxuY29uc3QgaXNXZWJBc3NlbWJseVN1cHBvcnRlZCA9IHR5cGVvZiBXZWJBc3NlbWJseSAhPT0gJ29iamVjdCc7XG5cbmNvbnN0IHdhc21fYmFzZSA9ICdCOWg5ejl0RkJCQkY4Zkw5Z0JCOWdMYWFhYWFGYTlnRWFhYUI5Z0ZhRmE5Z0VhYWFGYUVNY0JGRkZHR0dFSUlJTEY5d0ZGRkxFRkJGS05GYUZDeC9JRk1PL0xGVks5dHY5dDl2cTk1R0J0OWY5ZjkzOWg5ejl0OWY5ajloOXM5czlmOWpXOXZxOXpCQnA5dHY5ejlvOXY5d1c5ZjlrdjlqOXY5a3Y5V3ZxV3Y5NGg5MTltOW12cUJGOFo5dHY5ejlvOXY5d1c5ZjlrdjlqOXY5a3Y5Sjl1OWt2OTRoOTE5bTltdnFCR3k5dHY5ejlvOXY5d1c5ZjlrdjlqOXY5a3Y5Sjl1OWt2OTQ5VHZaOTF2OXU5anZCRW45dHY5ejlvOXY5d1c5ZjlrdjlqOXY5a3Y2OXA5c1d2cTlQOWpXQklpOXR2OXo5bzl2OXdXOWY5a3Y5ajl2OWt2NjlwOXNXdnE5UjkxOWhXQkxuOXR2OXo5bzl2OXdXOWY5a3Y5ajl2OWt2NjlwOXNXdnE5Rjk0OXdCS0k5ejlpcWxCT2MreDh5Y0dCTS9xUUZUYThqVVVVVUJDVS9FQmxITDhrVVVVVUJDOStSS0dYQUdDRkpBSTlMUUJDYVJLQUUyQkJDK2dGOUhRQkFMQUVBSUpIT0FHbEFHVGtVVVVCUk5DVW9CQUc5dUMvd2dCWkhLQ1VHQUtDVUc5SnlSVkFFQ0ZKUklDQlJjR1hFWEFjQUY5UFFGQVZBRkFjbEFjQVZKQUY5SnlSTUdYR1hBRzlGUUJBTUNiSkhLQzl3WlJTQUtDSXJDRUpDR3JSUUFOQ1VHSlJmQ0JSYkFJUlRFWEdYQU9BVGxBUTlQUUJDQlJJU0VNQVRBUUpSSUdYQVM5RlFCQ0JSdENCUkVFWEdYQU9BSWxDaTlQUUJDQlJJU0xNQU5DVS9DQkpBRUpSS0dYR1hHWEdYR1hBVEFFQ0tySjJCQkF0Q0tackNFWmZJQkZHRUJNQUtoQjgzRUJBS0NOSmhCODNFQlNFTUFLQUkyQklBSTJCQkhtQ0tySFlBWUNFNkhZeTg2QkJBS0NGSkFJQ0lKQVlKSFkyQkJBbUNJckNFWkhQQVBDRTZIUHk4NkJCQUtDR0pBWUFQSkhZMkJCQW1DR3JDRVpIUEFQQ0U2SFB5ODZCQkFLQ0VKQVlBUEpIWTJCQkFtQ0VaSG1BbUNFNkhteTg2QkJBS0NJSkFZQW1KSFkyQkJBSTJCRkhtQ0tySFBBUENFNkhQeTg2QkJBS0NMSkFZQVBKSFkyQkJBbUNJckNFWkhQQVBDRTZIUHk4NkJCQUtDS0pBWUFQSkhZMkJCQW1DR3JDRVpIUEFQQ0U2SFB5ODZCQkFLQ09KQVlBUEpIWTJCQkFtQ0VaSG1BbUNFNkhteTg2QkJBS0NOSkFZQW1KSFkyQkJBSTJCR0htQ0tySFBBUENFNkhQeTg2QkJBS0NWSkFZQVBKSFkyQkJBbUNJckNFWkhQQVBDRTZIUHk4NkJCQUtDY0pBWUFQSkhZMkJCQW1DR3JDRVpIUEFQQ0U2SFB5ODZCQkFLQ01KQVlBUEpIWTJCQkFtQ0VaSG1BbUNFNkhteTg2QkJBS0NTSkFZQW1KSG0yQkJBSTJCRUhJQ0tySFlBWUNFNkhZeTg2QkJBS0NRSkFtQVlKSG0yQkJBSUNJckNFWkhZQVlDRTZIWXk4NkJCQUtDZkpBbUFZSkhtMkJCQUlDR3JDRVpIWUFZQ0U2SFl5ODZCQkFLQ2JKQW1BWUpISzJCQkFJQ0VaSElBSUNFNkhJeTg2QkJBS0FJSlJJU0dNQUtBSTJCTkFJMkJCSG1DSXJIWUFZQ2I2SFl5ODZCQkFLQ0ZKQUlDTkpBWUpIWTJCQkFtQ2JaSG1BbUNiNkhteTg2QkJBS0NHSkFZQW1KSG0yQkJBSTJCRkhZQ0lySFBBUENiNkhQeTg2QkJBS0NFSkFtQVBKSG0yQkJBWUNiWkhZQVlDYjZIWXk4NkJCQUtDSUpBbUFZSkhtMkJCQUkyQkdIWUNJckhQQVBDYjZIUHk4NkJCQUtDTEpBbUFQSkhtMkJCQVlDYlpIWUFZQ2I2SFl5ODZCQkFLQ0tKQW1BWUpIbTJCQkFJMkJFSFlDSXJIUEFQQ2I2SFB5ODZCQkFLQ09KQW1BUEpIbTJCQkFZQ2JaSFlBWUNiNkhZeTg2QkJBS0NOSkFtQVlKSG0yQkJBSTJCSUhZQ0lySFBBUENiNkhQeTg2QkJBS0NWSkFtQVBKSG0yQkJBWUNiWkhZQVlDYjZIWXk4NkJCQUtDY0pBbUFZSkhtMkJCQUkyQkxIWUNJckhQQVBDYjZIUHk4NkJCQUtDTUpBbUFQSkhtMkJCQVlDYlpIWUFZQ2I2SFl5ODZCQkFLQ1NKQW1BWUpIbTJCQkFJMkJLSFlDSXJIUEFQQ2I2SFB5ODZCQkFLQ1FKQW1BUEpIbTJCQkFZQ2JaSFlBWUNiNkhZeTg2QkJBS0NmSkFtQVlKSG0yQkJBSTJCT0hJQ0lySFlBWUNiNkhZeTg2QkJBS0NiSkFtQVlKSEsyQkJBSUNiWkhJQUlDYjZISXk4NkJCQUtBSUpSSVNGTUFLQUk4cEJCODNCQkFLQ05KQUlDTko4cEJCODNCQkFJQ1RKUklNQXRDR0pSdEFFQ1RKSEVBUzlKUUJNTUdYQUlRQkNCUklTRU1HWEFNOUZRQkFOQWJKMkJCUnRDQlJLQWZSRUVYQUVBTkNVL0NCSkFLSjJCQkhUQ0ZyQ0JBVENGWmw5ekF0Skh0ODZCQkFFQUdKUkVBS0NGSkhLQU05SFFCTU1BZkNGSlJmQUlSVEFiQ0ZKSGJBRzlIUUJNTUFCQWNBRzlzSkFOQ1VHSkFNQUc5c1RrVVVVQnBBTkFOQ1VHSkFNQ2FKQUc5c0pBR1RrVVVVQnBNQU1DQkFJeUFjSlJjQUlRQk1DOStSS1NGTUNCQzk5QU9BSWxBR0NBQUdDQTlMeTZ5UktNQUxDVS9FQko4a1VVVVVCQUtNK09tRlRhOGpVVVVVQkNvRmxITDhrVVVVVUJDOStSS0dYQUZDRTl1SE9DdEpBSTlMUUJDYVJLQUUyQkJITkMvd0ZaQy9nRjlIUUJBTkNiWkhWQ0Y5TFFCQUxDb0JKQ2dGQ1VGVCtKVVVVQnBBTEM4NEpoYTgzRUJBTEM4d0poYTgzRUJBTEM4b0poYTgzRUJBTENBSmhhODNFQkFMQ2lKaGE4M0VCQUxDVEpoYTgzRUJBTGhhODNFTkFMaGE4M0VCQUVBSUpDOXdKUmNBRUNGSkhOQU9KUk1HWEFGOUZRQkNRQ2JBVkNGNnlSU0FCUkVDQlJWQ0JSUUNCUmZDQlJJQ0JSS0VYR1hBTUFjdVFCQzkrUktTRU1HWEdYQU4yQkJIT0MvdkY5TFFCQUxDb0JKQU9DSXJDYTl6QUtKQ2JaQ0VXSkhiOG9HSVJUQWI4b0dCUnRHWEFPQ2JaSGJBUzlQUUJBTEFPQ2E5ekFJSkNiWkNHV0o4b0dCQVZBYnlST0FiOUZSYkdYR1hBR0NHOUhRQkFCQXQ4N0ZCQUJDSUpBTzg3RkJBQkNHSkFUODdGQlNGTUFFQXRqR0JBRUNOSkFPakdCQUVDSUpBVGpHQk1BVkFiSlJWQUxDb0JKQUtDRVdKSG1BT2pHQkFtQVRqR0lBTEFJQ0dXSkFPakdCQUxDb0JKQUtDRkpDYlpIS0NFV0pIVEF0akdCQVRBT2pHSUFJQWJKUklBS0NGSlJLU0dNR1hHWEFiQ2I2UUJBUUFiSkFiQzk4OXpKQ0ZKUlFTRk1BTTFCQkhiQ2dGWlJPR1hHWEFiQ2E5TVFCQU1DRkpSTVNGTUFNMUJGSGJDZ0JaQ09XQU9DZ0JacVJPR1hBYkNhOU1RQkFNQ0dKUk1TRk1BTTFCR0hiQ2dCWkNmV0FPcVJPR1hBYkNhOU1RQkFNQ0VKUk1TRk1BTTFCRUhiQ2dCWkNkV0FPcVJPR1hBYkNhOU1RQkFNQ0lKUk1TRk1BTTJCSUM4Y1dBT3FST0FNQ0xKUk1NQU9DRnJDQkFPQ0ZabDl6QVFKUlFNR1hHWEFHQ0c5SFFCQUJBdDg3RkJBQkNJSkFRODdGQkFCQ0dKQVQ4N0ZCU0ZNQUVBdGpHQkFFQ05KQVFqR0JBRUNJSkFUakdCTUFMQ29CSkFLQ0VXSkhPQVFqR0JBT0FUakdJQUxBSUNHV0pBUWpHQkFMQ29CSkFLQ0ZKQ2JaSEtDRVdKSE9BdGpHQkFPQVFqR0lBSUNGSlJJQUtDRkpSS1NGTUdYQU9DREY5TFFCQUxBSUFjQU9DYlpKMkJCSGJDSXJIVGxDYlpDR1dKOG9HQkFWQ0ZKSHRBVHlST0FMQUlBYmxDYlpDR1dKOG9HQkF0QVQ5RkhtSkh0QWJDYlpIVHlSYkFUOUZSVEdYR1hBR0NHOUhRQkFCQVY4N0ZCQUJDSUpBYjg3RkJBQkNHSkFPODdGQlNGTUFFQVZqR0JBRUNOSkFiakdCQUVDSUpBT2pHQk1BTEFJQ0dXSkFWakdCQUxDb0JKQUtDRVdKSFlBT2pHQkFZQVZqR0lBTEFJQ0ZKSElDYlpDR1dKQU9qR0JBTENvQkpBS0NGSkNiWkNFV0pIWUFiakdCQVlBT2pHSUFMQUlBbUpDYlpISUNHV0pBYmpHQkFMQ29CSkFLQ0dKQ2JaSEtDRVdKSE9BVmpHQkFPQWJqR0lBS0NGSlJLQUlBVEpSSUF0QVRKUlZTRk1BVkNCQU0yQkJIWXlIVEFPQy8rRjZIUEpST0FZQ2JaUnRHWEdYQVlDSXJIbVFCQU9DRkpSYlNGTUFPUmJBTEFJQW1sQ2JaQ0dXSjhvR0JST01HWEdYQXRRQkFiQ0ZKUlZTRk1BYlJWQUxBSUFZbENiWkNHV0o4b0dCUmJNR1hHWEFQOUZRQkFNQ0ZKUllTRk1BTTFCRkhZQ2dGWlJUR1hHWEFZQ2E5TVFCQU1DR0pSWVNGTUFNMUJHSFlDZ0JaQ09XQVRDZ0JacVJUR1hBWUNhOU1RQkFNQ0VKUllTRk1BTTFCRUhZQ2dCWkNmV0FUcVJUR1hBWUNhOU1RQkFNQ0lKUllTRk1BTTFCSUhZQ2dCWkNkV0FUcVJUR1hBWUNhOU1RQkFNQ0xKUllTRk1BTUNLSlJZQU0yQkxDOGNXQVRxUlRNQVRDRnJDQkFUQ0ZabDl6QVFKSFFSVE1HWEdYQW1DYjZRQkFZUlBTRk1BWTFCQkhNQ2dGWlJPR1hHWEFNQ2E5TVFCQVlDRkpSUFNGTUFZMUJGSE1DZ0JaQ09XQU9DZ0JacVJPR1hBTUNhOU1RQkFZQ0dKUlBTRk1BWTFCR0hNQ2dCWkNmV0FPcVJPR1hBTUNhOU1RQkFZQ0VKUlBTRk1BWTFCRUhNQ2dCWkNkV0FPcVJPR1hBTUNhOU1RQkFZQ0lKUlBTRk1BWUNMSlJQQVkyQklDOGNXQU9xUk9NQU9DRnJDQkFPQ0ZabDl6QVFKSFFST01HWEdYQXRDYjZRQkFQUk1TRk1BUDFCQkhNQ2dGWlJiR1hHWEFNQ2E5TVFCQVBDRkpSTVNGTUFQMUJGSE1DZ0JaQ09XQWJDZ0JacVJiR1hBTUNhOU1RQkFQQ0dKUk1TRk1BUDFCR0hNQ2dCWkNmV0FicVJiR1hBTUNhOU1RQkFQQ0VKUk1TRk1BUDFCRUhNQ2dCWkNkV0FicVJiR1hBTUNhOU1RQkFQQ0lKUk1TRk1BUENMSlJNQVAyQklDOGNXQWJxUmJNQWJDRnJDQkFiQ0ZabDl6QVFKSFFSYk1HWEdYQUdDRzlIUUJBQkFUODdGQkFCQ0lKQWI4N0ZCQUJDR0pBTzg3RkJTRk1BRUFUakdCQUVDTkpBYmpHQkFFQ0lKQU9qR0JNQUxDb0JKQUtDRVdKSFlBT2pHQkFZQVRqR0lBTEFJQ0dXSkFUakdCQUxDb0JKQUtDRkpDYlpDRVdKSFlBYmpHQkFZQU9qR0lBTEFJQ0ZKSElDYlpDR1dKQU9qR0JBTENvQkpBS0NHSkNiWkNFV0pIT0FUakdCQU9BYmpHSUFMQUlBbTlGQW1DYjZxSkhJQ2JaQ0dXSkFiakdCQUlBdDlGQXRDYjZxSlJJQUtDRUpSS01BTkNGSlJOQUJDS0pSQkFFQ1NKUkVBS0NiWlJLQUlDYlpSSUFmQ0VKSGZBRjlKUUJNTUNCQzk5QU1BYzZ5UktNQUxDb0ZKOGtVVVVVQkFLTS90SUZHYThqVVVVVUJDVGxSTEM5K1JLR1hBRkNMSkFJOUxRQkNhUktBRTJCQkMvK0ZaQy9RRjlIUUJBTGhCODNFTkFFQ0ZKUktBRUFJSkM5OEpSRUdYQUY5RlFCR1hBR0NHNlFCRVhHWEFLQUU5SlFCQzkrYk1BSzFCQkhHQ2dGWlJJR1hHWEFHQ2E5TVFCQUtDRkpSS1NGTUFLMUJGSEdDZ0JaQ09XQUlDZ0JacVJJR1hBR0NhOU1RQkFLQ0dKUktTRk1BSzFCR0hHQ2dCWkNmV0FJcVJJR1hBR0NhOU1RQkFLQ0VKUktTRk1BSzFCRUhHQ2dCWkNkV0FJcVJJR1hBR0NhOU1RQkFLQ0lKUktTRk1BSzJCSUM4Y1dBSXFSSUFLQ0xKUktNQUxDTkpBSUNGWkNHV3FIR0FJQ0dyQ0JBSUNGckNGWmw5ekFHOG9HQkpISWpHQkFCQUlqR0JBQkNJSlJCQUZDYUpIRlFCU0dNTUVYR1hBS0FFOUpRQkM5K2JNQUsxQkJIR0NnRlpSSUdYR1hBR0NhOU1RQkFLQ0ZKUktTRk1BSzFCRkhHQ2dCWkNPV0FJQ2dCWnFSSUdYQUdDYTlNUUJBS0NHSlJLU0ZNQUsxQkdIR0NnQlpDZldBSXFSSUdYQUdDYTlNUUJBS0NFSlJLU0ZNQUsxQkVIR0NnQlpDZFdBSXFSSUdYQUdDYTlNUUJBS0NJSlJLU0ZNQUsyQklDOGNXQUlxUklBS0NMSlJLTUFCQUlDR3JDQkFJQ0ZyQ0ZabDl6QUxDTkpBSUNGWkNHV3FISThvR0JKSEc4N0ZCQUlBR2pHQkFCQ0dKUkJBRkNhSkhGUUJNTUNCQzk5QUtBRTZ5UktNQUtNK2xMS0ZhRjk5R2FHOTlGYUc5OUdYR1hBR0NJOUhRQkFGOUZRRkVYR1hHWDlEQkJCOC85REJCQisvQUJDR0pIRzFCQit5QUIxQkJIRSt5SEkrTCtUQUJDRkpITDFCQkhLK3lITytMK1RITjlEQkJCQjlnSFZ5QU45REJCLytoQU5BTitVOURCQkJCQU5BVnlIY0FjK01ITUFFQ2EzeUFJK1NISUFJK1VBY0FNQUtDYTN5QU8rU0hjQWMrVStTK1MrUitWSE8rVStTSE4rTDlEQkJCOVA5ZDlGUUJBTitvUkVTRk1DVVVVVTk0UkVNQUdBRTg2QkJHWEdYOURCQkI4LzlEQkJCKy9BYzlEQkJCQjlneUFjQU8rVStTSE4rTDlEQkJCOVA5ZDlGUUJBTitvUkdTRk1DVVVVVTk0UkdNQUxBRzg2QkJHWEdYOURCQkI4LzlEQkJCKy9BSTlEQkJCQjlneUFJQU8rVStTSE4rTDlEQkJCOVA5ZDlGUUJBTitvUkdTRk1DVVVVVTk0UkdNQUJBRzg2QkJBQkNJSlJCQUZDYUpIRlFCU0dNTUFGOUZRQkVYR1hHWDlEQkJCOC85REJCQisvQUJDSUpIRzh1RkIreUFCOHVGQkhFK3lISStMK1RBQkNHSkhMOHVGQkhLK3lITytMK1RITjlEQkJCQjlnSFZ5QU45REIvK2c2QU5BTitVOURCQkJCQU5BVnlIY0FjK01ITUFFQ2EzeUFJK1NISUFJK1VBY0FNQUtDYTN5QU8rU0hjQWMrVStTK1MrUitWSE8rVStTSE4rTDlEQkJCOVA5ZDlGUUJBTitvUkVTRk1DVVVVVTk0UkVNQUdBRTg3RkJHWEdYOURCQkI4LzlEQkJCKy9BYzlEQkJCQjlneUFjQU8rVStTSE4rTDlEQkJCOVA5ZDlGUUJBTitvUkdTRk1DVVVVVTk0UkdNQUxBRzg3RkJHWEdYOURCQkI4LzlEQkJCKy9BSTlEQkJCQjlneUFJQU8rVStTSE4rTDlEQkJCOVA5ZDlGUUJBTitvUkdTRk1DVVVVVTk0UkdNQUJBRzg3RkJBQkNOSlJCQUZDYUpIRlFCTU1NL1NFSUVhRTk5RWFGOTlHWEFGOUZRQkNCUkVBQlJJRVhHWEdYOUQvekk4MTgvQUlDS0o4dUZCSExDRXEreStWSEtBSTh1RkIreStVSE85REIvK2c2K1U5REJCQjgvOURCQkIrL0FPOURCQkJCOWd5K1NITitMOURCQkI5UDlkOUZRQkFOK29SVlNGTUNVVVVVOTRSVk1BSUNJSjh1RkJSY0FJQ0dKOHVGQlJNQUJBTENGSkNFWkFFcUNGV0pBVjg3RkJHWEdYQUtBTSt5K1VITjlEQi8rZzYrVTlEQkJCOC85REJCQisvQU45REJCQkI5Z3krU0hTK0w5REJCQjlQOWQ5RlFCQVMrb1JNU0ZNQ1VVVVU5NFJNTUFCQUxDR0pDRVpBRXFDRldKQU04N0ZCR1hHWEFLQWMreStVSEs5REIvK2c2K1U5REJCQjgvOURCQkIrL0FLOURCQkJCOWd5K1NIUytMOURCQkI5UDlkOUZRQkFTK29SY1NGTUNVVVVVOTRSY01BQkFMQ2FKQ0VaQUVxQ0ZXSkFjODdGQkdYR1g5REJCVTgvQU9BTytVK1RBTkFOK1UrVEFLQUsrVStUSE85REJCQkJBTzlEQkJCQjlneStSOURCLytnNitVOURCQkI4LytTSE8rTDlEQkJCOVA5ZDlGUUJBTytvUmNTRk1DVVVVVTk0UmNNQUJBTENFWkFFcUNGV0pBYzg3RkJBSUNOSlJJQUVDSUpSRUFGQ2FKSEZRQk1NTTlKQkdYQUdDR3JBRjlzSEY5RlFCRVhBQkFCOG9HQkhHQ05XQ045MSt5QUdDaTkxQ25XQ1VVVS84RUorKytVODRHQkFCQ0lKUkJBRkNhSkhGUUJNTU05VEZFYUNCQ0I4b0dVa1VVQkhGQUJDRUpDOThaSkhCakdVa1VVQkdYR1hBQjgvQkNUV0hHdVFCQ2FSRUFCQUdsQ2dnRUpDVHJYQkNhNlFGTUFGUkVNQUVNL2xGRkZhR1hHWEFGQUJxQ0VaOUZRQkFCUkVTRk1HWEdYQUdDVDlQUUJBQlJFU0ZNQUJSRUVYQUVBRjhvR0JqR0JBRUNJSkFGQ0lKOG9HQmpHQkFFQ05KQUZDTko4b0dCakdCQUVDU0pBRkNTSjhvR0JqR0JBRUNUSlJFQUZDVEpSRkFHQzl3SkhHQ2I5TFFCTU1BR0NJOUpRQkVYQUVBRjhvR0JqR0JBRkNJSlJGQUVDSUpSRUFHQzk4SkhHQ0U5TFFCTU1HWEFHOUZRQkVYQUVBRjJCQjg2QkJBRUNGSlJFQUZDRkpSRkFHQ2FKSEdRQk1NQUJNb0ZGR2FHWEdYQUJDRVo5RlFCQUJSRVNGTUFGQ2dGWkMrQndzTjlzUklHWEdYQUdDVDlQUUJBQlJFU0ZNQUJSRUVYQUVBSWpHQkFFQ1NKQUlqR0JBRUNOSkFJakdCQUVDSUpBSWpHQkFFQ1RKUkVBR0M5d0pIR0NiOUxRQk1NQUdDSTlKUUJFWEFFQUlqR0JBRUNJSlJFQUdDOThKSEdDRTlMUUJNTUdYQUc5RlFCRVhBRUFGODZCQkFFQ0ZKUkVBR0NhSkhHUUJNTUFCTU1NRkJDVU5NSVQ5a0JCJztcbmNvbnN0IHdhc21fc2ltZCA9ICdCOWg5ejl0RkJCQkY4ZEw5Z0JCOWdMYWFhYWFGYTlnRWFhYUI5Z0dhYUI5Z0ZhRmFFUVNCQkZCRkZHRUdFR0lJTEY5d0ZGRkxFRkJGS05GYUZDeC9hRk1PL0xGVks5dHY5dDl2cTk1R0J0OWY5ZjkzOWg5ejl0OWY5ajloOXM5czlmOWpXOXZxOXpCQnA5dHY5ejlvOXY5d1c5ZjlrdjlqOXY5a3Y5V3ZxV3Y5NGg5MTltOW12cUJHOFo5dHY5ejlvOXY5d1c5ZjlrdjlqOXY5a3Y5Sjl1OWt2OTRoOTE5bTltdnFCSXk5dHY5ejlvOXY5d1c5ZjlrdjlqOXY5a3Y5Sjl1OWt2OTQ5VHZaOTF2OXU5anZCTG45dHY5ejlvOXY5d1c5ZjlrdjlqOXY5a3Y2OXA5c1d2cTlQOWpXQktpOXR2OXo5bzl2OXdXOWY5a3Y5ajl2OWt2NjlwOXNXdnE5UjkxOWhXQk5uOXR2OXo5bzl2OXdXOWY5a3Y5ajl2OWt2NjlwOXNXdnE5Rjk0OXdCY0k5ejlpcWxCTWMvajlKU0lCVEVNOStGTGE4alVVVVVCQ1RsUkJDQlJGRVhDQlJHQ0JSRUVYQUJDTkpBR0pBRUNVYUFGQUdyQ0ZaSEl5ODZCQkFFQUlKUkVBR0NGSkhHQ045SFFCTUFGQ3grWVVVQkpBRTg2QkJBRkNFV0N4a1VVQkpBQjhwRU44M0VCQUZDRkpIRkNVRzlIUUJNTWtSSWJhRzk3RmFLOTc4alVVVVVCQ1UvS0JsSEw4a1VVVVVCQzkrUktHWEFHQ0ZKQUk5TFFCQ2FSS0FFMkJCQytnRjlIUUJBTEFFQUlKSE9BR2xBRy84Y0JCQ1VvQkFHOXVDL3dnQlpIS0NVR0FLQ1VHOUp5Uk5BRUNGSlJLQ0JSVkdYRVhBVkFGOVBRRkFOQUZBVmxBVkFOSkFGOUp5UmNHWEdYQUc5RlFCQWNDYkpISUM5d1pITUNFOXNSU0FNQ0ZXUlFBSUNJckNFSkNHclJmQ0JSYkVYQUtSVENCUnRHWEVYR1hBT0FUbEFmOVBRQkNCUktTTE1BTENVL0NCSkF0QU05c0pSbUFUQWZKUktDQlJFR1hBTUNvQjlKUUJBT0FLbEMvZ0I5SlFCQ0JSSUVYQW1BSUpSRUdYR1hHWEdYR1hBVEFJQ0tySjJCQkhZQ0VaZklCRkdFQk1BRUNCRHRETUlCU0VNQUVBS0RCQklBS0RCQkJIUENJRCtNRkFQRFFCVEZ0R21FWUlQTGRLZU9uSFBDR0QrTUZBUERRQlRGdEdtRVlJUExkS2VPbkMwK0crTWlEdEQ5T0hkQ0VEYkQ4akhQRDhkQmhVZy84LzQvdy9nb0I5K2g4NGs3SGVDRVdDeGtVVUJKREJFQkFlQ3grWVVVQkpEQkJCSG5BbkRRQkJCQkJCQkJCQkJCQkJCQkFQRDhkRmhVZy84LzQvdy9nb0I5K2g4NGs3SGVDRVdDeGtVVUJKREJFQkQ5dURRQkZHRUlMS09UdG1ZUGRlbkRmQWRBUEQ5U0RNSUJBS0NJSkFuRGVCSkFlQ3grWVVVQkoyQkJKUktTR01BRUFLREJCTkFLREJCQkhQQ0lEK01GQVBEUUJURnRHbUVZSVBMZEtlT25DK1ArZSs4LzRCRHREOU9IZENiRGJEOGpIUEQ4ZEJoVWcvOC80L3cvZ29COStoODRrN0hlQ0VXQ3hrVVVCSkRCRUJBZUN4K1lVVUJKREJCQkhuQW5EUUJCQkJCQkJCQkJCQkJCQkJBUEQ4ZEZoVWcvOC80L3cvZ29COStoODRrN0hlQ0VXQ3hrVVVCSkRCRUJEOXVEUUJGR0VJTEtPVHRtWVBkZW5EZkFkQVBEOVNETUlCQUtDTkpBbkRlQkpBZUN4K1lVVUJKMkJCSlJLU0ZNQUVBS0RCQkJETUlCQUtDVEpSS01HWEdYR1hHWEdYQVlDR3JDRVpmSUJGR0VCTUFFQ0JEdERNSVRTRU1BRUFLREJCSUFLREJCQkhQQ0lEK01GQVBEUUJURnRHbUVZSVBMZEtlT25IUENHRCtNRkFQRFFCVEZ0R21FWUlQTGRLZU9uQzArRytNaUR0RDlPSGRDRURiRDhqSFBEOGRCaFVnLzgvNC93L2dvQjkraDg0azdIZUNFV0N4a1VVQkpEQkVCQWVDeCtZVVVCSkRCQkJIbkFuRFFCQkJCQkJCQkJCQkJCQkJCQVBEOGRGaFVnLzgvNC93L2dvQjkraDg0azdIZUNFV0N4a1VVQkpEQkVCRDl1RFFCRkdFSUxLT1R0bVlQZGVuRGZBZEFQRDlTRE1JVEFLQ0lKQW5EZUJKQWVDeCtZVVVCSjJCQkpSS1NHTUFFQUtEQkJOQUtEQkJCSFBDSUQrTUZBUERRQlRGdEdtRVlJUExkS2VPbkMrUCtlKzgvNEJEdEQ5T0hkQ2JEYkQ4akhQRDhkQmhVZy84LzQvdy9nb0I5K2g4NGs3SGVDRVdDeGtVVUJKREJFQkFlQ3grWVVVQkpEQkJCSG5BbkRRQkJCQkJCQkJCQkJCQkJCQkFQRDhkRmhVZy84LzQvdy9nb0I5K2g4NGs3SGVDRVdDeGtVVUJKREJFQkQ5dURRQkZHRUlMS09UdG1ZUGRlbkRmQWRBUEQ5U0RNSVRBS0NOSkFuRGVCSkFlQ3grWVVVQkoyQkJKUktTRk1BRUFLREJCQkRNSVRBS0NUSlJLTUdYR1hHWEdYR1hBWUNJckNFWmZJQkZHRUJNQUVDQkR0RE1JQVNFTUFFQUtEQkJJQUtEQkJCSFBDSUQrTUZBUERRQlRGdEdtRVlJUExkS2VPbkhQQ0dEK01GQVBEUUJURnRHbUVZSVBMZEtlT25DMCtHK01pRHREOU9IZENFRGJEOGpIUEQ4ZEJoVWcvOC80L3cvZ29COStoODRrN0hlQ0VXQ3hrVVVCSkRCRUJBZUN4K1lVVUJKREJCQkhuQW5EUUJCQkJCQkJCQkJCQkJCQkJBUEQ4ZEZoVWcvOC80L3cvZ29COStoODRrN0hlQ0VXQ3hrVVVCSkRCRUJEOXVEUUJGR0VJTEtPVHRtWVBkZW5EZkFkQVBEOVNETUlBQUtDSUpBbkRlQkpBZUN4K1lVVUJKMkJCSlJLU0dNQUVBS0RCQk5BS0RCQkJIUENJRCtNRkFQRFFCVEZ0R21FWUlQTGRLZU9uQytQK2UrOC80QkR0RDlPSGRDYkRiRDhqSFBEOGRCaFVnLzgvNC93L2dvQjkraDg0azdIZUNFV0N4a1VVQkpEQkVCQWVDeCtZVVVCSkRCQkJIbkFuRFFCQkJCQkJCQkJCQkJCQkJCQVBEOGRGaFVnLzgvNC93L2dvQjkraDg0azdIZUNFV0N4a1VVQkpEQkVCRDl1RFFCRkdFSUxLT1R0bVlQZGVuRGZBZEFQRDlTRE1JQUFLQ05KQW5EZUJKQWVDeCtZVVVCSjJCQkpSS1NGTUFFQUtEQkJCRE1JQUFLQ1RKUktNR1hHWEdYR1hHWEFZQ0tyZklCRkdFQk1BRUNCRHRETUk4d1NFTUFFQUtEQkJJQUtEQkJCSFBDSUQrTUZBUERRQlRGdEdtRVlJUExkS2VPbkhQQ0dEK01GQVBEUUJURnRHbUVZSVBMZEtlT25DMCtHK01pRHREOU9IZENFRGJEOGpIUEQ4ZEJoVWcvOC80L3cvZ29COStoODRrN0hZQ0VXQ3hrVVVCSkRCRUJBWUN4K1lVVUJKREJCQkhuQW5EUUJCQkJCQkJCQkJCQkJCQkJBUEQ4ZEZoVWcvOC80L3cvZ29COStoODRrN0hZQ0VXQ3hrVVVCSkRCRUJEOXVEUUJGR0VJTEtPVHRtWVBkZW5EZkFkQVBEOVNETUk4d0FLQ0lKQW5EZUJKQVlDeCtZVVVCSjJCQkpSS1NHTUFFQUtEQkJOQUtEQkJCSFBDSUQrTUZBUERRQlRGdEdtRVlJUExkS2VPbkMrUCtlKzgvNEJEdEQ5T0hkQ2JEYkQ4akhQRDhkQmhVZy84LzQvdy9nb0I5K2g4NGs3SFlDRVdDeGtVVUJKREJFQkFZQ3grWVVVQkpEQkJCSG5BbkRRQkJCQkJCQkJCQkJCQkJCQkFQRDhkRmhVZy84LzQvdy9nb0I5K2g4NGs3SFlDRVdDeGtVVUJKREJFQkQ5dURRQkZHRUlMS09UdG1ZUGRlbkRmQWRBUEQ5U0RNSTh3QUtDTkpBbkRlQkpBWUN4K1lVVUJKMkJCSlJLU0ZNQUVBS0RCQkJETUk4d0FLQ1RKUktNQUlDb0JKUkVBSUNVRkpBTTlMUUZBRVJJQU9BS2xDL2ZCOUxRQk1NR1hBRUFNOVBRQkFFQ0VyUklFWEdYQU9BS2xDaTlQUUJDQlJLU09NQW1BRUpSWUdYR1hHWEdYR1hBVEFFQ0tySjJCQkFJQ0tackNFWmZJQkZHRUJNQVlDQkR0RE1JQlNFTUFZQUtEQkJJQUtEQkJCSFBDSUQrTUZBUERRQlRGdEdtRVlJUExkS2VPbkhQQ0dEK01GQVBEUUJURnRHbUVZSVBMZEtlT25DMCtHK01pRHREOU9IZENFRGJEOGpIUEQ4ZEJoVWcvOC80L3cvZ29COStoODRrN0hlQ0VXQ3hrVVVCSkRCRUJBZUN4K1lVVUJKREJCQkhuQW5EUUJCQkJCQkJCQkJCQkJCQkJBUEQ4ZEZoVWcvOC80L3cvZ29COStoODRrN0hlQ0VXQ3hrVVVCSkRCRUJEOXVEUUJGR0VJTEtPVHRtWVBkZW5EZkFkQVBEOVNETUlCQUtDSUpBbkRlQkpBZUN4K1lVVUJKMkJCSlJLU0dNQVlBS0RCQk5BS0RCQkJIUENJRCtNRkFQRFFCVEZ0R21FWUlQTGRLZU9uQytQK2UrOC80QkR0RDlPSGRDYkRiRDhqSFBEOGRCaFVnLzgvNC93L2dvQjkraDg0azdIZUNFV0N4a1VVQkpEQkVCQWVDeCtZVVVCSkRCQkJIbkFuRFFCQkJCQkJCQkJCQkJCQkJCQVBEOGRGaFVnLzgvNC93L2dvQjkraDg0azdIZUNFV0N4a1VVQkpEQkVCRDl1RFFCRkdFSUxLT1R0bVlQZGVuRGZBZEFQRDlTRE1JQkFLQ05KQW5EZUJKQWVDeCtZVVVCSjJCQkpSS1NGTUFZQUtEQkJCRE1JQkFLQ1RKUktNQUlDR0pSSUFFQ1RKSEVBTTlKUUJNTUdYQUs5RlFCQUtSVEF0Q0ZKSHRDSTZRR1NGTU1DQlJLU0VNR1hBTTlGUUJBTENVR0pBYkpSRUFMQWJKREJHQlJuQ0JSWUVYQUVBTENVL0NCSkFZSkhJREJJQkhkQ0ZEOXRBZENGRGJIUEQ5T0Q5aEQ5UkhkQUlBTUpEQklCSGlDRkQ5dEFpQVBEOU9EOWhEOVJIaURRQlRGdEdtRVlJUExkS2VPbkg4WkFJQVFKREJJQkhwQ0ZEOXRBcEFQRDlPRDloRDlSSHBBSUFTSkRCSUJIeUNGRDl0QXlBUEQ5T0Q5aEQ5Ukh5RFFCVEZ0R21FWUlQTGRLZU9uSDhjRFFCRlR0R0VtWUlMUGRLT2VuSFBBUERRQkZHRUJGR0VCRkdFQkZHRUFuRDl1SG5EeUJqR0JBRUFHSkhJQW5BUEFQRFFJTEtPSUxLT0lMS09JTEtPRDl1SG5EeUJqR0JBSUFHSkhJQW5BUEFQRFFOVmNNTlZjTU5WY01OVmNNRDl1SG5EeUJqR0JBSUFHSkhJQW5BUEFQRFFTUWZiU1FmYlNRZmJTUWZiRDl1SG5EeUJqR0JBSUFHSkhJQW5BOFpBOGNEUU5WaThaY01weVNROGM4ZGZiOGU4ZkhQQVBEUUJGR0VCRkdFQkZHRUJGR0VEOXVIbkR5QmpHQkFJQUdKSElBbkFQQVBEUUlMS09JTEtPSUxLT0lMS09EOXVIbkR5QmpHQkFJQUdKSElBbkFQQVBEUU5WY01OVmNNTlZjTU5WY01EOXVIbkR5QmpHQkFJQUdKSElBbkFQQVBEUVNRZmJTUWZiU1FmYlNRZmJEOXVIbkR5QmpHQkFJQUdKSElBbkFkQWlEUU5pVjhaY3BNeVM4Y1E4ZGY4ZWI4ZkhkQXBBeURRTmlWOFpjcE15UzhjUThkZjhlYjhmSGlEUUJGVHRHRW1ZSUxQZEtPZW5IUEFQRFFCRkdFQkZHRUJGR0VCRkdFRDl1SG5EeUJqR0JBSUFHSkhJQW5BUEFQRFFJTEtPSUxLT0lMS09JTEtPRDl1SG5EeUJqR0JBSUFHSkhJQW5BUEFQRFFOVmNNTlZjTU5WY01OVmNNRDl1SG5EeUJqR0JBSUFHSkhJQW5BUEFQRFFTUWZiU1FmYlNRZmJTUWZiRDl1SG5EeUJqR0JBSUFHSkhJQW5BZEFpRFFOVmk4WmNNcHlTUThjOGRmYjhlOGZIUEFQRFFCRkdFQkZHRUJGR0VCRkdFRDl1SG5EeUJqR0JBSUFHSkhJQW5BUEFQRFFJTEtPSUxLT0lMS09JTEtPRDl1SG5EeUJqR0JBSUFHSkhJQW5BUEFQRFFOVmNNTlZjTU5WY01OVmNNRDl1SG5EeUJqR0JBSUFHSkhJQW5BUEFQRFFTUWZiU1FmYlNRZmJTUWZiRDl1SG5EeUJqR0JBSUFHSlJFQVlDVEpIWUFNOUpRQk1NQWJDSUpIYkFHOUpRQk1NQUJBVkFHOXNKQUxDVUdKQWNBRzlzLzhjQkJBTEFMQ1VHSkFjQ2FKQUc5c0pBRy84Y0JCTUFjQ0JBS3lBVkpSVkFLUUJNQzkrUktTRk1DQkM5OUFPQUtsQUdDQUFHQ0E5THk2eVJLTUFMQ1UvS0JKOGtVVVVVQkFLTU5CVCtCVVVVQk0rS21GVGE4alVVVVVCQ29GbEhMOGtVVVVVQkM5K1JLR1hBRkNFOXVIT0N0SkFJOUxRQkNhUktBRTJCQkhOQy93RlpDL2dGOUhRQkFOQ2JaSFZDRjlMUUJBTENvQkpDZ0ZDVUYvOE1CQUxDODRKaGE4M0VCQUxDOHdKaGE4M0VCQUxDOG9KaGE4M0VCQUxDQUpoYTgzRUJBTENpSmhhODNFQkFMQ1RKaGE4M0VCQUxoYTgzRU5BTGhhODNFQkFFQUlKQzl3SlJjQUVDRkpITkFPSlJNR1hBRjlGUUJDUUNiQVZDRjZ5UlNBQlJFQ0JSVkNCUlFDQlJmQ0JSSUNCUktFWEdYQU1BY3VRQkM5K1JLU0VNR1hHWEFOMkJCSE9DL3ZGOUxRQkFMQ29CSkFPQ0lyQ2E5ekFLSkNiWkNFV0pIYjhvR0lSVEFiOG9HQlJ0R1hBT0NiWkhiQVM5UFFCQUxBT0NhOXpBSUpDYlpDR1dKOG9HQkFWQWJ5Uk9BYjlGUmJHWEdYQUdDRzlIUUJBQkF0ODdGQkFCQ0lKQU84N0ZCQUJDR0pBVDg3RkJTRk1BRUF0akdCQUVDTkpBT2pHQkFFQ0lKQVRqR0JNQVZBYkpSVkFMQ29CSkFLQ0VXSkhtQU9qR0JBbUFUakdJQUxBSUNHV0pBT2pHQkFMQ29CSkFLQ0ZKQ2JaSEtDRVdKSFRBdGpHQkFUQU9qR0lBSUFiSlJJQUtDRkpSS1NHTUdYR1hBYkNiNlFCQVFBYkpBYkM5ODl6SkNGSlJRU0ZNQU0xQkJIYkNnRlpST0dYR1hBYkNhOU1RQkFNQ0ZKUk1TRk1BTTFCRkhiQ2dCWkNPV0FPQ2dCWnFST0dYQWJDYTlNUUJBTUNHSlJNU0ZNQU0xQkdIYkNnQlpDZldBT3FST0dYQWJDYTlNUUJBTUNFSlJNU0ZNQU0xQkVIYkNnQlpDZFdBT3FST0dYQWJDYTlNUUJBTUNJSlJNU0ZNQU0yQklDOGNXQU9xUk9BTUNMSlJNTUFPQ0ZyQ0JBT0NGWmw5ekFRSlJRTUdYR1hBR0NHOUhRQkFCQXQ4N0ZCQUJDSUpBUTg3RkJBQkNHSkFUODdGQlNGTUFFQXRqR0JBRUNOSkFRakdCQUVDSUpBVGpHQk1BTENvQkpBS0NFV0pIT0FRakdCQU9BVGpHSUFMQUlDR1dKQVFqR0JBTENvQkpBS0NGSkNiWkhLQ0VXSkhPQXRqR0JBT0FRakdJQUlDRkpSSUFLQ0ZKUktTRk1HWEFPQ0RGOUxRQkFMQUlBY0FPQ2JaSjJCQkhiQ0lySFRsQ2JaQ0dXSjhvR0JBVkNGSkh0QVR5Uk9BTEFJQWJsQ2JaQ0dXSjhvR0JBdEFUOUZIbUpIdEFiQ2JaSFR5UmJBVDlGUlRHWEdYQUdDRzlIUUJBQkFWODdGQkFCQ0lKQWI4N0ZCQUJDR0pBTzg3RkJTRk1BRUFWakdCQUVDTkpBYmpHQkFFQ0lKQU9qR0JNQUxBSUNHV0pBVmpHQkFMQ29CSkFLQ0VXSkhZQU9qR0JBWUFWakdJQUxBSUNGSkhJQ2JaQ0dXSkFPakdCQUxDb0JKQUtDRkpDYlpDRVdKSFlBYmpHQkFZQU9qR0lBTEFJQW1KQ2JaSElDR1dKQWJqR0JBTENvQkpBS0NHSkNiWkhLQ0VXSkhPQVZqR0JBT0FiakdJQUtDRkpSS0FJQVRKUklBdEFUSlJWU0ZNQVZDQkFNMkJCSFl5SFRBT0MvK0Y2SFBKUk9BWUNiWlJ0R1hHWEFZQ0lySG1RQkFPQ0ZKUmJTRk1BT1JiQUxBSUFtbENiWkNHV0o4b0dCUk9NR1hHWEF0UUJBYkNGSlJWU0ZNQWJSVkFMQUlBWWxDYlpDR1dKOG9HQlJiTUdYR1hBUDlGUUJBTUNGSlJZU0ZNQU0xQkZIWUNnRlpSVEdYR1hBWUNhOU1RQkFNQ0dKUllTRk1BTTFCR0hZQ2dCWkNPV0FUQ2dCWnFSVEdYQVlDYTlNUUJBTUNFSlJZU0ZNQU0xQkVIWUNnQlpDZldBVHFSVEdYQVlDYTlNUUJBTUNJSlJZU0ZNQU0xQklIWUNnQlpDZFdBVHFSVEdYQVlDYTlNUUJBTUNMSlJZU0ZNQU1DS0pSWUFNMkJMQzhjV0FUcVJUTUFUQ0ZyQ0JBVENGWmw5ekFRSkhRUlRNR1hHWEFtQ2I2UUJBWVJQU0ZNQVkxQkJITUNnRlpST0dYR1hBTUNhOU1RQkFZQ0ZKUlBTRk1BWTFCRkhNQ2dCWkNPV0FPQ2dCWnFST0dYQU1DYTlNUUJBWUNHSlJQU0ZNQVkxQkdITUNnQlpDZldBT3FST0dYQU1DYTlNUUJBWUNFSlJQU0ZNQVkxQkVITUNnQlpDZFdBT3FST0dYQU1DYTlNUUJBWUNJSlJQU0ZNQVlDTEpSUEFZMkJJQzhjV0FPcVJPTUFPQ0ZyQ0JBT0NGWmw5ekFRSkhRUk9NR1hHWEF0Q2I2UUJBUFJNU0ZNQVAxQkJITUNnRlpSYkdYR1hBTUNhOU1RQkFQQ0ZKUk1TRk1BUDFCRkhNQ2dCWkNPV0FiQ2dCWnFSYkdYQU1DYTlNUUJBUENHSlJNU0ZNQVAxQkdITUNnQlpDZldBYnFSYkdYQU1DYTlNUUJBUENFSlJNU0ZNQVAxQkVITUNnQlpDZFdBYnFSYkdYQU1DYTlNUUJBUENJSlJNU0ZNQVBDTEpSTUFQMkJJQzhjV0FicVJiTUFiQ0ZyQ0JBYkNGWmw5ekFRSkhRUmJNR1hHWEFHQ0c5SFFCQUJBVDg3RkJBQkNJSkFiODdGQkFCQ0dKQU84N0ZCU0ZNQUVBVGpHQkFFQ05KQWJqR0JBRUNJSkFPakdCTUFMQ29CSkFLQ0VXSkhZQU9qR0JBWUFUakdJQUxBSUNHV0pBVGpHQkFMQ29CSkFLQ0ZKQ2JaQ0VXSkhZQWJqR0JBWUFPakdJQUxBSUNGSkhJQ2JaQ0dXSkFPakdCQUxDb0JKQUtDR0pDYlpDRVdKSE9BVGpHQkFPQWJqR0lBTEFJQW05RkFtQ2I2cUpISUNiWkNHV0pBYmpHQkFJQXQ5RkF0Q2I2cUpSSUFLQ0VKUktNQU5DRkpSTkFCQ0tKUkJBRUNTSlJFQUtDYlpSS0FJQ2JaUklBZkNFSkhmQUY5SlFCTU1DQkM5OUFNQWM2eVJLTUFMQ29GSjhrVVVVVUJBS00vdElGR2E4alVVVVVCQ1RsUkxDOStSS0dYQUZDTEpBSTlMUUJDYVJLQUUyQkJDLytGWkMvUUY5SFFCQUxoQjgzRU5BRUNGSlJLQUVBSUpDOThKUkVHWEFGOUZRQkdYQUdDRzZRQkVYR1hBS0FFOUpRQkM5K2JNQUsxQkJIR0NnRlpSSUdYR1hBR0NhOU1RQkFLQ0ZKUktTRk1BSzFCRkhHQ2dCWkNPV0FJQ2dCWnFSSUdYQUdDYTlNUUJBS0NHSlJLU0ZNQUsxQkdIR0NnQlpDZldBSXFSSUdYQUdDYTlNUUJBS0NFSlJLU0ZNQUsxQkVIR0NnQlpDZFdBSXFSSUdYQUdDYTlNUUJBS0NJSlJLU0ZNQUsyQklDOGNXQUlxUklBS0NMSlJLTUFMQ05KQUlDRlpDR1dxSEdBSUNHckNCQUlDRnJDRlpsOXpBRzhvR0JKSElqR0JBQkFJakdCQUJDSUpSQkFGQ2FKSEZRQlNHTU1FWEdYQUtBRTlKUUJDOStiTUFLMUJCSEdDZ0ZaUklHWEdYQUdDYTlNUUJBS0NGSlJLU0ZNQUsxQkZIR0NnQlpDT1dBSUNnQlpxUklHWEFHQ2E5TVFCQUtDR0pSS1NGTUFLMUJHSEdDZ0JaQ2ZXQUlxUklHWEFHQ2E5TVFCQUtDRUpSS1NGTUFLMUJFSEdDZ0JaQ2RXQUlxUklHWEFHQ2E5TVFCQUtDSUpSS1NGTUFLMkJJQzhjV0FJcVJJQUtDTEpSS01BQkFJQ0dyQ0JBSUNGckNGWmw5ekFMQ05KQUlDRlpDR1dxSEk4b0dCSkhHODdGQkFJQUdqR0JBQkNHSlJCQUZDYUpIRlFCTU1DQkM5OUFLQUU2eVJLTUFLTS94TEdFYUs5NzhqVVVVVUJDQWxIRThrVVVVVUJHWEdYQUdDSTlIUUJHWEFGQzk4WkhJOUZRQkFCUkdDQlJMRVhBR0FHREJCQkhLQ2lEK3JGQ2lEK3NGRC82RkhPQUtDTkQrckZDaUQrc0ZELzZGQU9EL2dGQUtDVEQrckZDaUQrc0ZELzZGSE5EL2dGRC9rRkQvbEZIVkNCRHREKzJGSGNBT0NVVVVVOTREdEhNRDlPRDlSRC9rRkhPOURCQi8raERZQU9BT0QvbUZBVkFWRC9tRkFOQWNBTkFNRDlPRDlSRC9rRkhPQU9EL21GRC9rRkQva0ZEL2pGRC9uRkhORC9tRjlEQkJYOUxEWUhjRC9rRkNnRkR0RDlPQUtDVVVVOTREdEQ5T0Q5UUFPQU5EL21GQWNEL2tGQ05EK3JGQ1UvK0VEdEQ5T0Q5UUFWQU5EL21GQWNEL2tGQ1REK3JGQ1VVLzhPRHREOU9EOVFETUJCQUdDVEpSR0FMQ0lKSExBSTlKUUJNTUFJQUY5UFFGQUVBRkNFWkhMQ0dXSEdxQ0JDVEFHbC84TUJBRUFCQUlDR1dKSElBRy84Y0JCR1hBTDlGUUJBRUFFREJJQkhLQ2lEK3JGQ2lEK3NGRC82RkhPQUtDTkQrckZDaUQrc0ZELzZGQU9EL2dGQUtDVEQrckZDaUQrc0ZELzZGSE5EL2dGRC9rRkQvbEZIVkNCRHREKzJGSGNBT0NVVVVVOTREdEhNRDlPRDlSRC9rRkhPOURCQi8raERZQU9BT0QvbUZBVkFWRC9tRkFOQWNBTkFNRDlPRDlSRC9rRkhPQU9EL21GRC9rRkQva0ZEL2pGRC9uRkhORC9tRjlEQkJYOUxEWUhjRC9rRkNnRkR0RDlPQUtDVVVVOTREdEQ5T0Q5UUFPQU5EL21GQWNEL2tGQ05EK3JGQ1UvK0VEdEQ5T0Q5UUFWQU5EL21GQWNEL2tGQ1REK3JGQ1VVLzhPRHREOU9EOVFETUlCTUFJQUVBRy84Y0JCU0ZNQUJBRkM5OFpIR1QrSFVVVUJBR0FGOVBRQkFFQUZDRVpISUNFV0hMSkNCQ0FBTGwvOE1CQUVBQkFHQ0VXSkhHQUwvOGNCQkFFQUlUK0hVVVVCQUdBRUFMLzhjQkJNQUVDQUo4a1VVVVVCTSt5RUdHYU85N0dYQUY5RlFCQ0JSR0VYQUJDVEpIRUFFREJCQkhJQ0JEdEhMQ1VVOThEOGNGQ1VVOThEOGNFSEtEOU9BQkRCQkJIT0FJRFFJTEtPU1FmYlBkZW44YzhkOGU4ZkNnZ0ZEdEQ5T0QvNkZBT0FJRFFCRkdFTlZjTVR0bVlpOFpweUhJQ1REK3NGRC82RkhORC9nRkFJQ1REK3JGQ1REK3NGRC82RkhWRC9nRkQva0ZEL2xGSEk5REIvK2c2RFlBVkFJQUxEKzJGSExBVkNVVVVVOTREdEhjRDlPRDlSRC9rRkhWQVZEL21GQUlBSUQvbUZBTkFMQU5BY0Q5T0Q5UkQva0ZISUFJRC9tRkQva0ZEL2tGRC9qRkQvbkZITkQvbUY5REJCWDlMRFlITEQva0ZDVEQrckZBVkFORC9tRkFMRC9rRkNnZ0VEdEQ5T0Q5UUhWQUlBTkQvbUZBTEQva0ZDYURiQ0JEbkdDQkRuRUNCRG5LQ0JEbk9DQkRuY0NCRG5NQ0JEbmZDQkRuYkQ5T0hJRFFOVmk4WmNNcHlTUThjOGRmYjhlOGZEOVFETUJCQUJBT0FLRDlPQVZBSURRQkZUdEdFbVlJTFBkS09lbkQ5UURNQkJBQkNBSlJCQUdDSUpIR0FGOUpRQk1NTTk0RkVhOGpVVVVVQkNBbEhFOGtVVVVVQkFCQUZDOThaSElUK0pVVVVCR1hBSUFGOVBRQkFFQUZDRVpITENFV0hGSkNCQ0FBRmwvOE1CQUVBQkFJQ0VXSkhCQUYvOGNCQkFFQUxUK0pVVVVCQUJBRUFGLzhjQkJNQUVDQUo4a1VVVVVCTS9oRUlHYUY5N0ZhTDk3OGpVVVVVQkNUbFJHR1hBRjlGUUJDQlJFRVhBR0FCREJCQkhJQUJDVEpITERCQkJIS0RRSUxLT1NRZmJQZGVuOGM4ZDhlOGZIT0NURCtzRkhOQ0lEK3JGRE1JQkFCOURCQlU4L0RZOUQvekk4MTgvRFlBTkNFRHREOVFELzZGRC9uRkhOQUlBS0RRQkZHRU5WY01UdG1ZaThacHlISUNURCtyRkNURCtzRkQvNkZEL21GSEtBS0QvbUZBTkFJQ1REK3NGRC82RkQvbUZIVkFWRC9tRkFOQU9DVEQrckZDVEQrc0ZELzZGRC9tRkhPQU9EL21GRC9rRkQva0ZEL2xGQ0JEdEQrNEZEL2pGOURCLytnNkRZSE5EL21GOURCQlg5TERZSElEL2tGQ2dnRUR0SGNEOU9BVkFORC9tRkFJRC9rRkNURCtyRkQ5UUhWQU9BTkQvbUZBSUQva0ZDVEQrckZBS0FORC9tRkFJRC9rRkFjRDlPRDlRSE5EUUJGVHRHRW1ZSUxQZEtPZW5ISUQ4ZEJBR0RCSUJEeUIrdCtKODNFQkFCQ05KQUlEOGRGQUdEQklCRHlGK3QrSjgzRUJBTEFWQU5EUU5WaThaY01weVNROGM4ZGZiOGU4ZkhORDhkQkFHREJJQkR5Ryt0K0o4M0VCQUJDaUpBTkQ4ZEZBR0RCSUJEeUUrdCtKODNFQkFCQ0FKUkJBRUNJSkhFQUY5SlFCTU1NLzNGR0VhRjk3OGpVVVVVQkNvQmxSRUdYQUdDR3JBRjlzSElDOThaSEw5RlFCQ0JSR0FCUkZFWEFGQUZEQkJCSEtDTkQrckZDTkQrc0ZELzZGQUtDaUQrc0ZDbkQrckZDVVVVLzhFRHREK3VGRC9tRkRNQkJBRkNUSlJGQUdDSUpIR0FMOUpRQk1NR1hBTEFJOVBRQkFFQUlDRVpIR0NHV0hGcUNCQ29CQUZsLzhNQkFFQUJBTENHV0pITEFGLzhjQkJHWEFHOUZRQkFFQUVEQklCSEtDTkQrckZDTkQrc0ZELzZGQUtDaUQrc0ZDbkQrckZDVVVVLzhFRHREK3VGRC9tRkRNSUJNQUxBRUFGLzhjQkJNTTlURkVhQ0JDQjhvR1VrVVVCSEZBQkNFSkM5OFpKSEJqR1VrVVVCR1hHWEFCOC9CQ1RXSEd1UUJDYVJFQUJBR2xDZ2dFSkNUclhCQ2E2UUZNQUZSRU1BRU1NTUZCQ1VOTUlUOXRCQic7XG5cbmNvbnN0IGRldGVjdG9yID0gbmV3IFVpbnQ4QXJyYXkoWzAsIDk3LCAxMTUsIDEwOSwgMSwgMCwgMCwgMCwgMSwgNCwgMSwgOTYsIDAsIDAsIDMsIDMsIDIsIDAsIDAsIDUsIDMsIDEsIDAsIDEsIDEyLCAxLCAwLCAxMCwgMjIsIDIsIDEyLCAwLCA2NSwgMCwgNjUsIDAsIDY1LCAwLCAyNTIsIDEwLCAwLCAwLCAxMSwgNywgMCwgNjUsIDAsIDI1MywgMTUsIDI2LCAxMV0pO1xuXG5jb25zdCB3YXNtcGFjayA9IG5ldyBVaW50OEFycmF5KFszMiwgMCwgNjUsIDI1MywgMywgMSwgMiwgMzQsIDQsIDEwNiwgNiwgNSwgMTEsIDgsIDcsIDIwLCAxMywgMzMsIDEyLCAxNiwgMTI4LCA5LCAxMTYsIDY0LCAxOSwgMTEzLCAxMjcsIDE1LCAxMCwgMjEsIDIyLCAxNCwgMjU1LCA2NiwgMjQsIDU0LCAxMzYsIDEwNywgMTgsIDIzLCAxOTIsIDI2LCAxMTQsIDExOCwgMTMyLCAxNywgNzcsIDEwMSwgMTMwLCAxNDQsIDI3LCA4NywgMTMxLCA0NCwgNDUsIDc0LCAxNTYsIDE1NCwgNzAsIDE2N10pO1xuY29uc3QgRklMVEVSUyA9IHtcbiAgMDogJycsXG4gIDE6ICdtZXNob3B0X2RlY29kZUZpbHRlck9jdCcsXG4gIDI6ICdtZXNob3B0X2RlY29kZUZpbHRlclF1YXQnLFxuICAzOiAnbWVzaG9wdF9kZWNvZGVGaWx0ZXJFeHAnLFxuICBOT05FOiAnJyxcbiAgT0NUQUhFRFJBTDogJ21lc2hvcHRfZGVjb2RlRmlsdGVyT2N0JyxcbiAgUVVBVEVSTklPTjogJ21lc2hvcHRfZGVjb2RlRmlsdGVyUXVhdCcsXG4gIEVYUE9ORU5USUFMOiAnbWVzaG9wdF9kZWNvZGVGaWx0ZXJFeHAnXG59O1xuY29uc3QgREVDT0RFUlMgPSB7XG4gIDA6ICdtZXNob3B0X2RlY29kZVZlcnRleEJ1ZmZlcicsXG4gIDE6ICdtZXNob3B0X2RlY29kZUluZGV4QnVmZmVyJyxcbiAgMjogJ21lc2hvcHRfZGVjb2RlSW5kZXhTZXF1ZW5jZScsXG4gIEFUVFJJQlVURVM6ICdtZXNob3B0X2RlY29kZVZlcnRleEJ1ZmZlcicsXG4gIFRSSUFOR0xFUzogJ21lc2hvcHRfZGVjb2RlSW5kZXhCdWZmZXInLFxuICBJTkRJQ0VTOiAnbWVzaG9wdF9kZWNvZGVJbmRleFNlcXVlbmNlJ1xufTtcbmV4cG9ydCBmdW5jdGlvbiBpc01lc2hvcHRTdXBwb3J0ZWQoKSB7XG4gIHJldHVybiBpc1dlYkFzc2VtYmx5U3VwcG9ydGVkO1xufVxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIG1lc2hvcHREZWNvZGVWZXJ0ZXhCdWZmZXIodGFyZ2V0LCBjb3VudCwgc2l6ZSwgc291cmNlKSB7XG4gIGxldCBmaWx0ZXIgPSBhcmd1bWVudHMubGVuZ3RoID4gNCAmJiBhcmd1bWVudHNbNF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1s0XSA6ICdOT05FJztcbiAgY29uc3QgaW5zdGFuY2UgPSBhd2FpdCBsb2FkV2FzbUluc3RhbmNlKCk7XG4gIGRlY29kZShpbnN0YW5jZSwgaW5zdGFuY2UuZXhwb3J0cy5tZXNob3B0X2RlY29kZVZlcnRleEJ1ZmZlciwgdGFyZ2V0LCBjb3VudCwgc2l6ZSwgc291cmNlLCBpbnN0YW5jZS5leHBvcnRzW0ZJTFRFUlNbZmlsdGVyXV0pO1xufVxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIG1lc2hvcHREZWNvZGVJbmRleEJ1ZmZlcih0YXJnZXQsIGNvdW50LCBzaXplLCBzb3VyY2UpIHtcbiAgY29uc3QgaW5zdGFuY2UgPSBhd2FpdCBsb2FkV2FzbUluc3RhbmNlKCk7XG4gIGRlY29kZShpbnN0YW5jZSwgaW5zdGFuY2UuZXhwb3J0cy5tZXNob3B0X2RlY29kZUluZGV4QnVmZmVyLCB0YXJnZXQsIGNvdW50LCBzaXplLCBzb3VyY2UpO1xufVxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIG1lc2hvcHREZWNvZGVJbmRleFNlcXVlbmNlKHRhcmdldCwgY291bnQsIHNpemUsIHNvdXJjZSkge1xuICBjb25zdCBpbnN0YW5jZSA9IGF3YWl0IGxvYWRXYXNtSW5zdGFuY2UoKTtcbiAgZGVjb2RlKGluc3RhbmNlLCBpbnN0YW5jZS5leHBvcnRzLm1lc2hvcHRfZGVjb2RlSW5kZXhTZXF1ZW5jZSwgdGFyZ2V0LCBjb3VudCwgc2l6ZSwgc291cmNlKTtcbn1cblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIG1lc2hvcHREZWNvZGVHbHRmQnVmZmVyKHRhcmdldCwgY291bnQsIHNpemUsIHNvdXJjZSwgbW9kZSkge1xuICBsZXQgZmlsdGVyID0gYXJndW1lbnRzLmxlbmd0aCA+IDUgJiYgYXJndW1lbnRzWzVdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbNV0gOiAnTk9ORSc7XG4gIGNvbnN0IGluc3RhbmNlID0gYXdhaXQgbG9hZFdhc21JbnN0YW5jZSgpO1xuICBkZWNvZGUoaW5zdGFuY2UsIGluc3RhbmNlLmV4cG9ydHNbREVDT0RFUlNbbW9kZV1dLCB0YXJnZXQsIGNvdW50LCBzaXplLCBzb3VyY2UsIGluc3RhbmNlLmV4cG9ydHNbRklMVEVSU1tmaWx0ZXIgfHwgJ05PTkUnXV0pO1xufVxubGV0IHdhc21Qcm9taXNlO1xuYXN5bmMgZnVuY3Rpb24gbG9hZFdhc21JbnN0YW5jZSgpIHtcbiAgaWYgKCF3YXNtUHJvbWlzZSkge1xuICAgIHdhc21Qcm9taXNlID0gbG9hZFdhc21Nb2R1bGUoKTtcbiAgfVxuICByZXR1cm4gd2FzbVByb21pc2U7XG59XG5hc3luYyBmdW5jdGlvbiBsb2FkV2FzbU1vZHVsZSgpIHtcbiAgbGV0IHdhc20gPSB3YXNtX2Jhc2U7XG4gIGlmIChXZWJBc3NlbWJseS52YWxpZGF0ZShkZXRlY3RvcikpIHtcbiAgICB3YXNtID0gd2FzbV9zaW1kO1xuXG4gICAgY29uc29sZS5sb2coJ1dhcm5pbmc6IG1lc2hvcHRfZGVjb2RlciBpcyB1c2luZyBleHBlcmltZW50YWwgU0lNRCBzdXBwb3J0Jyk7XG4gIH1cbiAgY29uc3QgcmVzdWx0ID0gYXdhaXQgV2ViQXNzZW1ibHkuaW5zdGFudGlhdGUodW5wYWNrKHdhc20pLCB7fSk7XG4gIGF3YWl0IHJlc3VsdC5pbnN0YW5jZS5leHBvcnRzLl9fd2FzbV9jYWxsX2N0b3JzKCk7XG4gIHJldHVybiByZXN1bHQuaW5zdGFuY2U7XG59XG5mdW5jdGlvbiB1bnBhY2soZGF0YSkge1xuICBjb25zdCByZXN1bHQgPSBuZXcgVWludDhBcnJheShkYXRhLmxlbmd0aCk7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgZGF0YS5sZW5ndGg7ICsraSkge1xuICAgIGNvbnN0IGNoID0gZGF0YS5jaGFyQ29kZUF0KGkpO1xuICAgIHJlc3VsdFtpXSA9IGNoID4gOTYgPyBjaCAtIDcxIDogY2ggPiA2NCA/IGNoIC0gNjUgOiBjaCA+IDQ3ID8gY2ggKyA0IDogY2ggPiA0NiA/IDYzIDogNjI7XG4gIH1cbiAgbGV0IHdyaXRlID0gMDtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBkYXRhLmxlbmd0aDsgKytpKSB7XG4gICAgcmVzdWx0W3dyaXRlKytdID0gcmVzdWx0W2ldIDwgNjAgPyB3YXNtcGFja1tyZXN1bHRbaV1dIDogKHJlc3VsdFtpXSAtIDYwKSAqIDY0ICsgcmVzdWx0WysraV07XG4gIH1cbiAgcmV0dXJuIHJlc3VsdC5idWZmZXIuc2xpY2UoMCwgd3JpdGUpO1xufVxuXG5mdW5jdGlvbiBkZWNvZGUoaW5zdGFuY2UsIGZ1biwgdGFyZ2V0LCBjb3VudCwgc2l6ZSwgc291cmNlLCBmaWx0ZXIpIHtcbiAgY29uc3Qgc2JyayA9IGluc3RhbmNlLmV4cG9ydHMuc2JyaztcbiAgY29uc3QgY291bnQ0ID0gY291bnQgKyAzICYgfjM7XG4gIGNvbnN0IHRwID0gc2Jyayhjb3VudDQgKiBzaXplKTtcbiAgY29uc3Qgc3AgPSBzYnJrKHNvdXJjZS5sZW5ndGgpO1xuICBjb25zdCBoZWFwID0gbmV3IFVpbnQ4QXJyYXkoaW5zdGFuY2UuZXhwb3J0cy5tZW1vcnkuYnVmZmVyKTtcbiAgaGVhcC5zZXQoc291cmNlLCBzcCk7XG4gIGNvbnN0IHJlcyA9IGZ1bih0cCwgY291bnQsIHNpemUsIHNwLCBzb3VyY2UubGVuZ3RoKTtcbiAgaWYgKHJlcyA9PT0gMCAmJiBmaWx0ZXIpIHtcbiAgICBmaWx0ZXIodHAsIGNvdW50NCwgc2l6ZSk7XG4gIH1cbiAgdGFyZ2V0LnNldChoZWFwLnN1YmFycmF5KHRwLCB0cCArIGNvdW50ICogc2l6ZSkpO1xuICBzYnJrKHRwIC0gc2JyaygwKSk7XG4gIGlmIChyZXMgIT09IDApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJNYWxmb3JtZWQgYnVmZmVyIGRhdGE6IFwiLmNvbmNhdChyZXMpKTtcbiAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bWVzaG9wdC1kZWNvZGVyLmpzLm1hcCIsIlxuXG5pbXBvcnQgR0xURlNjZW5lZ3JhcGggZnJvbSAnLi4vYXBpL2dsdGYtc2NlbmVncmFwaCc7XG5pbXBvcnQgeyBtZXNob3B0RGVjb2RlR2x0ZkJ1ZmZlciB9IGZyb20gJy4uLy4uL21lc2hvcHQvbWVzaG9wdC1kZWNvZGVyJztcblxuY29uc3QgREVGQVVMVF9NRVNIT1BUX09QVElPTlMgPSB7XG4gIGJ5dGVPZmZzZXQ6IDAsXG4gIGZpbHRlcjogJ05PTkUnXG59O1xuXG5jb25zdCBFWFRfTUVTSE9QVF9DT01QUkVTU0lPTiA9ICdFWFRfbWVzaG9wdF9jb21wcmVzc2lvbic7XG5leHBvcnQgY29uc3QgbmFtZSA9IEVYVF9NRVNIT1BUX0NPTVBSRVNTSU9OO1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGRlY29kZShnbHRmRGF0YSwgb3B0aW9ucykge1xuICB2YXIgX29wdGlvbnMkZ2x0ZjtcbiAgY29uc3Qgc2NlbmVncmFwaCA9IG5ldyBHTFRGU2NlbmVncmFwaChnbHRmRGF0YSk7XG4gIGlmICghKG9wdGlvbnMgIT09IG51bGwgJiYgb3B0aW9ucyAhPT0gdm9pZCAwICYmIChfb3B0aW9ucyRnbHRmID0gb3B0aW9ucy5nbHRmKSAhPT0gbnVsbCAmJiBfb3B0aW9ucyRnbHRmICE9PSB2b2lkIDAgJiYgX29wdGlvbnMkZ2x0Zi5kZWNvbXByZXNzTWVzaGVzKSkge1xuICAgIHJldHVybjtcbiAgfVxuICBjb25zdCBwcm9taXNlcyA9IFtdO1xuICBmb3IgKGNvbnN0IGJ1ZmZlclZpZXdJbmRleCBvZiBnbHRmRGF0YS5qc29uLmJ1ZmZlclZpZXdzIHx8IFtdKSB7XG4gICAgcHJvbWlzZXMucHVzaChkZWNvZGVNZXNob3B0QnVmZmVyVmlldyhzY2VuZWdyYXBoLCBidWZmZXJWaWV3SW5kZXgpKTtcbiAgfVxuXG4gIGF3YWl0IFByb21pc2UuYWxsKHByb21pc2VzKTtcblxuICBzY2VuZWdyYXBoLnJlbW92ZUV4dGVuc2lvbihFWFRfTUVTSE9QVF9DT01QUkVTU0lPTik7XG59XG5cbmFzeW5jIGZ1bmN0aW9uIGRlY29kZU1lc2hvcHRCdWZmZXJWaWV3KHNjZW5lZ3JhcGgsIGJ1ZmZlclZpZXcpIHtcbiAgY29uc3QgbWVzaG9wdEV4dGVuc2lvbiA9IHNjZW5lZ3JhcGguZ2V0T2JqZWN0RXh0ZW5zaW9uKGJ1ZmZlclZpZXcsIEVYVF9NRVNIT1BUX0NPTVBSRVNTSU9OKTtcbiAgaWYgKG1lc2hvcHRFeHRlbnNpb24pIHtcbiAgICBjb25zdCB7XG4gICAgICBieXRlT2Zmc2V0ID0gMCxcbiAgICAgIGJ5dGVMZW5ndGggPSAwLFxuICAgICAgYnl0ZVN0cmlkZSxcbiAgICAgIGNvdW50LFxuICAgICAgbW9kZSxcbiAgICAgIGZpbHRlciA9ICdOT05FJyxcbiAgICAgIGJ1ZmZlcjogYnVmZmVySW5kZXhcbiAgICB9ID0gbWVzaG9wdEV4dGVuc2lvbjtcbiAgICBjb25zdCBidWZmZXIgPSBzY2VuZWdyYXBoLmdsdGYuYnVmZmVyc1tidWZmZXJJbmRleF07XG4gICAgY29uc3Qgc291cmNlID0gbmV3IFVpbnQ4QXJyYXkoYnVmZmVyLmFycmF5QnVmZmVyLCBidWZmZXIuYnl0ZU9mZnNldCArIGJ5dGVPZmZzZXQsIGJ5dGVMZW5ndGgpO1xuICAgIGNvbnN0IHJlc3VsdCA9IG5ldyBVaW50OEFycmF5KHNjZW5lZ3JhcGguZ2x0Zi5idWZmZXJzW2J1ZmZlclZpZXcuYnVmZmVyXS5hcnJheUJ1ZmZlciwgYnVmZmVyVmlldy5ieXRlT2Zmc2V0LCBidWZmZXJWaWV3LmJ5dGVMZW5ndGgpO1xuICAgIGF3YWl0IG1lc2hvcHREZWNvZGVHbHRmQnVmZmVyKHJlc3VsdCwgY291bnQsIGJ5dGVTdHJpZGUsIHNvdXJjZSwgbW9kZSwgZmlsdGVyKTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG4gIHJldHVybiBudWxsO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9RVhUX21lc2hvcHRfY29tcHJlc3Npb24uanMubWFwIiwiaW1wb3J0IHsgaXNCcm93c2VyIH0gZnJvbSAnQGxvYWRlcnMuZ2wvbG9hZGVyLXV0aWxzJztcblxuY29uc3QgTk9ERV9GT1JNQVRfU1VQUE9SVCA9IFsnaW1hZ2UvcG5nJywgJ2ltYWdlL2pwZWcnLCAnaW1hZ2UvZ2lmJ107XG5cbmNvbnN0IG1pbWVUeXBlU3VwcG9ydGVkID0ge307XG5cbmV4cG9ydCBmdW5jdGlvbiBfaXNJbWFnZUZvcm1hdFN1cHBvcnRlZChtaW1lVHlwZSkge1xuICBpZiAobWltZVR5cGVTdXBwb3J0ZWRbbWltZVR5cGVdID09PSB1bmRlZmluZWQpIHtcbiAgICBtaW1lVHlwZVN1cHBvcnRlZFttaW1lVHlwZV0gPSBjaGVja0Zvcm1hdFN1cHBvcnQobWltZVR5cGUpO1xuICB9XG4gIHJldHVybiBtaW1lVHlwZVN1cHBvcnRlZFttaW1lVHlwZV07XG59XG5cbmZ1bmN0aW9uIGNoZWNrRm9ybWF0U3VwcG9ydChtaW1lVHlwZSkge1xuICBzd2l0Y2ggKG1pbWVUeXBlKSB7XG4gICAgY2FzZSAnaW1hZ2Uvd2VicCc6XG4gICAgICByZXR1cm4gY2hlY2tXZWJQU3VwcG9ydCgpO1xuICAgIGNhc2UgJ2ltYWdlL3N2Zyc6XG4gICAgICByZXR1cm4gaXNCcm93c2VyO1xuICAgIGRlZmF1bHQ6XG4gICAgICBpZiAoIWlzQnJvd3Nlcikge1xuICAgICAgICBjb25zdCB7XG4gICAgICAgICAgX3BhcnNlSW1hZ2VOb2RlXG4gICAgICAgIH0gPSBnbG9iYWxUaGlzO1xuICAgICAgICByZXR1cm4gQm9vbGVhbihfcGFyc2VJbWFnZU5vZGUpICYmIE5PREVfRk9STUFUX1NVUFBPUlQuaW5jbHVkZXMobWltZVR5cGUpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRydWU7XG4gIH1cbn1cblxuZnVuY3Rpb24gY2hlY2tXZWJQU3VwcG9ydCgpIHtcbiAgaWYgKCFpc0Jyb3dzZXIpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgdHJ5IHtcbiAgICBjb25zdCBlbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyk7XG4gICAgcmV0dXJuIGVsZW1lbnQudG9EYXRhVVJMKCdpbWFnZS93ZWJwJykuaW5kZXhPZignZGF0YTppbWFnZS93ZWJwJykgPT09IDA7XG4gIH0gY2F0Y2gge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW1hZ2UtZm9ybWF0LmpzLm1hcCIsIlxuXG5pbXBvcnQgeyBfaXNJbWFnZUZvcm1hdFN1cHBvcnRlZCB9IGZyb20gJ0Bsb2FkZXJzLmdsL2ltYWdlcyc7XG5pbXBvcnQgR0xURlNjZW5lZ3JhcGggZnJvbSAnLi4vYXBpL2dsdGYtc2NlbmVncmFwaCc7XG5jb25zdCBFWFRfVEVYVFVSRV9XRUJQID0gJ0VYVF90ZXh0dXJlX3dlYnAnO1xuXG5leHBvcnQgY29uc3QgbmFtZSA9IEVYVF9URVhUVVJFX1dFQlA7XG5cbmV4cG9ydCBmdW5jdGlvbiBwcmVwcm9jZXNzKGdsdGZEYXRhLCBvcHRpb25zKSB7XG4gIGNvbnN0IHNjZW5lZ3JhcGggPSBuZXcgR0xURlNjZW5lZ3JhcGgoZ2x0ZkRhdGEpO1xuICBpZiAoIV9pc0ltYWdlRm9ybWF0U3VwcG9ydGVkKCdpbWFnZS93ZWJwJykpIHtcbiAgICBpZiAoc2NlbmVncmFwaC5nZXRSZXF1aXJlZEV4dGVuc2lvbnMoKS5pbmNsdWRlcyhFWFRfVEVYVFVSRV9XRUJQKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiZ2x0ZjogUmVxdWlyZWQgZXh0ZW5zaW9uIFwiLmNvbmNhdChFWFRfVEVYVFVSRV9XRUJQLCBcIiBub3Qgc3VwcG9ydGVkIGJ5IGJyb3dzZXJcIikpO1xuICAgIH1cbiAgICByZXR1cm47XG4gIH1cbiAgY29uc3Qge1xuICAgIGpzb25cbiAgfSA9IHNjZW5lZ3JhcGg7XG4gIGZvciAoY29uc3QgdGV4dHVyZSBvZiBqc29uLnRleHR1cmVzIHx8IFtdKSB7XG4gICAgY29uc3QgZXh0ZW5zaW9uID0gc2NlbmVncmFwaC5nZXRPYmplY3RFeHRlbnNpb24odGV4dHVyZSwgRVhUX1RFWFRVUkVfV0VCUCk7XG4gICAgaWYgKGV4dGVuc2lvbikge1xuICAgICAgdGV4dHVyZS5zb3VyY2UgPSBleHRlbnNpb24uc291cmNlO1xuICAgIH1cbiAgICBzY2VuZWdyYXBoLnJlbW92ZU9iamVjdEV4dGVuc2lvbih0ZXh0dXJlLCBFWFRfVEVYVFVSRV9XRUJQKTtcbiAgfVxuXG4gIHNjZW5lZ3JhcGgucmVtb3ZlRXh0ZW5zaW9uKEVYVF9URVhUVVJFX1dFQlApO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9RVhUX3RleHR1cmVfd2VicC5qcy5tYXAiLCJcblxuaW1wb3J0IEdMVEZTY2VuZWdyYXBoIGZyb20gJy4uL2FwaS9nbHRmLXNjZW5lZ3JhcGgnO1xuY29uc3QgS0hSX1RFWFRVUkVfQkFTSVNVID0gJ0tIUl90ZXh0dXJlX2Jhc2lzdSc7XG5cbmV4cG9ydCBjb25zdCBuYW1lID0gS0hSX1RFWFRVUkVfQkFTSVNVO1xuXG5leHBvcnQgZnVuY3Rpb24gcHJlcHJvY2VzcyhnbHRmRGF0YSwgb3B0aW9ucykge1xuICBjb25zdCBzY2VuZSA9IG5ldyBHTFRGU2NlbmVncmFwaChnbHRmRGF0YSk7XG4gIGNvbnN0IHtcbiAgICBqc29uXG4gIH0gPSBzY2VuZTtcbiAgZm9yIChjb25zdCB0ZXh0dXJlIG9mIGpzb24udGV4dHVyZXMgfHwgW10pIHtcbiAgICBjb25zdCBleHRlbnNpb24gPSBzY2VuZS5nZXRPYmplY3RFeHRlbnNpb24odGV4dHVyZSwgS0hSX1RFWFRVUkVfQkFTSVNVKTtcbiAgICBpZiAoZXh0ZW5zaW9uKSB7XG4gICAgICB0ZXh0dXJlLnNvdXJjZSA9IGV4dGVuc2lvbi5zb3VyY2U7XG4gICAgfVxuICAgIHNjZW5lLnJlbW92ZU9iamVjdEV4dGVuc2lvbih0ZXh0dXJlLCBLSFJfVEVYVFVSRV9CQVNJU1UpO1xuICB9XG5cbiAgc2NlbmUucmVtb3ZlRXh0ZW5zaW9uKEtIUl9URVhUVVJFX0JBU0lTVSk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1LSFJfdGV4dHVyZV9iYXNpc3UuanMubWFwIiwiXG5leHBvcnQgY29uc3QgVkVSU0lPTiA9IHR5cGVvZiBcIjMuMy4xXCIgIT09ICd1bmRlZmluZWQnID8gXCIzLjMuMVwiIDogJ2xhdGVzdCc7XG4vLyMgc291cmNlTWFwcGluZ1VSTD12ZXJzaW9uLmpzLm1hcCIsImltcG9ydCB7IGlzQnJvd3NlciB9IGZyb20gJ0Bsb2FkZXJzLmdsL3dvcmtlci11dGlscyc7XG5pbXBvcnQgeyBWRVJTSU9OIH0gZnJvbSAnLi9saWIvdXRpbHMvdmVyc2lvbic7XG5jb25zdCBERUZBVUxUX0RSQUNPX09QVElPTlMgPSB7XG4gIGRyYWNvOiB7XG4gICAgZGVjb2RlclR5cGU6IHR5cGVvZiBXZWJBc3NlbWJseSA9PT0gJ29iamVjdCcgPyAnd2FzbScgOiAnanMnLFxuICAgIGxpYnJhcnlQYXRoOiAnbGlicy8nLFxuICAgIGV4dHJhQXR0cmlidXRlczoge30sXG4gICAgYXR0cmlidXRlTmFtZUVudHJ5OiB1bmRlZmluZWRcbiAgfVxufTtcblxuZXhwb3J0IGNvbnN0IERyYWNvTG9hZGVyID0ge1xuICBuYW1lOiAnRHJhY28nLFxuICBpZDogaXNCcm93c2VyID8gJ2RyYWNvJyA6ICdkcmFjby1ub2RlanMnLFxuICBtb2R1bGU6ICdkcmFjbycsXG4gIHNoYXBlczogWydtZXNoJ10sXG4gIHZlcnNpb246IFZFUlNJT04sXG4gIHdvcmtlcjogdHJ1ZSxcbiAgZXh0ZW5zaW9uczogWydkcmMnXSxcbiAgbWltZVR5cGVzOiBbJ2FwcGxpY2F0aW9uL29jdGV0LXN0cmVhbSddLFxuICBiaW5hcnk6IHRydWUsXG4gIHRlc3RzOiBbJ0RSQUNPJ10sXG4gIG9wdGlvbnM6IERFRkFVTFRfRFJBQ09fT1BUSU9OU1xufTtcbmV4cG9ydCBjb25zdCBfVHlwZWNoZWNrRHJhY29Mb2FkZXIgPSBEcmFjb0xvYWRlcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRyYWNvLWxvYWRlci5qcy5tYXAiLCJcblxuZXhwb3J0IGZ1bmN0aW9uIGdldE1lc2hTaXplKGF0dHJpYnV0ZXMpIHtcbiAgbGV0IHNpemUgPSAwO1xuICBmb3IgKGNvbnN0IGF0dHJpYnV0ZU5hbWUgaW4gYXR0cmlidXRlcykge1xuICAgIGNvbnN0IGF0dHJpYnV0ZSA9IGF0dHJpYnV0ZXNbYXR0cmlidXRlTmFtZV07XG4gICAgaWYgKEFycmF5QnVmZmVyLmlzVmlldyhhdHRyaWJ1dGUpKSB7XG4gICAgICBzaXplICs9IGF0dHJpYnV0ZS5ieXRlTGVuZ3RoICogYXR0cmlidXRlLkJZVEVTX1BFUl9FTEVNRU5UO1xuICAgIH1cbiAgfVxuICByZXR1cm4gc2l6ZTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdldE1lc2hCb3VuZGluZ0JveChhdHRyaWJ1dGVzKSB7XG4gIGxldCBtaW5YID0gSW5maW5pdHk7XG4gIGxldCBtaW5ZID0gSW5maW5pdHk7XG4gIGxldCBtaW5aID0gSW5maW5pdHk7XG4gIGxldCBtYXhYID0gLUluZmluaXR5O1xuICBsZXQgbWF4WSA9IC1JbmZpbml0eTtcbiAgbGV0IG1heFogPSAtSW5maW5pdHk7XG4gIGNvbnN0IHBvc2l0aW9ucyA9IGF0dHJpYnV0ZXMuUE9TSVRJT04gPyBhdHRyaWJ1dGVzLlBPU0lUSU9OLnZhbHVlIDogW107XG4gIGNvbnN0IGxlbiA9IHBvc2l0aW9ucyAmJiBwb3NpdGlvbnMubGVuZ3RoO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbjsgaSArPSAzKSB7XG4gICAgY29uc3QgeCA9IHBvc2l0aW9uc1tpXTtcbiAgICBjb25zdCB5ID0gcG9zaXRpb25zW2kgKyAxXTtcbiAgICBjb25zdCB6ID0gcG9zaXRpb25zW2kgKyAyXTtcbiAgICBtaW5YID0geCA8IG1pblggPyB4IDogbWluWDtcbiAgICBtaW5ZID0geSA8IG1pblkgPyB5IDogbWluWTtcbiAgICBtaW5aID0geiA8IG1pblogPyB6IDogbWluWjtcbiAgICBtYXhYID0geCA+IG1heFggPyB4IDogbWF4WDtcbiAgICBtYXhZID0geSA+IG1heFkgPyB5IDogbWF4WTtcbiAgICBtYXhaID0geiA+IG1heFogPyB6IDogbWF4WjtcbiAgfVxuICByZXR1cm4gW1ttaW5YLCBtaW5ZLCBtaW5aXSwgW21heFgsIG1heFksIG1heFpdXTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW1lc2gtdXRpbHMuanMubWFwIiwiaW1wb3J0IF9kZWZpbmVQcm9wZXJ0eSBmcm9tIFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vZGVmaW5lUHJvcGVydHlcIjtcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEZpZWxkIHtcbiAgY29uc3RydWN0b3IobmFtZSwgdHlwZSkge1xuICAgIGxldCBudWxsYWJsZSA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogZmFsc2U7XG4gICAgbGV0IG1ldGFkYXRhID0gYXJndW1lbnRzLmxlbmd0aCA+IDMgJiYgYXJndW1lbnRzWzNdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbM10gOiBuZXcgTWFwKCk7XG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwibmFtZVwiLCB2b2lkIDApO1xuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInR5cGVcIiwgdm9pZCAwKTtcbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJudWxsYWJsZVwiLCB2b2lkIDApO1xuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIm1ldGFkYXRhXCIsIHZvaWQgMCk7XG4gICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICB0aGlzLnR5cGUgPSB0eXBlO1xuICAgIHRoaXMubnVsbGFibGUgPSBudWxsYWJsZTtcbiAgICB0aGlzLm1ldGFkYXRhID0gbWV0YWRhdGE7XG4gIH1cbiAgZ2V0IHR5cGVJZCgpIHtcbiAgICByZXR1cm4gdGhpcy50eXBlICYmIHRoaXMudHlwZS50eXBlSWQ7XG4gIH1cbiAgY2xvbmUoKSB7XG4gICAgcmV0dXJuIG5ldyBGaWVsZCh0aGlzLm5hbWUsIHRoaXMudHlwZSwgdGhpcy5udWxsYWJsZSwgdGhpcy5tZXRhZGF0YSk7XG4gIH1cbiAgY29tcGFyZVRvKG90aGVyKSB7XG4gICAgcmV0dXJuIHRoaXMubmFtZSA9PT0gb3RoZXIubmFtZSAmJiB0aGlzLnR5cGUgPT09IG90aGVyLnR5cGUgJiYgdGhpcy5udWxsYWJsZSA9PT0gb3RoZXIubnVsbGFibGUgJiYgdGhpcy5tZXRhZGF0YSA9PT0gb3RoZXIubWV0YWRhdGE7XG4gIH1cbiAgdG9TdHJpbmcoKSB7XG4gICAgcmV0dXJuIFwiXCIuY29uY2F0KHRoaXMudHlwZSkuY29uY2F0KHRoaXMubnVsbGFibGUgPyAnLCBudWxsYWJsZScgOiAnJykuY29uY2F0KHRoaXMubWV0YWRhdGEgPyBcIiwgbWV0YWRhdGE6IFwiLmNvbmNhdCh0aGlzLm1ldGFkYXRhKSA6ICcnKTtcbiAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZmllbGQuanMubWFwIiwiXG5cbmV4cG9ydCBsZXQgVHlwZTtcbihmdW5jdGlvbiAoVHlwZSkge1xuICBUeXBlW1R5cGVbXCJOT05FXCJdID0gMF0gPSBcIk5PTkVcIjtcbiAgVHlwZVtUeXBlW1wiTnVsbFwiXSA9IDFdID0gXCJOdWxsXCI7XG4gIFR5cGVbVHlwZVtcIkludFwiXSA9IDJdID0gXCJJbnRcIjtcbiAgVHlwZVtUeXBlW1wiRmxvYXRcIl0gPSAzXSA9IFwiRmxvYXRcIjtcbiAgVHlwZVtUeXBlW1wiQmluYXJ5XCJdID0gNF0gPSBcIkJpbmFyeVwiO1xuICBUeXBlW1R5cGVbXCJVdGY4XCJdID0gNV0gPSBcIlV0ZjhcIjtcbiAgVHlwZVtUeXBlW1wiQm9vbFwiXSA9IDZdID0gXCJCb29sXCI7XG4gIFR5cGVbVHlwZVtcIkRlY2ltYWxcIl0gPSA3XSA9IFwiRGVjaW1hbFwiO1xuICBUeXBlW1R5cGVbXCJEYXRlXCJdID0gOF0gPSBcIkRhdGVcIjtcbiAgVHlwZVtUeXBlW1wiVGltZVwiXSA9IDldID0gXCJUaW1lXCI7XG4gIFR5cGVbVHlwZVtcIlRpbWVzdGFtcFwiXSA9IDEwXSA9IFwiVGltZXN0YW1wXCI7XG4gIFR5cGVbVHlwZVtcIkludGVydmFsXCJdID0gMTFdID0gXCJJbnRlcnZhbFwiO1xuICBUeXBlW1R5cGVbXCJMaXN0XCJdID0gMTJdID0gXCJMaXN0XCI7XG4gIFR5cGVbVHlwZVtcIlN0cnVjdFwiXSA9IDEzXSA9IFwiU3RydWN0XCI7XG4gIFR5cGVbVHlwZVtcIlVuaW9uXCJdID0gMTRdID0gXCJVbmlvblwiO1xuICBUeXBlW1R5cGVbXCJGaXhlZFNpemVCaW5hcnlcIl0gPSAxNV0gPSBcIkZpeGVkU2l6ZUJpbmFyeVwiO1xuICBUeXBlW1R5cGVbXCJGaXhlZFNpemVMaXN0XCJdID0gMTZdID0gXCJGaXhlZFNpemVMaXN0XCI7XG4gIFR5cGVbVHlwZVtcIk1hcFwiXSA9IDE3XSA9IFwiTWFwXCI7XG4gIFR5cGVbVHlwZVtcIkRpY3Rpb25hcnlcIl0gPSAtMV0gPSBcIkRpY3Rpb25hcnlcIjtcbiAgVHlwZVtUeXBlW1wiSW50OFwiXSA9IC0yXSA9IFwiSW50OFwiO1xuICBUeXBlW1R5cGVbXCJJbnQxNlwiXSA9IC0zXSA9IFwiSW50MTZcIjtcbiAgVHlwZVtUeXBlW1wiSW50MzJcIl0gPSAtNF0gPSBcIkludDMyXCI7XG4gIFR5cGVbVHlwZVtcIkludDY0XCJdID0gLTVdID0gXCJJbnQ2NFwiO1xuICBUeXBlW1R5cGVbXCJVaW50OFwiXSA9IC02XSA9IFwiVWludDhcIjtcbiAgVHlwZVtUeXBlW1wiVWludDE2XCJdID0gLTddID0gXCJVaW50MTZcIjtcbiAgVHlwZVtUeXBlW1wiVWludDMyXCJdID0gLThdID0gXCJVaW50MzJcIjtcbiAgVHlwZVtUeXBlW1wiVWludDY0XCJdID0gLTldID0gXCJVaW50NjRcIjtcbiAgVHlwZVtUeXBlW1wiRmxvYXQxNlwiXSA9IC0xMF0gPSBcIkZsb2F0MTZcIjtcbiAgVHlwZVtUeXBlW1wiRmxvYXQzMlwiXSA9IC0xMV0gPSBcIkZsb2F0MzJcIjtcbiAgVHlwZVtUeXBlW1wiRmxvYXQ2NFwiXSA9IC0xMl0gPSBcIkZsb2F0NjRcIjtcbiAgVHlwZVtUeXBlW1wiRGF0ZURheVwiXSA9IC0xM10gPSBcIkRhdGVEYXlcIjtcbiAgVHlwZVtUeXBlW1wiRGF0ZU1pbGxpc2Vjb25kXCJdID0gLTE0XSA9IFwiRGF0ZU1pbGxpc2Vjb25kXCI7XG4gIFR5cGVbVHlwZVtcIlRpbWVzdGFtcFNlY29uZFwiXSA9IC0xNV0gPSBcIlRpbWVzdGFtcFNlY29uZFwiO1xuICBUeXBlW1R5cGVbXCJUaW1lc3RhbXBNaWxsaXNlY29uZFwiXSA9IC0xNl0gPSBcIlRpbWVzdGFtcE1pbGxpc2Vjb25kXCI7XG4gIFR5cGVbVHlwZVtcIlRpbWVzdGFtcE1pY3Jvc2Vjb25kXCJdID0gLTE3XSA9IFwiVGltZXN0YW1wTWljcm9zZWNvbmRcIjtcbiAgVHlwZVtUeXBlW1wiVGltZXN0YW1wTmFub3NlY29uZFwiXSA9IC0xOF0gPSBcIlRpbWVzdGFtcE5hbm9zZWNvbmRcIjtcbiAgVHlwZVtUeXBlW1wiVGltZVNlY29uZFwiXSA9IC0xOV0gPSBcIlRpbWVTZWNvbmRcIjtcbiAgVHlwZVtUeXBlW1wiVGltZU1pbGxpc2Vjb25kXCJdID0gLTIwXSA9IFwiVGltZU1pbGxpc2Vjb25kXCI7XG4gIFR5cGVbVHlwZVtcIlRpbWVNaWNyb3NlY29uZFwiXSA9IC0yMV0gPSBcIlRpbWVNaWNyb3NlY29uZFwiO1xuICBUeXBlW1R5cGVbXCJUaW1lTmFub3NlY29uZFwiXSA9IC0yMl0gPSBcIlRpbWVOYW5vc2Vjb25kXCI7XG4gIFR5cGVbVHlwZVtcIkRlbnNlVW5pb25cIl0gPSAtMjNdID0gXCJEZW5zZVVuaW9uXCI7XG4gIFR5cGVbVHlwZVtcIlNwYXJzZVVuaW9uXCJdID0gLTI0XSA9IFwiU3BhcnNlVW5pb25cIjtcbiAgVHlwZVtUeXBlW1wiSW50ZXJ2YWxEYXlUaW1lXCJdID0gLTI1XSA9IFwiSW50ZXJ2YWxEYXlUaW1lXCI7XG4gIFR5cGVbVHlwZVtcIkludGVydmFsWWVhck1vbnRoXCJdID0gLTI2XSA9IFwiSW50ZXJ2YWxZZWFyTW9udGhcIjtcbn0pKFR5cGUgfHwgKFR5cGUgPSB7fSkpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZW51bS5qcy5tYXAiLCJpbXBvcnQgX2RlZmluZVByb3BlcnR5IGZyb20gXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9kZWZpbmVQcm9wZXJ0eVwiO1xubGV0IF9TeW1ib2wkdG9TdHJpbmdUYWcsIF9TeW1ib2wkdG9TdHJpbmdUYWcyLCBfU3ltYm9sJHRvU3RyaW5nVGFnMywgX1N5bWJvbCR0b1N0cmluZ1RhZzQsIF9TeW1ib2wkdG9TdHJpbmdUYWc1LCBfU3ltYm9sJHRvU3RyaW5nVGFnNiwgX1N5bWJvbCR0b1N0cmluZ1RhZzcsIF9TeW1ib2wkdG9TdHJpbmdUYWc4O1xuXG5pbXBvcnQgeyBUeXBlIH0gZnJvbSAnLi9lbnVtJztcbmV4cG9ydCB7IFR5cGUgfSBmcm9tICcuL2VudW0nO1xuZXhwb3J0IGNsYXNzIERhdGFUeXBlIHtcbiAgc3RhdGljIGlzTnVsbCh4KSB7XG4gICAgcmV0dXJuIHggJiYgeC50eXBlSWQgPT09IFR5cGUuTnVsbDtcbiAgfVxuICBzdGF0aWMgaXNJbnQoeCkge1xuICAgIHJldHVybiB4ICYmIHgudHlwZUlkID09PSBUeXBlLkludDtcbiAgfVxuICBzdGF0aWMgaXNGbG9hdCh4KSB7XG4gICAgcmV0dXJuIHggJiYgeC50eXBlSWQgPT09IFR5cGUuRmxvYXQ7XG4gIH1cbiAgc3RhdGljIGlzQmluYXJ5KHgpIHtcbiAgICByZXR1cm4geCAmJiB4LnR5cGVJZCA9PT0gVHlwZS5CaW5hcnk7XG4gIH1cbiAgc3RhdGljIGlzVXRmOCh4KSB7XG4gICAgcmV0dXJuIHggJiYgeC50eXBlSWQgPT09IFR5cGUuVXRmODtcbiAgfVxuICBzdGF0aWMgaXNCb29sKHgpIHtcbiAgICByZXR1cm4geCAmJiB4LnR5cGVJZCA9PT0gVHlwZS5Cb29sO1xuICB9XG4gIHN0YXRpYyBpc0RlY2ltYWwoeCkge1xuICAgIHJldHVybiB4ICYmIHgudHlwZUlkID09PSBUeXBlLkRlY2ltYWw7XG4gIH1cbiAgc3RhdGljIGlzRGF0ZSh4KSB7XG4gICAgcmV0dXJuIHggJiYgeC50eXBlSWQgPT09IFR5cGUuRGF0ZTtcbiAgfVxuICBzdGF0aWMgaXNUaW1lKHgpIHtcbiAgICByZXR1cm4geCAmJiB4LnR5cGVJZCA9PT0gVHlwZS5UaW1lO1xuICB9XG4gIHN0YXRpYyBpc1RpbWVzdGFtcCh4KSB7XG4gICAgcmV0dXJuIHggJiYgeC50eXBlSWQgPT09IFR5cGUuVGltZXN0YW1wO1xuICB9XG4gIHN0YXRpYyBpc0ludGVydmFsKHgpIHtcbiAgICByZXR1cm4geCAmJiB4LnR5cGVJZCA9PT0gVHlwZS5JbnRlcnZhbDtcbiAgfVxuICBzdGF0aWMgaXNMaXN0KHgpIHtcbiAgICByZXR1cm4geCAmJiB4LnR5cGVJZCA9PT0gVHlwZS5MaXN0O1xuICB9XG4gIHN0YXRpYyBpc1N0cnVjdCh4KSB7XG4gICAgcmV0dXJuIHggJiYgeC50eXBlSWQgPT09IFR5cGUuU3RydWN0O1xuICB9XG4gIHN0YXRpYyBpc1VuaW9uKHgpIHtcbiAgICByZXR1cm4geCAmJiB4LnR5cGVJZCA9PT0gVHlwZS5VbmlvbjtcbiAgfVxuICBzdGF0aWMgaXNGaXhlZFNpemVCaW5hcnkoeCkge1xuICAgIHJldHVybiB4ICYmIHgudHlwZUlkID09PSBUeXBlLkZpeGVkU2l6ZUJpbmFyeTtcbiAgfVxuICBzdGF0aWMgaXNGaXhlZFNpemVMaXN0KHgpIHtcbiAgICByZXR1cm4geCAmJiB4LnR5cGVJZCA9PT0gVHlwZS5GaXhlZFNpemVMaXN0O1xuICB9XG4gIHN0YXRpYyBpc01hcCh4KSB7XG4gICAgcmV0dXJuIHggJiYgeC50eXBlSWQgPT09IFR5cGUuTWFwO1xuICB9XG4gIHN0YXRpYyBpc0RpY3Rpb25hcnkoeCkge1xuICAgIHJldHVybiB4ICYmIHgudHlwZUlkID09PSBUeXBlLkRpY3Rpb25hcnk7XG4gIH1cbiAgZ2V0IHR5cGVJZCgpIHtcbiAgICByZXR1cm4gVHlwZS5OT05FO1xuICB9XG5cbiAgY29tcGFyZVRvKG90aGVyKSB7XG4gICAgcmV0dXJuIHRoaXMgPT09IG90aGVyO1xuICB9XG59XG5cbmV4cG9ydCBjbGFzcyBOdWxsIGV4dGVuZHMgRGF0YVR5cGUge1xuICBnZXQgdHlwZUlkKCkge1xuICAgIHJldHVybiBUeXBlLk51bGw7XG4gIH1cbiAgZ2V0IFtTeW1ib2wudG9TdHJpbmdUYWddKCkge1xuICAgIHJldHVybiAnTnVsbCc7XG4gIH1cbiAgdG9TdHJpbmcoKSB7XG4gICAgcmV0dXJuICdOdWxsJztcbiAgfVxufVxuXG5leHBvcnQgY2xhc3MgQm9vbCBleHRlbmRzIERhdGFUeXBlIHtcbiAgZ2V0IHR5cGVJZCgpIHtcbiAgICByZXR1cm4gVHlwZS5Cb29sO1xuICB9XG4gIGdldCBbU3ltYm9sLnRvU3RyaW5nVGFnXSgpIHtcbiAgICByZXR1cm4gJ0Jvb2wnO1xuICB9XG4gIHRvU3RyaW5nKCkge1xuICAgIHJldHVybiAnQm9vbCc7XG4gIH1cbn1cblxuX1N5bWJvbCR0b1N0cmluZ1RhZyA9IFN5bWJvbC50b1N0cmluZ1RhZztcblxuZXhwb3J0IGNsYXNzIEludCBleHRlbmRzIERhdGFUeXBlIHtcbiAgY29uc3RydWN0b3IoaXNTaWduZWQsIGJpdFdpZHRoKSB7XG4gICAgc3VwZXIoKTtcbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJpc1NpZ25lZFwiLCB2b2lkIDApO1xuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImJpdFdpZHRoXCIsIHZvaWQgMCk7XG4gICAgdGhpcy5pc1NpZ25lZCA9IGlzU2lnbmVkO1xuICAgIHRoaXMuYml0V2lkdGggPSBiaXRXaWR0aDtcbiAgfVxuICBnZXQgdHlwZUlkKCkge1xuICAgIHJldHVybiBUeXBlLkludDtcbiAgfVxuICBnZXQgW19TeW1ib2wkdG9TdHJpbmdUYWddKCkge1xuICAgIHJldHVybiAnSW50JztcbiAgfVxuICB0b1N0cmluZygpIHtcbiAgICByZXR1cm4gXCJcIi5jb25jYXQodGhpcy5pc1NpZ25lZCA/ICdJJyA6ICdVaScsIFwibnRcIikuY29uY2F0KHRoaXMuYml0V2lkdGgpO1xuICB9XG59XG5leHBvcnQgY2xhc3MgSW50OCBleHRlbmRzIEludCB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKHRydWUsIDgpO1xuICB9XG59XG5leHBvcnQgY2xhc3MgSW50MTYgZXh0ZW5kcyBJbnQge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlcih0cnVlLCAxNik7XG4gIH1cbn1cbmV4cG9ydCBjbGFzcyBJbnQzMiBleHRlbmRzIEludCB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKHRydWUsIDMyKTtcbiAgfVxufVxuZXhwb3J0IGNsYXNzIEludDY0IGV4dGVuZHMgSW50IHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIodHJ1ZSwgNjQpO1xuICB9XG59XG5leHBvcnQgY2xhc3MgVWludDggZXh0ZW5kcyBJbnQge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlcihmYWxzZSwgOCk7XG4gIH1cbn1cbmV4cG9ydCBjbGFzcyBVaW50MTYgZXh0ZW5kcyBJbnQge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlcihmYWxzZSwgMTYpO1xuICB9XG59XG5leHBvcnQgY2xhc3MgVWludDMyIGV4dGVuZHMgSW50IHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoZmFsc2UsIDMyKTtcbiAgfVxufVxuZXhwb3J0IGNsYXNzIFVpbnQ2NCBleHRlbmRzIEludCB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKGZhbHNlLCA2NCk7XG4gIH1cbn1cblxuY29uc3QgUHJlY2lzaW9uID0ge1xuICBIQUxGOiAxNixcbiAgU0lOR0xFOiAzMixcbiAgRE9VQkxFOiA2NFxufTtcbl9TeW1ib2wkdG9TdHJpbmdUYWcyID0gU3ltYm9sLnRvU3RyaW5nVGFnO1xuZXhwb3J0IGNsYXNzIEZsb2F0IGV4dGVuZHMgRGF0YVR5cGUge1xuICBjb25zdHJ1Y3RvcihwcmVjaXNpb24pIHtcbiAgICBzdXBlcigpO1xuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInByZWNpc2lvblwiLCB2b2lkIDApO1xuICAgIHRoaXMucHJlY2lzaW9uID0gcHJlY2lzaW9uO1xuICB9XG4gIGdldCB0eXBlSWQoKSB7XG4gICAgcmV0dXJuIFR5cGUuRmxvYXQ7XG4gIH1cbiAgZ2V0IFtfU3ltYm9sJHRvU3RyaW5nVGFnMl0oKSB7XG4gICAgcmV0dXJuICdGbG9hdCc7XG4gIH1cbiAgdG9TdHJpbmcoKSB7XG4gICAgcmV0dXJuIFwiRmxvYXRcIi5jb25jYXQodGhpcy5wcmVjaXNpb24pO1xuICB9XG59XG5leHBvcnQgY2xhc3MgRmxvYXQxNiBleHRlbmRzIEZsb2F0IHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoUHJlY2lzaW9uLkhBTEYpO1xuICB9XG59XG5leHBvcnQgY2xhc3MgRmxvYXQzMiBleHRlbmRzIEZsb2F0IHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoUHJlY2lzaW9uLlNJTkdMRSk7XG4gIH1cbn1cbmV4cG9ydCBjbGFzcyBGbG9hdDY0IGV4dGVuZHMgRmxvYXQge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlcihQcmVjaXNpb24uRE9VQkxFKTtcbiAgfVxufVxuZXhwb3J0IGNsYXNzIEJpbmFyeSBleHRlbmRzIERhdGFUeXBlIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoKTtcbiAgfVxuICBnZXQgdHlwZUlkKCkge1xuICAgIHJldHVybiBUeXBlLkJpbmFyeTtcbiAgfVxuICB0b1N0cmluZygpIHtcbiAgICByZXR1cm4gJ0JpbmFyeSc7XG4gIH1cbiAgZ2V0IFtTeW1ib2wudG9TdHJpbmdUYWddKCkge1xuICAgIHJldHVybiAnQmluYXJ5JztcbiAgfVxufVxuXG5leHBvcnQgY2xhc3MgVXRmOCBleHRlbmRzIERhdGFUeXBlIHtcbiAgZ2V0IHR5cGVJZCgpIHtcbiAgICByZXR1cm4gVHlwZS5VdGY4O1xuICB9XG4gIGdldCBbU3ltYm9sLnRvU3RyaW5nVGFnXSgpIHtcbiAgICByZXR1cm4gJ1V0ZjgnO1xuICB9XG4gIHRvU3RyaW5nKCkge1xuICAgIHJldHVybiAnVXRmOCc7XG4gIH1cbn1cblxuY29uc3QgRGF0ZVVuaXQgPSB7XG4gIERBWTogMCxcbiAgTUlMTElTRUNPTkQ6IDFcbn07XG5fU3ltYm9sJHRvU3RyaW5nVGFnMyA9IFN5bWJvbC50b1N0cmluZ1RhZztcbmV4cG9ydCBjbGFzcyBEYXRlIGV4dGVuZHMgRGF0YVR5cGUge1xuICBjb25zdHJ1Y3Rvcih1bml0KSB7XG4gICAgc3VwZXIoKTtcbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJ1bml0XCIsIHZvaWQgMCk7XG4gICAgdGhpcy51bml0ID0gdW5pdDtcbiAgfVxuICBnZXQgdHlwZUlkKCkge1xuICAgIHJldHVybiBUeXBlLkRhdGU7XG4gIH1cbiAgZ2V0IFtfU3ltYm9sJHRvU3RyaW5nVGFnM10oKSB7XG4gICAgcmV0dXJuICdEYXRlJztcbiAgfVxuICB0b1N0cmluZygpIHtcbiAgICByZXR1cm4gXCJEYXRlXCIuY29uY2F0KCh0aGlzLnVuaXQgKyAxKSAqIDMyLCBcIjxcIikuY29uY2F0KERhdGVVbml0W3RoaXMudW5pdF0sIFwiPlwiKTtcbiAgfVxufVxuZXhwb3J0IGNsYXNzIERhdGVEYXkgZXh0ZW5kcyBEYXRlIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoRGF0ZVVuaXQuREFZKTtcbiAgfVxufVxuZXhwb3J0IGNsYXNzIERhdGVNaWxsaXNlY29uZCBleHRlbmRzIERhdGUge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlcihEYXRlVW5pdC5NSUxMSVNFQ09ORCk7XG4gIH1cbn1cbmNvbnN0IFRpbWVVbml0ID0ge1xuICBTRUNPTkQ6IDEsXG4gIE1JTExJU0VDT05EOiAxZTMsXG4gIE1JQ1JPU0VDT05EOiAxZTYsXG4gIE5BTk9TRUNPTkQ6IDFlOVxufTtcbl9TeW1ib2wkdG9TdHJpbmdUYWc0ID0gU3ltYm9sLnRvU3RyaW5nVGFnO1xuZXhwb3J0IGNsYXNzIFRpbWUgZXh0ZW5kcyBEYXRhVHlwZSB7XG4gIGNvbnN0cnVjdG9yKHVuaXQsIGJpdFdpZHRoKSB7XG4gICAgc3VwZXIoKTtcbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJ1bml0XCIsIHZvaWQgMCk7XG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwiYml0V2lkdGhcIiwgdm9pZCAwKTtcbiAgICB0aGlzLnVuaXQgPSB1bml0O1xuICAgIHRoaXMuYml0V2lkdGggPSBiaXRXaWR0aDtcbiAgfVxuICBnZXQgdHlwZUlkKCkge1xuICAgIHJldHVybiBUeXBlLlRpbWU7XG4gIH1cbiAgdG9TdHJpbmcoKSB7XG4gICAgcmV0dXJuIFwiVGltZVwiLmNvbmNhdCh0aGlzLmJpdFdpZHRoLCBcIjxcIikuY29uY2F0KFRpbWVVbml0W3RoaXMudW5pdF0sIFwiPlwiKTtcbiAgfVxuICBnZXQgW19TeW1ib2wkdG9TdHJpbmdUYWc0XSgpIHtcbiAgICByZXR1cm4gJ1RpbWUnO1xuICB9XG59XG5cbmV4cG9ydCBjbGFzcyBUaW1lU2Vjb25kIGV4dGVuZHMgVGltZSB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKFRpbWVVbml0LlNFQ09ORCwgMzIpO1xuICB9XG59XG5leHBvcnQgY2xhc3MgVGltZU1pbGxpc2Vjb25kIGV4dGVuZHMgVGltZSB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKFRpbWVVbml0Lk1JTExJU0VDT05ELCAzMik7XG4gIH1cbn1cbl9TeW1ib2wkdG9TdHJpbmdUYWc1ID0gU3ltYm9sLnRvU3RyaW5nVGFnO1xuXG5leHBvcnQgY2xhc3MgVGltZXN0YW1wIGV4dGVuZHMgRGF0YVR5cGUge1xuICBjb25zdHJ1Y3Rvcih1bml0KSB7XG4gICAgbGV0IHRpbWV6b25lID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiBudWxsO1xuICAgIHN1cGVyKCk7XG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwidW5pdFwiLCB2b2lkIDApO1xuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInRpbWV6b25lXCIsIHZvaWQgMCk7XG4gICAgdGhpcy51bml0ID0gdW5pdDtcbiAgICB0aGlzLnRpbWV6b25lID0gdGltZXpvbmU7XG4gIH1cbiAgZ2V0IHR5cGVJZCgpIHtcbiAgICByZXR1cm4gVHlwZS5UaW1lc3RhbXA7XG4gIH1cbiAgZ2V0IFtfU3ltYm9sJHRvU3RyaW5nVGFnNV0oKSB7XG4gICAgcmV0dXJuICdUaW1lc3RhbXAnO1xuICB9XG4gIHRvU3RyaW5nKCkge1xuICAgIHJldHVybiBcIlRpbWVzdGFtcDxcIi5jb25jYXQoVGltZVVuaXRbdGhpcy51bml0XSkuY29uY2F0KHRoaXMudGltZXpvbmUgPyBcIiwgXCIuY29uY2F0KHRoaXMudGltZXpvbmUpIDogJycsIFwiPlwiKTtcbiAgfVxufVxuZXhwb3J0IGNsYXNzIFRpbWVzdGFtcFNlY29uZCBleHRlbmRzIFRpbWVzdGFtcCB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIGxldCB0aW1lem9uZSA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogbnVsbDtcbiAgICBzdXBlcihUaW1lVW5pdC5TRUNPTkQsIHRpbWV6b25lKTtcbiAgfVxufVxuZXhwb3J0IGNsYXNzIFRpbWVzdGFtcE1pbGxpc2Vjb25kIGV4dGVuZHMgVGltZXN0YW1wIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgbGV0IHRpbWV6b25lID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiBudWxsO1xuICAgIHN1cGVyKFRpbWVVbml0Lk1JTExJU0VDT05ELCB0aW1lem9uZSk7XG4gIH1cbn1cbmV4cG9ydCBjbGFzcyBUaW1lc3RhbXBNaWNyb3NlY29uZCBleHRlbmRzIFRpbWVzdGFtcCB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIGxldCB0aW1lem9uZSA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogbnVsbDtcbiAgICBzdXBlcihUaW1lVW5pdC5NSUNST1NFQ09ORCwgdGltZXpvbmUpO1xuICB9XG59XG5leHBvcnQgY2xhc3MgVGltZXN0YW1wTmFub3NlY29uZCBleHRlbmRzIFRpbWVzdGFtcCB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIGxldCB0aW1lem9uZSA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogbnVsbDtcbiAgICBzdXBlcihUaW1lVW5pdC5OQU5PU0VDT05ELCB0aW1lem9uZSk7XG4gIH1cbn1cbmNvbnN0IEludGVydmFsVW5pdCA9IHtcbiAgREFZX1RJTUU6IDAsXG4gIFlFQVJfTU9OVEg6IDFcbn07XG5fU3ltYm9sJHRvU3RyaW5nVGFnNiA9IFN5bWJvbC50b1N0cmluZ1RhZztcbmV4cG9ydCBjbGFzcyBJbnRlcnZhbCBleHRlbmRzIERhdGFUeXBlIHtcbiAgY29uc3RydWN0b3IodW5pdCkge1xuICAgIHN1cGVyKCk7XG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwidW5pdFwiLCB2b2lkIDApO1xuICAgIHRoaXMudW5pdCA9IHVuaXQ7XG4gIH1cbiAgZ2V0IHR5cGVJZCgpIHtcbiAgICByZXR1cm4gVHlwZS5JbnRlcnZhbDtcbiAgfVxuICBnZXQgW19TeW1ib2wkdG9TdHJpbmdUYWc2XSgpIHtcbiAgICByZXR1cm4gJ0ludGVydmFsJztcbiAgfVxuICB0b1N0cmluZygpIHtcbiAgICByZXR1cm4gXCJJbnRlcnZhbDxcIi5jb25jYXQoSW50ZXJ2YWxVbml0W3RoaXMudW5pdF0sIFwiPlwiKTtcbiAgfVxufVxuZXhwb3J0IGNsYXNzIEludGVydmFsRGF5VGltZSBleHRlbmRzIEludGVydmFsIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoSW50ZXJ2YWxVbml0LkRBWV9USU1FKTtcbiAgfVxufVxuZXhwb3J0IGNsYXNzIEludGVydmFsWWVhck1vbnRoIGV4dGVuZHMgSW50ZXJ2YWwge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlcihJbnRlcnZhbFVuaXQuWUVBUl9NT05USCk7XG4gIH1cbn1cbl9TeW1ib2wkdG9TdHJpbmdUYWc3ID0gU3ltYm9sLnRvU3RyaW5nVGFnO1xuZXhwb3J0IGNsYXNzIEZpeGVkU2l6ZUxpc3QgZXh0ZW5kcyBEYXRhVHlwZSB7XG4gIGNvbnN0cnVjdG9yKGxpc3RTaXplLCBjaGlsZCkge1xuICAgIHN1cGVyKCk7XG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwibGlzdFNpemVcIiwgdm9pZCAwKTtcbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJjaGlsZHJlblwiLCB2b2lkIDApO1xuICAgIHRoaXMubGlzdFNpemUgPSBsaXN0U2l6ZTtcbiAgICB0aGlzLmNoaWxkcmVuID0gW2NoaWxkXTtcbiAgfVxuICBnZXQgdHlwZUlkKCkge1xuICAgIHJldHVybiBUeXBlLkZpeGVkU2l6ZUxpc3Q7XG4gIH1cbiAgZ2V0IHZhbHVlVHlwZSgpIHtcbiAgICByZXR1cm4gdGhpcy5jaGlsZHJlblswXS50eXBlO1xuICB9XG4gIGdldCB2YWx1ZUZpZWxkKCkge1xuICAgIHJldHVybiB0aGlzLmNoaWxkcmVuWzBdO1xuICB9XG4gIGdldCBbX1N5bWJvbCR0b1N0cmluZ1RhZzddKCkge1xuICAgIHJldHVybiAnRml4ZWRTaXplTGlzdCc7XG4gIH1cbiAgdG9TdHJpbmcoKSB7XG4gICAgcmV0dXJuIFwiRml4ZWRTaXplTGlzdFtcIi5jb25jYXQodGhpcy5saXN0U2l6ZSwgXCJdPFwiKS5jb25jYXQodGhpcy52YWx1ZVR5cGUsIFwiPlwiKTtcbiAgfVxufVxuX1N5bWJvbCR0b1N0cmluZ1RhZzggPSBTeW1ib2wudG9TdHJpbmdUYWc7XG5leHBvcnQgY2xhc3MgU3RydWN0IGV4dGVuZHMgRGF0YVR5cGUge1xuICBjb25zdHJ1Y3RvcihjaGlsZHJlbikge1xuICAgIHN1cGVyKCk7XG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwiY2hpbGRyZW5cIiwgdm9pZCAwKTtcbiAgICB0aGlzLmNoaWxkcmVuID0gY2hpbGRyZW47XG4gIH1cbiAgZ2V0IHR5cGVJZCgpIHtcbiAgICByZXR1cm4gVHlwZS5TdHJ1Y3Q7XG4gIH1cbiAgdG9TdHJpbmcoKSB7XG4gICAgcmV0dXJuIFwiU3RydWN0PHtcIi5jb25jYXQodGhpcy5jaGlsZHJlbi5tYXAoZiA9PiBcIlwiLmNvbmNhdChmLm5hbWUsIFwiOlwiKS5jb25jYXQoZi50eXBlKSkuam9pbignLCAnKSwgXCJ9PlwiKTtcbiAgfVxuICBnZXQgW19TeW1ib2wkdG9TdHJpbmdUYWc4XSgpIHtcbiAgICByZXR1cm4gJ1N0cnVjdCc7XG4gIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXR5cGUuanMubWFwIiwiaW1wb3J0IHsgRmxvYXQzMiwgRmxvYXQ2NCwgSW50MTYsIEludDMyLCBJbnQ4LCBVaW50MTYsIFVpbnQzMiwgVWludDggfSBmcm9tICcuLi9zY2hlbWEvc2NoZW1hJztcbmV4cG9ydCBmdW5jdGlvbiBnZXRBcnJvd1R5cGVGcm9tVHlwZWRBcnJheShhcnJheSkge1xuICBzd2l0Y2ggKGFycmF5LmNvbnN0cnVjdG9yKSB7XG4gICAgY2FzZSBJbnQ4QXJyYXk6XG4gICAgICByZXR1cm4gbmV3IEludDgoKTtcbiAgICBjYXNlIFVpbnQ4QXJyYXk6XG4gICAgICByZXR1cm4gbmV3IFVpbnQ4KCk7XG4gICAgY2FzZSBJbnQxNkFycmF5OlxuICAgICAgcmV0dXJuIG5ldyBJbnQxNigpO1xuICAgIGNhc2UgVWludDE2QXJyYXk6XG4gICAgICByZXR1cm4gbmV3IFVpbnQxNigpO1xuICAgIGNhc2UgSW50MzJBcnJheTpcbiAgICAgIHJldHVybiBuZXcgSW50MzIoKTtcbiAgICBjYXNlIFVpbnQzMkFycmF5OlxuICAgICAgcmV0dXJuIG5ldyBVaW50MzIoKTtcbiAgICBjYXNlIEZsb2F0MzJBcnJheTpcbiAgICAgIHJldHVybiBuZXcgRmxvYXQzMigpO1xuICAgIGNhc2UgRmxvYXQ2NEFycmF5OlxuICAgICAgcmV0dXJuIG5ldyBGbG9hdDY0KCk7XG4gICAgZGVmYXVsdDpcbiAgICAgIHRocm93IG5ldyBFcnJvcignYXJyYXkgdHlwZSBub3Qgc3VwcG9ydGVkJyk7XG4gIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWFycm93LWxpa2UtdHlwZS11dGlscy5qcy5tYXAiLCJpbXBvcnQgeyBTY2hlbWEsIEZpZWxkLCBGaXhlZFNpemVMaXN0IH0gZnJvbSAnLi4vLi4vbGliL3NjaGVtYS9zY2hlbWEnO1xuaW1wb3J0IHsgZ2V0QXJyb3dUeXBlRnJvbVR5cGVkQXJyYXkgfSBmcm9tICcuLi8uLi9saWIvYXJyb3cvYXJyb3ctbGlrZS10eXBlLXV0aWxzJztcblxuZXhwb3J0IGZ1bmN0aW9uIGRlZHVjZU1lc2hTY2hlbWEoYXR0cmlidXRlcywgbWV0YWRhdGEpIHtcbiAgY29uc3QgZmllbGRzID0gZGVkdWNlTWVzaEZpZWxkcyhhdHRyaWJ1dGVzKTtcbiAgcmV0dXJuIG5ldyBTY2hlbWEoZmllbGRzLCBtZXRhZGF0YSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBkZWR1Y2VNZXNoRmllbGQoYXR0cmlidXRlTmFtZSwgYXR0cmlidXRlLCBvcHRpb25hbE1ldGFkYXRhKSB7XG4gIGNvbnN0IHR5cGUgPSBnZXRBcnJvd1R5cGVGcm9tVHlwZWRBcnJheShhdHRyaWJ1dGUudmFsdWUpO1xuICBjb25zdCBtZXRhZGF0YSA9IG9wdGlvbmFsTWV0YWRhdGEgPyBvcHRpb25hbE1ldGFkYXRhIDogbWFrZU1lc2hBdHRyaWJ1dGVNZXRhZGF0YShhdHRyaWJ1dGUpO1xuICBjb25zdCBmaWVsZCA9IG5ldyBGaWVsZChhdHRyaWJ1dGVOYW1lLCBuZXcgRml4ZWRTaXplTGlzdChhdHRyaWJ1dGUuc2l6ZSwgbmV3IEZpZWxkKCd2YWx1ZScsIHR5cGUpKSwgZmFsc2UsIG1ldGFkYXRhKTtcbiAgcmV0dXJuIGZpZWxkO1xufVxuXG5mdW5jdGlvbiBkZWR1Y2VNZXNoRmllbGRzKGF0dHJpYnV0ZXMpIHtcbiAgY29uc3QgZmllbGRzID0gW107XG4gIGZvciAoY29uc3QgYXR0cmlidXRlTmFtZSBpbiBhdHRyaWJ1dGVzKSB7XG4gICAgY29uc3QgYXR0cmlidXRlID0gYXR0cmlidXRlc1thdHRyaWJ1dGVOYW1lXTtcbiAgICBmaWVsZHMucHVzaChkZWR1Y2VNZXNoRmllbGQoYXR0cmlidXRlTmFtZSwgYXR0cmlidXRlKSk7XG4gIH1cbiAgcmV0dXJuIGZpZWxkcztcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIG1ha2VNZXNoQXR0cmlidXRlTWV0YWRhdGEoYXR0cmlidXRlKSB7XG4gIGNvbnN0IHJlc3VsdCA9IG5ldyBNYXAoKTtcbiAgaWYgKCdieXRlT2Zmc2V0JyBpbiBhdHRyaWJ1dGUpIHtcbiAgICByZXN1bHQuc2V0KCdieXRlT2Zmc2V0JywgYXR0cmlidXRlLmJ5dGVPZmZzZXQudG9TdHJpbmcoMTApKTtcbiAgfVxuICBpZiAoJ2J5dGVTdHJpZGUnIGluIGF0dHJpYnV0ZSkge1xuICAgIHJlc3VsdC5zZXQoJ2J5dGVTdHJpZGUnLCBhdHRyaWJ1dGUuYnl0ZVN0cmlkZS50b1N0cmluZygxMCkpO1xuICB9XG4gIGlmICgnbm9ybWFsaXplZCcgaW4gYXR0cmlidXRlKSB7XG4gICAgcmVzdWx0LnNldCgnbm9ybWFsaXplZCcsIGF0dHJpYnV0ZS5ub3JtYWxpemVkLnRvU3RyaW5nKCkpO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1kZWR1Y2UtbWVzaC1zY2hlbWEuanMubWFwIiwiXG5leHBvcnQgZnVuY3Rpb24gYXNzZXJ0KGNvbmRpdGlvbiwgbWVzc2FnZSkge1xuICBpZiAoIWNvbmRpdGlvbikge1xuICAgIHRocm93IG5ldyBFcnJvcihtZXNzYWdlIHx8ICdsb2FkZXIgYXNzZXJ0aW9uIGZhaWxlZC4nKTtcbiAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YXNzZXJ0LmpzLm1hcCIsImltcG9ydCBfZGVmaW5lUHJvcGVydHkgZnJvbSBcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL2RlZmluZVByb3BlcnR5XCI7XG5pbXBvcnQgeyBhc3NlcnQgfSBmcm9tICcuLi8uLi91dGlscy9hc3NlcnQnO1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgU2NoZW1hIHtcblxuICBjb25zdHJ1Y3RvcihmaWVsZHMsIG1ldGFkYXRhKSB7XG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwiZmllbGRzXCIsIHZvaWQgMCk7XG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwibWV0YWRhdGFcIiwgdm9pZCAwKTtcbiAgICBhc3NlcnQoQXJyYXkuaXNBcnJheShmaWVsZHMpKTtcbiAgICBjaGVja05hbWVzKGZpZWxkcyk7XG4gICAgdGhpcy5maWVsZHMgPSBmaWVsZHM7XG4gICAgdGhpcy5tZXRhZGF0YSA9IG1ldGFkYXRhIHx8IG5ldyBNYXAoKTtcbiAgfVxuXG4gIGNvbXBhcmVUbyhvdGhlcikge1xuICAgIGlmICh0aGlzLm1ldGFkYXRhICE9PSBvdGhlci5tZXRhZGF0YSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZiAodGhpcy5maWVsZHMubGVuZ3RoICE9PSBvdGhlci5maWVsZHMubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5maWVsZHMubGVuZ3RoOyArK2kpIHtcbiAgICAgIGlmICghdGhpcy5maWVsZHNbaV0uY29tcGFyZVRvKG90aGVyLmZpZWxkc1tpXSkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBzZWxlY3QoKSB7XG4gICAgY29uc3QgbmFtZU1hcCA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGNvbHVtbk5hbWVzID0gbmV3IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgICAgY29sdW1uTmFtZXNbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgfVxuICAgIGZvciAoY29uc3QgbmFtZSBvZiBjb2x1bW5OYW1lcykge1xuICAgICAgbmFtZU1hcFtuYW1lXSA9IHRydWU7XG4gICAgfVxuICAgIGNvbnN0IHNlbGVjdGVkRmllbGRzID0gdGhpcy5maWVsZHMuZmlsdGVyKGZpZWxkID0+IG5hbWVNYXBbZmllbGQubmFtZV0pO1xuICAgIHJldHVybiBuZXcgU2NoZW1hKHNlbGVjdGVkRmllbGRzLCB0aGlzLm1ldGFkYXRhKTtcbiAgfVxuICBzZWxlY3RBdCgpIHtcbiAgICBmb3IgKHZhciBfbGVuMiA9IGFyZ3VtZW50cy5sZW5ndGgsIGNvbHVtbkluZGljZXMgPSBuZXcgQXJyYXkoX2xlbjIpLCBfa2V5MiA9IDA7IF9rZXkyIDwgX2xlbjI7IF9rZXkyKyspIHtcbiAgICAgIGNvbHVtbkluZGljZXNbX2tleTJdID0gYXJndW1lbnRzW19rZXkyXTtcbiAgICB9XG4gICAgY29uc3Qgc2VsZWN0ZWRGaWVsZHMgPSBjb2x1bW5JbmRpY2VzLm1hcChpbmRleCA9PiB0aGlzLmZpZWxkc1tpbmRleF0pLmZpbHRlcihCb29sZWFuKTtcbiAgICByZXR1cm4gbmV3IFNjaGVtYShzZWxlY3RlZEZpZWxkcywgdGhpcy5tZXRhZGF0YSk7XG4gIH1cbiAgYXNzaWduKHNjaGVtYU9yRmllbGRzKSB7XG4gICAgbGV0IGZpZWxkcztcbiAgICBsZXQgbWV0YWRhdGEgPSB0aGlzLm1ldGFkYXRhO1xuICAgIGlmIChzY2hlbWFPckZpZWxkcyBpbnN0YW5jZW9mIFNjaGVtYSkge1xuICAgICAgY29uc3Qgb3RoZXJTY2hlbWEgPSBzY2hlbWFPckZpZWxkcztcbiAgICAgIGZpZWxkcyA9IG90aGVyU2NoZW1hLmZpZWxkcztcbiAgICAgIG1ldGFkYXRhID0gbWVyZ2VNYXBzKG1lcmdlTWFwcyhuZXcgTWFwKCksIHRoaXMubWV0YWRhdGEpLCBvdGhlclNjaGVtYS5tZXRhZGF0YSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGZpZWxkcyA9IHNjaGVtYU9yRmllbGRzO1xuICAgIH1cblxuICAgIGNvbnN0IGZpZWxkTWFwID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICBmb3IgKGNvbnN0IGZpZWxkIG9mIHRoaXMuZmllbGRzKSB7XG4gICAgICBmaWVsZE1hcFtmaWVsZC5uYW1lXSA9IGZpZWxkO1xuICAgIH1cbiAgICBmb3IgKGNvbnN0IGZpZWxkIG9mIGZpZWxkcykge1xuICAgICAgZmllbGRNYXBbZmllbGQubmFtZV0gPSBmaWVsZDtcbiAgICB9XG4gICAgY29uc3QgbWVyZ2VkRmllbGRzID0gT2JqZWN0LnZhbHVlcyhmaWVsZE1hcCk7XG4gICAgcmV0dXJuIG5ldyBTY2hlbWEobWVyZ2VkRmllbGRzLCBtZXRhZGF0YSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gY2hlY2tOYW1lcyhmaWVsZHMpIHtcbiAgY29uc3QgdXNlZE5hbWVzID0ge307XG4gIGZvciAoY29uc3QgZmllbGQgb2YgZmllbGRzKSB7XG4gICAgaWYgKHVzZWROYW1lc1tmaWVsZC5uYW1lXSkge1xuICAgICAgY29uc29sZS53YXJuKCdTY2hlbWE6IGR1cGxpY2F0ZWQgZmllbGQgbmFtZScsIGZpZWxkLm5hbWUsIGZpZWxkKTtcbiAgICB9XG4gICAgdXNlZE5hbWVzW2ZpZWxkLm5hbWVdID0gdHJ1ZTtcbiAgfVxufVxuZnVuY3Rpb24gbWVyZ2VNYXBzKG0xLCBtMikge1xuICByZXR1cm4gbmV3IE1hcChbLi4uKG0xIHx8IG5ldyBNYXAoKSksIC4uLihtMiB8fCBuZXcgTWFwKCkpXSk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zY2hlbWEuanMubWFwIiwiaW1wb3J0IHsgZGVkdWNlTWVzaEZpZWxkIH0gZnJvbSAnQGxvYWRlcnMuZ2wvc2NoZW1hJztcbmltcG9ydCB7IFNjaGVtYSB9IGZyb20gJ0Bsb2FkZXJzLmdsL3NjaGVtYSc7XG5leHBvcnQgZnVuY3Rpb24gZ2V0RHJhY29TY2hlbWEoYXR0cmlidXRlcywgbG9hZGVyRGF0YSwgaW5kaWNlcykge1xuICBjb25zdCBtZXRhZGF0YU1hcCA9IG1ha2VNZXRhZGF0YShsb2FkZXJEYXRhLm1ldGFkYXRhKTtcbiAgY29uc3QgZmllbGRzID0gW107XG4gIGNvbnN0IG5hbWVkTG9hZGVyRGF0YUF0dHJpYnV0ZXMgPSB0cmFuc2Zvcm1BdHRyaWJ1dGVzTG9hZGVyRGF0YShsb2FkZXJEYXRhLmF0dHJpYnV0ZXMpO1xuICBmb3IgKGNvbnN0IGF0dHJpYnV0ZU5hbWUgaW4gYXR0cmlidXRlcykge1xuICAgIGNvbnN0IGF0dHJpYnV0ZSA9IGF0dHJpYnV0ZXNbYXR0cmlidXRlTmFtZV07XG4gICAgY29uc3QgZmllbGQgPSBnZXRBcnJvd0ZpZWxkRnJvbUF0dHJpYnV0ZShhdHRyaWJ1dGVOYW1lLCBhdHRyaWJ1dGUsIG5hbWVkTG9hZGVyRGF0YUF0dHJpYnV0ZXNbYXR0cmlidXRlTmFtZV0pO1xuICAgIGZpZWxkcy5wdXNoKGZpZWxkKTtcbiAgfVxuICBpZiAoaW5kaWNlcykge1xuICAgIGNvbnN0IGluZGljZXNGaWVsZCA9IGdldEFycm93RmllbGRGcm9tQXR0cmlidXRlKCdpbmRpY2VzJywgaW5kaWNlcyk7XG4gICAgZmllbGRzLnB1c2goaW5kaWNlc0ZpZWxkKTtcbiAgfVxuICByZXR1cm4gbmV3IFNjaGVtYShmaWVsZHMsIG1ldGFkYXRhTWFwKTtcbn1cbmZ1bmN0aW9uIHRyYW5zZm9ybUF0dHJpYnV0ZXNMb2FkZXJEYXRhKGxvYWRlckRhdGEpIHtcbiAgY29uc3QgcmVzdWx0ID0ge307XG4gIGZvciAoY29uc3Qga2V5IGluIGxvYWRlckRhdGEpIHtcbiAgICBjb25zdCBkcmFjb0F0dHJpYnV0ZSA9IGxvYWRlckRhdGFba2V5XTtcbiAgICByZXN1bHRbZHJhY29BdHRyaWJ1dGUubmFtZSB8fCAndW5kZWZpbmVkJ10gPSBkcmFjb0F0dHJpYnV0ZTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gZ2V0QXJyb3dGaWVsZEZyb21BdHRyaWJ1dGUoYXR0cmlidXRlTmFtZSwgYXR0cmlidXRlLCBsb2FkZXJEYXRhKSB7XG4gIGNvbnN0IG1ldGFkYXRhTWFwID0gbG9hZGVyRGF0YSA/IG1ha2VNZXRhZGF0YShsb2FkZXJEYXRhLm1ldGFkYXRhKSA6IHVuZGVmaW5lZDtcbiAgY29uc3QgZmllbGQgPSBkZWR1Y2VNZXNoRmllbGQoYXR0cmlidXRlTmFtZSwgYXR0cmlidXRlLCBtZXRhZGF0YU1hcCk7XG4gIHJldHVybiBmaWVsZDtcbn1cbmZ1bmN0aW9uIG1ha2VNZXRhZGF0YShtZXRhZGF0YSkge1xuICBjb25zdCBtZXRhZGF0YU1hcCA9IG5ldyBNYXAoKTtcbiAgZm9yIChjb25zdCBrZXkgaW4gbWV0YWRhdGEpIHtcbiAgICBtZXRhZGF0YU1hcC5zZXQoXCJcIi5jb25jYXQoa2V5LCBcIi5zdHJpbmdcIiksIEpTT04uc3RyaW5naWZ5KG1ldGFkYXRhW2tleV0pKTtcbiAgfVxuICByZXR1cm4gbWV0YWRhdGFNYXA7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1nZXQtZHJhY28tc2NoZW1hLmpzLm1hcCIsImltcG9ydCBfZGVmaW5lUHJvcGVydHkgZnJvbSBcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL2RlZmluZVByb3BlcnR5XCI7XG5cbmltcG9ydCB7IGdldE1lc2hCb3VuZGluZ0JveCB9IGZyb20gJ0Bsb2FkZXJzLmdsL3NjaGVtYSc7XG5pbXBvcnQgeyBnZXREcmFjb1NjaGVtYSB9IGZyb20gJy4vdXRpbHMvZ2V0LWRyYWNvLXNjaGVtYSc7XG5cbmNvbnN0IEdFT01FVFJZX1RZUEUgPSB7XG4gIFRSSUFOR1VMQVJfTUVTSDogMCxcbiAgUE9JTlRfQ0xPVUQ6IDFcbn07XG5cbmNvbnN0IERSQUNPX1RPX0dMVEZfQVRUUklCVVRFX05BTUVfTUFQID0ge1xuICBQT1NJVElPTjogJ1BPU0lUSU9OJyxcbiAgTk9STUFMOiAnTk9STUFMJyxcbiAgQ09MT1I6ICdDT0xPUl8wJyxcbiAgVEVYX0NPT1JEOiAnVEVYQ09PUkRfMCdcbn07XG5jb25zdCBEUkFDT19EQVRBX1RZUEVfVE9fVFlQRURfQVJSQVlfTUFQID0ge1xuICAxOiBJbnQ4QXJyYXksXG4gIDI6IFVpbnQ4QXJyYXksXG4gIDM6IEludDE2QXJyYXksXG4gIDQ6IFVpbnQxNkFycmF5LFxuICA1OiBJbnQzMkFycmF5LFxuICA2OiBVaW50MzJBcnJheSxcbiAgOTogRmxvYXQzMkFycmF5XG59O1xuY29uc3QgSU5ERVhfSVRFTV9TSVpFID0gNDtcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIERyYWNvUGFyc2VyIHtcbiAgY29uc3RydWN0b3IoZHJhY28pIHtcbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJkcmFjb1wiLCB2b2lkIDApO1xuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImRlY29kZXJcIiwgdm9pZCAwKTtcbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJtZXRhZGF0YVF1ZXJpZXJcIiwgdm9pZCAwKTtcbiAgICB0aGlzLmRyYWNvID0gZHJhY287XG4gICAgdGhpcy5kZWNvZGVyID0gbmV3IHRoaXMuZHJhY28uRGVjb2RlcigpO1xuICAgIHRoaXMubWV0YWRhdGFRdWVyaWVyID0gbmV3IHRoaXMuZHJhY28uTWV0YWRhdGFRdWVyaWVyKCk7XG4gIH1cblxuICBkZXN0cm95KCkge1xuICAgIHRoaXMuZHJhY28uZGVzdHJveSh0aGlzLmRlY29kZXIpO1xuICAgIHRoaXMuZHJhY28uZGVzdHJveSh0aGlzLm1ldGFkYXRhUXVlcmllcik7XG4gIH1cblxuICBwYXJzZVN5bmMoYXJyYXlCdWZmZXIpIHtcbiAgICBsZXQgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG4gICAgY29uc3QgYnVmZmVyID0gbmV3IHRoaXMuZHJhY28uRGVjb2RlckJ1ZmZlcigpO1xuICAgIGJ1ZmZlci5Jbml0KG5ldyBJbnQ4QXJyYXkoYXJyYXlCdWZmZXIpLCBhcnJheUJ1ZmZlci5ieXRlTGVuZ3RoKTtcbiAgICB0aGlzLl9kaXNhYmxlQXR0cmlidXRlVHJhbnNmb3JtcyhvcHRpb25zKTtcbiAgICBjb25zdCBnZW9tZXRyeV90eXBlID0gdGhpcy5kZWNvZGVyLkdldEVuY29kZWRHZW9tZXRyeVR5cGUoYnVmZmVyKTtcbiAgICBjb25zdCBkcmFjb0dlb21ldHJ5ID0gZ2VvbWV0cnlfdHlwZSA9PT0gdGhpcy5kcmFjby5UUklBTkdVTEFSX01FU0ggPyBuZXcgdGhpcy5kcmFjby5NZXNoKCkgOiBuZXcgdGhpcy5kcmFjby5Qb2ludENsb3VkKCk7XG4gICAgdHJ5IHtcbiAgICAgIGxldCBkcmFjb1N0YXR1cztcbiAgICAgIHN3aXRjaCAoZ2VvbWV0cnlfdHlwZSkge1xuICAgICAgICBjYXNlIHRoaXMuZHJhY28uVFJJQU5HVUxBUl9NRVNIOlxuICAgICAgICAgIGRyYWNvU3RhdHVzID0gdGhpcy5kZWNvZGVyLkRlY29kZUJ1ZmZlclRvTWVzaChidWZmZXIsIGRyYWNvR2VvbWV0cnkpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIHRoaXMuZHJhY28uUE9JTlRfQ0xPVUQ6XG4gICAgICAgICAgZHJhY29TdGF0dXMgPSB0aGlzLmRlY29kZXIuRGVjb2RlQnVmZmVyVG9Qb2ludENsb3VkKGJ1ZmZlciwgZHJhY29HZW9tZXRyeSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdEUkFDTzogVW5rbm93biBnZW9tZXRyeSB0eXBlLicpO1xuICAgICAgfVxuICAgICAgaWYgKCFkcmFjb1N0YXR1cy5vaygpIHx8ICFkcmFjb0dlb21ldHJ5LnB0cikge1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gXCJEUkFDTyBkZWNvbXByZXNzaW9uIGZhaWxlZDogXCIuY29uY2F0KGRyYWNvU3RhdHVzLmVycm9yX21zZygpKTtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKG1lc3NhZ2UpO1xuICAgICAgfVxuICAgICAgY29uc3QgbG9hZGVyRGF0YSA9IHRoaXMuX2dldERyYWNvTG9hZGVyRGF0YShkcmFjb0dlb21ldHJ5LCBnZW9tZXRyeV90eXBlLCBvcHRpb25zKTtcbiAgICAgIGNvbnN0IGdlb21ldHJ5ID0gdGhpcy5fZ2V0TWVzaERhdGEoZHJhY29HZW9tZXRyeSwgbG9hZGVyRGF0YSwgb3B0aW9ucyk7XG4gICAgICBjb25zdCBib3VuZGluZ0JveCA9IGdldE1lc2hCb3VuZGluZ0JveChnZW9tZXRyeS5hdHRyaWJ1dGVzKTtcbiAgICAgIGNvbnN0IHNjaGVtYSA9IGdldERyYWNvU2NoZW1hKGdlb21ldHJ5LmF0dHJpYnV0ZXMsIGxvYWRlckRhdGEsIGdlb21ldHJ5LmluZGljZXMpO1xuICAgICAgY29uc3QgZGF0YSA9IHtcbiAgICAgICAgbG9hZGVyOiAnZHJhY28nLFxuICAgICAgICBsb2FkZXJEYXRhLFxuICAgICAgICBoZWFkZXI6IHtcbiAgICAgICAgICB2ZXJ0ZXhDb3VudDogZHJhY29HZW9tZXRyeS5udW1fcG9pbnRzKCksXG4gICAgICAgICAgYm91bmRpbmdCb3hcbiAgICAgICAgfSxcbiAgICAgICAgLi4uZ2VvbWV0cnksXG4gICAgICAgIHNjaGVtYVxuICAgICAgfTtcbiAgICAgIHJldHVybiBkYXRhO1xuICAgIH0gZmluYWxseSB7XG4gICAgICB0aGlzLmRyYWNvLmRlc3Ryb3koYnVmZmVyKTtcbiAgICAgIGlmIChkcmFjb0dlb21ldHJ5KSB7XG4gICAgICAgIHRoaXMuZHJhY28uZGVzdHJveShkcmFjb0dlb21ldHJ5KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBfZ2V0RHJhY29Mb2FkZXJEYXRhKGRyYWNvR2VvbWV0cnksIGdlb21ldHJ5X3R5cGUsIG9wdGlvbnMpIHtcbiAgICBjb25zdCBtZXRhZGF0YSA9IHRoaXMuX2dldFRvcExldmVsTWV0YWRhdGEoZHJhY29HZW9tZXRyeSk7XG4gICAgY29uc3QgYXR0cmlidXRlcyA9IHRoaXMuX2dldERyYWNvQXR0cmlidXRlcyhkcmFjb0dlb21ldHJ5LCBvcHRpb25zKTtcbiAgICByZXR1cm4ge1xuICAgICAgZ2VvbWV0cnlfdHlwZSxcbiAgICAgIG51bV9hdHRyaWJ1dGVzOiBkcmFjb0dlb21ldHJ5Lm51bV9hdHRyaWJ1dGVzKCksXG4gICAgICBudW1fcG9pbnRzOiBkcmFjb0dlb21ldHJ5Lm51bV9wb2ludHMoKSxcbiAgICAgIG51bV9mYWNlczogZHJhY29HZW9tZXRyeSBpbnN0YW5jZW9mIHRoaXMuZHJhY28uTWVzaCA/IGRyYWNvR2VvbWV0cnkubnVtX2ZhY2VzKCkgOiAwLFxuICAgICAgbWV0YWRhdGEsXG4gICAgICBhdHRyaWJ1dGVzXG4gICAgfTtcbiAgfVxuXG4gIF9nZXREcmFjb0F0dHJpYnV0ZXMoZHJhY29HZW9tZXRyeSwgb3B0aW9ucykge1xuICAgIGNvbnN0IGRyYWNvQXR0cmlidXRlcyA9IHt9O1xuICAgIGZvciAobGV0IGF0dHJpYnV0ZUlkID0gMDsgYXR0cmlidXRlSWQgPCBkcmFjb0dlb21ldHJ5Lm51bV9hdHRyaWJ1dGVzKCk7IGF0dHJpYnV0ZUlkKyspIHtcbiAgICAgIGNvbnN0IGRyYWNvQXR0cmlidXRlID0gdGhpcy5kZWNvZGVyLkdldEF0dHJpYnV0ZShkcmFjb0dlb21ldHJ5LCBhdHRyaWJ1dGVJZCk7XG4gICAgICBjb25zdCBtZXRhZGF0YSA9IHRoaXMuX2dldEF0dHJpYnV0ZU1ldGFkYXRhKGRyYWNvR2VvbWV0cnksIGF0dHJpYnV0ZUlkKTtcbiAgICAgIGRyYWNvQXR0cmlidXRlc1tkcmFjb0F0dHJpYnV0ZS51bmlxdWVfaWQoKV0gPSB7XG4gICAgICAgIHVuaXF1ZV9pZDogZHJhY29BdHRyaWJ1dGUudW5pcXVlX2lkKCksXG4gICAgICAgIGF0dHJpYnV0ZV90eXBlOiBkcmFjb0F0dHJpYnV0ZS5hdHRyaWJ1dGVfdHlwZSgpLFxuICAgICAgICBkYXRhX3R5cGU6IGRyYWNvQXR0cmlidXRlLmRhdGFfdHlwZSgpLFxuICAgICAgICBudW1fY29tcG9uZW50czogZHJhY29BdHRyaWJ1dGUubnVtX2NvbXBvbmVudHMoKSxcbiAgICAgICAgYnl0ZV9vZmZzZXQ6IGRyYWNvQXR0cmlidXRlLmJ5dGVfb2Zmc2V0KCksXG4gICAgICAgIGJ5dGVfc3RyaWRlOiBkcmFjb0F0dHJpYnV0ZS5ieXRlX3N0cmlkZSgpLFxuICAgICAgICBub3JtYWxpemVkOiBkcmFjb0F0dHJpYnV0ZS5ub3JtYWxpemVkKCksXG4gICAgICAgIGF0dHJpYnV0ZV9pbmRleDogYXR0cmlidXRlSWQsXG4gICAgICAgIG1ldGFkYXRhXG4gICAgICB9O1xuXG4gICAgICBjb25zdCBxdWFudGl6YXRpb24gPSB0aGlzLl9nZXRRdWFudGl6YXRpb25UcmFuc2Zvcm0oZHJhY29BdHRyaWJ1dGUsIG9wdGlvbnMpO1xuICAgICAgaWYgKHF1YW50aXphdGlvbikge1xuICAgICAgICBkcmFjb0F0dHJpYnV0ZXNbZHJhY29BdHRyaWJ1dGUudW5pcXVlX2lkKCldLnF1YW50aXphdGlvbl90cmFuc2Zvcm0gPSBxdWFudGl6YXRpb247XG4gICAgICB9XG4gICAgICBjb25zdCBvY3RhaGVkcm9uID0gdGhpcy5fZ2V0T2N0YWhlZHJvblRyYW5zZm9ybShkcmFjb0F0dHJpYnV0ZSwgb3B0aW9ucyk7XG4gICAgICBpZiAob2N0YWhlZHJvbikge1xuICAgICAgICBkcmFjb0F0dHJpYnV0ZXNbZHJhY29BdHRyaWJ1dGUudW5pcXVlX2lkKCldLm9jdGFoZWRyb25fdHJhbnNmb3JtID0gb2N0YWhlZHJvbjtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGRyYWNvQXR0cmlidXRlcztcbiAgfVxuXG4gIF9nZXRNZXNoRGF0YShkcmFjb0dlb21ldHJ5LCBsb2FkZXJEYXRhLCBvcHRpb25zKSB7XG4gICAgY29uc3QgYXR0cmlidXRlcyA9IHRoaXMuX2dldE1lc2hBdHRyaWJ1dGVzKGxvYWRlckRhdGEsIGRyYWNvR2VvbWV0cnksIG9wdGlvbnMpO1xuICAgIGNvbnN0IHBvc2l0aW9uQXR0cmlidXRlID0gYXR0cmlidXRlcy5QT1NJVElPTjtcbiAgICBpZiAoIXBvc2l0aW9uQXR0cmlidXRlKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0RSQUNPOiBObyBwb3NpdGlvbiBhdHRyaWJ1dGUgZm91bmQuJyk7XG4gICAgfVxuXG4gICAgaWYgKGRyYWNvR2VvbWV0cnkgaW5zdGFuY2VvZiB0aGlzLmRyYWNvLk1lc2gpIHtcbiAgICAgIHN3aXRjaCAob3B0aW9ucy50b3BvbG9neSkge1xuICAgICAgICBjYXNlICd0cmlhbmdsZS1zdHJpcCc6XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHRvcG9sb2d5OiAndHJpYW5nbGUtc3RyaXAnLFxuICAgICAgICAgICAgbW9kZTogNCxcbiAgICAgICAgICAgIGF0dHJpYnV0ZXMsXG4gICAgICAgICAgICBpbmRpY2VzOiB7XG4gICAgICAgICAgICAgIHZhbHVlOiB0aGlzLl9nZXRUcmlhbmdsZVN0cmlwSW5kaWNlcyhkcmFjb0dlb21ldHJ5KSxcbiAgICAgICAgICAgICAgc2l6ZTogMVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH07XG4gICAgICAgIGNhc2UgJ3RyaWFuZ2xlLWxpc3QnOlxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0b3BvbG9neTogJ3RyaWFuZ2xlLWxpc3QnLFxuICAgICAgICAgICAgbW9kZTogNSxcbiAgICAgICAgICAgIGF0dHJpYnV0ZXMsXG4gICAgICAgICAgICBpbmRpY2VzOiB7XG4gICAgICAgICAgICAgIHZhbHVlOiB0aGlzLl9nZXRUcmlhbmdsZUxpc3RJbmRpY2VzKGRyYWNvR2VvbWV0cnkpLFxuICAgICAgICAgICAgICBzaXplOiAxXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgdG9wb2xvZ3k6ICdwb2ludC1saXN0JyxcbiAgICAgIG1vZGU6IDAsXG4gICAgICBhdHRyaWJ1dGVzXG4gICAgfTtcbiAgfVxuICBfZ2V0TWVzaEF0dHJpYnV0ZXMobG9hZGVyRGF0YSwgZHJhY29HZW9tZXRyeSwgb3B0aW9ucykge1xuICAgIGNvbnN0IGF0dHJpYnV0ZXMgPSB7fTtcbiAgICBmb3IgKGNvbnN0IGxvYWRlckF0dHJpYnV0ZSBvZiBPYmplY3QudmFsdWVzKGxvYWRlckRhdGEuYXR0cmlidXRlcykpIHtcbiAgICAgIGNvbnN0IGF0dHJpYnV0ZU5hbWUgPSB0aGlzLl9kZWR1Y2VBdHRyaWJ1dGVOYW1lKGxvYWRlckF0dHJpYnV0ZSwgb3B0aW9ucyk7XG4gICAgICBsb2FkZXJBdHRyaWJ1dGUubmFtZSA9IGF0dHJpYnV0ZU5hbWU7XG4gICAgICBjb25zdCB7XG4gICAgICAgIHZhbHVlLFxuICAgICAgICBzaXplXG4gICAgICB9ID0gdGhpcy5fZ2V0QXR0cmlidXRlVmFsdWVzKGRyYWNvR2VvbWV0cnksIGxvYWRlckF0dHJpYnV0ZSk7XG4gICAgICBhdHRyaWJ1dGVzW2F0dHJpYnV0ZU5hbWVdID0ge1xuICAgICAgICB2YWx1ZSxcbiAgICAgICAgc2l6ZSxcbiAgICAgICAgYnl0ZU9mZnNldDogbG9hZGVyQXR0cmlidXRlLmJ5dGVfb2Zmc2V0LFxuICAgICAgICBieXRlU3RyaWRlOiBsb2FkZXJBdHRyaWJ1dGUuYnl0ZV9zdHJpZGUsXG4gICAgICAgIG5vcm1hbGl6ZWQ6IGxvYWRlckF0dHJpYnV0ZS5ub3JtYWxpemVkXG4gICAgICB9O1xuICAgIH1cbiAgICByZXR1cm4gYXR0cmlidXRlcztcbiAgfVxuXG4gIF9nZXRUcmlhbmdsZUxpc3RJbmRpY2VzKGRyYWNvR2VvbWV0cnkpIHtcbiAgICBjb25zdCBudW1GYWNlcyA9IGRyYWNvR2VvbWV0cnkubnVtX2ZhY2VzKCk7XG4gICAgY29uc3QgbnVtSW5kaWNlcyA9IG51bUZhY2VzICogMztcbiAgICBjb25zdCBieXRlTGVuZ3RoID0gbnVtSW5kaWNlcyAqIElOREVYX0lURU1fU0laRTtcbiAgICBjb25zdCBwdHIgPSB0aGlzLmRyYWNvLl9tYWxsb2MoYnl0ZUxlbmd0aCk7XG4gICAgdHJ5IHtcbiAgICAgIHRoaXMuZGVjb2Rlci5HZXRUcmlhbmdsZXNVSW50MzJBcnJheShkcmFjb0dlb21ldHJ5LCBieXRlTGVuZ3RoLCBwdHIpO1xuICAgICAgcmV0dXJuIG5ldyBVaW50MzJBcnJheSh0aGlzLmRyYWNvLkhFQVBGMzIuYnVmZmVyLCBwdHIsIG51bUluZGljZXMpLnNsaWNlKCk7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIHRoaXMuZHJhY28uX2ZyZWUocHRyKTtcbiAgICB9XG4gIH1cblxuICBfZ2V0VHJpYW5nbGVTdHJpcEluZGljZXMoZHJhY29HZW9tZXRyeSkge1xuICAgIGNvbnN0IGRyYWNvQXJyYXkgPSBuZXcgdGhpcy5kcmFjby5EcmFjb0ludDMyQXJyYXkoKTtcbiAgICB0cnkge1xuICAgICAgdGhpcy5kZWNvZGVyLkdldFRyaWFuZ2xlU3RyaXBzRnJvbU1lc2goZHJhY29HZW9tZXRyeSwgZHJhY29BcnJheSk7XG4gICAgICByZXR1cm4gZ2V0VWludDMyQXJyYXkoZHJhY29BcnJheSk7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIHRoaXMuZHJhY28uZGVzdHJveShkcmFjb0FycmF5KTtcbiAgICB9XG4gIH1cblxuICBfZ2V0QXR0cmlidXRlVmFsdWVzKGRyYWNvR2VvbWV0cnksIGF0dHJpYnV0ZSkge1xuICAgIGNvbnN0IFR5cGVkQXJyYXlDdG9yID0gRFJBQ09fREFUQV9UWVBFX1RPX1RZUEVEX0FSUkFZX01BUFthdHRyaWJ1dGUuZGF0YV90eXBlXTtcbiAgICBjb25zdCBudW1Db21wb25lbnRzID0gYXR0cmlidXRlLm51bV9jb21wb25lbnRzO1xuICAgIGNvbnN0IG51bVBvaW50cyA9IGRyYWNvR2VvbWV0cnkubnVtX3BvaW50cygpO1xuICAgIGNvbnN0IG51bVZhbHVlcyA9IG51bVBvaW50cyAqIG51bUNvbXBvbmVudHM7XG4gICAgY29uc3QgYnl0ZUxlbmd0aCA9IG51bVZhbHVlcyAqIFR5cGVkQXJyYXlDdG9yLkJZVEVTX1BFUl9FTEVNRU5UO1xuICAgIGNvbnN0IGRhdGFUeXBlID0gZ2V0RHJhY29EYXRhVHlwZSh0aGlzLmRyYWNvLCBUeXBlZEFycmF5Q3Rvcik7XG4gICAgbGV0IHZhbHVlO1xuICAgIGNvbnN0IHB0ciA9IHRoaXMuZHJhY28uX21hbGxvYyhieXRlTGVuZ3RoKTtcbiAgICB0cnkge1xuICAgICAgY29uc3QgZHJhY29BdHRyaWJ1dGUgPSB0aGlzLmRlY29kZXIuR2V0QXR0cmlidXRlKGRyYWNvR2VvbWV0cnksIGF0dHJpYnV0ZS5hdHRyaWJ1dGVfaW5kZXgpO1xuICAgICAgdGhpcy5kZWNvZGVyLkdldEF0dHJpYnV0ZURhdGFBcnJheUZvckFsbFBvaW50cyhkcmFjb0dlb21ldHJ5LCBkcmFjb0F0dHJpYnV0ZSwgZGF0YVR5cGUsIGJ5dGVMZW5ndGgsIHB0cik7XG4gICAgICB2YWx1ZSA9IG5ldyBUeXBlZEFycmF5Q3Rvcih0aGlzLmRyYWNvLkhFQVBGMzIuYnVmZmVyLCBwdHIsIG51bVZhbHVlcykuc2xpY2UoKTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgdGhpcy5kcmFjby5fZnJlZShwdHIpO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgdmFsdWUsXG4gICAgICBzaXplOiBudW1Db21wb25lbnRzXG4gICAgfTtcbiAgfVxuXG4gIF9kZWR1Y2VBdHRyaWJ1dGVOYW1lKGF0dHJpYnV0ZSwgb3B0aW9ucykge1xuICAgIGNvbnN0IHVuaXF1ZUlkID0gYXR0cmlidXRlLnVuaXF1ZV9pZDtcbiAgICBmb3IgKGNvbnN0IFthdHRyaWJ1dGVOYW1lLCBhdHRyaWJ1dGVVbmlxdWVJZF0gb2YgT2JqZWN0LmVudHJpZXMob3B0aW9ucy5leHRyYUF0dHJpYnV0ZXMgfHwge30pKSB7XG4gICAgICBpZiAoYXR0cmlidXRlVW5pcXVlSWQgPT09IHVuaXF1ZUlkKSB7XG4gICAgICAgIHJldHVybiBhdHRyaWJ1dGVOYW1lO1xuICAgICAgfVxuICAgIH1cblxuICAgIGNvbnN0IHRoaXNBdHRyaWJ1dGVUeXBlID0gYXR0cmlidXRlLmF0dHJpYnV0ZV90eXBlO1xuICAgIGZvciAoY29uc3QgZHJhY29BdHRyaWJ1dGVDb25zdGFudCBpbiBEUkFDT19UT19HTFRGX0FUVFJJQlVURV9OQU1FX01BUCkge1xuICAgICAgY29uc3QgYXR0cmlidXRlVHlwZSA9IHRoaXMuZHJhY29bZHJhY29BdHRyaWJ1dGVDb25zdGFudF07XG4gICAgICBpZiAoYXR0cmlidXRlVHlwZSA9PT0gdGhpc0F0dHJpYnV0ZVR5cGUpIHtcbiAgICAgICAgcmV0dXJuIERSQUNPX1RPX0dMVEZfQVRUUklCVVRFX05BTUVfTUFQW2RyYWNvQXR0cmlidXRlQ29uc3RhbnRdO1xuICAgICAgfVxuICAgIH1cblxuICAgIGNvbnN0IGVudHJ5TmFtZSA9IG9wdGlvbnMuYXR0cmlidXRlTmFtZUVudHJ5IHx8ICduYW1lJztcbiAgICBpZiAoYXR0cmlidXRlLm1ldGFkYXRhW2VudHJ5TmFtZV0pIHtcbiAgICAgIHJldHVybiBhdHRyaWJ1dGUubWV0YWRhdGFbZW50cnlOYW1lXS5zdHJpbmc7XG4gICAgfVxuXG4gICAgcmV0dXJuIFwiQ1VTVE9NX0FUVFJJQlVURV9cIi5jb25jYXQodW5pcXVlSWQpO1xuICB9XG5cbiAgX2dldFRvcExldmVsTWV0YWRhdGEoZHJhY29HZW9tZXRyeSkge1xuICAgIGNvbnN0IGRyYWNvTWV0YWRhdGEgPSB0aGlzLmRlY29kZXIuR2V0TWV0YWRhdGEoZHJhY29HZW9tZXRyeSk7XG4gICAgcmV0dXJuIHRoaXMuX2dldERyYWNvTWV0YWRhdGEoZHJhY29NZXRhZGF0YSk7XG4gIH1cblxuICBfZ2V0QXR0cmlidXRlTWV0YWRhdGEoZHJhY29HZW9tZXRyeSwgYXR0cmlidXRlSWQpIHtcbiAgICBjb25zdCBkcmFjb01ldGFkYXRhID0gdGhpcy5kZWNvZGVyLkdldEF0dHJpYnV0ZU1ldGFkYXRhKGRyYWNvR2VvbWV0cnksIGF0dHJpYnV0ZUlkKTtcbiAgICByZXR1cm4gdGhpcy5fZ2V0RHJhY29NZXRhZGF0YShkcmFjb01ldGFkYXRhKTtcbiAgfVxuXG4gIF9nZXREcmFjb01ldGFkYXRhKGRyYWNvTWV0YWRhdGEpIHtcbiAgICBpZiAoIWRyYWNvTWV0YWRhdGEgfHwgIWRyYWNvTWV0YWRhdGEucHRyKSB7XG4gICAgICByZXR1cm4ge307XG4gICAgfVxuICAgIGNvbnN0IHJlc3VsdCA9IHt9O1xuICAgIGNvbnN0IG51bUVudHJpZXMgPSB0aGlzLm1ldGFkYXRhUXVlcmllci5OdW1FbnRyaWVzKGRyYWNvTWV0YWRhdGEpO1xuICAgIGZvciAobGV0IGVudHJ5SW5kZXggPSAwOyBlbnRyeUluZGV4IDwgbnVtRW50cmllczsgZW50cnlJbmRleCsrKSB7XG4gICAgICBjb25zdCBlbnRyeU5hbWUgPSB0aGlzLm1ldGFkYXRhUXVlcmllci5HZXRFbnRyeU5hbWUoZHJhY29NZXRhZGF0YSwgZW50cnlJbmRleCk7XG4gICAgICByZXN1bHRbZW50cnlOYW1lXSA9IHRoaXMuX2dldERyYWNvTWV0YWRhdGFGaWVsZChkcmFjb01ldGFkYXRhLCBlbnRyeU5hbWUpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgX2dldERyYWNvTWV0YWRhdGFGaWVsZChkcmFjb01ldGFkYXRhLCBlbnRyeU5hbWUpIHtcbiAgICBjb25zdCBkcmFjb0FycmF5ID0gbmV3IHRoaXMuZHJhY28uRHJhY29JbnQzMkFycmF5KCk7XG4gICAgdHJ5IHtcbiAgICAgIHRoaXMubWV0YWRhdGFRdWVyaWVyLkdldEludEVudHJ5QXJyYXkoZHJhY29NZXRhZGF0YSwgZW50cnlOYW1lLCBkcmFjb0FycmF5KTtcbiAgICAgIGNvbnN0IGludEFycmF5ID0gZ2V0SW50MzJBcnJheShkcmFjb0FycmF5KTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGludDogdGhpcy5tZXRhZGF0YVF1ZXJpZXIuR2V0SW50RW50cnkoZHJhY29NZXRhZGF0YSwgZW50cnlOYW1lKSxcbiAgICAgICAgc3RyaW5nOiB0aGlzLm1ldGFkYXRhUXVlcmllci5HZXRTdHJpbmdFbnRyeShkcmFjb01ldGFkYXRhLCBlbnRyeU5hbWUpLFxuICAgICAgICBkb3VibGU6IHRoaXMubWV0YWRhdGFRdWVyaWVyLkdldERvdWJsZUVudHJ5KGRyYWNvTWV0YWRhdGEsIGVudHJ5TmFtZSksXG4gICAgICAgIGludEFycmF5XG4gICAgICB9O1xuICAgIH0gZmluYWxseSB7XG4gICAgICB0aGlzLmRyYWNvLmRlc3Ryb3koZHJhY29BcnJheSk7XG4gICAgfVxuICB9XG5cbiAgX2Rpc2FibGVBdHRyaWJ1dGVUcmFuc2Zvcm1zKG9wdGlvbnMpIHtcbiAgICBjb25zdCB7XG4gICAgICBxdWFudGl6ZWRBdHRyaWJ1dGVzID0gW10sXG4gICAgICBvY3RhaGVkcm9uQXR0cmlidXRlcyA9IFtdXG4gICAgfSA9IG9wdGlvbnM7XG4gICAgY29uc3Qgc2tpcEF0dHJpYnV0ZXMgPSBbLi4ucXVhbnRpemVkQXR0cmlidXRlcywgLi4ub2N0YWhlZHJvbkF0dHJpYnV0ZXNdO1xuICAgIGZvciAoY29uc3QgZHJhY29BdHRyaWJ1dGVOYW1lIG9mIHNraXBBdHRyaWJ1dGVzKSB7XG4gICAgICB0aGlzLmRlY29kZXIuU2tpcEF0dHJpYnV0ZVRyYW5zZm9ybSh0aGlzLmRyYWNvW2RyYWNvQXR0cmlidXRlTmFtZV0pO1xuICAgIH1cbiAgfVxuXG4gIF9nZXRRdWFudGl6YXRpb25UcmFuc2Zvcm0oZHJhY29BdHRyaWJ1dGUsIG9wdGlvbnMpIHtcbiAgICBjb25zdCB7XG4gICAgICBxdWFudGl6ZWRBdHRyaWJ1dGVzID0gW11cbiAgICB9ID0gb3B0aW9ucztcbiAgICBjb25zdCBhdHRyaWJ1dGVfdHlwZSA9IGRyYWNvQXR0cmlidXRlLmF0dHJpYnV0ZV90eXBlKCk7XG4gICAgY29uc3Qgc2tpcCA9IHF1YW50aXplZEF0dHJpYnV0ZXMubWFwKHR5cGUgPT4gdGhpcy5kZWNvZGVyW3R5cGVdKS5pbmNsdWRlcyhhdHRyaWJ1dGVfdHlwZSk7XG4gICAgaWYgKHNraXApIHtcbiAgICAgIGNvbnN0IHRyYW5zZm9ybSA9IG5ldyB0aGlzLmRyYWNvLkF0dHJpYnV0ZVF1YW50aXphdGlvblRyYW5zZm9ybSgpO1xuICAgICAgdHJ5IHtcbiAgICAgICAgaWYgKHRyYW5zZm9ybS5Jbml0RnJvbUF0dHJpYnV0ZShkcmFjb0F0dHJpYnV0ZSkpIHtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgcXVhbnRpemF0aW9uX2JpdHM6IHRyYW5zZm9ybS5xdWFudGl6YXRpb25fYml0cygpLFxuICAgICAgICAgICAgcmFuZ2U6IHRyYW5zZm9ybS5yYW5nZSgpLFxuICAgICAgICAgICAgbWluX3ZhbHVlczogbmV3IEZsb2F0MzJBcnJheShbMSwgMiwgM10pLm1hcChpID0+IHRyYW5zZm9ybS5taW5fdmFsdWUoaSkpXG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgdGhpcy5kcmFjby5kZXN0cm95KHRyYW5zZm9ybSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xuICB9XG4gIF9nZXRPY3RhaGVkcm9uVHJhbnNmb3JtKGRyYWNvQXR0cmlidXRlLCBvcHRpb25zKSB7XG4gICAgY29uc3Qge1xuICAgICAgb2N0YWhlZHJvbkF0dHJpYnV0ZXMgPSBbXVxuICAgIH0gPSBvcHRpb25zO1xuICAgIGNvbnN0IGF0dHJpYnV0ZV90eXBlID0gZHJhY29BdHRyaWJ1dGUuYXR0cmlidXRlX3R5cGUoKTtcbiAgICBjb25zdCBvY3RhaGVkcm9uID0gb2N0YWhlZHJvbkF0dHJpYnV0ZXMubWFwKHR5cGUgPT4gdGhpcy5kZWNvZGVyW3R5cGVdKS5pbmNsdWRlcyhhdHRyaWJ1dGVfdHlwZSk7XG4gICAgaWYgKG9jdGFoZWRyb24pIHtcbiAgICAgIGNvbnN0IHRyYW5zZm9ybSA9IG5ldyB0aGlzLmRyYWNvLkF0dHJpYnV0ZVF1YW50aXphdGlvblRyYW5zZm9ybSgpO1xuICAgICAgdHJ5IHtcbiAgICAgICAgaWYgKHRyYW5zZm9ybS5Jbml0RnJvbUF0dHJpYnV0ZShkcmFjb0F0dHJpYnV0ZSkpIHtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgcXVhbnRpemF0aW9uX2JpdHM6IHRyYW5zZm9ybS5xdWFudGl6YXRpb25fYml0cygpXG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgdGhpcy5kcmFjby5kZXN0cm95KHRyYW5zZm9ybSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xuICB9XG5cbn1cblxuZnVuY3Rpb24gZ2V0RHJhY29EYXRhVHlwZShkcmFjbywgYXR0cmlidXRlVHlwZSkge1xuICBzd2l0Y2ggKGF0dHJpYnV0ZVR5cGUpIHtcbiAgICBjYXNlIEZsb2F0MzJBcnJheTpcbiAgICAgIHJldHVybiBkcmFjby5EVF9GTE9BVDMyO1xuICAgIGNhc2UgSW50OEFycmF5OlxuICAgICAgcmV0dXJuIGRyYWNvLkRUX0lOVDg7XG4gICAgY2FzZSBJbnQxNkFycmF5OlxuICAgICAgcmV0dXJuIGRyYWNvLkRUX0lOVDE2O1xuICAgIGNhc2UgSW50MzJBcnJheTpcbiAgICAgIHJldHVybiBkcmFjby5EVF9JTlQzMjtcbiAgICBjYXNlIFVpbnQ4QXJyYXk6XG4gICAgICByZXR1cm4gZHJhY28uRFRfVUlOVDg7XG4gICAgY2FzZSBVaW50MTZBcnJheTpcbiAgICAgIHJldHVybiBkcmFjby5EVF9VSU5UMTY7XG4gICAgY2FzZSBVaW50MzJBcnJheTpcbiAgICAgIHJldHVybiBkcmFjby5EVF9VSU5UMzI7XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBkcmFjby5EVF9JTlZBTElEO1xuICB9XG59XG5cbmZ1bmN0aW9uIGdldEludDMyQXJyYXkoZHJhY29BcnJheSkge1xuICBjb25zdCBudW1WYWx1ZXMgPSBkcmFjb0FycmF5LnNpemUoKTtcbiAgY29uc3QgaW50QXJyYXkgPSBuZXcgSW50MzJBcnJheShudW1WYWx1ZXMpO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IG51bVZhbHVlczsgaSsrKSB7XG4gICAgaW50QXJyYXlbaV0gPSBkcmFjb0FycmF5LkdldFZhbHVlKGkpO1xuICB9XG4gIHJldHVybiBpbnRBcnJheTtcbn1cblxuZnVuY3Rpb24gZ2V0VWludDMyQXJyYXkoZHJhY29BcnJheSkge1xuICBjb25zdCBudW1WYWx1ZXMgPSBkcmFjb0FycmF5LnNpemUoKTtcbiAgY29uc3QgaW50QXJyYXkgPSBuZXcgSW50MzJBcnJheShudW1WYWx1ZXMpO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IG51bVZhbHVlczsgaSsrKSB7XG4gICAgaW50QXJyYXlbaV0gPSBkcmFjb0FycmF5LkdldFZhbHVlKGkpO1xuICB9XG4gIHJldHVybiBpbnRBcnJheTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRyYWNvLXBhcnNlci5qcy5tYXAiLCJcblxuaW1wb3J0IHsgbG9hZExpYnJhcnkgfSBmcm9tICdAbG9hZGVycy5nbC93b3JrZXItdXRpbHMnO1xuY29uc3QgRFJBQ09fREVDT0RFUl9WRVJTSU9OID0gJzEuNS41JztcbmNvbnN0IERSQUNPX0VOQ09ERVJfVkVSU0lPTiA9ICcxLjQuMSc7XG5jb25zdCBTVEFUSUNfREVDT0RFUl9VUkwgPSBcImh0dHBzOi8vd3d3LmdzdGF0aWMuY29tL2RyYWNvL3ZlcnNpb25lZC9kZWNvZGVycy9cIi5jb25jYXQoRFJBQ09fREVDT0RFUl9WRVJTSU9OKTtcbmNvbnN0IERSQUNPX0pTX0RFQ09ERVJfVVJMID0gXCJcIi5jb25jYXQoU1RBVElDX0RFQ09ERVJfVVJMLCBcIi9kcmFjb19kZWNvZGVyLmpzXCIpO1xuY29uc3QgRFJBQ09fV0FTTV9XUkFQUEVSX1VSTCA9IFwiXCIuY29uY2F0KFNUQVRJQ19ERUNPREVSX1VSTCwgXCIvZHJhY29fd2FzbV93cmFwcGVyLmpzXCIpO1xuY29uc3QgRFJBQ09fV0FTTV9ERUNPREVSX1VSTCA9IFwiXCIuY29uY2F0KFNUQVRJQ19ERUNPREVSX1VSTCwgXCIvZHJhY29fZGVjb2Rlci53YXNtXCIpO1xuY29uc3QgRFJBQ09fRU5DT0RFUl9VUkwgPSBcImh0dHBzOi8vcmF3LmdpdGh1YnVzZXJjb250ZW50LmNvbS9nb29nbGUvZHJhY28vXCIuY29uY2F0KERSQUNPX0VOQ09ERVJfVkVSU0lPTiwgXCIvamF2YXNjcmlwdC9kcmFjb19lbmNvZGVyLmpzXCIpO1xubGV0IGxvYWREZWNvZGVyUHJvbWlzZTtcbmxldCBsb2FkRW5jb2RlclByb21pc2U7XG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gbG9hZERyYWNvRGVjb2Rlck1vZHVsZShvcHRpb25zKSB7XG4gIGNvbnN0IG1vZHVsZXMgPSBvcHRpb25zLm1vZHVsZXMgfHwge307XG5cbiAgaWYgKG1vZHVsZXMuZHJhY28zZCkge1xuICAgIGxvYWREZWNvZGVyUHJvbWlzZSA9IGxvYWREZWNvZGVyUHJvbWlzZSB8fCBtb2R1bGVzLmRyYWNvM2QuY3JlYXRlRGVjb2Rlck1vZHVsZSh7fSkudGhlbihkcmFjbyA9PiB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBkcmFjb1xuICAgICAgfTtcbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICBsb2FkRGVjb2RlclByb21pc2UgPSBsb2FkRGVjb2RlclByb21pc2UgfHwgbG9hZERyYWNvRGVjb2RlcihvcHRpb25zKTtcbiAgfVxuICByZXR1cm4gYXdhaXQgbG9hZERlY29kZXJQcm9taXNlO1xufVxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGxvYWREcmFjb0VuY29kZXJNb2R1bGUob3B0aW9ucykge1xuICBjb25zdCBtb2R1bGVzID0gb3B0aW9ucy5tb2R1bGVzIHx8IHt9O1xuXG4gIGlmIChtb2R1bGVzLmRyYWNvM2QpIHtcbiAgICBsb2FkRW5jb2RlclByb21pc2UgPSBsb2FkRW5jb2RlclByb21pc2UgfHwgbW9kdWxlcy5kcmFjbzNkLmNyZWF0ZUVuY29kZXJNb2R1bGUoe30pLnRoZW4oZHJhY28gPT4ge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgZHJhY29cbiAgICAgIH07XG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgbG9hZEVuY29kZXJQcm9taXNlID0gbG9hZEVuY29kZXJQcm9taXNlIHx8IGxvYWREcmFjb0VuY29kZXIob3B0aW9ucyk7XG4gIH1cbiAgcmV0dXJuIGF3YWl0IGxvYWRFbmNvZGVyUHJvbWlzZTtcbn1cblxuYXN5bmMgZnVuY3Rpb24gbG9hZERyYWNvRGVjb2RlcihvcHRpb25zKSB7XG4gIGxldCBEcmFjb0RlY29kZXJNb2R1bGU7XG4gIGxldCB3YXNtQmluYXJ5O1xuICBzd2l0Y2ggKG9wdGlvbnMuZHJhY28gJiYgb3B0aW9ucy5kcmFjby5kZWNvZGVyVHlwZSkge1xuICAgIGNhc2UgJ2pzJzpcbiAgICAgIERyYWNvRGVjb2Rlck1vZHVsZSA9IGF3YWl0IGxvYWRMaWJyYXJ5KERSQUNPX0pTX0RFQ09ERVJfVVJMLCAnZHJhY28nLCBvcHRpb25zKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ3dhc20nOlxuICAgIGRlZmF1bHQ6XG4gICAgICBbRHJhY29EZWNvZGVyTW9kdWxlLCB3YXNtQmluYXJ5XSA9IGF3YWl0IFByb21pc2UuYWxsKFthd2FpdCBsb2FkTGlicmFyeShEUkFDT19XQVNNX1dSQVBQRVJfVVJMLCAnZHJhY28nLCBvcHRpb25zKSwgYXdhaXQgbG9hZExpYnJhcnkoRFJBQ09fV0FTTV9ERUNPREVSX1VSTCwgJ2RyYWNvJywgb3B0aW9ucyldKTtcbiAgfVxuICBEcmFjb0RlY29kZXJNb2R1bGUgPSBEcmFjb0RlY29kZXJNb2R1bGUgfHwgZ2xvYmFsVGhpcy5EcmFjb0RlY29kZXJNb2R1bGU7XG4gIHJldHVybiBhd2FpdCBpbml0aWFsaXplRHJhY29EZWNvZGVyKERyYWNvRGVjb2Rlck1vZHVsZSwgd2FzbUJpbmFyeSk7XG59XG5mdW5jdGlvbiBpbml0aWFsaXplRHJhY29EZWNvZGVyKERyYWNvRGVjb2Rlck1vZHVsZSwgd2FzbUJpbmFyeSkge1xuICBjb25zdCBvcHRpb25zID0ge307XG4gIGlmICh3YXNtQmluYXJ5KSB7XG4gICAgb3B0aW9ucy53YXNtQmluYXJ5ID0gd2FzbUJpbmFyeTtcbiAgfVxuICByZXR1cm4gbmV3IFByb21pc2UocmVzb2x2ZSA9PiB7XG4gICAgRHJhY29EZWNvZGVyTW9kdWxlKHtcbiAgICAgIC4uLm9wdGlvbnMsXG4gICAgICBvbk1vZHVsZUxvYWRlZDogZHJhY28gPT4gcmVzb2x2ZSh7XG4gICAgICAgIGRyYWNvXG4gICAgICB9KVxuICAgIH0pO1xuICB9KTtcbn1cblxuYXN5bmMgZnVuY3Rpb24gbG9hZERyYWNvRW5jb2RlcihvcHRpb25zKSB7XG4gIGxldCBEcmFjb0VuY29kZXJNb2R1bGUgPSBhd2FpdCBsb2FkTGlicmFyeShEUkFDT19FTkNPREVSX1VSTCwgJ2RyYWNvJywgb3B0aW9ucyk7XG4gIERyYWNvRW5jb2Rlck1vZHVsZSA9IERyYWNvRW5jb2Rlck1vZHVsZSB8fCBnbG9iYWxUaGlzLkRyYWNvRW5jb2Rlck1vZHVsZTtcbiAgcmV0dXJuIG5ldyBQcm9taXNlKHJlc29sdmUgPT4ge1xuICAgIERyYWNvRW5jb2Rlck1vZHVsZSh7XG4gICAgICBvbk1vZHVsZUxvYWRlZDogZHJhY28gPT4gcmVzb2x2ZSh7XG4gICAgICAgIGRyYWNvXG4gICAgICB9KVxuICAgIH0pO1xuICB9KTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRyYWNvLW1vZHVsZS1sb2FkZXIuanMubWFwIiwiaW1wb3J0IHsgRHJhY29Mb2FkZXIgYXMgRHJhY29Xb3JrZXJMb2FkZXIgfSBmcm9tICcuL2RyYWNvLWxvYWRlcic7XG5pbXBvcnQgRHJhY29QYXJzZXIgZnJvbSAnLi9saWIvZHJhY28tcGFyc2VyJztcbmltcG9ydCB7IGxvYWREcmFjb0RlY29kZXJNb2R1bGUgfSBmcm9tICcuL2xpYi9kcmFjby1tb2R1bGUtbG9hZGVyJztcbmltcG9ydCB7IFZFUlNJT04gfSBmcm9tICcuL2xpYi91dGlscy92ZXJzaW9uJztcbmltcG9ydCB7IGlzQnJvd3NlciB9IGZyb20gJ0Bsb2FkZXJzLmdsL3dvcmtlci11dGlscyc7XG5cbmV4cG9ydCB7IERyYWNvV3JpdGVyIH0gZnJvbSAnLi9kcmFjby13cml0ZXInO1xuXG5leHBvcnQgY29uc3QgRHJhY29Xcml0ZXJXb3JrZXIgPSB7XG4gIGlkOiBpc0Jyb3dzZXIgPyAnZHJhY28td3JpdGVyJyA6ICdkcmFjby13cml0ZXItbm9kZWpzJyxcbiAgbmFtZTogJ0RyYWNvIGNvbXByZXNzZWQgZ2VvbWV0cnkgd3JpdGVyJyxcbiAgbW9kdWxlOiAnZHJhY28nLFxuICB2ZXJzaW9uOiBWRVJTSU9OLFxuICB3b3JrZXI6IHRydWUsXG4gIG9wdGlvbnM6IHtcbiAgICBkcmFjbzoge30sXG4gICAgc291cmNlOiBudWxsXG4gIH1cbn07XG5cbmV4cG9ydCB7IERyYWNvV29ya2VyTG9hZGVyIH07XG5cbmV4cG9ydCBjb25zdCBEcmFjb0xvYWRlciA9IHtcbiAgLi4uRHJhY29Xb3JrZXJMb2FkZXIsXG4gIHBhcnNlXG59O1xuYXN5bmMgZnVuY3Rpb24gcGFyc2UoYXJyYXlCdWZmZXIsIG9wdGlvbnMpIHtcbiAgY29uc3Qge1xuICAgIGRyYWNvXG4gIH0gPSBhd2FpdCBsb2FkRHJhY29EZWNvZGVyTW9kdWxlKG9wdGlvbnMpO1xuICBjb25zdCBkcmFjb1BhcnNlciA9IG5ldyBEcmFjb1BhcnNlcihkcmFjbyk7XG4gIHRyeSB7XG4gICAgcmV0dXJuIGRyYWNvUGFyc2VyLnBhcnNlU3luYyhhcnJheUJ1ZmZlciwgb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLmRyYWNvKTtcbiAgfSBmaW5hbGx5IHtcbiAgICBkcmFjb1BhcnNlci5kZXN0cm95KCk7XG4gIH1cbn1cblxuZXhwb3J0IGNvbnN0IF9UeXBlY2hlY2tEcmFjb0xvYWRlciA9IERyYWNvTG9hZGVyO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIiwiXG5cbmltcG9ydCB7IGdldEFjY2Vzc29yVHlwZUZyb21TaXplLCBnZXRDb21wb25lbnRUeXBlRnJvbUFycmF5IH0gZnJvbSAnLi9nbHRmLXV0aWxzJztcblxuZXhwb3J0IGZ1bmN0aW9uIGdldEdMVEZBY2Nlc3NvcnMoYXR0cmlidXRlcykge1xuICBjb25zdCBhY2Nlc3NvcnMgPSB7fTtcbiAgZm9yIChjb25zdCBuYW1lIGluIGF0dHJpYnV0ZXMpIHtcbiAgICBjb25zdCBhdHRyaWJ1dGUgPSBhdHRyaWJ1dGVzW25hbWVdO1xuICAgIGlmIChuYW1lICE9PSAnaW5kaWNlcycpIHtcbiAgICAgIGNvbnN0IGdsVEZBY2Nlc3NvciA9IGdldEdMVEZBY2Nlc3NvcihhdHRyaWJ1dGUpO1xuICAgICAgYWNjZXNzb3JzW25hbWVdID0gZ2xURkFjY2Vzc29yO1xuICAgIH1cbiAgfVxuICByZXR1cm4gYWNjZXNzb3JzO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0R0xURkFjY2Vzc29yKGF0dHJpYnV0ZSkge1xuICBjb25zdCB7XG4gICAgYnVmZmVyLFxuICAgIHNpemUsXG4gICAgY291bnRcbiAgfSA9IGdldEFjY2Vzc29yRGF0YShhdHRyaWJ1dGUpO1xuICBjb25zdCBnbFRGQWNjZXNzb3IgPSB7XG4gICAgdmFsdWU6IGJ1ZmZlcixcbiAgICBzaXplLFxuXG4gICAgYnl0ZU9mZnNldDogMCxcbiAgICBjb3VudCxcbiAgICB0eXBlOiBnZXRBY2Nlc3NvclR5cGVGcm9tU2l6ZShzaXplKSxcbiAgICBjb21wb25lbnRUeXBlOiBnZXRDb21wb25lbnRUeXBlRnJvbUFycmF5KGJ1ZmZlcilcbiAgfTtcbiAgcmV0dXJuIGdsVEZBY2Nlc3Nvcjtcbn1cblxuZnVuY3Rpb24gZ2V0QWNjZXNzb3JEYXRhKGF0dHJpYnV0ZSkge1xuICBsZXQgYnVmZmVyID0gYXR0cmlidXRlO1xuICBsZXQgc2l6ZSA9IDE7XG4gIGxldCBjb3VudCA9IDA7XG4gIGlmIChhdHRyaWJ1dGUgJiYgYXR0cmlidXRlLnZhbHVlKSB7XG4gICAgYnVmZmVyID0gYXR0cmlidXRlLnZhbHVlO1xuICAgIHNpemUgPSBhdHRyaWJ1dGUuc2l6ZSB8fCAxO1xuICB9XG4gIGlmIChidWZmZXIpIHtcbiAgICBpZiAoIUFycmF5QnVmZmVyLmlzVmlldyhidWZmZXIpKSB7XG4gICAgICBidWZmZXIgPSB0b1R5cGVkQXJyYXkoYnVmZmVyLCBGbG9hdDMyQXJyYXkpO1xuICAgIH1cbiAgICBjb3VudCA9IGJ1ZmZlci5sZW5ndGggLyBzaXplO1xuICB9XG4gIHJldHVybiB7XG4gICAgYnVmZmVyLFxuICAgIHNpemUsXG4gICAgY291bnRcbiAgfTtcbn1cblxuZnVuY3Rpb24gdG9UeXBlZEFycmF5KGFycmF5LCBBcnJheVR5cGUpIHtcbiAgbGV0IGNvbnZlcnRUeXBlZEFycmF5cyA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogZmFsc2U7XG4gIGlmICghYXJyYXkpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBpZiAoQXJyYXkuaXNBcnJheShhcnJheSkpIHtcbiAgICByZXR1cm4gbmV3IEFycmF5VHlwZShhcnJheSk7XG4gIH1cbiAgaWYgKGNvbnZlcnRUeXBlZEFycmF5cyAmJiAhKGFycmF5IGluc3RhbmNlb2YgQXJyYXlUeXBlKSkge1xuICAgIHJldHVybiBuZXcgQXJyYXlUeXBlKGFycmF5KTtcbiAgfVxuICByZXR1cm4gYXJyYXk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1nbHRmLWF0dHJpYnV0ZS11dGlscy5qcy5tYXAiLCJcblxuaW1wb3J0IHsgRHJhY29Mb2FkZXIgfSBmcm9tICdAbG9hZGVycy5nbC9kcmFjbyc7XG5pbXBvcnQgeyBzbGljZUFycmF5QnVmZmVyIH0gZnJvbSAnQGxvYWRlcnMuZ2wvbG9hZGVyLXV0aWxzJztcbmltcG9ydCB7IGRlZmF1bHQgYXMgU2NlbmVncmFwaCB9IGZyb20gJy4uL2FwaS9nbHRmLXNjZW5lZ3JhcGgnO1xuaW1wb3J0IHsgZ2V0R0xURkFjY2Vzc29ycywgZ2V0R0xURkFjY2Vzc29yIH0gZnJvbSAnLi4vZ2x0Zi11dGlscy9nbHRmLWF0dHJpYnV0ZS11dGlscyc7XG5jb25zdCBLSFJfRFJBQ09fTUVTSF9DT01QUkVTU0lPTiA9ICdLSFJfZHJhY29fbWVzaF9jb21wcmVzc2lvbic7XG5cbmV4cG9ydCBjb25zdCBuYW1lID0gS0hSX0RSQUNPX01FU0hfQ09NUFJFU1NJT047XG5leHBvcnQgZnVuY3Rpb24gcHJlcHJvY2VzcyhnbHRmRGF0YSwgb3B0aW9ucywgY29udGV4dCkge1xuICBjb25zdCBzY2VuZWdyYXBoID0gbmV3IFNjZW5lZ3JhcGgoZ2x0ZkRhdGEpO1xuICBmb3IgKGNvbnN0IHByaW1pdGl2ZSBvZiBtYWtlTWVzaFByaW1pdGl2ZUl0ZXJhdG9yKHNjZW5lZ3JhcGgpKSB7XG4gICAgaWYgKHNjZW5lZ3JhcGguZ2V0T2JqZWN0RXh0ZW5zaW9uKHByaW1pdGl2ZSwgS0hSX0RSQUNPX01FU0hfQ09NUFJFU1NJT04pKSB7XG4gICAgfVxuICB9XG59XG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZGVjb2RlKGdsdGZEYXRhLCBvcHRpb25zLCBjb250ZXh0KSB7XG4gIHZhciBfb3B0aW9ucyRnbHRmO1xuICBpZiAoIShvcHRpb25zICE9PSBudWxsICYmIG9wdGlvbnMgIT09IHZvaWQgMCAmJiAoX29wdGlvbnMkZ2x0ZiA9IG9wdGlvbnMuZ2x0ZikgIT09IG51bGwgJiYgX29wdGlvbnMkZ2x0ZiAhPT0gdm9pZCAwICYmIF9vcHRpb25zJGdsdGYuZGVjb21wcmVzc01lc2hlcykpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgY29uc3Qgc2NlbmVncmFwaCA9IG5ldyBTY2VuZWdyYXBoKGdsdGZEYXRhKTtcbiAgY29uc3QgcHJvbWlzZXMgPSBbXTtcbiAgZm9yIChjb25zdCBwcmltaXRpdmUgb2YgbWFrZU1lc2hQcmltaXRpdmVJdGVyYXRvcihzY2VuZWdyYXBoKSkge1xuICAgIGlmIChzY2VuZWdyYXBoLmdldE9iamVjdEV4dGVuc2lvbihwcmltaXRpdmUsIEtIUl9EUkFDT19NRVNIX0NPTVBSRVNTSU9OKSkge1xuICAgICAgcHJvbWlzZXMucHVzaChkZWNvbXByZXNzUHJpbWl0aXZlKHNjZW5lZ3JhcGgsIHByaW1pdGl2ZSwgb3B0aW9ucywgY29udGV4dCkpO1xuICAgIH1cbiAgfVxuXG4gIGF3YWl0IFByb21pc2UuYWxsKHByb21pc2VzKTtcblxuICBzY2VuZWdyYXBoLnJlbW92ZUV4dGVuc2lvbihLSFJfRFJBQ09fTUVTSF9DT01QUkVTU0lPTik7XG59XG5leHBvcnQgZnVuY3Rpb24gZW5jb2RlKGdsdGZEYXRhKSB7XG4gIGxldCBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcbiAgY29uc3Qgc2NlbmVncmFwaCA9IG5ldyBTY2VuZWdyYXBoKGdsdGZEYXRhKTtcbiAgZm9yIChjb25zdCBtZXNoIG9mIHNjZW5lZ3JhcGguanNvbi5tZXNoZXMgfHwgW10pIHtcbiAgICBjb21wcmVzc01lc2gobWVzaCwgb3B0aW9ucyk7XG4gICAgc2NlbmVncmFwaC5hZGRSZXF1aXJlZEV4dGVuc2lvbihLSFJfRFJBQ09fTUVTSF9DT01QUkVTU0lPTik7XG4gIH1cbn1cblxuYXN5bmMgZnVuY3Rpb24gZGVjb21wcmVzc1ByaW1pdGl2ZShzY2VuZWdyYXBoLCBwcmltaXRpdmUsIG9wdGlvbnMsIGNvbnRleHQpIHtcbiAgY29uc3QgZHJhY29FeHRlbnNpb24gPSBzY2VuZWdyYXBoLmdldE9iamVjdEV4dGVuc2lvbihwcmltaXRpdmUsIEtIUl9EUkFDT19NRVNIX0NPTVBSRVNTSU9OKTtcbiAgaWYgKCFkcmFjb0V4dGVuc2lvbikge1xuICAgIHJldHVybjtcbiAgfVxuICBjb25zdCBidWZmZXIgPSBzY2VuZWdyYXBoLmdldFR5cGVkQXJyYXlGb3JCdWZmZXJWaWV3KGRyYWNvRXh0ZW5zaW9uLmJ1ZmZlclZpZXcpO1xuICBjb25zdCBidWZmZXJDb3B5ID0gc2xpY2VBcnJheUJ1ZmZlcihidWZmZXIuYnVmZmVyLCBidWZmZXIuYnl0ZU9mZnNldCk7XG5cbiAgY29uc3Qge1xuICAgIHBhcnNlXG4gIH0gPSBjb250ZXh0O1xuICBjb25zdCBkcmFjb09wdGlvbnMgPSB7XG4gICAgLi4ub3B0aW9uc1xuICB9O1xuXG4gIGRlbGV0ZSBkcmFjb09wdGlvbnNbJzNkLXRpbGVzJ107XG4gIGNvbnN0IGRlY29kZWREYXRhID0gYXdhaXQgcGFyc2UoYnVmZmVyQ29weSwgRHJhY29Mb2FkZXIsIGRyYWNvT3B0aW9ucywgY29udGV4dCk7XG4gIGNvbnN0IGRlY29kZWRBdHRyaWJ1dGVzID0gZ2V0R0xURkFjY2Vzc29ycyhkZWNvZGVkRGF0YS5hdHRyaWJ1dGVzKTtcblxuICBmb3IgKGNvbnN0IFthdHRyaWJ1dGVOYW1lLCBkZWNvZGVkQXR0cmlidXRlXSBvZiBPYmplY3QuZW50cmllcyhkZWNvZGVkQXR0cmlidXRlcykpIHtcbiAgICBpZiAoYXR0cmlidXRlTmFtZSBpbiBwcmltaXRpdmUuYXR0cmlidXRlcykge1xuICAgICAgY29uc3QgYWNjZXNzb3JJbmRleCA9IHByaW1pdGl2ZS5hdHRyaWJ1dGVzW2F0dHJpYnV0ZU5hbWVdO1xuICAgICAgY29uc3QgYWNjZXNzb3IgPSBzY2VuZWdyYXBoLmdldEFjY2Vzc29yKGFjY2Vzc29ySW5kZXgpO1xuICAgICAgaWYgKGFjY2Vzc29yICE9PSBudWxsICYmIGFjY2Vzc29yICE9PSB2b2lkIDAgJiYgYWNjZXNzb3IubWluICYmIGFjY2Vzc29yICE9PSBudWxsICYmIGFjY2Vzc29yICE9PSB2b2lkIDAgJiYgYWNjZXNzb3IubWF4KSB7XG4gICAgICAgIGRlY29kZWRBdHRyaWJ1dGUubWluID0gYWNjZXNzb3IubWluO1xuICAgICAgICBkZWNvZGVkQXR0cmlidXRlLm1heCA9IGFjY2Vzc29yLm1heDtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBwcmltaXRpdmUuYXR0cmlidXRlcyA9IGRlY29kZWRBdHRyaWJ1dGVzO1xuICBpZiAoZGVjb2RlZERhdGEuaW5kaWNlcykge1xuICAgIHByaW1pdGl2ZS5pbmRpY2VzID0gZ2V0R0xURkFjY2Vzc29yKGRlY29kZWREYXRhLmluZGljZXMpO1xuICB9XG5cbiAgY2hlY2tQcmltaXRpdmUocHJpbWl0aXZlKTtcbn1cblxuZnVuY3Rpb24gY29tcHJlc3NNZXNoKGF0dHJpYnV0ZXMsIGluZGljZXMpIHtcbiAgdmFyIF9jb250ZXh0JHBhcnNlU3luYztcbiAgbGV0IG1vZGUgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IDQ7XG4gIGxldCBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDMgPyBhcmd1bWVudHNbM10gOiB1bmRlZmluZWQ7XG4gIGxldCBjb250ZXh0ID0gYXJndW1lbnRzLmxlbmd0aCA+IDQgPyBhcmd1bWVudHNbNF0gOiB1bmRlZmluZWQ7XG4gIGlmICghb3B0aW9ucy5EcmFjb1dyaXRlcikge1xuICAgIHRocm93IG5ldyBFcnJvcignb3B0aW9ucy5nbHRmLkRyYWNvV3JpdGVyIG5vdCBwcm92aWRlZCcpO1xuICB9XG5cbiAgY29uc3QgY29tcHJlc3NlZERhdGEgPSBvcHRpb25zLkRyYWNvV3JpdGVyLmVuY29kZVN5bmMoe1xuICAgIGF0dHJpYnV0ZXNcbiAgfSk7XG5cbiAgY29uc3QgZGVjb2RlZERhdGEgPSBjb250ZXh0ID09PSBudWxsIHx8IGNvbnRleHQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IChfY29udGV4dCRwYXJzZVN5bmMgPSBjb250ZXh0LnBhcnNlU3luYykgPT09IG51bGwgfHwgX2NvbnRleHQkcGFyc2VTeW5jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfY29udGV4dCRwYXJzZVN5bmMuY2FsbChjb250ZXh0LCB7XG4gICAgYXR0cmlidXRlc1xuICB9KTtcbiAgY29uc3QgZmF1eEFjY2Vzc29ycyA9IG9wdGlvbnMuX2FkZEZhdXhBdHRyaWJ1dGVzKGRlY29kZWREYXRhLmF0dHJpYnV0ZXMpO1xuICBjb25zdCBidWZmZXJWaWV3SW5kZXggPSBvcHRpb25zLmFkZEJ1ZmZlclZpZXcoY29tcHJlc3NlZERhdGEpO1xuICBjb25zdCBnbFRGTWVzaCA9IHtcbiAgICBwcmltaXRpdmVzOiBbe1xuICAgICAgYXR0cmlidXRlczogZmF1eEFjY2Vzc29ycyxcbiAgICAgIG1vZGUsXG4gICAgICBleHRlbnNpb25zOiB7XG4gICAgICAgIFtLSFJfRFJBQ09fTUVTSF9DT01QUkVTU0lPTl06IHtcbiAgICAgICAgICBidWZmZXJWaWV3OiBidWZmZXJWaWV3SW5kZXgsXG4gICAgICAgICAgYXR0cmlidXRlczogZmF1eEFjY2Vzc29yc1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfV1cbiAgfTtcblxuICByZXR1cm4gZ2xURk1lc2g7XG59XG5cbmZ1bmN0aW9uIGNoZWNrUHJpbWl0aXZlKHByaW1pdGl2ZSkge1xuICBpZiAoIXByaW1pdGl2ZS5hdHRyaWJ1dGVzICYmIE9iamVjdC5rZXlzKHByaW1pdGl2ZS5hdHRyaWJ1dGVzKS5sZW5ndGggPiAwKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdnbFRGOiBFbXB0eSBwcmltaXRpdmUgZGV0ZWN0ZWQ6IERyYWNvIGRlY29tcHJlc3Npb24gZmFpbHVyZT8nKTtcbiAgfVxufVxuZnVuY3Rpb24qIG1ha2VNZXNoUHJpbWl0aXZlSXRlcmF0b3Ioc2NlbmVncmFwaCkge1xuICBmb3IgKGNvbnN0IG1lc2ggb2Ygc2NlbmVncmFwaC5qc29uLm1lc2hlcyB8fCBbXSkge1xuICAgIGZvciAoY29uc3QgcHJpbWl0aXZlIG9mIG1lc2gucHJpbWl0aXZlcykge1xuICAgICAgeWllbGQgcHJpbWl0aXZlO1xuICAgIH1cbiAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9S0hSX2RyYWNvX21lc2hfY29tcHJlc3Npb24uanMubWFwIiwiZXhwb3J0IGNvbnN0IENPTVBPTkVOVFMgPSB7XG4gIFNDQUxBUjogMSxcbiAgVkVDMjogMixcbiAgVkVDMzogMyxcbiAgVkVDNDogNCxcbiAgTUFUMjogNCxcbiAgTUFUMzogOSxcbiAgTUFUNDogMTZcbn07XG5leHBvcnQgY29uc3QgQllURVMgPSB7XG4gIDUxMjA6IDEsXG4gIDUxMjE6IDEsXG4gIDUxMjI6IDIsXG4gIDUxMjM6IDIsXG4gIDUxMjU6IDQsXG4gIDUxMjY6IDRcbn07XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRCeXRlc0Zyb21Db21wb25lbnRUeXBlKGNvbXBvbmVudFR5cGUpIHtcbiAgcmV0dXJuIEJZVEVTW2NvbXBvbmVudFR5cGVdO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGdldFNpemVGcm9tQWNjZXNzb3JUeXBlKHR5cGUpIHtcbiAgcmV0dXJuIENPTVBPTkVOVFNbdHlwZV07XG59XG5leHBvcnQgZnVuY3Rpb24gZ2V0R0xFbnVtRnJvbVNhbXBsZXJQYXJhbWV0ZXIocGFyYW1ldGVyKSB7XG4gIGNvbnN0IEdMX1RFWFRVUkVfTUFHX0ZJTFRFUiA9IDB4MjgwMDtcbiAgY29uc3QgR0xfVEVYVFVSRV9NSU5fRklMVEVSID0gMHgyODAxO1xuICBjb25zdCBHTF9URVhUVVJFX1dSQVBfUyA9IDB4MjgwMjtcbiAgY29uc3QgR0xfVEVYVFVSRV9XUkFQX1QgPSAweDI4MDM7XG4gIGNvbnN0IFBBUkFNRVRFUl9NQVAgPSB7XG4gICAgbWFnRmlsdGVyOiBHTF9URVhUVVJFX01BR19GSUxURVIsXG4gICAgbWluRmlsdGVyOiBHTF9URVhUVVJFX01JTl9GSUxURVIsXG4gICAgd3JhcFM6IEdMX1RFWFRVUkVfV1JBUF9TLFxuICAgIHdyYXBUOiBHTF9URVhUVVJFX1dSQVBfVFxuICB9O1xuICByZXR1cm4gUEFSQU1FVEVSX01BUFtwYXJhbWV0ZXJdO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Z2x0Zi1jb25zdGFudHMuanMubWFwIiwiXG5cbmltcG9ydCB7IFZlY3RvcjMsIE1hdHJpeDMgfSBmcm9tICdAbWF0aC5nbC9jb3JlJztcbmltcG9ydCB7IGdldEFjY2Vzc29yQXJyYXlUeXBlQW5kTGVuZ3RoIH0gZnJvbSAnLi4vZ2x0Zi11dGlscy9nbHRmLXV0aWxzJztcbmltcG9ydCB7IEJZVEVTLCBDT01QT05FTlRTIH0gZnJvbSAnLi4vZ2x0Zi11dGlscy9nbHRmLWNvbnN0YW50cyc7XG5pbXBvcnQgR0xURlNjZW5lZ3JhcGggZnJvbSAnLi4vYXBpL2dsdGYtc2NlbmVncmFwaCc7XG5cbmNvbnN0IEVYVF9NRVNIT1BUX1RSQU5TRk9STSA9ICdLSFJfdGV4dHVyZV90cmFuc2Zvcm0nO1xuZXhwb3J0IGNvbnN0IG5hbWUgPSBFWFRfTUVTSE9QVF9UUkFOU0ZPUk07XG5jb25zdCBzY3JhdGNoVmVjdG9yID0gbmV3IFZlY3RvcjMoKTtcbmNvbnN0IHNjcmF0Y2hSb3RhdGlvbk1hdHJpeCA9IG5ldyBNYXRyaXgzKCk7XG5jb25zdCBzY3JhdGNoU2NhbGVNYXRyaXggPSBuZXcgTWF0cml4MygpO1xuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZGVjb2RlKGdsdGZEYXRhLCBvcHRpb25zKSB7XG4gIGNvbnN0IGdsdGZTY2VuZWdyYXBoID0gbmV3IEdMVEZTY2VuZWdyYXBoKGdsdGZEYXRhKTtcbiAgY29uc3QgZXh0ZW5zaW9uID0gZ2x0ZlNjZW5lZ3JhcGguZ2V0RXh0ZW5zaW9uKEVYVF9NRVNIT1BUX1RSQU5TRk9STSk7XG4gIGlmICghZXh0ZW5zaW9uKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbnN0IG1hdGVyaWFscyA9IGdsdGZEYXRhLmpzb24ubWF0ZXJpYWxzIHx8IFtdO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IG1hdGVyaWFscy5sZW5ndGg7IGkrKykge1xuICAgIHRyYW5zZm9ybVRleENvb3JkcyhpLCBnbHRmRGF0YSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gdHJhbnNmb3JtVGV4Q29vcmRzKG1hdGVyaWFsSW5kZXgsIGdsdGZEYXRhKSB7XG4gIHZhciBfZ2x0ZkRhdGEkanNvbiRtYXRlcmksIF9tYXRlcmlhbCRwYnJNZXRhbGxpYywgX21hdGVyaWFsJHBick1ldGFsbGljMjtcbiAgY29uc3QgcHJvY2Vzc2VkVGV4Q29vcmRzID0gW107XG4gIGNvbnN0IG1hdGVyaWFsID0gKF9nbHRmRGF0YSRqc29uJG1hdGVyaSA9IGdsdGZEYXRhLmpzb24ubWF0ZXJpYWxzKSA9PT0gbnVsbCB8fCBfZ2x0ZkRhdGEkanNvbiRtYXRlcmkgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9nbHRmRGF0YSRqc29uJG1hdGVyaVttYXRlcmlhbEluZGV4XTtcbiAgY29uc3QgYmFzZUNvbG9yVGV4dHVyZSA9IG1hdGVyaWFsID09PSBudWxsIHx8IG1hdGVyaWFsID09PSB2b2lkIDAgPyB2b2lkIDAgOiAoX21hdGVyaWFsJHBick1ldGFsbGljID0gbWF0ZXJpYWwucGJyTWV0YWxsaWNSb3VnaG5lc3MpID09PSBudWxsIHx8IF9tYXRlcmlhbCRwYnJNZXRhbGxpYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX21hdGVyaWFsJHBick1ldGFsbGljLmJhc2VDb2xvclRleHR1cmU7XG4gIGlmIChiYXNlQ29sb3JUZXh0dXJlKSB7XG4gICAgdHJhbnNmb3JtUHJpbWl0aXZlcyhnbHRmRGF0YSwgbWF0ZXJpYWxJbmRleCwgYmFzZUNvbG9yVGV4dHVyZSwgcHJvY2Vzc2VkVGV4Q29vcmRzKTtcbiAgfVxuICBjb25zdCBlbWlzaXZlVGV4dHVyZSA9IG1hdGVyaWFsID09PSBudWxsIHx8IG1hdGVyaWFsID09PSB2b2lkIDAgPyB2b2lkIDAgOiBtYXRlcmlhbC5lbWlzc2l2ZVRleHR1cmU7XG4gIGlmIChlbWlzaXZlVGV4dHVyZSkge1xuICAgIHRyYW5zZm9ybVByaW1pdGl2ZXMoZ2x0ZkRhdGEsIG1hdGVyaWFsSW5kZXgsIGVtaXNpdmVUZXh0dXJlLCBwcm9jZXNzZWRUZXhDb29yZHMpO1xuICB9XG4gIGNvbnN0IG5vcm1hbFRleHR1cmUgPSBtYXRlcmlhbCA9PT0gbnVsbCB8fCBtYXRlcmlhbCA9PT0gdm9pZCAwID8gdm9pZCAwIDogbWF0ZXJpYWwubm9ybWFsVGV4dHVyZTtcbiAgaWYgKG5vcm1hbFRleHR1cmUpIHtcbiAgICB0cmFuc2Zvcm1QcmltaXRpdmVzKGdsdGZEYXRhLCBtYXRlcmlhbEluZGV4LCBub3JtYWxUZXh0dXJlLCBwcm9jZXNzZWRUZXhDb29yZHMpO1xuICB9XG4gIGNvbnN0IG9jY2x1c2lvblRleHR1cmUgPSBtYXRlcmlhbCA9PT0gbnVsbCB8fCBtYXRlcmlhbCA9PT0gdm9pZCAwID8gdm9pZCAwIDogbWF0ZXJpYWwub2NjbHVzaW9uVGV4dHVyZTtcbiAgaWYgKG9jY2x1c2lvblRleHR1cmUpIHtcbiAgICB0cmFuc2Zvcm1QcmltaXRpdmVzKGdsdGZEYXRhLCBtYXRlcmlhbEluZGV4LCBvY2NsdXNpb25UZXh0dXJlLCBwcm9jZXNzZWRUZXhDb29yZHMpO1xuICB9XG4gIGNvbnN0IG1ldGFsbGljUm91Z2huZXNzVGV4dHVyZSA9IG1hdGVyaWFsID09PSBudWxsIHx8IG1hdGVyaWFsID09PSB2b2lkIDAgPyB2b2lkIDAgOiAoX21hdGVyaWFsJHBick1ldGFsbGljMiA9IG1hdGVyaWFsLnBick1ldGFsbGljUm91Z2huZXNzKSA9PT0gbnVsbCB8fCBfbWF0ZXJpYWwkcGJyTWV0YWxsaWMyID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfbWF0ZXJpYWwkcGJyTWV0YWxsaWMyLm1ldGFsbGljUm91Z2huZXNzVGV4dHVyZTtcbiAgaWYgKG1ldGFsbGljUm91Z2huZXNzVGV4dHVyZSkge1xuICAgIHRyYW5zZm9ybVByaW1pdGl2ZXMoZ2x0ZkRhdGEsIG1hdGVyaWFsSW5kZXgsIG1ldGFsbGljUm91Z2huZXNzVGV4dHVyZSwgcHJvY2Vzc2VkVGV4Q29vcmRzKTtcbiAgfVxufVxuXG5mdW5jdGlvbiB0cmFuc2Zvcm1QcmltaXRpdmVzKGdsdGZEYXRhLCBtYXRlcmlhbEluZGV4LCB0ZXh0dXJlLCBwcm9jZXNzZWRUZXhDb29yZHMpIHtcbiAgY29uc3QgdHJhbnNmb3JtUGFyYW1ldGVycyA9IGdldFRyYW5zZm9ybVBhcmFtZXRlcnModGV4dHVyZSwgcHJvY2Vzc2VkVGV4Q29vcmRzKTtcbiAgaWYgKCF0cmFuc2Zvcm1QYXJhbWV0ZXJzKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbnN0IG1lc2hlcyA9IGdsdGZEYXRhLmpzb24ubWVzaGVzIHx8IFtdO1xuICBmb3IgKGNvbnN0IG1lc2ggb2YgbWVzaGVzKSB7XG4gICAgZm9yIChjb25zdCBwcmltaXRpdmUgb2YgbWVzaC5wcmltaXRpdmVzKSB7XG4gICAgICBjb25zdCBtYXRlcmlhbCA9IHByaW1pdGl2ZS5tYXRlcmlhbDtcbiAgICAgIGlmIChOdW1iZXIuaXNGaW5pdGUobWF0ZXJpYWwpICYmIG1hdGVyaWFsSW5kZXggPT09IG1hdGVyaWFsKSB7XG4gICAgICAgIHRyYW5zZm9ybVByaW1pdGl2ZShnbHRmRGF0YSwgcHJpbWl0aXZlLCB0cmFuc2Zvcm1QYXJhbWV0ZXJzKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gZ2V0VHJhbnNmb3JtUGFyYW1ldGVycyh0ZXh0dXJlLCBwcm9jZXNzZWRUZXhDb29yZHMpIHtcbiAgdmFyIF90ZXh0dXJlJGV4dGVuc2lvbnM7XG4gIGNvbnN0IHRleHR1cmVJbmZvID0gKF90ZXh0dXJlJGV4dGVuc2lvbnMgPSB0ZXh0dXJlLmV4dGVuc2lvbnMpID09PSBudWxsIHx8IF90ZXh0dXJlJGV4dGVuc2lvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF90ZXh0dXJlJGV4dGVuc2lvbnNbRVhUX01FU0hPUFRfVFJBTlNGT1JNXTtcbiAgY29uc3Qge1xuICAgIHRleENvb3JkOiBvcmlnaW5hbFRleENvb3JkID0gMFxuICB9ID0gdGV4dHVyZTtcbiAgY29uc3Qge1xuICAgIHRleENvb3JkID0gb3JpZ2luYWxUZXhDb29yZFxuICB9ID0gdGV4dHVyZUluZm87XG4gIGNvbnN0IGlzUHJvY2Vzc2VkID0gcHJvY2Vzc2VkVGV4Q29vcmRzLmZpbmRJbmRleChfcmVmID0+IHtcbiAgICBsZXQgW29yaWdpbmFsLCBuZXdUZXhDb29yZF0gPSBfcmVmO1xuICAgIHJldHVybiBvcmlnaW5hbCA9PT0gb3JpZ2luYWxUZXhDb29yZCAmJiBuZXdUZXhDb29yZCA9PT0gdGV4Q29vcmQ7XG4gIH0pICE9PSAtMTtcbiAgaWYgKCFpc1Byb2Nlc3NlZCkge1xuICAgIGNvbnN0IG1hdHJpeCA9IG1ha2VUcmFuc2Zvcm1hdGlvbk1hdHJpeCh0ZXh0dXJlSW5mbyk7XG4gICAgaWYgKG9yaWdpbmFsVGV4Q29vcmQgIT09IHRleENvb3JkKSB7XG4gICAgICB0ZXh0dXJlLnRleENvb3JkID0gdGV4Q29vcmQ7XG4gICAgfVxuICAgIHByb2Nlc3NlZFRleENvb3Jkcy5wdXNoKFtvcmlnaW5hbFRleENvb3JkLCB0ZXhDb29yZF0pO1xuICAgIHJldHVybiB7XG4gICAgICBvcmlnaW5hbFRleENvb3JkLFxuICAgICAgdGV4Q29vcmQsXG4gICAgICBtYXRyaXhcbiAgICB9O1xuICB9XG4gIHJldHVybiBudWxsO1xufVxuXG5mdW5jdGlvbiB0cmFuc2Zvcm1QcmltaXRpdmUoZ2x0ZkRhdGEsIHByaW1pdGl2ZSwgdHJhbnNmb3JtUGFyYW1ldGVycykge1xuICBjb25zdCB7XG4gICAgb3JpZ2luYWxUZXhDb29yZCxcbiAgICB0ZXhDb29yZCxcbiAgICBtYXRyaXhcbiAgfSA9IHRyYW5zZm9ybVBhcmFtZXRlcnM7XG4gIGNvbnN0IHRleENvb3JkQWNjZXNzb3IgPSBwcmltaXRpdmUuYXR0cmlidXRlc1tcIlRFWENPT1JEX1wiLmNvbmNhdChvcmlnaW5hbFRleENvb3JkKV07XG4gIGlmIChOdW1iZXIuaXNGaW5pdGUodGV4Q29vcmRBY2Nlc3NvcikpIHtcbiAgICB2YXIgX2dsdGZEYXRhJGpzb24kYWNjZXNzO1xuICAgIGNvbnN0IGFjY2Vzc29yID0gKF9nbHRmRGF0YSRqc29uJGFjY2VzcyA9IGdsdGZEYXRhLmpzb24uYWNjZXNzb3JzKSA9PT0gbnVsbCB8fCBfZ2x0ZkRhdGEkanNvbiRhY2Nlc3MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9nbHRmRGF0YSRqc29uJGFjY2Vzc1t0ZXhDb29yZEFjY2Vzc29yXTtcbiAgICBpZiAoYWNjZXNzb3IgJiYgYWNjZXNzb3IuYnVmZmVyVmlldykge1xuICAgICAgdmFyIF9nbHRmRGF0YSRqc29uJGJ1ZmZlcjtcbiAgICAgIGNvbnN0IGJ1ZmZlclZpZXcgPSAoX2dsdGZEYXRhJGpzb24kYnVmZmVyID0gZ2x0ZkRhdGEuanNvbi5idWZmZXJWaWV3cykgPT09IG51bGwgfHwgX2dsdGZEYXRhJGpzb24kYnVmZmVyID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZ2x0ZkRhdGEkanNvbiRidWZmZXJbYWNjZXNzb3IuYnVmZmVyVmlld107XG4gICAgICBpZiAoYnVmZmVyVmlldykge1xuICAgICAgICBjb25zdCB7XG4gICAgICAgICAgYXJyYXlCdWZmZXIsXG4gICAgICAgICAgYnl0ZU9mZnNldDogYnVmZmVyQnl0ZU9mZnNldFxuICAgICAgICB9ID0gZ2x0ZkRhdGEuYnVmZmVyc1tidWZmZXJWaWV3LmJ1ZmZlcl07XG4gICAgICAgIGNvbnN0IGJ5dGVPZmZzZXQgPSAoYnVmZmVyQnl0ZU9mZnNldCB8fCAwKSArIChhY2Nlc3Nvci5ieXRlT2Zmc2V0IHx8IDApICsgKGJ1ZmZlclZpZXcuYnl0ZU9mZnNldCB8fCAwKTtcbiAgICAgICAgY29uc3Qge1xuICAgICAgICAgIEFycmF5VHlwZSxcbiAgICAgICAgICBsZW5ndGhcbiAgICAgICAgfSA9IGdldEFjY2Vzc29yQXJyYXlUeXBlQW5kTGVuZ3RoKGFjY2Vzc29yLCBidWZmZXJWaWV3KTtcbiAgICAgICAgY29uc3QgYnl0ZXMgPSBCWVRFU1thY2Nlc3Nvci5jb21wb25lbnRUeXBlXTtcbiAgICAgICAgY29uc3QgY29tcG9uZW50cyA9IENPTVBPTkVOVFNbYWNjZXNzb3IudHlwZV07XG4gICAgICAgIGNvbnN0IGVsZW1lbnRBZGRyZXNzU2NhbGUgPSBidWZmZXJWaWV3LmJ5dGVTdHJpZGUgfHwgYnl0ZXMgKiBjb21wb25lbnRzO1xuICAgICAgICBjb25zdCByZXN1bHQgPSBuZXcgRmxvYXQzMkFycmF5KGxlbmd0aCk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYWNjZXNzb3IuY291bnQ7IGkrKykge1xuICAgICAgICAgIGNvbnN0IHV2ID0gbmV3IEFycmF5VHlwZShhcnJheUJ1ZmZlciwgYnl0ZU9mZnNldCArIGkgKiBlbGVtZW50QWRkcmVzc1NjYWxlLCAyKTtcbiAgICAgICAgICBzY3JhdGNoVmVjdG9yLnNldCh1dlswXSwgdXZbMV0sIDEpO1xuICAgICAgICAgIHNjcmF0Y2hWZWN0b3IudHJhbnNmb3JtQnlNYXRyaXgzKG1hdHJpeCk7XG4gICAgICAgICAgcmVzdWx0LnNldChbc2NyYXRjaFZlY3RvclswXSwgc2NyYXRjaFZlY3RvclsxXV0sIGkgKiBjb21wb25lbnRzKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob3JpZ2luYWxUZXhDb29yZCA9PT0gdGV4Q29vcmQpIHtcbiAgICAgICAgICB1cGRhdGVHbHRmKGFjY2Vzc29yLCBidWZmZXJWaWV3LCBnbHRmRGF0YS5idWZmZXJzLCByZXN1bHQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNyZWF0ZUF0dHJpYnV0ZSh0ZXhDb29yZCwgYWNjZXNzb3IsIHByaW1pdGl2ZSwgZ2x0ZkRhdGEsIHJlc3VsdCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gdXBkYXRlR2x0ZihhY2Nlc3NvciwgYnVmZmVyVmlldywgYnVmZmVycywgbmV3VGV4Q29vcmRBcnJheSkge1xuICBhY2Nlc3Nvci5jb21wb25lbnRUeXBlID0gNTEyNjtcbiAgYnVmZmVycy5wdXNoKHtcbiAgICBhcnJheUJ1ZmZlcjogbmV3VGV4Q29vcmRBcnJheS5idWZmZXIsXG4gICAgYnl0ZU9mZnNldDogMCxcbiAgICBieXRlTGVuZ3RoOiBuZXdUZXhDb29yZEFycmF5LmJ1ZmZlci5ieXRlTGVuZ3RoXG4gIH0pO1xuICBidWZmZXJWaWV3LmJ1ZmZlciA9IGJ1ZmZlcnMubGVuZ3RoIC0gMTtcbiAgYnVmZmVyVmlldy5ieXRlTGVuZ3RoID0gbmV3VGV4Q29vcmRBcnJheS5idWZmZXIuYnl0ZUxlbmd0aDtcbiAgYnVmZmVyVmlldy5ieXRlT2Zmc2V0ID0gMDtcbiAgZGVsZXRlIGJ1ZmZlclZpZXcuYnl0ZVN0cmlkZTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlQXR0cmlidXRlKG5ld1RleENvb3JkLCBvcmlnaW5hbEFjY2Vzc29yLCBwcmltaXRpdmUsIGdsdGZEYXRhLCBuZXdUZXhDb29yZEFycmF5KSB7XG4gIGdsdGZEYXRhLmJ1ZmZlcnMucHVzaCh7XG4gICAgYXJyYXlCdWZmZXI6IG5ld1RleENvb3JkQXJyYXkuYnVmZmVyLFxuICAgIGJ5dGVPZmZzZXQ6IDAsXG4gICAgYnl0ZUxlbmd0aDogbmV3VGV4Q29vcmRBcnJheS5idWZmZXIuYnl0ZUxlbmd0aFxuICB9KTtcbiAgY29uc3QgYnVmZmVyVmlld3MgPSBnbHRmRGF0YS5qc29uLmJ1ZmZlclZpZXdzO1xuICBpZiAoIWJ1ZmZlclZpZXdzKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGJ1ZmZlclZpZXdzLnB1c2goe1xuICAgIGJ1ZmZlcjogZ2x0ZkRhdGEuYnVmZmVycy5sZW5ndGggLSAxLFxuICAgIGJ5dGVMZW5ndGg6IG5ld1RleENvb3JkQXJyYXkuYnVmZmVyLmJ5dGVMZW5ndGgsXG4gICAgYnl0ZU9mZnNldDogMFxuICB9KTtcbiAgY29uc3QgYWNjZXNzb3JzID0gZ2x0ZkRhdGEuanNvbi5hY2Nlc3NvcnM7XG4gIGlmICghYWNjZXNzb3JzKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGFjY2Vzc29ycy5wdXNoKHtcbiAgICBidWZmZXJWaWV3OiAoYnVmZmVyVmlld3MgPT09IG51bGwgfHwgYnVmZmVyVmlld3MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGJ1ZmZlclZpZXdzLmxlbmd0aCkgLSAxLFxuICAgIGJ5dGVPZmZzZXQ6IDAsXG4gICAgY29tcG9uZW50VHlwZTogNTEyNixcbiAgICBjb3VudDogb3JpZ2luYWxBY2Nlc3Nvci5jb3VudCxcbiAgICB0eXBlOiAnVkVDMidcbiAgfSk7XG4gIHByaW1pdGl2ZS5hdHRyaWJ1dGVzW1wiVEVYQ09PUkRfXCIuY29uY2F0KG5ld1RleENvb3JkKV0gPSBhY2Nlc3NvcnMubGVuZ3RoIC0gMTtcbn1cblxuZnVuY3Rpb24gbWFrZVRyYW5zZm9ybWF0aW9uTWF0cml4KGV4dGVuc2lvbkRhdGEpIHtcbiAgY29uc3Qge1xuICAgIG9mZnNldCA9IFswLCAwXSxcbiAgICByb3RhdGlvbiA9IDAsXG4gICAgc2NhbGUgPSBbMSwgMV1cbiAgfSA9IGV4dGVuc2lvbkRhdGE7XG4gIGNvbnN0IHRyYW5zbGF0aW9uTWF0aXJ4ID0gbmV3IE1hdHJpeDMoKS5zZXQoMSwgMCwgMCwgMCwgMSwgMCwgb2Zmc2V0WzBdLCBvZmZzZXRbMV0sIDEpO1xuICBjb25zdCByb3RhdGlvbk1hdGlyeCA9IHNjcmF0Y2hSb3RhdGlvbk1hdHJpeC5zZXQoTWF0aC5jb3Mocm90YXRpb24pLCBNYXRoLnNpbihyb3RhdGlvbiksIDAsIC1NYXRoLnNpbihyb3RhdGlvbiksIE1hdGguY29zKHJvdGF0aW9uKSwgMCwgMCwgMCwgMSk7XG4gIGNvbnN0IHNjYWxlTWF0cml4ID0gc2NyYXRjaFNjYWxlTWF0cml4LnNldChzY2FsZVswXSwgMCwgMCwgMCwgc2NhbGVbMV0sIDAsIDAsIDAsIDEpO1xuICByZXR1cm4gdHJhbnNsYXRpb25NYXRpcngubXVsdGlwbHlSaWdodChyb3RhdGlvbk1hdGlyeCkubXVsdGlwbHlSaWdodChzY2FsZU1hdHJpeCk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1LSFJfdGV4dHVyZV90cmFuc2Zvcm0uanMubWFwIiwiXG5cbmltcG9ydCB7IGFzc2VydCB9IGZyb20gJy4uLy4uL3V0aWxzL2Fzc2VydCc7XG5pbXBvcnQgR0xURlNjZW5lZ3JhcGggZnJvbSAnLi4vLi4vYXBpL2dsdGYtc2NlbmVncmFwaCc7XG5jb25zdCBLSFJfTElHSFRTX1BVTkNUVUFMID0gJ0tIUl9saWdodHNfcHVuY3R1YWwnO1xuZXhwb3J0IGNvbnN0IG5hbWUgPSBLSFJfTElHSFRTX1BVTkNUVUFMO1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGRlY29kZShnbHRmRGF0YSkge1xuICBjb25zdCBnbHRmU2NlbmVncmFwaCA9IG5ldyBHTFRGU2NlbmVncmFwaChnbHRmRGF0YSk7XG4gIGNvbnN0IHtcbiAgICBqc29uXG4gIH0gPSBnbHRmU2NlbmVncmFwaDtcblxuICBjb25zdCBleHRlbnNpb24gPSBnbHRmU2NlbmVncmFwaC5nZXRFeHRlbnNpb24oS0hSX0xJR0hUU19QVU5DVFVBTCk7XG4gIGlmIChleHRlbnNpb24pIHtcbiAgICBnbHRmU2NlbmVncmFwaC5qc29uLmxpZ2h0cyA9IGV4dGVuc2lvbi5saWdodHM7XG4gICAgZ2x0ZlNjZW5lZ3JhcGgucmVtb3ZlRXh0ZW5zaW9uKEtIUl9MSUdIVFNfUFVOQ1RVQUwpO1xuICB9XG5cbiAgZm9yIChjb25zdCBub2RlIG9mIGpzb24ubm9kZXMgfHwgW10pIHtcbiAgICBjb25zdCBub2RlRXh0ZW5zaW9uID0gZ2x0ZlNjZW5lZ3JhcGguZ2V0T2JqZWN0RXh0ZW5zaW9uKG5vZGUsIEtIUl9MSUdIVFNfUFVOQ1RVQUwpO1xuICAgIGlmIChub2RlRXh0ZW5zaW9uKSB7XG4gICAgICBub2RlLmxpZ2h0ID0gbm9kZUV4dGVuc2lvbi5saWdodDtcbiAgICB9XG4gICAgZ2x0ZlNjZW5lZ3JhcGgucmVtb3ZlT2JqZWN0RXh0ZW5zaW9uKG5vZGUsIEtIUl9MSUdIVFNfUFVOQ1RVQUwpO1xuICB9XG59XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBlbmNvZGUoZ2x0ZkRhdGEpIHtcbiAgY29uc3QgZ2x0ZlNjZW5lZ3JhcGggPSBuZXcgR0xURlNjZW5lZ3JhcGgoZ2x0ZkRhdGEpO1xuICBjb25zdCB7XG4gICAganNvblxuICB9ID0gZ2x0ZlNjZW5lZ3JhcGg7XG5cbiAgaWYgKGpzb24ubGlnaHRzKSB7XG4gICAgY29uc3QgZXh0ZW5zaW9uID0gZ2x0ZlNjZW5lZ3JhcGguYWRkRXh0ZW5zaW9uKEtIUl9MSUdIVFNfUFVOQ1RVQUwpO1xuICAgIGFzc2VydCghZXh0ZW5zaW9uLmxpZ2h0cyk7XG4gICAgZXh0ZW5zaW9uLmxpZ2h0cyA9IGpzb24ubGlnaHRzO1xuICAgIGRlbGV0ZSBqc29uLmxpZ2h0cztcbiAgfVxuXG4gIGlmIChnbHRmU2NlbmVncmFwaC5qc29uLmxpZ2h0cykge1xuICAgIGZvciAoY29uc3QgbGlnaHQgb2YgZ2x0ZlNjZW5lZ3JhcGguanNvbi5saWdodHMpIHtcbiAgICAgIGNvbnN0IG5vZGUgPSBsaWdodC5ub2RlO1xuICAgICAgZ2x0ZlNjZW5lZ3JhcGguYWRkT2JqZWN0RXh0ZW5zaW9uKG5vZGUsIEtIUl9MSUdIVFNfUFVOQ1RVQUwsIGxpZ2h0KTtcbiAgICB9XG4gICAgZGVsZXRlIGdsdGZTY2VuZWdyYXBoLmpzb24ubGlnaHRzO1xuICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1LSFJfbGlnaHRzX3B1bmN0dWFsLmpzLm1hcCIsIlxuXG5pbXBvcnQgR0xURlNjZW5lZ3JhcGggZnJvbSAnLi4vLi4vYXBpL2dsdGYtc2NlbmVncmFwaCc7XG5jb25zdCBLSFJfTUFURVJJQUxTX1VOTElUID0gJ0tIUl9tYXRlcmlhbHNfdW5saXQnO1xuZXhwb3J0IGNvbnN0IG5hbWUgPSBLSFJfTUFURVJJQUxTX1VOTElUO1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGRlY29kZShnbHRmRGF0YSkge1xuICBjb25zdCBnbHRmU2NlbmVncmFwaCA9IG5ldyBHTFRGU2NlbmVncmFwaChnbHRmRGF0YSk7XG4gIGNvbnN0IHtcbiAgICBqc29uXG4gIH0gPSBnbHRmU2NlbmVncmFwaDtcblxuICBmb3IgKGNvbnN0IG1hdGVyaWFsIG9mIGpzb24ubWF0ZXJpYWxzIHx8IFtdKSB7XG4gICAgY29uc3QgZXh0ZW5zaW9uID0gbWF0ZXJpYWwuZXh0ZW5zaW9ucyAmJiBtYXRlcmlhbC5leHRlbnNpb25zLktIUl9tYXRlcmlhbHNfdW5saXQ7XG4gICAgaWYgKGV4dGVuc2lvbikge1xuICAgICAgbWF0ZXJpYWwudW5saXQgPSB0cnVlO1xuICAgIH1cbiAgICBnbHRmU2NlbmVncmFwaC5yZW1vdmVPYmplY3RFeHRlbnNpb24obWF0ZXJpYWwsIEtIUl9NQVRFUklBTFNfVU5MSVQpO1xuICB9XG5cbiAgZ2x0ZlNjZW5lZ3JhcGgucmVtb3ZlRXh0ZW5zaW9uKEtIUl9NQVRFUklBTFNfVU5MSVQpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGVuY29kZShnbHRmRGF0YSkge1xuICBjb25zdCBnbHRmU2NlbmVncmFwaCA9IG5ldyBHTFRGU2NlbmVncmFwaChnbHRmRGF0YSk7XG4gIGNvbnN0IHtcbiAgICBqc29uXG4gIH0gPSBnbHRmU2NlbmVncmFwaDtcblxuICBpZiAoZ2x0ZlNjZW5lZ3JhcGgubWF0ZXJpYWxzKSB7XG4gICAgZm9yIChjb25zdCBtYXRlcmlhbCBvZiBqc29uLm1hdGVyaWFscyB8fCBbXSkge1xuICAgICAgaWYgKG1hdGVyaWFsLnVubGl0KSB7XG4gICAgICAgIGRlbGV0ZSBtYXRlcmlhbC51bmxpdDtcbiAgICAgICAgZ2x0ZlNjZW5lZ3JhcGguYWRkT2JqZWN0RXh0ZW5zaW9uKG1hdGVyaWFsLCBLSFJfTUFURVJJQUxTX1VOTElULCB7fSk7XG4gICAgICAgIGdsdGZTY2VuZWdyYXBoLmFkZEV4dGVuc2lvbihLSFJfTUFURVJJQUxTX1VOTElUKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUtIUl9tYXRlcmlhbHNfdW5saXQuanMubWFwIiwiXG5cbmltcG9ydCBHTFRGU2NlbmVncmFwaCBmcm9tICcuLi8uLi9hcGkvZ2x0Zi1zY2VuZWdyYXBoJztcbmNvbnN0IEtIUl9URUNITklRVUVTX1dFQkdMID0gJ0tIUl90ZWNobmlxdWVzX3dlYmdsJztcbmV4cG9ydCBjb25zdCBuYW1lID0gS0hSX1RFQ0hOSVFVRVNfV0VCR0w7XG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZGVjb2RlKGdsdGZEYXRhKSB7XG4gIGNvbnN0IGdsdGZTY2VuZWdyYXBoID0gbmV3IEdMVEZTY2VuZWdyYXBoKGdsdGZEYXRhKTtcbiAgY29uc3Qge1xuICAgIGpzb25cbiAgfSA9IGdsdGZTY2VuZWdyYXBoO1xuICBjb25zdCBleHRlbnNpb24gPSBnbHRmU2NlbmVncmFwaC5nZXRFeHRlbnNpb24oS0hSX1RFQ0hOSVFVRVNfV0VCR0wpO1xuICBpZiAoZXh0ZW5zaW9uKSB7XG4gICAgY29uc3QgdGVjaG5pcXVlcyA9IHJlc29sdmVUZWNobmlxdWVzKGV4dGVuc2lvbiwgZ2x0ZlNjZW5lZ3JhcGgpO1xuICAgIGZvciAoY29uc3QgbWF0ZXJpYWwgb2YganNvbi5tYXRlcmlhbHMgfHwgW10pIHtcbiAgICAgIGNvbnN0IG1hdGVyaWFsRXh0ZW5zaW9uID0gZ2x0ZlNjZW5lZ3JhcGguZ2V0T2JqZWN0RXh0ZW5zaW9uKG1hdGVyaWFsLCBLSFJfVEVDSE5JUVVFU19XRUJHTCk7XG4gICAgICBpZiAobWF0ZXJpYWxFeHRlbnNpb24pIHtcbiAgICAgICAgbWF0ZXJpYWwudGVjaG5pcXVlID0gT2JqZWN0LmFzc2lnbih7fSwgbWF0ZXJpYWxFeHRlbnNpb24sXG4gICAgICAgIHRlY2huaXF1ZXNbbWF0ZXJpYWxFeHRlbnNpb24udGVjaG5pcXVlXSk7XG4gICAgICAgIG1hdGVyaWFsLnRlY2huaXF1ZS52YWx1ZXMgPSByZXNvbHZlVmFsdWVzKG1hdGVyaWFsLnRlY2huaXF1ZSwgZ2x0ZlNjZW5lZ3JhcGgpO1xuICAgICAgfVxuICAgICAgZ2x0ZlNjZW5lZ3JhcGgucmVtb3ZlT2JqZWN0RXh0ZW5zaW9uKG1hdGVyaWFsLCBLSFJfVEVDSE5JUVVFU19XRUJHTCk7XG4gICAgfVxuXG4gICAgZ2x0ZlNjZW5lZ3JhcGgucmVtb3ZlRXh0ZW5zaW9uKEtIUl9URUNITklRVUVTX1dFQkdMKTtcbiAgfVxufVxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGVuY29kZShnbHRmRGF0YSwgb3B0aW9ucykge1xufVxuZnVuY3Rpb24gcmVzb2x2ZVRlY2huaXF1ZXModGVjaG5pcXVlc0V4dGVuc2lvbixcbmdsdGZTY2VuZWdyYXBoKSB7XG4gIGNvbnN0IHtcbiAgICBwcm9ncmFtcyA9IFtdLFxuICAgIHNoYWRlcnMgPSBbXSxcbiAgICB0ZWNobmlxdWVzID0gW11cbiAgfSA9IHRlY2huaXF1ZXNFeHRlbnNpb247XG4gIGNvbnN0IHRleHREZWNvZGVyID0gbmV3IFRleHREZWNvZGVyKCk7XG4gIHNoYWRlcnMuZm9yRWFjaChzaGFkZXIgPT4ge1xuICAgIGlmIChOdW1iZXIuaXNGaW5pdGUoc2hhZGVyLmJ1ZmZlclZpZXcpKSB7XG4gICAgICBzaGFkZXIuY29kZSA9IHRleHREZWNvZGVyLmRlY29kZShnbHRmU2NlbmVncmFwaC5nZXRUeXBlZEFycmF5Rm9yQnVmZmVyVmlldyhzaGFkZXIuYnVmZmVyVmlldykpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0tIUl90ZWNobmlxdWVzX3dlYmdsOiBubyBzaGFkZXIgY29kZScpO1xuICAgIH1cbiAgfSk7XG4gIHByb2dyYW1zLmZvckVhY2gocHJvZ3JhbSA9PiB7XG4gICAgcHJvZ3JhbS5mcmFnbWVudFNoYWRlciA9IHNoYWRlcnNbcHJvZ3JhbS5mcmFnbWVudFNoYWRlcl07XG4gICAgcHJvZ3JhbS52ZXJ0ZXhTaGFkZXIgPSBzaGFkZXJzW3Byb2dyYW0udmVydGV4U2hhZGVyXTtcbiAgfSk7XG4gIHRlY2huaXF1ZXMuZm9yRWFjaCh0ZWNobmlxdWUgPT4ge1xuICAgIHRlY2huaXF1ZS5wcm9ncmFtID0gcHJvZ3JhbXNbdGVjaG5pcXVlLnByb2dyYW1dO1xuICB9KTtcbiAgcmV0dXJuIHRlY2huaXF1ZXM7XG59XG5mdW5jdGlvbiByZXNvbHZlVmFsdWVzKHRlY2huaXF1ZSwgZ2x0ZlNjZW5lZ3JhcGgpIHtcbiAgY29uc3QgdmFsdWVzID0gT2JqZWN0LmFzc2lnbih7fSwgdGVjaG5pcXVlLnZhbHVlcyk7XG5cbiAgT2JqZWN0LmtleXModGVjaG5pcXVlLnVuaWZvcm1zIHx8IHt9KS5mb3JFYWNoKHVuaWZvcm0gPT4ge1xuICAgIGlmICh0ZWNobmlxdWUudW5pZm9ybXNbdW5pZm9ybV0udmFsdWUgJiYgISh1bmlmb3JtIGluIHZhbHVlcykpIHtcbiAgICAgIHZhbHVlc1t1bmlmb3JtXSA9IHRlY2huaXF1ZS51bmlmb3Jtc1t1bmlmb3JtXS52YWx1ZTtcbiAgICB9XG4gIH0pO1xuXG4gIE9iamVjdC5rZXlzKHZhbHVlcykuZm9yRWFjaCh1bmlmb3JtID0+IHtcbiAgICBpZiAodHlwZW9mIHZhbHVlc1t1bmlmb3JtXSA9PT0gJ29iamVjdCcgJiYgdmFsdWVzW3VuaWZvcm1dLmluZGV4ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHZhbHVlc1t1bmlmb3JtXS50ZXh0dXJlID0gZ2x0ZlNjZW5lZ3JhcGguZ2V0VGV4dHVyZSh2YWx1ZXNbdW5pZm9ybV0uaW5kZXgpO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiB2YWx1ZXM7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1LSFJfdGVjaG5pcXVlc193ZWJnbC5qcy5tYXAiLCJcblxuaW1wb3J0IEdMVEZTY2VuZWdyYXBoIGZyb20gJy4uLy4uL2FwaS9nbHRmLXNjZW5lZ3JhcGgnO1xuY29uc3QgRVhUX0ZFQVRVUkVfTUVUQURBVEEgPSAnRVhUX2ZlYXR1cmVfbWV0YWRhdGEnO1xuZXhwb3J0IGNvbnN0IG5hbWUgPSBFWFRfRkVBVFVSRV9NRVRBREFUQTtcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBkZWNvZGUoZ2x0ZkRhdGEpIHtcbiAgY29uc3Qgc2NlbmVncmFwaCA9IG5ldyBHTFRGU2NlbmVncmFwaChnbHRmRGF0YSk7XG4gIGRlY29kZUV4dEZlYXR1cmVNZXRhZGF0YShzY2VuZWdyYXBoKTtcbn1cblxuZnVuY3Rpb24gZGVjb2RlRXh0RmVhdHVyZU1ldGFkYXRhKHNjZW5lZ3JhcGgpIHtcbiAgdmFyIF9leHRlbnNpb24kc2NoZW1hO1xuICBjb25zdCBleHRlbnNpb24gPSBzY2VuZWdyYXBoLmdldEV4dGVuc2lvbihFWFRfRkVBVFVSRV9NRVRBREFUQSk7XG4gIGNvbnN0IHNjaGVtYUNsYXNzZXMgPSBleHRlbnNpb24gPT09IG51bGwgfHwgZXh0ZW5zaW9uID09PSB2b2lkIDAgPyB2b2lkIDAgOiAoX2V4dGVuc2lvbiRzY2hlbWEgPSBleHRlbnNpb24uc2NoZW1hKSA9PT0gbnVsbCB8fCBfZXh0ZW5zaW9uJHNjaGVtYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2V4dGVuc2lvbiRzY2hlbWEuY2xhc3NlcztcbiAgY29uc3QgZmVhdHVyZVRhYmxlcyA9IGV4dGVuc2lvbiA9PT0gbnVsbCB8fCBleHRlbnNpb24gPT09IHZvaWQgMCA/IHZvaWQgMCA6IGV4dGVuc2lvbi5mZWF0dXJlVGFibGVzO1xuICBjb25zdCBmZWF0dXJlVGV4dHVyZXMgPSBleHRlbnNpb24gPT09IG51bGwgfHwgZXh0ZW5zaW9uID09PSB2b2lkIDAgPyB2b2lkIDAgOiBleHRlbnNpb24uZmVhdHVyZVRleHR1cmVzO1xuICBpZiAoZmVhdHVyZVRleHR1cmVzKSB7XG4gICAgY29uc29sZS53YXJuKCdmZWF0dXJlVGV4dHVyZXMgaXMgbm90IHlldCBzdXBwb3J0ZWQgaW4gdGhlIFwiRVhUX2ZlYXR1cmVfbWV0YWRhdGFcIiBleHRlbnNpb24uJyk7XG4gIH1cbiAgaWYgKHNjaGVtYUNsYXNzZXMgJiYgZmVhdHVyZVRhYmxlcykge1xuICAgIGZvciAoY29uc3Qgc2NoZW1hTmFtZSBpbiBzY2hlbWFDbGFzc2VzKSB7XG4gICAgICBjb25zdCBzY2hlbWFDbGFzcyA9IHNjaGVtYUNsYXNzZXNbc2NoZW1hTmFtZV07XG4gICAgICBjb25zdCBmZWF0dXJlVGFibGUgPSBmaW5kRmVhdHVyZVRhYmxlQnlOYW1lKGZlYXR1cmVUYWJsZXMsIHNjaGVtYU5hbWUpO1xuICAgICAgaWYgKGZlYXR1cmVUYWJsZSkge1xuICAgICAgICBoYW5kbGVGZWF0dXJlVGFibGVQcm9wZXJ0aWVzKHNjZW5lZ3JhcGgsIGZlYXR1cmVUYWJsZSwgc2NoZW1hQ2xhc3MpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBoYW5kbGVGZWF0dXJlVGFibGVQcm9wZXJ0aWVzKHNjZW5lZ3JhcGgsIGZlYXR1cmVUYWJsZSwgc2NoZW1hQ2xhc3MpIHtcbiAgZm9yIChjb25zdCBwcm9wZXJ0eU5hbWUgaW4gc2NoZW1hQ2xhc3MucHJvcGVydGllcykge1xuICAgIHZhciBfZmVhdHVyZVRhYmxlJHByb3BlcnQ7XG4gICAgY29uc3Qgc2NoZW1hUHJvcGVydHkgPSBzY2hlbWFDbGFzcy5wcm9wZXJ0aWVzW3Byb3BlcnR5TmFtZV07XG4gICAgY29uc3QgZmVhdHVyZVRhYmxlUHJvcGVydHkgPSBmZWF0dXJlVGFibGUgPT09IG51bGwgfHwgZmVhdHVyZVRhYmxlID09PSB2b2lkIDAgPyB2b2lkIDAgOiAoX2ZlYXR1cmVUYWJsZSRwcm9wZXJ0ID0gZmVhdHVyZVRhYmxlLnByb3BlcnRpZXMpID09PSBudWxsIHx8IF9mZWF0dXJlVGFibGUkcHJvcGVydCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2ZlYXR1cmVUYWJsZSRwcm9wZXJ0W3Byb3BlcnR5TmFtZV07XG4gICAgY29uc3QgbnVtYmVyT2ZGZWF0dXJlcyA9IGZlYXR1cmVUYWJsZS5jb3VudDtcbiAgICBpZiAoZmVhdHVyZVRhYmxlUHJvcGVydHkpIHtcbiAgICAgIGNvbnN0IGRhdGEgPSBnZXRQcm9wZXJ0eURhdGFGcm9tQmluYXJ5U291cmNlKHNjZW5lZ3JhcGgsIHNjaGVtYVByb3BlcnR5LCBudW1iZXJPZkZlYXR1cmVzLCBmZWF0dXJlVGFibGVQcm9wZXJ0eSk7XG4gICAgICBmZWF0dXJlVGFibGVQcm9wZXJ0eS5kYXRhID0gZGF0YTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gZ2V0UHJvcGVydHlEYXRhRnJvbUJpbmFyeVNvdXJjZShzY2VuZWdyYXBoLCBzY2hlbWFQcm9wZXJ0eSwgbnVtYmVyT2ZGZWF0dXJlcywgZmVhdHVyZVRhYmxlUHJvcGVydHkpIHtcbiAgY29uc3QgYnVmZmVyVmlldyA9IGZlYXR1cmVUYWJsZVByb3BlcnR5LmJ1ZmZlclZpZXc7XG4gIGxldCBkYXRhID0gc2NlbmVncmFwaC5nZXRUeXBlZEFycmF5Rm9yQnVmZmVyVmlldyhidWZmZXJWaWV3KTtcbiAgc3dpdGNoIChzY2hlbWFQcm9wZXJ0eS50eXBlKSB7XG4gICAgY2FzZSAnU1RSSU5HJzpcbiAgICAgIHtcbiAgICAgICAgY29uc3Qgc3RyaW5nT2Zmc2V0QnVmZmVyVmlldyA9IGZlYXR1cmVUYWJsZVByb3BlcnR5LnN0cmluZ09mZnNldEJ1ZmZlclZpZXc7XG4gICAgICAgIGNvbnN0IG9mZnNldHNEYXRhID0gc2NlbmVncmFwaC5nZXRUeXBlZEFycmF5Rm9yQnVmZmVyVmlldyhzdHJpbmdPZmZzZXRCdWZmZXJWaWV3KTtcbiAgICAgICAgZGF0YSA9IGdldFN0cmluZ0F0dHJpYnV0ZXMoZGF0YSwgb2Zmc2V0c0RhdGEsIG51bWJlck9mRmVhdHVyZXMpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICBkZWZhdWx0OlxuICB9XG4gIHJldHVybiBkYXRhO1xufVxuXG5mdW5jdGlvbiBmaW5kRmVhdHVyZVRhYmxlQnlOYW1lKGZlYXR1cmVUYWJsZXMsIHNjaGVtYUNsYXNzTmFtZSkge1xuICBmb3IgKGNvbnN0IGZlYXR1cmVUYWJsZU5hbWUgaW4gZmVhdHVyZVRhYmxlcykge1xuICAgIGNvbnN0IGZlYXR1cmVUYWJsZSA9IGZlYXR1cmVUYWJsZXNbZmVhdHVyZVRhYmxlTmFtZV07XG4gICAgaWYgKGZlYXR1cmVUYWJsZS5jbGFzcyA9PT0gc2NoZW1hQ2xhc3NOYW1lKSB7XG4gICAgICByZXR1cm4gZmVhdHVyZVRhYmxlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gbnVsbDtcbn1cblxuZnVuY3Rpb24gZ2V0U3RyaW5nQXR0cmlidXRlcyhkYXRhLCBvZmZzZXRzRGF0YSwgc3RyaW5nc0NvdW50KSB7XG4gIGNvbnN0IHN0cmluZ3NBcnJheSA9IFtdO1xuICBjb25zdCB0ZXh0RGVjb2RlciA9IG5ldyBUZXh0RGVjb2RlcigndXRmOCcpO1xuICBsZXQgc3RyaW5nT2Zmc2V0ID0gMDtcbiAgY29uc3QgYnl0ZXNQZXJTdHJpbmdTaXplID0gNDtcbiAgZm9yIChsZXQgaW5kZXggPSAwOyBpbmRleCA8IHN0cmluZ3NDb3VudDsgaW5kZXgrKykge1xuICAgIGNvbnN0IHN0cmluZ0J5dGVTaXplID0gb2Zmc2V0c0RhdGFbKGluZGV4ICsgMSkgKiBieXRlc1BlclN0cmluZ1NpemVdIC0gb2Zmc2V0c0RhdGFbaW5kZXggKiBieXRlc1BlclN0cmluZ1NpemVdO1xuICAgIGNvbnN0IHN0cmluZ0RhdGEgPSBkYXRhLnN1YmFycmF5KHN0cmluZ09mZnNldCwgc3RyaW5nQnl0ZVNpemUgKyBzdHJpbmdPZmZzZXQpO1xuICAgIGNvbnN0IHN0cmluZ0F0dHJpYnV0ZSA9IHRleHREZWNvZGVyLmRlY29kZShzdHJpbmdEYXRhKTtcbiAgICBzdHJpbmdzQXJyYXkucHVzaChzdHJpbmdBdHRyaWJ1dGUpO1xuICAgIHN0cmluZ09mZnNldCArPSBzdHJpbmdCeXRlU2l6ZTtcbiAgfVxuICByZXR1cm4gc3RyaW5nc0FycmF5O1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9RVhUX2ZlYXR1cmVfbWV0YWRhdGEuanMubWFwIiwiXG5cbmltcG9ydCAqIGFzIEVYVF9tZXNob3B0X2NvbXByZXNzaW9uIGZyb20gJy4uL2V4dGVuc2lvbnMvRVhUX21lc2hvcHRfY29tcHJlc3Npb24nO1xuaW1wb3J0ICogYXMgRVhUX3RleHR1cmVfd2VicCBmcm9tICcuLi9leHRlbnNpb25zL0VYVF90ZXh0dXJlX3dlYnAnO1xuaW1wb3J0ICogYXMgS0hSX3RleHR1cmVfYmFzaXN1IGZyb20gJy4uL2V4dGVuc2lvbnMvS0hSX3RleHR1cmVfYmFzaXN1JztcbmltcG9ydCAqIGFzIEtIUl9kcmFjb19tZXNoX2NvbXByZXNzaW9uIGZyb20gJy4uL2V4dGVuc2lvbnMvS0hSX2RyYWNvX21lc2hfY29tcHJlc3Npb24nO1xuaW1wb3J0ICogYXMgS0hSX3RleHR1cmVfdHJhbnNmb3JtIGZyb20gJy4uL2V4dGVuc2lvbnMvS0hSX3RleHR1cmVfdHJhbnNmb3JtJztcblxuaW1wb3J0ICogYXMgS0hSX2xpZ2h0c19wdW5jdHVhbCBmcm9tICcuLi9leHRlbnNpb25zL2RlcHJlY2F0ZWQvS0hSX2xpZ2h0c19wdW5jdHVhbCc7XG5pbXBvcnQgKiBhcyBLSFJfbWF0ZXJpYWxzX3VubGl0IGZyb20gJy4uL2V4dGVuc2lvbnMvZGVwcmVjYXRlZC9LSFJfbWF0ZXJpYWxzX3VubGl0JztcbmltcG9ydCAqIGFzIEtIUl90ZWNobmlxdWVzX3dlYmdsIGZyb20gJy4uL2V4dGVuc2lvbnMvZGVwcmVjYXRlZC9LSFJfdGVjaG5pcXVlc193ZWJnbCc7XG5pbXBvcnQgKiBhcyBFWFRfZmVhdHVyZV9tZXRhZGF0YSBmcm9tICcuLi9leHRlbnNpb25zL2RlcHJlY2F0ZWQvRVhUX2ZlYXR1cmVfbWV0YWRhdGEnO1xuXG5leHBvcnQgY29uc3QgRVhURU5TSU9OUyA9IFtcblxuRVhUX21lc2hvcHRfY29tcHJlc3Npb24sIEVYVF90ZXh0dXJlX3dlYnAsXG5LSFJfdGV4dHVyZV9iYXNpc3UsIEtIUl9kcmFjb19tZXNoX2NvbXByZXNzaW9uLCBLSFJfbGlnaHRzX3B1bmN0dWFsLCBLSFJfbWF0ZXJpYWxzX3VubGl0LCBLSFJfdGVjaG5pcXVlc193ZWJnbCwgS0hSX3RleHR1cmVfdHJhbnNmb3JtLCBFWFRfZmVhdHVyZV9tZXRhZGF0YV07XG5cbmV4cG9ydCBmdW5jdGlvbiBwcmVwcm9jZXNzRXh0ZW5zaW9ucyhnbHRmKSB7XG4gIGxldCBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcbiAgbGV0IGNvbnRleHQgPSBhcmd1bWVudHMubGVuZ3RoID4gMiA/IGFyZ3VtZW50c1syXSA6IHVuZGVmaW5lZDtcbiAgY29uc3QgZXh0ZW5zaW9ucyA9IEVYVEVOU0lPTlMuZmlsdGVyKGV4dGVuc2lvbiA9PiB1c2VFeHRlbnNpb24oZXh0ZW5zaW9uLm5hbWUsIG9wdGlvbnMpKTtcbiAgZm9yIChjb25zdCBleHRlbnNpb24gb2YgZXh0ZW5zaW9ucykge1xuICAgIHZhciBfZXh0ZW5zaW9uJHByZXByb2Nlc3M7XG4gICAgKF9leHRlbnNpb24kcHJlcHJvY2VzcyA9IGV4dGVuc2lvbi5wcmVwcm9jZXNzKSA9PT0gbnVsbCB8fCBfZXh0ZW5zaW9uJHByZXByb2Nlc3MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9leHRlbnNpb24kcHJlcHJvY2Vzcy5jYWxsKGV4dGVuc2lvbiwgZ2x0Ziwgb3B0aW9ucywgY29udGV4dCk7XG4gIH1cbn1cblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGRlY29kZUV4dGVuc2lvbnMoZ2x0Zikge1xuICBsZXQgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG4gIGxldCBjb250ZXh0ID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgPyBhcmd1bWVudHNbMl0gOiB1bmRlZmluZWQ7XG4gIGNvbnN0IGV4dGVuc2lvbnMgPSBFWFRFTlNJT05TLmZpbHRlcihleHRlbnNpb24gPT4gdXNlRXh0ZW5zaW9uKGV4dGVuc2lvbi5uYW1lLCBvcHRpb25zKSk7XG4gIGZvciAoY29uc3QgZXh0ZW5zaW9uIG9mIGV4dGVuc2lvbnMpIHtcbiAgICB2YXIgX2V4dGVuc2lvbiRkZWNvZGU7XG4gICAgYXdhaXQgKChfZXh0ZW5zaW9uJGRlY29kZSA9IGV4dGVuc2lvbi5kZWNvZGUpID09PSBudWxsIHx8IF9leHRlbnNpb24kZGVjb2RlID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZXh0ZW5zaW9uJGRlY29kZS5jYWxsKGV4dGVuc2lvbiwgZ2x0Ziwgb3B0aW9ucywgY29udGV4dCkpO1xuICB9XG59XG5mdW5jdGlvbiB1c2VFeHRlbnNpb24oZXh0ZW5zaW9uTmFtZSwgb3B0aW9ucykge1xuICB2YXIgX29wdGlvbnMkZ2x0ZjtcbiAgY29uc3QgZXhjbHVkZXMgPSAob3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiAoX29wdGlvbnMkZ2x0ZiA9IG9wdGlvbnMuZ2x0ZikgPT09IG51bGwgfHwgX29wdGlvbnMkZ2x0ZiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX29wdGlvbnMkZ2x0Zi5leGNsdWRlRXh0ZW5zaW9ucykgfHwge307XG4gIGNvbnN0IGV4Y2x1ZGUgPSBleHRlbnNpb25OYW1lIGluIGV4Y2x1ZGVzICYmICFleGNsdWRlc1tleHRlbnNpb25OYW1lXTtcbiAgcmV0dXJuICFleGNsdWRlO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Z2x0Zi1leHRlbnNpb25zLmpzLm1hcCIsIlxuXG5pbXBvcnQgR0xURlNjZW5lZ3JhcGggZnJvbSAnLi4vYXBpL2dsdGYtc2NlbmVncmFwaCc7XG5jb25zdCBLSFJfQklOQVJZX0dMVEYgPSAnS0hSX2JpbmFyeV9nbFRGJztcblxuZXhwb3J0IGNvbnN0IG5hbWUgPSBLSFJfQklOQVJZX0dMVEY7XG5leHBvcnQgZnVuY3Rpb24gcHJlcHJvY2VzcyhnbHRmRGF0YSkge1xuICBjb25zdCBnbHRmU2NlbmVncmFwaCA9IG5ldyBHTFRGU2NlbmVncmFwaChnbHRmRGF0YSk7XG4gIGNvbnN0IHtcbiAgICBqc29uXG4gIH0gPSBnbHRmU2NlbmVncmFwaDtcblxuICBmb3IgKGNvbnN0IGltYWdlIG9mIGpzb24uaW1hZ2VzIHx8IFtdKSB7XG4gICAgY29uc3QgZXh0ZW5zaW9uID0gZ2x0ZlNjZW5lZ3JhcGguZ2V0T2JqZWN0RXh0ZW5zaW9uKGltYWdlLCBLSFJfQklOQVJZX0dMVEYpO1xuICAgIGlmIChleHRlbnNpb24pIHtcbiAgICAgIE9iamVjdC5hc3NpZ24oaW1hZ2UsIGV4dGVuc2lvbik7XG4gICAgfVxuICAgIGdsdGZTY2VuZWdyYXBoLnJlbW92ZU9iamVjdEV4dGVuc2lvbihpbWFnZSwgS0hSX0JJTkFSWV9HTFRGKTtcbiAgfVxuXG4gIGlmIChqc29uLmJ1ZmZlcnMgJiYganNvbi5idWZmZXJzWzBdKSB7XG4gICAgZGVsZXRlIGpzb24uYnVmZmVyc1swXS51cmk7XG4gIH1cblxuICBnbHRmU2NlbmVncmFwaC5yZW1vdmVFeHRlbnNpb24oS0hSX0JJTkFSWV9HTFRGKTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUtIUl9iaW5hcnlfZ2x0Zi5qcy5tYXAiLCJpbXBvcnQgX2RlZmluZVByb3BlcnR5IGZyb20gXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9kZWZpbmVQcm9wZXJ0eVwiO1xuaW1wb3J0ICogYXMgS0hSX2JpbmFyeV9nbFRGIGZyb20gJy4uL2V4dGVuc2lvbnMvS0hSX2JpbmFyeV9nbHRmJztcblxuY29uc3QgR0xURl9BUlJBWVMgPSB7XG4gIGFjY2Vzc29yczogJ2FjY2Vzc29yJyxcbiAgYW5pbWF0aW9uczogJ2FuaW1hdGlvbicsXG4gIGJ1ZmZlcnM6ICdidWZmZXInLFxuICBidWZmZXJWaWV3czogJ2J1ZmZlclZpZXcnLFxuICBpbWFnZXM6ICdpbWFnZScsXG4gIG1hdGVyaWFsczogJ21hdGVyaWFsJyxcbiAgbWVzaGVzOiAnbWVzaCcsXG4gIG5vZGVzOiAnbm9kZScsXG4gIHNhbXBsZXJzOiAnc2FtcGxlcicsXG4gIHNjZW5lczogJ3NjZW5lJyxcbiAgc2tpbnM6ICdza2luJyxcbiAgdGV4dHVyZXM6ICd0ZXh0dXJlJ1xufTtcbmNvbnN0IEdMVEZfS0VZUyA9IHtcbiAgYWNjZXNzb3I6ICdhY2Nlc3NvcnMnLFxuICBhbmltYXRpb25zOiAnYW5pbWF0aW9uJyxcbiAgYnVmZmVyOiAnYnVmZmVycycsXG4gIGJ1ZmZlclZpZXc6ICdidWZmZXJWaWV3cycsXG4gIGltYWdlOiAnaW1hZ2VzJyxcbiAgbWF0ZXJpYWw6ICdtYXRlcmlhbHMnLFxuICBtZXNoOiAnbWVzaGVzJyxcbiAgbm9kZTogJ25vZGVzJyxcbiAgc2FtcGxlcjogJ3NhbXBsZXJzJyxcbiAgc2NlbmU6ICdzY2VuZXMnLFxuICBza2luOiAnc2tpbnMnLFxuICB0ZXh0dXJlOiAndGV4dHVyZXMnXG59O1xuXG5jbGFzcyBHTFRGVjFOb3JtYWxpemVyIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwiaWRUb0luZGV4TWFwXCIsIHtcbiAgICAgIGFuaW1hdGlvbnM6IHt9LFxuICAgICAgYWNjZXNzb3JzOiB7fSxcbiAgICAgIGJ1ZmZlcnM6IHt9LFxuICAgICAgYnVmZmVyVmlld3M6IHt9LFxuICAgICAgaW1hZ2VzOiB7fSxcbiAgICAgIG1hdGVyaWFsczoge30sXG4gICAgICBtZXNoZXM6IHt9LFxuICAgICAgbm9kZXM6IHt9LFxuICAgICAgc2FtcGxlcnM6IHt9LFxuICAgICAgc2NlbmVzOiB7fSxcbiAgICAgIHNraW5zOiB7fSxcbiAgICAgIHRleHR1cmVzOiB7fVxuICAgIH0pO1xuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImpzb25cIiwgdm9pZCAwKTtcbiAgfVxuXG4gIG5vcm1hbGl6ZShnbHRmLCBvcHRpb25zKSB7XG4gICAgdGhpcy5qc29uID0gZ2x0Zi5qc29uO1xuICAgIGNvbnN0IGpzb24gPSBnbHRmLmpzb247XG5cbiAgICBzd2l0Y2ggKGpzb24uYXNzZXQgJiYganNvbi5hc3NldC52ZXJzaW9uKSB7XG4gICAgICBjYXNlICcyLjAnOlxuICAgICAgICByZXR1cm47XG5cbiAgICAgIGNhc2UgdW5kZWZpbmVkOlxuICAgICAgY2FzZSAnMS4wJzpcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICBjb25zb2xlLndhcm4oXCJnbFRGOiBVbmtub3duIHZlcnNpb24gXCIuY29uY2F0KGpzb24uYXNzZXQudmVyc2lvbikpO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICghb3B0aW9ucy5ub3JtYWxpemUpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignZ2xURiB2MSBpcyBub3Qgc3VwcG9ydGVkLicpO1xuICAgIH1cblxuICAgIGNvbnNvbGUud2FybignQ29udmVydGluZyBnbFRGIHYxIHRvIGdsVEYgdjIgZm9ybWF0LiBUaGlzIGlzIGV4cGVyaW1lbnRhbCBhbmQgbWF5IGZhaWwuJyk7XG4gICAgdGhpcy5fYWRkQXNzZXQoanNvbik7XG5cbiAgICB0aGlzLl9jb252ZXJ0VG9wTGV2ZWxPYmplY3RzVG9BcnJheXMoanNvbik7XG5cbiAgICBLSFJfYmluYXJ5X2dsVEYucHJlcHJvY2VzcyhnbHRmKTtcblxuICAgIHRoaXMuX2NvbnZlcnRPYmplY3RJZHNUb0FycmF5SW5kaWNlcyhqc29uKTtcbiAgICB0aGlzLl91cGRhdGVPYmplY3RzKGpzb24pO1xuICAgIHRoaXMuX3VwZGF0ZU1hdGVyaWFsKGpzb24pO1xuICB9XG5cbiAgX2FkZEFzc2V0KGpzb24pIHtcbiAgICBqc29uLmFzc2V0ID0ganNvbi5hc3NldCB8fCB7fTtcbiAgICBqc29uLmFzc2V0LnZlcnNpb24gPSAnMi4wJztcbiAgICBqc29uLmFzc2V0LmdlbmVyYXRvciA9IGpzb24uYXNzZXQuZ2VuZXJhdG9yIHx8ICdOb3JtYWxpemVkIHRvIGdsVEYgMi4wIGJ5IGxvYWRlcnMuZ2wnO1xuICB9XG4gIF9jb252ZXJ0VG9wTGV2ZWxPYmplY3RzVG9BcnJheXMoanNvbikge1xuICAgIGZvciAoY29uc3QgYXJyYXlOYW1lIGluIEdMVEZfQVJSQVlTKSB7XG4gICAgICB0aGlzLl9jb252ZXJ0VG9wTGV2ZWxPYmplY3RUb0FycmF5KGpzb24sIGFycmF5TmFtZSk7XG4gICAgfVxuICB9XG5cbiAgX2NvbnZlcnRUb3BMZXZlbE9iamVjdFRvQXJyYXkoanNvbiwgbWFwTmFtZSkge1xuICAgIGNvbnN0IG9iamVjdE1hcCA9IGpzb25bbWFwTmFtZV07XG4gICAgaWYgKCFvYmplY3RNYXAgfHwgQXJyYXkuaXNBcnJheShvYmplY3RNYXApKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAganNvblttYXBOYW1lXSA9IFtdO1xuICAgIGZvciAoY29uc3QgaWQgaW4gb2JqZWN0TWFwKSB7XG4gICAgICBjb25zdCBvYmplY3QgPSBvYmplY3RNYXBbaWRdO1xuICAgICAgb2JqZWN0LmlkID0gb2JqZWN0LmlkIHx8IGlkO1xuICAgICAgY29uc3QgaW5kZXggPSBqc29uW21hcE5hbWVdLmxlbmd0aDtcbiAgICAgIGpzb25bbWFwTmFtZV0ucHVzaChvYmplY3QpO1xuICAgICAgdGhpcy5pZFRvSW5kZXhNYXBbbWFwTmFtZV1baWRdID0gaW5kZXg7XG4gICAgfVxuICB9XG5cbiAgX2NvbnZlcnRPYmplY3RJZHNUb0FycmF5SW5kaWNlcyhqc29uKSB7XG4gICAgZm9yIChjb25zdCBhcnJheU5hbWUgaW4gR0xURl9BUlJBWVMpIHtcbiAgICAgIHRoaXMuX2NvbnZlcnRJZHNUb0luZGljZXMoanNvbiwgYXJyYXlOYW1lKTtcbiAgICB9XG4gICAgaWYgKCdzY2VuZScgaW4ganNvbikge1xuICAgICAganNvbi5zY2VuZSA9IHRoaXMuX2NvbnZlcnRJZFRvSW5kZXgoanNvbi5zY2VuZSwgJ3NjZW5lJyk7XG4gICAgfVxuXG4gICAgZm9yIChjb25zdCB0ZXh0dXJlIG9mIGpzb24udGV4dHVyZXMpIHtcbiAgICAgIHRoaXMuX2NvbnZlcnRUZXh0dXJlSWRzKHRleHR1cmUpO1xuICAgIH1cbiAgICBmb3IgKGNvbnN0IG1lc2ggb2YganNvbi5tZXNoZXMpIHtcbiAgICAgIHRoaXMuX2NvbnZlcnRNZXNoSWRzKG1lc2gpO1xuICAgIH1cbiAgICBmb3IgKGNvbnN0IG5vZGUgb2YganNvbi5ub2Rlcykge1xuICAgICAgdGhpcy5fY29udmVydE5vZGVJZHMobm9kZSk7XG4gICAgfVxuICAgIGZvciAoY29uc3Qgbm9kZSBvZiBqc29uLnNjZW5lcykge1xuICAgICAgdGhpcy5fY29udmVydFNjZW5lSWRzKG5vZGUpO1xuICAgIH1cbiAgfVxuICBfY29udmVydFRleHR1cmVJZHModGV4dHVyZSkge1xuICAgIGlmICh0ZXh0dXJlLnNvdXJjZSkge1xuICAgICAgdGV4dHVyZS5zb3VyY2UgPSB0aGlzLl9jb252ZXJ0SWRUb0luZGV4KHRleHR1cmUuc291cmNlLCAnaW1hZ2UnKTtcbiAgICB9XG4gIH1cbiAgX2NvbnZlcnRNZXNoSWRzKG1lc2gpIHtcbiAgICBmb3IgKGNvbnN0IHByaW1pdGl2ZSBvZiBtZXNoLnByaW1pdGl2ZXMpIHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgYXR0cmlidXRlcyxcbiAgICAgICAgaW5kaWNlcyxcbiAgICAgICAgbWF0ZXJpYWxcbiAgICAgIH0gPSBwcmltaXRpdmU7XG4gICAgICBmb3IgKGNvbnN0IGF0dHJpYnV0ZU5hbWUgaW4gYXR0cmlidXRlcykge1xuICAgICAgICBhdHRyaWJ1dGVzW2F0dHJpYnV0ZU5hbWVdID0gdGhpcy5fY29udmVydElkVG9JbmRleChhdHRyaWJ1dGVzW2F0dHJpYnV0ZU5hbWVdLCAnYWNjZXNzb3InKTtcbiAgICAgIH1cbiAgICAgIGlmIChpbmRpY2VzKSB7XG4gICAgICAgIHByaW1pdGl2ZS5pbmRpY2VzID0gdGhpcy5fY29udmVydElkVG9JbmRleChpbmRpY2VzLCAnYWNjZXNzb3InKTtcbiAgICAgIH1cbiAgICAgIGlmIChtYXRlcmlhbCkge1xuICAgICAgICBwcmltaXRpdmUubWF0ZXJpYWwgPSB0aGlzLl9jb252ZXJ0SWRUb0luZGV4KG1hdGVyaWFsLCAnbWF0ZXJpYWwnKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgX2NvbnZlcnROb2RlSWRzKG5vZGUpIHtcbiAgICBpZiAobm9kZS5jaGlsZHJlbikge1xuICAgICAgbm9kZS5jaGlsZHJlbiA9IG5vZGUuY2hpbGRyZW4ubWFwKGNoaWxkID0+IHRoaXMuX2NvbnZlcnRJZFRvSW5kZXgoY2hpbGQsICdub2RlJykpO1xuICAgIH1cbiAgICBpZiAobm9kZS5tZXNoZXMpIHtcbiAgICAgIG5vZGUubWVzaGVzID0gbm9kZS5tZXNoZXMubWFwKG1lc2ggPT4gdGhpcy5fY29udmVydElkVG9JbmRleChtZXNoLCAnbWVzaCcpKTtcbiAgICB9XG4gIH1cbiAgX2NvbnZlcnRTY2VuZUlkcyhzY2VuZSkge1xuICAgIGlmIChzY2VuZS5ub2Rlcykge1xuICAgICAgc2NlbmUubm9kZXMgPSBzY2VuZS5ub2Rlcy5tYXAobm9kZSA9PiB0aGlzLl9jb252ZXJ0SWRUb0luZGV4KG5vZGUsICdub2RlJykpO1xuICAgIH1cbiAgfVxuXG4gIF9jb252ZXJ0SWRzVG9JbmRpY2VzKGpzb24sIHRvcExldmVsQXJyYXlOYW1lKSB7XG4gICAgaWYgKCFqc29uW3RvcExldmVsQXJyYXlOYW1lXSkge1xuICAgICAgY29uc29sZS53YXJuKFwiZ2x0ZiB2MToganNvbiBkb2Vzbid0IGNvbnRhaW4gYXR0cmlidXRlIFwiLmNvbmNhdCh0b3BMZXZlbEFycmF5TmFtZSkpO1xuICAgICAganNvblt0b3BMZXZlbEFycmF5TmFtZV0gPSBbXTtcbiAgICB9XG4gICAgZm9yIChjb25zdCBvYmplY3Qgb2YganNvblt0b3BMZXZlbEFycmF5TmFtZV0pIHtcbiAgICAgIGZvciAoY29uc3Qga2V5IGluIG9iamVjdCkge1xuICAgICAgICBjb25zdCBpZCA9IG9iamVjdFtrZXldO1xuICAgICAgICBjb25zdCBpbmRleCA9IHRoaXMuX2NvbnZlcnRJZFRvSW5kZXgoaWQsIGtleSk7XG4gICAgICAgIG9iamVjdFtrZXldID0gaW5kZXg7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIF9jb252ZXJ0SWRUb0luZGV4KGlkLCBrZXkpIHtcbiAgICBjb25zdCBhcnJheU5hbWUgPSBHTFRGX0tFWVNba2V5XTtcbiAgICBpZiAoYXJyYXlOYW1lIGluIHRoaXMuaWRUb0luZGV4TWFwKSB7XG4gICAgICBjb25zdCBpbmRleCA9IHRoaXMuaWRUb0luZGV4TWFwW2FycmF5TmFtZV1baWRdO1xuICAgICAgaWYgKCFOdW1iZXIuaXNGaW5pdGUoaW5kZXgpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcImdsdGYgdjE6IGZhaWxlZCB0byByZXNvbHZlIFwiLmNvbmNhdChrZXksIFwiIHdpdGggaWQgXCIpLmNvbmNhdChpZCkpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGluZGV4O1xuICAgIH1cbiAgICByZXR1cm4gaWQ7XG4gIH1cblxuICBfdXBkYXRlT2JqZWN0cyhqc29uKSB7XG4gICAgZm9yIChjb25zdCBidWZmZXIgb2YgdGhpcy5qc29uLmJ1ZmZlcnMpIHtcbiAgICAgIGRlbGV0ZSBidWZmZXIudHlwZTtcbiAgICB9XG4gIH1cblxuICBfdXBkYXRlTWF0ZXJpYWwoanNvbikge1xuICAgIGZvciAoY29uc3QgbWF0ZXJpYWwgb2YganNvbi5tYXRlcmlhbHMpIHtcbiAgICAgIHZhciBfbWF0ZXJpYWwkdmFsdWVzLCBfbWF0ZXJpYWwkdmFsdWVzMiwgX21hdGVyaWFsJHZhbHVlczM7XG4gICAgICBtYXRlcmlhbC5wYnJNZXRhbGxpY1JvdWdobmVzcyA9IHtcbiAgICAgICAgYmFzZUNvbG9yRmFjdG9yOiBbMSwgMSwgMSwgMV0sXG4gICAgICAgIG1ldGFsbGljRmFjdG9yOiAxLFxuICAgICAgICByb3VnaG5lc3NGYWN0b3I6IDFcbiAgICAgIH07XG4gICAgICBjb25zdCB0ZXh0dXJlSWQgPSAoKF9tYXRlcmlhbCR2YWx1ZXMgPSBtYXRlcmlhbC52YWx1ZXMpID09PSBudWxsIHx8IF9tYXRlcmlhbCR2YWx1ZXMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9tYXRlcmlhbCR2YWx1ZXMudGV4KSB8fCAoKF9tYXRlcmlhbCR2YWx1ZXMyID0gbWF0ZXJpYWwudmFsdWVzKSA9PT0gbnVsbCB8fCBfbWF0ZXJpYWwkdmFsdWVzMiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX21hdGVyaWFsJHZhbHVlczIudGV4dHVyZTJkXzApIHx8ICgoX21hdGVyaWFsJHZhbHVlczMgPSBtYXRlcmlhbC52YWx1ZXMpID09PSBudWxsIHx8IF9tYXRlcmlhbCR2YWx1ZXMzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfbWF0ZXJpYWwkdmFsdWVzMy5kaWZmdXNlVGV4KTtcbiAgICAgIGNvbnN0IHRleHR1cmVJbmRleCA9IGpzb24udGV4dHVyZXMuZmluZEluZGV4KHRleHR1cmUgPT4gdGV4dHVyZS5pZCA9PT0gdGV4dHVyZUlkKTtcbiAgICAgIGlmICh0ZXh0dXJlSW5kZXggIT09IC0xKSB7XG4gICAgICAgIG1hdGVyaWFsLnBick1ldGFsbGljUm91Z2huZXNzLmJhc2VDb2xvclRleHR1cmUgPSB7XG4gICAgICAgICAgaW5kZXg6IHRleHR1cmVJbmRleFxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuZXhwb3J0IGZ1bmN0aW9uIG5vcm1hbGl6ZUdMVEZWMShnbHRmKSB7XG4gIGxldCBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcbiAgcmV0dXJuIG5ldyBHTFRGVjFOb3JtYWxpemVyKCkubm9ybWFsaXplKGdsdGYsIG9wdGlvbnMpO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bm9ybWFsaXplLWdsdGYtdjEuanMubWFwIiwiaW1wb3J0IF9kZWZpbmVQcm9wZXJ0eSBmcm9tIFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vZGVmaW5lUHJvcGVydHlcIjtcbmltcG9ydCB7IGFzc2VydCB9IGZyb20gJy4uL3V0aWxzL2Fzc2VydCc7XG5pbXBvcnQgeyBnZXRBY2Nlc3NvckFycmF5VHlwZUFuZExlbmd0aCB9IGZyb20gJy4uL2dsdGYtdXRpbHMvZ2x0Zi11dGlscyc7XG5cbmNvbnN0IENPTVBPTkVOVFMgPSB7XG4gIFNDQUxBUjogMSxcbiAgVkVDMjogMixcbiAgVkVDMzogMyxcbiAgVkVDNDogNCxcbiAgTUFUMjogNCxcbiAgTUFUMzogOSxcbiAgTUFUNDogMTZcbn07XG5jb25zdCBCWVRFUyA9IHtcbiAgNTEyMDogMSxcbiAgNTEyMTogMSxcbiAgNTEyMjogMixcbiAgNTEyMzogMixcbiAgNTEyNTogNCxcbiAgNTEyNjogNFxufTtcblxuY29uc3QgR0xfU0FNUExFUiA9IHtcbiAgVEVYVFVSRV9NQUdfRklMVEVSOiAweDI4MDAsXG4gIFRFWFRVUkVfTUlOX0ZJTFRFUjogMHgyODAxLFxuICBURVhUVVJFX1dSQVBfUzogMHgyODAyLFxuICBURVhUVVJFX1dSQVBfVDogMHgyODAzLFxuICBSRVBFQVQ6IDB4MjkwMSxcbiAgTElORUFSOiAweDI2MDEsXG4gIE5FQVJFU1RfTUlQTUFQX0xJTkVBUjogMHgyNzAyXG59O1xuY29uc3QgU0FNUExFUl9QQVJBTUVURVJfR0xURl9UT19HTCA9IHtcbiAgbWFnRmlsdGVyOiBHTF9TQU1QTEVSLlRFWFRVUkVfTUFHX0ZJTFRFUixcbiAgbWluRmlsdGVyOiBHTF9TQU1QTEVSLlRFWFRVUkVfTUlOX0ZJTFRFUixcbiAgd3JhcFM6IEdMX1NBTVBMRVIuVEVYVFVSRV9XUkFQX1MsXG4gIHdyYXBUOiBHTF9TQU1QTEVSLlRFWFRVUkVfV1JBUF9UXG59O1xuXG5jb25zdCBERUZBVUxUX1NBTVBMRVIgPSB7XG4gIFtHTF9TQU1QTEVSLlRFWFRVUkVfTUFHX0ZJTFRFUl06IEdMX1NBTVBMRVIuTElORUFSLFxuICBbR0xfU0FNUExFUi5URVhUVVJFX01JTl9GSUxURVJdOiBHTF9TQU1QTEVSLk5FQVJFU1RfTUlQTUFQX0xJTkVBUixcbiAgW0dMX1NBTVBMRVIuVEVYVFVSRV9XUkFQX1NdOiBHTF9TQU1QTEVSLlJFUEVBVCxcbiAgW0dMX1NBTVBMRVIuVEVYVFVSRV9XUkFQX1RdOiBHTF9TQU1QTEVSLlJFUEVBVFxufTtcbmZ1bmN0aW9uIGdldEJ5dGVzRnJvbUNvbXBvbmVudFR5cGUoY29tcG9uZW50VHlwZSkge1xuICByZXR1cm4gQllURVNbY29tcG9uZW50VHlwZV07XG59XG5mdW5jdGlvbiBnZXRTaXplRnJvbUFjY2Vzc29yVHlwZSh0eXBlKSB7XG4gIHJldHVybiBDT01QT05FTlRTW3R5cGVdO1xufVxuY2xhc3MgR0xURlBvc3RQcm9jZXNzb3Ige1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJiYXNlVXJpXCIsICcnKTtcbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJqc29uXCIsIHt9KTtcbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJidWZmZXJzXCIsIFtdKTtcbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJpbWFnZXNcIiwgW10pO1xuICB9XG4gIHBvc3RQcm9jZXNzKGdsdGYpIHtcbiAgICBsZXQgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG4gICAgY29uc3Qge1xuICAgICAganNvbixcbiAgICAgIGJ1ZmZlcnMgPSBbXSxcbiAgICAgIGltYWdlcyA9IFtdLFxuICAgICAgYmFzZVVyaSA9ICcnXG4gICAgfSA9IGdsdGY7XG4gICAgYXNzZXJ0KGpzb24pO1xuICAgIHRoaXMuYmFzZVVyaSA9IGJhc2VVcmk7XG4gICAgdGhpcy5qc29uID0ganNvbjtcbiAgICB0aGlzLmJ1ZmZlcnMgPSBidWZmZXJzO1xuICAgIHRoaXMuaW1hZ2VzID0gaW1hZ2VzO1xuICAgIHRoaXMuX3Jlc29sdmVUcmVlKHRoaXMuanNvbiwgb3B0aW9ucyk7XG4gICAgcmV0dXJuIHRoaXMuanNvbjtcbiAgfVxuXG4gIF9yZXNvbHZlVHJlZShqc29uKSB7XG4gICAgbGV0IG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuICAgIGlmIChqc29uLmJ1ZmZlclZpZXdzKSB7XG4gICAgICBqc29uLmJ1ZmZlclZpZXdzID0ganNvbi5idWZmZXJWaWV3cy5tYXAoKGJ1ZlZpZXcsIGkpID0+IHRoaXMuX3Jlc29sdmVCdWZmZXJWaWV3KGJ1ZlZpZXcsIGkpKTtcbiAgICB9XG4gICAgaWYgKGpzb24uaW1hZ2VzKSB7XG4gICAgICBqc29uLmltYWdlcyA9IGpzb24uaW1hZ2VzLm1hcCgoaW1hZ2UsIGkpID0+IHRoaXMuX3Jlc29sdmVJbWFnZShpbWFnZSwgaSkpO1xuICAgIH1cbiAgICBpZiAoanNvbi5zYW1wbGVycykge1xuICAgICAganNvbi5zYW1wbGVycyA9IGpzb24uc2FtcGxlcnMubWFwKChzYW1wbGVyLCBpKSA9PiB0aGlzLl9yZXNvbHZlU2FtcGxlcihzYW1wbGVyLCBpKSk7XG4gICAgfVxuICAgIGlmIChqc29uLnRleHR1cmVzKSB7XG4gICAgICBqc29uLnRleHR1cmVzID0ganNvbi50ZXh0dXJlcy5tYXAoKHRleHR1cmUsIGkpID0+IHRoaXMuX3Jlc29sdmVUZXh0dXJlKHRleHR1cmUsIGkpKTtcbiAgICB9XG4gICAgaWYgKGpzb24uYWNjZXNzb3JzKSB7XG4gICAgICBqc29uLmFjY2Vzc29ycyA9IGpzb24uYWNjZXNzb3JzLm1hcCgoYWNjZXNzb3IsIGkpID0+IHRoaXMuX3Jlc29sdmVBY2Nlc3NvcihhY2Nlc3NvciwgaSkpO1xuICAgIH1cbiAgICBpZiAoanNvbi5tYXRlcmlhbHMpIHtcbiAgICAgIGpzb24ubWF0ZXJpYWxzID0ganNvbi5tYXRlcmlhbHMubWFwKChtYXRlcmlhbCwgaSkgPT4gdGhpcy5fcmVzb2x2ZU1hdGVyaWFsKG1hdGVyaWFsLCBpKSk7XG4gICAgfVxuICAgIGlmIChqc29uLm1lc2hlcykge1xuICAgICAganNvbi5tZXNoZXMgPSBqc29uLm1lc2hlcy5tYXAoKG1lc2gsIGkpID0+IHRoaXMuX3Jlc29sdmVNZXNoKG1lc2gsIGkpKTtcbiAgICB9XG4gICAgaWYgKGpzb24ubm9kZXMpIHtcbiAgICAgIGpzb24ubm9kZXMgPSBqc29uLm5vZGVzLm1hcCgobm9kZSwgaSkgPT4gdGhpcy5fcmVzb2x2ZU5vZGUobm9kZSwgaSkpO1xuICAgIH1cbiAgICBpZiAoanNvbi5za2lucykge1xuICAgICAganNvbi5za2lucyA9IGpzb24uc2tpbnMubWFwKChza2luLCBpKSA9PiB0aGlzLl9yZXNvbHZlU2tpbihza2luLCBpKSk7XG4gICAgfVxuICAgIGlmIChqc29uLnNjZW5lcykge1xuICAgICAganNvbi5zY2VuZXMgPSBqc29uLnNjZW5lcy5tYXAoKHNjZW5lLCBpKSA9PiB0aGlzLl9yZXNvbHZlU2NlbmUoc2NlbmUsIGkpKTtcbiAgICB9XG4gICAgaWYgKGpzb24uc2NlbmUgIT09IHVuZGVmaW5lZCkge1xuICAgICAganNvbi5zY2VuZSA9IGpzb24uc2NlbmVzW3RoaXMuanNvbi5zY2VuZV07XG4gICAgfVxuICB9XG4gIGdldFNjZW5lKGluZGV4KSB7XG4gICAgcmV0dXJuIHRoaXMuX2dldCgnc2NlbmVzJywgaW5kZXgpO1xuICB9XG4gIGdldE5vZGUoaW5kZXgpIHtcbiAgICByZXR1cm4gdGhpcy5fZ2V0KCdub2RlcycsIGluZGV4KTtcbiAgfVxuICBnZXRTa2luKGluZGV4KSB7XG4gICAgcmV0dXJuIHRoaXMuX2dldCgnc2tpbnMnLCBpbmRleCk7XG4gIH1cbiAgZ2V0TWVzaChpbmRleCkge1xuICAgIHJldHVybiB0aGlzLl9nZXQoJ21lc2hlcycsIGluZGV4KTtcbiAgfVxuICBnZXRNYXRlcmlhbChpbmRleCkge1xuICAgIHJldHVybiB0aGlzLl9nZXQoJ21hdGVyaWFscycsIGluZGV4KTtcbiAgfVxuICBnZXRBY2Nlc3NvcihpbmRleCkge1xuICAgIHJldHVybiB0aGlzLl9nZXQoJ2FjY2Vzc29ycycsIGluZGV4KTtcbiAgfVxuICBnZXRDYW1lcmEoaW5kZXgpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIGdldFRleHR1cmUoaW5kZXgpIHtcbiAgICByZXR1cm4gdGhpcy5fZ2V0KCd0ZXh0dXJlcycsIGluZGV4KTtcbiAgfVxuICBnZXRTYW1wbGVyKGluZGV4KSB7XG4gICAgcmV0dXJuIHRoaXMuX2dldCgnc2FtcGxlcnMnLCBpbmRleCk7XG4gIH1cbiAgZ2V0SW1hZ2UoaW5kZXgpIHtcbiAgICByZXR1cm4gdGhpcy5fZ2V0KCdpbWFnZXMnLCBpbmRleCk7XG4gIH1cbiAgZ2V0QnVmZmVyVmlldyhpbmRleCkge1xuICAgIHJldHVybiB0aGlzLl9nZXQoJ2J1ZmZlclZpZXdzJywgaW5kZXgpO1xuICB9XG4gIGdldEJ1ZmZlcihpbmRleCkge1xuICAgIHJldHVybiB0aGlzLl9nZXQoJ2J1ZmZlcnMnLCBpbmRleCk7XG4gIH1cbiAgX2dldChhcnJheSwgaW5kZXgpIHtcbiAgICBpZiAodHlwZW9mIGluZGV4ID09PSAnb2JqZWN0Jykge1xuICAgICAgcmV0dXJuIGluZGV4O1xuICAgIH1cbiAgICBjb25zdCBvYmplY3QgPSB0aGlzLmpzb25bYXJyYXldICYmIHRoaXMuanNvblthcnJheV1baW5kZXhdO1xuICAgIGlmICghb2JqZWN0KSB7XG4gICAgICBjb25zb2xlLndhcm4oXCJnbFRGIGZpbGUgZXJyb3I6IENvdWxkIG5vdCBmaW5kIFwiLmNvbmNhdChhcnJheSwgXCJbXCIpLmNvbmNhdChpbmRleCwgXCJdXCIpKTtcbiAgICB9XG5cbiAgICByZXR1cm4gb2JqZWN0O1xuICB9XG5cbiAgX3Jlc29sdmVTY2VuZShzY2VuZSwgaW5kZXgpIHtcbiAgICBzY2VuZS5pZCA9IHNjZW5lLmlkIHx8IFwic2NlbmUtXCIuY29uY2F0KGluZGV4KTtcbiAgICBzY2VuZS5ub2RlcyA9IChzY2VuZS5ub2RlcyB8fCBbXSkubWFwKG5vZGUgPT4gdGhpcy5nZXROb2RlKG5vZGUpKTtcbiAgICByZXR1cm4gc2NlbmU7XG4gIH1cbiAgX3Jlc29sdmVOb2RlKG5vZGUsIGluZGV4KSB7XG4gICAgbm9kZS5pZCA9IG5vZGUuaWQgfHwgXCJub2RlLVwiLmNvbmNhdChpbmRleCk7XG4gICAgaWYgKG5vZGUuY2hpbGRyZW4pIHtcbiAgICAgIG5vZGUuY2hpbGRyZW4gPSBub2RlLmNoaWxkcmVuLm1hcChjaGlsZCA9PiB0aGlzLmdldE5vZGUoY2hpbGQpKTtcbiAgICB9XG4gICAgaWYgKG5vZGUubWVzaCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBub2RlLm1lc2ggPSB0aGlzLmdldE1lc2gobm9kZS5tZXNoKTtcbiAgICB9IGVsc2UgaWYgKG5vZGUubWVzaGVzICE9PSB1bmRlZmluZWQgJiYgbm9kZS5tZXNoZXMubGVuZ3RoKSB7XG4gICAgICBub2RlLm1lc2ggPSBub2RlLm1lc2hlcy5yZWR1Y2UoKGFjY3VtLCBtZXNoSW5kZXgpID0+IHtcbiAgICAgICAgY29uc3QgbWVzaCA9IHRoaXMuZ2V0TWVzaChtZXNoSW5kZXgpO1xuICAgICAgICBhY2N1bS5pZCA9IG1lc2guaWQ7XG4gICAgICAgIGFjY3VtLnByaW1pdGl2ZXMgPSBhY2N1bS5wcmltaXRpdmVzLmNvbmNhdChtZXNoLnByaW1pdGl2ZXMpO1xuICAgICAgICByZXR1cm4gYWNjdW07XG4gICAgICB9LCB7XG4gICAgICAgIHByaW1pdGl2ZXM6IFtdXG4gICAgICB9KTtcbiAgICB9XG4gICAgaWYgKG5vZGUuY2FtZXJhICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIG5vZGUuY2FtZXJhID0gdGhpcy5nZXRDYW1lcmEobm9kZS5jYW1lcmEpO1xuICAgIH1cbiAgICBpZiAobm9kZS5za2luICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIG5vZGUuc2tpbiA9IHRoaXMuZ2V0U2tpbihub2RlLnNraW4pO1xuICAgIH1cbiAgICByZXR1cm4gbm9kZTtcbiAgfVxuICBfcmVzb2x2ZVNraW4oc2tpbiwgaW5kZXgpIHtcbiAgICBza2luLmlkID0gc2tpbi5pZCB8fCBcInNraW4tXCIuY29uY2F0KGluZGV4KTtcbiAgICBza2luLmludmVyc2VCaW5kTWF0cmljZXMgPSB0aGlzLmdldEFjY2Vzc29yKHNraW4uaW52ZXJzZUJpbmRNYXRyaWNlcyk7XG4gICAgcmV0dXJuIHNraW47XG4gIH1cbiAgX3Jlc29sdmVNZXNoKG1lc2gsIGluZGV4KSB7XG4gICAgbWVzaC5pZCA9IG1lc2guaWQgfHwgXCJtZXNoLVwiLmNvbmNhdChpbmRleCk7XG4gICAgaWYgKG1lc2gucHJpbWl0aXZlcykge1xuICAgICAgbWVzaC5wcmltaXRpdmVzID0gbWVzaC5wcmltaXRpdmVzLm1hcChwcmltaXRpdmUgPT4ge1xuICAgICAgICBwcmltaXRpdmUgPSB7XG4gICAgICAgICAgLi4ucHJpbWl0aXZlXG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IGF0dHJpYnV0ZXMgPSBwcmltaXRpdmUuYXR0cmlidXRlcztcbiAgICAgICAgcHJpbWl0aXZlLmF0dHJpYnV0ZXMgPSB7fTtcbiAgICAgICAgZm9yIChjb25zdCBhdHRyaWJ1dGUgaW4gYXR0cmlidXRlcykge1xuICAgICAgICAgIHByaW1pdGl2ZS5hdHRyaWJ1dGVzW2F0dHJpYnV0ZV0gPSB0aGlzLmdldEFjY2Vzc29yKGF0dHJpYnV0ZXNbYXR0cmlidXRlXSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHByaW1pdGl2ZS5pbmRpY2VzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBwcmltaXRpdmUuaW5kaWNlcyA9IHRoaXMuZ2V0QWNjZXNzb3IocHJpbWl0aXZlLmluZGljZXMpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwcmltaXRpdmUubWF0ZXJpYWwgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHByaW1pdGl2ZS5tYXRlcmlhbCA9IHRoaXMuZ2V0TWF0ZXJpYWwocHJpbWl0aXZlLm1hdGVyaWFsKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcHJpbWl0aXZlO1xuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiBtZXNoO1xuICB9XG4gIF9yZXNvbHZlTWF0ZXJpYWwobWF0ZXJpYWwsIGluZGV4KSB7XG4gICAgbWF0ZXJpYWwuaWQgPSBtYXRlcmlhbC5pZCB8fCBcIm1hdGVyaWFsLVwiLmNvbmNhdChpbmRleCk7XG4gICAgaWYgKG1hdGVyaWFsLm5vcm1hbFRleHR1cmUpIHtcbiAgICAgIG1hdGVyaWFsLm5vcm1hbFRleHR1cmUgPSB7XG4gICAgICAgIC4uLm1hdGVyaWFsLm5vcm1hbFRleHR1cmVcbiAgICAgIH07XG4gICAgICBtYXRlcmlhbC5ub3JtYWxUZXh0dXJlLnRleHR1cmUgPSB0aGlzLmdldFRleHR1cmUobWF0ZXJpYWwubm9ybWFsVGV4dHVyZS5pbmRleCk7XG4gICAgfVxuICAgIGlmIChtYXRlcmlhbC5vY2NsdXNpb25UZXh0dXJlKSB7XG4gICAgICBtYXRlcmlhbC5vY2NsdXN0aW9uVGV4dHVyZSA9IHtcbiAgICAgICAgLi4ubWF0ZXJpYWwub2NjbHVzdGlvblRleHR1cmVcbiAgICAgIH07XG4gICAgICBtYXRlcmlhbC5vY2NsdXNpb25UZXh0dXJlLnRleHR1cmUgPSB0aGlzLmdldFRleHR1cmUobWF0ZXJpYWwub2NjbHVzaW9uVGV4dHVyZS5pbmRleCk7XG4gICAgfVxuICAgIGlmIChtYXRlcmlhbC5lbWlzc2l2ZVRleHR1cmUpIHtcbiAgICAgIG1hdGVyaWFsLmVtbWlzaXZlVGV4dHVyZSA9IHtcbiAgICAgICAgLi4ubWF0ZXJpYWwuZW1taXNpdmVUZXh0dXJlXG4gICAgICB9O1xuICAgICAgbWF0ZXJpYWwuZW1pc3NpdmVUZXh0dXJlLnRleHR1cmUgPSB0aGlzLmdldFRleHR1cmUobWF0ZXJpYWwuZW1pc3NpdmVUZXh0dXJlLmluZGV4KTtcbiAgICB9XG4gICAgaWYgKCFtYXRlcmlhbC5lbWlzc2l2ZUZhY3Rvcikge1xuICAgICAgbWF0ZXJpYWwuZW1pc3NpdmVGYWN0b3IgPSBtYXRlcmlhbC5lbW1pc2l2ZVRleHR1cmUgPyBbMSwgMSwgMV0gOiBbMCwgMCwgMF07XG4gICAgfVxuICAgIGlmIChtYXRlcmlhbC5wYnJNZXRhbGxpY1JvdWdobmVzcykge1xuICAgICAgbWF0ZXJpYWwucGJyTWV0YWxsaWNSb3VnaG5lc3MgPSB7XG4gICAgICAgIC4uLm1hdGVyaWFsLnBick1ldGFsbGljUm91Z2huZXNzXG4gICAgICB9O1xuICAgICAgY29uc3QgbXIgPSBtYXRlcmlhbC5wYnJNZXRhbGxpY1JvdWdobmVzcztcbiAgICAgIGlmIChtci5iYXNlQ29sb3JUZXh0dXJlKSB7XG4gICAgICAgIG1yLmJhc2VDb2xvclRleHR1cmUgPSB7XG4gICAgICAgICAgLi4ubXIuYmFzZUNvbG9yVGV4dHVyZVxuICAgICAgICB9O1xuICAgICAgICBtci5iYXNlQ29sb3JUZXh0dXJlLnRleHR1cmUgPSB0aGlzLmdldFRleHR1cmUobXIuYmFzZUNvbG9yVGV4dHVyZS5pbmRleCk7XG4gICAgICB9XG4gICAgICBpZiAobXIubWV0YWxsaWNSb3VnaG5lc3NUZXh0dXJlKSB7XG4gICAgICAgIG1yLm1ldGFsbGljUm91Z2huZXNzVGV4dHVyZSA9IHtcbiAgICAgICAgICAuLi5tci5tZXRhbGxpY1JvdWdobmVzc1RleHR1cmVcbiAgICAgICAgfTtcbiAgICAgICAgbXIubWV0YWxsaWNSb3VnaG5lc3NUZXh0dXJlLnRleHR1cmUgPSB0aGlzLmdldFRleHR1cmUobXIubWV0YWxsaWNSb3VnaG5lc3NUZXh0dXJlLmluZGV4KTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG1hdGVyaWFsO1xuICB9XG4gIF9yZXNvbHZlQWNjZXNzb3IoYWNjZXNzb3IsIGluZGV4KSB7XG4gICAgYWNjZXNzb3IuaWQgPSBhY2Nlc3Nvci5pZCB8fCBcImFjY2Vzc29yLVwiLmNvbmNhdChpbmRleCk7XG4gICAgaWYgKGFjY2Vzc29yLmJ1ZmZlclZpZXcgIT09IHVuZGVmaW5lZCkge1xuICAgICAgYWNjZXNzb3IuYnVmZmVyVmlldyA9IHRoaXMuZ2V0QnVmZmVyVmlldyhhY2Nlc3Nvci5idWZmZXJWaWV3KTtcbiAgICB9XG5cbiAgICBhY2Nlc3Nvci5ieXRlc1BlckNvbXBvbmVudCA9IGdldEJ5dGVzRnJvbUNvbXBvbmVudFR5cGUoYWNjZXNzb3IuY29tcG9uZW50VHlwZSk7XG4gICAgYWNjZXNzb3IuY29tcG9uZW50cyA9IGdldFNpemVGcm9tQWNjZXNzb3JUeXBlKGFjY2Vzc29yLnR5cGUpO1xuICAgIGFjY2Vzc29yLmJ5dGVzUGVyRWxlbWVudCA9IGFjY2Vzc29yLmJ5dGVzUGVyQ29tcG9uZW50ICogYWNjZXNzb3IuY29tcG9uZW50cztcblxuICAgIGlmIChhY2Nlc3Nvci5idWZmZXJWaWV3KSB7XG4gICAgICBjb25zdCBidWZmZXIgPSBhY2Nlc3Nvci5idWZmZXJWaWV3LmJ1ZmZlcjtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgQXJyYXlUeXBlLFxuICAgICAgICBieXRlTGVuZ3RoXG4gICAgICB9ID0gZ2V0QWNjZXNzb3JBcnJheVR5cGVBbmRMZW5ndGgoYWNjZXNzb3IsIGFjY2Vzc29yLmJ1ZmZlclZpZXcpO1xuICAgICAgY29uc3QgYnl0ZU9mZnNldCA9IChhY2Nlc3Nvci5idWZmZXJWaWV3LmJ5dGVPZmZzZXQgfHwgMCkgKyAoYWNjZXNzb3IuYnl0ZU9mZnNldCB8fCAwKSArIGJ1ZmZlci5ieXRlT2Zmc2V0O1xuICAgICAgbGV0IGN1dEJ1ZmZlciA9IGJ1ZmZlci5hcnJheUJ1ZmZlci5zbGljZShieXRlT2Zmc2V0LCBieXRlT2Zmc2V0ICsgYnl0ZUxlbmd0aCk7XG4gICAgICBpZiAoYWNjZXNzb3IuYnVmZmVyVmlldy5ieXRlU3RyaWRlKSB7XG4gICAgICAgIGN1dEJ1ZmZlciA9IHRoaXMuX2dldFZhbHVlRnJvbUludGVybGVhdmVkQnVmZmVyKGJ1ZmZlciwgYnl0ZU9mZnNldCwgYWNjZXNzb3IuYnVmZmVyVmlldy5ieXRlU3RyaWRlLCBhY2Nlc3Nvci5ieXRlc1BlckVsZW1lbnQsIGFjY2Vzc29yLmNvdW50KTtcbiAgICAgIH1cbiAgICAgIGFjY2Vzc29yLnZhbHVlID0gbmV3IEFycmF5VHlwZShjdXRCdWZmZXIpO1xuICAgIH1cbiAgICByZXR1cm4gYWNjZXNzb3I7XG4gIH1cblxuICBfZ2V0VmFsdWVGcm9tSW50ZXJsZWF2ZWRCdWZmZXIoYnVmZmVyLCBieXRlT2Zmc2V0LCBieXRlU3RyaWRlLCBieXRlc1BlckVsZW1lbnQsIGNvdW50KSB7XG4gICAgY29uc3QgcmVzdWx0ID0gbmV3IFVpbnQ4QXJyYXkoY291bnQgKiBieXRlc1BlckVsZW1lbnQpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY291bnQ7IGkrKykge1xuICAgICAgY29uc3QgZWxlbWVudE9mZnNldCA9IGJ5dGVPZmZzZXQgKyBpICogYnl0ZVN0cmlkZTtcbiAgICAgIHJlc3VsdC5zZXQobmV3IFVpbnQ4QXJyYXkoYnVmZmVyLmFycmF5QnVmZmVyLnNsaWNlKGVsZW1lbnRPZmZzZXQsIGVsZW1lbnRPZmZzZXQgKyBieXRlc1BlckVsZW1lbnQpKSwgaSAqIGJ5dGVzUGVyRWxlbWVudCk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQuYnVmZmVyO1xuICB9XG4gIF9yZXNvbHZlVGV4dHVyZSh0ZXh0dXJlLCBpbmRleCkge1xuICAgIHRleHR1cmUuaWQgPSB0ZXh0dXJlLmlkIHx8IFwidGV4dHVyZS1cIi5jb25jYXQoaW5kZXgpO1xuICAgIHRleHR1cmUuc2FtcGxlciA9ICdzYW1wbGVyJyBpbiB0ZXh0dXJlID8gdGhpcy5nZXRTYW1wbGVyKHRleHR1cmUuc2FtcGxlcikgOiBERUZBVUxUX1NBTVBMRVI7XG4gICAgdGV4dHVyZS5zb3VyY2UgPSB0aGlzLmdldEltYWdlKHRleHR1cmUuc291cmNlKTtcbiAgICByZXR1cm4gdGV4dHVyZTtcbiAgfVxuICBfcmVzb2x2ZVNhbXBsZXIoc2FtcGxlciwgaW5kZXgpIHtcbiAgICBzYW1wbGVyLmlkID0gc2FtcGxlci5pZCB8fCBcInNhbXBsZXItXCIuY29uY2F0KGluZGV4KTtcbiAgICBzYW1wbGVyLnBhcmFtZXRlcnMgPSB7fTtcbiAgICBmb3IgKGNvbnN0IGtleSBpbiBzYW1wbGVyKSB7XG4gICAgICBjb25zdCBnbEVudW0gPSB0aGlzLl9lbnVtU2FtcGxlclBhcmFtZXRlcihrZXkpO1xuICAgICAgaWYgKGdsRW51bSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHNhbXBsZXIucGFyYW1ldGVyc1tnbEVudW1dID0gc2FtcGxlcltrZXldO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gc2FtcGxlcjtcbiAgfVxuICBfZW51bVNhbXBsZXJQYXJhbWV0ZXIoa2V5KSB7XG4gICAgcmV0dXJuIFNBTVBMRVJfUEFSQU1FVEVSX0dMVEZfVE9fR0xba2V5XTtcbiAgfVxuICBfcmVzb2x2ZUltYWdlKGltYWdlLCBpbmRleCkge1xuICAgIGltYWdlLmlkID0gaW1hZ2UuaWQgfHwgXCJpbWFnZS1cIi5jb25jYXQoaW5kZXgpO1xuICAgIGlmIChpbWFnZS5idWZmZXJWaWV3ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGltYWdlLmJ1ZmZlclZpZXcgPSB0aGlzLmdldEJ1ZmZlclZpZXcoaW1hZ2UuYnVmZmVyVmlldyk7XG4gICAgfVxuXG4gICAgY29uc3QgcHJlbG9hZGVkSW1hZ2UgPSB0aGlzLmltYWdlc1tpbmRleF07XG4gICAgaWYgKHByZWxvYWRlZEltYWdlKSB7XG4gICAgICBpbWFnZS5pbWFnZSA9IHByZWxvYWRlZEltYWdlO1xuICAgIH1cbiAgICByZXR1cm4gaW1hZ2U7XG4gIH1cbiAgX3Jlc29sdmVCdWZmZXJWaWV3KGJ1ZmZlclZpZXcsIGluZGV4KSB7XG4gICAgY29uc3QgYnVmZmVySW5kZXggPSBidWZmZXJWaWV3LmJ1ZmZlcjtcbiAgICBjb25zdCByZXN1bHQgPSB7XG4gICAgICBpZDogXCJidWZmZXJWaWV3LVwiLmNvbmNhdChpbmRleCksXG4gICAgICAuLi5idWZmZXJWaWV3LFxuICAgICAgYnVmZmVyOiB0aGlzLmJ1ZmZlcnNbYnVmZmVySW5kZXhdXG4gICAgfTtcblxuICAgIGNvbnN0IGFycmF5QnVmZmVyID0gdGhpcy5idWZmZXJzW2J1ZmZlckluZGV4XS5hcnJheUJ1ZmZlcjtcbiAgICBsZXQgYnl0ZU9mZnNldCA9IHRoaXMuYnVmZmVyc1tidWZmZXJJbmRleF0uYnl0ZU9mZnNldCB8fCAwO1xuICAgIGlmICgnYnl0ZU9mZnNldCcgaW4gYnVmZmVyVmlldykge1xuICAgICAgYnl0ZU9mZnNldCArPSBidWZmZXJWaWV3LmJ5dGVPZmZzZXQ7XG4gICAgfVxuICAgIHJlc3VsdC5kYXRhID0gbmV3IFVpbnQ4QXJyYXkoYXJyYXlCdWZmZXIsIGJ5dGVPZmZzZXQsIGJ1ZmZlclZpZXcuYnl0ZUxlbmd0aCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuICBfcmVzb2x2ZUNhbWVyYShjYW1lcmEsIGluZGV4KSB7XG4gICAgY2FtZXJhLmlkID0gY2FtZXJhLmlkIHx8IFwiY2FtZXJhLVwiLmNvbmNhdChpbmRleCk7XG4gICAgaWYgKGNhbWVyYS5wZXJzcGVjdGl2ZSkge1xuICAgIH1cbiAgICBpZiAoY2FtZXJhLm9ydGhvZ3JhcGhpYykge1xuICAgIH1cbiAgICByZXR1cm4gY2FtZXJhO1xuICB9XG59XG5leHBvcnQgZnVuY3Rpb24gcG9zdFByb2Nlc3NHTFRGKGdsdGYsIG9wdGlvbnMpIHtcbiAgcmV0dXJuIG5ldyBHTFRGUG9zdFByb2Nlc3NvcigpLnBvc3RQcm9jZXNzKGdsdGYsIG9wdGlvbnMpO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cG9zdC1wcm9jZXNzLWdsdGYuanMubWFwIiwiXG5cbmltcG9ydCB7IHBhZFRvTkJ5dGVzLCBhc3NlcnQgfSBmcm9tICdAbG9hZGVycy5nbC9sb2FkZXItdXRpbHMnO1xuY29uc3QgTUFHSUNfZ2xURiA9IDB4Njc2YzU0NDY7XG5cbmNvbnN0IEdMQl9GSUxFX0hFQURFUl9TSVpFID0gMTI7XG5jb25zdCBHTEJfQ0hVTktfSEVBREVSX1NJWkUgPSA4O1xuY29uc3QgR0xCX0NIVU5LX1RZUEVfSlNPTiA9IDB4NGU0ZjUzNGE7XG5jb25zdCBHTEJfQ0hVTktfVFlQRV9CSU4gPSAweDAwNGU0OTQyO1xuY29uc3QgR0xCX0NIVU5LX1RZUEVfSlNPTl9YVklaX0RFUFJFQ0FURUQgPSAwO1xuY29uc3QgR0xCX0NIVU5LX1RZUEVfQklYX1hWSVpfREVQUkVDQVRFRCA9IDE7XG5cbmNvbnN0IEdMQl9WMV9DT05URU5UX0ZPUk1BVF9KU09OID0gMHgwO1xuY29uc3QgTEUgPSB0cnVlO1xuXG5mdW5jdGlvbiBnZXRNYWdpY1N0cmluZyhkYXRhVmlldykge1xuICBsZXQgYnl0ZU9mZnNldCA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogMDtcbiAgcmV0dXJuIFwiXCIuY29uY2F0KFN0cmluZy5mcm9tQ2hhckNvZGUoZGF0YVZpZXcuZ2V0VWludDgoYnl0ZU9mZnNldCArIDApKSkuY29uY2F0KFN0cmluZy5mcm9tQ2hhckNvZGUoZGF0YVZpZXcuZ2V0VWludDgoYnl0ZU9mZnNldCArIDEpKSkuY29uY2F0KFN0cmluZy5mcm9tQ2hhckNvZGUoZGF0YVZpZXcuZ2V0VWludDgoYnl0ZU9mZnNldCArIDIpKSkuY29uY2F0KFN0cmluZy5mcm9tQ2hhckNvZGUoZGF0YVZpZXcuZ2V0VWludDgoYnl0ZU9mZnNldCArIDMpKSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBpc0dMQihhcnJheUJ1ZmZlcikge1xuICBsZXQgYnl0ZU9mZnNldCA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogMDtcbiAgbGV0IG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IHt9O1xuICBjb25zdCBkYXRhVmlldyA9IG5ldyBEYXRhVmlldyhhcnJheUJ1ZmZlcik7XG4gIGNvbnN0IHtcbiAgICBtYWdpYyA9IE1BR0lDX2dsVEZcbiAgfSA9IG9wdGlvbnM7XG4gIGNvbnN0IG1hZ2ljMSA9IGRhdGFWaWV3LmdldFVpbnQzMihieXRlT2Zmc2V0LCBmYWxzZSk7XG4gIHJldHVybiBtYWdpYzEgPT09IG1hZ2ljIHx8IG1hZ2ljMSA9PT0gTUFHSUNfZ2xURjtcbn1cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIHBhcnNlR0xCU3luYyhnbGIsIGFycmF5QnVmZmVyKSB7XG4gIGxldCBieXRlT2Zmc2V0ID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiAwO1xuICBsZXQgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAzICYmIGFyZ3VtZW50c1szXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzNdIDoge307XG4gIGNvbnN0IGRhdGFWaWV3ID0gbmV3IERhdGFWaWV3KGFycmF5QnVmZmVyKTtcblxuICBjb25zdCB0eXBlID0gZ2V0TWFnaWNTdHJpbmcoZGF0YVZpZXcsIGJ5dGVPZmZzZXQgKyAwKTtcbiAgY29uc3QgdmVyc2lvbiA9IGRhdGFWaWV3LmdldFVpbnQzMihieXRlT2Zmc2V0ICsgNCwgTEUpO1xuICBjb25zdCBieXRlTGVuZ3RoID0gZGF0YVZpZXcuZ2V0VWludDMyKGJ5dGVPZmZzZXQgKyA4LCBMRSk7XG5cbiAgT2JqZWN0LmFzc2lnbihnbGIsIHtcbiAgICBoZWFkZXI6IHtcbiAgICAgIGJ5dGVPZmZzZXQsXG4gICAgICBieXRlTGVuZ3RoLFxuICAgICAgaGFzQmluQ2h1bms6IGZhbHNlXG4gICAgfSxcbiAgICB0eXBlLFxuICAgIHZlcnNpb24sXG4gICAganNvbjoge30sXG4gICAgYmluQ2h1bmtzOiBbXVxuICB9KTtcbiAgYnl0ZU9mZnNldCArPSBHTEJfRklMRV9IRUFERVJfU0laRTtcbiAgc3dpdGNoIChnbGIudmVyc2lvbikge1xuICAgIGNhc2UgMTpcbiAgICAgIHJldHVybiBwYXJzZUdMQlYxKGdsYiwgZGF0YVZpZXcsIGJ5dGVPZmZzZXQpO1xuICAgIGNhc2UgMjpcbiAgICAgIHJldHVybiBwYXJzZUdMQlYyKGdsYiwgZGF0YVZpZXcsIGJ5dGVPZmZzZXQsIG9wdGlvbnMgPSB7fSk7XG4gICAgZGVmYXVsdDpcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgR0xCIHZlcnNpb24gXCIuY29uY2F0KGdsYi52ZXJzaW9uLCBcIi4gT25seSBzdXBwb3J0cyB2MSBhbmQgdjIuXCIpKTtcbiAgfVxufVxuZnVuY3Rpb24gcGFyc2VHTEJWMShnbGIsIGRhdGFWaWV3LCBieXRlT2Zmc2V0KSB7XG4gIGFzc2VydChnbGIuaGVhZGVyLmJ5dGVMZW5ndGggPiBHTEJfRklMRV9IRUFERVJfU0laRSArIEdMQl9DSFVOS19IRUFERVJfU0laRSk7XG5cbiAgY29uc3QgY29udGVudExlbmd0aCA9IGRhdGFWaWV3LmdldFVpbnQzMihieXRlT2Zmc2V0ICsgMCwgTEUpO1xuICBjb25zdCBjb250ZW50Rm9ybWF0ID0gZGF0YVZpZXcuZ2V0VWludDMyKGJ5dGVPZmZzZXQgKyA0LCBMRSk7XG4gIGJ5dGVPZmZzZXQgKz0gR0xCX0NIVU5LX0hFQURFUl9TSVpFO1xuXG4gIGFzc2VydChjb250ZW50Rm9ybWF0ID09PSBHTEJfVjFfQ09OVEVOVF9GT1JNQVRfSlNPTik7XG4gIHBhcnNlSlNPTkNodW5rKGdsYiwgZGF0YVZpZXcsIGJ5dGVPZmZzZXQsIGNvbnRlbnRMZW5ndGgpO1xuICBieXRlT2Zmc2V0ICs9IGNvbnRlbnRMZW5ndGg7XG4gIGJ5dGVPZmZzZXQgKz0gcGFyc2VCSU5DaHVuayhnbGIsIGRhdGFWaWV3LCBieXRlT2Zmc2V0LCBnbGIuaGVhZGVyLmJ5dGVMZW5ndGgpO1xuICByZXR1cm4gYnl0ZU9mZnNldDtcbn1cbmZ1bmN0aW9uIHBhcnNlR0xCVjIoZ2xiLCBkYXRhVmlldywgYnl0ZU9mZnNldCwgb3B0aW9ucykge1xuICBhc3NlcnQoZ2xiLmhlYWRlci5ieXRlTGVuZ3RoID4gR0xCX0ZJTEVfSEVBREVSX1NJWkUgKyBHTEJfQ0hVTktfSEVBREVSX1NJWkUpO1xuICBwYXJzZUdMQkNodW5rc1N5bmMoZ2xiLCBkYXRhVmlldywgYnl0ZU9mZnNldCwgb3B0aW9ucyk7XG4gIHJldHVybiBieXRlT2Zmc2V0ICsgZ2xiLmhlYWRlci5ieXRlTGVuZ3RoO1xufVxuZnVuY3Rpb24gcGFyc2VHTEJDaHVua3NTeW5jKGdsYiwgZGF0YVZpZXcsIGJ5dGVPZmZzZXQsIG9wdGlvbnMpIHtcbiAgd2hpbGUgKGJ5dGVPZmZzZXQgKyA4IDw9IGdsYi5oZWFkZXIuYnl0ZUxlbmd0aCkge1xuICAgIGNvbnN0IGNodW5rTGVuZ3RoID0gZGF0YVZpZXcuZ2V0VWludDMyKGJ5dGVPZmZzZXQgKyAwLCBMRSk7XG4gICAgY29uc3QgY2h1bmtGb3JtYXQgPSBkYXRhVmlldy5nZXRVaW50MzIoYnl0ZU9mZnNldCArIDQsIExFKTtcbiAgICBieXRlT2Zmc2V0ICs9IEdMQl9DSFVOS19IRUFERVJfU0laRTtcblxuICAgIHN3aXRjaCAoY2h1bmtGb3JtYXQpIHtcbiAgICAgIGNhc2UgR0xCX0NIVU5LX1RZUEVfSlNPTjpcbiAgICAgICAgcGFyc2VKU09OQ2h1bmsoZ2xiLCBkYXRhVmlldywgYnl0ZU9mZnNldCwgY2h1bmtMZW5ndGgpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgR0xCX0NIVU5LX1RZUEVfQklOOlxuICAgICAgICBwYXJzZUJJTkNodW5rKGdsYiwgZGF0YVZpZXcsIGJ5dGVPZmZzZXQsIGNodW5rTGVuZ3RoKTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgR0xCX0NIVU5LX1RZUEVfSlNPTl9YVklaX0RFUFJFQ0FURUQ6XG4gICAgICAgIGlmICghb3B0aW9ucy5zdHJpY3QpIHtcbiAgICAgICAgICBwYXJzZUpTT05DaHVuayhnbGIsIGRhdGFWaWV3LCBieXRlT2Zmc2V0LCBjaHVua0xlbmd0aCk7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIEdMQl9DSFVOS19UWVBFX0JJWF9YVklaX0RFUFJFQ0FURUQ6XG4gICAgICAgIGlmICghb3B0aW9ucy5zdHJpY3QpIHtcbiAgICAgICAgICBwYXJzZUJJTkNodW5rKGdsYiwgZGF0YVZpZXcsIGJ5dGVPZmZzZXQsIGNodW5rTGVuZ3RoKTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBieXRlT2Zmc2V0ICs9IHBhZFRvTkJ5dGVzKGNodW5rTGVuZ3RoLCA0KTtcbiAgfVxuICByZXR1cm4gYnl0ZU9mZnNldDtcbn1cblxuZnVuY3Rpb24gcGFyc2VKU09OQ2h1bmsoZ2xiLCBkYXRhVmlldywgYnl0ZU9mZnNldCwgY2h1bmtMZW5ndGgpIHtcbiAgY29uc3QganNvbkNodW5rID0gbmV3IFVpbnQ4QXJyYXkoZGF0YVZpZXcuYnVmZmVyLCBieXRlT2Zmc2V0LCBjaHVua0xlbmd0aCk7XG5cbiAgY29uc3QgdGV4dERlY29kZXIgPSBuZXcgVGV4dERlY29kZXIoJ3V0ZjgnKTtcbiAgY29uc3QganNvblRleHQgPSB0ZXh0RGVjb2Rlci5kZWNvZGUoanNvbkNodW5rKTtcblxuICBnbGIuanNvbiA9IEpTT04ucGFyc2UoanNvblRleHQpO1xuICByZXR1cm4gcGFkVG9OQnl0ZXMoY2h1bmtMZW5ndGgsIDQpO1xufVxuXG5mdW5jdGlvbiBwYXJzZUJJTkNodW5rKGdsYiwgZGF0YVZpZXcsIGJ5dGVPZmZzZXQsIGNodW5rTGVuZ3RoKSB7XG4gIGdsYi5oZWFkZXIuaGFzQmluQ2h1bmsgPSB0cnVlO1xuICBnbGIuYmluQ2h1bmtzLnB1c2goe1xuICAgIGJ5dGVPZmZzZXQsXG4gICAgYnl0ZUxlbmd0aDogY2h1bmtMZW5ndGgsXG4gICAgYXJyYXlCdWZmZXI6IGRhdGFWaWV3LmJ1ZmZlclxuICB9KTtcblxuICByZXR1cm4gcGFkVG9OQnl0ZXMoY2h1bmtMZW5ndGgsIDQpO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cGFyc2UtZ2xiLmpzLm1hcCIsIlxuXG5pbXBvcnQgeyBCYXNpc0xvYWRlciwgc2VsZWN0U3VwcG9ydGVkQmFzaXNGb3JtYXQgfSBmcm9tICdAbG9hZGVycy5nbC90ZXh0dXJlcyc7XG5pbXBvcnQgeyBJbWFnZUxvYWRlciB9IGZyb20gJ0Bsb2FkZXJzLmdsL2ltYWdlcyc7XG5pbXBvcnQgeyBwYXJzZUpTT04sIHNsaWNlQXJyYXlCdWZmZXIgfSBmcm9tICdAbG9hZGVycy5nbC9sb2FkZXItdXRpbHMnO1xuaW1wb3J0IHsgYXNzZXJ0IH0gZnJvbSAnLi4vdXRpbHMvYXNzZXJ0JztcbmltcG9ydCB7IHJlc29sdmVVcmwgfSBmcm9tICcuLi9nbHRmLXV0aWxzL3Jlc29sdmUtdXJsJztcbmltcG9ydCB7IGdldFR5cGVkQXJyYXlGb3JCdWZmZXJWaWV3IH0gZnJvbSAnLi4vZ2x0Zi11dGlscy9nZXQtdHlwZWQtYXJyYXknO1xuaW1wb3J0IHsgcHJlcHJvY2Vzc0V4dGVuc2lvbnMsIGRlY29kZUV4dGVuc2lvbnMgfSBmcm9tICcuLi9hcGkvZ2x0Zi1leHRlbnNpb25zJztcbmltcG9ydCB7IG5vcm1hbGl6ZUdMVEZWMSB9IGZyb20gJy4uL2FwaS9ub3JtYWxpemUtZ2x0Zi12MSc7XG5pbXBvcnQgeyBwb3N0UHJvY2Vzc0dMVEYgfSBmcm9tICcuLi9hcGkvcG9zdC1wcm9jZXNzLWdsdGYnO1xuaW1wb3J0IHBhcnNlR0xCU3luYywgeyBpc0dMQiB9IGZyb20gJy4vcGFyc2UtZ2xiJztcblxuZXhwb3J0IGZ1bmN0aW9uIGlzR0xURihhcnJheUJ1ZmZlciwgb3B0aW9ucykge1xuICBjb25zdCBieXRlT2Zmc2V0ID0gMDtcbiAgcmV0dXJuIGlzR0xCKGFycmF5QnVmZmVyLCBieXRlT2Zmc2V0LCBvcHRpb25zKTtcbn1cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBwYXJzZUdMVEYoZ2x0ZiwgYXJyYXlCdWZmZXJPclN0cmluZykge1xuICB2YXIgX29wdGlvbnMkZ2x0ZiwgX29wdGlvbnMkZ2x0ZjIsIF9vcHRpb25zJGdsdGYzLCBfb3B0aW9ucyRnbHRmNDtcbiAgbGV0IGJ5dGVPZmZzZXQgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IDA7XG4gIGxldCBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDMgPyBhcmd1bWVudHNbM10gOiB1bmRlZmluZWQ7XG4gIGxldCBjb250ZXh0ID0gYXJndW1lbnRzLmxlbmd0aCA+IDQgPyBhcmd1bWVudHNbNF0gOiB1bmRlZmluZWQ7XG4gIHBhcnNlR0xURkNvbnRhaW5lclN5bmMoZ2x0ZiwgYXJyYXlCdWZmZXJPclN0cmluZywgYnl0ZU9mZnNldCwgb3B0aW9ucyk7XG4gIG5vcm1hbGl6ZUdMVEZWMShnbHRmLCB7XG4gICAgbm9ybWFsaXplOiBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IChfb3B0aW9ucyRnbHRmID0gb3B0aW9ucy5nbHRmKSA9PT0gbnVsbCB8fCBfb3B0aW9ucyRnbHRmID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfb3B0aW9ucyRnbHRmLm5vcm1hbGl6ZVxuICB9KTtcbiAgcHJlcHJvY2Vzc0V4dGVuc2lvbnMoZ2x0Ziwgb3B0aW9ucywgY29udGV4dCk7XG4gIGNvbnN0IHByb21pc2VzID0gW107XG5cbiAgaWYgKG9wdGlvbnMgIT09IG51bGwgJiYgb3B0aW9ucyAhPT0gdm9pZCAwICYmIChfb3B0aW9ucyRnbHRmMiA9IG9wdGlvbnMuZ2x0ZikgIT09IG51bGwgJiYgX29wdGlvbnMkZ2x0ZjIgIT09IHZvaWQgMCAmJiBfb3B0aW9ucyRnbHRmMi5sb2FkQnVmZmVycyAmJiBnbHRmLmpzb24uYnVmZmVycykge1xuICAgIGF3YWl0IGxvYWRCdWZmZXJzKGdsdGYsIG9wdGlvbnMsIGNvbnRleHQpO1xuICB9XG4gIGlmIChvcHRpb25zICE9PSBudWxsICYmIG9wdGlvbnMgIT09IHZvaWQgMCAmJiAoX29wdGlvbnMkZ2x0ZjMgPSBvcHRpb25zLmdsdGYpICE9PSBudWxsICYmIF9vcHRpb25zJGdsdGYzICE9PSB2b2lkIDAgJiYgX29wdGlvbnMkZ2x0ZjMubG9hZEltYWdlcykge1xuICAgIGNvbnN0IHByb21pc2UgPSBsb2FkSW1hZ2VzKGdsdGYsIG9wdGlvbnMsIGNvbnRleHQpO1xuICAgIHByb21pc2VzLnB1c2gocHJvbWlzZSk7XG4gIH1cbiAgY29uc3QgcHJvbWlzZSA9IGRlY29kZUV4dGVuc2lvbnMoZ2x0Ziwgb3B0aW9ucywgY29udGV4dCk7XG4gIHByb21pc2VzLnB1c2gocHJvbWlzZSk7XG5cbiAgYXdhaXQgUHJvbWlzZS5hbGwocHJvbWlzZXMpO1xuXG4gIHJldHVybiBvcHRpb25zICE9PSBudWxsICYmIG9wdGlvbnMgIT09IHZvaWQgMCAmJiAoX29wdGlvbnMkZ2x0ZjQgPSBvcHRpb25zLmdsdGYpICE9PSBudWxsICYmIF9vcHRpb25zJGdsdGY0ICE9PSB2b2lkIDAgJiYgX29wdGlvbnMkZ2x0ZjQucG9zdFByb2Nlc3MgPyBwb3N0UHJvY2Vzc0dMVEYoZ2x0Ziwgb3B0aW9ucykgOiBnbHRmO1xufVxuXG5mdW5jdGlvbiBwYXJzZUdMVEZDb250YWluZXJTeW5jKGdsdGYsIGRhdGEsIGJ5dGVPZmZzZXQsIG9wdGlvbnMpIHtcbiAgaWYgKG9wdGlvbnMudXJpKSB7XG4gICAgZ2x0Zi5iYXNlVXJpID0gb3B0aW9ucy51cmk7XG4gIH1cblxuICBpZiAoZGF0YSBpbnN0YW5jZW9mIEFycmF5QnVmZmVyICYmICFpc0dMQihkYXRhLCBieXRlT2Zmc2V0LCBvcHRpb25zKSkge1xuICAgIGNvbnN0IHRleHREZWNvZGVyID0gbmV3IFRleHREZWNvZGVyKCk7XG4gICAgZGF0YSA9IHRleHREZWNvZGVyLmRlY29kZShkYXRhKTtcbiAgfVxuICBpZiAodHlwZW9mIGRhdGEgPT09ICdzdHJpbmcnKSB7XG4gICAgZ2x0Zi5qc29uID0gcGFyc2VKU09OKGRhdGEpO1xuICB9IGVsc2UgaWYgKGRhdGEgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikge1xuICAgIGNvbnN0IGdsYiA9IHt9O1xuICAgIGJ5dGVPZmZzZXQgPSBwYXJzZUdMQlN5bmMoZ2xiLCBkYXRhLCBieXRlT2Zmc2V0LCBvcHRpb25zLmdsYik7XG4gICAgYXNzZXJ0KGdsYi50eXBlID09PSAnZ2xURicsIFwiSW52YWxpZCBHTEIgbWFnaWMgc3RyaW5nIFwiLmNvbmNhdChnbGIudHlwZSkpO1xuICAgIGdsdGYuX2dsYiA9IGdsYjtcbiAgICBnbHRmLmpzb24gPSBnbGIuanNvbjtcbiAgfSBlbHNlIHtcbiAgICBhc3NlcnQoZmFsc2UsICdHTFRGOiBtdXN0IGJlIEFycmF5QnVmZmVyIG9yIHN0cmluZycpO1xuICB9XG5cbiAgY29uc3QgYnVmZmVycyA9IGdsdGYuanNvbi5idWZmZXJzIHx8IFtdO1xuICBnbHRmLmJ1ZmZlcnMgPSBuZXcgQXJyYXkoYnVmZmVycy5sZW5ndGgpLmZpbGwobnVsbCk7XG5cbiAgaWYgKGdsdGYuX2dsYiAmJiBnbHRmLl9nbGIuaGVhZGVyLmhhc0JpbkNodW5rKSB7XG4gICAgY29uc3Qge1xuICAgICAgYmluQ2h1bmtzXG4gICAgfSA9IGdsdGYuX2dsYjtcbiAgICBnbHRmLmJ1ZmZlcnNbMF0gPSB7XG4gICAgICBhcnJheUJ1ZmZlcjogYmluQ2h1bmtzWzBdLmFycmF5QnVmZmVyLFxuICAgICAgYnl0ZU9mZnNldDogYmluQ2h1bmtzWzBdLmJ5dGVPZmZzZXQsXG4gICAgICBieXRlTGVuZ3RoOiBiaW5DaHVua3NbMF0uYnl0ZUxlbmd0aFxuICAgIH07XG5cbiAgfVxuXG4gIGNvbnN0IGltYWdlcyA9IGdsdGYuanNvbi5pbWFnZXMgfHwgW107XG4gIGdsdGYuaW1hZ2VzID0gbmV3IEFycmF5KGltYWdlcy5sZW5ndGgpLmZpbGwoe30pO1xufVxuXG5hc3luYyBmdW5jdGlvbiBsb2FkQnVmZmVycyhnbHRmLCBvcHRpb25zLCBjb250ZXh0KSB7XG4gIGNvbnN0IGJ1ZmZlcnMgPSBnbHRmLmpzb24uYnVmZmVycyB8fCBbXTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBidWZmZXJzLmxlbmd0aDsgKytpKSB7XG4gICAgY29uc3QgYnVmZmVyID0gYnVmZmVyc1tpXTtcbiAgICBpZiAoYnVmZmVyLnVyaSkge1xuICAgICAgdmFyIF9jb250ZXh0JGZldGNoLCBfcmVzcG9uc2UkYXJyYXlCdWZmZXI7XG4gICAgICBjb25zdCB7XG4gICAgICAgIGZldGNoXG4gICAgICB9ID0gY29udGV4dDtcbiAgICAgIGFzc2VydChmZXRjaCk7XG4gICAgICBjb25zdCB1cmkgPSByZXNvbHZlVXJsKGJ1ZmZlci51cmksIG9wdGlvbnMpO1xuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCAoY29udGV4dCA9PT0gbnVsbCB8fCBjb250ZXh0ID09PSB2b2lkIDAgPyB2b2lkIDAgOiAoX2NvbnRleHQkZmV0Y2ggPSBjb250ZXh0LmZldGNoKSA9PT0gbnVsbCB8fCBfY29udGV4dCRmZXRjaCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2NvbnRleHQkZmV0Y2guY2FsbChjb250ZXh0LCB1cmkpKTtcbiAgICAgIGNvbnN0IGFycmF5QnVmZmVyID0gYXdhaXQgKHJlc3BvbnNlID09PSBudWxsIHx8IHJlc3BvbnNlID09PSB2b2lkIDAgPyB2b2lkIDAgOiAoX3Jlc3BvbnNlJGFycmF5QnVmZmVyID0gcmVzcG9uc2UuYXJyYXlCdWZmZXIpID09PSBudWxsIHx8IF9yZXNwb25zZSRhcnJheUJ1ZmZlciA9PT0gdm9pZCAwID8gdm9pZCAwIDogX3Jlc3BvbnNlJGFycmF5QnVmZmVyLmNhbGwocmVzcG9uc2UpKTtcbiAgICAgIGdsdGYuYnVmZmVyc1tpXSA9IHtcbiAgICAgICAgYXJyYXlCdWZmZXIsXG4gICAgICAgIGJ5dGVPZmZzZXQ6IDAsXG4gICAgICAgIGJ5dGVMZW5ndGg6IGFycmF5QnVmZmVyLmJ5dGVMZW5ndGhcbiAgICAgIH07XG4gICAgICBkZWxldGUgYnVmZmVyLnVyaTtcbiAgICB9IGVsc2UgaWYgKGdsdGYuYnVmZmVyc1tpXSA9PT0gbnVsbCkge1xuICAgICAgZ2x0Zi5idWZmZXJzW2ldID0ge1xuICAgICAgICBhcnJheUJ1ZmZlcjogbmV3IEFycmF5QnVmZmVyKGJ1ZmZlci5ieXRlTGVuZ3RoKSxcbiAgICAgICAgYnl0ZU9mZnNldDogMCxcbiAgICAgICAgYnl0ZUxlbmd0aDogYnVmZmVyLmJ5dGVMZW5ndGhcbiAgICAgIH07XG4gICAgfVxuICB9XG59XG5cbmFzeW5jIGZ1bmN0aW9uIGxvYWRJbWFnZXMoZ2x0Ziwgb3B0aW9ucywgY29udGV4dCkge1xuICBjb25zdCBpbWFnZUluZGljZXMgPSBnZXRSZWZlcmVuY2VzSW1hZ2VJbmRpY2VzKGdsdGYpO1xuICBjb25zdCBpbWFnZXMgPSBnbHRmLmpzb24uaW1hZ2VzIHx8IFtdO1xuICBjb25zdCBwcm9taXNlcyA9IFtdO1xuICBmb3IgKGNvbnN0IGltYWdlSW5kZXggb2YgaW1hZ2VJbmRpY2VzKSB7XG4gICAgcHJvbWlzZXMucHVzaChsb2FkSW1hZ2UoZ2x0ZiwgaW1hZ2VzW2ltYWdlSW5kZXhdLCBpbWFnZUluZGV4LCBvcHRpb25zLCBjb250ZXh0KSk7XG4gIH1cbiAgcmV0dXJuIGF3YWl0IFByb21pc2UuYWxsKHByb21pc2VzKTtcbn1cblxuZnVuY3Rpb24gZ2V0UmVmZXJlbmNlc0ltYWdlSW5kaWNlcyhnbHRmKSB7XG4gIGNvbnN0IGltYWdlSW5kaWNlcyA9IG5ldyBTZXQoKTtcbiAgY29uc3QgdGV4dHVyZXMgPSBnbHRmLmpzb24udGV4dHVyZXMgfHwgW107XG4gIGZvciAoY29uc3QgdGV4dHVyZSBvZiB0ZXh0dXJlcykge1xuICAgIGlmICh0ZXh0dXJlLnNvdXJjZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBpbWFnZUluZGljZXMuYWRkKHRleHR1cmUuc291cmNlKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIEFycmF5LmZyb20oaW1hZ2VJbmRpY2VzKS5zb3J0KCk7XG59XG5cbmFzeW5jIGZ1bmN0aW9uIGxvYWRJbWFnZShnbHRmLCBpbWFnZSwgaW5kZXgsIG9wdGlvbnMsIGNvbnRleHQpIHtcbiAgY29uc3Qge1xuICAgIGZldGNoLFxuICAgIHBhcnNlXG4gIH0gPSBjb250ZXh0O1xuICBsZXQgYXJyYXlCdWZmZXI7XG4gIGlmIChpbWFnZS51cmkgJiYgIWltYWdlLmhhc093blByb3BlcnR5KCdidWZmZXJWaWV3JykpIHtcbiAgICBjb25zdCB1cmkgPSByZXNvbHZlVXJsKGltYWdlLnVyaSwgb3B0aW9ucyk7XG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaCh1cmkpO1xuICAgIGFycmF5QnVmZmVyID0gYXdhaXQgcmVzcG9uc2UuYXJyYXlCdWZmZXIoKTtcbiAgICBpbWFnZS5idWZmZXJWaWV3ID0ge1xuICAgICAgZGF0YTogYXJyYXlCdWZmZXJcbiAgICB9O1xuICB9XG4gIGlmIChOdW1iZXIuaXNGaW5pdGUoaW1hZ2UuYnVmZmVyVmlldykpIHtcbiAgICBjb25zdCBhcnJheSA9IGdldFR5cGVkQXJyYXlGb3JCdWZmZXJWaWV3KGdsdGYuanNvbiwgZ2x0Zi5idWZmZXJzLCBpbWFnZS5idWZmZXJWaWV3KTtcbiAgICBhcnJheUJ1ZmZlciA9IHNsaWNlQXJyYXlCdWZmZXIoYXJyYXkuYnVmZmVyLCBhcnJheS5ieXRlT2Zmc2V0LCBhcnJheS5ieXRlTGVuZ3RoKTtcbiAgfVxuICBhc3NlcnQoYXJyYXlCdWZmZXIsICdnbFRGIGltYWdlIGhhcyBubyBkYXRhJyk7XG5cbiAgbGV0IHBhcnNlZEltYWdlID0gYXdhaXQgcGFyc2UoYXJyYXlCdWZmZXIsIFtJbWFnZUxvYWRlciwgQmFzaXNMb2FkZXJdLCB7XG4gICAgbWltZVR5cGU6IGltYWdlLm1pbWVUeXBlLFxuICAgIGJhc2lzOiBvcHRpb25zLmJhc2lzIHx8IHtcbiAgICAgIGZvcm1hdDogc2VsZWN0U3VwcG9ydGVkQmFzaXNGb3JtYXQoKVxuICAgIH1cbiAgfSwgY29udGV4dCk7XG4gIGlmIChwYXJzZWRJbWFnZSAmJiBwYXJzZWRJbWFnZVswXSkge1xuICAgIHBhcnNlZEltYWdlID0ge1xuICAgICAgY29tcHJlc3NlZDogdHJ1ZSxcbiAgICAgIG1pcG1hcHM6IGZhbHNlLFxuICAgICAgd2lkdGg6IHBhcnNlZEltYWdlWzBdLndpZHRoLFxuICAgICAgaGVpZ2h0OiBwYXJzZWRJbWFnZVswXS5oZWlnaHQsXG4gICAgICBkYXRhOiBwYXJzZWRJbWFnZVswXVxuICAgIH07XG4gIH1cblxuICBnbHRmLmltYWdlcyA9IGdsdGYuaW1hZ2VzIHx8IFtdO1xuICBnbHRmLmltYWdlc1tpbmRleF0gPSBwYXJzZWRJbWFnZTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXBhcnNlLWdsdGYuanMubWFwIiwiaW1wb3J0IHsgVkVSU0lPTiB9IGZyb20gJy4vbGliL3V0aWxzL3ZlcnNpb24nO1xuaW1wb3J0IHsgcGFyc2VHTFRGIH0gZnJvbSAnLi9saWIvcGFyc2Vycy9wYXJzZS1nbHRmJztcbmV4cG9ydCBjb25zdCBHTFRGTG9hZGVyID0ge1xuICBuYW1lOiAnZ2xURicsXG4gIGlkOiAnZ2x0ZicsXG4gIG1vZHVsZTogJ2dsdGYnLFxuICB2ZXJzaW9uOiBWRVJTSU9OLFxuICBleHRlbnNpb25zOiBbJ2dsdGYnLCAnZ2xiJ10sXG4gIG1pbWVUeXBlczogWydtb2RlbC9nbHRmK2pzb24nLCAnbW9kZWwvZ2x0Zi1iaW5hcnknXSxcbiAgdGV4dDogdHJ1ZSxcbiAgYmluYXJ5OiB0cnVlLFxuICB0ZXN0czogWydnbFRGJ10sXG4gIHBhcnNlLFxuICBvcHRpb25zOiB7XG4gICAgZ2x0Zjoge1xuICAgICAgbm9ybWFsaXplOiB0cnVlLFxuICAgICAgbG9hZEJ1ZmZlcnM6IHRydWUsXG4gICAgICBsb2FkSW1hZ2VzOiB0cnVlLFxuICAgICAgZGVjb21wcmVzc01lc2hlczogdHJ1ZSxcbiAgICAgIHBvc3RQcm9jZXNzOiB0cnVlXG4gICAgfSxcblxuICAgIGxvZzogY29uc29sZVxuICB9LFxuXG4gIGRlcHJlY2F0ZWRPcHRpb25zOiB7XG4gICAgZmV0Y2hJbWFnZXM6ICdnbHRmLmxvYWRJbWFnZXMnLFxuICAgIGNyZWF0ZUltYWdlczogJ2dsdGYubG9hZEltYWdlcycsXG4gICAgZGVjb21wcmVzczogJ2dsdGYuZGVjb21wcmVzc01lc2hlcycsXG4gICAgcG9zdFByb2Nlc3M6ICdnbHRmLnBvc3RQcm9jZXNzJyxcbiAgICBnbHRmOiB7XG4gICAgICBkZWNvbXByZXNzOiAnZ2x0Zi5kZWNvbXByZXNzTWVzaGVzJ1xuICAgIH1cbiAgfVxufTtcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBwYXJzZShhcnJheUJ1ZmZlcikge1xuICBsZXQgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG4gIGxldCBjb250ZXh0ID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgPyBhcmd1bWVudHNbMl0gOiB1bmRlZmluZWQ7XG4gIG9wdGlvbnMgPSB7XG4gICAgLi4uR0xURkxvYWRlci5vcHRpb25zLFxuICAgIC4uLm9wdGlvbnNcbiAgfTtcbiAgb3B0aW9ucy5nbHRmID0ge1xuICAgIC4uLkdMVEZMb2FkZXIub3B0aW9ucy5nbHRmLFxuICAgIC4uLm9wdGlvbnMuZ2x0ZlxuICB9O1xuICBjb25zdCB7XG4gICAgYnl0ZU9mZnNldCA9IDBcbiAgfSA9IG9wdGlvbnM7XG4gIGNvbnN0IGdsdGYgPSB7fTtcbiAgcmV0dXJuIGF3YWl0IHBhcnNlR0xURihnbHRmLCBhcnJheUJ1ZmZlciwgYnl0ZU9mZnNldCwgb3B0aW9ucywgY29udGV4dCk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1nbHRmLWxvYWRlci5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///52462\n")},54022:function(__unused_webpack_module,__webpack_exports__,__webpack_require__){eval("\n// EXPORTS\n__webpack_require__.d(__webpack_exports__, {\n  \"S\": function() { return /* binding */ ImageLoader; }\n});\n\n// UNUSED EXPORTS: _typecheckImageLoader\n\n;// CONCATENATED MODULE: ./node_modules/@loaders.gl/images/dist/esm/lib/utils/version.js\n\nconst VERSION =  true ? \"3.3.1\" : 0;\n//# sourceMappingURL=version.js.map\n// EXTERNAL MODULE: ./node_modules/@loaders.gl/loader-utils/dist/esm/lib/env-utils/assert.js\nvar assert = __webpack_require__(16269);\n// EXTERNAL MODULE: ./node_modules/@loaders.gl/loader-utils/dist/esm/lib/env-utils/globals.js\nvar globals = __webpack_require__(84959);\n;// CONCATENATED MODULE: ./node_modules/@loaders.gl/images/dist/esm/lib/category-api/image-type.js\n\nconst {\n  _parseImageNode\n} = globalThis;\nconst IMAGE_SUPPORTED = typeof Image !== 'undefined';\nconst IMAGE_BITMAP_SUPPORTED = typeof ImageBitmap !== 'undefined';\nconst NODE_IMAGE_SUPPORTED = Boolean(_parseImageNode);\nconst DATA_SUPPORTED = globals/* isBrowser */.jU ? true : NODE_IMAGE_SUPPORTED;\n\nfunction isImageTypeSupported(type) {\n  switch (type) {\n    case 'auto':\n      return IMAGE_BITMAP_SUPPORTED || IMAGE_SUPPORTED || DATA_SUPPORTED;\n    case 'imagebitmap':\n      return IMAGE_BITMAP_SUPPORTED;\n    case 'image':\n      return IMAGE_SUPPORTED;\n    case 'data':\n      return DATA_SUPPORTED;\n    default:\n      throw new Error(\"@loaders.gl/images: image \".concat(type, \" not supported in this environment\"));\n  }\n}\n\nfunction getDefaultImageType() {\n  if (IMAGE_BITMAP_SUPPORTED) {\n    return 'imagebitmap';\n  }\n  if (IMAGE_SUPPORTED) {\n    return 'image';\n  }\n  if (DATA_SUPPORTED) {\n    return 'data';\n  }\n\n  throw new Error('Install \\'@loaders.gl/polyfills\\' to parse images under Node.js');\n}\n//# sourceMappingURL=image-type.js.map\n;// CONCATENATED MODULE: ./node_modules/@loaders.gl/images/dist/esm/lib/category-api/parsed-image-api.js\nfunction isImage(image) {\n  return Boolean(getImageTypeOrNull(image));\n}\nfunction deleteImage(image) {\n  switch (getImageType(image)) {\n    case 'imagebitmap':\n      image.close();\n      break;\n    default:\n  }\n}\n\nfunction getImageType(image) {\n  const format = getImageTypeOrNull(image);\n  if (!format) {\n    throw new Error('Not an image');\n  }\n  return format;\n}\nfunction getImageSize(image) {\n  return getImageData(image);\n}\nfunction getImageData(image) {\n  switch (getImageType(image)) {\n    case 'data':\n      return image;\n    case 'image':\n    case 'imagebitmap':\n      const canvas = document.createElement('canvas');\n      const context = canvas.getContext('2d');\n      if (!context) {\n        throw new Error('getImageData');\n      }\n      canvas.width = image.width;\n      canvas.height = image.height;\n      context.drawImage(image, 0, 0);\n      return context.getImageData(0, 0, image.width, image.height);\n    default:\n      throw new Error('getImageData');\n  }\n}\n\nfunction getImageTypeOrNull(image) {\n  if (typeof ImageBitmap !== 'undefined' && image instanceof ImageBitmap) {\n    return 'imagebitmap';\n  }\n  if (typeof Image !== 'undefined' && image instanceof Image) {\n    return 'image';\n  }\n  if (image && typeof image === 'object' && image.data && image.width && image.height) {\n    return 'data';\n  }\n  return null;\n}\n//# sourceMappingURL=parsed-image-api.js.map\n;// CONCATENATED MODULE: ./node_modules/@loaders.gl/images/dist/esm/lib/parsers/svg-utils.js\n\n\nconst SVG_DATA_URL_PATTERN = /^data:image\\/svg\\+xml/;\nconst SVG_URL_PATTERN = /\\.svg((\\?|#).*)?$/;\nfunction isSVG(url) {\n  return url && (SVG_DATA_URL_PATTERN.test(url) || SVG_URL_PATTERN.test(url));\n}\nfunction getBlobOrSVGDataUrl(arrayBuffer, url) {\n  if (isSVG(url)) {\n    const textDecoder = new TextDecoder();\n    let xmlText = textDecoder.decode(arrayBuffer);\n    try {\n      if (typeof unescape === 'function' && typeof encodeURIComponent === 'function') {\n        xmlText = unescape(encodeURIComponent(xmlText));\n      }\n    } catch (error) {\n      throw new Error(error.message);\n    }\n    const src = \"data:image/svg+xml;base64,\".concat(btoa(xmlText));\n    return src;\n  }\n  return getBlob(arrayBuffer, url);\n}\nfunction getBlob(arrayBuffer, url) {\n  if (isSVG(url)) {\n    throw new Error('SVG cannot be parsed directly to imagebitmap');\n  }\n  return new Blob([new Uint8Array(arrayBuffer)]);\n}\n//# sourceMappingURL=svg-utils.js.map\n;// CONCATENATED MODULE: ./node_modules/@loaders.gl/images/dist/esm/lib/parsers/parse-to-image.js\n\n\nasync function parseToImage(arrayBuffer, options, url) {\n\n  const blobOrDataUrl = getBlobOrSVGDataUrl(arrayBuffer, url);\n  const URL = self.URL || self.webkitURL;\n  const objectUrl = typeof blobOrDataUrl !== 'string' && URL.createObjectURL(blobOrDataUrl);\n  try {\n    return await loadToImage(objectUrl || blobOrDataUrl, options);\n  } finally {\n    if (objectUrl) {\n      URL.revokeObjectURL(objectUrl);\n    }\n  }\n}\nasync function loadToImage(url, options) {\n  const image = new Image();\n  image.src = url;\n\n  if (options.image && options.image.decode && image.decode) {\n    await image.decode();\n    return image;\n  }\n\n  return await new Promise((resolve, reject) => {\n    try {\n      image.onload = () => resolve(image);\n      image.onerror = err => reject(new Error(\"Could not load image \".concat(url, \": \").concat(err)));\n    } catch (error) {\n      reject(error);\n    }\n  });\n}\n//# sourceMappingURL=parse-to-image.js.map\n;// CONCATENATED MODULE: ./node_modules/@loaders.gl/images/dist/esm/lib/parsers/parse-to-image-bitmap.js\n\n\nconst EMPTY_OBJECT = {};\nlet imagebitmapOptionsSupported = true;\n\nasync function parseToImageBitmap(arrayBuffer, options, url) {\n  let blob;\n\n  if (isSVG(url)) {\n    const image = await parseToImage(arrayBuffer, options, url);\n    blob = image;\n  } else {\n    blob = getBlob(arrayBuffer, url);\n  }\n  const imagebitmapOptions = options && options.imagebitmap;\n  return await safeCreateImageBitmap(blob, imagebitmapOptions);\n}\n\nasync function safeCreateImageBitmap(blob) {\n  let imagebitmapOptions = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n  if (isEmptyObject(imagebitmapOptions) || !imagebitmapOptionsSupported) {\n    imagebitmapOptions = null;\n  }\n  if (imagebitmapOptions) {\n    try {\n      return await createImageBitmap(blob, imagebitmapOptions);\n    } catch (error) {\n      console.warn(error);\n      imagebitmapOptionsSupported = false;\n    }\n  }\n  return await createImageBitmap(blob);\n}\nfunction isEmptyObject(object) {\n  for (const key in object || EMPTY_OBJECT) {\n    return false;\n  }\n  return true;\n}\n//# sourceMappingURL=parse-to-image-bitmap.js.map\n// EXTERNAL MODULE: ./node_modules/@loaders.gl/images/dist/esm/lib/category-api/binary-image-api.js\nvar binary_image_api = __webpack_require__(39105);\n;// CONCATENATED MODULE: ./node_modules/@loaders.gl/images/dist/esm/lib/parsers/parse-to-node-image.js\n\n\n\nasync function parseToNodeImage(arrayBuffer, options) {\n  const {\n    mimeType\n  } = (0,binary_image_api/* getBinaryImageMetadata */.I)(arrayBuffer) || {};\n\n  const _parseImageNode = globalThis._parseImageNode;\n  (0,assert/* assert */.h)(_parseImageNode);\n\n  return await _parseImageNode(arrayBuffer, mimeType);\n}\n//# sourceMappingURL=parse-to-node-image.js.map\n;// CONCATENATED MODULE: ./node_modules/@loaders.gl/images/dist/esm/lib/parsers/parse-image.js\n\n\n\n\n\n\n\nasync function parseImage(arrayBuffer, options, context) {\n  options = options || {};\n  const imageOptions = options.image || {};\n\n  const imageType = imageOptions.type || 'auto';\n  const {\n    url\n  } = context || {};\n\n  const loadType = getLoadableImageType(imageType);\n  let image;\n  switch (loadType) {\n    case 'imagebitmap':\n      image = await parseToImageBitmap(arrayBuffer, options, url);\n      break;\n    case 'image':\n      image = await parseToImage(arrayBuffer, options, url);\n      break;\n    case 'data':\n      image = await parseToNodeImage(arrayBuffer, options);\n      break;\n    default:\n      (0,assert/* assert */.h)(false);\n  }\n\n  if (imageType === 'data') {\n    image = getImageData(image);\n  }\n  return image;\n}\n\nfunction getLoadableImageType(type) {\n  switch (type) {\n    case 'auto':\n    case 'data':\n      return getDefaultImageType();\n    default:\n      isImageTypeSupported(type);\n      return type;\n  }\n}\n//# sourceMappingURL=parse-image.js.map\n;// CONCATENATED MODULE: ./node_modules/@loaders.gl/images/dist/esm/image-loader.js\n\n\n\nconst EXTENSIONS = ['png', 'jpg', 'jpeg', 'gif', 'webp', 'bmp', 'ico', 'svg'];\nconst MIME_TYPES = ['image/png', 'image/jpeg', 'image/gif', 'image/webp', 'image/bmp', 'image/vnd.microsoft.icon', 'image/svg+xml'];\nconst DEFAULT_IMAGE_LOADER_OPTIONS = {\n  image: {\n    type: 'auto',\n    decode: true\n  }\n};\n\nconst ImageLoader = {\n  id: 'image',\n  module: 'images',\n  name: 'Images',\n  version: VERSION,\n  mimeTypes: MIME_TYPES,\n  extensions: EXTENSIONS,\n  parse: parseImage,\n  tests: [arrayBuffer => Boolean((0,binary_image_api/* getBinaryImageMetadata */.I)(new DataView(arrayBuffer)))],\n  options: DEFAULT_IMAGE_LOADER_OPTIONS\n};\nconst _typecheckImageLoader = (/* unused pure expression or super */ null && (ImageLoader));\n//# sourceMappingURL=image-loader.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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Li9ub2RlX21vZHVsZXMvQGxvYWRlcnMuZ2wvaW1hZ2VzL2Rpc3QvZXNtL2xpYi91dGlscy92ZXJzaW9uLmpzPzcxOWMiLCJ3ZWJwYWNrOi8vdnVlMy13ZWJwYWNrNS8uL25vZGVfbW9kdWxlcy9AbG9hZGVycy5nbC9pbWFnZXMvZGlzdC9lc20vbGliL2NhdGVnb3J5LWFwaS9pbWFnZS10eXBlLmpzP2NlNjEiLCJ3ZWJwYWNrOi8vdnVlMy13ZWJwYWNrNS8uL25vZGVfbW9kdWxlcy9AbG9hZGVycy5nbC9pbWFnZXMvZGlzdC9lc20vbGliL2NhdGVnb3J5LWFwaS9wYXJzZWQtaW1hZ2UtYXBpLmpzPzRkZmIiLCJ3ZWJwYWNrOi8vdnVlMy13ZWJwYWNrNS8uL25vZGVfbW9kdWxlcy9AbG9hZGVycy5nbC9pbWFnZXMvZGlzdC9lc20vbGliL3BhcnNlcnMvc3ZnLXV0aWxzLmpzPzU2ZWMiLCJ3ZWJwYWNrOi8vdnVlMy13ZWJwYWNrNS8uL25vZGVfbW9kdWxlcy9AbG9hZGVycy5nbC9pbWFnZXMvZGlzdC9lc20vbGliL3BhcnNlcnMvcGFyc2UtdG8taW1hZ2UuanM/ZGI1YSIsIndlYnBhY2s6Ly92dWUzLXdlYnBhY2s1Ly4vbm9kZV9tb2R1bGVzL0Bsb2FkZXJzLmdsL2ltYWdlcy9kaXN0L2VzbS9saWIvcGFyc2Vycy9wYXJzZS10by1pbWFnZS1iaXRtYXAuanM/OGMyNCIsIndlYnBhY2s6Ly92dWUzLXdlYnBhY2s1Ly4vbm9kZV9tb2R1bGVzL0Bsb2FkZXJzLmdsL2ltYWdlcy9kaXN0L2VzbS9saWIvcGFyc2Vycy9wYXJzZS10by1ub2RlLWltYWdlLmpzPzZjZWYiLCJ3ZWJwYWNrOi8vdnVlMy13ZWJwYWNrNS8uL25vZGVfbW9kdWxlcy9AbG9hZGVycy5nbC9pbWFnZXMvZGlzdC9lc20vbGliL3BhcnNlcnMvcGFyc2UtaW1hZ2UuanM/ZTExYSIsIndlYnBhY2s6Ly92dWUzLXdlYnBhY2s1Ly4vbm9kZV9tb2R1bGVzL0Bsb2FkZXJzLmdsL2ltYWdlcy9kaXN0L2VzbS9pbWFnZS1sb2FkZXIuanM/MjZlZSJdLCJzb3VyY2VzQ29udGVudCI6WyJcbmV4cG9ydCBjb25zdCBWRVJTSU9OID0gdHlwZW9mIFwiMy4zLjFcIiAhPT0gJ3VuZGVmaW5lZCcgPyBcIjMuMy4xXCIgOiAnbGF0ZXN0Jztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXZlcnNpb24uanMubWFwIiwiaW1wb3J0IHsgaXNCcm93c2VyIH0gZnJvbSAnQGxvYWRlcnMuZ2wvbG9hZGVyLXV0aWxzJztcbmNvbnN0IHtcbiAgX3BhcnNlSW1hZ2VOb2RlXG59ID0gZ2xvYmFsVGhpcztcbmNvbnN0IElNQUdFX1NVUFBPUlRFRCA9IHR5cGVvZiBJbWFnZSAhPT0gJ3VuZGVmaW5lZCc7XG5jb25zdCBJTUFHRV9CSVRNQVBfU1VQUE9SVEVEID0gdHlwZW9mIEltYWdlQml0bWFwICE9PSAndW5kZWZpbmVkJztcbmNvbnN0IE5PREVfSU1BR0VfU1VQUE9SVEVEID0gQm9vbGVhbihfcGFyc2VJbWFnZU5vZGUpO1xuY29uc3QgREFUQV9TVVBQT1JURUQgPSBpc0Jyb3dzZXIgPyB0cnVlIDogTk9ERV9JTUFHRV9TVVBQT1JURUQ7XG5cbmV4cG9ydCBmdW5jdGlvbiBpc0ltYWdlVHlwZVN1cHBvcnRlZCh0eXBlKSB7XG4gIHN3aXRjaCAodHlwZSkge1xuICAgIGNhc2UgJ2F1dG8nOlxuICAgICAgcmV0dXJuIElNQUdFX0JJVE1BUF9TVVBQT1JURUQgfHwgSU1BR0VfU1VQUE9SVEVEIHx8IERBVEFfU1VQUE9SVEVEO1xuICAgIGNhc2UgJ2ltYWdlYml0bWFwJzpcbiAgICAgIHJldHVybiBJTUFHRV9CSVRNQVBfU1VQUE9SVEVEO1xuICAgIGNhc2UgJ2ltYWdlJzpcbiAgICAgIHJldHVybiBJTUFHRV9TVVBQT1JURUQ7XG4gICAgY2FzZSAnZGF0YSc6XG4gICAgICByZXR1cm4gREFUQV9TVVBQT1JURUQ7XG4gICAgZGVmYXVsdDpcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkBsb2FkZXJzLmdsL2ltYWdlczogaW1hZ2UgXCIuY29uY2F0KHR5cGUsIFwiIG5vdCBzdXBwb3J0ZWQgaW4gdGhpcyBlbnZpcm9ubWVudFwiKSk7XG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdldERlZmF1bHRJbWFnZVR5cGUoKSB7XG4gIGlmIChJTUFHRV9CSVRNQVBfU1VQUE9SVEVEKSB7XG4gICAgcmV0dXJuICdpbWFnZWJpdG1hcCc7XG4gIH1cbiAgaWYgKElNQUdFX1NVUFBPUlRFRCkge1xuICAgIHJldHVybiAnaW1hZ2UnO1xuICB9XG4gIGlmIChEQVRBX1NVUFBPUlRFRCkge1xuICAgIHJldHVybiAnZGF0YSc7XG4gIH1cblxuICB0aHJvdyBuZXcgRXJyb3IoJ0luc3RhbGwgXFwnQGxvYWRlcnMuZ2wvcG9seWZpbGxzXFwnIHRvIHBhcnNlIGltYWdlcyB1bmRlciBOb2RlLmpzJyk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbWFnZS10eXBlLmpzLm1hcCIsImV4cG9ydCBmdW5jdGlvbiBpc0ltYWdlKGltYWdlKSB7XG4gIHJldHVybiBCb29sZWFuKGdldEltYWdlVHlwZU9yTnVsbChpbWFnZSkpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGRlbGV0ZUltYWdlKGltYWdlKSB7XG4gIHN3aXRjaCAoZ2V0SW1hZ2VUeXBlKGltYWdlKSkge1xuICAgIGNhc2UgJ2ltYWdlYml0bWFwJzpcbiAgICAgIGltYWdlLmNsb3NlKCk7XG4gICAgICBicmVhaztcbiAgICBkZWZhdWx0OlxuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRJbWFnZVR5cGUoaW1hZ2UpIHtcbiAgY29uc3QgZm9ybWF0ID0gZ2V0SW1hZ2VUeXBlT3JOdWxsKGltYWdlKTtcbiAgaWYgKCFmb3JtYXQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ05vdCBhbiBpbWFnZScpO1xuICB9XG4gIHJldHVybiBmb3JtYXQ7XG59XG5leHBvcnQgZnVuY3Rpb24gZ2V0SW1hZ2VTaXplKGltYWdlKSB7XG4gIHJldHVybiBnZXRJbWFnZURhdGEoaW1hZ2UpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGdldEltYWdlRGF0YShpbWFnZSkge1xuICBzd2l0Y2ggKGdldEltYWdlVHlwZShpbWFnZSkpIHtcbiAgICBjYXNlICdkYXRhJzpcbiAgICAgIHJldHVybiBpbWFnZTtcbiAgICBjYXNlICdpbWFnZSc6XG4gICAgY2FzZSAnaW1hZ2ViaXRtYXAnOlxuICAgICAgY29uc3QgY2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyk7XG4gICAgICBjb25zdCBjb250ZXh0ID0gY2FudmFzLmdldENvbnRleHQoJzJkJyk7XG4gICAgICBpZiAoIWNvbnRleHQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdnZXRJbWFnZURhdGEnKTtcbiAgICAgIH1cbiAgICAgIGNhbnZhcy53aWR0aCA9IGltYWdlLndpZHRoO1xuICAgICAgY2FudmFzLmhlaWdodCA9IGltYWdlLmhlaWdodDtcbiAgICAgIGNvbnRleHQuZHJhd0ltYWdlKGltYWdlLCAwLCAwKTtcbiAgICAgIHJldHVybiBjb250ZXh0LmdldEltYWdlRGF0YSgwLCAwLCBpbWFnZS53aWR0aCwgaW1hZ2UuaGVpZ2h0KTtcbiAgICBkZWZhdWx0OlxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdnZXRJbWFnZURhdGEnKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBnZXRJbWFnZVR5cGVPck51bGwoaW1hZ2UpIHtcbiAgaWYgKHR5cGVvZiBJbWFnZUJpdG1hcCAhPT0gJ3VuZGVmaW5lZCcgJiYgaW1hZ2UgaW5zdGFuY2VvZiBJbWFnZUJpdG1hcCkge1xuICAgIHJldHVybiAnaW1hZ2ViaXRtYXAnO1xuICB9XG4gIGlmICh0eXBlb2YgSW1hZ2UgIT09ICd1bmRlZmluZWQnICYmIGltYWdlIGluc3RhbmNlb2YgSW1hZ2UpIHtcbiAgICByZXR1cm4gJ2ltYWdlJztcbiAgfVxuICBpZiAoaW1hZ2UgJiYgdHlwZW9mIGltYWdlID09PSAnb2JqZWN0JyAmJiBpbWFnZS5kYXRhICYmIGltYWdlLndpZHRoICYmIGltYWdlLmhlaWdodCkge1xuICAgIHJldHVybiAnZGF0YSc7XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1wYXJzZWQtaW1hZ2UtYXBpLmpzLm1hcCIsIlxuXG5jb25zdCBTVkdfREFUQV9VUkxfUEFUVEVSTiA9IC9eZGF0YTppbWFnZVxcL3N2Z1xcK3htbC87XG5jb25zdCBTVkdfVVJMX1BBVFRFUk4gPSAvXFwuc3ZnKChcXD98IykuKik/JC87XG5leHBvcnQgZnVuY3Rpb24gaXNTVkcodXJsKSB7XG4gIHJldHVybiB1cmwgJiYgKFNWR19EQVRBX1VSTF9QQVRURVJOLnRlc3QodXJsKSB8fCBTVkdfVVJMX1BBVFRFUk4udGVzdCh1cmwpKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBnZXRCbG9iT3JTVkdEYXRhVXJsKGFycmF5QnVmZmVyLCB1cmwpIHtcbiAgaWYgKGlzU1ZHKHVybCkpIHtcbiAgICBjb25zdCB0ZXh0RGVjb2RlciA9IG5ldyBUZXh0RGVjb2RlcigpO1xuICAgIGxldCB4bWxUZXh0ID0gdGV4dERlY29kZXIuZGVjb2RlKGFycmF5QnVmZmVyKTtcbiAgICB0cnkge1xuICAgICAgaWYgKHR5cGVvZiB1bmVzY2FwZSA9PT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgZW5jb2RlVVJJQ29tcG9uZW50ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHhtbFRleHQgPSB1bmVzY2FwZShlbmNvZGVVUklDb21wb25lbnQoeG1sVGV4dCkpO1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoZXJyb3IubWVzc2FnZSk7XG4gICAgfVxuICAgIGNvbnN0IHNyYyA9IFwiZGF0YTppbWFnZS9zdmcreG1sO2Jhc2U2NCxcIi5jb25jYXQoYnRvYSh4bWxUZXh0KSk7XG4gICAgcmV0dXJuIHNyYztcbiAgfVxuICByZXR1cm4gZ2V0QmxvYihhcnJheUJ1ZmZlciwgdXJsKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBnZXRCbG9iKGFycmF5QnVmZmVyLCB1cmwpIHtcbiAgaWYgKGlzU1ZHKHVybCkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1NWRyBjYW5ub3QgYmUgcGFyc2VkIGRpcmVjdGx5IHRvIGltYWdlYml0bWFwJyk7XG4gIH1cbiAgcmV0dXJuIG5ldyBCbG9iKFtuZXcgVWludDhBcnJheShhcnJheUJ1ZmZlcildKTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXN2Zy11dGlscy5qcy5tYXAiLCJpbXBvcnQgeyBnZXRCbG9iT3JTVkdEYXRhVXJsIH0gZnJvbSAnLi9zdmctdXRpbHMnO1xuXG5leHBvcnQgZGVmYXVsdCBhc3luYyBmdW5jdGlvbiBwYXJzZVRvSW1hZ2UoYXJyYXlCdWZmZXIsIG9wdGlvbnMsIHVybCkge1xuXG4gIGNvbnN0IGJsb2JPckRhdGFVcmwgPSBnZXRCbG9iT3JTVkdEYXRhVXJsKGFycmF5QnVmZmVyLCB1cmwpO1xuICBjb25zdCBVUkwgPSBzZWxmLlVSTCB8fCBzZWxmLndlYmtpdFVSTDtcbiAgY29uc3Qgb2JqZWN0VXJsID0gdHlwZW9mIGJsb2JPckRhdGFVcmwgIT09ICdzdHJpbmcnICYmIFVSTC5jcmVhdGVPYmplY3RVUkwoYmxvYk9yRGF0YVVybCk7XG4gIHRyeSB7XG4gICAgcmV0dXJuIGF3YWl0IGxvYWRUb0ltYWdlKG9iamVjdFVybCB8fCBibG9iT3JEYXRhVXJsLCBvcHRpb25zKTtcbiAgfSBmaW5hbGx5IHtcbiAgICBpZiAob2JqZWN0VXJsKSB7XG4gICAgICBVUkwucmV2b2tlT2JqZWN0VVJMKG9iamVjdFVybCk7XG4gICAgfVxuICB9XG59XG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gbG9hZFRvSW1hZ2UodXJsLCBvcHRpb25zKSB7XG4gIGNvbnN0IGltYWdlID0gbmV3IEltYWdlKCk7XG4gIGltYWdlLnNyYyA9IHVybDtcblxuICBpZiAob3B0aW9ucy5pbWFnZSAmJiBvcHRpb25zLmltYWdlLmRlY29kZSAmJiBpbWFnZS5kZWNvZGUpIHtcbiAgICBhd2FpdCBpbWFnZS5kZWNvZGUoKTtcbiAgICByZXR1cm4gaW1hZ2U7XG4gIH1cblxuICByZXR1cm4gYXdhaXQgbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgIHRyeSB7XG4gICAgICBpbWFnZS5vbmxvYWQgPSAoKSA9PiByZXNvbHZlKGltYWdlKTtcbiAgICAgIGltYWdlLm9uZXJyb3IgPSBlcnIgPT4gcmVqZWN0KG5ldyBFcnJvcihcIkNvdWxkIG5vdCBsb2FkIGltYWdlIFwiLmNvbmNhdCh1cmwsIFwiOiBcIikuY29uY2F0KGVycikpKTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgcmVqZWN0KGVycm9yKTtcbiAgICB9XG4gIH0pO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cGFyc2UtdG8taW1hZ2UuanMubWFwIiwiaW1wb3J0IHsgaXNTVkcsIGdldEJsb2IgfSBmcm9tICcuL3N2Zy11dGlscyc7XG5pbXBvcnQgcGFyc2VUb0ltYWdlIGZyb20gJy4vcGFyc2UtdG8taW1hZ2UnO1xuY29uc3QgRU1QVFlfT0JKRUNUID0ge307XG5sZXQgaW1hZ2ViaXRtYXBPcHRpb25zU3VwcG9ydGVkID0gdHJ1ZTtcblxuZXhwb3J0IGRlZmF1bHQgYXN5bmMgZnVuY3Rpb24gcGFyc2VUb0ltYWdlQml0bWFwKGFycmF5QnVmZmVyLCBvcHRpb25zLCB1cmwpIHtcbiAgbGV0IGJsb2I7XG5cbiAgaWYgKGlzU1ZHKHVybCkpIHtcbiAgICBjb25zdCBpbWFnZSA9IGF3YWl0IHBhcnNlVG9JbWFnZShhcnJheUJ1ZmZlciwgb3B0aW9ucywgdXJsKTtcbiAgICBibG9iID0gaW1hZ2U7XG4gIH0gZWxzZSB7XG4gICAgYmxvYiA9IGdldEJsb2IoYXJyYXlCdWZmZXIsIHVybCk7XG4gIH1cbiAgY29uc3QgaW1hZ2ViaXRtYXBPcHRpb25zID0gb3B0aW9ucyAmJiBvcHRpb25zLmltYWdlYml0bWFwO1xuICByZXR1cm4gYXdhaXQgc2FmZUNyZWF0ZUltYWdlQml0bWFwKGJsb2IsIGltYWdlYml0bWFwT3B0aW9ucyk7XG59XG5cbmFzeW5jIGZ1bmN0aW9uIHNhZmVDcmVhdGVJbWFnZUJpdG1hcChibG9iKSB7XG4gIGxldCBpbWFnZWJpdG1hcE9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IG51bGw7XG4gIGlmIChpc0VtcHR5T2JqZWN0KGltYWdlYml0bWFwT3B0aW9ucykgfHwgIWltYWdlYml0bWFwT3B0aW9uc1N1cHBvcnRlZCkge1xuICAgIGltYWdlYml0bWFwT3B0aW9ucyA9IG51bGw7XG4gIH1cbiAgaWYgKGltYWdlYml0bWFwT3B0aW9ucykge1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gYXdhaXQgY3JlYXRlSW1hZ2VCaXRtYXAoYmxvYiwgaW1hZ2ViaXRtYXBPcHRpb25zKTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS53YXJuKGVycm9yKTtcbiAgICAgIGltYWdlYml0bWFwT3B0aW9uc1N1cHBvcnRlZCA9IGZhbHNlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gYXdhaXQgY3JlYXRlSW1hZ2VCaXRtYXAoYmxvYik7XG59XG5mdW5jdGlvbiBpc0VtcHR5T2JqZWN0KG9iamVjdCkge1xuICBmb3IgKGNvbnN0IGtleSBpbiBvYmplY3QgfHwgRU1QVFlfT0JKRUNUKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHJldHVybiB0cnVlO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cGFyc2UtdG8taW1hZ2UtYml0bWFwLmpzLm1hcCIsImltcG9ydCB7IGFzc2VydCB9IGZyb20gJ0Bsb2FkZXJzLmdsL2xvYWRlci11dGlscyc7XG5pbXBvcnQgeyBnZXRCaW5hcnlJbWFnZU1ldGFkYXRhIH0gZnJvbSAnLi4vY2F0ZWdvcnktYXBpL2JpbmFyeS1pbWFnZS1hcGknO1xuXG5leHBvcnQgZGVmYXVsdCBhc3luYyBmdW5jdGlvbiBwYXJzZVRvTm9kZUltYWdlKGFycmF5QnVmZmVyLCBvcHRpb25zKSB7XG4gIGNvbnN0IHtcbiAgICBtaW1lVHlwZVxuICB9ID0gZ2V0QmluYXJ5SW1hZ2VNZXRhZGF0YShhcnJheUJ1ZmZlcikgfHwge307XG5cbiAgY29uc3QgX3BhcnNlSW1hZ2VOb2RlID0gZ2xvYmFsVGhpcy5fcGFyc2VJbWFnZU5vZGU7XG4gIGFzc2VydChfcGFyc2VJbWFnZU5vZGUpO1xuXG4gIHJldHVybiBhd2FpdCBfcGFyc2VJbWFnZU5vZGUoYXJyYXlCdWZmZXIsIG1pbWVUeXBlKTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXBhcnNlLXRvLW5vZGUtaW1hZ2UuanMubWFwIiwiaW1wb3J0IHsgYXNzZXJ0IH0gZnJvbSAnQGxvYWRlcnMuZ2wvbG9hZGVyLXV0aWxzJztcbmltcG9ydCB7IGlzSW1hZ2VUeXBlU3VwcG9ydGVkLCBnZXREZWZhdWx0SW1hZ2VUeXBlIH0gZnJvbSAnLi4vY2F0ZWdvcnktYXBpL2ltYWdlLXR5cGUnO1xuaW1wb3J0IHsgZ2V0SW1hZ2VEYXRhIH0gZnJvbSAnLi4vY2F0ZWdvcnktYXBpL3BhcnNlZC1pbWFnZS1hcGknO1xuaW1wb3J0IHBhcnNlVG9JbWFnZSBmcm9tICcuL3BhcnNlLXRvLWltYWdlJztcbmltcG9ydCBwYXJzZVRvSW1hZ2VCaXRtYXAgZnJvbSAnLi9wYXJzZS10by1pbWFnZS1iaXRtYXAnO1xuaW1wb3J0IHBhcnNlVG9Ob2RlSW1hZ2UgZnJvbSAnLi9wYXJzZS10by1ub2RlLWltYWdlJztcblxuZXhwb3J0IGRlZmF1bHQgYXN5bmMgZnVuY3Rpb24gcGFyc2VJbWFnZShhcnJheUJ1ZmZlciwgb3B0aW9ucywgY29udGV4dCkge1xuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgY29uc3QgaW1hZ2VPcHRpb25zID0gb3B0aW9ucy5pbWFnZSB8fCB7fTtcblxuICBjb25zdCBpbWFnZVR5cGUgPSBpbWFnZU9wdGlvbnMudHlwZSB8fCAnYXV0byc7XG4gIGNvbnN0IHtcbiAgICB1cmxcbiAgfSA9IGNvbnRleHQgfHwge307XG5cbiAgY29uc3QgbG9hZFR5cGUgPSBnZXRMb2FkYWJsZUltYWdlVHlwZShpbWFnZVR5cGUpO1xuICBsZXQgaW1hZ2U7XG4gIHN3aXRjaCAobG9hZFR5cGUpIHtcbiAgICBjYXNlICdpbWFnZWJpdG1hcCc6XG4gICAgICBpbWFnZSA9IGF3YWl0IHBhcnNlVG9JbWFnZUJpdG1hcChhcnJheUJ1ZmZlciwgb3B0aW9ucywgdXJsKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ2ltYWdlJzpcbiAgICAgIGltYWdlID0gYXdhaXQgcGFyc2VUb0ltYWdlKGFycmF5QnVmZmVyLCBvcHRpb25zLCB1cmwpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnZGF0YSc6XG4gICAgICBpbWFnZSA9IGF3YWl0IHBhcnNlVG9Ob2RlSW1hZ2UoYXJyYXlCdWZmZXIsIG9wdGlvbnMpO1xuICAgICAgYnJlYWs7XG4gICAgZGVmYXVsdDpcbiAgICAgIGFzc2VydChmYWxzZSk7XG4gIH1cblxuICBpZiAoaW1hZ2VUeXBlID09PSAnZGF0YScpIHtcbiAgICBpbWFnZSA9IGdldEltYWdlRGF0YShpbWFnZSk7XG4gIH1cbiAgcmV0dXJuIGltYWdlO1xufVxuXG5mdW5jdGlvbiBnZXRMb2FkYWJsZUltYWdlVHlwZSh0eXBlKSB7XG4gIHN3aXRjaCAodHlwZSkge1xuICAgIGNhc2UgJ2F1dG8nOlxuICAgIGNhc2UgJ2RhdGEnOlxuICAgICAgcmV0dXJuIGdldERlZmF1bHRJbWFnZVR5cGUoKTtcbiAgICBkZWZhdWx0OlxuICAgICAgaXNJbWFnZVR5cGVTdXBwb3J0ZWQodHlwZSk7XG4gICAgICByZXR1cm4gdHlwZTtcbiAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cGFyc2UtaW1hZ2UuanMubWFwIiwiaW1wb3J0IHsgVkVSU0lPTiB9IGZyb20gJy4vbGliL3V0aWxzL3ZlcnNpb24nO1xuaW1wb3J0IHBhcnNlSW1hZ2UgZnJvbSAnLi9saWIvcGFyc2Vycy9wYXJzZS1pbWFnZSc7XG5pbXBvcnQgeyBnZXRCaW5hcnlJbWFnZU1ldGFkYXRhIH0gZnJvbSAnLi9saWIvY2F0ZWdvcnktYXBpL2JpbmFyeS1pbWFnZS1hcGknO1xuY29uc3QgRVhURU5TSU9OUyA9IFsncG5nJywgJ2pwZycsICdqcGVnJywgJ2dpZicsICd3ZWJwJywgJ2JtcCcsICdpY28nLCAnc3ZnJ107XG5jb25zdCBNSU1FX1RZUEVTID0gWydpbWFnZS9wbmcnLCAnaW1hZ2UvanBlZycsICdpbWFnZS9naWYnLCAnaW1hZ2Uvd2VicCcsICdpbWFnZS9ibXAnLCAnaW1hZ2Uvdm5kLm1pY3Jvc29mdC5pY29uJywgJ2ltYWdlL3N2Zyt4bWwnXTtcbmNvbnN0IERFRkFVTFRfSU1BR0VfTE9BREVSX09QVElPTlMgPSB7XG4gIGltYWdlOiB7XG4gICAgdHlwZTogJ2F1dG8nLFxuICAgIGRlY29kZTogdHJ1ZVxuICB9XG59O1xuXG5leHBvcnQgY29uc3QgSW1hZ2VMb2FkZXIgPSB7XG4gIGlkOiAnaW1hZ2UnLFxuICBtb2R1bGU6ICdpbWFnZXMnLFxuICBuYW1lOiAnSW1hZ2VzJyxcbiAgdmVyc2lvbjogVkVSU0lPTixcbiAgbWltZVR5cGVzOiBNSU1FX1RZUEVTLFxuICBleHRlbnNpb25zOiBFWFRFTlNJT05TLFxuICBwYXJzZTogcGFyc2VJbWFnZSxcbiAgdGVzdHM6IFthcnJheUJ1ZmZlciA9PiBCb29sZWFuKGdldEJpbmFyeUltYWdlTWV0YWRhdGEobmV3IERhdGFWaWV3KGFycmF5QnVmZmVyKSkpXSxcbiAgb3B0aW9uczogREVGQVVMVF9JTUFHRV9MT0FERVJfT1BUSU9OU1xufTtcbmV4cG9ydCBjb25zdCBfdHlwZWNoZWNrSW1hZ2VMb2FkZXIgPSBJbWFnZUxvYWRlcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWltYWdlLWxvYWRlci5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///54022\n")},39105:function(__unused_webpack_module,__webpack_exports__,__webpack_require__){eval("/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"I\": function() { return /* binding */ getBinaryImageMetadata; }\n/* harmony export */ });\n/* unused harmony export getBmpMetadata */\n\n\nconst BIG_ENDIAN = false;\nconst LITTLE_ENDIAN = true;\n\nfunction getBinaryImageMetadata(binaryData) {\n  const dataView = toDataView(binaryData);\n  return getPngMetadata(dataView) || getJpegMetadata(dataView) || getGifMetadata(dataView) || getBmpMetadata(dataView);\n}\n\nfunction getPngMetadata(binaryData) {\n  const dataView = toDataView(binaryData);\n  const isPng = dataView.byteLength >= 24 && dataView.getUint32(0, BIG_ENDIAN) === 0x89504e47;\n  if (!isPng) {\n    return null;\n  }\n\n  return {\n    mimeType: 'image/png',\n    width: dataView.getUint32(16, BIG_ENDIAN),\n    height: dataView.getUint32(20, BIG_ENDIAN)\n  };\n}\n\nfunction getGifMetadata(binaryData) {\n  const dataView = toDataView(binaryData);\n  const isGif = dataView.byteLength >= 10 && dataView.getUint32(0, BIG_ENDIAN) === 0x47494638;\n  if (!isGif) {\n    return null;\n  }\n\n  return {\n    mimeType: 'image/gif',\n    width: dataView.getUint16(6, LITTLE_ENDIAN),\n    height: dataView.getUint16(8, LITTLE_ENDIAN)\n  };\n}\n\nfunction getBmpMetadata(binaryData) {\n  const dataView = toDataView(binaryData);\n  const isBmp = dataView.byteLength >= 14 && dataView.getUint16(0, BIG_ENDIAN) === 0x424d && dataView.getUint32(2, LITTLE_ENDIAN) === dataView.byteLength;\n  if (!isBmp) {\n    return null;\n  }\n\n  return {\n    mimeType: 'image/bmp',\n    width: dataView.getUint32(18, LITTLE_ENDIAN),\n    height: dataView.getUint32(22, LITTLE_ENDIAN)\n  };\n}\n\nfunction getJpegMetadata(binaryData) {\n  const dataView = toDataView(binaryData);\n  const isJpeg = dataView.byteLength >= 3 && dataView.getUint16(0, BIG_ENDIAN) === 0xffd8 && dataView.getUint8(2) === 0xff;\n  if (!isJpeg) {\n    return null;\n  }\n  const {\n    tableMarkers,\n    sofMarkers\n  } = getJpegMarkers();\n\n  let i = 2;\n  while (i + 9 < dataView.byteLength) {\n    const marker = dataView.getUint16(i, BIG_ENDIAN);\n\n    if (sofMarkers.has(marker)) {\n      return {\n        mimeType: 'image/jpeg',\n        height: dataView.getUint16(i + 5, BIG_ENDIAN),\n        width: dataView.getUint16(i + 7, BIG_ENDIAN)\n      };\n    }\n\n    if (!tableMarkers.has(marker)) {\n      return null;\n    }\n\n    i += 2;\n    i += dataView.getUint16(i, BIG_ENDIAN);\n  }\n  return null;\n}\nfunction getJpegMarkers() {\n  const tableMarkers = new Set([0xffdb, 0xffc4, 0xffcc, 0xffdd, 0xfffe]);\n  for (let i = 0xffe0; i < 0xfff0; ++i) {\n    tableMarkers.add(i);\n  }\n\n  const sofMarkers = new Set([0xffc0, 0xffc1, 0xffc2, 0xffc3, 0xffc5, 0xffc6, 0xffc7, 0xffc9, 0xffca, 0xffcb, 0xffcd, 0xffce, 0xffcf, 0xffde]);\n  return {\n    tableMarkers,\n    sofMarkers\n  };\n}\n\nfunction toDataView(data) {\n  if (data instanceof DataView) {\n    return data;\n  }\n  if (ArrayBuffer.isView(data)) {\n    return new DataView(data.buffer);\n  }\n\n  if (data instanceof ArrayBuffer) {\n    return new DataView(data);\n  }\n  throw new Error('toDataView');\n}\n//# sourceMappingURL=binary-image-api.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMzkxMDUuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBRUE7QUFDQTs7QUFFTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsWUFBWTtBQUNuQztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly92dWUzLXdlYnBhY2s1Ly4vbm9kZV9tb2R1bGVzL0Bsb2FkZXJzLmdsL2ltYWdlcy9kaXN0L2VzbS9saWIvY2F0ZWdvcnktYXBpL2JpbmFyeS1pbWFnZS1hcGkuanM/MzBhZCJdLCJzb3VyY2VzQ29udGVudCI6WyJcblxuY29uc3QgQklHX0VORElBTiA9IGZhbHNlO1xuY29uc3QgTElUVExFX0VORElBTiA9IHRydWU7XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRCaW5hcnlJbWFnZU1ldGFkYXRhKGJpbmFyeURhdGEpIHtcbiAgY29uc3QgZGF0YVZpZXcgPSB0b0RhdGFWaWV3KGJpbmFyeURhdGEpO1xuICByZXR1cm4gZ2V0UG5nTWV0YWRhdGEoZGF0YVZpZXcpIHx8IGdldEpwZWdNZXRhZGF0YShkYXRhVmlldykgfHwgZ2V0R2lmTWV0YWRhdGEoZGF0YVZpZXcpIHx8IGdldEJtcE1ldGFkYXRhKGRhdGFWaWV3KTtcbn1cblxuZnVuY3Rpb24gZ2V0UG5nTWV0YWRhdGEoYmluYXJ5RGF0YSkge1xuICBjb25zdCBkYXRhVmlldyA9IHRvRGF0YVZpZXcoYmluYXJ5RGF0YSk7XG4gIGNvbnN0IGlzUG5nID0gZGF0YVZpZXcuYnl0ZUxlbmd0aCA+PSAyNCAmJiBkYXRhVmlldy5nZXRVaW50MzIoMCwgQklHX0VORElBTikgPT09IDB4ODk1MDRlNDc7XG4gIGlmICghaXNQbmcpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgbWltZVR5cGU6ICdpbWFnZS9wbmcnLFxuICAgIHdpZHRoOiBkYXRhVmlldy5nZXRVaW50MzIoMTYsIEJJR19FTkRJQU4pLFxuICAgIGhlaWdodDogZGF0YVZpZXcuZ2V0VWludDMyKDIwLCBCSUdfRU5ESUFOKVxuICB9O1xufVxuXG5mdW5jdGlvbiBnZXRHaWZNZXRhZGF0YShiaW5hcnlEYXRhKSB7XG4gIGNvbnN0IGRhdGFWaWV3ID0gdG9EYXRhVmlldyhiaW5hcnlEYXRhKTtcbiAgY29uc3QgaXNHaWYgPSBkYXRhVmlldy5ieXRlTGVuZ3RoID49IDEwICYmIGRhdGFWaWV3LmdldFVpbnQzMigwLCBCSUdfRU5ESUFOKSA9PT0gMHg0NzQ5NDYzODtcbiAgaWYgKCFpc0dpZikge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBtaW1lVHlwZTogJ2ltYWdlL2dpZicsXG4gICAgd2lkdGg6IGRhdGFWaWV3LmdldFVpbnQxNig2LCBMSVRUTEVfRU5ESUFOKSxcbiAgICBoZWlnaHQ6IGRhdGFWaWV3LmdldFVpbnQxNig4LCBMSVRUTEVfRU5ESUFOKVxuICB9O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0Qm1wTWV0YWRhdGEoYmluYXJ5RGF0YSkge1xuICBjb25zdCBkYXRhVmlldyA9IHRvRGF0YVZpZXcoYmluYXJ5RGF0YSk7XG4gIGNvbnN0IGlzQm1wID0gZGF0YVZpZXcuYnl0ZUxlbmd0aCA+PSAxNCAmJiBkYXRhVmlldy5nZXRVaW50MTYoMCwgQklHX0VORElBTikgPT09IDB4NDI0ZCAmJiBkYXRhVmlldy5nZXRVaW50MzIoMiwgTElUVExFX0VORElBTikgPT09IGRhdGFWaWV3LmJ5dGVMZW5ndGg7XG4gIGlmICghaXNCbXApIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgbWltZVR5cGU6ICdpbWFnZS9ibXAnLFxuICAgIHdpZHRoOiBkYXRhVmlldy5nZXRVaW50MzIoMTgsIExJVFRMRV9FTkRJQU4pLFxuICAgIGhlaWdodDogZGF0YVZpZXcuZ2V0VWludDMyKDIyLCBMSVRUTEVfRU5ESUFOKVxuICB9O1xufVxuXG5mdW5jdGlvbiBnZXRKcGVnTWV0YWRhdGEoYmluYXJ5RGF0YSkge1xuICBjb25zdCBkYXRhVmlldyA9IHRvRGF0YVZpZXcoYmluYXJ5RGF0YSk7XG4gIGNvbnN0IGlzSnBlZyA9IGRhdGFWaWV3LmJ5dGVMZW5ndGggPj0gMyAmJiBkYXRhVmlldy5nZXRVaW50MTYoMCwgQklHX0VORElBTikgPT09IDB4ZmZkOCAmJiBkYXRhVmlldy5nZXRVaW50OCgyKSA9PT0gMHhmZjtcbiAgaWYgKCFpc0pwZWcpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBjb25zdCB7XG4gICAgdGFibGVNYXJrZXJzLFxuICAgIHNvZk1hcmtlcnNcbiAgfSA9IGdldEpwZWdNYXJrZXJzKCk7XG5cbiAgbGV0IGkgPSAyO1xuICB3aGlsZSAoaSArIDkgPCBkYXRhVmlldy5ieXRlTGVuZ3RoKSB7XG4gICAgY29uc3QgbWFya2VyID0gZGF0YVZpZXcuZ2V0VWludDE2KGksIEJJR19FTkRJQU4pO1xuXG4gICAgaWYgKHNvZk1hcmtlcnMuaGFzKG1hcmtlcikpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIG1pbWVUeXBlOiAnaW1hZ2UvanBlZycsXG4gICAgICAgIGhlaWdodDogZGF0YVZpZXcuZ2V0VWludDE2KGkgKyA1LCBCSUdfRU5ESUFOKSxcbiAgICAgICAgd2lkdGg6IGRhdGFWaWV3LmdldFVpbnQxNihpICsgNywgQklHX0VORElBTilcbiAgICAgIH07XG4gICAgfVxuXG4gICAgaWYgKCF0YWJsZU1hcmtlcnMuaGFzKG1hcmtlcikpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIGkgKz0gMjtcbiAgICBpICs9IGRhdGFWaWV3LmdldFVpbnQxNihpLCBCSUdfRU5ESUFOKTtcbiAgfVxuICByZXR1cm4gbnVsbDtcbn1cbmZ1bmN0aW9uIGdldEpwZWdNYXJrZXJzKCkge1xuICBjb25zdCB0YWJsZU1hcmtlcnMgPSBuZXcgU2V0KFsweGZmZGIsIDB4ZmZjNCwgMHhmZmNjLCAweGZmZGQsIDB4ZmZmZV0pO1xuICBmb3IgKGxldCBpID0gMHhmZmUwOyBpIDwgMHhmZmYwOyArK2kpIHtcbiAgICB0YWJsZU1hcmtlcnMuYWRkKGkpO1xuICB9XG5cbiAgY29uc3Qgc29mTWFya2VycyA9IG5ldyBTZXQoWzB4ZmZjMCwgMHhmZmMxLCAweGZmYzIsIDB4ZmZjMywgMHhmZmM1LCAweGZmYzYsIDB4ZmZjNywgMHhmZmM5LCAweGZmY2EsIDB4ZmZjYiwgMHhmZmNkLCAweGZmY2UsIDB4ZmZjZiwgMHhmZmRlXSk7XG4gIHJldHVybiB7XG4gICAgdGFibGVNYXJrZXJzLFxuICAgIHNvZk1hcmtlcnNcbiAgfTtcbn1cblxuZnVuY3Rpb24gdG9EYXRhVmlldyhkYXRhKSB7XG4gIGlmIChkYXRhIGluc3RhbmNlb2YgRGF0YVZpZXcpIHtcbiAgICByZXR1cm4gZGF0YTtcbiAgfVxuICBpZiAoQXJyYXlCdWZmZXIuaXNWaWV3KGRhdGEpKSB7XG4gICAgcmV0dXJuIG5ldyBEYXRhVmlldyhkYXRhLmJ1ZmZlcik7XG4gIH1cblxuICBpZiAoZGF0YSBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSB7XG4gICAgcmV0dXJuIG5ldyBEYXRhVmlldyhkYXRhKTtcbiAgfVxuICB0aHJvdyBuZXcgRXJyb3IoJ3RvRGF0YVZpZXcnKTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWJpbmFyeS1pbWFnZS1hcGkuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///39105\n")},74609:function(__unused_webpack_module,__webpack_exports__,__webpack_require__){eval('/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "JY": function() { return /* binding */ concatenateArrayBuffers; },\n/* harmony export */   "Xq": function() { return /* binding */ compareArrayBuffers; },\n/* harmony export */   "qv": function() { return /* binding */ sliceArrayBuffer; }\n/* harmony export */ });\n/* unused harmony export concatenateTypedArrays */\n\nfunction compareArrayBuffers(arrayBuffer1, arrayBuffer2, byteLength) {\n  byteLength = byteLength || arrayBuffer1.byteLength;\n  if (arrayBuffer1.byteLength < byteLength || arrayBuffer2.byteLength < byteLength) {\n    return false;\n  }\n  const array1 = new Uint8Array(arrayBuffer1);\n  const array2 = new Uint8Array(arrayBuffer2);\n  for (let i = 0; i < array1.length; ++i) {\n    if (array1[i] !== array2[i]) {\n      return false;\n    }\n  }\n  return true;\n}\n\nfunction concatenateArrayBuffers() {\n  for (var _len = arguments.length, sources = new Array(_len), _key = 0; _key < _len; _key++) {\n    sources[_key] = arguments[_key];\n  }\n  const sourceArrays = sources.map(source2 => source2 instanceof ArrayBuffer ? new Uint8Array(source2) : source2);\n\n  const byteLength = sourceArrays.reduce((length, typedArray) => length + typedArray.byteLength, 0);\n\n  const result = new Uint8Array(byteLength);\n\n  let offset = 0;\n  for (const sourceArray of sourceArrays) {\n    result.set(sourceArray, offset);\n    offset += sourceArray.byteLength;\n  }\n\n  return result.buffer;\n}\n\nfunction concatenateTypedArrays() {\n  for (var _len2 = arguments.length, typedArrays = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n    typedArrays[_key2] = arguments[_key2];\n  }\n  const arrays = typedArrays;\n  const TypedArrayConstructor = arrays && arrays.length > 1 && arrays[0].constructor || null;\n  if (!TypedArrayConstructor) {\n    throw new Error(\'"concatenateTypedArrays" - incorrect quantity of arguments or arguments have incompatible data types\');\n  }\n  const sumLength = arrays.reduce((acc, value) => acc + value.length, 0);\n  const result = new TypedArrayConstructor(sumLength);\n  let offset = 0;\n  for (const array of arrays) {\n    result.set(array, offset);\n    offset += array.length;\n  }\n  return result;\n}\n\nfunction sliceArrayBuffer(arrayBuffer, byteOffset, byteLength) {\n  const subArray = byteLength !== undefined ? new Uint8Array(arrayBuffer).subarray(byteOffset, byteOffset + byteLength) : new Uint8Array(arrayBuffer).subarray(byteOffset);\n  const arrayCopy = new Uint8Array(subArray);\n  return arrayCopy.buffer;\n}\n//# sourceMappingURL=array-buffer-utils.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNzQ2MDkuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLG1CQUFtQjtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRU87QUFDUCx5RUFBeUUsYUFBYTtBQUN0RjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVPO0FBQ1AsZ0ZBQWdGLGVBQWU7QUFDL0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdnVlMy13ZWJwYWNrNS8uL25vZGVfbW9kdWxlcy9AbG9hZGVycy5nbC9sb2FkZXItdXRpbHMvZGlzdC9lc20vbGliL2JpbmFyeS11dGlscy9hcnJheS1idWZmZXItdXRpbHMuanM/MTNkNiJdLCJzb3VyY2VzQ29udGVudCI6WyJcbmV4cG9ydCBmdW5jdGlvbiBjb21wYXJlQXJyYXlCdWZmZXJzKGFycmF5QnVmZmVyMSwgYXJyYXlCdWZmZXIyLCBieXRlTGVuZ3RoKSB7XG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoIHx8IGFycmF5QnVmZmVyMS5ieXRlTGVuZ3RoO1xuICBpZiAoYXJyYXlCdWZmZXIxLmJ5dGVMZW5ndGggPCBieXRlTGVuZ3RoIHx8IGFycmF5QnVmZmVyMi5ieXRlTGVuZ3RoIDwgYnl0ZUxlbmd0aCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBjb25zdCBhcnJheTEgPSBuZXcgVWludDhBcnJheShhcnJheUJ1ZmZlcjEpO1xuICBjb25zdCBhcnJheTIgPSBuZXcgVWludDhBcnJheShhcnJheUJ1ZmZlcjIpO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGFycmF5MS5sZW5ndGg7ICsraSkge1xuICAgIGlmIChhcnJheTFbaV0gIT09IGFycmF5MltpXSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGNvbmNhdGVuYXRlQXJyYXlCdWZmZXJzKCkge1xuICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgc291cmNlcyA9IG5ldyBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICBzb3VyY2VzW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICB9XG4gIGNvbnN0IHNvdXJjZUFycmF5cyA9IHNvdXJjZXMubWFwKHNvdXJjZTIgPT4gc291cmNlMiBpbnN0YW5jZW9mIEFycmF5QnVmZmVyID8gbmV3IFVpbnQ4QXJyYXkoc291cmNlMikgOiBzb3VyY2UyKTtcblxuICBjb25zdCBieXRlTGVuZ3RoID0gc291cmNlQXJyYXlzLnJlZHVjZSgobGVuZ3RoLCB0eXBlZEFycmF5KSA9PiBsZW5ndGggKyB0eXBlZEFycmF5LmJ5dGVMZW5ndGgsIDApO1xuXG4gIGNvbnN0IHJlc3VsdCA9IG5ldyBVaW50OEFycmF5KGJ5dGVMZW5ndGgpO1xuXG4gIGxldCBvZmZzZXQgPSAwO1xuICBmb3IgKGNvbnN0IHNvdXJjZUFycmF5IG9mIHNvdXJjZUFycmF5cykge1xuICAgIHJlc3VsdC5zZXQoc291cmNlQXJyYXksIG9mZnNldCk7XG4gICAgb2Zmc2V0ICs9IHNvdXJjZUFycmF5LmJ5dGVMZW5ndGg7XG4gIH1cblxuICByZXR1cm4gcmVzdWx0LmJ1ZmZlcjtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGNvbmNhdGVuYXRlVHlwZWRBcnJheXMoKSB7XG4gIGZvciAodmFyIF9sZW4yID0gYXJndW1lbnRzLmxlbmd0aCwgdHlwZWRBcnJheXMgPSBuZXcgQXJyYXkoX2xlbjIpLCBfa2V5MiA9IDA7IF9rZXkyIDwgX2xlbjI7IF9rZXkyKyspIHtcbiAgICB0eXBlZEFycmF5c1tfa2V5Ml0gPSBhcmd1bWVudHNbX2tleTJdO1xuICB9XG4gIGNvbnN0IGFycmF5cyA9IHR5cGVkQXJyYXlzO1xuICBjb25zdCBUeXBlZEFycmF5Q29uc3RydWN0b3IgPSBhcnJheXMgJiYgYXJyYXlzLmxlbmd0aCA+IDEgJiYgYXJyYXlzWzBdLmNvbnN0cnVjdG9yIHx8IG51bGw7XG4gIGlmICghVHlwZWRBcnJheUNvbnN0cnVjdG9yKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdcImNvbmNhdGVuYXRlVHlwZWRBcnJheXNcIiAtIGluY29ycmVjdCBxdWFudGl0eSBvZiBhcmd1bWVudHMgb3IgYXJndW1lbnRzIGhhdmUgaW5jb21wYXRpYmxlIGRhdGEgdHlwZXMnKTtcbiAgfVxuICBjb25zdCBzdW1MZW5ndGggPSBhcnJheXMucmVkdWNlKChhY2MsIHZhbHVlKSA9PiBhY2MgKyB2YWx1ZS5sZW5ndGgsIDApO1xuICBjb25zdCByZXN1bHQgPSBuZXcgVHlwZWRBcnJheUNvbnN0cnVjdG9yKHN1bUxlbmd0aCk7XG4gIGxldCBvZmZzZXQgPSAwO1xuICBmb3IgKGNvbnN0IGFycmF5IG9mIGFycmF5cykge1xuICAgIHJlc3VsdC5zZXQoYXJyYXksIG9mZnNldCk7XG4gICAgb2Zmc2V0ICs9IGFycmF5Lmxlbmd0aDtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gc2xpY2VBcnJheUJ1ZmZlcihhcnJheUJ1ZmZlciwgYnl0ZU9mZnNldCwgYnl0ZUxlbmd0aCkge1xuICBjb25zdCBzdWJBcnJheSA9IGJ5dGVMZW5ndGggIT09IHVuZGVmaW5lZCA/IG5ldyBVaW50OEFycmF5KGFycmF5QnVmZmVyKS5zdWJhcnJheShieXRlT2Zmc2V0LCBieXRlT2Zmc2V0ICsgYnl0ZUxlbmd0aCkgOiBuZXcgVWludDhBcnJheShhcnJheUJ1ZmZlcikuc3ViYXJyYXkoYnl0ZU9mZnNldCk7XG4gIGNvbnN0IGFycmF5Q29weSA9IG5ldyBVaW50OEFycmF5KHN1YkFycmF5KTtcbiAgcmV0dXJuIGFycmF5Q29weS5idWZmZXI7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1hcnJheS1idWZmZXItdXRpbHMuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///74609\n')},16269:function(__unused_webpack_module,__webpack_exports__,__webpack_require__){eval("/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"h\": function() { return /* binding */ assert; }\n/* harmony export */ });\n\nfunction assert(condition, message) {\n  if (!condition) {\n    throw new Error(message || 'loader assertion failed.');\n  }\n}\n//# sourceMappingURL=assert.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTYyNjkuanMiLCJtYXBwaW5ncyI6Ijs7OztBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3Z1ZTMtd2VicGFjazUvLi9ub2RlX21vZHVsZXMvQGxvYWRlcnMuZ2wvbG9hZGVyLXV0aWxzL2Rpc3QvZXNtL2xpYi9lbnYtdXRpbHMvYXNzZXJ0LmpzPzFhMmQiXSwic291cmNlc0NvbnRlbnQiOlsiXG5leHBvcnQgZnVuY3Rpb24gYXNzZXJ0KGNvbmRpdGlvbiwgbWVzc2FnZSkge1xuICBpZiAoIWNvbmRpdGlvbikge1xuICAgIHRocm93IG5ldyBFcnJvcihtZXNzYWdlIHx8ICdsb2FkZXIgYXNzZXJ0aW9uIGZhaWxlZC4nKTtcbiAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YXNzZXJ0LmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///16269\n")},84959:function(__unused_webpack_module,__webpack_exports__,__webpack_require__){eval("/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"jU\": function() { return /* binding */ isBrowser; }\n/* harmony export */ });\n/* unused harmony exports self, window, global, document, isWorker, nodeVersion */\n\n\nconst globals = {\n  self: typeof self !== 'undefined' && self,\n  window: typeof window !== 'undefined' && window,\n  global: typeof __webpack_require__.g !== 'undefined' && __webpack_require__.g,\n  document: typeof document !== 'undefined' && document\n};\nconst self_ = globals.self || globals.window || globals.global || {};\nconst window_ = globals.window || globals.self || globals.global || {};\nconst global_ = globals.global || globals.self || globals.window || {};\nconst document_ = globals.document || {};\n\n\nconst isBrowser =\nBoolean(typeof process !== 'object' || String(process) !== '[object process]' || process.browser);\n\nconst isWorker = typeof importScripts === 'function';\n\nconst matches = typeof process !== 'undefined' && process.version && /v([0-9]*)/.exec(process.version);\nconst nodeVersion = matches && parseFloat(matches[1]) || 0;\n//# sourceMappingURL=globals.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiODQ5NTkuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLHFCQUFNLG9CQUFvQixxQkFBTTtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDc0Y7O0FBRS9FO0FBQ1A7O0FBRU87O0FBRVA7QUFDTztBQUNQIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdnVlMy13ZWJwYWNrNS8uL25vZGVfbW9kdWxlcy9AbG9hZGVycy5nbC9sb2FkZXItdXRpbHMvZGlzdC9lc20vbGliL2Vudi11dGlscy9nbG9iYWxzLmpzPzliNDEiXSwic291cmNlc0NvbnRlbnQiOlsiXG5cbmNvbnN0IGdsb2JhbHMgPSB7XG4gIHNlbGY6IHR5cGVvZiBzZWxmICE9PSAndW5kZWZpbmVkJyAmJiBzZWxmLFxuICB3aW5kb3c6IHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHdpbmRvdyxcbiAgZ2xvYmFsOiB0eXBlb2YgZ2xvYmFsICE9PSAndW5kZWZpbmVkJyAmJiBnbG9iYWwsXG4gIGRvY3VtZW50OiB0eXBlb2YgZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnICYmIGRvY3VtZW50XG59O1xuY29uc3Qgc2VsZl8gPSBnbG9iYWxzLnNlbGYgfHwgZ2xvYmFscy53aW5kb3cgfHwgZ2xvYmFscy5nbG9iYWwgfHwge307XG5jb25zdCB3aW5kb3dfID0gZ2xvYmFscy53aW5kb3cgfHwgZ2xvYmFscy5zZWxmIHx8IGdsb2JhbHMuZ2xvYmFsIHx8IHt9O1xuY29uc3QgZ2xvYmFsXyA9IGdsb2JhbHMuZ2xvYmFsIHx8IGdsb2JhbHMuc2VsZiB8fCBnbG9iYWxzLndpbmRvdyB8fCB7fTtcbmNvbnN0IGRvY3VtZW50XyA9IGdsb2JhbHMuZG9jdW1lbnQgfHwge307XG5leHBvcnQgeyBzZWxmXyBhcyBzZWxmLCB3aW5kb3dfIGFzIHdpbmRvdywgZ2xvYmFsXyBhcyBnbG9iYWwsIGRvY3VtZW50XyBhcyBkb2N1bWVudCB9O1xuXG5leHBvcnQgY29uc3QgaXNCcm93c2VyID1cbkJvb2xlYW4odHlwZW9mIHByb2Nlc3MgIT09ICdvYmplY3QnIHx8IFN0cmluZyhwcm9jZXNzKSAhPT0gJ1tvYmplY3QgcHJvY2Vzc10nIHx8IHByb2Nlc3MuYnJvd3Nlcik7XG5cbmV4cG9ydCBjb25zdCBpc1dvcmtlciA9IHR5cGVvZiBpbXBvcnRTY3JpcHRzID09PSAnZnVuY3Rpb24nO1xuXG5jb25zdCBtYXRjaGVzID0gdHlwZW9mIHByb2Nlc3MgIT09ICd1bmRlZmluZWQnICYmIHByb2Nlc3MudmVyc2lvbiAmJiAvdihbMC05XSopLy5leGVjKHByb2Nlc3MudmVyc2lvbik7XG5leHBvcnQgY29uc3Qgbm9kZVZlcnNpb24gPSBtYXRjaGVzICYmIHBhcnNlRmxvYXQobWF0Y2hlc1sxXSkgfHwgMDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWdsb2JhbHMuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///84959\n")},78634:function(__unused_webpack_module,__webpack_exports__,__webpack_require__){eval('/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "Z": function() { return /* binding */ RequestScheduler; }\n/* harmony export */ });\n/* harmony import */ var _babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(82482);\n/* harmony import */ var _probe_gl_stats__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(23881);\n\n\nconst STAT_QUEUED_REQUESTS = \'Queued Requests\';\nconst STAT_ACTIVE_REQUESTS = \'Active Requests\';\nconst STAT_CANCELLED_REQUESTS = \'Cancelled Requests\';\nconst STAT_QUEUED_REQUESTS_EVER = \'Queued Requests Ever\';\nconst STAT_ACTIVE_REQUESTS_EVER = \'Active Requests Ever\';\nconst DEFAULT_PROPS = {\n  id: \'request-scheduler\',\n  throttleRequests: true,\n  maxRequests: 6\n};\n\nclass RequestScheduler {\n\n  constructor() {\n    let props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    (0,_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .Z)(this, "props", void 0);\n    (0,_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .Z)(this, "stats", void 0);\n    (0,_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .Z)(this, "activeRequestCount", 0);\n    (0,_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .Z)(this, "requestQueue", []);\n    (0,_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .Z)(this, "requestMap", new Map());\n    (0,_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .Z)(this, "deferredUpdate", null);\n    this.props = {\n      ...DEFAULT_PROPS,\n      ...props\n    };\n\n    this.stats = new _probe_gl_stats__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .Z({\n      id: this.props.id\n    });\n    this.stats.get(STAT_QUEUED_REQUESTS);\n    this.stats.get(STAT_ACTIVE_REQUESTS);\n    this.stats.get(STAT_CANCELLED_REQUESTS);\n    this.stats.get(STAT_QUEUED_REQUESTS_EVER);\n    this.stats.get(STAT_ACTIVE_REQUESTS_EVER);\n  }\n\n  scheduleRequest(handle) {\n    let getPriority = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : () => 0;\n    if (!this.props.throttleRequests) {\n      return Promise.resolve({\n        done: () => {}\n      });\n    }\n\n    if (this.requestMap.has(handle)) {\n      return this.requestMap.get(handle);\n    }\n    const request = {\n      handle,\n      priority: 0,\n      getPriority\n    };\n    const promise = new Promise(resolve => {\n      request.resolve = resolve;\n      return request;\n    });\n    this.requestQueue.push(request);\n    this.requestMap.set(handle, promise);\n    this._issueNewRequests();\n    return promise;\n  }\n\n  _issueRequest(request) {\n    const {\n      handle,\n      resolve\n    } = request;\n    let isDone = false;\n    const done = () => {\n      if (!isDone) {\n        isDone = true;\n\n        this.requestMap.delete(handle);\n        this.activeRequestCount--;\n        this._issueNewRequests();\n      }\n    };\n\n    this.activeRequestCount++;\n    return resolve ? resolve({\n      done\n    }) : Promise.resolve({\n      done\n    });\n  }\n\n  _issueNewRequests() {\n    if (!this.deferredUpdate) {\n      this.deferredUpdate = setTimeout(() => this._issueNewRequestsAsync(), 0);\n    }\n  }\n\n  _issueNewRequestsAsync() {\n    this.deferredUpdate = null;\n    const freeSlots = Math.max(this.props.maxRequests - this.activeRequestCount, 0);\n    if (freeSlots === 0) {\n      return;\n    }\n    this._updateAllRequests();\n\n    for (let i = 0; i < freeSlots; ++i) {\n      const request = this.requestQueue.shift();\n      if (request) {\n        this._issueRequest(request);\n      }\n    }\n\n  }\n\n  _updateAllRequests() {\n    const requestQueue = this.requestQueue;\n    for (let i = 0; i < requestQueue.length; ++i) {\n      const request = requestQueue[i];\n      if (!this._updateRequest(request)) {\n        requestQueue.splice(i, 1);\n        this.requestMap.delete(request.handle);\n        i--;\n      }\n    }\n\n    requestQueue.sort((a, b) => a.priority - b.priority);\n  }\n\n  _updateRequest(request) {\n    request.priority = request.getPriority(request.handle);\n\n    if (request.priority < 0) {\n      request.resolve(null);\n      return false;\n    }\n    return true;\n  }\n}\n//# sourceMappingURL=request-scheduler.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNzg2MzQuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBd0U7QUFDaEM7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRWU7O0FBRWY7QUFDQTtBQUNBLElBQUksOEZBQWU7QUFDbkIsSUFBSSw4RkFBZTtBQUNuQixJQUFJLDhGQUFlO0FBQ25CLElBQUksOEZBQWU7QUFDbkIsSUFBSSw4RkFBZTtBQUNuQixJQUFJLDhGQUFlO0FBQ25CO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHFCQUFxQixnRUFBSztBQUMxQjtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxvQkFBb0IsZUFBZTtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxvQkFBb0IseUJBQXlCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdnVlMy13ZWJwYWNrNS8uL25vZGVfbW9kdWxlcy9AbG9hZGVycy5nbC9sb2FkZXItdXRpbHMvZGlzdC9lc20vbGliL3JlcXVlc3QtdXRpbHMvcmVxdWVzdC1zY2hlZHVsZXIuanM/MzYyMyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgX2RlZmluZVByb3BlcnR5IGZyb20gXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9kZWZpbmVQcm9wZXJ0eVwiO1xuaW1wb3J0IHsgU3RhdHMgfSBmcm9tICdAcHJvYmUuZ2wvc3RhdHMnO1xuY29uc3QgU1RBVF9RVUVVRURfUkVRVUVTVFMgPSAnUXVldWVkIFJlcXVlc3RzJztcbmNvbnN0IFNUQVRfQUNUSVZFX1JFUVVFU1RTID0gJ0FjdGl2ZSBSZXF1ZXN0cyc7XG5jb25zdCBTVEFUX0NBTkNFTExFRF9SRVFVRVNUUyA9ICdDYW5jZWxsZWQgUmVxdWVzdHMnO1xuY29uc3QgU1RBVF9RVUVVRURfUkVRVUVTVFNfRVZFUiA9ICdRdWV1ZWQgUmVxdWVzdHMgRXZlcic7XG5jb25zdCBTVEFUX0FDVElWRV9SRVFVRVNUU19FVkVSID0gJ0FjdGl2ZSBSZXF1ZXN0cyBFdmVyJztcbmNvbnN0IERFRkFVTFRfUFJPUFMgPSB7XG4gIGlkOiAncmVxdWVzdC1zY2hlZHVsZXInLFxuICB0aHJvdHRsZVJlcXVlc3RzOiB0cnVlLFxuICBtYXhSZXF1ZXN0czogNlxufTtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgUmVxdWVzdFNjaGVkdWxlciB7XG5cbiAgY29uc3RydWN0b3IoKSB7XG4gICAgbGV0IHByb3BzID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fTtcbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJwcm9wc1wiLCB2b2lkIDApO1xuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInN0YXRzXCIsIHZvaWQgMCk7XG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwiYWN0aXZlUmVxdWVzdENvdW50XCIsIDApO1xuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInJlcXVlc3RRdWV1ZVwiLCBbXSk7XG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwicmVxdWVzdE1hcFwiLCBuZXcgTWFwKCkpO1xuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImRlZmVycmVkVXBkYXRlXCIsIG51bGwpO1xuICAgIHRoaXMucHJvcHMgPSB7XG4gICAgICAuLi5ERUZBVUxUX1BST1BTLFxuICAgICAgLi4ucHJvcHNcbiAgICB9O1xuXG4gICAgdGhpcy5zdGF0cyA9IG5ldyBTdGF0cyh7XG4gICAgICBpZDogdGhpcy5wcm9wcy5pZFxuICAgIH0pO1xuICAgIHRoaXMuc3RhdHMuZ2V0KFNUQVRfUVVFVUVEX1JFUVVFU1RTKTtcbiAgICB0aGlzLnN0YXRzLmdldChTVEFUX0FDVElWRV9SRVFVRVNUUyk7XG4gICAgdGhpcy5zdGF0cy5nZXQoU1RBVF9DQU5DRUxMRURfUkVRVUVTVFMpO1xuICAgIHRoaXMuc3RhdHMuZ2V0KFNUQVRfUVVFVUVEX1JFUVVFU1RTX0VWRVIpO1xuICAgIHRoaXMuc3RhdHMuZ2V0KFNUQVRfQUNUSVZFX1JFUVVFU1RTX0VWRVIpO1xuICB9XG5cbiAgc2NoZWR1bGVSZXF1ZXN0KGhhbmRsZSkge1xuICAgIGxldCBnZXRQcmlvcml0eSA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogKCkgPT4gMDtcbiAgICBpZiAoIXRoaXMucHJvcHMudGhyb3R0bGVSZXF1ZXN0cykge1xuICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh7XG4gICAgICAgIGRvbmU6ICgpID0+IHt9XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5yZXF1ZXN0TWFwLmhhcyhoYW5kbGUpKSB7XG4gICAgICByZXR1cm4gdGhpcy5yZXF1ZXN0TWFwLmdldChoYW5kbGUpO1xuICAgIH1cbiAgICBjb25zdCByZXF1ZXN0ID0ge1xuICAgICAgaGFuZGxlLFxuICAgICAgcHJpb3JpdHk6IDAsXG4gICAgICBnZXRQcmlvcml0eVxuICAgIH07XG4gICAgY29uc3QgcHJvbWlzZSA9IG5ldyBQcm9taXNlKHJlc29sdmUgPT4ge1xuICAgICAgcmVxdWVzdC5yZXNvbHZlID0gcmVzb2x2ZTtcbiAgICAgIHJldHVybiByZXF1ZXN0O1xuICAgIH0pO1xuICAgIHRoaXMucmVxdWVzdFF1ZXVlLnB1c2gocmVxdWVzdCk7XG4gICAgdGhpcy5yZXF1ZXN0TWFwLnNldChoYW5kbGUsIHByb21pc2UpO1xuICAgIHRoaXMuX2lzc3VlTmV3UmVxdWVzdHMoKTtcbiAgICByZXR1cm4gcHJvbWlzZTtcbiAgfVxuXG4gIF9pc3N1ZVJlcXVlc3QocmVxdWVzdCkge1xuICAgIGNvbnN0IHtcbiAgICAgIGhhbmRsZSxcbiAgICAgIHJlc29sdmVcbiAgICB9ID0gcmVxdWVzdDtcbiAgICBsZXQgaXNEb25lID0gZmFsc2U7XG4gICAgY29uc3QgZG9uZSA9ICgpID0+IHtcbiAgICAgIGlmICghaXNEb25lKSB7XG4gICAgICAgIGlzRG9uZSA9IHRydWU7XG5cbiAgICAgICAgdGhpcy5yZXF1ZXN0TWFwLmRlbGV0ZShoYW5kbGUpO1xuICAgICAgICB0aGlzLmFjdGl2ZVJlcXVlc3RDb3VudC0tO1xuICAgICAgICB0aGlzLl9pc3N1ZU5ld1JlcXVlc3RzKCk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIHRoaXMuYWN0aXZlUmVxdWVzdENvdW50Kys7XG4gICAgcmV0dXJuIHJlc29sdmUgPyByZXNvbHZlKHtcbiAgICAgIGRvbmVcbiAgICB9KSA6IFByb21pc2UucmVzb2x2ZSh7XG4gICAgICBkb25lXG4gICAgfSk7XG4gIH1cblxuICBfaXNzdWVOZXdSZXF1ZXN0cygpIHtcbiAgICBpZiAoIXRoaXMuZGVmZXJyZWRVcGRhdGUpIHtcbiAgICAgIHRoaXMuZGVmZXJyZWRVcGRhdGUgPSBzZXRUaW1lb3V0KCgpID0+IHRoaXMuX2lzc3VlTmV3UmVxdWVzdHNBc3luYygpLCAwKTtcbiAgICB9XG4gIH1cblxuICBfaXNzdWVOZXdSZXF1ZXN0c0FzeW5jKCkge1xuICAgIHRoaXMuZGVmZXJyZWRVcGRhdGUgPSBudWxsO1xuICAgIGNvbnN0IGZyZWVTbG90cyA9IE1hdGgubWF4KHRoaXMucHJvcHMubWF4UmVxdWVzdHMgLSB0aGlzLmFjdGl2ZVJlcXVlc3RDb3VudCwgMCk7XG4gICAgaWYgKGZyZWVTbG90cyA9PT0gMCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLl91cGRhdGVBbGxSZXF1ZXN0cygpO1xuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBmcmVlU2xvdHM7ICsraSkge1xuICAgICAgY29uc3QgcmVxdWVzdCA9IHRoaXMucmVxdWVzdFF1ZXVlLnNoaWZ0KCk7XG4gICAgICBpZiAocmVxdWVzdCkge1xuICAgICAgICB0aGlzLl9pc3N1ZVJlcXVlc3QocmVxdWVzdCk7XG4gICAgICB9XG4gICAgfVxuXG4gIH1cblxuICBfdXBkYXRlQWxsUmVxdWVzdHMoKSB7XG4gICAgY29uc3QgcmVxdWVzdFF1ZXVlID0gdGhpcy5yZXF1ZXN0UXVldWU7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCByZXF1ZXN0UXVldWUubGVuZ3RoOyArK2kpIHtcbiAgICAgIGNvbnN0IHJlcXVlc3QgPSByZXF1ZXN0UXVldWVbaV07XG4gICAgICBpZiAoIXRoaXMuX3VwZGF0ZVJlcXVlc3QocmVxdWVzdCkpIHtcbiAgICAgICAgcmVxdWVzdFF1ZXVlLnNwbGljZShpLCAxKTtcbiAgICAgICAgdGhpcy5yZXF1ZXN0TWFwLmRlbGV0ZShyZXF1ZXN0LmhhbmRsZSk7XG4gICAgICAgIGktLTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXF1ZXN0UXVldWUuc29ydCgoYSwgYikgPT4gYS5wcmlvcml0eSAtIGIucHJpb3JpdHkpO1xuICB9XG5cbiAgX3VwZGF0ZVJlcXVlc3QocmVxdWVzdCkge1xuICAgIHJlcXVlc3QucHJpb3JpdHkgPSByZXF1ZXN0LmdldFByaW9yaXR5KHJlcXVlc3QuaGFuZGxlKTtcblxuICAgIGlmIChyZXF1ZXN0LnByaW9yaXR5IDwgMCkge1xuICAgICAgcmVxdWVzdC5yZXNvbHZlKG51bGwpO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cmVxdWVzdC1zY2hlZHVsZXIuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///78634\n')},96040:function(__unused_webpack_module,__webpack_exports__,__webpack_require__){eval("/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"h\": function() { return /* binding */ assert; }\n/* harmony export */ });\n\n\nfunction assert(condition, message) {\n  if (!condition) {\n    throw new Error(message || 'loaders.gl assertion failed.');\n  }\n}\n//# sourceMappingURL=assert.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiOTYwNDAuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFFTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly92dWUzLXdlYnBhY2s1Ly4vbm9kZV9tb2R1bGVzL0Bsb2FkZXJzLmdsL3dvcmtlci11dGlscy9kaXN0L2VzbS9saWIvZW52LXV0aWxzL2Fzc2VydC5qcz82NGFhIl0sInNvdXJjZXNDb250ZW50IjpbIlxuXG5leHBvcnQgZnVuY3Rpb24gYXNzZXJ0KGNvbmRpdGlvbiwgbWVzc2FnZSkge1xuICBpZiAoIWNvbmRpdGlvbikge1xuICAgIHRocm93IG5ldyBFcnJvcihtZXNzYWdlIHx8ICdsb2FkZXJzLmdsIGFzc2VydGlvbiBmYWlsZWQuJyk7XG4gIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWFzc2VydC5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///96040\n")},96013:function(__unused_webpack_module,__webpack_exports__,__webpack_require__){eval("/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"CO\": function() { return /* binding */ global_; },\n/* harmony export */   \"hJ\": function() { return /* binding */ isWorker; },\n/* harmony export */   \"jU\": function() { return /* binding */ isBrowser; },\n/* harmony export */   \"tq\": function() { return /* binding */ isMobile; }\n/* harmony export */ });\n/* unused harmony exports self, window, document, nodeVersion */\n\n\nconst globals = {\n  self: typeof self !== 'undefined' && self,\n  window: typeof window !== 'undefined' && window,\n  global: typeof __webpack_require__.g !== 'undefined' && __webpack_require__.g,\n  document: typeof document !== 'undefined' && document\n};\nconst self_ = globals.self || globals.window || globals.global || {};\nconst window_ = globals.window || globals.self || globals.global || {};\nconst global_ = globals.global || globals.self || globals.window || {};\nconst document_ = globals.document || {};\n\n\nconst isBrowser =\ntypeof process !== 'object' || String(process) !== '[object process]' || process.browser;\n\nconst isWorker = typeof importScripts === 'function';\n\nconst isMobile = typeof window !== 'undefined' && typeof window.orientation !== 'undefined';\n\nconst matches = typeof process !== 'undefined' && process.version && /v([0-9]*)/.exec(process.version);\n\nconst nodeVersion = matches && parseFloat(matches[1]) || 0;\n//# sourceMappingURL=globals.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiOTYwMTMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLHFCQUFNLG9CQUFvQixxQkFBTTtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDc0Y7O0FBRS9FO0FBQ1A7O0FBRU87O0FBRUE7O0FBRVA7O0FBRU87QUFDUCIsInNvdXJjZXMiOlsid2VicGFjazovL3Z1ZTMtd2VicGFjazUvLi9ub2RlX21vZHVsZXMvQGxvYWRlcnMuZ2wvd29ya2VyLXV0aWxzL2Rpc3QvZXNtL2xpYi9lbnYtdXRpbHMvZ2xvYmFscy5qcz9mODhlIl0sInNvdXJjZXNDb250ZW50IjpbIlxuXG5jb25zdCBnbG9iYWxzID0ge1xuICBzZWxmOiB0eXBlb2Ygc2VsZiAhPT0gJ3VuZGVmaW5lZCcgJiYgc2VsZixcbiAgd2luZG93OiB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB3aW5kb3csXG4gIGdsb2JhbDogdHlwZW9mIGdsb2JhbCAhPT0gJ3VuZGVmaW5lZCcgJiYgZ2xvYmFsLFxuICBkb2N1bWVudDogdHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJyAmJiBkb2N1bWVudFxufTtcbmNvbnN0IHNlbGZfID0gZ2xvYmFscy5zZWxmIHx8IGdsb2JhbHMud2luZG93IHx8IGdsb2JhbHMuZ2xvYmFsIHx8IHt9O1xuY29uc3Qgd2luZG93XyA9IGdsb2JhbHMud2luZG93IHx8IGdsb2JhbHMuc2VsZiB8fCBnbG9iYWxzLmdsb2JhbCB8fCB7fTtcbmNvbnN0IGdsb2JhbF8gPSBnbG9iYWxzLmdsb2JhbCB8fCBnbG9iYWxzLnNlbGYgfHwgZ2xvYmFscy53aW5kb3cgfHwge307XG5jb25zdCBkb2N1bWVudF8gPSBnbG9iYWxzLmRvY3VtZW50IHx8IHt9O1xuZXhwb3J0IHsgc2VsZl8gYXMgc2VsZiwgd2luZG93XyBhcyB3aW5kb3csIGdsb2JhbF8gYXMgZ2xvYmFsLCBkb2N1bWVudF8gYXMgZG9jdW1lbnQgfTtcblxuZXhwb3J0IGNvbnN0IGlzQnJvd3NlciA9XG50eXBlb2YgcHJvY2VzcyAhPT0gJ29iamVjdCcgfHwgU3RyaW5nKHByb2Nlc3MpICE9PSAnW29iamVjdCBwcm9jZXNzXScgfHwgcHJvY2Vzcy5icm93c2VyO1xuXG5leHBvcnQgY29uc3QgaXNXb3JrZXIgPSB0eXBlb2YgaW1wb3J0U2NyaXB0cyA9PT0gJ2Z1bmN0aW9uJztcblxuZXhwb3J0IGNvbnN0IGlzTW9iaWxlID0gdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIHdpbmRvdy5vcmllbnRhdGlvbiAhPT0gJ3VuZGVmaW5lZCc7XG5cbmNvbnN0IG1hdGNoZXMgPSB0eXBlb2YgcHJvY2VzcyAhPT0gJ3VuZGVmaW5lZCcgJiYgcHJvY2Vzcy52ZXJzaW9uICYmIC92KFswLTldKikvLmV4ZWMocHJvY2Vzcy52ZXJzaW9uKTtcblxuZXhwb3J0IGNvbnN0IG5vZGVWZXJzaW9uID0gbWF0Y2hlcyAmJiBwYXJzZUZsb2F0KG1hdGNoZXNbMV0pIHx8IDA7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1nbG9iYWxzLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///96013\n")}}]);